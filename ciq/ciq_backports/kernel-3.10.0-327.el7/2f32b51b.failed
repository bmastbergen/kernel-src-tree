xfrm: Introduce xfrm_input_afinfo to access the the callbacks properly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit 2f32b51b609faea1e40bb8c5bd305f1351740936
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2f32b51b.failed

IPv6 can be build as a module, so we need mechanism to access
the address family dependent callback functions properly.
Therefore we introduce xfrm_input_afinfo, similar to that
what we have for the address family dependent part of
policies and states.

	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 2f32b51b609faea1e40bb8c5bd305f1351740936)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/xfrm.h
diff --cc include/net/xfrm.h
index 5211203ed953,af13599b60a0..000000000000
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@@ -344,12 -341,25 +344,26 @@@ struct xfrm_state_afinfo 
  						  struct sk_buff *skb);
  	int			(*transport_finish)(struct sk_buff *skb,
  						    int async);
 -	void			(*local_error)(struct sk_buff *skb, u32 mtu);
  };
  
 -int xfrm_state_register_afinfo(struct xfrm_state_afinfo *afinfo);
 -int xfrm_state_unregister_afinfo(struct xfrm_state_afinfo *afinfo);
 -struct xfrm_state_afinfo *xfrm_state_get_afinfo(unsigned int family);
 -void xfrm_state_put_afinfo(struct xfrm_state_afinfo *afinfo);
 +extern int xfrm_state_register_afinfo(struct xfrm_state_afinfo *afinfo);
 +extern int xfrm_state_unregister_afinfo(struct xfrm_state_afinfo *afinfo);
  
++<<<<<<< HEAD
 +extern void xfrm_state_delete_tunnel(struct xfrm_state *x);
++=======
+ struct xfrm_input_afinfo {
+ 	unsigned int		family;
+ 	struct module		*owner;
+ 	int			(*callback)(struct sk_buff *skb, u8 protocol,
+ 					    int err);
+ };
+ 
+ int xfrm_input_register_afinfo(struct xfrm_input_afinfo *afinfo);
+ int xfrm_input_unregister_afinfo(struct xfrm_input_afinfo *afinfo);
+ 
+ void xfrm_state_delete_tunnel(struct xfrm_state *x);
++>>>>>>> 2f32b51b609f (xfrm: Introduce xfrm_input_afinfo to access the the callbacks properly)
  
  struct xfrm_type {
  	char			*description;
@@@ -1386,16 -1397,17 +1400,25 @@@ struct xfrm6_tunnel 
  	int priority;
  };
  
++<<<<<<< HEAD
 +extern void xfrm_init(void);
 +extern void xfrm4_init(void);
 +extern int xfrm_state_init(struct net *net);
 +extern void xfrm_state_fini(struct net *net);
 +extern void xfrm4_state_init(void);
++=======
+ void xfrm_init(void);
+ void xfrm4_init(void);
+ int xfrm_state_init(struct net *net);
+ void xfrm_state_fini(struct net *net);
+ void xfrm4_state_init(void);
+ void xfrm4_protocol_init(void);
++>>>>>>> 2f32b51b609f (xfrm: Introduce xfrm_input_afinfo to access the the callbacks properly)
  #ifdef CONFIG_XFRM
 -int xfrm6_init(void);
 -void xfrm6_fini(void);
 -int xfrm6_state_init(void);
 -void xfrm6_state_fini(void);
 +extern int xfrm6_init(void);
 +extern void xfrm6_fini(void);
 +extern int xfrm6_state_init(void);
 +extern void xfrm6_state_fini(void);
  #else
  static inline int xfrm6_init(void)
  {
* Unmerged path include/net/xfrm.h
diff --git a/net/ipv4/xfrm4_policy.c b/net/ipv4/xfrm4_policy.c
index 9a459be24af7..58b9b090b130 100644
--- a/net/ipv4/xfrm4_policy.c
+++ b/net/ipv4/xfrm4_policy.c
@@ -320,6 +320,7 @@ void __init xfrm4_init(void)
 
 	xfrm4_state_init();
 	xfrm4_policy_init();
+	xfrm4_protocol_init();
 #ifdef CONFIG_SYSCTL
 	register_pernet_subsys(&xfrm4_net_ops);
 #endif
diff --git a/net/ipv4/xfrm4_protocol.c b/net/ipv4/xfrm4_protocol.c
index 42e26e12c165..dccefa9d84cf 100644
--- a/net/ipv4/xfrm4_protocol.c
+++ b/net/ipv4/xfrm4_protocol.c
@@ -188,6 +188,12 @@ static const struct net_protocol ipcomp4_protocol = {
 	.netns_ok	=	1,
 };
 
+static struct xfrm_input_afinfo xfrm4_input_afinfo = {
+	.family		=	AF_INET,
+	.owner		=	THIS_MODULE,
+	.callback	=	xfrm4_rcv_cb,
+};
+
 static inline const struct net_protocol *netproto(unsigned char protocol)
 {
 	switch (protocol) {
@@ -208,7 +214,6 @@ int xfrm4_protocol_register(struct xfrm4_protocol *handler,
 	struct xfrm4_protocol __rcu **pprev;
 	struct xfrm4_protocol *t;
 	bool add_netproto = false;
-
 	int ret = -EEXIST;
 	int priority = handler->priority;
 
@@ -288,3 +293,9 @@ int xfrm4_protocol_deregister(struct xfrm4_protocol *handler,
 	return ret;
 }
 EXPORT_SYMBOL(xfrm4_protocol_deregister);
+
+void __init xfrm4_protocol_init(void)
+{
+	xfrm_input_register_afinfo(&xfrm4_input_afinfo);
+}
+EXPORT_SYMBOL(xfrm4_protocol_init);
diff --git a/net/xfrm/xfrm_input.c b/net/xfrm/xfrm_input.c
index 737d6094995a..f7dbe6a1d80a 100644
--- a/net/xfrm/xfrm_input.c
+++ b/net/xfrm/xfrm_input.c
@@ -16,6 +16,81 @@
 
 static struct kmem_cache *secpath_cachep __read_mostly;
 
+static DEFINE_SPINLOCK(xfrm_input_afinfo_lock);
+static struct xfrm_input_afinfo __rcu *xfrm_input_afinfo[NPROTO];
+
+int xfrm_input_register_afinfo(struct xfrm_input_afinfo *afinfo)
+{
+	int err = 0;
+
+	if (unlikely(afinfo == NULL))
+		return -EINVAL;
+	if (unlikely(afinfo->family >= NPROTO))
+		return -EAFNOSUPPORT;
+	spin_lock_bh(&xfrm_input_afinfo_lock);
+	if (unlikely(xfrm_input_afinfo[afinfo->family] != NULL))
+		err = -ENOBUFS;
+	else
+		rcu_assign_pointer(xfrm_input_afinfo[afinfo->family], afinfo);
+	spin_unlock_bh(&xfrm_input_afinfo_lock);
+	return err;
+}
+EXPORT_SYMBOL(xfrm_input_register_afinfo);
+
+int xfrm_input_unregister_afinfo(struct xfrm_input_afinfo *afinfo)
+{
+	int err = 0;
+
+	if (unlikely(afinfo == NULL))
+		return -EINVAL;
+	if (unlikely(afinfo->family >= NPROTO))
+		return -EAFNOSUPPORT;
+	spin_lock_bh(&xfrm_input_afinfo_lock);
+	if (likely(xfrm_input_afinfo[afinfo->family] != NULL)) {
+		if (unlikely(xfrm_input_afinfo[afinfo->family] != afinfo))
+			err = -EINVAL;
+		else
+			RCU_INIT_POINTER(xfrm_input_afinfo[afinfo->family], NULL);
+	}
+	spin_unlock_bh(&xfrm_input_afinfo_lock);
+	synchronize_rcu();
+	return err;
+}
+EXPORT_SYMBOL(xfrm_input_unregister_afinfo);
+
+static struct xfrm_input_afinfo *xfrm_input_get_afinfo(unsigned int family)
+{
+	struct xfrm_input_afinfo *afinfo;
+
+	if (unlikely(family >= NPROTO))
+		return NULL;
+	rcu_read_lock();
+	afinfo = rcu_dereference(xfrm_input_afinfo[family]);
+	if (unlikely(!afinfo))
+		rcu_read_unlock();
+	return afinfo;
+}
+
+static void xfrm_input_put_afinfo(struct xfrm_input_afinfo *afinfo)
+{
+	rcu_read_unlock();
+}
+
+static int xfrm_rcv_cb(struct sk_buff *skb, unsigned int family, u8 protocol,
+		       int err)
+{
+	int ret;
+	struct xfrm_input_afinfo *afinfo = xfrm_input_get_afinfo(family);
+
+	if (!afinfo)
+		return -EAFNOSUPPORT;
+
+	ret = afinfo->callback(skb, protocol, err);
+	xfrm_input_put_afinfo(afinfo);
+
+	return ret;
+}
+
 void __secpath_destroy(struct sec_path *sp)
 {
 	int i;
