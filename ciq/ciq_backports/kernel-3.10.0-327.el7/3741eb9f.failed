perf tools: allow user to specify hardware breakpoint bp_len

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [perf] tools: allow user to specify hardware breakpoint bp_len (Jiri Olsa) [1209607]
Rebuild_FUZZ: 95.65%
commit-author Jacob Shin <jacob.w.shin@gmail.com>
commit 3741eb9f8c3be3ec59583881c1f49980dad844e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3741eb9f.failed

Currently bp_len is given a default value of 4. Allow user to override it:

  $ perf stat -e mem:0x1000/8
                            ^
                            bp_len

If no value is given, it will default to 4 as it did before.

	Signed-off-by: Jacob Shin <jacob.w.shin@gmail.com>
	Signed-off-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Reviewed-by: Oleg Nesterov <oleg@redhat.com>
	Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: xiakaixu <xiakaixu@huawei.com>
	Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
(cherry picked from commit 3741eb9f8c3be3ec59583881c1f49980dad844e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Documentation/perf-record.txt
diff --cc tools/perf/Documentation/perf-record.txt
index 7d8df2e5edd8,81a20f21a3e6..000000000000
--- a/tools/perf/Documentation/perf-record.txt
+++ b/tools/perf/Documentation/perf-record.txt
@@@ -33,24 -33,15 +33,31 @@@ OPTION
          - a raw PMU event (eventsel+umask) in the form of rNNN where NNN is a
  	  hexadecimal event descriptor.
  
++<<<<<<< HEAD
 +	- a symbolically formed PMU event like 'pmu/param1=0x3,param2/' where
 +	  'param1', 'param2', etc are defined as formats for the PMU in
 +	  /sys/bus/event_sources/devices/<pmu>/format/*.
 +
 +	- a symbolically formed event like 'pmu/config=M,config1=N,config3=K/'
 +
 +          where M, N, K are numbers (in decimal, hex, octal format). Acceptable
 +          values for each of 'config', 'config1' and 'config2' are defined by
 +          corresponding entries in /sys/bus/event_sources/devices/<pmu>/format/*
 +          param1 and param2 are defined as formats for the PMU in:
 +          /sys/bus/event_sources/devices/<pmu>/format/*
 +
 +        - a hardware breakpoint event in the form of '\mem:addr[:access]'
++=======
+         - a hardware breakpoint event in the form of '\mem:addr[/len][:access]'
++>>>>>>> 3741eb9f8c3b (perf tools: allow user to specify hardware breakpoint bp_len)
            where addr is the address in memory you want to break in.
            Access is the memory access type (read, write, execute) it can
-           be passed as follows: '\mem:addr[:[r][w][x]]'.
+           be passed as follows: '\mem:addr[:[r][w][x]]'. len is the range,
+           number of bytes from specified addr, which the breakpoint will cover.
            If you want to profile read-write accesses in 0x1000, just set
            'mem:0x1000:rw'.
+           If you want to profile write accesses in [0x1000~1008), just set
+           'mem:0x1000/8:w'.
  
  --filter=<filter>::
          Event filter.
* Unmerged path tools/perf/Documentation/perf-record.txt
diff --git a/tools/perf/util/parse-events.c b/tools/perf/util/parse-events.c
index f36b80ecaf52..7f8ec6ce2823 100644
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@ -526,7 +526,7 @@ do {					\
 }
 
 int parse_events_add_breakpoint(struct list_head *list, int *idx,
-				void *ptr, char *type)
+				void *ptr, char *type, u64 len)
 {
 	struct perf_event_attr attr;
 
@@ -536,14 +536,15 @@ int parse_events_add_breakpoint(struct list_head *list, int *idx,
 	if (parse_breakpoint_type(type, &attr))
 		return -EINVAL;
 
-	/*
-	 * We should find a nice way to override the access length
-	 * Provide some defaults for now
-	 */
-	if (attr.bp_type == HW_BREAKPOINT_X)
-		attr.bp_len = sizeof(long);
-	else
-		attr.bp_len = HW_BREAKPOINT_LEN_4;
+	/* Provide some defaults if len is not specified */
+	if (!len) {
+		if (attr.bp_type == HW_BREAKPOINT_X)
+			len = sizeof(long);
+		else
+			len = HW_BREAKPOINT_LEN_4;
+	}
+
+	attr.bp_len = len;
 
 	attr.type = PERF_TYPE_BREAKPOINT;
 	attr.sample_period = 1;
@@ -1366,7 +1367,7 @@ void print_events(const char *event_glob, bool name_only)
 		printf("\n");
 
 		printf("  %-50s [%s]\n",
-		       "mem:<addr>[:access]",
+		       "mem:<addr>[/len][:access]",
 			event_type_descriptors[PERF_TYPE_BREAKPOINT]);
 		printf("\n");
 	}
diff --git a/tools/perf/util/parse-events.h b/tools/perf/util/parse-events.h
index ca226cef8460..ff6e1fa4111e 100644
--- a/tools/perf/util/parse-events.h
+++ b/tools/perf/util/parse-events.h
@@ -105,7 +105,7 @@ int parse_events_add_numeric(struct list_head *list, int *idx,
 int parse_events_add_cache(struct list_head *list, int *idx,
 			   char *type, char *op_result1, char *op_result2);
 int parse_events_add_breakpoint(struct list_head *list, int *idx,
-				void *ptr, char *type);
+				void *ptr, char *type, u64 len);
 int parse_events_add_pmu(struct list_head *list, int *idx,
 			 char *pmu , struct list_head *head_config);
 enum perf_pmu_event_symbol_type
diff --git a/tools/perf/util/parse-events.l b/tools/perf/util/parse-events.l
index 906630bbf8eb..94eacb6c1ef7 100644
--- a/tools/perf/util/parse-events.l
+++ b/tools/perf/util/parse-events.l
@@ -159,6 +159,7 @@ branch_type		{ return term(yyscanner, PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE
 <mem>{
 {modifier_bp}		{ return str(yyscanner, PE_MODIFIER_BP); }
 :			{ return ':'; }
+"/"			{ return '/'; }
 {num_dec}		{ return value(yyscanner, 10); }
 {num_hex}		{ return value(yyscanner, 16); }
 	/*
diff --git a/tools/perf/util/parse-events.y b/tools/perf/util/parse-events.y
index 93c4c9fbc922..72def077dbbf 100644
--- a/tools/perf/util/parse-events.y
+++ b/tools/perf/util/parse-events.y
@@ -326,6 +326,28 @@ PE_NAME_CACHE_TYPE
 }
 
 event_legacy_mem:
+PE_PREFIX_MEM PE_VALUE '/' PE_VALUE ':' PE_MODIFIER_BP sep_dc
+{
+	struct parse_events_evlist *data = _data;
+	struct list_head *list;
+
+	ALLOC_LIST(list);
+	ABORT_ON(parse_events_add_breakpoint(list, &data->idx,
+					     (void *) $2, $6, $4));
+	$$ = list;
+}
+|
+PE_PREFIX_MEM PE_VALUE '/' PE_VALUE sep_dc
+{
+	struct parse_events_evlist *data = _data;
+	struct list_head *list;
+
+	ALLOC_LIST(list);
+	ABORT_ON(parse_events_add_breakpoint(list, &data->idx,
+					     (void *) $2, NULL, $4));
+	$$ = list;
+}
+|
 PE_PREFIX_MEM PE_VALUE ':' PE_MODIFIER_BP sep_dc
 {
 	struct parse_events_evlist *data = _data;
@@ -333,7 +355,7 @@ PE_PREFIX_MEM PE_VALUE ':' PE_MODIFIER_BP sep_dc
 
 	ALLOC_LIST(list);
 	ABORT_ON(parse_events_add_breakpoint(list, &data->idx,
-					     (void *) $2, $4));
+					     (void *) $2, $4, 0));
 	$$ = list;
 }
 |
@@ -344,7 +366,7 @@ PE_PREFIX_MEM PE_VALUE sep_dc
 
 	ALLOC_LIST(list);
 	ABORT_ON(parse_events_add_breakpoint(list, &data->idx,
-					     (void *) $2, NULL));
+					     (void *) $2, NULL, 0));
 	$$ = list;
 }
 
