xfs: move node entry counts to xfs_da_geometry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 7ab610f9e0f1701b7b319bdc946b9804fb79e780
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7ab610f9.failed

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 7ab610f9e0f1701b7b319bdc946b9804fb79e780)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_dir2.c
#	fs/xfs/xfs_dir2_node.c
diff --cc fs/xfs/xfs_dir2.c
index 94787d4498db,97f1802a9018..000000000000
--- a/fs/xfs/xfs_dir2.c
+++ b/fs/xfs/xfs_dir2.c
@@@ -139,14 -144,6 +139,17 @@@ xfs_da_mount
  	else
  		mp->m_dirnameops = &xfs_default_nameops;
  
++<<<<<<< HEAD
 +	/* XXX: these are to be removed as code is converted to use geo */
 +	mp->m_dirblksize = mp->m_dir_geo->blksize;
 +	mp->m_dirblkfsbs = mp->m_dir_geo->fsbcount;
 +	mp->m_dirdatablk = mp->m_dir_geo->datablk;
 +	mp->m_dirleafblk = mp->m_dir_geo->leafblk;
 +	mp->m_dirfreeblk = mp->m_dir_geo->freeblk;
 +	mp->m_dir_node_ents = mp->m_dir_geo->node_ents;
 +	mp->m_attr_node_ents = mp->m_attr_geo->node_ents;
++=======
++>>>>>>> 7ab610f9e0f1 (xfs: move node entry counts to xfs_da_geometry)
  	return 0;
  }
  
diff --cc fs/xfs/xfs_dir2_node.c
index 697fc13c6486,eff6b8d67dab..000000000000
--- a/fs/xfs/xfs_dir2_node.c
+++ b/fs/xfs/xfs_dir2_node.c
@@@ -1587,8 -1596,8 +1587,13 @@@ xfs_dir2_node_addname
  	state = xfs_da_state_alloc();
  	state->args = args;
  	state->mp = args->dp->i_mount;
++<<<<<<< HEAD
 +	state->blocksize = state->mp->m_dirblksize;
 +	state->node_ents = state->mp->m_dir_node_ents;
++=======
+ 	state->blocksize = args->geo->blksize;
+ 	state->node_ents = args->geo->node_ents;
++>>>>>>> 7ab610f9e0f1 (xfs: move node entry counts to xfs_da_geometry)
  	/*
  	 * Look up the name.  We're not supposed to find it, but
  	 * this gives us the insertion point.
@@@ -2031,8 -2042,8 +2036,13 @@@ xfs_dir2_node_lookup
  	state = xfs_da_state_alloc();
  	state->args = args;
  	state->mp = args->dp->i_mount;
++<<<<<<< HEAD
 +	state->blocksize = state->mp->m_dirblksize;
 +	state->node_ents = state->mp->m_dir_node_ents;
++=======
+ 	state->blocksize = args->geo->blksize;
+ 	state->node_ents = args->geo->node_ents;
++>>>>>>> 7ab610f9e0f1 (xfs: move node entry counts to xfs_da_geometry)
  	/*
  	 * Fill in the path to the entry in the cursor.
  	 */
@@@ -2086,8 -2097,8 +2096,13 @@@ xfs_dir2_node_removename
  	state = xfs_da_state_alloc();
  	state->args = args;
  	state->mp = args->dp->i_mount;
++<<<<<<< HEAD
 +	state->blocksize = state->mp->m_dirblksize;
 +	state->node_ents = state->mp->m_dir_node_ents;
++=======
+ 	state->blocksize = args->geo->blksize;
+ 	state->node_ents = args->geo->node_ents;
++>>>>>>> 7ab610f9e0f1 (xfs: move node entry counts to xfs_da_geometry)
  
  	/* Look up the entry we're deleting, set up the cursor. */
  	error = xfs_da3_node_lookup_int(state, &rval);
@@@ -2156,8 -2167,8 +2171,13 @@@ xfs_dir2_node_replace
  	state = xfs_da_state_alloc();
  	state->args = args;
  	state->mp = args->dp->i_mount;
++<<<<<<< HEAD
 +	state->blocksize = state->mp->m_dirblksize;
 +	state->node_ents = state->mp->m_dir_node_ents;
++=======
+ 	state->blocksize = args->geo->blksize;
+ 	state->node_ents = args->geo->node_ents;
++>>>>>>> 7ab610f9e0f1 (xfs: move node entry counts to xfs_da_geometry)
  	inum = args->inumber;
  	/*
  	 * Lookup the entry to change in the btree.
diff --git a/fs/xfs/xfs_attr.c b/fs/xfs/xfs_attr.c
index f3b9670979f5..8fe28c1ca685 100644
--- a/fs/xfs/xfs_attr.c
+++ b/fs/xfs/xfs_attr.c
@@ -903,7 +903,7 @@ restart:
 	state->args = args;
 	state->mp = mp;
 	state->blocksize = state->mp->m_sb.sb_blocksize;
-	state->node_ents = state->mp->m_attr_node_ents;
+	state->node_ents = args->geo->node_ents;
 
 	/*
 	 * Search to see if name already exists, and get back a pointer
@@ -1082,7 +1082,7 @@ restart:
 		state->args = args;
 		state->mp = mp;
 		state->blocksize = state->mp->m_sb.sb_blocksize;
-		state->node_ents = state->mp->m_attr_node_ents;
+		state->node_ents = args->geo->node_ents;
 		state->inleaf = 0;
 		error = xfs_da3_node_lookup_int(state, &retval);
 		if (error)
@@ -1174,7 +1174,7 @@ xfs_attr_node_removename(xfs_da_args_t *args)
 	state->args = args;
 	state->mp = dp->i_mount;
 	state->blocksize = state->mp->m_sb.sb_blocksize;
-	state->node_ents = state->mp->m_attr_node_ents;
+	state->node_ents = args->geo->node_ents;
 
 	/*
 	 * Search to see if name exists, and get back a pointer to it.
@@ -1437,7 +1437,7 @@ xfs_attr_node_get(xfs_da_args_t *args)
 	state->args = args;
 	state->mp = args->dp->i_mount;
 	state->blocksize = state->mp->m_sb.sb_blocksize;
-	state->node_ents = state->mp->m_attr_node_ents;
+	state->node_ents = args->geo->node_ents;
 
 	/*
 	 * Search to see if name exists, and get back a pointer to it.
diff --git a/fs/xfs/xfs_da_btree.c b/fs/xfs/xfs_da_btree.c
index 4db5102d403a..465547c16298 100644
--- a/fs/xfs/xfs_da_btree.c
+++ b/fs/xfs/xfs_da_btree.c
@@ -167,8 +167,8 @@ xfs_da3_node_verify(
 	 * we don't know if the node is for and attribute or directory tree,
 	 * so only fail if the count is outside both bounds
 	 */
-	if (ichdr.count > mp->m_dir_node_ents &&
-	    ichdr.count > mp->m_attr_node_ents)
+	if (ichdr.count > mp->m_dir_geo->node_ents &&
+	    ichdr.count > mp->m_attr_geo->node_ents)
 		return false;
 
 	/* XXX: hash order check? */
* Unmerged path fs/xfs/xfs_dir2.c
* Unmerged path fs/xfs/xfs_dir2_node.c
diff --git a/fs/xfs/xfs_mount.h b/fs/xfs/xfs_mount.h
index 19ca0489a94a..6dffe9b9aada 100644
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@ -134,8 +134,6 @@ typedef struct xfs_mount {
 	int			m_fixedfsid[2];	/* unchanged for life of FS */
 	uint			m_dmevmask;	/* DMI events for this FS */
 	__uint64_t		m_flags;	/* global mount flags */
-	uint			m_dir_node_ents; /* #entries in a dir danode */
-	uint			m_attr_node_ents; /* #entries in attr danode */
 	int			m_ialloc_inos;	/* inodes in inode allocation */
 	int			m_ialloc_blks;	/* blocks in inode allocation */
 	int			m_inoalign_mask;/* mask sb_inoalignmt if used */
