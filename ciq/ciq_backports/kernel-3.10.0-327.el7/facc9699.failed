net/mlx5e: Fix HW MTU settings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx5e: Fix HW MTU settings (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 92.86%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit facc9699f0fe7d65a92cc09e175662659306066d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/facc9699.failed

Previously we configured HW MTU to be netdev->mtu, actually we
need to configure netdev->mtu + (ETH_HLEN + VLAN_HLEN + ETH_FCS_LEN).

Also, query MTU can not fail, hence make the relevant helper a
void functionm, add mlx5e_set_dev_port_mtu, helper function to
handle MTU setting.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit facc9699f0fe7d65a92cc09e175662659306066d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
#	drivers/net/ethernet/mellanox/mlx5/core/port.c
#	include/linux/mlx5/driver.h
diff --cc drivers/infiniband/hw/mlx5/main.c
index 86005fa8c936,79dadd627e9c..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -161,10 -295,173 +161,178 @@@ static int mlx5_ib_query_device(struct 
  	props->odp_caps = dev->odp_caps;
  #endif
  
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ enum mlx5_ib_width {
+ 	MLX5_IB_WIDTH_1X	= 1 << 0,
+ 	MLX5_IB_WIDTH_2X	= 1 << 1,
+ 	MLX5_IB_WIDTH_4X	= 1 << 2,
+ 	MLX5_IB_WIDTH_8X	= 1 << 3,
+ 	MLX5_IB_WIDTH_12X	= 1 << 4
+ };
+ 
+ static int translate_active_width(struct ib_device *ibdev, u8 active_width,
+ 				  u8 *ib_width)
+ {
+ 	struct mlx5_ib_dev *dev = to_mdev(ibdev);
+ 	int err = 0;
+ 
+ 	if (active_width & MLX5_IB_WIDTH_1X) {
+ 		*ib_width = IB_WIDTH_1X;
+ 	} else if (active_width & MLX5_IB_WIDTH_2X) {
+ 		mlx5_ib_dbg(dev, "active_width %d is not supported by IB spec\n",
+ 			    (int)active_width);
+ 		err = -EINVAL;
+ 	} else if (active_width & MLX5_IB_WIDTH_4X) {
+ 		*ib_width = IB_WIDTH_4X;
+ 	} else if (active_width & MLX5_IB_WIDTH_8X) {
+ 		*ib_width = IB_WIDTH_8X;
+ 	} else if (active_width & MLX5_IB_WIDTH_12X) {
+ 		*ib_width = IB_WIDTH_12X;
+ 	} else {
+ 		mlx5_ib_dbg(dev, "Invalid active_width %d\n",
+ 			    (int)active_width);
+ 		err = -EINVAL;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static int mlx5_mtu_to_ib_mtu(int mtu)
+ {
+ 	switch (mtu) {
+ 	case 256: return 1;
+ 	case 512: return 2;
+ 	case 1024: return 3;
+ 	case 2048: return 4;
+ 	case 4096: return 5;
+ 	default:
+ 		pr_warn("invalid mtu\n");
+ 		return -1;
+ 	}
+ }
+ 
+ enum ib_max_vl_num {
+ 	__IB_MAX_VL_0		= 1,
+ 	__IB_MAX_VL_0_1		= 2,
+ 	__IB_MAX_VL_0_3		= 3,
+ 	__IB_MAX_VL_0_7		= 4,
+ 	__IB_MAX_VL_0_14	= 5,
+ };
+ 
+ enum mlx5_vl_hw_cap {
+ 	MLX5_VL_HW_0	= 1,
+ 	MLX5_VL_HW_0_1	= 2,
+ 	MLX5_VL_HW_0_2	= 3,
+ 	MLX5_VL_HW_0_3	= 4,
+ 	MLX5_VL_HW_0_4	= 5,
+ 	MLX5_VL_HW_0_5	= 6,
+ 	MLX5_VL_HW_0_6	= 7,
+ 	MLX5_VL_HW_0_7	= 8,
+ 	MLX5_VL_HW_0_14	= 15
+ };
+ 
+ static int translate_max_vl_num(struct ib_device *ibdev, u8 vl_hw_cap,
+ 				u8 *max_vl_num)
+ {
+ 	switch (vl_hw_cap) {
+ 	case MLX5_VL_HW_0:
+ 		*max_vl_num = __IB_MAX_VL_0;
+ 		break;
+ 	case MLX5_VL_HW_0_1:
+ 		*max_vl_num = __IB_MAX_VL_0_1;
+ 		break;
+ 	case MLX5_VL_HW_0_3:
+ 		*max_vl_num = __IB_MAX_VL_0_3;
+ 		break;
+ 	case MLX5_VL_HW_0_7:
+ 		*max_vl_num = __IB_MAX_VL_0_7;
+ 		break;
+ 	case MLX5_VL_HW_0_14:
+ 		*max_vl_num = __IB_MAX_VL_0_14;
+ 		break;
+ 
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx5_query_hca_port(struct ib_device *ibdev, u8 port,
+ 			       struct ib_port_attr *props)
+ {
+ 	struct mlx5_ib_dev *dev = to_mdev(ibdev);
+ 	struct mlx5_core_dev *mdev = dev->mdev;
+ 	struct mlx5_hca_vport_context *rep;
+ 	int max_mtu;
+ 	int oper_mtu;
+ 	int err;
+ 	u8 ib_link_width_oper;
+ 	u8 vl_hw_cap;
+ 
+ 	rep = kzalloc(sizeof(*rep), GFP_KERNEL);
+ 	if (!rep) {
+ 		err = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	memset(props, 0, sizeof(*props));
+ 
+ 	err = mlx5_query_hca_vport_context(mdev, 0, port, 0, rep);
+ 	if (err)
+ 		goto out;
+ 
+ 	props->lid		= rep->lid;
+ 	props->lmc		= rep->lmc;
+ 	props->sm_lid		= rep->sm_lid;
+ 	props->sm_sl		= rep->sm_sl;
+ 	props->state		= rep->vport_state;
+ 	props->phys_state	= rep->port_physical_state;
+ 	props->port_cap_flags	= rep->cap_mask1;
+ 	props->gid_tbl_len	= mlx5_get_gid_table_len(MLX5_CAP_GEN(mdev, gid_table_size));
+ 	props->max_msg_sz	= 1 << MLX5_CAP_GEN(mdev, log_max_msg);
+ 	props->pkey_tbl_len	= mlx5_to_sw_pkey_sz(MLX5_CAP_GEN(mdev, pkey_table_size));
+ 	props->bad_pkey_cntr	= rep->pkey_violation_counter;
+ 	props->qkey_viol_cntr	= rep->qkey_violation_counter;
+ 	props->subnet_timeout	= rep->subnet_timeout;
+ 	props->init_type_reply	= rep->init_type_reply;
+ 
+ 	err = mlx5_query_port_link_width_oper(mdev, &ib_link_width_oper, port);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = translate_active_width(ibdev, ib_link_width_oper,
+ 				     &props->active_width);
+ 	if (err)
+ 		goto out;
+ 	err = mlx5_query_port_proto_oper(mdev, &props->active_speed, MLX5_PTYS_IB,
+ 					 port);
+ 	if (err)
+ 		goto out;
+ 
+ 	mlx5_query_port_max_mtu(mdev, &max_mtu, port);
+ 
+ 	props->max_mtu = mlx5_mtu_to_ib_mtu(max_mtu);
+ 
+ 	mlx5_query_port_oper_mtu(mdev, &oper_mtu, port);
+ 
+ 	props->active_mtu = mlx5_mtu_to_ib_mtu(oper_mtu);
+ 
+ 	err = mlx5_query_port_vl_hw_cap(mdev, &vl_hw_cap, port);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = translate_max_vl_num(ibdev, vl_hw_cap,
+ 				   &props->max_vl_num);
++>>>>>>> facc9699f0fe (net/mlx5e: Fix HW MTU settings)
  out:
 -	kfree(rep);
 +	kfree(in_mad);
 +	kfree(out_mad);
 +
  	return err;
  }
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/port.c
index 7d3d0f9f328d,70147999f657..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/port.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/port.c
@@@ -212,21 -248,18 +212,27 @@@ int mlx5_query_port_status(struct mlx5_
  	return err;
  }
  
++<<<<<<< HEAD
 +static int mlx5_query_port_mtu(struct mlx5_core_dev *dev,
 +			       int *admin_mtu, int *max_mtu, int *oper_mtu)
++=======
+ static void mlx5_query_port_mtu(struct mlx5_core_dev *dev, int *admin_mtu,
+ 				int *max_mtu, int *oper_mtu, u8 port)
++>>>>>>> facc9699f0fe (net/mlx5e: Fix HW MTU settings)
  {
  	u32 in[MLX5_ST_SZ_DW(pmtu_reg)];
  	u32 out[MLX5_ST_SZ_DW(pmtu_reg)];
  
  	memset(in, 0, sizeof(in));
  
++<<<<<<< HEAD
 +	MLX5_SET(pmtu_reg, in, local_port, 1);
++=======
+ 	MLX5_SET(pmtu_reg, in, local_port, port);
++>>>>>>> facc9699f0fe (net/mlx5e: Fix HW MTU settings)
  
- 	err = mlx5_core_access_reg(dev, in, sizeof(in), out,
- 				   sizeof(out), MLX5_REG_PMTU, 0, 0);
- 	if (err)
- 		return err;
+ 	mlx5_core_access_reg(dev, in, sizeof(in), out,
+ 			     sizeof(out), MLX5_REG_PMTU, 0, 0);
  
  	if (max_mtu)
  		*max_mtu  = MLX5_GET(pmtu_reg, out, max_mtu);
@@@ -253,14 -284,47 +257,28 @@@ int mlx5_set_port_mtu(struct mlx5_core_
  }
  EXPORT_SYMBOL_GPL(mlx5_set_port_mtu);
  
++<<<<<<< HEAD
 +int mlx5_query_port_max_mtu(struct mlx5_core_dev *dev, int *max_mtu)
 +{
 +	return mlx5_query_port_mtu(dev, NULL, max_mtu, NULL);
 +}
 +EXPORT_SYMBOL_GPL(mlx5_query_port_max_mtu);
 +
 +int mlx5_query_port_oper_mtu(struct mlx5_core_dev *dev, int *oper_mtu)
 +{
 +	return mlx5_query_port_mtu(dev, NULL, NULL, oper_mtu);
++=======
+ void mlx5_query_port_max_mtu(struct mlx5_core_dev *dev, int *max_mtu,
+ 			     u8 port)
+ {
+ 	mlx5_query_port_mtu(dev, NULL, max_mtu, NULL, port);
+ }
+ EXPORT_SYMBOL_GPL(mlx5_query_port_max_mtu);
+ 
+ void mlx5_query_port_oper_mtu(struct mlx5_core_dev *dev, int *oper_mtu,
+ 			      u8 port)
+ {
+ 	mlx5_query_port_mtu(dev, NULL, NULL, oper_mtu, port);
++>>>>>>> facc9699f0fe (net/mlx5e: Fix HW MTU settings)
  }
  EXPORT_SYMBOL_GPL(mlx5_query_port_oper_mtu);
 -
 -static int mlx5_query_port_pvlc(struct mlx5_core_dev *dev, u32 *pvlc,
 -				int pvlc_size,  u8 local_port)
 -{
 -	u32 in[MLX5_ST_SZ_DW(pvlc_reg)];
 -	int err;
 -
 -	memset(in, 0, sizeof(in));
 -	MLX5_SET(ptys_reg, in, local_port, local_port);
 -
 -	err = mlx5_core_access_reg(dev, in, sizeof(in), pvlc,
 -				   pvlc_size, MLX5_REG_PVLC, 0, 0);
 -
 -	return err;
 -}
 -
 -int mlx5_query_port_vl_hw_cap(struct mlx5_core_dev *dev,
 -			      u8 *vl_hw_cap, u8 local_port)
 -{
 -	u32 out[MLX5_ST_SZ_DW(pvlc_reg)];
 -	int err;
 -
 -	err = mlx5_query_port_pvlc(dev, out, sizeof(out), local_port);
 -	if (err)
 -		return err;
 -
 -	*vl_hw_cap = MLX5_GET(pvlc_reg, out, vl_hw_cap);
 -
 -	return 0;
 -}
 -EXPORT_SYMBOL_GPL(mlx5_query_port_vl_hw_cap);
diff --cc include/linux/mlx5/driver.h
index ee45556daa8c,c0930f8d7021..000000000000
--- a/include/linux/mlx5/driver.h
+++ b/include/linux/mlx5/driver.h
@@@ -756,9 -756,13 +756,19 @@@ int mlx5_set_port_status(struct mlx5_co
  			 enum mlx5_port_status status);
  int mlx5_query_port_status(struct mlx5_core_dev *dev, u8 *status);
  
++<<<<<<< HEAD
 +int mlx5_set_port_mtu(struct mlx5_core_dev *dev, int mtu);
 +int mlx5_query_port_max_mtu(struct mlx5_core_dev *dev, int *max_mtu);
 +int mlx5_query_port_oper_mtu(struct mlx5_core_dev *dev, int *oper_mtu);
++=======
+ int mlx5_set_port_mtu(struct mlx5_core_dev *dev, int mtu, u8 port);
+ void mlx5_query_port_max_mtu(struct mlx5_core_dev *dev, int *max_mtu, u8 port);
+ void mlx5_query_port_oper_mtu(struct mlx5_core_dev *dev, int *oper_mtu,
+ 			      u8 port);
+ 
+ int mlx5_query_port_vl_hw_cap(struct mlx5_core_dev *dev,
+ 			      u8 *vl_hw_cap, u8 local_port);
++>>>>>>> facc9699f0fe (net/mlx5e: Fix HW MTU settings)
  
  int mlx5_debug_eq_add(struct mlx5_core_dev *dev, struct mlx5_eq *eq);
  void mlx5_debug_eq_remove(struct mlx5_core_dev *dev, struct mlx5_eq *eq);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/infiniband/hw/mlx5/main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/port.c
* Unmerged path include/linux/mlx5/driver.h
