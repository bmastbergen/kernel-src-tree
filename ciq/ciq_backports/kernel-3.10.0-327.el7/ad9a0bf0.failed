net/mlx4_core: Refactor the catas flow to work per device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4_core: Refactor the catas flow to work per device (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 96.36%
commit-author Yishai Hadas <yishaih@mellanox.com>
commit ad9a0bf08ffbf32b8f292c3bb78ca0f24bb8f6b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ad9a0bf0.failed

Using a WQ per device instead of a single global WQ, this allows
independent reset handling per device even when SRIOV is used.

This comes as a pre-patch for supporting chip reset
for both native and SRIOV.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ad9a0bf08ffbf32b8f292c3bb78ca0f24bb8f6b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/catas.c
#	include/linux/mlx4/device.h
diff --cc drivers/net/ethernet/mellanox/mlx4/catas.c
index 9c656fe4983d,5bb9aa6e281d..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/catas.c
+++ b/drivers/net/ethernet/mellanox/mlx4/catas.c
@@@ -92,33 -85,23 +85,50 @@@ static void poll_catas(unsigned long de
  
  static void catas_reset(struct work_struct *work)
  {
++<<<<<<< HEAD
 +	struct mlx4_priv *priv, *tmppriv;
 +	struct mlx4_dev *dev;
 +
 +	LIST_HEAD(tlist);
++=======
+ 	struct mlx4_dev_persistent *persist =
+ 		container_of(work, struct mlx4_dev_persistent,
+ 			     catas_work);
+ 	struct pci_dev *pdev = persist->pdev;
++>>>>>>> ad9a0bf08ffb (net/mlx4_core: Refactor the catas flow to work per device)
  	int ret;
  
- 	spin_lock_irq(&catas_lock);
- 	list_splice_init(&catas_list, &tlist);
- 	spin_unlock_irq(&catas_lock);
+ 	/* If the device is off-line, we cannot reset it */
+ 	if (pci_channel_offline(pdev))
+ 		return;
  
++<<<<<<< HEAD
 +	list_for_each_entry_safe(priv, tmppriv, &tlist, catas_err.list) {
 +		struct pci_dev *pdev = priv->dev.pdev;
 +
 +		/* If the device is off-line, we cannot reset it */
 +		if (pci_channel_offline(pdev))
 +			continue;
 +
 +		ret = mlx4_restart_one(priv->dev.pdev);
 +		/* 'priv' now is not valid */
 +		if (ret)
 +			pr_err("mlx4 %s: Reset failed (%d)\n",
 +			       pci_name(pdev), ret);
 +		else {
 +			dev  = pci_get_drvdata(pdev);
 +			mlx4_dbg(dev, "Reset succeeded\n");
 +		}
 +	}
++=======
+ 	ret = mlx4_restart_one(pdev);
+ 	/* 'priv' now is not valid */
+ 	if (ret)
+ 		pr_err("mlx4 %s: Reset failed (%d)\n",
+ 		       pci_name(pdev), ret);
+ 	else
+ 		mlx4_dbg(persist->dev, "Reset succeeded\n");
++>>>>>>> ad9a0bf08ffb (net/mlx4_core: Refactor the catas flow to work per device)
  }
  
  void mlx4_start_catas_poll(struct mlx4_dev *dev)
diff --cc include/linux/mlx4/device.h
index 04d2bbb20a34,da425d2f3708..000000000000
--- a/include/linux/mlx4/device.h
+++ b/include/linux/mlx4/device.h
@@@ -728,8 -744,19 +728,22 @@@ struct mlx4_vf_dev 
  	u8			n_ports;
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx4_dev_persistent {
+ 	struct pci_dev	       *pdev;
+ 	struct mlx4_dev	       *dev;
+ 	int                     nvfs[MLX4_MAX_PORTS + 1];
+ 	int			num_vfs;
+ 	enum mlx4_port_type curr_port_type[MLX4_MAX_PORTS + 1];
+ 	enum mlx4_port_type curr_port_poss_type[MLX4_MAX_PORTS + 1];
+ 	struct work_struct      catas_work;
+ 	struct workqueue_struct *catas_wq;
+ };
+ 
++>>>>>>> ad9a0bf08ffb (net/mlx4_core: Refactor the catas flow to work per device)
  struct mlx4_dev {
 -	struct mlx4_dev_persistent *persist;
 +	struct pci_dev	       *pdev;
  	unsigned long		flags;
  	unsigned long		num_slaves;
  	struct mlx4_caps	caps;
* Unmerged path drivers/net/ethernet/mellanox/mlx4/catas.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/main.c b/drivers/net/ethernet/mellanox/mlx4/main.c
index e21046536e8b..303b24f53759 100644
--- a/drivers/net/ethernet/mellanox/mlx4/main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/main.c
@@ -2805,11 +2805,19 @@ static int __mlx4_init_one(struct pci_dev *pdev, int pci_dev_data,
 		}
 	}
 
-	err = mlx4_load_one(pdev, pci_dev_data, total_vfs, nvfs, priv);
+	err = mlx4_catas_init(&priv->dev);
 	if (err)
 		goto err_release_regions;
+
+	err = mlx4_load_one(pdev, pci_dev_data, total_vfs, nvfs, priv);
+	if (err)
+		goto err_catas;
+
 	return 0;
 
+err_catas:
+	mlx4_catas_end(&priv->dev);
+
 err_release_regions:
 	pci_release_regions(pdev);
 
@@ -2935,6 +2943,7 @@ static void mlx4_remove_one(struct pci_dev *pdev)
 	struct mlx4_priv *priv = mlx4_priv(dev);
 
 	mlx4_unload_one(pdev);
+	mlx4_catas_end(dev);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
 	kfree(priv);
@@ -3091,7 +3100,6 @@ static int __init mlx4_init(void)
 	if (mlx4_verify_params())
 		return -EINVAL;
 
-	mlx4_catas_init();
 
 	mlx4_wq = create_singlethread_workqueue("mlx4");
 	if (!mlx4_wq)
diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4.h b/drivers/net/ethernet/mellanox/mlx4/mlx4.h
index cebd1180702b..361ec878b5f1 100644
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4.h
@@ -996,7 +996,8 @@ void __mlx4_xrcd_free(struct mlx4_dev *dev, u32 xrcdn);
 
 void mlx4_start_catas_poll(struct mlx4_dev *dev);
 void mlx4_stop_catas_poll(struct mlx4_dev *dev);
-void mlx4_catas_init(void);
+int mlx4_catas_init(struct mlx4_dev *dev);
+void mlx4_catas_end(struct mlx4_dev *dev);
 int mlx4_restart_one(struct pci_dev *pdev);
 int mlx4_register_device(struct mlx4_dev *dev);
 void mlx4_unregister_device(struct mlx4_dev *dev);
* Unmerged path include/linux/mlx4/device.h
