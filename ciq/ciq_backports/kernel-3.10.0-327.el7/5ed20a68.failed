flow_dissector: Abstract out hash computation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Tom Herbert <therbert@google.com>
commit 5ed20a68cd6ca4adc0aa2d240913d604a2eb3e25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/5ed20a68.failed

Move the hash computation located in __skb_get_hash to be a separate
function which takes flow_keys as input. This will allow flow hash
computation in other contexts where we only have addresses and ports.

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5ed20a68cd6ca4adc0aa2d240913d604a2eb3e25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow_keys.h
#	net/core/flow_dissector.c
diff --cc include/net/flow_keys.h
index d4fec0ba6827,6667a054763a..000000000000
--- a/include/net/flow_keys.h
+++ b/include/net/flow_keys.h
@@@ -27,5 -27,7 +27,11 @@@ struct flow_keys 
  	u8 ip_proto;
  };
  
++<<<<<<< HEAD
 +extern bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow);
++=======
+ bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow);
+ __be32 skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto);
+ u32 flow_hash_from_keys(struct flow_keys *keys);
++>>>>>>> 5ed20a68cd6c (flow_dissector: Abstract out hash computation)
  #endif
diff --cc net/core/flow_dissector.c
index a82ac44a3fe2,2ff8cd4dfc5f..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -180,10 -202,37 +180,37 @@@ static __always_inline u32 __flow_hash_
  	return jhash_1word(a, hashrnd);
  }
  
+ static inline u32 __flow_hash_from_keys(struct flow_keys *keys)
+ {
+ 	u32 hash;
+ 
+ 	/* get a consistent hash (same value on both flow directions) */
+ 	if (((__force u32)keys->dst < (__force u32)keys->src) ||
+ 	    (((__force u32)keys->dst == (__force u32)keys->src) &&
+ 	     ((__force u16)keys->port16[1] < (__force u16)keys->port16[0]))) {
+ 		swap(keys->dst, keys->src);
+ 		swap(keys->port16[0], keys->port16[1]);
+ 	}
+ 
+ 	hash = __flow_hash_3words((__force u32)keys->dst,
+ 				  (__force u32)keys->src,
+ 				  (__force u32)keys->ports);
+ 	if (!hash)
+ 		hash = 1;
+ 
+ 	return hash;
+ }
+ 
+ u32 flow_hash_from_keys(struct flow_keys *keys)
+ {
+ 	return __flow_hash_from_keys(keys);
+ }
+ EXPORT_SYMBOL(flow_hash_from_keys);
+ 
  /*
   * __skb_get_hash: calculate a flow hash based on src/dst addresses
 - * and src/dst port numbers.  Sets hash in skb to non-zero hash value
 - * on success, zero indicates no valid hash.  Also, sets l4_hash in skb
 + * and src/dst port numbers.  Sets rxhash in skb to non-zero hash value
 + * on success, zero indicates no valid hash.  Also, sets l4_rxhash in skb
   * if hash is a canonical 4-tuple hash over transport ports.
   */
  void __skb_get_hash(struct sk_buff *skb)
@@@ -195,23 -243,9 +221,27 @@@
  		return;
  
  	if (keys.ports)
 -		skb->l4_hash = 1;
 +		skb->l4_rxhash = 1;
 +
++<<<<<<< HEAD
 +	/* get a consistent hash (same value on both flow directions) */
 +	if (((__force u32)keys.dst < (__force u32)keys.src) ||
 +	    (((__force u32)keys.dst == (__force u32)keys.src) &&
 +	     ((__force u16)keys.port16[1] < (__force u16)keys.port16[0]))) {
 +		swap(keys.dst, keys.src);
 +		swap(keys.port16[0], keys.port16[1]);
 +	}
 +
 +	hash = __flow_hash_3words((__force u32)keys.dst,
 +				  (__force u32)keys.src,
 +				  (__force u32)keys.ports);
 +	if (!hash)
 +		hash = 1;
  
 +	skb->rxhash = hash;
++=======
+ 	skb->hash = __flow_hash_from_keys(&keys);
++>>>>>>> 5ed20a68cd6c (flow_dissector: Abstract out hash computation)
  }
  EXPORT_SYMBOL(__skb_get_hash);
  
* Unmerged path include/net/flow_keys.h
* Unmerged path net/core/flow_dissector.c
