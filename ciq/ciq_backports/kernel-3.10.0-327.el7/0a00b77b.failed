nfs: mirroring support for direct io

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Weston Andros Adamson <dros@primarydata.com>
commit 0a00b77b331a0e4aac461d4e920677661256918a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0a00b77b.failed

The current mirroring code only notices short writes to the first
mirror. This patch keeps per-mirror byte counts and only considers
a byte to be written once all mirrors report so.

	Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
(cherry picked from commit 0a00b77b331a0e4aac461d4e920677661256918a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/direct.c
diff --cc fs/nfs/direct.c
index 74e3798cd593,651387bbfd9f..000000000000
--- a/fs/nfs/direct.c
+++ b/fs/nfs/direct.c
@@@ -370,7 -405,8 +414,12 @@@ static void nfs_direct_read_completion(
  	if (test_bit(NFS_IOHDR_ERROR, &hdr->flags) && (hdr->good_bytes == 0))
  		dreq->error = hdr->error;
  	else
++<<<<<<< HEAD
 +		dreq->count += hdr->good_bytes;
++=======
+ 		nfs_direct_good_bytes(dreq, hdr);
+ 
++>>>>>>> 0a00b77b331a (nfs: mirroring support for direct io)
  	spin_unlock(&dreq->lock);
  
  	while (!list_empty(&hdr->pages)) {
@@@ -649,14 -637,14 +698,17 @@@ static void nfs_direct_write_reschedule
  	LIST_HEAD(reqs);
  	struct nfs_commit_info cinfo;
  	LIST_HEAD(failed);
+ 	int i;
  
  	nfs_init_cinfo_from_dreq(&cinfo, dreq);
 -	nfs_direct_write_scan_commit_list(dreq->inode, &reqs, &cinfo);
 +	pnfs_recover_commit_reqs(dreq->inode, &reqs, &cinfo);
 +	spin_lock(cinfo.lock);
 +	nfs_scan_commit_list(&cinfo.mds->list, &reqs, &cinfo, 0);
 +	spin_unlock(cinfo.lock);
  
  	dreq->count = 0;
+ 	for (i = 0; i < dreq->mirror_count; i++)
+ 		dreq->mirrors[i].count = 0;
  	get_dreq(dreq);
  
  	nfs_pageio_init_write(&desc, dreq->inode, FLUSH_STABLE, false,
@@@ -897,7 -775,7 +952,11 @@@ static void nfs_direct_write_completion
  		dreq->error = hdr->error;
  	}
  	if (dreq->error == 0) {
++<<<<<<< HEAD
 +		dreq->count += hdr->good_bytes;
++=======
+ 		nfs_direct_good_bytes(dreq, hdr);
++>>>>>>> 0a00b77b331a (nfs: mirroring support for direct io)
  		if (nfs_write_need_commit(hdr)) {
  			if (dreq->flags == NFS_ODIRECT_RESCHED_WRITES)
  				request_commit = true;
@@@ -966,16 -856,52 +1025,53 @@@ static ssize_t nfs_direct_write_schedul
  	get_dreq(dreq);
  	atomic_inc(&inode->i_dio_count);
  
 -	NFS_I(inode)->write_io += iov_iter_count(iter);
 -	while (iov_iter_count(iter)) {
 -		struct page **pagevec;
 -		size_t bytes;
 -		size_t pgbase;
 -		unsigned npages, i;
 -
 -		result = iov_iter_get_pages_alloc(iter, &pagevec, 
 -						  wsize, &pgbase);
 +	NFS_I(dreq->inode)->write_io += iov_length(iov, nr_segs);
 +	for (seg = 0; seg < nr_segs; seg++) {
 +		const struct iovec *vec = &iov[seg];
 +		result = nfs_direct_write_schedule_segment(&desc, vec, pos, uio);
  		if (result < 0)
  			break;
++<<<<<<< HEAD
 +		requested_bytes += result;
 +		if ((size_t)result < vec->iov_len)
++=======
+ 
+ 		bytes = result;
+ 		iov_iter_advance(iter, bytes);
+ 		npages = (result + pgbase + PAGE_SIZE - 1) / PAGE_SIZE;
+ 		for (i = 0; i < npages; i++) {
+ 			struct nfs_page *req;
+ 			unsigned int req_len = min_t(size_t, bytes, PAGE_SIZE - pgbase);
+ 
+ 			req = nfs_create_request(dreq->ctx, pagevec[i], NULL,
+ 						 pgbase, req_len);
+ 			if (IS_ERR(req)) {
+ 				result = PTR_ERR(req);
+ 				break;
+ 			}
+ 
+ 			nfs_direct_setup_mirroring(dreq, &desc, req);
+ 
+ 			nfs_lock_request(req);
+ 			req->wb_index = pos >> PAGE_SHIFT;
+ 			req->wb_offset = pos & ~PAGE_MASK;
+ 			if (!nfs_pageio_add_request(&desc, req)) {
+ 				result = desc.pg_error;
+ 				nfs_unlock_and_release_request(req);
+ 				break;
+ 			}
+ 			pgbase = 0;
+ 			bytes -= req_len;
+ 			requested_bytes += req_len;
+ 			pos += req_len;
+ 			dreq->bytes_left -= req_len;
+ 		}
+ 		nfs_direct_release_pages(pagevec, npages);
+ 		kvfree(pagevec);
+ 		if (result < 0)
++>>>>>>> 0a00b77b331a (nfs: mirroring support for direct io)
  			break;
 +		pos += vec->iov_len;
  	}
  	nfs_pageio_complete(&desc);
  
* Unmerged path fs/nfs/direct.c
