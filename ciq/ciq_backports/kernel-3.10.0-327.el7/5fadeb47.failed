nfs: count DIO good bytes correctly with mirroring

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Peng Tao <tao.peng@primarydata.com>
commit 5fadeb47dcc5c30d4b6cf481b4a78689eab59443
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/5fadeb47.failed

When resending to MDS, we might resend multiple mirroring
requests to MDS. As a result, nfs_direct_good_bytes() ends
up counting bytes multiple times, causing application to
get wrong return results in read/write syscalls.

Fix it by tracking start of a dreq and checking the range of
pgio header.

	Cc: Weston Andros Adamson <dros@primarydata.com>
	Signed-off-by: Peng Tao <tao.peng@primarydata.com>
(cherry picked from commit 5fadeb47dcc5c30d4b6cf481b4a78689eab59443)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/direct.c
diff --cc fs/nfs/direct.c
index 74e3798cd593,3715b4957abc..000000000000
--- a/fs/nfs/direct.c
+++ b/fs/nfs/direct.c
@@@ -78,8 -82,13 +78,9 @@@ struct nfs_direct_req 
  	/* completion state */
  	atomic_t		io_count;	/* i/os we're waiting for */
  	spinlock_t		lock;		/* protect completion state */
 -
 -	struct nfs_direct_mirror mirrors[NFS_PAGEIO_DESCRIPTOR_MIRROR_MAX];
 -	int			mirror_count;
 -
  	ssize_t			count,		/* bytes actually processed */
  				bytes_left,	/* bytes left to be sent */
+ 				io_start,	/* start of IO */
  				error;		/* any reported error */
  	struct completion	completion;	/* wait for i/o completion */
  
@@@ -108,6 -117,36 +109,39 @@@ static inline int put_dreq(struct nfs_d
  	return atomic_dec_and_test(&dreq->io_count);
  }
  
++<<<<<<< HEAD
++=======
+ void nfs_direct_set_resched_writes(struct nfs_direct_req *dreq)
+ {
+ 	dreq->flags = NFS_ODIRECT_RESCHED_WRITES;
+ }
+ EXPORT_SYMBOL_GPL(nfs_direct_set_resched_writes);
+ 
+ static void
+ nfs_direct_good_bytes(struct nfs_direct_req *dreq, struct nfs_pgio_header *hdr)
+ {
+ 	int i;
+ 	ssize_t count;
+ 
+ 	WARN_ON_ONCE(hdr->pgio_mirror_idx >= dreq->mirror_count);
+ 
+ 	count = dreq->mirrors[hdr->pgio_mirror_idx].count;
+ 	if (count + dreq->io_start < hdr->io_start + hdr->good_bytes) {
+ 		count = hdr->io_start + hdr->good_bytes - dreq->io_start;
+ 		dreq->mirrors[hdr->pgio_mirror_idx].count = count;
+ 	}
+ 
+ 	/* update the dreq->count by finding the minimum agreed count from all
+ 	 * mirrors */
+ 	count = dreq->mirrors[0].count;
+ 
+ 	for (i = 1; i < dreq->mirror_count; i++)
+ 		count = min(count, dreq->mirrors[i].count);
+ 
+ 	dreq->count = count;
+ }
+ 
++>>>>>>> 5fadeb47dcc5 (nfs: count DIO good bytes correctly with mirroring)
  /*
   * nfs_direct_select_verf - select the right verifier
   * @dreq - direct request possibly spanning multiple servers
@@@ -608,7 -595,8 +642,12 @@@ ssize_t nfs_file_direct_read(struct kio
  		goto out_unlock;
  
  	dreq->inode = inode;
++<<<<<<< HEAD
 +	dreq->bytes_left = iov_length(iov, nr_segs);
++=======
+ 	dreq->bytes_left = count;
+ 	dreq->io_start = pos;
++>>>>>>> 5fadeb47dcc5 (nfs: count DIO good bytes correctly with mirroring)
  	dreq->ctx = get_nfs_open_context(nfs_file_open_context(iocb->ki_filp));
  	l_ctx = nfs_get_lock_context(dreq->ctx);
  	if (IS_ERR(l_ctx)) {
* Unmerged path fs/nfs/direct.c
