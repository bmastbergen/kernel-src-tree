NVMe: Freeze admin queue on device failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Keith Busch <keith.busch@intel.com>
commit 6df3dbc83fb8043a5975d75970d296d6d14f7273
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6df3dbc8.failed

This fixes a race accessing an invalid address when a controller's admin
queue is in use during a reset for failure or hot removal occurs. The
admin queue will be frozen to prevent new users from entering prior to
the doorbell queue being unmapped.

	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 6df3dbc83fb8043a5975d75970d296d6d14f7273)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index 6783fae878e4,ee83554c28ba..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -1341,10 -1342,14 +1341,13 @@@ static int nvme_suspend_queue(struct nv
  		spin_unlock_irq(&nvmeq->q_lock);
  		return 1;
  	}
 -	vector = nvmeq->dev->entry[nvmeq->cq_vector].vector;
 +	nvmeq->q_suspended = 1;
  	nvmeq->dev->online_queues--;
 -	nvmeq->cq_vector = -1;
  	spin_unlock_irq(&nvmeq->q_lock);
  
+ 	if (!nvmeq->qid && nvmeq->dev->admin_q)
+ 		blk_mq_freeze_queue_start(nvmeq->dev->admin_q);
+ 
  	irq_set_affinity_hint(vector, NULL);
  	free_irq(vector, nvmeq);
  
@@@ -1374,7 -1381,10 +1377,14 @@@ static void nvme_disable_queue(struct n
  		adapter_delete_sq(dev, qid);
  		adapter_delete_cq(dev, qid);
  	}
++<<<<<<< HEAD
 +	nvme_clear_queue(nvmeq);
++=======
+ 
+ 	spin_lock_irq(&nvmeq->q_lock);
+ 	nvme_process_cq(nvmeq);
+ 	spin_unlock_irq(&nvmeq->q_lock);
++>>>>>>> 6df3dbc83fb8 (NVMe: Freeze admin queue on device failure)
  }
  
  static struct nvme_queue *nvme_alloc_queue(struct nvme_dev *dev, int qid,
* Unmerged path drivers/block/nvme-core.c
