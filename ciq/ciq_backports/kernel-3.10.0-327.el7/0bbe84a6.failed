ipv6: Append sending data to arbitrary queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Vlad Yasevich <vyasevich@gmail.com>
commit 0bbe84a67b0b5460c2e67101b3aa95cb828845f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0bbe84a6.failed

Add the ability to append data to arbitrary queue.  This
will be needed later to implement lockless UDP sends.

	Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0bbe84a67b0b5460c2e67101b3aa95cb828845f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_output.c
diff --cc net/ipv6/ip6_output.c
index 524b4ad02d70,1b66453a695d..000000000000
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@@ -1032,7 -1057,8 +1033,12 @@@ static inline int ip6_ufo_append_data(s
  	 * device, so create one single skb packet containing complete
  	 * udp datagram
  	 */
++<<<<<<< HEAD
 +	if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {
++=======
+ 	skb = skb_peek_tail(queue);
+ 	if (skb == NULL) {
++>>>>>>> 0bbe84a67b0b (ipv6: Append sending data to arbitrary queue)
  		skb = sock_alloc_send_skb(sk,
  			hh_len + fragheaderlen + transhdrlen + 20,
  			(flags & MSG_DONTWAIT), &err);
@@@ -1051,9 -1077,10 +1057,9 @@@
  		/* initialize protocol header pointer */
  		skb->transport_header = skb->network_header + fragheaderlen;
  
 -		skb->protocol = htons(ETH_P_IPV6);
  		skb->csum = 0;
  
- 		__skb_queue_tail(&sk->sk_write_queue, skb);
+ 		__skb_queue_tail(queue, skb);
  	} else if (skb_is_gso(skb)) {
  		goto append;
  	}
@@@ -1195,30 -1224,16 +1203,19 @@@ static int __ip6_append_data(struct soc
  	int err;
  	int offset = 0;
  	__u8 tx_flags = 0;
- 
- 	if (flags&MSG_PROBE)
- 		return 0;
- 	cork = &inet->cork.base;
- 	if (skb_queue_empty(&sk->sk_write_queue)) {
- 		/*
- 		 * setup for corking
- 		 */
- 		err = ip6_setup_cork(sk, &inet->cork, &np->cork, hlimit,
- 				     tclass, opt, rt, fl6);
- 		if (err)
- 			return err;
- 		exthdrlen = (opt ? opt->opt_flen : 0);
- 		length += exthdrlen;
- 		transhdrlen += exthdrlen;
++<<<<<<< HEAD
++=======
+ 	u32 tskey = 0;
+ 	struct rt6_info *rt = (struct rt6_info *)cork->dst;
+ 	struct ipv6_txoptions *opt = v6_cork->opt;
++>>>>>>> 0bbe84a67b0b (ipv6: Append sending data to arbitrary queue)
+ 
+ 	skb = skb_peek_tail(queue);
+ 	if (!skb) {
+ 		exthdrlen = opt ? opt->opt_flen : 0;
  		dst_exthdrlen = rt->dst.header_len - rt->rt6i_nfheader_len;
- 	} else {
- 		rt = (struct rt6_info *)cork->dst;
- 		fl6 = &inet->cork.fl.u.ip6;
- 		opt = np->cork.opt;
- 		transhdrlen = 0;
- 		exthdrlen = 0;
- 		dst_exthdrlen = 0;
  	}
+ 
  	mtu = cork->fragsize;
  	orig_mtu = mtu;
  
* Unmerged path net/ipv6/ip6_output.c
