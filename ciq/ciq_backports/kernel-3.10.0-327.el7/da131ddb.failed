bonding: make local function static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author stephen hemminger <stephen@networkplumber.org>
commit da131ddbffae0d225f36e0651b8cf7014a576c0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/da131ddb.failed

bond_xmit_slave_id is only used in main.

	Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit da131ddbffae0d225f36e0651b8cf7014a576c0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index ab67050d61a5,881fade98919..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -3828,6 -3501,76 +3828,79 @@@ unwind
  	return res;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * bond_xmit_slave_id - transmit skb through slave with slave_id
+  * @bond: bonding device that is transmitting
+  * @skb: buffer to transmit
+  * @slave_id: slave id up to slave_cnt-1 through which to transmit
+  *
+  * This function tries to transmit through slave with slave_id but in case
+  * it fails, it tries to find the first available slave for transmission.
+  * The skb is consumed in all cases, thus the function is void.
+  */
+ static void bond_xmit_slave_id(struct bonding *bond, struct sk_buff *skb, int slave_id)
+ {
+ 	struct list_head *iter;
+ 	struct slave *slave;
+ 	int i = slave_id;
+ 
+ 	/* Here we start from the slave with slave_id */
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		if (--i < 0) {
+ 			if (slave_can_tx(slave)) {
+ 				bond_dev_queue_xmit(bond, skb, slave->dev);
+ 				return;
+ 			}
+ 		}
+ 	}
+ 
+ 	/* Here we start from the first slave up to slave_id */
+ 	i = slave_id;
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
+ 		if (--i < 0)
+ 			break;
+ 		if (slave_can_tx(slave)) {
+ 			bond_dev_queue_xmit(bond, skb, slave->dev);
+ 			return;
+ 		}
+ 	}
+ 	/* no slave that can tx has been found */
+ 	kfree_skb(skb);
+ }
+ 
+ /**
+  * bond_rr_gen_slave_id - generate slave id based on packets_per_slave
+  * @bond: bonding device to use
+  *
+  * Based on the value of the bonding device's packets_per_slave parameter
+  * this function generates a slave id, which is usually used as the next
+  * slave to transmit through.
+  */
+ static u32 bond_rr_gen_slave_id(struct bonding *bond)
+ {
+ 	int packets_per_slave = bond->params.packets_per_slave;
+ 	u32 slave_id;
+ 
+ 	switch (packets_per_slave) {
+ 	case 0:
+ 		slave_id = prandom_u32();
+ 		break;
+ 	case 1:
+ 		slave_id = bond->rr_tx_counter;
+ 		break;
+ 	default:
+ 		slave_id = reciprocal_divide(bond->rr_tx_counter,
+ 					     packets_per_slave);
+ 		break;
+ 	}
+ 	bond->rr_tx_counter++;
+ 
+ 	return slave_id;
+ }
+ 
++>>>>>>> da131ddbffae (bonding: make local function static)
  static int bond_xmit_roundrobin(struct sk_buff *skb, struct net_device *bond_dev)
  {
  	struct bonding *bond = netdev_priv(bond_dev);
* Unmerged path drivers/net/bonding/bond_main.c
