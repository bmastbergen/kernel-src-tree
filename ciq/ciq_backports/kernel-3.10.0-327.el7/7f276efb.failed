ixgbe: Add the appropriate ethtool ops to query RSS indirection table and key

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Vlad Zolotarov <vladz@cloudius-systems.com>
commit 7f276efb45f8b022eeb9a0453240937806dc27e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7f276efb.failed

Added get_rxfh_indir_size, get_rxfh_key_size and get_rxfh ethtool_ops
callbacks implementations.

This enables the ethtool's "-x" and "--show-rxfh[-indir]" options.

	Signed-off-by: Vlad Zolotarov <vladz@cloudius-systems.com>
	Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 7f276efb45f8b022eeb9a0453240937806dc27e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe.h
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe.h
index dcedeeeaac8b,d3d27ec86ad2..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
@@@ -938,4 -961,8 +938,11 @@@ void ixgbe_ptp_check_pps_event(struct i
  void ixgbe_sriov_reinit(struct ixgbe_adapter *adapter);
  #endif
  
++<<<<<<< HEAD
++=======
+ netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb,
+ 				  struct ixgbe_adapter *adapter,
+ 				  struct ixgbe_ring *tx_ring);
+ u32 ixgbe_rss_indir_tbl_entries(struct ixgbe_adapter *adapter);
++>>>>>>> 7f276efb45f8 (ixgbe: Add the appropriate ethtool ops to query RSS indirection table and key)
  #endif /* _IXGBE_H_ */
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index be14b10f1d85,fb096dd7b773..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -3209,15 -3228,98 +3209,28 @@@ static void ixgbe_configure_srrctl(stru
  	IXGBE_WRITE_REG(hw, IXGBE_SRRCTL(reg_idx), srrctl);
  }
  
++<<<<<<< HEAD
 +static void ixgbe_setup_reta(struct ixgbe_adapter *adapter, const u32 *seed)
++=======
+ /**
+  * Return a number of entries in the RSS indirection table
+  *
+  * @adapter: device handle
+  *
+  *  - 82598/82599/X540:     128
+  *  - X550(non-SRIOV mode): 512
+  *  - X550(SRIOV mode):     64
+  */
+ u32 ixgbe_rss_indir_tbl_entries(struct ixgbe_adapter *adapter)
++>>>>>>> 7f276efb45f8 (ixgbe: Add the appropriate ethtool ops to query RSS indirection table and key)
  {
 -	if (adapter->hw.mac.type < ixgbe_mac_X550)
 -		return 128;
 -	else if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED)
 -		return 64;
 -	else
 -		return 512;
 -}
 -
 -/**
 - * Write the RETA table to HW
 - *
 - * @adapter: device handle
 - *
 - * Write the RSS redirection table stored in adapter.rss_indir_tbl[] to HW.
 - */
 -static void ixgbe_store_reta(struct ixgbe_adapter *adapter)
 -{
 -	u32 i, reta_entries = ixgbe_rss_indir_tbl_entries(adapter);
  	struct ixgbe_hw *hw = &adapter->hw;
  	u32 reta = 0;
 -	u32 indices_multi;
 -	u8 *indir_tbl = adapter->rss_indir_tbl;
 -
 -	/* Fill out the redirection table as follows:
 -	 *  - 82598:      8 bit wide entries containing pair of 4 bit RSS
 -	 *    indices.
 -	 *  - 82599/X540: 8 bit wide entries containing 4 bit RSS index
 -	 *  - X550:       8 bit wide entries containing 6 bit RSS index
 -	 */
 -	if (adapter->hw.mac.type == ixgbe_mac_82598EB)
 -		indices_multi = 0x11;
 -	else
 -		indices_multi = 0x1;
 -
 -	/* Write redirection table to HW */
 -	for (i = 0; i < reta_entries; i++) {
 -		reta |= indices_multi * indir_tbl[i] << (i & 0x3) * 8;
 -		if ((i & 3) == 3) {
 -			if (i < 128)
 -				IXGBE_WRITE_REG(hw, IXGBE_RETA(i >> 2), reta);
 -			else
 -				IXGBE_WRITE_REG(hw, IXGBE_ERETA((i >> 2) - 32),
 -						reta);
 -			reta = 0;
 -		}
 -	}
 -}
 -
 -/**
 - * Write the RETA table to HW (for x550 devices in SRIOV mode)
 - *
 - * @adapter: device handle
 - *
 - * Write the RSS redirection table stored in adapter.rss_indir_tbl[] to HW.
 - */
 -static void ixgbe_store_vfreta(struct ixgbe_adapter *adapter)
 -{
 -	u32 i, reta_entries = ixgbe_rss_indir_tbl_entries(adapter);
 -	struct ixgbe_hw *hw = &adapter->hw;
 -	u32 vfreta = 0;
 -	unsigned int pf_pool = adapter->num_vfs;
 -
 -	/* Write redirection table to HW */
 -	for (i = 0; i < reta_entries; i++) {
 -		vfreta |= (u32)adapter->rss_indir_tbl[i] << (i & 0x3) * 8;
 -		if ((i & 3) == 3) {
 -			IXGBE_WRITE_REG(hw, IXGBE_PFVFRETA(i >> 2, pf_pool),
 -					vfreta);
 -			vfreta = 0;
 -		}
 -	}
 -}
 -
 -static void ixgbe_setup_reta(struct ixgbe_adapter *adapter)
 -{
 -	struct ixgbe_hw *hw = &adapter->hw;
 -	u32 i, j;
 -	u32 reta_entries = ixgbe_rss_indir_tbl_entries(adapter);
 +	int i, j;
  	u16 rss_i = adapter->ring_feature[RING_F_RSS].indices;
  
 -	/* Program table for at least 2 queues w/ SR-IOV so that VFs can
 +	/*
 +	 * Program table for at least 2 queues w/ SR-IOV so that VFs can
  	 * make full use of any rings they may have.  We will use the
  	 * PSRTYPE register to control how many rings we use within the PF.
  	 */
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe.h
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
index 7b9a19fba23a..b0729744e762 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
@@ -2857,6 +2857,45 @@ static int ixgbe_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)
 	return ret;
 }
 
+static u32 ixgbe_get_rxfh_key_size(struct net_device *netdev)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+
+	return sizeof(adapter->rss_key);
+}
+
+static u32 ixgbe_rss_indir_size(struct net_device *netdev)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+
+	return ixgbe_rss_indir_tbl_entries(adapter);
+}
+
+static void ixgbe_get_reta(struct ixgbe_adapter *adapter, u32 *indir)
+{
+	int i, reta_size = ixgbe_rss_indir_tbl_entries(adapter);
+
+	for (i = 0; i < reta_size; i++)
+		indir[i] = adapter->rss_indir_tbl[i];
+}
+
+static int ixgbe_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
+			  u8 *hfunc)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+
+	if (hfunc)
+		*hfunc = ETH_RSS_HASH_TOP;
+
+	if (indir)
+		ixgbe_get_reta(adapter, indir);
+
+	if (key)
+		memcpy(key, adapter->rss_key, ixgbe_get_rxfh_key_size(netdev));
+
+	return 0;
+}
+
 static int ixgbe_get_ts_info(struct net_device *dev,
 			     struct ethtool_ts_info *info)
 {
@@ -3113,6 +3152,9 @@ static const struct ethtool_ops ixgbe_ethtool_ops = {
 	.set_coalesce           = ixgbe_set_coalesce,
 	.get_rxnfc		= ixgbe_get_rxnfc,
 	.set_rxnfc		= ixgbe_set_rxnfc,
+	.get_rxfh_indir_size	= ixgbe_rss_indir_size,
+	.get_rxfh_key_size	= ixgbe_get_rxfh_key_size,
+	.get_rxfh		= ixgbe_get_rxfh,
 	.get_channels		= ixgbe_get_channels,
 	.set_channels		= ixgbe_set_channels,
 	.get_ts_info		= ixgbe_get_ts_info,
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
