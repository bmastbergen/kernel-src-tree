s390/irq: Use defines for external interruption codes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [s390] irq: Use defines for external interruption codes (Hendrik Brueckner) [1182294]
Rebuild_FUZZ: 95.05%
commit-author Thomas Huth <thuth@linux.vnet.ibm.com>
commit 1dad093b66fdd4fd5d7d2692169dc1bafd794628
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1dad093b.failed

Use the new defines for external interruption codes to get rid
of "magic" numbers in the s390 source code. And while we're at it,
also rename the (un-)register_external_interrupt function to
something shorter so that this patch does not exceed the 80
columns all over the place.

	Signed-off-by: Thomas Huth <thuth@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 1dad093b66fdd4fd5d7d2692169dc1bafd794628)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/irq.h
#	arch/s390/kernel/irq.c
#	arch/s390/kernel/runtime_instr.c
#	drivers/s390/block/dasd_diag.c
#	drivers/s390/kvm/kvm_virtio.c
diff --cc arch/s390/include/asm/irq.h
index 15c258edc318,763ccdcb70ba..000000000000
--- a/arch/s390/include/asm/irq.h
+++ b/arch/s390/include/asm/irq.h
@@@ -1,6 -1,37 +1,40 @@@
  #ifndef _ASM_IRQ_H
  #define _ASM_IRQ_H
  
++<<<<<<< HEAD
++=======
+ #define EXT_INTERRUPT	1
+ #define IO_INTERRUPT	2
+ #define THIN_INTERRUPT	3
+ 
+ #define NR_IRQS_BASE	4
+ 
+ #ifdef CONFIG_PCI_NR_MSI
+ # define NR_IRQS	(NR_IRQS_BASE + CONFIG_PCI_NR_MSI)
+ #else
+ # define NR_IRQS	NR_IRQS_BASE
+ #endif
+ 
+ /* This number is used when no interrupt has been assigned */
+ #define NO_IRQ		0
+ 
+ /* External interruption codes */
+ #define EXT_IRQ_INTERRUPT_KEY	0x0040
+ #define EXT_IRQ_CLK_COMP	0x1004
+ #define EXT_IRQ_CPU_TIMER	0x1005
+ #define EXT_IRQ_WARNING_TRACK	0x1007
+ #define EXT_IRQ_MALFUNC_ALERT	0x1200
+ #define EXT_IRQ_EMERGENCY_SIG	0x1201
+ #define EXT_IRQ_EXTERNAL_CALL	0x1202
+ #define EXT_IRQ_TIMING_ALERT	0x1406
+ #define EXT_IRQ_MEASURE_ALERT	0x1407
+ #define EXT_IRQ_SERVICE_SIG	0x2401
+ #define EXT_IRQ_CP_SERVICE	0x2603
+ #define EXT_IRQ_IUCV		0x4000
+ 
+ #ifndef __ASSEMBLY__
+ 
++>>>>>>> 1dad093b66fd (s390/irq: Use defines for external interruption codes)
  #include <linux/hardirq.h>
  #include <linux/percpu.h>
  #include <linux/cache.h>
@@@ -68,21 -90,19 +102,26 @@@ struct ext_code 
  
  typedef void (*ext_int_handler_t)(struct ext_code, unsigned int, unsigned long);
  
++<<<<<<< HEAD
 +int register_external_interrupt(u16 code, ext_int_handler_t handler);
 +int unregister_external_interrupt(u16 code, ext_int_handler_t handler);
 +void service_subclass_irq_register(void);
 +void service_subclass_irq_unregister(void);
 +void measurement_alert_subclass_register(void);
 +void measurement_alert_subclass_unregister(void);
++=======
+ int register_external_irq(u16 code, ext_int_handler_t handler);
+ int unregister_external_irq(u16 code, ext_int_handler_t handler);
 -
 -enum irq_subclass {
 -	IRQ_SUBCLASS_MEASUREMENT_ALERT = 5,
 -	IRQ_SUBCLASS_SERVICE_SIGNAL = 9,
 -};
 -
 -void irq_subclass_register(enum irq_subclass subclass);
 -void irq_subclass_unregister(enum irq_subclass subclass);
 -
 -#define irq_canonicalize(irq)  (irq)
 -
 -#endif /* __ASSEMBLY__ */
++>>>>>>> 1dad093b66fd (s390/irq: Use defines for external interruption codes)
 +
 +#ifdef CONFIG_LOCKDEP
 +#  define disable_irq_nosync_lockdep(irq)	disable_irq_nosync(irq)
 +#  define disable_irq_nosync_lockdep_irqsave(irq, flags) \
 +						disable_irq_nosync(irq)
 +#  define disable_irq_lockdep(irq)		disable_irq(irq)
 +#  define enable_irq_lockdep(irq)		enable_irq(irq)
 +#  define enable_irq_lockdep_irqrestore(irq, flags) \
 +						enable_irq(irq)
 +#endif
  
  #endif /* _ASM_IRQ_H */
diff --cc arch/s390/kernel/irq.c
index e63edadc6fd6,083617d739d8..000000000000
--- a/arch/s390/kernel/irq.c
+++ b/arch/s390/kernel/irq.c
@@@ -186,22 -196,16 +186,22 @@@ struct ext_int_info 
  };
  
  /* ext_int_hash_lock protects the handler lists for external interrupts */
 -static DEFINE_SPINLOCK(ext_int_hash_lock);
 +DEFINE_SPINLOCK(ext_int_hash_lock);
  
 -static inline int ext_hash(u16 code)
 +static void __init init_external_interrupts(void)
  {
 -	BUILD_BUG_ON(!is_power_of_2(ARRAY_SIZE(ext_int_hash)));
 +	int idx;
  
 -	return (code + (code >> 9)) & (ARRAY_SIZE(ext_int_hash) - 1);
 +	for (idx = 0; idx < ARRAY_SIZE(ext_int_hash); idx++)
 +		INIT_LIST_HEAD(&ext_int_hash[idx]);
 +}
 +
 +static inline int ext_hash(u16 code)
 +{
 +	return (code + (code >> 9)) & 0xff;
  }
  
- int register_external_interrupt(u16 code, ext_int_handler_t handler)
+ int register_external_irq(u16 code, ext_int_handler_t handler)
  {
  	struct ext_int_info *p;
  	unsigned long flags;
@@@ -237,23 -241,17 +237,28 @@@ int unregister_external_irq(u16 code, e
  	spin_unlock_irqrestore(&ext_int_hash_lock, flags);
  	return 0;
  }
- EXPORT_SYMBOL(unregister_external_interrupt);
+ EXPORT_SYMBOL(unregister_external_irq);
  
 -static irqreturn_t do_ext_interrupt(int irq, void *dummy)
 +void __irq_entry do_extint(struct pt_regs *regs, struct ext_code ext_code,
 +			   unsigned int param32, unsigned long param64)
  {
 -	struct pt_regs *regs = get_irq_regs();
 -	struct ext_code ext_code;
 +	struct pt_regs *old_regs;
  	struct ext_int_info *p;
  	int index;
  
++<<<<<<< HEAD
 +	old_regs = set_irq_regs(regs);
 +	irq_enter();
 +	if (S390_lowcore.int_clock >= S390_lowcore.clock_comparator) {
 +		/* Serve timer interrupts first. */
 +		clock_comparator_work();
 +	}
 +	kstat_incr_irqs_this_cpu(EXTERNAL_INTERRUPT, NULL);
 +	if (ext_code.code != 0x1004)
++=======
+ 	ext_code = *(struct ext_code *) &regs->int_code;
+ 	if (ext_code.code != EXT_IRQ_CLK_COMP)
++>>>>>>> 1dad093b66fd (s390/irq: Use defines for external interruption codes)
  		__get_cpu_var(s390_idle).nohz_delay = 1;
  
  	index = ext_hash(ext_code.code);
diff --cc arch/s390/kernel/runtime_instr.c
index 040d596c7c47,26b4ae96fdd7..000000000000
--- a/arch/s390/kernel/runtime_instr.c
+++ b/arch/s390/kernel/runtime_instr.c
@@@ -137,10 -137,11 +137,16 @@@ static int __init runtime_instr_init(vo
  	if (!runtime_instr_avail())
  		return 0;
  
++<<<<<<< HEAD
 +	measurement_alert_subclass_register();
 +	rc = register_external_interrupt(0x1407, runtime_instr_int_handler);
++=======
+ 	irq_subclass_register(IRQ_SUBCLASS_MEASUREMENT_ALERT);
+ 	rc = register_external_irq(EXT_IRQ_MEASURE_ALERT,
+ 				   runtime_instr_int_handler);
++>>>>>>> 1dad093b66fd (s390/irq: Use defines for external interruption codes)
  	if (rc)
 -		irq_subclass_unregister(IRQ_SUBCLASS_MEASUREMENT_ALERT);
 +		measurement_alert_subclass_unregister();
  	else
  		pr_info("Runtime instrumentation facility initialized\n");
  	return rc;
diff --cc drivers/s390/block/dasd_diag.c
index cc0603358522,c062f1620c58..000000000000
--- a/drivers/s390/block/dasd_diag.c
+++ b/drivers/s390/block/dasd_diag.c
@@@ -641,8 -645,8 +641,13 @@@ dasd_diag_init(void
  	}
  	ASCEBC(dasd_diag_discipline.ebcname, 4);
  
++<<<<<<< HEAD
 +	service_subclass_irq_register();
 +	register_external_interrupt(0x2603, dasd_ext_handler);
++=======
+ 	irq_subclass_register(IRQ_SUBCLASS_SERVICE_SIGNAL);
+ 	register_external_irq(EXT_IRQ_CP_SERVICE, dasd_ext_handler);
++>>>>>>> 1dad093b66fd (s390/irq: Use defines for external interruption codes)
  	dasd_diag_discipline_pointer = &dasd_diag_discipline;
  	return 0;
  }
@@@ -650,8 -654,8 +655,13 @@@
  static void __exit
  dasd_diag_cleanup(void)
  {
++<<<<<<< HEAD
 +	unregister_external_interrupt(0x2603, dasd_ext_handler);
 +	service_subclass_irq_unregister();
++=======
+ 	unregister_external_irq(EXT_IRQ_CP_SERVICE, dasd_ext_handler);
+ 	irq_subclass_unregister(IRQ_SUBCLASS_SERVICE_SIGNAL);
++>>>>>>> 1dad093b66fd (s390/irq: Use defines for external interruption codes)
  	dasd_diag_discipline_pointer = NULL;
  }
  
diff --cc drivers/s390/kvm/kvm_virtio.c
index 0b51fa7ede7f,a1349653c6d9..000000000000
--- a/drivers/s390/kvm/kvm_virtio.c
+++ b/drivers/s390/kvm/kvm_virtio.c
@@@ -476,8 -476,8 +476,13 @@@ static int __init kvm_devices_init(void
  
  	INIT_WORK(&hotplug_work, hotplug_devices);
  
++<<<<<<< HEAD
 +	service_subclass_irq_register();
 +	register_external_interrupt(0x2603, kvm_extint_handler);
++=======
+ 	irq_subclass_register(IRQ_SUBCLASS_SERVICE_SIGNAL);
+ 	register_external_irq(EXT_IRQ_CP_SERVICE, kvm_extint_handler);
++>>>>>>> 1dad093b66fd (s390/irq: Use defines for external interruption codes)
  
  	scan_devices();
  	return 0;
* Unmerged path arch/s390/include/asm/irq.h
* Unmerged path arch/s390/kernel/irq.c
diff --git a/arch/s390/kernel/perf_cpum_cf.c b/arch/s390/kernel/perf_cpum_cf.c
index c46c5b2d6570..10c3981103a1 100644
--- a/arch/s390/kernel/perf_cpum_cf.c
+++ b/arch/s390/kernel/perf_cpum_cf.c
@@ -673,7 +673,8 @@ static int __init cpumf_pmu_init(void)
 	ctl_clear_bit(0, 48);
 
 	/* register handler for measurement-alert interruptions */
-	rc = register_external_interrupt(0x1407, cpumf_measurement_alert);
+	rc = register_external_irq(EXT_IRQ_MEASURE_ALERT,
+				   cpumf_measurement_alert);
 	if (rc) {
 		pr_err("Registering for CPU-measurement alerts "
 		       "failed with rc=%i\n", rc);
@@ -684,7 +685,8 @@ static int __init cpumf_pmu_init(void)
 	rc = perf_pmu_register(&cpumf_pmu, "cpum_cf", PERF_TYPE_RAW);
 	if (rc) {
 		pr_err("Registering the cpum_cf PMU failed with rc=%i\n", rc);
-		unregister_external_interrupt(0x1407, cpumf_measurement_alert);
+		unregister_external_irq(EXT_IRQ_MEASURE_ALERT,
+					cpumf_measurement_alert);
 		goto out;
 	}
 	perf_cpu_notifier(cpumf_pmu_notifier);
diff --git a/arch/s390/kernel/perf_cpum_sf.c b/arch/s390/kernel/perf_cpum_sf.c
index 5a13e430307b..27474533f4c5 100644
--- a/arch/s390/kernel/perf_cpum_sf.c
+++ b/arch/s390/kernel/perf_cpum_sf.c
@@ -1610,7 +1610,8 @@ static int __init init_cpum_sampling_pmu(void)
 		pr_err("Registering for s390dbf failed\n");
 	debug_register_view(sfdbg, &debug_sprintf_view);
 
-	err = register_external_interrupt(0x1407, cpumf_measurement_alert);
+	err = register_external_irq(EXT_IRQ_MEASURE_ALERT,
+				    cpumf_measurement_alert);
 	if (err) {
 		pr_cpumsf_err(RS_INIT_FAILURE_ALRT);
 		goto out;
@@ -1619,7 +1620,8 @@ static int __init init_cpum_sampling_pmu(void)
 	err = perf_pmu_register(&cpumf_sampling, "cpum_sf", PERF_TYPE_RAW);
 	if (err) {
 		pr_cpumsf_err(RS_INIT_FAILURE_PERF);
-		unregister_external_interrupt(0x1407, cpumf_measurement_alert);
+		unregister_external_irq(EXT_IRQ_MEASURE_ALERT,
+					cpumf_measurement_alert);
 		goto out;
 	}
 	perf_cpu_notifier(cpumf_pmu_notifier);
* Unmerged path arch/s390/kernel/runtime_instr.c
diff --git a/arch/s390/kernel/sclp.S b/arch/s390/kernel/sclp.S
index 29bd7bec4176..a41f2c99dcc8 100644
--- a/arch/s390/kernel/sclp.S
+++ b/arch/s390/kernel/sclp.S
@@ -9,6 +9,7 @@
  */
 
 #include <linux/linkage.h>
+#include <asm/irq.h>
 
 LC_EXT_NEW_PSW		= 0x58			# addr of ext int handler
 LC_EXT_NEW_PSW_64	= 0x1b0			# addr of ext int handler 64 bit
@@ -73,9 +74,9 @@ _sclp_wait_int:
 	lpsw	.LwaitpswS1-.LbaseS1(%r13)	# wait until interrupt
 .LwaitS1:
 	lh	%r7,LC_EXT_INT_CODE
-	chi	%r7,0x1004			# timeout?
+	chi	%r7,EXT_IRQ_CLK_COMP		# timeout?
 	je	.LtimeoutS1
-	chi	%r7,0x2401			# service int?
+	chi	%r7,EXT_IRQ_SERVICE_SIG		# service int?
 	jne	.LloopS1
 	sr	%r2,%r2
 	l	%r3,LC_EXT_INT_PARAM
diff --git a/arch/s390/kernel/smp.c b/arch/s390/kernel/smp.c
index 6055d9cfb3ce..1965bbc75b97 100644
--- a/arch/s390/kernel/smp.c
+++ b/arch/s390/kernel/smp.c
@@ -788,10 +788,10 @@ void __init smp_fill_possible_mask(void)
 void __init smp_prepare_cpus(unsigned int max_cpus)
 {
 	/* request the 0x1201 emergency signal external interrupt */
-	if (register_external_interrupt(0x1201, do_ext_call_interrupt) != 0)
+	if (register_external_irq(EXT_IRQ_EMERGENCY_SIG, do_ext_call_interrupt))
 		panic("Couldn't request external interrupt 0x1201");
 	/* request the 0x1202 external call external interrupt */
-	if (register_external_interrupt(0x1202, do_ext_call_interrupt) != 0)
+	if (register_external_irq(EXT_IRQ_EXTERNAL_CALL, do_ext_call_interrupt))
 		panic("Couldn't request external interrupt 0x1202");
 	smp_detect_cpus();
 }
diff --git a/arch/s390/kernel/time.c b/arch/s390/kernel/time.c
index dd95f1631621..386d37a228bb 100644
--- a/arch/s390/kernel/time.c
+++ b/arch/s390/kernel/time.c
@@ -262,11 +262,11 @@ void __init time_init(void)
 	stp_reset();
 
 	/* request the clock comparator external interrupt */
-	if (register_external_interrupt(0x1004, clock_comparator_interrupt))
-                panic("Couldn't request external interrupt 0x1004");
+	if (register_external_irq(EXT_IRQ_CLK_COMP, clock_comparator_interrupt))
+		panic("Couldn't request external interrupt 0x1004");
 
 	/* request the timing alert external interrupt */
-	if (register_external_interrupt(0x1406, timing_alert_interrupt))
+	if (register_external_irq(EXT_IRQ_TIMING_ALERT, timing_alert_interrupt))
 		panic("Couldn't request external interrupt 0x1406");
 
 	if (clocksource_register(&clocksource_tod) != 0)
diff --git a/arch/s390/mm/fault.c b/arch/s390/mm/fault.c
index aa05f5819cbb..2cfabdc4f3e5 100644
--- a/arch/s390/mm/fault.c
+++ b/arch/s390/mm/fault.c
@@ -604,7 +604,7 @@ static int __init pfault_irq_init(void)
 {
 	int rc;
 
-	rc = register_external_interrupt(0x2603, pfault_interrupt);
+	rc = register_external_irq(EXT_IRQ_CP_SERVICE, pfault_interrupt);
 	if (rc)
 		goto out_extint;
 	rc = pfault_init() == 0 ? 0 : -EOPNOTSUPP;
@@ -615,7 +615,7 @@ static int __init pfault_irq_init(void)
 	return 0;
 
 out_pfault:
-	unregister_external_interrupt(0x2603, pfault_interrupt);
+	unregister_external_irq(EXT_IRQ_CP_SERVICE, pfault_interrupt);
 out_extint:
 	pfault_disable = 1;
 	return rc;
diff --git a/arch/s390/oprofile/hwsampler.c b/arch/s390/oprofile/hwsampler.c
index 77fdde0f0aa9..3436b9075d64 100644
--- a/arch/s390/oprofile/hwsampler.c
+++ b/arch/s390/oprofile/hwsampler.c
@@ -1028,7 +1028,7 @@ int hwsampler_setup(void)
 				max_sampler_rate = cb->qsi.max_sampl_rate;
 		}
 	}
-	register_external_interrupt(0x1407, hws_ext_handler);
+	register_external_irq(EXT_IRQ_MEASURE_ALERT, hws_ext_handler);
 
 	hws_state = HWS_DEALLOCATED;
 	rc = 0;
@@ -1062,7 +1062,7 @@ int hwsampler_shutdown(void)
 			hws_wq = NULL;
 		}
 
-		unregister_external_interrupt(0x1407, hws_ext_handler);
+		unregister_external_irq(EXT_IRQ_MEASURE_ALERT, hws_ext_handler);
 		hws_state = HWS_INIT;
 		rc = 0;
 	}
* Unmerged path drivers/s390/block/dasd_diag.c
diff --git a/drivers/s390/char/sclp.c b/drivers/s390/char/sclp.c
index d5b6ef09fa60..c0e8d9a080d2 100644
--- a/drivers/s390/char/sclp.c
+++ b/drivers/s390/char/sclp.c
@@ -892,7 +892,7 @@ sclp_check_interface(void)
 
 	spin_lock_irqsave(&sclp_lock, flags);
 	/* Prepare init mask command */
-	rc = register_external_interrupt(0x2401, sclp_check_handler);
+	rc = register_external_irq(EXT_IRQ_SERVICE_SIG, sclp_check_handler);
 	if (rc) {
 		spin_unlock_irqrestore(&sclp_lock, flags);
 		return rc;
@@ -925,7 +925,7 @@ sclp_check_interface(void)
 		} else
 			rc = -EBUSY;
 	}
-	unregister_external_interrupt(0x2401, sclp_check_handler);
+	unregister_external_irq(EXT_IRQ_SERVICE_SIG, sclp_check_handler);
 	spin_unlock_irqrestore(&sclp_lock, flags);
 	return rc;
 }
@@ -1124,7 +1124,7 @@ sclp_init(void)
 	if (rc)
 		goto fail_init_state_uninitialized;
 	/* Register interrupt handler */
-	rc = register_external_interrupt(0x2401, sclp_interrupt_handler);
+	rc = register_external_irq(EXT_IRQ_SERVICE_SIG, sclp_interrupt_handler);
 	if (rc)
 		goto fail_unregister_reboot_notifier;
 	sclp_init_state = sclp_init_state_initialized;
* Unmerged path drivers/s390/kvm/kvm_virtio.c
diff --git a/net/iucv/iucv.c b/net/iucv/iucv.c
index cd5b8ec9be04..12afba10a61f 100644
--- a/net/iucv/iucv.c
+++ b/net/iucv/iucv.c
@@ -2016,7 +2016,7 @@ static int __init iucv_init(void)
 	rc = iucv_query_maxconn();
 	if (rc)
 		goto out_ctl;
-	rc = register_external_interrupt(0x4000, iucv_external_interrupt);
+	rc = register_external_irq(EXT_IRQ_IUCV, iucv_external_interrupt);
 	if (rc)
 		goto out_ctl;
 	iucv_root = root_device_register("iucv");
@@ -2081,7 +2081,7 @@ out_free:
 	}
 	root_device_unregister(iucv_root);
 out_int:
-	unregister_external_interrupt(0x4000, iucv_external_interrupt);
+	unregister_external_irq(EXT_IRQ_IUCV, iucv_external_interrupt);
 out_ctl:
 	ctl_clear_bit(0, 1);
 out:
@@ -2116,7 +2116,7 @@ static void __exit iucv_exit(void)
 	}
 	root_device_unregister(iucv_root);
 	bus_unregister(&iucv_bus);
-	unregister_external_interrupt(0x4000, iucv_external_interrupt);
+	unregister_external_irq(EXT_IRQ_IUCV, iucv_external_interrupt);
 }
 
 subsys_initcall(iucv_init);
