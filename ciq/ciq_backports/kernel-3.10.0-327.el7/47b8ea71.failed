cpusets, isolcpus: exclude isolcpus from load balancing in cpusets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kernel] cpusets: isolcpus: exclude isolcpus from load balancing in cpusets (Rik van Riel) [1194687]
Rebuild_FUZZ: 98.48%
commit-author Rik van Riel <riel@redhat.com>
commit 47b8ea7186aae7f474ec4c98f43eaa8da719cd83
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/47b8ea71.failed

Ensure that cpus specified with the isolcpus= boot commandline
option stay outside of the load balancing in the kernel scheduler.

Operations like load balancing can introduce unwanted latencies,
which is exactly what the isolcpus= commandline is there to prevent.

Previously, simply creating a new cpuset, without even touching the
cpuset.cpus field inside the new cpuset, would undo the effects of
isolcpus=, by creating a scheduler domain spanning the whole system,
and setting up load balancing inside that domain. The cpuset root
cpuset.cpus file is read-only, so there was not even a way to undo
that effect.

This does not impact the majority of cpusets users, since isolcpus=
is a fairly specialized feature used for realtime purposes.

	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Clark Williams <williams@redhat.com>
	Cc: Li Zefan <lizefan@huawei.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Luiz Capitulino <lcapitulino@redhat.com>
	Cc: Mike Galbraith <umgwanakikbuti@gmail.com>
	Cc: cgroups@vger.kernel.org
	Signed-off-by: Rik van Riel <riel@redhat.com>
	Tested-by: David Rientjes <rientjes@google.com>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Acked-by: David Rientjes <rientjes@google.com>
	Acked-by: Zefan Li <lizefan@huawei.com>
	Signed-off-by: Tejun Heo <tj@kernel.org>
(cherry picked from commit 47b8ea7186aae7f474ec4c98f43eaa8da719cd83)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/cpuset.c
diff --cc kernel/cpuset.c
index 37ee6fa4e721,c68f0721df10..000000000000
--- a/kernel/cpuset.c
+++ b/kernel/cpuset.c
@@@ -617,7 -648,8 +622,12 @@@ static int generate_sched_domains(cpuma
  			*dattr = SD_ATTR_INIT;
  			update_domain_attr_tree(dattr, &top_cpuset);
  		}
++<<<<<<< HEAD
 +		cpumask_copy(doms[0], top_cpuset.cpus_allowed);
++=======
+ 		cpumask_and(doms[0], top_cpuset.effective_cpus,
+ 				     non_isolated_cpus);
++>>>>>>> 47b8ea7186aa (cpusets, isolcpus: exclude isolcpus from load balancing in cpusets)
  
  		goto done;
  	}
@@@ -722,7 -754,8 +733,12 @@@ restart
  			struct cpuset *b = csa[j];
  
  			if (apn == b->pn) {
++<<<<<<< HEAD
 +				cpumask_or(dp, dp, b->cpus_allowed);
++=======
+ 				cpumask_or(dp, dp, b->effective_cpus);
+ 				cpumask_and(dp, dp, non_isolated_cpus);
++>>>>>>> 47b8ea7186aa (cpusets, isolcpus: exclude isolcpus from load balancing in cpusets)
  				if (dattr)
  					update_domain_attr_tree(dattr + nslot, b);
  
* Unmerged path kernel/cpuset.c
