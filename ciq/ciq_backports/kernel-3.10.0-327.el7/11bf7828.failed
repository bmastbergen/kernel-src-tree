vxlan: Inline vxlan_gso_check().

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Joe Stringer <joestringer@nicira.com>
commit 11bf7828a59880427403e13dcff8228d67e9e0f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/11bf7828.failed

	Suggested-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Joe Stringer <joestringer@nicira.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 11bf7828a59880427403e13dcff8228d67e9e0f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	include/net/vxlan.h
diff --cc drivers/net/vxlan.c
index 4d5ed907f617,e1e335c339e3..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1570,15 -1565,8 +1564,18 @@@ static bool route_shortcircuit(struct n
  	return false;
  }
  
++<<<<<<< HEAD
 +static inline struct sk_buff *vxlan_handle_offloads(struct sk_buff *skb,
 +						    bool udp_csum)
 +{
 +	int type = udp_csum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
 +	return iptunnel_handle_offloads(skb, udp_csum, type);
 +}
 +
++=======
++>>>>>>> 11bf7828a598 (vxlan: Inline vxlan_gso_check().)
  #if IS_ENABLED(CONFIG_IPV6)
 -static int vxlan6_xmit_skb(struct vxlan_sock *vs,
 +static int vxlan6_xmit_skb(struct net *net, struct vxlan_sock *vs,
  			   struct dst_entry *dst, struct sk_buff *skb,
  			   struct net_device *dev, struct in6_addr *saddr,
  			   struct in6_addr *daddr, __u8 prio, __u8 ttl,
diff --cc include/net/vxlan.h
index 1ddc74769f81,57cccd0052e5..000000000000
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@@ -40,10 -46,22 +46,26 @@@ struct vxlan_sock *vxlan_sock_add(struc
  
  void vxlan_sock_release(struct vxlan_sock *vs);
  
 -int vxlan_xmit_skb(struct vxlan_sock *vs,
 +int vxlan_xmit_skb(struct net *net, struct vxlan_sock *vs,
  		   struct rtable *rt, struct sk_buff *skb,
  		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
++<<<<<<< HEAD
 +		   __be16 src_port, __be16 dst_port, __be32 vni);
++=======
+ 		   __be16 src_port, __be16 dst_port, __be32 vni, bool xnet);
+ 
+ static inline bool vxlan_gso_check(struct sk_buff *skb)
+ {
+ 	if ((skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL) &&
+ 	    (skb->inner_protocol_type != ENCAP_TYPE_ETHER ||
+ 	     skb->inner_protocol != htons(ETH_P_TEB) ||
+ 	     (skb_inner_mac_header(skb) - skb_transport_header(skb) !=
+ 	      sizeof(struct udphdr) + sizeof(struct vxlanhdr))))
+ 		return false;
+ 
+ 	return true;
+ }
++>>>>>>> 11bf7828a598 (vxlan: Inline vxlan_gso_check().)
  
  /* IP header + UDP + VXLAN + Ethernet header */
  #define VXLAN_HEADROOM (20 + 8 + 8 + 14)
* Unmerged path drivers/net/vxlan.c
* Unmerged path include/net/vxlan.h
