fib_trie: Prevent allocating tnode if bits is too big for size_t

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 1de3d87bcd2c2e631500b9e4f0c40b38ce0d0d57
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1de3d87b.failed

This patch adds code to prevent us from attempting to allocate a tnode with
a size larger than what can be represented by size_t.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1de3d87bcd2c2e631500b9e4f0c40b38ce0d0d57)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 3fe26090641a,fae34ad4bb1a..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -274,7 -276,9 +274,13 @@@ static inline void alias_free_mem_rcu(s
  }
  
  #define TNODE_KMALLOC_MAX \
++<<<<<<< HEAD
 +	ilog2((PAGE_SIZE - sizeof(struct tnode)) / sizeof(struct tnode *))
++=======
+ 	ilog2((PAGE_SIZE - TNODE_SIZE(0)) / sizeof(struct tnode *))
+ #define TNODE_VMALLOC_MAX \
+ 	ilog2((SIZE_MAX - TNODE_SIZE(0)) / sizeof(struct tnode *))
++>>>>>>> 1de3d87bcd2c (fib_trie: Prevent allocating tnode if bits is too big for size_t)
  
  static void __node_free_rcu(struct rcu_head *head)
  {
@@@ -290,13 -294,17 +296,26 @@@
  
  #define node_free(n) call_rcu(&n->rcu, __node_free_rcu)
  
++<<<<<<< HEAD
 +static inline void free_leaf_info(struct leaf_info *leaf)
 +{
 +	kfree_rcu(leaf, rcu);
 +}
 +
 +static struct tnode *tnode_alloc(size_t size)
++=======
+ static struct tnode *tnode_alloc(int bits)
++>>>>>>> 1de3d87bcd2c (fib_trie: Prevent allocating tnode if bits is too big for size_t)
  {
+ 	size_t size;
+ 
+ 	/* verify bits is within bounds */
+ 	if (bits > TNODE_VMALLOC_MAX)
+ 		return NULL;
+ 
+ 	/* determine size and verify it is non-zero and didn't overflow */
+ 	size = TNODE_SIZE(1ul << bits);
+ 
  	if (size <= PAGE_SIZE)
  		return kzalloc(size, GFP_KERNEL);
  	else
@@@ -333,21 -343,9 +352,25 @@@ static struct tnode *leaf_new(t_key key
  	return l;
  }
  
 +static struct leaf_info *leaf_info_new(int plen)
 +{
 +	struct leaf_info *li = kmalloc(sizeof(struct leaf_info),  GFP_KERNEL);
 +	if (li) {
 +		li->plen = plen;
 +		li->mask_plen = ntohl(inet_make_mask(plen));
 +		INIT_LIST_HEAD(&li->falh);
 +	}
 +	return li;
 +}
 +
  static struct tnode *tnode_new(t_key key, int pos, int bits)
  {
++<<<<<<< HEAD
 +	size_t sz = offsetof(struct tnode, child[1ul << bits]);
 +	struct tnode *tn = tnode_alloc(sz);
++=======
+ 	struct tnode *tn = tnode_alloc(bits);
++>>>>>>> 1de3d87bcd2c (fib_trie: Prevent allocating tnode if bits is too big for size_t)
  	unsigned int shift = pos + bits;
  
  	/* verify bits and pos their msb bits clear and values are valid */
* Unmerged path net/ipv4/fib_trie.c
