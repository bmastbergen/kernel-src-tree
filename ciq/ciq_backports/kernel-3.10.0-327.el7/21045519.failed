scsi: use per-cpu buffer for formatting sense

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] use per-cpu buffer for formatting sense (Ewan Milne) [1124082]
Rebuild_FUZZ: 92.86%
commit-author Hannes Reinecke <hare@suse.de>
commit 2104551969e8011e72788dc5674609d437448cf6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/21045519.failed

Convert sense buffer logging to use the per-cpu buffer to avoid line
breakup.

	Tested-by: Robert Elliott <elliott@hp.com>
	Reviewed-by: Robert Elliott <elliott@hp.com>
	Signed-off-by: Hannes Reinecke <hare@suse.de>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 2104551969e8011e72788dc5674609d437448cf6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/constants.c
#	drivers/scsi/scsi_logging.c
#	drivers/scsi/sd.c
#	drivers/scsi/ufs/ufshcd.c
diff --cc drivers/scsi/constants.c
index cd7131c88f5d,a23ef75533d6..000000000000
--- a/drivers/scsi/constants.c
+++ b/drivers/scsi/constants.c
@@@ -1296,181 -1246,6 +1296,184 @@@ scsi_extd_sense_format(unsigned char as
  }
  EXPORT_SYMBOL(scsi_extd_sense_format);
  
++<<<<<<< HEAD
 +void
 +scsi_show_extd_sense(unsigned char asc, unsigned char ascq)
 +{
 +        const char *extd_sense_fmt = scsi_extd_sense_format(asc, ascq);
 +
 +	if (extd_sense_fmt) {
 +		if (strstr(extd_sense_fmt, "%x")) {
 +			printk("Add. Sense: ");
 +			printk(extd_sense_fmt, ascq);
 +		} else
 +			printk("Add. Sense: %s", extd_sense_fmt);
 +	} else {
 +		if (asc >= 0x80)
 +			printk("<<vendor>> ASC=0x%x ASCQ=0x%x", asc,
 +			       ascq);
 +		if (ascq >= 0x80)
 +			printk("ASC=0x%x <<vendor>> ASCQ=0x%x", asc,
 +			       ascq);
 +		else
 +			printk("ASC=0x%x ASCQ=0x%x", asc, ascq);
 +	}
 +
 +	printk("\n");
 +}
 +EXPORT_SYMBOL(scsi_show_extd_sense);
 +
 +void
 +scsi_show_sense_hdr(struct scsi_sense_hdr *sshdr)
 +{
 +	const char *sense_txt;
 +
 +	sense_txt = scsi_sense_key_string(sshdr->sense_key);
 +	if (sense_txt)
 +		printk("Sense Key : %s ", sense_txt);
 +	else
 +		printk("Sense Key : 0x%x ", sshdr->sense_key);
 +
 +	printk("%s", scsi_sense_is_deferred(sshdr) ? "[deferred] " :
 +	       "[current] ");
 +
 +	if (sshdr->response_code >= 0x72)
 +		printk("[descriptor]");
 +
 +	printk("\n");
 +}
 +EXPORT_SYMBOL(scsi_show_sense_hdr);
 +
 +/*
 + * Print normalized SCSI sense header with a prefix.
 + */
 +void
 +scsi_print_sense_hdr(const char *name, struct scsi_sense_hdr *sshdr)
 +{
 +	printk(KERN_INFO "%s: ", name);
 +	scsi_show_sense_hdr(sshdr);
 +	printk(KERN_INFO "%s: ", name);
 +	scsi_show_extd_sense(sshdr->asc, sshdr->ascq);
 +}
 +EXPORT_SYMBOL(scsi_print_sense_hdr);
 +
 +static void
 +scsi_decode_sense_buffer(const unsigned char *sense_buffer, int sense_len,
 +		       struct scsi_sense_hdr *sshdr)
 +{
 +	int k, num, res;
 +
 +	res = scsi_normalize_sense(sense_buffer, sense_len, sshdr);
 +	if (0 == res) {
 +		/* this may be SCSI-1 sense data */
 +		num = (sense_len < 32) ? sense_len : 32;
 +		printk("Unrecognized sense data (in hex):");
 +		for (k = 0; k < num; ++k) {
 +			if (0 == (k % 16)) {
 +				printk("\n");
 +				printk(KERN_INFO "        ");
 +			}
 +			printk("%02x ", sense_buffer[k]);
 +		}
 +		printk("\n");
 +		return;
 +	}
 +}
 +
 +static void
 +scsi_decode_sense_extras(const unsigned char *sense_buffer, int sense_len,
 +			 struct scsi_sense_hdr *sshdr)
 +{
 +	int k, num, res;
 +
 +	if (sshdr->response_code < 0x72)
 +	{
 +		/* only decode extras for "fixed" format now */
 +		char buff[80];
 +		int blen, fixed_valid;
 +		unsigned int info;
 +
 +		fixed_valid = sense_buffer[0] & 0x80;
 +		info = ((sense_buffer[3] << 24) | (sense_buffer[4] << 16) |
 +			(sense_buffer[5] << 8) | sense_buffer[6]);
 +		res = 0;
 +		memset(buff, 0, sizeof(buff));
 +		blen = sizeof(buff) - 1;
 +		if (fixed_valid)
 +			res += snprintf(buff + res, blen - res,
 +					"Info fld=0x%x", info);
 +		if (sense_buffer[2] & 0x80) {
 +			/* current command has read a filemark */
 +			if (res > 0)
 +				res += snprintf(buff + res, blen - res, ", ");
 +			res += snprintf(buff + res, blen - res, "FMK");
 +		}
 +		if (sense_buffer[2] & 0x40) {
 +			/* end-of-medium condition exists */
 +			if (res > 0)
 +				res += snprintf(buff + res, blen - res, ", ");
 +			res += snprintf(buff + res, blen - res, "EOM");
 +		}
 +		if (sense_buffer[2] & 0x20) {
 +			/* incorrect block length requested */
 +			if (res > 0)
 +				res += snprintf(buff + res, blen - res, ", ");
 +			res += snprintf(buff + res, blen - res, "ILI");
 +		}
 +		if (res > 0)
 +			printk("%s\n", buff);
 +	} else if (sshdr->additional_length > 0) {
 +		/* descriptor format with sense descriptors */
 +		num = 8 + sshdr->additional_length;
 +		num = (sense_len < num) ? sense_len : num;
 +		printk("Descriptor sense data with sense descriptors "
 +		       "(in hex):");
 +		for (k = 0; k < num; ++k) {
 +			if (0 == (k % 16)) {
 +				printk("\n");
 +				printk(KERN_INFO "        ");
 +			}
 +			printk("%02x ", sense_buffer[k]);
 +		}
 +
 +		printk("\n");
 +	}
 +
 +}
 +
 +/* Normalize and print sense buffer with name prefix */
 +void __scsi_print_sense(const char *name, const unsigned char *sense_buffer,
 +			int sense_len)
 +{
 +	struct scsi_sense_hdr sshdr;
 +
 +	printk(KERN_INFO "%s: ", name);
 +	scsi_decode_sense_buffer(sense_buffer, sense_len, &sshdr);
 +	scsi_show_sense_hdr(&sshdr);
 +	scsi_decode_sense_extras(sense_buffer, sense_len, &sshdr);
 +	printk(KERN_INFO "%s: ", name);
 +	scsi_show_extd_sense(sshdr.asc, sshdr.ascq);
 +}
 +EXPORT_SYMBOL(__scsi_print_sense);
 +
 +/* Normalize and print sense buffer in SCSI command */
 +void scsi_print_sense(char *name, struct scsi_cmnd *cmd)
 +{
 +	struct scsi_sense_hdr sshdr;
 +
 +	scmd_printk(KERN_INFO, cmd, " ");
 +	scsi_decode_sense_buffer(cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE,
 +				 &sshdr);
 +	scsi_show_sense_hdr(&sshdr);
 +	scsi_decode_sense_extras(cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE,
 +				 &sshdr);
 +	scmd_printk(KERN_INFO, cmd, " ");
 +	scsi_show_extd_sense(sshdr.asc, sshdr.ascq);
 +}
 +EXPORT_SYMBOL(scsi_print_sense);
 +
++=======
++>>>>>>> 2104551969e8 (scsi: use per-cpu buffer for formatting sense)
  #ifdef CONFIG_SCSI_CONSTANTS
  
  static const char * const hostbyte_table[]={
diff --cc drivers/scsi/scsi_logging.c
index 4d20132c897d,c7cba3113f31..000000000000
--- a/drivers/scsi/scsi_logging.c
+++ b/drivers/scsi/scsi_logging.c
@@@ -69,6 -69,30 +69,33 @@@ static void scsi_log_release_buffer(cha
  	preempt_enable();
  }
  
++<<<<<<< HEAD
++=======
+ static inline const char *scmd_name(const struct scsi_cmnd *scmd)
+ {
+ 	return scmd->request->rq_disk ?
+ 		scmd->request->rq_disk->disk_name : NULL;
+ }
+ 
+ static size_t sdev_format_header(char *logbuf, size_t logbuf_len,
+ 				 const char *name, int tag)
+ {
+ 	size_t off = 0;
+ 
+ 	if (name)
+ 		off += scnprintf(logbuf + off, logbuf_len - off,
+ 				 "[%s] ", name);
+ 
+ 	if (WARN_ON(off >= logbuf_len))
+ 		return off;
+ 
+ 	if (tag >= 0)
+ 		off += scnprintf(logbuf + off, logbuf_len - off,
+ 				 "tag#%d ", tag);
+ 	return off;
+ }
+ 
++>>>>>>> 2104551969e8 (scsi: use per-cpu buffer for formatting sense)
  int sdev_prefix_printk(const char *level, const struct scsi_device *sdev,
  		       const char *name, const char *fmt, ...)
  {
@@@ -111,18 -136,295 +137,311 @@@ int scmd_printk(const char *level, cons
  	logbuf = scsi_log_reserve_buffer(&logbuf_len);
  	if (!logbuf)
  		return 0;
++<<<<<<< HEAD
 +	if (disk)
 +		off += scnprintf(logbuf + off, logbuf_len - off,
 +				 "[%s] ", disk->disk_name);
 +
 +	if (scmd->request->tag >= 0)
 +		off += scnprintf(logbuf + off, logbuf_len - off,
 +				 "tag#%d ", scmd->request->tag);
 +	va_start(args, fmt);
 +	off += vscnprintf(logbuf + off, logbuf_len - off, fmt, args);
 +	va_end(args);
++=======
+ 	off = sdev_format_header(logbuf, logbuf_len, scmd_name(scmd),
+ 				 scmd->request->tag);
+ 	if (off < logbuf_len) {
+ 		va_start(args, fmt);
+ 		off += vscnprintf(logbuf + off, logbuf_len - off, fmt, args);
+ 		va_end(args);
+ 	}
++>>>>>>> 2104551969e8 (scsi: use per-cpu buffer for formatting sense)
  	ret = dev_printk(level, &scmd->device->sdev_gendev, "%s", logbuf);
  	scsi_log_release_buffer(logbuf);
  	return ret;
  }
  EXPORT_SYMBOL(scmd_printk);
++<<<<<<< HEAD
++=======
+ 
+ static size_t scsi_format_opcode_name(char *buffer, size_t buf_len,
+ 				      const unsigned char *cdbp)
+ {
+ 	int sa, cdb0;
+ 	const char *cdb_name = NULL, *sa_name = NULL;
+ 	size_t off;
+ 
+ 	cdb0 = cdbp[0];
+ 	if (cdb0 == VARIABLE_LENGTH_CMD) {
+ 		int len = scsi_varlen_cdb_length(cdbp);
+ 
+ 		if (len < 10) {
+ 			off = scnprintf(buffer, buf_len,
+ 					"short variable length command, len=%d",
+ 					len);
+ 			return off;
+ 		}
+ 		sa = (cdbp[8] << 8) + cdbp[9];
+ 	} else
+ 		sa = cdbp[1] & 0x1f;
+ 
+ 	if (!scsi_opcode_sa_name(cdb0, sa, &cdb_name, &sa_name)) {
+ 		if (cdb_name)
+ 			off = scnprintf(buffer, buf_len, "%s", cdb_name);
+ 		else {
+ 			off = scnprintf(buffer, buf_len, "opcode=0x%x", cdb0);
+ 			if (WARN_ON(off >= buf_len))
+ 				return off;
+ 			if (cdb0 >= VENDOR_SPECIFIC_CDB)
+ 				off += scnprintf(buffer + off, buf_len - off,
+ 						 " (vendor)");
+ 			else if (cdb0 >= 0x60 && cdb0 < 0x7e)
+ 				off += scnprintf(buffer + off, buf_len - off,
+ 						 " (reserved)");
+ 		}
+ 	} else {
+ 		if (sa_name)
+ 			off = scnprintf(buffer, buf_len, "%s", sa_name);
+ 		else if (cdb_name)
+ 			off = scnprintf(buffer, buf_len, "%s, sa=0x%x",
+ 					cdb_name, sa);
+ 		else
+ 			off = scnprintf(buffer, buf_len,
+ 					"opcode=0x%x, sa=0x%x", cdb0, sa);
+ 	}
+ 	WARN_ON(off >= buf_len);
+ 	return off;
+ }
+ 
+ size_t __scsi_format_command(char *logbuf, size_t logbuf_len,
+ 			     const unsigned char *cdb, size_t cdb_len)
+ {
+ 	int len, k;
+ 	size_t off;
+ 
+ 	off = scsi_format_opcode_name(logbuf, logbuf_len, cdb);
+ 	if (off >= logbuf_len)
+ 		return off;
+ 	len = scsi_command_size(cdb);
+ 	if (cdb_len < len)
+ 		len = cdb_len;
+ 	/* print out all bytes in cdb */
+ 	for (k = 0; k < len; ++k) {
+ 		if (off > logbuf_len - 3)
+ 			break;
+ 		off += scnprintf(logbuf + off, logbuf_len - off,
+ 				 " %02x", cdb[k]);
+ 	}
+ 	return off;
+ }
+ EXPORT_SYMBOL(__scsi_format_command);
+ 
+ void scsi_print_command(struct scsi_cmnd *cmd)
+ {
+ 	int k;
+ 	char *logbuf;
+ 	size_t off, logbuf_len;
+ 
+ 	if (!cmd->cmnd)
+ 		return;
+ 
+ 	logbuf = scsi_log_reserve_buffer(&logbuf_len);
+ 	if (!logbuf)
+ 		return;
+ 
+ 	off = sdev_format_header(logbuf, logbuf_len,
+ 				 scmd_name(cmd), cmd->request->tag);
+ 	if (off >= logbuf_len)
+ 		goto out_printk;
+ 	off += scnprintf(logbuf + off, logbuf_len - off, "CDB: ");
+ 	if (WARN_ON(off >= logbuf_len))
+ 		goto out_printk;
+ 
+ 	off += scsi_format_opcode_name(logbuf + off, logbuf_len - off,
+ 				       cmd->cmnd);
+ 	if (off >= logbuf_len)
+ 		goto out_printk;
+ 
+ 	/* print out all bytes in cdb */
+ 	if (cmd->cmd_len > 16) {
+ 		/* Print opcode in one line and use separate lines for CDB */
+ 		off += scnprintf(logbuf + off, logbuf_len - off, "\n");
+ 		dev_printk(KERN_INFO, &cmd->device->sdev_gendev, logbuf);
+ 		scsi_log_release_buffer(logbuf);
+ 		for (k = 0; k < cmd->cmd_len; k += 16) {
+ 			size_t linelen = min(cmd->cmd_len - k, 16);
+ 
+ 			logbuf = scsi_log_reserve_buffer(&logbuf_len);
+ 			if (!logbuf)
+ 				break;
+ 			off = sdev_format_header(logbuf, logbuf_len,
+ 						 scmd_name(cmd),
+ 						 cmd->request->tag);
+ 			if (!WARN_ON(off > logbuf_len - 58)) {
+ 				off += scnprintf(logbuf + off, logbuf_len - off,
+ 						 "CDB[%02x]: ", k);
+ 				hex_dump_to_buffer(&cmd->cmnd[k], linelen,
+ 						   16, 1, logbuf + off,
+ 						   logbuf_len - off, false);
+ 			}
+ 			dev_printk(KERN_INFO, &cmd->device->sdev_gendev,
+ 				   logbuf);
+ 			scsi_log_release_buffer(logbuf);
+ 		}
+ 		return;
+ 	}
+ 	if (!WARN_ON(off > logbuf_len - 49)) {
+ 		off += scnprintf(logbuf + off, logbuf_len - off, " ");
+ 		hex_dump_to_buffer(cmd->cmnd, cmd->cmd_len, 16, 1,
+ 				   logbuf + off, logbuf_len - off,
+ 				   false);
+ 	}
+ out_printk:
+ 	dev_printk(KERN_INFO, &cmd->device->sdev_gendev, logbuf);
+ 	scsi_log_release_buffer(logbuf);
+ }
+ EXPORT_SYMBOL(scsi_print_command);
+ 
+ static size_t
+ scsi_format_extd_sense(char *buffer, size_t buf_len,
+ 		       unsigned char asc, unsigned char ascq)
+ {
+ 	size_t off = 0;
+ 	const char *extd_sense_fmt = NULL;
+ 	const char *extd_sense_str = scsi_extd_sense_format(asc, ascq,
+ 							    &extd_sense_fmt);
+ 
+ 	if (extd_sense_str) {
+ 		off = scnprintf(buffer, buf_len, "Add. Sense: %s",
+ 				extd_sense_str);
+ 		if (extd_sense_fmt)
+ 			off += scnprintf(buffer + off, buf_len - off,
+ 					 "(%s%x)", extd_sense_fmt, ascq);
+ 	} else {
+ 		if (asc >= 0x80)
+ 			off = scnprintf(buffer, buf_len, "<<vendor>>");
+ 		off += scnprintf(buffer + off, buf_len - off,
+ 				 "ASC=0x%x ", asc);
+ 		if (ascq >= 0x80)
+ 			off += scnprintf(buffer + off, buf_len - off,
+ 					 "<<vendor>>");
+ 		off += scnprintf(buffer + off, buf_len - off,
+ 				 "ASCQ=0x%x ", ascq);
+ 	}
+ 	return off;
+ }
+ 
+ static size_t
+ scsi_format_sense_hdr(char *buffer, size_t buf_len,
+ 		      const struct scsi_sense_hdr *sshdr)
+ {
+ 	const char *sense_txt;
+ 	size_t off;
+ 
+ 	off = scnprintf(buffer, buf_len, "Sense Key : ");
+ 	sense_txt = scsi_sense_key_string(sshdr->sense_key);
+ 	if (sense_txt)
+ 		off += scnprintf(buffer + off, buf_len - off,
+ 				 "%s ", sense_txt);
+ 	else
+ 		off += scnprintf(buffer + off, buf_len - off,
+ 				 "0x%x ", sshdr->sense_key);
+ 	off += scnprintf(buffer + off, buf_len - off,
+ 		scsi_sense_is_deferred(sshdr) ? "[deferred] " : "[current] ");
+ 
+ 	if (sshdr->response_code >= 0x72)
+ 		off += scnprintf(buffer + off, buf_len - off, "[descriptor] ");
+ 	return off;
+ }
+ 
+ static void
+ scsi_log_dump_sense(const struct scsi_device *sdev, const char *name, int tag,
+ 		    const unsigned char *sense_buffer, int sense_len)
+ {
+ 	char *logbuf;
+ 	size_t logbuf_len;
+ 	int i;
+ 
+ 	logbuf = scsi_log_reserve_buffer(&logbuf_len);
+ 	if (!logbuf)
+ 		return;
+ 
+ 	for (i = 0; i < sense_len; i += 16) {
+ 		int len = min(sense_len - i, 16);
+ 		size_t off;
+ 
+ 		off = sdev_format_header(logbuf, logbuf_len,
+ 					 name, tag);
+ 		hex_dump_to_buffer(&sense_buffer[i], len, 16, 1,
+ 				   logbuf + off, logbuf_len - off,
+ 				   false);
+ 		dev_printk(KERN_INFO, &sdev->sdev_gendev, logbuf);
+ 	}
+ 	scsi_log_release_buffer(logbuf);
+ }
+ 
+ static void
+ scsi_log_print_sense_hdr(const struct scsi_device *sdev, const char *name,
+ 			 int tag, const struct scsi_sense_hdr *sshdr)
+ {
+ 	char *logbuf;
+ 	size_t off, logbuf_len;
+ 
+ 	logbuf = scsi_log_reserve_buffer(&logbuf_len);
+ 	if (!logbuf)
+ 		return;
+ 	off = sdev_format_header(logbuf, logbuf_len, name, tag);
+ 	off += scsi_format_sense_hdr(logbuf + off, logbuf_len - off, sshdr);
+ 	dev_printk(KERN_INFO, &sdev->sdev_gendev, logbuf);
+ 	scsi_log_release_buffer(logbuf);
+ 
+ 	logbuf = scsi_log_reserve_buffer(&logbuf_len);
+ 	if (!logbuf)
+ 		return;
+ 	off = sdev_format_header(logbuf, logbuf_len, name, tag);
+ 	off += scsi_format_extd_sense(logbuf + off, logbuf_len - off,
+ 				      sshdr->asc, sshdr->ascq);
+ 	dev_printk(KERN_INFO, &sdev->sdev_gendev, logbuf);
+ 	scsi_log_release_buffer(logbuf);
+ }
+ 
+ static void
+ scsi_log_print_sense(const struct scsi_device *sdev, const char *name, int tag,
+ 		     const unsigned char *sense_buffer, int sense_len)
+ {
+ 	struct scsi_sense_hdr sshdr;
+ 
+ 	if (scsi_normalize_sense(sense_buffer, sense_len, &sshdr))
+ 		scsi_log_print_sense_hdr(sdev, name, tag, &sshdr);
+ 	else
+ 		scsi_log_dump_sense(sdev, name, tag, sense_buffer, sense_len);
+ }
+ 
+ /*
+  * Print normalized SCSI sense header with a prefix.
+  */
+ void
+ scsi_print_sense_hdr(const struct scsi_device *sdev, const char *name,
+ 		     const struct scsi_sense_hdr *sshdr)
+ {
+ 	scsi_log_print_sense_hdr(sdev, name, -1, sshdr);
+ }
+ EXPORT_SYMBOL(scsi_print_sense_hdr);
+ 
+ /* Normalize and print sense buffer with name prefix */
+ void __scsi_print_sense(const struct scsi_device *sdev, const char *name,
+ 			const unsigned char *sense_buffer, int sense_len)
+ {
+ 	scsi_log_print_sense(sdev, name, -1, sense_buffer, sense_len);
+ }
+ EXPORT_SYMBOL(__scsi_print_sense);
+ 
+ /* Normalize and print sense buffer in SCSI command */
+ void scsi_print_sense(const struct scsi_cmnd *cmd)
+ {
+ 	scsi_log_print_sense(cmd->device, scmd_name(cmd), cmd->request->tag,
+ 			     cmd->sense_buffer, SCSI_SENSE_BUFFERSIZE);
+ }
+ EXPORT_SYMBOL(scsi_print_sense);
++>>>>>>> 2104551969e8 (scsi: use per-cpu buffer for formatting sense)
diff --cc drivers/scsi/sd.c
index 70b68764775a,ebf35cb64216..000000000000
--- a/drivers/scsi/sd.c
+++ b/drivers/scsi/sd.c
@@@ -3233,15 -3318,24 +3233,20 @@@ module_exit(exit_sd)
  static void sd_print_sense_hdr(struct scsi_disk *sdkp,
  			       struct scsi_sense_hdr *sshdr)
  {
++<<<<<<< HEAD
 +	sd_printk(KERN_INFO, sdkp, " ");
 +	scsi_show_sense_hdr(sshdr);
 +	sd_printk(KERN_INFO, sdkp, " ");
 +	scsi_show_extd_sense(sshdr->asc, sshdr->ascq);
++=======
+ 	scsi_print_sense_hdr(sdkp->device,
+ 			     sdkp->disk ? sdkp->disk->disk_name : NULL, sshdr);
++>>>>>>> 2104551969e8 (scsi: use per-cpu buffer for formatting sense)
  }
  
 -static void sd_print_result(const struct scsi_disk *sdkp, const char *msg,
 -			    int result)
 +static void sd_print_result(struct scsi_disk *sdkp, int result)
  {
 -	const char *hb_string = scsi_hostbyte_string(result);
 -	const char *db_string = scsi_driverbyte_string(result);
 -
 -	if (hb_string || db_string)
 -		sd_printk(KERN_INFO, sdkp,
 -			  "%s: Result: hostbyte=%s driverbyte=%s\n", msg,
 -			  hb_string ? hb_string : "invalid",
 -			  db_string ? db_string : "invalid");
 -	else
 -		sd_printk(KERN_INFO, sdkp,
 -			  "%s: Result: hostbyte=0x%02x driverbyte=0x%02x\n",
 -			  msg, host_byte(result), driver_byte(result));
 +	sd_printk(KERN_INFO, sdkp, " ");
 +	scsi_show_result(result);
  }
  
diff --cc drivers/scsi/ufs/ufshcd.c
index c32a478df81b,5d60a868830d..000000000000
--- a/drivers/scsi/ufs/ufshcd.c
+++ b/drivers/scsi/ufs/ufshcd.c
@@@ -1509,75 -3830,1402 +1509,183 @@@ out
  	return err;
  }
  
 -/**
 - * ufshcd_get_max_icc_level - calculate the ICC level
 - * @sup_curr_uA: max. current supported by the regulator
 - * @start_scan: row at the desc table to start scan from
 - * @buff: power descriptor buffer
 - *
 - * Returns calculated max ICC level for specific regulator
 - */
 -static u32 ufshcd_get_max_icc_level(int sup_curr_uA, u32 start_scan, char *buff)
 -{
 -	int i;
 -	int curr_uA;
 -	u16 data;
 -	u16 unit;
 -
 -	for (i = start_scan; i >= 0; i--) {
 -		data = be16_to_cpu(*((u16 *)(buff + 2*i)));
 -		unit = (data & ATTR_ICC_LVL_UNIT_MASK) >>
 -						ATTR_ICC_LVL_UNIT_OFFSET;
 -		curr_uA = data & ATTR_ICC_LVL_VALUE_MASK;
 -		switch (unit) {
 -		case UFSHCD_NANO_AMP:
 -			curr_uA = curr_uA / 1000;
 -			break;
 -		case UFSHCD_MILI_AMP:
 -			curr_uA = curr_uA * 1000;
 -			break;
 -		case UFSHCD_AMP:
 -			curr_uA = curr_uA * 1000 * 1000;
 -			break;
 -		case UFSHCD_MICRO_AMP:
 -		default:
 -			break;
 -		}
 -		if (sup_curr_uA >= curr_uA)
 -			break;
 -	}
 -	if (i < 0) {
 -		i = 0;
 -		pr_err("%s: Couldn't find valid icc_level = %d", __func__, i);
 -	}
 -
 -	return (u32)i;
 -}
 -
 -/**
 - * ufshcd_calc_icc_level - calculate the max ICC level
 - * In case regulators are not initialized we'll return 0
 - * @hba: per-adapter instance
 - * @desc_buf: power descriptor buffer to extract ICC levels from.
 - * @len: length of desc_buff
 - *
 - * Returns calculated ICC level
 - */
 -static u32 ufshcd_find_max_sup_active_icc_level(struct ufs_hba *hba,
 -							u8 *desc_buf, int len)
 -{
 -	u32 icc_level = 0;
 -
 -	if (!hba->vreg_info.vcc || !hba->vreg_info.vccq ||
 -						!hba->vreg_info.vccq2) {
 -		dev_err(hba->dev,
 -			"%s: Regulator capability was not set, actvIccLevel=%d",
 -							__func__, icc_level);
 -		goto out;
 -	}
 -
 -	if (hba->vreg_info.vcc)
 -		icc_level = ufshcd_get_max_icc_level(
 -				hba->vreg_info.vcc->max_uA,
 -				POWER_DESC_MAX_ACTV_ICC_LVLS - 1,
 -				&desc_buf[PWR_DESC_ACTIVE_LVLS_VCC_0]);
 -
 -	if (hba->vreg_info.vccq)
 -		icc_level = ufshcd_get_max_icc_level(
 -				hba->vreg_info.vccq->max_uA,
 -				icc_level,
 -				&desc_buf[PWR_DESC_ACTIVE_LVLS_VCCQ_0]);
 -
 -	if (hba->vreg_info.vccq2)
 -		icc_level = ufshcd_get_max_icc_level(
 -				hba->vreg_info.vccq2->max_uA,
 -				icc_level,
 -				&desc_buf[PWR_DESC_ACTIVE_LVLS_VCCQ2_0]);
 -out:
 -	return icc_level;
 -}
 -
 -static void ufshcd_init_icc_levels(struct ufs_hba *hba)
 -{
 -	int ret;
 -	int buff_len = QUERY_DESC_POWER_MAX_SIZE;
 -	u8 desc_buf[QUERY_DESC_POWER_MAX_SIZE];
 -
 -	ret = ufshcd_read_power_desc(hba, desc_buf, buff_len);
 -	if (ret) {
 -		dev_err(hba->dev,
 -			"%s: Failed reading power descriptor.len = %d ret = %d",
 -			__func__, buff_len, ret);
 -		return;
 -	}
 -
 -	hba->init_prefetch_data.icc_level =
 -			ufshcd_find_max_sup_active_icc_level(hba,
 -			desc_buf, buff_len);
 -	dev_dbg(hba->dev, "%s: setting icc_level 0x%x",
 -			__func__, hba->init_prefetch_data.icc_level);
 -
 -	ret = ufshcd_query_attr(hba, UPIU_QUERY_OPCODE_WRITE_ATTR,
 -			QUERY_ATTR_IDN_ACTIVE_ICC_LVL, 0, 0,
 -			&hba->init_prefetch_data.icc_level);
 -
 -	if (ret)
 -		dev_err(hba->dev,
 -			"%s: Failed configuring bActiveICCLevel = %d ret = %d",
 -			__func__, hba->init_prefetch_data.icc_level , ret);
 -
 -}
 -
 -/**
 - * ufshcd_scsi_add_wlus - Adds required W-LUs
 - * @hba: per-adapter instance
 - *
 - * UFS device specification requires the UFS devices to support 4 well known
 - * logical units:
 - *	"REPORT_LUNS" (address: 01h)
 - *	"UFS Device" (address: 50h)
 - *	"RPMB" (address: 44h)
 - *	"BOOT" (address: 30h)
 - * UFS device's power management needs to be controlled by "POWER CONDITION"
 - * field of SSU (START STOP UNIT) command. But this "power condition" field
 - * will take effect only when its sent to "UFS device" well known logical unit
 - * hence we require the scsi_device instance to represent this logical unit in
 - * order for the UFS host driver to send the SSU command for power management.
 -
 - * We also require the scsi_device instance for "RPMB" (Replay Protected Memory
 - * Block) LU so user space process can control this LU. User space may also
 - * want to have access to BOOT LU.
 -
 - * This function adds scsi device instances for each of all well known LUs
 - * (except "REPORT LUNS" LU).
 - *
 - * Returns zero on success (all required W-LUs are added successfully),
 - * non-zero error value on failure (if failed to add any of the required W-LU).
 - */
 -static int ufshcd_scsi_add_wlus(struct ufs_hba *hba)
 -{
 -	int ret = 0;
 -	struct scsi_device *sdev_rpmb;
 -	struct scsi_device *sdev_boot;
 -
 -	hba->sdev_ufs_device = __scsi_add_device(hba->host, 0, 0,
 -		ufshcd_upiu_wlun_to_scsi_wlun(UFS_UPIU_UFS_DEVICE_WLUN), NULL);
 -	if (IS_ERR(hba->sdev_ufs_device)) {
 -		ret = PTR_ERR(hba->sdev_ufs_device);
 -		hba->sdev_ufs_device = NULL;
 -		goto out;
 -	}
 -	scsi_device_put(hba->sdev_ufs_device);
 -
 -	sdev_boot = __scsi_add_device(hba->host, 0, 0,
 -		ufshcd_upiu_wlun_to_scsi_wlun(UFS_UPIU_BOOT_WLUN), NULL);
 -	if (IS_ERR(sdev_boot)) {
 -		ret = PTR_ERR(sdev_boot);
 -		goto remove_sdev_ufs_device;
 -	}
 -	scsi_device_put(sdev_boot);
 -
 -	sdev_rpmb = __scsi_add_device(hba->host, 0, 0,
 -		ufshcd_upiu_wlun_to_scsi_wlun(UFS_UPIU_RPMB_WLUN), NULL);
 -	if (IS_ERR(sdev_rpmb)) {
 -		ret = PTR_ERR(sdev_rpmb);
 -		goto remove_sdev_boot;
 -	}
 -	scsi_device_put(sdev_rpmb);
 -	goto out;
 -
 -remove_sdev_boot:
 -	scsi_remove_device(sdev_boot);
 -remove_sdev_ufs_device:
 -	scsi_remove_device(hba->sdev_ufs_device);
 -out:
 -	return ret;
 -}
 +static struct scsi_host_template ufshcd_driver_template = {
 +	.module			= THIS_MODULE,
 +	.name			= UFSHCD,
 +	.proc_name		= UFSHCD,
 +	.queuecommand		= ufshcd_queuecommand,
 +	.slave_alloc		= ufshcd_slave_alloc,
 +	.slave_destroy		= ufshcd_slave_destroy,
 +	.eh_abort_handler	= ufshcd_abort,
 +	.eh_device_reset_handler = ufshcd_device_reset,
 +	.eh_host_reset_handler	= ufshcd_host_reset,
 +	.this_id		= -1,
 +	.sg_tablesize		= SG_ALL,
 +	.cmd_per_lun		= UFSHCD_CMD_PER_LUN,
 +	.can_queue		= UFSHCD_CAN_QUEUE,
 +};
  
  /**
 - * ufshcd_probe_hba - probe hba to detect device and initialize
 - * @hba: per-adapter instance
 - *
 - * Execute link-startup and verify device initialization
 - */
 -static int ufshcd_probe_hba(struct ufs_hba *hba)
 -{
 -	int ret;
 -
 -	ret = ufshcd_link_startup(hba);
 -	if (ret)
 -		goto out;
 -
 -	ufshcd_init_pwr_info(hba);
 -
 -	/* UniPro link is active now */
 -	ufshcd_set_link_active(hba);
 -
 -	ret = ufshcd_verify_dev_init(hba);
 -	if (ret)
 -		goto out;
 -
 -	ret = ufshcd_complete_dev_init(hba);
 -	if (ret)
 -		goto out;
 -
 -	/* UFS device is also active now */
 -	ufshcd_set_ufs_dev_active(hba);
 -	ufshcd_force_reset_auto_bkops(hba);
 -	hba->ufshcd_state = UFSHCD_STATE_OPERATIONAL;
 -	hba->wlun_dev_clr_ua = true;
 -
 -	if (ufshcd_get_max_pwr_mode(hba)) {
 -		dev_err(hba->dev,
 -			"%s: Failed getting max supported power mode\n",
 -			__func__);
 -	} else {
 -		ret = ufshcd_config_pwr_mode(hba, &hba->max_pwr_info.info);
 -		if (ret)
 -			dev_err(hba->dev, "%s: Failed setting power mode, err = %d\n",
 -					__func__, ret);
 -	}
 -
 -	/*
 -	 * If we are in error handling context or in power management callbacks
 -	 * context, no need to scan the host
 -	 */
 -	if (!ufshcd_eh_in_progress(hba) && !hba->pm_op_in_progress) {
 -		bool flag;
 -
 -		/* clear any previous UFS device information */
 -		memset(&hba->dev_info, 0, sizeof(hba->dev_info));
 -		if (!ufshcd_query_flag(hba, UPIU_QUERY_OPCODE_READ_FLAG,
 -				       QUERY_FLAG_IDN_PWR_ON_WPE, &flag))
 -			hba->dev_info.f_power_on_wp_en = flag;
 -
 -		if (!hba->is_init_prefetch)
 -			ufshcd_init_icc_levels(hba);
 -
 -		/* Add required well known logical units to scsi mid layer */
 -		if (ufshcd_scsi_add_wlus(hba))
 -			goto out;
 -
 -		scsi_scan_host(hba->host);
 -		pm_runtime_put_sync(hba->dev);
 -	}
 -
 -	if (!hba->is_init_prefetch)
 -		hba->is_init_prefetch = true;
 -
 -	/* Resume devfreq after UFS device is detected */
 -	if (ufshcd_is_clkscaling_enabled(hba))
 -		devfreq_resume_device(hba->devfreq);
 -
 -out:
 -	/*
 -	 * If we failed to initialize the device or the device is not
 -	 * present, turn off the power/clocks etc.
 -	 */
 -	if (ret && !ufshcd_eh_in_progress(hba) && !hba->pm_op_in_progress) {
 -		pm_runtime_put_sync(hba->dev);
 -		ufshcd_hba_exit(hba);
 -	}
 -
 -	return ret;
 -}
 -
 -/**
 - * ufshcd_async_scan - asynchronous execution for probing hba
 - * @data: data pointer to pass to this function
 - * @cookie: cookie data
 - */
 -static void ufshcd_async_scan(void *data, async_cookie_t cookie)
 -{
 -	struct ufs_hba *hba = (struct ufs_hba *)data;
 -
 -	ufshcd_probe_hba(hba);
 -}
 -
 -static struct scsi_host_template ufshcd_driver_template = {
 -	.module			= THIS_MODULE,
 -	.name			= UFSHCD,
 -	.proc_name		= UFSHCD,
 -	.queuecommand		= ufshcd_queuecommand,
 -	.slave_alloc		= ufshcd_slave_alloc,
 -	.slave_configure	= ufshcd_slave_configure,
 -	.slave_destroy		= ufshcd_slave_destroy,
 -	.change_queue_depth	= ufshcd_change_queue_depth,
 -	.eh_abort_handler	= ufshcd_abort,
 -	.eh_device_reset_handler = ufshcd_eh_device_reset_handler,
 -	.eh_host_reset_handler   = ufshcd_eh_host_reset_handler,
 -	.this_id		= -1,
 -	.sg_tablesize		= SG_ALL,
 -	.cmd_per_lun		= UFSHCD_CMD_PER_LUN,
 -	.can_queue		= UFSHCD_CAN_QUEUE,
 -	.max_host_blocked	= 1,
 -	.use_blk_tags		= 1,
 -	.track_queue_depth	= 1,
 -};
 -
 -static int ufshcd_config_vreg_load(struct device *dev, struct ufs_vreg *vreg,
 -				   int ua)
 -{
 -	int ret = 0;
 -	struct regulator *reg = vreg->reg;
 -	const char *name = vreg->name;
 -
 -	BUG_ON(!vreg);
 -
 -	ret = regulator_set_optimum_mode(reg, ua);
 -	if (ret >= 0) {
 -		/*
 -		 * regulator_set_optimum_mode() returns new regulator
 -		 * mode upon success.
 -		 */
 -		ret = 0;
 -	} else {
 -		dev_err(dev, "%s: %s set optimum mode(ua=%d) failed, err=%d\n",
 -				__func__, name, ua, ret);
 -	}
 -
 -	return ret;
 -}
 -
 -static inline int ufshcd_config_vreg_lpm(struct ufs_hba *hba,
 -					 struct ufs_vreg *vreg)
 -{
 -	if (!vreg)
 -		return 0;
 -
 -	return ufshcd_config_vreg_load(hba->dev, vreg, UFS_VREG_LPM_LOAD_UA);
 -}
 -
 -static inline int ufshcd_config_vreg_hpm(struct ufs_hba *hba,
 -					 struct ufs_vreg *vreg)
 -{
 -	if (!vreg)
 -		return 0;
 -
 -	return ufshcd_config_vreg_load(hba->dev, vreg, vreg->max_uA);
 -}
 -
 -static int ufshcd_config_vreg(struct device *dev,
 -		struct ufs_vreg *vreg, bool on)
 -{
 -	int ret = 0;
 -	struct regulator *reg = vreg->reg;
 -	const char *name = vreg->name;
 -	int min_uV, uA_load;
 -
 -	BUG_ON(!vreg);
 -
 -	if (regulator_count_voltages(reg) > 0) {
 -		min_uV = on ? vreg->min_uV : 0;
 -		ret = regulator_set_voltage(reg, min_uV, vreg->max_uV);
 -		if (ret) {
 -			dev_err(dev, "%s: %s set voltage failed, err=%d\n",
 -					__func__, name, ret);
 -			goto out;
 -		}
 -
 -		uA_load = on ? vreg->max_uA : 0;
 -		ret = ufshcd_config_vreg_load(dev, vreg, uA_load);
 -		if (ret)
 -			goto out;
 -	}
 -out:
 -	return ret;
 -}
 -
 -static int ufshcd_enable_vreg(struct device *dev, struct ufs_vreg *vreg)
 -{
 -	int ret = 0;
 -
 -	if (!vreg || vreg->enabled)
 -		goto out;
 -
 -	ret = ufshcd_config_vreg(dev, vreg, true);
 -	if (!ret)
 -		ret = regulator_enable(vreg->reg);
 -
 -	if (!ret)
 -		vreg->enabled = true;
 -	else
 -		dev_err(dev, "%s: %s enable failed, err=%d\n",
 -				__func__, vreg->name, ret);
 -out:
 -	return ret;
 -}
 -
 -static int ufshcd_disable_vreg(struct device *dev, struct ufs_vreg *vreg)
 -{
 -	int ret = 0;
 -
 -	if (!vreg || !vreg->enabled)
 -		goto out;
 -
 -	ret = regulator_disable(vreg->reg);
 -
 -	if (!ret) {
 -		/* ignore errors on applying disable config */
 -		ufshcd_config_vreg(dev, vreg, false);
 -		vreg->enabled = false;
 -	} else {
 -		dev_err(dev, "%s: %s disable failed, err=%d\n",
 -				__func__, vreg->name, ret);
 -	}
 -out:
 -	return ret;
 -}
 -
 -static int ufshcd_setup_vreg(struct ufs_hba *hba, bool on)
 -{
 -	int ret = 0;
 -	struct device *dev = hba->dev;
 -	struct ufs_vreg_info *info = &hba->vreg_info;
 -
 -	if (!info)
 -		goto out;
 -
 -	ret = ufshcd_toggle_vreg(dev, info->vcc, on);
 -	if (ret)
 -		goto out;
 -
 -	ret = ufshcd_toggle_vreg(dev, info->vccq, on);
 -	if (ret)
 -		goto out;
 -
 -	ret = ufshcd_toggle_vreg(dev, info->vccq2, on);
 -	if (ret)
 -		goto out;
 -
 -out:
 -	if (ret) {
 -		ufshcd_toggle_vreg(dev, info->vccq2, false);
 -		ufshcd_toggle_vreg(dev, info->vccq, false);
 -		ufshcd_toggle_vreg(dev, info->vcc, false);
 -	}
 -	return ret;
 -}
 -
 -static int ufshcd_setup_hba_vreg(struct ufs_hba *hba, bool on)
 -{
 -	struct ufs_vreg_info *info = &hba->vreg_info;
 -
 -	if (info)
 -		return ufshcd_toggle_vreg(hba->dev, info->vdd_hba, on);
 -
 -	return 0;
 -}
 -
 -static int ufshcd_get_vreg(struct device *dev, struct ufs_vreg *vreg)
 -{
 -	int ret = 0;
 -
 -	if (!vreg)
 -		goto out;
 -
 -	vreg->reg = devm_regulator_get(dev, vreg->name);
 -	if (IS_ERR(vreg->reg)) {
 -		ret = PTR_ERR(vreg->reg);
 -		dev_err(dev, "%s: %s get failed, err=%d\n",
 -				__func__, vreg->name, ret);
 -	}
 -out:
 -	return ret;
 -}
 -
 -static int ufshcd_init_vreg(struct ufs_hba *hba)
 -{
 -	int ret = 0;
 -	struct device *dev = hba->dev;
 -	struct ufs_vreg_info *info = &hba->vreg_info;
 -
 -	if (!info)
 -		goto out;
 -
 -	ret = ufshcd_get_vreg(dev, info->vcc);
 -	if (ret)
 -		goto out;
 -
 -	ret = ufshcd_get_vreg(dev, info->vccq);
 -	if (ret)
 -		goto out;
 -
 -	ret = ufshcd_get_vreg(dev, info->vccq2);
 -out:
 -	return ret;
 -}
 -
 -static int ufshcd_init_hba_vreg(struct ufs_hba *hba)
 -{
 -	struct ufs_vreg_info *info = &hba->vreg_info;
 -
 -	if (info)
 -		return ufshcd_get_vreg(hba->dev, info->vdd_hba);
 -
 -	return 0;
 -}
 -
 -static int __ufshcd_setup_clocks(struct ufs_hba *hba, bool on,
 -					bool skip_ref_clk)
 -{
 -	int ret = 0;
 -	struct ufs_clk_info *clki;
 -	struct list_head *head = &hba->clk_list_head;
 -	unsigned long flags;
 -
 -	if (!head || list_empty(head))
 -		goto out;
 -
 -	list_for_each_entry(clki, head, list) {
 -		if (!IS_ERR_OR_NULL(clki->clk)) {
 -			if (skip_ref_clk && !strcmp(clki->name, "ref_clk"))
 -				continue;
 -
 -			if (on && !clki->enabled) {
 -				ret = clk_prepare_enable(clki->clk);
 -				if (ret) {
 -					dev_err(hba->dev, "%s: %s prepare enable failed, %d\n",
 -						__func__, clki->name, ret);
 -					goto out;
 -				}
 -			} else if (!on && clki->enabled) {
 -				clk_disable_unprepare(clki->clk);
 -			}
 -			clki->enabled = on;
 -			dev_dbg(hba->dev, "%s: clk: %s %sabled\n", __func__,
 -					clki->name, on ? "en" : "dis");
 -		}
 -	}
 -
 -	if (hba->vops && hba->vops->setup_clocks)
 -		ret = hba->vops->setup_clocks(hba, on);
 -out:
 -	if (ret) {
 -		list_for_each_entry(clki, head, list) {
 -			if (!IS_ERR_OR_NULL(clki->clk) && clki->enabled)
 -				clk_disable_unprepare(clki->clk);
 -		}
 -	} else if (on) {
 -		spin_lock_irqsave(hba->host->host_lock, flags);
 -		hba->clk_gating.state = CLKS_ON;
 -		spin_unlock_irqrestore(hba->host->host_lock, flags);
 -	}
 -	return ret;
 -}
 -
 -static int ufshcd_setup_clocks(struct ufs_hba *hba, bool on)
 -{
 -	return  __ufshcd_setup_clocks(hba, on, false);
 -}
 -
 -static int ufshcd_init_clocks(struct ufs_hba *hba)
 -{
 -	int ret = 0;
 -	struct ufs_clk_info *clki;
 -	struct device *dev = hba->dev;
 -	struct list_head *head = &hba->clk_list_head;
 -
 -	if (!head || list_empty(head))
 -		goto out;
 -
 -	list_for_each_entry(clki, head, list) {
 -		if (!clki->name)
 -			continue;
 -
 -		clki->clk = devm_clk_get(dev, clki->name);
 -		if (IS_ERR(clki->clk)) {
 -			ret = PTR_ERR(clki->clk);
 -			dev_err(dev, "%s: %s clk get failed, %d\n",
 -					__func__, clki->name, ret);
 -			goto out;
 -		}
 -
 -		if (clki->max_freq) {
 -			ret = clk_set_rate(clki->clk, clki->max_freq);
 -			if (ret) {
 -				dev_err(hba->dev, "%s: %s clk set rate(%dHz) failed, %d\n",
 -					__func__, clki->name,
 -					clki->max_freq, ret);
 -				goto out;
 -			}
 -			clki->curr_freq = clki->max_freq;
 -		}
 -		dev_dbg(dev, "%s: clk: %s, rate: %lu\n", __func__,
 -				clki->name, clk_get_rate(clki->clk));
 -	}
 -out:
 -	return ret;
 -}
 -
 -static int ufshcd_variant_hba_init(struct ufs_hba *hba)
 -{
 -	int err = 0;
 -
 -	if (!hba->vops)
 -		goto out;
 -
 -	if (hba->vops->init) {
 -		err = hba->vops->init(hba);
 -		if (err)
 -			goto out;
 -	}
 -
 -	if (hba->vops->setup_regulators) {
 -		err = hba->vops->setup_regulators(hba, true);
 -		if (err)
 -			goto out_exit;
 -	}
 -
 -	goto out;
 -
 -out_exit:
 -	if (hba->vops->exit)
 -		hba->vops->exit(hba);
 -out:
 -	if (err)
 -		dev_err(hba->dev, "%s: variant %s init failed err %d\n",
 -			__func__, hba->vops ? hba->vops->name : "", err);
 -	return err;
 -}
 -
 -static void ufshcd_variant_hba_exit(struct ufs_hba *hba)
 -{
 -	if (!hba->vops)
 -		return;
 -
 -	if (hba->vops->setup_clocks)
 -		hba->vops->setup_clocks(hba, false);
 -
 -	if (hba->vops->setup_regulators)
 -		hba->vops->setup_regulators(hba, false);
 -
 -	if (hba->vops->exit)
 -		hba->vops->exit(hba);
 -}
 -
 -static int ufshcd_hba_init(struct ufs_hba *hba)
 -{
 -	int err;
 -
 -	/*
 -	 * Handle host controller power separately from the UFS device power
 -	 * rails as it will help controlling the UFS host controller power
 -	 * collapse easily which is different than UFS device power collapse.
 -	 * Also, enable the host controller power before we go ahead with rest
 -	 * of the initialization here.
 -	 */
 -	err = ufshcd_init_hba_vreg(hba);
 -	if (err)
 -		goto out;
 -
 -	err = ufshcd_setup_hba_vreg(hba, true);
 -	if (err)
 -		goto out;
 -
 -	err = ufshcd_init_clocks(hba);
 -	if (err)
 -		goto out_disable_hba_vreg;
 -
 -	err = ufshcd_setup_clocks(hba, true);
 -	if (err)
 -		goto out_disable_hba_vreg;
 -
 -	err = ufshcd_init_vreg(hba);
 -	if (err)
 -		goto out_disable_clks;
 -
 -	err = ufshcd_setup_vreg(hba, true);
 -	if (err)
 -		goto out_disable_clks;
 -
 -	err = ufshcd_variant_hba_init(hba);
 -	if (err)
 -		goto out_disable_vreg;
 -
 -	hba->is_powered = true;
 -	goto out;
 -
 -out_disable_vreg:
 -	ufshcd_setup_vreg(hba, false);
 -out_disable_clks:
 -	ufshcd_setup_clocks(hba, false);
 -out_disable_hba_vreg:
 -	ufshcd_setup_hba_vreg(hba, false);
 -out:
 -	return err;
 -}
 -
 -static void ufshcd_hba_exit(struct ufs_hba *hba)
 -{
 -	if (hba->is_powered) {
 -		ufshcd_variant_hba_exit(hba);
 -		ufshcd_setup_vreg(hba, false);
 -		ufshcd_setup_clocks(hba, false);
 -		ufshcd_setup_hba_vreg(hba, false);
 -		hba->is_powered = false;
 -	}
 -}
 -
 -static int
 -ufshcd_send_request_sense(struct ufs_hba *hba, struct scsi_device *sdp)
 -{
 -	unsigned char cmd[6] = {REQUEST_SENSE,
 -				0,
 -				0,
 -				0,
 -				SCSI_SENSE_BUFFERSIZE,
 -				0};
 -	char *buffer;
 -	int ret;
 -
 -	buffer = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_KERNEL);
 -	if (!buffer) {
 -		ret = -ENOMEM;
 -		goto out;
 -	}
 -
 -	ret = scsi_execute_req_flags(sdp, cmd, DMA_FROM_DEVICE, buffer,
 -				SCSI_SENSE_BUFFERSIZE, NULL,
 -				msecs_to_jiffies(1000), 3, NULL, REQ_PM);
 -	if (ret)
 -		pr_err("%s: failed with err %d\n", __func__, ret);
 -
 -	kfree(buffer);
 -out:
 -	return ret;
 -}
 -
 -/**
 - * ufshcd_set_dev_pwr_mode - sends START STOP UNIT command to set device
 - *			     power mode
 - * @hba: per adapter instance
 - * @pwr_mode: device power mode to set
 - *
 - * Returns 0 if requested power mode is set successfully
 - * Returns non-zero if failed to set the requested power mode
 - */
 -static int ufshcd_set_dev_pwr_mode(struct ufs_hba *hba,
 -				     enum ufs_dev_pwr_mode pwr_mode)
 -{
 -	unsigned char cmd[6] = { START_STOP };
 -	struct scsi_sense_hdr sshdr;
 -	struct scsi_device *sdp;
 -	unsigned long flags;
 -	int ret;
 -
 -	spin_lock_irqsave(hba->host->host_lock, flags);
 -	sdp = hba->sdev_ufs_device;
 -	if (sdp) {
 -		ret = scsi_device_get(sdp);
 -		if (!ret && !scsi_device_online(sdp)) {
 -			ret = -ENODEV;
 -			scsi_device_put(sdp);
 -		}
 -	} else {
 -		ret = -ENODEV;
 -	}
 -	spin_unlock_irqrestore(hba->host->host_lock, flags);
 -
 -	if (ret)
 -		return ret;
 -
 -	/*
 -	 * If scsi commands fail, the scsi mid-layer schedules scsi error-
 -	 * handling, which would wait for host to be resumed. Since we know
 -	 * we are functional while we are here, skip host resume in error
 -	 * handling context.
 -	 */
 -	hba->host->eh_noresume = 1;
 -	if (hba->wlun_dev_clr_ua) {
 -		ret = ufshcd_send_request_sense(hba, sdp);
 -		if (ret)
 -			goto out;
 -		/* Unit attention condition is cleared now */
 -		hba->wlun_dev_clr_ua = false;
 -	}
 -
 -	cmd[4] = pwr_mode << 4;
 -
 -	/*
 -	 * Current function would be generally called from the power management
 -	 * callbacks hence set the REQ_PM flag so that it doesn't resume the
 -	 * already suspended childs.
 -	 */
 -	ret = scsi_execute_req_flags(sdp, cmd, DMA_NONE, NULL, 0, &sshdr,
 -				     START_STOP_TIMEOUT, 0, NULL, REQ_PM);
 -	if (ret) {
 -		sdev_printk(KERN_WARNING, sdp,
 -			    "START_STOP failed for power mode: %d, result %x\n",
 -			    pwr_mode, ret);
 -		if (driver_byte(ret) & DRIVER_SENSE)
 -			scsi_print_sense_hdr(sdp, NULL, &sshdr);
 -	}
 -
 -	if (!ret)
 -		hba->curr_dev_pwr_mode = pwr_mode;
 -out:
 -	scsi_device_put(sdp);
 -	hba->host->eh_noresume = 0;
 -	return ret;
 -}
 -
 -static int ufshcd_link_state_transition(struct ufs_hba *hba,
 -					enum uic_link_state req_link_state,
 -					int check_for_bkops)
 -{
 -	int ret = 0;
 -
 -	if (req_link_state == hba->uic_link_state)
 -		return 0;
 -
 -	if (req_link_state == UIC_LINK_HIBERN8_STATE) {
 -		ret = ufshcd_uic_hibern8_enter(hba);
 -		if (!ret)
 -			ufshcd_set_link_hibern8(hba);
 -		else
 -			goto out;
 -	}
 -	/*
 -	 * If autobkops is enabled, link can't be turned off because
 -	 * turning off the link would also turn off the device.
 -	 */
 -	else if ((req_link_state == UIC_LINK_OFF_STATE) &&
 -		   (!check_for_bkops || (check_for_bkops &&
 -		    !hba->auto_bkops_enabled))) {
 -		/*
 -		 * Change controller state to "reset state" which
 -		 * should also put the link in off/reset state
 -		 */
 -		ufshcd_hba_stop(hba);
 -		/*
 -		 * TODO: Check if we need any delay to make sure that
 -		 * controller is reset
 -		 */
 -		ufshcd_set_link_off(hba);
 -	}
 -
 -out:
 -	return ret;
 -}
 -
 -static void ufshcd_vreg_set_lpm(struct ufs_hba *hba)
 -{
 -	/*
 -	 * If UFS device is either in UFS_Sleep turn off VCC rail to save some
 -	 * power.
 -	 *
 -	 * If UFS device and link is in OFF state, all power supplies (VCC,
 -	 * VCCQ, VCCQ2) can be turned off if power on write protect is not
 -	 * required. If UFS link is inactive (Hibern8 or OFF state) and device
 -	 * is in sleep state, put VCCQ & VCCQ2 rails in LPM mode.
 -	 *
 -	 * Ignore the error returned by ufshcd_toggle_vreg() as device is anyway
 -	 * in low power state which would save some power.
 -	 */
 -	if (ufshcd_is_ufs_dev_poweroff(hba) && ufshcd_is_link_off(hba) &&
 -	    !hba->dev_info.is_lu_power_on_wp) {
 -		ufshcd_setup_vreg(hba, false);
 -	} else if (!ufshcd_is_ufs_dev_active(hba)) {
 -		ufshcd_toggle_vreg(hba->dev, hba->vreg_info.vcc, false);
 -		if (!ufshcd_is_link_active(hba)) {
 -			ufshcd_config_vreg_lpm(hba, hba->vreg_info.vccq);
 -			ufshcd_config_vreg_lpm(hba, hba->vreg_info.vccq2);
 -		}
 -	}
 -}
 -
 -static int ufshcd_vreg_set_hpm(struct ufs_hba *hba)
 -{
 -	int ret = 0;
 -
 -	if (ufshcd_is_ufs_dev_poweroff(hba) && ufshcd_is_link_off(hba) &&
 -	    !hba->dev_info.is_lu_power_on_wp) {
 -		ret = ufshcd_setup_vreg(hba, true);
 -	} else if (!ufshcd_is_ufs_dev_active(hba)) {
 -		ret = ufshcd_toggle_vreg(hba->dev, hba->vreg_info.vcc, true);
 -		if (!ret && !ufshcd_is_link_active(hba)) {
 -			ret = ufshcd_config_vreg_hpm(hba, hba->vreg_info.vccq);
 -			if (ret)
 -				goto vcc_disable;
 -			ret = ufshcd_config_vreg_hpm(hba, hba->vreg_info.vccq2);
 -			if (ret)
 -				goto vccq_lpm;
 -		}
 -	}
 -	goto out;
 -
 -vccq_lpm:
 -	ufshcd_config_vreg_lpm(hba, hba->vreg_info.vccq);
 -vcc_disable:
 -	ufshcd_toggle_vreg(hba->dev, hba->vreg_info.vcc, false);
 -out:
 -	return ret;
 -}
 -
 -static void ufshcd_hba_vreg_set_lpm(struct ufs_hba *hba)
 -{
 -	if (ufshcd_is_link_off(hba))
 -		ufshcd_setup_hba_vreg(hba, false);
 -}
 -
 -static void ufshcd_hba_vreg_set_hpm(struct ufs_hba *hba)
 -{
 -	if (ufshcd_is_link_off(hba))
 -		ufshcd_setup_hba_vreg(hba, true);
 -}
 -
 -/**
 - * ufshcd_suspend - helper function for suspend operations
 - * @hba: per adapter instance
 - * @pm_op: desired low power operation type
 - *
 - * This function will try to put the UFS device and link into low power
 - * mode based on the "rpm_lvl" (Runtime PM level) or "spm_lvl"
 - * (System PM level).
 - *
 - * If this function is called during shutdown, it will make sure that
 - * both UFS device and UFS link is powered off.
 - *
 - * NOTE: UFS device & link must be active before we enter in this function.
 - *
 - * Returns 0 for success and non-zero for failure
 - */
 -static int ufshcd_suspend(struct ufs_hba *hba, enum ufs_pm_op pm_op)
 -{
 -	int ret = 0;
 -	enum ufs_pm_level pm_lvl;
 -	enum ufs_dev_pwr_mode req_dev_pwr_mode;
 -	enum uic_link_state req_link_state;
 -
 -	hba->pm_op_in_progress = 1;
 -	if (!ufshcd_is_shutdown_pm(pm_op)) {
 -		pm_lvl = ufshcd_is_runtime_pm(pm_op) ?
 -			 hba->rpm_lvl : hba->spm_lvl;
 -		req_dev_pwr_mode = ufs_get_pm_lvl_to_dev_pwr_mode(pm_lvl);
 -		req_link_state = ufs_get_pm_lvl_to_link_pwr_state(pm_lvl);
 -	} else {
 -		req_dev_pwr_mode = UFS_POWERDOWN_PWR_MODE;
 -		req_link_state = UIC_LINK_OFF_STATE;
 -	}
 -
 -	/*
 -	 * If we can't transition into any of the low power modes
 -	 * just gate the clocks.
 -	 */
 -	ufshcd_hold(hba, false);
 -	hba->clk_gating.is_suspended = true;
 -
 -	if (req_dev_pwr_mode == UFS_ACTIVE_PWR_MODE &&
 -			req_link_state == UIC_LINK_ACTIVE_STATE) {
 -		goto disable_clks;
 -	}
 -
 -	if ((req_dev_pwr_mode == hba->curr_dev_pwr_mode) &&
 -	    (req_link_state == hba->uic_link_state))
 -		goto out;
 -
 -	/* UFS device & link must be active before we enter in this function */
 -	if (!ufshcd_is_ufs_dev_active(hba) || !ufshcd_is_link_active(hba)) {
 -		ret = -EINVAL;
 -		goto out;
 -	}
 -
 -	if (ufshcd_is_runtime_pm(pm_op)) {
 -		if (ufshcd_can_autobkops_during_suspend(hba)) {
 -			/*
 -			 * The device is idle with no requests in the queue,
 -			 * allow background operations if bkops status shows
 -			 * that performance might be impacted.
 -			 */
 -			ret = ufshcd_urgent_bkops(hba);
 -			if (ret)
 -				goto enable_gating;
 -		} else {
 -			/* make sure that auto bkops is disabled */
 -			ufshcd_disable_auto_bkops(hba);
 -		}
 -	}
 -
 -	if ((req_dev_pwr_mode != hba->curr_dev_pwr_mode) &&
 -	     ((ufshcd_is_runtime_pm(pm_op) && !hba->auto_bkops_enabled) ||
 -	       !ufshcd_is_runtime_pm(pm_op))) {
 -		/* ensure that bkops is disabled */
 -		ufshcd_disable_auto_bkops(hba);
 -		ret = ufshcd_set_dev_pwr_mode(hba, req_dev_pwr_mode);
 -		if (ret)
 -			goto enable_gating;
 -	}
 -
 -	ret = ufshcd_link_state_transition(hba, req_link_state, 1);
 -	if (ret)
 -		goto set_dev_active;
 -
 -	ufshcd_vreg_set_lpm(hba);
 -
 -disable_clks:
 -	/*
 -	 * The clock scaling needs access to controller registers. Hence, Wait
 -	 * for pending clock scaling work to be done before clocks are
 -	 * turned off.
 -	 */
 -	if (ufshcd_is_clkscaling_enabled(hba)) {
 -		devfreq_suspend_device(hba->devfreq);
 -		hba->clk_scaling.window_start_t = 0;
 -	}
 -	/*
 -	 * Call vendor specific suspend callback. As these callbacks may access
 -	 * vendor specific host controller register space call them before the
 -	 * host clocks are ON.
 -	 */
 -	if (hba->vops && hba->vops->suspend) {
 -		ret = hba->vops->suspend(hba, pm_op);
 -		if (ret)
 -			goto set_link_active;
 -	}
 -
 -	if (hba->vops && hba->vops->setup_clocks) {
 -		ret = hba->vops->setup_clocks(hba, false);
 -		if (ret)
 -			goto vops_resume;
 -	}
 -
 -	if (!ufshcd_is_link_active(hba))
 -		ufshcd_setup_clocks(hba, false);
 -	else
 -		/* If link is active, device ref_clk can't be switched off */
 -		__ufshcd_setup_clocks(hba, false, true);
 -
 -	hba->clk_gating.state = CLKS_OFF;
 + * ufshcd_suspend - suspend power management function
 + * @hba: per adapter instance
 + * @state: power state
 + *
 + * Returns -ENOSYS
 + */
 +int ufshcd_suspend(struct ufs_hba *hba, pm_message_t state)
 +{
  	/*
 -	 * Disable the host irq as host controller as there won't be any
 -	 * host controller trasanction expected till resume.
 +	 * TODO:
 +	 * 1. Block SCSI requests from SCSI midlayer
 +	 * 2. Change the internal driver state to non operational
 +	 * 3. Set UTRLRSR and UTMRLRSR bits to zero
 +	 * 4. Wait until outstanding commands are completed
 +	 * 5. Set HCE to zero to send the UFS host controller to reset state
  	 */
 -	ufshcd_disable_irq(hba);
 -	/* Put the host controller in low power mode if possible */
 -	ufshcd_hba_vreg_set_lpm(hba);
 -	goto out;
 -
 -vops_resume:
 -	if (hba->vops && hba->vops->resume)
 -		hba->vops->resume(hba, pm_op);
 -set_link_active:
 -	ufshcd_vreg_set_hpm(hba);
 -	if (ufshcd_is_link_hibern8(hba) && !ufshcd_uic_hibern8_exit(hba))
 -		ufshcd_set_link_active(hba);
 -	else if (ufshcd_is_link_off(hba))
 -		ufshcd_host_reset_and_restore(hba);
 -set_dev_active:
 -	if (!ufshcd_set_dev_pwr_mode(hba, UFS_ACTIVE_PWR_MODE))
 -		ufshcd_disable_auto_bkops(hba);
 -enable_gating:
 -	hba->clk_gating.is_suspended = false;
 -	ufshcd_release(hba);
 -out:
 -	hba->pm_op_in_progress = 0;
 -	return ret;
 +
 +	return -ENOSYS;
  }
 +EXPORT_SYMBOL_GPL(ufshcd_suspend);
  
  /**
 - * ufshcd_resume - helper function for resume operations
 + * ufshcd_resume - resume power management function
   * @hba: per adapter instance
 - * @pm_op: runtime PM or system PM
 - *
 - * This function basically brings the UFS device, UniPro link and controller
 - * to active state.
   *
 - * Returns 0 for success and non-zero for failure
 + * Returns -ENOSYS
   */
 -static int ufshcd_resume(struct ufs_hba *hba, enum ufs_pm_op pm_op)
++<<<<<<< HEAD
 +int ufshcd_resume(struct ufs_hba *hba)
++=======
++static int ufshcd_set_dev_pwr_mode(struct ufs_hba *hba,
++				     enum ufs_dev_pwr_mode pwr_mode)
+ {
++	unsigned char cmd[6] = { START_STOP };
++	struct scsi_sense_hdr sshdr;
++	struct scsi_device *sdp;
++	unsigned long flags;
+ 	int ret;
 -	enum uic_link_state old_link_state;
 -
 -	hba->pm_op_in_progress = 1;
 -	old_link_state = hba->uic_link_state;
 -
 -	ufshcd_hba_vreg_set_hpm(hba);
 -	/* Make sure clocks are enabled before accessing controller */
 -	ret = ufshcd_setup_clocks(hba, true);
 -	if (ret)
 -		goto out;
+ 
 -	/* enable the host irq as host controller would be active soon */
 -	ret = ufshcd_enable_irq(hba);
 -	if (ret)
 -		goto disable_irq_and_vops_clks;
++	spin_lock_irqsave(hba->host->host_lock, flags);
++	sdp = hba->sdev_ufs_device;
++	if (sdp) {
++		ret = scsi_device_get(sdp);
++		if (!ret && !scsi_device_online(sdp)) {
++			ret = -ENODEV;
++			scsi_device_put(sdp);
++		}
++	} else {
++		ret = -ENODEV;
++	}
++	spin_unlock_irqrestore(hba->host->host_lock, flags);
+ 
 -	ret = ufshcd_vreg_set_hpm(hba);
+ 	if (ret)
 -		goto disable_irq_and_vops_clks;
++		return ret;
+ 
+ 	/*
 -	 * Call vendor specific resume callback. As these callbacks may access
 -	 * vendor specific host controller register space call them when the
 -	 * host clocks are ON.
++	 * If scsi commands fail, the scsi mid-layer schedules scsi error-
++	 * handling, which would wait for host to be resumed. Since we know
++	 * we are functional while we are here, skip host resume in error
++	 * handling context.
+ 	 */
 -	if (hba->vops && hba->vops->resume) {
 -		ret = hba->vops->resume(hba, pm_op);
++	hba->host->eh_noresume = 1;
++	if (hba->wlun_dev_clr_ua) {
++		ret = ufshcd_send_request_sense(hba, sdp);
+ 		if (ret)
 -			goto disable_vreg;
 -	}
 -
 -	if (ufshcd_is_link_hibern8(hba)) {
 -		ret = ufshcd_uic_hibern8_exit(hba);
 -		if (!ret)
 -			ufshcd_set_link_active(hba);
 -		else
 -			goto vendor_suspend;
 -	} else if (ufshcd_is_link_off(hba)) {
 -		ret = ufshcd_host_reset_and_restore(hba);
 -		/*
 -		 * ufshcd_host_reset_and_restore() should have already
 -		 * set the link state as active
 -		 */
 -		if (ret || !ufshcd_is_link_active(hba))
 -			goto vendor_suspend;
++			goto out;
++		/* Unit attention condition is cleared now */
++		hba->wlun_dev_clr_ua = false;
+ 	}
+ 
 -	if (!ufshcd_is_ufs_dev_active(hba)) {
 -		ret = ufshcd_set_dev_pwr_mode(hba, UFS_ACTIVE_PWR_MODE);
 -		if (ret)
 -			goto set_old_link_state;
 -	}
++	cmd[4] = pwr_mode << 4;
+ 
+ 	/*
 -	 * If BKOPs operations are urgently needed at this moment then
 -	 * keep auto-bkops enabled or else disable it.
++	 * Current function would be generally called from the power management
++	 * callbacks hence set the REQ_PM flag so that it doesn't resume the
++	 * already suspended childs.
+ 	 */
 -	ufshcd_urgent_bkops(hba);
 -	hba->clk_gating.is_suspended = false;
 -
 -	if (ufshcd_is_clkscaling_enabled(hba))
 -		devfreq_resume_device(hba->devfreq);
 -
 -	/* Schedule clock gating in case of no access to UFS device yet */
 -	ufshcd_release(hba);
 -	goto out;
 -
 -set_old_link_state:
 -	ufshcd_link_state_transition(hba, old_link_state, 0);
 -vendor_suspend:
 -	if (hba->vops && hba->vops->suspend)
 -		hba->vops->suspend(hba, pm_op);
 -disable_vreg:
 -	ufshcd_vreg_set_lpm(hba);
 -disable_irq_and_vops_clks:
 -	ufshcd_disable_irq(hba);
 -	ufshcd_setup_clocks(hba, false);
++	ret = scsi_execute_req_flags(sdp, cmd, DMA_NONE, NULL, 0, &sshdr,
++				     START_STOP_TIMEOUT, 0, NULL, REQ_PM);
++	if (ret) {
++		sdev_printk(KERN_WARNING, sdp,
++			    "START_STOP failed for power mode: %d, result %x\n",
++			    pwr_mode, ret);
++		if (driver_byte(ret) & DRIVER_SENSE)
++			scsi_print_sense_hdr(sdp, NULL, &sshdr);
++	}
++
++	if (!ret)
++		hba->curr_dev_pwr_mode = pwr_mode;
+ out:
 -	hba->pm_op_in_progress = 0;
++	scsi_device_put(sdp);
++	hba->host->eh_noresume = 0;
+ 	return ret;
+ }
+ 
 -/**
 - * ufshcd_system_suspend - system suspend routine
 - * @hba: per adapter instance
 - * @pm_op: runtime PM or system PM
 - *
 - * Check the description of ufshcd_suspend() function for more details.
 - *
 - * Returns 0 for success and non-zero for failure
 - */
 -int ufshcd_system_suspend(struct ufs_hba *hba)
++static int ufshcd_link_state_transition(struct ufs_hba *hba,
++					enum uic_link_state req_link_state,
++					int check_for_bkops)
+ {
+ 	int ret = 0;
+ 
 -	if (!hba || !hba->is_powered)
++	if (req_link_state == hba->uic_link_state)
+ 		return 0;
+ 
 -	if (pm_runtime_suspended(hba->dev)) {
 -		if (hba->rpm_lvl == hba->spm_lvl)
 -			/*
 -			 * There is possibility that device may still be in
 -			 * active state during the runtime suspend.
 -			 */
 -			if ((ufs_get_pm_lvl_to_dev_pwr_mode(hba->spm_lvl) ==
 -			    hba->curr_dev_pwr_mode) && !hba->auto_bkops_enabled)
 -				goto out;
 -
++	if (req_link_state == UIC_LINK_HIBERN8_STATE) {
++		ret = ufshcd_uic_hibern8_enter(hba);
++		if (!ret)
++			ufshcd_set_link_hibern8(hba);
++		else
++			goto out;
++	}
++	/*
++	 * If autobkops is enabled, link can't be turned off because
++	 * turning off the link would also turn off the device.
++	 */
++	else if ((req_link_state == UIC_LINK_OFF_STATE) &&
++		   (!check_for_bkops || (check_for_bkops &&
++		    !hba->auto_bkops_enabled))) {
++		/*
++		 * Change controller state to "reset state" which
++		 * should also put the link in off/reset state
++		 */
++		ufshcd_hba_stop(hba);
+ 		/*
 -		 * UFS device and/or UFS link low power states during runtime
 -		 * suspend seems to be different than what is expected during
 -		 * system suspend. Hence runtime resume the devic & link and
 -		 * let the system suspend low power states to take effect.
 -		 * TODO: If resume takes longer time, we might have optimize
 -		 * it in future by not resuming everything if possible.
++		 * TODO: Check if we need any delay to make sure that
++		 * controller is reset
+ 		 */
 -		ret = ufshcd_runtime_resume(hba);
 -		if (ret)
 -			goto out;
++		ufshcd_set_link_off(hba);
+ 	}
+ 
 -	ret = ufshcd_suspend(hba, UFS_SYSTEM_PM);
+ out:
 -	if (!ret)
 -		hba->is_sys_suspended = true;
+ 	return ret;
+ }
 -EXPORT_SYMBOL(ufshcd_system_suspend);
 -
 -/**
 - * ufshcd_system_resume - system resume routine
 - * @hba: per adapter instance
 - *
 - * Returns 0 for success and non-zero for failure
 - */
 -
 -int ufshcd_system_resume(struct ufs_hba *hba)
 -{
 -	if (!hba || !hba->is_powered || pm_runtime_suspended(hba->dev))
 -		/*
 -		 * Let the runtime resume take care of resuming
 -		 * if runtime suspended.
 -		 */
 -		return 0;
 -
 -	return ufshcd_resume(hba, UFS_SYSTEM_PM);
 -}
 -EXPORT_SYMBOL(ufshcd_system_resume);
 -
 -/**
 - * ufshcd_runtime_suspend - runtime suspend routine
 - * @hba: per adapter instance
 - *
 - * Check the description of ufshcd_suspend() function for more details.
 - *
 - * Returns 0 for success and non-zero for failure
 - */
 -int ufshcd_runtime_suspend(struct ufs_hba *hba)
 -{
 -	if (!hba || !hba->is_powered)
 -		return 0;
 -
 -	return ufshcd_suspend(hba, UFS_RUNTIME_PM);
 -}
 -EXPORT_SYMBOL(ufshcd_runtime_suspend);
+ 
 -/**
 - * ufshcd_runtime_resume - runtime resume routine
 - * @hba: per adapter instance
 - *
 - * This function basically brings the UFS device, UniPro link and controller
 - * to active state. Following operations are done in this function:
 - *
 - * 1. Turn on all the controller related clocks
 - * 2. Bring the UniPro link out of Hibernate state
 - * 3. If UFS device is in sleep state, turn ON VCC rail and bring the UFS device
 - *    to active state.
 - * 4. If auto-bkops is enabled on the device, disable it.
 - *
 - * So following would be the possible power state after this function return
 - * successfully:
 - *	S1: UFS device in Active state with VCC rail ON
 - *	    UniPro link in Active state
 - *	    All the UFS/UniPro controller clocks are ON
 - *
 - * Returns 0 for success and non-zero for failure
 - */
 -int ufshcd_runtime_resume(struct ufs_hba *hba)
++static void ufshcd_vreg_set_lpm(struct ufs_hba *hba)
++>>>>>>> 2104551969e8 (scsi: use per-cpu buffer for formatting sense)
  {
 -	if (!hba || !hba->is_powered)
 -		return 0;
 -	else
 -		return ufshcd_resume(hba, UFS_RUNTIME_PM);
 -}
 -EXPORT_SYMBOL(ufshcd_runtime_resume);
 +	/*
 +	 * TODO:
 +	 * 1. Set HCE to 1, to start the UFS host controller
 +	 * initialization process
 +	 * 2. Set UTRLRSR and UTMRLRSR bits to 1
 +	 * 3. Change the internal driver state to operational
 +	 * 4. Unblock SCSI requests from SCSI midlayer
 +	 */
  
 -int ufshcd_runtime_idle(struct ufs_hba *hba)
 -{
 -	return 0;
 +	return -ENOSYS;
  }
 -EXPORT_SYMBOL(ufshcd_runtime_idle);
 +EXPORT_SYMBOL_GPL(ufshcd_resume);
  
  /**
 - * ufshcd_shutdown - shutdown routine
 + * ufshcd_hba_free - free allocated memory for
 + *			host memory space data structures
   * @hba: per adapter instance
 - *
 - * This function would power off both UFS device and UFS link.
 - *
 - * Returns 0 always to allow force shutdown even in case of errors.
   */
 -int ufshcd_shutdown(struct ufs_hba *hba)
 +static void ufshcd_hba_free(struct ufs_hba *hba)
  {
 -	int ret = 0;
 -
 -	if (ufshcd_is_ufs_dev_poweroff(hba) && ufshcd_is_link_off(hba))
 -		goto out;
 -
 -	if (pm_runtime_suspended(hba->dev)) {
 -		ret = ufshcd_runtime_resume(hba);
 -		if (ret)
 -			goto out;
 -	}
 -
 -	ret = ufshcd_suspend(hba, UFS_SHUTDOWN_PM);
 -out:
 -	if (ret)
 -		dev_err(hba->dev, "%s failed, err %d\n", __func__, ret);
 -	/* allow force shutdown even in case of errors */
 -	return 0;
 +	iounmap(hba->mmio_base);
 +	ufshcd_free_hba_memory(hba);
  }
 -EXPORT_SYMBOL(ufshcd_shutdown);
  
  /**
   * ufshcd_remove - de-allocate SCSI host and host memory space
* Unmerged path drivers/scsi/constants.c
* Unmerged path drivers/scsi/scsi_logging.c
* Unmerged path drivers/scsi/sd.c
* Unmerged path drivers/scsi/ufs/ufshcd.c
