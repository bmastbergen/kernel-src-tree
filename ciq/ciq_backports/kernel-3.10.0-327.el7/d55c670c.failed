ip_vti/ip6_vti: Preserve skb->mark after rcv_cb call

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] vti, vti6: Preserve skb->mark after rcv_cb call (Alexander Duyck) [1129761]
Rebuild_FUZZ: 88.89%
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit d55c670cbc54b2270a465cdc382ce71adae45785
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d55c670c.failed

The vti6_rcv_cb and vti_rcv_cb calls were leaving the skb->mark modified
after completing the function.  This resulted in the original skb->mark
value being lost.  Since we only need skb->mark to be set for
xfrm_policy_check we can pull the assignment into the rcv_cb calls and then
just restore the original mark after xfrm_policy_check has been completed.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit d55c670cbc54b2270a465cdc382ce71adae45785)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_vti.c
diff --cc net/ipv6/ip6_vti.c
index 28ec2c553191,ff3bd863fa03..000000000000
--- a/net/ipv6/ip6_vti.c
+++ b/net/ipv6/ip6_vti.c
@@@ -325,24 -321,60 +325,81 @@@ static int vti6_rcv(struct sk_buff *skb
  			goto discard;
  		}
  
++<<<<<<< HEAD
 +		tstats = this_cpu_ptr(t->dev->tstats);
 +		u64_stats_update_begin(&tstats->syncp);
 +		tstats->rx_packets++;
 +		tstats->rx_bytes += skb->len;
 +		u64_stats_update_end(&tstats->syncp);
 +
 +		skb->mark = 0;
 +		secpath_reset(skb);
 +		skb->dev = t->dev;
 +
 +		rcu_read_unlock();
++=======
+ 		XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6 = t;
+ 
+ 		rcu_read_unlock();
+ 
+ 		return xfrm6_rcv(skb);
+ 	}
+ 	rcu_read_unlock();
+ 	return -EINVAL;
+ discard:
+ 	kfree_skb(skb);
+ 	return 0;
+ }
+ 
+ static int vti6_rcv_cb(struct sk_buff *skb, int err)
+ {
+ 	unsigned short family;
+ 	struct net_device *dev;
+ 	struct pcpu_sw_netstats *tstats;
+ 	struct xfrm_state *x;
+ 	struct ip6_tnl *t = XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6;
+ 	u32 orig_mark = skb->mark;
+ 	int ret;
+ 
+ 	if (!t)
+ 		return 1;
+ 
+ 	dev = t->dev;
+ 
+ 	if (err) {
+ 		dev->stats.rx_errors++;
+ 		dev->stats.rx_dropped++;
+ 
++>>>>>>> d55c670cbc54 (ip_vti/ip6_vti: Preserve skb->mark after rcv_cb call)
  		return 0;
  	}
 +	rcu_read_unlock();
 +	return 1;
  
++<<<<<<< HEAD
 +discard:
 +	kfree_skb(skb);
++=======
+ 	x = xfrm_input_state(skb);
+ 	family = x->inner_mode->afinfo->family;
+ 
+ 	skb->mark = be32_to_cpu(t->parms.i_key);
+ 	ret = xfrm_policy_check(NULL, XFRM_POLICY_IN, skb, family);
+ 	skb->mark = orig_mark;
+ 
+ 	if (!ret)
+ 		return -EPERM;
+ 
+ 	skb_scrub_packet(skb, !net_eq(t->net, dev_net(skb->dev)));
+ 	skb->dev = dev;
+ 
+ 	tstats = this_cpu_ptr(dev->tstats);
+ 	u64_stats_update_begin(&tstats->syncp);
+ 	tstats->rx_packets++;
+ 	tstats->rx_bytes += skb->len;
+ 	u64_stats_update_end(&tstats->syncp);
+ 
++>>>>>>> d55c670cbc54 (ip_vti/ip6_vti: Preserve skb->mark after rcv_cb call)
  	return 0;
  }
  
diff --git a/net/ipv4/ip_vti.c b/net/ipv4/ip_vti.c
index 15cadca3cd11..81de13506e22 100644
--- a/net/ipv4/ip_vti.c
+++ b/net/ipv4/ip_vti.c
@@ -65,7 +65,6 @@ static int vti_input(struct sk_buff *skb, int nexthdr, __be32 spi,
 			goto drop;
 
 		XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = tunnel;
-		skb->mark = be32_to_cpu(tunnel->parms.i_key);
 
 		return xfrm_input(skb, nexthdr, spi, encap_type);
 	}
@@ -91,6 +90,8 @@ static int vti_rcv_cb(struct sk_buff *skb, int err)
 	struct pcpu_tstats *tstats;
 	struct xfrm_state *x;
 	struct ip_tunnel *tunnel = XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4;
+	u32 orig_mark = skb->mark;
+	int ret;
 
 	if (!tunnel)
 		return 1;
@@ -107,7 +108,11 @@ static int vti_rcv_cb(struct sk_buff *skb, int err)
 	x = xfrm_input_state(skb);
 	family = x->inner_mode->afinfo->family;
 
-	if (!xfrm_policy_check(NULL, XFRM_POLICY_IN, skb, family))
+	skb->mark = be32_to_cpu(tunnel->parms.i_key);
+	ret = xfrm_policy_check(NULL, XFRM_POLICY_IN, skb, family);
+	skb->mark = orig_mark;
+
+	if (!ret)
 		return -EPERM;
 
 	skb_scrub_packet(skb, !net_eq(tunnel->net, dev_net(skb->dev)));
* Unmerged path net/ipv6/ip6_vti.c
