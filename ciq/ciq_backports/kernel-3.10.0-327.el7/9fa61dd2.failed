i40e: Add support to firmware CEE DCBX mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Neerav Parikh <neerav.parikh@intel.com>
commit 9fa61dd2153a4ff3a57891d4866a2595eb9ac81a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9fa61dd2.failed

This patch allows i40e driver to query and use DCB configuration from
firmware when firmware DCBX agent is in CEE mode.

Change-ID: I30f92a67eb890f0f024f35339696e6e83d49a274
	Signed-off-by: Neerav Parikh <neerav.parikh@intel.com>
Tested-By: Jack Morgan <jack.morgan@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 9fa61dd2153a4ff3a57891d4866a2595eb9ac81a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h
diff --cc drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h
index 15f289f2917f,8835aeeff23e..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h
@@@ -120,162 -120,163 +120,173 @@@ enum i40e_admin_queue_err 
  /* Admin Queue command opcodes */
  enum i40e_admin_queue_opc {
  	/* aq commands */
 -	i40e_aqc_opc_get_version	= 0x0001,
 -	i40e_aqc_opc_driver_version	= 0x0002,
 -	i40e_aqc_opc_queue_shutdown	= 0x0003,
 -	i40e_aqc_opc_set_pf_context	= 0x0004,
 +	i40e_aqc_opc_get_version      = 0x0001,
 +	i40e_aqc_opc_driver_version   = 0x0002,
 +	i40e_aqc_opc_queue_shutdown   = 0x0003,
 +	i40e_aqc_opc_set_pf_context   = 0x0004,
  
  	/* resource ownership */
 -	i40e_aqc_opc_request_resource	= 0x0008,
 -	i40e_aqc_opc_release_resource	= 0x0009,
 +	i40e_aqc_opc_request_resource = 0x0008,
 +	i40e_aqc_opc_release_resource = 0x0009,
  
 -	i40e_aqc_opc_list_func_capabilities	= 0x000A,
 -	i40e_aqc_opc_list_dev_capabilities	= 0x000B,
 +	i40e_aqc_opc_list_func_capabilities = 0x000A,
 +	i40e_aqc_opc_list_dev_capabilities  = 0x000B,
  
 -	i40e_aqc_opc_set_cppm_configuration	= 0x0103,
 -	i40e_aqc_opc_set_arp_proxy_entry	= 0x0104,
 -	i40e_aqc_opc_set_ns_proxy_entry		= 0x0105,
 +	i40e_aqc_opc_set_cppm_configuration = 0x0103,
 +	i40e_aqc_opc_set_arp_proxy_entry    = 0x0104,
 +	i40e_aqc_opc_set_ns_proxy_entry     = 0x0105,
  
  	/* LAA */
 -	i40e_aqc_opc_mng_laa		= 0x0106,   /* AQ obsolete */
 -	i40e_aqc_opc_mac_address_read	= 0x0107,
 -	i40e_aqc_opc_mac_address_write	= 0x0108,
 +	i40e_aqc_opc_mng_laa                = 0x0106,   /* AQ obsolete */
 +	i40e_aqc_opc_mac_address_read       = 0x0107,
 +	i40e_aqc_opc_mac_address_write      = 0x0108,
  
  	/* PXE */
 -	i40e_aqc_opc_clear_pxe_mode	= 0x0110,
 +	i40e_aqc_opc_clear_pxe_mode         = 0x0110,
  
  	/* internal switch commands */
 -	i40e_aqc_opc_get_switch_config		= 0x0200,
 -	i40e_aqc_opc_add_statistics		= 0x0201,
 -	i40e_aqc_opc_remove_statistics		= 0x0202,
 -	i40e_aqc_opc_set_port_parameters	= 0x0203,
 -	i40e_aqc_opc_get_switch_resource_alloc	= 0x0204,
 -
 -	i40e_aqc_opc_add_vsi			= 0x0210,
 -	i40e_aqc_opc_update_vsi_parameters	= 0x0211,
 -	i40e_aqc_opc_get_vsi_parameters		= 0x0212,
 -
 -	i40e_aqc_opc_add_pv			= 0x0220,
 -	i40e_aqc_opc_update_pv_parameters	= 0x0221,
 -	i40e_aqc_opc_get_pv_parameters		= 0x0222,
 -
 -	i40e_aqc_opc_add_veb			= 0x0230,
 -	i40e_aqc_opc_update_veb_parameters	= 0x0231,
 -	i40e_aqc_opc_get_veb_parameters		= 0x0232,
 -
 -	i40e_aqc_opc_delete_element		= 0x0243,
 -
 -	i40e_aqc_opc_add_macvlan		= 0x0250,
 -	i40e_aqc_opc_remove_macvlan		= 0x0251,
 -	i40e_aqc_opc_add_vlan			= 0x0252,
 -	i40e_aqc_opc_remove_vlan		= 0x0253,
 -	i40e_aqc_opc_set_vsi_promiscuous_modes	= 0x0254,
 -	i40e_aqc_opc_add_tag			= 0x0255,
 -	i40e_aqc_opc_remove_tag			= 0x0256,
 -	i40e_aqc_opc_add_multicast_etag		= 0x0257,
 -	i40e_aqc_opc_remove_multicast_etag	= 0x0258,
 -	i40e_aqc_opc_update_tag			= 0x0259,
 -	i40e_aqc_opc_add_control_packet_filter	= 0x025A,
 -	i40e_aqc_opc_remove_control_packet_filter	= 0x025B,
 -	i40e_aqc_opc_add_cloud_filters		= 0x025C,
 -	i40e_aqc_opc_remove_cloud_filters	= 0x025D,
 -
 -	i40e_aqc_opc_add_mirror_rule	= 0x0260,
 -	i40e_aqc_opc_delete_mirror_rule	= 0x0261,
 +	i40e_aqc_opc_get_switch_config         = 0x0200,
 +	i40e_aqc_opc_add_statistics            = 0x0201,
 +	i40e_aqc_opc_remove_statistics         = 0x0202,
 +	i40e_aqc_opc_set_port_parameters       = 0x0203,
 +	i40e_aqc_opc_get_switch_resource_alloc = 0x0204,
 +
 +	i40e_aqc_opc_add_vsi                = 0x0210,
 +	i40e_aqc_opc_update_vsi_parameters  = 0x0211,
 +	i40e_aqc_opc_get_vsi_parameters     = 0x0212,
 +
 +	i40e_aqc_opc_add_pv                = 0x0220,
 +	i40e_aqc_opc_update_pv_parameters  = 0x0221,
 +	i40e_aqc_opc_get_pv_parameters     = 0x0222,
 +
 +	i40e_aqc_opc_add_veb               = 0x0230,
 +	i40e_aqc_opc_update_veb_parameters = 0x0231,
 +	i40e_aqc_opc_get_veb_parameters    = 0x0232,
 +
 +	i40e_aqc_opc_delete_element  = 0x0243,
 +
 +	i40e_aqc_opc_add_macvlan                  = 0x0250,
 +	i40e_aqc_opc_remove_macvlan               = 0x0251,
 +	i40e_aqc_opc_add_vlan                     = 0x0252,
 +	i40e_aqc_opc_remove_vlan                  = 0x0253,
 +	i40e_aqc_opc_set_vsi_promiscuous_modes    = 0x0254,
 +	i40e_aqc_opc_add_tag                      = 0x0255,
 +	i40e_aqc_opc_remove_tag                   = 0x0256,
 +	i40e_aqc_opc_add_multicast_etag           = 0x0257,
 +	i40e_aqc_opc_remove_multicast_etag        = 0x0258,
 +	i40e_aqc_opc_update_tag                   = 0x0259,
 +	i40e_aqc_opc_add_control_packet_filter    = 0x025A,
 +	i40e_aqc_opc_remove_control_packet_filter = 0x025B,
 +	i40e_aqc_opc_add_cloud_filters            = 0x025C,
 +	i40e_aqc_opc_remove_cloud_filters         = 0x025D,
 +
 +	i40e_aqc_opc_add_mirror_rule    = 0x0260,
 +	i40e_aqc_opc_delete_mirror_rule = 0x0261,
  
  	/* DCB commands */
 -	i40e_aqc_opc_dcb_ignore_pfc	= 0x0301,
 -	i40e_aqc_opc_dcb_updated	= 0x0302,
 +	i40e_aqc_opc_dcb_ignore_pfc = 0x0301,
 +	i40e_aqc_opc_dcb_updated    = 0x0302,
  
  	/* TX scheduler */
 -	i40e_aqc_opc_configure_vsi_bw_limit		= 0x0400,
 -	i40e_aqc_opc_configure_vsi_ets_sla_bw_limit	= 0x0406,
 -	i40e_aqc_opc_configure_vsi_tc_bw		= 0x0407,
 -	i40e_aqc_opc_query_vsi_bw_config		= 0x0408,
 -	i40e_aqc_opc_query_vsi_ets_sla_config		= 0x040A,
 -	i40e_aqc_opc_configure_switching_comp_bw_limit	= 0x0410,
 -
 -	i40e_aqc_opc_enable_switching_comp_ets			= 0x0413,
 -	i40e_aqc_opc_modify_switching_comp_ets			= 0x0414,
 -	i40e_aqc_opc_disable_switching_comp_ets			= 0x0415,
 -	i40e_aqc_opc_configure_switching_comp_ets_bw_limit	= 0x0416,
 -	i40e_aqc_opc_configure_switching_comp_bw_config		= 0x0417,
 -	i40e_aqc_opc_query_switching_comp_ets_config		= 0x0418,
 -	i40e_aqc_opc_query_port_ets_config			= 0x0419,
 -	i40e_aqc_opc_query_switching_comp_bw_config		= 0x041A,
 -	i40e_aqc_opc_suspend_port_tx				= 0x041B,
 -	i40e_aqc_opc_resume_port_tx				= 0x041C,
 -	i40e_aqc_opc_configure_partition_bw			= 0x041D,
 +	i40e_aqc_opc_configure_vsi_bw_limit            = 0x0400,
 +	i40e_aqc_opc_configure_vsi_ets_sla_bw_limit    = 0x0406,
 +	i40e_aqc_opc_configure_vsi_tc_bw               = 0x0407,
 +	i40e_aqc_opc_query_vsi_bw_config               = 0x0408,
 +	i40e_aqc_opc_query_vsi_ets_sla_config          = 0x040A,
 +	i40e_aqc_opc_configure_switching_comp_bw_limit = 0x0410,
 +
 +	i40e_aqc_opc_enable_switching_comp_ets             = 0x0413,
 +	i40e_aqc_opc_modify_switching_comp_ets             = 0x0414,
 +	i40e_aqc_opc_disable_switching_comp_ets            = 0x0415,
 +	i40e_aqc_opc_configure_switching_comp_ets_bw_limit = 0x0416,
 +	i40e_aqc_opc_configure_switching_comp_bw_config    = 0x0417,
 +	i40e_aqc_opc_query_switching_comp_ets_config       = 0x0418,
 +	i40e_aqc_opc_query_port_ets_config                 = 0x0419,
 +	i40e_aqc_opc_query_switching_comp_bw_config        = 0x041A,
 +	i40e_aqc_opc_suspend_port_tx                       = 0x041B,
 +	i40e_aqc_opc_resume_port_tx                        = 0x041C,
 +	i40e_aqc_opc_configure_partition_bw                = 0x041D,
  
  	/* hmc */
 -	i40e_aqc_opc_query_hmc_resource_profile	= 0x0500,
 -	i40e_aqc_opc_set_hmc_resource_profile	= 0x0501,
 +	i40e_aqc_opc_query_hmc_resource_profile = 0x0500,
 +	i40e_aqc_opc_set_hmc_resource_profile   = 0x0501,
  
  	/* phy commands*/
 -	i40e_aqc_opc_get_phy_abilities		= 0x0600,
 -	i40e_aqc_opc_set_phy_config		= 0x0601,
 -	i40e_aqc_opc_set_mac_config		= 0x0603,
 -	i40e_aqc_opc_set_link_restart_an	= 0x0605,
 -	i40e_aqc_opc_get_link_status		= 0x0607,
 -	i40e_aqc_opc_set_phy_int_mask		= 0x0613,
 -	i40e_aqc_opc_get_local_advt_reg		= 0x0614,
 -	i40e_aqc_opc_set_local_advt_reg		= 0x0615,
 -	i40e_aqc_opc_get_partner_advt		= 0x0616,
 -	i40e_aqc_opc_set_lb_modes		= 0x0618,
 -	i40e_aqc_opc_get_phy_wol_caps		= 0x0621,
 -	i40e_aqc_opc_set_phy_debug		= 0x0622,
 -	i40e_aqc_opc_upload_ext_phy_fm		= 0x0625,
 +	i40e_aqc_opc_get_phy_abilities   = 0x0600,
 +	i40e_aqc_opc_set_phy_config      = 0x0601,
 +	i40e_aqc_opc_set_mac_config      = 0x0603,
 +	i40e_aqc_opc_set_link_restart_an = 0x0605,
 +	i40e_aqc_opc_get_link_status     = 0x0607,
 +	i40e_aqc_opc_set_phy_int_mask    = 0x0613,
 +	i40e_aqc_opc_get_local_advt_reg  = 0x0614,
 +	i40e_aqc_opc_set_local_advt_reg  = 0x0615,
 +	i40e_aqc_opc_get_partner_advt    = 0x0616,
 +	i40e_aqc_opc_set_lb_modes        = 0x0618,
 +	i40e_aqc_opc_get_phy_wol_caps    = 0x0621,
 +	i40e_aqc_opc_set_phy_debug	 = 0x0622,
 +	i40e_aqc_opc_upload_ext_phy_fm   = 0x0625,
  
  	/* NVM commands */
 -	i40e_aqc_opc_nvm_read			= 0x0701,
 -	i40e_aqc_opc_nvm_erase			= 0x0702,
 -	i40e_aqc_opc_nvm_update			= 0x0703,
 -	i40e_aqc_opc_nvm_config_read		= 0x0704,
 -	i40e_aqc_opc_nvm_config_write		= 0x0705,
 +	i40e_aqc_opc_nvm_read         = 0x0701,
 +	i40e_aqc_opc_nvm_erase        = 0x0702,
 +	i40e_aqc_opc_nvm_update       = 0x0703,
 +	i40e_aqc_opc_nvm_config_read  = 0x0704,
 +	i40e_aqc_opc_nvm_config_write = 0x0705,
  
  	/* virtualization commands */
 -	i40e_aqc_opc_send_msg_to_pf		= 0x0801,
 -	i40e_aqc_opc_send_msg_to_vf		= 0x0802,
 -	i40e_aqc_opc_send_msg_to_peer		= 0x0803,
 +	i40e_aqc_opc_send_msg_to_pf   = 0x0801,
 +	i40e_aqc_opc_send_msg_to_vf   = 0x0802,
 +	i40e_aqc_opc_send_msg_to_peer = 0x0803,
  
  	/* alternate structure */
 -	i40e_aqc_opc_alternate_write		= 0x0900,
 -	i40e_aqc_opc_alternate_write_indirect	= 0x0901,
 -	i40e_aqc_opc_alternate_read		= 0x0902,
 -	i40e_aqc_opc_alternate_read_indirect	= 0x0903,
 -	i40e_aqc_opc_alternate_write_done	= 0x0904,
 -	i40e_aqc_opc_alternate_set_mode		= 0x0905,
 -	i40e_aqc_opc_alternate_clear_port	= 0x0906,
 +	i40e_aqc_opc_alternate_write          = 0x0900,
 +	i40e_aqc_opc_alternate_write_indirect = 0x0901,
 +	i40e_aqc_opc_alternate_read           = 0x0902,
 +	i40e_aqc_opc_alternate_read_indirect  = 0x0903,
 +	i40e_aqc_opc_alternate_write_done     = 0x0904,
 +	i40e_aqc_opc_alternate_set_mode       = 0x0905,
 +	i40e_aqc_opc_alternate_clear_port     = 0x0906,
  
  	/* LLDP commands */
++<<<<<<< HEAD
 +	i40e_aqc_opc_lldp_get_mib    = 0x0A00,
 +	i40e_aqc_opc_lldp_update_mib = 0x0A01,
 +	i40e_aqc_opc_lldp_add_tlv    = 0x0A02,
 +	i40e_aqc_opc_lldp_update_tlv = 0x0A03,
 +	i40e_aqc_opc_lldp_delete_tlv = 0x0A04,
 +	i40e_aqc_opc_lldp_stop       = 0x0A05,
 +	i40e_aqc_opc_lldp_start      = 0x0A06,
++=======
+ 	i40e_aqc_opc_lldp_get_mib	= 0x0A00,
+ 	i40e_aqc_opc_lldp_update_mib	= 0x0A01,
+ 	i40e_aqc_opc_lldp_add_tlv	= 0x0A02,
+ 	i40e_aqc_opc_lldp_update_tlv	= 0x0A03,
+ 	i40e_aqc_opc_lldp_delete_tlv	= 0x0A04,
+ 	i40e_aqc_opc_lldp_stop		= 0x0A05,
+ 	i40e_aqc_opc_lldp_start		= 0x0A06,
+ 	i40e_aqc_opc_get_cee_dcb_cfg	= 0x0A07,
++>>>>>>> 9fa61dd2153a (i40e: Add support to firmware CEE DCBX mode)
  
  	/* Tunnel commands */
 -	i40e_aqc_opc_add_udp_tunnel	= 0x0B00,
 -	i40e_aqc_opc_del_udp_tunnel	= 0x0B01,
 -	i40e_aqc_opc_tunnel_key_structure	= 0x0B10,
 +	i40e_aqc_opc_add_udp_tunnel       = 0x0B00,
 +	i40e_aqc_opc_del_udp_tunnel       = 0x0B01,
 +	i40e_aqc_opc_tunnel_key_structure = 0x0B10,
  
  	/* Async Events */
 -	i40e_aqc_opc_event_lan_overflow		= 0x1001,
 +	i40e_aqc_opc_event_lan_overflow = 0x1001,
  
  	/* OEM commands */
 -	i40e_aqc_opc_oem_parameter_change	= 0xFE00,
 -	i40e_aqc_opc_oem_device_status_change	= 0xFE01,
 +	i40e_aqc_opc_oem_parameter_change     = 0xFE00,
 +	i40e_aqc_opc_oem_device_status_change = 0xFE01,
  
  	/* debug commands */
 -	i40e_aqc_opc_debug_get_deviceid		= 0xFF00,
 -	i40e_aqc_opc_debug_set_mode		= 0xFF01,
 -	i40e_aqc_opc_debug_read_reg		= 0xFF03,
 -	i40e_aqc_opc_debug_write_reg		= 0xFF04,
 -	i40e_aqc_opc_debug_modify_reg		= 0xFF07,
 -	i40e_aqc_opc_debug_dump_internals	= 0xFF08,
 -	i40e_aqc_opc_debug_modify_internals	= 0xFF09,
 +	i40e_aqc_opc_debug_get_deviceid     = 0xFF00,
 +	i40e_aqc_opc_debug_set_mode         = 0xFF01,
 +	i40e_aqc_opc_debug_read_reg         = 0xFF03,
 +	i40e_aqc_opc_debug_write_reg        = 0xFF04,
 +	i40e_aqc_opc_debug_modify_reg       = 0xFF07,
 +	i40e_aqc_opc_debug_dump_internals   = 0xFF08,
 +	i40e_aqc_opc_debug_modify_internals = 0xFF09,
  };
  
  /* command structures and indirect data structures */
@@@ -1988,15 -1988,55 +1999,55 @@@ struct i40e_aqc_lldp_start 
  
  I40E_CHECK_CMD_LENGTH(i40e_aqc_lldp_start);
  
- /* Apply MIB changes (0x0A07)
-  * uses the generic struc as it contains no data
+ /* Get CEE DCBX Oper Config (0x0A07)
+  * uses the generic descriptor struct
+  * returns below as indirect response
   */
  
+ #define I40E_AQC_CEE_APP_FCOE_SHIFT	0x0
+ #define I40E_AQC_CEE_APP_FCOE_MASK	(0x7 << I40E_AQC_CEE_APP_FCOE_SHIFT)
+ #define I40E_AQC_CEE_APP_ISCSI_SHIFT	0x3
+ #define I40E_AQC_CEE_APP_ISCSI_MASK	(0x7 << I40E_AQC_CEE_APP_ISCSI_SHIFT)
+ #define I40E_AQC_CEE_APP_FIP_SHIFT	0x8
+ #define I40E_AQC_CEE_APP_FIP_MASK	(0x7 << I40E_AQC_CEE_APP_FIP_SHIFT)
+ #define I40E_AQC_CEE_PG_STATUS_SHIFT	0x0
+ #define I40E_AQC_CEE_PG_STATUS_MASK	(0x7 << I40E_AQC_CEE_PG_STATUS_SHIFT)
+ #define I40E_AQC_CEE_PFC_STATUS_SHIFT	0x3
+ #define I40E_AQC_CEE_PFC_STATUS_MASK	(0x7 << I40E_AQC_CEE_PFC_STATUS_SHIFT)
+ #define I40E_AQC_CEE_APP_STATUS_SHIFT	0x8
+ #define I40E_AQC_CEE_APP_STATUS_MASK	(0x7 << I40E_AQC_CEE_APP_STATUS_SHIFT)
+ struct i40e_aqc_get_cee_dcb_cfg_v1_resp {
+ 	u8	reserved1;
+ 	u8	oper_num_tc;
+ 	u8	oper_prio_tc[4];
+ 	u8	reserved2;
+ 	u8	oper_tc_bw[8];
+ 	u8	oper_pfc_en;
+ 	u8	reserved3;
+ 	__le16	oper_app_prio;
+ 	u8	reserved4;
+ 	__le16	tlv_status;
+ };
+ 
+ I40E_CHECK_STRUCT_LEN(0x18, i40e_aqc_get_cee_dcb_cfg_v1_resp);
+ 
+ struct i40e_aqc_get_cee_dcb_cfg_resp {
+ 	u8	oper_num_tc;
+ 	u8	oper_prio_tc[4];
+ 	u8	oper_tc_bw[8];
+ 	u8	oper_pfc_en;
+ 	__le16	oper_app_prio;
+ 	__le32	tlv_status;
+ 	u8	reserved[12];
+ };
+ 
+ I40E_CHECK_STRUCT_LEN(0x20, i40e_aqc_get_cee_dcb_cfg_resp);
+ 
  /* Add Udp Tunnel command and completion (direct 0x0B00) */
  struct i40e_aqc_add_udp_tunnel {
 -	__le16	udp_port;
 -	u8	reserved0[3];
 -	u8	protocol_type;
 +	__le16 udp_port;
 +	u8     reserved0[3];
 +	u8     protocol_type;
  #define I40E_AQC_TUNNEL_TYPE_VXLAN	0x00
  #define I40E_AQC_TUNNEL_TYPE_NGE	0x01
  #define I40E_AQC_TUNNEL_TYPE_TEREDO	0x10
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_adminq_cmd.h
diff --git a/drivers/net/ethernet/intel/i40e/i40e_common.c b/drivers/net/ethernet/intel/i40e/i40e_common.c
index 770208ed3eac..a2a576eaaed0 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_common.c
@@ -2658,6 +2658,34 @@ i40e_status i40e_aq_start_lldp(struct i40e_hw *hw,
 	return status;
 }
 
+/**
+ * i40e_aq_get_cee_dcb_config
+ * @hw: pointer to the hw struct
+ * @buff: response buffer that stores CEE operational configuration
+ * @buff_size: size of the buffer passed
+ * @cmd_details: pointer to command details structure or NULL
+ *
+ * Get CEE DCBX mode operational configuration from firmware
+ **/
+i40e_status i40e_aq_get_cee_dcb_config(struct i40e_hw *hw,
+				       void *buff, u16 buff_size,
+				       struct i40e_asq_cmd_details *cmd_details)
+{
+	struct i40e_aq_desc desc;
+	i40e_status status;
+
+	if (buff_size == 0 || !buff)
+		return I40E_ERR_PARAM;
+
+	i40e_fill_default_direct_cmd_desc(&desc, i40e_aqc_opc_get_cee_dcb_cfg);
+
+	desc.flags |= cpu_to_le16((u16)I40E_AQ_FLAG_BUF);
+	status = i40e_asq_send_command(hw, &desc, (void *)buff, buff_size,
+				       cmd_details);
+
+	return status;
+}
+
 /**
  * i40e_aq_add_udp_tunnel
  * @hw: pointer to the hw struct
diff --git a/drivers/net/ethernet/intel/i40e/i40e_dcb.c b/drivers/net/ethernet/intel/i40e/i40e_dcb.c
index 036570d76176..1396c70b871c 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_dcb.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_dcb.c
@@ -59,7 +59,7 @@ i40e_status i40e_get_dcbx_status(struct i40e_hw *hw, u16 *status)
 static void i40e_parse_ieee_etscfg_tlv(struct i40e_lldp_org_tlv *tlv,
 				       struct i40e_dcbx_config *dcbcfg)
 {
-	struct i40e_ieee_ets_config *etscfg;
+	struct i40e_dcb_ets_config *etscfg;
 	u8 *buf = tlv->tlvinfo;
 	u16 offset = 0;
 	u8 priority;
@@ -406,6 +406,166 @@ free_mem:
 	return ret;
 }
 
+/**
+ * i40e_cee_to_dcb_v1_config
+ * @cee_cfg: pointer to CEE v1 response configuration struct
+ * @dcbcfg: DCB configuration struct
+ *
+ * Convert CEE v1 configuration from firmware to DCB configuration
+ **/
+static void i40e_cee_to_dcb_v1_config(
+			struct i40e_aqc_get_cee_dcb_cfg_v1_resp *cee_cfg,
+			struct i40e_dcbx_config *dcbcfg)
+{
+	u16 status, tlv_status = le16_to_cpu(cee_cfg->tlv_status);
+	u16 app_prio = le16_to_cpu(cee_cfg->oper_app_prio);
+	u8 i, tc, err, sync, oper;
+
+	/* CEE PG data to ETS config */
+	dcbcfg->etscfg.maxtcs = cee_cfg->oper_num_tc;
+
+	for (i = 0; i < 4; i++) {
+		tc = (u8)((cee_cfg->oper_prio_tc[i] &
+			 I40E_CEE_PGID_PRIO_1_MASK) >>
+			 I40E_CEE_PGID_PRIO_1_SHIFT);
+		dcbcfg->etscfg.prioritytable[i*2] =  tc;
+		tc = (u8)((cee_cfg->oper_prio_tc[i] &
+			 I40E_CEE_PGID_PRIO_0_MASK) >>
+			 I40E_CEE_PGID_PRIO_0_SHIFT);
+		dcbcfg->etscfg.prioritytable[i*2 + 1] = tc;
+	}
+
+	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)
+		dcbcfg->etscfg.tcbwtable[i] = cee_cfg->oper_tc_bw[i];
+
+	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+		if (dcbcfg->etscfg.prioritytable[i] == I40E_CEE_PGID_STRICT) {
+			/* Map it to next empty TC */
+			dcbcfg->etscfg.prioritytable[i] =
+						cee_cfg->oper_num_tc - 1;
+			dcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_STRICT;
+		} else {
+			dcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_ETS;
+		}
+	}
+
+	/* CEE PFC data to ETS config */
+	dcbcfg->pfc.pfcenable = cee_cfg->oper_pfc_en;
+	dcbcfg->pfc.pfccap = I40E_MAX_TRAFFIC_CLASS;
+
+	status = (tlv_status & I40E_AQC_CEE_APP_STATUS_MASK) >>
+		  I40E_AQC_CEE_APP_STATUS_SHIFT;
+	err = (status & I40E_TLV_STATUS_ERR) ? 1 : 0;
+	sync = (status & I40E_TLV_STATUS_SYNC) ? 1 : 0;
+	oper = (status & I40E_TLV_STATUS_OPER) ? 1 : 0;
+	/* Add APPs if Error is False and Oper/Sync is True */
+	if (!err && sync && oper) {
+		/* CEE operating configuration supports FCoE/iSCSI/FIP only */
+		dcbcfg->numapps = I40E_CEE_OPER_MAX_APPS;
+
+		/* FCoE APP */
+		dcbcfg->app[0].priority =
+			(app_prio & I40E_AQC_CEE_APP_FCOE_MASK) >>
+			 I40E_AQC_CEE_APP_FCOE_SHIFT;
+		dcbcfg->app[0].selector = I40E_APP_SEL_ETHTYPE;
+		dcbcfg->app[0].protocolid = I40E_APP_PROTOID_FCOE;
+
+		/* iSCSI APP */
+		dcbcfg->app[1].priority =
+			(app_prio & I40E_AQC_CEE_APP_ISCSI_MASK) >>
+			 I40E_AQC_CEE_APP_ISCSI_SHIFT;
+		dcbcfg->app[1].selector = I40E_APP_SEL_TCPIP;
+		dcbcfg->app[1].protocolid = I40E_APP_PROTOID_ISCSI;
+
+		/* FIP APP */
+		dcbcfg->app[2].priority =
+			(app_prio & I40E_AQC_CEE_APP_FIP_MASK) >>
+			 I40E_AQC_CEE_APP_FIP_SHIFT;
+		dcbcfg->app[2].selector = I40E_APP_SEL_ETHTYPE;
+		dcbcfg->app[2].protocolid = I40E_APP_PROTOID_FIP;
+	}
+}
+
+/**
+ * i40e_cee_to_dcb_config
+ * @cee_cfg: pointer to CEE configuration struct
+ * @dcbcfg: DCB configuration struct
+ *
+ * Convert CEE configuration from firmware to DCB configuration
+ **/
+static void i40e_cee_to_dcb_config(
+				struct i40e_aqc_get_cee_dcb_cfg_resp *cee_cfg,
+				struct i40e_dcbx_config *dcbcfg)
+{
+	u32 status, tlv_status = le32_to_cpu(cee_cfg->tlv_status);
+	u16 app_prio = le16_to_cpu(cee_cfg->oper_app_prio);
+	u8 i, tc, err, sync, oper;
+
+	/* CEE PG data to ETS config */
+	dcbcfg->etscfg.maxtcs = cee_cfg->oper_num_tc;
+
+	for (i = 0; i < 4; i++) {
+		tc = (u8)((cee_cfg->oper_prio_tc[i] &
+			 I40E_CEE_PGID_PRIO_1_MASK) >>
+			 I40E_CEE_PGID_PRIO_1_SHIFT);
+		dcbcfg->etscfg.prioritytable[i*2] =  tc;
+		tc = (u8)((cee_cfg->oper_prio_tc[i] &
+			 I40E_CEE_PGID_PRIO_0_MASK) >>
+			 I40E_CEE_PGID_PRIO_0_SHIFT);
+		dcbcfg->etscfg.prioritytable[i*2 + 1] = tc;
+	}
+
+	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++)
+		dcbcfg->etscfg.tcbwtable[i] = cee_cfg->oper_tc_bw[i];
+
+	for (i = 0; i < I40E_MAX_TRAFFIC_CLASS; i++) {
+		if (dcbcfg->etscfg.prioritytable[i] == I40E_CEE_PGID_STRICT) {
+			/* Map it to next empty TC */
+			dcbcfg->etscfg.prioritytable[i] =
+						cee_cfg->oper_num_tc - 1;
+			dcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_STRICT;
+		} else {
+			dcbcfg->etscfg.tsatable[i] = I40E_IEEE_TSA_ETS;
+		}
+	}
+
+	/* CEE PFC data to ETS config */
+	dcbcfg->pfc.pfcenable = cee_cfg->oper_pfc_en;
+	dcbcfg->pfc.pfccap = I40E_MAX_TRAFFIC_CLASS;
+
+	status = (tlv_status & I40E_AQC_CEE_APP_STATUS_MASK) >>
+		  I40E_AQC_CEE_APP_STATUS_SHIFT;
+	err = (status & I40E_TLV_STATUS_ERR) ? 1 : 0;
+	sync = (status & I40E_TLV_STATUS_SYNC) ? 1 : 0;
+	oper = (status & I40E_TLV_STATUS_OPER) ? 1 : 0;
+	/* Add APPs if Error is False and Oper/Sync is True */
+	if (!err && sync && oper) {
+		/* CEE operating configuration supports FCoE/iSCSI/FIP only */
+		dcbcfg->numapps = I40E_CEE_OPER_MAX_APPS;
+
+		/* FCoE APP */
+		dcbcfg->app[0].priority =
+			(app_prio & I40E_AQC_CEE_APP_FCOE_MASK) >>
+			 I40E_AQC_CEE_APP_FCOE_SHIFT;
+		dcbcfg->app[0].selector = I40E_APP_SEL_ETHTYPE;
+		dcbcfg->app[0].protocolid = I40E_APP_PROTOID_FCOE;
+
+		/* iSCSI APP */
+		dcbcfg->app[1].priority =
+			(app_prio & I40E_AQC_CEE_APP_ISCSI_MASK) >>
+			 I40E_AQC_CEE_APP_ISCSI_SHIFT;
+		dcbcfg->app[1].selector = I40E_APP_SEL_TCPIP;
+		dcbcfg->app[1].protocolid = I40E_APP_PROTOID_ISCSI;
+
+		/* FIP APP */
+		dcbcfg->app[2].priority =
+			(app_prio & I40E_AQC_CEE_APP_FIP_MASK) >>
+			 I40E_AQC_CEE_APP_FIP_SHIFT;
+		dcbcfg->app[2].selector = I40E_APP_SEL_ETHTYPE;
+		dcbcfg->app[2].protocolid = I40E_APP_PROTOID_FIP;
+	}
+}
+
 /**
  * i40e_get_dcb_config
  * @hw: pointer to the hw struct
@@ -415,7 +575,44 @@ free_mem:
 i40e_status i40e_get_dcb_config(struct i40e_hw *hw)
 {
 	i40e_status ret = 0;
+	struct i40e_aqc_get_cee_dcb_cfg_resp cee_cfg;
+	struct i40e_aqc_get_cee_dcb_cfg_v1_resp cee_v1_cfg;
+
+	/* If Firmware version < v4.33 IEEE only */
+	if (((hw->aq.fw_maj_ver == 4) && (hw->aq.fw_min_ver < 33)) ||
+	    (hw->aq.fw_maj_ver < 4))
+		goto ieee;
+
+	/* If Firmware version == v4.33 use old CEE struct */
+	if ((hw->aq.fw_maj_ver == 4) && (hw->aq.fw_min_ver == 33)) {
+		ret = i40e_aq_get_cee_dcb_config(hw, &cee_v1_cfg,
+						 sizeof(cee_v1_cfg), NULL);
+		if (!ret) {
+			/* CEE mode */
+			hw->local_dcbx_config.dcbx_mode = I40E_DCBX_MODE_CEE;
+			i40e_cee_to_dcb_v1_config(&cee_v1_cfg,
+						  &hw->local_dcbx_config);
+		}
+	} else {
+		ret = i40e_aq_get_cee_dcb_config(hw, &cee_cfg,
+						 sizeof(cee_cfg), NULL);
+		if (!ret) {
+			/* CEE mode */
+			hw->local_dcbx_config.dcbx_mode = I40E_DCBX_MODE_CEE;
+			i40e_cee_to_dcb_config(&cee_cfg,
+					       &hw->local_dcbx_config);
+		}
+	}
+
+	/* CEE mode not enabled try querying IEEE data */
+	if (hw->aq.asq_last_status == I40E_AQ_RC_ENOENT)
+		goto ieee;
+	else
+		goto out;
 
+ieee:
+	/* IEEE mode */
+	hw->local_dcbx_config.dcbx_mode = I40E_DCBX_MODE_IEEE;
 	/* Get Local DCB Config */
 	ret = i40e_aq_get_dcb_config(hw, I40E_AQ_LLDP_MIB_LOCAL, 0,
 				     &hw->local_dcbx_config);
@@ -426,6 +623,10 @@ i40e_status i40e_get_dcb_config(struct i40e_hw *hw)
 	ret = i40e_aq_get_dcb_config(hw, I40E_AQ_LLDP_MIB_REMOTE,
 				     I40E_AQ_LLDP_BRIDGE_TYPE_NEAREST_BRIDGE,
 				     &hw->remote_dcbx_config);
+	/* Don't treat ENOENT as an error for Remote MIBs */
+	if (hw->aq.asq_last_status == I40E_AQ_RC_ENOENT)
+		ret = 0;
+
 out:
 	return ret;
 }
diff --git a/drivers/net/ethernet/intel/i40e/i40e_dcb.h b/drivers/net/ethernet/intel/i40e/i40e_dcb.h
index 34cf1c30c7ff..e137e3fac8ee 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_dcb.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_dcb.h
@@ -65,6 +65,11 @@
 #define I40E_IEEE_ETS_PRIO_0_MASK	(0x7 << I40E_IEEE_ETS_PRIO_0_SHIFT)
 #define I40E_IEEE_ETS_PRIO_1_SHIFT	4
 #define I40E_IEEE_ETS_PRIO_1_MASK	(0x7 << I40E_IEEE_ETS_PRIO_1_SHIFT)
+#define I40E_CEE_PGID_PRIO_0_SHIFT	0
+#define I40E_CEE_PGID_PRIO_0_MASK	(0xF << I40E_CEE_PGID_PRIO_0_SHIFT)
+#define I40E_CEE_PGID_PRIO_1_SHIFT	4
+#define I40E_CEE_PGID_PRIO_1_MASK	(0xF << I40E_CEE_PGID_PRIO_1_SHIFT)
+#define I40E_CEE_PGID_STRICT		15
 
 /* Defines for IEEE TSA types */
 #define I40E_IEEE_TSA_STRICT		0
diff --git a/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c b/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c
index 00bc0cdb3a03..183dcb63ce98 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_dcb_nl.c
@@ -207,7 +207,7 @@ void i40e_dcbnl_set_all(struct i40e_vsi *vsi)
  * VSI
  **/
 static int i40e_dcbnl_vsi_del_app(struct i40e_vsi *vsi,
-				  struct i40e_ieee_app_priority_table *app)
+				  struct i40e_dcb_app_priority_table *app)
 {
 	struct net_device *dev = vsi->netdev;
 	struct dcb_app sapp;
@@ -229,7 +229,7 @@ static int i40e_dcbnl_vsi_del_app(struct i40e_vsi *vsi,
  * Delete given APP from all the VSIs for given PF
  **/
 static void i40e_dcbnl_del_app(struct i40e_pf *pf,
-			      struct i40e_ieee_app_priority_table *app)
+			       struct i40e_dcb_app_priority_table *app)
 {
 	int v, err;
 	for (v = 0; v < pf->num_alloc_vsi; v++) {
@@ -252,7 +252,7 @@ static void i40e_dcbnl_del_app(struct i40e_pf *pf,
  * Find given APP in the DCB configuration
  **/
 static bool i40e_dcbnl_find_app(struct i40e_dcbx_config *cfg,
-				struct i40e_ieee_app_priority_table *app)
+				struct i40e_dcb_app_priority_table *app)
 {
 	int i;
 
@@ -277,7 +277,7 @@ static bool i40e_dcbnl_find_app(struct i40e_dcbx_config *cfg,
 void i40e_dcbnl_flush_apps(struct i40e_pf *pf,
 			   struct i40e_dcbx_config *new_cfg)
 {
-	struct i40e_ieee_app_priority_table app;
+	struct i40e_dcb_app_priority_table app;
 	struct i40e_dcbx_config *dcbxcfg;
 	struct i40e_hw *hw = &pf->hw;
 	int i;
diff --git a/drivers/net/ethernet/intel/i40e/i40e_debugfs.c b/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
index a03f4590cb0f..3a3c237b76d4 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
@@ -1312,6 +1312,8 @@ static ssize_t i40e_dbg_command_write(struct file *filp,
 			kfree(bw_data);
 			bw_data = NULL;
 
+			dev_info(&pf->pdev->dev,
+				 "port dcbx_mode=%d\n", cfg->dcbx_mode);
 			dev_info(&pf->pdev->dev,
 				 "port ets_cfg: willing=%d cbs=%d, maxtcs=%d\n",
 				 cfg->etscfg.willing, cfg->etscfg.cbs,
diff --git a/drivers/net/ethernet/intel/i40e/i40e_fcoe.c b/drivers/net/ethernet/intel/i40e/i40e_fcoe.c
index dc37b779005a..4537c0319d46 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_fcoe.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_fcoe.c
@@ -347,7 +347,7 @@ int i40e_init_pf_fcoe(struct i40e_pf *pf)
  **/
 u8 i40e_get_fcoe_tc_map(struct i40e_pf *pf)
 {
-	struct i40e_ieee_app_priority_table app;
+	struct i40e_dcb_app_priority_table app;
 	struct i40e_hw *hw = &pf->hw;
 	u8 enabled_tc = 0;
 	u8 tc, i;
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index 9854310d4c60..35c8be97d9e3 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -4442,6 +4442,8 @@ static int i40e_init_pf_dcb(struct i40e_pf *pf)
 			/* Enable DCB tagging only when more than one TC */
 			if (i40e_dcb_get_num_tc(&hw->local_dcbx_config) > 1)
 				pf->flags |= I40E_FLAG_DCB_ENABLED;
+			dev_dbg(&pf->pdev->dev,
+				"DCBX offload is supported for this PF.\n");
 		}
 	} else {
 		dev_info(&pf->pdev->dev, "AQ Querying DCB configuration failed: %d\n",
@@ -5023,6 +5025,8 @@ bool i40e_dcb_need_reconfig(struct i40e_pf *pf,
 		dev_dbg(&pf->pdev->dev, "APP Table change detected.\n");
 	}
 
+	dev_dbg(&pf->pdev->dev, "%s: need_reconfig=%d\n", __func__,
+		need_reconfig);
 	return need_reconfig;
 }
 
@@ -5050,11 +5054,16 @@ static int i40e_handle_lldp_event(struct i40e_pf *pf,
 	/* Ignore if event is not for Nearest Bridge */
 	type = ((mib->type >> I40E_AQ_LLDP_BRIDGE_TYPE_SHIFT)
 		& I40E_AQ_LLDP_BRIDGE_TYPE_MASK);
+	dev_dbg(&pf->pdev->dev,
+		"%s: LLDP event mib bridge type 0x%x\n", __func__, type);
 	if (type != I40E_AQ_LLDP_BRIDGE_TYPE_NEAREST_BRIDGE)
 		return ret;
 
 	/* Check MIB Type and return if event for Remote MIB update */
 	type = mib->type & I40E_AQ_LLDP_MIB_TYPE_MASK;
+	dev_dbg(&pf->pdev->dev,
+		"%s: LLDP event mib type %s\n", __func__,
+		type ? "remote" : "local");
 	if (type == I40E_AQ_LLDP_MIB_REMOTE) {
 		/* Update the remote cached instance and return */
 		ret = i40e_aq_get_dcb_config(hw, I40E_AQ_LLDP_MIB_REMOTE,
@@ -5063,12 +5072,14 @@ static int i40e_handle_lldp_event(struct i40e_pf *pf,
 		goto exit;
 	}
 
-	/* Convert/store the DCBX data from LLDPDU temporarily */
 	memset(&tmp_dcbx_cfg, 0, sizeof(tmp_dcbx_cfg));
-	ret = i40e_lldp_to_dcb_config(e->msg_buf, &tmp_dcbx_cfg);
+	/* Store the old configuration */
+	tmp_dcbx_cfg = *dcbx_cfg;
+
+	/* Get updated DCBX data from firmware */
+	ret = i40e_get_dcb_config(&pf->hw);
 	if (ret) {
-		/* Error in LLDPDU parsing return */
-		dev_info(&pf->pdev->dev, "Failed parsing LLDPDU from event buffer\n");
+		dev_info(&pf->pdev->dev, "Failed querying DCB configuration data from firmware.\n");
 		goto exit;
 	}
 
@@ -5078,12 +5089,9 @@ static int i40e_handle_lldp_event(struct i40e_pf *pf,
 		goto exit;
 	}
 
-	need_reconfig = i40e_dcb_need_reconfig(pf, dcbx_cfg, &tmp_dcbx_cfg);
-
-	i40e_dcbnl_flush_apps(pf, &tmp_dcbx_cfg);
+	need_reconfig = i40e_dcb_need_reconfig(pf, &tmp_dcbx_cfg, dcbx_cfg);
 
-	/* Overwrite the new configuration */
-	*dcbx_cfg = tmp_dcbx_cfg;
+	i40e_dcbnl_flush_apps(pf, dcbx_cfg);
 
 	if (!need_reconfig)
 		goto exit;
diff --git a/drivers/net/ethernet/intel/i40e/i40e_prototype.h b/drivers/net/ethernet/intel/i40e/i40e_prototype.h
index 98a735cdf038..24bdc4333dc6 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_prototype.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_prototype.h
@@ -175,6 +175,9 @@ i40e_status i40e_aq_stop_lldp(struct i40e_hw *hw, bool shutdown_agent,
 				struct i40e_asq_cmd_details *cmd_details);
 i40e_status i40e_aq_start_lldp(struct i40e_hw *hw,
 				struct i40e_asq_cmd_details *cmd_details);
+i40e_status i40e_aq_get_cee_dcb_config(struct i40e_hw *hw,
+				       void *buff, u16 buff_size,
+				       struct i40e_asq_cmd_details *cmd_details);
 i40e_status i40e_aq_add_udp_tunnel(struct i40e_hw *hw,
 				u16 udp_port, u8 protocol_index,
 				u8 *filter_index,
diff --git a/drivers/net/ethernet/intel/i40e/i40e_type.h b/drivers/net/ethernet/intel/i40e/i40e_type.h
index 3a237c3d0dcb..afe2539b49d6 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_type.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_type.h
@@ -381,9 +381,18 @@ struct i40e_fc_info {
 #define I40E_MAX_USER_PRIORITY		8
 #define I40E_DCBX_MAX_APPS		32
 #define I40E_LLDPDU_SIZE		1500
-
-/* IEEE 802.1Qaz ETS Configuration data */
-struct i40e_ieee_ets_config {
+#define I40E_TLV_STATUS_OPER		0x1
+#define I40E_TLV_STATUS_SYNC		0x2
+#define I40E_TLV_STATUS_ERR		0x4
+#define I40E_CEE_OPER_MAX_APPS		3
+#define I40E_APP_PROTOID_FCOE		0x8906
+#define I40E_APP_PROTOID_ISCSI		0x0cbc
+#define I40E_APP_PROTOID_FIP		0x8914
+#define I40E_APP_SEL_ETHTYPE		0x1
+#define I40E_APP_SEL_TCPIP		0x2
+
+/* CEE or IEEE 802.1Qaz ETS Configuration data */
+struct i40e_dcb_ets_config {
 	u8 willing;
 	u8 cbs;
 	u8 maxtcs;
@@ -392,34 +401,30 @@ struct i40e_ieee_ets_config {
 	u8 tsatable[I40E_MAX_TRAFFIC_CLASS];
 };
 
-/* IEEE 802.1Qaz ETS Recommendation data */
-struct i40e_ieee_ets_recommend {
-	u8 prioritytable[I40E_MAX_TRAFFIC_CLASS];
-	u8 tcbwtable[I40E_MAX_TRAFFIC_CLASS];
-	u8 tsatable[I40E_MAX_TRAFFIC_CLASS];
-};
-
-/* IEEE 802.1Qaz PFC Configuration data */
-struct i40e_ieee_pfc_config {
+/* CEE or IEEE 802.1Qaz PFC Configuration data */
+struct i40e_dcb_pfc_config {
 	u8 willing;
 	u8 mbc;
 	u8 pfccap;
 	u8 pfcenable;
 };
 
-/* IEEE 802.1Qaz Application Priority data */
-struct i40e_ieee_app_priority_table {
+/* CEE or IEEE 802.1Qaz Application Priority data */
+struct i40e_dcb_app_priority_table {
 	u8  priority;
 	u8  selector;
 	u16 protocolid;
 };
 
 struct i40e_dcbx_config {
+	u8  dcbx_mode;
+#define I40E_DCBX_MODE_CEE	0x1
+#define I40E_DCBX_MODE_IEEE	0x2
 	u32 numapps;
-	struct i40e_ieee_ets_config etscfg;
-	struct i40e_ieee_ets_recommend etsrec;
-	struct i40e_ieee_pfc_config pfc;
-	struct i40e_ieee_app_priority_table app[I40E_DCBX_MAX_APPS];
+	struct i40e_dcb_ets_config etscfg;
+	struct i40e_dcb_ets_config etsrec;
+	struct i40e_dcb_pfc_config pfc;
+	struct i40e_dcb_app_priority_table app[I40E_DCBX_MAX_APPS];
 };
 
 /* Port hardware description */
