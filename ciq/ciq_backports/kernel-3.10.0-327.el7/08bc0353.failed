cifs: revalidate mapping prior to satisfying read_iter request with cache=loose

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jeff Layton <jlayton@poochiereds.net>
commit 08bc03539d38508eff3fd470a82ea422ce279f6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/08bc0353.failed

Before satisfying a read with cache=loose, we should always check
that the pagecache is valid before allowing a read to be satisfied
out of it.

	Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Signed-off-by: Jeff Layton <jlayton@poochiereds.net>
	Signed-off-by: Steve French <smfrench@gmail.com>
(cherry picked from commit 08bc03539d38508eff3fd470a82ea422ce279f6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifsfs.c
diff --cc fs/cifs/cifsfs.c
index 35309d1d74d2,888398067420..000000000000
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@@ -724,8 -725,20 +724,25 @@@ out_nls
  	goto out;
  }
  
++<<<<<<< HEAD
 +static ssize_t cifs_file_aio_write(struct kiocb *iocb, const struct iovec *iov,
 +				   unsigned long nr_segs, loff_t pos)
++=======
+ static ssize_t
+ cifs_loose_read_iter(struct kiocb *iocb, struct iov_iter *iter)
+ {
+ 	ssize_t rc;
+ 	struct inode *inode = file_inode(iocb->ki_filp);
+ 
+ 	rc = cifs_revalidate_mapping(inode);
+ 	if (rc)
+ 		return rc;
+ 
+ 	return generic_file_read_iter(iocb, iter);
+ }
+ 
+ static ssize_t cifs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
++>>>>>>> 08bc03539d38 (cifs: revalidate mapping prior to satisfying read_iter request with cache=loose)
  {
  	struct inode *inode = file_inode(iocb->ki_filp);
  	struct cifsInodeInfo *cinode = CIFS_I(inode);
@@@ -888,10 -892,10 +905,17 @@@ const struct inode_operations cifs_syml
  };
  
  const struct file_operations cifs_file_ops = {
++<<<<<<< HEAD
 +	.read = do_sync_read,
 +	.write = do_sync_write,
 +	.aio_read = generic_file_aio_read,
 +	.aio_write = cifs_file_aio_write,
++=======
+ 	.read = new_sync_read,
+ 	.write = new_sync_write,
+ 	.read_iter = cifs_loose_read_iter,
+ 	.write_iter = cifs_file_write_iter,
++>>>>>>> 08bc03539d38 (cifs: revalidate mapping prior to satisfying read_iter request with cache=loose)
  	.open = cifs_open,
  	.release = cifs_close,
  	.lock = cifs_lock,
@@@ -946,10 -950,10 +970,17 @@@ const struct file_operations cifs_file_
  };
  
  const struct file_operations cifs_file_nobrl_ops = {
++<<<<<<< HEAD
 +	.read = do_sync_read,
 +	.write = do_sync_write,
 +	.aio_read = generic_file_aio_read,
 +	.aio_write = cifs_file_aio_write,
++=======
+ 	.read = new_sync_read,
+ 	.write = new_sync_write,
+ 	.read_iter = cifs_loose_read_iter,
+ 	.write_iter = cifs_file_write_iter,
++>>>>>>> 08bc03539d38 (cifs: revalidate mapping prior to satisfying read_iter request with cache=loose)
  	.open = cifs_open,
  	.release = cifs_close,
  	.fsync = cifs_fsync,
* Unmerged path fs/cifs/cifsfs.c
