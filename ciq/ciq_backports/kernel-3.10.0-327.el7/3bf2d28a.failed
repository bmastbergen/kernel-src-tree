bonding: clean up style for bond_3ad.c

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@redhat.com>
commit 3bf2d28a2d7112bdae851f420b9f2386b3fb362a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3bf2d28a.failed

It's a huge mess currently, that is really hard to read. This cleanup
doesn't touch the logic at all, it only breaks easy-to-fix long lines and
updates comment styles.

CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3bf2d28a2d7112bdae851f420b9f2386b3fb362a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
diff --cc drivers/net/bonding/bond_3ad.c
index dc508c87249d,9828209ab492..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -179,38 -147,25 +180,47 @@@ static inline struct port *__get_next_p
  static inline struct aggregator *__get_first_agg(struct port *port)
  {
  	struct bonding *bond = __get_bond_by_port(port);
 -	struct slave *first_slave;
  
 -	/* If there's no bond for this port, or bond has no slaves */
 -	if (bond == NULL)
 +	// If there's no bond for this port, or bond has no slaves
 +	if ((bond == NULL) || (bond->slave_cnt == 0))
 +		return NULL;
 +
++<<<<<<< HEAD
 +	return &(SLAVE_AD_INFO(bond->first_slave).aggregator);
 +}
 +
 +/**
 + * __get_next_agg - get the next aggregator in the bond
 + * @aggregator: the aggregator we're looking at
 + *
 + * Return the aggregator of the slave that is next in line of @aggregator's
 + * slave in the bond, or %NULL if it can't be found.
 + */
 +static inline struct aggregator *__get_next_agg(struct aggregator *aggregator)
 +{
 +	struct slave *slave = aggregator->slave;
 +	struct bonding *bond = bond_get_bond_by_slave(slave);
 +
 +	// If there's no bond for this aggregator, or this is the last slave
 +	if ((bond == NULL) || (slave->next == bond->first_slave))
  		return NULL;
  
 +	return &(SLAVE_AD_INFO(slave->next).aggregator);
++=======
+ 	rcu_read_lock();
+ 	first_slave = bond_first_slave_rcu(bond);
+ 	rcu_read_unlock();
+ 
+ 	return first_slave ? &(SLAVE_AD_INFO(first_slave).aggregator) : NULL;
++>>>>>>> 3bf2d28a2d71 (bonding: clean up style for bond_3ad.c)
  }
  
- /*
-  * __agg_has_partner
+ /**
+  * __agg_has_partner - see if we have a partner
+  * @agg: the agregator we're looking at
   *
   * Return nonzero if aggregator has a partner (denoted by a non-zero ether
-  * address for the partner).  Return 0 if not.
+  * address for the partner). Return 0 if not.
   */
  static inline int __agg_has_partner(struct aggregator *agg)
  {
@@@ -1595,7 -1608,9 +1657,13 @@@ static void ad_agg_selection_logic(stru
  			 best->partner_oper_aggregator_key,
  			 best->is_individual, best->is_active);
  
++<<<<<<< HEAD
 +		// disable the ports that were related to the former active_aggregator
++=======
+ 		/* disable the ports that were related to the former
+ 		 * active_aggregator
+ 		 */
++>>>>>>> 3bf2d28a2d71 (bonding: clean up style for bond_3ad.c)
  		if (active) {
  			for (port = active->lag_ports; port;
  			     port = port->next_port_in_aggregator) {
@@@ -2111,21 -2137,26 +2188,32 @@@ void bond_3ad_state_machine_handler(str
  {
  	struct bonding *bond = container_of(work, struct bonding,
  					    ad_work.work);
 -	struct aggregator *aggregator;
 -	struct list_head *iter;
 -	struct slave *slave;
  	struct port *port;
 +	struct aggregator *aggregator;
  
 -	read_lock(&bond->lock);
 -	rcu_read_lock();
 -
 -	/* check if there are any slaves */
 -	if (!bond_has_slaves(bond))
 +	if (!rtnl_trylock()) {
 +		queue_delayed_work(bond->wq, &bond->ad_work, ad_delta_in_ticks);
 +		return;
 +	}
 +	//check if there are any slaves
 +	if (bond->slave_cnt == 0)
  		goto re_arm;
  
++<<<<<<< HEAD
 +	// check if agg_select_timer timer after initialize is timed out
 +	if (BOND_AD_INFO(bond).agg_select_timer && !(--BOND_AD_INFO(bond).agg_select_timer)) {
 +		// select the active aggregator for the bond
 +		if ((port = __get_first_port(bond))) {
++=======
+ 	/* check if agg_select_timer timer after initialize is timed out */
+ 	if (BOND_AD_INFO(bond).agg_select_timer &&
+ 	    !(--BOND_AD_INFO(bond).agg_select_timer)) {
+ 		slave = bond_first_slave_rcu(bond);
+ 		port = slave ? &(SLAVE_AD_INFO(slave).port) : NULL;
+ 
+ 		/* select the active aggregator for the bond */
+ 		if (port) {
++>>>>>>> 3bf2d28a2d71 (bonding: clean up style for bond_3ad.c)
  			if (!port->slave) {
  				pr_warning("%s: Warning: bond's first port is uninitialized\n",
  					   bond->dev->name);
@@@ -2474,31 -2531,23 +2569,41 @@@ int bond_3ad_xmit_xor(struct sk_buff *s
  	if (slave_agg_no >= 0) {
  		pr_err("%s: Error: Couldn't find a slave to tx on for aggregator ID %d\n",
  		       dev->name, agg_id);
 -		goto err_free;
 +		goto out;
  	}
  
++<<<<<<< HEAD
 +	start_at = slave;
 +
 +	bond_for_each_slave_from(bond, slave, i, start_at) {
 +		int slave_agg_id = 0;
 +		struct aggregator *agg = SLAVE_AD_INFO(slave).port.aggregator;
 +
 +		if (agg)
 +			slave_agg_id = agg->aggregator_identifier;
 +
 +		if (SLAVE_IS_OK(slave) && agg && (slave_agg_id == agg_id)) {
 +			res = bond_dev_queue_xmit(bond, skb, slave->dev);
 +			break;
 +		}
 +	}
++=======
+ 	/* we couldn't find any suitable slave after the agg_no, so use the
+ 	 * first suitable found, if found.
+ 	 */
+ 	if (first_ok_slave)
+ 		bond_dev_queue_xmit(bond, skb, first_ok_slave->dev);
+ 	else
+ 		goto err_free;
++>>>>>>> 3bf2d28a2d71 (bonding: clean up style for bond_3ad.c)
  
  out:
 +	if (res) {
 +		/* no suitable interface, frame not sent */
 +		kfree_skb(skb);
 +	}
 +
  	return NETDEV_TX_OK;
 -err_free:
 -	/* no suitable interface, frame not sent */
 -	kfree_skb(skb);
 -	goto out;
  }
  
  int bond_3ad_lacpdu_recv(const struct sk_buff *skb, struct bonding *bond,
* Unmerged path drivers/net/bonding/bond_3ad.c
