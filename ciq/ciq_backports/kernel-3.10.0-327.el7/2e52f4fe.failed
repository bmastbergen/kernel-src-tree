bonding: rebuild the lock use for bond_loadbalance_arp_mon()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author dingtianhong <dingtianhong@huawei.com>
commit 2e52f4fe3655c7a2311070c6713f7feabc75486c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2e52f4fe.failed

The bond_loadbalance_arp_mon() use the bond lock to protect the
bond slave list, it is no effect, so I could use RTNL or RCU to
replace it, considering the performance impact, the RCU is more
better here, so the bond lock replace with the RCU.

The bond_select_active_slave() need RTNL and curr_slave_lock
together, but there is no RTNL lock here, so add a rtnl_rtylock.

	Suggested-by: Jay Vosburgh <fubar@us.ibm.com>
	Suggested-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2e52f4fe3655c7a2311070c6713f7feabc75486c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index b9b7314b42bb,1781ea620d76..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -2660,19 -2408,15 +2660,25 @@@ void bond_loadbalance_arp_mon(struct wo
  	struct bonding *bond = container_of(work, struct bonding,
  					    arp_work.work);
  	struct slave *slave, *oldcurrent;
 -	struct list_head *iter;
  	int do_failover = 0;
 +	int delta_in_ticks, extra_ticks;
 +	int i;
 +
++<<<<<<< HEAD
 +	read_lock(&bond->lock);
 +
 +	delta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);
 +	extra_ticks = delta_in_ticks / 2;
  
 +	if (bond->slave_cnt == 0)
++=======
+ 	if (!bond_has_slaves(bond))
++>>>>>>> 2e52f4fe3655 (bonding: rebuild the lock use for bond_loadbalance_arp_mon())
  		goto re_arm;
  
- 	oldcurrent = bond->curr_active_slave;
+ 	rcu_read_lock();
+ 
+ 	oldcurrent = ACCESS_ONCE(bond->curr_active_slave);
  	/* see if any of the previous devices are up now (i.e. they have
  	 * xmt and rcv traffic). the curr_active_slave does not come into
  	 * the picture unless it is null. also, slave->jiffies is not needed
@@@ -2681,7 -2425,7 +2687,11 @@@
  	 * TODO: what about up/down delay in arp mode? it wasn't here before
  	 *       so it can wait
  	 */
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
++>>>>>>> 2e52f4fe3655 (bonding: rebuild the lock use for bond_loadbalance_arp_mon())
  		unsigned long trans_start = dev_trans_start(slave->dev);
  
  		if (slave->link != BOND_LINK_UP) {
@@@ -2763,9 -2507,8 +2781,14 @@@
  
  re_arm:
  	if (bond->params.arp_interval)
++<<<<<<< HEAD
 +		queue_delayed_work(bond->wq, &bond->arp_work, delta_in_ticks);
 +
 +	read_unlock(&bond->lock);
++=======
+ 		queue_delayed_work(bond->wq, &bond->arp_work,
+ 				   msecs_to_jiffies(bond->params.arp_interval));
++>>>>>>> 2e52f4fe3655 (bonding: rebuild the lock use for bond_loadbalance_arp_mon())
  }
  
  /*
* Unmerged path drivers/net/bonding/bond_main.c
