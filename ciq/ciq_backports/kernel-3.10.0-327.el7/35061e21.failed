Fnic: Improper resue of exchange Ids

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hiral Shah <hishah@cisco.com>
commit 35061e21a1d29dc37ab28a50e82bfcf6de81b65d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/35061e21.failed

IOs belonging to an rport are aborted with Internal terminate option
when rport goes offline. Any new IO issued to the rport during this
time can reuse the terminated exchange which will cause inconsistent
state of the exchange between local port and remote port.

fc_rport_priv is set to RPORT_ST_DELETE before exchanges are aborted by
libfc. Not issuing amy more I/O requests when RPORT_ST_DELETE is set,
will avoid inconsistent state of the exchange between local port and
remote port.

- Increment fnic version from 1.6.0.13 to 1.6.0.14

	Signed-off-by: Hiral Shah <hishah@cisco.com>
	Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
	Signed-off-by: Anil Chintalapati <achintal@cisco.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 35061e21a1d29dc37ab28a50e82bfcf6de81b65d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fnic.h
diff --cc drivers/scsi/fnic/fnic.h
index a547c3fee2f5,5336e8d21704..000000000000
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@@ -39,7 -39,7 +39,11 @@@
  
  #define DRV_NAME		"fnic"
  #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
++<<<<<<< HEAD
 +#define DRV_VERSION		"1.5.0.45a"
++=======
+ #define DRV_VERSION		"1.6.0.14"
++>>>>>>> 35061e21a1d2 (Fnic: Improper resue of exchange Ids)
  #define PFX			DRV_NAME ": "
  #define DFX                     DRV_NAME "%d: "
  
* Unmerged path drivers/scsi/fnic/fnic.h
diff --git a/drivers/scsi/fnic/fnic_scsi.c b/drivers/scsi/fnic/fnic_scsi.c
index 0521436d05d6..f542d2a8714a 100644
--- a/drivers/scsi/fnic/fnic_scsi.c
+++ b/drivers/scsi/fnic/fnic_scsi.c
@@ -430,6 +430,7 @@ static int fnic_queuecommand_lck(struct scsi_cmnd *sc, void (*done)(struct scsi_
 	int sg_count = 0;
 	unsigned long flags;
 	unsigned long ptr;
+	struct fc_rport_priv *rdata;
 
 	if (unlikely(fnic_chk_state_flags_locked(fnic, FNIC_FLAGS_IO_BLOCKED)))
 		return SCSI_MLQUEUE_HOST_BUSY;
@@ -443,6 +444,16 @@ static int fnic_queuecommand_lck(struct scsi_cmnd *sc, void (*done)(struct scsi_
 		return 0;
 	}
 
+	rdata = lp->tt.rport_lookup(lp, rport->port_id);
+	if (!rdata || (rdata->rp_state == RPORT_ST_DELETE)) {
+		FNIC_SCSI_DBG(KERN_DEBUG, fnic->lport->host,
+			"returning IO as rport is removed\n");
+		atomic64_inc(&fnic_stats->misc_stats.rport_not_ready);
+		sc->result = DID_NO_CONNECT;
+		done(sc);
+		return 0;
+	}
+
 	if (lp->state != LPORT_ST_READY || !(lp->link_up))
 		return SCSI_MLQUEUE_HOST_BUSY;
 
