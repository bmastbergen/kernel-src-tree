tcp: make tcp_cwnd_application_limited() static

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Weiping Pan <wpan@redhat.com>
commit 86fd14ad1e8c4b8f5e9a7a27b26bdade91dd4bd0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/86fd14ad.failed

Make tcp_cwnd_application_limited() static and move it from tcp_input.c to
tcp_output.c

	Signed-off-by: Weiping Pan <wpan@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 86fd14ad1e8c4b8f5e9a7a27b26bdade91dd4bd0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tcp.h
diff --cc include/net/tcp.h
index ba45accd7103,163d2b467d78..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -533,40 -532,38 +533,46 @@@ static inline __u32 cookie_v6_init_sequ
  #endif
  /* tcp_output.c */
  
 -void __tcp_push_pending_frames(struct sock *sk, unsigned int cur_mss,
 -			       int nonagle);
 -bool tcp_may_send_now(struct sock *sk);
 -int __tcp_retransmit_skb(struct sock *, struct sk_buff *);
 -int tcp_retransmit_skb(struct sock *, struct sk_buff *);
 -void tcp_retransmit_timer(struct sock *sk);
 -void tcp_xmit_retransmit_queue(struct sock *);
 -void tcp_simple_retransmit(struct sock *);
 -int tcp_trim_head(struct sock *, struct sk_buff *, u32);
 -int tcp_fragment(struct sock *, struct sk_buff *, u32, unsigned int);
 -
 -void tcp_send_probe0(struct sock *);
 -void tcp_send_partial(struct sock *);
 -int tcp_write_wakeup(struct sock *);
 -void tcp_send_fin(struct sock *sk);
 -void tcp_send_active_reset(struct sock *sk, gfp_t priority);
 -int tcp_send_synack(struct sock *);
 -bool tcp_syn_flood_action(struct sock *sk, const struct sk_buff *skb,
 -			  const char *proto);
 -void tcp_push_one(struct sock *, unsigned int mss_now);
 -void tcp_send_ack(struct sock *sk);
 -void tcp_send_delayed_ack(struct sock *sk);
 -void tcp_send_loss_probe(struct sock *sk);
 -bool tcp_schedule_loss_probe(struct sock *sk);
 +extern void __tcp_push_pending_frames(struct sock *sk, unsigned int cur_mss,
 +				      int nonagle);
 +extern bool tcp_may_send_now(struct sock *sk);
 +extern int __tcp_retransmit_skb(struct sock *, struct sk_buff *);
 +extern int tcp_retransmit_skb(struct sock *, struct sk_buff *);
 +extern void tcp_retransmit_timer(struct sock *sk);
 +extern void tcp_xmit_retransmit_queue(struct sock *);
 +extern void tcp_simple_retransmit(struct sock *);
 +extern int tcp_trim_head(struct sock *, struct sk_buff *, u32);
 +extern int tcp_fragment(struct sock *, struct sk_buff *, u32, unsigned int);
 +
 +extern void tcp_send_probe0(struct sock *);
 +extern void tcp_send_partial(struct sock *);
 +extern int tcp_write_wakeup(struct sock *);
 +extern void tcp_send_fin(struct sock *sk);
 +extern void tcp_send_active_reset(struct sock *sk, gfp_t priority);
 +extern int tcp_send_synack(struct sock *);
 +extern bool tcp_syn_flood_action(struct sock *sk,
 +				 const struct sk_buff *skb,
 +				 const char *proto);
 +extern void tcp_push_one(struct sock *, unsigned int mss_now);
 +extern void tcp_send_ack(struct sock *sk);
 +extern void tcp_send_delayed_ack(struct sock *sk);
 +extern void tcp_send_loss_probe(struct sock *sk);
 +extern bool tcp_schedule_loss_probe(struct sock *sk);
  
  /* tcp_input.c */
++<<<<<<< HEAD
 +extern void tcp_cwnd_application_limited(struct sock *sk);
 +extern void tcp_resume_early_retransmit(struct sock *sk);
 +extern void tcp_rearm_rto(struct sock *sk);
 +extern void tcp_reset(struct sock *sk);
++=======
+ void tcp_resume_early_retransmit(struct sock *sk);
+ void tcp_rearm_rto(struct sock *sk);
+ void tcp_reset(struct sock *sk);
++>>>>>>> 86fd14ad1e8c (tcp: make tcp_cwnd_application_limited() static)
  
  /* tcp_timer.c */
 -void tcp_init_xmit_timers(struct sock *);
 +extern void tcp_init_xmit_timers(struct sock *);
  static inline void tcp_clear_xmit_timers(struct sock *sk)
  {
  	inet_csk_clear_xmit_timers(sk);
* Unmerged path include/net/tcp.h
diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 5c9d537a2d7a..f103240d4ddc 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -4689,28 +4689,6 @@ static int tcp_prune_queue(struct sock *sk)
 	return -1;
 }
 
-/* RFC2861, slow part. Adjust cwnd, after it was not full during one rto.
- * As additional protections, we do not touch cwnd in retransmission phases,
- * and if application hit its sndbuf limit recently.
- */
-void tcp_cwnd_application_limited(struct sock *sk)
-{
-	struct tcp_sock *tp = tcp_sk(sk);
-
-	if (inet_csk(sk)->icsk_ca_state == TCP_CA_Open &&
-	    sk->sk_socket && !test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {
-		/* Limited by application or receiver window. */
-		u32 init_win = tcp_init_cwnd(tp, __sk_dst_get(sk));
-		u32 win_used = max(tp->snd_cwnd_used, init_win);
-		if (win_used < tp->snd_cwnd) {
-			tp->snd_ssthresh = tcp_current_ssthresh(sk);
-			tp->snd_cwnd = (tp->snd_cwnd + win_used) >> 1;
-		}
-		tp->snd_cwnd_used = 0;
-	}
-	tp->snd_cwnd_stamp = tcp_time_stamp;
-}
-
 static bool tcp_should_expand_sndbuf(const struct sock *sk)
 {
 	const struct tcp_sock *tp = tcp_sk(sk);
diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index d61225e4f4f2..af921cb95dd2 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -1389,6 +1389,28 @@ unsigned int tcp_current_mss(struct sock *sk)
 	return mss_now;
 }
 
+/* RFC2861, slow part. Adjust cwnd, after it was not full during one rto.
+ * As additional protections, we do not touch cwnd in retransmission phases,
+ * and if application hit its sndbuf limit recently.
+ */
+static void tcp_cwnd_application_limited(struct sock *sk)
+{
+	struct tcp_sock *tp = tcp_sk(sk);
+
+	if (inet_csk(sk)->icsk_ca_state == TCP_CA_Open &&
+	    sk->sk_socket && !test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {
+		/* Limited by application or receiver window. */
+		u32 init_win = tcp_init_cwnd(tp, __sk_dst_get(sk));
+		u32 win_used = max(tp->snd_cwnd_used, init_win);
+		if (win_used < tp->snd_cwnd) {
+			tp->snd_ssthresh = tcp_current_ssthresh(sk);
+			tp->snd_cwnd = (tp->snd_cwnd + win_used) >> 1;
+		}
+		tp->snd_cwnd_used = 0;
+	}
+	tp->snd_cwnd_stamp = tcp_time_stamp;
+}
+
 /* Congestion window validation. (RFC2861) */
 static void tcp_cwnd_validate(struct sock *sk)
 {
