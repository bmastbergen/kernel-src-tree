net/mlx4_core: Manage interface state for Reset flow cases

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4_core: Manage interface state for Reset flow cases (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 96.43%
commit-author Yishai Hadas <yishaih@mellanox.com>
commit c69453e294c9f16da977b68e658a8028b854c209
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c69453e2.failed

We need to manage interface state to sync between reset flow and some other
relative cases such as remove_one. This has to be done to prevent certain
races. For example in case software stack is down as a result of unload call,
the remove_one should skip the unload phase.

Implement the remove_one case, handling AER and other cases comes next.

The interface can be up/down, upon remove_one, the state will include an extra
bit indicating that the device is cleaned-up, forcing other tasks to finish
before the final cleanup.

	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c69453e294c9f16da977b68e658a8028b854c209)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/catas.c
#	drivers/net/ethernet/mellanox/mlx4/main.c
#	include/linux/mlx4/device.h
diff --cc drivers/net/ethernet/mellanox/mlx4/catas.c
index 9c656fe4983d,3fcf3cfaedfc..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/catas.c
+++ b/drivers/net/ethernet/mellanox/mlx4/catas.c
@@@ -51,6 -48,90 +51,93 @@@ MODULE_PARM_DESC(internal_err_reset
  		 "Reset device on internal errors if non-zero"
  		 " (default 1, in SRIOV mode default is 0)");
  
++<<<<<<< HEAD
++=======
+ static int read_vendor_id(struct mlx4_dev *dev)
+ {
+ 	u16 vendor_id = 0;
+ 	int ret;
+ 
+ 	ret = pci_read_config_word(dev->persist->pdev, 0, &vendor_id);
+ 	if (ret) {
+ 		mlx4_err(dev, "Failed to read vendor ID, ret=%d\n", ret);
+ 		return ret;
+ 	}
+ 
+ 	if (vendor_id == 0xffff) {
+ 		mlx4_err(dev, "PCI can't be accessed to read vendor id\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx4_reset_master(struct mlx4_dev *dev)
+ {
+ 	int err = 0;
+ 
+ 	if (!pci_channel_offline(dev->persist->pdev)) {
+ 		err = read_vendor_id(dev);
+ 		/* If PCI can't be accessed to read vendor ID we assume that its
+ 		 * link was disabled and chip was already reset.
+ 		 */
+ 		if (err)
+ 			return 0;
+ 
+ 		err = mlx4_reset(dev);
+ 		if (err)
+ 			mlx4_err(dev, "Fail to reset HCA\n");
+ 	}
+ 
+ 	return err;
+ }
+ 
+ void mlx4_enter_error_state(struct mlx4_dev_persistent *persist)
+ {
+ 	int err;
+ 	struct mlx4_dev *dev;
+ 
+ 	if (!mlx4_internal_err_reset)
+ 		return;
+ 
+ 	mutex_lock(&persist->device_state_mutex);
+ 	if (persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR)
+ 		goto out;
+ 
+ 	dev = persist->dev;
+ 	mlx4_err(dev, "device is going to be reset\n");
+ 	err = mlx4_reset_master(dev);
+ 	BUG_ON(err != 0);
+ 
+ 	dev->persist->state |= MLX4_DEVICE_STATE_INTERNAL_ERROR;
+ 	mlx4_err(dev, "device was reset successfully\n");
+ 	mutex_unlock(&persist->device_state_mutex);
+ 
+ 	/* At that step HW was already reset, now notify clients */
+ 	mlx4_dispatch_event(dev, MLX4_DEV_EVENT_CATASTROPHIC_ERROR, 0);
+ 	mlx4_cmd_wake_completions(dev);
+ 	return;
+ 
+ out:
+ 	mutex_unlock(&persist->device_state_mutex);
+ }
+ 
+ static void mlx4_handle_error_state(struct mlx4_dev_persistent *persist)
+ {
+ 	int err = 0;
+ 
+ 	mlx4_enter_error_state(persist);
+ 	mutex_lock(&persist->interface_state_mutex);
+ 	if (persist->interface_state & MLX4_INTERFACE_STATE_UP &&
+ 	    !(persist->interface_state & MLX4_INTERFACE_STATE_DELETION)) {
+ 		err = mlx4_restart_one(persist->pdev);
+ 		mlx4_info(persist->dev, "mlx4_restart_one was ended, ret=%d\n",
+ 			  err);
+ 	}
+ 	mutex_unlock(&persist->interface_state_mutex);
+ }
+ 
++>>>>>>> c69453e294c9 (net/mlx4_core: Manage interface state for Reset flow cases)
  static void dump_err_buf(struct mlx4_dev *dev)
  {
  	struct mlx4_priv *priv = mlx4_priv(dev);
@@@ -157,15 -213,29 +244,23 @@@ void mlx4_stop_catas_poll(struct mlx4_d
  
  	del_timer_sync(&priv->catas_err.timer);
  
 -	if (priv->catas_err.map) {
 +	if (priv->catas_err.map)
  		iounmap(priv->catas_err.map);
++<<<<<<< HEAD
 +
 +	spin_lock_irq(&catas_lock);
 +	list_del(&priv->catas_err.list);
 +	spin_unlock_irq(&catas_lock);
++=======
+ 		priv->catas_err.map = NULL;
+ 	}
+ 
+ 	if (dev->persist->interface_state & MLX4_INTERFACE_STATE_DELETION)
+ 		flush_workqueue(dev->persist->catas_wq);
++>>>>>>> c69453e294c9 (net/mlx4_core: Manage interface state for Reset flow cases)
  }
  
 -int  mlx4_catas_init(struct mlx4_dev *dev)
 -{
 -	INIT_WORK(&dev->persist->catas_work, catas_reset);
 -	dev->persist->catas_wq = create_singlethread_workqueue("mlx4_health");
 -	if (!dev->persist->catas_wq)
 -		return -ENOMEM;
 -
 -	return 0;
 -}
 -
 -void mlx4_catas_end(struct mlx4_dev *dev)
 +void  __init mlx4_catas_init(void)
  {
 -	if (dev->persist->catas_wq) {
 -		destroy_workqueue(dev->persist->catas_wq);
 -		dev->persist->catas_wq = NULL;
 -	}
 +	INIT_WORK(&catas_work, catas_reset);
  }
diff --cc drivers/net/ethernet/mellanox/mlx4/main.c
index e21046536e8b,d59cae5da3f0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/main.c
@@@ -2832,15 -3104,33 +2832,20 @@@ static int mlx4_init_one(struct pci_de
  		return -ENOMEM;
  
  	dev       = &priv->dev;
 -	dev->persist = kzalloc(sizeof(*dev->persist), GFP_KERNEL);
 -	if (!dev->persist) {
 -		kfree(priv);
 -		return -ENOMEM;
 -	}
 -	dev->persist->pdev = pdev;
 -	dev->persist->dev = dev;
 -	pci_set_drvdata(pdev, dev->persist);
 +	dev->pdev = pdev;
 +	pci_set_drvdata(pdev, dev);
  	priv->pci_dev_data = id->driver_data;
++<<<<<<< HEAD
++=======
+ 	mutex_init(&dev->persist->device_state_mutex);
+ 	mutex_init(&dev->persist->interface_state_mutex);
++>>>>>>> c69453e294c9 (net/mlx4_core: Manage interface state for Reset flow cases)
  
  	ret =  __mlx4_init_one(pdev, id->driver_data, priv);
 -	if (ret) {
 -		kfree(dev->persist);
 +	if (ret)
  		kfree(priv);
 -	}
 -	return ret;
 -}
  
 -static void mlx4_clean_dev(struct mlx4_dev *dev)
 -{
 -	struct mlx4_dev_persistent *persist = dev->persist;
 -	struct mlx4_priv *priv = mlx4_priv(dev);
 -
 -	memset(priv, 0, sizeof(*priv));
 -	priv->dev.persist = persist;
 +	return ret;
  }
  
  static void mlx4_unload_one(struct pci_dev *pdev)
@@@ -2931,12 -3229,25 +2936,27 @@@
  
  static void mlx4_remove_one(struct pci_dev *pdev)
  {
 -	struct mlx4_dev_persistent *persist = pci_get_drvdata(pdev);
 -	struct mlx4_dev  *dev  = persist->dev;
 +	struct mlx4_dev  *dev  = pci_get_drvdata(pdev);
  	struct mlx4_priv *priv = mlx4_priv(dev);
  
++<<<<<<< HEAD
 +	mlx4_unload_one(pdev);
++=======
+ 	mutex_lock(&persist->interface_state_mutex);
+ 	persist->interface_state |= MLX4_INTERFACE_STATE_DELETION;
+ 	mutex_unlock(&persist->interface_state_mutex);
+ 
+ 	/* device marked to be under deletion running now without the lock
+ 	 * letting other tasks to be terminated
+ 	 */
+ 	if (persist->interface_state & MLX4_INTERFACE_STATE_UP)
+ 		mlx4_unload_one(pdev);
+ 	else
+ 		mlx4_info(dev, "%s: interface is down\n", __func__);
+ 	mlx4_catas_end(dev);
++>>>>>>> c69453e294c9 (net/mlx4_core: Manage interface state for Reset flow cases)
  	pci_release_regions(pdev);
  	pci_disable_device(pdev);
 -	kfree(dev->persist);
  	kfree(priv);
  	pci_set_drvdata(pdev, NULL);
  }
diff --cc include/linux/mlx4/device.h
index 04d2bbb20a34,33f9ca71925c..000000000000
--- a/include/linux/mlx4/device.h
+++ b/include/linux/mlx4/device.h
@@@ -399,6 -411,16 +399,19 @@@ enum 
  	MLX4_EQ_PORT_INFO_MSTR_SM_SL_CHANGE_MASK	= 1 << 4,
  };
  
++<<<<<<< HEAD
++=======
+ enum {
+ 	MLX4_DEVICE_STATE_UP			= 1 << 0,
+ 	MLX4_DEVICE_STATE_INTERNAL_ERROR	= 1 << 1,
+ };
+ 
+ enum {
+ 	MLX4_INTERFACE_STATE_UP		= 1 << 0,
+ 	MLX4_INTERFACE_STATE_DELETION	= 1 << 1,
+ };
+ 
++>>>>>>> c69453e294c9 (net/mlx4_core: Manage interface state for Reset flow cases)
  #define MSTR_SM_CHANGE_MASK (MLX4_EQ_PORT_INFO_MSTR_SM_SL_CHANGE_MASK | \
  			     MLX4_EQ_PORT_INFO_MSTR_SM_LID_CHANGE_MASK)
  
@@@ -728,8 -754,23 +741,26 @@@ struct mlx4_vf_dev 
  	u8			n_ports;
  };
  
++<<<<<<< HEAD
++=======
+ struct mlx4_dev_persistent {
+ 	struct pci_dev	       *pdev;
+ 	struct mlx4_dev	       *dev;
+ 	int                     nvfs[MLX4_MAX_PORTS + 1];
+ 	int			num_vfs;
+ 	enum mlx4_port_type curr_port_type[MLX4_MAX_PORTS + 1];
+ 	enum mlx4_port_type curr_port_poss_type[MLX4_MAX_PORTS + 1];
+ 	struct work_struct      catas_work;
+ 	struct workqueue_struct *catas_wq;
+ 	struct mutex	device_state_mutex; /* protect HW state */
+ 	u8		state;
+ 	struct mutex	interface_state_mutex; /* protect SW state */
+ 	u8	interface_state;
+ };
+ 
++>>>>>>> c69453e294c9 (net/mlx4_core: Manage interface state for Reset flow cases)
  struct mlx4_dev {
 -	struct mlx4_dev_persistent *persist;
 +	struct pci_dev	       *pdev;
  	unsigned long		flags;
  	unsigned long		num_slaves;
  	struct mlx4_caps	caps;
* Unmerged path drivers/net/ethernet/mellanox/mlx4/catas.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/intf.c b/drivers/net/ethernet/mellanox/mlx4/intf.c
index 116895ac8b35..fba0b96a6f28 100644
--- a/drivers/net/ethernet/mellanox/mlx4/intf.c
+++ b/drivers/net/ethernet/mellanox/mlx4/intf.c
@@ -138,6 +138,7 @@ int mlx4_register_device(struct mlx4_dev *dev)
 
 	mutex_lock(&intf_mutex);
 
+	dev->persist->interface_state |= MLX4_INTERFACE_STATE_UP;
 	list_add_tail(&priv->dev_list, &dev_list);
 	list_for_each_entry(intf, &intf_list, list)
 		mlx4_add_device(intf, priv);
@@ -162,6 +163,7 @@ void mlx4_unregister_device(struct mlx4_dev *dev)
 		mlx4_remove_device(intf, priv);
 
 	list_del(&priv->dev_list);
+	dev->persist->interface_state &= ~MLX4_INTERFACE_STATE_UP;
 
 	mutex_unlock(&intf_mutex);
 }
* Unmerged path drivers/net/ethernet/mellanox/mlx4/main.c
* Unmerged path include/linux/mlx4/device.h
