sfc: manually allocate and free vadaptors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Shradha Shah <sshah@solarflare.com>
commit 7b8c7b54f0070edb207add4777e68e4e79d7c3fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7b8c7b54.failed

To be able to use MC_CMD_VADAPTOR_SET_MAC, vadaptors must be
manually allocated and freed as automatic vadaptors will disappear
when their reference_count reaches zero, which must happen before
the MAC address is changed.

Vadaptors are allocated and freed in the vswitching_probe/remove
functions for PFs and VFs, and this means that vadaptors are restored
correctly following an MC reboot or other reset when required.

	Signed-off-by: Shradha Shah <sshah@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7b8c7b54f0070edb207add4777e68e4e79d7c3fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/ef10.c
#	drivers/net/ethernet/sfc/ef10_sriov.c
#	drivers/net/ethernet/sfc/ef10_sriov.h
diff --cc drivers/net/ethernet/sfc/ef10.c
index 61edbf385044,0dff8123da04..000000000000
--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@@ -3621,9 -3684,107 +3621,109 @@@ static int efx_ef10_ptp_set_ts_config(s
  	}
  }
  
++<<<<<<< HEAD
++=======
+ const struct efx_nic_type efx_hunt_a0_vf_nic_type = {
+ 	.mem_bar = EFX_MEM_VF_BAR,
+ 	.mem_map_size = efx_ef10_mem_map_size,
+ 	.probe = efx_ef10_probe_vf,
+ 	.remove = efx_ef10_remove,
+ 	.dimension_resources = efx_ef10_dimension_resources,
+ 	.init = efx_ef10_init_nic,
+ 	.fini = efx_port_dummy_op_void,
+ 	.map_reset_reason = efx_mcdi_map_reset_reason,
+ 	.map_reset_flags = efx_ef10_map_reset_flags,
+ 	.reset = efx_ef10_reset,
+ 	.probe_port = efx_mcdi_port_probe,
+ 	.remove_port = efx_mcdi_port_remove,
+ 	.fini_dmaq = efx_ef10_fini_dmaq,
+ 	.prepare_flr = efx_ef10_prepare_flr,
+ 	.finish_flr = efx_port_dummy_op_void,
+ 	.describe_stats = efx_ef10_describe_stats,
+ 	.update_stats = efx_ef10_update_stats,
+ 	.start_stats = efx_port_dummy_op_void,
+ 	.pull_stats = efx_port_dummy_op_void,
+ 	.stop_stats = efx_port_dummy_op_void,
+ 	.set_id_led = efx_mcdi_set_id_led,
+ 	.push_irq_moderation = efx_ef10_push_irq_moderation,
+ 	.reconfigure_mac = efx_ef10_mac_reconfigure,
+ 	.check_mac_fault = efx_mcdi_mac_check_fault,
+ 	.reconfigure_port = efx_mcdi_port_reconfigure,
+ 	.get_wol = efx_ef10_get_wol_vf,
+ 	.set_wol = efx_ef10_set_wol_vf,
+ 	.resume_wol = efx_port_dummy_op_void,
+ 	.mcdi_request = efx_ef10_mcdi_request,
+ 	.mcdi_poll_response = efx_ef10_mcdi_poll_response,
+ 	.mcdi_read_response = efx_ef10_mcdi_read_response,
+ 	.mcdi_poll_reboot = efx_ef10_mcdi_poll_reboot,
+ 	.irq_enable_master = efx_port_dummy_op_void,
+ 	.irq_test_generate = efx_ef10_irq_test_generate,
+ 	.irq_disable_non_ev = efx_port_dummy_op_void,
+ 	.irq_handle_msi = efx_ef10_msi_interrupt,
+ 	.irq_handle_legacy = efx_ef10_legacy_interrupt,
+ 	.tx_probe = efx_ef10_tx_probe,
+ 	.tx_init = efx_ef10_tx_init,
+ 	.tx_remove = efx_ef10_tx_remove,
+ 	.tx_write = efx_ef10_tx_write,
+ 	.rx_push_rss_config = efx_ef10_rx_push_rss_config,
+ 	.rx_probe = efx_ef10_rx_probe,
+ 	.rx_init = efx_ef10_rx_init,
+ 	.rx_remove = efx_ef10_rx_remove,
+ 	.rx_write = efx_ef10_rx_write,
+ 	.rx_defer_refill = efx_ef10_rx_defer_refill,
+ 	.ev_probe = efx_ef10_ev_probe,
+ 	.ev_init = efx_ef10_ev_init,
+ 	.ev_fini = efx_ef10_ev_fini,
+ 	.ev_remove = efx_ef10_ev_remove,
+ 	.ev_process = efx_ef10_ev_process,
+ 	.ev_read_ack = efx_ef10_ev_read_ack,
+ 	.ev_test_generate = efx_ef10_ev_test_generate,
+ 	.filter_table_probe = efx_ef10_filter_table_probe,
+ 	.filter_table_restore = efx_ef10_filter_table_restore,
+ 	.filter_table_remove = efx_ef10_filter_table_remove,
+ 	.filter_update_rx_scatter = efx_ef10_filter_update_rx_scatter,
+ 	.filter_insert = efx_ef10_filter_insert,
+ 	.filter_remove_safe = efx_ef10_filter_remove_safe,
+ 	.filter_get_safe = efx_ef10_filter_get_safe,
+ 	.filter_clear_rx = efx_ef10_filter_clear_rx,
+ 	.filter_count_rx_used = efx_ef10_filter_count_rx_used,
+ 	.filter_get_rx_id_limit = efx_ef10_filter_get_rx_id_limit,
+ 	.filter_get_rx_ids = efx_ef10_filter_get_rx_ids,
+ #ifdef CONFIG_RFS_ACCEL
+ 	.filter_rfs_insert = efx_ef10_filter_rfs_insert,
+ 	.filter_rfs_expire_one = efx_ef10_filter_rfs_expire_one,
+ #endif
+ #ifdef CONFIG_SFC_MTD
+ 	.mtd_probe = efx_port_dummy_op_int,
+ #endif
+ 	.ptp_write_host_time = efx_ef10_ptp_write_host_time_vf,
+ 	.ptp_set_ts_config = efx_ef10_ptp_set_ts_config_vf,
+ #ifdef CONFIG_SFC_SRIOV
+ 	.vswitching_probe = efx_ef10_vswitching_probe_vf,
+ 	.vswitching_restore = efx_ef10_vswitching_restore_vf,
+ 	.vswitching_remove = efx_ef10_vswitching_remove_vf,
+ #endif
+ 	.revision = EFX_REV_HUNT_A0,
+ 	.max_dma_mask = DMA_BIT_MASK(ESF_DZ_TX_KER_BUF_ADDR_WIDTH),
+ 	.rx_prefix_size = ES_DZ_RX_PREFIX_SIZE,
+ 	.rx_hash_offset = ES_DZ_RX_PREFIX_HASH_OFST,
+ 	.rx_ts_offset = ES_DZ_RX_PREFIX_TSTAMP_OFST,
+ 	.can_rx_scatter = true,
+ 	.always_rx_scatter = true,
+ 	.max_interrupt_mode = EFX_INT_MODE_MSIX,
+ 	.timer_period_max = 1 << ERF_DD_EVQ_IND_TIMER_VAL_WIDTH,
+ 	.offload_features = (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+ 			     NETIF_F_RXHASH | NETIF_F_NTUPLE),
+ 	.mcdi_max_ver = 2,
+ 	.max_rx_ip_filters = HUNT_FILTER_TBL_ROWS,
+ 	.hwtstamp_filters = 1 << HWTSTAMP_FILTER_NONE |
+ 			    1 << HWTSTAMP_FILTER_ALL,
+ };
+ 
++>>>>>>> 7b8c7b54f007 (sfc: manually allocate and free vadaptors)
  const struct efx_nic_type efx_hunt_a0_nic_type = {
 -	.mem_bar = EFX_MEM_BAR,
  	.mem_map_size = efx_ef10_mem_map_size,
 -	.probe = efx_ef10_probe_pf,
 +	.probe = efx_ef10_probe,
  	.remove = efx_ef10_remove,
  	.dimension_resources = efx_ef10_dimension_resources,
  	.init = efx_ef10_init_nic,
@@@ -3714,6 -3876,10 +3814,13 @@@
  	.sriov_set_vf_vlan = efx_ef10_sriov_set_vf_vlan,
  	.sriov_set_vf_spoofchk = efx_ef10_sriov_set_vf_spoofchk,
  	.sriov_get_vf_config = efx_ef10_sriov_get_vf_config,
++<<<<<<< HEAD
++=======
+ 	.vswitching_probe = efx_ef10_vswitching_probe_pf,
+ 	.vswitching_restore = efx_ef10_vswitching_restore_pf,
+ 	.vswitching_remove = efx_ef10_vswitching_remove_pf,
+ #endif
++>>>>>>> 7b8c7b54f007 (sfc: manually allocate and free vadaptors)
  
  	.revision = EFX_REV_HUNT_A0,
  	.max_dma_mask = DMA_BIT_MASK(ESF_DZ_TX_KER_BUF_ADDR_WIDTH),
diff --cc drivers/net/ethernet/sfc/ef10_sriov.c
index 9e6a3e197e01,1b93acf2d28d..000000000000
--- a/drivers/net/ethernet/sfc/ef10_sriov.c
+++ b/drivers/net/ethernet/sfc/ef10_sriov.c
@@@ -13,7 -14,357 +13,361 @@@
  #include "nic.h"
  #include "mcdi_pcol.h"
  
++<<<<<<< HEAD
 +#ifdef CONFIG_SFC_SRIOV
++=======
+ static int efx_ef10_evb_port_assign(struct efx_nic *efx, unsigned int port_id,
+ 				    unsigned int vf_fn)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_EVB_PORT_ASSIGN_IN_LEN);
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	MCDI_SET_DWORD(inbuf, EVB_PORT_ASSIGN_IN_PORT_ID, port_id);
+ 	MCDI_POPULATE_DWORD_2(inbuf, EVB_PORT_ASSIGN_IN_FUNCTION,
+ 			      EVB_PORT_ASSIGN_IN_PF, nic_data->pf_index,
+ 			      EVB_PORT_ASSIGN_IN_VF, vf_fn);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_EVB_PORT_ASSIGN, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vport_add_mac(struct efx_nic *efx,
+ 				  unsigned int port_id, u8 *mac)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_ADD_MAC_ADDRESS_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_ADD_MAC_ADDRESS_IN_VPORT_ID, port_id);
+ 	ether_addr_copy(MCDI_PTR(inbuf, VPORT_ADD_MAC_ADDRESS_IN_MACADDR), mac);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VPORT_ADD_MAC_ADDRESS, inbuf,
+ 			    sizeof(inbuf), NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vport_del_mac(struct efx_nic *efx,
+ 				  unsigned int port_id, u8 *mac)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_DEL_MAC_ADDRESS_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_DEL_MAC_ADDRESS_IN_VPORT_ID, port_id);
+ 	ether_addr_copy(MCDI_PTR(inbuf, VPORT_DEL_MAC_ADDRESS_IN_MACADDR), mac);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VPORT_DEL_MAC_ADDRESS, inbuf,
+ 			    sizeof(inbuf), NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vswitch_alloc(struct efx_nic *efx, unsigned int port_id,
+ 				  unsigned int vswitch_type)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VSWITCH_ALLOC_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_UPSTREAM_PORT_ID, port_id);
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_TYPE, vswitch_type);
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_NUM_VLAN_TAGS, 0);
+ 	MCDI_POPULATE_DWORD_1(inbuf, VSWITCH_ALLOC_IN_FLAGS,
+ 			      VSWITCH_ALLOC_IN_FLAG_AUTO_PORT, 0);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VSWITCH_ALLOC, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vswitch_free(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VSWITCH_FREE_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_FREE_IN_UPSTREAM_PORT_ID, port_id);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VSWITCH_FREE, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vport_alloc(struct efx_nic *efx,
+ 				unsigned int port_id_in,
+ 				unsigned int vport_type,
+ 				unsigned int *port_id_out)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_ALLOC_IN_LEN);
+ 	MCDI_DECLARE_BUF(outbuf, MC_CMD_VPORT_ALLOC_OUT_LEN);
+ 	size_t outlen;
+ 	int rc;
+ 
+ 	EFX_WARN_ON_PARANOID(!port_id_out);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_UPSTREAM_PORT_ID, port_id_in);
+ 	MCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_TYPE, vport_type);
+ 	MCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_NUM_VLAN_TAGS, 0);
+ 	MCDI_POPULATE_DWORD_1(inbuf, VPORT_ALLOC_IN_FLAGS,
+ 			      VPORT_ALLOC_IN_FLAG_AUTO_PORT, 0);
+ 
+ 	rc = efx_mcdi_rpc(efx, MC_CMD_VPORT_ALLOC, inbuf, sizeof(inbuf),
+ 			  outbuf, sizeof(outbuf), &outlen);
+ 	if (rc)
+ 		return rc;
+ 	if (outlen < MC_CMD_VPORT_ALLOC_OUT_LEN)
+ 		return -EIO;
+ 
+ 	*port_id_out = MCDI_DWORD(outbuf, VPORT_ALLOC_OUT_VPORT_ID);
+ 	return 0;
+ }
+ 
+ static int efx_ef10_vport_free(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_FREE_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_FREE_IN_VPORT_ID, port_id);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VPORT_FREE, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vadaptor_alloc(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VADAPTOR_ALLOC_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VADAPTOR_ALLOC_IN_UPSTREAM_PORT_ID, port_id);
+ 	return efx_mcdi_rpc(efx, MC_CMD_VADAPTOR_ALLOC, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vadaptor_free(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VADAPTOR_FREE_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VADAPTOR_FREE_IN_UPSTREAM_PORT_ID, port_id);
+ 	return efx_mcdi_rpc(efx, MC_CMD_VADAPTOR_FREE, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static void efx_ef10_sriov_free_vf_vports(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	int i;
+ 
+ 	if (!nic_data->vf)
+ 		return;
+ 
+ 	for (i = 0; i < efx->vf_count; i++) {
+ 		struct ef10_vf *vf = nic_data->vf + i;
+ 
+ 		if (vf->vport_assigned) {
+ 			efx_ef10_evb_port_assign(efx, EVB_PORT_ID_NULL, i);
+ 			vf->vport_assigned = 0;
+ 		}
+ 
+ 		if (!is_zero_ether_addr(vf->mac)) {
+ 			efx_ef10_vport_del_mac(efx, vf->vport_id, vf->mac);
+ 			eth_zero_addr(vf->mac);
+ 		}
+ 
+ 		if (vf->vport_id) {
+ 			efx_ef10_vport_free(efx, vf->vport_id);
+ 			vf->vport_id = 0;
+ 		}
+ 	}
+ }
+ 
+ static void efx_ef10_sriov_free_vf_vswitching(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	efx_ef10_sriov_free_vf_vports(efx);
+ 	kfree(nic_data->vf);
+ 	nic_data->vf = NULL;
+ }
+ 
+ static int efx_ef10_sriov_assign_vf_vport(struct efx_nic *efx,
+ 					  unsigned int vf_i)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	struct ef10_vf *vf = nic_data->vf + vf_i;
+ 	int rc;
+ 
+ 	if (WARN_ON_ONCE(!nic_data->vf))
+ 		return -EOPNOTSUPP;
+ 
+ 	rc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,
+ 				  MC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,
+ 				  &vf->vport_id);
+ 	if (rc)
+ 		return rc;
+ 
+ 	rc = efx_ef10_vport_add_mac(efx, vf->vport_id, vf->mac);
+ 	if (rc) {
+ 		eth_zero_addr(vf->mac);
+ 		return rc;
+ 	}
+ 
+ 	rc =  efx_ef10_evb_port_assign(efx, vf->vport_id, vf_i);
+ 	if (rc)
+ 		return rc;
+ 
+ 	vf->vport_assigned = 1;
+ 	return 0;
+ }
+ 
+ static int efx_ef10_sriov_alloc_vf_vswitching(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	unsigned int i;
+ 	int rc;
+ 
+ 	nic_data->vf = kcalloc(efx->vf_count, sizeof(struct ef10_vf),
+ 			       GFP_KERNEL);
+ 	if (!nic_data->vf)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < efx->vf_count; i++) {
+ 		random_ether_addr(nic_data->vf[i].mac);
+ 
+ 		rc = efx_ef10_sriov_assign_vf_vport(efx, i);
+ 		if (rc)
+ 			goto fail;
+ 	}
+ 
+ 	return 0;
+ fail:
+ 	efx_ef10_sriov_free_vf_vports(efx);
+ 	kfree(nic_data->vf);
+ 	nic_data->vf = NULL;
+ 	return rc;
+ }
+ 
+ static int efx_ef10_sriov_restore_vf_vswitching(struct efx_nic *efx)
+ {
+ 	unsigned int i;
+ 	int rc;
+ 
+ 	for (i = 0; i < efx->vf_count; i++) {
+ 		rc = efx_ef10_sriov_assign_vf_vport(efx, i);
+ 		if (rc)
+ 			goto fail;
+ 	}
+ 
+ 	return 0;
+ fail:
+ 	efx_ef10_sriov_free_vf_vswitching(efx);
+ 	return rc;
+ }
+ 
+ /* On top of the default firmware vswitch setup, create a VEB vswitch and
+  * expansion vport for use by this function.
+  */
+ int efx_ef10_vswitching_probe_pf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	struct net_device *net_dev = efx->net_dev;
+ 	int rc;
+ 
+ 	if (pci_sriov_get_totalvfs(efx->pci_dev) <= 0) {
+ 		/* vswitch not needed as we have no VFs */
+ 		efx_ef10_vadaptor_alloc(efx, nic_data->vport_id);
+ 		return 0;
+ 	}
+ 
+ 	rc = efx_ef10_vswitch_alloc(efx, EVB_PORT_ID_ASSIGNED,
+ 				    MC_CMD_VSWITCH_ALLOC_IN_VSWITCH_TYPE_VEB);
+ 	if (rc)
+ 		goto fail1;
+ 
+ 	rc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,
+ 				  MC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,
+ 				  &nic_data->vport_id);
+ 	if (rc)
+ 		goto fail2;
+ 
+ 	rc = efx_ef10_vport_add_mac(efx, nic_data->vport_id, net_dev->dev_addr);
+ 	if (rc)
+ 		goto fail3;
+ 	ether_addr_copy(nic_data->vport_mac, net_dev->dev_addr);
+ 
+ 	rc = efx_ef10_vadaptor_alloc(efx, nic_data->vport_id);
+ 	if (rc)
+ 		goto fail4;
+ 
+ 	return 0;
+ fail4:
+ 	efx_ef10_vport_del_mac(efx, nic_data->vport_id, nic_data->vport_mac);
+ 	eth_zero_addr(nic_data->vport_mac);
+ fail3:
+ 	efx_ef10_vport_free(efx, nic_data->vport_id);
+ 	nic_data->vport_id = EVB_PORT_ID_ASSIGNED;
+ fail2:
+ 	efx_ef10_vswitch_free(efx, EVB_PORT_ID_ASSIGNED);
+ fail1:
+ 	return rc;
+ }
+ 
+ int efx_ef10_vswitching_probe_vf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	return efx_ef10_vadaptor_alloc(efx, nic_data->vport_id);
+ }
+ 
+ int efx_ef10_vswitching_restore_pf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	int rc;
+ 
+ 	if (!nic_data->must_probe_vswitching)
+ 		return 0;
+ 
+ 	rc = efx_ef10_vswitching_probe_pf(efx);
+ 	if (rc)
+ 		goto fail;
+ 
+ 	rc = efx_ef10_sriov_restore_vf_vswitching(efx);
+ 	if (rc)
+ 		goto fail;
+ 
+ 	nic_data->must_probe_vswitching = false;
+ fail:
+ 	return rc;
+ }
+ 
+ int efx_ef10_vswitching_restore_vf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	int rc;
+ 
+ 	if (!nic_data->must_probe_vswitching)
+ 		return 0;
+ 
+ 	rc = efx_ef10_vadaptor_free(efx, EVB_PORT_ID_ASSIGNED);
+ 	if (rc)
+ 		return rc;
+ 
+ 	nic_data->must_probe_vswitching = false;
+ 	return 0;
+ }
+ 
+ void efx_ef10_vswitching_remove_pf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	efx_ef10_sriov_free_vf_vswitching(efx);
+ 
+ 	efx_ef10_vadaptor_free(efx, nic_data->vport_id);
+ 
+ 	if (nic_data->vport_id == EVB_PORT_ID_ASSIGNED)
+ 		return; /* No vswitch was ever created */
+ 
+ 	if (!is_zero_ether_addr(nic_data->vport_mac)) {
+ 		efx_ef10_vport_del_mac(efx, nic_data->vport_id,
+ 				       efx->net_dev->dev_addr);
+ 		eth_zero_addr(nic_data->vport_mac);
+ 	}
+ 	efx_ef10_vport_free(efx, nic_data->vport_id);
+ 	nic_data->vport_id = EVB_PORT_ID_ASSIGNED;
+ 
+ 	efx_ef10_vswitch_free(efx, nic_data->vport_id);
+ }
+ 
+ void efx_ef10_vswitching_remove_vf(struct efx_nic *efx)
+ {
+ 	efx_ef10_vadaptor_free(efx, EVB_PORT_ID_ASSIGNED);
+ }
+ 
++>>>>>>> 7b8c7b54f007 (sfc: manually allocate and free vadaptors)
  static int efx_ef10_pci_sriov_enable(struct efx_nic *efx, int num_vfs)
  {
  	int rc = 0;
diff --cc drivers/net/ethernet/sfc/ef10_sriov.h
index 6ea115e3c3f2,86bac7ebb01a..000000000000
--- a/drivers/net/ethernet/sfc/ef10_sriov.h
+++ b/drivers/net/ethernet/sfc/ef10_sriov.h
@@@ -53,6 -59,12 +53,16 @@@ static inline int efx_ef10_sriov_get_vf
  {
  	return -EOPNOTSUPP;
  }
++<<<<<<< HEAD
 +#endif /* CONFIG_SFC_SRIOV */
++=======
+ 
+ int efx_ef10_vswitching_probe_pf(struct efx_nic *efx);
+ int efx_ef10_vswitching_probe_vf(struct efx_nic *efx);
+ int efx_ef10_vswitching_restore_pf(struct efx_nic *efx);
+ int efx_ef10_vswitching_restore_vf(struct efx_nic *efx);
+ void efx_ef10_vswitching_remove_pf(struct efx_nic *efx);
+ void efx_ef10_vswitching_remove_vf(struct efx_nic *efx);
++>>>>>>> 7b8c7b54f007 (sfc: manually allocate and free vadaptors)
  
  #endif /* EF10_SRIOV_H */
* Unmerged path drivers/net/ethernet/sfc/ef10.c
* Unmerged path drivers/net/ethernet/sfc/ef10_sriov.c
* Unmerged path drivers/net/ethernet/sfc/ef10_sriov.h
