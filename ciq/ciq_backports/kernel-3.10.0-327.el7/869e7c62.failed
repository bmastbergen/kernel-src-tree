net: af_unix: implement stream sendpage support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] af_unix: implement stream sendpage support (Hannes Frederic Sowa) [1226230]
Rebuild_FUZZ: 94.38%
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit 869e7c62486ec0e170a9771acaa251d1a33b5871
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/869e7c62.failed

This patch implements sendpage support for AF_UNIX SOCK_STREAM
sockets. This is also required for a complete splice implementation.

The implementation is a bit tricky because we append to already existing
skbs and so have to hold unix_sk->readlock to protect the reading side
from either advancing UNIXCB.consumed or freeing the skb at the socket
receive tail.

	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 869e7c62486ec0e170a9771acaa251d1a33b5871)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/unix/af_unix.c
diff --cc net/unix/af_unix.c
index 1c6b80b0a837,7762c0b46721..000000000000
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@@ -514,20 -516,17 +514,29 @@@ static unsigned int unix_dgram_poll(str
  				    poll_table *);
  static int unix_ioctl(struct socket *, unsigned int, unsigned long);
  static int unix_shutdown(struct socket *, int);
++<<<<<<< HEAD
 +static int unix_stream_sendmsg(struct kiocb *, struct socket *,
 +			       struct msghdr *, size_t);
 +static int unix_stream_recvmsg(struct kiocb *, struct socket *,
 +			       struct msghdr *, size_t, int);
 +static int unix_dgram_sendmsg(struct kiocb *, struct socket *,
 +			      struct msghdr *, size_t);
 +static int unix_dgram_recvmsg(struct kiocb *, struct socket *,
 +			      struct msghdr *, size_t, int);
++=======
+ static int unix_stream_sendmsg(struct socket *, struct msghdr *, size_t);
+ static int unix_stream_recvmsg(struct socket *, struct msghdr *, size_t, int);
+ static ssize_t unix_stream_sendpage(struct socket *, struct page *, int offset,
+ 				    size_t size, int flags);
+ static int unix_dgram_sendmsg(struct socket *, struct msghdr *, size_t);
+ static int unix_dgram_recvmsg(struct socket *, struct msghdr *, size_t, int);
++>>>>>>> 869e7c62486e (net: af_unix: implement stream sendpage support)
  static int unix_dgram_connect(struct socket *, struct sockaddr *,
  			      int, int);
 -static int unix_seqpacket_sendmsg(struct socket *, struct msghdr *, size_t);
 -static int unix_seqpacket_recvmsg(struct socket *, struct msghdr *, size_t,
 -				  int);
 +static int unix_seqpacket_sendmsg(struct kiocb *, struct socket *,
 +				  struct msghdr *, size_t);
 +static int unix_seqpacket_recvmsg(struct kiocb *, struct socket *,
 +				  struct msghdr *, size_t, int);
  
  static int unix_set_peek_off(struct sock *sk, int val)
  {
@@@ -1732,8 -1722,103 +1741,108 @@@ out_err
  	return sent ? : err;
  }
  
++<<<<<<< HEAD
 +static int unix_seqpacket_sendmsg(struct kiocb *kiocb, struct socket *sock,
 +				  struct msghdr *msg, size_t len)
++=======
+ static ssize_t unix_stream_sendpage(struct socket *socket, struct page *page,
+ 				    int offset, size_t size, int flags)
+ {
+ 	int err = 0;
+ 	bool send_sigpipe = true;
+ 	struct sock *other, *sk = socket->sk;
+ 	struct sk_buff *skb, *newskb = NULL, *tail = NULL;
+ 
+ 	if (flags & MSG_OOB)
+ 		return -EOPNOTSUPP;
+ 
+ 	other = unix_peer(sk);
+ 	if (!other || sk->sk_state != TCP_ESTABLISHED)
+ 		return -ENOTCONN;
+ 
+ 	if (false) {
+ alloc_skb:
+ 		unix_state_unlock(other);
+ 		mutex_unlock(&unix_sk(other)->readlock);
+ 		newskb = sock_alloc_send_pskb(sk, 0, 0, flags & MSG_DONTWAIT,
+ 					      &err, 0);
+ 		if (!newskb)
+ 			return err;
+ 	}
+ 
+ 	/* we must acquire readlock as we modify already present
+ 	 * skbs in the sk_receive_queue and mess with skb->len
+ 	 */
+ 	err = mutex_lock_interruptible(&unix_sk(other)->readlock);
+ 	if (err) {
+ 		err = flags & MSG_DONTWAIT ? -EAGAIN : -ERESTARTSYS;
+ 		send_sigpipe = false;
+ 		goto err;
+ 	}
+ 
+ 	if (sk->sk_shutdown & SEND_SHUTDOWN) {
+ 		err = -EPIPE;
+ 		goto err_unlock;
+ 	}
+ 
+ 	unix_state_lock(other);
+ 
+ 	if (sock_flag(other, SOCK_DEAD) ||
+ 	    other->sk_shutdown & RCV_SHUTDOWN) {
+ 		err = -EPIPE;
+ 		goto err_state_unlock;
+ 	}
+ 
+ 	skb = skb_peek_tail(&other->sk_receive_queue);
+ 	if (tail && tail == skb) {
+ 		skb = newskb;
+ 	} else if (!skb) {
+ 		if (newskb)
+ 			skb = newskb;
+ 		else
+ 			goto alloc_skb;
+ 	} else if (newskb) {
+ 		/* this is fast path, we don't necessarily need to
+ 		 * call to kfree_skb even though with newskb == NULL
+ 		 * this - does no harm
+ 		 */
+ 		consume_skb(newskb);
+ 	}
+ 
+ 	if (skb_append_pagefrags(skb, page, offset, size)) {
+ 		tail = skb;
+ 		goto alloc_skb;
+ 	}
+ 
+ 	skb->len += size;
+ 	skb->data_len += size;
+ 	skb->truesize += size;
+ 	atomic_add(size, &sk->sk_wmem_alloc);
+ 
+ 	if (newskb)
+ 		__skb_queue_tail(&other->sk_receive_queue, newskb);
+ 
+ 	unix_state_unlock(other);
+ 	mutex_unlock(&unix_sk(other)->readlock);
+ 
+ 	other->sk_data_ready(other);
+ 
+ 	return size;
+ 
+ err_state_unlock:
+ 	unix_state_unlock(other);
+ err_unlock:
+ 	mutex_unlock(&unix_sk(other)->readlock);
+ err:
+ 	kfree_skb(newskb);
+ 	if (send_sigpipe && !(flags & MSG_NOSIGNAL))
+ 		send_sig(SIGPIPE, current, 0);
+ 	return err;
+ }
+ 
+ static int unix_seqpacket_sendmsg(struct socket *sock, struct msghdr *msg,
+ 				  size_t len)
++>>>>>>> 869e7c62486e (net: af_unix: implement stream sendpage support)
  {
  	int err;
  	struct sock *sk = sock->sk;
* Unmerged path net/unix/af_unix.c
