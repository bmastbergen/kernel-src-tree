vxlan: Move socket initialization to within rtnl scope

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
commit 56ef9c909b40483d2c8cb63fcbf83865f162d5ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/56ef9c90.failed

Currently, if a multicast join operation fail, the vxlan interface will
be UP but not functional, without even a log message informing the user.

Now that we can grab socket lock after already having rntl, we don't
need to defer socket creation and multicast operations. By not deferring
we can do proper error reporting to the user through ip exit code.

This patch thus removes all deferred work that vxlan had and put it back
inline. Now the socket will only be created, bound and join multicast
group when one bring the interface up, and will undo all that as soon as
one put the interface down.

As vxlan_sock_hold() is not used after this patch, it was removed too.

	Signed-off-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 56ef9c909b40483d2c8cb63fcbf83865f162d5ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index f6bd9cff732e,5f749a51f356..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1032,13 -1084,11 +1021,12 @@@ void vxlan_sock_release(struct vxlan_so
  }
  EXPORT_SYMBOL_GPL(vxlan_sock_release);
  
- /* Callback to update multicast group membership when first VNI on
+ /* Update multicast group membership when first VNI on
   * multicast asddress is brought up
 + * Done as workqueue because ip_mc_join_group acquires RTNL.
   */
- static void vxlan_igmp_join(struct work_struct *work)
+ static int vxlan_igmp_join(struct vxlan_dev *vxlan)
  {
- 	struct vxlan_dev *vxlan = container_of(work, struct vxlan_dev, igmp_join);
  	struct vxlan_sock *vs = vxlan->vn_sock;
  	struct sock *sk = vs->sock->sk;
  	union vxlan_addr *ip = &vxlan->default_dst.remote_ip;
@@@ -1080,20 -1130,41 +1068,18 @@@ static int vxlan_igmp_leave(struct vxla
  			.imr_ifindex		= ifindex,
  		};
  
- 		ip_mc_leave_group(sk, &mreq);
+ 		ret = ip_mc_leave_group(sk, &mreq);
  #if IS_ENABLED(CONFIG_IPV6)
  	} else {
- 		ipv6_stub->ipv6_sock_mc_drop(sk, ifindex,
- 					     &ip->sin6.sin6_addr);
+ 		ret = ipv6_stub->ipv6_sock_mc_drop(sk, ifindex,
+ 						   &ip->sin6.sin6_addr);
  #endif
  	}
- 
  	release_sock(sk);
  
- 	vxlan_sock_release(vs);
- 	dev_put(vxlan->dev);
+ 	return ret;
  }
  
 -static struct vxlanhdr *vxlan_remcsum(struct sk_buff *skb, struct vxlanhdr *vh,
 -				      size_t hdrlen, u32 data, bool nopartial)
 -{
 -	size_t start, offset, plen;
 -
 -	start = (data & VXLAN_RCO_MASK) << VXLAN_RCO_SHIFT;
 -	offset = start + ((data & VXLAN_RCO_UDP) ?
 -			  offsetof(struct udphdr, check) :
 -			  offsetof(struct tcphdr, check));
 -
 -	plen = hdrlen + offset + sizeof(u16);
 -
 -	if (!pskb_may_pull(skb, plen))
 -		return NULL;
 -
 -	vh = (struct vxlanhdr *)(udp_hdr(skb) + 1);
 -
 -	skb_remcsum_process(skb, (void *)vh + hdrlen, start, offset,
 -			    nopartial);
 -
 -	return vh;
 -}
 -
  /* Callback from net/ipv4/udp.c to receive packets */
  static int vxlan_udp_encap_recv(struct sock *sk, struct sk_buff *skb)
  {
@@@ -1987,28 -2172,10 +1976,35 @@@ static void vxlan_vs_add_dev(struct vxl
  /* Setup stats when device is created */
  static int vxlan_init(struct net_device *dev)
  {
++<<<<<<< HEAD
 +	struct vxlan_dev *vxlan = netdev_priv(dev);
 +	struct vxlan_net *vn = net_generic(dev_net(dev), vxlan_net_id);
 +	struct vxlan_sock *vs;
 +	bool ipv6 = vxlan->flags & VXLAN_F_IPV6;
 +
 +	dev->tstats = alloc_percpu(struct pcpu_tstats);
 +	if (!dev->tstats)
 +		return -ENOMEM;
 +
 +	spin_lock(&vn->sock_lock);
 +	vs = vxlan_find_sock(dev_net(dev), ipv6 ? AF_INET6 : AF_INET,
 +			     vxlan->dst_port);
 +	if (vs && atomic_add_unless(&vs->refcnt, 1, 0)) {
 +		/* If we have a socket with same port already, reuse it */
 +		vxlan_vs_add_dev(vs, vxlan);
 +	} else {
 +		/* otherwise make new socket outside of RTNL */
 +		dev_hold(dev);
 +		queue_work(vxlan_wq, &vxlan->sock_work);
 +	}
 +	spin_unlock(&vn->sock_lock);
 +
++=======
+ 	dev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);
+ 	if (!dev->tstats)
+ 		return -ENOMEM;
+ 
++>>>>>>> 56ef9c909b40 (vxlan: Move socket initialization to within rtnl scope)
  	return 0;
  }
  
@@@ -2079,9 -2249,10 +2078,10 @@@ static void vxlan_flush(struct vxlan_de
  /* Cleanup timer and forwarding table on shutdown */
  static int vxlan_stop(struct net_device *dev)
  {
 +	struct vxlan_net *vn = net_generic(dev_net(dev), vxlan_net_id);
  	struct vxlan_dev *vxlan = netdev_priv(dev);
 -	struct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);
  	struct vxlan_sock *vs = vxlan->vn_sock;
+ 	int ret = 0;
  
  	if (vs && vxlan_addr_multicast(&vxlan->default_dst.remote_ip) &&
  	    !vxlan_group_used(vn, vxlan)) {
@@@ -2404,49 -2564,27 +2404,66 @@@ struct vxlan_sock *vxlan_sock_add(struc
  	struct vxlan_sock *vs;
  	bool ipv6 = flags & VXLAN_F_IPV6;
  
- 	vs = vxlan_socket_create(net, port, rcv, data, flags);
- 	if (!IS_ERR(vs))
- 		return vs;
+ 	if (!no_share) {
+ 		spin_lock(&vn->sock_lock);
+ 		vs = vxlan_find_sock(net, ipv6 ? AF_INET6 : AF_INET, port,
+ 				     flags);
+ 		if (vs && vs->rcv == rcv) {
+ 			if (!atomic_add_unless(&vs->refcnt, 1, 0))
+ 				vs = ERR_PTR(-EBUSY);
+ 			spin_unlock(&vn->sock_lock);
+ 			return vs;
+ 		}
+ 		spin_unlock(&vn->sock_lock);
+ 	}
  
++<<<<<<< HEAD
 +	if (no_share)	/* Return error if sharing is not allowed. */
 +		return vs;
 +
 +	spin_lock(&vn->sock_lock);
 +	vs = vxlan_find_sock(net, ipv6 ? AF_INET6 : AF_INET, port);
 +	if (vs && ((vs->rcv != rcv) ||
 +		   !atomic_add_unless(&vs->refcnt, 1, 0)))
 +			vs = ERR_PTR(-EBUSY);
 +	spin_unlock(&vn->sock_lock);
 +
 +	if (!vs)
 +		vs = ERR_PTR(-EINVAL);
 +
 +	return vs;
 +}
 +EXPORT_SYMBOL_GPL(vxlan_sock_add);
 +
 +/* Scheduled at device creation to bind to a socket */
 +static void vxlan_sock_work(struct work_struct *work)
 +{
 +	struct vxlan_dev *vxlan = container_of(work, struct vxlan_dev, sock_work);
 +	struct net *net = dev_net(vxlan->dev);
 +	struct vxlan_net *vn = net_generic(net, vxlan_net_id);
 +	__be16 port = vxlan->dst_port;
 +	struct vxlan_sock *nvs;
 +
 +	nvs = vxlan_sock_add(net, port, vxlan_rcv, NULL, false, vxlan->flags);
 +	spin_lock(&vn->sock_lock);
 +	if (!IS_ERR(nvs))
 +		vxlan_vs_add_dev(nvs, vxlan);
 +	spin_unlock(&vn->sock_lock);
 +
 +	dev_put(vxlan->dev);
 +}
 +
 +static int vxlan_newlink(struct net *net, struct net_device *dev,
++=======
+ 	return vxlan_socket_create(net, port, rcv, data, flags);
+ }
+ EXPORT_SYMBOL_GPL(vxlan_sock_add);
+ 
+ static int vxlan_newlink(struct net *src_net, struct net_device *dev,
++>>>>>>> 56ef9c909b40 (vxlan: Move socket initialization to within rtnl scope)
  			 struct nlattr *tb[], struct nlattr *data[])
  {
 -	struct vxlan_net *vn = net_generic(src_net, vxlan_net_id);
 +	struct vxlan_net *vn = net_generic(net, vxlan_net_id);
  	struct vxlan_dev *vxlan = netdev_priv(dev);
  	struct vxlan_rdst *dst = &vxlan->default_dst;
  	__u32 vni;
* Unmerged path drivers/net/vxlan.c
