NVMe: make setup work for devices that don't do INTx

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jens Axboe <axboe@fb.com>
commit e32efbfc35c1b06f1bfe3e6d737acdd14d27baed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e32efbfc.failed

The setup/probe part currently relies on INTx being there and
working, that's not always the case. For devices that don't
advertise INTx, enable a single MSIx vector early on and disable
it again before we ask for our full range of queue vecs.

	Acked-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit e32efbfc35c1b06f1bfe3e6d737acdd14d27baed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index dfa7c848f446,9310fe51382e..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -2355,31 -1998,23 +2355,42 @@@ static int nvme_setup_io_queues(struct 
  	/* Deregister the admin queue's interrupt */
  	free_irq(dev->entry[0].vector, adminq);
  
++<<<<<<< HEAD
 +	vecs = nr_io_queues;
 +	for (i = 0; i < vecs; i++)
++=======
+ 	/*
+ 	 * If we enable msix early due to not intx, disable it again before
+ 	 * setting up the full range we need.
+ 	 */
+ 	if (!pdev->irq)
+ 		pci_disable_msix(pdev);
+ 
+ 	for (i = 0; i < nr_io_queues; i++)
++>>>>>>> e32efbfc35c1 (NVMe: make setup work for devices that don't do INTx)
  		dev->entry[i].entry = i;
 -	vecs = pci_enable_msix_range(pdev, dev->entry, 1, nr_io_queues);
 -	if (vecs < 0) {
 -		vecs = pci_enable_msi_range(pdev, 1, min(nr_io_queues, 32));
 -		if (vecs < 0) {
 -			vecs = 1;
 -		} else {
 -			for (i = 0; i < vecs; i++)
 -				dev->entry[i].vector = i + pdev->irq;
 +	for (;;) {
 +		result = pci_enable_msix(pdev, dev->entry, vecs);
 +		if (result <= 0)
 +			break;
 +		vecs = result;
 +	}
 +
 +	if (result < 0) {
 +		vecs = nr_io_queues;
 +		if (vecs > 32)
 +			vecs = 32;
 +		for (;;) {
 +			result = pci_enable_msi_block(pdev, vecs);
 +			if (result == 0) {
 +				for (i = 0; i < vecs; i++)
 +					dev->entry[i].vector = i + pdev->irq;
 +				break;
 +			} else if (result < 0) {
 +				vecs = 1;
 +				break;
 +			}
 +			vecs = result;
  		}
  	}
  
* Unmerged path drivers/block/nvme-core.c
