netem: Fixes byte backlog accounting for the first of two chained netem instances

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Beshay, Joseph <jdb109120@utdallas.edu>
commit 0ad2a8365975d6794d79a4e4dde60fcc036692c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0ad2a836.failed

Fixes byte backlog accounting for the first of two chained netem instances.
Bytes backlog reported now corresponds to the number of queued packets.

When two netem instances are chained, for instance to apply rate and queue
limitation followed by packet delay, the number of backlogged bytes reported
by the first netem instance is wrong. It reports the sum of bytes in the queues
of the first and second netem. The first netem reports the correct number of
backlogged packets but not bytes. This is shown in the example below.

Consider a chain of two netem schedulers created using the following commands:

$ tc -s qdisc replace dev veth2 root handle 1:0 netem rate 10000kbit limit 100
$ tc -s qdisc add dev veth2 parent 1:0 handle 2: netem delay 50ms

Start an iperf session to send packets out on the specified interface and
monitor the backlog using tc:

$ tc -s qdisc show dev veth2

Output using unpatched netem:
	qdisc netem 1: root refcnt 2 limit 100 rate 10000Kbit
	 Sent 98422639 bytes 65434 pkt (dropped 123, overlimits 0 requeues 0)
	 backlog 172694b 73p requeues 0
	qdisc netem 2: parent 1: limit 1000 delay 50.0ms
	 Sent 98422639 bytes 65434 pkt (dropped 0, overlimits 0 requeues 0)
	 backlog 63588b 42p requeues 0

The interface used to produce this output has an MTU of 1500. The output for
backlogged bytes behind netem 1 is 172694b. This value is not correct. Consider
the total number of sent bytes and packets. By dividing the number of sent
bytes by the number of sent packets, we get an average packet size of ~=1504.
If we divide the number of backlogged bytes by packets, we get ~=2365. This is
due to the first netem incorrectly counting the 63588b which are in netem 2's
queue as being in its own queue. To verify this is the case, we subtract them
from the reported value and divide by the number of packets as follows:
	172694 - 63588 = 109106 bytes actualled backlogged in netem 1
	109106 / 73 packets ~= 1494 bytes (which matches our MTU)

The root cause is that the byte accounting is not done at the
same time with packet accounting. The solution is to update the backlog value
every time the packet queue is updated.

	Signed-off-by: Joseph D Beshay <joseph.beshay@utdallas.edu>
	Acked-by: Hagen Paul Pfeifer <hagen@jauu.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0ad2a8365975d6794d79a4e4dde60fcc036692c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_netem.c
diff --cc net/sched/sch_netem.c
index 43ba8fdeeffc,956ead2cab9a..000000000000
--- a/net/sched/sch_netem.c
+++ b/net/sched/sch_netem.c
@@@ -547,8 -560,8 +547,13 @@@ static struct sk_buff *netem_dequeue(st
  tfifo_dequeue:
  	skb = __skb_dequeue(&sch->q);
  	if (skb) {
++<<<<<<< HEAD
 +deliver:
 +		sch->qstats.backlog -= qdisc_pkt_len(skb);
++=======
+ 		qdisc_qstats_backlog_dec(sch, skb);
+ deliver:
++>>>>>>> 0ad2a8365975 (netem: Fixes byte backlog accounting for the first of two chained netem instances)
  		qdisc_unthrottled(sch);
  		qdisc_bstats_update(sch, skb);
  		return skb;
* Unmerged path net/sched/sch_netem.c
