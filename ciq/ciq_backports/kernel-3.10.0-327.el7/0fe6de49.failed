bridge: fix uninitialized variable warning

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Roopa Prabhu <roopa@cumulusnetworks.com>
commit 0fe6de490320bfbf1b82a33d7ee49b62af5f29db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0fe6de49.failed

net/bridge/br_netlink.c: In function ‘br_fill_ifinfo’:
net/bridge/br_netlink.c:146:32: warning: ‘vid_range_flags’ may be used uninitialized in this function [-Wmaybe-uninitialized]
  err = br_fill_ifvlaninfo_range(skb, vid_range_start,
                                ^
net/bridge/br_netlink.c:108:6: note: ‘vid_range_flags’ was declared here
  u16 vid_range_flags;

	Reported-by: Thomas Graf <tgraf@suug.ch>
	Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0fe6de490320bfbf1b82a33d7ee49b62af5f29db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_netlink.c
diff --cc net/bridge/br_netlink.c
index 12e6d5e60e99,66ece91ee165..000000000000
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@@ -66,6 -67,120 +66,123 @@@ static int br_port_fill_attrs(struct sk
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int br_fill_ifvlaninfo_range(struct sk_buff *skb, u16 vid_start,
+ 				    u16 vid_end, u16 flags)
+ {
+ 	struct  bridge_vlan_info vinfo;
+ 
+ 	if ((vid_end - vid_start) > 0) {
+ 		/* add range to skb */
+ 		vinfo.vid = vid_start;
+ 		vinfo.flags = flags | BRIDGE_VLAN_INFO_RANGE_BEGIN;
+ 		if (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,
+ 			    sizeof(vinfo), &vinfo))
+ 			goto nla_put_failure;
+ 
+ 		vinfo.flags &= ~BRIDGE_VLAN_INFO_RANGE_BEGIN;
+ 
+ 		vinfo.vid = vid_end;
+ 		vinfo.flags = flags | BRIDGE_VLAN_INFO_RANGE_END;
+ 		if (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,
+ 			    sizeof(vinfo), &vinfo))
+ 			goto nla_put_failure;
+ 	} else {
+ 		vinfo.vid = vid_start;
+ 		vinfo.flags = flags;
+ 		if (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,
+ 			    sizeof(vinfo), &vinfo))
+ 			goto nla_put_failure;
+ 	}
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ 	return -EMSGSIZE;
+ }
+ 
+ static int br_fill_ifvlaninfo_compressed(struct sk_buff *skb,
+ 					 const struct net_port_vlans *pv)
+ {
+ 	u16 vid_range_start = 0, vid_range_end = 0;
+ 	u16 vid_range_flags = 0;
+ 	u16 pvid, vid, flags;
+ 	int err = 0;
+ 
+ 	/* Pack IFLA_BRIDGE_VLAN_INFO's for every vlan
+ 	 * and mark vlan info with begin and end flags
+ 	 * if vlaninfo represents a range
+ 	 */
+ 	pvid = br_get_pvid(pv);
+ 	for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {
+ 		flags = 0;
+ 		if (vid == pvid)
+ 			flags |= BRIDGE_VLAN_INFO_PVID;
+ 
+ 		if (test_bit(vid, pv->untagged_bitmap))
+ 			flags |= BRIDGE_VLAN_INFO_UNTAGGED;
+ 
+ 		if (vid_range_start == 0) {
+ 			goto initvars;
+ 		} else if ((vid - vid_range_end) == 1 &&
+ 			flags == vid_range_flags) {
+ 			vid_range_end = vid;
+ 			continue;
+ 		} else {
+ 			err = br_fill_ifvlaninfo_range(skb, vid_range_start,
+ 						       vid_range_end,
+ 						       vid_range_flags);
+ 			if (err)
+ 				return err;
+ 		}
+ 
+ initvars:
+ 		vid_range_start = vid;
+ 		vid_range_end = vid;
+ 		vid_range_flags = flags;
+ 	}
+ 
+ 	if (vid_range_start != 0) {
+ 		/* Call it once more to send any left over vlans */
+ 		err = br_fill_ifvlaninfo_range(skb, vid_range_start,
+ 					       vid_range_end,
+ 					       vid_range_flags);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int br_fill_ifvlaninfo(struct sk_buff *skb,
+ 			      const struct net_port_vlans *pv)
+ {
+ 	struct bridge_vlan_info vinfo;
+ 	u16 pvid, vid;
+ 
+ 	pvid = br_get_pvid(pv);
+ 	for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {
+ 		vinfo.vid = vid;
+ 		vinfo.flags = 0;
+ 		if (vid == pvid)
+ 			vinfo.flags |= BRIDGE_VLAN_INFO_PVID;
+ 
+ 		if (test_bit(vid, pv->untagged_bitmap))
+ 			vinfo.flags |= BRIDGE_VLAN_INFO_UNTAGGED;
+ 
+ 		if (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,
+ 			    sizeof(vinfo), &vinfo))
+ 			goto nla_put_failure;
+ 	}
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ 	return -EMSGSIZE;
+ }
+ 
++>>>>>>> 0fe6de490320 (bridge: fix uninitialized variable warning)
  /*
   * Create one netlink message for one interface
   * Contains port and master info as well as carrier and bridge state.
* Unmerged path net/bridge/br_netlink.c
