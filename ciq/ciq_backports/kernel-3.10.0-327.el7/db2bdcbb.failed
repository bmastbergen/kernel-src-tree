KVM: x86: fix edge EOI and IOAPIC reconfig race

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [x86] kvm: fix edge EOI and IOAPIC reconfig race (Radim Krcmar) [1271333]
Rebuild_FUZZ: 94.38%
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit db2bdcbbbd32e5500b822d5e74ef8b5bd777e687
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/db2bdcbb.failed

KVM uses eoi_exit_bitmap to track vectors that need an action on EOI.
The problem is that IOAPIC can be reconfigured while an interrupt with
old configuration is pending and eoi_exit_bitmap only remembers the
newest configuration;  thus EOI from the pending interrupt is not
recognized.

(Reconfiguration is not a problem for level interrupts, because IOAPIC
 sends interrupt with the new configuration.)

For an edge interrupt with ACK notifiers, like i8254 timer; things can
happen in this order
 1) IOAPIC inject a vector from i8254
 2) guest reconfigures that vector's VCPU and therefore eoi_exit_bitmap
    on original VCPU gets cleared
 3) guest's handler for the vector does EOI
 4) KVM's EOI handler doesn't pass that vector to IOAPIC because it is
    not in that VCPU's eoi_exit_bitmap
 5) i8254 stops working

A simple solution is to set the IOAPIC vector in eoi_exit_bitmap if the
vector is in PIR/IRR/ISR.

This creates an unwanted situation if the vector is reused by a
non-IOAPIC source, but I think it is so rare that we don't want to make
the solution more sophisticated.  The simple solution also doesn't work
if we are reconfiguring the vector.  (Shouldn't happen in the wild and
I'd rather fix users of ACK notifiers instead of working around that.)

The are no races because ioapic injection and reconfig are locked.

Fixes: b053b2aef25d ("KVM: x86: Add EOI exit bitmap inference")
[Before b053b2aef25d, this bug happened only with APICv.]
Fixes: c7c9c56ca26f ("x86, apicv: add virtual interrupt delivery support")
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit db2bdcbbbd32e5500b822d5e74ef8b5bd777e687)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/ioapic.c
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/ioapic.c
index 04d60f12efe3,88d0a92d3f94..000000000000
--- a/arch/x86/kvm/ioapic.c
+++ b/arch/x86/kvm/ioapic.c
@@@ -260,13 -246,11 +260,19 @@@ void kvm_ioapic_scan_entry(struct kvm_v
  		    kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||
  		    index == RTC_GSI) {
  			if (kvm_apic_match_dest(vcpu, NULL, 0,
++<<<<<<< HEAD
 +				e->fields.dest_id, e->fields.dest_mode)) {
++=======
+ 			             e->fields.dest_id, e->fields.dest_mode) ||
+ 			    (e->fields.trig_mode == IOAPIC_EDGE_TRIG &&
+ 			     kvm_apic_pending_eoi(vcpu, e->fields.vector)))
++>>>>>>> db2bdcbbbd32 (KVM: x86: fix edge EOI and IOAPIC reconfig race)
  				__set_bit(e->fields.vector,
  					(unsigned long *)eoi_exit_bitmap);
 +				if (e->fields.trig_mode == IOAPIC_LEVEL_TRIG)
 +					__set_bit(e->fields.vector,
 +						(unsigned long *)tmr);
 +			}
  		}
  	}
  	spin_unlock(&ioapic->lock);
diff --cc arch/x86/kvm/x86.c
index d09ae6bde6e7,e33aebbf189e..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -6086,12 -6197,21 +6086,28 @@@ static void vcpu_scan_ioapic(struct kvm
  	if (!kvm_apic_hw_enabled(vcpu->arch.apic))
  		return;
  
 -	memset(vcpu->arch.eoi_exit_bitmap, 0, 256 / 8);
 +	memset(eoi_exit_bitmap, 0, 32);
 +	memset(tmr, 0, 32);
  
++<<<<<<< HEAD
 +	kvm_ioapic_scan_entry(vcpu, eoi_exit_bitmap, tmr);
 +	kvm_x86_ops->load_eoi_exitmap(vcpu, eoi_exit_bitmap);
 +	kvm_apic_update_tmr(vcpu, tmr);
++=======
+ 	if (irqchip_split(vcpu->kvm))
+ 		kvm_scan_ioapic_routes(vcpu, vcpu->arch.eoi_exit_bitmap);
+ 	else {
+ 		kvm_x86_ops->sync_pir_to_irr(vcpu);
+ 		kvm_ioapic_scan_entry(vcpu, vcpu->arch.eoi_exit_bitmap);
+ 	}
+ 	kvm_x86_ops->load_eoi_exitmap(vcpu);
+ }
+ 
+ static void kvm_vcpu_flush_tlb(struct kvm_vcpu *vcpu)
+ {
+ 	++vcpu->stat.tlb_flush;
+ 	kvm_x86_ops->tlb_flush(vcpu);
++>>>>>>> db2bdcbbbd32 (KVM: x86: fix edge EOI and IOAPIC reconfig race)
  }
  
  void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/ioapic.c
* Unmerged path arch/x86/kvm/x86.c
