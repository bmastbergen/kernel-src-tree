xfs: factor extsize hint checking out of xfs_ioctl_setattr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit d4388d3c0988ec00787ad1f8e63b5e2a6abef1dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d4388d3c.failed

The extent size hint change checking is fairly complex, so isolate
that into it's own function. This simplifies the logic flow of the
setattr code, making it easier to read.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit d4388d3c0988ec00787ad1f8e63b5e2a6abef1dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_ioctl.c
diff --cc fs/xfs/xfs_ioctl.c
index c6e180d60c21,9f808539fc61..000000000000
--- a/fs/xfs/xfs_ioctl.c
+++ b/fs/xfs/xfs_ioctl.c
@@@ -1045,10 -1013,136 +1045,55 @@@ xfs_diflags_to_linux
  		inode->i_flags &= ~S_NOATIME;
  }
  
 -static int
 -xfs_ioctl_setattr_xflags(
 -	struct xfs_trans	*tp,
 -	struct xfs_inode	*ip,
 -	struct fsxattr		*fa)
 -{
 -	struct xfs_mount	*mp = ip->i_mount;
 -
 -	/* Can't change realtime flag if any extents are allocated. */
 -	if ((ip->i_d.di_nextents || ip->i_delayed_blks) &&
 -	    XFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & XFS_XFLAG_REALTIME))
 -		return -EINVAL;
 -
 -	/* If realtime flag is set then must have realtime device */
 -	if (fa->fsx_xflags & XFS_XFLAG_REALTIME) {
 -		if (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||
 -		    (ip->i_d.di_extsize % mp->m_sb.sb_rextsize))
 -			return -EINVAL;
 -	}
 -
 -	/*
 -	 * Can't modify an immutable/append-only file unless
 -	 * we have appropriate permission.
 -	 */
 -	if (((ip->i_d.di_flags & (XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND)) ||
 -	     (fa->fsx_xflags & (XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&
 -	    !capable(CAP_LINUX_IMMUTABLE))
 -		return -EPERM;
 -
 -	xfs_set_diflags(ip, fa->fsx_xflags);
 -	xfs_diflags_to_linux(ip);
 -	xfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);
 -	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
 -	XFS_STATS_INC(xs_ig_attrchg);
 -	return 0;
 -}
 -
 -/*
 - * Set up the transaction structure for the setattr operation, checking that we
 - * have permission to do so. On success, return a clean transaction and the
 - * inode locked exclusively ready for further operation specific checks. On
 - * failure, return an error without modifying or locking the inode.
 - */
 -static struct xfs_trans *
 -xfs_ioctl_setattr_get_trans(
 -	struct xfs_inode	*ip)
 -{
 -	struct xfs_mount	*mp = ip->i_mount;
 -	struct xfs_trans	*tp;
 -	int			error;
 -
 -	if (mp->m_flags & XFS_MOUNT_RDONLY)
 -		return ERR_PTR(-EROFS);
 -	if (XFS_FORCED_SHUTDOWN(mp))
 -		return ERR_PTR(-EIO);
 -
 -	tp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);
 -	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);
 -	if (error)
 -		goto out_cancel;
 -
 -	xfs_ilock(ip, XFS_ILOCK_EXCL);
 -	xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
 -
 -	/*
 -	 * CAP_FOWNER overrides the following restrictions:
 -	 *
 -	 * The user ID of the calling process must be equal to the file owner
 -	 * ID, except in cases where the CAP_FSETID capability is applicable.
 -	 */
 -	if (!inode_owner_or_capable(VFS_I(ip))) {
 -		error = -EPERM;
 -		goto out_cancel;
 -	}
 -
 -	if (mp->m_flags & XFS_MOUNT_WSYNC)
 -		xfs_trans_set_sync(tp);
 -
 -	return tp;
 -
 -out_cancel:
 -	xfs_trans_cancel(tp, 0);
 -	return ERR_PTR(error);
 -}
 +#define FSX_PROJID	1
 +#define FSX_EXTSIZE	2
 +#define FSX_XFLAGS	4
  
+ int
+ xfs_ioctl_setattr_check_extsize(
+ 	struct xfs_inode	*ip,
+ 	struct fsxattr		*fa)
+ {
+ 	struct xfs_mount	*mp = ip->i_mount;
+ 
+ 	/* Can't change extent size if any extents are allocated. */
+ 	if (ip->i_d.di_nextents &&
+ 	    ((ip->i_d.di_extsize << mp->m_sb.sb_blocklog) != fa->fsx_extsize))
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * Extent size must be a multiple of the appropriate block size, if set
+ 	 * at all. It must also be smaller than the maximum extent size
+ 	 * supported by the filesystem.
+ 	 *
+ 	 * Also, for non-realtime files, limit the extent size hint to half the
+ 	 * size of the AGs in the filesystem so alignment doesn't result in
+ 	 * extents larger than an AG.
+ 	 */
+ 	if (fa->fsx_extsize != 0) {
+ 		xfs_extlen_t    size;
+ 		xfs_fsblock_t   extsize_fsb;
+ 
+ 		extsize_fsb = XFS_B_TO_FSB(mp, fa->fsx_extsize);
+ 		if (extsize_fsb > MAXEXTLEN)
+ 			return -EINVAL;
+ 
+ 		if (XFS_IS_REALTIME_INODE(ip) ||
+ 		    (fa->fsx_xflags & XFS_XFLAG_REALTIME)) {
+ 			size = mp->m_sb.sb_rextsize << mp->m_sb.sb_blocklog;
+ 		} else {
+ 			size = mp->m_sb.sb_blocksize;
+ 			if (extsize_fsb > mp->m_sb.sb_agblocks / 2)
+ 				return -EINVAL;
+ 		}
+ 
+ 		if (fa->fsx_extsize % size)
+ 			return -EINVAL;
+ 	}
+ 	return 0;
+ }
+ 
+ 
  STATIC int
  xfs_ioctl_setattr(
  	xfs_inode_t		*ip,
@@@ -1093,182 -1193,49 +1138,205 @@@
  			return code;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * For the other attributes, we acquire the inode lock and
 +	 * first do an error checking pass.
 +	 */
 +	tp = xfs_trans_alloc(mp, XFS_TRANS_SETATTR_NOT_SIZE);
 +	code = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);
++=======
+ 	tp = xfs_ioctl_setattr_get_trans(ip);
+ 	if (IS_ERR(tp)) {
+ 		code = PTR_ERR(tp);
+ 		goto error_free_dquots;
+ 	}
+ 
+ 
+ 	if (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp) &&
+ 	    xfs_get_projid(ip) != fa->fsx_projid) {
+ 		code = xfs_qm_vop_chown_reserve(tp, ip, udqp, NULL, pdqp,
+ 				capable(CAP_FOWNER) ?  XFS_QMOPT_FORCE_RES : 0);
+ 		if (code)	/* out of quota */
+ 			goto error_trans_cancel;
+ 	}
+ 
+ 	code = xfs_ioctl_setattr_check_extsize(ip, fa);
  	if (code)
- 		goto error_return;
+ 		goto error_trans_cancel;
+ 
+ 	code = xfs_ioctl_setattr_xflags(tp, ip, fa);
++>>>>>>> d4388d3c0988 (xfs: factor extsize hint checking out of xfs_ioctl_setattr)
+ 	if (code)
+ 		goto error_trans_cancel;
  
 +	lock_flags = XFS_ILOCK_EXCL;
 +	xfs_ilock(ip, lock_flags);
 +
  	/*
 -	 * Change file ownership.  Must be the owner or privileged.  CAP_FSETID
 -	 * overrides the following restrictions:
 +	 * CAP_FOWNER overrides the following restrictions:
  	 *
 -	 * The set-user-ID and set-group-ID bits of a file will be cleared upon
 -	 * successful return from chown()
 +	 * The user ID of the calling process must be equal
 +	 * to the file owner ID, except in cases where the
 +	 * CAP_FSETID capability is applicable.
 +	 */
 +	if (!inode_owner_or_capable(VFS_I(ip))) {
 +		code = XFS_ERROR(EPERM);
 +		goto error_return;
 +	}
 +
 +	/*
 +	 * Do a quota reservation only if projid is actually going to change.
 +	 * Only allow changing of projid from init_user_ns since it is a
 +	 * non user namespace aware identifier.
  	 */
 +	if (mask & FSX_PROJID) {
 +		if (current_user_ns() != &init_user_ns) {
 +			code = XFS_ERROR(EINVAL);
 +			goto error_return;
 +		}
 +
 +		if (XFS_IS_QUOTA_RUNNING(mp) &&
 +		    XFS_IS_PQUOTA_ON(mp) &&
 +		    xfs_get_projid(ip) != fa->fsx_projid) {
 +			ASSERT(tp);
 +			code = xfs_qm_vop_chown_reserve(tp, ip, udqp, NULL,
 +						pdqp, capable(CAP_FOWNER) ?
 +						XFS_QMOPT_FORCE_RES : 0);
 +			if (code)	/* out of quota */
 +				goto error_return;
 +		}
 +	}
 +
 +	if (mask & FSX_EXTSIZE) {
 +		/*
 +		 * Can't change extent size if any extents are allocated.
 +		 */
 +		if (ip->i_d.di_nextents &&
 +		    ((ip->i_d.di_extsize << mp->m_sb.sb_blocklog) !=
 +		     fa->fsx_extsize)) {
 +			code = XFS_ERROR(EINVAL);	/* EFBIG? */
 +			goto error_return;
 +		}
 +
 +		/*
 +		 * Extent size must be a multiple of the appropriate block
 +		 * size, if set at all. It must also be smaller than the
 +		 * maximum extent size supported by the filesystem.
 +		 *
 +		 * Also, for non-realtime files, limit the extent size hint to
 +		 * half the size of the AGs in the filesystem so alignment
 +		 * doesn't result in extents larger than an AG.
 +		 */
 +		if (fa->fsx_extsize != 0) {
 +			xfs_extlen_t    size;
 +			xfs_fsblock_t   extsize_fsb;
 +
 +			extsize_fsb = XFS_B_TO_FSB(mp, fa->fsx_extsize);
 +			if (extsize_fsb > MAXEXTLEN) {
 +				code = XFS_ERROR(EINVAL);
 +				goto error_return;
 +			}
 +
 +			if (XFS_IS_REALTIME_INODE(ip) ||
 +			    ((mask & FSX_XFLAGS) &&
 +			    (fa->fsx_xflags & XFS_XFLAG_REALTIME))) {
 +				size = mp->m_sb.sb_rextsize <<
 +				       mp->m_sb.sb_blocklog;
 +			} else {
 +				size = mp->m_sb.sb_blocksize;
 +				if (extsize_fsb > mp->m_sb.sb_agblocks / 2) {
 +					code = XFS_ERROR(EINVAL);
 +					goto error_return;
 +				}
 +			}
 +
 +			if (fa->fsx_extsize % size) {
 +				code = XFS_ERROR(EINVAL);
 +				goto error_return;
 +			}
 +		}
 +	}
 +
 +
 +	if (mask & FSX_XFLAGS) {
 +		/*
 +		 * Can't change realtime flag if any extents are allocated.
 +		 */
 +		if ((ip->i_d.di_nextents || ip->i_delayed_blks) &&
 +		    (XFS_IS_REALTIME_INODE(ip)) !=
 +		    (fa->fsx_xflags & XFS_XFLAG_REALTIME)) {
 +			code = XFS_ERROR(EINVAL);	/* EFBIG? */
 +			goto error_return;
 +		}
 +
 +		/*
 +		 * If realtime flag is set then must have realtime data.
 +		 */
 +		if ((fa->fsx_xflags & XFS_XFLAG_REALTIME)) {
 +			if ((mp->m_sb.sb_rblocks == 0) ||
 +			    (mp->m_sb.sb_rextsize == 0) ||
 +			    (ip->i_d.di_extsize % mp->m_sb.sb_rextsize)) {
 +				code = XFS_ERROR(EINVAL);
 +				goto error_return;
 +			}
 +		}
 +
 +		/*
 +		 * Can't modify an immutable/append-only file unless
 +		 * we have appropriate permission.
 +		 */
 +		if ((ip->i_d.di_flags &
 +				(XFS_DIFLAG_IMMUTABLE|XFS_DIFLAG_APPEND) ||
 +		     (fa->fsx_xflags &
 +				(XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND))) &&
 +		    !capable(CAP_LINUX_IMMUTABLE)) {
 +			code = XFS_ERROR(EPERM);
 +			goto error_return;
 +		}
 +	}
 +
 +	xfs_trans_ijoin(tp, ip, 0);
  
 -	if ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&
 -	    !capable_wrt_inode_uidgid(VFS_I(ip), CAP_FSETID))
 -		ip->i_d.di_mode &= ~(S_ISUID|S_ISGID);
 +	/*
 +	 * Change file ownership.  Must be the owner or privileged.
 +	 */
 +	if (mask & FSX_PROJID) {
 +		/*
 +		 * CAP_FSETID overrides the following restrictions:
 +		 *
 +		 * The set-user-ID and set-group-ID bits of a file will be
 +		 * cleared upon successful return from chown()
 +		 */
 +		if ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&
 +		    !inode_capable(VFS_I(ip), CAP_FSETID))
 +			ip->i_d.di_mode &= ~(S_ISUID|S_ISGID);
  
 -	/* Change the ownerships and register project quota modifications */
 -	if (xfs_get_projid(ip) != fa->fsx_projid) {
 -		if (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {
 -			olddquot = xfs_qm_vop_chown(tp, ip,
 -						&ip->i_pdquot, pdqp);
 +		/*
 +		 * Change the ownerships and register quota modifications
 +		 * in the transaction.
 +		 */
 +		if (xfs_get_projid(ip) != fa->fsx_projid) {
 +			if (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {
 +				olddquot = xfs_qm_vop_chown(tp, ip,
 +							&ip->i_pdquot, pdqp);
 +			}
 +			xfs_set_projid(ip, fa->fsx_projid);
 +
 +			/*
 +			 * We may have to rev the inode as well as
 +			 * the superblock version number since projids didn't
 +			 * exist before DINODE_VERSION_2 and SB_VERSION_NLINK.
 +			 */
 +			if (ip->i_d.di_version == 1)
 +				xfs_bump_ino_vers2(tp, ip);
  		}
 -		ASSERT(ip->i_d.di_version > 1);
 -		xfs_set_projid(ip, fa->fsx_projid);
 +
 +	}
 +
 +	if (mask & FSX_XFLAGS) {
 +		xfs_set_diflags(ip, fa->fsx_xflags);
 +		xfs_diflags_to_linux(ip);
  	}
  
  	/*
@@@ -1314,12 -1259,11 +1382,18 @@@
  
  	return code;
  
++<<<<<<< HEAD
 + error_return:
++=======
+ error_trans_cancel:
+ 	xfs_trans_cancel(tp, 0);
+ error_free_dquots:
++>>>>>>> d4388d3c0988 (xfs: factor extsize hint checking out of xfs_ioctl_setattr)
  	xfs_qm_dqrele(udqp);
  	xfs_qm_dqrele(pdqp);
 +	xfs_trans_cancel(tp, 0);
 +	if (lock_flags)
 +		xfs_iunlock(ip, lock_flags);
  	return code;
  }
  
* Unmerged path fs/xfs/xfs_ioctl.c
