Btrfs: be aware of btree inode write errors to avoid fs corruption

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Filipe Manana <fdmanana@suse.com>
commit 656f30dba7ab8179c9a2e04293b0c7b383fa9ce9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/656f30db.failed

While we have a transaction ongoing, the VM might decide at any time
to call btree_inode->i_mapping->a_ops->writepages(), which will start
writeback of dirty pages belonging to btree nodes/leafs. This call
might return an error or the writeback might finish with an error
before we attempt to commit the running transaction. If this happens,
we might have no way of knowing that such error happened when we are
committing the transaction - because the pages might no longer be
marked dirty nor tagged for writeback (if a subsequent modification
to the extent buffer didn't happen before the transaction commit) which
makes filemap_fdata[write|wait]_range unable to find such pages (even
if they're marked with SetPageError).
So if this happens we must abort the transaction, otherwise we commit
a super block with btree roots that point to btree nodes/leafs whose
content on disk is invalid - either garbage or the content of some
node/leaf from a past generation that got cowed or deleted and is no
longer valid (for this later case we end up getting error messages like
"parent transid verify failed on 10826481664 wanted 25748 found 29562"
when reading btree nodes/leafs from disk).

Note that setting and checking AS_EIO/AS_ENOSPC in the btree inode's
i_mapping would not be enough because we need to distinguish between
log tree extents (not fatal) vs non-log tree extents (fatal) and
because the next call to filemap_fdatawait_range() will catch and clear
such errors in the mapping - and that call might be from a log sync and
not from a transaction commit, which means we would not know about the
error at transaction commit time. Also, checking for the eb flag
EXTENT_BUFFER_IOERR at transaction commit time isn't done and would
not be completely reliable, as the eb might be removed from memory and
read back when trying to get it, which clears that flag right before
reading the eb's pages from disk, making us not know about the previous
write error.

Using the new 3 flags for the btree inode also makes us achieve the
goal of AS_EIO/AS_ENOSPC when writepages() returns success, started
writeback for all dirty pages and before filemap_fdatawait_range() is
called, the writeback for all dirty pages had already finished with
errors - because we were not using AS_EIO/AS_ENOSPC,
filemap_fdatawait_range() would return success, as it could not know
that writeback errors happened (the pages were no longer tagged for
writeback).

	Signed-off-by: Filipe Manana <fdmanana@suse.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit 656f30dba7ab8179c9a2e04293b0c7b383fa9ce9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/extent_io.c
diff --cc fs/btrfs/extent_io.c
index bc73864031df,215603b911f1..000000000000
--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@@ -3538,25 -3601,84 +3538,91 @@@ static void end_extent_buffer_writeback
  	wake_up_bit(&eb->bflags, EXTENT_BUFFER_WRITEBACK);
  }
  
+ static void set_btree_ioerr(struct page *page)
+ {
+ 	struct extent_buffer *eb = (struct extent_buffer *)page->private;
+ 	struct btrfs_inode *btree_ino = BTRFS_I(eb->fs_info->btree_inode);
+ 
+ 	SetPageError(page);
+ 	if (test_and_set_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags))
+ 		return;
+ 
+ 	/*
+ 	 * If writeback for a btree extent that doesn't belong to a log tree
+ 	 * failed, increment the counter transaction->eb_write_errors.
+ 	 * We do this because while the transaction is running and before it's
+ 	 * committing (when we call filemap_fdata[write|wait]_range against
+ 	 * the btree inode), we might have
+ 	 * btree_inode->i_mapping->a_ops->writepages() called by the VM - if it
+ 	 * returns an error or an error happens during writeback, when we're
+ 	 * committing the transaction we wouldn't know about it, since the pages
+ 	 * can be no longer dirty nor marked anymore for writeback (if a
+ 	 * subsequent modification to the extent buffer didn't happen before the
+ 	 * transaction commit), which makes filemap_fdata[write|wait]_range not
+ 	 * able to find the pages tagged with SetPageError at transaction
+ 	 * commit time. So if this happens we must abort the transaction,
+ 	 * otherwise we commit a super block with btree roots that point to
+ 	 * btree nodes/leafs whose content on disk is invalid - either garbage
+ 	 * or the content of some node/leaf from a past generation that got
+ 	 * cowed or deleted and is no longer valid.
+ 	 *
+ 	 * Note: setting AS_EIO/AS_ENOSPC in the btree inode's i_mapping would
+ 	 * not be enough - we need to distinguish between log tree extents vs
+ 	 * non-log tree extents, and the next filemap_fdatawait_range() call
+ 	 * will catch and clear such errors in the mapping - and that call might
+ 	 * be from a log sync and not from a transaction commit. Also, checking
+ 	 * for the eb flag EXTENT_BUFFER_WRITE_ERR at transaction commit time is
+ 	 * not done and would not be reliable - the eb might have been released
+ 	 * from memory and reading it back again means that flag would not be
+ 	 * set (since it's a runtime flag, not persisted on disk).
+ 	 *
+ 	 * Using the flags below in the btree inode also makes us achieve the
+ 	 * goal of AS_EIO/AS_ENOSPC when writepages() returns success, started
+ 	 * writeback for all dirty pages and before filemap_fdatawait_range()
+ 	 * is called, the writeback for all dirty pages had already finished
+ 	 * with errors - because we were not using AS_EIO/AS_ENOSPC,
+ 	 * filemap_fdatawait_range() would return success, as it could not know
+ 	 * that writeback errors happened (the pages were no longer tagged for
+ 	 * writeback).
+ 	 */
+ 	switch (eb->log_index) {
+ 	case -1:
+ 		set_bit(BTRFS_INODE_BTREE_ERR, &btree_ino->runtime_flags);
+ 		break;
+ 	case 0:
+ 		set_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);
+ 		break;
+ 	case 1:
+ 		set_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);
+ 		break;
+ 	default:
+ 		BUG(); /* unexpected, logic error */
+ 	}
+ }
+ 
  static void end_bio_extent_buffer_writepage(struct bio *bio, int err)
  {
 -	struct bio_vec *bvec;
 +	int uptodate = err == 0;
 +	struct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;
  	struct extent_buffer *eb;
 -	int i, done;
 +	int done;
  
 -	bio_for_each_segment_all(bvec, bio, i) {
 +	do {
  		struct page *page = bvec->bv_page;
  
 +		bvec--;
  		eb = (struct extent_buffer *)page->private;
  		BUG_ON(!eb);
  		done = atomic_dec_and_test(&eb->io_pages);
  
++<<<<<<< HEAD
 +		if (!uptodate || test_bit(EXTENT_BUFFER_IOERR, &eb->bflags)) {
 +			set_bit(EXTENT_BUFFER_IOERR, &eb->bflags);
++=======
+ 		if (err || test_bit(EXTENT_BUFFER_WRITE_ERR, &eb->bflags)) {
++>>>>>>> 656f30dba7ab (Btrfs: be aware of btree inode write errors to avoid fs corruption)
  			ClearPageUptodate(page);
- 			SetPageError(page);
+ 			set_btree_ioerr(page);
  		}
  
  		end_page_writeback(page);
diff --git a/fs/btrfs/btrfs_inode.h b/fs/btrfs/btrfs_inode.h
index 1aa38414f6c8..421b59f0161a 100644
--- a/fs/btrfs/btrfs_inode.h
+++ b/fs/btrfs/btrfs_inode.h
@@ -44,6 +44,17 @@
 #define BTRFS_INODE_IN_DELALLOC_LIST		9
 #define BTRFS_INODE_READDIO_NEED_LOCK		10
 #define BTRFS_INODE_HAS_PROPS		        11
+/*
+ * The following 3 bits are meant only for the btree inode.
+ * When any of them is set, it means an error happened while writing an
+ * extent buffer belonging to:
+ * 1) a non-log btree
+ * 2) a log btree and first log sub-transaction
+ * 3) a log btree and second log sub-transaction
+ */
+#define BTRFS_INODE_BTREE_ERR		        12
+#define BTRFS_INODE_BTREE_LOG1_ERR		13
+#define BTRFS_INODE_BTREE_LOG2_ERR		14
 
 /* in memory btrfs inode */
 struct btrfs_inode {
diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index 5be819470d6d..b865a730b2ac 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -606,7 +606,7 @@ static int btree_readpage_end_io_hook(struct btrfs_io_bio *io_bio,
 		goto err;
 
 	eb->read_mirror = mirror;
-	if (test_bit(EXTENT_BUFFER_IOERR, &eb->bflags)) {
+	if (test_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags)) {
 		ret = -EIO;
 		goto err;
 	}
@@ -679,7 +679,7 @@ static int btree_io_failed_hook(struct page *page, int failed_mirror)
 	struct btrfs_root *root = BTRFS_I(page->mapping->host)->root;
 
 	eb = (struct extent_buffer *)page->private;
-	set_bit(EXTENT_BUFFER_IOERR, &eb->bflags);
+	set_bit(EXTENT_BUFFER_READ_ERR, &eb->bflags);
 	eb->read_mirror = failed_mirror;
 	atomic_dec(&eb->io_pages);
 	if (test_and_clear_bit(EXTENT_BUFFER_READAHEAD, &eb->bflags))
diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c
index 76f503b1e5cc..6d3edae58f53 100644
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -7234,17 +7234,19 @@ btrfs_init_new_buffer(struct btrfs_trans_handle *trans, struct btrfs_root *root,
 	btrfs_set_buffer_uptodate(buf);
 
 	if (root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID) {
+		buf->log_index = root->log_transid % 2;
 		/*
 		 * we allow two log transactions at a time, use different
 		 * EXENT bit to differentiate dirty pages.
 		 */
-		if (root->log_transid % 2 == 0)
+		if (buf->log_index == 0)
 			set_extent_dirty(&root->dirty_log_pages, buf->start,
 					buf->start + buf->len - 1, GFP_NOFS);
 		else
 			set_extent_new(&root->dirty_log_pages, buf->start,
 					buf->start + buf->len - 1, GFP_NOFS);
 	} else {
+		buf->log_index = -1;
 		set_extent_dirty(&trans->transaction->dirty_pages, buf->start,
 			 buf->start + buf->len - 1, GFP_NOFS);
 	}
* Unmerged path fs/btrfs/extent_io.c
diff --git a/fs/btrfs/extent_io.h b/fs/btrfs/extent_io.h
index d33406bf20ca..9fcd8d203a8d 100644
--- a/fs/btrfs/extent_io.h
+++ b/fs/btrfs/extent_io.h
@@ -38,9 +38,10 @@
 #define EXTENT_BUFFER_TREE_REF 5
 #define EXTENT_BUFFER_STALE 6
 #define EXTENT_BUFFER_WRITEBACK 7
-#define EXTENT_BUFFER_IOERR 8
+#define EXTENT_BUFFER_READ_ERR 8        /* read IO error */
 #define EXTENT_BUFFER_DUMMY 9
 #define EXTENT_BUFFER_IN_TREE 10
+#define EXTENT_BUFFER_WRITE_ERR 11    /* write IO error */
 
 /* these are flags for extent_clear_unlock_delalloc */
 #define PAGE_UNLOCK		(1 << 0)
@@ -137,7 +138,9 @@ struct extent_buffer {
 	atomic_t blocking_readers;
 	atomic_t spinning_readers;
 	atomic_t spinning_writers;
-	int lock_nested;
+	short lock_nested;
+	/* >= 0 if eb belongs to a log tree, -1 otherwise */
+	short log_index;
 
 	/* protects write locks */
 	rwlock_t lock;
diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.c
index b6cbf7c57023..2b7f360a7632 100644
--- a/fs/btrfs/transaction.c
+++ b/fs/btrfs/transaction.c
@@ -851,6 +851,8 @@ int btrfs_wait_marked_extents(struct btrfs_root *root,
 	struct extent_state *cached_state = NULL;
 	u64 start = 0;
 	u64 end;
+	struct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);
+	bool errors = false;
 
 	while (!find_first_extent_bit(dirty_pages, start, &start, &end,
 				      EXTENT_NEED_WAIT, &cached_state)) {
@@ -864,6 +866,26 @@ int btrfs_wait_marked_extents(struct btrfs_root *root,
 	}
 	if (err)
 		werr = err;
+
+	if (root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID) {
+		if ((mark & EXTENT_DIRTY) &&
+		    test_and_clear_bit(BTRFS_INODE_BTREE_LOG1_ERR,
+				       &btree_ino->runtime_flags))
+			errors = true;
+
+		if ((mark & EXTENT_NEW) &&
+		    test_and_clear_bit(BTRFS_INODE_BTREE_LOG2_ERR,
+				       &btree_ino->runtime_flags))
+			errors = true;
+	} else {
+		if (test_and_clear_bit(BTRFS_INODE_BTREE_ERR,
+				       &btree_ino->runtime_flags))
+			errors = true;
+	}
+
+	if (errors && !werr)
+		werr = -EIO;
+
 	return werr;
 }
 
@@ -1629,6 +1651,7 @@ int btrfs_commit_transaction(struct btrfs_trans_handle *trans,
 {
 	struct btrfs_transaction *cur_trans = trans->transaction;
 	struct btrfs_transaction *prev_trans = NULL;
+	struct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);
 	int ret;
 
 	/* Stop the commit early if ->aborted is set */
@@ -1871,6 +1894,9 @@ int btrfs_commit_transaction(struct btrfs_trans_handle *trans,
 	btrfs_update_commit_device_size(root->fs_info);
 	btrfs_update_commit_device_bytes_used(root, cur_trans);
 
+	clear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);
+	clear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);
+
 	spin_lock(&root->fs_info->trans_lock);
 	cur_trans->state = TRANS_STATE_UNBLOCKED;
 	root->fs_info->running_transaction = NULL;
