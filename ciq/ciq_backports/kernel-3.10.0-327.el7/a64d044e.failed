bonding: slight optimization for bond_xmit_roundrobin()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author dingtianhong <dingtianhong@huawei.com>
commit a64d044e3907b717ae3d1e3711226064b42c83f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a64d044e.failed

When the slave is the curr_active_slave, no need to check
whether the slave is active or not, it is always active.

	Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a64d044e3907b717ae3d1e3711226064b42c83f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index b4cb8784d691,88b1ab04ce4b..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -3853,40 -3524,15 +3853,49 @@@ static int bond_xmit_roundrobin(struct 
  	 * send the join/membership reports.  The curr_active_slave found
  	 * will send all of this type of traffic.
  	 */
++<<<<<<< HEAD
 +	if ((iph->protocol == IPPROTO_IGMP) &&
 +	    (skb->protocol == htons(ETH_P_IP))) {
 +		slave = bond->curr_active_slave;
 +		if (!slave)
 +			goto out;
++=======
+ 	if (iph->protocol == IPPROTO_IGMP && skb->protocol == htons(ETH_P_IP)) {
+ 		slave = rcu_dereference(bond->curr_active_slave);
+ 		if (slave)
+ 			bond_dev_queue_xmit(bond, skb, slave->dev);
+ 		else
+ 			bond_xmit_slave_id(bond, skb, 0);
++>>>>>>> a64d044e3907 (bonding: slight optimization for bond_xmit_roundrobin())
  	} else {
 -		slave_id = bond_rr_gen_slave_id(bond);
 -		bond_xmit_slave_id(bond, skb, slave_id % bond->slave_cnt);
 +		/*
 +		 * Concurrent TX may collide on rr_tx_counter; we accept
 +		 * that as being rare enough not to justify using an
 +		 * atomic op here.
 +		 */
 +		slave_no = bond->rr_tx_counter++ % bond->slave_cnt;
 +
 +		bond_for_each_slave(bond, slave, i) {
 +			slave_no--;
 +			if (slave_no < 0)
 +				break;
 +		}
 +	}
 +
 +	start_at = slave;
 +	bond_for_each_slave_from(bond, slave, i, start_at) {
 +		if (IS_UP(slave->dev) &&
 +		    (slave->link == BOND_LINK_UP) &&
 +		    bond_is_active_slave(slave)) {
 +			res = bond_dev_queue_xmit(bond, skb, slave->dev);
 +			break;
 +		}
 +	}
 +
 +out:
 +	if (res) {
 +		/* no suitable interface, frame not sent */
 +		kfree_skb(skb);
  	}
  
  	return NETDEV_TX_OK;
* Unmerged path drivers/net/bonding/bond_main.c
