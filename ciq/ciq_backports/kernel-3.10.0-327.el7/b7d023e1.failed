ALSA: hda - Move PCM format and rate handling code to core library

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Move PCM format and rate handling code to core library (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 95.24%
commit-author Takashi Iwai <tiwai@suse.de>
commit b7d023e11434131e5a7ceb4be33c3afa2c855e89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b7d023e1.failed

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit b7d023e11434131e5a7ceb4be33c3afa2c855e89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/hdaudio.h
#	sound/hda/hdac_device.c
#	sound/pci/hda/hda_codec.c
#	sound/pci/hda/hda_controller.c
diff --cc sound/pci/hda/hda_codec.c
index d744f45d5fe3,df3cebc06110..000000000000
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@@ -4110,325 -3192,6 +4110,328 @@@ int snd_hda_codec_build_controls(struc
  }
  
  /*
++<<<<<<< HEAD
 + * stream formats
 + */
 +struct hda_rate_tbl {
 +	unsigned int hz;
 +	unsigned int alsa_bits;
 +	unsigned int hda_fmt;
 +};
 +
 +/* rate = base * mult / div */
 +#define HDA_RATE(base, mult, div) \
 +	(AC_FMT_BASE_##base##K | (((mult) - 1) << AC_FMT_MULT_SHIFT) | \
 +	 (((div) - 1) << AC_FMT_DIV_SHIFT))
 +
 +static struct hda_rate_tbl rate_bits[] = {
 +	/* rate in Hz, ALSA rate bitmask, HDA format value */
 +
 +	/* autodetected value used in snd_hda_query_supported_pcm */
 +	{ 8000, SNDRV_PCM_RATE_8000, HDA_RATE(48, 1, 6) },
 +	{ 11025, SNDRV_PCM_RATE_11025, HDA_RATE(44, 1, 4) },
 +	{ 16000, SNDRV_PCM_RATE_16000, HDA_RATE(48, 1, 3) },
 +	{ 22050, SNDRV_PCM_RATE_22050, HDA_RATE(44, 1, 2) },
 +	{ 32000, SNDRV_PCM_RATE_32000, HDA_RATE(48, 2, 3) },
 +	{ 44100, SNDRV_PCM_RATE_44100, HDA_RATE(44, 1, 1) },
 +	{ 48000, SNDRV_PCM_RATE_48000, HDA_RATE(48, 1, 1) },
 +	{ 88200, SNDRV_PCM_RATE_88200, HDA_RATE(44, 2, 1) },
 +	{ 96000, SNDRV_PCM_RATE_96000, HDA_RATE(48, 2, 1) },
 +	{ 176400, SNDRV_PCM_RATE_176400, HDA_RATE(44, 4, 1) },
 +	{ 192000, SNDRV_PCM_RATE_192000, HDA_RATE(48, 4, 1) },
 +#define AC_PAR_PCM_RATE_BITS	11
 +	/* up to bits 10, 384kHZ isn't supported properly */
 +
 +	/* not autodetected value */
 +	{ 9600, SNDRV_PCM_RATE_KNOT, HDA_RATE(48, 1, 5) },
 +
 +	{ 0 } /* terminator */
 +};
 +
 +/**
 + * snd_hda_calc_stream_format - calculate format bitset
 + * @codec: HD-audio codec
 + * @rate: the sample rate
 + * @channels: the number of channels
 + * @format: the PCM format (SNDRV_PCM_FORMAT_XXX)
 + * @maxbps: the max. bps
 + * @spdif_ctls: HD-audio SPDIF status bits (0 if irrelevant)
 + *
 + * Calculate the format bitset from the given rate, channels and th PCM format.
 + *
 + * Return zero if invalid.
 + */
 +unsigned int snd_hda_calc_stream_format(struct hda_codec *codec,
 +					unsigned int rate,
 +					unsigned int channels,
 +					unsigned int format,
 +					unsigned int maxbps,
 +					unsigned short spdif_ctls)
 +{
 +	int i;
 +	unsigned int val = 0;
 +
 +	for (i = 0; rate_bits[i].hz; i++)
 +		if (rate_bits[i].hz == rate) {
 +			val = rate_bits[i].hda_fmt;
 +			break;
 +		}
 +	if (!rate_bits[i].hz) {
 +		codec_dbg(codec, "invalid rate %d\n", rate);
 +		return 0;
 +	}
 +
 +	if (channels == 0 || channels > 8) {
 +		codec_dbg(codec, "invalid channels %d\n", channels);
 +		return 0;
 +	}
 +	val |= channels - 1;
 +
 +	switch (snd_pcm_format_width(format)) {
 +	case 8:
 +		val |= AC_FMT_BITS_8;
 +		break;
 +	case 16:
 +		val |= AC_FMT_BITS_16;
 +		break;
 +	case 20:
 +	case 24:
 +	case 32:
 +		if (maxbps >= 32 || format == SNDRV_PCM_FORMAT_FLOAT_LE)
 +			val |= AC_FMT_BITS_32;
 +		else if (maxbps >= 24)
 +			val |= AC_FMT_BITS_24;
 +		else
 +			val |= AC_FMT_BITS_20;
 +		break;
 +	default:
 +		codec_dbg(codec, "invalid format width %d\n",
 +			  snd_pcm_format_width(format));
 +		return 0;
 +	}
 +
 +	if (spdif_ctls & AC_DIG1_NONAUDIO)
 +		val |= AC_FMT_TYPE_NON_PCM;
 +
 +	return val;
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_calc_stream_format);
 +
 +static unsigned int get_pcm_param(struct hda_codec *codec, hda_nid_t nid,
 +				  int dir)
 +{
 +	unsigned int val = 0;
 +	if (nid != codec->afg &&
 +	    (get_wcaps(codec, nid) & AC_WCAP_FORMAT_OVRD))
 +		val = snd_hda_param_read(codec, nid, AC_PAR_PCM);
 +	if (!val || val == -1)
 +		val = snd_hda_param_read(codec, codec->afg, AC_PAR_PCM);
 +	if (!val || val == -1)
 +		return 0;
 +	return val;
 +}
 +
 +static unsigned int query_pcm_param(struct hda_codec *codec, hda_nid_t nid)
 +{
 +	return query_caps_hash(codec, nid, 0, HDA_HASH_PARPCM_KEY(nid),
 +			       get_pcm_param);
 +}
 +
 +static unsigned int get_stream_param(struct hda_codec *codec, hda_nid_t nid,
 +				     int dir)
 +{
 +	unsigned int streams = snd_hda_param_read(codec, nid, AC_PAR_STREAM);
 +	if (!streams || streams == -1)
 +		streams = snd_hda_param_read(codec, codec->afg, AC_PAR_STREAM);
 +	if (!streams || streams == -1)
 +		return 0;
 +	return streams;
 +}
 +
 +static unsigned int query_stream_param(struct hda_codec *codec, hda_nid_t nid)
 +{
 +	return query_caps_hash(codec, nid, 0, HDA_HASH_PARSTR_KEY(nid),
 +			       get_stream_param);
 +}
 +
 +/**
 + * snd_hda_query_supported_pcm - query the supported PCM rates and formats
 + * @codec: the HDA codec
 + * @nid: NID to query
 + * @ratesp: the pointer to store the detected rate bitflags
 + * @formatsp: the pointer to store the detected formats
 + * @bpsp: the pointer to store the detected format widths
 + *
 + * Queries the supported PCM rates and formats.  The NULL @ratesp, @formatsp
 + * or @bsps argument is ignored.
 + *
 + * Returns 0 if successful, otherwise a negative error code.
 + */
 +int snd_hda_query_supported_pcm(struct hda_codec *codec, hda_nid_t nid,
 +				u32 *ratesp, u64 *formatsp, unsigned int *bpsp)
 +{
 +	unsigned int i, val, wcaps;
 +
 +	wcaps = get_wcaps(codec, nid);
 +	val = query_pcm_param(codec, nid);
 +
 +	if (ratesp) {
 +		u32 rates = 0;
 +		for (i = 0; i < AC_PAR_PCM_RATE_BITS; i++) {
 +			if (val & (1 << i))
 +				rates |= rate_bits[i].alsa_bits;
 +		}
 +		if (rates == 0) {
 +			codec_err(codec,
 +				  "rates == 0 (nid=0x%x, val=0x%x, ovrd=%i)\n",
 +				  nid, val,
 +				  (wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0);
 +			return -EIO;
 +		}
 +		*ratesp = rates;
 +	}
 +
 +	if (formatsp || bpsp) {
 +		u64 formats = 0;
 +		unsigned int streams, bps;
 +
 +		streams = query_stream_param(codec, nid);
 +		if (!streams)
 +			return -EIO;
 +
 +		bps = 0;
 +		if (streams & AC_SUPFMT_PCM) {
 +			if (val & AC_SUPPCM_BITS_8) {
 +				formats |= SNDRV_PCM_FMTBIT_U8;
 +				bps = 8;
 +			}
 +			if (val & AC_SUPPCM_BITS_16) {
 +				formats |= SNDRV_PCM_FMTBIT_S16_LE;
 +				bps = 16;
 +			}
 +			if (wcaps & AC_WCAP_DIGITAL) {
 +				if (val & AC_SUPPCM_BITS_32)
 +					formats |= SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE;
 +				if (val & (AC_SUPPCM_BITS_20|AC_SUPPCM_BITS_24))
 +					formats |= SNDRV_PCM_FMTBIT_S32_LE;
 +				if (val & AC_SUPPCM_BITS_24)
 +					bps = 24;
 +				else if (val & AC_SUPPCM_BITS_20)
 +					bps = 20;
 +			} else if (val & (AC_SUPPCM_BITS_20|AC_SUPPCM_BITS_24|
 +					  AC_SUPPCM_BITS_32)) {
 +				formats |= SNDRV_PCM_FMTBIT_S32_LE;
 +				if (val & AC_SUPPCM_BITS_32)
 +					bps = 32;
 +				else if (val & AC_SUPPCM_BITS_24)
 +					bps = 24;
 +				else if (val & AC_SUPPCM_BITS_20)
 +					bps = 20;
 +			}
 +		}
 +#if 0 /* FIXME: CS4206 doesn't work, which is the only codec supporting float */
 +		if (streams & AC_SUPFMT_FLOAT32) {
 +			formats |= SNDRV_PCM_FMTBIT_FLOAT_LE;
 +			if (!bps)
 +				bps = 32;
 +		}
 +#endif
 +		if (streams == AC_SUPFMT_AC3) {
 +			/* should be exclusive */
 +			/* temporary hack: we have still no proper support
 +			 * for the direct AC3 stream...
 +			 */
 +			formats |= SNDRV_PCM_FMTBIT_U8;
 +			bps = 8;
 +		}
 +		if (formats == 0) {
 +			codec_err(codec,
 +				  "formats == 0 (nid=0x%x, val=0x%x, ovrd=%i, streams=0x%x)\n",
 +				  nid, val,
 +				  (wcaps & AC_WCAP_FORMAT_OVRD) ? 1 : 0,
 +				  streams);
 +			return -EIO;
 +		}
 +		if (formatsp)
 +			*formatsp = formats;
 +		if (bpsp)
 +			*bpsp = bps;
 +	}
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_query_supported_pcm);
 +
 +/**
 + * snd_hda_is_supported_format - Check the validity of the format
 + * @codec: HD-audio codec
 + * @nid: NID to check
 + * @format: the HD-audio format value to check
 + *
 + * Check whether the given node supports the format value.
 + *
 + * Returns 1 if supported, 0 if not.
 + */
 +int snd_hda_is_supported_format(struct hda_codec *codec, hda_nid_t nid,
 +				unsigned int format)
 +{
 +	int i;
 +	unsigned int val = 0, rate, stream;
 +
 +	val = query_pcm_param(codec, nid);
 +	if (!val)
 +		return 0;
 +
 +	rate = format & 0xff00;
 +	for (i = 0; i < AC_PAR_PCM_RATE_BITS; i++)
 +		if (rate_bits[i].hda_fmt == rate) {
 +			if (val & (1 << i))
 +				break;
 +			return 0;
 +		}
 +	if (i >= AC_PAR_PCM_RATE_BITS)
 +		return 0;
 +
 +	stream = query_stream_param(codec, nid);
 +	if (!stream)
 +		return 0;
 +
 +	if (stream & AC_SUPFMT_PCM) {
 +		switch (format & 0xf0) {
 +		case 0x00:
 +			if (!(val & AC_SUPPCM_BITS_8))
 +				return 0;
 +			break;
 +		case 0x10:
 +			if (!(val & AC_SUPPCM_BITS_16))
 +				return 0;
 +			break;
 +		case 0x20:
 +			if (!(val & AC_SUPPCM_BITS_20))
 +				return 0;
 +			break;
 +		case 0x30:
 +			if (!(val & AC_SUPPCM_BITS_24))
 +				return 0;
 +			break;
 +		case 0x40:
 +			if (!(val & AC_SUPPCM_BITS_32))
 +				return 0;
 +			break;
 +		default:
 +			return 0;
 +		}
 +	} else {
 +		/* FIXME: check for float32 and AC3? */
 +	}
 +
 +	return 1;
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_is_supported_format);
 +
 +/*
++=======
++>>>>>>> b7d023e11434 (ALSA: hda - Move PCM format and rate handling code to core library)
   * PCM stuff
   */
  static int hda_pcm_default_open_close(struct hda_pcm_stream *hinfo,
diff --cc sound/pci/hda/hda_controller.c
index 0d7233e1e418,8f12ad9a4df5..000000000000
--- a/sound/pci/hda/hda_controller.c
+++ b/sound/pci/hda/hda_controller.c
@@@ -484,9 -166,8 +484,14 @@@ static int azx_pcm_prepare(struct snd_p
  		goto unlock;
  	}
  
++<<<<<<< HEAD
 +	azx_stream_reset(chip, azx_dev);
 +	format_val = snd_hda_calc_stream_format(apcm->codec,
 +						runtime->rate,
++=======
+ 	snd_hdac_stream_reset(azx_stream(azx_dev));
+ 	format_val = snd_hdac_calc_stream_format(runtime->rate,
++>>>>>>> b7d023e11434 (ALSA: hda - Move PCM format and rate handling code to core library)
  						runtime->channels,
  						runtime->format,
  						hinfo->maxbps,
* Unmerged path include/sound/hdaudio.h
* Unmerged path sound/hda/hdac_device.c
* Unmerged path include/sound/hdaudio.h
* Unmerged path sound/hda/hdac_device.c
* Unmerged path sound/pci/hda/hda_codec.c
diff --git a/sound/pci/hda/hda_codec.h b/sound/pci/hda/hda_codec.h
index 00c6f394c5ce..cf30cb7131d3 100644
--- a/sound/pci/hda/hda_codec.h
+++ b/sound/pci/hda/hda_codec.h
@@ -464,8 +464,6 @@ int snd_hda_get_conn_index(struct hda_codec *codec, hda_nid_t mux,
 			   hda_nid_t nid, int recursive);
 int snd_hda_get_devices(struct hda_codec *codec, hda_nid_t nid,
 			u8 *dev_list, int max_devices);
-int snd_hda_query_supported_pcm(struct hda_codec *codec, hda_nid_t nid,
-				u32 *ratesp, u64 *formatsp, unsigned int *bpsp);
 
 struct hda_verb {
 	hda_nid_t nid;
@@ -553,14 +551,11 @@ void __snd_hda_codec_cleanup_stream(struct hda_codec *codec, hda_nid_t nid,
 				    int do_now);
 #define snd_hda_codec_cleanup_stream(codec, nid) \
 	__snd_hda_codec_cleanup_stream(codec, nid, 0)
-unsigned int snd_hda_calc_stream_format(struct hda_codec *codec,
-					unsigned int rate,
-					unsigned int channels,
-					unsigned int format,
-					unsigned int maxbps,
-					unsigned short spdif_ctls);
-int snd_hda_is_supported_format(struct hda_codec *codec, hda_nid_t nid,
-				unsigned int format);
+
+#define snd_hda_query_supported_pcm(codec, nid, ratesp, fmtsp, bpsp) \
+	snd_hdac_query_supported_pcm(&(codec)->core, nid, ratesp, fmtsp, bpsp)
+#define snd_hda_is_supported_format(codec, nid, fmt) \
+	snd_hdac_is_supported_format(&(codec)->core, nid, fmt)
 
 extern const struct snd_pcm_chmap_elem snd_pcm_2_1_chmaps[];
 
* Unmerged path sound/pci/hda/hda_controller.c
diff --git a/sound/pci/hda/patch_ca0132.c b/sound/pci/hda/patch_ca0132.c
index 72d20652df50..0e99bcb17f7f 100644
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@ -2052,11 +2052,8 @@ static int dma_convert_to_hda_format(struct hda_codec *codec,
 {
 	unsigned int format_val;
 
-	format_val = snd_hda_calc_stream_format(codec,
-				sample_rate,
-				channels,
-				SNDRV_PCM_FORMAT_S32_LE,
-				32, 0);
+	format_val = snd_hdac_calc_stream_format(sample_rate,
+				channels, SNDRV_PCM_FORMAT_S32_LE, 32, 0);
 
 	if (hda_format)
 		*hda_format = (unsigned short)format_val;
