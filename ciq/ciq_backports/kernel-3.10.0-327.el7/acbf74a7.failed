vxlan: Refactor vxlan driver to make use of the common UDP tunnel functions.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] vxlan: Refactor vxlan driver to make use of the common UDP tunnel functions (Marcelo Leitner) [1206570]
Rebuild_FUZZ: 99.34%
commit-author Andy Zhou <azhou@nicira.com>
commit acbf74a763002bdc74ccfcdac22360bf18e305c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/acbf74a7.failed

Simplify vxlan implementation using common UDP tunnel APIs.

	Signed-off-by: Andy Zhou <azhou@nicira.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit acbf74a763002bdc74ccfcdac22360bf18e305c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index 82f83662a0c5,39c86536fb9b..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1571,27 -1569,20 +1570,19 @@@ static bool route_shortcircuit(struct n
  	return false;
  }
  
- static inline struct sk_buff *vxlan_handle_offloads(struct sk_buff *skb,
- 						    bool udp_csum)
- {
- 	int type = udp_csum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
- 	return iptunnel_handle_offloads(skb, udp_csum, type);
- }
- 
  #if IS_ENABLED(CONFIG_IPV6)
 -static int vxlan6_xmit_skb(struct vxlan_sock *vs,
 +static int vxlan6_xmit_skb(struct net *net, struct vxlan_sock *vs,
  			   struct dst_entry *dst, struct sk_buff *skb,
  			   struct net_device *dev, struct in6_addr *saddr,
  			   struct in6_addr *daddr, __u8 prio, __u8 ttl,
 -			   __be16 src_port, __be16 dst_port, __be32 vni,
 -			   bool xnet)
 +			   __be16 src_port, __be16 dst_port, __be32 vni)
  {
- 	struct ipv6hdr *ip6h;
  	struct vxlanhdr *vxh;
- 	struct udphdr *uh;
  	int min_headroom;
  	int err;
+ 	bool udp_sum = !udp_get_no_check6_tx(vs->sock->sk);
  
- 	skb = vxlan_handle_offloads(skb, !udp_get_no_check6_tx(vs->sock->sk));
+ 	skb = udp_tunnel_handle_offloads(skb, udp_sum);
  	if (IS_ERR(skb))
  		return -EINVAL;
  
@@@ -1617,54 -1610,23 +1608,59 @@@
  	vxh->vx_flags = htonl(VXLAN_FLAGS);
  	vxh->vx_vni = vni;
  
++<<<<<<< HEAD
 +	__skb_push(skb, sizeof(*uh));
 +	skb_reset_transport_header(skb);
 +	uh = udp_hdr(skb);
 +
 +	uh->dest = dst_port;
 +	uh->source = src_port;
 +
 +	uh->len = htons(skb->len);
 +
 +	memset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));
 +	IPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED |
 +			      IPSKB_REROUTED);
 +	skb_dst_drop(skb);
 +	skb_dst_set(skb, dst);
 +
 +	udp6_set_csum(udp_get_no_check6_tx(vs->sock->sk), skb,
 +		      saddr, daddr, skb->len);
 +
 +	__skb_push(skb, sizeof(*ip6h));
 +	skb_reset_network_header(skb);
 +	ip6h		  = ipv6_hdr(skb);
 +	ip6h->version	  = 6;
 +	ip6h->priority	  = prio;
 +	ip6h->flow_lbl[0] = 0;
 +	ip6h->flow_lbl[1] = 0;
 +	ip6h->flow_lbl[2] = 0;
 +	ip6h->payload_len = htons(skb->len);
 +	ip6h->nexthdr     = IPPROTO_UDP;
 +	ip6h->hop_limit   = ttl;
 +	ip6h->daddr	  = *daddr;
 +	ip6h->saddr	  = *saddr;
 +
 +	ip6tunnel_xmit(skb, dev);
++=======
+ 	udp_tunnel6_xmit_skb(vs->sock, dst, skb, dev, saddr, daddr, prio,
+ 			     ttl, src_port, dst_port);
++>>>>>>> acbf74a76300 (vxlan: Refactor vxlan driver to make use of the common UDP tunnel functions.)
  	return 0;
  }
  #endif
  
 -int vxlan_xmit_skb(struct vxlan_sock *vs,
 +int vxlan_xmit_skb(struct net *net, struct vxlan_sock *vs,
  		   struct rtable *rt, struct sk_buff *skb,
  		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
 -		   __be16 src_port, __be16 dst_port, __be32 vni, bool xnet)
 +		   __be16 src_port, __be16 dst_port, __be32 vni)
  {
  	struct vxlanhdr *vxh;
- 	struct udphdr *uh;
  	int min_headroom;
  	int err;
+ 	bool udp_sum = !vs->sock->sk->sk_no_check_tx;
  
- 	skb = vxlan_handle_offloads(skb, !vs->sock->sk->sk_no_check_tx);
+ 	skb = udp_tunnel_handle_offloads(skb, udp_sum);
  	if (IS_ERR(skb))
  		return -EINVAL;
  
@@@ -1690,20 -1652,8 +1686,25 @@@
  	vxh->vx_flags = htonl(VXLAN_FLAGS);
  	vxh->vx_vni = vni;
  
++<<<<<<< HEAD
 +	__skb_push(skb, sizeof(*uh));
 +	skb_reset_transport_header(skb);
 +	uh = udp_hdr(skb);
 +
 +	uh->dest = dst_port;
 +	uh->source = src_port;
 +
 +	uh->len = htons(skb->len);
 +
 +	udp_set_csum(vs->sock->sk->sk_no_check_tx, skb,
 +		     src, dst, skb->len);
 +
 +	return iptunnel_xmit(vs->sock->sk, rt, skb, src, dst, IPPROTO_UDP,
 +			     tos, ttl, df);
++=======
+ 	return udp_tunnel_xmit_skb(vs->sock, rt, skb, src, dst, tos,
+ 				   ttl, df, src_port, dst_port, xnet);
++>>>>>>> acbf74a76300 (vxlan: Refactor vxlan driver to make use of the common UDP tunnel functions.)
  }
  EXPORT_SYMBOL_GPL(vxlan_xmit_skb);
  
@@@ -1828,10 -1778,11 +1829,18 @@@ static void vxlan_xmit_one(struct sk_bu
  		tos = ip_tunnel_ecn_encap(tos, old_iph, skb);
  		ttl = ttl ? : ip4_dst_hoplimit(&rt->dst);
  
++<<<<<<< HEAD
 +		err = vxlan_xmit_skb(dev_net(dev), vxlan->vn_sock, rt, skb,
 +				     fl4.saddr, dst->sin.sin_addr.s_addr,
 +				     tos, ttl, df, src_port, dst_port,
 +				     htonl(vni << 8));
++=======
+ 		err = udp_tunnel_xmit_skb(vxlan->vn_sock->sock, rt, skb,
+ 					  fl4.saddr, dst->sin.sin_addr.s_addr,
+ 					  tos, ttl, df, src_port, dst_port,
+ 					  !net_eq(vxlan->net,
+ 						  dev_net(vxlan->dev)));
++>>>>>>> acbf74a76300 (vxlan: Refactor vxlan driver to make use of the common UDP tunnel functions.)
  
  		if (err < 0)
  			goto rt_tx_error;
* Unmerged path drivers/net/vxlan.c
