IB/iser: Don't bound release_work completions timeouts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Don't bound release_work completions timeouts (Amir Vadai) [1164539]
Rebuild_FUZZ: 97.14%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit c107a6c0cf1ab883ea87ca50136f4fc5204a4b82
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c107a6c0.failed

We no longer rely on iscsi connection teardown sequence, so no need to
give a grace period and continue cleanup if it expired. Have
iser_conn_release wait for full completion before freeing iser_conn.

ib_completion:
	Guaranteed to come when:
	    - Got DISCONNECTED/ADDR_CHANGE event or
	    - iSCSI called ep_disconnect/conn_stop
	Guaranteed to finish when:
	    - Got TIMEWAIT_EXIT/DEVICE_REMOVAL event
	    - All Flush errors are consumed
	    - IB related resources are destroyed

stop_completion:
	Guaranteed to come when:
	    - iSCSI calls conn_stop
	Guaranteed to finish when:
	    - All inflight tasks were cleaned up

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Ariel Nahum <arieln@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit c107a6c0cf1ab883ea87ca50136f4fc5204a4b82)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_verbs.c
diff --cc drivers/infiniband/ulp/iser/iser_verbs.c
index fbf2a1e0f2e2,6ce20fd9abac..000000000000
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@@ -591,26 -565,54 +591,37 @@@ static int iser_conn_state_comp_exch(st
  
  void iser_release_work(struct work_struct *work)
  {
++<<<<<<< HEAD
 +	struct iser_conn *ib_conn;
 +	int rc;
++=======
+ 	struct iser_conn *iser_conn;
++>>>>>>> c107a6c0cf1a (IB/iser: Don't bound release_work completions timeouts)
  
 -	iser_conn = container_of(work, struct iser_conn, release_work);
 +	ib_conn = container_of(work, struct iser_conn, release_work);
  
++<<<<<<< HEAD
 +	/* wait for .conn_stop callback */
 +	rc = wait_for_completion_timeout(&ib_conn->stop_completion, 30 * HZ);
 +	WARN_ON(rc == 0);
 +
 +	/* wait for the qp`s post send and post receive buffers to empty */
 +	rc = wait_for_completion_timeout(&ib_conn->flush_completion, 30 * HZ);
 +	WARN_ON(rc == 0);
++=======
+ 	/* Wait for conn_stop to complete */
+ 	wait_for_completion(&iser_conn->stop_completion);
+ 	/* Wait for IB resouces cleanup to complete */
+ 	wait_for_completion(&iser_conn->ib_completion);
++>>>>>>> c107a6c0cf1a (IB/iser: Don't bound release_work completions timeouts)
  
 -	mutex_lock(&iser_conn->state_mutex);
 -	iser_conn->state = ISER_CONN_DOWN;
 -	mutex_unlock(&iser_conn->state_mutex);
 +	ib_conn->state = ISER_CONN_DOWN;
  
 -	iser_conn_release(iser_conn);
 -}
 +	mutex_lock(&ib_conn->state_mutex);
 +	ib_conn->state = ISER_CONN_DOWN;
 +	mutex_unlock(&ib_conn->state_mutex);
  
 -/**
 - * iser_free_ib_conn_res - release IB related resources
 - * @iser_conn: iser connection struct
 - * @destroy_device: indicator if we need to try to release
 - *     the iser device (only iscsi shutdown and DEVICE_REMOVAL
 - *     will use this.
 - *
 - * This routine is called with the iser state mutex held
 - * so the cm_id removal is out of here. It is Safe to
 - * be invoked multiple times.
 - */
 -static void iser_free_ib_conn_res(struct iser_conn *iser_conn,
 -				  bool destroy_device)
 -{
 -	struct ib_conn *ib_conn = &iser_conn->ib_conn;
 -	struct iser_device *device = ib_conn->device;
 -
 -	iser_info("freeing conn %p cma_id %p qp %p\n",
 -		  iser_conn, ib_conn->cma_id, ib_conn->qp);
 -
 -	iser_free_rx_descriptors(iser_conn);
 -
 -	if (ib_conn->qp != NULL) {
 -		ib_conn->device->cq_active_qps[ib_conn->cq_index]--;
 -		rdma_destroy_qp(ib_conn->cma_id);
 -		ib_conn->qp = NULL;
 -	}
 -
 -	if (destroy_device && device != NULL) {
 -		iser_device_try_release(device);
 -		ib_conn->device = NULL;
 -	}
 +	iser_conn_release(ib_conn);
  }
  
  /**
* Unmerged path drivers/infiniband/ulp/iser/iser_verbs.c
