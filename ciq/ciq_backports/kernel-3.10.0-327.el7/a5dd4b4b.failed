PCI: pciehp: Wait for hotplug command completion where necessary

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [pci] pciehp: Wait for hotplug command completion where necessary (Myron Stowe) [1227034]
Rebuild_FUZZ: 95.93%
commit-author Alex Williamson <alex.williamson@redhat.com>
commit a5dd4b4b0570b3bf880d563969b245dfbd170c1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a5dd4b4b.failed

The commit referenced below deferred waiting for command completion until
the start of the next command, allowing hardware to do the latching
asynchronously.  Unfortunately, being ready to accept a new command is the
only indication we have that the previous command is completed.  In cases
where we need that state change to be enabled, we must still wait for
completion.  For instance, pciehp_reset_slot() attempts to disable anything
that might generate a surprise hotplug on slots that support presence
detection.  If we don't wait for those settings to latch before the
secondary bus reset, we negate any value in attempting to prevent the
spurious hotplug.

Create a base function with optional wait and helper functions so that
pcie_write_cmd() turns back into the "safe" interface which waits before
and after issuing a command and add pcie_write_cmd_nowait(), which
eliminates the trailing wait for asynchronous completion.  The following
functions are returned to their previous behavior:

  pciehp_power_on_slot
  pciehp_power_off_slot
  pcie_disable_notification
  pciehp_reset_slot

The rationale is that pciehp_power_on_slot() enables the link and therefore
relies on completion of power-on.  pciehp_power_off_slot() and
pcie_disable_notification() need a wait because data structures may be
freed after these calls and continued signaling from the device would be
unexpected.  And, of course, pciehp_reset_slot() needs to wait for the
scenario outlined above.

Fixes: 3461a068661c ("PCI: pciehp: Wait for hotplug command completion lazily")
	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
CC: stable@vger.kernel.org	# v3.17+
(cherry picked from commit a5dd4b4b0570b3bf880d563969b245dfbd170c1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/pciehp_hpc.c
diff --cc drivers/pci/hotplug/pciehp_hpc.c
index 641bd0c924d4,6d6868811e56..000000000000
--- a/drivers/pci/hotplug/pciehp_hpc.c
+++ b/drivers/pci/hotplug/pciehp_hpc.c
@@@ -129,59 -128,66 +129,61 @@@ static int pcie_poll_cmd(struct control
  	return 0;	/* timeout */
  }
  
 -static void pcie_wait_cmd(struct controller *ctrl)
 +static void pcie_wait_cmd(struct controller *ctrl, int poll)
  {
  	unsigned int msecs = pciehp_poll_mode ? 2500 : 1000;
 -	unsigned long duration = msecs_to_jiffies(msecs);
 -	unsigned long cmd_timeout = ctrl->cmd_started + duration;
 -	unsigned long now, timeout;
 +	unsigned long timeout = msecs_to_jiffies(msecs);
  	int rc;
  
 -	/*
 -	 * If the controller does not generate notifications for command
 -	 * completions, we never need to wait between writes.
 -	 */
 -	if (NO_CMD_CMPL(ctrl))
 -		return;
 -
 -	if (!ctrl->cmd_busy)
 -		return;
 -
 -	/*
 -	 * Even if the command has already timed out, we want to call
 -	 * pcie_poll_cmd() so it can clear PCI_EXP_SLTSTA_CC.
 -	 */
 -	now = jiffies;
 -	if (time_before_eq(cmd_timeout, now))
 -		timeout = 1;
 +	if (poll)
 +		rc = pcie_poll_cmd(ctrl);
  	else
 -		timeout = cmd_timeout - now;
 -
 -	if (ctrl->slot_ctrl & PCI_EXP_SLTCTL_HPIE &&
 -	    ctrl->slot_ctrl & PCI_EXP_SLTCTL_CCIE)
  		rc = wait_event_timeout(ctrl->queue, !ctrl->cmd_busy, timeout);
 -	else
 -		rc = pcie_poll_cmd(ctrl, jiffies_to_msecs(timeout));
 -
 -	/*
 -	 * Controllers with errata like Intel CF118 don't generate
 -	 * completion notifications unless the power/indicator/interlock
 -	 * control bits are changed.  On such controllers, we'll emit this
 -	 * timeout message when we wait for completion of commands that
 -	 * don't change those bits, e.g., commands that merely enable
 -	 * interrupts.
 -	 */
  	if (!rc)
 -		ctrl_info(ctrl, "Timeout on hotplug command %#06x (issued %u msec ago)\n",
 -			  ctrl->slot_ctrl,
 -			  jiffies_to_msecs(jiffies - ctrl->cmd_started));
 +		ctrl_dbg(ctrl, "Command not completed in 1000 msec\n");
  }
  
- /**
-  * pcie_write_cmd - Issue controller command
-  * @ctrl: controller to which the command is issued
-  * @cmd:  command value written to slot control register
-  * @mask: bitmask of slot control register to be modified
-  */
- static void pcie_write_cmd(struct controller *ctrl, u16 cmd, u16 mask)
+ static void pcie_do_write_cmd(struct controller *ctrl, u16 cmd,
+ 			      u16 mask, bool wait)
  {
  	struct pci_dev *pdev = ctrl_dev(ctrl);
 +	u16 slot_status;
  	u16 slot_ctrl;
  
  	mutex_lock(&ctrl->ctrl_lock);
  
++<<<<<<< HEAD
 +	pcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);
 +	if (slot_status & PCI_EXP_SLTSTA_CC) {
 +		pcie_capability_write_word(pdev, PCI_EXP_SLTSTA,
 +					   PCI_EXP_SLTSTA_CC);
 +		if (!ctrl->no_cmd_complete) {
 +			/*
 +			 * After 1 sec and CMD_COMPLETED still not set, just
 +			 * proceed forward to issue the next command according
 +			 * to spec. Just print out the error message.
 +			 */
 +			ctrl_dbg(ctrl, "CMD_COMPLETED not clear after 1 sec\n");
 +		} else if (!NO_CMD_CMPL(ctrl)) {
 +			/*
 +			 * This controller seems to notify of command completed
 +			 * event even though it supports none of power
 +			 * controller, attention led, power led and EMI.
 +			 */
 +			ctrl_dbg(ctrl, "Unexpected CMD_COMPLETED. Need to "
 +				 "wait for command completed event.\n");
 +			ctrl->no_cmd_complete = 0;
 +		} else {
 +			ctrl_dbg(ctrl, "Unexpected CMD_COMPLETED. Maybe "
 +				 "the controller is broken.\n");
 +		}
 +	}
++=======
+ 	/*
+ 	 * Always wait for any previous command that might still be in progress
+ 	 */
+ 	pcie_wait_cmd(ctrl);
++>>>>>>> a5dd4b4b0570 (PCI: pciehp: Wait for hotplug command completion where necessary)
  
  	pcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);
  	slot_ctrl &= ~mask;
@@@ -189,22 -195,16 +191,31 @@@
  	ctrl->cmd_busy = 1;
  	smp_mb();
  	pcie_capability_write_word(pdev, PCI_EXP_SLTCTL, slot_ctrl);
 -	ctrl->cmd_started = jiffies;
 -	ctrl->slot_ctrl = slot_ctrl;
  
  	/*
++<<<<<<< HEAD
 +	 * Wait for command completion.
 +	 */
 +	if (!ctrl->no_cmd_complete) {
 +		int poll = 0;
 +		/*
 +		 * if hotplug interrupt is not enabled or command
 +		 * completed interrupt is not enabled, we need to poll
 +		 * command completed event.
 +		 */
 +		if (!(slot_ctrl & PCI_EXP_SLTCTL_HPIE) ||
 +		    !(slot_ctrl & PCI_EXP_SLTCTL_CCIE))
 +			poll = 1;
 +                pcie_wait_cmd(ctrl, poll);
 +	}
++=======
+ 	 * Optionally wait for the hardware to be ready for a new command,
+ 	 * indicating completion of the above issued command.
+ 	 */
+ 	if (wait)
+ 		pcie_wait_cmd(ctrl);
+ 
++>>>>>>> a5dd4b4b0570 (PCI: pciehp: Wait for hotplug command completion where necessary)
  	mutex_unlock(&ctrl->ctrl_lock);
  }
  
* Unmerged path drivers/pci/hotplug/pciehp_hpc.c
