ACPI / Fan: add ACPI 4.0 style fan support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [acpi] fan: add ACPI 4.0 style fan support (Prarit Bhargava) [1174059]
Rebuild_FUZZ: 90.91%
commit-author Aaron Lu <aaron.lu@intel.com>
commit 9519a6356cbf63b1f22a7a208385dc56092c8b7d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9519a635.failed

This patch adds support for ACPI 4.0 style fan, lacking part is: no
support for 'Low Speed Notification Support', 'Fine Grain Control' is
not used yet.

It's not clear what to do on suspend/resume callback for 4.0 style ACPI
fan, so it does nothing for now.

	Signed-off-by: Aaron Lu <aaron.lu@intel.com>
	Signed-off-by: Zhang Rui <rui.zhang@intel.com>
(cherry picked from commit 9519a6356cbf63b1f22a7a208385dc56092c8b7d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/fan.c
diff --cc drivers/acpi/fan.c
index ab786f1e65cc,f7d1c8027736..000000000000
--- a/drivers/acpi/fan.c
+++ b/drivers/acpi/fan.c
@@@ -29,16 -29,9 +29,22 @@@
  #include <linux/types.h>
  #include <asm/uaccess.h>
  #include <linux/thermal.h>
++<<<<<<< HEAD
 +#include <acpi/acpi_bus.h>
 +#include <acpi/acpi_drivers.h>
 +
 +#define PREFIX "ACPI: "
 +
 +#define ACPI_FAN_CLASS			"fan"
 +#define ACPI_FAN_FILE_STATE		"state"
 +
 +#define _COMPONENT		ACPI_FAN_COMPONENT
 +ACPI_MODULE_NAME("fan");
++=======
+ #include <linux/acpi.h>
+ #include <linux/platform_device.h>
+ #include <linux/sort.h>
++>>>>>>> 9519a6356cbf (ACPI / Fan: add ACPI 4.0 style fan support)
  
  MODULE_AUTHOR("Paul Diefenbaugh");
  MODULE_DESCRIPTION("ACPI Fan Driver");
@@@ -67,15 -60,37 +73,49 @@@ static struct dev_pm_ops acpi_fan_pm = 
  #define FAN_PM_OPS_PTR NULL
  #endif
  
++<<<<<<< HEAD
 +static struct acpi_driver acpi_fan_driver = {
 +	.name = "fan",
 +	.class = ACPI_FAN_CLASS,
 +	.ids = fan_device_ids,
 +	.ops = {
 +		.add = acpi_fan_add,
 +		.remove = acpi_fan_remove,
 +		},
 +	.drv.pm = FAN_PM_OPS_PTR,
++=======
+ struct acpi_fan_fps {
+ 	u64 control;
+ 	u64 trip_point;
+ 	u64 speed;
+ 	u64 noise_level;
+ 	u64 power;
+ };
+ 
+ struct acpi_fan_fif {
+ 	u64 revision;
+ 	u64 fine_grain_ctrl;
+ 	u64 step_size;
+ 	u64 low_speed_notification;
+ };
+ 
+ struct acpi_fan {
+ 	bool acpi4;
+ 	struct acpi_fan_fif fif;
+ 	struct acpi_fan_fps *fps;
+ 	int fps_count;
+ 	struct thermal_cooling_device *cdev;
+ };
+ 
+ static struct platform_driver acpi_fan_driver = {
+ 	.probe = acpi_fan_probe,
+ 	.remove = acpi_fan_remove,
+ 	.driver = {
+ 		.name = "acpi-fan",
+ 		.acpi_match_table = fan_device_ids,
+ 		.pm = FAN_PM_OPS_PTR,
+ 	},
++>>>>>>> 9519a6356cbf (ACPI / Fan: add ACPI 4.0 style fan support)
  };
  
  /* thermal cooling device callbacks */
@@@ -131,18 -223,125 +248,140 @@@ static const struct thermal_cooling_dev
                                   Driver Interface
     -------------------------------------------------------------------------- */
  
++<<<<<<< HEAD
 +static int acpi_fan_add(struct acpi_device *device)
 +{
 +	int result = 0;
 +	struct thermal_cooling_device *cdev;
 +
 +	strcpy(acpi_device_name(device), "Fan");
 +	strcpy(acpi_device_class(device), ACPI_FAN_CLASS);
 +
 +	result = acpi_device_update_power(device, NULL);
 +	if (result) {
 +		printk(KERN_ERR PREFIX "Setting initial power state\n");
 +		goto end;
++=======
+ static bool acpi_fan_is_acpi4(struct acpi_device *device)
+ {
+ 	return acpi_has_method(device->handle, "_FIF") &&
+ 	       acpi_has_method(device->handle, "_FPS") &&
+ 	       acpi_has_method(device->handle, "_FSL") &&
+ 	       acpi_has_method(device->handle, "_FST");
+ }
+ 
+ static int acpi_fan_get_fif(struct acpi_device *device)
+ {
+ 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+ 	struct acpi_fan *fan = acpi_driver_data(device);
+ 	struct acpi_buffer format = { sizeof("NNNN"), "NNNN" };
+ 	struct acpi_buffer fif = { sizeof(fan->fif), &fan->fif };
+ 	union acpi_object *obj;
+ 	acpi_status status;
+ 
+ 	status = acpi_evaluate_object(device->handle, "_FIF", NULL, &buffer);
+ 	if (ACPI_FAILURE(status))
+ 		return status;
+ 
+ 	obj = buffer.pointer;
+ 	if (!obj || obj->type != ACPI_TYPE_PACKAGE) {
+ 		dev_err(&device->dev, "Invalid _FIF data\n");
+ 		status = -EINVAL;
+ 		goto err;
+ 	}
+ 
+ 	status = acpi_extract_package(obj, &format, &fif);
+ 	if (ACPI_FAILURE(status)) {
+ 		dev_err(&device->dev, "Invalid _FIF element\n");
+ 		status = -EINVAL;
+ 	}
+ 
+ err:
+ 	kfree(obj);
+ 	return status;
+ }
+ 
+ static int acpi_fan_speed_cmp(const void *a, const void *b)
+ {
+ 	const struct acpi_fan_fps *fps1 = a;
+ 	const struct acpi_fan_fps *fps2 = b;
+ 	return fps1->speed - fps2->speed;
+ }
+ 
+ static int acpi_fan_get_fps(struct acpi_device *device)
+ {
+ 	struct acpi_fan *fan = acpi_driver_data(device);
+ 	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+ 	union acpi_object *obj;
+ 	acpi_status status;
+ 	int i;
+ 
+ 	status = acpi_evaluate_object(device->handle, "_FPS", NULL, &buffer);
+ 	if (ACPI_FAILURE(status))
+ 		return status;
+ 
+ 	obj = buffer.pointer;
+ 	if (!obj || obj->type != ACPI_TYPE_PACKAGE || obj->package.count < 2) {
+ 		dev_err(&device->dev, "Invalid _FPS data\n");
+ 		status = -EINVAL;
+ 		goto err;
+ 	}
+ 
+ 	fan->fps_count = obj->package.count - 1; /* minus revision field */
+ 	fan->fps = devm_kzalloc(&device->dev,
+ 				fan->fps_count * sizeof(struct acpi_fan_fps),
+ 				GFP_KERNEL);
+ 	if (!fan->fps) {
+ 		dev_err(&device->dev, "Not enough memory\n");
+ 		status = -ENOMEM;
+ 		goto err;
+ 	}
+ 	for (i = 0; i < fan->fps_count; i++) {
+ 		struct acpi_buffer format = { sizeof("NNNNN"), "NNNNN" };
+ 		struct acpi_buffer fps = { sizeof(fan->fps[i]), &fan->fps[i] };
+ 		status = acpi_extract_package(&obj->package.elements[i + 1],
+ 					      &format, &fps);
+ 		if (ACPI_FAILURE(status)) {
+ 			dev_err(&device->dev, "Invalid _FPS element\n");
+ 			break;
+ 		}
+ 	}
+ 
+ 	/* sort the state array according to fan speed in increase order */
+ 	sort(fan->fps, fan->fps_count, sizeof(*fan->fps),
+ 	     acpi_fan_speed_cmp, NULL);
+ 
+ err:
+ 	kfree(obj);
+ 	return status;
+ }
+ 
+ static int acpi_fan_probe(struct platform_device *pdev)
+ {
+ 	int result = 0;
+ 	struct thermal_cooling_device *cdev;
+ 	struct acpi_fan *fan;
+ 	struct acpi_device *device = ACPI_COMPANION(&pdev->dev);
+ 
+ 	fan = devm_kzalloc(&pdev->dev, sizeof(*fan), GFP_KERNEL);
+ 	if (!fan) {
+ 		dev_err(&device->dev, "No memory for fan\n");
+ 		return -ENOMEM;
+ 	}
+ 	device->driver_data = fan;
+ 	platform_set_drvdata(pdev, fan);
+ 
+ 	if (acpi_fan_is_acpi4(device)) {
+ 		if (acpi_fan_get_fif(device) || acpi_fan_get_fps(device))
+ 			goto end;
+ 		fan->acpi4 = true;
+ 	} else {
+ 		result = acpi_device_update_power(device, NULL);
+ 		if (result) {
+ 			dev_err(&device->dev, "Setting initial power state\n");
+ 			goto end;
+ 		}
++>>>>>>> 9519a6356cbf (ACPI / Fan: add ACPI 4.0 style fan support)
  	}
  
  	cdev = thermal_cooling_device_register("Fan", device,
@@@ -152,10 -351,10 +391,15 @@@
  		goto end;
  	}
  
 -	dev_dbg(&pdev->dev, "registered as cooling_device%d\n", cdev->id);
 +	dev_dbg(&device->dev, "registered as cooling_device%d\n", cdev->id);
  
++<<<<<<< HEAD
 +	device->driver_data = cdev;
 +	result = sysfs_create_link(&device->dev.kobj,
++=======
+ 	fan->cdev = cdev;
+ 	result = sysfs_create_link(&pdev->dev.kobj,
++>>>>>>> 9519a6356cbf (ACPI / Fan: add ACPI 4.0 style fan support)
  				   &cdev->device.kobj,
  				   "thermal_cooling");
  	if (result)
@@@ -163,27 -362,23 +407,39 @@@
  			"'thermal_cooling'\n");
  
  	result = sysfs_create_link(&cdev->device.kobj,
 -				   &pdev->dev.kobj,
 +				   &device->dev.kobj,
  				   "device");
  	if (result)
 -		dev_err(&pdev->dev, "Failed to create sysfs link "
 +		dev_err(&device->dev, "Failed to create sysfs link "
  			"'device'\n");
  
++<<<<<<< HEAD
 +	printk(KERN_INFO PREFIX "%s [%s] (%s)\n",
 +	       acpi_device_name(device), acpi_device_bid(device),
 +	       !device->power.state ? "on" : "off");
 +
 +      end:
++=======
+ end:
++>>>>>>> 9519a6356cbf (ACPI / Fan: add ACPI 4.0 style fan support)
  	return result;
  }
  
 -static int acpi_fan_remove(struct platform_device *pdev)
 +static int acpi_fan_remove(struct acpi_device *device)
  {
++<<<<<<< HEAD
 +	struct thermal_cooling_device *cdev = acpi_driver_data(device);
 +
 +	sysfs_remove_link(&device->dev.kobj, "thermal_cooling");
 +	sysfs_remove_link(&cdev->device.kobj, "device");
 +	thermal_cooling_device_unregister(cdev);
++=======
+ 	struct acpi_fan *fan = platform_get_drvdata(pdev);
+ 
+ 	sysfs_remove_link(&pdev->dev.kobj, "thermal_cooling");
+ 	sysfs_remove_link(&fan->cdev->device.kobj, "device");
+ 	thermal_cooling_device_unregister(fan->cdev);
++>>>>>>> 9519a6356cbf (ACPI / Fan: add ACPI 4.0 style fan support)
  
  	return 0;
  }
@@@ -191,7 -386,11 +447,15 @@@
  #ifdef CONFIG_PM_SLEEP
  static int acpi_fan_suspend(struct device *dev)
  {
++<<<<<<< HEAD
 +	acpi_device_set_power(to_acpi_device(dev), ACPI_STATE_D0);
++=======
+ 	struct acpi_fan *fan = dev_get_drvdata(dev);
+ 	if (fan->acpi4)
+ 		return 0;
+ 
+ 	acpi_device_set_power(ACPI_COMPANION(dev), ACPI_STATE_D0);
++>>>>>>> 9519a6356cbf (ACPI / Fan: add ACPI 4.0 style fan support)
  
  	return AE_OK;
  }
@@@ -199,10 -398,14 +463,14 @@@
  static int acpi_fan_resume(struct device *dev)
  {
  	int result;
+ 	struct acpi_fan *fan = dev_get_drvdata(dev);
+ 
+ 	if (fan->acpi4)
+ 		return 0;
  
 -	result = acpi_device_update_power(ACPI_COMPANION(dev), NULL);
 +	result = acpi_device_update_power(to_acpi_device(dev), NULL);
  	if (result)
 -		dev_err(dev, "Error updating fan power state\n");
 +		printk(KERN_ERR PREFIX "Error updating fan power state\n");
  
  	return result;
  }
* Unmerged path drivers/acpi/fan.c
