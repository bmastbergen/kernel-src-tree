kvm,rcu,nohz: use RCU extended quiescent state when running KVM guest

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kernel] kvm: rcu: nohz: use RCU extended quiescent state when running KVM guest (Rik van Riel) [1194681]
Rebuild_FUZZ: 95.71%
commit-author Rik van Riel <riel@redhat.com>
commit 126a6a542446f1a49b9f3c69237c87df3eb4e6e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/126a6a54.failed

The host kernel is not doing anything while the CPU is executing
a KVM guest VCPU, so it can be marked as being in an extended
quiescent state, identical to that used when running user space
code.

The only exception to that rule is when the host handles an
interrupt, which is already handled by the irq code, which
calls rcu_irq_enter and rcu_irq_exit.

The guest_enter and guest_exit functions already switch vtime
accounting independent of context tracking. Leave those calls
where they are, instead of moving them into the context tracking
code.

	Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Signed-off-by: Rik van Riel <riel@redhat.com>
	Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Will deacon <will.deacon@arm.com>
	Cc: Marcelo Tosatti <mtosatti@redhat.com>
	Cc: Christian Borntraeger <borntraeger@de.ibm.com>
	Cc: Luiz Capitulino <lcapitulino@redhat.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
(cherry picked from commit 126a6a542446f1a49b9f3c69237c87df3eb4e6e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/context_tracking_state.h
diff --cc include/linux/context_tracking_state.h
index 72ab10fe1e46,6b7b96a32b75..000000000000
--- a/include/linux/context_tracking_state.h
+++ b/include/linux/context_tracking_state.h
@@@ -13,8 -13,9 +13,14 @@@ struct context_tracking 
  	 */
  	bool active;
  	enum ctx_state {
++<<<<<<< HEAD
 +		IN_KERNEL = 0,
 +		IN_USER,
++=======
+ 		CONTEXT_KERNEL = 0,
+ 		CONTEXT_USER,
+ 		CONTEXT_GUEST,
++>>>>>>> 126a6a542446 (kvm,rcu,nohz: use RCU extended quiescent state when running KVM guest)
  	} state;
  };
  
diff --git a/include/linux/context_tracking.h b/include/linux/context_tracking.h
index 37b81bd51ec0..81440cee8619 100644
--- a/include/linux/context_tracking.h
+++ b/include/linux/context_tracking.h
@@ -78,10 +78,16 @@ static inline void guest_enter(void)
 		vtime_guest_enter(current);
 	else
 		current->flags |= PF_VCPU;
+
+	if (context_tracking_is_enabled())
+		context_tracking_enter(CONTEXT_GUEST);
 }
 
 static inline void guest_exit(void)
 {
+	if (context_tracking_is_enabled())
+		context_tracking_exit(CONTEXT_GUEST);
+
 	if (vtime_accounting_enabled())
 		vtime_guest_exit(current);
 	else
* Unmerged path include/linux/context_tracking_state.h
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index 9be71a00c996..a0a9ca34b15e 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -791,7 +791,8 @@ static inline void kvm_guest_enter(void)
 	 * one time slice). Lets treat guest mode as quiescent state, just like
 	 * we do with user-mode execution.
 	 */
-	rcu_virt_note_context_switch(smp_processor_id());
+	if (!context_tracking_cpu_is_enabled())
+		rcu_virt_note_context_switch(smp_processor_id());
 }
 
 static inline void kvm_guest_exit(void)
