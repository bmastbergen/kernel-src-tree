bonding: rework rlb_next_rx_slave() to use bond_for_each_slave()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@redhat.com>
commit 6475ae4ceea2f430db1daabf6460a9f36bc97438
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6475ae4c.failed

Currently, we're using bond_for_each_slave_from(), which is really hard to
implement under RCU and/or neighbour list.

Remove it and use bond_for_each_slave() instead, taking care of the last
used slave.

Also, rename next_rx_slave to rx_slave and store the current (last)
rx_slave.

CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6475ae4ceea2f430db1daabf6460a9f36bc97438)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_alb.c
diff --cc drivers/net/bonding/bond_alb.c
index b7563cd17726,c5b85ad5554d..000000000000
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@@ -383,30 -383,31 +383,51 @@@ out
  static struct slave *rlb_next_rx_slave(struct bonding *bond)
  {
  	struct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));
- 	struct slave *rx_slave, *slave, *start_at;
- 	int i = 0;
+ 	struct slave *before = NULL, *rx_slave = NULL, *slave;
+ 	struct list_head *iter;
+ 	bool found = false;
  
++<<<<<<< HEAD
 +	if (bond_info->next_rx_slave) {
 +		start_at = bond_info->next_rx_slave;
 +	} else {
 +		start_at = bond->first_slave;
 +	}
 +
 +	rx_slave = NULL;
 +
 +	bond_for_each_slave_from(bond, slave, i, start_at) {
 +		if (SLAVE_IS_OK(slave)) {
 +			if (!rx_slave) {
++=======
+ 	bond_for_each_slave(bond, slave, iter) {
+ 		if (!SLAVE_IS_OK(slave))
+ 			continue;
+ 		if (!found) {
+ 			if (!before || before->speed < slave->speed)
+ 				before = slave;
+ 		} else {
+ 			if (!rx_slave || rx_slave->speed < slave->speed)
++>>>>>>> 6475ae4ceea2 (bonding: rework rlb_next_rx_slave() to use bond_for_each_slave())
  				rx_slave = slave;
- 			} else if (slave->speed > rx_slave->speed) {
- 				rx_slave = slave;
- 			}
  		}
+ 		if (slave == bond_info->rx_slave)
+ 			found = true;
  	}
+ 	/* we didn't find anything after the current or we have something
+ 	 * better before and up to the current slave
+ 	 */
+ 	if (!rx_slave || (before && rx_slave->speed < before->speed))
+ 		rx_slave = before;
  
++<<<<<<< HEAD
 +	if (rx_slave) {
 +		bond_info->next_rx_slave = rx_slave->next;
 +	}
++=======
+ 	if (rx_slave)
+ 		bond_info->rx_slave = rx_slave;
++>>>>>>> 6475ae4ceea2 (bonding: rework rlb_next_rx_slave() to use bond_for_each_slave())
  
  	return rx_slave;
  }
* Unmerged path drivers/net/bonding/bond_alb.c
diff --git a/drivers/net/bonding/bond_alb.h b/drivers/net/bonding/bond_alb.h
index 1dfbe69caad3..4003dec9a7d1 100644
--- a/drivers/net/bonding/bond_alb.h
+++ b/drivers/net/bonding/bond_alb.h
@@ -154,9 +154,7 @@ struct alb_bond_info {
 	u8			rx_ntt;	/* flag - need to transmit
 					 * to all rx clients
 					 */
-	struct slave		*next_rx_slave;/* next slave to be assigned
-						* to a new rx client for
-						*/
+	struct slave		*rx_slave;/* last slave to xmit from */
 	u8			primary_is_promisc;	   /* boolean */
 	u32			rlb_promisc_timeout_counter;/* counts primary
 							     * promiscuity time
