xfs: correct error sign on COLLAPSE_RANGE errors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 65149e3fab7f053396d09a429085f3071fa50825
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/65149e3f.failed

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Jie Liu <jeff.liu@oracle.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 65149e3fab7f053396d09a429085f3071fa50825)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_file.c
diff --cc fs/xfs/xfs_file.c
index ca62368780a0,830c1c937b88..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -864,6 -833,28 +864,31 @@@ xfs_file_fallocate
  		error = xfs_free_file_space(ip, offset, len);
  		if (error)
  			goto out_unlock;
++<<<<<<< HEAD
++=======
+ 	} else if (mode & FALLOC_FL_COLLAPSE_RANGE) {
+ 		unsigned blksize_mask = (1 << inode->i_blkbits) - 1;
+ 
+ 		if (offset & blksize_mask || len & blksize_mask) {
+ 			error = EINVAL;
+ 			goto out_unlock;
+ 		}
+ 
+ 		/*
+ 		 * There is no need to overlap collapse range with EOF,
+ 		 * in which case it is effectively a truncate operation
+ 		 */
+ 		if (offset + len >= i_size_read(inode)) {
+ 			error = EINVAL;
+ 			goto out_unlock;
+ 		}
+ 
+ 		new_size = i_size_read(inode) - len;
+ 
+ 		error = xfs_collapse_file_space(ip, offset, len);
+ 		if (error)
+ 			goto out_unlock;
++>>>>>>> 65149e3fab7f (xfs: correct error sign on COLLAPSE_RANGE errors)
  	} else {
  		if (!(mode & FALLOC_FL_KEEP_SIZE) &&
  		    offset + len > i_size_read(inode)) {
* Unmerged path fs/xfs/xfs_file.c
