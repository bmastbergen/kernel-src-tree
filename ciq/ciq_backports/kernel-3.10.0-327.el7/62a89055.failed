net/mlx4_en: Support ndo_get_vf_stats

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4_en: Support ndo_get_vf_stats (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 94.29%
commit-author Eran Ben Elisha <eranbe@mellanox.com>
commit 62a890557f57e6cbebe9cc6c32aef045405d4fa2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/62a89055.failed

Implement the ndo to gather VF statistics through the PF.

All counters related to this VF are stored in a per slave
list, run over the slave's list and collect all statistics.

	Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
	Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 62a890557f57e6cbebe9cc6c32aef045405d4fa2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/cmd.c
#	include/linux/mlx4/cmd.h
diff --cc drivers/net/ethernet/mellanox/mlx4/cmd.c
index 50870bc73db8,82040137d7d9..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx4/cmd.c
@@@ -2735,6 -3167,92 +2735,95 @@@ int mlx4_set_vf_link_state(struct mlx4_
  }
  EXPORT_SYMBOL_GPL(mlx4_set_vf_link_state);
  
++<<<<<<< HEAD
++=======
+ int mlx4_get_counter_stats(struct mlx4_dev *dev, int counter_index,
+ 			   struct mlx4_counter *counter_stats, int reset)
+ {
+ 	struct mlx4_cmd_mailbox *mailbox = NULL;
+ 	struct mlx4_counter *tmp_counter;
+ 	int err;
+ 	u32 if_stat_in_mod;
+ 
+ 	if (!counter_stats)
+ 		return -EINVAL;
+ 
+ 	if (counter_index == MLX4_SINK_COUNTER_INDEX(dev))
+ 		return 0;
+ 
+ 	mailbox = mlx4_alloc_cmd_mailbox(dev);
+ 	if (IS_ERR(mailbox))
+ 		return PTR_ERR(mailbox);
+ 
+ 	memset(mailbox->buf, 0, sizeof(struct mlx4_counter));
+ 	if_stat_in_mod = counter_index;
+ 	if (reset)
+ 		if_stat_in_mod |= MLX4_QUERY_IF_STAT_RESET;
+ 	err = mlx4_cmd_box(dev, 0, mailbox->dma,
+ 			   if_stat_in_mod, 0,
+ 			   MLX4_CMD_QUERY_IF_STAT,
+ 			   MLX4_CMD_TIME_CLASS_C,
+ 			   MLX4_CMD_NATIVE);
+ 	if (err) {
+ 		mlx4_dbg(dev, "%s: failed to read statistics for counter index %d\n",
+ 			 __func__, counter_index);
+ 		goto if_stat_out;
+ 	}
+ 	tmp_counter = (struct mlx4_counter *)mailbox->buf;
+ 	counter_stats->counter_mode = tmp_counter->counter_mode;
+ 	if (counter_stats->counter_mode == 0) {
+ 		counter_stats->rx_frames =
+ 			cpu_to_be64(be64_to_cpu(counter_stats->rx_frames) +
+ 				    be64_to_cpu(tmp_counter->rx_frames));
+ 		counter_stats->tx_frames =
+ 			cpu_to_be64(be64_to_cpu(counter_stats->tx_frames) +
+ 				    be64_to_cpu(tmp_counter->tx_frames));
+ 		counter_stats->rx_bytes =
+ 			cpu_to_be64(be64_to_cpu(counter_stats->rx_bytes) +
+ 				    be64_to_cpu(tmp_counter->rx_bytes));
+ 		counter_stats->tx_bytes =
+ 			cpu_to_be64(be64_to_cpu(counter_stats->tx_bytes) +
+ 				    be64_to_cpu(tmp_counter->tx_bytes));
+ 	}
+ 
+ if_stat_out:
+ 	mlx4_free_cmd_mailbox(dev, mailbox);
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(mlx4_get_counter_stats);
+ 
+ int mlx4_get_vf_stats(struct mlx4_dev *dev, int port, int vf_idx,
+ 		      struct ifla_vf_stats *vf_stats)
+ {
+ 	struct mlx4_counter tmp_vf_stats;
+ 	int slave;
+ 	int err = 0;
+ 
+ 	if (!vf_stats)
+ 		return -EINVAL;
+ 
+ 	if (!mlx4_is_master(dev))
+ 		return -EPROTONOSUPPORT;
+ 
+ 	slave = mlx4_get_slave_indx(dev, vf_idx);
+ 	if (slave < 0)
+ 		return -EINVAL;
+ 
+ 	port = mlx4_slaves_closest_port(dev, slave, port);
+ 	err = mlx4_calc_vf_counters(dev, slave, port, &tmp_vf_stats);
+ 	if (!err && tmp_vf_stats.counter_mode == 0) {
+ 		vf_stats->rx_packets = be64_to_cpu(tmp_vf_stats.rx_frames);
+ 		vf_stats->tx_packets = be64_to_cpu(tmp_vf_stats.tx_frames);
+ 		vf_stats->rx_bytes = be64_to_cpu(tmp_vf_stats.rx_bytes);
+ 		vf_stats->tx_bytes = be64_to_cpu(tmp_vf_stats.tx_bytes);
+ 	}
+ 
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(mlx4_get_vf_stats);
+ 
++>>>>>>> 62a890557f57 (net/mlx4_en: Support ndo_get_vf_stats)
  int mlx4_vf_smi_enabled(struct mlx4_dev *dev, int slave, int port)
  {
  	struct mlx4_priv *priv = mlx4_priv(dev);
diff --cc include/linux/mlx4/cmd.h
index 0aa19a3dabb9,58391f2e0414..000000000000
--- a/include/linux/mlx4/cmd.h
+++ b/include/linux/mlx4/cmd.h
@@@ -35,6 -35,8 +35,11 @@@
  
  #include <linux/dma-mapping.h>
  #include <linux/if_link.h>
++<<<<<<< HEAD
++=======
+ #include <linux/mlx4/device.h>
+ #include <linux/netdevice.h>
++>>>>>>> 62a890557f57 (net/mlx4_en: Support ndo_get_vf_stats)
  
  enum {
  	/* initialization and general commands */
@@@ -279,6 -302,10 +284,13 @@@ static inline int mlx4_cmd_imm(struct m
  struct mlx4_cmd_mailbox *mlx4_alloc_cmd_mailbox(struct mlx4_dev *dev);
  void mlx4_free_cmd_mailbox(struct mlx4_dev *dev, struct mlx4_cmd_mailbox *mailbox);
  
++<<<<<<< HEAD
++=======
+ int mlx4_get_counter_stats(struct mlx4_dev *dev, int counter_index,
+ 			   struct mlx4_counter *counter_stats, int reset);
+ int mlx4_get_vf_stats(struct mlx4_dev *dev, int port, int vf_idx,
+ 		      struct ifla_vf_stats *vf_stats);
++>>>>>>> 62a890557f57 (net/mlx4_en: Support ndo_get_vf_stats)
  u32 mlx4_comm_get_version(void);
  int mlx4_set_vf_mac(struct mlx4_dev *dev, int port, int vf, u64 mac);
  int mlx4_set_vf_vlan(struct mlx4_dev *dev, int port, int vf, u16 vlan, u8 qos);
* Unmerged path drivers/net/ethernet/mellanox/mlx4/cmd.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 9a988b45c844..ca1617ee0d5f 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -2264,6 +2264,15 @@ static int mlx4_en_set_vf_link_state(struct net_device *dev, int vf, int link_st
 	return mlx4_set_vf_link_state(mdev->dev, en_priv->port, vf, link_state);
 }
 
+static int mlx4_en_get_vf_stats(struct net_device *dev, int vf,
+				struct ifla_vf_stats *vf_stats)
+{
+	struct mlx4_en_priv *en_priv = netdev_priv(dev);
+	struct mlx4_en_dev *mdev = en_priv->mdev;
+
+	return mlx4_get_vf_stats(mdev->dev, en_priv->port, vf, vf_stats);
+}
+
 #define PORT_ID_BYTE_LEN 8
 static int mlx4_en_get_phys_port_id(struct net_device *dev,
 				    struct netdev_phys_port_id *ppid)
@@ -2429,6 +2438,7 @@ static const struct net_device_ops mlx4_netdev_ops_master = {
 	.ndo_set_vf_vlan	= mlx4_en_set_vf_vlan,
 	.ndo_set_vf_spoofchk	= mlx4_en_set_vf_spoofchk,
 	.ndo_set_vf_link_state	= mlx4_en_set_vf_link_state,
+	.ndo_get_vf_stats       = mlx4_en_get_vf_stats,
 	.ndo_get_vf_config	= mlx4_en_get_vf_config,
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller	= mlx4_en_netpoll,
diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4.h b/drivers/net/ethernet/mellanox/mlx4/mlx4.h
index cd5c0ac55f20..dd43caf66b45 100644
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4.h
@@ -989,6 +989,8 @@ int __mlx4_write_mtt(struct mlx4_dev *dev, struct mlx4_mtt *mtt,
 		     int start_index, int npages, u64 *page_list);
 int __mlx4_counter_alloc(struct mlx4_dev *dev, u32 *idx);
 void __mlx4_counter_free(struct mlx4_dev *dev, u32 idx);
+int mlx4_calc_vf_counters(struct mlx4_dev *dev, int slave, int port,
+			  struct mlx4_counter *data);
 int __mlx4_xrcd_alloc(struct mlx4_dev *dev, u32 *xrcdn);
 void __mlx4_xrcd_free(struct mlx4_dev *dev, u32 xrcdn);
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
index efe0385e079d..cca4e3604225 100644
--- a/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
+++ b/drivers/net/ethernet/mellanox/mlx4/resource_tracker.c
@@ -46,6 +46,7 @@
 
 #include "mlx4.h"
 #include "fw.h"
+#include "mlx4_stats.h"
 
 #define MLX4_MAC_VALID		(1ull << 63)
 
@@ -1112,6 +1113,53 @@ static struct res_common *alloc_tr(u64 id, enum mlx4_resource type, int slave,
 	return ret;
 }
 
+int mlx4_calc_vf_counters(struct mlx4_dev *dev, int slave, int port,
+			  struct mlx4_counter *data)
+{
+	struct mlx4_priv *priv = mlx4_priv(dev);
+	struct mlx4_resource_tracker *tracker = &priv->mfunc.master.res_tracker;
+	struct res_common *tmp;
+	struct res_counter *counter;
+	int *counters_arr;
+	int i = 0, err = 0;
+
+	memset(data, 0, sizeof(*data));
+
+	counters_arr = kmalloc_array(dev->caps.max_counters,
+				     sizeof(*counters_arr), GFP_KERNEL);
+	if (!counters_arr)
+		return -ENOMEM;
+
+	spin_lock_irq(mlx4_tlock(dev));
+	list_for_each_entry(tmp,
+			    &tracker->slave_list[slave].res_list[RES_COUNTER],
+			    list) {
+		counter = container_of(tmp, struct res_counter, com);
+		if (counter->port == port) {
+			counters_arr[i] = (int)tmp->res_id;
+			i++;
+		}
+	}
+	spin_unlock_irq(mlx4_tlock(dev));
+	counters_arr[i] = -1;
+
+	i = 0;
+
+	while (counters_arr[i] != -1) {
+		err = mlx4_get_counter_stats(dev, counters_arr[i], data,
+					     0);
+		if (err) {
+			memset(data, 0, sizeof(*data));
+			goto table_changed;
+		}
+		i++;
+	}
+
+table_changed:
+	kfree(counters_arr);
+	return 0;
+}
+
 static int add_res_range(struct mlx4_dev *dev, int slave, u64 base, int count,
 			 enum mlx4_resource type, int extra)
 {
* Unmerged path include/linux/mlx4/cmd.h
