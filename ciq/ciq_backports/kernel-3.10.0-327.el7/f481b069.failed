KVM: implement multiple address spaces

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kvm] implement multiple address spaces (Paolo Bonzini) [1202825]
Rebuild_FUZZ: 92.96%
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit f481b069e674378758c73761827e83ab05c46b52
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f481b069.failed

Only two ioctls have to be modified; the address space id is
placed in the higher 16 bits of their slot id argument.

As of this patch, no architecture defines more than one
address space; x86 will be the first.

	Reviewed-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit f481b069e674378758c73761827e83ab05c46b52)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kvm_host.h
#	include/uapi/linux/kvm.h
#	virt/kvm/kvm_main.c
diff --cc include/linux/kvm_host.h
index 9984ea276f63,9564fd78c547..000000000000
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@@ -466,6 -482,18 +477,21 @@@ static inline struct kvm_memslots *__kv
  			|| lockdep_is_held(&kvm->slots_lock));
  }
  
++<<<<<<< HEAD
++=======
+ static inline struct kvm_memslots *kvm_memslots(struct kvm *kvm)
+ {
+ 	return __kvm_memslots(kvm, 0);
+ }
+ 
+ static inline struct kvm_memslots *kvm_vcpu_memslots(struct kvm_vcpu *vcpu)
+ {
+ 	int as_id = kvm_arch_vcpu_memslots_id(vcpu);
+ 
+ 	return __kvm_memslots(vcpu->kvm, as_id);
+ }
+ 
++>>>>>>> f481b069e674 (KVM: implement multiple address spaces)
  static inline struct kvm_memory_slot *
  id_to_memslot(struct kvm_memslots *slots, int id)
  {
diff --cc include/uapi/linux/kvm.h
index 7d851dae2791,5ff1038437e3..000000000000
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@@ -665,9 -797,26 +665,26 @@@ struct kvm_ppc_smmu_info 
  #define KVM_CAP_HYPERV_TIME 96
  #define KVM_CAP_IOAPIC_POLARITY_IGNORED 97
  #define KVM_CAP_ENABLE_CAP_VM 98
 -#define KVM_CAP_S390_IRQCHIP 99
  #define KVM_CAP_IOEVENTFD_NO_LENGTH 100
 -#define KVM_CAP_VM_ATTRIBUTES 101
 -#define KVM_CAP_ARM_PSCI_0_2 102
  #define KVM_CAP_PPC_FIXUP_HCALL 103
  #define KVM_CAP_PPC_ENABLE_HCALL 104
++<<<<<<< HEAD
++=======
+ #define KVM_CAP_CHECK_EXTENSION_VM 105
+ #define KVM_CAP_S390_USER_SIGP 106
+ #define KVM_CAP_S390_VECTOR_REGISTERS 107
+ #define KVM_CAP_S390_MEM_OP 108
+ #define KVM_CAP_S390_USER_STSI 109
+ #define KVM_CAP_S390_SKEYS 110
+ #define KVM_CAP_MIPS_FPU 111
+ #define KVM_CAP_MIPS_MSA 112
+ #define KVM_CAP_S390_INJECT_IRQ 113
+ #define KVM_CAP_S390_IRQ_STATE 114
+ #define KVM_CAP_PPC_HWRNG 115
+ #define KVM_CAP_DISABLE_QUIRKS 116
+ #define KVM_CAP_X86_SMM 117
+ #define KVM_CAP_MULTI_ADDRESS_SPACE 118
++>>>>>>> f481b069e674 (KVM: implement multiple address spaces)
  
  #ifdef KVM_CAP_IRQ_ROUTING
  
diff --cc virt/kvm/kvm_main.c
index 9c5b960f56f6,848af90b8091..000000000000
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@@ -727,9 -733,9 +731,13 @@@ static int check_memory_region_flags(st
  }
  
  static struct kvm_memslots *install_new_memslots(struct kvm *kvm,
- 		struct kvm_memslots *slots)
+ 		int as_id, struct kvm_memslots *slots)
  {
++<<<<<<< HEAD
 +	struct kvm_memslots *old_memslots = kvm->memslots;
++=======
+ 	struct kvm_memslots *old_memslots = __kvm_memslots(kvm, as_id);
++>>>>>>> f481b069e674 (KVM: implement multiple address spaces)
  
  	/*
  	 * Set the low bit in the generation, which disables SPTE caching
@@@ -794,19 -804,16 +806,23 @@@ int __kvm_set_memory_region(struct kvm 
  	if (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)
  		goto out;
  
++<<<<<<< HEAD
 +	slot = id_to_memslot(kvm->memslots, mem->slot);
++=======
+ 	slot = id_to_memslot(__kvm_memslots(kvm, as_id), id);
++>>>>>>> f481b069e674 (KVM: implement multiple address spaces)
  	base_gfn = mem->guest_phys_addr >> PAGE_SHIFT;
  	npages = mem->memory_size >> PAGE_SHIFT;
  
  	if (npages > KVM_MEM_MAX_NR_PAGES)
  		goto out;
  
 +	if (!npages)
 +		mem->flags &= ~KVM_MEM_LOG_DIRTY_PAGES;
 +
  	new = old = *slot;
  
- 	new.id = mem->slot;
+ 	new.id = id;
  	new.base_gfn = base_gfn;
  	new.npages = npages;
  	new.flags = mem->flags;
@@@ -837,9 -848,9 +853,13 @@@
  	if ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {
  		/* Check for overlaps */
  		r = -EEXIST;
++<<<<<<< HEAD
 +		kvm_for_each_memslot(slot, kvm->memslots) {
++=======
+ 		kvm_for_each_memslot(slot, __kvm_memslots(kvm, as_id)) {
++>>>>>>> f481b069e674 (KVM: implement multiple address spaces)
  			if ((slot->id >= KVM_USER_MEM_SLOTS) ||
- 			    (slot->id == mem->slot))
+ 			    (slot->id == id))
  				continue;
  			if (!((base_gfn + npages <= slot->base_gfn) ||
  			      (base_gfn >= slot->base_gfn + slot->npages)))
@@@ -868,13 -879,13 +888,17 @@@
  	slots = kvm_kvzalloc(sizeof(struct kvm_memslots));
  	if (!slots)
  		goto out_free;
++<<<<<<< HEAD
 +	memcpy(slots, kvm->memslots, sizeof(struct kvm_memslots));
++=======
+ 	memcpy(slots, __kvm_memslots(kvm, as_id), sizeof(struct kvm_memslots));
++>>>>>>> f481b069e674 (KVM: implement multiple address spaces)
  
  	if ((change == KVM_MR_DELETE) || (change == KVM_MR_MOVE)) {
- 		slot = id_to_memslot(slots, mem->slot);
+ 		slot = id_to_memslot(slots, id);
  		slot->flags |= KVM_MEMSLOT_INVALID;
  
- 		old_memslots = install_new_memslots(kvm, slots);
+ 		old_memslots = install_new_memslots(kvm, as_id, slots);
  
  		/* slot was deleted or moved, clear iommu mapping */
  		kvm_iommu_unmap_pages(kvm, &old);
@@@ -906,9 -917,9 +930,9 @@@
  	}
  
  	update_memslots(slots, &new);
- 	old_memslots = install_new_memslots(kvm, slots);
+ 	old_memslots = install_new_memslots(kvm, as_id, slots);
  
 -	kvm_arch_commit_memory_region(kvm, mem, &old, &new, change);
 +	kvm_arch_commit_memory_region(kvm, mem, &old, change);
  
  	kvm_free_memslot(kvm, &old, &new);
  	kvfree(old_memslots);
@@@ -953,24 -964,29 +977,31 @@@ EXPORT_SYMBOL_GPL(kvm_set_memory_region
  static int kvm_vm_ioctl_set_memory_region(struct kvm *kvm,
  					  struct kvm_userspace_memory_region *mem)
  {
- 	if (mem->slot >= KVM_USER_MEM_SLOTS)
+ 	if ((u16)mem->slot >= KVM_USER_MEM_SLOTS)
  		return -EINVAL;
 -
  	return kvm_set_memory_region(kvm, mem);
  }
  
  int kvm_get_dirty_log(struct kvm *kvm,
  			struct kvm_dirty_log *log, int *is_dirty)
  {
 -	struct kvm_memslots *slots;
  	struct kvm_memory_slot *memslot;
- 	int r, i;
+ 	int r, i, as_id, id;
  	unsigned long n;
  	unsigned long any = 0;
  
  	r = -EINVAL;
- 	if (log->slot >= KVM_USER_MEM_SLOTS)
+ 	as_id = log->slot >> 16;
+ 	id = (u16)log->slot;
+ 	if (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)
  		goto out;
  
++<<<<<<< HEAD
 +	memslot = id_to_memslot(kvm->memslots, log->slot);
++=======
+ 	slots = __kvm_memslots(kvm, as_id);
+ 	memslot = id_to_memslot(slots, id);
++>>>>>>> f481b069e674 (KVM: implement multiple address spaces)
  	r = -ENOENT;
  	if (!memslot->dirty_bitmap)
  		goto out;
@@@ -1019,17 -1035,21 +1050,24 @@@ EXPORT_SYMBOL_GPL(kvm_get_dirty_log)
  int kvm_get_dirty_log_protect(struct kvm *kvm,
  			struct kvm_dirty_log *log, bool *is_dirty)
  {
 -	struct kvm_memslots *slots;
  	struct kvm_memory_slot *memslot;
- 	int r, i;
+ 	int r, i, as_id, id;
  	unsigned long n;
  	unsigned long *dirty_bitmap;
  	unsigned long *dirty_bitmap_buffer;
  
  	r = -EINVAL;
- 	if (log->slot >= KVM_USER_MEM_SLOTS)
+ 	as_id = log->slot >> 16;
+ 	id = (u16)log->slot;
+ 	if (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)
  		goto out;
  
++<<<<<<< HEAD
 +	memslot = id_to_memslot(kvm->memslots, log->slot);
++=======
+ 	slots = __kvm_memslots(kvm, as_id);
+ 	memslot = id_to_memslot(slots, id);
++>>>>>>> f481b069e674 (KVM: implement multiple address spaces)
  
  	dirty_bitmap = memslot->dirty_bitmap;
  	r = -ENOENT;
@@@ -2397,6 -2609,39 +2435,42 @@@ static int kvm_ioctl_create_device(stru
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static long kvm_vm_ioctl_check_extension_generic(struct kvm *kvm, long arg)
+ {
+ 	switch (arg) {
+ 	case KVM_CAP_USER_MEMORY:
+ 	case KVM_CAP_DESTROY_MEMORY_REGION_WORKS:
+ 	case KVM_CAP_JOIN_MEMORY_REGIONS_WORKS:
+ #ifdef CONFIG_KVM_APIC_ARCHITECTURE
+ 	case KVM_CAP_SET_BOOT_CPU_ID:
+ #endif
+ 	case KVM_CAP_INTERNAL_ERROR_DATA:
+ #ifdef CONFIG_HAVE_KVM_MSI
+ 	case KVM_CAP_SIGNAL_MSI:
+ #endif
+ #ifdef CONFIG_HAVE_KVM_IRQFD
+ 	case KVM_CAP_IRQFD:
+ 	case KVM_CAP_IRQFD_RESAMPLE:
+ #endif
+ 	case KVM_CAP_CHECK_EXTENSION_VM:
+ 		return 1;
+ #ifdef CONFIG_HAVE_KVM_IRQ_ROUTING
+ 	case KVM_CAP_IRQ_ROUTING:
+ 		return KVM_MAX_IRQ_ROUTES;
+ #endif
+ #if KVM_ADDRESS_SPACE_NUM > 1
+ 	case KVM_CAP_MULTI_ADDRESS_SPACE:
+ 		return KVM_ADDRESS_SPACE_NUM;
+ #endif
+ 	default:
+ 		break;
+ 	}
+ 	return kvm_vm_ioctl_check_extension(kvm, arg);
+ }
+ 
++>>>>>>> f481b069e674 (KVM: implement multiple address spaces)
  static long kvm_vm_ioctl(struct file *filp,
  			   unsigned int ioctl, unsigned long arg)
  {
diff --git a/Documentation/virtual/kvm/api.txt b/Documentation/virtual/kvm/api.txt
index 63d448f87c08..1e97d2616167 100644
--- a/Documentation/virtual/kvm/api.txt
+++ b/Documentation/virtual/kvm/api.txt
@@ -251,6 +251,11 @@ since the last call to this ioctl.  Bit 0 is the first page in the
 memory slot.  Ensure the entire structure is cleared to avoid padding
 issues.
 
+If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 specifies
+the address space for which you want to return the dirty bitmap.
+They must be less than the value that KVM_CHECK_EXTENSION returns for
+the KVM_CAP_MULTI_ADDRESS_SPACE capability.
+
 
 4.9 KVM_SET_MEMORY_ALIAS
 
@@ -887,6 +892,13 @@ slot.  When changing an existing slot, it may be moved in the guest
 physical memory space, or its flags may be modified.  It may not be
 resized.  Slots may not overlap in guest physical address space.
 
+If KVM_CAP_MULTI_ADDRESS_SPACE is available, bits 16-31 of "slot"
+specifies the address space which is being modified.  They must be
+less than the value that KVM_CHECK_EXTENSION returns for the
+KVM_CAP_MULTI_ADDRESS_SPACE capability.  Slots in separate address spaces
+are unrelated; the restriction on overlapping slots only applies within
+each address space.
+
 Memory for the region is taken starting at the address denoted by the
 field userspace_addr, which must point at user addressable memory for
 the entire memory slot size.  Any object may back this memory, including
diff --git a/arch/powerpc/include/asm/kvm_book3s_64.h b/arch/powerpc/include/asm/kvm_book3s_64.h
index 893b466027eb..e7cedd67c405 100644
--- a/arch/powerpc/include/asm/kvm_book3s_64.h
+++ b/arch/powerpc/include/asm/kvm_book3s_64.h
@@ -411,7 +411,7 @@ static inline void note_hpte_modification(struct kvm *kvm,
  */
 static inline struct kvm_memslots *kvm_memslots_raw(struct kvm *kvm)
 {
-	return rcu_dereference_raw_notrace(kvm->memslots);
+	return rcu_dereference_raw_notrace(kvm->memslots[0]);
 }
 
 #endif /* CONFIG_KVM_BOOK3S_HV_POSSIBLE */
* Unmerged path include/linux/kvm_host.h
* Unmerged path include/uapi/linux/kvm.h
* Unmerged path virt/kvm/kvm_main.c
