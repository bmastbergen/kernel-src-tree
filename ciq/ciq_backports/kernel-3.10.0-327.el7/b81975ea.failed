x86, irq: Clean up irqdomain transition code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [x86] irq: Clean up irqdomain transition code (Steve Best) [1231358]
Rebuild_FUZZ: 93.98%
commit-author Jiang Liu <jiang.liu@linux.intel.com>
commit b81975eade8c6495f3c4d6746d22bdc95f617777
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b81975ea.failed

Now we have completely switched to irqdomain, so clean up transition code
in IOAPIC drivers.

	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Joerg Roedel <joro@8bytes.org>
	Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Grant Likely <grant.likely@linaro.org>
	Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
	Cc: Bjorn Helgaas <bhelgaas@google.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Yinghai Lu <yinghai@kernel.org>
Link: http://lkml.kernel.org/r/1402302011-23642-43-git-send-email-jiang.liu@linux.intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit b81975eade8c6495f3c4d6746d22bdc95f617777)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/apic/io_apic.c
diff --cc arch/x86/kernel/apic/io_apic.c
index 07a33b81b46c,a44dce8cc559..000000000000
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@@ -86,6 -84,17 +86,20 @@@ int sis_apic_bug = -1
  
  static DEFINE_RAW_SPINLOCK(ioapic_lock);
  static DEFINE_RAW_SPINLOCK(vector_lock);
++<<<<<<< HEAD
++=======
+ static DEFINE_MUTEX(ioapic_mutex);
+ static unsigned int ioapic_dynirq_base;
+ static int ioapic_initialized;
+ 
+ struct mp_pin_info {
+ 	int trigger;
+ 	int polarity;
+ 	int node;
+ 	int set;
+ 	u32 count;
+ };
++>>>>>>> b81975eade8c (x86, irq: Clean up irqdomain transition code)
  
  static struct ioapic {
  	/*
@@@ -984,11 -996,94 +998,66 @@@ static int irq_trigger(int idx
  	return trigger;
  }
  
 -static int alloc_irq_from_domain(struct irq_domain *domain, u32 gsi, int pin)
 -{
 -	int irq = -1;
 -	int ioapic = (int)(long)domain->host_data;
 -	int type = ioapics[ioapic].irqdomain_cfg.type;
 -
 -	switch (type) {
 -	case IOAPIC_DOMAIN_LEGACY:
 -		/*
 -		 * Dynamically allocate IRQ number for non-ISA IRQs in the first 16
 -		 * GSIs on some weird platforms.
 -		 */
 -		if (gsi < nr_legacy_irqs())
 -			irq = irq_create_mapping(domain, pin);
 -		else if (irq_create_strict_mappings(domain, gsi, pin, 1) == 0)
 -			irq = gsi;
 -		break;
 -	case IOAPIC_DOMAIN_STRICT:
 -		if (irq_create_strict_mappings(domain, gsi, pin, 1) == 0)
 -			irq = gsi;
 -		break;
 -	case IOAPIC_DOMAIN_DYNAMIC:
 -		irq = irq_create_mapping(domain, pin);
 -		break;
 -	default:
 -		WARN(1, "ioapic: unknown irqdomain type %d\n", type);
 -		break;
 -	}
 -
 -	return irq > 0 ? irq : -1;
 -}
 -
 -static int mp_map_pin_to_irq(u32 gsi, int idx, int ioapic, int pin,
 -			     unsigned int flags)
 +static int pin_2_irq(int idx, int apic, int pin)
  {
  	int irq;
++<<<<<<< HEAD
 +	int bus = mp_irqs[idx].srcbus;
 +	struct mp_ioapic_gsi *gsi_cfg = mp_ioapic_gsi_routing(apic);
++=======
+ 	struct irq_domain *domain = mp_ioapic_irqdomain(ioapic);
+ 	struct mp_pin_info *info = mp_pin_info(ioapic, pin);
+ 
+ 	if (!domain)
+ 		return -1;
+ 
+ 	mutex_lock(&ioapic_mutex);
+ 
+ 	/*
+ 	 * Don't use irqdomain to manage ISA IRQs because there may be
+ 	 * multiple IOAPIC pins sharing the same ISA IRQ number and
+ 	 * irqdomain only supports 1:1 mapping between IOAPIC pin and
+ 	 * IRQ number. A typical IOAPIC has 24 pins, pin 0-15 are used
+ 	 * for legacy IRQs and pin 16-23 are used for PCI IRQs (PIRQ A-H).
+ 	 * When ACPI is disabled, only legacy IRQ numbers (IRQ0-15) are
+ 	 * available, and some BIOSes may use MP Interrupt Source records
+ 	 * to override IRQ numbers for PIRQs instead of reprogramming
+ 	 * the interrupt routing logic. Thus there may be multiple pins
+ 	 * sharing the same legacy IRQ number when ACPI is disabled.
+ 	 */
+ 	if (idx >= 0 && test_bit(mp_irqs[idx].srcbus, mp_bus_not_pci)) {
+ 		irq = mp_irqs[idx].srcbusirq;
+ 		if (flags & IOAPIC_MAP_ALLOC) {
+ 			if (info->count == 0 &&
+ 			    mp_irqdomain_map(domain, irq, pin) != 0)
+ 				irq = -1;
+ 
+ 			/* special handling for timer IRQ0 */
+ 			if (irq == 0)
+ 				info->count++;
+ 		}
+ 	} else {
+ 		irq = irq_find_mapping(domain, pin);
+ 		if (irq <= 0 && (flags & IOAPIC_MAP_ALLOC))
+ 			irq = alloc_irq_from_domain(domain, gsi, pin);
+ 	}
+ 
+ 	if (flags & IOAPIC_MAP_ALLOC) {
+ 		if (irq > 0)
+ 			info->count++;
+ 		else if (info->count == 0)
+ 			info->set = 0;
+ 	}
+ 
+ 	mutex_unlock(&ioapic_mutex);
+ 
+ 	return irq > 0 ? irq : -1;
+ }
+ 
+ static int pin_2_irq(int idx, int ioapic, int pin, unsigned int flags)
+ {
+ 	u32 gsi = mp_pin_to_gsi(ioapic, pin);
++>>>>>>> b81975eade8c (x86, irq: Clean up irqdomain transition code)
  
  	/*
  	 * Debugging check, we are in big trouble if this message pops up!
@@@ -2871,8 -2980,10 +2940,10 @@@ void __init setup_IO_APIC(void
  	sync_Arb_IDs();
  	setup_IO_APIC_irqs();
  	init_IO_APIC_traps();
 -	if (nr_legacy_irqs())
 +	if (legacy_pic->nr_legacy_irqs)
  		check_timer();
+ 
+ 	ioapic_initialized = 1;
  }
  
  /*
@@@ -3423,20 -3457,13 +3494,28 @@@ static int __init io_apic_get_redir_ent
  	return reg_01.bits.entries + 1;
  }
  
 -unsigned int arch_dynirq_lower_bound(unsigned int from)
 +static void __init probe_nr_irqs_gsi(void)
  {
++<<<<<<< HEAD
 +	int nr;
 +
 +	nr = gsi_top + NR_IRQS_LEGACY;
 +	if (nr > nr_irqs_gsi)
 +		nr_irqs_gsi = nr;
 +
 +	printk(KERN_DEBUG "nr_irqs_gsi: %d\n", nr_irqs_gsi);
 +}
 +
 +int get_nr_irqs_gsi(void)
 +{
 +	return nr_irqs_gsi;
++=======
+ 	/*
+ 	 * dmar_alloc_hwirq() may be called before setup_IO_APIC(), so use
+ 	 * gsi_top if ioapic_dynirq_base hasn't been initialized yet.
+ 	 */
+ 	return ioapic_initialized ? ioapic_dynirq_base : gsi_top;
++>>>>>>> b81975eade8c (x86, irq: Clean up irqdomain transition code)
  }
  
  int __init arch_probe_nr_irqs(void)
@@@ -3827,6 -3837,8 +3906,11 @@@ void __init mp_register_ioapic(int id, 
  	ioapics[idx].mp_config.type = MP_IOAPIC;
  	ioapics[idx].mp_config.flags = MPC_APIC_USABLE;
  	ioapics[idx].mp_config.apicaddr = address;
++<<<<<<< HEAD
++=======
+ 	ioapics[idx].irqdomain = NULL;
+ 	ioapics[idx].irqdomain_cfg = *cfg;
++>>>>>>> b81975eade8c (x86, irq: Clean up irqdomain transition code)
  
  	set_fixmap_nocache(FIX_IO_APIC_BASE_0 + idx, address);
  
* Unmerged path arch/x86/kernel/apic/io_apic.c
