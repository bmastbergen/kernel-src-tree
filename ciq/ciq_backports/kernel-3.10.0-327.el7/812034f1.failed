cxgb4: Move ethtool related code to a separate file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit 812034f11628aaaab0e2d7af1d3bc50a49eb396b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/812034f1.failed

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 812034f11628aaaab0e2d7af1d3bc50a49eb396b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/Makefile
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/Makefile
index 1df65c915b99,ace0ab98d0f1..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/Makefile
+++ b/drivers/net/ethernet/chelsio/cxgb4/Makefile
@@@ -4,5 -4,7 +4,9 @@@
  
  obj-$(CONFIG_CHELSIO_T4) += cxgb4.o
  
++<<<<<<< HEAD
 +cxgb4-objs := cxgb4_main.o l2t.o t4_hw.o sge.o
++=======
+ cxgb4-objs := cxgb4_main.o l2t.o t4_hw.o sge.o clip_tbl.o cxgb4_ethtool.o
++>>>>>>> 812034f11628 (cxgb4: Move ethtool related code to a separate file)
  cxgb4-$(CONFIG_CHELSIO_T4_DCB) +=  cxgb4_dcb.o
 -cxgb4-$(CONFIG_CHELSIO_T4_FCOE) +=  cxgb4_fcoe.o
 -cxgb4-$(CONFIG_DEBUG_FS) += cxgb4_debugfs.o
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index dddf17cba9bf,524d11098c56..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@@ -866,6 -920,126 +882,129 @@@ static inline struct adapter *netdev2ad
  	return netdev2pinfo(dev)->adapter;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NET_RX_BUSY_POLL
+ static inline void cxgb_busy_poll_init_lock(struct sge_rspq *q)
+ {
+ 	spin_lock_init(&q->bpoll_lock);
+ 	q->bpoll_state = CXGB_POLL_STATE_IDLE;
+ }
+ 
+ static inline bool cxgb_poll_lock_napi(struct sge_rspq *q)
+ {
+ 	bool rc = true;
+ 
+ 	spin_lock(&q->bpoll_lock);
+ 	if (q->bpoll_state & CXGB_POLL_LOCKED) {
+ 		q->bpoll_state |= CXGB_POLL_STATE_NAPI_YIELD;
+ 		rc = false;
+ 	} else {
+ 		q->bpoll_state = CXGB_POLL_STATE_NAPI;
+ 	}
+ 	spin_unlock(&q->bpoll_lock);
+ 	return rc;
+ }
+ 
+ static inline bool cxgb_poll_unlock_napi(struct sge_rspq *q)
+ {
+ 	bool rc = false;
+ 
+ 	spin_lock(&q->bpoll_lock);
+ 	if (q->bpoll_state & CXGB_POLL_STATE_POLL_YIELD)
+ 		rc = true;
+ 	q->bpoll_state = CXGB_POLL_STATE_IDLE;
+ 	spin_unlock(&q->bpoll_lock);
+ 	return rc;
+ }
+ 
+ static inline bool cxgb_poll_lock_poll(struct sge_rspq *q)
+ {
+ 	bool rc = true;
+ 
+ 	spin_lock_bh(&q->bpoll_lock);
+ 	if (q->bpoll_state & CXGB_POLL_LOCKED) {
+ 		q->bpoll_state |= CXGB_POLL_STATE_POLL_YIELD;
+ 		rc = false;
+ 	} else {
+ 		q->bpoll_state |= CXGB_POLL_STATE_POLL;
+ 	}
+ 	spin_unlock_bh(&q->bpoll_lock);
+ 	return rc;
+ }
+ 
+ static inline bool cxgb_poll_unlock_poll(struct sge_rspq *q)
+ {
+ 	bool rc = false;
+ 
+ 	spin_lock_bh(&q->bpoll_lock);
+ 	if (q->bpoll_state & CXGB_POLL_STATE_POLL_YIELD)
+ 		rc = true;
+ 	q->bpoll_state = CXGB_POLL_STATE_IDLE;
+ 	spin_unlock_bh(&q->bpoll_lock);
+ 	return rc;
+ }
+ 
+ static inline bool cxgb_poll_busy_polling(struct sge_rspq *q)
+ {
+ 	return q->bpoll_state & CXGB_POLL_USER_PEND;
+ }
+ #else
+ static inline void cxgb_busy_poll_init_lock(struct sge_rspq *q)
+ {
+ }
+ 
+ static inline bool cxgb_poll_lock_napi(struct sge_rspq *q)
+ {
+ 	return true;
+ }
+ 
+ static inline bool cxgb_poll_unlock_napi(struct sge_rspq *q)
+ {
+ 	return false;
+ }
+ 
+ static inline bool cxgb_poll_lock_poll(struct sge_rspq *q)
+ {
+ 	return false;
+ }
+ 
+ static inline bool cxgb_poll_unlock_poll(struct sge_rspq *q)
+ {
+ 	return false;
+ }
+ 
+ static inline bool cxgb_poll_busy_polling(struct sge_rspq *q)
+ {
+ 	return false;
+ }
+ #endif /* CONFIG_NET_RX_BUSY_POLL */
+ 
+ /* Return a version number to identify the type of adapter.  The scheme is:
+  * - bits 0..9: chip version
+  * - bits 10..15: chip revision
+  * - bits 16..23: register dump version
+  */
+ static inline unsigned int mk_adap_vers(struct adapter *ap)
+ {
+ 	return CHELSIO_CHIP_VERSION(ap->params.chip) |
+ 		(CHELSIO_CHIP_RELEASE(ap->params.chip) << 10) | (1 << 16);
+ }
+ 
+ /* Return a queue's interrupt hold-off time in us.  0 means no timer. */
+ static inline unsigned int qtimer_val(const struct adapter *adap,
+ 				      const struct sge_rspq *q)
+ {
+ 	unsigned int idx = q->intr_params >> 1;
+ 
+ 	return idx < SGE_NTIMERS ? adap->sge.timer_val[idx] : 0;
+ }
+ 
+ /* driver version & name used for ethtool_drvinfo */
+ extern char cxgb4_driver_name[];
+ extern const char cxgb4_driver_version[];
+ 
++>>>>>>> 812034f11628 (cxgb4: Move ethtool related code to a separate file)
  void t4_os_portmod_changed(const struct adapter *adap, int port_id);
  void t4_os_link_changed(struct adapter *adap, int port_id, int link_stat);
  
@@@ -894,6 -1068,11 +1033,14 @@@ irqreturn_t t4_sge_intr_msix(int irq, v
  int t4_sge_init(struct adapter *adap);
  void t4_sge_start(struct adapter *adap);
  void t4_sge_stop(struct adapter *adap);
++<<<<<<< HEAD
++=======
+ int cxgb_busy_poll(struct napi_struct *napi);
+ int cxgb4_set_rspq_intr_params(struct sge_rspq *q, unsigned int us,
+ 			       unsigned int cnt);
+ void cxgb4_set_ethtool_ops(struct net_device *netdev);
+ int cxgb4_write_rss(const struct port_info *pi, const u16 *queues);
++>>>>>>> 812034f11628 (cxgb4: Move ethtool related code to a separate file)
  extern int dbfifo_int_thresh;
  
  #define for_each_port(adapter, iter) \
@@@ -982,9 -1161,15 +1129,12 @@@ static inline int t4_memory_write(struc
  	return t4_memory_rw(adap, 0, mtype, addr, len, buf, 0);
  }
  
+ unsigned int t4_get_regs_len(struct adapter *adapter);
+ void t4_get_regs(struct adapter *adap, void *buf, size_t buf_size);
+ 
  int t4_seeprom_wp(struct adapter *adapter, bool enable);
  int get_vpd_params(struct adapter *adapter, struct vpd_params *p);
 -int t4_read_flash(struct adapter *adapter, unsigned int addr,
 -		  unsigned int nwords, u32 *data, int byte_oriented);
  int t4_load_fw(struct adapter *adapter, const u8 *fw_data, unsigned int size);
 -int t4_fwcache(struct adapter *adap, enum fw_params_param_dev_fwcache op);
  int t4_fw_upgrade(struct adapter *adap, unsigned int mbox,
  		  const u8 *fw_data, unsigned int size, int force);
  unsigned int t4_flash_cfg_addr(struct adapter *adapter);
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 1b2d97e91707,24e10ea3d5ef..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -65,122 -67,24 +65,130 @@@
  
  #include "cxgb4.h"
  #include "t4_regs.h"
 -#include "t4_values.h"
  #include "t4_msg.h"
  #include "t4fw_api.h"
 -#include "t4fw_version.h"
 -#include "cxgb4_dcb.h"
 -#include "cxgb4_debugfs.h"
 -#include "clip_tbl.h"
  #include "l2t.h"
  
++<<<<<<< HEAD
 +#include <../drivers/net/bonding/bonding.h>
++=======
+ char cxgb4_driver_name[] = KBUILD_MODNAME;
++>>>>>>> 812034f11628 (cxgb4: Move ethtool related code to a separate file)
  
  #ifdef DRV_VERSION
  #undef DRV_VERSION
  #endif
  #define DRV_VERSION "2.0.0-ko"
+ const char cxgb4_driver_version[] = DRV_VERSION;
  #define DRV_DESC "Chelsio T4/T5 Network Driver"
  
++<<<<<<< HEAD
 +/*
 + * Max interrupt hold-off timer value in us.  Queues fall back to this value
 + * under extreme memory pressure so it's largish to give the system time to
 + * recover.
 + */
 +#define MAX_SGE_TIMERVAL 200U
 +
 +enum {
 +	/*
 +	 * Physical Function provisioning constants.
 +	 */
 +	PFRES_NVI = 4,			/* # of Virtual Interfaces */
 +	PFRES_NETHCTRL = 128,		/* # of EQs used for ETH or CTRL Qs */
 +	PFRES_NIQFLINT = 128,		/* # of ingress Qs/w Free List(s)/intr
 +					 */
 +	PFRES_NEQ = 256,		/* # of egress queues */
 +	PFRES_NIQ = 0,			/* # of ingress queues */
 +	PFRES_TC = 0,			/* PCI-E traffic class */
 +	PFRES_NEXACTF = 128,		/* # of exact MPS filters */
 +
 +	PFRES_R_CAPS = FW_CMD_CAP_PF,
 +	PFRES_WX_CAPS = FW_CMD_CAP_PF,
 +
 +#ifdef CONFIG_PCI_IOV
 +	/*
 +	 * Virtual Function provisioning constants.  We need two extra Ingress
 +	 * Queues with Interrupt capability to serve as the VF's Firmware
 +	 * Event Queue and Forwarded Interrupt Queue (when using MSI mode) --
 +	 * neither will have Free Lists associated with them).  For each
 +	 * Ethernet/Control Egress Queue and for each Free List, we need an
 +	 * Egress Context.
 +	 */
 +	VFRES_NPORTS = 1,		/* # of "ports" per VF */
 +	VFRES_NQSETS = 2,		/* # of "Queue Sets" per VF */
 +
 +	VFRES_NVI = VFRES_NPORTS,	/* # of Virtual Interfaces */
 +	VFRES_NETHCTRL = VFRES_NQSETS,	/* # of EQs used for ETH or CTRL Qs */
 +	VFRES_NIQFLINT = VFRES_NQSETS+2,/* # of ingress Qs/w Free List(s)/intr */
 +	VFRES_NEQ = VFRES_NQSETS*2,	/* # of egress queues */
 +	VFRES_NIQ = 0,			/* # of non-fl/int ingress queues */
 +	VFRES_TC = 0,			/* PCI-E traffic class */
 +	VFRES_NEXACTF = 16,		/* # of exact MPS filters */
 +
 +	VFRES_R_CAPS = FW_CMD_CAP_DMAQ|FW_CMD_CAP_VF|FW_CMD_CAP_PORT,
 +	VFRES_WX_CAPS = FW_CMD_CAP_DMAQ|FW_CMD_CAP_VF,
 +#endif
 +};
 +
 +/*
 + * Provide a Port Access Rights Mask for the specified PF/VF.  This is very
 + * static and likely not to be useful in the long run.  We really need to
 + * implement some form of persistent configuration which the firmware
 + * controls.
 + */
 +static unsigned int pfvfres_pmask(struct adapter *adapter,
 +				  unsigned int pf, unsigned int vf)
 +{
 +	unsigned int portn, portvec;
 +
 +	/*
 +	 * Give PF's access to all of the ports.
 +	 */
 +	if (vf == 0)
 +		return FW_PFVF_CMD_PMASK_MASK;
 +
 +	/*
 +	 * For VFs, we'll assign them access to the ports based purely on the
 +	 * PF.  We assign active ports in order, wrapping around if there are
 +	 * fewer active ports than PFs: e.g. active port[pf % nports].
 +	 * Unfortunately the adapter's port_info structs haven't been
 +	 * initialized yet so we have to compute this.
 +	 */
 +	if (adapter->params.nports == 0)
 +		return 0;
 +
 +	portn = pf % adapter->params.nports;
 +	portvec = adapter->params.portvec;
 +	for (;;) {
 +		/*
 +		 * Isolate the lowest set bit in the port vector.  If we're at
 +		 * the port number that we want, return that as the pmask.
 +		 * otherwise mask that bit out of the port vector and
 +		 * decrement our port number ...
 +		 */
 +		unsigned int pmask = portvec ^ (portvec & (portvec-1));
 +		if (portn == 0)
 +			return pmask;
 +		portn--;
 +		portvec &= ~pmask;
 +	}
 +	/*NOTREACHED*/
 +}
 +
 +enum {
 +	MAX_TXQ_ENTRIES      = 16384,
 +	MAX_CTRL_TXQ_ENTRIES = 1024,
 +	MAX_RSPQ_ENTRIES     = 16384,
 +	MAX_RX_BUFFERS       = 16384,
 +	MIN_TXQ_ENTRIES      = 32,
 +	MIN_CTRL_TXQ_ENTRIES = 32,
 +	MIN_RSPQ_ENTRIES     = 128,
 +	MIN_FL_ENTRIES       = 16
 +};
 +
++=======
++>>>>>>> 812034f11628 (cxgb4: Move ethtool related code to a separate file)
  /* Host shadow copy of ingress filter entry.  This is in host native format
   * and doesn't match the ordering or bit order, etc. of the hardware of the
   * firmware command.  The use of bit-field structure elements is purely to
@@@ -1328,1188 -1268,57 +1336,1191 @@@ static int del_filter_wr(struct adapte
  	return 0;
  }
  
 -static u16 cxgb_select_queue(struct net_device *dev, struct sk_buff *skb,
 -			     void *accel_priv, select_queue_fallback_t fallback)
 +static inline int is_offload(const struct adapter *adap)
  {
 -	int txq;
 +	return adap->params.offload;
 +}
  
 -#ifdef CONFIG_CHELSIO_T4_DCB
 -	/* If a Data Center Bridging has been successfully negotiated on this
 -	 * link then we'll use the skb's priority to map it to a TX Queue.
 -	 * The skb's priority is determined via the VLAN Tag Priority Code
 -	 * Point field.
 -	 */
 -	if (cxgb4_dcb_enabled(dev)) {
 -		u16 vlan_tci;
 -		int err;
++<<<<<<< HEAD
 +/*
 + * Implementation of ethtool operations.
 + */
  
 -		err = vlan_get_tag(skb, &vlan_tci);
 -		if (unlikely(err)) {
 -			if (net_ratelimit())
 -				netdev_warn(dev,
 -					    "TX Packet without VLAN Tag on DCB Link\n");
 -			txq = 0;
 -		} else {
 -			txq = (vlan_tci & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;
 -#ifdef CONFIG_CHELSIO_T4_FCOE
 -			if (skb->protocol == htons(ETH_P_FCOE))
 -				txq = skb->priority & 0x7;
 -#endif /* CONFIG_CHELSIO_T4_FCOE */
 -		}
 -		return txq;
 +static u32 get_msglevel(struct net_device *dev)
 +{
 +	return netdev2adap(dev)->msg_enable;
 +}
 +
 +static void set_msglevel(struct net_device *dev, u32 val)
 +{
 +	netdev2adap(dev)->msg_enable = val;
 +}
 +
 +static char stats_strings[][ETH_GSTRING_LEN] = {
 +	"TxOctetsOK         ",
 +	"TxFramesOK         ",
 +	"TxBroadcastFrames  ",
 +	"TxMulticastFrames  ",
 +	"TxUnicastFrames    ",
 +	"TxErrorFrames      ",
 +
 +	"TxFrames64         ",
 +	"TxFrames65To127    ",
 +	"TxFrames128To255   ",
 +	"TxFrames256To511   ",
 +	"TxFrames512To1023  ",
 +	"TxFrames1024To1518 ",
 +	"TxFrames1519ToMax  ",
 +
 +	"TxFramesDropped    ",
 +	"TxPauseFrames      ",
 +	"TxPPP0Frames       ",
 +	"TxPPP1Frames       ",
 +	"TxPPP2Frames       ",
 +	"TxPPP3Frames       ",
 +	"TxPPP4Frames       ",
 +	"TxPPP5Frames       ",
 +	"TxPPP6Frames       ",
 +	"TxPPP7Frames       ",
 +
 +	"RxOctetsOK         ",
 +	"RxFramesOK         ",
 +	"RxBroadcastFrames  ",
 +	"RxMulticastFrames  ",
 +	"RxUnicastFrames    ",
 +
 +	"RxFramesTooLong    ",
 +	"RxJabberErrors     ",
 +	"RxFCSErrors        ",
 +	"RxLengthErrors     ",
 +	"RxSymbolErrors     ",
 +	"RxRuntFrames       ",
 +
 +	"RxFrames64         ",
 +	"RxFrames65To127    ",
 +	"RxFrames128To255   ",
 +	"RxFrames256To511   ",
 +	"RxFrames512To1023  ",
 +	"RxFrames1024To1518 ",
 +	"RxFrames1519ToMax  ",
 +
 +	"RxPauseFrames      ",
 +	"RxPPP0Frames       ",
 +	"RxPPP1Frames       ",
 +	"RxPPP2Frames       ",
 +	"RxPPP3Frames       ",
 +	"RxPPP4Frames       ",
 +	"RxPPP5Frames       ",
 +	"RxPPP6Frames       ",
 +	"RxPPP7Frames       ",
 +
 +	"RxBG0FramesDropped ",
 +	"RxBG1FramesDropped ",
 +	"RxBG2FramesDropped ",
 +	"RxBG3FramesDropped ",
 +	"RxBG0FramesTrunc   ",
 +	"RxBG1FramesTrunc   ",
 +	"RxBG2FramesTrunc   ",
 +	"RxBG3FramesTrunc   ",
 +
 +	"TSO                ",
 +	"TxCsumOffload      ",
 +	"RxCsumGood         ",
 +	"VLANextractions    ",
 +	"VLANinsertions     ",
 +	"GROpackets         ",
 +	"GROmerged          ",
 +	"WriteCoalSuccess   ",
 +	"WriteCoalFail      ",
 +};
 +
 +static int get_sset_count(struct net_device *dev, int sset)
 +{
 +	switch (sset) {
 +	case ETH_SS_STATS:
 +		return ARRAY_SIZE(stats_strings);
 +	default:
 +		return -EOPNOTSUPP;
  	}
 -#endif /* CONFIG_CHELSIO_T4_DCB */
 +}
  
 -	if (select_queue) {
 -		txq = (skb_rx_queue_recorded(skb)
 -			? skb_get_rx_queue(skb)
 -			: smp_processor_id());
 +#define T4_REGMAP_SIZE (160 * 1024)
 +#define T5_REGMAP_SIZE (332 * 1024)
  
 -		while (unlikely(txq >= dev->real_num_tx_queues))
 -			txq -= dev->real_num_tx_queues;
 +static int get_regs_len(struct net_device *dev)
 +{
 +	struct adapter *adap = netdev2adap(dev);
 +	if (is_t4(adap->params.chip))
 +		return T4_REGMAP_SIZE;
 +	else
 +		return T5_REGMAP_SIZE;
 +}
 +
 +static int get_eeprom_len(struct net_device *dev)
 +{
 +	return EEPROMSIZE;
 +}
  
 -		return txq;
 +static void get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
 +{
 +	struct adapter *adapter = netdev2adap(dev);
 +
 +	strlcpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));
 +	strlcpy(info->version, DRV_VERSION, sizeof(info->version));
 +	strlcpy(info->bus_info, pci_name(adapter->pdev),
 +		sizeof(info->bus_info));
 +
 +	if (adapter->params.fw_vers)
 +		snprintf(info->fw_version, sizeof(info->fw_version),
 +			"%u.%u.%u.%u, TP %u.%u.%u.%u",
 +			FW_HDR_FW_VER_MAJOR_GET(adapter->params.fw_vers),
 +			FW_HDR_FW_VER_MINOR_GET(adapter->params.fw_vers),
 +			FW_HDR_FW_VER_MICRO_GET(adapter->params.fw_vers),
 +			FW_HDR_FW_VER_BUILD_GET(adapter->params.fw_vers),
 +			FW_HDR_FW_VER_MAJOR_GET(adapter->params.tp_vers),
 +			FW_HDR_FW_VER_MINOR_GET(adapter->params.tp_vers),
 +			FW_HDR_FW_VER_MICRO_GET(adapter->params.tp_vers),
 +			FW_HDR_FW_VER_BUILD_GET(adapter->params.tp_vers));
 +}
 +
 +static void get_strings(struct net_device *dev, u32 stringset, u8 *data)
 +{
 +	if (stringset == ETH_SS_STATS)
 +		memcpy(data, stats_strings, sizeof(stats_strings));
 +}
 +
 +/*
 + * port stats maintained per queue of the port.  They should be in the same
 + * order as in stats_strings above.
 + */
 +struct queue_port_stats {
 +	u64 tso;
 +	u64 tx_csum;
 +	u64 rx_csum;
 +	u64 vlan_ex;
 +	u64 vlan_ins;
 +	u64 gro_pkts;
 +	u64 gro_merged;
 +};
 +
 +static void collect_sge_port_stats(const struct adapter *adap,
 +		const struct port_info *p, struct queue_port_stats *s)
 +{
 +	int i;
 +	const struct sge_eth_txq *tx = &adap->sge.ethtxq[p->first_qset];
 +	const struct sge_eth_rxq *rx = &adap->sge.ethrxq[p->first_qset];
 +
 +	memset(s, 0, sizeof(*s));
 +	for (i = 0; i < p->nqsets; i++, rx++, tx++) {
 +		s->tso += tx->tso;
 +		s->tx_csum += tx->tx_cso;
 +		s->rx_csum += rx->stats.rx_cso;
 +		s->vlan_ex += rx->stats.vlan_ex;
 +		s->vlan_ins += tx->vlan_ins;
 +		s->gro_pkts += rx->stats.lro_pkts;
 +		s->gro_merged += rx->stats.lro_merged;
  	}
 +}
 +
 +static void get_stats(struct net_device *dev, struct ethtool_stats *stats,
 +		      u64 *data)
 +{
 +	struct port_info *pi = netdev_priv(dev);
 +	struct adapter *adapter = pi->adapter;
 +	u32 val1, val2;
 +
 +	t4_get_port_stats(adapter, pi->tx_chan, (struct port_stats *)data);
  
 -	return fallback(dev, skb) % dev->real_num_tx_queues;
 +	data += sizeof(struct port_stats) / sizeof(u64);
 +	collect_sge_port_stats(adapter, pi, (struct queue_port_stats *)data);
 +	data += sizeof(struct queue_port_stats) / sizeof(u64);
 +	if (!is_t4(adapter->params.chip)) {
 +		t4_write_reg(adapter, SGE_STAT_CFG, STATSOURCE_T5(7));
 +		val1 = t4_read_reg(adapter, SGE_STAT_TOTAL);
 +		val2 = t4_read_reg(adapter, SGE_STAT_MATCH);
 +		*data = val1 - val2;
 +		data++;
 +		*data = val2;
 +		data++;
 +	} else {
 +		memset(data, 0, 2 * sizeof(u64));
 +		*data += 2;
 +	}
  }
  
 -static inline int is_offload(const struct adapter *adap)
 +/*
 + * Return a version number to identify the type of adapter.  The scheme is:
 + * - bits 0..9: chip version
 + * - bits 10..15: chip revision
 + * - bits 16..23: register dump version
 + */
 +static inline unsigned int mk_adap_vers(const struct adapter *ap)
  {
 -	return adap->params.offload;
 +	return CHELSIO_CHIP_VERSION(ap->params.chip) |
 +		(CHELSIO_CHIP_RELEASE(ap->params.chip) << 10) | (1 << 16);
 +}
 +
 +static void reg_block_dump(struct adapter *ap, void *buf, unsigned int start,
 +			   unsigned int end)
 +{
 +	u32 *p = buf + start;
 +
 +	for ( ; start <= end; start += sizeof(u32))
 +		*p++ = t4_read_reg(ap, start);
 +}
 +
 +static void get_regs(struct net_device *dev, struct ethtool_regs *regs,
 +		     void *buf)
 +{
 +	static const unsigned int t4_reg_ranges[] = {
 +		0x1008, 0x1108,
 +		0x1180, 0x11b4,
 +		0x11fc, 0x123c,
 +		0x1300, 0x173c,
 +		0x1800, 0x18fc,
 +		0x3000, 0x30d8,
 +		0x30e0, 0x5924,
 +		0x5960, 0x59d4,
 +		0x5a00, 0x5af8,
 +		0x6000, 0x6098,
 +		0x6100, 0x6150,
 +		0x6200, 0x6208,
 +		0x6240, 0x6248,
 +		0x6280, 0x6338,
 +		0x6370, 0x638c,
 +		0x6400, 0x643c,
 +		0x6500, 0x6524,
 +		0x6a00, 0x6a38,
 +		0x6a60, 0x6a78,
 +		0x6b00, 0x6b84,
 +		0x6bf0, 0x6c84,
 +		0x6cf0, 0x6d84,
 +		0x6df0, 0x6e84,
 +		0x6ef0, 0x6f84,
 +		0x6ff0, 0x7084,
 +		0x70f0, 0x7184,
 +		0x71f0, 0x7284,
 +		0x72f0, 0x7384,
 +		0x73f0, 0x7450,
 +		0x7500, 0x7530,
 +		0x7600, 0x761c,
 +		0x7680, 0x76cc,
 +		0x7700, 0x7798,
 +		0x77c0, 0x77fc,
 +		0x7900, 0x79fc,
 +		0x7b00, 0x7c38,
 +		0x7d00, 0x7efc,
 +		0x8dc0, 0x8e1c,
 +		0x8e30, 0x8e78,
 +		0x8ea0, 0x8f6c,
 +		0x8fc0, 0x9074,
 +		0x90fc, 0x90fc,
 +		0x9400, 0x9458,
 +		0x9600, 0x96bc,
 +		0x9800, 0x9808,
 +		0x9820, 0x983c,
 +		0x9850, 0x9864,
 +		0x9c00, 0x9c6c,
 +		0x9c80, 0x9cec,
 +		0x9d00, 0x9d6c,
 +		0x9d80, 0x9dec,
 +		0x9e00, 0x9e6c,
 +		0x9e80, 0x9eec,
 +		0x9f00, 0x9f6c,
 +		0x9f80, 0x9fec,
 +		0xd004, 0xd03c,
 +		0xdfc0, 0xdfe0,
 +		0xe000, 0xea7c,
 +		0xf000, 0x11110,
 +		0x11118, 0x11190,
 +		0x19040, 0x1906c,
 +		0x19078, 0x19080,
 +		0x1908c, 0x19124,
 +		0x19150, 0x191b0,
 +		0x191d0, 0x191e8,
 +		0x19238, 0x1924c,
 +		0x193f8, 0x19474,
 +		0x19490, 0x194f8,
 +		0x19800, 0x19f30,
 +		0x1a000, 0x1a06c,
 +		0x1a0b0, 0x1a120,
 +		0x1a128, 0x1a138,
 +		0x1a190, 0x1a1c4,
 +		0x1a1fc, 0x1a1fc,
 +		0x1e040, 0x1e04c,
 +		0x1e284, 0x1e28c,
 +		0x1e2c0, 0x1e2c0,
 +		0x1e2e0, 0x1e2e0,
 +		0x1e300, 0x1e384,
 +		0x1e3c0, 0x1e3c8,
 +		0x1e440, 0x1e44c,
 +		0x1e684, 0x1e68c,
 +		0x1e6c0, 0x1e6c0,
 +		0x1e6e0, 0x1e6e0,
 +		0x1e700, 0x1e784,
 +		0x1e7c0, 0x1e7c8,
 +		0x1e840, 0x1e84c,
 +		0x1ea84, 0x1ea8c,
 +		0x1eac0, 0x1eac0,
 +		0x1eae0, 0x1eae0,
 +		0x1eb00, 0x1eb84,
 +		0x1ebc0, 0x1ebc8,
 +		0x1ec40, 0x1ec4c,
 +		0x1ee84, 0x1ee8c,
 +		0x1eec0, 0x1eec0,
 +		0x1eee0, 0x1eee0,
 +		0x1ef00, 0x1ef84,
 +		0x1efc0, 0x1efc8,
 +		0x1f040, 0x1f04c,
 +		0x1f284, 0x1f28c,
 +		0x1f2c0, 0x1f2c0,
 +		0x1f2e0, 0x1f2e0,
 +		0x1f300, 0x1f384,
 +		0x1f3c0, 0x1f3c8,
 +		0x1f440, 0x1f44c,
 +		0x1f684, 0x1f68c,
 +		0x1f6c0, 0x1f6c0,
 +		0x1f6e0, 0x1f6e0,
 +		0x1f700, 0x1f784,
 +		0x1f7c0, 0x1f7c8,
 +		0x1f840, 0x1f84c,
 +		0x1fa84, 0x1fa8c,
 +		0x1fac0, 0x1fac0,
 +		0x1fae0, 0x1fae0,
 +		0x1fb00, 0x1fb84,
 +		0x1fbc0, 0x1fbc8,
 +		0x1fc40, 0x1fc4c,
 +		0x1fe84, 0x1fe8c,
 +		0x1fec0, 0x1fec0,
 +		0x1fee0, 0x1fee0,
 +		0x1ff00, 0x1ff84,
 +		0x1ffc0, 0x1ffc8,
 +		0x20000, 0x2002c,
 +		0x20100, 0x2013c,
 +		0x20190, 0x201c8,
 +		0x20200, 0x20318,
 +		0x20400, 0x20528,
 +		0x20540, 0x20614,
 +		0x21000, 0x21040,
 +		0x2104c, 0x21060,
 +		0x210c0, 0x210ec,
 +		0x21200, 0x21268,
 +		0x21270, 0x21284,
 +		0x212fc, 0x21388,
 +		0x21400, 0x21404,
 +		0x21500, 0x21518,
 +		0x2152c, 0x2153c,
 +		0x21550, 0x21554,
 +		0x21600, 0x21600,
 +		0x21608, 0x21628,
 +		0x21630, 0x2163c,
 +		0x21700, 0x2171c,
 +		0x21780, 0x2178c,
 +		0x21800, 0x21c38,
 +		0x21c80, 0x21d7c,
 +		0x21e00, 0x21e04,
 +		0x22000, 0x2202c,
 +		0x22100, 0x2213c,
 +		0x22190, 0x221c8,
 +		0x22200, 0x22318,
 +		0x22400, 0x22528,
 +		0x22540, 0x22614,
 +		0x23000, 0x23040,
 +		0x2304c, 0x23060,
 +		0x230c0, 0x230ec,
 +		0x23200, 0x23268,
 +		0x23270, 0x23284,
 +		0x232fc, 0x23388,
 +		0x23400, 0x23404,
 +		0x23500, 0x23518,
 +		0x2352c, 0x2353c,
 +		0x23550, 0x23554,
 +		0x23600, 0x23600,
 +		0x23608, 0x23628,
 +		0x23630, 0x2363c,
 +		0x23700, 0x2371c,
 +		0x23780, 0x2378c,
 +		0x23800, 0x23c38,
 +		0x23c80, 0x23d7c,
 +		0x23e00, 0x23e04,
 +		0x24000, 0x2402c,
 +		0x24100, 0x2413c,
 +		0x24190, 0x241c8,
 +		0x24200, 0x24318,
 +		0x24400, 0x24528,
 +		0x24540, 0x24614,
 +		0x25000, 0x25040,
 +		0x2504c, 0x25060,
 +		0x250c0, 0x250ec,
 +		0x25200, 0x25268,
 +		0x25270, 0x25284,
 +		0x252fc, 0x25388,
 +		0x25400, 0x25404,
 +		0x25500, 0x25518,
 +		0x2552c, 0x2553c,
 +		0x25550, 0x25554,
 +		0x25600, 0x25600,
 +		0x25608, 0x25628,
 +		0x25630, 0x2563c,
 +		0x25700, 0x2571c,
 +		0x25780, 0x2578c,
 +		0x25800, 0x25c38,
 +		0x25c80, 0x25d7c,
 +		0x25e00, 0x25e04,
 +		0x26000, 0x2602c,
 +		0x26100, 0x2613c,
 +		0x26190, 0x261c8,
 +		0x26200, 0x26318,
 +		0x26400, 0x26528,
 +		0x26540, 0x26614,
 +		0x27000, 0x27040,
 +		0x2704c, 0x27060,
 +		0x270c0, 0x270ec,
 +		0x27200, 0x27268,
 +		0x27270, 0x27284,
 +		0x272fc, 0x27388,
 +		0x27400, 0x27404,
 +		0x27500, 0x27518,
 +		0x2752c, 0x2753c,
 +		0x27550, 0x27554,
 +		0x27600, 0x27600,
 +		0x27608, 0x27628,
 +		0x27630, 0x2763c,
 +		0x27700, 0x2771c,
 +		0x27780, 0x2778c,
 +		0x27800, 0x27c38,
 +		0x27c80, 0x27d7c,
 +		0x27e00, 0x27e04
 +	};
 +
 +	static const unsigned int t5_reg_ranges[] = {
 +		0x1008, 0x1148,
 +		0x1180, 0x11b4,
 +		0x11fc, 0x123c,
 +		0x1280, 0x173c,
 +		0x1800, 0x18fc,
 +		0x3000, 0x3028,
 +		0x3060, 0x30d8,
 +		0x30e0, 0x30fc,
 +		0x3140, 0x357c,
 +		0x35a8, 0x35cc,
 +		0x35ec, 0x35ec,
 +		0x3600, 0x5624,
 +		0x56cc, 0x575c,
 +		0x580c, 0x5814,
 +		0x5890, 0x58bc,
 +		0x5940, 0x59dc,
 +		0x59fc, 0x5a18,
 +		0x5a60, 0x5a9c,
 +		0x5b9c, 0x5bfc,
 +		0x6000, 0x6040,
 +		0x6058, 0x614c,
 +		0x7700, 0x7798,
 +		0x77c0, 0x78fc,
 +		0x7b00, 0x7c54,
 +		0x7d00, 0x7efc,
 +		0x8dc0, 0x8de0,
 +		0x8df8, 0x8e84,
 +		0x8ea0, 0x8f84,
 +		0x8fc0, 0x90f8,
 +		0x9400, 0x9470,
 +		0x9600, 0x96f4,
 +		0x9800, 0x9808,
 +		0x9820, 0x983c,
 +		0x9850, 0x9864,
 +		0x9c00, 0x9c6c,
 +		0x9c80, 0x9cec,
 +		0x9d00, 0x9d6c,
 +		0x9d80, 0x9dec,
 +		0x9e00, 0x9e6c,
 +		0x9e80, 0x9eec,
 +		0x9f00, 0x9f6c,
 +		0x9f80, 0xa020,
 +		0xd004, 0xd03c,
 +		0xdfc0, 0xdfe0,
 +		0xe000, 0x11088,
 +		0x1109c, 0x11110,
 +		0x11118, 0x1117c,
 +		0x11190, 0x11204,
 +		0x19040, 0x1906c,
 +		0x19078, 0x19080,
 +		0x1908c, 0x19124,
 +		0x19150, 0x191b0,
 +		0x191d0, 0x191e8,
 +		0x19238, 0x19290,
 +		0x193f8, 0x19474,
 +		0x19490, 0x194cc,
 +		0x194f0, 0x194f8,
 +		0x19c00, 0x19c60,
 +		0x19c94, 0x19e10,
 +		0x19e50, 0x19f34,
 +		0x19f40, 0x19f50,
 +		0x19f90, 0x19fe4,
 +		0x1a000, 0x1a06c,
 +		0x1a0b0, 0x1a120,
 +		0x1a128, 0x1a138,
 +		0x1a190, 0x1a1c4,
 +		0x1a1fc, 0x1a1fc,
 +		0x1e008, 0x1e00c,
 +		0x1e040, 0x1e04c,
 +		0x1e284, 0x1e290,
 +		0x1e2c0, 0x1e2c0,
 +		0x1e2e0, 0x1e2e0,
 +		0x1e300, 0x1e384,
 +		0x1e3c0, 0x1e3c8,
 +		0x1e408, 0x1e40c,
 +		0x1e440, 0x1e44c,
 +		0x1e684, 0x1e690,
 +		0x1e6c0, 0x1e6c0,
 +		0x1e6e0, 0x1e6e0,
 +		0x1e700, 0x1e784,
 +		0x1e7c0, 0x1e7c8,
 +		0x1e808, 0x1e80c,
 +		0x1e840, 0x1e84c,
 +		0x1ea84, 0x1ea90,
 +		0x1eac0, 0x1eac0,
 +		0x1eae0, 0x1eae0,
 +		0x1eb00, 0x1eb84,
 +		0x1ebc0, 0x1ebc8,
 +		0x1ec08, 0x1ec0c,
 +		0x1ec40, 0x1ec4c,
 +		0x1ee84, 0x1ee90,
 +		0x1eec0, 0x1eec0,
 +		0x1eee0, 0x1eee0,
 +		0x1ef00, 0x1ef84,
 +		0x1efc0, 0x1efc8,
 +		0x1f008, 0x1f00c,
 +		0x1f040, 0x1f04c,
 +		0x1f284, 0x1f290,
 +		0x1f2c0, 0x1f2c0,
 +		0x1f2e0, 0x1f2e0,
 +		0x1f300, 0x1f384,
 +		0x1f3c0, 0x1f3c8,
 +		0x1f408, 0x1f40c,
 +		0x1f440, 0x1f44c,
 +		0x1f684, 0x1f690,
 +		0x1f6c0, 0x1f6c0,
 +		0x1f6e0, 0x1f6e0,
 +		0x1f700, 0x1f784,
 +		0x1f7c0, 0x1f7c8,
 +		0x1f808, 0x1f80c,
 +		0x1f840, 0x1f84c,
 +		0x1fa84, 0x1fa90,
 +		0x1fac0, 0x1fac0,
 +		0x1fae0, 0x1fae0,
 +		0x1fb00, 0x1fb84,
 +		0x1fbc0, 0x1fbc8,
 +		0x1fc08, 0x1fc0c,
 +		0x1fc40, 0x1fc4c,
 +		0x1fe84, 0x1fe90,
 +		0x1fec0, 0x1fec0,
 +		0x1fee0, 0x1fee0,
 +		0x1ff00, 0x1ff84,
 +		0x1ffc0, 0x1ffc8,
 +		0x30000, 0x30030,
 +		0x30100, 0x30144,
 +		0x30190, 0x301d0,
 +		0x30200, 0x30318,
 +		0x30400, 0x3052c,
 +		0x30540, 0x3061c,
 +		0x30800, 0x30834,
 +		0x308c0, 0x30908,
 +		0x30910, 0x309ac,
 +		0x30a00, 0x30a04,
 +		0x30a0c, 0x30a2c,
 +		0x30a44, 0x30a50,
 +		0x30a74, 0x30c24,
 +		0x30d08, 0x30d14,
 +		0x30d1c, 0x30d20,
 +		0x30d3c, 0x30d50,
 +		0x31200, 0x3120c,
 +		0x31220, 0x31220,
 +		0x31240, 0x31240,
 +		0x31600, 0x31600,
 +		0x31608, 0x3160c,
 +		0x31a00, 0x31a1c,
 +		0x31e04, 0x31e20,
 +		0x31e38, 0x31e3c,
 +		0x31e80, 0x31e80,
 +		0x31e88, 0x31ea8,
 +		0x31eb0, 0x31eb4,
 +		0x31ec8, 0x31ed4,
 +		0x31fb8, 0x32004,
 +		0x32208, 0x3223c,
 +		0x32600, 0x32630,
 +		0x32a00, 0x32abc,
 +		0x32b00, 0x32b70,
 +		0x33000, 0x33048,
 +		0x33060, 0x3309c,
 +		0x330f0, 0x33148,
 +		0x33160, 0x3319c,
 +		0x331f0, 0x332e4,
 +		0x332f8, 0x333e4,
 +		0x333f8, 0x33448,
 +		0x33460, 0x3349c,
 +		0x334f0, 0x33548,
 +		0x33560, 0x3359c,
 +		0x335f0, 0x336e4,
 +		0x336f8, 0x337e4,
 +		0x337f8, 0x337fc,
 +		0x33814, 0x33814,
 +		0x3382c, 0x3382c,
 +		0x33880, 0x3388c,
 +		0x338e8, 0x338ec,
 +		0x33900, 0x33948,
 +		0x33960, 0x3399c,
 +		0x339f0, 0x33ae4,
 +		0x33af8, 0x33b10,
 +		0x33b28, 0x33b28,
 +		0x33b3c, 0x33b50,
 +		0x33bf0, 0x33c10,
 +		0x33c28, 0x33c28,
 +		0x33c3c, 0x33c50,
 +		0x33cf0, 0x33cfc,
 +		0x34000, 0x34030,
 +		0x34100, 0x34144,
 +		0x34190, 0x341d0,
 +		0x34200, 0x34318,
 +		0x34400, 0x3452c,
 +		0x34540, 0x3461c,
 +		0x34800, 0x34834,
 +		0x348c0, 0x34908,
 +		0x34910, 0x349ac,
 +		0x34a00, 0x34a04,
 +		0x34a0c, 0x34a2c,
 +		0x34a44, 0x34a50,
 +		0x34a74, 0x34c24,
 +		0x34d08, 0x34d14,
 +		0x34d1c, 0x34d20,
 +		0x34d3c, 0x34d50,
 +		0x35200, 0x3520c,
 +		0x35220, 0x35220,
 +		0x35240, 0x35240,
 +		0x35600, 0x35600,
 +		0x35608, 0x3560c,
 +		0x35a00, 0x35a1c,
 +		0x35e04, 0x35e20,
 +		0x35e38, 0x35e3c,
 +		0x35e80, 0x35e80,
 +		0x35e88, 0x35ea8,
 +		0x35eb0, 0x35eb4,
 +		0x35ec8, 0x35ed4,
 +		0x35fb8, 0x36004,
 +		0x36208, 0x3623c,
 +		0x36600, 0x36630,
 +		0x36a00, 0x36abc,
 +		0x36b00, 0x36b70,
 +		0x37000, 0x37048,
 +		0x37060, 0x3709c,
 +		0x370f0, 0x37148,
 +		0x37160, 0x3719c,
 +		0x371f0, 0x372e4,
 +		0x372f8, 0x373e4,
 +		0x373f8, 0x37448,
 +		0x37460, 0x3749c,
 +		0x374f0, 0x37548,
 +		0x37560, 0x3759c,
 +		0x375f0, 0x376e4,
 +		0x376f8, 0x377e4,
 +		0x377f8, 0x377fc,
 +		0x37814, 0x37814,
 +		0x3782c, 0x3782c,
 +		0x37880, 0x3788c,
 +		0x378e8, 0x378ec,
 +		0x37900, 0x37948,
 +		0x37960, 0x3799c,
 +		0x379f0, 0x37ae4,
 +		0x37af8, 0x37b10,
 +		0x37b28, 0x37b28,
 +		0x37b3c, 0x37b50,
 +		0x37bf0, 0x37c10,
 +		0x37c28, 0x37c28,
 +		0x37c3c, 0x37c50,
 +		0x37cf0, 0x37cfc,
 +		0x38000, 0x38030,
 +		0x38100, 0x38144,
 +		0x38190, 0x381d0,
 +		0x38200, 0x38318,
 +		0x38400, 0x3852c,
 +		0x38540, 0x3861c,
 +		0x38800, 0x38834,
 +		0x388c0, 0x38908,
 +		0x38910, 0x389ac,
 +		0x38a00, 0x38a04,
 +		0x38a0c, 0x38a2c,
 +		0x38a44, 0x38a50,
 +		0x38a74, 0x38c24,
 +		0x38d08, 0x38d14,
 +		0x38d1c, 0x38d20,
 +		0x38d3c, 0x38d50,
 +		0x39200, 0x3920c,
 +		0x39220, 0x39220,
 +		0x39240, 0x39240,
 +		0x39600, 0x39600,
 +		0x39608, 0x3960c,
 +		0x39a00, 0x39a1c,
 +		0x39e04, 0x39e20,
 +		0x39e38, 0x39e3c,
 +		0x39e80, 0x39e80,
 +		0x39e88, 0x39ea8,
 +		0x39eb0, 0x39eb4,
 +		0x39ec8, 0x39ed4,
 +		0x39fb8, 0x3a004,
 +		0x3a208, 0x3a23c,
 +		0x3a600, 0x3a630,
 +		0x3aa00, 0x3aabc,
 +		0x3ab00, 0x3ab70,
 +		0x3b000, 0x3b048,
 +		0x3b060, 0x3b09c,
 +		0x3b0f0, 0x3b148,
 +		0x3b160, 0x3b19c,
 +		0x3b1f0, 0x3b2e4,
 +		0x3b2f8, 0x3b3e4,
 +		0x3b3f8, 0x3b448,
 +		0x3b460, 0x3b49c,
 +		0x3b4f0, 0x3b548,
 +		0x3b560, 0x3b59c,
 +		0x3b5f0, 0x3b6e4,
 +		0x3b6f8, 0x3b7e4,
 +		0x3b7f8, 0x3b7fc,
 +		0x3b814, 0x3b814,
 +		0x3b82c, 0x3b82c,
 +		0x3b880, 0x3b88c,
 +		0x3b8e8, 0x3b8ec,
 +		0x3b900, 0x3b948,
 +		0x3b960, 0x3b99c,
 +		0x3b9f0, 0x3bae4,
 +		0x3baf8, 0x3bb10,
 +		0x3bb28, 0x3bb28,
 +		0x3bb3c, 0x3bb50,
 +		0x3bbf0, 0x3bc10,
 +		0x3bc28, 0x3bc28,
 +		0x3bc3c, 0x3bc50,
 +		0x3bcf0, 0x3bcfc,
 +		0x3c000, 0x3c030,
 +		0x3c100, 0x3c144,
 +		0x3c190, 0x3c1d0,
 +		0x3c200, 0x3c318,
 +		0x3c400, 0x3c52c,
 +		0x3c540, 0x3c61c,
 +		0x3c800, 0x3c834,
 +		0x3c8c0, 0x3c908,
 +		0x3c910, 0x3c9ac,
 +		0x3ca00, 0x3ca04,
 +		0x3ca0c, 0x3ca2c,
 +		0x3ca44, 0x3ca50,
 +		0x3ca74, 0x3cc24,
 +		0x3cd08, 0x3cd14,
 +		0x3cd1c, 0x3cd20,
 +		0x3cd3c, 0x3cd50,
 +		0x3d200, 0x3d20c,
 +		0x3d220, 0x3d220,
 +		0x3d240, 0x3d240,
 +		0x3d600, 0x3d600,
 +		0x3d608, 0x3d60c,
 +		0x3da00, 0x3da1c,
 +		0x3de04, 0x3de20,
 +		0x3de38, 0x3de3c,
 +		0x3de80, 0x3de80,
 +		0x3de88, 0x3dea8,
 +		0x3deb0, 0x3deb4,
 +		0x3dec8, 0x3ded4,
 +		0x3dfb8, 0x3e004,
 +		0x3e208, 0x3e23c,
 +		0x3e600, 0x3e630,
 +		0x3ea00, 0x3eabc,
 +		0x3eb00, 0x3eb70,
 +		0x3f000, 0x3f048,
 +		0x3f060, 0x3f09c,
 +		0x3f0f0, 0x3f148,
 +		0x3f160, 0x3f19c,
 +		0x3f1f0, 0x3f2e4,
 +		0x3f2f8, 0x3f3e4,
 +		0x3f3f8, 0x3f448,
 +		0x3f460, 0x3f49c,
 +		0x3f4f0, 0x3f548,
 +		0x3f560, 0x3f59c,
 +		0x3f5f0, 0x3f6e4,
 +		0x3f6f8, 0x3f7e4,
 +		0x3f7f8, 0x3f7fc,
 +		0x3f814, 0x3f814,
 +		0x3f82c, 0x3f82c,
 +		0x3f880, 0x3f88c,
 +		0x3f8e8, 0x3f8ec,
 +		0x3f900, 0x3f948,
 +		0x3f960, 0x3f99c,
 +		0x3f9f0, 0x3fae4,
 +		0x3faf8, 0x3fb10,
 +		0x3fb28, 0x3fb28,
 +		0x3fb3c, 0x3fb50,
 +		0x3fbf0, 0x3fc10,
 +		0x3fc28, 0x3fc28,
 +		0x3fc3c, 0x3fc50,
 +		0x3fcf0, 0x3fcfc,
 +		0x40000, 0x4000c,
 +		0x40040, 0x40068,
 +		0x40080, 0x40144,
 +		0x40180, 0x4018c,
 +		0x40200, 0x40298,
 +		0x402ac, 0x4033c,
 +		0x403f8, 0x403fc,
 +		0x41304, 0x413c4,
 +		0x41400, 0x4141c,
 +		0x41480, 0x414d0,
 +		0x44000, 0x44078,
 +		0x440c0, 0x44278,
 +		0x442c0, 0x44478,
 +		0x444c0, 0x44678,
 +		0x446c0, 0x44878,
 +		0x448c0, 0x449fc,
 +		0x45000, 0x45068,
 +		0x45080, 0x45084,
 +		0x450a0, 0x450b0,
 +		0x45200, 0x45268,
 +		0x45280, 0x45284,
 +		0x452a0, 0x452b0,
 +		0x460c0, 0x460e4,
 +		0x47000, 0x4708c,
 +		0x47200, 0x47250,
 +		0x47400, 0x47420,
 +		0x47600, 0x47618,
 +		0x47800, 0x47814,
 +		0x48000, 0x4800c,
 +		0x48040, 0x48068,
 +		0x48080, 0x48144,
 +		0x48180, 0x4818c,
 +		0x48200, 0x48298,
 +		0x482ac, 0x4833c,
 +		0x483f8, 0x483fc,
 +		0x49304, 0x493c4,
 +		0x49400, 0x4941c,
 +		0x49480, 0x494d0,
 +		0x4c000, 0x4c078,
 +		0x4c0c0, 0x4c278,
 +		0x4c2c0, 0x4c478,
 +		0x4c4c0, 0x4c678,
 +		0x4c6c0, 0x4c878,
 +		0x4c8c0, 0x4c9fc,
 +		0x4d000, 0x4d068,
 +		0x4d080, 0x4d084,
 +		0x4d0a0, 0x4d0b0,
 +		0x4d200, 0x4d268,
 +		0x4d280, 0x4d284,
 +		0x4d2a0, 0x4d2b0,
 +		0x4e0c0, 0x4e0e4,
 +		0x4f000, 0x4f08c,
 +		0x4f200, 0x4f250,
 +		0x4f400, 0x4f420,
 +		0x4f600, 0x4f618,
 +		0x4f800, 0x4f814,
 +		0x50000, 0x500cc,
 +		0x50400, 0x50400,
 +		0x50800, 0x508cc,
 +		0x50c00, 0x50c00,
 +		0x51000, 0x5101c,
 +		0x51300, 0x51308,
 +	};
 +
 +	int i;
 +	struct adapter *ap = netdev2adap(dev);
 +	static const unsigned int *reg_ranges;
 +	int arr_size = 0, buf_size = 0;
 +
 +	if (is_t4(ap->params.chip)) {
 +		reg_ranges = &t4_reg_ranges[0];
 +		arr_size = ARRAY_SIZE(t4_reg_ranges);
 +		buf_size = T4_REGMAP_SIZE;
 +	} else {
 +		reg_ranges = &t5_reg_ranges[0];
 +		arr_size = ARRAY_SIZE(t5_reg_ranges);
 +		buf_size = T5_REGMAP_SIZE;
 +	}
 +
 +	regs->version = mk_adap_vers(ap);
 +
 +	memset(buf, 0, buf_size);
 +	for (i = 0; i < arr_size; i += 2)
 +		reg_block_dump(ap, buf, reg_ranges[i], reg_ranges[i + 1]);
 +}
 +
 +static int restart_autoneg(struct net_device *dev)
 +{
 +	struct port_info *p = netdev_priv(dev);
 +
 +	if (!netif_running(dev))
 +		return -EAGAIN;
 +	if (p->link_cfg.autoneg != AUTONEG_ENABLE)
 +		return -EINVAL;
 +	t4_restart_aneg(p->adapter, p->adapter->fn, p->tx_chan);
 +	return 0;
 +}
 +
 +static int identify_port(struct net_device *dev,
 +			 enum ethtool_phys_id_state state)
 +{
 +	unsigned int val;
 +	struct adapter *adap = netdev2adap(dev);
 +
 +	if (state == ETHTOOL_ID_ACTIVE)
 +		val = 0xffff;
 +	else if (state == ETHTOOL_ID_INACTIVE)
 +		val = 0;
 +	else
 +		return -EINVAL;
 +
 +	return t4_identify_port(adap, adap->fn, netdev2pinfo(dev)->viid, val);
 +}
 +
 +static unsigned int from_fw_linkcaps(enum fw_port_type type, unsigned int caps)
 +{
 +	unsigned int v = 0;
 +
 +	if (type == FW_PORT_TYPE_BT_SGMII || type == FW_PORT_TYPE_BT_XFI ||
 +	    type == FW_PORT_TYPE_BT_XAUI) {
 +		v |= SUPPORTED_TP;
 +		if (caps & FW_PORT_CAP_SPEED_100M)
 +			v |= SUPPORTED_100baseT_Full;
 +		if (caps & FW_PORT_CAP_SPEED_1G)
 +			v |= SUPPORTED_1000baseT_Full;
 +		if (caps & FW_PORT_CAP_SPEED_10G)
 +			v |= SUPPORTED_10000baseT_Full;
 +	} else if (type == FW_PORT_TYPE_KX4 || type == FW_PORT_TYPE_KX) {
 +		v |= SUPPORTED_Backplane;
 +		if (caps & FW_PORT_CAP_SPEED_1G)
 +			v |= SUPPORTED_1000baseKX_Full;
 +		if (caps & FW_PORT_CAP_SPEED_10G)
 +			v |= SUPPORTED_10000baseKX4_Full;
 +	} else if (type == FW_PORT_TYPE_KR)
 +		v |= SUPPORTED_Backplane | SUPPORTED_10000baseKR_Full;
 +	else if (type == FW_PORT_TYPE_BP_AP)
 +		v |= SUPPORTED_Backplane | SUPPORTED_10000baseR_FEC |
 +		     SUPPORTED_10000baseKR_Full | SUPPORTED_1000baseKX_Full;
 +	else if (type == FW_PORT_TYPE_BP4_AP)
 +		v |= SUPPORTED_Backplane | SUPPORTED_10000baseR_FEC |
 +		     SUPPORTED_10000baseKR_Full | SUPPORTED_1000baseKX_Full |
 +		     SUPPORTED_10000baseKX4_Full;
 +	else if (type == FW_PORT_TYPE_FIBER_XFI ||
 +		 type == FW_PORT_TYPE_FIBER_XAUI ||
 +		 type == FW_PORT_TYPE_SFP ||
 +		 type == FW_PORT_TYPE_QSFP_10G ||
 +		 type == FW_PORT_TYPE_QSA) {
 +		v |= SUPPORTED_FIBRE;
 +		if (caps & FW_PORT_CAP_SPEED_1G)
 +			v |= SUPPORTED_1000baseT_Full;
 +		if (caps & FW_PORT_CAP_SPEED_10G)
 +			v |= SUPPORTED_10000baseT_Full;
 +	} else if (type == FW_PORT_TYPE_BP40_BA ||
 +		   type == FW_PORT_TYPE_QSFP) {
 +		v |= SUPPORTED_40000baseSR4_Full;
 +		v |= SUPPORTED_FIBRE;
 +	}
 +
 +	if (caps & FW_PORT_CAP_ANEG)
 +		v |= SUPPORTED_Autoneg;
 +	return v;
 +}
 +
 +static unsigned int to_fw_linkcaps(unsigned int caps)
 +{
 +	unsigned int v = 0;
 +
 +	if (caps & ADVERTISED_100baseT_Full)
 +		v |= FW_PORT_CAP_SPEED_100M;
 +	if (caps & ADVERTISED_1000baseT_Full)
 +		v |= FW_PORT_CAP_SPEED_1G;
 +	if (caps & ADVERTISED_10000baseT_Full)
 +		v |= FW_PORT_CAP_SPEED_10G;
 +	if (caps & ADVERTISED_40000baseSR4_Full)
 +		v |= FW_PORT_CAP_SPEED_40G;
 +	return v;
 +}
 +
 +static int get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 +{
 +	const struct port_info *p = netdev_priv(dev);
 +
 +	if (p->port_type == FW_PORT_TYPE_BT_SGMII ||
 +	    p->port_type == FW_PORT_TYPE_BT_XFI ||
 +	    p->port_type == FW_PORT_TYPE_BT_XAUI)
 +		cmd->port = PORT_TP;
 +	else if (p->port_type == FW_PORT_TYPE_FIBER_XFI ||
 +		 p->port_type == FW_PORT_TYPE_FIBER_XAUI)
 +		cmd->port = PORT_FIBRE;
 +	else if (p->port_type == FW_PORT_TYPE_SFP ||
 +		 p->port_type == FW_PORT_TYPE_QSFP_10G ||
 +		 p->port_type == FW_PORT_TYPE_QSA ||
 +		 p->port_type == FW_PORT_TYPE_QSFP) {
 +		if (p->mod_type == FW_PORT_MOD_TYPE_LR ||
 +		    p->mod_type == FW_PORT_MOD_TYPE_SR ||
 +		    p->mod_type == FW_PORT_MOD_TYPE_ER ||
 +		    p->mod_type == FW_PORT_MOD_TYPE_LRM)
 +			cmd->port = PORT_FIBRE;
 +		else if (p->mod_type == FW_PORT_MOD_TYPE_TWINAX_PASSIVE ||
 +			 p->mod_type == FW_PORT_MOD_TYPE_TWINAX_ACTIVE)
 +			cmd->port = PORT_DA;
 +		else
 +			cmd->port = PORT_OTHER;
 +	} else
 +		cmd->port = PORT_OTHER;
 +
 +	if (p->mdio_addr >= 0) {
 +		cmd->phy_address = p->mdio_addr;
 +		cmd->transceiver = XCVR_EXTERNAL;
 +		cmd->mdio_support = p->port_type == FW_PORT_TYPE_BT_SGMII ?
 +			MDIO_SUPPORTS_C22 : MDIO_SUPPORTS_C45;
 +	} else {
 +		cmd->phy_address = 0;  /* not really, but no better option */
 +		cmd->transceiver = XCVR_INTERNAL;
 +		cmd->mdio_support = 0;
 +	}
 +
 +	cmd->supported = from_fw_linkcaps(p->port_type, p->link_cfg.supported);
 +	cmd->advertising = from_fw_linkcaps(p->port_type,
 +					    p->link_cfg.advertising);
 +	ethtool_cmd_speed_set(cmd,
 +			      netif_carrier_ok(dev) ? p->link_cfg.speed : 0);
 +	cmd->duplex = DUPLEX_FULL;
 +	cmd->autoneg = p->link_cfg.autoneg;
 +	cmd->maxtxpkt = 0;
 +	cmd->maxrxpkt = 0;
 +	return 0;
 +}
 +
 +static unsigned int speed_to_caps(int speed)
 +{
 +	if (speed == 100)
 +		return FW_PORT_CAP_SPEED_100M;
 +	if (speed == 1000)
 +		return FW_PORT_CAP_SPEED_1G;
 +	if (speed == 10000)
 +		return FW_PORT_CAP_SPEED_10G;
 +	if (speed == 40000)
 +		return FW_PORT_CAP_SPEED_40G;
 +	return 0;
 +}
 +
 +static int set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 +{
 +	unsigned int cap;
 +	struct port_info *p = netdev_priv(dev);
 +	struct link_config *lc = &p->link_cfg;
 +	u32 speed = ethtool_cmd_speed(cmd);
 +
 +	if (cmd->duplex != DUPLEX_FULL)     /* only full-duplex supported */
 +		return -EINVAL;
 +
 +	if (!(lc->supported & FW_PORT_CAP_ANEG)) {
 +		/*
 +		 * PHY offers a single speed.  See if that's what's
 +		 * being requested.
 +		 */
 +		if (cmd->autoneg == AUTONEG_DISABLE &&
 +		    (lc->supported & speed_to_caps(speed)))
 +			return 0;
 +		return -EINVAL;
 +	}
 +
 +	if (cmd->autoneg == AUTONEG_DISABLE) {
 +		cap = speed_to_caps(speed);
 +
 +		if (!(lc->supported & cap) ||
 +		    (speed == 1000) ||
 +		    (speed == 10000) ||
 +		    (speed == 40000))
 +			return -EINVAL;
 +		lc->requested_speed = cap;
 +		lc->advertising = 0;
 +	} else {
 +		cap = to_fw_linkcaps(cmd->advertising);
 +		if (!(lc->supported & cap))
 +			return -EINVAL;
 +		lc->requested_speed = 0;
 +		lc->advertising = cap | FW_PORT_CAP_ANEG;
 +	}
 +	lc->autoneg = cmd->autoneg;
 +
 +	if (netif_running(dev))
 +		return t4_link_start(p->adapter, p->adapter->fn, p->tx_chan,
 +				     lc);
 +	return 0;
  }
  
 +static void get_pauseparam(struct net_device *dev,
 +			   struct ethtool_pauseparam *epause)
 +{
 +	struct port_info *p = netdev_priv(dev);
 +
 +	epause->autoneg = (p->link_cfg.requested_fc & PAUSE_AUTONEG) != 0;
 +	epause->rx_pause = (p->link_cfg.fc & PAUSE_RX) != 0;
 +	epause->tx_pause = (p->link_cfg.fc & PAUSE_TX) != 0;
 +}
 +
 +static int set_pauseparam(struct net_device *dev,
 +			  struct ethtool_pauseparam *epause)
 +{
 +	struct port_info *p = netdev_priv(dev);
 +	struct link_config *lc = &p->link_cfg;
 +
 +	if (epause->autoneg == AUTONEG_DISABLE)
 +		lc->requested_fc = 0;
 +	else if (lc->supported & FW_PORT_CAP_ANEG)
 +		lc->requested_fc = PAUSE_AUTONEG;
 +	else
 +		return -EINVAL;
 +
 +	if (epause->rx_pause)
 +		lc->requested_fc |= PAUSE_RX;
 +	if (epause->tx_pause)
 +		lc->requested_fc |= PAUSE_TX;
 +	if (netif_running(dev))
 +		return t4_link_start(p->adapter, p->adapter->fn, p->tx_chan,
 +				     lc);
 +	return 0;
 +}
 +
 +static void get_sge_param(struct net_device *dev, struct ethtool_ringparam *e)
 +{
 +	const struct port_info *pi = netdev_priv(dev);
 +	const struct sge *s = &pi->adapter->sge;
 +
 +	e->rx_max_pending = MAX_RX_BUFFERS;
 +	e->rx_mini_max_pending = MAX_RSPQ_ENTRIES;
 +	e->rx_jumbo_max_pending = 0;
 +	e->tx_max_pending = MAX_TXQ_ENTRIES;
 +
 +	e->rx_pending = s->ethrxq[pi->first_qset].fl.size - 8;
 +	e->rx_mini_pending = s->ethrxq[pi->first_qset].rspq.size;
 +	e->rx_jumbo_pending = 0;
 +	e->tx_pending = s->ethtxq[pi->first_qset].q.size;
 +}
 +
 +static int set_sge_param(struct net_device *dev, struct ethtool_ringparam *e)
 +{
 +	int i;
 +	const struct port_info *pi = netdev_priv(dev);
 +	struct adapter *adapter = pi->adapter;
 +	struct sge *s = &adapter->sge;
 +
 +	if (e->rx_pending > MAX_RX_BUFFERS || e->rx_jumbo_pending ||
 +	    e->tx_pending > MAX_TXQ_ENTRIES ||
 +	    e->rx_mini_pending > MAX_RSPQ_ENTRIES ||
 +	    e->rx_mini_pending < MIN_RSPQ_ENTRIES ||
 +	    e->rx_pending < MIN_FL_ENTRIES || e->tx_pending < MIN_TXQ_ENTRIES)
 +		return -EINVAL;
 +
 +	if (adapter->flags & FULL_INIT_DONE)
 +		return -EBUSY;
 +
 +	for (i = 0; i < pi->nqsets; ++i) {
 +		s->ethtxq[pi->first_qset + i].q.size = e->tx_pending;
 +		s->ethrxq[pi->first_qset + i].fl.size = e->rx_pending + 8;
 +		s->ethrxq[pi->first_qset + i].rspq.size = e->rx_mini_pending;
 +	}
 +	return 0;
 +}
 +
++=======
++>>>>>>> 812034f11628 (cxgb4: Move ethtool related code to a separate file)
  static int closest_timer(const struct sge *s, int time)
  {
  	int i, delta, match = 0, min_delta = INT_MAX;
@@@ -2542,19 -1351,8 +2553,22 @@@ static int closest_thres(const struct s
  	return match;
  }
  
++<<<<<<< HEAD
 +/*
 + * Return a queue's interrupt hold-off time in us.  0 means no timer.
 + */
 +static unsigned int qtimer_val(const struct adapter *adap,
 +			       const struct sge_rspq *q)
 +{
 +	unsigned int idx = q->intr_params >> 1;
 +
 +	return idx < SGE_NTIMERS ? adap->sge.timer_val[idx] : 0;
 +}
 +
++=======
++>>>>>>> 812034f11628 (cxgb4: Move ethtool related code to a separate file)
  /**
-  *	set_rspq_intr_params - set a queue's interrupt holdoff parameters
+  *	cxgb4_set_rspq_intr_params - set a queue's interrupt holdoff parameters
   *	@q: the Rx queue
   *	@us: the hold-off time in us, or 0 to disable timer
   *	@cnt: the hold-off packet count, or 0 to disable counter
@@@ -2593,259 -1392,6 +2607,262 @@@ int cxgb4_set_rspq_intr_params(struct s
  	return 0;
  }
  
++<<<<<<< HEAD
 +/**
 + * set_rx_intr_params - set a net devices's RX interrupt holdoff paramete!
 + * @dev: the network device
 + * @us: the hold-off time in us, or 0 to disable timer
 + * @cnt: the hold-off packet count, or 0 to disable counter
 + *
 + * Set the RX interrupt hold-off parameters for a network device.
 + */
 +static int set_rx_intr_params(struct net_device *dev,
 +			      unsigned int us, unsigned int cnt)
 +{
 +	int i, err;
 +	struct port_info *pi = netdev_priv(dev);
 +	struct adapter *adap = pi->adapter;
 +	struct sge_eth_rxq *q = &adap->sge.ethrxq[pi->first_qset];
 +
 +	for (i = 0; i < pi->nqsets; i++, q++) {
 +		err = set_rspq_intr_params(&q->rspq, us, cnt);
 +		if (err)
 +			return err;
 +	}
 +	return 0;
 +}
 +
 +static int set_adaptive_rx_setting(struct net_device *dev, int adaptive_rx)
 +{
 +	int i;
 +	struct port_info *pi = netdev_priv(dev);
 +	struct adapter *adap = pi->adapter;
 +	struct sge_eth_rxq *q = &adap->sge.ethrxq[pi->first_qset];
 +
 +	for (i = 0; i < pi->nqsets; i++, q++)
 +		q->rspq.adaptive_rx = adaptive_rx;
 +
 +	return 0;
 +}
 +
 +static int get_adaptive_rx_setting(struct net_device *dev)
 +{
 +	struct port_info *pi = netdev_priv(dev);
 +	struct adapter *adap = pi->adapter;
 +	struct sge_eth_rxq *q = &adap->sge.ethrxq[pi->first_qset];
 +
 +	return q->rspq.adaptive_rx;
 +}
 +
 +static int set_coalesce(struct net_device *dev, struct ethtool_coalesce *c)
 +{
 +	set_adaptive_rx_setting(dev, c->use_adaptive_rx_coalesce);
 +	return set_rx_intr_params(dev, c->rx_coalesce_usecs,
 +				  c->rx_max_coalesced_frames);
 +}
 +
 +static int get_coalesce(struct net_device *dev, struct ethtool_coalesce *c)
 +{
 +	const struct port_info *pi = netdev_priv(dev);
 +	const struct adapter *adap = pi->adapter;
 +	const struct sge_rspq *rq = &adap->sge.ethrxq[pi->first_qset].rspq;
 +
 +	c->rx_coalesce_usecs = qtimer_val(adap, rq);
 +	c->rx_max_coalesced_frames = (rq->intr_params & QINTR_CNT_EN) ?
 +		adap->sge.counter_val[rq->pktcnt_idx] : 0;
 +	c->use_adaptive_rx_coalesce = get_adaptive_rx_setting(dev);
 +	return 0;
 +}
 +
 +/**
 + *	eeprom_ptov - translate a physical EEPROM address to virtual
 + *	@phys_addr: the physical EEPROM address
 + *	@fn: the PCI function number
 + *	@sz: size of function-specific area
 + *
 + *	Translate a physical EEPROM address to virtual.  The first 1K is
 + *	accessed through virtual addresses starting at 31K, the rest is
 + *	accessed through virtual addresses starting at 0.
 + *
 + *	The mapping is as follows:
 + *	[0..1K) -> [31K..32K)
 + *	[1K..1K+A) -> [31K-A..31K)
 + *	[1K+A..ES) -> [0..ES-A-1K)
 + *
 + *	where A = @fn * @sz, and ES = EEPROM size.
 + */
 +static int eeprom_ptov(unsigned int phys_addr, unsigned int fn, unsigned int sz)
 +{
 +	fn *= sz;
 +	if (phys_addr < 1024)
 +		return phys_addr + (31 << 10);
 +	if (phys_addr < 1024 + fn)
 +		return 31744 - fn + phys_addr - 1024;
 +	if (phys_addr < EEPROMSIZE)
 +		return phys_addr - 1024 - fn;
 +	return -EINVAL;
 +}
 +
 +/*
 + * The next two routines implement eeprom read/write from physical addresses.
 + */
 +static int eeprom_rd_phys(struct adapter *adap, unsigned int phys_addr, u32 *v)
 +{
 +	int vaddr = eeprom_ptov(phys_addr, adap->fn, EEPROMPFSIZE);
 +
 +	if (vaddr >= 0)
 +		vaddr = pci_read_vpd(adap->pdev, vaddr, sizeof(u32), v);
 +	return vaddr < 0 ? vaddr : 0;
 +}
 +
 +static int eeprom_wr_phys(struct adapter *adap, unsigned int phys_addr, u32 v)
 +{
 +	int vaddr = eeprom_ptov(phys_addr, adap->fn, EEPROMPFSIZE);
 +
 +	if (vaddr >= 0)
 +		vaddr = pci_write_vpd(adap->pdev, vaddr, sizeof(u32), &v);
 +	return vaddr < 0 ? vaddr : 0;
 +}
 +
 +#define EEPROM_MAGIC 0x38E2F10C
 +
 +static int get_eeprom(struct net_device *dev, struct ethtool_eeprom *e,
 +		      u8 *data)
 +{
 +	int i, err = 0;
 +	struct adapter *adapter = netdev2adap(dev);
 +
 +	u8 *buf = kmalloc(EEPROMSIZE, GFP_KERNEL);
 +	if (!buf)
 +		return -ENOMEM;
 +
 +	e->magic = EEPROM_MAGIC;
 +	for (i = e->offset & ~3; !err && i < e->offset + e->len; i += 4)
 +		err = eeprom_rd_phys(adapter, i, (u32 *)&buf[i]);
 +
 +	if (!err)
 +		memcpy(data, buf + e->offset, e->len);
 +	kfree(buf);
 +	return err;
 +}
 +
 +static int set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,
 +		      u8 *data)
 +{
 +	u8 *buf;
 +	int err = 0;
 +	u32 aligned_offset, aligned_len, *p;
 +	struct adapter *adapter = netdev2adap(dev);
 +
 +	if (eeprom->magic != EEPROM_MAGIC)
 +		return -EINVAL;
 +
 +	aligned_offset = eeprom->offset & ~3;
 +	aligned_len = (eeprom->len + (eeprom->offset & 3) + 3) & ~3;
 +
 +	if (adapter->fn > 0) {
 +		u32 start = 1024 + adapter->fn * EEPROMPFSIZE;
 +
 +		if (aligned_offset < start ||
 +		    aligned_offset + aligned_len > start + EEPROMPFSIZE)
 +			return -EPERM;
 +	}
 +
 +	if (aligned_offset != eeprom->offset || aligned_len != eeprom->len) {
 +		/*
 +		 * RMW possibly needed for first or last words.
 +		 */
 +		buf = kmalloc(aligned_len, GFP_KERNEL);
 +		if (!buf)
 +			return -ENOMEM;
 +		err = eeprom_rd_phys(adapter, aligned_offset, (u32 *)buf);
 +		if (!err && aligned_len > 4)
 +			err = eeprom_rd_phys(adapter,
 +					     aligned_offset + aligned_len - 4,
 +					     (u32 *)&buf[aligned_len - 4]);
 +		if (err)
 +			goto out;
 +		memcpy(buf + (eeprom->offset & 3), data, eeprom->len);
 +	} else
 +		buf = data;
 +
 +	err = t4_seeprom_wp(adapter, false);
 +	if (err)
 +		goto out;
 +
 +	for (p = (u32 *)buf; !err && aligned_len; aligned_len -= 4, p++) {
 +		err = eeprom_wr_phys(adapter, aligned_offset, *p);
 +		aligned_offset += 4;
 +	}
 +
 +	if (!err)
 +		err = t4_seeprom_wp(adapter, true);
 +out:
 +	if (buf != data)
 +		kfree(buf);
 +	return err;
 +}
 +
 +static int set_flash(struct net_device *netdev, struct ethtool_flash *ef)
 +{
 +	int ret;
 +	const struct firmware *fw;
 +	struct adapter *adap = netdev2adap(netdev);
 +	unsigned int mbox = FW_PCIE_FW_MASTER_MASK + 1;
 +
 +	ef->data[sizeof(ef->data) - 1] = '\0';
 +	ret = request_firmware(&fw, ef->data, adap->pdev_dev);
 +	if (ret < 0)
 +		return ret;
 +
 +	/* If the adapter has been fully initialized then we'll go ahead and
 +	 * try to get the firmware's cooperation in upgrading to the new
 +	 * firmware image otherwise we'll try to do the entire job from the
 +	 * host ... and we always "force" the operation in this path.
 +	 */
 +	if (adap->flags & FULL_INIT_DONE)
 +		mbox = adap->mbox;
 +
 +	ret = t4_fw_upgrade(adap, mbox, fw->data, fw->size, 1);
 +	release_firmware(fw);
 +	if (!ret)
 +		dev_info(adap->pdev_dev, "loaded firmware %s,"
 +			 " reload cxgb4 driver\n", ef->data);
 +	return ret;
 +}
 +
 +#define WOL_SUPPORTED (WAKE_BCAST | WAKE_MAGIC)
 +#define BCAST_CRC 0xa0ccc1a6
 +
 +static void get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 +{
 +	wol->supported = WAKE_BCAST | WAKE_MAGIC;
 +	wol->wolopts = netdev2adap(dev)->wol;
 +	memset(&wol->sopass, 0, sizeof(wol->sopass));
 +}
 +
 +static int set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 +{
 +	int err = 0;
 +	struct port_info *pi = netdev_priv(dev);
 +
 +	if (wol->wolopts & ~WOL_SUPPORTED)
 +		return -EINVAL;
 +	t4_wol_magic_enable(pi->adapter, pi->tx_chan,
 +			    (wol->wolopts & WAKE_MAGIC) ? dev->dev_addr : NULL);
 +	if (wol->wolopts & WAKE_BCAST) {
 +		err = t4_wol_pat_enable(pi->adapter, pi->tx_chan, 0xfe, ~0ULL,
 +					~0ULL, 0, false);
 +		if (!err)
 +			err = t4_wol_pat_enable(pi->adapter, pi->tx_chan, 1,
 +						~6ULL, ~0ULL, BCAST_CRC, true);
 +	} else
 +		t4_wol_pat_enable(pi->adapter, pi->tx_chan, 0, 0, 0, 0, false);
 +	return err;
 +}
 +
++=======
++>>>>>>> 812034f11628 (cxgb4: Move ethtool related code to a separate file)
  static int cxgb_set_features(struct net_device *dev, netdev_features_t features)
  {
  	const struct port_info *pi = netdev_priv(dev);
@@@ -2863,194 -1409,8 +2880,197 @@@
  	return err;
  }
  
++<<<<<<< HEAD
 +static u32 get_rss_table_size(struct net_device *dev)
 +{
 +	const struct port_info *pi = netdev_priv(dev);
 +
 +	return pi->rss_size;
 +}
 +
 +static int get_rss_table(struct net_device *dev, u32 *p)
 +{
 +	const struct port_info *pi = netdev_priv(dev);
 +	unsigned int n = pi->rss_size;
 +
 +	while (n--)
 +		p[n] = pi->rss[n];
 +	return 0;
 +}
 +
 +static int set_rss_table(struct net_device *dev, const u32 *p)
 +{
 +	unsigned int i;
 +	struct port_info *pi = netdev_priv(dev);
 +
 +	for (i = 0; i < pi->rss_size; i++)
 +		pi->rss[i] = p[i];
 +	if (pi->adapter->flags & FULL_INIT_DONE)
 +		return write_rss(pi, pi->rss);
 +	return 0;
 +}
 +
 +static int get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,
 +		     u32 *rules)
 +{
 +	const struct port_info *pi = netdev_priv(dev);
 +
 +	switch (info->cmd) {
 +	case ETHTOOL_GRXFH: {
 +		unsigned int v = pi->rss_mode;
 +
 +		info->data = 0;
 +		switch (info->flow_type) {
 +		case TCP_V4_FLOW:
 +			if (v & FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN)
 +				info->data = RXH_IP_SRC | RXH_IP_DST |
 +					     RXH_L4_B_0_1 | RXH_L4_B_2_3;
 +			else if (v & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN)
 +				info->data = RXH_IP_SRC | RXH_IP_DST;
 +			break;
 +		case UDP_V4_FLOW:
 +			if ((v & FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN) &&
 +			    (v & FW_RSS_VI_CONFIG_CMD_UDPEN))
 +				info->data = RXH_IP_SRC | RXH_IP_DST |
 +					     RXH_L4_B_0_1 | RXH_L4_B_2_3;
 +			else if (v & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN)
 +				info->data = RXH_IP_SRC | RXH_IP_DST;
 +			break;
 +		case SCTP_V4_FLOW:
 +		case AH_ESP_V4_FLOW:
 +		case IPV4_FLOW:
 +			if (v & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN)
 +				info->data = RXH_IP_SRC | RXH_IP_DST;
 +			break;
 +		case TCP_V6_FLOW:
 +			if (v & FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN)
 +				info->data = RXH_IP_SRC | RXH_IP_DST |
 +					     RXH_L4_B_0_1 | RXH_L4_B_2_3;
 +			else if (v & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN)
 +				info->data = RXH_IP_SRC | RXH_IP_DST;
 +			break;
 +		case UDP_V6_FLOW:
 +			if ((v & FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN) &&
 +			    (v & FW_RSS_VI_CONFIG_CMD_UDPEN))
 +				info->data = RXH_IP_SRC | RXH_IP_DST |
 +					     RXH_L4_B_0_1 | RXH_L4_B_2_3;
 +			else if (v & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN)
 +				info->data = RXH_IP_SRC | RXH_IP_DST;
 +			break;
 +		case SCTP_V6_FLOW:
 +		case AH_ESP_V6_FLOW:
 +		case IPV6_FLOW:
 +			if (v & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN)
 +				info->data = RXH_IP_SRC | RXH_IP_DST;
 +			break;
 +		}
 +		return 0;
 +	}
 +	case ETHTOOL_GRXRINGS:
 +		info->data = pi->nqsets;
 +		return 0;
 +	}
 +	return -EOPNOTSUPP;
 +}
 +
 +static const struct ethtool_ops cxgb_ethtool_ops = {
 +	.get_settings      = get_settings,
 +	.set_settings      = set_settings,
 +	.get_drvinfo       = get_drvinfo,
 +	.get_msglevel      = get_msglevel,
 +	.set_msglevel      = set_msglevel,
 +	.get_ringparam     = get_sge_param,
 +	.set_ringparam     = set_sge_param,
 +	.get_coalesce      = get_coalesce,
 +	.set_coalesce      = set_coalesce,
 +	.get_eeprom_len    = get_eeprom_len,
 +	.get_eeprom        = get_eeprom,
 +	.set_eeprom        = set_eeprom,
 +	.get_pauseparam    = get_pauseparam,
 +	.set_pauseparam    = set_pauseparam,
 +	.get_link          = ethtool_op_get_link,
 +	.get_strings       = get_strings,
 +	.set_phys_id       = identify_port,
 +	.nway_reset        = restart_autoneg,
 +	.get_sset_count    = get_sset_count,
 +	.get_ethtool_stats = get_stats,
 +	.get_regs_len      = get_regs_len,
 +	.get_regs          = get_regs,
 +	.get_wol           = get_wol,
 +	.set_wol           = set_wol,
 +	.get_rxnfc         = get_rxnfc,
 +	.get_rxfh_indir_size = get_rss_table_size,
 +	.get_rxfh_indir    = get_rss_table,
 +	.set_rxfh_indir    = set_rss_table,
 +	.flash_device      = set_flash,
 +};
 +
 +/*
 + * debugfs support
 + */
 +static ssize_t mem_read(struct file *file, char __user *buf, size_t count,
 +			loff_t *ppos)
 +{
 +	loff_t pos = *ppos;
 +	loff_t avail = file_inode(file)->i_size;
 +	unsigned int mem = (uintptr_t)file->private_data & 3;
 +	struct adapter *adap = file->private_data - mem;
 +	__be32 *data;
 +	int ret;
 +
 +	if (pos < 0)
 +		return -EINVAL;
 +	if (pos >= avail)
 +		return 0;
 +	if (count > avail - pos)
 +		count = avail - pos;
 +
 +	data = t4_alloc_mem(count);
 +	if (!data)
 +		return -ENOMEM;
 +
 +	spin_lock(&adap->win0_lock);
 +	ret = t4_memory_rw(adap, 0, mem, pos, count, data, T4_MEMORY_READ);
 +	spin_unlock(&adap->win0_lock);
 +	if (ret) {
 +		t4_free_mem(data);
 +		return ret;
 +	}
 +	ret = copy_to_user(buf, data, count);
 +
 +	t4_free_mem(data);
 +	if (ret)
 +		return -EFAULT;
 +
 +	*ppos = pos + count;
 +	return count;
 +}
 +
 +static const struct file_operations mem_debugfs_fops = {
 +	.owner   = THIS_MODULE,
 +	.open    = simple_open,
 +	.read    = mem_read,
 +	.llseek  = default_llseek,
 +};
 +
 +static void add_debugfs_mem(struct adapter *adap, const char *name,
 +			    unsigned int idx, unsigned int size_mb)
 +{
 +	struct dentry *de;
 +
 +	de = debugfs_create_file(name, S_IRUSR, adap->debugfs_root,
 +				 (void *)adap + idx, &mem_debugfs_fops);
 +	if (de && de->d_inode)
 +		de->d_inode->i_size = size_mb << 20;
 +}
 +
++=======
++>>>>>>> 812034f11628 (cxgb4: Move ethtool related code to a separate file)
  static int setup_debugfs(struct adapter *adap)
  {
 +	int i;
 +	u32 size;
 +
  	if (IS_ERR_OR_NULL(adap->debugfs_root))
  		return -1;
  
@@@ -6505,7 -4584,11 +6525,15 @@@ static int init_one(struct pci_dev *pde
  		netdev->priv_flags |= IFF_UNICAST_FLT;
  
  		netdev->netdev_ops = &cxgb4_netdev_ops;
++<<<<<<< HEAD
 +		SET_ETHTOOL_OPS(netdev, &cxgb_ethtool_ops);
++=======
+ #ifdef CONFIG_CHELSIO_T4_DCB
+ 		netdev->dcbnl_ops = &cxgb4_dcb_ops;
+ 		cxgb4_dcb_state_init(netdev);
+ #endif
+ 		cxgb4_set_ethtool_ops(netdev);
++>>>>>>> 812034f11628 (cxgb4: Move ethtool related code to a separate file)
  	}
  
  	pci_set_drvdata(pdev, adapter);
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/Makefile
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c
new file mode 100644
index 000000000000..10d82b51d7ef
--- /dev/null
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_ethtool.c
@@ -0,0 +1,915 @@
+/*
+ *  Copyright (C) 2013-2015 Chelsio Communications.  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms and conditions of the GNU General Public License,
+ *  version 2, as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  The full GNU General Public License is included in this distribution in
+ *  the file called "COPYING".
+ *
+ */
+
+#include <linux/firmware.h>
+#include <linux/mdio.h>
+
+#include "cxgb4.h"
+#include "t4_regs.h"
+#include "t4fw_api.h"
+
+#define EEPROM_MAGIC 0x38E2F10C
+
+static u32 get_msglevel(struct net_device *dev)
+{
+	return netdev2adap(dev)->msg_enable;
+}
+
+static void set_msglevel(struct net_device *dev, u32 val)
+{
+	netdev2adap(dev)->msg_enable = val;
+}
+
+static const char stats_strings[][ETH_GSTRING_LEN] = {
+	"TxOctetsOK         ",
+	"TxFramesOK         ",
+	"TxBroadcastFrames  ",
+	"TxMulticastFrames  ",
+	"TxUnicastFrames    ",
+	"TxErrorFrames      ",
+
+	"TxFrames64         ",
+	"TxFrames65To127    ",
+	"TxFrames128To255   ",
+	"TxFrames256To511   ",
+	"TxFrames512To1023  ",
+	"TxFrames1024To1518 ",
+	"TxFrames1519ToMax  ",
+
+	"TxFramesDropped    ",
+	"TxPauseFrames      ",
+	"TxPPP0Frames       ",
+	"TxPPP1Frames       ",
+	"TxPPP2Frames       ",
+	"TxPPP3Frames       ",
+	"TxPPP4Frames       ",
+	"TxPPP5Frames       ",
+	"TxPPP6Frames       ",
+	"TxPPP7Frames       ",
+
+	"RxOctetsOK         ",
+	"RxFramesOK         ",
+	"RxBroadcastFrames  ",
+	"RxMulticastFrames  ",
+	"RxUnicastFrames    ",
+
+	"RxFramesTooLong    ",
+	"RxJabberErrors     ",
+	"RxFCSErrors        ",
+	"RxLengthErrors     ",
+	"RxSymbolErrors     ",
+	"RxRuntFrames       ",
+
+	"RxFrames64         ",
+	"RxFrames65To127    ",
+	"RxFrames128To255   ",
+	"RxFrames256To511   ",
+	"RxFrames512To1023  ",
+	"RxFrames1024To1518 ",
+	"RxFrames1519ToMax  ",
+
+	"RxPauseFrames      ",
+	"RxPPP0Frames       ",
+	"RxPPP1Frames       ",
+	"RxPPP2Frames       ",
+	"RxPPP3Frames       ",
+	"RxPPP4Frames       ",
+	"RxPPP5Frames       ",
+	"RxPPP6Frames       ",
+	"RxPPP7Frames       ",
+
+	"RxBG0FramesDropped ",
+	"RxBG1FramesDropped ",
+	"RxBG2FramesDropped ",
+	"RxBG3FramesDropped ",
+	"RxBG0FramesTrunc   ",
+	"RxBG1FramesTrunc   ",
+	"RxBG2FramesTrunc   ",
+	"RxBG3FramesTrunc   ",
+
+	"TSO                ",
+	"TxCsumOffload      ",
+	"RxCsumGood         ",
+	"VLANextractions    ",
+	"VLANinsertions     ",
+	"GROpackets         ",
+	"GROmerged          ",
+	"WriteCoalSuccess   ",
+	"WriteCoalFail      ",
+};
+
+static int get_sset_count(struct net_device *dev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return ARRAY_SIZE(stats_strings);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static int get_regs_len(struct net_device *dev)
+{
+	struct adapter *adap = netdev2adap(dev);
+
+	return t4_get_regs_len(adap);
+}
+
+static int get_eeprom_len(struct net_device *dev)
+{
+	return EEPROMSIZE;
+}
+
+static void get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
+{
+	struct adapter *adapter = netdev2adap(dev);
+	u32 exprom_vers;
+
+	strlcpy(info->driver, cxgb4_driver_name, sizeof(info->driver));
+	strlcpy(info->version, cxgb4_driver_version,
+		sizeof(info->version));
+	strlcpy(info->bus_info, pci_name(adapter->pdev),
+		sizeof(info->bus_info));
+
+	if (adapter->params.fw_vers)
+		snprintf(info->fw_version, sizeof(info->fw_version),
+			 "%u.%u.%u.%u, TP %u.%u.%u.%u",
+			 FW_HDR_FW_VER_MAJOR_G(adapter->params.fw_vers),
+			 FW_HDR_FW_VER_MINOR_G(adapter->params.fw_vers),
+			 FW_HDR_FW_VER_MICRO_G(adapter->params.fw_vers),
+			 FW_HDR_FW_VER_BUILD_G(adapter->params.fw_vers),
+			 FW_HDR_FW_VER_MAJOR_G(adapter->params.tp_vers),
+			 FW_HDR_FW_VER_MINOR_G(adapter->params.tp_vers),
+			 FW_HDR_FW_VER_MICRO_G(adapter->params.tp_vers),
+			 FW_HDR_FW_VER_BUILD_G(adapter->params.tp_vers));
+
+	if (!t4_get_exprom_version(adapter, &exprom_vers))
+		snprintf(info->erom_version, sizeof(info->erom_version),
+			 "%u.%u.%u.%u",
+			 FW_HDR_FW_VER_MAJOR_G(exprom_vers),
+			 FW_HDR_FW_VER_MINOR_G(exprom_vers),
+			 FW_HDR_FW_VER_MICRO_G(exprom_vers),
+			 FW_HDR_FW_VER_BUILD_G(exprom_vers));
+}
+
+static void get_strings(struct net_device *dev, u32 stringset, u8 *data)
+{
+	if (stringset == ETH_SS_STATS)
+		memcpy(data, stats_strings, sizeof(stats_strings));
+}
+
+/* port stats maintained per queue of the port. They should be in the same
+ * order as in stats_strings above.
+ */
+struct queue_port_stats {
+	u64 tso;
+	u64 tx_csum;
+	u64 rx_csum;
+	u64 vlan_ex;
+	u64 vlan_ins;
+	u64 gro_pkts;
+	u64 gro_merged;
+};
+
+static void collect_sge_port_stats(const struct adapter *adap,
+				   const struct port_info *p,
+				   struct queue_port_stats *s)
+{
+	int i;
+	const struct sge_eth_txq *tx = &adap->sge.ethtxq[p->first_qset];
+	const struct sge_eth_rxq *rx = &adap->sge.ethrxq[p->first_qset];
+
+	memset(s, 0, sizeof(*s));
+	for (i = 0; i < p->nqsets; i++, rx++, tx++) {
+		s->tso += tx->tso;
+		s->tx_csum += tx->tx_cso;
+		s->rx_csum += rx->stats.rx_cso;
+		s->vlan_ex += rx->stats.vlan_ex;
+		s->vlan_ins += tx->vlan_ins;
+		s->gro_pkts += rx->stats.lro_pkts;
+		s->gro_merged += rx->stats.lro_merged;
+	}
+}
+
+static void get_stats(struct net_device *dev, struct ethtool_stats *stats,
+		      u64 *data)
+{
+	struct port_info *pi = netdev_priv(dev);
+	struct adapter *adapter = pi->adapter;
+	u32 val1, val2;
+
+	t4_get_port_stats(adapter, pi->tx_chan, (struct port_stats *)data);
+
+	data += sizeof(struct port_stats) / sizeof(u64);
+	collect_sge_port_stats(adapter, pi, (struct queue_port_stats *)data);
+	data += sizeof(struct queue_port_stats) / sizeof(u64);
+	if (!is_t4(adapter->params.chip)) {
+		t4_write_reg(adapter, SGE_STAT_CFG_A, STATSOURCE_T5_V(7));
+		val1 = t4_read_reg(adapter, SGE_STAT_TOTAL_A);
+		val2 = t4_read_reg(adapter, SGE_STAT_MATCH_A);
+		*data = val1 - val2;
+		data++;
+		*data = val2;
+		data++;
+	} else {
+		memset(data, 0, 2 * sizeof(u64));
+		*data += 2;
+	}
+}
+
+static void get_regs(struct net_device *dev, struct ethtool_regs *regs,
+		     void *buf)
+{
+	struct adapter *adap = netdev2adap(dev);
+	size_t buf_size;
+
+	buf_size = t4_get_regs_len(adap);
+	regs->version = mk_adap_vers(adap);
+	t4_get_regs(adap, buf, buf_size);
+}
+
+static int restart_autoneg(struct net_device *dev)
+{
+	struct port_info *p = netdev_priv(dev);
+
+	if (!netif_running(dev))
+		return -EAGAIN;
+	if (p->link_cfg.autoneg != AUTONEG_ENABLE)
+		return -EINVAL;
+	t4_restart_aneg(p->adapter, p->adapter->fn, p->tx_chan);
+	return 0;
+}
+
+static int identify_port(struct net_device *dev,
+			 enum ethtool_phys_id_state state)
+{
+	unsigned int val;
+	struct adapter *adap = netdev2adap(dev);
+
+	if (state == ETHTOOL_ID_ACTIVE)
+		val = 0xffff;
+	else if (state == ETHTOOL_ID_INACTIVE)
+		val = 0;
+	else
+		return -EINVAL;
+
+	return t4_identify_port(adap, adap->fn, netdev2pinfo(dev)->viid, val);
+}
+
+static unsigned int from_fw_linkcaps(enum fw_port_type type, unsigned int caps)
+{
+	unsigned int v = 0;
+
+	if (type == FW_PORT_TYPE_BT_SGMII || type == FW_PORT_TYPE_BT_XFI ||
+	    type == FW_PORT_TYPE_BT_XAUI) {
+		v |= SUPPORTED_TP;
+		if (caps & FW_PORT_CAP_SPEED_100M)
+			v |= SUPPORTED_100baseT_Full;
+		if (caps & FW_PORT_CAP_SPEED_1G)
+			v |= SUPPORTED_1000baseT_Full;
+		if (caps & FW_PORT_CAP_SPEED_10G)
+			v |= SUPPORTED_10000baseT_Full;
+	} else if (type == FW_PORT_TYPE_KX4 || type == FW_PORT_TYPE_KX) {
+		v |= SUPPORTED_Backplane;
+		if (caps & FW_PORT_CAP_SPEED_1G)
+			v |= SUPPORTED_1000baseKX_Full;
+		if (caps & FW_PORT_CAP_SPEED_10G)
+			v |= SUPPORTED_10000baseKX4_Full;
+	} else if (type == FW_PORT_TYPE_KR) {
+		v |= SUPPORTED_Backplane | SUPPORTED_10000baseKR_Full;
+	} else if (type == FW_PORT_TYPE_BP_AP) {
+		v |= SUPPORTED_Backplane | SUPPORTED_10000baseR_FEC |
+		     SUPPORTED_10000baseKR_Full | SUPPORTED_1000baseKX_Full;
+	} else if (type == FW_PORT_TYPE_BP4_AP) {
+		v |= SUPPORTED_Backplane | SUPPORTED_10000baseR_FEC |
+		     SUPPORTED_10000baseKR_Full | SUPPORTED_1000baseKX_Full |
+		     SUPPORTED_10000baseKX4_Full;
+	} else if (type == FW_PORT_TYPE_FIBER_XFI ||
+		   type == FW_PORT_TYPE_FIBER_XAUI ||
+		   type == FW_PORT_TYPE_SFP ||
+		   type == FW_PORT_TYPE_QSFP_10G ||
+		   type == FW_PORT_TYPE_QSA) {
+		v |= SUPPORTED_FIBRE;
+		if (caps & FW_PORT_CAP_SPEED_1G)
+			v |= SUPPORTED_1000baseT_Full;
+		if (caps & FW_PORT_CAP_SPEED_10G)
+			v |= SUPPORTED_10000baseT_Full;
+	} else if (type == FW_PORT_TYPE_BP40_BA ||
+		   type == FW_PORT_TYPE_QSFP) {
+		v |= SUPPORTED_40000baseSR4_Full;
+		v |= SUPPORTED_FIBRE;
+	}
+
+	if (caps & FW_PORT_CAP_ANEG)
+		v |= SUPPORTED_Autoneg;
+	return v;
+}
+
+static unsigned int to_fw_linkcaps(unsigned int caps)
+{
+	unsigned int v = 0;
+
+	if (caps & ADVERTISED_100baseT_Full)
+		v |= FW_PORT_CAP_SPEED_100M;
+	if (caps & ADVERTISED_1000baseT_Full)
+		v |= FW_PORT_CAP_SPEED_1G;
+	if (caps & ADVERTISED_10000baseT_Full)
+		v |= FW_PORT_CAP_SPEED_10G;
+	if (caps & ADVERTISED_40000baseSR4_Full)
+		v |= FW_PORT_CAP_SPEED_40G;
+	return v;
+}
+
+static int get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	const struct port_info *p = netdev_priv(dev);
+
+	if (p->port_type == FW_PORT_TYPE_BT_SGMII ||
+	    p->port_type == FW_PORT_TYPE_BT_XFI ||
+	    p->port_type == FW_PORT_TYPE_BT_XAUI) {
+		cmd->port = PORT_TP;
+	} else if (p->port_type == FW_PORT_TYPE_FIBER_XFI ||
+		   p->port_type == FW_PORT_TYPE_FIBER_XAUI) {
+		cmd->port = PORT_FIBRE;
+	} else if (p->port_type == FW_PORT_TYPE_SFP ||
+		   p->port_type == FW_PORT_TYPE_QSFP_10G ||
+		   p->port_type == FW_PORT_TYPE_QSA ||
+		   p->port_type == FW_PORT_TYPE_QSFP) {
+		if (p->mod_type == FW_PORT_MOD_TYPE_LR ||
+		    p->mod_type == FW_PORT_MOD_TYPE_SR ||
+		    p->mod_type == FW_PORT_MOD_TYPE_ER ||
+		    p->mod_type == FW_PORT_MOD_TYPE_LRM)
+			cmd->port = PORT_FIBRE;
+		else if (p->mod_type == FW_PORT_MOD_TYPE_TWINAX_PASSIVE ||
+			 p->mod_type == FW_PORT_MOD_TYPE_TWINAX_ACTIVE)
+			cmd->port = PORT_DA;
+		else
+			cmd->port = PORT_OTHER;
+	} else {
+		cmd->port = PORT_OTHER;
+	}
+
+	if (p->mdio_addr >= 0) {
+		cmd->phy_address = p->mdio_addr;
+		cmd->transceiver = XCVR_EXTERNAL;
+		cmd->mdio_support = p->port_type == FW_PORT_TYPE_BT_SGMII ?
+			MDIO_SUPPORTS_C22 : MDIO_SUPPORTS_C45;
+	} else {
+		cmd->phy_address = 0;  /* not really, but no better option */
+		cmd->transceiver = XCVR_INTERNAL;
+		cmd->mdio_support = 0;
+	}
+
+	cmd->supported = from_fw_linkcaps(p->port_type, p->link_cfg.supported);
+	cmd->advertising = from_fw_linkcaps(p->port_type,
+					    p->link_cfg.advertising);
+	ethtool_cmd_speed_set(cmd,
+			      netif_carrier_ok(dev) ? p->link_cfg.speed : 0);
+	cmd->duplex = DUPLEX_FULL;
+	cmd->autoneg = p->link_cfg.autoneg;
+	cmd->maxtxpkt = 0;
+	cmd->maxrxpkt = 0;
+	return 0;
+}
+
+static unsigned int speed_to_caps(int speed)
+{
+	if (speed == 100)
+		return FW_PORT_CAP_SPEED_100M;
+	if (speed == 1000)
+		return FW_PORT_CAP_SPEED_1G;
+	if (speed == 10000)
+		return FW_PORT_CAP_SPEED_10G;
+	if (speed == 40000)
+		return FW_PORT_CAP_SPEED_40G;
+	return 0;
+}
+
+static int set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	unsigned int cap;
+	struct port_info *p = netdev_priv(dev);
+	struct link_config *lc = &p->link_cfg;
+	u32 speed = ethtool_cmd_speed(cmd);
+
+	if (cmd->duplex != DUPLEX_FULL)     /* only full-duplex supported */
+		return -EINVAL;
+
+	if (!(lc->supported & FW_PORT_CAP_ANEG)) {
+		/* PHY offers a single speed.  See if that's what's
+		 * being requested.
+		 */
+		if (cmd->autoneg == AUTONEG_DISABLE &&
+		    (lc->supported & speed_to_caps(speed)))
+			return 0;
+		return -EINVAL;
+	}
+
+	if (cmd->autoneg == AUTONEG_DISABLE) {
+		cap = speed_to_caps(speed);
+
+		if (!(lc->supported & cap) ||
+		    (speed == 1000) ||
+		    (speed == 10000) ||
+		    (speed == 40000))
+			return -EINVAL;
+		lc->requested_speed = cap;
+		lc->advertising = 0;
+	} else {
+		cap = to_fw_linkcaps(cmd->advertising);
+		if (!(lc->supported & cap))
+			return -EINVAL;
+		lc->requested_speed = 0;
+		lc->advertising = cap | FW_PORT_CAP_ANEG;
+	}
+	lc->autoneg = cmd->autoneg;
+
+	if (netif_running(dev))
+		return t4_link_start(p->adapter, p->adapter->fn, p->tx_chan,
+				     lc);
+	return 0;
+}
+
+static void get_pauseparam(struct net_device *dev,
+			   struct ethtool_pauseparam *epause)
+{
+	struct port_info *p = netdev_priv(dev);
+
+	epause->autoneg = (p->link_cfg.requested_fc & PAUSE_AUTONEG) != 0;
+	epause->rx_pause = (p->link_cfg.fc & PAUSE_RX) != 0;
+	epause->tx_pause = (p->link_cfg.fc & PAUSE_TX) != 0;
+}
+
+static int set_pauseparam(struct net_device *dev,
+			  struct ethtool_pauseparam *epause)
+{
+	struct port_info *p = netdev_priv(dev);
+	struct link_config *lc = &p->link_cfg;
+
+	if (epause->autoneg == AUTONEG_DISABLE)
+		lc->requested_fc = 0;
+	else if (lc->supported & FW_PORT_CAP_ANEG)
+		lc->requested_fc = PAUSE_AUTONEG;
+	else
+		return -EINVAL;
+
+	if (epause->rx_pause)
+		lc->requested_fc |= PAUSE_RX;
+	if (epause->tx_pause)
+		lc->requested_fc |= PAUSE_TX;
+	if (netif_running(dev))
+		return t4_link_start(p->adapter, p->adapter->fn, p->tx_chan,
+				     lc);
+	return 0;
+}
+
+static void get_sge_param(struct net_device *dev, struct ethtool_ringparam *e)
+{
+	const struct port_info *pi = netdev_priv(dev);
+	const struct sge *s = &pi->adapter->sge;
+
+	e->rx_max_pending = MAX_RX_BUFFERS;
+	e->rx_mini_max_pending = MAX_RSPQ_ENTRIES;
+	e->rx_jumbo_max_pending = 0;
+	e->tx_max_pending = MAX_TXQ_ENTRIES;
+
+	e->rx_pending = s->ethrxq[pi->first_qset].fl.size - 8;
+	e->rx_mini_pending = s->ethrxq[pi->first_qset].rspq.size;
+	e->rx_jumbo_pending = 0;
+	e->tx_pending = s->ethtxq[pi->first_qset].q.size;
+}
+
+static int set_sge_param(struct net_device *dev, struct ethtool_ringparam *e)
+{
+	int i;
+	const struct port_info *pi = netdev_priv(dev);
+	struct adapter *adapter = pi->adapter;
+	struct sge *s = &adapter->sge;
+
+	if (e->rx_pending > MAX_RX_BUFFERS || e->rx_jumbo_pending ||
+	    e->tx_pending > MAX_TXQ_ENTRIES ||
+	    e->rx_mini_pending > MAX_RSPQ_ENTRIES ||
+	    e->rx_mini_pending < MIN_RSPQ_ENTRIES ||
+	    e->rx_pending < MIN_FL_ENTRIES || e->tx_pending < MIN_TXQ_ENTRIES)
+		return -EINVAL;
+
+	if (adapter->flags & FULL_INIT_DONE)
+		return -EBUSY;
+
+	for (i = 0; i < pi->nqsets; ++i) {
+		s->ethtxq[pi->first_qset + i].q.size = e->tx_pending;
+		s->ethrxq[pi->first_qset + i].fl.size = e->rx_pending + 8;
+		s->ethrxq[pi->first_qset + i].rspq.size = e->rx_mini_pending;
+	}
+	return 0;
+}
+
+/**
+ * set_rx_intr_params - set a net devices's RX interrupt holdoff paramete!
+ * @dev: the network device
+ * @us: the hold-off time in us, or 0 to disable timer
+ * @cnt: the hold-off packet count, or 0 to disable counter
+ *
+ * Set the RX interrupt hold-off parameters for a network device.
+ */
+static int set_rx_intr_params(struct net_device *dev,
+			      unsigned int us, unsigned int cnt)
+{
+	int i, err;
+	struct port_info *pi = netdev_priv(dev);
+	struct adapter *adap = pi->adapter;
+	struct sge_eth_rxq *q = &adap->sge.ethrxq[pi->first_qset];
+
+	for (i = 0; i < pi->nqsets; i++, q++) {
+		err = cxgb4_set_rspq_intr_params(&q->rspq, us, cnt);
+		if (err)
+			return err;
+	}
+	return 0;
+}
+
+static int set_adaptive_rx_setting(struct net_device *dev, int adaptive_rx)
+{
+	int i;
+	struct port_info *pi = netdev_priv(dev);
+	struct adapter *adap = pi->adapter;
+	struct sge_eth_rxq *q = &adap->sge.ethrxq[pi->first_qset];
+
+	for (i = 0; i < pi->nqsets; i++, q++)
+		q->rspq.adaptive_rx = adaptive_rx;
+
+	return 0;
+}
+
+static int get_adaptive_rx_setting(struct net_device *dev)
+{
+	struct port_info *pi = netdev_priv(dev);
+	struct adapter *adap = pi->adapter;
+	struct sge_eth_rxq *q = &adap->sge.ethrxq[pi->first_qset];
+
+	return q->rspq.adaptive_rx;
+}
+
+static int set_coalesce(struct net_device *dev, struct ethtool_coalesce *c)
+{
+	set_adaptive_rx_setting(dev, c->use_adaptive_rx_coalesce);
+	return set_rx_intr_params(dev, c->rx_coalesce_usecs,
+				  c->rx_max_coalesced_frames);
+}
+
+static int get_coalesce(struct net_device *dev, struct ethtool_coalesce *c)
+{
+	const struct port_info *pi = netdev_priv(dev);
+	const struct adapter *adap = pi->adapter;
+	const struct sge_rspq *rq = &adap->sge.ethrxq[pi->first_qset].rspq;
+
+	c->rx_coalesce_usecs = qtimer_val(adap, rq);
+	c->rx_max_coalesced_frames = (rq->intr_params & QINTR_CNT_EN) ?
+		adap->sge.counter_val[rq->pktcnt_idx] : 0;
+	c->use_adaptive_rx_coalesce = get_adaptive_rx_setting(dev);
+	return 0;
+}
+
+/**
+ *	eeprom_ptov - translate a physical EEPROM address to virtual
+ *	@phys_addr: the physical EEPROM address
+ *	@fn: the PCI function number
+ *	@sz: size of function-specific area
+ *
+ *	Translate a physical EEPROM address to virtual.  The first 1K is
+ *	accessed through virtual addresses starting at 31K, the rest is
+ *	accessed through virtual addresses starting at 0.
+ *
+ *	The mapping is as follows:
+ *	[0..1K) -> [31K..32K)
+ *	[1K..1K+A) -> [31K-A..31K)
+ *	[1K+A..ES) -> [0..ES-A-1K)
+ *
+ *	where A = @fn * @sz, and ES = EEPROM size.
+ */
+static int eeprom_ptov(unsigned int phys_addr, unsigned int fn, unsigned int sz)
+{
+	fn *= sz;
+	if (phys_addr < 1024)
+		return phys_addr + (31 << 10);
+	if (phys_addr < 1024 + fn)
+		return 31744 - fn + phys_addr - 1024;
+	if (phys_addr < EEPROMSIZE)
+		return phys_addr - 1024 - fn;
+	return -EINVAL;
+}
+
+/* The next two routines implement eeprom read/write from physical addresses.
+ */
+static int eeprom_rd_phys(struct adapter *adap, unsigned int phys_addr, u32 *v)
+{
+	int vaddr = eeprom_ptov(phys_addr, adap->fn, EEPROMPFSIZE);
+
+	if (vaddr >= 0)
+		vaddr = pci_read_vpd(adap->pdev, vaddr, sizeof(u32), v);
+	return vaddr < 0 ? vaddr : 0;
+}
+
+static int eeprom_wr_phys(struct adapter *adap, unsigned int phys_addr, u32 v)
+{
+	int vaddr = eeprom_ptov(phys_addr, adap->fn, EEPROMPFSIZE);
+
+	if (vaddr >= 0)
+		vaddr = pci_write_vpd(adap->pdev, vaddr, sizeof(u32), &v);
+	return vaddr < 0 ? vaddr : 0;
+}
+
+#define EEPROM_MAGIC 0x38E2F10C
+
+static int get_eeprom(struct net_device *dev, struct ethtool_eeprom *e,
+		      u8 *data)
+{
+	int i, err = 0;
+	struct adapter *adapter = netdev2adap(dev);
+	u8 *buf = kmalloc(EEPROMSIZE, GFP_KERNEL);
+
+	if (!buf)
+		return -ENOMEM;
+
+	e->magic = EEPROM_MAGIC;
+	for (i = e->offset & ~3; !err && i < e->offset + e->len; i += 4)
+		err = eeprom_rd_phys(adapter, i, (u32 *)&buf[i]);
+
+	if (!err)
+		memcpy(data, buf + e->offset, e->len);
+	kfree(buf);
+	return err;
+}
+
+static int set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,
+		      u8 *data)
+{
+	u8 *buf;
+	int err = 0;
+	u32 aligned_offset, aligned_len, *p;
+	struct adapter *adapter = netdev2adap(dev);
+
+	if (eeprom->magic != EEPROM_MAGIC)
+		return -EINVAL;
+
+	aligned_offset = eeprom->offset & ~3;
+	aligned_len = (eeprom->len + (eeprom->offset & 3) + 3) & ~3;
+
+	if (adapter->fn > 0) {
+		u32 start = 1024 + adapter->fn * EEPROMPFSIZE;
+
+		if (aligned_offset < start ||
+		    aligned_offset + aligned_len > start + EEPROMPFSIZE)
+			return -EPERM;
+	}
+
+	if (aligned_offset != eeprom->offset || aligned_len != eeprom->len) {
+		/* RMW possibly needed for first or last words.
+		 */
+		buf = kmalloc(aligned_len, GFP_KERNEL);
+		if (!buf)
+			return -ENOMEM;
+		err = eeprom_rd_phys(adapter, aligned_offset, (u32 *)buf);
+		if (!err && aligned_len > 4)
+			err = eeprom_rd_phys(adapter,
+					     aligned_offset + aligned_len - 4,
+					     (u32 *)&buf[aligned_len - 4]);
+		if (err)
+			goto out;
+		memcpy(buf + (eeprom->offset & 3), data, eeprom->len);
+	} else {
+		buf = data;
+	}
+
+	err = t4_seeprom_wp(adapter, false);
+	if (err)
+		goto out;
+
+	for (p = (u32 *)buf; !err && aligned_len; aligned_len -= 4, p++) {
+		err = eeprom_wr_phys(adapter, aligned_offset, *p);
+		aligned_offset += 4;
+	}
+
+	if (!err)
+		err = t4_seeprom_wp(adapter, true);
+out:
+	if (buf != data)
+		kfree(buf);
+	return err;
+}
+
+static int set_flash(struct net_device *netdev, struct ethtool_flash *ef)
+{
+	int ret;
+	const struct firmware *fw;
+	struct adapter *adap = netdev2adap(netdev);
+	unsigned int mbox = PCIE_FW_MASTER_M + 1;
+
+	ef->data[sizeof(ef->data) - 1] = '\0';
+	ret = request_firmware(&fw, ef->data, adap->pdev_dev);
+	if (ret < 0)
+		return ret;
+
+	/* If the adapter has been fully initialized then we'll go ahead and
+	 * try to get the firmware's cooperation in upgrading to the new
+	 * firmware image otherwise we'll try to do the entire job from the
+	 * host ... and we always "force" the operation in this path.
+	 */
+	if (adap->flags & FULL_INIT_DONE)
+		mbox = adap->mbox;
+
+	ret = t4_fw_upgrade(adap, mbox, fw->data, fw->size, 1);
+	release_firmware(fw);
+	if (!ret)
+		dev_info(adap->pdev_dev,
+			 "loaded firmware %s, reload cxgb4 driver\n", ef->data);
+	return ret;
+}
+
+#define WOL_SUPPORTED (WAKE_BCAST | WAKE_MAGIC)
+#define BCAST_CRC 0xa0ccc1a6
+
+static void get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+{
+	wol->supported = WAKE_BCAST | WAKE_MAGIC;
+	wol->wolopts = netdev2adap(dev)->wol;
+	memset(&wol->sopass, 0, sizeof(wol->sopass));
+}
+
+static int set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
+{
+	int err = 0;
+	struct port_info *pi = netdev_priv(dev);
+
+	if (wol->wolopts & ~WOL_SUPPORTED)
+		return -EINVAL;
+	t4_wol_magic_enable(pi->adapter, pi->tx_chan,
+			    (wol->wolopts & WAKE_MAGIC) ? dev->dev_addr : NULL);
+	if (wol->wolopts & WAKE_BCAST) {
+		err = t4_wol_pat_enable(pi->adapter, pi->tx_chan, 0xfe, ~0ULL,
+					~0ULL, 0, false);
+		if (!err)
+			err = t4_wol_pat_enable(pi->adapter, pi->tx_chan, 1,
+						~6ULL, ~0ULL, BCAST_CRC, true);
+	} else {
+		t4_wol_pat_enable(pi->adapter, pi->tx_chan, 0, 0, 0, 0, false);
+	}
+	return err;
+}
+
+static u32 get_rss_table_size(struct net_device *dev)
+{
+	const struct port_info *pi = netdev_priv(dev);
+
+	return pi->rss_size;
+}
+
+static int get_rss_table(struct net_device *dev, u32 *p, u8 *key, u8 *hfunc)
+{
+	const struct port_info *pi = netdev_priv(dev);
+	unsigned int n = pi->rss_size;
+
+	if (hfunc)
+		*hfunc = ETH_RSS_HASH_TOP;
+	if (!p)
+		return 0;
+	while (n--)
+		p[n] = pi->rss[n];
+	return 0;
+}
+
+static int set_rss_table(struct net_device *dev, const u32 *p, const u8 *key,
+			 const u8 hfunc)
+{
+	unsigned int i;
+	struct port_info *pi = netdev_priv(dev);
+
+	/* We require at least one supported parameter to be changed and no
+	 * change in any of the unsupported parameters
+	 */
+	if (key ||
+	    (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))
+		return -EOPNOTSUPP;
+	if (!p)
+		return 0;
+
+	for (i = 0; i < pi->rss_size; i++)
+		pi->rss[i] = p[i];
+	if (pi->adapter->flags & FULL_INIT_DONE)
+		return cxgb4_write_rss(pi, pi->rss);
+	return 0;
+}
+
+static int get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *info,
+		     u32 *rules)
+{
+	const struct port_info *pi = netdev_priv(dev);
+
+	switch (info->cmd) {
+	case ETHTOOL_GRXFH: {
+		unsigned int v = pi->rss_mode;
+
+		info->data = 0;
+		switch (info->flow_type) {
+		case TCP_V4_FLOW:
+			if (v & FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN_F)
+				info->data = RXH_IP_SRC | RXH_IP_DST |
+					     RXH_L4_B_0_1 | RXH_L4_B_2_3;
+			else if (v & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F)
+				info->data = RXH_IP_SRC | RXH_IP_DST;
+			break;
+		case UDP_V4_FLOW:
+			if ((v & FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN_F) &&
+			    (v & FW_RSS_VI_CONFIG_CMD_UDPEN_F))
+				info->data = RXH_IP_SRC | RXH_IP_DST |
+					     RXH_L4_B_0_1 | RXH_L4_B_2_3;
+			else if (v & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F)
+				info->data = RXH_IP_SRC | RXH_IP_DST;
+			break;
+		case SCTP_V4_FLOW:
+		case AH_ESP_V4_FLOW:
+		case IPV4_FLOW:
+			if (v & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN_F)
+				info->data = RXH_IP_SRC | RXH_IP_DST;
+			break;
+		case TCP_V6_FLOW:
+			if (v & FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN_F)
+				info->data = RXH_IP_SRC | RXH_IP_DST |
+					     RXH_L4_B_0_1 | RXH_L4_B_2_3;
+			else if (v & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F)
+				info->data = RXH_IP_SRC | RXH_IP_DST;
+			break;
+		case UDP_V6_FLOW:
+			if ((v & FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN_F) &&
+			    (v & FW_RSS_VI_CONFIG_CMD_UDPEN_F))
+				info->data = RXH_IP_SRC | RXH_IP_DST |
+					     RXH_L4_B_0_1 | RXH_L4_B_2_3;
+			else if (v & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F)
+				info->data = RXH_IP_SRC | RXH_IP_DST;
+			break;
+		case SCTP_V6_FLOW:
+		case AH_ESP_V6_FLOW:
+		case IPV6_FLOW:
+			if (v & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN_F)
+				info->data = RXH_IP_SRC | RXH_IP_DST;
+			break;
+		}
+		return 0;
+	}
+	case ETHTOOL_GRXRINGS:
+		info->data = pi->nqsets;
+		return 0;
+	}
+	return -EOPNOTSUPP;
+}
+
+static const struct ethtool_ops cxgb_ethtool_ops = {
+	.get_settings      = get_settings,
+	.set_settings      = set_settings,
+	.get_drvinfo       = get_drvinfo,
+	.get_msglevel      = get_msglevel,
+	.set_msglevel      = set_msglevel,
+	.get_ringparam     = get_sge_param,
+	.set_ringparam     = set_sge_param,
+	.get_coalesce      = get_coalesce,
+	.set_coalesce      = set_coalesce,
+	.get_eeprom_len    = get_eeprom_len,
+	.get_eeprom        = get_eeprom,
+	.set_eeprom        = set_eeprom,
+	.get_pauseparam    = get_pauseparam,
+	.set_pauseparam    = set_pauseparam,
+	.get_link          = ethtool_op_get_link,
+	.get_strings       = get_strings,
+	.set_phys_id       = identify_port,
+	.nway_reset        = restart_autoneg,
+	.get_sset_count    = get_sset_count,
+	.get_ethtool_stats = get_stats,
+	.get_regs_len      = get_regs_len,
+	.get_regs          = get_regs,
+	.get_wol           = get_wol,
+	.set_wol           = set_wol,
+	.get_rxnfc         = get_rxnfc,
+	.get_rxfh_indir_size = get_rss_table_size,
+	.get_rxfh	   = get_rss_table,
+	.set_rxfh	   = set_rss_table,
+	.flash_device      = set_flash,
+};
+
+void cxgb4_set_ethtool_ops(struct net_device *netdev)
+{
+	netdev->ethtool_ops = &cxgb_ethtool_ops;
+}
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index 4234b8c917e7..6379d6963917 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@ -624,6 +624,734 @@ int t4_memory_rw(struct adapter *adap, int win, int mtype, u32 addr,
 	return 0;
 }
 
+/**
+ *	t4_get_regs_len - return the size of the chips register set
+ *	@adapter: the adapter
+ *
+ *	Returns the size of the chip's BAR0 register space.
+ */
+unsigned int t4_get_regs_len(struct adapter *adapter)
+{
+	unsigned int chip_version = CHELSIO_CHIP_VERSION(adapter->params.chip);
+
+	switch (chip_version) {
+	case CHELSIO_T4:
+		return T4_REGMAP_SIZE;
+
+	case CHELSIO_T5:
+		return T5_REGMAP_SIZE;
+	}
+
+	dev_err(adapter->pdev_dev,
+		"Unsupported chip version %d\n", chip_version);
+	return 0;
+}
+
+/**
+ *	t4_get_regs - read chip registers into provided buffer
+ *	@adap: the adapter
+ *	@buf: register buffer
+ *	@buf_size: size (in bytes) of register buffer
+ *
+ *	If the provided register buffer isn't large enough for the chip's
+ *	full register range, the register dump will be truncated to the
+ *	register buffer's size.
+ */
+void t4_get_regs(struct adapter *adap, void *buf, size_t buf_size)
+{
+	static const unsigned int t4_reg_ranges[] = {
+		0x1008, 0x1108,
+		0x1180, 0x11b4,
+		0x11fc, 0x123c,
+		0x1300, 0x173c,
+		0x1800, 0x18fc,
+		0x3000, 0x30d8,
+		0x30e0, 0x5924,
+		0x5960, 0x59d4,
+		0x5a00, 0x5af8,
+		0x6000, 0x6098,
+		0x6100, 0x6150,
+		0x6200, 0x6208,
+		0x6240, 0x6248,
+		0x6280, 0x6338,
+		0x6370, 0x638c,
+		0x6400, 0x643c,
+		0x6500, 0x6524,
+		0x6a00, 0x6a38,
+		0x6a60, 0x6a78,
+		0x6b00, 0x6b84,
+		0x6bf0, 0x6c84,
+		0x6cf0, 0x6d84,
+		0x6df0, 0x6e84,
+		0x6ef0, 0x6f84,
+		0x6ff0, 0x7084,
+		0x70f0, 0x7184,
+		0x71f0, 0x7284,
+		0x72f0, 0x7384,
+		0x73f0, 0x7450,
+		0x7500, 0x7530,
+		0x7600, 0x761c,
+		0x7680, 0x76cc,
+		0x7700, 0x7798,
+		0x77c0, 0x77fc,
+		0x7900, 0x79fc,
+		0x7b00, 0x7c38,
+		0x7d00, 0x7efc,
+		0x8dc0, 0x8e1c,
+		0x8e30, 0x8e78,
+		0x8ea0, 0x8f6c,
+		0x8fc0, 0x9074,
+		0x90fc, 0x90fc,
+		0x9400, 0x9458,
+		0x9600, 0x96bc,
+		0x9800, 0x9808,
+		0x9820, 0x983c,
+		0x9850, 0x9864,
+		0x9c00, 0x9c6c,
+		0x9c80, 0x9cec,
+		0x9d00, 0x9d6c,
+		0x9d80, 0x9dec,
+		0x9e00, 0x9e6c,
+		0x9e80, 0x9eec,
+		0x9f00, 0x9f6c,
+		0x9f80, 0x9fec,
+		0xd004, 0xd03c,
+		0xdfc0, 0xdfe0,
+		0xe000, 0xea7c,
+		0xf000, 0x11110,
+		0x11118, 0x11190,
+		0x19040, 0x1906c,
+		0x19078, 0x19080,
+		0x1908c, 0x19124,
+		0x19150, 0x191b0,
+		0x191d0, 0x191e8,
+		0x19238, 0x1924c,
+		0x193f8, 0x19474,
+		0x19490, 0x194f8,
+		0x19800, 0x19f30,
+		0x1a000, 0x1a06c,
+		0x1a0b0, 0x1a120,
+		0x1a128, 0x1a138,
+		0x1a190, 0x1a1c4,
+		0x1a1fc, 0x1a1fc,
+		0x1e040, 0x1e04c,
+		0x1e284, 0x1e28c,
+		0x1e2c0, 0x1e2c0,
+		0x1e2e0, 0x1e2e0,
+		0x1e300, 0x1e384,
+		0x1e3c0, 0x1e3c8,
+		0x1e440, 0x1e44c,
+		0x1e684, 0x1e68c,
+		0x1e6c0, 0x1e6c0,
+		0x1e6e0, 0x1e6e0,
+		0x1e700, 0x1e784,
+		0x1e7c0, 0x1e7c8,
+		0x1e840, 0x1e84c,
+		0x1ea84, 0x1ea8c,
+		0x1eac0, 0x1eac0,
+		0x1eae0, 0x1eae0,
+		0x1eb00, 0x1eb84,
+		0x1ebc0, 0x1ebc8,
+		0x1ec40, 0x1ec4c,
+		0x1ee84, 0x1ee8c,
+		0x1eec0, 0x1eec0,
+		0x1eee0, 0x1eee0,
+		0x1ef00, 0x1ef84,
+		0x1efc0, 0x1efc8,
+		0x1f040, 0x1f04c,
+		0x1f284, 0x1f28c,
+		0x1f2c0, 0x1f2c0,
+		0x1f2e0, 0x1f2e0,
+		0x1f300, 0x1f384,
+		0x1f3c0, 0x1f3c8,
+		0x1f440, 0x1f44c,
+		0x1f684, 0x1f68c,
+		0x1f6c0, 0x1f6c0,
+		0x1f6e0, 0x1f6e0,
+		0x1f700, 0x1f784,
+		0x1f7c0, 0x1f7c8,
+		0x1f840, 0x1f84c,
+		0x1fa84, 0x1fa8c,
+		0x1fac0, 0x1fac0,
+		0x1fae0, 0x1fae0,
+		0x1fb00, 0x1fb84,
+		0x1fbc0, 0x1fbc8,
+		0x1fc40, 0x1fc4c,
+		0x1fe84, 0x1fe8c,
+		0x1fec0, 0x1fec0,
+		0x1fee0, 0x1fee0,
+		0x1ff00, 0x1ff84,
+		0x1ffc0, 0x1ffc8,
+		0x20000, 0x2002c,
+		0x20100, 0x2013c,
+		0x20190, 0x201c8,
+		0x20200, 0x20318,
+		0x20400, 0x20528,
+		0x20540, 0x20614,
+		0x21000, 0x21040,
+		0x2104c, 0x21060,
+		0x210c0, 0x210ec,
+		0x21200, 0x21268,
+		0x21270, 0x21284,
+		0x212fc, 0x21388,
+		0x21400, 0x21404,
+		0x21500, 0x21518,
+		0x2152c, 0x2153c,
+		0x21550, 0x21554,
+		0x21600, 0x21600,
+		0x21608, 0x21628,
+		0x21630, 0x2163c,
+		0x21700, 0x2171c,
+		0x21780, 0x2178c,
+		0x21800, 0x21c38,
+		0x21c80, 0x21d7c,
+		0x21e00, 0x21e04,
+		0x22000, 0x2202c,
+		0x22100, 0x2213c,
+		0x22190, 0x221c8,
+		0x22200, 0x22318,
+		0x22400, 0x22528,
+		0x22540, 0x22614,
+		0x23000, 0x23040,
+		0x2304c, 0x23060,
+		0x230c0, 0x230ec,
+		0x23200, 0x23268,
+		0x23270, 0x23284,
+		0x232fc, 0x23388,
+		0x23400, 0x23404,
+		0x23500, 0x23518,
+		0x2352c, 0x2353c,
+		0x23550, 0x23554,
+		0x23600, 0x23600,
+		0x23608, 0x23628,
+		0x23630, 0x2363c,
+		0x23700, 0x2371c,
+		0x23780, 0x2378c,
+		0x23800, 0x23c38,
+		0x23c80, 0x23d7c,
+		0x23e00, 0x23e04,
+		0x24000, 0x2402c,
+		0x24100, 0x2413c,
+		0x24190, 0x241c8,
+		0x24200, 0x24318,
+		0x24400, 0x24528,
+		0x24540, 0x24614,
+		0x25000, 0x25040,
+		0x2504c, 0x25060,
+		0x250c0, 0x250ec,
+		0x25200, 0x25268,
+		0x25270, 0x25284,
+		0x252fc, 0x25388,
+		0x25400, 0x25404,
+		0x25500, 0x25518,
+		0x2552c, 0x2553c,
+		0x25550, 0x25554,
+		0x25600, 0x25600,
+		0x25608, 0x25628,
+		0x25630, 0x2563c,
+		0x25700, 0x2571c,
+		0x25780, 0x2578c,
+		0x25800, 0x25c38,
+		0x25c80, 0x25d7c,
+		0x25e00, 0x25e04,
+		0x26000, 0x2602c,
+		0x26100, 0x2613c,
+		0x26190, 0x261c8,
+		0x26200, 0x26318,
+		0x26400, 0x26528,
+		0x26540, 0x26614,
+		0x27000, 0x27040,
+		0x2704c, 0x27060,
+		0x270c0, 0x270ec,
+		0x27200, 0x27268,
+		0x27270, 0x27284,
+		0x272fc, 0x27388,
+		0x27400, 0x27404,
+		0x27500, 0x27518,
+		0x2752c, 0x2753c,
+		0x27550, 0x27554,
+		0x27600, 0x27600,
+		0x27608, 0x27628,
+		0x27630, 0x2763c,
+		0x27700, 0x2771c,
+		0x27780, 0x2778c,
+		0x27800, 0x27c38,
+		0x27c80, 0x27d7c,
+		0x27e00, 0x27e04
+	};
+
+	static const unsigned int t5_reg_ranges[] = {
+		0x1008, 0x1148,
+		0x1180, 0x11b4,
+		0x11fc, 0x123c,
+		0x1280, 0x173c,
+		0x1800, 0x18fc,
+		0x3000, 0x3028,
+		0x3060, 0x30d8,
+		0x30e0, 0x30fc,
+		0x3140, 0x357c,
+		0x35a8, 0x35cc,
+		0x35ec, 0x35ec,
+		0x3600, 0x5624,
+		0x56cc, 0x575c,
+		0x580c, 0x5814,
+		0x5890, 0x58bc,
+		0x5940, 0x59dc,
+		0x59fc, 0x5a18,
+		0x5a60, 0x5a9c,
+		0x5b9c, 0x5bfc,
+		0x6000, 0x6040,
+		0x6058, 0x614c,
+		0x7700, 0x7798,
+		0x77c0, 0x78fc,
+		0x7b00, 0x7c54,
+		0x7d00, 0x7efc,
+		0x8dc0, 0x8de0,
+		0x8df8, 0x8e84,
+		0x8ea0, 0x8f84,
+		0x8fc0, 0x90f8,
+		0x9400, 0x9470,
+		0x9600, 0x96f4,
+		0x9800, 0x9808,
+		0x9820, 0x983c,
+		0x9850, 0x9864,
+		0x9c00, 0x9c6c,
+		0x9c80, 0x9cec,
+		0x9d00, 0x9d6c,
+		0x9d80, 0x9dec,
+		0x9e00, 0x9e6c,
+		0x9e80, 0x9eec,
+		0x9f00, 0x9f6c,
+		0x9f80, 0xa020,
+		0xd004, 0xd03c,
+		0xdfc0, 0xdfe0,
+		0xe000, 0x11088,
+		0x1109c, 0x11110,
+		0x11118, 0x1117c,
+		0x11190, 0x11204,
+		0x19040, 0x1906c,
+		0x19078, 0x19080,
+		0x1908c, 0x19124,
+		0x19150, 0x191b0,
+		0x191d0, 0x191e8,
+		0x19238, 0x19290,
+		0x193f8, 0x19474,
+		0x19490, 0x194cc,
+		0x194f0, 0x194f8,
+		0x19c00, 0x19c60,
+		0x19c94, 0x19e10,
+		0x19e50, 0x19f34,
+		0x19f40, 0x19f50,
+		0x19f90, 0x19fe4,
+		0x1a000, 0x1a06c,
+		0x1a0b0, 0x1a120,
+		0x1a128, 0x1a138,
+		0x1a190, 0x1a1c4,
+		0x1a1fc, 0x1a1fc,
+		0x1e008, 0x1e00c,
+		0x1e040, 0x1e04c,
+		0x1e284, 0x1e290,
+		0x1e2c0, 0x1e2c0,
+		0x1e2e0, 0x1e2e0,
+		0x1e300, 0x1e384,
+		0x1e3c0, 0x1e3c8,
+		0x1e408, 0x1e40c,
+		0x1e440, 0x1e44c,
+		0x1e684, 0x1e690,
+		0x1e6c0, 0x1e6c0,
+		0x1e6e0, 0x1e6e0,
+		0x1e700, 0x1e784,
+		0x1e7c0, 0x1e7c8,
+		0x1e808, 0x1e80c,
+		0x1e840, 0x1e84c,
+		0x1ea84, 0x1ea90,
+		0x1eac0, 0x1eac0,
+		0x1eae0, 0x1eae0,
+		0x1eb00, 0x1eb84,
+		0x1ebc0, 0x1ebc8,
+		0x1ec08, 0x1ec0c,
+		0x1ec40, 0x1ec4c,
+		0x1ee84, 0x1ee90,
+		0x1eec0, 0x1eec0,
+		0x1eee0, 0x1eee0,
+		0x1ef00, 0x1ef84,
+		0x1efc0, 0x1efc8,
+		0x1f008, 0x1f00c,
+		0x1f040, 0x1f04c,
+		0x1f284, 0x1f290,
+		0x1f2c0, 0x1f2c0,
+		0x1f2e0, 0x1f2e0,
+		0x1f300, 0x1f384,
+		0x1f3c0, 0x1f3c8,
+		0x1f408, 0x1f40c,
+		0x1f440, 0x1f44c,
+		0x1f684, 0x1f690,
+		0x1f6c0, 0x1f6c0,
+		0x1f6e0, 0x1f6e0,
+		0x1f700, 0x1f784,
+		0x1f7c0, 0x1f7c8,
+		0x1f808, 0x1f80c,
+		0x1f840, 0x1f84c,
+		0x1fa84, 0x1fa90,
+		0x1fac0, 0x1fac0,
+		0x1fae0, 0x1fae0,
+		0x1fb00, 0x1fb84,
+		0x1fbc0, 0x1fbc8,
+		0x1fc08, 0x1fc0c,
+		0x1fc40, 0x1fc4c,
+		0x1fe84, 0x1fe90,
+		0x1fec0, 0x1fec0,
+		0x1fee0, 0x1fee0,
+		0x1ff00, 0x1ff84,
+		0x1ffc0, 0x1ffc8,
+		0x30000, 0x30030,
+		0x30100, 0x30144,
+		0x30190, 0x301d0,
+		0x30200, 0x30318,
+		0x30400, 0x3052c,
+		0x30540, 0x3061c,
+		0x30800, 0x30834,
+		0x308c0, 0x30908,
+		0x30910, 0x309ac,
+		0x30a00, 0x30a04,
+		0x30a0c, 0x30a2c,
+		0x30a44, 0x30a50,
+		0x30a74, 0x30c24,
+		0x30d08, 0x30d14,
+		0x30d1c, 0x30d20,
+		0x30d3c, 0x30d50,
+		0x31200, 0x3120c,
+		0x31220, 0x31220,
+		0x31240, 0x31240,
+		0x31600, 0x31600,
+		0x31608, 0x3160c,
+		0x31a00, 0x31a1c,
+		0x31e04, 0x31e20,
+		0x31e38, 0x31e3c,
+		0x31e80, 0x31e80,
+		0x31e88, 0x31ea8,
+		0x31eb0, 0x31eb4,
+		0x31ec8, 0x31ed4,
+		0x31fb8, 0x32004,
+		0x32208, 0x3223c,
+		0x32600, 0x32630,
+		0x32a00, 0x32abc,
+		0x32b00, 0x32b70,
+		0x33000, 0x33048,
+		0x33060, 0x3309c,
+		0x330f0, 0x33148,
+		0x33160, 0x3319c,
+		0x331f0, 0x332e4,
+		0x332f8, 0x333e4,
+		0x333f8, 0x33448,
+		0x33460, 0x3349c,
+		0x334f0, 0x33548,
+		0x33560, 0x3359c,
+		0x335f0, 0x336e4,
+		0x336f8, 0x337e4,
+		0x337f8, 0x337fc,
+		0x33814, 0x33814,
+		0x3382c, 0x3382c,
+		0x33880, 0x3388c,
+		0x338e8, 0x338ec,
+		0x33900, 0x33948,
+		0x33960, 0x3399c,
+		0x339f0, 0x33ae4,
+		0x33af8, 0x33b10,
+		0x33b28, 0x33b28,
+		0x33b3c, 0x33b50,
+		0x33bf0, 0x33c10,
+		0x33c28, 0x33c28,
+		0x33c3c, 0x33c50,
+		0x33cf0, 0x33cfc,
+		0x34000, 0x34030,
+		0x34100, 0x34144,
+		0x34190, 0x341d0,
+		0x34200, 0x34318,
+		0x34400, 0x3452c,
+		0x34540, 0x3461c,
+		0x34800, 0x34834,
+		0x348c0, 0x34908,
+		0x34910, 0x349ac,
+		0x34a00, 0x34a04,
+		0x34a0c, 0x34a2c,
+		0x34a44, 0x34a50,
+		0x34a74, 0x34c24,
+		0x34d08, 0x34d14,
+		0x34d1c, 0x34d20,
+		0x34d3c, 0x34d50,
+		0x35200, 0x3520c,
+		0x35220, 0x35220,
+		0x35240, 0x35240,
+		0x35600, 0x35600,
+		0x35608, 0x3560c,
+		0x35a00, 0x35a1c,
+		0x35e04, 0x35e20,
+		0x35e38, 0x35e3c,
+		0x35e80, 0x35e80,
+		0x35e88, 0x35ea8,
+		0x35eb0, 0x35eb4,
+		0x35ec8, 0x35ed4,
+		0x35fb8, 0x36004,
+		0x36208, 0x3623c,
+		0x36600, 0x36630,
+		0x36a00, 0x36abc,
+		0x36b00, 0x36b70,
+		0x37000, 0x37048,
+		0x37060, 0x3709c,
+		0x370f0, 0x37148,
+		0x37160, 0x3719c,
+		0x371f0, 0x372e4,
+		0x372f8, 0x373e4,
+		0x373f8, 0x37448,
+		0x37460, 0x3749c,
+		0x374f0, 0x37548,
+		0x37560, 0x3759c,
+		0x375f0, 0x376e4,
+		0x376f8, 0x377e4,
+		0x377f8, 0x377fc,
+		0x37814, 0x37814,
+		0x3782c, 0x3782c,
+		0x37880, 0x3788c,
+		0x378e8, 0x378ec,
+		0x37900, 0x37948,
+		0x37960, 0x3799c,
+		0x379f0, 0x37ae4,
+		0x37af8, 0x37b10,
+		0x37b28, 0x37b28,
+		0x37b3c, 0x37b50,
+		0x37bf0, 0x37c10,
+		0x37c28, 0x37c28,
+		0x37c3c, 0x37c50,
+		0x37cf0, 0x37cfc,
+		0x38000, 0x38030,
+		0x38100, 0x38144,
+		0x38190, 0x381d0,
+		0x38200, 0x38318,
+		0x38400, 0x3852c,
+		0x38540, 0x3861c,
+		0x38800, 0x38834,
+		0x388c0, 0x38908,
+		0x38910, 0x389ac,
+		0x38a00, 0x38a04,
+		0x38a0c, 0x38a2c,
+		0x38a44, 0x38a50,
+		0x38a74, 0x38c24,
+		0x38d08, 0x38d14,
+		0x38d1c, 0x38d20,
+		0x38d3c, 0x38d50,
+		0x39200, 0x3920c,
+		0x39220, 0x39220,
+		0x39240, 0x39240,
+		0x39600, 0x39600,
+		0x39608, 0x3960c,
+		0x39a00, 0x39a1c,
+		0x39e04, 0x39e20,
+		0x39e38, 0x39e3c,
+		0x39e80, 0x39e80,
+		0x39e88, 0x39ea8,
+		0x39eb0, 0x39eb4,
+		0x39ec8, 0x39ed4,
+		0x39fb8, 0x3a004,
+		0x3a208, 0x3a23c,
+		0x3a600, 0x3a630,
+		0x3aa00, 0x3aabc,
+		0x3ab00, 0x3ab70,
+		0x3b000, 0x3b048,
+		0x3b060, 0x3b09c,
+		0x3b0f0, 0x3b148,
+		0x3b160, 0x3b19c,
+		0x3b1f0, 0x3b2e4,
+		0x3b2f8, 0x3b3e4,
+		0x3b3f8, 0x3b448,
+		0x3b460, 0x3b49c,
+		0x3b4f0, 0x3b548,
+		0x3b560, 0x3b59c,
+		0x3b5f0, 0x3b6e4,
+		0x3b6f8, 0x3b7e4,
+		0x3b7f8, 0x3b7fc,
+		0x3b814, 0x3b814,
+		0x3b82c, 0x3b82c,
+		0x3b880, 0x3b88c,
+		0x3b8e8, 0x3b8ec,
+		0x3b900, 0x3b948,
+		0x3b960, 0x3b99c,
+		0x3b9f0, 0x3bae4,
+		0x3baf8, 0x3bb10,
+		0x3bb28, 0x3bb28,
+		0x3bb3c, 0x3bb50,
+		0x3bbf0, 0x3bc10,
+		0x3bc28, 0x3bc28,
+		0x3bc3c, 0x3bc50,
+		0x3bcf0, 0x3bcfc,
+		0x3c000, 0x3c030,
+		0x3c100, 0x3c144,
+		0x3c190, 0x3c1d0,
+		0x3c200, 0x3c318,
+		0x3c400, 0x3c52c,
+		0x3c540, 0x3c61c,
+		0x3c800, 0x3c834,
+		0x3c8c0, 0x3c908,
+		0x3c910, 0x3c9ac,
+		0x3ca00, 0x3ca04,
+		0x3ca0c, 0x3ca2c,
+		0x3ca44, 0x3ca50,
+		0x3ca74, 0x3cc24,
+		0x3cd08, 0x3cd14,
+		0x3cd1c, 0x3cd20,
+		0x3cd3c, 0x3cd50,
+		0x3d200, 0x3d20c,
+		0x3d220, 0x3d220,
+		0x3d240, 0x3d240,
+		0x3d600, 0x3d600,
+		0x3d608, 0x3d60c,
+		0x3da00, 0x3da1c,
+		0x3de04, 0x3de20,
+		0x3de38, 0x3de3c,
+		0x3de80, 0x3de80,
+		0x3de88, 0x3dea8,
+		0x3deb0, 0x3deb4,
+		0x3dec8, 0x3ded4,
+		0x3dfb8, 0x3e004,
+		0x3e208, 0x3e23c,
+		0x3e600, 0x3e630,
+		0x3ea00, 0x3eabc,
+		0x3eb00, 0x3eb70,
+		0x3f000, 0x3f048,
+		0x3f060, 0x3f09c,
+		0x3f0f0, 0x3f148,
+		0x3f160, 0x3f19c,
+		0x3f1f0, 0x3f2e4,
+		0x3f2f8, 0x3f3e4,
+		0x3f3f8, 0x3f448,
+		0x3f460, 0x3f49c,
+		0x3f4f0, 0x3f548,
+		0x3f560, 0x3f59c,
+		0x3f5f0, 0x3f6e4,
+		0x3f6f8, 0x3f7e4,
+		0x3f7f8, 0x3f7fc,
+		0x3f814, 0x3f814,
+		0x3f82c, 0x3f82c,
+		0x3f880, 0x3f88c,
+		0x3f8e8, 0x3f8ec,
+		0x3f900, 0x3f948,
+		0x3f960, 0x3f99c,
+		0x3f9f0, 0x3fae4,
+		0x3faf8, 0x3fb10,
+		0x3fb28, 0x3fb28,
+		0x3fb3c, 0x3fb50,
+		0x3fbf0, 0x3fc10,
+		0x3fc28, 0x3fc28,
+		0x3fc3c, 0x3fc50,
+		0x3fcf0, 0x3fcfc,
+		0x40000, 0x4000c,
+		0x40040, 0x40068,
+		0x40080, 0x40144,
+		0x40180, 0x4018c,
+		0x40200, 0x40298,
+		0x402ac, 0x4033c,
+		0x403f8, 0x403fc,
+		0x41304, 0x413c4,
+		0x41400, 0x4141c,
+		0x41480, 0x414d0,
+		0x44000, 0x44078,
+		0x440c0, 0x44278,
+		0x442c0, 0x44478,
+		0x444c0, 0x44678,
+		0x446c0, 0x44878,
+		0x448c0, 0x449fc,
+		0x45000, 0x45068,
+		0x45080, 0x45084,
+		0x450a0, 0x450b0,
+		0x45200, 0x45268,
+		0x45280, 0x45284,
+		0x452a0, 0x452b0,
+		0x460c0, 0x460e4,
+		0x47000, 0x4708c,
+		0x47200, 0x47250,
+		0x47400, 0x47420,
+		0x47600, 0x47618,
+		0x47800, 0x47814,
+		0x48000, 0x4800c,
+		0x48040, 0x48068,
+		0x48080, 0x48144,
+		0x48180, 0x4818c,
+		0x48200, 0x48298,
+		0x482ac, 0x4833c,
+		0x483f8, 0x483fc,
+		0x49304, 0x493c4,
+		0x49400, 0x4941c,
+		0x49480, 0x494d0,
+		0x4c000, 0x4c078,
+		0x4c0c0, 0x4c278,
+		0x4c2c0, 0x4c478,
+		0x4c4c0, 0x4c678,
+		0x4c6c0, 0x4c878,
+		0x4c8c0, 0x4c9fc,
+		0x4d000, 0x4d068,
+		0x4d080, 0x4d084,
+		0x4d0a0, 0x4d0b0,
+		0x4d200, 0x4d268,
+		0x4d280, 0x4d284,
+		0x4d2a0, 0x4d2b0,
+		0x4e0c0, 0x4e0e4,
+		0x4f000, 0x4f08c,
+		0x4f200, 0x4f250,
+		0x4f400, 0x4f420,
+		0x4f600, 0x4f618,
+		0x4f800, 0x4f814,
+		0x50000, 0x500cc,
+		0x50400, 0x50400,
+		0x50800, 0x508cc,
+		0x50c00, 0x50c00,
+		0x51000, 0x5101c,
+		0x51300, 0x51308,
+	};
+
+	u32 *buf_end = (u32 *)((char *)buf + buf_size);
+	const unsigned int *reg_ranges;
+	int reg_ranges_size, range;
+	unsigned int chip_version = CHELSIO_CHIP_VERSION(adap->params.chip);
+
+	/* Select the right set of register ranges to dump depending on the
+	 * adapter chip type.
+	 */
+	switch (chip_version) {
+	case CHELSIO_T4:
+		reg_ranges = t4_reg_ranges;
+		reg_ranges_size = ARRAY_SIZE(t4_reg_ranges);
+		break;
+
+	case CHELSIO_T5:
+		reg_ranges = t5_reg_ranges;
+		reg_ranges_size = ARRAY_SIZE(t5_reg_ranges);
+		break;
+
+	default:
+		dev_err(adap->pdev_dev,
+			"Unsupported chip version %d\n", chip_version);
+		return;
+	}
+
+	/* Clear the register buffer and insert the appropriate register
+	 * values selected by the above register ranges.
+	 */
+	memset(buf, 0, buf_size);
+	for (range = 0; range < reg_ranges_size; range += 2) {
+		unsigned int reg = reg_ranges[range];
+		unsigned int last_reg = reg_ranges[range + 1];
+		u32 *bufp = (u32 *)((char *)buf + reg);
+
+		/* Iterate across the register range filling in the register
+		 * buffer but don't write past the end of the register buffer.
+		 */
+		while (reg <= last_reg && bufp < buf_end) {
+			*bufp++ = t4_read_reg(adap, reg);
+			reg += sizeof(u32);
+		}
+	}
+}
+
 #define EEPROM_STAT_ADDR   0x7bfc
 #define VPD_BASE           0x400
 #define VPD_BASE_OLD       0
