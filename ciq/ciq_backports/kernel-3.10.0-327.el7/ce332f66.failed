srcu: API for barrier after srcu read unlock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Michael S. Tsirkin <mst@redhat.com>
commit ce332f662deb545c8a4f3f58debcca26bb2e44b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ce332f66.failed

srcu read lock/unlock include a full memory barrier
but that's an implementation detail.
Add an API for make memory fencing explicit for
users that need this barrier, to make sure we
can change it as needed without breaking all users.

	Acked-by: "Paul E. McKenney" <paulmck@linux.vnet.ibm.com>
	Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
	Signed-off-by: Gleb Natapov <gleb@redhat.com>
(cherry picked from commit ce332f662deb545c8a4f3f58debcca26bb2e44b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/srcu.h
diff --cc include/linux/srcu.h
index 04f4121a23ae,9b058eecd403..000000000000
--- a/include/linux/srcu.h
+++ b/include/linux/srcu.h
@@@ -238,46 -238,17 +238,60 @@@ static inline void srcu_read_unlock(str
  }
  
  /**
++<<<<<<< HEAD
 + * srcu_read_lock_raw - register a new reader for an SRCU-protected structure.
 + * @sp: srcu_struct in which to register the new reader.
 + *
 + * Enter an SRCU read-side critical section.  Similar to srcu_read_lock(),
 + * but avoids the RCU-lockdep checking.  This means that it is legal to
 + * use srcu_read_lock_raw() in one context, for example, in an exception
 + * handler, and then have the matching srcu_read_unlock_raw() in another
 + * context, for example in the task that took the exception.
 + *
 + * However, the entire SRCU read-side critical section must reside within a
 + * single task.  For example, beware of using srcu_read_lock_raw() in
 + * a device interrupt handler and srcu_read_unlock() in the interrupted
 + * task:  This will not work if interrupts are threaded.
 + */
 +static inline int srcu_read_lock_raw(struct srcu_struct *sp)
 +{
 +	unsigned long flags;
 +	int ret;
 +
 +	local_irq_save(flags);
 +	ret =  __srcu_read_lock(sp);
 +	local_irq_restore(flags);
 +	return ret;
 +}
 +
 +/**
 + * srcu_read_unlock_raw - unregister reader from an SRCU-protected structure.
 + * @sp: srcu_struct in which to unregister the old reader.
 + * @idx: return value from corresponding srcu_read_lock_raw().
 + *
 + * Exit an SRCU read-side critical section without lockdep-RCU checking.
 + * See srcu_read_lock_raw() for more details.
 + */
 +static inline void srcu_read_unlock_raw(struct srcu_struct *sp, int idx)
 +{
 +	unsigned long flags;
 +
 +	local_irq_save(flags);
 +	__srcu_read_unlock(sp, idx);
 +	local_irq_restore(flags);
++=======
+  * smp_mb__after_srcu_read_unlock - ensure full ordering after srcu_read_unlock
+  *
+  * Converts the preceding srcu_read_unlock into a two-way memory barrier.
+  *
+  * Call this after srcu_read_unlock, to guarantee that all memory operations
+  * that occur after smp_mb__after_srcu_read_unlock will appear to happen after
+  * the preceding srcu_read_unlock.
+  */
+ static inline void smp_mb__after_srcu_read_unlock(void)
+ {
+ 	/* __srcu_read_unlock has smp_mb() internally so nothing to do here. */
++>>>>>>> ce332f662deb (srcu: API for barrier after srcu read unlock)
  }
  
  #endif
* Unmerged path include/linux/srcu.h
