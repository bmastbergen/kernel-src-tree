drm/dp/mst: fixup handling hotplug on port removal.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [drm] dp_mst: fixup handling hotplug on port removal (Dave Airlie) [1251331]
Rebuild_FUZZ: 92.78%
commit-author Dave Airlie <airlied@redhat.com>
commit df4839fdc9b3c922586b945f062f38cbbda022bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/df4839fd.failed

output ports should always have a connector, unless
in the rare case connector allocation fails in the
driver.

In this case we only need to teardown the pdt,
and free the struct, and there is no need to
send a hotplug msg.

In the case were we add the port to the destroy
list we need to send a hotplug if we destroy
any connectors, so userspace knows to reprobe
stuff.

this patch also handles port->connector allocation
failing which should be a rare event, but makes
the code consistent.

	Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: stable@vger.kernel.org
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit df4839fdc9b3c922586b945f062f38cbbda022bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_dp_mst_topology.c
diff --cc drivers/gpu/drm/drm_dp_mst_topology.c
index 4e5ebafd116c,d11052c2f84a..000000000000
--- a/drivers/gpu/drm/drm_dp_mst_topology.c
+++ b/drivers/gpu/drm/drm_dp_mst_topology.c
@@@ -859,18 -863,33 +859,38 @@@ static void drm_dp_destroy_port(struct 
  {
  	struct drm_dp_mst_port *port = container_of(kref, struct drm_dp_mst_port, kref);
  	struct drm_dp_mst_topology_mgr *mgr = port->mgr;
+ 
  	if (!port->input) {
  		port->vcpi.num_slots = 0;
++<<<<<<< HEAD
 +		if (port->connector)
 +			(*port->mgr->cbs->destroy_connector)(mgr, port->connector);
++=======
+ 
+ 		kfree(port->cached_edid);
+ 
+ 		/*
+ 		 * The only time we don't have a connector
+ 		 * on an output port is if the connector init
+ 		 * fails.
+ 		 */
+ 		if (port->connector) {
+ 			/* we can't destroy the connector here, as
+ 			 * we might be holding the mode_config.mutex
+ 			 * from an EDID retrieval */
+ 
+ 			mutex_lock(&mgr->destroy_connector_lock);
+ 			list_add(&port->next, &mgr->destroy_connector_list);
+ 			mutex_unlock(&mgr->destroy_connector_lock);
+ 			schedule_work(&mgr->destroy_connector_work);
+ 			return;
+ 		}
+ 		/* no need to clean up vcpi
+ 		 * as if we have no connector we never setup a vcpi */
++>>>>>>> df4839fdc9b3 (drm/dp/mst: fixup handling hotplug on port removal.)
  		drm_dp_port_teardown_pdt(port, port->pdt);
- 
- 		if (!port->input && port->vcpi.vcpi > 0)
- 			drm_dp_mst_put_payload_id(mgr, port->vcpi.vcpi);
  	}
  	kfree(port);
- 
- 	(*mgr->cbs->hotplug)(mgr);
  }
  
  static void drm_dp_put_port(struct drm_dp_mst_port *port)
@@@ -1098,10 -1117,24 +1118,26 @@@ static void drm_dp_add_port(struct drm_
  
  	if (created && !port->input) {
  		char proppath[255];
 -
 -		build_mst_prop_path(mstb, port->port_num, proppath, sizeof(proppath));
 +		build_mst_prop_path(port, mstb, proppath);
  		port->connector = (*mstb->mgr->cbs->add_connector)(mstb->mgr, port, proppath);
++<<<<<<< HEAD
++=======
+ 		if (!port->connector) {
+ 			/* remove it from the port list */
+ 			mutex_lock(&mstb->mgr->lock);
+ 			list_del(&port->next);
+ 			mutex_unlock(&mstb->mgr->lock);
+ 			/* drop port list reference */
+ 			drm_dp_put_port(port);
+ 			goto out;
+ 		}
+ 		if (port->port_num >= 8) {
+ 			port->cached_edid = drm_get_edid(port->connector, &port->aux.ddc);
+ 		}
++>>>>>>> df4839fdc9b3 (drm/dp/mst: fixup handling hotplug on port removal.)
  	}
  
+ out:
  	/* put reference to this port */
  	drm_dp_put_port(port);
  }
@@@ -2608,6 -2681,39 +2644,42 @@@ static void drm_dp_tx_work(struct work_
  	mutex_unlock(&mgr->qlock);
  }
  
++<<<<<<< HEAD
++=======
+ static void drm_dp_destroy_connector_work(struct work_struct *work)
+ {
+ 	struct drm_dp_mst_topology_mgr *mgr = container_of(work, struct drm_dp_mst_topology_mgr, destroy_connector_work);
+ 	struct drm_dp_mst_port *port;
+ 	bool send_hotplug = false;
+ 	/*
+ 	 * Not a regular list traverse as we have to drop the destroy
+ 	 * connector lock before destroying the connector, to avoid AB->BA
+ 	 * ordering between this lock and the config mutex.
+ 	 */
+ 	for (;;) {
+ 		mutex_lock(&mgr->destroy_connector_lock);
+ 		port = list_first_entry_or_null(&mgr->destroy_connector_list, struct drm_dp_mst_port, next);
+ 		if (!port) {
+ 			mutex_unlock(&mgr->destroy_connector_lock);
+ 			break;
+ 		}
+ 		list_del(&port->next);
+ 		mutex_unlock(&mgr->destroy_connector_lock);
+ 
+ 		mgr->cbs->destroy_connector(mgr, port->connector);
+ 
+ 		drm_dp_port_teardown_pdt(port, port->pdt);
+ 
+ 		if (!port->input && port->vcpi.vcpi > 0)
+ 			drm_dp_mst_put_payload_id(mgr, port->vcpi.vcpi);
+ 		kfree(port);
+ 		send_hotplug = true;
+ 	}
+ 	if (send_hotplug)
+ 		(*mgr->cbs->hotplug)(mgr);
+ }
+ 
++>>>>>>> df4839fdc9b3 (drm/dp/mst: fixup handling hotplug on port removal.)
  /**
   * drm_dp_mst_topology_mgr_init - initialise a topology manager
   * @mgr: manager struct to initialise
* Unmerged path drivers/gpu/drm/drm_dp_mst_topology.c
