ipmi: Cleanup DEBUG_TIMING ifdef usage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author John Stultz <john.stultz@linaro.org>
commit f93aae9f8d30fc96fc57740f5e9260cf719c39d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f93aae9f.failed

The driver uses #ifdef DEBUG_TIMING in order to conditionally print out
timestamped debug messages. Unfortunately it adds the ifdefs all over the
usage sites.

This patch cleans it up by adding a debug_timestamp() function which
is compiled out if DEBUG_TIMING isn't present. This cleans up all
the ugly ifdefs in the function logic.

	Cc: openipmi-developer@lists.sourceforge.net
	Cc: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: John Stultz <john.stultz@linaro.org>
	Signed-off-by: Corey Minyard <minyard@mvista.com>
(cherry picked from commit f93aae9f8d30fc96fc57740f5e9260cf719c39d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 542a86a528b9,5116f767610d..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -349,32 -370,16 +361,41 @@@ static void return_hosed_msg(struct smi
  static enum si_sm_result start_next_msg(struct smi_info *smi_info)
  {
  	int              rv;
++<<<<<<< HEAD
 +	struct list_head *entry = NULL;
 +#ifdef DEBUG_TIMING
 +	struct timeval t;
 +#endif
++=======
++>>>>>>> f93aae9f8d30 (ipmi: Cleanup DEBUG_TIMING ifdef usage)
  
 -	if (!smi_info->waiting_msg) {
 +	/* Pick the high priority queue first. */
 +	if (!list_empty(&(smi_info->hp_xmit_msgs))) {
 +		entry = smi_info->hp_xmit_msgs.next;
 +	} else if (!list_empty(&(smi_info->xmit_msgs))) {
 +		entry = smi_info->xmit_msgs.next;
 +	}
 +
 +	if (!entry) {
  		smi_info->curr_msg = NULL;
  		rv = SI_SM_IDLE;
  	} else {
  		int err;
  
++<<<<<<< HEAD
 +		list_del(entry);
 +		smi_info->curr_msg = list_entry(entry,
 +						struct ipmi_smi_msg,
 +						link);
 +#ifdef DEBUG_TIMING
 +		do_gettimeofday(&t);
 +		printk(KERN_DEBUG "**Start2: %d.%9.9d\n", t.tv_sec, t.tv_usec);
 +#endif
++=======
+ 		smi_info->curr_msg = smi_info->waiting_msg;
+ 		smi_info->waiting_msg = NULL;
+ 		debug_timestamp("Start2");
++>>>>>>> f93aae9f8d30 (ipmi: Cleanup DEBUG_TIMING ifdef usage)
  		err = atomic_notifier_call_chain(&xaction_notifier_list,
  				0, smi_info);
  		if (err & NOTIFY_STOP_MASK) {
@@@ -888,23 -931,11 +905,17 @@@ static void sender(void                
  	struct smi_info   *smi_info = send_info;
  	enum si_sm_result result;
  	unsigned long     flags;
- #ifdef DEBUG_TIMING
- 	struct timeval    t;
- #endif
  
 -	BUG_ON(smi_info->waiting_msg);
 -	smi_info->waiting_msg = msg;
 +	if (atomic_read(&smi_info->stop_operation)) {
 +		msg->rsp[0] = msg->data[0] | 4;
 +		msg->rsp[1] = msg->data[1];
 +		msg->rsp[2] = IPMI_ERR_UNSPECIFIED;
 +		msg->rsp_size = 3;
 +		deliver_recv_msg(smi_info, msg);
 +		return;
 +	}
  
- #ifdef DEBUG_TIMING
- 	do_gettimeofday(&t);
- 	printk("**Enqueue: %d.%9.9d\n", t.tv_sec, t.tv_usec);
- #endif
+ 	debug_timestamp("Enqueue");
  
  	if (smi_info->run_to_completion) {
  		/*
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
