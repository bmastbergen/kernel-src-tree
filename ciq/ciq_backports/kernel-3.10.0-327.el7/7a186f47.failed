sfc: add legacy method for changing a PF's MAC address

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Daniel Pieczko <dpieczko@solarflare.com>
commit 7a186f4703de6f4b7feb5d09735b096145b8918c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/7a186f47.failed

Some versions of MCFW do not support the MC_CMD_VADAPTOR_SET_MAC
command, and ENOSYS will be returned.

If the PF created its own vport, the function's datapath must be
stopped and the vport can be reconfigured to reflect the new MAC
address.

If the MCFW created the vport for the PF (which is the case when
the nic_data->vport_mac is blank), nothing further needs to be
done as the vport is not under the control of the PF.

This only applies to PFs because the MCFW in question does not
support VFs.

	Signed-off-by: Shradha Shah <sshah@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7a186f4703de6f4b7feb5d09735b096145b8918c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/ef10.c
#	drivers/net/ethernet/sfc/ef10_sriov.c
#	drivers/net/ethernet/sfc/ef10_sriov.h
diff --cc drivers/net/ethernet/sfc/ef10.c
index 95f33d51af2f,e0cb3617f549..000000000000
--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@@ -93,9 -95,55 +93,55 @@@ static int efx_ef10_get_warm_boot_count
  
  static unsigned int efx_ef10_mem_map_size(struct efx_nic *efx)
  {
 -	int bar;
 -
 -	bar = efx->type->mem_bar;
 -	return resource_size(&efx->pci_dev->resource[bar]);
 +	return resource_size(&efx->pci_dev->resource[EFX_MEM_BAR]);
  }
  
++<<<<<<< HEAD
++=======
+ static bool efx_ef10_is_vf(struct efx_nic *efx)
+ {
+ 	return efx->type->is_vf;
+ }
+ 
+ static int efx_ef10_get_pf_index(struct efx_nic *efx)
+ {
+ 	MCDI_DECLARE_BUF(outbuf, MC_CMD_GET_FUNCTION_INFO_OUT_LEN);
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	size_t outlen;
+ 	int rc;
+ 
+ 	rc = efx_mcdi_rpc(efx, MC_CMD_GET_FUNCTION_INFO, NULL, 0, outbuf,
+ 			  sizeof(outbuf), &outlen);
+ 	if (rc)
+ 		return rc;
+ 	if (outlen < sizeof(outbuf))
+ 		return -EIO;
+ 
+ 	nic_data->pf_index = MCDI_DWORD(outbuf, GET_FUNCTION_INFO_OUT_PF);
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_SFC_SRIOV
+ static int efx_ef10_get_vf_index(struct efx_nic *efx)
+ {
+ 	MCDI_DECLARE_BUF(outbuf, MC_CMD_GET_FUNCTION_INFO_OUT_LEN);
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	size_t outlen;
+ 	int rc;
+ 
+ 	rc = efx_mcdi_rpc(efx, MC_CMD_GET_FUNCTION_INFO, NULL, 0, outbuf,
+ 			  sizeof(outbuf), &outlen);
+ 	if (rc)
+ 		return rc;
+ 	if (outlen < sizeof(outbuf))
+ 		return -EIO;
+ 
+ 	nic_data->vf_index = MCDI_DWORD(outbuf, GET_FUNCTION_INFO_OUT_VF);
+ 	return 0;
+ }
+ #endif
+ 
++>>>>>>> 7a186f4703de (sfc: add legacy method for changing a PF's MAC address)
  static int efx_ef10_init_datapath_caps(struct efx_nic *efx)
  {
  	MCDI_DECLARE_BUF(outbuf, MC_CMD_GET_CAPABILITIES_OUT_LEN);
@@@ -524,6 -677,112 +570,115 @@@ static void efx_ef10_remove(struct efx_
  	kfree(nic_data);
  }
  
++<<<<<<< HEAD
++=======
+ static int efx_ef10_probe_pf(struct efx_nic *efx)
+ {
+ 	return efx_ef10_probe(efx);
+ }
+ 
+ int efx_ef10_vadaptor_alloc(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VADAPTOR_ALLOC_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VADAPTOR_ALLOC_IN_UPSTREAM_PORT_ID, port_id);
+ 	return efx_mcdi_rpc(efx, MC_CMD_VADAPTOR_ALLOC, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ int efx_ef10_vadaptor_free(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VADAPTOR_FREE_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VADAPTOR_FREE_IN_UPSTREAM_PORT_ID, port_id);
+ 	return efx_mcdi_rpc(efx, MC_CMD_VADAPTOR_FREE, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ int efx_ef10_vport_add_mac(struct efx_nic *efx,
+ 			   unsigned int port_id, u8 *mac)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_ADD_MAC_ADDRESS_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_ADD_MAC_ADDRESS_IN_VPORT_ID, port_id);
+ 	ether_addr_copy(MCDI_PTR(inbuf, VPORT_ADD_MAC_ADDRESS_IN_MACADDR), mac);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VPORT_ADD_MAC_ADDRESS, inbuf,
+ 			    sizeof(inbuf), NULL, 0, NULL);
+ }
+ 
+ int efx_ef10_vport_del_mac(struct efx_nic *efx,
+ 			   unsigned int port_id, u8 *mac)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_DEL_MAC_ADDRESS_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_DEL_MAC_ADDRESS_IN_VPORT_ID, port_id);
+ 	ether_addr_copy(MCDI_PTR(inbuf, VPORT_DEL_MAC_ADDRESS_IN_MACADDR), mac);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VPORT_DEL_MAC_ADDRESS, inbuf,
+ 			    sizeof(inbuf), NULL, 0, NULL);
+ }
+ 
+ #ifdef CONFIG_SFC_SRIOV
+ static int efx_ef10_probe_vf(struct efx_nic *efx)
+ {
+ 	int rc;
+ 	struct pci_dev *pci_dev_pf;
+ 
+ 	/* If the parent PF has no VF data structure, it doesn't know about this
+ 	 * VF so fail probe.  The VF needs to be re-created.  This can happen
+ 	 * if the PF driver is unloaded while the VF is assigned to a guest.
+ 	 */
+ 	pci_dev_pf = efx->pci_dev->physfn;
+ 	if (pci_dev_pf) {
+ 		struct efx_nic *efx_pf = pci_get_drvdata(pci_dev_pf);
+ 		struct efx_ef10_nic_data *nic_data_pf = efx_pf->nic_data;
+ 
+ 		if (!nic_data_pf->vf) {
+ 			netif_info(efx, drv, efx->net_dev,
+ 				   "The VF cannot link to its parent PF; "
+ 				   "please destroy and re-create the VF\n");
+ 			return -EBUSY;
+ 		}
+ 	}
+ 
+ 	rc = efx_ef10_probe(efx);
+ 	if (rc)
+ 		return rc;
+ 
+ 	rc = efx_ef10_get_vf_index(efx);
+ 	if (rc)
+ 		goto fail;
+ 
+ 	if (efx->pci_dev->is_virtfn) {
+ 		if (efx->pci_dev->physfn) {
+ 			struct efx_nic *efx_pf =
+ 				pci_get_drvdata(efx->pci_dev->physfn);
+ 			struct efx_ef10_nic_data *nic_data_p = efx_pf->nic_data;
+ 			struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 			nic_data_p->vf[nic_data->vf_index].efx = efx;
+ 			nic_data_p->vf[nic_data->vf_index].pci_dev =
+ 				efx->pci_dev;
+ 		} else
+ 			netif_info(efx, drv, efx->net_dev,
+ 				   "Could not get the PF id from VF\n");
+ 	}
+ 
+ 	return 0;
+ 
+ fail:
+ 	efx_ef10_remove(efx);
+ 	return rc;
+ }
+ #else
+ static int efx_ef10_probe_vf(struct efx_nic *efx __attribute__ ((unused)))
+ {
+ 	return 0;
+ }
+ #endif
+ 
++>>>>>>> 7a186f4703de (sfc: add legacy method for changing a PF's MAC address)
  static int efx_ef10_alloc_vis(struct efx_nic *efx,
  			      unsigned int min_vis, unsigned int max_vis)
  {
@@@ -3353,6 -3851,146 +3508,149 @@@ static void efx_ef10_filter_sync_rx_mod
  	WARN_ON(remove_failed);
  }
  
++<<<<<<< HEAD
++=======
+ static int efx_ef10_vport_set_mac_address(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	u8 mac_old[ETH_ALEN];
+ 	int rc, rc2;
+ 
+ 	/* Only reconfigure a PF-created vport */
+ 	if (is_zero_ether_addr(nic_data->vport_mac))
+ 		return 0;
+ 
+ 	efx_device_detach_sync(efx);
+ 	efx_net_stop(efx->net_dev);
+ 	down_write(&efx->filter_sem);
+ 	efx_ef10_filter_table_remove(efx);
+ 	up_write(&efx->filter_sem);
+ 
+ 	rc = efx_ef10_vadaptor_free(efx, nic_data->vport_id);
+ 	if (rc)
+ 		goto restore_filters;
+ 
+ 	ether_addr_copy(mac_old, nic_data->vport_mac);
+ 	rc = efx_ef10_vport_del_mac(efx, nic_data->vport_id,
+ 				    nic_data->vport_mac);
+ 	if (rc)
+ 		goto restore_vadaptor;
+ 
+ 	rc = efx_ef10_vport_add_mac(efx, nic_data->vport_id,
+ 				    efx->net_dev->dev_addr);
+ 	if (!rc) {
+ 		ether_addr_copy(nic_data->vport_mac, efx->net_dev->dev_addr);
+ 	} else {
+ 		rc2 = efx_ef10_vport_add_mac(efx, nic_data->vport_id, mac_old);
+ 		if (rc2) {
+ 			/* Failed to add original MAC, so clear vport_mac */
+ 			eth_zero_addr(nic_data->vport_mac);
+ 			goto reset_nic;
+ 		}
+ 	}
+ 
+ restore_vadaptor:
+ 	rc2 = efx_ef10_vadaptor_alloc(efx, nic_data->vport_id);
+ 	if (rc2)
+ 		goto reset_nic;
+ restore_filters:
+ 	down_write(&efx->filter_sem);
+ 	rc2 = efx_ef10_filter_table_probe(efx);
+ 	up_write(&efx->filter_sem);
+ 	if (rc2)
+ 		goto reset_nic;
+ 
+ 	rc2 = efx_net_open(efx->net_dev);
+ 	if (rc2)
+ 		goto reset_nic;
+ 
+ 	netif_device_attach(efx->net_dev);
+ 
+ 	return rc;
+ 
+ reset_nic:
+ 	netif_err(efx, drv, efx->net_dev,
+ 		  "Failed to restore when changing MAC address - scheduling reset\n");
+ 	efx_schedule_reset(efx, RESET_TYPE_DATAPATH);
+ 
+ 	return rc ? rc : rc2;
+ }
+ 
+ static int efx_ef10_set_mac_address(struct efx_nic *efx)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VADAPTOR_SET_MAC_IN_LEN);
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	bool was_enabled = efx->port_enabled;
+ 	int rc;
+ 
+ 	efx_device_detach_sync(efx);
+ 	efx_net_stop(efx->net_dev);
+ 	down_write(&efx->filter_sem);
+ 	efx_ef10_filter_table_remove(efx);
+ 
+ 	ether_addr_copy(MCDI_PTR(inbuf, VADAPTOR_SET_MAC_IN_MACADDR),
+ 			efx->net_dev->dev_addr);
+ 	MCDI_SET_DWORD(inbuf, VADAPTOR_SET_MAC_IN_UPSTREAM_PORT_ID,
+ 		       nic_data->vport_id);
+ 	rc = efx_mcdi_rpc(efx, MC_CMD_VADAPTOR_SET_MAC, inbuf,
+ 			  sizeof(inbuf), NULL, 0, NULL);
+ 
+ 	efx_ef10_filter_table_probe(efx);
+ 	up_write(&efx->filter_sem);
+ 	if (was_enabled)
+ 		efx_net_open(efx->net_dev);
+ 	netif_device_attach(efx->net_dev);
+ 
+ #ifdef CONFIG_SFC_SRIOV
+ 	if (efx->pci_dev->is_virtfn && efx->pci_dev->physfn) {
+ 		struct pci_dev *pci_dev_pf = efx->pci_dev->physfn;
+ 
+ 		if (rc == -EPERM) {
+ 			struct efx_nic *efx_pf;
+ 
+ 			/* Switch to PF and change MAC address on vport */
+ 			efx_pf = pci_get_drvdata(pci_dev_pf);
+ 
+ 			rc = efx_ef10_sriov_set_vf_mac(efx_pf,
+ 						       nic_data->vf_index,
+ 						       efx->net_dev->dev_addr);
+ 		} else if (!rc) {
+ 			struct efx_nic *efx_pf = pci_get_drvdata(pci_dev_pf);
+ 			struct efx_ef10_nic_data *nic_data = efx_pf->nic_data;
+ 			unsigned int i;
+ 
+ 			/* MAC address successfully changed by VF (with MAC
+ 			 * spoofing) so update the parent PF if possible.
+ 			 */
+ 			for (i = 0; i < efx_pf->vf_count; ++i) {
+ 				struct ef10_vf *vf = nic_data->vf + i;
+ 
+ 				if (vf->efx == efx) {
+ 					ether_addr_copy(vf->mac,
+ 							efx->net_dev->dev_addr);
+ 					return 0;
+ 				}
+ 			}
+ 		}
+ 	} else
+ #endif
+ 	if (rc == -EPERM) {
+ 		netif_err(efx, drv, efx->net_dev,
+ 			  "Cannot change MAC address; use sfboot to enable"
+ 			  " mac-spoofing on this interface\n");
+ 	} else if (rc == -ENOSYS && !efx_ef10_is_vf(efx)) {
+ 		/* If the active MCFW does not support MC_CMD_VADAPTOR_SET_MAC
+ 		 * fall-back to the method of changing the MAC address on the
+ 		 * vport.  This only applies to PFs because such versions of
+ 		 * MCFW do not support VFs.
+ 		 */
+ 		rc = efx_ef10_vport_set_mac_address(efx);
+ 	}
+ 
+ 	return rc;
+ }
+ 
++>>>>>>> 7a186f4703de (sfc: add legacy method for changing a PF's MAC address)
  static int efx_ef10_mac_reconfigure(struct efx_nic *efx)
  {
  	efx_ef10_filter_sync_rx_mode(efx);
diff --cc drivers/net/ethernet/sfc/ef10_sriov.c
index 9e6a3e197e01,7485f71b4e2f..000000000000
--- a/drivers/net/ethernet/sfc/ef10_sriov.c
+++ b/drivers/net/ethernet/sfc/ef10_sriov.c
@@@ -13,7 -14,345 +13,349 @@@
  #include "nic.h"
  #include "mcdi_pcol.h"
  
++<<<<<<< HEAD
 +#ifdef CONFIG_SFC_SRIOV
++=======
+ static int efx_ef10_evb_port_assign(struct efx_nic *efx, unsigned int port_id,
+ 				    unsigned int vf_fn)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_EVB_PORT_ASSIGN_IN_LEN);
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	MCDI_SET_DWORD(inbuf, EVB_PORT_ASSIGN_IN_PORT_ID, port_id);
+ 	MCDI_POPULATE_DWORD_2(inbuf, EVB_PORT_ASSIGN_IN_FUNCTION,
+ 			      EVB_PORT_ASSIGN_IN_PF, nic_data->pf_index,
+ 			      EVB_PORT_ASSIGN_IN_VF, vf_fn);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_EVB_PORT_ASSIGN, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vswitch_alloc(struct efx_nic *efx, unsigned int port_id,
+ 				  unsigned int vswitch_type)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VSWITCH_ALLOC_IN_LEN);
+ 	int rc;
+ 
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_UPSTREAM_PORT_ID, port_id);
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_TYPE, vswitch_type);
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_NUM_VLAN_TAGS, 2);
+ 	MCDI_POPULATE_DWORD_1(inbuf, VSWITCH_ALLOC_IN_FLAGS,
+ 			      VSWITCH_ALLOC_IN_FLAG_AUTO_PORT, 0);
+ 
+ 	/* Quietly try to allocate 2 VLAN tags */
+ 	rc = efx_mcdi_rpc_quiet(efx, MC_CMD_VSWITCH_ALLOC, inbuf, sizeof(inbuf),
+ 				NULL, 0, NULL);
+ 
+ 	/* If 2 VLAN tags is too many, revert to trying with 1 VLAN tags */
+ 	if (rc == -EPROTO) {
+ 		MCDI_SET_DWORD(inbuf, VSWITCH_ALLOC_IN_NUM_VLAN_TAGS, 1);
+ 		rc = efx_mcdi_rpc(efx, MC_CMD_VSWITCH_ALLOC, inbuf,
+ 				  sizeof(inbuf), NULL, 0, NULL);
+ 	} else if (rc) {
+ 		efx_mcdi_display_error(efx, MC_CMD_VSWITCH_ALLOC,
+ 				       MC_CMD_VSWITCH_ALLOC_IN_LEN,
+ 				       NULL, 0, rc);
+ 	}
+ 	return rc;
+ }
+ 
+ static int efx_ef10_vswitch_free(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VSWITCH_FREE_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VSWITCH_FREE_IN_UPSTREAM_PORT_ID, port_id);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VSWITCH_FREE, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static int efx_ef10_vport_alloc(struct efx_nic *efx,
+ 				unsigned int port_id_in,
+ 				unsigned int vport_type,
+ 				u16 vlan,
+ 				unsigned int *port_id_out)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_ALLOC_IN_LEN);
+ 	MCDI_DECLARE_BUF(outbuf, MC_CMD_VPORT_ALLOC_OUT_LEN);
+ 	size_t outlen;
+ 	int rc;
+ 
+ 	EFX_WARN_ON_PARANOID(!port_id_out);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_UPSTREAM_PORT_ID, port_id_in);
+ 	MCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_TYPE, vport_type);
+ 	MCDI_SET_DWORD(inbuf, VPORT_ALLOC_IN_NUM_VLAN_TAGS,
+ 		       (vlan != EFX_EF10_NO_VLAN));
+ 	MCDI_POPULATE_DWORD_1(inbuf, VPORT_ALLOC_IN_FLAGS,
+ 			      VPORT_ALLOC_IN_FLAG_AUTO_PORT, 0);
+ 	if (vlan != EFX_EF10_NO_VLAN)
+ 		MCDI_POPULATE_DWORD_1(inbuf, VPORT_ALLOC_IN_VLAN_TAGS,
+ 				      VPORT_ALLOC_IN_VLAN_TAG_0, vlan);
+ 
+ 	rc = efx_mcdi_rpc(efx, MC_CMD_VPORT_ALLOC, inbuf, sizeof(inbuf),
+ 			  outbuf, sizeof(outbuf), &outlen);
+ 	if (rc)
+ 		return rc;
+ 	if (outlen < MC_CMD_VPORT_ALLOC_OUT_LEN)
+ 		return -EIO;
+ 
+ 	*port_id_out = MCDI_DWORD(outbuf, VPORT_ALLOC_OUT_VPORT_ID);
+ 	return 0;
+ }
+ 
+ static int efx_ef10_vport_free(struct efx_nic *efx, unsigned int port_id)
+ {
+ 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_FREE_IN_LEN);
+ 
+ 	MCDI_SET_DWORD(inbuf, VPORT_FREE_IN_VPORT_ID, port_id);
+ 
+ 	return efx_mcdi_rpc(efx, MC_CMD_VPORT_FREE, inbuf, sizeof(inbuf),
+ 			    NULL, 0, NULL);
+ }
+ 
+ static void efx_ef10_sriov_free_vf_vports(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	int i;
+ 
+ 	if (!nic_data->vf)
+ 		return;
+ 
+ 	for (i = 0; i < efx->vf_count; i++) {
+ 		struct ef10_vf *vf = nic_data->vf + i;
+ 
+ 		/* If VF is assigned, do not free the vport  */
+ 		if (vf->pci_dev &&
+ 		    vf->pci_dev->dev_flags & PCI_DEV_FLAGS_ASSIGNED)
+ 			continue;
+ 
+ 		if (vf->vport_assigned) {
+ 			efx_ef10_evb_port_assign(efx, EVB_PORT_ID_NULL, i);
+ 			vf->vport_assigned = 0;
+ 		}
+ 
+ 		if (!is_zero_ether_addr(vf->mac)) {
+ 			efx_ef10_vport_del_mac(efx, vf->vport_id, vf->mac);
+ 			eth_zero_addr(vf->mac);
+ 		}
+ 
+ 		if (vf->vport_id) {
+ 			efx_ef10_vport_free(efx, vf->vport_id);
+ 			vf->vport_id = 0;
+ 		}
+ 
+ 		vf->efx = NULL;
+ 	}
+ }
+ 
+ static void efx_ef10_sriov_free_vf_vswitching(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	efx_ef10_sriov_free_vf_vports(efx);
+ 	kfree(nic_data->vf);
+ 	nic_data->vf = NULL;
+ }
+ 
+ static int efx_ef10_sriov_assign_vf_vport(struct efx_nic *efx,
+ 					  unsigned int vf_i)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	struct ef10_vf *vf = nic_data->vf + vf_i;
+ 	int rc;
+ 
+ 	if (WARN_ON_ONCE(!nic_data->vf))
+ 		return -EOPNOTSUPP;
+ 
+ 	rc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,
+ 				  MC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,
+ 				  vf->vlan, &vf->vport_id);
+ 	if (rc)
+ 		return rc;
+ 
+ 	rc = efx_ef10_vport_add_mac(efx, vf->vport_id, vf->mac);
+ 	if (rc) {
+ 		eth_zero_addr(vf->mac);
+ 		return rc;
+ 	}
+ 
+ 	rc =  efx_ef10_evb_port_assign(efx, vf->vport_id, vf_i);
+ 	if (rc)
+ 		return rc;
+ 
+ 	vf->vport_assigned = 1;
+ 	return 0;
+ }
+ 
+ static int efx_ef10_sriov_alloc_vf_vswitching(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	unsigned int i;
+ 	int rc;
+ 
+ 	nic_data->vf = kcalloc(efx->vf_count, sizeof(struct ef10_vf),
+ 			       GFP_KERNEL);
+ 	if (!nic_data->vf)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < efx->vf_count; i++) {
+ 		random_ether_addr(nic_data->vf[i].mac);
+ 		nic_data->vf[i].efx = NULL;
+ 		nic_data->vf[i].vlan = EFX_EF10_NO_VLAN;
+ 
+ 		rc = efx_ef10_sriov_assign_vf_vport(efx, i);
+ 		if (rc)
+ 			goto fail;
+ 	}
+ 
+ 	return 0;
+ fail:
+ 	efx_ef10_sriov_free_vf_vports(efx);
+ 	kfree(nic_data->vf);
+ 	nic_data->vf = NULL;
+ 	return rc;
+ }
+ 
+ static int efx_ef10_sriov_restore_vf_vswitching(struct efx_nic *efx)
+ {
+ 	unsigned int i;
+ 	int rc;
+ 
+ 	for (i = 0; i < efx->vf_count; i++) {
+ 		rc = efx_ef10_sriov_assign_vf_vport(efx, i);
+ 		if (rc)
+ 			goto fail;
+ 	}
+ 
+ 	return 0;
+ fail:
+ 	efx_ef10_sriov_free_vf_vswitching(efx);
+ 	return rc;
+ }
+ 
+ /* On top of the default firmware vswitch setup, create a VEB vswitch and
+  * expansion vport for use by this function.
+  */
+ int efx_ef10_vswitching_probe_pf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	struct net_device *net_dev = efx->net_dev;
+ 	int rc;
+ 
+ 	if (pci_sriov_get_totalvfs(efx->pci_dev) <= 0) {
+ 		/* vswitch not needed as we have no VFs */
+ 		efx_ef10_vadaptor_alloc(efx, nic_data->vport_id);
+ 		return 0;
+ 	}
+ 
+ 	rc = efx_ef10_vswitch_alloc(efx, EVB_PORT_ID_ASSIGNED,
+ 				    MC_CMD_VSWITCH_ALLOC_IN_VSWITCH_TYPE_VEB);
+ 	if (rc)
+ 		goto fail1;
+ 
+ 	rc = efx_ef10_vport_alloc(efx, EVB_PORT_ID_ASSIGNED,
+ 				  MC_CMD_VPORT_ALLOC_IN_VPORT_TYPE_NORMAL,
+ 				  EFX_EF10_NO_VLAN, &nic_data->vport_id);
+ 	if (rc)
+ 		goto fail2;
+ 
+ 	rc = efx_ef10_vport_add_mac(efx, nic_data->vport_id, net_dev->dev_addr);
+ 	if (rc)
+ 		goto fail3;
+ 	ether_addr_copy(nic_data->vport_mac, net_dev->dev_addr);
+ 
+ 	rc = efx_ef10_vadaptor_alloc(efx, nic_data->vport_id);
+ 	if (rc)
+ 		goto fail4;
+ 
+ 	return 0;
+ fail4:
+ 	efx_ef10_vport_del_mac(efx, nic_data->vport_id, nic_data->vport_mac);
+ 	eth_zero_addr(nic_data->vport_mac);
+ fail3:
+ 	efx_ef10_vport_free(efx, nic_data->vport_id);
+ 	nic_data->vport_id = EVB_PORT_ID_ASSIGNED;
+ fail2:
+ 	efx_ef10_vswitch_free(efx, EVB_PORT_ID_ASSIGNED);
+ fail1:
+ 	return rc;
+ }
+ 
+ int efx_ef10_vswitching_probe_vf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	return efx_ef10_vadaptor_alloc(efx, nic_data->vport_id);
+ }
+ 
+ int efx_ef10_vswitching_restore_pf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	int rc;
+ 
+ 	if (!nic_data->must_probe_vswitching)
+ 		return 0;
+ 
+ 	rc = efx_ef10_vswitching_probe_pf(efx);
+ 	if (rc)
+ 		goto fail;
+ 
+ 	rc = efx_ef10_sriov_restore_vf_vswitching(efx);
+ 	if (rc)
+ 		goto fail;
+ 
+ 	nic_data->must_probe_vswitching = false;
+ fail:
+ 	return rc;
+ }
+ 
+ int efx_ef10_vswitching_restore_vf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 	int rc;
+ 
+ 	if (!nic_data->must_probe_vswitching)
+ 		return 0;
+ 
+ 	rc = efx_ef10_vadaptor_free(efx, EVB_PORT_ID_ASSIGNED);
+ 	if (rc)
+ 		return rc;
+ 
+ 	nic_data->must_probe_vswitching = false;
+ 	return 0;
+ }
+ 
+ void efx_ef10_vswitching_remove_pf(struct efx_nic *efx)
+ {
+ 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
+ 
+ 	efx_ef10_sriov_free_vf_vswitching(efx);
+ 
+ 	efx_ef10_vadaptor_free(efx, nic_data->vport_id);
+ 
+ 	if (nic_data->vport_id == EVB_PORT_ID_ASSIGNED)
+ 		return; /* No vswitch was ever created */
+ 
+ 	if (!is_zero_ether_addr(nic_data->vport_mac)) {
+ 		efx_ef10_vport_del_mac(efx, nic_data->vport_id,
+ 				       efx->net_dev->dev_addr);
+ 		eth_zero_addr(nic_data->vport_mac);
+ 	}
+ 	efx_ef10_vport_free(efx, nic_data->vport_id);
+ 	nic_data->vport_id = EVB_PORT_ID_ASSIGNED;
+ 
+ 	/* Only free the vswitch if no VFs are assigned */
+ 	if (!pci_vfs_assigned(efx->pci_dev))
+ 		efx_ef10_vswitch_free(efx, nic_data->vport_id);
+ }
+ 
+ void efx_ef10_vswitching_remove_vf(struct efx_nic *efx)
+ {
+ 	efx_ef10_vadaptor_free(efx, EVB_PORT_ID_ASSIGNED);
+ }
+ 
++>>>>>>> 7a186f4703de (sfc: add legacy method for changing a PF's MAC address)
  static int efx_ef10_pci_sriov_enable(struct efx_nic *efx, int num_vfs)
  {
  	int rc = 0;
diff --cc drivers/net/ethernet/sfc/ef10_sriov.h
index 6ea115e3c3f2,6d25b92cb45e..000000000000
--- a/drivers/net/ethernet/sfc/ef10_sriov.h
+++ b/drivers/net/ethernet/sfc/ef10_sriov.h
@@@ -18,41 -37,39 +18,65 @@@ static inline bool efx_ef10_sriov_wante
  }
  
  int efx_ef10_sriov_configure(struct efx_nic *efx, int num_vfs);
 -int efx_ef10_sriov_init(struct efx_nic *efx);
 +
 +static inline int efx_ef10_sriov_init(struct efx_nic *efx)
 +{
 +	return -EOPNOTSUPP;
 +}
 +
 +static inline void efx_ef10_sriov_mac_address_changed(struct efx_nic *efx) {}
  static inline void efx_ef10_sriov_reset(struct efx_nic *efx) {}
 -void efx_ef10_sriov_fini(struct efx_nic *efx);
 +static inline void efx_ef10_sriov_fini(struct efx_nic *efx) {}
  static inline void efx_ef10_sriov_flr(struct efx_nic *efx, unsigned vf_i) {}
  
 -int efx_ef10_sriov_set_vf_mac(struct efx_nic *efx, int vf, u8 *mac);
 +#ifdef CONFIG_SFC_SRIOV
 +static inline int efx_ef10_sriov_set_vf_mac(struct efx_nic *efx, int vf,
 +					    u8 *mac)
 +{
 +	return -EOPNOTSUPP;
 +}
  
 -int efx_ef10_sriov_set_vf_vlan(struct efx_nic *efx, int vf_i,
 -			       u16 vlan, u8 qos);
 +static inline int efx_ef10_sriov_set_vf_vlan(struct efx_nic *efx, int vf,
 +					     u16 vlan, u8 qos)
 +{
 +	return -EOPNOTSUPP;
 +}
  
 -int efx_ef10_sriov_set_vf_spoofchk(struct efx_nic *efx, int vf,
 -				   bool spoofchk);
 +static inline int efx_ef10_sriov_set_vf_spoofchk(struct efx_nic *efx, int vf,
 +						 bool spoofchk)
 +{
 +	return -EOPNOTSUPP;
 +}
  
++<<<<<<< HEAD
 +static inline int efx_ef10_sriov_get_vf_config(struct efx_nic *efx, int vf,
 +					       struct ifla_vf_info *ivf)
 +{
 +	return -EOPNOTSUPP;
 +}
 +#endif /* CONFIG_SFC_SRIOV */
++=======
+ int efx_ef10_sriov_get_vf_config(struct efx_nic *efx, int vf_i,
+ 				 struct ifla_vf_info *ivf);
+ 
+ int efx_ef10_sriov_set_vf_link_state(struct efx_nic *efx, int vf_i,
+ 				     int link_state);
+ 
+ int efx_ef10_sriov_get_phys_port_id(struct efx_nic *efx,
+ 				    struct netdev_phys_item_id *ppid);
+ 
+ int efx_ef10_vswitching_probe_pf(struct efx_nic *efx);
+ int efx_ef10_vswitching_probe_vf(struct efx_nic *efx);
+ int efx_ef10_vswitching_restore_pf(struct efx_nic *efx);
+ int efx_ef10_vswitching_restore_vf(struct efx_nic *efx);
+ void efx_ef10_vswitching_remove_pf(struct efx_nic *efx);
+ void efx_ef10_vswitching_remove_vf(struct efx_nic *efx);
+ int efx_ef10_vport_add_mac(struct efx_nic *efx,
+ 			   unsigned int port_id, u8 *mac);
+ int efx_ef10_vport_del_mac(struct efx_nic *efx,
+ 			   unsigned int port_id, u8 *mac);
+ int efx_ef10_vadaptor_alloc(struct efx_nic *efx, unsigned int port_id);
+ int efx_ef10_vadaptor_free(struct efx_nic *efx, unsigned int port_id);
++>>>>>>> 7a186f4703de (sfc: add legacy method for changing a PF's MAC address)
  
  #endif /* EF10_SRIOV_H */
* Unmerged path drivers/net/ethernet/sfc/ef10.c
* Unmerged path drivers/net/ethernet/sfc/ef10_sriov.c
* Unmerged path drivers/net/ethernet/sfc/ef10_sriov.h
