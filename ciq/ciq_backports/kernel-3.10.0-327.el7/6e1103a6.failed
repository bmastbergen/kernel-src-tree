btrfs: fix state->private cast on 32 bit machines

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>
commit 6e1103a6e9b19dbdc348077d04a546b626911fc5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6e1103a6.failed

Suppress the following warning displayed on building 32bit (i686) kernel.

===============================================================================
...
   CC [M]  fs/btrfs/extent_io.o
fs/btrfs/extent_io.c: In function ‘btrfs_free_io_failure_record’:
fs/btrfs/extent_io.c:2193:13: warning: cast to pointer from integer of
different size [-Wint-to-pointer-cast]
    failrec = (struct io_failure_record *)state->private;
...
===============================================================================

	Signed-off-by: Satoru Takeuchi <takeuchi_satoru@jp.fujitsu.com>
	Reported-by: Chris Murphy <chris@colorremedies.com>
	Signed-off-by: Chris Mason <clm@fb.com>
(cherry picked from commit 6e1103a6e9b19dbdc348077d04a546b626911fc5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/extent_io.c
diff --cc fs/btrfs/extent_io.c
index e75094fb3d73,790dbae3343c..000000000000
--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@@ -2185,21 -2166,45 +2185,54 @@@ out
  }
  
  /*
 - * Can be called when
 - * - hold extent lock
 - * - under ordered extent
 - * - the inode is freeing
 + * this is a generic handler for readpage errors (default
 + * readpage_io_failed_hook). if other copies exist, read those and write back
 + * good data to the failed position. does not investigate in remapping the
 + * failed extent elsewhere, hoping the device will be smart enough to do this as
 + * needed
   */
 -void btrfs_free_io_failure_record(struct inode *inode, u64 start, u64 end)
 +
 +static int bio_readpage_error(struct bio *failed_bio, u64 phy_offset,
 +			      struct page *page, u64 start, u64 end,
 +			      int failed_mirror)
  {
++<<<<<<< HEAD
 +	struct io_failure_record *failrec = NULL;
++=======
+ 	struct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;
+ 	struct io_failure_record *failrec;
+ 	struct extent_state *state, *next;
+ 
+ 	if (RB_EMPTY_ROOT(&failure_tree->state))
+ 		return;
+ 
+ 	spin_lock(&failure_tree->lock);
+ 	state = find_first_extent_bit_state(failure_tree, start, EXTENT_DIRTY);
+ 	while (state) {
+ 		if (state->start > end)
+ 			break;
+ 
+ 		ASSERT(state->end <= end);
+ 
+ 		next = next_state(state);
+ 
+ 		failrec = (struct io_failure_record *)(unsigned long)state->private;
+ 		free_extent_state(state);
+ 		kfree(failrec);
+ 
+ 		state = next;
+ 	}
+ 	spin_unlock(&failure_tree->lock);
+ }
+ 
+ int btrfs_get_io_failure_record(struct inode *inode, u64 start, u64 end,
+ 				struct io_failure_record **failrec_ret)
+ {
+ 	struct io_failure_record *failrec;
++>>>>>>> 6e1103a6e9b1 (btrfs: fix state->private cast on 32 bit machines)
  	u64 private;
  	struct extent_map *em;
 +	struct inode *inode = page->mapping->host;
  	struct extent_io_tree *failure_tree = &BTRFS_I(inode)->io_failure_tree;
  	struct extent_io_tree *tree = &BTRFS_I(inode)->io_tree;
  	struct extent_map_tree *em_tree = &BTRFS_I(inode)->extent_tree;
* Unmerged path fs/btrfs/extent_io.c
