vti6: Add pmtu handling to vti6_xmit.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] vti6: Add pmtu handling to vti6_xmit (Alexander Duyck) [1129761]
Rebuild_FUZZ: 98.63%
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit ccd740cbc6e01b2a08baa341867063ed2887f4b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ccd740cb.failed

We currently rely on the PMTU discovery of xfrm.
However if a packet is localy sent, the PMTU mechanism
of xfrm tries to to local socket notification what
might not work for applications like ping that don't
check for this. So add pmtu handling to vti6_xmit to
report MTU changes immediately.

	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ccd740cbc6e01b2a08baa341867063ed2887f4b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_vti.c
diff --cc net/ipv6/ip6_vti.c
index 28ec2c553191,0224c032dca5..000000000000
--- a/net/ipv6/ip6_vti.c
+++ b/net/ipv6/ip6_vti.c
@@@ -398,19 -432,11 +398,20 @@@ static int vti6_xmit(struct sk_buff *sk
  	struct ip6_tnl *t = netdev_priv(dev);
  	struct net_device_stats *stats = &t->dev->stats;
  	struct dst_entry *dst = skb_dst(skb);
 +	struct flowi fl;
 +	struct ipv6hdr *ipv6h = ipv6_hdr(skb);
  	struct net_device *tdev;
 -	struct xfrm_state *x;
  	int err = -1;
+ 	int mtu;
  
 +	if ((t->parms.proto != IPPROTO_IPV6 && t->parms.proto != 0) ||
 +	    !ip6_tnl_xmit_ctl(t) || vti6_addr_conflict(t, ipv6h))
 +		return err;
 +
 +	memset(&fl, 0, sizeof(fl));
 +	skb->mark = be32_to_cpu(t->parms.o_key);
 +	xfrm_decode_session(skb, &fl, AF_INET6);
 +
  	if (!dst)
  		goto tx_err_link_failure;
  
@@@ -440,7 -469,31 +441,35 @@@
  	skb_dst_set(skb, dst);
  	skb->dev = skb_dst(skb)->dev;
  
++<<<<<<< HEAD
 +	ip6tunnel_xmit(skb, dev);
++=======
+ 	mtu = dst_mtu(dst);
+ 	if (!skb->ignore_df && skb->len > mtu) {
+ 		skb_dst(skb)->ops->update_pmtu(dst, NULL, skb, mtu);
+ 
+ 		if (skb->protocol == htons(ETH_P_IPV6))
+ 			icmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);
+ 		else
+ 			icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
+ 				  htonl(mtu));
+ 
+ 		return -EMSGSIZE;
+ 	}
+ 
+ 	err = dst_output(skb);
+ 	if (net_xmit_eval(err) == 0) {
+ 		struct pcpu_sw_netstats *tstats = this_cpu_ptr(dev->tstats);
+ 
+ 		u64_stats_update_begin(&tstats->syncp);
+ 		tstats->tx_bytes += skb->len;
+ 		tstats->tx_packets++;
+ 		u64_stats_update_end(&tstats->syncp);
+ 	} else {
+ 		stats->tx_errors++;
+ 		stats->tx_aborted_errors++;
+ 	}
++>>>>>>> ccd740cbc6e0 (vti6: Add pmtu handling to vti6_xmit.)
  
  	return 0;
  tx_err_link_failure:
* Unmerged path net/ipv6/ip6_vti.c
