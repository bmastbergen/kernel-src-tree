cxgb4 : Integrate DCBx support into cxgb4 module. Register dbcnl_ops to give access to DCBx functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] cxgb4: Integrate DCBx support into cxgb4 module. Register dbcnl_ops to give access to DCBx functions (Sai Vemuri) [1251611]
Rebuild_FUZZ: 99.50%
commit-author Anish Bhatt <anish@chelsio.com>
commit 688848b1493a0a55059041dcc1ea332dabd1c75d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/688848b1.failed

	Signed-off-by: Anish Bhatt <anish@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 688848b1493a0a55059041dcc1ea332dabd1c75d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 9df6656ca8da,74b0ce50a8ef..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@@ -6218,34 -6158,38 +6395,47 @@@ static int enable_msix(struct adapter *
  		/* need nchan for each possible ULD */
  		ofld_need = 3 * nchan;
  	}
+ #ifdef CONFIG_CHELSIO_T4_DCB
+ 	/* For Data Center Bridging we need 8 Ethernet TX Priority Queues for
+ 	 * each port.
+ 	 */
+ 	need = 8 * adap->params.nports + EXTRA_VECS + ofld_need;
+ #else
  	need = adap->params.nports + EXTRA_VECS + ofld_need;
++<<<<<<< HEAD
 +
 +	while ((err = pci_enable_msix(adap->pdev, entries, want)) >= need)
 +		want = err;
++=======
+ #endif
+ 	want = pci_enable_msix_range(adap->pdev, entries, need, want);
+ 	if (want < 0)
+ 		return want;
++>>>>>>> 688848b1493a (cxgb4 : Integrate DCBx support into cxgb4 module. Register dbcnl_ops to give access to DCBx functions)
  
 -	/*
 -	 * Distribute available vectors to the various queue groups.
 -	 * Every group gets its minimum requirement and NIC gets top
 -	 * priority for leftovers.
 -	 */
 -	i = want - EXTRA_VECS - ofld_need;
 -	if (i < s->max_ethqsets) {
 -		s->max_ethqsets = i;
 -		if (i < s->ethqsets)
 -			reduce_ethqs(adap, i);
 -	}
 -	if (is_offload(adap)) {
 -		i = want - EXTRA_VECS - s->max_ethqsets;
 -		i -= ofld_need - nchan;
 -		s->ofldqsets = (i / nchan) * nchan;  /* round down */
 -	}
 -	for (i = 0; i < want; ++i)
 -		adap->msix_info[i].vec = entries[i].vector;
 -
 -	return 0;
 +	if (!err) {
 +		/*
 +		 * Distribute available vectors to the various queue groups.
 +		 * Every group gets its minimum requirement and NIC gets top
 +		 * priority for leftovers.
 +		 */
 +		i = want - EXTRA_VECS - ofld_need;
 +		if (i < s->max_ethqsets) {
 +			s->max_ethqsets = i;
 +			if (i < s->ethqsets)
 +				reduce_ethqs(adap, i);
 +		}
 +		if (is_offload(adap)) {
 +			i = want - EXTRA_VECS - s->max_ethqsets;
 +			i -= ofld_need - nchan;
 +			s->ofldqsets = (i / nchan) * nchan;  /* round down */
 +		}
 +		for (i = 0; i < want; ++i)
 +			adap->msix_info[i].vec = entries[i].vector;
 +	} else if (err > 0)
 +		dev_info(adap->pdev_dev,
 +			 "only %d MSI-X vectors left, not using MSI-X\n", err);
 +	return err;
  }
  
  #undef EXTRA_VECS
@@@ -6499,7 -6428,11 +6689,15 @@@ static int init_one(struct pci_dev *pde
  		netdev->priv_flags |= IFF_UNICAST_FLT;
  
  		netdev->netdev_ops = &cxgb4_netdev_ops;
++<<<<<<< HEAD
 +		SET_ETHTOOL_OPS(netdev, &cxgb_ethtool_ops);
++=======
+ #ifdef CONFIG_CHELSIO_T4_DCB
+ 		netdev->dcbnl_ops = &cxgb4_dcb_ops;
+ 		cxgb4_dcb_state_init(netdev);
+ #endif
+ 		netdev->ethtool_ops = &cxgb_ethtool_ops;
++>>>>>>> 688848b1493a (cxgb4 : Integrate DCBx support into cxgb4 module. Register dbcnl_ops to give access to DCBx functions)
  	}
  
  	pci_set_drvdata(pdev, adapter);
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index 6d750bf56d7a..62f4051cec21 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@ -377,6 +377,8 @@ enum {
 struct adapter;
 struct sge_rspq;
 
+#include "cxgb4_dcb.h"
+
 struct port_info {
 	struct adapter *adapter;
 	u16    viid;
@@ -393,6 +395,9 @@ struct port_info {
 	u8     rss_mode;
 	struct link_config link_cfg;
 	u16   *rss;
+#ifdef CONFIG_CHELSIO_T4_DCB
+	struct port_dcb_info dcb;     /* Data Center Bridging support */
+#endif
 };
 
 struct dentry;
@@ -1030,6 +1035,10 @@ int t4_query_params(struct adapter *adap, unsigned int mbox, unsigned int pf,
 int t4_set_params(struct adapter *adap, unsigned int mbox, unsigned int pf,
 		  unsigned int vf, unsigned int nparams, const u32 *params,
 		  const u32 *val);
+int t4_set_params_nosleep(struct adapter *adap, unsigned int mbox,
+			  unsigned int pf, unsigned int vf,
+			  unsigned int nparams, const u32 *params,
+			  const u32 *val);
 int t4_cfg_pfvf(struct adapter *adap, unsigned int mbox, unsigned int pf,
 		unsigned int vf, unsigned int txq, unsigned int txq_eth_ctrl,
 		unsigned int rxqi, unsigned int rxq, unsigned int tc,
@@ -1048,6 +1057,8 @@ int t4_change_mac(struct adapter *adap, unsigned int mbox, unsigned int viid,
 		  int idx, const u8 *addr, bool persist, bool add_smt);
 int t4_set_addr_hash(struct adapter *adap, unsigned int mbox, unsigned int viid,
 		     bool ucast, u64 vec, bool sleep_ok);
+int t4_enable_vi_params(struct adapter *adap, unsigned int mbox,
+			unsigned int viid, bool rx_en, bool tx_en, bool dcb_en);
 int t4_enable_vi(struct adapter *adap, unsigned int mbox, unsigned int viid,
 		 bool rx_en, bool tx_en);
 int t4_identify_port(struct adapter *adap, unsigned int mbox, unsigned int viid,
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index 3af8bc8aff35..7d1411cafcd0 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@ -3265,6 +3265,46 @@ int t4_query_params(struct adapter *adap, unsigned int mbox, unsigned int pf,
 	return ret;
 }
 
+/**
+ *      t4_set_params_nosleep - sets FW or device parameters
+ *      @adap: the adapter
+ *      @mbox: mailbox to use for the FW command
+ *      @pf: the PF
+ *      @vf: the VF
+ *      @nparams: the number of parameters
+ *      @params: the parameter names
+ *      @val: the parameter values
+ *
+ *	 Does not ever sleep
+ *      Sets the value of FW or device parameters.  Up to 7 parameters can be
+ *      specified at once.
+ */
+int t4_set_params_nosleep(struct adapter *adap, unsigned int mbox,
+			  unsigned int pf, unsigned int vf,
+			  unsigned int nparams, const u32 *params,
+			  const u32 *val)
+{
+	struct fw_params_cmd c;
+	__be32 *p = &c.param[0].mnem;
+
+	if (nparams > 7)
+		return -EINVAL;
+
+	memset(&c, 0, sizeof(c));
+	c.op_to_vfn = cpu_to_be32(FW_CMD_OP(FW_PARAMS_CMD) |
+				FW_CMD_REQUEST | FW_CMD_WRITE |
+				FW_PARAMS_CMD_PFN(pf) |
+				FW_PARAMS_CMD_VFN(vf));
+	c.retval_len16 = cpu_to_be32(FW_LEN16(c));
+
+	while (nparams--) {
+		*p++ = cpu_to_be32(*params++);
+		*p++ = cpu_to_be32(*val++);
+	}
+
+	return t4_wr_mbox_ns(adap, mbox, &c, sizeof(c), NULL);
+}
+
 /**
  *	t4_set_params - sets FW or device parameters
  *	@adap: the adapter
@@ -3589,6 +3629,33 @@ int t4_set_addr_hash(struct adapter *adap, unsigned int mbox, unsigned int viid,
 	return t4_wr_mbox_meat(adap, mbox, &c, sizeof(c), NULL, sleep_ok);
 }
 
+/**
+ *      t4_enable_vi_params - enable/disable a virtual interface
+ *      @adap: the adapter
+ *      @mbox: mailbox to use for the FW command
+ *      @viid: the VI id
+ *      @rx_en: 1=enable Rx, 0=disable Rx
+ *      @tx_en: 1=enable Tx, 0=disable Tx
+ *      @dcb_en: 1=enable delivery of Data Center Bridging messages.
+ *
+ *      Enables/disables a virtual interface.  Note that setting DCB Enable
+ *      only makes sense when enabling a Virtual Interface ...
+ */
+int t4_enable_vi_params(struct adapter *adap, unsigned int mbox,
+			unsigned int viid, bool rx_en, bool tx_en, bool dcb_en)
+{
+	struct fw_vi_enable_cmd c;
+
+	memset(&c, 0, sizeof(c));
+	c.op_to_viid = htonl(FW_CMD_OP(FW_VI_ENABLE_CMD) | FW_CMD_REQUEST |
+			     FW_CMD_EXEC | FW_VI_ENABLE_CMD_VIID(viid));
+
+	c.ien_to_len16 = htonl(FW_VI_ENABLE_CMD_IEN(rx_en) |
+			       FW_VI_ENABLE_CMD_EEN(tx_en) | FW_LEN16(c) |
+			       FW_VI_ENABLE_CMD_DCB_INFO(dcb_en));
+	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
+}
+
 /**
  *	t4_enable_vi - enable/disable a virtual interface
  *	@adap: the adapter
@@ -3602,14 +3669,7 @@ int t4_set_addr_hash(struct adapter *adap, unsigned int mbox, unsigned int viid,
 int t4_enable_vi(struct adapter *adap, unsigned int mbox, unsigned int viid,
 		 bool rx_en, bool tx_en)
 {
-	struct fw_vi_enable_cmd c;
-
-	memset(&c, 0, sizeof(c));
-	c.op_to_viid = htonl(FW_CMD_OP(FW_VI_ENABLE_CMD) | FW_CMD_REQUEST |
-			     FW_CMD_EXEC | FW_VI_ENABLE_CMD_VIID(viid));
-	c.ien_to_len16 = htonl(FW_VI_ENABLE_CMD_IEN(rx_en) |
-			       FW_VI_ENABLE_CMD_EEN(tx_en) | FW_LEN16(c));
-	return t4_wr_mbox(adap, mbox, &c, sizeof(c), NULL);
+	return t4_enable_vi_params(adap, mbox, viid, rx_en, tx_en, 0);
 }
 
 /**
