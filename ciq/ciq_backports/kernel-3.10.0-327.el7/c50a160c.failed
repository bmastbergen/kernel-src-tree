s390/zcrypt: Fixed reset and interrupt handling of AP queues

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [s390] zcrypt: Fixed reset and interrupt handling of AP queues (Hendrik Brueckner) [1238230]
Rebuild_FUZZ: 95.65%
commit-author Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
commit c50a160c176aadfbbbeed69a55caf1040b22692e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c50a160c.failed

In case of request timeouts an AP queue reset will be triggered to
recover and reinitialize the AP queue. The previous behavior was an
immediate reset execution regardless of current/pending requests.
Due to newly changed firmware behavior the reset may be delayed, based
on the priority of pending request. The device driver's waiting time
frame was limited, hence it did not received the reset response. As a
consequence interrupts would not be enabled afterwards.

The RAPQ (queue reset) and AQIC (interrupt control) commands will be
treated fully asynchronous now. The device driver will check the reset and
interrupt states periodically, thus it can handle the reinitialization
properly.

	Signed-off-by: Ingo Tuchscherer <ingo.tuchscherer@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit c50a160c176aadfbbbeed69a55caf1040b22692e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/ap_bus.c
diff --cc drivers/s390/crypto/ap_bus.c
index c18e0eb185de,559a9dcdb15d..000000000000
--- a/drivers/s390/crypto/ap_bus.c
+++ b/drivers/s390/crypto/ap_bus.c
@@@ -316,40 -309,27 +316,35 @@@ static inline int __ap_query_configurat
   */
  static int ap_query_functions(ap_qid_t qid, unsigned int *functions)
  {
 +#ifdef CONFIG_64BIT
  	struct ap_queue_status status;
- 	int i;
+ 
  	status = __ap_query_functions(qid, functions);
  
- 	for (i = 0; i < AP_MAX_RESET; i++) {
- 		if (ap_queue_status_invalid_test(&status))
- 			return -ENODEV;
+ 	if (ap_queue_status_invalid_test(&status))
+ 		return -ENODEV;
  
- 		switch (status.response_code) {
- 		case AP_RESPONSE_NORMAL:
- 			return 0;
- 		case AP_RESPONSE_RESET_IN_PROGRESS:
- 		case AP_RESPONSE_BUSY:
- 			break;
- 		case AP_RESPONSE_Q_NOT_AVAIL:
- 		case AP_RESPONSE_DECONFIGURED:
- 		case AP_RESPONSE_CHECKSTOPPED:
- 		case AP_RESPONSE_INVALID_ADDRESS:
- 			return -ENODEV;
- 		case AP_RESPONSE_OTHERWISE_CHANGED:
- 			break;
- 		default:
- 			break;
- 		}
- 		if (i < AP_MAX_RESET - 1) {
- 			udelay(5);
- 			status = __ap_query_functions(qid, functions);
- 		}
+ 	switch (status.response_code) {
+ 	case AP_RESPONSE_NORMAL:
+ 		return 0;
+ 	case AP_RESPONSE_Q_NOT_AVAIL:
+ 	case AP_RESPONSE_DECONFIGURED:
+ 	case AP_RESPONSE_CHECKSTOPPED:
+ 	case AP_RESPONSE_INVALID_ADDRESS:
+ 		return -ENODEV;
+ 	case AP_RESPONSE_RESET_IN_PROGRESS:
+ 	case AP_RESPONSE_BUSY:
+ 	case AP_RESPONSE_OTHERWISE_CHANGED:
+ 	default:
+ 		return -EBUSY;
  	}
++<<<<<<< HEAD
 +	return -EBUSY;
 +#else
 +	return -EINVAL;
 +#endif
++=======
++>>>>>>> c50a160c176a (s390/zcrypt: Fixed reset and interrupt handling of AP queues)
  }
  
  /**
@@@ -361,51 -341,25 +356,33 @@@
   * on the return value it waits a while and tests the AP queue if interrupts
   * have been switched on using ap_test_queue().
   */
- static int ap_queue_enable_interruption(ap_qid_t qid, void *ind)
+ static int ap_queue_enable_interruption(struct ap_device *ap_dev, void *ind)
  {
 +#ifdef CONFIG_64BIT
  	struct ap_queue_status status;
- 	int t_depth, t_device_type, rc, i;
  
- 	rc = -EBUSY;
- 	status = ap_queue_interruption_control(qid, ind);
- 
- 	for (i = 0; i < AP_MAX_RESET; i++) {
- 		switch (status.response_code) {
- 		case AP_RESPONSE_NORMAL:
- 			if (status.int_enabled)
- 				return 0;
- 			break;
- 		case AP_RESPONSE_RESET_IN_PROGRESS:
- 		case AP_RESPONSE_BUSY:
- 			if (i < AP_MAX_RESET - 1) {
- 				udelay(5);
- 				status = ap_queue_interruption_control(qid,
- 								       ind);
- 				continue;
- 			}
- 			break;
- 		case AP_RESPONSE_Q_NOT_AVAIL:
- 		case AP_RESPONSE_DECONFIGURED:
- 		case AP_RESPONSE_CHECKSTOPPED:
- 		case AP_RESPONSE_INVALID_ADDRESS:
- 			return -ENODEV;
- 		case AP_RESPONSE_OTHERWISE_CHANGED:
- 			if (status.int_enabled)
- 				return 0;
- 			break;
- 		default:
- 			break;
- 		}
- 		if (i < AP_MAX_RESET - 1) {
- 			udelay(5);
- 			status = ap_test_queue(qid, &t_depth, &t_device_type);
- 		}
+ 	status = ap_queue_interruption_control(ap_dev->qid, ind);
+ 	switch (status.response_code) {
+ 	case AP_RESPONSE_NORMAL:
+ 	case AP_RESPONSE_OTHERWISE_CHANGED:
+ 		return 0;
+ 	case AP_RESPONSE_Q_NOT_AVAIL:
+ 	case AP_RESPONSE_DECONFIGURED:
+ 	case AP_RESPONSE_CHECKSTOPPED:
+ 	case AP_RESPONSE_INVALID_ADDRESS:
+ 		return -ENODEV;
+ 	case AP_RESPONSE_RESET_IN_PROGRESS:
+ 	case AP_RESPONSE_BUSY:
+ 	default:
+ 		return -EBUSY;
  	}
++<<<<<<< HEAD
 +	return rc;
 +#else
 +	return -EINVAL;
 +#endif
++=======
++>>>>>>> c50a160c176a (s390/zcrypt: Fixed reset and interrupt handling of AP queues)
  }
  
  /**
@@@ -1538,39 -1529,6 +1555,42 @@@ ap_config_timeout(unsigned long ptr
  }
  
  /**
++<<<<<<< HEAD
 + * __ap_schedule_poll_timer(): Schedule poll timer.
 + *
 + * Set up the timer to run the poll tasklet
 + */
 +static inline void __ap_schedule_poll_timer(void)
 +{
 +	ktime_t hr_time;
 +
 +	spin_lock_bh(&ap_poll_timer_lock);
 +	if (hrtimer_is_queued(&ap_poll_timer) || ap_suspend_flag)
 +		goto out;
 +	if (ktime_to_ns(hrtimer_expires_remaining(&ap_poll_timer)) <= 0) {
 +		hr_time = ktime_set(0, poll_timeout);
 +		hrtimer_forward_now(&ap_poll_timer, hr_time);
 +		hrtimer_restart(&ap_poll_timer);
 +	}
 +out:
 +	spin_unlock_bh(&ap_poll_timer_lock);
 +}
 +
 +/**
 + * ap_schedule_poll_timer(): Schedule poll timer.
 + *
 + * Set up the timer to run the poll tasklet
 + */
 +static inline void ap_schedule_poll_timer(void)
 +{
 +	if (ap_using_interrupts())
 +		return;
 +	__ap_schedule_poll_timer();
 +}
 +
 +/**
++=======
++>>>>>>> c50a160c176a (s390/zcrypt: Fixed reset and interrupt handling of AP queues)
   * ap_poll_read(): Receive pending reply messages from an AP device.
   * @ap_dev: pointer to the AP device
   * @flags: pointer to control flags, bit 2^0 is set if another poll is
* Unmerged path drivers/s390/crypto/ap_bus.c
diff --git a/drivers/s390/crypto/ap_bus.h b/drivers/s390/crypto/ap_bus.h
index 2737d261a324..00468c8d0781 100644
--- a/drivers/s390/crypto/ap_bus.h
+++ b/drivers/s390/crypto/ap_bus.h
@@ -32,11 +32,13 @@
 
 #define AP_DEVICES 64		/* Number of AP devices. */
 #define AP_DOMAINS 256		/* Number of AP domains. */
-#define AP_MAX_RESET 90		/* Maximum number of resets. */
 #define AP_RESET_TIMEOUT (HZ*0.7)	/* Time in ticks for reset timeouts. */
 #define AP_CONFIG_TIME 30	/* Time in seconds between AP bus rescans. */
 #define AP_POLL_TIME 1		/* Time in ticks between receive polls. */
 
+#define AP_POLL_IMMEDIATELY	1 /* continue running poll tasklet */
+#define AP_POLL_AFTER_TIMEOUT	2 /* run poll tasklet again after timout */
+
 extern int ap_domain_index;
 
 /**
@@ -135,6 +137,14 @@ static inline int ap_test_bit(unsigned int *ptr, unsigned int nr)
 #define AP_RESET_IGNORE	0	/* request timeout will be ignored */
 #define AP_RESET_ARMED	1	/* request timeout timer is active */
 #define AP_RESET_DO	2	/* AP reset required */
+#define AP_RESET_IN_PROGRESS	3	/* AP reset in progress */
+
+/*
+ * AP interrupt states
+ */
+#define AP_INTR_DISABLED	0	/* AP interrupt disabled */
+#define AP_INTR_ENABLED		1	/* AP interrupt enabled */
+#define AP_INTR_IN_PROGRESS	3	/* AP interrupt in progress */
 
 struct ap_device;
 struct ap_message;
@@ -168,6 +178,7 @@ struct ap_device {
 	struct timer_list timeout;	/* Timer for request timeouts. */
 	int reset;			/* Reset required after req. timeout. */
 
+	int interrupt;			/* indicate if interrupts are enabled */
 	int queue_count;		/* # messages currently on AP queue. */
 
 	struct list_head pendingq;	/* List of message sent to AP queue. */
diff --git a/drivers/s390/crypto/zcrypt_cex4.c b/drivers/s390/crypto/zcrypt_cex4.c
index 71e698b85772..bb3908818505 100644
--- a/drivers/s390/crypto/zcrypt_cex4.c
+++ b/drivers/s390/crypto/zcrypt_cex4.c
@@ -39,7 +39,7 @@
  * But the maximum time limit managed by the stomper code is set to 60sec.
  * Hence we have to wait at least that time period.
  */
-#define CEX4_CLEANUP_TIME	(61*HZ)
+#define CEX4_CLEANUP_TIME	(900*HZ)
 
 static struct ap_device_id zcrypt_cex4_ids[] = {
 	{ AP_DEVICE(AP_DEVICE_TYPE_CEX4)  },
