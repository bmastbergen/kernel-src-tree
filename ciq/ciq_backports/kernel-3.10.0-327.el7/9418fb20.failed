rcu: Do not trace rcu_is_watching() functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Steven Rostedt <rostedt@goodmis.org>
commit 9418fb208059d6f916bdb116653e166c5db9456d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9418fb20.failed

As perf uses the rcu_read_lock() primitives for recording into its
ring buffer, perf tracing can not be called when RCU in inactive.
With the perf function tracing, there are functions that can be
traced when RCU is not active, and perf must not have its function
callback called when this is the case.

Luckily, Paul McKenney has created a way to detect when RCU is
active or not with the rcu_is_watching() function. Unfortunately,
this function can also be traced, and if that happens it can cause
a bit of overhead for the perf function calls that do the check.
Recursion protection prevents anything bad from happening, but
there is a bit of added overhead for every function being traced that
must detect that the rcu_is_watching() is also being traced.

As rcu_is_watching() is a helper routine and not part of the
critical logic in RCU, it does not need to be traced in order to
debug RCU itself. Add the "notrace" annotation to all the rcu_is_watching()
calls such that we never trace it.

Link: http://lkml.kernel.org/r/20131104202736.72dd8e45@gandalf.local.home

	Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Signed-off-by: Steven Rostedt <rostedt@goodmis.org>
(cherry picked from commit 9418fb208059d6f916bdb116653e166c5db9456d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/rcutiny.c
#	kernel/rcutree.c
diff --cc kernel/rcutiny.c
index a7bead918405,590c8a82aa00..000000000000
--- a/kernel/rcutiny.c
+++ b/kernel/rcutiny.c
@@@ -180,11 -179,11 +180,15 @@@ EXPORT_SYMBOL_GPL(rcu_irq_enter)
  /*
   * Test whether RCU thinks that the current CPU is idle.
   */
++<<<<<<< HEAD
 +int rcu_is_cpu_idle(void)
++=======
+ bool notrace __rcu_is_watching(void)
++>>>>>>> 9418fb208059 (rcu: Do not trace rcu_is_watching() functions)
  {
 -	return rcu_dynticks_nesting;
 +	return !rcu_dynticks_nesting;
  }
 -EXPORT_SYMBOL(__rcu_is_watching);
 +EXPORT_SYMBOL(rcu_is_cpu_idle);
  
  #endif /* defined(CONFIG_DEBUG_LOCK_ALLOC) || defined(CONFIG_RCU_TRACE) */
  
diff --cc kernel/rcutree.c
index 5a215b166d26,499bb2b2198c..000000000000
--- a/kernel/rcutree.c
+++ b/kernel/rcutree.c
@@@ -670,12 -655,25 +670,33 @@@ void rcu_nmi_exit(void
  }
  
  /**
++<<<<<<< HEAD
 + * rcu_is_cpu_idle - see if RCU thinks that the current CPU is idle
++=======
+  * __rcu_is_watching - are RCU read-side critical sections safe?
+  *
+  * Return true if RCU is watching the running CPU, which means that
+  * this CPU can safely enter RCU read-side critical sections.  Unlike
+  * rcu_is_watching(), the caller of __rcu_is_watching() must have at
+  * least disabled preemption.
+  */
+ bool notrace __rcu_is_watching(void)
+ {
+ 	return atomic_read(this_cpu_ptr(&rcu_dynticks.dynticks)) & 0x1;
+ }
+ 
+ /**
+  * rcu_is_watching - see if RCU thinks that the current CPU is idle
++>>>>>>> 9418fb208059 (rcu: Do not trace rcu_is_watching() functions)
   *
   * If the current CPU is in its idle loop and is neither in an interrupt
   * or NMI handler, return true.
   */
++<<<<<<< HEAD
 +int rcu_is_cpu_idle(void)
++=======
+ bool notrace rcu_is_watching(void)
++>>>>>>> 9418fb208059 (rcu: Do not trace rcu_is_watching() functions)
  {
  	int ret;
  
* Unmerged path kernel/rcutiny.c
* Unmerged path kernel/rcutree.c
