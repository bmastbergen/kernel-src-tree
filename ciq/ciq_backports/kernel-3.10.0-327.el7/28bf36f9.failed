powerpc/eeh: Set EEH_PE_RESET on PE reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] eeh: Set EEH_PE_RESET on PE reset (Laurent Vivier) [1213675]
Rebuild_FUZZ: 89.19%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit 28bf36f92afc6b22ba50ceaf36ba89afa9f5c1e8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/28bf36f9.failed

The patch introduces additional flag EEH_PE_RESET to indicate the
corresponding PE is under reset. In turn, the PE retrieval bakcend
on PowerNV platform can return unfrozen state for the EEH core to
moving forward. Flag EEH_PE_CFG_BLOCKED isn't the correct one for
the purpose.

In PCI passthrou case, the problem is more worse: Guest doesn't
recover 6th EEH error. The PE is left in isolated (frozen) and
config blocked state on Broadcom adapters. We can't retrieve the
PE's state correctly any more, even from the host side via sysfs
/sys/bus/pci/devices/xxx/eeh_pe_state.

	Reported-by: Rajeshkumar Subramanian <rajeshkumars@in.ibm.com>
	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 28bf36f92afc6b22ba50ceaf36ba89afa9f5c1e8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/eeh.h
#	arch/powerpc/kernel/eeh_driver.c
#	arch/powerpc/platforms/powernv/eeh-ioda.c
diff --cc arch/powerpc/include/asm/eeh.h
index 52bd2259c082,2e633b41712a..000000000000
--- a/arch/powerpc/include/asm/eeh.h
+++ b/arch/powerpc/include/asm/eeh.h
@@@ -72,9 -71,11 +72,14 @@@ struct device_node
  
  #define EEH_PE_ISOLATED		(1 << 0)	/* Isolated PE		*/
  #define EEH_PE_RECOVERING	(1 << 1)	/* Recovering PE	*/
++<<<<<<< HEAD
 +#define EEH_PE_RESET		(1 << 2)	/* PE reset in progress	*/
++=======
+ #define EEH_PE_CFG_BLOCKED	(1 << 2)	/* Block config access	*/
+ #define EEH_PE_RESET		(1 << 3)	/* PE reset in progress */
++>>>>>>> 28bf36f92afc (powerpc/eeh: Set EEH_PE_RESET on PE reset)
  
  #define EEH_PE_KEEP		(1 << 8)	/* Keep PE on hotplug	*/
 -#define EEH_PE_CFG_RESTRICTED	(1 << 9)	/* Block config on error */
  
  struct eeh_pe {
  	int type;			/* PE type: PHB/Bus/Device	*/
diff --cc arch/powerpc/kernel/eeh_driver.c
index 420da61d4ce0,b17e793ba67e..000000000000
--- a/arch/powerpc/kernel/eeh_driver.c
+++ b/arch/powerpc/kernel/eeh_driver.c
@@@ -482,6 -510,52 +482,55 @@@ static int eeh_clear_pe_frozen_state(st
  	return rc ? -EIO : 0;
  }
  
++<<<<<<< HEAD
++=======
+ int eeh_pe_reset_and_recover(struct eeh_pe *pe)
+ {
+ 	int result, ret;
+ 
+ 	/* Bail if the PE is being recovered */
+ 	if (pe->state & EEH_PE_RECOVERING)
+ 		return 0;
+ 
+ 	/* Put the PE into recovery mode */
+ 	eeh_pe_state_mark(pe, EEH_PE_RECOVERING);
+ 
+ 	/* Save states */
+ 	eeh_pe_dev_traverse(pe, eeh_dev_save_state, NULL);
+ 
+ 	/* Report error */
+ 	eeh_pe_dev_traverse(pe, eeh_report_error, &result);
+ 
+ 	/* Issue reset */
+ 	ret = eeh_reset_pe(pe);
+ 	if (ret) {
+ 		eeh_pe_state_clear(pe, EEH_PE_RECOVERING);
+ 		return ret;
+ 	}
+ 
+ 	/* Unfreeze the PE */
+ 	ret = eeh_clear_pe_frozen_state(pe, true);
+ 	if (ret) {
+ 		eeh_pe_state_clear(pe, EEH_PE_RECOVERING);
+ 		return ret;
+ 	}
+ 
+ 	/* Notify completion of reset */
+ 	eeh_pe_dev_traverse(pe, eeh_report_reset, &result);
+ 
+ 	/* Restore device state */
+ 	eeh_pe_dev_traverse(pe, eeh_dev_restore_state, NULL);
+ 
+ 	/* Resume */
+ 	eeh_pe_dev_traverse(pe, eeh_report_resume, NULL);
+ 
+ 	/* Clear recovery mode */
+ 	eeh_pe_state_clear(pe, EEH_PE_RECOVERING);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 28bf36f92afc (powerpc/eeh: Set EEH_PE_RESET on PE reset)
  /**
   * eeh_reset_device - Perform actual reset of a pci slot
   * @pe: EEH PE
@@@ -525,22 -599,18 +574,29 @@@ static int eeh_reset_device(struct eeh_
  	 * config accesses. So we prefer to block them. However, controlled
  	 * PCI config accesses initiated from EEH itself are allowed.
  	 */
++<<<<<<< HEAD
 +	eeh_pe_state_mark(pe, EEH_PE_RESET);
 +	rc = eeh_reset_pe(pe);
 +	if (rc) {
 +		eeh_pe_state_clear(pe, EEH_PE_RESET);
++=======
+ 	rc = eeh_reset_pe(pe);
+ 	if (rc)
++>>>>>>> 28bf36f92afc (powerpc/eeh: Set EEH_PE_RESET on PE reset)
  		return rc;
- 	}
  
  	pci_lock_rescan_remove();
  
  	/* Restore PE */
  	eeh_ops->configure_bridge(pe);
  	eeh_pe_restore_bars(pe);
++<<<<<<< HEAD
 +	eeh_pe_state_clear(pe, EEH_PE_RESET);
++=======
++>>>>>>> 28bf36f92afc (powerpc/eeh: Set EEH_PE_RESET on PE reset)
  
  	/* Clear frozen state */
 -	rc = eeh_clear_pe_frozen_state(pe, false);
 +	rc = eeh_clear_pe_frozen_state(pe);
  	if (rc)
  		return rc;
  
diff --cc arch/powerpc/platforms/powernv/eeh-ioda.c
index 47d55b12a81e,fb38fe4dba89..000000000000
--- a/arch/powerpc/platforms/powernv/eeh-ioda.c
+++ b/arch/powerpc/platforms/powernv/eeh-ioda.c
@@@ -291,20 -277,183 +291,136 @@@ static int ioda_eeh_set_option(struct e
  	return ret;
  }
  
 -static void ioda_eeh_phb_diag(struct eeh_pe *pe)
 +static void ioda_eeh_phb_diag(struct pci_controller *hose)
  {
 -	struct pnv_phb *phb = pe->phb->private_data;
 +	struct pnv_phb *phb = hose->private_data;
  	long rc;
  
 -	rc = opal_pci_get_phb_diag_data2(phb->opal_id, pe->data,
 +	rc = opal_pci_get_phb_diag_data2(phb->opal_id, phb->diag.blob,
  					 PNV_PCI_DIAG_BUF_SIZE);
 -	if (rc != OPAL_SUCCESS)
 -		pr_warn("%s: Failed to get diag-data for PHB#%x (%ld)\n",
 -			__func__, pe->phb->global_number, rc);
 -}
 -
 -static int ioda_eeh_get_phb_state(struct eeh_pe *pe)
 -{
 -	struct pnv_phb *phb = pe->phb->private_data;
 -	u8 fstate;
 -	__be16 pcierr;
 -	s64 rc;
 -	int result = 0;
 -
 -	rc = opal_pci_eeh_freeze_status(phb->opal_id,
 -					pe->addr,
 -					&fstate,
 -					&pcierr,
 -					NULL);
  	if (rc != OPAL_SUCCESS) {
 -		pr_warn("%s: Failure %lld getting PHB#%x state\n",
 -			__func__, rc, phb->hose->global_number);
 -		return EEH_STATE_NOT_SUPPORT;
 +		pr_warning("%s: Failed to get diag-data for PHB#%x (%ld)\n",
 +			    __func__, hose->global_number, rc);
 +		return;
  	}
  
++<<<<<<< HEAD
 +	pnv_pci_dump_phb_diag_data(hose, phb->diag.blob);
++=======
+ 	/*
+ 	 * Check PHB state. If the PHB is frozen for the
+ 	 * first time, to dump the PHB diag-data.
+ 	 */
+ 	if (be16_to_cpu(pcierr) != OPAL_EEH_PHB_ERROR) {
+ 		result = (EEH_STATE_MMIO_ACTIVE  |
+ 			  EEH_STATE_DMA_ACTIVE   |
+ 			  EEH_STATE_MMIO_ENABLED |
+ 			  EEH_STATE_DMA_ENABLED);
+ 	} else if (!(pe->state & EEH_PE_ISOLATED)) {
+ 		eeh_pe_state_mark(pe, EEH_PE_ISOLATED);
+ 		ioda_eeh_phb_diag(pe);
+ 	}
+ 
+ 	return result;
+ }
+ 
+ static int ioda_eeh_get_pe_state(struct eeh_pe *pe)
+ {
+ 	struct pnv_phb *phb = pe->phb->private_data;
+ 	u8 fstate;
+ 	__be16 pcierr;
+ 	s64 rc;
+ 	int result;
+ 
+ 	/*
+ 	 * We don't clobber hardware frozen state until PE
+ 	 * reset is completed. In order to keep EEH core
+ 	 * moving forward, we have to return operational
+ 	 * state during PE reset.
+ 	 */
+ 	if (pe->state & EEH_PE_RESET) {
+ 		result = (EEH_STATE_MMIO_ACTIVE  |
+ 			  EEH_STATE_DMA_ACTIVE   |
+ 			  EEH_STATE_MMIO_ENABLED |
+ 			  EEH_STATE_DMA_ENABLED);
+ 		return result;
+ 	}
+ 
+ 	/*
+ 	 * Fetch PE state from hardware. If the PHB
+ 	 * supports compound PE, let it handle that.
+ 	 */
+ 	if (phb->get_pe_state) {
+ 		fstate = phb->get_pe_state(phb, pe->addr);
+ 	} else {
+ 		rc = opal_pci_eeh_freeze_status(phb->opal_id,
+ 						pe->addr,
+ 						&fstate,
+ 						&pcierr,
+ 						NULL);
+ 		if (rc != OPAL_SUCCESS) {
+ 			pr_warn("%s: Failure %lld getting PHB#%x-PE%x state\n",
+ 				__func__, rc, phb->hose->global_number, pe->addr);
+ 			return EEH_STATE_NOT_SUPPORT;
+ 		}
+ 	}
+ 
+ 	/* Figure out state */
+ 	switch (fstate) {
+ 	case OPAL_EEH_STOPPED_NOT_FROZEN:
+ 		result = (EEH_STATE_MMIO_ACTIVE  |
+ 			  EEH_STATE_DMA_ACTIVE   |
+ 			  EEH_STATE_MMIO_ENABLED |
+ 			  EEH_STATE_DMA_ENABLED);
+ 		break;
+ 	case OPAL_EEH_STOPPED_MMIO_FREEZE:
+ 		result = (EEH_STATE_DMA_ACTIVE |
+ 			  EEH_STATE_DMA_ENABLED);
+ 		break;
+ 	case OPAL_EEH_STOPPED_DMA_FREEZE:
+ 		result = (EEH_STATE_MMIO_ACTIVE |
+ 			  EEH_STATE_MMIO_ENABLED);
+ 		break;
+ 	case OPAL_EEH_STOPPED_MMIO_DMA_FREEZE:
+ 		result = 0;
+ 		break;
+ 	case OPAL_EEH_STOPPED_RESET:
+ 		result = EEH_STATE_RESET_ACTIVE;
+ 		break;
+ 	case OPAL_EEH_STOPPED_TEMP_UNAVAIL:
+ 		result = EEH_STATE_UNAVAILABLE;
+ 		break;
+ 	case OPAL_EEH_STOPPED_PERM_UNAVAIL:
+ 		result = EEH_STATE_NOT_SUPPORT;
+ 		break;
+ 	default:
+ 		result = EEH_STATE_NOT_SUPPORT;
+ 		pr_warn("%s: Invalid PHB#%x-PE#%x state %x\n",
+ 			__func__, phb->hose->global_number,
+ 			pe->addr, fstate);
+ 	}
+ 
+ 	/*
+ 	 * If PHB supports compound PE, to freeze all
+ 	 * slave PEs for consistency.
+ 	 *
+ 	 * If the PE is switching to frozen state for the
+ 	 * first time, to dump the PHB diag-data.
+ 	 */
+ 	if (!(result & EEH_STATE_NOT_SUPPORT) &&
+ 	    !(result & EEH_STATE_UNAVAILABLE) &&
+ 	    !(result & EEH_STATE_MMIO_ACTIVE) &&
+ 	    !(result & EEH_STATE_DMA_ACTIVE)  &&
+ 	    !(pe->state & EEH_PE_ISOLATED)) {
+ 		if (phb->freeze_pe)
+ 			phb->freeze_pe(phb, pe->addr);
+ 
+ 		eeh_pe_state_mark(pe, EEH_PE_ISOLATED);
+ 		ioda_eeh_phb_diag(pe);
+ 	}
+ 
+ 	return result;
++>>>>>>> 28bf36f92afc (powerpc/eeh: Set EEH_PE_RESET on PE reset)
  }
  
  /**
* Unmerged path arch/powerpc/include/asm/eeh.h
diff --git a/arch/powerpc/kernel/eeh.c b/arch/powerpc/kernel/eeh.c
index b7697ea6a6ff..c5a0a455d488 100644
--- a/arch/powerpc/kernel/eeh.c
+++ b/arch/powerpc/kernel/eeh.c
@@ -759,6 +759,9 @@ int eeh_reset_pe(struct eeh_pe *pe)
 	int flags = (EEH_STATE_MMIO_ACTIVE | EEH_STATE_DMA_ACTIVE);
 	int i, state, ret;
 
+	/* Mark as reset and block config space */
+	eeh_pe_state_mark(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);
+
 	/* Take three shots at resetting the bus */
 	for (i = 0; i < 3; i++) {
 		eeh_reset_pe_once(pe);
@@ -787,6 +790,7 @@ int eeh_reset_pe(struct eeh_pe *pe)
 	}
 
 out:
+	eeh_pe_state_clear(pe, EEH_PE_RESET | EEH_PE_CFG_BLOCKED);
 	return ret;
 }
 
* Unmerged path arch/powerpc/kernel/eeh_driver.c
* Unmerged path arch/powerpc/platforms/powernv/eeh-ioda.c
