ALSA: line6: Handle impulse response via control API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] line6: Handle impulse response via control API (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 93.88%
commit-author Takashi Iwai <tiwai@suse.de>
commit 075587b723ec5d90d1788b9cdba3034f524a64c9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/075587b7.failed

Instead of sysfs and the conditional build with Kconfig, implement the
handling of the impulse response controls via control API, and always
enable the build.  Two new controls, "Impulse Response Volume" and
"Impulse Response Period" are added as a replacement for the former
sysfs files.

	Tested-by: Chris Rorvick <chris@rorvick.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 075587b723ec5d90d1788b9cdba3034f524a64c9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/line6/Kconfig
#	drivers/staging/line6/pcm.c
diff --cc drivers/staging/line6/Kconfig
index 4f1219b4c692,8287ae6a2c26..000000000000
--- a/drivers/staging/line6/Kconfig
+++ b/drivers/staging/line6/Kconfig
@@@ -18,21 -20,21 +18,24 @@@ menuconfig LINE6_US
  	    * Signal routing (record clean/processed guitar signal,
  	      re-amping)
  
 -config SND_USB_PODHD
 -	tristate "Line6 POD HD300/400/500 USB support"
 -	select SND_USB_LINE6
 -	help
 -	  This is a driver for POD HD300, 400 and 500 devices.
 +	  Preliminary support for the Variax Workbench and TonePort
 +	  devices is included.
  
 -config SND_USB_TONEPORT
 -	tristate "TonePort GX, UX1 and UX2 USB support"
 -	select SND_USB_LINE6
 -	help
 -	  This is a driver for TonePort GX, UX1 and UX2 devices.
 +if LINE6_USB
  
 -config SND_USB_VARIAX
 -	tristate "Variax Workbench USB support"
 -	select SND_USB_LINE6
++<<<<<<< HEAD:drivers/staging/line6/Kconfig
 +config LINE6_USB_IMPULSE_RESPONSE
 +	bool "measure impulse response"
 +	default n
  	help
 -	  This is a driver for Variax Workbench device.
 +	  Say Y here to add code to measure the impulse response of a Line6
 +	  device. This is more accurate than user-space methods since it
 +	  bypasses any PCM data buffering (e.g., by ALSA or jack). This is
 +	  useful for assessing the performance of new devices, but is not
 +	  required for normal operation.
 +
 +	  If unsure, say N.
  
 +endif # LINE6_USB
++=======
++>>>>>>> 075587b723ec (ALSA: line6: Handle impulse response via control API):sound/usb/line6/Kconfig
diff --cc drivers/staging/line6/pcm.c
index a7856bad3cc6,626b6c158023..000000000000
--- a/drivers/staging/line6/pcm.c
+++ b/drivers/staging/line6/pcm.c
@@@ -19,85 -20,76 +19,119 @@@
  #include "capture.h"
  #include "driver.h"
  #include "playback.h"
 +#include "pod.h"
  
- #ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
- 
- static struct snd_line6_pcm *dev2pcm(struct device *dev)
+ /* impulse response volume controls */
+ static int snd_line6_impulse_volume_info(struct snd_kcontrol *kcontrol,
+ 					 struct snd_ctl_elem_info *uinfo)
  {
- 	struct usb_interface *interface = to_usb_interface(dev);
- 	struct usb_line6 *line6 = usb_get_intfdata(interface);
- 	struct snd_line6_pcm *line6pcm = line6->line6pcm;
- 	return line6pcm;
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+ 	uinfo->count = 1;
+ 	uinfo->value.integer.min = 0;
+ 	uinfo->value.integer.max = 255;
+ 	return 0;
  }
  
++<<<<<<< HEAD:drivers/staging/line6/pcm.c
 +/*
 +	"read" request on "impulse_volume" special file.
 +*/
 +static ssize_t pcm_get_impulse_volume(struct device *dev,
 +				      struct device_attribute *attr, char *buf)
++=======
+ static int snd_line6_impulse_volume_get(struct snd_kcontrol *kcontrol,
+ 					struct snd_ctl_elem_value *ucontrol)
++>>>>>>> 075587b723ec (ALSA: line6: Handle impulse response via control API):sound/usb/line6/pcm.c
  {
- 	return sprintf(buf, "%d\n", dev2pcm(dev)->impulse_volume);
+ 	struct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);
+ 
+ 	ucontrol->value.integer.value[0] = line6pcm->impulse_volume;
+ 	return 0;
  }
  
++<<<<<<< HEAD:drivers/staging/line6/pcm.c
 +/*
 +	"write" request on "impulse_volume" special file.
 +*/
 +static ssize_t pcm_set_impulse_volume(struct device *dev,
 +				      struct device_attribute *attr,
 +				      const char *buf, size_t count)
++=======
+ static int snd_line6_impulse_volume_put(struct snd_kcontrol *kcontrol,
+ 					struct snd_ctl_elem_value *ucontrol)
++>>>>>>> 075587b723ec (ALSA: line6: Handle impulse response via control API):sound/usb/line6/pcm.c
  {
- 	struct snd_line6_pcm *line6pcm = dev2pcm(dev);
- 	int value;
- 	int ret;
+ 	struct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);
+ 	int value = ucontrol->value.integer.value[0];
  
- 	ret = kstrtoint(buf, 10, &value);
- 	if (ret < 0)
- 		return ret;
+ 	if (line6pcm->impulse_volume == value)
+ 		return 0;
  
  	line6pcm->impulse_volume = value;
- 
  	if (value > 0)
  		line6_pcm_acquire(line6pcm, LINE6_BITS_PCM_IMPULSE);
  	else
  		line6_pcm_release(line6pcm, LINE6_BITS_PCM_IMPULSE);
- 
- 	return count;
+ 	return 1;
  }
  
++<<<<<<< HEAD:drivers/staging/line6/pcm.c
 +/*
 +	"read" request on "impulse_period" special file.
 +*/
 +static ssize_t pcm_get_impulse_period(struct device *dev,
 +				      struct device_attribute *attr, char *buf)
++=======
+ /* impulse response period controls */
+ static int snd_line6_impulse_period_info(struct snd_kcontrol *kcontrol,
+ 					 struct snd_ctl_elem_info *uinfo)
++>>>>>>> 075587b723ec (ALSA: line6: Handle impulse response via control API):sound/usb/line6/pcm.c
  {
- 	return sprintf(buf, "%d\n", dev2pcm(dev)->impulse_period);
+ 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+ 	uinfo->count = 1;
+ 	uinfo->value.integer.min = 0;
+ 	uinfo->value.integer.max = 2000;
+ 	return 0;
  }
  
++<<<<<<< HEAD:drivers/staging/line6/pcm.c
 +/*
 +	"write" request on "impulse_period" special file.
 +*/
 +static ssize_t pcm_set_impulse_period(struct device *dev,
 +				      struct device_attribute *attr,
 +				      const char *buf, size_t count)
++=======
+ static int snd_line6_impulse_period_get(struct snd_kcontrol *kcontrol,
+ 					struct snd_ctl_elem_value *ucontrol)
++>>>>>>> 075587b723ec (ALSA: line6: Handle impulse response via control API):sound/usb/line6/pcm.c
  {
- 	int value;
- 	int ret;
- 
- 	ret = kstrtoint(buf, 10, &value);
- 	if (ret < 0)
- 		return ret;
+ 	struct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);
  
- 	dev2pcm(dev)->impulse_period = value;
- 	return count;
+ 	ucontrol->value.integer.value[0] = line6pcm->impulse_period;
+ 	return 0;
  }
++<<<<<<< HEAD:drivers/staging/line6/pcm.c
 +
 +static DEVICE_ATTR(impulse_volume, S_IWUSR | S_IRUGO, pcm_get_impulse_volume,
 +		   pcm_set_impulse_volume);
 +static DEVICE_ATTR(impulse_period, S_IWUSR | S_IRUGO, pcm_get_impulse_period,
 +		   pcm_set_impulse_period);
++=======
++>>>>>>> 075587b723ec (ALSA: line6: Handle impulse response via control API):sound/usb/line6/pcm.c
  
- #endif
+ static int snd_line6_impulse_period_put(struct snd_kcontrol *kcontrol,
+ 					struct snd_ctl_elem_value *ucontrol)
+ {
+ 	struct snd_line6_pcm *line6pcm = snd_kcontrol_chip(kcontrol);
+ 	int value = ucontrol->value.integer.value[0];
+ 
+ 	if (line6pcm->impulse_period == value)
+ 		return 0;
+ 
+ 	line6pcm->impulse_period = value;
+ 	return 1;
+ }
  
  static bool test_flags(unsigned long flags0, unsigned long flags1,
  		       unsigned long mask)
@@@ -416,61 -427,15 +459,67 @@@ int line6_init_pcm(struct usb_line6 *li
  		.dev_free = snd_line6_pcm_free,
  	};
  
++<<<<<<< HEAD:drivers/staging/line6/pcm.c
 +	int err;
 +	int ep_read = 0, ep_write = 0;
++=======
+ 	int i, err;
+ 	unsigned ep_read = line6->properties->ep_audio_r;
+ 	unsigned ep_write = line6->properties->ep_audio_w;
++>>>>>>> 075587b723ec (ALSA: line6: Handle impulse response via control API):sound/usb/line6/pcm.c
  	struct snd_line6_pcm *line6pcm;
  
 -	if (!(line6->properties->capabilities & LINE6_CAP_PCM))
 +	if (!(line6->properties->capabilities & LINE6_BIT_PCM))
  		return 0;	/* skip PCM initialization and report success */
  
 -	line6pcm = kzalloc(sizeof(*line6pcm), GFP_KERNEL);
 +	/* initialize PCM subsystem based on product id: */
 +	switch (line6->product) {
 +	case LINE6_DEVID_BASSPODXT:
 +	case LINE6_DEVID_BASSPODXTLIVE:
 +	case LINE6_DEVID_BASSPODXTPRO:
 +	case LINE6_DEVID_PODXT:
 +	case LINE6_DEVID_PODXTLIVE:
 +	case LINE6_DEVID_PODXTPRO:
 +	case LINE6_DEVID_PODHD300:
 +		ep_read = 0x82;
 +		ep_write = 0x01;
 +		break;
 +
 +	case LINE6_DEVID_PODHD500:
 +	case LINE6_DEVID_PODX3:
 +	case LINE6_DEVID_PODX3LIVE:
 +		ep_read = 0x86;
 +		ep_write = 0x02;
 +		break;
 +
 +	case LINE6_DEVID_POCKETPOD:
 +		ep_read = 0x82;
 +		ep_write = 0x02;
 +		break;
 +
 +	case LINE6_DEVID_GUITARPORT:
 +	case LINE6_DEVID_PODSTUDIO_GX:
 +	case LINE6_DEVID_PODSTUDIO_UX1:
 +	case LINE6_DEVID_PODSTUDIO_UX2:
 +	case LINE6_DEVID_TONEPORT_GX:
 +	case LINE6_DEVID_TONEPORT_UX1:
 +	case LINE6_DEVID_TONEPORT_UX2:
 +		ep_read = 0x82;
 +		ep_write = 0x01;
 +		break;
 +
 +	/* this is for interface_number == 1:
 +	case LINE6_DEVID_TONEPORT_UX2:
 +	case LINE6_DEVID_PODSTUDIO_UX2:
 +		ep_read  = 0x87;
 +		ep_write = 0x00;
 +		break; */
 +
 +	default:
 +		MISSING_CASE;
 +	}
 +
 +	line6pcm = kzalloc(sizeof(struct snd_line6_pcm), GFP_KERNEL);
  
  	if (line6pcm == NULL)
  		return -ENOMEM;
* Unmerged path drivers/staging/line6/Kconfig
diff --git a/drivers/staging/line6/capture.c b/drivers/staging/line6/capture.c
index f8316b71f13d..15f658209b9a 100644
--- a/drivers/staging/line6/capture.c
+++ b/drivers/staging/line6/capture.c
@@ -243,9 +243,7 @@ static void audio_in_callback(struct urb *urb)
 		line6pcm->prev_fbuf = fbuf;
 		line6pcm->prev_fsize = fsize;
 
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 		if (!(line6pcm->flags & LINE6_BITS_PCM_IMPULSE))
-#endif
 			if (test_bit(LINE6_INDEX_PCM_ALSA_CAPTURE_STREAM,
 				     &line6pcm->flags) && (fsize > 0))
 				line6_capture_copy(line6pcm, fbuf, fsize);
@@ -261,9 +259,7 @@ static void audio_in_callback(struct urb *urb)
 	if (!shutdown) {
 		submit_audio_in_urb(line6pcm);
 
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 		if (!(line6pcm->flags & LINE6_BITS_PCM_IMPULSE))
-#endif
 			if (test_bit(LINE6_INDEX_PCM_ALSA_CAPTURE_STREAM,
 				     &line6pcm->flags))
 				line6_capture_check_period(line6pcm, length);
* Unmerged path drivers/staging/line6/pcm.c
diff --git a/drivers/staging/line6/pcm.h b/drivers/staging/line6/pcm.h
index 6aa0d46a2890..a9e450cd303e 100644
--- a/drivers/staging/line6/pcm.h
+++ b/drivers/staging/line6/pcm.h
@@ -35,9 +35,7 @@
 /* in a "full speed" device (such as the PODxt Pro) this means 1ms */
 #define LINE6_ISO_INTERVAL	1
 
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 #define LINE6_IMPULSE_DEFAULT_PERIOD 100
-#endif
 
 /*
 	Get substream from Line6 PCM data structure
@@ -89,12 +87,10 @@ enum {
 	LINE6_INDEX_PCM_MONITOR_PLAYBACK_STREAM,
 	LINE6_INDEX_PCM_MONITOR_CAPTURE_BUFFER,
 	LINE6_INDEX_PCM_MONITOR_CAPTURE_STREAM,
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	LINE6_INDEX_PCM_IMPULSE_PLAYBACK_BUFFER,
 	LINE6_INDEX_PCM_IMPULSE_PLAYBACK_STREAM,
 	LINE6_INDEX_PCM_IMPULSE_CAPTURE_BUFFER,
 	LINE6_INDEX_PCM_IMPULSE_CAPTURE_STREAM,
-#endif
 	LINE6_INDEX_PAUSE_PLAYBACK,
 	LINE6_INDEX_PREPARED,
 
@@ -107,12 +103,10 @@ enum {
 	LINE6_BIT(PCM_MONITOR_PLAYBACK_STREAM),
 	LINE6_BIT(PCM_MONITOR_CAPTURE_BUFFER),
 	LINE6_BIT(PCM_MONITOR_CAPTURE_STREAM),
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	LINE6_BIT(PCM_IMPULSE_PLAYBACK_BUFFER),
 	LINE6_BIT(PCM_IMPULSE_PLAYBACK_STREAM),
 	LINE6_BIT(PCM_IMPULSE_CAPTURE_BUFFER),
 	LINE6_BIT(PCM_IMPULSE_CAPTURE_STREAM),
-#endif
 	LINE6_BIT(PAUSE_PLAYBACK),
 	LINE6_BIT(PREPARED),
 
@@ -131,40 +125,30 @@ enum {
 	    LINE6_BIT_PCM_MONITOR_CAPTURE_BUFFER |
 	    LINE6_BIT_PCM_MONITOR_CAPTURE_STREAM,
 
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	LINE6_BITS_PCM_IMPULSE =
 	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_BUFFER |
 	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_STREAM |
 	    LINE6_BIT_PCM_IMPULSE_CAPTURE_BUFFER |
 	    LINE6_BIT_PCM_IMPULSE_CAPTURE_STREAM,
-#endif
 
 	/* combined bit masks (by direction): */
 	LINE6_BITS_PLAYBACK_BUFFER =
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_BUFFER |
-#endif
 	    LINE6_BIT_PCM_ALSA_PLAYBACK_BUFFER |
 	    LINE6_BIT_PCM_MONITOR_PLAYBACK_BUFFER ,
 
 	LINE6_BITS_PLAYBACK_STREAM =
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	    LINE6_BIT_PCM_IMPULSE_PLAYBACK_STREAM |
-#endif
 	    LINE6_BIT_PCM_ALSA_PLAYBACK_STREAM |
 	    LINE6_BIT_PCM_MONITOR_PLAYBACK_STREAM ,
 
 	LINE6_BITS_CAPTURE_BUFFER =
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	    LINE6_BIT_PCM_IMPULSE_CAPTURE_BUFFER |
-#endif
 	    LINE6_BIT_PCM_ALSA_CAPTURE_BUFFER |
 	    LINE6_BIT_PCM_MONITOR_CAPTURE_BUFFER ,
 
 	LINE6_BITS_CAPTURE_STREAM =
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	    LINE6_BIT_PCM_IMPULSE_CAPTURE_STREAM |
-#endif
 	    LINE6_BIT_PCM_ALSA_CAPTURE_STREAM |
 	    LINE6_BIT_PCM_MONITOR_CAPTURE_STREAM,
 
@@ -346,7 +330,6 @@ struct snd_line6_pcm {
 	*/
 	int volume_monitor;
 
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 	/**
 		 Volume of impulse response test signal (if zero, test is disabled).
 	*/
@@ -361,7 +344,6 @@ struct snd_line6_pcm {
 		 Counter for impulse response test signal.
 	*/
 	int impulse_count;
-#endif
 
 	/**
 		 Several status bits (see LINE6_BIT_*).
diff --git a/drivers/staging/line6/playback.c b/drivers/staging/line6/playback.c
index f9135c7cb195..a9cff044c8b0 100644
--- a/drivers/staging/line6/playback.c
+++ b/drivers/staging/line6/playback.c
@@ -58,8 +58,6 @@ static void change_volume(struct urb *urb_out, int volume[],
 	}
 }
 
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
-
 /*
 	Create signal for impulse response test.
 */
@@ -103,8 +101,6 @@ static void create_impulse_test_signal(struct snd_line6_pcm *line6pcm,
 	}
 }
 
-#endif
-
 /*
 	Add signal to buffer for software monitoring.
 */
@@ -238,7 +234,6 @@ static int submit_audio_out_urb(struct snd_line6_pcm *line6pcm)
 	change_volume(urb_out, line6pcm->volume_playback, bytes_per_frame);
 
 	if (line6pcm->prev_fbuf != NULL) {
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 		if (line6pcm->flags & LINE6_BITS_PCM_IMPULSE) {
 			create_impulse_test_signal(line6pcm, urb_out,
 						   bytes_per_frame);
@@ -251,7 +246,6 @@ static int submit_audio_out_urb(struct snd_line6_pcm *line6pcm)
 							   urb_out->transfer_buffer_length);
 			}
 		} else {
-#endif
 			if (!
 			    (line6pcm->line6->
 			     properties->capabilities & LINE6_BIT_HWMON)
@@ -260,9 +254,7 @@ static int submit_audio_out_urb(struct snd_line6_pcm *line6pcm)
 				add_monitor_signal(urb_out, line6pcm->prev_fbuf,
 						   line6pcm->volume_monitor,
 						   bytes_per_frame);
-#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
 		}
-#endif
 	}
 
 	ret = usb_submit_urb(urb_out, GFP_ATOMIC);
