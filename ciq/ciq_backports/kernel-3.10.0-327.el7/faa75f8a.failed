ALSA: hda - Use regmap for parameter caches, too

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Use regmap for parameter caches, too (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 93.33%
commit-author Takashi Iwai <tiwai@suse.de>
commit faa75f8a2edf005a5caf43be4875ffeeb9bcb498
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/faa75f8a.failed

The amp hash table was used for recording the cached reads of some
capability values like pin caps or amp caps.  Now all these are moved
to regmap as well.

One addition to the regmap helper is codec->caps_overwriting flag.
This is set in snd_hdac_override_parm(), and the regmap helper accepts
any register while this flag is set, so that it can overwrite even the
read-only verb like AC_VERB_PARAMETERS.  The flag is cleared
immediately in snd_hdac_override_parm(), as it's a once-off flag.

Along with these changes, the no longer needed amp hash and relevant
fields are removed from hda_codec struct now.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit faa75f8a2edf005a5caf43be4875ffeeb9bcb498)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/hdaudio.h
#	sound/hda/hdac_device.c
#	sound/hda/hdac_regmap.c
#	sound/pci/hda/hda_codec.c
diff --cc sound/pci/hda/hda_codec.c
index 05cb5f57659a,b27f250088c1..000000000000
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@@ -1259,10 -987,17 +1257,22 @@@ static int snd_hda_codec_dev_free(struc
  	return 0;
  }
  
 +/* just free the container */
  static void snd_hda_codec_dev_release(struct device *dev)
  {
++<<<<<<< HEAD
 +	kfree(dev_to_hda_codec(dev));
++=======
+ 	struct hda_codec *codec = dev_to_hda_codec(dev);
+ 
+ 	free_init_pincfgs(codec);
+ 	snd_hdac_device_exit(&codec->core);
+ 	snd_hda_sysfs_clear(codec);
+ 	free_hda_cache(&codec->cmd_cache);
+ 	kfree(codec->modelname);
+ 	kfree(codec->wcaps);
+ 	kfree(codec);
++>>>>>>> faa75f8a2edf (ALSA: hda - Use regmap for parameter caches, too)
  }
  
  /**
@@@ -1694,67 -1376,6 +1703,70 @@@ static struct hda_cache_head  *get_allo
  	return info;
  }
  
++<<<<<<< HEAD
 +/* query and allocate an amp hash entry */
 +static inline struct hda_amp_info *
 +get_alloc_amp_hash(struct hda_codec *codec, u32 key)
 +{
 +	return (struct hda_amp_info *)get_alloc_hash(&codec->amp_cache, key);
 +}
 +
 +/* overwrite the value with the key in the caps hash */
 +static int write_caps_hash(struct hda_codec *codec, u32 key, unsigned int val)
 +{
 +	struct hda_amp_info *info;
 +
 +	mutex_lock(&codec->hash_mutex);
 +	info = get_alloc_amp_hash(codec, key);
 +	if (!info) {
 +		mutex_unlock(&codec->hash_mutex);
 +		return -EINVAL;
 +	}
 +	info->amp_caps = val;
 +	info->head.val |= INFO_AMP_CAPS;
 +	mutex_unlock(&codec->hash_mutex);
 +	return 0;
 +}
 +
 +/* query the value from the caps hash; if not found, fetch the current
 + * value from the given function and store in the hash
 + */
 +static unsigned int
 +query_caps_hash(struct hda_codec *codec, hda_nid_t nid, int dir, u32 key,
 +		unsigned int (*func)(struct hda_codec *, hda_nid_t, int))
 +{
 +	struct hda_amp_info *info;
 +	unsigned int val;
 +
 +	mutex_lock(&codec->hash_mutex);
 +	info = get_alloc_amp_hash(codec, key);
 +	if (!info) {
 +		mutex_unlock(&codec->hash_mutex);
 +		return 0;
 +	}
 +	if (!(info->head.val & INFO_AMP_CAPS)) {
 +		mutex_unlock(&codec->hash_mutex); /* for reentrance */
 +		val = func(codec, nid, dir);
 +		write_caps_hash(codec, key, val);
 +	} else {
 +		val = info->amp_caps;
 +		mutex_unlock(&codec->hash_mutex);
 +	}
 +	return val;
 +}
 +
 +static unsigned int read_amp_cap(struct hda_codec *codec, hda_nid_t nid,
 +				 int direction)
 +{
 +	if (!(get_wcaps(codec, nid) & AC_WCAP_AMP_OVRD))
 +		nid = codec->afg;
 +	return snd_hda_param_read(codec, nid,
 +				  direction == HDA_OUTPUT ?
 +				  AC_PAR_AMP_OUT_CAP : AC_PAR_AMP_IN_CAP);
 +}
 +
++=======
++>>>>>>> faa75f8a2edf (ALSA: hda - Use regmap for parameter caches, too)
  /**
   * query_amp_caps - query AMP capabilities
   * @codec: the HD-auio codec
@@@ -1816,180 -1444,6 +1835,183 @@@ int snd_hda_override_amp_caps(struct hd
  }
  EXPORT_SYMBOL_GPL(snd_hda_override_amp_caps);
  
++<<<<<<< HEAD
 +static unsigned int read_pin_cap(struct hda_codec *codec, hda_nid_t nid,
 +				 int dir)
 +{
 +	return snd_hda_param_read(codec, nid, AC_PAR_PIN_CAP);
 +}
 +
 +/**
 + * snd_hda_query_pin_caps - Query PIN capabilities
 + * @codec: the HD-auio codec
 + * @nid: the NID to query
 + *
 + * Query PIN capabilities for the given widget.
 + * Returns the obtained capability bits.
 + *
 + * When cap bits have been already read, this doesn't read again but
 + * returns the cached value.
 + */
 +u32 snd_hda_query_pin_caps(struct hda_codec *codec, hda_nid_t nid)
 +{
 +	return query_caps_hash(codec, nid, 0, HDA_HASH_PINCAP_KEY(nid),
 +			       read_pin_cap);
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_query_pin_caps);
 +
 +/**
 + * snd_hda_override_pin_caps - Override the pin capabilities
 + * @codec: the CODEC
 + * @nid: the NID to override
 + * @caps: the capability bits to set
 + *
 + * Override the cached PIN capabilitiy bits value by the given one.
 + *
 + * Returns zero if successful or a negative error code.
 + */
 +int snd_hda_override_pin_caps(struct hda_codec *codec, hda_nid_t nid,
 +			      unsigned int caps)
 +{
 +	return write_caps_hash(codec, HDA_HASH_PINCAP_KEY(nid), caps);
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_override_pin_caps);
 +
 +/* read or sync the hash value with the current value;
 + * call within hash_mutex
 + */
 +static struct hda_amp_info *
 +update_amp_hash(struct hda_codec *codec, hda_nid_t nid, int ch,
 +		int direction, int index, bool init_only)
 +{
 +	struct hda_amp_info *info;
 +	unsigned int parm, val = 0;
 +	bool val_read = false;
 +
 + retry:
 +	info = get_alloc_amp_hash(codec, HDA_HASH_KEY(nid, direction, index));
 +	if (!info)
 +		return NULL;
 +	if (!(info->head.val & INFO_AMP_VOL(ch))) {
 +		if (!val_read) {
 +			mutex_unlock(&codec->hash_mutex);
 +			parm = ch ? AC_AMP_GET_RIGHT : AC_AMP_GET_LEFT;
 +			parm |= direction == HDA_OUTPUT ?
 +				AC_AMP_GET_OUTPUT : AC_AMP_GET_INPUT;
 +			parm |= index;
 +			val = snd_hda_codec_read(codec, nid, 0,
 +				 AC_VERB_GET_AMP_GAIN_MUTE, parm);
 +			val &= 0xff;
 +			val_read = true;
 +			mutex_lock(&codec->hash_mutex);
 +			goto retry;
 +		}
 +		info->vol[ch] = val;
 +		info->head.val |= INFO_AMP_VOL(ch);
 +	} else if (init_only)
 +		return NULL;
 +	return info;
 +}
 +
 +/*
 + * write the current volume in info to the h/w
 + */
 +static void put_vol_mute(struct hda_codec *codec, unsigned int amp_caps,
 +			 hda_nid_t nid, int ch, int direction, int index,
 +			 int val)
 +{
 +	u32 parm;
 +
 +	parm = ch ? AC_AMP_SET_RIGHT : AC_AMP_SET_LEFT;
 +	parm |= direction == HDA_OUTPUT ? AC_AMP_SET_OUTPUT : AC_AMP_SET_INPUT;
 +	parm |= index << AC_AMP_SET_INDEX_SHIFT;
 +	if ((val & HDA_AMP_MUTE) && !(amp_caps & AC_AMPCAP_MUTE) &&
 +	    (amp_caps & AC_AMPCAP_MIN_MUTE))
 +		; /* set the zero value as a fake mute */
 +	else
 +		parm |= val;
 +	snd_hda_codec_write(codec, nid, 0, AC_VERB_SET_AMP_GAIN_MUTE, parm);
 +}
 +
 +/**
 + * snd_hda_codec_amp_read - Read AMP value
 + * @codec: HD-audio codec
 + * @nid: NID to read the AMP value
 + * @ch: channel (left=0 or right=1)
 + * @direction: #HDA_INPUT or #HDA_OUTPUT
 + * @index: the index value (only for input direction)
 + *
 + * Read AMP value.  The volume is between 0 to 0x7f, 0x80 = mute bit.
 + */
 +int snd_hda_codec_amp_read(struct hda_codec *codec, hda_nid_t nid, int ch,
 +			   int direction, int index)
 +{
 +	struct hda_amp_info *info;
 +	unsigned int val = 0;
 +
 +	mutex_lock(&codec->hash_mutex);
 +	info = update_amp_hash(codec, nid, ch, direction, index, false);
 +	if (info)
 +		val = info->vol[ch];
 +	mutex_unlock(&codec->hash_mutex);
 +	return val;
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_codec_amp_read);
 +
 +static int codec_amp_update(struct hda_codec *codec, hda_nid_t nid, int ch,
 +			    int direction, int idx, int mask, int val,
 +			    bool init_only, bool cache_only)
 +{
 +	struct hda_amp_info *info;
 +	unsigned int caps;
 +
 +	if (snd_BUG_ON(mask & ~0xff))
 +		mask &= 0xff;
 +	val &= mask;
 +
 +	mutex_lock(&codec->hash_mutex);
 +	info = update_amp_hash(codec, nid, ch, direction, idx, init_only);
 +	if (!info) {
 +		mutex_unlock(&codec->hash_mutex);
 +		return 0;
 +	}
 +	val |= info->vol[ch] & ~mask;
 +	if (info->vol[ch] == val) {
 +		mutex_unlock(&codec->hash_mutex);
 +		return 0;
 +	}
 +	info->vol[ch] = val;
 +	info->head.dirty |= cache_only;
 +	caps = info->amp_caps;
 +	mutex_unlock(&codec->hash_mutex);
 +	if (!cache_only)
 +		put_vol_mute(codec, caps, nid, ch, direction, idx, val);
 +	return 1;
 +}
 +
 +/**
 + * snd_hda_codec_amp_update - update the AMP value
 + * @codec: HD-audio codec
 + * @nid: NID to read the AMP value
 + * @ch: channel (left=0 or right=1)
 + * @direction: #HDA_INPUT or #HDA_OUTPUT
 + * @idx: the index value (only for input direction)
 + * @mask: bit mask to set
 + * @val: the bits value to set
 + *
 + * Update the AMP value with a bit mask.
 + * Returns 0 if the value is unchanged, 1 if changed.
 + */
 +int snd_hda_codec_amp_update(struct hda_codec *codec, hda_nid_t nid, int ch,
 +			     int direction, int idx, int mask, int val)
 +{
 +	return codec_amp_update(codec, nid, ch, direction, idx, mask, val,
 +				false, codec->cached_write);
 +}
 +EXPORT_SYMBOL_GPL(snd_hda_codec_amp_update);
 +
++=======
++>>>>>>> faa75f8a2edf (ALSA: hda - Use regmap for parameter caches, too)
  /**
   * snd_hda_codec_amp_stereo - update the AMP stereo values
   * @codec: HD-audio codec
@@@ -4212,11 -3610,10 +4229,10 @@@ unsigned int snd_hda_calc_stream_format
  }
  EXPORT_SYMBOL_GPL(snd_hda_calc_stream_format);
  
- static unsigned int get_pcm_param(struct hda_codec *codec, hda_nid_t nid,
- 				  int dir)
+ static unsigned int query_pcm_param(struct hda_codec *codec, hda_nid_t nid)
  {
  	unsigned int val = 0;
 -	if (nid != codec->core.afg &&
 +	if (nid != codec->afg &&
  	    (get_wcaps(codec, nid) & AC_WCAP_FORMAT_OVRD))
  		val = snd_hda_param_read(codec, nid, AC_PAR_PCM);
  	if (!val || val == -1)
* Unmerged path include/sound/hdaudio.h
* Unmerged path sound/hda/hdac_device.c
* Unmerged path sound/hda/hdac_regmap.c
* Unmerged path include/sound/hdaudio.h
* Unmerged path sound/hda/hdac_device.c
* Unmerged path sound/hda/hdac_regmap.c
* Unmerged path sound/pci/hda/hda_codec.c
diff --git a/sound/pci/hda/hda_codec.h b/sound/pci/hda/hda_codec.h
index 4f8090e5338d..76269f7897a8 100644
--- a/sound/pci/hda/hda_codec.h
+++ b/sound/pci/hda/hda_codec.h
@@ -216,12 +216,6 @@ struct hda_cache_head {
 	u16 next;
 };
 
-struct hda_amp_info {
-	struct hda_cache_head head;
-	u32 amp_caps;		/* amp capabilities */
-	u16 vol[2];		/* current volume & mute */
-};
-
 struct hda_cache_rec {
 	u16 hash[64];			/* hash table for index */
 	struct snd_array buf;		/* record entries */
@@ -327,7 +321,6 @@ struct hda_codec {
 	struct snd_array mixers;	/* list of assigned mixer elements */
 	struct snd_array nids;		/* list of mapped mixer elements */
 
-	struct hda_cache_rec amp_cache;	/* cache for amp access */
 	struct hda_cache_rec cmd_cache;	/* cache for other commands */
 
 	struct list_head conn_list;	/* linked-list of connection-list */
diff --git a/sound/pci/hda/hda_local.h b/sound/pci/hda/hda_local.h
index 1d001647fc47..d6a5bb10f6ca 100644
--- a/sound/pci/hda/hda_local.h
+++ b/sound/pci/hda/hda_local.h
@@ -555,9 +555,41 @@ static inline void snd_hda_override_wcaps(struct hda_codec *codec,
 u32 query_amp_caps(struct hda_codec *codec, hda_nid_t nid, int direction);
 int snd_hda_override_amp_caps(struct hda_codec *codec, hda_nid_t nid, int dir,
 			      unsigned int caps);
-u32 snd_hda_query_pin_caps(struct hda_codec *codec, hda_nid_t nid);
-int snd_hda_override_pin_caps(struct hda_codec *codec, hda_nid_t nid,
-			      unsigned int caps);
+/**
+ * snd_hda_query_pin_caps - Query PIN capabilities
+ * @codec: the HD-auio codec
+ * @nid: the NID to query
+ *
+ * Query PIN capabilities for the given widget.
+ * Returns the obtained capability bits.
+ *
+ * When cap bits have been already read, this doesn't read again but
+ * returns the cached value.
+ */
+static inline u32
+snd_hda_query_pin_caps(struct hda_codec *codec, hda_nid_t nid)
+{
+	return snd_hda_param_read(codec, nid, AC_PAR_PIN_CAP);
+
+}
+
+/**
+ * snd_hda_override_pin_caps - Override the pin capabilities
+ * @codec: the CODEC
+ * @nid: the NID to override
+ * @caps: the capability bits to set
+ *
+ * Override the cached PIN capabilitiy bits value by the given one.
+ *
+ * Returns zero if successful or a negative error code.
+ */
+static inline int
+snd_hda_override_pin_caps(struct hda_codec *codec, hda_nid_t nid,
+			  unsigned int caps)
+{
+	return snd_hdac_override_parm(&codec->core, nid, AC_PAR_PIN_CAP, caps);
+}
+
 bool snd_hda_check_amp_caps(struct hda_codec *codec, hda_nid_t nid,
 			   int dir, unsigned int bits);
 
