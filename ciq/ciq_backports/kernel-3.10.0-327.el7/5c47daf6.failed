md: move mddev_lock and related to md.h

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [md] move mddev_lock and related to md.h (Jes Sorensen) [1150149 1173510 1194720]
Rebuild_FUZZ: 94.59%
commit-author NeilBrown <neilb@suse.de>
commit 5c47daf6e76f657d961a96d89f6419fde8eda557
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/5c47daf6.failed

The one which is not inline (mddev_unlock) gets EXPORTed.

This makes the locking available to personality modules so that it
doesn't have to be imposed upon them.

	Signed-off-by: NeilBrown <neilb@suse.de>
(cherry picked from commit 5c47daf6e76f657d961a96d89f6419fde8eda557)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
#	drivers/md/md.h
diff --cc drivers/md/md.c
index 5d8c7c589a1e,ea839d811f64..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -597,32 -590,9 +597,38 @@@ static struct mddev * mddev_find(dev_t 
  	goto retry;
  }
  
++<<<<<<< HEAD
 +static inline int __must_check mddev_lock(struct mddev * mddev)
 +{
 +	return mutex_lock_interruptible(&mddev->reconfig_mutex);
 +}
 +
 +/* Sometimes we need to take the lock in a situation where
 + * failure due to interrupts is not acceptable.
 + */
 +static inline void mddev_lock_nointr(struct mddev * mddev)
 +{
 +	mutex_lock(&mddev->reconfig_mutex);
 +}
 +
 +static inline int mddev_is_locked(struct mddev *mddev)
 +{
 +	return mutex_is_locked(&mddev->reconfig_mutex);
 +}
 +
 +static inline int mddev_trylock(struct mddev * mddev)
 +{
 +	return mutex_trylock(&mddev->reconfig_mutex);
 +}
 +
 +static struct attribute_group md_redundancy_group;
 +
 +static void mddev_unlock(struct mddev * mddev)
++=======
+ static struct attribute_group md_redundancy_group;
+ 
+ void mddev_unlock(struct mddev *mddev)
++>>>>>>> 5c47daf6e76f (md: move mddev_lock and related to md.h)
  {
  	if (mddev->to_remove) {
  		/* These cannot be removed under reconfig_mutex as
diff --cc drivers/md/md.h
index 8c92b269b12b,14367d919351..000000000000
--- a/drivers/md/md.h
+++ b/drivers/md/md.h
@@@ -445,6 -450,29 +445,32 @@@ struct mddev 
  	void (*sync_super)(struct mddev *mddev, struct md_rdev *rdev);
  };
  
++<<<<<<< HEAD
++=======
+ static inline int __must_check mddev_lock(struct mddev *mddev)
+ {
+ 	return mutex_lock_interruptible(&mddev->reconfig_mutex);
+ }
+ 
+ /* Sometimes we need to take the lock in a situation where
+  * failure due to interrupts is not acceptable.
+  */
+ static inline void mddev_lock_nointr(struct mddev *mddev)
+ {
+ 	mutex_lock(&mddev->reconfig_mutex);
+ }
+ 
+ static inline int mddev_is_locked(struct mddev *mddev)
+ {
+ 	return mutex_is_locked(&mddev->reconfig_mutex);
+ }
+ 
+ static inline int mddev_trylock(struct mddev *mddev)
+ {
+ 	return mutex_trylock(&mddev->reconfig_mutex);
+ }
+ extern void mddev_unlock(struct mddev *mddev);
++>>>>>>> 5c47daf6e76f (md: move mddev_lock and related to md.h)
  
  static inline void rdev_dec_pending(struct md_rdev *rdev, struct mddev *mddev)
  {
* Unmerged path drivers/md/md.c
* Unmerged path drivers/md/md.h
