fib_trie: Remove leaf_info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 79e5ad2ceb00673e5f2d278a892adcbf596a6b5a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/79e5ad2c.failed

At this point the leaf_info hash is redundant.  By adding the suffix length
to the fib_alias hash list we no longer have need of leaf_info as we can
determine the prefix length from fa_slen.  So we can compress things by
dropping the leaf_info structure from fib_trie and instead directly connect
the leaves to the fib_alias hash list.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 79e5ad2ceb00673e5f2d278a892adcbf596a6b5a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 3fe26090641a,f48534577f8d..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -112,14 -112,6 +112,17 @@@ struct tnode 
  	};
  };
  
++<<<<<<< HEAD
 +struct leaf_info {
 +	struct hlist_node hlist;
 +	int plen;
 +	u32 mask_plen; /* ntohl(inet_make_mask(plen)) */
 +	struct list_head falh;
 +	struct rcu_head rcu;
 +};
 +
++=======
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  #ifdef CONFIG_IP_FIB_TRIE_STATS
  struct trie_use_stats {
  	unsigned int gets;
@@@ -333,17 -320,6 +331,20 @@@ static struct tnode *leaf_new(t_key key
  	return l;
  }
  
++<<<<<<< HEAD
 +static struct leaf_info *leaf_info_new(int plen)
 +{
 +	struct leaf_info *li = kmalloc(sizeof(struct leaf_info),  GFP_KERNEL);
 +	if (li) {
 +		li->plen = plen;
 +		li->mask_plen = ntohl(inet_make_mask(plen));
 +		INIT_LIST_HEAD(&li->falh);
 +	}
 +	return li;
 +}
 +
++=======
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  static struct tnode *tnode_new(t_key key, int pos, int bits)
  {
  	size_t sz = offsetof(struct tnode, child[1ul << bits]);
@@@ -877,31 -842,6 +878,34 @@@ static void resize(struct trie *t, stru
  	}
  }
  
++<<<<<<< HEAD
 +/* readside must use rcu_read_lock currently dump routines
 + via get_fa_head and dump */
 +
 +static struct leaf_info *find_leaf_info(struct tnode *l, int plen)
 +{
 +	struct hlist_head *head = &l->list;
 +	struct leaf_info *li;
 +
 +	hlist_for_each_entry_rcu(li, head, hlist)
 +		if (li->plen == plen)
 +			return li;
 +
 +	return NULL;
 +}
 +
 +static inline struct list_head *get_fa_head(struct tnode *l, int plen)
 +{
 +	struct leaf_info *li = find_leaf_info(l, plen);
 +
 +	if (!li)
 +		return NULL;
 +
 +	return &li->falh;
 +}
 +
++=======
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  static void leaf_pull_suffix(struct tnode *l)
  {
  	struct tnode *tp = node_parent(l);
@@@ -940,33 -880,33 +944,61 @@@ static void fib_remove_alias(struct tno
  		return;
  
  	/* update the trie with the latest suffix length */
++<<<<<<< HEAD
 +	l->slen = KEYLENGTH - li->plen;
++=======
+ 	l->slen = fa->fa_slen;
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  	leaf_pull_suffix(l);
  }
  
- static void insert_leaf_info(struct tnode *l, struct leaf_info *new)
+ static void fib_insert_alias(struct tnode *l, struct fib_alias *fa,
+ 			     struct fib_alias *new)
  {
++<<<<<<< HEAD
 +	struct hlist_head *head = &l->list;
 +	struct leaf_info *li = NULL, *last = NULL;
 +
 +	if (hlist_empty(head)) {
 +		hlist_add_head_rcu(&new->hlist, head);
 +	} else {
 +		hlist_for_each_entry(li, head, hlist) {
 +			if (new->plen > li->plen)
 +				break;
 +
 +			last = li;
 +		}
 +		if (last)
 +			hlist_add_after_rcu(&last->hlist, &new->hlist);
 +		else
 +			hlist_add_before_rcu(&new->hlist, &li->hlist);
 +	}
 +
 +	/* if we added to the tail node then we need to update slen */
 +	if (l->slen < (KEYLENGTH - new->plen)) {
 +		l->slen = KEYLENGTH - new->plen;
++=======
+ 	if (fa) {
+ 		hlist_add_before_rcu(&new->fa_list, &fa->fa_list);
+ 	} else {
+ 		struct fib_alias *last;
+ 
+ 		hlist_for_each_entry(last, &l->leaf, fa_list) {
+ 			if (new->fa_slen < last->fa_slen)
+ 				break;
+ 			fa = last;
+ 		}
+ 
+ 		if (fa)
+ 			hlist_add_behind_rcu(&new->fa_list, &fa->fa_list);
+ 		else
+ 			hlist_add_head_rcu(&new->fa_list, &l->leaf);
+ 	}
+ 
+ 	/* if we added to the tail node then we need to update slen */
+ 	if (l->slen < new->fa_slen) {
+ 		l->slen = new->fa_slen;
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  		leaf_push_suffix(l);
  	}
  }
@@@ -1002,6 -942,31 +1034,34 @@@ static struct tnode *fib_find_node(stru
  	return n;
  }
  
++<<<<<<< HEAD
++=======
+ /* Return the first fib alias matching TOS with
+  * priority less than or equal to PRIO.
+  */
+ static struct fib_alias *fib_find_alias(struct hlist_head *fah, u8 slen,
+ 					u8 tos, u32 prio)
+ {
+ 	struct fib_alias *fa;
+ 
+ 	if (!fah)
+ 		return NULL;
+ 
+ 	hlist_for_each_entry(fa, fah, fa_list) {
+ 		if (fa->fa_slen < slen)
+ 			continue;
+ 		if (fa->fa_slen != slen)
+ 			break;
+ 		if (fa->fa_tos > tos)
+ 			continue;
+ 		if (fa->fa_info->fib_priority >= prio || fa->fa_tos < tos)
+ 			return fa;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  static void trie_rebalance(struct trie *t, struct tnode *tn)
  {
  	struct tnode *tp;
@@@ -1018,16 -983,9 +1078,15 @@@
  
  /* only used from updater-side */
  
++<<<<<<< HEAD
 +static struct list_head *fib_insert_node(struct trie *t, u32 key, int plen)
 +{
 +	struct list_head *fa_head = NULL;
++=======
+ static struct tnode *fib_insert_node(struct trie *t, u32 key, int plen)
+ {
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  	struct tnode *l, *n, *tp = NULL;
- 	struct leaf_info *li;
- 
- 	li = leaf_info_new(plen);
- 	if (!li)
- 		return NULL;
- 	fa_head = &li->falh;
  
  	n = rtnl_dereference(t->trie);
  
@@@ -1121,9 -1073,9 +1174,13 @@@ int fib_table_insert(struct fib_table *
  {
  	struct trie *t = (struct trie *) tb->tb_data;
  	struct fib_alias *fa, *new_fa;
++<<<<<<< HEAD
 +	struct list_head *fa_head = NULL;
++=======
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  	struct fib_info *fi;
- 	int plen = cfg->fc_dst_len;
+ 	u8 plen = cfg->fc_dst_len;
+ 	u8 slen = KEYLENGTH - plen;
  	u8 tos = cfg->fc_tos;
  	u32 key, mask;
  	int err;
@@@ -1183,9 -1126,8 +1233,14 @@@
  		 */
  		fa_match = NULL;
  		fa_first = fa;
++<<<<<<< HEAD
 +		fa = list_entry(fa->fa_list.prev, struct fib_alias, fa_list);
 +		list_for_each_entry_continue(fa, fa_head, fa_list) {
 +			if (fa->fa_tos != tos)
++=======
+ 		hlist_for_each_entry_from(fa, fa_list) {
+ 			if ((fa->fa_slen != slen) || (fa->fa_tos != tos))
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  				break;
  			if (fa->fa_info->fib_priority != fi->fib_priority)
  				break;
@@@ -1252,13 -1195,12 +1307,22 @@@
  	new_fa->fa_tos = tos;
  	new_fa->fa_type = cfg->fc_type;
  	new_fa->fa_state = 0;
++<<<<<<< HEAD
 +	/*
 +	 * Insert new entry to the list.
 +	 */
 +
 +	if (!fa_head) {
 +		fa_head = fib_insert_node(t, key, plen);
 +		if (unlikely(!fa_head)) {
++=======
+ 	new_fa->fa_slen = slen;
+ 
+ 	/* Insert new entry to the list. */
+ 	if (!l) {
+ 		l = fib_insert_node(t, key, plen);
+ 		if (unlikely(!l)) {
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  			err = -ENOMEM;
  			goto out_free_new_fa;
  		}
@@@ -1267,8 -1209,7 +1331,12 @@@
  	if (!plen)
  		tb->tb_num_default++;
  
++<<<<<<< HEAD
 +	list_add_tail_rcu(&new_fa->fa_list,
 +			  (fa ? &fa->fa_list : fa_head));
++=======
+ 	fib_insert_alias(l, fa, new_fa);
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  
  	rt_cache_flush(cfg->fc_nlinfo.nl_net);
  	rtmsg_fib(RTM_NEWROUTE, htonl(key), new_fa, plen, tb->tb_id,
@@@ -1404,61 -1345,56 +1472,89 @@@ backtrace
  
  found:
  	/* Step 3: Process the leaf, if that fails fall back to backtracing */
- 	hlist_for_each_entry_rcu(li, &n->list, hlist) {
- 		struct fib_alias *fa;
+ 	hlist_for_each_entry_rcu(fa, &n->leaf, fa_list) {
+ 		struct fib_info *fi = fa->fa_info;
+ 		int nhsel, err;
  
++<<<<<<< HEAD
 +		if ((key ^ n->key) & li->mask_plen)
 +			continue;
 +
 +		list_for_each_entry_rcu(fa, &li->falh, fa_list) {
 +			struct fib_info *fi = fa->fa_info;
 +			int nhsel, err;
 +
 +			if (fa->fa_tos && fa->fa_tos != flp->flowi4_tos)
 +				continue;
 +			if (fi->fib_dead)
 +				continue;
 +			if (fa->fa_info->fib_scope < flp->flowi4_scope)
 +				continue;
 +			fib_alias_accessed(fa);
 +			err = fib_props[fa->fa_type].error;
 +			if (unlikely(err < 0)) {
++=======
+ 		if (((key ^ n->key) >= (1ul << fa->fa_slen)) &&
+ 		    ((BITS_PER_LONG > KEYLENGTH) || (fa->fa_slen != KEYLENGTH)))
+ 				continue;
+ 		if (fa->fa_tos && fa->fa_tos != flp->flowi4_tos)
+ 			continue;
+ 		if (fi->fib_dead)
+ 			continue;
+ 		if (fa->fa_info->fib_scope < flp->flowi4_scope)
+ 			continue;
+ 		fib_alias_accessed(fa);
+ 		err = fib_props[fa->fa_type].error;
+ 		if (unlikely(err < 0)) {
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  #ifdef CONFIG_IP_FIB_TRIE_STATS
- 				this_cpu_inc(stats->semantic_match_passed);
+ 			this_cpu_inc(stats->semantic_match_passed);
  #endif
- 				return err;
- 			}
- 			if (fi->fib_flags & RTNH_F_DEAD)
+ 			return err;
+ 		}
+ 		if (fi->fib_flags & RTNH_F_DEAD)
+ 			continue;
+ 		for (nhsel = 0; nhsel < fi->fib_nhs; nhsel++) {
+ 			const struct fib_nh *nh = &fi->fib_nh[nhsel];
+ 
+ 			if (nh->nh_flags & RTNH_F_DEAD)
+ 				continue;
+ 			if (flp->flowi4_oif && flp->flowi4_oif != nh->nh_oif)
  				continue;
- 			for (nhsel = 0; nhsel < fi->fib_nhs; nhsel++) {
- 				const struct fib_nh *nh = &fi->fib_nh[nhsel];
  
- 				if (nh->nh_flags & RTNH_F_DEAD)
- 					continue;
- 				if (flp->flowi4_oif && flp->flowi4_oif != nh->nh_oif)
- 					continue;
+ 			if (!(fib_flags & FIB_LOOKUP_NOREF))
+ 				atomic_inc(&fi->fib_clntref);
  
++<<<<<<< HEAD
 +				if (!(fib_flags & FIB_LOOKUP_NOREF))
 +					atomic_inc(&fi->fib_clntref);
 +
 +				res->prefixlen = li->plen;
 +				res->nh_sel = nhsel;
 +				res->type = fa->fa_type;
 +				res->scope = fi->fib_scope;
 +				res->fi = fi;
 +				res->table = tb;
 +				res->fa_head = &li->falh;
++=======
+ 			res->prefixlen = KEYLENGTH - fa->fa_slen;
+ 			res->nh_sel = nhsel;
+ 			res->type = fa->fa_type;
+ 			res->scope = fi->fib_scope;
+ 			res->fi = fi;
+ 			res->table = tb;
+ 			res->fa_head = &n->leaf;
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  #ifdef CONFIG_IP_FIB_TRIE_STATS
- 				this_cpu_inc(stats->semantic_match_passed);
+ 			this_cpu_inc(stats->semantic_match_passed);
  #endif
- 				return err;
- 			}
+ 			return err;
  		}
 -	}
 +
  #ifdef CONFIG_IP_FIB_TRIE_STATS
 -	this_cpu_inc(stats->semantic_match_miss);
 +		this_cpu_inc(stats->semantic_match_miss);
  #endif
 +	}
  	goto backtrace;
  }
  EXPORT_SYMBOL_GPL(fib_table_lookup);
@@@ -1488,15 -1424,14 +1584,18 @@@ static void trie_leaf_remove(struct tri
  int fib_table_delete(struct fib_table *tb, struct fib_config *cfg)
  {
  	struct trie *t = (struct trie *) tb->tb_data;
- 	u32 key, mask;
- 	int plen = cfg->fc_dst_len;
- 	u8 tos = cfg->fc_tos;
  	struct fib_alias *fa, *fa_to_delete;
++<<<<<<< HEAD
 +	struct list_head *fa_head;
++=======
+ 	u8 plen = cfg->fc_dst_len;
+ 	u8 tos = cfg->fc_tos;
+ 	u8 slen = KEYLENGTH - plen;
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  	struct tnode *l;
- 	struct leaf_info *li;
+ 	u32 key, mask;
  
- 	if (plen > 32)
+ 	if (plen > KEYLENGTH)
  		return -EINVAL;
  
  	key = ntohl(cfg->fc_dst);
@@@ -1525,11 -1452,10 +1616,11 @@@
  	pr_debug("Deleting %08x/%d tos=%d t=%p\n", key, plen, tos, t);
  
  	fa_to_delete = NULL;
 -	hlist_for_each_entry_from(fa, fa_list) {
 +	fa = list_entry(fa->fa_list.prev, struct fib_alias, fa_list);
 +	list_for_each_entry_continue(fa, fa_head, fa_list) {
  		struct fib_info *fi = fa->fa_info;
  
- 		if (fa->fa_tos != tos)
+ 		if ((fa->fa_slen != slen) || (fa->fa_tos != tos))
  			break;
  
  		if ((!cfg->fc_type || fa->fa_type == cfg->fc_type) &&
@@@ -1552,17 -1478,12 +1643,25 @@@
  	rtmsg_fib(RTM_DELROUTE, htonl(key), fa, plen, tb->tb_id,
  		  &cfg->fc_nlinfo, 0);
  
++<<<<<<< HEAD
 +	list_del_rcu(&fa->fa_list);
++=======
+ 	fib_remove_alias(l, fa);
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  
  	if (!plen)
  		tb->tb_num_default--;
  
++<<<<<<< HEAD
 +	if (list_empty(fa_head)) {
 +		remove_leaf_info(l, li);
 +		free_leaf_info(li);
 +	}
 +
 +	if (hlist_empty(&l->list))
++=======
+ 	if (hlist_empty(&l->leaf))
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  		trie_leaf_remove(t, l);
  
  	if (fa->fa_state & FA_S_ACCESSED)
@@@ -1573,12 -1494,14 +1672,23 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int trie_flush_list(struct list_head *head)
 +{
 +	struct fib_alias *fa, *fa_node;
 +	int found = 0;
 +
 +	list_for_each_entry_safe(fa, fa_node, head, fa_list) {
++=======
+ static int trie_flush_leaf(struct tnode *l)
+ {
+ 	struct hlist_node *tmp;
+ 	unsigned char slen = 0;
+ 	struct fib_alias *fa;
+ 	int found = 0;
+ 
+ 	hlist_for_each_entry_safe(fa, tmp, &l->leaf, fa_list) {
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  		struct fib_info *fi = fa->fa_info;
  
  		if (fi && (fi->fib_flags & RTNH_F_DEAD)) {
@@@ -1586,32 -1509,14 +1696,35 @@@
  			fib_release_info(fa->fa_info);
  			alias_free_mem_rcu(fa);
  			found++;
- 		}
- 	}
- 	return found;
- }
  
++<<<<<<< HEAD
 +static int trie_flush_leaf(struct tnode *l)
 +{
 +	int found = 0;
 +	struct hlist_head *lih = &l->list;
 +	struct hlist_node *tmp;
 +	struct leaf_info *li = NULL;
 +	unsigned char plen = KEYLENGTH;
 +
 +	hlist_for_each_entry_safe(li, tmp, lih, hlist) {
 +		found += trie_flush_list(&li->falh);
 +
 +		if (list_empty(&li->falh)) {
 +			hlist_del_rcu(&li->hlist);
 +			free_leaf_info(li);
 +			continue;
 +		}
 +
 +		plen = li->plen;
++=======
+ 			continue;
+ 		}
+ 
+ 		slen = fa->fa_slen;
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  	}
  
 -	l->slen = slen;
 +	l->slen = KEYLENGTH - plen;
  
  	return found;
  }
@@@ -1722,20 -1626,18 +1834,29 @@@ void fib_free_table(struct fib_table *t
  	kfree(tb);
  }
  
++<<<<<<< HEAD
 +static int fn_trie_dump_fa(t_key key, int plen, struct list_head *fah,
 +			   struct fib_table *tb,
 +			   struct sk_buff *skb, struct netlink_callback *cb)
++=======
+ static int fn_trie_dump_leaf(struct tnode *l, struct fib_table *tb,
+ 			     struct sk_buff *skb, struct netlink_callback *cb)
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  {
- 	int i, s_i;
+ 	__be32 xkey = htonl(l->key);
  	struct fib_alias *fa;
- 	__be32 xkey = htonl(key);
+ 	int i, s_i;
  
- 	s_i = cb->args[5];
+ 	s_i = cb->args[4];
  	i = 0;
  
  	/* rcu_read_lock is hold by caller */
++<<<<<<< HEAD
 +
 +	list_for_each_entry_rcu(fa, fah, fa_list) {
++=======
+ 	hlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  		if (i < s_i) {
  			i++;
  			continue;
@@@ -1747,41 -1649,9 +1868,44 @@@
  				  tb->tb_id,
  				  fa->fa_type,
  				  xkey,
 -				  KEYLENGTH - fa->fa_slen,
 +				  plen,
  				  fa->fa_tos,
  				  fa->fa_info, NLM_F_MULTI) < 0) {
++<<<<<<< HEAD
 +			cb->args[5] = i;
 +			return -1;
 +		}
 +		i++;
 +	}
 +	cb->args[5] = i;
 +	return skb->len;
 +}
 +
 +static int fn_trie_dump_leaf(struct tnode *l, struct fib_table *tb,
 +			struct sk_buff *skb, struct netlink_callback *cb)
 +{
 +	struct leaf_info *li;
 +	int i, s_i;
 +
 +	s_i = cb->args[4];
 +	i = 0;
 +
 +	/* rcu_read_lock is hold by caller */
 +	hlist_for_each_entry_rcu(li, &l->list, hlist) {
 +		if (i < s_i) {
 +			i++;
 +			continue;
 +		}
 +
 +		if (i > s_i)
 +			cb->args[5] = 0;
 +
 +		if (list_empty(&li->falh))
 +			continue;
 +
 +		if (fn_trie_dump_fa(l->key, li->plen, &li->falh, tb, skb, cb) < 0) {
++=======
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  			cb->args[4] = i;
  			return -1;
  		}
@@@ -2260,22 -2129,19 +2383,35 @@@ static int fib_trie_seq_show(struct seq
  		seq_indent(seq, iter->depth);
  		seq_printf(seq, "  |-- %pI4\n", &val);
  
- 		hlist_for_each_entry_rcu(li, &n->list, hlist) {
- 			struct fib_alias *fa;
+ 		hlist_for_each_entry_rcu(fa, &n->leaf, fa_list) {
+ 			char buf1[32], buf2[32];
  
++<<<<<<< HEAD
 +			list_for_each_entry_rcu(fa, &li->falh, fa_list) {
 +				char buf1[32], buf2[32];
 +
 +				seq_indent(seq, iter->depth+1);
 +				seq_printf(seq, "  /%d %s %s", li->plen,
 +					   rtn_scope(buf1, sizeof(buf1),
 +						     fa->fa_info->fib_scope),
 +					   rtn_type(buf2, sizeof(buf2),
 +						    fa->fa_type));
 +				if (fa->fa_tos)
 +					seq_printf(seq, " tos=%d", fa->fa_tos);
 +				seq_putc(seq, '\n');
 +			}
++=======
+ 			seq_indent(seq, iter->depth + 1);
+ 			seq_printf(seq, "  /%zu %s %s",
+ 				   KEYLENGTH - fa->fa_slen,
+ 				   rtn_scope(buf1, sizeof(buf1),
+ 					     fa->fa_info->fib_scope),
+ 				   rtn_type(buf2, sizeof(buf2),
+ 					    fa->fa_type));
+ 			if (fa->fa_tos)
+ 				seq_printf(seq, " tos=%d", fa->fa_tos);
+ 			seq_putc(seq, '\n');
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  		}
  	}
  
@@@ -2403,8 -2269,9 +2539,13 @@@ static unsigned int fib_flag_trans(int 
   */
  static int fib_route_seq_show(struct seq_file *seq, void *v)
  {
+ 	struct fib_alias *fa;
  	struct tnode *l = v;
++<<<<<<< HEAD
 +	struct leaf_info *li;
++=======
+ 	__be32 prefix;
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  
  	if (v == SEQ_START_TOKEN) {
  		seq_printf(seq, "%-127s\n", "Iface\tDestination\tGateway "
@@@ -2413,44 -2280,40 +2554,79 @@@
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(li, &l->list, hlist) {
 +		struct fib_alias *fa;
 +		__be32 mask, prefix;
 +
 +		mask = inet_make_mask(li->plen);
 +		prefix = htonl(l->key);
 +
 +		list_for_each_entry_rcu(fa, &li->falh, fa_list) {
 +			const struct fib_info *fi = fa->fa_info;
 +			unsigned int flags = fib_flag_trans(fa->fa_type, mask, fi);
 +			int len;
++=======
+ 	prefix = htonl(l->key);
  
- 			if (fa->fa_type == RTN_BROADCAST
- 			    || fa->fa_type == RTN_MULTICAST)
- 				continue;
+ 	hlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {
+ 		const struct fib_info *fi = fa->fa_info;
+ 		__be32 mask = inet_make_mask(KEYLENGTH - fa->fa_slen);
+ 		unsigned int flags = fib_flag_trans(fa->fa_type, mask, fi);
+ 
+ 		if ((fa->fa_type == RTN_BROADCAST) ||
+ 		    (fa->fa_type == RTN_MULTICAST))
+ 			continue;
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
+ 
+ 		seq_setwidth(seq, 127);
  
++<<<<<<< HEAD
 +			if (fi)
 +				seq_printf(seq,
 +					 "%s\t%08X\t%08X\t%04X\t%d\t%u\t"
 +					 "%d\t%08X\t%d\t%u\t%u%n",
 +					 fi->fib_dev ? fi->fib_dev->name : "*",
 +					 prefix,
 +					 fi->fib_nh->nh_gw, flags, 0, 0,
 +					 fi->fib_priority,
 +					 mask,
 +					 (fi->fib_advmss ?
 +					  fi->fib_advmss + 40 : 0),
 +					 fi->fib_window,
 +					 fi->fib_rtt >> 3, &len);
 +			else
 +				seq_printf(seq,
 +					 "*\t%08X\t%08X\t%04X\t%d\t%u\t"
 +					 "%d\t%08X\t%d\t%u\t%u%n",
 +					 prefix, 0, flags, 0, 0, 0,
 +					 mask, 0, 0, 0, &len);
 +
 +			seq_printf(seq, "%*s\n", 127 - len, "");
 +		}
++=======
+ 		if (fi)
+ 			seq_printf(seq,
+ 				   "%s\t%08X\t%08X\t%04X\t%d\t%u\t"
+ 				   "%d\t%08X\t%d\t%u\t%u",
+ 				   fi->fib_dev ? fi->fib_dev->name : "*",
+ 				   prefix,
+ 				   fi->fib_nh->nh_gw, flags, 0, 0,
+ 				   fi->fib_priority,
+ 				   mask,
+ 				   (fi->fib_advmss ?
+ 				    fi->fib_advmss + 40 : 0),
+ 				   fi->fib_window,
+ 				   fi->fib_rtt >> 3);
+ 		else
+ 			seq_printf(seq,
+ 				   "*\t%08X\t%08X\t%04X\t%d\t%u\t"
+ 				   "%d\t%08X\t%d\t%u\t%u",
+ 				   prefix, 0, flags, 0, 0, 0,
+ 				   mask, 0, 0, 0);
+ 
+ 		seq_pad(seq, '\n');
++>>>>>>> 79e5ad2ceb00 (fib_trie: Remove leaf_info)
  	}
  
  	return 0;
* Unmerged path net/ipv4/fib_trie.c
