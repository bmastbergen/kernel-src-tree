bonding: trivial: rename slave->jiffies to ->last_link_up

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@redhat.com>
commit 8e603460fa388c89f08e359366ec9398971cf49c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8e603460.failed

slave->jiffies is updated every time the slave becomes active, which, for
bonding, means that its link is 'up'.

CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8e603460fa388c89f08e359366ec9398971cf49c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index 1769905a03a5,f6d56d911a86..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -1737,10 -1444,10 +1737,10 @@@ int bond_enslave(struct net_device *bon
  	}
  
  	if (new_slave->link != BOND_LINK_DOWN)
- 		new_slave->jiffies = jiffies;
+ 		new_slave->last_link_up = jiffies;
  	pr_debug("Initial state of slave_dev is BOND_LINK_%s\n",
 -		 new_slave->link == BOND_LINK_DOWN ? "DOWN" :
 -		 (new_slave->link == BOND_LINK_UP ? "UP" : "BACK"));
 +		new_slave->link == BOND_LINK_DOWN ? "DOWN" :
 +			(new_slave->link == BOND_LINK_UP ? "UP" : "BACK"));
  
  	if (USES_PRIMARY(bond->params.mode) && bond->params.primary[0]) {
  		/* if there is a primary slave, remember it */
@@@ -2197,8 -1891,8 +2197,13 @@@ static int bond_miimon_inspect(struct b
  				 * recovered before downdelay expired
  				 */
  				slave->link = BOND_LINK_UP;
++<<<<<<< HEAD
 +				slave->jiffies = jiffies;
 +				pr_info("%s: link status up again after %d ms for interface %s.\n",
++=======
+ 				slave->last_link_up = jiffies;
+ 				pr_info("%s: link status up again after %d ms for interface %s\n",
++>>>>>>> 8e603460fa38 (bonding: trivial: rename slave->jiffies to ->last_link_up)
  					bond->dev->name,
  					(bond->params.downdelay - slave->delay) *
  					bond->params.miimon,
@@@ -2643,24 -2347,20 +2648,24 @@@ void bond_loadbalance_arp_mon(struct wo
  	struct bonding *bond = container_of(work, struct bonding,
  					    arp_work.work);
  	struct slave *slave, *oldcurrent;
 -	struct list_head *iter;
 -	int do_failover = 0, slave_state_changed = 0;
 +	int do_failover = 0;
 +	int delta_in_ticks, extra_ticks;
 +	int i;
  
 -	if (!bond_has_slaves(bond))
 -		goto re_arm;
 +	read_lock(&bond->lock);
  
 -	rcu_read_lock();
 +	delta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);
 +	extra_ticks = delta_in_ticks / 2;
 +
 +	if (bond->slave_cnt == 0)
 +		goto re_arm;
  
 -	oldcurrent = ACCESS_ONCE(bond->curr_active_slave);
 +	oldcurrent = bond->curr_active_slave;
  	/* see if any of the previous devices are up now (i.e. they have
  	 * xmt and rcv traffic). the curr_active_slave does not come into
- 	 * the picture unless it is null. also, slave->jiffies is not needed
- 	 * here because we send an arp on each slave and give a slave as
- 	 * long as it needs to get the tx/rx within the delta.
+ 	 * the picture unless it is null. also, slave->last_link_up is not
+ 	 * needed here because we send an arp on each slave and give a slave
+ 	 * as long as it needs to get the tx/rx within the delta.
  	 * TODO: what about up/down delay in arp mode? it wasn't here before
  	 *       so it can wait
  	 */
@@@ -2793,9 -2486,7 +2798,13 @@@ static int bond_ab_arp_inspect(struct b
  		 * active.  This avoids bouncing, as the last receive
  		 * times need a full ARP monitor cycle to be updated.
  		 */
++<<<<<<< HEAD
 +		if (time_in_range(jiffies,
 +				  slave->jiffies - delta_in_ticks,
 +				  slave->jiffies + 2 * delta_in_ticks + extra_ticks))
++=======
+ 		if (bond_time_in_interval(bond, slave->last_link_up, 2))
++>>>>>>> 8e603460fa38 (bonding: trivial: rename slave->jiffies to ->last_link_up)
  			continue;
  
  		/*
@@@ -2985,13 -2669,32 +2994,33 @@@ static void bond_ab_arp_probe(struct bo
  
  			bond_set_slave_inactive_flags(slave);
  
 -			pr_info("%s: backup interface %s is now down\n",
 +			pr_info("%s: backup interface %s is now down.\n",
  				bond->dev->name, slave->dev->name);
  		}
 -		if (slave == curr_arp_slave)
 -			found = true;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (!new_slave && before)
+ 		new_slave = before;
+ 
+ 	if (!new_slave) {
+ 		rtnl_unlock();
+ 		return true;
+ 	}
+ 
+ 	new_slave->link = BOND_LINK_BACK;
+ 	bond_set_slave_active_flags(new_slave);
+ 	bond_arp_send_all(bond, new_slave);
+ 	new_slave->last_link_up = jiffies;
+ 	rcu_assign_pointer(bond->current_arp_slave, new_slave);
+ 	rtnl_unlock();
+ 
+ 	return true;
++>>>>>>> 8e603460fa38 (bonding: trivial: rename slave->jiffies to ->last_link_up)
  }
  
 -static void bond_activebackup_arp_mon(struct work_struct *work)
 +void bond_activebackup_arp_mon(struct work_struct *work)
  {
  	struct bonding *bond = container_of(work, struct bonding,
  					    arp_work.work);
* Unmerged path drivers/net/bonding/bond_main.c
diff --git a/drivers/net/bonding/bonding.h b/drivers/net/bonding/bonding.h
index e1ca02f0b074..fb4d68508a5e 100644
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@ -179,7 +179,8 @@ struct slave {
 	struct slave *prev;
 	struct bonding *bond; /* our master */
 	int    delay;
-	unsigned long jiffies;
+	/* all three in jiffies */
+	unsigned long last_link_up;
 	unsigned long last_arp_rx;
 	unsigned long target_last_arp_rx[BOND_MAX_ARP_TARGETS];
 	s8     link;    /* one of BOND_LINK_XXXX */
