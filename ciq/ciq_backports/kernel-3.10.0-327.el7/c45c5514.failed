KVM: PPC: Use kvm_read_guest in kvmppc_ld

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kvm] ppc: Use kvm_read_guest in kvmppc_ld (Thomas Huth) [1226884 1227323]
Rebuild_FUZZ: 93.51%
commit-author Alexander Graf <agraf@suse.de>
commit c45c551403f0a7b152e56c53735b954faa36c54c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c45c5514.failed

We have a nice and handy helper to read from guest physical address space,
so we should make use of it in kvmppc_ld as we already do for its counterpart
in kvmppc_st.

	Signed-off-by: Alexander Graf <agraf@suse.de>
(cherry picked from commit c45c551403f0a7b152e56c53735b954faa36c54c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/powerpc.c
diff --cc arch/powerpc/kvm/powerpc.c
index bf2571061516,be40886e8f0a..000000000000
--- a/arch/powerpc/kvm/powerpc.c
+++ b/arch/powerpc/kvm/powerpc.c
@@@ -310,6 -309,59 +310,62 @@@ int kvmppc_emulate_mmio(struct kvm_run 
  }
  EXPORT_SYMBOL_GPL(kvmppc_emulate_mmio);
  
++<<<<<<< HEAD
++=======
+ int kvmppc_st(struct kvm_vcpu *vcpu, ulong *eaddr, int size, void *ptr,
+ 	      bool data)
+ {
+ 	struct kvmppc_pte pte;
+ 	int r;
+ 
+ 	vcpu->stat.st++;
+ 
+ 	r = kvmppc_xlate(vcpu, *eaddr, data ? XLATE_DATA : XLATE_INST,
+ 			 XLATE_WRITE, &pte);
+ 	if (r < 0)
+ 		return r;
+ 
+ 	*eaddr = pte.raddr;
+ 
+ 	if (!pte.may_write)
+ 		return -EPERM;
+ 
+ 	if (kvm_write_guest(vcpu->kvm, pte.raddr, ptr, size))
+ 		return EMULATE_DO_MMIO;
+ 
+ 	return EMULATE_DONE;
+ }
+ EXPORT_SYMBOL_GPL(kvmppc_st);
+ 
+ int kvmppc_ld(struct kvm_vcpu *vcpu, ulong *eaddr, int size, void *ptr,
+ 		      bool data)
+ {
+ 	struct kvmppc_pte pte;
+ 	int rc;
+ 
+ 	vcpu->stat.ld++;
+ 
+ 	rc = kvmppc_xlate(vcpu, *eaddr, data ? XLATE_DATA : XLATE_INST,
+ 			  XLATE_READ, &pte);
+ 	if (rc)
+ 		return rc;
+ 
+ 	*eaddr = pte.raddr;
+ 
+ 	if (!pte.may_read)
+ 		return -EPERM;
+ 
+ 	if (!data && !pte.may_execute)
+ 		return -ENOEXEC;
+ 
+ 	if (kvm_read_guest(vcpu->kvm, pte.raddr, ptr, size))
+ 		return EMULATE_DO_MMIO;
+ 
+ 	return EMULATE_DONE;
+ }
+ EXPORT_SYMBOL_GPL(kvmppc_ld);
+ 
++>>>>>>> c45c551403f0 (KVM: PPC: Use kvm_read_guest in kvmppc_ld)
  int kvm_arch_hardware_enable(void *garbage)
  {
  	return 0;
* Unmerged path arch/powerpc/kvm/powerpc.c
