Bluetooth: don't release the port in rfcomm_dev_state_change()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [bluetooth] don't release the port in rfcomm_dev_state_change() (Lubomir Rintel) [1241844]
Rebuild_FUZZ: 90.27%
commit-author Gianluca Anzolin <gianluca@sottospazio.it>
commit 29cd718beba999bda4bdbbf59b5a4d25c07e1547
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/29cd718b.failed

When the dlc is closed, rfcomm_dev_state_change() tries to release the
port in the case it cannot get a reference to the tty. However this is
racy and not even needed.

Infact as Peter Hurley points out:

1. Only consider dlcs that are 'stolen' from a connected socket, ie.
   reused. Allocated dlcs cannot have been closed prior to port
   activate and so for these dlcs a tty reference will always be avail
   in rfcomm_dev_state_change() -- except for the conditions covered by
   #2b below.
2. If a tty was at some point previously created for this rfcomm, then
   either
   (a) the tty reference is still avail, so rfcomm_dev_state_change()
       will perform a hangup. So nothing to do, or,
   (b) the tty reference is no longer avail, and the tty_port will be
       destroyed by the last tty_port_put() in rfcomm_tty_cleanup.
       Again, no action required.
3. Prior to obtaining the dlc lock in rfcomm_dev_add(),
   rfcomm_dev_state_change() will not 'see' a rfcomm_dev so nothing to
   do here.
4. After releasing the dlc lock in rfcomm_dev_add(),
   rfcomm_dev_state_change() will 'see' an incomplete rfcomm_dev if a
   tty reference could not be obtained. Again, the best thing to do here
   is nothing. Any future attempted open() will block on
   rfcomm_dev_carrier_raised(). The unconnected device will exist until
   released by ioctl(RFCOMMRELEASEDEV).

The patch removes the aforementioned code and uses the
tty_port_tty_hangup() helper to hangup the tty.

	Signed-off-by: Gianluca Anzolin <gianluca@sottospazio.it>
	Reviewed-by: Peter Hurley <peter@hurleysoftware.com>
	Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
(cherry picked from commit 29cd718beba999bda4bdbbf59b5a4d25c07e1547)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/rfcomm/tty.c
diff --cc net/bluetooth/rfcomm/tty.c
index 62bd75eda078,84fcf9fff3ea..000000000000
--- a/net/bluetooth/rfcomm/tty.c
+++ b/net/bluetooth/rfcomm/tty.c
@@@ -559,31 -575,13 +559,37 @@@ static void rfcomm_dev_state_change(str
  	BT_DBG("dlc %p dev %p err %d", dlc, dev, err);
  
  	dev->err = err;
 -	if (dlc->state == BT_CONNECTED) {
 -		device_move(dev->tty_dev, rfcomm_get_device(dev),
 -			    DPM_ORDER_DEV_AFTER_PARENT);
 -
 +	wake_up_interruptible(&dev->wait);
 +
++<<<<<<< HEAD
 +	if (dlc->state == BT_CLOSED) {
 +		if (!dev->port.tty) {
 +			if (test_bit(RFCOMM_RELEASE_ONHUP, &dev->flags)) {
 +				/* Drop DLC lock here to avoid deadlock
 +				 * 1. rfcomm_dev_get will take rfcomm_dev_lock
 +				 *    but in rfcomm_dev_add there's lock order:
 +				 *    rfcomm_dev_lock -> dlc lock
 +				 * 2. tty_port_put will deadlock if it's
 +				 *    the last reference
 +				 */
 +				rfcomm_dlc_unlock(dlc);
 +				if (rfcomm_dev_get(dev->id) == NULL) {
 +					rfcomm_dlc_lock(dlc);
 +					return;
 +				}
 +
 +				rfcomm_dev_del(dev);
 +				tty_port_put(&dev->port);
 +				rfcomm_dlc_lock(dlc);
 +			}
 +		} else
 +			tty_hangup(dev->port.tty);
 +	}
++=======
+ 		wake_up_interruptible(&dev->port.open_wait);
+ 	} else if (dlc->state == BT_CLOSED)
+ 		tty_port_tty_hangup(&dev->port, false);
++>>>>>>> 29cd718beba9 (Bluetooth: don't release the port in rfcomm_dev_state_change())
  }
  
  static void rfcomm_dev_modem_status(struct rfcomm_dlc *dlc, u8 v24_sig)
* Unmerged path net/bluetooth/rfcomm/tty.c
