i40e: Communicate VSI id in place of VSI index to the VFs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Anjali Singhai Jain <anjali.singhai@intel.com>
commit fdf0e0bfc363a9b5380ecb5e9c46d6f5a39a9b75
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/fdf0e0bf.failed

This does not affect the Virtual channel API as such but it changes the
meaning of what is communicated to the VSI resource struct as vsi_id.
Earlier vsi_idx was being passed in, which was the index in the PF's VSI
array. Now we pass vsi_id as communicated by the FW to the driver.
This will help with future expansion of VF and FW communication.

With this in place now the VF and Virtual channel driver change to move over
to VSI id use is complete and is validated.

Change-ID: I14246ef82b3b3dc1fa76291d2dd0c05d12cedb7c
	Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
	Tested-by: Jim Young <james.m.young@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit fdf0e0bfc363a9b5380ecb5e9c46d6f5a39a9b75)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
index 7302589acecb,4d69e1f04901..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
@@@ -48,18 -48,17 +48,17 @@@ static inline void i40e_vc_disable_vf(s
  
  /**
   * i40e_vc_isvalid_vsi_id
 - * @vf: pointer to the VF info
 - * @vsi_id: VF relative VSI id
 + * @vf: pointer to the vf info
 + * @vsi_id: vf relative vsi id
   *
 - * check for the valid VSI id
 + * check for the valid vsi id
   **/
- static inline bool i40e_vc_isvalid_vsi_id(struct i40e_vf *vf, u8 vsi_id)
+ static inline bool i40e_vc_isvalid_vsi_id(struct i40e_vf *vf, u16 vsi_id)
  {
  	struct i40e_pf *pf = vf->pf;
+ 	struct i40e_vsi *vsi = i40e_find_vsi_from_id(pf, vsi_id);
  
- 	if (vsi_id > pf->num_alloc_vsi)
- 		return false;
- 	return pf->vsi[vsi_id]->vf_id == vf->vf_id;
+ 	return (vsi && (vsi->vf_id == vf->vf_id));
  }
  
  /**
@@@ -96,13 -96,13 +96,18 @@@ static inline bool i40e_vc_isvalid_vect
  
  /**
   * i40e_vc_get_pf_queue_id
++<<<<<<< HEAD
 + * @vf: pointer to the vf info
 + * @vsi_idx: index of VSI in PF struct
++=======
+  * @vf: pointer to the VF info
+  * @vsi_id: id of VSI as provided by the FW
++>>>>>>> fdf0e0bfc363 (i40e: Communicate VSI id in place of VSI index to the VFs)
   * @vsi_queue_id: vsi relative queue id
   *
 - * return PF relative queue id
 + * return pf relative queue id
   **/
- static u16 i40e_vc_get_pf_queue_id(struct i40e_vf *vf, u8 vsi_idx,
+ static u16 i40e_vc_get_pf_queue_id(struct i40e_vf *vf, u16 vsi_id,
  				   u8 vsi_queue_id)
  {
  	struct i40e_pf *pf = vf->pf;
@@@ -122,8 -125,8 +130,13 @@@
  
  /**
   * i40e_config_irq_link_list
++<<<<<<< HEAD
 + * @vf: pointer to the vf info
 + * @vsi_idx: index of VSI in PF struct
++=======
+  * @vf: pointer to the VF info
+  * @vsi_id: id of VSI as given by the FW
++>>>>>>> fdf0e0bfc363 (i40e: Communicate VSI id in place of VSI index to the VFs)
   * @vecmap: irq map info
   *
   * configure irq link list from the map
@@@ -222,8 -225,8 +235,13 @@@ irq_list_done
  
  /**
   * i40e_config_vsi_tx_queue
++<<<<<<< HEAD
 + * @vf: pointer to the vf info
 + * @vsi_idx: index of VSI in PF struct
++=======
+  * @vf: pointer to the VF info
+  * @vsi_id: id of VSI as provided by the FW
++>>>>>>> fdf0e0bfc363 (i40e: Communicate VSI id in place of VSI index to the VFs)
   * @vsi_queue_id: vsi relative queue index
   * @info: config. info
   *
@@@ -289,8 -294,8 +309,13 @@@ error_context
  
  /**
   * i40e_config_vsi_rx_queue
++<<<<<<< HEAD
 + * @vf: pointer to the vf info
 + * @vsi_idx: index of VSI in PF struct
++=======
+  * @vf: pointer to the VF info
+  * @vsi_id: id of VSI  as provided by the FW
++>>>>>>> fdf0e0bfc363 (i40e: Communicate VSI id in place of VSI index to the VFs)
   * @vsi_queue_id: vsi relative queue index
   * @info: config. info
   *
@@@ -694,12 -699,12 +719,12 @@@ void i40e_reset_vf(struct i40e_vf *vf, 
  	wr32(hw, I40E_VPGEN_VFRTRIG(vf->vf_id), reg);
  
  	/* On initial reset, we won't have any queues */
- 	if (vf->lan_vsi_index == 0)
+ 	if (vf->lan_vsi_idx == 0)
  		goto complete_reset;
  
- 	i40e_vsi_control_rings(pf->vsi[vf->lan_vsi_index], false);
+ 	i40e_vsi_control_rings(pf->vsi[vf->lan_vsi_idx], false);
  complete_reset:
 -	/* reallocate VF resources to reset the VSI state */
 +	/* reallocate vf resources to reset the VSI state */
  	i40e_free_vf_res(vf);
  	i40e_alloc_vf_res(vf);
  	i40e_enable_vf_mappings(vf);
@@@ -1149,11 -1154,11 +1174,16 @@@ static int i40e_vc_config_queues_msg(st
  			goto error_param;
  		}
  	}
++<<<<<<< HEAD
 +	/* set vsi num_queue_pairs in use to num configured by vf */
 +	pf->vsi[vf->lan_vsi_index]->num_queue_pairs = qci->num_queue_pairs;
++=======
+ 	/* set vsi num_queue_pairs in use to num configured by VF */
+ 	pf->vsi[vf->lan_vsi_idx]->num_queue_pairs = qci->num_queue_pairs;
++>>>>>>> fdf0e0bfc363 (i40e: Communicate VSI id in place of VSI index to the VFs)
  
  error_param:
 -	/* send the response to the VF */
 +	/* send the response to the vf */
  	return i40e_vc_send_resp_to_vf(vf, I40E_VIRTCHNL_OP_CONFIG_VSI_QUEUES,
  				       aq_ret);
  }
@@@ -1251,10 -1256,11 +1281,11 @@@ static int i40e_vc_enable_queues_msg(st
  		aq_ret = I40E_ERR_PARAM;
  		goto error_param;
  	}
- 	if (i40e_vsi_control_rings(pf->vsi[vsi_id], true))
+ 
+ 	if (i40e_vsi_control_rings(pf->vsi[vf->lan_vsi_idx], true))
  		aq_ret = I40E_ERR_TIMEOUT;
  error_param:
 -	/* send the response to the VF */
 +	/* send the response to the vf */
  	return i40e_vc_send_resp_to_vf(vf, I40E_VIRTCHNL_OP_ENABLE_QUEUES,
  				       aq_ret);
  }
@@@ -2145,8 -2152,14 +2176,8 @@@ int i40e_ndo_set_vf_bw(struct net_devic
  		goto error;
  	}
  
 -	if (min_tx_rate) {
 -		dev_err(&pf->pdev->dev, "Invalid min tx rate (%d) (greater than 0) specified for VF %d.\n",
 -			min_tx_rate, vf_id);
 -		return -EINVAL;
 -	}
 -
  	vf = &(pf->vf[vf_id]);
- 	vsi = pf->vsi[vf->lan_vsi_index];
+ 	vsi = pf->vsi[vf->lan_vsi_idx];
  	if (!test_bit(I40E_VF_STAT_INIT, &vf->vf_states)) {
  		dev_err(&pf->pdev->dev, "Uninitialized VF %d.\n", vf_id);
  		ret = -EINVAL;
diff --git a/drivers/net/ethernet/intel/i40e/i40e.h b/drivers/net/ethernet/intel/i40e/i40e.h
index 3753b38a70e0..85b33b2e795a 100644
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -626,6 +626,7 @@ extern const char i40e_driver_name[];
 extern const char i40e_driver_version_str[];
 void i40e_do_reset_safe(struct i40e_pf *pf, u32 reset_flags);
 void i40e_do_reset(struct i40e_pf *pf, u32 reset_flags);
+struct i40e_vsi *i40e_find_vsi_from_id(struct i40e_pf *pf, u16 id);
 void i40e_update_stats(struct i40e_vsi *vsi);
 void i40e_update_eth_stats(struct i40e_vsi *vsi);
 struct rtnl_link_stats64 *i40e_get_vsi_stats_struct(struct i40e_vsi *vsi);
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index 2fa52cd642ec..c21d0a09c0f3 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -248,6 +248,22 @@ static int i40e_put_lump(struct i40e_lump_tracking *pile, u16 index, u16 id)
 	return count;
 }
 
+/**
+ * i40e_find_vsi_from_id - searches for the vsi with the given id
+ * @pf - the pf structure to search for the vsi
+ * @id - id of the vsi it is searching for
+ **/
+struct i40e_vsi *i40e_find_vsi_from_id(struct i40e_pf *pf, u16 id)
+{
+	int i;
+
+	for (i = 0; i < pf->num_alloc_vsi; i++)
+		if (pf->vsi[i] && (pf->vsi[i]->id == id))
+			return pf->vsi[i];
+
+	return NULL;
+}
+
 /**
  * i40e_service_event_schedule - Schedule the service task to wake up
  * @pf: board private structure
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
index 15f04db7c1f6..64015bdb4224 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_virtchnl_pf.h
@@ -88,7 +88,7 @@ struct i40e_vf {
 	 * When assigned, these will be non-zero, because VSI 0 is always
 	 * the main LAN VSI for the PF.
 	 */
-	u8 lan_vsi_index;	/* index into PF struct */
+	u8 lan_vsi_idx;	        /* index into PF struct */
 	u8 lan_vsi_id;		/* ID as used by firmware */
 
 	u8 num_queue_pairs;	/* num of qps assigned to vf vsis */
