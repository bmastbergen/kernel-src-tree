Use 'E' instead of 'X' for unsigned module taint flag.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kernel] Use 'E' instead of 'X' for unsigned module taint flag (Jiri Olsa) [1179759]
Rebuild_FUZZ: 99.07%
commit-author Rusty Russell <rusty@rustcorp.com.au>
commit 57673c2b0baa900dddae3b9eb3d7748ebf550eb3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/57673c2b.failed

Takashi Iwai <tiwai@suse.de> says:
> The letter 'X' has been already used for SUSE kernels for very long
> time, to indicate the external supported modules.  Can the new flag be
> changed to another letter for avoiding conflict...?
> (BTW, we also use 'N' for "no support", too.)

Note: this code should be cleaned up, so we don't have such maps in
three places!

	Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
(cherry picked from commit 57673c2b0baa900dddae3b9eb3d7748ebf550eb3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/ABI/testing/sysfs-module
#	Documentation/module-signing.txt
#	Documentation/oops-tracing.txt
#	kernel/module.c
#	kernel/panic.c
diff --cc Documentation/ABI/testing/sysfs-module
index 47064c2b1f79,0aac02e7fb0e..000000000000
--- a/Documentation/ABI/testing/sysfs-module
+++ b/Documentation/ABI/testing/sysfs-module
@@@ -49,3 -49,4 +49,7 @@@ Description:	Module taint flags
  			O - out-of-tree module
  			F - force-loaded module
  			C - staging driver module
++<<<<<<< HEAD
++=======
+ 			E - unsigned module
++>>>>>>> 57673c2b0baa (Use 'E' instead of 'X' for unsigned module taint flag.)
diff --cc Documentation/module-signing.txt
index 2fecf1324005,2429024c0749..000000000000
--- a/Documentation/module-signing.txt
+++ b/Documentation/module-signing.txt
@@@ -2,69 -2,212 +2,76 @@@
  			KERNEL MODULE SIGNING FACILITY
  			==============================
  
 -CONTENTS
 +The module signing facility applies cryptographic signature checking to modules
 +on module load, checking the signature against a ring of public keys compiled
 +into the kernel. Currently only RSA keys encoded as X.509 certificates are
 +supported by the module signature code.
  
 - - Overview.
 - - Configuring module signing.
 - - Generating signing keys.
 - - Public keys in the kernel.
 - - Manually signing modules.
 - - Signed modules and stripping.
 - - Loading signed modules.
 - - Non-valid signatures and unsigned modules.
 - - Administering/protecting the private key.
 +This facility is enabled through CONFIG_MODULE_SIG. Turning on signature
 +checking will also force the module's ELF metadata to be verified before the
 +signature is checked.
  
 +=====================
 +SUPPLYING PUBLIC KEYS
 +=====================
  
 -========
 -OVERVIEW
 -========
 +A set of public keys must be supplied at main kernel compile time. A file,
 +x509.genkey must be provided which is used to generate the X.509 keys. If
 +not provided, a default configuration will be provided. The Makefile target
 +"x509.genkey" will generate the example configuration which can be modified
 +in the top level of the kernel build.
  
 -The kernel module signing facility cryptographically signs modules during
 -installation and then checks the signature upon loading the module.  This
 -allows increased kernel security by disallowing the loading of unsigned modules
 -or modules signed with an invalid key.  Module signing increases security by
 -making it harder to load a malicious module into the kernel.  The module
 -signature checking is done by the kernel so that it is not necessary to have
 -trusted userspace bits.
 +From this, the private and public keys will be generated as ./signing_key.priv
 +and ./signing_key.x509 respectively during the kernel build process.
  
 -This facility uses X.509 ITU-T standard certificates to encode the public keys
 -involved.  The signatures are not themselves encoded in any industrial standard
 -type.  The facility currently only supports the RSA public key encryption
 -standard (though it is pluggable and permits others to be used).  The possible
 -hash algorithms that can be used are SHA-1, SHA-224, SHA-256, SHA-384, and
 -SHA-512 (the algorithm is selected by data in the signature).
 +The above generates fresh keys using /dev/random.  If there's insufficient data
 +in /dev/random, more can be provided more by running:
  
 +	rngd -r /dev/urandom
  
 -==========================
 -CONFIGURING MODULE SIGNING
 -==========================
 +in the background.
  
 -The module signing facility is enabled by going to the "Enable Loadable Module
 -Support" section of the kernel configuration and turning on
 +==============
 +MODULE SIGNING
 +==============
  
 -	CONFIG_MODULE_SIG	"Module signature verification"
 +If CONFIG_MODULE_SIG_ALL is set, all modules will be signed automatically. If
 +not, they can be signed manually using scripts/sign-file:
  
 -This has a number of options available:
 +	scripts/sign-file <hash algo> $(MODSECKEY) $(MODPUBKEY) module.ko
  
 - (1) "Require modules to be validly signed" (CONFIG_MODULE_SIG_FORCE)
 + (*) The hash algorithm must be one of sha1, sha224, sha256, sha384, sha512.
 +     The corresponding crypto algorithm must be enabled in the kernel.
 +     CONFIG_MODULE_SIG_HASH selects the default algorithm used by sign-file as
 +     part of the kernel build process.
  
 -     This specifies how the kernel should deal with a module that has a
 -     signature for which the key is not known or a module that is unsigned.
 + (*) MODSECKEY=<secret-key-ring-path>
  
++<<<<<<< HEAD
 +     This indicates the whereabouts of the keyring that is the source of
 +     the secret key to be used.  The default is "./signing_key.priv".
++=======
+      If this is off (ie. "permissive"), then modules for which the key is not
+      available and modules that are unsigned are permitted, but the kernel will
+      be marked as being tainted, and the concerned modules will be marked as
+      tainted, shown with the character 'E'.
++>>>>>>> 57673c2b0baa (Use 'E' instead of 'X' for unsigned module taint flag.)
  
 -     If this is on (ie. "restrictive"), only modules that have a valid
 -     signature that can be verified by a public key in the kernel's possession
 -     will be loaded.  All other modules will generate an error.
 + (*) MODPUBKEY=<public-key-ring-path>
  
 -     Irrespective of the setting here, if the module has a signature block that
 -     cannot be parsed, it will be rejected out of hand.
 +     This indicates the whereabouts of the keyring that is the source of
 +     the public key to be used.  The default is "./signing_key.x509".
  
 +The resulting module.ko file will be the signed module.
  
 - (2) "Automatically sign all modules" (CONFIG_MODULE_SIG_ALL)
 -
 -     If this is on then modules will be automatically signed during the
 -     modules_install phase of a build.  If this is off, then the modules must
 -     be signed manually using:
 -
 -	scripts/sign-file
 -
 -
 - (3) "Which hash algorithm should modules be signed with?"
 -
 -     This presents a choice of which hash algorithm the installation phase will
 -     sign the modules with:
 -
 -	CONFIG_SIG_SHA1		"Sign modules with SHA-1"
 -	CONFIG_SIG_SHA224	"Sign modules with SHA-224"
 -	CONFIG_SIG_SHA256	"Sign modules with SHA-256"
 -	CONFIG_SIG_SHA384	"Sign modules with SHA-384"
 -	CONFIG_SIG_SHA512	"Sign modules with SHA-512"
 -
 -     The algorithm selected here will also be built into the kernel (rather
 -     than being a module) so that modules signed with that algorithm can have
 -     their signatures checked without causing a dependency loop.
 -
 -
 -=======================
 -GENERATING SIGNING KEYS
 -=======================
 -
 -Cryptographic keypairs are required to generate and check signatures.  A
 -private key is used to generate a signature and the corresponding public key is
 -used to check it.  The private key is only needed during the build, after which
 -it can be deleted or stored securely.  The public key gets built into the
 -kernel so that it can be used to check the signatures as the modules are
 -loaded.
 -
 -Under normal conditions, the kernel build will automatically generate a new
 -keypair using openssl if one does not exist in the files:
 -
 -	signing_key.priv
 -	signing_key.x509
 -
 -during the building of vmlinux (the public part of the key needs to be built
 -into vmlinux) using parameters in the:
 -
 -	x509.genkey
 -
 -file (which is also generated if it does not already exist).
 -
 -It is strongly recommended that you provide your own x509.genkey file.
 -
 -Most notably, in the x509.genkey file, the req_distinguished_name section
 -should be altered from the default:
 -
 -	[ req_distinguished_name ]
 -	O = Magrathea
 -	CN = Glacier signing key
 -	emailAddress = slartibartfast@magrathea.h2g2
 -
 -The generated RSA key size can also be set with:
 -
 -	[ req ]
 -	default_bits = 4096
 -
 -
 -It is also possible to manually generate the key private/public files using the
 -x509.genkey key generation configuration file in the root node of the Linux
 -kernel sources tree and the openssl command.  The following is an example to
 -generate the public/private key files:
 -
 -	openssl req -new -nodes -utf8 -sha256 -days 36500 -batch -x509 \
 -	   -config x509.genkey -outform DER -out signing_key.x509 \
 -	   -keyout signing_key.priv
 -
 -
 -=========================
 -PUBLIC KEYS IN THE KERNEL
 -=========================
 -
 -The kernel contains a ring of public keys that can be viewed by root.  They're
 -in a keyring called ".system_keyring" that can be seen by:
 -
 -	[root@deneb ~]# cat /proc/keys
 -	...
 -	223c7853 I------     1 perm 1f030000     0     0 keyring   .system_keyring: 1
 -	302d2d52 I------     1 perm 1f010000     0     0 asymmetri Fedora kernel signing key: d69a84e6bce3d216b979e9505b3e3ef9a7118079: X509.RSA a7118079 []
 -	...
 -
 -Beyond the public key generated specifically for module signing, any file
 -placed in the kernel source root directory or the kernel build root directory
 -whose name is suffixed with ".x509" will be assumed to be an X.509 public key
 -and will be added to the keyring.
 -
 -Further, the architecture code may take public keys from a hardware store and
 -add those in also (e.g. from the UEFI key database).
 -
 -Finally, it is possible to add additional public keys by doing:
 -
 -	keyctl padd asymmetric "" [.system_keyring-ID] <[key-file]
 -
 -e.g.:
 -
 -	keyctl padd asymmetric "" 0x223c7853 <my_public_key.x509
 -
 -Note, however, that the kernel will only permit keys to be added to
 -.system_keyring _if_ the new key's X.509 wrapper is validly signed by a key
 -that is already resident in the .system_keyring at the time the key was added.
 -
 -
 -=========================
 -MANUALLY SIGNING MODULES
 -=========================
 -
 -To manually sign a module, use the scripts/sign-file tool available in
 -the Linux kernel source tree.  The script requires 4 arguments:
 -
 -	1.  The hash algorithm (e.g., sha256)
 -	2.  The private key filename
 -	3.  The public key filename
 -	4.  The kernel module to be signed
 -
 -The following is an example to sign a kernel module:
 -
 -	scripts/sign-file sha512 kernel-signkey.priv \
 -		kernel-signkey.x509 module.ko
 -
 -The hash algorithm used does not have to match the one configured, but if it
 -doesn't, you should make sure that hash algorithm is either built into the
 -kernel or can be loaded without requiring itself.
 -
 -
 -============================
 -SIGNED MODULES AND STRIPPING
 -============================
 -
 -A signed module has a digital signature simply appended at the end.  The string
 -"~Module signature appended~." at the end of the module's file confirms that a
 -signature is present but it does not confirm that the signature is valid!
 -
 -Signed modules are BRITTLE as the signature is outside of the defined ELF
 -container.  Thus they MAY NOT be stripped once the signature is computed and
 -attached.  Note the entire module is the signed payload, including any and all
 -debug information present at the time of signing.
 +========================
 +STRIPPING SIGNED MODULES
 +========================
  
 +Kernel modules must be stripped before they are signed, as stripping a signed
 +module will remove the appended signature. As a result, care must be taken
 +when packaging kernel modules for distribution that initrd generation avoids
 +stripping modules which have signatures.
  
  ======================
  LOADING SIGNED MODULES
diff --cc Documentation/oops-tracing.txt
index 13032c0140d4,e3155995ddd8..000000000000
--- a/Documentation/oops-tracing.txt
+++ b/Documentation/oops-tracing.txt
@@@ -265,6 -265,9 +265,12 @@@ characters, each representing a particu
  
   13: 'O' if an externally-built ("out-of-tree") module has been loaded.
  
++<<<<<<< HEAD
++=======
+  14: 'E' if an unsigned module has been loaded in a kernel supporting
+      module signature.
+ 
++>>>>>>> 57673c2b0baa (Use 'E' instead of 'X' for unsigned module taint flag.)
  The primary reason for the 'Tainted: ' string is to tell kernel
  debuggers if this is a clean kernel or if anything unusual has
  occurred.  Tainting is permanent: even if an offending module is
diff --cc kernel/module.c
index 1960a3030875,5806e096d110..000000000000
--- a/kernel/module.c
+++ b/kernel/module.c
@@@ -1122,6 -1013,8 +1122,11 @@@ static size_t module_flags_taint(struc
  		buf[l++] = 'F';
  	if (mod->taints & (1 << TAINT_CRAP))
  		buf[l++] = 'C';
++<<<<<<< HEAD
++=======
+ 	if (mod->taints & (1 << TAINT_UNSIGNED_MODULE))
+ 		buf[l++] = 'E';
++>>>>>>> 57673c2b0baa (Use 'E' instead of 'X' for unsigned module taint flag.)
  	/*
  	 * TAINT_FORCED_RMMOD: could be added.
  	 * TAINT_UNSAFE_SMP, TAINT_MACHINE_CHECK, TAINT_BAD_PAGE don't
diff --cc kernel/panic.c
index 68447f710f29,02b6c9f0171b..000000000000
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@@ -206,23 -210,7 +206,27 @@@ static const struct tnt tnts[] = 
  	{ TAINT_CRAP,			'C', ' ' },
  	{ TAINT_FIRMWARE_WORKAROUND,	'I', ' ' },
  	{ TAINT_OOT_MODULE,		'O', ' ' },
++<<<<<<< HEAD
 +	{ TAINT_14,			'?', '-' },
 +	{ TAINT_15,			'?', '-' },
 +	{ TAINT_16,			'?', '-' },
 +	{ TAINT_17,			'?', '-' },
 +	{ TAINT_18,			'?', '-' },
 +	{ TAINT_19,			'?', '-' },
 +	{ TAINT_20,			'?', '-' },
 +	{ TAINT_21,			'?', '-' },
 +	{ TAINT_22,			'?', '-' },
 +	{ TAINT_23,			'?', '-' },
 +	{ TAINT_24,			'?', '-' },
 +	{ TAINT_25,			'?', '-' },
 +	{ TAINT_26,			'?', '-' },
 +	{ TAINT_27,			'?', '-' },
 +	{ TAINT_HARDWARE_UNSUPPORTED,	'H', ' ' },
 +	{ TAINT_TECH_PREVIEW,		'T', ' ' },
 +
++=======
+ 	{ TAINT_UNSIGNED_MODULE,	'E', ' ' },
++>>>>>>> 57673c2b0baa (Use 'E' instead of 'X' for unsigned module taint flag.)
  };
  
  /**
@@@ -241,6 -229,7 +245,10 @@@
   *  'C' - modules from drivers/staging are loaded.
   *  'I' - Working around severe firmware bug.
   *  'O' - Out-of-tree module has been loaded.
++<<<<<<< HEAD
++=======
+  *  'E' - Unsigned module has been loaded.
++>>>>>>> 57673c2b0baa (Use 'E' instead of 'X' for unsigned module taint flag.)
   *
   *	The string is overwritten by the next call to print_tainted().
   */
* Unmerged path Documentation/ABI/testing/sysfs-module
* Unmerged path Documentation/module-signing.txt
* Unmerged path Documentation/oops-tracing.txt
* Unmerged path kernel/module.c
* Unmerged path kernel/panic.c
