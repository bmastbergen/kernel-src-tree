mm/memory-failure: split thp earlier in memory error handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [mm] memory-failure: split thp earlier in memory error handling (Tomoaki Nishimura) [1226196]
Rebuild_FUZZ: 97.48%
commit-author Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
commit 415c64c1453aa2bbcc7e30a38f8894d0894cb8ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/415c64c1.failed

memory_failure() doesn't handle thp itself at this time and need to split
it before doing isolation.  Currently thp is split in the middle of
hwpoison_user_mappings(), but there're corner cases where memory_failure()
wrongly tries to handle thp without splitting.

1) "non anonymous" thp, which is not a normal operating mode of thp,
   but a memory error could hit a thp before anon_vma is initialized.  In
   such case, split_huge_page() fails and me_huge_page() (intended for
   hugetlb) is called for thp, which triggers BUG_ON in page_hstate().

2) !PageLRU case, where hwpoison_user_mappings() returns with
   SWAP_SUCCESS and the result is the same as case 1.

memory_failure() can't avoid splitting, so let's split it more earlier,
which also reduces code which are prepared for both of normal page and
thp.

	Signed-off-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: "Kirill A. Shutemov" <kirill@shutemov.name>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 415c64c1453aa2bbcc7e30a38f8894d0894cb8ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory-failure.c
diff --cc mm/memory-failure.c
index 96911c114194,17a8e3bc3b01..000000000000
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@@ -1183,8 -1174,8 +1145,13 @@@ int memory_failure(unsigned long pfn, i
  	 * The page could have changed compound pages during the locking.
  	 * If this happens just bail out.
  	 */
++<<<<<<< HEAD
 +	if (compound_head(p) != hpage) {
 +		action_result(pfn, "different compound page after locking", IGNORED);
++=======
+ 	if (PageCompound(p) && compound_head(p) != orig_head) {
+ 		action_result(pfn, MSG_DIFFERENT_COMPOUND, IGNORED);
++>>>>>>> 415c64c1453a (mm/memory-failure: split thp earlier in memory error handling)
  		res = -EBUSY;
  		goto out;
  	}
* Unmerged path mm/memory-failure.c
