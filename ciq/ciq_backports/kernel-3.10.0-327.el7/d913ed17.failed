CIFS: Optimize cifs_user_read() in a short read case on reconnects

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Pavel Shilovsky <pshilovsky@samba.org>
commit d913ed17f0a7d74e2847695bc920d77a33f2490b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d913ed17.failed

by filling the output buffer with a data got from a partially received
response and requesting the remaining data from the server. This is
suitable for non-signed connections.

	Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
	Signed-off-by: Steve French <smfrench@gmail.com>
(cherry picked from commit d913ed17f0a7d74e2847695bc920d77a33f2490b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/file.c
diff --cc fs/cifs/file.c
index aef9c17411b5,5d2501df8f6b..000000000000
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@@ -2956,28 -3027,44 +2956,55 @@@ again
  			rc = wait_for_completion_killable(&rdata->done);
  			if (rc)
  				rc = -EINTR;
 -			else if (rdata->result == -EAGAIN) {
 +			else if (rdata->result) {
 +				rc = rdata->result;
  				/* resend call if it's a retryable error */
++<<<<<<< HEAD
 +				if (rc == -EAGAIN) {
 +					struct list_head tmp_list;
++=======
+ 				struct list_head tmp_list;
+ 				unsigned int got_bytes = rdata->got_bytes;
++>>>>>>> d913ed17f0a7 (CIFS: Optimize cifs_user_read() in a short read case on reconnects)
  
 -				list_del_init(&rdata->list);
 -				INIT_LIST_HEAD(&tmp_list);
 +					list_del_init(&rdata->list);
 +					INIT_LIST_HEAD(&tmp_list);
  
++<<<<<<< HEAD
 +					rc = cifs_send_async_read(rdata->offset,
 +						rdata->bytes, rdata->cfile,
 +						cifs_sb, &tmp_list);
++=======
+ 				/*
+ 				 * Got a part of data and then reconnect has
+ 				 * happened -- fill the buffer and continue
+ 				 * reading.
+ 				 */
+ 				if (got_bytes && got_bytes < rdata->bytes) {
+ 					rc = cifs_readdata_to_iov(rdata, to);
+ 					if (rc) {
+ 						kref_put(&rdata->refcount,
+ 						cifs_uncached_readdata_release);
+ 						continue;
+ 					}
+ 				}
+ 
+ 				rc = cifs_send_async_read(
+ 						rdata->offset + got_bytes,
+ 						rdata->bytes - got_bytes,
+ 						rdata->cfile, cifs_sb,
+ 						&tmp_list);
++>>>>>>> d913ed17f0a7 (CIFS: Optimize cifs_user_read() in a short read case on reconnects)
  
 -				list_splice(&tmp_list, &rdata_list);
 -
 -				kref_put(&rdata->refcount,
 -					 cifs_uncached_readdata_release);
 -				goto again;
 -			} else if (rdata->result)
 -				rc = rdata->result;
 -			else
 -				rc = cifs_readdata_to_iov(rdata, to);
 +					list_splice(&tmp_list, &rdata_list);
  
 +					kref_put(&rdata->refcount,
 +						cifs_uncached_readdata_release);
 +					goto again;
 +				}
 +			} else {
 +				rc = cifs_readdata_to_iov(rdata, &to);
 +			}
  			/* if there was a short read -- discard anything left */
  			if (rdata->got_bytes && rdata->got_bytes < rdata->bytes)
  				rc = -ENODATA;
diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c
index da019c10b6dd..b5e72ec49edc 100644
--- a/fs/cifs/cifssmb.c
+++ b/fs/cifs/cifssmb.c
@@ -1565,6 +1565,12 @@ cifs_readv_callback(struct mid_q_entry *mid)
 	case MID_REQUEST_SUBMITTED:
 	case MID_RETRY_NEEDED:
 		rdata->result = -EAGAIN;
+		if (server->sign && rdata->got_bytes)
+			/* reset bytes number since we can not check a sign */
+			rdata->got_bytes = 0;
+		/* FIXME: should this be counted toward the initiating task? */
+		task_io_account_read(rdata->got_bytes);
+		cifs_stats_bytes_read(tcon, rdata->got_bytes);
 		break;
 	default:
 		rdata->result = -EIO;
* Unmerged path fs/cifs/file.c
diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c
index 42f7a4f351f8..88bd91f0de2e 100644
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@ -1735,6 +1735,12 @@ smb2_readv_callback(struct mid_q_entry *mid)
 	case MID_REQUEST_SUBMITTED:
 	case MID_RETRY_NEEDED:
 		rdata->result = -EAGAIN;
+		if (server->sign && rdata->got_bytes)
+			/* reset bytes number since we can not check a sign */
+			rdata->got_bytes = 0;
+		/* FIXME: should this be counted toward the initiating task? */
+		task_io_account_read(rdata->got_bytes);
+		cifs_stats_bytes_read(tcon, rdata->got_bytes);
 		break;
 	default:
 		if (rdata->result != -ENODATA)
