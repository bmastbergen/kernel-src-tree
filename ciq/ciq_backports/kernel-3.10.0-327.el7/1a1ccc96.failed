xfrm: Remove caching of xfrm_policy_sk_bundles

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit 1a1ccc96abb2ed9b8fbb71018e64b97324caef53
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1a1ccc96.failed

We currently cache socket policy bundles at xfrm_policy_sk_bundles.
These cached bundles are never used. Instead we create and cache
a new one whenever xfrm_lookup() is called on a socket policy.

Most protocols cache the used routes to the socket, so let's
remove the unused caching of socket policy bundles in xfrm.

	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 1a1ccc96abb2ed9b8fbb71018e64b97324caef53)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netns/xfrm.h
#	net/xfrm/xfrm_policy.c
diff --cc include/net/netns/xfrm.h
index 5299e69a32af,51f0dce7b643..000000000000
--- a/include/net/netns/xfrm.h
+++ b/include/net/netns/xfrm.h
@@@ -59,6 -58,19 +59,22 @@@ struct netns_xfrm 
  #if IS_ENABLED(CONFIG_IPV6)
  	struct dst_ops		xfrm6_dst_ops;
  #endif
++<<<<<<< HEAD
++=======
+ 	spinlock_t xfrm_state_lock;
+ 	rwlock_t xfrm_policy_lock;
+ 	struct mutex xfrm_cfg_mutex;
+ 
+ 	/* flow cache part */
+ 	struct flow_cache	flow_cache_global;
+ 	struct kmem_cache	*flow_cachep;
+ 	atomic_t		flow_cache_genid;
+ 	struct list_head	flow_cache_gc_list;
+ 	spinlock_t		flow_cache_gc_lock;
+ 	struct work_struct	flow_cache_gc_work;
+ 	struct work_struct	flow_cache_flush_work;
+ 	struct mutex		flow_flush_sem;
++>>>>>>> 1a1ccc96abb2 (xfrm: Remove caching of xfrm_policy_sk_bundles)
  };
  
  #endif
diff --cc net/xfrm/xfrm_policy.c
index 8da957011964,bb3669d973a7..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -39,13 -39,6 +39,16 @@@
  #define XFRM_QUEUE_TMO_MAX ((unsigned)(60*HZ))
  #define XFRM_MAX_QUEUE_LEN	100
  
++<<<<<<< HEAD
 +DEFINE_MUTEX(xfrm_cfg_mutex);
 +EXPORT_SYMBOL(xfrm_cfg_mutex);
 +
 +static DEFINE_SPINLOCK(xfrm_policy_sk_bundle_lock);
 +static struct dst_entry *xfrm_policy_sk_bundles;
 +static DEFINE_RWLOCK(xfrm_policy_lock);
 +
++=======
++>>>>>>> 1a1ccc96abb2 (xfrm: Remove caching of xfrm_policy_sk_bundles)
  static DEFINE_SPINLOCK(xfrm_policy_afinfo_lock);
  static struct xfrm_policy_afinfo __rcu *xfrm_policy_afinfo[NPROTO]
  						__read_mostly;
@@@ -2097,13 -2107,6 +2100,16 @@@ restart
  				goto no_transform;
  			}
  
++<<<<<<< HEAD
 +			dst_hold(&xdst->u.dst);
 +
 +			spin_lock_bh(&xfrm_policy_sk_bundle_lock);
 +			xdst->u.dst.next = xfrm_policy_sk_bundles;
 +			xfrm_policy_sk_bundles = &xdst->u.dst;
 +			spin_unlock_bh(&xfrm_policy_sk_bundle_lock);
 +
++=======
++>>>>>>> 1a1ccc96abb2 (xfrm: Remove caching of xfrm_policy_sk_bundles)
  			route = xdst->route;
  		}
  	}
@@@ -2570,33 -2540,15 +2576,43 @@@ static struct dst_entry *xfrm_negative_
  	return dst;
  }
  
++<<<<<<< HEAD
 +static void __xfrm_garbage_collect(struct net *net)
 +{
 +	struct dst_entry *head, *next;
 +
 +	spin_lock_bh(&xfrm_policy_sk_bundle_lock);
 +	head = xfrm_policy_sk_bundles;
 +	xfrm_policy_sk_bundles = NULL;
 +	spin_unlock_bh(&xfrm_policy_sk_bundle_lock);
 +
 +	while (head) {
 +		next = head->next;
 +		dst_free(head);
 +		head = next;
 +	}
 +}
 +
 +void xfrm_garbage_collect(struct net *net)
 +{
 +	flow_cache_flush();
 +	__xfrm_garbage_collect(net);
++=======
+ void xfrm_garbage_collect(struct net *net)
+ {
+ 	flow_cache_flush(net);
++>>>>>>> 1a1ccc96abb2 (xfrm: Remove caching of xfrm_policy_sk_bundles)
  }
  EXPORT_SYMBOL(xfrm_garbage_collect);
  
  static void xfrm_garbage_collect_deferred(struct net *net)
  {
++<<<<<<< HEAD
 +	flow_cache_flush_deferred();
 +	__xfrm_garbage_collect(net);
++=======
+ 	flow_cache_flush_deferred(net);
++>>>>>>> 1a1ccc96abb2 (xfrm: Remove caching of xfrm_policy_sk_bundles)
  }
  
  static void xfrm_init_pmtu(struct dst_entry *dst)
@@@ -2961,6 -2913,13 +2977,16 @@@ static int __net_init xfrm_net_init(str
  	rv = xfrm_sysctl_init(net);
  	if (rv < 0)
  		goto out_sysctl;
++<<<<<<< HEAD
++=======
+ 
+ 	/* Initialize the per-net locks here */
+ 	spin_lock_init(&net->xfrm.xfrm_state_lock);
+ 	rwlock_init(&net->xfrm.xfrm_policy_lock);
+ 	mutex_init(&net->xfrm.xfrm_cfg_mutex);
+ 
+ 	flow_cache_init(net);
++>>>>>>> 1a1ccc96abb2 (xfrm: Remove caching of xfrm_policy_sk_bundles)
  	return 0;
  
  out_sysctl:
* Unmerged path include/net/netns/xfrm.h
* Unmerged path net/xfrm/xfrm_policy.c
