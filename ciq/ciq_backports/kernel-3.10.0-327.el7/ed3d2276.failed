net/mlx4_core: need to call close fw if alloc icm is called twice

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4_core: need to call close fw if alloc icm is called twice (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 96.83%
commit-author Carol Soto <clsoto@linux.vnet.ibm.com>
commit ed3d2276ef72be23c6367358d80004130d8c797d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ed3d2276.failed

If mlx4_enable_sriov is called by adapter without this
feature MLX4_DEV_CAP_FLAG2_SYS_EQS then during this path the function alloc
icm is called twice without freeing the structures from the first time.

	Acked-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Carol L Soto <clsoto@linux.vnet.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ed3d2276ef72be23c6367358d80004130d8c797d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/main.c
diff --cc drivers/net/ethernet/mellanox/mlx4/main.c
index ee60c3ae7334,7d57777e65c5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/main.c
@@@ -2567,6 -2951,62 +2567,65 @@@ slave_start
  		goto err_mfunc;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (mlx4_is_master(dev)) {
+ 		/* when we hit the goto slave_start below, dev_cap already initialized */
+ 		if (!dev_cap) {
+ 			dev_cap = kzalloc(sizeof(*dev_cap), GFP_KERNEL);
+ 
+ 			if (!dev_cap) {
+ 				err = -ENOMEM;
+ 				goto err_fw;
+ 			}
+ 
+ 			err = mlx4_QUERY_DEV_CAP(dev, dev_cap);
+ 			if (err) {
+ 				mlx4_err(dev, "QUERY_DEV_CAP command failed, aborting.\n");
+ 				goto err_fw;
+ 			}
+ 
+ 			if (mlx4_check_dev_cap(dev, dev_cap, nvfs))
+ 				goto err_fw;
+ 
+ 			if (!(dev_cap->flags2 & MLX4_DEV_CAP_FLAG2_SYS_EQS)) {
+ 				u64 dev_flags = mlx4_enable_sriov(dev, pdev,
+ 								  total_vfs,
+ 								  existing_vfs,
+ 								  reset_flow);
+ 
+ 				mlx4_close_fw(dev);
+ 				mlx4_cmd_cleanup(dev, MLX4_CMD_CLEANUP_ALL);
+ 				dev->flags = dev_flags;
+ 				if (!SRIOV_VALID_STATE(dev->flags)) {
+ 					mlx4_err(dev, "Invalid SRIOV state\n");
+ 					goto err_sriov;
+ 				}
+ 				err = mlx4_reset(dev);
+ 				if (err) {
+ 					mlx4_err(dev, "Failed to reset HCA, aborting.\n");
+ 					goto err_sriov;
+ 				}
+ 				goto slave_start;
+ 			}
+ 		} else {
+ 			/* Legacy mode FW requires SRIOV to be enabled before
+ 			 * doing QUERY_DEV_CAP, since max_eq's value is different if
+ 			 * SRIOV is enabled.
+ 			 */
+ 			memset(dev_cap, 0, sizeof(*dev_cap));
+ 			err = mlx4_QUERY_DEV_CAP(dev, dev_cap);
+ 			if (err) {
+ 				mlx4_err(dev, "QUERY_DEV_CAP command failed, aborting.\n");
+ 				goto err_fw;
+ 			}
+ 
+ 			if (mlx4_check_dev_cap(dev, dev_cap, nvfs))
+ 				goto err_fw;
+ 		}
+ 	}
+ 
++>>>>>>> ed3d2276ef72 (net/mlx4_core: need to call close fw if alloc icm is called twice)
  	err = mlx4_init_hca(dev);
  	if (err) {
  		if (err == -EACCES) {
* Unmerged path drivers/net/ethernet/mellanox/mlx4/main.c
