iwlwifi: pcie: prepare the device before accessing it

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Emmanuel Grumbach <emmanuel.grumbach@intel.com>
commit f9e5554cd8ca1d1212ec922755b397a20f737923
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/f9e5554c.failed

For 8000 series, we need to access the device to know what
firmware to load. Before we do so, we need to prepare the
device otherwise we might not be able to access the
hardware.

Fixes: c278754a21e6 ("iwlwifi: mvm: support family 8000 B2/C steps")
CC: <stable@vger.kernel.org> [4.1]
	Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
(cherry picked from commit f9e5554cd8ca1d1212ec922755b397a20f737923)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/iwlwifi/pcie/trans.c
diff --cc drivers/net/wireless/iwlwifi/pcie/trans.c
index 9788fc59c13b,6203c4ad9bba..000000000000
--- a/drivers/net/wireless/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/iwlwifi/pcie/trans.c
@@@ -1872,6 -2539,56 +1872,59 @@@ struct iwl_trans *iwl_trans_pcie_alloc(
  	}
  
  	trans->hw_rev = iwl_read32(trans, CSR_HW_REV);
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * In the 8000 HW family the format of the 4 bytes of CSR_HW_REV have
+ 	 * changed, and now the revision step also includes bit 0-1 (no more
+ 	 * "dash" value). To keep hw_rev backwards compatible - we'll store it
+ 	 * in the old format.
+ 	 */
+ 	if (trans->cfg->device_family == IWL_DEVICE_FAMILY_8000) {
+ 		unsigned long flags;
+ 
+ 		trans->hw_rev = (trans->hw_rev & 0xfff0) |
+ 				(CSR_HW_REV_STEP(trans->hw_rev << 2) << 2);
+ 
+ 		ret = iwl_pcie_prepare_card_hw(trans);
+ 		if (ret) {
+ 			IWL_WARN(trans, "Exit HW not ready\n");
+ 			goto out_pci_disable_msi;
+ 		}
+ 
+ 		/*
+ 		 * in-order to recognize C step driver should read chip version
+ 		 * id located at the AUX bus MISC address space.
+ 		 */
+ 		iwl_set_bit(trans, CSR_GP_CNTRL,
+ 			    CSR_GP_CNTRL_REG_FLAG_INIT_DONE);
+ 		udelay(2);
+ 
+ 		ret = iwl_poll_bit(trans, CSR_GP_CNTRL,
+ 				   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
+ 				   CSR_GP_CNTRL_REG_FLAG_MAC_CLOCK_READY,
+ 				   25000);
+ 		if (ret < 0) {
+ 			IWL_DEBUG_INFO(trans, "Failed to wake up the nic\n");
+ 			goto out_pci_disable_msi;
+ 		}
+ 
+ 		if (iwl_trans_grab_nic_access(trans, false, &flags)) {
+ 			u32 hw_step;
+ 
+ 			hw_step = __iwl_read_prph(trans, WFPM_CTRL_REG);
+ 			hw_step |= ENABLE_WFPM;
+ 			__iwl_write_prph(trans, WFPM_CTRL_REG, hw_step);
+ 			hw_step = __iwl_read_prph(trans, AUX_MISC_REG);
+ 			hw_step = (hw_step >> HW_STEP_LOCATION_BITS) & 0xF;
+ 			if (hw_step == 0x3)
+ 				trans->hw_rev = (trans->hw_rev & 0xFFFFFFF3) |
+ 						(SILICON_C_STEP << 2);
+ 			iwl_trans_release_nic_access(trans, &flags);
+ 		}
+ 	}
+ 
++>>>>>>> f9e5554cd8ca (iwlwifi: pcie: prepare the device before accessing it)
  	trans->hw_id = (pdev->device << 16) + pdev->subsystem_device;
  	snprintf(trans->hw_id_str, sizeof(trans->hw_id_str),
  		 "PCI ID: 0x%04X:0x%04X", pdev->device, pdev->subsystem_device);
* Unmerged path drivers/net/wireless/iwlwifi/pcie/trans.c
