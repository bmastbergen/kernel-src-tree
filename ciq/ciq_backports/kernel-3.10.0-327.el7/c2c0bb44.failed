proc: fix PAGE_SIZE limit of /proc/$PID/cmdline

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [fs] proc: fix page_size limit of proc pid cmdline fix (Jarod Wilson) [1193998]
Rebuild_FUZZ: 89.58%
commit-author Alexey Dobriyan <adobriyan@gmail.com>
commit c2c0bb44620dece7ec97e28167e32c343da22867
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c2c0bb44.failed

/proc/$PID/cmdline truncates output at PAGE_SIZE. It is easy to see with

	$ cat /proc/self/cmdline $(seq 1037) 2>/dev/null

However, command line size was never limited to PAGE_SIZE but to 128 KB
and relatively recently limitation was removed altogether.

People noticed and ask questions:
http://stackoverflow.com/questions/199130/how-do-i-increase-the-proc-pid-cmdline-4096-byte-limit

seq file interface is not OK, because it kmalloc's for whole output and
open + read(, 1) + sleep will pin arbitrary amounts of kernel memory.  To
not do that, limit must be imposed which is incompatible with arbitrary
sized command lines.

I apologize for hairy code, but this it direct consequence of command line
layout in memory and hacks to support things like "init [3]".

The loops are "unrolled" otherwise it is either macros which hide control
flow or functions with 7-8 arguments with equal line count.

There should be real setproctitle(2) or something.

[akpm@linux-foundation.org: fix a billion min() warnings]
	Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
	Tested-by: Jarod Wilson <jarod@redhat.com>
	Acked-by: Jarod Wilson <jarod@redhat.com>
	Cc: Cyrill Gorcunov <gorcunov@openvz.org>
	Cc: Jan Stancek <jstancek@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c2c0bb44620dece7ec97e28167e32c343da22867)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/base.c
diff --cc fs/proc/base.c
index c80fcbf2395e,bd7a9affc14b..000000000000
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@@ -200,47 -196,209 +200,251 @@@ static int proc_root_link(struct dentr
  	return result;
  }
  
++<<<<<<< HEAD
 +static int proc_pid_cmdline(struct task_struct *task, char * buffer)
 +{
 +	int res = 0;
 +	unsigned int len;
 +	struct mm_struct *mm = get_task_mm(task);
 +	if (!mm)
 +		goto out;
 +	if (!mm->arg_end)
 +		goto out_mm;	/* Shh! No looking before we're done */
 +
 + 	len = mm->arg_end - mm->arg_start;
 + 
 +	if (len > PAGE_SIZE)
 +		len = PAGE_SIZE;
 + 
 +	res = access_process_vm(task, mm->arg_start, buffer, len, 0);
 +
 +	// If the nul at the end of args has been overwritten, then
 +	// assume application is using setproctitle(3).
 +	if (res > 0 && buffer[res-1] != '\0' && len < PAGE_SIZE) {
 +		len = strnlen(buffer, res);
 +		if (len < res) {
 +		    res = len;
 +		} else {
 +			len = mm->env_end - mm->env_start;
 +			if (len > PAGE_SIZE - res)
 +				len = PAGE_SIZE - res;
 +			res += access_process_vm(task, mm->env_start, buffer+res, len, 0);
 +			res = strnlen(buffer, res);
 +		}
 +	}
 +out_mm:
 +	mmput(mm);
 +out:
 +	return res;
 +}
 +
 +static int proc_pid_auxv(struct task_struct *task, char *buffer)
++=======
+ static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,
+ 				     size_t _count, loff_t *pos)
+ {
+ 	struct task_struct *tsk;
+ 	struct mm_struct *mm;
+ 	char *page;
+ 	unsigned long count = _count;
+ 	unsigned long arg_start, arg_end, env_start, env_end;
+ 	unsigned long len1, len2, len;
+ 	unsigned long p;
+ 	char c;
+ 	ssize_t rv;
+ 
+ 	BUG_ON(*pos < 0);
+ 
+ 	tsk = get_proc_task(file_inode(file));
+ 	if (!tsk)
+ 		return -ESRCH;
+ 	mm = get_task_mm(tsk);
+ 	put_task_struct(tsk);
+ 	if (!mm)
+ 		return 0;
+ 	/* Check if process spawned far enough to have cmdline. */
+ 	if (!mm->env_end) {
+ 		rv = 0;
+ 		goto out_mmput;
+ 	}
+ 
+ 	page = (char *)__get_free_page(GFP_TEMPORARY);
+ 	if (!page) {
+ 		rv = -ENOMEM;
+ 		goto out_mmput;
+ 	}
+ 
+ 	down_read(&mm->mmap_sem);
+ 	arg_start = mm->arg_start;
+ 	arg_end = mm->arg_end;
+ 	env_start = mm->env_start;
+ 	env_end = mm->env_end;
+ 	up_read(&mm->mmap_sem);
+ 
+ 	BUG_ON(arg_start > arg_end);
+ 	BUG_ON(env_start > env_end);
+ 
+ 	len1 = arg_end - arg_start;
+ 	len2 = env_end - env_start;
+ 
+ 	/*
+ 	 * Inherently racy -- command line shares address space
+ 	 * with code and data.
+ 	 */
+ 	rv = access_remote_vm(mm, arg_end - 1, &c, 1, 0);
+ 	if (rv <= 0)
+ 		goto out_free_page;
+ 
+ 	rv = 0;
+ 
+ 	if (c == '\0') {
+ 		/* Command line (set of strings) occupies whole ARGV. */
+ 		if (len1 <= *pos)
+ 			goto out_free_page;
+ 
+ 		p = arg_start + *pos;
+ 		len = len1 - *pos;
+ 		while (count > 0 && len > 0) {
+ 			unsigned int _count;
+ 			int nr_read;
+ 
+ 			_count = min3(count, len, PAGE_SIZE);
+ 			nr_read = access_remote_vm(mm, p, page, _count, 0);
+ 			if (nr_read < 0)
+ 				rv = nr_read;
+ 			if (nr_read <= 0)
+ 				goto out_free_page;
+ 
+ 			if (copy_to_user(buf, page, nr_read)) {
+ 				rv = -EFAULT;
+ 				goto out_free_page;
+ 			}
+ 
+ 			p	+= nr_read;
+ 			len	-= nr_read;
+ 			buf	+= nr_read;
+ 			count	-= nr_read;
+ 			rv	+= nr_read;
+ 		}
+ 	} else {
+ 		/*
+ 		 * Command line (1 string) occupies ARGV and maybe
+ 		 * extends into ENVP.
+ 		 */
+ 		if (len1 + len2 <= *pos)
+ 			goto skip_argv_envp;
+ 		if (len1 <= *pos)
+ 			goto skip_argv;
+ 
+ 		p = arg_start + *pos;
+ 		len = len1 - *pos;
+ 		while (count > 0 && len > 0) {
+ 			unsigned int _count, l;
+ 			int nr_read;
+ 			bool final;
+ 
+ 			_count = min3(count, len, PAGE_SIZE);
+ 			nr_read = access_remote_vm(mm, p, page, _count, 0);
+ 			if (nr_read < 0)
+ 				rv = nr_read;
+ 			if (nr_read <= 0)
+ 				goto out_free_page;
+ 
+ 			/*
+ 			 * Command line can be shorter than whole ARGV
+ 			 * even if last "marker" byte says it is not.
+ 			 */
+ 			final = false;
+ 			l = strnlen(page, nr_read);
+ 			if (l < nr_read) {
+ 				nr_read = l;
+ 				final = true;
+ 			}
+ 
+ 			if (copy_to_user(buf, page, nr_read)) {
+ 				rv = -EFAULT;
+ 				goto out_free_page;
+ 			}
+ 
+ 			p	+= nr_read;
+ 			len	-= nr_read;
+ 			buf	+= nr_read;
+ 			count	-= nr_read;
+ 			rv	+= nr_read;
+ 
+ 			if (final)
+ 				goto out_free_page;
+ 		}
+ skip_argv:
+ 		/*
+ 		 * Command line (1 string) occupies ARGV and
+ 		 * extends into ENVP.
+ 		 */
+ 		if (len1 <= *pos) {
+ 			p = env_start + *pos - len1;
+ 			len = len1 + len2 - *pos;
+ 		} else {
+ 			p = env_start;
+ 			len = len2;
+ 		}
+ 		while (count > 0 && len > 0) {
+ 			unsigned int _count, l;
+ 			int nr_read;
+ 			bool final;
+ 
+ 			_count = min3(count, len, PAGE_SIZE);
+ 			nr_read = access_remote_vm(mm, p, page, _count, 0);
+ 			if (nr_read < 0)
+ 				rv = nr_read;
+ 			if (nr_read <= 0)
+ 				goto out_free_page;
+ 
+ 			/* Find EOS. */
+ 			final = false;
+ 			l = strnlen(page, nr_read);
+ 			if (l < nr_read) {
+ 				nr_read = l;
+ 				final = true;
+ 			}
+ 
+ 			if (copy_to_user(buf, page, nr_read)) {
+ 				rv = -EFAULT;
+ 				goto out_free_page;
+ 			}
+ 
+ 			p	+= nr_read;
+ 			len	-= nr_read;
+ 			buf	+= nr_read;
+ 			count	-= nr_read;
+ 			rv	+= nr_read;
+ 
+ 			if (final)
+ 				goto out_free_page;
+ 		}
+ skip_argv_envp:
+ 		;
+ 	}
+ 
+ out_free_page:
+ 	free_page((unsigned long)page);
+ out_mmput:
+ 	mmput(mm);
+ 	if (rv > 0)
+ 		*pos += rv;
+ 	return rv;
+ }
+ 
+ static const struct file_operations proc_pid_cmdline_ops = {
+ 	.read	= proc_pid_cmdline_read,
+ 	.llseek	= generic_file_llseek,
+ };
+ 
+ static int proc_pid_auxv(struct seq_file *m, struct pid_namespace *ns,
+ 			 struct pid *pid, struct task_struct *task)
++>>>>>>> c2c0bb44620d (proc: fix PAGE_SIZE limit of /proc/$PID/cmdline)
  {
  	struct mm_struct *mm = mm_access(task, PTRACE_MODE_READ);
 +	int res = PTR_ERR(mm);
  	if (mm && !IS_ERR(mm)) {
  		unsigned int nwords = 0;
  		do {
@@@ -2660,9 -2757,9 +2864,13 @@@ static const struct pid_entry tgid_base
  #endif
  	REG("comm",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),
  #ifdef CONFIG_HAVE_ARCH_TRACEHOOK
 -	ONE("syscall",    S_IRUSR, proc_pid_syscall),
 +	INF("syscall",    S_IRUGO, proc_pid_syscall),
  #endif
++<<<<<<< HEAD
 +	INF("cmdline",    S_IRUGO, proc_pid_cmdline),
++=======
+ 	REG("cmdline",    S_IRUGO, proc_pid_cmdline_ops),
++>>>>>>> c2c0bb44620d (proc: fix PAGE_SIZE limit of /proc/$PID/cmdline)
  	ONE("stat",       S_IRUGO, proc_tgid_stat),
  	ONE("statm",      S_IRUGO, proc_pid_statm),
  	REG("maps",       S_IRUGO, proc_pid_maps_operations),
@@@ -3014,9 -3103,9 +3222,13 @@@ static const struct pid_entry tid_base_
  #endif
  	REG("comm",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),
  #ifdef CONFIG_HAVE_ARCH_TRACEHOOK
 -	ONE("syscall",   S_IRUSR, proc_pid_syscall),
 +	INF("syscall",   S_IRUGO, proc_pid_syscall),
  #endif
++<<<<<<< HEAD
 +	INF("cmdline",   S_IRUGO, proc_pid_cmdline),
++=======
+ 	REG("cmdline",   S_IRUGO, proc_pid_cmdline_ops),
++>>>>>>> c2c0bb44620d (proc: fix PAGE_SIZE limit of /proc/$PID/cmdline)
  	ONE("stat",      S_IRUGO, proc_tid_stat),
  	ONE("statm",     S_IRUGO, proc_pid_statm),
  	REG("maps",      S_IRUGO, proc_tid_maps_operations),
* Unmerged path fs/proc/base.c
