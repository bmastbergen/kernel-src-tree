fnic: assign FIP_ALL_FCF_MACS to fcoe_all_fcfs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hiral Shah <hishah@cisco.com>
commit 86001f248e943b7b22c22b50151ffaee9447df2d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/86001f24.failed

1) Assgning FIP_ALL_FCF_MACS to fcoe_all_fcfs allows VLAN request to be sent
to correct Mac address for VLAN Discovery otherwise VLAN request will be
sent to invalid address hence FLOGI never happens.

2) Simplify the copy_and_format_trace_data code and log the correct Link event
for fnic control path tracing in case of link status UP->UP.

3) Increment Fnic driver version

	Signed-off-by: Hiral Shah <hishah@cisco.com>
	Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 86001f248e943b7b22c22b50151ffaee9447df2d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/fnic/fnic.h
#	drivers/scsi/fnic/fnic_fcs.c
#	drivers/scsi/fnic/fnic_trace.c
diff --cc drivers/scsi/fnic/fnic.h
index a547c3fee2f5,bf8d34c26f13..000000000000
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@@ -39,7 -39,7 +39,11 @@@
  
  #define DRV_NAME		"fnic"
  #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
++<<<<<<< HEAD
 +#define DRV_VERSION		"1.5.0.45a"
++=======
+ #define DRV_VERSION		"1.6.0.11"
++>>>>>>> 86001f248e94 (fnic: assign FIP_ALL_FCF_MACS to fcoe_all_fcfs)
  #define PFX			DRV_NAME ": "
  #define DFX                     DRV_NAME "%d: "
  
diff --cc drivers/scsi/fnic/fnic_fcs.c
index e4f005760a36,f3984b48f8e9..000000000000
--- a/drivers/scsi/fnic/fnic_fcs.c
+++ b/drivers/scsi/fnic/fnic_fcs.c
@@@ -35,7 -35,7 +35,11 @@@
  #include "cq_enet_desc.h"
  #include "cq_exch_desc.h"
  
++<<<<<<< HEAD
 +static u8 fcoe_all_fcfs[ETH_ALEN] =  FIP_ALL_FCF_MACS;
++=======
+ static u8 fcoe_all_fcfs[ETH_ALEN] = FIP_ALL_FCF_MACS;
++>>>>>>> 86001f248e94 (fnic: assign FIP_ALL_FCF_MACS to fcoe_all_fcfs)
  struct workqueue_struct *fnic_fip_queue;
  struct workqueue_struct *fnic_event_queue;
  
@@@ -85,9 -101,14 +89,17 @@@ void fnic_handle_link(struct work_struc
  				FNIC_FCS_DBG(KERN_DEBUG, fnic->lport->host,
  					     "link up\n");
  				fcoe_ctlr_link_up(&fnic->ctlr);
- 			} else
+ 			} else {
  				/* UP -> UP */
  				spin_unlock_irqrestore(&fnic->fnic_lock, flags);
++<<<<<<< HEAD
++=======
+ 				fnic_fc_trace_set_data(
+ 					fnic->lport->host->host_no, FNIC_FC_LE,
+ 					"Link Status: UP_UP",
+ 					strlen("Link Status: UP_UP"));
+ 			}
++>>>>>>> 86001f248e94 (fnic: assign FIP_ALL_FCF_MACS to fcoe_all_fcfs)
  		}
  	} else if (fnic->link_status) {
  		/* DOWN -> UP */
diff --cc drivers/scsi/fnic/fnic_trace.c
index e002e7187dc0,121a5d7e98c4..000000000000
--- a/drivers/scsi/fnic/fnic_trace.c
+++ b/drivers/scsi/fnic/fnic_trace.c
@@@ -456,3 -467,313 +456,316 @@@ void fnic_trace_free(void
  	}
  	printk(KERN_INFO PFX "Successfully Freed Trace Buffer\n");
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * fnic_fc_ctlr_trace_buf_init -
+  * Initialize trace buffer to log fnic control frames
+  * Description:
+  * Initialize trace buffer data structure by allocating
+  * required memory for trace data as well as for Indexes.
+  * Frame size is 256 bytes and
+  * memory is allocated for 1024 entries of 256 bytes.
+  * Page_offset(Index) is set to the address of trace entry
+  * and page_offset is initialized by adding frame size
+  * to the previous page_offset entry.
+  */
+ 
+ int fnic_fc_trace_init(void)
+ {
+ 	unsigned long fc_trace_buf_head;
+ 	int err = 0;
+ 	int i;
+ 
+ 	fc_trace_max_entries = (fnic_fc_trace_max_pages * PAGE_SIZE)/
+ 				FC_TRC_SIZE_BYTES;
+ 	fnic_fc_ctlr_trace_buf_p = (unsigned long)vmalloc(
+ 					fnic_fc_trace_max_pages * PAGE_SIZE);
+ 	if (!fnic_fc_ctlr_trace_buf_p) {
+ 		pr_err("fnic: Failed to allocate memory for "
+ 		       "FC Control Trace Buf\n");
+ 		err = -ENOMEM;
+ 		goto err_fnic_fc_ctlr_trace_buf_init;
+ 	}
+ 
+ 	memset((void *)fnic_fc_ctlr_trace_buf_p, 0,
+ 			fnic_fc_trace_max_pages * PAGE_SIZE);
+ 
+ 	/* Allocate memory for page offset */
+ 	fc_trace_entries.page_offset = vmalloc(fc_trace_max_entries *
+ 						sizeof(unsigned long));
+ 	if (!fc_trace_entries.page_offset) {
+ 		pr_err("fnic:Failed to allocate memory for page_offset\n");
+ 		if (fnic_fc_ctlr_trace_buf_p) {
+ 			pr_err("fnic: Freeing FC Control Trace Buf\n");
+ 			vfree((void *)fnic_fc_ctlr_trace_buf_p);
+ 			fnic_fc_ctlr_trace_buf_p = 0;
+ 		}
+ 		err = -ENOMEM;
+ 		goto err_fnic_fc_ctlr_trace_buf_init;
+ 	}
+ 	memset((void *)fc_trace_entries.page_offset, 0,
+ 	       (fc_trace_max_entries * sizeof(unsigned long)));
+ 
+ 	fc_trace_entries.rd_idx = fc_trace_entries.wr_idx = 0;
+ 	fc_trace_buf_head = fnic_fc_ctlr_trace_buf_p;
+ 
+ 	/*
+ 	* Set up fc_trace_entries.page_offset field with memory location
+ 	* for every trace entry
+ 	*/
+ 	for (i = 0; i < fc_trace_max_entries; i++) {
+ 		fc_trace_entries.page_offset[i] = fc_trace_buf_head;
+ 		fc_trace_buf_head += FC_TRC_SIZE_BYTES;
+ 	}
+ 	err = fnic_fc_trace_debugfs_init();
+ 	if (err < 0) {
+ 		pr_err("fnic: Failed to initialize FC_CTLR tracing.\n");
+ 		goto err_fnic_fc_ctlr_trace_debugfs_init;
+ 	}
+ 	pr_info("fnic: Successfully Initialized FC_CTLR Trace Buffer\n");
+ 	return err;
+ 
+ err_fnic_fc_ctlr_trace_debugfs_init:
+ 	fnic_fc_trace_free();
+ err_fnic_fc_ctlr_trace_buf_init:
+ 	return err;
+ }
+ 
+ /*
+  * Fnic_fc_ctlr_trace_free - Free memory of fnic_fc_ctlr trace data structures.
+  */
+ void fnic_fc_trace_free(void)
+ {
+ 	fnic_fc_tracing_enabled = 0;
+ 	fnic_fc_trace_debugfs_terminate();
+ 	if (fc_trace_entries.page_offset) {
+ 		vfree((void *)fc_trace_entries.page_offset);
+ 		fc_trace_entries.page_offset = NULL;
+ 	}
+ 	if (fnic_fc_ctlr_trace_buf_p) {
+ 		vfree((void *)fnic_fc_ctlr_trace_buf_p);
+ 		fnic_fc_ctlr_trace_buf_p = 0;
+ 	}
+ 	pr_info("fnic:Successfully FC_CTLR Freed Trace Buffer\n");
+ }
+ 
+ /*
+  * fnic_fc_ctlr_set_trace_data:
+  *       Maintain rd & wr idx accordingly and set data
+  * Passed parameters:
+  *       host_no: host number accociated with fnic
+  *       frame_type: send_frame, rece_frame or link event
+  *       fc_frame: pointer to fc_frame
+  *       frame_len: Length of the fc_frame
+  * Description:
+  *   This routine will get next available wr_idx and
+  *   copy all passed trace data to the buffer pointed by wr_idx
+  *   and increment wr_idx. It will also make sure that we dont
+  *   overwrite the entry which we are reading and also
+  *   wrap around if we reach the maximum entries.
+  * Returned Value:
+  *   It will return 0 for success or -1 for failure
+  */
+ int fnic_fc_trace_set_data(u32 host_no, u8 frame_type,
+ 				char *frame, u32 fc_trc_frame_len)
+ {
+ 	unsigned long flags;
+ 	struct fc_trace_hdr *fc_buf;
+ 	unsigned long eth_fcoe_hdr_len;
+ 	char *fc_trace;
+ 
+ 	if (fnic_fc_tracing_enabled == 0)
+ 		return 0;
+ 
+ 	spin_lock_irqsave(&fnic_fc_trace_lock, flags);
+ 
+ 	if (fnic_fc_trace_cleared == 1) {
+ 		fc_trace_entries.rd_idx = fc_trace_entries.wr_idx = 0;
+ 		pr_info("fnic: Reseting the read idx\n");
+ 		memset((void *)fnic_fc_ctlr_trace_buf_p, 0,
+ 				fnic_fc_trace_max_pages * PAGE_SIZE);
+ 		fnic_fc_trace_cleared = 0;
+ 	}
+ 
+ 	fc_buf = (struct fc_trace_hdr *)
+ 		fc_trace_entries.page_offset[fc_trace_entries.wr_idx];
+ 
+ 	fc_trace_entries.wr_idx++;
+ 
+ 	if (fc_trace_entries.wr_idx >= fc_trace_max_entries)
+ 		fc_trace_entries.wr_idx = 0;
+ 
+ 	if (fc_trace_entries.wr_idx == fc_trace_entries.rd_idx) {
+ 		fc_trace_entries.rd_idx++;
+ 		if (fc_trace_entries.rd_idx >= fc_trace_max_entries)
+ 			fc_trace_entries.rd_idx = 0;
+ 	}
+ 
+ 	fc_buf->time_stamp = CURRENT_TIME;
+ 	fc_buf->host_no = host_no;
+ 	fc_buf->frame_type = frame_type;
+ 
+ 	fc_trace = (char *)FC_TRACE_ADDRESS(fc_buf);
+ 
+ 	/* During the receive path, we do not have eth hdr as well as fcoe hdr
+ 	 * at trace entry point so we will stuff 0xff just to make it generic.
+ 	 */
+ 	if (frame_type == FNIC_FC_RECV) {
+ 		eth_fcoe_hdr_len = sizeof(struct ethhdr) +
+ 					sizeof(struct fcoe_hdr);
+ 		fc_trc_frame_len = fc_trc_frame_len + eth_fcoe_hdr_len;
+ 		memset((char *)fc_trace, 0xff, eth_fcoe_hdr_len);
+ 		/* Copy the rest of data frame */
+ 		memcpy((char *)(fc_trace + eth_fcoe_hdr_len), (void *)frame,
+ 		min_t(u8, fc_trc_frame_len,
+ 			(u8)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE)));
+ 	} else {
+ 		memcpy((char *)fc_trace, (void *)frame,
+ 		min_t(u8, fc_trc_frame_len,
+ 			(u8)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE)));
+ 	}
+ 
+ 	/* Store the actual received length */
+ 	fc_buf->frame_len = fc_trc_frame_len;
+ 
+ 	spin_unlock_irqrestore(&fnic_fc_trace_lock, flags);
+ 	return 0;
+ }
+ 
+ /*
+  * fnic_fc_ctlr_get_trace_data: Copy trace buffer to a memory file
+  * Passed parameter:
+  *       @fnic_dbgfs_t: pointer to debugfs trace buffer
+  *       rdata_flag: 1 => Unformated file
+  *                   0 => formated file
+  * Description:
+  *       This routine will copy the trace data to memory file with
+  *       proper formatting and also copy to another memory
+  *       file without formatting for further procesing.
+  * Retrun Value:
+  *       Number of bytes that were dumped into fnic_dbgfs_t
+  */
+ 
+ int fnic_fc_trace_get_data(fnic_dbgfs_t *fnic_dbgfs_prt, u8 rdata_flag)
+ {
+ 	int rd_idx, wr_idx;
+ 	unsigned long flags;
+ 	int len = 0, j;
+ 	struct fc_trace_hdr *tdata;
+ 	char *fc_trace;
+ 
+ 	spin_lock_irqsave(&fnic_fc_trace_lock, flags);
+ 	if (fc_trace_entries.wr_idx == fc_trace_entries.rd_idx) {
+ 		spin_unlock_irqrestore(&fnic_fc_trace_lock, flags);
+ 		pr_info("fnic: Buffer is empty\n");
+ 		return 0;
+ 	}
+ 	rd_idx = fc_trace_entries.rd_idx;
+ 	wr_idx = fc_trace_entries.wr_idx;
+ 	if (rdata_flag == 0) {
+ 		len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 			(fnic_fc_trace_max_pages * PAGE_SIZE * 3) - len,
+ 			"Time Stamp (UTC)\t\t"
+ 			"Host No:   F Type:  len:     FCoE_FRAME:\n");
+ 	}
+ 
+ 	while (rd_idx != wr_idx) {
+ 		tdata = (struct fc_trace_hdr *)
+ 			fc_trace_entries.page_offset[rd_idx];
+ 		if (!tdata) {
+ 			pr_info("fnic: Rd data is NULL\n");
+ 			spin_unlock_irqrestore(&fnic_fc_trace_lock, flags);
+ 			return 0;
+ 		}
+ 		if (rdata_flag == 0) {
+ 			copy_and_format_trace_data(tdata,
+ 				fnic_dbgfs_prt, &len, rdata_flag);
+ 		} else {
+ 			fc_trace = (char *)tdata;
+ 			for (j = 0; j < FC_TRC_SIZE_BYTES; j++) {
+ 				len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 				(fnic_fc_trace_max_pages * PAGE_SIZE * 3)
+ 				- len, "%02x", fc_trace[j] & 0xff);
+ 			} /* for loop */
+ 			len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 				(fnic_fc_trace_max_pages * PAGE_SIZE * 3) - len,
+ 				"\n");
+ 		}
+ 		rd_idx++;
+ 		if (rd_idx > (fc_trace_max_entries - 1))
+ 			rd_idx = 0;
+ 	}
+ 
+ 	spin_unlock_irqrestore(&fnic_fc_trace_lock, flags);
+ 	return len;
+ }
+ 
+ /*
+  * copy_and_format_trace_data: Copy formatted data to char * buffer
+  * Passed Parameter:
+  *      @fc_trace_hdr_t: pointer to trace data
+  *      @fnic_dbgfs_t: pointer to debugfs trace buffer
+  *      @orig_len: pointer to len
+  *      rdata_flag: 0 => Formated file, 1 => Unformated file
+  * Description:
+  *      This routine will format and copy the passed trace data
+  *      for formated file or unformated file accordingly.
+  */
+ 
+ void copy_and_format_trace_data(struct fc_trace_hdr *tdata,
+ 				fnic_dbgfs_t *fnic_dbgfs_prt, int *orig_len,
+ 				u8 rdata_flag)
+ {
+ 	struct tm tm;
+ 	int j, i = 1, len;
+ 	char *fc_trace, *fmt;
+ 	int ethhdr_len = sizeof(struct ethhdr) - 1;
+ 	int fcoehdr_len = sizeof(struct fcoe_hdr);
+ 	int fchdr_len = sizeof(struct fc_frame_header);
+ 	int max_size = fnic_fc_trace_max_pages * PAGE_SIZE * 3;
+ 
+ 	tdata->frame_type = tdata->frame_type & 0x7F;
+ 
+ 	len = *orig_len;
+ 
+ 	time_to_tm(tdata->time_stamp.tv_sec, 0, &tm);
+ 
+ 	fmt = "%02d:%02d:%04ld %02d:%02d:%02d.%09lu ns%8x       %c%8x\t";
+ 	len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 		max_size - len,
+ 		fmt,
+ 		tm.tm_mon + 1, tm.tm_mday, tm.tm_year + 1900,
+ 		tm.tm_hour, tm.tm_min, tm.tm_sec,
+ 		tdata->time_stamp.tv_nsec, tdata->host_no,
+ 		tdata->frame_type, tdata->frame_len);
+ 
+ 	fc_trace = (char *)FC_TRACE_ADDRESS(tdata);
+ 
+ 	for (j = 0; j < min_t(u8, tdata->frame_len,
+ 		(u8)(FC_TRC_SIZE_BYTES - FC_TRC_HEADER_SIZE)); j++) {
+ 		if (tdata->frame_type == FNIC_FC_LE) {
+ 			len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 				max_size - len, "%c", fc_trace[j]);
+ 		} else {
+ 			len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 				max_size - len, "%02x", fc_trace[j] & 0xff);
+ 			len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 				max_size - len, " ");
+ 			if (j == ethhdr_len ||
+ 				j == ethhdr_len + fcoehdr_len ||
+ 				j == ethhdr_len + fcoehdr_len + fchdr_len ||
+ 				(i > 3 && j%fchdr_len == 0)) {
+ 				len += snprintf(fnic_dbgfs_prt->buffer
+ 					+ len, max_size - len,
+ 					"\n\t\t\t\t\t\t\t\t");
+ 				i++;
+ 			}
+ 		} /* end of else*/
+ 	} /* End of for loop*/
+ 	len += snprintf(fnic_dbgfs_prt->buffer + len,
+ 		max_size - len, "\n");
+ 	*orig_len = len;
+ }
++>>>>>>> 86001f248e94 (fnic: assign FIP_ALL_FCF_MACS to fcoe_all_fcfs)
* Unmerged path drivers/scsi/fnic/fnic.h
* Unmerged path drivers/scsi/fnic/fnic_fcs.c
* Unmerged path drivers/scsi/fnic/fnic_trace.c
