PCI / pci-label: treat PCI label with index 0 as valid label

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [pci] label: treat PCI label with index 0 as valid label (Myron Stowe) [1223472]
Rebuild_FUZZ: 90.91%
commit-author Jiang Liu <jiang.liu@linux.intel.com>
commit 2fc59fe2ecdca56a68728b6091590c07bb3e358d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2fc59fe2.failed

Current pci-label driver detects ACPI label by checking label index
returned by ACPI _DSM method, and treats it as valid if label index
is positive. According to ACPI Firmware specification 3.1, zero is
also an valid label index. So change code to detect availability of
ACPI slot label by checking availaiblity of ACPI _DSM function for
PCI label.

	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 2fc59fe2ecdca56a68728b6091590c07bb3e358d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci-label.c
diff --cc drivers/pci/pci-label.c
index b62523cdf57a,0260b14c8d94..000000000000
--- a/drivers/pci/pci-label.c
+++ b/drivers/pci/pci-label.c
@@@ -179,71 -202,53 +178,103 @@@ static void dsm_label_utf16s_to_utf8s(u
  }
  
  static int
 -dsm_get_label(struct device *dev, char *buf, enum acpi_attr_enum attr)
 +dsm_get_label(acpi_handle handle, int func,
 +	      struct acpi_buffer *output,
 +	      char *buf, enum acpi_attr_enum attribute)
  {
 -	acpi_handle handle;
 -	union acpi_object *obj, *tmp;
 -	int len = -1;
 -
 -	handle = ACPI_HANDLE(dev);
 -	if (!handle)
 +	struct acpi_object_list input;
 +	union acpi_object params[4];
 +	union acpi_object *obj;
 +	int len = 0;
 +
 +	int err;
 +
 +	input.count = 4;
 +	input.pointer = params;
 +	params[0].type = ACPI_TYPE_BUFFER;
 +	params[0].buffer.length = sizeof(device_label_dsm_uuid);
 +	params[0].buffer.pointer = (char *)device_label_dsm_uuid;
 +	params[1].type = ACPI_TYPE_INTEGER;
 +	params[1].integer.value = 0x02;
 +	params[2].type = ACPI_TYPE_INTEGER;
 +	params[2].integer.value = func;
 +	params[3].type = ACPI_TYPE_PACKAGE;
 +	params[3].package.count = 0;
 +	params[3].package.elements = NULL;
 +
 +	err = acpi_evaluate_object(handle, "_DSM", &input, output);
 +	if (err)
  		return -1;
  
++<<<<<<< HEAD
 +	obj = (union acpi_object *)output->pointer;
 +	if (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 2) {
 +		len = obj->package.elements[0].integer.value;
 +		if (buf) {
 +			if (attribute == ACPI_ATTR_INDEX_SHOW)
 +				scnprintf(buf, PAGE_SIZE, "%llu\n",
 +				obj->package.elements[0].integer.value);
 +			else if (attribute == ACPI_ATTR_LABEL_SHOW)
 +				dsm_label_utf16s_to_utf8s(obj, buf);
 +			kfree(output->pointer);
 +			return strlen(buf);
 +		}
 +		kfree(output->pointer);
 +		return len;
++=======
+ 	obj = acpi_evaluate_dsm(handle, device_label_dsm_uuid, 0x2,
+ 				DEVICE_LABEL_DSM, NULL);
+ 	if (!obj)
+ 		return -1;
+ 
+ 	tmp = obj->package.elements;
+ 	if (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 2 &&
+ 	    tmp[0].type == ACPI_TYPE_INTEGER &&
+ 	    tmp[1].type == ACPI_TYPE_STRING) {
+ 		/*
+ 		 * The second string element is optional even when
+ 		 * this _DSM is implemented; when not implemented,
+ 		 * this entry must return a null string.
+ 		 */
+ 		if (attr == ACPI_ATTR_INDEX_SHOW)
+ 			scnprintf(buf, PAGE_SIZE, "%llu\n", tmp->integer.value);
+ 		else if (attr == ACPI_ATTR_LABEL_SHOW)
+ 			dsm_label_utf16s_to_utf8s(tmp + 1, buf);
+ 		len = strlen(buf) > 0 ? strlen(buf) : -1;
++>>>>>>> 2fc59fe2ecdc (PCI / pci-label: treat PCI label with index 0 as valid label)
  	}
  
 -	ACPI_FREE(obj);
 +	kfree(output->pointer);
  
 -	return len;
 +	return -1;
  }
  
  static bool
  device_has_dsm(struct device *dev)
  {
  	acpi_handle handle;
++<<<<<<< HEAD
 +	struct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};
 +
 +	handle = DEVICE_ACPI_HANDLE(dev);
 +
 +	if (!handle)
 +		return FALSE;
 +
 +	if (dsm_get_label(handle, DEVICE_LABEL_DSM, &output, NULL,
 +			  ACPI_ATTR_NONE) > 0)
 +		return TRUE;
 +
 +	return FALSE;
++=======
+ 
+ 	handle = ACPI_HANDLE(dev);
+ 	if (!handle)
+ 		return false;
+ 
+ 	return !!acpi_check_dsm(handle, device_label_dsm_uuid, 0x2,
+ 				1 << DEVICE_LABEL_DSM);
++>>>>>>> 2fc59fe2ecdc (PCI / pci-label: treat PCI label with index 0 as valid label)
  }
  
  static umode_t
* Unmerged path drivers/pci/pci-label.c
