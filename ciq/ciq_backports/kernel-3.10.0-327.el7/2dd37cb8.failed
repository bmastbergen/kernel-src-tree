Drivers: hv: vmbus: Handle both rescind and offer messages in the same context

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [hv] vmbus: Handle both rescind and offer messages in the same context (Vitaly Kuznetsov) [1203682]
Rebuild_FUZZ: 90.91%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 2dd37cb81580dce6dfb8c5a7d5c37b904a188ae7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2dd37cb8.failed

Execute both ressind and offer messages in the same work context. This serializes these
operations and naturally addresses the various corner cases.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 2dd37cb81580dce6dfb8c5a7d5c37b904a188ae7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/channel_mgmt.c
diff --cc drivers/hv/channel_mgmt.c
index f9943186ea53,f8528e1e3a77..000000000000
--- a/drivers/hv/channel_mgmt.c
+++ b/drivers/hv/channel_mgmt.c
@@@ -339,9 -351,19 +364,23 @@@ static void vmbus_process_offer(struct 
  
  			newchannel->state = CHANNEL_OPEN_STATE;
  			if (channel->sc_creation_callback != NULL)
- 				channel->sc_creation_callback(newchannel);
- 
+ 				/*
+ 				 * We need to invoke the sub-channel creation
+ 				 * callback; invoke this in a seperate work
+ 				 * context since we are currently running on
+ 				 * the global work context in which we handle
+ 				 * messages from the host.
+ 				 */
+ 				INIT_WORK(&newchannel->work,
+ 					  vmbus_sc_creation_cb);
+ 				queue_work(newchannel->controlwq,
+ 					   &newchannel->work);
+ 
++<<<<<<< HEAD
 +			goto out;
++=======
+ 			return;
++>>>>>>> 2dd37cb81580 (Drivers: hv: vmbus: Handle both rescind and offer messages in the same context)
  		}
  
  		goto err_free_chan;
@@@ -382,8 -404,9 +421,13 @@@
  		kfree(newchannel->device_obj);
  		goto err_free_chan;
  	}
++<<<<<<< HEAD
 +out:
++=======
+ 
++>>>>>>> 2dd37cb81580 (Drivers: hv: vmbus: Handle both rescind and offer messages in the same context)
  	return;
+ 
  err_free_chan:
  	free_channel(newchannel);
  }
@@@ -524,15 -549,28 +567,34 @@@ static void vmbus_onoffer_rescind(struc
  	rescind = (struct vmbus_channel_rescind_offer *)hdr;
  	channel = relid2channel(rescind->child_relid);
  
- 	if (channel == NULL)
- 		/* Just return here, no channel found */
+ 	if (channel == NULL) {
+ 		hv_process_channel_removal(NULL, rescind->child_relid);
  		return;
+ 	}
  
 -	spin_lock_irqsave(&channel->lock, flags);
  	channel->rescind = true;
++<<<<<<< HEAD
 +
 +	/* work is initialized for vmbus_process_rescind_offer() from
 +	 * vmbus_process_offer() where the channel got created */
 +	queue_work(channel->controlwq, &channel->work);
++=======
+ 	spin_unlock_irqrestore(&channel->lock, flags);
+ 
+ 	if (channel->device_obj) {
+ 		/*
+ 		 * We will have to unregister this device from the
+ 		 * driver core. Do this in the per-channel work context.
+ 		 * Note that we are currently executing on the global
+ 		 * workq for handling messages from the host.
+ 		 */
+ 		INIT_WORK(&channel->work, vmbus_process_device_unregister);
+ 		queue_work(channel->controlwq, &channel->work);
+ 	} else {
+ 		hv_process_channel_removal(channel,
+ 					   channel->offermsg.child_relid);
+ 	}
++>>>>>>> 2dd37cb81580 (Drivers: hv: vmbus: Handle both rescind and offer messages in the same context)
  }
  
  /*
* Unmerged path drivers/hv/channel_mgmt.c
