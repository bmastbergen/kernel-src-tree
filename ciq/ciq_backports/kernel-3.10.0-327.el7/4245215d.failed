Btrfs, raid56: fix use-after-free problem in the final device replace procedure on raid56

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Miao Xie <miaox@cn.fujitsu.com>
commit 4245215d6a8dba1a51c50533b6667919687c0b89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4245215d.failed

The commit c404e0dc (Btrfs: fix use-after-free in the finishing
procedure of the device replace) fixed a use-after-free problem
which happened when removing the source device at the end of device
replace, but at that time, btrfs didn't support device replace
on raid56, so we didn't fix the problem on the raid56 profile.
Currently, we implemented device replace for raid56, so we need
kick that problem out before we enable that function for raid56.

The fix method is very simple, we just increase the bio per-cpu
counter before we submit a raid56 io, and decrease the counter
when the raid56 io ends.

	Signed-off-by: Miao Xie <miaox@cn.fujitsu.com>
(cherry picked from commit 4245215d6a8dba1a51c50533b6667919687c0b89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/btrfs/raid56.c
#	fs/btrfs/raid56.h
#	fs/btrfs/scrub.c
#	fs/btrfs/volumes.c
diff --cc fs/btrfs/raid56.c
index 6c2905ba2744,8ab2a17bbba8..000000000000
--- a/fs/btrfs/raid56.c
+++ b/fs/btrfs/raid56.c
@@@ -143,9 -162,10 +143,11 @@@ struct btrfs_raid_bio 
  	 */
  	int bio_list_bytes;
  
+ 	int generic_bio_cnt;
+ 
  	atomic_t refs;
  
 +
  	atomic_t stripes_pending;
  
  	atomic_t error;
@@@ -1690,13 -1782,20 +1697,17 @@@ int raid56_parity_write(struct btrfs_ro
  	struct btrfs_raid_bio *rbio;
  	struct btrfs_plug_cb *plug = NULL;
  	struct blk_plug_cb *cb;
+ 	int ret;
  
  	rbio = alloc_rbio(root, bbio, raid_map, stripe_len);
 -	if (IS_ERR(rbio)) {
 -		__free_bbio_and_raid_map(bbio, raid_map, 1);
 +	if (IS_ERR(rbio))
  		return PTR_ERR(rbio);
 -	}
  	bio_list_add(&rbio->bio_list, bio);
 -	rbio->bio_list_bytes = bio->bi_iter.bi_size;
 -	rbio->operation = BTRFS_RBIO_WRITE;
 +	rbio->bio_list_bytes = bio->bi_size;
  
+ 	btrfs_bio_counter_inc_noblocked(root->fs_info);
+ 	rbio->generic_bio_cnt = 1;
+ 
  	/*
  	 * don't plug on full rbios, just get them out the door
  	 * as quickly as we can
@@@ -2038,24 -2157,25 +2056,41 @@@ cleanup
   */
  int raid56_parity_recover(struct btrfs_root *root, struct bio *bio,
  			  struct btrfs_bio *bbio, u64 *raid_map,
++<<<<<<< HEAD
 +			  u64 stripe_len, int mirror_num)
++=======
+ 			  u64 stripe_len, int mirror_num, int generic_io)
++>>>>>>> 4245215d6a8d (Btrfs, raid56: fix use-after-free problem in the final device replace procedure on raid56)
  {
  	struct btrfs_raid_bio *rbio;
  	int ret;
  
  	rbio = alloc_rbio(root, bbio, raid_map, stripe_len);
++<<<<<<< HEAD
 +	if (IS_ERR(rbio))
++=======
+ 	if (IS_ERR(rbio)) {
+ 		__free_bbio_and_raid_map(bbio, raid_map, generic_io);
++>>>>>>> 4245215d6a8d (Btrfs, raid56: fix use-after-free problem in the final device replace procedure on raid56)
  		return PTR_ERR(rbio);
 -	}
  
++<<<<<<< HEAD
 +	rbio->read_rebuild = 1;
++=======
+ 	rbio->operation = BTRFS_RBIO_READ_REBUILD;
++>>>>>>> 4245215d6a8d (Btrfs, raid56: fix use-after-free problem in the final device replace procedure on raid56)
  	bio_list_add(&rbio->bio_list, bio);
 -	rbio->bio_list_bytes = bio->bi_iter.bi_size;
 +	rbio->bio_list_bytes = bio->bi_size;
  
  	rbio->faila = find_logical_bio_stripe(rbio, bio);
  	if (rbio->faila == -1) {
  		BUG();
++<<<<<<< HEAD
 +		kfree(raid_map);
 +		kfree(bbio);
++=======
+ 		__free_bbio_and_raid_map(bbio, raid_map, generic_io);
++>>>>>>> 4245215d6a8d (Btrfs, raid56: fix use-after-free problem in the final device replace procedure on raid56)
  		kfree(rbio);
  		return -EIO;
  	}
diff --cc fs/btrfs/raid56.h
index ea5d73bfdfbe,31d4a157b5e3..000000000000
--- a/fs/btrfs/raid56.h
+++ b/fs/btrfs/raid56.h
@@@ -39,9 -39,12 +39,14 @@@ static inline int nr_data_stripes(struc
  #define is_parity_stripe(x) (((x) == RAID5_P_STRIPE) ||		\
  			     ((x) == RAID6_Q_STRIPE))
  
 -struct btrfs_raid_bio;
 -struct btrfs_device;
 -
  int raid56_parity_recover(struct btrfs_root *root, struct bio *bio,
++<<<<<<< HEAD
 +				 struct btrfs_bio *bbio, u64 *raid_map,
 +				 u64 stripe_len, int mirror_num);
++=======
+ 			  struct btrfs_bio *bbio, u64 *raid_map,
+ 			  u64 stripe_len, int mirror_num, int generic_io);
++>>>>>>> 4245215d6a8d (Btrfs, raid56: fix use-after-free problem in the final device replace procedure on raid56)
  int raid56_parity_write(struct btrfs_root *root, struct bio *bio,
  			       struct btrfs_bio *bbio, u64 *raid_map,
  			       u64 stripe_len);
diff --cc fs/btrfs/scrub.c
index 5189c8700c82,27f2e16cd259..000000000000
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@@ -1293,6 -1443,51 +1293,54 @@@ leave_nomem
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ struct scrub_bio_ret {
+ 	struct completion event;
+ 	int error;
+ };
+ 
+ static void scrub_bio_wait_endio(struct bio *bio, int error)
+ {
+ 	struct scrub_bio_ret *ret = bio->bi_private;
+ 
+ 	ret->error = error;
+ 	complete(&ret->event);
+ }
+ 
+ static inline int scrub_is_page_on_raid56(struct scrub_page *page)
+ {
+ 	return page->recover && page->recover->raid_map;
+ }
+ 
+ static int scrub_submit_raid56_bio_wait(struct btrfs_fs_info *fs_info,
+ 					struct bio *bio,
+ 					struct scrub_page *page)
+ {
+ 	struct scrub_bio_ret done;
+ 	int ret;
+ 
+ 	init_completion(&done.event);
+ 	done.error = 0;
+ 	bio->bi_iter.bi_sector = page->logical >> 9;
+ 	bio->bi_private = &done;
+ 	bio->bi_end_io = scrub_bio_wait_endio;
+ 
+ 	ret = raid56_parity_recover(fs_info->fs_root, bio, page->recover->bbio,
+ 				    page->recover->raid_map,
+ 				    page->recover->map_length,
+ 				    page->mirror_num, 0);
+ 	if (ret)
+ 		return ret;
+ 
+ 	wait_for_completion(&done.event);
+ 	if (done.error)
+ 		return -EIO;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 4245215d6a8d (Btrfs, raid56: fix use-after-free problem in the final device replace procedure on raid56)
  /*
   * this function will check the on disk data for checksum errors, header
   * errors and read I/O errors. If any I/O errors happen, the exact pages
diff --cc fs/btrfs/volumes.c
index a656dcd9e09a,cbb766577f31..000000000000
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@@ -5803,12 -5843,9 +5803,13 @@@ int btrfs_map_bio(struct btrfs_root *ro
  		} else {
  			ret = raid56_parity_recover(root, bio, bbio,
  						    raid_map, map_length,
++<<<<<<< HEAD
 +						    mirror_num);
++=======
+ 						    mirror_num, 1);
++>>>>>>> 4245215d6a8d (Btrfs, raid56: fix use-after-free problem in the final device replace procedure on raid56)
  		}
- 		/*
- 		 * FIXME, replace dosen't support raid56 yet, please fix
- 		 * it in the future.
- 		 */
+ 
  		btrfs_bio_counter_dec(root->fs_info);
  		return ret;
  	}
diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h
index bc89d85a5d61..e37e227b2de1 100644
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -4158,7 +4158,12 @@ int btrfs_scrub_progress(struct btrfs_root *root, u64 devid,
 /* dev-replace.c */
 void btrfs_bio_counter_inc_blocked(struct btrfs_fs_info *fs_info);
 void btrfs_bio_counter_inc_noblocked(struct btrfs_fs_info *fs_info);
-void btrfs_bio_counter_dec(struct btrfs_fs_info *fs_info);
+void btrfs_bio_counter_sub(struct btrfs_fs_info *fs_info, s64 amount);
+
+static inline void btrfs_bio_counter_dec(struct btrfs_fs_info *fs_info)
+{
+	btrfs_bio_counter_sub(fs_info, 1);
+}
 
 /* reada.c */
 struct reada_control {
diff --git a/fs/btrfs/dev-replace.c b/fs/btrfs/dev-replace.c
index f9334145d1a6..14fde6559cb4 100644
--- a/fs/btrfs/dev-replace.c
+++ b/fs/btrfs/dev-replace.c
@@ -927,9 +927,9 @@ void btrfs_bio_counter_inc_noblocked(struct btrfs_fs_info *fs_info)
 	percpu_counter_inc(&fs_info->bio_counter);
 }
 
-void btrfs_bio_counter_dec(struct btrfs_fs_info *fs_info)
+void btrfs_bio_counter_sub(struct btrfs_fs_info *fs_info, s64 amount)
 {
-	percpu_counter_dec(&fs_info->bio_counter);
+	percpu_counter_sub(&fs_info->bio_counter, amount);
 
 	if (waitqueue_active(&fs_info->replace_wait))
 		wake_up(&fs_info->replace_wait);
* Unmerged path fs/btrfs/raid56.c
* Unmerged path fs/btrfs/raid56.h
* Unmerged path fs/btrfs/scrub.c
* Unmerged path fs/btrfs/volumes.c
