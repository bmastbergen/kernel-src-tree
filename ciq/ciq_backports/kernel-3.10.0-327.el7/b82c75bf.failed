powerpc/iommu: Fix IOMMU ownership control functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [powerpc] iommu: Fix IOMMU ownership control functions (David Gibson) [1213665]
Rebuild_FUZZ: 91.67%
commit-author Alexey Kardashevskiy <aik@ozlabs.ru>
commit b82c75bfbeb5b4c7c23ee09dd6f295c7f06aeb25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b82c75bf.failed

This adds missing locks in iommu_take_ownership()/
iommu_release_ownership().

This marks all pages busy in iommu_table::it_map in order to catch
errors if there is an attempt to use this table while ownership over it
is taken.

This only clears TCE content if there is no page marked busy in it_map.
Clearing must be done outside of the table locks as iommu_clear_tce()
called from iommu_clear_tces_and_put_pages() does this.

In order to use bitmap_empty(), the existing code clears bit#0 which
is set even in an empty table if it is bus-mapped at 0 as
iommu_init_table() reserves page#0 to prevent buggy drivers
from crashing when allocated page is bus-mapped at zero
(which is correct). This restores the bit in the case of failure
to bring the it_map to the state it was in when we called
iommu_take_ownership().

	Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
	Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
	Reviewed-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit b82c75bfbeb5b4c7c23ee09dd6f295c7f06aeb25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/iommu.c
diff --cc arch/powerpc/kernel/iommu.c
index a8ba9f468d1a,0fb88005c3c5..000000000000
--- a/arch/powerpc/kernel/iommu.c
+++ b/arch/powerpc/kernel/iommu.c
@@@ -1046,20 -1047,19 +1051,31 @@@ int iommu_take_ownership(struct iommu_t
  
  	if (!bitmap_empty(tbl->it_map, tbl->it_size)) {
  		pr_err("iommu_tce: it_map is not empty");
- 		return -EBUSY;
+ 		ret = -EBUSY;
+ 		/* Restore bit#0 set by iommu_init_table() */
+ 		if (tbl->it_offset == 0)
+ 			set_bit(0, tbl->it_map);
+ 	} else {
+ 		memset(tbl->it_map, 0xff, sz);
  	}
  
- 	memset(tbl->it_map, 0xff, sz);
+ 	for (i = 0; i < tbl->nr_pools; i++)
+ 		spin_unlock(&tbl->pools[i].lock);
+ 	spin_unlock_irqrestore(&tbl->large_pool.lock, flags);
  
++<<<<<<< HEAD
 +	/*
 +	 * Disable iommu bypass, otherwise the user can DMA to all of
 +	 * our physical memory via the bypass window instead of just
 +	 * the pages that has been explicitly mapped into the iommu
 +	 */
 +	if (tbl->set_bypass)
 +		tbl->set_bypass(tbl, false);
 +
 +	return 0;
++=======
+ 	return ret;
++>>>>>>> b82c75bfbeb5 (powerpc/iommu: Fix IOMMU ownership control functions)
  }
  EXPORT_SYMBOL_GPL(iommu_take_ownership);
  
@@@ -1073,9 -1077,9 +1093,15 @@@ void iommu_release_ownership(struct iom
  	if (tbl->it_offset == 0)
  		set_bit(0, tbl->it_map);
  
++<<<<<<< HEAD
 +	/* The kernel owns the device now, we can restore the iommu bypass */
 +	if (tbl->set_bypass)
 +		tbl->set_bypass(tbl, true);
++=======
+ 	for (i = 0; i < tbl->nr_pools; i++)
+ 		spin_unlock(&tbl->pools[i].lock);
+ 	spin_unlock_irqrestore(&tbl->large_pool.lock, flags);
++>>>>>>> b82c75bfbeb5 (powerpc/iommu: Fix IOMMU ownership control functions)
  }
  EXPORT_SYMBOL_GPL(iommu_release_ownership);
  
* Unmerged path arch/powerpc/kernel/iommu.c
