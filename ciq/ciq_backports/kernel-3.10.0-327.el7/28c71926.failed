bonding: use RCU protection for alb xmit path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author dingtianhong <dingtianhong@huawei.com>
commit 28c719260da032c999ecb4b73ba56311c635ef4e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/28c71926.failed

The commit 278b20837511776dc9d5f6ee1c7fabd5479838bb
(bonding: initial RCU conversion) has convert the roundrobin,
active-backup, broadcast and xor xmit path to rcu protection,
the performance will be better for these mode, so this time,
convert xmit path for alb mode.

	Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
	Signed-off-by: Yang Yingliang <yangyingliang@huawei.com>
	Cc: Nikolay Aleksandrov <nikolay@redhat.com>
	Cc: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 28c719260da032c999ecb4b73ba56311c635ef4e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_alb.c
diff --cc drivers/net/bonding/bond_alb.c
index b7563cd17726,02872405d35d..000000000000
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@@ -230,7 -230,7 +230,11 @@@ static struct slave *tlb_get_least_load
  	max_gap = LLONG_MIN;
  
  	/* Find the slave with the largest gap */
++<<<<<<< HEAD
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave_rcu(bond, slave, iter) {
++>>>>>>> 28c719260da0 (bonding: use RCU protection for alb xmit path)
  		if (SLAVE_IS_OK(slave)) {
  			long long gap = compute_gap(slave);
  
@@@ -1342,10 -1378,6 +1381,13 @@@ int bond_alb_xmit(struct sk_buff *skb, 
  	skb_reset_mac_header(skb);
  	eth_data = eth_hdr(skb);
  
++<<<<<<< HEAD
 +	/* make sure that the curr_active_slave do not change during tx
 +	 */
 +	read_lock(&bond->curr_slave_lock);
 +
++=======
++>>>>>>> 28c719260da0 (bonding: use RCU protection for alb xmit path)
  	switch (ntohs(skb->protocol)) {
  	case ETH_P_IP: {
  		const struct iphdr *iph = ip_hdr(skb);
@@@ -1447,8 -1479,6 +1489,11 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	read_unlock(&bond->curr_slave_lock);
 +
++=======
++>>>>>>> 28c719260da0 (bonding: use RCU protection for alb xmit path)
  	if (res) {
  		/* no suitable interface, frame not sent */
  		kfree_skb(skb);
* Unmerged path drivers/net/bonding/bond_alb.c
diff --git a/drivers/net/bonding/bonding.h b/drivers/net/bonding/bonding.h
index d605c88d8e52..6e314b5cfaa1 100644
--- a/drivers/net/bonding/bonding.h
+++ b/drivers/net/bonding/bonding.h
@@ -484,6 +484,20 @@ static inline struct slave *bond_slave_has_mac(struct bonding *bond,
 	return NULL;
 }
 
+/* Caller must hold rcu_read_lock() for read */
+static inline struct slave *bond_slave_has_mac_rcu(struct bonding *bond,
+					       const u8 *mac)
+{
+	struct list_head *iter;
+	struct slave *tmp;
+
+	bond_for_each_slave_rcu(bond, tmp, iter)
+		if (ether_addr_equal_64bits(mac, tmp->dev->dev_addr))
+			return tmp;
+
+	return NULL;
+}
+
 /* Check if the ip is present in arp ip list, or first free slot if ip == 0
  * Returns -1 if not found, index if found
  */
