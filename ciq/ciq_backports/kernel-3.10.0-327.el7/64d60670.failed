KVM: x86: stubs for SMM support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kvm] x86: stubs for SMM support (Paolo Bonzini) [1202825]
Rebuild_FUZZ: 91.23%
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 64d6067057d9658acb8675afcfba549abdb7fc16
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/64d60670.failed

This patch adds the interface between x86.c and the emulator: the
SMBASE register, a new emulator flag, the RSM instruction.  It also
adds a new request bit that will be used by the KVM_SMI ioctl.

	Reviewed-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 64d6067057d9658acb8675afcfba549abdb7fc16)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index 44ac86d26f9f,ab977e763812..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -2564,26 -2668,31 +2570,31 @@@ int kvm_get_msr_common(struct kvm_vcpu 
  		 * multiplying by zero otherwise.
  		 */
  	case MSR_EBC_FREQUENCY_ID:
 -		msr_info->data = 1 << 24;
 +		data = 1 << 24;
  		break;
  	case MSR_IA32_APICBASE:
 -		msr_info->data = kvm_get_apic_base(vcpu);
 +		data = kvm_get_apic_base(vcpu);
  		break;
  	case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:
 -		return kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);
 +		return kvm_x2apic_msr_read(vcpu, msr, pdata);
  		break;
  	case MSR_IA32_TSCDEADLINE:
 -		msr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);
 +		data = kvm_get_lapic_tscdeadline_msr(vcpu);
  		break;
  	case MSR_IA32_TSC_ADJUST:
 -		msr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;
 +		data = (u64)vcpu->arch.ia32_tsc_adjust_msr;
  		break;
  	case MSR_IA32_MISC_ENABLE:
 -		msr_info->data = vcpu->arch.ia32_misc_enable_msr;
 +		data = vcpu->arch.ia32_misc_enable_msr;
  		break;
+ 	case MSR_IA32_SMBASE:
+ 		if (!msr_info->host_initiated)
+ 			return 1;
+ 		msr_info->data = vcpu->arch.smbase;
+ 		break;
  	case MSR_IA32_PERF_STATUS:
  		/* TSC increment by tick */
 -		msr_info->data = 1000ULL;
 +		data = 1000ULL;
  		/* CPU multiplier */
  		data |= (((uint64_t)4ULL) << 40);
  		break;
@@@ -3003,6 -3112,13 +3014,16 @@@ static int kvm_vcpu_ioctl_nmi(struct kv
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int kvm_vcpu_ioctl_smi(struct kvm_vcpu *vcpu)
+ {
+ 	kvm_make_request(KVM_REQ_SMI, vcpu);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 64d6067057d9 (KVM: x86: stubs for SMM support)
  static int vcpu_ioctl_tpr_access_reporting(struct kvm_vcpu *vcpu,
  					   struct kvm_tpr_access_ctl *tac)
  {
@@@ -7057,7 -7421,10 +7123,14 @@@ void kvm_vcpu_reset(struct kvm_vcpu *vc
  	kvm_async_pf_hash_reset(vcpu);
  	vcpu->arch.apf.halted = false;
  
++<<<<<<< HEAD
 +	kvm_pmu_reset(vcpu);
++=======
+ 	if (!init_event) {
+ 		kvm_pmu_reset(vcpu);
+ 		vcpu->arch.smbase = 0x30000;
+ 	}
++>>>>>>> 64d6067057d9 (KVM: x86: stubs for SMM support)
  
  	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));
  	vcpu->arch.regs_avail = ~0;
diff --git a/arch/x86/include/asm/kvm_emulate.h b/arch/x86/include/asm/kvm_emulate.h
index 7410879a41f7..e16466ec473c 100644
--- a/arch/x86/include/asm/kvm_emulate.h
+++ b/arch/x86/include/asm/kvm_emulate.h
@@ -193,6 +193,8 @@ struct x86_emulate_ops {
 	int (*cpl)(struct x86_emulate_ctxt *ctxt);
 	int (*get_dr)(struct x86_emulate_ctxt *ctxt, int dr, ulong *dest);
 	int (*set_dr)(struct x86_emulate_ctxt *ctxt, int dr, ulong value);
+	u64 (*get_smbase)(struct x86_emulate_ctxt *ctxt);
+	void (*set_smbase)(struct x86_emulate_ctxt *ctxt, u64 smbase);
 	int (*set_msr)(struct x86_emulate_ctxt *ctxt, u32 msr_index, u64 data);
 	int (*get_msr)(struct x86_emulate_ctxt *ctxt, u32 msr_index, u64 *pdata);
 	int (*check_pmc)(struct x86_emulate_ctxt *ctxt, u32 pmc);
@@ -264,6 +266,8 @@ enum x86emul_mode {
 
 /* These match some of the HF_* flags defined in kvm_host.h  */
 #define X86EMUL_GUEST_MASK           (1 << 5) /* VCPU is in guest-mode */
+#define X86EMUL_SMM_MASK             (1 << 6)
+#define X86EMUL_SMM_INSIDE_NMI_MASK  (1 << 7)
 
 struct x86_emulate_ctxt {
 	const struct x86_emulate_ops *ops;
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 1442e6fbe132..f68b9bffa4bb 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -366,6 +366,7 @@ struct kvm_vcpu_arch {
 	int32_t apic_arb_prio;
 	int mp_state;
 	u64 ia32_misc_enable_msr;
+	u64 smbase;
 	bool tpr_access_reporting;
 
 	/*
diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c
index c33632e20c48..e48f0b7b4c51 100644
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -2195,6 +2195,14 @@ static int em_lseg(struct x86_emulate_ctxt *ctxt)
 	return rc;
 }
 
+static int em_rsm(struct x86_emulate_ctxt *ctxt)
+{
+	if ((ctxt->emul_flags & X86EMUL_SMM_MASK) == 0)
+		return emulate_ud(ctxt);
+
+	return X86EMUL_UNHANDLEABLE;
+}
+
 static void
 setup_syscalls_segments(struct x86_emulate_ctxt *ctxt,
 			struct desc_struct *cs, struct desc_struct *ss)
@@ -4141,7 +4149,7 @@ static const struct opcode twobyte_table[256] = {
 	F(DstMem | SrcReg | Src2CL | ModRM, em_shld), N, N,
 	/* 0xA8 - 0xAF */
 	I(Stack | Src2GS, em_push_sreg), I(Stack | Src2GS, em_pop_sreg),
-	DI(ImplicitOps, rsm),
+	II(No64 | EmulateOnUD | ImplicitOps, em_rsm, rsm),
 	F(DstMem | SrcReg | ModRM | BitOp | Lock | PageTable, em_bts),
 	F(DstMem | SrcReg | Src2ImmByte | ModRM, em_shrd),
 	F(DstMem | SrcReg | Src2CL | ModRM, em_shrd),
diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c
index ad5b409427db..6c28e6ca880f 100644
--- a/arch/x86/kvm/lapic.c
+++ b/arch/x86/kvm/lapic.c
@@ -789,7 +789,9 @@ static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,
 		break;
 
 	case APIC_DM_SMI:
-		apic_debug("Ignoring guest SMI\n");
+		result = 1;
+		kvm_make_request(KVM_REQ_SMI, vcpu);
+		kvm_vcpu_kick(vcpu);
 		break;
 
 	case APIC_DM_NMI:
diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c
index e21cbdc1b064..88c11ae26055 100644
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -3380,6 +3380,7 @@ static int (*const svm_exit_handlers[])(struct vcpu_svm *svm) = {
 	[SVM_EXIT_MWAIT]			= mwait_interception,
 	[SVM_EXIT_XSETBV]			= xsetbv_interception,
 	[SVM_EXIT_NPF]				= pf_interception,
+	[SVM_EXIT_RSM]                          = emulate_on_interception,
 };
 
 static void dump_vmcb(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/x86.c
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index 9984ea276f63..72f689296785 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -136,6 +136,7 @@ static inline bool is_error_page(struct page *page)
 #define KVM_REQ_SCAN_IOAPIC       21
 #define KVM_REQ_GLOBAL_CLOCK_UPDATE 22
 #define KVM_REQ_APIC_PAGE_RELOAD  25
+#define KVM_REQ_SMI               26
 
 #define KVM_USERSPACE_IRQ_SOURCE_ID		0
 #define KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID	1
