mm: soft-offline: fix num_poisoned_pages counting on concurrent events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [mm] soft-offline: fix num_poisoned_pages counting on concurrent events (Tomoaki Nishimura) [1226196]
Rebuild_FUZZ: 97.06%
commit-author Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
commit 602498f9aa43d4951eece3fd6ad95a6d0a78d537
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/602498f9.failed

If multiple soft offline events hit one free page/hugepage concurrently,
soft_offline_page() can handle the free page/hugepage multiple times,
which makes num_poisoned_pages counter increased more than once.  This
patch fixes this wrong counting by checking TestSetPageHWPoison for normal
papes and by checking the return value of dequeue_hwpoisoned_huge_page()
for hugepages.

	Signed-off-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Acked-by: Dean Nelson <dnelson@redhat.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: <stable@vger.kernel.org>	[3.14+]
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 602498f9aa43d4951eece3fd6ad95a6d0a78d537)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/memory-failure.c
diff --cc mm/memory-failure.c
index 96911c114194,501820c815b3..000000000000
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@@ -1749,3 -1716,75 +1749,78 @@@ static int __soft_offline_page(struct p
  	}
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * soft_offline_page - Soft offline a page.
+  * @page: page to offline
+  * @flags: flags. Same as memory_failure().
+  *
+  * Returns 0 on success, otherwise negated errno.
+  *
+  * Soft offline a page, by migration or invalidation,
+  * without killing anything. This is for the case when
+  * a page is not corrupted yet (so it's still valid to access),
+  * but has had a number of corrected errors and is better taken
+  * out.
+  *
+  * The actual policy on when to do that is maintained by
+  * user space.
+  *
+  * This should never impact any application or cause data loss,
+  * however it might take some time.
+  *
+  * This is not a 100% solution for all memory, but tries to be
+  * ``good enough'' for the majority of memory.
+  */
+ int soft_offline_page(struct page *page, int flags)
+ {
+ 	int ret;
+ 	unsigned long pfn = page_to_pfn(page);
+ 	struct page *hpage = compound_head(page);
+ 
+ 	if (PageHWPoison(page)) {
+ 		pr_info("soft offline: %#lx page already poisoned\n", pfn);
+ 		return -EBUSY;
+ 	}
+ 	if (!PageHuge(page) && PageTransHuge(hpage)) {
+ 		if (PageAnon(hpage) && unlikely(split_huge_page(hpage))) {
+ 			pr_info("soft offline: %#lx: failed to split THP\n",
+ 				pfn);
+ 			return -EBUSY;
+ 		}
+ 	}
+ 
+ 	get_online_mems();
+ 
+ 	/*
+ 	 * Isolate the page, so that it doesn't get reallocated if it
+ 	 * was free. This flag should be kept set until the source page
+ 	 * is freed and PG_hwpoison on it is set.
+ 	 */
+ 	if (get_pageblock_migratetype(page) != MIGRATE_ISOLATE)
+ 		set_migratetype_isolate(page, true);
+ 
+ 	ret = get_any_page(page, pfn, flags);
+ 	put_online_mems();
+ 	if (ret > 0) { /* for in-use pages */
+ 		if (PageHuge(page))
+ 			ret = soft_offline_huge_page(page, flags);
+ 		else
+ 			ret = __soft_offline_page(page, flags);
+ 	} else if (ret == 0) { /* for free pages */
+ 		if (PageHuge(page)) {
+ 			set_page_hwpoison_huge_page(hpage);
+ 			if (!dequeue_hwpoisoned_huge_page(hpage))
+ 				atomic_long_add(1 << compound_order(hpage),
+ 					&num_poisoned_pages);
+ 		} else {
+ 			if (!TestSetPageHWPoison(page))
+ 				atomic_long_inc(&num_poisoned_pages);
+ 		}
+ 	}
+ 	unset_migratetype_isolate(page, MIGRATE_MOVABLE);
+ 	return ret;
+ }
++>>>>>>> 602498f9aa43 (mm: soft-offline: fix num_poisoned_pages counting on concurrent events)
* Unmerged path mm/memory-failure.c
