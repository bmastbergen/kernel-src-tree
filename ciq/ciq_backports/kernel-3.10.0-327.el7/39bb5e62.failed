net: skb_fclone_busy() needs to detect orphaned skb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] skb_fclone_busy() needs to detect orphaned skb (Florian Westphal) [1151756]
Rebuild_FUZZ: 94.85%
commit-author Eric Dumazet <edumazet@google.com>
commit 39bb5e62867de82b269b07df900165029b928359
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/39bb5e62.failed

Some drivers are unable to perform TX completions in a bound time.
They instead call skb_orphan()

Problem is skb_fclone_busy() has to detect this case, otherwise
we block TCP retransmits and can freeze unlucky tcp sessions on
mostly idle hosts.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
Fixes: 1f3279ae0c13 ("tcp: avoid retransmits of TCP packets hanging in host queues")
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 39bb5e62867de82b269b07df900165029b928359)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/ipv4/tcp_output.c
#	net/xfrm/xfrm_policy.c
diff --cc include/linux/skbuff.h
index 67a799712ba7,6c8b6f604e76..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -771,6 -779,41 +771,44 @@@ static inline struct sk_buff *alloc_skb
  	return __alloc_skb(size, priority, 0, NUMA_NO_NODE);
  }
  
++<<<<<<< HEAD
++=======
+ struct sk_buff *alloc_skb_with_frags(unsigned long header_len,
+ 				     unsigned long data_len,
+ 				     int max_page_order,
+ 				     int *errcode,
+ 				     gfp_t gfp_mask);
+ 
+ /* Layout of fast clones : [skb1][skb2][fclone_ref] */
+ struct sk_buff_fclones {
+ 	struct sk_buff	skb1;
+ 
+ 	struct sk_buff	skb2;
+ 
+ 	atomic_t	fclone_ref;
+ };
+ 
+ /**
+  *	skb_fclone_busy - check if fclone is busy
+  *	@skb: buffer
+  *
+  * Returns true is skb is a fast clone, and its clone is not freed.
+  * Some drivers call skb_orphan() in their ndo_start_xmit(),
+  * so we also check that this didnt happen.
+  */
+ static inline bool skb_fclone_busy(const struct sock *sk,
+ 				   const struct sk_buff *skb)
+ {
+ 	const struct sk_buff_fclones *fclones;
+ 
+ 	fclones = container_of(skb, struct sk_buff_fclones, skb1);
+ 
+ 	return skb->fclone == SKB_FCLONE_ORIG &&
+ 	       fclones->skb2.fclone == SKB_FCLONE_CLONE &&
+ 	       fclones->skb2.sk == sk;
+ }
+ 
++>>>>>>> 39bb5e62867d (net: skb_fclone_busy() needs to detect orphaned skb)
  static inline struct sk_buff *alloc_skb_fclone(unsigned int size,
  					       gfp_t priority)
  {
diff --cc net/ipv4/tcp_output.c
index c50742a4dcce,a3d453b94747..000000000000
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@@ -2044,6 -2118,22 +2044,25 @@@ bool tcp_schedule_loss_probe(struct soc
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ /* Thanks to skb fast clones, we can detect if a prior transmit of
+  * a packet is still in a qdisc or driver queue.
+  * In this case, there is very little point doing a retransmit !
+  * Note: This is called from BH context only.
+  */
+ static bool skb_still_in_host_queue(const struct sock *sk,
+ 				    const struct sk_buff *skb)
+ {
+ 	if (unlikely(skb_fclone_busy(sk, skb))) {
+ 		NET_INC_STATS_BH(sock_net(sk),
+ 				 LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES);
+ 		return true;
+ 	}
+ 	return false;
+ }
+ 
++>>>>>>> 39bb5e62867d (net: skb_fclone_busy() needs to detect orphaned skb)
  /* When probe timeout (PTO) fires, send a new segment if one exists, else
   * retransmit the last segment.
   */
diff --cc net/xfrm/xfrm_policy.c
index f93ccd6902d4,88bf289abdc9..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -1831,7 -1959,13 +1831,17 @@@ static int xdst_queue_output(struct soc
  	unsigned long sched_next;
  	struct dst_entry *dst = skb_dst(skb);
  	struct xfrm_dst *xdst = (struct xfrm_dst *) dst;
++<<<<<<< HEAD
 +	struct xfrm_policy_queue *pq = &xdst->pols[0]->polq;
++=======
+ 	struct xfrm_policy *pol = xdst->pols[0];
+ 	struct xfrm_policy_queue *pq = &pol->polq;
+ 
+ 	if (unlikely(skb_fclone_busy(sk, skb))) {
+ 		kfree_skb(skb);
+ 		return 0;
+ 	}
++>>>>>>> 39bb5e62867d (net: skb_fclone_busy() needs to detect orphaned skb)
  
  	if (pq->hold_queue.qlen > XFRM_MAX_QUEUE_LEN) {
  		kfree_skb(skb);
* Unmerged path include/linux/skbuff.h
* Unmerged path net/ipv4/tcp_output.c
* Unmerged path net/xfrm/xfrm_policy.c
