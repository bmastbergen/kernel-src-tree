xfrm: release dst_orig in case of error in xfrm_lookup()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author huaibin Wang <huaibin.wang@6wind.com>
commit ac37e2515c1a89c477459a2020b6bfdedabdb91b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/ac37e251.failed

dst_orig should be released on error. Function like __xfrm_route_forward()
expects that behavior.
Since a recent commit, xfrm_lookup() may also be called by xfrm_lookup_route(),
which expects the opposite.
Let's introduce a new flag (XFRM_LOOKUP_KEEP_DST_REF) to tell what should be
done in case of error.

Fixes: f92ee61982d("xfrm: Generate blackhole routes only from route lookup functions")
	Signed-off-by: huaibin Wang <huaibin.wang@6wind.com>
	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit ac37e2515c1a89c477459a2020b6bfdedabdb91b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/dst.h
#	net/xfrm/xfrm_policy.c
diff --cc include/net/dst.h
index 82d356bbf71e,0fb99a26e973..000000000000
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@@ -488,6 -480,8 +488,11 @@@ extern void		dst_init(void)
  /* Flags for xfrm_lookup flags argument. */
  enum {
  	XFRM_LOOKUP_ICMP = 1 << 0,
++<<<<<<< HEAD
++=======
+ 	XFRM_LOOKUP_QUEUE = 1 << 1,
+ 	XFRM_LOOKUP_KEEP_DST_REF = 1 << 2,
++>>>>>>> ac37e2515c1a (xfrm: release dst_orig in case of error in xfrm_lookup())
  };
  
  struct flowi;
diff --cc net/xfrm/xfrm_policy.c
index 45d7878f13c0,638af0655aaf..000000000000
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@@ -2139,29 -2269,12 +2139,27 @@@ restart
  		 * have the xfrm_state's. We need to wait for KM to
  		 * negotiate new SA's or bail out with error.*/
  		if (net->xfrm.sysctl_larval_drop) {
- 			dst_release(dst);
- 			xfrm_pols_put(pols, drop_pols);
  			XFRM_INC_STATS(net, LINUX_MIB_XFRMOUTNOSTATES);
- 
- 			return ERR_PTR(-EREMOTE);
+ 			err = -EREMOTE;
+ 			goto error;
  		}
 +		if (fl->flowi_flags & FLOWI_FLAG_CAN_SLEEP) {
 +			DECLARE_WAITQUEUE(wait, current);
  
 -		err = -EAGAIN;
 +			add_wait_queue(&net->xfrm.km_waitq, &wait);
 +			set_current_state(TASK_INTERRUPTIBLE);
 +			schedule();
 +			set_current_state(TASK_RUNNING);
 +			remove_wait_queue(&net->xfrm.km_waitq, &wait);
 +
 +			if (!signal_pending(current)) {
 +				dst_release(dst);
 +				goto restart;
 +			}
 +
 +			err = -ERESTART;
 +		} else
 +			err = -EAGAIN;
  
  		XFRM_INC_STATS(net, LINUX_MIB_XFRMOUTNOSTATES);
  		goto error;
@@@ -2222,7 -2336,9 +2221,13 @@@ struct dst_entry *xfrm_lookup_route(str
  				    const struct flowi *fl,
  				    struct sock *sk, int flags)
  {
++<<<<<<< HEAD
 +	struct dst_entry *dst = xfrm_lookup(net, dst_orig, fl, sk, flags);
++=======
+ 	struct dst_entry *dst = xfrm_lookup(net, dst_orig, fl, sk,
+ 					    flags | XFRM_LOOKUP_QUEUE |
+ 					    XFRM_LOOKUP_KEEP_DST_REF);
++>>>>>>> ac37e2515c1a (xfrm: release dst_orig in case of error in xfrm_lookup())
  
  	if (IS_ERR(dst) && PTR_ERR(dst) == -EREMOTE)
  		return make_blackhole(net, dst_orig->ops->family, dst_orig);
* Unmerged path include/net/dst.h
* Unmerged path net/xfrm/xfrm_policy.c
