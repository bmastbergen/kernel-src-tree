ovl: support multiple lower layers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit a78d9f0d5d5ca9054703376c7c23c901807ddd87
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a78d9f0d.failed

Allow "lowerdir=" option to contain multiple lower directories separated by
a colon (e.g. "lowerdir=/bin:/usr/bin").  Colon characters in filenames can
be escaped with a backslash.

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit a78d9f0d5d5ca9054703376c7c23c901807ddd87)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index ab28e68ccbc7,5c495a17a5a3..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -56,10 -56,18 +56,12 @@@ struct ovl_entry 
  		};
  		struct rcu_head rcu;
  	};
 -	unsigned numlower;
 -	struct path lowerstack[];
  };
  
+ #define OVL_MAX_STACK 500
+ 
  const char *ovl_opaque_xattr = "trusted.overlay.opaque";
  
 -static struct dentry *__ovl_dentry_lower(struct ovl_entry *oe)
 -{
 -	return oe->numlower ? oe->lowerstack[0].dentry : NULL;
 -}
  
  enum ovl_path_type ovl_path_type(struct dentry *dentry)
  {
@@@ -643,6 -692,75 +645,78 @@@ static bool ovl_is_allowed_fs_type(stru
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static int ovl_mount_dir_noesc(const char *name, struct path *path)
+ {
+ 	int err = -EINVAL;
+ 
+ 	if (!*name) {
+ 		pr_err("overlayfs: empty lowerdir\n");
+ 		goto out;
+ 	}
+ 	err = kern_path(name, LOOKUP_FOLLOW, path);
+ 	if (err) {
+ 		pr_err("overlayfs: failed to resolve '%s': %i\n", name, err);
+ 		goto out;
+ 	}
+ 	err = -EINVAL;
+ 	if (!ovl_is_allowed_fs_type(path->dentry)) {
+ 		pr_err("overlayfs: filesystem on '%s' not supported\n", name);
+ 		goto out_put;
+ 	}
+ 	if (!S_ISDIR(path->dentry->d_inode->i_mode)) {
+ 		pr_err("overlayfs: '%s' not a directory\n", name);
+ 		goto out_put;
+ 	}
+ 	return 0;
+ 
+ out_put:
+ 	path_put(path);
+ out:
+ 	return err;
+ }
+ 
+ static int ovl_mount_dir(const char *name, struct path *path)
+ {
+ 	int err = -ENOMEM;
+ 	char *tmp = kstrdup(name, GFP_KERNEL);
+ 
+ 	if (tmp) {
+ 		ovl_unescape(tmp);
+ 		err = ovl_mount_dir_noesc(tmp, path);
+ 		kfree(tmp);
+ 	}
+ 	return err;
+ }
+ 
+ static int ovl_lower_dir(const char *name, struct path *path, long *namelen,
+ 			 int *stack_depth)
+ {
+ 	int err;
+ 	struct kstatfs statfs;
+ 
+ 	err = ovl_mount_dir_noesc(name, path);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = vfs_statfs(path, &statfs);
+ 	if (err) {
+ 		pr_err("overlayfs: statfs failed on '%s'\n", name);
+ 		goto out_put;
+ 	}
+ 	*namelen = max(*namelen, statfs.f_namelen);
+ 	*stack_depth = max(*stack_depth, path->mnt->mnt_sb->s_stack_depth);
+ 
+ 	return 0;
+ 
+ out_put:
+ 	path_put(path);
+ out:
+ 	return err;
+ }
+ 
++>>>>>>> a78d9f0d5d5c (ovl: support multiple lower layers)
  /* Workdir should not be subdir of upperdir and vice versa */
  static bool ovl_workdir_ok(struct dentry *workdir, struct dentry *upperdir)
  {
@@@ -655,18 -773,39 +729,52 @@@
  	return ok;
  }
  
+ static unsigned int ovl_split_lowerdirs(char *str)
+ {
+ 	unsigned int ctr = 1;
+ 	char *s, *d;
+ 
+ 	for (s = d = str;; s++, d++) {
+ 		if (*s == '\\') {
+ 			s++;
+ 		} else if (*s == ':') {
+ 			*d = '\0';
+ 			ctr++;
+ 			continue;
+ 		}
+ 		*d = *s;
+ 		if (!*s)
+ 			break;
+ 	}
+ 	return ctr;
+ }
+ 
  static int ovl_fill_super(struct super_block *sb, void *data, int silent)
  {
++<<<<<<< HEAD
 +	struct path lowerpath;
 +	struct path upperpath;
 +	struct path workpath;
 +	struct inode *root_inode;
 +	struct dentry *root_dentry;
 +	struct ovl_entry *oe;
 +	struct ovl_fs *ufs;
 +	struct kstatfs statfs;
 +	const int *upper_stack_depth, *lower_stack_depth;
 +	int *overlay_stack_depth;
++=======
+ 	struct path upperpath = { NULL, NULL };
+ 	struct path workpath = { NULL, NULL };
+ 	struct dentry *root_dentry;
+ 	struct ovl_entry *oe;
+ 	struct ovl_fs *ufs;
+ 	struct path *stack = NULL;
+ 	char *lowertmp;
+ 	char *lower;
+ 	unsigned int numlower;
+ 	unsigned int stacklen = 0;
+ 	unsigned int i;
++>>>>>>> a78d9f0d5d5c (ovl: support multiple lower layers)
  	int err;
  
  	err = -ENOMEM;
@@@ -686,123 -823,126 +794,211 @@@
  		goto out_free_config;
  	}
  
 -	sb->s_stack_depth = 0;
 -	if (ufs->config.upperdir) {
 -		/* FIXME: workdir is not needed for a R/O mount */
 -		if (!ufs->config.workdir) {
 -			pr_err("overlayfs: missing 'workdir'\n");
 -			goto out_free_config;
 -		}
 +	err = -ENOMEM;
 +	oe = ovl_alloc_entry();
 +	if (oe == NULL)
 +		goto out_free_config;
 +
++<<<<<<< HEAD
 +	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 +	if (err)
 +		goto out_free_oe;
 +
 +	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
 +	if (err)
 +		goto out_put_upperpath;
 +
 +	err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +	if (err)
 +		goto out_put_lowerpath;
 +
 +	err = -EINVAL;
 +	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
 +	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
 +	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
 +		pr_err("overlayfs: upperdir or lowerdir or workdir not a directory\n");
 +		goto out_put_workpath;
 +	}
 +
 +	if (upperpath.mnt != workpath.mnt) {
 +		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +		goto out_put_workpath;
 +	}
 +	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +		goto out_put_workpath;
 +	}
 +
 +	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
 +		pr_err("overlayfs: filesystem of upperdir is not supported\n");
 +		goto out_put_workpath;
 +	}
 +
 +	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
 +		pr_err("overlayfs: filesystem of lowerdir is not supported\n");
 +		goto out_put_workpath;
 +	}
 +
 +	err = vfs_statfs(&lowerpath, &statfs);
 +	if (err) {
 +		pr_err("overlayfs: statfs failed on lowerpath\n");
 +		goto out_put_workpath;
 +	}
 +	ufs->lower_namelen = statfs.f_namelen;
 +
 +	upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +	lower_stack_depth = get_s_stack_depth(lowerpath.mnt->mnt_sb);
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!upper_stack_depth || !lower_stack_depth || !overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_put_workpath;
 +	}
 +
 +	*overlay_stack_depth = max(*upper_stack_depth, *lower_stack_depth) + 1;
  
 +	err = -EINVAL;
 +	if (*overlay_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
++=======
+ 		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
+ 		if (err)
+ 			goto out_free_config;
+ 
+ 		err = ovl_mount_dir(ufs->config.workdir, &workpath);
+ 		if (err)
+ 			goto out_put_upperpath;
+ 
+ 		if (upperpath.mnt != workpath.mnt) {
+ 			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
+ 			goto out_put_workpath;
+ 		}
+ 		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
+ 			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
+ 			goto out_put_workpath;
+ 		}
+ 		sb->s_stack_depth = upperpath.mnt->mnt_sb->s_stack_depth;
+ 	}
+ 	err = -ENOMEM;
+ 	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
+ 	if (!lowertmp)
+ 		goto out_put_workpath;
+ 
+ 	err = -EINVAL;
+ 	stacklen = ovl_split_lowerdirs(lowertmp);
+ 	if (stacklen > OVL_MAX_STACK)
+ 		goto out_free_lowertmp;
+ 
+ 	stack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);
+ 	if (!stack)
+ 		goto out_free_lowertmp;
+ 
+ 	lower = lowertmp;
+ 	for (numlower = 0; numlower < stacklen; numlower++) {
+ 		err = ovl_lower_dir(lower, &stack[numlower],
+ 				    &ufs->lower_namelen, &sb->s_stack_depth);
+ 		if (err)
+ 			goto out_put_lowerpath;
+ 
+ 		lower = strchr(lower, '\0') + 1;
+ 	}
+ 
+ 	err = -EINVAL;
+ 	sb->s_stack_depth++;
+ 	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
++>>>>>>> a78d9f0d5d5c (ovl: support multiple lower layers)
  		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 -		goto out_put_lowerpath;
 +		goto out_put_workpath;
  	}
  
 -	if (ufs->config.upperdir) {
 -		ufs->upper_mnt = clone_private_mount(&upperpath);
 -		err = PTR_ERR(ufs->upper_mnt);
 -		if (IS_ERR(ufs->upper_mnt)) {
 -			pr_err("overlayfs: failed to clone upperpath\n");
 -			goto out_put_lowerpath;
 -		}
 +	ufs->upper_mnt = clone_private_mount(&upperpath);
 +	err = PTR_ERR(ufs->upper_mnt);
 +	if (IS_ERR(ufs->upper_mnt)) {
 +		pr_err("overlayfs: failed to clone upperpath\n");
 +		goto out_put_workpath;
 +	}
  
 -		ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
 -		err = PTR_ERR(ufs->workdir);
 -		if (IS_ERR(ufs->workdir)) {
 -			pr_err("overlayfs: failed to create directory %s/%s\n",
 -			       ufs->config.workdir, OVL_WORKDIR_NAME);
 -			goto out_put_upper_mnt;
 -		}
++<<<<<<< HEAD
 +	ufs->lower_mnt = clone_private_mount(&lowerpath);
 +	err = PTR_ERR(ufs->lower_mnt);
 +	if (IS_ERR(ufs->lower_mnt)) {
 +		pr_err("overlayfs: failed to clone lowerpath\n");
 +		goto out_put_upper_mnt;
  	}
  
 +	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
 +	err = PTR_ERR(ufs->workdir);
 +	if (IS_ERR(ufs->workdir)) {
 +		pr_err("overlayfs: failed to create directory %s/%s\n",
 +		       ufs->config.workdir, OVL_WORKDIR_NAME);
 +		goto out_put_lower_mnt;
 +	}
 +
 +	/*
 +	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 +	 * will fail instead of modifying lower fs.
 +	 */
 +	ufs->lower_mnt->mnt_flags |= MNT_READONLY;
 +
 +	/* If the upper fs is r/o, we mark overlayfs r/o too */
 +	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
++=======
+ 	ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
+ 	if (ufs->lower_mnt == NULL)
+ 		goto out_put_workdir;
+ 	for (i = 0; i < numlower; i++) {
+ 		struct vfsmount *mnt = clone_private_mount(&stack[i]);
+ 
+ 		if (IS_ERR(mnt)) {
+ 			pr_err("overlayfs: failed to clone lowerpath\n");
+ 			goto out_put_lower_mnt;
+ 		}
+ 		/*
+ 		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
+ 		 * will fail instead of modifying lower fs.
+ 		 */
+ 		mnt->mnt_flags |= MNT_READONLY;
+ 
+ 		ufs->lower_mnt[ufs->numlower] = mnt;
+ 		ufs->numlower++;
+ 	}
+ 
+ 	/* If the upper fs is r/o or nonexistent, we mark overlayfs r/o too */
+ 	if (!ufs->upper_mnt || (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY))
++>>>>>>> a78d9f0d5d5c (ovl: support multiple lower layers)
  		sb->s_flags |= MS_RDONLY;
  
  	sb->s_d_op = &ovl_dentry_operations;
  
  	err = -ENOMEM;
++<<<<<<< HEAD
 +	root_inode = ovl_new_inode(sb, S_IFDIR, oe);
 +	if (!root_inode)
 +		goto out_put_workdir;
++=======
+ 	oe = ovl_alloc_entry(numlower);
+ 	if (!oe)
+ 		goto out_put_lower_mnt;
++>>>>>>> a78d9f0d5d5c (ovl: support multiple lower layers)
  
 -	root_dentry = d_make_root(ovl_new_inode(sb, S_IFDIR, oe));
 +	root_dentry = d_make_root(root_inode);
  	if (!root_dentry)
 -		goto out_free_oe;
 +		goto out_put_workdir;
  
  	mntput(upperpath.mnt);
- 	mntput(lowerpath.mnt);
+ 	for (i = 0; i < numlower; i++)
+ 		mntput(stack[i].mnt);
  	path_put(&workpath);
+ 	kfree(lowertmp);
  
  	oe->__upperdentry = upperpath.dentry;
++<<<<<<< HEAD
 +	oe->lowerdentry = lowerpath.dentry;
++=======
+ 	for (i = 0; i < numlower; i++) {
+ 		oe->lowerstack[i].dentry = stack[i].dentry;
+ 		oe->lowerstack[i].mnt = ufs->lower_mnt[i];
+ 	}
++>>>>>>> a78d9f0d5d5c (ovl: support multiple lower layers)
  
  	root_dentry->d_fsdata = oe;
  
@@@ -813,20 -953,26 +1009,29 @@@
  
  	return 0;
  
 -out_free_oe:
 -	kfree(oe);
 -out_put_lower_mnt:
 -	for (i = 0; i < ufs->numlower; i++)
 -		mntput(ufs->lower_mnt[i]);
 -	kfree(ufs->lower_mnt);
  out_put_workdir:
  	dput(ufs->workdir);
 +out_put_lower_mnt:
 +	mntput(ufs->lower_mnt);
  out_put_upper_mnt:
  	mntput(ufs->upper_mnt);
++<<<<<<< HEAD
++=======
+ out_put_lowerpath:
+ 	for (i = 0; i < numlower; i++)
+ 		path_put(&stack[i]);
+ 	kfree(stack);
+ out_free_lowertmp:
+ 	kfree(lowertmp);
++>>>>>>> a78d9f0d5d5c (ovl: support multiple lower layers)
  out_put_workpath:
  	path_put(&workpath);
 +out_put_lowerpath:
 +	path_put(&lowerpath);
  out_put_upperpath:
  	path_put(&upperpath);
 +out_free_oe:
 +	kfree(oe);
  out_free_config:
  	kfree(ufs->config.lowerdir);
  	kfree(ufs->config.upperdir);
diff --git a/Documentation/filesystems/overlayfs.txt b/Documentation/filesystems/overlayfs.txt
index a27c950ece61..b37092886dcc 100644
--- a/Documentation/filesystems/overlayfs.txt
+++ b/Documentation/filesystems/overlayfs.txt
@@ -159,6 +159,18 @@ overlay filesystem (though an operation on the name of the file such as
 rename or unlink will of course be noticed and handled).
 
 
+Multiple lower layers
+---------------------
+
+Multiple lower layers can now be given using the the colon (":") as a
+separator character between the directory names.  For example:
+
+  mount -t overlay overlay -olowerdir=/lower1:/lower2:/lower3 /merged
+
+As the example shows, "upperdir=" and "workdir=" may be omitted.  In that case
+the overlay will be read-only.
+
+
 Non-standard behavior
 ---------------------
 
* Unmerged path fs/overlayfs/super.c
