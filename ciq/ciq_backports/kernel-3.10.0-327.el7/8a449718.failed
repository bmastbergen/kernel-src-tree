arch: Cleanup read_barrier_depends() and comments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [arch] Cleanup read_barrier_depends() and comments (Alexander Duyck) [1205268]
Rebuild_FUZZ: 93.48%
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 8a449718414ff10b9d5559ed3e8e09c7178774f2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8a449718.failed

This patch is meant to cleanup the handling of read_barrier_depends and
smp_read_barrier_depends.  In multiple spots in the kernel headers
read_barrier_depends is defined as "do {} while (0)", however we then go
into the SMP vs non-SMP sections and have the SMP version reference
read_barrier_depends, and the non-SMP define it as yet another empty
do/while.

With this commit I went through and cleaned out the duplicate definitions
and reduced the number of definitions down to 2 per header.  In addition I
moved the 50 line comments for the macro from the x86 and mips headers that
defined it as an empty do/while to those that were actually defining the
macro, alpha and blackfin.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8a449718414ff10b9d5559ed3e8e09c7178774f2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/alpha/include/asm/barrier.h
#	arch/ia64/include/asm/barrier.h
#	arch/mips/include/asm/barrier.h
#	arch/x86/include/asm/barrier.h
diff --cc arch/alpha/include/asm/barrier.h
index ce8860a0b32d,77516c87255d..000000000000
--- a/arch/alpha/include/asm/barrier.h
+++ b/arch/alpha/include/asm/barrier.h
@@@ -3,17 -3,62 +3,72 @@@
  
  #include <asm/compiler.h>
  
 -#define mb()	__asm__ __volatile__("mb": : :"memory")
 -#define rmb()	__asm__ __volatile__("mb": : :"memory")
 -#define wmb()	__asm__ __volatile__("wmb": : :"memory")
 +#define mb() \
 +__asm__ __volatile__("mb": : :"memory")
  
++<<<<<<< HEAD
 +#define rmb() \
 +__asm__ __volatile__("mb": : :"memory")
 +
 +#define wmb() \
 +__asm__ __volatile__("wmb": : :"memory")
 +
 +#define read_barrier_depends() \
 +__asm__ __volatile__("mb": : :"memory")
++=======
+ /**
+  * read_barrier_depends - Flush all pending reads that subsequents reads
+  * depend on.
+  *
+  * No data-dependent reads from memory-like regions are ever reordered
+  * over this barrier.  All reads preceding this primitive are guaranteed
+  * to access memory (but not necessarily other CPUs' caches) before any
+  * reads following this primitive that depend on the data return by
+  * any of the preceding reads.  This primitive is much lighter weight than
+  * rmb() on most CPUs, and is never heavier weight than is
+  * rmb().
+  *
+  * These ordering constraints are respected by both the local CPU
+  * and the compiler.
+  *
+  * Ordering is not guaranteed by anything other than these primitives,
+  * not even by data dependencies.  See the documentation for
+  * memory_barrier() for examples and URLs to more information.
+  *
+  * For example, the following code would force ordering (the initial
+  * value of "a" is zero, "b" is one, and "p" is "&a"):
+  *
+  * <programlisting>
+  *	CPU 0				CPU 1
+  *
+  *	b = 2;
+  *	memory_barrier();
+  *	p = &b;				q = p;
+  *					read_barrier_depends();
+  *					d = *q;
+  * </programlisting>
+  *
+  * because the read of "*q" depends on the read of "p" and these
+  * two reads are separated by a read_barrier_depends().  However,
+  * the following code, with the same initial values for "a" and "b":
+  *
+  * <programlisting>
+  *	CPU 0				CPU 1
+  *
+  *	a = 2;
+  *	memory_barrier();
+  *	b = 3;				y = b;
+  *					read_barrier_depends();
+  *					x = a;
+  * </programlisting>
+  *
+  * does not enforce ordering, since there is no data dependency between
+  * the read of "a" and the read of "b".  Therefore, on some CPUs, such
+  * as Alpha, "y" could be set to 3 and "x" to 0.  Use rmb()
+  * in cases like this where there are no data dependencies.
+  */
+ #define read_barrier_depends() __asm__ __volatile__("mb": : :"memory")
++>>>>>>> 8a449718414f (arch: Cleanup read_barrier_depends() and comments)
  
  #ifdef CONFIG_SMP
  #define __ASM_SMP_MB	"\tmb\n"
diff --cc arch/ia64/include/asm/barrier.h
index 60576e06b6fb,e8fffb03963c..000000000000
--- a/arch/ia64/include/asm/barrier.h
+++ b/arch/ia64/include/asm/barrier.h
@@@ -42,16 -41,39 +41,52 @@@
  
  #ifdef CONFIG_SMP
  # define smp_mb()	mb()
++<<<<<<< HEAD
 +# define smp_rmb()	rmb()
 +# define smp_wmb()	wmb()
 +# define smp_read_barrier_depends()	read_barrier_depends()
 +#else
 +# define smp_mb()	barrier()
 +# define smp_rmb()	barrier()
 +# define smp_wmb()	barrier()
 +# define smp_read_barrier_depends()	do { } while(0)
 +#endif
 +
++=======
+ #else
+ # define smp_mb()	barrier()
+ #endif
+ 
+ #define smp_rmb()	smp_mb()
+ #define smp_wmb()	smp_mb()
+ 
+ #define read_barrier_depends()		do { } while (0)
+ #define smp_read_barrier_depends()	do { } while (0)
+ 
+ #define smp_mb__before_atomic()	barrier()
+ #define smp_mb__after_atomic()	barrier()
+ 
+ /*
+  * IA64 GCC turns volatile stores into st.rel and volatile loads into ld.acq no
+  * need for asm trickery!
+  */
+ 
+ #define smp_store_release(p, v)						\
+ do {									\
+ 	compiletime_assert_atomic_type(*p);				\
+ 	barrier();							\
+ 	ACCESS_ONCE(*p) = (v);						\
+ } while (0)
+ 
+ #define smp_load_acquire(p)						\
+ ({									\
+ 	typeof(*p) ___p1 = ACCESS_ONCE(*p);				\
+ 	compiletime_assert_atomic_type(*p);				\
+ 	barrier();							\
+ 	___p1;								\
+ })
+ 
++>>>>>>> 8a449718414f (arch: Cleanup read_barrier_depends() and comments)
  /*
   * XXX check on this ---I suspect what Linus really wants here is
   * acquire vs release semantics but we can't discuss this stuff with
diff --cc arch/mips/include/asm/barrier.h
index 314ab5532019,3d69aa829a76..000000000000
--- a/arch/mips/include/asm/barrier.h
+++ b/arch/mips/include/asm/barrier.h
@@@ -10,58 -10,6 +10,61 @@@
  
  #include <asm/addrspace.h>
  
++<<<<<<< HEAD
 +/*
 + * read_barrier_depends - Flush all pending reads that subsequents reads
 + * depend on.
 + *
 + * No data-dependent reads from memory-like regions are ever reordered
 + * over this barrier.  All reads preceding this primitive are guaranteed
 + * to access memory (but not necessarily other CPUs' caches) before any
 + * reads following this primitive that depend on the data return by
 + * any of the preceding reads.	This primitive is much lighter weight than
 + * rmb() on most CPUs, and is never heavier weight than is
 + * rmb().
 + *
 + * These ordering constraints are respected by both the local CPU
 + * and the compiler.
 + *
 + * Ordering is not guaranteed by anything other than these primitives,
 + * not even by data dependencies.  See the documentation for
 + * memory_barrier() for examples and URLs to more information.
 + *
 + * For example, the following code would force ordering (the initial
 + * value of "a" is zero, "b" is one, and "p" is "&a"):
 + *
 + * <programlisting>
 + *	CPU 0				CPU 1
 + *
 + *	b = 2;
 + *	memory_barrier();
 + *	p = &b;				q = p;
 + *					read_barrier_depends();
 + *					d = *q;
 + * </programlisting>
 + *
 + * because the read of "*q" depends on the read of "p" and these
 + * two reads are separated by a read_barrier_depends().	 However,
 + * the following code, with the same initial values for "a" and "b":
 + *
 + * <programlisting>
 + *	CPU 0				CPU 1
 + *
 + *	a = 2;
 + *	memory_barrier();
 + *	b = 3;				y = b;
 + *					read_barrier_depends();
 + *					x = a;
 + * </programlisting>
 + *
 + * does not enforce ordering, since there is no data dependency between
 + * the read of "a" and the read of "b".	 Therefore, on some CPUs, such
 + * as Alpha, "y" could be set to 3 and "x" to 0.  Use rmb()
 + * in cases like this where there are no data dependencies.
 + */
 +
++=======
++>>>>>>> 8a449718414f (arch: Cleanup read_barrier_depends() and comments)
  #define read_barrier_depends()		do { } while(0)
  #define smp_read_barrier_depends()	do { } while(0)
  
diff --cc arch/x86/include/asm/barrier.h
index 72b200c1716e,5238000285c1..000000000000
--- a/arch/x86/include/asm/barrier.h
+++ b/arch/x86/include/asm/barrier.h
@@@ -85,12 -31,7 +31,16 @@@
  #else
  # define smp_rmb()	barrier()
  #endif
++<<<<<<< HEAD
 +#ifdef CONFIG_X86_OOSTORE
 +# define smp_wmb() 	wmb()
 +#else
 +# define smp_wmb()	barrier()
 +#endif
 +#define smp_read_barrier_depends()	read_barrier_depends()
++=======
+ #define smp_wmb()	barrier()
++>>>>>>> 8a449718414f (arch: Cleanup read_barrier_depends() and comments)
  #define set_mb(var, value) do { (void)xchg(&var, value); } while (0)
  #else /* !SMP */
  #define smp_mb()	barrier()
@@@ -99,11 -40,13 +49,17 @@@
  #define set_mb(var, value) do { var = value; barrier(); } while (0)
  #endif /* SMP */
  
++<<<<<<< HEAD
 +#if defined(CONFIG_X86_OOSTORE) || defined(CONFIG_X86_PPRO_FENCE)
++=======
+ #define read_barrier_depends()		do { } while (0)
+ #define smp_read_barrier_depends()	do { } while (0)
+ 
+ #if defined(CONFIG_X86_PPRO_FENCE)
++>>>>>>> 8a449718414f (arch: Cleanup read_barrier_depends() and comments)
  
  /*
 - * For this option x86 doesn't have a strong TSO memory
 + * For either of these options x86 doesn't have a strong TSO memory
   * model and we should fall back to full barriers.
   */
  
* Unmerged path arch/alpha/include/asm/barrier.h
diff --git a/arch/blackfin/include/asm/barrier.h b/arch/blackfin/include/asm/barrier.h
index ebb189507dd7..aaaff2dcb186 100644
--- a/arch/blackfin/include/asm/barrier.h
+++ b/arch/blackfin/include/asm/barrier.h
@@ -22,6 +22,57 @@
 # define mb()	do { barrier(); smp_check_barrier(); smp_mark_barrier(); } while (0)
 # define rmb()	do { barrier(); smp_check_barrier(); } while (0)
 # define wmb()	do { barrier(); smp_mark_barrier(); } while (0)
+/*
+ * read_barrier_depends - Flush all pending reads that subsequents reads
+ * depend on.
+ *
+ * No data-dependent reads from memory-like regions are ever reordered
+ * over this barrier.  All reads preceding this primitive are guaranteed
+ * to access memory (but not necessarily other CPUs' caches) before any
+ * reads following this primitive that depend on the data return by
+ * any of the preceding reads.  This primitive is much lighter weight than
+ * rmb() on most CPUs, and is never heavier weight than is
+ * rmb().
+ *
+ * These ordering constraints are respected by both the local CPU
+ * and the compiler.
+ *
+ * Ordering is not guaranteed by anything other than these primitives,
+ * not even by data dependencies.  See the documentation for
+ * memory_barrier() for examples and URLs to more information.
+ *
+ * For example, the following code would force ordering (the initial
+ * value of "a" is zero, "b" is one, and "p" is "&a"):
+ *
+ * <programlisting>
+ *	CPU 0				CPU 1
+ *
+ *	b = 2;
+ *	memory_barrier();
+ *	p = &b;				q = p;
+ *					read_barrier_depends();
+ *					d = *q;
+ * </programlisting>
+ *
+ * because the read of "*q" depends on the read of "p" and these
+ * two reads are separated by a read_barrier_depends().  However,
+ * the following code, with the same initial values for "a" and "b":
+ *
+ * <programlisting>
+ *	CPU 0				CPU 1
+ *
+ *	a = 2;
+ *	memory_barrier();
+ *	b = 3;				y = b;
+ *					read_barrier_depends();
+ *					x = a;
+ * </programlisting>
+ *
+ * does not enforce ordering, since there is no data dependency between
+ * the read of "a" and the read of "b".  Therefore, on some CPUs, such
+ * as Alpha, "y" could be set to 3 and "x" to 0.  Use rmb()
+ * in cases like this where there are no data dependencies.
+ */
 # define read_barrier_depends()	do { barrier(); smp_check_barrier(); } while (0)
 #else
 # define mb()	barrier()
* Unmerged path arch/ia64/include/asm/barrier.h
diff --git a/arch/metag/include/asm/barrier.h b/arch/metag/include/asm/barrier.h
index c90bfc6bf648..5013918b054b 100644
--- a/arch/metag/include/asm/barrier.h
+++ b/arch/metag/include/asm/barrier.h
@@ -45,8 +45,6 @@ static inline void wmb(void)
 	wr_fence();
 }
 
-#define read_barrier_depends()  do { } while (0)
-
 #ifndef CONFIG_SMP
 #define fence()		do { } while (0)
 #define smp_mb()        barrier()
@@ -79,7 +77,10 @@ static inline void fence(void)
 #define smp_wmb()       barrier()
 #endif
 #endif
-#define smp_read_barrier_depends()     do { } while (0)
+
+#define read_barrier_depends()		do { } while (0)
+#define smp_read_barrier_depends()	do { } while (0)
+
 #define set_mb(var, value) do { var = value; smp_mb(); } while (0)
 
 #endif /* _ASM_METAG_BARRIER_H */
* Unmerged path arch/mips/include/asm/barrier.h
diff --git a/arch/powerpc/include/asm/barrier.h b/arch/powerpc/include/asm/barrier.h
index bab79a110c7b..cb6d66c6e3e1 100644
--- a/arch/powerpc/include/asm/barrier.h
+++ b/arch/powerpc/include/asm/barrier.h
@@ -33,7 +33,6 @@
 #define mb()   __asm__ __volatile__ ("sync" : : : "memory")
 #define rmb()  __asm__ __volatile__ ("sync" : : : "memory")
 #define wmb()  __asm__ __volatile__ ("sync" : : : "memory")
-#define read_barrier_depends()  do { } while(0)
 
 #define set_mb(var, value)	do { var = value; mb(); } while (0)
 
@@ -50,16 +49,17 @@
 #define smp_mb()	mb()
 #define smp_rmb()	__lwsync()
 #define smp_wmb()	__asm__ __volatile__ (stringify_in_c(SMPWMB) : : :"memory")
-#define smp_read_barrier_depends()	read_barrier_depends()
 #else
 #define __lwsync()	barrier()
 
 #define smp_mb()	barrier()
 #define smp_rmb()	barrier()
 #define smp_wmb()	barrier()
-#define smp_read_barrier_depends()	do { } while(0)
 #endif /* CONFIG_SMP */
 
+#define read_barrier_depends()		do { } while (0)
+#define smp_read_barrier_depends()	do { } while (0)
+
 /*
  * This is a barrier which prevents following instructions from being
  * started until the value of the argument x is known.  For example, if
diff --git a/arch/s390/include/asm/barrier.h b/arch/s390/include/asm/barrier.h
index 19ff956b752b..f1a2a45f45d4 100644
--- a/arch/s390/include/asm/barrier.h
+++ b/arch/s390/include/asm/barrier.h
@@ -22,11 +22,12 @@
 
 #define rmb()				mb()
 #define wmb()				mb()
-#define read_barrier_depends()		do { } while(0)
 #define smp_mb()			mb()
 #define smp_rmb()			rmb()
 #define smp_wmb()			wmb()
-#define smp_read_barrier_depends()	read_barrier_depends()
+
+#define read_barrier_depends()		do { } while (0)
+#define smp_read_barrier_depends()	do { } while (0)
 
 #define smp_mb__before_atomic()		smp_mb()
 #define smp_mb__after_atomic()		smp_mb()
diff --git a/arch/sparc/include/asm/barrier_64.h b/arch/sparc/include/asm/barrier_64.h
index 95d45986f908..6f2f80be675c 100644
--- a/arch/sparc/include/asm/barrier_64.h
+++ b/arch/sparc/include/asm/barrier_64.h
@@ -37,7 +37,6 @@ do {	__asm__ __volatile__("ba,pt	%%xcc, 1f\n\t" \
 #define rmb()	__asm__ __volatile__("":::"memory")
 #define wmb()	__asm__ __volatile__("":::"memory")
 
-#define read_barrier_depends()		do { } while(0)
 #define set_mb(__var, __value) \
 	do { __var = __value; membar_safe("#StoreLoad"); } while(0)
 
@@ -51,6 +50,7 @@ do {	__asm__ __volatile__("ba,pt	%%xcc, 1f\n\t" \
 #define smp_wmb()	__asm__ __volatile__("":::"memory")
 #endif
 
-#define smp_read_barrier_depends()	do { } while(0)
+#define read_barrier_depends()		do { } while (0)
+#define smp_read_barrier_depends()	do { } while (0)
 
 #endif /* !(__SPARC64_BARRIER_H) */
* Unmerged path arch/x86/include/asm/barrier.h
diff --git a/arch/x86/um/asm/barrier.h b/arch/x86/um/asm/barrier.h
index 7d01b8c56c00..f3af36d8ba47 100644
--- a/arch/x86/um/asm/barrier.h
+++ b/arch/x86/um/asm/barrier.h
@@ -29,8 +29,6 @@
 
 #endif /* CONFIG_X86_32 */
 
-#define read_barrier_depends()	do { } while (0)
-
 #ifdef CONFIG_SMP
 
 #define smp_mb()	mb()
@@ -46,7 +44,6 @@
 #define smp_wmb()	barrier()
 #endif /* CONFIG_X86_OOSTORE */
 
-#define smp_read_barrier_depends()	read_barrier_depends()
 #define set_mb(var, value) do { (void)xchg(&var, value); } while (0)
 
 #else /* CONFIG_SMP */
@@ -54,11 +51,13 @@
 #define smp_mb()	barrier()
 #define smp_rmb()	barrier()
 #define smp_wmb()	barrier()
-#define smp_read_barrier_depends()	do { } while (0)
 #define set_mb(var, value) do { var = value; barrier(); } while (0)
 
 #endif /* CONFIG_SMP */
 
+#define read_barrier_depends()		do { } while (0)
+#define smp_read_barrier_depends()	do { } while (0)
+
 /*
  * Stop RDTSC speculation. This is needed when you need to use RDTSC
  * (or get_cycles or vread that possibly accesses the TSC) in a defined
