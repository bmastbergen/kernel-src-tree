cxgb4: Remove dead function t4_read_edc and t4_read_mc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit 75daacc7eae9cc7b3bdebb854c26840a48e0586a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/75daacc7.failed

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 75daacc7eae9cc7b3bdebb854c26840a48e0586a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
#	drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index dddf17cba9bf,7988f5ea3098..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@@ -1011,10 -1208,31 +1011,38 @@@ int t4_config_rss_range(struct adapter 
  			int start, int n, const u16 *rspq, unsigned int nrspq);
  int t4_config_glbl_rss(struct adapter *adapter, int mbox, unsigned int mode,
  		       unsigned int flags);
++<<<<<<< HEAD
 +int t4_mc_read(struct adapter *adap, int idx, u32 addr, __be32 *data,
 +	       u64 *parity);
 +int t4_edc_read(struct adapter *adap, int idx, u32 addr, __be32 *data,
 +		u64 *parity);
++=======
+ int t4_config_vi_rss(struct adapter *adapter, int mbox, unsigned int viid,
+ 		     unsigned int flags, unsigned int defq);
+ int t4_read_rss(struct adapter *adapter, u16 *entries);
+ void t4_read_rss_key(struct adapter *adapter, u32 *key);
+ void t4_write_rss_key(struct adapter *adap, const u32 *key, int idx);
+ void t4_read_rss_pf_config(struct adapter *adapter, unsigned int index,
+ 			   u32 *valp);
+ void t4_read_rss_vf_config(struct adapter *adapter, unsigned int index,
+ 			   u32 *vfl, u32 *vfh);
+ u32 t4_read_rss_pf_map(struct adapter *adapter);
+ u32 t4_read_rss_pf_mask(struct adapter *adapter);
+ 
+ unsigned int t4_get_mps_bg_map(struct adapter *adapter, int idx);
+ void t4_pmtx_get_stats(struct adapter *adap, u32 cnt[], u64 cycles[]);
+ void t4_pmrx_get_stats(struct adapter *adap, u32 cnt[], u64 cycles[]);
+ int t4_read_cim_ibq(struct adapter *adap, unsigned int qid, u32 *data,
+ 		    size_t n);
+ int t4_read_cim_obq(struct adapter *adap, unsigned int qid, u32 *data,
+ 		    size_t n);
+ int t4_cim_read(struct adapter *adap, unsigned int addr, unsigned int n,
+ 		unsigned int *valp);
+ int t4_cim_write(struct adapter *adap, unsigned int addr, unsigned int n,
+ 		 const unsigned int *valp);
+ int t4_cim_read_la(struct adapter *adap, u32 *la_buf, unsigned int *wrptr);
+ void t4_read_cimq_cfg(struct adapter *adap, u16 *base, u16 *size, u16 *thres);
++>>>>>>> 75daacc7eae9 (cxgb4: Remove dead function t4_read_edc and t4_read_mc)
  const char *t4_get_port_type_description(enum fw_port_type port_type);
  void t4_get_port_stats(struct adapter *adap, int idx, struct port_stats *p);
  void t4_read_mtu_tbl(struct adapter *adap, u16 *mtus, u8 *mtu_log);
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
index 4234b8c917e7,3bde71bd6ca3..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
@@@ -332,116 -333,6 +332,119 @@@ int t4_wr_mbox_meat(struct adapter *ada
  }
  
  /**
++<<<<<<< HEAD
 + *	t4_mc_read - read from MC through backdoor accesses
 + *	@adap: the adapter
 + *	@addr: address of first byte requested
 + *	@idx: which MC to access
 + *	@data: 64 bytes of data containing the requested address
 + *	@ecc: where to store the corresponding 64-bit ECC word
 + *
 + *	Read 64 bytes of data from MC starting at a 64-byte-aligned address
 + *	that covers the requested address @addr.  If @parity is not %NULL it
 + *	is assigned the 64-bit ECC word for the read data.
 + */
 +int t4_mc_read(struct adapter *adap, int idx, u32 addr, __be32 *data, u64 *ecc)
 +{
 +	int i;
 +	u32 mc_bist_cmd, mc_bist_cmd_addr, mc_bist_cmd_len;
 +	u32 mc_bist_status_rdata, mc_bist_data_pattern;
 +
 +	if (is_t4(adap->params.chip)) {
 +		mc_bist_cmd = MC_BIST_CMD;
 +		mc_bist_cmd_addr = MC_BIST_CMD_ADDR;
 +		mc_bist_cmd_len = MC_BIST_CMD_LEN;
 +		mc_bist_status_rdata = MC_BIST_STATUS_RDATA;
 +		mc_bist_data_pattern = MC_BIST_DATA_PATTERN;
 +	} else {
 +		mc_bist_cmd = MC_REG(MC_P_BIST_CMD, idx);
 +		mc_bist_cmd_addr = MC_REG(MC_P_BIST_CMD_ADDR, idx);
 +		mc_bist_cmd_len = MC_REG(MC_P_BIST_CMD_LEN, idx);
 +		mc_bist_status_rdata = MC_REG(MC_P_BIST_STATUS_RDATA, idx);
 +		mc_bist_data_pattern = MC_REG(MC_P_BIST_DATA_PATTERN, idx);
 +	}
 +
 +	if (t4_read_reg(adap, mc_bist_cmd) & START_BIST)
 +		return -EBUSY;
 +	t4_write_reg(adap, mc_bist_cmd_addr, addr & ~0x3fU);
 +	t4_write_reg(adap, mc_bist_cmd_len, 64);
 +	t4_write_reg(adap, mc_bist_data_pattern, 0xc);
 +	t4_write_reg(adap, mc_bist_cmd, BIST_OPCODE(1) | START_BIST |
 +		     BIST_CMD_GAP(1));
 +	i = t4_wait_op_done(adap, mc_bist_cmd, START_BIST, 0, 10, 1);
 +	if (i)
 +		return i;
 +
 +#define MC_DATA(i) MC_BIST_STATUS_REG(mc_bist_status_rdata, i)
 +
 +	for (i = 15; i >= 0; i--)
 +		*data++ = htonl(t4_read_reg(adap, MC_DATA(i)));
 +	if (ecc)
 +		*ecc = t4_read_reg64(adap, MC_DATA(16));
 +#undef MC_DATA
 +	return 0;
 +}
 +
 +/**
 + *	t4_edc_read - read from EDC through backdoor accesses
 + *	@adap: the adapter
 + *	@idx: which EDC to access
 + *	@addr: address of first byte requested
 + *	@data: 64 bytes of data containing the requested address
 + *	@ecc: where to store the corresponding 64-bit ECC word
 + *
 + *	Read 64 bytes of data from EDC starting at a 64-byte-aligned address
 + *	that covers the requested address @addr.  If @parity is not %NULL it
 + *	is assigned the 64-bit ECC word for the read data.
 + */
 +int t4_edc_read(struct adapter *adap, int idx, u32 addr, __be32 *data, u64 *ecc)
 +{
 +	int i;
 +	u32 edc_bist_cmd, edc_bist_cmd_addr, edc_bist_cmd_len;
 +	u32 edc_bist_cmd_data_pattern, edc_bist_status_rdata;
 +
 +	if (is_t4(adap->params.chip)) {
 +		edc_bist_cmd = EDC_REG(EDC_BIST_CMD, idx);
 +		edc_bist_cmd_addr = EDC_REG(EDC_BIST_CMD_ADDR, idx);
 +		edc_bist_cmd_len = EDC_REG(EDC_BIST_CMD_LEN, idx);
 +		edc_bist_cmd_data_pattern = EDC_REG(EDC_BIST_DATA_PATTERN,
 +						    idx);
 +		edc_bist_status_rdata = EDC_REG(EDC_BIST_STATUS_RDATA,
 +						    idx);
 +	} else {
 +		edc_bist_cmd = EDC_REG_T5(EDC_H_BIST_CMD, idx);
 +		edc_bist_cmd_addr = EDC_REG_T5(EDC_H_BIST_CMD_ADDR, idx);
 +		edc_bist_cmd_len = EDC_REG_T5(EDC_H_BIST_CMD_LEN, idx);
 +		edc_bist_cmd_data_pattern =
 +			EDC_REG_T5(EDC_H_BIST_DATA_PATTERN, idx);
 +		edc_bist_status_rdata =
 +			 EDC_REG_T5(EDC_H_BIST_STATUS_RDATA, idx);
 +	}
 +
 +	if (t4_read_reg(adap, edc_bist_cmd) & START_BIST)
 +		return -EBUSY;
 +	t4_write_reg(adap, edc_bist_cmd_addr, addr & ~0x3fU);
 +	t4_write_reg(adap, edc_bist_cmd_len, 64);
 +	t4_write_reg(adap, edc_bist_cmd_data_pattern, 0xc);
 +	t4_write_reg(adap, edc_bist_cmd,
 +		     BIST_OPCODE(1) | BIST_CMD_GAP(1) | START_BIST);
 +	i = t4_wait_op_done(adap, edc_bist_cmd, START_BIST, 0, 10, 1);
 +	if (i)
 +		return i;
 +
 +#define EDC_DATA(i) (EDC_BIST_STATUS_REG(edc_bist_status_rdata, i))
 +
 +	for (i = 15; i >= 0; i--)
 +		*data++ = htonl(t4_read_reg(adap, EDC_DATA(i)));
 +	if (ecc)
 +		*ecc = t4_read_reg64(adap, EDC_DATA(16));
 +#undef EDC_DATA
 +	return 0;
 +}
 +
 +/**
++=======
++>>>>>>> 75daacc7eae9 (cxgb4: Remove dead function t4_read_edc and t4_read_mc)
   *	t4_memory_rw - read/write EDC 0, EDC 1 or MC via PCIE memory window
   *	@adap: the adapter
   *	@win: PCI-E Memory Window to use
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4_hw.c
