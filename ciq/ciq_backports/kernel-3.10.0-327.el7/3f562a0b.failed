IB/iser: Fix possible NULL derefernce ib_conn->device in session_create

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Fix possible NULL derefernce ib_conn->device in session_create (Amir Vadai) [1164539]
Rebuild_FUZZ: 97.84%
commit-author Ariel Nahum <arieln@mellanox.com>
commit 3f562a0b8f0b47c4315e08bccd6a0b2d7f5aae1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3f562a0b.failed

If rdma_cm error event comes after ep_poll but before conn_bind, we
should protect against dereferncing the device (which may have been
terminated) in session_create and conn_create (already protected)
callbacks.

	Signed-off-by: Ariel Nahum <arieln@mellanox.com>
	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit 3f562a0b8f0b47c4315e08bccd6a0b2d7f5aae1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.c
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.c
index 9e53334ea7c7,cc7b84a235c8..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@@ -571,7 -586,18 +571,22 @@@ iscsi_iser_session_create(struct iscsi_
  	 * the leading conn's ep so this will be NULL;
  	 */
  	if (ep) {
++<<<<<<< HEAD
 +		ib_conn = ep->dd_data;
++=======
+ 		iser_conn = ep->dd_data;
+ 		max_cmds = iser_conn->max_cmds;
+ 
+ 		mutex_lock(&iser_conn->state_mutex);
+ 		if (iser_conn->state != ISER_CONN_UP) {
+ 			iser_err("iser conn %p already started teardown\n",
+ 				 iser_conn);
+ 			mutex_unlock(&iser_conn->state_mutex);
+ 			goto free_host;
+ 		}
+ 
+ 		ib_conn = &iser_conn->ib_conn;
++>>>>>>> 3f562a0b8f0b (IB/iser: Fix possible NULL derefernce ib_conn->device in session_create)
  		if (ib_conn->pi_support) {
  			u32 sig_caps = ib_conn->device->dev_attr.sig_prot_cap;
  
@@@ -581,16 -607,23 +596,33 @@@
  			else
  				scsi_host_set_guard(shost, SHOST_DIX_GUARD_CRC);
  		}
++<<<<<<< HEAD
 +	}
 +
 +	if (iscsi_host_add(shost,
 +			   ep ? ib_conn->device->ib_device->dma_device : NULL))
 +		goto free_host;
 +
 +	if (cmds_max > ISER_DEF_XMIT_CMDS_MAX) {
++=======
+ 
+ 		if (iscsi_host_add(shost,
+ 				   ib_conn->device->ib_device->dma_device)) {
+ 			mutex_unlock(&iser_conn->state_mutex);
+ 			goto free_host;
+ 		}
+ 		mutex_unlock(&iser_conn->state_mutex);
+ 	} else {
+ 		max_cmds = ISER_DEF_XMIT_CMDS_MAX;
+ 		if (iscsi_host_add(shost, NULL))
+ 			goto free_host;
+ 	}
+ 
+ 	if (cmds_max > max_cmds) {
++>>>>>>> 3f562a0b8f0b (IB/iser: Fix possible NULL derefernce ib_conn->device in session_create)
  		iser_info("cmds_max changed from %u to %u\n",
 -			  cmds_max, max_cmds);
 -		cmds_max = max_cmds;
 +			  cmds_max, ISER_DEF_XMIT_CMDS_MAX);
 +		cmds_max = ISER_DEF_XMIT_CMDS_MAX;
  	}
  
  	cls_session = iscsi_session_setup(&iscsi_iser_transport, shost,
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.c
