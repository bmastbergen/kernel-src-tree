xfrm: Using the right namespace to migrate key info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Fan Du <fan.du@windriver.com>
commit 8d549c4f5d92d80fc6f888fd314e10972ae0ec37
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8d549c4f.failed

because the home agent could surely be run on a different
net namespace other than init_net. The original behavior
could lead into inconsistent of key info.

	Signed-off-by: Fan Du <fan.du@windriver.com>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 8d549c4f5d92d80fc6f888fd314e10972ae0ec37)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/xfrm.h
diff --cc include/net/xfrm.h
index 3060c2bd32b0,5b522c5f0188..000000000000
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@@ -1585,40 -1570,41 +1585,52 @@@ struct xfrm_state *xfrm_find_acq(struc
  				 const xfrm_address_t *daddr,
  				 const xfrm_address_t *saddr, int create,
  				 unsigned short family);
 -int xfrm_sk_policy_insert(struct sock *sk, int dir, struct xfrm_policy *pol);
 +extern int xfrm_sk_policy_insert(struct sock *sk, int dir, struct xfrm_policy *pol);
  
  #ifdef CONFIG_XFRM_MIGRATE
++<<<<<<< HEAD
 +extern int km_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,
 +		      const struct xfrm_migrate *m, int num_bundles,
 +		      const struct xfrm_kmaddress *k);
 +extern struct xfrm_state * xfrm_migrate_state_find(struct xfrm_migrate *m);
 +extern struct xfrm_state * xfrm_state_migrate(struct xfrm_state *x,
 +					      struct xfrm_migrate *m);
 +extern int xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,
 +			struct xfrm_migrate *m, int num_bundles,
 +			struct xfrm_kmaddress *k);
++=======
+ int km_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,
+ 	       const struct xfrm_migrate *m, int num_bundles,
+ 	       const struct xfrm_kmaddress *k);
+ struct xfrm_state *xfrm_migrate_state_find(struct xfrm_migrate *m);
+ struct xfrm_state *xfrm_state_migrate(struct xfrm_state *x,
+ 				      struct xfrm_migrate *m);
+ int xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,
+ 		 struct xfrm_migrate *m, int num_bundles,
+ 		 struct xfrm_kmaddress *k, struct net *net);
++>>>>>>> 8d549c4f5d92 (xfrm: Using the right namespace to migrate key info)
  #endif
  
 -int km_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport);
 -void km_policy_expired(struct xfrm_policy *pol, int dir, int hard, u32 portid);
 -int km_report(struct net *net, u8 proto, struct xfrm_selector *sel,
 -	      xfrm_address_t *addr);
 -
 -void xfrm_input_init(void);
 -int xfrm_parse_spi(struct sk_buff *skb, u8 nexthdr, __be32 *spi, __be32 *seq);
 -
 -void xfrm_probe_algs(void);
 -int xfrm_count_pfkey_auth_supported(void);
 -int xfrm_count_pfkey_enc_supported(void);
 -struct xfrm_algo_desc *xfrm_aalg_get_byidx(unsigned int idx);
 -struct xfrm_algo_desc *xfrm_ealg_get_byidx(unsigned int idx);
 -struct xfrm_algo_desc *xfrm_aalg_get_byid(int alg_id);
 -struct xfrm_algo_desc *xfrm_ealg_get_byid(int alg_id);
 -struct xfrm_algo_desc *xfrm_calg_get_byid(int alg_id);
 -struct xfrm_algo_desc *xfrm_aalg_get_byname(const char *name, int probe);
 -struct xfrm_algo_desc *xfrm_ealg_get_byname(const char *name, int probe);
 -struct xfrm_algo_desc *xfrm_calg_get_byname(const char *name, int probe);
 -struct xfrm_algo_desc *xfrm_aead_get_byname(const char *name, int icv_len,
 -					    int probe);
 +extern int km_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr, __be16 sport);
 +extern void km_policy_expired(struct xfrm_policy *pol, int dir, int hard, u32 portid);
 +extern int km_report(struct net *net, u8 proto, struct xfrm_selector *sel, xfrm_address_t *addr);
 +
 +extern void xfrm_input_init(void);
 +extern int xfrm_parse_spi(struct sk_buff *skb, u8 nexthdr, __be32 *spi, __be32 *seq);
 +
 +extern void xfrm_probe_algs(void);
 +extern int xfrm_count_pfkey_auth_supported(void);
 +extern int xfrm_count_pfkey_enc_supported(void);
 +extern struct xfrm_algo_desc *xfrm_aalg_get_byidx(unsigned int idx);
 +extern struct xfrm_algo_desc *xfrm_ealg_get_byidx(unsigned int idx);
 +extern struct xfrm_algo_desc *xfrm_aalg_get_byid(int alg_id);
 +extern struct xfrm_algo_desc *xfrm_ealg_get_byid(int alg_id);
 +extern struct xfrm_algo_desc *xfrm_calg_get_byid(int alg_id);
 +extern struct xfrm_algo_desc *xfrm_aalg_get_byname(const char *name, int probe);
 +extern struct xfrm_algo_desc *xfrm_ealg_get_byname(const char *name, int probe);
 +extern struct xfrm_algo_desc *xfrm_calg_get_byname(const char *name, int probe);
 +extern struct xfrm_algo_desc *xfrm_aead_get_byname(const char *name, int icv_len,
 +						   int probe);
  
  static inline bool xfrm6_addr_equal(const xfrm_address_t *a,
  				    const xfrm_address_t *b)
* Unmerged path include/net/xfrm.h
diff --git a/net/key/af_key.c b/net/key/af_key.c
index 4f7982631637..aadfc2ef54d6 100644
--- a/net/key/af_key.c
+++ b/net/key/af_key.c
@@ -2492,6 +2492,7 @@ static int pfkey_migrate(struct sock *sk, struct sk_buff *skb,
 	struct xfrm_selector sel;
 	struct xfrm_migrate m[XFRM_MAX_DEPTH];
 	struct xfrm_kmaddress k;
+	struct net *net = sock_net(sk);
 
 	if (!present_and_same_family(ext_hdrs[SADB_EXT_ADDRESS_SRC - 1],
 				     ext_hdrs[SADB_EXT_ADDRESS_DST - 1]) ||
@@ -2565,7 +2566,7 @@ static int pfkey_migrate(struct sock *sk, struct sk_buff *skb,
 	}
 
 	return xfrm_migrate(&sel, dir, XFRM_POLICY_TYPE_MAIN, m, i,
-			    kma ? &k : NULL);
+			    kma ? &k : NULL, net);
 
  out:
 	return err;
diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
index 8da957011964..3e5d44b1ecd5 100644
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@ -3081,14 +3081,14 @@ static bool xfrm_migrate_selector_match(const struct xfrm_selector *sel_cmp,
 }
 
 static struct xfrm_policy * xfrm_migrate_policy_find(const struct xfrm_selector *sel,
-						     u8 dir, u8 type)
+						     u8 dir, u8 type, struct net *net)
 {
 	struct xfrm_policy *pol, *ret = NULL;
 	struct hlist_head *chain;
 	u32 priority = ~0U;
 
 	read_lock_bh(&xfrm_policy_lock);
-	chain = policy_hash_direct(&init_net, &sel->daddr, &sel->saddr, sel->family, dir);
+	chain = policy_hash_direct(net, &sel->daddr, &sel->saddr, sel->family, dir);
 	hlist_for_each_entry(pol, chain, bydst) {
 		if (xfrm_migrate_selector_match(sel, &pol->selector) &&
 		    pol->type == type) {
@@ -3097,7 +3097,7 @@ static struct xfrm_policy * xfrm_migrate_policy_find(const struct xfrm_selector
 			break;
 		}
 	}
-	chain = &init_net.xfrm.policy_inexact[dir];
+	chain = &net->xfrm.policy_inexact[dir];
 	hlist_for_each_entry(pol, chain, bydst) {
 		if (xfrm_migrate_selector_match(sel, &pol->selector) &&
 		    pol->type == type &&
@@ -3221,7 +3221,7 @@ static int xfrm_migrate_check(const struct xfrm_migrate *m, int num_migrate)
 
 int xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,
 		 struct xfrm_migrate *m, int num_migrate,
-		 struct xfrm_kmaddress *k)
+		 struct xfrm_kmaddress *k, struct net *net)
 {
 	int i, err, nx_cur = 0, nx_new = 0;
 	struct xfrm_policy *pol = NULL;
@@ -3234,7 +3234,7 @@ int xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,
 		goto out;
 
 	/* Stage 1 - find policy */
-	if ((pol = xfrm_migrate_policy_find(sel, dir, type)) == NULL) {
+	if ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {
 		err = -ENOENT;
 		goto out;
 	}
diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c
index 7a70a5a5671a..e82b960959f0 100644
--- a/net/xfrm/xfrm_user.c
+++ b/net/xfrm/xfrm_user.c
@@ -2128,6 +2128,7 @@ static int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,
 	u8 type;
 	int err;
 	int n = 0;
+	struct net *net = sock_net(skb->sk);
 
 	if (attrs[XFRMA_MIGRATE] == NULL)
 		return -EINVAL;
@@ -2145,7 +2146,7 @@ static int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,
 	if (!n)
 		return 0;
 
-	xfrm_migrate(&pi->sel, pi->dir, type, m, n, kmp);
+	xfrm_migrate(&pi->sel, pi->dir, type, m, n, kmp, net);
 
 	return 0;
 }
