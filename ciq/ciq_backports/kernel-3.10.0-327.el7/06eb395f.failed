pkt_sched: fq: better control of DDOS traffic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 06eb395fa9856b5a87cf7d80baee2a0ed3cdb9d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/06eb395f.failed

FQ has a fast path for skb attached to a socket, as it does not
have to compute a flow hash. But for other packets, FQ being non
stochastic means that hosts exposed to random Internet traffic
can allocate million of flows structure (104 bytes each) pretty
easily. Not only host can OOM, but lookup in RB trees can take
too much cpu and memory resources.

This patch adds a new attribute, orphan_mask, that is adding
possibility of having a stochastic hash for orphaned skb.

Its default value is 1024 slots, to mimic SFQ behavior.

Note: This does not apply to locally generated TCP traffic,
and no locally generated traffic will share a flow structure
with another perfect or stochastic flow.

This patch also handles the specific case of SYNACK messages:

They are attached to the listener socket, and therefore all map
to a single hash bucket. If listener have set SO_MAX_PACING_RATE,
hoping to have new accepted socket inherit this rate, SYNACK
might be paced and even dropped.

This is very similar to an internal patch Google have used more
than one year.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 06eb395fa9856b5a87cf7d80baee2a0ed3cdb9d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_fq.c
diff --cc net/sched/sch_fq.c
index f5d1f9896484,a00c43043001..000000000000
--- a/net/sched/sch_fq.c
+++ b/net/sched/sch_fq.c
@@@ -226,7 -236,8 +235,12 @@@ static struct fq_flow *fq_classify(stru
  		/* By forcing low order bit to 1, we make sure to not
  		 * collide with a local flow (socket pointers are word aligned)
  		 */
++<<<<<<< HEAD
 +		sk = (struct sock *)(skb_get_rxhash(skb) | 1L);
++=======
+ 		sk = (struct sock *)((hash << 1) | 1UL);
+ 		skb_orphan(skb);
++>>>>>>> 06eb395fa985 (pkt_sched: fq: better control of DDOS traffic)
  	}
  
  	root = &q->fq_root[hash_32((u32)(long)sk, q->fq_trees_log)];
diff --git a/include/uapi/linux/pkt_sched.h b/include/uapi/linux/pkt_sched.h
index 66f925d3c07b..525f41b6e557 100644
--- a/include/uapi/linux/pkt_sched.h
+++ b/include/uapi/linux/pkt_sched.h
@@ -767,6 +767,8 @@ enum {
 
 	TCA_FQ_FLOW_REFILL_DELAY,	/* flow credit refill delay in usec */
 
+	TCA_FQ_ORPHAN_MASK,	/* mask applied to orphaned skb hashes */
+
 	__TCA_FQ_MAX
 };
 
* Unmerged path net/sched/sch_fq.c
