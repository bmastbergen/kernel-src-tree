ALSA: Fix spelling typo in Documentation/DocBook/alsa-driver-api.xml

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] Fix spelling typo in Documentation/DocBook/alsa-driver-api.xml (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 95.38%
commit-author Masanari Iida <standby24x7@gmail.com>
commit 1a6ab46fa9c2bc9399694b4856ab7ea19c036485
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1a6ab46f.failed

This patch fix spelling typo found in alsa-driver-api.xml.
It is because this file is generated from comments in source files,
I have to fix source files.

	Signed-off-by: Masanari Iida <standby24x7@gmail.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 1a6ab46fa9c2bc9399694b4856ab7ea19c036485)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/compress_driver.h
#	include/sound/soc.h
diff --cc include/sound/compress_driver.h
index ebdf3f251c4b,fa1d05512c09..000000000000
--- a/include/sound/compress_driver.h
+++ b/include/sound/compress_driver.h
@@@ -94,6 -94,8 +94,11 @@@ struct snd_compr_stream 
   * This can be called in during stream creation only to set codec params
   * and the stream properties
   * @get_params: retrieve the codec parameters, mandatory
++<<<<<<< HEAD
++=======
+  * @set_metadata: Set the metadata values for a stream
+  * @get_metadata: retrieves the requested metadata values from stream
++>>>>>>> 1a6ab46fa9c2 (ALSA: Fix spelling typo in Documentation/DocBook/alsa-driver-api.xml)
   * @trigger: Trigger operations like start, pause, resume, drain, stop.
   * This callback is mandatory
   * @pointer: Retrieve current h/w pointer information. Mandatory
diff --cc include/sound/soc.h
index 85c15226103b,cf0bb156d6da..000000000000
--- a/include/sound/soc.h
+++ b/include/sound/soc.h
@@@ -1187,6 -1403,85 +1187,88 @@@ static inline bool snd_soc_volsw_is_ste
  	return 1;
  }
  
++<<<<<<< HEAD
++=======
+ static inline unsigned int snd_soc_enum_val_to_item(struct soc_enum *e,
+ 	unsigned int val)
+ {
+ 	unsigned int i;
+ 
+ 	if (!e->values)
+ 		return val;
+ 
+ 	for (i = 0; i < e->items; i++)
+ 		if (val == e->values[i])
+ 			return i;
+ 
+ 	return 0;
+ }
+ 
+ static inline unsigned int snd_soc_enum_item_to_val(struct soc_enum *e,
+ 	unsigned int item)
+ {
+ 	if (!e->values)
+ 		return item;
+ 
+ 	return e->values[item];
+ }
+ 
+ static inline bool snd_soc_component_is_active(
+ 	struct snd_soc_component *component)
+ {
+ 	return component->active != 0;
+ }
+ 
+ static inline bool snd_soc_codec_is_active(struct snd_soc_codec *codec)
+ {
+ 	return snd_soc_component_is_active(&codec->component);
+ }
+ 
+ /**
+  * snd_soc_kcontrol_component() - Returns the component that registered the
+  *  control
+  * @kcontrol: The control for which to get the component
+  *
+  * Note: This function will work correctly if the control has been registered
+  * for a component. Either with snd_soc_add_codec_controls() or
+  * snd_soc_add_platform_controls() or via  table based setup for either a
+  * CODEC, a platform or component driver. Otherwise the behavior is undefined.
+  */
+ static inline struct snd_soc_component *snd_soc_kcontrol_component(
+ 	struct snd_kcontrol *kcontrol)
+ {
+ 	return snd_kcontrol_chip(kcontrol);
+ }
+ 
+ /**
+  * snd_soc_kcontrol_codec() - Returns the CODEC that registered the control
+  * @kcontrol: The control for which to get the CODEC
+  *
+  * Note: This function will only work correctly if the control has been
+  * registered with snd_soc_add_codec_controls() or via table based setup of
+  * snd_soc_codec_driver. Otherwise the behavior is undefined.
+  */
+ static inline struct snd_soc_codec *snd_soc_kcontrol_codec(
+ 	struct snd_kcontrol *kcontrol)
+ {
+ 	return snd_soc_component_to_codec(snd_soc_kcontrol_component(kcontrol));
+ }
+ 
+ /**
+  * snd_soc_kcontrol_platform() - Returns the platform that registered the control
+  * @kcontrol: The control for which to get the platform
+  *
+  * Note: This function will only work correctly if the control has been
+  * registered with snd_soc_add_platform_controls() or via table based setup of
+  * a snd_soc_platform_driver. Otherwise the behavior is undefined.
+  */
+ static inline struct snd_soc_platform *snd_soc_kcontrol_platform(
+ 	struct snd_kcontrol *kcontrol)
+ {
+ 	return snd_soc_component_to_platform(snd_soc_kcontrol_component(kcontrol));
+ }
+ 
++>>>>>>> 1a6ab46fa9c2 (ALSA: Fix spelling typo in Documentation/DocBook/alsa-driver-api.xml)
  int snd_soc_util_init(void);
  void snd_soc_util_exit(void);
  
* Unmerged path include/sound/compress_driver.h
diff --git a/include/sound/control.h b/include/sound/control.h
index 75f3054023f7..95aad6d3fd1a 100644
--- a/include/sound/control.h
+++ b/include/sound/control.h
@@ -227,7 +227,7 @@ snd_ctl_add_slave(struct snd_kcontrol *master, struct snd_kcontrol *slave)
  * Add a virtual slave control to the given master.
  * Unlike snd_ctl_add_slave(), the element added via this function
  * is supposed to have volatile values, and get callback is called
- * at each time quried from the master.
+ * at each time queried from the master.
  *
  * When the control peeks the hardware values directly and the value
  * can be changed by other means than the put callback of the element,
* Unmerged path include/sound/soc.h
diff --git a/include/uapi/sound/compress_offload.h b/include/uapi/sound/compress_offload.h
index d630163b9a2e..7a0e548d7dbb 100644
--- a/include/uapi/sound/compress_offload.h
+++ b/include/uapi/sound/compress_offload.h
@@ -75,7 +75,7 @@ struct snd_compr_tstamp {
 /**
  * struct snd_compr_avail: avail descriptor
  * @avail: Number of bytes available in ring buffer for writing/reading
- * @tstamp: timestamp infomation
+ * @tstamp: timestamp information
  */
 struct snd_compr_avail {
 	__u64 avail;
diff --git a/sound/soc/soc-dmaengine-pcm.c b/sound/soc/soc-dmaengine-pcm.c
index 6542c4083594..fba365a78390 100644
--- a/sound/soc/soc-dmaengine-pcm.c
+++ b/sound/soc/soc-dmaengine-pcm.c
@@ -289,7 +289,7 @@ EXPORT_SYMBOL_GPL(snd_dmaengine_pcm_request_channel);
  *
  * The function should usually be called from the pcm open callback. Note that
  * this function will use private_data field of the substream's runtime. So it
- * is not availabe to your pcm driver implementation.
+ * is not available to your pcm driver implementation.
  */
 int snd_dmaengine_pcm_open(struct snd_pcm_substream *substream,
 	struct dma_chan *chan)
@@ -328,7 +328,7 @@ EXPORT_SYMBOL_GPL(snd_dmaengine_pcm_open);
  * This function will request a DMA channel using the passed filter function and
  * data. The function should usually be called from the pcm open callback. Note
  * that this function will use private_data field of the substream's runtime. So
- * it is not availabe to your pcm driver implementation.
+ * it is not available to your pcm driver implementation.
  */
 int snd_dmaengine_pcm_open_request_chan(struct snd_pcm_substream *substream,
 	dma_filter_fn filter_fn, void *filter_data)
