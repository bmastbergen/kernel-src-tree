net: Introduce passthru_features_check

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] Introduce passthru_features_check (Ivan Vecera) [1200759]
Rebuild_FUZZ: 92.96%
commit-author Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
commit e38f30256b36700aa63aa709dc091bf6eb69c257
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e38f3025.failed

As there are a number of (especially virtual) devices that don't
need the multiple vlan check, introduce passthru_features_check() for
convenience.

	Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e38f30256b36700aa63aa709dc091bf6eb69c257)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/dev.c
diff --cc net/core/dev.c
index 9a2bea4eeeee,3a06003ecafd..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -2458,35 -2562,40 +2458,53 @@@ static netdev_features_t harmonize_feat
  	return features;
  }
  
++<<<<<<< HEAD
++=======
+ netdev_features_t passthru_features_check(struct sk_buff *skb,
+ 					  struct net_device *dev,
+ 					  netdev_features_t features)
+ {
+ 	return features;
+ }
+ EXPORT_SYMBOL(passthru_features_check);
+ 
+ static netdev_features_t dflt_features_check(const struct sk_buff *skb,
+ 					     struct net_device *dev,
+ 					     netdev_features_t features)
+ {
+ 	return vlan_features_check(skb, features);
+ }
+ 
++>>>>>>> e38f30256b36 (net: Introduce passthru_features_check)
  netdev_features_t netif_skb_features(struct sk_buff *skb)
  {
 -	struct net_device *dev = skb->dev;
 -	netdev_features_t features = dev->features;
 -	u16 gso_segs = skb_shinfo(skb)->gso_segs;
 +	__be16 protocol = skb->protocol;
 +	netdev_features_t features = skb->dev->features;
  
 -	if (gso_segs > dev->gso_max_segs || gso_segs < dev->gso_min_segs)
 +	if (skb_shinfo(skb)->gso_segs > skb->dev->gso_max_segs)
  		features &= ~NETIF_F_GSO_MASK;
  
 -	/* If encapsulation offload request, verify we are testing
 -	 * hardware encapsulation features instead of standard
 -	 * features for the netdev
 -	 */
 -	if (skb->encapsulation)
 -		features &= dev->hw_enc_features;
 +	if (!vlan_tx_tag_present(skb)) {
 +		if (unlikely(protocol == htons(ETH_P_8021Q) ||
 +			     protocol == htons(ETH_P_8021AD))) {
 +			struct vlan_ethhdr *veh = (struct vlan_ethhdr *)skb->data;
 +			protocol = veh->h_vlan_encapsulated_proto;
 +		} else {
 +			return harmonize_features(skb, features);
 +		}
 +	}
 +
 +	features = netdev_intersect_features(features,
 +					     skb->dev->vlan_features |
 +					     NETIF_F_HW_VLAN_CTAG_TX |
 +					     NETIF_F_HW_VLAN_STAG_TX);
  
 -	if (skb_vlan_tagged(skb))
 +	if (protocol == htons(ETH_P_8021Q) || protocol == htons(ETH_P_8021AD))
  		features = netdev_intersect_features(features,
 -						     dev->vlan_features |
 +						     NETIF_F_SG |
 +						     NETIF_F_HIGHDMA |
 +						     NETIF_F_FRAGLIST |
 +						     NETIF_F_GEN_CSUM |
  						     NETIF_F_HW_VLAN_CTAG_TX |
  						     NETIF_F_HW_VLAN_STAG_TX);
  
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index d77c2cff9dff..803039e99876 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -3035,6 +3035,9 @@ void netdev_change_features(struct net_device *dev);
 void netif_stacked_transfer_operstate(const struct net_device *rootdev,
 					struct net_device *dev);
 
+netdev_features_t passthru_features_check(struct sk_buff *skb,
+					  struct net_device *dev,
+					  netdev_features_t features);
 netdev_features_t netif_skb_features(struct sk_buff *skb);
 
 static inline bool net_gso_ok(netdev_features_t features, int gso_type)
* Unmerged path net/core/dev.c
