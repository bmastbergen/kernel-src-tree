net: Allow raw buffers to be passed into the flow dissector.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] flow: Allow raw buffers to be passed into the flow dissector (Ivan Vecera) [1200759]
Rebuild_FUZZ: 93.33%
commit-author David S. Miller <davem@davemloft.net>
commit 690e36e726d00d2528bc569809048adf61550d80
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/690e36e7.failed

Drivers, and perhaps other entities we have not yet considered,
sometimes want to know how deep the protocol headers go before
deciding how large of an SKB to allocate and how much of the packet to
place into the linear SKB area.

For example, consider a driver which has a device which DMAs into
pools of pages and then tells the driver where the data went in the
DMA descriptor(s).  The driver can then build an SKB and reference
most of the data via SKB fragments (which are page/offset/length
triplets).

However at least some of the front of the packet should be placed into
the linear SKB area, which comes before the fragments, so that packet
processing can get at the headers efficiently.  The first thing each
protocol layer is going to do is a "pskb_may_pull()" so we might as
well aggregate as much of this as possible while we're building the
SKB in the driver.

Part of supporting this is that we don't have an SKB yet, so we want
to be able to let the flow dissector operate on a raw buffer in order
to compute the offset of the end of the headers.

So now we have a __skb_flow_dissect() which takes an explicit data
pointer and length.

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 690e36e726d00d2528bc569809048adf61550d80)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow_keys.h
#	net/core/flow_dissector.c
diff --cc include/net/flow_keys.h
index d4fec0ba6827,4040f63932c5..000000000000
--- a/include/net/flow_keys.h
+++ b/include/net/flow_keys.h
@@@ -27,5 -27,17 +27,21 @@@ struct flow_keys 
  	u8 ip_proto;
  };
  
++<<<<<<< HEAD
 +extern bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow);
++=======
+ bool __skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow,
+ 			void *data, int hlen);
+ static inline bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow)
+ {
+ 	return __skb_flow_dissect(skb, flow, NULL, 0);
+ }
+ __be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,
+ 			    void *data, int hlen_proto);
+ static inline __be32 skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto)
+ {
+ 	return __skb_flow_get_ports(skb, thoff, ip_proto, NULL, 0);
+ }
+ u32 flow_hash_from_keys(struct flow_keys *keys);
++>>>>>>> 690e36e726d0 (net: Allow raw buffers to be passed into the flow dissector.)
  #endif
diff --cc net/core/flow_dissector.c
index 6a5c78b76323,660c6492fb78..000000000000
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@@ -25,9 -25,41 +25,45 @@@ static void iph_to_flow_copy_addrs(stru
  	memcpy(&flow->src, &iph->saddr, sizeof(flow->src) + sizeof(flow->dst));
  }
  
++<<<<<<< HEAD
 +bool skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow)
++=======
+ /**
+  * skb_flow_get_ports - extract the upper layer ports and return them
+  * @skb: buffer to extract the ports from
+  * @thoff: transport header offset
+  * @ip_proto: protocol for which to get port offset
+  *
+  * The function will try to retrieve the ports at offset thoff + poff where poff
+  * is the protocol port offset returned from proto_ports_offset
+  */
+ __be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,
+ 			    void *data, int hlen)
+ {
+ 	int poff = proto_ports_offset(ip_proto);
+ 
+ 	if (!data) {
+ 		data = skb->data;
+ 		hlen = skb_headlen(skb);
+ 	}
+ 
+ 	if (poff >= 0) {
+ 		__be32 *ports, _ports;
+ 
+ 		ports = __skb_header_pointer(skb, thoff + poff,
+ 					     sizeof(_ports), data, hlen, &_ports);
+ 		if (ports)
+ 			return *ports;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(__skb_flow_get_ports);
+ 
+ bool __skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow, void *data, int hlen)
++>>>>>>> 690e36e726d0 (net: Allow raw buffers to be passed into the flow dissector.)
  {
 -	int nhoff = skb_network_offset(skb);
 +	int poff, nhoff = skb_network_offset(skb);
  	u8 ip_proto;
  	__be16 proto = skb->protocol;
  
@@@ -39,23 -76,25 +80,23 @@@ again
  		const struct iphdr *iph;
  		struct iphdr _iph;
  ip:
- 		iph = skb_header_pointer(skb, nhoff, sizeof(_iph), &_iph);
+ 		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
  		if (!iph || iph->ihl < 5)
  			return false;
 -		nhoff += iph->ihl * 4;
  
 -		ip_proto = iph->protocol;
  		if (ip_is_fragment(iph))
  			ip_proto = 0;
 -
 +		else
 +			ip_proto = iph->protocol;
  		iph_to_flow_copy_addrs(flow, iph);
 +		nhoff += iph->ihl * 4;
  		break;
  	}
 -	case htons(ETH_P_IPV6): {
 +	case __constant_htons(ETH_P_IPV6): {
  		const struct ipv6hdr *iph;
  		struct ipv6hdr _iph;
 -		__be32 flow_label;
 -
  ipv6:
- 		iph = skb_header_pointer(skb, nhoff, sizeof(_iph), &_iph);
+ 		iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);
  		if (!iph)
  			return false;
  
@@@ -146,23 -206,51 +188,27 @@@
  
  	flow->n_proto = proto;
  	flow->ip_proto = ip_proto;
++<<<<<<< HEAD
 +	poff = proto_ports_offset(ip_proto);
 +	if (poff >= 0) {
 +		__be32 *ports, _ports;
 +
 +		ports = skb_header_pointer(skb, nhoff + poff,
 +					   sizeof(_ports), &_ports);
 +		if (ports)
 +			flow->ports = *ports;
 +	}
 +
++=======
+ 	flow->ports = __skb_flow_get_ports(skb, nhoff, ip_proto, data, hlen);
++>>>>>>> 690e36e726d0 (net: Allow raw buffers to be passed into the flow dissector.)
  	flow->thoff = (u16) nhoff;
  
  	return true;
  }
- EXPORT_SYMBOL(skb_flow_dissect);
+ EXPORT_SYMBOL(__skb_flow_dissect);
  
  static u32 hashrnd __read_mostly;
 -static __always_inline void __flow_hash_secret_init(void)
 -{
 -	net_get_random_once(&hashrnd, sizeof(hashrnd));
 -}
 -
 -static __always_inline u32 __flow_hash_3words(u32 a, u32 b, u32 c)
 -{
 -	__flow_hash_secret_init();
 -	return jhash_3words(a, b, c, hashrnd);
 -}
 -
 -static inline u32 __flow_hash_from_keys(struct flow_keys *keys)
 -{
 -	u32 hash;
 -
 -	/* get a consistent hash (same value on both flow directions) */
 -	if (((__force u32)keys->dst < (__force u32)keys->src) ||
 -	    (((__force u32)keys->dst == (__force u32)keys->src) &&
 -	     ((__force u16)keys->port16[1] < (__force u16)keys->port16[0]))) {
 -		swap(keys->dst, keys->src);
 -		swap(keys->port16[0], keys->port16[1]);
 -	}
 -
 -	hash = __flow_hash_3words((__force u32)keys->dst,
 -				  (__force u32)keys->src,
 -				  (__force u32)keys->ports);
 -	if (!hash)
 -		hash = 1;
 -
 -	return hash;
 -}
 -
 -u32 flow_hash_from_keys(struct flow_keys *keys)
 -{
 -	return __flow_hash_from_keys(keys);
 -}
 -EXPORT_SYMBOL(flow_hash_from_keys);
  
  /*
   * __skb_get_hash: calculate a flow hash based on src/dst addresses
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index af2c639c5324..76ff7694df26 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -2628,20 +2628,26 @@ __wsum __skb_checksum(const struct sk_buff *skb, int offset, int len,
 __wsum skb_checksum(const struct sk_buff *skb, int offset, int len,
 		    __wsum csum);
 
-static inline void *skb_header_pointer(const struct sk_buff *skb, int offset,
-				       int len, void *buffer)
+static inline void *__skb_header_pointer(const struct sk_buff *skb, int offset,
+					 int len, void *data, int hlen, void *buffer)
 {
-	int hlen = skb_headlen(skb);
-
 	if (hlen - offset >= len)
-		return skb->data + offset;
+		return data + offset;
 
-	if (skb_copy_bits(skb, offset, buffer, len) < 0)
+	if (!skb ||
+	    skb_copy_bits(skb, offset, buffer, len) < 0)
 		return NULL;
 
 	return buffer;
 }
 
+static inline void *skb_header_pointer(const struct sk_buff *skb, int offset,
+				       int len, void *buffer)
+{
+	return __skb_header_pointer(skb, offset, len, skb->data,
+				    skb_headlen(skb), buffer);
+}
+
 /**
  *	skb_needs_linearize - check if we need to linearize a given skb
  *			      depending on the given device features.
* Unmerged path include/net/flow_keys.h
* Unmerged path net/core/flow_dissector.c
