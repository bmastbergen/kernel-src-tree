IB/ipoib: Remove IPOIB_MCAST_RUN bit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] ipoib: Remove IPOIB_MCAST_RUN bit (Honggang Li) [1230203]
Rebuild_FUZZ: 95.65%
commit-author Erez Shitrit <erezsh@mellanox.com>
commit 0e5544d9bff432bfcac49ecf237738cc7cf3d032
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0e5544d9.failed

After Doug Ledford's changes there is no need in that bit, it's
semantic becomes subset of the IPOIB_FLAG_OPER_UP bit.

	Signed-off-by: Erez Shitrit <erezsh@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 0e5544d9bff432bfcac49ecf237738cc7cf3d032)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/ipoib/ipoib_multicast.c
diff --cc drivers/infiniband/ulp/ipoib/ipoib_multicast.c
index a98fc8463b5e,0d23e0568deb..000000000000
--- a/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
@@@ -66,6 -64,48 +66,51 @@@ struct ipoib_mcast_iter 
  	unsigned int       send_only;
  };
  
++<<<<<<< HEAD
++=======
+ /*
+  * This should be called with the priv->lock held
+  */
+ static void __ipoib_mcast_schedule_join_thread(struct ipoib_dev_priv *priv,
+ 					       struct ipoib_mcast *mcast,
+ 					       bool delay)
+ {
+ 	if (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))
+ 		return;
+ 
+ 	/*
+ 	 * We will be scheduling *something*, so cancel whatever is
+ 	 * currently scheduled first
+ 	 */
+ 	cancel_delayed_work(&priv->mcast_task);
+ 	if (mcast && delay) {
+ 		/*
+ 		 * We had a failure and want to schedule a retry later
+ 		 */
+ 		mcast->backoff *= 2;
+ 		if (mcast->backoff > IPOIB_MAX_BACKOFF_SECONDS)
+ 			mcast->backoff = IPOIB_MAX_BACKOFF_SECONDS;
+ 		mcast->delay_until = jiffies + (mcast->backoff * HZ);
+ 		/*
+ 		 * Mark this mcast for its delay, but restart the
+ 		 * task immediately.  The join task will make sure to
+ 		 * clear out all entries without delays, and then
+ 		 * schedule itself to run again when the earliest
+ 		 * delay expires
+ 		 */
+ 		queue_delayed_work(priv->wq, &priv->mcast_task, 0);
+ 	} else if (delay) {
+ 		/*
+ 		 * Special case of retrying after a failure to
+ 		 * allocate the broadcast multicast group, wait
+ 		 * 1 second and try again
+ 		 */
+ 		queue_delayed_work(priv->wq, &priv->mcast_task, HZ);
+ 	} else
+ 		queue_delayed_work(priv->wq, &priv->mcast_task, 0);
+ }
+ 
++>>>>>>> 0e5544d9bff4 (IB/ipoib: Remove IPOIB_MCAST_RUN bit)
  static void ipoib_mcast_free(struct ipoib_mcast *mcast)
  {
  	struct net_device *dev = mcast->dev;
@@@ -535,8 -515,11 +580,8 @@@ void ipoib_mcast_join_task(struct work_
  		container_of(work, struct ipoib_dev_priv, mcast_task.work);
  	struct net_device *dev = priv->dev;
  	struct ib_port_attr port_attr;
 -	unsigned long delay_until = 0;
 -	struct ipoib_mcast *mcast = NULL;
 -	int create = 1;
  
- 	if (!test_bit(IPOIB_MCAST_RUN, &priv->flags))
+ 	if (!test_bit(IPOIB_FLAG_OPER_UP, &priv->flags))
  		return;
  
  	if (ib_query_port(priv->ca, priv->port, &port_attr) ||
@@@ -618,10 -627,10 +663,16 @@@ int ipoib_mcast_start_thread(struct net
  
  	ipoib_dbg_mcast(priv, "starting multicast thread\n");
  
++<<<<<<< HEAD
 +	mutex_lock(&mcast_mutex);
 +	if (!test_and_set_bit(IPOIB_MCAST_RUN, &priv->flags))
 +		queue_delayed_work(ipoib_workqueue, &priv->mcast_task, 0);
 +	mutex_unlock(&mcast_mutex);
++=======
+ 	spin_lock_irqsave(&priv->lock, flags);
+ 	__ipoib_mcast_schedule_join_thread(priv, NULL, 0);
+ 	spin_unlock_irqrestore(&priv->lock, flags);
++>>>>>>> 0e5544d9bff4 (IB/ipoib: Remove IPOIB_MCAST_RUN bit)
  
  	return 0;
  }
@@@ -632,13 -641,12 +683,17 @@@ int ipoib_mcast_stop_thread(struct net_
  
  	ipoib_dbg_mcast(priv, "stopping multicast thread\n");
  
++<<<<<<< HEAD
 +	mutex_lock(&mcast_mutex);
 +	clear_bit(IPOIB_MCAST_RUN, &priv->flags);
++=======
+ 	spin_lock_irqsave(&priv->lock, flags);
++>>>>>>> 0e5544d9bff4 (IB/ipoib: Remove IPOIB_MCAST_RUN bit)
  	cancel_delayed_work(&priv->mcast_task);
 -	spin_unlock_irqrestore(&priv->lock, flags);
 +	mutex_unlock(&mcast_mutex);
  
 -	flush_workqueue(priv->wq);
 +	if (flush)
 +		flush_workqueue(ipoib_workqueue);
  
  	return 0;
  }
diff --git a/drivers/infiniband/ulp/ipoib/ipoib.h b/drivers/infiniband/ulp/ipoib/ipoib.h
index 560b5668e293..b33f499f8af3 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib.h
+++ b/drivers/infiniband/ulp/ipoib/ipoib.h
@@ -87,7 +87,6 @@ enum {
 	IPOIB_FLAG_ADMIN_UP	  = 2,
 	IPOIB_PKEY_ASSIGNED	  = 3,
 	IPOIB_FLAG_SUBINTERFACE	  = 5,
-	IPOIB_MCAST_RUN		  = 6,
 	IPOIB_STOP_REAPER	  = 7,
 	IPOIB_FLAG_ADMIN_CM	  = 9,
 	IPOIB_FLAG_UMCAST	  = 10,
* Unmerged path drivers/infiniband/ulp/ipoib/ipoib_multicast.c
