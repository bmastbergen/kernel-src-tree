bonding: add bond_time_in_interval() and use it for time comparison

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Veaceslav Falico <vfalico@redhat.com>
commit e7f63f1dc4bd643d9249c653e60c530d4a438147
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e7f63f1d.failed

Currently we use a lot of time comparison math for arp_interval
comparisons, which are sometimes quite hard to read and understand.

All the time comparisons have one pattern:
(time - arp_interval_jiffies) <= jiffies <= (time + mod *
arp_interval_jiffies + arp_interval_jiffies/2)

Introduce a new helper - bond_time_in_interval(), which will do the math in
one place and, thus, will clean up the logical code. This helper introduces
a bit of overhead (by always calculating the jiffies from arp_interval),
however it's really not visible, considering that functions using it
usually run once in arp_interval milliseconds.

There are several lines slightly over 80 chars, however breaking them would
result in more hard-to-read code than several character after the 80 mark.

CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
	Signed-off-by: Veaceslav Falico <vfalico@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e7f63f1dc4bd643d9249c653e60c530d4a438147)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
diff --cc drivers/net/bonding/bond_main.c
index ef8213746e65,d58237b3dd98..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -2729,15 -2662,10 +2743,22 @@@ void bond_loadbalance_arp_mon(struct wo
  					    arp_work.work);
  	struct slave *slave, *oldcurrent;
  	int do_failover = 0;
++<<<<<<< HEAD
 +	int delta_in_ticks, extra_ticks;
 +	int i;
 +
 +	read_lock(&bond->lock);
 +
 +	delta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);
 +	extra_ticks = delta_in_ticks / 2;
 +
 +	if (bond->slave_cnt == 0)
++=======
+ 
+ 	read_lock(&bond->lock);
+ 
+ 	if (list_empty(&bond->slave_list))
++>>>>>>> e7f63f1dc4bd (bonding: add bond_time_in_interval() and use it for time comparison)
  		goto re_arm;
  
  	oldcurrent = bond->curr_active_slave;
@@@ -2844,28 -2765,18 +2858,38 @@@ re_arm
   *
   * Called with bond->lock held for read.
   */
- static int bond_ab_arp_inspect(struct bonding *bond, int delta_in_ticks)
+ static int bond_ab_arp_inspect(struct bonding *bond)
  {
 -	unsigned long trans_start, last_rx;
  	struct slave *slave;
++<<<<<<< HEAD
 +	int i, commit = 0;
 +	unsigned long trans_start;
 +	int extra_ticks;
 +
 +	/* All the time comparisons below need some extra time. Otherwise, on
 +	 * fast networks the ARP probe/reply may arrive within the same jiffy
 +	 * as it was sent.  Then, the next time the ARP monitor is run, one
 +	 * arp_interval will already have passed in the comparisons.
 +	 */
 +	extra_ticks = delta_in_ticks / 2;
 +
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	int commit = 0;
+ 
+ 	bond_for_each_slave(bond, slave) {
++>>>>>>> e7f63f1dc4bd (bonding: add bond_time_in_interval() and use it for time comparison)
  		slave->new_link = BOND_LINK_NOCHANGE;
 -		last_rx = slave_last_rx(bond, slave);
  
  		if (slave->link != BOND_LINK_UP) {
++<<<<<<< HEAD
 +			if (time_in_range(jiffies,
 +				slave_last_rx(bond, slave) - delta_in_ticks,
 +				slave_last_rx(bond, slave) + delta_in_ticks + extra_ticks)) {
 +
++=======
+ 			if (bond_time_in_interval(bond, last_rx, 1)) {
++>>>>>>> e7f63f1dc4bd (bonding: add bond_time_in_interval() and use it for time comparison)
  				slave->new_link = BOND_LINK_UP;
  				commit++;
  			}
@@@ -2898,10 -2806,7 +2919,14 @@@
  		 */
  		if (!bond_is_active_slave(slave) &&
  		    !bond->current_arp_slave &&
++<<<<<<< HEAD
 +		    !time_in_range(jiffies,
 +			slave_last_rx(bond, slave) - delta_in_ticks,
 +			slave_last_rx(bond, slave) + 3 * delta_in_ticks + extra_ticks)) {
 +
++=======
+ 		    !bond_time_in_interval(bond, last_rx, 3)) {
++>>>>>>> e7f63f1dc4bd (bonding: add bond_time_in_interval() and use it for time comparison)
  			slave->new_link = BOND_LINK_DOWN;
  			commit++;
  		}
@@@ -2914,13 -2819,8 +2939,18 @@@
  		 */
  		trans_start = dev_trans_start(slave->dev);
  		if (bond_is_active_slave(slave) &&
++<<<<<<< HEAD
 +		    (!time_in_range(jiffies,
 +			trans_start - delta_in_ticks,
 +			trans_start + 2 * delta_in_ticks + extra_ticks) ||
 +		     !time_in_range(jiffies,
 +			slave_last_rx(bond, slave) - delta_in_ticks,
 +			slave_last_rx(bond, slave) + 2 * delta_in_ticks + extra_ticks))) {
 +
++=======
+ 		    (!bond_time_in_interval(bond, trans_start, 2) ||
+ 		     !bond_time_in_interval(bond, last_rx, 2))) {
++>>>>>>> e7f63f1dc4bd (bonding: add bond_time_in_interval() and use it for time comparison)
  			slave->new_link = BOND_LINK_DOWN;
  			commit++;
  		}
@@@ -2935,13 -2835,12 +2965,13 @@@
   *
   * Called with RTNL and bond->lock for read.
   */
- static void bond_ab_arp_commit(struct bonding *bond, int delta_in_ticks)
+ static void bond_ab_arp_commit(struct bonding *bond)
  {
 -	unsigned long trans_start;
  	struct slave *slave;
 +	int i;
 +	unsigned long trans_start;
  
 -	bond_for_each_slave(bond, slave) {
 +	bond_for_each_slave(bond, slave, i) {
  		switch (slave->new_link) {
  		case BOND_LINK_NOCHANGE:
  			continue;
* Unmerged path drivers/net/bonding/bond_main.c
