CIFS: Separate filling pages from iovec write

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Pavel Shilovsky <pshilovsky@samba.org>
commit 66386c08be5d1a2eefc1f7ab8c008561b6c811e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/66386c08.failed

	Reviewed-by: Shirish Pargaonkar <spargaonkar@suse.com>
	Signed-off-by: Pavel Shilovsky <pshilovsky@samba.org>
	Signed-off-by: Steve French <smfrench@gmail.com>
(cherry picked from commit 66386c08be5d1a2eefc1f7ab8c008561b6c811e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/file.c
diff --cc fs/cifs/file.c
index 6b4ebc406ff2,f96f61c849fe..000000000000
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@@ -2427,15 -2423,55 +2427,57 @@@ cifs_uncached_retry_writev(struct cifs_
  	return rc;
  }
  
+ static int
+ wdata_fill_from_iovec(struct cifs_writedata *wdata, struct iov_iter *from,
+ 		      size_t *len, unsigned long *num_pages)
+ {
+ 	size_t save_len, copied, bytes, cur_len = *len;
+ 	unsigned long i, nr_pages = *num_pages;
+ 
+ 	save_len = cur_len;
+ 	for (i = 0; i < nr_pages; i++) {
+ 		bytes = min_t(const size_t, cur_len, PAGE_SIZE);
+ 		copied = copy_page_from_iter(wdata->pages[i], 0, bytes, from);
+ 		cur_len -= copied;
+ 		/*
+ 		 * If we didn't copy as much as we expected, then that
+ 		 * may mean we trod into an unmapped area. Stop copying
+ 		 * at that point. On the next pass through the big
+ 		 * loop, we'll likely end up getting a zero-length
+ 		 * write and bailing out of it.
+ 		 */
+ 		if (copied < bytes)
+ 			break;
+ 	}
+ 	cur_len = save_len - cur_len;
+ 	*len = cur_len;
+ 
+ 	/*
+ 	 * If we have no data to send, then that probably means that
+ 	 * the copy above failed altogether. That's most likely because
+ 	 * the address in the iovec was bogus. Return -EFAULT and let
+ 	 * the caller free anything we allocated and bail out.
+ 	 */
+ 	if (!cur_len)
+ 		return -EFAULT;
+ 
+ 	/*
+ 	 * i + 1 now represents the number of pages we actually used in
+ 	 * the copy phase above.
+ 	 */
+ 	*num_pages = i + 1;
+ 	return 0;
+ }
+ 
  static ssize_t
 -cifs_iovec_write(struct file *file, struct iov_iter *from, loff_t *poffset)
 +cifs_iovec_write(struct file *file, const struct iovec *iov,
 +		 unsigned long nr_segs, loff_t *poffset)
  {
- 	unsigned long nr_pages, i;
- 	size_t bytes, copied, len, cur_len;
+ 	unsigned long nr_pages, num_pages, i;
+ 	size_t len, cur_len;
  	ssize_t total_written = 0;
  	loff_t offset;
 +	struct iov_iter it;
  	struct cifsFileInfo *open_file;
  	struct cifs_tcon *tcon;
  	struct cifs_sb_info *cifs_sb;
@@@ -2467,10 -2505,7 +2509,8 @@@
  	else
  		pid = current->tgid;
  
 +	iov_iter_init(&it, iov, nr_segs, len, 0);
  	do {
- 		size_t save_len;
- 
  		nr_pages = get_numpages(cifs_sb->wsize, len, &cur_len);
  		wdata = cifs_writedata_alloc(nr_pages,
  					     cifs_uncached_writev_complete);
@@@ -2485,32 -2520,9 +2525,38 @@@
  			break;
  		}
  
++<<<<<<< HEAD
 +		save_len = cur_len;
 +		for (i = 0; i < nr_pages; i++) {
 +			bytes = min_t(const size_t, cur_len, PAGE_SIZE);
 +			copied = iov_iter_copy_from_user(wdata->pages[i], &it,
 +							 0, bytes);
 +			cur_len -= copied;
 +			iov_iter_advance(&it, copied);
 +			/*
 +			 * If we didn't copy as much as we expected, then that
 +			 * may mean we trod into an unmapped area. Stop copying
 +			 * at that point. On the next pass through the big
 +			 * loop, we'll likely end up getting a zero-length
 +			 * write and bailing out of it.
 +			 */
 +			if (copied < bytes)
 +				break;
 +		}
 +		cur_len = save_len - cur_len;
 +
 +		/*
 +		 * If we have no data to send, then that probably means that
 +		 * the copy above failed altogether. That's most likely because
 +		 * the address in the iovec was bogus. Set the rc to -EFAULT,
 +		 * free anything we allocated and bail out.
 +		 */
 +		if (!cur_len) {
++=======
+ 		num_pages = nr_pages;
+ 		rc = wdata_fill_from_iovec(wdata, from, &cur_len, &num_pages);
+ 		if (rc) {
++>>>>>>> 66386c08be5d (CIFS: Separate filling pages from iovec write)
  			for (i = 0; i < nr_pages; i++)
  				put_page(wdata->pages[i]);
  			kfree(wdata);
* Unmerged path fs/cifs/file.c
