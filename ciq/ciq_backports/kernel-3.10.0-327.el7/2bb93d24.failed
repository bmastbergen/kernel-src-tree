Trivial whitespace fix

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Steve French <smfrench@gmail.com>
commit 2bb93d244157b6dfa4964d4088be4680b3169701
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2bb93d24.failed

	Signed-off-by: Steve French <smfrench@gmail.com>
(cherry picked from commit 2bb93d244157b6dfa4964d4088be4680b3169701)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2ops.c
diff --cc fs/cifs/smb2ops.c
index 78de2c9b38f8,4e4eecdec4f9..000000000000
--- a/fs/cifs/smb2ops.c
+++ b/fs/cifs/smb2ops.c
@@@ -967,6 -1015,105 +967,108 @@@ smb2_query_symlink(const unsigned int x
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static long smb3_zero_range(struct file *file, struct cifs_tcon *tcon,
+ 			    loff_t offset, loff_t len, bool keep_size)
+ {
+ 	struct inode *inode;
+ 	struct cifsInodeInfo *cifsi;
+ 	struct cifsFileInfo *cfile = file->private_data;
+ 	struct file_zero_data_information fsctl_buf;
+ 	long rc;
+ 	unsigned int xid;
+ 
+ 	xid = get_xid();
+ 
+ 	inode = cfile->dentry->d_inode;
+ 	cifsi = CIFS_I(inode);
+ 
+ 	/* if file not oplocked can't be sure whether asking to extend size */
+ 	if (!CIFS_CACHE_READ(cifsi))
+ 		if (keep_size == false)
+ 			return -EOPNOTSUPP;
+ 
+ 	/*
+ 	 * Must check if file sparse since fallocate -z (zero range) assumes
+ 	 * non-sparse allocation
+ 	 */
+ 	if (!(cifsi->cifsAttrs & FILE_ATTRIBUTE_SPARSE_FILE))
+ 		return -EOPNOTSUPP;
+ 
+ 	/*
+ 	 * need to make sure we are not asked to extend the file since the SMB3
+ 	 * fsctl does not change the file size. In the future we could change
+ 	 * this to zero the first part of the range then set the file size
+ 	 * which for a non sparse file would zero the newly extended range
+ 	 */
+ 	if (keep_size == false)
+ 		if (i_size_read(inode) < offset + len)
+ 			return -EOPNOTSUPP;
+ 
+ 	cifs_dbg(FYI, "offset %lld len %lld", offset, len);
+ 
+ 	fsctl_buf.FileOffset = cpu_to_le64(offset);
+ 	fsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);
+ 
+ 	rc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,
+ 			cfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,
+ 			true /* is_fctl */, (char *)&fsctl_buf,
+ 			sizeof(struct file_zero_data_information), NULL, NULL);
+ 	free_xid(xid);
+ 	return rc;
+ }
+ 
+ static long smb3_punch_hole(struct file *file, struct cifs_tcon *tcon,
+ 			    loff_t offset, loff_t len)
+ {
+ 	struct inode *inode;
+ 	struct cifsInodeInfo *cifsi;
+ 	struct cifsFileInfo *cfile = file->private_data;
+ 	struct file_zero_data_information fsctl_buf;
+ 	long rc;
+ 	unsigned int xid;
+ 	__u8 set_sparse = 1;
+ 
+ 	xid = get_xid();
+ 
+ 	inode = cfile->dentry->d_inode;
+ 	cifsi = CIFS_I(inode);
+ 
+ 	/* Need to make file sparse, if not already, before freeing range. */
+ 	/* Consider adding equivalent for compressed since it could also work */
+ 	if (!smb2_set_sparse(xid, tcon, cfile, inode, set_sparse))
+ 		return -EOPNOTSUPP;
+ 
+ 	cifs_dbg(FYI, "offset %lld len %lld", offset, len);
+ 
+ 	fsctl_buf.FileOffset = cpu_to_le64(offset);
+ 	fsctl_buf.BeyondFinalZero = cpu_to_le64(offset + len);
+ 
+ 	rc = SMB2_ioctl(xid, tcon, cfile->fid.persistent_fid,
+ 			cfile->fid.volatile_fid, FSCTL_SET_ZERO_DATA,
+ 			true /* is_fctl */, (char *)&fsctl_buf,
+ 			sizeof(struct file_zero_data_information), NULL, NULL);
+ 	free_xid(xid);
+ 	return rc;
+ }
+ 
+ static long smb3_fallocate(struct file *file, struct cifs_tcon *tcon, int mode,
+ 			   loff_t off, loff_t len)
+ {
+ 	/* KEEP_SIZE already checked for by do_fallocate */
+ 	if (mode & FALLOC_FL_PUNCH_HOLE)
+ 		return smb3_punch_hole(file, tcon, off, len);
+ 	else if (mode & FALLOC_FL_ZERO_RANGE) {
+ 		if (mode & FALLOC_FL_KEEP_SIZE)
+ 			return smb3_zero_range(file, tcon, off, len, true);
+ 		return smb3_zero_range(file, tcon, off, len, false);
+ 	}
+ 
+ 	return -EOPNOTSUPP;
+ }
+ 
++>>>>>>> 2bb93d244157 (Trivial whitespace fix)
  static void
  smb2_downgrade_oplock(struct TCP_Server_Info *server,
  			struct cifsInodeInfo *cinode, bool set_level2)
* Unmerged path fs/cifs/smb2ops.c
