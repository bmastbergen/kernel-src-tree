fib_trie: Replace plen with slen in leaf_info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 5786ec60549961a575044e0fb81664da1f8bf225
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/5786ec60.failed

This replaces the prefix length variable in the leaf_info structure with a
suffix length value, or host identifier length in bits.  By doing this it
makes it easier to sort out since the tnodes and leaf are carrying this
value as well since it is compatible with the ->pos field in tnodes.

I also cleaned up one spot that had some list manipulation that could be
simplified.  I basically updated it so that we just use hlist_add_head_rcu
instead of calling hlist_add_before_rcu on the first node in the list.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5786ec60549961a575044e0fb81664da1f8bf225)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 3fe26090641a,d28362db51a0..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -114,9 -114,8 +114,14 @@@ struct tnode 
  
  struct leaf_info {
  	struct hlist_node hlist;
++<<<<<<< HEAD
 +	int plen;
 +	u32 mask_plen; /* ntohl(inet_make_mask(plen)) */
 +	struct list_head falh;
++=======
+ 	unsigned char slen;
+ 	struct hlist_head falh;
++>>>>>>> 5786ec605499 (fib_trie: Replace plen with slen in leaf_info)
  	struct rcu_head rcu;
  };
  
@@@ -337,9 -336,8 +342,14 @@@ static struct leaf_info *leaf_info_new(
  {
  	struct leaf_info *li = kmalloc(sizeof(struct leaf_info),  GFP_KERNEL);
  	if (li) {
++<<<<<<< HEAD
 +		li->plen = plen;
 +		li->mask_plen = ntohl(inet_make_mask(plen));
 +		INIT_LIST_HEAD(&li->falh);
++=======
+ 		li->slen = KEYLENGTH - plen;
+ 		INIT_HLIST_HEAD(&li->falh);
++>>>>>>> 5786ec605499 (fib_trie: Replace plen with slen in leaf_info)
  	}
  	return li;
  }
@@@ -947,26 -935,22 +958,38 @@@ static void remove_leaf_info(struct tno
  static void insert_leaf_info(struct tnode *l, struct leaf_info *new)
  {
  	struct hlist_head *head = &l->list;
- 	struct leaf_info *li = NULL, *last = NULL;
+ 	struct leaf_info *li, *last = NULL;
  
++<<<<<<< HEAD
 +	if (hlist_empty(head)) {
 +		hlist_add_head_rcu(&new->hlist, head);
 +	} else {
 +		hlist_for_each_entry(li, head, hlist) {
 +			if (new->plen > li->plen)
 +				break;
 +
 +			last = li;
 +		}
 +		if (last)
 +			hlist_add_after_rcu(&last->hlist, &new->hlist);
 +		else
 +			hlist_add_before_rcu(&new->hlist, &li->hlist);
++=======
+ 	hlist_for_each_entry(li, head, hlist) {
+ 		if (new->slen < li->slen)
+ 			break;
+ 		last = li;
++>>>>>>> 5786ec605499 (fib_trie: Replace plen with slen in leaf_info)
  	}
  
+ 	if (last)
+ 		hlist_add_behind_rcu(&new->hlist, &last->hlist);
+ 	else
+ 		hlist_add_head_rcu(&new->hlist, head);
+ 
  	/* if we added to the tail node then we need to update slen */
- 	if (l->slen < (KEYLENGTH - new->plen)) {
- 		l->slen = KEYLENGTH - new->plen;
+ 	if (l->slen < new->slen) {
+ 		l->slen = new->slen;
  		leaf_push_suffix(l);
  	}
  }
@@@ -1407,10 -1420,11 +1430,11 @@@ found
  	hlist_for_each_entry_rcu(li, &n->list, hlist) {
  		struct fib_alias *fa;
  
- 		if ((key ^ n->key) & li->mask_plen)
+ 		if (((key ^ n->key) >= (1ul << li->slen)) &&
+ 		    ((BITS_PER_LONG > KEYLENGTH) || (li->slen != KEYLENGTH)))
  			continue;
  
 -		hlist_for_each_entry_rcu(fa, &li->falh, fa_list) {
 +		list_for_each_entry_rcu(fa, &li->falh, fa_list) {
  			struct fib_info *fi = fa->fa_info;
  			int nhsel, err;
  
@@@ -1594,15 -1608,14 +1618,20 @@@ static int trie_flush_list(struct list_
  static int trie_flush_leaf(struct tnode *l)
  {
  	int found = 0;
 +	struct hlist_head *lih = &l->list;
  	struct hlist_node *tmp;
++<<<<<<< HEAD
 +	struct leaf_info *li = NULL;
 +	unsigned char plen = KEYLENGTH;
++=======
+ 	struct leaf_info *li;
+ 	unsigned char slen = 0;
++>>>>>>> 5786ec605499 (fib_trie: Replace plen with slen in leaf_info)
  
 -	hlist_for_each_entry_safe(li, tmp, &l->list, hlist) {
 +	hlist_for_each_entry_safe(li, tmp, lih, hlist) {
  		found += trie_flush_list(&li->falh);
  
 -		if (hlist_empty(&li->falh)) {
 +		if (list_empty(&li->falh)) {
  			hlist_del_rcu(&li->hlist);
  			free_leaf_info(li);
  			continue;
@@@ -1722,7 -1735,7 +1751,11 @@@ void fib_free_table(struct fib_table *t
  	kfree(tb);
  }
  
++<<<<<<< HEAD
 +static int fn_trie_dump_fa(t_key key, int plen, struct list_head *fah,
++=======
+ static int fn_trie_dump_fa(t_key key, int slen, struct hlist_head *fah,
++>>>>>>> 5786ec605499 (fib_trie: Replace plen with slen in leaf_info)
  			   struct fib_table *tb,
  			   struct sk_buff *skb, struct netlink_callback *cb)
  {
@@@ -1778,10 -1791,10 +1811,10 @@@ static int fn_trie_dump_leaf(struct tno
  		if (i > s_i)
  			cb->args[5] = 0;
  
 -		if (hlist_empty(&li->falh))
 +		if (list_empty(&li->falh))
  			continue;
  
- 		if (fn_trie_dump_fa(l->key, li->plen, &li->falh, tb, skb, cb) < 0) {
+ 		if (fn_trie_dump_fa(l->key, li->slen, &li->falh, tb, skb, cb) < 0) {
  			cb->args[4] = i;
  			return -1;
  		}
@@@ -2417,13 -2431,12 +2451,13 @@@ static int fib_route_seq_show(struct se
  		struct fib_alias *fa;
  		__be32 mask, prefix;
  
- 		mask = inet_make_mask(li->plen);
+ 		mask = inet_make_mask(KEYLENGTH - li->slen);
  		prefix = htonl(l->key);
  
 -		hlist_for_each_entry_rcu(fa, &li->falh, fa_list) {
 +		list_for_each_entry_rcu(fa, &li->falh, fa_list) {
  			const struct fib_info *fi = fa->fa_info;
  			unsigned int flags = fib_flag_trans(fa->fa_type, mask, fi);
 +			int len;
  
  			if (fa->fa_type == RTN_BROADCAST
  			    || fa->fa_type == RTN_MULTICAST)
* Unmerged path net/ipv4/fib_trie.c
