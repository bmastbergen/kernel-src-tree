fib_trie: Convert fib_alias to hlist from list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 56315f9e6e3a0ba0483c2e1f53333d5275268cb1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/56315f9e.failed

There isn't any advantage to having it as a list and by making it an hlist
we make the fib_alias more compatible with the list_info in terms of the
type of list used.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 56315f9e6e3a0ba0483c2e1f53333d5275268cb1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 3fe26090641a,f17e2239b7b9..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -1002,6 -991,27 +1002,30 @@@ static struct tnode *fib_find_node(stru
  	return n;
  }
  
++<<<<<<< HEAD
++=======
+ /* Return the first fib alias matching TOS with
+  * priority less than or equal to PRIO.
+  */
+ static struct fib_alias *fib_find_alias(struct hlist_head *fah, u8 tos,
+ 					u32 prio)
+ {
+ 	struct fib_alias *fa;
+ 
+ 	if (!fah)
+ 		return NULL;
+ 
+ 	hlist_for_each_entry(fa, fah, fa_list) {
+ 		if (fa->fa_tos > tos)
+ 			continue;
+ 		if (fa->fa_info->fib_priority >= prio || fa->fa_tos < tos)
+ 			return fa;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
++>>>>>>> 56315f9e6e3a (fib_trie: Convert fib_alias to hlist from list)
  static void trie_rebalance(struct trie *t, struct tnode *tn)
  {
  	struct tnode *tp;
@@@ -2420,10 -2437,9 +2451,10 @@@ static int fib_route_seq_show(struct se
  		mask = inet_make_mask(li->plen);
  		prefix = htonl(l->key);
  
- 		list_for_each_entry_rcu(fa, &li->falh, fa_list) {
+ 		hlist_for_each_entry_rcu(fa, &li->falh, fa_list) {
  			const struct fib_info *fi = fa->fa_info;
  			unsigned int flags = fib_flag_trans(fa->fa_type, mask, fi);
 +			int len;
  
  			if (fa->fa_type == RTN_BROADCAST
  			    || fa->fa_type == RTN_MULTICAST)
diff --git a/include/net/ip_fib.h b/include/net/ip_fib.h
index b6b47c06a6d0..20b0705cce19 100644
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@ -134,7 +134,7 @@ struct fib_result {
 	u32		tclassid;
 	struct fib_info *fi;
 	struct fib_table *table;
-	struct list_head *fa_head;
+	struct hlist_head *fa_head;
 };
 
 struct fib_result_nl {
diff --git a/net/ipv4/fib_lookup.h b/net/ipv4/fib_lookup.h
index af0f14aba169..8a303b52ed21 100644
--- a/net/ipv4/fib_lookup.h
+++ b/net/ipv4/fib_lookup.h
@@ -6,7 +6,7 @@
 #include <net/ip_fib.h>
 
 struct fib_alias {
-	struct list_head	fa_list;
+	struct hlist_node	fa_list;
 	struct fib_info		*fa_info;
 	u8			fa_tos;
 	u8			fa_type;
diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c
index b6c8c98fb7b5..17a64004b221 100644
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@ -1167,12 +1167,12 @@ int fib_sync_down_dev(struct net_device *dev, int force)
 void fib_select_default(struct fib_result *res)
 {
 	struct fib_info *fi = NULL, *last_resort = NULL;
-	struct list_head *fa_head = res->fa_head;
+	struct hlist_head *fa_head = res->fa_head;
 	struct fib_table *tb = res->table;
 	int order = -1, last_idx = -1;
 	struct fib_alias *fa;
 
-	list_for_each_entry_rcu(fa, fa_head, fa_list) {
+	hlist_for_each_entry_rcu(fa, fa_head, fa_list) {
 		struct fib_info *next_fi = fa->fa_info;
 
 		if (next_fi->fib_scope != res->scope ||
* Unmerged path net/ipv4/fib_trie.c
