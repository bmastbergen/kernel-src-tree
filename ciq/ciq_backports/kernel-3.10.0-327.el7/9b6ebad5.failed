fib_trie: Add slen to fib alias

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 9b6ebad5c3a152271c6af19cd44e20001ae72fe8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/9b6ebad5.failed

Make use of an empty spot in the alias to store the suffix length so that
we don't need to pull that information from the leaf_info structure.

This patch also makes a slight change to the user statistics.  Instead of
incrementing semantic_match_miss once per leaf_info miss we now just
increment it once per leaf if a match was not found.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9b6ebad5c3a152271c6af19cd44e20001ae72fe8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 3fe26090641a,79cd8c029cf4..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -1217,8 -1219,9 +1217,9 @@@ int fib_table_insert(struct fib_table *
  			new_fa->fa_type = cfg->fc_type;
  			state = fa->fa_state;
  			new_fa->fa_state = state & ~FA_S_ACCESSED;
+ 			new_fa->fa_slen = fa->fa_slen;
  
 -			hlist_replace_rcu(&fa->fa_list, &new_fa->fa_list);
 +			list_replace_rcu(&fa->fa_list, &new_fa->fa_list);
  			alias_free_mem_rcu(fa);
  
  			fib_release_info(fi_drop);
@@@ -1407,10 -1420,7 +1407,14 @@@ found
  	hlist_for_each_entry_rcu(li, &n->list, hlist) {
  		struct fib_alias *fa;
  
++<<<<<<< HEAD
 +		if ((key ^ n->key) & li->mask_plen)
 +			continue;
 +
 +		list_for_each_entry_rcu(fa, &li->falh, fa_list) {
++=======
+ 		hlist_for_each_entry_rcu(fa, &li->falh, fa_list) {
++>>>>>>> 9b6ebad5c3a1 (fib_trie: Add slen to fib alias)
  			struct fib_info *fi = fa->fa_info;
  			int nhsel, err;
  
@@@ -1441,7 -1455,7 +1449,11 @@@
  				if (!(fib_flags & FIB_LOOKUP_NOREF))
  					atomic_inc(&fi->fib_clntref);
  
++<<<<<<< HEAD
 +				res->prefixlen = li->plen;
++=======
+ 				res->prefixlen = KEYLENGTH - fa->fa_slen;
++>>>>>>> 9b6ebad5c3a1 (fib_trie: Add slen to fib alias)
  				res->nh_sel = nhsel;
  				res->type = fa->fa_type;
  				res->scope = fi->fib_scope;
@@@ -1722,7 -1734,7 +1733,11 @@@ void fib_free_table(struct fib_table *t
  	kfree(tb);
  }
  
++<<<<<<< HEAD
 +static int fn_trie_dump_fa(t_key key, int plen, struct list_head *fah,
++=======
+ static int fn_trie_dump_fa(t_key key, struct hlist_head *fah,
++>>>>>>> 9b6ebad5c3a1 (fib_trie: Add slen to fib alias)
  			   struct fib_table *tb,
  			   struct sk_buff *skb, struct netlink_callback *cb)
  {
@@@ -1747,7 -1759,7 +1762,11 @@@
  				  tb->tb_id,
  				  fa->fa_type,
  				  xkey,
++<<<<<<< HEAD
 +				  plen,
++=======
+ 				  KEYLENGTH - fa->fa_slen,
++>>>>>>> 9b6ebad5c3a1 (fib_trie: Add slen to fib alias)
  				  fa->fa_tos,
  				  fa->fa_info, NLM_F_MULTI) < 0) {
  			cb->args[5] = i;
@@@ -1778,10 -1790,10 +1797,14 @@@ static int fn_trie_dump_leaf(struct tno
  		if (i > s_i)
  			cb->args[5] = 0;
  
 -		if (hlist_empty(&li->falh))
 +		if (list_empty(&li->falh))
  			continue;
  
++<<<<<<< HEAD
 +		if (fn_trie_dump_fa(l->key, li->plen, &li->falh, tb, skb, cb) < 0) {
++=======
+ 		if (fn_trie_dump_fa(l->key, &li->falh, tb, skb, cb) < 0) {
++>>>>>>> 9b6ebad5c3a1 (fib_trie: Add slen to fib alias)
  			cb->args[4] = i;
  			return -1;
  		}
@@@ -2267,7 -2279,8 +2290,12 @@@ static int fib_trie_seq_show(struct seq
  				char buf1[32], buf2[32];
  
  				seq_indent(seq, iter->depth+1);
++<<<<<<< HEAD
 +				seq_printf(seq, "  /%d %s %s", li->plen,
++=======
+ 				seq_printf(seq, "  /%zu %s %s",
+ 					   KEYLENGTH - fa->fa_slen,
++>>>>>>> 9b6ebad5c3a1 (fib_trie: Add slen to fib alias)
  					   rtn_scope(buf1, sizeof(buf1),
  						     fa->fa_info->fib_scope),
  					   rtn_type(buf2, sizeof(buf2),
@@@ -2413,17 -2427,15 +2442,23 @@@ static int fib_route_seq_show(struct se
  		return 0;
  	}
  
+ 	prefix = htonl(l->key);
+ 
  	hlist_for_each_entry_rcu(li, &l->list, hlist) {
  		struct fib_alias *fa;
++<<<<<<< HEAD
 +		__be32 mask, prefix;
  
 -		hlist_for_each_entry_rcu(fa, &li->falh, fa_list) {
 +		mask = inet_make_mask(li->plen);
 +		prefix = htonl(l->key);
++=======
++>>>>>>> 9b6ebad5c3a1 (fib_trie: Add slen to fib alias)
 +
 +		list_for_each_entry_rcu(fa, &li->falh, fa_list) {
  			const struct fib_info *fi = fa->fa_info;
+ 			__be32 mask = inet_make_mask(KEYLENGTH - fa->fa_slen);
  			unsigned int flags = fib_flag_trans(fa->fa_type, mask, fi);
 +			int len;
  
  			if (fa->fa_type == RTN_BROADCAST
  			    || fa->fa_type == RTN_MULTICAST)
diff --git a/net/ipv4/fib_lookup.h b/net/ipv4/fib_lookup.h
index af0f14aba169..7c1c36eb1fd3 100644
--- a/net/ipv4/fib_lookup.h
+++ b/net/ipv4/fib_lookup.h
@@ -11,6 +11,7 @@ struct fib_alias {
 	u8			fa_tos;
 	u8			fa_type;
 	u8			fa_state;
+	u8			fa_slen;
 	struct rcu_head		rcu;
 };
 
* Unmerged path net/ipv4/fib_trie.c
