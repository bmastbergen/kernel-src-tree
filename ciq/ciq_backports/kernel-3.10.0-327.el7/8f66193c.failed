xfs: convert m_dirblksize to xfs_da_geometry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 8f66193c89f0b0259db6b27b4df3deb828c294f9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/8f66193c.failed

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>


(cherry picked from commit 8f66193c89f0b0259db6b27b4df3deb828c294f9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_da_format.c
#	fs/xfs/xfs_dir2.c
#	fs/xfs/xfs_dir2_leaf.c
#	fs/xfs/xfs_dir2_node.c
#	fs/xfs/xfs_dir2_priv.h
#	fs/xfs/xfs_dir2_sf.c
#	fs/xfs/xfs_mount.h
diff --cc fs/xfs/xfs_da_format.c
index 6ba0090d4962,c9aee52a37e2..000000000000
--- a/fs/xfs/xfs_da_format.c
+++ b/fs/xfs/xfs_da_format.c
@@@ -607,10 -609,10 +607,15 @@@ xfs_dir2_free_bests_p(struct xfs_dir2_f
   * Convert data space db to the corresponding free db.
   */
  static xfs_dir2_db_t
- xfs_dir2_db_to_fdb(struct xfs_mount *mp, xfs_dir2_db_t db)
+ xfs_dir2_db_to_fdb(struct xfs_da_geometry *geo, xfs_dir2_db_t db)
  {
++<<<<<<< HEAD
 +	return xfs_dir2_byte_to_db(mp, XFS_DIR2_FREE_OFFSET) +
 +			(db / xfs_dir2_free_max_bests(mp));
++=======
+ 	return xfs_dir2_byte_to_db(geo, XFS_DIR2_FREE_OFFSET) +
+ 			(db / xfs_dir2_free_max_bests(geo));
++>>>>>>> 8f66193c89f0 (xfs: convert m_dirblksize to xfs_da_geometry)
  }
  
  /*
@@@ -639,10 -641,10 +644,15 @@@ xfs_dir3_free_bests_p(struct xfs_dir2_f
   * Convert data space db to the corresponding free db.
   */
  static xfs_dir2_db_t
- xfs_dir3_db_to_fdb(struct xfs_mount *mp, xfs_dir2_db_t db)
+ xfs_dir3_db_to_fdb(struct xfs_da_geometry *geo, xfs_dir2_db_t db)
  {
++<<<<<<< HEAD
 +	return xfs_dir2_byte_to_db(mp, XFS_DIR2_FREE_OFFSET) +
 +			(db / xfs_dir3_free_max_bests(mp));
++=======
+ 	return xfs_dir2_byte_to_db(geo, XFS_DIR2_FREE_OFFSET) +
+ 			(db / xfs_dir3_free_max_bests(geo));
++>>>>>>> 8f66193c89f0 (xfs: convert m_dirblksize to xfs_da_geometry)
  }
  
  /*
diff --cc fs/xfs/xfs_dir2.c
index b4210d6721ad,2685552480f0..000000000000
--- a/fs/xfs/xfs_dir2.c
+++ b/fs/xfs/xfs_dir2.c
@@@ -140,11 -145,6 +140,14 @@@ xfs_da_mount
  		mp->m_dirnameops = &xfs_default_nameops;
  
  	/* XXX: these are to be removed as code is converted to use geo */
++<<<<<<< HEAD
 +	mp->m_dirblksize = mp->m_dir_geo->blksize;
 +	mp->m_dirblkfsbs = mp->m_dir_geo->fsbcount;
 +	mp->m_dirdatablk = mp->m_dir_geo->datablk;
 +	mp->m_dirleafblk = mp->m_dir_geo->leafblk;
 +	mp->m_dirfreeblk = mp->m_dir_geo->freeblk;
++=======
++>>>>>>> 8f66193c89f0 (xfs: convert m_dirblksize to xfs_da_geometry)
  	mp->m_dir_node_ents = mp->m_dir_geo->node_ents;
  	mp->m_dir_magicpct = mp->m_dir_geo->magicpct;
  	mp->m_attr_node_ents = mp->m_attr_geo->node_ents;
@@@ -663,10 -662,10 +666,10 @@@ xfs_dir2_isblock
  	int		rval;
  
  	mp = dp->i_mount;
 -	if ((rval = xfs_bmap_last_offset(dp, &last, XFS_DATA_FORK)))
 +	if ((rval = xfs_bmap_last_offset(tp, dp, &last, XFS_DATA_FORK)))
  		return rval;
- 	rval = XFS_FSB_TO_B(mp, last) == mp->m_dirblksize;
- 	ASSERT(rval == 0 || dp->i_d.di_size == mp->m_dirblksize);
+ 	rval = XFS_FSB_TO_B(mp, last) == mp->m_dir_geo->blksize;
+ 	ASSERT(rval == 0 || dp->i_d.di_size == mp->m_dir_geo->blksize);
  	*vp = rval;
  	return 0;
  }
diff --cc fs/xfs/xfs_dir2_leaf.c
index 4d5097750d39,e517bd0544cd..000000000000
--- a/fs/xfs/xfs_dir2_leaf.c
+++ b/fs/xfs/xfs_dir2_leaf.c
@@@ -1380,12 -1384,12 +1381,12 @@@ xfs_dir2_leaf_removename
  	 * Point to the leaf entry, use that to point to the data entry.
  	 */
  	lep = &ents[index];
 -	db = xfs_dir2_dataptr_to_db(args->geo, be32_to_cpu(lep->address));
 -	dep = (xfs_dir2_data_entry_t *)((char *)hdr +
 -		xfs_dir2_dataptr_to_off(args->geo, be32_to_cpu(lep->address)));
 +	db = xfs_dir2_dataptr_to_db(mp, be32_to_cpu(lep->address));
 +	dep = (xfs_dir2_data_entry_t *)
 +	      ((char *)hdr + xfs_dir2_dataptr_to_off(mp, be32_to_cpu(lep->address)));
  	needscan = needlog = 0;
  	oldbest = be16_to_cpu(bf[0].length);
- 	ltp = xfs_dir2_leaf_tail_p(mp, leaf);
+ 	ltp = xfs_dir2_leaf_tail_p(args->geo, leaf);
  	bestsp = xfs_dir2_leaf_bests_p(ltp);
  	ASSERT(be16_to_cpu(bestsp[db]) == oldbest);
  	/*
@@@ -1425,8 -1429,8 +1426,13 @@@
  	 * If the data block is now empty then get rid of the data block.
  	 */
  	if (be16_to_cpu(bf[0].length) ==
++<<<<<<< HEAD
 +			mp->m_dirblksize - dp->d_ops->data_entry_offset) {
 +		ASSERT(db != mp->m_dirdatablk);
++=======
+ 			args->geo->blksize - dp->d_ops->data_entry_offset) {
+ 		ASSERT(db != args->geo->datablk);
++>>>>>>> 8f66193c89f0 (xfs: convert m_dirblksize to xfs_da_geometry)
  		if ((error = xfs_dir2_shrink_inode(args, db, dbp))) {
  			/*
  			 * Nope, can't get rid of it because it caused
diff --cc fs/xfs/xfs_dir2_node.c
index 36c68e9c23d3,ef34c197b62f..000000000000
--- a/fs/xfs/xfs_dir2_node.c
+++ b/fs/xfs/xfs_dir2_node.c
@@@ -1245,8 -1252,9 +1246,14 @@@ xfs_dir2_leafn_remove
  		 * Convert the data block number to a free block,
  		 * read in the free block.
  		 */
++<<<<<<< HEAD
 +		fdb = dp->d_ops->db_to_fdb(mp, db);
 +		error = xfs_dir2_free_read(tp, dp, xfs_dir2_db_to_da(mp, fdb),
++=======
+ 		fdb = dp->d_ops->db_to_fdb(args->geo, db);
+ 		error = xfs_dir2_free_read(tp, dp,
+ 					   xfs_dir2_db_to_da(args->geo, fdb),
++>>>>>>> 8f66193c89f0 (xfs: convert m_dirblksize to xfs_da_geometry)
  					   &fbp);
  		if (error)
  			return error;
@@@ -1255,8 -1263,9 +1262,14 @@@
  	{
  		struct xfs_dir3_icfree_hdr freehdr;
  		dp->d_ops->free_hdr_from_disk(&freehdr, free);
++<<<<<<< HEAD
 +		ASSERT(freehdr.firstdb == dp->d_ops->free_max_bests(mp) *
 +			  (fdb - xfs_dir2_byte_to_db(mp, XFS_DIR2_FREE_OFFSET)));
++=======
+ 		ASSERT(freehdr.firstdb == dp->d_ops->free_max_bests(args->geo) *
+ 			(fdb - xfs_dir2_byte_to_db(args->geo,
+ 						   XFS_DIR2_FREE_OFFSET)));
++>>>>>>> 8f66193c89f0 (xfs: convert m_dirblksize to xfs_da_geometry)
  	}
  #endif
  		/*
@@@ -1835,10 -1844,10 +1848,10 @@@ xfs_dir2_node_addname_int
  		 * Get the freespace block corresponding to the data block
  		 * that was just allocated.
  		 */
- 		fbno = dp->d_ops->db_to_fdb(mp, dbno);
+ 		fbno = dp->d_ops->db_to_fdb(args->geo, dbno);
  		error = xfs_dir2_free_try_read(tp, dp,
 -				       xfs_dir2_db_to_da(args->geo, fbno),
 -				       &fbp);
 +					       xfs_dir2_db_to_da(mp, fbno),
 +					       &fbp);
  		if (error)
  			return error;
  
@@@ -1889,9 -1899,9 +1903,9 @@@
  			 * Remember the first slot as our empty slot.
  			 */
  			freehdr.firstdb =
 -				(fbno - xfs_dir2_byte_to_db(args->geo,
 +				(fbno - xfs_dir2_byte_to_db(mp,
  							XFS_DIR2_FREE_OFFSET)) *
- 					dp->d_ops->free_max_bests(mp);
+ 					dp->d_ops->free_max_bests(args->geo);
  		} else {
  			free = fbp->b_addr;
  			bests = dp->d_ops->free_bests_p(free);
diff --cc fs/xfs/xfs_dir2_priv.h
index f3dfbc996c43,436135f28f96..000000000000
--- a/fs/xfs/xfs_dir2_priv.h
+++ b/fs/xfs/xfs_dir2_priv.h
@@@ -20,6 -20,140 +20,143 @@@
  
  struct dir_context;
  
++<<<<<<< HEAD
++=======
+ /*
+  * Directory offset/block conversion functions.
+  *
+  * DB blocks here are logical directory block numbers, not filesystem blocks.
+  */
+ 
+ /*
+  * Convert dataptr to byte in file space
+  */
+ static inline xfs_dir2_off_t
+ xfs_dir2_dataptr_to_byte(xfs_dir2_dataptr_t dp)
+ {
+ 	return (xfs_dir2_off_t)dp << XFS_DIR2_DATA_ALIGN_LOG;
+ }
+ 
+ /*
+  * Convert byte in file space to dataptr.  It had better be aligned.
+  */
+ static inline xfs_dir2_dataptr_t
+ xfs_dir2_byte_to_dataptr(xfs_dir2_off_t by)
+ {
+ 	return (xfs_dir2_dataptr_t)(by >> XFS_DIR2_DATA_ALIGN_LOG);
+ }
+ 
+ /*
+  * Convert byte in space to (DB) block
+  */
+ static inline xfs_dir2_db_t
+ xfs_dir2_byte_to_db(struct xfs_da_geometry *geo, xfs_dir2_off_t by)
+ {
+ 	return (xfs_dir2_db_t)(by >> geo->blklog);
+ }
+ 
+ /*
+  * Convert dataptr to a block number
+  */
+ static inline xfs_dir2_db_t
+ xfs_dir2_dataptr_to_db(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)
+ {
+ 	return xfs_dir2_byte_to_db(geo, xfs_dir2_dataptr_to_byte(dp));
+ }
+ 
+ /*
+  * Convert byte in space to offset in a block
+  */
+ static inline xfs_dir2_data_aoff_t
+ xfs_dir2_byte_to_off(struct xfs_da_geometry *geo, xfs_dir2_off_t by)
+ {
+ 	return (xfs_dir2_data_aoff_t)(by & (geo->blksize - 1));
+ }
+ 
+ /*
+  * Convert dataptr to a byte offset in a block
+  */
+ static inline xfs_dir2_data_aoff_t
+ xfs_dir2_dataptr_to_off(struct xfs_da_geometry *geo, xfs_dir2_dataptr_t dp)
+ {
+ 	return xfs_dir2_byte_to_off(geo, xfs_dir2_dataptr_to_byte(dp));
+ }
+ 
+ /*
+  * Convert block and offset to byte in space
+  */
+ static inline xfs_dir2_off_t
+ xfs_dir2_db_off_to_byte(struct xfs_da_geometry *geo, xfs_dir2_db_t db,
+ 			xfs_dir2_data_aoff_t o)
+ {
+ 	return ((xfs_dir2_off_t)db << geo->blklog) + o;
+ }
+ 
+ /*
+  * Convert block (DB) to block (dablk)
+  */
+ static inline xfs_dablk_t
+ xfs_dir2_db_to_da(struct xfs_da_geometry *geo, xfs_dir2_db_t db)
+ {
+ 	return (xfs_dablk_t)(db << (geo->blklog - geo->fsblog));
+ }
+ 
+ /*
+  * Convert byte in space to (DA) block
+  */
+ static inline xfs_dablk_t
+ xfs_dir2_byte_to_da(struct xfs_da_geometry *geo, xfs_dir2_off_t by)
+ {
+ 	return xfs_dir2_db_to_da(geo, xfs_dir2_byte_to_db(geo, by));
+ }
+ 
+ /*
+  * Convert block and offset to dataptr
+  */
+ static inline xfs_dir2_dataptr_t
+ xfs_dir2_db_off_to_dataptr(struct xfs_da_geometry *geo, xfs_dir2_db_t db,
+ 			   xfs_dir2_data_aoff_t o)
+ {
+ 	return xfs_dir2_byte_to_dataptr(xfs_dir2_db_off_to_byte(geo, db, o));
+ }
+ 
+ /*
+  * Convert block (dablk) to block (DB)
+  */
+ static inline xfs_dir2_db_t
+ xfs_dir2_da_to_db(struct xfs_da_geometry *geo, xfs_dablk_t da)
+ {
+ 	return (xfs_dir2_db_t)(da >> (geo->blklog - geo->fsblog));
+ }
+ 
+ /*
+  * Convert block (dablk) to byte offset in space
+  */
+ static inline xfs_dir2_off_t
+ xfs_dir2_da_to_byte(struct xfs_da_geometry *geo, xfs_dablk_t da)
+ {
+ 	return xfs_dir2_db_off_to_byte(geo, xfs_dir2_da_to_db(geo, da), 0);
+ }
+ 
+ /*
+  * Directory tail pointer accessor functions. Based on block geometry.
+  */
+ static inline struct xfs_dir2_block_tail *
+ xfs_dir2_block_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_data_hdr *hdr)
+ {
+ 	return ((struct xfs_dir2_block_tail *)
+ 		((char *)hdr + geo->blksize)) - 1;
+ }
+ 
+ static inline struct xfs_dir2_leaf_tail *
+ xfs_dir2_leaf_tail_p(struct xfs_da_geometry *geo, struct xfs_dir2_leaf *lp)
+ {
+ 	return (struct xfs_dir2_leaf_tail *)
+ 		((char *)lp + geo->blksize -
+ 		  sizeof(struct xfs_dir2_leaf_tail));
+ }
+ 
++>>>>>>> 8f66193c89f0 (xfs: convert m_dirblksize to xfs_da_geometry)
  /* xfs_dir2.c */
  extern int xfs_dir_ino_validate(struct xfs_mount *mp, xfs_ino_t ino);
  extern int xfs_dir2_grow_inode(struct xfs_da_args *args, int space,
diff --cc fs/xfs/xfs_dir2_sf.c
index 7aab8ec117ad,53c3be619db5..000000000000
--- a/fs/xfs/xfs_dir2_sf.c
+++ b/fs/xfs/xfs_dir2_sf.c
@@@ -104,8 -106,8 +106,13 @@@ xfs_dir2_block_sfsize
  		/*
  		 * Calculate the pointer to the entry at hand.
  		 */
++<<<<<<< HEAD
 +		dep = (xfs_dir2_data_entry_t *)
 +		      ((char *)hdr + xfs_dir2_dataptr_to_off(mp, addr));
++=======
+ 		dep = (xfs_dir2_data_entry_t *)((char *)hdr +
+ 				xfs_dir2_dataptr_to_off(geo, addr));
++>>>>>>> 8f66193c89f0 (xfs: convert m_dirblksize to xfs_da_geometry)
  		/*
  		 * Detect . and .., so we can special-case them.
  		 * . is not included in sf directories.
diff --cc fs/xfs/xfs_mount.h
index 2f4a123357f9,4e3f6cebebc6..000000000000
--- a/fs/xfs/xfs_mount.h
+++ b/fs/xfs/xfs_mount.h
@@@ -154,11 -154,6 +154,14 @@@ typedef struct xfs_mount 
  	const struct xfs_nameops *m_dirnameops;	/* vector of dir name ops */
  	const struct xfs_dir_ops *m_dir_inode_ops; /* vector of dir inode ops */
  	const struct xfs_dir_ops *m_nondir_inode_ops; /* !dir inode ops */
++<<<<<<< HEAD
 +	int			m_dirblksize;	/* directory block sz--bytes */
 +	int			m_dirblkfsbs;	/* directory block sz--fsbs */
 +	xfs_dablk_t		m_dirdatablk;	/* blockno of dir data v2 */
 +	xfs_dablk_t		m_dirleafblk;	/* blockno of dir non-data v2 */
 +	xfs_dablk_t		m_dirfreeblk;	/* blockno of dirfreeindex v2 */
++=======
++>>>>>>> 8f66193c89f0 (xfs: convert m_dirblksize to xfs_da_geometry)
  	uint			m_chsize;	/* size of next field */
  	atomic_t		m_active_trans;	/* number trans frozen */
  #ifdef HAVE_PERCPU_SB
diff --git a/fs/xfs/xfs_da_btree.c b/fs/xfs/xfs_da_btree.c
index 4db5102d403a..71f34843147c 100644
--- a/fs/xfs/xfs_da_btree.c
+++ b/fs/xfs/xfs_da_btree.c
@@ -2177,8 +2177,8 @@ xfs_da3_swap_lastblock(
 	/*
 	 * Copy the last block into the dead buffer and log it.
 	 */
-	memcpy(dead_buf->b_addr, last_buf->b_addr, mp->m_dirblksize);
-	xfs_trans_log_buf(tp, dead_buf, 0, mp->m_dirblksize - 1);
+	memcpy(dead_buf->b_addr, last_buf->b_addr, args->geo->blksize);
+	xfs_trans_log_buf(tp, dead_buf, 0, args->geo->blksize - 1);
 	dead_info = dead_buf->b_addr;
 	/*
 	 * Get values from the moved block.
* Unmerged path fs/xfs/xfs_da_format.c
* Unmerged path fs/xfs/xfs_dir2.c
diff --git a/fs/xfs/xfs_dir2.h b/fs/xfs/xfs_dir2.h
index caf663f31f38..10aff35bb9ae 100644
--- a/fs/xfs/xfs_dir2.h
+++ b/fs/xfs/xfs_dir2.h
@@ -80,7 +80,7 @@ struct xfs_dir_ops {
 				    struct xfs_dir3_icleaf_hdr *from);
 	void	(*leaf_hdr_from_disk)(struct xfs_dir3_icleaf_hdr *to,
 				      struct xfs_dir2_leaf *from);
-	int	(*leaf_max_ents)(struct xfs_mount *mp);
+	int	(*leaf_max_ents)(struct xfs_da_geometry *geo);
 	struct xfs_dir2_leaf_entry *
 		(*leaf_ents_p)(struct xfs_dir2_leaf *lp);
 
@@ -97,10 +97,12 @@ struct xfs_dir_ops {
 				    struct xfs_dir3_icfree_hdr *from);
 	void	(*free_hdr_from_disk)(struct xfs_dir3_icfree_hdr *to,
 				      struct xfs_dir2_free *from);
-	int	(*free_max_bests)(struct xfs_mount *mp);
+	int	(*free_max_bests)(struct xfs_da_geometry *geo);
 	__be16 * (*free_bests_p)(struct xfs_dir2_free *free);
-	xfs_dir2_db_t (*db_to_fdb)(struct xfs_mount *mp, xfs_dir2_db_t db);
-	int	(*db_to_fdindex)(struct xfs_mount *mp, xfs_dir2_db_t db);
+	xfs_dir2_db_t (*db_to_fdb)(struct xfs_da_geometry *geo,
+				   xfs_dir2_db_t db);
+	int	(*db_to_fdindex)(struct xfs_da_geometry *geo,
+				 xfs_dir2_db_t db);
 };
 
 extern const struct xfs_dir_ops *
diff --git a/fs/xfs/xfs_dir2_block.c b/fs/xfs/xfs_dir2_block.c
index 525993902ddb..aee65a05e320 100644
--- a/fs/xfs/xfs_dir2_block.c
+++ b/fs/xfs/xfs_dir2_block.c
@@ -377,7 +377,7 @@ xfs_dir2_block_addname(
 	 * Set up pointers to parts of the block.
 	 */
 	hdr = bp->b_addr;
-	btp = xfs_dir2_block_tail_p(mp, hdr);
+	btp = xfs_dir2_block_tail_p(args->geo, hdr);
 	blp = xfs_dir2_block_leaf_p(btp);
 
 	/*
@@ -581,7 +581,7 @@ xfs_dir2_block_log_leaf(
 	xfs_dir2_leaf_entry_t	*blp;
 	xfs_dir2_block_tail_t	*btp;
 
-	btp = xfs_dir2_block_tail_p(tp->t_mountp, hdr);
+	btp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);
 	blp = xfs_dir2_block_leaf_p(btp);
 	xfs_trans_log_buf(tp, bp, (uint)((char *)&blp[first] - (char *)hdr),
 		(uint)((char *)&blp[last + 1] - (char *)hdr - 1));
@@ -598,7 +598,7 @@ xfs_dir2_block_log_tail(
 	xfs_dir2_data_hdr_t	*hdr = bp->b_addr;
 	xfs_dir2_block_tail_t	*btp;
 
-	btp = xfs_dir2_block_tail_p(tp->t_mountp, hdr);
+	btp = xfs_dir2_block_tail_p(tp->t_mountp->m_dir_geo, hdr);
 	xfs_trans_log_buf(tp, bp, (uint)((char *)btp - (char *)hdr),
 		(uint)((char *)(btp + 1) - (char *)hdr - 1));
 }
@@ -633,7 +633,7 @@ xfs_dir2_block_lookup(
 	mp = dp->i_mount;
 	hdr = bp->b_addr;
 	xfs_dir3_data_check(dp, bp);
-	btp = xfs_dir2_block_tail_p(mp, hdr);
+	btp = xfs_dir2_block_tail_p(args->geo, hdr);
 	blp = xfs_dir2_block_leaf_p(btp);
 	/*
 	 * Get the offset from the leaf entry, to point to the data.
@@ -685,7 +685,7 @@ xfs_dir2_block_lookup_int(
 
 	hdr = bp->b_addr;
 	xfs_dir3_data_check(dp, bp);
-	btp = xfs_dir2_block_tail_p(mp, hdr);
+	btp = xfs_dir2_block_tail_p(args->geo, hdr);
 	blp = xfs_dir2_block_leaf_p(btp);
 	/*
 	 * Loop doing a binary search for our hash value.
@@ -790,7 +790,7 @@ xfs_dir2_block_removename(
 	tp = args->trans;
 	mp = dp->i_mount;
 	hdr = bp->b_addr;
-	btp = xfs_dir2_block_tail_p(mp, hdr);
+	btp = xfs_dir2_block_tail_p(args->geo, hdr);
 	blp = xfs_dir2_block_leaf_p(btp);
 	/*
 	 * Point to the data entry using the leaf entry.
@@ -865,7 +865,7 @@ xfs_dir2_block_replace(
 	dp = args->dp;
 	mp = dp->i_mount;
 	hdr = bp->b_addr;
-	btp = xfs_dir2_block_tail_p(mp, hdr);
+	btp = xfs_dir2_block_tail_p(args->geo, hdr);
 	blp = xfs_dir2_block_leaf_p(btp);
 	/*
 	 * Point to the data entry we need to change.
@@ -938,7 +938,7 @@ xfs_dir2_leaf_to_block(
 	leaf = lbp->b_addr;
 	dp->d_ops->leaf_hdr_from_disk(&leafhdr, leaf);
 	ents = dp->d_ops->leaf_ents_p(leaf);
-	ltp = xfs_dir2_leaf_tail_p(mp, leaf);
+	ltp = xfs_dir2_leaf_tail_p(args->geo, leaf);
 
 	ASSERT(leafhdr.magic == XFS_DIR2_LEAF1_MAGIC ||
 	       leafhdr.magic == XFS_DIR3_LEAF1_MAGIC);
@@ -948,13 +948,13 @@ xfs_dir2_leaf_to_block(
 	 * been left behind during no-space-reservation operations.
 	 * These will show up in the leaf bests table.
 	 */
-	while (dp->i_d.di_size > mp->m_dirblksize) {
+	while (dp->i_d.di_size > args->geo->blksize) {
 		int hdrsz;
 
 		hdrsz = dp->d_ops->data_entry_offset;
 		bestsp = xfs_dir2_leaf_bests_p(ltp);
 		if (be16_to_cpu(bestsp[be32_to_cpu(ltp->bestcount) - 1]) ==
-					    mp->m_dirblksize - hdrsz) {
+					    args->geo->blksize - hdrsz) {
 			if ((error =
 			    xfs_dir2_leaf_trim_data(args, lbp,
 				    (xfs_dir2_db_t)(be32_to_cpu(ltp->bestcount) - 1))))
@@ -982,7 +982,7 @@ xfs_dir2_leaf_to_block(
 	/*
 	 * Look at the last data entry.
 	 */
-	tagp = (__be16 *)((char *)hdr + mp->m_dirblksize) - 1;
+	tagp = (__be16 *)((char *)hdr + args->geo->blksize) - 1;
 	dup = (xfs_dir2_data_unused_t *)((char *)hdr + be16_to_cpu(*tagp));
 	/*
 	 * If it's not free or is too short we can't do it.
@@ -1001,12 +1001,12 @@ xfs_dir2_leaf_to_block(
 	/*
 	 * Use up the space at the end of the block (blp/btp).
 	 */
-	xfs_dir2_data_use_free(tp, dp, dbp, dup, mp->m_dirblksize - size, size,
+	xfs_dir2_data_use_free(tp, dp, dbp, dup, args->geo->blksize - size, size,
 		&needlog, &needscan);
 	/*
 	 * Initialize the block tail.
 	 */
-	btp = xfs_dir2_block_tail_p(mp, hdr);
+	btp = xfs_dir2_block_tail_p(args->geo, hdr);
 	btp->count = cpu_to_be32(leafhdr.count - leafhdr.stale);
 	btp->stale = 0;
 	xfs_dir2_block_log_tail(tp, dbp);
@@ -1140,13 +1140,13 @@ xfs_dir2_sf_to_block(
 	 */
 	dup = dp->d_ops->data_unused_p(hdr);
 	needlog = needscan = 0;
-	xfs_dir2_data_use_free(tp, dp, bp, dup, mp->m_dirblksize - i, i, &needlog,
-		&needscan);
+	xfs_dir2_data_use_free(tp, dp, bp, dup, args->geo->blksize - i,
+			       i, &needlog, &needscan);
 	ASSERT(needscan == 0);
 	/*
 	 * Fill in the tail.
 	 */
-	btp = xfs_dir2_block_tail_p(mp, hdr);
+	btp = xfs_dir2_block_tail_p(args->geo, hdr);
 	btp->count = cpu_to_be32(sfp->count + 2);	/* ., .. */
 	btp->stale = 0;
 	blp = xfs_dir2_block_leaf_p(btp);
diff --git a/fs/xfs/xfs_dir2_data.c b/fs/xfs/xfs_dir2_data.c
index bae8b5b8d1c2..7bf647f87fc3 100644
--- a/fs/xfs/xfs_dir2_data.c
+++ b/fs/xfs/xfs_dir2_data.c
@@ -78,7 +78,7 @@ __xfs_dir3_data_check(
 	switch (hdr->magic) {
 	case cpu_to_be32(XFS_DIR3_BLOCK_MAGIC):
 	case cpu_to_be32(XFS_DIR2_BLOCK_MAGIC):
-		btp = xfs_dir2_block_tail_p(mp, hdr);
+		btp = xfs_dir2_block_tail_p(geo, hdr);
 		lep = xfs_dir2_block_leaf_p(btp);
 		endp = (char *)lep;
 
@@ -94,7 +94,7 @@ __xfs_dir3_data_check(
 		break;
 	case cpu_to_be32(XFS_DIR3_DATA_MAGIC):
 	case cpu_to_be32(XFS_DIR2_DATA_MAGIC):
-		endp = (char *)hdr + mp->m_dirblksize;
+		endp = (char *)hdr + geo->blksize;
 		break;
 	default:
 		XFS_ERROR_REPORT("Bad Magic", XFS_ERRLEVEL_LOW, mp);
@@ -509,6 +509,7 @@ xfs_dir2_data_freescan(
 	struct xfs_dir2_data_free *bf;
 	char			*endp;		/* end of block's data */
 	char			*p;		/* current entry pointer */
+	struct xfs_da_geometry	*geo = dp->i_mount->m_dir_geo;
 
 	ASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||
 	       hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC) ||
@@ -527,10 +528,10 @@ xfs_dir2_data_freescan(
 	p = (char *)dp->d_ops->data_entry_p(hdr);
 	if (hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||
 	    hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC)) {
-		btp = xfs_dir2_block_tail_p(dp->i_mount, hdr);
+		btp = xfs_dir2_block_tail_p(geo, hdr);
 		endp = (char *)xfs_dir2_block_leaf_p(btp);
 	} else
-		endp = (char *)hdr + dp->i_mount->m_dirblksize;
+		endp = (char *)hdr + geo->blksize;
 	/*
 	 * Loop over the block's entries.
 	 */
@@ -620,7 +621,7 @@ xfs_dir3_data_init(
 	dup = dp->d_ops->data_unused_p(hdr);
 	dup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);
 
-	t = mp->m_dirblksize - (uint)dp->d_ops->data_entry_offset;
+	t = args->geo->blksize - (uint)dp->d_ops->data_entry_offset;
 	bf[0].length = cpu_to_be16(t);
 	dup->length = cpu_to_be16(t);
 	*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16((char *)dup - (char *)hdr);
@@ -730,22 +731,24 @@ xfs_dir2_data_make_free(
 	xfs_dir2_data_unused_t	*postdup;	/* unused entry after us */
 	xfs_dir2_data_unused_t	*prevdup;	/* unused entry before us */
 	struct xfs_dir2_data_free *bf;
+	struct xfs_da_geometry	*geo;
 
 	mp = tp->t_mountp;
 	hdr = bp->b_addr;
+	geo = mp->m_dir_geo;
 
 	/*
 	 * Figure out where the end of the data area is.
 	 */
 	if (hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC) ||
 	    hdr->magic == cpu_to_be32(XFS_DIR3_DATA_MAGIC))
-		endptr = (char *)hdr + mp->m_dirblksize;
+		endptr = (char *)hdr + geo->blksize;
 	else {
 		xfs_dir2_block_tail_t	*btp;	/* block tail */
 
 		ASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_BLOCK_MAGIC) ||
 			hdr->magic == cpu_to_be32(XFS_DIR3_BLOCK_MAGIC));
-		btp = xfs_dir2_block_tail_p(mp, hdr);
+		btp = xfs_dir2_block_tail_p(geo, hdr);
 		endptr = (char *)xfs_dir2_block_leaf_p(btp);
 	}
 	/*
* Unmerged path fs/xfs/xfs_dir2_leaf.c
* Unmerged path fs/xfs/xfs_dir2_node.c
* Unmerged path fs/xfs/xfs_dir2_priv.h
diff --git a/fs/xfs/xfs_dir2_readdir.c b/fs/xfs/xfs_dir2_readdir.c
index d6645e8c5ecc..1a07a62c5a62 100644
--- a/fs/xfs/xfs_dir2_readdir.c
+++ b/fs/xfs/xfs_dir2_readdir.c
@@ -220,7 +220,7 @@ xfs_dir2_block_getdents(
 	/*
 	 * Set up values for the loop.
 	 */
-	btp = xfs_dir2_block_tail_p(mp, hdr);
+	btp = xfs_dir2_block_tail_p(geo, hdr);
 	ptr = (char *)dp->d_ops->data_entry_p(hdr);
 	endptr = (char *)xfs_dir2_block_leaf_p(btp);
 
@@ -341,7 +341,7 @@ xfs_dir2_leaf_readbuf(
 	/*
 	 * Recalculate the readahead blocks wanted.
 	 */
-	mip->ra_want = howmany(bufsize + mp->m_dirblksize,
+	mip->ra_want = howmany(bufsize + geo->blksize,
 			       mp->m_sb.sb_blocksize) - 1;
 	ASSERT(mip->ra_want >= 0);
 
@@ -529,8 +529,7 @@ xfs_dir2_leaf_getdents(
 	 * buffer size, the directory block size, and the filesystem
 	 * block size.
 	 */
-	length = howmany(bufsize + mp->m_dirblksize,
-				     mp->m_sb.sb_blocksize);
+	length = howmany(bufsize + geo->blksize, mp->m_sb.sb_blocksize);
 	map_info = kmem_zalloc(offsetof(struct xfs_dir2_leaf_map_info, map) +
 				(length * sizeof(struct xfs_bmbt_irec)),
 			       KM_SLEEP | KM_NOFS);
@@ -560,7 +559,7 @@ xfs_dir2_leaf_getdents(
 		 * If we have no buffer, or we're off the end of the
 		 * current buffer, need to get another one.
 		 */
-		if (!bp || ptr >= (char *)bp->b_addr + mp->m_dirblksize) {
+		if (!bp || ptr >= (char *)bp->b_addr + geo->blksize) {
 
 			error = xfs_dir2_leaf_readbuf(dp, bufsize, map_info,
 						      &curoff, &bp);
@@ -620,7 +619,7 @@ xfs_dir2_leaf_getdents(
 					xfs_dir2_db_off_to_byte(mp,
 					    xfs_dir2_byte_to_db(mp, curoff),
 					    (char *)ptr - (char *)hdr);
-				if (ptr >= (char *)hdr + mp->m_dirblksize) {
+				if (ptr >= (char *)hdr + geo->blksize) {
 					continue;
 				}
 			}
* Unmerged path fs/xfs/xfs_dir2_sf.c
diff --git a/fs/xfs/xfs_fsops.c b/fs/xfs/xfs_fsops.c
index 3445ead7c1fc..a8cbcf06e792 100644
--- a/fs/xfs/xfs_fsops.c
+++ b/fs/xfs/xfs_fsops.c
@@ -24,6 +24,8 @@
 #include "xfs_sb.h"
 #include "xfs_ag.h"
 #include "xfs_mount.h"
+#include "xfs_da_format.h"
+#include "xfs_da_btree.h"
 #include "xfs_inode.h"
 #include "xfs_trans.h"
 #include "xfs_inode_item.h"
@@ -110,7 +112,7 @@ xfs_fs_geometry(
 		geo->logsectsize = xfs_sb_version_hassector(&mp->m_sb) ?
 				mp->m_sb.sb_logsectsize : BBSIZE;
 		geo->rtsectsize = mp->m_sb.sb_blocksize;
-		geo->dirblocksize = mp->m_dirblksize;
+		geo->dirblocksize = mp->m_dir_geo->blksize;
 	}
 	if (new_version >= 4) {
 		geo->flags |=
* Unmerged path fs/xfs/xfs_mount.h
diff --git a/fs/xfs/xfs_trans_resv.c b/fs/xfs/xfs_trans_resv.c
index be8e370802d6..11a55e96be84 100644
--- a/fs/xfs/xfs_trans_resv.c
+++ b/fs/xfs/xfs_trans_resv.c
@@ -568,7 +568,7 @@ xfs_calc_addafork_reservation(
 	return XFS_DQUOT_LOGRES(mp) +
 		xfs_calc_inode_res(mp, 1) +
 		xfs_calc_buf_res(2, mp->m_sb.sb_sectsize) +
-		xfs_calc_buf_res(1, mp->m_dirblksize) +
+		xfs_calc_buf_res(1, mp->m_dir_geo->blksize) +
 		xfs_calc_buf_res(XFS_DAENTER_BMAP1B(mp, XFS_DATA_FORK) + 1,
 				 XFS_FSB_TO_B(mp, 1)) +
 		xfs_calc_buf_res(XFS_ALLOCFREE_LOG_COUNT(mp, 1),
