firmware: dmi_scan: Use direct access to static vars

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [firmware] dmi_scan: Use direct access to static vars (Jarod Wilson) [853192]
Rebuild_FUZZ: 89.36%
commit-author Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
commit 552e19d8764aeea3ecdf6cf29e22d6b99a505091
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/552e19d8.failed

There is no reason to pass static vars to function that can use
only them.

The dmi_table() can use only dmi_len and dmi_num static vars, so use
them directly. In this case we can freely change their type in one
place and slightly decrease redundancy.

	Signed-off-by: Ivan Khoronzhuk <ivan.khoronzhuk@linaro.org>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit 552e19d8764aeea3ecdf6cf29e22d6b99a505091)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/dmi_scan.c
diff --cc drivers/firmware/dmi_scan.c
index aef094cb4e8f,c9cb725520c5..000000000000
--- a/drivers/firmware/dmi_scan.c
+++ b/drivers/firmware/dmi_scan.c
@@@ -15,9 -15,11 +15,15 @@@
   * of and an antecedent to, SMBIOS, which stands for System
   * Management BIOS.  See further: http://www.dmtf.org/standards
   */
 -static const char dmi_empty_string[] = "        ";
 +static char dmi_empty_string[] = "        ";
  
++<<<<<<< HEAD
 +static u16 __initdata dmi_ver;
++=======
+ static u32 dmi_ver __initdata;
+ static u32 dmi_len;
+ static u16 dmi_num;
++>>>>>>> 552e19d8764a (firmware: dmi_scan: Use direct access to static vars)
  /*
   * Catch too early calls to dmi_check_system():
   */
@@@ -80,7 -80,7 +86,11 @@@ static char * __init dmi_string(const s
   *	We have to be cautious here. We have seen BIOSes with DMI pointers
   *	pointing to completely the wrong place for example
   */
++<<<<<<< HEAD
 +static void dmi_table(u8 *buf, int len, int num,
++=======
+ static void dmi_table(u8 *buf,
++>>>>>>> 552e19d8764a (firmware: dmi_scan: Use direct access to static vars)
  		      void (*decode)(const struct dmi_header *, void *),
  		      void *private_data)
  {
@@@ -88,13 -88,11 +98,18 @@@
  	int i = 0;
  
  	/*
 -	 *	Stop when we see all the items the table claimed to have
 -	 *	OR we run off the end of the table (also happens)
 +	 * Stop when we have seen all the items the table claimed to have
 +	 * (SMBIOS < 3.0 only) OR we reach an end-of-table marker OR we run
 +	 * off the end of the table (should never happen but sometimes does
 +	 * on bogus implementations.)
  	 */
++<<<<<<< HEAD
 +	while ((!num || i < num) &&
 +	       (data - buf + sizeof(struct dmi_header)) <= len) {
++=======
+ 	while ((i < dmi_num) && (data - buf + sizeof(struct dmi_header))
+ 		<= dmi_len) {
++>>>>>>> 552e19d8764a (firmware: dmi_scan: Use direct access to static vars)
  		const struct dmi_header *dm = (const struct dmi_header *)data;
  
  		/*
@@@ -120,8 -118,6 +135,11 @@@
  }
  
  static phys_addr_t dmi_base;
++<<<<<<< HEAD
 +static u16 dmi_len;
 +static u16 dmi_num;
++=======
++>>>>>>> 552e19d8764a (firmware: dmi_scan: Use direct access to static vars)
  
  static int __init dmi_walk_early(void (*decode)(const struct dmi_header *,
  		void *))
@@@ -908,9 -906,9 +926,9 @@@ int dmi_walk(void (*decode)(const struc
  	if (buf == NULL)
  		return -1;
  
- 	dmi_table(buf, dmi_len, dmi_num, decode, private_data);
+ 	dmi_table(buf, decode, private_data);
  
 -	dmi_unmap(buf);
 +	iounmap(buf);
  	return 0;
  }
  EXPORT_SYMBOL_GPL(dmi_walk);
* Unmerged path drivers/firmware/dmi_scan.c
