fib_trie: Rename tnode to key_vector

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alexander Duyck <alexander.h.duyck@redhat.com>
commit 35c6edac197fcfb53cea9993d9b64386b15abf48
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/35c6edac.failed

Rename the tnode to key_vector.  The key_vector will be the eventual
container for all of the information needed by either a leaf or a tnode.
The final result should be much smaller than the 40 bytes currently needed
for either one.

This also updates the trie struct so that it contains an array of size 1 of
tnode pointers.  This is to bring the structure more inline with how an
actual tnode itself is configured.

	Signed-off-by: Alexander Duyck <alexander.h.duyck@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 35c6edac197fcfb53cea9993d9b64386b15abf48)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 8be89b1a8b93,8b21fc3da43e..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -93,32 -94,27 +93,54 @@@ typedef unsigned int t_key
  
  #define get_index(_key, _kv) (((_key) ^ (_kv)->key) >> (_kv)->pos)
  
++<<<<<<< HEAD
 +struct tnode {
++=======
+ struct key_vector {
+ 	struct rcu_head rcu;
+ 
+ 	t_key empty_children; /* KEYLENGTH bits needed */
+ 	t_key full_children;  /* KEYLENGTH bits needed */
+ 	struct key_vector __rcu *parent;
+ 
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	t_key key;
 -	unsigned char pos;		/* 2log(KEYLENGTH) bits needed */
  	unsigned char bits;		/* 2log(KEYLENGTH) bits needed */
 +	unsigned char pos;		/* 2log(KEYLENGTH) bits needed */
  	unsigned char slen;
 +	struct tnode __rcu *parent;
 +	struct rcu_head rcu;
  	union {
++<<<<<<< HEAD
 +		/* The fields in this struct are valid if bits > 0 (TNODE) */
 +		struct {
 +			t_key empty_children; /* KEYLENGTH bits needed */
 +			t_key full_children;  /* KEYLENGTH bits needed */
 +			struct tnode __rcu *child[0];
 +		};
 +		/* This list pointer if valid if bits == 0 (LEAF) */
 +		struct hlist_head list;
 +	};
 +};
 +
 +struct leaf_info {
 +	struct hlist_node hlist;
 +	int plen;
 +	u32 mask_plen; /* ntohl(inet_make_mask(plen)) */
 +	struct list_head falh;
 +	struct rcu_head rcu;
 +};
++=======
+ 		/* This list pointer if valid if (pos | bits) == 0 (LEAF) */
+ 		struct hlist_head leaf;
+ 		/* This array is valid if (pos | bits) > 0 (TNODE) */
+ 		struct key_vector __rcu *tnode[0];
+ 	};
+ };
+ 
+ #define TNODE_SIZE(n)	offsetof(struct key_vector, tnode[n])
+ #define LEAF_SIZE	TNODE_SIZE(1)
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  
  #ifdef CONFIG_IP_FIB_TRIE_STATS
  struct trie_use_stats {
@@@ -148,7 -144,7 +170,11 @@@ struct trie 
  #endif
  };
  
++<<<<<<< HEAD
 +static void resize(struct trie *t, struct tnode *tn);
++=======
+ static struct key_vector **resize(struct trie *t, struct key_vector *tn);
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  static size_t tnode_free_size;
  
  /*
@@@ -185,17 -181,24 +211,17 @@@ static inline unsigned long tnode_child
  }
  
  /* caller must hold RTNL */
- static inline struct tnode *tnode_get_child(const struct tnode *tn,
- 					    unsigned long i)
+ static inline struct key_vector *tnode_get_child(struct key_vector *tn,
+ 						 unsigned long i)
  {
 -	return rtnl_dereference(tn->tnode[i]);
 +	return rtnl_dereference(tn->child[i]);
  }
  
  /* caller must hold RCU read lock or RTNL */
- static inline struct tnode *tnode_get_child_rcu(const struct tnode *tn,
- 						unsigned long i)
+ static inline struct key_vector *tnode_get_child_rcu(struct key_vector *tn,
+ 						     unsigned long i)
  {
 -	return rcu_dereference_rtnl(tn->tnode[i]);
 -}
 -
 -static inline struct fib_table *trie_get_table(struct trie *t)
 -{
 -	unsigned long *tb_data = (unsigned long *)t;
 -
 -	return container_of(tb_data, struct fib_table, tb_data[0]);
 +	return rcu_dereference_rtnl(tn->child[i]);
  }
  
  /* To understand this stuff, an understanding of keys and all their bits is
@@@ -274,7 -277,9 +300,13 @@@ static inline void alias_free_mem_rcu(s
  }
  
  #define TNODE_KMALLOC_MAX \
++<<<<<<< HEAD
 +	ilog2((PAGE_SIZE - sizeof(struct tnode)) / sizeof(struct tnode *))
++=======
+ 	ilog2((PAGE_SIZE - TNODE_SIZE(0)) / sizeof(struct key_vector *))
+ #define TNODE_VMALLOC_MAX \
+ 	ilog2((SIZE_MAX - TNODE_SIZE(0)) / sizeof(struct key_vector *))
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  
  static void __node_free_rcu(struct rcu_head *head)
  {
@@@ -290,13 -295,17 +322,17 @@@
  
  #define node_free(n) call_rcu(&n->rcu, __node_free_rcu)
  
++<<<<<<< HEAD
 +static inline void free_leaf_info(struct leaf_info *leaf)
++=======
+ static struct key_vector *tnode_alloc(int bits)
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  {
 -	size_t size;
 -
 -	/* verify bits is within bounds */
 -	if (bits > TNODE_VMALLOC_MAX)
 -		return NULL;
 -
 -	/* determine size and verify it is non-zero and didn't overflow */
 -	size = TNODE_SIZE(1ul << bits);
 +	kfree_rcu(leaf, rcu);
 +}
  
 +static struct tnode *tnode_alloc(size_t size)
 +{
  	if (size <= PAGE_SIZE)
  		return kzalloc(size, GFP_KERNEL);
  	else
@@@ -313,9 -322,9 +349,13 @@@ static inline void empty_child_dec(stru
  	n->empty_children-- ? : n->full_children--;
  }
  
++<<<<<<< HEAD
 +static struct tnode *leaf_new(t_key key)
++=======
+ static struct key_vector *leaf_new(t_key key, struct fib_alias *fa)
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  {
- 	struct tnode *l = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);
+ 	struct key_vector *l = kmem_cache_alloc(trie_leaf_kmem, GFP_KERNEL);
  	if (l) {
  		l->parent = NULL;
  		/* set key and pos to reflect full key value
@@@ -333,21 -344,9 +373,27 @@@
  	return l;
  }
  
++<<<<<<< HEAD
 +static struct leaf_info *leaf_info_new(int plen)
 +{
 +	struct leaf_info *li = kmalloc(sizeof(struct leaf_info),  GFP_KERNEL);
 +	if (li) {
 +		li->plen = plen;
 +		li->mask_plen = ntohl(inet_make_mask(plen));
 +		INIT_LIST_HEAD(&li->falh);
 +	}
 +	return li;
 +}
 +
 +static struct tnode *tnode_new(t_key key, int pos, int bits)
 +{
 +	size_t sz = offsetof(struct tnode, child[1ul << bits]);
 +	struct tnode *tn = tnode_alloc(sz);
++=======
+ static struct key_vector *tnode_new(t_key key, int pos, int bits)
+ {
+ 	struct key_vector *tn = tnode_alloc(bits);
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	unsigned int shift = pos + bits;
  
  	/* verify bits and pos their msb bits clear and values are valid */
@@@ -365,8 -364,8 +411,13 @@@
  			tn->empty_children = 1ul << bits;
  	}
  
++<<<<<<< HEAD
 +	pr_debug("AT %p s=%zu %zu\n", tn, sizeof(struct tnode),
 +		 sizeof(struct tnode *) << bits);
++=======
+ 	pr_debug("AT %p s=%zu %zu\n", tn, TNODE_SIZE(0),
+ 		 sizeof(struct key_vector *) << bits);
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	return tn;
  }
  
@@@ -406,10 -406,10 +458,10 @@@ static void put_child(struct key_vecto
  	if (n && (tn->slen < n->slen))
  		tn->slen = n->slen;
  
 -	rcu_assign_pointer(tn->tnode[i], n);
 +	rcu_assign_pointer(tn->child[i], n);
  }
  
- static void update_children(struct tnode *tn)
+ static void update_children(struct key_vector *tn)
  {
  	unsigned long i;
  
@@@ -457,10 -458,10 +510,10 @@@ static void tnode_free(struct key_vecto
  
  	while (head) {
  		head = head->next;
 -		tnode_free_size += TNODE_SIZE(1ul << tn->bits);
 +		tnode_free_size += offsetof(struct tnode, child[1 << tn->bits]);
  		node_free(tn);
  
- 		tn = container_of(head, struct tnode, rcu);
+ 		tn = container_of(head, struct key_vector, rcu);
  	}
  
  	if (tnode_free_size >= PAGE_SIZE * sync_pages) {
@@@ -469,9 -470,12 +522,18 @@@
  	}
  }
  
++<<<<<<< HEAD
 +static void replace(struct trie *t, struct tnode *oldtnode, struct tnode *tn)
 +{
 +	struct tnode *tp = node_parent(oldtnode);
++=======
+ static struct key_vector __rcu **replace(struct trie *t,
+ 					 struct key_vector *oldtnode,
+ 					 struct key_vector *tn)
+ {
+ 	struct key_vector *tp = node_parent(oldtnode);
+ 	struct key_vector **cptr;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	unsigned long i;
  
  	/* setup the parent pointer out of and back into this node */
@@@ -484,19 -488,25 +546,30 @@@
  	/* all pointers should be clean so we are done */
  	tnode_free(oldtnode);
  
++<<<<<<< HEAD
++=======
+ 	/* record the pointer that is pointing to this node */
+ 	cptr = tp ? tp->tnode : t->tnode;
+ 
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	/* resize children now that oldtnode is freed */
  	for (i = tnode_child_length(tn); i;) {
- 		struct tnode *inode = tnode_get_child(tn, --i);
+ 		struct key_vector *inode = tnode_get_child(tn, --i);
  
  		/* resize child node */
  		if (tnode_full(tn, inode))
  			resize(t, inode);
  	}
 -
 -	return cptr;
  }
  
++<<<<<<< HEAD
 +static int inflate(struct trie *t, struct tnode *oldtnode)
++=======
+ static struct key_vector __rcu **inflate(struct trie *t,
+ 					 struct key_vector *oldtnode)
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  {
- 	struct tnode *tn;
+ 	struct key_vector *tn;
  	unsigned long i;
  	t_key m;
  
@@@ -587,12 -595,14 +660,17 @@@
  nomem:
  	/* all pointers should be clean so we are done */
  	tnode_free(tn);
 -notnode:
 -	return NULL;
 +	return -ENOMEM;
  }
  
++<<<<<<< HEAD
 +static int halve(struct trie *t, struct tnode *oldtnode)
++=======
+ static struct key_vector __rcu **halve(struct trie *t,
+ 				       struct key_vector *oldtnode)
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  {
- 	struct tnode *tn;
+ 	struct key_vector *tn;
  	unsigned long i;
  
  	pr_debug("In halve\n");
@@@ -638,14 -646,17 +716,14 @@@
  	}
  
  	/* setup the parent pointers into and out of this node */
 -	return replace(t, oldtnode, tn);
 -nomem:
 -	/* all pointers should be clean so we are done */
 -	tnode_free(tn);
 -notnode:
 -	return NULL;
 +	replace(t, oldtnode, tn);
 +
 +	return 0;
  }
  
- static void collapse(struct trie *t, struct tnode *oldtnode)
+ static void collapse(struct trie *t, struct key_vector *oldtnode)
  {
- 	struct tnode *n, *tp;
+ 	struct key_vector *n, *tp;
  	unsigned long i;
  
  	/* scan the tnode looking for that one child that might still exist */
@@@ -797,10 -808,15 +875,22 @@@ static inline bool should_collapse(stru
  }
  
  #define MAX_WORK 10
++<<<<<<< HEAD
 +static void resize(struct trie *t, struct tnode *tn)
 +{
 +	struct tnode *tp = node_parent(tn);
 +	struct tnode __rcu **cptr;
++=======
+ static struct key_vector __rcu **resize(struct trie *t,
+ 					struct key_vector *tn)
+ {
+ #ifdef CONFIG_IP_FIB_TRIE_STATS
+ 	struct trie_use_stats __percpu *stats = t->stats;
+ #endif
+ 	struct key_vector *tp = node_parent(tn);
+ 	unsigned long cindex = tp ? get_index(tn->key, tp) : 0;
+ 	struct key_vector __rcu **cptr = tp ? tp->tnode : t->tnode;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	int max_work = MAX_WORK;
  
  	pr_debug("In tnode_resize %p inflate_threshold=%d threshold=%d\n",
@@@ -817,9 -832,11 +907,15 @@@
  	 * nonempty nodes that are above the threshold.
  	 */
  	while (should_inflate(tp, tn) && max_work) {
++<<<<<<< HEAD
 +		if (inflate(t, tn)) {
++=======
+ 		struct key_vector __rcu **tcptr = inflate(t, tn);
+ 
+ 		if (!tcptr) {
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  #ifdef CONFIG_IP_FIB_TRIE_STATS
 -			this_cpu_inc(stats->resize_node_skipped);
 +			this_cpu_inc(t->stats->resize_node_skipped);
  #endif
  			break;
  		}
@@@ -836,9 -854,11 +932,15 @@@
  	 * node is above threshold.
  	 */
  	while (should_halve(tp, tn) && max_work) {
++<<<<<<< HEAD
 +		if (halve(t, tn)) {
++=======
+ 		struct key_vector __rcu **tcptr = halve(t, tn);
+ 
+ 		if (!tcptr) {
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  #ifdef CONFIG_IP_FIB_TRIE_STATS
 -			this_cpu_inc(stats->resize_node_skipped);
 +			this_cpu_inc(t->stats->resize_node_skipped);
  #endif
  			break;
  		}
@@@ -864,37 -885,12 +966,41 @@@
  		if (tp && (slen > tp->slen))
  			tp->slen = slen;
  	}
 -
 -	return cptr;
  }
  
++<<<<<<< HEAD
 +/* readside must use rcu_read_lock currently dump routines
 + via get_fa_head and dump */
 +
 +static struct leaf_info *find_leaf_info(struct tnode *l, int plen)
++=======
+ static void leaf_pull_suffix(struct key_vector *tp, struct key_vector *l)
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  {
 +	struct hlist_head *head = &l->list;
 +	struct leaf_info *li;
 +
 +	hlist_for_each_entry_rcu(li, head, hlist)
 +		if (li->plen == plen)
 +			return li;
 +
 +	return NULL;
 +}
 +
 +static inline struct list_head *get_fa_head(struct tnode *l, int plen)
 +{
 +	struct leaf_info *li = find_leaf_info(l, plen);
 +
 +	if (!li)
 +		return NULL;
 +
 +	return &li->falh;
 +}
 +
 +static void leaf_pull_suffix(struct tnode *l)
 +{
 +	struct tnode *tp = node_parent(l);
 +
  	while (tp && (tp->slen > tp->pos) && (tp->slen > l->slen)) {
  		if (update_suffix(tp) > l->slen)
  			break;
@@@ -902,10 -898,8 +1008,14 @@@
  	}
  }
  
++<<<<<<< HEAD
 +static void leaf_push_suffix(struct tnode *l)
++=======
+ static void leaf_push_suffix(struct key_vector *tn, struct key_vector *l)
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  {
 +	struct tnode *tn = node_parent(l);
 +
  	/* if this is a new leaf then tn will be NULL and we can sort
  	 * out parent suffix lengths as a part of trie_rebalance
  	 */
@@@ -915,55 -909,11 +1025,63 @@@
  	}
  }
  
++<<<<<<< HEAD
 +static void remove_leaf_info(struct tnode *l, struct leaf_info *old)
 +{
 +	/* record the location of the previous list_info entry */
 +	struct hlist_node **pprev = old->hlist.pprev;
 +	struct leaf_info *li = hlist_entry(pprev, typeof(*li), hlist.next);
 +
 +	/* remove the leaf info from the list */
 +	hlist_del_rcu(&old->hlist);
 +
 +	/* only access li if it is pointing at the last valid hlist_node */
 +	if (hlist_empty(&l->list) || (*pprev))
 +		return;
 +
 +	/* update the trie with the latest suffix length */
 +	l->slen = KEYLENGTH - li->plen;
 +	leaf_pull_suffix(l);
 +}
 +
 +static void insert_leaf_info(struct tnode *l, struct leaf_info *new)
 +{
 +	struct hlist_head *head = &l->list;
 +	struct leaf_info *li = NULL, *last = NULL;
 +
 +	if (hlist_empty(head)) {
 +		hlist_add_head_rcu(&new->hlist, head);
 +	} else {
 +		hlist_for_each_entry(li, head, hlist) {
 +			if (new->plen > li->plen)
 +				break;
 +
 +			last = li;
 +		}
 +		if (last)
 +			hlist_add_after_rcu(&last->hlist, &new->hlist);
 +		else
 +			hlist_add_before_rcu(&new->hlist, &li->hlist);
 +	}
 +
 +	/* if we added to the tail node then we need to update slen */
 +	if (l->slen < (KEYLENGTH - new->plen)) {
 +		l->slen = KEYLENGTH - new->plen;
 +		leaf_push_suffix(l);
 +	}
 +}
 +
 +/* rcu_read_lock needs to be hold by caller from readside */
 +static struct tnode *fib_find_node(struct trie *t, u32 key)
 +{
 +	struct tnode *n = rcu_dereference_rtnl(t->trie);
++=======
+ /* rcu_read_lock needs to be hold by caller from readside */
+ static struct key_vector *fib_find_node(struct trie *t,
+ 					struct key_vector **tp, u32 key)
+ {
+ 	struct key_vector *pn = NULL, *n = rcu_dereference_rtnl(t->tnode[0]);
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  
  	while (n) {
  		unsigned long index = get_index(key, n);
@@@ -988,80 -944,65 +1106,139 @@@
  		n = tnode_get_child_rcu(n, index);
  	}
  
++<<<<<<< HEAD
 +	return n;
 +}
 +
 +static void trie_rebalance(struct trie *t, struct tnode *tn)
 +{
 +	struct tnode *tp;
 +
 +	while ((tp = node_parent(tn)) != NULL) {
 +		resize(t, tn);
 +		tn = tp;
++=======
+ 	*tp = pn;
+ 
+ 	return n;
+ }
+ 
+ /* Return the first fib alias matching TOS with
+  * priority less than or equal to PRIO.
+  */
+ static struct fib_alias *fib_find_alias(struct hlist_head *fah, u8 slen,
+ 					u8 tos, u32 prio)
+ {
+ 	struct fib_alias *fa;
+ 
+ 	if (!fah)
+ 		return NULL;
+ 
+ 	hlist_for_each_entry(fa, fah, fa_list) {
+ 		if (fa->fa_slen < slen)
+ 			continue;
+ 		if (fa->fa_slen != slen)
+ 			break;
+ 		if (fa->fa_tos > tos)
+ 			continue;
+ 		if (fa->fa_info->fib_priority >= prio || fa->fa_tos < tos)
+ 			return fa;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static void trie_rebalance(struct trie *t, struct key_vector *tn)
+ {
+ 	struct key_vector __rcu **cptr = t->tnode;
+ 
+ 	while (tn) {
+ 		struct key_vector *tp = node_parent(tn);
+ 
+ 		cptr = resize(t, tn);
+ 		if (!tp)
+ 			break;
+ 		tn = container_of(cptr, struct key_vector, tnode[0]);
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	}
 +
 +	/* Handle last (top) tnode */
 +	if (IS_TNODE(tn))
 +		resize(t, tn);
  }
  
++<<<<<<< HEAD
 +/* only used from updater-side */
 +
 +static struct list_head *fib_insert_node(struct trie *t, u32 key, int plen)
 +{
 +	struct list_head *fa_head = NULL;
 +	struct tnode *l, *n, *tp = NULL;
 +	struct leaf_info *li;
++=======
+ static int fib_insert_node(struct trie *t, struct key_vector *tp,
+ 			   struct fib_alias *new, t_key key)
+ {
+ 	struct key_vector *n, *l;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  
 -	l = leaf_new(key, new);
 -	if (!l)
 -		goto noleaf;
 +	li = leaf_info_new(plen);
 +	if (!li)
 +		return NULL;
 +	fa_head = &li->falh;
 +
++<<<<<<< HEAD
 +	n = rtnl_dereference(t->trie);
 +
 +	/* If we point to NULL, stop. Either the tree is empty and we should
 +	 * just put a new leaf in if, or we have reached an empty child slot,
 +	 * and we should just put our new leaf in that.
 +	 *
 +	 * If we hit a node with a key that does't match then we should stop
 +	 * and create a new tnode to replace that node and insert ourselves
 +	 * and the other node into the new tnode.
 +	 */
 +	while (n) {
 +		unsigned long index = get_index(key, n);
 +
 +		/* This bit of code is a bit tricky but it combines multiple
 +		 * checks into a single check.  The prefix consists of the
 +		 * prefix plus zeros for the "bits" in the prefix. The index
 +		 * is the difference between the key and this value.  From
 +		 * this we can actually derive several pieces of data.
 +		 *   if !(index >> bits)
 +		 *     we know the value is child index
 +		 *   else
 +		 *     we have a mismatch in skip bits and failed
 +		 */
 +		if (index >> n->bits)
 +			break;
 +
 +		/* we have found a leaf. Prefixes have already been compared */
 +		if (IS_LEAF(n)) {
 +			/* Case 1: n is a leaf, and prefixes match*/
 +			insert_leaf_info(n, li);
 +			return fa_head;
 +		}
  
 +		tp = n;
 +		n = tnode_get_child_rcu(n, index);
 +	}
 +
 +	l = leaf_new(key);
 +	if (!l) {
 +		free_leaf_info(li);
 +		return NULL;
 +	}
 +
 +	insert_leaf_info(l, li);
++=======
+ 	/* retrieve child from parent node */
+ 	if (tp)
+ 		n = tnode_get_child(tp, get_index(key, tp));
+ 	else
+ 		n = rcu_dereference_rtnl(t->tnode[0]);
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  
  	/* Case 2: n is a LEAF or a TNODE and the key doesn't match.
  	 *
@@@ -1070,14 -1011,11 +1247,14 @@@
  	 *  leaves us in position for handling as case 3
  	 */
  	if (n) {
- 		struct tnode *tn;
+ 		struct key_vector *tn;
  
  		tn = tnode_new(key, __fls(key ^ n->key), 1);
 -		if (!tn)
 -			goto notnode;
 +		if (!tn) {
 +			free_leaf_info(li);
 +			node_free(l);
 +			return NULL;
 +		}
  
  		/* initialize routes out of node */
  		NODE_INIT_PARENT(tn, tp);
@@@ -1092,33 -1030,64 +1269,60 @@@
  	}
  
  	/* Case 3: n is NULL, and will just insert a new leaf */
++<<<<<<< HEAD
 +	if (tp) {
 +		NODE_INIT_PARENT(l, tp);
 +		put_child(tp, get_index(key, tp), l);
 +		trie_rebalance(t, tp);
++=======
+ 	NODE_INIT_PARENT(l, tp);
+ 	put_child_root(tp, t, key, l);
+ 	trie_rebalance(t, tp);
+ 
+ 	return 0;
+ notnode:
+ 	node_free(l);
+ noleaf:
+ 	return -ENOMEM;
+ }
+ 
+ static int fib_insert_alias(struct trie *t, struct key_vector *tp,
+ 			    struct key_vector *l, struct fib_alias *new,
+ 			    struct fib_alias *fa, t_key key)
+ {
+ 	if (!l)
+ 		return fib_insert_node(t, tp, new, key);
+ 
+ 	if (fa) {
+ 		hlist_add_before_rcu(&new->fa_list, &fa->fa_list);
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	} else {
 -		struct fib_alias *last;
 -
 -		hlist_for_each_entry(last, &l->leaf, fa_list) {
 -			if (new->fa_slen < last->fa_slen)
 -				break;
 -			fa = last;
 -		}
 -
 -		if (fa)
 -			hlist_add_behind_rcu(&new->fa_list, &fa->fa_list);
 -		else
 -			hlist_add_head_rcu(&new->fa_list, &l->leaf);
 -	}
 -
 -	/* if we added to the tail node then we need to update slen */
 -	if (l->slen < new->fa_slen) {
 -		l->slen = new->fa_slen;
 -		leaf_push_suffix(tp, l);
 +		rcu_assign_pointer(t->trie, l);
  	}
  
 -	return 0;
 +	return fa_head;
  }
  
 -/* Caller must hold RTNL. */
 +/*
 + * Caller must hold RTNL.
 + */
  int fib_table_insert(struct fib_table *tb, struct fib_config *cfg)
  {
 -	struct trie *t = (struct trie *)tb->tb_data;
 +	struct trie *t = (struct trie *) tb->tb_data;
  	struct fib_alias *fa, *new_fa;
++<<<<<<< HEAD
 +	struct list_head *fa_head = NULL;
++=======
+ 	struct key_vector *l, *tp;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	struct fib_info *fi;
 -	u8 plen = cfg->fc_dst_len;
 -	u8 slen = KEYLENGTH - plen;
 +	int plen = cfg->fc_dst_len;
  	u8 tos = cfg->fc_tos;
 -	u32 key;
 +	u32 key, mask;
  	int err;
 +	struct tnode *l;
  
 -	if (plen > KEYLENGTH)
 +	if (plen > 32)
  		return -EINVAL;
  
  	key = ntohl(cfg->fc_dst);
@@@ -1289,11 -1260,12 +1493,17 @@@ int fib_table_lookup(struct fib_table *
  	struct trie_use_stats __percpu *stats = t->stats;
  #endif
  	const t_key key = ntohl(flp->daddr);
++<<<<<<< HEAD
 +	struct tnode *n, *pn;
 +	struct leaf_info *li;
++=======
+ 	struct key_vector *n, *pn;
+ 	struct fib_alias *fa;
+ 	unsigned long index;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	t_key cindex;
  
- 	n = rcu_dereference(t->trie);
+ 	n = rcu_dereference(t->tnode[0]);
  	if (!n)
  		return -EAGAIN;
  
@@@ -1341,7 -1317,7 +1551,11 @@@
  	/* Step 2: Sort out leaves and begin backtracing for longest prefix */
  	for (;;) {
  		/* record the pointer where our next node pointer is stored */
++<<<<<<< HEAD
 +		struct tnode __rcu **cptr = n->child;
++=======
+ 		struct key_vector __rcu **cptr = n->tnode;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  
  		/* This test verifies that none of the bits that differ
  		 * between the key and the prefix exist in the region of
@@@ -1452,40 -1426,47 +1666,52 @@@ found
  }
  EXPORT_SYMBOL_GPL(fib_table_lookup);
  
++<<<<<<< HEAD
 +/*
 + * Remove the leaf and return parent.
 + */
 +static void trie_leaf_remove(struct trie *t, struct tnode *l)
++=======
+ static void fib_remove_alias(struct trie *t, struct key_vector *tp,
+ 			     struct key_vector *l, struct fib_alias *old)
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  {
 -	/* record the location of the previous list_info entry */
 -	struct hlist_node **pprev = old->fa_list.pprev;
 -	struct fib_alias *fa = hlist_entry(pprev, typeof(*fa), fa_list.next);
 +	struct tnode *tp = node_parent(l);
  
 -	/* remove the fib_alias from the list */
 -	hlist_del_rcu(&old->fa_list);
 +	pr_debug("entering trie_leaf_remove(%p)\n", l);
  
 -	/* if we emptied the list this leaf will be freed and we can sort
 -	 * out parent suffix lengths as a part of trie_rebalance
 -	 */
 -	if (hlist_empty(&l->leaf)) {
 -		put_child_root(tp, t, l->key, NULL);
 -		node_free(l);
 +	if (tp) {
 +		put_child(tp, get_index(l->key, tp), NULL);
  		trie_rebalance(t, tp);
 -		return;
 +	} else {
 +		RCU_INIT_POINTER(t->trie, NULL);
  	}
  
 -	/* only access fa if it is pointing at the last valid hlist_node */
 -	if (*pprev)
 -		return;
 -
 -	/* update the trie with the latest suffix length */
 -	l->slen = fa->fa_slen;
 -	leaf_pull_suffix(tp, l);
 +	node_free(l);
  }
  
 -/* Caller must hold RTNL. */
 +/*
 + * Caller must hold RTNL.
 + */
  int fib_table_delete(struct fib_table *tb, struct fib_config *cfg)
  {
  	struct trie *t = (struct trie *) tb->tb_data;
++<<<<<<< HEAD
 +	u32 key, mask;
 +	int plen = cfg->fc_dst_len;
++=======
+ 	struct fib_alias *fa, *fa_to_delete;
+ 	struct key_vector *l, *tp;
+ 	u8 plen = cfg->fc_dst_len;
+ 	u8 slen = KEYLENGTH - plen;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	u8 tos = cfg->fc_tos;
 -	u32 key;
 +	struct fib_alias *fa, *fa_to_delete;
 +	struct list_head *fa_head;
 +	struct tnode *l;
 +	struct leaf_info *li;
  
 -	if (plen > KEYLENGTH)
 +	if (plen > 32)
  		return -EINVAL;
  
  	key = ntohl(cfg->fc_dst);
@@@ -1562,12 -1526,178 +1788,187 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int trie_flush_list(struct list_head *head)
 +{
 +	struct fib_alias *fa, *fa_node;
 +	int found = 0;
 +
 +	list_for_each_entry_safe(fa, fa_node, head, fa_list) {
++=======
+ /* Scan for the next leaf starting at the provided key value */
+ static struct key_vector *leaf_walk_rcu(struct key_vector **tn, t_key key)
+ {
+ 	struct key_vector *pn, *n = *tn;
+ 	unsigned long cindex;
+ 
+ 	/* record parent node for backtracing */
+ 	pn = n;
+ 	cindex = n ? get_index(key, n) : 0;
+ 
+ 	/* this loop is meant to try and find the key in the trie */
+ 	while (n) {
+ 		unsigned long idx = get_index(key, n);
+ 
+ 		/* guarantee forward progress on the keys */
+ 		if (IS_LEAF(n) && (n->key >= key))
+ 			goto found;
+ 		if (idx >= (1ul << n->bits))
+ 			break;
+ 
+ 		/* record parent and next child index */
+ 		pn = n;
+ 		cindex = idx;
+ 
+ 		/* descend into the next child */
+ 		n = tnode_get_child_rcu(pn, cindex++);
+ 	}
+ 
+ 	/* this loop will search for the next leaf with a greater key */
+ 	while (pn) {
+ 		/* if we exhausted the parent node we will need to climb */
+ 		if (cindex >= (1ul << pn->bits)) {
+ 			t_key pkey = pn->key;
+ 
+ 			pn = node_parent_rcu(pn);
+ 			if (!pn)
+ 				break;
+ 
+ 			cindex = get_index(pkey, pn) + 1;
+ 			continue;
+ 		}
+ 
+ 		/* grab the next available node */
+ 		n = tnode_get_child_rcu(pn, cindex++);
+ 		if (!n)
+ 			continue;
+ 
+ 		/* no need to compare keys since we bumped the index */
+ 		if (IS_LEAF(n))
+ 			goto found;
+ 
+ 		/* Rescan start scanning in new node */
+ 		pn = n;
+ 		cindex = 0;
+ 	}
+ 
+ 	*tn = pn;
+ 	return NULL; /* Root of trie */
+ found:
+ 	/* if we are at the limit for keys just return NULL for the tnode */
+ 	*tn = (n->key == KEY_MAX) ? NULL : pn;
+ 	return n;
+ }
+ 
+ /* Caller must hold RTNL */
+ void fib_table_flush_external(struct fib_table *tb)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct fib_alias *fa;
+ 	struct key_vector *n, *pn;
+ 	unsigned long cindex;
+ 
+ 	n = rcu_dereference(t->tnode[0]);
+ 	if (!n)
+ 		return;
+ 
+ 	pn = NULL;
+ 	cindex = 0;
+ 
+ 	while (IS_TNODE(n)) {
+ 		/* record pn and cindex for leaf walking */
+ 		pn = n;
+ 		cindex = 1ul << n->bits;
+ backtrace:
+ 		/* walk trie in reverse order */
+ 		do {
+ 			while (!(cindex--)) {
+ 				t_key pkey = pn->key;
+ 
+ 				/* if we got the root we are done */
+ 				pn = node_parent(pn);
+ 				if (!pn)
+ 					return;
+ 
+ 				cindex = get_index(pkey, pn);
+ 			}
+ 
+ 			/* grab the next available node */
+ 			n = tnode_get_child(pn, cindex);
+ 		} while (!n);
+ 	}
+ 
+ 	hlist_for_each_entry(fa, &n->leaf, fa_list) {
+ 		struct fib_info *fi = fa->fa_info;
+ 
+ 		if (!fi || !(fi->fib_flags & RTNH_F_EXTERNAL))
+ 			continue;
+ 
+ 		netdev_switch_fib_ipv4_del(n->key,
+ 					   KEYLENGTH - fa->fa_slen,
+ 					   fi, fa->fa_tos,
+ 					   fa->fa_type, tb->tb_id);
+ 	}
+ 
+ 	/* if trie is leaf only loop is completed */
+ 	if (pn)
+ 		goto backtrace;
+ }
+ 
+ /* Caller must hold RTNL. */
+ int fib_table_flush(struct fib_table *tb)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *n, *pn;
+ 	struct hlist_node *tmp;
+ 	struct fib_alias *fa;
+ 	unsigned long cindex;
+ 	unsigned char slen;
+ 	int found = 0;
+ 
+ 	n = rcu_dereference(t->tnode[0]);
+ 	if (!n)
+ 		goto flush_complete;
+ 
+ 	pn = NULL;
+ 	cindex = 0;
+ 
+ 	while (IS_TNODE(n)) {
+ 		/* record pn and cindex for leaf walking */
+ 		pn = n;
+ 		cindex = 1ul << n->bits;
+ backtrace:
+ 		/* walk trie in reverse order */
+ 		do {
+ 			while (!(cindex--)) {
+ 				struct key_vector __rcu **cptr;
+ 				t_key pkey = pn->key;
+ 
+ 				n = pn;
+ 				pn = node_parent(n);
+ 
+ 				/* resize completed node */
+ 				cptr = resize(t, n);
+ 
+ 				/* if we got the root we are done */
+ 				if (!pn)
+ 					goto flush_complete;
+ 
+ 				pn = container_of(cptr, struct key_vector,
+ 						  tnode[0]);
+ 				cindex = get_index(pkey, pn);
+ 			}
+ 
+ 			/* grab the next available node */
+ 			n = tnode_get_child(pn, cindex);
+ 		} while (!n);
+ 	}
+ 
+ 	/* track slen in case any prefixes survive */
+ 	slen = 0;
+ 
+ 	hlist_for_each_entry_safe(fa, tmp, &n->leaf, fa_list) {
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  		struct fib_info *fi = fa->fa_info;
  
  		if (fi && (fi->fib_flags & RTNH_F_DEAD)) {
@@@ -1711,15 -1745,19 +2112,26 @@@ void fib_free_table(struct fib_table *t
  	kfree(tb);
  }
  
 -void fib_free_table(struct fib_table *tb)
 +static int fn_trie_dump_fa(t_key key, int plen, struct list_head *fah,
 +			   struct fib_table *tb,
 +			   struct sk_buff *skb, struct netlink_callback *cb)
  {
++<<<<<<< HEAD
++=======
+ 	call_rcu(&tb->rcu, __trie_free_rcu);
+ }
+ 
+ static int fn_trie_dump_leaf(struct key_vector *l, struct fib_table *tb,
+ 			     struct sk_buff *skb, struct netlink_callback *cb)
+ {
+ 	__be32 xkey = htonl(l->key);
+ 	struct fib_alias *fa;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	int i, s_i;
 +	struct fib_alias *fa;
 +	__be32 xkey = htonl(key);
  
 -	s_i = cb->args[4];
 +	s_i = cb->args[5];
  	i = 0;
  
  	/* rcu_read_lock is hold by caller */
@@@ -1784,31 -1789,21 +2196,42 @@@ static int fn_trie_dump_leaf(struct tno
  int fib_table_dump(struct fib_table *tb, struct sk_buff *skb,
  		   struct netlink_callback *cb)
  {
++<<<<<<< HEAD
 +	struct tnode *l;
 +	struct trie *t = (struct trie *) tb->tb_data;
 +	t_key key = cb->args[2];
 +	int count = cb->args[3];
 +
 +	rcu_read_lock();
++=======
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *l, *tp;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	/* Dump starting at last key.
  	 * Note: 0.0.0.0/0 (ie default) is first key.
  	 */
 -	int count = cb->args[2];
 -	t_key key = cb->args[3];
 +	if (count == 0)
 +		l = trie_firstleaf(t);
 +	else {
 +		/* Normally, continue from last key, but if that is missing
 +		 * fallback to using slow rescan
 +		 */
 +		l = fib_find_node(t, key);
 +		if (!l)
 +			l = trie_leafindex(t, count);
 +	}
  
++<<<<<<< HEAD
 +	while (l) {
 +		cb->args[2] = l->key;
++=======
+ 	tp = rcu_dereference_rtnl(t->tnode[0]);
+ 
+ 	while ((l = leaf_walk_rcu(&tp, key)) != NULL) {
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  		if (fn_trie_dump_leaf(l, tb, skb, cb) < 0) {
 -			cb->args[3] = key;
 -			cb->args[2] = count;
 +			cb->args[3] = count;
 +			rcu_read_unlock();
  			return -1;
  		}
  
@@@ -2294,27 -2291,43 +2717,47 @@@ static const struct file_operations fib
  
  struct fib_route_iter {
  	struct seq_net_private p;
++<<<<<<< HEAD
 +	struct trie *main_trie;
++=======
+ 	struct fib_table *main_tb;
+ 	struct key_vector *tnode;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  	loff_t	pos;
  	t_key	key;
  };
  
- static struct tnode *fib_route_get_idx(struct fib_route_iter *iter, loff_t pos)
+ static struct key_vector *fib_route_get_idx(struct fib_route_iter *iter,
+ 					    loff_t pos)
  {
++<<<<<<< HEAD
 +	struct tnode *l = NULL;
 +	struct trie *t = iter->main_trie;
++=======
+ 	struct fib_table *tb = iter->main_tb;
+ 	struct key_vector *l, **tp = &iter->tnode;
+ 	struct trie *t;
+ 	t_key key;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  
 -	/* use cache location of next-to-find key */
 -	if (iter->pos > 0 && pos >= iter->pos) {
 +	/* use cache location of last found key */
 +	if (iter->pos > 0 && pos >= iter->pos && (l = fib_find_node(t, iter->key)))
  		pos -= iter->pos;
++<<<<<<< HEAD
 +	else {
++=======
+ 		key = iter->key;
+ 	} else {
+ 		t = (struct trie *)tb->tb_data;
+ 		iter->tnode = rcu_dereference_rtnl(t->tnode[0]);
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  		iter->pos = 0;
 -		key = 0;
 +		l = trie_firstleaf(t);
  	}
  
 -	while ((l = leaf_walk_rcu(tp, key)) != NULL) {
 -		key = l->key + 1;
 +	while (l && pos-- > 0) {
  		iter->pos++;
 -
 -		if (pos-- <= 0)
 -			break;
 -
 -		l = NULL;
 -
 -		/* handle unlikely case of a key wrap */
 -		if (!key)
 -			break;
 +		l = trie_nextleaf(l);
  	}
  
  	if (l)
@@@ -2336,31 -2351,38 +2779,50 @@@ static void *fib_route_seq_start(struc
  	if (!tb)
  		return NULL;
  
++<<<<<<< HEAD
 +	iter->main_trie = (struct trie *) tb->tb_data;
 +	if (*pos == 0)
 +		return SEQ_START_TOKEN;
 +	else
 +		return fib_route_get_idx(iter, *pos - 1);
++=======
+ 	iter->main_tb = tb;
+ 
+ 	if (*pos != 0)
+ 		return fib_route_get_idx(iter, *pos);
+ 
+ 	t = (struct trie *)tb->tb_data;
+ 	iter->tnode = rcu_dereference_rtnl(t->tnode[0]);
+ 	iter->pos = 0;
+ 	iter->key = 0;
+ 
+ 	return SEQ_START_TOKEN;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  }
  
  static void *fib_route_seq_next(struct seq_file *seq, void *v, loff_t *pos)
  {
  	struct fib_route_iter *iter = seq->private;
++<<<<<<< HEAD
 +	struct tnode *l = v;
++=======
+ 	struct key_vector *l = NULL;
+ 	t_key key = iter->key;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  
  	++*pos;
 -
 -	/* only allow key of 0 for start of sequence */
 -	if ((v == SEQ_START_TOKEN) || key)
 -		l = leaf_walk_rcu(&iter->tnode, key);
 -
 -	if (l) {
 -		iter->key = l->key + 1;
 -		iter->pos++;
 -	} else {
 +	if (v == SEQ_START_TOKEN) {
  		iter->pos = 0;
 +		l = trie_firstleaf(iter->main_trie);
 +	} else {
 +		iter->pos++;
 +		l = trie_nextleaf(l);
  	}
  
 +	if (l)
 +		iter->key = l->key;
 +	else
 +		iter->pos = 0;
  	return l;
  }
  
@@@ -2392,8 -2414,9 +2854,14 @@@ static unsigned int fib_flag_trans(int 
   */
  static int fib_route_seq_show(struct seq_file *seq, void *v)
  {
++<<<<<<< HEAD
 +	struct tnode *l = v;
 +	struct leaf_info *li;
++=======
+ 	struct fib_alias *fa;
+ 	struct key_vector *l = v;
+ 	__be32 prefix;
++>>>>>>> 35c6edac197f (fib_trie: Rename tnode to key_vector)
  
  	if (v == SEQ_START_TOKEN) {
  		seq_printf(seq, "%-127s\n", "Iface\tDestination\tGateway "
* Unmerged path net/ipv4/fib_trie.c
