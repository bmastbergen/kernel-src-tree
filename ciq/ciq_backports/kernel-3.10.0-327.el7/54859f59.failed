x86: Remove create/destroy_irq()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [x86] Remove create/destroy_irq() (Steve Best) [1231358]
Rebuild_FUZZ: 91.53%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 54859f59fc18e5c104a4095420b3fcef8bc3ae63
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/54859f59.failed

No more users. Remove the cruft

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Grant Likely <grant.likely@linaro.org>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: x86@kernel.org
Link: http://lkml.kernel.org/r/20140507154336.760446122@linutronix.de
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit 54859f59fc18e5c104a4095420b3fcef8bc3ae63)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/apic/io_apic.c
diff --cc arch/x86/kernel/apic/io_apic.c
index d0aa37330fca,efda2f648f59..000000000000
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@@ -2905,98 -2904,39 +2893,131 @@@ static int __init ioapic_init_ops(void
  device_initcall(ioapic_init_ops);
  
  /*
-  * Dynamic irq allocate and deallocation
+  * Dynamic irq allocate and deallocation. Should be replaced by irq domains!
   */
++<<<<<<< HEAD
 +unsigned int __create_irqs(unsigned int from, unsigned int count, int node)
 +{
 +	struct irq_cfg **cfg;
 +	unsigned long flags;
 +	int irq, i;
 +
 +	if (from < nr_irqs_gsi)
 +		from = nr_irqs_gsi;
 +
 +	cfg = kzalloc_node(count * sizeof(cfg[0]), GFP_KERNEL, node);
 +	if (!cfg)
 +		return 0;
 +
 +	irq = alloc_irqs_from(from, count, node);
 +	if (irq < 0)
 +		goto out_cfgs;
 +
 +	for (i = 0; i < count; i++) {
 +		cfg[i] = alloc_irq_cfg(irq + i, node);
 +		if (!cfg[i])
 +			goto out_irqs;
 +	}
 +
 +	raw_spin_lock_irqsave(&vector_lock, flags);
 +	for (i = 0; i < count; i++)
 +		if (__assign_irq_vector(irq + i, cfg[i], apic->target_cpus()))
 +			goto out_vecs;
 +	raw_spin_unlock_irqrestore(&vector_lock, flags);
 +
 +	for (i = 0; i < count; i++) {
 +		irq_set_chip_data(irq + i, cfg[i]);
 +		irq_clear_status_flags(irq + i, IRQ_NOREQUEST);
 +	}
 +
 +	kfree(cfg);
 +	return irq;
 +
 +out_vecs:
 +	for (i--; i >= 0; i--)
 +		__clear_irq_vector(irq + i, cfg[i]);
 +	raw_spin_unlock_irqrestore(&vector_lock, flags);
 +out_irqs:
 +	for (i = 0; i < count; i++)
 +		free_irq_at(irq + i, cfg[i]);
 +out_cfgs:
 +	kfree(cfg);
 +	return 0;
 +}
 +
 +unsigned int create_irq_nr(unsigned int from, int node)
 +{
 +	return __create_irqs(from, 1, node);
 +}
 +
 +int create_irq(void)
 +{
 +	int node = cpu_to_node(0);
 +	unsigned int irq_want;
 +	int irq;
 +
 +	irq_want = nr_irqs_gsi;
 +	irq = create_irq_nr(irq_want, node);
 +
 +	if (irq == 0)
 +		irq = -1;
 +
 +	return irq;
 +}
 +
 +void destroy_irq(unsigned int irq)
++=======
+ int arch_setup_hwirq(unsigned int irq, int node)
+ {
+ 	struct irq_cfg *cfg;
+ 	unsigned long flags;
+ 	int ret;
+ 
+ 	cfg = alloc_irq_cfg(irq, node);
+ 	if (!cfg)
+ 		return -ENOMEM;
+ 
+ 	raw_spin_lock_irqsave(&vector_lock, flags);
+ 	ret = __assign_irq_vector(irq, cfg, apic->target_cpus());
+ 	raw_spin_unlock_irqrestore(&vector_lock, flags);
+ 
+ 	if (!ret)
+ 		irq_set_chip_data(irq, cfg);
+ 	else
+ 		free_irq_cfg(irq, cfg);
+ 	return ret;
+ }
+ 
+ void arch_teardown_hwirq(unsigned int irq)
++>>>>>>> 54859f59fc18 (x86: Remove create/destroy_irq())
  {
  	struct irq_cfg *cfg = irq_get_chip_data(irq);
  	unsigned long flags;
  
++<<<<<<< HEAD
 +	irq_set_status_flags(irq, IRQ_NOREQUEST|IRQ_NOPROBE);
 +
 +	free_remapped_irq(irq);
 +
 +	raw_spin_lock_irqsave(&vector_lock, flags);
 +	__clear_irq_vector(irq, cfg);
 +	raw_spin_unlock_irqrestore(&vector_lock, flags);
 +	free_irq_at(irq, cfg);
 +}
 +
 +void destroy_irqs(unsigned int irq, unsigned int count)
 +{
 +	unsigned int i;
 +
 +	for (i = 0; i < count; i++)
 +		destroy_irq(irq + i);
++=======
+ 	free_remapped_irq(irq);
+ 	raw_spin_lock_irqsave(&vector_lock, flags);
+ 	__clear_irq_vector(irq, cfg);
+ 	raw_spin_unlock_irqrestore(&vector_lock, flags);
+ 	free_irq_cfg(irq, cfg);
++>>>>>>> 54859f59fc18 (x86: Remove create/destroy_irq())
  }
  
  /*
* Unmerged path arch/x86/kernel/apic/io_apic.c
diff --git a/include/linux/irq.h b/include/linux/irq.h
index 832538a7367f..8f5bf846640a 100644
--- a/include/linux/irq.h
+++ b/include/linux/irq.h
@@ -509,12 +509,8 @@ static inline void irq_set_percpu_devid_flags(unsigned int irq)
 }
 
 /* Handle dynamic irq creation and destruction */
-extern unsigned int create_irq_nr(unsigned int irq_want, int node);
-extern unsigned int __create_irqs(unsigned int from, unsigned int count,
-				  int node);
 extern int create_irq(void);
 extern void destroy_irq(unsigned int irq);
-extern void destroy_irqs(unsigned int irq, unsigned int count);
 
 /*
  * Dynamic irq helper functions. Obsolete. Use irq_alloc_desc* and
