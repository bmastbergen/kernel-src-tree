of: Eliminate of_allnodes list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [of] Eliminate of_allnodes list (Gustavo Duarte) [1210533]
Rebuild_FUZZ: 92.86%
commit-author Grant Likely <grant.likely@linaro.org>
commit 5063e25a302e6a83f6590d9a06bd5f6400b17430
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/5063e25a.failed

The device tree structure is composed of two lists; the 'allnodes' list
which is a singly linked list containing every node in the tree, and the
child->parent structure where each parent node has a singly linked list
of children. All of the data in the allnodes list can be easily
reproduced with the parent-child lists, so of_allnodes is actually
unnecessary. Remove it entirely which saves a bit of memory and
simplifies the data structure quite a lot.

	Signed-off-by: Grant Likely <grant.likely@linaro.org>
	Cc: Rob Herring <robh@kernel.org>
	Cc: Gaurav Minocha <gaurav.minocha.os@gmail.com>
	Cc: Pantelis Antoniou <pantelis@pantelis.antoniou@konsulko.com>
(cherry picked from commit 5063e25a302e6a83f6590d9a06bd5f6400b17430)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/devicetree/of_selftest.txt
#	Documentation/devicetree/todo.txt
#	drivers/mfd/vexpress-sysreg.c
#	drivers/of/base.c
#	drivers/of/dynamic.c
#	drivers/of/fdt.c
#	drivers/of/selftest.c
#	include/linux/of.h
diff --cc drivers/mfd/vexpress-sysreg.c
index 96a020b1dcd1,8f43ab8fd2d6..000000000000
--- a/drivers/mfd/vexpress-sysreg.c
+++ b/drivers/mfd/vexpress-sysreg.c
@@@ -351,154 -112,142 +351,175 @@@ void __init vexpress_sysreg_of_early_in
  }
  
  
 -/* The sysreg block is just a random collection of various functions... */
 +#define VEXPRESS_SYSREG_GPIO(_name, _reg, _value) \
 +	[VEXPRESS_GPIO_##_name] = { \
 +		.reg = _reg, \
 +		.value = _reg##_##_value, \
 +	}
  
 -static struct syscon_platform_data vexpress_sysreg_sys_id_pdata = {
 -	.label = "sys_id",
 +static struct vexpress_sysreg_gpio {
 +	unsigned long reg;
 +	u32 value;
 +} vexpress_sysreg_gpios[] = {
 +	VEXPRESS_SYSREG_GPIO(MMC_CARDIN,	SYS_MCI,	CARDIN),
 +	VEXPRESS_SYSREG_GPIO(MMC_WPROT,		SYS_MCI,	WPROT),
 +	VEXPRESS_SYSREG_GPIO(FLASH_WPn,		SYS_FLASH,	WPn),
 +	VEXPRESS_SYSREG_GPIO(LED0,		SYS_LED,	LED(0)),
 +	VEXPRESS_SYSREG_GPIO(LED1,		SYS_LED,	LED(1)),
 +	VEXPRESS_SYSREG_GPIO(LED2,		SYS_LED,	LED(2)),
 +	VEXPRESS_SYSREG_GPIO(LED3,		SYS_LED,	LED(3)),
 +	VEXPRESS_SYSREG_GPIO(LED4,		SYS_LED,	LED(4)),
 +	VEXPRESS_SYSREG_GPIO(LED5,		SYS_LED,	LED(5)),
 +	VEXPRESS_SYSREG_GPIO(LED6,		SYS_LED,	LED(6)),
 +	VEXPRESS_SYSREG_GPIO(LED7,		SYS_LED,	LED(7)),
  };
  
 -static struct bgpio_pdata vexpress_sysreg_sys_led_pdata = {
 -	.label = "sys_led",
 -	.base = -1,
 -	.ngpio = 8,
 -};
 +static int vexpress_sysreg_gpio_direction_input(struct gpio_chip *chip,
 +				       unsigned offset)
 +{
 +	return 0;
 +}
  
 -static struct bgpio_pdata vexpress_sysreg_sys_mci_pdata = {
 -	.label = "sys_mci",
 -	.base = -1,
 -	.ngpio = 2,
 -};
 +static int vexpress_sysreg_gpio_get(struct gpio_chip *chip,
 +				       unsigned offset)
 +{
 +	struct vexpress_sysreg_gpio *gpio = &vexpress_sysreg_gpios[offset];
 +	u32 reg_value = readl(vexpress_sysreg_base + gpio->reg);
  
 -static struct bgpio_pdata vexpress_sysreg_sys_flash_pdata = {
 -	.label = "sys_flash",
 -	.base = -1,
 -	.ngpio = 1,
 -};
 +	return !!(reg_value & gpio->value);
 +}
  
 -static struct syscon_platform_data vexpress_sysreg_sys_misc_pdata = {
 -	.label = "sys_misc",
 -};
 +static void vexpress_sysreg_gpio_set(struct gpio_chip *chip,
 +				       unsigned offset, int value)
 +{
 +	struct vexpress_sysreg_gpio *gpio = &vexpress_sysreg_gpios[offset];
 +	u32 reg_value = readl(vexpress_sysreg_base + gpio->reg);
  
 -static struct syscon_platform_data vexpress_sysreg_sys_procid_pdata = {
 -	.label = "sys_procid",
 +	if (value)
 +		reg_value |= gpio->value;
 +	else
 +		reg_value &= ~gpio->value;
 +
 +	writel(reg_value, vexpress_sysreg_base + gpio->reg);
 +}
 +
 +static int vexpress_sysreg_gpio_direction_output(struct gpio_chip *chip,
 +						unsigned offset, int value)
 +{
 +	vexpress_sysreg_gpio_set(chip, offset, value);
 +
 +	return 0;
 +}
 +
 +static struct gpio_chip vexpress_sysreg_gpio_chip = {
 +	.label = "vexpress-sysreg",
 +	.direction_input = vexpress_sysreg_gpio_direction_input,
 +	.direction_output = vexpress_sysreg_gpio_direction_output,
 +	.get = vexpress_sysreg_gpio_get,
 +	.set = vexpress_sysreg_gpio_set,
 +	.ngpio = ARRAY_SIZE(vexpress_sysreg_gpios),
 +	.base = 0,
  };
  
 -static struct mfd_cell vexpress_sysreg_cells[] = {
 -	{
 -		.name = "syscon",
 -		.num_resources = 1,
 -		.resources = (struct resource []) {
 -			DEFINE_RES_MEM(SYS_ID, 0x4),
 -		},
 -		.platform_data = &vexpress_sysreg_sys_id_pdata,
 -		.pdata_size = sizeof(vexpress_sysreg_sys_id_pdata),
 -	}, {
 -		.name = "basic-mmio-gpio",
 -		.of_compatible = "arm,vexpress-sysreg,sys_led",
 -		.num_resources = 1,
 -		.resources = (struct resource []) {
 -			DEFINE_RES_MEM_NAMED(SYS_LED, 0x4, "dat"),
 -		},
 -		.platform_data = &vexpress_sysreg_sys_led_pdata,
 -		.pdata_size = sizeof(vexpress_sysreg_sys_led_pdata),
 -	}, {
 -		.name = "basic-mmio-gpio",
 -		.of_compatible = "arm,vexpress-sysreg,sys_mci",
 -		.num_resources = 1,
 -		.resources = (struct resource []) {
 -			DEFINE_RES_MEM_NAMED(SYS_MCI, 0x4, "dat"),
 -		},
 -		.platform_data = &vexpress_sysreg_sys_mci_pdata,
 -		.pdata_size = sizeof(vexpress_sysreg_sys_mci_pdata),
 -	}, {
 -		.name = "basic-mmio-gpio",
 -		.of_compatible = "arm,vexpress-sysreg,sys_flash",
 -		.num_resources = 1,
 -		.resources = (struct resource []) {
 -			DEFINE_RES_MEM_NAMED(SYS_FLASH, 0x4, "dat"),
 -		},
 -		.platform_data = &vexpress_sysreg_sys_flash_pdata,
 -		.pdata_size = sizeof(vexpress_sysreg_sys_flash_pdata),
 -	}, {
 -		.name = "syscon",
 -		.num_resources = 1,
 -		.resources = (struct resource []) {
 -			DEFINE_RES_MEM(SYS_MISC, 0x4),
 -		},
 -		.platform_data = &vexpress_sysreg_sys_misc_pdata,
 -		.pdata_size = sizeof(vexpress_sysreg_sys_misc_pdata),
 -	}, {
 -		.name = "syscon",
 -		.num_resources = 1,
 -		.resources = (struct resource []) {
 -			DEFINE_RES_MEM(SYS_PROCID0, 0x8),
 -		},
 -		.platform_data = &vexpress_sysreg_sys_procid_pdata,
 -		.pdata_size = sizeof(vexpress_sysreg_sys_procid_pdata),
 -	}, {
 -		.name = "vexpress-syscfg",
 -		.num_resources = 1,
 -		.resources = (struct resource []) {
 -			DEFINE_RES_MEM(SYS_CFGDATA, 0xc),
 -		},
 +
 +#define VEXPRESS_SYSREG_GREEN_LED(_name, _default_trigger, _gpio) \
 +	{ \
 +		.name = "v2m:green:"_name, \
 +		.default_trigger = _default_trigger, \
 +		.gpio = VEXPRESS_GPIO_##_gpio, \
  	}
 +
 +struct gpio_led vexpress_sysreg_leds[] = {
 +	VEXPRESS_SYSREG_GREEN_LED("user1",	"heartbeat",	LED0),
 +	VEXPRESS_SYSREG_GREEN_LED("user2",	"mmc0",		LED1),
 +	VEXPRESS_SYSREG_GREEN_LED("user3",	"cpu0",		LED2),
 +	VEXPRESS_SYSREG_GREEN_LED("user4",	"cpu1",		LED3),
 +	VEXPRESS_SYSREG_GREEN_LED("user5",	"cpu2",		LED4),
 +	VEXPRESS_SYSREG_GREEN_LED("user6",	"cpu3",		LED5),
 +	VEXPRESS_SYSREG_GREEN_LED("user7",	"cpu4",		LED6),
 +	VEXPRESS_SYSREG_GREEN_LED("user8",	"cpu5",		LED7),
  };
  
 -static int vexpress_sysreg_probe(struct platform_device *pdev)
 +struct gpio_led_platform_data vexpress_sysreg_leds_pdata = {
 +	.num_leds = ARRAY_SIZE(vexpress_sysreg_leds),
 +	.leds = vexpress_sysreg_leds,
 +};
 +
 +
 +static ssize_t vexpress_sysreg_sys_id_show(struct device *dev,
 +		struct device_attribute *attr, char *buf)
  {
 -	struct resource *mem;
 -	void __iomem *base;
 -	struct bgpio_chip *mmc_gpio_chip;
 -	u32 dt_hbi;
 +	return sprintf(buf, "0x%08x\n", readl(vexpress_sysreg_base + SYS_ID));
 +}
 +
 +DEVICE_ATTR(sys_id, S_IRUGO, vexpress_sysreg_sys_id_show, NULL);
  
 +static int vexpress_sysreg_probe(struct platform_device *pdev)
 +{
 +	int err;
 +	struct resource *res = platform_get_resource(pdev,
 +			IORESOURCE_MEM, 0);
 +
++<<<<<<< HEAD
 +	if (!devm_request_mem_region(&pdev->dev, res->start,
 +			resource_size(res), pdev->name)) {
 +		dev_err(&pdev->dev, "Failed to request memory region!\n");
 +		return -EBUSY;
++=======
+ 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	if (!mem)
+ 		return -EINVAL;
+ 
+ 	base = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
+ 	if (!base)
+ 		return -ENOMEM;
+ 
+ 	vexpress_config_set_master(vexpress_sysreg_get_master());
+ 
+ 	/* Confirm board type against DT property, if available */
+ 	if (of_property_read_u32(of_root, "arm,hbi", &dt_hbi) == 0) {
+ 		u32 id = vexpress_get_procid(VEXPRESS_SITE_MASTER);
+ 		u32 hbi = (id >> SYS_PROCIDx_HBI_SHIFT) & SYS_HBI_MASK;
+ 
+ 		if (WARN_ON(dt_hbi != hbi))
+ 			dev_warn(&pdev->dev, "DT HBI (%x) is not matching hardware (%x)!\n",
+ 					dt_hbi, hbi);
++>>>>>>> 5063e25a302e (of: Eliminate of_allnodes list)
  	}
  
 -	/*
 -	 * Duplicated SYS_MCI pseudo-GPIO controller for compatibility with
 -	 * older trees using sysreg node for MMC control lines.
 -	 */
 -	mmc_gpio_chip = devm_kzalloc(&pdev->dev, sizeof(*mmc_gpio_chip),
 -			GFP_KERNEL);
 -	if (!mmc_gpio_chip)
 -		return -ENOMEM;
 -	bgpio_init(mmc_gpio_chip, &pdev->dev, 0x4, base + SYS_MCI,
 -			NULL, NULL, NULL, NULL, 0);
 -	mmc_gpio_chip->gc.ngpio = 2;
 -	gpiochip_add(&mmc_gpio_chip->gc);
 -
 -	return mfd_add_devices(&pdev->dev, PLATFORM_DEVID_AUTO,
 -			vexpress_sysreg_cells,
 -			ARRAY_SIZE(vexpress_sysreg_cells), mem, 0, NULL);
 +	if (!vexpress_sysreg_base) {
 +		vexpress_sysreg_base = devm_ioremap(&pdev->dev, res->start,
 +				resource_size(res));
 +		vexpress_sysreg_setup(pdev->dev.of_node);
 +	}
 +
 +	if (!vexpress_sysreg_base) {
 +		dev_err(&pdev->dev, "Failed to obtain base address!\n");
 +		return -EFAULT;
 +	}
 +
 +	setup_timer(&vexpress_sysreg_config_timer,
 +			vexpress_sysreg_config_complete, 0);
 +
 +	vexpress_sysreg_gpio_chip.dev = &pdev->dev;
 +	err = gpiochip_add(&vexpress_sysreg_gpio_chip);
 +	if (err) {
 +		vexpress_config_bridge_unregister(
 +				vexpress_sysreg_config_bridge);
 +		dev_err(&pdev->dev, "Failed to register GPIO chip! (%d)\n",
 +				err);
 +		return err;
 +	}
 +
 +	vexpress_sysreg_dev = &pdev->dev;
 +
 +	platform_device_register_data(vexpress_sysreg_dev, "leds-gpio",
 +			PLATFORM_DEVID_AUTO, &vexpress_sysreg_leds_pdata,
 +			sizeof(vexpress_sysreg_leds_pdata));
 +
 +	device_create_file(vexpress_sysreg_dev, &dev_attr_sys_id);
 +
 +	return 0;
  }
  
  static const struct of_device_id vexpress_sysreg_match[] = {
diff --cc drivers/of/base.c
index f1fa838522f1,1f61a908a767..000000000000
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@@ -29,20 -32,23 +29,20 @@@
  
  LIST_HEAD(aliases_lookup);
  
- struct device_node *of_allnodes;
- EXPORT_SYMBOL(of_allnodes);
+ struct device_node *of_root;
+ EXPORT_SYMBOL(of_root);
  struct device_node *of_chosen;
  struct device_node *of_aliases;
 -struct device_node *of_stdout;
  
 -struct kset *of_kset;
 +static struct kset *of_kset;
  
  /*
 - * Used to protect the of_aliases, to hold off addition of nodes to sysfs.
 - * This mutex must be held whenever modifications are being made to the
 - * device tree. The of_{attach,detach}_node() and
 - * of_{add,remove,update}_property() helpers make sure this happens.
 + * Used to protect the of_aliases; but also overloaded to hold off addition of
 + * nodes to sysfs
   */
 -DEFINE_MUTEX(of_mutex);
 +DEFINE_MUTEX(of_aliases_mutex);
  
- /* use when traversing tree through the allnext, child, sibling,
+ /* use when traversing tree through the child, sibling,
   * or parent members of struct device_node.
   */
  DEFINE_RAW_SPINLOCK(devtree_lock);
@@@ -285,14 -200,12 +285,19 @@@ static int __init of_init(void
  		return -ENOMEM;
  	}
  	for_each_of_allnodes(np)
 -		__of_attach_node_sysfs(np);
 -	mutex_unlock(&of_mutex);
 -
 +		__of_node_add(np);
 +	mutex_unlock(&of_aliases_mutex);
 +
++<<<<<<< HEAD
 +#if !defined(CONFIG_PROC_DEVICETREE)
 +	/* Symlink to the new tree when PROC_DEVICETREE is disabled */
 +	if (of_allnodes)
++=======
+ 	/* Symlink in /proc as required by userspace ABI */
+ 	if (of_root)
++>>>>>>> 5063e25a302e (of: Eliminate of_allnodes list)
  		proc_symlink("device-tree", NULL, "/sys/firmware/devicetree/base");
 +#endif /* CONFIG_PROC_DEVICETREE */
  
  	return 0;
  }
@@@ -621,14 -746,41 +641,48 @@@ EXPORT_SYMBOL(of_get_child_by_name)
   */
  struct device_node *of_find_node_by_path(const char *path)
  {
 -	struct device_node *np = NULL;
 -	struct property *pp;
 +	struct device_node *np = of_allnodes;
  	unsigned long flags;
  
++<<<<<<< HEAD
 +	raw_spin_lock_irqsave(&devtree_lock, flags);
 +	for (; np; np = np->allnext) {
 +		if (np->full_name && (of_node_cmp(np->full_name, path) == 0)
 +		    && of_node_get(np))
 +			break;
++=======
+ 	if (strcmp(path, "/") == 0)
+ 		return of_node_get(of_root);
+ 
+ 	/* The path could begin with an alias */
+ 	if (*path != '/') {
+ 		char *p = strchrnul(path, '/');
+ 		int len = p - path;
+ 
+ 		/* of_aliases must not be NULL */
+ 		if (!of_aliases)
+ 			return NULL;
+ 
+ 		for_each_property_of_node(of_aliases, pp) {
+ 			if (strlen(pp->name) == len && !strncmp(pp->name, path, len)) {
+ 				np = of_find_node_by_path(pp->value);
+ 				break;
+ 			}
+ 		}
+ 		if (!np)
+ 			return NULL;
+ 		path = p;
+ 	}
+ 
+ 	/* Step down the tree matching path components */
+ 	raw_spin_lock_irqsave(&devtree_lock, flags);
+ 	if (!np)
+ 		np = of_node_get(of_root);
+ 	while (np && *path == '/') {
+ 		path++; /* Increment past '/' delimiter */
+ 		np = __of_find_node_by_path(np, path);
+ 		path = strchrnul(path, '/');
++>>>>>>> 5063e25a302e (of: Eliminate of_allnodes list)
  	}
  	raw_spin_unlock_irqrestore(&devtree_lock, flags);
  	return np;
@@@ -715,15 -865,10 +767,19 @@@ struct device_node *of_find_compatible_
  	unsigned long flags;
  
  	raw_spin_lock_irqsave(&devtree_lock, flags);
++<<<<<<< HEAD
 +	np = from ? from->allnext : of_allnodes;
 +	for (; np; np = np->allnext) {
 +		if (type
 +		    && !(np->type && (of_node_cmp(np->type, type) == 0)))
 +			continue;
 +		if (__of_device_is_compatible(np, compatible) &&
++=======
+ 	for_each_of_allnodes_from(from, np)
+ 		if (__of_device_is_compatible(np, compatible, type, NULL) &&
++>>>>>>> 5063e25a302e (of: Eliminate of_allnodes list)
  		    of_node_get(np))
  			break;
- 	}
  	of_node_put(from);
  	raw_spin_unlock_irqrestore(&devtree_lock, flags);
  	return np;
@@@ -890,8 -1030,11 +944,8 @@@ struct device_node *of_find_node_by_pha
  	struct device_node *np;
  	unsigned long flags;
  
 -	if (!handle)
 -		return NULL;
 -
  	raw_spin_lock_irqsave(&devtree_lock, flags);
- 	for (np = of_allnodes; np; np = np->allnext)
+ 	for_each_of_allnodes(np)
  		if (np->phandle == handle)
  			break;
  	of_node_get(np);
diff --cc drivers/of/fdt.c
index d167159c02a6,1d30b9f96466..000000000000
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@@ -143,21 -145,24 +143,21 @@@ static void *unflatten_dt_alloc(unsigne
   * @mem: Memory chunk to use for allocating device nodes and properties
   * @p: pointer to node in flat tree
   * @dad: Parent struct device_node
-  * @allnextpp: pointer to ->allnext from last allocated device_node
   * @fpsize: Size of the node path up at the current depth.
   */
 -static void * unflatten_dt_node(void *blob,
 -				void *mem,
 -				int *poffset,
 +static unsigned long unflatten_dt_node(struct boot_param_header *blob,
 +				unsigned long mem,
 +				unsigned long *p,
  				struct device_node *dad,
- 				struct device_node ***allnextpp,
- 				unsigned long fpsize)
+ 				struct device_node **nodepp,
+ 				unsigned long fpsize,
+ 				bool dryrun)
  {
 -	const __be32 *p;
  	struct device_node *np;
  	struct property *pp, **prev_pp = NULL;
 -	const char *pathp;
 +	char *pathp;
 +	u32 tag;
  	unsigned int l, allocl;
 -	static int depth = 0;
 -	int old_depth;
 -	int offset;
  	int has_name = 0;
  	int new_format = 0;
  
@@@ -199,9 -200,8 +199,9 @@@
  
  	np = unflatten_dt_alloc(&mem, sizeof(struct device_node) + allocl,
  				__alignof__(struct device_node));
- 	if (allnextpp) {
+ 	if (!dryrun) {
  		char *fn;
 +		memset(np, 0, sizeof(*np));
  		of_node_init(np);
  		np->full_name = fn = ((char *)np) + sizeof(*np);
  		if (new_format) {
@@@ -260,10 -250,9 +258,10 @@@
  		}
  		if (strcmp(pname, "name") == 0)
  			has_name = 1;
 +		l = strlen(pname) + 1;
  		pp = unflatten_dt_alloc(&mem, sizeof(struct property),
  					__alignof__(struct property));
- 		if (allnextpp) {
+ 		if (!dryrun) {
  			/* We accept flattened tree phandles either in
  			 * ePAPR-style "phandle" properties, or the
  			 * legacy "linux,phandle" properties.  If both
@@@ -328,19 -316,20 +326,36 @@@
  		if (!np->type)
  			np->type = "<NULL>";
  	}
++<<<<<<< HEAD
 +	while (tag == OF_DT_BEGIN_NODE || tag == OF_DT_NOP) {
 +		if (tag == OF_DT_NOP)
 +			*p += 4;
 +		else
 +			mem = unflatten_dt_node(blob, mem, p, np, allnextpp,
 +						fpsize);
 +		tag = be32_to_cpup((__be32 *)(*p));
 +	}
 +	if (tag != OF_DT_END_NODE) {
 +		pr_err("Weird tag at end of node: %x\n", tag);
 +		return mem;
 +	}
 +	*p += 4;
++=======
+ 
+ 	old_depth = depth;
+ 	*poffset = fdt_next_node(blob, *poffset, &depth);
+ 	if (depth < 0)
+ 		depth = 0;
+ 	while (*poffset > 0 && depth > old_depth)
+ 		mem = unflatten_dt_node(blob, mem, poffset, np, NULL,
+ 					fpsize, dryrun);
+ 
+ 	if (*poffset < 0 && *poffset != -FDT_ERR_NOTFOUND)
+ 		pr_err("unflatten: error %d processing FDT\n", *poffset);
+ 	if (nodepp)
+ 		*nodepp = np;
+ 
++>>>>>>> 5063e25a302e (of: Eliminate of_allnodes list)
  	return mem;
  }
  
@@@ -360,8 -349,9 +375,14 @@@ static void __unflatten_device_tree(str
  			     struct device_node **mynodes,
  			     void * (*dt_alloc)(u64 size, u64 align))
  {
++<<<<<<< HEAD
 +	unsigned long start, mem, size;
 +	struct device_node **allnextp = mynodes;
++=======
+ 	unsigned long size;
+ 	int start;
+ 	void *mem;
++>>>>>>> 5063e25a302e (of: Eliminate of_allnodes list)
  
  	pr_debug(" -> unflatten_device_tree()\n");
  
@@@ -381,33 -371,26 +402,47 @@@
  	}
  
  	/* First pass, scan for size */
++<<<<<<< HEAD
 +	start = ((unsigned long)blob) +
 +		be32_to_cpu(blob->off_dt_struct);
 +	size = unflatten_dt_node(blob, 0, &start, NULL, NULL, 0);
 +	size = (size | 3) + 1;
++=======
+ 	start = 0;
+ 	size = (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL, 0, true);
+ 	size = ALIGN(size, 4);
++>>>>>>> 5063e25a302e (of: Eliminate of_allnodes list)
  
  	pr_debug("  size is %lx, allocating...\n", size);
  
  	/* Allocate memory for the expanded device tree */
 -	mem = dt_alloc(size + 4, __alignof__(struct device_node));
 -	memset(mem, 0, size);
 +	mem = (unsigned long)
 +		dt_alloc(size + 4, __alignof__(struct device_node));
  
 -	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);
 +	memset((void *)mem, 0, size);
  
 -	pr_debug("  unflattening %p...\n", mem);
 +	((__be32 *)mem)[size / 4] = cpu_to_be32(0xdeadbeef);
 +
 +	pr_debug("  unflattening %lx...\n", mem);
  
  	/* Second pass, do actual unflattening */
++<<<<<<< HEAD
 +	start = ((unsigned long)blob) +
 +		be32_to_cpu(blob->off_dt_struct);
 +	unflatten_dt_node(blob, mem, &start, NULL, &allnextp, 0);
 +	if (be32_to_cpup((__be32 *)start) != OF_DT_END)
 +		pr_warning("Weird tag at end of tree: %08x\n", *((u32 *)start));
 +	if (be32_to_cpu(((__be32 *)mem)[size / 4]) != 0xdeadbeef)
 +		pr_warning("End of tree marker overwritten: %08x\n",
 +			   be32_to_cpu(((__be32 *)mem)[size / 4]));
 +	*allnextp = NULL;
++=======
+ 	start = 0;
+ 	unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
+ 	if (be32_to_cpup(mem + size) != 0xdeadbeef)
+ 		pr_warning("End of tree marker overwritten: %08x\n",
+ 			   be32_to_cpup(mem + size));
++>>>>>>> 5063e25a302e (of: Eliminate of_allnodes list)
  
  	pr_debug(" <- unflatten_device_tree()\n");
  }
@@@ -708,10 -1039,10 +743,10 @@@ int __init early_init_dt_scan_chosen(un
   */
  void __init unflatten_device_tree(void)
  {
- 	__unflatten_device_tree(initial_boot_params, &of_allnodes,
+ 	__unflatten_device_tree(initial_boot_params, &of_root,
  				early_init_dt_alloc_memory_arch);
  
 -	/* Get pointer to "/chosen" and "/aliases" nodes for use everywhere */
 +	/* Get pointer to "/chosen" and "/aliasas" nodes for use everywhere */
  	of_alias_scan(early_init_dt_alloc_memory_arch);
  }
  
diff --cc drivers/of/selftest.c
index 0eb5c38b4e07,bf7d99317a94..000000000000
--- a/drivers/of/selftest.c
+++ b/drivers/of/selftest.c
@@@ -24,6 -40,195 +24,198 @@@ static bool selftest_passed = true
  	} \
  }
  
++<<<<<<< HEAD
++=======
+ static void __init of_selftest_find_node_by_name(void)
+ {
+ 	struct device_node *np;
+ 
+ 	np = of_find_node_by_path("/testcase-data");
+ 	selftest(np && !strcmp("/testcase-data", np->full_name),
+ 		"find /testcase-data failed\n");
+ 	of_node_put(np);
+ 
+ 	/* Test if trailing '/' works */
+ 	np = of_find_node_by_path("/testcase-data/");
+ 	selftest(!np, "trailing '/' on /testcase-data/ should fail\n");
+ 
+ 	np = of_find_node_by_path("/testcase-data/phandle-tests/consumer-a");
+ 	selftest(np && !strcmp("/testcase-data/phandle-tests/consumer-a", np->full_name),
+ 		"find /testcase-data/phandle-tests/consumer-a failed\n");
+ 	of_node_put(np);
+ 
+ 	np = of_find_node_by_path("testcase-alias");
+ 	selftest(np && !strcmp("/testcase-data", np->full_name),
+ 		"find testcase-alias failed\n");
+ 	of_node_put(np);
+ 
+ 	/* Test if trailing '/' works on aliases */
+ 	np = of_find_node_by_path("testcase-alias/");
+ 	selftest(!np, "trailing '/' on testcase-alias/ should fail\n");
+ 
+ 	np = of_find_node_by_path("testcase-alias/phandle-tests/consumer-a");
+ 	selftest(np && !strcmp("/testcase-data/phandle-tests/consumer-a", np->full_name),
+ 		"find testcase-alias/phandle-tests/consumer-a failed\n");
+ 	of_node_put(np);
+ 
+ 	np = of_find_node_by_path("/testcase-data/missing-path");
+ 	selftest(!np, "non-existent path returned node %s\n", np->full_name);
+ 	of_node_put(np);
+ 
+ 	np = of_find_node_by_path("missing-alias");
+ 	selftest(!np, "non-existent alias returned node %s\n", np->full_name);
+ 	of_node_put(np);
+ 
+ 	np = of_find_node_by_path("testcase-alias/missing-path");
+ 	selftest(!np, "non-existent alias with relative path returned node %s\n", np->full_name);
+ 	of_node_put(np);
+ }
+ 
+ static void __init of_selftest_dynamic(void)
+ {
+ 	struct device_node *np;
+ 	struct property *prop;
+ 
+ 	np = of_find_node_by_path("/testcase-data");
+ 	if (!np) {
+ 		pr_err("missing testcase data\n");
+ 		return;
+ 	}
+ 
+ 	/* Array of 4 properties for the purpose of testing */
+ 	prop = kzalloc(sizeof(*prop) * 4, GFP_KERNEL);
+ 	if (!prop) {
+ 		selftest(0, "kzalloc() failed\n");
+ 		return;
+ 	}
+ 
+ 	/* Add a new property - should pass*/
+ 	prop->name = "new-property";
+ 	prop->value = "new-property-data";
+ 	prop->length = strlen(prop->value);
+ 	selftest(of_add_property(np, prop) == 0, "Adding a new property failed\n");
+ 
+ 	/* Try to add an existing property - should fail */
+ 	prop++;
+ 	prop->name = "new-property";
+ 	prop->value = "new-property-data-should-fail";
+ 	prop->length = strlen(prop->value);
+ 	selftest(of_add_property(np, prop) != 0,
+ 		 "Adding an existing property should have failed\n");
+ 
+ 	/* Try to modify an existing property - should pass */
+ 	prop->value = "modify-property-data-should-pass";
+ 	prop->length = strlen(prop->value);
+ 	selftest(of_update_property(np, prop) == 0,
+ 		 "Updating an existing property should have passed\n");
+ 
+ 	/* Try to modify non-existent property - should pass*/
+ 	prop++;
+ 	prop->name = "modify-property";
+ 	prop->value = "modify-missing-property-data-should-pass";
+ 	prop->length = strlen(prop->value);
+ 	selftest(of_update_property(np, prop) == 0,
+ 		 "Updating a missing property should have passed\n");
+ 
+ 	/* Remove property - should pass */
+ 	selftest(of_remove_property(np, prop) == 0,
+ 		 "Removing a property should have passed\n");
+ 
+ 	/* Adding very large property - should pass */
+ 	prop++;
+ 	prop->name = "large-property-PAGE_SIZEx8";
+ 	prop->length = PAGE_SIZE * 8;
+ 	prop->value = kzalloc(prop->length, GFP_KERNEL);
+ 	selftest(prop->value != NULL, "Unable to allocate large buffer\n");
+ 	if (prop->value)
+ 		selftest(of_add_property(np, prop) == 0,
+ 			 "Adding a large property should have passed\n");
+ }
+ 
+ static int __init of_selftest_check_node_linkage(struct device_node *np)
+ {
+ 	struct device_node *child;
+ 	int count = 0, rc;
+ 
+ 	for_each_child_of_node(np, child) {
+ 		if (child->parent != np) {
+ 			pr_err("Child node %s links to wrong parent %s\n",
+ 				 child->name, np->name);
+ 			return -EINVAL;
+ 		}
+ 
+ 		rc = of_selftest_check_node_linkage(child);
+ 		if (rc < 0)
+ 			return rc;
+ 		count += rc;
+ 	}
+ 
+ 	return count + 1;
+ }
+ 
+ static void __init of_selftest_check_tree_linkage(void)
+ {
+ 	struct device_node *np;
+ 	int allnode_count = 0, child_count;
+ 
+ 	if (!of_root)
+ 		return;
+ 
+ 	for_each_of_allnodes(np)
+ 		allnode_count++;
+ 	child_count = of_selftest_check_node_linkage(of_root);
+ 
+ 	selftest(child_count > 0, "Device node data structure is corrupted\n");
+ 	selftest(child_count == allnode_count, "allnodes list size (%i) doesn't match"
+ 		 "sibling lists size (%i)\n", allnode_count, child_count);
+ 	pr_debug("allnodes list size (%i); sibling lists size (%i)\n", allnode_count, child_count);
+ }
+ 
+ struct node_hash {
+ 	struct hlist_node node;
+ 	struct device_node *np;
+ };
+ 
+ static DEFINE_HASHTABLE(phandle_ht, 8);
+ static void __init of_selftest_check_phandles(void)
+ {
+ 	struct device_node *np;
+ 	struct node_hash *nh;
+ 	struct hlist_node *tmp;
+ 	int i, dup_count = 0, phandle_count = 0;
+ 
+ 	for_each_of_allnodes(np) {
+ 		if (!np->phandle)
+ 			continue;
+ 
+ 		hash_for_each_possible(phandle_ht, nh, node, np->phandle) {
+ 			if (nh->np->phandle == np->phandle) {
+ 				pr_info("Duplicate phandle! %i used by %s and %s\n",
+ 					np->phandle, nh->np->full_name, np->full_name);
+ 				dup_count++;
+ 				break;
+ 			}
+ 		}
+ 
+ 		nh = kzalloc(sizeof(*nh), GFP_KERNEL);
+ 		if (WARN_ON(!nh))
+ 			return;
+ 
+ 		nh->np = np;
+ 		hash_add(phandle_ht, &nh->node, np->phandle);
+ 		phandle_count++;
+ 	}
+ 	selftest(dup_count == 0, "Found %i duplicates in %i phandles\n",
+ 		 dup_count, phandle_count);
+ 
+ 	/* Clean up */
+ 	hash_for_each_safe(phandle_ht, i, tmp, nh, node) {
+ 		hash_del(&nh->node);
+ 		kfree(nh);
+ 	}
+ }
+ 
++>>>>>>> 5063e25a302e (of: Eliminate of_allnodes list)
  static void __init of_selftest_parse_phandle_with_args(void)
  {
  	struct device_node *np;
@@@ -145,13 -350,561 +337,565 @@@ static void __init of_selftest_property
  	rc = of_property_match_string(np, "phandle-list-names", "third");
  	selftest(rc == 2, "third expected:0 got:%i\n", rc);
  	rc = of_property_match_string(np, "phandle-list-names", "fourth");
 -	selftest(rc == -ENODATA, "unmatched string; rc=%i\n", rc);
 +	selftest(rc == -ENODATA, "unmatched string; rc=%i", rc);
  	rc = of_property_match_string(np, "missing-property", "blah");
 -	selftest(rc == -EINVAL, "missing property; rc=%i\n", rc);
 +	selftest(rc == -EINVAL, "missing property; rc=%i", rc);
  	rc = of_property_match_string(np, "empty-property", "blah");
 -	selftest(rc == -ENODATA, "empty property; rc=%i\n", rc);
 +	selftest(rc == -ENODATA, "empty property; rc=%i", rc);
  	rc = of_property_match_string(np, "unterminated-string", "blah");
++<<<<<<< HEAD
 +	selftest(rc == -EILSEQ, "unterminated string; rc=%i", rc);
++=======
+ 	selftest(rc == -EILSEQ, "unterminated string; rc=%i\n", rc);
+ 
+ 	/* of_property_count_strings() tests */
+ 	rc = of_property_count_strings(np, "string-property");
+ 	selftest(rc == 1, "Incorrect string count; rc=%i\n", rc);
+ 	rc = of_property_count_strings(np, "phandle-list-names");
+ 	selftest(rc == 3, "Incorrect string count; rc=%i\n", rc);
+ 	rc = of_property_count_strings(np, "unterminated-string");
+ 	selftest(rc == -EILSEQ, "unterminated string; rc=%i\n", rc);
+ 	rc = of_property_count_strings(np, "unterminated-string-list");
+ 	selftest(rc == -EILSEQ, "unterminated string array; rc=%i\n", rc);
+ 
+ 	/* of_property_read_string_index() tests */
+ 	rc = of_property_read_string_index(np, "string-property", 0, strings);
+ 	selftest(rc == 0 && !strcmp(strings[0], "foobar"), "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	strings[0] = NULL;
+ 	rc = of_property_read_string_index(np, "string-property", 1, strings);
+ 	selftest(rc == -ENODATA && strings[0] == NULL, "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	rc = of_property_read_string_index(np, "phandle-list-names", 0, strings);
+ 	selftest(rc == 0 && !strcmp(strings[0], "first"), "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	rc = of_property_read_string_index(np, "phandle-list-names", 1, strings);
+ 	selftest(rc == 0 && !strcmp(strings[0], "second"), "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	rc = of_property_read_string_index(np, "phandle-list-names", 2, strings);
+ 	selftest(rc == 0 && !strcmp(strings[0], "third"), "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	strings[0] = NULL;
+ 	rc = of_property_read_string_index(np, "phandle-list-names", 3, strings);
+ 	selftest(rc == -ENODATA && strings[0] == NULL, "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	strings[0] = NULL;
+ 	rc = of_property_read_string_index(np, "unterminated-string", 0, strings);
+ 	selftest(rc == -EILSEQ && strings[0] == NULL, "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	rc = of_property_read_string_index(np, "unterminated-string-list", 0, strings);
+ 	selftest(rc == 0 && !strcmp(strings[0], "first"), "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	strings[0] = NULL;
+ 	rc = of_property_read_string_index(np, "unterminated-string-list", 2, strings); /* should fail */
+ 	selftest(rc == -EILSEQ && strings[0] == NULL, "of_property_read_string_index() failure; rc=%i\n", rc);
+ 	strings[1] = NULL;
+ 
+ 	/* of_property_read_string_array() tests */
+ 	rc = of_property_read_string_array(np, "string-property", strings, 4);
+ 	selftest(rc == 1, "Incorrect string count; rc=%i\n", rc);
+ 	rc = of_property_read_string_array(np, "phandle-list-names", strings, 4);
+ 	selftest(rc == 3, "Incorrect string count; rc=%i\n", rc);
+ 	rc = of_property_read_string_array(np, "unterminated-string", strings, 4);
+ 	selftest(rc == -EILSEQ, "unterminated string; rc=%i\n", rc);
+ 	/* -- An incorrectly formed string should cause a failure */
+ 	rc = of_property_read_string_array(np, "unterminated-string-list", strings, 4);
+ 	selftest(rc == -EILSEQ, "unterminated string array; rc=%i\n", rc);
+ 	/* -- parsing the correctly formed strings should still work: */
+ 	strings[2] = NULL;
+ 	rc = of_property_read_string_array(np, "unterminated-string-list", strings, 2);
+ 	selftest(rc == 2 && strings[2] == NULL, "of_property_read_string_array() failure; rc=%i\n", rc);
+ 	strings[1] = NULL;
+ 	rc = of_property_read_string_array(np, "phandle-list-names", strings, 1);
+ 	selftest(rc == 1 && strings[1] == NULL, "Overwrote end of string array; rc=%i, str='%s'\n", rc, strings[1]);
+ }
+ 
+ #define propcmp(p1, p2) (((p1)->length == (p2)->length) && \
+ 			(p1)->value && (p2)->value && \
+ 			!memcmp((p1)->value, (p2)->value, (p1)->length) && \
+ 			!strcmp((p1)->name, (p2)->name))
+ static void __init of_selftest_property_copy(void)
+ {
+ #ifdef CONFIG_OF_DYNAMIC
+ 	struct property p1 = { .name = "p1", .length = 0, .value = "" };
+ 	struct property p2 = { .name = "p2", .length = 5, .value = "abcd" };
+ 	struct property *new;
+ 
+ 	new = __of_prop_dup(&p1, GFP_KERNEL);
+ 	selftest(new && propcmp(&p1, new), "empty property didn't copy correctly\n");
+ 	kfree(new->value);
+ 	kfree(new->name);
+ 	kfree(new);
+ 
+ 	new = __of_prop_dup(&p2, GFP_KERNEL);
+ 	selftest(new && propcmp(&p2, new), "non-empty property didn't copy correctly\n");
+ 	kfree(new->value);
+ 	kfree(new->name);
+ 	kfree(new);
+ #endif
+ }
+ 
+ static void __init of_selftest_changeset(void)
+ {
+ #ifdef CONFIG_OF_DYNAMIC
+ 	struct property *ppadd, padd = { .name = "prop-add", .length = 0, .value = "" };
+ 	struct property *ppupdate, pupdate = { .name = "prop-update", .length = 5, .value = "abcd" };
+ 	struct property *ppremove;
+ 	struct device_node *n1, *n2, *n21, *nremove, *parent;
+ 	struct of_changeset chgset;
+ 
+ 	of_changeset_init(&chgset);
+ 	n1 = __of_node_alloc("/testcase-data/changeset/n1", GFP_KERNEL);
+ 	selftest(n1, "testcase setup failure\n");
+ 	n2 = __of_node_alloc("/testcase-data/changeset/n2", GFP_KERNEL);
+ 	selftest(n2, "testcase setup failure\n");
+ 	n21 = __of_node_alloc("/testcase-data/changeset/n2/n21", GFP_KERNEL);
+ 	selftest(n21, "testcase setup failure %p\n", n21);
+ 	nremove = of_find_node_by_path("/testcase-data/changeset/node-remove");
+ 	selftest(nremove, "testcase setup failure\n");
+ 	ppadd = __of_prop_dup(&padd, GFP_KERNEL);
+ 	selftest(ppadd, "testcase setup failure\n");
+ 	ppupdate = __of_prop_dup(&pupdate, GFP_KERNEL);
+ 	selftest(ppupdate, "testcase setup failure\n");
+ 	parent = nremove->parent;
+ 	n1->parent = parent;
+ 	n2->parent = parent;
+ 	n21->parent = n2;
+ 	n2->child = n21;
+ 	ppremove = of_find_property(parent, "prop-remove", NULL);
+ 	selftest(ppremove, "failed to find removal prop");
+ 
+ 	of_changeset_init(&chgset);
+ 	selftest(!of_changeset_attach_node(&chgset, n1), "fail attach n1\n");
+ 	selftest(!of_changeset_attach_node(&chgset, n2), "fail attach n2\n");
+ 	selftest(!of_changeset_detach_node(&chgset, nremove), "fail remove node\n");
+ 	selftest(!of_changeset_attach_node(&chgset, n21), "fail attach n21\n");
+ 	selftest(!of_changeset_add_property(&chgset, parent, ppadd), "fail add prop\n");
+ 	selftest(!of_changeset_update_property(&chgset, parent, ppupdate), "fail update prop\n");
+ 	selftest(!of_changeset_remove_property(&chgset, parent, ppremove), "fail remove prop\n");
+ 	mutex_lock(&of_mutex);
+ 	selftest(!of_changeset_apply(&chgset), "apply failed\n");
+ 	mutex_unlock(&of_mutex);
+ 
+ 	mutex_lock(&of_mutex);
+ 	selftest(!of_changeset_revert(&chgset), "revert failed\n");
+ 	mutex_unlock(&of_mutex);
+ 
+ 	of_changeset_destroy(&chgset);
+ #endif
+ }
+ 
+ static void __init of_selftest_parse_interrupts(void)
+ {
+ 	struct device_node *np;
+ 	struct of_phandle_args args;
+ 	int i, rc;
+ 
+ 	np = of_find_node_by_path("/testcase-data/interrupts/interrupts0");
+ 	if (!np) {
+ 		pr_err("missing testcase data\n");
+ 		return;
+ 	}
+ 
+ 	for (i = 0; i < 4; i++) {
+ 		bool passed = true;
+ 		args.args_count = 0;
+ 		rc = of_irq_parse_one(np, i, &args);
+ 
+ 		passed &= !rc;
+ 		passed &= (args.args_count == 1);
+ 		passed &= (args.args[0] == (i + 1));
+ 
+ 		selftest(passed, "index %i - data error on node %s rc=%i\n",
+ 			 i, args.np->full_name, rc);
+ 	}
+ 	of_node_put(np);
+ 
+ 	np = of_find_node_by_path("/testcase-data/interrupts/interrupts1");
+ 	if (!np) {
+ 		pr_err("missing testcase data\n");
+ 		return;
+ 	}
+ 
+ 	for (i = 0; i < 4; i++) {
+ 		bool passed = true;
+ 		args.args_count = 0;
+ 		rc = of_irq_parse_one(np, i, &args);
+ 
+ 		/* Test the values from tests-phandle.dtsi */
+ 		switch (i) {
+ 		case 0:
+ 			passed &= !rc;
+ 			passed &= (args.args_count == 1);
+ 			passed &= (args.args[0] == 9);
+ 			break;
+ 		case 1:
+ 			passed &= !rc;
+ 			passed &= (args.args_count == 3);
+ 			passed &= (args.args[0] == 10);
+ 			passed &= (args.args[1] == 11);
+ 			passed &= (args.args[2] == 12);
+ 			break;
+ 		case 2:
+ 			passed &= !rc;
+ 			passed &= (args.args_count == 2);
+ 			passed &= (args.args[0] == 13);
+ 			passed &= (args.args[1] == 14);
+ 			break;
+ 		case 3:
+ 			passed &= !rc;
+ 			passed &= (args.args_count == 2);
+ 			passed &= (args.args[0] == 15);
+ 			passed &= (args.args[1] == 16);
+ 			break;
+ 		default:
+ 			passed = false;
+ 		}
+ 		selftest(passed, "index %i - data error on node %s rc=%i\n",
+ 			 i, args.np->full_name, rc);
+ 	}
+ 	of_node_put(np);
+ }
+ 
+ static void __init of_selftest_parse_interrupts_extended(void)
+ {
+ 	struct device_node *np;
+ 	struct of_phandle_args args;
+ 	int i, rc;
+ 
+ 	np = of_find_node_by_path("/testcase-data/interrupts/interrupts-extended0");
+ 	if (!np) {
+ 		pr_err("missing testcase data\n");
+ 		return;
+ 	}
+ 
+ 	for (i = 0; i < 7; i++) {
+ 		bool passed = true;
+ 		rc = of_irq_parse_one(np, i, &args);
+ 
+ 		/* Test the values from tests-phandle.dtsi */
+ 		switch (i) {
+ 		case 0:
+ 			passed &= !rc;
+ 			passed &= (args.args_count == 1);
+ 			passed &= (args.args[0] == 1);
+ 			break;
+ 		case 1:
+ 			passed &= !rc;
+ 			passed &= (args.args_count == 3);
+ 			passed &= (args.args[0] == 2);
+ 			passed &= (args.args[1] == 3);
+ 			passed &= (args.args[2] == 4);
+ 			break;
+ 		case 2:
+ 			passed &= !rc;
+ 			passed &= (args.args_count == 2);
+ 			passed &= (args.args[0] == 5);
+ 			passed &= (args.args[1] == 6);
+ 			break;
+ 		case 3:
+ 			passed &= !rc;
+ 			passed &= (args.args_count == 1);
+ 			passed &= (args.args[0] == 9);
+ 			break;
+ 		case 4:
+ 			passed &= !rc;
+ 			passed &= (args.args_count == 3);
+ 			passed &= (args.args[0] == 10);
+ 			passed &= (args.args[1] == 11);
+ 			passed &= (args.args[2] == 12);
+ 			break;
+ 		case 5:
+ 			passed &= !rc;
+ 			passed &= (args.args_count == 2);
+ 			passed &= (args.args[0] == 13);
+ 			passed &= (args.args[1] == 14);
+ 			break;
+ 		case 6:
+ 			passed &= !rc;
+ 			passed &= (args.args_count == 1);
+ 			passed &= (args.args[0] == 15);
+ 			break;
+ 		default:
+ 			passed = false;
+ 		}
+ 
+ 		selftest(passed, "index %i - data error on node %s rc=%i\n",
+ 			 i, args.np->full_name, rc);
+ 	}
+ 	of_node_put(np);
+ }
+ 
+ static struct of_device_id match_node_table[] = {
+ 	{ .data = "A", .name = "name0", }, /* Name alone is lowest priority */
+ 	{ .data = "B", .type = "type1", }, /* followed by type alone */
+ 
+ 	{ .data = "Ca", .name = "name2", .type = "type1", }, /* followed by both together */
+ 	{ .data = "Cb", .name = "name2", }, /* Only match when type doesn't match */
+ 	{ .data = "Cc", .name = "name2", .type = "type2", },
+ 
+ 	{ .data = "E", .compatible = "compat3" },
+ 	{ .data = "G", .compatible = "compat2", },
+ 	{ .data = "H", .compatible = "compat2", .name = "name5", },
+ 	{ .data = "I", .compatible = "compat2", .type = "type1", },
+ 	{ .data = "J", .compatible = "compat2", .type = "type1", .name = "name8", },
+ 	{ .data = "K", .compatible = "compat2", .name = "name9", },
+ 	{}
+ };
+ 
+ static struct {
+ 	const char *path;
+ 	const char *data;
+ } match_node_tests[] = {
+ 	{ .path = "/testcase-data/match-node/name0", .data = "A", },
+ 	{ .path = "/testcase-data/match-node/name1", .data = "B", },
+ 	{ .path = "/testcase-data/match-node/a/name2", .data = "Ca", },
+ 	{ .path = "/testcase-data/match-node/b/name2", .data = "Cb", },
+ 	{ .path = "/testcase-data/match-node/c/name2", .data = "Cc", },
+ 	{ .path = "/testcase-data/match-node/name3", .data = "E", },
+ 	{ .path = "/testcase-data/match-node/name4", .data = "G", },
+ 	{ .path = "/testcase-data/match-node/name5", .data = "H", },
+ 	{ .path = "/testcase-data/match-node/name6", .data = "G", },
+ 	{ .path = "/testcase-data/match-node/name7", .data = "I", },
+ 	{ .path = "/testcase-data/match-node/name8", .data = "J", },
+ 	{ .path = "/testcase-data/match-node/name9", .data = "K", },
+ };
+ 
+ static void __init of_selftest_match_node(void)
+ {
+ 	struct device_node *np;
+ 	const struct of_device_id *match;
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(match_node_tests); i++) {
+ 		np = of_find_node_by_path(match_node_tests[i].path);
+ 		if (!np) {
+ 			selftest(0, "missing testcase node %s\n",
+ 				match_node_tests[i].path);
+ 			continue;
+ 		}
+ 
+ 		match = of_match_node(match_node_table, np);
+ 		if (!match) {
+ 			selftest(0, "%s didn't match anything\n",
+ 				match_node_tests[i].path);
+ 			continue;
+ 		}
+ 
+ 		if (strcmp(match->data, match_node_tests[i].data) != 0) {
+ 			selftest(0, "%s got wrong match. expected %s, got %s\n",
+ 				match_node_tests[i].path, match_node_tests[i].data,
+ 				(const char *)match->data);
+ 			continue;
+ 		}
+ 		selftest(1, "passed");
+ 	}
+ }
+ 
+ static void __init of_selftest_platform_populate(void)
+ {
+ 	int irq;
+ 	struct device_node *np, *child;
+ 	struct platform_device *pdev;
+ 	struct of_device_id match[] = {
+ 		{ .compatible = "test-device", },
+ 		{}
+ 	};
+ 
+ 	np = of_find_node_by_path("/testcase-data");
+ 	of_platform_populate(np, of_default_bus_match_table, NULL, NULL);
+ 
+ 	/* Test that a missing irq domain returns -EPROBE_DEFER */
+ 	np = of_find_node_by_path("/testcase-data/testcase-device1");
+ 	pdev = of_find_device_by_node(np);
+ 	selftest(pdev, "device 1 creation failed\n");
+ 
+ 	irq = platform_get_irq(pdev, 0);
+ 	selftest(irq == -EPROBE_DEFER, "device deferred probe failed - %d\n", irq);
+ 
+ 	/* Test that a parsing failure does not return -EPROBE_DEFER */
+ 	np = of_find_node_by_path("/testcase-data/testcase-device2");
+ 	pdev = of_find_device_by_node(np);
+ 	selftest(pdev, "device 2 creation failed\n");
+ 	irq = platform_get_irq(pdev, 0);
+ 	selftest(irq < 0 && irq != -EPROBE_DEFER, "device parsing error failed - %d\n", irq);
+ 
+ 	np = of_find_node_by_path("/testcase-data/platform-tests");
+ 	if (!np) {
+ 		pr_err("No testcase data in device tree\n");
+ 		return;
+ 	}
+ 
+ 	for_each_child_of_node(np, child) {
+ 		struct device_node *grandchild;
+ 		of_platform_populate(child, match, NULL, NULL);
+ 		for_each_child_of_node(child, grandchild)
+ 			selftest(of_find_device_by_node(grandchild),
+ 				 "Could not create device for node '%s'\n",
+ 				 grandchild->name);
+ 	}
+ }
+ 
+ /**
+  *	update_node_properties - adds the properties
+  *	of np into dup node (present in live tree) and
+  *	updates parent of children of np to dup.
+  *
+  *	@np:	node already present in live tree
+  *	@dup:	node present in live tree to be updated
+  */
+ static void update_node_properties(struct device_node *np,
+ 					struct device_node *dup)
+ {
+ 	struct property *prop;
+ 	struct device_node *child;
+ 
+ 	for_each_property_of_node(np, prop)
+ 		of_add_property(dup, prop);
+ 
+ 	for_each_child_of_node(np, child)
+ 		child->parent = dup;
+ }
+ 
+ /**
+  *	attach_node_and_children - attaches nodes
+  *	and its children to live tree
+  *
+  *	@np:	Node to attach to live tree
+  */
+ static int attach_node_and_children(struct device_node *np)
+ {
+ 	struct device_node *next, *dup, *child;
+ 
+ 	dup = of_find_node_by_path(np->full_name);
+ 	if (dup) {
+ 		update_node_properties(np, dup);
+ 		return 0;
+ 	}
+ 
+ 	/* Children of the root need to be remembered for removal */
+ 	if (np->parent == of_root) {
+ 		if (WARN_ON(last_node_index >= NO_OF_NODES))
+ 			return -EINVAL;
+ 		nodes[last_node_index++] = np;
+ 	}
+ 
+ 	child = np->child;
+ 	np->child = NULL;
+ 	np->sibling = NULL;
+ 	of_attach_node(np);
+ 	while (child) {
+ 		next = child->sibling;
+ 		attach_node_and_children(child);
+ 		child = next;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  *	selftest_data_add - Reads, copies data from
+  *	linked tree and attaches it to the live tree
+  */
+ static int __init selftest_data_add(void)
+ {
+ 	void *selftest_data;
+ 	struct device_node *selftest_data_node, *np;
+ 	extern uint8_t __dtb_testcases_begin[];
+ 	extern uint8_t __dtb_testcases_end[];
+ 	const int size = __dtb_testcases_end - __dtb_testcases_begin;
+ 	int rc;
+ 
+ 	if (!size) {
+ 		pr_warn("%s: No testcase data to attach; not running tests\n",
+ 			__func__);
+ 		return -ENODATA;
+ 	}
+ 
+ 	/* creating copy */
+ 	selftest_data = kmemdup(__dtb_testcases_begin, size, GFP_KERNEL);
+ 
+ 	if (!selftest_data) {
+ 		pr_warn("%s: Failed to allocate memory for selftest_data; "
+ 			"not running tests\n", __func__);
+ 		return -ENOMEM;
+ 	}
+ 	of_fdt_unflatten_tree(selftest_data, &selftest_data_node);
+ 	if (!selftest_data_node) {
+ 		pr_warn("%s: No tree to attach; not running tests\n", __func__);
+ 		return -ENODATA;
+ 	}
+ 	of_node_set_flag(selftest_data_node, OF_DETACHED);
+ 	rc = of_resolve_phandles(selftest_data_node);
+ 	if (rc) {
+ 		pr_err("%s: Failed to resolve phandles (rc=%i)\n", __func__, rc);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!of_root) {
+ 		/* enabling flag for removing nodes */
+ 		selftest_live_tree = true;
+ 		of_root = selftest_data_node;
+ 
+ 		for_each_of_allnodes(np)
+ 			__of_attach_node_sysfs(np);
+ 		of_aliases = of_find_node_by_path("/aliases");
+ 		of_chosen = of_find_node_by_path("/chosen");
+ 		return 0;
+ 	}
+ 
+ 	/* attach the sub-tree to live tree */
+ 	np = selftest_data_node->child;
+ 	while (np) {
+ 		struct device_node *next = np->sibling;
+ 		np->parent = of_root;
+ 		attach_node_and_children(np);
+ 		np = next;
+ 	}
+ 	return 0;
+ }
+ 
+ /**
+  *	detach_node_and_children - detaches node
+  *	and its children from live tree
+  *
+  *	@np:	Node to detach from live tree
+  */
+ static void detach_node_and_children(struct device_node *np)
+ {
+ 	while (np->child)
+ 		detach_node_and_children(np->child);
+ 	of_detach_node(np);
+ }
+ 
+ /**
+  *	selftest_data_remove - removes the selftest data
+  *	nodes from the live tree
+  */
+ static void selftest_data_remove(void)
+ {
+ 	struct device_node *np;
+ 	struct property *prop;
+ 
+ 	if (selftest_live_tree) {
+ 		of_node_put(of_aliases);
+ 		of_node_put(of_chosen);
+ 		of_aliases = NULL;
+ 		of_chosen = NULL;
+ 		for_each_child_of_node(of_root, np)
+ 			detach_node_and_children(np);
+ 		__of_detach_node_sysfs(of_root);
+ 		of_root = NULL;
+ 		return;
+ 	}
+ 
+ 	while (last_node_index >= 0) {
+ 		if (nodes[last_node_index]) {
+ 			np = of_find_node_by_path(nodes[last_node_index]->full_name);
+ 			if (strcmp(np->full_name, "/aliases") != 0) {
+ 				detach_node_and_children(np);
+ 			} else {
+ 				for_each_property_of_node(np, prop) {
+ 					if (strcmp(prop->name, "testcase-alias") == 0)
+ 						of_remove_property(np, prop);
+ 				}
+ 			}
+ 		}
+ 		last_node_index--;
+ 	}
++>>>>>>> 5063e25a302e (of: Eliminate of_allnodes list)
  }
  
  static int __init of_selftest(void)
diff --cc include/linux/of.h
index 768a2bb38295,f54da3b699a8..000000000000
--- a/include/linux/of.h
+++ b/include/linux/of.h
@@@ -58,9 -56,7 +58,13 @@@ struct device_node 
  	struct	device_node *child;
  	struct	device_node *sibling;
  	struct	device_node *next;	/* next device of same type */
++<<<<<<< HEAD
 +	struct	device_node *allnext;	/* next in list of all nodes */
 +	struct	proc_dir_entry *pde;	/* this node's proc directory */
 +	struct kref kref;
++=======
+ 	struct	kobject kobj;
++>>>>>>> 5063e25a302e (of: Eliminate of_allnodes list)
  	unsigned long _flags;
  	void	*data;
  #if defined(CONFIG_SPARC)
@@@ -114,9 -107,10 +118,9 @@@ static inline void of_node_put(struct d
  #ifdef CONFIG_OF
  
  /* Pointer for first entry in chain of all nodes. */
- extern struct device_node *of_allnodes;
+ extern struct device_node *of_root;
  extern struct device_node *of_chosen;
  extern struct device_node *of_aliases;
 -extern struct device_node *of_stdout;
  extern raw_spinlock_t devtree_lock;
  
  static inline bool of_have_populated_dt(void)
@@@ -139,6 -139,27 +143,30 @@@ static inline void of_node_set_flag(str
  	set_bit(flag, &n->_flags);
  }
  
++<<<<<<< HEAD
++=======
+ static inline void of_node_clear_flag(struct device_node *n, unsigned long flag)
+ {
+ 	clear_bit(flag, &n->_flags);
+ }
+ 
+ static inline int of_property_check_flag(struct property *p, unsigned long flag)
+ {
+ 	return test_bit(flag, &p->_flags);
+ }
+ 
+ static inline void of_property_set_flag(struct property *p, unsigned long flag)
+ {
+ 	set_bit(flag, &p->_flags);
+ }
+ 
+ static inline void of_property_clear_flag(struct property *p, unsigned long flag)
+ {
+ 	clear_bit(flag, &p->_flags);
+ }
+ 
+ extern struct device_node *__of_find_all_nodes(struct device_node *prev);
++>>>>>>> 5063e25a302e (of: Eliminate of_allnodes list)
  extern struct device_node *of_find_all_nodes(struct device_node *prev);
  
  /*
@@@ -190,23 -215,15 +218,24 @@@ static inline const char *of_node_full_
  	return np ? np->full_name : "<no-node>";
  }
  
- #define for_each_of_allnodes(dn) \
- 	for (dn = of_allnodes; dn; dn = dn->allnext)
+ #define for_each_of_allnodes_from(from, dn) \
+ 	for (dn = __of_find_all_nodes(from); dn; dn = __of_find_all_nodes(dn))
+ #define for_each_of_allnodes(dn) for_each_of_allnodes_from(NULL, dn)
  extern struct device_node *of_find_node_by_name(struct device_node *from,
  	const char *name);
 +#define for_each_node_by_name(dn, name) \
 +	for (dn = of_find_node_by_name(NULL, name); dn; \
 +	     dn = of_find_node_by_name(dn, name))
  extern struct device_node *of_find_node_by_type(struct device_node *from,
  	const char *type);
 +#define for_each_node_by_type(dn, type) \
 +	for (dn = of_find_node_by_type(NULL, type); dn; \
 +	     dn = of_find_node_by_type(dn, type))
  extern struct device_node *of_find_compatible_node(struct device_node *from,
  	const char *type, const char *compat);
 +#define for_each_compatible_node(dn, type, compatible) \
 +	for (dn = of_find_compatible_node(NULL, type, compatible); dn; \
 +	     dn = of_find_compatible_node(dn, type, compatible))
  extern struct device_node *of_find_matching_node_and_match(
  	struct device_node *from,
  	const struct of_device_id *matches,
* Unmerged path Documentation/devicetree/of_selftest.txt
* Unmerged path Documentation/devicetree/todo.txt
* Unmerged path drivers/of/dynamic.c
* Unmerged path Documentation/devicetree/of_selftest.txt
* Unmerged path Documentation/devicetree/todo.txt
* Unmerged path drivers/mfd/vexpress-sysreg.c
* Unmerged path drivers/of/base.c
* Unmerged path drivers/of/dynamic.c
* Unmerged path drivers/of/fdt.c
diff --git a/drivers/of/pdt.c b/drivers/of/pdt.c
index 37961b853b41..ecab1a28bddd 100644
--- a/drivers/of/pdt.c
+++ b/drivers/of/pdt.c
@@ -26,8 +26,7 @@
 
 static struct of_pdt_ops *of_pdt_prom_ops __initdata;
 
-void __initdata (*of_pdt_build_more)(struct device_node *dp,
-		struct device_node ***nextp);
+void __initdata (*of_pdt_build_more)(struct device_node *dp);
 
 #if defined(CONFIG_SPARC)
 unsigned int of_pdt_unique_id __initdata;
@@ -193,8 +192,7 @@ static struct device_node * __init of_pdt_create_node(phandle node,
 }
 
 static struct device_node * __init of_pdt_build_tree(struct device_node *parent,
-						   phandle node,
-						   struct device_node ***nextp)
+						   phandle node)
 {
 	struct device_node *ret = NULL, *prev_sibling = NULL;
 	struct device_node *dp;
@@ -211,16 +209,12 @@ static struct device_node * __init of_pdt_build_tree(struct device_node *parent,
 			ret = dp;
 		prev_sibling = dp;
 
-		*(*nextp) = dp;
-		*nextp = &dp->allnext;
-
 		dp->full_name = of_pdt_build_full_name(dp);
 
-		dp->child = of_pdt_build_tree(dp,
-				of_pdt_prom_ops->getchild(node), nextp);
+		dp->child = of_pdt_build_tree(dp, of_pdt_prom_ops->getchild(node));
 
 		if (of_pdt_build_more)
-			of_pdt_build_more(dp, nextp);
+			of_pdt_build_more(dp);
 
 		node = of_pdt_prom_ops->getsibling(node);
 	}
@@ -235,20 +229,17 @@ static void * __init kernel_tree_alloc(u64 size, u64 align)
 
 void __init of_pdt_build_devicetree(phandle root_node, struct of_pdt_ops *ops)
 {
-	struct device_node **nextp;
-
 	BUG_ON(!ops);
 	of_pdt_prom_ops = ops;
 
-	of_allnodes = of_pdt_create_node(root_node, NULL);
+	of_root = of_pdt_create_node(root_node, NULL);
 #if defined(CONFIG_SPARC)
-	of_allnodes->path_component_name = "";
+	of_root->path_component_name = "";
 #endif
-	of_allnodes->full_name = "/";
+	of_root->full_name = "/";
 
-	nextp = &of_allnodes->allnext;
-	of_allnodes->child = of_pdt_build_tree(of_allnodes,
-			of_pdt_prom_ops->getchild(of_allnodes->phandle), &nextp);
+	of_root->child = of_pdt_build_tree(of_root,
+				of_pdt_prom_ops->getchild(of_root->phandle));
 
 	/* Get pointer to "/chosen" and "/aliasas" nodes for use everywhere */
 	of_alias_scan(kernel_tree_alloc);
* Unmerged path drivers/of/selftest.c
* Unmerged path include/linux/of.h
diff --git a/include/linux/of_pdt.h b/include/linux/of_pdt.h
index c65a18a0cfdf..7e09244bb679 100644
--- a/include/linux/of_pdt.h
+++ b/include/linux/of_pdt.h
@@ -39,7 +39,6 @@ extern void *prom_early_alloc(unsigned long size);
 /* for building the device tree */
 extern void of_pdt_build_devicetree(phandle root_node, struct of_pdt_ops *ops);
 
-extern void (*of_pdt_build_more)(struct device_node *dp,
-		struct device_node ***nextp);
+extern void (*of_pdt_build_more)(struct device_node *dp);
 
 #endif /* _LINUX_OF_PDT_H */
