IB/mlx4: Add support for CQ time-stamping

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [inifniband] mlx4: Add support for CQ time-stamping (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 96.20%
commit-author Matan Barak <matanb@mellanox.com>
commit 4b664c4355b251a142d9d57d0ca0298b497f8428
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4b664c43.failed

This includes:

* support allocation of CQ with the TIMESTAMP_COMPLETION creation flag.

* add timestamp_mask and hca_core_clock to query_device, reporting the
  number of supported timestamp bits (mask) and the hca_core_clock frequency.

* return hca core clock's offset in query_device vendor's data,
  this is needed in order to read the HCA's core clock.

	Signed-off-by: Matan Barak <matanb@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 4b664c4355b251a142d9d57d0ca0298b497f8428)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx4/cq.c
#	drivers/infiniband/hw/mlx4/main.c
diff --cc drivers/infiniband/hw/mlx4/cq.c
index 0176caa5792c,36eb3d012b6d..000000000000
--- a/drivers/infiniband/hw/mlx4/cq.c
+++ b/drivers/infiniband/hw/mlx4/cq.c
@@@ -166,7 -166,9 +166,13 @@@ err_buf
  	return err;
  }
  
++<<<<<<< HEAD
 +struct ib_cq *mlx4_ib_create_cq(struct ib_device *ibdev, int entries, int vector,
++=======
+ #define CQ_CREATE_FLAGS_SUPPORTED IB_CQ_FLAGS_TIMESTAMP_COMPLETION
+ struct ib_cq *mlx4_ib_create_cq(struct ib_device *ibdev,
+ 				const struct ib_cq_init_attr *attr,
++>>>>>>> 4b664c4355b2 (IB/mlx4: Add support for CQ time-stamping)
  				struct ib_ucontext *context,
  				struct ib_udata *udata)
  {
@@@ -176,6 -180,9 +182,12 @@@
  	int err;
  
  	if (entries < 1 || entries > dev->dev->caps.max_cqes)
++<<<<<<< HEAD
++=======
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	if (attr->flags & ~CQ_CREATE_FLAGS_SUPPORTED)
++>>>>>>> 4b664c4355b2 (IB/mlx4: Add support for CQ time-stamping)
  		return ERR_PTR(-EINVAL);
  
  	cq = kmalloc(sizeof *cq, GFP_KERNEL);
diff --cc drivers/infiniband/hw/mlx4/main.c
index 7be9683a71c1,67979ea1453a..000000000000
--- a/drivers/infiniband/hw/mlx4/main.c
+++ b/drivers/infiniband/hw/mlx4/main.c
@@@ -139,7 -140,27 +139,30 @@@ static int mlx4_ib_query_device(struct 
  	struct ib_smp *out_mad = NULL;
  	int err = -ENOMEM;
  	int have_ib_ports;
+ 	struct mlx4_uverbs_ex_query_device cmd;
+ 	struct mlx4_uverbs_ex_query_device_resp resp = {.comp_mask = 0};
+ 	struct mlx4_clock_params clock_params;
+ 
++<<<<<<< HEAD
++=======
+ 	if (uhw->inlen) {
+ 		if (uhw->inlen < sizeof(cmd))
+ 			return -EINVAL;
+ 
+ 		err = ib_copy_from_udata(&cmd, uhw, sizeof(cmd));
+ 		if (err)
+ 			return err;
+ 
+ 		if (cmd.comp_mask)
+ 			return -EINVAL;
  
+ 		if (cmd.reserved)
+ 			return -EINVAL;
+ 	}
+ 
+ 	resp.response_length = offsetof(typeof(resp), response_length) +
+ 		sizeof(resp.response_length);
++>>>>>>> 4b664c4355b2 (IB/mlx4: Add support for CQ time-stamping)
  	in_mad  = kzalloc(sizeof *in_mad, GFP_KERNEL);
  	out_mad = kmalloc(sizeof *out_mad, GFP_KERNEL);
  	if (!in_mad || !out_mad)
* Unmerged path drivers/infiniband/hw/mlx4/cq.c
* Unmerged path drivers/infiniband/hw/mlx4/main.c
diff --git a/drivers/infiniband/hw/mlx4/mlx4_ib.h b/drivers/infiniband/hw/mlx4/mlx4_ib.h
index 33d239140fff..66809327a339 100644
--- a/drivers/infiniband/hw/mlx4/mlx4_ib.h
+++ b/drivers/infiniband/hw/mlx4/mlx4_ib.h
@@ -110,6 +110,7 @@ struct mlx4_ib_cq {
 	struct mutex		resize_mutex;
 	struct ib_umem	       *umem;
 	struct ib_umem	       *resize_umem;
+	int			create_flags;
 	/* List of qps that it serves.*/
 	struct list_head		send_qp_list;
 	struct list_head		recv_qp_list;
@@ -553,6 +554,21 @@ struct mlx4_ib_qp_tunnel_init_attr {
 	u8 port;
 };
 
+struct mlx4_uverbs_ex_query_device {
+	__u32 comp_mask;
+	__u32 reserved;
+};
+
+enum query_device_resp_mask {
+	QUERY_DEVICE_RESP_MASK_TIMESTAMP = 1UL << 0,
+};
+
+struct mlx4_uverbs_ex_query_device_resp {
+	__u32 comp_mask;
+	__u32 response_length;
+	__u64 hca_core_clock_offset;
+};
+
 static inline struct mlx4_ib_dev *to_mdev(struct ib_device *ibdev)
 {
 	return container_of(ibdev, struct mlx4_ib_dev, ib_dev);
