ALSA: line6: Fix racy loopback handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] line6: Fix racy loopback handling (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 91.67%
commit-author Takashi Iwai <tiwai@suse.de>
commit 3d3ae4454deb94bbad9ad0b2b559cbf6c0db4ec2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3d3ae445.failed

The impulse and monitor handling in submit_audio_out_urb() isn't
protected thus this can be racy with the capture stream handling.
This patch extends the range to protect via each stream's spinlock
(now the whole submit_audio_*_urb() are covered), and take the capture
stream lock additionally for the impulse and monitor handling part.

	Tested-by: Chris Rorvick <chris@rorvick.com>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 3d3ae4454deb94bbad9ad0b2b559cbf6c0db4ec2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/staging/line6/capture.c
#	drivers/staging/line6/playback.c
diff --cc drivers/staging/line6/capture.c
index 7ed8560f3c0a,21342a9dddd7..000000000000
--- a/drivers/staging/line6/capture.c
+++ b/drivers/staging/line6/capture.c
@@@ -31,12 -29,10 +31,18 @@@ static int submit_audio_in_urb(struct s
  	int ret;
  	struct urb *urb_in;
  
++<<<<<<< HEAD:drivers/staging/line6/capture.c
 +	spin_lock_irqsave(&line6pcm->lock_audio_in, flags);
++=======
++>>>>>>> 3d3ae4454deb (ALSA: line6: Fix racy loopback handling):sound/usb/line6/capture.c
  	index =
 -	    find_first_zero_bit(&line6pcm->in.active_urbs, LINE6_ISO_BUFFERS);
 +	    find_first_zero_bit(&line6pcm->active_urb_in, LINE6_ISO_BUFFERS);
  
  	if (index < 0 || index >= LINE6_ISO_BUFFERS) {
++<<<<<<< HEAD:drivers/staging/line6/capture.c
 +		spin_unlock_irqrestore(&line6pcm->lock_audio_in, flags);
++=======
++>>>>>>> 3d3ae4454deb (ALSA: line6: Fix racy loopback handling):sound/usb/line6/capture.c
  		dev_err(line6pcm->line6->ifcdev, "no free URB found\n");
  		return -EINVAL;
  	}
@@@ -66,7 -62,6 +72,10 @@@
  		dev_err(line6pcm->line6->ifcdev,
  			"URB in #%d submission failed (%d)\n", index, ret);
  
++<<<<<<< HEAD:drivers/staging/line6/capture.c
 +	spin_unlock_irqrestore(&line6pcm->lock_audio_in, flags);
++=======
++>>>>>>> 3d3ae4454deb (ALSA: line6: Fix racy loopback handling):sound/usb/line6/capture.c
  	return 0;
  }
  
@@@ -80,63 -77,13 +91,64 @@@ int line6_submit_audio_in_all_urbs(stru
  	for (i = 0; i < LINE6_ISO_BUFFERS; ++i) {
  		ret = submit_audio_in_urb(line6pcm);
  		if (ret < 0)
- 			return ret;
+ 			break;
  	}
  
- 	return 0;
+ 	spin_unlock_irqrestore(&line6pcm->in.lock, flags);
+ 	return ret;
  }
  
 +/*
 +	Unlink all currently active capture URBs.
 +*/
 +void line6_unlink_audio_in_urbs(struct snd_line6_pcm *line6pcm)
 +{
 +	unsigned int i;
 +
 +	for (i = LINE6_ISO_BUFFERS; i--;) {
 +		if (test_bit(i, &line6pcm->active_urb_in)) {
 +			if (!test_and_set_bit(i, &line6pcm->unlink_urb_in)) {
 +				struct urb *u = line6pcm->urb_audio_in[i];
 +				usb_unlink_urb(u);
 +			}
 +		}
 +	}
 +}
 +
 +/*
 +	Wait until unlinking of all currently active capture URBs has been
 +	finished.
 +*/
 +void line6_wait_clear_audio_in_urbs(struct snd_line6_pcm *line6pcm)
 +{
 +	int timeout = HZ;
 +	unsigned int i;
 +	int alive;
 +
 +	do {
 +		alive = 0;
 +		for (i = LINE6_ISO_BUFFERS; i--;) {
 +			if (test_bit(i, &line6pcm->active_urb_in))
 +				alive++;
 +		}
 +		if (!alive)
 +			break;
 +		set_current_state(TASK_UNINTERRUPTIBLE);
 +		schedule_timeout(1);
 +	} while (--timeout > 0);
 +	if (alive)
 +		snd_printk(KERN_ERR "timeout: still %d active urbs..\n", alive);
 +}
 +
 +/*
 +	Unlink all currently active capture URBs, and wait for finishing.
 +*/
 +void line6_unlink_wait_clear_audio_in_urbs(struct snd_line6_pcm *line6pcm)
 +{
 +	line6_unlink_audio_in_urbs(line6pcm);
 +	line6_wait_clear_audio_in_urbs(line6pcm);
 +}
 +
  /*
  	Copy data into ALSA capture buffer.
  */
@@@ -186,10 -134,12 +198,18 @@@ void line6_capture_check_period(struct 
  	struct snd_pcm_substream *substream =
  	    get_substream(line6pcm, SNDRV_PCM_STREAM_CAPTURE);
  
++<<<<<<< HEAD:drivers/staging/line6/capture.c
 +	line6pcm->bytes_in += length;
 +	if (line6pcm->bytes_in >= line6pcm->period_in) {
 +		line6pcm->bytes_in %= line6pcm->period_in;
++=======
+ 	line6pcm->in.bytes += length;
+ 	if (line6pcm->in.bytes >= line6pcm->in.period) {
+ 		line6pcm->in.bytes %= line6pcm->in.period;
+ 		spin_unlock(&line6pcm->in.lock);
++>>>>>>> 3d3ae4454deb (ALSA: line6: Fix racy loopback handling):sound/usb/line6/capture.c
  		snd_pcm_period_elapsed(substream);
+ 		spin_lock(&line6pcm->in.lock);
  	}
  }
  
@@@ -251,13 -193,11 +271,16 @@@ static void audio_in_callback(struct ur
  				line6_capture_copy(line6pcm, fbuf, fsize);
  	}
  
 -	clear_bit(index, &line6pcm->in.active_urbs);
 +	clear_bit(index, &line6pcm->active_urb_in);
  
 -	if (test_and_clear_bit(index, &line6pcm->in.unlink_urbs))
 +	if (test_and_clear_bit(index, &line6pcm->unlink_urb_in))
  		shutdown = 1;
  
++<<<<<<< HEAD:drivers/staging/line6/capture.c
 +	spin_unlock_irqrestore(&line6pcm->lock_audio_in, flags);
 +
++=======
++>>>>>>> 3d3ae4454deb (ALSA: line6: Fix racy loopback handling):sound/usb/line6/capture.c
  	if (!shutdown) {
  		submit_audio_in_urb(line6pcm);
  
diff --cc drivers/staging/line6/playback.c
index f97584b88a0d,b4a26d0c8267..000000000000
--- a/drivers/staging/line6/playback.c
+++ b/drivers/staging/line6/playback.c
@@@ -151,12 -149,10 +151,18 @@@ static int submit_audio_out_urb(struct 
  	    (USB_INTERVALS_PER_SECOND / LINE6_ISO_INTERVAL);
  	struct urb *urb_out;
  
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +	spin_lock_irqsave(&line6pcm->lock_audio_out, flags);
++=======
++>>>>>>> 3d3ae4454deb (ALSA: line6: Fix racy loopback handling):sound/usb/line6/playback.c
  	index =
 -	    find_first_zero_bit(&line6pcm->out.active_urbs, LINE6_ISO_BUFFERS);
 +	    find_first_zero_bit(&line6pcm->active_urb_out, LINE6_ISO_BUFFERS);
  
  	if (index < 0 || index >= LINE6_ISO_BUFFERS) {
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +		spin_unlock_irqrestore(&line6pcm->lock_audio_out, flags);
++=======
++>>>>>>> 3d3ae4454deb (ALSA: line6: Fix racy loopback handling):sound/usb/line6/playback.c
  		dev_err(line6pcm->line6->ifcdev, "no free URB found\n");
  		return -EINVAL;
  	}
@@@ -188,7 -185,6 +194,10 @@@
  
  	if (urb_size == 0) {
  		/* can't determine URB size */
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +		spin_unlock_irqrestore(&line6pcm->lock_audio_out, flags);
++=======
++>>>>>>> 3d3ae4454deb (ALSA: line6: Fix racy loopback handling):sound/usb/line6/playback.c
  		dev_err(line6pcm->line6->ifcdev, "driver bug: urb_size = 0\n");
  		return -EINVAL;
  	}
@@@ -239,10 -239,8 +248,15 @@@
  		       urb_out->transfer_buffer_length);
  	}
  
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +	change_volume(urb_out, line6pcm->volume_playback, bytes_per_frame);
 +
 +	if (line6pcm->prev_fbuf != NULL) {
 +#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
++=======
+ 	spin_lock_nested(&line6pcm->in.lock, SINGLE_DEPTH_NESTING);
+ 	if (line6pcm->prev_fbuf) {
++>>>>>>> 3d3ae4454deb (ALSA: line6: Fix racy loopback handling):sound/usb/line6/playback.c
  		if (line6pcm->flags & LINE6_BITS_PCM_IMPULSE) {
  			create_impulse_test_signal(line6pcm, urb_out,
  						   bytes_per_frame);
@@@ -264,10 -262,9 +278,11 @@@
  				add_monitor_signal(urb_out, line6pcm->prev_fbuf,
  						   line6pcm->volume_monitor,
  						   bytes_per_frame);
 +#ifdef CONFIG_LINE6_USB_IMPULSE_RESPONSE
  		}
 +#endif
  	}
+ 	spin_unlock(&line6pcm->in.lock);
  
  	ret = usb_submit_urb(urb_out, GFP_ATOMIC);
  
@@@ -277,7 -274,6 +292,10 @@@
  		dev_err(line6pcm->line6->ifcdev,
  			"URB out #%d submission failed (%d)\n", index, ret);
  
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +	spin_unlock_irqrestore(&line6pcm->lock_audio_out, flags);
++=======
++>>>>>>> 3d3ae4454deb (ALSA: line6: Fix racy loopback handling):sound/usb/line6/playback.c
  	return 0;
  }
  
@@@ -291,69 -289,13 +311,70 @@@ int line6_submit_audio_out_all_urbs(str
  	for (i = 0; i < LINE6_ISO_BUFFERS; ++i) {
  		ret = submit_audio_out_urb(line6pcm);
  		if (ret < 0)
- 			return ret;
+ 			break;
  	}
  
- 	return 0;
+ 	spin_unlock_irqrestore(&line6pcm->out.lock, flags);
+ 	return ret;
  }
  
 +/*
 +	Unlink all currently active playback URBs.
 +*/
 +void line6_unlink_audio_out_urbs(struct snd_line6_pcm *line6pcm)
 +{
 +	unsigned int i;
 +
 +	for (i = LINE6_ISO_BUFFERS; i--;) {
 +		if (test_bit(i, &line6pcm->active_urb_out)) {
 +			if (!test_and_set_bit(i, &line6pcm->unlink_urb_out)) {
 +				struct urb *u = line6pcm->urb_audio_out[i];
 +				usb_unlink_urb(u);
 +			}
 +		}
 +	}
 +}
 +
 +/*
 +	Wait until unlinking of all currently active playback URBs has been
 +	finished.
 +*/
 +void line6_wait_clear_audio_out_urbs(struct snd_line6_pcm *line6pcm)
 +{
 +	int timeout = HZ;
 +	unsigned int i;
 +	int alive;
 +
 +	do {
 +		alive = 0;
 +		for (i = LINE6_ISO_BUFFERS; i--;) {
 +			if (test_bit(i, &line6pcm->active_urb_out))
 +				alive++;
 +		}
 +		if (!alive)
 +			break;
 +		set_current_state(TASK_UNINTERRUPTIBLE);
 +		schedule_timeout(1);
 +	} while (--timeout > 0);
 +	if (alive)
 +		snd_printk(KERN_ERR "timeout: still %d active urbs..\n", alive);
 +}
 +
 +/*
 +	Unlink all currently active playback URBs, and wait for finishing.
 +*/
 +void line6_unlink_wait_clear_audio_out_urbs(struct snd_line6_pcm *line6pcm)
 +{
 +	line6_unlink_audio_out_urbs(line6pcm);
 +	line6_wait_clear_audio_out_urbs(line6pcm);
 +}
 +
 +void line6_free_playback_buffer(struct snd_line6_pcm *line6pcm)
 +{
 +	kfree(line6pcm->buffer_out);
 +	line6pcm->buffer_out = NULL;
 +}
 +
  /*
  	Callback for completed playback URB.
  */
@@@ -402,20 -344,20 +423,31 @@@ static void audio_out_callback(struct u
  			break;
  		}
  
 -	if (test_and_clear_bit(index, &line6pcm->out.unlink_urbs))
 +	if (test_and_clear_bit(index, &line6pcm->unlink_urb_out))
  		shutdown = 1;
  
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +	spin_unlock_irqrestore(&line6pcm->lock_audio_out, flags);
 +
++=======
++>>>>>>> 3d3ae4454deb (ALSA: line6: Fix racy loopback handling):sound/usb/line6/playback.c
  	if (!shutdown) {
  		submit_audio_out_urb(line6pcm);
  
  		if (test_bit(LINE6_INDEX_PCM_ALSA_PLAYBACK_STREAM,
  			     &line6pcm->flags)) {
++<<<<<<< HEAD:drivers/staging/line6/playback.c
 +			line6pcm->bytes_out += length;
 +			if (line6pcm->bytes_out >= line6pcm->period_out) {
 +				line6pcm->bytes_out %= line6pcm->period_out;
++=======
+ 			line6pcm->out.bytes += length;
+ 			if (line6pcm->out.bytes >= line6pcm->out.period) {
+ 				line6pcm->out.bytes %= line6pcm->out.period;
+ 				spin_unlock(&line6pcm->out.lock);
++>>>>>>> 3d3ae4454deb (ALSA: line6: Fix racy loopback handling):sound/usb/line6/playback.c
  				snd_pcm_period_elapsed(substream);
+ 				spin_lock(&line6pcm->out.lock);
  			}
  		}
  	}
* Unmerged path drivers/staging/line6/capture.c
* Unmerged path drivers/staging/line6/playback.c
