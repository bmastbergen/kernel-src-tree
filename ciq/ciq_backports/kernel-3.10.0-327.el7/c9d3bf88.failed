NVMe: Start and stop h/w queues on reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Keith Busch <keith.busch@intel.com>
commit c9d3bf8810514b1d32b49254a8f3485f36380eed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c9d3bf88.failed

This freezes and stops all the queues on device shutdown and restarts
them on resume. This fixes hotplug and reset issues when the controller
is actively being used.

	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit c9d3bf8810514b1d32b49254a8f3485f36380eed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index 48e1152870d9,ff4ff0999f02..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -466,32 -424,38 +466,44 @@@ static void bio_completion(struct nvme_
  						struct nvme_completion *cqe)
  {
  	struct nvme_iod *iod = ctx;
 -	struct request *req = iod->private;
 -	struct nvme_cmd_info *cmd_rq = blk_mq_rq_to_pdu(req);
 -
 +	struct bio *bio = iod->private;
  	u16 status = le16_to_cpup(&cqe->status) >> 1;
 +	int error = 0;
  
  	if (unlikely(status)) {
++<<<<<<< HEAD
 +		if (!(status & NVME_SC_DNR ||
 +				bio->bi_rw & REQ_FAILFAST_MASK) &&
 +				(jiffies - iod->start_time) < IOD_TIMEOUT) {
 +			if (!waitqueue_active(&nvmeq->sq_full))
 +				add_wait_queue(&nvmeq->sq_full,
 +							&nvmeq->sq_cong_wait);
 +			list_add_tail(&iod->node, &nvmeq->iod_bio);
 +			wake_up(&nvmeq->sq_full);
++=======
+ 		if (!(status & NVME_SC_DNR || blk_noretry_request(req))
+ 		    && (jiffies - req->start_time) < req->timeout) {
+ 			unsigned long flags;
+ 
+ 			blk_mq_requeue_request(req);
+ 			spin_lock_irqsave(req->q->queue_lock, flags);
+ 			if (!blk_queue_stopped(req->q))
+ 				blk_mq_kick_requeue_list(req->q);
+ 			spin_unlock_irqrestore(req->q->queue_lock, flags);
++>>>>>>> c9d3bf881051 (NVMe: Start and stop h/w queues on reset)
  			return;
  		}
 -		req->errors = nvme_error_status(status);
 -	} else
 -		req->errors = 0;
 -
 -	if (cmd_rq->aborted)
 -		dev_warn(&nvmeq->dev->pci_dev->dev,
 -			"completing aborted command with status:%04x\n",
 -			status);
 -
 -	if (iod->nents)
 -		dma_unmap_sg(&nvmeq->dev->pci_dev->dev, iod->sg, iod->nents,
 -			rq_data_dir(req) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 +		error = nvme_error_status(status);
 +	}
 +	if (iod->nents) {
 +		dma_unmap_sg(nvmeq->q_dmadev, iod->sg, iod->nents,
 +			bio_data_dir(bio) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 +		nvme_end_io_acct(bio, iod->start_time);
 +	}
  	nvme_free_iod(nvmeq->dev, iod);
  
 -	blk_mq_complete_request(req);
 +	trace_block_bio_complete(bdev_get_queue(bio->bi_bdev), bio, error);
 +	bio_endio(bio, error);
  }
  
  /* length is in bytes.  gfp flags indicates whether we may sleep. */
@@@ -2708,11 -2446,13 +2748,13 @@@ static void nvme_dev_shutdown(struct nv
  	dev->initialized = 0;
  	nvme_dev_list_remove(dev);
  
- 	if (dev->bar)
+ 	if (dev->bar) {
+ 		nvme_freeze_queues(dev);
  		csts = readl(&dev->bar->csts);
+ 	}
  	if (csts & NVME_CSTS_CFS || !(csts & NVME_CSTS_RDY)) {
  		for (i = dev->queue_count - 1; i >= 0; i--) {
 -			struct nvme_queue *nvmeq = dev->queues[i];
 +			struct nvme_queue *nvmeq = raw_nvmeq(dev, i);
  			nvme_suspend_queue(nvmeq);
  			nvme_clear_queue(nvmeq);
  		}
@@@ -2929,9 -2702,12 +2971,12 @@@ static int nvme_dev_resume(struct nvme_
  		return ret;
  	if (dev->online_queues < 2) {
  		spin_lock(&dev_list_lock);
 -		dev->reset_workfn = nvme_remove_disks;
 +		PREPARE_WORK(&dev->reset_work, nvme_remove_disks);
  		queue_work(nvme_workq, &dev->reset_work);
  		spin_unlock(&dev_list_lock);
+ 	} else {
+ 		nvme_unfreeze_queues(dev);
+ 		nvme_set_irq_hints(dev);
  	}
  	dev->initialized = 1;
  	return 0;
@@@ -3059,12 -2844,11 +3104,17 @@@ static void nvme_remove(struct pci_dev 
  
  	pci_set_drvdata(pdev, NULL);
  	flush_work(&dev->reset_work);
 +	flush_work(&dev->cpu_work);
  	misc_deregister(&dev->miscdev);
  	nvme_dev_shutdown(dev);
++<<<<<<< HEAD
++=======
+ 	nvme_dev_remove(dev);
+ 	nvme_dev_remove_admin(dev);
++>>>>>>> c9d3bf881051 (NVMe: Start and stop h/w queues on reset)
  	nvme_free_queues(dev, 0);
 +	nvme_dev_remove(dev);
 +	nvme_release_instance(dev);
  	nvme_release_prp_pools(dev);
  	kref_put(&dev->kref, nvme_free_dev);
  }
* Unmerged path drivers/block/nvme-core.c
