context_tracking: Export context_tracking_user_enter/exit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Rik van Riel <riel@redhat.com>
commit efc1e2c9bcbab73797d7bc214014cb916d6a8eb5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/efc1e2c9.failed

Export context_tracking_user_enter/exit so it can be used by KVM.

	Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Signed-off-by: Rik van Riel <riel@redhat.com>
	Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Will deacon <will.deacon@arm.com>
	Cc: Marcelo Tosatti <mtosatti@redhat.com>
	Cc: Christian Borntraeger <borntraeger@de.ibm.com>
	Cc: Luiz Capitulino <lcapitulino@redhat.com>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
(cherry picked from commit efc1e2c9bcbab73797d7bc214014cb916d6a8eb5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/context_tracking.c
diff --cc kernel/context_tracking.c
index 5baa7b9cfb32,72d59a1a6eb6..000000000000
--- a/kernel/context_tracking.c
+++ b/kernel/context_tracking.c
@@@ -106,54 -107,23 +106,59 @@@ void context_tracking_user_enter(void
  	}
  	local_irq_restore(flags);
  }
++<<<<<<< HEAD
++=======
+ NOKPROBE_SYMBOL(context_tracking_enter);
+ EXPORT_SYMBOL_GPL(context_tracking_enter);
++>>>>>>> efc1e2c9bcba (context_tracking: Export context_tracking_user_enter/exit)
  
 -void context_tracking_user_enter(void)
 +#ifdef CONFIG_PREEMPT
 +/**
 + * preempt_schedule_context - preempt_schedule called by tracing
 + *
 + * The tracing infrastructure uses preempt_enable_notrace to prevent
 + * recursion and tracing preempt enabling caused by the tracing
 + * infrastructure itself. But as tracing can happen in areas coming
 + * from userspace or just about to enter userspace, a preempt enable
 + * can occur before user_exit() is called. This will cause the scheduler
 + * to be called when the system is still in usermode.
 + *
 + * To prevent this, the preempt_enable_notrace will use this function
 + * instead of preempt_schedule() to exit user context if needed before
 + * calling the scheduler.
 + */
 +void __sched notrace preempt_schedule_context(void)
  {
 -	context_tracking_enter(CONTEXT_USER);
 +	enum ctx_state prev_ctx;
 +
 +	if (likely(!preemptible()))
 +		return;
 +
 +	/*
 +	 * Need to disable preemption in case user_exit() is traced
 +	 * and the tracer calls preempt_enable_notrace() causing
 +	 * an infinite recursion.
 +	 */
 +	preempt_disable_notrace();
 +	prev_ctx = exception_enter();
 +	preempt_enable_no_resched_notrace();
 +
 +	preempt_schedule();
 +
 +	preempt_disable_notrace();
 +	exception_exit(prev_ctx);
 +	preempt_enable_notrace();
  }
 -NOKPROBE_SYMBOL(context_tracking_user_enter);
 +EXPORT_SYMBOL_GPL(preempt_schedule_context);
 +#endif /* CONFIG_PREEMPT */
  
  /**
 - * context_tracking_exit - Inform the context tracking that the CPU is
 - *                         exiting user or guest mode and entering the kernel.
 + * context_tracking_user_exit - Inform the context tracking that the CPU is
 + *                              exiting userspace mode and entering the kernel.
   *
 - * This function must be called after we entered the kernel from user or
 - * guest space before any use of RCU read side critical section. This
 - * potentially include any high level kernel code like syscalls, exceptions,
 - * signal handling, etc...
 + * This function must be called after we entered the kernel from userspace
 + * before any use of RCU read side critical section. This potentially include
 + * any high level kernel code like syscalls, exceptions, signal handling, etc...
   *
   * This call supports re-entrancy. This way it can be called from any exception
   * handler without needing to know if we came from userspace or not.
@@@ -185,6 -155,14 +190,17 @@@ void context_tracking_user_exit(void
  	}
  	local_irq_restore(flags);
  }
++<<<<<<< HEAD
++=======
+ NOKPROBE_SYMBOL(context_tracking_exit);
+ EXPORT_SYMBOL_GPL(context_tracking_exit);
+ 
+ void context_tracking_user_exit(void)
+ {
+ 	context_tracking_exit(CONTEXT_USER);
+ }
+ NOKPROBE_SYMBOL(context_tracking_user_exit);
++>>>>>>> efc1e2c9bcba (context_tracking: Export context_tracking_user_enter/exit)
  
  /**
   * __context_tracking_task_switch - context switch the syscall callbacks
* Unmerged path kernel/context_tracking.c
