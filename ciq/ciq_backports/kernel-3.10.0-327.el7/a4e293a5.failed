ixgbe: add link check for X550 copper

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Don Skidmore <donald.c.skidmore@intel.com>
commit a4e293a5bfaf18a94c3421f3a424939ce3524ccd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a4e293a5.failed

This patch adds ixgbe_check_link_t_X550em for checking copper PHY
link.  We check that both the MAC and external PHY have link. This
is to avoid a false link up between the internal and external PHY
when  the external PHY doesn't have link.

	Signed-off-by: Don Skidmore <donald.c.skidmore@intel.com>
	Tested-by: Krishneil Singh <krishneil.k.singh@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit a4e293a5bfaf18a94c3421f3a424939ce3524ccd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
index b0f0c518df36,dc320af618af..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
@@@ -941,6 -877,417 +941,420 @@@ static s32 ixgbe_setup_ixfi_x550em(stru
  	return status;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * ixgbe_setup_mac_link_t_X550em - Sets the auto advertised link speed
+  * @hw: pointer to hardware structure
+  * @speed: new link speed
+  * @autoneg_wait_to_complete: true when waiting for completion is needed
+  *
+  * Setup internal/external PHY link speed based on link speed, then set
+  * external PHY auto advertised link speed.
+  *
+  * Returns error status for any failure
+  **/
+ static s32 ixgbe_setup_mac_link_t_X550em(struct ixgbe_hw *hw,
+ 					 ixgbe_link_speed speed,
+ 					 bool autoneg_wait)
+ {
+ 	s32 status;
+ 	ixgbe_link_speed force_speed;
+ 
+ 	/* Setup internal/external PHY link speed to iXFI (10G), unless
+ 	 * only 1G is auto advertised then setup KX link.
+ 	 */
+ 	if (speed & IXGBE_LINK_SPEED_10GB_FULL)
+ 		force_speed = IXGBE_LINK_SPEED_10GB_FULL;
+ 	else
+ 		force_speed = IXGBE_LINK_SPEED_1GB_FULL;
+ 
+ 	/* If internal link mode is XFI, then setup XFI internal link. */
+ 	if (!(hw->phy.nw_mng_if_sel & IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE)) {
+ 		status = ixgbe_setup_ixfi_x550em(hw, &force_speed);
+ 
+ 		if (status)
+ 			return status;
+ 	}
+ 
+ 	return hw->phy.ops.setup_link_speed(hw, speed, autoneg_wait);
+ }
+ 
+ /** ixgbe_check_link_t_X550em - Determine link and speed status
+   * @hw: pointer to hardware structure
+   * @speed: pointer to link speed
+   * @link_up: true when link is up
+   * @link_up_wait_to_complete: bool used to wait for link up or not
+   *
+   * Check that both the MAC and X557 external PHY have link.
+   **/
+ static s32 ixgbe_check_link_t_X550em(struct ixgbe_hw *hw,
+ 				     ixgbe_link_speed *speed,
+ 				     bool *link_up,
+ 				     bool link_up_wait_to_complete)
+ {
+ 	u32 status;
+ 	u16 autoneg_status;
+ 
+ 	if (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_copper)
+ 		return IXGBE_ERR_CONFIG;
+ 
+ 	status = ixgbe_check_mac_link_generic(hw, speed, link_up,
+ 					      link_up_wait_to_complete);
+ 
+ 	/* If check link fails or MAC link is not up, then return */
+ 	if (status || !(*link_up))
+ 		return status;
+ 
+ 	 /* MAC link is up, so check external PHY link.
+ 	  * Read this twice back to back to indicate current status.
+ 	  */
+ 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_STATUS,
+ 				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+ 				      &autoneg_status);
+ 	if (status)
+ 		return status;
+ 
+ 	/* If external PHY link is not up, then indicate link not up */
+ 	if (!(autoneg_status & IXGBE_MDIO_AUTO_NEG_LINK_STATUS))
+ 		*link_up = false;
+ 
+ 	return 0;
+ }
+ 
+ /** ixgbe_init_mac_link_ops_X550em - init mac link function pointers
+  *  @hw: pointer to hardware structure
+  **/
+ static void ixgbe_init_mac_link_ops_X550em(struct ixgbe_hw *hw)
+ {
+ 	struct ixgbe_mac_info *mac = &hw->mac;
+ 
+ 	switch (mac->ops.get_media_type(hw)) {
+ 	case ixgbe_media_type_fiber:
+ 		/* CS4227 does not support autoneg, so disable the laser control
+ 		 * functions for SFP+ fiber
+ 		 */
+ 		mac->ops.disable_tx_laser = NULL;
+ 		mac->ops.enable_tx_laser = NULL;
+ 		mac->ops.flap_tx_laser = NULL;
+ 		break;
+ 	case ixgbe_media_type_copper:
+ 		mac->ops.setup_link = ixgbe_setup_mac_link_t_X550em;
+ 		mac->ops.check_link = ixgbe_check_link_t_X550em;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ /** ixgbe_setup_sfp_modules_X550em - Setup SFP module
+  * @hw: pointer to hardware structure
+  */
+ static s32 ixgbe_setup_sfp_modules_X550em(struct ixgbe_hw *hw)
+ {
+ 	bool setup_linear;
+ 	u16 reg_slice, edc_mode;
+ 	s32 ret_val;
+ 
+ 	switch (hw->phy.sfp_type) {
+ 	case ixgbe_sfp_type_unknown:
+ 		return 0;
+ 	case ixgbe_sfp_type_not_present:
+ 		return IXGBE_ERR_SFP_NOT_PRESENT;
+ 	case ixgbe_sfp_type_da_cu_core0:
+ 	case ixgbe_sfp_type_da_cu_core1:
+ 		setup_linear = true;
+ 		break;
+ 	case ixgbe_sfp_type_srlr_core0:
+ 	case ixgbe_sfp_type_srlr_core1:
+ 	case ixgbe_sfp_type_da_act_lmt_core0:
+ 	case ixgbe_sfp_type_da_act_lmt_core1:
+ 	case ixgbe_sfp_type_1g_sx_core0:
+ 	case ixgbe_sfp_type_1g_sx_core1:
+ 		setup_linear = false;
+ 		break;
+ 	default:
+ 		return IXGBE_ERR_SFP_NOT_SUPPORTED;
+ 	}
+ 
+ 	ixgbe_init_mac_link_ops_X550em(hw);
+ 	hw->phy.ops.reset = NULL;
+ 
+ 	/* The CS4227 slice address is the base address + the port-pair reg
+ 	 * offset. I.e. Slice 0 = 0x12B0 and slice 1 = 0x22B0.
+ 	 */
+ 	reg_slice = IXGBE_CS4227_SPARE24_LSB + (hw->bus.lan_id << 12);
+ 
+ 	if (setup_linear)
+ 		edc_mode = (IXGBE_CS4227_EDC_MODE_CX1 << 1) | 0x1;
+ 	else
+ 		edc_mode = (IXGBE_CS4227_EDC_MODE_SR << 1) | 0x1;
+ 
+ 	/* Configure CS4227 for connection type. */
+ 	ret_val = hw->phy.ops.write_i2c_combined(hw, IXGBE_CS4227, reg_slice,
+ 						 edc_mode);
+ 
+ 	if (ret_val)
+ 		ret_val = hw->phy.ops.write_i2c_combined(hw, 0x80, reg_slice,
+ 							 edc_mode);
+ 
+ 	return ret_val;
+ }
+ 
+ /** ixgbe_get_link_capabilities_x550em - Determines link capabilities
+  * @hw: pointer to hardware structure
+  * @speed: pointer to link speed
+  * @autoneg: true when autoneg or autotry is enabled
+  **/
+ static s32 ixgbe_get_link_capabilities_X550em(struct ixgbe_hw *hw,
+ 					      ixgbe_link_speed *speed,
+ 					      bool *autoneg)
+ {
+ 	/* SFP */
+ 	if (hw->phy.media_type == ixgbe_media_type_fiber) {
+ 		/* CS4227 SFP must not enable auto-negotiation */
+ 		*autoneg = false;
+ 
+ 		if (hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||
+ 		    hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1) {
+ 			*speed = IXGBE_LINK_SPEED_1GB_FULL;
+ 			return 0;
+ 		}
+ 
+ 		/* Link capabilities are based on SFP */
+ 		if (hw->phy.multispeed_fiber)
+ 			*speed = IXGBE_LINK_SPEED_10GB_FULL |
+ 				 IXGBE_LINK_SPEED_1GB_FULL;
+ 		else
+ 			*speed = IXGBE_LINK_SPEED_10GB_FULL;
+ 	} else {
+ 		*speed = IXGBE_LINK_SPEED_10GB_FULL |
+ 			 IXGBE_LINK_SPEED_1GB_FULL;
+ 		*autoneg = true;
+ 	}
+ 	return 0;
+ }
+ 
+ /**
+  * ixgbe_get_lasi_ext_t_x550em - Determime external Base T PHY interrupt cause
+  * @hw: pointer to hardware structure
+  * @lsc: pointer to boolean flag which indicates whether external Base T
+  *	 PHY interrupt is lsc
+  *
+  * Determime if external Base T PHY interrupt cause is high temperature
+  * failure alarm or link status change.
+  *
+  * Return IXGBE_ERR_OVERTEMP if interrupt is high temperature
+  * failure alarm, else return PHY access status.
+  **/
+ static s32 ixgbe_get_lasi_ext_t_x550em(struct ixgbe_hw *hw, bool *lsc)
+ {
+ 	u32 status;
+ 	u16 reg;
+ 
+ 	*lsc = false;
+ 
+ 	/* Vendor alarm triggered */
+ 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_CHIP_STD_INT_FLAG,
+ 				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+ 				      &reg);
+ 
+ 	if (status || !(reg & IXGBE_MDIO_GLOBAL_VEN_ALM_INT_EN))
+ 		return status;
+ 
+ 	/* Vendor Auto-Neg alarm triggered or Global alarm 1 triggered */
+ 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_FLAG,
+ 				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+ 				      &reg);
+ 
+ 	if (status || !(reg & (IXGBE_MDIO_GLOBAL_AN_VEN_ALM_INT_EN |
+ 				IXGBE_MDIO_GLOBAL_ALARM_1_INT)))
+ 		return status;
+ 
+ 	/* High temperature failure alarm triggered */
+ 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_ALARM_1,
+ 				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+ 				      &reg);
+ 
+ 	if (status)
+ 		return status;
+ 
+ 	/* If high temperature failure, then return over temp error and exit */
+ 	if (reg & IXGBE_MDIO_GLOBAL_ALM_1_HI_TMP_FAIL) {
+ 		/* power down the PHY in case the PHY FW didn't already */
+ 		ixgbe_set_copper_phy_power(hw, false);
+ 		return IXGBE_ERR_OVERTEMP;
+ 	}
+ 
+ 	/* Vendor alarm 2 triggered */
+ 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_CHIP_STD_INT_FLAG,
+ 				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &reg);
+ 
+ 	if (status || !(reg & IXGBE_MDIO_GLOBAL_STD_ALM2_INT))
+ 		return status;
+ 
+ 	/* link connect/disconnect event occurred */
+ 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_VENDOR_TX_ALARM2,
+ 				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &reg);
+ 
+ 	if (status)
+ 		return status;
+ 
+ 	/* Indicate LSC */
+ 	if (reg & IXGBE_MDIO_AUTO_NEG_VEN_LSC)
+ 		*lsc = true;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ixgbe_enable_lasi_ext_t_x550em - Enable external Base T PHY interrupts
+  * @hw: pointer to hardware structure
+  *
+  * Enable link status change and temperature failure alarm for the external
+  * Base T PHY
+  *
+  * Returns PHY access status
+  **/
+ static s32 ixgbe_enable_lasi_ext_t_x550em(struct ixgbe_hw *hw)
+ {
+ 	u32 status;
+ 	u16 reg;
+ 	bool lsc;
+ 
+ 	/* Clear interrupt flags */
+ 	status = ixgbe_get_lasi_ext_t_x550em(hw, &lsc);
+ 
+ 	/* Enable link status change alarm */
+ 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK,
+ 				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &reg);
+ 	if (status)
+ 		return status;
+ 
+ 	reg |= IXGBE_MDIO_PMA_TX_VEN_LASI_INT_EN;
+ 
+ 	status = hw->phy.ops.write_reg(hw, IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK,
+ 				       IXGBE_MDIO_AUTO_NEG_DEV_TYPE, reg);
+ 	if (status)
+ 		return status;
+ 
+ 	/* Enables high temperature failure alarm */
+ 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_INT_MASK,
+ 				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+ 				      &reg);
+ 	if (status)
+ 		return status;
+ 
+ 	reg |= IXGBE_MDIO_GLOBAL_INT_HI_TEMP_EN;
+ 
+ 	status = hw->phy.ops.write_reg(hw, IXGBE_MDIO_GLOBAL_INT_MASK,
+ 				       IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+ 				       reg);
+ 	if (status)
+ 		return status;
+ 
+ 	/* Enable vendor Auto-Neg alarm and Global Interrupt Mask 1 alarm */
+ 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_MASK,
+ 				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+ 				      &reg);
+ 	if (status)
+ 		return status;
+ 
+ 	reg |= (IXGBE_MDIO_GLOBAL_AN_VEN_ALM_INT_EN |
+ 		IXGBE_MDIO_GLOBAL_ALARM_1_INT);
+ 
+ 	status = hw->phy.ops.write_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_MASK,
+ 				       IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+ 				       reg);
+ 	if (status)
+ 		return status;
+ 
+ 	/* Enable chip-wide vendor alarm */
+ 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_STD_MASK,
+ 				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+ 				      &reg);
+ 	if (status)
+ 		return status;
+ 
+ 	reg |= IXGBE_MDIO_GLOBAL_VEN_ALM_INT_EN;
+ 
+ 	status = hw->phy.ops.write_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_STD_MASK,
+ 				       IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+ 				       reg);
+ 
+ 	return status;
+ }
+ 
+ /**
+  * ixgbe_handle_lasi_ext_t_x550em - Handle external Base T PHY interrupt
+  * @hw: pointer to hardware structure
+  *
+  * Handle external Base T PHY interrupt. If high temperature
+  * failure alarm then return error, else if link status change
+  * then setup internal/external PHY link
+  *
+  * Return IXGBE_ERR_OVERTEMP if interrupt is high temperature
+  * failure alarm, else return PHY access status.
+  **/
+ static s32 ixgbe_handle_lasi_ext_t_x550em(struct ixgbe_hw *hw)
+ {
+ 	struct ixgbe_phy_info *phy = &hw->phy;
+ 	bool lsc;
+ 	u32 status;
+ 
+ 	status = ixgbe_get_lasi_ext_t_x550em(hw, &lsc);
+ 	if (status)
+ 		return status;
+ 
+ 	if (lsc)
+ 		return phy->ops.setup_internal_link(hw);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ixgbe_setup_kr_speed_x550em - Configure the KR PHY for link speed.
+  * @hw: pointer to hardware structure
+  * @speed: link speed
+  *
+  * Configures the integrated KR PHY.
+  **/
+ static s32 ixgbe_setup_kr_speed_x550em(struct ixgbe_hw *hw,
+ 				       ixgbe_link_speed speed)
+ {
+ 	s32 status;
+ 	u32 reg_val;
+ 
+ 	status = ixgbe_read_iosf_sb_reg_x550(hw,
+ 					IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),
+ 					IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
+ 	if (status)
+ 		return status;
+ 
+ 	reg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE;
+ 	reg_val &= ~(IXGBE_KRM_LINK_CTRL_1_TETH_AN_FEC_REQ |
+ 		     IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_FEC);
+ 	reg_val &= ~(IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KR |
+ 		     IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KX);
+ 
+ 	/* Advertise 10G support. */
+ 	if (speed & IXGBE_LINK_SPEED_10GB_FULL)
+ 		reg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KR;
+ 
+ 	/* Advertise 1G support. */
+ 	if (speed & IXGBE_LINK_SPEED_1GB_FULL)
+ 		reg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KX;
+ 
+ 	/* Restart auto-negotiation. */
+ 	reg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_RESTART;
+ 	status = ixgbe_write_iosf_sb_reg_x550(hw,
+ 					IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),
+ 					IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
+ 
+ 	return status;
+ }
+ 
++>>>>>>> a4e293a5bfaf (ixgbe: add link check for X550 copper)
  /** ixgbe_setup_kx4_x550em - Configure the KX4 PHY.
   *  @hw: pointer to hardware structure
   *
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
