vfio-pci: Fix remove path locking

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Alex Williamson <alex.williamson@redhat.com>
commit 93899a679fd6b2534b5c297d9316bae039ebcbe1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/93899a67.failed

Locking both the remove() and release() path results in a deadlock
that should have been obvious.  To fix this we can get and hold the
vfio_device reference as we evaluate whether to do a bus/slot reset.
This will automatically block any remove() calls, allowing us to
remove the explict lock.  Fixes 61d792562b53.

	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
	Cc: stable@vger.kernel.org	[3.17]
(cherry picked from commit 93899a679fd6b2534b5c297d9316bae039ebcbe1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vfio/pci/vfio_pci.c
diff --cc drivers/vfio/pci/vfio_pci.c
index a22e87f88fa7,9558da3f06a0..000000000000
--- a/drivers/vfio/pci/vfio_pci.c
+++ b/drivers/vfio/pci/vfio_pci.c
@@@ -857,11 -877,10 +857,18 @@@ static void vfio_pci_remove(struct pci_
  	struct vfio_pci_device *vdev;
  
  	vdev = vfio_del_group_dev(&pdev->dev);
++<<<<<<< HEAD
 +	if (!vdev)
 +		return;
 +
 +	iommu_group_put(pdev->dev.iommu_group);
 +	kfree(vdev);
++=======
+ 	if (vdev) {
+ 		iommu_group_put(pdev->dev.iommu_group);
+ 		kfree(vdev);
+ 	}
++>>>>>>> 93899a679fd6 (vfio-pci: Fix remove path locking)
  }
  
  static pci_ers_result_t vfio_pci_aer_err_detected(struct pci_dev *pdev,
@@@ -904,6 -923,92 +911,95 @@@ static struct pci_driver vfio_pci_drive
  	.err_handler	= &vfio_err_handlers,
  };
  
++<<<<<<< HEAD
++=======
+ struct vfio_devices {
+ 	struct vfio_device **devices;
+ 	int cur_index;
+ 	int max_index;
+ };
+ 
+ static int vfio_pci_get_devs(struct pci_dev *pdev, void *data)
+ {
+ 	struct vfio_devices *devs = data;
+ 	struct pci_driver *pci_drv = ACCESS_ONCE(pdev->driver);
+ 
+ 	if (pci_drv != &vfio_pci_driver)
+ 		return -EBUSY;
+ 
+ 	if (devs->cur_index == devs->max_index)
+ 		return -ENOSPC;
+ 
+ 	devs->devices[devs->cur_index] = vfio_device_get_from_dev(&pdev->dev);
+ 	if (!devs->devices[devs->cur_index])
+ 		return -EINVAL;
+ 
+ 	devs->cur_index++;
+ 	return 0;
+ }
+ 
+ /*
+  * Attempt to do a bus/slot reset if there are devices affected by a reset for
+  * this device that are needs_reset and all of the affected devices are unused
+  * (!refcnt).  Callers are required to hold driver_lock when calling this to
+  * prevent device opens and concurrent bus reset attempts.  We prevent device
+  * unbinds by acquiring and holding a reference to the vfio_device.
+  *
+  * NB: vfio-core considers a group to be viable even if some devices are
+  * bound to drivers like pci-stub or pcieport.  Here we require all devices
+  * to be bound to vfio_pci since that's the only way we can be sure they
+  * stay put.
+  */
+ static void vfio_pci_try_bus_reset(struct vfio_pci_device *vdev)
+ {
+ 	struct vfio_devices devs = { .cur_index = 0 };
+ 	int i = 0, ret = -EINVAL;
+ 	bool needs_reset = false, slot = false;
+ 	struct vfio_pci_device *tmp;
+ 
+ 	if (!pci_probe_reset_slot(vdev->pdev->slot))
+ 		slot = true;
+ 	else if (pci_probe_reset_bus(vdev->pdev->bus))
+ 		return;
+ 
+ 	if (vfio_pci_for_each_slot_or_bus(vdev->pdev, vfio_pci_count_devs,
+ 					  &i, slot) || !i)
+ 		return;
+ 
+ 	devs.max_index = i;
+ 	devs.devices = kcalloc(i, sizeof(struct vfio_device *), GFP_KERNEL);
+ 	if (!devs.devices)
+ 		return;
+ 
+ 	if (vfio_pci_for_each_slot_or_bus(vdev->pdev,
+ 					  vfio_pci_get_devs, &devs, slot))
+ 		goto put_devs;
+ 
+ 	for (i = 0; i < devs.cur_index; i++) {
+ 		tmp = vfio_device_data(devs.devices[i]);
+ 		if (tmp->needs_reset)
+ 			needs_reset = true;
+ 		if (tmp->refcnt)
+ 			goto put_devs;
+ 	}
+ 
+ 	if (needs_reset)
+ 		ret = slot ? pci_try_reset_slot(vdev->pdev->slot) :
+ 			     pci_try_reset_bus(vdev->pdev->bus);
+ 
+ put_devs:
+ 	for (i = 0; i < devs.cur_index; i++) {
+ 		if (!ret) {
+ 			tmp = vfio_device_data(devs.devices[i]);
+ 			tmp->needs_reset = false;
+ 		}
+ 		vfio_device_put(devs.devices[i]);
+ 	}
+ 
+ 	kfree(devs.devices);
+ }
+ 
++>>>>>>> 93899a679fd6 (vfio-pci: Fix remove path locking)
  static void __exit vfio_pci_cleanup(void)
  {
  	pci_unregister_driver(&vfio_pci_driver);
* Unmerged path drivers/vfio/pci/vfio_pci.c
