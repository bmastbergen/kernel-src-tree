NVMe: nvme_submit_async_admin_req() must use atomic rq allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Jens Axboe <axboe@fb.com>
commit 6dcc0cf6cb3120cedc0d4c12171894f3d6415981
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6dcc0cf6.failed

We are called for async event notification issues, and the
nvmeq lock is already held. If we fail the request allocation,
we'll just retry next time.

	Reported-by: Julia Lawall <julia.lawall@lip6.fr>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 6dcc0cf6cb3120cedc0d4c12171894f3d6415981)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index dfa7c848f446,fb4b205317c6..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -1054,17 -818,47 +1054,50 @@@ static int nvme_submit_sync_cmd(struct 
  	return cmdinfo.status;
  }
  
 -static int nvme_submit_async_admin_req(struct nvme_dev *dev)
 +int nvme_submit_async_cmd(struct nvme_queue *nvmeq, struct nvme_command *cmd,
 +						struct async_cmd_info *cmdinfo,
 +						unsigned timeout)
  {
 -	struct nvme_queue *nvmeq = dev->queues[0];
 -	struct nvme_command c;
 -	struct nvme_cmd_info *cmd_info;
 -	struct request *req;
 +	int cmdid;
  
++<<<<<<< HEAD
 +	cmdid = alloc_cmdid_killable(nvmeq, cmdinfo, async_completion, timeout);
 +	if (cmdid < 0)
 +		return cmdid;
++=======
+ 	req = blk_mq_alloc_request(dev->admin_q, WRITE, GFP_ATOMIC, false);
+ 	if (IS_ERR(req))
+ 		return PTR_ERR(req);
+ 
+ 	cmd_info = blk_mq_rq_to_pdu(req);
+ 	nvme_set_info(cmd_info, req, async_req_completion);
+ 
+ 	memset(&c, 0, sizeof(c));
+ 	c.common.opcode = nvme_admin_async_event;
+ 	c.common.command_id = req->tag;
+ 
+ 	return __nvme_submit_cmd(nvmeq, &c);
+ }
+ 
+ static int nvme_submit_admin_async_cmd(struct nvme_dev *dev,
+ 			struct nvme_command *cmd,
+ 			struct async_cmd_info *cmdinfo, unsigned timeout)
+ {
+ 	struct nvme_queue *nvmeq = dev->queues[0];
+ 	struct request *req;
+ 	struct nvme_cmd_info *cmd_rq;
+ 
+ 	req = blk_mq_alloc_request(dev->admin_q, WRITE, GFP_KERNEL, false);
+ 	if (IS_ERR(req))
+ 		return PTR_ERR(req);
+ 
+ 	req->timeout = timeout;
+ 	cmd_rq = blk_mq_rq_to_pdu(req);
+ 	cmdinfo->req = req;
+ 	nvme_set_info(cmd_rq, cmdinfo, async_completion);
++>>>>>>> 6dcc0cf6cb31 (NVMe: nvme_submit_async_admin_req() must use atomic rq allocation)
  	cmdinfo->status = -EINTR;
 -
 -	cmd->common.command_id = req->tag;
 -
 +	cmd->common.command_id = cmdid;
  	return nvme_submit_cmd(nvmeq, cmd);
  }
  
* Unmerged path drivers/block/nvme-core.c
