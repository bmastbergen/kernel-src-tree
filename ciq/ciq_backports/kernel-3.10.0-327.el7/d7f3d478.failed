x86, irq: Introduce mechanisms to support dynamically allocate IRQ for IOAPIC

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [x86] irq: Introduce mechanisms to support dynamically allocate IRQ for IOAPIC (Steve Best) [1231358]
Rebuild_FUZZ: 96.64%
commit-author Jiang Liu <jiang.liu@linux.intel.com>
commit d7f3d4781852f5160b939f526afbc21a813a0206
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d7f3d478.failed

Currently x86 support identity mapping between GSI(IOAPIC pin) and IRQ
number, so continous IRQs at low end are statically allocated to IOAPICs
at boot time. This design causes trouble to support IOAPIC hotplug.

This patch implements basic mechanism to dynamically allocate IRQ on
demand for IOAPIC pins by using irqdomain framework.

It first adds several fields into struct ioapic to support irqdomain.
Then it implements an algorithm to dynamically allocate IRQ number
for IOAPIC pins on demand.

Currently it supports three types of irqdomain:
1) LEGACY: used to support IOAPIC hosting legacy IRQs and building
   identity mapping for legacy IRQs. A speical case, we dynamically
   allocate IRQ number for IOAPIC pin which has GSI number below
   nr_legacy_irqs() but isn't legacy IRQ. This is for backward
   compatibility and avoid regression.
2) STRICT: build identity mapping between GSI and IRQ nubmer.
3) DYNAMIC: dynamically allocate IRQ number for IOAPIC pin on demand.

Legacy(ISA) IRQs is not managed by irqdomain because there may be
multiple pins sharing the same IRQ number and current irqdomain only
supports 1:1 mapping between pins and IRQ.

	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Joerg Roedel <joro@8bytes.org>
	Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Grant Likely <grant.likely@linaro.org>
	Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
	Cc: Bjorn Helgaas <bhelgaas@google.com>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Yinghai Lu <yinghai@kernel.org>
	Cc: Len Brown <len.brown@intel.com>
	Cc: Pavel Machek <pavel@ucw.cz>
Link: http://lkml.kernel.org/r/1402302011-23642-24-git-send-email-jiang.liu@linux.intel.com
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
(cherry picked from commit d7f3d4781852f5160b939f526afbc21a813a0206)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/Kconfig
#	arch/x86/include/asm/io_apic.h
#	arch/x86/kernel/acpi/boot.c
#	arch/x86/kernel/apic/io_apic.c
diff --cc arch/x86/Kconfig
index 9069e9f6086e,147a7b788100..000000000000
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@@ -877,11 -834,9 +877,17 @@@ config X86_LOCAL_API
  
  config X86_IO_APIC
  	def_bool y
++<<<<<<< HEAD
 +	depends on X86_64 || SMP || X86_32_NON_STANDARD || X86_UP_IOAPIC
 +
 +config X86_VISWS_APIC
 +	def_bool y
 +	depends on X86_32 && X86_VISWS
++=======
+ 	depends on X86_64 || SMP || X86_32_NON_STANDARD || X86_UP_IOAPIC || PCI_MSI
+ 	select GENERIC_IRQ_LEGACY_ALLOC_HWIRQ
+ 	select IRQ_DOMAIN
++>>>>>>> d7f3d4781852 (x86, irq: Introduce mechanisms to support dynamically allocate IRQ for IOAPIC)
  
  config X86_REROUTE_FOR_BROKEN_BOOT_IRQS
  	bool "Reroute for broken boot IRQs"
diff --cc arch/x86/include/asm/io_apic.h
index 7eb3755fee9a,64c6e344399b..000000000000
--- a/arch/x86/include/asm/io_apic.h
+++ b/arch/x86/include/asm/io_apic.h
@@@ -177,6 -189,7 +194,10 @@@ extern u32 gsi_top
  extern int mp_find_ioapic(u32 gsi);
  extern int mp_find_ioapic_pin(int ioapic, u32 gsi);
  extern u32 mp_pin_to_gsi(int ioapic, int pin);
++<<<<<<< HEAD
++=======
+ extern int mp_map_gsi_to_irq(u32 gsi, unsigned int flags);
++>>>>>>> d7f3d4781852 (x86, irq: Introduce mechanisms to support dynamically allocate IRQ for IOAPIC)
  extern void __init mp_register_ioapic(int id, u32 address, u32 gsi_base);
  extern void __init pre_init_apic_IRQ0(void);
  
@@@ -219,6 -232,7 +240,10 @@@ static inline void ioapic_insert_resour
  #define gsi_top (NR_IRQS_LEGACY)
  static inline int mp_find_ioapic(u32 gsi) { return 0; }
  static inline u32 mp_pin_to_gsi(int ioapic, int pin) { return UINT_MAX; }
++<<<<<<< HEAD
++=======
+ static inline int mp_map_gsi_to_irq(u32 gsi, unsigned int flags) { return gsi; }
++>>>>>>> d7f3d4781852 (x86, irq: Introduce mechanisms to support dynamically allocate IRQ for IOAPIC)
  
  struct io_apic_irq_attr;
  static inline int io_apic_set_pci_routing(struct device *dev, int irq,
diff --cc arch/x86/kernel/acpi/boot.c
index e90087442d73,d6635baf9e3d..000000000000
--- a/arch/x86/kernel/acpi/boot.c
+++ b/arch/x86/kernel/acpi/boot.c
@@@ -102,27 -98,17 +102,37 @@@ static u32 isa_irq_to_gsi[NR_IRQS_LEGAC
  	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
  };
  
++<<<<<<< HEAD
 +static unsigned int gsi_to_irq(unsigned int gsi)
++=======
+ #define	ACPI_INVALID_GSI		INT_MIN
+ 
+ static int map_gsi_to_irq(unsigned int gsi, unsigned int flags)
++>>>>>>> d7f3d4781852 (x86, irq: Introduce mechanisms to support dynamically allocate IRQ for IOAPIC)
  {
 -	int i;
 +	unsigned int irq = gsi + NR_IRQS_LEGACY;
 +	unsigned int i;
  
 -	for (i = 0; i < nr_legacy_irqs(); i++)
 -		if (isa_irq_to_gsi[i] == gsi)
 +	for (i = 0; i < NR_IRQS_LEGACY; i++) {
 +		if (isa_irq_to_gsi[i] == gsi) {
  			return i;
 +		}
 +	}
  
++<<<<<<< HEAD
 +	/* Provide an identity mapping of gsi == irq
 +	 * except on truly weird platforms that have
 +	 * non isa irqs in the first 16 gsis.
 +	 */
 +	if (gsi >= NR_IRQS_LEGACY)
 +		irq = gsi;
 +	else
 +		irq = gsi_top + gsi;
 +
 +	return irq;
++=======
+ 	return mp_map_gsi_to_irq(gsi, flags);
++>>>>>>> d7f3d4781852 (x86, irq: Introduce mechanisms to support dynamically allocate IRQ for IOAPIC)
  }
  
  /*
@@@ -334,6 -320,134 +344,137 @@@ acpi_parse_lapic_nmi(struct acpi_subtab
  #endif				/*CONFIG_X86_LOCAL_APIC */
  
  #ifdef CONFIG_X86_IO_APIC
++<<<<<<< HEAD
++=======
+ #define MP_ISA_BUS		0
+ 
+ static void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger,
+ 					  u32 gsi)
+ {
+ 	int ioapic;
+ 	int pin;
+ 	struct mpc_intsrc mp_irq;
+ 
+ 	/*
+ 	 * Convert 'gsi' to 'ioapic.pin'.
+ 	 */
+ 	ioapic = mp_find_ioapic(gsi);
+ 	if (ioapic < 0)
+ 		return;
+ 	pin = mp_find_ioapic_pin(ioapic, gsi);
+ 
+ 	/*
+ 	 * TBD: This check is for faulty timer entries, where the override
+ 	 *      erroneously sets the trigger to level, resulting in a HUGE
+ 	 *      increase of timer interrupts!
+ 	 */
+ 	if ((bus_irq == 0) && (trigger == 3))
+ 		trigger = 1;
+ 
+ 	mp_irq.type = MP_INTSRC;
+ 	mp_irq.irqtype = mp_INT;
+ 	mp_irq.irqflag = (trigger << 2) | polarity;
+ 	mp_irq.srcbus = MP_ISA_BUS;
+ 	mp_irq.srcbusirq = bus_irq;	/* IRQ */
+ 	mp_irq.dstapic = mpc_ioapic_id(ioapic); /* APIC ID */
+ 	mp_irq.dstirq = pin;	/* INTIN# */
+ 
+ 	mp_save_irq(&mp_irq);
+ 
+ 	/*
+ 	 * Reset default identity mapping if gsi is also an legacy IRQ,
+ 	 * otherwise there will be more than one entry with the same GSI
+ 	 * and acpi_isa_irq_to_gsi() may give wrong result.
+ 	 */
+ 	if (gsi < nr_legacy_irqs() && isa_irq_to_gsi[gsi] == gsi)
+ 		isa_irq_to_gsi[gsi] = ACPI_INVALID_GSI;
+ 	isa_irq_to_gsi[bus_irq] = gsi;
+ }
+ 
+ static int mp_config_acpi_gsi(struct device *dev, u32 gsi, int trigger,
+ 			int polarity)
+ {
+ #ifdef CONFIG_X86_MPPARSE
+ 	struct mpc_intsrc mp_irq;
+ 	struct pci_dev *pdev;
+ 	unsigned char number;
+ 	unsigned int devfn;
+ 	int ioapic;
+ 	u8 pin;
+ 
+ 	if (!acpi_ioapic)
+ 		return 0;
+ 	if (!dev || !dev_is_pci(dev))
+ 		return 0;
+ 
+ 	pdev = to_pci_dev(dev);
+ 	number = pdev->bus->number;
+ 	devfn = pdev->devfn;
+ 	pin = pdev->pin;
+ 	/* print the entry should happen on mptable identically */
+ 	mp_irq.type = MP_INTSRC;
+ 	mp_irq.irqtype = mp_INT;
+ 	mp_irq.irqflag = (trigger == ACPI_EDGE_SENSITIVE ? 4 : 0x0c) |
+ 				(polarity == ACPI_ACTIVE_HIGH ? 1 : 3);
+ 	mp_irq.srcbus = number;
+ 	mp_irq.srcbusirq = (((devfn >> 3) & 0x1f) << 2) | ((pin - 1) & 3);
+ 	ioapic = mp_find_ioapic(gsi);
+ 	mp_irq.dstapic = mpc_ioapic_id(ioapic);
+ 	mp_irq.dstirq = mp_find_ioapic_pin(ioapic, gsi);
+ 
+ 	mp_save_irq(&mp_irq);
+ #endif
+ 	return 0;
+ }
+ 
+ static int mp_register_gsi(struct device *dev, u32 gsi, int trigger,
+ 			   int polarity)
+ {
+ 	int irq;
+ 	int ioapic;
+ 	int ioapic_pin;
+ 	struct io_apic_irq_attr irq_attr;
+ 	int ret;
+ 
+ 	if (acpi_irq_model != ACPI_IRQ_MODEL_IOAPIC)
+ 		return gsi;
+ 
+ 	/* Don't set up the ACPI SCI because it's already set up */
+ 	if (acpi_gbl_FADT.sci_interrupt == gsi)
+ 		return gsi;
+ 
+ 	irq = map_gsi_to_irq(gsi, IOAPIC_MAP_ALLOC);
+ 	if (irq < 0)
+ 		return irq;
+ 
+ 	ioapic = mp_find_ioapic(gsi);
+ 	if (ioapic < 0) {
+ 		printk(KERN_WARNING "No IOAPIC for GSI %u\n", gsi);
+ 		return gsi;
+ 	}
+ 
+ 	ioapic_pin = mp_find_ioapic_pin(ioapic, gsi);
+ 
+ 	if (ioapic_pin > MP_MAX_IOAPIC_PIN) {
+ 		printk(KERN_ERR "Invalid reference to IOAPIC pin "
+ 		       "%d-%d\n", mpc_ioapic_id(ioapic),
+ 		       ioapic_pin);
+ 		return gsi;
+ 	}
+ 
+ 	if (enable_update_mptable)
+ 		mp_config_acpi_gsi(dev, gsi, trigger, polarity);
+ 
+ 	set_io_apic_irq_attr(&irq_attr, ioapic, ioapic_pin,
+ 			     trigger == ACPI_EDGE_SENSITIVE ? 0 : 1,
+ 			     polarity == ACPI_ACTIVE_HIGH ? 0 : 1);
+ 	ret = io_apic_set_pci_routing(dev, irq, &irq_attr);
+ 	if (ret < 0)
+ 		irq = -1;
+ 
+ 	return irq;
+ }
++>>>>>>> d7f3d4781852 (x86, irq: Introduce mechanisms to support dynamically allocate IRQ for IOAPIC)
  
  static int __init
  acpi_parse_ioapic(struct acpi_subtable_header * header, const unsigned long end)
@@@ -492,16 -606,20 +633,20 @@@ void __init acpi_pic_sci_set_trigger(un
  	outb(new >> 8, 0x4d1);
  }
  
 -int acpi_gsi_to_irq(u32 gsi, unsigned int *irqp)
 +int acpi_gsi_to_irq(u32 gsi, unsigned int *irq)
  {
++<<<<<<< HEAD
 +	*irq = gsi_to_irq(gsi);
++=======
+ 	int irq = map_gsi_to_irq(gsi, IOAPIC_MAP_ALLOC | IOAPIC_MAP_CHECK);
++>>>>>>> d7f3d4781852 (x86, irq: Introduce mechanisms to support dynamically allocate IRQ for IOAPIC)
  
 -	if (irq >= 0) {
  #ifdef CONFIG_X86_IO_APIC
 -		if (acpi_irq_model == ACPI_IRQ_MODEL_IOAPIC)
 -			setup_IO_APIC_irq_extra(gsi);
 +	if (acpi_irq_model == ACPI_IRQ_MODEL_IOAPIC)
 +		setup_IO_APIC_irq_extra(gsi);
  #endif
 -		*irqp = irq;
 -		return 0;
 -	}
  
 -	return -1;
 +	return 0;
  }
  EXPORT_SYMBOL_GPL(acpi_gsi_to_irq);
  
diff --cc arch/x86/kernel/apic/io_apic.c
index 07a33b81b46c,51ce80004a78..000000000000
--- a/arch/x86/kernel/apic/io_apic.c
+++ b/arch/x86/kernel/apic/io_apic.c
@@@ -132,12 -133,24 +136,17 @@@ u32 mp_pin_to_gsi(int ioapic, int pin
  	return mp_ioapic_gsi_routing(ioapic)->gsi_base + pin;
  }
  
 -/*
 - * Initialize all legacy IRQs and all pins on the first IOAPIC
 - * if we have legacy interrupt controller. Kernel boot option "pirq="
 - * may rely on non-legacy pins on the first IOAPIC.
 - */
 +/* Initialize all legacy IRQs and all pins on the first IOAPIC at boot */
  static inline int mp_init_irq_at_boot(int ioapic, int irq)
  {
 -	if (!nr_legacy_irqs())
 -		return 0;
 -
 -	return ioapic == 0 || (irq >= 0 && irq < nr_legacy_irqs());
 +	return ioapic == 0 || (irq >= 0 && irq < NR_IRQS_LEGACY);
  }
  
+ static inline struct irq_domain *mp_ioapic_irqdomain(int ioapic)
+ {
+ 	return ioapics[ioapic].irqdomain;
+ }
+ 
  int nr_ioapics;
  
  /* The one past the highest gsi number used */
@@@ -984,11 -968,79 +993,87 @@@ static int irq_trigger(int idx
  	return trigger;
  }
  
++<<<<<<< HEAD
 +static int pin_2_irq(int idx, int apic, int pin)
 +{
 +	int irq;
 +	int bus = mp_irqs[idx].srcbus;
 +	struct mp_ioapic_gsi *gsi_cfg = mp_ioapic_gsi_routing(apic);
++=======
+ static int alloc_irq_from_domain(struct irq_domain *domain, u32 gsi, int pin)
+ {
+ 	int irq = -1;
+ 	int ioapic = (int)(long)domain->host_data;
+ 	int type = ioapics[ioapic].irqdomain_cfg.type;
+ 
+ 	switch (type) {
+ 	case IOAPIC_DOMAIN_LEGACY:
+ 		/*
+ 		 * Dynamically allocate IRQ number for non-ISA IRQs in the first 16
+ 		 * GSIs on some weird platforms.
+ 		 */
+ 		if (gsi < nr_legacy_irqs())
+ 			irq = irq_create_mapping(domain, pin);
+ 		else if (irq_create_strict_mappings(domain, gsi, pin, 1) == 0)
+ 			irq = gsi;
+ 		break;
+ 	case IOAPIC_DOMAIN_STRICT:
+ 		if (irq_create_strict_mappings(domain, gsi, pin, 1) == 0)
+ 			irq = gsi;
+ 		break;
+ 	case IOAPIC_DOMAIN_DYNAMIC:
+ 		irq = irq_create_mapping(domain, pin);
+ 		break;
+ 	default:
+ 		WARN(1, "ioapic: unknown irqdomain type %d\n", type);
+ 		break;
+ 	}
+ 
+ 	return irq > 0 ? irq : -1;
+ }
+ 
+ static int mp_map_pin_to_irq(u32 gsi, int idx, int ioapic, int pin,
+ 			     unsigned int flags)
+ {
+ 	int irq;
+ 	struct irq_domain *domain = mp_ioapic_irqdomain(ioapic);
+ 
+ 	/*
+ 	 * Don't use irqdomain to manage ISA IRQs because there may be
+ 	 * multiple IOAPIC pins sharing the same ISA IRQ number and
+ 	 * irqdomain only supports 1:1 mapping between IOAPIC pin and
+ 	 * IRQ number. A typical IOAPIC has 24 pins, pin 0-15 are used
+ 	 * for legacy IRQs and pin 16-23 are used for PCI IRQs (PIRQ A-H).
+ 	 * When ACPI is disabled, only legacy IRQ numbers (IRQ0-15) are
+ 	 * available, and some BIOSes may use MP Interrupt Source records
+ 	 * to override IRQ numbers for PIRQs instead of reprogramming
+ 	 * the interrupt routing logic. Thus there may be multiple pins
+ 	 * sharing the same legacy IRQ number when ACPI is disabled.
+ 	 */
+ 	if (idx >= 0 && test_bit(mp_irqs[idx].srcbus, mp_bus_not_pci))
+ 		return mp_irqs[idx].srcbusirq;
+ 
+ 	if (!domain) {
+ 		/*
+ 		 * Provide an identity mapping of gsi == irq except on truly
+ 		 * weird platforms that have non isa irqs in the first 16 gsis.
+ 		 */
+ 		return gsi >= nr_legacy_irqs() ? gsi : gsi_top + gsi;
+ 	}
+ 
+ 	mutex_lock(&ioapic_mutex);
+ 	irq = irq_find_mapping(domain, pin);
+ 	if (irq <= 0 && (flags & IOAPIC_MAP_ALLOC))
+ 		irq = alloc_irq_from_domain(domain, gsi, pin);
+ 	mutex_unlock(&ioapic_mutex);
+ 
+ 	return irq > 0 ? irq : -1;
+ }
+ 
+ static int pin_2_irq(int idx, int ioapic, int pin, unsigned int flags)
+ {
+ 	u32 gsi = mp_pin_to_gsi(ioapic, pin);
++>>>>>>> d7f3d4781852 (x86, irq: Introduce mechanisms to support dynamically allocate IRQ for IOAPIC)
  
  	/*
  	 * Debugging check, we are in big trouble if this message pops up!
@@@ -1026,7 -1068,23 +1111,27 @@@
  	}
  #endif
  
++<<<<<<< HEAD
 +	return irq;
++=======
+ 	return  mp_map_pin_to_irq(gsi, idx, ioapic, pin, flags);
+ }
+ 
+ int mp_map_gsi_to_irq(u32 gsi, unsigned int flags)
+ {
+ 	int ioapic, pin, idx;
+ 
+ 	ioapic = mp_find_ioapic(gsi);
+ 	if (ioapic < 0)
+ 		return -1;
+ 
+ 	pin = mp_find_ioapic_pin(ioapic, gsi);
+ 	idx = find_irq_entry(ioapic, pin, mp_INT);
+ 	if ((flags & IOAPIC_MAP_CHECK) && idx < 0)
+ 		return -1;
+ 
+ 	return mp_map_pin_to_irq(gsi, idx, ioapic, pin, flags);
++>>>>>>> d7f3d4781852 (x86, irq: Introduce mechanisms to support dynamically allocate IRQ for IOAPIC)
  }
  
  /*
* Unmerged path arch/x86/Kconfig
* Unmerged path arch/x86/include/asm/io_apic.h
* Unmerged path arch/x86/kernel/acpi/boot.c
* Unmerged path arch/x86/kernel/apic/io_apic.c
