be2net: convert dest field in udp-hdr to host-endian

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Venkat Duvvuru <VenkatKumar.Duvvuru@Emulex.com>
commit 1645d99768e00d3148ebded5d8c4ab55cdb19a5c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1645d997.failed

The "dest" field in the UDP-hdr of a TX skb is in network endian format.
Convert it to host endian before accessing it. The os2bmc patch,
mentioned below introduced this code.

Fixes: 760c295e0e8d ("be2net: Support for OS2BMC")
	Signed-off-by: Venkat Duvvuru <VenkatKumar.Duvvuru@Emulex.com>
	Signed-off-by: Sathya Perla <sathya.perla@avagotech.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1645d99768e00d3148ebded5d8c4ab55cdb19a5c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/emulex/benet/be_main.c
diff --cc drivers/net/ethernet/emulex/benet/be_main.c
index 433797e2aad9,c996dd76f546..000000000000
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@@ -1054,9 -1158,132 +1054,136 @@@ static void be_xmit_flush(struct be_ada
  	txo->pend_wrb_cnt = 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* OS2BMC related */
+ 
+ #define DHCP_CLIENT_PORT	68
+ #define DHCP_SERVER_PORT	67
+ #define NET_BIOS_PORT1		137
+ #define NET_BIOS_PORT2		138
+ #define DHCPV6_RAS_PORT		547
+ 
+ #define is_mc_allowed_on_bmc(adapter, eh)	\
+ 	(!is_multicast_filt_enabled(adapter) &&	\
+ 	 is_multicast_ether_addr(eh->h_dest) &&	\
+ 	 !is_broadcast_ether_addr(eh->h_dest))
+ 
+ #define is_bc_allowed_on_bmc(adapter, eh)	\
+ 	(!is_broadcast_filt_enabled(adapter) &&	\
+ 	 is_broadcast_ether_addr(eh->h_dest))
+ 
+ #define is_arp_allowed_on_bmc(adapter, skb)	\
+ 	(is_arp(skb) && is_arp_filt_enabled(adapter))
+ 
+ #define is_broadcast_packet(eh, adapter)	\
+ 		(is_multicast_ether_addr(eh->h_dest) && \
+ 		!compare_ether_addr(eh->h_dest, adapter->netdev->broadcast))
+ 
+ #define is_arp(skb)	(skb->protocol == htons(ETH_P_ARP))
+ 
+ #define is_arp_filt_enabled(adapter)	\
+ 		(adapter->bmc_filt_mask & (BMC_FILT_BROADCAST_ARP))
+ 
+ #define is_dhcp_client_filt_enabled(adapter)	\
+ 		(adapter->bmc_filt_mask & BMC_FILT_BROADCAST_DHCP_CLIENT)
+ 
+ #define is_dhcp_srvr_filt_enabled(adapter)	\
+ 		(adapter->bmc_filt_mask & BMC_FILT_BROADCAST_DHCP_SERVER)
+ 
+ #define is_nbios_filt_enabled(adapter)	\
+ 		(adapter->bmc_filt_mask & BMC_FILT_BROADCAST_NET_BIOS)
+ 
+ #define is_ipv6_na_filt_enabled(adapter)	\
+ 		(adapter->bmc_filt_mask &	\
+ 			BMC_FILT_MULTICAST_IPV6_NEIGH_ADVER)
+ 
+ #define is_ipv6_ra_filt_enabled(adapter)	\
+ 		(adapter->bmc_filt_mask & BMC_FILT_MULTICAST_IPV6_RA)
+ 
+ #define is_ipv6_ras_filt_enabled(adapter)	\
+ 		(adapter->bmc_filt_mask & BMC_FILT_MULTICAST_IPV6_RAS)
+ 
+ #define is_broadcast_filt_enabled(adapter)	\
+ 		(adapter->bmc_filt_mask & BMC_FILT_BROADCAST)
+ 
+ #define is_multicast_filt_enabled(adapter)	\
+ 		(adapter->bmc_filt_mask & BMC_FILT_MULTICAST)
+ 
+ static bool be_send_pkt_to_bmc(struct be_adapter *adapter,
+ 			       struct sk_buff **skb)
+ {
+ 	struct ethhdr *eh = (struct ethhdr *)(*skb)->data;
+ 	bool os2bmc = false;
+ 
+ 	if (!be_is_os2bmc_enabled(adapter))
+ 		goto done;
+ 
+ 	if (!is_multicast_ether_addr(eh->h_dest))
+ 		goto done;
+ 
+ 	if (is_mc_allowed_on_bmc(adapter, eh) ||
+ 	    is_bc_allowed_on_bmc(adapter, eh) ||
+ 	    is_arp_allowed_on_bmc(adapter, (*skb))) {
+ 		os2bmc = true;
+ 		goto done;
+ 	}
+ 
+ 	if ((*skb)->protocol == htons(ETH_P_IPV6)) {
+ 		struct ipv6hdr *hdr = ipv6_hdr((*skb));
+ 		u8 nexthdr = hdr->nexthdr;
+ 
+ 		if (nexthdr == IPPROTO_ICMPV6) {
+ 			struct icmp6hdr *icmp6 = icmp6_hdr((*skb));
+ 
+ 			switch (icmp6->icmp6_type) {
+ 			case NDISC_ROUTER_ADVERTISEMENT:
+ 				os2bmc = is_ipv6_ra_filt_enabled(adapter);
+ 				goto done;
+ 			case NDISC_NEIGHBOUR_ADVERTISEMENT:
+ 				os2bmc = is_ipv6_na_filt_enabled(adapter);
+ 				goto done;
+ 			default:
+ 				break;
+ 			}
+ 		}
+ 	}
+ 
+ 	if (is_udp_pkt((*skb))) {
+ 		struct udphdr *udp = udp_hdr((*skb));
+ 
+ 		switch (ntohs(udp->dest)) {
+ 		case DHCP_CLIENT_PORT:
+ 			os2bmc = is_dhcp_client_filt_enabled(adapter);
+ 			goto done;
+ 		case DHCP_SERVER_PORT:
+ 			os2bmc = is_dhcp_srvr_filt_enabled(adapter);
+ 			goto done;
+ 		case NET_BIOS_PORT1:
+ 		case NET_BIOS_PORT2:
+ 			os2bmc = is_nbios_filt_enabled(adapter);
+ 			goto done;
+ 		case DHCPV6_RAS_PORT:
+ 			os2bmc = is_ipv6_ras_filt_enabled(adapter);
+ 			goto done;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ done:
+ 	/* For packets over a vlan, which are destined
+ 	 * to BMC, asic expects the vlan to be inline in the packet.
+ 	 */
+ 	if (os2bmc)
+ 		*skb = be_insert_vlan_in_pkt(adapter, *skb, NULL);
+ 
+ 	return os2bmc;
+ }
+ 
++>>>>>>> 1645d99768e0 (be2net: convert dest field in udp-hdr to host-endian)
  static netdev_tx_t be_xmit(struct sk_buff *skb, struct net_device *netdev)
  {
 +	bool skip_hw_vlan = false, flush = !skb->xmit_more;
  	struct be_adapter *adapter = netdev_priv(netdev);
  	u16 q_idx = skb_get_queue_mapping(skb);
  	struct be_tx_obj *txo = &adapter->tx_obj[q_idx];
* Unmerged path drivers/net/ethernet/emulex/benet/be_main.c
