bonding: simplify bond_3ad_update_lacp_rate and use RTNL for sync

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author nikolay@redhat.com <nikolay@redhat.com>
commit c509316b5b33664b08b2a40d09534e0bd3c6b648
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/c509316b.failed

We can drop the use of bond->lock for mutual exclusion in
bond_3ad_update_lacp_rate and use RTNL in the sysfs store function
instead. This way we'll prevent races with mode change and interface
up/down as well as simplify update_lacp_rate by removing the check for
port->slave because it'll always be initialized (done while enslaving
with RTNL). This change will also help in the future removal of reader
bond->lock from bond_enslave.

	Signed-off-by: Nikolay Aleksandrov <nikolay@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c509316b5b33664b08b2a40d09534e0bd3c6b648)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_3ad.c
diff --cc drivers/net/bonding/bond_3ad.c
index 390061d09693,0d8f427ade93..000000000000
--- a/drivers/net/bonding/bond_3ad.c
+++ b/drivers/net/bonding/bond_3ad.c
@@@ -2501,18 -2514,13 +2501,23 @@@ int bond_3ad_lacpdu_recv(const struct s
   */
  void bond_3ad_update_lacp_rate(struct bonding *bond)
  {
++<<<<<<< HEAD
 +	int i;
 +	struct slave *slave;
++=======
++>>>>>>> c509316b5b33 (bonding: simplify bond_3ad_update_lacp_rate and use RTNL for sync)
  	struct port *port = NULL;
+ 	struct slave *slave;
  	int lacp_fast;
  
- 	write_lock_bh(&bond->lock);
  	lacp_fast = bond->params.lacp_fast;
++<<<<<<< HEAD
 +
 +	bond_for_each_slave(bond, slave, i) {
++=======
+ 	bond_for_each_slave(bond, slave) {
++>>>>>>> c509316b5b33 (bonding: simplify bond_3ad_update_lacp_rate and use RTNL for sync)
  		port = &(SLAVE_AD_INFO(slave).port);
- 		if (port->slave == NULL)
- 			continue;
  		__get_state_machine_lock(port);
  		if (lacp_fast)
  			port->actor_oper_port_state |= AD_STATE_LACP_TIMEOUT;
* Unmerged path drivers/net/bonding/bond_3ad.c
diff --git a/drivers/net/bonding/bond_sysfs.c b/drivers/net/bonding/bond_sysfs.c
index c0344ce23f37..dfe921fc1eb0 100644
--- a/drivers/net/bonding/bond_sysfs.c
+++ b/drivers/net/bonding/bond_sysfs.c
@@ -858,8 +858,11 @@ static ssize_t bonding_store_lacp(struct device *d,
 				  struct device_attribute *attr,
 				  const char *buf, size_t count)
 {
-	int new_value, ret = count;
 	struct bonding *bond = to_bond(d);
+	int new_value, ret = count;
+
+	if (!rtnl_trylock())
+		return restart_syscall();
 
 	if (bond->dev->flags & IFF_UP) {
 		pr_err("%s: Unable to update LACP rate because interface is up.\n",
@@ -889,6 +892,8 @@ static ssize_t bonding_store_lacp(struct device *d,
 		ret = -EINVAL;
 	}
 out:
+	rtnl_unlock();
+
 	return ret;
 }
 static DEVICE_ATTR(lacp_rate, S_IRUGO | S_IWUSR,
