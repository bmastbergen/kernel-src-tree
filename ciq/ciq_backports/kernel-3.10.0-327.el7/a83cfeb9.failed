uprobes: Change handle_trampoline() to find the next chain beforehand

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Oleg Nesterov <oleg@redhat.com>
commit a83cfeb92132c279b20bbc8ed3cef833b0fe417e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a83cfeb9.failed

No functional changes, preparation.

Add the new helper, find_next_ret_chain(), which finds the first
!chained entry and returns its ->next. Yes, it is suboptimal. We
probably want to turn ->chained into ->start_of_this_chain
pointer and avoid another loop. But this needs the boring
changes in dup_utask(), so lets do this later.

Change the main loop in handle_trampoline() to unwind the stack
until ri is equal to the pointer returned by this new helper.

	Tested-by: Pratyush Anand <panand@redhat.com>
	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Acked-by: Anton Arapov <arapov@gmail.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20150721134013.GA4755@redhat.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit a83cfeb92132c279b20bbc8ed3cef833b0fe417e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/uprobes.c
diff --cc kernel/events/uprobes.c
index b0b89515dd30,98e4d97b8c31..000000000000
--- a/kernel/events/uprobes.c
+++ b/kernel/events/uprobes.c
@@@ -1716,8 -1781,7 +1728,12 @@@ static struct return_instance *find_nex
  static void handle_trampoline(struct pt_regs *regs)
  {
  	struct uprobe_task *utask;
++<<<<<<< HEAD
 +	struct return_instance *ri, *tmp;
 +	bool chained;
++=======
+ 	struct return_instance *ri, *next;
++>>>>>>> a83cfeb92132 (uprobes: Change handle_trampoline() to find the next chain beforehand)
  
  	utask = current->utask;
  	if (!utask)
@@@ -1733,22 -1798,11 +1750,21 @@@
  	 * returns.
  	 */
  	instruction_pointer_set(regs, ri->orig_ret_vaddr);
- 
- 	for (;;) {
+ 	do {
  		handle_uretprobe_chain(ri, regs);
++<<<<<<< HEAD
 +
 +		chained = ri->chained;
 +		put_uprobe(ri->uprobe);
 +
 +		tmp = ri;
 +		ri = ri->next;
 +		kfree(tmp);
++=======
+ 		ri = free_ret_instance(ri);
++>>>>>>> a83cfeb92132 (uprobes: Change handle_trampoline() to find the next chain beforehand)
  		utask->depth--;
- 
- 		if (!chained)
- 			break;
- 		BUG_ON(!ri);
- 	}
+ 	} while (ri != next);
  
  	utask->return_instances = ri;
  	return;
* Unmerged path kernel/events/uprobes.c
