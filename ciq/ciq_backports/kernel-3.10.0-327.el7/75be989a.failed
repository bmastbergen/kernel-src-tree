perf evlist: Adopt events_stats from perf_session

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [perf] evlist: Adopt events_stats from perf_session (Jiri Olsa) [1222189]
Rebuild_FUZZ: 94.62%
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 75be989a7a18e9666efd92b846ee48bed79e8086
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/75be989a.failed

For tools that don't deal with perf.data files, thus do not need to
use perf_session.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Don Zickus <dzickus@redhat.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Mike Galbraith <efault@gmx.de>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
Link: http://lkml.kernel.org/n/tip-kglq67gvauq9tak02a4se00r@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 75be989a7a18e9666efd92b846ee48bed79e8086)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/session.c
diff --cc tools/perf/util/session.c
index 78b55d673ea4,06ef1c35a65a..000000000000
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@@ -691,45 -532,88 +691,54 @@@ int perf_session_queue_event(struct per
  	if (!timestamp || timestamp == ~0ULL)
  		return -ETIME;
  
++<<<<<<< HEAD
 +	if (timestamp < s->ordered_events.last_flush) {
 +		printf("Warning: Timestamp below last timeslice flush\n");
 +		return -EINVAL;
++=======
+ 	if (timestamp < oe->last_flush) {
+ 		pr_oe_time(timestamp,      "out of order event\n");
+ 		pr_oe_time(oe->last_flush, "last flush, last_flush_type %d\n",
+ 			   oe->last_flush_type);
+ 
+ 		s->evlist->stats.nr_unordered_events++;
++>>>>>>> 75be989a7a18 (perf evlist: Adopt events_stats from perf_session)
  	}
  
 -	new = ordered_events__new(oe, timestamp, event);
 -	if (!new) {
 -		ordered_events__flush(s, tool, OE_FLUSH__HALF);
 -		new = ordered_events__new(oe, timestamp, event);
 +	if (!list_empty(cache)) {
 +		new = list_entry(cache->next, struct ordered_event, list);
 +		list_del(&new->list);
 +	} else if (oe->buffer) {
 +		new = oe->buffer + oe->buffer_idx;
 +		if (++oe->buffer_idx == MAX_SAMPLE_BUFFER)
 +			oe->buffer = NULL;
 +	} else {
 +		oe->buffer = malloc(MAX_SAMPLE_BUFFER * sizeof(*new));
 +		if (!oe->buffer)
 +			return -ENOMEM;
 +		list_add(&oe->buffer->list, &oe->to_free);
 +		oe->buffer_idx = 2;
 +		new = oe->buffer + 1;
  	}
  
 -	if (!new)
 -		return -ENOMEM;
 -
 +	new->timestamp = timestamp;
  	new->file_offset = file_offset;
 -	return 0;
 -}
 -
 -static void callchain__lbr_callstack_printf(struct perf_sample *sample)
 -{
 -	struct ip_callchain *callchain = sample->callchain;
 -	struct branch_stack *lbr_stack = sample->branch_stack;
 -	u64 kernel_callchain_nr = callchain->nr;
 -	unsigned int i;
 -
 -	for (i = 0; i < kernel_callchain_nr; i++) {
 -		if (callchain->ips[i] == PERF_CONTEXT_USER)
 -			break;
 -	}
 -
 -	if ((i != kernel_callchain_nr) && lbr_stack->nr) {
 -		u64 total_nr;
 -		/*
 -		 * LBR callstack can only get user call chain,
 -		 * i is kernel call chain number,
 -		 * 1 is PERF_CONTEXT_USER.
 -		 *
 -		 * The user call chain is stored in LBR registers.
 -		 * LBR are pair registers. The caller is stored
 -		 * in "from" register, while the callee is stored
 -		 * in "to" register.
 -		 * For example, there is a call stack
 -		 * "A"->"B"->"C"->"D".
 -		 * The LBR registers will recorde like
 -		 * "C"->"D", "B"->"C", "A"->"B".
 -		 * So only the first "to" register and all "from"
 -		 * registers are needed to construct the whole stack.
 -		 */
 -		total_nr = i + 1 + lbr_stack->nr + 1;
 -		kernel_callchain_nr = i + 1;
 -
 -		printf("... LBR call chain: nr:%" PRIu64 "\n", total_nr);
 +	new->event = event;
  
 -		for (i = 0; i < kernel_callchain_nr; i++)
 -			printf("..... %2d: %016" PRIx64 "\n",
 -			       i, callchain->ips[i]);
 +	__queue_event(new, s);
  
 -		printf("..... %2d: %016" PRIx64 "\n",
 -		       (int)(kernel_callchain_nr), lbr_stack->entries[0].to);
 -		for (i = 0; i < lbr_stack->nr; i++)
 -			printf("..... %2d: %016" PRIx64 "\n",
 -			       (int)(i + kernel_callchain_nr + 1), lbr_stack->entries[i].from);
 -	}
 +	return 0;
  }
  
 -static void callchain__printf(struct perf_evsel *evsel,
 -			      struct perf_sample *sample)
 +static void callchain__printf(struct perf_sample *sample)
  {
  	unsigned int i;
 -	struct ip_callchain *callchain = sample->callchain;
  
 -	if (has_branch_callstack(evsel))
 -		callchain__lbr_callstack_printf(sample);
 +	printf("... chain: nr:%" PRIu64 "\n", sample->callchain->nr);
  
 -	printf("... FP chain: nr:%" PRIu64 "\n", callchain->nr);
 -
 -	for (i = 0; i < callchain->nr; i++)
 +	for (i = 0; i < sample->callchain->nr; i++)
  		printf("..... %2d: %016" PRIx64 "\n",
 -		       i, callchain->ips[i]);
 +		       i, sample->callchain->ips[i]);
  }
  
  static void branch_stack__printf(struct perf_sample *sample)
@@@ -1259,27 -1142,30 +1268,33 @@@ static void perf_session__warn_about_er
  			    "file generated by a more recent tool?\n\n"
  			    "If that is not the case, consider "
  			    "reporting to linux-kernel@vger.kernel.org.\n\n",
- 			    session->stats.nr_unknown_events);
+ 			    session->evlist->stats.nr_unknown_events);
  	}
  
- 	if (session->stats.nr_unknown_id != 0) {
+ 	if (session->evlist->stats.nr_unknown_id != 0) {
  		ui__warning("%u samples with id not present in the header\n",
- 			    session->stats.nr_unknown_id);
+ 			    session->evlist->stats.nr_unknown_id);
  	}
  
-  	if (session->stats.nr_invalid_chains != 0) {
-  		ui__warning("Found invalid callchains!\n\n"
-  			    "%u out of %u events were discarded for this reason.\n\n"
-  			    "Consider reporting to linux-kernel@vger.kernel.org.\n\n",
-  			    session->stats.nr_invalid_chains,
-  			    session->stats.nr_events[PERF_RECORD_SAMPLE]);
-  	}
+ 	if (session->evlist->stats.nr_invalid_chains != 0) {
+ 		ui__warning("Found invalid callchains!\n\n"
+ 			    "%u out of %u events were discarded for this reason.\n\n"
+ 			    "Consider reporting to linux-kernel@vger.kernel.org.\n\n",
+ 			    session->evlist->stats.nr_invalid_chains,
+ 			    session->evlist->stats.nr_events[PERF_RECORD_SAMPLE]);
+ 	}
  
- 	if (session->stats.nr_unprocessable_samples != 0) {
+ 	if (session->evlist->stats.nr_unprocessable_samples != 0) {
  		ui__warning("%u unprocessable samples recorded.\n"
  			    "Do you have a KVM guest running and not using 'perf kvm'?\n",
- 			    session->stats.nr_unprocessable_samples);
+ 			    session->evlist->stats.nr_unprocessable_samples);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (session->evlist->stats.nr_unordered_events != 0)
+ 		ui__warning("%u out of order events recorded.\n", session->evlist->stats.nr_unordered_events);
++>>>>>>> 75be989a7a18 (perf evlist: Adopt events_stats from perf_session)
  }
  
  volatile int session_done;
diff --git a/tools/perf/builtin-sched.c b/tools/perf/builtin-sched.c
index 891c3930080e..7ce296618717 100644
--- a/tools/perf/builtin-sched.c
+++ b/tools/perf/builtin-sched.c
@@ -1473,9 +1473,9 @@ static int perf_sched__read_events(struct perf_sched *sched,
 			goto out_delete;
 		}
 
-		sched->nr_events      = session->stats.nr_events[0];
-		sched->nr_lost_events = session->stats.total_lost;
-		sched->nr_lost_chunks = session->stats.nr_events[PERF_RECORD_LOST];
+		sched->nr_events      = session->evlist->stats.nr_events[0];
+		sched->nr_lost_events = session->evlist->stats.total_lost;
+		sched->nr_lost_chunks = session->evlist->stats.nr_events[PERF_RECORD_LOST];
 	}
 
 	if (psession)
diff --git a/tools/perf/builtin-top.c b/tools/perf/builtin-top.c
index c4c7eac69de4..5fb8723c7128 100644
--- a/tools/perf/builtin-top.c
+++ b/tools/perf/builtin-top.c
@@ -716,7 +716,7 @@ static void perf_event__process_sample(struct perf_tool *tool,
 
 	if (!machine) {
 		pr_err("%u unprocessable samples recorded.\r",
-		       top->session->stats.nr_unprocessable_samples++);
+		       top->session->evlist->stats.nr_unprocessable_samples++);
 		return;
 	}
 
@@ -856,7 +856,7 @@ static void perf_top__mmap_read_idx(struct perf_top *top, int idx)
 			hists__inc_nr_events(evsel__hists(evsel), event->header.type);
 			machine__process_event(machine, event, &sample);
 		} else
-			++session->stats.nr_unknown_events;
+			++session->evlist->stats.nr_unknown_events;
 next_event:
 		perf_evlist__mmap_consume(top->evlist, idx);
 	}
diff --git a/tools/perf/util/evlist.h b/tools/perf/util/evlist.h
index 315401dca17e..f07c984465f0 100644
--- a/tools/perf/util/evlist.h
+++ b/tools/perf/util/evlist.h
@@ -51,6 +51,7 @@ struct perf_evlist {
 	struct thread_map *threads;
 	struct cpu_map	  *cpus;
 	struct perf_evsel *selected;
+	struct events_stats stats;
 };
 
 struct perf_evsel_str_handler {
* Unmerged path tools/perf/util/session.c
diff --git a/tools/perf/util/session.h b/tools/perf/util/session.h
index 4c0f5b098c9f..be39d75e30a8 100644
--- a/tools/perf/util/session.h
+++ b/tools/perf/util/session.h
@@ -33,7 +33,6 @@ struct perf_session {
 	struct machines		machines;
 	struct perf_evlist	*evlist;
 	struct trace_event	tevent;
-	struct events_stats	stats;
 	bool			repipe;
 	bool			one_mmap;
 	void			*one_mmap_addr;
