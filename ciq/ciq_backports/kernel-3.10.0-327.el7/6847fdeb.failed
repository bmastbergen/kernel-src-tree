IB/iser: Remove redundant assignments in iser_reg_page_vec

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Remove redundant assignments in iser_reg_page_vec (Amir Vadai) [1164539]
Rebuild_FUZZ: 97.35%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 6847fdeb0bcd2eade5b8183d3d2857c4fd7b70d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/6847fdeb.failed

Buffer length was assigned twice, and no reason to set va to
io_addr and then add the offset, just set va to io_addr + offset.

This patch does not change any functionality.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Adir Lev <adirl@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 6847fdeb0bcd2eade5b8183d3d2857c4fd7b70d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_memory.c
diff --cc drivers/infiniband/ulp/iser/iser_memory.c
index f40132fc970c,cb308650b94a..000000000000
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@@ -366,6 -362,91 +366,94 @@@ static int fall_to_bounce_buf(struct is
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * iser_reg_page_vec - Register physical memory
+  *
+  * returns: 0 on success, errno code on failure
+  */
+ static
+ int iser_reg_page_vec(struct ib_conn *ib_conn,
+ 		      struct iser_page_vec *page_vec,
+ 		      struct iser_mem_reg  *mem_reg)
+ {
+ 	struct ib_pool_fmr *mem;
+ 	u64		   io_addr;
+ 	u64		   *page_list;
+ 	int		   status;
+ 
+ 	page_list = page_vec->pages;
+ 	io_addr	  = page_list[0];
+ 
+ 	mem  = ib_fmr_pool_map_phys(ib_conn->fmr.pool,
+ 				    page_list,
+ 				    page_vec->length,
+ 				    io_addr);
+ 
+ 	if (IS_ERR(mem)) {
+ 		status = (int)PTR_ERR(mem);
+ 		iser_err("ib_fmr_pool_map_phys failed: %d\n", status);
+ 		return status;
+ 	}
+ 
+ 	mem_reg->lkey  = mem->fmr->lkey;
+ 	mem_reg->rkey  = mem->fmr->rkey;
+ 	mem_reg->len   = page_vec->data_size;
+ 	mem_reg->va    = io_addr + page_vec->offset;
+ 	mem_reg->mem_h = (void *)mem;
+ 
+ 	iser_dbg("PHYSICAL Mem.register, [PHYS p_array: 0x%p, sz: %d, "
+ 		 "entry[0]: (0x%08lx,%ld)] -> "
+ 		 "[lkey: 0x%08X mem_h: 0x%p va: 0x%08lX sz: %ld]\n",
+ 		 page_vec, page_vec->length,
+ 		 (unsigned long)page_vec->pages[0],
+ 		 (unsigned long)page_vec->data_size,
+ 		 (unsigned int)mem_reg->lkey, mem_reg->mem_h,
+ 		 (unsigned long)mem_reg->va, (unsigned long)mem_reg->len);
+ 	return 0;
+ }
+ 
+ /**
+  * Unregister (previosuly registered using FMR) memory.
+  * If memory is non-FMR does nothing.
+  */
+ void iser_unreg_mem_fmr(struct iscsi_iser_task *iser_task,
+ 			enum iser_data_dir cmd_dir)
+ {
+ 	struct iser_mem_reg *reg = &iser_task->rdma_regd[cmd_dir].reg;
+ 	int ret;
+ 
+ 	if (!reg->mem_h)
+ 		return;
+ 
+ 	iser_dbg("PHYSICAL Mem.Unregister mem_h %p\n", reg->mem_h);
+ 
+ 	ret = ib_fmr_pool_unmap((struct ib_pool_fmr *)reg->mem_h);
+ 	if (ret)
+ 		iser_err("ib_fmr_pool_unmap failed %d\n", ret);
+ 
+ 	reg->mem_h = NULL;
+ }
+ 
+ void iser_unreg_mem_fastreg(struct iscsi_iser_task *iser_task,
+ 			    enum iser_data_dir cmd_dir)
+ {
+ 	struct iser_mem_reg *reg = &iser_task->rdma_regd[cmd_dir].reg;
+ 	struct iser_conn *iser_conn = iser_task->iser_conn;
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
+ 	struct fast_reg_descriptor *desc = reg->mem_h;
+ 
+ 	if (!desc)
+ 		return;
+ 
+ 	reg->mem_h = NULL;
+ 	spin_lock_bh(&ib_conn->lock);
+ 	list_add_tail(&desc->list, &ib_conn->fastreg.pool);
+ 	spin_unlock_bh(&ib_conn->lock);
+ }
+ 
+ /**
++>>>>>>> 6847fdeb0bcd (IB/iser: Remove redundant assignments in iser_reg_page_vec)
   * iser_reg_rdma_mem_fmr - Registers memory intended for RDMA,
   * using FMR (if possible) obtaining rkey and va
   *
* Unmerged path drivers/infiniband/ulp/iser/iser_memory.c
