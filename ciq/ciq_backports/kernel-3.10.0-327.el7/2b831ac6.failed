xfs: bulkstat chunk-formatter has issues

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 2b831ac6bc87d3cbcbb1a8816827b6923403e461
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/2b831ac6.failed

The loop construct has issues:
	- clustidx is completely unused, so remove it.
	- the loop tries to be smart by terminating when the
	  "freecount" tells it that all inodes are free. Just drop
	  it as in most cases we have to scan all inodes in the
	  chunk anyway.
	- move the "user buffer left" condition check to the only
	  point where we consume space int eh user buffer.
	- move the initialisation of agino out of the loop, leaving
	  just a simple loop control logic using the clusteridx.

Also, double handling of the user buffer variables leads to problems
tracking the current state - use the cursor variables directly
rather than keeping local copies and then having to update the
cursor before returning.

cc: <stable@vger.kernel.org> # 3.17
	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>
(cherry picked from commit 2b831ac6bc87d3cbcbb1a8816827b6923403e461)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_itable.c
diff --cc fs/xfs/xfs_itable.c
index 00889cf40587,7ea2b113db1b..000000000000
--- a/fs/xfs/xfs_itable.c
+++ b/fs/xfs/xfs_itable.c
@@@ -262,6 -262,74 +262,77 @@@ xfs_bulkstat_grab_ichunk
  
  #define XFS_BULKSTAT_UBLEFT(ubleft)	((ubleft) >= statstruct_size)
  
++<<<<<<< HEAD
++=======
+ struct xfs_bulkstat_agichunk {
+ 	char		__user **ac_ubuffer;/* pointer into user's buffer */
+ 	int		ac_ubleft;	/* bytes left in user's buffer */
+ 	int		ac_ubelem;	/* spaces used in user's buffer */
+ };
+ 
+ /*
+  * Process inodes in chunk with a pointer to a formatter function
+  * that will iget the inode and fill in the appropriate structure.
+  */
+ static int
+ xfs_bulkstat_ag_ichunk(
+ 	struct xfs_mount		*mp,
+ 	xfs_agnumber_t			agno,
+ 	struct xfs_inobt_rec_incore	*irbp,
+ 	bulkstat_one_pf			formatter,
+ 	size_t				statstruct_size,
+ 	struct xfs_bulkstat_agichunk	*acp,
+ 	xfs_ino_t			*lastino)
+ {
+ 	char				__user **ubufp = acp->ac_ubuffer;
+ 	int				chunkidx;
+ 	int				error = 0;
+ 	xfs_agino_t			agino;
+ 
+ 	agino = irbp->ir_startino;
+ 	for (chunkidx = 0; chunkidx < XFS_INODES_PER_CHUNK;
+ 	     chunkidx++, agino++) {
+ 		int		fmterror;
+ 		int		ubused;
+ 		xfs_ino_t	ino = XFS_AGINO_TO_INO(mp, agno, agino);
+ 
+ 		/* Skip if this inode is free */
+ 		if (XFS_INOBT_MASK(chunkidx) & irbp->ir_free) {
+ 			*lastino = ino;
+ 			continue;
+ 		}
+ 
+ 		/* Get the inode and fill in a single buffer */
+ 		ubused = statstruct_size;
+ 		error = formatter(mp, ino, *ubufp, acp->ac_ubleft,
+ 				  &ubused, &fmterror);
+ 		if (fmterror == BULKSTAT_RV_GIVEUP ||
+ 		    (error && error != -ENOENT && error != -EINVAL)) {
+ 			acp->ac_ubleft = 0;
+ 			ASSERT(error);
+ 			break;
+ 		}
+ 
+ 		/* be careful not to leak error if at end of chunk */
+ 		if (fmterror == BULKSTAT_RV_NOTHING || error) {
+ 			*lastino = ino;
+ 			error = 0;
+ 			continue;
+ 		}
+ 
+ 		*ubufp += ubused;
+ 		acp->ac_ubleft -= ubused;
+ 		acp->ac_ubelem++;
+ 		*lastino = ino;
+ 
+ 		if (acp->ac_ubleft < statstruct_size)
+ 			break;
+ 	}
+ 
+ 	return error;
+ }
+ 
++>>>>>>> 2b831ac6bc87 (xfs: bulkstat chunk-formatter has issues)
  /*
   * Return stat information in bulk (by-inode) for the filesystem.
   */
* Unmerged path fs/xfs/xfs_itable.c
