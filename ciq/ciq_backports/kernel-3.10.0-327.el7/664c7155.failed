ALSA: hda - Work around races of power up/down with runtime PM

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Work around races of power up/down with runtime PM (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 94.92%
commit-author Takashi Iwai <tiwai@suse.de>
commit 664c715573c2c116c2d8f5de7d59ce85a98a1751
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/664c7155.failed

Currently, snd_hdac_power_up()/down() helpers checks whether the codec
is being in pm (suspend/resume), and skips the call of runtime get/put
during it.  This is needed as there are lots of power up/down
sequences called in the paths that are also used in the PM itself.  An
example is found in hda_codec.c::codec_exec_verb(), where this can
power up the codec while it may be called again in its power up
sequence, too.

The above works in most cases, but sometimes we really want to wait
for the real power up.  For example, the control element get/put may
want explicit power up so that the value change is assured to reach to
the hardware.   Using the current snd_hdac_power_up(), however,
results in a race, e.g. when it's called during the runtime suspend is
being performed.  In the worst case, as found in patch_ca0132.c, it
can even lead to the deadlock because the code assumes the power up
while it was skipped due to the check above.

For dealing with such cases, this patch makes snd_hdac_power_up() and
_down() to two variants: with and without in_pm flag check.  The
version with pm flag check is named as snd_hdac_power_up_pm() while
the version without pm flag check is still kept as
snd_hdac_power_up().  (Just because the usage of the former is fewer.)

Then finally, the patch replaces each call potentially done in PM with
the new _pm() variant.

In theory, we can implement a unified version -- if we can distinguish
the current context whether it's in the pm path.  But such an
implementation is cumbersome, so leave the code like this a bit messy
way for now...

Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=96271
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 664c715573c2c116c2d8f5de7d59ce85a98a1751)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/sound/hdaudio.h
#	sound/hda/hdac_device.c
#	sound/hda/hdac_regmap.c
#	sound/pci/hda/hda_codec.c
#	sound/pci/hda/hda_codec.h
diff --cc sound/pci/hda/hda_codec.c
index 05cb5f57659a,e70a7fb393dd..000000000000
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@@ -170,29 -136,17 +170,40 @@@ static int codec_exec_verb(struct hda_c
  	if (cmd == ~0)
  		return -1;
  
 +	if (res)
 +		*res = -1;
   again:
++<<<<<<< HEAD
 +	snd_hda_power_up(codec);
 +	mutex_lock(&bus->cmd_mutex);
++=======
+ 	snd_hda_power_up_pm(codec);
+ 	mutex_lock(&bus->core.cmd_mutex);
++>>>>>>> 664c715573c2 (ALSA: hda - Work around races of power up/down with runtime PM)
  	if (flags & HDA_RW_NO_RESPONSE_FALLBACK)
  		bus->no_response_fallback = 1;
 -	err = snd_hdac_bus_exec_verb_unlocked(&bus->core, codec->core.addr,
 -					      cmd, res);
 +	for (;;) {
 +		trace_hda_send_cmd(codec, cmd);
 +		err = bus->ops.command(bus, cmd);
 +		if (err != -EAGAIN)
 +			break;
 +		/* process pending verbs */
 +		bus->ops.get_response(bus, codec->addr);
 +	}
 +	if (!err && res) {
 +		*res = bus->ops.get_response(bus, codec->addr);
 +		trace_hda_get_response(codec, *res);
 +	}
  	bus->no_response_fallback = 0;
++<<<<<<< HEAD
 +	mutex_unlock(&bus->cmd_mutex);
 +	snd_hda_power_down(codec);
 +	if (!codec_in_pm(codec) && res && *res == -1 && bus->rirb_error) {
++=======
+ 	mutex_unlock(&bus->core.cmd_mutex);
+ 	snd_hda_power_down_pm(codec);
+ 	if (!codec_in_pm(codec) && res && err < 0 && bus->rirb_error) {
++>>>>>>> 664c715573c2 (ALSA: hda - Work around races of power up/down with runtime PM)
  		if (bus->response_reset) {
  			codec_dbg(codec,
  				  "resetting BUS due to fatal communication error\n");
diff --cc sound/pci/hda/hda_codec.h
index 00c6f394c5ce,9075ac28dc4b..000000000000
--- a/sound/pci/hda/hda_codec.h
+++ b/sound/pci/hda/hda_codec.h
@@@ -601,15 -507,15 +601,22 @@@ const char *snd_hda_get_jack_location(u
  /*
   * power saving
   */
++<<<<<<< HEAD
++=======
+ #define snd_hda_power_up(codec)		snd_hdac_power_up(&(codec)->core)
+ #define snd_hda_power_up_pm(codec)	snd_hdac_power_up_pm(&(codec)->core)
+ #define snd_hda_power_down(codec)	snd_hdac_power_down(&(codec)->core)
+ #define snd_hda_power_down_pm(codec)	snd_hdac_power_down_pm(&(codec)->core)
++>>>>>>> 664c715573c2 (ALSA: hda - Work around races of power up/down with runtime PM)
  #ifdef CONFIG_PM
 -void snd_hda_set_power_save(struct hda_bus *bus, int delay);
 +void snd_hda_power_up(struct hda_codec *codec);
 +void snd_hda_power_down(struct hda_codec *codec);
 +void snd_hda_power_sync(struct hda_codec *codec);
  void snd_hda_update_power_acct(struct hda_codec *codec);
  #else
 -static inline void snd_hda_set_power_save(struct hda_bus *bus, int delay) {}
 +static inline void snd_hda_power_up(struct hda_codec *codec) {}
 +static inline void snd_hda_power_down(struct hda_codec *codec) {}
 +static inline void snd_hda_power_sync(struct hda_codec *codec) {}
  #endif
  
  #ifdef CONFIG_SND_HDA_PATCH_LOADER
* Unmerged path include/sound/hdaudio.h
* Unmerged path sound/hda/hdac_device.c
* Unmerged path sound/hda/hdac_regmap.c
* Unmerged path include/sound/hdaudio.h
* Unmerged path sound/hda/hdac_device.c
* Unmerged path sound/hda/hdac_regmap.c
* Unmerged path sound/pci/hda/hda_codec.c
* Unmerged path sound/pci/hda/hda_codec.h
diff --git a/sound/pci/hda/patch_ca0132.c b/sound/pci/hda/patch_ca0132.c
index 72d20652df50..734a122ec2a3 100644
--- a/sound/pci/hda/patch_ca0132.c
+++ b/sound/pci/hda/patch_ca0132.c
@@ -3131,7 +3131,7 @@ static int ca0132_select_out(struct hda_codec *codec)
 
 	codec_dbg(codec, "ca0132_select_out\n");
 
-	snd_hda_power_up(codec);
+	snd_hda_power_up_pm(codec);
 
 	auto_jack = spec->vnode_lswitch[VNID_HP_ASEL - VNODE_START_NID];
 
@@ -3215,7 +3215,7 @@ static int ca0132_select_out(struct hda_codec *codec)
 	}
 
 exit:
-	snd_hda_power_down(codec);
+	snd_hda_power_down_pm(codec);
 
 	return err < 0 ? err : 0;
 }
@@ -3293,7 +3293,7 @@ static int ca0132_select_mic(struct hda_codec *codec)
 
 	codec_dbg(codec, "ca0132_select_mic\n");
 
-	snd_hda_power_up(codec);
+	snd_hda_power_up_pm(codec);
 
 	auto_jack = spec->vnode_lswitch[VNID_AMIC1_ASEL - VNODE_START_NID];
 
@@ -3326,7 +3326,7 @@ static int ca0132_select_mic(struct hda_codec *codec)
 		ca0132_effects_set(codec, VOICE_FOCUS, 0);
 	}
 
-	snd_hda_power_down(codec);
+	snd_hda_power_down_pm(codec);
 
 	return 0;
 }
@@ -4550,7 +4550,7 @@ static int ca0132_init(struct hda_codec *codec)
 		spec->dsp_state = DSP_DOWNLOAD_INIT;
 	spec->curr_chip_addx = INVALID_CHIP_ADDRESS;
 
-	snd_hda_power_up(codec);
+	snd_hda_power_up_pm(codec);
 
 	ca0132_init_unsol(codec);
 
@@ -4581,7 +4581,7 @@ static int ca0132_init(struct hda_codec *codec)
 
 	snd_hda_jack_report_sync(codec);
 
-	snd_hda_power_down(codec);
+	snd_hda_power_down_pm(codec);
 
 	return 0;
 }
diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c
index 7e9ff7b16e56..837c31ec93db 100644
--- a/sound/pci/hda/patch_hdmi.c
+++ b/sound/pci/hda/patch_hdmi.c
@@ -1546,7 +1546,7 @@ static bool hdmi_present_sense(struct hdmi_spec_per_pin *per_pin, int repoll)
 	bool eld_changed = false;
 	bool ret;
 
-	snd_hda_power_up(codec);
+	snd_hda_power_up_pm(codec);
 	present = snd_hda_pin_sense(codec, pin_nid);
 
 	mutex_lock(&per_pin->lock);
@@ -1632,7 +1632,7 @@ static bool hdmi_present_sense(struct hdmi_spec_per_pin *per_pin, int repoll)
 		jack->block_report = !ret;
 
 	mutex_unlock(&per_pin->lock);
-	snd_hda_power_down(codec);
+	snd_hda_power_down_pm(codec);
 	return ret;
 }
 
