HID: rmi: only bind the hid-rmi driver to the mouse interface of composite USB devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [hid] rmi: only bind the hid-rmi driver to the mouse interface of composite USB devices (Aristeu Rozanski) [1075108 1075114]
Rebuild_FUZZ: 97.01%
commit-author Andrew Duggan <aduggan@synaptics.com>
commit e19ff99f256aeeff6c07b373e01883b72e049552
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/e19ff99f.failed

On composite HID devices there may be multiple HID devices on separate interfaces, but hid-rmi
should only bind to the mouse interface. One example is the Dell Venue 11 Pro's keyboard dock
which contains a composite USB device with a HID touchpad and HID keyboard on separate intefaces.
Since the USB Vendor ID is Synaptic's, hid-core is currently trying to bind hid-rmi to all\of
the HID devices. This patch ensures that hid-rmi only binds to the mouse interface.

related bug:
https://bugzilla.kernel.org/show_bug.cgi?id=80091

	Signed-off-by: Andrew Duggan <aduggan@synaptics.com>
	Reviewed-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Jiri Kosina <jkosina@suse.cz>
(cherry picked from commit e19ff99f256aeeff6c07b373e01883b72e049552)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hid/hid-core.c
diff --cc drivers/hid/hid-core.c
index c4e5cdfa5d24,f10e768b4caf..000000000000
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@@ -692,48 -745,51 +692,77 @@@ static void hid_scan_usage(struct hid_d
   */
  static int hid_scan_report(struct hid_device *hid)
  {
 -	struct hid_parser *parser;
 -	struct hid_item item;
 +	unsigned int page = 0, delim = 0;
  	__u8 *start = hid->dev_rdesc;
  	__u8 *end = start + hid->dev_rsize;
 -	static int (*dispatch_type[])(struct hid_parser *parser,
 -				      struct hid_item *item) = {
 -		hid_scan_main,
 -		hid_parser_global,
 -		hid_parser_local,
 -		hid_parser_reserved
 -	};
 -
 -	parser = vzalloc(sizeof(struct hid_parser));
 -	if (!parser)
 -		return -ENOMEM;
 +	unsigned int u, u_min = 0, u_max = 0;
 +	struct hid_item item;
  
 -	parser->device = hid;
  	hid->group = HID_GROUP_GENERIC;
 +	while ((start = fetch_item(start, end, &item)) != NULL) {
 +		if (item.format != HID_ITEM_FORMAT_SHORT)
 +			return -EINVAL;
 +		if (item.type == HID_ITEM_TYPE_GLOBAL) {
 +			if (item.tag == HID_GLOBAL_ITEM_TAG_USAGE_PAGE)
 +				page = item_udata(&item) << 16;
 +		} else if (item.type == HID_ITEM_TYPE_LOCAL) {
 +			if (delim > 1)
 +				break;
 +			u = item_udata(&item);
 +			if (item.size <= 2)
 +				u += page;
 +			switch (item.tag) {
 +			case HID_LOCAL_ITEM_TAG_DELIMITER:
 +				delim += !!u;
 +				break;
 +			case HID_LOCAL_ITEM_TAG_USAGE:
 +				hid_scan_usage(hid, u);
 +				break;
 +			case HID_LOCAL_ITEM_TAG_USAGE_MINIMUM:
 +				u_min = u;
 +				break;
 +			case HID_LOCAL_ITEM_TAG_USAGE_MAXIMUM:
 +				u_max = u;
 +				for (u = u_min; u <= u_max; u++)
 +					hid_scan_usage(hid, u);
 +				break;
 +			}
 +		} else if (page == HID_UP_SENSOR &&
 +			item.type == HID_ITEM_TYPE_MAIN &&
 +			item.tag == HID_MAIN_ITEM_TAG_BEGIN_COLLECTION &&
 +			(item_udata(&item) & 0xff) == HID_COLLECTION_PHYSICAL)
 +			hid->group = HID_GROUP_SENSOR_HUB;
 +	}
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * The parsing is simpler than the one in hid_open_report() as we should
+ 	 * be robust against hid errors. Those errors will be raised by
+ 	 * hid_open_report() anyway.
+ 	 */
+ 	while ((start = fetch_item(start, end, &item)) != NULL)
+ 		dispatch_type[item.type](parser, &item);
+ 
+ 	/*
+ 	 * Handle special flags set during scanning.
+ 	 */
+ 	if ((parser->scan_flags & HID_SCAN_FLAG_MT_WIN_8) &&
+ 	    (hid->group == HID_GROUP_MULTITOUCH))
+ 		hid->group = HID_GROUP_MULTITOUCH_WIN_8;
+ 
+ 	/*
+ 	* Vendor specific handlings
+ 	*/
+ 	if ((hid->vendor == USB_VENDOR_ID_SYNAPTICS) &&
+ 	    (hid->group == HID_GROUP_GENERIC) &&
+ 	    /* only bind to the mouse interface of composite USB devices */
+ 	    (hid->bus != BUS_USB || hid->type == HID_TYPE_USBMOUSE))
+ 		/* hid-rmi should take care of them, not hid-generic */
+ 		hid->group = HID_GROUP_RMI;
+ 
+ 	vfree(parser);
++>>>>>>> e19ff99f256a (HID: rmi: only bind the hid-rmi driver to the mouse interface of composite USB devices)
  	return 0;
  }
  
* Unmerged path drivers/hid/hid-core.c
