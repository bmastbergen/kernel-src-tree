ovl: discard independent cursor in readdir()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author hujianyang <hujianyang@huawei.com>
commit 4330397e4e8a662f36d101659e2a59ce32e76ff4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4330397e.failed

Since the ovl_dir_cache is stable during a directory reading, the cursor
of struct ovl_dir_file don't need to be an independent entry in the list
of a merged directory.

This patch changes *cursor* to a pointer which points to the entry in the
ovl_dir_cache. After this, we don't need to check *is_cursor* either.

	Signed-off-by: hujianyang <hujianyang@huawei.com>
	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit 4330397e4e8a662f36d101659e2a59ce32e76ff4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/readdir.c
diff --cc fs/overlayfs/readdir.c
index f4eb1dbe8305,dcf1d412888d..000000000000
--- a/fs/overlayfs/readdir.c
+++ b/fs/overlayfs/readdir.c
@@@ -92,16 -87,41 +91,53 @@@ static struct ovl_cache_entry *ovl_cach
  	size_t size = offsetof(struct ovl_cache_entry, name[len + 1]);
  
  	p = kmalloc(size, GFP_KERNEL);
++<<<<<<< HEAD
 +	if (p) {
 +		memcpy(p->name, name, len);
 +		p->name[len] = '\0';
 +		p->len = len;
 +		p->type = d_type;
 +		p->ino = ino;
 +		p->is_whiteout = false;
 +		p->is_cursor = false;
++=======
+ 	if (!p)
+ 		return NULL;
+ 
+ 	memcpy(p->name, name, len);
+ 	p->name[len] = '\0';
+ 	p->len = len;
+ 	p->type = d_type;
+ 	p->ino = ino;
+ 	p->is_whiteout = false;
+ 
+ 	if (d_type == DT_CHR) {
+ 		struct dentry *dentry;
+ 		const struct cred *old_cred;
+ 		struct cred *override_cred;
+ 
+ 		override_cred = prepare_creds();
+ 		if (!override_cred) {
+ 			kfree(p);
+ 			return NULL;
+ 		}
+ 
+ 		/*
+ 		 * CAP_DAC_OVERRIDE for lookup
+ 		 */
+ 		cap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE);
+ 		old_cred = override_creds(override_cred);
+ 
+ 		dentry = lookup_one_len(name, dir, len);
+ 		if (!IS_ERR(dentry)) {
+ 			p->is_whiteout = ovl_is_whiteout(dentry);
+ 			dput(dentry);
+ 		}
+ 		revert_creds(old_cred);
+ 		put_cred(override_cred);
++>>>>>>> 4330397e4e8a (ovl: discard independent cursor in readdir())
  	}
 +
  	return p;
  }
  
@@@ -350,17 -341,13 +385,21 @@@ static int ovl_readdir(struct file *fil
  {
  	struct ovl_dir_file *od = file->private_data;
  	struct dentry *dentry = file->f_path.dentry;
++<<<<<<< HEAD
 +	int res;
++=======
+ 	struct ovl_cache_entry *p;
++>>>>>>> 4330397e4e8a (ovl: discard independent cursor in readdir())
  
 -	if (!ctx->pos)
 +	if (!file->f_pos)
  		ovl_dir_reset(file);
  
 -	if (od->is_real)
 -		return iterate_dir(od->realfile, ctx);
 +	if (od->is_real) {
 +		res = vfs_readdir(od->realfile, filler, buf);
 +		file->f_pos = od->realfile->f_pos;
 +
 +		return res;
 +	}
  
  	if (!od->cache) {
  		struct ovl_dir_cache *cache;
@@@ -370,27 -357,16 +409,37 @@@
  			return PTR_ERR(cache);
  
  		od->cache = cache;
 -		ovl_seek_cursor(od, ctx->pos);
 +		ovl_seek_cursor(od, file->f_pos);
  	}
  
++<<<<<<< HEAD
 +	while (od->cursor.l_node.next != &od->cache->entries) {
 +		int over;
 +		loff_t off;
 +		struct ovl_cache_entry *p;
 +
 +		p = list_entry(od->cursor.l_node.next, struct ovl_cache_entry, l_node);
 +		off = file->f_pos;
 +		/* Skip cursors */
 +		if (!p->is_cursor) {
 +			if (!p->is_whiteout) {
 +				over = filler(buf, p->name, p->len, off, p->ino,
 +					      p->type);
 +				if (over)
 +					break;
 +			}
 +			file->f_pos++;
 +		}
 +		list_move(&od->cursor.l_node, &p->l_node);
++=======
+ 	while (od->cursor != &od->cache->entries) {
+ 		p = list_entry(od->cursor, struct ovl_cache_entry, l_node);
+ 		if (!p->is_whiteout)
+ 			if (!dir_emit(ctx, p->name, p->len, p->ino, p->type))
+ 				break;
+ 		od->cursor = p->l_node.next;
+ 		ctx->pos++;
++>>>>>>> 4330397e4e8a (ovl: discard independent cursor in readdir())
  	}
  	return 0;
  }
* Unmerged path fs/overlayfs/readdir.c
