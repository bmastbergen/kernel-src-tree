nfsd: add trace events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 31ef83dc053835fc14741426e20c60dbbba8c13d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/31ef83dc.failed

For now just a few simple events to trace the layout stateid lifetime, but
these already were enough to find several bugs in the Linux client layout
stateid handling.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 31ef83dc053835fc14741426e20c60dbbba8c13d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4layouts.c
#	fs/nfsd/nfs4proc.c
diff --cc fs/nfsd/nfs4proc.c
index 3e6a2e352c96,d30bea8d0277..000000000000
--- a/fs/nfsd/nfs4proc.c
+++ b/fs/nfsd/nfs4proc.c
@@@ -41,6 -42,9 +41,12 @@@
  #include "vfs.h"
  #include "current_stateid.h"
  #include "netns.h"
++<<<<<<< HEAD
++=======
+ #include "acl.h"
+ #include "pnfs.h"
+ #include "trace.h"
++>>>>>>> 31ef83dc0538 (nfsd: add trace events)
  
  #ifdef CONFIG_NFSD_V4_SECURITY_LABEL
  #include <linux/security.h>
@@@ -1095,6 -1180,259 +1101,262 @@@ nfsd4_verify(struct svc_rqst *rqstp, st
  	return status == nfserr_same ? nfs_ok : status;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NFSD_PNFS
+ static const struct nfsd4_layout_ops *
+ nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)
+ {
+ 	if (!exp->ex_layout_type) {
+ 		dprintk("%s: export does not support pNFS\n", __func__);
+ 		return NULL;
+ 	}
+ 
+ 	if (exp->ex_layout_type != layout_type) {
+ 		dprintk("%s: layout type %d not supported\n",
+ 			__func__, layout_type);
+ 		return NULL;
+ 	}
+ 
+ 	return nfsd4_layout_ops[layout_type];
+ }
+ 
+ static __be32
+ nfsd4_getdeviceinfo(struct svc_rqst *rqstp,
+ 		struct nfsd4_compound_state *cstate,
+ 		struct nfsd4_getdeviceinfo *gdp)
+ {
+ 	const struct nfsd4_layout_ops *ops;
+ 	struct nfsd4_deviceid_map *map;
+ 	struct svc_export *exp;
+ 	__be32 nfserr;
+ 
+ 	dprintk("%s: layout_type %u dev_id [0x%llx:0x%x] maxcnt %u\n",
+ 	       __func__,
+ 	       gdp->gd_layout_type,
+ 	       gdp->gd_devid.fsid_idx, gdp->gd_devid.generation,
+ 	       gdp->gd_maxcount);
+ 
+ 	map = nfsd4_find_devid_map(gdp->gd_devid.fsid_idx);
+ 	if (!map) {
+ 		dprintk("%s: couldn't find device ID to export mapping!\n",
+ 			__func__);
+ 		return nfserr_noent;
+ 	}
+ 
+ 	exp = rqst_exp_find(rqstp, map->fsid_type, map->fsid);
+ 	if (IS_ERR(exp)) {
+ 		dprintk("%s: could not find device id\n", __func__);
+ 		return nfserr_noent;
+ 	}
+ 
+ 	nfserr = nfserr_layoutunavailable;
+ 	ops = nfsd4_layout_verify(exp, gdp->gd_layout_type);
+ 	if (!ops)
+ 		goto out;
+ 
+ 	nfserr = nfs_ok;
+ 	if (gdp->gd_maxcount != 0)
+ 		nfserr = ops->proc_getdeviceinfo(exp->ex_path.mnt->mnt_sb, gdp);
+ 
+ 	gdp->gd_notify_types &= ops->notify_types;
+ 	exp_put(exp);
+ out:
+ 	return nfserr;
+ }
+ 
+ static __be32
+ nfsd4_layoutget(struct svc_rqst *rqstp,
+ 		struct nfsd4_compound_state *cstate,
+ 		struct nfsd4_layoutget *lgp)
+ {
+ 	struct svc_fh *current_fh = &cstate->current_fh;
+ 	const struct nfsd4_layout_ops *ops;
+ 	struct nfs4_layout_stateid *ls;
+ 	__be32 nfserr;
+ 	int accmode;
+ 
+ 	switch (lgp->lg_seg.iomode) {
+ 	case IOMODE_READ:
+ 		accmode = NFSD_MAY_READ;
+ 		break;
+ 	case IOMODE_RW:
+ 		accmode = NFSD_MAY_READ | NFSD_MAY_WRITE;
+ 		break;
+ 	default:
+ 		dprintk("%s: invalid iomode %d\n",
+ 			__func__, lgp->lg_seg.iomode);
+ 		nfserr = nfserr_badiomode;
+ 		goto out;
+ 	}
+ 
+ 	nfserr = fh_verify(rqstp, current_fh, 0, accmode);
+ 	if (nfserr)
+ 		goto out;
+ 
+ 	nfserr = nfserr_layoutunavailable;
+ 	ops = nfsd4_layout_verify(current_fh->fh_export, lgp->lg_layout_type);
+ 	if (!ops)
+ 		goto out;
+ 
+ 	/*
+ 	 * Verify minlength and range as per RFC5661:
+ 	 *  o  If loga_length is less than loga_minlength,
+ 	 *     the metadata server MUST return NFS4ERR_INVAL.
+ 	 *  o  If the sum of loga_offset and loga_minlength exceeds
+ 	 *     NFS4_UINT64_MAX, and loga_minlength is not
+ 	 *     NFS4_UINT64_MAX, the error NFS4ERR_INVAL MUST result.
+ 	 *  o  If the sum of loga_offset and loga_length exceeds
+ 	 *     NFS4_UINT64_MAX, and loga_length is not NFS4_UINT64_MAX,
+ 	 *     the error NFS4ERR_INVAL MUST result.
+ 	 */
+ 	nfserr = nfserr_inval;
+ 	if (lgp->lg_seg.length < lgp->lg_minlength ||
+ 	    (lgp->lg_minlength != NFS4_MAX_UINT64 &&
+ 	     lgp->lg_minlength > NFS4_MAX_UINT64 - lgp->lg_seg.offset) ||
+ 	    (lgp->lg_seg.length != NFS4_MAX_UINT64 &&
+ 	     lgp->lg_seg.length > NFS4_MAX_UINT64 - lgp->lg_seg.offset))
+ 		goto out;
+ 	if (lgp->lg_seg.length == 0)
+ 		goto out;
+ 
+ 	nfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lgp->lg_sid,
+ 						true, lgp->lg_layout_type, &ls);
+ 	if (nfserr) {
+ 		trace_layout_get_lookup_fail(&lgp->lg_sid);
+ 		goto out;
+ 	}
+ 
+ 	nfserr = nfserr_recallconflict;
+ 	if (atomic_read(&ls->ls_stid.sc_file->fi_lo_recalls))
+ 		goto out_put_stid;
+ 
+ 	nfserr = ops->proc_layoutget(current_fh->fh_dentry->d_inode,
+ 				     current_fh, lgp);
+ 	if (nfserr)
+ 		goto out_put_stid;
+ 
+ 	nfserr = nfsd4_insert_layout(lgp, ls);
+ 
+ out_put_stid:
+ 	nfs4_put_stid(&ls->ls_stid);
+ out:
+ 	return nfserr;
+ }
+ 
+ static __be32
+ nfsd4_layoutcommit(struct svc_rqst *rqstp,
+ 		struct nfsd4_compound_state *cstate,
+ 		struct nfsd4_layoutcommit *lcp)
+ {
+ 	const struct nfsd4_layout_seg *seg = &lcp->lc_seg;
+ 	struct svc_fh *current_fh = &cstate->current_fh;
+ 	const struct nfsd4_layout_ops *ops;
+ 	loff_t new_size = lcp->lc_last_wr + 1;
+ 	struct inode *inode;
+ 	struct nfs4_layout_stateid *ls;
+ 	__be32 nfserr;
+ 
+ 	nfserr = fh_verify(rqstp, current_fh, 0, NFSD_MAY_WRITE);
+ 	if (nfserr)
+ 		goto out;
+ 
+ 	nfserr = nfserr_layoutunavailable;
+ 	ops = nfsd4_layout_verify(current_fh->fh_export, lcp->lc_layout_type);
+ 	if (!ops)
+ 		goto out;
+ 	inode = current_fh->fh_dentry->d_inode;
+ 
+ 	nfserr = nfserr_inval;
+ 	if (new_size <= seg->offset) {
+ 		dprintk("pnfsd: last write before layout segment\n");
+ 		goto out;
+ 	}
+ 	if (new_size > seg->offset + seg->length) {
+ 		dprintk("pnfsd: last write beyond layout segment\n");
+ 		goto out;
+ 	}
+ 	if (!lcp->lc_newoffset && new_size > i_size_read(inode)) {
+ 		dprintk("pnfsd: layoutcommit beyond EOF\n");
+ 		goto out;
+ 	}
+ 
+ 	nfserr = nfsd4_preprocess_layout_stateid(rqstp, cstate, &lcp->lc_sid,
+ 						false, lcp->lc_layout_type,
+ 						&ls);
+ 	if (nfserr) {
+ 		trace_layout_commit_lookup_fail(&lcp->lc_sid);
+ 		/* fixup error code as per RFC5661 */
+ 		if (nfserr == nfserr_bad_stateid)
+ 			nfserr = nfserr_badlayout;
+ 		goto out;
+ 	}
+ 
+ 	nfserr = ops->proc_layoutcommit(inode, lcp);
+ 	if (nfserr)
+ 		goto out_put_stid;
+ 
+ 	if (new_size > i_size_read(inode)) {
+ 		lcp->lc_size_chg = 1;
+ 		lcp->lc_newsize = new_size;
+ 	} else {
+ 		lcp->lc_size_chg = 0;
+ 	}
+ 
+ out_put_stid:
+ 	nfs4_put_stid(&ls->ls_stid);
+ out:
+ 	return nfserr;
+ }
+ 
+ static __be32
+ nfsd4_layoutreturn(struct svc_rqst *rqstp,
+ 		struct nfsd4_compound_state *cstate,
+ 		struct nfsd4_layoutreturn *lrp)
+ {
+ 	struct svc_fh *current_fh = &cstate->current_fh;
+ 	__be32 nfserr;
+ 
+ 	nfserr = fh_verify(rqstp, current_fh, 0, NFSD_MAY_NOP);
+ 	if (nfserr)
+ 		goto out;
+ 
+ 	nfserr = nfserr_layoutunavailable;
+ 	if (!nfsd4_layout_verify(current_fh->fh_export, lrp->lr_layout_type))
+ 		goto out;
+ 
+ 	switch (lrp->lr_seg.iomode) {
+ 	case IOMODE_READ:
+ 	case IOMODE_RW:
+ 	case IOMODE_ANY:
+ 		break;
+ 	default:
+ 		dprintk("%s: invalid iomode %d\n", __func__,
+ 			lrp->lr_seg.iomode);
+ 		nfserr = nfserr_inval;
+ 		goto out;
+ 	}
+ 
+ 	switch (lrp->lr_return_type) {
+ 	case RETURN_FILE:
+ 		nfserr = nfsd4_return_file_layouts(rqstp, cstate, lrp);
+ 		break;
+ 	case RETURN_FSID:
+ 	case RETURN_ALL:
+ 		nfserr = nfsd4_return_client_layouts(rqstp, cstate, lrp);
+ 		break;
+ 	default:
+ 		dprintk("%s: invalid return_type %d\n", __func__,
+ 			lrp->lr_return_type);
+ 		nfserr = nfserr_inval;
+ 		break;
+ 	}
+ out:
+ 	return nfserr;
+ }
+ #endif /* CONFIG_NFSD_PNFS */
+ 
++>>>>>>> 31ef83dc0538 (nfsd: add trace events)
  /*
   * NULL call.
   */
* Unmerged path fs/nfsd/nfs4layouts.c
diff --git a/fs/nfsd/Makefile b/fs/nfsd/Makefile
index af32ef06b4fe..5b7733dd0aed 100644
--- a/fs/nfsd/Makefile
+++ b/fs/nfsd/Makefile
@@ -2,9 +2,14 @@
 # Makefile for the Linux nfs server
 #
 
+ccflags-y += -I$(src)			# needed for trace events
+
 obj-$(CONFIG_NFSD)	+= nfsd.o
 
-nfsd-y 			:= nfssvc.o nfsctl.o nfsproc.o nfsfh.o vfs.o \
+# this one should be compiled first, as the tracing macros can easily blow up
+nfsd-y			+= trace.o
+
+nfsd-y 			+= nfssvc.o nfsctl.o nfsproc.o nfsfh.o vfs.o \
 			   export.o auth.o lockd.o nfscache.o nfsxdr.o stats.o
 nfsd-$(CONFIG_NFSD_FAULT_INJECTION) += fault_inject.o
 nfsd-$(CONFIG_NFSD_V2_ACL) += nfs2acl.o
* Unmerged path fs/nfsd/nfs4layouts.c
* Unmerged path fs/nfsd/nfs4proc.c
diff --git a/fs/nfsd/trace.c b/fs/nfsd/trace.c
new file mode 100644
index 000000000000..82f89070594c
--- /dev/null
+++ b/fs/nfsd/trace.c
@@ -0,0 +1,5 @@
+
+#include "state.h"
+
+#define CREATE_TRACE_POINTS
+#include "trace.h"
diff --git a/fs/nfsd/trace.h b/fs/nfsd/trace.h
new file mode 100644
index 000000000000..c668520c344b
--- /dev/null
+++ b/fs/nfsd/trace.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2014 Christoph Hellwig.
+ */
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM nfsd
+
+#if !defined(_NFSD_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _NFSD_TRACE_H
+
+#include <linux/tracepoint.h>
+
+DECLARE_EVENT_CLASS(nfsd_stateid_class,
+	TP_PROTO(stateid_t *stp),
+	TP_ARGS(stp),
+	TP_STRUCT__entry(
+		__field(u32, cl_boot)
+		__field(u32, cl_id)
+		__field(u32, si_id)
+		__field(u32, si_generation)
+	),
+	TP_fast_assign(
+		__entry->cl_boot = stp->si_opaque.so_clid.cl_boot;
+		__entry->cl_id = stp->si_opaque.so_clid.cl_id;
+		__entry->si_id = stp->si_opaque.so_id;
+		__entry->si_generation = stp->si_generation;
+	),
+	TP_printk("client %08x:%08x stateid %08x:%08x",
+		__entry->cl_boot,
+		__entry->cl_id,
+		__entry->si_id,
+		__entry->si_generation)
+)
+
+#define DEFINE_STATEID_EVENT(name) \
+DEFINE_EVENT(nfsd_stateid_class, name, \
+	TP_PROTO(stateid_t *stp), \
+	TP_ARGS(stp))
+DEFINE_STATEID_EVENT(layoutstate_alloc);
+DEFINE_STATEID_EVENT(layoutstate_unhash);
+DEFINE_STATEID_EVENT(layoutstate_free);
+DEFINE_STATEID_EVENT(layout_get_lookup_fail);
+DEFINE_STATEID_EVENT(layout_commit_lookup_fail);
+DEFINE_STATEID_EVENT(layout_return_lookup_fail);
+DEFINE_STATEID_EVENT(layout_recall);
+DEFINE_STATEID_EVENT(layout_recall_done);
+DEFINE_STATEID_EVENT(layout_recall_fail);
+DEFINE_STATEID_EVENT(layout_recall_release);
+
+#endif /* _NFSD_TRACE_H */
+
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH .
+#define TRACE_INCLUDE_FILE trace
+#include <trace/define_trace.h>
