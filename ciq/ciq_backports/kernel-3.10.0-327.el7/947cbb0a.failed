net/mlx4_en: Support for configurable RSS hash function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] mlx4_en: Support for configurable RSS hash function (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 96.23%
commit-author Eyal Perry <eyalpe@mellanox.com>
commit 947cbb0ac242096d60380952ec1a1761372cba66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/947cbb0a.failed

The ConnectX HW is capable of using one of the following hash functions:
Toeplitz and an XOR hash function. This patch extends the implementation
of the mlx4_en driver set/get_rxfh callbacks to support getting and
setting the RSS hash function used by the device.

	Signed-off-by: Eyal Perry <eyalpe@mellanox.com>
	Signed-off-by: Amir Vadai <amirv@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 947cbb0ac242096d60380952ec1a1761372cba66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
#	drivers/net/ethernet/mellanox/mlx4/en_rx.c
#	drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
diff --cc drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index 1b8da57abd19,90e0f045a6bc..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@@ -991,7 -973,34 +991,38 @@@ static u32 mlx4_en_get_rxfh_indir_size(
  	return priv->rx_ring_num;
  }
  
++<<<<<<< HEAD
 +static int mlx4_en_get_rxfh_indir(struct net_device *dev, u32 *ring_index)
++=======
+ static u32 mlx4_en_get_rxfh_key_size(struct net_device *netdev)
+ {
+ 	return MLX4_EN_RSS_KEY_SIZE;
+ }
+ 
+ static int mlx4_en_check_rxfh_func(struct net_device *dev, u8 hfunc)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 
+ 	/* check if requested function is supported by the device */
+ 	if ((hfunc == ETH_RSS_HASH_TOP &&
+ 	     !(priv->mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_RSS_TOP)) ||
+ 	    (hfunc == ETH_RSS_HASH_XOR &&
+ 	     !(priv->mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_RSS_XOR)))
+ 		return -EINVAL;
+ 
+ 	priv->rss_hash_fn = hfunc;
+ 	if (hfunc == ETH_RSS_HASH_TOP && !(dev->features & NETIF_F_RXHASH))
+ 		en_warn(priv,
+ 			"Toeplitz hash function should be used in conjunction with RX hashing for optimal performance\n");
+ 	if (hfunc == ETH_RSS_HASH_XOR && (dev->features & NETIF_F_RXHASH))
+ 		en_warn(priv,
+ 			"Enabling both XOR Hash function and RX Hashing can limit RPS functionality\n");
+ 	return 0;
+ }
+ 
+ static int mlx4_en_get_rxfh(struct net_device *dev, u32 *ring_index, u8 *key,
+ 			    u8 *hfunc)
++>>>>>>> 947cbb0ac242 (net/mlx4_en: Support for configurable RSS hash function)
  {
  	struct mlx4_en_priv *priv = netdev_priv(dev);
  	struct mlx4_en_rss_map *rss_map = &priv->rss_map;
@@@ -1006,7 -1015,12 +1037,14 @@@
  		ring_index[n] = rss_map->qps[n % rss_rings].qpn -
  			rss_map->base_qpn;
  	}
- 
++<<<<<<< HEAD
++
++=======
+ 	if (key)
+ 		memcpy(key, priv->rss_key, MLX4_EN_RSS_KEY_SIZE);
+ 	if (hfunc)
+ 		*hfunc = priv->rss_hash_fn;
++>>>>>>> 947cbb0ac242 (net/mlx4_en: Support for configurable RSS hash function)
  	return err;
  }
  
@@@ -1044,7 -1066,10 +1088,14 @@@ static int mlx4_en_set_rxfh_indir(struc
  		mlx4_en_stop_port(dev, 1);
  	}
  
++<<<<<<< HEAD
 +	priv->prof->rss_rings = rss_rings;
++=======
+ 	if (ring_index)
+ 		priv->prof->rss_rings = rss_rings;
+ 	if (key)
+ 		memcpy(priv->rss_key, key, MLX4_EN_RSS_KEY_SIZE);
++>>>>>>> 947cbb0ac242 (net/mlx4_en: Support for configurable RSS hash function)
  
  	if (port_up) {
  		err = mlx4_en_start_port(dev);
diff --cc drivers/net/ethernet/mellanox/mlx4/en_rx.c
index e559ff412170,4ca396e3168f..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_rx.c
@@@ -1263,9 -1223,19 +1263,25 @@@ int mlx4_en_config_rss_steer(struct mlx
  
  	rss_context->flags = rss_mask;
  	rss_context->hash_fn = MLX4_RSS_HASH_TOP;
++<<<<<<< HEAD
 +	for (i = 0; i < 10; i++)
 +		rss_context->rss_key[i] = cpu_to_be32(rsskey[i]);
 +
++=======
+ 	if (priv->rss_hash_fn == ETH_RSS_HASH_XOR) {
+ 		rss_context->hash_fn = MLX4_RSS_HASH_XOR;
+ 	} else if (priv->rss_hash_fn == ETH_RSS_HASH_TOP) {
+ 		rss_context->hash_fn = MLX4_RSS_HASH_TOP;
+ 		memcpy(rss_context->rss_key, priv->rss_key,
+ 		       MLX4_EN_RSS_KEY_SIZE);
+ 		netdev_rss_key_fill(rss_context->rss_key,
+ 				    MLX4_EN_RSS_KEY_SIZE);
+ 	} else {
+ 		en_err(priv, "Unknown RSS hash function requested\n");
+ 		err = -EINVAL;
+ 		goto indir_err;
+ 	}
++>>>>>>> 947cbb0ac242 (net/mlx4_en: Support for configurable RSS hash function)
  	err = mlx4_qp_to_ready(mdev->dev, &priv->res.mtt, &context,
  			       &rss_map->indir_qp, &rss_map->indir_state);
  	if (err)
diff --cc drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
index 16811bfb94e5,ac48a8d91501..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
@@@ -587,6 -617,8 +586,11 @@@ struct mlx4_en_priv 
  	__be16 vxlan_port;
  
  	u32 pflags;
++<<<<<<< HEAD
++=======
+ 	u8 rss_key[MLX4_EN_RSS_KEY_SIZE];
+ 	u8 rss_hash_fn;
++>>>>>>> 947cbb0ac242 (net/mlx4_en: Support for configurable RSS hash function)
  };
  
  enum mlx4_en_wol {
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 9a988b45c844..21bb8aff6a30 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -2616,6 +2616,17 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	if (mdev->dev->caps.steering_mode != MLX4_STEERING_MODE_A0)
 		dev->priv_flags |= IFF_UNICAST_FLT;
 
+	/* Setting a default hash function value */
+	if (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_RSS_TOP) {
+		priv->rss_hash_fn = ETH_RSS_HASH_TOP;
+	} else if (mdev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_RSS_XOR) {
+		priv->rss_hash_fn = ETH_RSS_HASH_XOR;
+	} else {
+		en_warn(priv,
+			"No RSS hash capabilities exposed, using Toeplitz\n");
+		priv->rss_hash_fn = ETH_RSS_HASH_TOP;
+	}
+
 	mdev->pndev[port] = dev;
 
 	netif_carrier_off(dev);
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_rx.c
* Unmerged path drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
