md: re-add a failed disk

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [md] re-add a failed disk (Jes Sorensen) [1150149 1173510 1194720]
Rebuild_FUZZ: 90.91%
commit-author Goldwyn Rodrigues <rgoldwyn@suse.de>
commit a6da4ef85cef0382244fc588c901e133a2ec5109
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a6da4ef8.failed

This adds the capability of re-adding a failed disk by
writing "re-add" to /sys/block/mdXX/md/dev-YYY/state.

This facilitates adding disks which have encountered a temporary
error such as a network disconnection/hiccup in an iSCSI device,
or a SAN cable disconnection which has been restored. In such
a situation, you do not need to remove and re-add the device.
Writing re-add to the failed device's state would add it again
to the array and perform the recovery of only the blocks which
were written after the device failed.

This works for generic md, and is not related to clustering. However,
this patch is to ease re-add operations listed above in clustering
environments.

	Signed-off-by: Goldwyn Rodrigues <rgoldwyn@suse.com>
	Signed-off-by: NeilBrown <neilb@suse.de>
(cherry picked from commit a6da4ef85cef0382244fc588c901e133a2ec5109)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/md.c
diff --cc drivers/md/md.c
index 5d8c7c589a1e,429e95e9a942..000000000000
--- a/drivers/md/md.c
+++ b/drivers/md/md.c
@@@ -2531,7 -2373,38 +2531,37 @@@ repeat
  		wake_up(&rdev->blocked_wait);
  	}
  }
 -EXPORT_SYMBOL(md_update_sb);
  
+ static int add_bound_rdev(struct md_rdev *rdev)
+ {
+ 	struct mddev *mddev = rdev->mddev;
+ 	int err = 0;
+ 
+ 	if (!mddev->pers->hot_remove_disk) {
+ 		/* If there is hot_add_disk but no hot_remove_disk
+ 		 * then added disks for geometry changes,
+ 		 * and should be added immediately.
+ 		 */
+ 		super_types[mddev->major_version].
+ 			validate_super(mddev, rdev);
+ 		err = mddev->pers->hot_add_disk(mddev, rdev);
+ 		if (err) {
+ 			unbind_rdev_from_array(rdev);
+ 			export_rdev(rdev);
+ 			return err;
+ 		}
+ 	}
+ 	sysfs_notify_dirent_safe(rdev->sysfs_state);
+ 
+ 	set_bit(MD_CHANGE_DEVS, &mddev->flags);
+ 	if (mddev->degraded)
+ 		set_bit(MD_RECOVERY_RECOVER, &mddev->recovery);
+ 	set_bit(MD_RECOVERY_NEEDED, &mddev->recovery);
+ 	md_new_event(mddev);
+ 	md_wakeup_thread(mddev->thread);
+ 	return 0;
+ }
+ 
  /* words written to sysfs files may, or may not, be \n terminated.
   * We want to accept with case. For this we use cmd_match.
   */
@@@ -5786,31 -5886,38 +5822,27 @@@ static int add_new_disk(struct mddev * 
  		else
  			clear_bit(WriteMostly, &rdev->flags);
  
 -		/*
 -		 * check whether the device shows up in other nodes
 -		 */
 -		if (mddev_is_clustered(mddev)) {
 -			if (info->state & (1 << MD_DISK_CANDIDATE)) {
 -				/* Through --cluster-confirm */
 -				set_bit(Candidate, &rdev->flags);
 -				err = md_cluster_ops->new_disk_ack(mddev, true);
 -				if (err) {
 -					export_rdev(rdev);
 -					return err;
 -				}
 -			} else if (info->state & (1 << MD_DISK_CLUSTER_ADD)) {
 -				/* --add initiated by this node */
 -				err = md_cluster_ops->add_new_disk_start(mddev, rdev);
 -				if (err) {
 -					md_cluster_ops->add_new_disk_finish(mddev);
 -					export_rdev(rdev);
 -					return err;
 -				}
 -			}
 -		}
 -
  		rdev->raid_disk = -1;
  		err = bind_rdev_to_array(rdev, mddev);
- 		if (!err && !mddev->pers->hot_remove_disk) {
- 			/* If there is hot_add_disk but no hot_remove_disk
- 			 * then added disks for geometry changes,
- 			 * and should be added immediately.
- 			 */
- 			super_types[mddev->major_version].
- 				validate_super(mddev, rdev);
- 			err = mddev->pers->hot_add_disk(mddev, rdev);
- 			if (err)
- 				unbind_rdev_from_array(rdev);
- 		}
  		if (err)
  			export_rdev(rdev);
  		else
++<<<<<<< HEAD
 +			sysfs_notify_dirent_safe(rdev->sysfs_state);
 +
 +		set_bit(MD_CHANGE_DEVS, &mddev->flags);
 +		if (mddev->degraded)
 +			set_bit(MD_RECOVERY_RECOVER, &mddev->recovery);
 +		set_bit(MD_RECOVERY_NEEDED, &mddev->recovery);
 +		if (!err)
 +			md_new_event(mddev);
 +		md_wakeup_thread(mddev->thread);
++=======
+ 			err = add_bound_rdev(rdev);
+ 		if (mddev_is_clustered(mddev) &&
+ 				(info->state & (1 << MD_DISK_CLUSTER_ADD)))
+ 			md_cluster_ops->add_new_disk_finish(mddev);
++>>>>>>> a6da4ef85cef (md: re-add a failed disk)
  		return err;
  	}
  
* Unmerged path drivers/md/md.c
