ipmi: Fix a memory ordering issue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Corey Minyard <cminyard@mvista.com>
commit 1d86e29b4a612eb01c39daa48749ab7964e77e03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/1d86e29b.failed

From a locking point of view it is safe to check waiting_msg without
a lock, but there is a memory ordering issue that causes it to
possibly not be set right when viewed from another processor.  We are
already claiming a lock right after that, move the check to inside
the lock to enforce the memory ordering.

	Signed-off-by: Corey Minyard <cminyard@mvista.com>
(cherry picked from commit 1d86e29b4a612eb01c39daa48749ab7964e77e03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/char/ipmi/ipmi_si_intf.c
diff --cc drivers/char/ipmi/ipmi_si_intf.c
index 871f1e755604,f6646ed3047e..000000000000
--- a/drivers/char/ipmi/ipmi_si_intf.c
+++ b/drivers/char/ipmi/ipmi_si_intf.c
@@@ -888,30 -931,16 +888,39 @@@ static void sender(void                
  	struct smi_info   *smi_info = send_info;
  	enum si_sm_result result;
  	unsigned long     flags;
 +#ifdef DEBUG_TIMING
 +	struct timeval    t;
 +#endif
  
++<<<<<<< HEAD
 +	if (atomic_read(&smi_info->stop_operation)) {
 +		msg->rsp[0] = msg->data[0] | 4;
 +		msg->rsp[1] = msg->data[1];
 +		msg->rsp[2] = IPMI_ERR_UNSPECIFIED;
 +		msg->rsp_size = 3;
 +		deliver_recv_msg(smi_info, msg);
 +		return;
 +	}
 +
 +#ifdef DEBUG_TIMING
 +	do_gettimeofday(&t);
 +	printk("**Enqueue: %d.%9.9d\n", t.tv_sec, t.tv_usec);
 +#endif
++=======
+ 	debug_timestamp("Enqueue");
++>>>>>>> 1d86e29b4a61 (ipmi: Fix a memory ordering issue)
  
  	if (smi_info->run_to_completion) {
  		/*
 -		 * If we are running to completion, start it and run
 -		 * transactions until everything is clear.
 +		 * If we are running to completion, then throw it in
 +		 * the list and run transactions until everything is
 +		 * clear.  Priority doesn't matter here.
  		 */
++<<<<<<< HEAD
++=======
+ 		smi_info->curr_msg = msg;
+ 		smi_info->waiting_msg = NULL;
++>>>>>>> 1d86e29b4a61 (ipmi: Fix a memory ordering issue)
  
  		/*
  		 * Run to completion means we are single-threaded, no
@@@ -929,11 -957,15 +938,23 @@@
  	}
  
  	spin_lock_irqsave(&smi_info->si_lock, flags);
++<<<<<<< HEAD
 +	if (priority > 0)
 +		list_add_tail(&msg->link, &smi_info->hp_xmit_msgs);
 +	else
 +		list_add_tail(&msg->link, &smi_info->xmit_msgs);
 +
++=======
+ 	/*
+ 	 * The following two lines don't need to be under the lock for
+ 	 * the lock's sake, but they do need SMP memory barriers to
+ 	 * avoid getting things out of order.  We are already claiming
+ 	 * the lock, anyway, so just do it under the lock to avoid the
+ 	 * ordering problem.
+ 	 */
+ 	BUG_ON(smi_info->waiting_msg);
+ 	smi_info->waiting_msg = msg;
++>>>>>>> 1d86e29b4a61 (ipmi: Fix a memory ordering issue)
  	check_start_timer_thread(smi_info);
  	spin_unlock_irqrestore(&smi_info->si_lock, flags);
  }
* Unmerged path drivers/char/ipmi/ipmi_si_intf.c
