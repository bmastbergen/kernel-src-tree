perf tools: Fix race in build_id_cache__add_s()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [tools] perf: Fix race in build_id_cache__add_s() (Milos Vyletel) [1204077]
Rebuild_FUZZ: 93.18%
commit-author Milos Vyletel <milos@redhat.com>
commit 0635b0f71424be7706793ac260d063491a2889a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/0635b0f7.failed

int build_id_cache__add_s(const char *sbuild_id, const char *debugdir,
                          const char *name, bool is_kallsyms, bool is_vdso)
{
...
        if (access(filename, F_OK)) {
               ^--------------------------------------------------------- [1]
                if (is_kallsyms) {
                         if (copyfile("/proc/kallsyms", filename))
                                goto out_free;
                } else if (link(realname, filename) && copyfile(name, filename))
                             ^-----------------------------^------------- [2]
                                                            \------------ [3]
                        goto out_free;
        }
...

When multiple instances of perf record get to [1] at more or less same time and
run access() one or more may get failure because the file does not exist yet
(since the first instance did not have chance to link it yet).

At this point the race moves to link() at [2] where first thread to get
there links file and goes on but second one gets -EEXIST so it runs
copyfile [3] which truncates the file.

reproducer:

rm -rf /root/.debug
for cpu in $(awk '/processor/ {print $3}' /proc/cpuinfo); do
	perf record -a -v -T -F 1000 -C $cpu \
		-o perf-${cpu}.data sleep 5 2> /dev/null &
done
wait

and simply search for empty files by:

find /lib/modules/`uname -r`/kernel/* -size 0

	Signed-off-by: Milos Vyletel <milos@redhat.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Stephane Eranian <eranian@google.com>
Link: http://lkml.kernel.org/r/1426847846-11112-1-git-send-email-milos@redhat.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 0635b0f71424be7706793ac260d063491a2889a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/build-id.c
diff --cc tools/perf/util/build-id.c
index a904a4cfe7d3,f7fb2587df69..000000000000
--- a/tools/perf/util/build-id.c
+++ b/tools/perf/util/build-id.c
@@@ -97,12 -131,412 +97,262 @@@ char *dso__build_id_filename(const stru
  		return NULL;
  
  	build_id__sprintf(dso->build_id, sizeof(dso->build_id), build_id_hex);
 -	return build_id__filename(build_id_hex, bf, size);
 -}
 -
 -#define dsos__for_each_with_build_id(pos, head)	\
 -	list_for_each_entry(pos, head, node)	\
 -		if (!pos->has_build_id)		\
 -			continue;		\
 -		else
 -
 -static int write_buildid(const char *name, size_t name_len, u8 *build_id,
 -			 pid_t pid, u16 misc, int fd)
 -{
 -	int err;
 -	struct build_id_event b;
 -	size_t len;
 -
 -	len = name_len + 1;
 -	len = PERF_ALIGN(len, NAME_ALIGN);
 -
 -	memset(&b, 0, sizeof(b));
 -	memcpy(&b.build_id, build_id, BUILD_ID_SIZE);
 -	b.pid = pid;
 -	b.header.misc = misc;
 -	b.header.size = sizeof(b) + len;
 -
 -	err = writen(fd, &b, sizeof(b));
 -	if (err < 0)
 -		return err;
 -
 -	return write_padded(fd, name, name_len + 1, len);
 -}
 -
 -static int __dsos__write_buildid_table(struct list_head *head,
 -				       struct machine *machine,
 -				       pid_t pid, u16 misc, int fd)
 -{
 -	char nm[PATH_MAX];
 -	struct dso *pos;
 -
 -	dsos__for_each_with_build_id(pos, head) {
 -		int err;
 -		const char *name;
 -		size_t name_len;
 -
 -		if (!pos->hit)
 -			continue;
 -
 -		if (dso__is_vdso(pos)) {
 -			name = pos->short_name;
 -			name_len = pos->short_name_len + 1;
 -		} else if (dso__is_kcore(pos)) {
 -			machine__mmap_name(machine, nm, sizeof(nm));
 -			name = nm;
 -			name_len = strlen(nm) + 1;
 -		} else {
 -			name = pos->long_name;
 -			name_len = pos->long_name_len + 1;
 -		}
 -
 -		err = write_buildid(name, name_len, pos->build_id,
 -				    pid, misc, fd);
 -		if (err)
 -			return err;
 -	}
 -
 -	return 0;
 -}
 -
 -static int machine__write_buildid_table(struct machine *machine, int fd)
 -{
 -	int err;
 -	u16 kmisc = PERF_RECORD_MISC_KERNEL,
 -	    umisc = PERF_RECORD_MISC_USER;
 -
 -	if (!machine__is_host(machine)) {
 -		kmisc = PERF_RECORD_MISC_GUEST_KERNEL;
 -		umisc = PERF_RECORD_MISC_GUEST_USER;
 -	}
 -
 -	err = __dsos__write_buildid_table(&machine->kernel_dsos.head, machine,
 -					  machine->pid, kmisc, fd);
 -	if (err == 0)
 -		err = __dsos__write_buildid_table(&machine->user_dsos.head,
 -						  machine, machine->pid, umisc,
 -						  fd);
 -	return err;
 -}
 -
 -int perf_session__write_buildid_table(struct perf_session *session, int fd)
 -{
 -	struct rb_node *nd;
 -	int err = machine__write_buildid_table(&session->machines.host, fd);
 -
 -	if (err)
 -		return err;
 -
 -	for (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {
 -		struct machine *pos = rb_entry(nd, struct machine, rb_node);
 -		err = machine__write_buildid_table(pos, fd);
 -		if (err)
 -			break;
 -	}
 -	return err;
 -}
 -
 -static int __dsos__hit_all(struct list_head *head)
 -{
 -	struct dso *pos;
 -
 -	list_for_each_entry(pos, head, node)
 -		pos->hit = true;
 -
 -	return 0;
 -}
 -
 -static int machine__hit_all_dsos(struct machine *machine)
 -{
 -	int err;
 -
 -	err = __dsos__hit_all(&machine->kernel_dsos.head);
 -	if (err)
 -		return err;
 -
 -	return __dsos__hit_all(&machine->user_dsos.head);
 -}
 -
 -int dsos__hit_all(struct perf_session *session)
 -{
 -	struct rb_node *nd;
 -	int err;
 -
 -	err = machine__hit_all_dsos(&session->machines.host);
 -	if (err)
 -		return err;
 -
 -	for (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {
 -		struct machine *pos = rb_entry(nd, struct machine, rb_node);
 -
 -		err = machine__hit_all_dsos(pos);
 -		if (err)
 -			return err;
 -	}
 -
 -	return 0;
 -}
 -
 -void disable_buildid_cache(void)
 -{
 -	no_buildid_cache = true;
 -}
 -
 -static char *build_id_cache__dirname_from_path(const char *name,
 -					       bool is_kallsyms, bool is_vdso)
 -{
 -	char *realname = (char *)name, *filename;
 -	bool slash = is_kallsyms || is_vdso;
 -
 -	if (!slash) {
 -		realname = realpath(name, NULL);
 -		if (!realname)
 +	if (bf == NULL) {
 +		if (asprintf(&bf, "%s/.build-id/%.2s/%s", buildid_dir,
 +			     build_id_hex, build_id_hex + 2) < 0)
  			return NULL;
++<<<<<<< HEAD
 +	} else
 +		snprintf(bf, size, "%s/.build-id/%.2s/%s", buildid_dir,
 +			 build_id_hex, build_id_hex + 2);
 +	return bf;
++=======
+ 	}
+ 
+ 	if (asprintf(&filename, "%s%s%s", buildid_dir, slash ? "/" : "",
+ 		     is_vdso ? DSO__NAME_VDSO : realname) < 0)
+ 		filename = NULL;
+ 
+ 	if (!slash)
+ 		free(realname);
+ 
+ 	return filename;
+ }
+ 
+ int build_id_cache__list_build_ids(const char *pathname,
+ 				   struct strlist **result)
+ {
+ 	struct strlist *list;
+ 	char *dir_name;
+ 	DIR *dir;
+ 	struct dirent *d;
+ 	int ret = 0;
+ 
+ 	list = strlist__new(true, NULL);
+ 	dir_name = build_id_cache__dirname_from_path(pathname, false, false);
+ 	if (!list || !dir_name) {
+ 		ret = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	/* List up all dirents */
+ 	dir = opendir(dir_name);
+ 	if (!dir) {
+ 		ret = -errno;
+ 		goto out;
+ 	}
+ 
+ 	while ((d = readdir(dir)) != NULL) {
+ 		if (!strcmp(d->d_name, ".") || !strcmp(d->d_name, ".."))
+ 			continue;
+ 		strlist__add(list, d->d_name);
+ 	}
+ 	closedir(dir);
+ 
+ out:
+ 	free(dir_name);
+ 	if (ret)
+ 		strlist__delete(list);
+ 	else
+ 		*result = list;
+ 
+ 	return ret;
+ }
+ 
+ int build_id_cache__add_s(const char *sbuild_id, const char *name,
+ 			  bool is_kallsyms, bool is_vdso)
+ {
+ 	const size_t size = PATH_MAX;
+ 	char *realname = NULL, *filename = NULL, *dir_name = NULL,
+ 	     *linkname = zalloc(size), *targetname, *tmp;
+ 	int err = -1;
+ 
+ 	if (!is_kallsyms) {
+ 		realname = realpath(name, NULL);
+ 		if (!realname)
+ 			goto out_free;
+ 	}
+ 
+ 	dir_name = build_id_cache__dirname_from_path(name, is_kallsyms, is_vdso);
+ 	if (!dir_name)
+ 		goto out_free;
+ 
+ 	if (mkdir_p(dir_name, 0755))
+ 		goto out_free;
+ 
+ 	if (asprintf(&filename, "%s/%s", dir_name, sbuild_id) < 0) {
+ 		filename = NULL;
+ 		goto out_free;
+ 	}
+ 
+ 	if (access(filename, F_OK)) {
+ 		if (is_kallsyms) {
+ 			 if (copyfile("/proc/kallsyms", filename))
+ 				goto out_free;
+ 		} else if (link(realname, filename) && errno != EEXIST &&
+ 				copyfile(name, filename))
+ 			goto out_free;
+ 	}
+ 
+ 	if (!build_id__filename(sbuild_id, linkname, size))
+ 		goto out_free;
+ 	tmp = strrchr(linkname, '/');
+ 	*tmp = '\0';
+ 
+ 	if (access(linkname, X_OK) && mkdir_p(linkname, 0755))
+ 		goto out_free;
+ 
+ 	*tmp = '/';
+ 	targetname = filename + strlen(buildid_dir) - 5;
+ 	memcpy(targetname, "../..", 5);
+ 
+ 	if (symlink(targetname, linkname) == 0)
+ 		err = 0;
+ out_free:
+ 	if (!is_kallsyms)
+ 		free(realname);
+ 	free(filename);
+ 	free(dir_name);
+ 	free(linkname);
+ 	return err;
+ }
+ 
+ static int build_id_cache__add_b(const u8 *build_id, size_t build_id_size,
+ 				 const char *name, bool is_kallsyms,
+ 				 bool is_vdso)
+ {
+ 	char sbuild_id[BUILD_ID_SIZE * 2 + 1];
+ 
+ 	build_id__sprintf(build_id, build_id_size, sbuild_id);
+ 
+ 	return build_id_cache__add_s(sbuild_id, name, is_kallsyms, is_vdso);
+ }
+ 
+ bool build_id_cache__cached(const char *sbuild_id)
+ {
+ 	bool ret = false;
+ 	char *filename = build_id__filename(sbuild_id, NULL, 0);
+ 
+ 	if (filename && !access(filename, F_OK))
+ 		ret = true;
+ 	free(filename);
+ 
+ 	return ret;
+ }
+ 
+ int build_id_cache__remove_s(const char *sbuild_id)
+ {
+ 	const size_t size = PATH_MAX;
+ 	char *filename = zalloc(size),
+ 	     *linkname = zalloc(size), *tmp;
+ 	int err = -1;
+ 
+ 	if (filename == NULL || linkname == NULL)
+ 		goto out_free;
+ 
+ 	if (!build_id__filename(sbuild_id, linkname, size))
+ 		goto out_free;
+ 
+ 	if (access(linkname, F_OK))
+ 		goto out_free;
+ 
+ 	if (readlink(linkname, filename, size - 1) < 0)
+ 		goto out_free;
+ 
+ 	if (unlink(linkname))
+ 		goto out_free;
+ 
+ 	/*
+ 	 * Since the link is relative, we must make it absolute:
+ 	 */
+ 	tmp = strrchr(linkname, '/') + 1;
+ 	snprintf(tmp, size - (tmp - linkname), "%s", filename);
+ 
+ 	if (unlink(linkname))
+ 		goto out_free;
+ 
+ 	err = 0;
+ out_free:
+ 	free(filename);
+ 	free(linkname);
+ 	return err;
+ }
+ 
+ static int dso__cache_build_id(struct dso *dso, struct machine *machine)
+ {
+ 	bool is_kallsyms = dso->kernel && dso->long_name[0] != '/';
+ 	bool is_vdso = dso__is_vdso(dso);
+ 	const char *name = dso->long_name;
+ 	char nm[PATH_MAX];
+ 
+ 	if (dso__is_kcore(dso)) {
+ 		is_kallsyms = true;
+ 		machine__mmap_name(machine, nm, sizeof(nm));
+ 		name = nm;
+ 	}
+ 	return build_id_cache__add_b(dso->build_id, sizeof(dso->build_id), name,
+ 				     is_kallsyms, is_vdso);
+ }
+ 
+ static int __dsos__cache_build_ids(struct list_head *head,
+ 				   struct machine *machine)
+ {
+ 	struct dso *pos;
+ 	int err = 0;
+ 
+ 	dsos__for_each_with_build_id(pos, head)
+ 		if (dso__cache_build_id(pos, machine))
+ 			err = -1;
+ 
+ 	return err;
+ }
+ 
+ static int machine__cache_build_ids(struct machine *machine)
+ {
+ 	int ret = __dsos__cache_build_ids(&machine->kernel_dsos.head, machine);
+ 	ret |= __dsos__cache_build_ids(&machine->user_dsos.head, machine);
+ 	return ret;
+ }
+ 
+ int perf_session__cache_build_ids(struct perf_session *session)
+ {
+ 	struct rb_node *nd;
+ 	int ret;
+ 
+ 	if (no_buildid_cache)
+ 		return 0;
+ 
+ 	if (mkdir(buildid_dir, 0755) != 0 && errno != EEXIST)
+ 		return -1;
+ 
+ 	ret = machine__cache_build_ids(&session->machines.host);
+ 
+ 	for (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {
+ 		struct machine *pos = rb_entry(nd, struct machine, rb_node);
+ 		ret |= machine__cache_build_ids(pos);
+ 	}
+ 	return ret ? -1 : 0;
+ }
+ 
+ static bool machine__read_build_ids(struct machine *machine, bool with_hits)
+ {
+ 	bool ret;
+ 
+ 	ret  = __dsos__read_build_ids(&machine->kernel_dsos.head, with_hits);
+ 	ret |= __dsos__read_build_ids(&machine->user_dsos.head, with_hits);
+ 	return ret;
+ }
+ 
+ bool perf_session__read_build_ids(struct perf_session *session, bool with_hits)
+ {
+ 	struct rb_node *nd;
+ 	bool ret = machine__read_build_ids(&session->machines.host, with_hits);
+ 
+ 	for (nd = rb_first(&session->machines.guests); nd; nd = rb_next(nd)) {
+ 		struct machine *pos = rb_entry(nd, struct machine, rb_node);
+ 		ret |= machine__read_build_ids(pos, with_hits);
+ 	}
+ 
+ 	return ret;
++>>>>>>> 0635b0f71424 (perf tools: Fix race in build_id_cache__add_s())
  }
* Unmerged path tools/perf/util/build-id.c
