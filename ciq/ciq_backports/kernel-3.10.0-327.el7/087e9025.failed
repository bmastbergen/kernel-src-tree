sfc: Change entity reset on MC reboot to a new datapath-only reset.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] sfc: Change entity reset on MC reboot to a new datapath-only reset (Jarod Wilson) [1199178]
Rebuild_FUZZ: 99.25%
commit-author Jon Cooper <jcooper@solarflare.com>
commit 087e90255035f914f5be2eb2a7ae3a3850066138
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/087e9025.failed

Currently we do an entity reset when we detect an MC reboot.
This messes up SRIOV because it leaves VFs orphaned. The extra
reset is rather redundant anyway, since the MC reboot will have
basically reset everything.

This change replaces the entity reset after MC reboot with a
simpler datapath reset that reallocates resources but doesn't
perform the entity reset.

	Signed-off-by: Shradha Shah <sshah@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 087e90255035f914f5be2eb2a7ae3a3850066138)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/ef10.c
diff --cc drivers/net/ethernet/sfc/ef10.c
index 6249861a8939,525808f34036..000000000000
--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@@ -3635,9 -3939,111 +3643,112 @@@ static int efx_ef10_ptp_set_ts_config(s
  	}
  }
  
++<<<<<<< HEAD
++=======
+ const struct efx_nic_type efx_hunt_a0_vf_nic_type = {
+ 	.is_vf = true,
+ 	.mem_bar = EFX_MEM_VF_BAR,
+ 	.mem_map_size = efx_ef10_mem_map_size,
+ 	.probe = efx_ef10_probe_vf,
+ 	.remove = efx_ef10_remove,
+ 	.dimension_resources = efx_ef10_dimension_resources,
+ 	.init = efx_ef10_init_nic,
+ 	.fini = efx_port_dummy_op_void,
+ 	.map_reset_reason = efx_ef10_map_reset_reason,
+ 	.map_reset_flags = efx_ef10_map_reset_flags,
+ 	.reset = efx_ef10_reset,
+ 	.probe_port = efx_mcdi_port_probe,
+ 	.remove_port = efx_mcdi_port_remove,
+ 	.fini_dmaq = efx_ef10_fini_dmaq,
+ 	.prepare_flr = efx_ef10_prepare_flr,
+ 	.finish_flr = efx_port_dummy_op_void,
+ 	.describe_stats = efx_ef10_describe_stats,
+ 	.update_stats = efx_ef10_update_stats,
+ 	.start_stats = efx_port_dummy_op_void,
+ 	.pull_stats = efx_port_dummy_op_void,
+ 	.stop_stats = efx_port_dummy_op_void,
+ 	.set_id_led = efx_mcdi_set_id_led,
+ 	.push_irq_moderation = efx_ef10_push_irq_moderation,
+ 	.reconfigure_mac = efx_ef10_mac_reconfigure_vf,
+ 	.check_mac_fault = efx_mcdi_mac_check_fault,
+ 	.reconfigure_port = efx_mcdi_port_reconfigure,
+ 	.get_wol = efx_ef10_get_wol_vf,
+ 	.set_wol = efx_ef10_set_wol_vf,
+ 	.resume_wol = efx_port_dummy_op_void,
+ 	.mcdi_request = efx_ef10_mcdi_request,
+ 	.mcdi_poll_response = efx_ef10_mcdi_poll_response,
+ 	.mcdi_read_response = efx_ef10_mcdi_read_response,
+ 	.mcdi_poll_reboot = efx_ef10_mcdi_poll_reboot,
+ 	.irq_enable_master = efx_port_dummy_op_void,
+ 	.irq_test_generate = efx_ef10_irq_test_generate,
+ 	.irq_disable_non_ev = efx_port_dummy_op_void,
+ 	.irq_handle_msi = efx_ef10_msi_interrupt,
+ 	.irq_handle_legacy = efx_ef10_legacy_interrupt,
+ 	.tx_probe = efx_ef10_tx_probe,
+ 	.tx_init = efx_ef10_tx_init,
+ 	.tx_remove = efx_ef10_tx_remove,
+ 	.tx_write = efx_ef10_tx_write,
+ 	.rx_push_rss_config = efx_ef10_vf_rx_push_rss_config,
+ 	.rx_probe = efx_ef10_rx_probe,
+ 	.rx_init = efx_ef10_rx_init,
+ 	.rx_remove = efx_ef10_rx_remove,
+ 	.rx_write = efx_ef10_rx_write,
+ 	.rx_defer_refill = efx_ef10_rx_defer_refill,
+ 	.ev_probe = efx_ef10_ev_probe,
+ 	.ev_init = efx_ef10_ev_init,
+ 	.ev_fini = efx_ef10_ev_fini,
+ 	.ev_remove = efx_ef10_ev_remove,
+ 	.ev_process = efx_ef10_ev_process,
+ 	.ev_read_ack = efx_ef10_ev_read_ack,
+ 	.ev_test_generate = efx_ef10_ev_test_generate,
+ 	.filter_table_probe = efx_ef10_filter_table_probe,
+ 	.filter_table_restore = efx_ef10_filter_table_restore,
+ 	.filter_table_remove = efx_ef10_filter_table_remove,
+ 	.filter_update_rx_scatter = efx_ef10_filter_update_rx_scatter,
+ 	.filter_insert = efx_ef10_filter_insert,
+ 	.filter_remove_safe = efx_ef10_filter_remove_safe,
+ 	.filter_get_safe = efx_ef10_filter_get_safe,
+ 	.filter_clear_rx = efx_ef10_filter_clear_rx,
+ 	.filter_count_rx_used = efx_ef10_filter_count_rx_used,
+ 	.filter_get_rx_id_limit = efx_ef10_filter_get_rx_id_limit,
+ 	.filter_get_rx_ids = efx_ef10_filter_get_rx_ids,
+ #ifdef CONFIG_RFS_ACCEL
+ 	.filter_rfs_insert = efx_ef10_filter_rfs_insert,
+ 	.filter_rfs_expire_one = efx_ef10_filter_rfs_expire_one,
+ #endif
+ #ifdef CONFIG_SFC_MTD
+ 	.mtd_probe = efx_port_dummy_op_int,
+ #endif
+ 	.ptp_write_host_time = efx_ef10_ptp_write_host_time_vf,
+ 	.ptp_set_ts_config = efx_ef10_ptp_set_ts_config_vf,
+ #ifdef CONFIG_SFC_SRIOV
+ 	.vswitching_probe = efx_ef10_vswitching_probe_vf,
+ 	.vswitching_restore = efx_ef10_vswitching_restore_vf,
+ 	.vswitching_remove = efx_ef10_vswitching_remove_vf,
+ #endif
+ 	.get_mac_address = efx_ef10_get_mac_address_vf,
+ 
+ 	.revision = EFX_REV_HUNT_A0,
+ 	.max_dma_mask = DMA_BIT_MASK(ESF_DZ_TX_KER_BUF_ADDR_WIDTH),
+ 	.rx_prefix_size = ES_DZ_RX_PREFIX_SIZE,
+ 	.rx_hash_offset = ES_DZ_RX_PREFIX_HASH_OFST,
+ 	.rx_ts_offset = ES_DZ_RX_PREFIX_TSTAMP_OFST,
+ 	.can_rx_scatter = true,
+ 	.always_rx_scatter = true,
+ 	.max_interrupt_mode = EFX_INT_MODE_MSIX,
+ 	.timer_period_max = 1 << ERF_DD_EVQ_IND_TIMER_VAL_WIDTH,
+ 	.offload_features = (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+ 			     NETIF_F_RXHASH | NETIF_F_NTUPLE),
+ 	.mcdi_max_ver = 2,
+ 	.max_rx_ip_filters = HUNT_FILTER_TBL_ROWS,
+ 	.hwtstamp_filters = 1 << HWTSTAMP_FILTER_NONE |
+ 			    1 << HWTSTAMP_FILTER_ALL,
+ };
+ 
++>>>>>>> 087e90255035 (sfc: Change entity reset on MC reboot to a new datapath-only reset.)
  const struct efx_nic_type efx_hunt_a0_nic_type = {
 -	.is_vf = false,
 -	.mem_bar = EFX_MEM_BAR,
  	.mem_map_size = efx_ef10_mem_map_size,
 -	.probe = efx_ef10_probe_pf,
 +	.probe = efx_ef10_probe,
  	.remove = efx_ef10_remove,
  	.dimension_resources = efx_ef10_dimension_resources,
  	.init = efx_ef10_init_nic,
* Unmerged path drivers/net/ethernet/sfc/ef10.c
diff --git a/drivers/net/ethernet/sfc/efx.c b/drivers/net/ethernet/sfc/efx.c
index 9557690dd00f..01f7b286b10f 100644
--- a/drivers/net/ethernet/sfc/efx.c
+++ b/drivers/net/ethernet/sfc/efx.c
@@ -77,6 +77,7 @@ const char *const efx_reset_type_names[] = {
 	[RESET_TYPE_RECOVER_OR_ALL]     = "RECOVER_OR_ALL",
 	[RESET_TYPE_WORLD]              = "WORLD",
 	[RESET_TYPE_RECOVER_OR_DISABLE] = "RECOVER_OR_DISABLE",
+	[RESET_TYPE_DATAPATH]           = "DATAPATH",
 	[RESET_TYPE_MC_BIST]		= "MC_BIST",
 	[RESET_TYPE_DISABLE]            = "DISABLE",
 	[RESET_TYPE_TX_WATCHDOG]        = "TX_WATCHDOG",
@@ -2375,7 +2376,8 @@ void efx_reset_down(struct efx_nic *efx, enum reset_type method)
 	efx_disable_interrupts(efx);
 
 	mutex_lock(&efx->mac_lock);
-	if (efx->port_initialized && method != RESET_TYPE_INVISIBLE)
+	if (efx->port_initialized && method != RESET_TYPE_INVISIBLE &&
+	    method != RESET_TYPE_DATAPATH)
 		efx->phy_op->fini(efx);
 	efx->type->fini(efx);
 }
@@ -2404,7 +2406,8 @@ int efx_reset_up(struct efx_nic *efx, enum reset_type method, bool ok)
 	if (!ok)
 		goto fail;
 
-	if (efx->port_initialized && method != RESET_TYPE_INVISIBLE) {
+	if (efx->port_initialized && method != RESET_TYPE_INVISIBLE &&
+	    method != RESET_TYPE_DATAPATH) {
 		rc = efx->phy_op->init(efx);
 		if (rc)
 			goto fail;
@@ -2591,6 +2594,7 @@ void efx_schedule_reset(struct efx_nic *efx, enum reset_type type)
 	case RESET_TYPE_WORLD:
 	case RESET_TYPE_DISABLE:
 	case RESET_TYPE_RECOVER_OR_DISABLE:
+	case RESET_TYPE_DATAPATH:
 	case RESET_TYPE_MC_BIST:
 	case RESET_TYPE_MCDI_TIMEOUT:
 		method = type;
diff --git a/drivers/net/ethernet/sfc/enum.h b/drivers/net/ethernet/sfc/enum.h
index d1dbb5fb31bb..c94f56271dd4 100644
--- a/drivers/net/ethernet/sfc/enum.h
+++ b/drivers/net/ethernet/sfc/enum.h
@@ -143,6 +143,7 @@ enum efx_loopback_mode {
  * @RESET_TYPE_WORLD: Reset as much as possible
  * @RESET_TYPE_RECOVER_OR_DISABLE: Try to recover. Apply RESET_TYPE_DISABLE if
  * unsuccessful.
+ * @RESET_TYPE_DATAPATH: Reset datapath only.
  * @RESET_TYPE_MC_BIST: MC entering BIST mode.
  * @RESET_TYPE_DISABLE: Reset datapath, MAC and PHY; leave NIC disabled
  * @RESET_TYPE_TX_WATCHDOG: reset due to TX watchdog
@@ -159,6 +160,7 @@ enum reset_type {
 	RESET_TYPE_ALL,
 	RESET_TYPE_WORLD,
 	RESET_TYPE_RECOVER_OR_DISABLE,
+	RESET_TYPE_DATAPATH,
 	RESET_TYPE_MC_BIST,
 	RESET_TYPE_DISABLE,
 	RESET_TYPE_MAX_METHOD,
diff --git a/drivers/net/ethernet/sfc/mcdi.c b/drivers/net/ethernet/sfc/mcdi.c
index f12b16a7708d..0ef0d513bac7 100644
--- a/drivers/net/ethernet/sfc/mcdi.c
+++ b/drivers/net/ethernet/sfc/mcdi.c
@@ -1568,7 +1568,9 @@ int efx_mcdi_reset(struct efx_nic *efx, enum reset_type method)
 	if (rc)
 		return rc;
 
-	if (method == RESET_TYPE_WORLD)
+	if (method == RESET_TYPE_DATAPATH)
+		return 0;
+	else if (method == RESET_TYPE_WORLD)
 		return efx_mcdi_reset_mc(efx);
 	else
 		return efx_mcdi_reset_func(efx);
