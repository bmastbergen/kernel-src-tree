s390/kernel: add system calls for PCI memory access

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [s390] kernel: add system calls for PCI memory access (Hendrik Brueckner) [1182169]
Rebuild_FUZZ: 94.85%
commit-author Alexey Ishchuk <aishchuk@linux.vnet.ibm.com>
commit 4eafad7febd482092b331ea72c37274d745956be
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/4eafad7f.failed

Add the new __NR_s390_pci_mmio_write and __NR_s390_pci_mmio_read
system calls to allow user space applications to access device PCI I/O
memory pages on s390x platform.

[ Martin Schwidefsky: some code beautification ]

	Signed-off-by: Alexey Ishchuk <aishchuk@linux.vnet.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 4eafad7febd482092b331ea72c37274d745956be)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/uapi/asm/unistd.h
#	arch/s390/kernel/compat_wrapper.c
#	arch/s390/kernel/syscalls.S
#	arch/s390/pci/Makefile
diff --cc arch/s390/include/uapi/asm/unistd.h
index 864f693c237f,2b446cf0cc65..000000000000
--- a/arch/s390/include/uapi/asm/unistd.h
+++ b/arch/s390/include/uapi/asm/unistd.h
@@@ -280,7 -280,16 +280,20 @@@
  #define __NR_s390_runtime_instr 342
  #define __NR_kcmp		343
  #define __NR_finit_module	344
++<<<<<<< HEAD
 +#define NR_syscalls 345
++=======
+ #define __NR_sched_setattr	345
+ #define __NR_sched_getattr	346
+ #define __NR_renameat2		347
+ #define __NR_seccomp		348
+ #define __NR_getrandom		349
+ #define __NR_memfd_create	350
+ #define __NR_bpf		351
+ #define __NR_s390_pci_mmio_write	352
+ #define __NR_s390_pci_mmio_read		353
+ #define NR_syscalls 354
++>>>>>>> 4eafad7febd4 (s390/kernel: add system calls for PCI memory access)
  
  /* 
   * There are some system calls that are not present on 64 bit, some
diff --cc arch/s390/kernel/syscalls.S
index 913410bd74a3,a2987243bc76..000000000000
--- a/arch/s390/kernel/syscalls.S
+++ b/arch/s390/kernel/syscalls.S
@@@ -339,17 -339,26 +339,37 @@@ SYSCALL(sys_epoll_create1,sys_epoll_cre
  SYSCALL(sys_preadv,sys_preadv,compat_sys_preadv)
  SYSCALL(sys_pwritev,sys_pwritev,compat_sys_pwritev)
  SYSCALL(sys_rt_tgsigqueueinfo,sys_rt_tgsigqueueinfo,compat_sys_rt_tgsigqueueinfo) /* 330 */
 -SYSCALL(sys_perf_event_open,sys_perf_event_open,compat_sys_perf_event_open)
 -SYSCALL(sys_fanotify_init,sys_fanotify_init,compat_sys_fanotify_init)
 +SYSCALL(sys_perf_event_open,sys_perf_event_open,sys_perf_event_open_wrapper)
 +SYSCALL(sys_fanotify_init,sys_fanotify_init,sys_fanotify_init_wrapper)
  SYSCALL(sys_fanotify_mark,sys_fanotify_mark,compat_sys_fanotify_mark)
 -SYSCALL(sys_prlimit64,sys_prlimit64,compat_sys_prlimit64)
 -SYSCALL(sys_name_to_handle_at,sys_name_to_handle_at,compat_sys_name_to_handle_at) /* 335 */
 +SYSCALL(sys_prlimit64,sys_prlimit64,sys_prlimit64_wrapper)
 +SYSCALL(sys_name_to_handle_at,sys_name_to_handle_at,sys_name_to_handle_at_wrapper) /* 335 */
  SYSCALL(sys_open_by_handle_at,sys_open_by_handle_at,compat_sys_open_by_handle_at)
++<<<<<<< HEAD
 +SYSCALL(sys_clock_adjtime,sys_clock_adjtime,compat_sys_clock_adjtime_wrapper)
 +SYSCALL(sys_syncfs,sys_syncfs,sys_syncfs_wrapper)
 +SYSCALL(sys_setns,sys_setns,sys_setns_wrapper)
 +SYSCALL(sys_process_vm_readv,sys_process_vm_readv,compat_sys_process_vm_readv_wrapper) /* 340 */
 +SYSCALL(sys_process_vm_writev,sys_process_vm_writev,compat_sys_process_vm_writev_wrapper)
 +SYSCALL(sys_ni_syscall,sys_s390_runtime_instr,sys_s390_runtime_instr_wrapper)
 +SYSCALL(sys_kcmp,sys_kcmp,sys_kcmp_wrapper)
 +SYSCALL(sys_finit_module,sys_finit_module,sys_finit_module_wrapper)
++=======
+ SYSCALL(sys_clock_adjtime,sys_clock_adjtime,compat_sys_clock_adjtime)
+ SYSCALL(sys_syncfs,sys_syncfs,compat_sys_syncfs)
+ SYSCALL(sys_setns,sys_setns,compat_sys_setns)
+ SYSCALL(sys_process_vm_readv,sys_process_vm_readv,compat_sys_process_vm_readv) /* 340 */
+ SYSCALL(sys_process_vm_writev,sys_process_vm_writev,compat_sys_process_vm_writev)
+ SYSCALL(sys_ni_syscall,sys_s390_runtime_instr,compat_sys_s390_runtime_instr)
+ SYSCALL(sys_kcmp,sys_kcmp,compat_sys_kcmp)
+ SYSCALL(sys_finit_module,sys_finit_module,compat_sys_finit_module)
+ SYSCALL(sys_sched_setattr,sys_sched_setattr,compat_sys_sched_setattr) /* 345 */
+ SYSCALL(sys_sched_getattr,sys_sched_getattr,compat_sys_sched_getattr)
+ SYSCALL(sys_renameat2,sys_renameat2,compat_sys_renameat2)
+ SYSCALL(sys_seccomp,sys_seccomp,compat_sys_seccomp)
+ SYSCALL(sys_getrandom,sys_getrandom,compat_sys_getrandom)
+ SYSCALL(sys_memfd_create,sys_memfd_create,compat_sys_memfd_create) /* 350 */
+ SYSCALL(sys_bpf,sys_bpf,compat_sys_bpf)
+ SYSCALL(sys_ni_syscall,sys_s390_pci_mmio_write,compat_sys_s390_pci_mmio_write)
+ SYSCALL(sys_ni_syscall,sys_s390_pci_mmio_read,compat_sys_s390_pci_mmio_read)
++>>>>>>> 4eafad7febd4 (s390/kernel: add system calls for PCI memory access)
diff --cc arch/s390/pci/Makefile
index 086a2e37935d,805d8b29193a..000000000000
--- a/arch/s390/pci/Makefile
+++ b/arch/s390/pci/Makefile
@@@ -2,5 -2,5 +2,10 @@@
  # Makefile for the s390 PCI subsystem.
  #
  
++<<<<<<< HEAD
 +obj-$(CONFIG_PCI)	+= pci.o pci_dma.o pci_clp.o pci_msi.o pci_sysfs.o \
 +			   pci_event.o pci_debug.o pci_insn.o
++=======
+ obj-$(CONFIG_PCI)	+= pci.o pci_dma.o pci_clp.o pci_sysfs.o \
+ 			   pci_event.o pci_debug.o pci_insn.o pci_mmio.o
++>>>>>>> 4eafad7febd4 (s390/kernel: add system calls for PCI memory access)
* Unmerged path arch/s390/kernel/compat_wrapper.c
* Unmerged path arch/s390/include/uapi/asm/unistd.h
* Unmerged path arch/s390/kernel/compat_wrapper.c
diff --git a/arch/s390/kernel/entry.h b/arch/s390/kernel/entry.h
index 93afeee4ca12..bd5a80436d2e 100644
--- a/arch/s390/kernel/entry.h
+++ b/arch/s390/kernel/entry.h
@@ -78,4 +78,6 @@ long sys_rt_sigreturn(void);
 long sys32_sigreturn(void);
 long sys32_rt_sigreturn(void);
 
+long sys_s390_pci_mmio_write(unsigned long, const void __user *, size_t);
+long sys_s390_pci_mmio_read(unsigned long, void __user *, size_t);
 #endif /* _ENTRY_H */
* Unmerged path arch/s390/kernel/syscalls.S
* Unmerged path arch/s390/pci/Makefile
diff --git a/arch/s390/pci/pci_mmio.c b/arch/s390/pci/pci_mmio.c
new file mode 100644
index 000000000000..62c5ea6d8682
--- /dev/null
+++ b/arch/s390/pci/pci_mmio.c
@@ -0,0 +1,115 @@
+/*
+ * Access to PCI I/O memory from user space programs.
+ *
+ * Copyright IBM Corp. 2014
+ * Author(s): Alexey Ishchuk <aishchuk@linux.vnet.ibm.com>
+ */
+#include <linux/kernel.h>
+#include <linux/syscalls.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+
+static long get_pfn(unsigned long user_addr, unsigned long access,
+		    unsigned long *pfn)
+{
+	struct vm_area_struct *vma;
+	long ret;
+
+	down_read(&current->mm->mmap_sem);
+	ret = -EINVAL;
+	vma = find_vma(current->mm, user_addr);
+	if (!vma)
+		goto out;
+	ret = -EACCES;
+	if (!(vma->vm_flags & access))
+		goto out;
+	ret = follow_pfn(vma, user_addr, pfn);
+out:
+	up_read(&current->mm->mmap_sem);
+	return ret;
+}
+
+SYSCALL_DEFINE3(s390_pci_mmio_write, unsigned long, mmio_addr,
+		const void __user *, user_buffer, size_t, length)
+{
+	u8 local_buf[64];
+	void __iomem *io_addr;
+	void *buf;
+	unsigned long pfn;
+	long ret;
+
+	if (!zpci_is_enabled())
+		return -ENODEV;
+
+	if (length <= 0 || PAGE_SIZE - (mmio_addr & ~PAGE_MASK) < length)
+		return -EINVAL;
+	if (length > 64) {
+		buf = kmalloc(length, GFP_KERNEL);
+		if (!buf)
+			return -ENOMEM;
+	} else
+		buf = local_buf;
+
+	ret = get_pfn(mmio_addr, VM_WRITE, &pfn);
+	if (ret)
+		goto out;
+	io_addr = (void *)((pfn << PAGE_SHIFT) | (mmio_addr & ~PAGE_MASK));
+
+	ret = -EFAULT;
+	if ((unsigned long) io_addr < ZPCI_IOMAP_ADDR_BASE)
+		goto out;
+
+	if (copy_from_user(buf, user_buffer, length))
+		goto out;
+
+	memcpy_toio(io_addr, buf, length);
+	ret = 0;
+out:
+	if (buf != local_buf)
+		kfree(buf);
+	return ret;
+}
+
+SYSCALL_DEFINE3(s390_pci_mmio_read, unsigned long, mmio_addr,
+		void __user *, user_buffer, size_t, length)
+{
+	u8 local_buf[64];
+	void __iomem *io_addr;
+	void *buf;
+	unsigned long pfn;
+	long ret;
+
+	if (!zpci_is_enabled())
+		return -ENODEV;
+
+	if (length <= 0 || PAGE_SIZE - (mmio_addr & ~PAGE_MASK) < length)
+		return -EINVAL;
+	if (length > 64) {
+		buf = kmalloc(length, GFP_KERNEL);
+		if (!buf)
+			return -ENOMEM;
+	} else
+		buf = local_buf;
+
+	ret = get_pfn(mmio_addr, VM_READ, &pfn);
+	if (ret)
+		goto out;
+	io_addr = (void *)((pfn << PAGE_SHIFT) | (mmio_addr & ~PAGE_MASK));
+
+	ret = -EFAULT;
+	if ((unsigned long) io_addr < ZPCI_IOMAP_ADDR_BASE)
+		goto out;
+
+	memcpy_fromio(buf, io_addr, length);
+
+	if (copy_to_user(user_buffer, buf, length))
+		goto out;
+
+	ret = 0;
+out:
+	if (buf != local_buf)
+		kfree(buf);
+	return ret;
+}
diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 7e1e13d76acc..8626c1b9d34e 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -162,6 +162,8 @@ cond_syscall(ppc_rtas);
 cond_syscall(sys_spu_run);
 cond_syscall(sys_spu_create);
 cond_syscall(sys_subpage_prot);
+cond_syscall(sys_s390_pci_mmio_read);
+cond_syscall(sys_s390_pci_mmio_write);
 
 /* mmu depending weak syscall entries */
 cond_syscall(sys_mprotect);
