KVM: VFIO: register kvm_device_ops dynamically

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kvm] vfio: register kvm_device_ops dynamically (Bandan Das) [1209995]
Rebuild_FUZZ: 94.25%
commit-author Will Deacon <will.deacon@arm.com>
commit 80ce1639727e9d38729c34f162378508c307ca25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/80ce1639.failed

Now that we have a dynamic means to register kvm_device_ops, use that
for the VFIO kvm device, instead of relying on the static table.

This is achieved by a module_init call to register the ops with KVM.

	Cc: Gleb Natapov <gleb@kernel.org>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Acked-by: Alex Williamson <Alex.Williamson@redhat.com>
	Signed-off-by: Will Deacon <will.deacon@arm.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 80ce1639727e9d38729c34f162378508c307ca25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	virt/kvm/kvm_main.c
diff --cc virt/kvm/kvm_main.c
index 570c0d8e02bd,db57363cc287..000000000000
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@@ -2284,6 -2272,29 +2284,32 @@@ struct kvm_device *kvm_device_from_filp
  	return filp->private_data;
  }
  
++<<<<<<< HEAD
++=======
+ static struct kvm_device_ops *kvm_device_ops_table[KVM_DEV_TYPE_MAX] = {
+ #ifdef CONFIG_KVM_MPIC
+ 	[KVM_DEV_TYPE_FSL_MPIC_20]	= &kvm_mpic_ops,
+ 	[KVM_DEV_TYPE_FSL_MPIC_42]	= &kvm_mpic_ops,
+ #endif
+ 
+ #ifdef CONFIG_KVM_XICS
+ 	[KVM_DEV_TYPE_XICS]		= &kvm_xics_ops,
+ #endif
+ };
+ 
+ int kvm_register_device_ops(struct kvm_device_ops *ops, u32 type)
+ {
+ 	if (type >= ARRAY_SIZE(kvm_device_ops_table))
+ 		return -ENOSPC;
+ 
+ 	if (kvm_device_ops_table[type] != NULL)
+ 		return -EEXIST;
+ 
+ 	kvm_device_ops_table[type] = ops;
+ 	return 0;
+ }
+ 
++>>>>>>> 80ce1639727e (KVM: VFIO: register kvm_device_ops dynamically)
  static int kvm_ioctl_create_device(struct kvm *kvm,
  				   struct kvm_create_device *cd)
  {
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index e1e1c9fa034a..3aa2ed0af8f5 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -1055,7 +1055,6 @@ struct kvm_device *kvm_device_from_filp(struct file *filp);
 
 extern struct kvm_device_ops kvm_mpic_ops;
 extern struct kvm_device_ops kvm_xics_ops;
-extern struct kvm_device_ops kvm_vfio_ops;
 
 #ifdef CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT
 
* Unmerged path virt/kvm/kvm_main.c
diff --git a/virt/kvm/vfio.c b/virt/kvm/vfio.c
index ba1a93f935c7..bb11b36ee8a2 100644
--- a/virt/kvm/vfio.c
+++ b/virt/kvm/vfio.c
@@ -246,6 +246,16 @@ static void kvm_vfio_destroy(struct kvm_device *dev)
 	kfree(dev); /* alloc by kvm_ioctl_create_device, free by .destroy */
 }
 
+static int kvm_vfio_create(struct kvm_device *dev, u32 type);
+
+static struct kvm_device_ops kvm_vfio_ops = {
+	.name = "kvm-vfio",
+	.create = kvm_vfio_create,
+	.destroy = kvm_vfio_destroy,
+	.set_attr = kvm_vfio_set_attr,
+	.has_attr = kvm_vfio_has_attr,
+};
+
 static int kvm_vfio_create(struct kvm_device *dev, u32 type)
 {
 	struct kvm_device *tmp;
@@ -268,10 +278,8 @@ static int kvm_vfio_create(struct kvm_device *dev, u32 type)
 	return 0;
 }
 
-struct kvm_device_ops kvm_vfio_ops = {
-	.name = "kvm-vfio",
-	.create = kvm_vfio_create,
-	.destroy = kvm_vfio_destroy,
-	.set_attr = kvm_vfio_set_attr,
-	.has_attr = kvm_vfio_has_attr,
-};
+static int __init kvm_vfio_ops_init(void)
+{
+	return kvm_register_device_ops(&kvm_vfio_ops, KVM_DEV_TYPE_VFIO);
+}
+module_init(kvm_vfio_ops_init);
