sfc: Add use of shared RSS contexts.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [netdrv] sfc: Add use of shared RSS contexts (Jarod Wilson) [1199178]
Rebuild_FUZZ: 98.59%
commit-author Jon Cooper <jcooper@solarflare.com>
commit 267c01571bd38ea807bae1da93788d3b577661cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/267c0157.failed

Allow PFs to allocate shared RSS contexts if we exhaust our
exclusive RSS contexts. Make VFs use shared RSS contexts in
all cases.
Spruce up error handling so that the shadow copy of the RSS
table is updated after successful update, rather than in all
cases, so that we report the actual contents of the RSS table
after a failure to set it, rather than what we'd like it to be.

Populate context_size parameter when vacuously allocating RSS
context of size 1.

	Signed-off-by: Shradha Shah <sshah@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 267c01571bd38ea807bae1da93788d3b577661cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/sfc/ef10.c
#	drivers/net/ethernet/sfc/ethtool.c
diff --cc drivers/net/ethernet/sfc/ef10.c
index cd683661ffb0,7a67202fb1cb..000000000000
--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@@ -3633,9 -3809,107 +3746,109 @@@ static int efx_ef10_ptp_set_ts_config(s
  	}
  }
  
++<<<<<<< HEAD
++=======
+ const struct efx_nic_type efx_hunt_a0_vf_nic_type = {
+ 	.mem_bar = EFX_MEM_VF_BAR,
+ 	.mem_map_size = efx_ef10_mem_map_size,
+ 	.probe = efx_ef10_probe_vf,
+ 	.remove = efx_ef10_remove,
+ 	.dimension_resources = efx_ef10_dimension_resources,
+ 	.init = efx_ef10_init_nic,
+ 	.fini = efx_port_dummy_op_void,
+ 	.map_reset_reason = efx_mcdi_map_reset_reason,
+ 	.map_reset_flags = efx_ef10_map_reset_flags,
+ 	.reset = efx_ef10_reset,
+ 	.probe_port = efx_mcdi_port_probe,
+ 	.remove_port = efx_mcdi_port_remove,
+ 	.fini_dmaq = efx_ef10_fini_dmaq,
+ 	.prepare_flr = efx_ef10_prepare_flr,
+ 	.finish_flr = efx_port_dummy_op_void,
+ 	.describe_stats = efx_ef10_describe_stats,
+ 	.update_stats = efx_ef10_update_stats,
+ 	.start_stats = efx_port_dummy_op_void,
+ 	.pull_stats = efx_port_dummy_op_void,
+ 	.stop_stats = efx_port_dummy_op_void,
+ 	.set_id_led = efx_mcdi_set_id_led,
+ 	.push_irq_moderation = efx_ef10_push_irq_moderation,
+ 	.reconfigure_mac = efx_ef10_mac_reconfigure,
+ 	.check_mac_fault = efx_mcdi_mac_check_fault,
+ 	.reconfigure_port = efx_mcdi_port_reconfigure,
+ 	.get_wol = efx_ef10_get_wol_vf,
+ 	.set_wol = efx_ef10_set_wol_vf,
+ 	.resume_wol = efx_port_dummy_op_void,
+ 	.mcdi_request = efx_ef10_mcdi_request,
+ 	.mcdi_poll_response = efx_ef10_mcdi_poll_response,
+ 	.mcdi_read_response = efx_ef10_mcdi_read_response,
+ 	.mcdi_poll_reboot = efx_ef10_mcdi_poll_reboot,
+ 	.irq_enable_master = efx_port_dummy_op_void,
+ 	.irq_test_generate = efx_ef10_irq_test_generate,
+ 	.irq_disable_non_ev = efx_port_dummy_op_void,
+ 	.irq_handle_msi = efx_ef10_msi_interrupt,
+ 	.irq_handle_legacy = efx_ef10_legacy_interrupt,
+ 	.tx_probe = efx_ef10_tx_probe,
+ 	.tx_init = efx_ef10_tx_init,
+ 	.tx_remove = efx_ef10_tx_remove,
+ 	.tx_write = efx_ef10_tx_write,
+ 	.rx_push_rss_config = efx_ef10_vf_rx_push_rss_config,
+ 	.rx_probe = efx_ef10_rx_probe,
+ 	.rx_init = efx_ef10_rx_init,
+ 	.rx_remove = efx_ef10_rx_remove,
+ 	.rx_write = efx_ef10_rx_write,
+ 	.rx_defer_refill = efx_ef10_rx_defer_refill,
+ 	.ev_probe = efx_ef10_ev_probe,
+ 	.ev_init = efx_ef10_ev_init,
+ 	.ev_fini = efx_ef10_ev_fini,
+ 	.ev_remove = efx_ef10_ev_remove,
+ 	.ev_process = efx_ef10_ev_process,
+ 	.ev_read_ack = efx_ef10_ev_read_ack,
+ 	.ev_test_generate = efx_ef10_ev_test_generate,
+ 	.filter_table_probe = efx_ef10_filter_table_probe,
+ 	.filter_table_restore = efx_ef10_filter_table_restore,
+ 	.filter_table_remove = efx_ef10_filter_table_remove,
+ 	.filter_update_rx_scatter = efx_ef10_filter_update_rx_scatter,
+ 	.filter_insert = efx_ef10_filter_insert,
+ 	.filter_remove_safe = efx_ef10_filter_remove_safe,
+ 	.filter_get_safe = efx_ef10_filter_get_safe,
+ 	.filter_clear_rx = efx_ef10_filter_clear_rx,
+ 	.filter_count_rx_used = efx_ef10_filter_count_rx_used,
+ 	.filter_get_rx_id_limit = efx_ef10_filter_get_rx_id_limit,
+ 	.filter_get_rx_ids = efx_ef10_filter_get_rx_ids,
+ #ifdef CONFIG_RFS_ACCEL
+ 	.filter_rfs_insert = efx_ef10_filter_rfs_insert,
+ 	.filter_rfs_expire_one = efx_ef10_filter_rfs_expire_one,
+ #endif
+ #ifdef CONFIG_SFC_MTD
+ 	.mtd_probe = efx_port_dummy_op_int,
+ #endif
+ 	.ptp_write_host_time = efx_ef10_ptp_write_host_time_vf,
+ 	.ptp_set_ts_config = efx_ef10_ptp_set_ts_config_vf,
+ #ifdef CONFIG_SFC_SRIOV
+ 	.vswitching_probe = efx_ef10_vswitching_probe_vf,
+ 	.vswitching_restore = efx_ef10_vswitching_restore_vf,
+ 	.vswitching_remove = efx_ef10_vswitching_remove_vf,
+ #endif
+ 	.revision = EFX_REV_HUNT_A0,
+ 	.max_dma_mask = DMA_BIT_MASK(ESF_DZ_TX_KER_BUF_ADDR_WIDTH),
+ 	.rx_prefix_size = ES_DZ_RX_PREFIX_SIZE,
+ 	.rx_hash_offset = ES_DZ_RX_PREFIX_HASH_OFST,
+ 	.rx_ts_offset = ES_DZ_RX_PREFIX_TSTAMP_OFST,
+ 	.can_rx_scatter = true,
+ 	.always_rx_scatter = true,
+ 	.max_interrupt_mode = EFX_INT_MODE_MSIX,
+ 	.timer_period_max = 1 << ERF_DD_EVQ_IND_TIMER_VAL_WIDTH,
+ 	.offload_features = (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+ 			     NETIF_F_RXHASH | NETIF_F_NTUPLE),
+ 	.mcdi_max_ver = 2,
+ 	.max_rx_ip_filters = HUNT_FILTER_TBL_ROWS,
+ 	.hwtstamp_filters = 1 << HWTSTAMP_FILTER_NONE |
+ 			    1 << HWTSTAMP_FILTER_ALL,
+ };
+ 
++>>>>>>> 267c01571bd3 (sfc: Add use of shared RSS contexts.)
  const struct efx_nic_type efx_hunt_a0_nic_type = {
 -	.mem_bar = EFX_MEM_BAR,
  	.mem_map_size = efx_ef10_mem_map_size,
 -	.probe = efx_ef10_probe_pf,
 +	.probe = efx_ef10_probe,
  	.remove = efx_ef10_remove,
  	.dimension_resources = efx_ef10_dimension_resources,
  	.init = efx_ef10_init_nic,
diff --cc drivers/net/ethernet/sfc/ethtool.c
index 2f161d4e65ac,03829b48547a..000000000000
--- a/drivers/net/ethernet/sfc/ethtool.c
+++ b/drivers/net/ethernet/sfc/ethtool.c
@@@ -1099,9 -1103,14 +1099,20 @@@ static int efx_ethtool_set_rxfh_indir(s
  {
  	struct efx_nic *efx = netdev_priv(net_dev);
  
++<<<<<<< HEAD
 +	memcpy(efx->rx_indir_table, indir, sizeof(efx->rx_indir_table));
 +	efx->type->rx_push_rss_config(efx);
 +	return 0;
++=======
+ 	/* We do not allow change in unsupported parameters */
+ 	if (key ||
+ 	    (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP))
+ 		return -EOPNOTSUPP;
+ 	if (!indir)
+ 		return 0;
+ 
+ 	return efx->type->rx_push_rss_config(efx, true, indir);
++>>>>>>> 267c01571bd3 (sfc: Add use of shared RSS contexts.)
  }
  
  static int efx_ethtool_get_ts_info(struct net_device *net_dev,
* Unmerged path drivers/net/ethernet/sfc/ef10.c
diff --git a/drivers/net/ethernet/sfc/efx.c b/drivers/net/ethernet/sfc/efx.c
index 9557690dd00f..183a88a339c1 100644
--- a/drivers/net/ethernet/sfc/efx.c
+++ b/drivers/net/ethernet/sfc/efx.c
@@ -1285,6 +1285,15 @@ static void efx_fini_io(struct efx_nic *efx)
 	pci_disable_device(efx->pci_dev);
 }
 
+void efx_set_default_rx_indir_table(struct efx_nic *efx)
+{
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(efx->rx_indir_table); i++)
+		efx->rx_indir_table[i] =
+			ethtool_rxfh_indir_default(i, efx->rss_spread);
+}
+
 static unsigned int efx_wanted_parallelism(struct efx_nic *efx)
 {
 	cpumask_var_t thread_mask;
@@ -1601,7 +1610,6 @@ static void efx_set_channels(struct efx_nic *efx)
 
 static int efx_probe_nic(struct efx_nic *efx)
 {
-	size_t i;
 	int rc;
 
 	netif_dbg(efx, probe, efx->net_dev, "creating NIC\n");
@@ -1624,10 +1632,9 @@ static int efx_probe_nic(struct efx_nic *efx)
 		goto fail2;
 
 	if (efx->n_channels > 1)
-		netdev_rss_key_fill(&efx->rx_hash_key, sizeof(efx->rx_hash_key));
-	for (i = 0; i < ARRAY_SIZE(efx->rx_indir_table); i++)
-		efx->rx_indir_table[i] =
-			ethtool_rxfh_indir_default(i, efx->rss_spread);
+		netdev_rss_key_fill(&efx->rx_hash_key,
+				    sizeof(efx->rx_hash_key));
+	efx_set_default_rx_indir_table(efx);
 
 	netif_set_real_num_tx_queues(efx->net_dev, efx->n_tx_channels);
 	netif_set_real_num_rx_queues(efx->net_dev, efx->n_rx_channels);
diff --git a/drivers/net/ethernet/sfc/efx.h b/drivers/net/ethernet/sfc/efx.h
index bc4e4b3e6aad..f0f81544f9cd 100644
--- a/drivers/net/ethernet/sfc/efx.h
+++ b/drivers/net/ethernet/sfc/efx.h
@@ -32,6 +32,7 @@ unsigned int efx_tx_max_skb_descs(struct efx_nic *efx);
 extern unsigned int efx_piobuf_size;
 
 /* RX */
+void efx_set_default_rx_indir_table(struct efx_nic *efx);
 void efx_rx_config_page_split(struct efx_nic *efx);
 int efx_probe_rx_queue(struct efx_rx_queue *rx_queue);
 void efx_remove_rx_queue(struct efx_rx_queue *rx_queue);
* Unmerged path drivers/net/ethernet/sfc/ethtool.c
diff --git a/drivers/net/ethernet/sfc/falcon.c b/drivers/net/ethernet/sfc/falcon.c
index 157037546d30..66793fbc8624 100644
--- a/drivers/net/ethernet/sfc/falcon.c
+++ b/drivers/net/ethernet/sfc/falcon.c
@@ -477,16 +477,29 @@ static irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id)
  *
  **************************************************************************
  */
+static int dummy_rx_push_rss_config(struct efx_nic *efx, bool user,
+				    const u32 *rx_indir_table)
+{
+	(void) efx;
+	(void) user;
+	(void) rx_indir_table;
+	return -ENOSYS;
+}
 
-static void falcon_b0_rx_push_rss_config(struct efx_nic *efx)
+static int falcon_b0_rx_push_rss_config(struct efx_nic *efx, bool user,
+					const u32 *rx_indir_table)
 {
 	efx_oword_t temp;
 
+	(void) user;
 	/* Set hash key for IPv4 */
 	memcpy(&temp, efx->rx_hash_key, sizeof(temp));
 	efx_writeo(efx, &temp, FR_BZ_RX_RSS_TKEY);
 
+	memcpy(efx->rx_indir_table, rx_indir_table,
+	       sizeof(efx->rx_indir_table));
 	efx_farch_rx_push_indir_table(efx);
+	return 0;
 }
 
 /**************************************************************************
@@ -2507,7 +2520,7 @@ static int falcon_init_nic(struct efx_nic *efx)
 	falcon_init_rx_cfg(efx);
 
 	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {
-		falcon_b0_rx_push_rss_config(efx);
+		falcon_b0_rx_push_rss_config(efx, false, efx->rx_indir_table);
 
 		/* Set destination of both TX and RX Flush events */
 		EFX_POPULATE_OWORD_1(temp, FRF_BZ_FLS_EVQ_ID, 0);
@@ -2729,7 +2742,7 @@ const struct efx_nic_type falcon_a1_nic_type = {
 	.tx_init = efx_farch_tx_init,
 	.tx_remove = efx_farch_tx_remove,
 	.tx_write = efx_farch_tx_write,
-	.rx_push_rss_config = efx_port_dummy_op_void,
+	.rx_push_rss_config = dummy_rx_push_rss_config,
 	.rx_probe = efx_farch_rx_probe,
 	.rx_init = efx_farch_rx_init,
 	.rx_remove = efx_farch_rx_remove,
diff --git a/drivers/net/ethernet/sfc/net_driver.h b/drivers/net/ethernet/sfc/net_driver.h
index a6f4d9aadd40..9f04bb0532cf 100644
--- a/drivers/net/ethernet/sfc/net_driver.h
+++ b/drivers/net/ethernet/sfc/net_driver.h
@@ -1277,7 +1277,8 @@ struct efx_nic_type {
 	void (*tx_init)(struct efx_tx_queue *tx_queue);
 	void (*tx_remove)(struct efx_tx_queue *tx_queue);
 	void (*tx_write)(struct efx_tx_queue *tx_queue);
-	void (*rx_push_rss_config)(struct efx_nic *efx);
+	int (*rx_push_rss_config)(struct efx_nic *efx, bool user,
+				  const u32 *rx_indir_table);
 	int (*rx_probe)(struct efx_rx_queue *rx_queue);
 	void (*rx_init)(struct efx_rx_queue *rx_queue);
 	void (*rx_remove)(struct efx_rx_queue *rx_queue);
diff --git a/drivers/net/ethernet/sfc/nic.h b/drivers/net/ethernet/sfc/nic.h
index ce965cc22a3b..78105b5b7965 100644
--- a/drivers/net/ethernet/sfc/nic.h
+++ b/drivers/net/ethernet/sfc/nic.h
@@ -483,6 +483,7 @@ enum {
  * @must_restore_piobufs: Flag: PIO buffers have yet to be restored after MC
  *	reboot
  * @rx_rss_context: Firmware handle for our RSS context
+ * @rx_rss_context_exclusive: Whether our RSS context is exclusive or shared
  * @stats: Hardware statistics
  * @workaround_35388: Flag: firmware supports workaround for bug 35388
  * @must_check_datapath_caps: Flag: @datapath_caps needs to be revalidated
@@ -506,6 +507,7 @@ struct efx_ef10_nic_data {
 	unsigned int piobuf_handle[EF10_TX_PIOBUF_COUNT];
 	bool must_restore_piobufs;
 	u32 rx_rss_context;
+	bool rx_rss_context_exclusive;
 	u64 stats[EF10_STAT_COUNT];
 	bool workaround_35388;
 	bool must_check_datapath_caps;
diff --git a/drivers/net/ethernet/sfc/siena.c b/drivers/net/ethernet/sfc/siena.c
index 49792287dd67..abee91c48c6b 100644
--- a/drivers/net/ethernet/sfc/siena.c
+++ b/drivers/net/ethernet/sfc/siena.c
@@ -323,7 +323,8 @@ fail1:
 	return rc;
 }
 
-static void siena_rx_push_rss_config(struct efx_nic *efx)
+static int siena_rx_push_rss_config(struct efx_nic *efx, bool user,
+				    const u32 *rx_indir_table)
 {
 	efx_oword_t temp;
 
@@ -345,7 +346,11 @@ static void siena_rx_push_rss_config(struct efx_nic *efx)
 	       FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH / 8);
 	efx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG3);
 
+	memcpy(efx->rx_indir_table, rx_indir_table,
+	       sizeof(efx->rx_indir_table));
 	efx_farch_rx_push_indir_table(efx);
+
+	return 0;
 }
 
 /* This call performs hardware-specific global initialisation, such as
@@ -388,7 +393,7 @@ static int siena_init_nic(struct efx_nic *efx)
 			    EFX_RX_USR_BUF_SIZE >> 5);
 	efx_writeo(efx, &temp, FR_AZ_RX_CFG);
 
-	siena_rx_push_rss_config(efx);
+	siena_rx_push_rss_config(efx, false, efx->rx_indir_table);
 
 	/* Enable event logging */
 	rc = efx_mcdi_log_ctrl(efx, true, false, 0);
