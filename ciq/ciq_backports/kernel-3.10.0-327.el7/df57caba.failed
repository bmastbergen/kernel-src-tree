qla2xxx: Add FDMI-2 functionality.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [scsi] qla2xxx: Add FDMI-2 functionality (Chad Dupuis) [1187302]
Rebuild_FUZZ: 98.51%
commit-author Himanshu Madhani <himanshu.madhani@qlogic.com>
commit df57cabac41fd54e8eb73f9de482f054eb0b98eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/df57caba.failed

Add support for the FDMI-2 fabric switch feature.

Since FDMI-2 uses code from FDMI-1, some of the existing code
needed to be repaired to prevent fields from being overflowed.

	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Signed-off-by: Saurav Kashyap <saurav.kashyap@qlogic.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit df57cabac41fd54e8eb73f9de482f054eb0b98eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_dbg.c
#	drivers/scsi/qla2xxx/qla_gs.c
diff --cc drivers/scsi/qla2xxx/qla_dbg.c
index e7fa7d02d853,28442d082ba1..000000000000
--- a/drivers/scsi/qla2xxx/qla_dbg.c
+++ b/drivers/scsi/qla2xxx/qla_dbg.c
@@@ -19,9 -19,10 +19,14 @@@
   * |                              |                    | 0x10ca         |
   * |                              |                    | 0x1115-0x1116  |
   * |                              |                    | 0x111a-0x111b	|
++<<<<<<< HEAD
 + * | Device Discovery             |       0x2095       | 0x2020-0x2022, |
++=======
+  * |                              |                    | 0x1155-0x1158  |
+  * | Device Discovery             |       0x2016       | 0x2020-0x2022, |
++>>>>>>> df57cabac41f (qla2xxx: Add FDMI-2 functionality.)
   * |                              |                    | 0x2011-0x2012, |
-  * |                              |                    | 0x2016         |
+  * |                              |                    | 0x2099-0x20a4  |
   * | Queue Command and IO tracing |       0x3059       | 0x3006-0x300b  |
   * |                              |                    | 0x3027-0x3028  |
   * |                              |                    | 0x303d-0x3041  |
diff --cc drivers/scsi/qla2xxx/qla_gs.c
index 0b4be8503a8f,dccc4dcc39c8..000000000000
--- a/drivers/scsi/qla2xxx/qla_gs.c
+++ b/drivers/scsi/qla2xxx/qla_gs.c
@@@ -1526,63 -2087,73 +2087,86 @@@ qla2x00_fdmiv2_rpa(scsi_qla_host_t *vha
  	    eiter->a.fc4_types[1]);
  
  	/* Supported speed. */
- 	eiter = (struct ct_fdmi_port_attr *) (entries + size);
- 	eiter->type = __constant_cpu_to_be16(FDMI_PORT_SUPPORT_SPEED);
- 	eiter->len = __constant_cpu_to_be16(4 + 4);
+ 	eiter = entries + size;
+ 	eiter->type = cpu_to_be16(FDMI_PORT_SUPPORT_SPEED);
+ 	eiter->len = cpu_to_be16(4 + 4);
  	if (IS_CNA_CAPABLE(ha))
- 		eiter->a.sup_speed = __constant_cpu_to_be32(
+ 		eiter->a.sup_speed = cpu_to_be32(
  		    FDMI_PORT_SPEED_10GB);
++<<<<<<< HEAD
 +	else if (IS_QLA25XX(ha))
 +		eiter->a.sup_speed = __constant_cpu_to_be32(
 +		    FDMI_PORT_SPEED_1GB|FDMI_PORT_SPEED_2GB|
 +		    FDMI_PORT_SPEED_4GB|FDMI_PORT_SPEED_8GB);
 +	else if (IS_QLA24XX_TYPE(ha))
 +		eiter->a.sup_speed = __constant_cpu_to_be32(
 +		    FDMI_PORT_SPEED_1GB|FDMI_PORT_SPEED_2GB|
++=======
+ 	else if (IS_QLA27XX(ha))
+ 		eiter->a.sup_speed = cpu_to_be32(
+ 		    FDMI_PORT_SPEED_32GB|
+ 		    FDMI_PORT_SPEED_16GB|
+ 		    FDMI_PORT_SPEED_8GB);
+ 	else if (IS_QLA2031(ha))
+ 		eiter->a.sup_speed = cpu_to_be32(
+ 		    FDMI_PORT_SPEED_16GB|
+ 		    FDMI_PORT_SPEED_8GB|
++>>>>>>> df57cabac41f (qla2xxx: Add FDMI-2 functionality.)
  		    FDMI_PORT_SPEED_4GB);
+ 	else if (IS_QLA25XX(ha))
+ 		eiter->a.sup_speed = cpu_to_be32(
+ 		    FDMI_PORT_SPEED_8GB|
+ 		    FDMI_PORT_SPEED_4GB|
+ 		    FDMI_PORT_SPEED_2GB|
+ 		    FDMI_PORT_SPEED_1GB);
+ 	else if (IS_QLA24XX_TYPE(ha))
+ 		eiter->a.sup_speed = cpu_to_be32(
+ 		    FDMI_PORT_SPEED_4GB|
+ 		    FDMI_PORT_SPEED_2GB|
+ 		    FDMI_PORT_SPEED_1GB);
  	else if (IS_QLA23XX(ha))
- 		eiter->a.sup_speed =__constant_cpu_to_be32(
- 		    FDMI_PORT_SPEED_1GB|FDMI_PORT_SPEED_2GB);
+ 		eiter->a.sup_speed = cpu_to_be32(
+ 		    FDMI_PORT_SPEED_2GB|
+ 		    FDMI_PORT_SPEED_1GB);
  	else
- 		eiter->a.sup_speed = __constant_cpu_to_be32(
+ 		eiter->a.sup_speed = cpu_to_be32(
  		    FDMI_PORT_SPEED_1GB);
  	size += 4 + 4;
  
- 	ql_dbg(ql_dbg_disc, vha, 0x203a,
- 	    "Supported_Speed=%x.\n", eiter->a.sup_speed);
+ 	ql_dbg(ql_dbg_disc, vha, 0x20bb,
+ 	    "Supported Port Speed = %x.\n", eiter->a.sup_speed);
  
  	/* Current speed. */
- 	eiter = (struct ct_fdmi_port_attr *) (entries + size);
- 	eiter->type = __constant_cpu_to_be16(FDMI_PORT_CURRENT_SPEED);
- 	eiter->len = __constant_cpu_to_be16(4 + 4);
+ 	eiter = entries + size;
+ 	eiter->type = cpu_to_be16(FDMI_PORT_CURRENT_SPEED);
+ 	eiter->len = cpu_to_be16(4 + 4);
  	switch (ha->link_data_rate) {
  	case PORT_SPEED_1GB:
- 		eiter->a.cur_speed =
- 		    __constant_cpu_to_be32(FDMI_PORT_SPEED_1GB);
+ 		eiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_1GB);
  		break;
  	case PORT_SPEED_2GB:
- 		eiter->a.cur_speed =
- 		    __constant_cpu_to_be32(FDMI_PORT_SPEED_2GB);
+ 		eiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_2GB);
  		break;
  	case PORT_SPEED_4GB:
- 		eiter->a.cur_speed =
- 		    __constant_cpu_to_be32(FDMI_PORT_SPEED_4GB);
+ 		eiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_4GB);
  		break;
  	case PORT_SPEED_8GB:
- 		eiter->a.cur_speed =
- 		    __constant_cpu_to_be32(FDMI_PORT_SPEED_8GB);
+ 		eiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_8GB);
  		break;
  	case PORT_SPEED_10GB:
- 		eiter->a.cur_speed =
- 		    __constant_cpu_to_be32(FDMI_PORT_SPEED_10GB);
+ 		eiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_10GB);
  		break;
  	case PORT_SPEED_16GB:
- 		eiter->a.cur_speed =
- 		    __constant_cpu_to_be32(FDMI_PORT_SPEED_16GB);
+ 		eiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_16GB);
  		break;
++<<<<<<< HEAD
++=======
+ 	case PORT_SPEED_32GB:
+ 		eiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_32GB);
+ 		break;
++>>>>>>> df57cabac41f (qla2xxx: Add FDMI-2 functionality.)
  	default:
- 		eiter->a.cur_speed =
- 		    __constant_cpu_to_be32(FDMI_PORT_SPEED_UNKNOWN);
+ 		eiter->a.cur_speed = cpu_to_be32(FDMI_PORT_SPEED_UNKNOWN);
  		break;
  	}
  	size += 4 + 4;
diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c
index b2615422348b..56efd74a3ea9 100644
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -925,7 +925,7 @@ qla2x00_fw_version_show(struct device *dev,
 	char fw_str[128];
 
 	return scnprintf(buf, PAGE_SIZE, "%s\n",
-	    ha->isp_ops->fw_version_str(vha, fw_str));
+	    ha->isp_ops->fw_version_str(vha, fw_str, sizeof(fw_str)));
 }
 
 static ssize_t
@@ -1832,7 +1832,8 @@ qla2x00_get_host_symbolic_name(struct Scsi_Host *shost)
 {
 	scsi_qla_host_t *vha = shost_priv(shost);
 
-	qla2x00_get_sym_node_name(vha, fc_host_symbolic_name(shost));
+	qla2x00_get_sym_node_name(vha, fc_host_symbolic_name(shost),
+	    sizeof(fc_host_symbolic_name(shost)));
 }
 
 static void
* Unmerged path drivers/scsi/qla2xxx/qla_dbg.c
diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h
index 823aec28928b..21e4ed282fbf 100644
--- a/drivers/scsi/qla2xxx/qla_def.h
+++ b/drivers/scsi/qla2xxx/qla_def.h
@@ -2045,10 +2045,21 @@ static const char * const port_state_str[] = {
 
 #define CT_REJECT_RESPONSE	0x8001
 #define CT_ACCEPT_RESPONSE	0x8002
-#define CT_REASON_INVALID_COMMAND_CODE	0x01
-#define CT_REASON_CANNOT_PERFORM	0x09
-#define CT_REASON_COMMAND_UNSUPPORTED	0x0b
-#define CT_EXPL_ALREADY_REGISTERED	0x10
+#define CT_REASON_INVALID_COMMAND_CODE		0x01
+#define CT_REASON_CANNOT_PERFORM		0x09
+#define CT_REASON_COMMAND_UNSUPPORTED		0x0b
+#define CT_EXPL_ALREADY_REGISTERED		0x10
+#define CT_EXPL_HBA_ATTR_NOT_REGISTERED		0x11
+#define CT_EXPL_MULTIPLE_HBA_ATTR		0x12
+#define CT_EXPL_INVALID_HBA_BLOCK_LENGTH	0x13
+#define CT_EXPL_MISSING_REQ_HBA_ATTR		0x14
+#define CT_EXPL_PORT_NOT_REGISTERED_		0x15
+#define CT_EXPL_MISSING_HBA_ID_PORT_LIST	0x16
+#define CT_EXPL_HBA_NOT_REGISTERED		0x17
+#define CT_EXPL_PORT_ATTR_NOT_REGISTERED	0x20
+#define CT_EXPL_PORT_NOT_REGISTERED		0x21
+#define CT_EXPL_MULTIPLE_PORT_ATTR		0x22
+#define CT_EXPL_INVALID_PORT_BLOCK_LENGTH	0x23
 
 #define NS_N_PORT_TYPE	0x01
 #define NS_NL_PORT_TYPE	0x02
@@ -2105,33 +2116,40 @@ static const char * const port_state_str[] = {
  * HBA attribute types.
  */
 #define FDMI_HBA_ATTR_COUNT			9
-#define FDMI_HBA_NODE_NAME			1
-#define FDMI_HBA_MANUFACTURER			2
-#define FDMI_HBA_SERIAL_NUMBER			3
-#define FDMI_HBA_MODEL				4
-#define FDMI_HBA_MODEL_DESCRIPTION		5
-#define FDMI_HBA_HARDWARE_VERSION		6
-#define FDMI_HBA_DRIVER_VERSION			7
-#define FDMI_HBA_OPTION_ROM_VERSION		8
-#define FDMI_HBA_FIRMWARE_VERSION		9
+#define FDMIV2_HBA_ATTR_COUNT			17
+#define FDMI_HBA_NODE_NAME			0x1
+#define FDMI_HBA_MANUFACTURER			0x2
+#define FDMI_HBA_SERIAL_NUMBER			0x3
+#define FDMI_HBA_MODEL				0x4
+#define FDMI_HBA_MODEL_DESCRIPTION		0x5
+#define FDMI_HBA_HARDWARE_VERSION		0x6
+#define FDMI_HBA_DRIVER_VERSION			0x7
+#define FDMI_HBA_OPTION_ROM_VERSION		0x8
+#define FDMI_HBA_FIRMWARE_VERSION		0x9
 #define FDMI_HBA_OS_NAME_AND_VERSION		0xa
 #define FDMI_HBA_MAXIMUM_CT_PAYLOAD_LENGTH	0xb
+#define FDMI_HBA_NODE_SYMBOLIC_NAME		0xc
+#define FDMI_HBA_VENDOR_ID			0xd
+#define FDMI_HBA_NUM_PORTS			0xe
+#define FDMI_HBA_FABRIC_NAME			0xf
+#define FDMI_HBA_BOOT_BIOS_NAME			0x10
+#define FDMI_HBA_TYPE_VENDOR_IDENTIFIER		0xe0
 
 struct ct_fdmi_hba_attr {
 	uint16_t type;
 	uint16_t len;
 	union {
 		uint8_t node_name[WWN_SIZE];
-		uint8_t manufacturer[32];
-		uint8_t serial_num[8];
+		uint8_t manufacturer[64];
+		uint8_t serial_num[32];
 		uint8_t model[16];
 		uint8_t model_desc[80];
-		uint8_t hw_version[16];
+		uint8_t hw_version[32];
 		uint8_t driver_version[32];
 		uint8_t orom_version[16];
-		uint8_t fw_version[16];
+		uint8_t fw_version[32];
 		uint8_t os_version[128];
-		uint8_t max_ct_len[4];
+		uint32_t max_ct_len;
 	} a;
 };
 
@@ -2140,16 +2158,56 @@ struct ct_fdmi_hba_attributes {
 	struct ct_fdmi_hba_attr entry[FDMI_HBA_ATTR_COUNT];
 };
 
+struct ct_fdmiv2_hba_attr {
+	uint16_t type;
+	uint16_t len;
+	union {
+		uint8_t node_name[WWN_SIZE];
+		uint8_t manufacturer[32];
+		uint8_t serial_num[32];
+		uint8_t model[16];
+		uint8_t model_desc[80];
+		uint8_t hw_version[16];
+		uint8_t driver_version[32];
+		uint8_t orom_version[16];
+		uint8_t fw_version[32];
+		uint8_t os_version[128];
+		uint32_t max_ct_len;
+		uint8_t sym_name[256];
+		uint32_t vendor_id;
+		uint32_t num_ports;
+		uint8_t fabric_name[WWN_SIZE];
+		uint8_t bios_name[32];
+		uint8_t vendor_indentifer[8];
+	} a;
+};
+
+struct ct_fdmiv2_hba_attributes {
+	uint32_t count;
+	struct ct_fdmiv2_hba_attr entry[FDMIV2_HBA_ATTR_COUNT];
+};
+
 /*
  * Port attribute types.
  */
 #define FDMI_PORT_ATTR_COUNT		6
-#define FDMI_PORT_FC4_TYPES		1
-#define FDMI_PORT_SUPPORT_SPEED		2
-#define FDMI_PORT_CURRENT_SPEED		3
-#define FDMI_PORT_MAX_FRAME_SIZE	4
-#define FDMI_PORT_OS_DEVICE_NAME	5
-#define FDMI_PORT_HOST_NAME		6
+#define FDMIV2_PORT_ATTR_COUNT		16
+#define FDMI_PORT_FC4_TYPES		0x1
+#define FDMI_PORT_SUPPORT_SPEED		0x2
+#define FDMI_PORT_CURRENT_SPEED		0x3
+#define FDMI_PORT_MAX_FRAME_SIZE	0x4
+#define FDMI_PORT_OS_DEVICE_NAME	0x5
+#define FDMI_PORT_HOST_NAME		0x6
+#define FDMI_PORT_NODE_NAME		0x7
+#define FDMI_PORT_NAME			0x8
+#define FDMI_PORT_SYM_NAME		0x9
+#define FDMI_PORT_TYPE			0xa
+#define FDMI_PORT_SUPP_COS		0xb
+#define FDMI_PORT_FABRIC_NAME		0xc
+#define FDMI_PORT_FC4_TYPE		0xd
+#define FDMI_PORT_STATE			0x101
+#define FDMI_PORT_COUNT			0x102
+#define FDMI_PORT_ID			0x103
 
 #define FDMI_PORT_SPEED_1GB		0x1
 #define FDMI_PORT_SPEED_2GB		0x2
@@ -2159,7 +2217,11 @@ struct ct_fdmi_hba_attributes {
 #define FDMI_PORT_SPEED_16GB		0x20
 #define FDMI_PORT_SPEED_UNKNOWN		0x8000
 
-struct ct_fdmi_port_attr {
+#define FC_CLASS_2	0x04
+#define FC_CLASS_3	0x08
+#define FC_CLASS_2_3	0x0C
+
+struct ct_fdmiv2_port_attr {
 	uint16_t type;
 	uint16_t len;
 	union {
@@ -2169,12 +2231,40 @@ struct ct_fdmi_port_attr {
 		uint32_t max_frame_size;
 		uint8_t os_dev_name[32];
 		uint8_t host_name[32];
+		uint8_t node_name[WWN_SIZE];
+		uint8_t port_name[WWN_SIZE];
+		uint8_t port_sym_name[128];
+		uint32_t port_type;
+		uint32_t port_supported_cos;
+		uint8_t fabric_name[WWN_SIZE];
+		uint8_t port_fc4_type[32];
+		uint32_t port_state;
+		uint32_t num_ports;
+		uint32_t port_id;
 	} a;
 };
 
 /*
  * Port Attribute Block.
  */
+struct ct_fdmiv2_port_attributes {
+	uint32_t count;
+	struct ct_fdmiv2_port_attr entry[FDMIV2_PORT_ATTR_COUNT];
+};
+
+struct ct_fdmi_port_attr {
+	uint16_t type;
+	uint16_t len;
+	union {
+		uint8_t fc4_types[32];
+		uint32_t sup_speed;
+		uint32_t cur_speed;
+		uint32_t max_frame_size;
+		uint8_t os_dev_name[32];
+		uint8_t host_name[32];
+	} a;
+};
+
 struct ct_fdmi_port_attributes {
 	uint32_t count;
 	struct ct_fdmi_port_attr entry[FDMI_PORT_ATTR_COUNT];
@@ -2272,6 +2362,13 @@ struct ct_sns_req {
 			struct ct_fdmi_hba_attributes attrs;
 		} rhba;
 
+		struct {
+			uint8_t hba_identifier[8];
+			uint32_t entry_count;
+			uint8_t port_name[8];
+			struct ct_fdmiv2_hba_attributes attrs;
+		} rhba2;
+
 		struct {
 			uint8_t hba_identifier[8];
 			struct ct_fdmi_hba_attributes attrs;
@@ -2282,6 +2379,11 @@ struct ct_sns_req {
 			struct ct_fdmi_port_attributes attrs;
 		} rpa;
 
+		struct {
+			uint8_t port_name[8];
+			struct ct_fdmiv2_port_attributes attrs;
+		} rpa2;
+
 		struct {
 			uint8_t port_name[8];
 		} dhba;
@@ -2510,7 +2612,7 @@ struct isp_operations {
 	int (*load_risc) (struct scsi_qla_host *, uint32_t *);
 
 	char * (*pci_info_str) (struct scsi_qla_host *, char *);
-	char * (*fw_version_str) (struct scsi_qla_host *, char *);
+	char * (*fw_version_str)(struct scsi_qla_host *, char *, size_t);
 
 	irq_handler_t intr_handler;
 	void (*enable_intrs) (struct qla_hw_data *);
diff --git a/drivers/scsi/qla2xxx/qla_gbl.h b/drivers/scsi/qla2xxx/qla_gbl.h
index be003f674852..d5a95df045a8 100644
--- a/drivers/scsi/qla2xxx/qla_gbl.h
+++ b/drivers/scsi/qla2xxx/qla_gbl.h
@@ -543,7 +543,7 @@ extern void *qla24xx_prep_ms_fdmi_iocb(scsi_qla_host_t *, uint32_t, uint32_t);
 extern int qla2x00_fdmi_register(scsi_qla_host_t *);
 extern int qla2x00_gfpn_id(scsi_qla_host_t *, sw_info_t *);
 extern int qla2x00_gpsc(scsi_qla_host_t *, sw_info_t *);
-extern void qla2x00_get_sym_node_name(scsi_qla_host_t *, uint8_t *);
+extern void qla2x00_get_sym_node_name(scsi_qla_host_t *, uint8_t *, size_t);
 
 /*
  * Global Function Prototypes in qla_attr.c source file.
@@ -596,7 +596,7 @@ extern void qlafx00_soft_reset(scsi_qla_host_t *);
 extern int qlafx00_chip_diag(scsi_qla_host_t *);
 extern void qlafx00_config_rings(struct scsi_qla_host *);
 extern char *qlafx00_pci_info_str(struct scsi_qla_host *, char *);
-extern char *qlafx00_fw_version_str(struct scsi_qla_host *, char *);
+extern char *qlafx00_fw_version_str(struct scsi_qla_host *, char *, size_t);
 extern irqreturn_t qlafx00_intr_handler(int, void *);
 extern void qlafx00_enable_intrs(struct qla_hw_data *);
 extern void qlafx00_disable_intrs(struct qla_hw_data *);
* Unmerged path drivers/scsi/qla2xxx/qla_gs.c
diff --git a/drivers/scsi/qla2xxx/qla_mr.c b/drivers/scsi/qla2xxx/qla_mr.c
index bc6250c1ea89..d65949b02fc9 100644
--- a/drivers/scsi/qla2xxx/qla_mr.c
+++ b/drivers/scsi/qla2xxx/qla_mr.c
@@ -695,11 +695,11 @@ qlafx00_pci_info_str(struct scsi_qla_host *vha, char *str)
 }
 
 char *
-qlafx00_fw_version_str(struct scsi_qla_host *vha, char *str)
+qlafx00_fw_version_str(struct scsi_qla_host *vha, char *str, size_t size)
 {
 	struct qla_hw_data *ha = vha->hw;
 
-	sprintf(str, "%s", ha->mr.fw_version);
+	snprintf(str, size, "%s", ha->mr.fw_version);
 	return str;
 }
 
diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c
index 9c38367784b7..bc3b01bf1290 100644
--- a/drivers/scsi/qla2xxx/qla_os.c
+++ b/drivers/scsi/qla2xxx/qla_os.c
@@ -547,14 +547,13 @@ qla24xx_pci_info_str(struct scsi_qla_host *vha, char *str)
 }
 
 static char *
-qla2x00_fw_version_str(struct scsi_qla_host *vha, char *str)
+qla2x00_fw_version_str(struct scsi_qla_host *vha, char *str, size_t size)
 {
 	char un_str[10];
 	struct qla_hw_data *ha = vha->hw;
 
-	sprintf(str, "%d.%02d.%02d ", ha->fw_major_version,
-	    ha->fw_minor_version,
-	    ha->fw_subminor_version);
+	snprintf(str, size, "%d.%02d.%02d ", ha->fw_major_version,
+	    ha->fw_minor_version, ha->fw_subminor_version);
 
 	if (ha->fw_attributes & BIT_9) {
 		strcat(str, "FLX");
@@ -586,11 +585,11 @@ qla2x00_fw_version_str(struct scsi_qla_host *vha, char *str)
 }
 
 static char *
-qla24xx_fw_version_str(struct scsi_qla_host *vha, char *str)
+qla24xx_fw_version_str(struct scsi_qla_host *vha, char *str, size_t size)
 {
 	struct qla_hw_data *ha = vha->hw;
 
-	sprintf(str, "%d.%02d.%02d (%x)", ha->fw_major_version,
+	snprintf(str, size, "%d.%02d.%02d (%x)", ha->fw_major_version,
 	    ha->fw_minor_version, ha->fw_subminor_version, ha->fw_attributes);
 	return str;
 }
@@ -2848,7 +2847,7 @@ skip_dpc:
 	    pdev->device, ha->isp_ops->pci_info_str(base_vha, pci_info),
 	    pci_name(pdev), ha->flags.enable_64bit_addressing ? '+' : '-',
 	    base_vha->host_no,
-	    ha->isp_ops->fw_version_str(base_vha, fw_str));
+	    ha->isp_ops->fw_version_str(base_vha, fw_str, sizeof(fw_str)));
 
 	qlt_add_target(ha, base_vha);
 
