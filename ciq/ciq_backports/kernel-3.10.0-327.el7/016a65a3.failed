drm/i915: Always reset vma->ggtt_view.pages cache on unbinding

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [drm] i915: Always reset vma->ggtt_view.pages cache on unbinding (Rob Clark) [1249805]
Rebuild_FUZZ: 96.67%
commit-author Chris Wilson <chris@chris-wilson.co.uk>
commit 016a65a39170c3cdca09a6ac343ff4f124668b45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/016a65a3.failed

With the introduction of multiple views of an obj in the same vm, each
vma was taught to cache its copy of the pages (so that different views
could have different page arrangements). However, this missed decoupling
those vma->ggtt_view.pages when the vma released its reference on the
obj->pages. As we don't always free the vma, this leads to a possible
scenario (e.g. execbuffer interrupted by the shrinker) where the vma
points to a stale obj->pages, and explodes.

Fixes regression from commit fe14d5f4e5468c5b80a24f1a64abcbe116143670
Author: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Date:   Wed Dec 10 17:27:58 2014 +0000

    drm/i915: Infrastructure for supporting different GGTT views per object

Tvrtko says, if someone else will be confused how this can happen, key
is the reservation execbuffer path. That puts the VMA on the exec_list
which prevents i915_vma_unbind and i915_gem_vma_destroy from fully
destroying the VMA. So the VMA is left existing as an empty object in
the list - unbound and disassociated with the backing store. Kind of a
cached memory object. And then re-using it needs to clear the cached
pages pointer which is fixed above.

Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=1227892
	Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
	Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
	Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: Michel Thierry <michel.thierry@intel.com>
	Cc: stable@vger.kernel.org
	Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
[Jani: Added Tvrtko's explanation to commit message.]
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
(cherry picked from commit 016a65a39170c3cdca09a6ac343ff4f124668b45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_gem.c
diff --cc drivers/gpu/drm/i915/i915_gem.c
index 53b4db8b449c,c3806c66650a..000000000000
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@@ -2927,12 -2993,16 +2927,24 @@@ int i915_vma_unbind(struct i915_vma *vm
  
  	vma->unbind_vma(vma);
  
 +	i915_gem_gtt_finish_object(obj);
 +
  	list_del_init(&vma->mm_list);
++<<<<<<< HEAD
 +	/* Avoid an unnecessary call to unbind on rebind. */
 +	if (i915_is_ggtt(vma->vm))
 +		obj->map_and_fenceable = true;
++=======
+ 	if (i915_is_ggtt(vma->vm)) {
+ 		if (vma->ggtt_view.type == I915_GGTT_VIEW_NORMAL) {
+ 			obj->map_and_fenceable = false;
+ 		} else if (vma->ggtt_view.pages) {
+ 			sg_free_table(vma->ggtt_view.pages);
+ 			kfree(vma->ggtt_view.pages);
+ 		}
+ 		vma->ggtt_view.pages = NULL;
+ 	}
++>>>>>>> 016a65a39170 (drm/i915: Always reset vma->ggtt_view.pages cache on unbinding)
  
  	drm_mm_remove_node(&vma->node);
  	i915_gem_vma_destroy(vma);
* Unmerged path drivers/gpu/drm/i915/i915_gem.c
