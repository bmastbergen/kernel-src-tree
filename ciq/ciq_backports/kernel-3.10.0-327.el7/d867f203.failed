mm/zsmalloc: make zsmalloc module-buildable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [mm] zsmalloc: make zsmalloc module-buildable (Seth Jennings) [1141434]
Rebuild_FUZZ: 96.39%
commit-author Minchan Kim <minchan@kernel.org>
commit d867f203b974e9a670028fda909ef09044b221f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d867f203.failed

Now, we can build zsmalloc as module because unmap_kernel_range was
exported.

	Signed-off-by: Minchan Kim <minchan@kernel.org>
	Cc: Nitin Gupta <ngupta@vflare.org>
	Cc: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>
	Cc: Jerome Marchand <jmarchan@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit d867f203b974e9a670028fda909ef09044b221f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/Kconfig
diff --cc mm/Kconfig
index 229c9742ecb3,3e9977a9d657..000000000000
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@@ -540,3 -537,58 +540,61 @@@ config ZSWA
  	  interactions don't cause any known issues on simple memory setups,
  	  they have not be fully explored on the large set of potential
  	  configurations and workloads that exist.
++<<<<<<< HEAD
++=======
+ 
+ config MEM_SOFT_DIRTY
+ 	bool "Track memory changes"
+ 	depends on CHECKPOINT_RESTORE && HAVE_ARCH_SOFT_DIRTY && PROC_FS
+ 	select PROC_PAGE_MONITOR
+ 	help
+ 	  This option enables memory changes tracking by introducing a
+ 	  soft-dirty bit on pte-s. This bit it set when someone writes
+ 	  into a page just as regular dirty bit, but unlike the latter
+ 	  it can be cleared by hands.
+ 
+ 	  See Documentation/vm/soft-dirty.txt for more details.
+ 
+ config ZSMALLOC
+ 	tristate "Memory allocator for compressed pages"
+ 	depends on MMU
+ 	default n
+ 	help
+ 	  zsmalloc is a slab-based memory allocator designed to store
+ 	  compressed RAM pages.  zsmalloc uses virtual memory mapping
+ 	  in order to reduce fragmentation.  However, this results in a
+ 	  non-standard allocator interface where a handle, not a pointer, is
+ 	  returned by an alloc().  This handle must be mapped in order to
+ 	  access the allocated space.
+ 
+ config PGTABLE_MAPPING
+ 	bool "Use page table mapping to access object in zsmalloc"
+ 	depends on ZSMALLOC
+ 	help
+ 	  By default, zsmalloc uses a copy-based object mapping method to
+ 	  access allocations that span two pages. However, if a particular
+ 	  architecture (ex, ARM) performs VM mapping faster than copying,
+ 	  then you should select this. This causes zsmalloc to use page table
+ 	  mapping rather than copying for object mapping.
+ 
+ 	  You can check speed with zsmalloc benchmark:
+ 	  https://github.com/spartacus06/zsmapbench
+ 
+ config GENERIC_EARLY_IOREMAP
+ 	bool
+ 
+ config MAX_STACK_SIZE_MB
+ 	int "Maximum user stack size for 32-bit processes (MB)"
+ 	default 80
+ 	range 8 256 if METAG
+ 	range 8 2048
+ 	depends on STACK_GROWSUP && (!64BIT || COMPAT)
+ 	help
+ 	  This is the maximum stack size in Megabytes in the VM layout of 32-bit
+ 	  user processes when the stack grows upwards (currently only on parisc
+ 	  and metag arch). The stack will be located at the highest memory
+ 	  address minus the given value, unless the RLIMIT_STACK hard limit is
+ 	  changed to a smaller value in which case that is used.
+ 
+ 	  A sane initial value is 80 MB.
++>>>>>>> d867f203b974 (mm/zsmalloc: make zsmalloc module-buildable)
* Unmerged path mm/Kconfig
