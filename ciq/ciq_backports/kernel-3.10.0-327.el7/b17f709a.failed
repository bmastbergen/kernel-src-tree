gue: TX support for using remote checksum offload option

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Tom Herbert <therbert@google.com>
commit b17f709a24013fcbb257f6f89b4d81ac9fdf0d18
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b17f709a.failed

Add if_tunnel flag TUNNEL_ENCAP_FLAG_REMCSUM to configure
remote checksum offload on an IP tunnel. Add logic in gue_build_header
to insert remote checksum offload option.

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b17f709a24013fcbb257f6f89b4d81ac9fdf0d18)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/fou.h
#	include/uapi/linux/if_tunnel.h
#	net/ipv4/fou.c
diff --cc include/uapi/linux/if_tunnel.h
index aee73d0611fb,bd3cc11a431f..000000000000
--- a/include/uapi/linux/if_tunnel.h
+++ b/include/uapi/linux/if_tunnel.h
@@@ -57,6 -61,16 +57,19 @@@ enum 
  };
  #define IFLA_IPTUN_MAX	(__IFLA_IPTUN_MAX - 1)
  
++<<<<<<< HEAD
++=======
+ enum tunnel_encap_types {
+ 	TUNNEL_ENCAP_NONE,
+ 	TUNNEL_ENCAP_FOU,
+ 	TUNNEL_ENCAP_GUE,
+ };
+ 
+ #define TUNNEL_ENCAP_FLAG_CSUM		(1<<0)
+ #define TUNNEL_ENCAP_FLAG_CSUM6		(1<<1)
+ #define TUNNEL_ENCAP_FLAG_REMCSUM	(1<<2)
+ 
++>>>>>>> b17f709a2401 (gue: TX support for using remote checksum offload option)
  /* SIT-mode i_flags */
  #define	SIT_ISATAP	0x0001
  
diff --cc net/ipv4/fou.c
index 32e78924e246,fb0db99adf9e..000000000000
--- a/net/ipv4/fou.c
+++ b/net/ipv4/fou.c
@@@ -487,6 -516,125 +487,128 @@@ static const struct genl_ops fou_nl_ops
  	},
  };
  
++<<<<<<< HEAD
++=======
+ static void fou_build_udp(struct sk_buff *skb, struct ip_tunnel_encap *e,
+ 			  struct flowi4 *fl4, u8 *protocol, __be16 sport)
+ {
+ 	struct udphdr *uh;
+ 
+ 	skb_push(skb, sizeof(struct udphdr));
+ 	skb_reset_transport_header(skb);
+ 
+ 	uh = udp_hdr(skb);
+ 
+ 	uh->dest = e->dport;
+ 	uh->source = sport;
+ 	uh->len = htons(skb->len);
+ 	uh->check = 0;
+ 	udp_set_csum(!(e->flags & TUNNEL_ENCAP_FLAG_CSUM), skb,
+ 		     fl4->saddr, fl4->daddr, skb->len);
+ 
+ 	*protocol = IPPROTO_UDP;
+ }
+ 
+ int fou_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
+ 		     u8 *protocol, struct flowi4 *fl4)
+ {
+ 	bool csum = !!(e->flags & TUNNEL_ENCAP_FLAG_CSUM);
+ 	int type = csum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
+ 	__be16 sport;
+ 
+ 	skb = iptunnel_handle_offloads(skb, csum, type);
+ 
+ 	if (IS_ERR(skb))
+ 		return PTR_ERR(skb);
+ 
+ 	sport = e->sport ? : udp_flow_src_port(dev_net(skb->dev),
+ 					       skb, 0, 0, false);
+ 	fou_build_udp(skb, e, fl4, protocol, sport);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(fou_build_header);
+ 
+ int gue_build_header(struct sk_buff *skb, struct ip_tunnel_encap *e,
+ 		     u8 *protocol, struct flowi4 *fl4)
+ {
+ 	bool csum = !!(e->flags & TUNNEL_ENCAP_FLAG_CSUM);
+ 	int type = csum ? SKB_GSO_UDP_TUNNEL_CSUM : SKB_GSO_UDP_TUNNEL;
+ 	struct guehdr *guehdr;
+ 	size_t hdrlen, optlen = 0;
+ 	__be16 sport;
+ 	void *data;
+ 	bool need_priv = false;
+ 
+ 	if ((e->flags & TUNNEL_ENCAP_FLAG_REMCSUM) &&
+ 	    skb->ip_summed == CHECKSUM_PARTIAL) {
+ 		csum = false;
+ 		optlen += GUE_PLEN_REMCSUM;
+ 		type |= SKB_GSO_TUNNEL_REMCSUM;
+ 		need_priv = true;
+ 	}
+ 
+ 	optlen += need_priv ? GUE_LEN_PRIV : 0;
+ 
+ 	skb = iptunnel_handle_offloads(skb, csum, type);
+ 
+ 	if (IS_ERR(skb))
+ 		return PTR_ERR(skb);
+ 
+ 	/* Get source port (based on flow hash) before skb_push */
+ 	sport = e->sport ? : udp_flow_src_port(dev_net(skb->dev),
+ 					       skb, 0, 0, false);
+ 
+ 	hdrlen = sizeof(struct guehdr) + optlen;
+ 
+ 	skb_push(skb, hdrlen);
+ 
+ 	guehdr = (struct guehdr *)skb->data;
+ 
+ 	guehdr->control = 0;
+ 	guehdr->version = 0;
+ 	guehdr->hlen = optlen >> 2;
+ 	guehdr->flags = 0;
+ 	guehdr->proto_ctype = *protocol;
+ 
+ 	data = &guehdr[1];
+ 
+ 	if (need_priv) {
+ 		__be32 *flags = data;
+ 
+ 		guehdr->flags |= GUE_FLAG_PRIV;
+ 		*flags = 0;
+ 		data += GUE_LEN_PRIV;
+ 
+ 		if (type & SKB_GSO_TUNNEL_REMCSUM) {
+ 			u16 csum_start = skb_checksum_start_offset(skb);
+ 			__be16 *pd = data;
+ 
+ 			if (csum_start < hdrlen)
+ 				return -EINVAL;
+ 
+ 			csum_start -= hdrlen;
+ 			pd[0] = htons(csum_start);
+ 			pd[1] = htons(csum_start + skb->csum_offset);
+ 
+ 			if (!skb_is_gso(skb)) {
+ 				skb->ip_summed = CHECKSUM_NONE;
+ 				skb->encapsulation = 0;
+ 			}
+ 
+ 			*flags |= GUE_PFLAG_REMCSUM;
+ 			data += GUE_PLEN_REMCSUM;
+ 		}
+ 
+ 	}
+ 
+ 	fou_build_udp(skb, e, fl4, protocol, sport);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL(gue_build_header);
+ 
++>>>>>>> b17f709a2401 (gue: TX support for using remote checksum offload option)
  static int __init fou_init(void)
  {
  	int ret;
* Unmerged path include/net/fou.h
* Unmerged path include/net/fou.h
* Unmerged path include/uapi/linux/if_tunnel.h
* Unmerged path net/ipv4/fou.c
