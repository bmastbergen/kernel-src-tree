intel_pstate: provide option to only use intel_pstate with HWP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Kristen Carlson Accardi <kristen@linux.intel.com>
commit d64c3b0bb9195d4de856d841337368d930cdb0ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/d64c3b0b.failed

Allow users the option to disable the driver for any hardware
which does not support HWP.

	Signed-off-by: Kristen Carlson Accardi <kristen@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit d64c3b0bb9195d4de856d841337368d930cdb0ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/kernel-parameters.txt
#	drivers/cpufreq/intel_pstate.c
diff --cc Documentation/kernel-parameters.txt
index ce43fea91f93,07e6701a1439..000000000000
--- a/Documentation/kernel-parameters.txt
+++ b/Documentation/kernel-parameters.txt
@@@ -1238,6 -1457,21 +1238,24 @@@ bytes respectively. Such letter suffixe
  		       disable
  		         Do not enable intel_pstate as the default
  		         scaling driver for the supported processors
++<<<<<<< HEAD
++=======
+ 		       force
+ 			 Enable intel_pstate on systems that prohibit it by default
+ 			 in favor of acpi-cpufreq. Forcing the intel_pstate driver
+ 			 instead of acpi-cpufreq may disable platform features, such
+ 			 as thermal controls and power capping, that rely on ACPI
+ 			 P-States information being indicated to OSPM and therefore
+ 			 should be used with caution. This option does not work with
+ 			 processors that aren't supported by the intel_pstate driver
+ 			 or on platforms that use pcc-cpufreq instead of acpi-cpufreq.
+ 		       no_hwp
+ 		         Do not enable hardware P state control (HWP)
+ 			 if available.
+ 		hwp_only
+ 			Only load intel_pstate on systems which support
+ 			hardware P state control (HWP) if available.
++>>>>>>> d64c3b0bb919 (intel_pstate: provide option to only use intel_pstate with HWP)
  
  	intremap=	[X86-64, Intel-IOMMU]
  			on	enable Interrupt Remapping (default)
diff --cc drivers/cpufreq/intel_pstate.c
index f94b3dfc5690,872c5772c5d3..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -897,6 -1018,9 +897,12 @@@ static struct cpufreq_driver intel_psta
  };
  
  static int __initdata no_load;
++<<<<<<< HEAD
++=======
+ static int __initdata no_hwp;
+ static int __initdata hwp_only;
+ static unsigned int force_load;
++>>>>>>> d64c3b0bb919 (intel_pstate: provide option to only use intel_pstate with HWP)
  
  static int intel_pstate_msrs_not_valid(void)
  {
@@@ -1079,6 -1214,12 +1085,15 @@@ static int __init intel_pstate_init(voi
  	if (!all_cpu_data)
  		return -ENOMEM;
  
++<<<<<<< HEAD
++=======
+ 	if (cpu_has(c,X86_FEATURE_HWP) && !no_hwp)
+ 		intel_pstate_hwp_enable();
+ 
+ 	if (!hwp_active && hwp_only)
+ 		goto out;
+ 
++>>>>>>> d64c3b0bb919 (intel_pstate: provide option to only use intel_pstate with HWP)
  	rc = cpufreq_register_driver(&intel_pstate_driver);
  	if (rc)
  		goto out;
@@@ -1109,6 -1250,12 +1124,15 @@@ static int __init intel_pstate_setup(ch
  
  	if (!strcmp(str, "disable"))
  		no_load = 1;
++<<<<<<< HEAD
++=======
+ 	if (!strcmp(str, "no_hwp"))
+ 		no_hwp = 1;
+ 	if (!strcmp(str, "force"))
+ 		force_load = 1;
+ 	if (!strcmp(str, "hwp_only"))
+ 		hwp_only = 1;
++>>>>>>> d64c3b0bb919 (intel_pstate: provide option to only use intel_pstate with HWP)
  	return 0;
  }
  early_param("intel_pstate", intel_pstate_setup);
* Unmerged path Documentation/kernel-parameters.txt
* Unmerged path drivers/cpufreq/intel_pstate.c
