tun: Fix csum_start with VLAN acceleration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Herbert Xu <herbert@gondor.apana.org.au>
commit a8f9bfdf982e2b1fb9f094e4de9ab08c57f3d2fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a8f9bfdf.failed

When VLAN acceleration is in use on the xmit path, we end up
setting csum_start to the wrong place.  The result is that the
whoever ends up doing the checksum setting will corrupt the packet
instead of writing the checksum to the expected location, usually
this means writing the checksum with an offset of -4.

This patch fixes this by adjusting csum_start when VLAN acceleration
is detected.

Fixes: 6680ec68eff4 ("tuntap: hardware vlan tx support")
	Cc: stable@vger.kernel.org
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a8f9bfdf982e2b1fb9f094e4de9ab08c57f3d2fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/tun.c
diff --cc drivers/net/tun.c
index 5e36119f8ef6,57e6bf75a632..000000000000
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@@ -1274,12 -1233,12 +1274,21 @@@ static ssize_t tun_put_user(struct tun_
  			    const struct iovec *iv, int len)
  {
  	struct tun_pi pi = { 0, skb->protocol };
++<<<<<<< HEAD
 +	struct {
 +		__be16 h_vlan_proto;
 +		__be16 h_vlan_TCI;
 +	} veth;
 +	ssize_t total = 0, off = 0;
 +	int vlan_offset = 0;
++=======
+ 	ssize_t total = 0;
+ 	int vlan_offset = 0, copied;
+ 	int vlan_hlen = 0;
+ 
+ 	if (vlan_tx_tag_present(skb))
+ 		vlan_hlen = VLAN_HLEN;
++>>>>>>> a8f9bfdf982e (tun: Fix csum_start with VLAN acceleration)
  
  	if (!(tun->flags & TUN_NO_PI)) {
  		if ((len -= sizeof(pi)) < 0)
@@@ -1343,22 -1301,25 +1353,32 @@@
  		total += tun->vnet_hdr_sz;
  	}
  
++<<<<<<< HEAD
 +	off = total;
 +	if (!vlan_tx_tag_present(skb)) {
 +		len = min_t(int, skb->len, len);
 +	} else {
++=======
+ 	copied = total;
+ 	len = min_t(int, skb->len + vlan_hlen, len);
+ 	total += skb->len + vlan_hlen;
+ 	if (vlan_hlen) {
++>>>>>>> a8f9bfdf982e (tun: Fix csum_start with VLAN acceleration)
  		int copy, ret;
 -		struct {
 -			__be16 h_vlan_proto;
 -			__be16 h_vlan_TCI;
 -		} veth;
  
  		veth.h_vlan_proto = skb->vlan_proto;
  		veth.h_vlan_TCI = htons(vlan_tx_tag_get(skb));
  
  		vlan_offset = offsetof(struct vlan_ethhdr, h_vlan_proto);
++<<<<<<< HEAD
 +		len = min_t(int, skb->len + VLAN_HLEN, len);
++=======
++>>>>>>> a8f9bfdf982e (tun: Fix csum_start with VLAN acceleration)
  
  		copy = min_t(int, vlan_offset, len);
 -		ret = skb_copy_datagram_const_iovec(skb, 0, iv, copied, copy);
 +		ret = skb_copy_datagram_const_iovec(skb, 0, iv, off, copy);
  		len -= copy;
 -		copied += copy;
 +		off += copy;
  		if (ret || !len)
  			goto done;
  
* Unmerged path drivers/net/tun.c
