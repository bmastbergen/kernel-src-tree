IB/iser: Don't pass ib_device to fall_to_bounce_buff routine

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Don't pass ib_device to fall_to_bounce_buff routine (Amir Vadai) [1164539]
Rebuild_FUZZ: 97.44%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit 56408325900d380f6544460c5892bfeb0616cab3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/56408325.failed

No need to pass that, we can take it from the task.
In a later stage, this function will be invoked
according to a device capability.

This patch does not change any functionality.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Adir Lev <adirl@mellanox.com>
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit 56408325900d380f6544460c5892bfeb0616cab3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_memory.c
diff --cc drivers/infiniband/ulp/iser/iser_memory.c
index f40132fc970c,9c60ff1d82a2..000000000000
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@@ -339,23 -334,24 +339,27 @@@ void iser_dma_unmap_task_data(struct is
  }
  
  static int fall_to_bounce_buf(struct iscsi_iser_task *iser_task,
- 			      struct ib_device *ibdev,
  			      struct iser_data_buf *mem,
 +			      struct iser_data_buf *mem_copy,
  			      enum iser_data_dir cmd_dir,
  			      int aligned_len)
  {
++<<<<<<< HEAD
 +	struct iscsi_conn    *iscsi_conn = iser_task->ib_conn->iscsi_conn;
++=======
+ 	struct iscsi_conn *iscsi_conn = iser_task->iser_conn->iscsi_conn;
+ 	struct iser_device *device = iser_task->iser_conn->ib_conn.device;
++>>>>>>> 56408325900d (IB/iser: Don't pass ib_device to fall_to_bounce_buff routine)
  
  	iscsi_conn->fmr_unalign_cnt++;
  	iser_warn("rdma alignment violation (%d/%d aligned) or FMR not supported\n",
  		  aligned_len, mem->size);
  
  	if (iser_debug_level > 0)
- 		iser_data_buf_dump(mem, ibdev);
+ 		iser_data_buf_dump(mem, device->ib_device);
  
  	/* unmap the command data before accessing it */
 -	iser_dma_unmap_task_data(iser_task, mem,
 -				 (cmd_dir == ISER_DIR_OUT) ?
 -				 DMA_TO_DEVICE : DMA_FROM_DEVICE);
 +	iser_dma_unmap_task_data(iser_task, mem);
  
  	/* allocate copy buf, if we are writing, copy the */
  	/* unaligned scatterlist, dma map the copy        */
@@@ -388,8 -384,7 +392,12 @@@ int iser_reg_rdma_mem_fmr(struct iscsi_
  
  	aligned_len = iser_data_buf_aligned_len(mem, ibdev);
  	if (aligned_len != mem->dma_nents) {
++<<<<<<< HEAD
 +		err = fall_to_bounce_buf(iser_task, ibdev, mem,
 +					 &iser_task->data_copy[cmd_dir],
++=======
+ 		err = fall_to_bounce_buf(iser_task, mem,
++>>>>>>> 56408325900d (IB/iser: Don't pass ib_device to fall_to_bounce_buff routine)
  					 cmd_dir, aligned_len);
  		if (err) {
  			iser_err("failed to allocate bounce buffer\n");
@@@ -709,8 -669,7 +717,12 @@@ int iser_reg_rdma_mem_fastreg(struct is
  
  	aligned_len = iser_data_buf_aligned_len(mem, ibdev);
  	if (aligned_len != mem->dma_nents) {
++<<<<<<< HEAD
 +		err = fall_to_bounce_buf(iser_task, ibdev, mem,
 +					 &iser_task->data_copy[cmd_dir],
++=======
+ 		err = fall_to_bounce_buf(iser_task, mem,
++>>>>>>> 56408325900d (IB/iser: Don't pass ib_device to fall_to_bounce_buff routine)
  					 cmd_dir, aligned_len);
  		if (err) {
  			iser_err("failed to allocate bounce buffer\n");
@@@ -742,8 -700,7 +754,12 @@@
  			mem = &iser_task->prot[cmd_dir];
  			aligned_len = iser_data_buf_aligned_len(mem, ibdev);
  			if (aligned_len != mem->dma_nents) {
++<<<<<<< HEAD
 +				err = fall_to_bounce_buf(iser_task, ibdev, mem,
 +							 &iser_task->prot_copy[cmd_dir],
++=======
+ 				err = fall_to_bounce_buf(iser_task, mem,
++>>>>>>> 56408325900d (IB/iser: Don't pass ib_device to fall_to_bounce_buff routine)
  							 cmd_dir, aligned_len);
  				if (err) {
  					iser_err("failed to allocate bounce buffer\n");
* Unmerged path drivers/infiniband/ulp/iser/iser_memory.c
