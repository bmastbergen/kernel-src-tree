hpsa: count passthru cmds with atomics, not a spin locked int

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author Don Brace <don.brace@pmcs.com>
commit 34f0c6277c686b191936cc321faebd15b28f9ece
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/34f0c627.failed

Performance enhancement. Remove spin_locks from the driver.

	Reviewed-by: Scott Teel <scott.teel@pmcs.com>
	Signed-off-by: Don Brace <don.brace@pmcs.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 34f0c6277c686b191936cc321faebd15b28f9ece)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/hpsa.h
diff --cc drivers/scsi/hpsa.h
index b105d9492e11,1856445f883a..000000000000
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@@ -167,9 -182,8 +167,14 @@@ struct ctlr_info 
  	unsigned long transMethod;
  
  	/* cap concurrent passthrus at some reasonable maximum */
++<<<<<<< HEAD
 +#define HPSA_MAX_CONCURRENT_PASSTHRUS (20)
 +	spinlock_t passthru_count_lock; /* protects passthru_count */
 +	int passthru_count;
++=======
+ #define HPSA_MAX_CONCURRENT_PASSTHRUS (10)
+ 	atomic_t passthru_cmds_avail;
++>>>>>>> 34f0c6277c68 (hpsa: count passthru cmds with atomics, not a spin locked int)
  
  	/*
  	 * Performant mode completion buffers
diff --git a/drivers/scsi/hpsa.c b/drivers/scsi/hpsa.c
index 3e784c38914c..f4ff93c2b771 100644
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@ -4943,35 +4943,6 @@ static void check_ioctl_unit_attention(struct ctlr_info *h,
 		(void) check_for_unit_attention(h, c);
 }
 
-static int increment_passthru_count(struct ctlr_info *h)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&h->passthru_count_lock, flags);
-	if (h->passthru_count >= HPSA_MAX_CONCURRENT_PASSTHRUS) {
-		spin_unlock_irqrestore(&h->passthru_count_lock, flags);
-		return -1;
-	}
-	h->passthru_count++;
-	spin_unlock_irqrestore(&h->passthru_count_lock, flags);
-	return 0;
-}
-
-static void decrement_passthru_count(struct ctlr_info *h)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&h->passthru_count_lock, flags);
-	if (h->passthru_count <= 0) {
-		spin_unlock_irqrestore(&h->passthru_count_lock, flags);
-		/* not expecting to get here. */
-		dev_warn(&h->pdev->dev, "Bug detected, passthru_count seems to be incorrect.\n");
-		return;
-	}
-	h->passthru_count--;
-	spin_unlock_irqrestore(&h->passthru_count_lock, flags);
-}
-
 /*
  * ioctl
  */
@@ -4994,16 +4965,16 @@ static int hpsa_ioctl(struct scsi_device *dev, int cmd, void __user *arg)
 	case CCISS_GETDRIVVER:
 		return hpsa_getdrivver_ioctl(h, argp);
 	case CCISS_PASSTHRU:
-		if (increment_passthru_count(h))
+		if (atomic_dec_if_positive(&h->passthru_cmds_avail) < 0)
 			return -EAGAIN;
 		rc = hpsa_passthru_ioctl(h, argp);
-		decrement_passthru_count(h);
+		atomic_inc(&h->passthru_cmds_avail);
 		return rc;
 	case CCISS_BIG_PASSTHRU:
-		if (increment_passthru_count(h))
+		if (atomic_dec_if_positive(&h->passthru_cmds_avail) < 0)
 			return -EAGAIN;
 		rc = hpsa_big_passthru_ioctl(h, argp);
-		decrement_passthru_count(h);
+		atomic_inc(&h->passthru_cmds_avail);
 		return rc;
 	default:
 		return -ENOTTY;
@@ -6685,7 +6656,7 @@ reinit_after_soft_reset:
 	spin_lock_init(&h->lock);
 	spin_lock_init(&h->offline_device_lock);
 	spin_lock_init(&h->scan_lock);
-	spin_lock_init(&h->passthru_count_lock);
+	atomic_set(&h->passthru_cmds_avail, HPSA_MAX_CONCURRENT_PASSTHRUS);
 
 	/* Allocate and clear per-cpu variable lockup_detected */
 	h->lockup_detected = alloc_percpu(u32);
* Unmerged path drivers/scsi/hpsa.h
