ovl: upper fs should not be R/O

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
commit-author hujianyang <hujianyang@huawei.com>
commit 71cbad7e694ee81233b3be3a38b81c3d5872cc6f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/71cbad7e.failed

After importing multi-lower layer support, users could mount a r/o
partition as the left most lowerdir instead of using it as upperdir.
And a r/o upperdir may cause an error like

	overlayfs: failed to create directory ./workdir/work

during mount.

This patch check the *s_flags* of upper fs and return an error if
it is a r/o partition. The checking of *upper_mnt->mnt_sb->s_flags*
can be removed now.

This patch also remove

	/* FIXME: workdir is not needed for a R/O mount */

from ovl_fill_super() because:

1) for upper fs r/o case
Setting a r/o partition as upper is prevented, no need to care about
workdir in this case.

2) for "mount overlay -o ro" with a r/w upper fs case
Users could remount overlayfs to r/w in this case, so workdir should
not be omitted.

	Signed-off-by: hujianyang <hujianyang@huawei.com>
	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit 71cbad7e694ee81233b3be3a38b81c3d5872cc6f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/overlayfs/super.c
diff --cc fs/overlayfs/super.c
index 247af4499a61,5f0d1993e6e3..000000000000
--- a/fs/overlayfs/super.c
+++ b/fs/overlayfs/super.c
@@@ -698,104 -844,117 +706,145 @@@ static int ovl_fill_super(struct super_
  		goto out_free_config;
  	}
  
++<<<<<<< HEAD
++=======
+ 	sb->s_stack_depth = 0;
+ 	if (ufs->config.upperdir) {
+ 		if (!ufs->config.workdir) {
+ 			pr_err("overlayfs: missing 'workdir'\n");
+ 			goto out_free_config;
+ 		}
+ 
+ 		err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
+ 		if (err)
+ 			goto out_free_config;
+ 
+ 		/* Upper fs should not be r/o */
+ 		if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) {
+ 			pr_err("overlayfs: upper fs is r/o, try multi-lower layers mount\n");
+ 			err = -EINVAL;
+ 			goto out_put_upperpath;
+ 		}
+ 
+ 		err = ovl_mount_dir(ufs->config.workdir, &workpath);
+ 		if (err)
+ 			goto out_put_upperpath;
+ 
+ 		err = -EINVAL;
+ 		if (upperpath.mnt != workpath.mnt) {
+ 			pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
+ 			goto out_put_workpath;
+ 		}
+ 		if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
+ 			pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
+ 			goto out_put_workpath;
+ 		}
+ 		sb->s_stack_depth = upperpath.mnt->mnt_sb->s_stack_depth;
+ 	}
++>>>>>>> 71cbad7e694e (ovl: upper fs should not be R/O)
  	err = -ENOMEM;
 -	lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL);
 -	if (!lowertmp)
 -		goto out_put_workpath;
 +	oe = ovl_alloc_entry();
 +	if (oe == NULL)
 +		goto out_free_config;
 +
 +	err = ovl_mount_dir(ufs->config.upperdir, &upperpath);
 +	if (err)
 +		goto out_free_oe;
 +
 +	err = ovl_mount_dir(ufs->config.lowerdir, &lowerpath);
 +	if (err)
 +		goto out_put_upperpath;
 +
 +	err = ovl_mount_dir(ufs->config.workdir, &workpath);
 +	if (err)
 +		goto out_put_lowerpath;
  
  	err = -EINVAL;
 -	stacklen = ovl_split_lowerdirs(lowertmp);
 -	if (stacklen > OVL_MAX_STACK) {
 -		pr_err("overlayfs: too many lower directries, limit is %d\n",
 -		       OVL_MAX_STACK);
 -		goto out_free_lowertmp;
 -	} else if (!ufs->config.upperdir && stacklen == 1) {
 -		pr_err("overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n");
 -		goto out_free_lowertmp;
 +	if (!S_ISDIR(upperpath.dentry->d_inode->i_mode) ||
 +	    !S_ISDIR(lowerpath.dentry->d_inode->i_mode) ||
 +	    !S_ISDIR(workpath.dentry->d_inode->i_mode)) {
 +		pr_err("overlayfs: upperdir or lowerdir or workdir not a directory\n");
 +		goto out_put_workpath;
  	}
  
 -	stack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL);
 -	if (!stack)
 -		goto out_free_lowertmp;
 +	if (upperpath.mnt != workpath.mnt) {
 +		pr_err("overlayfs: workdir and upperdir must reside under the same mount\n");
 +		goto out_put_workpath;
 +	}
 +	if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) {
 +		pr_err("overlayfs: workdir and upperdir must be separate subtrees\n");
 +		goto out_put_workpath;
 +	}
  
 -	lower = lowertmp;
 -	for (numlower = 0; numlower < stacklen; numlower++) {
 -		err = ovl_lower_dir(lower, &stack[numlower],
 -				    &ufs->lower_namelen, &sb->s_stack_depth);
 -		if (err)
 -			goto out_put_lowerpath;
 +	if (!ovl_is_allowed_fs_type(upperpath.dentry)) {
 +		pr_err("overlayfs: filesystem of upperdir is not supported\n");
 +		goto out_put_workpath;
 +	}
  
 -		lower = strchr(lower, '\0') + 1;
++<<<<<<< HEAD
 +	if (!ovl_is_allowed_fs_type(lowerpath.dentry)) {
 +		pr_err("overlayfs: filesystem of lowerdir is not supported\n");
 +		goto out_put_workpath;
  	}
  
 +	err = vfs_statfs(&lowerpath, &statfs);
 +	if (err) {
 +		pr_err("overlayfs: statfs failed on lowerpath\n");
 +		goto out_put_workpath;
 +	}
 +	ufs->lower_namelen = statfs.f_namelen;
 +
 +	upper_stack_depth = get_s_stack_depth(upperpath.mnt->mnt_sb);
 +	lower_stack_depth = get_s_stack_depth(lowerpath.mnt->mnt_sb);
 +	overlay_stack_depth = get_s_stack_depth(sb);
 +	err = -EOPNOTSUPP;
 +	if (!upper_stack_depth || !lower_stack_depth || !overlay_stack_depth) {
 +		pr_err("overlayfs: superblock missing extension wrapper (old kernel?)\n");
 +		goto out_put_workpath;
 +	}
 +
 +	*overlay_stack_depth = max(*upper_stack_depth, *lower_stack_depth) + 1;
 +
  	err = -EINVAL;
 -	sb->s_stack_depth++;
 -	if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
 +	if (*overlay_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) {
  		pr_err("overlayfs: maximum fs stacking depth exceeded\n");
 -		goto out_put_lowerpath;
 +		goto out_put_workpath;
  	}
  
 -	if (ufs->config.upperdir) {
 -		ufs->upper_mnt = clone_private_mount(&upperpath);
 -		err = PTR_ERR(ufs->upper_mnt);
 -		if (IS_ERR(ufs->upper_mnt)) {
 -			pr_err("overlayfs: failed to clone upperpath\n");
 -			goto out_put_lowerpath;
 -		}
 -
 -		ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
 -		err = PTR_ERR(ufs->workdir);
 -		if (IS_ERR(ufs->workdir)) {
 -			pr_err("overlayfs: failed to create directory %s/%s\n",
 -			       ufs->config.workdir, OVL_WORKDIR_NAME);
 -			goto out_put_upper_mnt;
 -		}
 +	ufs->upper_mnt = clone_private_mount(&upperpath);
 +	err = PTR_ERR(ufs->upper_mnt);
 +	if (IS_ERR(ufs->upper_mnt)) {
 +		pr_err("overlayfs: failed to clone upperpath\n");
 +		goto out_put_workpath;
  	}
  
 -	err = -ENOMEM;
 -	ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL);
 -	if (ufs->lower_mnt == NULL)
 -		goto out_put_workdir;
 -	for (i = 0; i < numlower; i++) {
 -		struct vfsmount *mnt = clone_private_mount(&stack[i]);
 +	ufs->lower_mnt = clone_private_mount(&lowerpath);
 +	err = PTR_ERR(ufs->lower_mnt);
 +	if (IS_ERR(ufs->lower_mnt)) {
 +		pr_err("overlayfs: failed to clone lowerpath\n");
 +		goto out_put_upper_mnt;
 +	}
  
 -		err = PTR_ERR(mnt);
 -		if (IS_ERR(mnt)) {
 -			pr_err("overlayfs: failed to clone lowerpath\n");
 -			goto out_put_lower_mnt;
 -		}
 -		/*
 -		 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 -		 * will fail instead of modifying lower fs.
 -		 */
 -		mnt->mnt_flags |= MNT_READONLY;
 -
 -		ufs->lower_mnt[ufs->numlower] = mnt;
 -		ufs->numlower++;
 +	ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry);
 +	err = PTR_ERR(ufs->workdir);
 +	if (IS_ERR(ufs->workdir)) {
 +		pr_err("overlayfs: failed to create directory %s/%s\n",
 +		       ufs->config.workdir, OVL_WORKDIR_NAME);
 +		goto out_put_lower_mnt;
  	}
  
 +	/*
 +	 * Make lower_mnt R/O.  That way fchmod/fchown on lower file
 +	 * will fail instead of modifying lower fs.
 +	 */
 +	ufs->lower_mnt->mnt_flags |= MNT_READONLY;
 +
 +	/* If the upper fs is r/o, we mark overlayfs r/o too */
 +	if (ufs->upper_mnt->mnt_sb->s_flags & MS_RDONLY)
++=======
+ 	/* If the upper fs is nonexistent, we mark overlayfs r/o too */
+ 	if (!ufs->upper_mnt)
++>>>>>>> 71cbad7e694e (ovl: upper fs should not be R/O)
  		sb->s_flags |= MS_RDONLY;
  
  	sb->s_d_op = &ovl_dentry_operations;
* Unmerged path fs/overlayfs/super.c
