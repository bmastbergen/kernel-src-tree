net/core: Add reading VF statistics through the PF netdevice

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [net] core: Add reading VF statistics through the PF netdevice (Amir Vadai) [1164527 1164530 1164531 1164536 1164537]
Rebuild_FUZZ: 96.55%
commit-author Eran Ben Elisha <eranbe@mellanox.com>
commit 3b766cd832328fcb87db3507e7b98cf42f21689d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/3b766cd8.failed

Add ndo_get_vf_stats where the PF retrieves and fills the VFs traffic
statistics. We encode the VF stats in a nested manner to allow for
future extensions.

	Signed-off-by: Eran Ben Elisha <eranbe@mellanox.com>
	Signed-off-by: Hadar Hen Zion <hadarh@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3b766cd832328fcb87db3507e7b98cf42f21689d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_link.h
#	net/core/rtnetlink.c
diff --cc include/uapi/linux/if_link.h
index 4efe6bcb6e67,2c7e8e3d3981..000000000000
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@@ -359,9 -477,14 +359,17 @@@ enum 
  	IFLA_VF_UNSPEC,
  	IFLA_VF_MAC,		/* Hardware queue specific attributes */
  	IFLA_VF_VLAN,
 -	IFLA_VF_TX_RATE,	/* Max TX Bandwidth Allocation */
 +	IFLA_VF_TX_RATE,	/* TX Bandwidth Allocation */
  	IFLA_VF_SPOOFCHK,	/* Spoof Checking on/off switch */
  	IFLA_VF_LINK_STATE,	/* link state enable/disable/auto switch */
++<<<<<<< HEAD
++=======
+ 	IFLA_VF_RATE,		/* Min and Max TX Bandwidth Allocation */
+ 	IFLA_VF_RSS_QUERY_EN,	/* RSS Redirection Table and Hash Key query
+ 				 * on/off switch
+ 				 */
+ 	IFLA_VF_STATS,		/* network device statistics */
++>>>>>>> 3b766cd83232 (net/core: Add reading VF statistics through the PF netdevice)
  	__IFLA_VF_MAX,
  };
  
@@@ -400,6 -529,23 +408,26 @@@ struct ifla_vf_link_state 
  	__u32 link_state;
  };
  
++<<<<<<< HEAD
++=======
+ struct ifla_vf_rss_query_en {
+ 	__u32 vf;
+ 	__u32 setting;
+ };
+ 
+ enum {
+ 	IFLA_VF_STATS_RX_PACKETS,
+ 	IFLA_VF_STATS_TX_PACKETS,
+ 	IFLA_VF_STATS_RX_BYTES,
+ 	IFLA_VF_STATS_TX_BYTES,
+ 	IFLA_VF_STATS_BROADCAST,
+ 	IFLA_VF_STATS_MULTICAST,
+ 	__IFLA_VF_STATS_MAX,
+ };
+ 
+ #define IFLA_VF_STATS_MAX (__IFLA_VF_STATS_MAX - 1)
+ 
++>>>>>>> 3b766cd83232 (net/core: Add reading VF statistics through the PF netdevice)
  /* VF ports management section
   *
   *	Nested layout of set/get msg is:
diff --cc net/core/rtnetlink.c
index 46e91a591c6a,2d102ce1474f..000000000000
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@@ -743,9 -816,22 +743,27 @@@ static inline int rtnl_vfinfo_size(cons
  		size += num_vfs *
  			(nla_total_size(sizeof(struct ifla_vf_mac)) +
  			 nla_total_size(sizeof(struct ifla_vf_vlan)) +
 +			 nla_total_size(sizeof(struct ifla_vf_tx_rate)) +
  			 nla_total_size(sizeof(struct ifla_vf_spoofchk)) +
++<<<<<<< HEAD
 +			 nla_total_size(sizeof(struct ifla_vf_link_state)));
++=======
+ 			 nla_total_size(sizeof(struct ifla_vf_rate)) +
+ 			 nla_total_size(sizeof(struct ifla_vf_link_state)) +
+ 			 nla_total_size(sizeof(struct ifla_vf_rss_query_en)) +
+ 			 /* IFLA_VF_STATS_RX_PACKETS */
+ 			 nla_total_size(sizeof(__u64)) +
+ 			 /* IFLA_VF_STATS_TX_PACKETS */
+ 			 nla_total_size(sizeof(__u64)) +
+ 			 /* IFLA_VF_STATS_RX_BYTES */
+ 			 nla_total_size(sizeof(__u64)) +
+ 			 /* IFLA_VF_STATS_TX_BYTES */
+ 			 nla_total_size(sizeof(__u64)) +
+ 			 /* IFLA_VF_STATS_BROADCAST */
+ 			 nla_total_size(sizeof(__u64)) +
+ 			 /* IFLA_VF_STATS_MULTICAST */
+ 			 nla_total_size(sizeof(__u64)));
++>>>>>>> 3b766cd83232 (net/core: Add reading VF statistics through the PF netdevice)
  		return size;
  	} else
  		return 0;
@@@ -1011,6 -1148,9 +1029,11 @@@ static int rtnl_fill_ifinfo(struct sk_b
  			struct ifla_vf_tx_rate vf_tx_rate;
  			struct ifla_vf_spoofchk vf_spoofchk;
  			struct ifla_vf_link_state vf_linkstate;
++<<<<<<< HEAD
++=======
+ 			struct ifla_vf_rss_query_en vf_rss_query_en;
+ 			struct ifla_vf_stats vf_stats;
++>>>>>>> 3b766cd83232 (net/core: Add reading VF statistics through the PF netdevice)
  
  			/*
  			 * Not all SR-IOV capable drivers support the
@@@ -1050,8 -1198,35 +1073,32 @@@
  			    nla_put(skb, IFLA_VF_SPOOFCHK, sizeof(vf_spoofchk),
  				    &vf_spoofchk) ||
  			    nla_put(skb, IFLA_VF_LINK_STATE, sizeof(vf_linkstate),
 -				    &vf_linkstate) ||
 -			    nla_put(skb, IFLA_VF_RSS_QUERY_EN,
 -				    sizeof(vf_rss_query_en),
 -				    &vf_rss_query_en))
 +				    &vf_linkstate))
  				goto nla_put_failure;
+ 			memset(&vf_stats, 0, sizeof(vf_stats));
+ 			if (dev->netdev_ops->ndo_get_vf_stats)
+ 				dev->netdev_ops->ndo_get_vf_stats(dev, i,
+ 								  &vf_stats);
+ 			vfstats = nla_nest_start(skb, IFLA_VF_STATS);
+ 			if (!vfstats) {
+ 				nla_nest_cancel(skb, vf);
+ 				nla_nest_cancel(skb, vfinfo);
+ 				goto nla_put_failure;
+ 			}
+ 			if (nla_put_u64(skb, IFLA_VF_STATS_RX_PACKETS,
+ 					vf_stats.rx_packets) ||
+ 			    nla_put_u64(skb, IFLA_VF_STATS_TX_PACKETS,
+ 					vf_stats.tx_packets) ||
+ 			    nla_put_u64(skb, IFLA_VF_STATS_RX_BYTES,
+ 					vf_stats.rx_bytes) ||
+ 			    nla_put_u64(skb, IFLA_VF_STATS_TX_BYTES,
+ 					vf_stats.tx_bytes) ||
+ 			    nla_put_u64(skb, IFLA_VF_STATS_BROADCAST,
+ 					vf_stats.broadcast) ||
+ 			    nla_put_u64(skb, IFLA_VF_STATS_MULTICAST,
+ 					vf_stats.multicast))
+ 				goto nla_put_failure;
+ 			nla_nest_end(skb, vfstats);
  			nla_nest_end(skb, vf);
  		}
  		nla_nest_end(skb, vfinfo);
@@@ -1140,14 -1333,23 +1187,34 @@@ static const struct nla_policy ifla_vfi
  };
  
  static const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {
++<<<<<<< HEAD
 +	[IFLA_VF_MAC]		= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_vf_mac) },
 +	[IFLA_VF_VLAN]		= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_vf_vlan) },
 +	[IFLA_VF_TX_RATE]	= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_vf_tx_rate) },
 +	[IFLA_VF_SPOOFCHK]	= { .type = NLA_BINARY,
 +				    .len = sizeof(struct ifla_vf_spoofchk) },
++=======
+ 	[IFLA_VF_MAC]		= { .len = sizeof(struct ifla_vf_mac) },
+ 	[IFLA_VF_VLAN]		= { .len = sizeof(struct ifla_vf_vlan) },
+ 	[IFLA_VF_TX_RATE]	= { .len = sizeof(struct ifla_vf_tx_rate) },
+ 	[IFLA_VF_SPOOFCHK]	= { .len = sizeof(struct ifla_vf_spoofchk) },
+ 	[IFLA_VF_RATE]		= { .len = sizeof(struct ifla_vf_rate) },
+ 	[IFLA_VF_LINK_STATE]	= { .len = sizeof(struct ifla_vf_link_state) },
+ 	[IFLA_VF_RSS_QUERY_EN]	= { .len = sizeof(struct ifla_vf_rss_query_en) },
+ 	[IFLA_VF_STATS]		= { .type = NLA_NESTED },
+ };
+ 
+ static const struct nla_policy ifla_vf_stats_policy[IFLA_VF_STATS_MAX + 1] = {
+ 	[IFLA_VF_STATS_RX_PACKETS]	= { .type = NLA_U64 },
+ 	[IFLA_VF_STATS_TX_PACKETS]	= { .type = NLA_U64 },
+ 	[IFLA_VF_STATS_RX_BYTES]	= { .type = NLA_U64 },
+ 	[IFLA_VF_STATS_TX_BYTES]	= { .type = NLA_U64 },
+ 	[IFLA_VF_STATS_BROADCAST]	= { .type = NLA_U64 },
+ 	[IFLA_VF_STATS_MULTICAST]	= { .type = NLA_U64 },
++>>>>>>> 3b766cd83232 (net/core: Add reading VF statistics through the PF netdevice)
  };
  
  static const struct nla_policy ifla_port_policy[IFLA_PORT_MAX+1] = {
diff --git a/include/linux/if_link.h b/include/linux/if_link.h
index a86784dec3d3..88b872923796 100644
--- a/include/linux/if_link.h
+++ b/include/linux/if_link.h
@@ -5,6 +5,15 @@
 
 
 /* We don't want this structure exposed to user space */
+struct ifla_vf_stats {
+	__u64 rx_packets;
+	__u64 tx_packets;
+	__u64 rx_bytes;
+	__u64 tx_bytes;
+	__u64 broadcast;
+	__u64 multicast;
+};
+
 struct ifla_vf_info {
 	__u32 vf;
 	__u8 mac[32];
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index c81a9410e562..5afe36ef8a14 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1020,6 +1020,10 @@ struct net_device_ops {
 						     struct ifla_vf_info *ivf);
 	int			(*ndo_set_vf_link_state)(struct net_device *dev,
 							 int vf, int link_state);
+	int			(*ndo_get_vf_stats)(struct net_device *dev,
+						    int vf,
+						    struct ifla_vf_stats
+						    *vf_stats);
 	int			(*ndo_set_vf_port)(struct net_device *dev,
 						   int vf,
 						   struct nlattr *port[]);
* Unmerged path include/uapi/linux/if_link.h
* Unmerged path net/core/rtnetlink.c
