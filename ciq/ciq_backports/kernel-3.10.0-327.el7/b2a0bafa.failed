ALSA: hda - Use shutdown driver ops instead of reboot notifier

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [alsa] hda - Use shutdown driver ops instead of reboot notifier (Jaroslav Kysela) [1197064]
Rebuild_FUZZ: 94.92%
commit-author Takashi Iwai <tiwai@suse.de>
commit b2a0bafa758256442e04d1f34d6d0746b846d23d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/b2a0bafa.failed

The driver shutdown ops is simpler than registering reboot notifier
manually.  There should be no functional change by this -- the codec
driver calls its own callback while the bus driver just calls
azx_stop() like before.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit b2a0bafa758256442e04d1f34d6d0746b846d23d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_controller.h
#	sound/pci/hda/hda_intel.c
#	sound/pci/hda/hda_tegra.c
diff --cc sound/pci/hda/hda_controller.h
index 2993061145a5,be1b7ded8d82..000000000000
--- a/sound/pci/hda/hda_controller.h
+++ b/sound/pci/hda/hda_controller.h
@@@ -15,10 -15,396 +15,397 @@@
  #ifndef __SOUND_HDA_CONTROLLER_H
  #define __SOUND_HDA_CONTROLLER_H
  
 -#include <linux/timecounter.h>
 -#include <linux/interrupt.h>
  #include <sound/core.h>
 -#include <sound/pcm.h>
  #include <sound/initval.h>
  #include "hda_codec.h"
++<<<<<<< HEAD
 +#include "hda_priv.h"
++=======
+ 
+ /*
+  * registers
+  */
+ #define AZX_REG_GCAP			0x00
+ #define   AZX_GCAP_64OK		(1 << 0)   /* 64bit address support */
+ #define   AZX_GCAP_NSDO		(3 << 1)   /* # of serial data out signals */
+ #define   AZX_GCAP_BSS		(31 << 3)  /* # of bidirectional streams */
+ #define   AZX_GCAP_ISS		(15 << 8)  /* # of input streams */
+ #define   AZX_GCAP_OSS		(15 << 12) /* # of output streams */
+ #define AZX_REG_VMIN			0x02
+ #define AZX_REG_VMAJ			0x03
+ #define AZX_REG_OUTPAY			0x04
+ #define AZX_REG_INPAY			0x06
+ #define AZX_REG_GCTL			0x08
+ #define   AZX_GCTL_RESET	(1 << 0)   /* controller reset */
+ #define   AZX_GCTL_FCNTRL	(1 << 1)   /* flush control */
+ #define   AZX_GCTL_UNSOL	(1 << 8)   /* accept unsol. response enable */
+ #define AZX_REG_WAKEEN			0x0c
+ #define AZX_REG_STATESTS		0x0e
+ #define AZX_REG_GSTS			0x10
+ #define   AZX_GSTS_FSTS		(1 << 1)   /* flush status */
+ #define AZX_REG_INTCTL			0x20
+ #define AZX_REG_INTSTS			0x24
+ #define AZX_REG_WALLCLK			0x30	/* 24Mhz source */
+ #define AZX_REG_OLD_SSYNC		0x34	/* SSYNC for old ICH */
+ #define AZX_REG_SSYNC			0x38
+ #define AZX_REG_CORBLBASE		0x40
+ #define AZX_REG_CORBUBASE		0x44
+ #define AZX_REG_CORBWP			0x48
+ #define AZX_REG_CORBRP			0x4a
+ #define   AZX_CORBRP_RST	(1 << 15)  /* read pointer reset */
+ #define AZX_REG_CORBCTL			0x4c
+ #define   AZX_CORBCTL_RUN	(1 << 1)   /* enable DMA */
+ #define   AZX_CORBCTL_CMEIE	(1 << 0)   /* enable memory error irq */
+ #define AZX_REG_CORBSTS			0x4d
+ #define   AZX_CORBSTS_CMEI	(1 << 0)   /* memory error indication */
+ #define AZX_REG_CORBSIZE		0x4e
+ 
+ #define AZX_REG_RIRBLBASE		0x50
+ #define AZX_REG_RIRBUBASE		0x54
+ #define AZX_REG_RIRBWP			0x58
+ #define   AZX_RIRBWP_RST	(1 << 15)  /* write pointer reset */
+ #define AZX_REG_RINTCNT			0x5a
+ #define AZX_REG_RIRBCTL			0x5c
+ #define   AZX_RBCTL_IRQ_EN	(1 << 0)   /* enable IRQ */
+ #define   AZX_RBCTL_DMA_EN	(1 << 1)   /* enable DMA */
+ #define   AZX_RBCTL_OVERRUN_EN	(1 << 2)   /* enable overrun irq */
+ #define AZX_REG_RIRBSTS			0x5d
+ #define   AZX_RBSTS_IRQ		(1 << 0)   /* response irq */
+ #define   AZX_RBSTS_OVERRUN	(1 << 2)   /* overrun irq */
+ #define AZX_REG_RIRBSIZE		0x5e
+ 
+ #define AZX_REG_IC			0x60
+ #define AZX_REG_IR			0x64
+ #define AZX_REG_IRS			0x68
+ #define   AZX_IRS_VALID		(1<<1)
+ #define   AZX_IRS_BUSY		(1<<0)
+ 
+ #define AZX_REG_DPLBASE			0x70
+ #define AZX_REG_DPUBASE			0x74
+ #define   AZX_DPLBASE_ENABLE	0x1	/* Enable position buffer */
+ 
+ /* SD offset: SDI0=0x80, SDI1=0xa0, ... SDO3=0x160 */
+ enum { SDI0, SDI1, SDI2, SDI3, SDO0, SDO1, SDO2, SDO3 };
+ 
+ /* stream register offsets from stream base */
+ #define AZX_REG_SD_CTL			0x00
+ #define AZX_REG_SD_STS			0x03
+ #define AZX_REG_SD_LPIB			0x04
+ #define AZX_REG_SD_CBL			0x08
+ #define AZX_REG_SD_LVI			0x0c
+ #define AZX_REG_SD_FIFOW		0x0e
+ #define AZX_REG_SD_FIFOSIZE		0x10
+ #define AZX_REG_SD_FORMAT		0x12
+ #define AZX_REG_SD_BDLPL		0x18
+ #define AZX_REG_SD_BDLPU		0x1c
+ 
+ /* PCI space */
+ #define AZX_PCIREG_TCSEL		0x44
+ 
+ /*
+  * other constants
+  */
+ 
+ /* max number of fragments - we may use more if allocating more pages for BDL */
+ #define BDL_SIZE		4096
+ #define AZX_MAX_BDL_ENTRIES	(BDL_SIZE / 16)
+ #define AZX_MAX_FRAG		32
+ /* max buffer size - no h/w limit, you can increase as you like */
+ #define AZX_MAX_BUF_SIZE	(1024*1024*1024)
+ 
+ /* RIRB int mask: overrun[2], response[0] */
+ #define RIRB_INT_RESPONSE	0x01
+ #define RIRB_INT_OVERRUN	0x04
+ #define RIRB_INT_MASK		0x05
+ 
+ /* STATESTS int mask: S3,SD2,SD1,SD0 */
+ #define AZX_MAX_CODECS		8
+ #define AZX_DEFAULT_CODECS	4
+ #define STATESTS_INT_MASK	((1 << AZX_MAX_CODECS) - 1)
+ 
+ /* SD_CTL bits */
+ #define SD_CTL_STREAM_RESET	0x01	/* stream reset bit */
+ #define SD_CTL_DMA_START	0x02	/* stream DMA start bit */
+ #define SD_CTL_STRIPE		(3 << 16)	/* stripe control */
+ #define SD_CTL_TRAFFIC_PRIO	(1 << 18)	/* traffic priority */
+ #define SD_CTL_DIR		(1 << 19)	/* bi-directional stream */
+ #define SD_CTL_STREAM_TAG_MASK	(0xf << 20)
+ #define SD_CTL_STREAM_TAG_SHIFT	20
+ 
+ /* SD_CTL and SD_STS */
+ #define SD_INT_DESC_ERR		0x10	/* descriptor error interrupt */
+ #define SD_INT_FIFO_ERR		0x08	/* FIFO error interrupt */
+ #define SD_INT_COMPLETE		0x04	/* completion interrupt */
+ #define SD_INT_MASK		(SD_INT_DESC_ERR|SD_INT_FIFO_ERR|\
+ 				 SD_INT_COMPLETE)
+ 
+ /* SD_STS */
+ #define SD_STS_FIFO_READY	0x20	/* FIFO ready */
+ 
+ /* INTCTL and INTSTS */
+ #define AZX_INT_ALL_STREAM	0xff	   /* all stream interrupts */
+ #define AZX_INT_CTRL_EN	0x40000000 /* controller interrupt enable bit */
+ #define AZX_INT_GLOBAL_EN	0x80000000 /* global interrupt enable bit */
+ 
+ /* below are so far hardcoded - should read registers in future */
+ #define AZX_MAX_CORB_ENTRIES	256
+ #define AZX_MAX_RIRB_ENTRIES	256
+ 
+ /* driver quirks (capabilities) */
+ /* bits 0-7 are used for indicating driver type */
+ #define AZX_DCAPS_NO_TCSEL	(1 << 8)	/* No Intel TCSEL bit */
+ #define AZX_DCAPS_NO_MSI	(1 << 9)	/* No MSI support */
+ #define AZX_DCAPS_SNOOP_MASK	(3 << 10)	/* snoop type mask */
+ #define AZX_DCAPS_SNOOP_OFF	(1 << 12)	/* snoop default off */
+ #define AZX_DCAPS_RIRB_DELAY	(1 << 13)	/* Long delay in read loop */
+ #define AZX_DCAPS_RIRB_PRE_DELAY (1 << 14)	/* Put a delay before read */
+ #define AZX_DCAPS_CTX_WORKAROUND (1 << 15)	/* X-Fi workaround */
+ #define AZX_DCAPS_POSFIX_LPIB	(1 << 16)	/* Use LPIB as default */
+ #define AZX_DCAPS_POSFIX_VIA	(1 << 17)	/* Use VIACOMBO as default */
+ #define AZX_DCAPS_NO_64BIT	(1 << 18)	/* No 64bit address */
+ #define AZX_DCAPS_SYNC_WRITE	(1 << 19)	/* sync each cmd write */
+ #define AZX_DCAPS_OLD_SSYNC	(1 << 20)	/* Old SSYNC reg for ICH */
+ #define AZX_DCAPS_NO_ALIGN_BUFSIZE (1 << 21)	/* no buffer size alignment */
+ /* 22 unused */
+ #define AZX_DCAPS_4K_BDLE_BOUNDARY (1 << 23)	/* BDLE in 4k boundary */
+ #define AZX_DCAPS_REVERSE_ASSIGN (1 << 24)	/* Assign devices in reverse order */
+ #define AZX_DCAPS_COUNT_LPIB_DELAY  (1 << 25)	/* Take LPIB as delay */
+ #define AZX_DCAPS_PM_RUNTIME	(1 << 26)	/* runtime PM support */
+ #define AZX_DCAPS_I915_POWERWELL (1 << 27)	/* HSW i915 powerwell support */
+ #define AZX_DCAPS_CORBRP_SELF_CLEAR (1 << 28)	/* CORBRP clears itself after reset */
+ #define AZX_DCAPS_NO_MSI64      (1 << 29)	/* Stick to 32-bit MSIs */
+ #define AZX_DCAPS_SEPARATE_STREAM_TAG	(1 << 30) /* capture and playback use separate stream tag */
+ 
+ enum {
+ 	AZX_SNOOP_TYPE_NONE,
+ 	AZX_SNOOP_TYPE_SCH,
+ 	AZX_SNOOP_TYPE_ATI,
+ 	AZX_SNOOP_TYPE_NVIDIA,
+ };
+ 
+ /* HD Audio class code */
+ #define PCI_CLASS_MULTIMEDIA_HD_AUDIO	0x0403
+ 
+ struct azx_dev {
+ 	struct snd_dma_buffer bdl; /* BDL buffer */
+ 	u32 *posbuf;		/* position buffer pointer */
+ 
+ 	unsigned int bufsize;	/* size of the play buffer in bytes */
+ 	unsigned int period_bytes; /* size of the period in bytes */
+ 	unsigned int frags;	/* number for period in the play buffer */
+ 	unsigned int fifo_size;	/* FIFO size */
+ 	unsigned long start_wallclk;	/* start + minimum wallclk */
+ 	unsigned long period_wallclk;	/* wallclk for period */
+ 
+ 	void __iomem *sd_addr;	/* stream descriptor pointer */
+ 
+ 	u32 sd_int_sta_mask;	/* stream int status mask */
+ 
+ 	/* pcm support */
+ 	struct snd_pcm_substream *substream;	/* assigned substream,
+ 						 * set in PCM open
+ 						 */
+ 	unsigned int format_val;	/* format value to be set in the
+ 					 * controller and the codec
+ 					 */
+ 	unsigned char stream_tag;	/* assigned stream */
+ 	unsigned char index;		/* stream index */
+ 	int assigned_key;		/* last device# key assigned to */
+ 
+ 	unsigned int opened:1;
+ 	unsigned int running:1;
+ 	unsigned int irq_pending:1;
+ 	unsigned int prepared:1;
+ 	unsigned int locked:1;
+ 	/*
+ 	 * For VIA:
+ 	 *  A flag to ensure DMA position is 0
+ 	 *  when link position is not greater than FIFO size
+ 	 */
+ 	unsigned int insufficient:1;
+ 	unsigned int wc_marked:1;
+ 	unsigned int no_period_wakeup:1;
+ 
+ 	struct timecounter  azx_tc;
+ 	struct cyclecounter azx_cc;
+ 
+ 	int delay_negative_threshold;
+ 
+ #ifdef CONFIG_SND_HDA_DSP_LOADER
+ 	/* Allows dsp load to have sole access to the playback stream. */
+ 	struct mutex dsp_mutex;
+ #endif
+ };
+ 
+ /* CORB/RIRB */
+ struct azx_rb {
+ 	u32 *buf;		/* CORB/RIRB buffer
+ 				 * Each CORB entry is 4byte, RIRB is 8byte
+ 				 */
+ 	dma_addr_t addr;	/* physical address of CORB/RIRB buffer */
+ 	/* for RIRB */
+ 	unsigned short rp, wp;	/* read/write pointers */
+ 	int cmds[AZX_MAX_CODECS];	/* number of pending requests */
+ 	u32 res[AZX_MAX_CODECS];	/* last read value */
+ };
+ 
+ struct azx;
+ 
+ /* Functions to read/write to hda registers. */
+ struct hda_controller_ops {
+ 	/* Register Access */
+ 	void (*reg_writel)(u32 value, u32 __iomem *addr);
+ 	u32 (*reg_readl)(u32 __iomem *addr);
+ 	void (*reg_writew)(u16 value, u16 __iomem *addr);
+ 	u16 (*reg_readw)(u16 __iomem *addr);
+ 	void (*reg_writeb)(u8 value, u8 __iomem *addr);
+ 	u8 (*reg_readb)(u8 __iomem *addr);
+ 	/* Disable msi if supported, PCI only */
+ 	int (*disable_msi_reset_irq)(struct azx *);
+ 	/* Allocation ops */
+ 	int (*dma_alloc_pages)(struct azx *chip,
+ 			       int type,
+ 			       size_t size,
+ 			       struct snd_dma_buffer *buf);
+ 	void (*dma_free_pages)(struct azx *chip, struct snd_dma_buffer *buf);
+ 	int (*substream_alloc_pages)(struct azx *chip,
+ 				     struct snd_pcm_substream *substream,
+ 				     size_t size);
+ 	int (*substream_free_pages)(struct azx *chip,
+ 				    struct snd_pcm_substream *substream);
+ 	void (*pcm_mmap_prepare)(struct snd_pcm_substream *substream,
+ 				 struct vm_area_struct *area);
+ 	/* Check if current position is acceptable */
+ 	int (*position_check)(struct azx *chip, struct azx_dev *azx_dev);
+ };
+ 
+ struct azx_pcm {
+ 	struct azx *chip;
+ 	struct snd_pcm *pcm;
+ 	struct hda_codec *codec;
+ 	struct hda_pcm *info;
+ 	struct list_head list;
+ };
+ 
+ typedef unsigned int (*azx_get_pos_callback_t)(struct azx *, struct azx_dev *);
+ typedef int (*azx_get_delay_callback_t)(struct azx *, struct azx_dev *, unsigned int pos);
+ 
+ struct azx {
+ 	struct snd_card *card;
+ 	struct pci_dev *pci;
+ 	int dev_index;
+ 
+ 	/* chip type specific */
+ 	int driver_type;
+ 	unsigned int driver_caps;
+ 	int playback_streams;
+ 	int playback_index_offset;
+ 	int capture_streams;
+ 	int capture_index_offset;
+ 	int num_streams;
+ 	const int *jackpoll_ms; /* per-card jack poll interval */
+ 
+ 	/* Register interaction. */
+ 	const struct hda_controller_ops *ops;
+ 
+ 	/* position adjustment callbacks */
+ 	azx_get_pos_callback_t get_position[2];
+ 	azx_get_delay_callback_t get_delay[2];
+ 
+ 	/* pci resources */
+ 	unsigned long addr;
+ 	void __iomem *remap_addr;
+ 	int irq;
+ 
+ 	/* locks */
+ 	spinlock_t reg_lock;
+ 	struct mutex open_mutex; /* Prevents concurrent open/close operations */
+ 
+ 	/* streams (x num_streams) */
+ 	struct azx_dev *azx_dev;
+ 
+ 	/* PCM */
+ 	struct list_head pcm_list; /* azx_pcm list */
+ 
+ 	/* HD codec */
+ 	unsigned short codec_mask;
+ 	int  codec_probe_mask; /* copied from probe_mask option */
+ 	struct hda_bus *bus;
+ 	unsigned int beep_mode;
+ 
+ 	/* CORB/RIRB */
+ 	struct azx_rb corb;
+ 	struct azx_rb rirb;
+ 
+ 	/* CORB/RIRB and position buffers */
+ 	struct snd_dma_buffer rb;
+ 	struct snd_dma_buffer posbuf;
+ 
+ #ifdef CONFIG_SND_HDA_PATCH_LOADER
+ 	const struct firmware *fw;
+ #endif
+ 
+ 	/* flags */
+ 	const int *bdl_pos_adj;
+ 	int poll_count;
+ 	unsigned int running:1;
+ 	unsigned int initialized:1;
+ 	unsigned int single_cmd:1;
+ 	unsigned int polling_mode:1;
+ 	unsigned int msi:1;
+ 	unsigned int probing:1; /* codec probing phase */
+ 	unsigned int snoop:1;
+ 	unsigned int align_buffer_size:1;
+ 	unsigned int region_requested:1;
+ 	unsigned int disabled:1; /* disabled by VGA-switcher */
+ 
+ 	/* for debugging */
+ 	unsigned int last_cmd[AZX_MAX_CODECS];
+ 
+ #ifdef CONFIG_SND_HDA_DSP_LOADER
+ 	struct azx_dev saved_azx_dev;
+ #endif
+ };
+ 
+ #ifdef CONFIG_X86
+ #define azx_snoop(chip)		((chip)->snoop)
+ #else
+ #define azx_snoop(chip)		true
+ #endif
+ 
+ /*
+  * macros for easy use
+  */
+ 
+ #define azx_writel(chip, reg, value) \
+ 	((chip)->ops->reg_writel(value, (chip)->remap_addr + AZX_REG_##reg))
+ #define azx_readl(chip, reg) \
+ 	((chip)->ops->reg_readl((chip)->remap_addr + AZX_REG_##reg))
+ #define azx_writew(chip, reg, value) \
+ 	((chip)->ops->reg_writew(value, (chip)->remap_addr + AZX_REG_##reg))
+ #define azx_readw(chip, reg) \
+ 	((chip)->ops->reg_readw((chip)->remap_addr + AZX_REG_##reg))
+ #define azx_writeb(chip, reg, value) \
+ 	((chip)->ops->reg_writeb(value, (chip)->remap_addr + AZX_REG_##reg))
+ #define azx_readb(chip, reg) \
+ 	((chip)->ops->reg_readb((chip)->remap_addr + AZX_REG_##reg))
+ 
+ #define azx_sd_writel(chip, dev, reg, value) \
+ 	((chip)->ops->reg_writel(value, (dev)->sd_addr + AZX_REG_##reg))
+ #define azx_sd_readl(chip, dev, reg) \
+ 	((chip)->ops->reg_readl((dev)->sd_addr + AZX_REG_##reg))
+ #define azx_sd_writew(chip, dev, reg, value) \
+ 	((chip)->ops->reg_writew(value, (dev)->sd_addr + AZX_REG_##reg))
+ #define azx_sd_readw(chip, dev, reg) \
+ 	((chip)->ops->reg_readw((dev)->sd_addr + AZX_REG_##reg))
+ #define azx_sd_writeb(chip, dev, reg, value) \
+ 	((chip)->ops->reg_writeb(value, (dev)->sd_addr + AZX_REG_##reg))
+ #define azx_sd_readb(chip, dev, reg) \
+ 	((chip)->ops->reg_readb((dev)->sd_addr + AZX_REG_##reg))
+ 
+ #define azx_has_pm_runtime(chip) \
+ 	(!AZX_DCAPS_PM_RUNTIME || ((chip)->driver_caps & AZX_DCAPS_PM_RUNTIME))
++>>>>>>> b2a0bafa7582 (ALSA: hda - Use shutdown driver ops instead of reboot notifier)
  
  /* PCM setup */
  static inline struct azx_dev *get_azx_dev(struct snd_pcm_substream *substream)
diff --cc sound/pci/hda/hda_intel.c
index 34eb98e2793b,25668fde8480..000000000000
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@@ -1923,10 -1898,9 +1921,13 @@@ static int azx_probe_continue(struct az
  		goto out_free;
  
  	chip->running = 1;
++<<<<<<< HEAD
 +	power_down_all_codecs(chip);
 +	azx_notifier_register(chip);
++=======
++>>>>>>> b2a0bafa7582 (ALSA: hda - Use shutdown driver ops instead of reboot notifier)
  	azx_add_card_list(chip);
 -	snd_hda_set_power_save(chip->bus, power_save * 1000);
 -	if (azx_has_pm_runtime(chip) || hda->use_vga_switcheroo)
 +	if ((chip->driver_caps & AZX_DCAPS_PM_RUNTIME) || hda->use_vga_switcheroo)
  		pm_runtime_put_noidle(&pci->dev);
  
  out_free:
diff --cc sound/pci/hda/hda_tegra.c
index 6c19abff991c,2e4fd5c56d3b..000000000000
--- a/sound/pci/hda/hda_tegra.c
+++ b/sound/pci/hda/hda_tegra.c
@@@ -514,8 -500,7 +512,12 @@@ static int hda_tegra_probe(struct platf
  		goto out_free;
  
  	chip->running = 1;
++<<<<<<< HEAD
 +	power_down_all_codecs(chip);
 +	azx_notifier_register(chip);
++=======
+ 	snd_hda_set_power_save(chip->bus, power_save * 1000);
++>>>>>>> b2a0bafa7582 (ALSA: hda - Use shutdown driver ops instead of reboot notifier)
  
  	return 0;
  
diff --git a/sound/pci/hda/hda_bind.c b/sound/pci/hda/hda_bind.c
index a49bc45c2ea5..1f40ce3c1696 100644
--- a/sound/pci/hda/hda_bind.c
+++ b/sound/pci/hda/hda_bind.c
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/export.h>
 #include <linux/pm.h>
+#include <linux/pm_runtime.h>
 #include <sound/core.h>
 #include "hda_codec.h"
 #include "hda_local.h"
@@ -142,6 +143,14 @@ static int hda_codec_driver_remove(struct device *dev)
 	return 0;
 }
 
+static void hda_codec_driver_shutdown(struct device *dev)
+{
+	struct hda_codec *codec = dev_to_hda_codec(dev);
+
+	if (!pm_runtime_suspended(dev) && codec->patch_ops.reboot_notify)
+		codec->patch_ops.reboot_notify(codec);
+}
+
 int __hda_codec_driver_register(struct hda_codec_driver *drv, const char *name,
 			       struct module *owner)
 {
@@ -150,6 +159,7 @@ int __hda_codec_driver_register(struct hda_codec_driver *drv, const char *name,
 	drv->driver.bus = &snd_hda_bus_type;
 	drv->driver.probe = hda_codec_driver_probe;
 	drv->driver.remove = hda_codec_driver_remove;
+	drv->driver.shutdown = hda_codec_driver_shutdown;
 	drv->driver.pm = &hda_codec_driver_pm;
 	return driver_register(&drv->driver);
 }
diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c
index b23b865bd99f..1c4c1304f4d0 100644
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@ -4960,24 +4960,6 @@ static void cleanup_dig_out_stream(struct hda_codec *codec, hda_nid_t nid)
 	}
 }
 
-/**
- * snd_hda_bus_reboot_notify - call the reboot notifier of each codec
- * @bus: HD-audio bus
- */
-void snd_hda_bus_reboot_notify(struct hda_bus *bus)
-{
-	struct hda_codec *codec;
-
-	if (!bus)
-		return;
-	list_for_each_entry(codec, &bus->codec_list, list) {
-		if (hda_codec_is_power_on(codec) &&
-		    codec->patch_ops.reboot_notify)
-			codec->patch_ops.reboot_notify(codec);
-	}
-}
-EXPORT_SYMBOL_GPL(snd_hda_bus_reboot_notify);
-
 /**
  * snd_hda_multi_out_dig_open - open the digital out in the exclusive mode
  * @codec: the HDA codec
diff --git a/sound/pci/hda/hda_codec.h b/sound/pci/hda/hda_codec.h
index 4d992f825d2b..cea566ae2893 100644
--- a/sound/pci/hda/hda_codec.h
+++ b/sound/pci/hda/hda_codec.h
@@ -569,7 +569,6 @@ extern const struct snd_pcm_chmap_elem snd_pcm_2_1_chmaps[];
  * Misc
  */
 void snd_hda_get_codec_name(struct hda_codec *codec, char *name, int namelen);
-void snd_hda_bus_reboot_notify(struct hda_bus *bus);
 void snd_hda_codec_set_power_to_all(struct hda_codec *codec, hda_nid_t fg,
 				    unsigned int power_state);
 
diff --git a/sound/pci/hda/hda_controller.c b/sound/pci/hda/hda_controller.c
index 0d7233e1e418..44f48f8d7661 100644
--- a/sound/pci/hda/hda_controller.c
+++ b/sound/pci/hda/hda_controller.c
@@ -27,7 +27,6 @@
 #include <linux/module.h>
 #include <linux/pm_runtime.h>
 #include <linux/slab.h>
-#include <linux/reboot.h>
 #include <sound/core.h>
 #include <sound/initval.h>
 #include "hda_priv.h"
@@ -1984,30 +1983,5 @@ int azx_init_stream(struct azx *chip)
 }
 EXPORT_SYMBOL_GPL(azx_init_stream);
 
-/*
- * reboot notifier for hang-up problem at power-down
- */
-static int azx_halt(struct notifier_block *nb, unsigned long event, void *buf)
-{
-	struct azx *chip = container_of(nb, struct azx, reboot_notifier);
-	snd_hda_bus_reboot_notify(chip->bus);
-	azx_stop_chip(chip);
-	return NOTIFY_OK;
-}
-
-void azx_notifier_register(struct azx *chip)
-{
-	chip->reboot_notifier.notifier_call = azx_halt;
-	register_reboot_notifier(&chip->reboot_notifier);
-}
-EXPORT_SYMBOL_GPL(azx_notifier_register);
-
-void azx_notifier_unregister(struct azx *chip)
-{
-	if (chip->reboot_notifier.notifier_call)
-		unregister_reboot_notifier(&chip->reboot_notifier);
-}
-EXPORT_SYMBOL_GPL(azx_notifier_unregister);
-
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Common HDA driver functions");
* Unmerged path sound/pci/hda/hda_controller.h
* Unmerged path sound/pci/hda/hda_intel.c
* Unmerged path sound/pci/hda/hda_tegra.c
