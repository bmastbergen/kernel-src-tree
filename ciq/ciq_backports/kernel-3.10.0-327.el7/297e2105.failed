KVM: Give IRQFD its own separate enabling Kconfig option

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [kvm] Give IRQFD its own separate enabling Kconfig option (Thomas Huth) [1231879]
Rebuild_FUZZ: 95.33%
commit-author Paul Mackerras <paulus@samba.org>
commit 297e21053a52f060944e9f0de4c64fad9bcd72fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/297e2105.failed

Currently, the IRQFD code is conditional on CONFIG_HAVE_KVM_IRQ_ROUTING.
So that we can have the IRQFD code compiled in without having the
IRQ routing code, this creates a new CONFIG_HAVE_KVM_IRQFD, makes
the IRQFD code conditional on it instead of CONFIG_HAVE_KVM_IRQ_ROUTING,
and makes all the platforms that currently select HAVE_KVM_IRQ_ROUTING
also select HAVE_KVM_IRQFD.

	Signed-off-by: Paul Mackerras <paulus@samba.org>
	Tested-by: Eric Auger <eric.auger@linaro.org>
	Tested-by: Cornelia Huck <cornelia.huck@de.ibm.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 297e21053a52f060944e9f0de4c64fad9bcd72fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kvm/Kconfig
#	include/linux/kvm_host.h
#	virt/kvm/kvm_main.c
diff --cc arch/s390/kvm/Kconfig
index 70b46eacf8e1,646db9c467d1..000000000000
--- a/arch/s390/kvm/Kconfig
+++ b/arch/s390/kvm/Kconfig
@@@ -23,6 -23,11 +23,14 @@@ config KV
  	select ANON_INODES
  	select HAVE_KVM_CPU_RELAX_INTERCEPT
  	select HAVE_KVM_EVENTFD
++<<<<<<< HEAD
++=======
+ 	select KVM_ASYNC_PF
+ 	select KVM_ASYNC_PF_SYNC
+ 	select HAVE_KVM_IRQCHIP
+ 	select HAVE_KVM_IRQFD
+ 	select HAVE_KVM_IRQ_ROUTING
++>>>>>>> 297e21053a52 (KVM: Give IRQFD its own separate enabling Kconfig option)
  	---help---
  	  Support hosting paravirtualized guest machines using the SIE
  	  virtualization capability on the mainframe. This should work
diff --cc include/linux/kvm_host.h
index 9984ea276f63,8593d2e61cbf..000000000000
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@@ -431,14 -437,6 +431,17 @@@ void kvm_vcpu_uninit(struct kvm_vcpu *v
  int __must_check vcpu_load(struct kvm_vcpu *vcpu);
  void vcpu_put(struct kvm_vcpu *vcpu);
  
++<<<<<<< HEAD
 +#ifdef __KVM_HAVE_IOAPIC
 +void kvm_vcpu_request_scan_ioapic(struct kvm *kvm);
 +#else
 +static inline void kvm_vcpu_request_scan_ioapic(struct kvm *kvm)
 +{
 +}
 +#endif
 +
++=======
++>>>>>>> 297e21053a52 (KVM: Give IRQFD its own separate enabling Kconfig option)
  #ifdef CONFIG_HAVE_KVM_IRQFD
  int kvm_irqfd_init(void);
  void kvm_irqfd_exit(void);
diff --cc virt/kvm/kvm_main.c
index 9c5b960f56f6,a69a623938b8..000000000000
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@@ -2397,6 -2324,34 +2397,37 @@@ static int kvm_ioctl_create_device(stru
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static long kvm_vm_ioctl_check_extension_generic(struct kvm *kvm, long arg)
+ {
+ 	switch (arg) {
+ 	case KVM_CAP_USER_MEMORY:
+ 	case KVM_CAP_DESTROY_MEMORY_REGION_WORKS:
+ 	case KVM_CAP_JOIN_MEMORY_REGIONS_WORKS:
+ #ifdef CONFIG_KVM_APIC_ARCHITECTURE
+ 	case KVM_CAP_SET_BOOT_CPU_ID:
+ #endif
+ 	case KVM_CAP_INTERNAL_ERROR_DATA:
+ #ifdef CONFIG_HAVE_KVM_MSI
+ 	case KVM_CAP_SIGNAL_MSI:
+ #endif
+ #ifdef CONFIG_HAVE_KVM_IRQFD
+ 	case KVM_CAP_IRQFD_RESAMPLE:
+ #endif
+ 	case KVM_CAP_CHECK_EXTENSION_VM:
+ 		return 1;
+ #ifdef CONFIG_HAVE_KVM_IRQ_ROUTING
+ 	case KVM_CAP_IRQ_ROUTING:
+ 		return KVM_MAX_IRQ_ROUTES;
+ #endif
+ 	default:
+ 		break;
+ 	}
+ 	return kvm_vm_ioctl_check_extension(kvm, arg);
+ }
+ 
++>>>>>>> 297e21053a52 (KVM: Give IRQFD its own separate enabling Kconfig option)
  static long kvm_vm_ioctl(struct file *filp,
  			   unsigned int ioctl, unsigned long arg)
  {
* Unmerged path arch/s390/kvm/Kconfig
* Unmerged path include/linux/kvm_host.h
* Unmerged path virt/kvm/kvm_main.c
