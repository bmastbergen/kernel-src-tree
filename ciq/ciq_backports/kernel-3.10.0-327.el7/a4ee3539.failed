IB/iser: Re-introduce ib_conn

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [infiniband] iser: Re-introduce ib_conn (Amir Vadai) [1164539]
Rebuild_FUZZ: 94.55%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit a4ee3539f6e2955815b93350bbce01e8915d27f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/a4ee3539.failed

Structure that describes the RDMA relates connection objects.  Static
member of iser_conn.

This patch does not change any functionality

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
	Signed-off-by: Roland Dreier <roland@purestorage.com>
(cherry picked from commit a4ee3539f6e2955815b93350bbce01e8915d27f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.c
#	drivers/infiniband/ulp/iser/iscsi_iser.h
#	drivers/infiniband/ulp/iser/iser_initiator.c
#	drivers/infiniband/ulp/iser/iser_memory.c
#	drivers/infiniband/ulp/iser/iser_verbs.c
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.c
index 93ce62fe1594,db83530184f8..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@@ -147,8 -147,8 +147,13 @@@ static int iscsi_iser_pdu_alloc(struct 
  int iser_initialize_task_headers(struct iscsi_task *task,
  						struct iser_tx_desc *tx_desc)
  {
++<<<<<<< HEAD
 +	struct iser_conn       *ib_conn   = task->conn->dd_data;
 +	struct iser_device     *device    = ib_conn->device;
++=======
+ 	struct iser_conn       *iser_conn   = task->conn->dd_data;
+ 	struct iser_device *device = iser_conn->ib_conn.device;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	struct iscsi_iser_task *iser_task = task->dd_data;
  	u64 dma_addr;
  
@@@ -290,8 -290,8 +295,13 @@@ static void iscsi_iser_cleanup_task(str
  {
  	struct iscsi_iser_task *iser_task = task->dd_data;
  	struct iser_tx_desc    *tx_desc   = &iser_task->desc;
++<<<<<<< HEAD
 +	struct iser_conn       *ib_conn	  = task->conn->dd_data;
 +	struct iser_device     *device	  = ib_conn->device;
++=======
+ 	struct iser_conn       *iser_conn	  = task->conn->dd_data;
+ 	struct iser_device *device = iser_conn->ib_conn.device;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
  	ib_dma_unmap_single(device->ib_device,
  		tx_desc->dma_addr, ISER_HEADERS_LEN, DMA_TO_DEVICE);
@@@ -447,7 -447,8 +457,12 @@@ iscsi_iser_session_create(struct iscsi_
  	struct iscsi_cls_session *cls_session;
  	struct iscsi_session *session;
  	struct Scsi_Host *shost;
++<<<<<<< HEAD
 +	struct iser_conn *ib_conn = NULL;
++=======
+ 	struct iser_conn *iser_conn = NULL;
+ 	struct ib_conn *ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
  	shost = iscsi_host_alloc(&iscsi_iser_sht, 0, 0);
  	if (!shost)
@@@ -464,7 -465,8 +479,12 @@@
  	 * the leading conn's ep so this will be NULL;
  	 */
  	if (ep) {
++<<<<<<< HEAD
 +		ib_conn = ep->dd_data;
++=======
+ 		iser_conn = ep->dd_data;
+ 		ib_conn = &iser_conn->ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  		if (ib_conn->pi_support) {
  			u32 sig_caps = ib_conn->device->dev_attr.sig_prot_cap;
  
@@@ -476,8 -478,8 +496,13 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	if (iscsi_host_add(shost,
 +			   ep ? ib_conn->device->ib_device->dma_device : NULL))
++=======
+ 	if (iscsi_host_add(shost, ep ?
+ 			   ib_conn->device->ib_device->dma_device : NULL))
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  		goto free_host;
  
  	if (cmds_max > ISER_DEF_XMIT_CMDS_MAX) {
@@@ -583,12 -585,12 +608,21 @@@ static int iscsi_iser_get_ep_param(stru
  	switch (param) {
  	case ISCSI_PARAM_CONN_PORT:
  	case ISCSI_PARAM_CONN_ADDRESS:
++<<<<<<< HEAD
 +		if (!ib_conn || !ib_conn->cma_id)
 +			return -ENOTCONN;
 +
 +		return iscsi_conn_get_addr_param((struct sockaddr_storage *)
 +					&ib_conn->cma_id->route.addr.dst_addr,
 +					param, buf);
++=======
+ 		if (!iser_conn || !iser_conn->ib_conn.cma_id)
+ 			return -ENOTCONN;
+ 
+ 		return iscsi_conn_get_addr_param((struct sockaddr_storage *)
+ 				&iser_conn->ib_conn.cma_id->route.addr.dst_addr,
+ 				param, buf);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  		break;
  	default:
  		return -ENOSYS;
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.h
index 9f0e0e34d6ca,4ad73c91e531..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@@ -281,9 -282,9 +282,15 @@@ struct iser_device 
  	int                          cq_active_qps[ISER_MAX_CQ];
  	int			     cqs_used;
  	struct iser_cq_desc	     *cq_desc;
++<<<<<<< HEAD
 +	int                          (*iser_alloc_rdma_reg_res)(struct iser_conn *ib_conn,
 +								unsigned cmds_max);
 +	void                         (*iser_free_rdma_reg_res)(struct iser_conn *ib_conn);
++=======
+ 	int                          (*iser_alloc_rdma_reg_res)(struct ib_conn *ib_conn,
+ 								unsigned cmds_max);
+ 	void                         (*iser_free_rdma_reg_res)(struct ib_conn *ib_conn);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	int                          (*iser_reg_rdma_mem)(struct iscsi_iser_task *iser_task,
  							  enum iser_data_dir cmd_dir);
  	void                         (*iser_unreg_rdma_mem)(struct iscsi_iser_task *iser_task,
@@@ -317,15 -318,54 +324,54 @@@ struct fast_reg_descriptor 
  	u8				  reg_indicators;
  };
  
+ /**
+  * struct ib_conn - Infiniband related objects
+  *
+  * @cma_id:              rdma_cm connection maneger handle
+  * @qp:                  Connection Queue-pair
+  * @post_recv_buf_count: post receive counter
+  * @post_send_buf_count: post send counter
+  * @rx_wr:               receive work request for batch posts
+  * @device:              reference to iser device
+  * @pi_support:          Indicate device T10-PI support
+  * @lock:                protects fmr/fastreg pool
+  * @union.fmr:
+  *     @pool:            FMR pool for fast registrations
+  *     @page_vec:        page vector to hold mapped commands pages
+  *                       used for registration
+  * @union.fastreg:
+  *     @pool:            Fast registration descriptors pool for fast
+  *                       registrations
+  *     @pool_size:       Size of pool
+  */
+ struct ib_conn {
+ 	struct rdma_cm_id           *cma_id;
+ 	struct ib_qp	            *qp;
+ 	int                          post_recv_buf_count;
+ 	atomic_t                     post_send_buf_count;
+ 	struct ib_recv_wr	     rx_wr[ISER_MIN_POSTED_RX];
+ 	struct iser_device          *device;
+ 	int			     cq_index;
+ 	bool			     pi_support;
+ 	spinlock_t		     lock;
+ 	union {
+ 		struct {
+ 			struct ib_fmr_pool      *pool;
+ 			struct iser_page_vec	*page_vec;
+ 		} fmr;
+ 		struct {
+ 			struct list_head	 pool;
+ 			int			 pool_size;
+ 		} fastreg;
+ 	};
+ };
+ 
  struct iser_conn {
+ 	struct ib_conn		     ib_conn;
  	struct iscsi_conn	     *iscsi_conn;
  	struct iscsi_endpoint	     *ep;
 -	enum iser_conn_state	     state;	    /* rdma connection state   */
 +	enum iser_ib_conn_state	     state;	    /* rdma connection state   */
  	atomic_t		     refcount;
- 	spinlock_t		     lock;	    /* used for state changes  */
- 	struct iser_device           *device;       /* device context          */
- 	struct rdma_cm_id            *cma_id;       /* CMA ID		       */
- 	struct ib_qp	             *qp;           /* QP 		       */
  	unsigned		     qp_max_recv_dtos; /* num of rx buffers */
  	unsigned		     qp_max_recv_dtos_mask; /* above minus 1 */
  	unsigned		     min_posted_rx; /* qp_max_recv_dtos >> 2 */
@@@ -429,9 -452,10 +458,16 @@@ void iser_release_work(struct work_stru
  
  void iser_rcv_completion(struct iser_rx_desc *desc,
  			 unsigned long    dto_xfer_len,
++<<<<<<< HEAD
 +			struct iser_conn *ib_conn);
 +
 +void iser_snd_completion(struct iser_tx_desc *desc, struct iser_conn *ib_conn);
++=======
+ 			 struct ib_conn *ib_conn);
+ 
+ void iser_snd_completion(struct iser_tx_desc *desc,
+ 			 struct ib_conn *ib_conn);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
  void iser_task_rdma_init(struct iscsi_iser_task *task);
  
@@@ -454,7 -478,7 +490,11 @@@ int  iser_connect(struct iser_conn   *i
  		  struct sockaddr    *dst_addr,
  		  int                non_blocking);
  
++<<<<<<< HEAD
 +int  iser_reg_page_vec(struct iser_conn     *ib_conn,
++=======
+ int  iser_reg_page_vec(struct ib_conn *ib_conn,
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  		       struct iser_page_vec *page_vec,
  		       struct iser_mem_reg  *mem_reg);
  
@@@ -463,9 -487,9 +503,15 @@@ void iser_unreg_mem_fmr(struct iscsi_is
  void iser_unreg_mem_fastreg(struct iscsi_iser_task *iser_task,
  			    enum iser_data_dir cmd_dir);
  
++<<<<<<< HEAD
 +int  iser_post_recvl(struct iser_conn *ib_conn);
 +int  iser_post_recvm(struct iser_conn *ib_conn, int count);
 +int  iser_post_send(struct iser_conn *ib_conn, struct iser_tx_desc *tx_desc);
++=======
+ int  iser_post_recvl(struct iser_conn *iser_conn);
+ int  iser_post_recvm(struct iser_conn *iser_conn, int count);
+ int  iser_post_send(struct ib_conn *ib_conn, struct iser_tx_desc *tx_desc);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
  int iser_dma_map_task_data(struct iscsi_iser_task *iser_task,
  			    struct iser_data_buf       *data,
@@@ -476,11 -500,12 +522,20 @@@ void iser_dma_unmap_task_data(struct is
  			      struct iser_data_buf *data);
  int  iser_initialize_task_headers(struct iscsi_task *task,
  			struct iser_tx_desc *tx_desc);
++<<<<<<< HEAD
 +int iser_alloc_rx_descriptors(struct iser_conn *ib_conn, struct iscsi_session *session);
 +int iser_create_fmr_pool(struct iser_conn *ib_conn, unsigned cmds_max);
 +void iser_free_fmr_pool(struct iser_conn *ib_conn);
 +int iser_create_fastreg_pool(struct iser_conn *ib_conn, unsigned cmds_max);
 +void iser_free_fastreg_pool(struct iser_conn *ib_conn);
++=======
+ int iser_alloc_rx_descriptors(struct iser_conn *iser_conn,
+ 			      struct iscsi_session *session);
+ int iser_create_fmr_pool(struct ib_conn *ib_conn, unsigned cmds_max);
+ void iser_free_fmr_pool(struct ib_conn *ib_conn);
+ int iser_create_fastreg_pool(struct ib_conn *ib_conn, unsigned cmds_max);
+ void iser_free_fastreg_pool(struct ib_conn *ib_conn);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  u8 iser_check_task_pi_status(struct iscsi_iser_task *iser_task,
  			     enum iser_data_dir cmd_dir, sector_t *sector);
  #endif
diff --cc drivers/infiniband/ulp/iser/iser_initiator.c
index 8d44a4060634,123174570c16..000000000000
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@@ -49,7 -49,7 +49,11 @@@ static int iser_prepare_read_cmd(struc
  
  {
  	struct iscsi_iser_task *iser_task = task->dd_data;
++<<<<<<< HEAD
 +	struct iser_device  *device = iser_task->ib_conn->device;
++=======
+ 	struct iser_device  *device = iser_task->iser_conn->ib_conn.device;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	struct iser_regd_buf *regd_buf;
  	int err;
  	struct iser_hdr *hdr = &iser_task->desc.iser_header;
@@@ -103,7 -103,7 +107,11 @@@ iser_prepare_write_cmd(struct iscsi_tas
  		       unsigned int edtl)
  {
  	struct iscsi_iser_task *iser_task = task->dd_data;
++<<<<<<< HEAD
 +	struct iser_device  *device = iser_task->ib_conn->device;
++=======
+ 	struct iser_device  *device = iser_task->iser_conn->ib_conn.device;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	struct iser_regd_buf *regd_buf;
  	int err;
  	struct iser_hdr *hdr = &iser_task->desc.iser_header;
@@@ -160,10 -160,10 +168,14 @@@
  }
  
  /* creates a new tx descriptor and adds header regd buffer */
 -static void iser_create_send_desc(struct iser_conn	*iser_conn,
 +static void iser_create_send_desc(struct iser_conn	*ib_conn,
  				  struct iser_tx_desc	*tx_desc)
  {
++<<<<<<< HEAD
 +	struct iser_device *device = ib_conn->device;
++=======
+ 	struct iser_device *device = iser_conn->ib_conn.device;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
  	ib_dma_sync_single_for_cpu(device->ib_device,
  		tx_desc->dma_addr, ISER_HEADERS_LEN, DMA_TO_DEVICE);
@@@ -179,59 -179,61 +191,79 @@@
  	}
  }
  
 -static void iser_free_login_buf(struct iser_conn *iser_conn)
 +static void iser_free_login_buf(struct iser_conn *ib_conn)
  {
++<<<<<<< HEAD
 +	if (!ib_conn->login_buf)
 +		return;
 +
 +	if (ib_conn->login_req_dma)
 +		ib_dma_unmap_single(ib_conn->device->ib_device,
 +				    ib_conn->login_req_dma,
 +				    ISCSI_DEF_MAX_RECV_SEG_LEN, DMA_TO_DEVICE);
 +
 +	if (ib_conn->login_resp_dma)
 +		ib_dma_unmap_single(ib_conn->device->ib_device,
 +				    ib_conn->login_resp_dma,
++=======
+ 	struct iser_device *device = iser_conn->ib_conn.device;
+ 
+ 	if (!iser_conn->login_buf)
+ 		return;
+ 
+ 	if (iser_conn->login_req_dma)
+ 		ib_dma_unmap_single(device->ib_device,
+ 				    iser_conn->login_req_dma,
+ 				    ISCSI_DEF_MAX_RECV_SEG_LEN, DMA_TO_DEVICE);
+ 
+ 	if (iser_conn->login_resp_dma)
+ 		ib_dma_unmap_single(device->ib_device,
+ 				    iser_conn->login_resp_dma,
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  				    ISER_RX_LOGIN_SIZE, DMA_FROM_DEVICE);
  
 -	kfree(iser_conn->login_buf);
 +	kfree(ib_conn->login_buf);
  
  	/* make sure we never redo any unmapping */
 -	iser_conn->login_req_dma = 0;
 -	iser_conn->login_resp_dma = 0;
 -	iser_conn->login_buf = NULL;
 +	ib_conn->login_req_dma = 0;
 +	ib_conn->login_resp_dma = 0;
 +	ib_conn->login_buf = NULL;
  }
  
 -static int iser_alloc_login_buf(struct iser_conn *iser_conn)
 +static int iser_alloc_login_buf(struct iser_conn *ib_conn)
  {
- 	struct iser_device	*device;
+ 	struct iser_device *device = iser_conn->ib_conn.device;
  	int			req_err, resp_err;
  
++<<<<<<< HEAD
 +	BUG_ON(ib_conn->device == NULL);
 +
 +	device = ib_conn->device;
++=======
+ 	BUG_ON(device == NULL);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
 -	iser_conn->login_buf = kmalloc(ISCSI_DEF_MAX_RECV_SEG_LEN +
 +	ib_conn->login_buf = kmalloc(ISCSI_DEF_MAX_RECV_SEG_LEN +
  				     ISER_RX_LOGIN_SIZE, GFP_KERNEL);
 -	if (!iser_conn->login_buf)
 +	if (!ib_conn->login_buf)
  		goto out_err;
  
 -	iser_conn->login_req_buf  = iser_conn->login_buf;
 -	iser_conn->login_resp_buf = iser_conn->login_buf +
 +	ib_conn->login_req_buf  = ib_conn->login_buf;
 +	ib_conn->login_resp_buf = ib_conn->login_buf +
  						ISCSI_DEF_MAX_RECV_SEG_LEN;
  
 -	iser_conn->login_req_dma = ib_dma_map_single(device->ib_device,
 -						     iser_conn->login_req_buf,
 -						     ISCSI_DEF_MAX_RECV_SEG_LEN,
 -						     DMA_TO_DEVICE);
 +	ib_conn->login_req_dma = ib_dma_map_single(ib_conn->device->ib_device,
 +				(void *)ib_conn->login_req_buf,
 +				ISCSI_DEF_MAX_RECV_SEG_LEN, DMA_TO_DEVICE);
  
 -	iser_conn->login_resp_dma = ib_dma_map_single(device->ib_device,
 -						      iser_conn->login_resp_buf,
 -						      ISER_RX_LOGIN_SIZE,
 -						      DMA_FROM_DEVICE);
 +	ib_conn->login_resp_dma = ib_dma_map_single(ib_conn->device->ib_device,
 +				(void *)ib_conn->login_resp_buf,
 +				ISER_RX_LOGIN_SIZE, DMA_FROM_DEVICE);
  
  	req_err  = ib_dma_mapping_error(device->ib_device,
 -					iser_conn->login_req_dma);
 +					ib_conn->login_req_dma);
  	resp_err = ib_dma_mapping_error(device->ib_device,
 -					iser_conn->login_resp_dma);
 +					ib_conn->login_resp_dma);
  
  	if (req_err || resp_err) {
  		if (req_err)
@@@ -256,11 -259,12 +288,16 @@@ int iser_alloc_rx_descriptors(struct is
  	u64 dma_addr;
  	struct iser_rx_desc *rx_desc;
  	struct ib_sge       *rx_sg;
++<<<<<<< HEAD
 +	struct iser_device  *device = ib_conn->device;
++=======
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
+ 	struct iser_device *device = ib_conn->device;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
 -	iser_conn->qp_max_recv_dtos = session->cmds_max;
 -	iser_conn->qp_max_recv_dtos_mask = session->cmds_max - 1; /* cmds_max is 2^N */
 -	iser_conn->min_posted_rx = iser_conn->qp_max_recv_dtos >> 2;
 +	ib_conn->qp_max_recv_dtos = session->cmds_max;
 +	ib_conn->qp_max_recv_dtos_mask = session->cmds_max - 1; /* cmds_max is 2^N */
 +	ib_conn->min_posted_rx = ib_conn->qp_max_recv_dtos >> 2;
  
  	if (device->iser_alloc_rdma_reg_res(ib_conn, session->scsi_cmds_max))
  		goto create_rdma_reg_res_failed;
@@@ -312,9 -316,10 +349,13 @@@ void iser_free_rx_descriptors(struct is
  {
  	int i;
  	struct iser_rx_desc *rx_desc;
++<<<<<<< HEAD
++=======
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	struct iser_device *device = ib_conn->device;
  
 -	if (!iser_conn->rx_descs)
 +	if (!ib_conn->rx_descs)
  		goto free_login_buf;
  
  	if (device->iser_free_rdma_reg_res)
@@@ -334,7 -339,8 +375,12 @@@ free_login_buf
  
  static int iser_post_rx_bufs(struct iscsi_conn *conn, struct iscsi_hdr *req)
  {
++<<<<<<< HEAD
 +	struct iser_conn *ib_conn = conn->dd_data;
++=======
+ 	struct iser_conn *iser_conn = conn->dd_data;
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	struct iscsi_session *session = conn->session;
  
  	iser_dbg("req op %x flags %x\n", req->opcode, req->flags);
@@@ -423,7 -429,7 +469,11 @@@ int iser_send_command(struct iscsi_con
  
  	iser_task->status = ISER_TASK_STATUS_STARTED;
  
++<<<<<<< HEAD
 +	err = iser_post_send(ib_conn, tx_desc);
++=======
+ 	err = iser_post_send(&iser_conn->ib_conn, tx_desc);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	if (!err)
  		return 0;
  
@@@ -488,7 -494,7 +538,11 @@@ int iser_send_data_out(struct iscsi_con
  		 itt, buf_offset, data_seg_len);
  
  
++<<<<<<< HEAD
 +	err = iser_post_send(ib_conn, tx_desc);
++=======
+ 	err = iser_post_send(&iser_conn->ib_conn, tx_desc);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	if (!err)
  		return 0;
  
@@@ -510,9 -516,9 +564,13 @@@ int iser_send_control(struct iscsi_con
  
  	/* build the tx desc regd header and add it to the tx desc dto */
  	mdesc->type = ISCSI_TX_CONTROL;
 -	iser_create_send_desc(iser_conn, mdesc);
 +	iser_create_send_desc(ib_conn, mdesc);
  
++<<<<<<< HEAD
 +	device = ib_conn->device;
++=======
+ 	device = iser_conn->ib_conn.device;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
  	data_seg_len = ntoh24(task->hdr->dlength);
  
@@@ -550,7 -556,7 +608,11 @@@
  			goto send_control_error;
  	}
  
++<<<<<<< HEAD
 +	err = iser_post_send(ib_conn, mdesc);
++=======
+ 	err = iser_post_send(&iser_conn->ib_conn, mdesc);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	if (!err)
  		return 0;
  
@@@ -564,8 -570,10 +626,14 @@@ send_control_error
   */
  void iser_rcv_completion(struct iser_rx_desc *rx_desc,
  			 unsigned long rx_xfer_len,
++<<<<<<< HEAD
 +			 struct iser_conn *ib_conn)
++=======
+ 			 struct ib_conn *ib_conn)
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  {
+ 	struct iser_conn *iser_conn = container_of(ib_conn, struct iser_conn,
+ 						   ib_conn);
  	struct iscsi_hdr *hdr;
  	u64 rx_dma;
  	int rx_buflen, outstanding, count, err;
@@@ -580,7 -588,7 +648,11 @@@
  	}
  
  	ib_dma_sync_single_for_cpu(ib_conn->device->ib_device, rx_dma,
++<<<<<<< HEAD
 +			rx_buflen, DMA_FROM_DEVICE);
++=======
+ 				   rx_buflen, DMA_FROM_DEVICE);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
  	hdr = &rx_desc->iscsi_header;
  
@@@ -603,17 -611,17 +675,28 @@@
  		return;
  
  	outstanding = ib_conn->post_recv_buf_count;
++<<<<<<< HEAD
 +	if (outstanding + ib_conn->min_posted_rx <= ib_conn->qp_max_recv_dtos) {
 +		count = min(ib_conn->qp_max_recv_dtos - outstanding,
 +						ib_conn->min_posted_rx);
 +		err = iser_post_recvm(ib_conn, count);
++=======
+ 	if (outstanding + iser_conn->min_posted_rx <= iser_conn->qp_max_recv_dtos) {
+ 		count = min(iser_conn->qp_max_recv_dtos - outstanding,
+ 			    iser_conn->min_posted_rx);
+ 		err = iser_post_recvm(iser_conn, count);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  		if (err)
  			iser_err("posting %d rx bufs err %d\n", count, err);
  	}
  }
  
  void iser_snd_completion(struct iser_tx_desc *tx_desc,
++<<<<<<< HEAD
 +			struct iser_conn *ib_conn)
++=======
+ 			struct ib_conn *ib_conn)
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  {
  	struct iscsi_task *task;
  	struct iser_device *device = ib_conn->device;
@@@ -658,7 -666,7 +741,11 @@@ void iser_task_rdma_init(struct iscsi_i
  
  void iser_task_rdma_finalize(struct iscsi_iser_task *iser_task)
  {
++<<<<<<< HEAD
 +	struct iser_device *device = iser_task->ib_conn->device;
++=======
+ 	struct iser_device *device = iser_task->iser_conn->ib_conn.device;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	int is_rdma_data_aligned = 1;
  	int is_rdma_prot_aligned = 1;
  	int prot_count = scsi_prot_sg_count(iser_task->sc);
diff --cc drivers/infiniband/ulp/iser/iser_memory.c
index 47acd3ad3a17,de4db762dc77..000000000000
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@@ -49,7 -49,7 +49,11 @@@ static int iser_start_rdma_unaligned_sg
  					struct iser_data_buf *data_copy,
  					enum iser_data_dir cmd_dir)
  {
++<<<<<<< HEAD
 +	struct ib_device *dev = iser_task->ib_conn->device->ib_device;
++=======
+ 	struct ib_device *dev = iser_task->iser_conn->ib_conn.device->ib_device;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	struct scatterlist *sgl = (struct scatterlist *)data->buf;
  	struct scatterlist *sg;
  	char *mem = NULL;
@@@ -116,7 -116,7 +120,11 @@@ void iser_finalize_rdma_unaligned_sg(st
  	struct ib_device *dev;
  	unsigned long  cmd_data_len;
  
++<<<<<<< HEAD
 +	dev = iser_task->ib_conn->device->ib_device;
++=======
+ 	dev = iser_task->iser_conn->ib_conn.device->ib_device;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
  	ib_dma_unmap_sg(dev, &data_copy->sg_single, 1,
  			(cmd_dir == ISER_DIR_OUT) ?
@@@ -322,7 -322,7 +330,11 @@@ int iser_dma_map_task_data(struct iscsi
  	struct ib_device *dev;
  
  	iser_task->dir[iser_dir] = 1;
++<<<<<<< HEAD
 +	dev = iser_task->ib_conn->device->ib_device;
++=======
+ 	dev = iser_task->iser_conn->ib_conn.device->ib_device;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
  	data->dma_nents = ib_dma_map_sg(dev, data->buf, data->size, dma_dir);
  	if (data->dma_nents == 0) {
@@@ -337,7 -337,7 +349,11 @@@ void iser_dma_unmap_task_data(struct is
  {
  	struct ib_device *dev;
  
++<<<<<<< HEAD
 +	dev = iser_task->ib_conn->device->ib_device;
++=======
+ 	dev = iser_task->iser_conn->ib_conn.device->ib_device;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	ib_dma_unmap_sg(dev, data->buf, data->size, DMA_FROM_DEVICE);
  }
  
@@@ -377,7 -377,7 +393,11 @@@ static int fall_to_bounce_buf(struct is
  int iser_reg_rdma_mem_fmr(struct iscsi_iser_task *iser_task,
  			  enum iser_data_dir cmd_dir)
  {
++<<<<<<< HEAD
 +	struct iser_conn     *ib_conn = iser_task->ib_conn;
++=======
+ 	struct ib_conn *ib_conn = &iser_task->iser_conn->ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	struct iser_device   *device = ib_conn->device;
  	struct ib_device     *ibdev = device->ib_device;
  	struct iser_data_buf *mem = &iser_task->data[cmd_dir];
@@@ -432,7 -432,7 +452,11 @@@
  				 ib_conn->fmr.page_vec->offset);
  			for (i = 0; i < ib_conn->fmr.page_vec->length; i++)
  				iser_err("page_vec[%d] = 0x%llx\n", i,
++<<<<<<< HEAD
 +					 (unsigned long long) ib_conn->fmr.page_vec->pages[i]);
++=======
+ 					 (unsigned long long)ib_conn->fmr.page_vec->pages[i]);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  		}
  		if (err)
  			return err;
@@@ -533,7 -533,7 +557,11 @@@ iser_reg_sig_mr(struct iscsi_iser_task 
  		struct fast_reg_descriptor *desc, struct ib_sge *data_sge,
  		struct ib_sge *prot_sge, struct ib_sge *sig_sge)
  {
++<<<<<<< HEAD
 +	struct iser_conn *ib_conn = iser_task->ib_conn;
++=======
+ 	struct ib_conn *ib_conn = &iser_task->iser_conn->ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	struct iser_pi_context *pi_ctx = desc->pi_ctx;
  	struct ib_send_wr sig_wr, inv_wr;
  	struct ib_send_wr *bad_wr, *wr = NULL;
@@@ -609,7 -609,7 +637,11 @@@ static int iser_fast_reg_mr(struct iscs
  			    struct ib_sge *sge)
  {
  	struct fast_reg_descriptor *desc = regd_buf->reg.mem_h;
++<<<<<<< HEAD
 +	struct iser_conn *ib_conn = iser_task->ib_conn;
++=======
+ 	struct ib_conn *ib_conn = &iser_task->iser_conn->ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	struct iser_device *device = ib_conn->device;
  	struct ib_device *ibdev = device->ib_device;
  	struct ib_mr *mr;
@@@ -700,7 -700,7 +732,11 @@@
  int iser_reg_rdma_mem_fastreg(struct iscsi_iser_task *iser_task,
  			      enum iser_data_dir cmd_dir)
  {
++<<<<<<< HEAD
 +	struct iser_conn *ib_conn = iser_task->ib_conn;
++=======
+ 	struct ib_conn *ib_conn = &iser_task->iser_conn->ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	struct iser_device *device = ib_conn->device;
  	struct ib_device *ibdev = device->ib_device;
  	struct iser_data_buf *mem = &iser_task->data[cmd_dir];
diff --cc drivers/infiniband/ulp/iser/iser_verbs.c
index fbf2a1e0f2e2,e69aba8eabec..000000000000
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@@ -215,7 -213,7 +215,11 @@@ static void iser_free_device_ib_res(str
   *
   * returns 0 on success, or errno code on failure
   */
++<<<<<<< HEAD
 +int iser_create_fmr_pool(struct iser_conn *ib_conn, unsigned cmds_max)
++=======
+ int iser_create_fmr_pool(struct ib_conn *ib_conn, unsigned cmds_max)
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  {
  	struct iser_device *device = ib_conn->device;
  	struct ib_fmr_pool_param params;
@@@ -265,7 -263,7 +269,11 @@@
  /**
   * iser_free_fmr_pool - releases the FMR pool and page vec
   */
++<<<<<<< HEAD
 +void iser_free_fmr_pool(struct iser_conn *ib_conn)
++=======
+ void iser_free_fmr_pool(struct ib_conn *ib_conn)
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  {
  	iser_info("freeing conn %p fmr pool %p\n",
  		  ib_conn, ib_conn->fmr.pool);
@@@ -369,10 -367,10 +377,17 @@@ fast_reg_mr_failure
   * for fast registration work requests.
   * returns 0 on success, or errno code on failure
   */
++<<<<<<< HEAD
 +int iser_create_fastreg_pool(struct iser_conn *ib_conn, unsigned cmds_max)
 +{
 +	struct iser_device	*device = ib_conn->device;
 +	struct fast_reg_descriptor	*desc;
++=======
+ int iser_create_fastreg_pool(struct ib_conn *ib_conn, unsigned cmds_max)
+ {
+ 	struct iser_device *device = ib_conn->device;
+ 	struct fast_reg_descriptor *desc;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	int i, ret;
  
  	INIT_LIST_HEAD(&ib_conn->fastreg.pool);
@@@ -408,7 -406,7 +423,11 @@@ err
  /**
   * iser_free_fastreg_pool - releases the pool of fast_reg descriptors
   */
++<<<<<<< HEAD
 +void iser_free_fastreg_pool(struct iser_conn *ib_conn)
++=======
+ void iser_free_fastreg_pool(struct ib_conn *ib_conn)
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  {
  	struct fast_reg_descriptor *desc, *tmp;
  	int i = 0;
@@@ -442,10 -440,9 +461,14 @@@
   *
   * returns 0 on success, -1 on failure
   */
++<<<<<<< HEAD
 +static int iser_create_ib_conn_res(struct iser_conn *ib_conn)
++=======
+ static int iser_create_ib_conn_res(struct ib_conn *ib_conn)
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  {
  	struct iser_device	*device;
 +	struct ib_device_attr	*dev_attr;
  	struct ib_qp_init_attr	init_attr;
  	int			ret = -ENOMEM;
  	int index, min_index = 0;
@@@ -453,7 -450,6 +476,10 @@@
  	BUG_ON(ib_conn->device == NULL);
  
  	device = ib_conn->device;
++<<<<<<< HEAD
 +	dev_attr = &device->dev_attr;
++=======
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
  	memset(&init_attr, 0, sizeof init_attr);
  
@@@ -477,12 -474,10 +504,16 @@@
  	init_attr.sq_sig_type	= IB_SIGNAL_REQ_WR;
  	init_attr.qp_type	= IB_QPT_RC;
  	if (ib_conn->pi_support) {
++<<<<<<< HEAD
 +		init_attr.cap.max_send_wr = min(ISER_QP_SIG_MAX_REQ_DTOS,
 +							dev_attr->max_qp_wr);
++=======
+ 		init_attr.cap.max_send_wr = ISER_QP_SIG_MAX_REQ_DTOS;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  		init_attr.create_flags |= IB_QP_CREATE_SIGNATURE_EN;
  	} else {
 -		init_attr.cap.max_send_wr  = ISER_QP_MAX_REQ_DTOS;
 +		init_attr.cap.max_send_wr  = min(ISER_QP_MAX_REQ_DTOS,
 +							dev_attr->max_qp_wr);
  	}
  
  	ret = rdma_create_qp(ib_conn->cma_id, device->pd, &init_attr);
@@@ -503,10 -498,9 +534,14 @@@ out_err
  /**
   * releases the QP object
   */
 -static void iser_free_ib_conn_res(struct iser_conn *iser_conn)
 +static void iser_free_ib_conn_res(struct iser_conn *ib_conn)
  {
++<<<<<<< HEAD
 +	int cq_index;
 +	BUG_ON(ib_conn == NULL);
++=======
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
  	iser_info("freeing conn %p cma_id %p qp %p\n",
  		  ib_conn, ib_conn->cma_id,
@@@ -515,9 -509,7 +550,13 @@@
  	/* qp is created only once both addr & route are resolved */
  
  	if (ib_conn->qp != NULL) {
++<<<<<<< HEAD
 +		cq_index = ((struct iser_cq_desc *)ib_conn->qp->recv_cq->cq_context)->cq_index;
 +		ib_conn->device->cq_active_qps[cq_index]--;
 +
++=======
+ 		ib_conn->device->cq_active_qps[ib_conn->cq_index]--;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  		rdma_destroy_qp(ib_conn->cma_id);
  	}
  
@@@ -616,38 -610,40 +655,56 @@@ void iser_release_work(struct work_stru
  /**
   * Frees all conn objects and deallocs conn descriptor
   */
 -void iser_conn_release(struct iser_conn *iser_conn)
 +void iser_conn_release(struct iser_conn *ib_conn)
  {
++<<<<<<< HEAD
++=======
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	struct iser_device  *device = ib_conn->device;
  
  	mutex_lock(&ig.connlist_mutex);
 -	list_del(&iser_conn->conn_list);
 +	list_del(&ib_conn->conn_list);
  	mutex_unlock(&ig.connlist_mutex);
  
 -	mutex_lock(&iser_conn->state_mutex);
 -	BUG_ON(iser_conn->state != ISER_CONN_DOWN);
 +	mutex_lock(&ib_conn->state_mutex);
 +	BUG_ON(ib_conn->state != ISER_CONN_DOWN);
  
++<<<<<<< HEAD
 +	iser_free_rx_descriptors(ib_conn);
 +	iser_free_ib_conn_res(ib_conn);
++=======
+ 	iser_free_rx_descriptors(iser_conn);
+ 	iser_free_ib_conn_res(iser_conn);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	ib_conn->device = NULL;
  	/* on EVENT_ADDR_ERROR there's no device yet for this conn */
  	if (device != NULL)
  		iser_device_try_release(device);
 -	mutex_unlock(&iser_conn->state_mutex);
 +	mutex_unlock(&ib_conn->state_mutex);
  
++<<<<<<< HEAD
 +	/* if cma handler context, the caller actually destroy the id */
++=======
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	if (ib_conn->cma_id != NULL) {
  		rdma_destroy_id(ib_conn->cma_id);
  		ib_conn->cma_id = NULL;
  	}
++<<<<<<< HEAD
 +	kfree(ib_conn);
++=======
+ 
+ 	kfree(iser_conn);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  }
  
  /**
   * triggers start of the disconnect procedures and wait for them to be done
   */
 -void iser_conn_terminate(struct iser_conn *iser_conn)
 +void iser_conn_terminate(struct iser_conn *ib_conn)
  {
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
  	int err = 0;
  
  	/* change the ib conn state only if the conn is UP, however always call
@@@ -655,7 -651,7 +712,11 @@@
  	 * the QP state to ERROR
  	 */
  
++<<<<<<< HEAD
 +	iser_conn_state_comp_exch(ib_conn, ISER_CONN_UP, ISER_CONN_TERMINATING);
++=======
+ 	iser_conn_state_comp_exch(iser_conn, ISER_CONN_UP, ISER_CONN_TERMINATING);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	err = rdma_disconnect(ib_conn->cma_id);
  	if (err)
  		iser_err("Failed to disconnect, conn: 0x%p err %d\n",
@@@ -679,11 -675,12 +740,16 @@@ static void iser_connect_error(struct r
  static void iser_addr_handler(struct rdma_cm_id *cma_id)
  {
  	struct iser_device *device;
++<<<<<<< HEAD
 +	struct iser_conn   *ib_conn;
++=======
+ 	struct iser_conn   *iser_conn;
+ 	struct ib_conn   *ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	int    ret;
  
 -	iser_conn = (struct iser_conn *)cma_id->context;
 -	if (iser_conn->state != ISER_CONN_PENDING)
 +	ib_conn = (struct iser_conn *)cma_id->context;
 +	if (ib_conn->state != ISER_CONN_PENDING)
  		/* bailout */
  		return;
  
@@@ -725,10 -723,11 +792,15 @@@ static void iser_route_handler(struct r
  	struct rdma_conn_param conn_param;
  	int    ret;
  	struct iser_cm_hdr req_hdr;
++<<<<<<< HEAD
 +	struct iser_conn *ib_conn = (struct iser_conn *)cma_id->context;
++=======
+ 	struct iser_conn *iser_conn = (struct iser_conn *)cma_id->context;
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	struct iser_device *device = ib_conn->device;
  
 -	if (iser_conn->state != ISER_CONN_PENDING)
 +	if (ib_conn->state != ISER_CONN_PENDING)
  		/* bailout */
  		return;
  
@@@ -779,9 -778,10 +851,14 @@@ static void iser_connected_handler(stru
  
  static void iser_disconnected_handler(struct rdma_cm_id *cma_id)
  {
++<<<<<<< HEAD
 +	struct iser_conn *ib_conn;
++=======
+ 	struct iser_conn *iser_conn;
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
 -	iser_conn = (struct iser_conn *)cma_id->context;
 +	ib_conn = (struct iser_conn *)cma_id->context;
  
  	/* getting here when the state is UP means that the conn is being *
  	 * terminated asynchronously from the iSCSI layer's perspective.  */
@@@ -799,7 -799,7 +876,11 @@@
  	 */
  	if (ib_conn->post_recv_buf_count == 0 &&
  	    (atomic_read(&ib_conn->post_send_buf_count) == 0)) {
++<<<<<<< HEAD
 +		complete(&ib_conn->flush_completion);
++=======
+ 		complete(&iser_conn->flush_completion);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	}
  }
  
@@@ -843,17 -843,17 +924,29 @@@ static int iser_cma_handler(struct rdma
  	return 0;
  }
  
 -void iser_conn_init(struct iser_conn *iser_conn)
 +void iser_conn_init(struct iser_conn *ib_conn)
  {
++<<<<<<< HEAD
 +	ib_conn->state = ISER_CONN_INIT;
 +	ib_conn->post_recv_buf_count = 0;
 +	atomic_set(&ib_conn->post_send_buf_count, 0);
 +	init_completion(&ib_conn->stop_completion);
 +	init_completion(&ib_conn->flush_completion);
 +	init_completion(&ib_conn->up_completion);
 +	INIT_LIST_HEAD(&ib_conn->conn_list);
 +	spin_lock_init(&ib_conn->lock);
 +	mutex_init(&ib_conn->state_mutex);
++=======
+ 	iser_conn->state = ISER_CONN_INIT;
+ 	iser_conn->ib_conn.post_recv_buf_count = 0;
+ 	atomic_set(&iser_conn->ib_conn.post_send_buf_count, 0);
+ 	init_completion(&iser_conn->stop_completion);
+ 	init_completion(&iser_conn->flush_completion);
+ 	init_completion(&iser_conn->up_completion);
+ 	INIT_LIST_HEAD(&iser_conn->conn_list);
+ 	spin_lock_init(&iser_conn->ib_conn.lock);
+ 	mutex_init(&iser_conn->state_mutex);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  }
  
   /**
@@@ -865,22 -865,23 +958,28 @@@ int iser_connect(struct iser_conn   *ib
  		 struct sockaddr    *dst_addr,
  		 int                 non_blocking)
  {
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
  	int err = 0;
  
 -	mutex_lock(&iser_conn->state_mutex);
 +	mutex_lock(&ib_conn->state_mutex);
  
 -	sprintf(iser_conn->name, "%pISp", dst_addr);
 +	sprintf(ib_conn->name, "%pISp", dst_addr);
  
 -	iser_info("connecting to: %s\n", iser_conn->name);
 +	iser_info("connecting to: %s\n", ib_conn->name);
  
  	/* the device is known only --after-- address resolution */
  	ib_conn->device = NULL;
  
 -	iser_conn->state = ISER_CONN_PENDING;
 +	ib_conn->state = ISER_CONN_PENDING;
  
  	ib_conn->cma_id = rdma_create_id(iser_cma_handler,
++<<<<<<< HEAD
 +					     (void *)ib_conn,
 +					     RDMA_PS_TCP, IB_QPT_RC);
++=======
+ 					 (void *)iser_conn,
+ 					 RDMA_PS_TCP, IB_QPT_RC);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	if (IS_ERR(ib_conn->cma_id)) {
  		err = PTR_ERR(ib_conn->cma_id);
  		iser_err("rdma_create_id failed: %d\n", err);
@@@ -923,7 -924,7 +1022,11 @@@ connect_failure
   *
   * returns: 0 on success, errno code on failure
   */
++<<<<<<< HEAD
 +int iser_reg_page_vec(struct iser_conn     *ib_conn,
++=======
+ int iser_reg_page_vec(struct ib_conn *ib_conn,
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  		      struct iser_page_vec *page_vec,
  		      struct iser_mem_reg  *mem_reg)
  {
@@@ -993,7 -994,8 +1096,12 @@@ void iser_unreg_mem_fastreg(struct iscs
  			    enum iser_data_dir cmd_dir)
  {
  	struct iser_mem_reg *reg = &iser_task->rdma_regd[cmd_dir].reg;
++<<<<<<< HEAD
 +	struct iser_conn *ib_conn = iser_task->ib_conn;
++=======
+ 	struct iser_conn *iser_conn = iser_task->iser_conn;
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	struct fast_reg_descriptor *desc = reg->mem_h;
  
  	if (!reg->is_mr)
@@@ -1006,9 -1008,10 +1114,10 @@@
  	spin_unlock_bh(&ib_conn->lock);
  }
  
 -int iser_post_recvl(struct iser_conn *iser_conn)
 +int iser_post_recvl(struct iser_conn *ib_conn)
  {
  	struct ib_recv_wr rx_wr, *rx_wr_failed;
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
  	struct ib_sge	  sge;
  	int ib_ret;
  
@@@ -1034,11 -1037,12 +1143,20 @@@ int iser_post_recvm(struct iser_conn *i
  {
  	struct ib_recv_wr *rx_wr, *rx_wr_failed;
  	int i, ib_ret;
++<<<<<<< HEAD
 +	unsigned int my_rx_head = ib_conn->rx_desc_head;
 +	struct iser_rx_desc *rx_desc;
 +
 +	for (rx_wr = ib_conn->rx_wr, i = 0; i < count; i++, rx_wr++) {
 +		rx_desc		= &ib_conn->rx_descs[my_rx_head];
++=======
+ 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
+ 	unsigned int my_rx_head = iser_conn->rx_desc_head;
+ 	struct iser_rx_desc *rx_desc;
+ 
+ 	for (rx_wr = ib_conn->rx_wr, i = 0; i < count; i++, rx_wr++) {
+ 		rx_desc		= &iser_conn->rx_descs[my_rx_head];
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  		rx_wr->wr_id	= (unsigned long)rx_desc;
  		rx_wr->sg_list	= &rx_desc->rx_sg;
  		rx_wr->num_sge	= 1;
@@@ -1065,13 -1069,14 +1183,22 @@@
   *
   * returns 0 on success, -1 on failure
   */
++<<<<<<< HEAD
 +int iser_post_send(struct iser_conn *ib_conn, struct iser_tx_desc *tx_desc)
++=======
+ int iser_post_send(struct ib_conn *ib_conn, struct iser_tx_desc *tx_desc)
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  {
  	int		  ib_ret;
  	struct ib_send_wr send_wr, *send_wr_failed;
  
  	ib_dma_sync_single_for_device(ib_conn->device->ib_device,
++<<<<<<< HEAD
 +		tx_desc->dma_addr, ISER_HEADERS_LEN, DMA_TO_DEVICE);
++=======
+ 				      tx_desc->dma_addr, ISER_HEADERS_LEN,
+ 				      DMA_TO_DEVICE);
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  
  	send_wr.next	   = NULL;
  	send_wr.wr_id	   = (unsigned long)tx_desc;
@@@ -1091,8 -1096,11 +1218,15 @@@
  }
  
  static void iser_handle_comp_error(struct iser_tx_desc *desc,
++<<<<<<< HEAD
 +				struct iser_conn *ib_conn)
++=======
+ 				   struct ib_conn *ib_conn)
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  {
+ 	struct iser_conn *iser_conn = container_of(ib_conn, struct iser_conn,
+ 						   ib_conn);
+ 
  	if (desc && desc->type == ISCSI_TX_DATAOUT)
  		kmem_cache_free(ig.desc_cache, desc);
  
@@@ -1119,7 -1127,7 +1253,11 @@@ static int iser_drain_tx_cq(struct iser
  	struct ib_cq  *cq = device->tx_cq[cq_index];
  	struct ib_wc  wc;
  	struct iser_tx_desc *tx_desc;
++<<<<<<< HEAD
 +	struct iser_conn *ib_conn;
++=======
+ 	struct ib_conn *ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	int completed_tx = 0;
  
  	while (ib_poll_cq(cq, 1, &wc) == 1) {
@@@ -1154,7 -1162,7 +1292,11 @@@ static void iser_cq_tasklet_fn(unsigne
  	 struct ib_wc	     wc;
  	 struct iser_rx_desc *desc;
  	 unsigned long	     xfer_len;
++<<<<<<< HEAD
 +	struct iser_conn *ib_conn;
++=======
+ 	struct ib_conn *ib_conn;
++>>>>>>> a4ee3539f6e2 (IB/iser: Re-introduce ib_conn)
  	int completed_tx, completed_rx = 0;
  
  	/* First do tx drain, so in a case where we have rx flushes and a successful
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.c
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.h
* Unmerged path drivers/infiniband/ulp/iser/iser_initiator.c
* Unmerged path drivers/infiniband/ulp/iser/iser_memory.c
* Unmerged path drivers/infiniband/ulp/iser/iser_verbs.c
