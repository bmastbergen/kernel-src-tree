drm/radeon: Handle irqs only based on irq ring, not irq status regs.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-327.el7
Rebuild_CHGLOG: - [drm] radeon: Handle irqs only based on irq ring, not irq status regs (Rob Clark) [1249805]
Rebuild_FUZZ: 96.18%
commit-author Mario Kleiner <mario.kleiner.de@gmail.com>
commit 07f18f0bb8d8d65badd8b4988b40d329fc0cc6dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-327.el7/07f18f0b.failed

Trying to resolve issues with missed vblanks and impossible
values inside delivered kms pageflip completion events showed
that radeon's irq handling sometimes doesn't handle valid irqs,
but silently skips them. This was observed for vblank interrupts.

Although those irqs have corresponding events queued in the gpu's
irq ring at time of interrupt, and therefore the corresponding
handling code gets triggered by these events, the handling code
sometimes silently skipped processing the irq. The reason for those
skips is that the handling code double-checks for each irq event if
the corresponding irq status bits in the irq status registers
are set. Sometimes those bits are not set at time of check
for valid irqs, maybe due to some hardware race on some setups?

The problem only seems to happen on some machine + card combos
sometimes, e.g., never happened during my testing of different PC
cards of the DCE-2/3/4 generation a year ago, but happens consistently
now on two different Apple Mac cards (RV730, DCE-3, Apple iMac and
Evergreen JUNIPER, DCE-4 in a Apple MacPro). It also doesn't happen
at each interrupt but only occassionally every couple of
hundred or thousand vblank interrupts.

This results in XOrg warning messages like

"[  7084.472] (WW) RADEON(0): radeon_dri2_flip_event_handler:
Pageflip completion event has impossible msc 420120 < target_msc 420121"

as well as skipped frames and problems for applications that
use kms pageflip events or vblank events, e.g., users of DRI2 and
DRI3/Present, Waylands Weston compositor, etc. See also

https://bugs.freedesktop.org/show_bug.cgi?id=85203

After some talking to Alex and Michel, we decided to fix this
by turning the double-check for asserted irq status bits into a
warning. Whenever a irq event is queued in the IH ring, always
execute the corresponding interrupt handler. Still check the irq
status bits, but only to log a DRM_DEBUG message on a mismatch.

This fixed the problems reliably on both previously failing
cards, RV-730 dual-head tested on both crtcs (pipes D1 and D2)
and a triple-output Juniper HD-5770 card tested on all three
available crtcs (D1/D2/D3). The r600 and evergreen irq handling
is therefore tested, but the cik an si handling is only compile
tested due to lack of hw.

	Reviewed-by: Christian König <christian.koenig@amd.com>
	Signed-off-by: Mario Kleiner <mario.kleiner.de@gmail.com>
CC: Michel Dänzer <michel.daenzer@amd.com>
CC: Alex Deucher <alexander.deucher@amd.com>
CC: <stable@vger.kernel.org> # v3.16+
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 07f18f0bb8d8d65badd8b4988b40d329fc0cc6dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/radeon/cik.c
#	drivers/gpu/drm/radeon/evergreen.c
#	drivers/gpu/drm/radeon/si.c
diff --cc drivers/gpu/drm/radeon/cik.c
index c81095c445db,248953d2fdb7..000000000000
--- a/drivers/gpu/drm/radeon/cik.c
+++ b/drivers/gpu/drm/radeon/cik.c
@@@ -7658,47 -8154,113 +7682,116 @@@ restart_ih
  		case 42: /* HPD hotplug */
  			switch (src_data) {
  			case 0:
- 				if (rdev->irq.stat_regs.cik.disp_int & DC_HPD1_INTERRUPT) {
- 					rdev->irq.stat_regs.cik.disp_int &= ~DC_HPD1_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD1\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.cik.disp_int & DC_HPD1_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.cik.disp_int &= ~DC_HPD1_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD1\n");
+ 
  				break;
  			case 1:
- 				if (rdev->irq.stat_regs.cik.disp_int_cont & DC_HPD2_INTERRUPT) {
- 					rdev->irq.stat_regs.cik.disp_int_cont &= ~DC_HPD2_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD2\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.cik.disp_int_cont & DC_HPD2_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.cik.disp_int_cont &= ~DC_HPD2_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD2\n");
+ 
  				break;
  			case 2:
- 				if (rdev->irq.stat_regs.cik.disp_int_cont2 & DC_HPD3_INTERRUPT) {
- 					rdev->irq.stat_regs.cik.disp_int_cont2 &= ~DC_HPD3_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD3\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.cik.disp_int_cont2 & DC_HPD3_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.cik.disp_int_cont2 &= ~DC_HPD3_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD3\n");
+ 
  				break;
  			case 3:
- 				if (rdev->irq.stat_regs.cik.disp_int_cont3 & DC_HPD4_INTERRUPT) {
- 					rdev->irq.stat_regs.cik.disp_int_cont3 &= ~DC_HPD4_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD4\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.cik.disp_int_cont3 & DC_HPD4_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.cik.disp_int_cont3 &= ~DC_HPD4_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD4\n");
+ 
  				break;
  			case 4:
- 				if (rdev->irq.stat_regs.cik.disp_int_cont4 & DC_HPD5_INTERRUPT) {
- 					rdev->irq.stat_regs.cik.disp_int_cont4 &= ~DC_HPD5_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD5\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.cik.disp_int_cont4 & DC_HPD5_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.cik.disp_int_cont4 &= ~DC_HPD5_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD5\n");
+ 
  				break;
  			case 5:
- 				if (rdev->irq.stat_regs.cik.disp_int_cont5 & DC_HPD6_INTERRUPT) {
- 					rdev->irq.stat_regs.cik.disp_int_cont5 &= ~DC_HPD6_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD6\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.cik.disp_int_cont5 & DC_HPD6_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.cik.disp_int_cont5 &= ~DC_HPD6_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD6\n");
+ 
+ 				break;
++<<<<<<< HEAD
++=======
+ 			case 6:
+ 				if (!(rdev->irq.stat_regs.cik.disp_int & DC_HPD1_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.cik.disp_int &= ~DC_HPD1_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 1\n");
+ 
+ 				break;
+ 			case 7:
+ 				if (!(rdev->irq.stat_regs.cik.disp_int_cont & DC_HPD2_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.cik.disp_int_cont &= ~DC_HPD2_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 2\n");
+ 
+ 				break;
+ 			case 8:
+ 				if (!(rdev->irq.stat_regs.cik.disp_int_cont2 & DC_HPD3_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.cik.disp_int_cont2 &= ~DC_HPD3_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 3\n");
+ 
+ 				break;
+ 			case 9:
+ 				if (!(rdev->irq.stat_regs.cik.disp_int_cont3 & DC_HPD4_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.cik.disp_int_cont3 &= ~DC_HPD4_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 4\n");
+ 
+ 				break;
+ 			case 10:
+ 				if (!(rdev->irq.stat_regs.cik.disp_int_cont4 & DC_HPD5_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.cik.disp_int_cont4 &= ~DC_HPD5_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 5\n");
+ 
+ 				break;
+ 			case 11:
+ 				if (!(rdev->irq.stat_regs.cik.disp_int_cont5 & DC_HPD6_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.cik.disp_int_cont5 &= ~DC_HPD6_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 6\n");
+ 
  				break;
++>>>>>>> 07f18f0bb8d8 (drm/radeon: Handle irqs only based on irq ring, not irq status regs.)
  			default:
  				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
  				break;
diff --cc drivers/gpu/drm/radeon/evergreen.c
index ddeb3bd79e79,0acde1949c18..000000000000
--- a/drivers/gpu/drm/radeon/evergreen.c
+++ b/drivers/gpu/drm/radeon/evergreen.c
@@@ -4967,47 -5132,101 +4991,104 @@@ restart_ih
  		case 42: /* HPD hotplug */
  			switch (src_data) {
  			case 0:
- 				if (rdev->irq.stat_regs.evergreen.disp_int & DC_HPD1_INTERRUPT) {
- 					rdev->irq.stat_regs.evergreen.disp_int &= ~DC_HPD1_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD1\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int & DC_HPD1_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int &= ~DC_HPD1_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD1\n");
  				break;
  			case 1:
- 				if (rdev->irq.stat_regs.evergreen.disp_int_cont & DC_HPD2_INTERRUPT) {
- 					rdev->irq.stat_regs.evergreen.disp_int_cont &= ~DC_HPD2_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD2\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont & DC_HPD2_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont &= ~DC_HPD2_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD2\n");
  				break;
  			case 2:
- 				if (rdev->irq.stat_regs.evergreen.disp_int_cont2 & DC_HPD3_INTERRUPT) {
- 					rdev->irq.stat_regs.evergreen.disp_int_cont2 &= ~DC_HPD3_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD3\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont2 & DC_HPD3_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont2 &= ~DC_HPD3_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD3\n");
  				break;
  			case 3:
- 				if (rdev->irq.stat_regs.evergreen.disp_int_cont3 & DC_HPD4_INTERRUPT) {
- 					rdev->irq.stat_regs.evergreen.disp_int_cont3 &= ~DC_HPD4_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD4\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont3 & DC_HPD4_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont3 &= ~DC_HPD4_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD4\n");
  				break;
  			case 4:
- 				if (rdev->irq.stat_regs.evergreen.disp_int_cont4 & DC_HPD5_INTERRUPT) {
- 					rdev->irq.stat_regs.evergreen.disp_int_cont4 &= ~DC_HPD5_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD5\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont4 & DC_HPD5_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont4 &= ~DC_HPD5_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD5\n");
  				break;
  			case 5:
- 				if (rdev->irq.stat_regs.evergreen.disp_int_cont5 & DC_HPD6_INTERRUPT) {
- 					rdev->irq.stat_regs.evergreen.disp_int_cont5 &= ~DC_HPD6_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD6\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont5 & DC_HPD6_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont5 &= ~DC_HPD6_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD6\n");
  				break;
++<<<<<<< HEAD
++=======
+ 			case 6:
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int & DC_HPD1_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int &= ~DC_HPD1_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 1\n");
+ 				break;
+ 			case 7:
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont & DC_HPD2_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont &= ~DC_HPD2_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 2\n");
+ 				break;
+ 			case 8:
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont2 & DC_HPD3_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont2 &= ~DC_HPD3_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 3\n");
+ 				break;
+ 			case 9:
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont3 & DC_HPD4_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont3 &= ~DC_HPD4_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 4\n");
+ 				break;
+ 			case 10:
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont4 & DC_HPD5_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont4 &= ~DC_HPD5_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 5\n");
+ 				break;
+ 			case 11:
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont5 & DC_HPD6_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont5 &= ~DC_HPD6_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 6\n");
+ 				break;
++>>>>>>> 07f18f0bb8d8 (drm/radeon: Handle irqs only based on irq ring, not irq status regs.)
  			default:
  				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
  				break;
diff --cc drivers/gpu/drm/radeon/si.c
index 6c17d3b0be8b,07037e32dea3..000000000000
--- a/drivers/gpu/drm/radeon/si.c
+++ b/drivers/gpu/drm/radeon/si.c
@@@ -6322,47 -6656,113 +6346,116 @@@ restart_ih
  		case 42: /* HPD hotplug */
  			switch (src_data) {
  			case 0:
- 				if (rdev->irq.stat_regs.evergreen.disp_int & DC_HPD1_INTERRUPT) {
- 					rdev->irq.stat_regs.evergreen.disp_int &= ~DC_HPD1_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD1\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int & DC_HPD1_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int &= ~DC_HPD1_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD1\n");
+ 
  				break;
  			case 1:
- 				if (rdev->irq.stat_regs.evergreen.disp_int_cont & DC_HPD2_INTERRUPT) {
- 					rdev->irq.stat_regs.evergreen.disp_int_cont &= ~DC_HPD2_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD2\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont & DC_HPD2_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont &= ~DC_HPD2_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD2\n");
+ 
  				break;
  			case 2:
- 				if (rdev->irq.stat_regs.evergreen.disp_int_cont2 & DC_HPD3_INTERRUPT) {
- 					rdev->irq.stat_regs.evergreen.disp_int_cont2 &= ~DC_HPD3_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD3\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont2 & DC_HPD3_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont2 &= ~DC_HPD3_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD3\n");
+ 
  				break;
  			case 3:
- 				if (rdev->irq.stat_regs.evergreen.disp_int_cont3 & DC_HPD4_INTERRUPT) {
- 					rdev->irq.stat_regs.evergreen.disp_int_cont3 &= ~DC_HPD4_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD4\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont3 & DC_HPD4_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont3 &= ~DC_HPD4_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD4\n");
+ 
  				break;
  			case 4:
- 				if (rdev->irq.stat_regs.evergreen.disp_int_cont4 & DC_HPD5_INTERRUPT) {
- 					rdev->irq.stat_regs.evergreen.disp_int_cont4 &= ~DC_HPD5_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD5\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont4 & DC_HPD5_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont4 &= ~DC_HPD5_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD5\n");
+ 
  				break;
  			case 5:
- 				if (rdev->irq.stat_regs.evergreen.disp_int_cont5 & DC_HPD6_INTERRUPT) {
- 					rdev->irq.stat_regs.evergreen.disp_int_cont5 &= ~DC_HPD6_INTERRUPT;
- 					queue_hotplug = true;
- 					DRM_DEBUG("IH: HPD6\n");
- 				}
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont5 & DC_HPD6_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont5 &= ~DC_HPD6_INTERRUPT;
+ 				queue_hotplug = true;
+ 				DRM_DEBUG("IH: HPD6\n");
+ 
+ 				break;
++<<<<<<< HEAD
++=======
+ 			case 6:
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int & DC_HPD1_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int &= ~DC_HPD1_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 1\n");
+ 
+ 				break;
+ 			case 7:
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont & DC_HPD2_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont &= ~DC_HPD2_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 2\n");
+ 
+ 				break;
+ 			case 8:
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont2 & DC_HPD3_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont2 &= ~DC_HPD3_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 3\n");
+ 
+ 				break;
+ 			case 9:
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont3 & DC_HPD4_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont3 &= ~DC_HPD4_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 4\n");
+ 
+ 				break;
+ 			case 10:
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont4 & DC_HPD5_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont4 &= ~DC_HPD5_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 5\n");
+ 
+ 				break;
+ 			case 11:
+ 				if (!(rdev->irq.stat_regs.evergreen.disp_int_cont5 & DC_HPD6_RX_INTERRUPT))
+ 					DRM_DEBUG("IH: IH event w/o asserted irq bit?\n");
+ 
+ 				rdev->irq.stat_regs.evergreen.disp_int_cont5 &= ~DC_HPD6_RX_INTERRUPT;
+ 				queue_dp = true;
+ 				DRM_DEBUG("IH: HPD_RX 6\n");
+ 
  				break;
++>>>>>>> 07f18f0bb8d8 (drm/radeon: Handle irqs only based on irq ring, not irq status regs.)
  			default:
  				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
  				break;
* Unmerged path drivers/gpu/drm/radeon/cik.c
* Unmerged path drivers/gpu/drm/radeon/evergreen.c
diff --git a/drivers/gpu/drm/radeon/r600.c b/drivers/gpu/drm/radeon/r600.c
index 44b046b4056f..bafe016d8185 100644
--- a/drivers/gpu/drm/radeon/r600.c
+++ b/drivers/gpu/drm/radeon/r600.c
@@ -3863,23 +3863,27 @@ restart_ih:
 		case 1: /* D1 vblank/vline */
 			switch (src_data) {
 			case 0: /* D1 vblank */
-				if (rdev->irq.stat_regs.r600.disp_int & LB_D1_VBLANK_INTERRUPT) {
-					if (rdev->irq.crtc_vblank_int[0]) {
-						drm_handle_vblank(rdev->ddev, 0);
-						rdev->pm.vblank_sync = true;
-						wake_up(&rdev->irq.vblank_queue);
-					}
-					if (atomic_read(&rdev->irq.pflip[0]))
-						radeon_crtc_handle_vblank(rdev, 0);
-					rdev->irq.stat_regs.r600.disp_int &= ~LB_D1_VBLANK_INTERRUPT;
-					DRM_DEBUG("IH: D1 vblank\n");
+				if (!(rdev->irq.stat_regs.r600.disp_int & LB_D1_VBLANK_INTERRUPT))
+					DRM_DEBUG("IH: D1 vblank - IH event w/o asserted irq bit?\n");
+
+				if (rdev->irq.crtc_vblank_int[0]) {
+					drm_handle_vblank(rdev->ddev, 0);
+					rdev->pm.vblank_sync = true;
+					wake_up(&rdev->irq.vblank_queue);
 				}
+				if (atomic_read(&rdev->irq.pflip[0]))
+					radeon_crtc_handle_vblank(rdev, 0);
+				rdev->irq.stat_regs.r600.disp_int &= ~LB_D1_VBLANK_INTERRUPT;
+				DRM_DEBUG("IH: D1 vblank\n");
+
 				break;
 			case 1: /* D1 vline */
-				if (rdev->irq.stat_regs.r600.disp_int & LB_D1_VLINE_INTERRUPT) {
-					rdev->irq.stat_regs.r600.disp_int &= ~LB_D1_VLINE_INTERRUPT;
-					DRM_DEBUG("IH: D1 vline\n");
-				}
+				if (!(rdev->irq.stat_regs.r600.disp_int & LB_D1_VLINE_INTERRUPT))
+				    DRM_DEBUG("IH: D1 vline - IH event w/o asserted irq bit?\n");
+
+				rdev->irq.stat_regs.r600.disp_int &= ~LB_D1_VLINE_INTERRUPT;
+				DRM_DEBUG("IH: D1 vline\n");
+
 				break;
 			default:
 				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
@@ -3889,23 +3893,27 @@ restart_ih:
 		case 5: /* D2 vblank/vline */
 			switch (src_data) {
 			case 0: /* D2 vblank */
-				if (rdev->irq.stat_regs.r600.disp_int & LB_D2_VBLANK_INTERRUPT) {
-					if (rdev->irq.crtc_vblank_int[1]) {
-						drm_handle_vblank(rdev->ddev, 1);
-						rdev->pm.vblank_sync = true;
-						wake_up(&rdev->irq.vblank_queue);
-					}
-					if (atomic_read(&rdev->irq.pflip[1]))
-						radeon_crtc_handle_vblank(rdev, 1);
-					rdev->irq.stat_regs.r600.disp_int &= ~LB_D2_VBLANK_INTERRUPT;
-					DRM_DEBUG("IH: D2 vblank\n");
+				if (!(rdev->irq.stat_regs.r600.disp_int & LB_D2_VBLANK_INTERRUPT))
+					DRM_DEBUG("IH: D2 vblank - IH event w/o asserted irq bit?\n");
+
+				if (rdev->irq.crtc_vblank_int[1]) {
+					drm_handle_vblank(rdev->ddev, 1);
+					rdev->pm.vblank_sync = true;
+					wake_up(&rdev->irq.vblank_queue);
 				}
+				if (atomic_read(&rdev->irq.pflip[1]))
+					radeon_crtc_handle_vblank(rdev, 1);
+				rdev->irq.stat_regs.r600.disp_int &= ~LB_D2_VBLANK_INTERRUPT;
+				DRM_DEBUG("IH: D2 vblank\n");
+
 				break;
 			case 1: /* D1 vline */
-				if (rdev->irq.stat_regs.r600.disp_int & LB_D2_VLINE_INTERRUPT) {
-					rdev->irq.stat_regs.r600.disp_int &= ~LB_D2_VLINE_INTERRUPT;
-					DRM_DEBUG("IH: D2 vline\n");
-				}
+				if (!(rdev->irq.stat_regs.r600.disp_int & LB_D2_VLINE_INTERRUPT))
+					DRM_DEBUG("IH: D2 vline - IH event w/o asserted irq bit?\n");
+
+				rdev->irq.stat_regs.r600.disp_int &= ~LB_D2_VLINE_INTERRUPT;
+				DRM_DEBUG("IH: D2 vline\n");
+
 				break;
 			default:
 				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
@@ -3923,46 +3931,53 @@ restart_ih:
 		case 19: /* HPD/DAC hotplug */
 			switch (src_data) {
 			case 0:
-				if (rdev->irq.stat_regs.r600.disp_int & DC_HPD1_INTERRUPT) {
-					rdev->irq.stat_regs.r600.disp_int &= ~DC_HPD1_INTERRUPT;
-					queue_hotplug = true;
-					DRM_DEBUG("IH: HPD1\n");
-				}
+				if (!(rdev->irq.stat_regs.r600.disp_int & DC_HPD1_INTERRUPT))
+					DRM_DEBUG("IH: HPD1 - IH event w/o asserted irq bit?\n");
+
+				rdev->irq.stat_regs.r600.disp_int &= ~DC_HPD1_INTERRUPT;
+				queue_hotplug = true;
+				DRM_DEBUG("IH: HPD1\n");
 				break;
 			case 1:
-				if (rdev->irq.stat_regs.r600.disp_int & DC_HPD2_INTERRUPT) {
-					rdev->irq.stat_regs.r600.disp_int &= ~DC_HPD2_INTERRUPT;
-					queue_hotplug = true;
-					DRM_DEBUG("IH: HPD2\n");
-				}
+				if (!(rdev->irq.stat_regs.r600.disp_int & DC_HPD2_INTERRUPT))
+					DRM_DEBUG("IH: HPD2 - IH event w/o asserted irq bit?\n");
+
+				rdev->irq.stat_regs.r600.disp_int &= ~DC_HPD2_INTERRUPT;
+				queue_hotplug = true;
+				DRM_DEBUG("IH: HPD2\n");
 				break;
 			case 4:
-				if (rdev->irq.stat_regs.r600.disp_int_cont & DC_HPD3_INTERRUPT) {
-					rdev->irq.stat_regs.r600.disp_int_cont &= ~DC_HPD3_INTERRUPT;
-					queue_hotplug = true;
-					DRM_DEBUG("IH: HPD3\n");
-				}
+				if (!(rdev->irq.stat_regs.r600.disp_int_cont & DC_HPD3_INTERRUPT))
+					DRM_DEBUG("IH: HPD3 - IH event w/o asserted irq bit?\n");
+
+				rdev->irq.stat_regs.r600.disp_int_cont &= ~DC_HPD3_INTERRUPT;
+				queue_hotplug = true;
+				DRM_DEBUG("IH: HPD3\n");
 				break;
 			case 5:
-				if (rdev->irq.stat_regs.r600.disp_int_cont & DC_HPD4_INTERRUPT) {
-					rdev->irq.stat_regs.r600.disp_int_cont &= ~DC_HPD4_INTERRUPT;
-					queue_hotplug = true;
-					DRM_DEBUG("IH: HPD4\n");
-				}
+				if (!(rdev->irq.stat_regs.r600.disp_int_cont & DC_HPD4_INTERRUPT))
+					DRM_DEBUG("IH: HPD4 - IH event w/o asserted irq bit?\n");
+
+				rdev->irq.stat_regs.r600.disp_int_cont &= ~DC_HPD4_INTERRUPT;
+				queue_hotplug = true;
+				DRM_DEBUG("IH: HPD4\n");
 				break;
 			case 10:
-				if (rdev->irq.stat_regs.r600.disp_int_cont2 & DC_HPD5_INTERRUPT) {
-					rdev->irq.stat_regs.r600.disp_int_cont2 &= ~DC_HPD5_INTERRUPT;
-					queue_hotplug = true;
-					DRM_DEBUG("IH: HPD5\n");
-				}
+				if (!(rdev->irq.stat_regs.r600.disp_int_cont2 & DC_HPD5_INTERRUPT))
+					DRM_DEBUG("IH: HPD5 - IH event w/o asserted irq bit?\n");
+
+				rdev->irq.stat_regs.r600.disp_int_cont2 &= ~DC_HPD5_INTERRUPT;
+				queue_hotplug = true;
+				DRM_DEBUG("IH: HPD5\n");
 				break;
 			case 12:
-				if (rdev->irq.stat_regs.r600.disp_int_cont2 & DC_HPD6_INTERRUPT) {
-					rdev->irq.stat_regs.r600.disp_int_cont2 &= ~DC_HPD6_INTERRUPT;
-					queue_hotplug = true;
-					DRM_DEBUG("IH: HPD6\n");
-				}
+				if (!(rdev->irq.stat_regs.r600.disp_int_cont2 & DC_HPD6_INTERRUPT))
+					DRM_DEBUG("IH: HPD6 - IH event w/o asserted irq bit?\n");
+
+				rdev->irq.stat_regs.r600.disp_int_cont2 &= ~DC_HPD6_INTERRUPT;
+				queue_hotplug = true;
+				DRM_DEBUG("IH: HPD6\n");
+
 				break;
 			default:
 				DRM_DEBUG("Unhandled interrupt: %d %d\n", src_id, src_data);
@@ -3972,18 +3987,22 @@ restart_ih:
 		case 21: /* hdmi */
 			switch (src_data) {
 			case 4:
-				if (rdev->irq.stat_regs.r600.hdmi0_status & HDMI0_AZ_FORMAT_WTRIG) {
-					rdev->irq.stat_regs.r600.hdmi0_status &= ~HDMI0_AZ_FORMAT_WTRIG;
-					queue_hdmi = true;
-					DRM_DEBUG("IH: HDMI0\n");
-				}
+				if (!(rdev->irq.stat_regs.r600.hdmi0_status & HDMI0_AZ_FORMAT_WTRIG))
+					DRM_DEBUG("IH: HDMI0 - IH event w/o asserted irq bit?\n");
+
+				rdev->irq.stat_regs.r600.hdmi0_status &= ~HDMI0_AZ_FORMAT_WTRIG;
+				queue_hdmi = true;
+				DRM_DEBUG("IH: HDMI0\n");
+
 				break;
 			case 5:
-				if (rdev->irq.stat_regs.r600.hdmi1_status & HDMI0_AZ_FORMAT_WTRIG) {
-					rdev->irq.stat_regs.r600.hdmi1_status &= ~HDMI0_AZ_FORMAT_WTRIG;
-					queue_hdmi = true;
-					DRM_DEBUG("IH: HDMI1\n");
-				}
+				if (!(rdev->irq.stat_regs.r600.hdmi1_status & HDMI0_AZ_FORMAT_WTRIG))
+					DRM_DEBUG("IH: HDMI1 - IH event w/o asserted irq bit?\n");
+
+				rdev->irq.stat_regs.r600.hdmi1_status &= ~HDMI0_AZ_FORMAT_WTRIG;
+				queue_hdmi = true;
+				DRM_DEBUG("IH: HDMI1\n");
+
 				break;
 			default:
 				DRM_ERROR("Unhandled interrupt: %d %d\n", src_id, src_data);
* Unmerged path drivers/gpu/drm/radeon/si.c
