proc/pagemap: walk page tables under pte lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.95.1.el7
commit-author Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
commit 05fbf357d94152171bc50f8a369390f1f16efd89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.95.1.el7/05fbf357.failed

Lockless access to pte in pagemap_pte_range() might race with page
migration and trigger BUG_ON(!PageLocked()) in migration_entry_to_page():

CPU A (pagemap)                           CPU B (migration)
                                          lock_page()
                                          try_to_unmap(page, TTU_MIGRATION...)
                                               make_migration_entry()
                                               set_pte_at()
<read *pte>
pte_to_pagemap_entry()
                                          remove_migration_ptes()
                                          unlock_page()
    if(is_migration_entry())
        migration_entry_to_page()
            BUG_ON(!PageLocked(page))

Also lockless read might be non-atomic if pte is larger than wordsize.
Other pte walkers (smaps, numa_maps, clear_refs) already lock ptes.

Fixes: 052fb0d635df ("proc: report file/anon bit in /proc/pid/pagemap")
	Signed-off-by: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>
	Reported-by: Andrey Ryabinin <a.ryabinin@samsung.com>
	Reviewed-by: Cyrill Gorcunov <gorcunov@openvz.org>
	Acked-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Cc: <stable@vger.kernel.org>	[3.5+]
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 05fbf357d94152171bc50f8a369390f1f16efd89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/proc/task_mmu.c
diff --cc fs/proc/task_mmu.c
index e27a1d4280af,eeab30fcffcc..000000000000
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@@ -1198,15 -1117,19 +1198,25 @@@ static int pagemap_pmd_range(pmd_t *pmd
  		BUG_ON(is_vm_hugetlb_page(vma));
  
  		/* Addresses in the VMA. */
- 		for (; addr < min(end, vma->vm_end); addr += PAGE_SIZE) {
+ 		orig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);
+ 		for (; addr < min(end, vma->vm_end); pte++, addr += PAGE_SIZE) {
  			pagemap_entry_t pme;
++<<<<<<< HEAD
 +			pte = pte_offset_map(pmdp, addr);
 +			pme = pte_to_pagemap_entry(pm, vma, addr, *pte);
 +			pte_unmap(pte);
++=======
+ 
+ 			pte_to_pagemap_entry(&pme, pm, vma, addr, *pte);
++>>>>>>> 05fbf357d941 (proc/pagemap: walk page tables under pte lock)
  			err = add_to_pagemap(addr, &pme, pm);
  			if (err)
- 				return err;
+ 				break;
  		}
+ 		pte_unmap_unlock(orig_pte, ptl);
+ 
+ 		if (err)
+ 			return err;
  
  		if (addr == end)
  			break;
* Unmerged path fs/proc/task_mmu.c
