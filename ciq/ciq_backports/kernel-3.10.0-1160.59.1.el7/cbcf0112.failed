af_unix: fix garbage collect vs MSG_PEEK

jira LE-1907
cve CVE-2021-0920
Rebuild_History Non-Buildable kernel-3.10.0-1160.59.1.el7
commit-author Miklos Szeredi <mszeredi@redhat.com>
commit cbcf01128d0a92e131bd09f1688fe032480b65ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.59.1.el7/cbcf0112.failed

unix_gc() assumes that candidate sockets can never gain an external
reference (i.e.  be installed into an fd) while the unix_gc_lock is
held.  Except for MSG_PEEK this is guaranteed by modifying inflight
count under the unix_gc_lock.

MSG_PEEK does not touch any variable protected by unix_gc_lock (file
count is not), yet it needs to be serialized with garbage collection.
Do this by locking/unlocking unix_gc_lock:

 1) increment file count

 2) lock/unlock barrier to make sure incremented file count is visible
    to garbage collection

 3) install file into fd

This is a lock barrier (unlike smp_mb()) that ensures that garbage
collection is run completely before or completely after the barrier.

	Cc: <stable@vger.kernel.org>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit cbcf01128d0a92e131bd09f1688fe032480b65ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/unix/af_unix.c
diff --cc net/unix/af_unix.c
index f68c8590693d,ba7ced947e51..000000000000
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@@ -1468,81 -1526,51 +1468,129 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
 +static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
 +{
 +	int i;
 +
 +	scm->fp = UNIXCB(skb).fp;
 +	UNIXCB(skb).fp = NULL;
 +
 +	for (i = scm->fp->count-1; i >= 0; i--)
 +		unix_notinflight(scm->fp->user, scm->fp->fp[i]);
 +}
 +
 +static void unix_destruct_scm(struct sk_buff *skb)
 +{
 +	struct scm_cookie scm;
 +	memset(&scm, 0, sizeof(scm));
 +	scm.pid  = UNIXCB(skb).pid;
 +	if (UNIXCB(skb).fp)
 +		unix_detach_fds(&scm, skb);
 +
 +	/* Alas, it calls VFS */
 +	/* So fscking what? fput() had been SMP-safe since the last Summer */
 +	scm_destroy(&scm);
 +	sock_wfree(skb);
 +}
 +
 +/*
 + * The "user->unix_inflight" variable is protected by the garbage
 + * collection lock, and we just read it locklessly here. If you go
 + * over the limit, there might be a tiny race in actually noticing
 + * it across threads. Tough.
 + */
 +static inline bool too_many_unix_fds(struct task_struct *p)
 +{
 +	struct user_struct *user = current_user();
 +
 +	if (unlikely(user->unix_inflight > task_rlimit(p, RLIMIT_NOFILE)))
 +		return !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN);
 +	return false;
 +}
 +
 +#define MAX_RECURSION_LEVEL 4
 +
 +static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)
 +{
 +	int i;
 +	unsigned char max_level = 0;
 +	int unix_sock_count = 0;
 +
 +	if (too_many_unix_fds(current))
 +		return -ETOOMANYREFS;
 +
 +	for (i = scm->fp->count - 1; i >= 0; i--) {
 +		struct sock *sk = unix_get_socket(scm->fp->fp[i]);
 +
 +		if (sk) {
 +			unix_sock_count++;
 +			max_level = max(max_level,
 +					unix_sk(sk)->recursion_level);
 +		}
 +	}
 +	if (unlikely(max_level > MAX_RECURSION_LEVEL))
 +		return -ETOOMANYREFS;
 +
 +	/*
 +	 * Need to duplicate file references for the sake of garbage
 +	 * collection.  Otherwise a socket in the fps might become a
 +	 * candidate for GC while the skb is not yet queued.
 +	 */
 +	UNIXCB(skb).fp = scm_fp_dup(scm->fp);
 +	if (!UNIXCB(skb).fp)
 +		return -ENOMEM;
 +
 +	for (i = scm->fp->count - 1; i >= 0; i--)
 +		unix_inflight(scm->fp->user, scm->fp->fp[i]);
 +	return max_level;
++=======
+ static void unix_peek_fds(struct scm_cookie *scm, struct sk_buff *skb)
+ {
+ 	scm->fp = scm_fp_dup(UNIXCB(skb).fp);
+ 
+ 	/*
+ 	 * Garbage collection of unix sockets starts by selecting a set of
+ 	 * candidate sockets which have reference only from being in flight
+ 	 * (total_refs == inflight_refs).  This condition is checked once during
+ 	 * the candidate collection phase, and candidates are marked as such, so
+ 	 * that non-candidates can later be ignored.  While inflight_refs is
+ 	 * protected by unix_gc_lock, total_refs (file count) is not, hence this
+ 	 * is an instantaneous decision.
+ 	 *
+ 	 * Once a candidate, however, the socket must not be reinstalled into a
+ 	 * file descriptor while the garbage collection is in progress.
+ 	 *
+ 	 * If the above conditions are met, then the directed graph of
+ 	 * candidates (*) does not change while unix_gc_lock is held.
+ 	 *
+ 	 * Any operations that changes the file count through file descriptors
+ 	 * (dup, close, sendmsg) does not change the graph since candidates are
+ 	 * not installed in fds.
+ 	 *
+ 	 * Dequeing a candidate via recvmsg would install it into an fd, but
+ 	 * that takes unix_gc_lock to decrement the inflight count, so it's
+ 	 * serialized with garbage collection.
+ 	 *
+ 	 * MSG_PEEK is special in that it does not change the inflight count,
+ 	 * yet does install the socket into an fd.  The following lock/unlock
+ 	 * pair is to ensure serialization with garbage collection.  It must be
+ 	 * done between incrementing the file count and installing the file into
+ 	 * an fd.
+ 	 *
+ 	 * If garbage collection starts after the barrier provided by the
+ 	 * lock/unlock, then it will see the elevated refcount and not mark this
+ 	 * as a candidate.  If a garbage collection is already in progress
+ 	 * before the file count was incremented, then the lock/unlock pair will
+ 	 * ensure that garbage collection is finished before progressing to
+ 	 * installing the fd.
+ 	 *
+ 	 * (*) A -> B where B is on the queue of A or B is on the queue of C
+ 	 * which is on the queue of listening socket A.
+ 	 */
+ 	spin_lock(&unix_gc_lock);
+ 	spin_unlock(&unix_gc_lock);
++>>>>>>> cbcf01128d0a (af_unix: fix garbage collect vs MSG_PEEK)
  }
  
  static int unix_scm_to_skb(struct scm_cookie *scm, struct sk_buff *skb, bool send_fds)
@@@ -2182,7 -2222,7 +2230,11 @@@ static int unix_dgram_recvmsg(struct ki
  		sk_peek_offset_fwd(sk, size);
  
  		if (UNIXCB(skb).fp)
++<<<<<<< HEAD
 +			siocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);
++=======
+ 			unix_peek_fds(&scm, skb);
++>>>>>>> cbcf01128d0a (af_unix: fix garbage collect vs MSG_PEEK)
  	}
  	err = (flags & MSG_TRUNC) ? skb->len - skip : size;
  
@@@ -2433,7 -2465,7 +2485,11 @@@ unlock
  			/* It is questionable, see note in unix_dgram_recvmsg.
  			 */
  			if (UNIXCB(skb).fp)
++<<<<<<< HEAD
 +				siocb->scm->fp = scm_fp_dup(UNIXCB(skb).fp);
++=======
+ 				unix_peek_fds(&scm, skb);
++>>>>>>> cbcf01128d0a (af_unix: fix garbage collect vs MSG_PEEK)
  
  			sk_peek_offset_fwd(sk, chunk);
  
* Unmerged path net/unix/af_unix.c
