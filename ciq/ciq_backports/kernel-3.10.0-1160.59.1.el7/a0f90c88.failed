drm/vmwgfx: Fix stale file descriptors on failed usercopy

jira LE-1907
cve CVE-2022-22942
Rebuild_History Non-Buildable kernel-3.10.0-1160.59.1.el7
commit-author Mathias Krause <minipli@grsecurity.net>
commit a0f90c8815706981c483a652a6aefca51a5e191c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.59.1.el7/a0f90c88.failed

A failing usercopy of the fence_rep object will lead to a stale entry in
the file descriptor table as put_unused_fd() won't release it. This
enables userland to refer to a dangling 'file' object through that still
valid file descriptor, leading to all kinds of use-after-free
exploitation scenarios.

Fix this by deferring the call to fd_install() until after the usercopy
has succeeded.

Fixes: c906965dee22 ("drm/vmwgfx: Add export fence to file descriptor support")
	Signed-off-by: Mathias Krause <minipli@grsecurity.net>
	Signed-off-by: Zack Rusin <zackr@vmware.com>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a0f90c8815706981c483a652a6aefca51a5e191c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
diff --cc drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
index 88b8178d4687,dd2ff441068e..000000000000
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
@@@ -3587,23 -3871,20 +3587,28 @@@ int vmw_execbuf_fence_commands(struct d
   * @out_fence_fd: exported file descriptor for the fence.  -1 if not used
   * @sync_file:  Only used to clean up in case of an error in this function.
   *
 - * This function copies fence information to user-space. If copying fails, the
 - * user-space struct drm_vmw_fence_rep::error member is hopefully left
 - * untouched, and if it's preloaded with an -EFAULT by user-space, the error
 - * will hopefully be detected.
 - *
 - * Also if copying fails, user-space will be unable to signal the fence object
 - * so we wait for it immediately, and then unreference the user-space reference.
 + * This function copies fence information to user-space. If copying fails,
 + * The user-space struct drm_vmw_fence_rep::error member is hopefully
 + * left untouched, and if it's preloaded with an -EFAULT by user-space,
 + * the error will hopefully be detected.
 + * Also if copying fails, user-space will be unable to signal the fence
 + * object so we wait for it immediately, and then unreference the
 + * user-space reference.
   */
- void
+ int
  vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv,
 -			    struct vmw_fpriv *vmw_fp, int ret,
 +			    struct vmw_fpriv *vmw_fp,
 +			    int ret,
  			    struct drm_vmw_fence_rep __user *user_fence_rep,
++<<<<<<< HEAD
 +			    struct vmw_fence_obj *fence,
 +			    uint32_t fence_handle,
 +			    int32_t out_fence_fd,
 +			    struct sync_file *sync_file)
++=======
+ 			    struct vmw_fence_obj *fence, uint32_t fence_handle,
+ 			    int32_t out_fence_fd)
++>>>>>>> a0f90c881570 (drm/vmwgfx: Fix stale file descriptors on failed usercopy)
  {
  	struct drm_vmw_fence_rep fence_rep;
  
@@@ -3632,21 -3913,12 +3637,26 @@@
  			   sizeof(fence_rep));
  
  	/*
 -	 * User-space lost the fence object. We need to sync and unreference the
 -	 * handle.
 +	 * User-space lost the fence object. We need to sync
 +	 * and unreference the handle.
  	 */
  	if (unlikely(ret != 0) && (fence_rep.error == 0)) {
++<<<<<<< HEAD
 +		if (sync_file)
 +			fput(sync_file->file);
 +
 +		if (fence_rep.fd != -1) {
 +			put_unused_fd(fence_rep.fd);
 +			fence_rep.fd = -1;
 +		}
 +
 +		ttm_ref_object_base_unref(vmw_fp->tfile,
 +					  fence_handle, TTM_REF_USAGE);
 +		DRM_ERROR("Fence copy error. Syncing.\n");
++=======
+ 		ttm_ref_object_base_unref(vmw_fp->tfile, fence_handle);
+ 		VMW_DEBUG_USER("Fence copy error. Syncing.\n");
++>>>>>>> a0f90c881570 (drm/vmwgfx: Fix stale file descriptors on failed usercopy)
  		(void) vmw_fence_obj_wait(fence, false, false,
  					  VMW_FENCE_WAIT_TIMEOUT);
  	}
@@@ -4003,10 -4277,6 +4026,13 @@@ int vmw_execbuf_process(struct drm_fil
  		}
  	}
  
++<<<<<<< HEAD
 +	vmw_execbuf_copy_fence_user(dev_priv, vmw_fpriv(file_priv), ret,
 +				    user_fence_rep, fence, handle,
 +				    out_fence_fd, sync_file);
 +
++=======
++>>>>>>> a0f90c881570 (drm/vmwgfx: Fix stale file descriptors on failed usercopy)
  	/* Don't unreference when handing fence out */
  	if (unlikely(out_fence != NULL)) {
  		*out_fence = fence;
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
index cd607ba9c2fe..efd540f02227 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h
@@ -924,15 +924,14 @@ extern int vmw_execbuf_fence_commands(struct drm_file *file_priv,
 				      struct vmw_private *dev_priv,
 				      struct vmw_fence_obj **p_fence,
 				      uint32_t *p_handle);
-extern void vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv,
+extern int vmw_execbuf_copy_fence_user(struct vmw_private *dev_priv,
 					struct vmw_fpriv *vmw_fp,
 					int ret,
 					struct drm_vmw_fence_rep __user
 					*user_fence_rep,
 					struct vmw_fence_obj *fence,
 					uint32_t fence_handle,
-					int32_t out_fence_fd,
-					struct sync_file *sync_file);
+					int32_t out_fence_fd);
 bool vmw_cmd_describe(const void *buf, u32 *size, char const **cmd);
 
 /**
* Unmerged path drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c b/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c
index 301260e23e52..624754cc4fc1 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_fence.c
@@ -1167,7 +1167,7 @@ int vmw_fence_event_ioctl(struct drm_device *dev, void *data,
 	}
 
 	vmw_execbuf_copy_fence_user(dev_priv, vmw_fp, 0, user_fence_rep, fence,
-				    handle, -1, NULL);
+				    handle, -1);
 	vmw_fence_obj_unreference(&fence);
 	return 0;
 out_no_create:
diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
index ed2f67822f45..fdf58090aa4a 100644
--- a/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_kms.c
@@ -2565,7 +2565,7 @@ void vmw_kms_helper_validation_finish(struct vmw_private *dev_priv,
 	if (file_priv)
 		vmw_execbuf_copy_fence_user(dev_priv, vmw_fpriv(file_priv),
 					    ret, user_fence_rep, fence,
-					    handle, -1, NULL);
+					    handle, -1);
 	if (out_fence)
 		*out_fence = fence;
 	else
