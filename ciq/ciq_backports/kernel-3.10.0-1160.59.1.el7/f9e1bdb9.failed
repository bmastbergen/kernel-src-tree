efi: Decode IA32/X64 Processor Error Section

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-1160.59.1.el7
commit-author Yazen Ghannam <yazen.ghannam@amd.com>
commit f9e1bdb9f35f4f5cfa7c9025ac68c02909b6d3b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.59.1.el7/f9e1bdb9.failed

Recognize the IA32/X64 Processor Error Section.

Do the section decoding in a new "cper-x86.c" file and add this to the
Makefile depending on a new "UEFI_CPER_X86" config option.

Print the Local APIC ID and CPUID info from the Processor Error Record.

The "Processor Error Info" and "Processor Context" fields will be
decoded in following patches.

Based on UEFI 2.7 Table 252. Processor Error Record.

	Signed-off-by: Yazen Ghannam <yazen.ghannam@amd.com>
	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Matt Fleming <matt@codeblueprint.co.uk>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-efi@vger.kernel.org
Link: http://lkml.kernel.org/r/20180504060003.19618-5-ard.biesheuvel@linaro.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit f9e1bdb9f35f4f5cfa7c9025ac68c02909b6d3b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/Kconfig
#	drivers/firmware/efi/Makefile
#	drivers/firmware/efi/cper.c
#	include/linux/cper.h
diff --cc drivers/firmware/efi/Kconfig
index 6dde5f3c511f,781a4a337557..000000000000
--- a/drivers/firmware/efi/Kconfig
+++ b/drivers/firmware/efi/Kconfig
@@@ -58,8 -84,101 +58,24 @@@ config UEFI_CPE
  config EFI_RUNTIME_WRAPPERS
  	bool
  
 -config EFI_ARMSTUB
 -	bool
 -
 -config EFI_BOOTLOADER_CONTROL
 -	tristate "EFI Bootloader Control"
 -	depends on EFI_VARS
 -	default n
 -	---help---
 -	  This module installs a reboot hook, such that if reboot() is
 -	  invoked with a string argument NNN, "NNN" is copied to the
 -	  "LoaderEntryOneShot" EFI variable, to be read by the
 -	  bootloader. If the string matches one of the boot labels
 -	  defined in its configuration, the bootloader will boot once
 -	  to that label. The "LoaderEntryRebootReason" EFI variable is
 -	  set with the reboot reason: "reboot" or "shutdown". The
 -	  bootloader reads this reboot reason and takes particular
 -	  action according to its policy.
 -
 -config EFI_CAPSULE_LOADER
 -	tristate "EFI capsule loader"
 -	depends on EFI
 -	help
 -	  This option exposes a loader interface "/dev/efi_capsule_loader" for
 -	  users to load EFI capsules. This driver requires working runtime
 -	  capsule support in the firmware, which many OEMs do not provide.
 -
 -	  Most users should say N.
 -
 -config EFI_CAPSULE_QUIRK_QUARK_CSH
 -	bool "Add support for Quark capsules with non-standard headers"
 -	depends on X86 && !64BIT
 -	select EFI_CAPSULE_LOADER
 -	default y
 -	help
 -	  Add support for processing Quark X1000 EFI capsules, whose header
 -	  layout deviates from the layout mandated by the UEFI specification.
 -
 -config EFI_TEST
 -	tristate "EFI Runtime Service Tests Support"
 -	depends on EFI
 -	default n
 -	help
 -	  This driver uses the efi.<service> function pointers directly instead
 -	  of going through the efivar API, because it is not trying to test the
 -	  kernel subsystem, just for testing the UEFI runtime service
 -	  interfaces which are provided by the firmware. This driver is used
 -	  by the Firmware Test Suite (FWTS) for testing the UEFI runtime
 -	  interfaces readiness of the firmware.
 -	  Details for FWTS are available from:
 -	  <https://wiki.ubuntu.com/FirmwareTestSuite>
 -
 -	  Say Y here to enable the runtime services support via /dev/efi_test.
 -	  If unsure, say N.
 -
 -config APPLE_PROPERTIES
 -	bool "Apple Device Properties"
 -	depends on EFI_STUB && X86
 -	select EFI_DEV_PATH_PARSER
 -	select UCS2_STRING
 -	help
 -	  Retrieve properties from EFI on Apple Macs and assign them to
 -	  devices, allowing for improved support of Apple hardware.
 -	  Properties that would otherwise be missing include the
 -	  Thunderbolt Device ROM and GPU configuration data.
 -
 -	  If unsure, say Y if you have a Mac.  Otherwise N.
 -
 -config RESET_ATTACK_MITIGATION
 -	bool "Reset memory attack mitigation"
 -	depends on EFI_STUB
 -	help
 -	  Request that the firmware clear the contents of RAM after a reboot
 -	  using the TCG Platform Reset Attack Mitigation specification. This
 -	  protects against an attacker forcibly rebooting the system while it
 -	  still contains secrets in RAM, booting another OS and extracting the
 -	  secrets. This should only be enabled when userland is configured to
 -	  clear the MemoryOverwriteRequest flag on clean shutdown after secrets
 -	  have been evicted, since otherwise it will trigger even on clean
 -	  reboots.
 -
  endmenu
  
++<<<<<<< HEAD
++=======
+ config UEFI_CPER
+ 	bool
+ 
+ config UEFI_CPER_ARM
+ 	bool
+ 	depends on UEFI_CPER && ( ARM || ARM64 )
+ 	default y
+ 
+ config UEFI_CPER_X86
+ 	bool
+ 	depends on UEFI_CPER && X86
+ 	default y
+ 
++>>>>>>> f9e1bdb9f35f (efi: Decode IA32/X64 Processor Error Section)
  config EFI_DEV_PATH_PARSER
  	bool
  	depends on ACPI
diff --cc drivers/firmware/efi/Makefile
index 1b9de08e6252,5f9f5039de50..000000000000
--- a/drivers/firmware/efi/Makefile
+++ b/drivers/firmware/efi/Makefile
@@@ -5,7 -16,19 +5,18 @@@ obj-y					+= efi.o vars.
  obj-$(CONFIG_EFI_VARS)			+= efivars.o
  obj-$(CONFIG_EFI_ESRT)			+= esrt.o
  obj-$(CONFIG_EFI_VARS_PSTORE)		+= efi-pstore.o
 -obj-$(CONFIG_UEFI_CPER)			+= cper.o
  obj-$(CONFIG_EFI_RUNTIME_MAP)		+= runtime-map.o
 +obj-$(CONFIG_UEFI_CPER)			+= cper.o
  obj-$(CONFIG_EFI_RUNTIME_WRAPPERS)	+= runtime-wrappers.o
 -obj-$(CONFIG_EFI_STUB)			+= libstub/
 -obj-$(CONFIG_EFI_FAKE_MEMMAP)		+= fake_mem.o
 -obj-$(CONFIG_EFI_BOOTLOADER_CONTROL)	+= efibc.o
 -obj-$(CONFIG_EFI_TEST)			+= test/
  obj-$(CONFIG_EFI_DEV_PATH_PARSER)	+= dev-path-parser.o
++<<<<<<< HEAD
++=======
+ obj-$(CONFIG_APPLE_PROPERTIES)		+= apple-properties.o
+ 
+ arm-obj-$(CONFIG_EFI)			:= arm-init.o arm-runtime.o
+ obj-$(CONFIG_ARM)			+= $(arm-obj-y)
+ obj-$(CONFIG_ARM64)			+= $(arm-obj-y)
+ obj-$(CONFIG_EFI_CAPSULE_LOADER)	+= capsule-loader.o
+ obj-$(CONFIG_UEFI_CPER_ARM)		+= cper-arm.o
+ obj-$(CONFIG_UEFI_CPER_X86)		+= cper-x86.o
++>>>>>>> f9e1bdb9f35f (efi: Decode IA32/X64 Processor Error Section)
diff --cc drivers/firmware/efi/cper.c
index aa1b118519c3,3bf0dca378a6..000000000000
--- a/drivers/firmware/efi/cper.c
+++ b/drivers/firmware/efi/cper.c
@@@ -436,8 -458,35 +436,40 @@@ cper_estatus_print_section(const char *
  			cper_print_pcie(newpfx, pcie, gdata);
  		else
  			goto err_section_too_small;
++<<<<<<< HEAD
 +	} else
 +		printk("%s""section type: unknown, %pUl\n", newpfx, sec_type);
++=======
+ #if defined(CONFIG_ARM64) || defined(CONFIG_ARM)
+ 	} else if (!uuid_le_cmp(*sec_type, CPER_SEC_PROC_ARM)) {
+ 		struct cper_sec_proc_arm *arm_err = acpi_hest_get_payload(gdata);
+ 
+ 		printk("%ssection_type: ARM processor error\n", newpfx);
+ 		if (gdata->error_data_length >= sizeof(*arm_err))
+ 			cper_print_proc_arm(newpfx, arm_err);
+ 		else
+ 			goto err_section_too_small;
+ #endif
+ #if defined(CONFIG_UEFI_CPER_X86)
+ 	} else if (guid_equal(sec_type, &CPER_SEC_PROC_IA)) {
+ 		struct cper_sec_proc_ia *ia_err = acpi_hest_get_payload(gdata);
+ 
+ 		printk("%ssection_type: IA32/X64 processor error\n", newpfx);
+ 		if (gdata->error_data_length >= sizeof(*ia_err))
+ 			cper_print_proc_ia(newpfx, ia_err);
+ 		else
+ 			goto err_section_too_small;
+ #endif
+ 	} else {
+ 		const void *err = acpi_hest_get_payload(gdata);
+ 
+ 		printk("%ssection type: unknown, %pUl\n", newpfx, sec_type);
+ 		printk("%ssection length: %#x\n", newpfx,
+ 		       gdata->error_data_length);
+ 		print_hex_dump(newpfx, "", DUMP_PREFIX_OFFSET, 16, 4, err,
+ 			       gdata->error_data_length, true);
+ 	}
++>>>>>>> f9e1bdb9f35f (efi: Decode IA32/X64 Processor Error Section)
  
  	return;
  
diff --cc include/linux/cper.h
index 1c6fa31e2aa2,9c703a0abe6e..000000000000
--- a/include/linux/cper.h
+++ b/include/linux/cper.h
@@@ -429,5 -549,9 +429,12 @@@ void cper_mem_err_pack(const struct cpe
  		       struct cper_mem_err_compact *);
  const char *cper_mem_err_unpack(struct trace_seq *,
  				struct cper_mem_err_compact *);
++<<<<<<< HEAD
++=======
+ void cper_print_proc_arm(const char *pfx,
+ 			 const struct cper_sec_proc_arm *proc);
+ void cper_print_proc_ia(const char *pfx,
+ 			const struct cper_sec_proc_ia *proc);
++>>>>>>> f9e1bdb9f35f (efi: Decode IA32/X64 Processor Error Section)
  
  #endif
* Unmerged path drivers/firmware/efi/Kconfig
* Unmerged path drivers/firmware/efi/Makefile
diff --git a/drivers/firmware/efi/cper-x86.c b/drivers/firmware/efi/cper-x86.c
new file mode 100644
index 000000000000..863f0cd2a0ff
--- /dev/null
+++ b/drivers/firmware/efi/cper-x86.c
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (C) 2018, Advanced Micro Devices, Inc.
+
+#include <linux/cper.h>
+
+/*
+ * We don't need a "CPER_IA" prefix since these are all locally defined.
+ * This will save us a lot of line space.
+ */
+#define VALID_LAPIC_ID			BIT_ULL(0)
+#define VALID_CPUID_INFO		BIT_ULL(1)
+
+void cper_print_proc_ia(const char *pfx, const struct cper_sec_proc_ia *proc)
+{
+	if (proc->validation_bits & VALID_LAPIC_ID)
+		printk("%sLocal APIC_ID: 0x%llx\n", pfx, proc->lapic_id);
+
+	if (proc->validation_bits & VALID_CPUID_INFO) {
+		printk("%sCPUID Info:\n", pfx);
+		print_hex_dump(pfx, "", DUMP_PREFIX_OFFSET, 16, 4, proc->cpuid,
+			       sizeof(proc->cpuid), 0);
+	}
+}
* Unmerged path drivers/firmware/efi/cper.c
* Unmerged path include/linux/cper.h
