epoll: Keep a reference on files added to the check list

jira LE-1907
cve CVE-2020-0466
Rebuild_History Non-Buildable kernel-3.10.0-1160.59.1.el7
commit-author Marc Zyngier <maz@kernel.org>
commit a9ed4a6560b8562b7e2e2bed9527e88001f7b682
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-1160.59.1.el7/a9ed4a65.failed

When adding a new fd to an epoll, and that this new fd is an
epoll fd itself, we recursively scan the fds attached to it
to detect cycles, and add non-epool files to a "check list"
that gets subsequently parsed.

However, this check list isn't completely safe when deletions
can happen concurrently. To sidestep the issue, make sure that
a struct file placed on the check list sees its f_count increased,
ensuring that a concurrent deletion won't result in the file
disapearing from under our feet.

	Cc: stable@vger.kernel.org
	Signed-off-by: Marc Zyngier <maz@kernel.org>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit a9ed4a6560b8562b7e2e2bed9527e88001f7b682)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/eventpoll.c
diff --cc fs/eventpoll.c
index 6731b99a481f,196003d9242c..000000000000
--- a/fs/eventpoll.c
+++ b/fs/eventpoll.c
@@@ -1951,13 -2207,26 +1954,26 @@@ SYSCALL_DEFINE4(epoll_ctl, int, epfd, i
  					clear_tfile_check_list();
  					goto error_tgt_fput;
  				}
- 			} else
+ 			} else {
+ 				get_file(tf.file);
  				list_add(&tf.file->f_tfile_llink,
  							&tfile_check_list);
++<<<<<<< HEAD
 +			mutex_lock_nested(&ep->mtx, 0);
++=======
+ 			}
+ 			error = epoll_mutex_lock(&ep->mtx, 0, nonblock);
+ 			if (error) {
+ out_del:
+ 				list_del(&tf.file->f_tfile_llink);
+ 				if (!is_file_epoll(tf.file))
+ 					fput(tf.file);
+ 				goto error_tgt_fput;
+ 			}
++>>>>>>> a9ed4a6560b8 (epoll: Keep a reference on files added to the check list)
  			if (is_file_epoll(tf.file)) {
  				tep = tf.file->private_data;
 -				error = epoll_mutex_lock(&tep->mtx, 1, nonblock);
 -				if (error) {
 -					mutex_unlock(&ep->mtx);
 -					goto out_del;
 -				}
 +				mutex_lock_nested(&tep->mtx, 1);
  			}
  		}
  	}
* Unmerged path fs/eventpoll.c
