netfilter: nf_tables: simplify NLM_F_CREATE handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 445509eb9b00278b31c92f16b05260176a41c27f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/445509eb.failed

* From nf_tables_newchain(), codepath provides context that allows us to
  infer if we are updating a chain (in that case, no module autoload is
  required) or adding a new one (then, module autoload is indeed
  needed).
* We only need it in one single spot in nf_tables_newrule().
* Not needed for nf_tables_newset() at all.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 445509eb9b00278b31c92f16b05260176a41c27f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index eb8b9258c93a,67cdd5c4f4f5..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -1523,13 -1464,10 +1523,13 @@@ static int nft_chain_parse_hook(struct 
  	hook->num = ntohl(nla_get_be32(ha[NFTA_HOOK_HOOKNUM]));
  	hook->priority = ntohl(nla_get_be32(ha[NFTA_HOOK_PRIORITY]));
  
 -	type = chain_type[family][NFT_CHAIN_T_DEFAULT];
 +	type = __nft_chain_type_get(family, NFT_CHAIN_T_DEFAULT);
 +	if (!type)
 +		return -EOPNOTSUPP;
 +
  	if (nla[NFTA_CHAIN_TYPE]) {
  		type = nf_tables_chain_type_lookup(net, nla[NFTA_CHAIN_TYPE],
- 						   family, create);
+ 						   family, autoload);
  		if (IS_ERR(type))
  			return PTR_ERR(type);
  	}
@@@ -1822,10 -1760,9 +1821,7 @@@ static int nf_tables_newchain(struct ne
  	u8 policy = NF_ACCEPT;
  	struct nft_ctx ctx;
  	u64 handle = 0;
- 	bool create;
- 
- 	create = nlh->nlmsg_flags & NLM_F_CREATE ? true : false;
  
 -	lockdep_assert_held(&net->nft.commit_mutex);
 -
  	table = nft_table_lookup(net, nla[NFTA_CHAIN_TABLE], family, genmask);
  	if (IS_ERR(table)) {
  		NL_SET_BAD_ATTR(extack, nla[NFTA_CHAIN_TABLE]);
@@@ -2648,10 -2525,9 +2644,13 @@@ static int nf_tables_newrule(struct ne
  	struct nlattr *tmp;
  	unsigned int size, i, n, ulen = 0, usize = 0;
  	int err, rem;
- 	bool create;
  	u64 handle, pos_handle;
  
++<<<<<<< HEAD
 +	create = nlh->nlmsg_flags & NLM_F_CREATE ? true : false;
++=======
+ 	lockdep_assert_held(&net->nft.commit_mutex);
++>>>>>>> 445509eb9b00 (netfilter: nf_tables: simplify NLM_F_CREATE handling)
  
  	table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask);
  	if (IS_ERR(table)) {
@@@ -3544,8 -3354,7 +3544,12 @@@ static int nf_tables_newset(struct net 
  	struct nft_set *set;
  	struct nft_ctx ctx;
  	char *name;
++<<<<<<< HEAD
 +	u64 size;
 +	bool create;
++=======
+ 	unsigned int size;
++>>>>>>> 445509eb9b00 (netfilter: nf_tables: simplify NLM_F_CREATE handling)
  	u64 timeout;
  	u32 ktype, dtype, flags, policy, gc_int, objtype;
  	struct nft_set_desc desc;
* Unmerged path net/netfilter/nf_tables_api.c
