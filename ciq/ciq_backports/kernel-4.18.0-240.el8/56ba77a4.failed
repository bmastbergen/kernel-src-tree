KVM: x86: Save L1 TSC offset in 'struct kvm_vcpu_arch'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 56ba77a459a72a7d95be74355a40a91e1f6dd7f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/56ba77a4.failed

Save L1's TSC offset in 'struct kvm_vcpu_arch' and drop the kvm_x86_ops
hook read_l1_tsc_offset().  This avoids a retpoline (when configured)
when reading L1's effective TSC, which is done at least once on every
VM-Exit.

No functional change intended.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200502043234.12481-2-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 56ba77a459a72a7d95be74355a40a91e1f6dd7f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/vmx/vmx.c
index d3ab0cabbd21,31a8d04a6c41..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -1776,17 -1740,6 +1776,20 @@@ static void setup_msrs(struct vcpu_vmx 
  		vmx_update_msr_bitmap(&vmx->vcpu);
  }
  
++<<<<<<< HEAD
 +static u64 vmx_read_l1_tsc_offset(struct kvm_vcpu *vcpu)
 +{
 +	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
 +
 +	if (is_guest_mode(vcpu) &&
 +	    (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETING))
 +		return vcpu->arch.tsc_offset - vmcs12->tsc_offset;
 +
 +	return vcpu->arch.tsc_offset;
 +}
 +
++=======
++>>>>>>> 56ba77a459a7 (KVM: x86: Save L1 TSC offset in 'struct kvm_vcpu_arch')
  static u64 vmx_write_l1_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)
  {
  	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
@@@ -7707,6 -7764,153 +7710,156 @@@ static bool vmx_apic_init_signal_blocke
  	return to_vmx(vcpu)->nested.vmxon;
  }
  
++<<<<<<< HEAD
++=======
+ static void hardware_unsetup(void)
+ {
+ 	if (nested)
+ 		nested_vmx_hardware_unsetup();
+ 
+ 	free_kvm_area();
+ }
+ 
+ static bool vmx_check_apicv_inhibit_reasons(ulong bit)
+ {
+ 	ulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |
+ 			  BIT(APICV_INHIBIT_REASON_HYPERV);
+ 
+ 	return supported & BIT(bit);
+ }
+ 
+ static struct kvm_x86_ops vmx_x86_ops __initdata = {
+ 	.hardware_unsetup = hardware_unsetup,
+ 
+ 	.hardware_enable = hardware_enable,
+ 	.hardware_disable = hardware_disable,
+ 	.cpu_has_accelerated_tpr = report_flexpriority,
+ 	.has_emulated_msr = vmx_has_emulated_msr,
+ 
+ 	.vm_size = sizeof(struct kvm_vmx),
+ 	.vm_init = vmx_vm_init,
+ 
+ 	.vcpu_create = vmx_create_vcpu,
+ 	.vcpu_free = vmx_free_vcpu,
+ 	.vcpu_reset = vmx_vcpu_reset,
+ 
+ 	.prepare_guest_switch = vmx_prepare_switch_to_guest,
+ 	.vcpu_load = vmx_vcpu_load,
+ 	.vcpu_put = vmx_vcpu_put,
+ 
+ 	.update_bp_intercept = update_exception_bitmap,
+ 	.get_msr_feature = vmx_get_msr_feature,
+ 	.get_msr = vmx_get_msr,
+ 	.set_msr = vmx_set_msr,
+ 	.get_segment_base = vmx_get_segment_base,
+ 	.get_segment = vmx_get_segment,
+ 	.set_segment = vmx_set_segment,
+ 	.get_cpl = vmx_get_cpl,
+ 	.get_cs_db_l_bits = vmx_get_cs_db_l_bits,
+ 	.decache_cr0_guest_bits = vmx_decache_cr0_guest_bits,
+ 	.decache_cr4_guest_bits = vmx_decache_cr4_guest_bits,
+ 	.set_cr0 = vmx_set_cr0,
+ 	.set_cr4 = vmx_set_cr4,
+ 	.set_efer = vmx_set_efer,
+ 	.get_idt = vmx_get_idt,
+ 	.set_idt = vmx_set_idt,
+ 	.get_gdt = vmx_get_gdt,
+ 	.set_gdt = vmx_set_gdt,
+ 	.set_dr7 = vmx_set_dr7,
+ 	.sync_dirty_debug_regs = vmx_sync_dirty_debug_regs,
+ 	.cache_reg = vmx_cache_reg,
+ 	.get_rflags = vmx_get_rflags,
+ 	.set_rflags = vmx_set_rflags,
+ 
+ 	.tlb_flush_all = vmx_flush_tlb_all,
+ 	.tlb_flush_current = vmx_flush_tlb_current,
+ 	.tlb_flush_gva = vmx_flush_tlb_gva,
+ 	.tlb_flush_guest = vmx_flush_tlb_guest,
+ 
+ 	.run = vmx_vcpu_run,
+ 	.handle_exit = vmx_handle_exit,
+ 	.skip_emulated_instruction = vmx_skip_emulated_instruction,
+ 	.update_emulated_instruction = vmx_update_emulated_instruction,
+ 	.set_interrupt_shadow = vmx_set_interrupt_shadow,
+ 	.get_interrupt_shadow = vmx_get_interrupt_shadow,
+ 	.patch_hypercall = vmx_patch_hypercall,
+ 	.set_irq = vmx_inject_irq,
+ 	.set_nmi = vmx_inject_nmi,
+ 	.queue_exception = vmx_queue_exception,
+ 	.cancel_injection = vmx_cancel_injection,
+ 	.interrupt_allowed = vmx_interrupt_allowed,
+ 	.nmi_allowed = vmx_nmi_allowed,
+ 	.get_nmi_mask = vmx_get_nmi_mask,
+ 	.set_nmi_mask = vmx_set_nmi_mask,
+ 	.enable_nmi_window = enable_nmi_window,
+ 	.enable_irq_window = enable_irq_window,
+ 	.update_cr8_intercept = update_cr8_intercept,
+ 	.set_virtual_apic_mode = vmx_set_virtual_apic_mode,
+ 	.set_apic_access_page_addr = vmx_set_apic_access_page_addr,
+ 	.refresh_apicv_exec_ctrl = vmx_refresh_apicv_exec_ctrl,
+ 	.load_eoi_exitmap = vmx_load_eoi_exitmap,
+ 	.apicv_post_state_restore = vmx_apicv_post_state_restore,
+ 	.check_apicv_inhibit_reasons = vmx_check_apicv_inhibit_reasons,
+ 	.hwapic_irr_update = vmx_hwapic_irr_update,
+ 	.hwapic_isr_update = vmx_hwapic_isr_update,
+ 	.guest_apic_has_interrupt = vmx_guest_apic_has_interrupt,
+ 	.sync_pir_to_irr = vmx_sync_pir_to_irr,
+ 	.deliver_posted_interrupt = vmx_deliver_posted_interrupt,
+ 	.dy_apicv_has_pending_interrupt = vmx_dy_apicv_has_pending_interrupt,
+ 
+ 	.set_tss_addr = vmx_set_tss_addr,
+ 	.set_identity_map_addr = vmx_set_identity_map_addr,
+ 	.get_tdp_level = get_ept_level,
+ 	.get_mt_mask = vmx_get_mt_mask,
+ 
+ 	.get_exit_info = vmx_get_exit_info,
+ 
+ 	.cpuid_update = vmx_cpuid_update,
+ 
+ 	.has_wbinvd_exit = cpu_has_vmx_wbinvd_exit,
+ 
+ 	.write_l1_tsc_offset = vmx_write_l1_tsc_offset,
+ 
+ 	.load_mmu_pgd = vmx_load_mmu_pgd,
+ 
+ 	.check_intercept = vmx_check_intercept,
+ 	.handle_exit_irqoff = vmx_handle_exit_irqoff,
+ 
+ 	.request_immediate_exit = vmx_request_immediate_exit,
+ 
+ 	.sched_in = vmx_sched_in,
+ 
+ 	.slot_enable_log_dirty = vmx_slot_enable_log_dirty,
+ 	.slot_disable_log_dirty = vmx_slot_disable_log_dirty,
+ 	.flush_log_dirty = vmx_flush_log_dirty,
+ 	.enable_log_dirty_pt_masked = vmx_enable_log_dirty_pt_masked,
+ 	.write_log_dirty = vmx_write_pml_buffer,
+ 
+ 	.pre_block = vmx_pre_block,
+ 	.post_block = vmx_post_block,
+ 
+ 	.pmu_ops = &intel_pmu_ops,
+ 	.nested_ops = &vmx_nested_ops,
+ 
+ 	.update_pi_irte = vmx_update_pi_irte,
+ 
+ #ifdef CONFIG_X86_64
+ 	.set_hv_timer = vmx_set_hv_timer,
+ 	.cancel_hv_timer = vmx_cancel_hv_timer,
+ #endif
+ 
+ 	.setup_mce = vmx_setup_mce,
+ 
+ 	.smi_allowed = vmx_smi_allowed,
+ 	.pre_enter_smm = vmx_pre_enter_smm,
+ 	.pre_leave_smm = vmx_pre_leave_smm,
+ 	.enable_smi_window = enable_smi_window,
+ 
+ 	.need_emulation_on_page_fault = vmx_need_emulation_on_page_fault,
+ 	.apic_init_signal_blocked = vmx_apic_init_signal_blocked,
+ };
+ 
++>>>>>>> 56ba77a459a7 (KVM: x86: Save L1 TSC offset in 'struct kvm_vcpu_arch')
  static __init int hardware_setup(void)
  {
  	unsigned long host_bndcfgs;
diff --cc arch/x86/kvm/x86.c
index 12e08a32ea3b,3622586a26a7..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -1901,7 -1910,7 +1901,11 @@@ static void kvm_track_tsc_matching(stru
  
  static void update_ia32_tsc_adjust_msr(struct kvm_vcpu *vcpu, s64 offset)
  {
++<<<<<<< HEAD
 +	u64 curr_offset = kvm_x86_ops->read_l1_tsc_offset(vcpu);
++=======
+ 	u64 curr_offset = vcpu->arch.l1_tsc_offset;
++>>>>>>> 56ba77a459a7 (KVM: x86: Save L1 TSC offset in 'struct kvm_vcpu_arch')
  	vcpu->arch.ia32_tsc_adjust_msr += offset - curr_offset;
  }
  
@@@ -1943,15 -1952,14 +1947,24 @@@ static u64 kvm_compute_tsc_offset(struc
  
  u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)
  {
++<<<<<<< HEAD
 +	u64 tsc_offset = kvm_x86_ops->read_l1_tsc_offset(vcpu);
 +
 +	return tsc_offset + kvm_scale_tsc(vcpu, host_tsc);
++=======
+ 	return vcpu->arch.l1_tsc_offset + kvm_scale_tsc(vcpu, host_tsc);
++>>>>>>> 56ba77a459a7 (KVM: x86: Save L1 TSC offset in 'struct kvm_vcpu_arch')
  }
  EXPORT_SYMBOL_GPL(kvm_read_l1_tsc);
  
  static void kvm_vcpu_write_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)
  {
++<<<<<<< HEAD
 +	vcpu->arch.tsc_offset = kvm_x86_ops->write_l1_tsc_offset(vcpu, offset);
++=======
+ 	vcpu->arch.l1_tsc_offset = offset;
+ 	vcpu->arch.tsc_offset = kvm_x86_ops.write_l1_tsc_offset(vcpu, offset);
++>>>>>>> 56ba77a459a7 (KVM: x86: Save L1 TSC offset in 'struct kvm_vcpu_arch')
  }
  
  static inline bool kvm_check_tsc_unstable(void)
@@@ -2075,7 -2083,7 +2088,11 @@@ EXPORT_SYMBOL_GPL(kvm_write_tsc)
  static inline void adjust_tsc_offset_guest(struct kvm_vcpu *vcpu,
  					   s64 adjustment)
  {
++<<<<<<< HEAD
 +	u64 tsc_offset = kvm_x86_ops->read_l1_tsc_offset(vcpu);
++=======
+ 	u64 tsc_offset = vcpu->arch.l1_tsc_offset;
++>>>>>>> 56ba77a459a7 (KVM: x86: Save L1 TSC offset in 'struct kvm_vcpu_arch')
  	kvm_vcpu_write_tsc_offset(vcpu, tsc_offset + adjustment);
  }
  
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 8e755c9a81df..8b6298fdbcf1 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -705,6 +705,7 @@ struct kvm_vcpu_arch {
 		struct gfn_to_pfn_cache cache;
 	} st;
 
+	u64 l1_tsc_offset;
 	u64 tsc_offset;
 	u64 last_guest_tsc;
 	u64 last_host_tsc;
@@ -1164,7 +1165,6 @@ struct kvm_x86_ops {
 
 	bool (*has_wbinvd_exit)(void);
 
-	u64 (*read_l1_tsc_offset)(struct kvm_vcpu *vcpu);
 	/* Returns actual tsc_offset set in active VMCS */
 	u64 (*write_l1_tsc_offset)(struct kvm_vcpu *vcpu, u64 offset);
 
diff --git a/arch/x86/kvm/svm/svm.c b/arch/x86/kvm/svm/svm.c
index 16a059812b69..f8bb85f0205f 100644
--- a/arch/x86/kvm/svm/svm.c
+++ b/arch/x86/kvm/svm/svm.c
@@ -1528,16 +1528,6 @@ static void init_sys_seg(struct vmcb_seg *seg, uint32_t type)
 	seg->base = 0;
 }
 
-static u64 svm_read_l1_tsc_offset(struct kvm_vcpu *vcpu)
-{
-	struct vcpu_svm *svm = to_svm(vcpu);
-
-	if (is_guest_mode(vcpu))
-		return svm->nested.hsave->control.tsc_offset;
-
-	return vcpu->arch.tsc_offset;
-}
-
 static u64 svm_write_l1_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)
 {
 	struct vcpu_svm *svm = to_svm(vcpu);
@@ -7556,7 +7546,6 @@ static struct kvm_x86_ops svm_x86_ops __ro_after_init = {
 
 	.has_wbinvd_exit = svm_has_wbinvd_exit,
 
-	.read_l1_tsc_offset = svm_read_l1_tsc_offset,
 	.write_l1_tsc_offset = svm_write_l1_tsc_offset,
 
 	.set_tdp_cr3 = set_tdp_cr3,
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/x86.c
