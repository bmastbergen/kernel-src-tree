bpf: Fix error path under memory pressure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Alexei Starovoitov <ast@kernel.org>
commit f59bbfc2f6099e8655f9e8f585e10ffde17176d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f59bbfc2.failed

Restore the 'if (env->cur_state)' check that was incorrectly removed during
code move. Under memory pressure env->cur_state can be freed and zeroed inside
do_check(). Hence the check is necessary.

Fixes: 51c39bb1d5d1 ("bpf: Introduce function-by-function verification")
	Reported-by: syzbot+b296579ba5015704d9fa@syzkaller.appspotmail.com
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Song Liu <songliubraving@fb.com>
Link: https://lore.kernel.org/bpf/20200122024138.3385590-1-ast@kernel.org
(cherry picked from commit f59bbfc2f6099e8655f9e8f585e10ffde17176d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index a2c1dcade9ad,6defbec9eb62..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -9504,11 -9505,164 +9504,29 @@@ static void free_states(struct bpf_veri
  			kfree(sl);
  			sl = sln;
  		}
 -		env->explored_states[i] = NULL;
 -	}
 -}
 -
 -/* The verifier is using insn_aux_data[] to store temporary data during
 - * verification and to store information for passes that run after the
 - * verification like dead code sanitization. do_check_common() for subprogram N
 - * may analyze many other subprograms. sanitize_insn_aux_data() clears all
 - * temporary data after do_check_common() finds that subprogram N cannot be
 - * verified independently. pass_cnt counts the number of times
 - * do_check_common() was run and insn->aux->seen tells the pass number
 - * insn_aux_data was touched. These variables are compared to clear temporary
 - * data from failed pass. For testing and experiments do_check_common() can be
 - * run multiple times even when prior attempt to verify is unsuccessful.
 - */
 -static void sanitize_insn_aux_data(struct bpf_verifier_env *env)
 -{
 -	struct bpf_insn *insn = env->prog->insnsi;
 -	struct bpf_insn_aux_data *aux;
 -	int i, class;
 -
 -	for (i = 0; i < env->prog->len; i++) {
 -		class = BPF_CLASS(insn[i].code);
 -		if (class != BPF_LDX && class != BPF_STX)
 -			continue;
 -		aux = &env->insn_aux_data[i];
 -		if (aux->seen != env->pass_cnt)
 -			continue;
 -		memset(aux, 0, offsetof(typeof(*aux), orig_idx));
 -	}
 -}
 -
 -static int do_check_common(struct bpf_verifier_env *env, int subprog)
 -{
 -	struct bpf_verifier_state *state;
 -	struct bpf_reg_state *regs;
 -	int ret, i;
 -
 -	env->prev_linfo = NULL;
 -	env->pass_cnt++;
 -
 -	state = kzalloc(sizeof(struct bpf_verifier_state), GFP_KERNEL);
 -	if (!state)
 -		return -ENOMEM;
 -	state->curframe = 0;
 -	state->speculative = false;
 -	state->branches = 1;
 -	state->frame[0] = kzalloc(sizeof(struct bpf_func_state), GFP_KERNEL);
 -	if (!state->frame[0]) {
 -		kfree(state);
 -		return -ENOMEM;
 -	}
 -	env->cur_state = state;
 -	init_func_state(env, state->frame[0],
 -			BPF_MAIN_FUNC /* callsite */,
 -			0 /* frameno */,
 -			subprog);
 -
 -	regs = state->frame[state->curframe]->regs;
 -	if (subprog) {
 -		ret = btf_prepare_func_args(env, subprog, regs);
 -		if (ret)
 -			goto out;
 -		for (i = BPF_REG_1; i <= BPF_REG_5; i++) {
 -			if (regs[i].type == PTR_TO_CTX)
 -				mark_reg_known_zero(env, regs, i);
 -			else if (regs[i].type == SCALAR_VALUE)
 -				mark_reg_unknown(env, regs, i);
 -		}
 -	} else {
 -		/* 1st arg to a function */
 -		regs[BPF_REG_1].type = PTR_TO_CTX;
 -		mark_reg_known_zero(env, regs, BPF_REG_1);
 -		ret = btf_check_func_arg_match(env, subprog, regs);
 -		if (ret == -EFAULT)
 -			/* unlikely verifier bug. abort.
 -			 * ret == 0 and ret < 0 are sadly acceptable for
 -			 * main() function due to backward compatibility.
 -			 * Like socket filter program may be written as:
 -			 * int bpf_prog(struct pt_regs *ctx)
 -			 * and never dereference that ctx in the program.
 -			 * 'struct pt_regs' is a type mismatch for socket
 -			 * filter that should be using 'struct __sk_buff'.
 -			 */
 -			goto out;
  	}
  
++<<<<<<< HEAD
 +	kvfree(env->explored_states);
++=======
+ 	ret = do_check(env);
+ out:
+ 	/* check for NULL is necessary, since cur_state can be freed inside
+ 	 * do_check() under memory pressure.
+ 	 */
+ 	if (env->cur_state) {
+ 		free_verifier_state(env->cur_state, true);
+ 		env->cur_state = NULL;
+ 	}
+ 	while (!pop_stack(env, NULL, NULL));
+ 	free_states(env);
+ 	if (ret)
+ 		/* clean aux data in case subprog was rejected */
+ 		sanitize_insn_aux_data(env);
+ 	return ret;
++>>>>>>> f59bbfc2f609 (bpf: Fix error path under memory pressure)
  }
  
 -/* Verify all global functions in a BPF program one by one based on their BTF.
 - * All global functions must pass verification. Otherwise the whole program is rejected.
 - * Consider:
 - * int bar(int);
 - * int foo(int f)
 - * {
 - *    return bar(f);
 - * }
 - * int bar(int b)
 - * {
 - *    ...
 - * }
 - * foo() will be verified first for R1=any_scalar_value. During verification it
 - * will be assumed that bar() already verified successfully and call to bar()
 - * from foo() will be checked for type match only. Later bar() will be verified
 - * independently to check that it's safe for R1=any_scalar_value.
 - */
 -static int do_check_subprogs(struct bpf_verifier_env *env)
 -{
 -	struct bpf_prog_aux *aux = env->prog->aux;
 -	int i, ret;
 -
 -	if (!aux->func_info)
 -		return 0;
 -
 -	for (i = 1; i < env->subprog_cnt; i++) {
 -		if (aux->func_info_aux[i].linkage != BTF_FUNC_GLOBAL)
 -			continue;
 -		env->insn_idx = env->subprog_info[i].start;
 -		WARN_ON_ONCE(env->insn_idx == 0);
 -		ret = do_check_common(env, i);
 -		if (ret) {
 -			return ret;
 -		} else if (env->log.level & BPF_LOG_LEVEL) {
 -			verbose(env,
 -				"Func#%d is safe for any args that match its prototype\n",
 -				i);
 -		}
 -	}
 -	return 0;
 -}
 -
 -static int do_check_main(struct bpf_verifier_env *env)
 -{
 -	int ret;
 -
 -	env->insn_idx = 0;
 -	ret = do_check_common(env, 0);
 -	if (!ret)
 -		env->prog->aux->stack_depth = env->subprog_info[0].stack_depth;
 -	return ret;
 -}
 -
 -
  static void print_verification_stats(struct bpf_verifier_env *env)
  {
  	int i;
* Unmerged path kernel/bpf/verifier.c
