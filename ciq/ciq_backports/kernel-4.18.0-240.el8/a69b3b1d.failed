platform/x86: Convert to new CPU match macros

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit a69b3b1d4cf061d9197d835dcf539d2dd7b9e46f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a69b3b1d.failed

The new macro set has a consistent namespace and uses C99 initializers
instead of the grufty C89 ones.

Get rid the of the local macro wrappers for consistency.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Link: https://lkml.kernel.org/r/20200320131509.766573641@linutronix.de
(cherry picked from commit a69b3b1d4cf061d9197d835dcf539d2dd7b9e46f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/platform/x86/intel-uncore-frequency.c
#	drivers/platform/x86/intel_int0002_vgpio.c
#	drivers/platform/x86/intel_mid_powerbtn.c
#	drivers/platform/x86/intel_pmc_core.c
#	drivers/platform/x86/intel_pmc_core_pltdrv.c
#	drivers/platform/x86/intel_telemetry_debugfs.c
diff --cc drivers/platform/x86/intel_int0002_vgpio.c
index e89ad4964dc1,7b23efc46a43..000000000000
--- a/drivers/platform/x86/intel_int0002_vgpio.c
+++ b/drivers/platform/x86/intel_int0002_vgpio.c
@@@ -132,8 -132,34 +132,36 @@@ static struct irq_chip int0002_irqchip 
  	.irq_ack		= int0002_irq_ack,
  	.irq_mask		= int0002_irq_mask,
  	.irq_unmask		= int0002_irq_unmask,
 -	.irq_set_wake		= int0002_irq_set_wake,
  };
  
++<<<<<<< HEAD
++=======
+ static struct irq_chip int0002_cht_irqchip = {
+ 	.name			= DRV_NAME,
+ 	.irq_ack		= int0002_irq_ack,
+ 	.irq_mask		= int0002_irq_mask,
+ 	.irq_unmask		= int0002_irq_unmask,
+ 	/*
+ 	 * No set_wake, on CHT the IRQ is typically shared with the ACPI SCI
+ 	 * and we don't want to mess with the ACPI SCI irq settings.
+ 	 */
+ 	.flags			= IRQCHIP_SKIP_SET_WAKE,
+ };
+ 
+ static const struct x86_cpu_id int0002_cpu_ids[] = {
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT,	&int0002_byt_irqchip),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT,	&int0002_cht_irqchip),
+ 	{}
+ };
+ 
+ static void int0002_init_irq_valid_mask(struct gpio_chip *chip,
+ 					unsigned long *valid_mask,
+ 					unsigned int ngpios)
+ {
+ 	bitmap_clear(valid_mask, 0, GPE0A_PME_B0_VIRT_GPIO_PIN);
+ }
+ 
++>>>>>>> a69b3b1d4cf0 (platform/x86: Convert to new CPU match macros)
  static int int0002_probe(struct platform_device *pdev)
  {
  	struct device *dev = &pdev->dev;
diff --cc drivers/platform/x86/intel_mid_powerbtn.c
index 5ad44204a9c3,9c9f209c8a33..000000000000
--- a/drivers/platform/x86/intel_mid_powerbtn.c
+++ b/drivers/platform/x86/intel_mid_powerbtn.c
@@@ -121,12 -112,9 +121,17 @@@ static const struct mid_pb_ddata mrfld_
  	.setup	= mrfld_setup,
  };
  
 +#define ICPU(model, ddata)	\
 +	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, (kernel_ulong_t)&ddata }
 +
  static const struct x86_cpu_id mid_pb_cpu_ids[] = {
++<<<<<<< HEAD
 +	ICPU(INTEL_FAM6_ATOM_SALTWELL_MID,		mfld_ddata),
 +	ICPU(INTEL_FAM6_ATOM_SILVERMONT_MID,	mrfld_ddata),
++=======
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SALTWELL_MID,	&mfld_ddata),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT_MID,	&mrfld_ddata),
++>>>>>>> a69b3b1d4cf0 (platform/x86: Convert to new CPU match macros)
  	{}
  };
  
diff --cc drivers/platform/x86/intel_pmc_core.c
index 9fe6a79a43d6,3df33ff50faa..000000000000
--- a/drivers/platform/x86/intel_pmc_core.c
+++ b/drivers/platform/x86/intel_pmc_core.c
@@@ -869,17 -871,18 +869,32 @@@ static inline void pmc_core_dbgfs_unreg
  #endif /* CONFIG_DEBUG_FS */
  
  static const struct x86_cpu_id intel_pmc_core_ids[] = {
++<<<<<<< HEAD
 +	INTEL_CPU_FAM6(SKYLAKE_L, spt_reg_map),
 +	INTEL_CPU_FAM6(SKYLAKE, spt_reg_map),
 +	INTEL_CPU_FAM6(KABYLAKE_L, spt_reg_map),
 +	INTEL_CPU_FAM6(KABYLAKE, spt_reg_map),
 +	INTEL_CPU_FAM6(CANNONLAKE_L, cnp_reg_map),
 +	INTEL_CPU_FAM6(ICELAKE_L, icl_reg_map),
 +	INTEL_CPU_FAM6(ICELAKE_NNPI, icl_reg_map),
 +	INTEL_CPU_FAM6(COMETLAKE, cnp_reg_map),
 +	INTEL_CPU_FAM6(COMETLAKE_L, cnp_reg_map),
 +	INTEL_CPU_FAM6(TIGERLAKE_L, tgl_reg_map),
 +	INTEL_CPU_FAM6(TIGERLAKE, tgl_reg_map),
++=======
+ 	X86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_L,		&spt_reg_map),
+ 	X86_MATCH_INTEL_FAM6_MODEL(SKYLAKE,		&spt_reg_map),
+ 	X86_MATCH_INTEL_FAM6_MODEL(KABYLAKE_L,		&spt_reg_map),
+ 	X86_MATCH_INTEL_FAM6_MODEL(KABYLAKE,		&spt_reg_map),
+ 	X86_MATCH_INTEL_FAM6_MODEL(CANNONLAKE_L,	&cnp_reg_map),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_L,		&icl_reg_map),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_NNPI,	&icl_reg_map),
+ 	X86_MATCH_INTEL_FAM6_MODEL(COMETLAKE,		&cnp_reg_map),
+ 	X86_MATCH_INTEL_FAM6_MODEL(COMETLAKE_L,		&cnp_reg_map),
+ 	X86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE_L,		&tgl_reg_map),
+ 	X86_MATCH_INTEL_FAM6_MODEL(TIGERLAKE,		&tgl_reg_map),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT,	&tgl_reg_map),
++>>>>>>> a69b3b1d4cf0 (platform/x86: Convert to new CPU match macros)
  	{}
  };
  
diff --cc drivers/platform/x86/intel_pmc_core_pltdrv.c
index 6fe829f30997,731281855cc8..000000000000
--- a/drivers/platform/x86/intel_pmc_core_pltdrv.c
+++ b/drivers/platform/x86/intel_pmc_core_pltdrv.c
@@@ -38,12 -38,14 +38,23 @@@ static struct platform_device pmc_core_
   * other list may grow, but this list should not.
   */
  static const struct x86_cpu_id intel_pmc_core_platform_ids[] = {
++<<<<<<< HEAD
 +	INTEL_CPU_FAM6(SKYLAKE_L, pmc_core_device),
 +	INTEL_CPU_FAM6(SKYLAKE, pmc_core_device),
 +	INTEL_CPU_FAM6(KABYLAKE_L, pmc_core_device),
 +	INTEL_CPU_FAM6(KABYLAKE, pmc_core_device),
 +	INTEL_CPU_FAM6(CANNONLAKE_L, pmc_core_device),
 +	INTEL_CPU_FAM6(ICELAKE_L, pmc_core_device),
++=======
+ 	X86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_L,		&pmc_core_device),
+ 	X86_MATCH_INTEL_FAM6_MODEL(SKYLAKE,		&pmc_core_device),
+ 	X86_MATCH_INTEL_FAM6_MODEL(KABYLAKE_L,		&pmc_core_device),
+ 	X86_MATCH_INTEL_FAM6_MODEL(KABYLAKE,		&pmc_core_device),
+ 	X86_MATCH_INTEL_FAM6_MODEL(CANNONLAKE_L,	&pmc_core_device),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_L,		&pmc_core_device),
+ 	X86_MATCH_INTEL_FAM6_MODEL(COMETLAKE,		&pmc_core_device),
+ 	X86_MATCH_INTEL_FAM6_MODEL(COMETLAKE_L,		&pmc_core_device),
++>>>>>>> a69b3b1d4cf0 (platform/x86: Convert to new CPU match macros)
  	{}
  };
  MODULE_DEVICE_TABLE(x86cpu, intel_pmc_core_platform_ids);
diff --cc drivers/platform/x86/intel_telemetry_debugfs.c
index cee08f236292,8a53d3b485b3..000000000000
--- a/drivers/platform/x86/intel_telemetry_debugfs.c
+++ b/drivers/platform/x86/intel_telemetry_debugfs.c
@@@ -319,11 -308,10 +319,15 @@@ static struct telemetry_debugfs_conf te
  };
  
  static const struct x86_cpu_id telemetry_debugfs_cpu_ids[] = {
++<<<<<<< HEAD
 +	TELEM_DEBUGFS_CPU(INTEL_FAM6_ATOM_GOLDMONT, telem_apl_debugfs_conf),
 +	TELEM_DEBUGFS_CPU(INTEL_FAM6_ATOM_GOLDMONT_PLUS, telem_apl_debugfs_conf),
++=======
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT,	&telem_apl_debugfs_conf),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT_PLUS,	&telem_apl_debugfs_conf),
++>>>>>>> a69b3b1d4cf0 (platform/x86: Convert to new CPU match macros)
  	{}
  };
- 
  MODULE_DEVICE_TABLE(x86cpu, telemetry_debugfs_cpu_ids);
  
  static int telemetry_debugfs_check_evts(void)
* Unmerged path drivers/platform/x86/intel-uncore-frequency.c
* Unmerged path drivers/platform/x86/intel-uncore-frequency.c
* Unmerged path drivers/platform/x86/intel_int0002_vgpio.c
* Unmerged path drivers/platform/x86/intel_mid_powerbtn.c
* Unmerged path drivers/platform/x86/intel_pmc_core.c
* Unmerged path drivers/platform/x86/intel_pmc_core_pltdrv.c
diff --git a/drivers/platform/x86/intel_speed_select_if/isst_if_mbox_msr.c b/drivers/platform/x86/intel_speed_select_if/isst_if_mbox_msr.c
index 89b042aecef3..1b6eab071068 100644
--- a/drivers/platform/x86/intel_speed_select_if/isst_if_mbox_msr.c
+++ b/drivers/platform/x86/intel_speed_select_if/isst_if_mbox_msr.c
@@ -160,10 +160,8 @@ static struct notifier_block isst_pm_nb = {
 	.notifier_call = isst_pm_notify,
 };
 
-#define ICPU(model)     { X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, }
-
 static const struct x86_cpu_id isst_if_cpu_ids[] = {
-	ICPU(INTEL_FAM6_SKYLAKE_X),
+	X86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_X, NULL),
 	{}
 };
 MODULE_DEVICE_TABLE(x86cpu, isst_if_cpu_ids);
* Unmerged path drivers/platform/x86/intel_telemetry_debugfs.c
diff --git a/drivers/platform/x86/intel_telemetry_pltdrv.c b/drivers/platform/x86/intel_telemetry_pltdrv.c
index fcc6bee51a42..7ffc79a8d0e6 100644
--- a/drivers/platform/x86/intel_telemetry_pltdrv.c
+++ b/drivers/platform/x86/intel_telemetry_pltdrv.c
@@ -75,9 +75,6 @@
 #define TELEM_CLEAR_VERBOSITY_BITS(x)	((x) &= ~(BIT(27) | BIT(28)))
 #define TELEM_SET_VERBOSITY_BITS(x, y)	((x) |= ((y) << 27))
 
-#define TELEM_CPU(model, data) \
-	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, (unsigned long)&data }
-
 enum telemetry_action {
 	TELEM_UPDATE = 0,
 	TELEM_ADD,
@@ -191,8 +188,8 @@ static struct telemetry_plt_config telem_glk_config = {
 };
 
 static const struct x86_cpu_id telemetry_cpu_ids[] = {
-	TELEM_CPU(INTEL_FAM6_ATOM_GOLDMONT, telem_apl_config),
-	TELEM_CPU(INTEL_FAM6_ATOM_GOLDMONT_PLUS, telem_glk_config),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT,	&telem_apl_config),
+	X86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT_PLUS,	&telem_glk_config),
 	{}
 };
 
diff --git a/drivers/platform/x86/intel_turbo_max_3.c b/drivers/platform/x86/intel_turbo_max_3.c
index a6d5aa0c3c47..49f302da5c9c 100644
--- a/drivers/platform/x86/intel_turbo_max_3.c
+++ b/drivers/platform/x86/intel_turbo_max_3.c
@@ -121,11 +121,9 @@ static int itmt_legacy_cpu_online(unsigned int cpu)
 	return 0;
 }
 
-#define ICPU(model)     { X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, }
-
 static const struct x86_cpu_id itmt_legacy_cpu_ids[] = {
-	ICPU(INTEL_FAM6_BROADWELL_X),
-	ICPU(INTEL_FAM6_SKYLAKE_X),
+	X86_MATCH_INTEL_FAM6_MODEL(BROADWELL_X,	NULL),
+	X86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_X,	NULL),
 	{}
 };
 
