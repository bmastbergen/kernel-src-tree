drm/i915: split intel_modeset_init() to pre/post irq install

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jani Nikula <jani.nikula@intel.com>
commit 80f286a552c6cc554199a7d14b76836cffabd451
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/80f286a5.failed

Split inte_modeset_init() to parts before and after irq install, to
facilitate further cleanup. The error paths are a mess, otherwise no
functional changes.

	Cc: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Reviewed-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200224120828.22105-1-jani.nikula@intel.com
(cherry picked from commit 80f286a552c6cc554199a7d14b76836cffabd451)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display.c
#	drivers/gpu/drm/i915/display/intel_display.h
#	drivers/gpu/drm/i915/i915_drv.c
diff --cc drivers/gpu/drm/i915/display/intel_display.c
index 5c8c11deb857,aaf2366d653f..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@@ -15998,42 -17730,109 +15998,100 @@@ int intel_modeset_init(struct drm_devic
  	 * Maximum framebuffer dimensions, chosen to match
  	 * the maximum render engine surface size on gen4+.
  	 */
 -	if (INTEL_GEN(i915) >= 7) {
 -		mode_config->max_width = 16384;
 -		mode_config->max_height = 16384;
 -	} else if (INTEL_GEN(i915) >= 4) {
 -		mode_config->max_width = 8192;
 -		mode_config->max_height = 8192;
 -	} else if (IS_GEN(i915, 3)) {
 -		mode_config->max_width = 4096;
 -		mode_config->max_height = 4096;
 +	if (INTEL_GEN(dev_priv) >= 7) {
 +		dev->mode_config.max_width = 16384;
 +		dev->mode_config.max_height = 16384;
 +	} else if (INTEL_GEN(dev_priv) >= 4) {
 +		dev->mode_config.max_width = 8192;
 +		dev->mode_config.max_height = 8192;
 +	} else if (IS_GEN(dev_priv, 3)) {
 +		dev->mode_config.max_width = 4096;
 +		dev->mode_config.max_height = 4096;
  	} else {
 -		mode_config->max_width = 2048;
 -		mode_config->max_height = 2048;
 +		dev->mode_config.max_width = 2048;
 +		dev->mode_config.max_height = 2048;
  	}
  
 -	if (IS_I845G(i915) || IS_I865G(i915)) {
 -		mode_config->cursor_width = IS_I845G(i915) ? 64 : 512;
 -		mode_config->cursor_height = 1023;
 -	} else if (IS_GEN(i915, 2)) {
 -		mode_config->cursor_width = 64;
 -		mode_config->cursor_height = 64;
 +	if (IS_I845G(dev_priv) || IS_I865G(dev_priv)) {
 +		dev->mode_config.cursor_width = IS_I845G(dev_priv) ? 64 : 512;
 +		dev->mode_config.cursor_height = 1023;
 +	} else if (IS_GEN(dev_priv, 2)) {
 +		dev->mode_config.cursor_width = 64;
 +		dev->mode_config.cursor_height = 64;
  	} else {
 -		mode_config->cursor_width = 256;
 -		mode_config->cursor_height = 256;
 +		dev->mode_config.cursor_width = 256;
 +		dev->mode_config.cursor_height = 256;
  	}
 -}
 -
 -static void intel_mode_config_cleanup(struct drm_i915_private *i915)
 -{
 -	intel_atomic_global_obj_cleanup(i915);
 -	drm_mode_config_cleanup(&i915->drm);
 -}
  
 -static void plane_config_fini(struct intel_initial_plane_config *plane_config)
 -{
 -	if (plane_config->fb) {
 -		struct drm_framebuffer *fb = &plane_config->fb->base;
 -
 -		/* We may only have the stub and not a full framebuffer */
 -		if (drm_framebuffer_read_refcount(fb))
 -			drm_framebuffer_put(fb);
 -		else
 -			kfree(fb);
 -	}
 +	dev->mode_config.fb_base = ggtt->gmadr.start;
  
 -	if (plane_config->vma)
 -		i915_vma_put(plane_config->vma);
 -}
++<<<<<<< HEAD
 +	DRM_DEBUG_KMS("%d display pipe%s available.\n",
 +		      INTEL_INFO(dev_priv)->num_pipes,
 +		      INTEL_INFO(dev_priv)->num_pipes > 1 ? "s" : "");
  
 +	for_each_pipe(dev_priv, pipe) {
 +		ret = intel_crtc_init(dev_priv, pipe);
 +		if (ret) {
 +			drm_mode_config_cleanup(dev);
 +			return ret;
++=======
+ /* part #1: call before irq install */
+ int intel_modeset_init_noirq(struct drm_i915_private *i915)
+ {
+ 	int ret;
+ 
+ 	i915->modeset_wq = alloc_ordered_workqueue("i915_modeset", 0);
+ 	i915->flip_wq = alloc_workqueue("i915_flip", WQ_HIGHPRI |
+ 					WQ_UNBOUND, WQ_UNBOUND_MAX_ACTIVE);
+ 
+ 	intel_mode_config_init(i915);
+ 
+ 	ret = intel_cdclk_init(i915);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = intel_bw_init(i915);
+ 	if (ret)
+ 		return ret;
+ 
+ 	init_llist_head(&i915->atomic_helper.free_list);
+ 	INIT_WORK(&i915->atomic_helper.free_work,
+ 		  intel_atomic_helper_free_state_worker);
+ 
+ 	intel_init_quirks(i915);
+ 
+ 	intel_fbc_init(i915);
+ 
+ 	return 0;
+ }
+ 
+ /* part #2: call after irq install */
+ int intel_modeset_init(struct drm_i915_private *i915)
+ {
+ 	struct drm_device *dev = &i915->drm;
+ 	enum pipe pipe;
+ 	struct intel_crtc *crtc;
+ 	int ret;
+ 
+ 	intel_init_pm(i915);
+ 
+ 	intel_panel_sanitize_ssc(i915);
+ 
+ 	intel_gmbus_setup(i915);
+ 
+ 	drm_dbg_kms(&i915->drm, "%d display pipe%s available.\n",
+ 		    INTEL_NUM_PIPES(i915),
+ 		    INTEL_NUM_PIPES(i915) > 1 ? "s" : "");
+ 
+ 	if (HAS_DISPLAY(i915) && INTEL_DISPLAY_ENABLED(i915)) {
+ 		for_each_pipe(i915, pipe) {
+ 			ret = intel_crtc_init(i915, pipe);
+ 			if (ret) {
+ 				intel_mode_config_cleanup(i915);
+ 				return ret;
+ 			}
++>>>>>>> 80f286a552c6 (drm/i915: split intel_modeset_init() to pre/post irq install)
  		}
  	}
  
diff --cc drivers/gpu/drm/i915/display/intel_display.h
index 868914c6d9b5,8f994244ccc7..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.h
+++ b/drivers/gpu/drm/i915/display/intel_display.h
@@@ -357,5 -482,180 +357,183 @@@ void lpt_disable_clkout_dp(struct drm_i
  u32 intel_plane_fb_max_stride(struct drm_i915_private *dev_priv,
  			      u32 pixel_format, u64 modifier);
  bool intel_plane_can_remap(const struct intel_plane_state *plane_state);
++<<<<<<< HEAD
++=======
+ enum drm_mode_status
+ intel_mode_valid_max_plane_size(struct drm_i915_private *dev_priv,
+ 				const struct drm_display_mode *mode);
+ enum phy intel_port_to_phy(struct drm_i915_private *i915, enum port port);
+ bool is_trans_port_sync_mode(const struct intel_crtc_state *state);
+ 
+ void intel_plane_destroy(struct drm_plane *plane);
+ void intel_enable_pipe(const struct intel_crtc_state *new_crtc_state);
+ void intel_disable_pipe(const struct intel_crtc_state *old_crtc_state);
+ void i830_enable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe);
+ void i830_disable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe);
+ enum pipe intel_crtc_pch_transcoder(struct intel_crtc *crtc);
+ int vlv_get_hpll_vco(struct drm_i915_private *dev_priv);
+ int vlv_get_cck_clock(struct drm_i915_private *dev_priv,
+ 		      const char *name, u32 reg, int ref_freq);
+ int vlv_get_cck_clock_hpll(struct drm_i915_private *dev_priv,
+ 			   const char *name, u32 reg);
+ void lpt_pch_enable(const struct intel_crtc_state *crtc_state);
+ void lpt_disable_pch_transcoder(struct drm_i915_private *dev_priv);
+ void lpt_disable_iclkip(struct drm_i915_private *dev_priv);
+ void intel_init_display_hooks(struct drm_i915_private *dev_priv);
+ unsigned int intel_fb_xy_to_linear(int x, int y,
+ 				   const struct intel_plane_state *state,
+ 				   int plane);
+ unsigned int intel_fb_align_height(const struct drm_framebuffer *fb,
+ 				   int color_plane, unsigned int height);
+ void intel_add_fb_offsets(int *x, int *y,
+ 			  const struct intel_plane_state *state, int plane);
+ unsigned int intel_rotation_info_size(const struct intel_rotation_info *rot_info);
+ unsigned int intel_remapped_info_size(const struct intel_remapped_info *rem_info);
+ bool intel_has_pending_fb_unpin(struct drm_i915_private *dev_priv);
+ int intel_display_suspend(struct drm_device *dev);
+ void intel_pps_unlock_regs_wa(struct drm_i915_private *dev_priv);
+ void intel_encoder_destroy(struct drm_encoder *encoder);
+ struct drm_display_mode *
+ intel_encoder_current_mode(struct intel_encoder *encoder);
+ bool intel_phy_is_combo(struct drm_i915_private *dev_priv, enum phy phy);
+ bool intel_phy_is_tc(struct drm_i915_private *dev_priv, enum phy phy);
+ enum tc_port intel_port_to_tc(struct drm_i915_private *dev_priv,
+ 			      enum port port);
+ int intel_get_pipe_from_crtc_id_ioctl(struct drm_device *dev, void *data,
+ 				      struct drm_file *file_priv);
+ u32 intel_crtc_get_vblank_counter(struct intel_crtc *crtc);
+ void intel_crtc_vblank_on(const struct intel_crtc_state *crtc_state);
+ void intel_crtc_vblank_off(const struct intel_crtc_state *crtc_state);
+ 
+ int ilk_get_lanes_required(int target_clock, int link_bw, int bpp);
+ void vlv_wait_port_ready(struct drm_i915_private *dev_priv,
+ 			 struct intel_digital_port *dport,
+ 			 unsigned int expected_mask);
+ int intel_get_load_detect_pipe(struct drm_connector *connector,
+ 			       struct intel_load_detect_pipe *old,
+ 			       struct drm_modeset_acquire_ctx *ctx);
+ void intel_release_load_detect_pipe(struct drm_connector *connector,
+ 				    struct intel_load_detect_pipe *old,
+ 				    struct drm_modeset_acquire_ctx *ctx);
+ struct i915_vma *
+ intel_pin_and_fence_fb_obj(struct drm_framebuffer *fb,
+ 			   const struct i915_ggtt_view *view,
+ 			   bool uses_fence,
+ 			   unsigned long *out_flags);
+ void intel_unpin_fb_vma(struct i915_vma *vma, unsigned long flags);
+ struct drm_framebuffer *
+ intel_framebuffer_create(struct drm_i915_gem_object *obj,
+ 			 struct drm_mode_fb_cmd2 *mode_cmd);
+ int intel_prepare_plane_fb(struct drm_plane *plane,
+ 			   struct drm_plane_state *new_state);
+ void intel_cleanup_plane_fb(struct drm_plane *plane,
+ 			    struct drm_plane_state *old_state);
+ 
+ void assert_pch_transcoder_disabled(struct drm_i915_private *dev_priv,
+ 				    enum pipe pipe);
+ 
+ int vlv_force_pll_on(struct drm_i915_private *dev_priv, enum pipe pipe,
+ 		     const struct dpll *dpll);
+ void vlv_force_pll_off(struct drm_i915_private *dev_priv, enum pipe pipe);
+ int lpt_get_iclkip(struct drm_i915_private *dev_priv);
+ bool intel_fuzzy_clock_check(int clock1, int clock2);
+ 
+ void intel_prepare_reset(struct drm_i915_private *dev_priv);
+ void intel_finish_reset(struct drm_i915_private *dev_priv);
+ void intel_dp_get_m_n(struct intel_crtc *crtc,
+ 		      struct intel_crtc_state *pipe_config);
+ void intel_dp_set_m_n(const struct intel_crtc_state *crtc_state,
+ 		      enum link_m_n_set m_n);
+ int intel_dotclock_calculate(int link_freq, const struct intel_link_m_n *m_n);
+ bool bxt_find_best_dpll(struct intel_crtc_state *crtc_state,
+ 			struct dpll *best_clock);
+ int chv_calc_dpll_params(int refclk, struct dpll *pll_clock);
+ 
+ bool hsw_crtc_state_ips_capable(const struct intel_crtc_state *crtc_state);
+ void hsw_enable_ips(const struct intel_crtc_state *crtc_state);
+ void hsw_disable_ips(const struct intel_crtc_state *crtc_state);
+ enum intel_display_power_domain intel_port_to_power_domain(enum port port);
+ enum intel_display_power_domain
+ intel_aux_power_domain(struct intel_digital_port *dig_port);
+ void intel_mode_from_pipe_config(struct drm_display_mode *mode,
+ 				 struct intel_crtc_state *pipe_config);
+ void intel_crtc_arm_fifo_underrun(struct intel_crtc *crtc,
+ 				  struct intel_crtc_state *crtc_state);
+ 
+ u16 skl_scaler_calc_phase(int sub, int scale, bool chroma_center);
+ int skl_update_scaler_crtc(struct intel_crtc_state *crtc_state);
+ void skl_scaler_disable(const struct intel_crtc_state *old_crtc_state);
+ void ilk_pfit_disable(const struct intel_crtc_state *old_crtc_state);
+ u32 glk_plane_color_ctl(const struct intel_crtc_state *crtc_state,
+ 			const struct intel_plane_state *plane_state);
+ u32 glk_plane_color_ctl_crtc(const struct intel_crtc_state *crtc_state);
+ u32 skl_plane_ctl(const struct intel_crtc_state *crtc_state,
+ 		  const struct intel_plane_state *plane_state);
+ u32 skl_plane_ctl_crtc(const struct intel_crtc_state *crtc_state);
+ u32 skl_plane_stride(const struct intel_plane_state *plane_state,
+ 		     int plane);
+ int skl_check_plane_surface(struct intel_plane_state *plane_state);
+ int i9xx_check_plane_surface(struct intel_plane_state *plane_state);
+ int skl_format_to_fourcc(int format, bool rgb_order, bool alpha);
+ unsigned int i9xx_plane_max_stride(struct intel_plane *plane,
+ 				   u32 pixel_format, u64 modifier,
+ 				   unsigned int rotation);
+ int bdw_get_pipemisc_bpp(struct intel_crtc *crtc);
+ 
+ struct intel_display_error_state *
+ intel_display_capture_error_state(struct drm_i915_private *dev_priv);
+ void intel_display_print_error_state(struct drm_i915_error_state_buf *e,
+ 				     struct intel_display_error_state *error);
+ 
+ bool
+ intel_format_info_is_yuv_semiplanar(const struct drm_format_info *info,
+ 				    uint64_t modifier);
+ 
+ /* modesetting */
+ void intel_modeset_init_hw(struct drm_i915_private *i915);
+ int intel_modeset_init_noirq(struct drm_i915_private *i915);
+ int intel_modeset_init(struct drm_i915_private *i915);
+ void intel_modeset_driver_remove(struct drm_i915_private *i915);
+ void intel_modeset_driver_remove_noirq(struct drm_i915_private *i915);
+ void intel_display_resume(struct drm_device *dev);
+ void intel_init_pch_refclk(struct drm_i915_private *dev_priv);
+ 
+ /* modesetting asserts */
+ void assert_panel_unlocked(struct drm_i915_private *dev_priv,
+ 			   enum pipe pipe);
+ void assert_pll(struct drm_i915_private *dev_priv,
+ 		enum pipe pipe, bool state);
+ #define assert_pll_enabled(d, p) assert_pll(d, p, true)
+ #define assert_pll_disabled(d, p) assert_pll(d, p, false)
+ void assert_dsi_pll(struct drm_i915_private *dev_priv, bool state);
+ #define assert_dsi_pll_enabled(d) assert_dsi_pll(d, true)
+ #define assert_dsi_pll_disabled(d) assert_dsi_pll(d, false)
+ void assert_fdi_rx_pll(struct drm_i915_private *dev_priv,
+ 		       enum pipe pipe, bool state);
+ #define assert_fdi_rx_pll_enabled(d, p) assert_fdi_rx_pll(d, p, true)
+ #define assert_fdi_rx_pll_disabled(d, p) assert_fdi_rx_pll(d, p, false)
+ void assert_pipe(struct drm_i915_private *dev_priv,
+ 		 enum transcoder cpu_transcoder, bool state);
+ #define assert_pipe_enabled(d, t) assert_pipe(d, t, true)
+ #define assert_pipe_disabled(d, t) assert_pipe(d, t, false)
+ 
+ /* Use I915_STATE_WARN(x) and I915_STATE_WARN_ON() (rather than WARN() and
+  * WARN_ON()) for hw state sanity checks to check for unexpected conditions
+  * which may not necessarily be a user visible problem.  This will either
+  * WARN() or DRM_ERROR() depending on the verbose_checks moduleparam, to
+  * enable distros and users to tailor their preferred amount of i915 abrt
+  * spam.
+  */
+ #define I915_STATE_WARN(condition, format...) ({			\
+ 	int __ret_warn_on = !!(condition);				\
+ 	if (unlikely(__ret_warn_on))					\
+ 		if (!WARN(i915_modparams.verbose_state_checks, format))	\
+ 			DRM_ERROR(format);				\
+ 	unlikely(__ret_warn_on);					\
+ })
+ 
+ #define I915_STATE_WARN_ON(x)						\
+ 	I915_STATE_WARN((x), "%s", "WARN_ON(" __stringify(x) ")")
++>>>>>>> 80f286a552c6 (drm/i915: split intel_modeset_init() to pre/post irq install)
  
  #endif
diff --cc drivers/gpu/drm/i915/i915_drv.c
index 1aa474313525,a87b28ee2d90..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@@ -695,34 -228,32 +695,48 @@@ static int i915_load_modeset_init(struc
  			goto out;
  	}
  
 -	intel_bios_init(i915);
 +	intel_bios_init(dev_priv);
  
 -	ret = intel_vga_register(i915);
 -	if (ret)
 +	/* If we have > 1 VGA cards, then we need to arbitrate access
 +	 * to the common VGA resources.
 +	 *
 +	 * If we are a secondary display controller (!PCI_DISPLAY_CLASS_VGA),
 +	 * then we do not take part in VGA arbitration and the
 +	 * vga_client_register() fails with -ENODEV.
 +	 */
 +	ret = vga_client_register(pdev, dev_priv, NULL, i915_vga_set_decode);
 +	if (ret && ret != -ENODEV)
  		goto out;
  
 -	intel_power_domains_init_hw(i915, false);
 +	intel_register_dsm_handler();
 +
 +	ret = vga_switcheroo_register_client(pdev, &i915_switcheroo_ops, false);
 +	if (ret)
 +		goto cleanup_vga_client;
  
 -	intel_csr_ucode_init(i915);
++<<<<<<< HEAD
 +	intel_power_domains_init_hw(dev_priv, false);
  
 +	intel_csr_ucode_init(dev_priv);
++=======
+ 	ret = intel_modeset_init_noirq(i915);
+ 	if (ret)
+ 		goto cleanup_vga_client;
+ 
+ 	return 0;
+ 
+ cleanup_vga_client:
+ 	intel_vga_unregister(i915);
+ out:
+ 	return ret;
+ }
++>>>>>>> 80f286a552c6 (drm/i915: split intel_modeset_init() to pre/post irq install)
  
 -/* part #2: call after irq install */
 -static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 -{
 -	int ret;
 +	ret = intel_irq_install(dev_priv);
 +	if (ret)
 +		goto cleanup_csr;
 +
 +	intel_gmbus_setup(dev_priv);
  
  	/* Important: The output setup functions called by modeset_init need
  	 * working irqs for e.g. gmbus and dp aux transfers. */
* Unmerged path drivers/gpu/drm/i915/display/intel_display.c
* Unmerged path drivers/gpu/drm/i915/display/intel_display.h
* Unmerged path drivers/gpu/drm/i915/i915_drv.c
