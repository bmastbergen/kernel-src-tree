ASoC: SOF: Intel: hda: Improve DSP state logging

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: SOF: Intel: hda: Improve DSP state logging (Jaroslav Kysela) [1797509]
Rebuild_FUZZ: 94.12%
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit 66de6beb933d373224f350834fbab68093d24627
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/66de6beb.failed

Improve the DSP power state logs with the state names
instead of values.

	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Link: https://lore.kernel.org/r/20200325211233.27394-2-pierre-louis.bossart@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 66de6beb933d373224f350834fbab68093d24627)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/intel/hda-dsp.c
diff --cc sound/soc/sof/intel/hda-dsp.c
index fddf2c48904f,c396b7ef0328..000000000000
--- a/sound/soc/sof/intel/hda-dsp.c
+++ b/sound/soc/sof/intel/hda-dsp.c
@@@ -381,6 -452,139 +381,142 @@@ int hda_dsp_set_power_state(struct snd_
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /* helper to log DSP state */
+ static void hda_dsp_state_log(struct snd_sof_dev *sdev)
+ {
+ 	switch (sdev->dsp_power_state.state) {
+ 	case SOF_DSP_PM_D0:
+ 		switch (sdev->dsp_power_state.substate) {
+ 		case SOF_HDA_DSP_PM_D0I0:
+ 			dev_dbg(sdev->dev, "Current DSP power state: D0I0\n");
+ 			break;
+ 		case SOF_HDA_DSP_PM_D0I3:
+ 			dev_dbg(sdev->dev, "Current DSP power state: D0I3\n");
+ 			break;
+ 		default:
+ 			dev_dbg(sdev->dev, "Unknown DSP D0 substate: %d\n",
+ 				sdev->dsp_power_state.substate);
+ 			break;
+ 		}
+ 		break;
+ 	case SOF_DSP_PM_D1:
+ 		dev_dbg(sdev->dev, "Current DSP power state: D1\n");
+ 		break;
+ 	case SOF_DSP_PM_D2:
+ 		dev_dbg(sdev->dev, "Current DSP power state: D2\n");
+ 		break;
+ 	case SOF_DSP_PM_D3_HOT:
+ 		dev_dbg(sdev->dev, "Current DSP power state: D3_HOT\n");
+ 		break;
+ 	case SOF_DSP_PM_D3:
+ 		dev_dbg(sdev->dev, "Current DSP power state: D3\n");
+ 		break;
+ 	case SOF_DSP_PM_D3_COLD:
+ 		dev_dbg(sdev->dev, "Current DSP power state: D3_COLD\n");
+ 		break;
+ 	default:
+ 		dev_dbg(sdev->dev, "Unknown DSP power state: %d\n",
+ 			sdev->dsp_power_state.state);
+ 		break;
+ 	}
+ }
+ 
+ /*
+  * All DSP power state transitions are initiated by the driver.
+  * If the requested state change fails, the error is simply returned.
+  * Further state transitions are attempted only when the set_power_save() op
+  * is called again either because of a new IPC sent to the DSP or
+  * during system suspend/resume.
+  */
+ int hda_dsp_set_power_state(struct snd_sof_dev *sdev,
+ 			    const struct sof_dsp_power_state *target_state)
+ {
+ 	int ret = 0;
+ 
+ 	/*
+ 	 * When the DSP is already in D0I3 and the target state is D0I3,
+ 	 * it could be the case that the DSP is in D0I3 during S0
+ 	 * and the system is suspending to S0Ix. Therefore,
+ 	 * hda_dsp_set_D0_state() must be called to disable trace DMA
+ 	 * by sending the PM_GATE IPC to the FW.
+ 	 */
+ 	if (target_state->substate == SOF_HDA_DSP_PM_D0I3 &&
+ 	    sdev->system_suspend_target == SOF_SUSPEND_S0IX)
+ 		goto set_state;
+ 
+ 	/*
+ 	 * For all other cases, return without doing anything if
+ 	 * the DSP is already in the target state.
+ 	 */
+ 	if (target_state->state == sdev->dsp_power_state.state &&
+ 	    target_state->substate == sdev->dsp_power_state.substate)
+ 		return 0;
+ 
+ set_state:
+ 	switch (target_state->state) {
+ 	case SOF_DSP_PM_D0:
+ 		ret = hda_dsp_set_D0_state(sdev, target_state);
+ 		break;
+ 	case SOF_DSP_PM_D3:
+ 		/* The only allowed transition is: D0I0 -> D3 */
+ 		if (sdev->dsp_power_state.state == SOF_DSP_PM_D0 &&
+ 		    sdev->dsp_power_state.substate == SOF_HDA_DSP_PM_D0I0)
+ 			break;
+ 
+ 		dev_err(sdev->dev,
+ 			"error: transition from %d to %d not allowed\n",
+ 			sdev->dsp_power_state.state, target_state->state);
+ 		return -EINVAL;
+ 	default:
+ 		dev_err(sdev->dev, "error: target state unsupported %d\n",
+ 			target_state->state);
+ 		return -EINVAL;
+ 	}
+ 	if (ret < 0) {
+ 		dev_err(sdev->dev,
+ 			"failed to set requested target DSP state %d substate %d\n",
+ 			target_state->state, target_state->substate);
+ 		return ret;
+ 	}
+ 
+ 	sdev->dsp_power_state = *target_state;
+ 	hda_dsp_state_log(sdev);
+ 	return ret;
+ }
+ 
+ /*
+  * Audio DSP states may transform as below:-
+  *
+  *                                         Opportunistic D0I3 in S0
+  *     Runtime    +---------------------+  Delayed D0i3 work timeout
+  *     suspend    |                     +--------------------+
+  *   +------------+       D0I0(active)  |                    |
+  *   |            |                     <---------------+    |
+  *   |   +-------->                     |    New IPC	|    |
+  *   |   |Runtime +--^--+---------^--+--+ (via mailbox)	|    |
+  *   |   |resume     |  |         |  |			|    |
+  *   |   |           |  |         |  |			|    |
+  *   |   |     System|  |         |  |			|    |
+  *   |   |     resume|  | S3/S0IX |  |                  |    |
+  *   |   |	     |  | suspend |  | S0IX             |    |
+  *   |   |           |  |         |  |suspend           |    |
+  *   |   |           |  |         |  |                  |    |
+  *   |   |           |  |         |  |                  |    |
+  * +-v---+-----------+--v-------+ |  |           +------+----v----+
+  * |                            | |  +----------->                |
+  * |       D3 (suspended)       | |              |      D0I3      |
+  * |                            | +--------------+                |
+  * |                            |  System resume |                |
+  * +----------------------------+		 +----------------+
+  *
+  * S0IX suspend: The DSP is in D0I3 if any D0I3-compatible streams
+  *		 ignored the suspend trigger. Otherwise the DSP
+  *		 is in D3.
+  */
+ 
++>>>>>>> 66de6beb933d (ASoC: SOF: Intel: hda: Improve DSP state logging)
  static int hda_suspend(struct snd_sof_dev *sdev, bool runtime_suspend)
  {
  	struct sof_intel_hda_dev *hda = sdev->pdata->hw_pdata;
* Unmerged path sound/soc/sof/intel/hda-dsp.c
