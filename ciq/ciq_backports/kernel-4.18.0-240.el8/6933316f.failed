KVM: s390: add new variants of UV CALL

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Janosch Frank <frankja@linux.ibm.com>
commit 6933316fe011d5875b360ea8b7404a6612846740
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6933316f.failed

This adds two new helper functions for doing UV CALLs.

The first variant handles UV CALLs that might have longer busy
conditions or just need longer when doing partial completion. We should
schedule when necessary.

The second variant handles UV CALLs that only need the handle but have
no payload (e.g. destroying a VM). We can provide a simple wrapper for
those.

	Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
	Reviewed-by: Thomas Huth <thuth@redhat.com>
	Reviewed-by: Cornelia Huck <cohuck@redhat.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
[borntraeger@de.ibm.com: patch merging, splitting, fixing]
	Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
(cherry picked from commit 6933316fe011d5875b360ea8b7404a6612846740)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/uv.h
diff --cc arch/s390/include/asm/uv.h
index 4093a2856929,d7aa91c89f6c..000000000000
--- a/arch/s390/include/asm/uv.h
+++ b/arch/s390/include/asm/uv.h
@@@ -14,7 -14,9 +14,8 @@@
  #include <linux/types.h>
  #include <linux/errno.h>
  #include <linux/bug.h>
+ #include <linux/sched.h>
  #include <asm/page.h>
 -#include <asm/gmap.h>
  
  #define UVC_RC_EXECUTED		0x0001
  #define UVC_RC_INV_CMD		0x0002
@@@ -44,9 -56,55 +45,22 @@@ struct uv_cb_qui 
  	struct uv_cb_header header;
  	u64 reserved08;
  	u64 inst_calls_list[4];
 -	u64 reserved30[2];
 -	u64 uv_base_stor_len;
 -	u64 reserved48;
 -	u64 conf_base_phys_stor_len;
 -	u64 conf_base_virt_stor_len;
 -	u64 conf_virt_var_stor_len;
 -	u64 cpu_stor_len;
 -	u32 reserved70[3];
 -	u32 max_num_sec_conf;
 -	u64 max_guest_stor_addr;
 -	u8  reserved88[158 - 136];
 -	u16 max_guest_cpus;
 -	u8  reserveda0[200 - 160];
 -} __packed __aligned(8);
 -
 -struct uv_cb_init {
 -	struct uv_cb_header header;
 -	u64 reserved08[2];
 -	u64 stor_origin;
 -	u64 stor_len;
 -	u64 reserved28[4];
 -} __packed __aligned(8);
 -
 -struct uv_cb_cts {
 -	struct uv_cb_header header;
 -	u64 reserved08[2];
 -	u64 guest_handle;
 -	u64 gaddr;
 -} __packed __aligned(8);
 -
 -struct uv_cb_cfs {
 -	struct uv_cb_header header;
 -	u64 reserved08[2];
 -	u64 paddr;
 +	u64 reserved30[15];
  } __packed __aligned(8);
  
+ /*
+  * A common UV call struct for calls that take no payload
+  * Examples:
+  * Destroy cpu/config
+  * Verify
+  */
+ struct uv_cb_nodata {
+ 	struct uv_cb_header header;
+ 	u64 reserved08[2];
+ 	u64 handle;
+ 	u64 reserved20[4];
+ } __packed __aligned(8);
+ 
  struct uv_cb_share {
  	struct uv_cb_header header;
  	u64 reserved08[3];
@@@ -69,6 -126,62 +82,65 @@@ static inline int __uv_call(unsigned lo
  	return cc;
  }
  
++<<<<<<< HEAD
++=======
+ static inline int uv_call(unsigned long r1, unsigned long r2)
+ {
+ 	int cc;
+ 
+ 	do {
+ 		cc = __uv_call(r1, r2);
+ 	} while (cc > 1);
+ 	return cc;
+ }
+ 
+ /* Low level uv_call that avoids stalls for long running busy conditions  */
+ static inline int uv_call_sched(unsigned long r1, unsigned long r2)
+ {
+ 	int cc;
+ 
+ 	do {
+ 		cc = __uv_call(r1, r2);
+ 		cond_resched();
+ 	} while (cc > 1);
+ 	return cc;
+ }
+ 
+ /*
+  * special variant of uv_call that only transports the cpu or guest
+  * handle and the command, like destroy or verify.
+  */
+ static inline int uv_cmd_nodata(u64 handle, u16 cmd, u16 *rc, u16 *rrc)
+ {
+ 	struct uv_cb_nodata uvcb = {
+ 		.header.cmd = cmd,
+ 		.header.len = sizeof(uvcb),
+ 		.handle = handle,
+ 	};
+ 	int cc;
+ 
+ 	WARN(!handle, "No handle provided to Ultravisor call cmd %x\n", cmd);
+ 	cc = uv_call_sched(0, (u64)&uvcb);
+ 	*rc = uvcb.header.rc;
+ 	*rrc = uvcb.header.rrc;
+ 	return cc ? -EINVAL : 0;
+ }
+ 
+ struct uv_info {
+ 	unsigned long inst_calls_list[4];
+ 	unsigned long uv_base_stor_len;
+ 	unsigned long guest_base_stor_len;
+ 	unsigned long guest_virt_base_stor_len;
+ 	unsigned long guest_virt_var_stor_len;
+ 	unsigned long guest_cpu_stor_len;
+ 	unsigned long max_sec_stor_addr;
+ 	unsigned int max_num_sec_conf;
+ 	unsigned short max_guest_cpus;
+ };
+ 
+ extern struct uv_info uv_info;
+ 
++>>>>>>> 6933316fe011 (KVM: s390: add new variants of UV CALL)
  #ifdef CONFIG_PROTECTED_VIRTUALIZATION_GUEST
  extern int prot_virt_guest;
  
* Unmerged path arch/s390/include/asm/uv.h
