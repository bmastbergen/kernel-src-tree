KVM: nVMX: Move VM-Fail check out of nested_vmx_exit_reflected()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit fbdd50250396d55bf9986b2b9f271a7e91c111ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/fbdd5025.failed

Check for VM-Fail on nested VM-Enter in nested_vmx_reflect_vmexit() in
preparation for separating nested_vmx_exit_reflected() into separate "L0
wants exit exit" and "L1 wants the exit" helpers.

Explicitly set exit_intr_info and exit_qual to zero instead of reading
them from vmcs02, as they are invalid on VM-Fail (and thankfully ignored
by nested_vmx_vmexit() for nested VM-Fail).

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200415175519.14230-4-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit fbdd50250396d55bf9986b2b9f271a7e91c111ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/nested.c
diff --cc arch/x86/kvm/vmx/nested.c
index 760296c07825,cb7fd78ad9da..000000000000
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@@ -5586,29 -5652,6 +5586,32 @@@ bool nested_vmx_exit_reflected(struct k
  	struct vcpu_vmx *vmx = to_vmx(vcpu);
  	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
  
++<<<<<<< HEAD
 +	if (vmx->nested.nested_run_pending)
 +		return false;
 +
 +	if (unlikely(vmx->fail)) {
 +		trace_kvm_nested_vmenter_failed(
 +			"hardware VM-instruction error: ",
 +			vmcs_read32(VM_INSTRUCTION_ERROR));
 +		return true;
 +	}
 +
 +	/*
 +	 * The host physical addresses of some pages of guest memory
 +	 * are loaded into the vmcs02 (e.g. vmcs12's Virtual APIC
 +	 * Page). The CPU may write to these pages via their host
 +	 * physical address while L2 is running, bypassing any
 +	 * address-translation-based dirty tracking (e.g. EPT write
 +	 * protection).
 +	 *
 +	 * Mark them dirty on every exit from L2 to prevent them from
 +	 * getting out of sync with dirty tracking.
 +	 */
 +	nested_mark_vmcs12_pages_dirty(vcpu);
 +
++=======
++>>>>>>> fbdd50250396 (KVM: nVMX: Move VM-Fail check out of nested_vmx_exit_reflected())
  	trace_kvm_nested_vmexit(kvm_rip_read(vcpu), exit_reason,
  				vmcs_readl(EXIT_QUALIFICATION),
  				vmx->idt_vectoring_info,
@@@ -5761,6 -5804,55 +5764,58 @@@
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Conditionally reflect a VM-Exit into L1.  Returns %true if the VM-Exit was
+  * reflected into L1.
+  */
+ bool nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason)
+ {
+ 	struct vcpu_vmx *vmx = to_vmx(vcpu);
+ 	u32 exit_intr_info, exit_qual;
+ 
+ 	WARN_ON_ONCE(vmx->nested.nested_run_pending);
+ 
+ 	/*
+ 	 * Late nested VM-Fail shares the same flow as nested VM-Exit since KVM
+ 	 * has already loaded L2's state.
+ 	 */
+ 	if (unlikely(vmx->fail)) {
+ 		trace_kvm_nested_vmenter_failed(
+ 			"hardware VM-instruction error: ",
+ 			vmcs_read32(VM_INSTRUCTION_ERROR));
+ 		exit_intr_info = 0;
+ 		exit_qual = 0;
+ 		goto reflect_vmexit;
+ 	}
+ 
+ 	if (!nested_vmx_exit_reflected(vcpu, exit_reason))
+ 		return false;
+ 
+ 	/*
+ 	 * At this point, the exit interruption info in exit_intr_info
+ 	 * is only valid for EXCEPTION_NMI exits.  For EXTERNAL_INTERRUPT
+ 	 * we need to query the in-kernel LAPIC.
+ 	 */
+ 	WARN_ON(exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT);
+ 
+ 	exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);
+ 	if ((exit_intr_info &
+ 	     (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) ==
+ 	    (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) {
+ 		struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
+ 
+ 		vmcs12->vm_exit_intr_error_code =
+ 			vmcs_read32(VM_EXIT_INTR_ERROR_CODE);
+ 	}
+ 	exit_qual = vmcs_readl(EXIT_QUALIFICATION);
+ 
+ reflect_vmexit:
+ 	nested_vmx_vmexit(vcpu, exit_reason, exit_intr_info, exit_qual);
+ 	return true;
+ }
++>>>>>>> fbdd50250396 (KVM: nVMX: Move VM-Fail check out of nested_vmx_exit_reflected())
  
  static int vmx_get_nested_state(struct kvm_vcpu *vcpu,
  				struct kvm_nested_state __user *user_kvm_nested_state,
* Unmerged path arch/x86/kvm/vmx/nested.c
