perf metricgroup: Fix printing event names of metric group with multiple events

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Kajol Jain <kjain@linux.ibm.com>
commit eb573e746b9d4f0921dcb2449be3df41dae3caea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/eb573e74.failed

Commit f01642e4912b ("perf metricgroup: Support multiple events for
metricgroup") introduced support for multiple events in a metric group.
But with the current upstream, metric events names are not printed
properly

In power9 platform:

command:# ./perf stat --metric-only -M translation -C 0 -I 1000 sleep 2
     1.000208486
     2.000368863
     2.001400558

Similarly in skylake platform:

command:./perf stat --metric-only -M Power -I 1000
     1.000579994
     2.002189493

With current upstream version, issue is with event name comparison logic
in find_evsel_group(). Current logic is to compare events belonging to a
metric group to the events in perf_evlist.  Since the break statement is
missing in the loop used for comparison between metric group and
perf_evlist events, the loop continues to execute even after getting a
pattern match, and end up in discarding the matches.

Incase of single metric event belongs to metric group, its working fine,
because in case of single event once it compare all events it reaches to
end of perf_evlist.

Example for single metric event in power9 platform:

command:# ./perf stat --metric-only  -M branches_per_inst -I 1000 sleep 1
     1.000094653                  0.2
     1.001337059                  0.0

This patch fixes the issue by making sure once we found all events
belongs to that metric event matched in find_evsel_group(), we
successfully break from that loop by adding corresponding condition.

With this patch:
In power9 platform:

command:# ./perf stat --metric-only -M translation -C 0 -I 1000 sleep 2
result:#
            time  derat_4k_miss_rate_percent  derat_4k_miss_ratio derat_miss_ratio derat_64k_miss_rate_percent  derat_64k_miss_ratio dslb_miss_rate_percent islb_miss_rate_percent
     1.000135672                         0.0                  0.3              1.0                         0.0                   0.2                    0.0                    0.0
     2.000380617                         0.0                  0.0              0.0                         0.0                   0.0                    0.0                    0.0

command:# ./perf stat --metric-only -M Power -I 1000

Similarly in skylake platform:
result:#
            time    Turbo_Utilization    C3_Core_Residency  C6_Core_Residency  C7_Core_Residency    C2_Pkg_Residency  C3_Pkg_Residency     C6_Pkg_Residency   C7_Pkg_Residency
     1.000563580                  0.3                  0.0                2.6               44.2                21.9               0.0                  0.0               0.0
     2.002235027                  0.4                  0.0                2.7               43.0                20.7               0.0                  0.0               0.0

Committer testing:

  Before:

  [root@seventh ~]# perf stat --metric-only -M Power -I 1000
  #           time
       1.000383223
       2.001168182
       3.001968545
       4.002741200
       5.003442022
  ^C     5.777687244

  [root@seventh ~]#

  After the patch:

  [root@seventh ~]# perf stat --metric-only -M Power -I 1000
  #           time    Turbo_Utilization    C3_Core_Residency    C6_Core_Residency    C7_Core_Residency     C2_Pkg_Residency     C3_Pkg_Residency     C6_Pkg_Residency     C7_Pkg_Residency
       1.000406577                  0.4                  0.1                  1.4                 97.0                  0.0                  0.0                  0.0                  0.0
       2.001481572                  0.3                  0.0                  0.6                 97.9                  0.0                  0.0                  0.0                  0.0
       3.002332585                  0.2                  0.0                  1.0                 97.5                  0.0                  0.0                  0.0                  0.0
       4.003196624                  0.2                  0.0                  0.3                 98.6                  0.0                  0.0                  0.0                  0.0
       5.004063851                  0.3                  0.0                  0.7                 97.7                  0.0                  0.0                  0.0                  0.0
  ^C     5.471260276                  0.2                  0.0                  0.5                 49.3                  0.0                  0.0                  0.0                  0.0

  [root@seventh ~]#
  [root@seventh ~]# dmesg | grep -i skylake
  [    0.187807] Performance Events: PEBS fmt3+, Skylake events, 32-deep LBR, full-width counters, Intel PMU driver.
  [root@seventh ~]#

Fixes: f01642e4912b ("perf metricgroup: Support multiple events for metricgroup")
	Signed-off-by: Kajol Jain <kjain@linux.ibm.com>
	Reviewed-by: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Anju T Sudhakar <anju@linux.vnet.ibm.com>
	Cc: Jin Yao <yao.jin@linux.intel.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Kan Liang <kan.liang@linux.intel.com>
	Cc: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lore.kernel.org/lkml/20191120084059.24458-1-kjain@linux.ibm.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit eb573e746b9d4f0921dcb2449be3df41dae3caea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/metricgroup.c
diff --cc tools/perf/util/metricgroup.c
index fe6f7545a885,02aee946b6c1..000000000000
--- a/tools/perf/util/metricgroup.c
+++ b/tools/perf/util/metricgroup.c
@@@ -94,59 -87,67 +94,110 @@@ struct egroup 
  	const char **ids;
  	const char *metric_name;
  	const char *metric_expr;
 -	const char *metric_unit;
  };
  
 -static struct evsel *find_evsel_group(struct evlist *perf_evlist,
 -				      const char **ids,
 -				      int idnum,
 -				      struct evsel **metric_events)
 +static bool record_evsel(int *ind, struct perf_evsel **start,
 +			 int idnum,
 +			 struct perf_evsel **metric_events,
 +			 struct perf_evsel *ev)
  {
 -	struct evsel *ev;
 -	int i = 0;
 -	bool leader_found;
 +	metric_events[*ind] = ev;
 +	if (*ind == 0)
 +		*start = ev;
 +	if (++*ind == idnum) {
 +		metric_events[*ind] = NULL;
 +		return true;
 +	}
 +	return false;
 +}
 +
 +static struct perf_evsel *find_evsel_group(struct perf_evlist *perf_evlist,
 +					   const char **ids,
 +					   int idnum,
 +					   struct perf_evsel **metric_events)
 +{
 +	struct perf_evsel *ev, *start = NULL;
 +	int ind = 0;
  
  	evlist__for_each_entry (perf_evlist, ev) {
++<<<<<<< HEAD
 +		if (ev->collect_stat)
 +			continue;
 +		if (!strcmp(ev->name, ids[ind])) {
 +			if (record_evsel(&ind, &start, idnum,
 +					 metric_events, ev))
 +				return start;
 +		} else {
 +			/*
 +			 * We saw some other event that is not
 +			 * in our list of events. Discard
 +			 * the whole match and start again.
 +			 */
 +			ind = 0;
 +			start = NULL;
 +			if (!strcmp(ev->name, ids[ind])) {
 +				if (record_evsel(&ind, &start, idnum,
 +						 metric_events, ev))
 +					return start;
 +			}
 +		}
 +	}
 +	/*
 +	 * This can happen when an alias expands to multiple
 +	 * events, like for uncore events.
 +	 * We don't support this case for now.
 +	 */
 +	return NULL;
++=======
+ 		if (!strcmp(ev->name, ids[i])) {
+ 			if (!metric_events[i])
+ 				metric_events[i] = ev;
+ 			i++;
+ 			if (i == idnum)
+ 				break;
+ 		} else {
+ 			if (i + 1 == idnum) {
+ 				/* Discard the whole match and start again */
+ 				i = 0;
+ 				memset(metric_events, 0,
+ 				       sizeof(struct evsel *) * idnum);
+ 				continue;
+ 			}
+ 
+ 			if (!strcmp(ev->name, ids[i]))
+ 				metric_events[i] = ev;
+ 			else {
+ 				/* Discard the whole match and start again */
+ 				i = 0;
+ 				memset(metric_events, 0,
+ 				       sizeof(struct evsel *) * idnum);
+ 				continue;
+ 			}
+ 		}
+ 	}
+ 
+ 	if (i != idnum) {
+ 		/* Not whole match */
+ 		return NULL;
+ 	}
+ 
+ 	metric_events[idnum] = NULL;
+ 
+ 	for (i = 0; i < idnum; i++) {
+ 		leader_found = false;
+ 		evlist__for_each_entry(perf_evlist, ev) {
+ 			if (!leader_found && (ev == metric_events[i]))
+ 				leader_found = true;
+ 
+ 			if (leader_found &&
+ 			    !strcmp(ev->name, metric_events[i]->name)) {
+ 				ev->metric_leader = metric_events[i];
+ 			}
+ 		}
+ 	}
+ 
+ 	return metric_events[0];
++>>>>>>> eb573e746b9d (perf metricgroup: Fix printing event names of metric group with multiple events)
  }
  
  static int metricgroup__setup_events(struct list_head *groups,
* Unmerged path tools/perf/util/metricgroup.c
