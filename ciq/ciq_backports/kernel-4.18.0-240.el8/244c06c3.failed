PCI/IOV: Remove group write permission from sriov_numvfs, sriov_drivers_autoprobe

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Kelsey Skunberg <skunberg.kelsey@gmail.com>
commit 244c06c3b6d86513066426c9707ee460cd845349
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/244c06c3.failed

Previously the sriov_numvfs and sriov_drivers_autoprobe sysfs files had
0664 permissions, which allowed group write.  libvirt runs as root when
dealing with PCI, and it chowns files needed by qemu, so group write
permission should not be needed.

Change these permissions from 0664 to 0644, which is what DEVICE_ATTR_RW()
does by default.

[bhelgaas: commit log]
Link: https://lore.kernel.org/r/20190905063226.43269-1-skunberg.kelsey@gmail.com
Link: https://lore.kernel.org/r/850cf536-0b72-d78c-efaf-855dcb391087@redhat.com
	Signed-off-by: Kelsey Skunberg <skunberg.kelsey@gmail.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Acked-by: Donald Dutile <ddutile@redhat.com>
(cherry picked from commit 244c06c3b6d86513066426c9707ee460cd845349)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/iov.c
diff --cc drivers/pci/iov.c
index 525fd3f272b3,617dccebccf5..000000000000
--- a/drivers/pci/iov.c
+++ b/drivers/pci/iov.c
@@@ -240,6 -240,173 +240,176 @@@ void pci_iov_remove_virtfn(struct pci_d
  	pci_dev_put(dev);
  }
  
++<<<<<<< HEAD
++=======
+ static ssize_t sriov_totalvfs_show(struct device *dev,
+ 				   struct device_attribute *attr,
+ 				   char *buf)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 
+ 	return sprintf(buf, "%u\n", pci_sriov_get_totalvfs(pdev));
+ }
+ 
+ static ssize_t sriov_numvfs_show(struct device *dev,
+ 				 struct device_attribute *attr,
+ 				 char *buf)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 
+ 	return sprintf(buf, "%u\n", pdev->sriov->num_VFs);
+ }
+ 
+ /*
+  * num_vfs > 0; number of VFs to enable
+  * num_vfs = 0; disable all VFs
+  *
+  * Note: SRIOV spec does not allow partial VF
+  *	 disable, so it's all or none.
+  */
+ static ssize_t sriov_numvfs_store(struct device *dev,
+ 				  struct device_attribute *attr,
+ 				  const char *buf, size_t count)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 	int ret;
+ 	u16 num_vfs;
+ 
+ 	ret = kstrtou16(buf, 0, &num_vfs);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (num_vfs > pci_sriov_get_totalvfs(pdev))
+ 		return -ERANGE;
+ 
+ 	device_lock(&pdev->dev);
+ 
+ 	if (num_vfs == pdev->sriov->num_VFs)
+ 		goto exit;
+ 
+ 	/* is PF driver loaded w/callback */
+ 	if (!pdev->driver || !pdev->driver->sriov_configure) {
+ 		pci_info(pdev, "Driver does not support SRIOV configuration via sysfs\n");
+ 		ret = -ENOENT;
+ 		goto exit;
+ 	}
+ 
+ 	if (num_vfs == 0) {
+ 		/* disable VFs */
+ 		ret = pdev->driver->sriov_configure(pdev, 0);
+ 		goto exit;
+ 	}
+ 
+ 	/* enable VFs */
+ 	if (pdev->sriov->num_VFs) {
+ 		pci_warn(pdev, "%d VFs already enabled. Disable before enabling %d VFs\n",
+ 			 pdev->sriov->num_VFs, num_vfs);
+ 		ret = -EBUSY;
+ 		goto exit;
+ 	}
+ 
+ 	ret = pdev->driver->sriov_configure(pdev, num_vfs);
+ 	if (ret < 0)
+ 		goto exit;
+ 
+ 	if (ret != num_vfs)
+ 		pci_warn(pdev, "%d VFs requested; only %d enabled\n",
+ 			 num_vfs, ret);
+ 
+ exit:
+ 	device_unlock(&pdev->dev);
+ 
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return count;
+ }
+ 
+ static ssize_t sriov_offset_show(struct device *dev,
+ 				 struct device_attribute *attr,
+ 				 char *buf)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 
+ 	return sprintf(buf, "%u\n", pdev->sriov->offset);
+ }
+ 
+ static ssize_t sriov_stride_show(struct device *dev,
+ 				 struct device_attribute *attr,
+ 				 char *buf)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 
+ 	return sprintf(buf, "%u\n", pdev->sriov->stride);
+ }
+ 
+ static ssize_t sriov_vf_device_show(struct device *dev,
+ 				    struct device_attribute *attr,
+ 				    char *buf)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 
+ 	return sprintf(buf, "%x\n", pdev->sriov->vf_device);
+ }
+ 
+ static ssize_t sriov_drivers_autoprobe_show(struct device *dev,
+ 					    struct device_attribute *attr,
+ 					    char *buf)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 
+ 	return sprintf(buf, "%u\n", pdev->sriov->drivers_autoprobe);
+ }
+ 
+ static ssize_t sriov_drivers_autoprobe_store(struct device *dev,
+ 					     struct device_attribute *attr,
+ 					     const char *buf, size_t count)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 	bool drivers_autoprobe;
+ 
+ 	if (kstrtobool(buf, &drivers_autoprobe) < 0)
+ 		return -EINVAL;
+ 
+ 	pdev->sriov->drivers_autoprobe = drivers_autoprobe;
+ 
+ 	return count;
+ }
+ 
+ static DEVICE_ATTR_RO(sriov_totalvfs);
+ static DEVICE_ATTR_RW(sriov_numvfs);
+ static DEVICE_ATTR_RO(sriov_offset);
+ static DEVICE_ATTR_RO(sriov_stride);
+ static DEVICE_ATTR_RO(sriov_vf_device);
+ static DEVICE_ATTR_RW(sriov_drivers_autoprobe);
+ 
+ static struct attribute *sriov_dev_attrs[] = {
+ 	&dev_attr_sriov_totalvfs.attr,
+ 	&dev_attr_sriov_numvfs.attr,
+ 	&dev_attr_sriov_offset.attr,
+ 	&dev_attr_sriov_stride.attr,
+ 	&dev_attr_sriov_vf_device.attr,
+ 	&dev_attr_sriov_drivers_autoprobe.attr,
+ 	NULL,
+ };
+ 
+ static umode_t sriov_attrs_are_visible(struct kobject *kobj,
+ 				       struct attribute *a, int n)
+ {
+ 	struct device *dev = kobj_to_dev(kobj);
+ 
+ 	if (!dev_is_pf(dev))
+ 		return 0;
+ 
+ 	return a->mode;
+ }
+ 
+ const struct attribute_group sriov_dev_attr_group = {
+ 	.attrs = sriov_dev_attrs,
+ 	.is_visible = sriov_attrs_are_visible,
+ };
+ 
++>>>>>>> 244c06c3b6d8 (PCI/IOV: Remove group write permission from sriov_numvfs, sriov_drivers_autoprobe)
  int __weak pcibios_sriov_enable(struct pci_dev *pdev, u16 num_vfs)
  {
  	return 0;
* Unmerged path drivers/pci/iov.c
