arm64: Rename WORKAROUND_1165522 to SPECULATIVE_AT_VHE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [arm64] Rename WORKAROUND_1165522 to SPECULATIVE_AT_VHE (Gavin Shan) [1814009]
Rebuild_FUZZ: 93.07%
commit-author Steven Price <steven.price@arm.com>
commit e85d68faed4e79fd0b481c72de8245d4290369db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e85d68fa.failed

Cortex-A55 is affected by a similar erratum, so rename the existing
workaround for errarum 1165522 so it can be used for both errata.

	Acked-by: Marc Zyngier <maz@kernel.org>
	Reviewed-by: Suzuki K Poulose <suzuki.poulose@arm.com>
	Signed-off-by: Steven Price <steven.price@arm.com>
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit e85d68faed4e79fd0b481c72de8245d4290369db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kernel/cpu_errata.c
diff --cc arch/arm64/kernel/cpu_errata.c
index 9de4d99cff30,7886ddbafded..000000000000
--- a/arch/arm64/kernel/cpu_errata.c
+++ b/arch/arm64/kernel/cpu_errata.c
@@@ -755,6 -730,43 +755,46 @@@ static const struct midr_range erratum_
  };
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_ERRATUM_845719
+ static const struct midr_range erratum_845719_list[] = {
+ 	/* Cortex-A53 r0p[01234] */
+ 	MIDR_REV_RANGE(MIDR_CORTEX_A53, 0, 0, 4),
+ 	/* Brahma-B53 r0p[0] */
+ 	MIDR_REV(MIDR_BRAHMA_B53, 0, 0),
+ 	{},
+ };
+ #endif
+ 
+ #ifdef CONFIG_ARM64_ERRATUM_843419
+ static const struct arm64_cpu_capabilities erratum_843419_list[] = {
+ 	{
+ 		/* Cortex-A53 r0p[01234] */
+ 		.matches = is_affected_midr_range,
+ 		ERRATA_MIDR_REV_RANGE(MIDR_CORTEX_A53, 0, 0, 4),
+ 		MIDR_FIXED(0x4, BIT(8)),
+ 	},
+ 	{
+ 		/* Brahma-B53 r0p[0] */
+ 		.matches = is_affected_midr_range,
+ 		ERRATA_MIDR_REV(MIDR_BRAHMA_B53, 0, 0),
+ 	},
+ 	{},
+ };
+ #endif
+ 
+ #ifdef CONFIG_ARM64_WORKAROUND_SPECULATIVE_AT_VHE
+ static const struct midr_range erratum_speculative_at_vhe_list[] = {
+ #ifdef CONFIG_ARM64_ERRATUM_1165522
+ 	/* Cortex A76 r0p0 to r2p0 */
+ 	MIDR_RANGE(MIDR_CORTEX_A76, 0, 0, 2, 0),
+ #endif
+ 	{},
+ };
+ #endif
+ 
++>>>>>>> e85d68faed4e (arm64: Rename WORKAROUND_1165522 to SPECULATIVE_AT_VHE)
  const struct arm64_cpu_capabilities arm64_errata[] = {
  #ifdef CONFIG_ARM64_WORKAROUND_CLEAN_CACHE
  	{
@@@ -880,14 -893,21 +920,13 @@@
  		ERRATA_MIDR_RANGE_LIST(erratum_1418040_list),
  	},
  #endif
- #ifdef CONFIG_ARM64_ERRATUM_1165522
+ #ifdef CONFIG_ARM64_WORKAROUND_SPECULATIVE_AT_VHE
  	{
- 		/* Cortex-A76 r0p0 to r2p0 */
  		.desc = "ARM erratum 1165522",
- 		.capability = ARM64_WORKAROUND_1165522,
- 		ERRATA_MIDR_RANGE(MIDR_CORTEX_A76, 0, 0, 2, 0),
+ 		.capability = ARM64_WORKAROUND_SPECULATIVE_AT_VHE,
+ 		ERRATA_MIDR_RANGE_LIST(erratum_speculative_at_vhe_list),
  	},
  #endif
 -#ifdef CONFIG_ARM64_ERRATUM_1463225
 -	{
 -		.desc = "ARM erratum 1463225",
 -		.capability = ARM64_WORKAROUND_1463225,
 -		.type = ARM64_CPUCAP_LOCAL_CPU_ERRATUM,
 -		.matches = has_cortex_a76_erratum_1463225,
 -	},
 -#endif
  #ifdef CONFIG_CAVIUM_TX2_ERRATUM_219
  	{
  		.desc = "Cavium ThunderX2 erratum 219 (KVM guest sysreg trapping)",
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index d9a7ce52dbae..335b92f5cbe5 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -510,9 +510,13 @@ config ARM64_ERRATUM_1418040
 
 	  If unsure, say Y.
 
+config ARM64_WORKAROUND_SPECULATIVE_AT_VHE
+	bool
+
 config ARM64_ERRATUM_1165522
 	bool "Cortex-A76: Speculative AT instruction using out-of-context translation regime could cause subsequent request to generate an incorrect translation"
 	default y
+	select ARM64_WORKAROUND_SPECULATIVE_AT_VHE
 	help
 	  This option adds a workaround for ARM Cortex-A76 erratum 1165522.
 
diff --git a/arch/arm64/include/asm/cpucaps.h b/arch/arm64/include/asm/cpucaps.h
index 5ca3d91a67b5..18b32ba8aaa7 100644
--- a/arch/arm64/include/asm/cpucaps.h
+++ b/arch/arm64/include/asm/cpucaps.h
@@ -55,7 +55,7 @@
 #define ARM64_SSBS				34
 #define ARM64_WORKAROUND_1418040		35
 #define ARM64_HAS_SB				36
-#define ARM64_WORKAROUND_1165522		37
+#define ARM64_WORKAROUND_SPECULATIVE_AT_VHE	37
 #define ARM64_HAS_ADDRESS_AUTH_ARCH		38
 #define ARM64_HAS_ADDRESS_AUTH_IMP_DEF		39
 #define ARM64_HAS_GENERIC_AUTH_ARCH		40
diff --git a/arch/arm64/include/asm/kvm_host.h b/arch/arm64/include/asm/kvm_host.h
index 4dd101adad0d..f69e3f763a51 100644
--- a/arch/arm64/include/asm/kvm_host.h
+++ b/arch/arm64/include/asm/kvm_host.h
@@ -550,7 +550,7 @@ static inline bool kvm_arch_requires_vhe(void)
 		return true;
 
 	/* Some implementations have defects that confine them to VHE */
-	if (cpus_have_cap(ARM64_WORKAROUND_1165522))
+	if (cpus_have_cap(ARM64_WORKAROUND_SPECULATIVE_AT_VHE))
 		return true;
 
 	return false;
diff --git a/arch/arm64/include/asm/kvm_hyp.h b/arch/arm64/include/asm/kvm_hyp.h
index 53230290e8da..09a67d806fd2 100644
--- a/arch/arm64/include/asm/kvm_hyp.h
+++ b/arch/arm64/include/asm/kvm_hyp.h
@@ -106,7 +106,7 @@ static __always_inline void __hyp_text __load_guest_stage2(struct kvm *kvm)
 	 * before we can switch to the EL1/EL0 translation regime used by
 	 * the guest.
 	 */
-	asm(ALTERNATIVE("nop", "isb", ARM64_WORKAROUND_1165522));
+	asm(ALTERNATIVE("nop", "isb", ARM64_WORKAROUND_SPECULATIVE_AT_VHE));
 }
 
 #endif /* __ARM64_KVM_HYP_H__ */
* Unmerged path arch/arm64/kernel/cpu_errata.c
diff --git a/arch/arm64/kvm/hyp/switch.c b/arch/arm64/kvm/hyp/switch.c
index b617da7815ad..d69b6d653dbb 100644
--- a/arch/arm64/kvm/hyp/switch.c
+++ b/arch/arm64/kvm/hyp/switch.c
@@ -180,7 +180,7 @@ static void deactivate_traps_vhe(void)
 	 * before we can switch to the EL2/EL0 translation regime used by
 	 * the host.
 	 */
-	asm(ALTERNATIVE("nop", "isb", ARM64_WORKAROUND_1165522));
+	asm(ALTERNATIVE("nop", "isb", ARM64_WORKAROUND_SPECULATIVE_AT_VHE));
 
 	write_sysreg(CPACR_EL1_DEFAULT, cpacr_el1);
 	write_sysreg(vectors, vbar_el1);
diff --git a/arch/arm64/kvm/hyp/tlb.c b/arch/arm64/kvm/hyp/tlb.c
index e566bc96cab0..30b33c5ae7a5 100644
--- a/arch/arm64/kvm/hyp/tlb.c
+++ b/arch/arm64/kvm/hyp/tlb.c
@@ -34,7 +34,7 @@ static void __hyp_text __tlb_switch_to_guest_vhe(struct kvm *kvm,
 
 	local_irq_save(cxt->flags);
 
-	if (cpus_have_const_cap(ARM64_WORKAROUND_1165522)) {
+	if (cpus_have_const_cap(ARM64_WORKAROUND_SPECULATIVE_AT_VHE)) {
 		/*
 		 * For CPUs that are affected by ARM erratum 1165522, we
 		 * cannot trust stage-1 to be in a correct state at that
@@ -114,7 +114,7 @@ static void __hyp_text __tlb_switch_to_host_vhe(struct kvm *kvm,
 	write_sysreg(HCR_HOST_VHE_FLAGS, hcr_el2);
 	isb();
 
-	if (cpus_have_const_cap(ARM64_WORKAROUND_1165522)) {
+	if (cpus_have_const_cap(ARM64_WORKAROUND_SPECULATIVE_AT_VHE)) {
 		/* Restore the registers to what they were */
 		write_sysreg_el1(cxt->tcr, SYS_TCR);
 		write_sysreg_el1(cxt->sctlr, SYS_SCTLR);
