netfilter: nft_redir: add inet support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 63ce3940f3ab1d81e7c6d310dba52aed85db6aa1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/63ce3940.failed

allows to redirect both ipv4 and ipv6 with a single rule in an
inet nat table.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 63ce3940f3ab1d81e7c6d310dba52aed85db6aa1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_redir.c
diff --cc net/netfilter/nft_redir.c
index c64cbe78dee7,da74fdc4a684..000000000000
--- a/net/netfilter/nft_redir.c
+++ b/net/netfilter/nft_redir.c
@@@ -101,7 -104,193 +101,197 @@@ int nft_redir_dump(struct sk_buff *skb
  nla_put_failure:
  	return -1;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(nft_redir_dump);
++=======
+ 
+ static void nft_redir_ipv4_eval(const struct nft_expr *expr,
+ 				struct nft_regs *regs,
+ 				const struct nft_pktinfo *pkt)
+ {
+ 	struct nft_redir *priv = nft_expr_priv(expr);
+ 	struct nf_nat_ipv4_multi_range_compat mr;
+ 
+ 	memset(&mr, 0, sizeof(mr));
+ 	if (priv->sreg_proto_min) {
+ 		mr.range[0].min.all = (__force __be16)nft_reg_load16(
+ 			&regs->data[priv->sreg_proto_min]);
+ 		mr.range[0].max.all = (__force __be16)nft_reg_load16(
+ 			&regs->data[priv->sreg_proto_max]);
+ 		mr.range[0].flags |= NF_NAT_RANGE_PROTO_SPECIFIED;
+ 	}
+ 
+ 	mr.range[0].flags |= priv->flags;
+ 
+ 	regs->verdict.code = nf_nat_redirect_ipv4(pkt->skb, &mr, nft_hook(pkt));
+ }
+ 
+ static void
+ nft_redir_ipv4_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)
+ {
+ 	nf_ct_netns_put(ctx->net, NFPROTO_IPV4);
+ }
+ 
+ static struct nft_expr_type nft_redir_ipv4_type;
+ static const struct nft_expr_ops nft_redir_ipv4_ops = {
+ 	.type		= &nft_redir_ipv4_type,
+ 	.size		= NFT_EXPR_SIZE(sizeof(struct nft_redir)),
+ 	.eval		= nft_redir_ipv4_eval,
+ 	.init		= nft_redir_init,
+ 	.destroy	= nft_redir_ipv4_destroy,
+ 	.dump		= nft_redir_dump,
+ 	.validate	= nft_redir_validate,
+ };
+ 
+ static struct nft_expr_type nft_redir_ipv4_type __read_mostly = {
+ 	.family		= NFPROTO_IPV4,
+ 	.name		= "redir",
+ 	.ops		= &nft_redir_ipv4_ops,
+ 	.policy		= nft_redir_policy,
+ 	.maxattr	= NFTA_REDIR_MAX,
+ 	.owner		= THIS_MODULE,
+ };
+ 
+ #ifdef CONFIG_NF_TABLES_IPV6
+ static void nft_redir_ipv6_eval(const struct nft_expr *expr,
+ 				struct nft_regs *regs,
+ 				const struct nft_pktinfo *pkt)
+ {
+ 	struct nft_redir *priv = nft_expr_priv(expr);
+ 	struct nf_nat_range2 range;
+ 
+ 	memset(&range, 0, sizeof(range));
+ 	if (priv->sreg_proto_min) {
+ 		range.min_proto.all = (__force __be16)nft_reg_load16(
+ 			&regs->data[priv->sreg_proto_min]);
+ 		range.max_proto.all = (__force __be16)nft_reg_load16(
+ 			&regs->data[priv->sreg_proto_max]);
+ 		range.flags |= NF_NAT_RANGE_PROTO_SPECIFIED;
+ 	}
+ 
+ 	range.flags |= priv->flags;
+ 
+ 	regs->verdict.code =
+ 		nf_nat_redirect_ipv6(pkt->skb, &range, nft_hook(pkt));
+ }
+ 
+ static void
+ nft_redir_ipv6_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)
+ {
+ 	nf_ct_netns_put(ctx->net, NFPROTO_IPV6);
+ }
+ 
+ static struct nft_expr_type nft_redir_ipv6_type;
+ static const struct nft_expr_ops nft_redir_ipv6_ops = {
+ 	.type		= &nft_redir_ipv6_type,
+ 	.size		= NFT_EXPR_SIZE(sizeof(struct nft_redir)),
+ 	.eval		= nft_redir_ipv6_eval,
+ 	.init		= nft_redir_init,
+ 	.destroy	= nft_redir_ipv6_destroy,
+ 	.dump		= nft_redir_dump,
+ 	.validate	= nft_redir_validate,
+ };
+ 
+ static struct nft_expr_type nft_redir_ipv6_type __read_mostly = {
+ 	.family		= NFPROTO_IPV6,
+ 	.name		= "redir",
+ 	.ops		= &nft_redir_ipv6_ops,
+ 	.policy		= nft_redir_policy,
+ 	.maxattr	= NFTA_REDIR_MAX,
+ 	.owner		= THIS_MODULE,
+ };
+ #endif
+ 
+ #ifdef CONFIG_NF_TABLES_INET
+ static void nft_redir_inet_eval(const struct nft_expr *expr,
+ 				struct nft_regs *regs,
+ 				const struct nft_pktinfo *pkt)
+ {
+ 	switch (nft_pf(pkt)) {
+ 	case NFPROTO_IPV4:
+ 		return nft_redir_ipv4_eval(expr, regs, pkt);
+ 	case NFPROTO_IPV6:
+ 		return nft_redir_ipv6_eval(expr, regs, pkt);
+ 	}
+ 
+ 	WARN_ON_ONCE(1);
+ }
+ 
+ static void
+ nft_redir_inet_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)
+ {
+ 	nf_ct_netns_put(ctx->net, NFPROTO_INET);
+ }
+ 
+ static struct nft_expr_type nft_redir_inet_type;
+ static const struct nft_expr_ops nft_redir_inet_ops = {
+ 	.type		= &nft_redir_inet_type,
+ 	.size		= NFT_EXPR_SIZE(sizeof(struct nft_redir)),
+ 	.eval		= nft_redir_inet_eval,
+ 	.init		= nft_redir_init,
+ 	.destroy	= nft_redir_inet_destroy,
+ 	.dump		= nft_redir_dump,
+ 	.validate	= nft_redir_validate,
+ };
+ 
+ static struct nft_expr_type nft_redir_inet_type __read_mostly = {
+ 	.family		= NFPROTO_INET,
+ 	.name		= "redir",
+ 	.ops		= &nft_redir_inet_ops,
+ 	.policy		= nft_redir_policy,
+ 	.maxattr	= NFTA_MASQ_MAX,
+ 	.owner		= THIS_MODULE,
+ };
+ 
+ static int __init nft_redir_module_init_inet(void)
+ {
+ 	return nft_register_expr(&nft_redir_inet_type);
+ }
+ #else
+ static inline int nft_redir_module_init_inet(void) { return 0; }
+ #endif
+ 
+ static int __init nft_redir_module_init(void)
+ {
+ 	int ret = nft_register_expr(&nft_redir_ipv4_type);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ #ifdef CONFIG_NF_TABLES_IPV6
+ 	ret = nft_register_expr(&nft_redir_ipv6_type);
+ 	if (ret) {
+ 		nft_unregister_expr(&nft_redir_ipv4_type);
+ 		return ret;
+ 	}
+ #endif
+ 
+ 	ret = nft_redir_module_init_inet();
+ 	if (ret < 0) {
+ 		nft_unregister_expr(&nft_redir_ipv4_type);
+ #ifdef CONFIG_NF_TABLES_IPV6
+ 		nft_unregister_expr(&nft_redir_ipv6_type);
+ #endif
+ 		return ret;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static void __exit nft_redir_module_exit(void)
+ {
+ 	nft_unregister_expr(&nft_redir_ipv4_type);
+ #ifdef CONFIG_NF_TABLES_IPV6
+ 	nft_unregister_expr(&nft_redir_ipv6_type);
+ #endif
+ #ifdef CONFIG_NF_TABLES_INET
+ 	nft_unregister_expr(&nft_redir_inet_type);
+ #endif
+ }
+ 
+ module_init(nft_redir_module_init);
+ module_exit(nft_redir_module_exit);
++>>>>>>> 63ce3940f3ab (netfilter: nft_redir: add inet support)
  
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Arturo Borrero Gonzalez <arturo@debian.org>");
* Unmerged path net/netfilter/nft_redir.c
