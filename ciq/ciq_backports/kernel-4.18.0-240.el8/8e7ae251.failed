bpf: Sanitize the bpf_struct_ops tcp-cc name

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Martin KaFai Lau <kafai@fb.com>
commit 8e7ae2518f5265f0ef09d561748098fde5a87ccd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8e7ae251.failed

The bpf_struct_ops tcp-cc name should be sanitized in order to
avoid problematic chars (e.g. whitespaces).

This patch reuses the bpf_obj_name_cpy() for accepting the same set
of characters in order to keep a consistent bpf programming experience.
A "size" param is added.  Also, the strlen is returned on success so
that the caller (like the bpf_tcp_ca here) can error out on empty name.
The existing callers of the bpf_obj_name_cpy() only need to change the
testing statement to "if (err < 0)".  For all these existing callers,
the err will be overwritten later, so no extra change is needed
for the new strlen return value.

v3:
  - reverse xmas tree style
v2:
  - Save the orig_src to avoid "end - size" (Andrii)

Fixes: 0baf26b0fcd7 ("bpf: tcp: Support tcp_congestion_ops in bpf")
	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
Link: https://lore.kernel.org/bpf/20200314010209.1131542-1-kafai@fb.com
(cherry picked from commit 8e7ae2518f5265f0ef09d561748098fde5a87ccd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/syscall.c
#	net/ipv4/bpf_tcp_ca.c
diff --cc kernel/bpf/syscall.c
index 4aa6a47aa4b8,2857b7dda382..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -599,21 -811,26 +600,22 @@@ static int map_create(union bpf_attr *a
  	if (IS_ERR(map))
  		return PTR_ERR(map);
  
- 	err = bpf_obj_name_cpy(map->name, attr->map_name);
- 	if (err)
+ 	err = bpf_obj_name_cpy(map->name, attr->map_name,
+ 			       sizeof(attr->map_name));
+ 	if (err < 0)
  		goto free_map;
  
 -	atomic64_set(&map->refcnt, 1);
 -	atomic64_set(&map->usercnt, 1);
 -	mutex_init(&map->freeze_mutex);
 -
 -	map->spin_lock_off = -EINVAL;
 -	if (attr->btf_key_type_id || attr->btf_value_type_id ||
 -	    /* Even the map's value is a kernel's struct,
 -	     * the bpf_prog.o must have BTF to begin with
 -	     * to figure out the corresponding kernel's
 -	     * counter part.  Thus, attr->btf_fd has
 -	     * to be valid also.
 -	     */
 -	    attr->btf_vmlinux_value_type_id) {
 +	atomic_set(&map->refcnt, 1);
 +	atomic_set(&map->usercnt, 1);
 +
 +	if (attr->btf_key_type_id || attr->btf_value_type_id) {
  		struct btf *btf;
  
 +		if (!attr->btf_value_type_id) {
 +			err = -EINVAL;
 +			goto free_map;
 +		}
 +
  		btf = btf_get_by_fd(attr->btf_fd);
  		if (IS_ERR(btf)) {
  			err = PTR_ERR(btf);
@@@ -1778,9 -2099,10 +1780,16 @@@ static int bpf_prog_load(union bpf_att
  	if (err < 0)
  		goto free_prog;
  
++<<<<<<< HEAD
 +	prog->aux->load_time = ktime_get_boot_ns();
 +	err = bpf_obj_name_cpy(prog->aux->name, attr->prog_name);
 +	if (err)
++=======
+ 	prog->aux->load_time = ktime_get_boottime_ns();
+ 	err = bpf_obj_name_cpy(prog->aux->name, attr->prog_name,
+ 			       sizeof(attr->prog_name));
+ 	if (err < 0)
++>>>>>>> 8e7ae2518f52 (bpf: Sanitize the bpf_struct_ops tcp-cc name)
  		goto free_prog;
  
  	/* run eBPF verifier */
* Unmerged path net/ipv4/bpf_tcp_ca.c
diff --git a/include/linux/bpf.h b/include/linux/bpf.h
index 602dd6841705..96e9521d1912 100644
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@ -150,6 +150,7 @@ static inline void copy_map_value(struct bpf_map *map, void *dst, void *src)
 }
 void copy_map_value_locked(struct bpf_map *map, void *dst, void *src,
 			   bool lock_src);
+int bpf_obj_name_cpy(char *dst, const char *src, unsigned int size);
 
 struct bpf_offload_dev;
 struct bpf_offloaded_map;
* Unmerged path kernel/bpf/syscall.c
* Unmerged path net/ipv4/bpf_tcp_ca.c
