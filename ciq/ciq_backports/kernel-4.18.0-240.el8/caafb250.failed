ipv6: Remove old route notifications and convert listeners

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ido Schimmel <idosch@mellanox.com>
commit caafb2509fac1432849650826953dd88b7cbe374
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/caafb250.failed

Now that mlxsw is converted to use the new FIB notifications it is
possible to delete the old ones and use the new replace / append /
delete notifications.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Reviewed-by: Jiri Pirko <jiri@mellanox.com>
	Reviewed-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit caafb2509fac1432849650826953dd88b7cbe374)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
#	drivers/net/netdevsim/fib.c
#	net/ipv6/ip6_fib.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 52037acf49a1,f62e8d67348c..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -5942,17 -5966,22 +5942,35 @@@ static void mlxsw_sp_router_fib6_event_
  	mlxsw_sp_span_respin(mlxsw_sp);
  
  	switch (fib_work->event) {
++<<<<<<< HEAD
 +	case FIB_EVENT_ENTRY_REPLACE: /* fall through */
 +	case FIB_EVENT_ENTRY_ADD:
 +		replace = fib_work->event == FIB_EVENT_ENTRY_REPLACE;
 +		err = mlxsw_sp_router_fib6_add(mlxsw_sp,
 +					       fib_work->fib6_work.rt_arr,
 +					       fib_work->fib6_work.nrt6,
 +					       replace);
++=======
+ 	case FIB_EVENT_ENTRY_REPLACE:
+ 		err = mlxsw_sp_router_fib6_replace(mlxsw_sp,
+ 						   fib_work->fib6_work.rt_arr,
+ 						   fib_work->fib6_work.nrt6);
++>>>>>>> caafb2509fac (ipv6: Remove old route notifications and convert listeners)
  		if (err)
  			mlxsw_sp_router_fib_abort(mlxsw_sp);
  		mlxsw_sp_router_fib6_work_fini(&fib_work->fib6_work);
  		break;
++<<<<<<< HEAD
++=======
+ 	case FIB_EVENT_ENTRY_APPEND:
+ 		err = mlxsw_sp_router_fib6_append(mlxsw_sp,
+ 						  fib_work->fib6_work.rt_arr,
+ 						  fib_work->fib6_work.nrt6);
+ 		if (err)
+ 			mlxsw_sp_router_fib_abort(mlxsw_sp);
+ 		mlxsw_sp_router_fib6_work_fini(&fib_work->fib6_work);
+ 		break;
++>>>>>>> caafb2509fac (ipv6: Remove old route notifications and convert listeners)
  	case FIB_EVENT_ENTRY_DEL:
  		mlxsw_sp_router_fib6_del(mlxsw_sp,
  					 fib_work->fib6_work.rt_arr,
@@@ -6040,7 -6069,7 +6058,11 @@@ static int mlxsw_sp_router_fib6_event(s
  
  	switch (fib_work->event) {
  	case FIB_EVENT_ENTRY_REPLACE: /* fall through */
++<<<<<<< HEAD
 +	case FIB_EVENT_ENTRY_ADD: /* fall through */
++=======
+ 	case FIB_EVENT_ENTRY_APPEND: /* fall through */
++>>>>>>> caafb2509fac (ipv6: Remove old route notifications and convert listeners)
  	case FIB_EVENT_ENTRY_DEL:
  		fen6_info = container_of(info, struct fib6_entry_notifier_info,
  					 info);
@@@ -6146,7 -6174,7 +6168,11 @@@ static int mlxsw_sp_router_fib_event(st
  		return notifier_from_errno(err);
  	case FIB_EVENT_ENTRY_ADD: /* fall through */
  	case FIB_EVENT_ENTRY_REPLACE: /* fall through */
++<<<<<<< HEAD
 +	case FIB_EVENT_ENTRY_REPLACE_TMP:
++=======
+ 	case FIB_EVENT_ENTRY_APPEND:
++>>>>>>> caafb2509fac (ipv6: Remove old route notifications and convert listeners)
  		if (router->aborted) {
  			NL_SET_ERR_MSG_MOD(info->extack, "FIB offload was aborted. Not configuring route");
  			return notifier_from_errno(-EINVAL);
diff --cc drivers/net/netdevsim/fib.c
index 1a251f76d09b,b5df308b4e33..000000000000
--- a/drivers/net/netdevsim/fib.c
+++ b/drivers/net/netdevsim/fib.c
@@@ -184,12 -173,13 +184,16 @@@ static int nsim_fib_event_nb(struct not
  	switch (event) {
  	case FIB_EVENT_RULE_ADD: /* fall through */
  	case FIB_EVENT_RULE_DEL:
 -		err = nsim_fib_rule_event(data, info,
 -					  event == FIB_EVENT_RULE_ADD);
 +		err = nsim_fib_rule_event(info, event == FIB_EVENT_RULE_ADD);
  		break;
  
++<<<<<<< HEAD
 +	case FIB_EVENT_ENTRY_ADD:  /* fall through */
++=======
+ 	case FIB_EVENT_ENTRY_REPLACE:  /* fall through */
++>>>>>>> caafb2509fac (ipv6: Remove old route notifications and convert listeners)
  	case FIB_EVENT_ENTRY_DEL:
 -		err = nsim_fib_event(data, info, event != FIB_EVENT_ENTRY_DEL);
 +		err = nsim_fib_event(info, event == FIB_EVENT_ENTRY_ADD);
  		break;
  	}
  
diff --cc net/ipv6/ip6_fib.c
index 246c67f714a3,b1e9a10e1133..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -415,35 -399,78 +415,90 @@@ static int call_fib6_entry_notifiers(st
  	return call_fib6_notifiers(net, event_type, &info.info);
  }
  
++<<<<<<< HEAD
++=======
+ int call_fib6_multipath_entry_notifiers(struct net *net,
+ 					enum fib_event_type event_type,
+ 					struct fib6_info *rt,
+ 					unsigned int nsiblings,
+ 					struct netlink_ext_ack *extack)
+ {
+ 	struct fib6_entry_notifier_info info = {
+ 		.info.extack = extack,
+ 		.rt = rt,
+ 		.nsiblings = nsiblings,
+ 	};
+ 
+ 	rt->fib6_table->fib_seq++;
+ 	return call_fib6_notifiers(net, event_type, &info.info);
+ }
+ 
+ int call_fib6_entry_notifiers_replace(struct net *net, struct fib6_info *rt)
+ {
+ 	struct fib6_entry_notifier_info info = {
+ 		.rt = rt,
+ 		.nsiblings = rt->fib6_nsiblings,
+ 	};
+ 
+ 	rt->fib6_table->fib_seq++;
+ 	return call_fib6_notifiers(net, FIB_EVENT_ENTRY_REPLACE, &info.info);
+ }
+ 
++>>>>>>> caafb2509fac (ipv6: Remove old route notifications and convert listeners)
  struct fib6_dump_arg {
  	struct net *net;
  	struct notifier_block *nb;
 -	struct netlink_ext_ack *extack;
  };
  
 -static int fib6_rt_dump(struct fib6_info *rt, struct fib6_dump_arg *arg)
 +static void fib6_rt_dump(struct fib6_info *rt, struct fib6_dump_arg *arg)
  {
++<<<<<<< HEAD
 +	if (rt == arg->net->ipv6.fib6_null_entry)
 +		return;
 +	call_fib6_entry_notifier(arg->nb, arg->net, FIB_EVENT_ENTRY_ADD, rt);
++=======
+ 	enum fib_event_type fib_event = FIB_EVENT_ENTRY_REPLACE;
+ 	int err;
+ 
+ 	if (!rt || rt == arg->net->ipv6.fib6_null_entry)
+ 		return 0;
+ 
+ 	if (rt->fib6_nsiblings)
+ 		err = call_fib6_multipath_entry_notifier(arg->nb, fib_event,
+ 							 rt,
+ 							 rt->fib6_nsiblings,
+ 							 arg->extack);
+ 	else
+ 		err = call_fib6_entry_notifier(arg->nb, fib_event, rt,
+ 					       arg->extack);
+ 
+ 	return err;
++>>>>>>> caafb2509fac (ipv6: Remove old route notifications and convert listeners)
  }
  
  static int fib6_node_dump(struct fib6_walker *w)
  {
++<<<<<<< HEAD
 +	struct fib6_info *rt;
 +
 +	for_each_fib6_walker_rt(w)
 +		fib6_rt_dump(rt, w->args);
++=======
+ 	int err;
+ 
+ 	err = fib6_rt_dump(w->leaf, w->args);
++>>>>>>> caafb2509fac (ipv6: Remove old route notifications and convert listeners)
  	w->leaf = NULL;
 -	return err;
 +	return 0;
  }
  
 -static int fib6_table_dump(struct net *net, struct fib6_table *tb,
 -			   struct fib6_walker *w)
 +static void fib6_table_dump(struct net *net, struct fib6_table *tb,
 +			    struct fib6_walker *w)
  {
 -	int err;
 -
  	w->root = &tb->tb6_root;
  	spin_lock_bh(&tb->tb6_lock);
 -	err = fib6_walk(net, w);
 +	fib6_walk(net, w);
  	spin_unlock_bh(&tb->tb6_lock);
 -	return err;
  }
  
  /* Called with rcu_read_lock() */
@@@ -1121,26 -1201,39 +1176,60 @@@ next_iter
  add:
  		nlflags |= NLM_F_CREATE;
  
++<<<<<<< HEAD
 +		err = call_fib6_entry_notifiers(info->nl_net,
 +						FIB_EVENT_ENTRY_ADD,
 +						rt, extack);
 +		if (err) {
 +			struct fib6_info *sibling, *next_sibling;
 +
 +			/* If the route has siblings, then it first
 +			 * needs to be unlinked from them.
 +			 */
 +			if (!rt->fib6_nsiblings)
++=======
+ 		/* The route should only be notified if it is the first
+ 		 * route in the node or if it is added as a sibling
+ 		 * route to the first route in the node.
+ 		 */
+ 		if (!info->skip_notify_kernel &&
+ 		    (notify_sibling_rt || ins == &fn->leaf)) {
+ 			enum fib_event_type fib_event;
+ 
+ 			if (notify_sibling_rt)
+ 				fib_event = FIB_EVENT_ENTRY_APPEND;
+ 			else
+ 				fib_event = FIB_EVENT_ENTRY_REPLACE;
+ 			err = call_fib6_entry_notifiers(info->nl_net,
+ 							fib_event, rt,
+ 							extack);
+ 			if (err) {
+ 				struct fib6_info *sibling, *next_sibling;
+ 
+ 				/* If the route has siblings, then it first
+ 				 * needs to be unlinked from them.
+ 				 */
+ 				if (!rt->fib6_nsiblings)
+ 					return err;
+ 
+ 				list_for_each_entry_safe(sibling, next_sibling,
+ 							 &rt->fib6_siblings,
+ 							 fib6_siblings)
+ 					sibling->fib6_nsiblings--;
+ 				rt->fib6_nsiblings = 0;
+ 				list_del_init(&rt->fib6_siblings);
+ 				rt6_multipath_rebalance(next_sibling);
++>>>>>>> caafb2509fac (ipv6: Remove old route notifications and convert listeners)
  				return err;
 -			}
 +
 +			list_for_each_entry_safe(sibling, next_sibling,
 +						 &rt->fib6_siblings,
 +						 fib6_siblings)
 +				sibling->fib6_nsiblings--;
 +			rt->fib6_nsiblings = 0;
 +			list_del_init(&rt->fib6_siblings);
 +			rt6_multipath_rebalance(next_sibling);
 +			return err;
  		}
  
  		rcu_assign_pointer(rt->fib6_next, iter);
@@@ -1166,13 -1259,15 +1255,25 @@@
  			return -ENOENT;
  		}
  
++<<<<<<< HEAD
 +		err = call_fib6_entry_notifiers(info->nl_net,
 +						FIB_EVENT_ENTRY_REPLACE,
 +						rt, extack);
 +		if (err)
 +			return err;
 +
 +		atomic_inc(&rt->fib6_ref);
++=======
+ 		if (!info->skip_notify_kernel && ins == &fn->leaf) {
+ 			err = call_fib6_entry_notifiers(info->nl_net,
+ 							FIB_EVENT_ENTRY_REPLACE,
+ 							rt, extack);
+ 			if (err)
+ 				return err;
+ 		}
+ 
+ 		fib6_info_hold(rt);
++>>>>>>> caafb2509fac (ipv6: Remove old route notifications and convert listeners)
  		rcu_assign_pointer(rt->fib6_node, fn);
  		rt->fib6_next = iter->fib6_next;
  		rcu_assign_pointer(*ins, rt);
@@@ -1844,9 -1975,16 +1945,19 @@@ static void fib6_del_route(struct fib6_
  
  	fib6_purge_rt(rt, fn, net);
  
++<<<<<<< HEAD
 +	call_fib6_entry_notifiers(net, FIB_EVENT_ENTRY_DEL, rt, NULL);
++=======
+ 	if (!info->skip_notify_kernel) {
+ 		if (notify_del)
+ 			call_fib6_entry_notifiers(net, FIB_EVENT_ENTRY_DEL,
+ 						  rt, NULL);
+ 		else if (replace_rt)
+ 			call_fib6_entry_notifiers_replace(net, replace_rt);
+ 	}
++>>>>>>> caafb2509fac (ipv6: Remove old route notifications and convert listeners)
  	if (!info->skip_notify)
  		inet6_rt_notify(RTM_DELROUTE, rt, info, 0);
 -
  	fib6_info_release(rt);
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
* Unmerged path drivers/net/netdevsim/fib.c
diff --git a/include/net/fib_notifier.h b/include/net/fib_notifier.h
index 48a83709f5e6..c49d7bfb5c30 100644
--- a/include/net/fib_notifier.h
+++ b/include/net/fib_notifier.h
@@ -24,8 +24,6 @@ enum fib_event_type {
 	FIB_EVENT_NH_DEL,
 	FIB_EVENT_VIF_ADD,
 	FIB_EVENT_VIF_DEL,
-	FIB_EVENT_ENTRY_REPLACE_TMP,
-	FIB_EVENT_ENTRY_DEL_TMP,
 };
 
 struct fib_notifier_ops {
* Unmerged path net/ipv6/ip6_fib.c
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index f5ddf61a52e6..511aff38b0a9 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -3300,15 +3300,10 @@ static int __ip6_del_rt_siblings(struct fib6_info *rt, struct fib6_config *cfg)
 								  replace_rt);
 			else
 				call_fib6_multipath_entry_notifiers(net,
-						       FIB_EVENT_ENTRY_DEL_TMP,
+						       FIB_EVENT_ENTRY_DEL,
 						       rt, rt->fib6_nsiblings,
 						       NULL);
 		}
-		call_fib6_multipath_entry_notifiers(net,
-						    FIB_EVENT_ENTRY_DEL,
-						    rt,
-						    rt->fib6_nsiblings,
-						    NULL);
 		list_for_each_entry_safe(sibling, next_sibling,
 					 &rt->fib6_siblings,
 					 fib6_siblings) {
@@ -4454,7 +4449,6 @@ static int ip6_route_multipath_add(struct fib6_config *cfg,
 {
 	struct fib6_info *rt_notif = NULL, *rt_last = NULL;
 	struct nl_info *info = &cfg->fc_nlinfo;
-	enum fib_event_type event_type;
 	struct fib6_config r_cfg;
 	struct rtnexthop *rtnh;
 	struct fib6_info *rt;
@@ -4590,7 +4584,7 @@ static int ip6_route_multipath_add(struct fib6_config *cfg,
 		if (rt_notif->fib6_nsiblings != nhn - 1)
 			fib_event = FIB_EVENT_ENTRY_APPEND;
 		else
-			fib_event = FIB_EVENT_ENTRY_REPLACE_TMP;
+			fib_event = FIB_EVENT_ENTRY_REPLACE;
 
 		err = call_fib6_multipath_entry_notifiers(info->nl_net,
 							  fib_event, rt_notif,
@@ -4601,14 +4595,6 @@ static int ip6_route_multipath_add(struct fib6_config *cfg,
 			goto add_errout;
 		}
 	}
-	event_type = replace ? FIB_EVENT_ENTRY_REPLACE : FIB_EVENT_ENTRY_ADD;
-	err = call_fib6_multipath_entry_notifiers(info->nl_net, event_type,
-						  rt_notif, nhn - 1, extack);
-	if (err) {
-		/* Delete all the siblings that were just added */
-		err_nh = NULL;
-		goto add_errout;
-	}
 
 	/* success ... tell user about new route */
 	ip6_route_mpath_notify(rt_notif, rt_last, info, nlflags);
