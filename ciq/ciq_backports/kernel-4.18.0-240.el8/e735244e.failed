gpiolib: don't clear FLAG_IS_OUT when emulating open-drain/open-source

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Bartosz Golaszewski <bgolaszewski@baylibre.com>
commit e735244e2cf068f98b6384681a38993e0517a838
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e735244e.failed

When emulating open-drain/open-source by not actively driving the output
lines - we're simply changing their mode to input. This is wrong as it
will then make it impossible to change the value of such line - it's now
considered to actually be in input mode. If we want to still use the
direction_input() callback for simplicity then we need to set FLAG_IS_OUT
manually in gpiod_direction_output() and not clear it in
gpio_set_open_drain_value_commit() and
gpio_set_open_source_value_commit().

Fixes: c663e5f56737 ("gpio: support native single-ended hardware drivers")
	Cc: stable@vger.kernel.org
	Reported-by: Kent Gibson <warthog618@gmail.com>
	Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
(cherry picked from commit e735244e2cf068f98b6384681a38993e0517a838)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib.c
diff --cc drivers/gpio/gpiolib.c
index c3f8d6d16953,5833e4f380d6..000000000000
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@@ -3139,19 -3462,17 +3154,23 @@@ static void gpio_set_open_drain_value_c
  	int offset = gpio_chip_hwgpio(desc);
  
  	if (value) {
++<<<<<<< HEAD
 +		err = chip->direction_input(chip, offset);
 +		if (!err)
 +			clear_bit(FLAG_IS_OUT, &desc->flags);
++=======
+ 		ret = chip->direction_input(chip, offset);
++>>>>>>> e735244e2cf0 (gpiolib: don't clear FLAG_IS_OUT when emulating open-drain/open-source)
  	} else {
 -		ret = chip->direction_output(chip, offset, 0);
 -		if (!ret)
 +		err = chip->direction_output(chip, offset, 0);
 +		if (!err)
  			set_bit(FLAG_IS_OUT, &desc->flags);
  	}
 -	trace_gpio_direction(desc_to_gpio(desc), value, ret);
 -	if (ret < 0)
 +	trace_gpio_direction(desc_to_gpio(desc), value, err);
 +	if (err < 0)
  		gpiod_err(desc,
  			  "%s: Error in set_value for open drain err %d\n",
 -			  __func__, ret);
 +			  __func__, err);
  }
  
  /*
@@@ -3166,19 -3487,17 +3185,23 @@@ static void gpio_set_open_source_value_
  	int offset = gpio_chip_hwgpio(desc);
  
  	if (value) {
 -		ret = chip->direction_output(chip, offset, 1);
 -		if (!ret)
 +		err = chip->direction_output(chip, offset, 1);
 +		if (!err)
  			set_bit(FLAG_IS_OUT, &desc->flags);
  	} else {
++<<<<<<< HEAD
 +		err = chip->direction_input(chip, offset);
 +		if (!err)
 +			clear_bit(FLAG_IS_OUT, &desc->flags);
++=======
+ 		ret = chip->direction_input(chip, offset);
++>>>>>>> e735244e2cf0 (gpiolib: don't clear FLAG_IS_OUT when emulating open-drain/open-source)
  	}
 -	trace_gpio_direction(desc_to_gpio(desc), !value, ret);
 -	if (ret < 0)
 +	trace_gpio_direction(desc_to_gpio(desc), !value, err);
 +	if (err < 0)
  		gpiod_err(desc,
  			  "%s: Error in set_value for open source err %d\n",
 -			  __func__, ret);
 +			  __func__, err);
  }
  
  static void gpiod_set_raw_value_commit(struct gpio_desc *desc, bool value)
* Unmerged path drivers/gpio/gpiolib.c
