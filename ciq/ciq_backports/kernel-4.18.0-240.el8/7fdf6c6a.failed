Bluetooth: Allow combination of BDADDR_PROPERTY and INVALID_BDADDR quirks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Marcel Holtmann <marcel@holtmann.org>
commit 7fdf6c6a0d0e032aac2aa4537a23af1e04a397ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7fdf6c6a.failed

When utilizing BDADDR_PROPERTY and INVALID_BDADDR quirks together it
results in an unconfigured controller even if the bootloader provides
a valid address. Fix this by allowing a bootloader provided address
to mark the controller as configured.

	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	Tested-by: Andre Heider <a.heider@gmail.com>
	Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
(cherry picked from commit 7fdf6c6a0d0e032aac2aa4537a23af1e04a397ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/hci_core.c
diff --cc net/bluetooth/hci_core.c
index af17f2e4031d,9e19d5a3aac8..000000000000
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@@ -1368,12 -1442,45 +1368,52 @@@ static int hci_dev_do_open(struct hci_d
  	atomic_set(&hdev->cmd_cnt, 1);
  	set_bit(HCI_INIT, &hdev->flags);
  
++<<<<<<< HEAD
 +	if (hci_dev_test_flag(hdev, HCI_SETUP)) {
++=======
+ 	if (hci_dev_test_flag(hdev, HCI_SETUP) ||
+ 	    test_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks)) {
+ 		bool invalid_bdaddr;
+ 
++>>>>>>> 7fdf6c6a0d0e (Bluetooth: Allow combination of BDADDR_PROPERTY and INVALID_BDADDR quirks)
  		hci_sock_dev_event(hdev, HCI_DEV_SETUP);
  
  		if (hdev->setup)
  			ret = hdev->setup(hdev);
  
++<<<<<<< HEAD
++=======
+ 		/* The transport driver can set the quirk to mark the
+ 		 * BD_ADDR invalid before creating the HCI device or in
+ 		 * its setup callback.
+ 		 */
+ 		invalid_bdaddr = test_bit(HCI_QUIRK_INVALID_BDADDR,
+ 					  &hdev->quirks);
+ 
+ 		if (ret)
+ 			goto setup_failed;
+ 
+ 		if (test_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks)) {
+ 			if (!bacmp(&hdev->public_addr, BDADDR_ANY))
+ 				hci_dev_get_bd_addr_from_property(hdev);
+ 
+ 			if (bacmp(&hdev->public_addr, BDADDR_ANY) &&
+ 			    hdev->set_bdaddr) {
+ 				ret = hdev->set_bdaddr(hdev,
+ 						       &hdev->public_addr);
+ 
+ 				/* If setting of the BD_ADDR from the device
+ 				 * property succeeds, then treat the address
+ 				 * as valid even if the invalid BD_ADDR
+ 				 * quirk indicates otherwise.
+ 				 */
+ 				if (!ret)
+ 					invalid_bdaddr = false;
+ 			}
+ 		}
+ 
+ setup_failed:
++>>>>>>> 7fdf6c6a0d0e (Bluetooth: Allow combination of BDADDR_PROPERTY and INVALID_BDADDR quirks)
  		/* The transport driver can set these quirks before
  		 * creating the HCI device or in its setup callback.
  		 *
* Unmerged path net/bluetooth/hci_core.c
