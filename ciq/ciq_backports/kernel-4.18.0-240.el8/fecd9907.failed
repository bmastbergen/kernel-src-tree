perf trace: Introduce accessors to trace specific evsel->priv

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit fecd990720306f93151747771f16bca71bb29c33
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/fecd9907.failed

We're using evsel->priv in syscalls:sys_{enter,exit}_SYSCALL and in
raw_syscalls:sys_{enter,exit} to cache the offset of the common fields,
the multiplexor id/syscall_id in the sys_enter case and syscall_id + ret
for sys_exit.

And for the rest of the tracepoints we use it to have a syscall_arg_fmt
array to have scnprintf/strtoul for tracepoint args.

So we better clearly mark them with accessors so that we can move to
having a 'struct evsel_trace' struct for all 'perf trace' specific
evsel->priv usage.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Luis Cláudio Gonçalves <lclaudio@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
Link: https://lkml.kernel.org/n/tip-dcoyxfslg7atz821tz9aupjh@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit fecd990720306f93151747771f16bca71bb29c33)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-trace.c
diff --cc tools/perf/builtin-trace.c
index d11441fd591b,e0be1df555a2..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -275,7 -285,28 +275,32 @@@ struct syscall_tp 
  	};
  };
  
++<<<<<<< HEAD
 +static int perf_evsel__init_tp_uint_field(struct perf_evsel *evsel,
++=======
+ /*
+  * Used with raw_syscalls:sys_{enter,exit} and with the
+  * syscalls:sys_{enter,exit}_SYSCALL tracepoints
+  */
+ static inline struct syscall_tp *__evsel__syscall_tp(struct evsel *evsel)
+ {
+ 	struct syscall_tp *sc = evsel->priv;
+ 
+ 	return sc;
+ }
+ 
+ /*
+  * Used with all the other tracepoints.
+  */
+ static inline struct syscall_arg_fmt *__evsel__syscall_arg_fmt(struct evsel *evsel)
+ {
+ 	struct syscall_arg_fmt *fmt = evsel->priv;
+ 
+ 	return fmt;
+ }
+ 
+ static int perf_evsel__init_tp_uint_field(struct evsel *evsel,
++>>>>>>> fecd99072030 (perf trace: Introduce accessors to trace specific evsel->priv)
  					  struct tp_field *field,
  					  const char *name)
  {
@@@ -288,10 -319,10 +313,10 @@@
  }
  
  #define perf_evsel__init_sc_tp_uint_field(evsel, name) \
- 	({ struct syscall_tp *sc = evsel->priv;\
+ 	({ struct syscall_tp *sc = __evsel__syscall_tp(evsel);\
  	   perf_evsel__init_tp_uint_field(evsel, &sc->name, #name); })
  
 -static int perf_evsel__init_tp_ptr_field(struct evsel *evsel,
 +static int perf_evsel__init_tp_ptr_field(struct perf_evsel *evsel,
  					 struct tp_field *field,
  					 const char *name)
  {
@@@ -304,16 -335,16 +329,16 @@@
  }
  
  #define perf_evsel__init_sc_tp_ptr_field(evsel, name) \
- 	({ struct syscall_tp *sc = evsel->priv;\
+ 	({ struct syscall_tp *sc = __evsel__syscall_tp(evsel);\
  	   perf_evsel__init_tp_ptr_field(evsel, &sc->name, #name); })
  
 -static void evsel__delete_priv(struct evsel *evsel)
 +static void perf_evsel__delete_priv(struct perf_evsel *evsel)
  {
  	zfree(&evsel->priv);
 -	evsel__delete(evsel);
 +	perf_evsel__delete(evsel);
  }
  
 -static int perf_evsel__init_syscall_tp(struct evsel *evsel)
 +static int perf_evsel__init_syscall_tp(struct perf_evsel *evsel)
  {
  	struct syscall_tp *sc = evsel->priv = malloc(sizeof(struct syscall_tp));
  
@@@ -352,16 -383,16 +377,16 @@@ out_delete
  	return -EINVAL;
  }
  
 -static int perf_evsel__init_augmented_syscall_tp_args(struct evsel *evsel)
 +static int perf_evsel__init_augmented_syscall_tp_args(struct perf_evsel *evsel)
  {
- 	struct syscall_tp *sc = evsel->priv;
+ 	struct syscall_tp *sc = __evsel__syscall_tp(evsel);
  
  	return __tp_field__init_ptr(&sc->args, sc->id.offset + sizeof(u64));
  }
  
 -static int perf_evsel__init_augmented_syscall_tp_ret(struct evsel *evsel)
 +static int perf_evsel__init_augmented_syscall_tp_ret(struct perf_evsel *evsel)
  {
- 	struct syscall_tp *sc = evsel->priv;
+ 	struct syscall_tp *sc = __evsel__syscall_tp(evsel);
  
  	return __tp_field__init_uint(&sc->ret, sizeof(u64), sc->id.offset + sizeof(u64), evsel->needs_swap);
  }
@@@ -2499,7 -2533,81 +2524,85 @@@ static void bpf_output__fprintf(struct 
  	++trace->nr_events_printed;
  }
  
++<<<<<<< HEAD
 +static int trace__event_handler(struct trace *trace, struct perf_evsel *evsel,
++=======
+ static size_t trace__fprintf_tp_fields(struct trace *trace, struct evsel *evsel, struct perf_sample *sample,
+ 				       struct thread *thread, void *augmented_args, int augmented_args_size)
+ {
+ 	char bf[2048];
+ 	size_t size = sizeof(bf);
+ 	struct tep_format_field *field = evsel->tp_format->format.fields;
+ 	struct syscall_arg_fmt *arg = __evsel__syscall_arg_fmt(evsel);
+ 	size_t printed = 0;
+ 	unsigned long val;
+ 	u8 bit = 1;
+ 	struct syscall_arg syscall_arg = {
+ 		.augmented = {
+ 			.size = augmented_args_size,
+ 			.args = augmented_args,
+ 		},
+ 		.idx	= 0,
+ 		.mask	= 0,
+ 		.trace  = trace,
+ 		.thread = thread,
+ 		.show_string_prefix = trace->show_string_prefix,
+ 	};
+ 
+ 	for (; field && arg; field = field->next, ++syscall_arg.idx, bit <<= 1, ++arg) {
+ 		if (syscall_arg.mask & bit)
+ 			continue;
+ 
+ 		syscall_arg.len = 0;
+ 		syscall_arg.fmt = arg;
+ 		if (field->flags & TEP_FIELD_IS_ARRAY) {
+ 			int offset = field->offset;
+ 
+ 			if (field->flags & TEP_FIELD_IS_DYNAMIC) {
+ 				offset = format_field__intval(field, sample, evsel->needs_swap);
+ 				syscall_arg.len = offset >> 16;
+ 				offset &= 0xffff;
+ 			}
+ 
+ 			val = (uintptr_t)(sample->raw_data + offset);
+ 		} else
+ 			val = format_field__intval(field, sample, evsel->needs_swap);
+ 		/*
+ 		 * Some syscall args need some mask, most don't and
+ 		 * return val untouched.
+ 		 */
+ 		val = syscall_arg_fmt__mask_val(arg, &syscall_arg, val);
+ 
+ 		/*
+ 		 * Suppress this argument if its value is zero and
+ 		 * and we don't have a string associated in an
+ 		 * strarray for it.
+ 		 */
+ 		if (val == 0 &&
+ 		    !trace->show_zeros &&
+ 		    !((arg->show_zero ||
+ 		       arg->scnprintf == SCA_STRARRAY ||
+ 		       arg->scnprintf == SCA_STRARRAYS) &&
+ 		      arg->parm))
+ 			continue;
+ 
+ 		printed += scnprintf(bf + printed, size - printed, "%s", printed ? ", " : "");
+ 
+ 		/*
+ 		 * XXX Perhaps we should have a show_tp_arg_names,
+ 		 * leaving show_arg_names just for syscalls?
+ 		 */
+ 		if (1 || trace->show_arg_names)
+ 			printed += scnprintf(bf + printed, size - printed, "%s: ", field->name);
+ 
+ 		printed += syscall_arg_fmt__scnprintf_val(arg, bf + printed, size - printed, &syscall_arg, val);
+ 	}
+ 
+ 	return printed + fprintf(trace->output, "%s", bf);
+ }
+ 
+ static int trace__event_handler(struct trace *trace, struct evsel *evsel,
++>>>>>>> fecd99072030 (perf trace: Introduce accessors to trace specific evsel->priv)
  				union perf_event *event __maybe_unused,
  				struct perf_sample *sample)
  {
* Unmerged path tools/perf/builtin-trace.c
