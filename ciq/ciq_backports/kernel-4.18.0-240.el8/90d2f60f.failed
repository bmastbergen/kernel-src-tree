KVM: x86: Use KVM cpu caps to track UMIP emulation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 90d2f60f41f73b90768554e5a30b1cfedd167731
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/90d2f60f.failed

Set UMIP in kvm_cpu_caps when it is emulated by VMX, even though the
bit will effectively be dropped by do_host_cpuid().  This allows
checking for UMIP emulation via kvm_cpu_caps instead of a dedicated
kvm_x86_ops callback.

No functional change intended.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 90d2f60f41f73b90768554e5a30b1cfedd167731)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/svm.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/include/asm/kvm_host.h
index 69418e1a3a68,c46373016574..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -1165,14 -1172,12 +1165,18 @@@ struct kvm_x86_ops 
  
  	int (*check_intercept)(struct kvm_vcpu *vcpu,
  			       struct x86_instruction_info *info,
 -			       enum x86_intercept_stage stage,
 -			       struct x86_exception *exception);
 +			       enum x86_intercept_stage stage);
  	void (*handle_exit_irqoff)(struct kvm_vcpu *vcpu,
  		enum exit_fastpath_completion *exit_fastpath);
++<<<<<<< HEAD
 +	bool (*mpx_supported)(void);
 +	bool (*xsaves_supported)(void);
 +	bool (*umip_emulated)(void);
++=======
+ 
++>>>>>>> 90d2f60f41f7 (KVM: x86: Use KVM cpu caps to track UMIP emulation)
  	bool (*pt_supported)(void);
 +	bool (*pku_supported)(void);
  
  	int (*check_nested_events)(struct kvm_vcpu *vcpu);
  	void (*request_immediate_exit)(struct kvm_vcpu *vcpu);
diff --cc arch/x86/kvm/svm.c
index 2c7c88ef7253,26d2e170e9fd..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -6091,26 -6088,6 +6091,29 @@@ static bool svm_rdtscp_supported(void
  	return boot_cpu_has(X86_FEATURE_RDTSCP);
  }
  
++<<<<<<< HEAD
 +static bool svm_invpcid_supported(void)
 +{
 +	return false;
 +}
 +
 +static bool svm_mpx_supported(void)
 +{
 +	return false;
 +}
 +
 +static bool svm_xsaves_supported(void)
 +{
 +	return boot_cpu_has(X86_FEATURE_XSAVES);
 +}
 +
 +static bool svm_umip_emulated(void)
 +{
 +	return false;
 +}
 +
++=======
++>>>>>>> 90d2f60f41f7 (KVM: x86: Use KVM cpu caps to track UMIP emulation)
  static bool svm_pt_supported(void)
  {
  	return false;
@@@ -7465,12 -7455,7 +7468,15 @@@ static struct kvm_x86_ops svm_x86_ops _
  	.cpuid_update = svm_cpuid_update,
  
  	.rdtscp_supported = svm_rdtscp_supported,
++<<<<<<< HEAD
 +	.invpcid_supported = svm_invpcid_supported,
 +	.mpx_supported = svm_mpx_supported,
 +	.xsaves_supported = svm_xsaves_supported,
 +	.umip_emulated = svm_umip_emulated,
++=======
++>>>>>>> 90d2f60f41f7 (KVM: x86: Use KVM cpu caps to track UMIP emulation)
  	.pt_supported = svm_pt_supported,
 +	.pku_supported = svm_pku_supported,
  
  	.set_supported_cpuid = svm_set_supported_cpuid,
  
diff --cc arch/x86/kvm/vmx/vmx.c
index b4f527d117f1,bea247fabca0..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -7251,10 -7123,57 +7251,57 @@@ static void vmx_cpuid_update(struct kvm
  	}
  }
  
 -/*
 - * Vendor specific emulation must be handled via ->set_supported_cpuid(), not
 - * vmx_set_cpu_caps(), as capabilities configured during hardware_setup() are
 - * masked against hardware/kernel support, i.e. they'd be lost.
 - */
 -static void vmx_set_supported_cpuid(struct kvm_cpuid_entry2 *entry)
 +static void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
  {
++<<<<<<< HEAD
 +	if (func == 1 && nested)
 +		entry->ecx |= feature_bit(VMX);
++=======
+ 	switch (entry->function) {
+ 	case 0x7:
+ 		/*
+ 		 * UMIP needs to be manually set even though vmx_set_cpu_caps()
+ 		 * also sets UMIP since do_host_cpuid() will drop it.
+ 		 */
+ 		if (vmx_umip_emulated())
+ 			cpuid_entry_set(entry, X86_FEATURE_UMIP);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static __init void vmx_set_cpu_caps(void)
+ {
+ 	kvm_set_cpu_caps();
+ 
+ 	/* CPUID 0x1 */
+ 	if (nested)
+ 		kvm_cpu_cap_set(X86_FEATURE_VMX);
+ 
+ 	/* CPUID 0x7 */
+ 	if (kvm_mpx_supported())
+ 		kvm_cpu_cap_check_and_set(X86_FEATURE_MPX);
+ 	if (cpu_has_vmx_invpcid())
+ 		kvm_cpu_cap_check_and_set(X86_FEATURE_INVPCID);
+ 	if (vmx_pt_mode_is_host_guest())
+ 		kvm_cpu_cap_check_and_set(X86_FEATURE_INTEL_PT);
+ 
+ 	/* PKU is not yet implemented for shadow paging. */
+ 	if (enable_ept && boot_cpu_has(X86_FEATURE_OSPKE))
+ 		kvm_cpu_cap_check_and_set(X86_FEATURE_PKU);
+ 
+ 	if (vmx_umip_emulated())
+ 		kvm_cpu_cap_set(X86_FEATURE_UMIP);
+ 
+ 	/* CPUID 0xD.1 */
+ 	if (!vmx_xsaves_supported())
+ 		kvm_cpu_cap_clear(X86_FEATURE_XSAVES);
+ 
+ 	/* CPUID 0x80000001 */
+ 	if (!cpu_has_vmx_rdtscp())
+ 		kvm_cpu_cap_clear(X86_FEATURE_RDTSCP);
++>>>>>>> 90d2f60f41f7 (KVM: x86: Use KVM cpu caps to track UMIP emulation)
  }
  
  static void vmx_request_immediate_exit(struct kvm_vcpu *vcpu)
@@@ -7990,11 -7970,7 +8037,14 @@@ static struct kvm_x86_ops vmx_x86_ops _
  
  	.check_intercept = vmx_check_intercept,
  	.handle_exit_irqoff = vmx_handle_exit_irqoff,
++<<<<<<< HEAD
 +	.mpx_supported = vmx_mpx_supported,
 +	.xsaves_supported = vmx_xsaves_supported,
 +	.umip_emulated = vmx_umip_emulated,
++=======
++>>>>>>> 90d2f60f41f7 (KVM: x86: Use KVM cpu caps to track UMIP emulation)
  	.pt_supported = vmx_pt_supported,
 +	.pku_supported = vmx_pku_supported,
  
  	.request_immediate_exit = vmx_request_immediate_exit,
  
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/svm.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 4ad9e50bf3f6..d50bf0e383aa 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -908,7 +908,7 @@ static u64 kvm_host_cr4_reserved_bits(struct cpuinfo_x86 *c)
 	if (cpuid_ecx(0x7) & feature_bit(LA57))
 		reserved_bits &= ~X86_CR4_LA57;
 
-	if (kvm_x86_ops->umip_emulated())
+	if (kvm_cpu_cap_has(X86_FEATURE_UMIP))
 		reserved_bits &= ~X86_CR4_UMIP;
 
 	return reserved_bits;
