netdevsim: implement proper devlink reload

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Pirko <jiri@mellanox.com>
commit 75ba029f3c07f4755b88ee3a9c441e9ffb468e6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/75ba029f.failed

During devlink reload, all driver objects should be reinstantiated with
the exception of devlink instance and devlink resources and params.
Move existing devlink_resource_size_get() calls into fib_create() just
before fib notifier is registered. Also, make sure that extack is
propagated down to fib_notifier_register() call.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 75ba029f3c07f4755b88ee3a9c441e9ffb468e6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/netdevsim/dev.c
#	drivers/net/netdevsim/fib.c
#	drivers/net/netdevsim/netdevsim.h
diff --cc drivers/net/netdevsim/dev.c
index 863a10803cdb,7de80faab047..000000000000
--- a/drivers/net/netdevsim/dev.c
+++ b/drivers/net/netdevsim/dev.c
@@@ -530,27 -485,9 +537,33 @@@ static int nsim_dev_reload_down(struct 
  static int nsim_dev_reload_up(struct devlink *devlink,
  			      struct netlink_ext_ack *extack)
  {
++<<<<<<< HEAD
 +	enum nsim_resource_id res_ids[] = {
 +		NSIM_RESOURCE_IPV4_FIB, NSIM_RESOURCE_IPV4_FIB_RULES,
 +		NSIM_RESOURCE_IPV6_FIB, NSIM_RESOURCE_IPV6_FIB_RULES
 +	};
 +	struct net *net = nsim_devlink_net(devlink);
 +	int i;
 +
 +	for (i = 0; i < ARRAY_SIZE(res_ids); ++i) {
 +		int err;
 +		u64 val;
 +
 +		err = devlink_resource_size_get(devlink, res_ids[i], &val);
 +		if (!err) {
 +			err = nsim_fib_set_max(net, res_ids[i], val, extack);
 +			if (err)
 +				return err;
 +		}
 +	}
 +	nsim_devlink_param_load_driverinit_values(devlink);
 +
 +	return 0;
++=======
+ 	struct nsim_dev *nsim_dev = devlink_priv(devlink);
+ 
+ 	return nsim_dev_reload_create(nsim_dev, extack);
++>>>>>>> 75ba029f3c07 (netdevsim: implement proper devlink reload)
  }
  
  #define NSIM_DEV_FLASH_SIZE 500000
@@@ -807,7 -656,177 +820,181 @@@ static void nsim_dev_port_del_all(struc
  	list_for_each_entry_safe(nsim_dev_port, tmp,
  				 &nsim_dev->port_list, list)
  		__nsim_dev_port_del(nsim_dev_port);
++<<<<<<< HEAD
 +	mutex_unlock(&nsim_dev->port_list_lock);
++=======
+ }
+ 
+ static int nsim_dev_port_add_all(struct nsim_dev *nsim_dev,
+ 				 unsigned int port_count)
+ {
+ 	int i, err;
+ 
+ 	for (i = 0; i < port_count; i++) {
+ 		err = __nsim_dev_port_add(nsim_dev, i);
+ 		if (err)
+ 			goto err_port_del_all;
+ 	}
+ 	return 0;
+ 
+ err_port_del_all:
+ 	nsim_dev_port_del_all(nsim_dev);
+ 	return err;
+ }
+ 
+ static int nsim_dev_reload_create(struct nsim_dev *nsim_dev,
+ 				  struct netlink_ext_ack *extack)
+ {
+ 	struct nsim_bus_dev *nsim_bus_dev = nsim_dev->nsim_bus_dev;
+ 	struct devlink *devlink;
+ 	int err;
+ 
+ 	devlink = priv_to_devlink(nsim_dev);
+ 	nsim_dev = devlink_priv(devlink);
+ 	INIT_LIST_HEAD(&nsim_dev->port_list);
+ 	mutex_init(&nsim_dev->port_list_lock);
+ 	nsim_dev->fw_update_status = true;
+ 
+ 	nsim_dev->fib_data = nsim_fib_create(devlink, extack);
+ 	if (IS_ERR(nsim_dev->fib_data))
+ 		return PTR_ERR(nsim_dev->fib_data);
+ 
+ 	nsim_devlink_param_load_driverinit_values(devlink);
+ 
+ 	err = nsim_dev_dummy_region_init(nsim_dev, devlink);
+ 	if (err)
+ 		goto err_fib_destroy;
+ 
+ 	err = nsim_dev_traps_init(devlink);
+ 	if (err)
+ 		goto err_dummy_region_exit;
+ 
+ 	err = nsim_dev_port_add_all(nsim_dev, nsim_bus_dev->port_count);
+ 	if (err)
+ 		goto err_traps_exit;
+ 
+ 	return 0;
+ 
+ err_traps_exit:
+ 	nsim_dev_traps_exit(devlink);
+ err_dummy_region_exit:
+ 	nsim_dev_dummy_region_exit(nsim_dev);
+ err_fib_destroy:
+ 	nsim_fib_destroy(devlink, nsim_dev->fib_data);
+ 	return err;
+ }
+ 
+ static struct nsim_dev *nsim_dev_create(struct nsim_bus_dev *nsim_bus_dev)
+ {
+ 	struct nsim_dev *nsim_dev;
+ 	struct devlink *devlink;
+ 	int err;
+ 
+ 	devlink = devlink_alloc(&nsim_dev_devlink_ops, sizeof(*nsim_dev));
+ 	if (!devlink)
+ 		return ERR_PTR(-ENOMEM);
+ 	nsim_dev = devlink_priv(devlink);
+ 	nsim_dev->nsim_bus_dev = nsim_bus_dev;
+ 	nsim_dev->switch_id.id_len = sizeof(nsim_dev->switch_id.id);
+ 	get_random_bytes(nsim_dev->switch_id.id, nsim_dev->switch_id.id_len);
+ 	INIT_LIST_HEAD(&nsim_dev->port_list);
+ 	mutex_init(&nsim_dev->port_list_lock);
+ 	nsim_dev->fw_update_status = true;
+ 	nsim_dev->max_macs = NSIM_DEV_MAX_MACS_DEFAULT;
+ 	nsim_dev->test1 = NSIM_DEV_TEST1_DEFAULT;
+ 
+ 	err = nsim_dev_resources_register(devlink);
+ 	if (err)
+ 		goto err_devlink_free;
+ 
+ 	nsim_dev->fib_data = nsim_fib_create(devlink, NULL);
+ 	if (IS_ERR(nsim_dev->fib_data)) {
+ 		err = PTR_ERR(nsim_dev->fib_data);
+ 		goto err_resources_unregister;
+ 	}
+ 
+ 	err = devlink_register(devlink, &nsim_bus_dev->dev);
+ 	if (err)
+ 		goto err_fib_destroy;
+ 
+ 	err = devlink_params_register(devlink, nsim_devlink_params,
+ 				      ARRAY_SIZE(nsim_devlink_params));
+ 	if (err)
+ 		goto err_dl_unregister;
+ 	nsim_devlink_set_params_init_values(nsim_dev, devlink);
+ 
+ 	err = nsim_dev_dummy_region_init(nsim_dev, devlink);
+ 	if (err)
+ 		goto err_params_unregister;
+ 
+ 	err = nsim_dev_traps_init(devlink);
+ 	if (err)
+ 		goto err_dummy_region_exit;
+ 
+ 	err = nsim_dev_debugfs_init(nsim_dev);
+ 	if (err)
+ 		goto err_traps_exit;
+ 
+ 	err = nsim_bpf_dev_init(nsim_dev);
+ 	if (err)
+ 		goto err_debugfs_exit;
+ 
+ 	err = nsim_dev_port_add_all(nsim_dev, nsim_bus_dev->port_count);
+ 	if (err)
+ 		goto err_bpf_dev_exit;
+ 
+ 	devlink_params_publish(devlink);
+ 	return nsim_dev;
+ 
+ err_bpf_dev_exit:
+ 	nsim_bpf_dev_exit(nsim_dev);
+ err_debugfs_exit:
+ 	nsim_dev_debugfs_exit(nsim_dev);
+ err_traps_exit:
+ 	nsim_dev_traps_exit(devlink);
+ err_dummy_region_exit:
+ 	nsim_dev_dummy_region_exit(nsim_dev);
+ err_params_unregister:
+ 	devlink_params_unregister(devlink, nsim_devlink_params,
+ 				  ARRAY_SIZE(nsim_devlink_params));
+ err_dl_unregister:
+ 	devlink_unregister(devlink);
+ err_fib_destroy:
+ 	nsim_fib_destroy(devlink, nsim_dev->fib_data);
+ err_resources_unregister:
+ 	devlink_resources_unregister(devlink, NULL);
+ err_devlink_free:
+ 	devlink_free(devlink);
+ 	return ERR_PTR(err);
+ }
+ 
+ static void nsim_dev_reload_destroy(struct nsim_dev *nsim_dev)
+ {
+ 	struct devlink *devlink = priv_to_devlink(nsim_dev);
+ 
+ 	if (devlink_is_reload_failed(devlink))
+ 		return;
+ 	nsim_dev_port_del_all(nsim_dev);
+ 	nsim_dev_traps_exit(devlink);
+ 	nsim_dev_dummy_region_exit(nsim_dev);
+ 	mutex_destroy(&nsim_dev->port_list_lock);
+ 	nsim_fib_destroy(devlink, nsim_dev->fib_data);
+ }
+ 
+ static void nsim_dev_destroy(struct nsim_dev *nsim_dev)
+ {
+ 	struct devlink *devlink = priv_to_devlink(nsim_dev);
+ 
+ 	nsim_dev_reload_destroy(nsim_dev);
+ 
+ 	nsim_bpf_dev_exit(nsim_dev);
+ 	nsim_dev_debugfs_exit(nsim_dev);
+ 	devlink_params_unregister(devlink, nsim_devlink_params,
+ 				  ARRAY_SIZE(nsim_devlink_params));
+ 	devlink_unregister(devlink);
+ 	devlink_resources_unregister(devlink, NULL);
+ 	devlink_free(devlink);
++>>>>>>> 75ba029f3c07 (netdevsim: implement proper devlink reload)
  }
  
  int nsim_dev_probe(struct nsim_bus_dev *nsim_bus_dev)
diff --cc drivers/net/netdevsim/fib.c
index 1a251f76d09b,fdc682f3a09a..000000000000
--- a/drivers/net/netdevsim/fib.c
+++ b/drivers/net/netdevsim/fib.c
@@@ -64,12 -63,10 +64,16 @@@ u64 nsim_fib_get_val(struct net *net, e
  	return max ? entry->max : entry->num;
  }
  
++<<<<<<< HEAD
 +int nsim_fib_set_max(struct net *net, enum nsim_resource_id res_id, u64 val,
 +		     struct netlink_ext_ack *extack)
++=======
+ static void nsim_fib_set_max(struct nsim_fib_data *fib_data,
+ 			     enum nsim_resource_id res_id, u64 val)
++>>>>>>> 75ba029f3c07 (netdevsim: implement proper devlink reload)
  {
 +	struct nsim_fib_data *fib_data = net_generic(net, nsim_fib_net_id);
  	struct nsim_fib_entry *entry;
- 	int err = 0;
  
  	switch (res_id) {
  	case NSIM_RESOURCE_IPV4_FIB:
@@@ -199,59 -190,80 +193,126 @@@ static int nsim_fib_event_nb(struct not
  /* inconsistent dump, trying again */
  static void nsim_fib_dump_inconsistent(struct notifier_block *nb)
  {
++<<<<<<< HEAD
++=======
+ 	struct nsim_fib_data *data = container_of(nb, struct nsim_fib_data,
+ 						  fib_nb);
+ 
+ 	data->ipv4.fib.num = 0ULL;
+ 	data->ipv4.rules.num = 0ULL;
+ 	data->ipv6.fib.num = 0ULL;
+ 	data->ipv6.rules.num = 0ULL;
+ }
+ 
+ static u64 nsim_fib_ipv4_resource_occ_get(void *priv)
+ {
+ 	struct nsim_fib_data *data = priv;
+ 
+ 	return nsim_fib_get_val(data, NSIM_RESOURCE_IPV4_FIB, false);
+ }
+ 
+ static u64 nsim_fib_ipv4_rules_res_occ_get(void *priv)
+ {
+ 	struct nsim_fib_data *data = priv;
+ 
+ 	return nsim_fib_get_val(data, NSIM_RESOURCE_IPV4_FIB_RULES, false);
+ }
+ 
+ static u64 nsim_fib_ipv6_resource_occ_get(void *priv)
+ {
+ 	struct nsim_fib_data *data = priv;
+ 
+ 	return nsim_fib_get_val(data, NSIM_RESOURCE_IPV6_FIB, false);
+ }
+ 
+ static u64 nsim_fib_ipv6_rules_res_occ_get(void *priv)
+ {
+ 	struct nsim_fib_data *data = priv;
+ 
+ 	return nsim_fib_get_val(data, NSIM_RESOURCE_IPV6_FIB_RULES, false);
+ }
+ 
+ static void nsim_fib_set_max_all(struct nsim_fib_data *data,
+ 				 struct devlink *devlink)
+ {
+ 	enum nsim_resource_id res_ids[] = {
+ 		NSIM_RESOURCE_IPV4_FIB, NSIM_RESOURCE_IPV4_FIB_RULES,
+ 		NSIM_RESOURCE_IPV6_FIB, NSIM_RESOURCE_IPV6_FIB_RULES
+ 	};
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(res_ids); i++) {
+ 		int err;
+ 		u64 val;
+ 
+ 		err = devlink_resource_size_get(devlink, res_ids[i], &val);
+ 		if (err)
+ 			val = (u64) -1;
+ 		nsim_fib_set_max(data, res_ids[i], val);
+ 	}
+ }
+ 
+ struct nsim_fib_data *nsim_fib_create(struct devlink *devlink,
+ 				      struct netlink_ext_ack *extack)
+ {
++>>>>>>> 75ba029f3c07 (netdevsim: implement proper devlink reload)
  	struct nsim_fib_data *data;
 -	int err;
 +	struct net *net;
  
 -	data = kzalloc(sizeof(*data), GFP_KERNEL);
 -	if (!data)
 -		return ERR_PTR(-ENOMEM);
 +	rcu_read_lock();
 +	for_each_net_rcu(net) {
 +		data = net_generic(net, nsim_fib_net_id);
 +
 +		data->ipv4.fib.num = 0ULL;
 +		data->ipv4.rules.num = 0ULL;
 +
 +		data->ipv6.fib.num = 0ULL;
 +		data->ipv6.rules.num = 0ULL;
 +	}
 +	rcu_read_unlock();
 +}
 +
 +static struct notifier_block nsim_fib_nb = {
 +	.notifier_call = nsim_fib_event_nb,
 +};
 +
 +/* Initialize per network namespace state */
 +static int __net_init nsim_fib_netns_init(struct net *net)
 +{
 +	struct nsim_fib_data *data = net_generic(net, nsim_fib_net_id);
  
- 	data->ipv4.fib.max = (u64)-1;
- 	data->ipv4.rules.max = (u64)-1;
- 
- 	data->ipv6.fib.max = (u64)-1;
- 	data->ipv6.rules.max = (u64)-1;
+ 	nsim_fib_set_max_all(data, devlink);
  
++<<<<<<< HEAD
 +	return 0;
 +}
 +
 +static struct pernet_operations nsim_fib_net_ops = {
 +	.init = nsim_fib_netns_init,
 +	.id   = &nsim_fib_net_id,
 +	.size = sizeof(struct nsim_fib_data),
 +};
 +
 +void nsim_fib_exit(void)
 +{
 +	unregister_fib_notifier(&nsim_fib_nb);
 +	unregister_pernet_subsys(&nsim_fib_net_ops);
 +}
 +
 +int nsim_fib_init(void)
 +{
 +	int err;
 +
 +	err = register_pernet_subsys(&nsim_fib_net_ops);
 +	if (err < 0) {
 +		pr_err("Failed to register pernet subsystem\n");
++=======
+ 	data->fib_nb.notifier_call = nsim_fib_event_nb;
+ 	err = register_fib_notifier(&init_net, &data->fib_nb,
+ 				    nsim_fib_dump_inconsistent, extack);
+ 	if (err) {
+ 		pr_err("Failed to register fib notifier\n");
++>>>>>>> 75ba029f3c07 (netdevsim: implement proper devlink reload)
  		goto err_out;
  	}
  
diff --cc drivers/net/netdevsim/netdevsim.h
index 66bf13765ad0,702d951fe160..000000000000
--- a/drivers/net/netdevsim/netdevsim.h
+++ b/drivers/net/netdevsim/netdevsim.h
@@@ -173,11 -173,11 +173,19 @@@ int nsim_dev_port_add(struct nsim_bus_d
  int nsim_dev_port_del(struct nsim_bus_dev *nsim_bus_dev,
  		      unsigned int port_index);
  
++<<<<<<< HEAD
 +int nsim_fib_init(void);
 +void nsim_fib_exit(void);
 +u64 nsim_fib_get_val(struct net *net, enum nsim_resource_id res_id, bool max);
 +int nsim_fib_set_max(struct net *net, enum nsim_resource_id res_id, u64 val,
 +		     struct netlink_ext_ack *extack);
++=======
+ struct nsim_fib_data *nsim_fib_create(struct devlink *devlink,
+ 				      struct netlink_ext_ack *extack);
+ void nsim_fib_destroy(struct devlink *devlink, struct nsim_fib_data *fib_data);
+ u64 nsim_fib_get_val(struct nsim_fib_data *fib_data,
+ 		     enum nsim_resource_id res_id, bool max);
++>>>>>>> 75ba029f3c07 (netdevsim: implement proper devlink reload)
  
  #if IS_ENABLED(CONFIG_XFRM_OFFLOAD)
  void nsim_ipsec_init(struct netdevsim *ns);
* Unmerged path drivers/net/netdevsim/dev.c
* Unmerged path drivers/net/netdevsim/fib.c
* Unmerged path drivers/net/netdevsim/netdevsim.h
