libceph: move away from global osd_req_flags

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ilya Dryomov <idryomov@gmail.com>
commit 22d2cfdffa5bff3566e16cb7320e13ceb814674b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/22d2cfdf.failed

osd_req_flags is overly general and doesn't suit its only user
(read_from_replica option) well:

- applying osd_req_flags in account_request() affects all OSD
  requests, including linger (i.e. watch and notify).  However,
  linger requests should always go to the primary even though
  some of them are reads (e.g. notify has side effects but it
  is a read because it doesn't result in mutation on the OSDs).

- calls to class methods that are reads are allowed to go to
  the replica, but most such calls issued for "rbd map" and/or
  exclusive lock transitions are requested to be resent to the
  primary via EAGAIN, doubling the latency.

Get rid of global osd_req_flags and set read_from_replica flag
only on specific OSD requests instead.

Fixes: 8ad44d5e0d1e ("libceph: read_from_replica option")
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
(cherry picked from commit 22d2cfdffa5bff3566e16cb7320e13ceb814674b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/ceph/libceph.h
#	net/ceph/ceph_common.c
diff --cc include/linux/ceph/libceph.h
index 8502dfc84465,e5ed1c541e7f..000000000000
--- a/include/linux/ceph/libceph.h
+++ b/include/linux/ceph/libceph.h
@@@ -52,6 -52,7 +52,10 @@@ struct ceph_options 
  	unsigned long osd_idle_ttl;		/* jiffies */
  	unsigned long osd_keepalive_timeout;	/* jiffies */
  	unsigned long osd_request_timeout;	/* jiffies */
++<<<<<<< HEAD
++=======
+ 	u32 read_from_replica;  /* CEPH_OSD_FLAG_BALANCE/LOCALIZE_READS */
++>>>>>>> 22d2cfdffa5b (libceph: move away from global osd_req_flags)
  
  	/*
  	 * any type that can't be simply compared or doesn't need
diff --cc net/ceph/ceph_common.c
index 9994af52dfb4,4e7edd707a14..000000000000
--- a/net/ceph/ceph_common.c
+++ b/net/ceph/ceph_common.c
@@@ -275,33 -274,69 +275,93 @@@ enum 
  	Opt_abort_on_full,
  };
  
 -enum {
 -	Opt_read_from_replica_no,
 -	Opt_read_from_replica_balance,
 -	Opt_read_from_replica_localize,
 +static match_table_t opt_tokens = {
 +	{Opt_osdtimeout, "osdtimeout=%d"},
 +	{Opt_osdkeepalivetimeout, "osdkeepalive=%d"},
 +	{Opt_mount_timeout, "mount_timeout=%d"},
 +	{Opt_osd_idle_ttl, "osd_idle_ttl=%d"},
 +	{Opt_osd_request_timeout, "osd_request_timeout=%d"},
 +	/* int args above */
 +	{Opt_fsid, "fsid=%s"},
 +	{Opt_name, "name=%s"},
 +	{Opt_secret, "secret=%s"},
 +	{Opt_key, "key=%s"},
 +	{Opt_ip, "ip=%s"},
 +	/* string args above */
 +	{Opt_share, "share"},
 +	{Opt_noshare, "noshare"},
 +	{Opt_crc, "crc"},
 +	{Opt_nocrc, "nocrc"},
 +	{Opt_cephx_require_signatures, "cephx_require_signatures"},
 +	{Opt_nocephx_require_signatures, "nocephx_require_signatures"},
 +	{Opt_cephx_sign_messages, "cephx_sign_messages"},
 +	{Opt_nocephx_sign_messages, "nocephx_sign_messages"},
 +	{Opt_tcp_nodelay, "tcp_nodelay"},
 +	{Opt_notcp_nodelay, "notcp_nodelay"},
 +	{Opt_abort_on_full, "abort_on_full"},
 +	{-1, NULL}
  };
  
++<<<<<<< HEAD
++=======
+ static const struct constant_table ceph_param_read_from_replica[] = {
+ 	{"no",		Opt_read_from_replica_no},
+ 	{"balance",	Opt_read_from_replica_balance},
+ 	{"localize",	Opt_read_from_replica_localize},
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec ceph_parameters[] = {
+ 	fsparam_flag	("abort_on_full",		Opt_abort_on_full),
+ 	fsparam_flag_no ("cephx_require_signatures",	Opt_cephx_require_signatures),
+ 	fsparam_flag_no ("cephx_sign_messages",		Opt_cephx_sign_messages),
+ 	fsparam_flag_no ("crc",				Opt_crc),
+ 	fsparam_string	("crush_location",		Opt_crush_location),
+ 	fsparam_string	("fsid",			Opt_fsid),
+ 	fsparam_string	("ip",				Opt_ip),
+ 	fsparam_string	("key",				Opt_key),
+ 	fsparam_u32	("mount_timeout",		Opt_mount_timeout),
+ 	fsparam_string	("name",			Opt_name),
+ 	fsparam_u32	("osd_idle_ttl",		Opt_osd_idle_ttl),
+ 	fsparam_u32	("osd_request_timeout",		Opt_osd_request_timeout),
+ 	fsparam_u32	("osdkeepalive",		Opt_osdkeepalivetimeout),
+ 	__fsparam	(fs_param_is_s32, "osdtimeout", Opt_osdtimeout,
+ 			 fs_param_deprecated, NULL),
+ 	fsparam_enum	("read_from_replica",		Opt_read_from_replica,
+ 			 ceph_param_read_from_replica),
+ 	fsparam_string	("secret",			Opt_secret),
+ 	fsparam_flag_no ("share",			Opt_share),
+ 	fsparam_flag_no ("tcp_nodelay",			Opt_tcp_nodelay),
+ 	{}
+ };
+ 
+ struct ceph_options *ceph_alloc_options(void)
+ {
+ 	struct ceph_options *opt;
+ 
+ 	opt = kzalloc(sizeof(*opt), GFP_KERNEL);
+ 	if (!opt)
+ 		return NULL;
+ 
+ 	opt->crush_locs = RB_ROOT;
+ 	opt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),
+ 				GFP_KERNEL);
+ 	if (!opt->mon_addr) {
+ 		kfree(opt);
+ 		return NULL;
+ 	}
+ 
+ 	opt->flags = CEPH_OPT_DEFAULT;
+ 	opt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;
+ 	opt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;
+ 	opt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;
+ 	opt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;
+ 	opt->read_from_replica = CEPH_READ_FROM_REPLICA_DEFAULT;
+ 	return opt;
+ }
+ EXPORT_SYMBOL(ceph_alloc_options);
+ 
++>>>>>>> 22d2cfdffa5b (libceph: move away from global osd_req_flags)
  void ceph_destroy_options(struct ceph_options *opt)
  {
  	dout("destroy_options %p\n", opt);
@@@ -360,217 -401,184 +420,273 @@@ out
  	return err;
  }
  
 -int ceph_parse_mon_ips(const char *buf, size_t len, struct ceph_options *opt,
 -		       struct fc_log *l)
 +struct ceph_options *
 +ceph_parse_options(char *options, const char *dev_name,
 +			const char *dev_name_end,
 +			int (*parse_extra_token)(char *c, void *private),
 +			void *private)
  {
 -	struct p_log log = {.prefix = "libceph", .log = l};
 -	int ret;
 +	struct ceph_options *opt;
 +	const char *c;
 +	int err = -ENOMEM;
 +	substring_t argstr[MAX_OPT_ARGS];
  
 -	/* ip1[:port1][,ip2[:port2]...] */
 -	ret = ceph_parse_ips(buf, buf + len, opt->mon_addr, CEPH_MAX_MON,
 -			     &opt->num_mon);
 -	if (ret) {
 -		error_plog(&log, "Failed to parse monitor IPs: %d", ret);
 -		return ret;
 -	}
 +	opt = kzalloc(sizeof(*opt), GFP_KERNEL);
 +	if (!opt)
 +		return ERR_PTR(-ENOMEM);
 +	opt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),
 +				GFP_KERNEL);
 +	if (!opt->mon_addr)
 +		goto out;
  
 -	return 0;
 -}
 -EXPORT_SYMBOL(ceph_parse_mon_ips);
 +	dout("parse_options %p options '%s' dev_name '%s'\n", opt, options,
 +	     dev_name);
  
 -int ceph_parse_param(struct fs_parameter *param, struct ceph_options *opt,
 -		     struct fc_log *l)
 -{
 -	struct fs_parse_result result;
 -	int token, err;
 -	struct p_log log = {.prefix = "libceph", .log = l};
 -
 -	token = __fs_parse(&log, ceph_parameters, param, &result);
 -	dout("%s fs_parse '%s' token %d\n", __func__, param->key, token);
 -	if (token < 0)
 -		return token;
 -
 -	switch (token) {
 -	case Opt_ip:
 -		err = ceph_parse_ips(param->string,
 -				     param->string + param->size,
 -				     &opt->my_addr,
 -				     1, NULL);
 -		if (err) {
 -			error_plog(&log, "Failed to parse ip: %d", err);
 -			return err;
 -		}
 -		opt->flags |= CEPH_OPT_MYIP;
 -		break;
 +	/* start with defaults */
 +	opt->flags = CEPH_OPT_DEFAULT;
 +	opt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;
 +	opt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;
 +	opt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;
 +	opt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;
  
 -	case Opt_fsid:
 -		err = parse_fsid(param->string, &opt->fsid);
 -		if (err) {
 -			error_plog(&log, "Failed to parse fsid: %d", err);
 -			return err;
 +	/* get mon ip(s) */
 +	/* ip1[:port1][,ip2[:port2]...] */
 +	err = ceph_parse_ips(dev_name, dev_name_end, opt->mon_addr,
 +			     CEPH_MAX_MON, &opt->num_mon);
 +	if (err < 0)
 +		goto out;
 +
 +	/* parse mount options */
 +	while ((c = strsep(&options, ",")) != NULL) {
 +		int token, intval;
 +		if (!*c)
 +			continue;
 +		err = -EINVAL;
 +		token = match_token((char *)c, opt_tokens, argstr);
 +		if (token < 0 && parse_extra_token) {
 +			/* extra? */
 +			err = parse_extra_token((char *)c, private);
 +			if (err < 0) {
 +				pr_err("bad option at '%s'\n", c);
 +				goto out;
 +			}
 +			continue;
  		}
 +		if (token < Opt_last_int) {
 +			err = match_int(&argstr[0], &intval);
 +			if (err < 0) {
 +				pr_err("bad option arg (not int) at '%s'\n", c);
 +				goto out;
 +			}
 +			dout("got int token %d val %d\n", token, intval);
 +		} else if (token > Opt_last_int && token < Opt_last_string) {
 +			dout("got string token %d val %s\n", token,
 +			     argstr[0].from);
 +		} else {
 +			dout("got token %d\n", token);
 +		}
++<<<<<<< HEAD
 +		switch (token) {
 +		case Opt_ip:
 +			err = ceph_parse_ips(argstr[0].from,
 +					     argstr[0].to,
 +					     &opt->my_addr,
 +					     1, NULL);
 +			if (err < 0)
 +				goto out;
 +			opt->flags |= CEPH_OPT_MYIP;
 +			break;
++=======
+ 		opt->flags |= CEPH_OPT_FSID;
+ 		break;
+ 	case Opt_name:
+ 		kfree(opt->name);
+ 		opt->name = param->string;
+ 		param->string = NULL;
+ 		break;
+ 	case Opt_secret:
+ 		ceph_crypto_key_destroy(opt->key);
+ 		kfree(opt->key);
+ 
+ 		opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
+ 		if (!opt->key)
+ 			return -ENOMEM;
+ 		err = ceph_crypto_key_unarmor(opt->key, param->string);
+ 		if (err) {
+ 			error_plog(&log, "Failed to parse secret: %d", err);
+ 			return err;
+ 		}
+ 		break;
+ 	case Opt_key:
+ 		ceph_crypto_key_destroy(opt->key);
+ 		kfree(opt->key);
+ 
+ 		opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
+ 		if (!opt->key)
+ 			return -ENOMEM;
+ 		return get_secret(opt->key, param->string, &log);
+ 	case Opt_crush_location:
+ 		ceph_clear_crush_locs(&opt->crush_locs);
+ 		err = ceph_parse_crush_location(param->string,
+ 						&opt->crush_locs);
+ 		if (err) {
+ 			error_plog(&log, "Failed to parse CRUSH location: %d",
+ 				   err);
+ 			return err;
+ 		}
+ 		break;
+ 	case Opt_read_from_replica:
+ 		switch (result.uint_32) {
+ 		case Opt_read_from_replica_no:
+ 			opt->read_from_replica = 0;
+ 			break;
+ 		case Opt_read_from_replica_balance:
+ 			opt->read_from_replica = CEPH_OSD_FLAG_BALANCE_READS;
+ 			break;
+ 		case Opt_read_from_replica_localize:
+ 			opt->read_from_replica = CEPH_OSD_FLAG_LOCALIZE_READS;
+ 			break;
+ 		default:
+ 			BUG();
+ 		}
+ 		break;
++>>>>>>> 22d2cfdffa5b (libceph: move away from global osd_req_flags)
  
 -	case Opt_osdtimeout:
 -		warn_plog(&log, "Ignoring osdtimeout");
 -		break;
 -	case Opt_osdkeepalivetimeout:
 -		/* 0 isn't well defined right now, reject it */
 -		if (result.uint_32 < 1 || result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_keepalive_timeout =
 -		    msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_osd_idle_ttl:
 -		/* 0 isn't well defined right now, reject it */
 -		if (result.uint_32 < 1 || result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_idle_ttl = msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_mount_timeout:
 -		/* 0 is "wait forever" (i.e. infinite timeout) */
 -		if (result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->mount_timeout = msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_osd_request_timeout:
 -		/* 0 is "wait forever" (i.e. infinite timeout) */
 -		if (result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_request_timeout =
 -		    msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 +		case Opt_fsid:
 +			err = parse_fsid(argstr[0].from, &opt->fsid);
 +			if (err == 0)
 +				opt->flags |= CEPH_OPT_FSID;
 +			break;
 +		case Opt_name:
 +			kfree(opt->name);
 +			opt->name = kstrndup(argstr[0].from,
 +					      argstr[0].to-argstr[0].from,
 +					      GFP_KERNEL);
 +			if (!opt->name) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			break;
 +		case Opt_secret:
 +			ceph_crypto_key_destroy(opt->key);
 +			kfree(opt->key);
 +
 +		        opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 +			if (!opt->key) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			err = ceph_crypto_key_unarmor(opt->key, argstr[0].from);
 +			if (err < 0)
 +				goto out;
 +			break;
 +		case Opt_key:
 +			ceph_crypto_key_destroy(opt->key);
 +			kfree(opt->key);
 +
 +		        opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 +			if (!opt->key) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			err = get_secret(opt->key, argstr[0].from);
 +			if (err < 0)
 +				goto out;
 +			break;
 +
 +			/* misc */
 +		case Opt_osdtimeout:
 +			pr_warn("ignoring deprecated osdtimeout option\n");
 +			break;
 +		case Opt_osdkeepalivetimeout:
 +			/* 0 isn't well defined right now, reject it */
 +			if (intval < 1 || intval > INT_MAX / 1000) {
 +				pr_err("osdkeepalive out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_keepalive_timeout =
 +					msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_osd_idle_ttl:
 +			/* 0 isn't well defined right now, reject it */
 +			if (intval < 1 || intval > INT_MAX / 1000) {
 +				pr_err("osd_idle_ttl out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_idle_ttl = msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_mount_timeout:
 +			/* 0 is "wait forever" (i.e. infinite timeout) */
 +			if (intval < 0 || intval > INT_MAX / 1000) {
 +				pr_err("mount_timeout out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->mount_timeout = msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_osd_request_timeout:
 +			/* 0 is "wait forever" (i.e. infinite timeout) */
 +			if (intval < 0 || intval > INT_MAX / 1000) {
 +				pr_err("osd_request_timeout out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_request_timeout = msecs_to_jiffies(intval * 1000);
 +			break;
  
 -	case Opt_share:
 -		if (!result.negated)
 +		case Opt_share:
  			opt->flags &= ~CEPH_OPT_NOSHARE;
 -		else
 +			break;
 +		case Opt_noshare:
  			opt->flags |= CEPH_OPT_NOSHARE;
 -		break;
 -	case Opt_crc:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_crc:
  			opt->flags &= ~CEPH_OPT_NOCRC;
 -		else
 +			break;
 +		case Opt_nocrc:
  			opt->flags |= CEPH_OPT_NOCRC;
 -		break;
 -	case Opt_cephx_require_signatures:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_cephx_require_signatures:
  			opt->flags &= ~CEPH_OPT_NOMSGAUTH;
 -		else
 +			break;
 +		case Opt_nocephx_require_signatures:
  			opt->flags |= CEPH_OPT_NOMSGAUTH;
 -		break;
 -	case Opt_cephx_sign_messages:
 -		if (!result.negated)
 +			break;
 +		case Opt_cephx_sign_messages:
  			opt->flags &= ~CEPH_OPT_NOMSGSIGN;
 -		else
 +			break;
 +		case Opt_nocephx_sign_messages:
  			opt->flags |= CEPH_OPT_NOMSGSIGN;
 -		break;
 -	case Opt_tcp_nodelay:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_tcp_nodelay:
  			opt->flags |= CEPH_OPT_TCP_NODELAY;
 -		else
 +			break;
 +		case Opt_notcp_nodelay:
  			opt->flags &= ~CEPH_OPT_TCP_NODELAY;
 -		break;
 +			break;
  
 -	case Opt_abort_on_full:
 -		opt->flags |= CEPH_OPT_ABORT_ON_FULL;
 -		break;
 +		case Opt_abort_on_full:
 +			opt->flags |= CEPH_OPT_ABORT_ON_FULL;
 +			break;
  
 -	default:
 -		BUG();
 +		default:
 +			BUG_ON(token);
 +		}
  	}
  
 -	return 0;
 +	/* success */
 +	return opt;
  
 -out_of_range:
 -	return inval_plog(&log, "%s out of range", param->key);
 +out:
 +	ceph_destroy_options(opt);
 +	return ERR_PTR(err);
  }
 -EXPORT_SYMBOL(ceph_parse_param);
 +EXPORT_SYMBOL(ceph_parse_options);
  
  int ceph_print_client_options(struct seq_file *m, struct ceph_client *client,
  			      bool show_all)
@@@ -586,6 -595,28 +702,31 @@@
  	if (opt->key)
  		seq_puts(m, "secret=<hidden>,");
  
++<<<<<<< HEAD
++=======
+ 	if (!RB_EMPTY_ROOT(&opt->crush_locs)) {
+ 		seq_puts(m, "crush_location=");
+ 		for (n = rb_first(&opt->crush_locs); ; ) {
+ 			struct crush_loc_node *loc =
+ 			    rb_entry(n, struct crush_loc_node, cl_node);
+ 
+ 			seq_printf(m, "%s:%s", loc->cl_loc.cl_type_name,
+ 				   loc->cl_loc.cl_name);
+ 			n = rb_next(n);
+ 			if (!n)
+ 				break;
+ 
+ 			seq_putc(m, '|');
+ 		}
+ 		seq_putc(m, ',');
+ 	}
+ 	if (opt->read_from_replica == CEPH_OSD_FLAG_BALANCE_READS) {
+ 		seq_puts(m, "read_from_replica=balance,");
+ 	} else if (opt->read_from_replica == CEPH_OSD_FLAG_LOCALIZE_READS) {
+ 		seq_puts(m, "read_from_replica=localize,");
+ 	}
+ 
++>>>>>>> 22d2cfdffa5b (libceph: move away from global osd_req_flags)
  	if (opt->flags & CEPH_OPT_FSID)
  		seq_printf(m, "fsid=%pU,", &opt->fsid);
  	if (opt->flags & CEPH_OPT_NOSHARE)
diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c
index 6a6ed999b02e..31d2b217cc6f 100644
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@ -1514,8 +1514,10 @@ static void rbd_osd_req_callback(struct ceph_osd_request *osd_req)
 static void rbd_osd_format_read(struct ceph_osd_request *osd_req)
 {
 	struct rbd_obj_request *obj_request = osd_req->r_priv;
+	struct rbd_device *rbd_dev = obj_request->img_request->rbd_dev;
+	struct ceph_options *opt = rbd_dev->rbd_client->client->options;
 
-	osd_req->r_flags = CEPH_OSD_FLAG_READ;
+	osd_req->r_flags = CEPH_OSD_FLAG_READ | opt->read_from_replica;
 	osd_req->r_snapid = obj_request->img_request->snap_id;
 }
 
* Unmerged path include/linux/ceph/libceph.h
* Unmerged path net/ceph/ceph_common.c
diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c
index 060162db6ce0..4d15095ffb73 100644
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@ -1117,10 +1117,10 @@ struct ceph_osd_request *ceph_osdc_new_request(struct ceph_osd_client *osdc,
 				       truncate_size, truncate_seq);
 	}
 
-	req->r_flags = flags;
 	req->r_base_oloc.pool = layout->pool_id;
 	req->r_base_oloc.pool_ns = ceph_try_get_string(layout->pool_ns);
 	ceph_oid_printf(&req->r_base_oid, "%llx.%08llx", vino.ino, objnum);
+	req->r_flags = flags | osdc->client->options->read_from_replica;
 
 	req->r_snapid = vino.snap;
 	if (flags & CEPH_OSD_FLAG_WRITE)
