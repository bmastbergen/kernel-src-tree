ext4: fix prefetchw of NULL page

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Liu Xiang <liu.xiang6@zte.com.cn>
commit d454a27384f6eb05904a59d1607461b7ad312aa9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d454a273.failed

In ext4_mpage_readpages(), if the parameter pages is not NULL, another
parameter page is NULL. At the first time prefetchw(&page->flags)
works on NULL. From second time, prefetchw(&page->flags) always works on
the last consumed page. This might do little improvment for handling
current page. So prefetchw() should be called while the page pointer
has just been updated.

	Signed-off-by: Liu Xiang <liu.xiang6@zte.com.cn>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit d454a27384f6eb05904a59d1607461b7ad312aa9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/readpage.c
diff --cc fs/ext4/readpage.c
index 7e9809dd8ae1,9386b0446afb..000000000000
--- a/fs/ext4/readpage.c
+++ b/fs/ext4/readpage.c
@@@ -126,9 -127,10 +126,14 @@@ int ext4_mpage_readpages(struct address
  		int fully_mapped = 1;
  		unsigned first_hole = blocks_per_page;
  
- 		prefetchw(&page->flags);
  		if (pages) {
++<<<<<<< HEAD
 +			page = list_entry(pages->prev, struct page, lru);
++=======
+ 			page = lru_to_page(pages);
+ 
+ 			prefetchw(&page->flags);
++>>>>>>> d454a27384f6 (ext4: fix prefetchw of NULL page)
  			list_del(&page->lru);
  			if (add_to_page_cache_lru(page, mapping, page->index,
  				  readahead_gfp_mask(mapping)))
* Unmerged path fs/ext4/readpage.c
