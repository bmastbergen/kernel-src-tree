drm/i915: Add missing deinitialization cases of load failure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit c0ff9e5e69f33ce5051f33cc4cb35afa754de01c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c0ff9e5e.failed

The intel_display_power_put_async() used in TC cold sequences made
easy to hit the missing deinitialization of driver in case of load
failure as seen in the stack trace bellow.

intel_modeset_driver_remove_noirq() had to be removed from
i915_driver_modeset_remove_noirq() as those are different
initialialition steps with IRQ and GEM initialization in between then.

[drm:__intel_engine_init_ctx_wa [i915]] Initialized 3 context workarounds on rcs'0
[drm:__i915_inject_probe_error [i915]] Injecting failure -19 at checkpoint 36 [__uc_init:294]
[drm:i915_hdcp_component_unbind [i915]] I915 HDCP comp unbind
[drm:edp_panel_vdd_off_sync [i915]] Turning [ENCODER:275:DDI A] VDD off
[drm:edp_panel_vdd_off_sync [i915]] PP_STATUS: 0x00000000 PP_CONTROL: 0x00000060
[drm:intel_power_well_disable [i915]] disabling AUX A
general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b6b: 0000 [#1] PREEMPT SMP NOPTI
CPU: 3 PID: 1142 Comm: kworker/u16:20 Tainted: G     U            5.6.0-CI-Patchwork_17226+ #1
Hardware name: Intel Corporation Tiger Lake Client Platform/TigerLake U DDR4 SODIMM RVP, BIOS TGLSFWI1.R00.2457.A16.1912270059 12/27/2019
Workqueue: events_unbound intel_display_power_put_async_work [i915]
RIP: 0010:__intel_display_power_put_domain+0xa5/0x180 [i915]
Code: 48 85 c0 78 54 44 89 e1 41 bd 01 00 00 00 49 c7 c4 80 44 41 a0 49 d3 e5 eb 0d 48 83 eb 10 48 3b 9d 08 ad 00 00 78 32 48 8b 03 <4c> 85 68 10 74 ea 8b 53 08 85 d2 74 2d 83 ea 01 85 d2 89 53 08 75
RSP: 0018:ffffc9000061fdb0 EFLAGS: 00010206
RAX: 6b6b6b6b6b6b6b6b RBX: ffff8884948f5df0 RCX: 000000000000003d
RDX: 0000000080000001 RSI: 0000000000000000 RDI: 0000000000000000
RBP: ffff888479be0000 R08: ffff88849a180920 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000000 R12: ffffffffa0414480
R13: 2000000000000000 R14: ffff888479beb320 R15: 2000000000000000
FS:  0000000000000000(0000) GS:ffff88849ff80000(0000) knlGS:0000000000000000
CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
CR2: 00005634fa8ed670 CR3: 0000000005610004 CR4: 0000000000760ee0
PKRU: 55555554
Call Trace:
 release_async_put_domains+0x9b/0x110 [i915]
 intel_display_power_put_async_work+0x91/0xf0 [i915]
 process_one_work+0x260/0x600
 ? worker_thread+0xc9/0x380
 worker_thread+0x37/0x380
 ? process_one_work+0x600/0x600
 kthread+0x119/0x130
 ? kthread_park+0x80/0x80
 ret_from_fork+0x24/0x50
Modules linked in: i915(+) vgem snd_hda_codec_hdmi mei_hdcp x86_pkg_temp_thermal coretemp crct10dif_pclmul crc32_pclmul cdc_ether usbnet mii snd_intel_dspcfg ghash_clmulni_intel snd_hda_codec snd_hwdep snd_hda_core e1000e ptp mei_me snd_pcm pps_core mei intel_lpss_pci prime_numbers [last unloaded: i915]
---[ end trace b402d1b4060f8b97 ]---
BUG: sleeping function called from invalid context at kernel/sched/completion.c:99
in_atomic(): 0, irqs_disabled(): 0, non_block: 0, pid: 1142, name: kworker/u16:20
INFO: lockdep is turned off.
Preemption disabled at:
[<0000000000000000>] 0x0
CPU: 3 PID: 1142 Comm: kworker/u16:20 Tainted: G     UD           5.6.0-CI-Patchwork_17226+ #1
Hardware name: Intel Corporation Tiger Lake Client Platform/TigerLake U DDR4 SODIMM RVP, BIOS TGLSFWI1.R00.2457.A16.1912270059 12/27/2019
Workqueue: events_unbound intel_display_power_put_async_work [i915]
Call Trace:
 dump_stack+0x71/0x9b
 ___might_sleep+0x178/0x260
 wait_for_completion+0x37/0x1a0
 virt_efi_query_variable_info+0x161/0x1b0
 efi_query_variable_store+0xb3/0x1a0
 ? efivar_entry_set_safe+0x19c/0x220
 efivar_entry_set_safe+0x19c/0x220
 ? efi_pstore_write+0x10b/0x150
 ? efi_pstore_write+0xa0/0x150
 efi_pstore_write+0x10b/0x150
 pstore_dump+0x123/0x340
 kmsg_dump+0x87/0x1b0
 oops_end+0x3e/0x90
 do_general_protection+0x1c3/0x2f0
 general_protection+0x2d/0x40
RIP: 0010:__intel_display_power_put_domain+0xa5/0x180 [i915]
Code: 48 85 c0 78 54 44 89 e1 41 bd 01 00 00 00 49 c7 c4 80 44 41 a0 49 d3 e5 eb 0d 48 83 eb 10 48 3b 9d 08 ad 00 00 78 32 48 8b 03 <4c> 85 68 10 74 ea 8b 53 08 85 d2 74 2d 83 ea 01 85 d2 89 53 08 75
RSP: 0018:ffffc9000061fdb0 EFLAGS: 00010206
RAX: 6b6b6b6b6b6b6b6b RBX: ffff8884948f5df0 RCX: 000000000000003d
RDX: 0000000080000001 RSI: 0000000000000000 RDI: 0000000000000000
RBP: ffff888479be0000 R08: ffff88849a180920 R09: 0000000000000000
R10: 0000000000000000 R11: 0000000000000000 R12: ffffffffa0414480
R13: 2000000000000000 R14: ffff888479beb320 R15: 2000000000000000
 release_async_put_domains+0x9b/0x110 [i915]
 intel_display_power_put_async_work+0x91/0xf0 [i915]
 process_one_work+0x260/0x600
 ? worker_thread+0xc9/0x380
 worker_thread+0x37/0x380
 ? process_one_work+0x600/0x600
 kthread+0x119/0x130
 ? kthread_park+0x80/0x80
 ret_from_fork+0x24/0x50
------------[ cut here ]------------
WARNING: CPU: 3 PID: 1142 at kernel/rcu/tree_plugin.h:293 rcu_note_context_switch+0x87/0x650
Modules linked in: i915(+) vgem snd_hda_codec_hdmi mei_hdcp x86_pkg_temp_thermal coretemp crct10dif_pclmul crc32_pclmul cdc_ether usbnet mii snd_intel_dspcfg ghash_clmulni_intel snd_hda_codec snd_hwdep snd_hda_core e1000e ptp mei_me snd_pcm pps_core mei intel_lpss_pci prime_numbers [last unloaded: i915]

v2:
- fixed handling in case of failure in drm_vblank_init()
- moved i915_gem_driver_remove() call to before
i915_driver_modeset_remove_noirq() this match initialization order too

v3:
- reverting call swap between i915_reset_error_state() and i915_gem_driver_remove()
call order
- improved label naming in i915_driver_modeset_probe_noirq()

Closes: https://gitlab.freedesktop.org/drm/intel/issues/1647
	Cc: Imre Deak <imre.deak@intel.com>
	Cc: Ville Syrjälä <ville.syrjala@linux.intel.com>
	Cc: Jani Nikula <jani.nikula@intel.com>
	Reviewed-by: Imre Deak <imre.deak@intel.com>
	Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>

	Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Link: https://patchwork.freedesktop.org/patch/msgid/20200416185841.125686-1-jose.souza@intel.com
(cherry picked from commit c0ff9e5e69f33ce5051f33cc4cb35afa754de01c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_drv.c
diff --cc drivers/gpu/drm/i915/i915_drv.c
index 1aa474313525,b5c4cad93a46..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@@ -625,104 -215,50 +625,121 @@@ intel_teardown_mchbar(struct drm_i915_p
  		release_resource(&dev_priv->mch_res);
  }
  
 -/* part #1: call before irq install */
 -static int i915_driver_modeset_probe_noirq(struct drm_i915_private *i915)
 +/* true = enable decode, false = disable decoder */
 +static unsigned int i915_vga_set_decode(void *cookie, bool state)
 +{
 +	struct drm_i915_private *dev_priv = cookie;
 +
 +	intel_modeset_vga_set_state(dev_priv, state);
 +	if (state)
 +		return VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM |
 +		       VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
 +	else
 +		return VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
 +}
 +
 +static int i915_resume_switcheroo(struct drm_device *dev);
 +static int i915_suspend_switcheroo(struct drm_device *dev, pm_message_t state);
 +
 +static void i915_switcheroo_set_state(struct pci_dev *pdev, enum vga_switcheroo_state state)
  {
 +	struct drm_device *dev = pci_get_drvdata(pdev);
 +	pm_message_t pmm = { .event = PM_EVENT_SUSPEND };
 +
 +	if (state == VGA_SWITCHEROO_ON) {
 +		pr_info("switched on\n");
 +		dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;
 +		/* i915 resume handler doesn't set to D0 */
 +		pci_set_power_state(pdev, PCI_D0);
 +		i915_resume_switcheroo(dev);
 +		dev->switch_power_state = DRM_SWITCH_POWER_ON;
 +	} else {
 +		pr_info("switched off\n");
 +		dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;
 +		i915_suspend_switcheroo(dev, pmm);
 +		dev->switch_power_state = DRM_SWITCH_POWER_OFF;
 +	}
 +}
 +
 +static bool i915_switcheroo_can_switch(struct pci_dev *pdev)
 +{
 +	struct drm_device *dev = pci_get_drvdata(pdev);
 +
 +	/*
 +	 * FIXME: open_count is protected by drm_global_mutex but that would lead to
 +	 * locking inversion with the driver load path. And the access here is
 +	 * completely racy anyway. So don't bother with locking for now.
 +	 */
 +	return dev->open_count == 0;
 +}
 +
 +static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 +	.set_gpu_state = i915_switcheroo_set_state,
 +	.reprobe = NULL,
 +	.can_switch = i915_switcheroo_can_switch,
 +};
 +
 +static int i915_load_modeset_init(struct drm_device *dev)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(dev);
 +	struct pci_dev *pdev = dev_priv->drm.pdev;
  	int ret;
  
 -	if (i915_inject_probe_failure(i915))
 +	if (i915_inject_load_failure())
  		return -ENODEV;
  
 -	if (HAS_DISPLAY(i915) && INTEL_DISPLAY_ENABLED(i915)) {
 -		ret = drm_vblank_init(&i915->drm,
 -				      INTEL_NUM_PIPES(i915));
 +	if (HAS_DISPLAY(dev_priv)) {
 +		ret = drm_vblank_init(&dev_priv->drm,
 +				      INTEL_INFO(dev_priv)->num_pipes);
  		if (ret)
- 			goto out;
+ 			return ret;
  	}
  
 -	intel_bios_init(i915);
 +	intel_bios_init(dev_priv);
  
++<<<<<<< HEAD
 +	/* If we have > 1 VGA cards, then we need to arbitrate access
 +	 * to the common VGA resources.
 +	 *
 +	 * If we are a secondary display controller (!PCI_DISPLAY_CLASS_VGA),
 +	 * then we do not take part in VGA arbitration and the
 +	 * vga_client_register() fails with -ENODEV.
 +	 */
 +	ret = vga_client_register(pdev, dev_priv, NULL, i915_vga_set_decode);
 +	if (ret && ret != -ENODEV)
 +		goto out;
++=======
+ 	ret = intel_vga_register(i915);
+ 	if (ret)
+ 		goto cleanup_bios;
++>>>>>>> c0ff9e5e69f3 (drm/i915: Add missing deinitialization cases of load failure)
  
 -	intel_power_domains_init_hw(i915, false);
 -
 -	intel_csr_ucode_init(i915);
 +	intel_register_dsm_handler();
  
 -	ret = intel_modeset_init_noirq(i915);
 +	ret = vga_switcheroo_register_client(pdev, &i915_switcheroo_ops, false);
  	if (ret)
- 		goto cleanup_vga_client;
+ 		goto cleanup_vga_client_pw_domain_csr;
  
 -	return 0;
 +	intel_power_domains_init_hw(dev_priv, false);
  
++<<<<<<< HEAD
 +	intel_csr_ucode_init(dev_priv);
++=======
+ cleanup_vga_client_pw_domain_csr:
+ 	intel_csr_ucode_fini(i915);
+ 	intel_power_domains_driver_remove(i915);
+ 	intel_vga_unregister(i915);
+ cleanup_bios:
+ 	intel_bios_driver_remove(i915);
+ 	return ret;
+ }
++>>>>>>> c0ff9e5e69f3 (drm/i915: Add missing deinitialization cases of load failure)
  
 -/* part #2: call after irq install */
 -static int i915_driver_modeset_probe(struct drm_i915_private *i915)
 -{
 -	int ret;
 +	ret = intel_irq_install(dev_priv);
 +	if (ret)
 +		goto cleanup_csr;
 +
 +	intel_gmbus_setup(dev_priv);
  
  	/* Important: The output setup functions called by modeset_init need
  	 * working irqs for e.g. gmbus and dp aux transfers. */
@@@ -769,29 -301,22 +786,42 @@@ out
  	return ret;
  }
  
 -/* part #1: call before irq uninstall */
 -static void i915_driver_modeset_remove(struct drm_i915_private *i915)
 +static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
  {
 -	intel_modeset_driver_remove(i915);
 -}
 +	struct apertures_struct *ap;
 +	struct pci_dev *pdev = dev_priv->drm.pdev;
 +	struct i915_ggtt *ggtt = &dev_priv->ggtt;
 +	bool primary;
 +	int ret;
 +
++<<<<<<< HEAD
 +	ap = alloc_apertures(1);
 +	if (!ap)
 +		return -ENOMEM;
  
 +	ap->ranges[0].base = ggtt->gmadr.start;
 +	ap->ranges[0].size = ggtt->mappable_end;
++=======
+ /* part #2: call after irq uninstall */
+ static void i915_driver_modeset_remove_noirq(struct drm_i915_private *i915)
+ {
+ 	intel_csr_ucode_fini(i915);
+ 
+ 	intel_power_domains_driver_remove(i915);
++>>>>>>> c0ff9e5e69f3 (drm/i915: Add missing deinitialization cases of load failure)
  
 -	intel_vga_unregister(i915);
 +	primary =
 +		pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
 +
++<<<<<<< HEAD
 +	ret = drm_fb_helper_remove_conflicting_framebuffers(ap, "inteldrmfb", primary);
  
 +	kfree(ap);
 +
 +	return ret;
++=======
+ 	intel_bios_driver_remove(i915);
++>>>>>>> c0ff9e5e69f3 (drm/i915: Add missing deinitialization cases of load failure)
  }
  
  static void intel_init_dpio(struct drm_i915_private *dev_priv)
@@@ -1927,14 -998,19 +1957,21 @@@ int i915_driver_load(struct pci_dev *pd
  
  	return 0;
  
++<<<<<<< HEAD
++=======
+ out_cleanup_irq:
+ 	intel_irq_uninstall(i915);
+ out_cleanup_modeset:
+ 	i915_driver_modeset_remove_noirq(i915);
++>>>>>>> c0ff9e5e69f3 (drm/i915: Add missing deinitialization cases of load failure)
  out_cleanup_hw:
 -	i915_driver_hw_remove(i915);
 -	intel_memory_regions_driver_release(i915);
 -	i915_ggtt_driver_release(i915);
 +	i915_driver_cleanup_hw(dev_priv);
 +	i915_ggtt_cleanup_hw(dev_priv);
  out_cleanup_mmio:
 -	i915_driver_mmio_release(i915);
 +	i915_driver_cleanup_mmio(dev_priv);
  out_runtime_pm_put:
 -	enable_rpm_wakeref_asserts(&i915->runtime_pm);
 -	i915_driver_late_release(i915);
 +	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 +	i915_driver_cleanup_early(dev_priv);
  out_pci_disable:
  	pci_disable_device(pdev);
  out_fini:
@@@ -1962,32 -1028,26 +1999,40 @@@ void i915_driver_unload(struct drm_devi
  	/* Flush any external code that still may be under the RCU lock */
  	synchronize_rcu();
  
 -	i915_gem_suspend(i915);
 +	i915_gem_suspend(dev_priv);
  
 -	drm_atomic_helper_shutdown(&i915->drm);
 +	drm_atomic_helper_shutdown(dev);
  
 -	intel_gvt_driver_remove(i915);
 +	intel_gvt_cleanup(dev_priv);
  
 -	i915_driver_modeset_remove(i915);
 +	intel_modeset_cleanup(dev);
  
 -	intel_irq_uninstall(i915);
 +	intel_bios_cleanup(dev_priv);
  
++<<<<<<< HEAD
 +	vga_switcheroo_unregister_client(pdev);
 +	vga_client_register(pdev, NULL, NULL, NULL);
++=======
+ 	intel_modeset_driver_remove_noirq(i915);
++>>>>>>> c0ff9e5e69f3 (drm/i915: Add missing deinitialization cases of load failure)
  
 -	i915_reset_error_state(i915);
 -	i915_gem_driver_remove(i915);
 +	intel_csr_ucode_fini(dev_priv);
  
++<<<<<<< HEAD
 +	/* Free error state after interrupts are fully disabled. */
 +	cancel_delayed_work_sync(&dev_priv->gpu_error.hangcheck_work);
 +	i915_reset_error_state(dev_priv);
++=======
+ 	i915_driver_modeset_remove_noirq(i915);
++>>>>>>> c0ff9e5e69f3 (drm/i915: Add missing deinitialization cases of load failure)
 +
 +	i915_gem_fini_hw(dev_priv);
 +
 +	intel_power_domains_fini_hw(dev_priv);
  
 -	i915_driver_hw_remove(i915);
 +	i915_driver_cleanup_hw(dev_priv);
  
 -	enable_rpm_wakeref_asserts(&i915->runtime_pm);
 +	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
  }
  
  static void i915_driver_release(struct drm_device *dev)
* Unmerged path drivers/gpu/drm/i915/i915_drv.c
