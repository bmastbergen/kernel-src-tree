netfilter: conntrack: make conntrack userspace helpers work again

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit ee04805ff54a63ffd90bc6749ebfe73473734ddb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ee04805f.failed

Florian Westphal says:

"Problem is that after the helper hook was merged back into the confirm
one, the queueing itself occurs from the confirm hook, i.e. we queue
from the last netfilter callback in the hook-list.

Therefore, on return, the packet bypasses the confirm action and the
connection is never committed to the main conntrack table.

To fix this there are several ways:
1. revert the 'Fixes' commit and have a extra helper hook again.
   Works, but has the drawback of adding another indirect call for
   everyone.

2. Special case this: split the hooks only when userspace helper
   gets added, so queueing occurs at a lower priority again,
   and normal enqueue reinject would eventually call the last hook.

3. Extend the existing nf_queue ct update hook to allow a forced
   confirmation (plus run the seqadj code).

This goes for 3)."

Fixes: 827318feb69cb ("netfilter: conntrack: remove helper hook again")
	Reviewed-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit ee04805ff54a63ffd90bc6749ebfe73473734ddb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_core.c
diff --cc net/netfilter/nf_conntrack_core.c
index 680e0b0d92a5,08e0c19f6b39..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -1725,34 -2016,26 +1725,36 @@@ static void nf_conntrack_attach(struct 
  	nf_conntrack_get(skb_nfct(nskb));
  }
  
- static int nf_conntrack_update(struct net *net, struct sk_buff *skb)
+ static int __nf_conntrack_update(struct net *net, struct sk_buff *skb,
+ 				 struct nf_conn *ct)
  {
 +	const struct nf_conntrack_l3proto *l3proto;
 +	const struct nf_conntrack_l4proto *l4proto;
  	struct nf_conntrack_tuple_hash *h;
  	struct nf_conntrack_tuple tuple;
  	enum ip_conntrack_info ctinfo;
  	struct nf_nat_hook *nat_hook;
++<<<<<<< HEAD
 +	unsigned int dataoff, status;
 +	struct nf_conn *ct;
++=======
+ 	unsigned int status;
+ 	int dataoff;
++>>>>>>> ee04805ff54a (netfilter: conntrack: make conntrack userspace helpers work again)
  	u16 l3num;
  	u8 l4num;
  
- 	ct = nf_ct_get(skb, &ctinfo);
- 	if (!ct || nf_ct_is_confirmed(ct))
- 		return 0;
- 
  	l3num = nf_ct_l3num(ct);
 +	l3proto = nf_ct_l3proto_find_get(l3num);
  
 -	dataoff = get_l4proto(skb, skb_network_offset(skb), l3num, &l4num);
 -	if (dataoff <= 0)
 +	if (l3proto->get_l4proto(skb, skb_network_offset(skb), &dataoff,
 +				 &l4num) <= 0)
  		return -1;
  
 +	l4proto = nf_ct_l4proto_find_get(l3num, l4num);
 +
  	if (!nf_ct_get_tuple(skb, skb_network_offset(skb), dataoff, l3num,
 -			     l4num, net, &tuple))
 +			     l4num, net, &tuple, l4proto))
  		return -1;
  
  	if (ct->status & IPS_SRC_NAT) {
* Unmerged path net/netfilter/nf_conntrack_core.c
