libbpf: Add generic bpf_program__attach()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit d7a18ea7e8b612669acd0131fd075e5c735c1ce5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d7a18ea7.failed

Generalize BPF program attaching and allow libbpf to auto-detect type (and
extra parameters, where applicable) and attach supported BPF program types
based on program sections. Currently this is supported for:
- kprobe/kretprobe;
- tracepoint;
- raw tracepoint;
- tracing programs (typed raw TP/fentry/fexit).

More types support can be trivially added within this framework.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
Link: https://lore.kernel.org/bpf/20191214014341.3442258-3-andriin@fb.com
(cherry picked from commit d7a18ea7e8b612669acd0131fd075e5c735c1ce5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
#	tools/lib/bpf/libbpf.map
diff --cc tools/lib/bpf/libbpf.c
index 729a06f61573,61b8cdf78332..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -4994,11 -5015,26 +5020,34 @@@ static const struct bpf_sec_def section
  	BPF_PROG_SEC("uretprobe/",		BPF_PROG_TYPE_KPROBE),
  	BPF_PROG_SEC("classifier",		BPF_PROG_TYPE_SCHED_CLS),
  	BPF_PROG_SEC("action",			BPF_PROG_TYPE_SCHED_ACT),
++<<<<<<< HEAD
 +	BPF_PROG_SEC("tracepoint/",		BPF_PROG_TYPE_TRACEPOINT),
 +	BPF_PROG_SEC("tp/",			BPF_PROG_TYPE_TRACEPOINT),
 +	BPF_PROG_SEC("raw_tracepoint/",		BPF_PROG_TYPE_RAW_TRACEPOINT),
 +	BPF_PROG_SEC("raw_tp/",			BPF_PROG_TYPE_RAW_TRACEPOINT),
 +	BPF_PROG_BTF("tp_btf/",			BPF_PROG_TYPE_RAW_TRACEPOINT),
++=======
+ 	SEC_DEF("tracepoint/", TRACEPOINT,
+ 		.attach_fn = attach_tp),
+ 	SEC_DEF("tp/", TRACEPOINT,
+ 		.attach_fn = attach_tp),
+ 	SEC_DEF("raw_tracepoint/", RAW_TRACEPOINT,
+ 		.attach_fn = attach_raw_tp),
+ 	SEC_DEF("raw_tp/", RAW_TRACEPOINT,
+ 		.attach_fn = attach_raw_tp),
+ 	SEC_DEF("tp_btf/", TRACING,
+ 		.expected_attach_type = BPF_TRACE_RAW_TP,
+ 		.is_attach_btf = true,
+ 		.attach_fn = attach_trace),
+ 	SEC_DEF("fentry/", TRACING,
+ 		.expected_attach_type = BPF_TRACE_FENTRY,
+ 		.is_attach_btf = true,
+ 		.attach_fn = attach_trace),
+ 	SEC_DEF("fexit/", TRACING,
+ 		.expected_attach_type = BPF_TRACE_FEXIT,
+ 		.is_attach_btf = true,
+ 		.attach_fn = attach_trace),
++>>>>>>> d7a18ea7e8b6 (libbpf: Add generic bpf_program__attach())
  	BPF_PROG_SEC("xdp",			BPF_PROG_TYPE_XDP),
  	BPF_PROG_SEC("perf_event",		BPF_PROG_TYPE_PERF_EVENT),
  	BPF_PROG_SEC("lwt_in",			BPF_PROG_TYPE_LWT_IN),
@@@ -5098,34 -5148,13 +5161,42 @@@ int libbpf_prog_type_by_name(const cha
  	if (!name)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	for (i = 0; i < ARRAY_SIZE(section_names); i++) {
 +		if (strncmp(name, section_names[i].sec, section_names[i].len))
 +			continue;
 +		*prog_type = section_names[i].prog_type;
 +		*expected_attach_type = section_names[i].expected_attach_type;
 +		if (section_names[i].is_attach_btf) {
 +			struct btf *btf = bpf_core_find_kernel_btf();
 +			char raw_tp_btf_name[128] = "btf_trace_";
 +			char *dst = raw_tp_btf_name + sizeof("btf_trace_") - 1;
 +			int ret;
 +
 +			if (IS_ERR(btf)) {
 +				pr_warning("vmlinux BTF is not found\n");
 +				return -EINVAL;
 +			}
 +			/* prepend "btf_trace_" prefix per kernel convention */
 +			strncat(dst, name + section_names[i].len,
 +				sizeof(raw_tp_btf_name) - sizeof("btf_trace_"));
 +			ret = btf__find_by_name(btf, raw_tp_btf_name);
 +			btf__free(btf);
 +			if (ret <= 0) {
 +				pr_warning("%s is not found in vmlinux BTF\n", dst);
 +				return -EINVAL;
 +			}
 +			*expected_attach_type = ret;
 +		}
++=======
+ 	sec_def = find_sec_def(name);
+ 	if (sec_def) {
+ 		*prog_type = sec_def->prog_type;
+ 		*expected_attach_type = sec_def->expected_attach_type;
++>>>>>>> d7a18ea7e8b6 (libbpf: Add generic bpf_program__attach())
  		return 0;
  	}
+ 
  	pr_warn("failed to guess program type from ELF section '%s'\n", name);
  	type_names = libbpf_get_type_names(false);
  	if (type_names != NULL) {
@@@ -5136,6 -5165,97 +5207,100 @@@
  	return -ESRCH;
  }
  
++<<<<<<< HEAD
++=======
+ #define BTF_PREFIX "btf_trace_"
+ int libbpf_find_vmlinux_btf_id(const char *name,
+ 			       enum bpf_attach_type attach_type)
+ {
+ 	struct btf *btf = bpf_core_find_kernel_btf();
+ 	char raw_tp_btf[128] = BTF_PREFIX;
+ 	char *dst = raw_tp_btf + sizeof(BTF_PREFIX) - 1;
+ 	const char *btf_name;
+ 	int err = -EINVAL;
+ 	__u32 kind;
+ 
+ 	if (IS_ERR(btf)) {
+ 		pr_warn("vmlinux BTF is not found\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (attach_type == BPF_TRACE_RAW_TP) {
+ 		/* prepend "btf_trace_" prefix per kernel convention */
+ 		strncat(dst, name, sizeof(raw_tp_btf) - sizeof(BTF_PREFIX));
+ 		btf_name = raw_tp_btf;
+ 		kind = BTF_KIND_TYPEDEF;
+ 	} else {
+ 		btf_name = name;
+ 		kind = BTF_KIND_FUNC;
+ 	}
+ 	err = btf__find_by_name_kind(btf, btf_name, kind);
+ 	btf__free(btf);
+ 	return err;
+ }
+ 
+ static int libbpf_find_prog_btf_id(const char *name, __u32 attach_prog_fd)
+ {
+ 	struct bpf_prog_info_linear *info_linear;
+ 	struct bpf_prog_info *info;
+ 	struct btf *btf = NULL;
+ 	int err = -EINVAL;
+ 
+ 	info_linear = bpf_program__get_prog_info_linear(attach_prog_fd, 0);
+ 	if (IS_ERR_OR_NULL(info_linear)) {
+ 		pr_warn("failed get_prog_info_linear for FD %d\n",
+ 			attach_prog_fd);
+ 		return -EINVAL;
+ 	}
+ 	info = &info_linear->info;
+ 	if (!info->btf_id) {
+ 		pr_warn("The target program doesn't have BTF\n");
+ 		goto out;
+ 	}
+ 	if (btf__get_from_id(info->btf_id, &btf)) {
+ 		pr_warn("Failed to get BTF of the program\n");
+ 		goto out;
+ 	}
+ 	err = btf__find_by_name_kind(btf, name, BTF_KIND_FUNC);
+ 	btf__free(btf);
+ 	if (err <= 0) {
+ 		pr_warn("%s is not found in prog's BTF\n", name);
+ 		goto out;
+ 	}
+ out:
+ 	free(info_linear);
+ 	return err;
+ }
+ 
+ static int libbpf_find_attach_btf_id(const char *name,
+ 				     enum bpf_attach_type attach_type,
+ 				     __u32 attach_prog_fd)
+ {
+ 	int i, err;
+ 
+ 	if (!name)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(section_defs); i++) {
+ 		if (!section_defs[i].is_attach_btf)
+ 			continue;
+ 		if (strncmp(name, section_defs[i].sec, section_defs[i].len))
+ 			continue;
+ 		if (attach_prog_fd)
+ 			err = libbpf_find_prog_btf_id(name + section_defs[i].len,
+ 						      attach_prog_fd);
+ 		else
+ 			err = libbpf_find_vmlinux_btf_id(name + section_defs[i].len,
+ 							 attach_type);
+ 		if (err <= 0)
+ 			pr_warn("%s is not found in vmlinux BTF\n", name);
+ 		return err;
+ 	}
+ 	pr_warn("failed to identify btf_id based on ELF section name '%s'\n", name);
+ 	return -ESRCH;
+ }
+ 
++>>>>>>> d7a18ea7e8b6 (libbpf: Add generic bpf_program__attach())
  int libbpf_attach_type_by_name(const char *name,
  			       enum bpf_attach_type *attach_type)
  {
@@@ -5761,6 -5919,62 +5964,65 @@@ struct bpf_link *bpf_program__attach_ra
  	return (struct bpf_link *)link;
  }
  
++<<<<<<< HEAD
++=======
+ static struct bpf_link *attach_raw_tp(const struct bpf_sec_def *sec,
+ 				      struct bpf_program *prog)
+ {
+ 	const char *tp_name = bpf_program__title(prog, false) + sec->len;
+ 
+ 	return bpf_program__attach_raw_tracepoint(prog, tp_name);
+ }
+ 
+ struct bpf_link *bpf_program__attach_trace(struct bpf_program *prog)
+ {
+ 	char errmsg[STRERR_BUFSIZE];
+ 	struct bpf_link_fd *link;
+ 	int prog_fd, pfd;
+ 
+ 	prog_fd = bpf_program__fd(prog);
+ 	if (prog_fd < 0) {
+ 		pr_warn("program '%s': can't attach before loaded\n",
+ 			bpf_program__title(prog, false));
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	link = malloc(sizeof(*link));
+ 	if (!link)
+ 		return ERR_PTR(-ENOMEM);
+ 	link->link.destroy = &bpf_link__destroy_fd;
+ 
+ 	pfd = bpf_raw_tracepoint_open(NULL, prog_fd);
+ 	if (pfd < 0) {
+ 		pfd = -errno;
+ 		free(link);
+ 		pr_warn("program '%s': failed to attach to trace: %s\n",
+ 			bpf_program__title(prog, false),
+ 			libbpf_strerror_r(pfd, errmsg, sizeof(errmsg)));
+ 		return ERR_PTR(pfd);
+ 	}
+ 	link->fd = pfd;
+ 	return (struct bpf_link *)link;
+ }
+ 
+ static struct bpf_link *attach_trace(const struct bpf_sec_def *sec,
+ 				     struct bpf_program *prog)
+ {
+ 	return bpf_program__attach_trace(prog);
+ }
+ 
+ struct bpf_link *bpf_program__attach(struct bpf_program *prog)
+ {
+ 	const struct bpf_sec_def *sec_def;
+ 
+ 	sec_def = find_sec_def(bpf_program__title(prog, false));
+ 	if (!sec_def || !sec_def->attach_fn)
+ 		return ERR_PTR(-ESRCH);
+ 
+ 	return sec_def->attach_fn(sec_def, prog);
+ }
+ 
++>>>>>>> d7a18ea7e8b6 (libbpf: Add generic bpf_program__attach())
  enum bpf_perf_event_ret
  bpf_perf_event_read_simple(void *mmap_mem, size_t mmap_size, size_t page_size,
  			   void **copy_mem, size_t *copy_size,
diff --cc tools/lib/bpf/libbpf.map
index 3ca7228af37e,757a88f64b5a..000000000000
--- a/tools/lib/bpf/libbpf.map
+++ b/tools/lib/bpf/libbpf.map
@@@ -188,9 -197,19 +188,20 @@@ LIBBPF_0.0.4 
  		bpf_map__get_pin_path;
  		bpf_map__is_pinned;
  		bpf_map__set_pin_path;
 -		bpf_object__open_file;
 -		bpf_object__open_mem;
 -		bpf_program__attach_trace;
  		bpf_program__get_expected_attach_type;
  		bpf_program__get_type;
 -		bpf_program__is_tracing;
 -		bpf_program__set_tracing;
 +		bpf_get_link_xdp_info;
  		bpf_program__size;
++<<<<<<< HEAD
 +		bpf_btf_get_next_id;
 +} LIBBPF_0.0.3;
++=======
+ 		btf__find_by_name_kind;
+ 		libbpf_find_vmlinux_btf_id;
+ } LIBBPF_0.0.5;
+ 
+ LIBBPF_0.0.7 {
+ 	global:
+ 		bpf_program__attach;
+ } LIBBPF_0.0.6;
++>>>>>>> d7a18ea7e8b6 (libbpf: Add generic bpf_program__attach())
* Unmerged path tools/lib/bpf/libbpf.c
diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index cb530c336c94..04f83c254483 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -234,6 +234,8 @@ struct bpf_link;
 
 LIBBPF_API int bpf_link__destroy(struct bpf_link *link);
 
+LIBBPF_API struct bpf_link *
+bpf_program__attach(struct bpf_program *prog);
 LIBBPF_API struct bpf_link *
 bpf_program__attach_perf_event(struct bpf_program *prog, int pfd);
 LIBBPF_API struct bpf_link *
* Unmerged path tools/lib/bpf/libbpf.map
diff --git a/tools/testing/selftests/bpf/prog_tests/probe_user.c b/tools/testing/selftests/bpf/prog_tests/probe_user.c
index 8a3187dec048..7aecfd9e87d1 100644
--- a/tools/testing/selftests/bpf/prog_tests/probe_user.c
+++ b/tools/testing/selftests/bpf/prog_tests/probe_user.c
@@ -3,8 +3,7 @@
 
 void test_probe_user(void)
 {
-#define kprobe_name "__sys_connect"
-	const char *prog_name = "kprobe/" kprobe_name;
+	const char *prog_name = "kprobe/__sys_connect";
 	const char *obj_file = "./test_probe_user.o";
 	DECLARE_LIBBPF_OPTS(bpf_object_open_opts, opts, );
 	int err, results_map_fd, sock_fd, duration = 0;
@@ -33,8 +32,7 @@ void test_probe_user(void)
 		  "err %d\n", results_map_fd))
 		goto cleanup;
 
-	kprobe_link = bpf_program__attach_kprobe(kprobe_prog, false,
-						 kprobe_name);
+	kprobe_link = bpf_program__attach(kprobe_prog);
 	if (CHECK(IS_ERR(kprobe_link), "attach_kprobe",
 		  "err %ld\n", PTR_ERR(kprobe_link))) {
 		kprobe_link = NULL;
