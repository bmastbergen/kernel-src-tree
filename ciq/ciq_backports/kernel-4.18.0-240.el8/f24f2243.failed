futex: Set task::futex_state to DEAD right after handling futex exit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit f24f22435dcc11389acc87e5586239c1819d217c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f24f2243.failed

Setting task::futex_state in do_exit() is rather arbitrarily placed for no
reason. Move it into the futex code.

Note, this is only done for the exit cleanup as the exec cleanup cannot set
the state to FUTEX_STATE_DEAD because the task struct is still in active
use.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Ingo Molnar <mingo@kernel.org>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20191106224556.439511191@linutronix.de


(cherry picked from commit f24f22435dcc11389acc87e5586239c1819d217c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/exit.c
#	kernel/futex.c
diff --cc kernel/exit.c
index 7d2d5ee2a742,f3b8fa1b8945..000000000000
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@@ -834,12 -837,6 +834,15 @@@ void __noreturn do_exit(long code
  	 * Make sure we are holding no locks:
  	 */
  	debug_check_no_locks_held();
++<<<<<<< HEAD
 +	/*
 +	 * We can do this unlocked here. The futex code uses this flag
 +	 * just to verify whether the pi state cleanup has been done
 +	 * or not. In the worst case it loops once more.
 +	 */
 +	tsk->flags |= PF_EXITPIDONE;
++=======
++>>>>>>> f24f22435dcc (futex: Set task::futex_state to DEAD right after handling futex exit)
  
  	if (tsk->io_context)
  		exit_io_context(tsk);
diff --cc kernel/futex.c
index ec3cc9521f31,426dd71e170d..000000000000
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@@ -3608,9 -3655,34 +3608,38 @@@ void exit_robust_list(struct task_struc
  		cond_resched();
  	}
  
 -	if (pending) {
 +	if (pending)
  		handle_futex_death((void __user *)pending + futex_offset,
++<<<<<<< HEAD
 +				   curr, pip);
++=======
+ 				   curr, pip, HANDLE_DEATH_PENDING);
+ 	}
+ }
+ 
+ void futex_exec_release(struct task_struct *tsk)
+ {
+ 	if (unlikely(tsk->robust_list)) {
+ 		exit_robust_list(tsk);
+ 		tsk->robust_list = NULL;
+ 	}
+ 
+ #ifdef CONFIG_COMPAT
+ 	if (unlikely(tsk->compat_robust_list)) {
+ 		compat_exit_robust_list(tsk);
+ 		tsk->compat_robust_list = NULL;
+ 	}
+ #endif
+ 
+ 	if (unlikely(!list_empty(&tsk->pi_state_list)))
+ 		exit_pi_state_list(tsk);
+ }
+ 
+ void futex_exit_release(struct task_struct *tsk)
+ {
+ 	futex_exec_release(tsk);
+ 	futex_exit_done(tsk);
++>>>>>>> f24f22435dcc (futex: Set task::futex_state to DEAD right after handling futex exit)
  }
  
  long do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,
* Unmerged path kernel/exit.c
* Unmerged path kernel/futex.c
