KVM: s390: protvirt: Report CPU state to Ultravisor

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Janosch Frank <frankja@linux.ibm.com>
commit fe28c7868f68b82e4517efb1dc3c22e2297df340
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/fe28c786.failed

VCPU states have to be reported to the ultravisor for SIGP
interpretation, kdump, kexec and reboot.

	Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
	Reviewed-by: Thomas Huth <thuth@redhat.com>
	Reviewed-by: Cornelia Huck <cohuck@redhat.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
[borntraeger@de.ibm.com: patch merging, splitting, fixing]
	Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
(cherry picked from commit fe28c7868f68b82e4517efb1dc3c22e2297df340)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/uv.h
#	arch/s390/kvm/kvm-s390.c
#	arch/s390/kvm/kvm-s390.h
#	arch/s390/kvm/pv.c
diff --cc arch/s390/include/asm/uv.h
index 4093a2856929,fc221d91a965..000000000000
--- a/arch/s390/include/asm/uv.h
+++ b/arch/s390/include/asm/uv.h
@@@ -21,16 -23,47 +21,45 @@@
  #define UVC_RC_INV_STATE	0x0003
  #define UVC_RC_INV_LEN		0x0005
  #define UVC_RC_NO_RESUME	0x0007
 -#define UVC_RC_NEED_DESTROY	0x8000
  
  #define UVC_CMD_QUI			0x0001
++<<<<<<< HEAD
++=======
+ #define UVC_CMD_INIT_UV			0x000f
+ #define UVC_CMD_CREATE_SEC_CONF		0x0100
+ #define UVC_CMD_DESTROY_SEC_CONF	0x0101
+ #define UVC_CMD_CREATE_SEC_CPU		0x0120
+ #define UVC_CMD_DESTROY_SEC_CPU		0x0121
+ #define UVC_CMD_CONV_TO_SEC_STOR	0x0200
+ #define UVC_CMD_CONV_FROM_SEC_STOR	0x0201
+ #define UVC_CMD_SET_SEC_CONF_PARAMS	0x0300
+ #define UVC_CMD_UNPACK_IMG		0x0301
+ #define UVC_CMD_VERIFY_IMG		0x0302
+ #define UVC_CMD_PREPARE_RESET		0x0320
+ #define UVC_CMD_CPU_SET_STATE		0x0330
+ #define UVC_CMD_SET_UNSHARE_ALL		0x0340
+ #define UVC_CMD_PIN_PAGE_SHARED		0x0341
+ #define UVC_CMD_UNPIN_PAGE_SHARED	0x0342
++>>>>>>> fe28c7868f68 (KVM: s390: protvirt: Report CPU state to Ultravisor)
  #define UVC_CMD_SET_SHARED_ACCESS	0x1000
  #define UVC_CMD_REMOVE_SHARED_ACCESS	0x1001
  
  /* Bits in installed uv calls */
  enum uv_cmds_inst {
  	BIT_UVC_CMD_QUI = 0,
 -	BIT_UVC_CMD_INIT_UV = 1,
 -	BIT_UVC_CMD_CREATE_SEC_CONF = 2,
 -	BIT_UVC_CMD_DESTROY_SEC_CONF = 3,
 -	BIT_UVC_CMD_CREATE_SEC_CPU = 4,
 -	BIT_UVC_CMD_DESTROY_SEC_CPU = 5,
 -	BIT_UVC_CMD_CONV_TO_SEC_STOR = 6,
 -	BIT_UVC_CMD_CONV_FROM_SEC_STOR = 7,
  	BIT_UVC_CMD_SET_SHARED_ACCESS = 8,
  	BIT_UVC_CMD_REMOVE_SHARED_ACCESS = 9,
++<<<<<<< HEAD
++=======
+ 	BIT_UVC_CMD_SET_SEC_PARMS = 11,
+ 	BIT_UVC_CMD_UNPACK_IMG = 13,
+ 	BIT_UVC_CMD_VERIFY_IMG = 14,
+ 	BIT_UVC_CMD_CPU_SET_STATE = 17,
+ 	BIT_UVC_CMD_PREPARE_RESET = 18,
+ 	BIT_UVC_CMD_UNSHARE_ALL = 20,
+ 	BIT_UVC_CMD_PIN_PAGE_SHARED = 21,
+ 	BIT_UVC_CMD_UNPIN_PAGE_SHARED = 22,
++>>>>>>> fe28c7868f68 (KVM: s390: protvirt: Report CPU state to Ultravisor)
  };
  
  struct uv_cb_header {
@@@ -44,9 -78,121 +73,112 @@@ struct uv_cb_qui 
  	struct uv_cb_header header;
  	u64 reserved08;
  	u64 inst_calls_list[4];
 -	u64 reserved30[2];
 -	u64 uv_base_stor_len;
 -	u64 reserved48;
 -	u64 conf_base_phys_stor_len;
 -	u64 conf_base_virt_stor_len;
 -	u64 conf_virt_var_stor_len;
 -	u64 cpu_stor_len;
 -	u32 reserved70[3];
 -	u32 max_num_sec_conf;
 -	u64 max_guest_stor_addr;
 -	u8  reserved88[158 - 136];
 -	u16 max_guest_cpus;
 -	u8  reserveda0[200 - 160];
 +	u64 reserved30[15];
  } __packed __aligned(8);
  
++<<<<<<< HEAD
++=======
+ /* Initialize Ultravisor */
+ struct uv_cb_init {
+ 	struct uv_cb_header header;
+ 	u64 reserved08[2];
+ 	u64 stor_origin;
+ 	u64 stor_len;
+ 	u64 reserved28[4];
+ } __packed __aligned(8);
+ 
+ /* Create Guest Configuration */
+ struct uv_cb_cgc {
+ 	struct uv_cb_header header;
+ 	u64 reserved08[2];
+ 	u64 guest_handle;
+ 	u64 conf_base_stor_origin;
+ 	u64 conf_virt_stor_origin;
+ 	u64 reserved30;
+ 	u64 guest_stor_origin;
+ 	u64 guest_stor_len;
+ 	u64 guest_sca;
+ 	u64 guest_asce;
+ 	u64 reserved58[5];
+ } __packed __aligned(8);
+ 
+ /* Create Secure CPU */
+ struct uv_cb_csc {
+ 	struct uv_cb_header header;
+ 	u64 reserved08[2];
+ 	u64 cpu_handle;
+ 	u64 guest_handle;
+ 	u64 stor_origin;
+ 	u8  reserved30[6];
+ 	u16 num;
+ 	u64 state_origin;
+ 	u64 reserved40[4];
+ } __packed __aligned(8);
+ 
+ /* Convert to Secure */
+ struct uv_cb_cts {
+ 	struct uv_cb_header header;
+ 	u64 reserved08[2];
+ 	u64 guest_handle;
+ 	u64 gaddr;
+ } __packed __aligned(8);
+ 
+ /* Convert from Secure / Pin Page Shared */
+ struct uv_cb_cfs {
+ 	struct uv_cb_header header;
+ 	u64 reserved08[2];
+ 	u64 paddr;
+ } __packed __aligned(8);
+ 
+ /* Set Secure Config Parameter */
+ struct uv_cb_ssc {
+ 	struct uv_cb_header header;
+ 	u64 reserved08[2];
+ 	u64 guest_handle;
+ 	u64 sec_header_origin;
+ 	u32 sec_header_len;
+ 	u32 reserved2c;
+ 	u64 reserved30[4];
+ } __packed __aligned(8);
+ 
+ /* Unpack */
+ struct uv_cb_unp {
+ 	struct uv_cb_header header;
+ 	u64 reserved08[2];
+ 	u64 guest_handle;
+ 	u64 gaddr;
+ 	u64 tweak[2];
+ 	u64 reserved38[3];
+ } __packed __aligned(8);
+ 
+ #define PV_CPU_STATE_OPR	1
+ #define PV_CPU_STATE_STP	2
+ #define PV_CPU_STATE_CHKSTP	3
+ 
+ struct uv_cb_cpu_set_state {
+ 	struct uv_cb_header header;
+ 	u64 reserved08[2];
+ 	u64 cpu_handle;
+ 	u8  reserved20[7];
+ 	u8  state;
+ 	u64 reserved28[5];
+ };
+ 
+ /*
+  * A common UV call struct for calls that take no payload
+  * Examples:
+  * Destroy cpu/config
+  * Verify
+  */
+ struct uv_cb_nodata {
+ 	struct uv_cb_header header;
+ 	u64 reserved08[2];
+ 	u64 handle;
+ 	u64 reserved20[4];
+ } __packed __aligned(8);
+ 
+ /* Set Shared Access */
++>>>>>>> fe28c7868f68 (KVM: s390: protvirt: Report CPU state to Ultravisor)
  struct uv_cb_share {
  	struct uv_cb_header header;
  	u64 reserved08[3];
diff --cc arch/s390/kvm/kvm-s390.c
index af147f0b9f94,80e16bd72d48..000000000000
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@@ -2255,6 -2453,33 +2255,36 @@@ long kvm_arch_vm_ioctl(struct file *fil
  		mutex_unlock(&kvm->slots_lock);
  		break;
  	}
++<<<<<<< HEAD
++=======
+ 	case KVM_S390_PV_COMMAND: {
+ 		struct kvm_pv_cmd args;
+ 
+ 		/* protvirt means user sigp */
+ 		kvm->arch.user_cpu_state_ctrl = 1;
+ 		r = 0;
+ 		if (!is_prot_virt_host()) {
+ 			r = -EINVAL;
+ 			break;
+ 		}
+ 		if (copy_from_user(&args, argp, sizeof(args))) {
+ 			r = -EFAULT;
+ 			break;
+ 		}
+ 		if (args.flags) {
+ 			r = -EINVAL;
+ 			break;
+ 		}
+ 		mutex_lock(&kvm->lock);
+ 		r = kvm_s390_handle_pv(kvm, &args);
+ 		mutex_unlock(&kvm->lock);
+ 		if (copy_to_user(argp, &args, sizeof(args))) {
+ 			r = -EFAULT;
+ 			break;
+ 		}
+ 		break;
+ 	}
++>>>>>>> fe28c7868f68 (KVM: s390: protvirt: Report CPU state to Ultravisor)
  	default:
  		r = -ENOTTY;
  	}
diff --cc arch/s390/kvm/kvm-s390.h
index be55b4b99bd3,79dcd647b378..000000000000
--- a/arch/s390/kvm/kvm-s390.h
+++ b/arch/s390/kvm/kvm-s390.h
@@@ -207,6 -208,39 +207,42 @@@ static inline int kvm_s390_user_cpu_sta
  	return kvm->arch.user_cpu_state_ctrl != 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* implemented in pv.c */
+ int kvm_s390_pv_destroy_cpu(struct kvm_vcpu *vcpu, u16 *rc, u16 *rrc);
+ int kvm_s390_pv_create_cpu(struct kvm_vcpu *vcpu, u16 *rc, u16 *rrc);
+ int kvm_s390_pv_deinit_vm(struct kvm *kvm, u16 *rc, u16 *rrc);
+ int kvm_s390_pv_init_vm(struct kvm *kvm, u16 *rc, u16 *rrc);
+ int kvm_s390_pv_set_sec_parms(struct kvm *kvm, void *hdr, u64 length, u16 *rc,
+ 			      u16 *rrc);
+ int kvm_s390_pv_unpack(struct kvm *kvm, unsigned long addr, unsigned long size,
+ 		       unsigned long tweak, u16 *rc, u16 *rrc);
+ int kvm_s390_pv_set_cpu_state(struct kvm_vcpu *vcpu, u8 state);
+ 
+ static inline u64 kvm_s390_pv_get_handle(struct kvm *kvm)
+ {
+ 	return kvm->arch.pv.handle;
+ }
+ 
+ static inline u64 kvm_s390_pv_cpu_get_handle(struct kvm_vcpu *vcpu)
+ {
+ 	return vcpu->arch.pv.handle;
+ }
+ 
+ static inline bool kvm_s390_pv_is_protected(struct kvm *kvm)
+ {
+ 	lockdep_assert_held(&kvm->lock);
+ 	return !!kvm_s390_pv_get_handle(kvm);
+ }
+ 
+ static inline bool kvm_s390_pv_cpu_is_protected(struct kvm_vcpu *vcpu)
+ {
+ 	lockdep_assert_held(&vcpu->mutex);
+ 	return !!kvm_s390_pv_cpu_get_handle(vcpu);
+ }
+ 
++>>>>>>> fe28c7868f68 (KVM: s390: protvirt: Report CPU state to Ultravisor)
  /* implemented in interrupt.c */
  int kvm_s390_handle_wait(struct kvm_vcpu *vcpu);
  void kvm_s390_vcpu_wakeup(struct kvm_vcpu *vcpu);
* Unmerged path arch/s390/kvm/pv.c
* Unmerged path arch/s390/include/asm/uv.h
diff --git a/arch/s390/kvm/diag.c b/arch/s390/kvm/diag.c
index 3fb54ec2cf3e..563429dece03 100644
--- a/arch/s390/kvm/diag.c
+++ b/arch/s390/kvm/diag.c
@@ -2,7 +2,7 @@
 /*
  * handling diagnose instructions
  *
- * Copyright IBM Corp. 2008, 2011
+ * Copyright IBM Corp. 2008, 2020
  *
  *    Author(s): Carsten Otte <cotte@de.ibm.com>
  *               Christian Borntraeger <borntraeger@de.ibm.com>
@@ -201,6 +201,10 @@ static int __diag_ipl_functions(struct kvm_vcpu *vcpu)
 		return -EOPNOTSUPP;
 	}
 
+	/*
+	 * no need to check the return value of vcpu_stop as it can only have
+	 * an error for protvirt, but protvirt means user cpu state
+	 */
 	if (!kvm_s390_user_cpu_state_ctrl(vcpu->kvm))
 		kvm_s390_vcpu_stop(vcpu);
 	vcpu->run->s390_reset_flags |= KVM_S390_RESET_SUBSYSTEM;
diff --git a/arch/s390/kvm/intercept.c b/arch/s390/kvm/intercept.c
index 8cf6b850e9f1..f9d8e513434f 100644
--- a/arch/s390/kvm/intercept.c
+++ b/arch/s390/kvm/intercept.c
@@ -79,6 +79,10 @@ static int handle_stop(struct kvm_vcpu *vcpu)
 			return rc;
 	}
 
+	/*
+	 * no need to check the return value of vcpu_stop as it can only have
+	 * an error for protvirt, but protvirt means user cpu state
+	 */
 	if (!kvm_s390_user_cpu_state_ctrl(vcpu->kvm))
 		kvm_s390_vcpu_stop(vcpu);
 	return -EOPNOTSUPP;
* Unmerged path arch/s390/kvm/kvm-s390.c
* Unmerged path arch/s390/kvm/kvm-s390.h
* Unmerged path arch/s390/kvm/pv.c
