mptcp: subflow: check parent mptcp socket on subflow state change

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 59832e246515ab6a4f5aa878073e6f415aa35166
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/59832e24.failed

This is needed at least until proper MPTCP-Level fin/reset
signalling gets added:

We wake parent when a subflow changes, but we should do this only
when all subflows have closed, not just one.

Schedule the mptcp worker and tell it to check eof state on all
subflows.

Only flag mptcp socket as closed and wake userspace processes blocking
in poll if all subflows have closed.

Co-developed-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 59832e246515ab6a4f5aa878073e6f415aa35166)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
diff --cc net/mptcp/protocol.c
index 4f5d5c0705dd,8cc9dd2cc828..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -1025,6 -1035,32 +1034,35 @@@ static void __mptcp_close_ssk(struct so
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static unsigned int mptcp_sync_mss(struct sock *sk, u32 pmtu)
+ {
+ 	return 0;
+ }
+ 
+ static void mptcp_check_for_eof(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_subflow_context *subflow;
+ 	struct sock *sk = (struct sock *)msk;
+ 	int receivers = 0;
+ 
+ 	mptcp_for_each_subflow(msk, subflow)
+ 		receivers += !subflow->rx_eof;
+ 
+ 	if (!receivers && !(sk->sk_shutdown & RCV_SHUTDOWN)) {
+ 		/* hopefully temporary hack: propagate shutdown status
+ 		 * to msk, when all subflows agree on it
+ 		 */
+ 		sk->sk_shutdown |= RCV_SHUTDOWN;
+ 
+ 		smp_mb__before_atomic(); /* SHUTDOWN must be visible first */
+ 		set_bit(MPTCP_DATA_READY, &msk->flags);
+ 		sk->sk_data_ready(sk);
+ 	}
+ }
+ 
++>>>>>>> 59832e246515 (mptcp: subflow: check parent mptcp socket on subflow state change)
  static void mptcp_worker(struct work_struct *work)
  {
  	struct mptcp_sock *msk = container_of(work, struct mptcp_sock, work);
* Unmerged path net/mptcp/protocol.c
diff --git a/net/mptcp/protocol.h b/net/mptcp/protocol.h
index 0999f74df027..151cb2c58c0f 100644
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@ -89,6 +89,7 @@
 #define MPTCP_DATA_READY	0
 #define MPTCP_SEND_SPACE	1
 #define MPTCP_WORK_RTX		2
+#define MPTCP_WORK_EOF		3
 
 static inline __be32 mptcp_option(u8 subopt, u8 len, u8 nib, u8 field)
 {
@@ -339,6 +340,7 @@ void mptcp_finish_connect(struct sock *sk);
 void mptcp_data_ready(struct sock *sk, struct sock *ssk);
 bool mptcp_finish_join(struct sock *sk);
 void mptcp_data_acked(struct sock *sk);
+void mptcp_subflow_eof(struct sock *sk);
 
 int mptcp_token_new_request(struct request_sock *req);
 void mptcp_token_destroy_request(u32 token);
diff --git a/net/mptcp/subflow.c b/net/mptcp/subflow.c
index c051db074708..fde3b78dc9ed 100644
--- a/net/mptcp/subflow.c
+++ b/net/mptcp/subflow.c
@@ -973,8 +973,7 @@ static void subflow_state_change(struct sock *sk)
 	if (!(parent->sk_shutdown & RCV_SHUTDOWN) &&
 	    !subflow->rx_eof && subflow_is_done(sk)) {
 		subflow->rx_eof = 1;
-		parent->sk_shutdown |= RCV_SHUTDOWN;
-		__subflow_state_change(parent);
+		mptcp_subflow_eof(parent);
 	}
 }
 
