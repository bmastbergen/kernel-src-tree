PCI/ERR: Return status of pcie_do_recovery()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
commit e8e5ff2aeec19ade42f0535f4b554a3f6e1a58f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e8e5ff2a.failed

As per the DPC Enhancements ECN [1], sec 4.5.1, table 4-4, if the OS
supports Error Disconnect Recover (EDR), it must invalidate the software
state associated with child devices of the port without attempting to
access the child device hardware. In addition, if the OS supports DPC, it
must attempt to recover the child devices if the port implements the DPC
Capability. If the OS continues operation, the OS must inform the firmware
of the status of the recovery operation via the _OST method.

Return the result of pcie_do_recovery() so we can report it to firmware via
_OST.

[1] Downstream Port Containment Related Enhancements ECN, Jan 28, 2019,
    affecting PCI Firmware Specification, Rev. 3.2
    https://members.pcisig.com/wg/PCI-SIG/document/12888

Link: https://lore.kernel.org/r/eb60ec89448769349c6722954ffbf2de163155b5.1585000084.git.sathyanarayanan.kuppuswamy@linux.intel.com
	Signed-off-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit e8e5ff2aeec19ade42f0535f4b554a3f6e1a58f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci.h
#	drivers/pci/pcie/err.c
diff --cc drivers/pci/pci.h
index 6d2dd6f5ea87,efbe94096050..000000000000
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@@ -548,8 -547,9 +548,14 @@@ static inline int pci_dev_specific_disa
  #endif
  
  /* PCI error reporting and recovery */
++<<<<<<< HEAD
 +void pcie_do_recovery(struct pci_dev *dev, enum pci_channel_state state,
 +		      u32 service);
++=======
+ pci_ers_result_t pcie_do_recovery(struct pci_dev *dev,
+ 			enum pci_channel_state state,
+ 			pci_ers_result_t (*reset_link)(struct pci_dev *pdev));
++>>>>>>> e8e5ff2aeec1 (PCI/ERR: Return status of pcie_do_recovery())
  
  bool pcie_wait_for_link(struct pci_dev *pdev, bool active);
  #ifdef CONFIG_PCIEASPM
diff --cc drivers/pci/pcie/err.c
index 1ac57e9e1e71,0c40488da651..000000000000
--- a/drivers/pci/pcie/err.c
+++ b/drivers/pci/pcie/err.c
@@@ -146,49 -146,9 +146,55 @@@ out
  	return 0;
  }
  
++<<<<<<< HEAD
 +/**
 + * default_reset_link - default reset function
 + * @dev: pointer to pci_dev data structure
 + *
 + * Invoked when performing link reset on a Downstream Port or a
 + * Root Port with no aer driver.
 + */
 +static pci_ers_result_t default_reset_link(struct pci_dev *dev)
 +{
 +	int rc;
 +
 +	rc = pci_bus_error_reset(dev);
 +	pci_printk(KERN_DEBUG, dev, "downstream link has been reset\n");
 +	return rc ? PCI_ERS_RESULT_DISCONNECT : PCI_ERS_RESULT_RECOVERED;
 +}
 +
 +static pci_ers_result_t reset_link(struct pci_dev *dev, u32 service)
 +{
 +	pci_ers_result_t status;
 +	struct pcie_port_service_driver *driver = NULL;
 +
 +	driver = pcie_port_find_service(dev, service);
 +	if (driver && driver->reset_link) {
 +		status = driver->reset_link(dev);
 +	} else if (pcie_downstream_port(dev)) {
 +		status = default_reset_link(dev);
 +	} else {
 +		pci_printk(KERN_DEBUG, dev, "no link-reset support at upstream device %s\n",
 +			pci_name(dev));
 +		return PCI_ERS_RESULT_DISCONNECT;
 +	}
 +
 +	if (status != PCI_ERS_RESULT_RECOVERED) {
 +		pci_printk(KERN_DEBUG, dev, "link reset at upstream device %s failed\n",
 +			pci_name(dev));
 +		return PCI_ERS_RESULT_DISCONNECT;
 +	}
 +
 +	return status;
 +}
 +
 +void pcie_do_recovery(struct pci_dev *dev, enum pci_channel_state state,
 +		      u32 service)
++=======
+ pci_ers_result_t pcie_do_recovery(struct pci_dev *dev,
+ 			enum pci_channel_state state,
+ 			pci_ers_result_t (*reset_link)(struct pci_dev *pdev))
++>>>>>>> e8e5ff2aeec1 (PCI/ERR: Return status of pcie_do_recovery())
  {
  	pci_ers_result_t status = PCI_ERS_RESULT_CAN_RECOVER;
  	struct pci_bus *bus;
* Unmerged path drivers/pci/pci.h
* Unmerged path drivers/pci/pcie/err.c
