drm/amd/display: work around fp code being emitted outside of DC_FP_START/END

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Daniel Kolesa <daniel@octaforge.org>
commit 8b91fd8bb1920a73b2c3a990a12d886fc62e1eef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8b91fd8b.failed

The dcn20_validate_bandwidth function would have code touching the
incorrect registers emitted outside of the boundaries of the
DC_FP_START/END macros, at least on ppc64le. Work around the
problem by wrapping the whole function instead.

	Signed-off-by: Daniel Kolesa <daniel@octaforge.org>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 8b91fd8bb1920a73b2c3a990a12d886fc62e1eef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c
diff --cc drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c
index 3cf504d27335,4dea550c3f83..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c
@@@ -2403,6 -3107,73 +2403,76 @@@ validate_out
  	return out;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * This must be noinline to ensure anything that deals with FP registers
+  * is contained within this call; previously our compiling with hard-float
+  * would result in fp instructions being emitted outside of the boundaries
+  * of the DC_FP_START/END macros, which makes sense as the compiler has no
+  * idea about what is wrapped and what is not
+  *
+  * This is largely just a workaround to avoid breakage introduced with 5.6,
+  * ideally all fp-using code should be moved into its own file, only that
+  * should be compiled with hard-float, and all code exported from there
+  * should be strictly wrapped with DC_FP_START/END
+  */
+ static noinline bool dcn20_validate_bandwidth_fp(struct dc *dc,
+ 		struct dc_state *context, bool fast_validate)
+ {
+ 	bool voltage_supported = false;
+ 	bool full_pstate_supported = false;
+ 	bool dummy_pstate_supported = false;
+ 	double p_state_latency_us;
+ 
+ 	p_state_latency_us = context->bw_ctx.dml.soc.dram_clock_change_latency_us;
+ 	context->bw_ctx.dml.soc.disable_dram_clock_change_vactive_support =
+ 		dc->debug.disable_dram_clock_change_vactive_support;
+ 
+ 	if (fast_validate) {
+ 		return dcn20_validate_bandwidth_internal(dc, context, true);
+ 	}
+ 
+ 	// Best case, we support full UCLK switch latency
+ 	voltage_supported = dcn20_validate_bandwidth_internal(dc, context, false);
+ 	full_pstate_supported = context->bw_ctx.bw.dcn.clk.p_state_change_support;
+ 
+ 	if (context->bw_ctx.dml.soc.dummy_pstate_latency_us == 0 ||
+ 		(voltage_supported && full_pstate_supported)) {
+ 		context->bw_ctx.bw.dcn.clk.p_state_change_support = full_pstate_supported;
+ 		goto restore_dml_state;
+ 	}
+ 
+ 	// Fallback: Try to only support G6 temperature read latency
+ 	context->bw_ctx.dml.soc.dram_clock_change_latency_us = context->bw_ctx.dml.soc.dummy_pstate_latency_us;
+ 
+ 	voltage_supported = dcn20_validate_bandwidth_internal(dc, context, false);
+ 	dummy_pstate_supported = context->bw_ctx.bw.dcn.clk.p_state_change_support;
+ 
+ 	if (voltage_supported && dummy_pstate_supported) {
+ 		context->bw_ctx.bw.dcn.clk.p_state_change_support = false;
+ 		goto restore_dml_state;
+ 	}
+ 
+ 	// ERROR: fallback is supposed to always work.
+ 	ASSERT(false);
+ 
+ restore_dml_state:
+ 	context->bw_ctx.dml.soc.dram_clock_change_latency_us = p_state_latency_us;
+ 	return voltage_supported;
+ }
+ 
+ bool dcn20_validate_bandwidth(struct dc *dc, struct dc_state *context,
+ 		bool fast_validate)
+ {
+ 	bool voltage_supported = false;
+ 	DC_FP_START();
+ 	voltage_supported = dcn20_validate_bandwidth_fp(dc, context, fast_validate);
+ 	DC_FP_END();
+ 	return voltage_supported;
+ }
+ 
++>>>>>>> 8b91fd8bb192 (drm/amd/display: work around fp code being emitted outside of DC_FP_START/END)
  struct pipe_ctx *dcn20_acquire_idle_pipe_for_layer(
  		struct dc_state *state,
  		const struct resource_pool *pool,
* Unmerged path drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c
