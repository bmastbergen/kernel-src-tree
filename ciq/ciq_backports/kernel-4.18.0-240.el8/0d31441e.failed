mlxsw: reg: Add Port Module Type Mapping register

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Danielle Ratson <danieller@nvidia.com>
commit 0d31441e87930dcf063ce9662194ebe1936747ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0d31441e.failed

Add the Port Module Type Mapping (PMTP) register. It will be used by
subsequent patches to query port module types and forbid certain
configurations based on the port module's type.

	Signed-off-by: Danielle Ratson <danieller@nvidia.com>
	Signed-off-by: Ido Schimmel <idosch@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0d31441e87930dcf063ce9662194ebe1936747ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/reg.h
diff --cc drivers/net/ethernet/mellanox/mlxsw/reg.h
index 7fd6fd9c5244,aba5db4bc780..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/reg.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/reg.h
@@@ -5375,6 -5811,311 +5375,314 @@@ static inline void mlxsw_reg_pplr_pack(
  				 MLXSW_REG_PPLR_LB_TYPE_BIT_PHY_LOCAL : 0);
  }
  
++<<<<<<< HEAD
++=======
+ /* PMTDB - Port Module To local DataBase Register
+  * ----------------------------------------------
+  * The PMTDB register allows to query the possible module<->local port
+  * mapping than can be used in PMLP. It does not represent the actual/current
+  * mapping of the local to module. Actual mapping is only defined by PMLP.
+  */
+ #define MLXSW_REG_PMTDB_ID 0x501A
+ #define MLXSW_REG_PMTDB_LEN 0x40
+ 
+ MLXSW_REG_DEFINE(pmtdb, MLXSW_REG_PMTDB_ID, MLXSW_REG_PMTDB_LEN);
+ 
+ /* reg_pmtdb_slot_index
+  * Slot index (0: Main board).
+  * Access: Index
+  */
+ MLXSW_ITEM32(reg, pmtdb, slot_index, 0x00, 24, 4);
+ 
+ /* reg_pmtdb_module
+  * Module number.
+  * Access: Index
+  */
+ MLXSW_ITEM32(reg, pmtdb, module, 0x00, 16, 8);
+ 
+ /* reg_pmtdb_ports_width
+  * Port's width
+  * Access: Index
+  */
+ MLXSW_ITEM32(reg, pmtdb, ports_width, 0x00, 12, 4);
+ 
+ /* reg_pmtdb_num_ports
+  * Number of ports in a single module (split/breakout)
+  * Access: Index
+  */
+ MLXSW_ITEM32(reg, pmtdb, num_ports, 0x00, 8, 4);
+ 
+ enum mlxsw_reg_pmtdb_status {
+ 	MLXSW_REG_PMTDB_STATUS_SUCCESS,
+ };
+ 
+ /* reg_pmtdb_status
+  * Status
+  * Access: RO
+  */
+ MLXSW_ITEM32(reg, pmtdb, status, 0x00, 0, 4);
+ 
+ /* reg_pmtdb_port_num
+  * The local_port value which can be assigned to the module.
+  * In case of more than one port, port<x> represent the /<x> port of
+  * the module.
+  * Access: RO
+  */
+ MLXSW_ITEM16_INDEXED(reg, pmtdb, port_num, 0x04, 0, 10, 0x02, 0x00, false);
+ 
+ static inline void mlxsw_reg_pmtdb_pack(char *payload, u8 slot_index, u8 module,
+ 					u8 ports_width, u8 num_ports)
+ {
+ 	MLXSW_REG_ZERO(pmtdb, payload);
+ 	mlxsw_reg_pmtdb_slot_index_set(payload, slot_index);
+ 	mlxsw_reg_pmtdb_module_set(payload, module);
+ 	mlxsw_reg_pmtdb_ports_width_set(payload, ports_width);
+ 	mlxsw_reg_pmtdb_num_ports_set(payload, num_ports);
+ }
+ 
+ /* PMPE - Port Module Plug/Unplug Event Register
+  * ---------------------------------------------
+  * This register reports any operational status change of a module.
+  * A change in the moduleâ€™s state will generate an event only if the change
+  * happens after arming the event mechanism. Any changes to the module state
+  * while the event mechanism is not armed will not be reported. Software can
+  * query the PMPE register for module status.
+  */
+ #define MLXSW_REG_PMPE_ID 0x5024
+ #define MLXSW_REG_PMPE_LEN 0x10
+ 
+ MLXSW_REG_DEFINE(pmpe, MLXSW_REG_PMPE_ID, MLXSW_REG_PMPE_LEN);
+ 
+ /* reg_pmpe_slot_index
+  * Slot index.
+  * Access: Index
+  */
+ MLXSW_ITEM32(reg, pmpe, slot_index, 0x00, 24, 4);
+ 
+ /* reg_pmpe_module
+  * Module number.
+  * Access: Index
+  */
+ MLXSW_ITEM32(reg, pmpe, module, 0x00, 16, 8);
+ 
+ enum mlxsw_reg_pmpe_module_status {
+ 	MLXSW_REG_PMPE_MODULE_STATUS_PLUGGED_ENABLED = 1,
+ 	MLXSW_REG_PMPE_MODULE_STATUS_UNPLUGGED,
+ 	MLXSW_REG_PMPE_MODULE_STATUS_PLUGGED_ERROR,
+ 	MLXSW_REG_PMPE_MODULE_STATUS_PLUGGED_DISABLED,
+ };
+ 
+ /* reg_pmpe_module_status
+  * Module status.
+  * Access: RO
+  */
+ MLXSW_ITEM32(reg, pmpe, module_status, 0x00, 0, 4);
+ 
+ /* reg_pmpe_error_type
+  * Module error details.
+  * Access: RO
+  */
+ MLXSW_ITEM32(reg, pmpe, error_type, 0x04, 8, 4);
+ 
+ /* PDDR - Port Diagnostics Database Register
+  * -----------------------------------------
+  * The PDDR enables to read the Phy debug database
+  */
+ #define MLXSW_REG_PDDR_ID 0x5031
+ #define MLXSW_REG_PDDR_LEN 0x100
+ 
+ MLXSW_REG_DEFINE(pddr, MLXSW_REG_PDDR_ID, MLXSW_REG_PDDR_LEN);
+ 
+ /* reg_pddr_local_port
+  * Local port number.
+  * Access: Index
+  */
+ MLXSW_ITEM32_LP(reg, pddr, 0x00, 16, 0x00, 12);
+ 
+ enum mlxsw_reg_pddr_page_select {
+ 	MLXSW_REG_PDDR_PAGE_SELECT_TROUBLESHOOTING_INFO = 1,
+ };
+ 
+ /* reg_pddr_page_select
+  * Page select index.
+  * Access: Index
+  */
+ MLXSW_ITEM32(reg, pddr, page_select, 0x04, 0, 8);
+ 
+ enum mlxsw_reg_pddr_trblsh_group_opcode {
+ 	/* Monitor opcodes */
+ 	MLXSW_REG_PDDR_TRBLSH_GROUP_OPCODE_MONITOR,
+ };
+ 
+ /* reg_pddr_group_opcode
+  * Group selector.
+  * Access: Index
+  */
+ MLXSW_ITEM32(reg, pddr, trblsh_group_opcode, 0x08, 0, 16);
+ 
+ /* reg_pddr_status_opcode
+  * Group selector.
+  * Access: RO
+  */
+ MLXSW_ITEM32(reg, pddr, trblsh_status_opcode, 0x0C, 0, 16);
+ 
+ static inline void mlxsw_reg_pddr_pack(char *payload, u16 local_port,
+ 				       u8 page_select)
+ {
+ 	MLXSW_REG_ZERO(pddr, payload);
+ 	mlxsw_reg_pddr_local_port_set(payload, local_port);
+ 	mlxsw_reg_pddr_page_select_set(payload, page_select);
+ }
+ 
+ /* PMMP - Port Module Memory Map Properties Register
+  * -------------------------------------------------
+  * The PMMP register allows to override the module memory map advertisement.
+  * The register can only be set when the module is disabled by PMAOS register.
+  */
+ #define MLXSW_REG_PMMP_ID 0x5044
+ #define MLXSW_REG_PMMP_LEN 0x2C
+ 
+ MLXSW_REG_DEFINE(pmmp, MLXSW_REG_PMMP_ID, MLXSW_REG_PMMP_LEN);
+ 
+ /* reg_pmmp_module
+  * Module number.
+  * Access: Index
+  */
+ MLXSW_ITEM32(reg, pmmp, module, 0x00, 16, 8);
+ 
+ /* reg_pmmp_sticky
+  * When set, will keep eeprom_override values after plug-out event.
+  * Access: OP
+  */
+ MLXSW_ITEM32(reg, pmmp, sticky, 0x00, 0, 1);
+ 
+ /* reg_pmmp_eeprom_override_mask
+  * Write mask bit (negative polarity).
+  * 0 - Allow write
+  * 1 - Ignore write
+  * On write, indicates which of the bits from eeprom_override field are
+  * updated.
+  * Access: WO
+  */
+ MLXSW_ITEM32(reg, pmmp, eeprom_override_mask, 0x04, 16, 16);
+ 
+ enum {
+ 	/* Set module to low power mode */
+ 	MLXSW_REG_PMMP_EEPROM_OVERRIDE_LOW_POWER_MASK = BIT(8),
+ };
+ 
+ /* reg_pmmp_eeprom_override
+  * Override / ignore EEPROM advertisement properties bitmask
+  * Access: RW
+  */
+ MLXSW_ITEM32(reg, pmmp, eeprom_override, 0x04, 0, 16);
+ 
+ static inline void mlxsw_reg_pmmp_pack(char *payload, u8 module)
+ {
+ 	MLXSW_REG_ZERO(pmmp, payload);
+ 	mlxsw_reg_pmmp_module_set(payload, module);
+ }
+ 
+ /* PLLP - Port Local port to Label Port mapping Register
+  * -----------------------------------------------------
+  * The PLLP register returns the mapping from Local Port into Label Port.
+  */
+ #define MLXSW_REG_PLLP_ID 0x504A
+ #define MLXSW_REG_PLLP_LEN 0x10
+ 
+ MLXSW_REG_DEFINE(pllp, MLXSW_REG_PLLP_ID, MLXSW_REG_PLLP_LEN);
+ 
+ /* reg_pllp_local_port
+  * Local port number.
+  * Access: Index
+  */
+ MLXSW_ITEM32_LP(reg, pllp, 0x00, 16, 0x00, 12);
+ 
+ /* reg_pllp_label_port
+  * Front panel label of the port.
+  * Access: RO
+  */
+ MLXSW_ITEM32(reg, pllp, label_port, 0x00, 0, 8);
+ 
+ /* reg_pllp_split_num
+  * Label split mapping for local_port.
+  * Access: RO
+  */
+ MLXSW_ITEM32(reg, pllp, split_num, 0x04, 0, 4);
+ 
+ /* reg_pllp_slot_index
+  * Slot index (0: Main board).
+  * Access: RO
+  */
+ MLXSW_ITEM32(reg, pllp, slot_index, 0x08, 0, 4);
+ 
+ static inline void mlxsw_reg_pllp_pack(char *payload, u16 local_port)
+ {
+ 	MLXSW_REG_ZERO(pllp, payload);
+ 	mlxsw_reg_pllp_local_port_set(payload, local_port);
+ }
+ 
+ static inline void mlxsw_reg_pllp_unpack(char *payload, u8 *label_port,
+ 					 u8 *split_num, u8 *slot_index)
+ {
+ 	*label_port = mlxsw_reg_pllp_label_port_get(payload);
+ 	*split_num = mlxsw_reg_pllp_split_num_get(payload);
+ 	*slot_index = mlxsw_reg_pllp_slot_index_get(payload);
+ }
+ 
+ /* PMTM - Port Module Type Mapping Register
+  * ----------------------------------------
+  * The PMTM register allows query or configuration of module types.
+  * The register can only be set when the module is disabled by PMAOS register
+  */
+ #define MLXSW_REG_PMTM_ID 0x5067
+ #define MLXSW_REG_PMTM_LEN 0x10
+ 
+ MLXSW_REG_DEFINE(pmtm, MLXSW_REG_PMTM_ID, MLXSW_REG_PMTM_LEN);
+ 
+ /* reg_pmtm_slot_index
+  * Slot index.
+  * Access: Index
+  */
+ MLXSW_ITEM32(reg, pmtm, slot_index, 0x00, 24, 4);
+ 
+ /* reg_pmtm_module
+  * Module number.
+  * Access: Index
+  */
+ MLXSW_ITEM32(reg, pmtm, module, 0x00, 16, 8);
+ 
+ enum mlxsw_reg_pmtm_module_type {
+ 	MLXSW_REG_PMTM_MODULE_TYPE_BACKPLANE_4_LANES = 0,
+ 	MLXSW_REG_PMTM_MODULE_TYPE_QSFP = 1,
+ 	MLXSW_REG_PMTM_MODULE_TYPE_SFP = 2,
+ 	MLXSW_REG_PMTM_MODULE_TYPE_BACKPLANE_SINGLE_LANE = 4,
+ 	MLXSW_REG_PMTM_MODULE_TYPE_BACKPLANE_2_LANES = 8,
+ 	MLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP4X = 10,
+ 	MLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP2X = 11,
+ 	MLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP1X = 12,
+ 	MLXSW_REG_PMTM_MODULE_TYPE_QSFP_DD = 14,
+ 	MLXSW_REG_PMTM_MODULE_TYPE_OSFP = 15,
+ 	MLXSW_REG_PMTM_MODULE_TYPE_SFP_DD = 16,
+ 	MLXSW_REG_PMTM_MODULE_TYPE_DSFP = 17,
+ 	MLXSW_REG_PMTM_MODULE_TYPE_CHIP2CHIP8X = 18,
+ 	MLXSW_REG_PMTM_MODULE_TYPE_TWISTED_PAIR = 19,
+ };
+ 
+ /* reg_pmtm_module_type
+  * Module type.
+  * Access: RW
+  */
+ MLXSW_ITEM32(reg, pmtm, module_type, 0x04, 0, 5);
+ 
+ static inline void mlxsw_reg_pmtm_pack(char *payload, u8 slot_index, u8 module)
+ {
+ 	MLXSW_REG_ZERO(pmtm, payload);
+ 	mlxsw_reg_pmtm_slot_index_set(payload, slot_index);
+ 	mlxsw_reg_pmtm_module_set(payload, module);
+ }
+ 
++>>>>>>> 0d31441e8793 (mlxsw: reg: Add Port Module Type Mapping register)
  /* HTGT - Host Trap Group Table
   * ----------------------------
   * Configures the properties for forwarding to CPU.
@@@ -10544,7 -12615,14 +10852,16 @@@ static const struct mlxsw_reg_info *mlx
  	MLXSW_REG(pptb),
  	MLXSW_REG(pbmc),
  	MLXSW_REG(pspa),
 -	MLXSW_REG(pmaos),
  	MLXSW_REG(pplr),
++<<<<<<< HEAD
++=======
+ 	MLXSW_REG(pmtdb),
+ 	MLXSW_REG(pmpe),
+ 	MLXSW_REG(pddr),
+ 	MLXSW_REG(pmmp),
+ 	MLXSW_REG(pllp),
+ 	MLXSW_REG(pmtm),
++>>>>>>> 0d31441e8793 (mlxsw: reg: Add Port Module Type Mapping register)
  	MLXSW_REG(htgt),
  	MLXSW_REG(hpkt),
  	MLXSW_REG(rgcr),
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/reg.h
