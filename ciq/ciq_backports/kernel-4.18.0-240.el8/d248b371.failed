drm/i915/gen12: Invalidate aux table entries forcibly

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mika Kuoppala <mika.kuoppala@linux.intel.com>
commit d248b371f7479a99caccf91da2ec6adee85e5e70
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d248b371.failed

Aux table invalidation can fail on update. So
next access may cause memory access to be into stale entry.

Proposed workaround is to invalidate entries between
all batchbuffers.

v2: correct register address (Yang)
v3: respect the order (Chris)

References bspec#43904, hsdes#1809175790
	Cc: Chris Wilson <chris@chris-wilson.co.uk>
	Cc: Chuansheng Liu <chuansheng.liu@intel.com>
	Cc: Rafael Antognolli <rafael.antognolli@intel.com>
	Cc: Yang A Shi <yang.a.shi@intel.com>
	Signed-off-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
	Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
	Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Link: https://patchwork.freedesktop.org/patch/msgid/20200506165310.1239-1-mika.kuoppala@linux.intel.com
(cherry picked from commit d248b371f7479a99caccf91da2ec6adee85e5e70)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/gt/intel_lrc.c
diff --cc drivers/gpu/drm/i915/gt/intel_lrc.c
index f2865f3cc1d5,bbdb0e2a4571..000000000000
--- a/drivers/gpu/drm/i915/gt/intel_lrc.c
+++ b/drivers/gpu/drm/i915/gt/intel_lrc.c
@@@ -2508,6 -4482,145 +2508,148 @@@ static int gen8_emit_flush_render(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int gen11_emit_flush_render(struct i915_request *request,
+ 				   u32 mode)
+ {
+ 	if (mode & EMIT_FLUSH) {
+ 		u32 *cs;
+ 		u32 flags = 0;
+ 
+ 		flags |= PIPE_CONTROL_CS_STALL;
+ 
+ 		flags |= PIPE_CONTROL_TILE_CACHE_FLUSH;
+ 		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
+ 		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
+ 		flags |= PIPE_CONTROL_DC_FLUSH_ENABLE;
+ 		flags |= PIPE_CONTROL_FLUSH_ENABLE;
+ 		flags |= PIPE_CONTROL_QW_WRITE;
+ 		flags |= PIPE_CONTROL_STORE_DATA_INDEX;
+ 
+ 		cs = intel_ring_begin(request, 6);
+ 		if (IS_ERR(cs))
+ 			return PTR_ERR(cs);
+ 
+ 		cs = gen8_emit_pipe_control(cs, flags, LRC_PPHWSP_SCRATCH_ADDR);
+ 		intel_ring_advance(request, cs);
+ 	}
+ 
+ 	if (mode & EMIT_INVALIDATE) {
+ 		u32 *cs;
+ 		u32 flags = 0;
+ 
+ 		flags |= PIPE_CONTROL_CS_STALL;
+ 
+ 		flags |= PIPE_CONTROL_COMMAND_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_TLB_INVALIDATE;
+ 		flags |= PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_QW_WRITE;
+ 		flags |= PIPE_CONTROL_STORE_DATA_INDEX;
+ 
+ 		cs = intel_ring_begin(request, 6);
+ 		if (IS_ERR(cs))
+ 			return PTR_ERR(cs);
+ 
+ 		cs = gen8_emit_pipe_control(cs, flags, LRC_PPHWSP_SCRATCH_ADDR);
+ 		intel_ring_advance(request, cs);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u32 preparser_disable(bool state)
+ {
+ 	return MI_ARB_CHECK | 1 << 8 | state;
+ }
+ 
+ static u32 *
+ gen12_emit_aux_table_inv(struct i915_request *rq, u32 *cs)
+ {
+ 	*cs++ = MI_LOAD_REGISTER_IMM(1);
+ 	*cs++ = i915_mmio_reg_offset(GEN12_GFX_CCS_AUX_NV);
+ 	*cs++ = AUX_INV;
+ 	*cs++ = MI_NOOP;
+ 
+ 	return cs;
+ }
+ 
+ static int gen12_emit_flush_render(struct i915_request *request,
+ 				   u32 mode)
+ {
+ 	if (mode & EMIT_FLUSH) {
+ 		u32 flags = 0;
+ 		u32 *cs;
+ 
+ 		flags |= PIPE_CONTROL_TILE_CACHE_FLUSH;
+ 		flags |= PIPE_CONTROL_FLUSH_L3;
+ 		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
+ 		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
+ 		/* Wa_1409600907:tgl */
+ 		flags |= PIPE_CONTROL_DEPTH_STALL;
+ 		flags |= PIPE_CONTROL_DC_FLUSH_ENABLE;
+ 		flags |= PIPE_CONTROL_FLUSH_ENABLE;
+ 
+ 		flags |= PIPE_CONTROL_STORE_DATA_INDEX;
+ 		flags |= PIPE_CONTROL_QW_WRITE;
+ 
+ 		flags |= PIPE_CONTROL_CS_STALL;
+ 
+ 		cs = intel_ring_begin(request, 6);
+ 		if (IS_ERR(cs))
+ 			return PTR_ERR(cs);
+ 
+ 		cs = gen12_emit_pipe_control(cs,
+ 					     PIPE_CONTROL0_HDC_PIPELINE_FLUSH,
+ 					     flags, LRC_PPHWSP_SCRATCH_ADDR);
+ 		intel_ring_advance(request, cs);
+ 	}
+ 
+ 	if (mode & EMIT_INVALIDATE) {
+ 		u32 flags = 0;
+ 		u32 *cs;
+ 
+ 		flags |= PIPE_CONTROL_COMMAND_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_TLB_INVALIDATE;
+ 		flags |= PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;
+ 
+ 		flags |= PIPE_CONTROL_STORE_DATA_INDEX;
+ 		flags |= PIPE_CONTROL_QW_WRITE;
+ 
+ 		flags |= PIPE_CONTROL_CS_STALL;
+ 
+ 		cs = intel_ring_begin(request, 8 + 4);
+ 		if (IS_ERR(cs))
+ 			return PTR_ERR(cs);
+ 
+ 		/*
+ 		 * Prevent the pre-parser from skipping past the TLB
+ 		 * invalidate and loading a stale page for the batch
+ 		 * buffer / request payload.
+ 		 */
+ 		*cs++ = preparser_disable(true);
+ 
+ 		cs = gen8_emit_pipe_control(cs, flags, LRC_PPHWSP_SCRATCH_ADDR);
+ 
+ 		/* hsdes: 1809175790 */
+ 		cs = gen12_emit_aux_table_inv(request, cs);
+ 
+ 		*cs++ = preparser_disable(false);
+ 		intel_ring_advance(request, cs);
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> d248b371f747 (drm/i915/gen12: Invalidate aux table entries forcibly)
  /*
   * Reserve space for 2 NOOPs at the end of each request to be
   * used as a workaround for not being allowed to do lite
* Unmerged path drivers/gpu/drm/i915/gt/intel_lrc.c
diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h
index 32940dd2ebc5..5f112d68de80 100644
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@ -2493,6 +2493,8 @@ enum i915_power_well_id {
 #define GEN8_PRIVATE_PAT_HI	_MMIO(0x40e0 + 4)
 #define GEN10_PAT_INDEX(index)	_MMIO(0x40e0 + (index) * 4)
 #define BSD_HWS_PGA_GEN7	_MMIO(0x04180)
+#define GEN12_GFX_CCS_AUX_NV	_MMIO(0x4208)
+#define   AUX_INV		REG_BIT(0)
 #define BLT_HWS_PGA_GEN7	_MMIO(0x04280)
 #define VEBOX_HWS_PGA_GEN7	_MMIO(0x04380)
 #define RING_ACTHD(base)	_MMIO((base) + 0x74)
