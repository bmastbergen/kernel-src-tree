x86/kernel: Convert to new CPU match macros

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit adefe55e725821e8ae23207992ded5994f1650a9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/adefe55e.failed

The new macro set has a consistent namespace and uses C99 initializers
instead of the grufty C89 ones.

Get rid the of the local macro wrappers for consistency.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Link: https://lkml.kernel.org/r/20200320131509.250559388@linutronix.de
(cherry picked from commit adefe55e725821e8ae23207992ded5994f1650a9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/apic/apic.c
#	arch/x86/kernel/tsc_msr.c
#	arch/x86/power/cpu.c
diff --cc arch/x86/kernel/apic/apic.c
index bd538da2d5d5,81b9c63dae1b..000000000000
--- a/arch/x86/kernel/apic/apic.c
+++ b/arch/x86/kernel/apic/apic.c
@@@ -581,23 -582,23 +575,37 @@@ static u32 skx_deadline_rev(void
  }
  
  static const struct x86_cpu_id deadline_match[] = {
- 	DEADLINE_MODEL_MATCH_FUNC( INTEL_FAM6_HASWELL_X,	hsx_deadline_rev),
- 	DEADLINE_MODEL_MATCH_REV ( INTEL_FAM6_BROADWELL_X,	0x0b000020),
- 	DEADLINE_MODEL_MATCH_FUNC( INTEL_FAM6_BROADWELL_D,	bdx_deadline_rev),
- 	DEADLINE_MODEL_MATCH_FUNC( INTEL_FAM6_SKYLAKE_X,	skx_deadline_rev),
+ 	X86_MATCH_INTEL_FAM6_MODEL( HASWELL_X,		&hsx_deadline_rev),
+ 	X86_MATCH_INTEL_FAM6_MODEL( BROADWELL_X,	0x0b000020),
+ 	X86_MATCH_INTEL_FAM6_MODEL( BROADWELL_D,	&bdx_deadline_rev),
+ 	X86_MATCH_INTEL_FAM6_MODEL( SKYLAKE_X,		&skx_deadline_rev),
  
++<<<<<<< HEAD
 +	DEADLINE_MODEL_MATCH_REV ( INTEL_FAM6_HASWELL,	0x22),
 +	DEADLINE_MODEL_MATCH_REV ( INTEL_FAM6_HASWELL_L,	0x20),
 +	DEADLINE_MODEL_MATCH_REV ( INTEL_FAM6_HASWELL_G,	0x17),
++=======
+ 	X86_MATCH_INTEL_FAM6_MODEL( HASWELL,		0x22),
+ 	X86_MATCH_INTEL_FAM6_MODEL( HASWELL_L,		0x20),
+ 	X86_MATCH_INTEL_FAM6_MODEL( HASWELL_G,		0x17),
++>>>>>>> adefe55e7258 (x86/kernel: Convert to new CPU match macros)
  
- 	DEADLINE_MODEL_MATCH_REV ( INTEL_FAM6_BROADWELL,	0x25),
- 	DEADLINE_MODEL_MATCH_REV ( INTEL_FAM6_BROADWELL_G,	0x17),
+ 	X86_MATCH_INTEL_FAM6_MODEL( BROADWELL,		0x25),
+ 	X86_MATCH_INTEL_FAM6_MODEL( BROADWELL_G,	0x17),
  
++<<<<<<< HEAD
 +	DEADLINE_MODEL_MATCH_REV ( INTEL_FAM6_SKYLAKE_L,	0xb2),
 +	DEADLINE_MODEL_MATCH_REV ( INTEL_FAM6_SKYLAKE,	0xb2),
 +
 +	DEADLINE_MODEL_MATCH_REV ( INTEL_FAM6_KABYLAKE_L,	0x52),
 +	DEADLINE_MODEL_MATCH_REV ( INTEL_FAM6_KABYLAKE,	0x52),
++=======
+ 	X86_MATCH_INTEL_FAM6_MODEL( SKYLAKE_L,		0xb2),
+ 	X86_MATCH_INTEL_FAM6_MODEL( SKYLAKE,		0xb2),
+ 
+ 	X86_MATCH_INTEL_FAM6_MODEL( KABYLAKE_L,		0x52),
+ 	X86_MATCH_INTEL_FAM6_MODEL( KABYLAKE,		0x52),
++>>>>>>> adefe55e7258 (x86/kernel: Convert to new CPU match macros)
  
  	{},
  };
diff --cc arch/x86/kernel/tsc_msr.c
index 7381ace7e909,bf528aae8ece..000000000000
--- a/arch/x86/kernel/tsc_msr.c
+++ b/arch/x86/kernel/tsc_msr.c
@@@ -29,38 -29,49 +29,63 @@@ struct freq_desc 
  	u32 freqs[MAX_NUM_FREQS];
  };
  
 -/*
 - * Penwell and Clovertrail use spread spectrum clock,
 - * so the freq number is not exactly the same as reported
 - * by MSR based on SDM.
 - */
 -static const struct freq_desc freq_desc_pnw = {
 -	0, { 0, 0, 0, 0, 0, 99840, 0, 83200 }
 +static struct freq_desc freq_desc_tables[] = {
 +	/* PNW */
 +	{ 6, 0x27, 0, { 0, 0, 0, 0, 0, 99840, 0, 83200 } },
 +	/* CLV+ */
 +	{ 6, 0x35, 0, { 0, 133200, 0, 0, 0, 99840, 0, 83200 } },
 +	/* TNG - Intel Atom processor Z3400 series */
 +	{ 6, 0x4a, 1, { 0, 100000, 133300, 0, 0, 0, 0, 0 } },
 +	/* VLV2 - Intel Atom processor E3000, Z3600, Z3700 series */
 +	{ 6, 0x37, 1, { 83300, 100000, 133300, 116700, 80000, 0, 0, 0 } },
 +	/* ANN - Intel Atom processor Z3500 series */
 +	{ 6, 0x5a, 1, { 83300, 100000, 133300, 100000, 0, 0, 0, 0 } },
 +	/* AMT - Intel Atom processor X7-Z8000 and X5-Z8000 series */
 +	{ 6, 0x4c, 1, { 83300, 100000, 133300, 116700,
 +			80000, 93300, 90000, 88900, 87500 } },
  };
  
 -static const struct freq_desc freq_desc_clv = {
 -	0, { 0, 133200, 0, 0, 0, 99840, 0, 83200 }
 -};
 +static int match_cpu(u8 family, u8 model)
 +{
 +	int i;
  
 -static const struct freq_desc freq_desc_byt = {
 -	1, { 83300, 100000, 133300, 116700, 80000, 0, 0, 0 }
 -};
 +	for (i = 0; i < ARRAY_SIZE(freq_desc_tables); i++) {
 +		if ((family == freq_desc_tables[i].x86_family) &&
 +			(model == freq_desc_tables[i].x86_model))
 +			return i;
 +	}
  
 -static const struct freq_desc freq_desc_cht = {
 -	1, { 83300, 100000, 133300, 116700, 80000, 93300, 90000, 88900, 87500 }
 -};
 +	return -1;
 +}
  
++<<<<<<< HEAD
 +/* Map CPU reference clock freq ID(0-7) to CPU reference clock freq(KHz) */
 +#define id_to_freq(cpu_index, freq_id) \
 +	(freq_desc_tables[cpu_index].freqs[freq_id])
++=======
+ static const struct freq_desc freq_desc_tng = {
+ 	1, { 0, 100000, 133300, 0, 0, 0, 0, 0 }
+ };
+ 
+ static const struct freq_desc freq_desc_ann = {
+ 	1, { 83300, 100000, 133300, 100000, 0, 0, 0, 0 }
+ };
+ 
+ static const struct freq_desc freq_desc_lgm = {
+ 	1, { 78000, 78000, 78000, 78000, 78000, 78000, 78000, 78000 }
+ };
+ 
+ static const struct x86_cpu_id tsc_msr_cpu_ids[] = {
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SALTWELL_MID,	&freq_desc_pnw),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SALTWELL_TABLET,&freq_desc_clv),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT,	&freq_desc_byt),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT_MID,	&freq_desc_tng),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT,	&freq_desc_cht),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT_MID,	&freq_desc_ann),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT_NP,	&freq_desc_lgm),
+ 	{}
+ };
++>>>>>>> adefe55e7258 (x86/kernel: Convert to new CPU match macros)
  
  /*
   * MSR-based CPU/TSC frequency discovery for certain CPUs.
diff --cc arch/x86/power/cpu.c
index a7d966964c6f,aaff9ed7ff45..000000000000
--- a/arch/x86/power/cpu.c
+++ b/arch/x86/power/cpu.c
@@@ -446,6 -462,41 +446,44 @@@ static const struct dmi_system_id msr_s
  	{}
  };
  
++<<<<<<< HEAD
++=======
+ static int msr_save_cpuid_features(const struct x86_cpu_id *c)
+ {
+ 	u32 cpuid_msr_id[] = {
+ 		MSR_AMD64_CPUID_FN_1,
+ 	};
+ 
+ 	pr_info("x86/pm: family %#hx cpu detected, MSR saving is needed during suspending.\n",
+ 		c->family);
+ 
+ 	return msr_build_context(cpuid_msr_id, ARRAY_SIZE(cpuid_msr_id));
+ }
+ 
+ static const struct x86_cpu_id msr_save_cpu_table[] = {
+ 	X86_MATCH_VENDOR_FAM(AMD, 0x15, &msr_save_cpuid_features),
+ 	X86_MATCH_VENDOR_FAM(AMD, 0x16, &msr_save_cpuid_features),
+ 	{}
+ };
+ 
+ typedef int (*pm_cpu_match_t)(const struct x86_cpu_id *);
+ static int pm_cpu_check(const struct x86_cpu_id *c)
+ {
+ 	const struct x86_cpu_id *m;
+ 	int ret = 0;
+ 
+ 	m = x86_match_cpu(msr_save_cpu_table);
+ 	if (m) {
+ 		pm_cpu_match_t fn;
+ 
+ 		fn = (pm_cpu_match_t)m->driver_data;
+ 		ret = fn(m);
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> adefe55e7258 (x86/kernel: Convert to new CPU match macros)
  static int pm_check_save_msr(void)
  {
  	dmi_check_system(msr_save_dmi_table);
* Unmerged path arch/x86/kernel/apic/apic.c
diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c
index 225d8912e216..3c5219e81ea4 100644
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@ -485,7 +485,7 @@ static bool match_smt(struct cpuinfo_x86 *c, struct cpuinfo_x86 *o)
  */
 
 static const struct x86_cpu_id snc_cpu[] = {
-	{ X86_VENDOR_INTEL, 6, INTEL_FAM6_SKYLAKE_X },
+	X86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_X, NULL),
 	{}
 };
 
* Unmerged path arch/x86/kernel/tsc_msr.c
* Unmerged path arch/x86/power/cpu.c
