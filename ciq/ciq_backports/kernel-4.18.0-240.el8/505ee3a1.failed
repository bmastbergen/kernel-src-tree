netfilter: flowtable: Make nf_flow_table_offload_add/del_cb inline

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Alaa Hleihel <alaa@mellanox.com>
commit 505ee3a1cab96785fbc2c7cdb41ab677ec270c3c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/505ee3a1.failed

Currently, nf_flow_table_offload_add/del_cb are exported by nf_flow_table
module, therefore modules using them will have hard-dependency
on nf_flow_table and will require loading it all the time.

This can lead to an unnecessary overhead on systems that do not
use this API.

To relax the hard-dependency between the modules, we unexport these
functions and make them static inline.

Fixes: 978703f42549 ("netfilter: flowtable: Add API for registering to flow table events")
	Signed-off-by: Alaa Hleihel <alaa@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 505ee3a1cab96785fbc2c7cdb41ab677ec270c3c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_flow_table.h
#	net/netfilter/nf_flow_table_core.c
diff --cc include/net/netfilter/nf_flow_table.h
index 4165d3a5a8ed,16e8b2f8d006..000000000000
--- a/include/net/netfilter/nf_flow_table.h
+++ b/include/net/netfilter/nf_flow_table.h
@@@ -94,6 -161,52 +94,55 @@@ struct nf_flow_route 
  struct flow_offload *flow_offload_alloc(struct nf_conn *ct);
  void flow_offload_free(struct flow_offload *flow);
  
++<<<<<<< HEAD
++=======
+ static inline int
+ nf_flow_table_offload_add_cb(struct nf_flowtable *flow_table,
+ 			     flow_setup_cb_t *cb, void *cb_priv)
+ {
+ 	struct flow_block *block = &flow_table->flow_block;
+ 	struct flow_block_cb *block_cb;
+ 	int err = 0;
+ 
+ 	down_write(&flow_table->flow_block_lock);
+ 	block_cb = flow_block_cb_lookup(block, cb, cb_priv);
+ 	if (block_cb) {
+ 		err = -EEXIST;
+ 		goto unlock;
+ 	}
+ 
+ 	block_cb = flow_block_cb_alloc(cb, cb_priv, cb_priv, NULL);
+ 	if (IS_ERR(block_cb)) {
+ 		err = PTR_ERR(block_cb);
+ 		goto unlock;
+ 	}
+ 
+ 	list_add_tail(&block_cb->list, &block->cb_list);
+ 
+ unlock:
+ 	up_write(&flow_table->flow_block_lock);
+ 	return err;
+ }
+ 
+ static inline void
+ nf_flow_table_offload_del_cb(struct nf_flowtable *flow_table,
+ 			     flow_setup_cb_t *cb, void *cb_priv)
+ {
+ 	struct flow_block *block = &flow_table->flow_block;
+ 	struct flow_block_cb *block_cb;
+ 
+ 	down_write(&flow_table->flow_block_lock);
+ 	block_cb = flow_block_cb_lookup(block, cb, cb_priv);
+ 	if (block_cb) {
+ 		list_del(&block_cb->list);
+ 		flow_block_cb_free(block_cb);
+ 	} else {
+ 		WARN_ON(true);
+ 	}
+ 	up_write(&flow_table->flow_block_lock);
+ }
+ 
++>>>>>>> 505ee3a1cab9 (netfilter: flowtable: Make nf_flow_table_offload_add/del_cb inline)
  int flow_offload_route_init(struct flow_offload *flow,
  			    const struct nf_flow_route *route);
  
diff --cc net/netfilter/nf_flow_table_core.c
index 8cd8a3f6d773,afa85171df38..000000000000
--- a/net/netfilter/nf_flow_table_core.c
+++ b/net/netfilter/nf_flow_table_core.c
@@@ -362,6 -387,7 +362,10 @@@ static void nf_flow_offload_work_gc(str
  	queue_delayed_work(system_power_efficient_wq, &flow_table->gc_work, HZ);
  }
  
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 505ee3a1cab9 (netfilter: flowtable: Make nf_flow_table_offload_add/del_cb inline)
  static int nf_flow_nat_port_tcp(struct sk_buff *skb, unsigned int thoff,
  				__be16 port, __be16 new_port)
  {
* Unmerged path include/net/netfilter/nf_flow_table.h
* Unmerged path net/netfilter/nf_flow_table_core.c
