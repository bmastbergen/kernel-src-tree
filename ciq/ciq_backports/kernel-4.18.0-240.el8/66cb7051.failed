Bluetooth: hci_qca: Enable clocks required for BT SOC

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Venkata Lakshmi Narayana Gubba <gubbaven@codeaurora.org>
commit 66cb7051356434062108b5cd74744b6473150147
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/66cb7051.failed

Instead of relying on other subsytem to turn ON clocks
required for BT SoC to operate, voting them from the driver.

	Signed-off-by: Venkata Lakshmi Narayana Gubba <gubbaven@codeaurora.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 66cb7051356434062108b5cd74744b6473150147)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/hci_qca.c
diff --cc drivers/bluetooth/hci_qca.c
index c7723b08787d,eacc65b02b30..000000000000
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@@ -988,6 -1653,168 +988,171 @@@ static const struct hci_uart_proto qca_
  	.dequeue	= qca_dequeue,
  };
  
++<<<<<<< HEAD
++=======
+ static const struct qca_vreg_data qca_soc_data_wcn3990 = {
+ 	.soc_type = QCA_WCN3990,
+ 	.vregs = (struct qca_vreg []) {
+ 		{ "vddio", 15000  },
+ 		{ "vddxo", 80000  },
+ 		{ "vddrf", 300000 },
+ 		{ "vddch0", 450000 },
+ 	},
+ 	.num_vregs = 4,
+ };
+ 
+ static const struct qca_vreg_data qca_soc_data_wcn3991 = {
+ 	.soc_type = QCA_WCN3991,
+ 	.vregs = (struct qca_vreg []) {
+ 		{ "vddio", 15000  },
+ 		{ "vddxo", 80000  },
+ 		{ "vddrf", 300000 },
+ 		{ "vddch0", 450000 },
+ 	},
+ 	.num_vregs = 4,
+ };
+ 
+ static const struct qca_vreg_data qca_soc_data_wcn3998 = {
+ 	.soc_type = QCA_WCN3998,
+ 	.vregs = (struct qca_vreg []) {
+ 		{ "vddio", 10000  },
+ 		{ "vddxo", 80000  },
+ 		{ "vddrf", 300000 },
+ 		{ "vddch0", 450000 },
+ 	},
+ 	.num_vregs = 4,
+ };
+ 
+ static void qca_power_shutdown(struct hci_uart *hu)
+ {
+ 	struct qca_serdev *qcadev;
+ 	struct qca_data *qca = hu->priv;
+ 	unsigned long flags;
+ 	enum qca_btsoc_type soc_type = qca_soc_type(hu);
+ 
+ 	qcadev = serdev_device_get_drvdata(hu->serdev);
+ 
+ 	/* From this point we go into power off state. But serial port is
+ 	 * still open, stop queueing the IBS data and flush all the buffered
+ 	 * data in skb's.
+ 	 */
+ 	spin_lock_irqsave(&qca->hci_ibs_lock, flags);
+ 	clear_bit(QCA_IBS_ENABLED, &qca->flags);
+ 	qca_flush(hu);
+ 	spin_unlock_irqrestore(&qca->hci_ibs_lock, flags);
+ 
+ 	hu->hdev->hw_error = NULL;
+ 	hu->hdev->cmd_timeout = NULL;
+ 
+ 	/* Non-serdev device usually is powered by external power
+ 	 * and don't need additional action in driver for power down
+ 	 */
+ 	if (!hu->serdev)
+ 		return;
+ 
+ 	if (qca_is_wcn399x(soc_type)) {
+ 		host_set_baudrate(hu, 2400);
+ 		qca_send_power_pulse(hu, false);
+ 		qca_regulator_disable(qcadev);
+ 	} else {
+ 		gpiod_set_value_cansleep(qcadev->bt_en, 0);
+ 	}
+ }
+ 
+ static int qca_power_off(struct hci_dev *hdev)
+ {
+ 	struct hci_uart *hu = hci_get_drvdata(hdev);
+ 	struct qca_data *qca = hu->priv;
+ 
+ 	/* Stop sending shutdown command if soc crashes. */
+ 	if (qca->memdump_state == QCA_MEMDUMP_IDLE) {
+ 		qca_send_pre_shutdown_cmd(hdev);
+ 		usleep_range(8000, 10000);
+ 	}
+ 
+ 	qca->memdump_state = QCA_MEMDUMP_IDLE;
+ 	qca_power_shutdown(hu);
+ 	return 0;
+ }
+ 
+ static int qca_regulator_enable(struct qca_serdev *qcadev)
+ {
+ 	struct qca_power *power = qcadev->bt_power;
+ 	int ret;
+ 
+ 	/* Already enabled */
+ 	if (power->vregs_on)
+ 		return 0;
+ 
+ 	BT_DBG("enabling %d regulators)", power->num_vregs);
+ 
+ 	ret = regulator_bulk_enable(power->num_vregs, power->vreg_bulk);
+ 	if (ret)
+ 		return ret;
+ 
+ 	power->vregs_on = true;
+ 
+ 	ret = clk_prepare_enable(qcadev->susclk);
+ 	if (ret) {
+ 		/* Turn off regulators to overcome power leakage */
+ 		qca_regulator_disable(qcadev);
+ 		return ret;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void qca_regulator_disable(struct qca_serdev *qcadev)
+ {
+ 	struct qca_power *power;
+ 
+ 	if (!qcadev)
+ 		return;
+ 
+ 	power = qcadev->bt_power;
+ 
+ 	/* Already disabled? */
+ 	if (!power->vregs_on)
+ 		return;
+ 
+ 	regulator_bulk_disable(power->num_vregs, power->vreg_bulk);
+ 	power->vregs_on = false;
+ 
+ 	if (qcadev->susclk)
+ 		clk_disable_unprepare(qcadev->susclk);
+ }
+ 
+ static int qca_init_regulators(struct qca_power *qca,
+ 				const struct qca_vreg *vregs, size_t num_vregs)
+ {
+ 	struct regulator_bulk_data *bulk;
+ 	int ret;
+ 	int i;
+ 
+ 	bulk = devm_kcalloc(qca->dev, num_vregs, sizeof(*bulk), GFP_KERNEL);
+ 	if (!bulk)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < num_vregs; i++)
+ 		bulk[i].supply = vregs[i].name;
+ 
+ 	ret = devm_regulator_bulk_get(qca->dev, num_vregs, bulk);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	for (i = 0; i < num_vregs; i++) {
+ 		ret = regulator_set_load(bulk[i].consumer, vregs[i].load_uA);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	qca->vreg_bulk = bulk;
+ 	qca->num_vregs = num_vregs;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 66cb70513564 (Bluetooth: hci_qca: Enable clocks required for BT SOC)
  static int qca_serdev_probe(struct serdev_device *serdev)
  {
  	struct qca_serdev *qcadev;
@@@ -998,47 -1827,192 +1163,105 @@@
  		return -ENOMEM;
  
  	qcadev->serdev_hu.serdev = serdev;
 -	data = device_get_match_data(&serdev->dev);
  	serdev_device_set_drvdata(serdev, qcadev);
 -	device_property_read_string(&serdev->dev, "firmware-name",
 -					 &qcadev->firmware_name);
 -	if (data && qca_is_wcn399x(data->soc_type)) {
 -		qcadev->btsoc_type = data->soc_type;
 -		qcadev->bt_power = devm_kzalloc(&serdev->dev,
 -						sizeof(struct qca_power),
 -						GFP_KERNEL);
 -		if (!qcadev->bt_power)
 -			return -ENOMEM;
  
++<<<<<<< HEAD
 +	qcadev->bt_en = devm_gpiod_get(&serdev->dev, "enable",
 +				       GPIOD_OUT_LOW);
 +	if (IS_ERR(qcadev->bt_en)) {
 +		dev_err(&serdev->dev, "failed to acquire enable gpio\n");
 +		return PTR_ERR(qcadev->bt_en);
++=======
+ 		qcadev->bt_power->dev = &serdev->dev;
+ 		err = qca_init_regulators(qcadev->bt_power, data->vregs,
+ 					  data->num_vregs);
+ 		if (err) {
+ 			BT_ERR("Failed to init regulators:%d", err);
+ 			return err;
+ 		}
+ 
+ 		qcadev->bt_power->vregs_on = false;
+ 
+ 		qcadev->susclk = devm_clk_get_optional(&serdev->dev, NULL);
+ 		if (IS_ERR(qcadev->susclk)) {
+ 			dev_err(&serdev->dev, "failed to acquire clk\n");
+ 			return PTR_ERR(qcadev->susclk);
+ 		}
+ 
+ 		device_property_read_u32(&serdev->dev, "max-speed",
+ 					 &qcadev->oper_speed);
+ 		if (!qcadev->oper_speed)
+ 			BT_DBG("UART will pick default operating speed");
+ 
+ 		err = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);
+ 		if (err) {
+ 			BT_ERR("wcn3990 serdev registration failed");
+ 			return err;
+ 		}
+ 	} else {
+ 		qcadev->btsoc_type = QCA_ROME;
+ 		qcadev->bt_en = devm_gpiod_get(&serdev->dev, "enable",
+ 					       GPIOD_OUT_LOW);
+ 		if (IS_ERR(qcadev->bt_en)) {
+ 			dev_err(&serdev->dev, "failed to acquire enable gpio\n");
+ 			return PTR_ERR(qcadev->bt_en);
+ 		}
+ 
+ 		qcadev->susclk = devm_clk_get(&serdev->dev, NULL);
+ 		if (IS_ERR(qcadev->susclk)) {
+ 			dev_err(&serdev->dev, "failed to acquire clk\n");
+ 			return PTR_ERR(qcadev->susclk);
+ 		}
+ 
+ 		err = clk_set_rate(qcadev->susclk, SUSCLK_RATE_32KHZ);
+ 		if (err)
+ 			return err;
+ 
+ 		err = clk_prepare_enable(qcadev->susclk);
+ 		if (err)
+ 			return err;
+ 
+ 		err = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);
+ 		if (err) {
+ 			BT_ERR("Rome serdev registration failed");
+ 			clk_disable_unprepare(qcadev->susclk);
+ 			return err;
+ 		}
++>>>>>>> 66cb70513564 (Bluetooth: hci_qca: Enable clocks required for BT SOC)
  	}
  
 -	hdev = qcadev->serdev_hu.hdev;
 -	set_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks);
 -	hdev->shutdown = qca_power_off;
 -
 -	return 0;
 -}
 -
 -static void qca_serdev_remove(struct serdev_device *serdev)
 -{
 -	struct qca_serdev *qcadev = serdev_device_get_drvdata(serdev);
 -
 -	if (qca_is_wcn399x(qcadev->btsoc_type))
 -		qca_power_shutdown(&qcadev->serdev_hu);
 -	else
 -		clk_disable_unprepare(qcadev->susclk);
 -
 -	hci_uart_unregister_device(&qcadev->serdev_hu);
 -}
 -
 -static int __maybe_unused qca_suspend(struct device *dev)
 -{
 -	struct hci_dev *hdev = container_of(dev, struct hci_dev, dev);
 -	struct hci_uart *hu = hci_get_drvdata(hdev);
 -	struct qca_data *qca = hu->priv;
 -	unsigned long flags;
 -	int ret = 0;
 -	u8 cmd;
 -
 -	set_bit(QCA_SUSPENDING, &qca->flags);
 -
 -	/* Device is downloading patch or doesn't support in-band sleep. */
 -	if (!test_bit(QCA_IBS_ENABLED, &qca->flags))
 -		return 0;
 -
 -	cancel_work_sync(&qca->ws_awake_device);
 -	cancel_work_sync(&qca->ws_awake_rx);
 -
 -	spin_lock_irqsave_nested(&qca->hci_ibs_lock,
 -				 flags, SINGLE_DEPTH_NESTING);
 -
 -	switch (qca->tx_ibs_state) {
 -	case HCI_IBS_TX_WAKING:
 -		del_timer(&qca->wake_retrans_timer);
 -		/* Fall through */
 -	case HCI_IBS_TX_AWAKE:
 -		del_timer(&qca->tx_idle_timer);
 -
 -		serdev_device_write_flush(hu->serdev);
 -		cmd = HCI_IBS_SLEEP_IND;
 -		ret = serdev_device_write_buf(hu->serdev, &cmd, sizeof(cmd));
 -
 -		if (ret < 0) {
 -			BT_ERR("Failed to send SLEEP to device");
 -			break;
 -		}
 -
 -		qca->tx_ibs_state = HCI_IBS_TX_ASLEEP;
 -		qca->ibs_sent_slps++;
 -
 -		qca_wq_serial_tx_clock_vote_off(&qca->ws_tx_vote_off);
 -		break;
 -
 -	case HCI_IBS_TX_ASLEEP:
 -		break;
 -
 -	default:
 -		BT_ERR("Spurious tx state %d", qca->tx_ibs_state);
 -		ret = -EINVAL;
 -		break;
 +	qcadev->susclk = devm_clk_get(&serdev->dev, NULL);
 +	if (IS_ERR(qcadev->susclk)) {
 +		dev_err(&serdev->dev, "failed to acquire clk\n");
 +		return PTR_ERR(qcadev->susclk);
  	}
  
 -	spin_unlock_irqrestore(&qca->hci_ibs_lock, flags);
 -
 -	if (ret < 0)
 -		goto error;
 -
 -	serdev_device_wait_until_sent(hu->serdev,
 -				      msecs_to_jiffies(CMD_TRANS_TIMEOUT_MS));
 -
 -	/* Wait for HCI_IBS_SLEEP_IND sent by device to indicate its Tx is going
 -	 * to sleep, so that the packet does not wake the system later.
 -	 */
 -
 -	ret = wait_event_interruptible_timeout(qca->suspend_wait_q,
 -			qca->rx_ibs_state == HCI_IBS_RX_ASLEEP,
 -			msecs_to_jiffies(IBS_BTSOC_TX_IDLE_TIMEOUT_MS));
 -
 -	if (ret > 0)
 -		return 0;
 +	err = clk_set_rate(qcadev->susclk, SUSCLK_RATE_32KHZ);
 +	if (err)
 +		return err;
  
 -	if (ret == 0)
 -		ret = -ETIMEDOUT;
 +	err = clk_prepare_enable(qcadev->susclk);
 +	if (err)
 +		return err;
  
 -error:
 -	clear_bit(QCA_SUSPENDING, &qca->flags);
 +	err = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);
 +	if (err)
 +		clk_disable_unprepare(qcadev->susclk);
  
 -	return ret;
 +	return err;
  }
  
 -static int __maybe_unused qca_resume(struct device *dev)
 +static void qca_serdev_remove(struct serdev_device *serdev)
  {
 -	struct hci_dev *hdev = container_of(dev, struct hci_dev, dev);
 -	struct hci_uart *hu = hci_get_drvdata(hdev);
 -	struct qca_data *qca = hu->priv;
 +	struct qca_serdev *qcadev = serdev_device_get_drvdata(serdev);
  
 -	clear_bit(QCA_SUSPENDING, &qca->flags);
 +	hci_uart_unregister_device(&qcadev->serdev_hu);
  
 -	return 0;
 +	clk_disable_unprepare(qcadev->susclk);
  }
  
 -static SIMPLE_DEV_PM_OPS(qca_pm_ops, qca_suspend, qca_resume);
 -
  static const struct of_device_id qca_bluetooth_of_match[] = {
  	{ .compatible = "qcom,qca6174-bt" },
 -	{ .compatible = "qcom,wcn3990-bt", .data = &qca_soc_data_wcn3990},
 -	{ .compatible = "qcom,wcn3991-bt", .data = &qca_soc_data_wcn3991},
 -	{ .compatible = "qcom,wcn3998-bt", .data = &qca_soc_data_wcn3998},
  	{ /* sentinel */ }
  };
  MODULE_DEVICE_TABLE(of, qca_bluetooth_of_match);
* Unmerged path drivers/bluetooth/hci_qca.c
