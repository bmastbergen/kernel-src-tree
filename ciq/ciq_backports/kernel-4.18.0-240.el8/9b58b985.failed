KVM: SVM: Convert feature updates from CPUID to KVM cpu caps

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 9b58b9857f221e4f7149a22727ef61d0c141f56b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9b58b985.failed

Use the recently introduced KVM CPU caps to propagate SVM-only (kernel)
settings to supported CPUID flags.

Note, there are a few subtleties:

  - Setting a flag based on a *different* feature is effectively
    emulation, and must be done at runtime via ->set_supported_cpuid().

  - CPUID 0x8000000A.EDX is a feature leaf that was previously not
    adjusted by kvm_cpu_cap_mask() because all features are hidden by
    default.

Opportunistically add a technically unnecessary break and fix an
indentation issue in svm_set_supported_cpuid().

No functional change intended.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9b58b9857f221e4f7149a22727ef61d0c141f56b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.c
#	arch/x86/kvm/svm.c
diff --cc arch/x86/kvm/cpuid.c
index d4472786ed92,a5aed82d9ffa..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -285,12 -261,129 +285,132 @@@ out
  	return r;
  }
  
 -static __always_inline void kvm_cpu_cap_mask(enum cpuid_leafs leaf, u32 mask)
 +static __always_inline void cpuid_mask(u32 *word, int wordnum)
  {
 -	reverse_cpuid_check(leaf);
 -	kvm_cpu_caps[leaf] &= mask;
 +	reverse_cpuid_check(wordnum);
 +	*word &= boot_cpu_data.x86_capability[wordnum];
  }
  
++<<<<<<< HEAD
++=======
+ void kvm_set_cpu_caps(void)
+ {
+ 	unsigned int f_nx = is_efer_nx() ? F(NX) : 0;
+ #ifdef CONFIG_X86_64
+ 	unsigned int f_gbpages = F(GBPAGES);
+ 	unsigned int f_lm = F(LM);
+ #else
+ 	unsigned int f_gbpages = 0;
+ 	unsigned int f_lm = 0;
+ #endif
+ 
+ 	BUILD_BUG_ON(sizeof(kvm_cpu_caps) >
+ 		     sizeof(boot_cpu_data.x86_capability));
+ 
+ 	memcpy(&kvm_cpu_caps, &boot_cpu_data.x86_capability,
+ 	       sizeof(kvm_cpu_caps));
+ 
+ 	kvm_cpu_cap_mask(CPUID_1_ECX,
+ 		/*
+ 		 * NOTE: MONITOR (and MWAIT) are emulated as NOP, but *not*
+ 		 * advertised to guests via CPUID!
+ 		 */
+ 		F(XMM3) | F(PCLMULQDQ) | 0 /* DTES64, MONITOR */ |
+ 		0 /* DS-CPL, VMX, SMX, EST */ |
+ 		0 /* TM2 */ | F(SSSE3) | 0 /* CNXT-ID */ | 0 /* Reserved */ |
+ 		F(FMA) | F(CX16) | 0 /* xTPR Update, PDCM */ |
+ 		F(PCID) | 0 /* Reserved, DCA */ | F(XMM4_1) |
+ 		F(XMM4_2) | F(X2APIC) | F(MOVBE) | F(POPCNT) |
+ 		0 /* Reserved*/ | F(AES) | F(XSAVE) | 0 /* OSXSAVE */ | F(AVX) |
+ 		F(F16C) | F(RDRAND)
+ 	);
+ 
+ 	kvm_cpu_cap_mask(CPUID_1_EDX,
+ 		F(FPU) | F(VME) | F(DE) | F(PSE) |
+ 		F(TSC) | F(MSR) | F(PAE) | F(MCE) |
+ 		F(CX8) | F(APIC) | 0 /* Reserved */ | F(SEP) |
+ 		F(MTRR) | F(PGE) | F(MCA) | F(CMOV) |
+ 		F(PAT) | F(PSE36) | 0 /* PSN */ | F(CLFLUSH) |
+ 		0 /* Reserved, DS, ACPI */ | F(MMX) |
+ 		F(FXSR) | F(XMM) | F(XMM2) | F(SELFSNOOP) |
+ 		0 /* HTT, TM, Reserved, PBE */
+ 	);
+ 
+ 	kvm_cpu_cap_mask(CPUID_7_0_EBX,
+ 		F(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |
+ 		F(BMI2) | F(ERMS) | 0 /*INVPCID*/ | F(RTM) | 0 /*MPX*/ | F(RDSEED) |
+ 		F(ADX) | F(SMAP) | F(AVX512IFMA) | F(AVX512F) | F(AVX512PF) |
+ 		F(AVX512ER) | F(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(AVX512DQ) |
+ 		F(SHA_NI) | F(AVX512BW) | F(AVX512VL) | 0 /*INTEL_PT*/
+ 	);
+ 
+ 	kvm_cpu_cap_mask(CPUID_7_ECX,
+ 		F(AVX512VBMI) | F(LA57) | 0 /*PKU*/ | 0 /*OSPKE*/ | F(RDPID) |
+ 		F(AVX512_VPOPCNTDQ) | F(UMIP) | F(AVX512_VBMI2) | F(GFNI) |
+ 		F(VAES) | F(VPCLMULQDQ) | F(AVX512_VNNI) | F(AVX512_BITALG) |
+ 		F(CLDEMOTE) | F(MOVDIRI) | F(MOVDIR64B) | 0 /*WAITPKG*/
+ 	);
+ 	/* Set LA57 based on hardware capability. */
+ 	if (cpuid_ecx(7) & F(LA57))
+ 		kvm_cpu_cap_set(X86_FEATURE_LA57);
+ 
+ 	kvm_cpu_cap_mask(CPUID_7_EDX,
+ 		F(AVX512_4VNNIW) | F(AVX512_4FMAPS) | F(SPEC_CTRL) |
+ 		F(SPEC_CTRL_SSBD) | F(ARCH_CAPABILITIES) | F(INTEL_STIBP) |
+ 		F(MD_CLEAR)
+ 	);
+ 
+ 	kvm_cpu_cap_mask(CPUID_7_1_EAX,
+ 		F(AVX512_BF16)
+ 	);
+ 
+ 	kvm_cpu_cap_mask(CPUID_D_1_EAX,
+ 		F(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | F(XSAVES)
+ 	);
+ 
+ 	kvm_cpu_cap_mask(CPUID_8000_0001_ECX,
+ 		F(LAHF_LM) | F(CMP_LEGACY) | 0 /*SVM*/ | 0 /* ExtApicSpace */ |
+ 		F(CR8_LEGACY) | F(ABM) | F(SSE4A) | F(MISALIGNSSE) |
+ 		F(3DNOWPREFETCH) | F(OSVW) | 0 /* IBS */ | F(XOP) |
+ 		0 /* SKINIT, WDT, LWP */ | F(FMA4) | F(TBM) |
+ 		F(TOPOEXT) | F(PERFCTR_CORE)
+ 	);
+ 
+ 	kvm_cpu_cap_mask(CPUID_8000_0001_EDX,
+ 		F(FPU) | F(VME) | F(DE) | F(PSE) |
+ 		F(TSC) | F(MSR) | F(PAE) | F(MCE) |
+ 		F(CX8) | F(APIC) | 0 /* Reserved */ | F(SYSCALL) |
+ 		F(MTRR) | F(PGE) | F(MCA) | F(CMOV) |
+ 		F(PAT) | F(PSE36) | 0 /* Reserved */ |
+ 		f_nx | 0 /* Reserved */ | F(MMXEXT) | F(MMX) |
+ 		F(FXSR) | F(FXSR_OPT) | f_gbpages | F(RDTSCP) |
+ 		0 /* Reserved */ | f_lm | F(3DNOWEXT) | F(3DNOW)
+ 	);
+ 
+ 	if (!tdp_enabled && IS_ENABLED(CONFIG_X86_64))
+ 		kvm_cpu_cap_set(X86_FEATURE_GBPAGES);
+ 
+ 	kvm_cpu_cap_mask(CPUID_8000_0008_EBX,
+ 		F(CLZERO) | F(XSAVEERPTR) |
+ 		F(WBNOINVD) | F(AMD_IBPB) | F(AMD_IBRS) | F(AMD_SSBD) | F(VIRT_SSBD) |
+ 		F(AMD_SSB_NO) | F(AMD_STIBP) | F(AMD_STIBP_ALWAYS_ON)
+ 	);
+ 
+ 	/*
+ 	 * Hide all SVM features by default, SVM will set the cap bits for
+ 	 * features it emulates and/or exposes for L1.
+ 	 */
+ 	kvm_cpu_cap_mask(CPUID_8000_000A_EDX, 0);
+ 
+ 	kvm_cpu_cap_mask(CPUID_C000_0001_EDX,
+ 		F(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |
+ 		F(ACE2) | F(ACE2_EN) | F(PHE) | F(PHE_EN) |
+ 		F(PMM) | F(PMM_EN)
+ 	);
+ }
+ EXPORT_SYMBOL_GPL(kvm_set_cpu_caps);
+ 
++>>>>>>> 9b58b9857f22 (KVM: SVM: Convert feature updates from CPUID to KVM cpu caps)
  struct kvm_cpuid_array {
  	struct kvm_cpuid_entry2 *entries;
  	const int maxnent;
diff --cc arch/x86/kvm/svm.c
index 2c7c88ef7253,61333c8306b0..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -1485,6 -1496,8 +1502,11 @@@ static __init int svm_hardware_setup(vo
  			pr_info("Virtual GIF supported\n");
  	}
  
++<<<<<<< HEAD
++=======
+ 	svm_set_cpu_caps();
+ 
++>>>>>>> 9b58b9857f22 (KVM: SVM: Convert feature updates from CPUID to KVM cpu caps)
  	return 0;
  
  err:
@@@ -6041,43 -6035,47 +6063,67 @@@ static void svm_cpuid_update(struct kvm
  	if (!kvm_vcpu_apicv_active(vcpu))
  		return;
  
 -	/*
 -	 * AVIC does not work with an x2APIC mode guest. If the X2APIC feature
 -	 * is exposed to the guest, disable AVIC.
 -	 */
 -	if (guest_cpuid_has(vcpu, X86_FEATURE_X2APIC))
 -		kvm_request_apicv_update(vcpu->kvm, false,
 -					 APICV_INHIBIT_REASON_X2APIC);
 -
 -	/*
 -	 * Currently, AVIC does not work with nested virtualization.
 -	 * So, we disable AVIC when cpuid for SVM is set in the L1 guest.
 -	 */
 -	if (nested && guest_cpuid_has(vcpu, X86_FEATURE_SVM))
 -		kvm_request_apicv_update(vcpu->kvm, false,
 -					 APICV_INHIBIT_REASON_NESTED);
 +	guest_cpuid_clear(vcpu, X86_FEATURE_X2APIC);
  }
  
++<<<<<<< HEAD
 +#define F feature_bit
 +
 +static void svm_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
 +{
 +	switch (func) {
 +	case 0x1:
 +		if (avic)
 +			entry->ecx &= ~F(X2APIC);
 +		break;
 +	case 0x80000001:
 +		if (nested)
 +			entry->ecx |= (1 << 2); /* Set SVM bit */
 +		break;
 +	case 0x80000008:
 +		if (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) ||
 +		     boot_cpu_has(X86_FEATURE_AMD_SSBD))
 +			entry->ebx |= F(VIRT_SSBD);
++=======
+ /*
+  * Vendor specific emulation must be handled via ->set_supported_cpuid(), not
+  * svm_set_cpu_caps(), as capabilities configured during hardware_setup() are
+  * masked against hardware/kernel support, i.e. they'd be lost.
+  *
+  * Note, setting a flag based on a *different* feature, e.g. setting VIRT_SSBD
+  * if LS_CFG_SSBD or AMD_SSBD is supported, is effectively emulation.
+  */
+ static void svm_set_supported_cpuid(struct kvm_cpuid_entry2 *entry)
+ {
+ 	switch (entry->function) {
+ 	case 0x80000008:
+ 		if (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) ||
+ 		    boot_cpu_has(X86_FEATURE_AMD_SSBD))
+ 			cpuid_entry_set(entry, X86_FEATURE_VIRT_SSBD);
++>>>>>>> 9b58b9857f22 (KVM: SVM: Convert feature updates from CPUID to KVM cpu caps)
  		break;
  	case 0x8000000A:
  		entry->eax = 1; /* SVM revision 1 */
  		entry->ebx = 8; /* Lets support 8 ASIDs in case we add proper
  				   ASID emulation to nested SVM */
  		entry->ecx = 0; /* Reserved */
++<<<<<<< HEAD
 +		entry->edx = 0; /* Per default do not support any
 +				   additional features */
 +
 +		/* Support next_rip if host supports it */
 +		if (boot_cpu_has(X86_FEATURE_NRIPS))
 +			entry->edx |= F(NRIPS);
 +
 +		/* Support NPT for the guest if enabled */
 +		if (npt_enabled)
 +			entry->edx |= F(NPT);
 +
++=======
+ 		/* Note, 0x8000000A.EDX is managed via kvm_cpu_caps. */;
+ 		cpuid_entry_mask(entry, CPUID_8000_000A_EDX);
+ 		break;
++>>>>>>> 9b58b9857f22 (KVM: SVM: Convert feature updates from CPUID to KVM cpu caps)
  	}
  }
  
* Unmerged path arch/x86/kvm/cpuid.c
* Unmerged path arch/x86/kvm/svm.c
