ceph: re-org copy_file_range and fix some error paths

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Luis Henriques <lhenriques@suse.com>
commit 1b0c3b9f91f0df03088d293fc9e62743fd789ad2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/1b0c3b9f.failed

This patch re-organizes copy_file_range, trying to fix a few issues in the
error handling.  Here's the summary:

- Abort copy if initial do_splice_direct() returns fewer bytes than
  requested.

- Move the 'size' initialization (with i_size_read()) further down in the
  code, after the initial call to do_splice_direct().  This avoids issues
  with a possibly stale value if a manual copy is done.

- Move the object copy loop into a separate function.  This makes it
  easier to handle errors (e.g, dirtying caps and updating the MDS
  metadata if only some objects have been copied before an error has
  occurred).

- Added calls to ceph_oloc_destroy() to avoid leaking memory with src_oloc
  and dst_oloc

- After the object copy loop, the new file size to be reported to the MDS
  (if there's file size change) is now the actual file size, and not the
  size after an eventual extra manual copy.

- Added a few dout() to show the number of bytes copied in the two manual
  copies and in the object copy loop.

	Signed-off-by: Luis Henriques <lhenriques@suse.com>
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 1b0c3b9f91f0df03088d293fc9e62743fd789ad2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/file.c
diff --cc fs/ceph/file.c
index db4ae58cb8ad,7f8c4e308301..000000000000
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@@ -1955,17 -2018,23 +2020,22 @@@ static ssize_t __ceph_copy_file_range(s
  	struct ceph_inode_info *src_ci = ceph_inode(src_inode);
  	struct ceph_inode_info *dst_ci = ceph_inode(dst_inode);
  	struct ceph_cap_flush *prealloc_cf;
++<<<<<<< HEAD
 +	struct ceph_object_locator src_oloc, dst_oloc;
 +	struct ceph_object_id src_oid, dst_oid;
 +	loff_t endoff = 0, size;
 +	ssize_t ret = -EIO;
++=======
+ 	struct ceph_fs_client *src_fsc = ceph_inode_to_client(src_inode);
+ 	loff_t size;
+ 	ssize_t ret = -EIO, bytes;
++>>>>>>> 1b0c3b9f91f0 (ceph: re-org copy_file_range and fix some error paths)
  	u64 src_objnum, dst_objnum, src_objoff, dst_objoff;
- 	u32 src_objlen, dst_objlen, object_size;
+ 	u32 src_objlen, dst_objlen;
  	int src_got = 0, dst_got = 0, err, dirty;
- 	bool do_final_copy = false;
  
 -	if (src_inode->i_sb != dst_inode->i_sb) {
 -		struct ceph_fs_client *dst_fsc = ceph_inode_to_client(dst_inode);
 -
 -		if (ceph_fsid_compare(&src_fsc->client->fsid,
 -				      &dst_fsc->client->fsid)) {
 -			dout("Copying files across clusters: src: %pU dst: %pU\n",
 -			     &src_fsc->client->fsid, &dst_fsc->client->fsid);
 -			return -EXDEV;
 -		}
 -	}
 +	if (src_inode->i_sb != dst_inode->i_sb)
 +		return -EXDEV;
  	if (ceph_snap(dst_inode) != CEPH_NOSNAP)
  		return -EROFS;
  
@@@ -2074,48 -2151,23 +2139,65 @@@
  		if (err < 0)
  			goto out_caps;
  	}
++<<<<<<< HEAD
 +	object_size = src_ci->i_layout.object_size;
 +	while (len >= object_size) {
 +		ceph_calc_file_object_mapping(&src_ci->i_layout, src_off,
 +					      object_size, &src_objnum,
 +					      &src_objoff, &src_objlen);
 +		ceph_calc_file_object_mapping(&dst_ci->i_layout, dst_off,
 +					      object_size, &dst_objnum,
 +					      &dst_objoff, &dst_objlen);
 +		ceph_oid_init(&src_oid);
 +		ceph_oid_printf(&src_oid, "%llx.%08llx",
 +				src_ci->i_vino.ino, src_objnum);
 +		ceph_oid_init(&dst_oid);
 +		ceph_oid_printf(&dst_oid, "%llx.%08llx",
 +				dst_ci->i_vino.ino, dst_objnum);
 +		/* Do an object remote copy */
 +		err = ceph_osdc_copy_from(
 +			&ceph_inode_to_client(src_inode)->client->osdc,
 +			src_ci->i_vino.snap, 0,
 +			&src_oid, &src_oloc,
 +			CEPH_OSD_OP_FLAG_FADVISE_SEQUENTIAL |
 +			CEPH_OSD_OP_FLAG_FADVISE_NOCACHE,
 +			&dst_oid, &dst_oloc,
 +			CEPH_OSD_OP_FLAG_FADVISE_SEQUENTIAL |
 +			CEPH_OSD_OP_FLAG_FADVISE_DONTNEED, 0);
 +		if (err) {
 +			dout("ceph_osdc_copy_from returned %d\n", err);
 +			if (!ret)
 +				ret = err;
 +			goto out_caps;
 +		}
 +		len -= object_size;
 +		src_off += object_size;
 +		dst_off += object_size;
 +		ret += object_size;
 +	}
++=======
++>>>>>>> 1b0c3b9f91f0 (ceph: re-org copy_file_range and fix some error paths)
  
- 	if (len)
- 		/* We still need one final local copy */
- 		do_final_copy = true;
+ 	size = i_size_read(dst_inode);
+ 	bytes = ceph_do_objects_copy(src_ci, &src_off, dst_ci, &dst_off,
+ 				     src_fsc, len, flags);
+ 	if (bytes <= 0) {
+ 		if (!ret)
+ 			ret = bytes;
+ 		goto out_caps;
+ 	}
+ 	dout("Copied %zu bytes out of %zu\n", bytes, len);
+ 	len -= bytes;
+ 	ret += bytes;
  
  	file_update_time(dst_file);
++<<<<<<< HEAD
 +	if (endoff > size) {
++=======
+ 	inode_inc_iversion_raw(dst_inode);
+ 
+ 	if (dst_off > size) {
++>>>>>>> 1b0c3b9f91f0 (ceph: re-org copy_file_range and fix some error paths)
  		int caps_flags = 0;
  
  		/* Let the MDS know about dst file size change */
* Unmerged path fs/ceph/file.c
