powerpc/dma: remove set_dma_offset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 0617fc0ca412b535c0ab0e5e7b03180067f0f7fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0617fc0c.failed

There is no good reason for this helper, just opencode it.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Tested-by: Christian Zigotzky <chzigotzky@xenosoft.de>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit 0617fc0ca412b535c0ab0e5e7b03180067f0f7fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/sysdev/fsl_pci.c
#	drivers/misc/cxl/vphb.c
diff --cc arch/powerpc/sysdev/fsl_pci.c
index 0c6510f340cb,a04c6dde6ed0..000000000000
--- a/arch/powerpc/sysdev/fsl_pci.c
+++ b/arch/powerpc/sysdev/fsl_pci.c
@@@ -141,8 -139,7 +141,12 @@@ static void fsl_pci_dma_set_mask(struc
  	 */
  	if (dev_is_pci(dev) && dma_mask >= pci64_dma_offset * 2 - 1) {
  		dev->bus_dma_mask = 0;
++<<<<<<< HEAD
 +		set_dma_ops(dev, &dma_nommu_ops);
 +		set_dma_offset(dev, pci64_dma_offset);
++=======
+ 		dev->archdata.dma_offset = pci64_dma_offset;
++>>>>>>> 0617fc0ca412 (powerpc/dma: remove set_dma_offset)
  	}
  }
  
diff --cc drivers/misc/cxl/vphb.c
index f8339eea51a9,631c5df246d4..000000000000
--- a/drivers/misc/cxl/vphb.c
+++ b/drivers/misc/cxl/vphb.c
@@@ -43,10 -43,32 +43,14 @@@ static bool cxl_pci_enable_device_hook(
  		return false;
  	}
  
++<<<<<<< HEAD
 +	set_dma_ops(&dev->dev, &dma_nommu_ops);
 +	set_dma_offset(&dev->dev, PAGE_OFFSET);
++=======
+ 	dev->dev.archdata.dma_offset = PAGE_OFFSET;
++>>>>>>> 0617fc0ca412 (powerpc/dma: remove set_dma_offset)
  
 -	/*
 -	 * Allocate a context to do cxl things too.  If we eventually do real
 -	 * DMA ops, we'll need a default context to attach them to
 -	 */
 -	ctx = cxl_dev_context_init(dev);
 -	if (IS_ERR(ctx))
 -		return false;
 -	dev->dev.archdata.cxl_ctx = ctx;
 -
 -	return (cxl_ops->afu_check_and_enable(afu) == 0);
 -}
 -
 -static void cxl_pci_disable_device(struct pci_dev *dev)
 -{
 -	struct cxl_context *ctx = cxl_get_context(dev);
 -
 -	if (ctx) {
 -		if (ctx->status == STARTED) {
 -			dev_err(&dev->dev, "Default context started\n");
 -			return;
 -		}
 -		dev->dev.archdata.cxl_ctx = NULL;
 -		cxl_release_context(ctx);
 -	}
 +	return _cxl_pci_associate_default_context(dev, afu);
  }
  
  static resource_size_t cxl_pci_window_alignment(struct pci_bus *bus,
diff --git a/arch/powerpc/include/asm/dma-mapping.h b/arch/powerpc/include/asm/dma-mapping.h
index 64d2dd3eb138..9b16b2d3401a 100644
--- a/arch/powerpc/include/asm/dma-mapping.h
+++ b/arch/powerpc/include/asm/dma-mapping.h
@@ -52,11 +52,5 @@ static inline const struct dma_map_ops *get_arch_dma_ops(struct bus_type *bus)
 	return NULL;
 }
 
-static inline void set_dma_offset(struct device *dev, dma_addr_t off)
-{
-	if (dev)
-		dev->archdata.dma_offset = off;
-}
-
 #endif /* __KERNEL__ */
 #endif	/* _ASM_DMA_MAPPING_H */
diff --git a/arch/powerpc/kernel/pci-common.c b/arch/powerpc/kernel/pci-common.c
index 2edb090d1269..cf3a9201bbaf 100644
--- a/arch/powerpc/kernel/pci-common.c
+++ b/arch/powerpc/kernel/pci-common.c
@@ -969,7 +969,7 @@ static void pcibios_setup_device(struct pci_dev *dev)
 
 	/* Hook up default DMA ops */
 	set_dma_ops(&dev->dev, pci_dma_ops);
-	set_dma_offset(&dev->dev, PCI_DRAM_OFFSET);
+	dev->dev.archdata.dma_offset = PCI_DRAM_OFFSET;
 
 	/* Additional platform DMA/iommu setup */
 	phb = pci_bus_to_host(dev->bus);
diff --git a/arch/powerpc/platforms/cell/iommu.c b/arch/powerpc/platforms/cell/iommu.c
index a3c4057a8f65..3e07d5d3dc1a 100644
--- a/arch/powerpc/platforms/cell/iommu.c
+++ b/arch/powerpc/platforms/cell/iommu.c
@@ -577,10 +577,10 @@ static void cell_dma_dev_setup(struct device *dev)
 		u64 addr = cell_iommu_get_fixed_address(dev);
 
 		if (addr != OF_BAD_ADDR)
-			set_dma_offset(dev, addr + dma_iommu_fixed_base);
+			dev->archdata.dma_offset = addr + dma_iommu_fixed_base;
 		set_iommu_table_base(dev, cell_get_iommu_table(dev));
 	} else {
-		set_dma_offset(dev, cell_dma_nommu_offset);
+		dev->archdata.dma_offset = cell_dma_nommu_offset;
 	}
 }
 
diff --git a/arch/powerpc/platforms/powernv/pci-ioda.c b/arch/powerpc/platforms/powernv/pci-ioda.c
index 8b1212a64cc7..67abe1caeef9 100644
--- a/arch/powerpc/platforms/powernv/pci-ioda.c
+++ b/arch/powerpc/platforms/powernv/pci-ioda.c
@@ -1751,7 +1751,7 @@ static void pnv_pci_ioda_dma_dev_setup(struct pnv_phb *phb, struct pci_dev *pdev
 
 	pe = &phb->ioda.pe_array[pdn->pe_number];
 	WARN_ON(get_dma_ops(&pdev->dev) != &dma_iommu_ops);
-	set_dma_offset(&pdev->dev, pe->tce_bypass_base);
+	pdev->dev.archdata.dma_offset = pe->tce_bypass_base;
 	set_iommu_table_base(&pdev->dev, pe->table_group.tables[0]);
 	/*
 	 * Note: iommu_add_device() will fail here as
@@ -1864,7 +1864,7 @@ static bool pnv_pci_ioda_iommu_bypass_supported(struct pci_dev *pdev,
 		if (rc)
 			return rc;
 		/* 4GB offset bypasses 32-bit space */
-		set_dma_offset(&pdev->dev, (1ULL << 32));
+		pdev->dev.archdata.dma_offset = (1ULL << 32);
 		return true;
 	}
 
@@ -1877,7 +1877,7 @@ static void pnv_ioda_setup_bus_dma(struct pnv_ioda_pe *pe, struct pci_bus *bus)
 
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		set_iommu_table_base(&dev->dev, pe->table_group.tables[0]);
-		set_dma_offset(&dev->dev, pe->tce_bypass_base);
+		dev->dev.archdata.dma_offset = pe->tce_bypass_base;
 
 		if ((pe->flags & PNV_IODA_PE_BUS_ALL) && dev->subordinate)
 			pnv_ioda_setup_bus_dma(pe, dev->subordinate);
diff --git a/arch/powerpc/platforms/pseries/iommu.c b/arch/powerpc/platforms/pseries/iommu.c
index 657f7e6f6bea..22ad5e4959a5 100644
--- a/arch/powerpc/platforms/pseries/iommu.c
+++ b/arch/powerpc/platforms/pseries/iommu.c
@@ -1211,7 +1211,6 @@ static bool iommu_bypass_supported_pSeriesLP(struct pci_dev *pdev, u64 dma_mask)
 {
 	struct device_node *dn = pci_device_to_OF_node(pdev), *pdn;
 	const __be32 *dma_window = NULL;
-	u64 dma_offset;
 
 	/* only attempt to use a new window if 64-bit DMA is requested */
 	if (dma_mask < DMA_BIT_MASK(64))
@@ -1233,11 +1232,9 @@ static bool iommu_bypass_supported_pSeriesLP(struct pci_dev *pdev, u64 dma_mask)
 	}
 
 	if (pdn && PCI_DN(pdn)) {
-		dma_offset = enable_ddw(pdev, pdn);
-		if (dma_offset != 0) {
-			set_dma_offset(&pdev->dev, dma_offset);
+		pdev->dev.archdata.dma_offset = enable_ddw(pdev, pdn);
+		if (pdev->dev.archdata.dma_offset)
 			return true;
-		}
 	}
 
 	return false;
diff --git a/arch/powerpc/sysdev/dart_iommu.c b/arch/powerpc/sysdev/dart_iommu.c
index d42ba645d51d..809797dbe169 100644
--- a/arch/powerpc/sysdev/dart_iommu.c
+++ b/arch/powerpc/sysdev/dart_iommu.c
@@ -386,7 +386,7 @@ static bool dart_device_on_pcie(struct device *dev)
 static void pci_dma_dev_setup_dart(struct pci_dev *dev)
 {
 	if (dart_is_u4 && dart_device_on_pcie(&dev->dev))
-		set_dma_offset(&dev->dev, DART_U4_BYPASS_BASE);
+		dev->dev.archdata.dma_offset = DART_U4_BYPASS_BASE;
 	set_iommu_table_base(&dev->dev, &iommu_table_dart);
 }
 
* Unmerged path arch/powerpc/sysdev/fsl_pci.c
* Unmerged path drivers/misc/cxl/vphb.c
