drm/amd/display: Defer cursor lock until after VUPDATE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
commit 31ecebee9c36d5e5e113a357a655d993fa916174
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/31ecebee.failed

[Why]
We dropped the delay after changed the cursor functions locking the
entire pipe to locking just the CURSOR registers to fix page flip
stuttering - this introduced cursor stuttering instead, and an underflow
issue.

The cursor update can be delayed indefinitely if the cursor update
repeatedly happens right around VUPDATE.

The underflow issue can happen if we do a viewport update on a pipe
on the same frame where a cursor update happens around VUPDATE - the
old cursor registers are retained which can be in an invalid position.

This can cause a pipe hang and indefinite underflow.

[How]
The complex, ideal solution to the problem would be a software
triple buffering mechanism from the DM layer to program only one cursor
update per frame just before VUPDATE.

The simple workaround until we have that infrastructure in place is
this change - bring back the delay until VUPDATE before locking, but
with some corrections to the calculations.

This didn't work for all timings before because the calculation for
VUPDATE was wrong - it was using the offset from VSTARTUP instead and
didn't correctly handle the case where VUPDATE could be in the back
porch.

Add a new hardware sequencer function to use the existing helper to
calculate the real VUPDATE start and VUPDATE end - VUPDATE can last
multiple lines after all.

Change the udelay to incorporate the width of VUPDATE as well.

	Signed-off-by: Nicholas Kazlauskas <nicholas.kazlauskas@amd.com>
	Reviewed-by: Aric Cyr <Aric.Cyr@amd.com>
	Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 31ecebee9c36d5e5e113a357a655d993fa916174)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
#	drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h
#	drivers/gpu/drm/amd/display/dc/dcn10/dcn10_init.c
#	drivers/gpu/drm/amd/display/dc/dcn20/dcn20_init.c
#	drivers/gpu/drm/amd/display/dc/dcn21/dcn21_init.c
#	drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
diff --cc drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
index 2118ea21d7e9,82fc3d5b3b2a..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@@ -1417,7 -1622,84 +1417,88 @@@ static void dcn10_pipe_control_lock
  		pipe->stream_res.tg->funcs->unlock(pipe->stream_res.tg);
  
  	if (dc->debug.sanity_checks)
++<<<<<<< HEAD
 +		dcn10_verify_allow_pstate_change_high(dc);
++=======
+ 		hws->funcs.verify_allow_pstate_change_high(dc);
+ }
+ 
+ /**
+  * delay_cursor_until_vupdate() - Delay cursor update if too close to VUPDATE.
+  *
+  * Software keepout workaround to prevent cursor update locking from stalling
+  * out cursor updates indefinitely or from old values from being retained in
+  * the case where the viewport changes in the same frame as the cursor.
+  *
+  * The idea is to calculate the remaining time from VPOS to VUPDATE. If it's
+  * too close to VUPDATE, then stall out until VUPDATE finishes.
+  *
+  * TODO: Optimize cursor programming to be once per frame before VUPDATE
+  *       to avoid the need for this workaround.
+  */
+ static void delay_cursor_until_vupdate(struct dc *dc, struct pipe_ctx *pipe_ctx)
+ {
+ 	struct dc_stream_state *stream = pipe_ctx->stream;
+ 	struct crtc_position position;
+ 	uint32_t vupdate_start, vupdate_end;
+ 	unsigned int lines_to_vupdate, us_to_vupdate, vpos;
+ 	unsigned int us_per_line, us_vupdate;
+ 
+ 	if (!dc->hwss.calc_vupdate_position || !dc->hwss.get_position)
+ 		return;
+ 
+ 	if (!pipe_ctx->stream_res.stream_enc || !pipe_ctx->stream_res.tg)
+ 		return;
+ 
+ 	dc->hwss.calc_vupdate_position(dc, pipe_ctx, &vupdate_start,
+ 				       &vupdate_end);
+ 
+ 	dc->hwss.get_position(&pipe_ctx, 1, &position);
+ 	vpos = position.vertical_count;
+ 
+ 	/* Avoid wraparound calculation issues */
+ 	vupdate_start += stream->timing.v_total;
+ 	vupdate_end += stream->timing.v_total;
+ 	vpos += stream->timing.v_total;
+ 
+ 	if (vpos <= vupdate_start) {
+ 		/* VPOS is in VACTIVE or back porch. */
+ 		lines_to_vupdate = vupdate_start - vpos;
+ 	} else if (vpos > vupdate_end) {
+ 		/* VPOS is in the front porch. */
+ 		return;
+ 	} else {
+ 		/* VPOS is in VUPDATE. */
+ 		lines_to_vupdate = 0;
+ 	}
+ 
+ 	/* Calculate time until VUPDATE in microseconds. */
+ 	us_per_line =
+ 		stream->timing.h_total * 10000u / stream->timing.pix_clk_100hz;
+ 	us_to_vupdate = lines_to_vupdate * us_per_line;
+ 
+ 	/* 70 us is a conservative estimate of cursor update time*/
+ 	if (us_to_vupdate > 70)
+ 		return;
+ 
+ 	/* Stall out until the cursor update completes. */
+ 	us_vupdate = (vupdate_end - vupdate_start + 1) * us_per_line;
+ 	udelay(us_to_vupdate + us_vupdate);
+ }
+ 
+ void dcn10_cursor_lock(struct dc *dc, struct pipe_ctx *pipe, bool lock)
+ {
+ 	/* cursor lock is per MPCC tree, so only need to lock one pipe per stream */
+ 	if (!pipe || pipe->top_pipe)
+ 		return;
+ 
+ 	/* Prevent cursor lock from stalling out cursor updates. */
+ 	if (lock)
+ 		delay_cursor_until_vupdate(dc, pipe);
+ 
+ 	dc->res_pool->mpc->funcs->cursor_lock(dc->res_pool->mpc,
+ 			pipe->stream_res.opp->inst, lock);
++>>>>>>> 31ecebee9c36 (drm/amd/display: Defer cursor lock until after VUPDATE)
  }
  
  static bool wait_for_reset_trigger_to_occur(
@@@ -2908,34 -3303,8 +2989,39 @@@ int get_vupdate_offset_from_vsync(struc
  	return vertical_line_start;
  }
  
++<<<<<<< HEAD
 +void lock_all_pipes(struct dc *dc,
 +	struct dc_state *context,
 +	bool lock)
 +{
 +	struct pipe_ctx *pipe_ctx;
 +	struct timing_generator *tg;
 +	int i;
 +
 +	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 +		pipe_ctx = &context->res_ctx.pipe_ctx[i];
 +		tg = pipe_ctx->stream_res.tg;
 +		/*
 +		 * Only lock the top pipe's tg to prevent redundant
 +		 * (un)locking. Also skip if pipe is disabled.
 +		 */
 +		if (pipe_ctx->top_pipe ||
 +		    !pipe_ctx->stream || !pipe_ctx->plane_state ||
 +		    !tg->funcs->is_tg_enabled(tg))
 +			continue;
 +
 +		if (lock)
 +			tg->funcs->lock(tg);
 +		else
 +			tg->funcs->unlock(tg);
 +	}
 +}
 +
 +static void calc_vupdate_position(
++=======
+ void dcn10_calc_vupdate_position(
+ 		struct dc *dc,
++>>>>>>> 31ecebee9c36 (drm/amd/display: Defer cursor lock until after VUPDATE)
  		struct pipe_ctx *pipe_ctx,
  		uint32_t *start_line,
  		uint32_t *end_line)
diff --cc drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h
index d3616b1948cc,42b6e016d71e..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h
@@@ -31,16 -32,76 +31,88 @@@
  struct dc;
  
  void dcn10_hw_sequencer_construct(struct dc *dc);
 +extern void fill_display_configs(
 +	const struct dc_state *context,
 +	struct dm_pp_display_configuration *pp_display_cfg);
  
 +bool is_rgb_cspace(enum dc_color_space output_color_space);
 +
 +void hwss1_plane_atomic_disconnect(struct dc *dc, struct pipe_ctx *pipe_ctx);
 +
 +void dcn10_verify_allow_pstate_change_high(struct dc *dc);
 +
++<<<<<<< HEAD
++=======
+ int dcn10_get_vupdate_offset_from_vsync(struct pipe_ctx *pipe_ctx);
+ void dcn10_calc_vupdate_position(
+ 		struct dc *dc,
+ 		struct pipe_ctx *pipe_ctx,
+ 		uint32_t *start_line,
+ 		uint32_t *end_line);
+ void dcn10_setup_vupdate_interrupt(struct dc *dc, struct pipe_ctx *pipe_ctx);
+ enum dc_status dcn10_enable_stream_timing(
+ 		struct pipe_ctx *pipe_ctx,
+ 		struct dc_state *context,
+ 		struct dc *dc);
+ void dcn10_optimize_bandwidth(
+ 		struct dc *dc,
+ 		struct dc_state *context);
+ void dcn10_prepare_bandwidth(
+ 		struct dc *dc,
+ 		struct dc_state *context);
+ void dcn10_pipe_control_lock(
+ 	struct dc *dc,
+ 	struct pipe_ctx *pipe,
+ 	bool lock);
+ void dcn10_cursor_lock(struct dc *dc, struct pipe_ctx *pipe, bool lock);
+ void dcn10_blank_pixel_data(
+ 		struct dc *dc,
+ 		struct pipe_ctx *pipe_ctx,
+ 		bool blank);
+ void dcn10_unblank_stream(struct pipe_ctx *pipe_ctx,
+ 		struct dc_link_settings *link_settings);
+ void dcn10_program_output_csc(struct dc *dc,
+ 		struct pipe_ctx *pipe_ctx,
+ 		enum dc_color_space colorspace,
+ 		uint16_t *matrix,
+ 		int opp_id);
+ bool dcn10_set_output_transfer_func(struct dc *dc, struct pipe_ctx *pipe_ctx,
+ 				const struct dc_stream_state *stream);
+ bool dcn10_set_input_transfer_func(struct dc *dc, struct pipe_ctx *pipe_ctx,
+ 			const struct dc_plane_state *plane_state);
+ void dcn10_update_plane_addr(const struct dc *dc, struct pipe_ctx *pipe_ctx);
+ void dcn10_update_mpcc(struct dc *dc, struct pipe_ctx *pipe_ctx);
+ void dcn10_reset_hw_ctx_wrap(
+ 		struct dc *dc,
+ 		struct dc_state *context);
+ void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx);
+ void dcn10_lock_all_pipes(
+ 		struct dc *dc,
+ 		struct dc_state *context,
+ 		bool lock);
+ void dcn10_apply_ctx_for_surface(
+ 		struct dc *dc,
+ 		const struct dc_stream_state *stream,
+ 		int num_planes,
+ 		struct dc_state *context);
+ void dcn10_post_unlock_program_front_end(
+ 		struct dc *dc,
+ 		struct dc_state *context);
+ void dcn10_hubp_pg_control(
+ 		struct dce_hwseq *hws,
+ 		unsigned int hubp_inst,
+ 		bool power_on);
+ void dcn10_dpp_pg_control(
+ 		struct dce_hwseq *hws,
+ 		unsigned int dpp_inst,
+ 		bool power_on);
+ void dcn10_enable_power_gating_plane(
+ 	struct dce_hwseq *hws,
+ 	bool enable);
+ void dcn10_plane_atomic_disable(struct dc *dc, struct pipe_ctx *pipe_ctx);
+ void dcn10_disable_vga(
+ 	struct dce_hwseq *hws);
++>>>>>>> 31ecebee9c36 (drm/amd/display: Defer cursor lock until after VUPDATE)
  void dcn10_program_pipe(
  		struct dc *dc,
  		struct pipe_ctx *pipe_ctx,
diff --cc drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
index c6fd0f92eb43,08307f3796e3..000000000000
--- a/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
@@@ -43,160 -37,85 +43,178 @@@ enum vline_select 
  	VLINE1
  };
  
 +struct dce_hwseq_wa {
 +	bool blnd_crtc_trigger;
 +	bool DEGVIDCN10_253;
 +	bool false_optc_underflow;
 +	bool DEGVIDCN10_254;
 +};
 +
 +struct hwseq_wa_state {
 +	bool DEGVIDCN10_253_applied;
 +};
 +
 +struct dce_hwseq {
 +	struct dc_context *ctx;
 +	const struct dce_hwseq_registers *regs;
 +	const struct dce_hwseq_shift *shifts;
 +	const struct dce_hwseq_mask *masks;
 +	struct dce_hwseq_wa wa;
 +	struct hwseq_wa_state wa_state;
 +};
 +
  struct pipe_ctx;
  struct dc_state;
 +#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
  struct dc_stream_status;
  struct dc_writeback_info;
 +#endif
  struct dchub_init_data;
 -struct dc_static_screen_params;
 +struct dc_static_screen_events;
  struct resource_pool;
 +struct resource_context;
 +struct stream_resource;
 +#ifdef CONFIG_DRM_AMD_DC_DCN2_0
  struct dc_phy_addr_space_config;
  struct dc_virtual_addr_space_config;
 -struct dpp;
 -struct dce_hwseq;
 +#endif
  
  struct hw_sequencer_funcs {
 -	/* Embedded Display Related */
 -	void (*edp_power_control)(struct dc_link *link, bool enable);
 -	void (*edp_wait_for_hpd_ready)(struct dc_link *link, bool power_up);
  
 -	/* Pipe Programming Related */
 +	void (*disable_stream_gating)(struct dc *dc, struct pipe_ctx *pipe_ctx);
 +
 +	void (*enable_stream_gating)(struct dc *dc, struct pipe_ctx *pipe_ctx);
 +
  	void (*init_hw)(struct dc *dc);
 -	void (*enable_accelerated_mode)(struct dc *dc,
 -			struct dc_state *context);
 -	enum dc_status (*apply_ctx_to_hw)(struct dc *dc,
 -			struct dc_state *context);
 -	void (*disable_plane)(struct dc *dc, struct pipe_ctx *pipe_ctx);
 -	void (*apply_ctx_for_surface)(struct dc *dc,
 +
 +	void (*init_pipes)(struct dc *dc, struct dc_state *context);
 +
 +	enum dc_status (*apply_ctx_to_hw)(
 +			struct dc *dc, struct dc_state *context);
 +
 +	void (*reset_hw_ctx_wrap)(
 +			struct dc *dc, struct dc_state *context);
 +
 +	void (*apply_ctx_for_surface)(
 +			struct dc *dc,
  			const struct dc_stream_state *stream,
 -			int num_planes, struct dc_state *context);
 -	void (*program_front_end_for_ctx)(struct dc *dc,
 +			int num_planes,
  			struct dc_state *context);
 -	void (*post_unlock_program_front_end)(struct dc *dc,
 -			struct dc_state *context);
 -	void (*update_plane_addr)(const struct dc *dc,
 -			struct pipe_ctx *pipe_ctx);
 -	void (*update_dchub)(struct dce_hwseq *hws,
 -			struct dchub_init_data *dh_data);
 -	void (*wait_for_mpcc_disconnect)(struct dc *dc,
 -			struct resource_pool *res_pool,
 +
 +	void (*program_gamut_remap)(
  			struct pipe_ctx *pipe_ctx);
 -	void (*program_triplebuffer)(const struct dc *dc,
 -		struct pipe_ctx *pipe_ctx, bool enableTripleBuffer);
 -	void (*update_pending_status)(struct pipe_ctx *pipe_ctx);
 -
 -	/* Pipe Lock Related */
 -	void (*pipe_control_lock)(struct dc *dc,
 -			struct pipe_ctx *pipe, bool lock);
 -	void (*interdependent_update_lock)(struct dc *dc,
 -			struct dc_state *context, bool lock);
 -	void (*set_flip_control_gsl)(struct pipe_ctx *pipe_ctx,
 -			bool flip_immediate);
 -	void (*cursor_lock)(struct dc *dc, struct pipe_ctx *pipe, bool lock);
  
++<<<<<<< HEAD
 +	void (*program_output_csc)(struct dc *dc,
++=======
+ 	/* Timing Related */
+ 	void (*get_position)(struct pipe_ctx **pipe_ctx, int num_pipes,
+ 			struct crtc_position *position);
+ 	int (*get_vupdate_offset_from_vsync)(struct pipe_ctx *pipe_ctx);
+ 	void (*calc_vupdate_position)(
+ 			struct dc *dc,
+ 			struct pipe_ctx *pipe_ctx,
+ 			uint32_t *start_line,
+ 			uint32_t *end_line);
+ 	void (*enable_per_frame_crtc_position_reset)(struct dc *dc,
+ 			int group_size, struct pipe_ctx *grouped_pipes[]);
+ 	void (*enable_timing_synchronization)(struct dc *dc,
+ 			int group_index, int group_size,
+ 			struct pipe_ctx *grouped_pipes[]);
+ 	void (*setup_periodic_interrupt)(struct dc *dc,
++>>>>>>> 31ecebee9c36 (drm/amd/display: Defer cursor lock until after VUPDATE)
  			struct pipe_ctx *pipe_ctx,
 -			enum vline_select vline);
 -	void (*set_drr)(struct pipe_ctx **pipe_ctx, int num_pipes,
 -			unsigned int vmin, unsigned int vmax,
 -			unsigned int vmid, unsigned int vmid_frame_number);
 -	void (*set_static_screen_control)(struct pipe_ctx **pipe_ctx,
 -			int num_pipes,
 -			const struct dc_static_screen_params *events);
 +			enum dc_color_space colorspace,
 +			uint16_t *matrix,
 +			int opp_id);
 +
 +#if defined(CONFIG_DRM_AMD_DC_DCN2_0)
 +	void (*program_triplebuffer)(
 +		const struct dc *dc,
 +		struct pipe_ctx *pipe_ctx,
 +		bool enableTripleBuffer);
 +	void (*set_flip_control_gsl)(
 +		struct pipe_ctx *pipe_ctx,
 +		bool flip_immediate);
 +#endif
 +
 +	void (*update_plane_addr)(
 +		const struct dc *dc,
 +		struct pipe_ctx *pipe_ctx);
 +
 +	void (*plane_atomic_disconnect)(
 +		struct dc *dc,
 +		struct pipe_ctx *pipe_ctx);
 +
 +	void (*update_dchub)(
 +		struct dce_hwseq *hws,
 +		struct dchub_init_data *dh_data);
 +
 +#ifdef CONFIG_DRM_AMD_DC_DCN2_0
 +	int (*init_sys_ctx)(
 +			struct dce_hwseq *hws,
 +			struct dc *dc,
 +			struct dc_phy_addr_space_config *pa_config);
 +	void (*init_vm_ctx)(
 +			struct dce_hwseq *hws,
 +			struct dc *dc,
 +			struct dc_virtual_addr_space_config *va_config,
 +			int vmid);
 +#endif
 +	void (*update_mpcc)(
 +		struct dc *dc,
 +		struct pipe_ctx *pipe_ctx);
 +
 +	void (*update_pending_status)(
 +			struct pipe_ctx *pipe_ctx);
 +
 +	bool (*set_input_transfer_func)(
 +				struct pipe_ctx *pipe_ctx,
 +				const struct dc_plane_state *plane_state);
 +
 +	bool (*set_output_transfer_func)(
 +				struct pipe_ctx *pipe_ctx,
 +				const struct dc_stream_state *stream);
 +
 +	void (*power_down)(struct dc *dc);
 +
 +	void (*enable_accelerated_mode)(struct dc *dc, struct dc_state *context);
 +
 +	void (*enable_timing_synchronization)(
 +			struct dc *dc,
 +			int group_index,
 +			int group_size,
 +			struct pipe_ctx *grouped_pipes[]);
 +
 +	void (*enable_per_frame_crtc_position_reset)(
 +			struct dc *dc,
 +			int group_size,
 +			struct pipe_ctx *grouped_pipes[]);
 +
 +	void (*enable_display_pipe_clock_gating)(
 +					struct dc_context *ctx,
 +					bool clock_gating);
 +
 +	bool (*enable_display_power_gating)(
 +					struct dc *dc,
 +					uint8_t controller_id,
 +					struct dc_bios *dcb,
 +					enum pipe_gating_control power_gating);
 +
 +	void (*disable_plane)(struct dc *dc, struct pipe_ctx *pipe_ctx);
 +
 +	void (*update_info_frame)(struct pipe_ctx *pipe_ctx);
 +
 +	void (*send_immediate_sdp_message)(
 +				struct pipe_ctx *pipe_ctx,
 +				const uint8_t *custom_sdp_message,
 +				unsigned int sdp_message_size);
  
 -	/* Stream Related */
  	void (*enable_stream)(struct pipe_ctx *pipe_ctx);
 -	void (*disable_stream)(struct pipe_ctx *pipe_ctx);
 -	void (*blank_stream)(struct pipe_ctx *pipe_ctx);
 +
 +	void (*disable_stream)(struct pipe_ctx *pipe_ctx,
 +			int option);
 +
  	void (*unblank_stream)(struct pipe_ctx *pipe_ctx,
  			struct dc_link_settings *link_settings);
  
* Unmerged path drivers/gpu/drm/amd/display/dc/dcn10/dcn10_init.c
* Unmerged path drivers/gpu/drm/amd/display/dc/dcn20/dcn20_init.c
* Unmerged path drivers/gpu/drm/amd/display/dc/dcn21/dcn21_init.c
* Unmerged path drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
* Unmerged path drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.h
* Unmerged path drivers/gpu/drm/amd/display/dc/dcn10/dcn10_init.c
* Unmerged path drivers/gpu/drm/amd/display/dc/dcn20/dcn20_init.c
* Unmerged path drivers/gpu/drm/amd/display/dc/dcn21/dcn21_init.c
* Unmerged path drivers/gpu/drm/amd/display/dc/inc/hw_sequencer.h
