io_uring: remove io_free_req_find_next()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pavel Begunkov <asml.silence@gmail.com>
commit 70cf9f3270a5c5148e93a526dc1e51965259e70c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/70cf9f32.failed

There is only one one-liner user of io_free_req_find_next(). Inline it.

	Signed-off-by: Pavel Begunkov <asml.silence@gmail.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 70cf9f3270a5c5148e93a526dc1e51965259e70c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 66de1d702552,6d8665e8f0e8..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -679,14 -964,51 +679,59 @@@ static void io_free_req(struct io_kioc
  	 * dependencies to the next request. In case of failure, fail the rest
  	 * of the chain.
  	 */
++<<<<<<< HEAD
 +	if (req->flags & REQ_F_LINK) {
 +		if (req->flags & REQ_F_FAIL_LINK)
 +			io_fail_links(req);
++=======
+ 	if (req->flags & REQ_F_FAIL_LINK) {
+ 		io_fail_links(req);
+ 	} else if ((req->flags & (REQ_F_LINK_TIMEOUT | REQ_F_COMP_LOCKED)) ==
+ 			REQ_F_LINK_TIMEOUT) {
+ 		struct io_ring_ctx *ctx = req->ctx;
+ 		unsigned long flags;
+ 
+ 		/*
+ 		 * If this is a timeout link, we could be racing with the
+ 		 * timeout timer. Grab the completion lock for this case to
+ 		 * protect against that.
+ 		 */
+ 		spin_lock_irqsave(&ctx->completion_lock, flags);
+ 		io_req_link_next(req, nxt);
+ 		spin_unlock_irqrestore(&ctx->completion_lock, flags);
+ 	} else {
+ 		io_req_link_next(req, nxt);
+ 	}
+ }
+ 
+ static void io_free_req(struct io_kiocb *req)
+ {
+ 	io_req_find_next(req, NULL);
+ 	__io_free_req(req);
+ }
+ 
+ /*
+  * Drop reference to request, return next in chain (if there is one) if this
+  * was the last reference to this request.
+  */
+ static void io_put_req_find_next(struct io_kiocb *req, struct io_kiocb **nxtptr)
+ {
+ 	struct io_kiocb *nxt = NULL;
+ 
+ 	io_req_find_next(req, &nxt);
+ 
+ 	if (refcount_dec_and_test(&req->refs))
+ 		__io_free_req(req);
+ 
+ 	if (nxt) {
+ 		if (nxtptr)
+ 			*nxtptr = nxt;
++>>>>>>> 70cf9f3270a5 (io_uring: remove io_free_req_find_next())
  		else
 -			io_queue_async_work(nxt);
 +			io_req_link_next(req);
  	}
 +
 +	__io_free_req(req);
  }
  
  static void io_put_req(struct io_kiocb *req)
* Unmerged path fs/io_uring.c
