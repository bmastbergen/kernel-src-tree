mm: update ptep_modify_prot_commit to take old pte value as arg

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
commit 04a8645304500be88b3345b65fef7efe58016166
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/04a86453.failed

Architectures like ppc64 require to do a conditional tlb flush based on
the old and new value of pte.  Enable that by passing old pte value as
the arg.

Link: http://lkml.kernel.org/r/20190116085035.29729-3-aneesh.kumar@linux.ibm.com
	Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Ingo Molnar <mingo@elte.hu>
	Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Nicholas Piggin <npiggin@gmail.com>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 04a8645304500be88b3345b65fef7efe58016166)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/pgtable.h
#	arch/s390/mm/pgtable.c
#	arch/x86/include/asm/paravirt.h
#	fs/proc/task_mmu.c
#	mm/memory.c
#	mm/mprotect.c
diff --cc arch/s390/include/asm/pgtable.h
index 78d1a7110bc1,76dc344edb8c..000000000000
--- a/arch/s390/include/asm/pgtable.h
+++ b/arch/s390/include/asm/pgtable.h
@@@ -1080,8 -1069,9 +1080,14 @@@ static inline pte_t ptep_get_and_clear(
  }
  
  #define __HAVE_ARCH_PTEP_MODIFY_PROT_TRANSACTION
++<<<<<<< HEAD
 +pte_t ptep_modify_prot_start(struct mm_struct *, unsigned long, pte_t *);
 +void ptep_modify_prot_commit(struct mm_struct *, unsigned long, pte_t *, pte_t);
++=======
+ pte_t ptep_modify_prot_start(struct vm_area_struct *, unsigned long, pte_t *);
+ void ptep_modify_prot_commit(struct vm_area_struct *, unsigned long,
+ 			     pte_t *, pte_t, pte_t);
++>>>>>>> 04a864530450 (mm: update ptep_modify_prot_commit to take old pte value as arg)
  
  #define __HAVE_ARCH_PTEP_CLEAR_FLUSH
  static inline pte_t ptep_clear_flush(struct vm_area_struct *vma,
diff --cc arch/s390/mm/pgtable.c
index ae894ac83fd6,8485d6dc2754..000000000000
--- a/arch/s390/mm/pgtable.c
+++ b/arch/s390/mm/pgtable.c
@@@ -318,12 -319,12 +318,17 @@@ pte_t ptep_modify_prot_start(struct mm_
  	}
  	return old;
  }
 +EXPORT_SYMBOL(ptep_modify_prot_start);
  
++<<<<<<< HEAD
 +void ptep_modify_prot_commit(struct mm_struct *mm, unsigned long addr,
 +			     pte_t *ptep, pte_t pte)
++=======
+ void ptep_modify_prot_commit(struct vm_area_struct *vma, unsigned long addr,
+ 			     pte_t *ptep, pte_t old_pte, pte_t pte)
++>>>>>>> 04a864530450 (mm: update ptep_modify_prot_commit to take old pte value as arg)
  {
  	pgste_t pgste;
 -	struct mm_struct *mm = vma->vm_mm;
  
  	if (!MACHINE_HAS_NX)
  		pte_val(pte) &= ~_PAGE_NOEXEC;
diff --cc arch/x86/include/asm/paravirt.h
index 76dbf9fc8714,c25c38a05c1c..000000000000
--- a/arch/x86/include/asm/paravirt.h
+++ b/arch/x86/include/asm/paravirt.h
@@@ -437,15 -432,16 +437,20 @@@ static inline pte_t ptep_modify_prot_st
  	return (pte_t) { .pte = ret };
  }
  
++<<<<<<< HEAD
 +static inline void ptep_modify_prot_commit(struct mm_struct *mm, unsigned long addr,
 +					   pte_t *ptep, pte_t pte)
++=======
+ static inline void ptep_modify_prot_commit(struct vm_area_struct *vma, unsigned long addr,
+ 					   pte_t *ptep, pte_t old_pte, pte_t pte)
++>>>>>>> 04a864530450 (mm: update ptep_modify_prot_commit to take old pte value as arg)
  {
 -
  	if (sizeof(pteval_t) > sizeof(long))
  		/* 5 arg words */
 -		pv_ops.mmu.ptep_modify_prot_commit(vma, addr, ptep, pte);
 +		pv_mmu_ops.ptep_modify_prot_commit(mm, addr, ptep, pte);
  	else
 -		PVOP_VCALL4(mmu.ptep_modify_prot_commit,
 -			    vma, addr, ptep, pte.pte);
 +		PVOP_VCALL4(pv_mmu_ops.ptep_modify_prot_commit,
 +			    mm, addr, ptep, pte.pte);
  }
  
  static inline void set_pte(pte_t *ptep, pte_t pte)
diff --cc fs/proc/task_mmu.c
index 85cefc505c86,beccb0b1d57c..000000000000
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@@ -947,10 -948,12 +947,19 @@@ static inline void clear_soft_dirty(str
  	pte_t ptent = *pte;
  
  	if (pte_present(ptent)) {
++<<<<<<< HEAD
 +		ptent = ptep_modify_prot_start(vma->vm_mm, addr, pte);
 +		ptent = pte_wrprotect(ptent);
 +		ptent = pte_clear_soft_dirty(ptent);
 +		ptep_modify_prot_commit(vma->vm_mm, addr, pte, ptent);
++=======
+ 		pte_t old_pte;
+ 
+ 		old_pte = ptep_modify_prot_start(vma, addr, pte);
+ 		ptent = pte_wrprotect(old_pte);
+ 		ptent = pte_clear_soft_dirty(ptent);
+ 		ptep_modify_prot_commit(vma, addr, pte, old_pte, ptent);
++>>>>>>> 04a864530450 (mm: update ptep_modify_prot_commit to take old pte value as arg)
  	} else if (is_swap_pte(ptent)) {
  		ptent = pte_swp_clear_soft_dirty(ptent);
  		set_pte_at(vma->vm_mm, addr, pte, ptent);
diff --cc mm/memory.c
index cb40d471f31c,557c6fffedd1..000000000000
--- a/mm/memory.c
+++ b/mm/memory.c
@@@ -3900,12 -3619,12 +3900,21 @@@ static vm_fault_t do_numa_page(struct v
  	 * Make it present again, Depending on how arch implementes non
  	 * accessible ptes, some can allow access by kernel mode.
  	 */
++<<<<<<< HEAD
 +	pte = ptep_modify_prot_start(vma->vm_mm, vmf->address, vmf->pte);
 +	pte = pte_modify(pte, vma->vm_page_prot);
 +	pte = pte_mkyoung(pte);
 +	if (was_writable)
 +		pte = pte_mkwrite(pte);
 +	ptep_modify_prot_commit(vma->vm_mm, vmf->address, vmf->pte, pte);
++=======
+ 	old_pte = ptep_modify_prot_start(vma, vmf->address, vmf->pte);
+ 	pte = pte_modify(old_pte, vma->vm_page_prot);
+ 	pte = pte_mkyoung(pte);
+ 	if (was_writable)
+ 		pte = pte_mkwrite(pte);
+ 	ptep_modify_prot_commit(vma, vmf->address, vmf->pte, old_pte, pte);
++>>>>>>> 04a864530450 (mm: update ptep_modify_prot_commit to take old pte value as arg)
  	update_mmu_cache(vma, vmf->address, vmf->pte);
  
  	page = vm_normal_page(vma, vmf->address, pte);
diff --cc mm/mprotect.c
index 86837f25055b,028c724dcb1a..000000000000
--- a/mm/mprotect.c
+++ b/mm/mprotect.c
@@@ -110,8 -110,8 +110,13 @@@ static unsigned long change_pte_range(s
  					continue;
  			}
  
++<<<<<<< HEAD
 +			ptent = ptep_modify_prot_start(mm, addr, pte);
 +			ptent = pte_modify(ptent, newprot);
++=======
+ 			oldpte = ptep_modify_prot_start(vma, addr, pte);
+ 			ptent = pte_modify(oldpte, newprot);
++>>>>>>> 04a864530450 (mm: update ptep_modify_prot_commit to take old pte value as arg)
  			if (preserve_write)
  				ptent = pte_mk_savedwrite(ptent);
  
@@@ -121,7 -121,7 +126,11 @@@
  					 !(vma->vm_flags & VM_SOFTDIRTY))) {
  				ptent = pte_mkwrite(ptent);
  			}
++<<<<<<< HEAD
 +			ptep_modify_prot_commit(mm, addr, pte, ptent);
++=======
+ 			ptep_modify_prot_commit(vma, addr, pte, oldpte, ptent);
++>>>>>>> 04a864530450 (mm: update ptep_modify_prot_commit to take old pte value as arg)
  			pages++;
  		} else if (IS_ENABLED(CONFIG_MIGRATION)) {
  			swp_entry_t entry = pte_to_swp_entry(oldpte);
* Unmerged path arch/s390/include/asm/pgtable.h
* Unmerged path arch/s390/mm/pgtable.c
* Unmerged path arch/x86/include/asm/paravirt.h
* Unmerged path fs/proc/task_mmu.c
diff --git a/include/asm-generic/pgtable.h b/include/asm-generic/pgtable.h
index 6ebca2e305b2..b67a4b9e789c 100644
--- a/include/asm-generic/pgtable.h
+++ b/include/asm-generic/pgtable.h
@@ -657,7 +657,7 @@ static inline pte_t ptep_modify_prot_start(struct mm_struct *mm,
  */
 static inline void ptep_modify_prot_commit(struct mm_struct *mm,
 					   unsigned long addr,
-					   pte_t *ptep, pte_t pte)
+					   pte_t *ptep, pte_t old_pte, pte_t pte)
 {
 	__ptep_modify_prot_commit(mm, addr, ptep, pte);
 }
* Unmerged path mm/memory.c
* Unmerged path mm/mprotect.c
