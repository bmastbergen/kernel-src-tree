EDAC/ghes: Setup DIMM label from DMI and use it in error reports

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Robert Richter <rrichter@marvell.com>
commit cb51a371d08e813b0be4253ad9efbc8488b69149
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/cb51a371.failed

The ghes driver reports errors with 'unknown label' even if the actual
DIMM label is known, e.g.:

 EDAC MC0: 1 CE Single-bit ECC on unknown label (node:0 card:0
   module:0 rank:1 bank:0 col:13 bit_pos:16 DIMM location:N0 DIMM_A0
   page:0x966a9b3 offset:0x0 grain:1 syndrome:0x0 - APEI location:
   node:0 card:0 module:0 rank:1 bank:0 col:13 bit_pos:16 DIMM
   location:N0 DIMM_A0 status(0x0000000000000400): Storage error in
   DRAM memory)

Fix this by using struct dimm_info's label string in error reports:

 EDAC MC0: 1 CE Single-bit ECC on N0 DIMM_A0 (node:0 card:0 module:0
   rank:1 bank:515 col:14 bit_pos:16 DIMM location:N0 DIMM_A0
   page:0x99223d8 offset:0x0 grain:1 syndrome:0x0 - APEI location:
   node:0 card:0 module:0 rank:1 bank:515 col:14 bit_pos:16 DIMM
   location:N0 DIMM_A0 status(0x0000000000000400): Storage error in
   DRAM memory)

The labels are initialized by reading the bank and device strings
from DMI. Now, the label information can also read from sysfs. E.g. a
ThunderX2 system will show the following:

  /sys/devices/system/edac/mc/mc0/dimm0/dimm_label:N0 DIMM_A0
  /sys/devices/system/edac/mc/mc0/dimm1/dimm_label:N0 DIMM_B0
  /sys/devices/system/edac/mc/mc0/dimm2/dimm_label:N0 DIMM_C0
  /sys/devices/system/edac/mc/mc0/dimm3/dimm_label:N0 DIMM_D0
  /sys/devices/system/edac/mc/mc0/dimm4/dimm_label:N0 DIMM_E0
  /sys/devices/system/edac/mc/mc0/dimm5/dimm_label:N0 DIMM_F0
  /sys/devices/system/edac/mc/mc0/dimm6/dimm_label:N0 DIMM_G0
  /sys/devices/system/edac/mc/mc0/dimm7/dimm_label:N0 DIMM_H0
  /sys/devices/system/edac/mc/mc0/dimm8/dimm_label:N1 DIMM_I0
  /sys/devices/system/edac/mc/mc0/dimm9/dimm_label:N1 DIMM_J0
  /sys/devices/system/edac/mc/mc0/dimm10/dimm_label:N1 DIMM_K0
  /sys/devices/system/edac/mc/mc0/dimm11/dimm_label:N1 DIMM_L0
  /sys/devices/system/edac/mc/mc0/dimm12/dimm_label:N1 DIMM_M0
  /sys/devices/system/edac/mc/mc0/dimm13/dimm_label:N1 DIMM_N0
  /sys/devices/system/edac/mc/mc0/dimm14/dimm_label:N1 DIMM_O0
  /sys/devices/system/edac/mc/mc0/dimm15/dimm_label:N1 DIMM_P0

Since dimm_labels can be rewritten, that label will be used in a later
error report:

  # echo foobar >/sys/devices/system/edac/mc/mc0/dimm0/dimm_label
  # # some error injection here
  # dmesg | grep foobar
  [ 751.383533] EDAC MC0: 1 CE Single-bit ECC on foobar (node:0 card:0
  module:0 rank:1 bank:259 col:3 bit_pos:16 DIMM location:N0 DIMM_A0
  page:0x8c8dc74 offset:0x0 grain:1 syndrome:0x0 - APEI location:
  node:0 card:0 module:0 rank:1 bank:259 col:3 bit_pos:16 DIMM
  location:N0 DIMM_A0 status(0x0000000000000400): Storage error in DRAM
  memory)

 [ bp: Remove curly brackets around a single if-statement in dimm_setup_label(). ]

	Signed-off-by: Robert Richter <rrichter@marvell.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
Link: https://lkml.kernel.org/r/20200528101307.23245-1-rrichter@marvell.com
(cherry picked from commit cb51a371d08e813b0be4253ad9efbc8488b69149)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/ghes_edac.c
diff --cc drivers/edac/ghes_edac.c
index 9b7b6e24fba2,94c70c95a896..000000000000
--- a/drivers/edac/ghes_edac.c
+++ b/drivers/edac/ghes_edac.c
@@@ -90,15 -87,27 +90,35 @@@ static void ghes_edac_count_dimms(cons
  		(*num_dimm)++;
  }
  
- static int get_dimm_smbios_index(struct mem_ctl_info *mci, u16 handle)
+ static struct dimm_info *find_dimm_by_handle(struct mem_ctl_info *mci, u16 handle)
  {
 -	struct dimm_info *dimm;
 +	int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < mci->tot_dimms; i++) {
 +		if (mci->dimms[i]->smbios_handle == handle)
 +			return i;
 +	}
 +	return -1;
++=======
+ 	mci_for_each_dimm(mci, dimm) {
+ 		if (dimm->smbios_handle == handle)
+ 			return dimm;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static void dimm_setup_label(struct dimm_info *dimm, u16 handle)
+ {
+ 	const char *bank = NULL, *device = NULL;
+ 
+ 	dmi_memdev_name(handle, &bank, &device);
+ 
+ 	/* both strings must be non-zero */
+ 	if (bank && *bank && device && *device)
+ 		snprintf(dimm->label, sizeof(dimm->label), "%s %s", bank, device);
++>>>>>>> cb51a371d08e (EDAC/ghes: Setup DIMM label from DMI and use it in error reports)
  }
  
  static void ghes_edac_dmidecode(const struct dmi_header *dh, void *arg)
@@@ -233,7 -236,7 +251,11 @@@ void ghes_edac_report_mem_error(int sev
  	/* Cleans the error report buffer */
  	memset(e, 0, sizeof (*e));
  	e->error_count = 1;
++<<<<<<< HEAD
 +	strcpy(e->label, "unknown label");
++=======
+ 	e->grain = 1;
++>>>>>>> cb51a371d08e (EDAC/ghes: Setup DIMM label from DMI and use it in error reports)
  	e->msg = pvt->msg;
  	e->other_detail = pvt->other_detail;
  	e->top_layer = -1;
@@@ -359,18 -362,22 +381,29 @@@
  			p += sprintf(p, "DIMM DMI handle: 0x%.4x ",
  				     mem_err->mem_dev_handle);
  
++<<<<<<< HEAD
 +		index = get_dimm_smbios_index(mci, mem_err->mem_dev_handle);
 +		if (index >= 0) {
 +			e->top_layer = index;
 +			e->enable_per_layer_report = true;
 +		}
 +
++=======
+ 		dimm = find_dimm_by_handle(mci, mem_err->mem_dev_handle);
+ 		if (dimm) {
+ 			e->top_layer = dimm->idx;
+ 			strcpy(e->label, dimm->label);
+ 		}
++>>>>>>> cb51a371d08e (EDAC/ghes: Setup DIMM label from DMI and use it in error reports)
  	}
  	if (p > e->location)
  		*(p - 1) = '\0';
  
+ 	if (!*e->label)
+ 		strcpy(e->label, "unknown memory");
+ 
  	/* All other fields are mapped on e->other_detail */
  	p = pvt->other_detail;
 -	p += snprintf(p, sizeof(pvt->other_detail),
 -		"APEI location: %s ", e->location);
  	if (mem_err->validation_bits & CPER_MEM_VALID_ERROR_STATUS) {
  		u64 status = mem_err->error_status;
  
* Unmerged path drivers/edac/ghes_edac.c
