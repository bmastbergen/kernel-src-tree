drm/ast: fix missing break in switch statement for format->cpp[0] case 4

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [drm] drm/ast: fix missing break in switch statement for format->cppcase 4 (Lyude Paul) [1827812]
Rebuild_FUZZ: 97.14%
commit-author Colin Ian King <colin.king@canonical.com>
commit 291ddeb621e4a9f1ced8302a777fbd7fbda058c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/291ddeb6.failed

Currently the switch statement for format->cpp[0] value 4 assigns
color_index which is never read again and then falls through to the
default case and returns. This looks like a missing break statement
bug. Fix this by adding a break statement.

Addresses-Coverity: ("Unused value")
Fixes: 259d14a76a27 ("drm/ast: Split ast_set_vbios_mode_info()")
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
	Tested-by: Thomas Zimmermann <tzimmermann@suse.de>
	Reviewed-by: Thomas Zimmermann <tzimmermann@suse.de>
Link: https://patchwork.freedesktop.org/patch/msgid/20200610115804.1132338-1-colin.king@canonical.com
(cherry picked from commit 291ddeb621e4a9f1ced8302a777fbd7fbda058c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/ast/ast_mode.c
diff --cc drivers/gpu/drm/ast/ast_mode.c
index a1cb020e07e5,3a3a511670c9..000000000000
--- a/drivers/gpu/drm/ast/ast_mode.c
+++ b/drivers/gpu/drm/ast/ast_mode.c
@@@ -199,6 -207,46 +199,49 @@@ static bool ast_get_vbios_mode_info(str
  					 vbios_mode->enh_table->vfp +
  					 vbios_mode->enh_table->vsync);
  
++<<<<<<< HEAD
++=======
+ 	return true;
+ }
+ 
+ static void ast_set_vbios_color_reg(struct ast_private *ast,
+ 				    const struct drm_format_info *format,
+ 				    const struct ast_vbios_mode_info *vbios_mode)
+ {
+ 	u32 color_index;
+ 
+ 	switch (format->cpp[0]) {
+ 	case 1:
+ 		color_index = VGAModeIndex - 1;
+ 		break;
+ 	case 2:
+ 		color_index = HiCModeIndex;
+ 		break;
+ 	case 3:
+ 	case 4:
+ 		color_index = TrueCModeIndex;
+ 		break;
+ 	default:
+ 		return;
+ 	}
+ 
+ 	ast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x8c, (u8)((color_index & 0x0f) << 4));
+ 
+ 	ast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x91, 0x00);
+ 
+ 	if (vbios_mode->enh_table->flags & NewModeInfo) {
+ 		ast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x91, 0xa8);
+ 		ast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x92, format->cpp[0] * 8);
+ 	}
+ }
+ 
+ static void ast_set_vbios_mode_reg(struct ast_private *ast,
+ 				   const struct drm_display_mode *adjusted_mode,
+ 				   const struct ast_vbios_mode_info *vbios_mode)
+ {
+ 	u32 refresh_rate_index, mode_id;
+ 
++>>>>>>> 291ddeb621e4 (drm/ast: fix missing break in switch statement for format->cpp[0] case 4)
  	refresh_rate_index = vbios_mode->enh_table->refresh_rate_index;
  	mode_id = vbios_mode->enh_table->mode_id;
  
* Unmerged path drivers/gpu/drm/ast/ast_mode.c
