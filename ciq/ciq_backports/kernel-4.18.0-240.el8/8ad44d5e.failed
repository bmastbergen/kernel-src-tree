libceph: read_from_replica option

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ilya Dryomov <idryomov@gmail.com>
commit 8ad44d5e0d1eda7e4a0ed382174888476dc81789
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8ad44d5e.failed

Expose replica reads through read_from_replica=balance and
read_from_replica=localize.  The default is to read from primary
(read_from_replica=no).

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
(cherry picked from commit 8ad44d5e0d1eda7e4a0ed382174888476dc81789)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/ceph_common.c
diff --cc net/ceph/ceph_common.c
index 9994af52dfb4,9bab3e9a039b..000000000000
--- a/net/ceph/ceph_common.c
+++ b/net/ceph/ceph_common.c
@@@ -260,48 -264,79 +260,91 @@@ enum 
  	Opt_secret,
  	Opt_key,
  	Opt_ip,
++<<<<<<< HEAD
 +	Opt_last_string,
++=======
+ 	Opt_crush_location,
+ 	Opt_read_from_replica,
++>>>>>>> 8ad44d5e0d1e (libceph: read_from_replica option)
  	/* string args above */
  	Opt_share,
 +	Opt_noshare,
  	Opt_crc,
 +	Opt_nocrc,
  	Opt_cephx_require_signatures,
 +	Opt_nocephx_require_signatures,
  	Opt_cephx_sign_messages,
 +	Opt_nocephx_sign_messages,
  	Opt_tcp_nodelay,
 +	Opt_notcp_nodelay,
  	Opt_abort_on_full,
  };
  
++<<<<<<< HEAD
 +static match_table_t opt_tokens = {
 +	{Opt_osdtimeout, "osdtimeout=%d"},
 +	{Opt_osdkeepalivetimeout, "osdkeepalive=%d"},
 +	{Opt_mount_timeout, "mount_timeout=%d"},
 +	{Opt_osd_idle_ttl, "osd_idle_ttl=%d"},
 +	{Opt_osd_request_timeout, "osd_request_timeout=%d"},
 +	/* int args above */
 +	{Opt_fsid, "fsid=%s"},
 +	{Opt_name, "name=%s"},
 +	{Opt_secret, "secret=%s"},
 +	{Opt_key, "key=%s"},
 +	{Opt_ip, "ip=%s"},
 +	/* string args above */
 +	{Opt_share, "share"},
 +	{Opt_noshare, "noshare"},
 +	{Opt_crc, "crc"},
 +	{Opt_nocrc, "nocrc"},
 +	{Opt_cephx_require_signatures, "cephx_require_signatures"},
 +	{Opt_nocephx_require_signatures, "nocephx_require_signatures"},
 +	{Opt_cephx_sign_messages, "cephx_sign_messages"},
 +	{Opt_nocephx_sign_messages, "nocephx_sign_messages"},
 +	{Opt_tcp_nodelay, "tcp_nodelay"},
 +	{Opt_notcp_nodelay, "notcp_nodelay"},
 +	{Opt_abort_on_full, "abort_on_full"},
 +	{-1, NULL}
++=======
+ enum {
+ 	Opt_read_from_replica_no,
+ 	Opt_read_from_replica_balance,
+ 	Opt_read_from_replica_localize,
+ };
+ 
+ static const struct constant_table ceph_param_read_from_replica[] = {
+ 	{"no",		Opt_read_from_replica_no},
+ 	{"balance",	Opt_read_from_replica_balance},
+ 	{"localize",	Opt_read_from_replica_localize},
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec ceph_parameters[] = {
+ 	fsparam_flag	("abort_on_full",		Opt_abort_on_full),
+ 	fsparam_flag_no ("cephx_require_signatures",	Opt_cephx_require_signatures),
+ 	fsparam_flag_no ("cephx_sign_messages",		Opt_cephx_sign_messages),
+ 	fsparam_flag_no ("crc",				Opt_crc),
+ 	fsparam_string	("crush_location",		Opt_crush_location),
+ 	fsparam_string	("fsid",			Opt_fsid),
+ 	fsparam_string	("ip",				Opt_ip),
+ 	fsparam_string	("key",				Opt_key),
+ 	fsparam_u32	("mount_timeout",		Opt_mount_timeout),
+ 	fsparam_string	("name",			Opt_name),
+ 	fsparam_u32	("osd_idle_ttl",		Opt_osd_idle_ttl),
+ 	fsparam_u32	("osd_request_timeout",		Opt_osd_request_timeout),
+ 	fsparam_u32	("osdkeepalive",		Opt_osdkeepalivetimeout),
+ 	__fsparam	(fs_param_is_s32, "osdtimeout", Opt_osdtimeout,
+ 			 fs_param_deprecated, NULL),
+ 	fsparam_enum	("read_from_replica",		Opt_read_from_replica,
+ 			 ceph_param_read_from_replica),
+ 	fsparam_string	("secret",			Opt_secret),
+ 	fsparam_flag_no ("share",			Opt_share),
+ 	fsparam_flag_no ("tcp_nodelay",			Opt_tcp_nodelay),
+ 	{}
++>>>>>>> 8ad44d5e0d1e (libceph: read_from_replica option)
  };
  
 -struct ceph_options *ceph_alloc_options(void)
 -{
 -	struct ceph_options *opt;
 -
 -	opt = kzalloc(sizeof(*opt), GFP_KERNEL);
 -	if (!opt)
 -		return NULL;
 -
 -	opt->crush_locs = RB_ROOT;
 -	opt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),
 -				GFP_KERNEL);
 -	if (!opt->mon_addr) {
 -		kfree(opt);
 -		return NULL;
 -	}
 -
 -	opt->flags = CEPH_OPT_DEFAULT;
 -	opt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;
 -	opt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;
 -	opt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;
 -	opt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;
 -	return opt;
 -}
 -EXPORT_SYMBOL(ceph_alloc_options);
 -
  void ceph_destroy_options(struct ceph_options *opt)
  {
  	dout("destroy_options %p\n", opt);
@@@ -360,217 -401,187 +403,252 @@@ out
  	return err;
  }
  
 -int ceph_parse_mon_ips(const char *buf, size_t len, struct ceph_options *opt,
 -		       struct fc_log *l)
 +struct ceph_options *
 +ceph_parse_options(char *options, const char *dev_name,
 +			const char *dev_name_end,
 +			int (*parse_extra_token)(char *c, void *private),
 +			void *private)
  {
 -	struct p_log log = {.prefix = "libceph", .log = l};
 -	int ret;
 +	struct ceph_options *opt;
 +	const char *c;
 +	int err = -ENOMEM;
 +	substring_t argstr[MAX_OPT_ARGS];
  
 -	/* ip1[:port1][,ip2[:port2]...] */
 -	ret = ceph_parse_ips(buf, buf + len, opt->mon_addr, CEPH_MAX_MON,
 -			     &opt->num_mon);
 -	if (ret) {
 -		error_plog(&log, "Failed to parse monitor IPs: %d", ret);
 -		return ret;
 -	}
 +	opt = kzalloc(sizeof(*opt), GFP_KERNEL);
 +	if (!opt)
 +		return ERR_PTR(-ENOMEM);
 +	opt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),
 +				GFP_KERNEL);
 +	if (!opt->mon_addr)
 +		goto out;
  
 -	return 0;
 -}
 -EXPORT_SYMBOL(ceph_parse_mon_ips);
 +	dout("parse_options %p options '%s' dev_name '%s'\n", opt, options,
 +	     dev_name);
  
 -int ceph_parse_param(struct fs_parameter *param, struct ceph_options *opt,
 -		     struct fc_log *l)
 -{
 -	struct fs_parse_result result;
 -	int token, err;
 -	struct p_log log = {.prefix = "libceph", .log = l};
 -
 -	token = __fs_parse(&log, ceph_parameters, param, &result);
 -	dout("%s fs_parse '%s' token %d\n", __func__, param->key, token);
 -	if (token < 0)
 -		return token;
 -
 -	switch (token) {
 -	case Opt_ip:
 -		err = ceph_parse_ips(param->string,
 -				     param->string + param->size,
 -				     &opt->my_addr,
 -				     1, NULL);
 -		if (err) {
 -			error_plog(&log, "Failed to parse ip: %d", err);
 -			return err;
 -		}
 -		opt->flags |= CEPH_OPT_MYIP;
 -		break;
 +	/* start with defaults */
 +	opt->flags = CEPH_OPT_DEFAULT;
 +	opt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;
 +	opt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;
 +	opt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;
 +	opt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;
  
 -	case Opt_fsid:
 -		err = parse_fsid(param->string, &opt->fsid);
 -		if (err) {
 -			error_plog(&log, "Failed to parse fsid: %d", err);
 -			return err;
 -		}
 -		opt->flags |= CEPH_OPT_FSID;
 -		break;
 -	case Opt_name:
 -		kfree(opt->name);
 -		opt->name = param->string;
 -		param->string = NULL;
 -		break;
 -	case Opt_secret:
 -		ceph_crypto_key_destroy(opt->key);
 -		kfree(opt->key);
 +	/* get mon ip(s) */
 +	/* ip1[:port1][,ip2[:port2]...] */
 +	err = ceph_parse_ips(dev_name, dev_name_end, opt->mon_addr,
 +			     CEPH_MAX_MON, &opt->num_mon);
 +	if (err < 0)
 +		goto out;
  
 -		opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 -		if (!opt->key)
 -			return -ENOMEM;
 -		err = ceph_crypto_key_unarmor(opt->key, param->string);
 -		if (err) {
 -			error_plog(&log, "Failed to parse secret: %d", err);
 -			return err;
 +	/* parse mount options */
 +	while ((c = strsep(&options, ",")) != NULL) {
 +		int token, intval;
 +		if (!*c)
 +			continue;
 +		err = -EINVAL;
 +		token = match_token((char *)c, opt_tokens, argstr);
 +		if (token < 0 && parse_extra_token) {
 +			/* extra? */
 +			err = parse_extra_token((char *)c, private);
 +			if (err < 0) {
 +				pr_err("bad option at '%s'\n", c);
 +				goto out;
 +			}
 +			continue;
  		}
 -		break;
 -	case Opt_key:
 -		ceph_crypto_key_destroy(opt->key);
 -		kfree(opt->key);
 +		if (token < Opt_last_int) {
 +			err = match_int(&argstr[0], &intval);
 +			if (err < 0) {
 +				pr_err("bad option arg (not int) at '%s'\n", c);
 +				goto out;
 +			}
 +			dout("got int token %d val %d\n", token, intval);
 +		} else if (token > Opt_last_int && token < Opt_last_string) {
 +			dout("got string token %d val %s\n", token,
 +			     argstr[0].from);
 +		} else {
 +			dout("got token %d\n", token);
 +		}
 +		switch (token) {
 +		case Opt_ip:
 +			err = ceph_parse_ips(argstr[0].from,
 +					     argstr[0].to,
 +					     &opt->my_addr,
 +					     1, NULL);
 +			if (err < 0)
 +				goto out;
 +			opt->flags |= CEPH_OPT_MYIP;
 +			break;
  
 +		case Opt_fsid:
 +			err = parse_fsid(argstr[0].from, &opt->fsid);
 +			if (err == 0)
 +				opt->flags |= CEPH_OPT_FSID;
 +			break;
 +		case Opt_name:
 +			kfree(opt->name);
 +			opt->name = kstrndup(argstr[0].from,
 +					      argstr[0].to-argstr[0].from,
 +					      GFP_KERNEL);
 +			if (!opt->name) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			break;
 +		case Opt_secret:
 +			ceph_crypto_key_destroy(opt->key);
 +			kfree(opt->key);
 +
++<<<<<<< HEAD
 +		        opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 +			if (!opt->key) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			err = ceph_crypto_key_unarmor(opt->key, argstr[0].from);
 +			if (err < 0)
 +				goto out;
 +			break;
 +		case Opt_key:
 +			ceph_crypto_key_destroy(opt->key);
 +			kfree(opt->key);
++=======
+ 		opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
+ 		if (!opt->key)
+ 			return -ENOMEM;
+ 		return get_secret(opt->key, param->string, &log);
+ 	case Opt_crush_location:
+ 		ceph_clear_crush_locs(&opt->crush_locs);
+ 		err = ceph_parse_crush_location(param->string,
+ 						&opt->crush_locs);
+ 		if (err) {
+ 			error_plog(&log, "Failed to parse CRUSH location: %d",
+ 				   err);
+ 			return err;
+ 		}
+ 		break;
+ 	case Opt_read_from_replica:
+ 		switch (result.uint_32) {
+ 		case Opt_read_from_replica_no:
+ 			opt->osd_req_flags &= ~(CEPH_OSD_FLAG_BALANCE_READS |
+ 						CEPH_OSD_FLAG_LOCALIZE_READS);
+ 			break;
+ 		case Opt_read_from_replica_balance:
+ 			opt->osd_req_flags |= CEPH_OSD_FLAG_BALANCE_READS;
+ 			opt->osd_req_flags &= ~CEPH_OSD_FLAG_LOCALIZE_READS;
+ 			break;
+ 		case Opt_read_from_replica_localize:
+ 			opt->osd_req_flags |= CEPH_OSD_FLAG_LOCALIZE_READS;
+ 			opt->osd_req_flags &= ~CEPH_OSD_FLAG_BALANCE_READS;
+ 			break;
+ 		default:
+ 			BUG();
+ 		}
+ 		break;
++>>>>>>> 8ad44d5e0d1e (libceph: read_from_replica option)
 +
 +		        opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 +			if (!opt->key) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			err = get_secret(opt->key, argstr[0].from);
 +			if (err < 0)
 +				goto out;
 +			break;
  
 -	case Opt_osdtimeout:
 -		warn_plog(&log, "Ignoring osdtimeout");
 -		break;
 -	case Opt_osdkeepalivetimeout:
 -		/* 0 isn't well defined right now, reject it */
 -		if (result.uint_32 < 1 || result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_keepalive_timeout =
 -		    msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_osd_idle_ttl:
 -		/* 0 isn't well defined right now, reject it */
 -		if (result.uint_32 < 1 || result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_idle_ttl = msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_mount_timeout:
 -		/* 0 is "wait forever" (i.e. infinite timeout) */
 -		if (result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->mount_timeout = msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_osd_request_timeout:
 -		/* 0 is "wait forever" (i.e. infinite timeout) */
 -		if (result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_request_timeout =
 -		    msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 +			/* misc */
 +		case Opt_osdtimeout:
 +			pr_warn("ignoring deprecated osdtimeout option\n");
 +			break;
 +		case Opt_osdkeepalivetimeout:
 +			/* 0 isn't well defined right now, reject it */
 +			if (intval < 1 || intval > INT_MAX / 1000) {
 +				pr_err("osdkeepalive out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_keepalive_timeout =
 +					msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_osd_idle_ttl:
 +			/* 0 isn't well defined right now, reject it */
 +			if (intval < 1 || intval > INT_MAX / 1000) {
 +				pr_err("osd_idle_ttl out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_idle_ttl = msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_mount_timeout:
 +			/* 0 is "wait forever" (i.e. infinite timeout) */
 +			if (intval < 0 || intval > INT_MAX / 1000) {
 +				pr_err("mount_timeout out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->mount_timeout = msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_osd_request_timeout:
 +			/* 0 is "wait forever" (i.e. infinite timeout) */
 +			if (intval < 0 || intval > INT_MAX / 1000) {
 +				pr_err("osd_request_timeout out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_request_timeout = msecs_to_jiffies(intval * 1000);
 +			break;
  
 -	case Opt_share:
 -		if (!result.negated)
 +		case Opt_share:
  			opt->flags &= ~CEPH_OPT_NOSHARE;
 -		else
 +			break;
 +		case Opt_noshare:
  			opt->flags |= CEPH_OPT_NOSHARE;
 -		break;
 -	case Opt_crc:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_crc:
  			opt->flags &= ~CEPH_OPT_NOCRC;
 -		else
 +			break;
 +		case Opt_nocrc:
  			opt->flags |= CEPH_OPT_NOCRC;
 -		break;
 -	case Opt_cephx_require_signatures:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_cephx_require_signatures:
  			opt->flags &= ~CEPH_OPT_NOMSGAUTH;
 -		else
 +			break;
 +		case Opt_nocephx_require_signatures:
  			opt->flags |= CEPH_OPT_NOMSGAUTH;
 -		break;
 -	case Opt_cephx_sign_messages:
 -		if (!result.negated)
 +			break;
 +		case Opt_cephx_sign_messages:
  			opt->flags &= ~CEPH_OPT_NOMSGSIGN;
 -		else
 +			break;
 +		case Opt_nocephx_sign_messages:
  			opt->flags |= CEPH_OPT_NOMSGSIGN;
 -		break;
 -	case Opt_tcp_nodelay:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_tcp_nodelay:
  			opt->flags |= CEPH_OPT_TCP_NODELAY;
 -		else
 +			break;
 +		case Opt_notcp_nodelay:
  			opt->flags &= ~CEPH_OPT_TCP_NODELAY;
 -		break;
 +			break;
  
 -	case Opt_abort_on_full:
 -		opt->flags |= CEPH_OPT_ABORT_ON_FULL;
 -		break;
 +		case Opt_abort_on_full:
 +			opt->flags |= CEPH_OPT_ABORT_ON_FULL;
 +			break;
  
 -	default:
 -		BUG();
 +		default:
 +			BUG_ON(token);
 +		}
  	}
  
 -	return 0;
 +	/* success */
 +	return opt;
  
 -out_of_range:
 -	return inval_plog(&log, "%s out of range", param->key);
 +out:
 +	ceph_destroy_options(opt);
 +	return ERR_PTR(err);
  }
 -EXPORT_SYMBOL(ceph_parse_param);
 +EXPORT_SYMBOL(ceph_parse_options);
  
  int ceph_print_client_options(struct seq_file *m, struct ceph_client *client,
  			      bool show_all)
@@@ -586,6 -598,28 +664,31 @@@
  	if (opt->key)
  		seq_puts(m, "secret=<hidden>,");
  
++<<<<<<< HEAD
++=======
+ 	if (!RB_EMPTY_ROOT(&opt->crush_locs)) {
+ 		seq_puts(m, "crush_location=");
+ 		for (n = rb_first(&opt->crush_locs); ; ) {
+ 			struct crush_loc_node *loc =
+ 			    rb_entry(n, struct crush_loc_node, cl_node);
+ 
+ 			seq_printf(m, "%s:%s", loc->cl_loc.cl_type_name,
+ 				   loc->cl_loc.cl_name);
+ 			n = rb_next(n);
+ 			if (!n)
+ 				break;
+ 
+ 			seq_putc(m, '|');
+ 		}
+ 		seq_putc(m, ',');
+ 	}
+ 	if (opt->osd_req_flags & CEPH_OSD_FLAG_BALANCE_READS) {
+ 		seq_puts(m, "read_from_replica=balance,");
+ 	} else if (opt->osd_req_flags & CEPH_OSD_FLAG_LOCALIZE_READS) {
+ 		seq_puts(m, "read_from_replica=localize,");
+ 	}
+ 
++>>>>>>> 8ad44d5e0d1e (libceph: read_from_replica option)
  	if (opt->flags & CEPH_OPT_FSID)
  		seq_printf(m, "fsid=%pU,", &opt->fsid);
  	if (opt->flags & CEPH_OPT_NOSHARE)
diff --git a/include/linux/ceph/libceph.h b/include/linux/ceph/libceph.h
index 8502dfc84465..4c4c431a27e8 100644
--- a/include/linux/ceph/libceph.h
+++ b/include/linux/ceph/libceph.h
@@ -53,6 +53,8 @@ struct ceph_options {
 	unsigned long osd_keepalive_timeout;	/* jiffies */
 	unsigned long osd_request_timeout;	/* jiffies */
 
+	u32 osd_req_flags;  /* CEPH_OSD_FLAG_*, applied to each OSD request */
+
 	/*
 	 * any type that can't be simply compared or doesn't need
 	 * to be compared should go beyond this point,
* Unmerged path net/ceph/ceph_common.c
diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c
index f1dcf63f4ec8..8da99c39154b 100644
--- a/net/ceph/osd_client.c
+++ b/net/ceph/osd_client.c
@@ -2366,11 +2366,14 @@ static void __submit_request(struct ceph_osd_request *req, bool wrlocked)
 
 static void account_request(struct ceph_osd_request *req)
 {
+	struct ceph_osd_client *osdc = req->r_osdc;
+
 	WARN_ON(req->r_flags & (CEPH_OSD_FLAG_ACK | CEPH_OSD_FLAG_ONDISK));
 	WARN_ON(!(req->r_flags & (CEPH_OSD_FLAG_READ | CEPH_OSD_FLAG_WRITE)));
 
 	req->r_flags |= CEPH_OSD_FLAG_ONDISK;
-	atomic_inc(&req->r_osdc->num_requests);
+	req->r_flags |= osdc->client->options->osd_req_flags;
+	atomic_inc(&osdc->num_requests);
 
 	req->r_start_stamp = jiffies;
 }
