KVM: s390: protvirt: Add UV cpu reset calls

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Janosch Frank <frankja@linux.ibm.com>
commit 8a8378fa61571eb308428780dee063c4580edb2a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8a8378fa.failed

For protected VMs, the VCPU resets are done by the Ultravisor, as KVM
has no access to the VCPU registers.

Note that the ultravisor will only accept a call for the exact reset
that has been requested.

	Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
	Reviewed-by: Thomas Huth <thuth@redhat.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
	Reviewed-by: Cornelia Huck <cohuck@redhat.com>
[borntraeger@de.ibm.com: patch merging, splitting, fixing]
	Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
(cherry picked from commit 8a8378fa61571eb308428780dee063c4580edb2a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/uv.h
#	arch/s390/kvm/kvm-s390.c
diff --cc arch/s390/include/asm/uv.h
index 4093a2856929,cff4b4c99b75..000000000000
--- a/arch/s390/include/asm/uv.h
+++ b/arch/s390/include/asm/uv.h
@@@ -21,16 -23,53 +21,51 @@@
  #define UVC_RC_INV_STATE	0x0003
  #define UVC_RC_INV_LEN		0x0005
  #define UVC_RC_NO_RESUME	0x0007
 -#define UVC_RC_NEED_DESTROY	0x8000
  
  #define UVC_CMD_QUI			0x0001
++<<<<<<< HEAD
++=======
+ #define UVC_CMD_INIT_UV			0x000f
+ #define UVC_CMD_CREATE_SEC_CONF		0x0100
+ #define UVC_CMD_DESTROY_SEC_CONF	0x0101
+ #define UVC_CMD_CREATE_SEC_CPU		0x0120
+ #define UVC_CMD_DESTROY_SEC_CPU		0x0121
+ #define UVC_CMD_CONV_TO_SEC_STOR	0x0200
+ #define UVC_CMD_CONV_FROM_SEC_STOR	0x0201
+ #define UVC_CMD_SET_SEC_CONF_PARAMS	0x0300
+ #define UVC_CMD_UNPACK_IMG		0x0301
+ #define UVC_CMD_VERIFY_IMG		0x0302
+ #define UVC_CMD_CPU_RESET		0x0310
+ #define UVC_CMD_CPU_RESET_INITIAL	0x0311
+ #define UVC_CMD_PREPARE_RESET		0x0320
+ #define UVC_CMD_CPU_RESET_CLEAR		0x0321
+ #define UVC_CMD_CPU_SET_STATE		0x0330
+ #define UVC_CMD_SET_UNSHARE_ALL		0x0340
+ #define UVC_CMD_PIN_PAGE_SHARED		0x0341
+ #define UVC_CMD_UNPIN_PAGE_SHARED	0x0342
++>>>>>>> 8a8378fa6157 (KVM: s390: protvirt: Add UV cpu reset calls)
  #define UVC_CMD_SET_SHARED_ACCESS	0x1000
  #define UVC_CMD_REMOVE_SHARED_ACCESS	0x1001
  
  /* Bits in installed uv calls */
  enum uv_cmds_inst {
  	BIT_UVC_CMD_QUI = 0,
 -	BIT_UVC_CMD_INIT_UV = 1,
 -	BIT_UVC_CMD_CREATE_SEC_CONF = 2,
 -	BIT_UVC_CMD_DESTROY_SEC_CONF = 3,
 -	BIT_UVC_CMD_CREATE_SEC_CPU = 4,
 -	BIT_UVC_CMD_DESTROY_SEC_CPU = 5,
 -	BIT_UVC_CMD_CONV_TO_SEC_STOR = 6,
 -	BIT_UVC_CMD_CONV_FROM_SEC_STOR = 7,
  	BIT_UVC_CMD_SET_SHARED_ACCESS = 8,
  	BIT_UVC_CMD_REMOVE_SHARED_ACCESS = 9,
++<<<<<<< HEAD
++=======
+ 	BIT_UVC_CMD_SET_SEC_PARMS = 11,
+ 	BIT_UVC_CMD_UNPACK_IMG = 13,
+ 	BIT_UVC_CMD_VERIFY_IMG = 14,
+ 	BIT_UVC_CMD_CPU_RESET = 15,
+ 	BIT_UVC_CMD_CPU_RESET_INITIAL = 16,
+ 	BIT_UVC_CMD_CPU_SET_STATE = 17,
+ 	BIT_UVC_CMD_PREPARE_RESET = 18,
+ 	BIT_UVC_CMD_CPU_PERFORM_CLEAR_RESET = 19,
+ 	BIT_UVC_CMD_UNSHARE_ALL = 20,
+ 	BIT_UVC_CMD_PIN_PAGE_SHARED = 21,
+ 	BIT_UVC_CMD_UNPIN_PAGE_SHARED = 22,
++>>>>>>> 8a8378fa6157 (KVM: s390: protvirt: Add UV cpu reset calls)
  };
  
  struct uv_cb_header {
diff --cc arch/s390/kvm/kvm-s390.c
index cbc729f2e4d5,bb060064cce0..000000000000
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@@ -4425,8 -4767,36 +4426,41 @@@ long kvm_arch_vcpu_ioctl(struct file *f
  		r = kvm_arch_vcpu_ioctl_set_initial_psw(vcpu, psw);
  		break;
  	}
++<<<<<<< HEAD
 +	case KVM_S390_INITIAL_RESET:
 +		r = kvm_arch_vcpu_ioctl_initial_reset(vcpu);
++=======
+ 	case KVM_S390_CLEAR_RESET:
+ 		r = 0;
+ 		kvm_arch_vcpu_ioctl_clear_reset(vcpu);
+ 		if (kvm_s390_pv_cpu_is_protected(vcpu)) {
+ 			r = uv_cmd_nodata(kvm_s390_pv_cpu_get_handle(vcpu),
+ 					  UVC_CMD_CPU_RESET_CLEAR, &rc, &rrc);
+ 			VCPU_EVENT(vcpu, 3, "PROTVIRT RESET CLEAR VCPU: rc %x rrc %x",
+ 				   rc, rrc);
+ 		}
+ 		break;
+ 	case KVM_S390_INITIAL_RESET:
+ 		r = 0;
+ 		kvm_arch_vcpu_ioctl_initial_reset(vcpu);
+ 		if (kvm_s390_pv_cpu_is_protected(vcpu)) {
+ 			r = uv_cmd_nodata(kvm_s390_pv_cpu_get_handle(vcpu),
+ 					  UVC_CMD_CPU_RESET_INITIAL,
+ 					  &rc, &rrc);
+ 			VCPU_EVENT(vcpu, 3, "PROTVIRT RESET INITIAL VCPU: rc %x rrc %x",
+ 				   rc, rrc);
+ 		}
+ 		break;
+ 	case KVM_S390_NORMAL_RESET:
+ 		r = 0;
+ 		kvm_arch_vcpu_ioctl_normal_reset(vcpu);
+ 		if (kvm_s390_pv_cpu_is_protected(vcpu)) {
+ 			r = uv_cmd_nodata(kvm_s390_pv_cpu_get_handle(vcpu),
+ 					  UVC_CMD_CPU_RESET, &rc, &rrc);
+ 			VCPU_EVENT(vcpu, 3, "PROTVIRT RESET NORMAL VCPU: rc %x rrc %x",
+ 				   rc, rrc);
+ 		}
++>>>>>>> 8a8378fa6157 (KVM: s390: protvirt: Add UV cpu reset calls)
  		break;
  	case KVM_SET_ONE_REG:
  	case KVM_GET_ONE_REG: {
* Unmerged path arch/s390/include/asm/uv.h
* Unmerged path arch/s390/kvm/kvm-s390.c
