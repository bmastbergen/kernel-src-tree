veth: remove atomic64_add from veth_xdp_xmit hotpath

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit d99a7c2f3d0e65d3906bd7cf719223b0f8b5b481
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d99a7c2f.failed

Remove atomic64_add from veth_xdp_xmit hotpath and rely on
xdp_xmit_err/xdp_tx_err counters

	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d99a7c2f3d0e65d3906bd7cf719223b0f8b5b481)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/veth.c
diff --cc drivers/net/veth.c
index 013947869d96,b6505a6c7102..000000000000
--- a/drivers/net/veth.c
+++ b/drivers/net/veth.c
@@@ -308,23 -301,29 +308,35 @@@ static void veth_stats_rx(struct veth_r
  	struct veth_priv *priv = netdev_priv(dev);
  	int i;
  
+ 	result->xdp_xmit_err = 0;
  	result->xdp_packets = 0;
+ 	result->xdp_tx_err = 0;
  	result->xdp_bytes = 0;
 -	result->rx_drops = 0;
 +	result->xdp_drops = 0;
  	for (i = 0; i < dev->num_rx_queues; i++) {
+ 		u64 packets, bytes, drops, xdp_tx_err, xdp_xmit_err;
  		struct veth_rq_stats *stats = &priv->rq[i].stats;
- 		u64 packets, bytes, drops;
  		unsigned int start;
  
  		do {
  			start = u64_stats_fetch_begin_irq(&stats->syncp);
++<<<<<<< HEAD
 +			packets = stats->xdp_packets;
 +			bytes = stats->xdp_bytes;
 +			drops = stats->xdp_drops;
++=======
+ 			xdp_xmit_err = stats->vs.xdp_xmit_err;
+ 			xdp_tx_err = stats->vs.xdp_tx_err;
+ 			packets = stats->vs.xdp_packets;
+ 			bytes = stats->vs.xdp_bytes;
+ 			drops = stats->vs.rx_drops;
++>>>>>>> d99a7c2f3d0e (veth: remove atomic64_add from veth_xdp_xmit hotpath)
  		} while (u64_stats_fetch_retry_irq(&stats->syncp, start));
+ 		result->xdp_xmit_err += xdp_xmit_err;
+ 		result->xdp_tx_err += xdp_tx_err;
  		result->xdp_packets += packets;
  		result->xdp_bytes += bytes;
 -		result->rx_drops += drops;
 +		result->xdp_drops += drops;
  	}
  }
  
@@@ -333,26 -332,28 +345,32 @@@ static void veth_get_stats64(struct net
  {
  	struct veth_priv *priv = netdev_priv(dev);
  	struct net_device *peer;
 -	struct veth_stats rx;
 -	u64 packets, bytes;
 +	struct veth_rq_stats rx;
 +	struct pcpu_lstats tx;
  
 -	tot->tx_dropped = veth_stats_tx(dev, &packets, &bytes);
 -	tot->tx_bytes = bytes;
 -	tot->tx_packets = packets;
 +	tot->tx_dropped = veth_stats_tx(&tx, dev);
 +	tot->tx_bytes = tx.bytes;
 +	tot->tx_packets = tx.packets;
  
  	veth_stats_rx(&rx, dev);
++<<<<<<< HEAD
 +	tot->rx_dropped = rx.xdp_drops;
++=======
+ 	tot->tx_dropped += rx.xdp_xmit_err + rx.xdp_tx_err;
+ 	tot->rx_dropped = rx.rx_drops;
++>>>>>>> d99a7c2f3d0e (veth: remove atomic64_add from veth_xdp_xmit hotpath)
  	tot->rx_bytes = rx.xdp_bytes;
  	tot->rx_packets = rx.xdp_packets;
  
  	rcu_read_lock();
  	peer = rcu_dereference(priv->peer);
  	if (peer) {
 -		veth_stats_tx(peer, &packets, &bytes);
 -		tot->rx_bytes += bytes;
 -		tot->rx_packets += packets;
 +		tot->rx_dropped += veth_stats_tx(&tx, peer);
 +		tot->rx_bytes += tx.bytes;
 +		tot->rx_packets += tx.packets;
  
  		veth_stats_rx(&rx, peer);
+ 		tot->rx_dropped += rx.xdp_xmit_err + rx.xdp_tx_err;
  		tot->tx_bytes += rx.xdp_bytes;
  		tot->tx_packets += rx.xdp_packets;
  	}
@@@ -389,17 -390,20 +407,18 @@@ static int veth_select_rxq(struct net_d
  }
  
  static int veth_xdp_xmit(struct net_device *dev, int n,
 -			 struct xdp_frame **frames,
 -			 u32 flags, bool ndo_xmit)
 +			 struct xdp_frame **frames, u32 flags)
  {
  	struct veth_priv *rcv_priv, *priv = netdev_priv(dev);
 -	unsigned int qidx, max_len;
  	struct net_device *rcv;
  	int i, ret, drops = n;
 +	unsigned int max_len;
  	struct veth_rq *rq;
  
 -	rcu_read_lock();
  	if (unlikely(flags & ~XDP_XMIT_FLAGS_MASK)) {
- 		ret = -EINVAL;
- 		goto drop;
+ 		rcu_read_unlock();
+ 		atomic64_add(drops, &priv->dropped);
+ 		return -EINVAL;
  	}
  
  	rcv = rcu_dereference(priv->peer);
@@@ -438,12 -444,20 +458,29 @@@
  	if (flags & XDP_XMIT_FLUSH)
  		__veth_xdp_flush(rq);
  
++<<<<<<< HEAD
 +	if (likely(!drops))
 +		return n;
 +
 +	ret = n - drops;
 +drop:
 +	atomic64_add(drops, &priv->dropped);
++=======
+ 	ret = n - drops;
+ drop:
+ 	rq = &priv->rq[qidx];
+ 	u64_stats_update_begin(&rq->stats.syncp);
+ 	if (ndo_xmit) {
+ 		rq->stats.vs.xdp_xmit += n - drops;
+ 		rq->stats.vs.xdp_xmit_err += drops;
+ 	} else {
+ 		rq->stats.vs.xdp_tx += n - drops;
+ 		rq->stats.vs.xdp_tx_err += drops;
+ 	}
+ 	u64_stats_update_end(&rq->stats.syncp);
+ 
+ 	rcu_read_unlock();
++>>>>>>> d99a7c2f3d0e (veth: remove atomic64_add from veth_xdp_xmit hotpath)
  
  	return ret;
  }
* Unmerged path drivers/net/veth.c
