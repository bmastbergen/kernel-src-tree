net/mlx5e: CT: Restore ct state from lookup in zone instead of tupleid

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paul Blakey <paulb@mellanox.com>
commit a8eb919ba659adcbed8fd782b3e9a949c3a65b9c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a8eb919b.failed

Remove tupleid, and replace it with zone_restore, which is the zone an
established tuple sets after match. On miss, Use this zone + tuple
taken from the skb, to lookup the ct entry and restore it.

This improves flow insertion rate by avoiding the allocation of a header
rewrite context.

	Signed-off-by: Paul Blakey <paulb@mellanox.com>
	Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit a8eb919ba659adcbed8fd782b3e9a949c3a65b9c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 23a1c21d8bab,090069e936b7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -149,6 -172,109 +149,112 @@@ struct mlx5e_tc_flow_parse_attr 
  #define MLX5E_TC_TABLE_NUM_GROUPS 4
  #define MLX5E_TC_TABLE_MAX_GROUP_SIZE BIT(16)
  
++<<<<<<< HEAD
++=======
+ struct mlx5e_tc_attr_to_reg_mapping mlx5e_tc_attr_to_reg_mappings[] = {
+ 	[CHAIN_TO_REG] = {
+ 		.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_0,
+ 		.moffset = 0,
+ 		.mlen = 2,
+ 	},
+ 	[TUNNEL_TO_REG] = {
+ 		.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_1,
+ 		.moffset = 3,
+ 		.mlen = 1,
+ 		.soffset = MLX5_BYTE_OFF(fte_match_param,
+ 					 misc_parameters_2.metadata_reg_c_1),
+ 	},
+ 	[ZONE_TO_REG] = zone_to_reg_ct,
+ 	[ZONE_RESTORE_TO_REG] = zone_restore_to_reg_ct,
+ 	[CTSTATE_TO_REG] = ctstate_to_reg_ct,
+ 	[MARK_TO_REG] = mark_to_reg_ct,
+ 	[LABELS_TO_REG] = labels_to_reg_ct,
+ 	[FTEID_TO_REG] = fteid_to_reg_ct,
+ };
+ 
+ static void mlx5e_put_flow_tunnel_id(struct mlx5e_tc_flow *flow);
+ 
+ void
+ mlx5e_tc_match_to_reg_match(struct mlx5_flow_spec *spec,
+ 			    enum mlx5e_tc_attr_to_reg type,
+ 			    u32 data,
+ 			    u32 mask)
+ {
+ 	int soffset = mlx5e_tc_attr_to_reg_mappings[type].soffset;
+ 	int match_len = mlx5e_tc_attr_to_reg_mappings[type].mlen;
+ 	void *headers_c = spec->match_criteria;
+ 	void *headers_v = spec->match_value;
+ 	void *fmask, *fval;
+ 
+ 	fmask = headers_c + soffset;
+ 	fval = headers_v + soffset;
+ 
+ 	mask = (__force u32)(cpu_to_be32(mask)) >> (32 - (match_len * 8));
+ 	data = (__force u32)(cpu_to_be32(data)) >> (32 - (match_len * 8));
+ 
+ 	memcpy(fmask, &mask, match_len);
+ 	memcpy(fval, &data, match_len);
+ 
+ 	spec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_2;
+ }
+ 
+ void
+ mlx5e_tc_match_to_reg_get_match(struct mlx5_flow_spec *spec,
+ 				enum mlx5e_tc_attr_to_reg type,
+ 				u32 *data,
+ 				u32 *mask)
+ {
+ 	int soffset = mlx5e_tc_attr_to_reg_mappings[type].soffset;
+ 	int match_len = mlx5e_tc_attr_to_reg_mappings[type].mlen;
+ 	void *headers_c = spec->match_criteria;
+ 	void *headers_v = spec->match_value;
+ 	void *fmask, *fval;
+ 
+ 	fmask = headers_c + soffset;
+ 	fval = headers_v + soffset;
+ 
+ 	memcpy(mask, fmask, match_len);
+ 	memcpy(data, fval, match_len);
+ 
+ 	*mask = be32_to_cpu((__force __be32)(*mask << (32 - (match_len * 8))));
+ 	*data = be32_to_cpu((__force __be32)(*data << (32 - (match_len * 8))));
+ }
+ 
+ int
+ mlx5e_tc_match_to_reg_set(struct mlx5_core_dev *mdev,
+ 			  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,
+ 			  enum mlx5e_tc_attr_to_reg type,
+ 			  u32 data)
+ {
+ 	int moffset = mlx5e_tc_attr_to_reg_mappings[type].moffset;
+ 	int mfield = mlx5e_tc_attr_to_reg_mappings[type].mfield;
+ 	int mlen = mlx5e_tc_attr_to_reg_mappings[type].mlen;
+ 	char *modact;
+ 	int err;
+ 
+ 	err = alloc_mod_hdr_actions(mdev, MLX5_FLOW_NAMESPACE_FDB,
+ 				    mod_hdr_acts);
+ 	if (err)
+ 		return err;
+ 
+ 	modact = mod_hdr_acts->actions +
+ 		 (mod_hdr_acts->num_actions * MLX5_MH_ACT_SZ);
+ 
+ 	/* Firmware has 5bit length field and 0 means 32bits */
+ 	if (mlen == 4)
+ 		mlen = 0;
+ 
+ 	MLX5_SET(set_action_in, modact, action_type, MLX5_ACTION_TYPE_SET);
+ 	MLX5_SET(set_action_in, modact, field, mfield);
+ 	MLX5_SET(set_action_in, modact, offset, moffset * 8);
+ 	MLX5_SET(set_action_in, modact, length, mlen * 8);
+ 	MLX5_SET(set_action_in, modact, data, data);
+ 	mod_hdr_acts->num_actions++;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> a8eb919ba659 (net/mlx5e: CT: Restore ct state from lookup in zone instead of tupleid)
  struct mlx5e_hairpin {
  	struct mlx5_hairpin *pair;
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 22d5efd4edec,856e034b92f3..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@@ -87,10 -122,29 +87,34 @@@ void mlx5e_put_encap_flow_list(struct m
  struct mlx5e_neigh_hash_entry;
  void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);
  
 +int mlx5e_tc_num_filters(struct mlx5e_priv *priv, unsigned long flags);
 +
  void mlx5e_tc_reoffload_flows_work(struct work_struct *work);
  
++<<<<<<< HEAD
++=======
+ enum mlx5e_tc_attr_to_reg {
+ 	CHAIN_TO_REG,
+ 	TUNNEL_TO_REG,
+ 	CTSTATE_TO_REG,
+ 	ZONE_TO_REG,
+ 	ZONE_RESTORE_TO_REG,
+ 	MARK_TO_REG,
+ 	LABELS_TO_REG,
+ 	FTEID_TO_REG,
+ };
+ 
+ struct mlx5e_tc_attr_to_reg_mapping {
+ 	int mfield; /* rewrite field */
+ 	int moffset; /* offset of mfield */
+ 	int mlen; /* bytes to rewrite/match */
+ 
+ 	int soffset; /* offset of spec for match */
+ };
+ 
+ extern struct mlx5e_tc_attr_to_reg_mapping mlx5e_tc_attr_to_reg_mappings[];
+ 
++>>>>>>> a8eb919ba659 (net/mlx5e: CT: Restore ct state from lookup in zone instead of tupleid)
  bool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,
  				    struct net_device *out_dev);
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/rep/tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
