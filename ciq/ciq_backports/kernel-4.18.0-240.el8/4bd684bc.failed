gfs2: Remove unnecessary gfs2_qa_{get,put} pairs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 4bd684bc0143b46eea6dcf4dd3a73dfd6dc7247c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/4bd684bc.failed

We now get the quota data structure when opening a file writable and put it
when closing that writable file descriptor, so there no longer is a need for
gfs2_qa_{get,put} while we're holding a writable file descriptor.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit 4bd684bc0143b46eea6dcf4dd3a73dfd6dc7247c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/file.c
diff --cc fs/gfs2/file.c
index a25b1766d059,fe305e4bfd37..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -405,12 -458,6 +405,15 @@@ static vm_fault_t gfs2_page_mkwrite(str
  
  	sb_start_pagefault(inode->i_sb);
  
++<<<<<<< HEAD
 +	ret = gfs2_rsqa_alloc(ip);
 +	if (ret)
 +		goto out;
 +
 +	gfs2_size_hint(vmf->vma->vm_file, pos, PAGE_SIZE);
 +
++=======
++>>>>>>> 4bd684bc0143 (gfs2: Remove unnecessary gfs2_qa_{get,put} pairs)
  	gfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);
  	ret = gfs2_glock_nq(&gh);
  	if (ret)
@@@ -780,12 -852,8 +782,15 @@@ static ssize_t gfs2_file_write_iter(str
  	struct file *file = iocb->ki_filp;
  	struct inode *inode = file_inode(file);
  	struct gfs2_inode *ip = GFS2_I(inode);
 -	ssize_t ret;
 +	ssize_t written = 0, ret;
 +
++<<<<<<< HEAD
 +	ret = gfs2_rsqa_alloc(ip);
 +	if (ret)
 +		return ret;
  
++=======
++>>>>>>> 4bd684bc0143 (gfs2: Remove unnecessary gfs2_qa_{get,put} pairs)
  	gfs2_size_hint(file, iocb->ki_pos, iov_iter_count(from));
  
  	if (iocb->ki_flags & IOCB_APPEND) {
@@@ -830,38 -896,30 +835,44 @@@
  		/*
  		 * We need to ensure that the page cache pages are written to
  		 * disk and invalidated to preserve the expected O_DIRECT
 -		 * semantics.  If the writeback or invalidate fails, only report
 -		 * the direct I/O range as we don't know if the buffered pages
 -		 * made it to disk.
 +		 * semantics.
  		 */
 -		iocb->ki_pos += buffered;
 -		ret2 = generic_write_sync(iocb, buffered);
 -		invalidate_mapping_pages(mapping,
 -				(iocb->ki_pos - buffered) >> PAGE_SHIFT,
 -				(iocb->ki_pos - 1) >> PAGE_SHIFT);
 -		if (!ret || ret2 > 0)
 -			ret += ret2;
 +		pos = iocb->ki_pos;
 +		endbyte = pos + buffered - 1;
 +		ret = filemap_write_and_wait_range(mapping, pos, endbyte);
 +		if (!ret) {
 +			iocb->ki_pos += buffered;
 +			written += buffered;
 +			invalidate_mapping_pages(mapping,
 +						 pos >> PAGE_SHIFT,
 +						 endbyte >> PAGE_SHIFT);
 +		} else {
 +			/*
 +			 * We don't know how much we wrote, so just return
 +			 * the number of bytes which were direct-written
 +			 */
 +		}
  	} else {
 -		current->backing_dev_info = inode_to_bdi(inode);
  		ret = iomap_file_buffered_write(iocb, from, &gfs2_iomap_ops);
 -		current->backing_dev_info = NULL;
 -		if (likely(ret > 0)) {
 +		if (likely(ret > 0))
  			iocb->ki_pos += ret;
 -			ret = generic_write_sync(iocb, ret);
 -		}
  	}
  
++<<<<<<< HEAD
 +out2:
 +	current->backing_dev_info = NULL;
 +out:
 +	inode_unlock(inode);
 +	if (likely(ret > 0)) {
 +		/* Handle various SYNC-type writes */
 +		ret = generic_write_sync(iocb, ret);
 +	}
 +	return written ? written : ret;
++=======
+ out_unlock:
+ 	inode_unlock(inode);
+ 	return ret;
++>>>>>>> 4bd684bc0143 (gfs2: Remove unnecessary gfs2_qa_{get,put} pairs)
  }
  
  static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,
@@@ -1091,12 -1150,7 +1102,14 @@@ static long gfs2_fallocate(struct file 
  	if (mode & FALLOC_FL_PUNCH_HOLE) {
  		ret = __gfs2_punch_hole(file, offset, len);
  	} else {
++<<<<<<< HEAD
 +		ret = gfs2_rsqa_alloc(ip);
 +		if (ret)
 +			goto out_putw;
 +
++=======
++>>>>>>> 4bd684bc0143 (gfs2: Remove unnecessary gfs2_qa_{get,put} pairs)
  		ret = __gfs2_fallocate(file, mode, offset, len);
- 
  		if (ret)
  			gfs2_rs_deltree(&ip->i_res);
  	}
@@@ -1115,16 -1168,12 +1127,25 @@@ static ssize_t gfs2_file_splice_write(s
  				      struct file *out, loff_t *ppos,
  				      size_t len, unsigned int flags)
  {
++<<<<<<< HEAD
 +	int error;
 +	struct gfs2_inode *ip = GFS2_I(out->f_mapping->host);
 +
 +	error = gfs2_rsqa_alloc(ip);
 +	if (error)
 +		return (ssize_t)error;
 +
 +	gfs2_size_hint(out, *ppos, len);
 +
 +	return iter_file_splice_write(pipe, out, ppos, len, flags);
++=======
+ 	ssize_t ret;
+ 
+ 	gfs2_size_hint(out, *ppos, len);
+ 
+ 	ret = iter_file_splice_write(pipe, out, ppos, len, flags);
+ 	return ret;
++>>>>>>> 4bd684bc0143 (gfs2: Remove unnecessary gfs2_qa_{get,put} pairs)
  }
  
  #ifdef CONFIG_GFS2_FS_LOCKING_DLM
* Unmerged path fs/gfs2/file.c
