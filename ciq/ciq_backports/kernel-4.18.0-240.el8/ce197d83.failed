xdp: Handle device unregister for devmap_hash map type

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Toke Høiland-Jørgensen <toke@redhat.com>
commit ce197d83a9fc42795c248c90983bf05faf0f013b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ce197d83.failed

It seems I forgot to add handling of devmap_hash type maps to the device
unregister hook for devmaps. This omission causes devices to not be
properly released, which causes hangs.

Fix this by adding the missing handler.

Fixes: 6f9d451ab1a3 ("xdp: Add devmap_hash map type for looking up devices by hashed index")
	Reported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
Link: https://lore.kernel.org/bpf/20191019111931.2981954-1-toke@redhat.com
(cherry picked from commit ce197d83a9fc42795c248c90983bf05faf0f013b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/devmap.c
diff --cc kernel/bpf/devmap.c
index cfc445b29247,3867864cdc2f..000000000000
--- a/kernel/bpf/devmap.c
+++ b/kernel/bpf/devmap.c
@@@ -520,6 -709,42 +520,45 @@@ const struct bpf_map_ops dev_map_ops = 
  	.map_check_btf = map_check_no_btf,
  };
  
++<<<<<<< HEAD
++=======
+ const struct bpf_map_ops dev_map_hash_ops = {
+ 	.map_alloc = dev_map_alloc,
+ 	.map_free = dev_map_free,
+ 	.map_get_next_key = dev_map_hash_get_next_key,
+ 	.map_lookup_elem = dev_map_hash_lookup_elem,
+ 	.map_update_elem = dev_map_hash_update_elem,
+ 	.map_delete_elem = dev_map_hash_delete_elem,
+ 	.map_check_btf = map_check_no_btf,
+ };
+ 
+ static void dev_map_hash_remove_netdev(struct bpf_dtab *dtab,
+ 				       struct net_device *netdev)
+ {
+ 	unsigned long flags;
+ 	u32 i;
+ 
+ 	spin_lock_irqsave(&dtab->index_lock, flags);
+ 	for (i = 0; i < dtab->n_buckets; i++) {
+ 		struct bpf_dtab_netdev *dev;
+ 		struct hlist_head *head;
+ 		struct hlist_node *next;
+ 
+ 		head = dev_map_index_hash(dtab, i);
+ 
+ 		hlist_for_each_entry_safe(dev, next, head, index_hlist) {
+ 			if (netdev != dev->dev)
+ 				continue;
+ 
+ 			dtab->items--;
+ 			hlist_del_rcu(&dev->index_hlist);
+ 			call_rcu(&dev->rcu, __dev_map_entry_free);
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&dtab->index_lock, flags);
+ }
+ 
++>>>>>>> ce197d83a9fc (xdp: Handle device unregister for devmap_hash map type)
  static int dev_map_notification(struct notifier_block *notifier,
  				ulong event, void *ptr)
  {
* Unmerged path kernel/bpf/devmap.c
