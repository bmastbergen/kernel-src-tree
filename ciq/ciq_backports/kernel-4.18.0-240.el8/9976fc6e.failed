netfilter: conntrack: remove the l4proto->new() function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 9976fc6e6edbb0372f084a2ae8c1b8103b3bff1d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9976fc6e.failed

->new() gets invoked after ->error() and before ->packet() if
a conntrack lookup has found no result for the tuple.

We can fold it into ->packet() -- the packet() implementations
can check if the conntrack is confirmed (new) or not
(already in hash).

If its unconfirmed, the conntrack isn't in the hash yet so current
skb created a new conntrack entry.

Only relevant side effect -- if packet() doesn't return NF_ACCEPT
but -NF_ACCEPT (or drop), while the conntrack was just created,
then the newly allocated conntrack is freed right away, rather than not
created in the first place.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 9976fc6e6edbb0372f084a2ae8c1b8103b3bff1d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_conntrack_l4proto.h
#	net/ipv4/netfilter/nf_conntrack_proto_icmp.c
#	net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
#	net/netfilter/nf_conntrack_core.c
#	net/netfilter/nf_conntrack_proto_dccp.c
#	net/netfilter/nf_conntrack_proto_generic.c
#	net/netfilter/nf_conntrack_proto_gre.c
#	net/netfilter/nf_conntrack_proto_sctp.c
#	net/netfilter/nf_conntrack_proto_tcp.c
#	net/netfilter/nf_conntrack_proto_udp.c
diff --cc include/net/netfilter/nf_conntrack_l4proto.h
index 771e9d473ecd,016958e67fcc..000000000000
--- a/include/net/netfilter/nf_conntrack_l4proto.h
+++ b/include/net/netfilter/nf_conntrack_l4proto.h
@@@ -46,13 -46,8 +46,16 @@@ struct nf_conntrack_l4proto 
  		      const struct sk_buff *skb,
  		      unsigned int dataoff,
  		      enum ip_conntrack_info ctinfo,
 -		      const struct nf_hook_state *state);
 +		      unsigned int *timeouts);
  
++<<<<<<< HEAD
 +	/* Called when a new connection for this protocol found;
 +	 * returns TRUE if it's OK.  If so, packet() called next. */
 +	bool (*new)(struct nf_conn *ct, const struct sk_buff *skb,
 +		    unsigned int dataoff, unsigned int *timeouts);
 +
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  	/* Called when a conntrack entry is destroyed */
  	void (*destroy)(struct nf_conn *ct);
  
diff --cc net/ipv4/netfilter/nf_conntrack_proto_icmp.c
index f2bc6a47243a,19ef0c41602b..000000000000
--- a/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
+++ b/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
@@@ -86,15 -82,7 +81,19 @@@ static int icmp_packet(struct nf_conn *
  	/* Do not immediately delete the connection after the first
  	   successful reply to avoid excessive conntrackd traffic
  	   and also to handle correctly ICMP echo reply duplicates. */
++<<<<<<< HEAD:net/ipv4/netfilter/nf_conntrack_proto_icmp.c
 +	nf_ct_refresh_acct(ct, ctinfo, skb, *timeout);
 +
 +	return NF_ACCEPT;
 +}
 +
 +/* Called when a new connection for this protocol found. */
 +static bool icmp_new(struct nf_conn *ct, const struct sk_buff *skb,
 +		     unsigned int dataoff, unsigned int *timeouts)
 +{
++=======
+ 	unsigned int *timeout = nf_ct_timeout_lookup(ct);
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function):net/netfilter/nf_conntrack_proto_icmp.c
  	static const u_int8_t valid_new[] = {
  		[ICMP_ECHO] = 1,
  		[ICMP_TIMESTAMP] = 1,
@@@ -357,8 -355,6 +361,11 @@@ const struct nf_conntrack_l4proto nf_co
  	.pkt_to_tuple		= icmp_pkt_to_tuple,
  	.invert_tuple		= icmp_invert_tuple,
  	.packet			= icmp_packet,
++<<<<<<< HEAD:net/ipv4/netfilter/nf_conntrack_proto_icmp.c
 +	.get_timeouts		= icmp_get_timeouts,
 +	.new			= icmp_new,
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function):net/netfilter/nf_conntrack_proto_icmp.c
  	.error			= icmp_error,
  	.destroy		= NULL,
  	.me			= NULL,
diff --cc net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
index c3ab22bf84b8,bb94363818e6..000000000000
--- a/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
@@@ -94,8 -95,29 +94,32 @@@ static int icmpv6_packet(struct nf_con
  		       const struct sk_buff *skb,
  		       unsigned int dataoff,
  		       enum ip_conntrack_info ctinfo,
 -		       const struct nf_hook_state *state)
 +		       unsigned int *timeout)
  {
++<<<<<<< HEAD:net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
++=======
+ 	unsigned int *timeout = nf_ct_timeout_lookup(ct);
+ 	static const u8 valid_new[] = {
+ 		[ICMPV6_ECHO_REQUEST - 128] = 1,
+ 		[ICMPV6_NI_QUERY - 128] = 1
+ 	};
+ 
+ 	if (!nf_ct_is_confirmed(ct)) {
+ 		int type = ct->tuplehash[0].tuple.dst.u.icmp.type - 128;
+ 
+ 		if (type < 0 || type >= sizeof(valid_new) || !valid_new[type]) {
+ 			/* Can't create a new ICMPv6 `conn' with this. */
+ 			pr_debug("icmpv6: can't create new conn with type %u\n",
+ 				 type + 128);
+ 			nf_ct_dump_tuple_ipv6(&ct->tuplehash[0].tuple);
+ 			return -NF_ACCEPT;
+ 		}
+ 	}
+ 
+ 	if (!timeout)
+ 		timeout = icmpv6_get_timeouts(nf_ct_net(ct));
+ 
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function):net/netfilter/nf_conntrack_proto_icmpv6.c
  	/* Do not immediately delete the connection after the first
  	   successful reply to avoid excessive conntrackd traffic
  	   and also to handle correctly ICMP echo reply duplicates. */
@@@ -104,26 -126,6 +128,29 @@@
  	return NF_ACCEPT;
  }
  
++<<<<<<< HEAD:net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
 +/* Called when a new connection for this protocol found. */
 +static bool icmpv6_new(struct nf_conn *ct, const struct sk_buff *skb,
 +		       unsigned int dataoff, unsigned int *timeouts)
 +{
 +	static const u_int8_t valid_new[] = {
 +		[ICMPV6_ECHO_REQUEST - 128] = 1,
 +		[ICMPV6_NI_QUERY - 128] = 1
 +	};
 +	int type = ct->tuplehash[0].tuple.dst.u.icmp.type - 128;
 +
 +	if (type < 0 || type >= sizeof(valid_new) || !valid_new[type]) {
 +		/* Can't create a new ICMPv6 `conn' with this. */
 +		pr_debug("icmpv6: can't create new conn with type %u\n",
 +			 type + 128);
 +		nf_ct_dump_tuple_ipv6(&ct->tuplehash[0].tuple);
 +		return false;
 +	}
 +	return true;
 +}
 +
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function):net/netfilter/nf_conntrack_proto_icmpv6.c
  static int
  icmpv6_error_message(struct net *net, struct nf_conn *tmpl,
  		     struct sk_buff *skb,
@@@ -358,8 -366,6 +385,11 @@@ const struct nf_conntrack_l4proto nf_co
  	.pkt_to_tuple		= icmpv6_pkt_to_tuple,
  	.invert_tuple		= icmpv6_invert_tuple,
  	.packet			= icmpv6_packet,
++<<<<<<< HEAD:net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
 +	.get_timeouts		= icmpv6_get_timeouts,
 +	.new			= icmpv6_new,
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function):net/netfilter/nf_conntrack_proto_icmpv6.c
  	.error			= icmpv6_error,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr	= icmpv6_tuple_to_nlattr,
diff --cc net/netfilter/nf_conntrack_core.c
index 397b134cecce,dccc96e94d7c..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -1349,20 -1369,7 +1349,23 @@@ init_conntrack(struct net *net, struct 
  	}
  
  	timeout_ext = tmpl ? nf_ct_timeout_find(tmpl) : NULL;
 +	if (timeout_ext) {
 +		timeouts = nf_ct_timeout_data(timeout_ext);
 +		if (unlikely(!timeouts))
 +			timeouts = l4proto->get_timeouts(net);
 +	} else {
 +		timeouts = l4proto->get_timeouts(net);
 +	}
  
++<<<<<<< HEAD
 +	if (!l4proto->new(ct, skb, dataoff, timeouts)) {
 +		nf_conntrack_free(ct);
 +		pr_debug("can't track with proto module\n");
 +		return NULL;
 +	}
 +
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  	if (timeout_ext)
  		nf_ct_timeout_ext_add(ct, rcu_dereference(timeout_ext->timeout),
  				      GFP_ATOMIC);
diff --cc net/netfilter/nf_conntrack_proto_dccp.c
index 5773ad591022,e7b5449ea883..000000000000
--- a/net/netfilter/nf_conntrack_proto_dccp.c
+++ b/net/netfilter/nf_conntrack_proto_dccp.c
@@@ -388,8 -389,9 +388,14 @@@ static inline struct nf_dccp_net *dccp_
  	return &net->ct.nf_ct_proto.dccp;
  }
  
++<<<<<<< HEAD
 +static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,
 +		     unsigned int dataoff, unsigned int *timeouts)
++=======
+ static noinline bool
+ dccp_new(struct nf_conn *ct, const struct sk_buff *skb,
+ 	 const struct dccp_hdr *dh)
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  {
  	struct net *net = nf_ct_net(ct);
  	struct nf_dccp_net *dn;
@@@ -450,10 -443,15 +452,14 @@@ static int dccp_packet(struct nf_conn *
  	struct dccp_hdr _dh, *dh;
  	u_int8_t type, old_state, new_state;
  	enum ct_dccp_roles role;
 -	unsigned int *timeouts;
  
  	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);
- 	BUG_ON(dh == NULL);
+ 	if (!dh)
+ 		return NF_DROP;
+ 
  	type = dh->dccph_type;
+ 	if (!nf_ct_is_confirmed(ct) && !dccp_new(ct, skb, dh))
+ 		return -NF_ACCEPT;
  
  	if (type == DCCP_PKT_RESET &&
  	    !test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {
@@@ -851,9 -851,7 +857,8 @@@ static struct nf_proto_net *dccp_get_ne
  const struct nf_conntrack_l4proto nf_conntrack_l4proto_dccp4 = {
  	.l3proto		= AF_INET,
  	.l4proto		= IPPROTO_DCCP,
- 	.new			= dccp_new,
  	.packet			= dccp_packet,
 +	.get_timeouts		= dccp_get_timeouts,
  	.error			= dccp_error,
  	.can_early_drop		= dccp_can_early_drop,
  #ifdef CONFIG_NF_CONNTRACK_PROCFS
@@@ -885,9 -883,7 +890,8 @@@ EXPORT_SYMBOL_GPL(nf_conntrack_l4proto_
  const struct nf_conntrack_l4proto nf_conntrack_l4proto_dccp6 = {
  	.l3proto		= AF_INET6,
  	.l4proto		= IPPROTO_DCCP,
- 	.new			= dccp_new,
  	.packet			= dccp_packet,
 +	.get_timeouts		= dccp_get_timeouts,
  	.error			= dccp_error,
  	.can_early_drop		= dccp_can_early_drop,
  #ifdef CONFIG_NF_CONNTRACK_PROCFS
diff --cc net/netfilter/nf_conntrack_proto_generic.c
index 592164faa299,deeb05c50f02..000000000000
--- a/net/netfilter/nf_conntrack_proto_generic.c
+++ b/net/netfilter/nf_conntrack_proto_generic.c
@@@ -51,25 -47,23 +51,42 @@@ static int generic_packet(struct nf_con
  			  const struct sk_buff *skb,
  			  unsigned int dataoff,
  			  enum ip_conntrack_info ctinfo,
 -			  const struct nf_hook_state *state)
 +			  unsigned int *timeout)
  {
++<<<<<<< HEAD
++=======
+ 	const unsigned int *timeout = nf_ct_timeout_lookup(ct);
+ 
+ 	if (!nf_generic_should_process(nf_ct_protonum(ct))) {
+ 		pr_warn_once("conntrack: generic helper won't handle protocol %d. Please consider loading the specific helper module.\n",
+ 			     nf_ct_protonum(ct));
+ 		return -NF_ACCEPT;
+ 	}
+ 
+ 	if (!timeout)
+ 		timeout = &generic_pernet(nf_ct_net(ct))->timeout;
+ 
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  	nf_ct_refresh_acct(ct, ctinfo, skb, *timeout);
  	return NF_ACCEPT;
  }
  
++<<<<<<< HEAD
 +/* Called when a new connection for this protocol found. */
 +static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 +			unsigned int dataoff, unsigned int *timeouts)
 +{
 +	bool ret;
 +
 +	ret = nf_generic_should_process(nf_ct_protonum(ct));
 +	if (!ret)
 +		pr_warn_once("conntrack: generic helper won't handle protocol %d. Please consider loading the specific helper module.\n",
 +			     nf_ct_protonum(ct));
 +	return ret;
 +}
 +
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  #ifdef CONFIG_NF_CONNTRACK_TIMEOUT
  
  #include <linux/netfilter/nfnetlink.h>
@@@ -160,8 -157,6 +177,11 @@@ const struct nf_conntrack_l4proto nf_co
  	.l4proto		= 255,
  	.pkt_to_tuple		= generic_pkt_to_tuple,
  	.packet			= generic_packet,
++<<<<<<< HEAD
 +	.get_timeouts		= generic_get_timeouts,
 +	.new			= generic_new,
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  #ifdef CONFIG_NF_CONNTRACK_TIMEOUT
  	.ctnl_timeout		= {
  		.nlattr_to_obj	= generic_timeout_nlattr_to_obj,
diff --cc net/netfilter/nf_conntrack_proto_gre.c
index 1d1fc1718f60,a44bbee271cb..000000000000
--- a/net/netfilter/nf_conntrack_proto_gre.c
+++ b/net/netfilter/nf_conntrack_proto_gre.c
@@@ -235,8 -236,20 +235,20 @@@ static int gre_packet(struct nf_conn *c
  		      const struct sk_buff *skb,
  		      unsigned int dataoff,
  		      enum ip_conntrack_info ctinfo,
 -		      const struct nf_hook_state *state)
 +		      unsigned int *timeouts)
  {
+ 	if (!nf_ct_is_confirmed(ct)) {
+ 		unsigned int *timeouts = nf_ct_timeout_lookup(ct);
+ 
+ 		if (!timeouts)
+ 			timeouts = gre_get_timeouts(nf_ct_net(ct));
+ 
+ 		/* initialize to sane value.  Ideally a conntrack helper
+ 		 * (e.g. in case of pptp) is increasing them */
+ 		ct->proto.gre.stream_timeout = timeouts[GRE_CT_REPLIED];
+ 		ct->proto.gre.timeout = timeouts[GRE_CT_UNREPLIED];
+ 	}
+ 
  	/* If we've seen traffic both ways, this is a GRE connection.
  	 * Extend timeout. */
  	if (ct->status & IPS_SEEN_REPLY) {
@@@ -252,21 -265,6 +264,24 @@@
  	return NF_ACCEPT;
  }
  
++<<<<<<< HEAD
 +/* Called when a new connection for this protocol found. */
 +static bool gre_new(struct nf_conn *ct, const struct sk_buff *skb,
 +		    unsigned int dataoff, unsigned int *timeouts)
 +{
 +	pr_debug(": ");
 +	nf_ct_dump_tuple(&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
 +
 +	/* initialize to sane value.  Ideally a conntrack helper
 +	 * (e.g. in case of pptp) is increasing them */
 +	ct->proto.gre.stream_timeout = timeouts[GRE_CT_REPLIED];
 +	ct->proto.gre.timeout = timeouts[GRE_CT_UNREPLIED];
 +
 +	return true;
 +}
 +
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  /* Called when a conntrack entry has already been removed from the hashes
   * and is about to be deleted from memory */
  static void gre_destroy(struct nf_conn *ct)
@@@ -350,9 -350,7 +365,8 @@@ static const struct nf_conntrack_l4prot
  #ifdef CONFIG_NF_CONNTRACK_PROCFS
  	.print_conntrack = gre_print_conntrack,
  #endif
 +	.get_timeouts    = gre_get_timeouts,
  	.packet		 = gre_packet,
- 	.new		 = gre_new,
  	.destroy	 = gre_destroy,
  	.me 		 = THIS_MODULE,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
diff --cc net/netfilter/nf_conntrack_proto_sctp.c
index 900b74fa0c53,78c115152a78..000000000000
--- a/net/netfilter/nf_conntrack_proto_sctp.c
+++ b/net/netfilter/nf_conntrack_proto_sctp.c
@@@ -272,9 -273,61 +272,67 @@@ static int sctp_new_state(enum ip_connt
  	return sctp_conntracks[dir][i][cur_state];
  }
  
++<<<<<<< HEAD
 +static unsigned int *sctp_get_timeouts(struct net *net)
 +{
 +	return sctp_pernet(net)->timeouts;
++=======
+ /* Don't need lock here: this conntrack not in circulation yet */
+ static noinline bool
+ sctp_new(struct nf_conn *ct, const struct sk_buff *skb,
+ 	 const struct sctphdr *sh, unsigned int dataoff)
+ {
+ 	enum sctp_conntrack new_state;
+ 	const struct sctp_chunkhdr *sch;
+ 	struct sctp_chunkhdr _sch;
+ 	u32 offset, count;
+ 
+ 	memset(&ct->proto.sctp, 0, sizeof(ct->proto.sctp));
+ 	new_state = SCTP_CONNTRACK_MAX;
+ 	for_each_sctp_chunk(skb, sch, _sch, offset, dataoff, count) {
+ 		new_state = sctp_new_state(IP_CT_DIR_ORIGINAL,
+ 					   SCTP_CONNTRACK_NONE, sch->type);
+ 
+ 		/* Invalid: delete conntrack */
+ 		if (new_state == SCTP_CONNTRACK_NONE ||
+ 		    new_state == SCTP_CONNTRACK_MAX) {
+ 			pr_debug("nf_conntrack_sctp: invalid new deleting.\n");
+ 			return false;
+ 		}
+ 
+ 		/* Copy the vtag into the state info */
+ 		if (sch->type == SCTP_CID_INIT) {
+ 			struct sctp_inithdr _inithdr, *ih;
+ 			/* Sec 8.5.1 (A) */
+ 			if (sh->vtag)
+ 				return false;
+ 
+ 			ih = skb_header_pointer(skb, offset + sizeof(_sch),
+ 						sizeof(_inithdr), &_inithdr);
+ 			if (!ih)
+ 				return false;
+ 
+ 			pr_debug("Setting vtag %x for new conn\n",
+ 				 ih->init_tag);
+ 
+ 			ct->proto.sctp.vtag[IP_CT_DIR_REPLY] = ih->init_tag;
+ 		} else if (sch->type == SCTP_CID_HEARTBEAT) {
+ 			pr_debug("Setting vtag %x for secondary conntrack\n",
+ 				 sh->vtag);
+ 			ct->proto.sctp.vtag[IP_CT_DIR_ORIGINAL] = sh->vtag;
+ 		} else {
+ 		/* If it is a shutdown ack OOTB packet, we expect a return
+ 		   shutdown complete, otherwise an ABORT Sec 8.4 (5) and (8) */
+ 			pr_debug("Setting vtag %x for new conn OOTB\n",
+ 				 sh->vtag);
+ 			ct->proto.sctp.vtag[IP_CT_DIR_REPLY] = sh->vtag;
+ 		}
+ 
+ 		ct->proto.sctp.state = new_state;
+ 	}
+ 
+ 	return true;
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  }
  
  /* Returns verdict for packet, or -NF_ACCEPT for invalid. */
@@@ -397,83 -466,9 +466,87 @@@ out
  	return -NF_ACCEPT;
  }
  
++<<<<<<< HEAD
 +/* Called when a new connection for this protocol found. */
 +static bool sctp_new(struct nf_conn *ct, const struct sk_buff *skb,
 +		     unsigned int dataoff, unsigned int *timeouts)
 +{
 +	enum sctp_conntrack new_state;
 +	const struct sctphdr *sh;
 +	struct sctphdr _sctph;
 +	const struct sctp_chunkhdr *sch;
 +	struct sctp_chunkhdr _sch;
 +	u_int32_t offset, count;
 +	unsigned long map[256 / sizeof(unsigned long)] = { 0 };
 +
 +	sh = skb_header_pointer(skb, dataoff, sizeof(_sctph), &_sctph);
 +	if (sh == NULL)
 +		return false;
 +
 +	if (do_basic_checks(ct, skb, dataoff, map) != 0)
 +		return false;
 +
 +	/* If an OOTB packet has any of these chunks discard (Sec 8.4) */
 +	if (test_bit(SCTP_CID_ABORT, map) ||
 +	    test_bit(SCTP_CID_SHUTDOWN_COMPLETE, map) ||
 +	    test_bit(SCTP_CID_COOKIE_ACK, map))
 +		return false;
 +
 +	memset(&ct->proto.sctp, 0, sizeof(ct->proto.sctp));
 +	new_state = SCTP_CONNTRACK_MAX;
 +	for_each_sctp_chunk (skb, sch, _sch, offset, dataoff, count) {
 +		/* Don't need lock here: this conntrack not in circulation yet */
 +		new_state = sctp_new_state(IP_CT_DIR_ORIGINAL,
 +					   SCTP_CONNTRACK_NONE, sch->type);
 +
 +		/* Invalid: delete conntrack */
 +		if (new_state == SCTP_CONNTRACK_NONE ||
 +		    new_state == SCTP_CONNTRACK_MAX) {
 +			pr_debug("nf_conntrack_sctp: invalid new deleting.\n");
 +			return false;
 +		}
 +
 +		/* Copy the vtag into the state info */
 +		if (sch->type == SCTP_CID_INIT) {
 +			struct sctp_inithdr _inithdr, *ih;
 +			/* Sec 8.5.1 (A) */
 +			if (sh->vtag)
 +				return false;
 +
 +			ih = skb_header_pointer(skb, offset + sizeof(_sch),
 +						sizeof(_inithdr), &_inithdr);
 +			if (!ih)
 +				return false;
 +
 +			pr_debug("Setting vtag %x for new conn\n",
 +				 ih->init_tag);
 +
 +			ct->proto.sctp.vtag[IP_CT_DIR_REPLY] = ih->init_tag;
 +		} else if (sch->type == SCTP_CID_HEARTBEAT) {
 +			pr_debug("Setting vtag %x for secondary conntrack\n",
 +				 sh->vtag);
 +			ct->proto.sctp.vtag[IP_CT_DIR_ORIGINAL] = sh->vtag;
 +		}
 +		/* If it is a shutdown ack OOTB packet, we expect a return
 +		   shutdown complete, otherwise an ABORT Sec 8.4 (5) and (8) */
 +		else {
 +			pr_debug("Setting vtag %x for new conn OOTB\n",
 +				 sh->vtag);
 +			ct->proto.sctp.vtag[IP_CT_DIR_REPLY] = sh->vtag;
 +		}
 +
 +		ct->proto.sctp.state = new_state;
 +	}
 +
 +	return true;
 +}
 +
 +static int sctp_error(struct net *net, struct nf_conn *tpl, struct sk_buff *skb,
++=======
+ static int sctp_error(struct nf_conn *tpl, struct sk_buff *skb,
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  		      unsigned int dataoff,
 -		      const struct nf_hook_state *state)
 +		      u8 pf, unsigned int hooknum)
  {
  	const struct sctphdr *sh;
  	const char *logmsg;
@@@ -770,8 -763,6 +843,11 @@@ const struct nf_conntrack_l4proto nf_co
  	.print_conntrack	= sctp_print_conntrack,
  #endif
  	.packet 		= sctp_packet,
++<<<<<<< HEAD
 +	.get_timeouts		= sctp_get_timeouts,
 +	.new 			= sctp_new,
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  	.error			= sctp_error,
  	.can_early_drop		= sctp_can_early_drop,
  	.me 			= THIS_MODULE,
@@@ -805,8 -796,6 +881,11 @@@ const struct nf_conntrack_l4proto nf_co
  	.print_conntrack	= sctp_print_conntrack,
  #endif
  	.packet 		= sctp_packet,
++<<<<<<< HEAD
 +	.get_timeouts		= sctp_get_timeouts,
 +	.new 			= sctp_new,
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  	.error			= sctp_error,
  	.can_early_drop		= sctp_can_early_drop,
  	.me 			= THIS_MODULE,
diff --cc net/netfilter/nf_conntrack_proto_tcp.c
index 4908e99488e6,6d278cdff145..000000000000
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@@ -770,9 -770,76 +770,82 @@@ static int tcp_error(struct net *net, s
  	return NF_ACCEPT;
  }
  
++<<<<<<< HEAD
 +static unsigned int *tcp_get_timeouts(struct net *net)
 +{
 +	return tcp_pernet(net)->timeouts;
++=======
+ static noinline bool tcp_new(struct nf_conn *ct, const struct sk_buff *skb,
+ 			     unsigned int dataoff,
+ 			     const struct tcphdr *th)
+ {
+ 	enum tcp_conntrack new_state;
+ 	struct net *net = nf_ct_net(ct);
+ 	const struct nf_tcp_net *tn = tcp_pernet(net);
+ 	const struct ip_ct_tcp_state *sender = &ct->proto.tcp.seen[0];
+ 	const struct ip_ct_tcp_state *receiver = &ct->proto.tcp.seen[1];
+ 
+ 	/* Don't need lock here: this conntrack not in circulation yet */
+ 	new_state = tcp_conntracks[0][get_conntrack_index(th)][TCP_CONNTRACK_NONE];
+ 
+ 	/* Invalid: delete conntrack */
+ 	if (new_state >= TCP_CONNTRACK_MAX) {
+ 		pr_debug("nf_ct_tcp: invalid new deleting.\n");
+ 		return false;
+ 	}
+ 
+ 	if (new_state == TCP_CONNTRACK_SYN_SENT) {
+ 		memset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));
+ 		/* SYN packet */
+ 		ct->proto.tcp.seen[0].td_end =
+ 			segment_seq_plus_len(ntohl(th->seq), skb->len,
+ 					     dataoff, th);
+ 		ct->proto.tcp.seen[0].td_maxwin = ntohs(th->window);
+ 		if (ct->proto.tcp.seen[0].td_maxwin == 0)
+ 			ct->proto.tcp.seen[0].td_maxwin = 1;
+ 		ct->proto.tcp.seen[0].td_maxend =
+ 			ct->proto.tcp.seen[0].td_end;
+ 
+ 		tcp_options(skb, dataoff, th, &ct->proto.tcp.seen[0]);
+ 	} else if (tn->tcp_loose == 0) {
+ 		/* Don't try to pick up connections. */
+ 		return false;
+ 	} else {
+ 		memset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));
+ 		/*
+ 		 * We are in the middle of a connection,
+ 		 * its history is lost for us.
+ 		 * Let's try to use the data from the packet.
+ 		 */
+ 		ct->proto.tcp.seen[0].td_end =
+ 			segment_seq_plus_len(ntohl(th->seq), skb->len,
+ 					     dataoff, th);
+ 		ct->proto.tcp.seen[0].td_maxwin = ntohs(th->window);
+ 		if (ct->proto.tcp.seen[0].td_maxwin == 0)
+ 			ct->proto.tcp.seen[0].td_maxwin = 1;
+ 		ct->proto.tcp.seen[0].td_maxend =
+ 			ct->proto.tcp.seen[0].td_end +
+ 			ct->proto.tcp.seen[0].td_maxwin;
+ 
+ 		/* We assume SACK and liberal window checking to handle
+ 		 * window scaling */
+ 		ct->proto.tcp.seen[0].flags =
+ 		ct->proto.tcp.seen[1].flags = IP_CT_TCP_FLAG_SACK_PERM |
+ 					      IP_CT_TCP_FLAG_BE_LIBERAL;
+ 	}
+ 
+ 	/* tcp_packet will set them */
+ 	ct->proto.tcp.last_index = TCP_NONE_SET;
+ 
+ 	pr_debug("%s: sender end=%u maxend=%u maxwin=%u scale=%i "
+ 		 "receiver end=%u maxend=%u maxwin=%u scale=%i\n",
+ 		 __func__,
+ 		 sender->td_end, sender->td_maxend, sender->td_maxwin,
+ 		 sender->td_scale,
+ 		 receiver->td_end, receiver->td_maxend, receiver->td_maxwin,
+ 		 receiver->td_scale);
+ 	return true;
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  }
  
  /* Returns verdict for packet, or -1 for invalid. */
@@@ -790,10 -858,13 +863,14 @@@ static int tcp_packet(struct nf_conn *c
  	const struct tcphdr *th;
  	struct tcphdr _tcph;
  	unsigned long timeout;
 +	unsigned int index;
  
  	th = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph);
- 	BUG_ON(th == NULL);
+ 	if (th == NULL)
+ 		return -NF_ACCEPT;
+ 
+ 	if (!nf_ct_is_confirmed(ct) && !tcp_new(ct, skb, dataoff, th))
+ 		return -NF_ACCEPT;
  
  	spin_lock_bh(&ct->lock);
  	old_state = ct->proto.tcp.state;
@@@ -1070,82 -1145,6 +1147,85 @@@
  	return NF_ACCEPT;
  }
  
++<<<<<<< HEAD
 +/* Called when a new connection for this protocol found. */
 +static bool tcp_new(struct nf_conn *ct, const struct sk_buff *skb,
 +		    unsigned int dataoff, unsigned int *timeouts)
 +{
 +	enum tcp_conntrack new_state;
 +	const struct tcphdr *th;
 +	struct tcphdr _tcph;
 +	struct net *net = nf_ct_net(ct);
 +	struct nf_tcp_net *tn = tcp_pernet(net);
 +	const struct ip_ct_tcp_state *sender = &ct->proto.tcp.seen[0];
 +	const struct ip_ct_tcp_state *receiver = &ct->proto.tcp.seen[1];
 +
 +	th = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph);
 +	BUG_ON(th == NULL);
 +
 +	/* Don't need lock here: this conntrack not in circulation yet */
 +	new_state = tcp_conntracks[0][get_conntrack_index(th)][TCP_CONNTRACK_NONE];
 +
 +	/* Invalid: delete conntrack */
 +	if (new_state >= TCP_CONNTRACK_MAX) {
 +		pr_debug("nf_ct_tcp: invalid new deleting.\n");
 +		return false;
 +	}
 +
 +	if (new_state == TCP_CONNTRACK_SYN_SENT) {
 +		memset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));
 +		/* SYN packet */
 +		ct->proto.tcp.seen[0].td_end =
 +			segment_seq_plus_len(ntohl(th->seq), skb->len,
 +					     dataoff, th);
 +		ct->proto.tcp.seen[0].td_maxwin = ntohs(th->window);
 +		if (ct->proto.tcp.seen[0].td_maxwin == 0)
 +			ct->proto.tcp.seen[0].td_maxwin = 1;
 +		ct->proto.tcp.seen[0].td_maxend =
 +			ct->proto.tcp.seen[0].td_end;
 +
 +		tcp_options(skb, dataoff, th, &ct->proto.tcp.seen[0]);
 +	} else if (tn->tcp_loose == 0) {
 +		/* Don't try to pick up connections. */
 +		return false;
 +	} else {
 +		memset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));
 +		/*
 +		 * We are in the middle of a connection,
 +		 * its history is lost for us.
 +		 * Let's try to use the data from the packet.
 +		 */
 +		ct->proto.tcp.seen[0].td_end =
 +			segment_seq_plus_len(ntohl(th->seq), skb->len,
 +					     dataoff, th);
 +		ct->proto.tcp.seen[0].td_maxwin = ntohs(th->window);
 +		if (ct->proto.tcp.seen[0].td_maxwin == 0)
 +			ct->proto.tcp.seen[0].td_maxwin = 1;
 +		ct->proto.tcp.seen[0].td_maxend =
 +			ct->proto.tcp.seen[0].td_end +
 +			ct->proto.tcp.seen[0].td_maxwin;
 +
 +		/* We assume SACK and liberal window checking to handle
 +		 * window scaling */
 +		ct->proto.tcp.seen[0].flags =
 +		ct->proto.tcp.seen[1].flags = IP_CT_TCP_FLAG_SACK_PERM |
 +					      IP_CT_TCP_FLAG_BE_LIBERAL;
 +	}
 +
 +	/* tcp_packet will set them */
 +	ct->proto.tcp.last_index = TCP_NONE_SET;
 +
 +	pr_debug("tcp_new: sender end=%u maxend=%u maxwin=%u scale=%i "
 +		 "receiver end=%u maxend=%u maxwin=%u scale=%i\n",
 +		 sender->td_end, sender->td_maxend, sender->td_maxwin,
 +		 sender->td_scale,
 +		 receiver->td_end, receiver->td_maxend, receiver->td_maxwin,
 +		 receiver->td_scale);
 +	return true;
 +}
 +
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  static bool tcp_can_early_drop(const struct nf_conn *ct)
  {
  	switch (ct->proto.tcp.state) {
@@@ -1547,8 -1548,6 +1627,11 @@@ const struct nf_conntrack_l4proto nf_co
  	.print_conntrack 	= tcp_print_conntrack,
  #endif
  	.packet 		= tcp_packet,
++<<<<<<< HEAD
 +	.get_timeouts		= tcp_get_timeouts,
 +	.new 			= tcp_new,
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  	.error			= tcp_error,
  	.can_early_drop		= tcp_can_early_drop,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
@@@ -1583,8 -1582,6 +1666,11 @@@ const struct nf_conntrack_l4proto nf_co
  	.print_conntrack 	= tcp_print_conntrack,
  #endif
  	.packet 		= tcp_packet,
++<<<<<<< HEAD
 +	.get_timeouts		= tcp_get_timeouts,
 +	.new 			= tcp_new,
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  	.error			= tcp_error,
  	.can_early_drop		= tcp_can_early_drop,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
diff --cc net/netfilter/nf_conntrack_proto_udp.c
index a89c059cbf40,1119323425e7..000000000000
--- a/net/netfilter/nf_conntrack_proto_udp.c
+++ b/net/netfilter/nf_conntrack_proto_udp.c
@@@ -63,24 -70,18 +63,27 @@@ static int udp_packet(struct nf_conn *c
  	return NF_ACCEPT;
  }
  
++<<<<<<< HEAD
 +/* Called when a new connection for this protocol found. */
 +static bool udp_new(struct nf_conn *ct, const struct sk_buff *skb,
 +		    unsigned int dataoff, unsigned int *timeouts)
 +{
 +	return true;
 +}
 +
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  #ifdef CONFIG_NF_CT_PROTO_UDPLITE
 -static void udplite_error_log(const struct sk_buff *skb,
 -			      const struct nf_hook_state *state,
 -			      const char *msg)
 +static void udplite_error_log(const struct sk_buff *skb, struct net *net,
 +			      u8 pf, const char *msg)
  {
 -	nf_l4proto_log_invalid(skb, state->net, state->pf,
 -			       IPPROTO_UDPLITE, "%s", msg);
 +	nf_l4proto_log_invalid(skb, net, pf, IPPROTO_UDPLITE, "%s", msg);
  }
  
 -static int udplite_error(struct nf_conn *tmpl, struct sk_buff *skb,
 +static int udplite_error(struct net *net, struct nf_conn *tmpl,
 +			 struct sk_buff *skb,
  			 unsigned int dataoff,
 -			 const struct nf_hook_state *state)
 +			 u8 pf, unsigned int hooknum)
  {
  	unsigned int udplen = skb->len - dataoff;
  	const struct udphdr *hdr;
@@@ -275,8 -281,6 +278,11 @@@ const struct nf_conntrack_l4proto nf_co
  	.l4proto		= IPPROTO_UDP,
  	.allow_clash		= true,
  	.packet			= udp_packet,
++<<<<<<< HEAD
 +	.get_timeouts		= udp_get_timeouts,
 +	.new			= udp_new,
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  	.error			= udp_error,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr	= nf_ct_port_tuple_to_nlattr,
@@@ -305,8 -309,6 +311,11 @@@ const struct nf_conntrack_l4proto nf_co
  	.l4proto		= IPPROTO_UDPLITE,
  	.allow_clash		= true,
  	.packet			= udp_packet,
++<<<<<<< HEAD
 +	.get_timeouts		= udp_get_timeouts,
 +	.new			= udp_new,
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  	.error			= udplite_error,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr	= nf_ct_port_tuple_to_nlattr,
@@@ -335,8 -337,6 +344,11 @@@ const struct nf_conntrack_l4proto nf_co
  	.l4proto		= IPPROTO_UDP,
  	.allow_clash		= true,
  	.packet			= udp_packet,
++<<<<<<< HEAD
 +	.get_timeouts		= udp_get_timeouts,
 +	.new			= udp_new,
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  	.error			= udp_error,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr	= nf_ct_port_tuple_to_nlattr,
@@@ -365,8 -365,6 +377,11 @@@ const struct nf_conntrack_l4proto nf_co
  	.l4proto		= IPPROTO_UDPLITE,
  	.allow_clash		= true,
  	.packet			= udp_packet,
++<<<<<<< HEAD
 +	.get_timeouts		= udp_get_timeouts,
 +	.new			= udp_new,
++=======
++>>>>>>> 9976fc6e6edb (netfilter: conntrack: remove the l4proto->new() function)
  	.error			= udplite_error,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr	= nf_ct_port_tuple_to_nlattr,
* Unmerged path include/net/netfilter/nf_conntrack_l4proto.h
* Unmerged path net/ipv4/netfilter/nf_conntrack_proto_icmp.c
* Unmerged path net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
* Unmerged path net/netfilter/nf_conntrack_core.c
* Unmerged path net/netfilter/nf_conntrack_proto_dccp.c
* Unmerged path net/netfilter/nf_conntrack_proto_generic.c
* Unmerged path net/netfilter/nf_conntrack_proto_gre.c
* Unmerged path net/netfilter/nf_conntrack_proto_sctp.c
* Unmerged path net/netfilter/nf_conntrack_proto_tcp.c
* Unmerged path net/netfilter/nf_conntrack_proto_udp.c
