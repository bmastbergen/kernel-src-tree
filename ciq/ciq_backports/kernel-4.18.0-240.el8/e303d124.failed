Bluetooth: btqca: Rename ROME specific variables to generic variables

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Balakrishna Godavarthi <bgodavar@codeaurora.org>
commit e303d124b70920ef86b26d792d8b959166a28f6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e303d124.failed

Variables which are named with rome are commonly used for all the
BT SoC's. Instead of continuing further, renamed them to generic
name.

	Signed-off-by: Balakrishna Godavarthi <bgodavar@codeaurora.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit e303d124b70920ef86b26d792d8b959166a28f6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btqca.c
#	drivers/bluetooth/btqca.h
diff --cc drivers/bluetooth/btqca.c
index 8219816c54a0,1a0f630515a6..000000000000
--- a/drivers/bluetooth/btqca.c
+++ b/drivers/bluetooth/btqca.c
@@@ -73,15 -59,17 +73,22 @@@ static int rome_patch_ver_req(struct hc
  
  	BT_DBG("%s: Product:0x%08x", hdev->name, le32_to_cpu(ver->product_id));
  	BT_DBG("%s: Patch  :0x%08x", hdev->name, le16_to_cpu(ver->patch_ver));
- 	BT_DBG("%s: ROM    :0x%08x", hdev->name, le16_to_cpu(ver->rome_ver));
+ 	BT_DBG("%s: ROM    :0x%08x", hdev->name, le16_to_cpu(ver->rom_ver));
  	BT_DBG("%s: SOC    :0x%08x", hdev->name, le32_to_cpu(ver->soc_id));
  
 -	/* QCA chipset version can be decided by patch and SoC
 +	/* ROME chipset version can be decided by patch and SoC
  	 * version, combination with upper 2 bytes from SoC
  	 * and lower 2 bytes from patch will be used.
  	 */
++<<<<<<< HEAD
 +	*rome_version = (le32_to_cpu(ver->soc_id) << 16) |
 +			(le16_to_cpu(ver->rome_ver) & 0x0000ffff);
++=======
+ 	*soc_version = (le32_to_cpu(ver->soc_id) << 16) |
+ 			(le16_to_cpu(ver->rom_ver) & 0x0000ffff);
+ 	if (*soc_version == 0)
+ 		err = -EILSEQ;
++>>>>>>> e303d124b709 (Bluetooth: btqca: Rename ROME specific variables to generic variables)
  
  out:
  	kfree_skb(skb);
@@@ -108,7 -99,29 +115,33 @@@ static int rome_reset(struct hci_dev *h
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void rome_tlv_check_data(struct rome_config *config,
++=======
+ int qca_send_pre_shutdown_cmd(struct hci_dev *hdev)
+ {
+ 	struct sk_buff *skb;
+ 	int err;
+ 
+ 	bt_dev_dbg(hdev, "QCA pre shutdown cmd");
+ 
+ 	skb = __hci_cmd_sync_ev(hdev, QCA_PRE_SHUTDOWN_CMD, 0,
+ 				NULL, HCI_EV_CMD_COMPLETE, HCI_INIT_TIMEOUT);
+ 
+ 	if (IS_ERR(skb)) {
+ 		err = PTR_ERR(skb);
+ 		bt_dev_err(hdev, "QCA preshutdown_cmd failed (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	kfree_skb(skb);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(qca_send_pre_shutdown_cmd);
+ 
+ static void qca_tlv_check_data(struct qca_fw_config *config,
++>>>>>>> e303d124b709 (Bluetooth: btqca: Rename ROME specific variables to generic variables)
  				const struct firmware *fw)
  {
  	const u8 *data;
@@@ -127,7 -140,8 +160,12 @@@
  	BT_DBG("TLV Type\t\t : 0x%x", type_len & 0x000000ff);
  	BT_DBG("Length\t\t : %d bytes", length);
  
++<<<<<<< HEAD
 +	config->dnld_mode = ROME_SKIP_EVT_NONE;
++=======
+ 	config->dnld_mode = QCA_SKIP_EVT_NONE;
+ 	config->dnld_type = QCA_SKIP_EVT_NONE;
++>>>>>>> e303d124b709 (Bluetooth: btqca: Rename ROME specific variables to generic variables)
  
  	switch (config->type) {
  	case TLV_TYPE_PATCH:
@@@ -207,8 -222,8 +245,13 @@@
  	}
  }
  
++<<<<<<< HEAD
 +static int rome_tlv_send_segment(struct hci_dev *hdev, int seg_size,
 +				 const u8 *data, enum rome_tlv_dnld_mode mode)
++=======
+ static int qca_tlv_send_segment(struct hci_dev *hdev, int seg_size,
+ 				 const u8 *data, enum qca_tlv_dnld_mode mode)
++>>>>>>> e303d124b709 (Bluetooth: btqca: Rename ROME specific variables to generic variables)
  {
  	struct sk_buff *skb;
  	struct edl_event_hdr *edl;
@@@ -260,8 -275,33 +303,38 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
 +static int rome_download_firmware(struct hci_dev *hdev,
 +				  struct rome_config *config)
++=======
+ static int qca_inject_cmd_complete_event(struct hci_dev *hdev)
+ {
+ 	struct hci_event_hdr *hdr;
+ 	struct hci_ev_cmd_complete *evt;
+ 	struct sk_buff *skb;
+ 
+ 	skb = bt_skb_alloc(sizeof(*hdr) + sizeof(*evt) + 1, GFP_KERNEL);
+ 	if (!skb)
+ 		return -ENOMEM;
+ 
+ 	hdr = skb_put(skb, sizeof(*hdr));
+ 	hdr->evt = HCI_EV_CMD_COMPLETE;
+ 	hdr->plen = sizeof(*evt) + 1;
+ 
+ 	evt = skb_put(skb, sizeof(*evt));
+ 	evt->ncmd = 1;
+ 	evt->opcode = cpu_to_le16(QCA_HCI_CC_OPCODE);
+ 
+ 	skb_put_u8(skb, QCA_HCI_CC_SUCCESS);
+ 
+ 	hci_skb_pkt_type(skb) = HCI_EVENT_PKT;
+ 
+ 	return hci_recv_frame(hdev, skb);
+ }
+ 
+ static int qca_download_firmware(struct hci_dev *hdev,
+ 				  struct qca_fw_config *config)
++>>>>>>> e303d124b709 (Bluetooth: btqca: Rename ROME specific variables to generic variables)
  {
  	const struct firmware *fw;
  	const u8 *segment;
@@@ -288,16 -328,27 +361,30 @@@
  		remain -= segsize;
  		/* The last segment is always acked regardless download mode */
  		if (!remain || segsize < MAX_SIZE_PER_TLV_SEGMENT)
- 			config->dnld_mode = ROME_SKIP_EVT_NONE;
+ 			config->dnld_mode = QCA_SKIP_EVT_NONE;
  
 -		ret = qca_tlv_send_segment(hdev, segsize, segment,
 +		ret = rome_tlv_send_segment(hdev, segsize, segment,
  					    config->dnld_mode);
  		if (ret)
 -			goto out;
 +			break;
  
  		segment += segsize;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Latest qualcomm chipsets are not sending a command complete event
+ 	 * for every fw packet sent. They only respond with a vendor specific
+ 	 * event for the last packet. This optimization in the chip will
+ 	 * decrease the BT in initialization time. Here we will inject a command
+ 	 * complete event to avoid a command timeout error message.
+ 	 */
+ 	if (config->dnld_type == QCA_SKIP_EVT_VSE_CC ||
+ 	    config->dnld_type == QCA_SKIP_EVT_VSE)
+ 		ret = qca_inject_cmd_complete_event(hdev);
+ 
+ out:
++>>>>>>> e303d124b709 (Bluetooth: btqca: Rename ROME specific variables to generic variables)
  	release_firmware(fw);
  
  	return ret;
@@@ -328,13 -378,15 +415,17 @@@ int qca_set_bdaddr_rome(struct hci_dev 
  }
  EXPORT_SYMBOL_GPL(qca_set_bdaddr_rome);
  
 -int qca_uart_setup(struct hci_dev *hdev, uint8_t baudrate,
 -		   enum qca_btsoc_type soc_type, u32 soc_ver,
 -		   const char *firmware_name)
 +int qca_uart_setup_rome(struct hci_dev *hdev, uint8_t baudrate)
  {
++<<<<<<< HEAD
 +	u32 rome_ver = 0;
 +	struct rome_config config;
++=======
+ 	struct qca_fw_config config;
++>>>>>>> e303d124b709 (Bluetooth: btqca: Rename ROME specific variables to generic variables)
  	int err;
 -	u8 rom_ver = 0;
  
 -	bt_dev_dbg(hdev, "QCA setup on UART");
 +	BT_DBG("%s: ROME setup on UART", hdev->name);
  
  	config.user_baud_rate = baudrate;
  
diff --cc drivers/bluetooth/btqca.h
index 13d77fd873b6,7f7a2b2c0df6..000000000000
--- a/drivers/bluetooth/btqca.h
+++ b/drivers/bluetooth/btqca.h
@@@ -77,7 -72,8 +77,12 @@@ struct qca_fw_config 
  	u8 type;
  	char fwname[64];
  	uint8_t user_baud_rate;
++<<<<<<< HEAD
 +	enum rome_tlv_dnld_mode dnld_mode;
++=======
+ 	enum qca_tlv_dnld_mode dnld_mode;
+ 	enum qca_tlv_dnld_mode dnld_type;
++>>>>>>> e303d124b709 (Bluetooth: btqca: Rename ROME specific variables to generic variables)
  };
  
  struct edl_event_hdr {
* Unmerged path drivers/bluetooth/btqca.c
* Unmerged path drivers/bluetooth/btqca.h
