xsk: Add rcu_read_lock around the XSK wakeup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Maxim Mikityanskiy <maximmi@mellanox.com>
commit 06870682087b58398671e8cdc896cd62314c4399
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/06870682.failed

The XSK wakeup callback in drivers makes some sanity checks before
triggering NAPI. However, some configuration changes may occur during
this function that affect the result of those checks. For example, the
interface can go down, and all the resources will be destroyed after the
checks in the wakeup function, but before it attempts to use these
resources. Wrap this callback in rcu_read_lock to allow driver to
synchronize_rcu before actually destroying the resources.

xsk_wakeup is a new function that encapsulates calling ndo_xsk_wakeup
wrapped into the RCU lock. After this commit, xsk_poll starts using
xsk_wakeup and checks xs->zc instead of ndo_xsk_wakeup != NULL to decide
ndo_xsk_wakeup should be called. It also fixes a bug introduced with the
need_wakeup feature: a non-zero-copy socket may be used with a driver
supporting zero-copy, and in this case ndo_xsk_wakeup should not be
called, so the xs->zc check is the correct one.

Fixes: 77cd0d7b3f25 ("xsk: add support for need_wakeup flag in AF_XDP rings")
	Signed-off-by: Maxim Mikityanskiy <maximmi@mellanox.com>
	Signed-off-by: Björn Töpel <bjorn.topel@intel.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Link: https://lore.kernel.org/bpf/20191217162023.16011-2-maximmi@mellanox.com
(cherry picked from commit 06870682087b58398671e8cdc896cd62314c4399)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/xdp/xsk.c
diff --cc net/xdp/xsk.c
index 6817d21fcba0,328f661b83b2..000000000000
--- a/net/xdp/xsk.c
+++ b/net/xdp/xsk.c
@@@ -305,11 -334,21 +305,25 @@@ out
  }
  EXPORT_SYMBOL(xsk_umem_consume_tx);
  
- static int xsk_zc_xmit(struct xdp_sock *xs)
+ static int xsk_wakeup(struct xdp_sock *xs, u8 flags)
  {
  	struct net_device *dev = xs->dev;
+ 	int err;
  
++<<<<<<< HEAD
 +	return dev->netdev_ops->ndo_xsk_async_xmit(dev, xs->queue_id);
++=======
+ 	rcu_read_lock();
+ 	err = dev->netdev_ops->ndo_xsk_wakeup(dev, xs->queue_id, flags);
+ 	rcu_read_unlock();
+ 
+ 	return err;
+ }
+ 
+ static int xsk_zc_xmit(struct xdp_sock *xs)
+ {
+ 	return xsk_wakeup(xs, XDP_WAKEUP_TX);
++>>>>>>> 06870682087b (xsk: Add rcu_read_lock around the XSK wakeup)
  }
  
  static void xsk_destruct_skb(struct sk_buff *skb)
@@@ -417,13 -456,12 +431,12 @@@ static int xsk_sendmsg(struct socket *s
  	return __xsk_sendmsg(sk);
  }
  
 -static __poll_t xsk_poll(struct file *file, struct socket *sock,
 +static unsigned int xsk_poll(struct file *file, struct socket *sock,
  			     struct poll_table_struct *wait)
  {
 -	__poll_t mask = datagram_poll(file, sock, wait);
 +	unsigned int mask = datagram_poll(file, sock, wait);
  	struct sock *sk = sock->sk;
  	struct xdp_sock *xs = xdp_sk(sk);
- 	struct net_device *dev;
  	struct xdp_umem *umem;
  
  	if (unlikely(!xsk_is_bound(xs)))
* Unmerged path net/xdp/xsk.c
