drm/i915: split intel_modeset_driver_remove() to pre/post irq uninstall

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jani Nikula <jani.nikula@intel.com>
commit 93a0ed6cc164bad2bc9afcf1d06186f8425020af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/93a0ed6c.failed

Split intel_modeset_driver_remove() to two, the part with working irqs
before irq uninstall, and the part after irq uninstall. Move
irq_unintall() closer to the layer it belongs.

The error path in i915_driver_modeset_probe() looks obviously weird
after this, but remains as good or broken as it ever was. No functional
changes.

	Cc: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Reviewed-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200214135058.7580-1-jani.nikula@intel.com
(cherry picked from commit 93a0ed6cc164bad2bc9afcf1d06186f8425020af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display.c
#	drivers/gpu/drm/i915/display/intel_display.h
#	drivers/gpu/drm/i915/i915_drv.c
diff --cc drivers/gpu/drm/i915/display/intel_display.c
index 5c8c11deb857,87df5f937f94..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@@ -16887,22 -18923,19 +16887,37 @@@ static void intel_hpd_poll_fini(struct 
  	drm_connector_list_iter_end(&conn_iter);
  }
  
++<<<<<<< HEAD
 +void intel_modeset_cleanup(struct drm_device *dev)
++=======
+ /* part #1: call before irq uninstall */
+ void intel_modeset_driver_remove(struct drm_i915_private *i915)
++>>>>>>> 93a0ed6cc164 (drm/i915: split intel_modeset_driver_remove() to pre/post irq uninstall)
  {
 -	flush_workqueue(i915->flip_wq);
 -	flush_workqueue(i915->modeset_wq);
 +	struct drm_i915_private *dev_priv = to_i915(dev);
  
++<<<<<<< HEAD
 +	flush_workqueue(dev_priv->modeset_wq);
 +
 +	flush_work(&dev_priv->atomic_helper.free_work);
 +	WARN_ON(!llist_empty(&dev_priv->atomic_helper.free_list));
 +
 +	/*
 +	 * Interrupts and polling as the first thing to avoid creating havoc.
 +	 * Too much stuff here (turning of connectors, ...) would
 +	 * experience fancy races otherwise.
 +	 */
 +	intel_irq_uninstall(dev_priv);
 +
++=======
+ 	flush_work(&i915->atomic_helper.free_work);
+ 	WARN_ON(!llist_empty(&i915->atomic_helper.free_list));
+ }
+ 
+ /* part #2: call after irq uninstall */
+ void intel_modeset_driver_remove_noirq(struct drm_i915_private *i915)
+ {
++>>>>>>> 93a0ed6cc164 (drm/i915: split intel_modeset_driver_remove() to pre/post irq uninstall)
  	/*
  	 * Due to the hpd irq storm handling the hotplug work can re-arm the
  	 * poll handlers. Hence disable polling after hpd handling is shut down.
diff --cc drivers/gpu/drm/i915/display/intel_display.h
index 868914c6d9b5,f92efbbec838..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.h
+++ b/drivers/gpu/drm/i915/display/intel_display.h
@@@ -357,5 -482,179 +357,182 @@@ void lpt_disable_clkout_dp(struct drm_i
  u32 intel_plane_fb_max_stride(struct drm_i915_private *dev_priv,
  			      u32 pixel_format, u64 modifier);
  bool intel_plane_can_remap(const struct intel_plane_state *plane_state);
++<<<<<<< HEAD
++=======
+ enum drm_mode_status
+ intel_mode_valid_max_plane_size(struct drm_i915_private *dev_priv,
+ 				const struct drm_display_mode *mode);
+ enum phy intel_port_to_phy(struct drm_i915_private *i915, enum port port);
+ bool is_trans_port_sync_mode(const struct intel_crtc_state *state);
+ 
+ void intel_plane_destroy(struct drm_plane *plane);
+ void intel_enable_pipe(const struct intel_crtc_state *new_crtc_state);
+ void intel_disable_pipe(const struct intel_crtc_state *old_crtc_state);
+ void i830_enable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe);
+ void i830_disable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe);
+ enum pipe intel_crtc_pch_transcoder(struct intel_crtc *crtc);
+ int vlv_get_hpll_vco(struct drm_i915_private *dev_priv);
+ int vlv_get_cck_clock(struct drm_i915_private *dev_priv,
+ 		      const char *name, u32 reg, int ref_freq);
+ int vlv_get_cck_clock_hpll(struct drm_i915_private *dev_priv,
+ 			   const char *name, u32 reg);
+ void lpt_pch_enable(const struct intel_crtc_state *crtc_state);
+ void lpt_disable_pch_transcoder(struct drm_i915_private *dev_priv);
+ void lpt_disable_iclkip(struct drm_i915_private *dev_priv);
+ void intel_init_display_hooks(struct drm_i915_private *dev_priv);
+ unsigned int intel_fb_xy_to_linear(int x, int y,
+ 				   const struct intel_plane_state *state,
+ 				   int plane);
+ unsigned int intel_fb_align_height(const struct drm_framebuffer *fb,
+ 				   int color_plane, unsigned int height);
+ void intel_add_fb_offsets(int *x, int *y,
+ 			  const struct intel_plane_state *state, int plane);
+ unsigned int intel_rotation_info_size(const struct intel_rotation_info *rot_info);
+ unsigned int intel_remapped_info_size(const struct intel_remapped_info *rem_info);
+ bool intel_has_pending_fb_unpin(struct drm_i915_private *dev_priv);
+ int intel_display_suspend(struct drm_device *dev);
+ void intel_pps_unlock_regs_wa(struct drm_i915_private *dev_priv);
+ void intel_encoder_destroy(struct drm_encoder *encoder);
+ struct drm_display_mode *
+ intel_encoder_current_mode(struct intel_encoder *encoder);
+ bool intel_phy_is_combo(struct drm_i915_private *dev_priv, enum phy phy);
+ bool intel_phy_is_tc(struct drm_i915_private *dev_priv, enum phy phy);
+ enum tc_port intel_port_to_tc(struct drm_i915_private *dev_priv,
+ 			      enum port port);
+ int intel_get_pipe_from_crtc_id_ioctl(struct drm_device *dev, void *data,
+ 				      struct drm_file *file_priv);
+ u32 intel_crtc_get_vblank_counter(struct intel_crtc *crtc);
+ void intel_crtc_vblank_on(const struct intel_crtc_state *crtc_state);
+ void intel_crtc_vblank_off(const struct intel_crtc_state *crtc_state);
+ 
+ int ilk_get_lanes_required(int target_clock, int link_bw, int bpp);
+ void vlv_wait_port_ready(struct drm_i915_private *dev_priv,
+ 			 struct intel_digital_port *dport,
+ 			 unsigned int expected_mask);
+ int intel_get_load_detect_pipe(struct drm_connector *connector,
+ 			       struct intel_load_detect_pipe *old,
+ 			       struct drm_modeset_acquire_ctx *ctx);
+ void intel_release_load_detect_pipe(struct drm_connector *connector,
+ 				    struct intel_load_detect_pipe *old,
+ 				    struct drm_modeset_acquire_ctx *ctx);
+ struct i915_vma *
+ intel_pin_and_fence_fb_obj(struct drm_framebuffer *fb,
+ 			   const struct i915_ggtt_view *view,
+ 			   bool uses_fence,
+ 			   unsigned long *out_flags);
+ void intel_unpin_fb_vma(struct i915_vma *vma, unsigned long flags);
+ struct drm_framebuffer *
+ intel_framebuffer_create(struct drm_i915_gem_object *obj,
+ 			 struct drm_mode_fb_cmd2 *mode_cmd);
+ int intel_prepare_plane_fb(struct drm_plane *plane,
+ 			   struct drm_plane_state *new_state);
+ void intel_cleanup_plane_fb(struct drm_plane *plane,
+ 			    struct drm_plane_state *old_state);
+ 
+ void assert_pch_transcoder_disabled(struct drm_i915_private *dev_priv,
+ 				    enum pipe pipe);
+ 
+ int vlv_force_pll_on(struct drm_i915_private *dev_priv, enum pipe pipe,
+ 		     const struct dpll *dpll);
+ void vlv_force_pll_off(struct drm_i915_private *dev_priv, enum pipe pipe);
+ int lpt_get_iclkip(struct drm_i915_private *dev_priv);
+ bool intel_fuzzy_clock_check(int clock1, int clock2);
+ 
+ void intel_prepare_reset(struct drm_i915_private *dev_priv);
+ void intel_finish_reset(struct drm_i915_private *dev_priv);
+ void intel_dp_get_m_n(struct intel_crtc *crtc,
+ 		      struct intel_crtc_state *pipe_config);
+ void intel_dp_set_m_n(const struct intel_crtc_state *crtc_state,
+ 		      enum link_m_n_set m_n);
+ int intel_dotclock_calculate(int link_freq, const struct intel_link_m_n *m_n);
+ bool bxt_find_best_dpll(struct intel_crtc_state *crtc_state,
+ 			struct dpll *best_clock);
+ int chv_calc_dpll_params(int refclk, struct dpll *pll_clock);
+ 
+ bool hsw_crtc_state_ips_capable(const struct intel_crtc_state *crtc_state);
+ void hsw_enable_ips(const struct intel_crtc_state *crtc_state);
+ void hsw_disable_ips(const struct intel_crtc_state *crtc_state);
+ enum intel_display_power_domain intel_port_to_power_domain(enum port port);
+ enum intel_display_power_domain
+ intel_aux_power_domain(struct intel_digital_port *dig_port);
+ void intel_mode_from_pipe_config(struct drm_display_mode *mode,
+ 				 struct intel_crtc_state *pipe_config);
+ void intel_crtc_arm_fifo_underrun(struct intel_crtc *crtc,
+ 				  struct intel_crtc_state *crtc_state);
+ 
+ u16 skl_scaler_calc_phase(int sub, int scale, bool chroma_center);
+ int skl_update_scaler_crtc(struct intel_crtc_state *crtc_state);
+ void skl_scaler_disable(const struct intel_crtc_state *old_crtc_state);
+ void ilk_pfit_disable(const struct intel_crtc_state *old_crtc_state);
+ u32 glk_plane_color_ctl(const struct intel_crtc_state *crtc_state,
+ 			const struct intel_plane_state *plane_state);
+ u32 glk_plane_color_ctl_crtc(const struct intel_crtc_state *crtc_state);
+ u32 skl_plane_ctl(const struct intel_crtc_state *crtc_state,
+ 		  const struct intel_plane_state *plane_state);
+ u32 skl_plane_ctl_crtc(const struct intel_crtc_state *crtc_state);
+ u32 skl_plane_stride(const struct intel_plane_state *plane_state,
+ 		     int plane);
+ int skl_check_plane_surface(struct intel_plane_state *plane_state);
+ int i9xx_check_plane_surface(struct intel_plane_state *plane_state);
+ int skl_format_to_fourcc(int format, bool rgb_order, bool alpha);
+ unsigned int i9xx_plane_max_stride(struct intel_plane *plane,
+ 				   u32 pixel_format, u64 modifier,
+ 				   unsigned int rotation);
+ int bdw_get_pipemisc_bpp(struct intel_crtc *crtc);
+ 
+ struct intel_display_error_state *
+ intel_display_capture_error_state(struct drm_i915_private *dev_priv);
+ void intel_display_print_error_state(struct drm_i915_error_state_buf *e,
+ 				     struct intel_display_error_state *error);
+ 
+ bool
+ intel_format_info_is_yuv_semiplanar(const struct drm_format_info *info,
+ 				    uint64_t modifier);
+ 
+ /* modesetting */
+ void intel_modeset_init_hw(struct drm_i915_private *i915);
+ int intel_modeset_init(struct drm_i915_private *i915);
+ void intel_modeset_driver_remove(struct drm_i915_private *i915);
+ void intel_modeset_driver_remove_noirq(struct drm_i915_private *i915);
+ void intel_display_resume(struct drm_device *dev);
+ void intel_init_pch_refclk(struct drm_i915_private *dev_priv);
+ 
+ /* modesetting asserts */
+ void assert_panel_unlocked(struct drm_i915_private *dev_priv,
+ 			   enum pipe pipe);
+ void assert_pll(struct drm_i915_private *dev_priv,
+ 		enum pipe pipe, bool state);
+ #define assert_pll_enabled(d, p) assert_pll(d, p, true)
+ #define assert_pll_disabled(d, p) assert_pll(d, p, false)
+ void assert_dsi_pll(struct drm_i915_private *dev_priv, bool state);
+ #define assert_dsi_pll_enabled(d) assert_dsi_pll(d, true)
+ #define assert_dsi_pll_disabled(d) assert_dsi_pll(d, false)
+ void assert_fdi_rx_pll(struct drm_i915_private *dev_priv,
+ 		       enum pipe pipe, bool state);
+ #define assert_fdi_rx_pll_enabled(d, p) assert_fdi_rx_pll(d, p, true)
+ #define assert_fdi_rx_pll_disabled(d, p) assert_fdi_rx_pll(d, p, false)
+ void assert_pipe(struct drm_i915_private *dev_priv,
+ 		 enum transcoder cpu_transcoder, bool state);
+ #define assert_pipe_enabled(d, t) assert_pipe(d, t, true)
+ #define assert_pipe_disabled(d, t) assert_pipe(d, t, false)
+ 
+ /* Use I915_STATE_WARN(x) and I915_STATE_WARN_ON() (rather than WARN() and
+  * WARN_ON()) for hw state sanity checks to check for unexpected conditions
+  * which may not necessarily be a user visible problem.  This will either
+  * WARN() or DRM_ERROR() depending on the verbose_checks moduleparam, to
+  * enable distros and users to tailor their preferred amount of i915 abrt
+  * spam.
+  */
+ #define I915_STATE_WARN(condition, format...) ({			\
+ 	int __ret_warn_on = !!(condition);				\
+ 	if (unlikely(__ret_warn_on))					\
+ 		if (!WARN(i915_modparams.verbose_state_checks, format))	\
+ 			DRM_ERROR(format);				\
+ 	unlikely(__ret_warn_on);					\
+ })
+ 
+ #define I915_STATE_WARN_ON(x)						\
+ 	I915_STATE_WARN((x), "%s", "WARN_ON(" __stringify(x) ")")
++>>>>>>> 93a0ed6cc164 (drm/i915: split intel_modeset_driver_remove() to pre/post irq uninstall)
  
  #endif
diff --cc drivers/gpu/drm/i915/i915_drv.c
index 1aa474313525,e85078eb7b7d..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@@ -751,47 -267,37 +751,60 @@@ static int i915_load_modeset_init(struc
  	return 0;
  
  cleanup_gem:
 -	i915_gem_suspend(i915);
 -	i915_gem_driver_remove(i915);
 -	i915_gem_driver_release(i915);
 +	i915_gem_suspend(dev_priv);
 +	i915_gem_fini_hw(dev_priv);
 +	i915_gem_fini(dev_priv);
  cleanup_modeset:
++<<<<<<< HEAD
 +	intel_modeset_cleanup(dev);
++=======
+ 	intel_modeset_driver_remove(i915);
+ 	intel_irq_uninstall(i915);
+ 	intel_modeset_driver_remove_noirq(i915);
+ 	goto cleanup_csr;
++>>>>>>> 93a0ed6cc164 (drm/i915: split intel_modeset_driver_remove() to pre/post irq uninstall)
  cleanup_irq:
 -	intel_irq_uninstall(i915);
 +	drm_irq_uninstall(dev);
 +	intel_gmbus_teardown(dev_priv);
  cleanup_csr:
 -	intel_csr_ucode_fini(i915);
 -	intel_power_domains_driver_remove(i915);
 -	intel_vga_unregister(i915);
 +	intel_csr_ucode_fini(dev_priv);
 +	intel_power_domains_fini_hw(dev_priv);
 +	vga_switcheroo_unregister_client(pdev);
 +cleanup_vga_client:
 +	vga_client_register(pdev, NULL, NULL, NULL);
  out:
  	return ret;
  }
  
 -static void i915_driver_modeset_remove(struct drm_i915_private *i915)
 +static int i915_kick_out_firmware_fb(struct drm_i915_private *dev_priv)
  {
 -	intel_modeset_driver_remove(i915);
 +	struct apertures_struct *ap;
 +	struct pci_dev *pdev = dev_priv->drm.pdev;
 +	struct i915_ggtt *ggtt = &dev_priv->ggtt;
 +	bool primary;
 +	int ret;
  
 -	intel_irq_uninstall(i915);
 +	ap = alloc_apertures(1);
 +	if (!ap)
 +		return -ENOMEM;
  
++<<<<<<< HEAD
 +	ap->ranges[0].base = ggtt->gmadr.start;
 +	ap->ranges[0].size = ggtt->mappable_end;
++=======
+ 	intel_modeset_driver_remove_noirq(i915);
+ 
+ 	intel_bios_driver_remove(i915);
++>>>>>>> 93a0ed6cc164 (drm/i915: split intel_modeset_driver_remove() to pre/post irq uninstall)
  
 -	intel_vga_unregister(i915);
 +	primary =
 +		pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
  
 -	intel_csr_ucode_fini(i915);
 +	ret = drm_fb_helper_remove_conflicting_framebuffers(ap, "inteldrmfb", primary);
 +
 +	kfree(ap);
 +
 +	return ret;
  }
  
  static void intel_init_dpio(struct drm_i915_private *dev_priv)
* Unmerged path drivers/gpu/drm/i915/display/intel_display.c
* Unmerged path drivers/gpu/drm/i915/display/intel_display.h
* Unmerged path drivers/gpu/drm/i915/i915_drv.c
