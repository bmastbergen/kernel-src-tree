mlxsw: spectrum_router: Set hardware flags for routes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ido Schimmel <idosch@mellanox.com>
commit ee5a0448e72b0857260e04f68126b2bfa27c154e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ee5a0448.failed

Previous patches added support for two hardware flags for IPv4 and IPv6
routes: 'RTM_F_OFFLOAD' and 'RTM_F_TRAP'. Both indicate the presence of
the route in hardware. The first indicates that traffic is actually
offloaded from the kernel, whereas the second indicates that packets
hitting such routes are trapped to the kernel for processing (e.g., host
routes).

Use these two flags in mlxsw. The flags are modified in two places.
Firstly, whenever a route is updated in the device's table. This
includes the addition, deletion or update of a route. For example, when
a host route is promoted to perform NVE decapsulation, its action in the
device is updated, the 'RTM_F_OFFLOAD' flag set and the 'RTM_F_TRAP'
flag cleared.

Secondly, when a route is replaced and overwritten by another route, its
flags are cleared.

v2:
* Convert to new fib_alias_hw_flags_set() interface

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ee5a0448e72b0857260e04f68126b2bfa27c154e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index dbb3091602fe,a014bd8d504d..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -4102,43 -4096,71 +4102,101 @@@ mlxsw_sp_rt6_nexthop(struct mlxsw_sp_ne
  }
  
  static void
- mlxsw_sp_fib4_entry_offload_set(struct mlxsw_sp_fib_entry *fib_entry)
+ mlxsw_sp_fib4_entry_hw_flags_set(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_fib_entry *fib_entry)
  {
- 	struct mlxsw_sp_nexthop_group *nh_grp = fib_entry->nh_group;
- 	int i;
+ 	struct fib_info *fi = mlxsw_sp_nexthop4_group_fi(fib_entry->nh_group);
+ 	u32 *p_dst = (u32 *) fib_entry->fib_node->key.addr;
+ 	int dst_len = fib_entry->fib_node->key.prefix_len;
+ 	struct mlxsw_sp_fib4_entry *fib4_entry;
+ 	struct fib_rt_info fri;
+ 	bool should_offload;
  
++<<<<<<< HEAD
 +	if (fib_entry->type == MLXSW_SP_FIB_ENTRY_TYPE_LOCAL ||
 +	    fib_entry->type == MLXSW_SP_FIB_ENTRY_TYPE_BLACKHOLE ||
 +	    fib_entry->type == MLXSW_SP_FIB_ENTRY_TYPE_IPIP_DECAP ||
 +	    fib_entry->type == MLXSW_SP_FIB_ENTRY_TYPE_NVE_DECAP) {
 +		nh_grp->nexthops->key.fib_nh->nh_flags |= RTNH_F_OFFLOAD;
 +		return;
 +	}
 +
 +	for (i = 0; i < nh_grp->count; i++) {
 +		struct mlxsw_sp_nexthop *nh = &nh_grp->nexthops[i];
 +
 +		if (nh->offloaded)
 +			nh->key.fib_nh->nh_flags |= RTNH_F_OFFLOAD;
 +		else
 +			nh->key.fib_nh->nh_flags &= ~RTNH_F_OFFLOAD;
 +	}
++=======
+ 	should_offload = mlxsw_sp_fib_entry_should_offload(fib_entry);
+ 	fib4_entry = container_of(fib_entry, struct mlxsw_sp_fib4_entry,
+ 				  common);
+ 	fri.fi = fi;
+ 	fri.tb_id = fib4_entry->tb_id;
+ 	fri.dst = cpu_to_be32(*p_dst);
+ 	fri.dst_len = dst_len;
+ 	fri.tos = fib4_entry->tos;
+ 	fri.type = fib4_entry->type;
+ 	fri.offload = should_offload;
+ 	fri.trap = !should_offload;
+ 	fib_alias_hw_flags_set(mlxsw_sp_net(mlxsw_sp), &fri);
++>>>>>>> ee5a0448e72b (mlxsw: spectrum_router: Set hardware flags for routes)
  }
  
  static void
- mlxsw_sp_fib4_entry_offload_unset(struct mlxsw_sp_fib_entry *fib_entry)
+ mlxsw_sp_fib4_entry_hw_flags_clear(struct mlxsw_sp *mlxsw_sp,
+ 				   struct mlxsw_sp_fib_entry *fib_entry)
  {
- 	struct mlxsw_sp_nexthop_group *nh_grp = fib_entry->nh_group;
- 	int i;
+ 	struct fib_info *fi = mlxsw_sp_nexthop4_group_fi(fib_entry->nh_group);
+ 	u32 *p_dst = (u32 *) fib_entry->fib_node->key.addr;
+ 	int dst_len = fib_entry->fib_node->key.prefix_len;
+ 	struct mlxsw_sp_fib4_entry *fib4_entry;
+ 	struct fib_rt_info fri;
  
++<<<<<<< HEAD
 +	if (!list_is_singular(&nh_grp->fib_list))
 +		return;
 +
 +	for (i = 0; i < nh_grp->count; i++) {
 +		struct mlxsw_sp_nexthop *nh = &nh_grp->nexthops[i];
 +
 +		nh->key.fib_nh->nh_flags &= ~RTNH_F_OFFLOAD;
 +	}
++=======
+ 	fib4_entry = container_of(fib_entry, struct mlxsw_sp_fib4_entry,
+ 				  common);
+ 	fri.fi = fi;
+ 	fri.tb_id = fib4_entry->tb_id;
+ 	fri.dst = cpu_to_be32(*p_dst);
+ 	fri.dst_len = dst_len;
+ 	fri.tos = fib4_entry->tos;
+ 	fri.type = fib4_entry->type;
+ 	fri.offload = false;
+ 	fri.trap = false;
+ 	fib_alias_hw_flags_set(mlxsw_sp_net(mlxsw_sp), &fri);
++>>>>>>> ee5a0448e72b (mlxsw: spectrum_router: Set hardware flags for routes)
+ }
+ 
+ static void
+ mlxsw_sp_fib6_entry_hw_flags_set(struct mlxsw_sp *mlxsw_sp,
+ 				 struct mlxsw_sp_fib_entry *fib_entry)
+ {
+ 	struct mlxsw_sp_fib6_entry *fib6_entry;
+ 	struct mlxsw_sp_rt6 *mlxsw_sp_rt6;
+ 	bool should_offload;
+ 
+ 	should_offload = mlxsw_sp_fib_entry_should_offload(fib_entry);
+ 
+ 	/* In IPv6 a multipath route is represented using multiple routes, so
+ 	 * we need to set the flags on all of them.
+ 	 */
+ 	fib6_entry = container_of(fib_entry, struct mlxsw_sp_fib6_entry,
+ 				  common);
+ 	list_for_each_entry(mlxsw_sp_rt6, &fib6_entry->rt6_list, list)
+ 		fib6_info_hw_flags_set(mlxsw_sp_rt6->rt, should_offload,
+ 				       !should_offload);
  }
  
  static void
@@@ -4149,42 -4172,13 +4208,52 @@@ mlxsw_sp_fib6_entry_hw_flags_clear(stru
  
  	fib6_entry = container_of(fib_entry, struct mlxsw_sp_fib6_entry,
  				  common);
++<<<<<<< HEAD
 +
 +	if (fib_entry->type == MLXSW_SP_FIB_ENTRY_TYPE_LOCAL ||
 +	    fib_entry->type == MLXSW_SP_FIB_ENTRY_TYPE_BLACKHOLE) {
 +		list_first_entry(&fib6_entry->rt6_list, struct mlxsw_sp_rt6,
 +				 list)->rt->fib6_nh.nh_flags |= RTNH_F_OFFLOAD;
 +		return;
 +	}
 +
 +	list_for_each_entry(mlxsw_sp_rt6, &fib6_entry->rt6_list, list) {
 +		struct mlxsw_sp_nexthop_group *nh_grp = fib_entry->nh_group;
 +		struct mlxsw_sp_nexthop *nh;
 +
 +		nh = mlxsw_sp_rt6_nexthop(nh_grp, mlxsw_sp_rt6);
 +		if (nh && nh->offloaded)
 +			mlxsw_sp_rt6->rt->fib6_nh.nh_flags |= RTNH_F_OFFLOAD;
 +		else
 +			mlxsw_sp_rt6->rt->fib6_nh.nh_flags &= ~RTNH_F_OFFLOAD;
 +	}
 +}
 +
 +static void
 +mlxsw_sp_fib6_entry_offload_unset(struct mlxsw_sp_fib_entry *fib_entry)
 +{
 +	struct mlxsw_sp_fib6_entry *fib6_entry;
 +	struct mlxsw_sp_rt6 *mlxsw_sp_rt6;
 +
 +	fib6_entry = container_of(fib_entry, struct mlxsw_sp_fib6_entry,
 +				  common);
 +	list_for_each_entry(mlxsw_sp_rt6, &fib6_entry->rt6_list, list) {
 +		struct fib6_info *rt = mlxsw_sp_rt6->rt;
 +
 +		rt->fib6_nh.nh_flags &= ~RTNH_F_OFFLOAD;
 +	}
 +}
 +
 +static void mlxsw_sp_fib_entry_offload_set(struct mlxsw_sp_fib_entry *fib_entry)
++=======
+ 	list_for_each_entry(mlxsw_sp_rt6, &fib6_entry->rt6_list, list)
+ 		fib6_info_hw_flags_set(mlxsw_sp_rt6->rt, false, false);
+ }
+ 
+ static void
+ mlxsw_sp_fib_entry_hw_flags_set(struct mlxsw_sp *mlxsw_sp,
+ 				struct mlxsw_sp_fib_entry *fib_entry)
++>>>>>>> ee5a0448e72b (mlxsw: spectrum_router: Set hardware flags for routes)
  {
  	switch (fib_entry->fib_node->fib->proto) {
  	case MLXSW_SP_L3_PROTO_IPV4:
@@@ -4931,13 -4872,21 +5001,24 @@@ mlxsw_sp_router_fib4_replace(struct mlx
  		goto err_fib4_entry_create;
  	}
  
 -	replaced = fib_node->fib_entry;
 -	err = mlxsw_sp_fib_node_entry_link(mlxsw_sp, &fib4_entry->common);
 +	err = mlxsw_sp_fib4_node_entry_link(mlxsw_sp, fib4_entry);
  	if (err) {
  		dev_warn(mlxsw_sp->bus_info->dev, "Failed to link FIB entry to node\n");
 -		goto err_fib_node_entry_link;
 +		goto err_fib4_node_entry_link;
  	}
  
++<<<<<<< HEAD
 +	mlxsw_sp_fib4_entry_replace(mlxsw_sp, fib4_entry);
++=======
+ 	/* Nothing to replace */
+ 	if (!replaced)
+ 		return 0;
+ 
+ 	mlxsw_sp_fib_entry_hw_flags_clear(mlxsw_sp, replaced);
+ 	fib4_replaced = container_of(replaced, struct mlxsw_sp_fib4_entry,
+ 				     common);
+ 	mlxsw_sp_fib4_entry_destroy(mlxsw_sp, fib4_replaced);
++>>>>>>> ee5a0448e72b (mlxsw: spectrum_router: Set hardware flags for routes)
  
  	return 0;
  
@@@ -5595,26 -5408,67 +5676,67 @@@ mlxsw_sp_fib6_entry_lookup(struct mlxsw
  	return NULL;
  }
  
 -static int mlxsw_sp_router_fib6_replace(struct mlxsw_sp *mlxsw_sp,
 -					struct fib6_info **rt_arr,
 -					unsigned int nrt6)
 +static void mlxsw_sp_fib6_entry_replace(struct mlxsw_sp *mlxsw_sp,
 +					struct mlxsw_sp_fib6_entry *fib6_entry,
 +					bool replace)
  {
 -	struct mlxsw_sp_fib6_entry *fib6_entry, *fib6_replaced;
 -	struct mlxsw_sp_fib_entry *replaced;
 -	struct mlxsw_sp_fib_node *fib_node;
 -	struct fib6_info *rt = rt_arr[0];
 -	int err;
 +	struct mlxsw_sp_fib_node *fib_node = fib6_entry->common.fib_node;
 +	struct mlxsw_sp_fib6_entry *replaced;
  
 -	if (mlxsw_sp->router->aborted)
 -		return 0;
 +	if (!replace)
 +		return;
  
 -	if (rt->fib6_src.plen)
 -		return -EINVAL;
 +	replaced = list_next_entry(fib6_entry, common.list);
  
++<<<<<<< HEAD
 +	mlxsw_sp_fib6_node_entry_unlink(mlxsw_sp, replaced);
 +	mlxsw_sp_fib6_entry_destroy(mlxsw_sp, replaced);
++=======
+ 	if (mlxsw_sp_fib6_rt_should_ignore(rt))
+ 		return 0;
+ 
+ 	fib_node = mlxsw_sp_fib_node_get(mlxsw_sp, rt->fib6_table->tb6_id,
+ 					 &rt->fib6_dst.addr,
+ 					 sizeof(rt->fib6_dst.addr),
+ 					 rt->fib6_dst.plen,
+ 					 MLXSW_SP_L3_PROTO_IPV6);
+ 	if (IS_ERR(fib_node))
+ 		return PTR_ERR(fib_node);
+ 
+ 	fib6_entry = mlxsw_sp_fib6_entry_create(mlxsw_sp, fib_node, rt_arr,
+ 						nrt6);
+ 	if (IS_ERR(fib6_entry)) {
+ 		err = PTR_ERR(fib6_entry);
+ 		goto err_fib6_entry_create;
+ 	}
+ 
+ 	replaced = fib_node->fib_entry;
+ 	err = mlxsw_sp_fib_node_entry_link(mlxsw_sp, &fib6_entry->common);
+ 	if (err)
+ 		goto err_fib_node_entry_link;
+ 
+ 	/* Nothing to replace */
+ 	if (!replaced)
+ 		return 0;
+ 
+ 	mlxsw_sp_fib_entry_hw_flags_clear(mlxsw_sp, replaced);
+ 	fib6_replaced = container_of(replaced, struct mlxsw_sp_fib6_entry,
+ 				     common);
+ 	mlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_replaced);
+ 
+ 	return 0;
+ 
+ err_fib_node_entry_link:
+ 	fib_node->fib_entry = replaced;
+ 	mlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_entry);
+ err_fib6_entry_create:
++>>>>>>> ee5a0448e72b (mlxsw: spectrum_router: Set hardware flags for routes)
  	mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
 -	return err;
  }
  
 -static int mlxsw_sp_router_fib6_append(struct mlxsw_sp *mlxsw_sp,
 -				       struct fib6_info **rt_arr,
 -				       unsigned int nrt6)
 +static int mlxsw_sp_router_fib6_add(struct mlxsw_sp *mlxsw_sp,
 +				    struct fib6_info **rt_arr,
 +				    unsigned int nrt6, bool replace)
  {
  	struct mlxsw_sp_fib6_entry *fib6_entry;
  	struct mlxsw_sp_fib_node *fib_node;
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
