netfilter: flowtable: Free block_cb when being deleted

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Roi Dayan <roid@mellanox.com>
commit bc8e71314e8444c6315c482441f3204c032ab327
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/bc8e7131.failed

Free block_cb memory when asked to be deleted.

Fixes: 978703f42549 ("netfilter: flowtable: Add API for registering to flow table events")
	Signed-off-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Paul Blakey <paulb@mellanox.com>
	Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit bc8e71314e8444c6315c482441f3204c032ab327)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_flow_table_core.c
diff --cc net/netfilter/nf_flow_table_core.c
index b5916ad46e76,4344e572b7f9..000000000000
--- a/net/netfilter/nf_flow_table_core.c
+++ b/net/netfilter/nf_flow_table_core.c
@@@ -362,6 -385,52 +362,55 @@@ static void nf_flow_offload_work_gc(str
  	queue_delayed_work(system_power_efficient_wq, &flow_table->gc_work, HZ);
  }
  
++<<<<<<< HEAD
++=======
+ int nf_flow_table_offload_add_cb(struct nf_flowtable *flow_table,
+ 				 flow_setup_cb_t *cb, void *cb_priv)
+ {
+ 	struct flow_block *block = &flow_table->flow_block;
+ 	struct flow_block_cb *block_cb;
+ 	int err = 0;
+ 
+ 	down_write(&flow_table->flow_block_lock);
+ 	block_cb = flow_block_cb_lookup(block, cb, cb_priv);
+ 	if (block_cb) {
+ 		err = -EEXIST;
+ 		goto unlock;
+ 	}
+ 
+ 	block_cb = flow_block_cb_alloc(cb, cb_priv, cb_priv, NULL);
+ 	if (IS_ERR(block_cb)) {
+ 		err = PTR_ERR(block_cb);
+ 		goto unlock;
+ 	}
+ 
+ 	list_add_tail(&block_cb->list, &block->cb_list);
+ 
+ unlock:
+ 	up_write(&flow_table->flow_block_lock);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(nf_flow_table_offload_add_cb);
+ 
+ void nf_flow_table_offload_del_cb(struct nf_flowtable *flow_table,
+ 				  flow_setup_cb_t *cb, void *cb_priv)
+ {
+ 	struct flow_block *block = &flow_table->flow_block;
+ 	struct flow_block_cb *block_cb;
+ 
+ 	down_write(&flow_table->flow_block_lock);
+ 	block_cb = flow_block_cb_lookup(block, cb, cb_priv);
+ 	if (block_cb) {
+ 		list_del(&block_cb->list);
+ 		flow_block_cb_free(block_cb);
+ 	} else {
+ 		WARN_ON(true);
+ 	}
+ 	up_write(&flow_table->flow_block_lock);
+ }
+ EXPORT_SYMBOL_GPL(nf_flow_table_offload_del_cb);
+ 
++>>>>>>> bc8e71314e84 (netfilter: flowtable: Free block_cb when being deleted)
  static int nf_flow_nat_port_tcp(struct sk_buff *skb, unsigned int thoff,
  				__be16 port, __be16 new_port)
  {
* Unmerged path net/netfilter/nf_flow_table_core.c
