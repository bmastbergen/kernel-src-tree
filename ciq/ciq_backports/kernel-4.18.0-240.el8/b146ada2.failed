mm: nobootmem: remove dead code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mike Rapoport <rppt@linux.vnet.ibm.com>
commit b146ada221c178a384fee2a8e2e5b2e8a04476b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b146ada2.failed

Several bootmem functions and macros are not used. Remove them.

Link: http://lkml.kernel.org/r/1536927045-23536-6-git-send-email-rppt@linux.vnet.ibm.com
	Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Chris Zankel <chris@zankel.net>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Geert Uytterhoeven <geert@linux-m68k.org>
	Cc: Greentime Hu <green.hu@gmail.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Guan Xuetao <gxt@pku.edu.cn>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
	Cc: Jonas Bonn <jonas@southpole.se>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Ley Foon Tan <lftan@altera.com>
	Cc: Mark Salter <msalter@redhat.com>
	Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Cc: Matt Turner <mattst88@gmail.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Michal Simek <monstr@monstr.eu>
	Cc: Palmer Dabbelt <palmer@sifive.com>
	Cc: Paul Burton <paul.burton@mips.com>
	Cc: Richard Kuo <rkuo@codeaurora.org>
	Cc: Richard Weinberger <richard@nod.at>
	Cc: Rich Felker <dalias@libc.org>
	Cc: Russell King <linux@armlinux.org.uk>
	Cc: Serge Semin <fancer.lancer@gmail.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Vineet Gupta <vgupta@synopsys.com>
	Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit b146ada221c178a384fee2a8e2e5b2e8a04476b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bootmem.h
diff --cc include/linux/bootmem.h
index 42515195d7d8,b74bafd110b9..000000000000
--- a/include/linux/bootmem.h
+++ b/include/linux/bootmem.h
@@@ -72,25 -36,6 +72,28 @@@ extern void free_bootmem_node(pg_data_
  extern void free_bootmem(unsigned long physaddr, unsigned long size);
  extern void free_bootmem_late(unsigned long physaddr, unsigned long size);
  
++<<<<<<< HEAD
 +/*
 + * Flags for reserve_bootmem (also if CONFIG_HAVE_ARCH_BOOTMEM_NODE,
 + * the architecture-specific code should honor this).
 + *
 + * If flags is BOOTMEM_DEFAULT, then the return value is always 0 (success).
 + * If flags contains BOOTMEM_EXCLUSIVE, then -EBUSY is returned if the memory
 + * already was reserved.
 + */
 +#define BOOTMEM_DEFAULT		0
 +#define BOOTMEM_EXCLUSIVE	(1<<0)
 +
 +extern int reserve_bootmem(unsigned long addr,
 +			   unsigned long size,
 +			   int flags);
 +extern int reserve_bootmem_node(pg_data_t *pgdat,
 +				unsigned long physaddr,
 +				unsigned long size,
 +				int flags);
 +
++=======
++>>>>>>> b146ada221c1 (mm: nobootmem: remove dead code)
  extern void *__alloc_bootmem(unsigned long size,
  			     unsigned long align,
  			     unsigned long goal);
@@@ -117,20 -62,9 +120,13 @@@ void *___alloc_bootmem_node_nopanic(pg_
  extern void *__alloc_bootmem_low(unsigned long size,
  				 unsigned long align,
  				 unsigned long goal) __malloc;
- void *__alloc_bootmem_low_nopanic(unsigned long size,
- 				 unsigned long align,
- 				 unsigned long goal) __malloc;
- extern void *__alloc_bootmem_low_node(pg_data_t *pgdat,
- 				      unsigned long size,
- 				      unsigned long align,
- 				      unsigned long goal) __malloc;
  
 +#ifdef CONFIG_NO_BOOTMEM
  /* We are using top down, so it is safe to use 0 here */
  #define BOOTMEM_LOW_LIMIT 0
 +#else
 +#define BOOTMEM_LOW_LIMIT __pa(MAX_DMA_ADDRESS)
 +#endif
  
  #ifndef ARCH_LOW_ADDRESS_LIMIT
  #define ARCH_LOW_ADDRESS_LIMIT  0xffffffffUL
@@@ -155,18 -87,9 +149,12 @@@
  
  #define alloc_bootmem_low(x) \
  	__alloc_bootmem_low(x, SMP_CACHE_BYTES, 0)
- #define alloc_bootmem_low_pages_nopanic(x) \
- 	__alloc_bootmem_low_nopanic(x, PAGE_SIZE, 0)
  #define alloc_bootmem_low_pages(x) \
  	__alloc_bootmem_low(x, PAGE_SIZE, 0)
- #define alloc_bootmem_low_pages_node(pgdat, x) \
- 	__alloc_bootmem_low_node(pgdat, x, PAGE_SIZE, 0)
  
 +
 +#if defined(CONFIG_HAVE_MEMBLOCK) && defined(CONFIG_NO_BOOTMEM)
 +
  /* FIXME: use MEMBLOCK_ALLOC_* variants here */
  #define BOOTMEM_ALLOC_ACCESSIBLE	0
  #define BOOTMEM_ALLOC_ANYWHERE		(~(phys_addr_t)0)
* Unmerged path include/linux/bootmem.h
diff --git a/mm/nobootmem.c b/mm/nobootmem.c
index 439af3b765a7..9246d4202b80 100644
--- a/mm/nobootmem.c
+++ b/mm/nobootmem.c
@@ -408,38 +408,3 @@ void * __init __alloc_bootmem_low(unsigned long size, unsigned long align,
 {
 	return ___alloc_bootmem(size, align, goal, ARCH_LOW_ADDRESS_LIMIT);
 }
-
-void * __init __alloc_bootmem_low_nopanic(unsigned long size,
-					  unsigned long align,
-					  unsigned long goal)
-{
-	return ___alloc_bootmem_nopanic(size, align, goal,
-					ARCH_LOW_ADDRESS_LIMIT);
-}
-
-/**
- * __alloc_bootmem_low_node - allocate low boot memory from a specific node
- * @pgdat: node to allocate from
- * @size: size of the request in bytes
- * @align: alignment of the region
- * @goal: preferred starting address of the region
- *
- * The goal is dropped if it can not be satisfied and the allocation will
- * fall back to memory below @goal.
- *
- * Allocation may fall back to any node in the system if the specified node
- * can not hold the requested memory.
- *
- * The function panics if the request can not be satisfied.
- *
- * Return: address of the allocated region.
- */
-void * __init __alloc_bootmem_low_node(pg_data_t *pgdat, unsigned long size,
-				       unsigned long align, unsigned long goal)
-{
-	if (WARN_ON_ONCE(slab_is_available()))
-		return kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);
-
-	return ___alloc_bootmem_node(pgdat, size, align, goal,
-				     ARCH_LOW_ADDRESS_LIMIT);
-}
