netfilter: nf_tables: store data in offload context registers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 43dd16efc7f235f153804500a4363769bd2276fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/43dd16ef.failed

Store immediate data into offload context register. This allows follow
up instructions to take it from the corresponding source register.

This patch is required to support for payload mangling, although other
instructions that take data from source register will benefit from this
too.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 43dd16efc7f235f153804500a4363769bd2276fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_tables_offload.h
#	net/netfilter/nft_immediate.c
diff --cc net/netfilter/nft_immediate.c
index 3f6d1d2a6281,c7f0ef73d939..000000000000
--- a/net/netfilter/nft_immediate.c
+++ b/net/netfilter/nft_immediate.c
@@@ -127,6 -125,44 +127,47 @@@ static int nft_immediate_validate(cons
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int nft_immediate_offload_verdict(struct nft_offload_ctx *ctx,
+ 					 struct nft_flow_rule *flow,
+ 					 const struct nft_immediate_expr *priv)
+ {
+ 	struct flow_action_entry *entry;
+ 	const struct nft_data *data;
+ 
+ 	entry = &flow->rule->action.entries[ctx->num_actions++];
+ 
+ 	data = &priv->data;
+ 	switch (data->verdict.code) {
+ 	case NF_ACCEPT:
+ 		entry->id = FLOW_ACTION_ACCEPT;
+ 		break;
+ 	case NF_DROP:
+ 		entry->id = FLOW_ACTION_DROP;
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int nft_immediate_offload(struct nft_offload_ctx *ctx,
+ 				 struct nft_flow_rule *flow,
+ 				 const struct nft_expr *expr)
+ {
+ 	const struct nft_immediate_expr *priv = nft_expr_priv(expr);
+ 
+ 	if (priv->dreg == NFT_REG_VERDICT)
+ 		return nft_immediate_offload_verdict(ctx, flow, priv);
+ 
+ 	memcpy(&ctx->regs[priv->dreg].data, &priv->data, sizeof(priv->data));
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 43dd16efc7f2 (netfilter: nf_tables: store data in offload context registers)
  static const struct nft_expr_ops nft_imm_ops = {
  	.type		= &nft_imm_type,
  	.size		= NFT_EXPR_SIZE(sizeof(struct nft_immediate_expr)),
* Unmerged path include/net/netfilter/nf_tables_offload.h
* Unmerged path include/net/netfilter/nf_tables_offload.h
* Unmerged path net/netfilter/nft_immediate.c
