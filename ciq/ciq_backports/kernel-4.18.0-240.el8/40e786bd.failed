netfilter: nat: fold in_range indirection into caller

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 40e786bd296d5517b1f6c4bcc9ed13e502606ced
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/40e786bd.failed

No need for indirections here, we only support ipv4 and ipv6
and the called functions are very small.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 40e786bd296d5517b1f6c4bcc9ed13e502606ced)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_nat_l3proto.h
#	net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
#	net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
diff --cc include/net/netfilter/nf_nat_l3proto.h
index d300b8f03972,1ce0980da638..000000000000
--- a/include/net/netfilter/nf_nat_l3proto.h
+++ b/include/net/netfilter/nf_nat_l3proto.h
@@@ -6,11 -6,6 +6,14 @@@ struct nf_nat_l4proto
  struct nf_nat_l3proto {
  	u8	l3proto;
  
++<<<<<<< HEAD
 +	bool	(*in_range)(const struct nf_conntrack_tuple *t,
 +			    const struct nf_nat_range2 *range);
 +
 +	u32 	(*secure_port)(const struct nf_conntrack_tuple *t, __be16);
 +
++=======
++>>>>>>> 40e786bd296d (netfilter: nat: fold in_range indirection into caller)
  	bool	(*manip_pkt)(struct sk_buff *skb,
  			     unsigned int iphdroff,
  			     const struct nf_nat_l4proto *l4proto,
diff --cc net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
index 78a67f961d86,00904e605e85..000000000000
--- a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
@@@ -62,19 -62,6 +62,22 @@@ static void nf_nat_ipv4_decode_session(
  }
  #endif /* CONFIG_XFRM */
  
++<<<<<<< HEAD
 +static bool nf_nat_ipv4_in_range(const struct nf_conntrack_tuple *t,
 +				 const struct nf_nat_range2 *range)
 +{
 +	return ntohl(t->src.u3.ip) >= ntohl(range->min_addr.ip) &&
 +	       ntohl(t->src.u3.ip) <= ntohl(range->max_addr.ip);
 +}
 +
 +static u32 nf_nat_ipv4_secure_port(const struct nf_conntrack_tuple *t,
 +				   __be16 dport)
 +{
 +	return secure_ipv4_port_ephemeral(t->src.u3.ip, t->dst.u3.ip, dport);
 +}
 +
++=======
++>>>>>>> 40e786bd296d (netfilter: nat: fold in_range indirection into caller)
  static bool nf_nat_ipv4_manip_pkt(struct sk_buff *skb,
  				  unsigned int iphdroff,
  				  const struct nf_nat_l4proto *l4proto,
@@@ -161,8 -148,6 +164,11 @@@ static int nf_nat_ipv4_nlattr_to_range(
  
  static const struct nf_nat_l3proto nf_nat_l3proto_ipv4 = {
  	.l3proto		= NFPROTO_IPV4,
++<<<<<<< HEAD
 +	.in_range		= nf_nat_ipv4_in_range,
 +	.secure_port		= nf_nat_ipv4_secure_port,
++=======
++>>>>>>> 40e786bd296d (netfilter: nat: fold in_range indirection into caller)
  	.manip_pkt		= nf_nat_ipv4_manip_pkt,
  	.csum_update		= nf_nat_ipv4_csum_update,
  	.csum_recalc		= nf_nat_ipv4_csum_recalc,
diff --cc net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
index 9a3e0cf4290a,016ab74ac1c6..000000000000
--- a/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
+++ b/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
@@@ -62,19 -61,6 +62,22 @@@ static void nf_nat_ipv6_decode_session(
  }
  #endif
  
++<<<<<<< HEAD
 +static bool nf_nat_ipv6_in_range(const struct nf_conntrack_tuple *t,
 +				 const struct nf_nat_range2 *range)
 +{
 +	return ipv6_addr_cmp(&t->src.u3.in6, &range->min_addr.in6) >= 0 &&
 +	       ipv6_addr_cmp(&t->src.u3.in6, &range->max_addr.in6) <= 0;
 +}
 +
 +static u32 nf_nat_ipv6_secure_port(const struct nf_conntrack_tuple *t,
 +				   __be16 dport)
 +{
 +	return secure_ipv6_port_ephemeral(t->src.u3.ip6, t->dst.u3.ip6, dport);
 +}
 +
++=======
++>>>>>>> 40e786bd296d (netfilter: nat: fold in_range indirection into caller)
  static bool nf_nat_ipv6_manip_pkt(struct sk_buff *skb,
  				  unsigned int iphdroff,
  				  const struct nf_nat_l4proto *l4proto,
@@@ -172,8 -158,6 +175,11 @@@ static int nf_nat_ipv6_nlattr_to_range(
  
  static const struct nf_nat_l3proto nf_nat_l3proto_ipv6 = {
  	.l3proto		= NFPROTO_IPV6,
++<<<<<<< HEAD
 +	.secure_port		= nf_nat_ipv6_secure_port,
 +	.in_range		= nf_nat_ipv6_in_range,
++=======
++>>>>>>> 40e786bd296d (netfilter: nat: fold in_range indirection into caller)
  	.manip_pkt		= nf_nat_ipv6_manip_pkt,
  	.csum_update		= nf_nat_ipv6_csum_update,
  	.csum_recalc		= nf_nat_ipv6_csum_recalc,
* Unmerged path include/net/netfilter/nf_nat_l3proto.h
* Unmerged path net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
diff --git a/net/netfilter/nf_nat_core.c b/net/netfilter/nf_nat_core.c
index 5e173f6800a4..b276d80c53ec 100644
--- a/net/netfilter/nf_nat_core.c
+++ b/net/netfilter/nf_nat_core.c
@@ -174,11 +174,21 @@ nf_nat_used_tuple(const struct nf_conntrack_tuple *tuple,
 }
 EXPORT_SYMBOL(nf_nat_used_tuple);
 
+static bool nf_nat_inet_in_range(const struct nf_conntrack_tuple *t,
+				 const struct nf_nat_range2 *range)
+{
+	if (t->src.l3num == NFPROTO_IPV4)
+		return ntohl(t->src.u3.ip) >= ntohl(range->min_addr.ip) &&
+		       ntohl(t->src.u3.ip) <= ntohl(range->max_addr.ip);
+
+	return ipv6_addr_cmp(&t->src.u3.in6, &range->min_addr.in6) >= 0 &&
+	       ipv6_addr_cmp(&t->src.u3.in6, &range->max_addr.in6) <= 0;
+}
+
 /* If we source map this tuple so reply looks like reply_tuple, will
  * that meet the constraints of range.
  */
-static int in_range(const struct nf_nat_l3proto *l3proto,
-		    const struct nf_nat_l4proto *l4proto,
+static int in_range(const struct nf_nat_l4proto *l4proto,
 		    const struct nf_conntrack_tuple *tuple,
 		    const struct nf_nat_range2 *range)
 {
@@ -186,7 +196,7 @@ static int in_range(const struct nf_nat_l3proto *l3proto,
 	 * range specified, otherwise let this drag us onto a new src IP.
 	 */
 	if (range->flags & NF_NAT_RANGE_MAP_IPS &&
-	    !l3proto->in_range(tuple, range))
+	    !nf_nat_inet_in_range(tuple, range))
 		return 0;
 
 	if (!(range->flags & NF_NAT_RANGE_PROTO_SPECIFIED) ||
@@ -213,7 +223,6 @@ same_src(const struct nf_conn *ct,
 static int
 find_appropriate_src(struct net *net,
 		     const struct nf_conntrack_zone *zone,
-		     const struct nf_nat_l3proto *l3proto,
 		     const struct nf_nat_l4proto *l4proto,
 		     const struct nf_conntrack_tuple *tuple,
 		     struct nf_conntrack_tuple *result,
@@ -231,7 +240,7 @@ find_appropriate_src(struct net *net,
 				       &ct->tuplehash[IP_CT_DIR_REPLY].tuple);
 			result->dst = tuple->dst;
 
-			if (in_range(l3proto, l4proto, result, range))
+			if (in_range(l4proto, result, range))
 				return 1;
 		}
 	}
@@ -348,12 +357,12 @@ get_unique_tuple(struct nf_conntrack_tuple *tuple,
 	if (maniptype == NF_NAT_MANIP_SRC &&
 	    !(range->flags & NF_NAT_RANGE_PROTO_RANDOM_ALL)) {
 		/* try the original tuple first */
-		if (in_range(l3proto, l4proto, orig_tuple, range)) {
+		if (in_range(l4proto, orig_tuple, range)) {
 			if (!nf_nat_used_tuple(orig_tuple, ct)) {
 				*tuple = *orig_tuple;
 				goto out;
 			}
-		} else if (find_appropriate_src(net, zone, l3proto, l4proto,
+		} else if (find_appropriate_src(net, zone, l4proto,
 						orig_tuple, tuple, range)) {
 			pr_debug("get_unique_tuple: Found current src map\n");
 			if (!nf_nat_used_tuple(tuple, ct))
