net: phylink: Add struct phylink_config to PHYLINK API

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ioana Ciornei <ioana.ciornei@nxp.com>
commit 44cc27e43fa3b8977373915a8e7f515a9d263343
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/44cc27e4.failed

The phylink_config structure will encapsulate a pointer to a struct
device and the operation type requested for this instance of PHYLINK.
This patch does not make any functional changes, it just transitions the
PHYLINK internals and all its users to the new API.

A pointer to a phylink_config structure will be passed to
phylink_create() instead of the net_device directly. Also, the same
phylink_config pointer will be passed back to all phylink_mac_ops
callbacks instead of the net_device. Using this mechanism, a PHYLINK
user can get the original net_device using a structure such as
'to_net_dev(config->dev)' or directly the structure containing the
phylink_config using a container_of call.

At the moment, only the PHYLINK_NETDEV is defined as a valid operation
type for PHYLINK. In this mode, a valid reference to a struct device
linked to the original net_device should be passed to PHYLINK through
the phylink_config structure.

This API changes is mainly driven by the necessity of adding a new
operation type in PHYLINK that disconnects the phy_device from the
net_device and also works when the net_device is lacking.

	Signed-off-by: Ioana Ciornei <ioana.ciornei@nxp.com>
	Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Reviewed-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
	Tested-by: Maxime Chevallier <maxime.chevallier@bootlin.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 44cc27e43fa3b8977373915a8e7f515a9d263343)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/networking/sfp-phylink.rst
#	drivers/net/ethernet/marvell/mvneta.c
#	drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
#	drivers/net/phy/phylink.c
#	include/net/dsa.h
diff --cc drivers/net/ethernet/marvell/mvneta.c
index e9e0d8fc3a1f,adbbcdde73e6..000000000000
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@@ -431,6 -437,8 +431,11 @@@ struct mvneta_port 
  	struct device_node *dn;
  	unsigned int tx_csum_limit;
  	struct phylink *phylink;
++<<<<<<< HEAD
++=======
+ 	struct phylink_config phylink_config;
+ 	struct phy *comphy;
++>>>>>>> 44cc27e43fa3 (net: phylink: Add struct phylink_config to PHYLINK API)
  
  	struct mvneta_bm *bm_priv;
  	struct mvneta_bm_pool *pool_long;
@@@ -3251,9 -3357,12 +3256,15 @@@ static int mvneta_set_mac_addr(struct n
  	return 0;
  }
  
- static void mvneta_validate(struct net_device *ndev, unsigned long *supported,
+ static void mvneta_validate(struct phylink_config *config,
+ 			    unsigned long *supported,
  			    struct phylink_link_state *state)
  {
++<<<<<<< HEAD
++=======
+ 	struct net_device *ndev = to_net_dev(config->dev);
+ 	struct mvneta_port *pp = netdev_priv(ndev);
++>>>>>>> 44cc27e43fa3 (net: phylink: Add struct phylink_config to PHYLINK API)
  	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
  
  	/* We only support QSGMII, SGMII, 802.3z and RGMII modes */
@@@ -3288,11 -3404,17 +3299,12 @@@
  		   __ETHTOOL_LINK_MODE_MASK_NBITS);
  	bitmap_and(state->advertising, state->advertising, mask,
  		   __ETHTOOL_LINK_MODE_MASK_NBITS);
 -
 -	/* We can only operate at 2500BaseX or 1000BaseX.  If requested
 -	 * to advertise both, only report advertising at 2500BaseX.
 -	 */
 -	phylink_helper_basex_speed(state);
  }
  
- static int mvneta_mac_link_state(struct net_device *ndev,
+ static int mvneta_mac_link_state(struct phylink_config *config,
  				 struct phylink_link_state *state)
  {
+ 	struct net_device *ndev = to_net_dev(config->dev);
  	struct mvneta_port *pp = netdev_priv(ndev);
  	u32 gmac_stat;
  
@@@ -4342,8 -4500,22 +4358,27 @@@ static int mvneta_probe(struct platform
  		goto err_free_irq;
  	}
  
++<<<<<<< HEAD
 +	phylink = phylink_create(dev, pdev->dev.fwnode, phy_mode,
 +				 &mvneta_phylink_ops);
++=======
+ 	comphy = devm_of_phy_get(&pdev->dev, dn, NULL);
+ 	if (comphy == ERR_PTR(-EPROBE_DEFER)) {
+ 		err = -EPROBE_DEFER;
+ 		goto err_free_irq;
+ 	} else if (IS_ERR(comphy)) {
+ 		comphy = NULL;
+ 	}
+ 
+ 	pp = netdev_priv(dev);
+ 	spin_lock_init(&pp->lock);
+ 
+ 	pp->phylink_config.dev = &dev->dev;
+ 	pp->phylink_config.type = PHYLINK_NETDEV;
+ 
+ 	phylink = phylink_create(&pp->phylink_config, pdev->dev.fwnode,
+ 				 phy_mode, &mvneta_phylink_ops);
++>>>>>>> 44cc27e43fa3 (net: phylink: Add struct phylink_config to PHYLINK API)
  	if (IS_ERR(phylink)) {
  		err = PTR_ERR(phylink);
  		goto err_free_irq;
@@@ -4355,9 -4527,8 +4390,7 @@@
  
  	dev->ethtool_ops = &mvneta_eth_tool_ops;
  
- 	pp = netdev_priv(dev);
- 	spin_lock_init(&pp->lock);
  	pp->phylink = phylink;
 -	pp->comphy = comphy;
  	pp->phy_interface = phy_mode;
  	pp->dn = dn;
  
diff --cc drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
index 0319ed9ef8b8,757f8e31645e..000000000000
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
@@@ -59,8 -56,10 +59,13 @@@ static struct 
  /* The prototype is added here to be used in start_dev when using ACPI. This
   * will be removed once phylink is used for all modes (dt+ACPI).
   */
- static void mvpp2_mac_config(struct net_device *dev, unsigned int mode,
+ static void mvpp2_mac_config(struct phylink_config *config, unsigned int mode,
  			     const struct phylink_link_state *state);
++<<<<<<< HEAD
++=======
+ static void mvpp2_mac_link_up(struct phylink_config *config, unsigned int mode,
+ 			      phy_interface_t interface, struct phy_device *phy);
++>>>>>>> 44cc27e43fa3 (net: phylink: Add struct phylink_config to PHYLINK API)
  
  /* Queue modes */
  #define MVPP2_QDIST_SINGLE_MODE	0
@@@ -3150,9 -3238,10 +3155,15 @@@ static void mvpp2_start_dev(struct mvpp
  		 */
  		struct phylink_link_state state = {
  			.interface = port->phy_interface,
 +			.link = 1,
  		};
++<<<<<<< HEAD
 +		mvpp2_mac_config(port->dev, MLO_AN_INBAND, &state);
++=======
+ 		mvpp2_mac_config(&port->phylink_config, MLO_AN_INBAND, &state);
+ 		mvpp2_mac_link_up(&port->phylink_config, MLO_AN_INBAND,
+ 				  port->phy_interface, NULL);
++>>>>>>> 44cc27e43fa3 (net: phylink: Add struct phylink_config to PHYLINK API)
  	}
  
  	netif_tx_start_all_queues(port->dev);
@@@ -4149,8 -4467,28 +4160,13 @@@ static void mvpp2_phylink_validate(stru
  				   unsigned long *supported,
  				   struct phylink_link_state *state)
  {
++<<<<<<< HEAD
++=======
+ 	struct mvpp2_port *port = container_of(config, struct mvpp2_port,
+ 					       phylink_config);
++>>>>>>> 44cc27e43fa3 (net: phylink: Add struct phylink_config to PHYLINK API)
  	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
  
 -	/* Invalid combinations */
 -	switch (state->interface) {
 -	case PHY_INTERFACE_MODE_10GKR:
 -	case PHY_INTERFACE_MODE_XAUI:
 -		if (port->gop_id != 0)
 -			goto empty_set;
 -		break;
 -	case PHY_INTERFACE_MODE_RGMII:
 -	case PHY_INTERFACE_MODE_RGMII_ID:
 -	case PHY_INTERFACE_MODE_RGMII_RXID:
 -	case PHY_INTERFACE_MODE_RGMII_TXID:
 -		if (port->priv->hw_version == MVPP22 && port->gop_id == 0)
 -			goto empty_set;
 -		break;
 -	default:
 -		break;
 -	}
 -
  	phylink_set(mask, Autoneg);
  	phylink_set_port_modes(mask);
  	phylink_set(mask, Pause);
@@@ -4257,20 -4612,16 +4274,26 @@@ static int mvpp2_phylink_mac_link_state
  	return 1;
  }
  
- static void mvpp2_mac_an_restart(struct net_device *dev)
+ static void mvpp2_mac_an_restart(struct phylink_config *config)
  {
++<<<<<<< HEAD
 +	struct mvpp2_port *port = netdev_priv(dev);
 +	u32 val;
++=======
+ 	struct mvpp2_port *port = container_of(config, struct mvpp2_port,
+ 					       phylink_config);
+ 	u32 val = readl(port->base + MVPP2_GMAC_AUTONEG_CONFIG);
++>>>>>>> 44cc27e43fa3 (net: phylink: Add struct phylink_config to PHYLINK API)
  
 -	writel(val | MVPP2_GMAC_IN_BAND_RESTART_AN,
 -	       port->base + MVPP2_GMAC_AUTONEG_CONFIG);
 -	writel(val & ~MVPP2_GMAC_IN_BAND_RESTART_AN,
 -	       port->base + MVPP2_GMAC_AUTONEG_CONFIG);
 +	if (port->phy_interface != PHY_INTERFACE_MODE_SGMII)
 +		return;
 +
 +	val = readl(port->base + MVPP2_GMAC_AUTONEG_CONFIG);
 +	/* The RESTART_AN bit is cleared by the h/w after restarting the AN
 +	 * process.
 +	 */
 +	val |= MVPP2_GMAC_IN_BAND_RESTART_AN | MVPP2_GMAC_IN_BAND_AUTONEG;
 +	writel(val, port->base + MVPP2_GMAC_AUTONEG_CONFIG);
  }
  
  static void mvpp2_xlg_config(struct mvpp2_port *port, unsigned int mode,
@@@ -4358,33 -4725,90 +4381,34 @@@ static void mvpp2_gmac_config(struct mv
  			ctrl4 |= MVPP22_CTRL4_TX_FC_EN;
  		if (state->pause & MLO_PAUSE_RX)
  			ctrl4 |= MVPP22_CTRL4_RX_FC_EN;
 -	} else if (state->interface == PHY_INTERFACE_MODE_SGMII) {
 -		/* SGMII in-band mode receives the speed and duplex from
 -		 * the PHY. Flow control information is not received. */
 -		an &= ~(MVPP2_GMAC_FORCE_LINK_DOWN | MVPP2_GMAC_FORCE_LINK_PASS);
 -		an |= MVPP2_GMAC_IN_BAND_AUTONEG |
 -		      MVPP2_GMAC_AN_SPEED_EN |
 -		      MVPP2_GMAC_AN_DUPLEX_EN;
 +	} else if (phy_interface_mode_is_rgmii(state->interface)) {
 +		an |= MVPP2_GMAC_IN_BAND_AUTONEG_BYPASS;
  
 -		if (state->pause & MLO_PAUSE_TX)
 -			ctrl4 |= MVPP22_CTRL4_TX_FC_EN;
 -		if (state->pause & MLO_PAUSE_RX)
 -			ctrl4 |= MVPP22_CTRL4_RX_FC_EN;
 -	} else if (phy_interface_mode_is_8023z(state->interface)) {
 -		/* 1000BaseX and 2500BaseX ports cannot negotiate speed nor can
 -		 * they negotiate duplex: they are always operating with a fixed
 -		 * speed of 1000/2500Mbps in full duplex, so force 1000/2500
 -		 * speed and full duplex here.
 -		 */
 -		ctrl0 |= MVPP2_GMAC_PORT_TYPE_MASK;
 -		an &= ~(MVPP2_GMAC_FORCE_LINK_DOWN | MVPP2_GMAC_FORCE_LINK_PASS);
 -		an |= MVPP2_GMAC_IN_BAND_AUTONEG |
 -		      MVPP2_GMAC_CONFIG_GMII_SPEED |
 -		      MVPP2_GMAC_CONFIG_FULL_DUPLEX;
 +		if (state->speed == SPEED_1000)
 +			an |= MVPP2_GMAC_CONFIG_GMII_SPEED;
 +		else if (state->speed == SPEED_100)
 +			an |= MVPP2_GMAC_CONFIG_MII_SPEED;
  
 -		if (state->pause & MLO_PAUSE_AN && state->an_enabled) {
 -			an |= MVPP2_GMAC_FLOW_CTRL_AUTONEG;
 -		} else {
 -			if (state->pause & MLO_PAUSE_TX)
 -				ctrl4 |= MVPP22_CTRL4_TX_FC_EN;
 -			if (state->pause & MLO_PAUSE_RX)
 -				ctrl4 |= MVPP22_CTRL4_RX_FC_EN;
 -		}
 +		ctrl4 &= ~MVPP22_CTRL4_DP_CLK_SEL;
 +		ctrl4 |= MVPP22_CTRL4_EXT_PIN_GMII_SEL |
 +			 MVPP22_CTRL4_SYNC_BYPASS_DIS |
 +			 MVPP22_CTRL4_QSGMII_BYPASS_ACTIVE;
  	}
  
 -/* Some fields of the auto-negotiation register require the port to be down when
 - * their value is updated.
 - */
 -#define MVPP2_GMAC_AN_PORT_DOWN_MASK	\
 -		(MVPP2_GMAC_IN_BAND_AUTONEG | \
 -		 MVPP2_GMAC_IN_BAND_AUTONEG_BYPASS | \
 -		 MVPP2_GMAC_CONFIG_MII_SPEED | MVPP2_GMAC_CONFIG_GMII_SPEED | \
 -		 MVPP2_GMAC_AN_SPEED_EN | MVPP2_GMAC_CONFIG_FULL_DUPLEX | \
 -		 MVPP2_GMAC_AN_DUPLEX_EN)
 -
 -	if ((old_ctrl0 ^ ctrl0) & MVPP2_GMAC_PORT_TYPE_MASK ||
 -	    (old_ctrl2 ^ ctrl2) & MVPP2_GMAC_INBAND_AN_MASK ||
 -	    (old_an ^ an) & MVPP2_GMAC_AN_PORT_DOWN_MASK) {
 -		/* Force link down */
 -		old_an &= ~MVPP2_GMAC_FORCE_LINK_PASS;
 -		old_an |= MVPP2_GMAC_FORCE_LINK_DOWN;
 -		writel(old_an, port->base + MVPP2_GMAC_AUTONEG_CONFIG);
 -
 -		/* Set the GMAC in a reset state - do this in a way that
 -		 * ensures we clear it below.
 -		 */
 -		old_ctrl2 |= MVPP2_GMAC_PORT_RESET_MASK;
 -		writel(old_ctrl2, port->base + MVPP2_GMAC_CTRL_2_REG);
 -	}
 -
 -	if (old_ctrl0 != ctrl0)
 -		writel(ctrl0, port->base + MVPP2_GMAC_CTRL_0_REG);
 -	if (old_ctrl2 != ctrl2)
 -		writel(ctrl2, port->base + MVPP2_GMAC_CTRL_2_REG);
 -	if (old_ctrl4 != ctrl4)
 -		writel(ctrl4, port->base + MVPP22_GMAC_CTRL_4_REG);
 -	if (old_an != an)
 -		writel(an, port->base + MVPP2_GMAC_AUTONEG_CONFIG);
 -
 -	if (old_ctrl2 & MVPP2_GMAC_PORT_RESET_MASK) {
 -		while (readl(port->base + MVPP2_GMAC_CTRL_2_REG) &
 -		       MVPP2_GMAC_PORT_RESET_MASK)
 -			continue;
 -	}
 +	writel(ctrl0, port->base + MVPP2_GMAC_CTRL_0_REG);
 +	writel(ctrl2, port->base + MVPP2_GMAC_CTRL_2_REG);
 +	writel(ctrl4, port->base + MVPP22_GMAC_CTRL_4_REG);
 +	writel(an, port->base + MVPP2_GMAC_AUTONEG_CONFIG);
  }
  
- static void mvpp2_mac_config(struct net_device *dev, unsigned int mode,
+ static void mvpp2_mac_config(struct phylink_config *config, unsigned int mode,
  			     const struct phylink_link_state *state)
  {
+ 	struct net_device *dev = to_net_dev(config->dev);
  	struct mvpp2_port *port = netdev_priv(dev);
 -	bool change_interface = port->phy_interface != state->interface;
  
  	/* Check for invalid configuration */
 -	if (mvpp2_is_xlg(state->interface) && port->gop_id != 0) {
 +	if (state->interface == PHY_INTERFACE_MODE_10GKR && port->gop_id != 0) {
  		netdev_err(dev, "Invalid mode on %s\n", dev->name);
  		return;
  	}
@@@ -4417,21 -4837,16 +4441,22 @@@
  	if (port->priv->hw_version == MVPP21 && port->flags & MVPP2_F_LOOPBACK)
  		mvpp2_port_loopback_set(port, state);
  
 -	if (port->priv->hw_version == MVPP22 && change_interface)
 -		mvpp22_gop_unmask_irq(port);
 +	/* If the port already was up, make sure it's still in the same state */
 +	if (state->link || !port->has_phy) {
 +		mvpp2_port_enable(port);
  
 -	mvpp2_port_enable(port);
 +		mvpp2_egress_enable(port);
 +		mvpp2_ingress_enable(port);
 +		if (!port->has_phy)
 +			netif_carrier_on(dev);
 +		netif_tx_wake_all_queues(dev);
 +	}
  }
  
- static void mvpp2_mac_link_up(struct net_device *dev, unsigned int mode,
+ static void mvpp2_mac_link_up(struct phylink_config *config, unsigned int mode,
  			      phy_interface_t interface, struct phy_device *phy)
  {
+ 	struct net_device *dev = to_net_dev(config->dev);
  	struct mvpp2_port *port = netdev_priv(dev);
  	u32 val;
  
diff --cc drivers/net/phy/phylink.c
index f51febdb1dc6,5a283bf9d402..000000000000
--- a/drivers/net/phy/phylink.c
+++ b/drivers/net/phy/phylink.c
@@@ -400,6 -395,34 +400,37 @@@ static const char *phylink_pause_to_str
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void phylink_mac_link_up(struct phylink *pl,
+ 				struct phylink_link_state link_state)
+ {
+ 	struct net_device *ndev = pl->netdev;
+ 
+ 	pl->ops->mac_link_up(pl->config, pl->link_an_mode,
+ 			     pl->phy_state.interface,
+ 			     pl->phydev);
+ 
+ 	netif_carrier_on(ndev);
+ 
+ 	netdev_info(ndev,
+ 		    "Link is Up - %s/%s - flow control %s\n",
+ 		    phy_speed_to_str(link_state.speed),
+ 		    phy_duplex_to_str(link_state.duplex),
+ 		    phylink_pause_to_str(link_state.pause));
+ }
+ 
+ static void phylink_mac_link_down(struct phylink *pl)
+ {
+ 	struct net_device *ndev = pl->netdev;
+ 
+ 	netif_carrier_off(ndev);
+ 	pl->ops->mac_link_down(pl->config, pl->link_an_mode,
+ 			       pl->phy_state.interface);
+ 	netdev_info(ndev, "Link is Down\n");
+ }
+ 
++>>>>>>> 44cc27e43fa3 (net: phylink: Add struct phylink_config to PHYLINK API)
  static void phylink_resolve(struct work_struct *w)
  {
  	struct phylink *pl = container_of(w, struct phylink, resolve);
diff --cc include/net/dsa.h
index fdbd6082945d,a7f36219904f..000000000000
--- a/include/net/dsa.h
+++ b/include/net/dsa.h
@@@ -21,6 -21,8 +21,11 @@@
  #include <linux/ethtool.h>
  #include <linux/net_tstamp.h>
  #include <linux/phy.h>
++<<<<<<< HEAD
++=======
+ #include <linux/platform_data/dsa.h>
+ #include <linux/phylink.h>
++>>>>>>> 44cc27e43fa3 (net: phylink: Add struct phylink_config to PHYLINK API)
  #include <net/devlink.h>
  #include <net/switchdev.h>
  
@@@ -202,6 -194,17 +207,20 @@@ struct dsa_port 
  	struct net_device	*bridge_dev;
  	struct devlink_port	devlink_port;
  	struct phylink		*pl;
++<<<<<<< HEAD
++=======
+ 	struct phylink_config	pl_config;
+ 
+ 	struct work_struct	xmit_work;
+ 	struct sk_buff_head	xmit_queue;
+ 
+ 	/*
+ 	 * Give the switch driver somewhere to hang its per-port private data
+ 	 * structures (accessible from the tagger).
+ 	 */
+ 	void *priv;
+ 
++>>>>>>> 44cc27e43fa3 (net: phylink: Add struct phylink_config to PHYLINK API)
  	/*
  	 * Original copy of the master netdev ethtool_ops
  	 */
* Unmerged path Documentation/networking/sfp-phylink.rst
* Unmerged path Documentation/networking/sfp-phylink.rst
* Unmerged path drivers/net/ethernet/marvell/mvneta.c
diff --git a/drivers/net/ethernet/marvell/mvpp2/mvpp2.h b/drivers/net/ethernet/marvell/mvpp2/mvpp2.h
index def00dc3eb4e..f6f1b5e433a9 100644
--- a/drivers/net/ethernet/marvell/mvpp2/mvpp2.h
+++ b/drivers/net/ethernet/marvell/mvpp2/mvpp2.h
@@ -782,6 +782,7 @@ struct mvpp2_port {
 
 	phy_interface_t phy_interface;
 	struct phylink *phylink;
+	struct phylink_config phylink_config;
 	struct phy *comphy;
 
 	struct mvpp2_bm_pool *pool_long;
* Unmerged path drivers/net/ethernet/marvell/mvpp2/mvpp2_main.c
* Unmerged path drivers/net/phy/phylink.c
diff --git a/include/linux/phylink.h b/include/linux/phylink.h
index 6411c624f63a..67f35f07ac4b 100644
--- a/include/linux/phylink.h
+++ b/include/linux/phylink.h
@@ -54,6 +54,20 @@ struct phylink_link_state {
 	unsigned int an_complete:1;
 };
 
+enum phylink_op_type {
+	PHYLINK_NETDEV = 0,
+};
+
+/**
+ * struct phylink_config - PHYLINK configuration structure
+ * @dev: a pointer to a struct device associated with the MAC
+ * @type: operation type of PHYLINK instance
+ */
+struct phylink_config {
+	struct device *dev;
+	enum phylink_op_type type;
+};
+
 /**
  * struct phylink_mac_ops - MAC operations structure.
  * @validate: Validate and update the link configuration.
@@ -66,16 +80,17 @@ struct phylink_link_state {
  * The individual methods are described more fully below.
  */
 struct phylink_mac_ops {
-	void (*validate)(struct net_device *ndev, unsigned long *supported,
+	void (*validate)(struct phylink_config *config,
+			 unsigned long *supported,
 			 struct phylink_link_state *state);
-	int (*mac_link_state)(struct net_device *ndev,
+	int (*mac_link_state)(struct phylink_config *config,
 			      struct phylink_link_state *state);
-	void (*mac_config)(struct net_device *ndev, unsigned int mode,
+	void (*mac_config)(struct phylink_config *config, unsigned int mode,
 			   const struct phylink_link_state *state);
-	void (*mac_an_restart)(struct net_device *ndev);
-	void (*mac_link_down)(struct net_device *ndev, unsigned int mode,
+	void (*mac_an_restart)(struct phylink_config *config);
+	void (*mac_link_down)(struct phylink_config *config, unsigned int mode,
 			      phy_interface_t interface);
-	void (*mac_link_up)(struct net_device *ndev, unsigned int mode,
+	void (*mac_link_up)(struct phylink_config *config, unsigned int mode,
 			    phy_interface_t interface,
 			    struct phy_device *phy);
 };
@@ -83,7 +98,7 @@ struct phylink_mac_ops {
 #if 0 /* For kernel-doc purposes only. */
 /**
  * validate - Validate and update the link configuration
- * @ndev: a pointer to a &struct net_device for the MAC.
+ * @config: a pointer to a &struct phylink_config.
  * @supported: ethtool bitmask for supported link modes.
  * @state: a pointer to a &struct phylink_link_state.
  *
@@ -100,12 +115,12 @@ struct phylink_mac_ops {
  * based on @state->advertising and/or @state->speed and update
  * @state->interface accordingly.
  */
-void validate(struct net_device *ndev, unsigned long *supported,
+void validate(struct phylink_config *config, unsigned long *supported,
 	      struct phylink_link_state *state);
 
 /**
  * mac_link_state() - Read the current link state from the hardware
- * @ndev: a pointer to a &struct net_device for the MAC.
+ * @config: a pointer to a &struct phylink_config.
  * @state: a pointer to a &struct phylink_link_state.
  *
  * Read the current link state from the MAC, reporting the current
@@ -114,12 +129,12 @@ void validate(struct net_device *ndev, unsigned long *supported,
  * negotiation completion state in @state->an_complete, and link
  * up state in @state->link.
  */
-int mac_link_state(struct net_device *ndev,
+int mac_link_state(struct phylink_config *config,
 		   struct phylink_link_state *state);
 
 /**
  * mac_config() - configure the MAC for the selected mode and state
- * @ndev: a pointer to a &struct net_device for the MAC.
+ * @config: a pointer to a &struct phylink_config.
  * @mode: one of %MLO_AN_FIXED, %MLO_AN_PHY, %MLO_AN_INBAND.
  * @state: a pointer to a &struct phylink_link_state.
  *
@@ -157,18 +172,18 @@ int mac_link_state(struct net_device *ndev,
  * down.  This "update" behaviour is critical to avoid bouncing the
  * link up status.
  */
-void mac_config(struct net_device *ndev, unsigned int mode,
+void mac_config(struct phylink_config *config, unsigned int mode,
 		const struct phylink_link_state *state);
 
 /**
  * mac_an_restart() - restart 802.3z BaseX autonegotiation
- * @ndev: a pointer to a &struct net_device for the MAC.
+ * @config: a pointer to a &struct phylink_config.
  */
-void mac_an_restart(struct net_device *ndev);
+void mac_an_restart(struct phylink_config *config);
 
 /**
  * mac_link_down() - take the link down
- * @ndev: a pointer to a &struct net_device for the MAC.
+ * @config: a pointer to a &struct phylink_config.
  * @mode: link autonegotiation mode
  * @interface: link &typedef phy_interface_t mode
  *
@@ -177,12 +192,12 @@ void mac_an_restart(struct net_device *ndev);
  * Energy Efficient Ethernet MAC configuration. Interface type
  * selection must be done in mac_config().
  */
-void mac_link_down(struct net_device *ndev, unsigned int mode,
+void mac_link_down(struct phylink_config *config, unsigned int mode,
 		   phy_interface_t interface);
 
 /**
  * mac_link_up() - allow the link to come up
- * @ndev: a pointer to a &struct net_device for the MAC.
+ * @config: a pointer to a &struct phylink_config.
  * @mode: link autonegotiation mode
  * @interface: link &typedef phy_interface_t mode
  * @phy: any attached phy
@@ -193,13 +208,14 @@ void mac_link_down(struct net_device *ndev, unsigned int mode,
  * phy_init_eee() and perform appropriate MAC configuration for EEE.
  * Interface type selection must be done in mac_config().
  */
-void mac_link_up(struct net_device *ndev, unsigned int mode,
+void mac_link_up(struct phylink_config *config, unsigned int mode,
 		 phy_interface_t interface,
 		 struct phy_device *phy);
 #endif
 
-struct phylink *phylink_create(struct net_device *, struct fwnode_handle *,
-	phy_interface_t iface, const struct phylink_mac_ops *ops);
+struct phylink *phylink_create(struct phylink_config *, struct fwnode_handle *,
+			       phy_interface_t iface,
+			       const struct phylink_mac_ops *ops);
 void phylink_destroy(struct phylink *);
 
 int phylink_connect_phy(struct phylink *, struct phy_device *);
* Unmerged path include/net/dsa.h
diff --git a/net/dsa/slave.c b/net/dsa/slave.c
index fb4f949cd420..148f9b729a61 100644
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@ -1080,11 +1080,11 @@ static struct device_type dsa_type = {
 	.name	= "dsa",
 };
 
-static void dsa_slave_phylink_validate(struct net_device *dev,
+static void dsa_slave_phylink_validate(struct phylink_config *config,
 				       unsigned long *supported,
 				       struct phylink_link_state *state)
 {
-	struct dsa_port *dp = dsa_slave_to_port(dev);
+	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
 	struct dsa_switch *ds = dp->ds;
 
 	if (!ds->ops->phylink_validate)
@@ -1093,10 +1093,10 @@ static void dsa_slave_phylink_validate(struct net_device *dev,
 	ds->ops->phylink_validate(ds, dp->index, supported, state);
 }
 
-static int dsa_slave_phylink_mac_link_state(struct net_device *dev,
+static int dsa_slave_phylink_mac_link_state(struct phylink_config *config,
 					    struct phylink_link_state *state)
 {
-	struct dsa_port *dp = dsa_slave_to_port(dev);
+	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
 	struct dsa_switch *ds = dp->ds;
 
 	/* Only called for SGMII and 802.3z */
@@ -1106,11 +1106,11 @@ static int dsa_slave_phylink_mac_link_state(struct net_device *dev,
 	return ds->ops->phylink_mac_link_state(ds, dp->index, state);
 }
 
-static void dsa_slave_phylink_mac_config(struct net_device *dev,
+static void dsa_slave_phylink_mac_config(struct phylink_config *config,
 					 unsigned int mode,
 					 const struct phylink_link_state *state)
 {
-	struct dsa_port *dp = dsa_slave_to_port(dev);
+	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
 	struct dsa_switch *ds = dp->ds;
 
 	if (!ds->ops->phylink_mac_config)
@@ -1119,9 +1119,9 @@ static void dsa_slave_phylink_mac_config(struct net_device *dev,
 	ds->ops->phylink_mac_config(ds, dp->index, mode, state);
 }
 
-static void dsa_slave_phylink_mac_an_restart(struct net_device *dev)
+static void dsa_slave_phylink_mac_an_restart(struct phylink_config *config)
 {
-	struct dsa_port *dp = dsa_slave_to_port(dev);
+	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
 	struct dsa_switch *ds = dp->ds;
 
 	if (!ds->ops->phylink_mac_an_restart)
@@ -1130,11 +1130,12 @@ static void dsa_slave_phylink_mac_an_restart(struct net_device *dev)
 	ds->ops->phylink_mac_an_restart(ds, dp->index);
 }
 
-static void dsa_slave_phylink_mac_link_down(struct net_device *dev,
+static void dsa_slave_phylink_mac_link_down(struct phylink_config *config,
 					    unsigned int mode,
 					    phy_interface_t interface)
 {
-	struct dsa_port *dp = dsa_slave_to_port(dev);
+	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+	struct net_device *dev = dp->slave;
 	struct dsa_switch *ds = dp->ds;
 
 	if (!ds->ops->phylink_mac_link_down) {
@@ -1146,12 +1147,13 @@ static void dsa_slave_phylink_mac_link_down(struct net_device *dev,
 	ds->ops->phylink_mac_link_down(ds, dp->index, mode, interface);
 }
 
-static void dsa_slave_phylink_mac_link_up(struct net_device *dev,
+static void dsa_slave_phylink_mac_link_up(struct phylink_config *config,
 					  unsigned int mode,
 					  phy_interface_t interface,
 					  struct phy_device *phydev)
 {
-	struct dsa_port *dp = dsa_slave_to_port(dev);
+	struct dsa_port *dp = container_of(config, struct dsa_port, pl_config);
+	struct net_device *dev = dp->slave;
 	struct dsa_switch *ds = dp->ds;
 
 	if (!ds->ops->phylink_mac_link_up) {
@@ -1219,7 +1221,10 @@ static int dsa_slave_phy_setup(struct net_device *slave_dev)
 	if (mode < 0)
 		mode = PHY_INTERFACE_MODE_NA;
 
-	dp->pl = phylink_create(slave_dev, of_fwnode_handle(port_dn), mode,
+	dp->pl_config.dev = &slave_dev->dev;
+	dp->pl_config.type = PHYLINK_NETDEV;
+
+	dp->pl = phylink_create(&dp->pl_config, of_fwnode_handle(port_dn), mode,
 				&dsa_slave_phylink_mac_ops);
 	if (IS_ERR(dp->pl)) {
 		netdev_err(slave_dev,
