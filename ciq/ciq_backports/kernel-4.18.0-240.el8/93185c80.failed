netfilter: conntrack: clamp l4proto array size at largers supported protocol

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 93185c80a5f748620f5652e492f2a1c8d89db593
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/93185c80.failed

All higher l4proto numbers are handled by the generic tracker; the
l4proto lookup function already returns generic one in case the l4proto
number exceeds max size.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 93185c80a5f748620f5652e492f2a1c8d89db593)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_proto.c
diff --cc net/netfilter/nf_conntrack_proto.c
index baa1f4cdedbb,40643af7137e..000000000000
--- a/net/netfilter/nf_conntrack_proto.c
+++ b/net/netfilter/nf_conntrack_proto.c
@@@ -29,9 -18,32 +29,38 @@@
  #include <net/netfilter/nf_conntrack_core.h>
  #include <net/netfilter/nf_log.h>
  
++<<<<<<< HEAD
 +static struct nf_conntrack_l4proto __rcu **nf_ct_protos[NFPROTO_NUMPROTO] __read_mostly;
 +struct nf_conntrack_l3proto __rcu *nf_ct_l3protos[NFPROTO_NUMPROTO] __read_mostly;
 +EXPORT_SYMBOL_GPL(nf_ct_l3protos);
++=======
+ #include <linux/ip.h>
+ #include <linux/icmp.h>
+ #include <linux/sysctl.h>
+ #include <net/route.h>
+ #include <net/ip.h>
+ 
+ #include <linux/netfilter_ipv4.h>
+ #include <linux/netfilter_ipv6.h>
+ #include <linux/netfilter_ipv6/ip6_tables.h>
+ #include <net/netfilter/nf_conntrack_helper.h>
+ #include <net/netfilter/nf_conntrack_zones.h>
+ #include <net/netfilter/nf_conntrack_seqadj.h>
+ #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
+ #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+ #include <net/netfilter/nf_nat_helper.h>
+ #include <net/netfilter/ipv4/nf_defrag_ipv4.h>
+ #include <net/netfilter/ipv6/nf_defrag_ipv6.h>
+ 
+ #include <linux/ipv6.h>
+ #include <linux/in6.h>
+ #include <net/ipv6.h>
+ #include <net/inet_frag.h>
+ 
+ extern unsigned int nf_conntrack_net_id;
+ 
+ static struct nf_conntrack_l4proto __rcu *nf_ct_protos[MAX_NF_CT_PROTO + 1] __read_mostly;
++>>>>>>> 93185c80a5f7 (netfilter: conntrack: clamp l4proto array size at largers supported protocol)
  
  static DEFINE_MUTEX(nf_ct_proto_mutex);
  
diff --git a/include/net/netfilter/nf_conntrack_l4proto.h b/include/net/netfilter/nf_conntrack_l4proto.h
index 264f50873a3a..f34c6789a737 100644
--- a/include/net/netfilter/nf_conntrack_l4proto.h
+++ b/include/net/netfilter/nf_conntrack_l4proto.h
@@ -108,7 +108,7 @@ struct nf_conntrack_l4proto {
 /* Existing built-in generic protocol */
 extern const struct nf_conntrack_l4proto nf_conntrack_l4proto_generic;
 
-#define MAX_NF_CT_PROTO 256
+#define MAX_NF_CT_PROTO IPPROTO_UDPLITE
 
 const struct nf_conntrack_l4proto *__nf_ct_l4proto_find(u_int16_t l3proto,
 						  u_int8_t l4proto);
* Unmerged path net/netfilter/nf_conntrack_proto.c
