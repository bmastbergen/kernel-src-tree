net/mlx5e: CT: Don't offload tuple rewrites for established tuples

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paul Blakey <paulb@mellanox.com>
commit 7e36feeb04676c7eed0b3fe9196543608bc7ecae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7e36feeb.failed

Next patches will remove the tupleid registers that is used
to restore the ct state on miss, and instead use the tuple on
the missed packet to lookup which state to restore.
Disable tuple rewrites after connection tracking.

For tuple rewrites, inject a ct_state=-trk match so it won't
change the tuple for established flows (+trk) that passed connection
tracking, and instead miss to software.

	Signed-off-by: Paul Blakey <paulb@mellanox.com>
	Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 7e36feeb04676c7eed0b3fe9196543608bc7ecae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 23a1c21d8bab,fd984ef234b2..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -149,6 -172,109 +149,112 @@@ struct mlx5e_tc_flow_parse_attr 
  #define MLX5E_TC_TABLE_NUM_GROUPS 4
  #define MLX5E_TC_TABLE_MAX_GROUP_SIZE BIT(16)
  
++<<<<<<< HEAD
++=======
+ struct mlx5e_tc_attr_to_reg_mapping mlx5e_tc_attr_to_reg_mappings[] = {
+ 	[CHAIN_TO_REG] = {
+ 		.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_0,
+ 		.moffset = 0,
+ 		.mlen = 2,
+ 	},
+ 	[TUNNEL_TO_REG] = {
+ 		.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_1,
+ 		.moffset = 3,
+ 		.mlen = 1,
+ 		.soffset = MLX5_BYTE_OFF(fte_match_param,
+ 					 misc_parameters_2.metadata_reg_c_1),
+ 	},
+ 	[ZONE_TO_REG] = zone_to_reg_ct,
+ 	[CTSTATE_TO_REG] = ctstate_to_reg_ct,
+ 	[MARK_TO_REG] = mark_to_reg_ct,
+ 	[LABELS_TO_REG] = labels_to_reg_ct,
+ 	[FTEID_TO_REG] = fteid_to_reg_ct,
+ 	[TUPLEID_TO_REG] = tupleid_to_reg_ct,
+ };
+ 
+ static void mlx5e_put_flow_tunnel_id(struct mlx5e_tc_flow *flow);
+ 
+ void
+ mlx5e_tc_match_to_reg_match(struct mlx5_flow_spec *spec,
+ 			    enum mlx5e_tc_attr_to_reg type,
+ 			    u32 data,
+ 			    u32 mask)
+ {
+ 	int soffset = mlx5e_tc_attr_to_reg_mappings[type].soffset;
+ 	int match_len = mlx5e_tc_attr_to_reg_mappings[type].mlen;
+ 	void *headers_c = spec->match_criteria;
+ 	void *headers_v = spec->match_value;
+ 	void *fmask, *fval;
+ 
+ 	fmask = headers_c + soffset;
+ 	fval = headers_v + soffset;
+ 
+ 	mask = (__force u32)(cpu_to_be32(mask)) >> (32 - (match_len * 8));
+ 	data = (__force u32)(cpu_to_be32(data)) >> (32 - (match_len * 8));
+ 
+ 	memcpy(fmask, &mask, match_len);
+ 	memcpy(fval, &data, match_len);
+ 
+ 	spec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_2;
+ }
+ 
+ void
+ mlx5e_tc_match_to_reg_get_match(struct mlx5_flow_spec *spec,
+ 				enum mlx5e_tc_attr_to_reg type,
+ 				u32 *data,
+ 				u32 *mask)
+ {
+ 	int soffset = mlx5e_tc_attr_to_reg_mappings[type].soffset;
+ 	int match_len = mlx5e_tc_attr_to_reg_mappings[type].mlen;
+ 	void *headers_c = spec->match_criteria;
+ 	void *headers_v = spec->match_value;
+ 	void *fmask, *fval;
+ 
+ 	fmask = headers_c + soffset;
+ 	fval = headers_v + soffset;
+ 
+ 	memcpy(mask, fmask, match_len);
+ 	memcpy(data, fval, match_len);
+ 
+ 	*mask = be32_to_cpu((__force __be32)(*mask << (32 - (match_len * 8))));
+ 	*data = be32_to_cpu((__force __be32)(*data << (32 - (match_len * 8))));
+ }
+ 
+ int
+ mlx5e_tc_match_to_reg_set(struct mlx5_core_dev *mdev,
+ 			  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,
+ 			  enum mlx5e_tc_attr_to_reg type,
+ 			  u32 data)
+ {
+ 	int moffset = mlx5e_tc_attr_to_reg_mappings[type].moffset;
+ 	int mfield = mlx5e_tc_attr_to_reg_mappings[type].mfield;
+ 	int mlen = mlx5e_tc_attr_to_reg_mappings[type].mlen;
+ 	char *modact;
+ 	int err;
+ 
+ 	err = alloc_mod_hdr_actions(mdev, MLX5_FLOW_NAMESPACE_FDB,
+ 				    mod_hdr_acts);
+ 	if (err)
+ 		return err;
+ 
+ 	modact = mod_hdr_acts->actions +
+ 		 (mod_hdr_acts->num_actions * MLX5_MH_ACT_SZ);
+ 
+ 	/* Firmware has 5bit length field and 0 means 32bits */
+ 	if (mlen == 4)
+ 		mlen = 0;
+ 
+ 	MLX5_SET(set_action_in, modact, action_type, MLX5_ACTION_TYPE_SET);
+ 	MLX5_SET(set_action_in, modact, field, mfield);
+ 	MLX5_SET(set_action_in, modact, offset, moffset * 8);
+ 	MLX5_SET(set_action_in, modact, length, mlen * 8);
+ 	MLX5_SET(set_action_in, modact, data, data);
+ 	mod_hdr_acts->num_actions++;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 7e36feeb0467 (net/mlx5e: CT: Don't offload tuple rewrites for established tuples)
  struct mlx5e_hairpin {
  	struct mlx5_hairpin *pair;
  
@@@ -2579,7 -3106,10 +2685,14 @@@ struct ipv6_hoplimit_word 
  	__u8	hop_limit;
  };
  
++<<<<<<< HEAD
 +static bool is_action_keys_supported(const struct flow_action_entry *act)
++=======
+ static int is_action_keys_supported(const struct flow_action_entry *act,
+ 				    bool ct_flow, bool *modify_ip_header,
+ 				    bool *modify_tuple,
+ 				    struct netlink_ext_ack *extack)
++>>>>>>> 7e36feeb0467 (net/mlx5e: CT: Don't offload tuple rewrites for established tuples)
  {
  	u32 mask, offset;
  	u8 htype;
@@@ -2598,7 -3128,16 +2711,20 @@@
  		if (offset != offsetof(struct iphdr, ttl) ||
  		    ttl_word->protocol ||
  		    ttl_word->check) {
++<<<<<<< HEAD
 +			return true;
++=======
+ 			*modify_ip_header = true;
+ 		}
+ 
+ 		if (offset >= offsetof(struct iphdr, saddr))
+ 			*modify_tuple = true;
+ 
+ 		if (ct_flow && *modify_tuple) {
+ 			NL_SET_ERR_MSG_MOD(extack,
+ 					   "can't offload re-write of ipv4 address with action ct");
+ 			return -EOPNOTSUPP;
++>>>>>>> 7e36feeb0467 (net/mlx5e: CT: Don't offload tuple rewrites for established tuples)
  		}
  	} else if (htype == FLOW_ACT_MANGLE_HDR_TYPE_IP6) {
  		struct ipv6_hoplimit_word *hoplimit_word =
@@@ -2607,20 -3146,40 +2733,50 @@@
  		if (offset != offsetof(struct ipv6hdr, payload_len) ||
  		    hoplimit_word->payload_len ||
  		    hoplimit_word->nexthdr) {
 -			*modify_ip_header = true;
 +			return true;
  		}
++<<<<<<< HEAD
++=======
+ 
+ 		if (ct_flow && offset >= offsetof(struct ipv6hdr, saddr))
+ 			*modify_tuple = true;
+ 
+ 		if (ct_flow && *modify_tuple) {
+ 			NL_SET_ERR_MSG_MOD(extack,
+ 					   "can't offload re-write of ipv6 address with action ct");
+ 			return -EOPNOTSUPP;
+ 		}
+ 	} else if (htype == FLOW_ACT_MANGLE_HDR_TYPE_TCP ||
+ 		   htype == FLOW_ACT_MANGLE_HDR_TYPE_UDP) {
+ 		*modify_tuple = true;
+ 		if (ct_flow) {
+ 			NL_SET_ERR_MSG_MOD(extack,
+ 					   "can't offload re-write of transport header ports with action ct");
+ 			return -EOPNOTSUPP;
+ 		}
++>>>>>>> 7e36feeb0467 (net/mlx5e: CT: Don't offload tuple rewrites for established tuples)
  	}
 -
 -	return 0;
 +	return false;
  }
  
  static bool modify_header_match_supported(struct mlx5e_priv *priv,
  					  struct mlx5_flow_spec *spec,
  					  struct flow_action *flow_action,
++<<<<<<< HEAD
 +					  u32 actions,
 +					  struct netlink_ext_ack *extack)
 +{
 +	const struct flow_action_entry *act;
 +	bool modify_ip_header;
++=======
+ 					  u32 actions, bool ct_flow,
+ 					  bool ct_clear,
+ 					  struct netlink_ext_ack *extack)
+ {
+ 	const struct flow_action_entry *act;
+ 	bool modify_ip_header, modify_tuple;
+ 	void *headers_c;
++>>>>>>> 7e36feeb0467 (net/mlx5e: CT: Don't offload tuple rewrites for established tuples)
  	void *headers_v;
  	u16 ethertype;
  	u8 ip_proto;
@@@ -2639,10 -3201,24 +2796,31 @@@
  		    act->id != FLOW_ACTION_ADD)
  			continue;
  
++<<<<<<< HEAD
 +		if (is_action_keys_supported(act)) {
 +			modify_ip_header = true;
 +			break;
 +		}
++=======
+ 		err = is_action_keys_supported(act, ct_flow,
+ 					       &modify_ip_header,
+ 					       &modify_tuple, extack);
+ 		if (err)
+ 			return err;
++>>>>>>> 7e36feeb0467 (net/mlx5e: CT: Don't offload tuple rewrites for established tuples)
+ 	}
+ 
+ 	/* Add ct_state=-trk match so it will be offloaded for non ct flows
+ 	 * (or after clear action), as otherwise, since the tuple is changed,
+ 	 *  we can't restore ct state
+ 	 */
+ 	if (!ct_clear && modify_tuple &&
+ 	    mlx5_tc_ct_add_no_trk_match(priv, spec)) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "can't offload tuple modify header with ct matches");
+ 		netdev_info(priv->netdev,
+ 			    "can't offload tuple modify header with ct matches");
+ 		return false;
  	}
  
  	ip_proto = MLX5_GET(fte_match_set_lyr_2_4, headers_v, ip_protocol);
@@@ -2691,6 -3264,7 +2869,10 @@@ static bool actions_match_supported(str
  	if (actions & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
  		return modify_header_match_supported(priv, &parse_attr->spec,
  						     flow_action, actions,
++<<<<<<< HEAD
++=======
+ 						     ct_flow, ct_clear,
++>>>>>>> 7e36feeb0467 (net/mlx5e: CT: Don't offload tuple rewrites for established tuples)
  						     extack);
  
  	return true;
@@@ -3644,7 -4532,12 +3826,16 @@@ __mlx5e_add_fdb_flow(struct mlx5e_priv 
  	if (err)
  		goto err_free;
  
++<<<<<<< HEAD
 +	err = parse_tc_fdb_actions(priv, &rule->action, flow, extack);
++=======
+ 	/* actions validation depends on parsing the ct matches first */
+ 	err = mlx5_tc_ct_parse_match(priv, &parse_attr->spec, f, extack);
+ 	if (err)
+ 		goto err_free;
+ 
+ 	err = parse_tc_fdb_actions(priv, &rule->action, flow, extack, filter_dev);
++>>>>>>> 7e36feeb0467 (net/mlx5e: CT: Don't offload tuple rewrites for established tuples)
  	if (err)
  		goto err_free;
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 22d5efd4edec,68d49b945184..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@@ -109,6 -154,21 +109,24 @@@ struct mlx5e_tc_mod_hdr_acts 
  	void *actions;
  };
  
++<<<<<<< HEAD
++=======
+ int mlx5e_tc_match_to_reg_set(struct mlx5_core_dev *mdev,
+ 			      struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,
+ 			      enum mlx5e_tc_attr_to_reg type,
+ 			      u32 data);
+ 
+ void mlx5e_tc_match_to_reg_match(struct mlx5_flow_spec *spec,
+ 				 enum mlx5e_tc_attr_to_reg type,
+ 				 u32 data,
+ 				 u32 mask);
+ 
+ void mlx5e_tc_match_to_reg_get_match(struct mlx5_flow_spec *spec,
+ 				     enum mlx5e_tc_attr_to_reg type,
+ 				     u32 *data,
+ 				     u32 *mask);
+ 
++>>>>>>> 7e36feeb0467 (net/mlx5e: CT: Don't offload tuple rewrites for established tuples)
  int alloc_mod_hdr_actions(struct mlx5_core_dev *mdev,
  			  int namespace,
  			  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
