IB/iser: remove redundant macro definitions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Max Gurtovoy <maxg@mellanox.com>
commit 6eeff06db999bf9b17aaa52fddda4fd449726a64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6eeff06d.failed

Use the general linux definition for 4K and retrieve the rest from it.

Link: https://lore.kernel.org/r/1569359148-12312-1-git-send-email-maxg@mellanox.com
	Signed-off-by: Max Gurtovoy <maxg@mellanox.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 6eeff06db999bf9b17aaa52fddda4fd449726a64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iscsi_iser.c
#	drivers/infiniband/ulp/iser/iscsi_iser.h
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.c
index a3e46ac2118f,55f45edeb5f9..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@@ -650,8 -652,10 +650,15 @@@ iscsi_iser_session_create(struct iscsi_
  						   SHOST_DIX_GUARD_CRC);
  		}
  
++<<<<<<< HEAD
 +		if (iscsi_host_add(shost,
 +				   ib_conn->device->ib_device->dev.parent)) {
++=======
+ 		if (!(ib_dev->attrs.device_cap_flags & IB_DEVICE_SG_GAPS_REG))
+ 			shost->virt_boundary_mask = SZ_4K - 1;
+ 
+ 		if (iscsi_host_add(shost, ib_dev->dev.parent)) {
++>>>>>>> 6eeff06db999 (IB/iser: remove redundant macro definitions)
  			mutex_unlock(&iser_conn->state_mutex);
  			goto free_host;
  		}
diff --cc drivers/infiniband/ulp/iser/iscsi_iser.h
index 39bf213444cb,2500c0df2670..000000000000
--- a/drivers/infiniband/ulp/iser/iscsi_iser.h
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h
@@@ -96,15 -96,12 +96,18 @@@
  #define iser_err(fmt, arg...) \
  	pr_err(PFX "%s: " fmt, __func__ , ## arg)
  
- #define SHIFT_4K	12
- #define SIZE_4K	(1ULL << SHIFT_4K)
- #define MASK_4K	(~(SIZE_4K-1))
- 
  /* Default support is 512KB I/O size */
  #define ISER_DEF_MAX_SECTORS		1024
++<<<<<<< HEAD
 +#define ISCSI_ISER_DEF_SG_TABLESIZE	((ISER_DEF_MAX_SECTORS * 512) >> SHIFT_4K)
 +/* Maximum support is 8MB I/O size */
 +#define ISCSI_ISER_MAX_SG_TABLESIZE	((16384 * 512) >> SHIFT_4K)
++=======
+ #define ISCSI_ISER_DEF_SG_TABLESIZE                                            \
+ 	((ISER_DEF_MAX_SECTORS * SECTOR_SIZE) >> ilog2(SZ_4K))
+ /* Maximum support is 16MB I/O size */
+ #define ISCSI_ISER_MAX_SG_TABLESIZE ((32768 * SECTOR_SIZE) >> ilog2(SZ_4K))
++>>>>>>> 6eeff06db999 (IB/iser: remove redundant macro definitions)
  
  #define ISER_DEF_XMIT_CMDS_DEFAULT		512
  #if ISCSI_DEF_XMIT_CMDS_MAX > ISER_DEF_XMIT_CMDS_DEFAULT
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.c
* Unmerged path drivers/infiniband/ulp/iser/iscsi_iser.h
diff --git a/drivers/infiniband/ulp/iser/iser_memory.c b/drivers/infiniband/ulp/iser/iser_memory.c
index 3a26e5be1717..0f74dc6d12fa 100644
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@ -237,7 +237,7 @@ int iser_fast_reg_fmr(struct iscsi_iser_task *iser_task,
 	int ret, plen;
 
 	page_vec->npages = 0;
-	page_vec->fake_mr.page_size = SIZE_4K;
+	page_vec->fake_mr.page_size = SZ_4K;
 	plen = ib_sg_to_pages(&page_vec->fake_mr, mem->sg,
 			      mem->dma_nents, NULL, iser_set_page);
 	if (unlikely(plen < mem->dma_nents)) {
@@ -451,7 +451,7 @@ static int iser_fast_reg_mr(struct iscsi_iser_task *iser_task,
 
 	ib_update_fast_reg_key(mr, ib_inc_rkey(mr->rkey));
 
-	n = ib_map_mr_sg(mr, mem->sg, mem->dma_nents, NULL, SIZE_4K);
+	n = ib_map_mr_sg(mr, mem->sg, mem->dma_nents, NULL, SZ_4K);
 	if (unlikely(n != mem->dma_nents)) {
 		iser_err("failed to map sg (%d/%d)\n",
 			 n, mem->dma_nents);
diff --git a/drivers/infiniband/ulp/iser/iser_verbs.c b/drivers/infiniband/ulp/iser/iser_verbs.c
index 94b50112cdb2..17f8e914b531 100644
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@ -180,7 +180,7 @@ int iser_alloc_fmr_pool(struct ib_conn *ib_conn,
 
 	page_vec->pages = (u64 *)(page_vec + 1);
 
-	params.page_shift        = SHIFT_4K;
+	params.page_shift        = ilog2(SZ_4K);
 	params.max_pages_per_fmr = size;
 	/* make the pool size twice the max number of SCSI commands *
 	 * the ML is expected to queue, watermark for unmap at 50%  */
@@ -670,7 +670,7 @@ iser_calc_scsi_params(struct iser_conn *iser_conn,
 	else
 		max_num_sg = attr->max_fast_reg_page_list_len;
 
-	sg_tablesize = DIV_ROUND_UP(max_sectors * 512, SIZE_4K);
+	sg_tablesize = DIV_ROUND_UP(max_sectors * SECTOR_SIZE, SZ_4K);
 	if (attr->device_cap_flags & IB_DEVICE_MEM_MGT_EXTENSIONS)
 		sup_sg_tablesize =
 			min_t(
