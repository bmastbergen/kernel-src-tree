drm/i915: Add a retry counter for hotplug detect retries

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Imre Deak <imre.deak@intel.com>
commit 8c8919c7c99f097c9e6a441486c1c263277288b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8c8919c7.failed

On TypeC connectors we need to retry the detection after hotplug events
for a longer time, so add a retry counter to support this. The next
patch will add detection retries on TypeC ports needing this.

	Signed-off-by: Imre Deak <imre.deak@intel.com>
	Reviewed-by: Jos√© Roberto de Souza <jose.souza@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200330095425.29113-1-imre.deak@intel.com
(cherry picked from commit 8c8919c7c99f097c9e6a441486c1c263277288b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_ddi.c
#	drivers/gpu/drm/i915/display/intel_dp.c
#	drivers/gpu/drm/i915/display/intel_hdmi.c
#	drivers/gpu/drm/i915/display/intel_hotplug.c
#	drivers/gpu/drm/i915/display/intel_hotplug.h
#	drivers/gpu/drm/i915/display/intel_sdvo.c
#	drivers/gpu/drm/i915/intel_drv.h
diff --cc drivers/gpu/drm/i915/display/intel_ddi.c
index fd58aa20d02e,1bc6bfb2511e..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@@ -4108,14 -4516,16 +4108,24 @@@ static int intel_hdmi_reset_link(struc
  	return modeset_pipe(&crtc->base, ctx);
  }
  
++<<<<<<< HEAD
 +static bool intel_ddi_hotplug(struct intel_encoder *encoder,
 +			      struct intel_connector *connector)
++=======
+ static enum intel_hotplug_state
+ intel_ddi_hotplug(struct intel_encoder *encoder,
+ 		  struct intel_connector *connector)
++>>>>>>> 8c8919c7c99f (drm/i915: Add a retry counter for hotplug detect retries)
  {
 -	struct intel_digital_port *dig_port = enc_to_dig_port(encoder);
  	struct drm_modeset_acquire_ctx ctx;
 -	enum intel_hotplug_state state;
 +	bool changed;
  	int ret;
  
++<<<<<<< HEAD
 +	changed = intel_encoder_hotplug(encoder, connector);
++=======
+ 	state = intel_encoder_hotplug(encoder, connector);
++>>>>>>> 8c8919c7c99f (drm/i915: Add a retry counter for hotplug detect retries)
  
  	drm_modeset_acquire_init(&ctx, 0);
  
@@@ -4135,9 -4545,30 +4145,33 @@@
  
  	drm_modeset_drop_locks(&ctx);
  	drm_modeset_acquire_fini(&ctx);
 -	drm_WARN(encoder->base.dev, ret,
 -		 "Acquiring modeset locks failed with %i\n", ret);
 +	WARN(ret, "Acquiring modeset locks failed with %i\n", ret);
  
++<<<<<<< HEAD
 +	return changed;
++=======
+ 	/*
+ 	 * Unpowered type-c dongles can take some time to boot and be
+ 	 * responsible, so here giving some time to those dongles to power up
+ 	 * and then retrying the probe.
+ 	 *
+ 	 * On many platforms the HDMI live state signal is known to be
+ 	 * unreliable, so we can't use it to detect if a sink is connected or
+ 	 * not. Instead we detect if it's connected based on whether we can
+ 	 * read the EDID or not. That in turn has a problem during disconnect,
+ 	 * since the HPD interrupt may be raised before the DDC lines get
+ 	 * disconnected (due to how the required length of DDC vs. HPD
+ 	 * connector pins are specified) and so we'll still be able to get a
+ 	 * valid EDID. To solve this schedule another detection cycle if this
+ 	 * time around we didn't detect any change in the sink's connection
+ 	 * status.
+ 	 */
+ 	if (state == INTEL_HOTPLUG_UNCHANGED && !connector->hotplug_retries &&
+ 	    !dig_port->dp.is_mst)
+ 		state = INTEL_HOTPLUG_RETRY;
+ 
+ 	return state;
++>>>>>>> 8c8919c7c99f (drm/i915: Add a retry counter for hotplug detect retries)
  }
  
  static struct intel_connector *
diff --cc drivers/gpu/drm/i915/display/intel_dp.c
index 9ec0808f141e,25f0baafd6d0..000000000000
--- a/drivers/gpu/drm/i915/display/intel_dp.c
+++ b/drivers/gpu/drm/i915/display/intel_dp.c
@@@ -4885,14 -5569,15 +4885,24 @@@ int intel_dp_retrain_link(struct intel_
   * retrain the link to get a picture. That's in case no
   * userspace component reacted to intermittent HPD dip.
   */
++<<<<<<< HEAD
 +static bool intel_dp_hotplug(struct intel_encoder *encoder,
 +			     struct intel_connector *connector)
++=======
+ static enum intel_hotplug_state
+ intel_dp_hotplug(struct intel_encoder *encoder,
+ 		 struct intel_connector *connector)
++>>>>>>> 8c8919c7c99f (drm/i915: Add a retry counter for hotplug detect retries)
  {
  	struct drm_modeset_acquire_ctx ctx;
 -	enum intel_hotplug_state state;
 +	bool changed;
  	int ret;
  
++<<<<<<< HEAD
 +	changed = intel_encoder_hotplug(encoder, connector);
++=======
+ 	state = intel_encoder_hotplug(encoder, connector);
++>>>>>>> 8c8919c7c99f (drm/i915: Add a retry counter for hotplug detect retries)
  
  	drm_modeset_acquire_init(&ctx, 0);
  
@@@ -4909,9 -5594,17 +4919,20 @@@
  
  	drm_modeset_drop_locks(&ctx);
  	drm_modeset_acquire_fini(&ctx);
 -	drm_WARN(encoder->base.dev, ret,
 -		 "Acquiring modeset locks failed with %i\n", ret);
 +	WARN(ret, "Acquiring modeset locks failed with %i\n", ret);
  
++<<<<<<< HEAD
 +	return changed;
++=======
+ 	/*
+ 	 * Keeping it consistent with intel_ddi_hotplug() and
+ 	 * intel_hdmi_hotplug().
+ 	 */
+ 	if (state == INTEL_HOTPLUG_UNCHANGED && !connector->hotplug_retries)
+ 		state = INTEL_HOTPLUG_RETRY;
+ 
+ 	return state;
++>>>>>>> 8c8919c7c99f (drm/i915: Add a retry counter for hotplug detect retries)
  }
  
  static void intel_dp_check_service_irq(struct intel_dp *intel_dp)
diff --cc drivers/gpu/drm/i915/display/intel_hdmi.c
index 0ebec69bbbfc,011d83c2a1e3..000000000000
--- a/drivers/gpu/drm/i915/display/intel_hdmi.c
+++ b/drivers/gpu/drm/i915/display/intel_hdmi.c
@@@ -3133,14 -3263,44 +3133,44 @@@ void intel_hdmi_init_connector(struct i
  	 * generated on the port when a cable is not attached.
  	 */
  	if (IS_G45(dev_priv)) {
 -		u32 temp = intel_de_read(dev_priv, PEG_BAND_GAP_DATA);
 -		intel_de_write(dev_priv, PEG_BAND_GAP_DATA,
 -		               (temp & ~0xf) | 0xd);
 +		u32 temp = I915_READ(PEG_BAND_GAP_DATA);
 +		I915_WRITE(PEG_BAND_GAP_DATA, (temp & ~0xf) | 0xd);
  	}
  
 -	cec_fill_conn_info_from_drm(&conn_info, connector);
 -
 -	intel_hdmi->cec_notifier =
 -		cec_notifier_conn_register(dev->dev, port_identifier(port),
 -					   &conn_info);
 +	intel_hdmi->cec_notifier = cec_notifier_get_conn(dev->dev,
 +							 port_identifier(port));
  	if (!intel_hdmi->cec_notifier)
++<<<<<<< HEAD
 +		DRM_DEBUG_KMS("CEC notifier get failed\n");
++=======
+ 		drm_dbg_kms(&dev_priv->drm, "CEC notifier get failed\n");
+ }
+ 
+ static enum intel_hotplug_state
+ intel_hdmi_hotplug(struct intel_encoder *encoder,
+ 		   struct intel_connector *connector)
+ {
+ 	enum intel_hotplug_state state;
+ 
+ 	state = intel_encoder_hotplug(encoder, connector);
+ 
+ 	/*
+ 	 * On many platforms the HDMI live state signal is known to be
+ 	 * unreliable, so we can't use it to detect if a sink is connected or
+ 	 * not. Instead we detect if it's connected based on whether we can
+ 	 * read the EDID or not. That in turn has a problem during disconnect,
+ 	 * since the HPD interrupt may be raised before the DDC lines get
+ 	 * disconnected (due to how the required length of DDC vs. HPD
+ 	 * connector pins are specified) and so we'll still be able to get a
+ 	 * valid EDID. To solve this schedule another detection cycle if this
+ 	 * time around we didn't detect any change in the sink's connection
+ 	 * status.
+ 	 */
+ 	if (state == INTEL_HOTPLUG_UNCHANGED && !connector->hotplug_retries)
+ 		state = INTEL_HOTPLUG_RETRY;
+ 
+ 	return state;
++>>>>>>> 8c8919c7c99f (drm/i915: Add a retry counter for hotplug detect retries)
  }
  
  void intel_hdmi_init(struct drm_i915_private *dev_priv,
diff --cc drivers/gpu/drm/i915/display/intel_hotplug.c
index ea3de4acc850,4f6f560e093e..000000000000
--- a/drivers/gpu/drm/i915/display/intel_hotplug.c
+++ b/drivers/gpu/drm/i915/display/intel_hotplug.c
@@@ -266,8 -268,9 +266,14 @@@ static void intel_hpd_irq_storm_reenabl
  	intel_runtime_pm_put(&dev_priv->runtime_pm, wakeref);
  }
  
++<<<<<<< HEAD
 +bool intel_encoder_hotplug(struct intel_encoder *encoder,
 +			   struct intel_connector *connector)
++=======
+ enum intel_hotplug_state
+ intel_encoder_hotplug(struct intel_encoder *encoder,
+ 		      struct intel_connector *connector)
++>>>>>>> 8c8919c7c99f (drm/i915: Add a retry counter for hotplug detect retries)
  {
  	struct drm_device *dev = connector->base.dev;
  	enum drm_connector_status old_status;
@@@ -372,17 -378,39 +378,45 @@@ static void i915_hotplug_work_func(stru
  	spin_unlock_irq(&dev_priv->irq_lock);
  
  	drm_connector_list_iter_begin(dev, &conn_iter);
 -	for_each_intel_connector_iter(connector, &conn_iter) {
 -		enum hpd_pin pin;
 -		u32 hpd_bit;
 -
 -		pin = intel_connector_hpd_pin(connector);
 -		if (pin == HPD_NONE)
 +	drm_for_each_connector_iter(connector, &conn_iter) {
 +		intel_connector = to_intel_connector(connector);
 +		if (!intel_connector->encoder)
  			continue;
 -
 +		intel_encoder = intel_connector->encoder;
 +		if (hpd_event_bits & (1 << intel_encoder->hpd_pin)) {
 +			DRM_DEBUG_KMS("Connector %s (pin %i) received hotplug event.\n",
 +				      connector->name, intel_encoder->hpd_pin);
 +
++<<<<<<< HEAD
 +			changed |= intel_encoder->hotplug(intel_encoder,
 +							  intel_connector);
++=======
+ 		hpd_bit = BIT(pin);
+ 		if ((hpd_event_bits | hpd_retry_bits) & hpd_bit) {
+ 			struct intel_encoder *encoder =
+ 				intel_attached_encoder(connector);
+ 
+ 			if (hpd_event_bits & hpd_bit)
+ 				connector->hotplug_retries = 0;
+ 			else
+ 				connector->hotplug_retries++;
+ 
+ 			drm_dbg_kms(&dev_priv->drm,
+ 				    "Connector %s (pin %i) received hotplug event. (retry %d)\n",
+ 				    connector->base.name, pin,
+ 				    connector->hotplug_retries);
+ 
+ 			switch (encoder->hotplug(encoder, connector)) {
+ 			case INTEL_HOTPLUG_UNCHANGED:
+ 				break;
+ 			case INTEL_HOTPLUG_CHANGED:
+ 				changed |= hpd_bit;
+ 				break;
+ 			case INTEL_HOTPLUG_RETRY:
+ 				retry |= hpd_bit;
+ 				break;
+ 			}
++>>>>>>> 8c8919c7c99f (drm/i915: Add a retry counter for hotplug detect retries)
  		}
  	}
  	drm_connector_list_iter_end(&conn_iter);
diff --cc drivers/gpu/drm/i915/display/intel_hotplug.h
index 805f897dbb7a,777b0743257e..000000000000
--- a/drivers/gpu/drm/i915/display/intel_hotplug.h
+++ b/drivers/gpu/drm/i915/display/intel_hotplug.h
@@@ -13,10 -11,11 +13,15 @@@
  struct drm_i915_private;
  struct intel_connector;
  struct intel_encoder;
 -enum port;
  
  void intel_hpd_poll_init(struct drm_i915_private *dev_priv);
++<<<<<<< HEAD
 +bool intel_encoder_hotplug(struct intel_encoder *encoder,
 +			   struct intel_connector *connector);
++=======
+ enum intel_hotplug_state intel_encoder_hotplug(struct intel_encoder *encoder,
+ 					       struct intel_connector *connector);
++>>>>>>> 8c8919c7c99f (drm/i915: Add a retry counter for hotplug detect retries)
  void intel_hpd_irq_handler(struct drm_i915_private *dev_priv,
  			   u32 pin_mask, u32 long_mask);
  void intel_hpd_init(struct drm_i915_private *dev_priv);
diff --cc drivers/gpu/drm/i915/display/intel_sdvo.c
index ceda03e5a3d4,bc6c26818e15..000000000000
--- a/drivers/gpu/drm/i915/display/intel_sdvo.c
+++ b/drivers/gpu/drm/i915/display/intel_sdvo.c
@@@ -1893,8 -1937,9 +1893,14 @@@ static void intel_sdvo_enable_hotplug(s
  			     &intel_sdvo->hotplug_active, 2);
  }
  
++<<<<<<< HEAD
 +static bool intel_sdvo_hotplug(struct intel_encoder *encoder,
 +			       struct intel_connector *connector)
++=======
+ static enum intel_hotplug_state
+ intel_sdvo_hotplug(struct intel_encoder *encoder,
+ 		   struct intel_connector *connector)
++>>>>>>> 8c8919c7c99f (drm/i915: Add a retry counter for hotplug detect retries)
  {
  	intel_sdvo_enable_hotplug(encoder);
  
diff --cc drivers/gpu/drm/i915/intel_drv.h
index e86655c972a8,5a0adf14ebef..000000000000
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@@ -106,9 -129,10 +106,16 @@@ struct intel_encoder 
  
  	enum intel_output_type type;
  	enum port port;
++<<<<<<< HEAD:drivers/gpu/drm/i915/intel_drv.h
 +	unsigned int cloneable;
 +	bool (*hotplug)(struct intel_encoder *encoder,
 +			struct intel_connector *connector);
++=======
+ 	u16 cloneable;
+ 	u8 pipe_mask;
+ 	enum intel_hotplug_state (*hotplug)(struct intel_encoder *encoder,
+ 					    struct intel_connector *connector);
++>>>>>>> 8c8919c7c99f (drm/i915: Add a retry counter for hotplug detect retries):drivers/gpu/drm/i915/display/intel_display_types.h
  	enum intel_output_type (*compute_output_type)(struct intel_encoder *,
  						      struct intel_crtc_state *,
  						      struct drm_connector_state *);
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.c
* Unmerged path drivers/gpu/drm/i915/display/intel_dp.c
* Unmerged path drivers/gpu/drm/i915/display/intel_hdmi.c
* Unmerged path drivers/gpu/drm/i915/display/intel_hotplug.c
* Unmerged path drivers/gpu/drm/i915/display/intel_hotplug.h
* Unmerged path drivers/gpu/drm/i915/display/intel_sdvo.c
* Unmerged path drivers/gpu/drm/i915/intel_drv.h
