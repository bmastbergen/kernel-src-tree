KVM: s390: Also reset registers in sync regs for initial cpu reset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Christian Borntraeger <borntraeger@de.ibm.com>
commit e93fc7b4544a5475cfdbc22f87e89f9829bf801c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e93fc7b4.failed

When we do the initial CPU reset we must not only clear the registers
in the internal data structures but also in kvm_run sync_regs. For
modern userspace sync_regs is the only place that it looks at.

Fixes: 7de3f1423ff9 ("KVM: s390: Add new reset vcpu API")
	Acked-by: David Hildenbrand <david@redhat.com>
	Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
(cherry picked from commit e93fc7b4544a5475cfdbc22f87e89f9829bf801c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kvm/kvm-s390.c
diff --cc arch/s390/kvm/kvm-s390.c
index 10dc0c88936f,c2e6d4ba4e23..000000000000
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@@ -3296,10 -3251,69 +3296,74 @@@ static int kvm_arch_vcpu_ioctl_set_one_
  	return r;
  }
  
 -static void kvm_arch_vcpu_ioctl_normal_reset(struct kvm_vcpu *vcpu)
 +static int kvm_arch_vcpu_ioctl_initial_reset(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	kvm_s390_vcpu_initial_reset(vcpu);
 +	return 0;
++=======
+ 	vcpu->arch.sie_block->gpsw.mask &= ~PSW_MASK_RI;
+ 	vcpu->arch.pfault_token = KVM_S390_PFAULT_TOKEN_INVALID;
+ 	memset(vcpu->run->s.regs.riccb, 0, sizeof(vcpu->run->s.regs.riccb));
+ 
+ 	kvm_clear_async_pf_completion_queue(vcpu);
+ 	if (!kvm_s390_user_cpu_state_ctrl(vcpu->kvm))
+ 		kvm_s390_vcpu_stop(vcpu);
+ 	kvm_s390_clear_local_irqs(vcpu);
+ }
+ 
+ static void kvm_arch_vcpu_ioctl_initial_reset(struct kvm_vcpu *vcpu)
+ {
+ 	/* Initial reset is a superset of the normal reset */
+ 	kvm_arch_vcpu_ioctl_normal_reset(vcpu);
+ 
+ 	/*
+ 	 * This equals initial cpu reset in pop, but we don't switch to ESA.
+ 	 * We do not only reset the internal data, but also ...
+ 	 */
+ 	vcpu->arch.sie_block->gpsw.mask = 0;
+ 	vcpu->arch.sie_block->gpsw.addr = 0;
+ 	kvm_s390_set_prefix(vcpu, 0);
+ 	kvm_s390_set_cpu_timer(vcpu, 0);
+ 	vcpu->arch.sie_block->ckc = 0;
+ 	vcpu->arch.sie_block->todpr = 0;
+ 	memset(vcpu->arch.sie_block->gcr, 0, sizeof(vcpu->arch.sie_block->gcr));
+ 	vcpu->arch.sie_block->gcr[0] = CR0_INITIAL_MASK;
+ 	vcpu->arch.sie_block->gcr[14] = CR14_INITIAL_MASK;
+ 
+ 	/* ... the data in sync regs */
+ 	memset(vcpu->run->s.regs.crs, 0, sizeof(vcpu->run->s.regs.crs));
+ 	vcpu->run->s.regs.ckc = 0;
+ 	vcpu->run->s.regs.crs[0] = CR0_INITIAL_MASK;
+ 	vcpu->run->s.regs.crs[14] = CR14_INITIAL_MASK;
+ 	vcpu->run->psw_addr = 0;
+ 	vcpu->run->psw_mask = 0;
+ 	vcpu->run->s.regs.todpr = 0;
+ 	vcpu->run->s.regs.cputm = 0;
+ 	vcpu->run->s.regs.ckc = 0;
+ 	vcpu->run->s.regs.pp = 0;
+ 	vcpu->run->s.regs.gbea = 1;
+ 	vcpu->run->s.regs.fpc = 0;
+ 	vcpu->arch.sie_block->gbea = 1;
+ 	vcpu->arch.sie_block->pp = 0;
+ 	vcpu->arch.sie_block->fpf &= ~FPF_BPBC;
+ }
+ 
+ static void kvm_arch_vcpu_ioctl_clear_reset(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_sync_regs *regs = &vcpu->run->s.regs;
+ 
+ 	/* Clear reset is a superset of the initial reset */
+ 	kvm_arch_vcpu_ioctl_initial_reset(vcpu);
+ 
+ 	memset(&regs->gprs, 0, sizeof(regs->gprs));
+ 	memset(&regs->vrs, 0, sizeof(regs->vrs));
+ 	memset(&regs->acrs, 0, sizeof(regs->acrs));
+ 	memset(&regs->gscb, 0, sizeof(regs->gscb));
+ 
+ 	regs->etoken = 0;
+ 	regs->etoken_extension = 0;
++>>>>>>> e93fc7b4544a (KVM: s390: Also reset registers in sync regs for initial cpu reset)
  }
  
  int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
* Unmerged path arch/s390/kvm/kvm-s390.c
