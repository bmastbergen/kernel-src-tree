libbpf: Don't use kernel-side u32 type in xsk.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit a566e35f1e8b4b3be1e96a804d1cca38b578167c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a566e35f.failed

u32 is a kernel-side typedef. User-space library is supposed to use __u32.
This breaks Github's projection of libbpf. Do u32 -> __u32 fix.

Fixes: 94ff9ebb49a5 ("libbpf: Fix compatibility for kernels without need_wakeup")
	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Björn Töpel <bjorn.topel@intel.com>
	Cc: Magnus Karlsson <magnus.karlsson@intel.com>
Link: https://lore.kernel.org/bpf/20191029055953.2461336-1-andriin@fb.com
(cherry picked from commit a566e35f1e8b4b3be1e96a804d1cca38b578167c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/xsk.c
diff --cc tools/lib/bpf/xsk.c
index 3912e8624945,74d84f36a5b2..000000000000
--- a/tools/lib/bpf/xsk.c
+++ b/tools/lib/bpf/xsk.c
@@@ -131,9 -148,62 +131,68 @@@ static int xsk_set_xdp_socket_config(st
  	return 0;
  }
  
++<<<<<<< HEAD
 +int xsk_umem__create(struct xsk_umem **umem_ptr, void *umem_area, __u64 size,
 +		     struct xsk_ring_prod *fill, struct xsk_ring_cons *comp,
 +		     const struct xsk_umem_config *usr_config)
++=======
+ static void xsk_mmap_offsets_v1(struct xdp_mmap_offsets *off)
+ {
+ 	struct xdp_mmap_offsets_v1 off_v1;
+ 
+ 	/* getsockopt on a kernel <= 5.3 has no flags fields.
+ 	 * Copy over the offsets to the correct places in the >=5.4 format
+ 	 * and put the flags where they would have been on that kernel.
+ 	 */
+ 	memcpy(&off_v1, off, sizeof(off_v1));
+ 
+ 	off->rx.producer = off_v1.rx.producer;
+ 	off->rx.consumer = off_v1.rx.consumer;
+ 	off->rx.desc = off_v1.rx.desc;
+ 	off->rx.flags = off_v1.rx.consumer + sizeof(__u32);
+ 
+ 	off->tx.producer = off_v1.tx.producer;
+ 	off->tx.consumer = off_v1.tx.consumer;
+ 	off->tx.desc = off_v1.tx.desc;
+ 	off->tx.flags = off_v1.tx.consumer + sizeof(__u32);
+ 
+ 	off->fr.producer = off_v1.fr.producer;
+ 	off->fr.consumer = off_v1.fr.consumer;
+ 	off->fr.desc = off_v1.fr.desc;
+ 	off->fr.flags = off_v1.fr.consumer + sizeof(__u32);
+ 
+ 	off->cr.producer = off_v1.cr.producer;
+ 	off->cr.consumer = off_v1.cr.consumer;
+ 	off->cr.desc = off_v1.cr.desc;
+ 	off->cr.flags = off_v1.cr.consumer + sizeof(__u32);
+ }
+ 
+ static int xsk_get_mmap_offsets(int fd, struct xdp_mmap_offsets *off)
+ {
+ 	socklen_t optlen;
+ 	int err;
+ 
+ 	optlen = sizeof(*off);
+ 	err = getsockopt(fd, SOL_XDP, XDP_MMAP_OFFSETS, off, &optlen);
+ 	if (err)
+ 		return err;
+ 
+ 	if (optlen == sizeof(*off))
+ 		return 0;
+ 
+ 	if (optlen == sizeof(struct xdp_mmap_offsets_v1)) {
+ 		xsk_mmap_offsets_v1(off);
+ 		return 0;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ int xsk_umem__create_v0_0_4(struct xsk_umem **umem_ptr, void *umem_area,
+ 			    __u64 size, struct xsk_ring_prod *fill,
+ 			    struct xsk_ring_cons *comp,
+ 			    const struct xsk_umem_config *usr_config)
++>>>>>>> a566e35f1e8b (libbpf: Don't use kernel-side u32 type in xsk.c)
  {
  	struct xdp_mmap_offsets off;
  	struct xdp_umem_reg mr;
* Unmerged path tools/lib/bpf/xsk.c
