net: add queue argument to __skb_wait_for_more_packets and __skb_{,try_}recv_datagram

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] add queue argument to __skb_wait_for_more_packets and __skb_{, try_}recv_datagram (Sabrina Dubroca) [1446392]
Rebuild_FUZZ: 96.39%
commit-author Sabrina Dubroca <sd@queasysnail.net>
commit b50b0580d27bc45a0637aefc8bac4d31aa85771a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b50b0580.failed

This will be used by ESP over TCP to handle the queue of IKE messages.

	Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
	Acked-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit b50b0580d27bc45a0637aefc8bac4d31aa85771a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/datagram.c
#	net/unix/af_unix.c
diff --cc net/core/datagram.c
index 98a524a31eb3,a78e7f864c1e..000000000000
--- a/net/core/datagram.c
+++ b/net/core/datagram.c
@@@ -208,9 -210,9 +209,10 @@@ struct sk_buff *__skb_try_recv_from_que
  /**
   *	__skb_try_recv_datagram - Receive a datagram skbuff
   *	@sk: socket
+  *	@queue: socket queue from which to receive
   *	@flags: MSG\_ flags
   *	@destructor: invoked under the receive lock on successful dequeue
 + *	@peeked: returns non-zero if this packet has been seen before
   *	@off: an offset in bytes to peek skb from. Returns an offset
   *	      within an skb where data actually starts
   *	@err: error code returned
@@@ -241,13 -243,14 +243,14 @@@
   *	quite explicitly by POSIX 1003.1g, don't change them without having
   *	the standard around please.
   */
- struct sk_buff *__skb_try_recv_datagram(struct sock *sk, unsigned int flags,
+ struct sk_buff *__skb_try_recv_datagram(struct sock *sk,
+ 					struct sk_buff_head *queue,
+ 					unsigned int flags,
  					void (*destructor)(struct sock *sk,
  							   struct sk_buff *skb),
 -					int *off, int *err,
 +					int *peeked, int *off, int *err,
  					struct sk_buff **last)
  {
- 	struct sk_buff_head *queue = &sk->sk_receive_queue;
  	struct sk_buff *skb;
  	unsigned long cpu_flags;
  	/*
@@@ -279,7 -281,7 +282,11 @@@
  			break;
  
  		sk_busy_loop(sk, flags & MSG_DONTWAIT);
++<<<<<<< HEAD
 +	} while (sk->sk_receive_queue.prev != *last);
++=======
+ 	} while (READ_ONCE(queue->prev) != *last);
++>>>>>>> b50b0580d27b (net: add queue argument to __skb_wait_for_more_packets and __skb_{,try_}recv_datagram)
  
  	error = -EAGAIN;
  
@@@ -289,10 -291,12 +296,12 @@@ no_packet
  }
  EXPORT_SYMBOL(__skb_try_recv_datagram);
  
- struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,
+ struct sk_buff *__skb_recv_datagram(struct sock *sk,
+ 				    struct sk_buff_head *sk_queue,
+ 				    unsigned int flags,
  				    void (*destructor)(struct sock *sk,
  						       struct sk_buff *skb),
 -				    int *off, int *err)
 +				    int *peeked, int *off, int *err)
  {
  	struct sk_buff *skb, *last;
  	long timeo;
@@@ -300,7 -304,7 +309,11 @@@
  	timeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);
  
  	do {
++<<<<<<< HEAD
 +		skb = __skb_try_recv_datagram(sk, flags, destructor, peeked,
++=======
+ 		skb = __skb_try_recv_datagram(sk, sk_queue, flags, destructor,
++>>>>>>> b50b0580d27b (net: add queue argument to __skb_wait_for_more_packets and __skb_{,try_}recv_datagram)
  					      off, err, &last);
  		if (skb)
  			return skb;
@@@ -317,10 -322,11 +331,16 @@@ EXPORT_SYMBOL(__skb_recv_datagram)
  struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned int flags,
  				  int noblock, int *err)
  {
 -	int off = 0;
 +	int peeked, off = 0;
  
++<<<<<<< HEAD
 +	return __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
 +				   NULL, &peeked, &off, err);
++=======
+ 	return __skb_recv_datagram(sk, &sk->sk_receive_queue,
+ 				   flags | (noblock ? MSG_DONTWAIT : 0),
+ 				   NULL, &off, err);
++>>>>>>> b50b0580d27b (net: add queue argument to __skb_wait_for_more_packets and __skb_{,try_}recv_datagram)
  }
  EXPORT_SYMBOL(skb_recv_datagram);
  
diff --cc net/unix/af_unix.c
index 2a031922ce3c,a7f707fc4cac..000000000000
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@@ -2036,8 -2058,8 +2036,13 @@@ static int unix_dgram_recvmsg(struct so
  		mutex_lock(&u->iolock);
  
  		skip = sk_peek_offset(sk, flags);
++<<<<<<< HEAD
 +		skb = __skb_try_recv_datagram(sk, flags, NULL, &peeked, &skip,
 +					      &err, &last);
++=======
+ 		skb = __skb_try_recv_datagram(sk, &sk->sk_receive_queue, flags,
+ 					      NULL, &skip, &err, &last);
++>>>>>>> b50b0580d27b (net: add queue argument to __skb_wait_for_more_packets and __skb_{,try_}recv_datagram)
  		if (skb)
  			break;
  
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 30aad86463b9..b59f172e43ec 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -3514,7 +3514,8 @@ static inline void skb_frag_list_init(struct sk_buff *skb)
 	for (iter = skb_shinfo(skb)->frag_list; iter; iter = iter->next)
 
 
-int __skb_wait_for_more_packets(struct sock *sk, int *err, long *timeo_p,
+int __skb_wait_for_more_packets(struct sock *sk, struct sk_buff_head *queue,
+				int *err, long *timeo_p,
 				const struct sk_buff *skb);
 struct sk_buff *__skb_try_recv_from_queue(struct sock *sk,
 					  struct sk_buff_head *queue,
@@ -3523,12 +3524,16 @@ struct sk_buff *__skb_try_recv_from_queue(struct sock *sk,
 							   struct sk_buff *skb),
 					  int *peeked, int *off, int *err,
 					  struct sk_buff **last);
-struct sk_buff *__skb_try_recv_datagram(struct sock *sk, unsigned flags,
+struct sk_buff *__skb_try_recv_datagram(struct sock *sk,
+					struct sk_buff_head *queue,
+					unsigned int flags,
 					void (*destructor)(struct sock *sk,
 							   struct sk_buff *skb),
 					int *peeked, int *off, int *err,
 					struct sk_buff **last);
-struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
+struct sk_buff *__skb_recv_datagram(struct sock *sk,
+				    struct sk_buff_head *sk_queue,
+				    unsigned int flags,
 				    void (*destructor)(struct sock *sk,
 						       struct sk_buff *skb),
 				    int *peeked, int *off, int *err);
* Unmerged path net/core/datagram.c
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 50f5c7dfecad..18ec97654561 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -1689,7 +1689,8 @@ struct sk_buff *__skb_recv_udp(struct sock *sk, unsigned int flags,
 
 		/* sk_queue is empty, reader_queue may contain peeked packets */
 	} while (timeo &&
-		 !__skb_wait_for_more_packets(sk, &error, &timeo,
+		 !__skb_wait_for_more_packets(sk, &sk->sk_receive_queue,
+					      &error, &timeo,
 					      (struct sk_buff *)sk_queue));
 
 	*err = error;
* Unmerged path net/unix/af_unix.c
