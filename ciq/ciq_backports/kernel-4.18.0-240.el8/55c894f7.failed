net: fib_notifier: propagate possible error during fib notifier registration

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] fib_notifier: propagate possible error during fib notifier registration (Petr Oros) [1805951]
Rebuild_FUZZ: 96.60%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 55c894f762a1a99fca80ee55d593083d78e7e4fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/55c894f7.failed

Unlike events for registered notifier, during the registration, the
errors that happened for the block being registered are not propagated
up to the caller. Make sure the error is propagated for FIB rules and
entries.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 55c894f762a1a99fca80ee55d593083d78e7e4fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip_fib.h
#	net/core/fib_rules.c
#	net/ipv4/fib_trie.c
#	net/ipv4/ipmr_base.c
#	net/ipv6/ip6_fib.c
diff --cc include/net/ip_fib.h
index cf0696685354,05c1fd9c5e23..000000000000
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@@ -211,7 -228,8 +211,12 @@@ int call_fib4_notifiers(struct net *net
  int __net_init fib4_notifier_init(struct net *net);
  void __net_exit fib4_notifier_exit(struct net *net);
  
++<<<<<<< HEAD
 +void fib_notify(struct net *net, struct notifier_block *nb);
++=======
+ void fib_info_notify_update(struct net *net, struct nl_info *info);
+ int fib_notify(struct net *net, struct notifier_block *nb);
++>>>>>>> 55c894f762a1 (net: fib_notifier: propagate possible error during fib notifier registration)
  
  struct fib_table {
  	struct hlist_node	tb_hlist;
diff --cc net/core/fib_rules.c
index 390d8b5d62ef,592d8aef90e3..000000000000
--- a/net/core/fib_rules.c
+++ b/net/core/fib_rules.c
@@@ -361,12 -359,15 +362,21 @@@ int fib_rules_dump(struct net *net, str
  	ops = lookup_rules_ops(net, family);
  	if (!ops)
  		return -EAFNOSUPPORT;
++<<<<<<< HEAD
 +	list_for_each_entry_rcu(rule, &ops->rules_list, list)
 +		call_fib_rule_notifier(nb, net, FIB_EVENT_RULE_ADD, rule,
 +				       family);
++=======
+ 	list_for_each_entry_rcu(rule, &ops->rules_list, list) {
+ 		err = call_fib_rule_notifier(nb, FIB_EVENT_RULE_ADD,
+ 					     rule, family);
+ 		if (err)
+ 			break;
+ 	}
++>>>>>>> 55c894f762a1 (net: fib_notifier: propagate possible error during fib notifier registration)
  	rules_ops_put(ops);
  
- 	return 0;
+ 	return err;
  }
  EXPORT_SYMBOL_GPL(fib_rules_dump);
  
diff --cc net/ipv4/fib_trie.c
index cbaed1062674,568e59423773..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -1942,11 -1944,83 +1942,88 @@@ int fib_table_flush(struct net *net, st
  	return found;
  }
  
++<<<<<<< HEAD
 +static void fib_leaf_notify(struct net *net, struct key_vector *l,
 +			    struct fib_table *tb, struct notifier_block *nb)
++=======
+ /* derived from fib_trie_free */
+ static void __fib_info_notify_update(struct net *net, struct fib_table *tb,
+ 				     struct nl_info *info)
  {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *pn = t->kv;
+ 	unsigned long cindex = 1;
  	struct fib_alias *fa;
  
+ 	for (;;) {
+ 		struct key_vector *n;
+ 
+ 		if (!(cindex--)) {
+ 			t_key pkey = pn->key;
+ 
+ 			if (IS_TRIE(pn))
+ 				break;
+ 
+ 			pn = node_parent(pn);
+ 			cindex = get_index(pkey, pn);
+ 			continue;
+ 		}
+ 
+ 		/* grab the next available node */
+ 		n = get_child(pn, cindex);
+ 		if (!n)
+ 			continue;
+ 
+ 		if (IS_TNODE(n)) {
+ 			/* record pn and cindex for leaf walking */
+ 			pn = n;
+ 			cindex = 1ul << n->bits;
+ 
+ 			continue;
+ 		}
+ 
+ 		hlist_for_each_entry(fa, &n->leaf, fa_list) {
+ 			struct fib_info *fi = fa->fa_info;
+ 
+ 			if (!fi || !fi->nh_updated || fa->tb_id != tb->tb_id)
+ 				continue;
+ 
+ 			rtmsg_fib(RTM_NEWROUTE, htonl(n->key), fa,
+ 				  KEYLENGTH - fa->fa_slen, tb->tb_id,
+ 				  info, NLM_F_REPLACE);
+ 
+ 			/* call_fib_entry_notifiers will be removed when
+ 			 * in-kernel notifier is implemented and supported
+ 			 * for nexthop objects
+ 			 */
+ 			call_fib_entry_notifiers(net, FIB_EVENT_ENTRY_REPLACE,
+ 						 n->key,
+ 						 KEYLENGTH - fa->fa_slen, fa,
+ 						 NULL);
+ 		}
+ 	}
+ }
+ 
+ void fib_info_notify_update(struct net *net, struct nl_info *info)
+ {
+ 	unsigned int h;
+ 
+ 	for (h = 0; h < FIB_TABLE_HASHSZ; h++) {
+ 		struct hlist_head *head = &net->ipv4.fib_table_hash[h];
+ 		struct fib_table *tb;
+ 
+ 		hlist_for_each_entry_rcu(tb, head, tb_hlist)
+ 			__fib_info_notify_update(net, tb, info);
+ 	}
+ }
+ 
+ static int fib_leaf_notify(struct key_vector *l, struct fib_table *tb,
+ 			   struct notifier_block *nb)
++>>>>>>> 55c894f762a1 (net: fib_notifier: propagate possible error during fib notifier registration)
+ {
+ 	struct fib_alias *fa;
+ 	int err;
+ 
  	hlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {
  		struct fib_info *fi = fa->fa_info;
  
@@@ -1959,20 -2033,25 +2036,39 @@@
  		if (tb->tb_id != fa->tb_id)
  			continue;
  
++<<<<<<< HEAD
 +		call_fib_entry_notifier(nb, net, FIB_EVENT_ENTRY_ADD, l->key,
 +					KEYLENGTH - fa->fa_slen, fa);
++=======
+ 		err = call_fib_entry_notifier(nb, FIB_EVENT_ENTRY_ADD, l->key,
+ 					      KEYLENGTH - fa->fa_slen, fa);
+ 		if (err)
+ 			return err;
++>>>>>>> 55c894f762a1 (net: fib_notifier: propagate possible error during fib notifier registration)
  	}
+ 	return 0;
  }
  
++<<<<<<< HEAD
 +static void fib_table_notify(struct net *net, struct fib_table *tb,
 +			     struct notifier_block *nb)
++=======
+ static int fib_table_notify(struct fib_table *tb, struct notifier_block *nb)
++>>>>>>> 55c894f762a1 (net: fib_notifier: propagate possible error during fib notifier registration)
  {
  	struct trie *t = (struct trie *)tb->tb_data;
  	struct key_vector *l, *tp = t->kv;
  	t_key key = 0;
+ 	int err;
  
  	while ((l = leaf_walk_rcu(&tp, key)) != NULL) {
++<<<<<<< HEAD
 +		fib_leaf_notify(net, l, tb, nb);
++=======
+ 		err = fib_leaf_notify(l, tb, nb);
+ 		if (err)
+ 			return err;
++>>>>>>> 55c894f762a1 (net: fib_notifier: propagate possible error during fib notifier registration)
  
  		key = l->key + 1;
  		/* stop in case of wrap around */
@@@ -1989,9 -2070,13 +2087,18 @@@ int fib_notify(struct net *net, struct 
  		struct hlist_head *head = &net->ipv4.fib_table_hash[h];
  		struct fib_table *tb;
  
++<<<<<<< HEAD
 +		hlist_for_each_entry_rcu(tb, head, tb_hlist)
 +			fib_table_notify(net, tb, nb);
++=======
+ 		hlist_for_each_entry_rcu(tb, head, tb_hlist) {
+ 			err = fib_table_notify(tb, nb);
+ 			if (err)
+ 				return err;
+ 		}
++>>>>>>> 55c894f762a1 (net: fib_notifier: propagate possible error during fib notifier registration)
  	}
+ 	return 0;
  }
  
  static void __trie_free_rcu(struct rcu_head *head)
diff --cc net/ipv4/ipmr_base.c
index ea48bd15a575,c4e23c2a0d5c..000000000000
--- a/net/ipv4/ipmr_base.c
+++ b/net/ipv4/ipmr_base.c
@@@ -409,17 -409,25 +409,38 @@@ int mr_dump(struct net *net, struct not
  			if (!v->dev)
  				continue;
  
++<<<<<<< HEAD
 +			mr_call_vif_notifier(nb, net, family,
 +					     FIB_EVENT_VIF_ADD,
 +					     v, vifi, mrt->id);
++=======
+ 			err = mr_call_vif_notifier(nb, family,
+ 						   FIB_EVENT_VIF_ADD,
+ 						   v, vifi, mrt->id);
+ 			if (err)
+ 				break;
++>>>>>>> 55c894f762a1 (net: fib_notifier: propagate possible error during fib notifier registration)
  		}
  		read_unlock(mrt_lock);
  
+ 		if (err)
+ 			return err;
+ 
  		/* Notify on table MFC entries */
++<<<<<<< HEAD
 +		list_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list)
 +			mr_call_mfc_notifier(nb, net, family,
 +					     FIB_EVENT_ENTRY_ADD,
 +					     mfc, mrt->id);
++=======
+ 		list_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list) {
+ 			err = mr_call_mfc_notifier(nb, family,
+ 						   FIB_EVENT_ENTRY_ADD,
+ 						   mfc, mrt->id);
+ 			if (err)
+ 				return err;
+ 		}
++>>>>>>> 55c894f762a1 (net: fib_notifier: propagate possible error during fib notifier registration)
  	}
  
  	return 0;
diff --cc net/ipv6/ip6_fib.c
index 246c67f714a3,76124a909395..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -420,11 -403,11 +420,16 @@@ struct fib6_dump_arg 
  	struct notifier_block *nb;
  };
  
- static void fib6_rt_dump(struct fib6_info *rt, struct fib6_dump_arg *arg)
+ static int fib6_rt_dump(struct fib6_info *rt, struct fib6_dump_arg *arg)
  {
  	if (rt == arg->net->ipv6.fib6_null_entry)
++<<<<<<< HEAD
 +		return;
 +	call_fib6_entry_notifier(arg->nb, arg->net, FIB_EVENT_ENTRY_ADD, rt);
++=======
+ 		return 0;
+ 	return call_fib6_entry_notifier(arg->nb, FIB_EVENT_ENTRY_ADD, rt);
++>>>>>>> 55c894f762a1 (net: fib_notifier: propagate possible error during fib notifier registration)
  }
  
  static int fib6_node_dump(struct fib6_walker *w)
* Unmerged path include/net/ip_fib.h
* Unmerged path net/core/fib_rules.c
diff --git a/net/ipv4/fib_notifier.c b/net/ipv4/fib_notifier.c
index b804ccbdb241..0b37ec6a7419 100644
--- a/net/ipv4/fib_notifier.c
+++ b/net/ipv4/fib_notifier.c
@@ -42,9 +42,7 @@ static int fib4_dump(struct net *net, struct notifier_block *nb)
 	if (err)
 		return err;
 
-	fib_notify(net, nb);
-
-	return 0;
+	return fib_notify(net, nb);
 }
 
 static const struct fib_notifier_ops fib4_notifier_ops_template = {
* Unmerged path net/ipv4/fib_trie.c
* Unmerged path net/ipv4/ipmr_base.c
* Unmerged path net/ipv6/ip6_fib.c
