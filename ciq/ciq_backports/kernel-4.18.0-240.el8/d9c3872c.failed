KVM: arm64: GICv4.1: Reload VLPI configuration on distributor enable/disable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Marc Zyngier <maz@kernel.org>
commit d9c3872cd2f86b7295446e35b4801270669d2960
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d9c3872c.failed

Each time a Group-enable bit gets flipped, the state of these bits
needs to be forwarded to the hardware. This is a pretty heavy
handed operation, requiring all vcpus to reload their GICv4
configuration. It is thus implemented as a new request type.

These enable bits are programmed into the HW by setting the VGrp{0,1}En
fields of GICR_VPENDBASER when the vPEs are made resident again.

Of course, we only support Group-1 for now...

	Signed-off-by: Marc Zyngier <maz@kernel.org>
	Reviewed-by: Zenghui Yu <yuzenghui@huawei.com>
Link: https://lore.kernel.org/r/20200304203330.4967-22-maz@kernel.org
(cherry picked from commit d9c3872cd2f86b7295446e35b4801270669d2960)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/include/asm/kvm_host.h
#	arch/arm64/include/asm/kvm_host.h
#	virt/kvm/arm/arm.c
diff --cc arch/arm/include/asm/kvm_host.h
index e5c90cf571a6,3da57e863df6..000000000000
--- a/arch/arm/include/asm/kvm_host.h
+++ b/arch/arm/include/asm/kvm_host.h
@@@ -50,6 -38,8 +50,11 @@@
  	KVM_ARCH_REQ_FLAGS(0, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)
  #define KVM_REQ_IRQ_PENDING	KVM_ARCH_REQ(1)
  #define KVM_REQ_VCPU_RESET	KVM_ARCH_REQ(2)
++<<<<<<< HEAD
++=======
+ #define KVM_REQ_RECORD_STEAL	KVM_ARCH_REQ(3)
+ #define KVM_REQ_RELOAD_GICv4	KVM_ARCH_REQ(4)
++>>>>>>> d9c3872cd2f8 (KVM: arm64: GICv4.1: Reload VLPI configuration on distributor enable/disable)
  
  DECLARE_STATIC_KEY_FALSE(userspace_irqchip_in_use);
  
diff --cc arch/arm64/include/asm/kvm_host.h
index 4dd101adad0d,32c8a675e5a4..000000000000
--- a/arch/arm64/include/asm/kvm_host.h
+++ b/arch/arm64/include/asm/kvm_host.h
@@@ -54,6 -43,8 +54,11 @@@
  	KVM_ARCH_REQ_FLAGS(0, KVM_REQUEST_WAIT | KVM_REQUEST_NO_WAKEUP)
  #define KVM_REQ_IRQ_PENDING	KVM_ARCH_REQ(1)
  #define KVM_REQ_VCPU_RESET	KVM_ARCH_REQ(2)
++<<<<<<< HEAD
++=======
+ #define KVM_REQ_RECORD_STEAL	KVM_ARCH_REQ(3)
+ #define KVM_REQ_RELOAD_GICv4	KVM_ARCH_REQ(4)
++>>>>>>> d9c3872cd2f8 (KVM: arm64: GICv4.1: Reload VLPI configuration on distributor enable/disable)
  
  DECLARE_STATIC_KEY_FALSE(userspace_irqchip_in_use);
  
diff --cc virt/kvm/arm/arm.c
index 616f7c6b13b9,4d864f857ac8..000000000000
--- a/virt/kvm/arm/arm.c
+++ b/virt/kvm/arm/arm.c
@@@ -647,6 -622,17 +647,20 @@@ static void check_vcpu_requests(struct 
  		 * that a VCPU sees new virtual interrupts.
  		 */
  		kvm_check_request(KVM_REQ_IRQ_PENDING, vcpu);
++<<<<<<< HEAD
++=======
+ 
+ 		if (kvm_check_request(KVM_REQ_RECORD_STEAL, vcpu))
+ 			kvm_update_stolen_time(vcpu);
+ 
+ 		if (kvm_check_request(KVM_REQ_RELOAD_GICv4, vcpu)) {
+ 			/* The distributor enable bits were changed */
+ 			preempt_disable();
+ 			vgic_v4_put(vcpu, false);
+ 			vgic_v4_load(vcpu);
+ 			preempt_enable();
+ 		}
++>>>>>>> d9c3872cd2f8 (KVM: arm64: GICv4.1: Reload VLPI configuration on distributor enable/disable)
  	}
  }
  
* Unmerged path arch/arm/include/asm/kvm_host.h
* Unmerged path arch/arm64/include/asm/kvm_host.h
* Unmerged path virt/kvm/arm/arm.c
diff --git a/virt/kvm/arm/vgic/vgic-mmio-v3.c b/virt/kvm/arm/vgic/vgic-mmio-v3.c
index 7eb0b3dfce65..5564c81a4e93 100644
--- a/virt/kvm/arm/vgic/vgic-mmio-v3.c
+++ b/virt/kvm/arm/vgic/vgic-mmio-v3.c
@@ -140,7 +140,10 @@ static void vgic_mmio_write_v3_misc(struct kvm_vcpu *vcpu,
 		if (is_hwsgi != dist->nassgireq)
 			vgic_v4_configure_vsgis(vcpu->kvm);
 
-		if (!was_enabled && dist->enabled)
+		if (kvm_vgic_global_state.has_gicv4_1 &&
+		    was_enabled != dist->enabled)
+			kvm_make_all_cpus_request(vcpu->kvm, KVM_REQ_RELOAD_GICv4);
+		else if (!was_enabled && dist->enabled)
 			vgic_kick_vcpus(vcpu->kvm);
 
 		mutex_unlock(&vcpu->kvm->lock);
