s390/qeth: refactor buffer pool code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 0f75e149298bedc48db03259a38a303611d247b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0f75e149.failed

In preparation for a subsequent fix, split out helpers to allocate/free
individual pool entries.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0f75e149298bedc48db03259a38a303611d247b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index bd154899d429,ceab3d0c4dfa..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -212,11 -211,54 +211,60 @@@ void qeth_clear_working_pool_list(struc
  }
  EXPORT_SYMBOL_GPL(qeth_clear_working_pool_list);
  
+ static void qeth_free_pool_entry(struct qeth_buffer_pool_entry *entry)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(entry->elements); i++) {
+ 		if (entry->elements[i])
+ 			__free_page(entry->elements[i]);
+ 	}
+ 
+ 	kfree(entry);
+ }
+ 
+ static void qeth_free_buffer_pool(struct qeth_card *card)
+ {
+ 	struct qeth_buffer_pool_entry *entry, *tmp;
+ 
+ 	list_for_each_entry_safe(entry, tmp, &card->qdio.init_pool.entry_list,
+ 				 init_list) {
+ 		list_del(&entry->init_list);
+ 		qeth_free_pool_entry(entry);
+ 	}
+ }
+ 
+ static struct qeth_buffer_pool_entry *qeth_alloc_pool_entry(unsigned int pages)
+ {
+ 	struct qeth_buffer_pool_entry *entry;
+ 	unsigned int i;
+ 
+ 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+ 	if (!entry)
+ 		return NULL;
+ 
+ 	for (i = 0; i < pages; i++) {
+ 		entry->elements[i] = alloc_page(GFP_KERNEL);
+ 
+ 		if (!entry->elements[i]) {
+ 			qeth_free_pool_entry(entry);
+ 			return NULL;
+ 		}
+ 	}
+ 
+ 	return entry;
+ }
+ 
  static int qeth_alloc_buffer_pool(struct qeth_card *card)
  {
++<<<<<<< HEAD
 +	struct qeth_buffer_pool_entry *pool_entry;
 +	void *ptr;
 +	int i, j;
++=======
+ 	unsigned int buf_elements = QETH_MAX_BUFFER_ELEMENTS(card);
+ 	unsigned int i;
++>>>>>>> 0f75e149298b (s390/qeth: refactor buffer pool code)
  
  	QETH_CARD_TEXT(card, 5, "alocpool");
  	for (i = 0; i < card->qdio.init_pool.buf_count; ++i) {
@@@ -225,20 -269,8 +275,25 @@@
  			qeth_free_buffer_pool(card);
  			return -ENOMEM;
  		}
++<<<<<<< HEAD
 +		for (j = 0; j < QETH_MAX_BUFFER_ELEMENTS(card); ++j) {
 +			ptr = (void *) __get_free_page(GFP_KERNEL);
 +			if (!ptr) {
 +				while (j > 0)
 +					free_page((unsigned long)
 +						  pool_entry->elements[--j]);
 +				kfree(pool_entry);
 +				qeth_free_buffer_pool(card);
 +				return -ENOMEM;
 +			}
 +			pool_entry->elements[j] = ptr;
 +		}
 +		list_add(&pool_entry->init_list,
 +			 &card->qdio.init_pool.entry_list);
++=======
+ 
+ 		list_add(&entry->init_list, &card->qdio.init_pool.entry_list);
++>>>>>>> 0f75e149298b (s390/qeth: refactor buffer pool code)
  	}
  	return 0;
  }
@@@ -1185,44 -1202,6 +1240,47 @@@ void qeth_drain_output_queues(struct qe
  }
  EXPORT_SYMBOL_GPL(qeth_drain_output_queues);
  
++<<<<<<< HEAD
 +static void qeth_free_buffer_pool(struct qeth_card *card)
 +{
 +	struct qeth_buffer_pool_entry *pool_entry, *tmp;
 +	int i = 0;
 +	list_for_each_entry_safe(pool_entry, tmp,
 +				 &card->qdio.init_pool.entry_list, init_list){
 +		for (i = 0; i < QETH_MAX_BUFFER_ELEMENTS(card); ++i)
 +			free_page((unsigned long)pool_entry->elements[i]);
 +		list_del(&pool_entry->init_list);
 +		kfree(pool_entry);
 +	}
 +}
 +
 +static void qeth_clean_channel(struct qeth_channel *channel)
 +{
 +	struct ccw_device *cdev = channel->ccwdev;
 +
 +	QETH_DBF_TEXT(SETUP, 2, "freech");
 +
 +	spin_lock_irq(get_ccwdev_lock(cdev));
 +	cdev->handler = NULL;
 +	spin_unlock_irq(get_ccwdev_lock(cdev));
 +}
 +
 +static void qeth_setup_channel(struct qeth_channel *channel)
 +{
 +	struct ccw_device *cdev = channel->ccwdev;
 +
 +	QETH_DBF_TEXT(SETUP, 2, "setupch");
 +
 +	channel->state = CH_STATE_DOWN;
 +	atomic_set(&channel->irq_pending, 0);
 +
 +	spin_lock_irq(get_ccwdev_lock(cdev));
 +	cdev->handler = qeth_irq;
 +	spin_unlock_irq(get_ccwdev_lock(cdev));
 +}
 +
++=======
++>>>>>>> 0f75e149298b (s390/qeth: refactor buffer pool code)
  static int qeth_osa_set_output_queues(struct qeth_card *card, bool single)
  {
  	unsigned int count = single ? 1 : card->dev->num_tx_queues;
* Unmerged path drivers/s390/net/qeth_core_main.c
