do_last(): fetch directory ->i_mode and ->i_uid before it's too late

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Al Viro <viro@zeniv.linux.org.uk>
commit d0cb50185ae942b03c4327be322055d622dc79f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d0cb5018.failed

may_create_in_sticky() call is done when we already have dropped the
reference to dir.

Fixes: 30aba6656f61e (namei: allow restricted O_CREAT of FIFOs and regular files)
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit d0cb50185ae942b03c4327be322055d622dc79f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namei.c
diff --cc fs/namei.c
index 941599119e24,4fb61e0754ed..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -997,6 -997,50 +997,53 @@@ static int may_linkat(struct path *link
  	return -EPERM;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * may_create_in_sticky - Check whether an O_CREAT open in a sticky directory
+  *			  should be allowed, or not, on files that already
+  *			  exist.
+  * @dir_mode: mode bits of directory
+  * @dir_uid: owner of directory
+  * @inode: the inode of the file to open
+  *
+  * Block an O_CREAT open of a FIFO (or a regular file) when:
+  *   - sysctl_protected_fifos (or sysctl_protected_regular) is enabled
+  *   - the file already exists
+  *   - we are in a sticky directory
+  *   - we don't own the file
+  *   - the owner of the directory doesn't own the file
+  *   - the directory is world writable
+  * If the sysctl_protected_fifos (or sysctl_protected_regular) is set to 2
+  * the directory doesn't have to be world writable: being group writable will
+  * be enough.
+  *
+  * Returns 0 if the open is allowed, -ve on error.
+  */
+ static int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,
+ 				struct inode * const inode)
+ {
+ 	if ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||
+ 	    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||
+ 	    likely(!(dir_mode & S_ISVTX)) ||
+ 	    uid_eq(inode->i_uid, dir_uid) ||
+ 	    uid_eq(current_fsuid(), inode->i_uid))
+ 		return 0;
+ 
+ 	if (likely(dir_mode & 0002) ||
+ 	    (dir_mode & 0020 &&
+ 	     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||
+ 	      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {
+ 		const char *operation = S_ISFIFO(inode->i_mode) ?
+ 					"sticky_create_fifo" :
+ 					"sticky_create_regular";
+ 		audit_log_path_denied(AUDIT_ANOM_CREAT, operation);
+ 		return -EACCES;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> d0cb50185ae9 (do_last(): fetch directory ->i_mode and ->i_uid before it's too late)
  static __always_inline
  const char *get_link(struct nameidata *nd)
  {
@@@ -3233,10 -3199,11 +3280,12 @@@ out_dput
   * Handle the last step of open()
   */
  static int do_last(struct nameidata *nd,
 -		   struct file *file, const struct open_flags *op)
 +		   struct file *file, const struct open_flags *op,
 +		   int *opened)
  {
  	struct dentry *dir = nd->path.dentry;
+ 	kuid_t dir_uid = dir->d_inode->i_uid;
+ 	umode_t dir_mode = dir->d_inode->i_mode;
  	int open_flag = op->open_flag;
  	bool will_truncate = (open_flag & O_TRUNC) != 0;
  	bool got_write = false;
@@@ -3368,9 -3330,15 +3417,21 @@@ finish_open
  	if (error)
  		return error;
  	audit_inode(nd->name, nd->path.dentry, 0);
++<<<<<<< HEAD
 +	error = -EISDIR;
 +	if ((open_flag & O_CREAT) && d_is_dir(nd->path.dentry))
 +		goto out;
++=======
+ 	if (open_flag & O_CREAT) {
+ 		error = -EISDIR;
+ 		if (d_is_dir(nd->path.dentry))
+ 			goto out;
+ 		error = may_create_in_sticky(dir_mode, dir_uid,
+ 					     d_backing_inode(nd->path.dentry));
+ 		if (unlikely(error))
+ 			goto out;
+ 	}
++>>>>>>> d0cb50185ae9 (do_last(): fetch directory ->i_mode and ->i_uid before it's too late)
  	error = -ENOTDIR;
  	if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))
  		goto out;
* Unmerged path fs/namei.c
