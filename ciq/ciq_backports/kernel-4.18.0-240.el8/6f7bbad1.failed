net/mlx5e: E-Switch, Specify flow_source for rule with no in_port

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jianbo Liu <jianbol@mellanox.com>
commit 6f7bbad18e8343da6318654f408dea0ccd6efb00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6f7bbad1.failed

The flow_source must be specified, even for rule without matching
source vport, because some actions are only allowed in uplink.
Otherwise, rule can't be offloaded and firmware syndrome happens.

Fixes: 6fb0701a9cfa ("net/mlx5: E-Switch, Add support for offloading rules with no in_port")
	Signed-off-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Chris Mi <chrism@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 6f7bbad18e8343da6318654f408dea0ccd6efb00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 98ef84b15725,ed75353c56b8..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -47,50 -50,200 +47,61 @@@
   * one for multicast.
   */
  #define MLX5_ESW_MISS_FLOWS (2)
 -#define UPLINK_REP_INDEX 0
 -
 -/* Per vport tables */
 -
 -#define MLX5_ESW_VPORT_TABLE_SIZE 128
 -
 -/* This struct is used as a key to the hash table and we need it to be packed
 - * so hash result is consistent
 - */
 -struct mlx5_vport_key {
 -	u32 chain;
 -	u16 prio;
 -	u16 vport;
 -	u16 vhca_id;
 -} __packed;
 -
 -struct mlx5_vport_table {
 -	struct hlist_node hlist;
 -	struct mlx5_flow_table *fdb;
 -	u32 num_rules;
 -	struct mlx5_vport_key key;
 -};
 -
 -#define MLX5_ESW_VPORT_TBL_NUM_GROUPS  4
 -
 -static struct mlx5_flow_table *
 -esw_vport_tbl_create(struct mlx5_eswitch *esw, struct mlx5_flow_namespace *ns)
 -{
 -	struct mlx5_flow_table_attr ft_attr = {};
 -	struct mlx5_flow_table *fdb;
 -
 -	ft_attr.autogroup.max_num_groups = MLX5_ESW_VPORT_TBL_NUM_GROUPS;
 -	ft_attr.max_fte = MLX5_ESW_VPORT_TABLE_SIZE;
 -	ft_attr.prio = FDB_PER_VPORT;
 -	fdb = mlx5_create_auto_grouped_flow_table(ns, &ft_attr);
 -	if (IS_ERR(fdb)) {
 -		esw_warn(esw->dev, "Failed to create per vport FDB Table err %ld\n",
 -			 PTR_ERR(fdb));
 -	}
  
 -	return fdb;
 -}
 +#define fdb_prio_table(esw, chain, prio, level) \
 +	(esw)->fdb_table.offloads.fdb_prio[(chain)][(prio)][(level)]
  
 -static u32 flow_attr_to_vport_key(struct mlx5_eswitch *esw,
 -				  struct mlx5_esw_flow_attr *attr,
 -				  struct mlx5_vport_key *key)
 -{
 -	key->vport = attr->in_rep->vport;
 -	key->chain = attr->chain;
 -	key->prio = attr->prio;
 -	key->vhca_id = MLX5_CAP_GEN(esw->dev, vhca_id);
 -	return jhash(key, sizeof(*key), 0);
 -}
 +#define UPLINK_REP_INDEX 0
  
 -/* caller must hold vports.lock */
 -static struct mlx5_vport_table *
 -esw_vport_tbl_lookup(struct mlx5_eswitch *esw, struct mlx5_vport_key *skey, u32 key)
 +static struct mlx5_eswitch_rep *mlx5_eswitch_get_rep(struct mlx5_eswitch *esw,
 +						     u16 vport_num)
  {
 -	struct mlx5_vport_table *e;
 -
 -	hash_for_each_possible(esw->fdb_table.offloads.vports.table, e, hlist, key)
 -		if (!memcmp(&e->key, skey, sizeof(*skey)))
 -			return e;
 +	int idx = mlx5_eswitch_vport_num_to_index(esw, vport_num);
  
 -	return NULL;
 +	WARN_ON(idx > esw->total_vports - 1);
 +	return &esw->offloads.vport_reps[idx];
  }
  
++<<<<<<< HEAD
 +static struct mlx5_flow_table *
 +esw_get_prio_table(struct mlx5_eswitch *esw, u32 chain, u16 prio, int level);
  static void
 -esw_vport_tbl_put(struct mlx5_eswitch *esw, struct mlx5_esw_flow_attr *attr)
 -{
 -	struct mlx5_vport_table *e;
 -	struct mlx5_vport_key key;
 -	u32 hkey;
 -
 -	mutex_lock(&esw->fdb_table.offloads.vports.lock);
 -	hkey = flow_attr_to_vport_key(esw, attr, &key);
 -	e = esw_vport_tbl_lookup(esw, &key, hkey);
 -	if (!e || --e->num_rules)
 -		goto out;
 +esw_put_prio_table(struct mlx5_eswitch *esw, u32 chain, u16 prio, int level);
  
 -	hash_del(&e->hlist);
 -	mlx5_destroy_flow_table(e->fdb);
 -	kfree(e);
 -out:
 -	mutex_unlock(&esw->fdb_table.offloads.vports.lock);
 -}
 -
 -static struct mlx5_flow_table *
 -esw_vport_tbl_get(struct mlx5_eswitch *esw, struct mlx5_esw_flow_attr *attr)
 +bool mlx5_eswitch_prios_supported(struct mlx5_eswitch *esw)
  {
 -	struct mlx5_core_dev *dev = esw->dev;
 -	struct mlx5_flow_namespace *ns;
 -	struct mlx5_flow_table *fdb;
 -	struct mlx5_vport_table *e;
 -	struct mlx5_vport_key skey;
 -	u32 hkey;
 -
 -	mutex_lock(&esw->fdb_table.offloads.vports.lock);
 -	hkey = flow_attr_to_vport_key(esw, attr, &skey);
 -	e = esw_vport_tbl_lookup(esw, &skey, hkey);
 -	if (e) {
 -		e->num_rules++;
 -		goto out;
 -	}
 -
 -	e = kzalloc(sizeof(*e), GFP_KERNEL);
 -	if (!e) {
 -		fdb = ERR_PTR(-ENOMEM);
 -		goto err_alloc;
 -	}
 -
 -	ns = mlx5_get_flow_namespace(dev, MLX5_FLOW_NAMESPACE_FDB);
 -	if (!ns) {
 -		esw_warn(dev, "Failed to get FDB namespace\n");
 -		fdb = ERR_PTR(-ENOENT);
 -		goto err_ns;
 -	}
 -
 -	fdb = esw_vport_tbl_create(esw, ns);
 -	if (IS_ERR(fdb))
 -		goto err_ns;
 -
 -	e->fdb = fdb;
 -	e->num_rules = 1;
 -	e->key = skey;
 -	hash_add(esw->fdb_table.offloads.vports.table, &e->hlist, hkey);
 -out:
 -	mutex_unlock(&esw->fdb_table.offloads.vports.lock);
 -	return e->fdb;
 -
 -err_ns:
 -	kfree(e);
 -err_alloc:
 -	mutex_unlock(&esw->fdb_table.offloads.vports.lock);
 -	return fdb;
 +	return (!!(esw->fdb_table.flags & ESW_FDB_CHAINS_AND_PRIOS_SUPPORTED));
  }
  
 -int mlx5_esw_vport_tbl_get(struct mlx5_eswitch *esw)
 +u32 mlx5_eswitch_get_chain_range(struct mlx5_eswitch *esw)
  {
 -	struct mlx5_esw_flow_attr attr = {};
 -	struct mlx5_eswitch_rep rep = {};
 -	struct mlx5_flow_table *fdb;
 -	struct mlx5_vport *vport;
 -	int i;
 +	if (esw->fdb_table.flags & ESW_FDB_CHAINS_AND_PRIOS_SUPPORTED)
 +		return FDB_MAX_CHAIN;
  
 -	attr.prio = 1;
 -	attr.in_rep = &rep;
 -	mlx5_esw_for_all_vports(esw, i, vport) {
 -		attr.in_rep->vport = vport->vport;
 -		fdb = esw_vport_tbl_get(esw, &attr);
 -		if (IS_ERR(fdb))
 -			goto out;
 -	}
  	return 0;
 -
 -out:
 -	mlx5_esw_vport_tbl_put(esw);
 -	return PTR_ERR(fdb);
  }
  
 -void mlx5_esw_vport_tbl_put(struct mlx5_eswitch *esw)
 +u32 mlx5_eswitch_get_ft_chain(struct mlx5_eswitch *esw)
  {
 -	struct mlx5_esw_flow_attr attr = {};
 -	struct mlx5_eswitch_rep rep = {};
 -	struct mlx5_vport *vport;
 -	int i;
 -
 -	attr.prio = 1;
 -	attr.in_rep = &rep;
 -	mlx5_esw_for_all_vports(esw, i, vport) {
 -		attr.in_rep->vport = vport->vport;
 -		esw_vport_tbl_put(esw, &attr);
 -	}
 +	return mlx5_eswitch_get_chain_range(esw) + 1;
  }
  
 -/* End: Per vport tables */
 -
 -static struct mlx5_eswitch_rep *mlx5_eswitch_get_rep(struct mlx5_eswitch *esw,
 -						     u16 vport_num)
 +u16 mlx5_eswitch_get_prio_range(struct mlx5_eswitch *esw)
  {
 -	int idx = mlx5_eswitch_vport_num_to_index(esw, vport_num);
 -
 -	WARN_ON(idx > esw->total_vports - 1);
 -	return &esw->offloads.vport_reps[idx];
 -}
 +	if (esw->fdb_table.flags & ESW_FDB_CHAINS_AND_PRIOS_SUPPORTED)
 +		return FDB_MAX_PRIO;
  
 +	return 1;
++=======
+ static void
+ mlx5_eswitch_set_rule_flow_source(struct mlx5_eswitch *esw,
+ 				  struct mlx5_flow_spec *spec,
+ 				  struct mlx5_esw_flow_attr *attr)
+ {
+ 	if (MLX5_CAP_ESW_FLOWTABLE(esw->dev, flow_source) &&
+ 	    attr && attr->in_rep && attr->in_rep->vport == MLX5_VPORT_UPLINK)
+ 		spec->flow_context.flow_source = MLX5_FLOW_CONTEXT_FLOW_SOURCE_UPLINK;
++>>>>>>> 6f7bbad18e83 (net/mlx5e: E-Switch, Specify flow_source for rule with no in_port)
  }
  
  static void
@@@ -221,13 -381,26 +228,34 @@@ mlx5_eswitch_add_offloaded_rule(struct 
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
  		flow_act.modify_hdr = attr->modify_hdr;
  
++<<<<<<< HEAD
 +	fdb = esw_get_prio_table(esw, attr->chain, attr->prio, !!split);
++=======
+ 	if (split) {
+ 		fdb = esw_vport_tbl_get(esw, attr);
+ 	} else {
+ 		if (attr->chain || attr->prio)
+ 			fdb = mlx5_esw_chains_get_table(esw, attr->chain,
+ 							attr->prio, 0);
+ 		else
+ 			fdb = attr->fdb;
+ 
+ 		if (!(attr->flags & MLX5_ESW_ATTR_FLAG_NO_IN_PORT))
+ 			mlx5_eswitch_set_rule_source_port(esw, spec, attr);
+ 	}
++>>>>>>> 6f7bbad18e83 (net/mlx5e: E-Switch, Specify flow_source for rule with no in_port)
  	if (IS_ERR(fdb)) {
  		rule = ERR_CAST(fdb);
  		goto err_esw_get;
  	}
  
++<<<<<<< HEAD
 +	if (mlx5_eswitch_termtbl_required(esw, &flow_act, spec))
++=======
+ 	mlx5_eswitch_set_rule_flow_source(esw, spec, attr);
+ 
+ 	if (mlx5_eswitch_termtbl_required(esw, attr, &flow_act, spec))
++>>>>>>> 6f7bbad18e83 (net/mlx5e: E-Switch, Specify flow_source for rule with no in_port)
  		rule = mlx5_eswitch_add_termtbl_rule(esw, fdb, spec, attr,
  						     &flow_act, dest, i);
  	else
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
