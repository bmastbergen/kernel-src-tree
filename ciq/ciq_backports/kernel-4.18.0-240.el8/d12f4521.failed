net/mlx5e: CT: Expand tunnel register mappings

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paul Blakey <paulb@mellanox.com>
commit d12f4521d3eff83206a0bb4a9135252ffbf1c3b5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d12f4521.failed

Reg_c1 is 32 bits wide. Originally, 24 bit were allocated for the tuple_id,
6 bits for tunnel mapping and 2 bits for tunnel options mappings.

Restoring the ct state from zone lookup instead of tuple id requires
reg_c1 to store 8 bits mapping the ct zone, leaving 24 bits for tunnel
mappings.

Expand tunnel and tunnel options register mappings to 12 bit each.

	Signed-off-by: Paul Blakey <paulb@mellanox.com>
	Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit d12f4521d3eff83206a0bb4a9135252ffbf1c3b5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 23a1c21d8bab,fa41c49691a7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -149,6 -172,109 +149,112 @@@ struct mlx5e_tc_flow_parse_attr 
  #define MLX5E_TC_TABLE_NUM_GROUPS 4
  #define MLX5E_TC_TABLE_MAX_GROUP_SIZE BIT(16)
  
++<<<<<<< HEAD
++=======
+ struct mlx5e_tc_attr_to_reg_mapping mlx5e_tc_attr_to_reg_mappings[] = {
+ 	[CHAIN_TO_REG] = {
+ 		.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_0,
+ 		.moffset = 0,
+ 		.mlen = 2,
+ 	},
+ 	[TUNNEL_TO_REG] = {
+ 		.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_1,
+ 		.moffset = 1,
+ 		.mlen = 3,
+ 		.soffset = MLX5_BYTE_OFF(fte_match_param,
+ 					 misc_parameters_2.metadata_reg_c_1),
+ 	},
+ 	[ZONE_TO_REG] = zone_to_reg_ct,
+ 	[ZONE_RESTORE_TO_REG] = zone_restore_to_reg_ct,
+ 	[CTSTATE_TO_REG] = ctstate_to_reg_ct,
+ 	[MARK_TO_REG] = mark_to_reg_ct,
+ 	[LABELS_TO_REG] = labels_to_reg_ct,
+ 	[FTEID_TO_REG] = fteid_to_reg_ct,
+ };
+ 
+ static void mlx5e_put_flow_tunnel_id(struct mlx5e_tc_flow *flow);
+ 
+ void
+ mlx5e_tc_match_to_reg_match(struct mlx5_flow_spec *spec,
+ 			    enum mlx5e_tc_attr_to_reg type,
+ 			    u32 data,
+ 			    u32 mask)
+ {
+ 	int soffset = mlx5e_tc_attr_to_reg_mappings[type].soffset;
+ 	int match_len = mlx5e_tc_attr_to_reg_mappings[type].mlen;
+ 	void *headers_c = spec->match_criteria;
+ 	void *headers_v = spec->match_value;
+ 	void *fmask, *fval;
+ 
+ 	fmask = headers_c + soffset;
+ 	fval = headers_v + soffset;
+ 
+ 	mask = (__force u32)(cpu_to_be32(mask)) >> (32 - (match_len * 8));
+ 	data = (__force u32)(cpu_to_be32(data)) >> (32 - (match_len * 8));
+ 
+ 	memcpy(fmask, &mask, match_len);
+ 	memcpy(fval, &data, match_len);
+ 
+ 	spec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_2;
+ }
+ 
+ void
+ mlx5e_tc_match_to_reg_get_match(struct mlx5_flow_spec *spec,
+ 				enum mlx5e_tc_attr_to_reg type,
+ 				u32 *data,
+ 				u32 *mask)
+ {
+ 	int soffset = mlx5e_tc_attr_to_reg_mappings[type].soffset;
+ 	int match_len = mlx5e_tc_attr_to_reg_mappings[type].mlen;
+ 	void *headers_c = spec->match_criteria;
+ 	void *headers_v = spec->match_value;
+ 	void *fmask, *fval;
+ 
+ 	fmask = headers_c + soffset;
+ 	fval = headers_v + soffset;
+ 
+ 	memcpy(mask, fmask, match_len);
+ 	memcpy(data, fval, match_len);
+ 
+ 	*mask = be32_to_cpu((__force __be32)(*mask << (32 - (match_len * 8))));
+ 	*data = be32_to_cpu((__force __be32)(*data << (32 - (match_len * 8))));
+ }
+ 
+ int
+ mlx5e_tc_match_to_reg_set(struct mlx5_core_dev *mdev,
+ 			  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,
+ 			  enum mlx5e_tc_attr_to_reg type,
+ 			  u32 data)
+ {
+ 	int moffset = mlx5e_tc_attr_to_reg_mappings[type].moffset;
+ 	int mfield = mlx5e_tc_attr_to_reg_mappings[type].mfield;
+ 	int mlen = mlx5e_tc_attr_to_reg_mappings[type].mlen;
+ 	char *modact;
+ 	int err;
+ 
+ 	err = alloc_mod_hdr_actions(mdev, MLX5_FLOW_NAMESPACE_FDB,
+ 				    mod_hdr_acts);
+ 	if (err)
+ 		return err;
+ 
+ 	modact = mod_hdr_acts->actions +
+ 		 (mod_hdr_acts->num_actions * MLX5_MH_ACT_SZ);
+ 
+ 	/* Firmware has 5bit length field and 0 means 32bits */
+ 	if (mlen == 4)
+ 		mlen = 0;
+ 
+ 	MLX5_SET(set_action_in, modact, action_type, MLX5_ACTION_TYPE_SET);
+ 	MLX5_SET(set_action_in, modact, field, mfield);
+ 	MLX5_SET(set_action_in, modact, offset, moffset * 8);
+ 	MLX5_SET(set_action_in, modact, length, mlen * 8);
+ 	MLX5_SET(set_action_in, modact, data, data);
+ 	mod_hdr_acts->num_actions++;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> d12f4521d3ef (net/mlx5e: CT: Expand tunnel register mappings)
  struct mlx5e_hairpin {
  	struct mlx5_hairpin *pair;
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 22d5efd4edec,437f680728fd..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@@ -39,6 -40,43 +39,46 @@@
  
  #ifdef CONFIG_MLX5_ESWITCH
  
++<<<<<<< HEAD
++=======
+ int mlx5e_tc_num_filters(struct mlx5e_priv *priv, unsigned long flags);
+ 
+ struct mlx5e_tc_update_priv {
+ 	struct net_device *tun_dev;
+ };
+ 
+ #if IS_ENABLED(CONFIG_MLX5_CLS_ACT)
+ 
+ struct tunnel_match_key {
+ 	struct flow_dissector_key_control enc_control;
+ 	struct flow_dissector_key_keyid enc_key_id;
+ 	struct flow_dissector_key_ports enc_tp;
+ 	struct flow_dissector_key_ip enc_ip;
+ 	union {
+ 		struct flow_dissector_key_ipv4_addrs enc_ipv4;
+ 		struct flow_dissector_key_ipv6_addrs enc_ipv6;
+ 	};
+ 
+ 	int filter_ifindex;
+ };
+ 
+ struct tunnel_match_enc_opts {
+ 	struct flow_dissector_key_enc_opts key;
+ 	struct flow_dissector_key_enc_opts mask;
+ };
+ 
+ /* Tunnel_id mapping is TUNNEL_INFO_BITS + ENC_OPTS_BITS.
+  * Upper TUNNEL_INFO_BITS for general tunnel info.
+  * Lower ENC_OPTS_BITS bits for enc_opts.
+  */
+ #define TUNNEL_INFO_BITS 12
+ #define TUNNEL_INFO_BITS_MASK GENMASK(TUNNEL_INFO_BITS - 1, 0)
+ #define ENC_OPTS_BITS 12
+ #define ENC_OPTS_BITS_MASK GENMASK(ENC_OPTS_BITS - 1, 0)
+ #define TUNNEL_ID_BITS (TUNNEL_INFO_BITS + ENC_OPTS_BITS)
+ #define TUNNEL_ID_MASK GENMASK(TUNNEL_ID_BITS - 1, 0)
+ 
++>>>>>>> d12f4521d3ef (net/mlx5e: CT: Expand tunnel register mappings)
  enum {
  	MLX5E_TC_FLAG_INGRESS_BIT,
  	MLX5E_TC_FLAG_EGRESS_BIT,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
