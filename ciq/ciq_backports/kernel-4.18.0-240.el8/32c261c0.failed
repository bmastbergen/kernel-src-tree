libperf: Adopt perf_mmap__mmap() function from tools/perf

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit 32c261c070c222858148c2171698d2954242ddd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/32c261c0.failed

Move perf_mmap__mmap() from tools/perf to libperf, it will be used in
the following patches. And rename the existing perf's function to
mmap__mmap().

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lore.kernel.org/lkml/20191007125344.14268-5-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 32c261c070c222858148c2171698d2954242ddd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/lib/include/internal/mmap.h
#	tools/perf/lib/mmap.c
#	tools/perf/util/mmap.c
#	tools/perf/util/mmap.h
diff --cc tools/perf/util/mmap.c
index 850493205040,acef6e3f6b80..000000000000
--- a/tools/perf/util/mmap.c
+++ b/tools/perf/util/mmap.c
@@@ -344,12 -348,12 +344,16 @@@ static void perf_mmap__setup_affinity_m
  {
  	CPU_ZERO(&map->affinity_mask);
  	if (mp->affinity == PERF_AFFINITY_NODE && cpu__max_node() > 1)
 -		build_node_mask(cpu__get_node(map->core.cpu), &map->affinity_mask);
 +		build_node_mask(cpu__get_node(map->cpu), &map->affinity_mask);
  	else if (mp->affinity == PERF_AFFINITY_CPU)
 -		CPU_SET(map->core.cpu, &map->affinity_mask);
 +		CPU_SET(map->cpu, &map->affinity_mask);
  }
  
++<<<<<<< HEAD
 +int perf_mmap__mmap(struct perf_mmap *map, struct mmap_params *mp, int fd, int cpu)
++=======
+ int mmap__mmap(struct mmap *map, struct mmap_params *mp, int fd, int cpu)
++>>>>>>> 32c261c070c2 (libperf: Adopt perf_mmap__mmap() function from tools/perf)
  {
  	/*
  	 * The last one will be done at perf_mmap__consume(), so that we
@@@ -364,19 -368,13 +368,29 @@@
  	 * evlist layer can't just drop it when filtering events in
  	 * perf_evlist__filter_pollfd().
  	 */
++<<<<<<< HEAD
 +	refcount_set(&map->refcnt, 2);
 +	map->prev = 0;
 +	map->mask = mp->mask;
 +	map->base = mmap(NULL, perf_mmap__mmap_len(map), mp->prot,
 +			 MAP_SHARED, fd, 0);
 +	if (map->base == MAP_FAILED) {
 +		pr_debug2("failed to mmap perf event ring buffer, error %d\n",
 +			  errno);
 +		map->base = NULL;
 +		return -1;
 +	}
 +	map->fd = fd;
 +	map->cpu = cpu;
++=======
+ 	refcount_set(&map->core.refcnt, 2);
+ 
+ 	if (perf_mmap__mmap(&map->core, &mp->core, fd, cpu)) {
+ 		pr_debug2("failed to mmap perf event ring buffer, error %d\n",
+ 			  errno);
+ 		return -1;
+ 	}
++>>>>>>> 32c261c070c2 (libperf: Adopt perf_mmap__mmap() function from tools/perf)
  
  	perf_mmap__setup_affinity_mask(map, mp);
  
diff --cc tools/perf/util/mmap.h
index 274ce389cd84,a60e6ead7255..000000000000
--- a/tools/perf/util/mmap.h
+++ b/tools/perf/util/mmap.h
@@@ -77,33 -42,33 +77,38 @@@ struct mmap_params 
  	struct auxtrace_mmap_params auxtrace_mp;
  };
  
++<<<<<<< HEAD
 +int perf_mmap__mmap(struct perf_mmap *map, struct mmap_params *mp, int fd, int cpu);
 +void perf_mmap__munmap(struct perf_mmap *map);
++=======
+ int mmap__mmap(struct mmap *map, struct mmap_params *mp, int fd, int cpu);
+ void perf_mmap__munmap(struct mmap *map);
++>>>>>>> 32c261c070c2 (libperf: Adopt perf_mmap__mmap() function from tools/perf)
  
 -void perf_mmap__get(struct mmap *map);
 -void perf_mmap__put(struct mmap *map);
 +void perf_mmap__get(struct perf_mmap *map);
 +void perf_mmap__put(struct perf_mmap *map);
  
 -void perf_mmap__consume(struct mmap *map);
 +void perf_mmap__consume(struct perf_mmap *map);
  
 -static inline u64 perf_mmap__read_head(struct mmap *mm)
 +static inline u64 perf_mmap__read_head(struct perf_mmap *mm)
  {
 -	return ring_buffer_read_head(mm->core.base);
 +	return ring_buffer_read_head(mm->base);
  }
  
 -static inline void perf_mmap__write_tail(struct mmap *md, u64 tail)
 +static inline void perf_mmap__write_tail(struct perf_mmap *md, u64 tail)
  {
 -	ring_buffer_write_tail(md->core.base, tail);
 +	ring_buffer_write_tail(md->base, tail);
  }
  
 -union perf_event *perf_mmap__read_forward(struct mmap *map);
 +union perf_event *perf_mmap__read_forward(struct perf_mmap *map);
  
 -union perf_event *perf_mmap__read_event(struct mmap *map);
 +union perf_event *perf_mmap__read_event(struct perf_mmap *map);
  
 -int perf_mmap__push(struct mmap *md, void *to,
 -		    int push(struct mmap *map, void *to, void *buf, size_t size));
 +int perf_mmap__push(struct perf_mmap *md, void *to,
 +		    int push(struct perf_mmap *map, void *to, void *buf, size_t size));
  
 -size_t mmap__mmap_len(struct mmap *map);
 +size_t perf_mmap__mmap_len(struct perf_mmap *map);
  
 -int perf_mmap__read_init(struct mmap *md);
 -void perf_mmap__read_done(struct mmap *map);
 +int perf_mmap__read_init(struct perf_mmap *md);
 +void perf_mmap__read_done(struct perf_mmap *map);
  #endif /*__PERF_MMAP_H */
* Unmerged path tools/perf/lib/include/internal/mmap.h
* Unmerged path tools/perf/lib/mmap.c
* Unmerged path tools/perf/lib/include/internal/mmap.h
* Unmerged path tools/perf/lib/mmap.c
diff --git a/tools/perf/util/evlist.c b/tools/perf/util/evlist.c
index 29a998d183ce..22acbd8b350b 100644
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@ -797,7 +797,7 @@ static int perf_evlist__mmap_per_evsel(struct perf_evlist *evlist, int idx,
 		if (*output == -1) {
 			*output = fd;
 
-			if (perf_mmap__mmap(&maps[idx], mp, *output, evlist_cpu) < 0)
+			if (mmap__mmap(&maps[idx], mp, *output, evlist_cpu) < 0)
 				return -1;
 		} else {
 			if (ioctl(fd, PERF_EVENT_IOC_SET_OUTPUT, *output) != 0)
* Unmerged path tools/perf/util/mmap.c
* Unmerged path tools/perf/util/mmap.h
