libbpf: Fix usage of u32 in userspace code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit b615e5a1e067dcb327482d1af7463268b89b1629
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b615e5a1.failed

u32 is not defined for libbpf when compiled outside of kernel sources (e.g.,
in Github projection). Use __u32 instead.

Fixes: b8c54ea455dc ("libbpf: Add support to attach to fentry/fexit tracing progs")
	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20191125212948.1163343-1-andriin@fb.com
(cherry picked from commit b615e5a1e067dcb327482d1af7463268b89b1629)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
diff --cc tools/lib/bpf/libbpf.c
index 8d47b5d0bb2e,b20f82e58989..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -5115,6 -5119,97 +5115,100 @@@ int libbpf_prog_type_by_name(const cha
  	return -ESRCH;
  }
  
++<<<<<<< HEAD
++=======
+ #define BTF_PREFIX "btf_trace_"
+ int libbpf_find_vmlinux_btf_id(const char *name,
+ 			       enum bpf_attach_type attach_type)
+ {
+ 	struct btf *btf = bpf_core_find_kernel_btf();
+ 	char raw_tp_btf[128] = BTF_PREFIX;
+ 	char *dst = raw_tp_btf + sizeof(BTF_PREFIX) - 1;
+ 	const char *btf_name;
+ 	int err = -EINVAL;
+ 	__u32 kind;
+ 
+ 	if (IS_ERR(btf)) {
+ 		pr_warn("vmlinux BTF is not found\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (attach_type == BPF_TRACE_RAW_TP) {
+ 		/* prepend "btf_trace_" prefix per kernel convention */
+ 		strncat(dst, name, sizeof(raw_tp_btf) - sizeof(BTF_PREFIX));
+ 		btf_name = raw_tp_btf;
+ 		kind = BTF_KIND_TYPEDEF;
+ 	} else {
+ 		btf_name = name;
+ 		kind = BTF_KIND_FUNC;
+ 	}
+ 	err = btf__find_by_name_kind(btf, btf_name, kind);
+ 	btf__free(btf);
+ 	return err;
+ }
+ 
+ static int libbpf_find_prog_btf_id(const char *name, __u32 attach_prog_fd)
+ {
+ 	struct bpf_prog_info_linear *info_linear;
+ 	struct bpf_prog_info *info;
+ 	struct btf *btf = NULL;
+ 	int err = -EINVAL;
+ 
+ 	info_linear = bpf_program__get_prog_info_linear(attach_prog_fd, 0);
+ 	if (IS_ERR_OR_NULL(info_linear)) {
+ 		pr_warn("failed get_prog_info_linear for FD %d\n",
+ 			attach_prog_fd);
+ 		return -EINVAL;
+ 	}
+ 	info = &info_linear->info;
+ 	if (!info->btf_id) {
+ 		pr_warn("The target program doesn't have BTF\n");
+ 		goto out;
+ 	}
+ 	if (btf__get_from_id(info->btf_id, &btf)) {
+ 		pr_warn("Failed to get BTF of the program\n");
+ 		goto out;
+ 	}
+ 	err = btf__find_by_name_kind(btf, name, BTF_KIND_FUNC);
+ 	btf__free(btf);
+ 	if (err <= 0) {
+ 		pr_warn("%s is not found in prog's BTF\n", name);
+ 		goto out;
+ 	}
+ out:
+ 	free(info_linear);
+ 	return err;
+ }
+ 
+ static int libbpf_find_attach_btf_id(const char *name,
+ 				     enum bpf_attach_type attach_type,
+ 				     __u32 attach_prog_fd)
+ {
+ 	int i, err;
+ 
+ 	if (!name)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(section_names); i++) {
+ 		if (!section_names[i].is_attach_btf)
+ 			continue;
+ 		if (strncmp(name, section_names[i].sec, section_names[i].len))
+ 			continue;
+ 		if (attach_prog_fd)
+ 			err = libbpf_find_prog_btf_id(name + section_names[i].len,
+ 						      attach_prog_fd);
+ 		else
+ 			err = libbpf_find_vmlinux_btf_id(name + section_names[i].len,
+ 							 attach_type);
+ 		if (err <= 0)
+ 			pr_warn("%s is not found in vmlinux BTF\n", name);
+ 		return err;
+ 	}
+ 	pr_warn("failed to identify btf_id based on ELF section name '%s'\n", name);
+ 	return -ESRCH;
+ }
+ 
++>>>>>>> b615e5a1e067 (libbpf: Fix usage of u32 in userspace code)
  int libbpf_attach_type_by_name(const char *name,
  			       enum bpf_attach_type *attach_type)
  {
* Unmerged path tools/lib/bpf/libbpf.c
