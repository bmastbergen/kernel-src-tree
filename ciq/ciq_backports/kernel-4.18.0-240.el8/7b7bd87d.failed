KVM: nVMX: Uninline nested_vmx_reflect_vmexit(), i.e. move it to nested.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 7b7bd87dbd6aa8c09d5e8a8028bda69c3ab13969
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7b7bd87d.failed

Uninline nested_vmx_reflect_vmexit() in preparation of refactoring
nested_vmx_exit_reflected() to split up the reflection logic into more
consumable chunks, e.g. VM-Fail vs. L1 wants the exit vs. L0 always
handles the exit.

No functional change intended.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200415175519.14230-3-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 7b7bd87dbd6aa8c09d5e8a8028bda69c3ab13969)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/nested.h
diff --cc arch/x86/kvm/vmx/nested.h
index 22c93a1e37fb,bd959bd2eb58..000000000000
--- a/arch/x86/kvm/vmx/nested.h
+++ b/arch/x86/kvm/vmx/nested.h
@@@ -78,34 -81,6 +78,37 @@@ static inline bool nested_ept_ad_enable
  }
  
  /*
++<<<<<<< HEAD
 + * Reflect a VM Exit into L1.
 + */
 +static inline int nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu,
 +					    u32 exit_reason)
 +{
 +	u32 exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);
 +
 +	/*
 +	 * At this point, the exit interruption info in exit_intr_info
 +	 * is only valid for EXCEPTION_NMI exits.  For EXTERNAL_INTERRUPT
 +	 * we need to query the in-kernel LAPIC.
 +	 */
 +	WARN_ON(exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT);
 +	if ((exit_intr_info &
 +	     (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) ==
 +	    (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) {
 +		struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
 +
 +		vmcs12->vm_exit_intr_error_code =
 +			vmcs_read32(VM_EXIT_INTR_ERROR_CODE);
 +	}
 +
 +	nested_vmx_vmexit(vcpu, exit_reason, exit_intr_info,
 +			  vmcs_readl(EXIT_QUALIFICATION));
 +	return 1;
 +}
 +
 +/*
++=======
++>>>>>>> 7b7bd87dbd6a (KVM: nVMX: Uninline nested_vmx_reflect_vmexit(), i.e. move it to nested.c)
   * Return the cr0 value that a nested guest would read. This is a combination
   * of the real cr0 used to run the guest (guest_cr0), and the bits shadowed by
   * its hypervisor (cr0_read_shadow).
diff --git a/arch/x86/kvm/vmx/nested.c b/arch/x86/kvm/vmx/nested.c
index 760296c07825..5e57b4a4ae31 100644
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@ -5580,7 +5580,7 @@ static bool nested_vmx_exit_handled_mtf(struct vmcs12 *vmcs12)
  * should handle it ourselves in L0 (and then continue L2). Only call this
  * when in is_guest_mode (L2).
  */
-bool nested_vmx_exit_reflected(struct kvm_vcpu *vcpu, u32 exit_reason)
+static bool nested_vmx_exit_reflected(struct kvm_vcpu *vcpu, u32 exit_reason)
 {
 	u32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
@@ -5761,6 +5761,38 @@ bool nested_vmx_exit_reflected(struct kvm_vcpu *vcpu, u32 exit_reason)
 	}
 }
 
+/*
+ * Conditionally reflect a VM-Exit into L1.  Returns %true if the VM-Exit was
+ * reflected into L1.
+ */
+bool nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason)
+{
+	u32 exit_intr_info;
+
+	if (!nested_vmx_exit_reflected(vcpu, exit_reason))
+		return false;
+
+	/*
+	 * At this point, the exit interruption info in exit_intr_info
+	 * is only valid for EXCEPTION_NMI exits.  For EXTERNAL_INTERRUPT
+	 * we need to query the in-kernel LAPIC.
+	 */
+	WARN_ON(exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT);
+
+	exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);
+	if ((exit_intr_info &
+	     (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) ==
+	    (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) {
+		struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
+
+		vmcs12->vm_exit_intr_error_code =
+			vmcs_read32(VM_EXIT_INTR_ERROR_CODE);
+	}
+
+	nested_vmx_vmexit(vcpu, exit_reason, exit_intr_info,
+			  vmcs_readl(EXIT_QUALIFICATION));
+	return true;
+}
 
 static int vmx_get_nested_state(struct kvm_vcpu *vcpu,
 				struct kvm_nested_state __user *user_kvm_nested_state,
* Unmerged path arch/x86/kvm/vmx/nested.h
