iommu/vt-d: Only clear real DMA device's context entries

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jon Derrick <jonathan.derrick@intel.com>
commit 8038bdb8553313ad53bfcffcf8294dd0ab44618f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8038bdb8.failed

Domain context mapping can encounter issues with sub-devices of a real
DMA device. A sub-device cannot have a valid context entry due to it
potentially aliasing another device's 16-bit ID. It's expected that
sub-devices of the real DMA device uses the real DMA device's requester
when context mapping.

This is an issue when a sub-device is removed where the context entry is
cleared for all aliases. Other sub-devices are still valid, resulting in
those sub-devices being stranded without valid context entries.

The correct approach is to use the real DMA device when programming the
context entries. The insertion path is correct because device_to_iommu()
will return the bus and devfn of the real DMA device. The removal path
needs to only operate on the real DMA device, otherwise the entire
context entry would be cleared for all sub-devices of the real DMA
device.

This patch also adds a helper to determine if a struct device is a
sub-device of a real DMA device.

Fixes: 2b0140c69637e ("iommu/vt-d: Use pci_real_dma_dev() for mapping")
	Cc: stable@vger.kernel.org # v5.6+
	Signed-off-by: Jon Derrick <jonathan.derrick@intel.com>
	Acked-by: Lu Baolu <baolu.lu@linux.intel.com>
Link: https://lore.kernel.org/r/20200527165617.297470-2-jonathan.derrick@intel.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 8038bdb8553313ad53bfcffcf8294dd0ab44618f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index bd51db7feec8,1ff45b2d03ab..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -2464,6 -2470,42 +2464,45 @@@ dmar_search_domain_by_dev_info(int segm
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ static int domain_setup_first_level(struct intel_iommu *iommu,
+ 				    struct dmar_domain *domain,
+ 				    struct device *dev,
+ 				    int pasid)
+ {
+ 	int flags = PASID_FLAG_SUPERVISOR_MODE;
+ 	struct dma_pte *pgd = domain->pgd;
+ 	int agaw, level;
+ 
+ 	/*
+ 	 * Skip top levels of page tables for iommu which has
+ 	 * less agaw than default. Unnecessary for PT mode.
+ 	 */
+ 	for (agaw = domain->agaw; agaw > iommu->agaw; agaw--) {
+ 		pgd = phys_to_virt(dma_pte_addr(pgd));
+ 		if (!dma_pte_present(pgd))
+ 			return -ENOMEM;
+ 	}
+ 
+ 	level = agaw_to_level(agaw);
+ 	if (level != 4 && level != 5)
+ 		return -EINVAL;
+ 
+ 	flags |= (level == 5) ? PASID_FLAG_FL5LP : 0;
+ 
+ 	return intel_pasid_setup_first_level(iommu, dev, (pgd_t *)pgd, pasid,
+ 					     domain->iommu_did[iommu->seq_id],
+ 					     flags);
+ }
+ 
+ static bool dev_is_real_dma_subdevice(struct device *dev)
+ {
+ 	return dev && dev_is_pci(dev) &&
+ 	       pci_real_dma_dev(to_pci_dev(dev)) != to_pci_dev(dev);
+ }
+ 
++>>>>>>> 8038bdb85533 (iommu/vt-d: Only clear real DMA device's context entries)
  static struct dmar_domain *dmar_insert_one_dev_info(struct intel_iommu *iommu,
  						    int bus, int devfn,
  						    struct device *dev,
@@@ -4896,10 -4978,11 +4935,11 @@@ static void __dmar_remove_one_dev_info(
  	if (info->dev) {
  		if (dev_is_pci(info->dev) && sm_supported(iommu))
  			intel_pasid_tear_down_entry(iommu, info->dev,
 -					PASID_RID2PASID, false);
 +					PASID_RID2PASID);
  
  		iommu_disable_dev_iotlb(info);
- 		domain_context_clear(iommu, info->dev);
+ 		if (!dev_is_real_dma_subdevice(info->dev))
+ 			domain_context_clear(iommu, info->dev);
  		intel_pasid_free_table(info->dev);
  	}
  
* Unmerged path drivers/iommu/intel-iommu.c
