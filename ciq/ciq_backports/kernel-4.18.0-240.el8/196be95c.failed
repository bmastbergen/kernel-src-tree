io_uring: allocate io_kiocb upfront

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pavel Begunkov <asml.silence@gmail.com>
commit 196be95cd5572078be9deb81cbea145fab246029
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/196be95c.failed

Let io_submit_sqes() to allocate io_kiocb before fetching an sqe.

	Signed-off-by: Pavel Begunkov <asml.silence@gmail.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 196be95cd5572078be9deb81cbea145fab246029)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index fca9cdc96d77,d10216dd02bc..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -2269,12 -2551,11 +2269,17 @@@ static int io_queue_link_head(struct io
  
  #define SQE_VALID_FLAGS	(IOSQE_FIXED_FILE|IOSQE_IO_DRAIN|IOSQE_IO_LINK)
  
++<<<<<<< HEAD
 +static void io_submit_sqe(struct io_ring_ctx *ctx, struct sqe_submit *s,
 +			  struct io_submit_state *state, struct io_kiocb **link,
 +			  bool force_nonblock)
++=======
+ static void io_submit_sqe(struct io_ring_ctx *ctx, struct io_kiocb *req,
+ 			  struct sqe_submit *s, struct io_submit_state *state,
+ 			  struct io_kiocb **link)
++>>>>>>> 196be95cd557 (io_uring: allocate io_kiocb upfront)
  {
  	struct io_uring_sqe *sqe_copy;
- 	struct io_kiocb *req;
  	int ret;
  
  	/* enforce forwards compatibility on users */
@@@ -2292,8 -2567,7 +2291,12 @@@
  	ret = io_req_set_file(ctx, s, state, req);
  	if (unlikely(ret)) {
  err_req:
++<<<<<<< HEAD
 +		io_free_req(req);
 +err:
++=======
+ 		io_free_req(req, NULL);
++>>>>>>> 196be95cd557 (io_uring: allocate io_kiocb upfront)
  		io_cqring_add_event(ctx, s->sqe->user_data, ret);
  		return;
  	}
@@@ -2423,19 -2702,29 +2426,42 @@@ static int io_submit_sqes(struct io_rin
  	}
  
  	for (i = 0; i < nr; i++) {
++<<<<<<< HEAD
 +		/*
 +		 * If previous wasn't linked and we have a linked command,
 +		 * that's the end of the chain. Submit the previous link.
 +		 */
 +		if (!prev_was_link && link) {
 +			io_queue_link_head(ctx, link, &link->submit, shadow_req,
 +						true);
 +			link = NULL;
 +			shadow_req = NULL;
++=======
+ 		struct sqe_submit s;
+ 		struct io_kiocb *req;
+ 
+ 		req = io_get_req(ctx, statep);
+ 		if (unlikely(!req)) {
+ 			if (!submitted)
+ 				submitted = -EAGAIN;
+ 			break;
+ 		}
+ 		if (!io_get_sqring(ctx, &s)) {
+ 			__io_free_req(req);
+ 			break;
+ 		}
+ 
+ 		if (io_sqe_needs_user(s.sqe) && !*mm) {
+ 			mm_fault = mm_fault || !mmget_not_zero(ctx->sqo_mm);
+ 			if (!mm_fault) {
+ 				use_mm(ctx->sqo_mm);
+ 				*mm = ctx->sqo_mm;
+ 			}
++>>>>>>> 196be95cd557 (io_uring: allocate io_kiocb upfront)
  		}
 +		prev_was_link = (sqes[i].sqe->flags & IOSQE_IO_LINK) != 0;
  
 -		if (link && (s.sqe->flags & IOSQE_IO_DRAIN)) {
 +		if (link && (sqes[i].sqe->flags & IOSQE_IO_DRAIN)) {
  			if (!shadow_req) {
  				shadow_req = io_get_req(ctx, NULL);
  				if (unlikely(!shadow_req))
@@@ -2447,15 -2736,23 +2473,35 @@@
  		}
  
  out:
++<<<<<<< HEAD
 +		if (unlikely(mm_fault)) {
 +			io_cqring_add_event(ctx, sqes[i].sqe->user_data,
 +						-EFAULT);
 +		} else {
 +			sqes[i].has_user = has_user;
 +			sqes[i].needs_lock = true;
 +			sqes[i].needs_fixed_file = true;
 +			io_submit_sqe(ctx, &sqes[i], statep, &link, true);
 +			submitted++;
++=======
+ 		s.ring_file = ring_file;
+ 		s.ring_fd = ring_fd;
+ 		s.has_user = *mm != NULL;
+ 		s.in_async = async;
+ 		s.needs_fixed_file = async;
+ 		trace_io_uring_submit_sqe(ctx, s.sqe->user_data, true, async);
+ 		io_submit_sqe(ctx, req, &s, statep, &link);
+ 		submitted++;
+ 
+ 		/*
+ 		 * If previous wasn't linked and we have a linked command,
+ 		 * that's the end of the chain. Submit the previous link.
+ 		 */
+ 		if (!(s.sqe->flags & IOSQE_IO_LINK) && link) {
+ 			io_queue_link_head(ctx, link, &link->submit, shadow_req);
+ 			link = NULL;
+ 			shadow_req = NULL;
++>>>>>>> 196be95cd557 (io_uring: allocate io_kiocb upfront)
  		}
  	}
  
* Unmerged path fs/io_uring.c
