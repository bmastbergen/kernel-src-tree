io_uring: async workers should inherit the user creds

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 181e448d8709e517c9c7b523fcd209f24eb38ca7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/181e448d.failed

If we don't inherit the original task creds, then we can confuse users
like fuse that pass creds in the request header. See link below on
identical aio issue.

Link: https://lore.kernel.org/linux-fsdevel/26f0d78e-99ca-2f1b-78b9-433088053a61@scylladb.com/T/#u
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 181e448d8709e517c9c7b523fcd209f24eb38ca7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io-wq.c
#	fs/io-wq.h
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 9058714611f6,b6c6fdc12de7..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -259,7 -237,27 +259,31 @@@ struct io_ring_ctx 
  
  	struct user_struct	*user;
  
++<<<<<<< HEAD
 +	struct completion	ctx_done;
++=======
+ 	struct cred		*creds;
+ 
+ 	/* 0 is for ctx quiesce/reinit/free, 1 is for sqo_thread started */
+ 	struct completion	*completions;
+ 
+ 	/* if all else fails... */
+ 	struct io_kiocb		*fallback_req;
+ 
+ #if defined(CONFIG_UNIX)
+ 	struct socket		*ring_sock;
+ #endif
+ 
+ 	struct {
+ 		unsigned		cached_cq_tail;
+ 		unsigned		cq_entries;
+ 		unsigned		cq_mask;
+ 		atomic_t		cq_timeouts;
+ 		struct wait_queue_head	cq_wait;
+ 		struct fasync_struct	*cq_fasync;
+ 		struct eventfd_ctx	*cq_ev_fd;
+ 	} ____cacheline_aligned_in_smp;
++>>>>>>> 181e448d8709 (io_uring: async workers should inherit the user creds)
  
  	struct {
  		struct mutex		uring_lock;
@@@ -2482,9 -3267,9 +2506,10 @@@ out
  
  static int io_sq_thread(void *data)
  {
 +	struct sqe_submit sqes[IO_IOPOLL_BATCH];
  	struct io_ring_ctx *ctx = data;
  	struct mm_struct *cur_mm = NULL;
+ 	const struct cred *old_cred;
  	mm_segment_t old_fs;
  	DEFINE_WAIT(wait);
  	unsigned inflight;
@@@ -2494,11 -3280,11 +2519,12 @@@
  
  	old_fs = get_fs();
  	set_fs(USER_DS);
+ 	old_cred = override_creds(ctx->creds);
  
 -	ret = timeout = inflight = 0;
 +	timeout = inflight = 0;
  	while (!kthread_should_park()) {
 -		unsigned int to_submit;
 +		bool all_fixed, mm_fault = false;
 +		int i;
  
  		if (inflight) {
  			unsigned nr_events = 0;
@@@ -3186,26 -4012,18 +3213,34 @@@ static int io_sq_offload_start(struct i
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	/* Do QD, or 2 * CPUS, whatever is smallest */
 +	ctx->sqo_wq[0] = alloc_workqueue("io_ring-wq",
 +			WQ_UNBOUND | WQ_FREEZABLE,
 +			min(ctx->sq_entries - 1, 2 * num_online_cpus()));
 +	if (!ctx->sqo_wq[0]) {
 +		ret = -ENOMEM;
 +		goto err;
 +	}
++=======
+ 	data.mm = ctx->sqo_mm;
+ 	data.user = ctx->user;
+ 	data.creds = ctx->creds;
+ 	data.get_work = io_get_work;
+ 	data.put_work = io_put_work;
++>>>>>>> 181e448d8709 (io_uring: async workers should inherit the user creds)
  
 -	/* Do QD, or 4 * CPUS, whatever is smallest */
 -	concurrency = min(ctx->sq_entries, 4 * num_online_cpus());
 -	ctx->io_wq = io_wq_create(concurrency, &data);
 -	if (IS_ERR(ctx->io_wq)) {
 -		ret = PTR_ERR(ctx->io_wq);
 -		ctx->io_wq = NULL;
 +	/*
 +	 * This is for buffered writes, where we want to limit the parallelism
 +	 * due to file locking in file systems. As "normal" buffered writes
 +	 * should parellelize on writeout quite nicely, limit us to having 2
 +	 * pending. This avoids massive contention on the inode when doing
 +	 * buffered async writes.
 +	 */
 +	ctx->sqo_wq[1] = alloc_workqueue("io_ring-write-wq",
 +						WQ_UNBOUND | WQ_FREEZABLE, 2);
 +	if (!ctx->sqo_wq[1]) {
 +		ret = -ENOMEM;
  		goto err;
  	}
  
@@@ -3526,6 -4369,9 +3561,12 @@@ static void io_ring_ctx_free(struct io_
  		io_unaccount_mem(ctx->user,
  				ring_pages(ctx->sq_entries, ctx->cq_entries));
  	free_uid(ctx->user);
++<<<<<<< HEAD
++=======
+ 	put_cred(ctx->creds);
+ 	kfree(ctx->completions);
+ 	kmem_cache_free(req_cachep, ctx->fallback_req);
++>>>>>>> 181e448d8709 (io_uring: async workers should inherit the user creds)
  	kfree(ctx);
  }
  
* Unmerged path fs/io-wq.c
* Unmerged path fs/io-wq.h
* Unmerged path fs/io-wq.c
* Unmerged path fs/io-wq.h
* Unmerged path fs/io_uring.c
