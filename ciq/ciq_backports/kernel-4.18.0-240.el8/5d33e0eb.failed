pinctrl: baytrail: Reuse struct intel_pinctrl in the driver

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 5d33e0eb7ffa2a4f4c431af1deca49f433faba8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5d33e0eb.failed

We may use now available struct intel_pinctrl in the driver.
No functional change implied.

	Acked-by: Hans de Goede <hdegoede@redhat.com>
	Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
(cherry picked from commit 5d33e0eb7ffa2a4f4c431af1deca49f433faba8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pinctrl/intel/pinctrl-baytrail.c
diff --cc drivers/pinctrl/intel/pinctrl-baytrail.c
index dbf8e5fd6a86,cb0c04c5269c..000000000000
--- a/drivers/pinctrl/intel/pinctrl-baytrail.c
+++ b/drivers/pinctrl/intel/pinctrl-baytrail.c
@@@ -113,16 -105,6 +113,19 @@@ struct intel_pad_context 
  		.pad_map	= (map),\
  	}
  
++<<<<<<< HEAD
 +struct byt_gpio {
 +	struct gpio_chip chip;
 +	struct platform_device *pdev;
 +	struct pinctrl_dev *pctl_dev;
 +	struct pinctrl_desc pctl_desc;
 +	const struct intel_pinctrl_soc_data *soc_data;
 +	struct intel_community *communities_copy;
 +	struct byt_gpio_pin_context *saved_context;
 +};
 +
++=======
++>>>>>>> 5d33e0eb7ffa (pinctrl: baytrail: Reuse struct intel_pinctrl in the driver)
  /* SCORE pins, aka GPIOC_<pin_no> or GPIO_S0_SC[<pin_no>] */
  static const struct pinctrl_pin_desc byt_score_pins[] = {
  	PINCTRL_PIN(0, "SATA_GP0"),
@@@ -807,10 -788,10 +810,10 @@@ static void byt_gpio_disable_free(struc
  				  struct pinctrl_gpio_range *range,
  				  unsigned int offset)
  {
- 	struct byt_gpio *vg = pinctrl_dev_get_drvdata(pctl_dev);
+ 	struct intel_pinctrl *vg = pinctrl_dev_get_drvdata(pctl_dev);
  
  	byt_gpio_clear_triggering(vg, offset);
 -	pm_runtime_put(vg->dev);
 +	pm_runtime_put(&vg->pdev->dev);
  }
  
  static int byt_gpio_set_direction(struct pinctrl_dev *pctl_dev,
@@@ -1443,12 -1416,13 +1445,16 @@@ static void byt_gpio_irq_handler(struc
  	chip->irq_eoi(data);
  }
  
 -static void byt_init_irq_valid_mask(struct gpio_chip *chip,
 -				    unsigned long *valid_mask,
 -				    unsigned int ngpios)
 +static void byt_gpio_irq_init_hw(struct byt_gpio *vg)
  {
++<<<<<<< HEAD
 +	struct gpio_chip *gc = &vg->chip;
 +	struct device *dev = &vg->pdev->dev;
++=======
+ 	struct intel_pinctrl *vg = gpiochip_get_data(chip);
++>>>>>>> 5d33e0eb7ffa (pinctrl: baytrail: Reuse struct intel_pinctrl in the driver)
  	void __iomem *reg;
 -	u32 value;
 +	u32 base, value;
  	int i;
  
  	/*
@@@ -1469,16 -1443,23 +1475,26 @@@
  
  		value = readl(reg);
  		if (value & BYT_DIRECT_IRQ_EN) {
 -			clear_bit(i, valid_mask);
 -			dev_dbg(vg->dev, "excluding GPIO %d from IRQ domain\n", i);
 +			clear_bit(i, gc->irq.valid_mask);
 +			dev_dbg(dev, "excluding GPIO %d from IRQ domain\n", i);
  		} else if ((value & BYT_PIN_MUX) == byt_get_gpio_mux(vg, i)) {
  			byt_gpio_clear_triggering(vg, i);
 -			dev_dbg(vg->dev, "disabling GPIO %d\n", i);
 +			dev_dbg(dev, "disabling GPIO %d\n", i);
  		}
  	}
++<<<<<<< HEAD
++=======
+ }
+ 
+ static int byt_gpio_irq_init_hw(struct gpio_chip *chip)
+ {
+ 	struct intel_pinctrl *vg = gpiochip_get_data(chip);
+ 	void __iomem *reg;
+ 	u32 base, value;
++>>>>>>> 5d33e0eb7ffa (pinctrl: baytrail: Reuse struct intel_pinctrl in the driver)
  
  	/* clear interrupt status trigger registers */
- 	for (base = 0; base < vg->soc_data->npins; base += 32) {
+ 	for (base = 0; base < vg->soc->npins; base += 32) {
  		reg = byt_gpio_reg(vg, base, BYT_INT_STAT_REG);
  
  		if (!reg) {
@@@ -1501,19 -1484,20 +1517,24 @@@
  
  static int byt_gpio_add_pin_ranges(struct gpio_chip *chip)
  {
++<<<<<<< HEAD
 +	struct byt_gpio *vg = gpiochip_get_data(chip);
 +	struct device *dev = &vg->pdev->dev;
++=======
+ 	struct intel_pinctrl *vg = gpiochip_get_data(chip);
+ 	struct device *dev = vg->dev;
++>>>>>>> 5d33e0eb7ffa (pinctrl: baytrail: Reuse struct intel_pinctrl in the driver)
  	int ret;
  
- 	ret = gpiochip_add_pin_range(chip, dev_name(dev), 0, 0, vg->soc_data->npins);
+ 	ret = gpiochip_add_pin_range(chip, dev_name(dev), 0, 0, vg->soc->npins);
  	if (ret)
  		dev_err(dev, "failed to add GPIO pin range\n");
  
  	return ret;
  }
  
- static int byt_gpio_probe(struct byt_gpio *vg)
+ static int byt_gpio_probe(struct intel_pinctrl *vg)
  {
 -	struct platform_device *pdev = to_platform_device(vg->dev);
  	struct gpio_chip *gc;
  	struct resource *irq_rc;
  	int ret;
@@@ -1525,60 -1509,72 +1546,79 @@@
  	gc->base	= -1;
  	gc->can_sleep	= false;
  	gc->add_pin_ranges = byt_gpio_add_pin_ranges;
++<<<<<<< HEAD
 +	gc->parent	= &vg->pdev->dev;
 +	gc->ngpio	= vg->soc_data->npins;
 +	gc->irq.need_valid_mask	= true;
 +
 +#ifdef CONFIG_PM_SLEEP
 +	vg->saved_context = devm_kcalloc(&vg->pdev->dev, gc->ngpio,
 +				       sizeof(*vg->saved_context), GFP_KERNEL);
 +	if (!vg->saved_context)
++=======
+ 	gc->parent	= vg->dev;
+ 	gc->ngpio	= vg->soc->npins;
+ 
+ #ifdef CONFIG_PM_SLEEP
+ 	vg->context.pads = devm_kcalloc(vg->dev, gc->ngpio, sizeof(*vg->context.pads),
+ 					GFP_KERNEL);
+ 	if (!vg->context.pads)
++>>>>>>> 5d33e0eb7ffa (pinctrl: baytrail: Reuse struct intel_pinctrl in the driver)
  		return -ENOMEM;
  #endif
 +	ret = devm_gpiochip_add_data(&vg->pdev->dev, gc, vg);
 +	if (ret) {
 +		dev_err(&vg->pdev->dev, "failed adding byt-gpio chip\n");
 +		return ret;
 +	}
  
  	/* set up interrupts  */
 -	irq_rc = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 +	irq_rc = platform_get_resource(vg->pdev, IORESOURCE_IRQ, 0);
  	if (irq_rc && irq_rc->start) {
 -		struct gpio_irq_chip *girq;
 -
 -		vg->irqchip.name = "BYT-GPIO",
 -		vg->irqchip.irq_ack = byt_irq_ack,
 -		vg->irqchip.irq_mask = byt_irq_mask,
 -		vg->irqchip.irq_unmask = byt_irq_unmask,
 -		vg->irqchip.irq_set_type = byt_irq_type,
 -		vg->irqchip.flags = IRQCHIP_SKIP_SET_WAKE,
 -
 -		girq = &gc->irq;
 -		girq->chip = &vg->irqchip;
 -		girq->init_hw = byt_gpio_irq_init_hw;
 -		girq->init_valid_mask = byt_init_irq_valid_mask;
 -		girq->parent_handler = byt_gpio_irq_handler;
 -		girq->num_parents = 1;
 -		girq->parents = devm_kcalloc(vg->dev, girq->num_parents,
 -					     sizeof(*girq->parents), GFP_KERNEL);
 -		if (!girq->parents)
 -			return -ENOMEM;
 -		girq->parents[0] = (unsigned int)irq_rc->start;
 -		girq->default_type = IRQ_TYPE_NONE;
 -		girq->handler = handle_bad_irq;
 -	}
 +		byt_gpio_irq_init_hw(vg);
 +		ret = gpiochip_irqchip_add(gc, &byt_irqchip, 0,
 +					   handle_bad_irq, IRQ_TYPE_NONE);
 +		if (ret) {
 +			dev_err(&vg->pdev->dev, "failed to add irqchip\n");
 +			return ret;
 +		}
  
 -	ret = devm_gpiochip_add_data(vg->dev, gc, vg);
 -	if (ret) {
 -		dev_err(vg->dev, "failed adding byt-gpio chip\n");
 -		return ret;
 +		gpiochip_set_chained_irqchip(gc, &byt_irqchip,
 +					     (unsigned)irq_rc->start,
 +					     byt_gpio_irq_handler);
  	}
  
  	return ret;
  }
  
- static int byt_set_soc_data(struct byt_gpio *vg,
- 			    const struct intel_pinctrl_soc_data *soc_data)
+ static int byt_set_soc_data(struct intel_pinctrl *vg,
+ 			    const struct intel_pinctrl_soc_data *soc)
  {
 -	struct platform_device *pdev = to_platform_device(vg->dev);
  	int i;
  
++<<<<<<< HEAD
 +	vg->soc_data = soc_data;
 +	vg->communities_copy = devm_kcalloc(&vg->pdev->dev,
 +					    soc_data->ncommunities,
 +					    sizeof(*vg->communities_copy),
 +					    GFP_KERNEL);
 +	if (!vg->communities_copy)
++=======
+ 	vg->soc = soc;
+ 
+ 	vg->ncommunities = vg->soc->ncommunities;
+ 	vg->communities = devm_kcalloc(vg->dev, vg->ncommunities,
+ 				       sizeof(*vg->communities), GFP_KERNEL);
+ 	if (!vg->communities)
++>>>>>>> 5d33e0eb7ffa (pinctrl: baytrail: Reuse struct intel_pinctrl in the driver)
  		return -ENOMEM;
  
- 	for (i = 0; i < soc_data->ncommunities; i++) {
- 		struct intel_community *comm = vg->communities_copy + i;
+ 	for (i = 0; i < vg->soc->ncommunities; i++) {
+ 		struct intel_community *comm = vg->communities + i;
  
- 		*comm = vg->soc_data->communities[i];
+ 		*comm = vg->soc->communities[i];
  
 -		comm->pad_regs = devm_platform_ioremap_resource(pdev, 0);
 +		comm->pad_regs = devm_platform_ioremap_resource(vg->pdev, 0);
  		if (IS_ERR(comm->pad_regs))
  			return PTR_ERR(comm->pad_regs);
  	}
@@@ -1596,11 -1592,12 +1636,11 @@@ static int byt_pinctrl_probe(struct pla
  {
  	const struct intel_pinctrl_soc_data *soc_data = NULL;
  	const struct intel_pinctrl_soc_data **soc_table;
 -	struct device *dev = &pdev->dev;
  	struct acpi_device *acpi_dev;
- 	struct byt_gpio *vg;
+ 	struct intel_pinctrl *vg;
  	int i, ret;
  
 -	acpi_dev = ACPI_COMPANION(dev);
 +	acpi_dev = ACPI_COMPANION(&pdev->dev);
  	if (!acpi_dev)
  		return -ENODEV;
  
@@@ -1627,15 -1624,15 +1667,27 @@@
  		return ret;
  	}
  
++<<<<<<< HEAD
 +	vg->pctl_desc		= byt_pinctrl_desc;
 +	vg->pctl_desc.name	= dev_name(&pdev->dev);
 +	vg->pctl_desc.pins	= vg->soc_data->pins;
 +	vg->pctl_desc.npins	= vg->soc_data->npins;
 +
 +	vg->pctl_dev = devm_pinctrl_register(&pdev->dev, &vg->pctl_desc, vg);
 +	if (IS_ERR(vg->pctl_dev)) {
 +		dev_err(&pdev->dev, "failed to register pinctrl driver\n");
 +		return PTR_ERR(vg->pctl_dev);
++=======
+ 	vg->pctldesc		= byt_pinctrl_desc;
+ 	vg->pctldesc.name	= dev_name(dev);
+ 	vg->pctldesc.pins	= vg->soc->pins;
+ 	vg->pctldesc.npins	= vg->soc->npins;
+ 
+ 	vg->pctldev = devm_pinctrl_register(dev, &vg->pctldesc, vg);
+ 	if (IS_ERR(vg->pctldev)) {
+ 		dev_err(dev, "failed to register pinctrl driver\n");
+ 		return PTR_ERR(vg->pctldev);
++>>>>>>> 5d33e0eb7ffa (pinctrl: baytrail: Reuse struct intel_pinctrl in the driver)
  	}
  
  	ret = byt_gpio_probe(vg);
* Unmerged path drivers/pinctrl/intel/pinctrl-baytrail.c
