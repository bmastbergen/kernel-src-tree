IB/mlx5: Fix device memory flows

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Yishai Hadas <yishaih@mellanox.com>
commit dc2316eba73ff03da6dde082a372c6b5209304c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dc2316eb.failed

Fix device memory flows so that only once there will be no live mmaped
VA to a given allocation the matching object will be destroyed.

This prevents a potential scenario that existing VA that was mmaped by
one process might still be used post its deallocation despite that it's
owned now by other process.

The above is achieved by integrating with IB core APIs to manage
mmap/munmap. Only once the refcount will become 0 the DM object and its
underlay area will be freed.

Fixes: 3b113a1ec3d4 ("IB/mlx5: Support device memory type attribute")
	Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
	Signed-off-by: Leon Romanovsky <leonro@mellanox.com>
Link: https://lore.kernel.org/r/20191212100237.330654-3-leon@kernel.org
	Signed-off-by: Doug Ledford <dledford@redhat.com>
(cherry picked from commit dc2316eba73ff03da6dde082a372c6b5209304c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/main.c
diff --cc drivers/infiniband/hw/mlx5/main.c
index 9788244ef159,997cbfe4b90c..000000000000
--- a/drivers/infiniband/hw/mlx5/main.c
+++ b/drivers/infiniband/hw/mlx5/main.c
@@@ -2195,25 -2204,55 +2213,64 @@@ free_bfreg
  	return err;
  }
  
- static int dm_mmap(struct ib_ucontext *context, struct vm_area_struct *vma)
+ static int add_dm_mmap_entry(struct ib_ucontext *context,
+ 			     struct mlx5_ib_dm *mdm,
+ 			     u64 address)
+ {
+ 	mdm->mentry.mmap_flag = MLX5_IB_MMAP_TYPE_MEMIC;
+ 	mdm->mentry.address = address;
+ 	return rdma_user_mmap_entry_insert_range(
+ 			context, &mdm->mentry.rdma_entry,
+ 			mdm->size,
+ 			MLX5_IB_MMAP_DEVICE_MEM << 16,
+ 			(MLX5_IB_MMAP_DEVICE_MEM << 16) + (1UL << 16) - 1);
+ }
+ 
+ static unsigned long mlx5_vma_to_pgoff(struct vm_area_struct *vma)
+ {
+ 	unsigned long idx;
+ 	u8 command;
+ 
+ 	command = get_command(vma->vm_pgoff);
+ 	idx = get_extended_index(vma->vm_pgoff);
+ 
+ 	return (command << 16 | idx);
+ }
+ 
+ static int mlx5_ib_mmap_offset(struct mlx5_ib_dev *dev,
+ 			       struct vm_area_struct *vma,
+ 			       struct ib_ucontext *ucontext)
  {
- 	struct mlx5_ib_ucontext *mctx = to_mucontext(context);
- 	struct mlx5_ib_dev *dev = to_mdev(context->device);
- 	u16 page_idx = get_extended_index(vma->vm_pgoff);
- 	size_t map_size = vma->vm_end - vma->vm_start;
- 	u32 npages = map_size >> PAGE_SHIFT;
+ 	struct mlx5_user_mmap_entry *mentry;
+ 	struct rdma_user_mmap_entry *entry;
+ 	unsigned long pgoff;
+ 	pgprot_t prot;
  	phys_addr_t pfn;
+ 	int ret;
  
- 	if (find_next_zero_bit(mctx->dm_pages, page_idx + npages, page_idx) !=
- 	    page_idx + npages)
+ 	pgoff = mlx5_vma_to_pgoff(vma);
+ 	entry = rdma_user_mmap_entry_get_pgoff(ucontext, pgoff);
+ 	if (!entry)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	pfn = ((dev->mdev->bar_addr +
 +	      MLX5_CAP64_DEV_MEM(dev->mdev, memic_bar_start_addr)) >>
 +	      PAGE_SHIFT) +
 +	      page_idx;
 +	return rdma_user_mmap_io(context, vma, pfn, map_size,
 +				 pgprot_writecombine(vma->vm_page_prot));
++=======
+ 	mentry = to_mmmap(entry);
+ 	pfn = (mentry->address >> PAGE_SHIFT);
+ 	prot = pgprot_writecombine(vma->vm_page_prot);
+ 	ret = rdma_user_mmap_io(ucontext, vma, pfn,
+ 				entry->npages * PAGE_SIZE,
+ 				prot,
+ 				entry);
+ 	rdma_user_mmap_entry_put(&mentry->rdma_entry);
+ 	return ret;
++>>>>>>> dc2316eba73f (IB/mlx5: Fix device memory flows)
  }
  
  static int mlx5_ib_mmap(struct ib_ucontext *ibcontext, struct vm_area_struct *vma)
diff --git a/drivers/infiniband/hw/mlx5/cmd.c b/drivers/infiniband/hw/mlx5/cmd.c
index 4937947400cd..4c26492ab8a3 100644
--- a/drivers/infiniband/hw/mlx5/cmd.c
+++ b/drivers/infiniband/hw/mlx5/cmd.c
@@ -157,7 +157,7 @@ int mlx5_cmd_alloc_memic(struct mlx5_dm *dm, phys_addr_t *addr,
 	return -ENOMEM;
 }
 
-int mlx5_cmd_dealloc_memic(struct mlx5_dm *dm, phys_addr_t addr, u64 length)
+void mlx5_cmd_dealloc_memic(struct mlx5_dm *dm, phys_addr_t addr, u64 length)
 {
 	struct mlx5_core_dev *dev = dm->dev;
 	u64 hw_start_addr = MLX5_CAP64_DEV_MEM(dev, memic_bar_start_addr);
@@ -175,15 +175,13 @@ int mlx5_cmd_dealloc_memic(struct mlx5_dm *dm, phys_addr_t addr, u64 length)
 	MLX5_SET(dealloc_memic_in, in, memic_size, length);
 
 	err =  mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));
+	if (err)
+		return;
 
-	if (!err) {
-		spin_lock(&dm->lock);
-		bitmap_clear(dm->memic_alloc_pages,
-			     start_page_idx, num_pages);
-		spin_unlock(&dm->lock);
-	}
-
-	return err;
+	spin_lock(&dm->lock);
+	bitmap_clear(dm->memic_alloc_pages,
+		     start_page_idx, num_pages);
+	spin_unlock(&dm->lock);
 }
 
 int mlx5_cmd_query_ext_ppcnt_counters(struct mlx5_core_dev *dev, void *out)
diff --git a/drivers/infiniband/hw/mlx5/cmd.h b/drivers/infiniband/hw/mlx5/cmd.h
index 169cab4915e3..945ebce73613 100644
--- a/drivers/infiniband/hw/mlx5/cmd.h
+++ b/drivers/infiniband/hw/mlx5/cmd.h
@@ -46,7 +46,7 @@ int mlx5_cmd_modify_cong_params(struct mlx5_core_dev *mdev,
 				void *in, int in_size);
 int mlx5_cmd_alloc_memic(struct mlx5_dm *dm, phys_addr_t *addr,
 			 u64 length, u32 alignment);
-int mlx5_cmd_dealloc_memic(struct mlx5_dm *dm, phys_addr_t addr, u64 length);
+void mlx5_cmd_dealloc_memic(struct mlx5_dm *dm, phys_addr_t addr, u64 length);
 void mlx5_cmd_dealloc_pd(struct mlx5_core_dev *dev, u32 pdn, u16 uid);
 void mlx5_cmd_destroy_tir(struct mlx5_core_dev *dev, u32 tirn, u16 uid);
 void mlx5_cmd_destroy_tis(struct mlx5_core_dev *dev, u32 tisn, u16 uid);
* Unmerged path drivers/infiniband/hw/mlx5/main.c
diff --git a/drivers/infiniband/hw/mlx5/mlx5_ib.h b/drivers/infiniband/hw/mlx5/mlx5_ib.h
index b39d154065df..8f09629de430 100644
--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h
+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h
@@ -118,6 +118,10 @@ enum {
 	MLX5_MEMIC_BASE_SIZE	= 1 << MLX5_MEMIC_BASE_ALIGN,
 };
 
+enum mlx5_ib_mmap_type {
+	MLX5_IB_MMAP_TYPE_MEMIC = 1,
+};
+
 #define MLX5_LOG_SW_ICM_BLOCK_SIZE(dev)                                        \
 	(MLX5_CAP_DEV_MEM(dev, log_sw_icm_alloc_granularity))
 #define MLX5_SW_ICM_BLOCK_SIZE(dev) (1 << MLX5_LOG_SW_ICM_BLOCK_SIZE(dev))
@@ -135,7 +139,6 @@ struct mlx5_ib_ucontext {
 	u32			tdn;
 
 	u64			lib_caps;
-	DECLARE_BITMAP(dm_pages, MLX5_MAX_MEMIC_PAGES);
 	u16			devx_uid;
 	/* For RoCE LAG TX affinity */
 	atomic_t		tx_port_affinity;
@@ -556,6 +559,12 @@ enum mlx5_ib_mtt_access_flags {
 	MLX5_IB_MTT_WRITE = (1 << 1),
 };
 
+struct mlx5_user_mmap_entry {
+	struct rdma_user_mmap_entry rdma_entry;
+	u8 mmap_flag;
+	u64 address;
+};
+
 struct mlx5_ib_dm {
 	struct ib_dm		ibdm;
 	phys_addr_t		dev_addr;
@@ -567,6 +576,7 @@ struct mlx5_ib_dm {
 		} icm_dm;
 		/* other dm types specific params should be added here */
 	};
+	struct mlx5_user_mmap_entry mentry;
 };
 
 #define MLX5_IB_MTT_PRESENT (MLX5_IB_MTT_READ | MLX5_IB_MTT_WRITE)
@@ -1094,6 +1104,13 @@ to_mflow_act(struct ib_flow_action *ibact)
 	return container_of(ibact, struct mlx5_ib_flow_action, ib_action);
 }
 
+static inline struct mlx5_user_mmap_entry *
+to_mmmap(struct rdma_user_mmap_entry *rdma_entry)
+{
+	return container_of(rdma_entry,
+		struct mlx5_user_mmap_entry, rdma_entry);
+}
+
 int mlx5_ib_db_map_user(struct mlx5_ib_ucontext *context,
 			struct ib_udata *udata, unsigned long virt,
 			struct mlx5_db *db);
