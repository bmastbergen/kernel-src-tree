libbpf: Fix compatibility for kernels without need_wakeup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Magnus Karlsson <magnus.karlsson@intel.com>
commit 94ff9ebb49a546b7f009ed840bafa235c96d4c4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/94ff9ebb.failed

When the need_wakeup flag was added to AF_XDP, the format of the
XDP_MMAP_OFFSETS getsockopt was extended. Code was added to the
kernel to take care of compatibility issues arrising from running
applications using any of the two formats. However, libbpf was
not extended to take care of the case when the application/libbpf
uses the new format but the kernel only supports the old
format. This patch adds support in libbpf for parsing the old
format, before the need_wakeup flag was added, and emulating a
set of static need_wakeup flags that will always work for the
application.

v2 -> v3:
* Incorporated code improvements suggested by Jonathan Lemon

v1 -> v2:
* Rebased to bpf-next
* Rewrote the code as the previous version made you blind

Fixes: a4500432c2587cb2a ("libbpf: add support for need_wakeup flag in AF_XDP part")
	Reported-by: Eloy Degen <degeneloy@gmail.com>
	Signed-off-by: Magnus Karlsson <magnus.karlsson@intel.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Jonathan Lemon <jonathan.lemon@gmail.com>
Link: https://lore.kernel.org/bpf/1571995035-21889-1-git-send-email-magnus.karlsson@intel.com
(cherry picked from commit 94ff9ebb49a546b7f009ed840bafa235c96d4c4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/xsk.c
diff --cc tools/lib/bpf/xsk.c
index 3912e8624945,d54111133123..000000000000
--- a/tools/lib/bpf/xsk.c
+++ b/tools/lib/bpf/xsk.c
@@@ -131,9 -148,62 +146,68 @@@ static int xsk_set_xdp_socket_config(st
  	return 0;
  }
  
++<<<<<<< HEAD
 +int xsk_umem__create(struct xsk_umem **umem_ptr, void *umem_area, __u64 size,
 +		     struct xsk_ring_prod *fill, struct xsk_ring_cons *comp,
 +		     const struct xsk_umem_config *usr_config)
++=======
+ static void xsk_mmap_offsets_v1(struct xdp_mmap_offsets *off)
+ {
+ 	struct xdp_mmap_offsets_v1 off_v1;
+ 
+ 	/* getsockopt on a kernel <= 5.3 has no flags fields.
+ 	 * Copy over the offsets to the correct places in the >=5.4 format
+ 	 * and put the flags where they would have been on that kernel.
+ 	 */
+ 	memcpy(&off_v1, off, sizeof(off_v1));
+ 
+ 	off->rx.producer = off_v1.rx.producer;
+ 	off->rx.consumer = off_v1.rx.consumer;
+ 	off->rx.desc = off_v1.rx.desc;
+ 	off->rx.flags = off_v1.rx.consumer + sizeof(u32);
+ 
+ 	off->tx.producer = off_v1.tx.producer;
+ 	off->tx.consumer = off_v1.tx.consumer;
+ 	off->tx.desc = off_v1.tx.desc;
+ 	off->tx.flags = off_v1.tx.consumer + sizeof(u32);
+ 
+ 	off->fr.producer = off_v1.fr.producer;
+ 	off->fr.consumer = off_v1.fr.consumer;
+ 	off->fr.desc = off_v1.fr.desc;
+ 	off->fr.flags = off_v1.fr.consumer + sizeof(u32);
+ 
+ 	off->cr.producer = off_v1.cr.producer;
+ 	off->cr.consumer = off_v1.cr.consumer;
+ 	off->cr.desc = off_v1.cr.desc;
+ 	off->cr.flags = off_v1.cr.consumer + sizeof(u32);
+ }
+ 
+ static int xsk_get_mmap_offsets(int fd, struct xdp_mmap_offsets *off)
+ {
+ 	socklen_t optlen;
+ 	int err;
+ 
+ 	optlen = sizeof(*off);
+ 	err = getsockopt(fd, SOL_XDP, XDP_MMAP_OFFSETS, off, &optlen);
+ 	if (err)
+ 		return err;
+ 
+ 	if (optlen == sizeof(*off))
+ 		return 0;
+ 
+ 	if (optlen == sizeof(struct xdp_mmap_offsets_v1)) {
+ 		xsk_mmap_offsets_v1(off);
+ 		return 0;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ int xsk_umem__create_v0_0_4(struct xsk_umem **umem_ptr, void *umem_area,
+ 			    __u64 size, struct xsk_ring_prod *fill,
+ 			    struct xsk_ring_cons *comp,
+ 			    const struct xsk_umem_config *usr_config)
++>>>>>>> 94ff9ebb49a5 (libbpf: Fix compatibility for kernels without need_wakeup)
  {
  	struct xdp_mmap_offsets off;
  	struct xdp_umem_reg mr;
* Unmerged path tools/lib/bpf/xsk.c
