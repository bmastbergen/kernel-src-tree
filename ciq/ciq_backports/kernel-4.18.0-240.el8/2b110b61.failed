KVM: x86: Add blurb to CPUID tracepoint when using max basic leaf values

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 2b110b61644a34e97c92ae20788cbcb42d474fa9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/2b110b61.failed

Tack on "used max basic" at the end of the CPUID tracepoint when the
output values correspond to the max basic leaf, i.e. when emulating
Intel's out-of-range CPUID behavior.  Observing "cpuid entry not found"
in the tracepoint with non-zero output values is confusing for users
that aren't familiar with the out-of-range semantics, and qualifying the
"not found" case hopefully makes it clear that "found" means "found the
exact entry".

	Suggested-by: Jan Kiszka <jan.kiszka@siemens.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 2b110b61644a34e97c92ae20788cbcb42d474fa9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.c
#	arch/x86/kvm/trace.h
diff --cc arch/x86/kvm/cpuid.c
index 78d6db1ce0f2,990c76f34b03..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -1012,25 -990,16 +1012,38 @@@ bool kvm_cpuid(struct kvm_vcpu *vcpu, u
  {
  	u32 orig_function = *eax, function = *eax, index = *ecx;
  	struct kvm_cpuid_entry2 *entry;
++<<<<<<< HEAD
 +	struct kvm_cpuid_entry2 *max;
 +	bool found;
 +
 +	entry = kvm_find_cpuid_entry(vcpu, function, index);
 +	found = entry;
 +	/*
 +	 * Intel CPUID semantics treats any query for an out-of-range
 +	 * leaf as if the highest basic leaf (i.e. CPUID.0H:EAX) were
 +	 * requested. AMD CPUID semantics returns all zeroes for any
 +	 * undefined leaf, whether or not the leaf is in range.
 +	 */
 +	if (!entry && check_limit && !guest_cpuid_is_amd(vcpu) &&
 +	    !cpuid_function_in_range(vcpu, function)) {
 +		max = kvm_find_cpuid_entry(vcpu, 0, 0);
 +		if (max) {
 +			function = max->eax;
 +			entry = kvm_find_cpuid_entry(vcpu, function, index);
 +		}
 +	}
++=======
+ 	bool exact, used_max_basic = false;
+ 
+ 	entry = kvm_find_cpuid_entry(vcpu, function, index);
+ 	exact = !!entry;
+ 
+ 	if (!entry && !exact_only) {
+ 		entry = get_out_of_range_cpuid_entry(vcpu, &function, index);
+ 		used_max_basic = !!entry;
+ 	}
+ 
++>>>>>>> 2b110b61644a (KVM: x86: Add blurb to CPUID tracepoint when using max basic leaf values)
  	if (entry) {
  		*eax = entry->eax;
  		*ebx = entry->ebx;
@@@ -1059,8 -1028,9 +1072,14 @@@
  			}
  		}
  	}
++<<<<<<< HEAD
 +	trace_kvm_cpuid(orig_function, *eax, *ebx, *ecx, *edx, found);
 +	return found;
++=======
+ 	trace_kvm_cpuid(orig_function, index, *eax, *ebx, *ecx, *edx, exact,
+ 			used_max_basic);
+ 	return exact;
++>>>>>>> 2b110b61644a (KVM: x86: Add blurb to CPUID tracepoint when using max basic leaf values)
  }
  EXPORT_SYMBOL_GPL(kvm_cpuid);
  
diff --cc arch/x86/kvm/trace.h
index 7c741a0c5f80,c3d1e9f4a2c0..000000000000
--- a/arch/x86/kvm/trace.h
+++ b/arch/x86/kvm/trace.h
@@@ -151,9 -151,10 +151,16 @@@ TRACE_EVENT(kvm_fast_mmio
   * Tracepoint for cpuid.
   */
  TRACE_EVENT(kvm_cpuid,
++<<<<<<< HEAD
 +	TP_PROTO(unsigned int function, unsigned long rax, unsigned long rbx,
 +		 unsigned long rcx, unsigned long rdx, bool found),
 +	TP_ARGS(function, rax, rbx, rcx, rdx, found),
++=======
+ 	TP_PROTO(unsigned int function, unsigned int index, unsigned long rax,
+ 		 unsigned long rbx, unsigned long rcx, unsigned long rdx,
+ 		 bool found, bool used_max_basic),
+ 	TP_ARGS(function, index, rax, rbx, rcx, rdx, found, used_max_basic),
++>>>>>>> 2b110b61644a (KVM: x86: Add blurb to CPUID tracepoint when using max basic leaf values)
  
  	TP_STRUCT__entry(
  		__field(	unsigned int,	function	)
@@@ -171,12 -175,14 +179,19 @@@
  		__entry->rcx		= rcx;
  		__entry->rdx		= rdx;
  		__entry->found		= found;
+ 		__entry->used_max_basic	= used_max_basic;
  	),
  
++<<<<<<< HEAD
 +	TP_printk("func %x rax %lx rbx %lx rcx %lx rdx %lx, cpuid entry %s",
 +		  __entry->function, __entry->rax,
++=======
+ 	TP_printk("func %x idx %x rax %lx rbx %lx rcx %lx rdx %lx, cpuid entry %s%s",
+ 		  __entry->function, __entry->index, __entry->rax,
++>>>>>>> 2b110b61644a (KVM: x86: Add blurb to CPUID tracepoint when using max basic leaf values)
  		  __entry->rbx, __entry->rcx, __entry->rdx,
- 		  __entry->found ? "found" : "not found")
+ 		  __entry->found ? "found" : "not found",
+ 		  __entry->used_max_basic ? ", used max basic" : "")
  );
  
  #define AREG(x) { APIC_##x, "APIC_" #x }
* Unmerged path arch/x86/kvm/cpuid.c
* Unmerged path arch/x86/kvm/trace.h
