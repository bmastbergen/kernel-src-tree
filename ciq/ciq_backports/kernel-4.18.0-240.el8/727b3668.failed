net: sfp: rework upstream interface

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit 727b3668b730634228fc65c336c2a7a080e02885
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/727b3668.failed

The current upstream interface is an all-or-nothing, which is
sub-optimal for future changes, as it doesn't allow the upstream driver
to prepare for the SFP module becoming available, as it is at boot.

Switch to a find-sfp-bus, add-upstream, del-upstream, put-sfp-bus
interface structure instead, which allows the upstream driver to
prepare for a module being available as soon as add-upstream is called.

	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 727b3668b730634228fc65c336c2a7a080e02885)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phylink.c
#	drivers/net/phy/sfp-bus.c
#	include/linux/sfp.h
diff --cc drivers/net/phy/phylink.c
index 3e70c842a997,e3fbc8e93317..000000000000
--- a/drivers/net/phy/phylink.c
+++ b/drivers/net/phy/phylink.c
@@@ -505,28 -564,22 +505,38 @@@ static const struct sfp_upstream_ops sf
  static int phylink_register_sfp(struct phylink *pl,
  				struct fwnode_handle *fwnode)
  {
 -	struct sfp_bus *bus;
 +	struct fwnode_reference_args ref;
  	int ret;
  
++<<<<<<< HEAD
 +	if (!fwnode)
 +		return 0;
 +
 +	ret = fwnode_property_get_reference_args(fwnode, "sfp", NULL,
 +						 0, 0, &ref);
 +	if (ret < 0) {
 +		if (ret == -ENOENT)
 +			return 0;
 +
 +		netdev_err(pl->netdev, "unable to parse \"sfp\" node: %d\n",
 +			   ret);
++=======
+ 	bus = sfp_bus_find_fwnode(fwnode);
+ 	if (IS_ERR(bus)) {
+ 		ret = PTR_ERR(bus);
+ 		phylink_err(pl, "unable to attach SFP bus: %d\n", ret);
++>>>>>>> 727b3668b730 (net: sfp: rework upstream interface)
  		return ret;
  	}
  
 -	pl->sfp_bus = bus;
 +	pl->sfp_bus = sfp_register_upstream(ref.fwnode, pl, &sfp_phylink_ops);
 +	if (!pl->sfp_bus)
 +		return -ENOMEM;
  
- 	return 0;
+ 	ret = sfp_bus_add_upstream(bus, pl, &sfp_phylink_ops);
+ 	sfp_bus_put(bus);
+ 
+ 	return ret;
  }
  
  /**
diff --cc drivers/net/phy/sfp-bus.c
index 5bc8099eaaf1,715d45214e18..000000000000
--- a/drivers/net/phy/sfp-bus.c
+++ b/drivers/net/phy/sfp-bus.c
@@@ -444,64 -455,111 +453,136 @@@ static void sfp_upstream_clear(struct s
  }
  
  /**
++<<<<<<< HEAD
 + * sfp_register_upstream() - Register the neighbouring device
 + * @fwnode: firmware node for the SFP bus
 + * @upstream: the upstream private data
 + * @ops: the upstream's &struct sfp_upstream_ops
 + *
 + * Register the upstream device (eg, PHY) with the SFP bus. MAC drivers
 + * should use phylink, which will call this function for them. Returns
 + * a pointer to the allocated &struct sfp_bus.
++=======
+  * sfp_bus_find_fwnode() - parse and locate the SFP bus from fwnode
+  * @fwnode: firmware node for the parent device (MAC or PHY)
+  *
+  * Parse the parent device's firmware node for a SFP bus, and locate
+  * the sfp_bus structure, incrementing its reference count.  This must
+  * be put via sfp_bus_put() when done.
++>>>>>>> 727b3668b730 (net: sfp: rework upstream interface)
   *
 - * Returns: on success, a pointer to the sfp_bus structure,
 - *	    %NULL if no SFP is specified,
 - * 	    on failure, an error pointer value:
 - * 		corresponding to the errors detailed for
 - * 		fwnode_property_get_reference_args().
 - * 	        %-ENOMEM if we failed to allocate the bus.
 - *		an error from the upstream's connect_phy() method.
 + * On error, returns %NULL.
   */
++<<<<<<< HEAD
 +struct sfp_bus *sfp_register_upstream(struct fwnode_handle *fwnode,
 +				      void *upstream,
 +				      const struct sfp_upstream_ops *ops)
++=======
+ struct sfp_bus *sfp_bus_find_fwnode(struct fwnode_handle *fwnode)
++>>>>>>> 727b3668b730 (net: sfp: rework upstream interface)
  {
 -	struct fwnode_reference_args ref;
 -	struct sfp_bus *bus;
 -	int ret;
 +	struct sfp_bus *bus = sfp_bus_get(fwnode);
 +	int ret = 0;
  
 -	ret = fwnode_property_get_reference_args(fwnode, "sfp", NULL,
 -						 0, 0, &ref);
 -	if (ret == -ENOENT)
 -		return NULL;
 -	else if (ret < 0)
 -		return ERR_PTR(ret);
 +	if (bus) {
 +		rtnl_lock();
 +		bus->upstream_ops = ops;
 +		bus->upstream = upstream;
  
++<<<<<<< HEAD
 +		if (bus->sfp) {
 +			ret = sfp_register_bus(bus);
 +			if (ret)
 +				sfp_upstream_clear(bus);
 +		}
 +		rtnl_unlock();
++=======
+ 	bus = sfp_bus_get(ref.fwnode);
+ 	fwnode_handle_put(ref.fwnode);
+ 	if (!bus)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	return bus;
+ }
+ EXPORT_SYMBOL_GPL(sfp_bus_find_fwnode);
+ 
+ /**
+  * sfp_bus_add_upstream() - parse and register the neighbouring device
+  * @bus: the &struct sfp_bus found via sfp_bus_find_fwnode()
+  * @upstream: the upstream private data
+  * @ops: the upstream's &struct sfp_upstream_ops
+  *
+  * Add upstream driver for the SFP bus, and if the bus is complete, register
+  * the SFP bus using sfp_register_upstream().  This takes a reference on the
+  * bus, so it is safe to put the bus after this call.
+  *
+  * Returns: on success, a pointer to the sfp_bus structure,
+  *	    %NULL if no SFP is specified,
+  * 	    on failure, an error pointer value:
+  * 		corresponding to the errors detailed for
+  * 		fwnode_property_get_reference_args().
+  * 	        %-ENOMEM if we failed to allocate the bus.
+  *		an error from the upstream's connect_phy() method.
+  */
+ int sfp_bus_add_upstream(struct sfp_bus *bus, void *upstream,
+ 			 const struct sfp_upstream_ops *ops)
+ {
+ 	int ret;
+ 
+ 	/* If no bus, return success */
+ 	if (!bus)
+ 		return 0;
+ 
+ 	rtnl_lock();
+ 	kref_get(&bus->kref);
+ 	bus->upstream_ops = ops;
+ 	bus->upstream = upstream;
+ 
+ 	if (bus->sfp) {
+ 		ret = sfp_register_bus(bus);
+ 		if (ret)
+ 			sfp_upstream_clear(bus);
+ 	} else {
+ 		ret = 0;
++>>>>>>> 727b3668b730 (net: sfp: rework upstream interface)
  	}
 -	rtnl_unlock();
  
- 	if (ret) {
+ 	if (ret)
  		sfp_bus_put(bus);
++<<<<<<< HEAD
 +		bus = NULL;
 +	}
++=======
++>>>>>>> 727b3668b730 (net: sfp: rework upstream interface)
  
- 	return bus;
+ 	return ret;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(sfp_register_upstream);
++=======
+ EXPORT_SYMBOL_GPL(sfp_bus_add_upstream);
++>>>>>>> 727b3668b730 (net: sfp: rework upstream interface)
  
  /**
-  * sfp_unregister_upstream() - Unregister sfp bus
+  * sfp_bus_del_upstream() - Delete a sfp bus
   * @bus: a pointer to the &struct sfp_bus structure for the sfp module
   *
-  * Unregister a previously registered upstream connection for the SFP
-  * module. @bus is returned from sfp_register_upstream().
+  * Delete a previously registered upstream connection for the SFP
+  * module. @bus should have been added by sfp_bus_add_upstream().
   */
- void sfp_unregister_upstream(struct sfp_bus *bus)
+ void sfp_bus_del_upstream(struct sfp_bus *bus)
  {
- 	rtnl_lock();
- 	if (bus->sfp)
- 		sfp_unregister_bus(bus);
- 	sfp_upstream_clear(bus);
- 	rtnl_unlock();
+ 	if (bus) {
+ 		rtnl_lock();
+ 		if (bus->sfp)
+ 			sfp_unregister_bus(bus);
+ 		sfp_upstream_clear(bus);
+ 		rtnl_unlock();
  
- 	sfp_bus_put(bus);
+ 		sfp_bus_put(bus);
+ 	}
  }
- EXPORT_SYMBOL_GPL(sfp_unregister_upstream);
+ EXPORT_SYMBOL_GPL(sfp_bus_del_upstream);
  
  /* Socket driver entry points */
  int sfp_add_phy(struct sfp_bus *bus, struct phy_device *phydev)
diff --cc include/linux/sfp.h
index fb3eeec347a9,c8464de7cff5..000000000000
--- a/include/linux/sfp.h
+++ b/include/linux/sfp.h
@@@ -508,10 -508,11 +508,18 @@@ int sfp_get_module_eeprom(struct sfp_bu
  			  u8 *data);
  void sfp_upstream_start(struct sfp_bus *bus);
  void sfp_upstream_stop(struct sfp_bus *bus);
++<<<<<<< HEAD
 +struct sfp_bus *sfp_register_upstream(struct fwnode_handle *fwnode,
 +				      void *upstream,
 +				      const struct sfp_upstream_ops *ops);
 +void sfp_unregister_upstream(struct sfp_bus *bus);
++=======
+ void sfp_bus_put(struct sfp_bus *bus);
+ struct sfp_bus *sfp_bus_find_fwnode(struct fwnode_handle *fwnode);
+ int sfp_bus_add_upstream(struct sfp_bus *bus, void *upstream,
+ 			 const struct sfp_upstream_ops *ops);
+ void sfp_bus_del_upstream(struct sfp_bus *bus);
++>>>>>>> 727b3668b730 (net: sfp: rework upstream interface)
  #else
  static inline int sfp_parse_port(struct sfp_bus *bus,
  				 const struct sfp_eeprom_id *id,
@@@ -553,14 -554,22 +561,28 @@@ static inline void sfp_upstream_stop(st
  {
  }
  
++<<<<<<< HEAD
 +static inline struct sfp_bus *sfp_register_upstream(
 +	struct fwnode_handle *fwnode, void *upstream,
 +	const struct sfp_upstream_ops *ops)
++=======
+ static inline void sfp_bus_put(struct sfp_bus *bus)
+ {
+ }
+ 
+ static inline struct sfp_bus *sfp_bus_find_fwnode(struct fwnode_handle *fwnode)
++>>>>>>> 727b3668b730 (net: sfp: rework upstream interface)
  {
 -	return NULL;
 +	return (struct sfp_bus *)-1;
  }
  
- static inline void sfp_unregister_upstream(struct sfp_bus *bus)
+ static int sfp_bus_add_upstream(struct sfp_bus *bus, void *upstream,
+ 				const struct sfp_upstream_ops *ops)
+ {
+ 	return 0;
+ }
+ 
+ static inline void sfp_bus_del_upstream(struct sfp_bus *bus)
  {
  }
  #endif
* Unmerged path drivers/net/phy/phylink.c
* Unmerged path drivers/net/phy/sfp-bus.c
* Unmerged path include/linux/sfp.h
