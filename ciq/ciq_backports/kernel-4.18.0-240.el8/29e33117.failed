perf cpumap: No need to include perf.h, ditch it

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 29e331176da121db22daa5dd9d72533b6a1efb33
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/29e33117.failed

From a quick look this was never needed and just polluted the build,
needlessly making things including cpumap.h to be rebuild if perf.h or
anything it includes gets changed.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
Link: https://lkml.kernel.org/n/tip-x10p8slllqkn3fc3bntjx3n0@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 29e331176da121db22daa5dd9d72533b6a1efb33)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/cpumap.h
diff --cc tools/perf/util/cpumap.h
index 1265f0e33920,c2519e7ea958..000000000000
--- a/tools/perf/util/cpumap.h
+++ b/tools/perf/util/cpumap.h
@@@ -4,40 -4,28 +4,44 @@@
  
  #include <stdio.h>
  #include <stdbool.h>
 -#include <internal/cpumap.h>
 -#include <perf/cpumap.h>
 +#include <linux/refcount.h>
  
++<<<<<<< HEAD
 +#include "perf.h"
 +#include "util/debug.h"
 +
 +struct cpu_map {
 +	refcount_t refcnt;
 +	int nr;
 +	int map[];
 +};
++=======
+ struct cpu_map_data;
++>>>>>>> 29e331176da1 (perf cpumap: No need to include perf.h, ditch it)
  
 -struct perf_cpu_map *perf_cpu_map__empty_new(int nr);
 -struct perf_cpu_map *cpu_map__new_data(struct cpu_map_data *data);
 -size_t cpu_map__snprint(struct perf_cpu_map *map, char *buf, size_t size);
 -size_t cpu_map__snprint_mask(struct perf_cpu_map *map, char *buf, size_t size);
 -size_t cpu_map__fprintf(struct perf_cpu_map *map, FILE *fp);
 +struct cpu_map *cpu_map__new(const char *cpu_list);
 +struct cpu_map *cpu_map__empty_new(int nr);
 +struct cpu_map *cpu_map__dummy_new(void);
 +struct cpu_map *cpu_map__new_data(struct cpu_map_data *data);
 +struct cpu_map *cpu_map__read(FILE *file);
 +size_t cpu_map__snprint(struct cpu_map *map, char *buf, size_t size);
 +size_t cpu_map__snprint_mask(struct cpu_map *map, char *buf, size_t size);
 +size_t cpu_map__fprintf(struct cpu_map *map, FILE *fp);
  int cpu_map__get_socket_id(int cpu);
 -int cpu_map__get_socket(struct perf_cpu_map *map, int idx, void *data);
 +int cpu_map__get_socket(struct cpu_map *map, int idx, void *data);
  int cpu_map__get_die_id(int cpu);
 -int cpu_map__get_die(struct perf_cpu_map *map, int idx, void *data);
 +int cpu_map__get_die(struct cpu_map *map, int idx, void *data);
  int cpu_map__get_core_id(int cpu);
 -int cpu_map__get_core(struct perf_cpu_map *map, int idx, void *data);
 -int cpu_map__build_socket_map(struct perf_cpu_map *cpus, struct perf_cpu_map **sockp);
 -int cpu_map__build_die_map(struct perf_cpu_map *cpus, struct perf_cpu_map **diep);
 -int cpu_map__build_core_map(struct perf_cpu_map *cpus, struct perf_cpu_map **corep);
 -const struct perf_cpu_map *cpu_map__online(void); /* thread unsafe */
 +int cpu_map__get_core(struct cpu_map *map, int idx, void *data);
 +int cpu_map__build_socket_map(struct cpu_map *cpus, struct cpu_map **sockp);
 +int cpu_map__build_die_map(struct cpu_map *cpus, struct cpu_map **diep);
 +int cpu_map__build_core_map(struct cpu_map *cpus, struct cpu_map **corep);
 +const struct cpu_map *cpu_map__online(void); /* thread unsafe */
 +
 +struct cpu_map *cpu_map__get(struct cpu_map *map);
 +void cpu_map__put(struct cpu_map *map);
  
 -static inline int cpu_map__socket(struct perf_cpu_map *sock, int s)
 +static inline int cpu_map__socket(struct cpu_map *sock, int s)
  {
  	if (!sock || s > sock->nr || s < 0)
  		return 0;
* Unmerged path tools/perf/util/cpumap.h
