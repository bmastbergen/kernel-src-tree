crypto: ecc - SP800-56A rev 3 local public key validation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Stephan MÃ¼ller <smueller@chronox.de>
commit 6914dd53eb7af7cbc66edf7992d600b1e952c40d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6914dd53.failed

After the generation of a local public key, SP800-56A rev 3 section
5.6.2.1.3 mandates a validation of that key with a full validation
compliant to section 5.6.2.3.3.

Only if the full validation passes, the key is allowed to be used.

The patch adds the full key validation compliant to 5.6.2.3.3 and
performs the required check on the generated public key.

	Signed-off-by: Stephan Mueller <smueller@chronox.de>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 6914dd53eb7af7cbc66edf7992d600b1e952c40d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/ecc.h
diff --cc crypto/ecc.h
index f75a86baa3bd,d4e546b9ad79..000000000000
--- a/crypto/ecc.h
+++ b/crypto/ecc.h
@@@ -91,4 -129,131 +91,134 @@@ int ecc_make_pub_key(const unsigned in
  int crypto_ecdh_shared_secret(unsigned int curve_id, unsigned int ndigits,
  			      const u64 *private_key, const u64 *public_key,
  			      u64 *secret);
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * ecc_is_pubkey_valid_partial() - Partial public key validation
+  *
+  * @curve:		elliptic curve domain parameters
+  * @pk:			public key as a point
+  *
+  * Valdiate public key according to SP800-56A section 5.6.2.3.4 ECC Partial
+  * Public-Key Validation Routine.
+  *
+  * Note: There is no check that the public key is in the correct elliptic curve
+  * subgroup.
+  *
+  * Return: 0 if validation is successful, -EINVAL if validation is failed.
+  */
+ int ecc_is_pubkey_valid_partial(const struct ecc_curve *curve,
+ 				struct ecc_point *pk);
+ 
+ /**
+  * ecc_is_pubkey_valid_full() - Full public key validation
+  *
+  * @curve:		elliptic curve domain parameters
+  * @pk:			public key as a point
+  *
+  * Valdiate public key according to SP800-56A section 5.6.2.3.3 ECC Full
+  * Public-Key Validation Routine.
+  *
+  * Return: 0 if validation is successful, -EINVAL if validation is failed.
+  */
+ int ecc_is_pubkey_valid_full(const struct ecc_curve *curve,
+ 			     struct ecc_point *pk);
+ 
+ /**
+  * vli_is_zero() - Determine is vli is zero
+  *
+  * @vli:		vli to check.
+  * @ndigits:		length of the @vli
+  */
+ bool vli_is_zero(const u64 *vli, unsigned int ndigits);
+ 
+ /**
+  * vli_cmp() - compare left and right vlis
+  *
+  * @left:		vli
+  * @right:		vli
+  * @ndigits:		length of both vlis
+  *
+  * Returns sign of @left - @right, i.e. -1 if @left < @right,
+  * 0 if @left == @right, 1 if @left > @right.
+  */
+ int vli_cmp(const u64 *left, const u64 *right, unsigned int ndigits);
+ 
+ /**
+  * vli_sub() - Subtracts right from left
+  *
+  * @result:		where to write result
+  * @left:		vli
+  * @right		vli
+  * @ndigits:		length of all vlis
+  *
+  * Note: can modify in-place.
+  *
+  * Return: carry bit.
+  */
+ u64 vli_sub(u64 *result, const u64 *left, const u64 *right,
+ 	    unsigned int ndigits);
+ 
+ /**
+  * vli_from_be64() - Load vli from big-endian u64 array
+  *
+  * @dest:		destination vli
+  * @src:		source array of u64 BE values
+  * @ndigits:		length of both vli and array
+  */
+ void vli_from_be64(u64 *dest, const void *src, unsigned int ndigits);
+ 
+ /**
+  * vli_from_le64() - Load vli from little-endian u64 array
+  *
+  * @dest:		destination vli
+  * @src:		source array of u64 LE values
+  * @ndigits:		length of both vli and array
+  */
+ void vli_from_le64(u64 *dest, const void *src, unsigned int ndigits);
+ 
+ /**
+  * vli_mod_inv() - Modular inversion
+  *
+  * @result:		where to write vli number
+  * @input:		vli value to operate on
+  * @mod:		modulus
+  * @ndigits:		length of all vlis
+  */
+ void vli_mod_inv(u64 *result, const u64 *input, const u64 *mod,
+ 		 unsigned int ndigits);
+ 
+ /**
+  * vli_mod_mult_slow() - Modular multiplication
+  *
+  * @result:		where to write result value
+  * @left:		vli number to multiply with @right
+  * @right:		vli number to multiply with @left
+  * @mod:		modulus
+  * @ndigits:		length of all vlis
+  *
+  * Note: Assumes that mod is big enough curve order.
+  */
+ void vli_mod_mult_slow(u64 *result, const u64 *left, const u64 *right,
+ 		       const u64 *mod, unsigned int ndigits);
+ 
+ /**
+  * ecc_point_mult_shamir() - Add two points multiplied by scalars
+  *
+  * @result:		resulting point
+  * @x:			scalar to multiply with @p
+  * @p:			point to multiply with @x
+  * @y:			scalar to multiply with @q
+  * @q:			point to multiply with @y
+  * @curve:		curve
+  *
+  * Returns result = x * p + x * q over the curve.
+  * This works faster than two multiplications and addition.
+  */
+ void ecc_point_mult_shamir(const struct ecc_point *result,
+ 			   const u64 *x, const struct ecc_point *p,
+ 			   const u64 *y, const struct ecc_point *q,
+ 			   const struct ecc_curve *curve);
++>>>>>>> 6914dd53eb7a (crypto: ecc - SP800-56A rev 3 local public key validation)
  #endif
diff --git a/crypto/ecc.c b/crypto/ecc.c
index 71c32b64d990..6f473573b944 100644
--- a/crypto/ecc.c
+++ b/crypto/ecc.c
@@ -1023,7 +1023,9 @@ int ecc_make_pub_key(unsigned int curve_id, unsigned int ndigits,
 	}
 
 	ecc_point_mult(pk, &curve->g, priv, NULL, curve, ndigits);
-	if (ecc_point_is_zero(pk)) {
+
+	/* SP800-56A rev 3 5.6.2.1.3 key check */
+	if (ecc_is_pubkey_valid_full(curve, pk)) {
 		ret = -EAGAIN;
 		goto err_free_point;
 	}
@@ -1067,6 +1069,33 @@ static int ecc_is_pubkey_valid_partial(const struct ecc_curve *curve,
 
 }
 
+/* SP800-56A section 5.6.2.3.3 full verification */
+int ecc_is_pubkey_valid_full(const struct ecc_curve *curve,
+			     struct ecc_point *pk)
+{
+	struct ecc_point *nQ;
+
+	/* Checks 1 through 3 */
+	int ret = ecc_is_pubkey_valid_partial(curve, pk);
+
+	if (ret)
+		return ret;
+
+	/* Check 4: Verify that nQ is the zero point. */
+	nQ = ecc_alloc_point(pk->ndigits);
+	if (!nQ)
+		return -ENOMEM;
+
+	ecc_point_mult(nQ, pk, curve->n, NULL, curve, pk->ndigits);
+	if (!ecc_point_is_zero(nQ))
+		ret = -EINVAL;
+
+	ecc_free_point(nQ);
+
+	return ret;
+}
+EXPORT_SYMBOL(ecc_is_pubkey_valid_full);
+
 int crypto_ecdh_shared_secret(unsigned int curve_id, unsigned int ndigits,
 			      const u64 *private_key, const u64 *public_key,
 			      u64 *secret)
* Unmerged path crypto/ecc.h
