Bluetooth: hci_qca: Add delay for wcn3990 stability

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jeffrey Hugo <jeffrey.l.hugo@gmail.com>
commit cde9dde6e11a5ab54b6462cd46d82878926783bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/cde9dde6.failed

On the msm8998 mtp, the response to the baudrate change command is never
received.  On the Lenovo Miix 630, the response to the baudrate change
command is corrupted - "Frame reassembly failed (-84)".

Adding a 50ms delay before re-enabling flow to receive the baudrate change
command response from the wcn3990 addesses both issues, and allows
bluetooth to become functional.

	Signed-off-by: Jeffrey Hugo <jeffrey.l.hugo@gmail.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit cde9dde6e11a5ab54b6462cd46d82878926783bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/hci_qca.c
diff --cc drivers/bluetooth/hci_qca.c
index c7723b08787d,265fc60c3850..000000000000
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@@ -909,6 -1046,189 +909,192 @@@ static inline void host_set_baudrate(st
  		hci_uart_set_baudrate(hu, speed);
  }
  
++<<<<<<< HEAD
++=======
+ static int qca_send_power_pulse(struct hci_uart *hu, bool on)
+ {
+ 	int ret;
+ 	int timeout = msecs_to_jiffies(CMD_TRANS_TIMEOUT_MS);
+ 	u8 cmd = on ? QCA_WCN3990_POWERON_PULSE : QCA_WCN3990_POWEROFF_PULSE;
+ 
+ 	/* These power pulses are single byte command which are sent
+ 	 * at required baudrate to wcn3990. On wcn3990, we have an external
+ 	 * circuit at Tx pin which decodes the pulse sent at specific baudrate.
+ 	 * For example, wcn3990 supports RF COEX antenna for both Wi-Fi/BT
+ 	 * and also we use the same power inputs to turn on and off for
+ 	 * Wi-Fi/BT. Powering up the power sources will not enable BT, until
+ 	 * we send a power on pulse at 115200 bps. This algorithm will help to
+ 	 * save power. Disabling hardware flow control is mandatory while
+ 	 * sending power pulses to SoC.
+ 	 */
+ 	bt_dev_dbg(hu->hdev, "sending power pulse %02x to controller", cmd);
+ 
+ 	serdev_device_write_flush(hu->serdev);
+ 	hci_uart_set_flow_control(hu, true);
+ 	ret = serdev_device_write_buf(hu->serdev, &cmd, sizeof(cmd));
+ 	if (ret < 0) {
+ 		bt_dev_err(hu->hdev, "failed to send power pulse %02x", cmd);
+ 		return ret;
+ 	}
+ 
+ 	serdev_device_wait_until_sent(hu->serdev, timeout);
+ 	hci_uart_set_flow_control(hu, false);
+ 
+ 	/* Give to controller time to boot/shutdown */
+ 	if (on)
+ 		msleep(100);
+ 	else
+ 		msleep(10);
+ 
+ 	return 0;
+ }
+ 
+ static unsigned int qca_get_speed(struct hci_uart *hu,
+ 				  enum qca_speed_type speed_type)
+ {
+ 	unsigned int speed = 0;
+ 
+ 	if (speed_type == QCA_INIT_SPEED) {
+ 		if (hu->init_speed)
+ 			speed = hu->init_speed;
+ 		else if (hu->proto->init_speed)
+ 			speed = hu->proto->init_speed;
+ 	} else {
+ 		if (hu->oper_speed)
+ 			speed = hu->oper_speed;
+ 		else if (hu->proto->oper_speed)
+ 			speed = hu->proto->oper_speed;
+ 	}
+ 
+ 	return speed;
+ }
+ 
+ static int qca_check_speeds(struct hci_uart *hu)
+ {
+ 	if (qca_is_wcn399x(qca_soc_type(hu))) {
+ 		if (!qca_get_speed(hu, QCA_INIT_SPEED) &&
+ 		    !qca_get_speed(hu, QCA_OPER_SPEED))
+ 			return -EINVAL;
+ 	} else {
+ 		if (!qca_get_speed(hu, QCA_INIT_SPEED) ||
+ 		    !qca_get_speed(hu, QCA_OPER_SPEED))
+ 			return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int qca_set_speed(struct hci_uart *hu, enum qca_speed_type speed_type)
+ {
+ 	unsigned int speed, qca_baudrate;
+ 	struct qca_data *qca = hu->priv;
+ 	int ret = 0;
+ 
+ 	if (speed_type == QCA_INIT_SPEED) {
+ 		speed = qca_get_speed(hu, QCA_INIT_SPEED);
+ 		if (speed)
+ 			host_set_baudrate(hu, speed);
+ 	} else {
+ 		enum qca_btsoc_type soc_type = qca_soc_type(hu);
+ 
+ 		speed = qca_get_speed(hu, QCA_OPER_SPEED);
+ 		if (!speed)
+ 			return 0;
+ 
+ 		/* Disable flow control for wcn3990 to deassert RTS while
+ 		 * changing the baudrate of chip and host.
+ 		 */
+ 		if (qca_is_wcn399x(soc_type))
+ 			hci_uart_set_flow_control(hu, true);
+ 
+ 		if (soc_type == QCA_WCN3990) {
+ 			reinit_completion(&qca->drop_ev_comp);
+ 			set_bit(QCA_DROP_VENDOR_EVENT, &qca->flags);
+ 		}
+ 
+ 		qca_baudrate = qca_get_baudrate_value(speed);
+ 		bt_dev_dbg(hu->hdev, "Set UART speed to %d", speed);
+ 		ret = qca_set_baudrate(hu->hdev, qca_baudrate);
+ 		if (ret)
+ 			goto error;
+ 
+ 		host_set_baudrate(hu, speed);
+ 
+ error:
+ 		if (qca_is_wcn399x(soc_type)) {
+ 			msleep(50);
+ 			hci_uart_set_flow_control(hu, false);
+ 		}
+ 
+ 		if (soc_type == QCA_WCN3990) {
+ 			/* Wait for the controller to send the vendor event
+ 			 * for the baudrate change command.
+ 			 */
+ 			if (!wait_for_completion_timeout(&qca->drop_ev_comp,
+ 						 msecs_to_jiffies(100))) {
+ 				bt_dev_err(hu->hdev,
+ 					   "Failed to change controller baudrate\n");
+ 				ret = -ETIMEDOUT;
+ 			}
+ 
+ 			clear_bit(QCA_DROP_VENDOR_EVENT, &qca->flags);
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int qca_wcn3990_init(struct hci_uart *hu)
+ {
+ 	struct qca_serdev *qcadev;
+ 	int ret;
+ 
+ 	/* Check for vregs status, may be hci down has turned
+ 	 * off the voltage regulator.
+ 	 */
+ 	qcadev = serdev_device_get_drvdata(hu->serdev);
+ 	if (!qcadev->bt_power->vregs_on) {
+ 		serdev_device_close(hu->serdev);
+ 		ret = qca_power_setup(hu, true);
+ 		if (ret)
+ 			return ret;
+ 
+ 		ret = serdev_device_open(hu->serdev);
+ 		if (ret) {
+ 			bt_dev_err(hu->hdev, "failed to open port");
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	/* Forcefully enable wcn3990 to enter in to boot mode. */
+ 	host_set_baudrate(hu, 2400);
+ 	ret = qca_send_power_pulse(hu, false);
+ 	if (ret)
+ 		return ret;
+ 
+ 	qca_set_speed(hu, QCA_INIT_SPEED);
+ 	ret = qca_send_power_pulse(hu, true);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* Now the device is in ready state to communicate with host.
+ 	 * To sync host with device we need to reopen port.
+ 	 * Without this, we will have RTS and CTS synchronization
+ 	 * issues.
+ 	 */
+ 	serdev_device_close(hu->serdev);
+ 	ret = serdev_device_open(hu->serdev);
+ 	if (ret) {
+ 		bt_dev_err(hu->hdev, "failed to open port");
+ 		return ret;
+ 	}
+ 
+ 	hci_uart_set_flow_control(hu, false);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> cde9dde6e11a (Bluetooth: hci_qca: Add delay for wcn3990 stability)
  static int qca_setup(struct hci_uart *hu)
  {
  	struct hci_dev *hdev = hu->hdev;
* Unmerged path drivers/bluetooth/hci_qca.c
