bpf: Prevent mmap()'ing read-only maps as writable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit dfeb376dd4cb2c5004aeb625e2475f58a5ff2ea7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dfeb376d.failed

As discussed in [0], it's dangerous to allow mapping BPF map, that's meant to
be frozen and is read-only on BPF program side, because that allows user-space
to actually store a writable view to the page even after it is frozen. This is
exacerbated by BPF verifier making a strong assumption that contents of such
frozen map will remain unchanged. To prevent this, disallow mapping
BPF_F_RDONLY_PROG mmap()'able BPF maps as writable, ever.

  [0] https://lore.kernel.org/bpf/CAEf4BzYGWYhXdp6BJ7_=9OQPJxQpgug080MMjdSB72i9R+5c6g@mail.gmail.com/

Fixes: fc9702273e2e ("bpf: Add mmap() support for BPF_MAP_TYPE_ARRAY")
	Suggested-by: Jann Horn <jannh@google.com>
	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Reviewed-by: Jann Horn <jannh@google.com>
Link: https://lore.kernel.org/bpf/20200519053824.1089415-1-andriin@fb.com
(cherry picked from commit dfeb376dd4cb2c5004aeb625e2475f58a5ff2ea7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/syscall.c
#	tools/testing/selftests/bpf/prog_tests/mmap.c
diff --cc kernel/bpf/syscall.c
index c66cb8c29897,4e6dee19a668..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -453,6 -581,83 +453,86 @@@ static ssize_t bpf_dummy_write(struct f
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ /* called for any extra memory-mapped regions (except initial) */
+ static void bpf_map_mmap_open(struct vm_area_struct *vma)
+ {
+ 	struct bpf_map *map = vma->vm_file->private_data;
+ 
+ 	if (vma->vm_flags & VM_MAYWRITE) {
+ 		mutex_lock(&map->freeze_mutex);
+ 		map->writecnt++;
+ 		mutex_unlock(&map->freeze_mutex);
+ 	}
+ }
+ 
+ /* called for all unmapped memory region (including initial) */
+ static void bpf_map_mmap_close(struct vm_area_struct *vma)
+ {
+ 	struct bpf_map *map = vma->vm_file->private_data;
+ 
+ 	if (vma->vm_flags & VM_MAYWRITE) {
+ 		mutex_lock(&map->freeze_mutex);
+ 		map->writecnt--;
+ 		mutex_unlock(&map->freeze_mutex);
+ 	}
+ }
+ 
+ static const struct vm_operations_struct bpf_map_default_vmops = {
+ 	.open		= bpf_map_mmap_open,
+ 	.close		= bpf_map_mmap_close,
+ };
+ 
+ static int bpf_map_mmap(struct file *filp, struct vm_area_struct *vma)
+ {
+ 	struct bpf_map *map = filp->private_data;
+ 	int err;
+ 
+ 	if (!map->ops->map_mmap || map_value_has_spin_lock(map))
+ 		return -ENOTSUPP;
+ 
+ 	if (!(vma->vm_flags & VM_SHARED))
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&map->freeze_mutex);
+ 
+ 	if (vma->vm_flags & VM_WRITE) {
+ 		if (map->frozen) {
+ 			err = -EPERM;
+ 			goto out;
+ 		}
+ 		/* map is meant to be read-only, so do not allow mapping as
+ 		 * writable, because it's possible to leak a writable page
+ 		 * reference and allows user-space to still modify it after
+ 		 * freezing, while verifier will assume contents do not change
+ 		 */
+ 		if (map->map_flags & BPF_F_RDONLY_PROG) {
+ 			err = -EACCES;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	/* set default open/close callbacks */
+ 	vma->vm_ops = &bpf_map_default_vmops;
+ 	vma->vm_private_data = map;
+ 	vma->vm_flags &= ~VM_MAYEXEC;
+ 	if (!(vma->vm_flags & VM_WRITE))
+ 		/* disallow re-mapping with PROT_WRITE */
+ 		vma->vm_flags &= ~VM_MAYWRITE;
+ 
+ 	err = map->ops->map_mmap(map, vma);
+ 	if (err)
+ 		goto out;
+ 
+ 	if (vma->vm_flags & VM_MAYWRITE)
+ 		map->writecnt++;
+ out:
+ 	mutex_unlock(&map->freeze_mutex);
+ 	return err;
+ }
+ 
++>>>>>>> dfeb376dd4cb (bpf: Prevent mmap()'ing read-only maps as writable)
  const struct file_operations bpf_map_fops = {
  #ifdef CONFIG_PROC_FS
  	.show_fdinfo	= bpf_map_show_fdinfo,
diff --cc tools/testing/selftests/bpf/prog_tests/mmap.c
index 051a6d48762c,43d0b5578f46..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/mmap.c
+++ b/tools/testing/selftests/bpf/prog_tests/mmap.c
@@@ -26,36 -19,43 +26,62 @@@ void test_mmap(void
  	const size_t map_sz = roundup_page(sizeof(struct map_data));
  	const int zero = 0, one = 1, two = 2, far = 1500;
  	const long page_size = sysconf(_SC_PAGE_SIZE);
++<<<<<<< HEAD
 +	int err, duration = 0, i, data_map_fd;
 +	struct bpf_program *prog;
 +	struct bpf_object *obj;
 +	struct bpf_link *link = NULL;
++=======
+ 	int err, duration = 0, i, data_map_fd, data_map_id, tmp_fd, rdmap_fd;
++>>>>>>> dfeb376dd4cb (bpf: Prevent mmap()'ing read-only maps as writable)
  	struct bpf_map *data_map, *bss_map;
  	void *bss_mmaped = NULL, *map_mmaped = NULL, *tmp1, *tmp2;
 -	struct test_mmap__bss *bss_data;
 -	struct bpf_map_info map_info;
 -	__u32 map_info_sz = sizeof(map_info);
 -	struct map_data *map_data;
 -	struct test_mmap *skel;
 +	volatile struct bss_data *bss_data;
 +	volatile struct map_data *map_data;
  	__u64 val = 0;
  
 -	skel = test_mmap__open_and_load();
 -	if (CHECK(!skel, "skel_open_and_load", "skeleton open/load failed\n"))
 +	obj = bpf_object__open_file("test_mmap.o", NULL);
 +	if (CHECK(IS_ERR(obj), "obj_open", "failed to open '%s': %ld\n",
 +		  file, PTR_ERR(obj)))
  		return;
 +	prog = bpf_object__find_program_by_title(obj, probe_name);
 +	if (CHECK(!prog, "find_probe", "prog '%s' not found\n", probe_name))
 +		goto cleanup;
 +	err = bpf_object__load(obj);
 +	if (CHECK(err, "obj_load", "failed to load prog '%s': %d\n",
 +		  probe_name, err))
 +		goto cleanup;
  
 -	bss_map = skel->maps.bss;
 -	data_map = skel->maps.data_map;
 +	bss_map = bpf_object__find_map_by_name(obj, "test_mma.bss");
 +	if (CHECK(!bss_map, "find_bss_map", ".bss map not found\n"))
 +		goto cleanup;
 +	data_map = bpf_object__find_map_by_name(obj, "data_map");
 +	if (CHECK(!data_map, "find_data_map", "data_map map not found\n"))
 +		goto cleanup;
  	data_map_fd = bpf_map__fd(data_map);
  
++<<<<<<< HEAD
++=======
+ 	rdmap_fd = bpf_map__fd(skel->maps.rdonly_map);
+ 	tmp1 = mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, rdmap_fd, 0);
+ 	if (CHECK(tmp1 != MAP_FAILED, "rdonly_write_mmap", "unexpected success\n")) {
+ 		munmap(tmp1, 4096);
+ 		goto cleanup;
+ 	}
+ 	/* now double-check if it's mmap()'able at all */
+ 	tmp1 = mmap(NULL, 4096, PROT_READ, MAP_SHARED, rdmap_fd, 0);
+ 	if (CHECK(tmp1 == MAP_FAILED, "rdonly_read_mmap", "failed: %d\n", errno))
+ 		goto cleanup;
+ 
+ 	/* get map's ID */
+ 	memset(&map_info, 0, map_info_sz);
+ 	err = bpf_obj_get_info_by_fd(data_map_fd, &map_info, &map_info_sz);
+ 	if (CHECK(err, "map_get_info", "failed %d\n", errno))
+ 		goto cleanup;
+ 	data_map_id = map_info.id;
+ 
+ 	/* mmap BSS map */
++>>>>>>> dfeb376dd4cb (bpf: Prevent mmap()'ing read-only maps as writable)
  	bss_mmaped = mmap(NULL, bss_sz, PROT_READ | PROT_WRITE, MAP_SHARED,
  			  bpf_map__fd(bss_map), 0);
  	if (CHECK(bss_mmaped == MAP_FAILED, "bss_mmap",
* Unmerged path kernel/bpf/syscall.c
* Unmerged path tools/testing/selftests/bpf/prog_tests/mmap.c
diff --git a/tools/testing/selftests/bpf/progs/test_mmap.c b/tools/testing/selftests/bpf/progs/test_mmap.c
index e808791b7047..3c8b430e2582 100644
--- a/tools/testing/selftests/bpf/progs/test_mmap.c
+++ b/tools/testing/selftests/bpf/progs/test_mmap.c
@@ -7,6 +7,14 @@
 
 char _license[] SEC("license") = "GPL";
 
+struct {
+	__uint(type, BPF_MAP_TYPE_ARRAY);
+	__uint(max_entries, 4096);
+	__uint(map_flags, BPF_F_MMAPABLE | BPF_F_RDONLY_PROG);
+	__type(key, __u32);
+	__type(value, char);
+} rdonly_map SEC(".maps");
+
 struct {
 	__uint(type, BPF_MAP_TYPE_ARRAY);
 	__uint(max_entries, 512 * 4); /* at least 4 pages of data */
