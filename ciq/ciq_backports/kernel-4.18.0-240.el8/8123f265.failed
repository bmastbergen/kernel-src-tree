KVM: x86/mmu: Add a helper to consolidate root sp allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 8123f265248c85603d55f4e97c68576f45eb1e4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8123f265.failed

Add a helper, mmu_alloc_root(), to consolidate the allocation of a root
shadow page, which has the same basic mechanics for all flavors of TDP
and shadow paging.

Note, __pa(sp->spt) doesn't need to be protected by mmu_lock, sp->spt
points at a kernel page.

No functional change intended.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200428023714.31923-1-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 8123f265248c85603d55f4e97c68576f45eb1e4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
diff --cc arch/x86/kvm/mmu/mmu.c
index 2c5020360749,907625fea7b3..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -3785,13 -3729,13 +3791,17 @@@ static int mmu_alloc_direct_roots(struc
  
  static int mmu_alloc_shadow_roots(struct kvm_vcpu *vcpu)
  {
- 	struct kvm_mmu_page *sp;
  	u64 pdptr, pm_mask;
++<<<<<<< HEAD
 +	gfn_t root_gfn, root_cr3;
++=======
+ 	gfn_t root_gfn, root_pgd;
+ 	hpa_t root;
++>>>>>>> 8123f265248c (KVM: x86/mmu: Add a helper to consolidate root sp allocation)
  	int i;
  
 -	root_pgd = vcpu->arch.mmu->get_guest_pgd(vcpu);
 -	root_gfn = root_pgd >> PAGE_SHIFT;
 +	root_cr3 = vcpu->arch.mmu->get_guest_pgd(vcpu);
 +	root_gfn = root_cr3 >> PAGE_SHIFT;
  
  	if (mmu_check_root(vcpu, root_gfn))
  		return 1;
@@@ -3801,22 -3745,14 +3811,14 @@@
  	 * write-protect the guests page table root.
  	 */
  	if (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {
- 		hpa_t root = vcpu->arch.mmu->root_hpa;
- 
- 		MMU_WARN_ON(VALID_PAGE(root));
+ 		MMU_WARN_ON(VALID_PAGE(vcpu->arch.mmu->root_hpa));
  
- 		spin_lock(&vcpu->kvm->mmu_lock);
- 		if (make_mmu_pages_available(vcpu) < 0) {
- 			spin_unlock(&vcpu->kvm->mmu_lock);
+ 		root = mmu_alloc_root(vcpu, root_gfn, 0,
+ 				      vcpu->arch.mmu->shadow_root_level, false);
+ 		if (!VALID_PAGE(root))
  			return -ENOSPC;
- 		}
- 		sp = kvm_mmu_get_page(vcpu, root_gfn, 0,
- 				vcpu->arch.mmu->shadow_root_level, 0, ACC_ALL);
- 		root = __pa(sp->spt);
- 		++sp->root_count;
- 		spin_unlock(&vcpu->kvm->mmu_lock);
  		vcpu->arch.mmu->root_hpa = root;
 -		goto set_root_pgd;
 +		goto set_root_cr3;
  	}
  
  	/*
* Unmerged path arch/x86/kvm/mmu/mmu.c
