ceph: reset i_requested_max_size if file write is not wanted

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Yan, Zheng <zyan@redhat.com>
commit 6f05b30ea063a2a05dda47a4105a69267ae5270f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6f05b30e.failed

write can stuck at waiting for larger max_size in following sequence of
events:

- client opens a file and writes to position 'A' (larger than unit of
  max size increment)
- client closes the file handle and updates wanted caps (not wanting
  file write caps)
- client opens and truncates the file, writes to position 'A' again.

At the 1st event, client set inode's requested_max_size to 'A'. At the
2nd event, mds removes client's writable range, but client does not reset
requested_max_size. At the 3rd event, client does not request max size
because requested_max_size is already larger than 'A'.

	Signed-off-by: "Yan, Zheng" <zyan@redhat.com>
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit 6f05b30ea063a2a05dda47a4105a69267ae5270f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/caps.c
diff --cc fs/ceph/caps.c
index e463d585a19d,53db1fcbfdd3..000000000000
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@@ -1381,47 -1359,53 +1381,59 @@@ static int __send_cap(struct ceph_mds_c
  	cap->implemented &= cap->issued | used;
  	cap->mds_wanted = want;
  
 -	arg->session = cap->session;
 -	arg->ino = ceph_vino(inode).ino;
 -	arg->cid = cap->cap_id;
 -	arg->follows = flushing ? ci->i_head_snapc->seq : 0;
 -	arg->flush_tid = flush_tid;
 -	arg->oldest_flush_tid = oldest_flush_tid;
 +	arg.ino = ceph_vino(inode).ino;
 +	arg.cid = cap->cap_id;
 +	arg.follows = flushing ? ci->i_head_snapc->seq : 0;
 +	arg.flush_tid = flush_tid;
 +	arg.oldest_flush_tid = oldest_flush_tid;
  
++<<<<<<< HEAD
 +	arg.size = inode->i_size;
 +	ci->i_reported_size = arg.size;
 +	arg.max_size = ci->i_wanted_max_size;
 +	if (cap == ci->i_auth_cap)
 +		ci->i_requested_max_size = arg.max_size;
++=======
+ 	arg->size = inode->i_size;
+ 	ci->i_reported_size = arg->size;
+ 	arg->max_size = ci->i_wanted_max_size;
+ 	if (cap == ci->i_auth_cap) {
+ 		if (want & CEPH_CAP_ANY_FILE_WR)
+ 			ci->i_requested_max_size = arg->max_size;
+ 		else
+ 			ci->i_requested_max_size = 0;
+ 	}
++>>>>>>> 6f05b30ea063 (ceph: reset i_requested_max_size if file write is not wanted)
  
  	if (flushing & CEPH_CAP_XATTR_EXCL) {
 -		arg->old_xattr_buf = __ceph_build_xattrs_blob(ci);
 -		arg->xattr_version = ci->i_xattrs.version;
 -		arg->xattr_buf = ci->i_xattrs.blob;
 +		old_blob = __ceph_build_xattrs_blob(ci);
 +		arg.xattr_version = ci->i_xattrs.version;
 +		arg.xattr_buf = ci->i_xattrs.blob;
  	} else {
 -		arg->xattr_buf = NULL;
 -		arg->old_xattr_buf = NULL;
 +		arg.xattr_buf = NULL;
  	}
  
 -	arg->mtime = inode->i_mtime;
 -	arg->atime = inode->i_atime;
 -	arg->ctime = inode->i_ctime;
 -	arg->btime = ci->i_btime;
 -	arg->change_attr = inode_peek_iversion_raw(inode);
 +	arg.mtime = inode->i_mtime;
 +	arg.atime = inode->i_atime;
 +	arg.ctime = inode->i_ctime;
 +	arg.btime = ci->i_btime;
 +	arg.change_attr = inode_peek_iversion_raw(inode);
  
 -	arg->op = op;
 -	arg->caps = cap->implemented;
 -	arg->wanted = want;
 -	arg->dirty = flushing;
 +	arg.op = op;
 +	arg.caps = cap->implemented;
 +	arg.wanted = want;
 +	arg.dirty = flushing;
  
 -	arg->seq = cap->seq;
 -	arg->issue_seq = cap->issue_seq;
 -	arg->mseq = cap->mseq;
 -	arg->time_warp_seq = ci->i_time_warp_seq;
 +	arg.seq = cap->seq;
 +	arg.issue_seq = cap->issue_seq;
 +	arg.mseq = cap->mseq;
 +	arg.time_warp_seq = ci->i_time_warp_seq;
  
 -	arg->uid = inode->i_uid;
 -	arg->gid = inode->i_gid;
 -	arg->mode = inode->i_mode;
 +	arg.uid = inode->i_uid;
 +	arg.gid = inode->i_gid;
 +	arg.mode = inode->i_mode;
  
 -	arg->inline_data = ci->i_inline_version != CEPH_INLINE_NONE;
 +	arg.inline_data = ci->i_inline_version != CEPH_INLINE_NONE;
  	if (!(flags & CEPH_CLIENT_CAPS_PENDING_CAPSNAP) &&
  	    !list_empty(&ci->i_cap_snaps)) {
  		struct ceph_cap_snap *capsnap;
* Unmerged path fs/ceph/caps.c
