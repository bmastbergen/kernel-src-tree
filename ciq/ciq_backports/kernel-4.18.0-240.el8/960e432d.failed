io_uring: use correct "is IO worker" helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 960e432dfa5927892a9b170d14de874597b84849
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/960e432d.failed

Since we switched to io-wq, the dependent link optimization for when to
pass back work inline has been broken. Fix this by providing a suitable
io-wq helper for io_uring to use to detect when to do this.

Fixes: 561fb04a6a22 ("io_uring: replace workqueue usage with io-wq")
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 960e432dfa5927892a9b170d14de874597b84849)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io-wq.h
#	fs/io_uring.c
diff --cc fs/io_uring.c
index fca9cdc96d77,3c573f0578a8..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -650,10 -862,27 +650,30 @@@ static void io_req_link_next(struct io_
  			nxt->flags |= REQ_F_LINK;
  		}
  
++<<<<<<< HEAD
 +		nxt->flags |= REQ_F_LINK_DONE;
 +		INIT_WORK(&nxt->work, io_sq_wq_submit_work);
 +		io_queue_async_work(req->ctx, nxt);
++=======
+ 		/*
+ 		 * If we're in async work, we can continue processing the chain
+ 		 * in this context instead of having to queue up new async work.
+ 		 */
+ 		if (req->flags & REQ_F_LINK_TIMEOUT) {
+ 			wake_ev = io_link_cancel_timeout(nxt);
+ 
+ 			/* we dropped this link, get next */
+ 			nxt = list_first_entry_or_null(&req->link_list,
+ 							struct io_kiocb, list);
+ 		} else if (nxtptr && io_wq_current_is_worker()) {
+ 			*nxtptr = nxt;
+ 			break;
+ 		} else {
+ 			io_queue_async_work(nxt);
+ 			break;
+ 		}
++>>>>>>> 960e432dfa59 (io_uring: use correct "is IO worker" helper)
  	}
 -
 -	if (wake_ev)
 -		io_cqring_ev_posted(ctx);
  }
  
  /*
* Unmerged path fs/io-wq.h
* Unmerged path fs/io-wq.h
* Unmerged path fs/io_uring.c
