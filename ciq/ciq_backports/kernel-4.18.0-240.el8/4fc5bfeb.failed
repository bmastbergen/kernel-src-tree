gpiolib: Make use of assign_bit() API

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 4fc5bfeb4b7d8306be6ed828df2cb5bdd14e3ed1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/4fc5bfeb.failed

We have for some time the assign_bit() API to replace open coded

	if (foo)
		set_bit(n, bar);
	else
		clear_bit(n, bar);

Use this API in GPIO library code.

No functional change intended.

	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Link: https://lore.kernel.org/r/20191204194229.64251-2-andriy.shevchenko@linux.intel.com
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 4fc5bfeb4b7d8306be6ed828df2cb5bdd14e3ed1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib.c
diff --cc drivers/gpio/gpiolib.c
index 0e900954a4ea,def586bc2568..000000000000
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@@ -229,17 -223,17 +229,31 @@@ int gpiod_get_direction(struct gpio_des
  	if (!chip->get_direction)
  		return -ENOTSUPP;
  
++<<<<<<< HEAD
 +	status = chip->get_direction(chip, offset);
 +	if (status > 0) {
 +		/* GPIOF_DIR_IN, or other positive */
 +		status = 1;
 +		clear_bit(FLAG_IS_OUT, &desc->flags);
 +	}
 +	if (status == 0) {
 +		/* GPIOF_DIR_OUT */
 +		set_bit(FLAG_IS_OUT, &desc->flags);
 +	}
 +	return status;
++=======
+ 	ret = chip->get_direction(chip, offset);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	/* GPIOF_DIR_IN or other positive, otherwise GPIOF_DIR_OUT */
+ 	if (ret > 0)
+ 		ret = 1;
+ 
+ 	assign_bit(FLAG_IS_OUT, &desc->flags, !ret);
+ 
+ 	return ret;
++>>>>>>> 4fc5bfeb4b7d (gpiolib: Make use of assign_bit() API)
  }
  EXPORT_SYMBOL_GPL(gpiod_get_direction);
  
@@@ -440,6 -436,112 +454,115 @@@ struct linehandle_state 
  	GPIOHANDLE_REQUEST_OPEN_DRAIN | \
  	GPIOHANDLE_REQUEST_OPEN_SOURCE)
  
++<<<<<<< HEAD
++=======
+ static int linehandle_validate_flags(u32 flags)
+ {
+ 	/* Return an error if an unknown flag is set */
+ 	if (flags & ~GPIOHANDLE_REQUEST_VALID_FLAGS)
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * Do not allow both INPUT & OUTPUT flags to be set as they are
+ 	 * contradictory.
+ 	 */
+ 	if ((flags & GPIOHANDLE_REQUEST_INPUT) &&
+ 	    (flags & GPIOHANDLE_REQUEST_OUTPUT))
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * Do not allow OPEN_SOURCE & OPEN_DRAIN flags in a single request. If
+ 	 * the hardware actually supports enabling both at the same time the
+ 	 * electrical result would be disastrous.
+ 	 */
+ 	if ((flags & GPIOHANDLE_REQUEST_OPEN_DRAIN) &&
+ 	    (flags & GPIOHANDLE_REQUEST_OPEN_SOURCE))
+ 		return -EINVAL;
+ 
+ 	/* OPEN_DRAIN and OPEN_SOURCE flags only make sense for output mode. */
+ 	if (!(flags & GPIOHANDLE_REQUEST_OUTPUT) &&
+ 	    ((flags & GPIOHANDLE_REQUEST_OPEN_DRAIN) ||
+ 	     (flags & GPIOHANDLE_REQUEST_OPEN_SOURCE)))
+ 		return -EINVAL;
+ 
+ 	/* Bias flags only allowed for input or output mode. */
+ 	if (!((flags & GPIOHANDLE_REQUEST_INPUT) ||
+ 	      (flags & GPIOHANDLE_REQUEST_OUTPUT)) &&
+ 	    ((flags & GPIOHANDLE_REQUEST_BIAS_DISABLE) ||
+ 	     (flags & GPIOHANDLE_REQUEST_BIAS_PULL_UP) ||
+ 	     (flags & GPIOHANDLE_REQUEST_BIAS_PULL_DOWN)))
+ 		return -EINVAL;
+ 
+ 	/* Only one bias flag can be set. */
+ 	if (((flags & GPIOHANDLE_REQUEST_BIAS_DISABLE) &&
+ 	     (flags & (GPIOHANDLE_REQUEST_BIAS_PULL_DOWN |
+ 			GPIOHANDLE_REQUEST_BIAS_PULL_UP))) ||
+ 	    ((flags & GPIOHANDLE_REQUEST_BIAS_PULL_DOWN) &&
+ 	     (flags & GPIOHANDLE_REQUEST_BIAS_PULL_UP)))
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
+ 
+ static long linehandle_set_config(struct linehandle_state *lh,
+ 				  void __user *ip)
+ {
+ 	struct gpiohandle_config gcnf;
+ 	struct gpio_desc *desc;
+ 	int i, ret;
+ 	u32 lflags;
+ 	unsigned long *flagsp;
+ 
+ 	if (copy_from_user(&gcnf, ip, sizeof(gcnf)))
+ 		return -EFAULT;
+ 
+ 	lflags = gcnf.flags;
+ 	ret = linehandle_validate_flags(lflags);
+ 	if (ret)
+ 		return ret;
+ 
+ 	for (i = 0; i < lh->numdescs; i++) {
+ 		desc = lh->descs[i];
+ 		flagsp = &desc->flags;
+ 
+ 		assign_bit(FLAG_ACTIVE_LOW, flagsp,
+ 			lflags & GPIOHANDLE_REQUEST_ACTIVE_LOW);
+ 
+ 		assign_bit(FLAG_OPEN_DRAIN, flagsp,
+ 			lflags & GPIOHANDLE_REQUEST_OPEN_DRAIN);
+ 
+ 		assign_bit(FLAG_OPEN_SOURCE, flagsp,
+ 			lflags & GPIOHANDLE_REQUEST_OPEN_SOURCE);
+ 
+ 		assign_bit(FLAG_PULL_UP, flagsp,
+ 			lflags & GPIOHANDLE_REQUEST_BIAS_PULL_UP);
+ 
+ 		assign_bit(FLAG_PULL_DOWN, flagsp,
+ 			lflags & GPIOHANDLE_REQUEST_BIAS_PULL_DOWN);
+ 
+ 		assign_bit(FLAG_BIAS_DISABLE, flagsp,
+ 			lflags & GPIOHANDLE_REQUEST_BIAS_DISABLE);
+ 
+ 		/*
+ 		 * Lines have to be requested explicitly for input
+ 		 * or output, else the line will be treated "as is".
+ 		 */
+ 		if (lflags & GPIOHANDLE_REQUEST_OUTPUT) {
+ 			int val = !!gcnf.default_values[i];
+ 
+ 			ret = gpiod_direction_output(desc, val);
+ 			if (ret)
+ 				return ret;
+ 		} else if (lflags & GPIOHANDLE_REQUEST_INPUT) {
+ 			ret = gpiod_direction_input(desc);
+ 			if (ret)
+ 				return ret;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 4fc5bfeb4b7d (gpiolib: Make use of assign_bit() API)
  static long linehandle_ioctl(struct file *filep, unsigned int cmd,
  			     unsigned long arg)
  {
* Unmerged path drivers/gpio/gpiolib.c
