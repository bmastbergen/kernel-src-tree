PM: Wrap documentation to fit in 80 columns

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Bjorn Helgaas <bhelgaas@google.com>
commit 1992b66d2f55cf36a14072cfd977fdf4f0d2f2c2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/1992b66d.failed

Wrap to 80 columns.  No textual change except to correct some "it's" that
should be "its".

	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 1992b66d2f55cf36a14072cfd977fdf4f0d2f2c2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/power/drivers-testing.txt
#	Documentation/power/opp.txt
#	Documentation/power/pm_qos_interface.txt
#	Documentation/power/runtime_pm.txt
#	Documentation/power/suspend-and-cpuhotplug.txt
#	Documentation/power/swsusp.rst
diff --cc Documentation/power/drivers-testing.txt
index 638afdf4d6b8,d77d2894f9fe..000000000000
--- a/Documentation/power/drivers-testing.txt
+++ b/Documentation/power/drivers-testing.txt
@@@ -34,12 -39,13 +34,19 @@@ c) Compile the driver directly into th
  d) Attempt to hibernate with the driver compiled directly into the kernel
     in the "reboot", "shutdown" and "platform" modes.
  
++<<<<<<< HEAD:Documentation/power/drivers-testing.txt
 +e) Try the test modes of suspend (see: Documentation/power/basic-pm-debugging.txt,
 +   2).  [As far as the STR tests are concerned, it should not matter whether or
 +   not the driver is built as a module.]
++=======
+ e) Try the test modes of suspend (see:
+    Documentation/power/basic-pm-debugging.rst, 2).  [As far as the STR tests are
+    concerned, it should not matter whether or not the driver is built as a
+    module.]
++>>>>>>> 1992b66d2f55 (PM: Wrap documentation to fit in 80 columns):Documentation/power/drivers-testing.rst
  
  f) Attempt to suspend to RAM using the s2ram tool with the driver loaded
 -   (see: Documentation/power/basic-pm-debugging.rst, 2).
 +   (see: Documentation/power/basic-pm-debugging.txt, 2).
  
  Each of the above tests should be repeated several times and the STD tests
  should be mixed with the STR tests.  If any of them fails, the driver cannot be
diff --cc Documentation/power/opp.txt
index 0c007e250cd1,e3cc4f349ea8..000000000000
--- a/Documentation/power/opp.txt
+++ b/Documentation/power/opp.txt
@@@ -88,17 -98,20 +90,17 @@@ registering the OPPs is maintained by O
  operation. The SoC framework can subsequently control the availability of the
  OPPs dynamically using the dev_pm_opp_enable / disable functions.
  
 -dev_pm_opp_add
 -	Add a new OPP for a specific domain represented by the device pointer.
 +dev_pm_opp_add - Add a new OPP for a specific domain represented by the device pointer.
  	The OPP is defined using the frequency and voltage. Once added, the OPP
- 	is assumed to be available and control of it's availability can be done
- 	with the dev_pm_opp_enable/disable functions. OPP library internally stores
- 	and manages this information in the opp struct. This function may be
- 	used by SoC framework to define a optimal list as per the demands of
- 	SoC usage environment.
+ 	is assumed to be available and control of its availability can be done
+ 	with the dev_pm_opp_enable/disable functions. OPP library
+ 	internally stores and manages this information in the opp struct.
+ 	This function may be used by SoC framework to define a optimal list
+ 	as per the demands of SoC usage environment.
  
 -	WARNING:
 -		Do not use this function in interrupt context.
 -
 -	Example::
 +	WARNING: Do not use this function in interrupt context.
  
 +	Example:
  	 soc_pm_init()
  	 {
  		/* Do things */
@@@ -312,12 -348,15 +314,18 @@@ struct dev_pm_opp - The internal data s
  	provided back to the users such as SoC framework to be used as a
  	identifier for OPP in the interactions with OPP layer.
  
 -	WARNING:
 -	  The struct dev_pm_opp pointer should not be parsed or modified by the
 -	  users. The defaults of for an instance is populated by
 -	  dev_pm_opp_add, but the availability of the OPP can be modified
 -	  by dev_pm_opp_enable/disable functions.
 +	WARNING: The struct dev_pm_opp pointer should not be parsed or modified by the
 +	users. The defaults of for an instance is populated by dev_pm_opp_add, but the
 +	availability of the OPP can be modified by dev_pm_opp_enable/disable functions.
  
++<<<<<<< HEAD:Documentation/power/opp.txt
 +struct device - This is used to identify a domain to the OPP layer. The
 +	nature of the device and it's implementation is left to the user of
++=======
+ struct device
+ 	This is used to identify a domain to the OPP layer. The
+ 	nature of the device and its implementation is left to the user of
++>>>>>>> 1992b66d2f55 (PM: Wrap documentation to fit in 80 columns):Documentation/power/opp.rst
  	OPP library such as the SoC framework.
  
  Overall, in a simplistic view, the data structure operations is represented as
diff --cc Documentation/power/pm_qos_interface.txt
index 37fa67804c07,0d62d506caf0..000000000000
--- a/Documentation/power/pm_qos_interface.txt
+++ b/Documentation/power/pm_qos_interface.txt
@@@ -6,10 -8,11 +6,10 @@@ one of the parameters
  
  Two different PM QoS frameworks are available:
  1. PM QoS classes for cpu_dma_latency
- 2. the per-device PM QoS framework provides the API to manage the per-device latency
- constraints and PM QoS flags.
+ 2. The per-device PM QoS framework provides the API to manage the
+    per-device latency constraints and PM QoS flags.
  
  Each parameters have defined units:
 -
   * latency: usec
   * timeout: usec
   * throughput: kbs (kilo bit / sec)
@@@ -36,35 -40,35 +36,46 @@@ reading the aggregated value does not r
  From kernel mode the use of this interface is simple:
  
  void pm_qos_add_request(handle, param_class, target_value):
 -  Will insert an element into the list for that identified PM QoS class with the
 -  target value.  Upon change to this list the new target is recomputed and any
 -  registered notifiers are called only if the target value is now different.
 -  Clients of pm_qos need to save the returned handle for future use in other
 -  pm_qos API functions.
 +Will insert an element into the list for that identified PM QoS class with the
 +target value.  Upon change to this list the new target is recomputed and any
 +registered notifiers are called only if the target value is now different.
 +Clients of pm_qos need to save the returned handle for future use in other
 +pm_qos API functions.
  
  void pm_qos_update_request(handle, new_target_value):
++<<<<<<< HEAD:Documentation/power/pm_qos_interface.txt
 +Will update the list element pointed to by the handle with the new target value
 +and recompute the new aggregated target, calling the notification tree if the
 +target is changed.
 +
 +void pm_qos_remove_request(handle):
 +Will remove the element.  After removal it will update the aggregate target and
 +call the notification tree if the target was changed as a result of removing
 +the request.
++=======
+   Will update the list element pointed to by the handle with the new target
+   value and recompute the new aggregated target, calling the notification tree
+   if the target is changed.
+ 
+ void pm_qos_remove_request(handle):
+   Will remove the element.  After removal it will update the aggregate target
+   and call the notification tree if the target was changed as a result of
+   removing the request.
++>>>>>>> 1992b66d2f55 (PM: Wrap documentation to fit in 80 columns):Documentation/power/pm_qos_interface.rst
  
  int pm_qos_request(param_class):
 -  Returns the aggregated value for a given PM QoS class.
 +Returns the aggregated value for a given PM QoS class.
  
  int pm_qos_request_active(handle):
 -  Returns if the request is still active, i.e. it has not been removed from a
 -  PM QoS class constraints list.
 +Returns if the request is still active, i.e. it has not been removed from a
 +PM QoS class constraints list.
  
  int pm_qos_add_notifier(param_class, notifier):
 -  Adds a notification callback function to the PM QoS class. The callback is
 -  called when the aggregated value for the PM QoS class is changed.
 +Adds a notification callback function to the PM QoS class. The callback is
 +called when the aggregated value for the PM QoS class is changed.
  
  int pm_qos_remove_notifier(int param_class, notifier):
 -  Removes the notification callback function for the PM QoS class.
 +Removes the notification callback function for the PM QoS class.
  
  
  From user mode:
@@@ -106,72 -112,78 +117,83 @@@ the aggregated value does not require a
  From kernel mode the use of this interface is the following:
  
  int dev_pm_qos_add_request(device, handle, type, value):
 -  Will insert an element into the list for that identified device with the
 -  target value.  Upon change to this list the new target is recomputed and any
 -  registered notifiers are called only if the target value is now different.
 -  Clients of dev_pm_qos need to save the handle for future use in other
 -  dev_pm_qos API functions.
 +Will insert an element into the list for that identified device with the
 +target value.  Upon change to this list the new target is recomputed and any
 +registered notifiers are called only if the target value is now different.
 +Clients of dev_pm_qos need to save the handle for future use in other
 +dev_pm_qos API functions.
  
  int dev_pm_qos_update_request(handle, new_value):
 -  Will update the list element pointed to by the handle with the new target
 -  value and recompute the new aggregated target, calling the notification
 -  trees if the target is changed.
 +Will update the list element pointed to by the handle with the new target value
 +and recompute the new aggregated target, calling the notification trees if the
 +target is changed.
  
  int dev_pm_qos_remove_request(handle):
 -  Will remove the element.  After removal it will update the aggregate target
 -  and call the notification trees if the target was changed as a result of
 -  removing the request.
 +Will remove the element.  After removal it will update the aggregate target and
 +call the notification trees if the target was changed as a result of removing
 +the request.
  
  s32 dev_pm_qos_read_value(device, type):
 -  Returns the aggregated value for a given device's constraints list.
 +Returns the aggregated value for a given device's constraints list.
  
  enum pm_qos_flags_status dev_pm_qos_flags(device, mask)
 -  Check PM QoS flags of the given device against the given mask of flags.
 -  The meaning of the return values is as follows:
 -
 -	PM_QOS_FLAGS_ALL:
 -		All flags from the mask are set
 -	PM_QOS_FLAGS_SOME:
 -		Some flags from the mask are set
 -	PM_QOS_FLAGS_NONE:
 -		No flags from the mask are set
 -	PM_QOS_FLAGS_UNDEFINED:
 -		The device's PM QoS structure has not been initialized
 -		or the list of requests is empty.
 +Check PM QoS flags of the given device against the given mask of flags.
 +The meaning of the return values is as follows:
 +	PM_QOS_FLAGS_ALL: All flags from the mask are set
 +	PM_QOS_FLAGS_SOME: Some flags from the mask are set
 +	PM_QOS_FLAGS_NONE: No flags from the mask are set
 +	PM_QOS_FLAGS_UNDEFINED: The device's PM QoS structure has not been
 +			initialized or the list of requests is empty.
  
  int dev_pm_qos_add_ancestor_request(dev, handle, type, value)
 -  Add a PM QoS request for the first direct ancestor of the given device whose
 -  power.ignore_children flag is unset (for DEV_PM_QOS_RESUME_LATENCY requests)
 -  or whose power.set_latency_tolerance callback pointer is not NULL (for
 -  DEV_PM_QOS_LATENCY_TOLERANCE requests).
 +Add a PM QoS request for the first direct ancestor of the given device whose
 +power.ignore_children flag is unset (for DEV_PM_QOS_RESUME_LATENCY requests)
 +or whose power.set_latency_tolerance callback pointer is not NULL (for
 +DEV_PM_QOS_LATENCY_TOLERANCE requests).
  
  int dev_pm_qos_expose_latency_limit(device, value)
 -  Add a request to the device's PM QoS list of resume latency constraints and
 -  create a sysfs attribute pm_qos_resume_latency_us under the device's power
 -  directory allowing user space to manipulate that request.
 +Add a request to the device's PM QoS list of resume latency constraints and
 +create a sysfs attribute pm_qos_resume_latency_us under the device's power
 +directory allowing user space to manipulate that request.
  
  void dev_pm_qos_hide_latency_limit(device)
 -  Drop the request added by dev_pm_qos_expose_latency_limit() from the device's
 -  PM QoS list of resume latency constraints and remove sysfs attribute
 -  pm_qos_resume_latency_us from the device's power directory.
 +Drop the request added by dev_pm_qos_expose_latency_limit() from the device's
 +PM QoS list of resume latency constraints and remove sysfs attribute
 +pm_qos_resume_latency_us from the device's power directory.
  
  int dev_pm_qos_expose_flags(device, value)
 -  Add a request to the device's PM QoS list of flags and create sysfs attribute
 -  pm_qos_no_power_off under the device's power directory allowing user space to
 -  change the value of the PM_QOS_FLAG_NO_POWER_OFF flag.
 +Add a request to the device's PM QoS list of flags and create sysfs attribute
 +pm_qos_no_power_off under the device's power directory allowing user space to
 +change the value of the PM_QOS_FLAG_NO_POWER_OFF flag.
  
  void dev_pm_qos_hide_flags(device)
++<<<<<<< HEAD:Documentation/power/pm_qos_interface.txt
 +Drop the request added by dev_pm_qos_expose_flags() from the device's PM QoS list
 +of flags and remove sysfs attribute pm_qos_no_power_off from the device's power
 +directory.
++=======
+   Drop the request added by dev_pm_qos_expose_flags() from the device's PM QoS
+   list of flags and remove sysfs attribute pm_qos_no_power_off from the device's
+   power directory.
++>>>>>>> 1992b66d2f55 (PM: Wrap documentation to fit in 80 columns):Documentation/power/pm_qos_interface.rst
  
  Notification mechanisms:
 -
  The per-device PM QoS framework has a per-device notification tree.
  
  int dev_pm_qos_add_notifier(device, notifier, type):
 -  Adds a notification callback function for the device for a particular request
 -  type.
 +Adds a notification callback function for the device for a particular request
 +type.
  
++<<<<<<< HEAD:Documentation/power/pm_qos_interface.txt
 +The callback is called when the aggregated value of the device constraints list
 +is changed.
++=======
+   The callback is called when the aggregated value of the device constraints
+   list is changed.
++>>>>>>> 1992b66d2f55 (PM: Wrap documentation to fit in 80 columns):Documentation/power/pm_qos_interface.rst
  
  int dev_pm_qos_remove_notifier(device, notifier, type):
 -  Removes the notification callback function for the device.
 +Removes the notification callback function for the device.
  
  
  Active state latency tolerance
diff --cc Documentation/power/runtime_pm.txt
index 937e33c46211,ab8406c84254..000000000000
--- a/Documentation/power/runtime_pm.txt
+++ b/Documentation/power/runtime_pm.txt
@@@ -258,13 -265,13 +258,18 @@@ defined in include/linux/pm.h
        RPM_SUSPENDED, which means that each device is initially regarded by the
        PM core as 'suspended', regardless of its real hardware status
  
 -  `unsigned int runtime_auto;`
 +  unsigned int runtime_auto;
      - if set, indicates that the user space has allowed the device driver to
        power manage the device at run time via the /sys/devices/.../power/control
++<<<<<<< HEAD:Documentation/power/runtime_pm.txt
 +      interface; it may only be modified with the help of the pm_runtime_allow()
 +      and pm_runtime_forbid() helper functions
++=======
+       `interface;` it may only be modified with the help of the
+       pm_runtime_allow() and pm_runtime_forbid() helper functions
++>>>>>>> 1992b66d2f55 (PM: Wrap documentation to fit in 80 columns):Documentation/power/runtime_pm.rst
  
 -  `unsigned int no_callbacks;`
 +  unsigned int no_callbacks;
      - indicates that the device does not use the runtime PM callbacks (see
        Section 8); it may be modified only by the pm_runtime_no_callbacks()
        helper function
diff --cc Documentation/power/suspend-and-cpuhotplug.txt
index a8751b8df10e,572d968c5375..000000000000
--- a/Documentation/power/suspend-and-cpuhotplug.txt
+++ b/Documentation/power/suspend-and-cpuhotplug.txt
@@@ -99,10 -106,12 +99,10 @@@ execution during resume)
  * Release system_transition_mutex lock.
  
  
- It is to be noted here that the system_transition_mutex lock is acquired at the very
- beginning, when we are just starting out to suspend, and then released only
+ It is to be noted here that the system_transition_mutex lock is acquired at the
+ very beginning, when we are just starting out to suspend, and then released only
  after the entire cycle is complete (i.e., suspend + resume).
  
 -::
 -
  
  
                            Regular CPU hotplug call path
@@@ -152,11 -161,12 +152,18 @@@ with the 'tasks_frozen' argument set t
  
  
  Important files and functions/entry points:
 --------------------------------------------
 +------------------------------------------
  
++<<<<<<< HEAD:Documentation/power/suspend-and-cpuhotplug.txt
 +kernel/power/process.c : freeze_processes(), thaw_processes()
 +kernel/power/suspend.c : suspend_prepare(), suspend_enter(), suspend_finish()
 +kernel/cpu.c: cpu_[up|down](), _cpu_[up|down](), [disable|enable]_nonboot_cpus()
++=======
+ - kernel/power/process.c : freeze_processes(), thaw_processes()
+ - kernel/power/suspend.c : suspend_prepare(), suspend_enter(), suspend_finish()
+ - kernel/cpu.c: cpu_[up|down](), _cpu_[up|down](),
+   [disable|enable]_nonboot_cpus()
++>>>>>>> 1992b66d2f55 (PM: Wrap documentation to fit in 80 columns):Documentation/power/suspend-and-cpuhotplug.rst
  
  
  
* Unmerged path Documentation/power/swsusp.rst
* Unmerged path Documentation/power/drivers-testing.txt
diff --git a/Documentation/power/freezing-of-tasks.txt b/Documentation/power/freezing-of-tasks.txt
index cd283190855a..3828b22d16a3 100644
--- a/Documentation/power/freezing-of-tasks.txt
+++ b/Documentation/power/freezing-of-tasks.txt
@@ -204,28 +204,29 @@ VI. Are there any precautions to be taken to prevent freezing failures?
 
 Yes, there are.
 
-First of all, grabbing the 'system_transition_mutex' lock to mutually exclude a piece of code
-from system-wide sleep such as suspend/hibernation is not encouraged.
-If possible, that piece of code must instead hook onto the suspend/hibernation
-notifiers to achieve mutual exclusion. Look at the CPU-Hotplug code
-(kernel/cpu.c) for an example.
-
-However, if that is not feasible, and grabbing 'system_transition_mutex' is deemed necessary,
-it is strongly discouraged to directly call mutex_[un]lock(&system_transition_mutex) since
-that could lead to freezing failures, because if the suspend/hibernate code
-successfully acquired the 'system_transition_mutex' lock, and hence that other entity failed
-to acquire the lock, then that task would get blocked in TASK_UNINTERRUPTIBLE
-state. As a consequence, the freezer would not be able to freeze that task,
-leading to freezing failure.
+First of all, grabbing the 'system_transition_mutex' lock to mutually exclude a
+piece of code from system-wide sleep such as suspend/hibernation is not
+encouraged.  If possible, that piece of code must instead hook onto the
+suspend/hibernation notifiers to achieve mutual exclusion. Look at the
+CPU-Hotplug code (kernel/cpu.c) for an example.
+
+However, if that is not feasible, and grabbing 'system_transition_mutex' is
+deemed necessary, it is strongly discouraged to directly call
+mutex_[un]lock(&system_transition_mutex) since that could lead to freezing
+failures, because if the suspend/hibernate code successfully acquired the
+'system_transition_mutex' lock, and hence that other entity failed to acquire
+the lock, then that task would get blocked in TASK_UNINTERRUPTIBLE state. As a
+consequence, the freezer would not be able to freeze that task, leading to
+freezing failure.
 
 However, the [un]lock_system_sleep() APIs are safe to use in this scenario,
 since they ask the freezer to skip freezing this task, since it is anyway
-"frozen enough" as it is blocked on 'system_transition_mutex', which will be released
-only after the entire suspend/hibernation sequence is complete.
-So, to summarize, use [un]lock_system_sleep() instead of directly using
+"frozen enough" as it is blocked on 'system_transition_mutex', which will be
+released only after the entire suspend/hibernation sequence is complete.  So, to
+summarize, use [un]lock_system_sleep() instead of directly using
 mutex_[un]lock(&system_transition_mutex). That would prevent freezing failures.
 
 V. Miscellaneous
 /sys/power/pm_freeze_timeout controls how long it will cost at most to freeze
-all user space processes or all freezable kernel threads, in unit of millisecond.
-The default value is 20000, with range of unsigned integer.
+all user space processes or all freezable kernel threads, in unit of
+millisecond.  The default value is 20000, with range of unsigned integer.
* Unmerged path Documentation/power/opp.txt
diff --git a/Documentation/power/pci.txt b/Documentation/power/pci.txt
index 8eaf9ee24d43..153b5b0b0ad3 100644
--- a/Documentation/power/pci.txt
+++ b/Documentation/power/pci.txt
@@ -417,12 +417,12 @@ pm->runtime_idle() callback.
 2.4. System-Wide Power Transitions
 ----------------------------------
 There are a few different types of system-wide power transitions, described in
-Documentation/driver-api/pm/devices.rst.  Each of them requires devices to be handled
-in a specific way and the PM core executes subsystem-level power management
-callbacks for this purpose.  They are executed in phases such that each phase
-involves executing the same subsystem-level callback for every device belonging
-to the given subsystem before the next phase begins.  These phases always run
-after tasks have been frozen.
+Documentation/driver-api/pm/devices.rst.  Each of them requires devices to be
+handled in a specific way and the PM core executes subsystem-level power
+management callbacks for this purpose.  They are executed in phases such that
+each phase involves executing the same subsystem-level callback for every device
+belonging to the given subsystem before the next phase begins.  These phases
+always run after tasks have been frozen.
 
 2.4.1. System Suspend
 
@@ -623,12 +623,12 @@ System restore requires a hibernation image to be loaded into memory and the
 pre-hibernation memory contents to be restored before the pre-hibernation system
 activity can be resumed.
 
-As described in Documentation/driver-api/pm/devices.rst, the hibernation image is loaded
-into memory by a fresh instance of the kernel, called the boot kernel, which in
-turn is loaded and run by a boot loader in the usual way.  After the boot kernel
-has loaded the image, it needs to replace its own code and data with the code
-and data of the "hibernated" kernel stored within the image, called the image
-kernel.  For this purpose all devices are frozen just like before creating
+As described in Documentation/driver-api/pm/devices.rst, the hibernation image
+is loaded into memory by a fresh instance of the kernel, called the boot kernel,
+which in turn is loaded and run by a boot loader in the usual way.  After the
+boot kernel has loaded the image, it needs to replace its own code and data with
+the code and data of the "hibernated" kernel stored within the image, called the
+image kernel.  For this purpose all devices are frozen just like before creating
 the image during hibernation, in the
 
 	prepare, freeze, freeze_noirq
@@ -677,8 +677,8 @@ controlling the runtime power management of their devices.
 
 At the time of this writing there are two ways to define power management
 callbacks for a PCI device driver, the recommended one, based on using a
-dev_pm_ops structure described in Documentation/driver-api/pm/devices.rst, and the
-"legacy" one, in which the .suspend(), .suspend_late(), .resume_early(), and
+dev_pm_ops structure described in Documentation/driver-api/pm/devices.rst, and
+the "legacy" one, in which the .suspend(), .suspend_late(), .resume_early(), and
 .resume() callbacks from struct pci_driver are used.  The legacy approach,
 however, doesn't allow one to define runtime power management callbacks and is
 not really suitable for any new drivers.  Therefore it is not covered by this
* Unmerged path Documentation/power/pm_qos_interface.txt
* Unmerged path Documentation/power/runtime_pm.txt
* Unmerged path Documentation/power/suspend-and-cpuhotplug.txt
* Unmerged path Documentation/power/swsusp.rst
