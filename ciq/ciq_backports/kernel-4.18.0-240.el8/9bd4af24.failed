KVM: nVMX: Drop a redundant call to vmx_get_intr_info()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 9bd4af240f4db39e754081d135e6ef7a54bb6828
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9bd4af24.failed

Drop nested_vmx_l1_wants_exit()'s initialization of intr_info from
vmx_get_intr_info() that was inadvertantly introduced along with the
caching mechanism.  EXIT_REASON_EXCEPTION_NMI, the only consumer of
intr_info, populates the variable before using it.

Fixes: bb53120d67cd ("KVM: VMX: Cache vmcs.EXIT_INTR_INFO using arch avail_reg flags")
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200421075328.14458-2-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9bd4af240f4db39e754081d135e6ef7a54bb6828)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/nested.c
diff --cc arch/x86/kvm/vmx/nested.c
index 65d39111747b,12b78468317c..000000000000
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@@ -5609,10 -5643,64 +5609,68 @@@ bool nested_vmx_exit_reflected(struct k
  		else if (is_debug(intr_info) &&
  			 vcpu->guest_debug &
  			 (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))
 -			return true;
 +			return false;
  		else if (is_breakpoint(intr_info) &&
  			 vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)
++<<<<<<< HEAD
 +			return false;
++=======
+ 			return true;
+ 		return false;
+ 	case EXIT_REASON_EXTERNAL_INTERRUPT:
+ 		return true;
+ 	case EXIT_REASON_MCE_DURING_VMENTRY:
+ 		return true;
+ 	case EXIT_REASON_EPT_VIOLATION:
+ 		/*
+ 		 * L0 always deals with the EPT violation. If nested EPT is
+ 		 * used, and the nested mmu code discovers that the address is
+ 		 * missing in the guest EPT table (EPT12), the EPT violation
+ 		 * will be injected with nested_ept_inject_page_fault()
+ 		 */
+ 		return true;
+ 	case EXIT_REASON_EPT_MISCONFIG:
+ 		/*
+ 		 * L2 never uses directly L1's EPT, but rather L0's own EPT
+ 		 * table (shadow on EPT) or a merged EPT table that L0 built
+ 		 * (EPT on EPT). So any problems with the structure of the
+ 		 * table is L0's fault.
+ 		 */
+ 		return true;
+ 	case EXIT_REASON_PREEMPTION_TIMER:
+ 		return true;
+ 	case EXIT_REASON_PML_FULL:
+ 		/* We emulate PML support to L1. */
+ 		return true;
+ 	case EXIT_REASON_VMFUNC:
+ 		/* VM functions are emulated through L2->L0 vmexits. */
+ 		return true;
+ 	case EXIT_REASON_ENCLS:
+ 		/* SGX is never exposed to L1 */
+ 		return true;
+ 	default:
+ 		break;
+ 	}
+ 	return false;
+ }
+ 
+ /*
+  * Return 1 if L1 wants to intercept an exit from L2.  Only call this when in
+  * is_guest_mode (L2).
+  */
+ static bool nested_vmx_l1_wants_exit(struct kvm_vcpu *vcpu, u32 exit_reason)
+ {
+ 	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
+ 	u32 intr_info;
+ 
+ 	switch (exit_reason) {
+ 	case EXIT_REASON_EXCEPTION_NMI:
+ 		intr_info = vmx_get_intr_info(vcpu);
+ 		if (is_nmi(intr_info))
+ 			return true;
+ 		else if (is_page_fault(intr_info))
+ 			return true;
++>>>>>>> 9bd4af240f4d (KVM: nVMX: Drop a redundant call to vmx_get_intr_info())
  		return vmcs12->exception_bitmap &
  				(1u << (intr_info & INTR_INFO_VECTOR_MASK));
  	case EXIT_REASON_EXTERNAL_INTERRUPT:
* Unmerged path arch/x86/kvm/vmx/nested.c
