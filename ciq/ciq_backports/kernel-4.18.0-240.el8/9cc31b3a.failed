bpf: Fix race in btf_resolve_helper_id()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Alexei Starovoitov <ast@kernel.org>
commit 9cc31b3a092d9bf2a18f09ad77e727ddb42a5b1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9cc31b3a.failed

btf_resolve_helper_id() caching logic is a bit racy, since under root the
verifier can verify several programs in parallel. Fix it with READ/WRITE_ONCE.
Fix the type as well, since error is also recorded.

Fixes: a7658e1a4164 ("bpf: Check types of arguments passed into helpers")
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Song Liu <songliubraving@fb.com>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
Link: https://lore.kernel.org/bpf/20191114185720.1641606-15-ast@kernel.org
(cherry picked from commit 9cc31b3a092d9bf2a18f09ad77e727ddb42a5b1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/btf.c
#	kernel/bpf/verifier.c
#	net/core/filter.c
diff --cc include/linux/bpf.h
index a5585413dfbe,cb5a356381f5..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -249,11 -238,17 +249,25 @@@ struct bpf_func_proto 
  	bool gpl_only;
  	bool pkt_access;
  	enum bpf_return_type ret_type;
++<<<<<<< HEAD
 +	enum bpf_arg_type arg1_type;
 +	enum bpf_arg_type arg2_type;
 +	enum bpf_arg_type arg3_type;
 +	enum bpf_arg_type arg4_type;
 +	enum bpf_arg_type arg5_type;
++=======
+ 	union {
+ 		struct {
+ 			enum bpf_arg_type arg1_type;
+ 			enum bpf_arg_type arg2_type;
+ 			enum bpf_arg_type arg3_type;
+ 			enum bpf_arg_type arg4_type;
+ 			enum bpf_arg_type arg5_type;
+ 		};
+ 		enum bpf_arg_type arg_type[5];
+ 	};
+ 	int *btf_id; /* BTF ids of arguments */
++>>>>>>> 9cc31b3a092d (bpf: Fix race in btf_resolve_helper_id())
  };
  
  /* bpf_context is intentionally undefined structure. Pointer to bpf_context is
@@@ -784,6 -881,14 +798,17 @@@ int btf_struct_access(struct bpf_verifi
  		      const struct btf_type *t, int off, int size,
  		      enum bpf_access_type atype,
  		      u32 *next_btf_id);
++<<<<<<< HEAD
++=======
+ int btf_resolve_helper_id(struct bpf_verifier_log *log,
+ 			  const struct bpf_func_proto *fn, int);
+ 
+ int btf_distill_func_proto(struct bpf_verifier_log *log,
+ 			   struct btf *btf,
+ 			   const struct btf_type *func_proto,
+ 			   const char *func_name,
+ 			   struct btf_func_model *m);
++>>>>>>> 9cc31b3a092d (bpf: Fix race in btf_resolve_helper_id())
  
  #else /* !CONFIG_BPF_SYSCALL */
  static inline struct bpf_prog *bpf_prog_get(u32 ufd)
diff --cc kernel/bpf/btf.c
index dc1f2324f36a,033d071eb59c..000000000000
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@@ -3763,6 -3721,162 +3763,165 @@@ again
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ static int __btf_resolve_helper_id(struct bpf_verifier_log *log, void *fn,
+ 				   int arg)
+ {
+ 	char fnname[KSYM_SYMBOL_LEN + 4] = "btf_";
+ 	const struct btf_param *args;
+ 	const struct btf_type *t;
+ 	const char *tname, *sym;
+ 	u32 btf_id, i;
+ 
+ 	if (IS_ERR(btf_vmlinux)) {
+ 		bpf_log(log, "btf_vmlinux is malformed\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	sym = kallsyms_lookup((long)fn, NULL, NULL, NULL, fnname + 4);
+ 	if (!sym) {
+ 		bpf_log(log, "kernel doesn't have kallsyms\n");
+ 		return -EFAULT;
+ 	}
+ 
+ 	for (i = 1; i <= btf_vmlinux->nr_types; i++) {
+ 		t = btf_type_by_id(btf_vmlinux, i);
+ 		if (BTF_INFO_KIND(t->info) != BTF_KIND_TYPEDEF)
+ 			continue;
+ 		tname = __btf_name_by_offset(btf_vmlinux, t->name_off);
+ 		if (!strcmp(tname, fnname))
+ 			break;
+ 	}
+ 	if (i > btf_vmlinux->nr_types) {
+ 		bpf_log(log, "helper %s type is not found\n", fnname);
+ 		return -ENOENT;
+ 	}
+ 
+ 	t = btf_type_by_id(btf_vmlinux, t->type);
+ 	if (!btf_type_is_ptr(t))
+ 		return -EFAULT;
+ 	t = btf_type_by_id(btf_vmlinux, t->type);
+ 	if (!btf_type_is_func_proto(t))
+ 		return -EFAULT;
+ 
+ 	args = (const struct btf_param *)(t + 1);
+ 	if (arg >= btf_type_vlen(t)) {
+ 		bpf_log(log, "bpf helper %s doesn't have %d-th argument\n",
+ 			fnname, arg);
+ 		return -EINVAL;
+ 	}
+ 
+ 	t = btf_type_by_id(btf_vmlinux, args[arg].type);
+ 	if (!btf_type_is_ptr(t) || !t->type) {
+ 		/* anything but the pointer to struct is a helper config bug */
+ 		bpf_log(log, "ARG_PTR_TO_BTF is misconfigured\n");
+ 		return -EFAULT;
+ 	}
+ 	btf_id = t->type;
+ 	t = btf_type_by_id(btf_vmlinux, t->type);
+ 	/* skip modifiers */
+ 	while (btf_type_is_modifier(t)) {
+ 		btf_id = t->type;
+ 		t = btf_type_by_id(btf_vmlinux, t->type);
+ 	}
+ 	if (!btf_type_is_struct(t)) {
+ 		bpf_log(log, "ARG_PTR_TO_BTF is not a struct\n");
+ 		return -EFAULT;
+ 	}
+ 	bpf_log(log, "helper %s arg%d has btf_id %d struct %s\n", fnname + 4,
+ 		arg, btf_id, __btf_name_by_offset(btf_vmlinux, t->name_off));
+ 	return btf_id;
+ }
+ 
+ int btf_resolve_helper_id(struct bpf_verifier_log *log,
+ 			  const struct bpf_func_proto *fn, int arg)
+ {
+ 	int *btf_id = &fn->btf_id[arg];
+ 	int ret;
+ 
+ 	if (fn->arg_type[arg] != ARG_PTR_TO_BTF_ID)
+ 		return -EINVAL;
+ 
+ 	ret = READ_ONCE(*btf_id);
+ 	if (ret)
+ 		return ret;
+ 	/* ok to race the search. The result is the same */
+ 	ret = __btf_resolve_helper_id(log, fn->func, arg);
+ 	if (!ret) {
+ 		/* Function argument cannot be type 'void' */
+ 		bpf_log(log, "BTF resolution bug\n");
+ 		return -EFAULT;
+ 	}
+ 	WRITE_ONCE(*btf_id, ret);
+ 	return ret;
+ }
+ 
+ static int __get_type_size(struct btf *btf, u32 btf_id,
+ 			   const struct btf_type **bad_type)
+ {
+ 	const struct btf_type *t;
+ 
+ 	if (!btf_id)
+ 		/* void */
+ 		return 0;
+ 	t = btf_type_by_id(btf, btf_id);
+ 	while (t && btf_type_is_modifier(t))
+ 		t = btf_type_by_id(btf, t->type);
+ 	if (!t)
+ 		return -EINVAL;
+ 	if (btf_type_is_ptr(t))
+ 		/* kernel size of pointer. Not BPF's size of pointer*/
+ 		return sizeof(void *);
+ 	if (btf_type_is_int(t) || btf_type_is_enum(t))
+ 		return t->size;
+ 	*bad_type = t;
+ 	return -EINVAL;
+ }
+ 
+ int btf_distill_func_proto(struct bpf_verifier_log *log,
+ 			   struct btf *btf,
+ 			   const struct btf_type *func,
+ 			   const char *tname,
+ 			   struct btf_func_model *m)
+ {
+ 	const struct btf_param *args;
+ 	const struct btf_type *t;
+ 	u32 i, nargs;
+ 	int ret;
+ 
+ 	args = (const struct btf_param *)(func + 1);
+ 	nargs = btf_type_vlen(func);
+ 	if (nargs >= MAX_BPF_FUNC_ARGS) {
+ 		bpf_log(log,
+ 			"The function %s has %d arguments. Too many.\n",
+ 			tname, nargs);
+ 		return -EINVAL;
+ 	}
+ 	ret = __get_type_size(btf, func->type, &t);
+ 	if (ret < 0) {
+ 		bpf_log(log,
+ 			"The function %s return type %s is unsupported.\n",
+ 			tname, btf_kind_str[BTF_INFO_KIND(t->info)]);
+ 		return -EINVAL;
+ 	}
+ 	m->ret_size = ret;
+ 
+ 	for (i = 0; i < nargs; i++) {
+ 		ret = __get_type_size(btf, args[i].type, &t);
+ 		if (ret < 0) {
+ 			bpf_log(log,
+ 				"The function %s arg%d type %s is unsupported.\n",
+ 				tname, i, btf_kind_str[BTF_INFO_KIND(t->info)]);
+ 			return -EINVAL;
+ 		}
+ 		m->arg_size[i] = ret;
+ 	}
+ 	m->nr_args = nargs;
+ 	return 0;
+ }
+ 
++>>>>>>> 9cc31b3a092d (bpf: Fix race in btf_resolve_helper_id())
  void btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,
  		       struct seq_file *m)
  {
diff --cc kernel/bpf/verifier.c
index ba15160eab20,e78ec7990767..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -4134,21 -4146,14 +4134,32 @@@ static int check_helper_call(struct bpf
  
  	meta.func_id = func_id;
  	/* check args */
++<<<<<<< HEAD
 +	err = check_func_arg(env, BPF_REG_1, fn->arg1_type, &meta);
 +	if (err)
 +		return err;
 +	err = check_func_arg(env, BPF_REG_2, fn->arg2_type, &meta);
 +	if (err)
 +		return err;
 +	err = check_func_arg(env, BPF_REG_3, fn->arg3_type, &meta);
 +	if (err)
 +		return err;
 +	err = check_func_arg(env, BPF_REG_4, fn->arg4_type, &meta);
 +	if (err)
 +		return err;
 +	err = check_func_arg(env, BPF_REG_5, fn->arg5_type, &meta);
 +	if (err)
 +		return err;
++=======
+ 	for (i = 0; i < 5; i++) {
+ 		err = btf_resolve_helper_id(&env->log, fn, i);
+ 		if (err > 0)
+ 			meta.btf_id = err;
+ 		err = check_func_arg(env, BPF_REG_1 + i, fn->arg_type[i], &meta);
+ 		if (err)
+ 			return err;
+ 	}
++>>>>>>> 9cc31b3a092d (bpf: Fix race in btf_resolve_helper_id())
  
  	err = record_func_map(env, &meta, func_id, insn_idx);
  	if (err)
diff --cc net/core/filter.c
index fe1308a67154,f72face90659..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -3825,6 -3816,19 +3825,22 @@@ static const struct bpf_func_proto bpf_
  	.arg5_type	= ARG_CONST_SIZE_OR_ZERO,
  };
  
++<<<<<<< HEAD
++=======
+ static int bpf_skb_output_btf_ids[5];
+ const struct bpf_func_proto bpf_skb_output_proto = {
+ 	.func		= bpf_skb_event_output,
+ 	.gpl_only	= true,
+ 	.ret_type	= RET_INTEGER,
+ 	.arg1_type	= ARG_PTR_TO_BTF_ID,
+ 	.arg2_type	= ARG_CONST_MAP_PTR,
+ 	.arg3_type	= ARG_ANYTHING,
+ 	.arg4_type	= ARG_PTR_TO_MEM,
+ 	.arg5_type	= ARG_CONST_SIZE_OR_ZERO,
+ 	.btf_id		= bpf_skb_output_btf_ids,
+ };
+ 
++>>>>>>> 9cc31b3a092d (bpf: Fix race in btf_resolve_helper_id())
  static unsigned short bpf_tunnel_key_af(u64 flags)
  {
  	return flags & BPF_F_TUNINFO_IPV6 ? AF_INET6 : AF_INET;
* Unmerged path include/linux/bpf.h
* Unmerged path kernel/bpf/btf.c
* Unmerged path kernel/bpf/verifier.c
* Unmerged path net/core/filter.c
