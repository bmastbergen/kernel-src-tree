gpiolib: Add support for the irqdomain which doesn't use irq_fwspec as arg

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Kevin Hao <haokexin@gmail.com>
commit 242587616710576808dc8d7cdf18cfe0d7bf9831
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/24258761.failed

Some gpio's parent irqdomain may not use the struct irq_fwspec as
argument, such as msi irqdomain. So rename the callback
populate_parent_fwspec() to populate_parent_alloc_arg() and make it
allocate and populate the specific struct which is needed by the
parent irqdomain.

	Signed-off-by: Kevin Hao <haokexin@gmail.com>
Link: https://lore.kernel.org/r/20200114082821.14015-3-haokexin@gmail.com
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 242587616710576808dc8d7cdf18cfe0d7bf9831)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpio-tegra186.c
#	drivers/gpio/gpiolib.c
#	drivers/pinctrl/qcom/pinctrl-spmi-gpio.c
#	drivers/pinctrl/qcom/pinctrl-ssbi-gpio.c
#	include/linux/gpio/driver.h
diff --cc drivers/gpio/gpio-tegra186.c
index 7f1aa4c21e0d,de241263d4be..000000000000
--- a/drivers/gpio/gpio-tegra186.c
+++ b/drivers/gpio/gpio-tegra186.c
@@@ -398,12 -448,91 +398,67 @@@ static int tegra186_gpio_irq_domain_xla
  	return 0;
  }
  
++<<<<<<< HEAD
 +static const struct irq_domain_ops tegra186_gpio_irq_domain_ops = {
 +	.map = gpiochip_irq_map,
 +	.unmap = gpiochip_irq_unmap,
 +	.xlate = tegra186_gpio_irq_domain_xlate,
++=======
+ static void *tegra186_gpio_populate_parent_fwspec(struct gpio_chip *chip,
+ 						 unsigned int parent_hwirq,
+ 						 unsigned int parent_type)
+ {
+ 	struct tegra_gpio *gpio = gpiochip_get_data(chip);
+ 	struct irq_fwspec *fwspec;
+ 
+ 	fwspec = kmalloc(sizeof(*fwspec), GFP_KERNEL);
+ 	if (!fwspec)
+ 		return NULL;
+ 
+ 	fwspec->fwnode = chip->irq.parent_domain->fwnode;
+ 	fwspec->param_count = 3;
+ 	fwspec->param[0] = gpio->soc->instance;
+ 	fwspec->param[1] = parent_hwirq;
+ 	fwspec->param[2] = parent_type;
+ 
+ 	return fwspec;
+ }
+ 
+ static int tegra186_gpio_child_to_parent_hwirq(struct gpio_chip *chip,
+ 					       unsigned int hwirq,
+ 					       unsigned int type,
+ 					       unsigned int *parent_hwirq,
+ 					       unsigned int *parent_type)
+ {
+ 	*parent_hwirq = chip->irq.child_offset_to_irq(chip, hwirq);
+ 	*parent_type = type;
+ 
+ 	return 0;
+ }
+ 
+ static unsigned int tegra186_gpio_child_offset_to_irq(struct gpio_chip *chip,
+ 						      unsigned int offset)
+ {
+ 	struct tegra_gpio *gpio = gpiochip_get_data(chip);
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < gpio->soc->num_ports; i++) {
+ 		if (offset < gpio->soc->ports[i].pins)
+ 			break;
+ 
+ 		offset -= gpio->soc->ports[i].pins;
+ 	}
+ 
+ 	return offset + i * 8;
+ }
+ 
+ static const struct of_device_id tegra186_pmc_of_match[] = {
+ 	{ .compatible = "nvidia,tegra186-pmc" },
+ 	{ .compatible = "nvidia,tegra194-pmc" },
+ 	{ /* sentinel */ }
++>>>>>>> 242587616710 (gpiolib: Add support for the irqdomain which doesn't use irq_fwspec as arg)
  };
  
 -static void tegra186_gpio_init_route_mapping(struct tegra_gpio *gpio)
 -{
 -	unsigned int i, j;
 -	u32 value;
 -
 -	for (i = 0; i < gpio->soc->num_ports; i++) {
 -		const struct tegra_gpio_port *port = &gpio->soc->ports[i];
 -		unsigned int offset, p = port->port;
 -		void __iomem *base;
 -
 -		base = gpio->secure + port->bank * 0x1000 + 0x800;
 -
 -		value = readl(base + TEGRA186_GPIO_CTL_SCR);
 -
 -		/*
 -		 * For controllers that haven't been locked down yet, make
 -		 * sure to program the default interrupt route mapping.
 -		 */
 -		if ((value & TEGRA186_GPIO_CTL_SCR_SEC_REN) == 0 &&
 -		    (value & TEGRA186_GPIO_CTL_SCR_SEC_WEN) == 0) {
 -			for (j = 0; j < 8; j++) {
 -				offset = TEGRA186_GPIO_INT_ROUTE_MAPPING(p, j);
 -
 -				value = readl(base + offset);
 -				value = BIT(port->pins) - 1;
 -				writel(value, base + offset);
 -			}
 -		}
 -	}
 -}
 -
  static int tegra186_gpio_probe(struct platform_device *pdev)
  {
  	unsigned int i, j, offset;
@@@ -492,7 -625,12 +547,15 @@@
  
  	irq = &gpio->gpio.irq;
  	irq->chip = &gpio->intc;
++<<<<<<< HEAD
 +	irq->domain_ops = &tegra186_gpio_irq_domain_ops;
++=======
+ 	irq->fwnode = of_node_to_fwnode(pdev->dev.of_node);
+ 	irq->child_to_parent_hwirq = tegra186_gpio_child_to_parent_hwirq;
+ 	irq->populate_parent_alloc_arg = tegra186_gpio_populate_parent_fwspec;
+ 	irq->child_offset_to_irq = tegra186_gpio_child_offset_to_irq;
+ 	irq->child_irq_domain_ops.translate = tegra186_gpio_irq_domain_translate;
++>>>>>>> 242587616710 (gpiolib: Add support for the irqdomain which doesn't use irq_fwspec as arg)
  	irq->handler = handle_simple_irq;
  	irq->default_type = IRQ_TYPE_NONE;
  	irq->parent_handler = tegra186_gpio_irq;
diff --cc drivers/gpio/gpiolib.c
index 1987b8ce323f,e0200dda2aee..000000000000
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@@ -1759,6 -1893,286 +1759,289 @@@ void gpiochip_set_nested_irqchip(struc
  }
  EXPORT_SYMBOL_GPL(gpiochip_set_nested_irqchip);
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_IRQ_DOMAIN_HIERARCHY
+ 
+ /**
+  * gpiochip_set_hierarchical_irqchip() - connects a hierarchical irqchip
+  * to a gpiochip
+  * @gc: the gpiochip to set the irqchip hierarchical handler to
+  * @irqchip: the irqchip to handle this level of the hierarchy, the interrupt
+  * will then percolate up to the parent
+  */
+ static void gpiochip_set_hierarchical_irqchip(struct gpio_chip *gc,
+ 					      struct irq_chip *irqchip)
+ {
+ 	/* DT will deal with mapping each IRQ as we go along */
+ 	if (is_of_node(gc->irq.fwnode))
+ 		return;
+ 
+ 	/*
+ 	 * This is for legacy and boardfile "irqchip" fwnodes: allocate
+ 	 * irqs upfront instead of dynamically since we don't have the
+ 	 * dynamic type of allocation that hardware description languages
+ 	 * provide. Once all GPIO drivers using board files are gone from
+ 	 * the kernel we can delete this code, but for a transitional period
+ 	 * it is necessary to keep this around.
+ 	 */
+ 	if (is_fwnode_irqchip(gc->irq.fwnode)) {
+ 		int i;
+ 		int ret;
+ 
+ 		for (i = 0; i < gc->ngpio; i++) {
+ 			struct irq_fwspec fwspec;
+ 			unsigned int parent_hwirq;
+ 			unsigned int parent_type;
+ 			struct gpio_irq_chip *girq = &gc->irq;
+ 
+ 			/*
+ 			 * We call the child to parent translation function
+ 			 * only to check if the child IRQ is valid or not.
+ 			 * Just pick the rising edge type here as that is what
+ 			 * we likely need to support.
+ 			 */
+ 			ret = girq->child_to_parent_hwirq(gc, i,
+ 							  IRQ_TYPE_EDGE_RISING,
+ 							  &parent_hwirq,
+ 							  &parent_type);
+ 			if (ret) {
+ 				chip_err(gc, "skip set-up on hwirq %d\n",
+ 					 i);
+ 				continue;
+ 			}
+ 
+ 			fwspec.fwnode = gc->irq.fwnode;
+ 			/* This is the hwirq for the GPIO line side of things */
+ 			fwspec.param[0] = girq->child_offset_to_irq(gc, i);
+ 			/* Just pick something */
+ 			fwspec.param[1] = IRQ_TYPE_EDGE_RISING;
+ 			fwspec.param_count = 2;
+ 			ret = __irq_domain_alloc_irqs(gc->irq.domain,
+ 						      /* just pick something */
+ 						      -1,
+ 						      1,
+ 						      NUMA_NO_NODE,
+ 						      &fwspec,
+ 						      false,
+ 						      NULL);
+ 			if (ret < 0) {
+ 				chip_err(gc,
+ 					 "can not allocate irq for GPIO line %d parent hwirq %d in hierarchy domain: %d\n",
+ 					 i, parent_hwirq,
+ 					 ret);
+ 			}
+ 		}
+ 	}
+ 
+ 	chip_err(gc, "%s unknown fwnode type proceed anyway\n", __func__);
+ 
+ 	return;
+ }
+ 
+ static int gpiochip_hierarchy_irq_domain_translate(struct irq_domain *d,
+ 						   struct irq_fwspec *fwspec,
+ 						   unsigned long *hwirq,
+ 						   unsigned int *type)
+ {
+ 	/* We support standard DT translation */
+ 	if (is_of_node(fwspec->fwnode) && fwspec->param_count == 2) {
+ 		return irq_domain_translate_twocell(d, fwspec, hwirq, type);
+ 	}
+ 
+ 	/* This is for board files and others not using DT */
+ 	if (is_fwnode_irqchip(fwspec->fwnode)) {
+ 		int ret;
+ 
+ 		ret = irq_domain_translate_twocell(d, fwspec, hwirq, type);
+ 		if (ret)
+ 			return ret;
+ 		WARN_ON(*type == IRQ_TYPE_NONE);
+ 		return 0;
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ static int gpiochip_hierarchy_irq_domain_alloc(struct irq_domain *d,
+ 					       unsigned int irq,
+ 					       unsigned int nr_irqs,
+ 					       void *data)
+ {
+ 	struct gpio_chip *gc = d->host_data;
+ 	irq_hw_number_t hwirq;
+ 	unsigned int type = IRQ_TYPE_NONE;
+ 	struct irq_fwspec *fwspec = data;
+ 	void *parent_arg;
+ 	unsigned int parent_hwirq;
+ 	unsigned int parent_type;
+ 	struct gpio_irq_chip *girq = &gc->irq;
+ 	int ret;
+ 
+ 	/*
+ 	 * The nr_irqs parameter is always one except for PCI multi-MSI
+ 	 * so this should not happen.
+ 	 */
+ 	WARN_ON(nr_irqs != 1);
+ 
+ 	ret = gc->irq.child_irq_domain_ops.translate(d, fwspec, &hwirq, &type);
+ 	if (ret)
+ 		return ret;
+ 
+ 	chip_info(gc, "allocate IRQ %d, hwirq %lu\n", irq,  hwirq);
+ 
+ 	ret = girq->child_to_parent_hwirq(gc, hwirq, type,
+ 					  &parent_hwirq, &parent_type);
+ 	if (ret) {
+ 		chip_err(gc, "can't look up hwirq %lu\n", hwirq);
+ 		return ret;
+ 	}
+ 	chip_info(gc, "found parent hwirq %u\n", parent_hwirq);
+ 
+ 	/*
+ 	 * We set handle_bad_irq because the .set_type() should
+ 	 * always be invoked and set the right type of handler.
+ 	 */
+ 	irq_domain_set_info(d,
+ 			    irq,
+ 			    hwirq,
+ 			    gc->irq.chip,
+ 			    gc,
+ 			    girq->handler,
+ 			    NULL, NULL);
+ 	irq_set_probe(irq);
+ 
+ 	/* This parent only handles asserted level IRQs */
+ 	parent_arg = girq->populate_parent_alloc_arg(gc, parent_hwirq, parent_type);
+ 	if (!parent_arg)
+ 		return -ENOMEM;
+ 
+ 	chip_info(gc, "alloc_irqs_parent for %d parent hwirq %d\n",
+ 		  irq, parent_hwirq);
+ 	ret = irq_domain_alloc_irqs_parent(d, irq, 1, parent_arg);
+ 	if (ret)
+ 		chip_err(gc,
+ 			 "failed to allocate parent hwirq %d for hwirq %lu\n",
+ 			 parent_hwirq, hwirq);
+ 
+ 	kfree(parent_arg);
+ 	return ret;
+ }
+ 
+ static unsigned int gpiochip_child_offset_to_irq_noop(struct gpio_chip *chip,
+ 						      unsigned int offset)
+ {
+ 	return offset;
+ }
+ 
+ static void gpiochip_hierarchy_setup_domain_ops(struct irq_domain_ops *ops)
+ {
+ 	ops->activate = gpiochip_irq_domain_activate;
+ 	ops->deactivate = gpiochip_irq_domain_deactivate;
+ 	ops->alloc = gpiochip_hierarchy_irq_domain_alloc;
+ 	ops->free = irq_domain_free_irqs_common;
+ 
+ 	/*
+ 	 * We only allow overriding the translate() function for
+ 	 * hierarchical chips, and this should only be done if the user
+ 	 * really need something other than 1:1 translation.
+ 	 */
+ 	if (!ops->translate)
+ 		ops->translate = gpiochip_hierarchy_irq_domain_translate;
+ }
+ 
+ static int gpiochip_hierarchy_add_domain(struct gpio_chip *gc)
+ {
+ 	if (!gc->irq.child_to_parent_hwirq ||
+ 	    !gc->irq.fwnode) {
+ 		chip_err(gc, "missing irqdomain vital data\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!gc->irq.child_offset_to_irq)
+ 		gc->irq.child_offset_to_irq = gpiochip_child_offset_to_irq_noop;
+ 
+ 	if (!gc->irq.populate_parent_alloc_arg)
+ 		gc->irq.populate_parent_alloc_arg =
+ 			gpiochip_populate_parent_fwspec_twocell;
+ 
+ 	gpiochip_hierarchy_setup_domain_ops(&gc->irq.child_irq_domain_ops);
+ 
+ 	gc->irq.domain = irq_domain_create_hierarchy(
+ 		gc->irq.parent_domain,
+ 		0,
+ 		gc->ngpio,
+ 		gc->irq.fwnode,
+ 		&gc->irq.child_irq_domain_ops,
+ 		gc);
+ 
+ 	if (!gc->irq.domain)
+ 		return -ENOMEM;
+ 
+ 	gpiochip_set_hierarchical_irqchip(gc, gc->irq.chip);
+ 
+ 	return 0;
+ }
+ 
+ static bool gpiochip_hierarchy_is_hierarchical(struct gpio_chip *gc)
+ {
+ 	return !!gc->irq.parent_domain;
+ }
+ 
+ void *gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
+ 					     unsigned int parent_hwirq,
+ 					     unsigned int parent_type)
+ {
+ 	struct irq_fwspec *fwspec;
+ 
+ 	fwspec = kmalloc(sizeof(*fwspec), GFP_KERNEL);
+ 	if (!fwspec)
+ 		return NULL;
+ 
+ 	fwspec->fwnode = chip->irq.parent_domain->fwnode;
+ 	fwspec->param_count = 2;
+ 	fwspec->param[0] = parent_hwirq;
+ 	fwspec->param[1] = parent_type;
+ 
+ 	return fwspec;
+ }
+ EXPORT_SYMBOL_GPL(gpiochip_populate_parent_fwspec_twocell);
+ 
+ void *gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
+ 					      unsigned int parent_hwirq,
+ 					      unsigned int parent_type)
+ {
+ 	struct irq_fwspec *fwspec;
+ 
+ 	fwspec = kmalloc(sizeof(*fwspec), GFP_KERNEL);
+ 	if (!fwspec)
+ 		return NULL;
+ 
+ 	fwspec->fwnode = chip->irq.parent_domain->fwnode;
+ 	fwspec->param_count = 4;
+ 	fwspec->param[0] = 0;
+ 	fwspec->param[1] = parent_hwirq;
+ 	fwspec->param[2] = 0;
+ 	fwspec->param[3] = parent_type;
+ 
+ 	return fwspec;
+ }
+ EXPORT_SYMBOL_GPL(gpiochip_populate_parent_fwspec_fourcell);
+ 
+ #else
+ 
+ static int gpiochip_hierarchy_add_domain(struct gpio_chip *gc)
+ {
+ 	return -EINVAL;
+ }
+ 
+ static bool gpiochip_hierarchy_is_hierarchical(struct gpio_chip *gc)
+ {
+ 	return false;
+ }
+ 
+ #endif /* CONFIG_IRQ_DOMAIN_HIERARCHY */
+ 
++>>>>>>> 242587616710 (gpiolib: Add support for the irqdomain which doesn't use irq_fwspec as arg)
  /**
   * gpiochip_irq_map() - maps an IRQ into a GPIO irqchip
   * @d: the irqdomain used by this irqchip
diff --cc drivers/pinctrl/qcom/pinctrl-spmi-gpio.c
index c1550d4d1b55,fe0be8a6ebb7..000000000000
--- a/drivers/pinctrl/qcom/pinctrl-spmi-gpio.c
+++ b/drivers/pinctrl/qcom/pinctrl-spmi-gpio.c
@@@ -1006,6 -1044,26 +1006,29 @@@ static int pmic_gpio_probe(struct platf
  	if (IS_ERR(state->ctrl))
  		return PTR_ERR(state->ctrl);
  
++<<<<<<< HEAD
++=======
+ 	parent_node = of_irq_find_parent(state->dev->of_node);
+ 	if (!parent_node)
+ 		return -ENXIO;
+ 
+ 	parent_domain = irq_find_host(parent_node);
+ 	of_node_put(parent_node);
+ 	if (!parent_domain)
+ 		return -ENXIO;
+ 
+ 	girq = &state->chip.irq;
+ 	girq->chip = &pmic_gpio_irq_chip;
+ 	girq->default_type = IRQ_TYPE_NONE;
+ 	girq->handler = handle_level_irq;
+ 	girq->fwnode = of_node_to_fwnode(state->dev->of_node);
+ 	girq->parent_domain = parent_domain;
+ 	girq->child_to_parent_hwirq = pmic_gpio_child_to_parent_hwirq;
+ 	girq->populate_parent_alloc_arg = gpiochip_populate_parent_fwspec_fourcell;
+ 	girq->child_offset_to_irq = pmic_gpio_child_offset_to_irq;
+ 	girq->child_irq_domain_ops.translate = pmic_gpio_domain_translate;
+ 
++>>>>>>> 242587616710 (gpiolib: Add support for the irqdomain which doesn't use irq_fwspec as arg)
  	ret = gpiochip_add_data(&state->chip, state);
  	if (ret) {
  		dev_err(state->dev, "can't add gpio chip\n");
diff --cc drivers/pinctrl/qcom/pinctrl-ssbi-gpio.c
index b9caf1d4948e,73d986a903f1..000000000000
--- a/drivers/pinctrl/qcom/pinctrl-ssbi-gpio.c
+++ b/drivers/pinctrl/qcom/pinctrl-ssbi-gpio.c
@@@ -742,6 -777,27 +742,30 @@@ static int pm8xxx_gpio_probe(struct pla
  	pctrl->chip.of_gpio_n_cells = 2;
  	pctrl->chip.label = dev_name(pctrl->dev);
  	pctrl->chip.ngpio = pctrl->npins;
++<<<<<<< HEAD
++=======
+ 
+ 	parent_node = of_irq_find_parent(pctrl->dev->of_node);
+ 	if (!parent_node)
+ 		return -ENXIO;
+ 
+ 	parent_domain = irq_find_host(parent_node);
+ 	of_node_put(parent_node);
+ 	if (!parent_domain)
+ 		return -ENXIO;
+ 
+ 	girq = &pctrl->chip.irq;
+ 	girq->chip = &pm8xxx_irq_chip;
+ 	girq->default_type = IRQ_TYPE_NONE;
+ 	girq->handler = handle_level_irq;
+ 	girq->fwnode = of_node_to_fwnode(pctrl->dev->of_node);
+ 	girq->parent_domain = parent_domain;
+ 	girq->child_to_parent_hwirq = pm8xxx_child_to_parent_hwirq;
+ 	girq->populate_parent_alloc_arg = gpiochip_populate_parent_fwspec_fourcell;
+ 	girq->child_offset_to_irq = pm8xxx_child_offset_to_irq;
+ 	girq->child_irq_domain_ops.translate = pm8xxx_domain_translate;
+ 
++>>>>>>> 242587616710 (gpiolib: Add support for the irqdomain which doesn't use irq_fwspec as arg)
  	ret = gpiochip_add_data(&pctrl->chip, pctrl);
  	if (ret) {
  		dev_err(&pdev->dev, "failed register gpiochip\n");
diff --cc include/linux/gpio/driver.h
index f4ee51450abd,9bb43467ed11..000000000000
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@@ -47,6 -51,83 +47,86 @@@ struct gpio_irq_chip 
  	 */
  	const struct irq_domain_ops *domain_ops;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_IRQ_DOMAIN_HIERARCHY
+ 	/**
+ 	 * @fwnode:
+ 	 *
+ 	 * Firmware node corresponding to this gpiochip/irqchip, necessary
+ 	 * for hierarchical irqdomain support.
+ 	 */
+ 	struct fwnode_handle *fwnode;
+ 
+ 	/**
+ 	 * @parent_domain:
+ 	 *
+ 	 * If non-NULL, will be set as the parent of this GPIO interrupt
+ 	 * controller's IRQ domain to establish a hierarchical interrupt
+ 	 * domain. The presence of this will activate the hierarchical
+ 	 * interrupt support.
+ 	 */
+ 	struct irq_domain *parent_domain;
+ 
+ 	/**
+ 	 * @child_to_parent_hwirq:
+ 	 *
+ 	 * This callback translates a child hardware IRQ offset to a parent
+ 	 * hardware IRQ offset on a hierarchical interrupt chip. The child
+ 	 * hardware IRQs correspond to the GPIO index 0..ngpio-1 (see the
+ 	 * ngpio field of struct gpio_chip) and the corresponding parent
+ 	 * hardware IRQ and type (such as IRQ_TYPE_*) shall be returned by
+ 	 * the driver. The driver can calculate this from an offset or using
+ 	 * a lookup table or whatever method is best for this chip. Return
+ 	 * 0 on successful translation in the driver.
+ 	 *
+ 	 * If some ranges of hardware IRQs do not have a corresponding parent
+ 	 * HWIRQ, return -EINVAL, but also make sure to fill in @valid_mask and
+ 	 * @need_valid_mask to make these GPIO lines unavailable for
+ 	 * translation.
+ 	 */
+ 	int (*child_to_parent_hwirq)(struct gpio_chip *chip,
+ 				     unsigned int child_hwirq,
+ 				     unsigned int child_type,
+ 				     unsigned int *parent_hwirq,
+ 				     unsigned int *parent_type);
+ 
+ 	/**
+ 	 * @populate_parent_alloc_arg :
+ 	 *
+ 	 * This optional callback allocates and populates the specific struct
+ 	 * for the parent's IRQ domain. If this is not specified, then
+ 	 * &gpiochip_populate_parent_fwspec_twocell will be used. A four-cell
+ 	 * variant named &gpiochip_populate_parent_fwspec_fourcell is also
+ 	 * available.
+ 	 */
+ 	void *(*populate_parent_alloc_arg)(struct gpio_chip *chip,
+ 				       unsigned int parent_hwirq,
+ 				       unsigned int parent_type);
+ 
+ 	/**
+ 	 * @child_offset_to_irq:
+ 	 *
+ 	 * This optional callback is used to translate the child's GPIO line
+ 	 * offset on the GPIO chip to an IRQ number for the GPIO to_irq()
+ 	 * callback. If this is not specified, then a default callback will be
+ 	 * provided that returns the line offset.
+ 	 */
+ 	unsigned int (*child_offset_to_irq)(struct gpio_chip *chip,
+ 					    unsigned int pin);
+ 
+ 	/**
+ 	 * @child_irq_domain_ops:
+ 	 *
+ 	 * The IRQ domain operations that will be used for this GPIO IRQ
+ 	 * chip. If no operations are provided, then default callbacks will
+ 	 * be populated to setup the IRQ hierarchy. Some drivers need to
+ 	 * supply their own translate function.
+ 	 */
+ 	struct irq_domain_ops child_irq_domain_ops;
+ #endif
+ 
++>>>>>>> 242587616710 (gpiolib: Add support for the irqdomain which doesn't use irq_fwspec as arg)
  	/**
  	 * @handler:
  	 *
@@@ -444,6 -534,31 +524,34 @@@ struct bgpio_pdata 
  	int ngpio;
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_IRQ_DOMAIN_HIERARCHY
+ 
+ void *gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
+ 					     unsigned int parent_hwirq,
+ 					     unsigned int parent_type);
+ void *gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
+ 					      unsigned int parent_hwirq,
+ 					      unsigned int parent_type);
+ 
+ #else
+ 
+ static inline void *gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
+ 						    unsigned int parent_hwirq,
+ 						    unsigned int parent_type)
+ {
+ }
+ 
+ static inline void *gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
+ 						     unsigned int parent_hwirq,
+ 						     unsigned int parent_type)
+ {
+ }
+ 
+ #endif /* CONFIG_IRQ_DOMAIN_HIERARCHY */
+ 
++>>>>>>> 242587616710 (gpiolib: Add support for the irqdomain which doesn't use irq_fwspec as arg)
  int bgpio_init(struct gpio_chip *gc, struct device *dev,
  	       unsigned long sz, void __iomem *dat, void __iomem *set,
  	       void __iomem *clr, void __iomem *dirout, void __iomem *dirin,
* Unmerged path drivers/gpio/gpio-tegra186.c
* Unmerged path drivers/gpio/gpiolib.c
* Unmerged path drivers/pinctrl/qcom/pinctrl-spmi-gpio.c
* Unmerged path drivers/pinctrl/qcom/pinctrl-ssbi-gpio.c
* Unmerged path include/linux/gpio/driver.h
