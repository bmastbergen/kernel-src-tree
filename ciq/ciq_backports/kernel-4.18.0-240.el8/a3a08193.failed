ceph: don't allow copy_file_range when stripe_count != 1

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Luis Henriques <lhenriques@suse.com>
commit a3a0819388b2bf15e7eafe38ff6aacfc27b12df0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a3a08193.failed

copy_file_range tries to use the OSD 'copy-from' operation, which simply
performs a full object copy.  Unfortunately, the implementation of this
system call assumes that stripe_count is always set to 1 and doesn't take
into account that the data may be striped across an object set.  If the
file layout has stripe_count different from 1, then the destination file
data will be corrupted.

For example:

Consider a 8 MiB file with 4 MiB object size, stripe_count of 2 and
stripe_size of 2 MiB; the first half of the file will be filled with 'A's
and the second half will be filled with 'B's:

               0      4M     8M       Obj1     Obj2
               +------+------+       +----+   +----+
        file:  | AAAA | BBBB |       | AA |   | AA |
               +------+------+       |----|   |----|
                                     | BB |   | BB |
                                     +----+   +----+

If we copy_file_range this file into a new file (which needs to have the
same file layout!), then it will start by copying the object starting at
file offset 0 (Obj1).  And then it will copy the object starting at file
offset 4M -- which is Obj1 again.

Unfortunately, the solution for this is to not allow remote object copies
to be performed when the file layout stripe_count is not 1 and simply
fallback to the default (VFS) copy_file_range implementation.

	Cc: stable@vger.kernel.org
	Signed-off-by: Luis Henriques <lhenriques@suse.com>
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit a3a0819388b2bf15e7eafe38ff6aacfc27b12df0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/file.c
diff --cc fs/ceph/file.c
index dbc64bff395f,bd77adb64bfd..000000000000
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@@ -1964,10 -1956,21 +1964,24 @@@ static ssize_t __ceph_copy_file_range(s
  	 * efficient).
  	 */
  
++<<<<<<< HEAD
++=======
+ 	if (ceph_test_mount_opt(src_fsc, NOCOPYFROM))
+ 		return -EOPNOTSUPP;
+ 
+ 	/*
+ 	 * Striped file layouts require that we copy partial objects, but the
+ 	 * OSD copy-from operation only supports full-object copies.  Limit
+ 	 * this to non-striped file layouts for now.
+ 	 */
++>>>>>>> a3a0819388b2 (ceph: don't allow copy_file_range when stripe_count != 1)
  	if ((src_ci->i_layout.stripe_unit != dst_ci->i_layout.stripe_unit) ||
- 	    (src_ci->i_layout.stripe_count != dst_ci->i_layout.stripe_count) ||
- 	    (src_ci->i_layout.object_size != dst_ci->i_layout.object_size))
+ 	    (src_ci->i_layout.stripe_count != 1) ||
+ 	    (dst_ci->i_layout.stripe_count != 1) ||
+ 	    (src_ci->i_layout.object_size != dst_ci->i_layout.object_size)) {
+ 		dout("Invalid src/dst files layout\n");
  		return -EOPNOTSUPP;
+ 	}
  
  	if (len < src_ci->i_layout.object_size)
  		return -EOPNOTSUPP; /* no remote copy will be done */
* Unmerged path fs/ceph/file.c
