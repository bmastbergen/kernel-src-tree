drm/i915/display: Split hsw_power_well_enable() into two

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit f8bb28e63a1e9f46fe15f63e924fab643ff8abe0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f8bb28e6.failed

This is a preparation for ICL TC cold exit sequences.

v2:
- renamed new functions to hsw_power_well_enable_prepare()/complete()

	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
	Reviewed-by: Imre Deak <imre.deak@intel.com>
	Tested-by: You-Sheng Yang <vicamo.yang@canonical.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200414194956.164323-3-jose.souza@intel.com
(cherry picked from commit f8bb28e63a1e9f46fe15f63e924fab643ff8abe0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display_power.c
diff --cc drivers/gpu/drm/i915/display/intel_display_power.c
index dd1a43a366f2,606a1659021b..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display_power.c
+++ b/drivers/gpu/drm/i915/display/intel_display_power.c
@@@ -324,13 -375,13 +324,13 @@@ static void gen9_wait_for_power_well_fu
  					   enum skl_power_gate pg)
  {
  	/* Timeout 5us for PG#0, for other PGs 1us */
 -	drm_WARN_ON(&dev_priv->drm,
 -		    intel_de_wait_for_set(dev_priv, SKL_FUSE_STATUS,
 -					  SKL_FUSE_PG_DIST_STATUS(pg), 1));
 +	WARN_ON(intel_wait_for_register(&dev_priv->uncore, SKL_FUSE_STATUS,
 +					SKL_FUSE_PG_DIST_STATUS(pg),
 +					SKL_FUSE_PG_DIST_STATUS(pg), 1));
  }
  
- static void hsw_power_well_enable(struct drm_i915_private *dev_priv,
- 				  struct i915_power_well *power_well)
+ static void hsw_power_well_enable_prepare(struct drm_i915_private *dev_priv,
+ 					  struct i915_power_well *power_well)
  {
  	const struct i915_power_well_regs *regs = power_well->desc->hsw.regs;
  	int pw_idx = power_well->desc->hsw.idx;
@@@ -352,21 -403,36 +352,45 @@@
  			gen9_wait_for_power_well_fuses(dev_priv, SKL_PG0);
  	}
  
++<<<<<<< HEAD
 +	val = I915_READ(regs->driver);
 +	I915_WRITE(regs->driver, val | HSW_PWR_WELL_CTL_REQ(pw_idx));
++=======
+ 	val = intel_de_read(dev_priv, regs->driver);
+ 	intel_de_write(dev_priv, regs->driver,
+ 		       val | HSW_PWR_WELL_CTL_REQ(pw_idx));
+ }
+ 
+ static void hsw_power_well_enable_complete(struct drm_i915_private *dev_priv,
+ 					   struct i915_power_well *power_well)
+ {
+ 	int pw_idx = power_well->desc->hsw.idx;
+ 
++>>>>>>> f8bb28e63a1e (drm/i915/display: Split hsw_power_well_enable() into two)
  	hsw_wait_for_power_well_enable(dev_priv, power_well);
  
  	/* Display WA #1178: cnl */
  	if (IS_CANNONLAKE(dev_priv) &&
  	    pw_idx >= GLK_PW_CTL_IDX_AUX_B &&
  	    pw_idx <= CNL_PW_CTL_IDX_AUX_F) {
++<<<<<<< HEAD
 +		val = I915_READ(CNL_AUX_ANAOVRD1(pw_idx));
++=======
+ 		u32 val;
+ 
+ 		val = intel_de_read(dev_priv, CNL_AUX_ANAOVRD1(pw_idx));
++>>>>>>> f8bb28e63a1e (drm/i915/display: Split hsw_power_well_enable() into two)
  		val |= CNL_AUX_ANAOVRD1_ENABLE | CNL_AUX_ANAOVRD1_LDO_BYPASS;
 -		intel_de_write(dev_priv, CNL_AUX_ANAOVRD1(pw_idx), val);
 +		I915_WRITE(CNL_AUX_ANAOVRD1(pw_idx), val);
  	}
  
- 	if (wait_fuses)
+ 	if (power_well->desc->hsw.has_fuses) {
+ 		enum skl_power_gate pg;
+ 
+ 		pg = INTEL_GEN(dev_priv) >= 11 ? ICL_PW_CTL_IDX_TO_PG(pw_idx) :
+ 						 SKL_PW_CTL_IDX_TO_PG(pw_idx);
  		gen9_wait_for_power_well_fuses(dev_priv, pg);
+ 	}
  
  	hsw_power_well_post_enable(dev_priv,
  				   power_well->desc->hsw.irq_pipe_mask,
@@@ -445,20 -579,48 +476,53 @@@ static voi
  icl_tc_phy_aux_power_well_enable(struct drm_i915_private *dev_priv,
  				 struct i915_power_well *power_well)
  {
 -	enum aux_ch aux_ch = icl_tc_phy_aux_ch(dev_priv, power_well);
 -	struct intel_digital_port *dig_port = aux_ch_to_digital_port(dev_priv, aux_ch);
 +	int pw_idx = power_well->desc->hsw.idx;
 +	bool is_tbt = power_well->desc->hsw.is_tc_tbt;
 +	enum aux_ch aux_ch;
  	u32 val;
  
 -	icl_tc_port_assert_ref_held(dev_priv, power_well, dig_port);
 -
 -	val = intel_de_read(dev_priv, DP_AUX_CH_CTL(aux_ch));
 +	aux_ch = is_tbt ? ICL_TBT_AUX_PW_TO_CH(pw_idx) :
 +			  ICL_AUX_PW_TO_CH(pw_idx);
 +	val = I915_READ(DP_AUX_CH_CTL(aux_ch));
  	val &= ~DP_AUX_CH_CTL_TBT_IO;
 -	if (power_well->desc->hsw.is_tc_tbt)
 +	if (is_tbt)
  		val |= DP_AUX_CH_CTL_TBT_IO;
 -	intel_de_write(dev_priv, DP_AUX_CH_CTL(aux_ch), val);
 +	I915_WRITE(DP_AUX_CH_CTL(aux_ch), val);
  
++<<<<<<< HEAD
 +	hsw_power_well_enable(dev_priv, power_well);
++=======
+ 	hsw_power_well_enable_prepare(dev_priv, power_well);
+ 
+ 	/* TODO ICL TC cold handling */
+ 
+ 	hsw_power_well_enable_complete(dev_priv, power_well);
+ 
+ 	if (INTEL_GEN(dev_priv) >= 12 && !power_well->desc->hsw.is_tc_tbt) {
+ 		enum tc_port tc_port;
+ 
+ 		tc_port = TGL_AUX_PW_TO_TC_PORT(power_well->desc->hsw.idx);
+ 		intel_de_write(dev_priv, HIP_INDEX_REG(tc_port),
+ 			       HIP_INDEX_VAL(tc_port, 0x2));
+ 
+ 		if (intel_de_wait_for_set(dev_priv, DKL_CMN_UC_DW_27(tc_port),
+ 					  DKL_CMN_UC_DW27_UC_HEALTH, 1))
+ 			drm_warn(&dev_priv->drm,
+ 				 "Timeout waiting TC uC health\n");
+ 	}
+ }
+ 
+ static void
+ icl_tc_phy_aux_power_well_disable(struct drm_i915_private *dev_priv,
+ 				  struct i915_power_well *power_well)
+ {
+ 	enum aux_ch aux_ch = icl_tc_phy_aux_ch(dev_priv, power_well);
+ 	struct intel_digital_port *dig_port = aux_ch_to_digital_port(dev_priv, aux_ch);
+ 
+ 	icl_tc_port_assert_ref_held(dev_priv, power_well, dig_port);
+ 
+ 	hsw_power_well_disable(dev_priv, power_well);
++>>>>>>> f8bb28e63a1e (drm/i915/display: Split hsw_power_well_enable() into two)
  }
  
  /*
* Unmerged path drivers/gpu/drm/i915/display/intel_display_power.c
