gpio: of: Switch to EXPORT_SYMBOL_GPL()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Geert Uytterhoeven <geert+renesas@glider.be>
commit 6d6624554da4a623fd047d15790157a0572ab091
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6d662455.failed

All exported functions provide genuine Linux-specific functionality.

	Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
Link: https://lore.kernel.org/r/20190906084539.21838-4-geert+renesas@glider.be
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 6d6624554da4a623fd047d15790157a0572ab091)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib-of.c
diff --cc drivers/gpio/gpiolib-of.c
index 3c4dc2243d7a,d5b98b48eb5d..000000000000
--- a/drivers/gpio/gpiolib-of.c
+++ b/drivers/gpio/gpiolib-of.c
@@@ -229,8 -274,77 +229,80 @@@ int of_get_named_gpio_flags(struct devi
  	else
  		return desc_to_gpio(desc);
  }
- EXPORT_SYMBOL(of_get_named_gpio_flags);
+ EXPORT_SYMBOL_GPL(of_get_named_gpio_flags);
  
++<<<<<<< HEAD
++=======
+ /**
+  * gpiod_get_from_of_node() - obtain a GPIO from an OF node
+  * @node:	handle of the OF node
+  * @propname:	name of the DT property representing the GPIO
+  * @index:	index of the GPIO to obtain for the consumer
+  * @dflags:	GPIO initialization flags
+  * @label:	label to attach to the requested GPIO
+  *
+  * Returns:
+  * On successful request the GPIO pin is configured in accordance with
+  * provided @dflags.
+  *
+  * In case of error an ERR_PTR() is returned.
+  */
+ struct gpio_desc *gpiod_get_from_of_node(struct device_node *node,
+ 					 const char *propname, int index,
+ 					 enum gpiod_flags dflags,
+ 					 const char *label)
+ {
+ 	unsigned long lflags = GPIO_LOOKUP_FLAGS_DEFAULT;
+ 	struct gpio_desc *desc;
+ 	enum of_gpio_flags flags;
+ 	bool active_low = false;
+ 	bool single_ended = false;
+ 	bool open_drain = false;
+ 	bool transitory = false;
+ 	int ret;
+ 
+ 	desc = of_get_named_gpiod_flags(node, propname,
+ 					index, &flags);
+ 
+ 	if (!desc || IS_ERR(desc)) {
+ 		return desc;
+ 	}
+ 
+ 	active_low = flags & OF_GPIO_ACTIVE_LOW;
+ 	single_ended = flags & OF_GPIO_SINGLE_ENDED;
+ 	open_drain = flags & OF_GPIO_OPEN_DRAIN;
+ 	transitory = flags & OF_GPIO_TRANSITORY;
+ 
+ 	ret = gpiod_request(desc, label);
+ 	if (ret == -EBUSY && (flags & GPIOD_FLAGS_BIT_NONEXCLUSIVE))
+ 		return desc;
+ 	if (ret)
+ 		return ERR_PTR(ret);
+ 
+ 	if (active_low)
+ 		lflags |= GPIO_ACTIVE_LOW;
+ 
+ 	if (single_ended) {
+ 		if (open_drain)
+ 			lflags |= GPIO_OPEN_DRAIN;
+ 		else
+ 			lflags |= GPIO_OPEN_SOURCE;
+ 	}
+ 
+ 	if (transitory)
+ 		lflags |= GPIO_TRANSITORY;
+ 
+ 	ret = gpiod_configure_flags(desc, propname, lflags, dflags);
+ 	if (ret < 0) {
+ 		gpiod_put(desc);
+ 		return ERR_PTR(ret);
+ 	}
+ 
+ 	return desc;
+ }
+ EXPORT_SYMBOL_GPL(gpiod_get_from_of_node);
+ 
++>>>>>>> 6d6624554da4 (gpio: of: Switch to EXPORT_SYMBOL_GPL())
  /*
   * The SPI GPIO bindings happened before we managed to establish that GPIO
   * properties should be named "foo-gpios" so we have this special kludge for
* Unmerged path drivers/gpio/gpiolib-of.c
