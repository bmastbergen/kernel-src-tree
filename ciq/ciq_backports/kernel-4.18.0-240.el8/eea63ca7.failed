xprtrdma: Initialize rb_credits in one place

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Chuck Lever <chuck.lever@oracle.com>
commit eea63ca7ffa1f3a4a0b02b902ec51eab2d4e9df4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/eea63ca7.failed

Clean up/code de-duplication.

Nit: RPC_CWNDSHIFT is incorrect as the initial value for xprt->cwnd.
This mistake does not appear to have operational consequences, since
the cwnd value is replaced with a valid value upon the first Receive
completion.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit eea63ca7ffa1f3a4a0b02b902ec51eab2d4e9df4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/rpc_rdma.c
#	net/sunrpc/xprtrdma/verbs.c
diff --cc net/sunrpc/xprtrdma/rpc_rdma.c
index e17f3d670e48,f1e3639d2050..000000000000
--- a/net/sunrpc/xprtrdma/rpc_rdma.c
+++ b/net/sunrpc/xprtrdma/rpc_rdma.c
@@@ -1330,13 -1390,8 +1364,18 @@@ void rpcrdma_reply_handler(struct rpcrd
  		credits = 1;	/* don't deadlock */
  	else if (credits > buf->rb_max_requests)
  		credits = buf->rb_max_requests;
++<<<<<<< HEAD
 +	if (buf->rb_credits != credits) {
 +		spin_lock_bh(&xprt->transport_lock);
 +		buf->rb_credits = credits;
 +		xprt->cwnd = credits << RPC_CWNDSHIFT;
 +		spin_unlock_bh(&xprt->transport_lock);
 +	}
 +	rpcrdma_post_recvs(r_xprt, false);
++=======
+ 	if (buf->rb_credits != credits)
+ 		rpcrdma_update_cwnd(r_xprt, credits);
++>>>>>>> eea63ca7ffa1 (xprtrdma: Initialize rb_credits in one place)
  
  	req = rpcr_to_rdmar(rqst);
  	if (req->rl_reply) {
diff --cc net/sunrpc/xprtrdma/verbs.c
index cfae694214c1,97bc15e287b2..000000000000
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@@ -1122,8 -1164,7 +1123,12 @@@ int rpcrdma_buffer_create(struct rpcrdm
  		list_add(&req->rl_list, &buf->rb_send_bufs);
  	}
  
++<<<<<<< HEAD
 +	buf->rb_credits = 1;
 +	INIT_LIST_HEAD(&buf->rb_recv_bufs);
++=======
+ 	init_llist_head(&buf->rb_free_reps);
++>>>>>>> eea63ca7ffa1 (xprtrdma: Initialize rb_credits in one place)
  
  	rc = rpcrdma_sendctxs_create(r_xprt);
  	if (rc)
* Unmerged path net/sunrpc/xprtrdma/rpc_rdma.c
diff --git a/net/sunrpc/xprtrdma/transport.c b/net/sunrpc/xprtrdma/transport.c
index 0fe08550a1a6..d6b8f0acdef9 100644
--- a/net/sunrpc/xprtrdma/transport.c
+++ b/net/sunrpc/xprtrdma/transport.c
@@ -427,15 +427,6 @@ void xprt_rdma_close(struct rpc_xprt *xprt)
 		xprt->reestablish_timeout = 0;
 	rpcrdma_ep_disconnect(ep, ia);
 
-	/* Prepare @xprt for the next connection by reinitializing
-	 * its credit grant to one (see RFC 8166, Section 3.3.3).
-	 */
-	spin_lock(&xprt->transport_lock);
-	r_xprt->rx_buf.rb_credits = 1;
-	xprt->cong = 0;
-	xprt->cwnd = RPC_CWNDSHIFT;
-	spin_unlock(&xprt->transport_lock);
-
 out:
 	++xprt->connect_cookie;
 	xprt_disconnect_done(xprt);
* Unmerged path net/sunrpc/xprtrdma/verbs.c
diff --git a/net/sunrpc/xprtrdma/xprt_rdma.h b/net/sunrpc/xprtrdma/xprt_rdma.h
index 2dbd229358d4..b97feb00091d 100644
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@ -580,6 +580,7 @@ int rpcrdma_prepare_send_sges(struct rpcrdma_xprt *r_xprt,
 void rpcrdma_sendctx_unmap(struct rpcrdma_sendctx *sc);
 int rpcrdma_marshal_req(struct rpcrdma_xprt *r_xprt, struct rpc_rqst *rqst);
 void rpcrdma_set_max_header_sizes(struct rpcrdma_xprt *);
+void rpcrdma_reset_cwnd(struct rpcrdma_xprt *r_xprt);
 void rpcrdma_complete_rqst(struct rpcrdma_rep *rep);
 void rpcrdma_reply_handler(struct rpcrdma_rep *rep);
 
