KVM: x86: Invoke kvm_vcpu_uninit() immediately prior to freeing vcpu

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit d2423b347de46657c306d4c58f2e08feba4a19c4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d2423b34.failed

Move the call to kvm_vcpu_uninit() in kvm_arch_vcpu_destroy() down a few
lines so that it is invoked immediately prior to freeing the vCPU.  This
paves the way for moving the uninit and free sequence to common KVM code
without an associated functional change.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit d2423b347de46657c306d4c58f2e08feba4a19c4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index fd0e26bb25de,335762a17180..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -9215,7 -9247,16 +9215,20 @@@ void kvm_arch_vcpu_postcreate(struct kv
  
  void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	kvm_arch_vcpu_free(vcpu);
++=======
+ 	kvmclock_reset(vcpu);
+ 
+ 	kvm_x86_ops->vcpu_free(vcpu);
+ 
+ 	free_cpumask_var(vcpu->arch.wbinvd_dirty_mask);
+ 	kmem_cache_free(x86_fpu_cache, vcpu->arch.user_fpu);
+ 	kmem_cache_free(x86_fpu_cache, vcpu->arch.guest_fpu);
+ 
+ 	kvm_vcpu_uninit(vcpu);
+ 	kmem_cache_free(kvm_vcpu_cache, vcpu);
++>>>>>>> d2423b347de4 (KVM: x86: Invoke kvm_vcpu_uninit() immediately prior to freeing vcpu)
  }
  
  void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
* Unmerged path arch/x86/kvm/x86.c
