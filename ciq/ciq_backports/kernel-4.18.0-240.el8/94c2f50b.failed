selftests/bpf: Fix race in tcp_rtt test

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 94c2f50b61258381abcd3a33fd5f2bc87e26df11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/94c2f50b.failed

Previous attempt to make tcp_rtt more robust introduced a new race, in which
server_done might be set to true before server can actually accept any
connection. Fix this by unconditionally waiting for accept(). Given socket is
non-blocking, if there are any problems with client side, it should eventually
close listening FD and let server thread exit with failure.

Fixes: 4cd729fa022c ("selftests/bpf: Make tcp_rtt test more robust to failures")
	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
Link: https://lore.kernel.org/bpf/20200314013932.4035712-1-andriin@fb.com
(cherry picked from commit 94c2f50b61258381abcd3a33fd5f2bc87e26df11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/test_tcp_rtt.c
diff --cc tools/testing/selftests/bpf/test_tcp_rtt.c
index a5e1b315bd8d,e56b52ab41da..000000000000
--- a/tools/testing/selftests/bpf/test_tcp_rtt.c
+++ b/tools/testing/selftests/bpf/test_tcp_rtt.c
@@@ -235,19 -221,26 +235,34 @@@ static void *server_thread(void *arg
  	pthread_cond_signal(&server_started);
  	pthread_mutex_unlock(&server_started_mtx);
  
 -	if (CHECK_FAIL(err < 0)) {
 -		perror("Failed to listed on socket");
 -		return ERR_PTR(err);
 -	}
 +	if (err < 0)
 +		error(1, errno, "Failed to listed on socket");
  
++<<<<<<< HEAD:tools/testing/selftests/bpf/test_tcp_rtt.c
 +	client_fd = accept(fd, (struct sockaddr *)&addr, &len);
 +	if (client_fd < 0)
 +		error(1, errno, "Failed to accept client");
++=======
+ 	while (true) {
+ 		client_fd = accept(fd, (struct sockaddr *)&addr, &len);
+ 		if (client_fd == -1 && errno == EAGAIN) {
+ 			usleep(50);
+ 			continue;
+ 		}
+ 		break;
+ 	}
+ 	if (CHECK_FAIL(client_fd < 0)) {
+ 		perror("Failed to accept client");
+ 		return ERR_PTR(err);
+ 	}
++>>>>>>> 94c2f50b6125 (selftests/bpf: Fix race in tcp_rtt test):tools/testing/selftests/bpf/prog_tests/tcp_rtt.c
  
 -	while (!server_done)
 -		usleep(50);
 +	/* Wait for the next connection (that never arrives)
 +	 * to keep this thread alive to prevent calling
 +	 * close() on client_fd.
 +	 */
 +	if (accept(fd, (struct sockaddr *)&addr, &len) >= 0)
 +		error(1, errno, "Unexpected success in second accept");
  
  	close(client_fd);
  
@@@ -286,11 -269,11 +301,17 @@@ int main(int args, char **argv
  	pthread_cond_wait(&server_started, &server_started_mtx);
  	pthread_mutex_unlock(&server_started_mtx);
  
 -	CHECK_FAIL(run_test(cgroup_fd, server_fd));
 +	if (run_test(cgroup_fd, server_fd))
 +		err = EXIT_FAILURE;
  
++<<<<<<< HEAD:tools/testing/selftests/bpf/test_tcp_rtt.c
 +	printf("test_sockopt_sk: %s\n",
 +	       err == EXIT_SUCCESS ? "PASSED" : "FAILED");
++=======
+ 	server_done = true;
+ 	CHECK_FAIL(pthread_join(tid, &server_res));
+ 	CHECK_FAIL(IS_ERR(server_res));
++>>>>>>> 94c2f50b6125 (selftests/bpf: Fix race in tcp_rtt test):tools/testing/selftests/bpf/prog_tests/tcp_rtt.c
  
  close_server_fd:
  	close(server_fd);
* Unmerged path tools/testing/selftests/bpf/test_tcp_rtt.c
