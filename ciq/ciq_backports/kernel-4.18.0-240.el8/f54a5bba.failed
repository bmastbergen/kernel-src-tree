bpf: Remove unused vairable 'bpf_xdp_link_lops'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author YueHaibing <yuehaibing@huawei.com>
commit f54a5bba120398e4d404e9553e6b92e6822eade0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f54a5bba.failed

kernel/bpf/syscall.c:2263:34: warning: 'bpf_xdp_link_lops' defined but not used [-Wunused-const-variable=]
 static const struct bpf_link_ops bpf_xdp_link_lops;
                                  ^~~~~~~~~~~~~~~~~

commit 70ed506c3bbc ("bpf: Introduce pinnable bpf_link abstraction")
involded this unused variable, remove it.

	Reported-by: Hulk Robot <hulkci@huawei.com>
	Signed-off-by: YueHaibing <yuehaibing@huawei.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
Link: https://lore.kernel.org/bpf/20200326031613.19372-1-yuehaibing@huawei.com
(cherry picked from commit f54a5bba120398e4d404e9553e6b92e6822eade0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/syscall.c
diff --cc kernel/bpf/syscall.c
index b5b79e59cfd4,b2584b25748c..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -1837,46 -2155,278 +1837,83 @@@ free_prog_nouncharge
  
  #define BPF_OBJ_LAST_FIELD file_flags
  
 -static int bpf_obj_pin(const union bpf_attr *attr)
 -{
 -	if (CHECK_ATTR(BPF_OBJ) || attr->file_flags != 0)
 -		return -EINVAL;
 -
 -	return bpf_obj_pin_user(attr->bpf_fd, u64_to_user_ptr(attr->pathname));
 -}
 -
 -static int bpf_obj_get(const union bpf_attr *attr)
 -{
 -	if (CHECK_ATTR(BPF_OBJ) || attr->bpf_fd != 0 ||
 -	    attr->file_flags & ~BPF_OBJ_FLAG_MASK)
 -		return -EINVAL;
 -
 -	return bpf_obj_get_user(u64_to_user_ptr(attr->pathname),
 -				attr->file_flags);
 -}
 -
 -struct bpf_link {
 -	atomic64_t refcnt;
 -	const struct bpf_link_ops *ops;
 -	struct bpf_prog *prog;
 -	struct work_struct work;
 -};
 -
 -void bpf_link_init(struct bpf_link *link, const struct bpf_link_ops *ops,
 -		   struct bpf_prog *prog)
 -{
 -	atomic64_set(&link->refcnt, 1);
 -	link->ops = ops;
 -	link->prog = prog;
 -}
 -
 -/* Clean up bpf_link and corresponding anon_inode file and FD. After
 - * anon_inode is created, bpf_link can't be just kfree()'d due to deferred
 - * anon_inode's release() call. This helper manages marking bpf_link as
 - * defunct, releases anon_inode file and puts reserved FD.
 - */
 -static void bpf_link_cleanup(struct bpf_link *link, struct file *link_file,
 -			     int link_fd)
 -{
 -	link->prog = NULL;
 -	fput(link_file);
 -	put_unused_fd(link_fd);
 -}
 -
 -void bpf_link_inc(struct bpf_link *link)
 -{
 -	atomic64_inc(&link->refcnt);
 -}
 -
 -/* bpf_link_free is guaranteed to be called from process context */
 -static void bpf_link_free(struct bpf_link *link)
 -{
 -	if (link->prog) {
 -		/* detach BPF program, clean up used resources */
 -		link->ops->release(link);
 -		bpf_prog_put(link->prog);
 -	}
 -	/* free bpf_link and its containing memory */
 -	link->ops->dealloc(link);
 -}
 -
 -static void bpf_link_put_deferred(struct work_struct *work)
 -{
 -	struct bpf_link *link = container_of(work, struct bpf_link, work);
 -
 -	bpf_link_free(link);
 -}
 -
 -/* bpf_link_put can be called from atomic context, but ensures that resources
 - * are freed from process context
 - */
 -void bpf_link_put(struct bpf_link *link)
 -{
 -	if (!atomic64_dec_and_test(&link->refcnt))
 -		return;
 -
 -	if (in_atomic()) {
 -		INIT_WORK(&link->work, bpf_link_put_deferred);
 -		schedule_work(&link->work);
 -	} else {
 -		bpf_link_free(link);
 -	}
 -}
 -
 -static int bpf_link_release(struct inode *inode, struct file *filp)
 -{
 -	struct bpf_link *link = filp->private_data;
 -
 -	bpf_link_put(link);
 -	return 0;
 -}
 -
 -#ifdef CONFIG_PROC_FS
 -static const struct bpf_link_ops bpf_raw_tp_lops;
 -static const struct bpf_link_ops bpf_tracing_link_lops;
 -
 -static void bpf_link_show_fdinfo(struct seq_file *m, struct file *filp)
 -{
 -	const struct bpf_link *link = filp->private_data;
 -	const struct bpf_prog *prog = link->prog;
 -	char prog_tag[sizeof(prog->tag) * 2 + 1] = { };
 -	const char *link_type;
 -
 -	if (link->ops == &bpf_raw_tp_lops)
 -		link_type = "raw_tracepoint";
 -	else if (link->ops == &bpf_tracing_link_lops)
 -		link_type = "tracing";
 -	else
 -		link_type = "unknown";
 -
 -	bin2hex(prog_tag, prog->tag, sizeof(prog->tag));
 -	seq_printf(m,
 -		   "link_type:\t%s\n"
 -		   "prog_tag:\t%s\n"
 -		   "prog_id:\t%u\n",
 -		   link_type,
 -		   prog_tag,
 -		   prog->aux->id);
 -}
 -#endif
 -
 -const struct file_operations bpf_link_fops = {
 -#ifdef CONFIG_PROC_FS
 -	.show_fdinfo	= bpf_link_show_fdinfo,
 -#endif
 -	.release	= bpf_link_release,
 -	.read		= bpf_dummy_read,
 -	.write		= bpf_dummy_write,
 -};
 -
 -int bpf_link_new_fd(struct bpf_link *link)
 -{
 -	return anon_inode_getfd("bpf-link", &bpf_link_fops, link, O_CLOEXEC);
 -}
 -
 -/* Similar to bpf_link_new_fd, create anon_inode for given bpf_link, but
 - * instead of immediately installing fd in fdtable, just reserve it and
 - * return. Caller then need to either install it with fd_install(fd, file) or
 - * release with put_unused_fd(fd).
 - * This is useful for cases when bpf_link attachment/detachment are
 - * complicated and expensive operations and should be delayed until all the fd
 - * reservation and anon_inode creation succeeds.
 - */
 -struct file *bpf_link_new_file(struct bpf_link *link, int *reserved_fd)
 -{
 -	struct file *file;
 -	int fd;
 -
 -	fd = get_unused_fd_flags(O_CLOEXEC);
 -	if (fd < 0)
 -		return ERR_PTR(fd);
 -
 -	file = anon_inode_getfile("bpf_link", &bpf_link_fops, link, O_CLOEXEC);
 -	if (IS_ERR(file)) {
 -		put_unused_fd(fd);
 -		return file;
 -	}
 -
 -	*reserved_fd = fd;
 -	return file;
 -}
 -
 -struct bpf_link *bpf_link_get_from_fd(u32 ufd)
 -{
 -	struct fd f = fdget(ufd);
 -	struct bpf_link *link;
 -
 -	if (!f.file)
 -		return ERR_PTR(-EBADF);
 -	if (f.file->f_op != &bpf_link_fops) {
 -		fdput(f);
 -		return ERR_PTR(-EINVAL);
 -	}
 -
 -	link = f.file->private_data;
 -	bpf_link_inc(link);
 -	fdput(f);
 -
 -	return link;
 -}
 -
 -struct bpf_tracing_link {
 -	struct bpf_link link;
 -};
 -
 -static void bpf_tracing_link_release(struct bpf_link *link)
 -{
 -	WARN_ON_ONCE(bpf_trampoline_unlink_prog(link->prog));
 -}
 -
 -static void bpf_tracing_link_dealloc(struct bpf_link *link)
 -{
 -	struct bpf_tracing_link *tr_link =
 -		container_of(link, struct bpf_tracing_link, link);
 -
 -	kfree(tr_link);
 -}
 -
 -static const struct bpf_link_ops bpf_tracing_link_lops = {
 -	.release = bpf_tracing_link_release,
 -	.dealloc = bpf_tracing_link_dealloc,
 -};
 -
 -static int bpf_tracing_prog_attach(struct bpf_prog *prog)
 -{
 -	struct bpf_tracing_link *link;
 -	struct file *link_file;
 -	int link_fd, err;
 -
 -	if (prog->expected_attach_type != BPF_TRACE_FENTRY &&
 -	    prog->expected_attach_type != BPF_TRACE_FEXIT &&
 -	    prog->expected_attach_type != BPF_MODIFY_RETURN &&
 -	    prog->type != BPF_PROG_TYPE_EXT) {
 -		err = -EINVAL;
 -		goto out_put_prog;
 -	}
 -
 -	link = kzalloc(sizeof(*link), GFP_USER);
 -	if (!link) {
 -		err = -ENOMEM;
 -		goto out_put_prog;
 -	}
 -	bpf_link_init(&link->link, &bpf_tracing_link_lops, prog);
 -
 -	link_file = bpf_link_new_file(&link->link, &link_fd);
 -	if (IS_ERR(link_file)) {
 -		kfree(link);
 -		err = PTR_ERR(link_file);
 -		goto out_put_prog;
 -	}
 -
 -	err = bpf_trampoline_link_prog(prog);
 -	if (err) {
 -		bpf_link_cleanup(&link->link, link_file, link_fd);
 -		goto out_put_prog;
 -	}
 +static int bpf_obj_pin(const union bpf_attr *attr)
 +{
 +	if (CHECK_ATTR(BPF_OBJ) || attr->file_flags != 0)
 +		return -EINVAL;
  
 -	fd_install(link_fd, link_file);
 -	return link_fd;
 +	return bpf_obj_pin_user(attr->bpf_fd, u64_to_user_ptr(attr->pathname));
 +}
  
 -out_put_prog:
 -	bpf_prog_put(prog);
 -	return err;
 +static int bpf_obj_get(const union bpf_attr *attr)
 +{
 +	if (CHECK_ATTR(BPF_OBJ) || attr->bpf_fd != 0 ||
 +	    attr->file_flags & ~BPF_OBJ_FLAG_MASK)
 +		return -EINVAL;
 +
 +	return bpf_obj_get_user(u64_to_user_ptr(attr->pathname),
 +				attr->file_flags);
  }
  
 -struct bpf_raw_tp_link {
 -	struct bpf_link link;
 +struct bpf_raw_tracepoint {
  	struct bpf_raw_event_map *btp;
 +	struct bpf_prog *prog;
  };
  
 -static void bpf_raw_tp_link_release(struct bpf_link *link)
 +static int bpf_raw_tracepoint_release(struct inode *inode, struct file *filp)
  {
 -	struct bpf_raw_tp_link *raw_tp =
 -		container_of(link, struct bpf_raw_tp_link, link);
 +	struct bpf_raw_tracepoint *raw_tp = filp->private_data;
  
 -	bpf_probe_unregister(raw_tp->btp, raw_tp->link.prog);
 +	if (raw_tp->prog) {
 +		bpf_probe_unregister(raw_tp->btp, raw_tp->prog);
 +		bpf_prog_put(raw_tp->prog);
 +	}
  	bpf_put_raw_tracepoint(raw_tp->btp);
 +	kfree(raw_tp);
 +	return 0;
  }
  
 -static void bpf_raw_tp_link_dealloc(struct bpf_link *link)
++<<<<<<< HEAD
 +static const struct file_operations bpf_raw_tp_fops = {
 +	.release	= bpf_raw_tracepoint_release,
++=======
++#ifdef CONFIG_PROC_FS
++static const struct bpf_link_ops bpf_raw_tp_lops;
++static const struct bpf_link_ops bpf_tracing_link_lops;
++
++static void bpf_link_show_fdinfo(struct seq_file *m, struct file *filp)
+ {
 -	struct bpf_raw_tp_link *raw_tp =
 -		container_of(link, struct bpf_raw_tp_link, link);
++	const struct bpf_link *link = filp->private_data;
++	const struct bpf_prog *prog = link->prog;
++	char prog_tag[sizeof(prog->tag) * 2 + 1] = { };
++	const char *link_type;
+ 
 -	kfree(raw_tp);
++	if (link->ops == &bpf_raw_tp_lops)
++		link_type = "raw_tracepoint";
++	else if (link->ops == &bpf_tracing_link_lops)
++		link_type = "tracing";
++	else
++		link_type = "unknown";
++
++	bin2hex(prog_tag, prog->tag, sizeof(prog->tag));
++	seq_printf(m,
++		   "link_type:\t%s\n"
++		   "prog_tag:\t%s\n"
++		   "prog_id:\t%u\n",
++		   link_type,
++		   prog_tag,
++		   prog->aux->id);
+ }
++#endif
+ 
 -static const struct bpf_link_ops bpf_raw_tp_lops = {
 -	.release = bpf_raw_tp_link_release,
 -	.dealloc = bpf_raw_tp_link_dealloc,
++const struct file_operations bpf_link_fops = {
++#ifdef CONFIG_PROC_FS
++	.show_fdinfo	= bpf_link_show_fdinfo,
++#endif
++	.release	= bpf_link_release,
++>>>>>>> f54a5bba1203 (bpf: Remove unused vairable 'bpf_xdp_link_lops')
 +	.read		= bpf_dummy_read,
 +	.write		= bpf_dummy_write,
  };
  
  #define BPF_RAW_TRACEPOINT_OPEN_LAST_FIELD raw_tracepoint.prog_fd
* Unmerged path kernel/bpf/syscall.c
