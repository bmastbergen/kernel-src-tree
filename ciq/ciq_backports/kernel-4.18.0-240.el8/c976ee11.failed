libperf: Move 'nr_mmaps' from 'struct evlist' to 'struct perf_evlist'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit c976ee11a0e1b3ba5e63e734dbf4b19154e39fab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c976ee11.failed

Moving 'nr_mmaps' from 'struct evlist' to 'struct perf_evlist', it will
be used in following patches.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lore.kernel.org/lkml/20190913132355.21634-21-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit c976ee11a0e1b3ba5e63e734dbf4b19154e39fab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-record.c
#	tools/perf/lib/include/internal/evlist.h
#	tools/perf/tests/backward-ring-buffer.c
#	tools/perf/util/evlist.c
#	tools/perf/util/python.c
diff --cc tools/perf/builtin-record.c
index de0619148499,8577bf33a556..000000000000
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@@ -353,10 -357,10 +353,15 @@@ static void record__aio_mmap_read_sync(
  	if (!record__aio_enabled(rec))
  		return;
  
++<<<<<<< HEAD
 +	for (i = 0; i < evlist->nr_mmaps; i++) {
 +		struct perf_mmap *map = &maps[i];
++=======
+ 	for (i = 0; i < evlist->core.nr_mmaps; i++) {
+ 		struct mmap *map = &maps[i];
++>>>>>>> c976ee11a0e1 (libperf: Move 'nr_mmaps' from 'struct evlist' to 'struct perf_evlist')
  
 -		if (map->core.base)
 +		if (map->base)
  			record__aio_sync(map, true);
  	}
  }
@@@ -599,8 -603,8 +604,13 @@@ static int record__auxtrace_read_snapsh
  	int i;
  	int rc = 0;
  
++<<<<<<< HEAD
 +	for (i = 0; i < rec->evlist->nr_mmaps; i++) {
 +		struct perf_mmap *map = &rec->evlist->mmap[i];
++=======
+ 	for (i = 0; i < rec->evlist->core.nr_mmaps; i++) {
+ 		struct mmap *map = &rec->evlist->mmap[i];
++>>>>>>> c976ee11a0e1 (libperf: Move 'nr_mmaps' from 'struct evlist' to 'struct perf_evlist')
  
  		if (!map->auxtrace_mmap.base)
  			continue;
@@@ -962,15 -966,15 +972,15 @@@ static int record__mmap_read_evlist(str
  	if (record__aio_enabled(rec))
  		off = record__aio_get_pos(trace_fd);
  
- 	for (i = 0; i < evlist->nr_mmaps; i++) {
+ 	for (i = 0; i < evlist->core.nr_mmaps; i++) {
  		u64 flush = 0;
 -		struct mmap *map = &maps[i];
 +		struct perf_mmap *map = &maps[i];
  
 -		if (map->core.base) {
 +		if (map->base) {
  			record__adjust_affinity(rec, map);
  			if (synch) {
 -				flush = map->core.flush;
 -				map->core.flush = 1;
 +				flush = map->flush;
 +				map->flush = 1;
  			}
  			if (!record__aio_enabled(rec)) {
  				if (perf_mmap__push(map, rec, record__pushfn) < 0) {
diff --cc tools/perf/tests/backward-ring-buffer.c
index 1a9c3becf5ff,338cd9faa835..000000000000
--- a/tools/perf/tests/backward-ring-buffer.c
+++ b/tools/perf/tests/backward-ring-buffer.c
@@@ -30,8 -33,8 +30,13 @@@ static int count_samples(struct perf_ev
  {
  	int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < evlist->nr_mmaps; i++) {
 +		struct perf_mmap *map = &evlist->overwrite_mmap[i];
++=======
+ 	for (i = 0; i < evlist->core.nr_mmaps; i++) {
+ 		struct mmap *map = &evlist->overwrite_mmap[i];
++>>>>>>> c976ee11a0e1 (libperf: Move 'nr_mmaps' from 'struct evlist' to 'struct perf_evlist')
  		union perf_event *event;
  
  		perf_mmap__read_init(map);
diff --cc tools/perf/util/evlist.c
index 29a998d183ce,d147834fbe60..000000000000
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@@ -673,8 -651,8 +673,13 @@@ static int perf_evlist__set_paused(stru
  	if (!evlist->overwrite_mmap)
  		return 0;
  
++<<<<<<< HEAD
 +	for (i = 0; i < evlist->nr_mmaps; i++) {
 +		int fd = evlist->overwrite_mmap[i].fd;
++=======
+ 	for (i = 0; i < evlist->core.nr_mmaps; i++) {
+ 		int fd = evlist->overwrite_mmap[i].core.fd;
++>>>>>>> c976ee11a0e1 (libperf: Move 'nr_mmaps' from 'struct evlist' to 'struct perf_evlist')
  		int err;
  
  		if (fd < 0)
@@@ -716,22 -694,22 +721,35 @@@ void perf_evlist__munmap(struct perf_ev
  	zfree(&evlist->overwrite_mmap);
  }
  
 -static struct mmap *evlist__alloc_mmap(struct evlist *evlist,
 -				       bool overwrite)
 +static struct perf_mmap *perf_evlist__alloc_mmap(struct perf_evlist *evlist,
 +						 bool overwrite)
  {
  	int i;
 -	struct mmap *map;
 +	struct perf_mmap *map;
 +
++<<<<<<< HEAD
 +	evlist->nr_mmaps = cpu_map__nr(evlist->cpus);
 +	if (cpu_map__empty(evlist->cpus))
 +		evlist->nr_mmaps = thread_map__nr(evlist->threads);
 +	map = zalloc(evlist->nr_mmaps * sizeof(struct perf_mmap));
 +	if (!map)
 +		return NULL;
  
 +	for (i = 0; i < evlist->nr_mmaps; i++) {
 +		map[i].fd = -1;
 +		map[i].overwrite = overwrite;
++=======
+ 	evlist->core.nr_mmaps = perf_cpu_map__nr(evlist->core.cpus);
+ 	if (perf_cpu_map__empty(evlist->core.cpus))
+ 		evlist->core.nr_mmaps = perf_thread_map__nr(evlist->core.threads);
+ 	map = zalloc(evlist->core.nr_mmaps * sizeof(struct mmap));
+ 	if (!map)
+ 		return NULL;
+ 
+ 	for (i = 0; i < evlist->core.nr_mmaps; i++) {
+ 		map[i].core.fd = -1;
+ 		map[i].core.overwrite = overwrite;
++>>>>>>> c976ee11a0e1 (libperf: Move 'nr_mmaps' from 'struct evlist' to 'struct perf_evlist')
  		/*
  		 * When the perf_mmap() call is made we grab one refcount, plus
  		 * one extra to let perf_mmap__consume() get the last
@@@ -1892,8 -1847,8 +1910,13 @@@ static void *perf_evlist__poll_thread(v
  		if (!draining)
  			perf_evlist__poll(evlist, 1000);
  
++<<<<<<< HEAD
 +		for (i = 0; i < evlist->nr_mmaps; i++) {
 +			struct perf_mmap *map = &evlist->mmap[i];
++=======
+ 		for (i = 0; i < evlist->core.nr_mmaps; i++) {
+ 			struct mmap *map = &evlist->mmap[i];
++>>>>>>> c976ee11a0e1 (libperf: Move 'nr_mmaps' from 'struct evlist' to 'struct perf_evlist')
  			union perf_event *event;
  
  			if (perf_mmap__read_init(map))
diff --cc tools/perf/util/python.c
index 9c3b43665909,62144b97e17b..000000000000
--- a/tools/perf/util/python.c
+++ b/tools/perf/util/python.c
@@@ -983,10 -988,10 +983,15 @@@ static struct perf_mmap *get_md(struct 
  {
  	int i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < evlist->nr_mmaps; i++) {
 +		struct perf_mmap *md = &evlist->mmap[i];
++=======
+ 	for (i = 0; i < evlist->core.nr_mmaps; i++) {
+ 		struct mmap *md = &evlist->mmap[i];
++>>>>>>> c976ee11a0e1 (libperf: Move 'nr_mmaps' from 'struct evlist' to 'struct perf_evlist')
  
 -		if (md->core.cpu == cpu)
 +		if (md->cpu == cpu)
  			return md;
  	}
  
* Unmerged path tools/perf/lib/include/internal/evlist.h
diff --git a/tools/perf/arch/arm/util/cs-etm.c b/tools/perf/arch/arm/util/cs-etm.c
index 4208974c24f8..40fa601d7fef 100644
--- a/tools/perf/arch/arm/util/cs-etm.c
+++ b/tools/perf/arch/arm/util/cs-etm.c
@@ -645,7 +645,7 @@ static int cs_etm_info_fill(struct auxtrace_record *itr,
 	if (priv_size != cs_etm_info_priv_size(itr, session->evlist))
 		return -EINVAL;
 
-	if (!session->evlist->nr_mmaps)
+	if (!session->evlist->core.nr_mmaps)
 		return -EINVAL;
 
 	/* If the cpu_map is empty all online CPUs are involved */
diff --git a/tools/perf/arch/arm64/util/arm-spe.c b/tools/perf/arch/arm64/util/arm-spe.c
index 2c009aa74633..a0988ccc90a0 100644
--- a/tools/perf/arch/arm64/util/arm-spe.c
+++ b/tools/perf/arch/arm64/util/arm-spe.c
@@ -49,7 +49,7 @@ static int arm_spe_info_fill(struct auxtrace_record *itr,
 	if (priv_size != ARM_SPE_AUXTRACE_PRIV_SIZE)
 		return -EINVAL;
 
-	if (!session->evlist->nr_mmaps)
+	if (!session->evlist->core.nr_mmaps)
 		return -EINVAL;
 
 	auxtrace_info->type = PERF_AUXTRACE_ARM_SPE;
diff --git a/tools/perf/arch/x86/tests/perf-time-to-tsc.c b/tools/perf/arch/x86/tests/perf-time-to-tsc.c
index 7a7721604b86..fd440d71abb9 100644
--- a/tools/perf/arch/x86/tests/perf-time-to-tsc.c
+++ b/tools/perf/arch/x86/tests/perf-time-to-tsc.c
@@ -109,7 +109,7 @@ int test__perf_time_to_tsc(struct test *test __maybe_unused, int subtest __maybe
 
 	perf_evlist__disable(evlist);
 
-	for (i = 0; i < evlist->nr_mmaps; i++) {
+	for (i = 0; i < evlist->core.nr_mmaps; i++) {
 		md = &evlist->mmap[i];
 		if (perf_mmap__read_init(md) < 0)
 			continue;
diff --git a/tools/perf/arch/x86/util/intel-bts.c b/tools/perf/arch/x86/util/intel-bts.c
index 4cbd3d775c19..1e6eb50e3a93 100644
--- a/tools/perf/arch/x86/util/intel-bts.c
+++ b/tools/perf/arch/x86/util/intel-bts.c
@@ -80,7 +80,7 @@ static int intel_bts_info_fill(struct auxtrace_record *itr,
 	if (priv_size != INTEL_BTS_AUXTRACE_PRIV_SIZE)
 		return -EINVAL;
 
-	if (!session->evlist->nr_mmaps)
+	if (!session->evlist->core.nr_mmaps)
 		return -EINVAL;
 
 	pc = session->evlist->mmap[0].base;
diff --git a/tools/perf/arch/x86/util/intel-pt.c b/tools/perf/arch/x86/util/intel-pt.c
index 3a851647e6f4..4cd3fec2f260 100644
--- a/tools/perf/arch/x86/util/intel-pt.c
+++ b/tools/perf/arch/x86/util/intel-pt.c
@@ -358,7 +358,7 @@ static int intel_pt_info_fill(struct auxtrace_record *itr,
 	filter = intel_pt_find_filter(session->evlist, ptr->intel_pt_pmu);
 	filter_str_len = filter ? strlen(filter) : 0;
 
-	if (!session->evlist->nr_mmaps)
+	if (!session->evlist->core.nr_mmaps)
 		return -EINVAL;
 
 	pc = session->evlist->mmap[0].base;
diff --git a/tools/perf/builtin-kvm.c b/tools/perf/builtin-kvm.c
index d30bd54b42ac..4204c8844226 100644
--- a/tools/perf/builtin-kvm.c
+++ b/tools/perf/builtin-kvm.c
@@ -797,7 +797,7 @@ static int perf_kvm__mmap_read(struct perf_kvm_stat *kvm)
 	s64 n, ntotal = 0;
 	u64 flush_time = ULLONG_MAX, mmap_time;
 
-	for (i = 0; i < kvm->evlist->nr_mmaps; i++) {
+	for (i = 0; i < kvm->evlist->core.nr_mmaps; i++) {
 		n = perf_kvm__mmap_read_idx(kvm, i, &mmap_time);
 		if (n < 0)
 			return -1;
* Unmerged path tools/perf/builtin-record.c
diff --git a/tools/perf/builtin-top.c b/tools/perf/builtin-top.c
index 95aec2602043..527c25b7d4a5 100644
--- a/tools/perf/builtin-top.c
+++ b/tools/perf/builtin-top.c
@@ -908,7 +908,7 @@ static void perf_top__mmap_read(struct perf_top *top)
 	if (overwrite)
 		perf_evlist__toggle_bkw_mmap(evlist, BKW_MMAP_DATA_PENDING);
 
-	for (i = 0; i < top->evlist->nr_mmaps; i++)
+	for (i = 0; i < top->evlist->core.nr_mmaps; i++)
 		perf_top__mmap_read_idx(top, i);
 
 	if (overwrite) {
diff --git a/tools/perf/builtin-trace.c b/tools/perf/builtin-trace.c
index 4b81b4c2c4c2..0d73e7dc03c2 100644
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@ -3435,7 +3435,7 @@ static int trace__run(struct trace *trace, int argc, const char **argv)
 again:
 	before = trace->nr_events;
 
-	for (i = 0; i < evlist->nr_mmaps; i++) {
+	for (i = 0; i < evlist->core.nr_mmaps; i++) {
 		union perf_event *event;
 		struct perf_mmap *md;
 
* Unmerged path tools/perf/lib/include/internal/evlist.h
* Unmerged path tools/perf/tests/backward-ring-buffer.c
diff --git a/tools/perf/tests/bpf.c b/tools/perf/tests/bpf.c
index c9e4cdc4c9c8..b0ab8252fbb5 100644
--- a/tools/perf/tests/bpf.c
+++ b/tools/perf/tests/bpf.c
@@ -175,7 +175,7 @@ static int do_test(struct bpf_object *obj, int (*func)(void),
 	(*func)();
 	perf_evlist__disable(evlist);
 
-	for (i = 0; i < evlist->nr_mmaps; i++) {
+	for (i = 0; i < evlist->core.nr_mmaps; i++) {
 		union perf_event *event;
 		struct perf_mmap *md;
 
diff --git a/tools/perf/tests/code-reading.c b/tools/perf/tests/code-reading.c
index aa6df122b175..9c2eb71a2991 100644
--- a/tools/perf/tests/code-reading.c
+++ b/tools/perf/tests/code-reading.c
@@ -415,7 +415,7 @@ static int process_events(struct machine *machine, struct perf_evlist *evlist,
 	struct perf_mmap *md;
 	int i, ret;
 
-	for (i = 0; i < evlist->nr_mmaps; i++) {
+	for (i = 0; i < evlist->core.nr_mmaps; i++) {
 		md = &evlist->mmap[i];
 		if (perf_mmap__read_init(md) < 0)
 			continue;
diff --git a/tools/perf/tests/keep-tracking.c b/tools/perf/tests/keep-tracking.c
index 17c46f3e6f1e..665ccc5631ce 100644
--- a/tools/perf/tests/keep-tracking.c
+++ b/tools/perf/tests/keep-tracking.c
@@ -31,7 +31,7 @@ static int find_comm(struct perf_evlist *evlist, const char *comm)
 	int i, found;
 
 	found = 0;
-	for (i = 0; i < evlist->nr_mmaps; i++) {
+	for (i = 0; i < evlist->core.nr_mmaps; i++) {
 		md = &evlist->mmap[i];
 		if (perf_mmap__read_init(md) < 0)
 			continue;
diff --git a/tools/perf/tests/openat-syscall-tp-fields.c b/tools/perf/tests/openat-syscall-tp-fields.c
index 344dc3ac2469..382fdae748ff 100644
--- a/tools/perf/tests/openat-syscall-tp-fields.c
+++ b/tools/perf/tests/openat-syscall-tp-fields.c
@@ -84,7 +84,7 @@ int test__syscall_openat_tp_fields(struct test *test __maybe_unused, int subtest
 	while (1) {
 		int before = nr_events;
 
-		for (i = 0; i < evlist->nr_mmaps; i++) {
+		for (i = 0; i < evlist->core.nr_mmaps; i++) {
 			union perf_event *event;
 			struct perf_mmap *md;
 
diff --git a/tools/perf/tests/perf-record.c b/tools/perf/tests/perf-record.c
index 07f6bd8ed719..3ec343516339 100644
--- a/tools/perf/tests/perf-record.c
+++ b/tools/perf/tests/perf-record.c
@@ -163,7 +163,7 @@ int test__PERF_RECORD(struct test *test __maybe_unused, int subtest __maybe_unus
 	while (1) {
 		int before = total_events;
 
-		for (i = 0; i < evlist->nr_mmaps; i++) {
+		for (i = 0; i < evlist->core.nr_mmaps; i++) {
 			union perf_event *event;
 			struct perf_mmap *md;
 
diff --git a/tools/perf/tests/switch-tracking.c b/tools/perf/tests/switch-tracking.c
index 6cdab5f4812a..288828642639 100644
--- a/tools/perf/tests/switch-tracking.c
+++ b/tools/perf/tests/switch-tracking.c
@@ -262,7 +262,7 @@ static int process_events(struct perf_evlist *evlist,
 	struct perf_mmap *md;
 	int i, ret;
 
-	for (i = 0; i < evlist->nr_mmaps; i++) {
+	for (i = 0; i < evlist->core.nr_mmaps; i++) {
 		md = &evlist->mmap[i];
 		if (perf_mmap__read_init(md) < 0)
 			continue;
* Unmerged path tools/perf/util/evlist.c
diff --git a/tools/perf/util/evlist.h b/tools/perf/util/evlist.h
index 49354fe24d5f..2f3db2588322 100644
--- a/tools/perf/util/evlist.h
+++ b/tools/perf/util/evlist.h
@@ -29,7 +29,6 @@ struct perf_evlist {
 	struct hlist_head heads[PERF_EVLIST__HLIST_SIZE];
 	int		 nr_entries;
 	int		 nr_groups;
-	int		 nr_mmaps;
 	bool		 enabled;
 	bool		 has_user_cpus;
 	size_t		 mmap_len;
* Unmerged path tools/perf/util/python.c
