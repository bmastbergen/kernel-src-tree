drm/i915: Implement a better i945gm vblank irq vs. C-states workaround

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 7d423af9bfb172c3802cc1ca6591ac608c26a311
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7d423af9.failed

The current "disable C3+" workaround for the delayed vblank
irqs on i945gm no longer works. I'm not sure what changed, but
now I need to also disable C2. I also got my hands on a i915gm
machine that suffers from the same issue.

After some furious poking of registers I managed to find a
better workaround: The "Do not Turn off Core Render Clock in C
states" bit. With that I no longer have to disable any C-states,
and as a nice bonus the power cost is only ~1/4 of the
"disable C3+" method (which mind you doesn't even work anymore,
and so would have an even higher power cost if we made it work
by also disabling C2).

So let's throw out all the cpuidle/qos crap and just toggle
the magic bit as needed. And we extend the workaround to cover
i915gm as well.

	Cc: Chris Wilson <chris@chris-wilson.co.uk>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20191003140231.24408-1-ville.syrjala@linux.intel.com
	Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
(cherry picked from commit 7d423af9bfb172c3802cc1ca6591ac608c26a311)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display.c
#	drivers/gpu/drm/i915/i915_drv.h
#	drivers/gpu/drm/i915/i915_irq.c
#	drivers/gpu/drm/i915/i915_irq.h
diff --cc drivers/gpu/drm/i915/display/intel_display.c
index 5c8c11deb857,5acc39f32d0c..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@@ -14931,8 -15017,76 +14931,78 @@@ static void intel_crtc_init_scalers(str
  	scaler_state->scaler_id = -1;
  }
  
++<<<<<<< HEAD
++=======
+ #define INTEL_CRTC_FUNCS \
+ 	.gamma_set = drm_atomic_helper_legacy_gamma_set, \
+ 	.set_config = drm_atomic_helper_set_config, \
+ 	.destroy = intel_crtc_destroy, \
+ 	.page_flip = drm_atomic_helper_page_flip, \
+ 	.atomic_duplicate_state = intel_crtc_duplicate_state, \
+ 	.atomic_destroy_state = intel_crtc_destroy_state, \
+ 	.set_crc_source = intel_crtc_set_crc_source, \
+ 	.verify_crc_source = intel_crtc_verify_crc_source, \
+ 	.get_crc_sources = intel_crtc_get_crc_sources
+ 
+ static const struct drm_crtc_funcs bdw_crtc_funcs = {
+ 	INTEL_CRTC_FUNCS,
+ 
+ 	.get_vblank_counter = g4x_get_vblank_counter,
+ 	.enable_vblank = bdw_enable_vblank,
+ 	.disable_vblank = bdw_disable_vblank,
+ };
+ 
+ static const struct drm_crtc_funcs ilk_crtc_funcs = {
+ 	INTEL_CRTC_FUNCS,
+ 
+ 	.get_vblank_counter = g4x_get_vblank_counter,
+ 	.enable_vblank = ilk_enable_vblank,
+ 	.disable_vblank = ilk_disable_vblank,
+ };
+ 
+ static const struct drm_crtc_funcs g4x_crtc_funcs = {
+ 	INTEL_CRTC_FUNCS,
+ 
+ 	.get_vblank_counter = g4x_get_vblank_counter,
+ 	.enable_vblank = i965_enable_vblank,
+ 	.disable_vblank = i965_disable_vblank,
+ };
+ 
+ static const struct drm_crtc_funcs i965_crtc_funcs = {
+ 	INTEL_CRTC_FUNCS,
+ 
+ 	.get_vblank_counter = i915_get_vblank_counter,
+ 	.enable_vblank = i965_enable_vblank,
+ 	.disable_vblank = i965_disable_vblank,
+ };
+ 
+ static const struct drm_crtc_funcs i915gm_crtc_funcs = {
+ 	INTEL_CRTC_FUNCS,
+ 
+ 	.get_vblank_counter = i915_get_vblank_counter,
+ 	.enable_vblank = i915gm_enable_vblank,
+ 	.disable_vblank = i915gm_disable_vblank,
+ };
+ 
+ static const struct drm_crtc_funcs i915_crtc_funcs = {
+ 	INTEL_CRTC_FUNCS,
+ 
+ 	.get_vblank_counter = i915_get_vblank_counter,
+ 	.enable_vblank = i8xx_enable_vblank,
+ 	.disable_vblank = i8xx_disable_vblank,
+ };
+ 
+ static const struct drm_crtc_funcs i8xx_crtc_funcs = {
+ 	INTEL_CRTC_FUNCS,
+ 
+ 	/* no hw vblank counter */
+ 	.enable_vblank = i8xx_enable_vblank,
+ 	.disable_vblank = i8xx_disable_vblank,
+ };
+ 
++>>>>>>> 7d423af9bfb1 (drm/i915: Implement a better i945gm vblank irq vs. C-states workaround)
  static int intel_crtc_init(struct drm_i915_private *dev_priv, enum pipe pipe)
  {
 -	const struct drm_crtc_funcs *funcs;
  	struct intel_crtc *intel_crtc;
  	struct intel_crtc_state *crtc_state = NULL;
  	struct intel_plane *primary = NULL;
@@@ -14976,10 -15130,28 +15046,32 @@@
  	}
  	intel_crtc->plane_ids_mask |= BIT(cursor->id);
  
++<<<<<<< HEAD
++=======
+ 	if (HAS_GMCH(dev_priv)) {
+ 		if (IS_CHERRYVIEW(dev_priv) ||
+ 		    IS_VALLEYVIEW(dev_priv) || IS_G4X(dev_priv))
+ 			funcs = &g4x_crtc_funcs;
+ 		else if (IS_GEN(dev_priv, 4))
+ 			funcs = &i965_crtc_funcs;
+ 		else if (IS_I945GM(dev_priv) || IS_I915GM(dev_priv))
+ 			funcs = &i915gm_crtc_funcs;
+ 		else if (IS_GEN(dev_priv, 3))
+ 			funcs = &i915_crtc_funcs;
+ 		else
+ 			funcs = &i8xx_crtc_funcs;
+ 	} else {
+ 		if (INTEL_GEN(dev_priv) >= 8)
+ 			funcs = &bdw_crtc_funcs;
+ 		else
+ 			funcs = &ilk_crtc_funcs;
+ 	}
+ 
++>>>>>>> 7d423af9bfb1 (drm/i915: Implement a better i945gm vblank irq vs. C-states workaround)
  	ret = drm_crtc_init_with_planes(&dev_priv->drm, &intel_crtc->base,
  					&primary->base, &cursor->base,
 -					funcs, "pipe %c", pipe_name(pipe));
 +					&intel_crtc_funcs,
 +					"pipe %c", pipe_name(pipe));
  	if (ret)
  		goto fail;
  
diff --cc drivers/gpu/drm/i915/i915_drv.h
index 6f70e09e3726,cde4c7fb5570..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@@ -1864,34 -1692,17 +1864,39 @@@ struct drm_i915_private 
  	struct {
  		struct notifier_block pm_notifier;
  
 -		struct i915_gem_contexts {
 -			spinlock_t lock; /* locks list */
 -			struct list_head list;
 +		/**
 +		 * We leave the user IRQ off as much as possible,
 +		 * but this means that requests will finish and never
 +		 * be retired once the system goes idle. Set a timer to
 +		 * fire periodically while the ring is running. When it
 +		 * fires, go retire requests.
 +		 */
 +		struct delayed_work retire_work;
  
 -			struct llist_head free_list;
 -			struct work_struct free_work;
 -		} contexts;
 +		/**
 +		 * When we detect an idle GPU, we want to turn on
 +		 * powersaving features. So once we see that there
 +		 * are no more requests outstanding and no more
 +		 * arrive within a small period of time, we fire
 +		 * off the idle_work.
 +		 */
 +		struct work_struct idle_work;
  	} gem;
  
++<<<<<<< HEAD
 +	u8 pch_ssc_use;
 +
 +	/* For i945gm vblank irq vs. C3 workaround */
 +	struct {
 +		struct work_struct work;
 +		struct pm_qos_request pm_qos;
 +		u8 c3_disable_latency;
 +		u8 enabled;
 +	} i945gm_vblank;
++=======
+ 	/* For i915gm/i945gm vblank irq workaround */
+ 	u8 vblank_enabled;
++>>>>>>> 7d423af9bfb1 (drm/i915: Implement a better i945gm vblank irq vs. C-states workaround)
  
  	/* perform PHY state sanity checks? */
  	bool chv_phy_assert[2];
diff --cc drivers/gpu/drm/i915/i915_irq.c
index b2e27b5b0df9,f2371b6083c6..000000000000
--- a/drivers/gpu/drm/i915/i915_irq.c
+++ b/drivers/gpu/drm/i915/i915_irq.c
@@@ -3255,19 -2909,26 +3254,29 @@@ static int i8xx_enable_vblank(struct dr
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int i945gm_enable_vblank(struct drm_device *dev, unsigned int pipe)
++=======
+ int i915gm_enable_vblank(struct drm_crtc *crtc)
++>>>>>>> 7d423af9bfb1 (drm/i915: Implement a better i945gm vblank irq vs. C-states workaround)
  {
 -	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 +	struct drm_i915_private *dev_priv = to_i915(dev);
  
- 	if (dev_priv->i945gm_vblank.enabled++ == 0)
- 		schedule_work(&dev_priv->i945gm_vblank.work);
+ 	/*
+ 	 * Vblank interrupts fail to wake the device up from C2+.
+ 	 * Disabling render clock gating during C-states avoids
+ 	 * the problem. There is a small power cost so we do this
+ 	 * only when vblank interrupts are actually enabled.
+ 	 */
+ 	if (dev_priv->vblank_enabled++ == 0)
+ 		I915_WRITE(SCPD0, _MASKED_BIT_ENABLE(CSTATE_RENDER_CLOCK_GATE_DISABLE));
  
 -	return i8xx_enable_vblank(crtc);
 +	return i8xx_enable_vblank(dev, pipe);
  }
  
 -int i965_enable_vblank(struct drm_crtc *crtc)
 +static int i965_enable_vblank(struct drm_device *dev, unsigned int pipe)
  {
 -	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 -	enum pipe pipe = to_intel_crtc(crtc)->pipe;
 +	struct drm_i915_private *dev_priv = to_i915(dev);
  	unsigned long irqflags;
  
  	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
@@@ -3329,19 -2993,20 +3338,23 @@@ static void i8xx_disable_vblank(struct 
  	spin_unlock_irqrestore(&dev_priv->irq_lock, irqflags);
  }
  
++<<<<<<< HEAD
 +static void i945gm_disable_vblank(struct drm_device *dev, unsigned int pipe)
++=======
+ void i915gm_disable_vblank(struct drm_crtc *crtc)
++>>>>>>> 7d423af9bfb1 (drm/i915: Implement a better i945gm vblank irq vs. C-states workaround)
  {
 -	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 +	struct drm_i915_private *dev_priv = to_i915(dev);
  
 -	i8xx_disable_vblank(crtc);
 +	i8xx_disable_vblank(dev, pipe);
  
- 	if (--dev_priv->i945gm_vblank.enabled == 0)
- 		schedule_work(&dev_priv->i945gm_vblank.work);
+ 	if (--dev_priv->vblank_enabled == 0)
+ 		I915_WRITE(SCPD0, _MASKED_BIT_DISABLE(CSTATE_RENDER_CLOCK_GATE_DISABLE));
  }
  
 -void i965_disable_vblank(struct drm_crtc *crtc)
 +static void i965_disable_vblank(struct drm_device *dev, unsigned int pipe)
  {
 -	struct drm_i915_private *dev_priv = to_i915(crtc->dev);
 -	enum pipe pipe = to_intel_crtc(crtc)->pipe;
 +	struct drm_i915_private *dev_priv = to_i915(dev);
  	unsigned long irqflags;
  
  	spin_lock_irqsave(&dev_priv->irq_lock, irqflags);
diff --cc drivers/gpu/drm/i915/i915_irq.h
index cb25dd213308,19a3bc019535..000000000000
--- a/drivers/gpu/drm/i915/i915_irq.h
+++ b/drivers/gpu/drm/i915/i915_irq.h
@@@ -107,11 -106,72 +107,81 @@@ void gen8_irq_power_well_post_enable(st
  				     u8 pipe_mask);
  void gen8_irq_power_well_pre_disable(struct drm_i915_private *dev_priv,
  				     u8 pipe_mask);
++<<<<<<< HEAD
 +void gen9_reset_guc_interrupts(struct drm_i915_private *dev_priv);
 +void gen9_enable_guc_interrupts(struct drm_i915_private *dev_priv);
 +void gen9_disable_guc_interrupts(struct drm_i915_private *dev_priv);
 +void gen11_reset_guc_interrupts(struct drm_i915_private *i915);
 +void gen11_enable_guc_interrupts(struct drm_i915_private *i915);
 +void gen11_disable_guc_interrupts(struct drm_i915_private *i915);
++=======
+ void gen9_reset_guc_interrupts(struct intel_guc *guc);
+ void gen9_enable_guc_interrupts(struct intel_guc *guc);
+ void gen9_disable_guc_interrupts(struct intel_guc *guc);
+ void gen11_reset_guc_interrupts(struct intel_guc *guc);
+ void gen11_enable_guc_interrupts(struct intel_guc *guc);
+ void gen11_disable_guc_interrupts(struct intel_guc *guc);
+ 
+ bool i915_get_crtc_scanoutpos(struct drm_device *dev, unsigned int pipe,
+ 			      bool in_vblank_irq, int *vpos, int *hpos,
+ 			      ktime_t *stime, ktime_t *etime,
+ 			      const struct drm_display_mode *mode);
+ 
+ u32 i915_get_vblank_counter(struct drm_crtc *crtc);
+ u32 g4x_get_vblank_counter(struct drm_crtc *crtc);
+ 
+ int i8xx_enable_vblank(struct drm_crtc *crtc);
+ int i915gm_enable_vblank(struct drm_crtc *crtc);
+ int i965_enable_vblank(struct drm_crtc *crtc);
+ int ilk_enable_vblank(struct drm_crtc *crtc);
+ int bdw_enable_vblank(struct drm_crtc *crtc);
+ void i8xx_disable_vblank(struct drm_crtc *crtc);
+ void i915gm_disable_vblank(struct drm_crtc *crtc);
+ void i965_disable_vblank(struct drm_crtc *crtc);
+ void ilk_disable_vblank(struct drm_crtc *crtc);
+ void bdw_disable_vblank(struct drm_crtc *crtc);
+ 
+ void gen2_irq_reset(struct intel_uncore *uncore);
+ void gen3_irq_reset(struct intel_uncore *uncore, i915_reg_t imr,
+ 		    i915_reg_t iir, i915_reg_t ier);
+ 
+ void gen2_irq_init(struct intel_uncore *uncore,
+ 		   u32 imr_val, u32 ier_val);
+ void gen3_irq_init(struct intel_uncore *uncore,
+ 		   i915_reg_t imr, u32 imr_val,
+ 		   i915_reg_t ier, u32 ier_val,
+ 		   i915_reg_t iir);
+ 
+ #define GEN8_IRQ_RESET_NDX(uncore, type, which) \
+ ({ \
+ 	unsigned int which_ = which; \
+ 	gen3_irq_reset((uncore), GEN8_##type##_IMR(which_), \
+ 		       GEN8_##type##_IIR(which_), GEN8_##type##_IER(which_)); \
+ })
+ 
+ #define GEN3_IRQ_RESET(uncore, type) \
+ 	gen3_irq_reset((uncore), type##IMR, type##IIR, type##IER)
+ 
+ #define GEN2_IRQ_RESET(uncore) \
+ 	gen2_irq_reset(uncore)
+ 
+ #define GEN8_IRQ_INIT_NDX(uncore, type, which, imr_val, ier_val) \
+ ({ \
+ 	unsigned int which_ = which; \
+ 	gen3_irq_init((uncore), \
+ 		      GEN8_##type##_IMR(which_), imr_val, \
+ 		      GEN8_##type##_IER(which_), ier_val, \
+ 		      GEN8_##type##_IIR(which_)); \
+ })
+ 
+ #define GEN3_IRQ_INIT(uncore, type, imr_val, ier_val) \
+ 	gen3_irq_init((uncore), \
+ 		      type##IMR, imr_val, \
+ 		      type##IER, ier_val, \
+ 		      type##IIR)
+ 
+ #define GEN2_IRQ_INIT(uncore, imr_val, ier_val) \
+ 	gen2_irq_init((uncore), imr_val, ier_val)
++>>>>>>> 7d423af9bfb1 (drm/i915: Implement a better i945gm vblank irq vs. C-states workaround)
  
  #endif /* __I915_IRQ_H__ */
* Unmerged path drivers/gpu/drm/i915/display/intel_display.c
* Unmerged path drivers/gpu/drm/i915/i915_drv.h
* Unmerged path drivers/gpu/drm/i915/i915_irq.c
* Unmerged path drivers/gpu/drm/i915/i915_irq.h
diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h
index 849d8b8f5673..386f1efccc39 100644
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@ -2732,6 +2732,7 @@ enum i915_power_well_id {
 #define VLV_GU_CTL0	_MMIO(VLV_DISPLAY_BASE + 0x2030)
 #define VLV_GU_CTL1	_MMIO(VLV_DISPLAY_BASE + 0x2034)
 #define SCPD0		_MMIO(0x209c) /* 915+ only */
+#define  CSTATE_RENDER_CLOCK_GATE_DISABLE	(1 << 5)
 #define GEN2_IER	_MMIO(0x20a0)
 #define GEN2_IIR	_MMIO(0x20a4)
 #define GEN2_IMR	_MMIO(0x20a8)
