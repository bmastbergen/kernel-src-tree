KVM: nVMX: Don't flush TLB on nested VMX transition

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 9805c5f74b8a65da397ec6b70734e44f1f191c0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9805c5f7.failed

Unconditionally skip the TLB flush triggered when reusing a root for a
nested transition as nested_vmx_transition_tlb_flush() ensures the TLB
is flushed when needed, regardless of whether the MMU can reuse a cached
root (or the last root).

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200320212833.3507-35-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9805c5f74b8a65da397ec6b70734e44f1f191c0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
#	arch/x86/kvm/vmx/nested.c
diff --cc arch/x86/kvm/mmu/mmu.c
index dbd97923dc2c,10fb9e7f1eca..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -5099,7 -5034,7 +5099,11 @@@ void kvm_init_shadow_ept_mmu(struct kvm
  		kvm_calc_shadow_ept_root_page_role(vcpu, accessed_dirty,
  						   execonly, level);
  
++<<<<<<< HEAD
 +	__kvm_mmu_new_cr3(vcpu, new_eptp, new_role.base, false);
++=======
+ 	__kvm_mmu_new_cr3(vcpu, new_eptp, new_role.base, true, true);
++>>>>>>> 9805c5f74b8a (KVM: nVMX: Don't flush TLB on nested VMX transition)
  
  	if (new_role.as_u64 == context->mmu_role.as_u64)
  		return;
diff --cc arch/x86/kvm/vmx/nested.c
index cd775c31a62d,237e2e32a659..000000000000
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@@ -1101,8 -1142,14 +1101,19 @@@ static int nested_vmx_load_cr3(struct k
  		}
  	}
  
++<<<<<<< HEAD
 +	if (!nested_ept)
 +		kvm_mmu_new_cr3(vcpu, cr3, false);
++=======
+ 	/*
+ 	 * Unconditionally skip the TLB flush on fast CR3 switch, all TLB
+ 	 * flushes are handled by nested_vmx_transition_tlb_flush().  See
+ 	 * nested_vmx_transition_mmu_sync for details on skipping the MMU sync.
+ 	 */
+ 	if (!nested_ept)
+ 		kvm_mmu_new_cr3(vcpu, cr3, true,
+ 				!nested_vmx_transition_mmu_sync(vcpu));
++>>>>>>> 9805c5f74b8a (KVM: nVMX: Don't flush TLB on nested VMX transition)
  
  	vcpu->arch.cr3 = cr3;
  	kvm_register_mark_available(vcpu, VCPU_EXREG_CR3);
* Unmerged path arch/x86/kvm/mmu/mmu.c
* Unmerged path arch/x86/kvm/vmx/nested.c
