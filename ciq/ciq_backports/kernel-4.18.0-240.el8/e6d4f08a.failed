intel_idle: Use ACPI _CST on server systems

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit e6d4f08a677654385869ba0c39d7c9ceec47e5c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e6d4f08a.failed

In many cases, especially on server systems, it is desirable to avoid
enabling C-states that have been disabled in the platform firmware
(BIOS) setup, except for C1E.

As a rule, the C-states disabled this way are not listed by ACPI
_CST, so if that is used by intel_idle along with the specific
table of C-states that it has for the given processor, the C-states
disabled through the platform firmware will not be enabled by default
by intel_idle.

Accordingly, set the use_acpi flag (introduced previously) in all
server processor profiles defined in intel_idle (so as to make it use
ACPI _CST to decide which C-states to enable by default) and set
the CPUIDLE_FLAG_ALWAYS_ENABLE flag (also introduced previously)
for C1E in all C-states tables in intel_idle that contain C1 too
(so that C1E is enabled regardless of whether or not it is listed
by ACPI _CST).

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit e6d4f08a677654385869ba0c39d7c9ceec47e5c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/idle/intel_idle.c
diff --cc drivers/idle/intel_idle.c
index 076189997131,1467490adfc3..000000000000
--- a/drivers/idle/intel_idle.c
+++ b/drivers/idle/intel_idle.c
@@@ -1084,19 -1125,19 +1114,29 @@@ static const struct x86_cpu_id intel_id
  	INTEL_CPU_FAM6(ATOM_AIRMONT,		idle_cpu_cht),
  	INTEL_CPU_FAM6(IVYBRIDGE,		idle_cpu_ivb),
  	INTEL_CPU_FAM6(IVYBRIDGE_X,		idle_cpu_ivt),
++<<<<<<< HEAD
 +	INTEL_CPU_FAM6(HASWELL,		idle_cpu_hsw),
 +	INTEL_CPU_FAM6(HASWELL_X,		idle_cpu_hsw),
++=======
+ 	INTEL_CPU_FAM6(HASWELL,			idle_cpu_hsw),
+ 	INTEL_CPU_FAM6(HASWELL_X,		idle_cpu_hsx),
++>>>>>>> e6d4f08a6776 (intel_idle: Use ACPI _CST on server systems)
  	INTEL_CPU_FAM6(HASWELL_L,		idle_cpu_hsw),
  	INTEL_CPU_FAM6(HASWELL_G,		idle_cpu_hsw),
  	INTEL_CPU_FAM6(ATOM_SILVERMONT_D,	idle_cpu_avn),
  	INTEL_CPU_FAM6(BROADWELL,		idle_cpu_bdw),
  	INTEL_CPU_FAM6(BROADWELL_G,		idle_cpu_bdw),
++<<<<<<< HEAD
 +	INTEL_CPU_FAM6(BROADWELL_X,		idle_cpu_bdw),
 +	INTEL_CPU_FAM6(BROADWELL_D,	idle_cpu_bdw),
++=======
+ 	INTEL_CPU_FAM6(BROADWELL_X,		idle_cpu_bdx),
+ 	INTEL_CPU_FAM6(BROADWELL_D,		idle_cpu_bdx),
++>>>>>>> e6d4f08a6776 (intel_idle: Use ACPI _CST on server systems)
  	INTEL_CPU_FAM6(SKYLAKE_L,		idle_cpu_skl),
 -	INTEL_CPU_FAM6(SKYLAKE,			idle_cpu_skl),
 +	INTEL_CPU_FAM6(SKYLAKE,		idle_cpu_skl),
  	INTEL_CPU_FAM6(KABYLAKE_L,		idle_cpu_skl),
 -	INTEL_CPU_FAM6(KABYLAKE,		idle_cpu_skl),
 +	INTEL_CPU_FAM6(KABYLAKE,	idle_cpu_skl),
  	INTEL_CPU_FAM6(SKYLAKE_X,		idle_cpu_skx),
  	INTEL_CPU_FAM6(XEON_PHI_KNL,		idle_cpu_knl),
  	INTEL_CPU_FAM6(XEON_PHI_KNM,		idle_cpu_knl),
* Unmerged path drivers/idle/intel_idle.c
