KVM: VMX: Directly query Intel PT mode when refreshing PMUs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit a1bead2abaa162e5e67ad258a06c9d71dddad00d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a1bead2a.failed

Use vmx_pt_mode_is_host_guest() in intel_pmu_refresh() instead of
bouncing through kvm_x86_ops->pt_supported, and remove ->pt_supported()
as the PMU code was the last remaining user.

Opportunistically clean up the wording of a comment that referenced
kvm_x86_ops->pt_supported().

No functional change intended.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit a1bead2abaa162e5e67ad258a06c9d71dddad00d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/svm.c
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/x86.c
diff --cc arch/x86/include/asm/kvm_host.h
index 69418e1a3a68,143d0ce493d5..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -1165,14 -1171,10 +1165,17 @@@ struct kvm_x86_ops 
  
  	int (*check_intercept)(struct kvm_vcpu *vcpu,
  			       struct x86_instruction_info *info,
 -			       enum x86_intercept_stage stage,
 -			       struct x86_exception *exception);
 +			       enum x86_intercept_stage stage);
  	void (*handle_exit_irqoff)(struct kvm_vcpu *vcpu,
  		enum exit_fastpath_completion *exit_fastpath);
++<<<<<<< HEAD
 +	bool (*mpx_supported)(void);
 +	bool (*xsaves_supported)(void);
 +	bool (*umip_emulated)(void);
 +	bool (*pt_supported)(void);
 +	bool (*pku_supported)(void);
++=======
++>>>>>>> a1bead2abaa1 (KVM: VMX: Directly query Intel PT mode when refreshing PMUs)
  
  	int (*check_nested_events)(struct kvm_vcpu *vcpu);
  	void (*request_immediate_exit)(struct kvm_vcpu *vcpu);
diff --cc arch/x86/kvm/svm.c
index 2c7c88ef7253,e0be6d0bca9e..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -6086,36 -6074,6 +6086,39 @@@ static int svm_get_lpage_level(void
  	return PT_PDPE_LEVEL;
  }
  
++<<<<<<< HEAD
 +static bool svm_rdtscp_supported(void)
 +{
 +	return boot_cpu_has(X86_FEATURE_RDTSCP);
 +}
 +
 +static bool svm_invpcid_supported(void)
 +{
 +	return false;
 +}
 +
 +static bool svm_mpx_supported(void)
 +{
 +	return false;
 +}
 +
 +static bool svm_xsaves_supported(void)
 +{
 +	return boot_cpu_has(X86_FEATURE_XSAVES);
 +}
 +
 +static bool svm_umip_emulated(void)
 +{
 +	return false;
 +}
 +
 +static bool svm_pt_supported(void)
 +{
 +	return false;
 +}
 +
++=======
++>>>>>>> a1bead2abaa1 (KVM: VMX: Directly query Intel PT mode when refreshing PMUs)
  static bool svm_has_wbinvd_exit(void)
  {
  	return true;
@@@ -7464,14 -7435,6 +7467,17 @@@ static struct kvm_x86_ops svm_x86_ops _
  
  	.cpuid_update = svm_cpuid_update,
  
++<<<<<<< HEAD
 +	.rdtscp_supported = svm_rdtscp_supported,
 +	.invpcid_supported = svm_invpcid_supported,
 +	.mpx_supported = svm_mpx_supported,
 +	.xsaves_supported = svm_xsaves_supported,
 +	.umip_emulated = svm_umip_emulated,
 +	.pt_supported = svm_pt_supported,
 +	.pku_supported = svm_pku_supported,
 +
++=======
++>>>>>>> a1bead2abaa1 (KVM: VMX: Directly query Intel PT mode when refreshing PMUs)
  	.set_supported_cpuid = svm_set_supported_cpuid,
  
  	.has_wbinvd_exit = svm_has_wbinvd_exit,
diff --cc arch/x86/kvm/vmx/vmx.c
index b4f527d117f1,75f61fb9c3b2..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -7990,11 -7940,6 +7985,14 @@@ static struct kvm_x86_ops vmx_x86_ops _
  
  	.check_intercept = vmx_check_intercept,
  	.handle_exit_irqoff = vmx_handle_exit_irqoff,
++<<<<<<< HEAD
 +	.mpx_supported = vmx_mpx_supported,
 +	.xsaves_supported = vmx_xsaves_supported,
 +	.umip_emulated = vmx_umip_emulated,
 +	.pt_supported = vmx_pt_supported,
 +	.pku_supported = vmx_pku_supported,
++=======
++>>>>>>> a1bead2abaa1 (KVM: VMX: Directly query Intel PT mode when refreshing PMUs)
  
  	.request_immediate_exit = vmx_request_immediate_exit,
  
diff --cc arch/x86/kvm/x86.c
index 4ad9e50bf3f6,5be4961d49dd..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -2781,6 -2815,19 +2781,22 @@@ int kvm_set_msr_common(struct kvm_vcpu 
  	case MSR_IA32_TSC:
  		kvm_write_tsc(vcpu, msr_info);
  		break;
++<<<<<<< HEAD
++=======
+ 	case MSR_IA32_XSS:
+ 		if (!msr_info->host_initiated &&
+ 		    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))
+ 			return 1;
+ 		/*
+ 		 * KVM supports exposing PT to the guest, but does not support
+ 		 * IA32_XSS[bit 8]. Guests have to use RDMSR/WRMSR rather than
+ 		 * XSAVES/XRSTORS to save/restore PT MSRs.
+ 		 */
+ 		if (data != 0)
+ 			return 1;
+ 		vcpu->arch.ia32_xss = data;
+ 		break;
++>>>>>>> a1bead2abaa1 (KVM: VMX: Directly query Intel PT mode when refreshing PMUs)
  	case MSR_SMI_COUNT:
  		if (!msr_info->host_initiated)
  			return 1;
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/svm.c
diff --git a/arch/x86/kvm/vmx/pmu_intel.c b/arch/x86/kvm/vmx/pmu_intel.c
index f94d3ae227a8..39d326f8fbd0 100644
--- a/arch/x86/kvm/vmx/pmu_intel.c
+++ b/arch/x86/kvm/vmx/pmu_intel.c
@@ -338,7 +338,7 @@ static void intel_pmu_refresh(struct kvm_vcpu *vcpu)
 	pmu->global_ovf_ctrl_mask = pmu->global_ctrl_mask
 			& ~(MSR_CORE_PERF_GLOBAL_OVF_CTRL_OVF_BUF |
 			    MSR_CORE_PERF_GLOBAL_OVF_CTRL_COND_CHGD);
-	if (kvm_x86_ops->pt_supported())
+	if (vmx_pt_mode_is_host_guest())
 		pmu->global_ovf_ctrl_mask &=
 				~MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI;
 
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/x86.c
