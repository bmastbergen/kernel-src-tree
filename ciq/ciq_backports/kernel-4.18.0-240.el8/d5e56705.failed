drm/i915/display: Fix mode private_flags comparison at atomic_check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Uma Shankar <uma.shankar@intel.com>
commit d5e56705927e00f703b2eb5a98299dd6622d16e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d5e56705.failed

This patch fixes the private_flags of mode to be checked and
compared against uapi.mode and not from hw.mode. This helps
properly trigger modeset at boot if desired by driver.

It helps resolve audio_codec initialization issues if display
is connected at boot. Initial discussion on this issue has happened
on below thread:
https://patchwork.freedesktop.org/series/74828/

v2: No functional change. Fixed the Closes tag and added
Maarten's RB.

v3: Added Fixes tag.

	Cc: Ville Syrjä <ville.syrjala@linux.intel.com>
	Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Cc: Kai Vehmanen <kai.vehmanen@linux.intel.com>
	Cc: Souza, Jose <jose.souza@intel.com>
Fixes: 58d124ea2739 ("drm/i915: Complete crtc hw/uapi split, v6.")
Closes: https://gitlab.freedesktop.org/drm/intel/issues/1363
	Suggested-by: Ville Syrjä <ville.syrjala@linux.intel.com>
	Signed-off-by: Uma Shankar <uma.shankar@intel.com>
	Signed-off-by: SweeAun Khor <swee.aun.khor@intel.com>
	Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200326125111.11081-1-uma.shankar@intel.com
(cherry picked from commit d5e56705927e00f703b2eb5a98299dd6622d16e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display.c
diff --cc drivers/gpu/drm/i915/display/intel_display.c
index 5c8c11deb857,f745027800d5..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@@ -13470,66 -14597,256 +13470,72 @@@ static void intel_crtc_check_fastset(co
  	new_crtc_state->has_drrs = old_crtc_state->has_drrs;
  }
  
 -static int intel_crtc_add_planes_to_state(struct intel_atomic_state *state,
 -					  struct intel_crtc *crtc,
 -					  u8 plane_ids_mask)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
 -	struct intel_plane *plane;
 -
 -	for_each_intel_plane_on_crtc(&dev_priv->drm, crtc, plane) {
 -		struct intel_plane_state *plane_state;
 -
 -		if ((plane_ids_mask & BIT(plane->id)) == 0)
 -			continue;
 -
 -		plane_state = intel_atomic_get_plane_state(state, plane);
 -		if (IS_ERR(plane_state))
 -			return PTR_ERR(plane_state);
 -	}
 -
 -	return 0;
 -}
 -
 -static bool active_planes_affects_min_cdclk(struct drm_i915_private *dev_priv)
 -{
 -	/* See {hsw,vlv,ivb}_plane_ratio() */
 -	return IS_BROADWELL(dev_priv) || IS_HASWELL(dev_priv) ||
 -		IS_CHERRYVIEW(dev_priv) || IS_VALLEYVIEW(dev_priv) ||
 -		IS_IVYBRIDGE(dev_priv);
 -}
 -
 -static int intel_atomic_check_planes(struct intel_atomic_state *state,
 -				     bool *need_cdclk_calc)
 +/**
 + * intel_atomic_check - validate state object
 + * @dev: drm device
 + * @_state: state to validate
 + */
 +static int intel_atomic_check(struct drm_device *dev,
 +			      struct drm_atomic_state *_state)
  {
 -	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
 +	struct drm_i915_private *dev_priv = to_i915(dev);
 +	struct intel_atomic_state *state = to_intel_atomic_state(_state);
  	struct intel_crtc_state *old_crtc_state, *new_crtc_state;
 -	struct intel_plane_state *plane_state;
 -	struct intel_plane *plane;
  	struct intel_crtc *crtc;
 -	int i, ret;
 -
 -	ret = icl_add_linked_planes(state);
 -	if (ret)
 -		return ret;
 +	int ret, i;
 +	bool any_ms = state->cdclk.force_min_cdclk_changed;
  
 -	for_each_new_intel_plane_in_state(state, plane, plane_state, i) {
 -		ret = intel_plane_atomic_check(state, plane);
 -		if (ret) {
 -			drm_dbg_atomic(&dev_priv->drm,
 -				       "[PLANE:%d:%s] atomic driver check failed\n",
 -				       plane->base.base.id, plane->base.name);
 -			return ret;
 -		}
 +	/* Catch I915_MODE_FLAG_INHERITED */
 +	for_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,
 +					    new_crtc_state, i) {
++<<<<<<< HEAD
 +		if (new_crtc_state->base.mode.private_flags !=
 +		    old_crtc_state->base.mode.private_flags)
 +			new_crtc_state->base.mode_changed = true;
++=======
++		if (new_crtc_state->uapi.mode.private_flags !=
++		    old_crtc_state->uapi.mode.private_flags)
++			new_crtc_state->uapi.mode_changed = true;
++>>>>>>> d5e56705927e (drm/i915/display: Fix mode private_flags comparison at atomic_check)
  	}
  
 +	ret = drm_atomic_helper_check_modeset(dev, &state->base);
 +	if (ret)
 +		goto fail;
 +
  	for_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,
  					    new_crtc_state, i) {
 -		u8 old_active_planes, new_active_planes;
 +		if (!needs_modeset(&new_crtc_state->base))
 +			continue;
  
 -		ret = icl_check_nv12_planes(new_crtc_state);
 +		if (!new_crtc_state->base.enable) {
 +			any_ms = true;
 +			continue;
 +		}
 +
 +		ret = intel_modeset_pipe_config(new_crtc_state);
  		if (ret)
 -			return ret;
 +			goto fail;
  
 -		/*
 -		 * On some platforms the number of active planes affects
 -		 * the planes' minimum cdclk calculation. Add such planes
 -		 * to the state before we compute the minimum cdclk.
 -		 */
 -		if (!active_planes_affects_min_cdclk(dev_priv))
 -			continue;
 +		intel_crtc_check_fastset(old_crtc_state, new_crtc_state);
  
 -		old_active_planes = old_crtc_state->active_planes & ~BIT(PLANE_CURSOR);
 -		new_active_planes = new_crtc_state->active_planes & ~BIT(PLANE_CURSOR);
 +		if (needs_modeset(&new_crtc_state->base))
 +			any_ms = true;
 +	}
  
 -		if (hweight8(old_active_planes) == hweight8(new_active_planes))
 -			continue;
 +	ret = drm_dp_mst_atomic_check(&state->base);
 +	if (ret)
 +		goto fail;
  
 -		ret = intel_crtc_add_planes_to_state(state, crtc, new_active_planes);
 +	if (any_ms) {
 +		ret = intel_modeset_checks(state);
  		if (ret)
 -			return ret;
 +			goto fail;
 +	} else {
 +		state->cdclk.logical = dev_priv->cdclk.logical;
  	}
  
 -	/*
 -	 * active_planes bitmask has been updated, and potentially
 -	 * affected planes are part of the state. We can now
 -	 * compute the minimum cdclk for each plane.
 -	 */
 -	for_each_new_intel_plane_in_state(state, plane, plane_state, i) {
 -		ret = intel_plane_calc_min_cdclk(state, plane, need_cdclk_calc);
 -		if (ret)
 -			return ret;
 -	}
 -
 -	return 0;
 -}
 -
 -static int intel_atomic_check_crtcs(struct intel_atomic_state *state)
 -{
 -	struct intel_crtc_state *crtc_state;
 -	struct intel_crtc *crtc;
 -	int i;
 -
 -	for_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {
 -		int ret = intel_crtc_atomic_check(state, crtc);
 -		struct drm_i915_private *i915 = to_i915(crtc->base.dev);
 -		if (ret) {
 -			drm_dbg_atomic(&i915->drm,
 -				       "[CRTC:%d:%s] atomic driver check failed\n",
 -				       crtc->base.base.id, crtc->base.name);
 -			return ret;
 -		}
 -	}
 -
 -	return 0;
 -}
 -
 -static bool intel_cpu_transcoders_need_modeset(struct intel_atomic_state *state,
 -					       u8 transcoders)
 -{
 -	const struct intel_crtc_state *new_crtc_state;
 -	struct intel_crtc *crtc;
 -	int i;
 -
 -	for_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {
 -		if (new_crtc_state->hw.enable &&
 -		    transcoders & BIT(new_crtc_state->cpu_transcoder) &&
 -		    needs_modeset(new_crtc_state))
 -			return true;
 -	}
 -
 -	return false;
 -}
 -
 -/**
 - * intel_atomic_check - validate state object
 - * @dev: drm device
 - * @_state: state to validate
 - */
 -static int intel_atomic_check(struct drm_device *dev,
 -			      struct drm_atomic_state *_state)
 -{
 -	struct drm_i915_private *dev_priv = to_i915(dev);
 -	struct intel_atomic_state *state = to_intel_atomic_state(_state);
 -	struct intel_crtc_state *old_crtc_state, *new_crtc_state;
 -	struct intel_cdclk_state *new_cdclk_state;
 -	struct intel_crtc *crtc;
 -	int ret, i;
 -	bool any_ms = false;
 -
 -	/* Catch I915_MODE_FLAG_INHERITED */
 -	for_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,
 -					    new_crtc_state, i) {
 -		if (new_crtc_state->uapi.mode.private_flags !=
 -		    old_crtc_state->uapi.mode.private_flags)
 -			new_crtc_state->uapi.mode_changed = true;
 -	}
 -
 -	ret = drm_atomic_helper_check_modeset(dev, &state->base);
 -	if (ret)
 -		goto fail;
 -
 -	for_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,
 -					    new_crtc_state, i) {
 -		if (!needs_modeset(new_crtc_state)) {
 -			/* Light copy */
 -			intel_crtc_copy_uapi_to_hw_state_nomodeset(new_crtc_state);
 -
 -			continue;
 -		}
 -
 -		ret = intel_crtc_prepare_cleared_state(new_crtc_state);
 -		if (ret)
 -			goto fail;
 -
 -		if (!new_crtc_state->hw.enable)
 -			continue;
 -
 -		ret = intel_modeset_pipe_config(new_crtc_state);
 -		if (ret)
 -			goto fail;
 -	}
 -
 -	for_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,
 -					    new_crtc_state, i) {
 -		if (!needs_modeset(new_crtc_state))
 -			continue;
 -
 -		ret = intel_modeset_pipe_config_late(new_crtc_state);
 -		if (ret)
 -			goto fail;
 -
 -		intel_crtc_check_fastset(old_crtc_state, new_crtc_state);
 -	}
 -
 -	/**
 -	 * Check if fastset is allowed by external dependencies like other
 -	 * pipes and transcoders.
 -	 *
 -	 * Right now it only forces a fullmodeset when the MST master
 -	 * transcoder did not changed but the pipe of the master transcoder
 -	 * needs a fullmodeset so all slaves also needs to do a fullmodeset or
 -	 * in case of port synced crtcs, if one of the synced crtcs
 -	 * needs a full modeset, all other synced crtcs should be
 -	 * forced a full modeset.
 -	 */
 -	for_each_new_intel_crtc_in_state(state, crtc, new_crtc_state, i) {
 -		if (!new_crtc_state->hw.enable || needs_modeset(new_crtc_state))
 -			continue;
 -
 -		if (intel_dp_mst_is_slave_trans(new_crtc_state)) {
 -			enum transcoder master = new_crtc_state->mst_master_transcoder;
 -
 -			if (intel_cpu_transcoders_need_modeset(state, BIT(master))) {
 -				new_crtc_state->uapi.mode_changed = true;
 -				new_crtc_state->update_pipe = false;
 -			}
 -		}
 -
 -		if (is_trans_port_sync_mode(new_crtc_state)) {
 -			u8 trans = new_crtc_state->sync_mode_slaves_mask;
 -
 -			if (new_crtc_state->master_transcoder != INVALID_TRANSCODER)
 -				trans |= BIT(new_crtc_state->master_transcoder);
 -
 -			if (intel_cpu_transcoders_need_modeset(state, trans)) {
 -				new_crtc_state->uapi.mode_changed = true;
 -				new_crtc_state->update_pipe = false;
 -			}
 -		}
 -	}
 -
 -	for_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,
 -					    new_crtc_state, i) {
 -		if (needs_modeset(new_crtc_state)) {
 -			any_ms = true;
 -			continue;
 -		}
 -
 -		if (!new_crtc_state->update_pipe)
 -			continue;
 -
 -		intel_crtc_copy_fastset(old_crtc_state, new_crtc_state);
 -	}
 -
 -	if (any_ms && !check_digital_port_conflicts(state)) {
 -		drm_dbg_kms(&dev_priv->drm,
 -			    "rejecting conflicting digital port configuration\n");
 -		ret = EINVAL;
 -		goto fail;
 -	}
 -
 -	ret = drm_dp_mst_atomic_check(&state->base);
 +	ret = icl_add_linked_planes(state);
  	if (ret)
  		goto fail;
  
* Unmerged path drivers/gpu/drm/i915/display/intel_display.c
