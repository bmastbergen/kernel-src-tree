KVM: x86: Move nSVM CPUID 0x8000000A handling into common x86 code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 257038745cae1fdaa3948013a22eba3b1d610174
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/25703874.failed

Handle CPUID 0x8000000A in the main switch in __do_cpuid_func() and drop
->set_supported_cpuid() now that both VMX and SVM implementations are
empty.  Like leaf 0x14 (Intel PT) and leaf 0x8000001F (SEV), leaf
0x8000000A is is (obviously) vendor specific but can be queried in
common code while respecting SVM's wishes by querying kvm_cpu_cap_has().

	Suggested-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 257038745cae1fdaa3948013a22eba3b1d610174)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/cpuid.c
#	arch/x86/kvm/svm.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/include/asm/kvm_host.h
index 57bbfbf61b11,24c90ea5ddbd..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -1153,8 -1158,6 +1153,11 @@@ struct kvm_x86_ops 
  
  	void (*set_tdp_cr3)(struct kvm_vcpu *vcpu, unsigned long cr3);
  
++<<<<<<< HEAD
 +	void (*set_supported_cpuid)(u32 func, struct kvm_cpuid_entry2 *entry);
 +
++=======
++>>>>>>> 257038745cae (KVM: x86: Move nSVM CPUID 0x8000000A handling into common x86 code)
  	bool (*has_wbinvd_exit)(void);
  
  	u64 (*read_l1_tsc_offset)(struct kvm_vcpu *vcpu);
diff --cc arch/x86/kvm/cpuid.c
index 6cc407efd815,cc8b24b4d8f3..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -768,32 -738,20 +768,43 @@@ static inline int __do_cpuid_func(struc
  			g_phys_as = phys_as;
  		entry->eax = g_phys_as | (virt_as << 8);
  		entry->edx = 0;
 -		cpuid_entry_override(entry, CPUID_8000_0008_EBX);
 +		entry->ebx &= kvm_cpuid_8000_0008_ebx_x86_features;
 +		cpuid_mask(&entry->ebx, CPUID_8000_0008_EBX);
 +		/*
 +		 * AMD has separate bits for each SPEC_CTRL bit.
 +		 * arch/x86/kernel/cpu/bugs.c is kind enough to
 +		 * record that in cpufeatures so use them.
 +		 */
 +		if (boot_cpu_has(X86_FEATURE_IBPB))
 +			entry->ebx |= F(AMD_IBPB);
 +		if (boot_cpu_has(X86_FEATURE_IBRS))
 +			entry->ebx |= F(AMD_IBRS);
 +		if (boot_cpu_has(X86_FEATURE_STIBP))
 +			entry->ebx |= F(AMD_STIBP);
 +		if (boot_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD))
 +			entry->ebx |= F(AMD_SSBD);
 +		if (!boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))
 +			entry->ebx |= F(AMD_SSB_NO);
 +		/*
 +		 * The preference is to use SPEC CTRL MSR instead of the
 +		 * VIRT_SPEC MSR.
 +		 */
 +		if (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) &&
 +		    !boot_cpu_has(X86_FEATURE_AMD_SSBD))
 +			entry->ebx |= F(VIRT_SSBD);
  		break;
  	}
+ 	case 0x8000000A:
+ 		if (!kvm_cpu_cap_has(X86_FEATURE_SVM)) {
+ 			entry->eax = entry->ebx = entry->ecx = entry->edx = 0;
+ 			break;
+ 		}
+ 		entry->eax = 1; /* SVM revision 1 */
+ 		entry->ebx = 8; /* Lets support 8 ASIDs in case we add proper
+ 				   ASID emulation to nested SVM */
+ 		entry->ecx = 0; /* Reserved */
+ 		cpuid_entry_override(entry, CPUID_8000_000A_EDX);
+ 		break;
  	case 0x80000019:
  		entry->ecx = entry->edx = 0;
  		break;
@@@ -824,8 -781,6 +835,11 @@@
  		break;
  	}
  
++<<<<<<< HEAD
 +	kvm_x86_ops->set_supported_cpuid(function, entry);
 +
++=======
++>>>>>>> 257038745cae (KVM: x86: Move nSVM CPUID 0x8000000A handling into common x86 code)
  	r = 0;
  
  out:
diff --cc arch/x86/kvm/svm.c
index 720353d5a356,c6e9910d1149..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -6036,81 -6035,23 +6036,84 @@@ static void svm_cpuid_update(struct kvm
  	if (!kvm_vcpu_apicv_active(vcpu))
  		return;
  
 -	/*
 -	 * AVIC does not work with an x2APIC mode guest. If the X2APIC feature
 -	 * is exposed to the guest, disable AVIC.
 -	 */
 -	if (guest_cpuid_has(vcpu, X86_FEATURE_X2APIC))
 -		kvm_request_apicv_update(vcpu->kvm, false,
 -					 APICV_INHIBIT_REASON_X2APIC);
 +	guest_cpuid_clear(vcpu, X86_FEATURE_X2APIC);
 +}
  
 -	/*
 -	 * Currently, AVIC does not work with nested virtualization.
 -	 * So, we disable AVIC when cpuid for SVM is set in the L1 guest.
 -	 */
 -	if (nested && guest_cpuid_has(vcpu, X86_FEATURE_SVM))
 -		kvm_request_apicv_update(vcpu->kvm, false,
 -					 APICV_INHIBIT_REASON_NESTED);
++<<<<<<< HEAD
 +#define F feature_bit
 +
 +static void svm_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
 +{
 +	switch (func) {
 +	case 0x1:
 +		if (avic)
 +			entry->ecx &= ~F(X2APIC);
 +		break;
 +	case 0x80000001:
 +		if (nested)
 +			entry->ecx |= (1 << 2); /* Set SVM bit */
 +		break;
 +	case 0x80000008:
 +		if (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) ||
 +		     boot_cpu_has(X86_FEATURE_AMD_SSBD))
 +			entry->ebx |= F(VIRT_SSBD);
 +		break;
 +	case 0x8000000A:
 +		entry->eax = 1; /* SVM revision 1 */
 +		entry->ebx = 8; /* Lets support 8 ASIDs in case we add proper
 +				   ASID emulation to nested SVM */
 +		entry->ecx = 0; /* Reserved */
 +		entry->edx = 0; /* Per default do not support any
 +				   additional features */
 +
 +		/* Support next_rip if host supports it */
 +		if (boot_cpu_has(X86_FEATURE_NRIPS))
 +			entry->edx |= F(NRIPS);
 +
 +		/* Support NPT for the guest if enabled */
 +		if (npt_enabled)
 +			entry->edx |= F(NPT);
 +
 +	}
 +}
 +
 +static int svm_get_lpage_level(void)
 +{
 +	return PT_PDPE_LEVEL;
 +}
 +
 +static bool svm_rdtscp_supported(void)
 +{
 +	return boot_cpu_has(X86_FEATURE_RDTSCP);
  }
  
 +static bool svm_invpcid_supported(void)
 +{
 +	return false;
 +}
 +
 +static bool svm_mpx_supported(void)
 +{
 +	return false;
 +}
 +
 +static bool svm_xsaves_supported(void)
 +{
 +	return boot_cpu_has(X86_FEATURE_XSAVES);
 +}
 +
 +static bool svm_umip_emulated(void)
 +{
 +	return false;
 +}
 +
 +static bool svm_pt_supported(void)
 +{
 +	return false;
 +}
 +
++=======
++>>>>>>> 257038745cae (KVM: x86: Move nSVM CPUID 0x8000000A handling into common x86 code)
  static bool svm_has_wbinvd_exit(void)
  {
  	return true;
@@@ -7455,20 -7409,8 +7458,23 @@@ static struct kvm_x86_ops svm_x86_ops _
  
  	.get_exit_info = svm_get_exit_info,
  
 +	.get_lpage_level = svm_get_lpage_level,
 +
  	.cpuid_update = svm_cpuid_update,
  
++<<<<<<< HEAD
 +	.rdtscp_supported = svm_rdtscp_supported,
 +	.invpcid_supported = svm_invpcid_supported,
 +	.mpx_supported = svm_mpx_supported,
 +	.xsaves_supported = svm_xsaves_supported,
 +	.umip_emulated = svm_umip_emulated,
 +	.pt_supported = svm_pt_supported,
 +	.pku_supported = svm_pku_supported,
 +
 +	.set_supported_cpuid = svm_set_supported_cpuid,
 +
++=======
++>>>>>>> 257038745cae (KVM: x86: Move nSVM CPUID 0x8000000A handling into common x86 code)
  	.has_wbinvd_exit = svm_has_wbinvd_exit,
  
  	.read_l1_tsc_offset = svm_read_l1_tsc_offset,
diff --cc arch/x86/kvm/vmx/vmx.c
index 81f81c6fe900,e91a84bb251c..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -7250,10 -7102,36 +7250,43 @@@ static void vmx_cpuid_update(struct kvm
  	}
  }
  
++<<<<<<< HEAD
 +static void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
 +{
 +	if (func == 1 && nested)
 +		entry->ecx |= feature_bit(VMX);
++=======
+ static __init void vmx_set_cpu_caps(void)
+ {
+ 	kvm_set_cpu_caps();
+ 
+ 	/* CPUID 0x1 */
+ 	if (nested)
+ 		kvm_cpu_cap_set(X86_FEATURE_VMX);
+ 
+ 	/* CPUID 0x7 */
+ 	if (kvm_mpx_supported())
+ 		kvm_cpu_cap_check_and_set(X86_FEATURE_MPX);
+ 	if (cpu_has_vmx_invpcid())
+ 		kvm_cpu_cap_check_and_set(X86_FEATURE_INVPCID);
+ 	if (vmx_pt_mode_is_host_guest())
+ 		kvm_cpu_cap_check_and_set(X86_FEATURE_INTEL_PT);
+ 
+ 	/* PKU is not yet implemented for shadow paging. */
+ 	if (enable_ept && boot_cpu_has(X86_FEATURE_OSPKE))
+ 		kvm_cpu_cap_check_and_set(X86_FEATURE_PKU);
+ 
+ 	if (vmx_umip_emulated())
+ 		kvm_cpu_cap_set(X86_FEATURE_UMIP);
+ 
+ 	/* CPUID 0xD.1 */
+ 	if (!vmx_xsaves_supported())
+ 		kvm_cpu_cap_clear(X86_FEATURE_XSAVES);
+ 
+ 	/* CPUID 0x80000001 */
+ 	if (!cpu_has_vmx_rdtscp())
+ 		kvm_cpu_cap_clear(X86_FEATURE_RDTSCP);
++>>>>>>> 257038745cae (KVM: x86: Move nSVM CPUID 0x8000000A handling into common x86 code)
  }
  
  static void vmx_request_immediate_exit(struct kvm_vcpu *vcpu)
@@@ -7967,14 -7914,7 +8000,17 @@@ static struct kvm_x86_ops vmx_x86_ops _
  
  	.get_exit_info = vmx_get_exit_info,
  
 +	.get_lpage_level = vmx_get_lpage_level,
 +
  	.cpuid_update = vmx_cpuid_update,
++<<<<<<< HEAD
 +
 +	.rdtscp_supported = vmx_rdtscp_supported,
 +	.invpcid_supported = vmx_invpcid_supported,
 +
 +	.set_supported_cpuid = vmx_set_supported_cpuid,
++=======
++>>>>>>> 257038745cae (KVM: x86: Move nSVM CPUID 0x8000000A handling into common x86 code)
  
  	.has_wbinvd_exit = cpu_has_vmx_wbinvd_exit,
  
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/cpuid.c
* Unmerged path arch/x86/kvm/svm.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
