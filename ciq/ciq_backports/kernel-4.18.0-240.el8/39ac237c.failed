net/mlx5: E-Switch, Refactor chains and priorities

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paul Blakey <paulb@mellanox.com>
commit 39ac237ce00968545e7298faa9e07ecb7e440fb5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/39ac237c.failed

To support the entire chain and prio range (32bit + 16bit),
instead of a using a static array of chains/prios of limited size, create
them dynamically, and use a rhashtable to search for existing chains/prio
combinations.

This will be used in next patch to actually increase the number using
unamanged tables support and ignore flow level capability.

	Signed-off-by: Paul Blakey <paulb@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
	Reviewed-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 39ac237ce00968545e7298faa9e07ecb7e440fb5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 3a708d1db4f9,26f559b453dc..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -1082,7 -1084,7 +1083,11 @@@ mlx5e_tc_offload_to_slow_path(struct ml
  	memcpy(slow_attr, flow->esw_attr, sizeof(*slow_attr));
  	slow_attr->action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
  	slow_attr->split_count = 0;
++<<<<<<< HEAD
 +	slow_attr->dest_chain = FDB_SLOW_PATH_CHAIN;
++=======
+ 	slow_attr->flags |= MLX5_ESW_ATTR_FLAG_SLOW_PATH;
++>>>>>>> 39ac237ce009 (net/mlx5: E-Switch, Refactor chains and priorities)
  
  	rule = mlx5e_tc_offload_fdb_rules(esw, flow, spec, slow_attr);
  	if (!IS_ERR(rule))
@@@ -1099,7 -1101,7 +1104,11 @@@ mlx5e_tc_unoffload_from_slow_path(struc
  	memcpy(slow_attr, flow->esw_attr, sizeof(*slow_attr));
  	slow_attr->action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;
  	slow_attr->split_count = 0;
++<<<<<<< HEAD
 +	slow_attr->dest_chain = FDB_SLOW_PATH_CHAIN;
++=======
+ 	slow_attr->flags |= MLX5_ESW_ATTR_FLAG_SLOW_PATH;
++>>>>>>> 39ac237ce009 (net/mlx5: E-Switch, Refactor chains and priorities)
  	mlx5e_tc_unoffload_fdb_rules(esw, flow, slow_attr);
  	flow_flag_clear(flow, SLOW);
  }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 9c629f913b96,4472710ccc9c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -139,9 -157,8 +139,9 @@@ enum offloads_fdb_flags 
  	ESW_FDB_CHAINS_AND_PRIOS_SUPPORTED = BIT(0),
  };
  
- extern const unsigned int ESW_POOLS[4];
+ struct mlx5_esw_chains_priv;
  
 +#define PRIO_LEVELS 2
  struct mlx5_eswitch_fdb {
  	union {
  		struct legacy_fdb {
@@@ -165,14 -182,7 +165,18 @@@
  			struct mlx5_flow_handle *miss_rule_multi;
  			int vlan_push_pop_refcount;
  
++<<<<<<< HEAD
 +			struct {
 +				struct mlx5_flow_table *fdb;
 +				u32 num_rules;
 +			} fdb_prio[FDB_MAX_CHAIN + 1][FDB_MAX_PRIO + 1][PRIO_LEVELS];
 +			/* Protects fdb_prio table */
 +			struct mutex fdb_prio_lock;
 +
 +			int fdb_left[ARRAY_SIZE(ESW_POOLS)];
++=======
+ 			struct mlx5_esw_chains_priv *esw_chains_priv;
++>>>>>>> 39ac237ce009 (net/mlx5: E-Switch, Refactor chains and priorities)
  		} offloads;
  	};
  	u32 flags;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index a042a52084fa,47f8729197e0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -62,35 -59,12 +59,44 @@@ static struct mlx5_eswitch_rep *mlx5_es
  	return &esw->offloads.vport_reps[idx];
  }
  
++<<<<<<< HEAD
 +static struct mlx5_flow_table *
 +esw_get_prio_table(struct mlx5_eswitch *esw, u32 chain, u16 prio, int level);
 +static void
 +esw_put_prio_table(struct mlx5_eswitch *esw, u32 chain, u16 prio, int level);
 +
 +bool mlx5_eswitch_prios_supported(struct mlx5_eswitch *esw)
 +{
 +	return (!!(esw->fdb_table.flags & ESW_FDB_CHAINS_AND_PRIOS_SUPPORTED));
 +}
 +
 +u32 mlx5_eswitch_get_chain_range(struct mlx5_eswitch *esw)
 +{
 +	if (esw->fdb_table.flags & ESW_FDB_CHAINS_AND_PRIOS_SUPPORTED)
 +		return FDB_MAX_CHAIN;
 +
 +	return 0;
 +}
 +
 +u32 mlx5_eswitch_get_ft_chain(struct mlx5_eswitch *esw)
 +{
 +	return mlx5_eswitch_get_chain_range(esw) + 1;
 +}
 +
 +u16 mlx5_eswitch_get_prio_range(struct mlx5_eswitch *esw)
 +{
 +	if (esw->fdb_table.flags & ESW_FDB_CHAINS_AND_PRIOS_SUPPORTED)
 +		return FDB_MAX_PRIO;
 +
 +	return 1;
++=======
+ static bool
+ esw_check_ingress_prio_tag_enabled(const struct mlx5_eswitch *esw,
+ 				   const struct mlx5_vport *vport)
+ {
+ 	return (MLX5_CAP_GEN(esw->dev, prio_tag_required) &&
+ 		mlx5_eswitch_is_vf_vport(esw, vport->vport));
++>>>>>>> 39ac237ce009 (net/mlx5: E-Switch, Refactor chains and priorities)
  }
  
  static void
@@@ -852,175 -835,6 +867,178 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
 +#define ESW_OFFLOADS_NUM_GROUPS  4
 +
 +/* Firmware currently has 4 pool of 4 sizes that it supports (ESW_POOLS),
 + * and a virtual memory region of 16M (ESW_SIZE), this region is duplicated
 + * for each flow table pool. We can allocate up to 16M of each pool,
 + * and we keep track of how much we used via put/get_sz_to_pool.
 + * Firmware doesn't report any of this for now.
 + * ESW_POOL is expected to be sorted from large to small
 + */
 +#define ESW_SIZE (16 * 1024 * 1024)
 +const unsigned int ESW_POOLS[4] = { 4 * 1024 * 1024, 1 * 1024 * 1024,
 +				    64 * 1024, 128 };
 +
 +static int
 +get_sz_from_pool(struct mlx5_eswitch *esw)
 +{
 +	int sz = 0, i;
 +
 +	for (i = 0; i < ARRAY_SIZE(ESW_POOLS); i++) {
 +		if (esw->fdb_table.offloads.fdb_left[i]) {
 +			--esw->fdb_table.offloads.fdb_left[i];
 +			sz = ESW_POOLS[i];
 +			break;
 +		}
 +	}
 +
 +	return sz;
 +}
 +
 +static void
 +put_sz_to_pool(struct mlx5_eswitch *esw, int sz)
 +{
 +	int i;
 +
 +	for (i = 0; i < ARRAY_SIZE(ESW_POOLS); i++) {
 +		if (sz >= ESW_POOLS[i]) {
 +			++esw->fdb_table.offloads.fdb_left[i];
 +			break;
 +		}
 +	}
 +}
 +
 +static struct mlx5_flow_table *
 +create_next_size_table(struct mlx5_eswitch *esw,
 +		       struct mlx5_flow_namespace *ns,
 +		       u16 table_prio,
 +		       int level,
 +		       u32 flags)
 +{
 +	struct mlx5_flow_table_attr ft_attr = {};
 +	struct mlx5_flow_table *fdb;
 +	int sz;
 +
 +	sz = get_sz_from_pool(esw);
 +	if (!sz)
 +		return ERR_PTR(-ENOSPC);
 +
 +	ft_attr.max_fte = sz;
 +	ft_attr.prio = table_prio;
 +	ft_attr.level = level;
 +	ft_attr.flags = flags;
 +	ft_attr.autogroup.max_num_groups = ESW_OFFLOADS_NUM_GROUPS;
 +	fdb = mlx5_create_auto_grouped_flow_table(ns, &ft_attr);
 +	if (IS_ERR(fdb)) {
 +		esw_warn(esw->dev, "Failed to create FDB Table err %d (table prio: %d, level: %d, size: %d)\n",
 +			 (int)PTR_ERR(fdb), table_prio, level, sz);
 +		put_sz_to_pool(esw, sz);
 +	}
 +
 +	return fdb;
 +}
 +
 +static struct mlx5_flow_table *
 +esw_get_prio_table(struct mlx5_eswitch *esw, u32 chain, u16 prio, int level)
 +{
 +	struct mlx5_core_dev *dev = esw->dev;
 +	struct mlx5_flow_table *fdb = NULL;
 +	struct mlx5_flow_namespace *ns;
 +	int table_prio, l = 0;
 +	u32 flags = 0;
 +
 +	if (chain == FDB_SLOW_PATH_CHAIN)
 +		return esw->fdb_table.offloads.slow_fdb;
 +
 +	mutex_lock(&esw->fdb_table.offloads.fdb_prio_lock);
 +
 +	fdb = fdb_prio_table(esw, chain, prio, level).fdb;
 +	if (fdb) {
 +		/* take ref on earlier levels as well */
 +		while (level >= 0)
 +			fdb_prio_table(esw, chain, prio, level--).num_rules++;
 +		mutex_unlock(&esw->fdb_table.offloads.fdb_prio_lock);
 +		return fdb;
 +	}
 +
 +	ns = mlx5_get_fdb_sub_ns(dev, chain);
 +	if (!ns) {
 +		esw_warn(dev, "Failed to get FDB sub namespace\n");
 +		mutex_unlock(&esw->fdb_table.offloads.fdb_prio_lock);
 +		return ERR_PTR(-EOPNOTSUPP);
 +	}
 +
 +	if (esw->offloads.encap != DEVLINK_ESWITCH_ENCAP_MODE_NONE)
 +		flags |= (MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT |
 +			  MLX5_FLOW_TABLE_TUNNEL_EN_DECAP);
 +
 +	table_prio = (chain * FDB_MAX_PRIO) + prio - 1;
 +
 +	/* create earlier levels for correct fs_core lookup when
 +	 * connecting tables
 +	 */
 +	for (l = 0; l <= level; l++) {
 +		if (fdb_prio_table(esw, chain, prio, l).fdb) {
 +			fdb_prio_table(esw, chain, prio, l).num_rules++;
 +			continue;
 +		}
 +
 +		fdb = create_next_size_table(esw, ns, table_prio, l, flags);
 +		if (IS_ERR(fdb)) {
 +			l--;
 +			goto err_create_fdb;
 +		}
 +
 +		fdb_prio_table(esw, chain, prio, l).fdb = fdb;
 +		fdb_prio_table(esw, chain, prio, l).num_rules = 1;
 +	}
 +
 +	mutex_unlock(&esw->fdb_table.offloads.fdb_prio_lock);
 +	return fdb;
 +
 +err_create_fdb:
 +	mutex_unlock(&esw->fdb_table.offloads.fdb_prio_lock);
 +	if (l >= 0)
 +		esw_put_prio_table(esw, chain, prio, l);
 +
 +	return fdb;
 +}
 +
 +static void
 +esw_put_prio_table(struct mlx5_eswitch *esw, u32 chain, u16 prio, int level)
 +{
 +	int l;
 +
 +	if (chain == FDB_SLOW_PATH_CHAIN)
 +		return;
 +
 +	mutex_lock(&esw->fdb_table.offloads.fdb_prio_lock);
 +
 +	for (l = level; l >= 0; l--) {
 +		if (--(fdb_prio_table(esw, chain, prio, l).num_rules) > 0)
 +			continue;
 +
 +		put_sz_to_pool(esw, fdb_prio_table(esw, chain, prio, l).fdb->max_fte);
 +		mlx5_destroy_flow_table(fdb_prio_table(esw, chain, prio, l).fdb);
 +		fdb_prio_table(esw, chain, prio, l).fdb = NULL;
 +	}
 +
 +	mutex_unlock(&esw->fdb_table.offloads.fdb_prio_lock);
 +}
 +
 +static void esw_destroy_offloads_fast_fdb_tables(struct mlx5_eswitch *esw)
 +{
 +	/* If lazy creation isn't supported, deref the fast path tables */
 +	if (!(esw->fdb_table.flags & ESW_FDB_CHAINS_AND_PRIOS_SUPPORTED)) {
 +		esw_put_prio_table(esw, 0, 1, 1);
 +		esw_put_prio_table(esw, 0, 1, 0);
 +	}
 +}
 +
++=======
++>>>>>>> 39ac237ce009 (net/mlx5: E-Switch, Refactor chains and priorities)
  #define MAX_PF_SQ 256
  #define MAX_SQ_NVPORTS 32
  
@@@ -2033,9 -1905,8 +2033,8 @@@ static int esw_offloads_steering_init(s
  		total_vports = num_vfs + MLX5_SPECIAL_VPORTS(esw->dev);
  
  	memset(&esw->fdb_table.offloads, 0, sizeof(struct offloads_fdb));
- 	mutex_init(&esw->fdb_table.offloads.fdb_prio_lock);
  
 -	err = esw_create_uplink_offloads_acl_tables(esw);
 +	err = esw_create_offloads_acl_tables(esw);
  	if (err)
  		return err;
  
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/Makefile b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
index 8d3b7a3aee92..8a46f751dde9 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@ -40,7 +40,7 @@ mlx5_core-$(CONFIG_MLX5_ESWITCH)     += en_rep.o en_tc.o en/tc_tun.o lib/port_tu
 # Core extra
 #
 mlx5_core-$(CONFIG_MLX5_ESWITCH)   += eswitch.o eswitch_offloads.o eswitch_offloads_termtbl.o \
-				      ecpf.o rdma.o
+				      ecpf.o rdma.o eswitch_offloads_chains.o
 mlx5_core-$(CONFIG_MLX5_MPFS)      += lib/mpfs.o
 mlx5_core-$(CONFIG_VXLAN)          += lib/vxlan.o
 mlx5_core-$(CONFIG_PTP_1588_CLOCK) += lib/clock.o
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
index 6ab9e23af131..507ac29d4a35 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c
@@ -41,6 +41,7 @@
 #include <net/ipv6_stubs.h>
 
 #include "eswitch.h"
+#include "eswitch_offloads_chains.h"
 #include "en.h"
 #include "en_rep.h"
 #include "en_tc.h"
@@ -1234,25 +1235,25 @@ static int mlx5e_rep_setup_ft_cb(enum tc_setup_type type, void *type_data,
 	case TC_SETUP_CLSFLOWER:
 		memcpy(&tmp, f, sizeof(*f));
 
-		if (!mlx5_eswitch_prios_supported(esw) ||
+		if (!mlx5_esw_chains_prios_supported(esw) ||
 		    tmp.common.chain_index)
 			return -EOPNOTSUPP;
 
 		/* Re-use tc offload path by moving the ft flow to the
 		 * reserved ft chain.
 		 *
-		 * FT offload can use prio range [0, INT_MAX], so we
-		 * normalize it to range [1, mlx5_eswitch_get_prio_range(esw)]
+		 * FT offload can use prio range [0, INT_MAX], so we normalize
+		 * it to range [1, mlx5_esw_chains_get_prio_range(esw)]
 		 * as with tc, where prio 0 isn't supported.
 		 *
 		 * We only support chain 0 of FT offload.
 		 */
-		if (tmp.common.prio >= mlx5_eswitch_get_prio_range(esw))
+		if (tmp.common.prio >= mlx5_esw_chains_get_prio_range(esw))
 			return -EOPNOTSUPP;
 		if (tmp.common.chain_index != 0)
 			return -EOPNOTSUPP;
 
-		tmp.common.chain_index = mlx5_eswitch_get_ft_chain(esw);
+		tmp.common.chain_index = mlx5_esw_chains_get_ft_chain(esw);
 		tmp.common.prio++;
 		err = mlx5e_rep_setup_tc_cls_flower(priv, &tmp, flags);
 		memcpy(&f->stats, &tmp.stats, sizeof(f->stats));
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c
new file mode 100644
index 000000000000..a694cc52d94c
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c
@@ -0,0 +1,542 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+// Copyright (c) 2020 Mellanox Technologies.
+
+#include <linux/mlx5/driver.h>
+#include <linux/mlx5/mlx5_ifc.h>
+#include <linux/mlx5/fs.h>
+
+#include "eswitch_offloads_chains.h"
+#include "mlx5_core.h"
+#include "fs_core.h"
+#include "eswitch.h"
+#include "en.h"
+
+#define esw_chains_priv(esw) ((esw)->fdb_table.offloads.esw_chains_priv)
+#define esw_chains_lock(esw) (esw_chains_priv(esw)->lock)
+#define esw_chains_ht(esw) (esw_chains_priv(esw)->chains_ht)
+#define esw_prios_ht(esw) (esw_chains_priv(esw)->prios_ht)
+#define fdb_pool_left(esw) (esw_chains_priv(esw)->fdb_left)
+
+#define ESW_OFFLOADS_NUM_GROUPS  4
+
+/* Firmware currently has 4 pool of 4 sizes that it supports (ESW_POOLS),
+ * and a virtual memory region of 16M (ESW_SIZE), this region is duplicated
+ * for each flow table pool. We can allocate up to 16M of each pool,
+ * and we keep track of how much we used via get_next_avail_sz_from_pool.
+ * Firmware doesn't report any of this for now.
+ * ESW_POOL is expected to be sorted from large to small and match firmware
+ * pools.
+ */
+#define ESW_SIZE (16 * 1024 * 1024)
+const unsigned int ESW_POOLS[] = { 4 * 1024 * 1024,
+				   1 * 1024 * 1024,
+				   64 * 1024,
+				   4 * 1024, };
+
+struct mlx5_esw_chains_priv {
+	struct rhashtable chains_ht;
+	struct rhashtable prios_ht;
+	/* Protects above chains_ht and prios_ht */
+	struct mutex lock;
+
+	int fdb_left[ARRAY_SIZE(ESW_POOLS)];
+};
+
+struct fdb_chain {
+	struct rhash_head node;
+
+	u32 chain;
+
+	int ref;
+
+	struct mlx5_eswitch *esw;
+};
+
+struct fdb_prio_key {
+	u32 chain;
+	u32 prio;
+	u32 level;
+};
+
+struct fdb_prio {
+	struct rhash_head node;
+
+	struct fdb_prio_key key;
+
+	int ref;
+
+	struct fdb_chain *fdb_chain;
+	struct mlx5_flow_table *fdb;
+};
+
+static const struct rhashtable_params chain_params = {
+	.head_offset = offsetof(struct fdb_chain, node),
+	.key_offset = offsetof(struct fdb_chain, chain),
+	.key_len = sizeof_field(struct fdb_chain, chain),
+	.automatic_shrinking = true,
+};
+
+static const struct rhashtable_params prio_params = {
+	.head_offset = offsetof(struct fdb_prio, node),
+	.key_offset = offsetof(struct fdb_prio, key),
+	.key_len = sizeof_field(struct fdb_prio, key),
+	.automatic_shrinking = true,
+};
+
+bool mlx5_esw_chains_prios_supported(struct mlx5_eswitch *esw)
+{
+	return esw->fdb_table.flags & ESW_FDB_CHAINS_AND_PRIOS_SUPPORTED;
+}
+
+u32 mlx5_esw_chains_get_chain_range(struct mlx5_eswitch *esw)
+{
+	if (!mlx5_esw_chains_prios_supported(esw))
+		return 1;
+
+	return FDB_TC_MAX_CHAIN;
+}
+
+u32 mlx5_esw_chains_get_ft_chain(struct mlx5_eswitch *esw)
+{
+	return mlx5_esw_chains_get_chain_range(esw) + 1;
+}
+
+u32 mlx5_esw_chains_get_prio_range(struct mlx5_eswitch *esw)
+{
+	if (!mlx5_esw_chains_prios_supported(esw))
+		return 1;
+
+	return FDB_TC_MAX_PRIO;
+}
+
+static unsigned int mlx5_esw_chains_get_level_range(struct mlx5_eswitch *esw)
+{
+	return FDB_TC_LEVELS_PER_PRIO;
+}
+
+#define POOL_NEXT_SIZE 0
+static int
+mlx5_esw_chains_get_avail_sz_from_pool(struct mlx5_eswitch *esw,
+				       int desired_size)
+{
+	int i, found_i = -1;
+
+	for (i = ARRAY_SIZE(ESW_POOLS) - 1; i >= 0; i--) {
+		if (fdb_pool_left(esw)[i] && ESW_POOLS[i] > desired_size) {
+			found_i = i;
+			if (desired_size != POOL_NEXT_SIZE)
+				break;
+		}
+	}
+
+	if (found_i != -1) {
+		--fdb_pool_left(esw)[found_i];
+		return ESW_POOLS[found_i];
+	}
+
+	return 0;
+}
+
+static void
+mlx5_esw_chains_put_sz_to_pool(struct mlx5_eswitch *esw, int sz)
+{
+	int i;
+
+	for (i = ARRAY_SIZE(ESW_POOLS) - 1; i >= 0; i--) {
+		if (sz == ESW_POOLS[i]) {
+			++fdb_pool_left(esw)[i];
+			return;
+		}
+	}
+
+	WARN_ONCE(1, "Couldn't find size %d in fdb size pool", sz);
+}
+
+static void
+mlx5_esw_chains_init_sz_pool(struct mlx5_eswitch *esw)
+{
+	u32 fdb_max;
+	int i;
+
+	fdb_max = 1 << MLX5_CAP_ESW_FLOWTABLE_FDB(esw->dev, log_max_ft_size);
+
+	for (i = ARRAY_SIZE(ESW_POOLS) - 1; i >= 0; i--)
+		fdb_pool_left(esw)[i] =
+			ESW_POOLS[i] <= fdb_max ? ESW_SIZE / ESW_POOLS[i] : 0;
+}
+
+static struct mlx5_flow_table *
+mlx5_esw_chains_create_fdb_table(struct mlx5_eswitch *esw,
+				 u32 chain, u32 prio, u32 level)
+{
+	struct mlx5_flow_table_attr ft_attr = {};
+	struct mlx5_flow_namespace *ns;
+	struct mlx5_flow_table *fdb;
+	int sz;
+
+	if (esw->offloads.encap != DEVLINK_ESWITCH_ENCAP_MODE_NONE)
+		ft_attr.flags |= (MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT |
+				  MLX5_FLOW_TABLE_TUNNEL_EN_DECAP);
+
+	sz = mlx5_esw_chains_get_avail_sz_from_pool(esw, POOL_NEXT_SIZE);
+	if (!sz)
+		return ERR_PTR(-ENOSPC);
+
+	ft_attr.max_fte = sz;
+	ft_attr.level = level;
+	ft_attr.prio = prio - 1;
+	ft_attr.autogroup.max_num_groups = ESW_OFFLOADS_NUM_GROUPS;
+	ns = mlx5_get_fdb_sub_ns(esw->dev, chain);
+
+	fdb = mlx5_create_auto_grouped_flow_table(ns, &ft_attr);
+	if (IS_ERR(fdb)) {
+		esw_warn(esw->dev,
+			 "Failed to create FDB table err %d (chain: %d, prio: %d, level: %d, size: %d)\n",
+			 (int)PTR_ERR(fdb), chain, prio, level, sz);
+		mlx5_esw_chains_put_sz_to_pool(esw, sz);
+		return fdb;
+	}
+
+	return fdb;
+}
+
+static void
+mlx5_esw_chains_destroy_fdb_table(struct mlx5_eswitch *esw,
+				  struct mlx5_flow_table *fdb)
+{
+	mlx5_esw_chains_put_sz_to_pool(esw, fdb->max_fte);
+	mlx5_destroy_flow_table(fdb);
+}
+
+static struct fdb_chain *
+mlx5_esw_chains_create_fdb_chain(struct mlx5_eswitch *esw, u32 chain)
+{
+	struct fdb_chain *fdb_chain = NULL;
+	int err;
+
+	fdb_chain = kvzalloc(sizeof(*fdb_chain), GFP_KERNEL);
+	if (!fdb_chain)
+		return ERR_PTR(-ENOMEM);
+
+	fdb_chain->esw = esw;
+	fdb_chain->chain = chain;
+
+	err = rhashtable_insert_fast(&esw_chains_ht(esw), &fdb_chain->node,
+				     chain_params);
+	if (err)
+		goto err_insert;
+
+	return fdb_chain;
+
+err_insert:
+	kvfree(fdb_chain);
+	return ERR_PTR(err);
+}
+
+static void
+mlx5_esw_chains_destroy_fdb_chain(struct fdb_chain *fdb_chain)
+{
+	struct mlx5_eswitch *esw = fdb_chain->esw;
+
+	rhashtable_remove_fast(&esw_chains_ht(esw), &fdb_chain->node,
+			       chain_params);
+	kvfree(fdb_chain);
+}
+
+static struct fdb_chain *
+mlx5_esw_chains_get_fdb_chain(struct mlx5_eswitch *esw, u32 chain)
+{
+	struct fdb_chain *fdb_chain;
+
+	fdb_chain = rhashtable_lookup_fast(&esw_chains_ht(esw), &chain,
+					   chain_params);
+	if (!fdb_chain) {
+		fdb_chain = mlx5_esw_chains_create_fdb_chain(esw, chain);
+		if (IS_ERR(fdb_chain))
+			return fdb_chain;
+	}
+
+	fdb_chain->ref++;
+
+	return fdb_chain;
+}
+
+static void
+mlx5_esw_chains_put_fdb_chain(struct fdb_chain *fdb_chain)
+{
+	if (--fdb_chain->ref == 0)
+		mlx5_esw_chains_destroy_fdb_chain(fdb_chain);
+}
+
+static struct fdb_prio *
+mlx5_esw_chains_create_fdb_prio(struct mlx5_eswitch *esw,
+				u32 chain, u32 prio, u32 level)
+{
+	struct fdb_prio *fdb_prio = NULL;
+	struct fdb_chain *fdb_chain;
+	struct mlx5_flow_table *fdb;
+	int err;
+
+	fdb_chain = mlx5_esw_chains_get_fdb_chain(esw, chain);
+	if (IS_ERR(fdb_chain))
+		return ERR_CAST(fdb_chain);
+
+	fdb_prio = kvzalloc(sizeof(*fdb_prio), GFP_KERNEL);
+	if (!fdb_prio) {
+		err = -ENOMEM;
+		goto err_alloc;
+	}
+
+	fdb = mlx5_esw_chains_create_fdb_table(esw, fdb_chain->chain, prio,
+					       level);
+	if (IS_ERR(fdb)) {
+		err = PTR_ERR(fdb);
+		goto err_create;
+	}
+
+	fdb_prio->fdb_chain = fdb_chain;
+	fdb_prio->key.chain = chain;
+	fdb_prio->key.prio = prio;
+	fdb_prio->key.level = level;
+	fdb_prio->fdb = fdb;
+
+	err = rhashtable_insert_fast(&esw_prios_ht(esw), &fdb_prio->node,
+				     prio_params);
+	if (err)
+		goto err_insert;
+
+	return fdb_prio;
+
+err_insert:
+	mlx5_esw_chains_destroy_fdb_table(esw, fdb);
+err_create:
+	kvfree(fdb_prio);
+err_alloc:
+	mlx5_esw_chains_put_fdb_chain(fdb_chain);
+	return ERR_PTR(err);
+}
+
+static void
+mlx5_esw_chains_destroy_fdb_prio(struct mlx5_eswitch *esw,
+				 struct fdb_prio *fdb_prio)
+{
+	struct fdb_chain *fdb_chain = fdb_prio->fdb_chain;
+
+	rhashtable_remove_fast(&esw_prios_ht(esw), &fdb_prio->node,
+			       prio_params);
+	mlx5_esw_chains_destroy_fdb_table(esw, fdb_prio->fdb);
+	mlx5_esw_chains_put_fdb_chain(fdb_chain);
+	kvfree(fdb_prio);
+}
+
+struct mlx5_flow_table *
+mlx5_esw_chains_get_table(struct mlx5_eswitch *esw, u32 chain, u32 prio,
+			  u32 level)
+{
+	struct mlx5_flow_table *prev_fts;
+	struct fdb_prio *fdb_prio;
+	struct fdb_prio_key key;
+	int l = 0;
+
+	if ((chain > mlx5_esw_chains_get_chain_range(esw) &&
+	     chain != mlx5_esw_chains_get_ft_chain(esw)) ||
+	    prio > mlx5_esw_chains_get_prio_range(esw) ||
+	    level > mlx5_esw_chains_get_level_range(esw))
+		return ERR_PTR(-EOPNOTSUPP);
+
+	/* create earlier levels for correct fs_core lookup when
+	 * connecting tables.
+	 */
+	for (l = 0; l < level; l++) {
+		prev_fts = mlx5_esw_chains_get_table(esw, chain, prio, l);
+		if (IS_ERR(prev_fts)) {
+			fdb_prio = ERR_CAST(prev_fts);
+			goto err_get_prevs;
+		}
+	}
+
+	key.chain = chain;
+	key.prio = prio;
+	key.level = level;
+
+	mutex_lock(&esw_chains_lock(esw));
+	fdb_prio = rhashtable_lookup_fast(&esw_prios_ht(esw), &key,
+					  prio_params);
+	if (!fdb_prio) {
+		fdb_prio = mlx5_esw_chains_create_fdb_prio(esw, chain,
+							   prio, level);
+		if (IS_ERR(fdb_prio))
+			goto err_create_prio;
+	}
+
+	++fdb_prio->ref;
+	mutex_unlock(&esw_chains_lock(esw));
+
+	return fdb_prio->fdb;
+
+err_create_prio:
+	mutex_unlock(&esw_chains_lock(esw));
+err_get_prevs:
+	while (--l >= 0)
+		mlx5_esw_chains_put_table(esw, chain, prio, l);
+	return ERR_CAST(fdb_prio);
+}
+
+void
+mlx5_esw_chains_put_table(struct mlx5_eswitch *esw, u32 chain, u32 prio,
+			  u32 level)
+{
+	struct fdb_prio *fdb_prio;
+	struct fdb_prio_key key;
+
+	key.chain = chain;
+	key.prio = prio;
+	key.level = level;
+
+	mutex_lock(&esw_chains_lock(esw));
+	fdb_prio = rhashtable_lookup_fast(&esw_prios_ht(esw), &key,
+					  prio_params);
+	if (!fdb_prio)
+		goto err_get_prio;
+
+	if (--fdb_prio->ref == 0)
+		mlx5_esw_chains_destroy_fdb_prio(esw, fdb_prio);
+	mutex_unlock(&esw_chains_lock(esw));
+
+	while (level-- > 0)
+		mlx5_esw_chains_put_table(esw, chain, prio, level);
+
+	return;
+
+err_get_prio:
+	mutex_unlock(&esw_chains_lock(esw));
+	WARN_ONCE(1,
+		  "Couldn't find table: (chain: %d prio: %d level: %d)",
+		  chain, prio, level);
+}
+
+static int
+mlx5_esw_chains_init(struct mlx5_eswitch *esw)
+{
+	struct mlx5_esw_chains_priv *chains_priv;
+	struct mlx5_core_dev *dev = esw->dev;
+	u32 max_flow_counter, fdb_max;
+	int err;
+
+	chains_priv = kzalloc(sizeof(*chains_priv), GFP_KERNEL);
+	if (!chains_priv)
+		return -ENOMEM;
+	esw_chains_priv(esw) = chains_priv;
+
+	max_flow_counter = (MLX5_CAP_GEN(dev, max_flow_counter_31_16) << 16) |
+			    MLX5_CAP_GEN(dev, max_flow_counter_15_0);
+	fdb_max = 1 << MLX5_CAP_ESW_FLOWTABLE_FDB(dev, log_max_ft_size);
+
+	esw_debug(dev,
+		  "Init esw offloads chains, max counters(%d), groups(%d), max flow table size(%d)\n",
+		  max_flow_counter, ESW_OFFLOADS_NUM_GROUPS, fdb_max);
+
+	mlx5_esw_chains_init_sz_pool(esw);
+
+	if (!MLX5_CAP_ESW_FLOWTABLE(esw->dev, multi_fdb_encap) &&
+	    esw->offloads.encap != DEVLINK_ESWITCH_ENCAP_MODE_NONE) {
+		esw->fdb_table.flags &= ~ESW_FDB_CHAINS_AND_PRIOS_SUPPORTED;
+		esw_warn(dev, "Tc chains and priorities offload aren't supported, update firmware if needed\n");
+	} else {
+		esw->fdb_table.flags |= ESW_FDB_CHAINS_AND_PRIOS_SUPPORTED;
+		esw_info(dev, "Supported tc offload range - chains: %u, prios: %u\n",
+			 mlx5_esw_chains_get_chain_range(esw),
+			 mlx5_esw_chains_get_prio_range(esw));
+	}
+
+	err = rhashtable_init(&esw_chains_ht(esw), &chain_params);
+	if (err)
+		goto init_chains_ht_err;
+
+	err = rhashtable_init(&esw_prios_ht(esw), &prio_params);
+	if (err)
+		goto init_prios_ht_err;
+
+	mutex_init(&esw_chains_lock(esw));
+
+	return 0;
+
+init_prios_ht_err:
+	rhashtable_destroy(&esw_chains_ht(esw));
+init_chains_ht_err:
+	kfree(chains_priv);
+	return err;
+}
+
+static void
+mlx5_esw_chains_cleanup(struct mlx5_eswitch *esw)
+{
+	mutex_destroy(&esw_chains_lock(esw));
+	rhashtable_destroy(&esw_prios_ht(esw));
+	rhashtable_destroy(&esw_chains_ht(esw));
+
+	kfree(esw_chains_priv(esw));
+}
+
+static int
+mlx5_esw_chains_open(struct mlx5_eswitch *esw)
+{
+	struct mlx5_flow_table *ft;
+	int err;
+
+	/* Always open the root for fast path */
+	ft = mlx5_esw_chains_get_table(esw, 0, 1, 0);
+	if (IS_ERR(ft))
+		return PTR_ERR(ft);
+
+	/* Open level 1 for split rules now if prios isn't supported  */
+	if (!mlx5_esw_chains_prios_supported(esw)) {
+		ft = mlx5_esw_chains_get_table(esw, 0, 1, 1);
+
+		if (IS_ERR(ft)) {
+			err = PTR_ERR(ft);
+			goto level_1_err;
+		}
+	}
+
+	return 0;
+
+level_1_err:
+	mlx5_esw_chains_put_table(esw, 0, 1, 0);
+	return err;
+}
+
+static void
+mlx5_esw_chains_close(struct mlx5_eswitch *esw)
+{
+	if (!mlx5_esw_chains_prios_supported(esw))
+		mlx5_esw_chains_put_table(esw, 0, 1, 1);
+	mlx5_esw_chains_put_table(esw, 0, 1, 0);
+}
+
+int
+mlx5_esw_chains_create(struct mlx5_eswitch *esw)
+{
+	int err;
+
+	err = mlx5_esw_chains_init(esw);
+	if (err)
+		return err;
+
+	err = mlx5_esw_chains_open(esw);
+	if (err)
+		goto err_open;
+
+	return 0;
+
+err_open:
+	mlx5_esw_chains_cleanup(esw);
+	return err;
+}
+
+void
+mlx5_esw_chains_destroy(struct mlx5_eswitch *esw)
+{
+	mlx5_esw_chains_close(esw);
+	mlx5_esw_chains_cleanup(esw);
+}
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.h
new file mode 100644
index 000000000000..52fadacab84d
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB */
+/* Copyright (c) 2020 Mellanox Technologies. */
+
+#ifndef __ML5_ESW_CHAINS_H__
+#define __ML5_ESW_CHAINS_H__
+
+bool
+mlx5_esw_chains_prios_supported(struct mlx5_eswitch *esw);
+u32
+mlx5_esw_chains_get_prio_range(struct mlx5_eswitch *esw);
+u32
+mlx5_esw_chains_get_chain_range(struct mlx5_eswitch *esw);
+u32
+mlx5_esw_chains_get_ft_chain(struct mlx5_eswitch *esw);
+
+struct mlx5_flow_table *
+mlx5_esw_chains_get_table(struct mlx5_eswitch *esw, u32 chain, u32 prio,
+			  u32 level);
+void
+mlx5_esw_chains_put_table(struct mlx5_eswitch *esw, u32 chain, u32 prio,
+			  u32 level);
+
+int mlx5_esw_chains_create(struct mlx5_eswitch *esw);
+void mlx5_esw_chains_destroy(struct mlx5_eswitch *esw);
+
+#endif /* __ML5_ESW_CHAINS_H__ */
+
