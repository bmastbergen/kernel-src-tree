libceph: crush_location infrastructure

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ilya Dryomov <idryomov@gmail.com>
commit 45e6aa9f5592cd127367074f4822039cd8a825c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/45e6aa9f.failed

Allow expressing client's location in terms of CRUSH hierarchy as
a set of (bucket type name, bucket name) pairs.  The userspace syntax
"crush_location = key1=value1 key2=value2" is incompatible with mount
options and needed adaptation.  Key-value pairs are separated by '|'
and we use ':' instead of '=' to separate keys from values.  So for:

  crush_location = host=foo rack=bar

one would write:

  crush_location=host:foo|rack:bar

As in userspace, "multipath" locations are supported, so indicating
locality for parallel hierarchies is possible:

  crush_location=rack:foo1|rack:foo2|datacenter:bar

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
(cherry picked from commit 45e6aa9f5592cd127367074f4822039cd8a825c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ceph/ceph_common.c
diff --cc net/ceph/ceph_common.c
index 9994af52dfb4,44770b60bc38..000000000000
--- a/net/ceph/ceph_common.c
+++ b/net/ceph/ceph_common.c
@@@ -260,51 -264,70 +264,112 @@@ enum 
  	Opt_secret,
  	Opt_key,
  	Opt_ip,
++<<<<<<< HEAD
 +	Opt_last_string,
++=======
+ 	Opt_crush_location,
++>>>>>>> 45e6aa9f5592 (libceph: crush_location infrastructure)
  	/* string args above */
  	Opt_share,
 +	Opt_noshare,
  	Opt_crc,
 +	Opt_nocrc,
  	Opt_cephx_require_signatures,
 +	Opt_nocephx_require_signatures,
  	Opt_cephx_sign_messages,
 +	Opt_nocephx_sign_messages,
  	Opt_tcp_nodelay,
 +	Opt_notcp_nodelay,
  	Opt_abort_on_full,
  };
  
++<<<<<<< HEAD
 +static match_table_t opt_tokens = {
 +	{Opt_osdtimeout, "osdtimeout=%d"},
 +	{Opt_osdkeepalivetimeout, "osdkeepalive=%d"},
 +	{Opt_mount_timeout, "mount_timeout=%d"},
 +	{Opt_osd_idle_ttl, "osd_idle_ttl=%d"},
 +	{Opt_osd_request_timeout, "osd_request_timeout=%d"},
 +	/* int args above */
 +	{Opt_fsid, "fsid=%s"},
 +	{Opt_name, "name=%s"},
 +	{Opt_secret, "secret=%s"},
 +	{Opt_key, "key=%s"},
 +	{Opt_ip, "ip=%s"},
 +	/* string args above */
 +	{Opt_share, "share"},
 +	{Opt_noshare, "noshare"},
 +	{Opt_crc, "crc"},
 +	{Opt_nocrc, "nocrc"},
 +	{Opt_cephx_require_signatures, "cephx_require_signatures"},
 +	{Opt_nocephx_require_signatures, "nocephx_require_signatures"},
 +	{Opt_cephx_sign_messages, "cephx_sign_messages"},
 +	{Opt_nocephx_sign_messages, "nocephx_sign_messages"},
 +	{Opt_tcp_nodelay, "tcp_nodelay"},
 +	{Opt_notcp_nodelay, "notcp_nodelay"},
 +	{Opt_abort_on_full, "abort_on_full"},
 +	{-1, NULL}
 +};
 +
 +void ceph_destroy_options(struct ceph_options *opt)
 +{
 +	dout("destroy_options %p\n", opt);
++=======
+ static const struct fs_parameter_spec ceph_parameters[] = {
+ 	fsparam_flag	("abort_on_full",		Opt_abort_on_full),
+ 	fsparam_flag_no ("cephx_require_signatures",	Opt_cephx_require_signatures),
+ 	fsparam_flag_no ("cephx_sign_messages",		Opt_cephx_sign_messages),
+ 	fsparam_flag_no ("crc",				Opt_crc),
+ 	fsparam_string	("crush_location",		Opt_crush_location),
+ 	fsparam_string	("fsid",			Opt_fsid),
+ 	fsparam_string	("ip",				Opt_ip),
+ 	fsparam_string	("key",				Opt_key),
+ 	fsparam_u32	("mount_timeout",		Opt_mount_timeout),
+ 	fsparam_string	("name",			Opt_name),
+ 	fsparam_u32	("osd_idle_ttl",		Opt_osd_idle_ttl),
+ 	fsparam_u32	("osd_request_timeout",		Opt_osd_request_timeout),
+ 	fsparam_u32	("osdkeepalive",		Opt_osdkeepalivetimeout),
+ 	__fsparam	(fs_param_is_s32, "osdtimeout", Opt_osdtimeout,
+ 			 fs_param_deprecated, NULL),
+ 	fsparam_string	("secret",			Opt_secret),
+ 	fsparam_flag_no ("share",			Opt_share),
+ 	fsparam_flag_no ("tcp_nodelay",			Opt_tcp_nodelay),
+ 	{}
+ };
+ 
+ struct ceph_options *ceph_alloc_options(void)
+ {
+ 	struct ceph_options *opt;
+ 
+ 	opt = kzalloc(sizeof(*opt), GFP_KERNEL);
+ 	if (!opt)
+ 		return NULL;
+ 
+ 	opt->crush_locs = RB_ROOT;
+ 	opt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),
+ 				GFP_KERNEL);
+ 	if (!opt->mon_addr) {
+ 		kfree(opt);
+ 		return NULL;
+ 	}
+ 
+ 	opt->flags = CEPH_OPT_DEFAULT;
+ 	opt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;
+ 	opt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;
+ 	opt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;
+ 	opt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;
+ 	return opt;
+ }
+ EXPORT_SYMBOL(ceph_alloc_options);
+ 
+ void ceph_destroy_options(struct ceph_options *opt)
+ {
+ 	dout("destroy_options %p\n", opt);
+ 	if (!opt)
+ 		return;
+ 
+ 	ceph_clear_crush_locs(&opt->crush_locs);
++>>>>>>> 45e6aa9f5592 (libceph: crush_location infrastructure)
  	kfree(opt->name);
  	if (opt->key) {
  		ceph_crypto_key_destroy(opt->key);
@@@ -360,217 -385,169 +425,234 @@@ out
  	return err;
  }
  
 -int ceph_parse_mon_ips(const char *buf, size_t len, struct ceph_options *opt,
 -		       struct fc_log *l)
 +struct ceph_options *
 +ceph_parse_options(char *options, const char *dev_name,
 +			const char *dev_name_end,
 +			int (*parse_extra_token)(char *c, void *private),
 +			void *private)
  {
 -	struct p_log log = {.prefix = "libceph", .log = l};
 -	int ret;
 +	struct ceph_options *opt;
 +	const char *c;
 +	int err = -ENOMEM;
 +	substring_t argstr[MAX_OPT_ARGS];
  
 -	/* ip1[:port1][,ip2[:port2]...] */
 -	ret = ceph_parse_ips(buf, buf + len, opt->mon_addr, CEPH_MAX_MON,
 -			     &opt->num_mon);
 -	if (ret) {
 -		error_plog(&log, "Failed to parse monitor IPs: %d", ret);
 -		return ret;
 -	}
 +	opt = kzalloc(sizeof(*opt), GFP_KERNEL);
 +	if (!opt)
 +		return ERR_PTR(-ENOMEM);
 +	opt->mon_addr = kcalloc(CEPH_MAX_MON, sizeof(*opt->mon_addr),
 +				GFP_KERNEL);
 +	if (!opt->mon_addr)
 +		goto out;
  
 -	return 0;
 -}
 -EXPORT_SYMBOL(ceph_parse_mon_ips);
 +	dout("parse_options %p options '%s' dev_name '%s'\n", opt, options,
 +	     dev_name);
  
 -int ceph_parse_param(struct fs_parameter *param, struct ceph_options *opt,
 -		     struct fc_log *l)
 -{
 -	struct fs_parse_result result;
 -	int token, err;
 -	struct p_log log = {.prefix = "libceph", .log = l};
 -
 -	token = __fs_parse(&log, ceph_parameters, param, &result);
 -	dout("%s fs_parse '%s' token %d\n", __func__, param->key, token);
 -	if (token < 0)
 -		return token;
 -
 -	switch (token) {
 -	case Opt_ip:
 -		err = ceph_parse_ips(param->string,
 -				     param->string + param->size,
 -				     &opt->my_addr,
 -				     1, NULL);
 -		if (err) {
 -			error_plog(&log, "Failed to parse ip: %d", err);
 -			return err;
 -		}
 -		opt->flags |= CEPH_OPT_MYIP;
 -		break;
 +	/* start with defaults */
 +	opt->flags = CEPH_OPT_DEFAULT;
 +	opt->osd_keepalive_timeout = CEPH_OSD_KEEPALIVE_DEFAULT;
 +	opt->mount_timeout = CEPH_MOUNT_TIMEOUT_DEFAULT;
 +	opt->osd_idle_ttl = CEPH_OSD_IDLE_TTL_DEFAULT;
 +	opt->osd_request_timeout = CEPH_OSD_REQUEST_TIMEOUT_DEFAULT;
  
 -	case Opt_fsid:
 -		err = parse_fsid(param->string, &opt->fsid);
 -		if (err) {
 -			error_plog(&log, "Failed to parse fsid: %d", err);
 -			return err;
 -		}
 -		opt->flags |= CEPH_OPT_FSID;
 -		break;
 -	case Opt_name:
 -		kfree(opt->name);
 -		opt->name = param->string;
 -		param->string = NULL;
 -		break;
 -	case Opt_secret:
 -		ceph_crypto_key_destroy(opt->key);
 -		kfree(opt->key);
 +	/* get mon ip(s) */
 +	/* ip1[:port1][,ip2[:port2]...] */
 +	err = ceph_parse_ips(dev_name, dev_name_end, opt->mon_addr,
 +			     CEPH_MAX_MON, &opt->num_mon);
 +	if (err < 0)
 +		goto out;
  
 -		opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 -		if (!opt->key)
 -			return -ENOMEM;
 -		err = ceph_crypto_key_unarmor(opt->key, param->string);
 -		if (err) {
 -			error_plog(&log, "Failed to parse secret: %d", err);
 -			return err;
 +	/* parse mount options */
 +	while ((c = strsep(&options, ",")) != NULL) {
 +		int token, intval;
 +		if (!*c)
 +			continue;
 +		err = -EINVAL;
 +		token = match_token((char *)c, opt_tokens, argstr);
 +		if (token < 0 && parse_extra_token) {
 +			/* extra? */
 +			err = parse_extra_token((char *)c, private);
 +			if (err < 0) {
 +				pr_err("bad option at '%s'\n", c);
 +				goto out;
 +			}
 +			continue;
  		}
 -		break;
 -	case Opt_key:
 -		ceph_crypto_key_destroy(opt->key);
 -		kfree(opt->key);
 +		if (token < Opt_last_int) {
 +			err = match_int(&argstr[0], &intval);
 +			if (err < 0) {
 +				pr_err("bad option arg (not int) at '%s'\n", c);
 +				goto out;
 +			}
 +			dout("got int token %d val %d\n", token, intval);
 +		} else if (token > Opt_last_int && token < Opt_last_string) {
 +			dout("got string token %d val %s\n", token,
 +			     argstr[0].from);
 +		} else {
 +			dout("got token %d\n", token);
 +		}
 +		switch (token) {
 +		case Opt_ip:
 +			err = ceph_parse_ips(argstr[0].from,
 +					     argstr[0].to,
 +					     &opt->my_addr,
 +					     1, NULL);
 +			if (err < 0)
 +				goto out;
 +			opt->flags |= CEPH_OPT_MYIP;
 +			break;
  
 +		case Opt_fsid:
 +			err = parse_fsid(argstr[0].from, &opt->fsid);
 +			if (err == 0)
 +				opt->flags |= CEPH_OPT_FSID;
 +			break;
 +		case Opt_name:
 +			kfree(opt->name);
 +			opt->name = kstrndup(argstr[0].from,
 +					      argstr[0].to-argstr[0].from,
 +					      GFP_KERNEL);
 +			if (!opt->name) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			break;
 +		case Opt_secret:
 +			ceph_crypto_key_destroy(opt->key);
 +			kfree(opt->key);
 +
++<<<<<<< HEAD
 +		        opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 +			if (!opt->key) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			err = ceph_crypto_key_unarmor(opt->key, argstr[0].from);
 +			if (err < 0)
 +				goto out;
 +			break;
 +		case Opt_key:
 +			ceph_crypto_key_destroy(opt->key);
 +			kfree(opt->key);
++=======
+ 		opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
+ 		if (!opt->key)
+ 			return -ENOMEM;
+ 		return get_secret(opt->key, param->string, &log);
+ 	case Opt_crush_location:
+ 		ceph_clear_crush_locs(&opt->crush_locs);
+ 		err = ceph_parse_crush_location(param->string,
+ 						&opt->crush_locs);
+ 		if (err) {
+ 			error_plog(&log, "Failed to parse CRUSH location: %d",
+ 				   err);
+ 			return err;
+ 		}
+ 		break;
++>>>>>>> 45e6aa9f5592 (libceph: crush_location infrastructure)
 +
 +		        opt->key = kzalloc(sizeof(*opt->key), GFP_KERNEL);
 +			if (!opt->key) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			err = get_secret(opt->key, argstr[0].from);
 +			if (err < 0)
 +				goto out;
 +			break;
  
 -	case Opt_osdtimeout:
 -		warn_plog(&log, "Ignoring osdtimeout");
 -		break;
 -	case Opt_osdkeepalivetimeout:
 -		/* 0 isn't well defined right now, reject it */
 -		if (result.uint_32 < 1 || result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_keepalive_timeout =
 -		    msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_osd_idle_ttl:
 -		/* 0 isn't well defined right now, reject it */
 -		if (result.uint_32 < 1 || result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_idle_ttl = msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_mount_timeout:
 -		/* 0 is "wait forever" (i.e. infinite timeout) */
 -		if (result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->mount_timeout = msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 -	case Opt_osd_request_timeout:
 -		/* 0 is "wait forever" (i.e. infinite timeout) */
 -		if (result.uint_32 > INT_MAX / 1000)
 -			goto out_of_range;
 -		opt->osd_request_timeout =
 -		    msecs_to_jiffies(result.uint_32 * 1000);
 -		break;
 +			/* misc */
 +		case Opt_osdtimeout:
 +			pr_warn("ignoring deprecated osdtimeout option\n");
 +			break;
 +		case Opt_osdkeepalivetimeout:
 +			/* 0 isn't well defined right now, reject it */
 +			if (intval < 1 || intval > INT_MAX / 1000) {
 +				pr_err("osdkeepalive out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_keepalive_timeout =
 +					msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_osd_idle_ttl:
 +			/* 0 isn't well defined right now, reject it */
 +			if (intval < 1 || intval > INT_MAX / 1000) {
 +				pr_err("osd_idle_ttl out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_idle_ttl = msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_mount_timeout:
 +			/* 0 is "wait forever" (i.e. infinite timeout) */
 +			if (intval < 0 || intval > INT_MAX / 1000) {
 +				pr_err("mount_timeout out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->mount_timeout = msecs_to_jiffies(intval * 1000);
 +			break;
 +		case Opt_osd_request_timeout:
 +			/* 0 is "wait forever" (i.e. infinite timeout) */
 +			if (intval < 0 || intval > INT_MAX / 1000) {
 +				pr_err("osd_request_timeout out of range\n");
 +				err = -EINVAL;
 +				goto out;
 +			}
 +			opt->osd_request_timeout = msecs_to_jiffies(intval * 1000);
 +			break;
  
 -	case Opt_share:
 -		if (!result.negated)
 +		case Opt_share:
  			opt->flags &= ~CEPH_OPT_NOSHARE;
 -		else
 +			break;
 +		case Opt_noshare:
  			opt->flags |= CEPH_OPT_NOSHARE;
 -		break;
 -	case Opt_crc:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_crc:
  			opt->flags &= ~CEPH_OPT_NOCRC;
 -		else
 +			break;
 +		case Opt_nocrc:
  			opt->flags |= CEPH_OPT_NOCRC;
 -		break;
 -	case Opt_cephx_require_signatures:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_cephx_require_signatures:
  			opt->flags &= ~CEPH_OPT_NOMSGAUTH;
 -		else
 +			break;
 +		case Opt_nocephx_require_signatures:
  			opt->flags |= CEPH_OPT_NOMSGAUTH;
 -		break;
 -	case Opt_cephx_sign_messages:
 -		if (!result.negated)
 +			break;
 +		case Opt_cephx_sign_messages:
  			opt->flags &= ~CEPH_OPT_NOMSGSIGN;
 -		else
 +			break;
 +		case Opt_nocephx_sign_messages:
  			opt->flags |= CEPH_OPT_NOMSGSIGN;
 -		break;
 -	case Opt_tcp_nodelay:
 -		if (!result.negated)
 +			break;
 +
 +		case Opt_tcp_nodelay:
  			opt->flags |= CEPH_OPT_TCP_NODELAY;
 -		else
 +			break;
 +		case Opt_notcp_nodelay:
  			opt->flags &= ~CEPH_OPT_TCP_NODELAY;
 -		break;
 +			break;
  
 -	case Opt_abort_on_full:
 -		opt->flags |= CEPH_OPT_ABORT_ON_FULL;
 -		break;
 +		case Opt_abort_on_full:
 +			opt->flags |= CEPH_OPT_ABORT_ON_FULL;
 +			break;
  
 -	default:
 -		BUG();
 +		default:
 +			BUG_ON(token);
 +		}
  	}
  
 -	return 0;
 +	/* success */
 +	return opt;
  
 -out_of_range:
 -	return inval_plog(&log, "%s out of range", param->key);
 +out:
 +	ceph_destroy_options(opt);
 +	return ERR_PTR(err);
  }
 -EXPORT_SYMBOL(ceph_parse_param);
 +EXPORT_SYMBOL(ceph_parse_options);
  
  int ceph_print_client_options(struct seq_file *m, struct ceph_client *client,
  			      bool show_all)
diff --git a/include/linux/ceph/libceph.h b/include/linux/ceph/libceph.h
index 8502dfc84465..b9739196efc8 100644
--- a/include/linux/ceph/libceph.h
+++ b/include/linux/ceph/libceph.h
@@ -64,6 +64,7 @@ struct ceph_options {
 	int num_mon;
 	char *name;
 	struct ceph_crypto_key *key;
+	struct rb_root crush_locs;
 };
 
 /*
diff --git a/include/linux/ceph/osdmap.h b/include/linux/ceph/osdmap.h
index 5e601975745f..8c9d18cc9f45 100644
--- a/include/linux/ceph/osdmap.h
+++ b/include/linux/ceph/osdmap.h
@@ -302,9 +302,23 @@ bool ceph_pg_to_primary_shard(struct ceph_osdmap *osdmap,
 int ceph_pg_to_acting_primary(struct ceph_osdmap *osdmap,
 			      const struct ceph_pg *raw_pgid);
 
+struct crush_loc {
+	char *cl_type_name;
+	char *cl_name;
+};
+
+struct crush_loc_node {
+	struct rb_node cl_node;
+	struct crush_loc cl_loc;  /* pointers into cl_data */
+	char cl_data[];
+};
+
+int ceph_parse_crush_location(char *crush_location, struct rb_root *locs);
+int ceph_compare_crush_locs(struct rb_root *locs1, struct rb_root *locs2);
+void ceph_clear_crush_locs(struct rb_root *locs);
+
 extern struct ceph_pg_pool_info *ceph_pg_pool_by_id(struct ceph_osdmap *map,
 						    u64 id);
-
 extern const char *ceph_pg_pool_name_by_id(struct ceph_osdmap *map, u64 id);
 extern int ceph_pg_poolid_by_name(struct ceph_osdmap *map, const char *name);
 u64 ceph_pg_pool_flags(struct ceph_osdmap *map, u64 id);
* Unmerged path net/ceph/ceph_common.c
diff --git a/net/ceph/osdmap.c b/net/ceph/osdmap.c
index e74130876d3a..4b81334e9e5b 100644
--- a/net/ceph/osdmap.c
+++ b/net/ceph/osdmap.c
@@ -2715,3 +2715,119 @@ int ceph_pg_to_acting_primary(struct ceph_osdmap *osdmap,
 	return acting.primary;
 }
 EXPORT_SYMBOL(ceph_pg_to_acting_primary);
+
+static struct crush_loc_node *alloc_crush_loc(size_t type_name_len,
+					      size_t name_len)
+{
+	struct crush_loc_node *loc;
+
+	loc = kmalloc(sizeof(*loc) + type_name_len + name_len + 2, GFP_NOIO);
+	if (!loc)
+		return NULL;
+
+	RB_CLEAR_NODE(&loc->cl_node);
+	return loc;
+}
+
+static void free_crush_loc(struct crush_loc_node *loc)
+{
+	WARN_ON(!RB_EMPTY_NODE(&loc->cl_node));
+
+	kfree(loc);
+}
+
+static int crush_loc_compare(const struct crush_loc *loc1,
+			     const struct crush_loc *loc2)
+{
+	return strcmp(loc1->cl_type_name, loc2->cl_type_name) ?:
+	       strcmp(loc1->cl_name, loc2->cl_name);
+}
+
+DEFINE_RB_FUNCS2(crush_loc, struct crush_loc_node, cl_loc, crush_loc_compare,
+		 RB_BYPTR, const struct crush_loc *, cl_node)
+
+/*
+ * Parses a set of <bucket type name>':'<bucket name> pairs separated
+ * by '|', e.g. "rack:foo1|rack:foo2|datacenter:bar".
+ *
+ * Note that @crush_location is modified by strsep().
+ */
+int ceph_parse_crush_location(char *crush_location, struct rb_root *locs)
+{
+	struct crush_loc_node *loc;
+	const char *type_name, *name, *colon;
+	size_t type_name_len, name_len;
+
+	dout("%s '%s'\n", __func__, crush_location);
+	while ((type_name = strsep(&crush_location, "|"))) {
+		colon = strchr(type_name, ':');
+		if (!colon)
+			return -EINVAL;
+
+		type_name_len = colon - type_name;
+		if (type_name_len == 0)
+			return -EINVAL;
+
+		name = colon + 1;
+		name_len = strlen(name);
+		if (name_len == 0)
+			return -EINVAL;
+
+		loc = alloc_crush_loc(type_name_len, name_len);
+		if (!loc)
+			return -ENOMEM;
+
+		loc->cl_loc.cl_type_name = loc->cl_data;
+		memcpy(loc->cl_loc.cl_type_name, type_name, type_name_len);
+		loc->cl_loc.cl_type_name[type_name_len] = '\0';
+
+		loc->cl_loc.cl_name = loc->cl_data + type_name_len + 1;
+		memcpy(loc->cl_loc.cl_name, name, name_len);
+		loc->cl_loc.cl_name[name_len] = '\0';
+
+		if (!__insert_crush_loc(locs, loc)) {
+			free_crush_loc(loc);
+			return -EEXIST;
+		}
+
+		dout("%s type_name '%s' name '%s'\n", __func__,
+		     loc->cl_loc.cl_type_name, loc->cl_loc.cl_name);
+	}
+
+	return 0;
+}
+
+int ceph_compare_crush_locs(struct rb_root *locs1, struct rb_root *locs2)
+{
+	struct rb_node *n1 = rb_first(locs1);
+	struct rb_node *n2 = rb_first(locs2);
+	int ret;
+
+	for ( ; n1 && n2; n1 = rb_next(n1), n2 = rb_next(n2)) {
+		struct crush_loc_node *loc1 =
+		    rb_entry(n1, struct crush_loc_node, cl_node);
+		struct crush_loc_node *loc2 =
+		    rb_entry(n2, struct crush_loc_node, cl_node);
+
+		ret = crush_loc_compare(&loc1->cl_loc, &loc2->cl_loc);
+		if (ret)
+			return ret;
+	}
+
+	if (!n1 && n2)
+		return -1;
+	if (n1 && !n2)
+		return 1;
+	return 0;
+}
+
+void ceph_clear_crush_locs(struct rb_root *locs)
+{
+	while (!RB_EMPTY_ROOT(locs)) {
+		struct crush_loc_node *loc =
+		    rb_entry(rb_first(locs), struct crush_loc_node, cl_node);
+
+		erase_crush_loc(locs, loc);
+		free_crush_loc(loc);
+	}
+}
