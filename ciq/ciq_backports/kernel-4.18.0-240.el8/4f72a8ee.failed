drm/i915/tc: fix the reset of ln0

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Khaled Almahallawy <khaled.almahallawy@intel.com>
commit 4f72a8ee819d57d7329d88f487a2fc9b45153177
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/4f72a8ee.failed

Setting ln0 similar to ln1

Fixes: 3b51be4e4061b ("drm/i915/tc: Update DP_MODE programming")
	Cc: <stable@vger.kernel.org> # v5.5+
	Signed-off-by: Khaled Almahallawy <khaled.almahallawy@intel.com>
	Reviewed-by: Jos√© Roberto de Souza <jose.souza@intel.com>
	Signed-off-by: Imre Deak <imre.deak@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200608204537.28468-1-khaled.almahallawy@intel.com
(cherry picked from commit 4f72a8ee819d57d7329d88f487a2fc9b45153177)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_ddi.c
diff --cc drivers/gpu/drm/i915/display/intel_ddi.c
index fd58aa20d02e,1c0c369573e7..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@@ -2927,133 -3001,95 +2927,138 @@@ static void intel_ddi_clk_disable(struc
  	}
  }
  
 -static void
 -icl_program_mg_dp_mode(struct intel_digital_port *intel_dig_port,
 -		       const struct intel_crtc_state *crtc_state)
 +static void icl_enable_phy_clock_gating(struct intel_digital_port *dig_port)
  {
 -	struct drm_i915_private *dev_priv = to_i915(intel_dig_port->base.base.dev);
 -	enum tc_port tc_port = intel_port_to_tc(dev_priv, intel_dig_port->base.port);
 -	u32 ln0, ln1, pin_assignment;
 -	u8 width;
 +	struct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);
 +	enum port port = dig_port->base.port;
 +	enum tc_port tc_port = intel_port_to_tc(dev_priv, port);
 +	u32 val;
 +	int ln;
  
 -	if (intel_dig_port->tc_mode == TC_PORT_TBT_ALT)
 +	if (tc_port == PORT_TC_NONE)
  		return;
  
 -	if (INTEL_GEN(dev_priv) >= 12) {
 -		intel_de_write(dev_priv, HIP_INDEX_REG(tc_port),
 -			       HIP_INDEX_VAL(tc_port, 0x0));
 -		ln0 = intel_de_read(dev_priv, DKL_DP_MODE(tc_port));
 -		intel_de_write(dev_priv, HIP_INDEX_REG(tc_port),
 -			       HIP_INDEX_VAL(tc_port, 0x1));
 -		ln1 = intel_de_read(dev_priv, DKL_DP_MODE(tc_port));
 -	} else {
 -		ln0 = intel_de_read(dev_priv, MG_DP_MODE(0, tc_port));
 -		ln1 = intel_de_read(dev_priv, MG_DP_MODE(1, tc_port));
 +	for (ln = 0; ln < 2; ln++) {
 +		val = I915_READ(MG_DP_MODE(ln, port));
 +		val |= MG_DP_MODE_CFG_TR2PWR_GATING |
 +		       MG_DP_MODE_CFG_TRPWR_GATING |
 +		       MG_DP_MODE_CFG_CLNPWR_GATING |
 +		       MG_DP_MODE_CFG_DIGPWR_GATING |
 +		       MG_DP_MODE_CFG_GAONPWR_GATING;
 +		I915_WRITE(MG_DP_MODE(ln, port), val);
  	}
  
++<<<<<<< HEAD
 +	val = I915_READ(MG_MISC_SUS0(tc_port));
 +	val |= MG_MISC_SUS0_SUSCLK_DYNCLKGATE_MODE(3) |
 +	       MG_MISC_SUS0_CFG_TR2PWR_GATING |
 +	       MG_MISC_SUS0_CFG_CL2PWR_GATING |
 +	       MG_MISC_SUS0_CFG_GAONPWR_GATING |
 +	       MG_MISC_SUS0_CFG_TRPWR_GATING |
 +	       MG_MISC_SUS0_CFG_CL1PWR_GATING |
 +	       MG_MISC_SUS0_CFG_DGPWR_GATING;
 +	I915_WRITE(MG_MISC_SUS0(tc_port), val);
 +}
++=======
+ 	ln0 &= ~(MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE);
+ 	ln1 &= ~(MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE);
++>>>>>>> 4f72a8ee819d (drm/i915/tc: fix the reset of ln0)
  
 -	/* DPPATC */
 -	pin_assignment = intel_tc_port_get_pin_assignment_mask(intel_dig_port);
 -	width = crtc_state->lane_count;
 +static void icl_disable_phy_clock_gating(struct intel_digital_port *dig_port)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(dig_port->base.base.dev);
 +	enum port port = dig_port->base.port;
 +	enum tc_port tc_port = intel_port_to_tc(dev_priv, port);
 +	u32 val;
 +	int ln;
  
 -	switch (pin_assignment) {
 -	case 0x0:
 -		drm_WARN_ON(&dev_priv->drm,
 -			    intel_dig_port->tc_mode != TC_PORT_LEGACY);
 -		if (width == 1) {
 -			ln1 |= MG_DP_MODE_CFG_DP_X1_MODE;
 -		} else {
 -			ln0 |= MG_DP_MODE_CFG_DP_X2_MODE;
 -			ln1 |= MG_DP_MODE_CFG_DP_X2_MODE;
 -		}
 -		break;
 -	case 0x1:
 -		if (width == 4) {
 -			ln0 |= MG_DP_MODE_CFG_DP_X2_MODE;
 -			ln1 |= MG_DP_MODE_CFG_DP_X2_MODE;
 -		}
 -		break;
 -	case 0x2:
 -		if (width == 2) {
 -			ln0 |= MG_DP_MODE_CFG_DP_X2_MODE;
 -			ln1 |= MG_DP_MODE_CFG_DP_X2_MODE;
 -		}
 -		break;
 -	case 0x3:
 -	case 0x5:
 -		if (width == 1) {
 +	if (tc_port == PORT_TC_NONE)
 +		return;
 +
 +	for (ln = 0; ln < 2; ln++) {
 +		val = I915_READ(MG_DP_MODE(ln, port));
 +		val &= ~(MG_DP_MODE_CFG_TR2PWR_GATING |
 +			 MG_DP_MODE_CFG_TRPWR_GATING |
 +			 MG_DP_MODE_CFG_CLNPWR_GATING |
 +			 MG_DP_MODE_CFG_DIGPWR_GATING |
 +			 MG_DP_MODE_CFG_GAONPWR_GATING);
 +		I915_WRITE(MG_DP_MODE(ln, port), val);
 +	}
 +
 +	val = I915_READ(MG_MISC_SUS0(tc_port));
 +	val &= ~(MG_MISC_SUS0_SUSCLK_DYNCLKGATE_MODE_MASK |
 +		 MG_MISC_SUS0_CFG_TR2PWR_GATING |
 +		 MG_MISC_SUS0_CFG_CL2PWR_GATING |
 +		 MG_MISC_SUS0_CFG_GAONPWR_GATING |
 +		 MG_MISC_SUS0_CFG_TRPWR_GATING |
 +		 MG_MISC_SUS0_CFG_CL1PWR_GATING |
 +		 MG_MISC_SUS0_CFG_DGPWR_GATING);
 +	I915_WRITE(MG_MISC_SUS0(tc_port), val);
 +}
 +
 +static void icl_program_mg_dp_mode(struct intel_digital_port *intel_dig_port)
 +{
 +	struct drm_i915_private *dev_priv = to_i915(intel_dig_port->base.base.dev);
 +	enum port port = intel_dig_port->base.port;
 +	enum tc_port tc_port = intel_port_to_tc(dev_priv, port);
 +	u32 ln0, ln1, lane_info;
 +
 +	if (tc_port == PORT_TC_NONE || intel_dig_port->tc_type == TC_PORT_TBT)
 +		return;
 +
 +	ln0 = I915_READ(MG_DP_MODE(0, port));
 +	ln1 = I915_READ(MG_DP_MODE(1, port));
 +
 +	switch (intel_dig_port->tc_type) {
 +	case TC_PORT_TYPEC:
 +		ln0 &= ~(MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE);
 +		ln1 &= ~(MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE);
 +
 +		lane_info = (I915_READ(PORT_TX_DFLEXDPSP) &
 +			     DP_LANE_ASSIGNMENT_MASK(tc_port)) >>
 +			    DP_LANE_ASSIGNMENT_SHIFT(tc_port);
 +
 +		switch (lane_info) {
 +		case 0x1:
 +		case 0x4:
 +			break;
 +		case 0x2:
  			ln0 |= MG_DP_MODE_CFG_DP_X1_MODE;
 +			break;
 +		case 0x3:
 +			ln0 |= MG_DP_MODE_CFG_DP_X1_MODE |
 +			       MG_DP_MODE_CFG_DP_X2_MODE;
 +			break;
 +		case 0x8:
  			ln1 |= MG_DP_MODE_CFG_DP_X1_MODE;
 -		} else {
 -			ln0 |= MG_DP_MODE_CFG_DP_X2_MODE;
 -			ln1 |= MG_DP_MODE_CFG_DP_X2_MODE;
 +			break;
 +		case 0xC:
 +			ln1 |= MG_DP_MODE_CFG_DP_X1_MODE |
 +			       MG_DP_MODE_CFG_DP_X2_MODE;
 +			break;
 +		case 0xF:
 +			ln0 |= MG_DP_MODE_CFG_DP_X1_MODE |
 +			       MG_DP_MODE_CFG_DP_X2_MODE;
 +			ln1 |= MG_DP_MODE_CFG_DP_X1_MODE |
 +			       MG_DP_MODE_CFG_DP_X2_MODE;
 +			break;
 +		default:
 +			MISSING_CASE(lane_info);
  		}
  		break;
 -	case 0x4:
 -	case 0x6:
 -		if (width == 1) {
 -			ln0 |= MG_DP_MODE_CFG_DP_X1_MODE;
 -			ln1 |= MG_DP_MODE_CFG_DP_X1_MODE;
 -		} else {
 -			ln0 |= MG_DP_MODE_CFG_DP_X2_MODE;
 -			ln1 |= MG_DP_MODE_CFG_DP_X2_MODE;
 -		}
 +
 +	case TC_PORT_LEGACY:
 +		ln0 |= MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE;
 +		ln1 |= MG_DP_MODE_CFG_DP_X1_MODE | MG_DP_MODE_CFG_DP_X2_MODE;
  		break;
 +
  	default:
 -		MISSING_CASE(pin_assignment);
 +		MISSING_CASE(intel_dig_port->tc_type);
 +		return;
  	}
  
 -	if (INTEL_GEN(dev_priv) >= 12) {
 -		intel_de_write(dev_priv, HIP_INDEX_REG(tc_port),
 -			       HIP_INDEX_VAL(tc_port, 0x0));
 -		intel_de_write(dev_priv, DKL_DP_MODE(tc_port), ln0);
 -		intel_de_write(dev_priv, HIP_INDEX_REG(tc_port),
 -			       HIP_INDEX_VAL(tc_port, 0x1));
 -		intel_de_write(dev_priv, DKL_DP_MODE(tc_port), ln1);
 -	} else {
 -		intel_de_write(dev_priv, MG_DP_MODE(0, tc_port), ln0);
 -		intel_de_write(dev_priv, MG_DP_MODE(1, tc_port), ln1);
 -	}
 +	I915_WRITE(MG_DP_MODE(0, port), ln0);
 +	I915_WRITE(MG_DP_MODE(1, port), ln1);
  }
  
  static void intel_dp_sink_set_fec_ready(struct intel_dp *intel_dp,
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.c
