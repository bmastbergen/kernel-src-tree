net/mlx5: Accept flow rules without match

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mark Bloch <markb@mellanox.com>
commit 5c2aa8ae3a2ccb383647e3ade369b32e0710ef0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5c2aa8ae.failed

Allow passing NULL spec when creating a flow rule. Such rules will act
as "catch all" flow rules.

	Signed-off-by: Mark Bloch <markb@mellanox.com>
	Reviewed-by: Maor Gottlieb <maorg@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 5c2aa8ae3a2ccb383647e3ade369b32e0710ef0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 6b21d02803c5,54e5334f02a7..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1307,11 -1344,11 +1306,16 @@@ static int esw_vport_ingress_config(str
  		dst = &drop_ctr_dst;
  		dest_num++;
  	}
++<<<<<<< HEAD
 +	vport->ingress.drop_rule =
 +		mlx5_add_flow_rules(vport->ingress.acl, spec,
++=======
+ 	vport->ingress.legacy.drop_rule =
+ 		mlx5_add_flow_rules(vport->ingress.acl, NULL,
++>>>>>>> 5c2aa8ae3a2c (net/mlx5: Accept flow rules without match)
  				    &flow_act, dst, dest_num);
 -	if (IS_ERR(vport->ingress.legacy.drop_rule)) {
 -		err = PTR_ERR(vport->ingress.legacy.drop_rule);
 +	if (IS_ERR(vport->ingress.drop_rule)) {
 +		err = PTR_ERR(vport->ingress.drop_rule);
  		esw_warn(esw->dev,
  			 "vport[%d] configure ingress drop rule, err(%d)\n",
  			 vport->vport, err);
@@@ -1414,18 -1446,17 +1412,22 @@@ static int esw_vport_egress_config(stru
  		dst = &drop_ctr_dst;
  		dest_num++;
  	}
++<<<<<<< HEAD
 +	vport->egress.drop_rule =
 +		mlx5_add_flow_rules(vport->egress.acl, spec,
++=======
+ 	vport->egress.legacy.drop_rule =
+ 		mlx5_add_flow_rules(vport->egress.acl, NULL,
++>>>>>>> 5c2aa8ae3a2c (net/mlx5: Accept flow rules without match)
  				    &flow_act, dst, dest_num);
 -	if (IS_ERR(vport->egress.legacy.drop_rule)) {
 -		err = PTR_ERR(vport->egress.legacy.drop_rule);
 +	if (IS_ERR(vport->egress.drop_rule)) {
 +		err = PTR_ERR(vport->egress.drop_rule);
  		esw_warn(esw->dev,
  			 "vport[%d] configure egress drop rule failed, err(%d)\n",
  			 vport->vport, err);
 -		vport->egress.legacy.drop_rule = NULL;
 +		vport->egress.drop_rule = NULL;
  	}
- out:
- 	kvfree(spec);
+ 
  	return err;
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
index 2c75b2752f58..014639ea06e3 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_arfs.c
@@ -175,28 +175,20 @@ static int arfs_add_default_rule(struct mlx5e_priv *priv,
 	struct mlx5e_tir *tir = priv->indir_tir;
 	struct mlx5_flow_destination dest = {};
 	MLX5_DECLARE_FLOW_ACT(flow_act);
-	struct mlx5_flow_spec *spec;
 	enum mlx5e_traffic_types tt;
 	int err = 0;
 
-	spec = kvzalloc(sizeof(*spec), GFP_KERNEL);
-	if (!spec) {
-		err = -ENOMEM;
-		goto out;
-	}
-
 	dest.type = MLX5_FLOW_DESTINATION_TYPE_TIR;
 	tt = arfs_get_tt(type);
 	if (tt == -EINVAL) {
 		netdev_err(priv->netdev, "%s: bad arfs_type: %d\n",
 			   __func__, type);
-		err = -EINVAL;
-		goto out;
+		return -EINVAL;
 	}
 
 	dest.tir_num = tir[tt].tirn;
 
-	arfs_t->default_rule = mlx5_add_flow_rules(arfs_t->ft.t, spec,
+	arfs_t->default_rule = mlx5_add_flow_rules(arfs_t->ft.t, NULL,
 						   &flow_act,
 						   &dest, 1);
 	if (IS_ERR(arfs_t->default_rule)) {
@@ -205,8 +197,7 @@ static int arfs_add_default_rule(struct mlx5e_priv *priv,
 		netdev_err(priv->netdev, "%s: add rule failed, arfs type=%d\n",
 			   __func__, type);
 	}
-out:
-	kvfree(spec);
+
 	return err;
 }
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 98ef84b15725..304db1f06085 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@ -1819,7 +1819,6 @@ static int esw_vport_add_ingress_acl_modify_metadata(struct mlx5_eswitch *esw,
 						     struct mlx5_vport *vport)
 {
 	u8 action[MLX5_UN_SZ_BYTES(set_action_in_add_action_in_auto)] = {};
-	static const struct mlx5_flow_spec spec = {};
 	struct mlx5_flow_act flow_act = {};
 	int err = 0;
 	u32 key;
@@ -1851,7 +1850,7 @@ static int esw_vport_add_ingress_acl_modify_metadata(struct mlx5_eswitch *esw,
 	flow_act.modify_hdr = vport->ingress.offloads.modify_metadata;
 	vport->ingress.offloads.modify_metadata_rule =
 				mlx5_add_flow_rules(vport->ingress.acl,
-						    &spec, &flow_act, NULL, 0);
+						    NULL, &flow_act, NULL, 0);
 	if (IS_ERR(vport->ingress.offloads.modify_metadata_rule)) {
 		err = PTR_ERR(vport->ingress.offloads.modify_metadata_rule);
 		esw_warn(esw->dev,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_termtbl.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_termtbl.c
index f3a925e5ba88..269eddc3d38b 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_termtbl.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_termtbl.c
@@ -49,7 +49,6 @@ mlx5_eswitch_termtbl_create(struct mlx5_core_dev *dev,
 			    struct mlx5_termtbl_handle *tt,
 			    struct mlx5_flow_act *flow_act)
 {
-	static const struct mlx5_flow_spec spec = {};
 	struct mlx5_flow_table_attr ft_attr = {};
 	struct mlx5_flow_namespace *root_ns;
 	int err;
@@ -73,7 +72,7 @@ mlx5_eswitch_termtbl_create(struct mlx5_core_dev *dev,
 		return -EOPNOTSUPP;
 	}
 
-	tt->rule = mlx5_add_flow_rules(tt->termtbl, &spec, flow_act,
+	tt->rule = mlx5_add_flow_rules(tt->termtbl, NULL, flow_act,
 				       &tt->dest, 1);
 
 	if (IS_ERR(tt->rule)) {
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index 51d3fc82107b..0556d1d7d509 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@ -1845,12 +1845,16 @@ mlx5_add_flow_rules(struct mlx5_flow_table *ft,
 		    int num_dest)
 {
 	struct mlx5_flow_root_namespace *root = find_root(&ft->node);
+	static const struct mlx5_flow_spec zero_spec = {};
 	struct mlx5_flow_destination gen_dest = {};
 	struct mlx5_flow_table *next_ft = NULL;
 	struct mlx5_flow_handle *handle = NULL;
 	u32 sw_action = flow_act->action;
 	struct fs_prio *prio;
 
+	if (!spec)
+		spec = &zero_spec;
+
 	fs_get_obj(prio, ft->node.parent);
 	if (flow_act->action == MLX5_FLOW_CONTEXT_ACTION_FWD_NEXT_PRIO) {
 		if (!fwd_next_prio_supported(ft))
