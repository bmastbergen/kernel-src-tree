selftests/bpf: Add test for freplace program with write access

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Udip Pant <udippant@fb.com>
commit 6dc03dc71387e1dc65cf14efb49e5cf7062a2d46
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6dc03dc7.failed

This adds a selftest that tests the behavior when a freplace target program
attempts to make a write access on a packet. The expectation is that the read or write
access is granted based on the program type of the linked program and
not itself (which is of type, for e.g., BPF_PROG_TYPE_EXT).

This test fails without the associated patch on the verifier.

	Signed-off-by: Udip Pant <udippant@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200825232003.2877030-3-udippant@fb.com
(cherry picked from commit 6dc03dc71387e1dc65cf14efb49e5cf7062a2d46)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/prog_tests/fexit_bpf2bpf.c
#	tools/testing/selftests/bpf/progs/fexit_bpf2bpf.c
diff --cc tools/testing/selftests/bpf/prog_tests/fexit_bpf2bpf.c
index 7d3740d38965,7c7168963d52..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/fexit_bpf2bpf.c
+++ b/tools/testing/selftests/bpf/prog_tests/fexit_bpf2bpf.c
@@@ -103,7 -110,36 +103,40 @@@ static void test_target_yes_callees(voi
  	test_fexit_bpf2bpf_common("./fexit_bpf2bpf.o",
  				  "./test_pkt_access.o",
  				  ARRAY_SIZE(prog_name),
++<<<<<<< HEAD
 +				  prog_name);
++=======
+ 				  prog_name, true);
+ }
+ 
+ static void test_func_replace(void)
+ {
+ 	const char *prog_name[] = {
+ 		"fexit/test_pkt_access",
+ 		"fexit/test_pkt_access_subprog1",
+ 		"fexit/test_pkt_access_subprog2",
+ 		"fexit/test_pkt_access_subprog3",
+ 		"freplace/get_skb_len",
+ 		"freplace/get_skb_ifindex",
+ 		"freplace/get_constant",
+ 		"freplace/test_pkt_write_access_subprog",
+ 	};
+ 	test_fexit_bpf2bpf_common("./fexit_bpf2bpf.o",
+ 				  "./test_pkt_access.o",
+ 				  ARRAY_SIZE(prog_name),
+ 				  prog_name, true);
+ }
+ 
+ static void test_func_replace_verify(void)
+ {
+ 	const char *prog_name[] = {
+ 		"freplace/do_bind",
+ 	};
+ 	test_fexit_bpf2bpf_common("./freplace_connect4.o",
+ 				  "./connect4_prog.o",
+ 				  ARRAY_SIZE(prog_name),
+ 				  prog_name, false);
++>>>>>>> 6dc03dc71387 (selftests/bpf: Add test for freplace program with write access)
  }
  
  void test_fexit_bpf2bpf(void)
diff --cc tools/testing/selftests/bpf/progs/fexit_bpf2bpf.c
index 7c17ee159378,49a84a3a2306..000000000000
--- a/tools/testing/selftests/bpf/progs/fexit_bpf2bpf.c
+++ b/tools/testing/selftests/bpf/progs/fexit_bpf2bpf.c
@@@ -1,8 -1,13 +1,19 @@@
  // SPDX-License-Identifier: GPL-2.0
  /* Copyright (c) 2019 Facebook */
++<<<<<<< HEAD
 +#include <linux/bpf.h>
 +#include "bpf_helpers.h"
 +#include "bpf_trace_helpers.h"
++=======
+ #include <linux/stddef.h>
+ #include <linux/if_ether.h>
+ #include <linux/ipv6.h>
+ #include <linux/bpf.h>
+ #include <linux/tcp.h>
+ #include <bpf/bpf_helpers.h>
+ #include <bpf/bpf_endian.h>
+ #include <bpf/bpf_tracing.h>
++>>>>>>> 6dc03dc71387 (selftests/bpf: Add test for freplace program with write access)
  
  struct sk_buff {
  	unsigned int len;
@@@ -94,4 -99,83 +105,86 @@@ int BPF_PROG(test_subprog3, int val, st
  	test_result_subprog3 = 1;
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ __u64 test_get_skb_len = 0;
+ SEC("freplace/get_skb_len")
+ int new_get_skb_len(struct __sk_buff *skb)
+ {
+ 	int len = skb->len;
+ 
+ 	if (len != 74)
+ 		return 0;
+ 	test_get_skb_len = 1;
+ 	return 74; /* original get_skb_len() returns skb->len */
+ }
+ 
+ __u64 test_get_skb_ifindex = 0;
+ SEC("freplace/get_skb_ifindex")
+ int new_get_skb_ifindex(int val, struct __sk_buff *skb, int var)
+ {
+ 	void *data_end = (void *)(long)skb->data_end;
+ 	void *data = (void *)(long)skb->data;
+ 	struct ipv6hdr ip6, *ip6p;
+ 	int ifindex = skb->ifindex;
+ 	__u32 eth_proto;
+ 	__u32 nh_off;
+ 
+ 	/* check that BPF extension can read packet via direct packet access */
+ 	if (data + 14 + sizeof(ip6) > data_end)
+ 		return 0;
+ 	ip6p = data + 14;
+ 
+ 	if (ip6p->nexthdr != 6 || ip6p->payload_len != __bpf_constant_htons(123))
+ 		return 0;
+ 
+ 	/* check that legacy packet access helper works too */
+ 	if (bpf_skb_load_bytes(skb, 14, &ip6, sizeof(ip6)) < 0)
+ 		return 0;
+ 	ip6p = &ip6;
+ 	if (ip6p->nexthdr != 6 || ip6p->payload_len != __bpf_constant_htons(123))
+ 		return 0;
+ 
+ 	if (ifindex != 1 || val != 3 || var != 1)
+ 		return 0;
+ 	test_get_skb_ifindex = 1;
+ 	return 3; /* original get_skb_ifindex() returns val * ifindex * var */
+ }
+ 
+ volatile __u64 test_get_constant = 0;
+ SEC("freplace/get_constant")
+ int new_get_constant(long val)
+ {
+ 	if (val != 123)
+ 		return 0;
+ 	test_get_constant = 1;
+ 	return test_get_constant; /* original get_constant() returns val - 122 */
+ }
+ 
+ __u64 test_pkt_write_access_subprog = 0;
+ SEC("freplace/test_pkt_write_access_subprog")
+ int new_test_pkt_write_access_subprog(struct __sk_buff *skb, __u32 off)
+ {
+ 
+ 	void *data = (void *)(long)skb->data;
+ 	void *data_end = (void *)(long)skb->data_end;
+ 	struct tcphdr *tcp;
+ 
+ 	if (off > sizeof(struct ethhdr) + sizeof(struct ipv6hdr))
+ 		return -1;
+ 
+ 	tcp = data + off;
+ 	if (tcp + 1 > data_end)
+ 		return -1;
+ 
+ 	/* make modifications to the packet data */
+ 	tcp->check++;
+ 	tcp->syn = 0;
+ 
+ 	test_pkt_write_access_subprog = 1;
+ 	return 0;
+ }
+ 
++>>>>>>> 6dc03dc71387 (selftests/bpf: Add test for freplace program with write access)
  char _license[] SEC("license") = "GPL";
* Unmerged path tools/testing/selftests/bpf/prog_tests/fexit_bpf2bpf.c
* Unmerged path tools/testing/selftests/bpf/progs/fexit_bpf2bpf.c
diff --git a/tools/testing/selftests/bpf/progs/test_pkt_access.c b/tools/testing/selftests/bpf/progs/test_pkt_access.c
index 26c60f236f5a..9dbb609b08cc 100644
--- a/tools/testing/selftests/bpf/progs/test_pkt_access.c
+++ b/tools/testing/selftests/bpf/progs/test_pkt_access.c
@@ -76,6 +76,24 @@ int get_skb_ifindex(int val, struct __sk_buff *skb, int var)
 	return skb->ifindex * val * var;
 }
 
+__attribute__ ((noinline))
+int test_pkt_write_access_subprog(struct __sk_buff *skb, __u32 off)
+{
+	void *data = (void *)(long)skb->data;
+	void *data_end = (void *)(long)skb->data_end;
+	struct tcphdr *tcp = NULL;
+
+	if (off > sizeof(struct ethhdr) + sizeof(struct ipv6hdr))
+		return -1;
+
+	tcp = data + off;
+	if (tcp + 1 > data_end)
+		return -1;
+	/* make modification to the packet data */
+	tcp->check++;
+	return 0;
+}
+
 SEC("classifier/test_pkt_access")
 int test_pkt_access(struct __sk_buff *skb)
 {
@@ -114,6 +132,8 @@ int test_pkt_access(struct __sk_buff *skb)
 	if (test_pkt_access_subprog3(3, skb) != skb->len * 3 * skb->ifindex)
 		return TC_ACT_SHOT;
 	if (tcp) {
+		if (test_pkt_write_access_subprog(skb, (void *)tcp - data))
+			return TC_ACT_SHOT;
 		if (((void *)(tcp) + 20) > data_end || proto != 6)
 			return TC_ACT_SHOT;
 		barrier(); /* to force ordering of checks */
