iommu: Add recoverable fault reporting

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
commit bf3255b3cfe2d06280340dbac3f44b65d3ee6da3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/bf3255b3.failed

Some IOMMU hardware features, for example PCI PRI and Arm SMMU Stall,
enable recoverable I/O page faults. Allow IOMMU drivers to report PRI Page
Requests and Stall events through the new fault reporting API. The
consumer of the fault can be either an I/O page fault handler in the host,
or a guest OS.

Once handled, the fault must be completed by sending a page response back
to the IOMMU. Add an iommu_page_response() function to complete a page
fault.

There are two ways to extend the userspace API:
* Add a field to iommu_page_response and a flag to
  iommu_page_response::flags describing the validity of this field.
* Introduce a new iommu_page_response_X structure with a different version
  number. The kernel must then support both versions.

	Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Signed-off-by: Jean-Philippe Brucker <jean-philippe.brucker@arm.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit bf3255b3cfe2d06280340dbac3f44b65d3ee6da3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
#	include/linux/iommu.h
#	include/uapi/linux/iommu.h
diff --cc drivers/iommu/iommu.c
index 7d730a379980,ac1f29c19e59..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -915,6 -885,206 +915,209 @@@ int iommu_group_unregister_notifier(str
  EXPORT_SYMBOL_GPL(iommu_group_unregister_notifier);
  
  /**
++<<<<<<< HEAD
++=======
+  * iommu_register_device_fault_handler() - Register a device fault handler
+  * @dev: the device
+  * @handler: the fault handler
+  * @data: private data passed as argument to the handler
+  *
+  * When an IOMMU fault event is received, this handler gets called with the
+  * fault event and data as argument. The handler should return 0 on success. If
+  * the fault is recoverable (IOMMU_FAULT_PAGE_REQ), the consumer should also
+  * complete the fault by calling iommu_page_response() with one of the following
+  * response code:
+  * - IOMMU_PAGE_RESP_SUCCESS: retry the translation
+  * - IOMMU_PAGE_RESP_INVALID: terminate the fault
+  * - IOMMU_PAGE_RESP_FAILURE: terminate the fault and stop reporting
+  *   page faults if possible.
+  *
+  * Return 0 if the fault handler was installed successfully, or an error.
+  */
+ int iommu_register_device_fault_handler(struct device *dev,
+ 					iommu_dev_fault_handler_t handler,
+ 					void *data)
+ {
+ 	struct iommu_param *param = dev->iommu_param;
+ 	int ret = 0;
+ 
+ 	if (!param)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&param->lock);
+ 	/* Only allow one fault handler registered for each device */
+ 	if (param->fault_param) {
+ 		ret = -EBUSY;
+ 		goto done_unlock;
+ 	}
+ 
+ 	get_device(dev);
+ 	param->fault_param = kzalloc(sizeof(*param->fault_param), GFP_KERNEL);
+ 	if (!param->fault_param) {
+ 		put_device(dev);
+ 		ret = -ENOMEM;
+ 		goto done_unlock;
+ 	}
+ 	param->fault_param->handler = handler;
+ 	param->fault_param->data = data;
+ 	mutex_init(&param->fault_param->lock);
+ 	INIT_LIST_HEAD(&param->fault_param->faults);
+ 
+ done_unlock:
+ 	mutex_unlock(&param->lock);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(iommu_register_device_fault_handler);
+ 
+ /**
+  * iommu_unregister_device_fault_handler() - Unregister the device fault handler
+  * @dev: the device
+  *
+  * Remove the device fault handler installed with
+  * iommu_register_device_fault_handler().
+  *
+  * Return 0 on success, or an error.
+  */
+ int iommu_unregister_device_fault_handler(struct device *dev)
+ {
+ 	struct iommu_param *param = dev->iommu_param;
+ 	int ret = 0;
+ 
+ 	if (!param)
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&param->lock);
+ 
+ 	if (!param->fault_param)
+ 		goto unlock;
+ 
+ 	/* we cannot unregister handler if there are pending faults */
+ 	if (!list_empty(&param->fault_param->faults)) {
+ 		ret = -EBUSY;
+ 		goto unlock;
+ 	}
+ 
+ 	kfree(param->fault_param);
+ 	param->fault_param = NULL;
+ 	put_device(dev);
+ unlock:
+ 	mutex_unlock(&param->lock);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(iommu_unregister_device_fault_handler);
+ 
+ /**
+  * iommu_report_device_fault() - Report fault event to device driver
+  * @dev: the device
+  * @evt: fault event data
+  *
+  * Called by IOMMU drivers when a fault is detected, typically in a threaded IRQ
+  * handler. When this function fails and the fault is recoverable, it is the
+  * caller's responsibility to complete the fault.
+  *
+  * Return 0 on success, or an error.
+  */
+ int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt)
+ {
+ 	struct iommu_param *param = dev->iommu_param;
+ 	struct iommu_fault_event *evt_pending = NULL;
+ 	struct iommu_fault_param *fparam;
+ 	int ret = 0;
+ 
+ 	if (!param || !evt)
+ 		return -EINVAL;
+ 
+ 	/* we only report device fault if there is a handler registered */
+ 	mutex_lock(&param->lock);
+ 	fparam = param->fault_param;
+ 	if (!fparam || !fparam->handler) {
+ 		ret = -EINVAL;
+ 		goto done_unlock;
+ 	}
+ 
+ 	if (evt->fault.type == IOMMU_FAULT_PAGE_REQ &&
+ 	    (evt->fault.prm.flags & IOMMU_FAULT_PAGE_REQUEST_LAST_PAGE)) {
+ 		evt_pending = kmemdup(evt, sizeof(struct iommu_fault_event),
+ 				      GFP_KERNEL);
+ 		if (!evt_pending) {
+ 			ret = -ENOMEM;
+ 			goto done_unlock;
+ 		}
+ 		mutex_lock(&fparam->lock);
+ 		list_add_tail(&evt_pending->list, &fparam->faults);
+ 		mutex_unlock(&fparam->lock);
+ 	}
+ 
+ 	ret = fparam->handler(&evt->fault, fparam->data);
+ 	if (ret && evt_pending) {
+ 		mutex_lock(&fparam->lock);
+ 		list_del(&evt_pending->list);
+ 		mutex_unlock(&fparam->lock);
+ 		kfree(evt_pending);
+ 	}
+ done_unlock:
+ 	mutex_unlock(&param->lock);
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(iommu_report_device_fault);
+ 
+ int iommu_page_response(struct device *dev,
+ 			struct iommu_page_response *msg)
+ {
+ 	bool pasid_valid;
+ 	int ret = -EINVAL;
+ 	struct iommu_fault_event *evt;
+ 	struct iommu_fault_page_request *prm;
+ 	struct iommu_param *param = dev->iommu_param;
+ 	struct iommu_domain *domain = iommu_get_domain_for_dev(dev);
+ 
+ 	if (!domain || !domain->ops->page_response)
+ 		return -ENODEV;
+ 
+ 	if (!param || !param->fault_param)
+ 		return -EINVAL;
+ 
+ 	if (msg->version != IOMMU_PAGE_RESP_VERSION_1 ||
+ 	    msg->flags & ~IOMMU_PAGE_RESP_PASID_VALID)
+ 		return -EINVAL;
+ 
+ 	/* Only send response if there is a fault report pending */
+ 	mutex_lock(&param->fault_param->lock);
+ 	if (list_empty(&param->fault_param->faults)) {
+ 		dev_warn_ratelimited(dev, "no pending PRQ, drop response\n");
+ 		goto done_unlock;
+ 	}
+ 	/*
+ 	 * Check if we have a matching page request pending to respond,
+ 	 * otherwise return -EINVAL
+ 	 */
+ 	list_for_each_entry(evt, &param->fault_param->faults, list) {
+ 		prm = &evt->fault.prm;
+ 		pasid_valid = prm->flags & IOMMU_FAULT_PAGE_REQUEST_PASID_VALID;
+ 
+ 		if ((pasid_valid && prm->pasid != msg->pasid) ||
+ 		    prm->grpid != msg->grpid)
+ 			continue;
+ 
+ 		/* Sanitize the reply */
+ 		msg->flags = pasid_valid ? IOMMU_PAGE_RESP_PASID_VALID : 0;
+ 
+ 		ret = domain->ops->page_response(dev, evt, msg);
+ 		list_del(&evt->list);
+ 		kfree(evt);
+ 		break;
+ 	}
+ 
+ done_unlock:
+ 	mutex_unlock(&param->fault_param->lock);
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(iommu_page_response);
+ 
+ /**
++>>>>>>> bf3255b3cfe2 (iommu: Add recoverable fault reporting)
   * iommu_group_id - Return ID for a group
   * @group: the group to ID
   *
diff --cc include/linux/iommu.h
index c1d843935775,76c8cda61dfd..000000000000
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@@ -324,8 -287,11 +325,12 @@@ struct iommu_ops 
  				      void *drvdata);
  	void (*sva_unbind)(struct iommu_sva *handle);
  	int (*sva_get_pasid)(struct iommu_sva *handle);
 +	) /* RH_KABI_BROKEN_INSERT_BLOCK */
  
+ 	int (*page_response)(struct device *dev,
+ 			     struct iommu_fault_event *evt,
+ 			     struct iommu_page_response *msg);
+ 
  	unsigned long pgsize_bitmap;
  };
  
@@@ -343,6 -309,48 +348,51 @@@ struct iommu_device 
  	struct device *dev;
  };
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct iommu_fault_event - Generic fault event
+  *
+  * Can represent recoverable faults such as a page requests or
+  * unrecoverable faults such as DMA or IRQ remapping faults.
+  *
+  * @fault: fault descriptor
+  * @list: pending fault event list, used for tracking responses
+  */
+ struct iommu_fault_event {
+ 	struct iommu_fault fault;
+ 	struct list_head list;
+ };
+ 
+ /**
+  * struct iommu_fault_param - per-device IOMMU fault data
+  * @handler: Callback function to handle IOMMU faults at device level
+  * @data: handler private data
+  * @faults: holds the pending faults which needs response
+  * @lock: protect pending faults list
+  */
+ struct iommu_fault_param {
+ 	iommu_dev_fault_handler_t handler;
+ 	void *data;
+ 	struct list_head faults;
+ 	struct mutex lock;
+ };
+ 
+ /**
+  * struct iommu_param - collection of per-device IOMMU data
+  *
+  * @fault_param: IOMMU detected device fault reporting data
+  *
+  * TODO: migrate other per device data pointers under iommu_dev_data, e.g.
+  *	struct iommu_group	*iommu_group;
+  *	struct iommu_fwspec	*iommu_fwspec;
+  */
+ struct iommu_param {
+ 	struct mutex lock;
+ 	struct iommu_fault_param *fault_param;
+ };
+ 
++>>>>>>> bf3255b3cfe2 (iommu: Add recoverable fault reporting)
  int  iommu_device_register(struct iommu_device *iommu);
  void iommu_device_unregister(struct iommu_device *iommu);
  int  iommu_device_sysfs_add(struct iommu_device *iommu,
@@@ -444,6 -440,17 +494,20 @@@ extern int iommu_group_register_notifie
  					 struct notifier_block *nb);
  extern int iommu_group_unregister_notifier(struct iommu_group *group,
  					   struct notifier_block *nb);
++<<<<<<< HEAD
++=======
+ extern int iommu_register_device_fault_handler(struct device *dev,
+ 					iommu_dev_fault_handler_t handler,
+ 					void *data);
+ 
+ extern int iommu_unregister_device_fault_handler(struct device *dev);
+ 
+ extern int iommu_report_device_fault(struct device *dev,
+ 				     struct iommu_fault_event *evt);
+ extern int iommu_page_response(struct device *dev,
+ 			       struct iommu_page_response *msg);
+ 
++>>>>>>> bf3255b3cfe2 (iommu: Add recoverable fault reporting)
  extern int iommu_group_id(struct iommu_group *group);
  extern struct iommu_group *iommu_group_get_for_dev(struct device *dev);
  extern struct iommu_domain *iommu_group_default_domain(struct iommu_group *);
@@@ -786,6 -759,31 +850,34 @@@ static inline int iommu_group_unregiste
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static inline
+ int iommu_register_device_fault_handler(struct device *dev,
+ 					iommu_dev_fault_handler_t handler,
+ 					void *data)
+ {
+ 	return -ENODEV;
+ }
+ 
+ static inline int iommu_unregister_device_fault_handler(struct device *dev)
+ {
+ 	return 0;
+ }
+ 
+ static inline
+ int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt)
+ {
+ 	return -ENODEV;
+ }
+ 
+ static inline int iommu_page_response(struct device *dev,
+ 				      struct iommu_page_response *msg)
+ {
+ 	return -ENODEV;
+ }
+ 
++>>>>>>> bf3255b3cfe2 (iommu: Add recoverable fault reporting)
  static inline int iommu_group_id(struct iommu_group *group)
  {
  	return -ENODEV;
* Unmerged path include/uapi/linux/iommu.h
* Unmerged path drivers/iommu/iommu.c
* Unmerged path include/linux/iommu.h
* Unmerged path include/uapi/linux/iommu.h
