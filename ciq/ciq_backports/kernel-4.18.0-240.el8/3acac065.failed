dma-mapping: merge the generic remapping helpers into dma-direct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 3acac065508f6cc60ac9d3e4b7c6cc37fd91d531
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/3acac065.failed

Integrate the generic dma remapping implementation into the main flow.
This prepares for architectures like xtensa that use an uncached
segment for pages in the kernel mapping, but can also remap highmem
from CMA.  To simplify that implementation we now always deduct the
page from the physical address via the DMA address instead of the
virtual address.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Max Filippov <jcmvbkbc@gmail.com>
(cherry picked from commit 3acac065508f6cc60ac9d3e4b7c6cc37fd91d531)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/remap.c
diff --cc kernel/dma/remap.c
index eaac29ecf933,d47bd40fc0f5..000000000000
--- a/kernel/dma/remap.c
+++ b/kernel/dma/remap.c
@@@ -193,59 -210,4 +193,62 @@@ bool dma_free_from_pool(void *start, si
  	gen_pool_free(atomic_pool, (unsigned long)start, size);
  	return true;
  }
++<<<<<<< HEAD
 +
 +void *arch_dma_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,
 +		gfp_t flags, unsigned long attrs)
 +{
 +	struct page *page = NULL;
 +	void *ret;
 +
 +	size = PAGE_ALIGN(size);
 +
 +	if (!gfpflags_allow_blocking(flags)) {
 +		ret = dma_alloc_from_pool(size, &page, flags);
 +		if (!ret)
 +			return NULL;
 +		goto done;
 +	}
 +
 +	page = __dma_direct_alloc_pages(dev, size, flags, attrs);
 +	if (!page)
 +		return NULL;
 +
 +	/* remove any dirty cache lines on the kernel alias */
 +	arch_dma_prep_coherent(page, size);
 +
 +	/* create a coherent mapping */
 +	ret = dma_common_contiguous_remap(page, size, VM_USERMAP,
 +			dma_pgprot(dev, PAGE_KERNEL, attrs),
 +			__builtin_return_address(0));
 +	if (!ret) {
 +		dma_free_contiguous(dev, page, size);
 +		return ret;
 +	}
 +
 +	memset(ret, 0, size);
 +done:
 +	*dma_handle = phys_to_dma(dev, page_to_phys(page));
 +	return ret;
 +}
 +
 +void arch_dma_free(struct device *dev, size_t size, void *vaddr,
 +		dma_addr_t dma_handle, unsigned long attrs)
 +{
 +	if (!dma_free_from_pool(vaddr, PAGE_ALIGN(size))) {
 +		phys_addr_t phys = dma_to_phys(dev, dma_handle);
 +		struct page *page = pfn_to_page(__phys_to_pfn(phys));
 +
 +		vunmap(vaddr);
 +		dma_free_contiguous(dev, page, size);
 +	}
 +}
 +
 +long arch_dma_coherent_to_pfn(struct device *dev, void *cpu_addr,
 +		dma_addr_t dma_addr)
 +{
 +	return __phys_to_pfn(dma_to_phys(dev, dma_addr));
 +}
++=======
++>>>>>>> 3acac065508f (dma-mapping: merge the generic remapping helpers into dma-direct)
  #endif /* CONFIG_DMA_DIRECT_REMAP */
diff --git a/kernel/dma/direct.c b/kernel/dma/direct.c
index f4581748eeeb..7110ed5000ee 100644
--- a/kernel/dma/direct.c
+++ b/kernel/dma/direct.c
@@ -12,6 +12,7 @@
 #include <linux/dma-contiguous.h>
 #include <linux/dma-noncoherent.h>
 #include <linux/pfn.h>
+#include <linux/vmalloc.h>
 #include <linux/set_memory.h>
 #include <linux/swiotlb.h>
 
@@ -131,6 +132,15 @@ void *dma_direct_alloc_pages(struct device *dev, size_t size,
 	struct page *page;
 	void *ret;
 
+	if (IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&
+	    dma_alloc_need_uncached(dev, attrs) &&
+	    !gfpflags_allow_blocking(gfp)) {
+		ret = dma_alloc_from_pool(PAGE_ALIGN(size), &page, gfp);
+		if (!ret)
+			return NULL;
+		goto done;
+	}
+
 	page = __dma_direct_alloc_pages(dev, size, gfp, attrs);
 	if (!page)
 		return NULL;
@@ -140,9 +150,28 @@ void *dma_direct_alloc_pages(struct device *dev, size_t size,
 		/* remove any dirty cache lines on the kernel alias */
 		if (!PageHighMem(page))
 			arch_dma_prep_coherent(page, size);
-		*dma_handle = phys_to_dma(dev, page_to_phys(page));
 		/* return the page pointer as the opaque cookie */
-		return page;
+		ret = page;
+		goto done;
+	}
+
+	if ((IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&
+	     dma_alloc_need_uncached(dev, attrs)) ||
+	    (IS_ENABLED(CONFIG_DMA_REMAP) && PageHighMem(page))) {
+		/* remove any dirty cache lines on the kernel alias */
+		arch_dma_prep_coherent(page, PAGE_ALIGN(size));
+
+		/* create a coherent mapping */
+		ret = dma_common_contiguous_remap(page, PAGE_ALIGN(size),
+				dma_pgprot(dev, PAGE_KERNEL, attrs),
+				__builtin_return_address(0));
+		if (!ret) {
+			dma_free_contiguous(dev, page, size);
+			return ret;
+		}
+
+		memset(ret, 0, size);
+		goto done;
 	}
 
 	if (PageHighMem(page)) {
@@ -158,12 +187,9 @@ void *dma_direct_alloc_pages(struct device *dev, size_t size,
 	}
 
 	ret = page_address(page);
-	if (force_dma_unencrypted(dev)) {
+	if (force_dma_unencrypted(dev))
 		set_memory_decrypted((unsigned long)ret, 1 << get_order(size));
-		*dma_handle = __phys_to_dma(dev, page_to_phys(page));
-	} else {
-		*dma_handle = phys_to_dma(dev, page_to_phys(page));
-	}
+
 	memset(ret, 0, size);
 
 	if (IS_ENABLED(CONFIG_ARCH_HAS_UNCACHED_SEGMENT) &&
@@ -171,7 +197,11 @@ void *dma_direct_alloc_pages(struct device *dev, size_t size,
 		arch_dma_prep_coherent(page, size);
 		ret = uncached_kernel_address(ret);
 	}
-
+done:
+	if (force_dma_unencrypted(dev))
+		*dma_handle = __phys_to_dma(dev, page_to_phys(page));
+	else
+		*dma_handle = phys_to_dma(dev, page_to_phys(page));
 	return ret;
 }
 
@@ -187,19 +217,24 @@ void dma_direct_free_pages(struct device *dev, size_t size, void *cpu_addr,
 		return;
 	}
 
+	if (IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&
+	    dma_free_from_pool(cpu_addr, PAGE_ALIGN(size)))
+		return;
+
 	if (force_dma_unencrypted(dev))
 		set_memory_encrypted((unsigned long)cpu_addr, 1 << page_order);
 
-	if (IS_ENABLED(CONFIG_ARCH_HAS_UNCACHED_SEGMENT) &&
-	    dma_alloc_need_uncached(dev, attrs))
-		cpu_addr = cached_kernel_address(cpu_addr);
-	dma_free_contiguous(dev, virt_to_page(cpu_addr), size);
+	if (IS_ENABLED(CONFIG_DMA_REMAP) && is_vmalloc_addr(cpu_addr))
+		vunmap(cpu_addr);
+
+	dma_free_contiguous(dev, dma_direct_to_page(dev, dma_addr), size);
 }
 
 void *dma_direct_alloc(struct device *dev, size_t size,
 		dma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)
 {
 	if (!IS_ENABLED(CONFIG_ARCH_HAS_UNCACHED_SEGMENT) &&
+	    !IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&
 	    dma_alloc_need_uncached(dev, attrs))
 		return arch_dma_alloc(dev, size, dma_handle, gfp, attrs);
 	return dma_direct_alloc_pages(dev, size, dma_handle, gfp, attrs);
@@ -209,6 +244,7 @@ void dma_direct_free(struct device *dev, size_t size,
 		void *cpu_addr, dma_addr_t dma_addr, unsigned long attrs)
 {
 	if (!IS_ENABLED(CONFIG_ARCH_HAS_UNCACHED_SEGMENT) &&
+	    !IS_ENABLED(CONFIG_DMA_DIRECT_REMAP) &&
 	    dma_alloc_need_uncached(dev, attrs))
 		arch_dma_free(dev, size, cpu_addr, dma_addr, attrs);
 	else
* Unmerged path kernel/dma/remap.c
