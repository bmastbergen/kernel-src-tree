nvme-tcp: don't poll a non-live queue

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sagi Grimberg <sagi@grimberg.me>
commit f86e5bf817a57c7e6538dafee2fc65a525bb9935
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f86e5bf8.failed

In error recovery we might be removing the queue so check we
can actually poll before we do.

	Reported-by: Mark Wunderlich <mark.wunderlich@intel.com>
	Tested-by: Mark Wunderlich <mark.wunderlich@intel.com>
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Keith Busch <kbusch@kernel.org>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit f86e5bf817a57c7e6538dafee2fc65a525bb9935)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/tcp.c
diff --cc drivers/nvme/host/tcp.c
index 4bc45ce806ec,eb31c689d2cf..000000000000
--- a/drivers/nvme/host/tcp.c
+++ b/drivers/nvme/host/tcp.c
@@@ -2245,6 -2294,20 +2245,23 @@@ static int nvme_tcp_map_queues(struct b
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int nvme_tcp_poll(struct blk_mq_hw_ctx *hctx)
+ {
+ 	struct nvme_tcp_queue *queue = hctx->driver_data;
+ 	struct sock *sk = queue->sock->sk;
+ 
+ 	if (!test_bit(NVME_TCP_Q_LIVE, &queue->flags))
+ 		return 0;
+ 
+ 	if (sk_can_busy_loop(sk) && skb_queue_empty_lockless(&sk->sk_receive_queue))
+ 		sk_busy_loop(sk, true);
+ 	nvme_tcp_try_recv(queue);
+ 	return queue->nr_cqe;
+ }
+ 
++>>>>>>> f86e5bf817a5 (nvme-tcp: don't poll a non-live queue)
  static struct blk_mq_ops nvme_tcp_mq_ops = {
  	.queue_rq	= nvme_tcp_queue_rq,
  	.complete	= nvme_complete_rq,
* Unmerged path drivers/nvme/host/tcp.c
