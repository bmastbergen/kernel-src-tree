perf tools: Rename 'struct perf_mmap' to 'struct mmap'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit a583053299c1e66e6202b494cbc3acd93cedc4cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a5830532.failed

Rename 'struct perf_evlist' to 'struct evlist', so we don't have a name
clash when we add 'struct perf_mmap' to libperf.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lore.kernel.org/lkml/20190913132355.21634-4-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit a583053299c1e66e6202b494cbc3acd93cedc4cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-record.c
#	tools/perf/builtin-top.c
#	tools/perf/tests/sw-clock.c
#	tools/perf/tests/task-exit.c
#	tools/perf/util/evlist.c
#	tools/perf/util/evlist.h
#	tools/perf/util/python.c
diff --cc tools/perf/builtin-record.c
index de0619148499,1528fb686f96..000000000000
--- a/tools/perf/builtin-record.c
+++ b/tools/perf/builtin-record.c
@@@ -347,8 -350,8 +347,13 @@@ static void record__aio_set_pos(int tra
  static void record__aio_mmap_read_sync(struct record *rec)
  {
  	int i;
++<<<<<<< HEAD
 +	struct perf_evlist *evlist = rec->evlist;
 +	struct perf_mmap *maps = evlist->mmap;
++=======
+ 	struct evlist *evlist = rec->evlist;
+ 	struct mmap *maps = evlist->mmap;
++>>>>>>> a583053299c1 (perf tools: Rename 'struct perf_mmap' to 'struct mmap')
  
  	if (!record__aio_enabled(rec))
  		return;
diff --cc tools/perf/builtin-top.c
index 95aec2602043,834a927107c4..000000000000
--- a/tools/perf/builtin-top.c
+++ b/tools/perf/builtin-top.c
@@@ -867,8 -862,8 +867,13 @@@ static u64 last_timestamp
  static void perf_top__mmap_read_idx(struct perf_top *top, int idx)
  {
  	struct record_opts *opts = &top->record_opts;
++<<<<<<< HEAD
 +	struct perf_evlist *evlist = top->evlist;
 +	struct perf_mmap *md;
++=======
+ 	struct evlist *evlist = top->evlist;
+ 	struct mmap *md;
++>>>>>>> a583053299c1 (perf tools: Rename 'struct perf_mmap' to 'struct mmap')
  	union perf_event *event;
  
  	md = opts->overwrite ? &evlist->overwrite_mmap[idx] : &evlist->mmap[idx];
diff --cc tools/perf/tests/sw-clock.c
index f9490b237893,7abe0b6aabb7..000000000000
--- a/tools/perf/tests/sw-clock.c
+++ b/tools/perf/tests/sw-clock.c
@@@ -37,9 -40,9 +37,15 @@@ static int __test__sw_clock_freq(enum p
  		.disabled = 1,
  		.freq = 1,
  	};
++<<<<<<< HEAD
 +	struct cpu_map *cpus;
 +	struct thread_map *threads;
 +	struct perf_mmap *md;
++=======
+ 	struct perf_cpu_map *cpus;
+ 	struct perf_thread_map *threads;
+ 	struct mmap *md;
++>>>>>>> a583053299c1 (perf tools: Rename 'struct perf_mmap' to 'struct mmap')
  
  	attr.sample_freq = 500;
  
diff --cc tools/perf/tests/task-exit.c
index e92fa6029ac7,cff99707cc9d..000000000000
--- a/tools/perf/tests/task-exit.c
+++ b/tools/perf/tests/task-exit.c
@@@ -45,9 -49,9 +45,15 @@@ int test__task_exit(struct test *test _
  	};
  	const char *argv[] = { "true", NULL };
  	char sbuf[STRERR_BUFSIZE];
++<<<<<<< HEAD
 +	struct cpu_map *cpus;
 +	struct thread_map *threads;
 +	struct perf_mmap *md;
++=======
+ 	struct perf_cpu_map *cpus;
+ 	struct perf_thread_map *threads;
+ 	struct mmap *md;
++>>>>>>> a583053299c1 (perf tools: Rename 'struct perf_mmap' to 'struct mmap')
  
  	signal(SIGCHLD, sig_handler);
  
diff --cc tools/perf/util/evlist.c
index 29a998d183ce,ceab9fb7f7f9..000000000000
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@@ -445,8 -422,8 +445,13 @@@ int perf_evlist__alloc_pollfd(struct pe
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int __perf_evlist__add_pollfd(struct perf_evlist *evlist, int fd,
 +				     struct perf_mmap *map, short revent)
++=======
+ static int __perf_evlist__add_pollfd(struct evlist *evlist, int fd,
+ 				     struct mmap *map, short revent)
++>>>>>>> a583053299c1 (perf tools: Rename 'struct perf_mmap' to 'struct mmap')
  {
  	int pos = fdarray__add(&evlist->pollfd, fd, revent | POLLERR | POLLHUP);
  	/*
@@@ -716,16 -693,16 +721,27 @@@ void perf_evlist__munmap(struct perf_ev
  	zfree(&evlist->overwrite_mmap);
  }
  
++<<<<<<< HEAD
 +static struct perf_mmap *perf_evlist__alloc_mmap(struct perf_evlist *evlist,
++=======
+ static struct mmap *perf_evlist__alloc_mmap(struct evlist *evlist,
++>>>>>>> a583053299c1 (perf tools: Rename 'struct perf_mmap' to 'struct mmap')
  						 bool overwrite)
  {
  	int i;
- 	struct perf_mmap *map;
+ 	struct mmap *map;
  
++<<<<<<< HEAD
 +	evlist->nr_mmaps = cpu_map__nr(evlist->cpus);
 +	if (cpu_map__empty(evlist->cpus))
 +		evlist->nr_mmaps = thread_map__nr(evlist->threads);
 +	map = zalloc(evlist->nr_mmaps * sizeof(struct perf_mmap));
++=======
+ 	evlist->nr_mmaps = perf_cpu_map__nr(evlist->core.cpus);
+ 	if (perf_cpu_map__empty(evlist->core.cpus))
+ 		evlist->nr_mmaps = perf_thread_map__nr(evlist->core.threads);
+ 	map = zalloc(evlist->nr_mmaps * sizeof(struct mmap));
++>>>>>>> a583053299c1 (perf tools: Rename 'struct perf_mmap' to 'struct mmap')
  	if (!map)
  		return NULL;
  
@@@ -759,12 -736,12 +775,12 @@@ static int perf_evlist__mmap_per_evsel(
  				       struct mmap_params *mp, int cpu_idx,
  				       int thread, int *_output, int *_output_overwrite)
  {
 -	struct evsel *evsel;
 +	struct perf_evsel *evsel;
  	int revent;
 -	int evlist_cpu = cpu_map__cpu(evlist->core.cpus, cpu_idx);
 +	int evlist_cpu = cpu_map__cpu(evlist->cpus, cpu_idx);
  
  	evlist__for_each_entry(evlist, evsel) {
- 		struct perf_mmap *maps = evlist->mmap;
+ 		struct mmap *maps = evlist->mmap;
  		int *output = _output;
  		int fd;
  		int cpu;
diff --cc tools/perf/util/evlist.h
index 49354fe24d5f,129786361572..000000000000
--- a/tools/perf/util/evlist.h
+++ b/tools/perf/util/evlist.h
@@@ -42,14 -39,12 +42,20 @@@ struct perf_evlist 
  		pid_t	pid;
  	} workload;
  	struct fdarray	 pollfd;
++<<<<<<< HEAD
 +	struct perf_mmap *mmap;
 +	struct perf_mmap *overwrite_mmap;
 +	struct thread_map *threads;
 +	struct cpu_map	  *cpus;
 +	struct perf_evsel *selected;
++=======
+ 	struct mmap *mmap;
+ 	struct mmap *overwrite_mmap;
+ 	struct evsel *selected;
++>>>>>>> a583053299c1 (perf tools: Rename 'struct perf_mmap' to 'struct mmap')
  	struct events_stats stats;
  	struct perf_env	*env;
 -	void (*trace_event_sample_raw)(struct evlist *evlist,
 +	void (*trace_event_sample_raw)(struct perf_evlist *evlist,
  				       union perf_event *event,
  				       struct perf_sample *sample);
  	u64		first_sample_time;
diff --cc tools/perf/util/python.c
index 9c3b43665909,1e1247cffea8..000000000000
--- a/tools/perf/util/python.c
+++ b/tools/perf/util/python.c
@@@ -973,13 -978,13 +973,17 @@@ static PyObject *pyrf_evlist__add(struc
  
  	Py_INCREF(pevsel);
  	evsel = &((struct pyrf_evsel *)pevsel)->evsel;
 -	evsel->idx = evlist->core.nr_entries;
 -	evlist__add(evlist, evsel);
 +	evsel->idx = evlist->nr_entries;
 +	perf_evlist__add(evlist, evsel);
  
 -	return Py_BuildValue("i", evlist->core.nr_entries);
 +	return Py_BuildValue("i", evlist->nr_entries);
  }
  
++<<<<<<< HEAD
 +static struct perf_mmap *get_md(struct perf_evlist *evlist, int cpu)
++=======
+ static struct mmap *get_md(struct evlist *evlist, int cpu)
++>>>>>>> a583053299c1 (perf tools: Rename 'struct perf_mmap' to 'struct mmap')
  {
  	int i;
  
diff --git a/tools/perf/arch/x86/tests/perf-time-to-tsc.c b/tools/perf/arch/x86/tests/perf-time-to-tsc.c
index 7a7721604b86..f8210036dbce 100644
--- a/tools/perf/arch/x86/tests/perf-time-to-tsc.c
+++ b/tools/perf/arch/x86/tests/perf-time-to-tsc.c
@@ -60,7 +60,7 @@ int test__perf_time_to_tsc(struct test *test __maybe_unused, int subtest __maybe
 	union perf_event *event;
 	u64 test_tsc, comm1_tsc, comm2_tsc;
 	u64 test_time, comm1_time = 0, comm2_time = 0;
-	struct perf_mmap *md;
+	struct mmap *md;
 
 	threads = thread_map__new(-1, getpid(), UINT_MAX);
 	CHECK_NOT_NULL__(threads);
diff --git a/tools/perf/builtin-kvm.c b/tools/perf/builtin-kvm.c
index d30bd54b42ac..a9544f913549 100644
--- a/tools/perf/builtin-kvm.c
+++ b/tools/perf/builtin-kvm.c
@@ -746,7 +746,7 @@ static s64 perf_kvm__mmap_read_idx(struct perf_kvm_stat *kvm, int idx,
 {
 	struct perf_evlist *evlist = kvm->evlist;
 	union perf_event *event;
-	struct perf_mmap *md;
+	struct mmap *md;
 	u64 timestamp;
 	s64 n = 0;
 	int err;
* Unmerged path tools/perf/builtin-record.c
* Unmerged path tools/perf/builtin-top.c
diff --git a/tools/perf/builtin-trace.c b/tools/perf/builtin-trace.c
index 4b81b4c2c4c2..7985cc5ddaac 100644
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@ -3437,7 +3437,7 @@ static int trace__run(struct trace *trace, int argc, const char **argv)
 
 	for (i = 0; i < evlist->nr_mmaps; i++) {
 		union perf_event *event;
-		struct perf_mmap *md;
+		struct mmap *md;
 
 		md = &evlist->mmap[i];
 		if (perf_mmap__read_init(md) < 0)
diff --git a/tools/perf/tests/backward-ring-buffer.c b/tools/perf/tests/backward-ring-buffer.c
index 1a9c3becf5ff..4cda822ad15d 100644
--- a/tools/perf/tests/backward-ring-buffer.c
+++ b/tools/perf/tests/backward-ring-buffer.c
@@ -31,7 +31,7 @@ static int count_samples(struct perf_evlist *evlist, int *sample_count,
 	int i;
 
 	for (i = 0; i < evlist->nr_mmaps; i++) {
-		struct perf_mmap *map = &evlist->overwrite_mmap[i];
+		struct mmap *map = &evlist->overwrite_mmap[i];
 		union perf_event *event;
 
 		perf_mmap__read_init(map);
diff --git a/tools/perf/tests/bpf.c b/tools/perf/tests/bpf.c
index c9e4cdc4c9c8..08f74f8e4a5a 100644
--- a/tools/perf/tests/bpf.c
+++ b/tools/perf/tests/bpf.c
@@ -177,7 +177,7 @@ static int do_test(struct bpf_object *obj, int (*func)(void),
 
 	for (i = 0; i < evlist->nr_mmaps; i++) {
 		union perf_event *event;
-		struct perf_mmap *md;
+		struct mmap *md;
 
 		md = &evlist->mmap[i];
 		if (perf_mmap__read_init(md) < 0)
diff --git a/tools/perf/tests/code-reading.c b/tools/perf/tests/code-reading.c
index aa6df122b175..42697a57d227 100644
--- a/tools/perf/tests/code-reading.c
+++ b/tools/perf/tests/code-reading.c
@@ -412,7 +412,7 @@ static int process_events(struct machine *machine, struct perf_evlist *evlist,
 			  struct state *state)
 {
 	union perf_event *event;
-	struct perf_mmap *md;
+	struct mmap *md;
 	int i, ret;
 
 	for (i = 0; i < evlist->nr_mmaps; i++) {
diff --git a/tools/perf/tests/keep-tracking.c b/tools/perf/tests/keep-tracking.c
index 17c46f3e6f1e..01987a4f8a1a 100644
--- a/tools/perf/tests/keep-tracking.c
+++ b/tools/perf/tests/keep-tracking.c
@@ -27,7 +27,7 @@
 static int find_comm(struct perf_evlist *evlist, const char *comm)
 {
 	union perf_event *event;
-	struct perf_mmap *md;
+	struct mmap *md;
 	int i, found;
 
 	found = 0;
diff --git a/tools/perf/tests/mmap-basic.c b/tools/perf/tests/mmap-basic.c
index 0919b0793e5b..c9a69aba26c7 100644
--- a/tools/perf/tests/mmap-basic.c
+++ b/tools/perf/tests/mmap-basic.c
@@ -38,7 +38,7 @@ int test__basic_mmap(struct test *test __maybe_unused, int subtest __maybe_unuse
 		     expected_nr_events[nsyscalls], i, j;
 	struct perf_evsel *evsels[nsyscalls], *evsel;
 	char sbuf[STRERR_BUFSIZE];
-	struct perf_mmap *md;
+	struct mmap *md;
 
 	threads = thread_map__new(-1, getpid(), UINT_MAX);
 	if (threads == NULL) {
diff --git a/tools/perf/tests/openat-syscall-tp-fields.c b/tools/perf/tests/openat-syscall-tp-fields.c
index 344dc3ac2469..27b7d2b4d7dd 100644
--- a/tools/perf/tests/openat-syscall-tp-fields.c
+++ b/tools/perf/tests/openat-syscall-tp-fields.c
@@ -86,7 +86,7 @@ int test__syscall_openat_tp_fields(struct test *test __maybe_unused, int subtest
 
 		for (i = 0; i < evlist->nr_mmaps; i++) {
 			union perf_event *event;
-			struct perf_mmap *md;
+			struct mmap *md;
 
 			md = &evlist->mmap[i];
 			if (perf_mmap__read_init(md) < 0)
diff --git a/tools/perf/tests/perf-record.c b/tools/perf/tests/perf-record.c
index 07f6bd8ed719..939062184cf9 100644
--- a/tools/perf/tests/perf-record.c
+++ b/tools/perf/tests/perf-record.c
@@ -165,7 +165,7 @@ int test__PERF_RECORD(struct test *test __maybe_unused, int subtest __maybe_unus
 
 		for (i = 0; i < evlist->nr_mmaps; i++) {
 			union perf_event *event;
-			struct perf_mmap *md;
+			struct mmap *md;
 
 			md = &evlist->mmap[i];
 			if (perf_mmap__read_init(md) < 0)
* Unmerged path tools/perf/tests/sw-clock.c
diff --git a/tools/perf/tests/switch-tracking.c b/tools/perf/tests/switch-tracking.c
index 6cdab5f4812a..b3a5c42f3dbe 100644
--- a/tools/perf/tests/switch-tracking.c
+++ b/tools/perf/tests/switch-tracking.c
@@ -259,7 +259,7 @@ static int process_events(struct perf_evlist *evlist,
 	unsigned pos, cnt = 0;
 	LIST_HEAD(events);
 	struct event_node *events_array, *node;
-	struct perf_mmap *md;
+	struct mmap *md;
 	int i, ret;
 
 	for (i = 0; i < evlist->nr_mmaps; i++) {
* Unmerged path tools/perf/tests/task-exit.c
diff --git a/tools/perf/util/auxtrace.c b/tools/perf/util/auxtrace.c
index 2e60b09cfd97..83937e9d2be7 100644
--- a/tools/perf/util/auxtrace.c
+++ b/tools/perf/util/auxtrace.c
@@ -1234,7 +1234,7 @@ int perf_event__process_auxtrace_error(struct perf_session *session,
 	return 0;
 }
 
-static int __auxtrace_mmap__read(struct perf_mmap *map,
+static int __auxtrace_mmap__read(struct mmap *map,
 				 struct auxtrace_record *itr,
 				 struct perf_tool *tool, process_auxtrace_t fn,
 				 bool snapshot, size_t snapshot_size)
@@ -1345,13 +1345,13 @@ static int __auxtrace_mmap__read(struct perf_mmap *map,
 	return 1;
 }
 
-int auxtrace_mmap__read(struct perf_mmap *map, struct auxtrace_record *itr,
+int auxtrace_mmap__read(struct mmap *map, struct auxtrace_record *itr,
 			struct perf_tool *tool, process_auxtrace_t fn)
 {
 	return __auxtrace_mmap__read(map, itr, tool, fn, false, 0);
 }
 
-int auxtrace_mmap__read_snapshot(struct perf_mmap *map,
+int auxtrace_mmap__read_snapshot(struct mmap *map,
 				 struct auxtrace_record *itr,
 				 struct perf_tool *tool, process_auxtrace_t fn,
 				 size_t snapshot_size)
diff --git a/tools/perf/util/auxtrace.h b/tools/perf/util/auxtrace.h
index 1a3ea1523cb0..708b0acc2993 100644
--- a/tools/perf/util/auxtrace.h
+++ b/tools/perf/util/auxtrace.h
@@ -34,7 +34,7 @@ union perf_event;
 struct perf_session;
 struct perf_evlist;
 struct perf_tool;
-struct perf_mmap;
+struct mmap;
 struct perf_sample;
 struct option;
 struct record_opts;
@@ -449,14 +449,14 @@ void auxtrace_mmap_params__set_idx(struct auxtrace_mmap_params *mp,
 				   bool per_cpu);
 
 typedef int (*process_auxtrace_t)(struct perf_tool *tool,
-				  struct perf_mmap *map,
+				  struct mmap *map,
 				  union perf_event *event, void *data1,
 				  size_t len1, void *data2, size_t len2);
 
-int auxtrace_mmap__read(struct perf_mmap *map, struct auxtrace_record *itr,
+int auxtrace_mmap__read(struct mmap *map, struct auxtrace_record *itr,
 			struct perf_tool *tool, process_auxtrace_t fn);
 
-int auxtrace_mmap__read_snapshot(struct perf_mmap *map,
+int auxtrace_mmap__read_snapshot(struct mmap *map,
 				 struct auxtrace_record *itr,
 				 struct perf_tool *tool, process_auxtrace_t fn,
 				 size_t snapshot_size);
* Unmerged path tools/perf/util/evlist.c
* Unmerged path tools/perf/util/evlist.h
diff --git a/tools/perf/util/mmap.c b/tools/perf/util/mmap.c
index 850493205040..5bff271251a9 100644
--- a/tools/perf/util/mmap.c
+++ b/tools/perf/util/mmap.c
@@ -19,13 +19,13 @@
 #include "mmap.h"
 #include "util.h" /* page_size */
 
-size_t perf_mmap__mmap_len(struct perf_mmap *map)
+size_t perf_mmap__mmap_len(struct mmap *map)
 {
 	return map->mask + 1 + page_size;
 }
 
 /* When check_messup is true, 'end' must points to a good entry */
-static union perf_event *perf_mmap__read(struct perf_mmap *map,
+static union perf_event *perf_mmap__read(struct mmap *map,
 					 u64 *startp, u64 end)
 {
 	unsigned char *data = map->base + page_size;
@@ -79,7 +79,7 @@ static union perf_event *perf_mmap__read(struct perf_mmap *map,
  * }
  * perf_mmap__read_done()
  */
-union perf_event *perf_mmap__read_event(struct perf_mmap *map)
+union perf_event *perf_mmap__read_event(struct mmap *map)
 {
 	union perf_event *event;
 
@@ -101,17 +101,17 @@ union perf_event *perf_mmap__read_event(struct perf_mmap *map)
 	return event;
 }
 
-static bool perf_mmap__empty(struct perf_mmap *map)
+static bool perf_mmap__empty(struct mmap *map)
 {
 	return perf_mmap__read_head(map) == map->prev && !map->auxtrace_mmap.base;
 }
 
-void perf_mmap__get(struct perf_mmap *map)
+void perf_mmap__get(struct mmap *map)
 {
 	refcount_inc(&map->refcnt);
 }
 
-void perf_mmap__put(struct perf_mmap *map)
+void perf_mmap__put(struct mmap *map)
 {
 	BUG_ON(map->base && refcount_read(&map->refcnt) == 0);
 
@@ -119,7 +119,7 @@ void perf_mmap__put(struct perf_mmap *map)
 		perf_mmap__munmap(map);
 }
 
-void perf_mmap__consume(struct perf_mmap *map)
+void perf_mmap__consume(struct mmap *map)
 {
 	if (!map->overwrite) {
 		u64 old = map->prev;
@@ -158,13 +158,13 @@ void __weak auxtrace_mmap_params__set_idx(struct auxtrace_mmap_params *mp __mayb
 }
 
 #ifdef HAVE_AIO_SUPPORT
-static int perf_mmap__aio_enabled(struct perf_mmap *map)
+static int perf_mmap__aio_enabled(struct mmap *map)
 {
 	return map->aio.nr_cblocks > 0;
 }
 
 #ifdef HAVE_LIBNUMA_SUPPORT
-static int perf_mmap__aio_alloc(struct perf_mmap *map, int idx)
+static int perf_mmap__aio_alloc(struct mmap *map, int idx)
 {
 	map->aio.data[idx] = mmap(NULL, perf_mmap__mmap_len(map), PROT_READ|PROT_WRITE,
 				  MAP_PRIVATE|MAP_ANONYMOUS, 0, 0);
@@ -176,7 +176,7 @@ static int perf_mmap__aio_alloc(struct perf_mmap *map, int idx)
 	return 0;
 }
 
-static void perf_mmap__aio_free(struct perf_mmap *map, int idx)
+static void perf_mmap__aio_free(struct mmap *map, int idx)
 {
 	if (map->aio.data[idx]) {
 		munmap(map->aio.data[idx], perf_mmap__mmap_len(map));
@@ -184,7 +184,7 @@ static void perf_mmap__aio_free(struct perf_mmap *map, int idx)
 	}
 }
 
-static int perf_mmap__aio_bind(struct perf_mmap *map, int idx, int cpu, int affinity)
+static int perf_mmap__aio_bind(struct mmap *map, int idx, int cpu, int affinity)
 {
 	void *data;
 	size_t mmap_len;
@@ -204,7 +204,7 @@ static int perf_mmap__aio_bind(struct perf_mmap *map, int idx, int cpu, int affi
 	return 0;
 }
 #else /* !HAVE_LIBNUMA_SUPPORT */
-static int perf_mmap__aio_alloc(struct perf_mmap *map, int idx)
+static int perf_mmap__aio_alloc(struct mmap *map, int idx)
 {
 	map->aio.data[idx] = malloc(perf_mmap__mmap_len(map));
 	if (map->aio.data[idx] == NULL)
@@ -213,19 +213,19 @@ static int perf_mmap__aio_alloc(struct perf_mmap *map, int idx)
 	return 0;
 }
 
-static void perf_mmap__aio_free(struct perf_mmap *map, int idx)
+static void perf_mmap__aio_free(struct mmap *map, int idx)
 {
 	zfree(&(map->aio.data[idx]));
 }
 
-static int perf_mmap__aio_bind(struct perf_mmap *map __maybe_unused, int idx __maybe_unused,
+static int perf_mmap__aio_bind(struct mmap *map __maybe_unused, int idx __maybe_unused,
 		int cpu __maybe_unused, int affinity __maybe_unused)
 {
 	return 0;
 }
 #endif
 
-static int perf_mmap__aio_mmap(struct perf_mmap *map, struct mmap_params *mp)
+static int perf_mmap__aio_mmap(struct mmap *map, struct mmap_params *mp)
 {
 	int delta_max, i, prio, ret;
 
@@ -279,7 +279,7 @@ static int perf_mmap__aio_mmap(struct perf_mmap *map, struct mmap_params *mp)
 	return 0;
 }
 
-static void perf_mmap__aio_munmap(struct perf_mmap *map)
+static void perf_mmap__aio_munmap(struct mmap *map)
 {
 	int i;
 
@@ -291,23 +291,23 @@ static void perf_mmap__aio_munmap(struct perf_mmap *map)
 	zfree(&map->aio.aiocb);
 }
 #else /* !HAVE_AIO_SUPPORT */
-static int perf_mmap__aio_enabled(struct perf_mmap *map __maybe_unused)
+static int perf_mmap__aio_enabled(struct mmap *map __maybe_unused)
 {
 	return 0;
 }
 
-static int perf_mmap__aio_mmap(struct perf_mmap *map __maybe_unused,
+static int perf_mmap__aio_mmap(struct mmap *map __maybe_unused,
 			       struct mmap_params *mp __maybe_unused)
 {
 	return 0;
 }
 
-static void perf_mmap__aio_munmap(struct perf_mmap *map __maybe_unused)
+static void perf_mmap__aio_munmap(struct mmap *map __maybe_unused)
 {
 }
 #endif
 
-void perf_mmap__munmap(struct perf_mmap *map)
+void perf_mmap__munmap(struct mmap *map)
 {
 	perf_mmap__aio_munmap(map);
 	if (map->data != NULL) {
@@ -340,7 +340,7 @@ static void build_node_mask(int node, cpu_set_t *mask)
 	}
 }
 
-static void perf_mmap__setup_affinity_mask(struct perf_mmap *map, struct mmap_params *mp)
+static void perf_mmap__setup_affinity_mask(struct mmap *map, struct mmap_params *mp)
 {
 	CPU_ZERO(&map->affinity_mask);
 	if (mp->affinity == PERF_AFFINITY_NODE && cpu__max_node() > 1)
@@ -349,7 +349,7 @@ static void perf_mmap__setup_affinity_mask(struct perf_mmap *map, struct mmap_pa
 		CPU_SET(map->cpu, &map->affinity_mask);
 }
 
-int perf_mmap__mmap(struct perf_mmap *map, struct mmap_params *mp, int fd, int cpu)
+int perf_mmap__mmap(struct mmap *map, struct mmap_params *mp, int fd, int cpu)
 {
 	/*
 	 * The last one will be done at perf_mmap__consume(), so that we
@@ -437,7 +437,7 @@ static int overwrite_rb_find_range(void *buf, int mask, u64 *start, u64 *end)
 /*
  * Report the start and end of the available data in ringbuffer
  */
-static int __perf_mmap__read_init(struct perf_mmap *md)
+static int __perf_mmap__read_init(struct mmap *md)
 {
 	u64 head = perf_mmap__read_head(md);
 	u64 old = md->prev;
@@ -471,7 +471,7 @@ static int __perf_mmap__read_init(struct perf_mmap *md)
 	return 0;
 }
 
-int perf_mmap__read_init(struct perf_mmap *map)
+int perf_mmap__read_init(struct mmap *map)
 {
 	/*
 	 * Check if event was unmapped due to a POLLHUP/POLLERR.
@@ -482,8 +482,8 @@ int perf_mmap__read_init(struct perf_mmap *map)
 	return __perf_mmap__read_init(map);
 }
 
-int perf_mmap__push(struct perf_mmap *md, void *to,
-		    int push(struct perf_mmap *map, void *to, void *buf, size_t size))
+int perf_mmap__push(struct mmap *md, void *to,
+		    int push(struct mmap *map, void *to, void *buf, size_t size))
 {
 	u64 head = perf_mmap__read_head(md);
 	unsigned char *data = md->base + page_size;
@@ -529,7 +529,7 @@ int perf_mmap__push(struct perf_mmap *md, void *to,
  * The last perf_mmap__read() will set tail to map->prev.
  * Need to correct the map->prev to head which is the end of next read.
  */
-void perf_mmap__read_done(struct perf_mmap *map)
+void perf_mmap__read_done(struct mmap *map)
 {
 	/*
 	 * Check if event was unmapped due to a POLLHUP/POLLERR.
diff --git a/tools/perf/util/mmap.h b/tools/perf/util/mmap.h
index 274ce389cd84..38fcf56655b7 100644
--- a/tools/perf/util/mmap.h
+++ b/tools/perf/util/mmap.h
@@ -14,11 +14,11 @@
 
 struct aiocb;
 /**
- * struct perf_mmap - perf's ring buffer mmap details
+ * struct mmap - perf's ring buffer mmap details
  *
  * @refcnt - e.g. code using PERF_EVENT_IOC_SET_OUTPUT to share this
  */
-struct perf_mmap {
+struct mmap {
 	void		 *base;
 	int		 mask;
 	int		 fd;
@@ -77,33 +77,33 @@ struct mmap_params {
 	struct auxtrace_mmap_params auxtrace_mp;
 };
 
-int perf_mmap__mmap(struct perf_mmap *map, struct mmap_params *mp, int fd, int cpu);
-void perf_mmap__munmap(struct perf_mmap *map);
+int perf_mmap__mmap(struct mmap *map, struct mmap_params *mp, int fd, int cpu);
+void perf_mmap__munmap(struct mmap *map);
 
-void perf_mmap__get(struct perf_mmap *map);
-void perf_mmap__put(struct perf_mmap *map);
+void perf_mmap__get(struct mmap *map);
+void perf_mmap__put(struct mmap *map);
 
-void perf_mmap__consume(struct perf_mmap *map);
+void perf_mmap__consume(struct mmap *map);
 
-static inline u64 perf_mmap__read_head(struct perf_mmap *mm)
+static inline u64 perf_mmap__read_head(struct mmap *mm)
 {
 	return ring_buffer_read_head(mm->base);
 }
 
-static inline void perf_mmap__write_tail(struct perf_mmap *md, u64 tail)
+static inline void perf_mmap__write_tail(struct mmap *md, u64 tail)
 {
 	ring_buffer_write_tail(md->base, tail);
 }
 
-union perf_event *perf_mmap__read_forward(struct perf_mmap *map);
+union perf_event *perf_mmap__read_forward(struct mmap *map);
 
-union perf_event *perf_mmap__read_event(struct perf_mmap *map);
+union perf_event *perf_mmap__read_event(struct mmap *map);
 
-int perf_mmap__push(struct perf_mmap *md, void *to,
-		    int push(struct perf_mmap *map, void *to, void *buf, size_t size));
+int perf_mmap__push(struct mmap *md, void *to,
+		    int push(struct mmap *map, void *to, void *buf, size_t size));
 
-size_t perf_mmap__mmap_len(struct perf_mmap *map);
+size_t perf_mmap__mmap_len(struct mmap *map);
 
-int perf_mmap__read_init(struct perf_mmap *md);
-void perf_mmap__read_done(struct perf_mmap *map);
+int perf_mmap__read_init(struct mmap *md);
+void perf_mmap__read_done(struct mmap *map);
 #endif /*__PERF_MMAP_H */
* Unmerged path tools/perf/util/python.c
