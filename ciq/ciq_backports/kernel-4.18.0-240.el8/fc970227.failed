bpf: Add mmap() support for BPF_MAP_TYPE_ARRAY

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit fc9702273e2edb90400a34b3be76f7b08fa3344b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/fc970227.failed

Add ability to memory-map contents of BPF array map. This is extremely useful
for working with BPF global data from userspace programs. It allows to avoid
typical bpf_map_{lookup,update}_elem operations, improving both performance
and usability.

There had to be special considerations for map freezing, to avoid having
writable memory view into a frozen map. To solve this issue, map freezing and
mmap-ing is happening under mutex now:
  - if map is already frozen, no writable mapping is allowed;
  - if map has writable memory mappings active (accounted in map->writecnt),
    map freezing will keep failing with -EBUSY;
  - once number of writable memory mappings drops to zero, map freezing can be
    performed again.

Only non-per-CPU plain arrays are supported right now. Maps with spinlocks
can't be memory mapped either.

For BPF_F_MMAPABLE array, memory allocation has to be done through vmalloc()
to be mmap()'able. We also need to make sure that array data memory is
page-sized and page-aligned, so we over-allocate memory in such a way that
struct bpf_array is at the end of a single page of memory with array->value
being aligned with the start of the second page. On deallocation we need to
accomodate this memory arrangement to free vmalloc()'ed memory correctly.

One important consideration regarding how memory-mapping subsystem functions.
Memory-mapping subsystem provides few optional callbacks, among them open()
and close().  close() is called for each memory region that is unmapped, so
that users can decrease their reference counters and free up resources, if
necessary. open() is *almost* symmetrical: it's called for each memory region
that is being mapped, **except** the very first one. So bpf_map_mmap does
initial refcnt bump, while open() will do any extra ones after that. Thus
number of close() calls is equal to number of open() calls plus one more.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Song Liu <songliubraving@fb.com>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
	Acked-by: Johannes Weiner <hannes@cmpxchg.org>
Link: https://lore.kernel.org/bpf/20191117172806.2195367-4-andriin@fb.com
(cherry picked from commit fc9702273e2edb90400a34b3be76f7b08fa3344b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/syscall.c
#	mm/vmalloc.c
#	tools/include/uapi/linux/bpf.h
diff --cc include/linux/bpf.h
index a5585413dfbe,e913dd5946ae..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -15,8 -12,11 +15,9 @@@
  #include <linux/err.h>
  #include <linux/rbtree_latch.h>
  #include <linux/numa.h>
+ #include <linux/mm_types.h>
  #include <linux/wait.h>
  #include <linux/u64_stats_sync.h>
 -#include <linux/refcount.h>
 -#include <linux/mutex.h>
  
  struct bpf_verifier_env;
  struct bpf_verifier_log;
@@@ -75,7 -69,7 +76,11 @@@ struct bpf_map_ops 
  				     u64 *imm, u32 off);
  	int (*map_direct_value_meta)(const struct bpf_map *map,
  				     u64 imm, u32 *off);
++<<<<<<< HEAD
 +	) /* RH_KABI_BROKEN_INSERT_BLOCK */
++=======
+ 	int (*map_mmap)(struct bpf_map *map, struct vm_area_struct *vma);
++>>>>>>> fc9702273e2e (bpf: Add mmap() support for BPF_MAP_TYPE_ARRAY)
  };
  
  struct bpf_map_memory {
@@@ -103,22 -97,20 +108,31 @@@ struct bpf_map 
  	u32 btf_key_type_id;
  	u32 btf_value_type_id;
  	struct btf *btf;
++<<<<<<< HEAD
 +	RH_KABI_BROKEN_INSERT(struct bpf_map_memory memory)
 +	bool unpriv_array;
 +	RH_KABI_FILL_HOLE(bool frozen) /* write-once */
 +	/* 48 bytes hole */
++=======
+ 	struct bpf_map_memory memory;
+ 	char name[BPF_OBJ_NAME_LEN];
+ 	bool unpriv_array;
+ 	bool frozen; /* write-once; write-protected by freeze_mutex */
+ 	/* 22 bytes hole */
++>>>>>>> fc9702273e2e (bpf: Add mmap() support for BPF_MAP_TYPE_ARRAY)
  
  	/* The 3rd and 4th cacheline with misc members to avoid false sharing
  	 * particularly with refcounting.
  	 */
 -	atomic64_t refcnt ____cacheline_aligned;
 -	atomic64_t usercnt;
 +	RH_KABI_BROKEN_REMOVE_BLOCK(
 +	struct user_struct *user ____cacheline_aligned;
 +	atomic_t refcnt;
 +	) /* RH_KABI_BROKEN_REMOVE_BLOCK */
 +	RH_KABI_BROKEN_INSERT(atomic_t refcnt ____cacheline_aligned)
 +	atomic_t usercnt;
  	struct work_struct work;
- 	char name[BPF_OBJ_NAME_LEN];
+ 	struct mutex freeze_mutex;
+ 	u64 writecnt; /* writable mmap cnt; protected by freeze_mutex */
  };
  
  static inline bool map_value_has_spin_lock(const struct bpf_map *map)
@@@ -691,7 -798,8 +705,12 @@@ int bpf_map_charge_init(struct bpf_map_
  void bpf_map_charge_finish(struct bpf_map_memory *mem);
  void bpf_map_charge_move(struct bpf_map_memory *dst,
  			 struct bpf_map_memory *src);
++<<<<<<< HEAD
 +void *bpf_map_area_alloc(u64 size, int numa_node);
++=======
+ void *bpf_map_area_alloc(size_t size, int numa_node);
+ void *bpf_map_area_mmapable_alloc(size_t size, int numa_node);
++>>>>>>> fc9702273e2e (bpf: Add mmap() support for BPF_MAP_TYPE_ARRAY)
  void bpf_map_area_free(void *base);
  void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr);
  
diff --cc kernel/bpf/syscall.c
index dd68cbc967e7,bac3becf9f90..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -156,7 -127,7 +156,11 @@@ static struct bpf_map *find_and_alloc_m
  	return map;
  }
  
++<<<<<<< HEAD
 +void *bpf_map_area_alloc(u64 size, int numa_node)
++=======
+ static void *__bpf_map_area_alloc(size_t size, int numa_node, bool mmapable)
++>>>>>>> fc9702273e2e (bpf: Add mmap() support for BPF_MAP_TYPE_ARRAY)
  {
  	/* We really just want to fail instead of triggering OOM killer
  	 * under memory pressure, therefore we set __GFP_NORETRY to kmalloc,
@@@ -171,10 -142,8 +175,15 @@@
  	const gfp_t flags = __GFP_NOWARN | __GFP_ZERO;
  	void *area;
  
++<<<<<<< HEAD
 +	if (size >= SIZE_MAX)
 +		return NULL;
 +
 +	if (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {
++=======
+ 	/* kmalloc()'ed memory can't be mmap()'ed */
+ 	if (!mmapable && size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {
++>>>>>>> fc9702273e2e (bpf: Add mmap() support for BPF_MAP_TYPE_ARRAY)
  		area = kmalloc_node(size, GFP_USER | __GFP_NORETRY | flags,
  				    numa_node);
  		if (area != NULL)
@@@ -607,8 -659,9 +699,14 @@@ static int map_create(union bpf_attr *a
  	if (err)
  		goto free_map;
  
++<<<<<<< HEAD
 +	atomic_set(&map->refcnt, 1);
 +	atomic_set(&map->usercnt, 1);
++=======
+ 	atomic64_set(&map->refcnt, 1);
+ 	atomic64_set(&map->usercnt, 1);
+ 	mutex_init(&map->freeze_mutex);
++>>>>>>> fc9702273e2e (bpf: Add mmap() support for BPF_MAP_TYPE_ARRAY)
  
  	if (attr->btf_key_type_id || attr->btf_value_type_id) {
  		struct btf *btf;
diff --cc mm/vmalloc.c
index 2ee9f1677a60,4a7d7459c4f9..000000000000
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@@ -1984,22 -2671,39 +1984,47 @@@ void *vzalloc_node(unsigned long size, 
  }
  EXPORT_SYMBOL(vzalloc_node);
  
 +#ifndef PAGE_KERNEL_EXEC
 +# define PAGE_KERNEL_EXEC PAGE_KERNEL
 +#endif
 +
  /**
++<<<<<<< HEAD
 + *	vmalloc_exec  -  allocate virtually contiguous, executable memory
 + *	@size:		allocation size
++=======
+  * vmalloc_user_node_flags - allocate memory for userspace on a specific node
+  * @size: allocation size
+  * @node: numa node
+  * @flags: flags for the page level allocator
+  *
+  * The resulting memory area is zeroed so it can be mapped to userspace
+  * without leaking data.
+  *
+  * Return: pointer to the allocated memory or %NULL on error
+  */
+ void *vmalloc_user_node_flags(unsigned long size, int node, gfp_t flags)
+ {
+ 	return __vmalloc_node_range(size, SHMLBA,  VMALLOC_START, VMALLOC_END,
+ 				    flags | __GFP_ZERO, PAGE_KERNEL,
+ 				    VM_USERMAP, node,
+ 				    __builtin_return_address(0));
+ }
+ EXPORT_SYMBOL(vmalloc_user_node_flags);
+ 
+ /**
+  * vmalloc_exec - allocate virtually contiguous, executable memory
+  * @size:	  allocation size
++>>>>>>> fc9702273e2e (bpf: Add mmap() support for BPF_MAP_TYPE_ARRAY)
   *
 - * Kernel-internal function to allocate enough pages to cover @size
 - * the page level allocator and map them into contiguous and
 - * executable kernel virtual space.
 + *	Kernel-internal function to allocate enough pages to cover @size
 + *	the page level allocator and map them into contiguous and
 + *	executable kernel virtual space.
   *
 - * For tight control over page level allocator and protection flags
 - * use __vmalloc() instead.
 - *
 - * Return: pointer to the allocated memory or %NULL on error
 + *	For tight control over page level allocator and protection flags
 + *	use __vmalloc() instead.
   */
 +
  void *vmalloc_exec(unsigned long size)
  {
  	return __vmalloc_node_range(size, 1, VMALLOC_START, VMALLOC_END,
diff --cc tools/include/uapi/linux/bpf.h
index 4c50a38c7288,dbbcf0b02970..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -341,6 -345,12 +341,15 @@@ enum bpf_attach_type 
  #define BPF_F_RDONLY_PROG	(1U << 7)
  #define BPF_F_WRONLY_PROG	(1U << 8)
  
++<<<<<<< HEAD
++=======
+ /* Clone map from listener for newly accepted socket */
+ #define BPF_F_CLONE		(1U << 9)
+ 
+ /* Enable memory-mapping BPF map */
+ #define BPF_F_MMAPABLE		(1U << 10)
+ 
++>>>>>>> fc9702273e2e (bpf: Add mmap() support for BPF_MAP_TYPE_ARRAY)
  /* flags for BPF_PROG_QUERY */
  #define BPF_F_QUERY_EFFECTIVE	(1U << 0)
  
* Unmerged path include/linux/bpf.h
diff --git a/include/linux/vmalloc.h b/include/linux/vmalloc.h
index c6eebb839552..a62e7ef4f6c3 100644
--- a/include/linux/vmalloc.h
+++ b/include/linux/vmalloc.h
@@ -79,6 +79,7 @@ extern void *vzalloc(unsigned long size);
 extern void *vmalloc_user(unsigned long size);
 extern void *vmalloc_node(unsigned long size, int node);
 extern void *vzalloc_node(unsigned long size, int node);
+extern void *vmalloc_user_node_flags(unsigned long size, int node, gfp_t flags);
 extern void *vmalloc_exec(unsigned long size);
 extern void *vmalloc_32(unsigned long size);
 extern void *vmalloc_32_user(unsigned long size);
diff --git a/include/uapi/linux/bpf.h b/include/uapi/linux/bpf.h
index f26f93a554f1..dd3a482de08c 100644
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@ -349,6 +349,9 @@ enum bpf_attach_type {
 /* Clone map from listener for newly accepted socket */
 #define BPF_F_CLONE		(1U << 9)
 
+/* Enable memory-mapping BPF map */
+#define BPF_F_MMAPABLE		(1U << 10)
+
 /* flags for BPF_PROG_QUERY */
 #define BPF_F_QUERY_EFFECTIVE	(1U << 0)
 
diff --git a/kernel/bpf/arraymap.c b/kernel/bpf/arraymap.c
index 0349cbf23cdb..a655957437f0 100644
--- a/kernel/bpf/arraymap.c
+++ b/kernel/bpf/arraymap.c
@@ -22,7 +22,7 @@
 #include "map_in_map.h"
 
 #define ARRAY_CREATE_FLAG_MASK \
-	(BPF_F_NUMA_NODE | BPF_F_ACCESS_MASK)
+	(BPF_F_NUMA_NODE | BPF_F_MMAPABLE | BPF_F_ACCESS_MASK)
 
 static void bpf_array_free_percpu(struct bpf_array *array)
 {
@@ -67,6 +67,10 @@ int array_map_alloc_check(union bpf_attr *attr)
 	    (percpu && numa_node != NUMA_NO_NODE))
 		return -EINVAL;
 
+	if (attr->map_type != BPF_MAP_TYPE_ARRAY &&
+	    attr->map_flags & BPF_F_MMAPABLE)
+		return -EINVAL;
+
 	if (attr->value_size > KMALLOC_MAX_SIZE)
 		/* if value_size is bigger, the user space won't be able to
 		 * access the elements.
@@ -110,10 +114,19 @@ static struct bpf_map *array_map_alloc(union bpf_attr *attr)
 	}
 
 	array_size = sizeof(*array);
-	if (percpu)
+	if (percpu) {
 		array_size += (u64) max_entries * sizeof(void *);
-	else
-		array_size += (u64) max_entries * elem_size;
+	} else {
+		/* rely on vmalloc() to return page-aligned memory and
+		 * ensure array->value is exactly page-aligned
+		 */
+		if (attr->map_flags & BPF_F_MMAPABLE) {
+			array_size = PAGE_ALIGN(array_size);
+			array_size += PAGE_ALIGN((u64) max_entries * elem_size);
+		} else {
+			array_size += (u64) max_entries * elem_size;
+		}
+	}
 
 	/* make sure there is no u32 overflow later in round_up() */
 	cost = array_size;
@@ -125,7 +138,20 @@ static struct bpf_map *array_map_alloc(union bpf_attr *attr)
 		return ERR_PTR(ret);
 
 	/* allocate all map elements and zero-initialize them */
-	array = bpf_map_area_alloc(array_size, numa_node);
+	if (attr->map_flags & BPF_F_MMAPABLE) {
+		void *data;
+
+		/* kmalloc'ed memory can't be mmap'ed, use explicit vmalloc */
+		data = bpf_map_area_mmapable_alloc(array_size, numa_node);
+		if (!data) {
+			bpf_map_charge_finish(&mem);
+			return ERR_PTR(-ENOMEM);
+		}
+		array = data + PAGE_ALIGN(sizeof(struct bpf_array))
+			- offsetof(struct bpf_array, value);
+	} else {
+		array = bpf_map_area_alloc(array_size, numa_node);
+	}
 	if (!array) {
 		bpf_map_charge_finish(&mem);
 		return ERR_PTR(-ENOMEM);
@@ -358,6 +384,11 @@ static int array_map_delete_elem(struct bpf_map *map, void *key)
 	return -EINVAL;
 }
 
+static void *array_map_vmalloc_addr(struct bpf_array *array)
+{
+	return (void *)round_down((unsigned long)array, PAGE_SIZE);
+}
+
 /* Called when map->refcnt goes to zero, either from workqueue or from syscall */
 static void array_map_free(struct bpf_map *map)
 {
@@ -373,7 +404,10 @@ static void array_map_free(struct bpf_map *map)
 	if (array->map.map_type == BPF_MAP_TYPE_PERCPU_ARRAY)
 		bpf_array_free_percpu(array);
 
-	bpf_map_area_free(array);
+	if (array->map.map_flags & BPF_F_MMAPABLE)
+		bpf_map_area_free(array_map_vmalloc_addr(array));
+	else
+		bpf_map_area_free(array);
 }
 
 static void array_map_seq_show_elem(struct bpf_map *map, void *key,
@@ -452,6 +486,17 @@ static int array_map_check_btf(const struct bpf_map *map,
 	return 0;
 }
 
+int array_map_mmap(struct bpf_map *map, struct vm_area_struct *vma)
+{
+	struct bpf_array *array = container_of(map, struct bpf_array, map);
+	pgoff_t pgoff = PAGE_ALIGN(sizeof(*array)) >> PAGE_SHIFT;
+
+	if (!(map->map_flags & BPF_F_MMAPABLE))
+		return -EINVAL;
+
+	return remap_vmalloc_range(vma, array_map_vmalloc_addr(array), pgoff);
+}
+
 const struct bpf_map_ops array_map_ops = {
 	.map_alloc_check = array_map_alloc_check,
 	.map_alloc = array_map_alloc,
@@ -463,6 +508,7 @@ const struct bpf_map_ops array_map_ops = {
 	.map_gen_lookup = array_map_gen_lookup,
 	.map_direct_value_addr = array_map_direct_value_addr,
 	.map_direct_value_meta = array_map_direct_value_meta,
+	.map_mmap = array_map_mmap,
 	.map_seq_show_elem = array_map_seq_show_elem,
 	.map_check_btf = array_map_check_btf,
 };
* Unmerged path kernel/bpf/syscall.c
* Unmerged path mm/vmalloc.c
* Unmerged path tools/include/uapi/linux/bpf.h
