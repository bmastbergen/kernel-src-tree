ASoC: rt5682: Fine tune the HP performance in soundwire mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: rt5682: Fine tune the HP performance in soundwire mode (Jaroslav Kysela) [1797509]
Rebuild_FUZZ: 95.24%
commit-author Oder Chiou <oder_chiou@realtek.com>
commit a252d78cf772f86c2dcc40df8117d9461eed88d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a252d78c.failed

The setting is sync with I2C/I2S mode.

	Signed-off-by: Oder Chiou <oder_chiou@realtek.com>
Link: https://lore.kernel.org/r/20200313023850.28875-1-oder_chiou@realtek.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit a252d78cf772f86c2dcc40df8117d9461eed88d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/codecs/rt5682.c
diff --cc sound/soc/codecs/rt5682.c
index f5ac644ce5be,f4b8af128828..000000000000
--- a/sound/soc/codecs/rt5682.c
+++ b/sound/soc/codecs/rt5682.c
@@@ -3064,6 -3297,221 +3064,224 @@@ static void rt5682_calibrate(struct rt5
  
  }
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_SND_SOC_RT5682_SDW)
+ static int rt5682_sdw_read(void *context, unsigned int reg, unsigned int *val)
+ {
+ 	struct device *dev = context;
+ 	struct rt5682_priv *rt5682 = dev_get_drvdata(dev);
+ 	unsigned int data_l, data_h;
+ 
+ 	regmap_write(rt5682->sdw_regmap, RT5682_SDW_CMD, 0);
+ 	regmap_write(rt5682->sdw_regmap, RT5682_SDW_ADDR_H, (reg >> 8) & 0xff);
+ 	regmap_write(rt5682->sdw_regmap, RT5682_SDW_ADDR_L, (reg & 0xff));
+ 	regmap_read(rt5682->sdw_regmap, RT5682_SDW_DATA_H, &data_h);
+ 	regmap_read(rt5682->sdw_regmap, RT5682_SDW_DATA_L, &data_l);
+ 
+ 	*val = (data_h << 8) | data_l;
+ 
+ 	dev_vdbg(dev, "[%s] %04x => %04x\n", __func__, reg, *val);
+ 
+ 	return 0;
+ }
+ 
+ static int rt5682_sdw_write(void *context, unsigned int reg, unsigned int val)
+ {
+ 	struct device *dev = context;
+ 	struct rt5682_priv *rt5682 = dev_get_drvdata(dev);
+ 
+ 	regmap_write(rt5682->sdw_regmap, RT5682_SDW_CMD, 1);
+ 	regmap_write(rt5682->sdw_regmap, RT5682_SDW_ADDR_H, (reg >> 8) & 0xff);
+ 	regmap_write(rt5682->sdw_regmap, RT5682_SDW_ADDR_L, (reg & 0xff));
+ 	regmap_write(rt5682->sdw_regmap, RT5682_SDW_DATA_H, (val >> 8) & 0xff);
+ 	regmap_write(rt5682->sdw_regmap, RT5682_SDW_DATA_L, (val & 0xff));
+ 
+ 	dev_vdbg(dev, "[%s] %04x <= %04x\n", __func__, reg, val);
+ 
+ 	return 0;
+ }
+ 
+ static const struct regmap_config rt5682_sdw_regmap = {
+ 	.reg_bits = 16,
+ 	.val_bits = 16,
+ 	.max_register = RT5682_I2C_MODE,
+ 	.volatile_reg = rt5682_volatile_register,
+ 	.readable_reg = rt5682_readable_register,
+ 	.cache_type = REGCACHE_RBTREE,
+ 	.reg_defaults = rt5682_reg,
+ 	.num_reg_defaults = ARRAY_SIZE(rt5682_reg),
+ 	.use_single_read = true,
+ 	.use_single_write = true,
+ 	.reg_read = rt5682_sdw_read,
+ 	.reg_write = rt5682_sdw_write,
+ };
+ 
+ int rt5682_sdw_init(struct device *dev, struct regmap *regmap,
+ 	struct sdw_slave *slave)
+ {
+ 	struct rt5682_priv *rt5682;
+ 	int ret;
+ 
+ 	rt5682 = devm_kzalloc(dev, sizeof(*rt5682), GFP_KERNEL);
+ 	if (!rt5682)
+ 		return -ENOMEM;
+ 
+ 	dev_set_drvdata(dev, rt5682);
+ 	rt5682->slave = slave;
+ 	rt5682->sdw_regmap = regmap;
+ 	rt5682->is_sdw = true;
+ 
+ 	rt5682->regmap = devm_regmap_init(dev, NULL, dev, &rt5682_sdw_regmap);
+ 	if (IS_ERR(rt5682->regmap)) {
+ 		ret = PTR_ERR(rt5682->regmap);
+ 		dev_err(dev, "Failed to allocate register map: %d\n",
+ 			ret);
+ 		return ret;
+ 	}
+ 
+ 	/*
+ 	 * Mark hw_init to false
+ 	 * HW init will be performed when device reports present
+ 	 */
+ 	rt5682->hw_init = false;
+ 	rt5682->first_hw_init = false;
+ 
+ 	mutex_init(&rt5682->calibrate_mutex);
+ 	INIT_DELAYED_WORK(&rt5682->jack_detect_work,
+ 		rt5682_jack_detect_handler);
+ 
+ 	ret = devm_snd_soc_register_component(dev, &soc_component_dev_rt5682,
+ 		rt5682_dai, ARRAY_SIZE(rt5682_dai));
+ 
+ 	dev_dbg(&slave->dev, "%s\n", __func__);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(rt5682_sdw_init);
+ 
+ int rt5682_io_init(struct device *dev, struct sdw_slave *slave)
+ {
+ 	struct rt5682_priv *rt5682 = dev_get_drvdata(dev);
+ 	int ret = 0;
+ 	unsigned int val;
+ 
+ 	if (rt5682->hw_init)
+ 		return 0;
+ 
+ 	regmap_read(rt5682->regmap, RT5682_DEVICE_ID, &val);
+ 	if (val != DEVICE_ID) {
+ 		pr_err("Device with ID register %x is not rt5682\n", val);
+ 		return -ENODEV;
+ 	}
+ 
+ 	/*
+ 	 * PM runtime is only enabled when a Slave reports as Attached
+ 	 */
+ 	if (!rt5682->first_hw_init) {
+ 		/* set autosuspend parameters */
+ 		pm_runtime_set_autosuspend_delay(&slave->dev, 3000);
+ 		pm_runtime_use_autosuspend(&slave->dev);
+ 
+ 		/* update count of parent 'active' children */
+ 		pm_runtime_set_active(&slave->dev);
+ 
+ 		/* make sure the device does not suspend immediately */
+ 		pm_runtime_mark_last_busy(&slave->dev);
+ 
+ 		pm_runtime_enable(&slave->dev);
+ 	}
+ 
+ 	pm_runtime_get_noresume(&slave->dev);
+ 
+ 	rt5682_reset(rt5682);
+ 
+ 	if (rt5682->first_hw_init) {
+ 		regcache_cache_only(rt5682->regmap, false);
+ 		regcache_cache_bypass(rt5682->regmap, true);
+ 	}
+ 
+ 	rt5682_calibrate(rt5682);
+ 
+ 	if (rt5682->first_hw_init) {
+ 		regcache_cache_bypass(rt5682->regmap, false);
+ 		regcache_mark_dirty(rt5682->regmap);
+ 		regcache_sync(rt5682->regmap);
+ 
+ 		/* volatile registers */
+ 		regmap_update_bits(rt5682->regmap, RT5682_CBJ_CTRL_2,
+ 			RT5682_EXT_JD_SRC, RT5682_EXT_JD_SRC_MANUAL);
+ 
+ 		goto reinit;
+ 	}
+ 
+ 	ret = regmap_multi_reg_write(rt5682->regmap, patch_list,
+ 				    ARRAY_SIZE(patch_list));
+ 	if (ret != 0)
+ 		dev_warn(dev, "Failed to apply regmap patch: %d\n", ret);
+ 
+ 	regmap_write(rt5682->regmap, RT5682_DEPOP_1, 0x0000);
+ 
+ 	regmap_update_bits(rt5682->regmap, RT5682_PWR_ANLG_1,
+ 			RT5682_LDO1_DVO_MASK | RT5682_HP_DRIVER_MASK,
+ 			RT5682_LDO1_DVO_12 | RT5682_HP_DRIVER_5X);
+ 	regmap_write(rt5682->regmap, RT5682_MICBIAS_2, 0x0380);
+ 	regmap_write(rt5682->regmap, RT5682_TEST_MODE_CTRL_1, 0x0000);
+ 	regmap_update_bits(rt5682->regmap, RT5682_BIAS_CUR_CTRL_8,
+ 			RT5682_HPA_CP_BIAS_CTRL_MASK, RT5682_HPA_CP_BIAS_3UA);
+ 	regmap_update_bits(rt5682->regmap, RT5682_CHARGE_PUMP_1,
+ 			RT5682_CP_CLK_HP_MASK, RT5682_CP_CLK_HP_300KHZ);
+ 	regmap_update_bits(rt5682->regmap, RT5682_HP_CHARGE_PUMP_1,
+ 			RT5682_PM_HP_MASK, RT5682_PM_HP_HV);
+ 
+ 	/* Soundwire */
+ 	regmap_write(rt5682->regmap, RT5682_PLL2_INTERNAL, 0xa266);
+ 	regmap_write(rt5682->regmap, RT5682_PLL2_CTRL_1, 0x1700);
+ 	regmap_write(rt5682->regmap, RT5682_PLL2_CTRL_2, 0x0006);
+ 	regmap_write(rt5682->regmap, RT5682_PLL2_CTRL_3, 0x2600);
+ 	regmap_write(rt5682->regmap, RT5682_PLL2_CTRL_4, 0x0c8f);
+ 	regmap_write(rt5682->regmap, RT5682_PLL_TRACK_2, 0x3000);
+ 	regmap_write(rt5682->regmap, RT5682_PLL_TRACK_3, 0x4000);
+ 	regmap_update_bits(rt5682->regmap, RT5682_GLB_CLK,
+ 		RT5682_SCLK_SRC_MASK | RT5682_PLL2_SRC_MASK,
+ 		RT5682_SCLK_SRC_PLL2 | RT5682_PLL2_SRC_SDW);
+ 
+ 	regmap_update_bits(rt5682->regmap, RT5682_CBJ_CTRL_2,
+ 		RT5682_EXT_JD_SRC, RT5682_EXT_JD_SRC_MANUAL);
+ 	regmap_write(rt5682->regmap, RT5682_CBJ_CTRL_1, 0xd042);
+ 	regmap_update_bits(rt5682->regmap, RT5682_CBJ_CTRL_3,
+ 		RT5682_CBJ_IN_BUF_EN, RT5682_CBJ_IN_BUF_EN);
+ 	regmap_update_bits(rt5682->regmap, RT5682_SAR_IL_CMD_1,
+ 		RT5682_SAR_POW_MASK, RT5682_SAR_POW_EN);
+ 	regmap_update_bits(rt5682->regmap, RT5682_RC_CLK_CTRL,
+ 			RT5682_POW_IRQ | RT5682_POW_JDH |
+ 			RT5682_POW_ANA, RT5682_POW_IRQ |
+ 			RT5682_POW_JDH | RT5682_POW_ANA);
+ 	regmap_update_bits(rt5682->regmap, RT5682_PWR_ANLG_2,
+ 		RT5682_PWR_JDH, RT5682_PWR_JDH);
+ 	regmap_update_bits(rt5682->regmap, RT5682_IRQ_CTRL_2,
+ 		RT5682_JD1_EN_MASK | RT5682_JD1_IRQ_MASK,
+ 		RT5682_JD1_EN | RT5682_JD1_IRQ_PUL);
+ 
+ reinit:
+ 	mod_delayed_work(system_power_efficient_wq,
+ 		   &rt5682->jack_detect_work, msecs_to_jiffies(250));
+ 
+ 	/* Mark Slave initialization complete */
+ 	rt5682->hw_init = true;
+ 	rt5682->first_hw_init = true;
+ 
+ 	pm_runtime_mark_last_busy(&slave->dev);
+ 	pm_runtime_put_autosuspend(&slave->dev);
+ 
+ 	dev_dbg(&slave->dev, "%s hw_init complete\n", __func__);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(rt5682_io_init);
+ #endif
+ 
++>>>>>>> a252d78cf772 (ASoC: rt5682: Fine tune the HP performance in soundwire mode)
  static int rt5682_i2c_probe(struct i2c_client *i2c,
  		    const struct i2c_device_id *id)
  {
* Unmerged path sound/soc/codecs/rt5682.c
