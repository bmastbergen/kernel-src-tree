gpio: Fix return value mismatch of function gpiod_get_from_of_node()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Waibel Georg <Georg.Waibel@sensor-technik.de>
commit 025bf37725f1929542361eef2245df30badf242e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/025bf377.failed

In case the requested gpio property is not found in the device tree, some
callers of gpiod_get_from_of_node() expect a return value of NULL, others
expect -ENOENT.
In particular devm_fwnode_get_index_gpiod_from_child() expects -ENOENT.
Currently it gets a NULL, which breaks the loop that tries all
gpio_suffixes. The result is that a gpio property is not found, even
though it is there.

This patch changes gpiod_get_from_of_node() to return -ENOENT instead
of NULL when the requested gpio property is not found in the device
tree. Additionally it modifies all calling functions to properly
evaluate the return value.

Another approach would be to leave the return value of
gpiod_get_from_of_node() as is and fix the bug in
devm_fwnode_get_index_gpiod_from_child(). Other callers would still need
to be reworked. The effort would be the same as with the chosen solution.

	Signed-off-by: Georg Waibel <georg.waibel@sensor-technik.de>
	Reviewed-by: Krzysztof Kozlowski <krzk@kernel.org>
	Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 025bf37725f1929542361eef2245df30badf242e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/regulator/da9211-regulator.c
#	drivers/regulator/s2mps11.c
#	drivers/regulator/s5m8767.c
diff --cc drivers/regulator/da9211-regulator.c
index 6c122b3df5d0,0309823d2c72..000000000000
--- a/drivers/regulator/da9211-regulator.c
+++ b/drivers/regulator/da9211-regulator.c
@@@ -294,11 -284,13 +294,21 @@@ static struct da9211_pdata *da9211_pars
  		pdata->init_data[n] = da9211_matches[i].init_data;
  		pdata->reg_node[n] = da9211_matches[i].of_node;
  		pdata->gpiod_ren[n] = devm_gpiod_get_from_of_node(dev,
++<<<<<<< HEAD
 +								  da9211_matches[i].of_node,
 +								  "enable",
 +								  0,
 +								  GPIOD_OUT_HIGH,
 +								  "da9211-enable");
++=======
+ 				  da9211_matches[i].of_node,
+ 				  "enable",
+ 				  0,
+ 				  GPIOD_OUT_HIGH | GPIOD_FLAGS_BIT_NONEXCLUSIVE,
+ 				  "da9211-enable");
+ 		if (IS_ERR(pdata->gpiod_ren[n]))
+ 			pdata->gpiod_ren[n] = NULL;
++>>>>>>> 025bf37725f1 (gpio: Fix return value mismatch of function gpiod_get_from_of_node())
  		n++;
  	}
  
diff --cc drivers/regulator/s2mps11.c
index d1207ec683db,e5a74ae40687..000000000000
--- a/drivers/regulator/s2mps11.c
+++ b/drivers/regulator/s2mps11.c
@@@ -829,11 -837,22 +829,30 @@@ static void s2mps14_pmic_dt_parse_ext_c
  		if (!rdata[reg].init_data || !rdata[reg].of_node)
  			continue;
  
++<<<<<<< HEAD
 +		gpio[reg] = of_get_named_gpio(rdata[reg].of_node,
 +				"samsung,ext-control-gpios", 0);
 +		if (gpio_is_valid(gpio[reg]))
 +			dev_dbg(&pdev->dev, "Using GPIO %d for ext-control over %d/%s\n",
 +					gpio[reg], reg, rdata[reg].name);
++=======
+ 		gpio[reg] = devm_gpiod_get_from_of_node(&pdev->dev,
+ 				rdata[reg].of_node,
+ 				"samsung,ext-control-gpios",
+ 				0,
+ 				GPIOD_OUT_HIGH | GPIOD_FLAGS_BIT_NONEXCLUSIVE,
+ 				"s2mps11-regulator");
+ 		if (PTR_ERR(gpio[reg]) == -ENOENT)
+ 			gpio[reg] = NULL;
+ 		else if (IS_ERR(gpio[reg])) {
+ 			dev_err(&pdev->dev, "Failed to get control GPIO for %d/%s\n",
+ 				reg, rdata[reg].name);
+ 			continue;
+ 		}
+ 		if (gpio[reg])
+ 			dev_dbg(&pdev->dev, "Using GPIO for ext-control over %d/%s\n",
+ 				reg, rdata[reg].name);
++>>>>>>> 025bf37725f1 (gpio: Fix return value mismatch of function gpiod_get_from_of_node())
  	}
  }
  
diff --cc drivers/regulator/s5m8767.c
index 0cbc980753c2,6ca27e9d5ef7..000000000000
--- a/drivers/regulator/s5m8767.c
+++ b/drivers/regulator/s5m8767.c
@@@ -579,13 -567,16 +579,26 @@@ static int s5m8767_pmic_dt_parse_pdata(
  			continue;
  		}
  
++<<<<<<< HEAD
 +		rdata->ext_control_gpiod = devm_gpiod_get_from_of_node(&pdev->dev,
 +								       reg_np,
 +								       "s5m8767,pmic-ext-control-gpios",
 +								       0,
 +								       GPIOD_OUT_HIGH,
 +								       "s5m8767");
 +		if (IS_ERR(rdata->ext_control_gpiod))
++=======
+ 		rdata->ext_control_gpiod = devm_gpiod_get_from_of_node(
+ 			&pdev->dev,
+ 			reg_np,
+ 			"s5m8767,pmic-ext-control-gpios",
+ 			0,
+ 			GPIOD_OUT_HIGH | GPIOD_FLAGS_BIT_NONEXCLUSIVE,
+ 			"s5m8767");
+ 		if (PTR_ERR(rdata->ext_control_gpiod) == -ENOENT)
+ 			rdata->ext_control_gpiod = NULL;
+ 		else if (IS_ERR(rdata->ext_control_gpiod))
++>>>>>>> 025bf37725f1 (gpio: Fix return value mismatch of function gpiod_get_from_of_node())
  			return PTR_ERR(rdata->ext_control_gpiod);
  
  		rdata->id = i;
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 5303188389a8..443cdd9126a9 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -4241,8 +4241,7 @@ EXPORT_SYMBOL_GPL(gpiod_get_index);
  *
  * Returns:
  * On successful request the GPIO pin is configured in accordance with
- * provided @dflags. If the node does not have the requested GPIO
- * property, NULL is returned.
+ * provided @dflags.
  *
  * In case of error an ERR_PTR() is returned.
  */
@@ -4264,9 +4263,6 @@ struct gpio_desc *gpiod_get_from_of_node(struct device_node *node,
 					index, &flags);
 
 	if (!desc || IS_ERR(desc)) {
-		/* If it is not there, just return NULL */
-		if (PTR_ERR(desc) == -ENOENT)
-			return NULL;
 		return desc;
 	}
 
* Unmerged path drivers/regulator/da9211-regulator.c
* Unmerged path drivers/regulator/s2mps11.c
* Unmerged path drivers/regulator/s5m8767.c
diff --git a/drivers/regulator/tps65090-regulator.c b/drivers/regulator/tps65090-regulator.c
index edaef9e4dc74..0e6b813f2508 100644
--- a/drivers/regulator/tps65090-regulator.c
+++ b/drivers/regulator/tps65090-regulator.c
@@ -380,11 +380,12 @@ static struct tps65090_platform_data *tps65090_parse_dt_reg_data(
 								    "dcdc-ext-control-gpios", 0,
 								    gflags,
 								    "tps65090");
-			if (IS_ERR(rpdata->gpiod))
-				return ERR_CAST(rpdata->gpiod);
-			if (!rpdata->gpiod)
+			if (PTR_ERR(rpdata->gpiod) == -ENOENT) {
 				dev_err(&pdev->dev,
 					"could not find DCDC external control GPIO\n");
+				rpdata->gpiod = NULL;
+			} else if (IS_ERR(rpdata->gpiod))
+				return ERR_CAST(rpdata->gpiod);
 		}
 
 		if (of_property_read_u32(tps65090_matches[idx].of_node,
