net/smc: adapt SMC client code to use the LLC flow

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Karsten Graul <kgraul@linux.ibm.com>
commit 0fb0b02bd6fd26cba38002be4a6bbcae2228fd44
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0fb0b02b.failed

Change the code that processes the SMC client part of connection
establishment to use the LLC flow framework (CONFIRM_LINK request
messages).

	Signed-off-by: Karsten Graul <kgraul@linux.ibm.com>
	Reviewed-by: Ursula Braun <ubraun@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0fb0b02bd6fd26cba38002be4a6bbcae2228fd44)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/smc/af_smc.c
#	net/smc/smc_core.h
#	net/smc/smc_llc.c
diff --cc net/smc/af_smc.c
index 61adbee56cf2,bd9662d06896..000000000000
--- a/net/smc/af_smc.c
+++ b/net/smc/af_smc.c
@@@ -379,16 -381,16 +379,17 @@@ static int smcr_lgr_reg_rmbs(struct smc
  
  static int smcr_clnt_conf_first_link(struct smc_sock *smc)
  {
 +	struct net *net = sock_net(smc->clcsock->sk);
  	struct smc_link *link = smc->conn.lnk;
- 	int rest;
+ 	struct smc_llc_qentry *qentry;
  	int rc;
  
+ 	link->lgr->type = SMC_LGR_SINGLE;
+ 
  	/* receive CONFIRM LINK request from server over RoCE fabric */
- 	rest = wait_for_completion_interruptible_timeout(
- 		&link->llc_confirm,
- 		SMC_LLC_WAIT_FIRST_TIME);
- 	if (rest <= 0) {
+ 	qentry = smc_llc_wait(link->lgr, NULL, SMC_LLC_WAIT_TIME,
+ 			      SMC_LLC_CONFIRM_LINK);
+ 	if (!qentry) {
  		struct smc_clc_msg_decline dclc;
  
  		rc = smc_clc_wait_msg(smc, &dclc, sizeof(dclc),
@@@ -421,18 -429,12 +428,25 @@@
  
  		rc = smc_clc_wait_msg(smc, &dclc, sizeof(dclc),
  				      SMC_CLC_DECLINE, CLC_WAIT_TIME_SHORT);
- 		return rc == -EAGAIN ? SMC_CLC_DECL_TIMEOUT_AL : rc;
+ 		if (rc == -EAGAIN)
+ 			rc = 0; /* no DECLINE received, go with one link */
+ 		return rc;
  	}
++<<<<<<< HEAD
 +
 +	/* send add link reject message, only one link supported for now */
 +	rc = smc_llc_send_add_link(link,
 +				   link->smcibdev->mac[link->ibport - 1],
 +				   link->gid, SMC_LLC_RESP);
 +	if (rc < 0)
 +		return SMC_CLC_DECL_TIMEOUT_AL;
 +
 +	smc_llc_link_active(link, net->ipv4.sysctl_tcp_keepalive_time);
 +
++=======
+ 	smc_llc_flow_qentry_clr(&link->lgr->llc_flow_lcl);
+ 	/* tbd: call smc_llc_cli_add_link(link, qentry); */
++>>>>>>> 0fb0b02bd6fd (net/smc: adapt SMC client code to use the LLC flow)
  	return 0;
  }
  
diff --cc net/smc/smc_core.h
index f72213c98957,31237c4c0d93..000000000000
--- a/net/smc/smc_core.h
+++ b/net/smc/smc_core.h
@@@ -119,13 -120,6 +119,16 @@@ struct smc_link 
  	struct smc_link_group	*lgr;		/* parent link group */
  
  	enum smc_link_state	state;		/* state of link */
++<<<<<<< HEAD
 +	struct workqueue_struct *llc_wq;	/* single thread work queue */
 +	struct completion	llc_confirm;	/* wait for rx of conf link */
 +	struct completion	llc_confirm_resp; /* wait 4 rx of cnf lnk rsp */
 +	int			llc_confirm_rc; /* rc from confirm link msg */
 +	int			llc_confirm_resp_rc; /* rc from conf_resp msg */
 +	struct completion	llc_add;	/* wait for rx of add link */
 +	struct completion	llc_add_resp;	/* wait for rx of add link rsp*/
++=======
++>>>>>>> 0fb0b02bd6fd (net/smc: adapt SMC client code to use the LLC flow)
  	struct delayed_work	llc_testlink_wrk; /* testlink worker */
  	struct completion	llc_testlink_resp; /* wait for rx of testlink */
  	int			llc_testlink_time; /* testlink interval */
diff --cc net/smc/smc_llc.c
index 4119cdb6b6bf,644e9ab0dec5..000000000000
--- a/net/smc/smc_llc.c
+++ b/net/smc/smc_llc.c
@@@ -400,62 -528,6 +400,65 @@@ static int smc_llc_send_message(struct 
  
  /********************************* receive ***********************************/
  
++<<<<<<< HEAD
 +static void smc_llc_rx_confirm_link(struct smc_link *link,
 +				    struct smc_llc_msg_confirm_link *llc)
 +{
 +	struct smc_link_group *lgr = smc_get_lgr(link);
 +	int conf_rc;
 +
 +	/* RMBE eyecatchers are not supported */
 +	if (llc->hd.flags & SMC_LLC_FLAG_NO_RMBE_EYEC)
 +		conf_rc = 0;
 +	else
 +		conf_rc = ENOTSUPP;
 +
 +	if (llc->hd.flags & SMC_LLC_FLAG_RESP) {
 +		if (lgr->role == SMC_SERV &&
 +		    link->state == SMC_LNK_ACTIVATING) {
 +			link->llc_confirm_resp_rc = conf_rc;
 +			complete(&link->llc_confirm_resp);
 +		}
 +	} else {
 +		if (lgr->role == SMC_CLNT &&
 +		    link->state == SMC_LNK_ACTIVATING) {
 +			link->llc_confirm_rc = conf_rc;
 +			link->link_id = llc->link_num;
 +			complete(&link->llc_confirm);
 +		}
 +	}
 +}
 +
 +static void smc_llc_rx_add_link(struct smc_link *link,
 +				struct smc_llc_msg_add_link *llc)
 +{
 +	struct smc_link_group *lgr = smc_get_lgr(link);
 +
 +	if (llc->hd.flags & SMC_LLC_FLAG_RESP) {
 +		if (link->state == SMC_LNK_ACTIVATING)
 +			complete(&link->llc_add_resp);
 +	} else {
 +		if (link->state == SMC_LNK_ACTIVATING) {
 +			complete(&link->llc_add);
 +			return;
 +		}
 +
 +		if (lgr->role == SMC_SERV) {
 +			smc_llc_prep_add_link(llc, link,
 +					link->smcibdev->mac[link->ibport - 1],
 +					link->gid, SMC_LLC_REQ);
 +
 +		} else {
 +			smc_llc_prep_add_link(llc, link,
 +					link->smcibdev->mac[link->ibport - 1],
 +					link->gid, SMC_LLC_RESP);
 +		}
 +		smc_llc_send_message(link, llc, sizeof(*llc));
 +	}
 +}
 +
++=======
++>>>>>>> 0fb0b02bd6fd (net/smc: adapt SMC client code to use the LLC flow)
  static void smc_llc_rx_delete_link(struct smc_link *link,
  				   struct smc_llc_msg_del_link *llc)
  {
@@@ -532,38 -584,42 +535,57 @@@ static void smc_llc_rx_delete_rkey(stru
  	u8 err_mask = 0;
  	int i, max;
  
 -	max = min_t(u8, llc->num_rkeys, SMC_LLC_DEL_RKEY_MAX);
 -	for (i = 0; i < max; i++) {
 -		if (smc_rtoken_delete(link, llc->rkey[i]))
 -			err_mask |= 1 << (SMC_LLC_DEL_RKEY_MAX - 1 - i);
 -	}
 +	if (llc->hd.flags & SMC_LLC_FLAG_RESP) {
 +		link->llc_delete_rkey_rc = llc->hd.flags &
 +					    SMC_LLC_FLAG_RKEY_NEG;
 +		complete(&link->llc_delete_rkey);
 +	} else {
 +		max = min_t(u8, llc->num_rkeys, SMC_LLC_DEL_RKEY_MAX);
 +		for (i = 0; i < max; i++) {
 +			if (smc_rtoken_delete(link, llc->rkey[i]))
 +				err_mask |= 1 << (SMC_LLC_DEL_RKEY_MAX - 1 - i);
 +		}
  
 -	if (err_mask) {
 -		llc->hd.flags |= SMC_LLC_FLAG_RKEY_NEG;
 -		llc->err_mask = err_mask;
 -	}
 +		if (err_mask) {
 +			llc->hd.flags |= SMC_LLC_FLAG_RKEY_NEG;
 +			llc->err_mask = err_mask;
 +		}
  
 -	llc->hd.flags |= SMC_LLC_FLAG_RESP;
 -	smc_llc_send_message(link, llc);
 +		llc->hd.flags |= SMC_LLC_FLAG_RESP;
 +		smc_llc_send_message(link, llc, sizeof(*llc));
 +	}
  }
  
 -/* flush the llc event queue */
 -static void smc_llc_event_flush(struct smc_link_group *lgr)
 +static void smc_llc_rx_handler(struct ib_wc *wc, void *buf)
  {
 -	struct smc_llc_qentry *qentry, *q;
 +	struct smc_link *link = (struct smc_link *)wc->qp->qp_context;
 +	union smc_llc_msg *llc = buf;
  
++<<<<<<< HEAD
 +	if (wc->byte_len < sizeof(*llc))
 +		return; /* short message */
 +	if (llc->raw.hdr.length != sizeof(*llc))
 +		return; /* invalid message */
 +	if (link->state == SMC_LNK_INACTIVE)
 +		return; /* link not active, drop msg */
++=======
+ 	spin_lock_bh(&lgr->llc_event_q_lock);
+ 	list_for_each_entry_safe(qentry, q, &lgr->llc_event_q, list) {
+ 		list_del_init(&qentry->list);
+ 		kfree(qentry);
+ 	}
+ 	spin_unlock_bh(&lgr->llc_event_q_lock);
+ }
+ 
+ static void smc_llc_event_handler(struct smc_llc_qentry *qentry)
+ {
+ 	union smc_llc_msg *llc = &qentry->msg;
+ 	struct smc_link *link = qentry->link;
+ 	struct smc_link_group *lgr = link->lgr;
+ 
+ 	if (!smc_link_usable(link))
+ 		goto out;
++>>>>>>> 0fb0b02bd6fd (net/smc: adapt SMC client code to use the LLC flow)
  
  	switch (llc->raw.hdr.common.type) {
  	case SMC_LLC_TEST_LINK:
@@@ -624,20 -811,34 +666,25 @@@ out
  	schedule_delayed_work(&link->llc_testlink_wrk, next_interval);
  }
  
 -void smc_llc_lgr_init(struct smc_link_group *lgr, struct smc_sock *smc)
 -{
 -	struct net *net = sock_net(smc->clcsock->sk);
 -
 -	INIT_WORK(&lgr->llc_event_work, smc_llc_event_work);
 -	INIT_LIST_HEAD(&lgr->llc_event_q);
 -	spin_lock_init(&lgr->llc_event_q_lock);
 -	spin_lock_init(&lgr->llc_flow_lock);
 -	init_waitqueue_head(&lgr->llc_waiter);
 -	lgr->llc_testlink_time = net->ipv4.sysctl_tcp_keepalive_time;
 -}
 -
 -/* called after lgr was removed from lgr_list */
 -void smc_llc_lgr_clear(struct smc_link_group *lgr)
 -{
 -	smc_llc_event_flush(lgr);
 -	wake_up_interruptible_all(&lgr->llc_waiter);
 -	cancel_work_sync(&lgr->llc_event_work);
 -	if (lgr->delayed_event) {
 -		kfree(lgr->delayed_event);
 -		lgr->delayed_event = NULL;
 -	}
 -}
 -
  int smc_llc_link_init(struct smc_link *link)
  {
++<<<<<<< HEAD
 +	struct smc_link_group *lgr = smc_get_lgr(link);
 +	link->llc_wq = alloc_ordered_workqueue("llc_wq-%x:%x)", WQ_MEM_RECLAIM,
 +					       *((u32 *)lgr->id),
 +					       link->link_id);
 +	if (!link->llc_wq)
 +		return -ENOMEM;
 +	init_completion(&link->llc_confirm);
 +	init_completion(&link->llc_confirm_resp);
 +	init_completion(&link->llc_add);
 +	init_completion(&link->llc_add_resp);
 +	init_completion(&link->llc_confirm_rkey);
 +	init_completion(&link->llc_delete_rkey);
++=======
+ 	init_completion(&link->llc_confirm_rkey_resp);
+ 	init_completion(&link->llc_delete_rkey_resp);
++>>>>>>> 0fb0b02bd6fd (net/smc: adapt SMC client code to use the LLC flow)
  	mutex_init(&link->llc_delete_rkey_mutex);
  	init_completion(&link->llc_testlink_resp);
  	INIT_DELAYED_WORK(&link->llc_testlink_wrk, smc_llc_testlink_work);
* Unmerged path net/smc/af_smc.c
diff --git a/net/smc/smc_clc.h b/net/smc/smc_clc.h
index 4f2e150a2be1..465876701b75 100644
--- a/net/smc/smc_clc.h
+++ b/net/smc/smc_clc.h
@@ -45,6 +45,7 @@
 #define SMC_CLC_DECL_GETVLANERR	0x03080000  /* err to get vlan id of ip device*/
 #define SMC_CLC_DECL_ISMVLANERR	0x03090000  /* err to reg vlan id on ism dev  */
 #define SMC_CLC_DECL_NOACTLINK	0x030a0000  /* no active smc-r link in lgr    */
+#define SMC_CLC_DECL_NOSRVLINK	0x030b0000  /* SMC-R link from srv not found  */
 #define SMC_CLC_DECL_SYNCERR	0x04000000  /* synchronization error          */
 #define SMC_CLC_DECL_PEERDECL	0x05000000  /* peer declined during handshake */
 #define SMC_CLC_DECL_INTERR	0x09990000  /* internal error		      */
* Unmerged path net/smc/smc_core.h
* Unmerged path net/smc/smc_llc.c
