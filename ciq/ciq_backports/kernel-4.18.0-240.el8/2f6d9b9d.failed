io_uring: clean up io_uring_cancel_files()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Bob Liu <bob.liu@oracle.com>
commit 2f6d9b9d6357ede64a29437676884ee263039910
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/2f6d9b9d.failed

We don't use the return value anymore, drop it. Also drop the
unecessary double cancel_req value check.

	Signed-off-by: Bob Liu <bob.liu@oracle.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 2f6d9b9d6357ede64a29437676884ee263039910)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index f656b9c7fa46,297b9e80dc5c..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -3565,6 -4296,53 +3565,56 @@@ static int io_uring_release(struct inod
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void io_uring_cancel_files(struct io_ring_ctx *ctx,
+ 				  struct files_struct *files)
+ {
+ 	struct io_kiocb *req;
+ 	DEFINE_WAIT(wait);
+ 
+ 	while (!list_empty_careful(&ctx->inflight_list)) {
+ 		struct io_kiocb *cancel_req = NULL;
+ 
+ 		spin_lock_irq(&ctx->inflight_lock);
+ 		list_for_each_entry(req, &ctx->inflight_list, inflight_entry) {
+ 			if (req->work.files != files)
+ 				continue;
+ 			/* req is being completed, ignore */
+ 			if (!refcount_inc_not_zero(&req->refs))
+ 				continue;
+ 			cancel_req = req;
+ 			break;
+ 		}
+ 		if (cancel_req)
+ 			prepare_to_wait(&ctx->inflight_wait, &wait,
+ 						TASK_UNINTERRUPTIBLE);
+ 		spin_unlock_irq(&ctx->inflight_lock);
+ 
+ 		/* We need to keep going until we don't find a matching req */
+ 		if (!cancel_req)
+ 			break;
+ 
+ 		io_wq_cancel_work(ctx->io_wq, &cancel_req->work);
+ 		io_put_req(cancel_req);
+ 		schedule();
+ 	}
+ 	finish_wait(&ctx->inflight_wait, &wait);
+ }
+ 
+ static int io_uring_flush(struct file *file, void *data)
+ {
+ 	struct io_ring_ctx *ctx = file->private_data;
+ 
+ 	io_uring_cancel_files(ctx, data);
+ 	if (fatal_signal_pending(current) || (current->flags & PF_EXITING)) {
+ 		io_cqring_overflow_flush(ctx, true);
+ 		io_wq_cancel_all(ctx->io_wq);
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 2f6d9b9d6357 (io_uring: clean up io_uring_cancel_files())
  static int io_uring_mmap(struct file *file, struct vm_area_struct *vma)
  {
  	loff_t offset = (loff_t) vma->vm_pgoff << PAGE_SHIFT;
* Unmerged path fs/io_uring.c
