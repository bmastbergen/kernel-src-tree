bpf: Fix a potential deadlock with bpf_map_do_batch

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Yonghong Song <yhs@fb.com>
commit b9aff38de2cb166476988020428985c5f7412ffc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b9aff38d.failed

Commit 057996380a42 ("bpf: Add batch ops to all htab bpf map")
added lookup_and_delete batch operation for hash table.
The current implementation has bpf_lru_push_free() inside
the bucket lock, which may cause a deadlock.

syzbot reports:
   -> #2 (&htab->buckets[i].lock#2){....}:
       __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]
       _raw_spin_lock_irqsave+0x95/0xcd kernel/locking/spinlock.c:159
       htab_lru_map_delete_node+0xce/0x2f0 kernel/bpf/hashtab.c:593
       __bpf_lru_list_shrink_inactive kernel/bpf/bpf_lru_list.c:220 [inline]
       __bpf_lru_list_shrink+0xf9/0x470 kernel/bpf/bpf_lru_list.c:266
       bpf_lru_list_pop_free_to_local kernel/bpf/bpf_lru_list.c:340 [inline]
       bpf_common_lru_pop_free kernel/bpf/bpf_lru_list.c:447 [inline]
       bpf_lru_pop_free+0x87c/0x1670 kernel/bpf/bpf_lru_list.c:499
       prealloc_lru_pop+0x2c/0xa0 kernel/bpf/hashtab.c:132
       __htab_lru_percpu_map_update_elem+0x67e/0xa90 kernel/bpf/hashtab.c:1069
       bpf_percpu_hash_update+0x16e/0x210 kernel/bpf/hashtab.c:1585
       bpf_map_update_value.isra.0+0x2d7/0x8e0 kernel/bpf/syscall.c:181
       generic_map_update_batch+0x41f/0x610 kernel/bpf/syscall.c:1319
       bpf_map_do_batch+0x3f5/0x510 kernel/bpf/syscall.c:3348
       __do_sys_bpf+0x9b7/0x41e0 kernel/bpf/syscall.c:3460
       __se_sys_bpf kernel/bpf/syscall.c:3355 [inline]
       __x64_sys_bpf+0x73/0xb0 kernel/bpf/syscall.c:3355
       do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
       entry_SYSCALL_64_after_hwframe+0x49/0xbe

   -> #0 (&loc_l->lock){....}:
       check_prev_add kernel/locking/lockdep.c:2475 [inline]
       check_prevs_add kernel/locking/lockdep.c:2580 [inline]
       validate_chain kernel/locking/lockdep.c:2970 [inline]
       __lock_acquire+0x2596/0x4a00 kernel/locking/lockdep.c:3954
       lock_acquire+0x190/0x410 kernel/locking/lockdep.c:4484
       __raw_spin_lock_irqsave include/linux/spinlock_api_smp.h:110 [inline]
       _raw_spin_lock_irqsave+0x95/0xcd kernel/locking/spinlock.c:159
       bpf_common_lru_push_free kernel/bpf/bpf_lru_list.c:516 [inline]
       bpf_lru_push_free+0x250/0x5b0 kernel/bpf/bpf_lru_list.c:555
       __htab_map_lookup_and_delete_batch+0x8d4/0x1540 kernel/bpf/hashtab.c:1374
       htab_lru_map_lookup_and_delete_batch+0x34/0x40 kernel/bpf/hashtab.c:1491
       bpf_map_do_batch+0x3f5/0x510 kernel/bpf/syscall.c:3348
       __do_sys_bpf+0x1f7d/0x41e0 kernel/bpf/syscall.c:3456
       __se_sys_bpf kernel/bpf/syscall.c:3355 [inline]
       __x64_sys_bpf+0x73/0xb0 kernel/bpf/syscall.c:3355
       do_syscall_64+0xfa/0x790 arch/x86/entry/common.c:294
       entry_SYSCALL_64_after_hwframe+0x49/0xbe

    Possible unsafe locking scenario:

          CPU0                    CPU2
          ----                    ----
     lock(&htab->buckets[i].lock#2);
                                  lock(&l->lock);
                                  lock(&htab->buckets[i].lock#2);
     lock(&loc_l->lock);

    *** DEADLOCK ***

To fix the issue, for htab_lru_map_lookup_and_delete_batch() in CPU0,
let us do bpf_lru_push_free() out of the htab bucket lock. This can
avoid the above deadlock scenario.

Fixes: 057996380a42 ("bpf: Add batch ops to all htab bpf map")
	Reported-by: syzbot+a38ff3d9356388f2fb83@syzkaller.appspotmail.com
	Reported-by: syzbot+122b5421d14e68f29cd1@syzkaller.appspotmail.com
	Suggested-by: Hillf Danton <hdanton@sina.com>
	Suggested-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Reviewed-by: Jakub Sitnicki <jakub@cloudflare.com>
	Acked-by: Brian Vazquez <brianvv@google.com>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
Link: https://lore.kernel.org/bpf/20200219234757.3544014-1-yhs@fb.com
(cherry picked from commit b9aff38de2cb166476988020428985c5f7412ffc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/hashtab.c
diff --cc kernel/bpf/hashtab.c
index d92e05d9979b,a1468e3f5af2..000000000000
--- a/kernel/bpf/hashtab.c
+++ b/kernel/bpf/hashtab.c
@@@ -1240,6 -1254,292 +1252,295 @@@ static void htab_map_seq_show_elem(stru
  	rcu_read_unlock();
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ __htab_map_lookup_and_delete_batch(struct bpf_map *map,
+ 				   const union bpf_attr *attr,
+ 				   union bpf_attr __user *uattr,
+ 				   bool do_delete, bool is_lru_map,
+ 				   bool is_percpu)
+ {
+ 	struct bpf_htab *htab = container_of(map, struct bpf_htab, map);
+ 	u32 bucket_cnt, total, key_size, value_size, roundup_key_size;
+ 	void *keys = NULL, *values = NULL, *value, *dst_key, *dst_val;
+ 	void __user *uvalues = u64_to_user_ptr(attr->batch.values);
+ 	void __user *ukeys = u64_to_user_ptr(attr->batch.keys);
+ 	void *ubatch = u64_to_user_ptr(attr->batch.in_batch);
+ 	u32 batch, max_count, size, bucket_size;
+ 	struct htab_elem *node_to_free = NULL;
+ 	u64 elem_map_flags, map_flags;
+ 	struct hlist_nulls_head *head;
+ 	struct hlist_nulls_node *n;
+ 	unsigned long flags = 0;
+ 	bool locked = false;
+ 	struct htab_elem *l;
+ 	struct bucket *b;
+ 	int ret = 0;
+ 
+ 	elem_map_flags = attr->batch.elem_flags;
+ 	if ((elem_map_flags & ~BPF_F_LOCK) ||
+ 	    ((elem_map_flags & BPF_F_LOCK) && !map_value_has_spin_lock(map)))
+ 		return -EINVAL;
+ 
+ 	map_flags = attr->batch.flags;
+ 	if (map_flags)
+ 		return -EINVAL;
+ 
+ 	max_count = attr->batch.count;
+ 	if (!max_count)
+ 		return 0;
+ 
+ 	if (put_user(0, &uattr->batch.count))
+ 		return -EFAULT;
+ 
+ 	batch = 0;
+ 	if (ubatch && copy_from_user(&batch, ubatch, sizeof(batch)))
+ 		return -EFAULT;
+ 
+ 	if (batch >= htab->n_buckets)
+ 		return -ENOENT;
+ 
+ 	key_size = htab->map.key_size;
+ 	roundup_key_size = round_up(htab->map.key_size, 8);
+ 	value_size = htab->map.value_size;
+ 	size = round_up(value_size, 8);
+ 	if (is_percpu)
+ 		value_size = size * num_possible_cpus();
+ 	total = 0;
+ 	/* while experimenting with hash tables with sizes ranging from 10 to
+ 	 * 1000, it was observed that a bucket can have upto 5 entries.
+ 	 */
+ 	bucket_size = 5;
+ 
+ alloc:
+ 	/* We cannot do copy_from_user or copy_to_user inside
+ 	 * the rcu_read_lock. Allocate enough space here.
+ 	 */
+ 	keys = kvmalloc(key_size * bucket_size, GFP_USER | __GFP_NOWARN);
+ 	values = kvmalloc(value_size * bucket_size, GFP_USER | __GFP_NOWARN);
+ 	if (!keys || !values) {
+ 		ret = -ENOMEM;
+ 		goto after_loop;
+ 	}
+ 
+ again:
+ 	preempt_disable();
+ 	this_cpu_inc(bpf_prog_active);
+ 	rcu_read_lock();
+ again_nocopy:
+ 	dst_key = keys;
+ 	dst_val = values;
+ 	b = &htab->buckets[batch];
+ 	head = &b->head;
+ 	/* do not grab the lock unless need it (bucket_cnt > 0). */
+ 	if (locked)
+ 		raw_spin_lock_irqsave(&b->lock, flags);
+ 
+ 	bucket_cnt = 0;
+ 	hlist_nulls_for_each_entry_rcu(l, n, head, hash_node)
+ 		bucket_cnt++;
+ 
+ 	if (bucket_cnt && !locked) {
+ 		locked = true;
+ 		goto again_nocopy;
+ 	}
+ 
+ 	if (bucket_cnt > (max_count - total)) {
+ 		if (total == 0)
+ 			ret = -ENOSPC;
+ 		/* Note that since bucket_cnt > 0 here, it is implicit
+ 		 * that the locked was grabbed, so release it.
+ 		 */
+ 		raw_spin_unlock_irqrestore(&b->lock, flags);
+ 		rcu_read_unlock();
+ 		this_cpu_dec(bpf_prog_active);
+ 		preempt_enable();
+ 		goto after_loop;
+ 	}
+ 
+ 	if (bucket_cnt > bucket_size) {
+ 		bucket_size = bucket_cnt;
+ 		/* Note that since bucket_cnt > 0 here, it is implicit
+ 		 * that the locked was grabbed, so release it.
+ 		 */
+ 		raw_spin_unlock_irqrestore(&b->lock, flags);
+ 		rcu_read_unlock();
+ 		this_cpu_dec(bpf_prog_active);
+ 		preempt_enable();
+ 		kvfree(keys);
+ 		kvfree(values);
+ 		goto alloc;
+ 	}
+ 
+ 	/* Next block is only safe to run if you have grabbed the lock */
+ 	if (!locked)
+ 		goto next_batch;
+ 
+ 	hlist_nulls_for_each_entry_safe(l, n, head, hash_node) {
+ 		memcpy(dst_key, l->key, key_size);
+ 
+ 		if (is_percpu) {
+ 			int off = 0, cpu;
+ 			void __percpu *pptr;
+ 
+ 			pptr = htab_elem_get_ptr(l, map->key_size);
+ 			for_each_possible_cpu(cpu) {
+ 				bpf_long_memcpy(dst_val + off,
+ 						per_cpu_ptr(pptr, cpu), size);
+ 				off += size;
+ 			}
+ 		} else {
+ 			value = l->key + roundup_key_size;
+ 			if (elem_map_flags & BPF_F_LOCK)
+ 				copy_map_value_locked(map, dst_val, value,
+ 						      true);
+ 			else
+ 				copy_map_value(map, dst_val, value);
+ 			check_and_init_map_lock(map, dst_val);
+ 		}
+ 		if (do_delete) {
+ 			hlist_nulls_del_rcu(&l->hash_node);
+ 
+ 			/* bpf_lru_push_free() will acquire lru_lock, which
+ 			 * may cause deadlock. See comments in function
+ 			 * prealloc_lru_pop(). Let us do bpf_lru_push_free()
+ 			 * after releasing the bucket lock.
+ 			 */
+ 			if (is_lru_map) {
+ 				l->batch_flink = node_to_free;
+ 				node_to_free = l;
+ 			} else {
+ 				free_htab_elem(htab, l);
+ 			}
+ 		}
+ 		dst_key += key_size;
+ 		dst_val += value_size;
+ 	}
+ 
+ 	raw_spin_unlock_irqrestore(&b->lock, flags);
+ 	locked = false;
+ 
+ 	while (node_to_free) {
+ 		l = node_to_free;
+ 		node_to_free = node_to_free->batch_flink;
+ 		bpf_lru_push_free(&htab->lru, &l->lru_node);
+ 	}
+ 
+ next_batch:
+ 	/* If we are not copying data, we can go to next bucket and avoid
+ 	 * unlocking the rcu.
+ 	 */
+ 	if (!bucket_cnt && (batch + 1 < htab->n_buckets)) {
+ 		batch++;
+ 		goto again_nocopy;
+ 	}
+ 
+ 	rcu_read_unlock();
+ 	this_cpu_dec(bpf_prog_active);
+ 	preempt_enable();
+ 	if (bucket_cnt && (copy_to_user(ukeys + total * key_size, keys,
+ 	    key_size * bucket_cnt) ||
+ 	    copy_to_user(uvalues + total * value_size, values,
+ 	    value_size * bucket_cnt))) {
+ 		ret = -EFAULT;
+ 		goto after_loop;
+ 	}
+ 
+ 	total += bucket_cnt;
+ 	batch++;
+ 	if (batch >= htab->n_buckets) {
+ 		ret = -ENOENT;
+ 		goto after_loop;
+ 	}
+ 	goto again;
+ 
+ after_loop:
+ 	if (ret == -EFAULT)
+ 		goto out;
+ 
+ 	/* copy # of entries and next batch */
+ 	ubatch = u64_to_user_ptr(attr->batch.out_batch);
+ 	if (copy_to_user(ubatch, &batch, sizeof(batch)) ||
+ 	    put_user(total, &uattr->batch.count))
+ 		ret = -EFAULT;
+ 
+ out:
+ 	kvfree(keys);
+ 	kvfree(values);
+ 	return ret;
+ }
+ 
+ static int
+ htab_percpu_map_lookup_batch(struct bpf_map *map, const union bpf_attr *attr,
+ 			     union bpf_attr __user *uattr)
+ {
+ 	return __htab_map_lookup_and_delete_batch(map, attr, uattr, false,
+ 						  false, true);
+ }
+ 
+ static int
+ htab_percpu_map_lookup_and_delete_batch(struct bpf_map *map,
+ 					const union bpf_attr *attr,
+ 					union bpf_attr __user *uattr)
+ {
+ 	return __htab_map_lookup_and_delete_batch(map, attr, uattr, true,
+ 						  false, true);
+ }
+ 
+ static int
+ htab_map_lookup_batch(struct bpf_map *map, const union bpf_attr *attr,
+ 		      union bpf_attr __user *uattr)
+ {
+ 	return __htab_map_lookup_and_delete_batch(map, attr, uattr, false,
+ 						  false, false);
+ }
+ 
+ static int
+ htab_map_lookup_and_delete_batch(struct bpf_map *map,
+ 				 const union bpf_attr *attr,
+ 				 union bpf_attr __user *uattr)
+ {
+ 	return __htab_map_lookup_and_delete_batch(map, attr, uattr, true,
+ 						  false, false);
+ }
+ 
+ static int
+ htab_lru_percpu_map_lookup_batch(struct bpf_map *map,
+ 				 const union bpf_attr *attr,
+ 				 union bpf_attr __user *uattr)
+ {
+ 	return __htab_map_lookup_and_delete_batch(map, attr, uattr, false,
+ 						  true, true);
+ }
+ 
+ static int
+ htab_lru_percpu_map_lookup_and_delete_batch(struct bpf_map *map,
+ 					    const union bpf_attr *attr,
+ 					    union bpf_attr __user *uattr)
+ {
+ 	return __htab_map_lookup_and_delete_batch(map, attr, uattr, true,
+ 						  true, true);
+ }
+ 
+ static int
+ htab_lru_map_lookup_batch(struct bpf_map *map, const union bpf_attr *attr,
+ 			  union bpf_attr __user *uattr)
+ {
+ 	return __htab_map_lookup_and_delete_batch(map, attr, uattr, false,
+ 						  true, false);
+ }
+ 
+ static int
+ htab_lru_map_lookup_and_delete_batch(struct bpf_map *map,
+ 				     const union bpf_attr *attr,
+ 				     union bpf_attr __user *uattr)
+ {
+ 	return __htab_map_lookup_and_delete_batch(map, attr, uattr, true,
+ 						  true, false);
+ }
+ 
++>>>>>>> b9aff38de2cb (bpf: Fix a potential deadlock with bpf_map_do_batch)
  const struct bpf_map_ops htab_map_ops = {
  	.map_alloc_check = htab_map_alloc_check,
  	.map_alloc = htab_map_alloc,
* Unmerged path kernel/bpf/hashtab.c
