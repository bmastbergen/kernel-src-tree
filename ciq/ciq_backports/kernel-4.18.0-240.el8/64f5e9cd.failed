nvmet: fix memory leak when removing namespaces and controllers concurrently

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sagi Grimberg <sagi@grimberg.me>
commit 64f5e9cdd711b030b05062c17b2ecfbce890cf4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/64f5e9cd.failed

When removing a namespace, we add an NS_CHANGE async event, however if
the controller admin queue is removed after the event was added but not
yet processed, we won't free the aens, resulting in the below memory
leak [1].

Fix that by moving nvmet_async_event_free to the final controller
release after it is detached from subsys->ctrls ensuring no async
events are added, and modify it to simply remove all pending aens.

--
$ cat /sys/kernel/debug/kmemleak
unreferenced object 0xffff888c1af2c000 (size 32):
  comm "nvmetcli", pid 5164, jiffies 4295220864 (age 6829.924s)
  hex dump (first 32 bytes):
    28 01 82 3b 8b 88 ff ff 28 01 82 3b 8b 88 ff ff  (..;....(..;....
    02 00 04 65 76 65 6e 74 5f 66 69 6c 65 00 00 00  ...event_file...
  backtrace:
    [<00000000217ae580>] nvmet_add_async_event+0x57/0x290 [nvmet]
    [<0000000012aa2ea9>] nvmet_ns_changed+0x206/0x300 [nvmet]
    [<00000000bb3fd52e>] nvmet_ns_disable+0x367/0x4f0 [nvmet]
    [<00000000e91ca9ec>] nvmet_ns_free+0x15/0x180 [nvmet]
    [<00000000a15deb52>] config_item_release+0xf1/0x1c0
    [<000000007e148432>] configfs_rmdir+0x555/0x7c0
    [<00000000f4506ea6>] vfs_rmdir+0x142/0x3c0
    [<0000000000acaaf0>] do_rmdir+0x2b2/0x340
    [<0000000034d1aa52>] do_syscall_64+0xa5/0x4d0
    [<00000000211f13bc>] entry_SYSCALL_64_after_hwframe+0x6a/0xdf

Fixes: a07b4970f464 ("nvmet: add a generic NVMe target")
	Reported-by: David Milburn <dmilburn@redhat.com>
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Tested-by: David Milburn <dmilburn@redhat.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 64f5e9cdd711b030b05062c17b2ecfbce890cf4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/core.c
diff --cc drivers/nvme/target/core.c
index 95fd5ac37be9,48f5123d875b..000000000000
--- a/drivers/nvme/target/core.c
+++ b/drivers/nvme/target/core.c
@@@ -181,6 -156,26 +181,29 @@@ static void nvmet_async_event_work(stru
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void nvmet_async_events_free(struct nvmet_ctrl *ctrl)
+ {
+ 	struct nvmet_async_event *aen, *tmp;
+ 
+ 	mutex_lock(&ctrl->lock);
+ 	list_for_each_entry_safe(aen, tmp, &ctrl->async_events, entry) {
+ 		list_del(&aen->entry);
+ 		kfree(aen);
+ 	}
+ 	mutex_unlock(&ctrl->lock);
+ }
+ 
+ static void nvmet_async_event_work(struct work_struct *work)
+ {
+ 	struct nvmet_ctrl *ctrl =
+ 		container_of(work, struct nvmet_ctrl, async_event_work);
+ 
+ 	nvmet_async_events_process(ctrl, 0);
+ }
+ 
++>>>>>>> 64f5e9cdd711 (nvmet: fix memory leak when removing namespaces and controllers concurrently)
  void nvmet_add_async_event(struct nvmet_ctrl *ctrl, u8 event_type,
  		u8 event_info, u8 log_page)
  {
@@@ -763,8 -789,8 +786,13 @@@ void nvmet_sq_destroy(struct nvmet_sq *
  	 * If this is the admin queue, complete all AERs so that our
  	 * queue doesn't have outstanding requests on it.
  	 */
++<<<<<<< HEAD
 +	if (sq->ctrl && sq->ctrl->sqs && sq->ctrl->sqs[0] == sq)
 +		nvmet_async_events_free(sq->ctrl);
++=======
+ 	if (ctrl && ctrl->sqs && ctrl->sqs[0] == sq)
+ 		nvmet_async_events_process(ctrl, status);
++>>>>>>> 64f5e9cdd711 (nvmet: fix memory leak when removing namespaces and controllers concurrently)
  	percpu_ref_kill_and_confirm(&sq->ref, nvmet_confirm_sq);
  	wait_for_completion(&sq->confirm_done);
  	wait_for_completion(&sq->free_done);
* Unmerged path drivers/nvme/target/core.c
