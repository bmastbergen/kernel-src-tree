io-wq: have io_wq_create() take a 'data' argument

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 576a347b7af8abfbddc80783fb6629c2894d036e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/576a347b.failed

We currently pass in 4 arguments outside of the bounded size. In
preparation for adding one more argument, let's bundle them up in
a struct to make it more readable.

No functional changes in this patch.

	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 576a347b7af8abfbddc80783fb6629c2894d036e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io-wq.c
#	fs/io-wq.h
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 9058714611f6,fabae84396bc..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -3143,6 -3948,22 +3143,11 @@@ static int io_sqe_files_update(struct i
  static int io_sq_offload_start(struct io_ring_ctx *ctx,
  			       struct io_uring_params *p)
  {
++<<<<<<< HEAD
++=======
+ 	struct io_wq_data data;
+ 	unsigned concurrency;
++>>>>>>> 576a347b7af8 (io-wq: have io_wq_create() take a 'data' argument)
  	int ret;
  
  	init_waitqueue_head(&ctx->sqo_wait);
@@@ -3186,26 -4007,17 +3191,40 @@@
  		goto err;
  	}
  
++<<<<<<< HEAD
 +	/* Do QD, or 2 * CPUS, whatever is smallest */
 +	ctx->sqo_wq[0] = alloc_workqueue("io_ring-wq",
 +			WQ_UNBOUND | WQ_FREEZABLE,
 +			min(ctx->sq_entries - 1, 2 * num_online_cpus()));
 +	if (!ctx->sqo_wq[0]) {
 +		ret = -ENOMEM;
 +		goto err;
 +	}
 +
 +	/*
 +	 * This is for buffered writes, where we want to limit the parallelism
 +	 * due to file locking in file systems. As "normal" buffered writes
 +	 * should parellelize on writeout quite nicely, limit us to having 2
 +	 * pending. This avoids massive contention on the inode when doing
 +	 * buffered async writes.
 +	 */
 +	ctx->sqo_wq[1] = alloc_workqueue("io_ring-write-wq",
 +						WQ_UNBOUND | WQ_FREEZABLE, 2);
 +	if (!ctx->sqo_wq[1]) {
 +		ret = -ENOMEM;
++=======
+ 	data.mm = ctx->sqo_mm;
+ 	data.user = ctx->user;
+ 	data.get_work = io_get_work;
+ 	data.put_work = io_put_work;
+ 
+ 	/* Do QD, or 4 * CPUS, whatever is smallest */
+ 	concurrency = min(ctx->sq_entries, 4 * num_online_cpus());
+ 	ctx->io_wq = io_wq_create(concurrency, &data);
+ 	if (IS_ERR(ctx->io_wq)) {
+ 		ret = PTR_ERR(ctx->io_wq);
+ 		ctx->io_wq = NULL;
++>>>>>>> 576a347b7af8 (io-wq: have io_wq_create() take a 'data' argument)
  		goto err;
  	}
  
* Unmerged path fs/io-wq.c
* Unmerged path fs/io-wq.h
* Unmerged path fs/io-wq.c
* Unmerged path fs/io-wq.h
* Unmerged path fs/io_uring.c
