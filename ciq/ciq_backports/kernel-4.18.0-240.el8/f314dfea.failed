modsign: log module name in the event of an error

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jessica Yu <jeyu@kernel.org>
commit f314dfea16a085a58d2ff227ea9fa9e490ee5d18
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f314dfea.failed

Now that we have the load_info struct all initialized (including
info->name, which contains the name of the module) before
module_sig_check(), make the load_info struct and hence module name
available to mod_verify_sig() so that we can log the module name in the
event of an error.

	Signed-off-by: Jessica Yu <jeyu@kernel.org>
(cherry picked from commit f314dfea16a085a58d2ff227ea9fa9e490ee5d18)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/module.c
#	kernel/module_signing.c
diff --cc kernel/module.c
index 6af46d7fb3c6,8a45986fd728..000000000000
--- a/kernel/module.c
+++ b/kernel/module.c
@@@ -313,24 -307,6 +313,27 @@@ int unregister_module_notifier(struct n
  }
  EXPORT_SYMBOL(unregister_module_notifier);
  
++<<<<<<< HEAD
 +struct load_info {
 +	const char *name;
 +	Elf_Ehdr *hdr;
 +	unsigned long len;
 +	Elf_Shdr *sechdrs;
 +	char *secstrings, *strtab;
 +	unsigned long symoffs, stroffs;
 +	struct _ddebug *debug;
 +	unsigned int num_debug;
 +	bool sig_ok;
 +#ifdef CONFIG_KALLSYMS
 +	unsigned long mod_kallsyms_init_off;
 +#endif
 +	struct {
 +		unsigned int sym, str, mod, vers, info, pcpu;
 +	} index;
 +};
 +
++=======
++>>>>>>> f314dfea16a0 (modsign: log module name in the event of an error)
  /*
   * We require a truly strong try_module_get(): 0 means success.
   * Otherwise an error is returned due to ongoing or failed
diff --cc kernel/module_signing.c
index 542a6768b56d,f2075ce8e4b3..000000000000
--- a/kernel/module_signing.c
+++ b/kernel/module_signing.c
@@@ -45,11 -45,10 +45,15 @@@ struct module_signature 
  /*
   * Verify the signature on a module.
   */
- int mod_verify_sig(const void *mod, unsigned long *_modlen)
+ int mod_verify_sig(const void *mod, struct load_info *info)
  {
  	struct module_signature ms;
++<<<<<<< HEAD
 +	size_t modlen = *_modlen, sig_len;
 +	int err;
++=======
+ 	size_t sig_len, modlen = info->len;
++>>>>>>> f314dfea16a0 (modsign: log module name in the event of an error)
  
  	pr_devel("==>%s(,%zu)\n", __func__, modlen);
  
diff --git a/kernel/module-internal.h b/kernel/module-internal.h
index 915e123a430f..79c9be2dbbe9 100644
--- a/kernel/module-internal.h
+++ b/kernel/module-internal.h
@@ -9,4 +9,27 @@
  * 2 of the Licence, or (at your option) any later version.
  */
 
-extern int mod_verify_sig(const void *mod, unsigned long *_modlen);
+#include <linux/elf.h>
+#include <asm/module.h>
+
+struct load_info {
+	const char *name;
+	/* pointer to module in temporary copy, freed at end of load_module() */
+	struct module *mod;
+	Elf_Ehdr *hdr;
+	unsigned long len;
+	Elf_Shdr *sechdrs;
+	char *secstrings, *strtab;
+	unsigned long symoffs, stroffs;
+	struct _ddebug *debug;
+	unsigned int num_debug;
+	bool sig_ok;
+#ifdef CONFIG_KALLSYMS
+	unsigned long mod_kallsyms_init_off;
+#endif
+	struct {
+		unsigned int sym, str, mod, vers, info, pcpu;
+	} index;
+};
+
+extern int mod_verify_sig(const void *mod, struct load_info *info);
* Unmerged path kernel/module.c
* Unmerged path kernel/module_signing.c
