iommu/amd: Do not loop forever when trying to increase address space

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Joerg Roedel <jroedel@suse.de>
commit 5b8a9a047b6cad361405c7900c1e1cdd378c4589
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5b8a9a04.failed

When increase_address_space() fails to allocate memory, alloc_pte()
will call it again until it succeeds. Do not loop forever while trying
to increase the address space and just return an error instead.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
	Tested-by: Qian Cai <cai@lca.pw>
Link: https://lore.kernel.org/r/20200504125413.16798-3-joro@8bytes.org
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 5b8a9a047b6cad361405c7900c1e1cdd378c4589)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/amd_iommu.c
diff --cc drivers/iommu/amd_iommu.c
index 6213e619c569,68da484a69dd..000000000000
--- a/drivers/iommu/amd_iommu.c
+++ b/drivers/iommu/amd_iommu.c
@@@ -1519,11 -1486,27 +1519,31 @@@ static u64 *alloc_pte(struct protection
  
  	BUG_ON(!is_power_of_2(page_size));
  
++<<<<<<< HEAD
 +	while (address > PM_LEVEL_SIZE(domain->mode))
 +		*updated = increase_address_space(domain, address, gfp) || *updated;
++=======
+ 	amd_iommu_domain_get_pgtable(domain, &pgtable);
+ 
+ 	while (address > PM_LEVEL_SIZE(pgtable.mode)) {
+ 		bool upd = increase_address_space(domain, address, gfp);
+ 
+ 		/* Read new values to check if update was successful */
+ 		amd_iommu_domain_get_pgtable(domain, &pgtable);
+ 
+ 		/*
+ 		 * Return an error if there is no memory to update the
+ 		 * page-table.
+ 		 */
+ 		if (!upd && (address > PM_LEVEL_SIZE(pgtable.mode)))
+ 			return NULL;
+ 
+ 		*updated = *updated || upd;
+ 	}
++>>>>>>> 5b8a9a047b6c (iommu/amd: Do not loop forever when trying to increase address space)
  
 -
 -	level   = pgtable.mode - 1;
 -	pte     = &pgtable.root[PM_LEVEL_INDEX(level, address)];
 +	level   = domain->mode - 1;
 +	pte     = &domain->pt_root[PM_LEVEL_INDEX(level, address)];
  	address = PAGE_SIZE_ALIGN(address, page_size);
  	end_lvl = PAGE_SIZE_LEVEL(page_size);
  
* Unmerged path drivers/iommu/amd_iommu.c
