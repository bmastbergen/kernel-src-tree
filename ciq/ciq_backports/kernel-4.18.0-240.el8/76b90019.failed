netfilter: nat: remove l4proto->nlattr_to_range

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 76b90019e03d866eab85cb57c2a6416ab94284dc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/76b90019.failed

all protocols did set this to nf_nat_l4proto_nlattr_to_range, so
just call it directly.

The important difference is that we'll now also call it for
protocols that we don't support (i.e., nf_nat_proto_unknown did
not provide .nlattr_to_range).

However, there should be no harm, even icmp provided this callback.
If we don't implement a specific l4nat for this, nothing would make
use of this information, so adding a big switch/case construct listing
all supported l4protocols seems a bit pointless.

This change leaves a single function pointer in the l4proto struct.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 76b90019e03d866eab85cb57c2a6416ab94284dc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_nat_l4proto.h
#	net/ipv4/netfilter/nf_nat_proto_gre.c
#	net/ipv4/netfilter/nf_nat_proto_icmp.c
#	net/ipv6/netfilter/nf_nat_proto_icmpv6.c
#	net/netfilter/nf_nat_proto_common.c
#	net/netfilter/nf_nat_proto_dccp.c
#	net/netfilter/nf_nat_proto_sctp.c
#	net/netfilter/nf_nat_proto_tcp.c
#	net/netfilter/nf_nat_proto_udp.c
diff --cc include/net/netfilter/nf_nat_l4proto.h
index 7ecac2cd1020,406f7effeb8e..000000000000
--- a/include/net/netfilter/nf_nat_l4proto.h
+++ b/include/net/netfilter/nf_nat_l4proto.h
@@@ -20,26 -20,6 +20,29 @@@ struct nf_nat_l4proto 
  			  unsigned int iphdroff, unsigned int hdroff,
  			  const struct nf_conntrack_tuple *tuple,
  			  enum nf_nat_manip_type maniptype);
++<<<<<<< HEAD
 +
 +	/* Is the manipable part of the tuple between min and max incl? */
 +	bool (*in_range)(const struct nf_conntrack_tuple *tuple,
 +			 enum nf_nat_manip_type maniptype,
 +			 const union nf_conntrack_man_proto *min,
 +			 const union nf_conntrack_man_proto *max);
 +
 +	/* Alter the per-proto part of the tuple (depending on
 +	 * maniptype), to give a unique tuple in the given range if
 +	 * possible.  Per-protocol part of tuple is initialized to the
 +	 * incoming packet.
 +	 */
 +	void (*unique_tuple)(const struct nf_nat_l3proto *l3proto,
 +			     struct nf_conntrack_tuple *tuple,
 +			     const struct nf_nat_range2 *range,
 +			     enum nf_nat_manip_type maniptype,
 +			     const struct nf_conn *ct);
 +
 +	int (*nlattr_to_range)(struct nlattr *tb[],
 +			       struct nf_nat_range2 *range);
++=======
++>>>>>>> 76b90019e03d (netfilter: nat: remove l4proto->nlattr_to_range)
  };
  
  /* Protocol registration. */
@@@ -65,18 -45,4 +68,21 @@@ extern const struct nf_nat_l4proto nf_n
  extern const struct nf_nat_l4proto nf_nat_l4proto_udplite;
  #endif
  
++<<<<<<< HEAD
 +bool nf_nat_l4proto_in_range(const struct nf_conntrack_tuple *tuple,
 +			     enum nf_nat_manip_type maniptype,
 +			     const union nf_conntrack_man_proto *min,
 +			     const union nf_conntrack_man_proto *max);
 +
 +void nf_nat_l4proto_unique_tuple(const struct nf_nat_l3proto *l3proto,
 +				 struct nf_conntrack_tuple *tuple,
 +				 const struct nf_nat_range2 *range,
 +				 enum nf_nat_manip_type maniptype,
 +				 const struct nf_conn *ct);
 +
 +int nf_nat_l4proto_nlattr_to_range(struct nlattr *tb[],
 +				   struct nf_nat_range2 *range);
 +
++=======
++>>>>>>> 76b90019e03d (netfilter: nat: remove l4proto->nlattr_to_range)
  #endif /*_NF_NAT_L4PROTO_H*/
diff --cc net/ipv4/netfilter/nf_nat_proto_gre.c
index 00fda6331ce5,86af36651edd..000000000000
--- a/net/ipv4/netfilter/nf_nat_proto_gre.c
+++ b/net/ipv4/netfilter/nf_nat_proto_gre.c
@@@ -123,11 -80,6 +123,14 @@@ gre_manip_pkt(struct sk_buff *skb
  static const struct nf_nat_l4proto gre = {
  	.l4proto		= IPPROTO_GRE,
  	.manip_pkt		= gre_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= nf_nat_l4proto_in_range,
 +	.unique_tuple		= gre_unique_tuple,
 +#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 +	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
 +#endif
++=======
++>>>>>>> 76b90019e03d (netfilter: nat: remove l4proto->nlattr_to_range)
  };
  
  static int __init nf_nat_proto_gre_init(void)
diff --cc net/ipv4/netfilter/nf_nat_proto_icmp.c
index 6d7cf1d79baf,4fecb3f2c55a..000000000000
--- a/net/ipv4/netfilter/nf_nat_proto_icmp.c
+++ b/net/ipv4/netfilter/nf_nat_proto_icmp.c
@@@ -75,9 -39,4 +75,12 @@@ icmp_manip_pkt(struct sk_buff *skb
  const struct nf_nat_l4proto nf_nat_l4proto_icmp = {
  	.l4proto		= IPPROTO_ICMP,
  	.manip_pkt		= icmp_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= icmp_in_range,
 +	.unique_tuple		= icmp_unique_tuple,
 +#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 +	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
 +#endif
++=======
++>>>>>>> 76b90019e03d (netfilter: nat: remove l4proto->nlattr_to_range)
  };
diff --cc net/ipv6/netfilter/nf_nat_proto_icmpv6.c
index d9bf42ba44fa,14717c226cec..000000000000
--- a/net/ipv6/netfilter/nf_nat_proto_icmpv6.c
+++ b/net/ipv6/netfilter/nf_nat_proto_icmpv6.c
@@@ -82,9 -47,4 +82,12 @@@ icmpv6_manip_pkt(struct sk_buff *skb
  const struct nf_nat_l4proto nf_nat_l4proto_icmpv6 = {
  	.l4proto		= IPPROTO_ICMPV6,
  	.manip_pkt		= icmpv6_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= icmpv6_in_range,
 +	.unique_tuple		= icmpv6_unique_tuple,
 +#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 +	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
 +#endif
++=======
++>>>>>>> 76b90019e03d (netfilter: nat: remove l4proto->nlattr_to_range)
  };
diff --cc net/netfilter/nf_nat_proto_dccp.c
index 7d4d2c124990,ab0b1384717d..000000000000
--- a/net/netfilter/nf_nat_proto_dccp.c
+++ b/net/netfilter/nf_nat_proto_dccp.c
@@@ -71,9 -61,4 +71,12 @@@ dccp_manip_pkt(struct sk_buff *skb
  const struct nf_nat_l4proto nf_nat_l4proto_dccp = {
  	.l4proto		= IPPROTO_DCCP,
  	.manip_pkt		= dccp_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= nf_nat_l4proto_in_range,
 +	.unique_tuple		= dccp_unique_tuple,
 +#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 +	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
 +#endif
++=======
++>>>>>>> 76b90019e03d (netfilter: nat: remove l4proto->nlattr_to_range)
  };
diff --cc net/netfilter/nf_nat_proto_sctp.c
index f05ad8fa7b20,37a9d347a029..000000000000
--- a/net/netfilter/nf_nat_proto_sctp.c
+++ b/net/netfilter/nf_nat_proto_sctp.c
@@@ -66,9 -56,4 +66,12 @@@ sctp_manip_pkt(struct sk_buff *skb
  const struct nf_nat_l4proto nf_nat_l4proto_sctp = {
  	.l4proto		= IPPROTO_SCTP,
  	.manip_pkt		= sctp_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= nf_nat_l4proto_in_range,
 +	.unique_tuple		= sctp_unique_tuple,
 +#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 +	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
 +#endif
++=======
++>>>>>>> 76b90019e03d (netfilter: nat: remove l4proto->nlattr_to_range)
  };
diff --cc net/netfilter/nf_nat_proto_tcp.c
index c312e6b3e2ea,d378b6c31d34..000000000000
--- a/net/netfilter/nf_nat_proto_tcp.c
+++ b/net/netfilter/nf_nat_proto_tcp.c
@@@ -74,9 -64,4 +74,12 @@@ tcp_manip_pkt(struct sk_buff *skb
  const struct nf_nat_l4proto nf_nat_l4proto_tcp = {
  	.l4proto		= IPPROTO_TCP,
  	.manip_pkt		= tcp_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= nf_nat_l4proto_in_range,
 +	.unique_tuple		= tcp_unique_tuple,
 +#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 +	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
 +#endif
++=======
++>>>>>>> 76b90019e03d (netfilter: nat: remove l4proto->nlattr_to_range)
  };
diff --cc net/netfilter/nf_nat_proto_udp.c
index 208c14316359,25fc6138fbf7..000000000000
--- a/net/netfilter/nf_nat_proto_udp.c
+++ b/net/netfilter/nf_nat_proto_udp.c
@@@ -105,20 -85,10 +105,26 @@@ udplite_unique_tuple(const struct nf_na
  const struct nf_nat_l4proto nf_nat_l4proto_udplite = {
  	.l4proto		= IPPROTO_UDPLITE,
  	.manip_pkt		= udplite_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= nf_nat_l4proto_in_range,
 +	.unique_tuple		= udplite_unique_tuple,
 +#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 +	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
 +#endif
++=======
++>>>>>>> 76b90019e03d (netfilter: nat: remove l4proto->nlattr_to_range)
  };
  #endif /* CONFIG_NF_NAT_PROTO_UDPLITE */
  
  const struct nf_nat_l4proto nf_nat_l4proto_udp = {
  	.l4proto		= IPPROTO_UDP,
  	.manip_pkt		= udp_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= nf_nat_l4proto_in_range,
 +	.unique_tuple		= udp_unique_tuple,
 +#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 +	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
 +#endif
++=======
++>>>>>>> 76b90019e03d (netfilter: nat: remove l4proto->nlattr_to_range)
  };
* Unmerged path net/netfilter/nf_nat_proto_common.c
* Unmerged path include/net/netfilter/nf_nat_l4proto.h
* Unmerged path net/ipv4/netfilter/nf_nat_proto_gre.c
* Unmerged path net/ipv4/netfilter/nf_nat_proto_icmp.c
* Unmerged path net/ipv6/netfilter/nf_nat_proto_icmpv6.c
diff --git a/net/netfilter/Makefile b/net/netfilter/Makefile
index c1b6a98afe92..0b99e5b58e31 100644
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -41,7 +41,7 @@ obj-$(CONFIG_NF_CONNTRACK_SANE) += nf_conntrack_sane.o
 obj-$(CONFIG_NF_CONNTRACK_SIP) += nf_conntrack_sip.o
 obj-$(CONFIG_NF_CONNTRACK_TFTP) += nf_conntrack_tftp.o
 
-nf_nat-y	:= nf_nat_core.o nf_nat_proto_unknown.o nf_nat_proto_common.o \
+nf_nat-y	:= nf_nat_core.o nf_nat_proto_unknown.o \
 		   nf_nat_proto_udp.o nf_nat_proto_tcp.o nf_nat_helper.o
 
 # NAT protocols (nf_nat)
diff --git a/net/netfilter/nf_nat_core.c b/net/netfilter/nf_nat_core.c
index 5e173f6800a4..b033083aec8c 100644
--- a/net/netfilter/nf_nat_core.c
+++ b/net/netfilter/nf_nat_core.c
@@ -810,12 +810,26 @@ static const struct nla_policy protonat_nla_policy[CTA_PROTONAT_MAX+1] = {
 	[CTA_PROTONAT_PORT_MAX]	= { .type = NLA_U16 },
 };
 
+static int nf_nat_l4proto_nlattr_to_range(struct nlattr *tb[],
+					  struct nf_nat_range2 *range)
+{
+	if (tb[CTA_PROTONAT_PORT_MIN]) {
+		range->min_proto.all = nla_get_be16(tb[CTA_PROTONAT_PORT_MIN]);
+		range->max_proto.all = range->min_proto.all;
+		range->flags |= NF_NAT_RANGE_PROTO_SPECIFIED;
+	}
+	if (tb[CTA_PROTONAT_PORT_MAX]) {
+		range->max_proto.all = nla_get_be16(tb[CTA_PROTONAT_PORT_MAX]);
+		range->flags |= NF_NAT_RANGE_PROTO_SPECIFIED;
+	}
+	return 0;
+}
+
 static int nfnetlink_parse_nat_proto(struct nlattr *attr,
 				     const struct nf_conn *ct,
 				     struct nf_nat_range2 *range)
 {
 	struct nlattr *tb[CTA_PROTONAT_MAX+1];
-	const struct nf_nat_l4proto *l4proto;
 	int err;
 
 	err = nla_parse_nested_deprecated(tb, CTA_PROTONAT_MAX, attr,
@@ -823,11 +837,7 @@ static int nfnetlink_parse_nat_proto(struct nlattr *attr,
 	if (err < 0)
 		return err;
 
-	l4proto = __nf_nat_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));
-	if (l4proto->nlattr_to_range)
-		err = l4proto->nlattr_to_range(tb, range);
-
-	return err;
+	return nf_nat_l4proto_nlattr_to_range(tb, range);
 }
 
 static const struct nla_policy nat_nla_policy[CTA_NAT_MAX+1] = {
* Unmerged path net/netfilter/nf_nat_proto_common.c
* Unmerged path net/netfilter/nf_nat_proto_dccp.c
* Unmerged path net/netfilter/nf_nat_proto_sctp.c
* Unmerged path net/netfilter/nf_nat_proto_tcp.c
* Unmerged path net/netfilter/nf_nat_proto_udp.c
