dm: do not use waitqueue for request-based DM

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 85067747cf9888249fa11fa49ef75af5192d3988
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/85067747.failed

Given request-based DM now uses blk-mq's blk_mq_queue_inflight() to
determine if outstanding IO has completed (and DM has no control over
the blk-mq state machine used to track outstanding IO) it is unsafe to
wakeup waiter (dm_wait_for_completion) before blk-mq has cleared a
request's state bits (e.g. MQ_RQ_IN_FLIGHT or MQ_RQ_COMPLETE).  As
such dm_wait_for_completion() could be left to wait indefinitely if no
other requests complete.

Fix this by eliminating request-based DM's use of waitqueue to wait
for blk-mq requests to complete in dm_wait_for_completion.

	Signed-off-by: Ming Lei <ming.lei@redhat.com>
Depends-on: 3c94d83cb3526 ("blk-mq: change blk_mq_queue_busy() to blk_mq_queue_inflight()")
	Cc: stable@vger.kernel.org
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 85067747cf9888249fa11fa49ef75af5192d3988)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm.c
diff --cc drivers/md/dm.c
index 8f84274dd6d8,446aff589732..000000000000
--- a/drivers/md/dm.c
+++ b/drivers/md/dm.c
@@@ -628,27 -654,14 +628,38 @@@ static void free_tio(struct dm_target_i
  	bio_put(&tio->clone);
  }
  
++<<<<<<< HEAD
 +static bool md_in_flight_bios(struct mapped_device *md)
 +{
 +	int cpu;
 +	struct hd_struct *part = &dm_disk(md)->part0;
 +	long sum = 0;
 +
 +	for_each_possible_cpu(cpu) {
 +		sum += part_stat_local_read_cpu(part, in_flight[0], cpu);
 +		sum += part_stat_local_read_cpu(part, in_flight[1], cpu);
 +	}
 +
 +	return sum != 0;
 +}
 +
 +static bool md_in_flight(struct mapped_device *md)
 +{
 +	if (queue_is_mq(md->queue))
 +		return blk_mq_queue_inflight(md->queue);
 +	else
 +		return md_in_flight_bios(md);
 +}
++=======
+ u64 dm_start_time_ns_from_clone(struct bio *bio)
+ {
+ 	struct dm_target_io *tio = container_of(bio, struct dm_target_io, clone);
+ 	struct dm_io *io = tio->io;
+ 
+ 	return jiffies_to_nsecs(io->start_time);
+ }
+ EXPORT_SYMBOL_GPL(dm_start_time_ns_from_clone);
++>>>>>>> 85067747cf98 (dm: do not use waitqueue for request-based DM)
  
  static void start_io_acct(struct dm_io *io)
  {
diff --git a/drivers/md/dm-rq.c b/drivers/md/dm-rq.c
index 3f8577e2c13b..9fb46a6301d8 100644
--- a/drivers/md/dm-rq.c
+++ b/drivers/md/dm-rq.c
@@ -146,10 +146,6 @@ static void rq_end_stats(struct mapped_device *md, struct request *orig)
  */
 static void rq_completed(struct mapped_device *md)
 {
-	/* nudge anyone waiting on suspend queue */
-	if (unlikely(wq_has_sleeper(&md->wait)))
-		wake_up(&md->wait);
-
 	/*
 	 * dm_put() must be at the end of this function. See the comment above
 	 */
* Unmerged path drivers/md/dm.c
