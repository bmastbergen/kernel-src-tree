x86/paravirt: Standardize 'insn_buff' variable names

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ingo Molnar <mingo@kernel.org>
commit 1fc654cf6e04b402ba9c4327b2919ea864037e7a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/1fc654cf.failed

We currently have 6 (!) separate naming variants to name temporary instruction
buffers that are used for code patching:

 - insnbuf
 - insnbuff
 - insn_buff
 - insn_buffer
 - ibuf
 - ibuffer

These are used as local variables, percpu fields and function parameters.

Standardize all the names to a single variant: 'insn_buff'.

	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Brian Gerst <brgerst@gmail.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: Denys Vlasenko <dvlasenk@redhat.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Juergen Gross <jgross@suse.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rik van Riel <riel@surriel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 1fc654cf6e04b402ba9c4327b2919ea864037e7a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/paravirt_types.h
#	arch/x86/kernel/alternative.c
#	arch/x86/kernel/paravirt.c
#	arch/x86/kernel/paravirt_patch.c
diff --cc arch/x86/include/asm/paravirt_types.h
index 84499d90941a,94b7281e7815..000000000000
--- a/arch/x86/include/asm/paravirt_types.h
+++ b/arch/x86/include/asm/paravirt_types.h
@@@ -87,7 -88,7 +87,11 @@@ struct pv_init_ops 
  	 * the number of bytes of code generated, as we nop pad the
  	 * rest in generic code.
  	 */
++<<<<<<< HEAD
 +	unsigned (*patch)(u8 type, u16 clobber, void *insnbuf,
++=======
+ 	unsigned (*patch)(u8 type, void *insn_buff,
++>>>>>>> 1fc654cf6e04 (x86/paravirt: Standardize 'insn_buff' variable names)
  			  unsigned long addr, unsigned len);
  } __no_randomize_layout;
  
@@@ -378,26 -370,11 +382,34 @@@ extern struct pv_lock_ops pv_lock_ops
  /* Simple instruction patching code. */
  #define NATIVE_LABEL(a,x,b) "\n\t.globl " a #x "_" #b "\n" a #x "_" #b ":\n\t"
  
++<<<<<<< HEAD
 +#define DEF_NATIVE(ops, name, code)					\
 +	__visible extern const char start_##ops##_##name[], end_##ops##_##name[];	\
 +	asm(NATIVE_LABEL("start_", ops, name) code NATIVE_LABEL("end_", ops, name))
 +
 +unsigned paravirt_patch_ident_32(void *insnbuf, unsigned len);
 +unsigned paravirt_patch_ident_64(void *insnbuf, unsigned len);
 +unsigned paravirt_patch_call(void *insnbuf,
 +			     const void *target, u16 tgt_clobbers,
 +			     unsigned long addr, u16 site_clobbers,
 +			     unsigned len);
 +unsigned paravirt_patch_jmp(void *insnbuf, const void *target,
 +			    unsigned long addr, unsigned len);
 +unsigned paravirt_patch_default(u8 type, u16 clobbers, void *insnbuf,
 +				unsigned long addr, unsigned len);
 +
 +unsigned paravirt_patch_insns(void *insnbuf, unsigned len,
 +			      const char *start, const char *end);
 +
 +unsigned native_patch(u8 type, u16 clobbers, void *ibuf,
 +		      unsigned long addr, unsigned len);
++=======
+ unsigned paravirt_patch_ident_64(void *insn_buff, unsigned len);
+ unsigned paravirt_patch_default(u8 type, void *insn_buff, unsigned long addr, unsigned len);
+ unsigned paravirt_patch_insns(void *insn_buff, unsigned len, const char *start, const char *end);
+ 
+ unsigned native_patch(u8 type, void *insn_buff, unsigned long addr, unsigned len);
++>>>>>>> 1fc654cf6e04 (x86/paravirt: Standardize 'insn_buff' variable names)
  
  int paravirt_disable_iospace(void);
  
diff --cc arch/x86/kernel/alternative.c
index f42ecc29b49a,92eafd1d3493..000000000000
--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@@ -595,8 -598,8 +595,13 @@@ void __init_or_module apply_paravirt(st
  
  		BUG_ON(p->len > MAX_PATCH_LEN);
  		/* prep the buffer with the original instructions */
++<<<<<<< HEAD
 +		memcpy(insnbuf, p->instr, p->len);
 +		used = pv_init_ops.patch(p->instrtype, p->clobbers, insnbuf,
++=======
+ 		memcpy(insn_buff, p->instr, p->len);
+ 		used = pv_ops.init.patch(p->instrtype, insn_buff,
++>>>>>>> 1fc654cf6e04 (x86/paravirt: Standardize 'insn_buff' variable names)
  					 (unsigned long)p->instr, p->len);
  
  		BUG_ON(used > p->len);
diff --cc arch/x86/kernel/paravirt.c
index 8dc69d82567e,b7d22912e20b..000000000000
--- a/arch/x86/kernel/paravirt.c
+++ b/arch/x86/kernel/paravirt.c
@@@ -81,32 -70,37 +81,53 @@@ struct branch 
  	u32 delta;
  } __attribute__((packed));
  
++<<<<<<< HEAD
 +unsigned paravirt_patch_call(void *insnbuf,
 +			     const void *target, u16 tgt_clobbers,
 +			     unsigned long addr, u16 site_clobbers,
 +			     unsigned len)
 +{
 +	struct branch *b = insnbuf;
 +	unsigned long delta = (unsigned long)target - (addr+5);
++=======
+ static unsigned paravirt_patch_call(void *insn_buff, const void *target,
+ 				    unsigned long addr, unsigned len)
+ {
+ 	const int call_len = 5;
+ 	struct branch *b = insn_buff;
+ 	unsigned long delta = (unsigned long)target - (addr+call_len);
++>>>>>>> 1fc654cf6e04 (x86/paravirt: Standardize 'insn_buff' variable names)
  
 -	if (len < call_len) {
 -		pr_warn("paravirt: Failed to patch indirect CALL at %ps\n", (void *)addr);
 -		/* Kernel might not be viable if patching fails, bail out: */
 -		BUG_ON(1);
 +	if (len < 5) {
 +#ifdef CONFIG_RETPOLINE
 +		WARN_ONCE(1, "Failing to patch indirect CALL in %ps\n", (void *)addr);
 +#endif
 +		return len;	/* call too long for patch site */
  	}
  
  	b->opcode = 0xe8; /* call */
  	b->delta = delta;
 -	BUILD_BUG_ON(sizeof(*b) != call_len);
 +	BUILD_BUG_ON(sizeof(*b) != 5);
  
 -	return call_len;
 +	return 5;
  }
  
++<<<<<<< HEAD
 +unsigned paravirt_patch_jmp(void *insnbuf, const void *target,
 +			    unsigned long addr, unsigned len)
++=======
+ #ifdef CONFIG_PARAVIRT_XXL
+ /* identity function, which can be inlined */
+ u64 notrace _paravirt_ident_64(u64 x)
  {
- 	struct branch *b = insnbuf;
+ 	return x;
+ }
+ 
+ static unsigned paravirt_patch_jmp(void *insn_buff, const void *target,
+ 				   unsigned long addr, unsigned len)
++>>>>>>> 1fc654cf6e04 (x86/paravirt: Standardize 'insn_buff' variable names)
+ {
+ 	struct branch *b = insn_buff;
  	unsigned long delta = (unsigned long)target - (addr+5);
  
  	if (len < 5) {
@@@ -130,29 -125,14 +151,33 @@@ void __init native_pv_lock_init(void
  		static_branch_disable(&virt_spin_lock_key);
  }
  
++<<<<<<< HEAD
 +/*
 + * Neat trick to map patch type back to the call within the
 + * corresponding structure.
 + */
 +static void *get_call_destination(u8 type)
 +{
 +	struct paravirt_patch_template tmpl = {
 +		.pv_init_ops = pv_init_ops,
 +		.pv_time_ops = pv_time_ops,
 +		.pv_cpu_ops = pv_cpu_ops,
 +		.pv_irq_ops = pv_irq_ops,
 +		.pv_mmu_ops = pv_mmu_ops,
 +#ifdef CONFIG_PARAVIRT_SPINLOCKS
 +		.pv_lock_ops = pv_lock_ops,
 +#endif
 +	};
 +	return *((void **)&tmpl + type);
 +}
 +
 +unsigned paravirt_patch_default(u8 type, u16 clobbers, void *insnbuf,
++=======
+ unsigned paravirt_patch_default(u8 type, void *insn_buff,
++>>>>>>> 1fc654cf6e04 (x86/paravirt: Standardize 'insn_buff' variable names)
  				unsigned long addr, unsigned len)
  {
 -	/*
 -	 * Neat trick to map patch type back to the call within the
 -	 * corresponding structure.
 -	 */
 -	void *opfunc = *((void **)&pv_ops + type);
 +	void *opfunc = get_call_destination(type);
  	unsigned ret;
  
  	if (opfunc == NULL)
@@@ -161,21 -141,19 +186,29 @@@
  	else if (opfunc == _paravirt_nop)
  		ret = 0;
  
 -#ifdef CONFIG_PARAVIRT_XXL
  	/* identity functions just return their single argument */
 +	else if (opfunc == _paravirt_ident_32)
 +		ret = paravirt_patch_ident_32(insnbuf, len);
  	else if (opfunc == _paravirt_ident_64)
- 		ret = paravirt_patch_ident_64(insnbuf, len);
+ 		ret = paravirt_patch_ident_64(insn_buff, len);
  
 -	else if (type == PARAVIRT_PATCH(cpu.iret) ||
 -		 type == PARAVIRT_PATCH(cpu.usergs_sysret64))
 +	else if (type == PARAVIRT_PATCH(pv_cpu_ops.iret) ||
 +		 type == PARAVIRT_PATCH(pv_cpu_ops.usergs_sysret64))
  		/* If operation requires a jmp, then jmp */
++<<<<<<< HEAD
 +		ret = paravirt_patch_jmp(insnbuf, opfunc, addr, len);
 +	else
 +		/* Otherwise call the function; assume target could
 +		   clobber any caller-save reg */
 +		ret = paravirt_patch_call(insnbuf, opfunc, CLBR_ANY,
 +					  addr, clobbers, len);
++=======
+ 		ret = paravirt_patch_jmp(insn_buff, opfunc, addr, len);
+ #endif
+ 	else
+ 		/* Otherwise call the function. */
+ 		ret = paravirt_patch_call(insn_buff, opfunc, addr, len);
++>>>>>>> 1fc654cf6e04 (x86/paravirt: Standardize 'insn_buff' variable names)
  
  	return ret;
  }
@@@ -185,10 -163,10 +218,17 @@@ unsigned paravirt_patch_insns(void *ins
  {
  	unsigned insn_len = end - start;
  
++<<<<<<< HEAD
 +	if (insn_len > len || start == NULL)
 +		insn_len = len;
 +	else
 +		memcpy(insnbuf, start, insn_len);
++=======
+ 	/* Alternative instruction is too large for the patch site and we cannot continue: */
+ 	BUG_ON(insn_len > len || start == NULL);
+ 
+ 	memcpy(insn_buff, start, insn_len);
++>>>>>>> 1fc654cf6e04 (x86/paravirt: Standardize 'insn_buff' variable names)
  
  	return insn_len;
  }
* Unmerged path arch/x86/kernel/paravirt_patch.c
diff --git a/arch/x86/events/intel/ds.c b/arch/x86/events/intel/ds.c
index af365eeb0dd4..dc43cc124e09 100644
--- a/arch/x86/events/intel/ds.c
+++ b/arch/x86/events/intel/ds.c
@@ -338,7 +338,7 @@ static int alloc_pebs_buffer(int cpu)
 	struct debug_store *ds = hwev->ds;
 	size_t bsiz = x86_pmu.pebs_buffer_size;
 	int max, node = cpu_to_node(cpu);
-	void *buffer, *ibuffer, *cea;
+	void *buffer, *insn_buff, *cea;
 
 	if (!x86_pmu.pebs)
 		return 0;
@@ -352,12 +352,12 @@ static int alloc_pebs_buffer(int cpu)
 	 * buffer then.
 	 */
 	if (x86_pmu.intel_cap.pebs_format < 2) {
-		ibuffer = kzalloc_node(PEBS_FIXUP_SIZE, GFP_KERNEL, node);
-		if (!ibuffer) {
+		insn_buff = kzalloc_node(PEBS_FIXUP_SIZE, GFP_KERNEL, node);
+		if (!insn_buff) {
 			dsfree_pages(buffer, bsiz);
 			return -ENOMEM;
 		}
-		per_cpu(insn_buffer, cpu) = ibuffer;
+		per_cpu(insn_buffer, cpu) = insn_buff;
 	}
 	hwev->ds_pebs_vaddr = buffer;
 	/* Update the cpu entry area mapping */
* Unmerged path arch/x86/include/asm/paravirt_types.h
* Unmerged path arch/x86/kernel/alternative.c
diff --git a/arch/x86/kernel/kprobes/opt.c b/arch/x86/kernel/kprobes/opt.c
index 203d398802a3..25f78d107d43 100644
--- a/arch/x86/kernel/kprobes/opt.c
+++ b/arch/x86/kernel/kprobes/opt.c
@@ -431,7 +431,7 @@ int arch_prepare_optimized_kprobe(struct optimized_kprobe *op,
 void arch_optimize_kprobes(struct list_head *oplist)
 {
 	struct optimized_kprobe *op, *tmp;
-	u8 insn_buf[RELATIVEJUMP_SIZE];
+	u8 insn_buff[RELATIVEJUMP_SIZE];
 
 	list_for_each_entry_safe(op, tmp, oplist, list) {
 		s32 rel = (s32)((long)op->optinsn.insn -
@@ -443,10 +443,10 @@ void arch_optimize_kprobes(struct list_head *oplist)
 		memcpy(op->optinsn.copied_insn, op->kp.addr + INT3_SIZE,
 		       RELATIVE_ADDR_SIZE);
 
-		insn_buf[0] = RELATIVEJUMP_OPCODE;
-		*(s32 *)(&insn_buf[1]) = rel;
+		insn_buff[0] = RELATIVEJUMP_OPCODE;
+		*(s32 *)(&insn_buff[1]) = rel;
 
-		text_poke_bp(op->kp.addr, insn_buf, RELATIVEJUMP_SIZE,
+		text_poke_bp(op->kp.addr, insn_buff, RELATIVEJUMP_SIZE,
 			     op->optinsn.insn);
 
 		list_del_init(&op->list);
@@ -456,12 +456,12 @@ void arch_optimize_kprobes(struct list_head *oplist)
 /* Replace a relative jump with a breakpoint (int3).  */
 void arch_unoptimize_kprobe(struct optimized_kprobe *op)
 {
-	u8 insn_buf[RELATIVEJUMP_SIZE];
+	u8 insn_buff[RELATIVEJUMP_SIZE];
 
 	/* Set int3 to first byte for kprobes */
-	insn_buf[0] = BREAKPOINT_INSTRUCTION;
-	memcpy(insn_buf + 1, op->optinsn.copied_insn, RELATIVE_ADDR_SIZE);
-	text_poke_bp(op->kp.addr, insn_buf, RELATIVEJUMP_SIZE,
+	insn_buff[0] = BREAKPOINT_INSTRUCTION;
+	memcpy(insn_buff + 1, op->optinsn.copied_insn, RELATIVE_ADDR_SIZE);
+	text_poke_bp(op->kp.addr, insn_buff, RELATIVEJUMP_SIZE,
 		     op->optinsn.insn);
 }
 
* Unmerged path arch/x86/kernel/paravirt.c
* Unmerged path arch/x86/kernel/paravirt_patch.c
diff --git a/arch/x86/tools/insn_decoder_test.c b/arch/x86/tools/insn_decoder_test.c
index a3b4fd954931..34c2b3691f4f 100644
--- a/arch/x86/tools/insn_decoder_test.c
+++ b/arch/x86/tools/insn_decoder_test.c
@@ -119,7 +119,7 @@ static void parse_args(int argc, char **argv)
 int main(int argc, char **argv)
 {
 	char line[BUFSIZE], sym[BUFSIZE] = "<unknown>";
-	unsigned char insn_buf[16];
+	unsigned char insn_buff[16];
 	struct insn insn;
 	int insns = 0;
 	int warnings = 0;
@@ -138,7 +138,7 @@ int main(int argc, char **argv)
 		}
 
 		insns++;
-		memset(insn_buf, 0, 16);
+		memset(insn_buff, 0, 16);
 		strcpy(copy, line);
 		tab1 = strchr(copy, '\t');
 		if (!tab1)
@@ -151,13 +151,13 @@ int main(int argc, char **argv)
 		*tab2 = '\0';	/* Characters beyond tab2 aren't examined */
 		while (s < tab2) {
 			if (sscanf(s, "%x", &b) == 1) {
-				insn_buf[nb++] = (unsigned char) b;
+				insn_buff[nb++] = (unsigned char) b;
 				s += 3;
 			} else
 				break;
 		}
 		/* Decode an instruction */
-		insn_init(&insn, insn_buf, sizeof(insn_buf), x86_64);
+		insn_init(&insn, insn_buff, sizeof(insn_buff), x86_64);
 		insn_get_length(&insn);
 		if (insn.length != nb) {
 			warnings++;
diff --git a/arch/x86/tools/insn_sanity.c b/arch/x86/tools/insn_sanity.c
index 1972565ab106..7adec7b490fd 100644
--- a/arch/x86/tools/insn_sanity.c
+++ b/arch/x86/tools/insn_sanity.c
@@ -96,7 +96,7 @@ static void dump_insn(FILE *fp, struct insn *insn)
 }
 
 static void dump_stream(FILE *fp, const char *msg, unsigned long nr_iter,
-			unsigned char *insn_buf, struct insn *insn)
+			unsigned char *insn_buff, struct insn *insn)
 {
 	int i;
 
@@ -109,7 +109,7 @@ static void dump_stream(FILE *fp, const char *msg, unsigned long nr_iter,
 	/* Input a decoded instruction sequence directly */
 	fprintf(fp, " $ echo ");
 	for (i = 0; i < MAX_INSN_SIZE; i++)
-		fprintf(fp, " %02x", insn_buf[i]);
+		fprintf(fp, " %02x", insn_buff[i]);
 	fprintf(fp, " | %s -i -\n", prog);
 
 	if (!input_file) {
@@ -137,7 +137,7 @@ static void init_random_seed(void)
 }
 
 /* Read given instruction sequence from the input file */
-static int read_next_insn(unsigned char *insn_buf)
+static int read_next_insn(unsigned char *insn_buff)
 {
 	char buf[256]  = "", *tmp;
 	int i;
@@ -147,7 +147,7 @@ static int read_next_insn(unsigned char *insn_buf)
 		return 0;
 
 	for (i = 0; i < MAX_INSN_SIZE; i++) {
-		insn_buf[i] = (unsigned char)strtoul(tmp, &tmp, 16);
+		insn_buff[i] = (unsigned char)strtoul(tmp, &tmp, 16);
 		if (*tmp != ' ')
 			break;
 	}
@@ -155,19 +155,19 @@ static int read_next_insn(unsigned char *insn_buf)
 	return i;
 }
 
-static int generate_insn(unsigned char *insn_buf)
+static int generate_insn(unsigned char *insn_buff)
 {
 	int i;
 
 	if (input_file)
-		return read_next_insn(insn_buf);
+		return read_next_insn(insn_buff);
 
 	/* Fills buffer with random binary up to MAX_INSN_SIZE */
 	for (i = 0; i < MAX_INSN_SIZE - 1; i += 2)
-		*(unsigned short *)(&insn_buf[i]) = random() & 0xffff;
+		*(unsigned short *)(&insn_buff[i]) = random() & 0xffff;
 
 	while (i < MAX_INSN_SIZE)
-		insn_buf[i++] = random() & 0xff;
+		insn_buff[i++] = random() & 0xff;
 
 	return i;
 }
@@ -239,31 +239,31 @@ int main(int argc, char **argv)
 	int insns = 0;
 	int errors = 0;
 	unsigned long i;
-	unsigned char insn_buf[MAX_INSN_SIZE * 2];
+	unsigned char insn_buff[MAX_INSN_SIZE * 2];
 
 	parse_args(argc, argv);
 
 	/* Prepare stop bytes with NOPs */
-	memset(insn_buf + MAX_INSN_SIZE, INSN_NOP, MAX_INSN_SIZE);
+	memset(insn_buff + MAX_INSN_SIZE, INSN_NOP, MAX_INSN_SIZE);
 
 	for (i = 0; i < iter_end; i++) {
-		if (generate_insn(insn_buf) <= 0)
+		if (generate_insn(insn_buff) <= 0)
 			break;
 
 		if (i < iter_start)	/* Skip to given iteration number */
 			continue;
 
 		/* Decode an instruction */
-		insn_init(&insn, insn_buf, sizeof(insn_buf), x86_64);
+		insn_init(&insn, insn_buff, sizeof(insn_buff), x86_64);
 		insn_get_length(&insn);
 
 		if (insn.next_byte <= insn.kaddr ||
 		    insn.kaddr + MAX_INSN_SIZE < insn.next_byte) {
 			/* Access out-of-range memory */
-			dump_stream(stderr, "Error: Found an access violation", i, insn_buf, &insn);
+			dump_stream(stderr, "Error: Found an access violation", i, insn_buff, &insn);
 			errors++;
 		} else if (verbose && !insn_complete(&insn))
-			dump_stream(stdout, "Info: Found an undecodable input", i, insn_buf, &insn);
+			dump_stream(stdout, "Info: Found an undecodable input", i, insn_buff, &insn);
 		else if (verbose >= 2)
 			dump_insn(stdout, &insn);
 		insns++;
