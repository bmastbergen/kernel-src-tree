net: sockmap: use bitmap for copy info

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] sockmap: use bitmap for copy info (Sabrina Dubroca) [1819627]
Rebuild_FUZZ: 92.96%
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 163ab96b52ae2bb2d8f188cd29f0b570610f9007
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/163ab96b.failed

Don't use bool array in struct sk_msg_sg, save 12 bytes.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Dirk van der Merwe <dirk.vandermerwe@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 163ab96b52ae2bb2d8f188cd29f0b570610f9007)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skmsg.h
diff --cc include/linux/skmsg.h
index cc87f7d35b23,fe80d537945d..000000000000
--- a/include/linux/skmsg.h
+++ b/include/linux/skmsg.h
@@@ -29,16 -28,14 +29,27 @@@ struct sk_msg_sg 
  	u32				end;
  	u32				size;
  	u32				copybreak;
++<<<<<<< HEAD
 +	bool				copy[MAX_MSG_FRAGS];
 +	/* The extra two elements:
 +	 * 1) used for chaining the front and sections when the list becomes
 +	 *    partitioned (e.g. end < start). The crypto APIs require the
 +	 *    chaining;
 +	 * 2) to chain tailer SG entries after the message.
++=======
+ 	unsigned long			copy;
+ 	/* The extra element is used for chaining the front and sections when
+ 	 * the list becomes partitioned (e.g. end < start). The crypto APIs
+ 	 * require the chaining.
++>>>>>>> 163ab96b52ae (net: sockmap: use bitmap for copy info)
  	 */
 -	struct scatterlist		data[MAX_MSG_FRAGS + 1];
 +	struct scatterlist		data[MAX_MSG_FRAGS + 2];
  };
++<<<<<<< HEAD
 +static_assert(BITS_PER_LONG >= NR_MSG_FRAG_IDS);
++=======
+ static_assert(BITS_PER_LONG >= MAX_MSG_FRAGS);
++>>>>>>> 163ab96b52ae (net: sockmap: use bitmap for copy info)
  
  /* UAPI in filter.c depends on struct sk_msg_sg being first element. */
  struct sk_msg {
* Unmerged path include/linux/skmsg.h
diff --git a/net/core/filter.c b/net/core/filter.c
index fe1308a67154..eff87869ec35 100644
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@ -2258,7 +2258,7 @@ BPF_CALL_4(bpf_msg_pull_data, struct sk_msg *, msg, u32, start,
 	 * account for the headroom.
 	 */
 	bytes_sg_total = start - offset + bytes;
-	if (!msg->sg.copy[i] && bytes_sg_total <= len)
+	if (!test_bit(i, &msg->sg.copy) && bytes_sg_total <= len)
 		goto out;
 
 	/* At this point we need to linearize multiple scatterlist
@@ -2464,7 +2464,7 @@ BPF_CALL_4(bpf_msg_push_data, struct sk_msg *, msg, u32, start,
 	/* Place newly allocated data buffer */
 	sk_mem_charge(msg->sk, len);
 	msg->sg.size += len;
-	msg->sg.copy[new] = false;
+	__clear_bit(new, &msg->sg.copy);
 	sg_set_page(&msg->sg.data[new], page, len + copy, 0);
 	if (rsge.length) {
 		get_page(sg_page(&rsge));
