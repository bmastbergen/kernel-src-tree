ftrace: Add ftrace_find_direct_func()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Steven Rostedt (VMware) <rostedt@goodmis.org>
commit 013bf0da0474816f57739daa006c8564ad7396a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/013bf0da.failed

As function_graph tracer modifies the return address to insert a trampoline
to trace the return of a function, it must be aware of a direct caller, as
when it gets called, the function's return address may not be at on the
stack where it expects. It may have to see if that return address points to
the a direct caller and adjust if it is.

	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit 013bf0da0474816f57739daa006c8564ad7396a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/ftrace.h
#	kernel/trace/ftrace.c
diff --cc include/linux/ftrace.h
index a0bdf45611c0,8b37b8105398..000000000000
--- a/include/linux/ftrace.h
+++ b/include/linux/ftrace.h
@@@ -243,6 -246,37 +244,40 @@@ static inline void ftrace_free_init_mem
  static inline void ftrace_free_mem(struct module *mod, void *start, void *end) { }
  #endif /* CONFIG_FUNCTION_TRACER */
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS
+ int register_ftrace_direct(unsigned long ip, unsigned long addr);
+ int unregister_ftrace_direct(unsigned long ip, unsigned long addr);
+ struct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr);
+ #else
+ static inline int register_ftrace_direct(unsigned long ip, unsigned long addr)
+ {
+ 	return -ENODEV;
+ }
+ static inline int unregister_ftrace_direct(unsigned long ip, unsigned long addr)
+ {
+ 	return -ENODEV;
+ }
+ static inline struct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr)
+ {
+ 	return NULL;
+ }
+ #endif /* CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS */
+ 
+ #ifndef CONFIG_HAVE_DYNAMIC_FTRACE_WITH_DIRECT_CALLS
+ /*
+  * This must be implemented by the architecture.
+  * It is the way the ftrace direct_ops helper, when called
+  * via ftrace (because there's other callbacks besides the
+  * direct call), can inform the architecture's trampoline that this
+  * routine has a direct caller, and what the caller is.
+  */
+ static inline void arch_ftrace_set_direct_caller(struct pt_regs *regs,
+ 						 unsigned long addr) { }
+ #endif /* CONFIG_HAVE_DYNAMIC_FTRACE_WITH_DIRECT_CALLS */
+ 
++>>>>>>> 013bf0da0474 (ftrace: Add ftrace_find_direct_func())
  #ifdef CONFIG_STACK_TRACER
  
  extern int stack_tracer_enabled;
diff --cc kernel/trace/ftrace.c
index ff6afd5bbf77,c4446eabacbe..000000000000
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@@ -4797,9 -4934,223 +4797,226 @@@ static in
  ftrace_set_addr(struct ftrace_ops *ops, unsigned long ip, int remove,
  		int reset, int enable)
  {
 -	return ftrace_set_hash(ops, NULL, 0, ip, remove, reset, enable);
 +	return ftrace_set_hash(ops, 0, 0, ip, remove, reset, enable);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS
+ 
+ struct ftrace_direct_func {
+ 	struct list_head	next;
+ 	unsigned long		addr;
+ 	int			count;
+ };
+ 
+ static LIST_HEAD(ftrace_direct_funcs);
+ 
+ /**
+  * ftrace_find_direct_func - test an address if it is a registered direct caller
+  * @addr: The address of a registered direct caller
+  *
+  * This searches to see if a ftrace direct caller has been registered
+  * at a specific address, and if so, it returns a descriptor for it.
+  *
+  * This can be used by architecture code to see if an address is
+  * a direct caller (trampoline) attached to a fentry/mcount location.
+  * This is useful for the function_graph tracer, as it may need to
+  * do adjustments if it traced a location that also has a direct
+  * trampoline attached to it.
+  */
+ struct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr)
+ {
+ 	struct ftrace_direct_func *entry;
+ 	bool found = false;
+ 
+ 	/* May be called by fgraph trampoline (protected by rcu tasks) */
+ 	list_for_each_entry_rcu(entry, &ftrace_direct_funcs, next) {
+ 		if (entry->addr == addr) {
+ 			found = true;
+ 			break;
+ 		}
+ 	}
+ 	if (found)
+ 		return entry;
+ 
+ 	return NULL;
+ }
+ 
+ /**
+  * register_ftrace_direct - Call a custom trampoline directly
+  * @ip: The address of the nop at the beginning of a function
+  * @addr: The address of the trampoline to call at @ip
+  *
+  * This is used to connect a direct call from the nop location (@ip)
+  * at the start of ftrace traced functions. The location that it calls
+  * (@addr) must be able to handle a direct call, and save the parameters
+  * of the function being traced, and restore them (or inject new ones
+  * if needed), before returning.
+  *
+  * Returns:
+  *  0 on success
+  *  -EBUSY - Another direct function is already attached (there can be only one)
+  *  -ENODEV - @ip does not point to a ftrace nop location (or not supported)
+  *  -ENOMEM - There was an allocation failure.
+  */
+ int register_ftrace_direct(unsigned long ip, unsigned long addr)
+ {
+ 	struct ftrace_direct_func *direct;
+ 	struct ftrace_func_entry *entry;
+ 	struct ftrace_hash *free_hash = NULL;
+ 	struct dyn_ftrace *rec;
+ 	int ret = -EBUSY;
+ 
+ 	mutex_lock(&direct_mutex);
+ 
+ 	/* See if there's a direct function at @ip already */
+ 	if (find_rec_direct(ip))
+ 		goto out_unlock;
+ 
+ 	ret = -ENODEV;
+ 	rec = lookup_rec(ip, ip);
+ 	if (!rec)
+ 		goto out_unlock;
+ 
+ 	/*
+ 	 * Check if the rec says it has a direct call but we didn't
+ 	 * find one earlier?
+ 	 */
+ 	if (WARN_ON(rec->flags & FTRACE_FL_DIRECT))
+ 		goto out_unlock;
+ 
+ 	/* Make sure the ip points to the exact record */
+ 	ip = rec->ip;
+ 
+ 	ret = -ENOMEM;
+ 	if (ftrace_hash_empty(direct_functions) ||
+ 	    direct_functions->count > 2 * (1 << direct_functions->size_bits)) {
+ 		struct ftrace_hash *new_hash;
+ 		int size = ftrace_hash_empty(direct_functions) ? 0 :
+ 			direct_functions->count + 1;
+ 
+ 		if (size < 32)
+ 			size = 32;
+ 
+ 		new_hash = dup_hash(direct_functions, size);
+ 		if (!new_hash)
+ 			goto out_unlock;
+ 
+ 		free_hash = direct_functions;
+ 		direct_functions = new_hash;
+ 	}
+ 
+ 	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
+ 	if (!entry)
+ 		goto out_unlock;
+ 
+ 	direct = ftrace_find_direct_func(addr);
+ 	if (!direct) {
+ 		direct = kmalloc(sizeof(*direct), GFP_KERNEL);
+ 		if (!direct) {
+ 			kfree(entry);
+ 			goto out_unlock;
+ 		}
+ 		direct->addr = addr;
+ 		direct->count = 0;
+ 		list_add_rcu(&direct->next, &ftrace_direct_funcs);
+ 	}
+ 
+ 	entry->ip = ip;
+ 	entry->direct = addr;
+ 	__add_hash_entry(direct_functions, entry);
+ 
+ 	ret = ftrace_set_filter_ip(&direct_ops, ip, 0, 0);
+ 	if (ret)
+ 		remove_hash_entry(direct_functions, entry);
+ 
+ 	if (!ret && !(direct_ops.flags & FTRACE_OPS_FL_ENABLED)) {
+ 		ret = register_ftrace_function(&direct_ops);
+ 		if (ret)
+ 			ftrace_set_filter_ip(&direct_ops, ip, 1, 0);
+ 	}
+ 
+ 	if (ret) {
+ 		kfree(entry);
+ 		if (!direct->count) {
+ 			list_del_rcu(&direct->next);
+ 			synchronize_rcu_tasks();
+ 			kfree(direct);
+ 			if (free_hash)
+ 				free_ftrace_hash(free_hash);
+ 			free_hash = NULL;
+ 		}
+ 	} else {
+ 		if (!direct->count)
+ 			direct->count++;
+ 	}
+  out_unlock:
+ 	mutex_unlock(&direct_mutex);
+ 
+ 	if (free_hash) {
+ 		synchronize_rcu_tasks();
+ 		free_ftrace_hash(free_hash);
+ 	}
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(register_ftrace_direct);
+ 
+ int unregister_ftrace_direct(unsigned long ip, unsigned long addr)
+ {
+ 	struct ftrace_func_entry *entry;
+ 	struct ftrace_direct_func *direct;
+ 	struct dyn_ftrace *rec;
+ 	int ret = -ENODEV;
+ 
+ 	mutex_lock(&direct_mutex);
+ 
+ 	entry = __ftrace_lookup_ip(direct_functions, ip);
+ 	if (!entry) {
+ 		/* OK if it is off by a little */
+ 		rec = lookup_rec(ip, ip);
+ 		if (!rec || rec->ip == ip)
+ 			goto out_unlock;
+ 
+ 		entry = __ftrace_lookup_ip(direct_functions, rec->ip);
+ 		if (!entry) {
+ 			WARN_ON(rec->flags & FTRACE_FL_DIRECT);
+ 			goto out_unlock;
+ 		}
+ 
+ 		WARN_ON(!(rec->flags & FTRACE_FL_DIRECT));
+ 	}
+ 
+ 	if (direct_functions->count == 1)
+ 		unregister_ftrace_function(&direct_ops);
+ 
+ 	ret = ftrace_set_filter_ip(&direct_ops, ip, 1, 0);
+ 
+ 	WARN_ON(ret);
+ 
+ 	remove_hash_entry(direct_functions, entry);
+ 
+ 	direct = ftrace_find_direct_func(addr);
+ 	if (!WARN_ON(!direct)) {
+ 		/* This is the good path (see the ! before WARN) */
+ 		direct->count--;
+ 		WARN_ON(direct->count < 0);
+ 		if (!direct->count) {
+ 			list_del_rcu(&direct->next);
+ 			synchronize_rcu_tasks();
+ 			kfree(direct);
+ 		}
+ 	}
+  out_unlock:
+ 	mutex_unlock(&direct_mutex);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(unregister_ftrace_direct);
+ #endif /* CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS */
+ 
++>>>>>>> 013bf0da0474 (ftrace: Add ftrace_find_direct_func())
  /**
   * ftrace_set_filter_ip - set a function to filter on in ftrace by address
   * @ops - the ops to set the filter with
* Unmerged path include/linux/ftrace.h
* Unmerged path kernel/trace/ftrace.c
