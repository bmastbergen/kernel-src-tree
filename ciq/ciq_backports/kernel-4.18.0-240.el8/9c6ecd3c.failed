ipv6: Only Replay routes of interest to new listeners

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ido Schimmel <idosch@mellanox.com>
commit 9c6ecd3cf62d0eb57539f966d7ad617ad3a59f4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9c6ecd3c.failed

When a new listener is registered to the FIB notification chain it
receives a dump of all the available routes in the system. Instead, make
sure to only replay the IPv6 routes that are actually used in the data
path and are of any interest to the new listener.

This is done by iterating over all the routing tables in the given
namespace, but from each traversed node only the first route ('leaf') is
notified. Multipath routes are notified in a single notification instead
of one for each nexthop.

Add fib6_rt_dump_tmp() to do that. Later on in the patch set it will be
renamed to fib6_rt_dump() instead of the existing one.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Reviewed-by: Jiri Pirko <jiri@mellanox.com>
	Reviewed-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9c6ecd3cf62d0eb57539f966d7ad617ad3a59f4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_fib.c
diff --cc net/ipv6/ip6_fib.c
index 246c67f714a3,51cf848e38f0..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -398,13 -366,29 +398,35 @@@ static int call_fib6_entry_notifier(str
  		.rt = rt,
  	};
  
 -	return call_fib6_notifier(nb, event_type, &info.info);
 +	return call_fib6_notifier(nb, net, event_type, &info.info);
  }
  
++<<<<<<< HEAD
 +static int call_fib6_entry_notifiers(struct net *net,
 +				     enum fib_event_type event_type,
 +				     struct fib6_info *rt,
 +				     struct netlink_ext_ack *extack)
++=======
+ static int call_fib6_multipath_entry_notifier(struct notifier_block *nb,
+ 					      enum fib_event_type event_type,
+ 					      struct fib6_info *rt,
+ 					      unsigned int nsiblings,
+ 					      struct netlink_ext_ack *extack)
+ {
+ 	struct fib6_entry_notifier_info info = {
+ 		.info.extack = extack,
+ 		.rt = rt,
+ 		.nsiblings = nsiblings,
+ 	};
+ 
+ 	return call_fib6_notifier(nb, event_type, &info.info);
+ }
+ 
+ int call_fib6_entry_notifiers(struct net *net,
+ 			      enum fib_event_type event_type,
+ 			      struct fib6_info *rt,
+ 			      struct netlink_ext_ack *extack)
++>>>>>>> 9c6ecd3cf62d (ipv6: Only Replay routes of interest to new listeners)
  {
  	struct fib6_entry_notifier_info info = {
  		.info.extack = extack,
@@@ -418,32 -402,82 +440,65 @@@
  struct fib6_dump_arg {
  	struct net *net;
  	struct notifier_block *nb;
 -	struct netlink_ext_ack *extack;
  };
  
 -static int fib6_rt_dump(struct fib6_info *rt, struct fib6_dump_arg *arg)
 +static void fib6_rt_dump(struct fib6_info *rt, struct fib6_dump_arg *arg)
  {
  	if (rt == arg->net->ipv6.fib6_null_entry)
 -		return 0;
 -	return call_fib6_entry_notifier(arg->nb, FIB_EVENT_ENTRY_ADD,
 -					rt, arg->extack);
 +		return;
 +	call_fib6_entry_notifier(arg->nb, arg->net, FIB_EVENT_ENTRY_ADD, rt);
  }
  
+ static int fib6_rt_dump_tmp(struct fib6_info *rt, struct fib6_dump_arg *arg)
+ {
+ 	enum fib_event_type fib_event = FIB_EVENT_ENTRY_REPLACE_TMP;
+ 	int err;
+ 
+ 	if (!rt || rt == arg->net->ipv6.fib6_null_entry)
+ 		return 0;
+ 
+ 	if (rt->fib6_nsiblings)
+ 		err = call_fib6_multipath_entry_notifier(arg->nb, fib_event,
+ 							 rt,
+ 							 rt->fib6_nsiblings,
+ 							 arg->extack);
+ 	else
+ 		err = call_fib6_entry_notifier(arg->nb, fib_event, rt,
+ 					       arg->extack);
+ 
+ 	return err;
+ }
+ 
  static int fib6_node_dump(struct fib6_walker *w)
  {
  	struct fib6_info *rt;
 -	int err = 0;
  
++<<<<<<< HEAD
 +	for_each_fib6_walker_rt(w)
 +		fib6_rt_dump(rt, w->args);
++=======
+ 	err = fib6_rt_dump_tmp(w->leaf, w->args);
+ 	if (err)
+ 		goto out;
+ 
+ 	for_each_fib6_walker_rt(w) {
+ 		err = fib6_rt_dump(rt, w->args);
+ 		if (err)
+ 			break;
+ 	}
+ out:
++>>>>>>> 9c6ecd3cf62d (ipv6: Only Replay routes of interest to new listeners)
  	w->leaf = NULL;
 -	return err;
 +	return 0;
  }
  
 -static int fib6_table_dump(struct net *net, struct fib6_table *tb,
 -			   struct fib6_walker *w)
 +static void fib6_table_dump(struct net *net, struct fib6_table *tb,
 +			    struct fib6_walker *w)
  {
 -	int err;
 -
  	w->root = &tb->tb6_root;
  	spin_lock_bh(&tb->tb6_lock);
 -	err = fib6_walk(net, w);
 +	fib6_walk(net, w);
  	spin_unlock_bh(&tb->tb6_lock);
 -	return err;
  }
  
  /* Called with rcu_read_lock() */
* Unmerged path net/ipv6/ip6_fib.c
