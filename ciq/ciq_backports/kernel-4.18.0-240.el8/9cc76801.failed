nfsd: make 'boot_time' 64-bit wide

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Arnd Bergmann <arnd@arndb.de>
commit 9cc7680149b238223bbb8bcf3272f6bd47f1fbfb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9cc76801.failed

The local boot time variable gets truncated to time_t at the moment,
which can lead to slightly odd behavior on 32-bit architectures.

Use ktime_get_real_seconds() instead of get_seconds() to always
get a 64-bit result, and keep it that way wherever possible.

It still gets truncated in a few places:

- When assigning to cl_clientid.cl_boot, this is already documented
  and is only used as a unique identifier.

- In clients_still_reclaiming(), the truncation is to 'unsigned long'
  in order to use the 'time_before() helper.

	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 9cc7680149b238223bbb8bcf3272f6bd47f1fbfb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/nfs4state.c
diff --cc fs/nfsd/nfs4state.c
index 5c01ce0ab7ca,a178374bacd5..000000000000
--- a/fs/nfsd/nfs4state.c
+++ b/fs/nfsd/nfs4state.c
@@@ -734,9 -748,14 +734,16 @@@ int nfs4_init_cp_state(struct nfsd_net 
  {
  	int new_id;
  
++<<<<<<< HEAD
++=======
+ 	stid->stid.si_opaque.so_clid.cl_boot = (u32)nn->boot_time;
+ 	stid->stid.si_opaque.so_clid.cl_id = nn->s2s_cp_cl_id;
+ 	stid->sc_type = sc_type;
+ 
++>>>>>>> 9cc7680149b2 (nfsd: make 'boot_time' 64-bit wide)
  	idr_preload(GFP_KERNEL);
  	spin_lock(&nn->s2s_cp_lock);
 -	new_id = idr_alloc_cyclic(&nn->s2s_cp_stateids, stid, 0, 0, GFP_NOWAIT);
 -	stid->stid.si_opaque.so_id = new_id;
 +	new_id = idr_alloc_cyclic(&nn->s2s_cp_stateids, copy, 0, 0, GFP_NOWAIT);
  	spin_unlock(&nn->s2s_cp_lock);
  	idr_preload_end();
  	if (new_id < 0)
diff --git a/fs/nfsd/netns.h b/fs/nfsd/netns.h
index d647fa17a5fd..bed7252bd716 100644
--- a/fs/nfsd/netns.h
+++ b/fs/nfsd/netns.h
@@ -53,7 +53,7 @@ struct nfsd_net {
 
 	struct lock_manager nfsd4_manager;
 	bool grace_ended;
-	time_t boot_time;
+	time64_t boot_time;
 
 	/* internal mount of the "nfsd" pseudofilesystem: */
 	struct vfsmount *nfsd_mnt;
diff --git a/fs/nfsd/nfs4recover.c b/fs/nfsd/nfs4recover.c
index 3e80f9f6ea99..efcf2ae73303 100644
--- a/fs/nfsd/nfs4recover.c
+++ b/fs/nfsd/nfs4recover.c
@@ -1446,7 +1446,7 @@ nfsd4_cld_grace_done_v0(struct nfsd_net *nn)
 	}
 
 	cup->cu_u.cu_msg.cm_cmd = Cld_GraceDone;
-	cup->cu_u.cu_msg.cm_u.cm_gracetime = (int64_t)nn->boot_time;
+	cup->cu_u.cu_msg.cm_u.cm_gracetime = nn->boot_time;
 	ret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_u.cu_msg);
 	if (!ret)
 		ret = cup->cu_u.cu_msg.cm_status;
@@ -1783,7 +1783,7 @@ nfsd4_cltrack_client_has_session(struct nfs4_client *clp)
 }
 
 static char *
-nfsd4_cltrack_grace_start(time_t grace_start)
+nfsd4_cltrack_grace_start(time64_t grace_start)
 {
 	int copied;
 	size_t len;
@@ -1796,7 +1796,7 @@ nfsd4_cltrack_grace_start(time_t grace_start)
 	if (!result)
 		return result;
 
-	copied = snprintf(result, len, GRACE_START_ENV_PREFIX "%ld",
+	copied = snprintf(result, len, GRACE_START_ENV_PREFIX "%lld",
 				grace_start);
 	if (copied >= len) {
 		/* just return nothing if output was truncated */
@@ -2005,7 +2005,7 @@ nfsd4_umh_cltrack_grace_done(struct nfsd_net *nn)
 	char *legacy;
 	char timestr[22]; /* FIXME: better way to determine max size? */
 
-	sprintf(timestr, "%ld", nn->boot_time);
+	sprintf(timestr, "%lld", nn->boot_time);
 	legacy = nfsd4_cltrack_legacy_topdir();
 	nfsd4_umh_cltrack_upcall("gracedone", timestr, legacy, NULL);
 	kfree(legacy);
* Unmerged path fs/nfsd/nfs4state.c
