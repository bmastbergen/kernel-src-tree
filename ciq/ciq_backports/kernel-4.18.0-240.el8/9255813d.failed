locking/atomic: Use s64 for atomic64

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mark Rutland <mark.rutland@arm.com>
commit 9255813d5841e158f033e0d83d455bffdae009a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9255813d.failed

As a step towards making the atomic64 API use consistent types treewide,
let's have the generic atomic64 implementation use s64 as the underlying
type for atomic64_t, rather than long long, matching the generated
headers.

Otherwise, there should be no functional change as a result of this
patch.

	Signed-off-by: Mark Rutland <mark.rutland@arm.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Acked-by: Arnd Bergmann <arnd@arndb.de>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Will Deacon <will.deacon@arm.com>
	Cc: aou@eecs.berkeley.edu
	Cc: bp@alien8.de
	Cc: catalin.marinas@arm.com
	Cc: davem@davemloft.net
	Cc: fenghua.yu@intel.com
	Cc: heiko.carstens@de.ibm.com
	Cc: herbert@gondor.apana.org.au
	Cc: ink@jurassic.park.msu.ru
	Cc: jhogan@kernel.org
	Cc: linux@armlinux.org.uk
	Cc: mattst88@gmail.com
	Cc: mpe@ellerman.id.au
	Cc: palmer@sifive.com
	Cc: paul.burton@mips.com
	Cc: paulus@samba.org
	Cc: ralf@linux-mips.org
	Cc: rth@twiddle.net
	Cc: tony.luck@intel.com
	Cc: vgupta@synopsys.com
Link: https://lkml.kernel.org/r/20190522132250.26499-4-mark.rutland@arm.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 9255813d5841e158f033e0d83d455bffdae009a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/asm-generic/atomic64.h
diff --cc include/asm-generic/atomic64.h
index 6b016e354b56,370f01d4450f..000000000000
--- a/include/asm-generic/atomic64.h
+++ b/include/asm-generic/atomic64.h
@@@ -50,20 -46,11 +50,28 @@@ ATOMIC64_OPS(xor
  #undef ATOMIC64_OP_RETURN
  #undef ATOMIC64_OP
  
++<<<<<<< HEAD
 +extern long long atomic64_dec_if_positive(atomic64_t *v);
 +extern long long atomic64_cmpxchg(atomic64_t *v, long long o, long long n);
 +extern long long atomic64_xchg(atomic64_t *v, long long new);
 +extern long long atomic64_fetch_add_unless(atomic64_t *v, long long a, long long u);
++=======
+ extern s64 atomic64_dec_if_positive(atomic64_t *v);
+ #define atomic64_dec_if_positive atomic64_dec_if_positive
+ extern s64 atomic64_cmpxchg(atomic64_t *v, s64 o, s64 n);
+ extern s64 atomic64_xchg(atomic64_t *v, s64 new);
+ extern s64 atomic64_fetch_add_unless(atomic64_t *v, s64 a, s64 u);
++>>>>>>> 9255813d5841 (locking/atomic: Use s64 for atomic64)
  #define atomic64_fetch_add_unless atomic64_fetch_add_unless
  
 +#define atomic64_add_negative(a, v)	(atomic64_add_return((a), (v)) < 0)
 +#define atomic64_inc(v)			atomic64_add(1LL, (v))
 +#define atomic64_inc_return(v)		atomic64_add_return(1LL, (v))
 +#define atomic64_inc_and_test(v) 	(atomic64_inc_return(v) == 0)
 +#define atomic64_sub_and_test(a, v)	(atomic64_sub_return((a), (v)) == 0)
 +#define atomic64_dec(v)			atomic64_sub(1LL, (v))
 +#define atomic64_dec_return(v)		atomic64_sub_return(1LL, (v))
 +#define atomic64_dec_and_test(v)	(atomic64_dec_return((v)) == 0)
 +#define atomic64_inc_not_zero(v) 	atomic64_add_unless((v), 1LL, 0LL)
 +
  #endif  /*  _ASM_GENERIC_ATOMIC64_H  */
* Unmerged path include/asm-generic/atomic64.h
diff --git a/lib/atomic64.c b/lib/atomic64.c
index 1d91e31eceec..62f218bf50a0 100644
--- a/lib/atomic64.c
+++ b/lib/atomic64.c
@@ -46,11 +46,11 @@ static inline raw_spinlock_t *lock_addr(const atomic64_t *v)
 	return &atomic64_lock[addr & (NR_LOCKS - 1)].lock;
 }
 
-long long atomic64_read(const atomic64_t *v)
+s64 atomic64_read(const atomic64_t *v)
 {
 	unsigned long flags;
 	raw_spinlock_t *lock = lock_addr(v);
-	long long val;
+	s64 val;
 
 	raw_spin_lock_irqsave(lock, flags);
 	val = v->counter;
@@ -59,7 +59,7 @@ long long atomic64_read(const atomic64_t *v)
 }
 EXPORT_SYMBOL(atomic64_read);
 
-void atomic64_set(atomic64_t *v, long long i)
+void atomic64_set(atomic64_t *v, s64 i)
 {
 	unsigned long flags;
 	raw_spinlock_t *lock = lock_addr(v);
@@ -71,7 +71,7 @@ void atomic64_set(atomic64_t *v, long long i)
 EXPORT_SYMBOL(atomic64_set);
 
 #define ATOMIC64_OP(op, c_op)						\
-void atomic64_##op(long long a, atomic64_t *v)				\
+void atomic64_##op(s64 a, atomic64_t *v)				\
 {									\
 	unsigned long flags;						\
 	raw_spinlock_t *lock = lock_addr(v);				\
@@ -83,11 +83,11 @@ void atomic64_##op(long long a, atomic64_t *v)				\
 EXPORT_SYMBOL(atomic64_##op);
 
 #define ATOMIC64_OP_RETURN(op, c_op)					\
-long long atomic64_##op##_return(long long a, atomic64_t *v)		\
+s64 atomic64_##op##_return(s64 a, atomic64_t *v)			\
 {									\
 	unsigned long flags;						\
 	raw_spinlock_t *lock = lock_addr(v);				\
-	long long val;							\
+	s64 val;							\
 									\
 	raw_spin_lock_irqsave(lock, flags);				\
 	val = (v->counter c_op a);					\
@@ -97,11 +97,11 @@ long long atomic64_##op##_return(long long a, atomic64_t *v)		\
 EXPORT_SYMBOL(atomic64_##op##_return);
 
 #define ATOMIC64_FETCH_OP(op, c_op)					\
-long long atomic64_fetch_##op(long long a, atomic64_t *v)		\
+s64 atomic64_fetch_##op(s64 a, atomic64_t *v)				\
 {									\
 	unsigned long flags;						\
 	raw_spinlock_t *lock = lock_addr(v);				\
-	long long val;							\
+	s64 val;							\
 									\
 	raw_spin_lock_irqsave(lock, flags);				\
 	val = v->counter;						\
@@ -134,11 +134,11 @@ ATOMIC64_OPS(xor, ^=)
 #undef ATOMIC64_OP_RETURN
 #undef ATOMIC64_OP
 
-long long atomic64_dec_if_positive(atomic64_t *v)
+s64 atomic64_dec_if_positive(atomic64_t *v)
 {
 	unsigned long flags;
 	raw_spinlock_t *lock = lock_addr(v);
-	long long val;
+	s64 val;
 
 	raw_spin_lock_irqsave(lock, flags);
 	val = v->counter - 1;
@@ -149,11 +149,11 @@ long long atomic64_dec_if_positive(atomic64_t *v)
 }
 EXPORT_SYMBOL(atomic64_dec_if_positive);
 
-long long atomic64_cmpxchg(atomic64_t *v, long long o, long long n)
+s64 atomic64_cmpxchg(atomic64_t *v, s64 o, s64 n)
 {
 	unsigned long flags;
 	raw_spinlock_t *lock = lock_addr(v);
-	long long val;
+	s64 val;
 
 	raw_spin_lock_irqsave(lock, flags);
 	val = v->counter;
@@ -164,11 +164,11 @@ long long atomic64_cmpxchg(atomic64_t *v, long long o, long long n)
 }
 EXPORT_SYMBOL(atomic64_cmpxchg);
 
-long long atomic64_xchg(atomic64_t *v, long long new)
+s64 atomic64_xchg(atomic64_t *v, s64 new)
 {
 	unsigned long flags;
 	raw_spinlock_t *lock = lock_addr(v);
-	long long val;
+	s64 val;
 
 	raw_spin_lock_irqsave(lock, flags);
 	val = v->counter;
@@ -178,11 +178,11 @@ long long atomic64_xchg(atomic64_t *v, long long new)
 }
 EXPORT_SYMBOL(atomic64_xchg);
 
-long long atomic64_fetch_add_unless(atomic64_t *v, long long a, long long u)
+s64 atomic64_fetch_add_unless(atomic64_t *v, s64 a, s64 u)
 {
 	unsigned long flags;
 	raw_spinlock_t *lock = lock_addr(v);
-	long long val;
+	s64 val;
 
 	raw_spin_lock_irqsave(lock, flags);
 	val = v->counter;
