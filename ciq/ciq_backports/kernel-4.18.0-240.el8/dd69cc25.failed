KVM: x86: Use kvm_cpu_caps to detect Intel PT support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit dd69cc2542f728179d5a0ae1c972813f88ab14aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dd69cc25.failed

Check for Intel PT using kvm_cpu_cap_has() to pave the way toward
eliminating ->pt_supported().

No functional change intended.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit dd69cc2542f728179d5a0ae1c972813f88ab14aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.c
diff --cc arch/x86/kvm/cpuid.c
index 70fb27088e0c,214bcb3a5c1e..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -450,74 -504,6 +450,77 @@@ static inline int __do_cpuid_func(struc
  {
  	struct kvm_cpuid_entry2 *entry;
  	int r, i, max_idx;
++<<<<<<< HEAD
 +	unsigned f_nx = is_efer_nx() ? F(NX) : 0;
 +#ifdef CONFIG_X86_64
 +	unsigned f_gbpages = (kvm_x86_ops->get_lpage_level() == PT_PDPE_LEVEL)
 +				? F(GBPAGES) : 0;
 +	unsigned f_lm = F(LM);
 +#else
 +	unsigned f_gbpages = 0;
 +	unsigned f_lm = 0;
 +#endif
 +	unsigned f_rdtscp = kvm_x86_ops->rdtscp_supported() ? F(RDTSCP) : 0;
 +	unsigned f_xsaves = kvm_x86_ops->xsaves_supported() ? F(XSAVES) : 0;
 +	unsigned f_intel_pt = kvm_x86_ops->pt_supported() ? F(INTEL_PT) : 0;
++=======
++>>>>>>> dd69cc2542f7 (KVM: x86: Use kvm_cpu_caps to detect Intel PT support)
 +
 +	/* cpuid 1.edx */
 +	const u32 kvm_cpuid_1_edx_x86_features =
 +		F(FPU) | F(VME) | F(DE) | F(PSE) |
 +		F(TSC) | F(MSR) | F(PAE) | F(MCE) |
 +		F(CX8) | F(APIC) | 0 /* Reserved */ | F(SEP) |
 +		F(MTRR) | F(PGE) | F(MCA) | F(CMOV) |
 +		F(PAT) | F(PSE36) | 0 /* PSN */ | F(CLFLUSH) |
 +		0 /* Reserved, DS, ACPI */ | F(MMX) |
 +		F(FXSR) | F(XMM) | F(XMM2) | F(SELFSNOOP) |
 +		0 /* HTT, TM, Reserved, PBE */;
 +	/* cpuid 0x80000001.edx */
 +	const u32 kvm_cpuid_8000_0001_edx_x86_features =
 +		F(FPU) | F(VME) | F(DE) | F(PSE) |
 +		F(TSC) | F(MSR) | F(PAE) | F(MCE) |
 +		F(CX8) | F(APIC) | 0 /* Reserved */ | F(SYSCALL) |
 +		F(MTRR) | F(PGE) | F(MCA) | F(CMOV) |
 +		F(PAT) | F(PSE36) | 0 /* Reserved */ |
 +		f_nx | 0 /* Reserved */ | F(MMXEXT) | F(MMX) |
 +		F(FXSR) | F(FXSR_OPT) | f_gbpages | f_rdtscp |
 +		0 /* Reserved */ | f_lm | F(3DNOWEXT) | F(3DNOW);
 +	/* cpuid 1.ecx */
 +	const u32 kvm_cpuid_1_ecx_x86_features =
 +		/* NOTE: MONITOR (and MWAIT) are emulated as NOP,
 +		 * but *not* advertised to guests via CPUID ! */
 +		F(XMM3) | F(PCLMULQDQ) | 0 /* DTES64, MONITOR */ |
 +		0 /* DS-CPL, VMX, SMX, EST */ |
 +		0 /* TM2 */ | F(SSSE3) | 0 /* CNXT-ID */ | 0 /* Reserved */ |
 +		F(FMA) | F(CX16) | 0 /* xTPR Update, PDCM */ |
 +		F(PCID) | 0 /* Reserved, DCA */ | F(XMM4_1) |
 +		F(XMM4_2) | F(X2APIC) | F(MOVBE) | F(POPCNT) |
 +		0 /* Reserved*/ | F(AES) | F(XSAVE) | 0 /* OSXSAVE */ | F(AVX) |
 +		F(F16C) | F(RDRAND);
 +	/* cpuid 0x80000001.ecx */
 +	const u32 kvm_cpuid_8000_0001_ecx_x86_features =
 +		F(LAHF_LM) | F(CMP_LEGACY) | 0 /*SVM*/ | 0 /* ExtApicSpace */ |
 +		F(CR8_LEGACY) | F(ABM) | F(SSE4A) | F(MISALIGNSSE) |
 +		F(3DNOWPREFETCH) | F(OSVW) | 0 /* IBS */ | F(XOP) |
 +		0 /* SKINIT, WDT, LWP */ | F(FMA4) | F(TBM) |
 +		F(TOPOEXT) | F(PERFCTR_CORE);
 +
 +	/* cpuid 0x80000008.ebx */
 +	const u32 kvm_cpuid_8000_0008_ebx_x86_features =
 +		F(CLZERO) | F(XSAVEERPTR) |
 +		F(WBNOINVD) | F(AMD_IBPB) | F(AMD_IBRS) | F(AMD_SSBD) | F(VIRT_SSBD) |
 +		F(AMD_SSB_NO) | F(AMD_STIBP) | F(AMD_STIBP_ALWAYS_ON);
 +
 +	/* cpuid 0xC0000001.edx */
 +	const u32 kvm_cpuid_C000_0001_edx_x86_features =
 +		F(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |
 +		F(ACE2) | F(ACE2_EN) | F(PHE) | F(PHE_EN) |
 +		F(PMM) | F(PMM_EN);
 +
 +	/* cpuid 0xD.1.eax */
 +	const u32 kvm_cpuid_D_1_eax_x86_features =
 +		F(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | f_xsaves;
  
  	/* all calls to cpuid_count() should be made on the same cpu */
  	get_cpu();
@@@ -696,10 -672,9 +699,10 @@@
  			entry->edx = 0;
  		}
  		break;
 +	}
  	/* Intel PT */
  	case 0x14:
- 		if (!f_intel_pt) {
+ 		if (!kvm_cpu_cap_has(X86_FEATURE_INTEL_PT)) {
  			entry->eax = entry->ebx = entry->ecx = entry->edx = 0;
  			break;
  		}
* Unmerged path arch/x86/kvm/cpuid.c
