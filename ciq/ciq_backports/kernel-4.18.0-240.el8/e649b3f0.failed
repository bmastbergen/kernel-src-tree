KVM: x86: Fix APIC page invalidation race

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Eiichi Tsukata <eiichi.tsukata@nutanix.com>
commit e649b3f0188f8fd34dd0dde8d43fd3312b902fb2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e649b3f0.failed

Commit b1394e745b94 ("KVM: x86: fix APIC page invalidation") tried
to fix inappropriate APIC page invalidation by re-introducing arch
specific kvm_arch_mmu_notifier_invalidate_range() and calling it from
kvm_mmu_notifier_invalidate_range_start. However, the patch left a
possible race where the VMCS APIC address cache is updated *before*
it is unmapped:

  (Invalidator) kvm_mmu_notifier_invalidate_range_start()
  (Invalidator) kvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD)
  (KVM VCPU) vcpu_enter_guest()
  (KVM VCPU) kvm_vcpu_reload_apic_access_page()
  (Invalidator) actually unmap page

Because of the above race, there can be a mismatch between the
host physical address stored in the APIC_ACCESS_PAGE VMCS field and
the host physical address stored in the EPT entry for the APIC GPA
(0xfee0000).  When this happens, the processor will not trap APIC
accesses, and will instead show the raw contents of the APIC-access page.
Because Windows OS periodically checks for unexpected modifications to
the LAPIC register, this will show up as a BSOD crash with BugCheck
CRITICAL_STRUCTURE_CORRUPTION (109) we are currently seeing in
https://bugzilla.redhat.com/show_bug.cgi?id=1751017.

The root cause of the issue is that kvm_arch_mmu_notifier_invalidate_range()
cannot guarantee that no additional references are taken to the pages in
the range before kvm_mmu_notifier_invalidate_range_end().  Fortunately,
this case is supported by the MMU notifier API, as documented in
include/linux/mmu_notifier.h:

	 * If the subsystem
         * can't guarantee that no additional references are taken to
         * the pages in the range, it has to implement the
         * invalidate_range() notifier to remove any references taken
         * after invalidate_range_start().

The fix therefore is to reload the APIC-access page field in the VMCS
from kvm_mmu_notifier_invalidate_range() instead of ..._range_start().

	Cc: stable@vger.kernel.org
Fixes: b1394e745b94 ("KVM: x86: fix APIC page invalidation")
Fixes: https://bugzilla.kernel.org/show_bug.cgi?id=197951
	Signed-off-by: Eiichi Tsukata <eiichi.tsukata@nutanix.com>
Message-Id: <20200606042627.61070-1-eiichi.tsukata@nutanix.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit e649b3f0188f8fd34dd0dde8d43fd3312b902fb2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
#	include/linux/kvm_host.h
#	virt/kvm/kvm_main.c
diff --cc arch/x86/kvm/x86.c
index f772e76d0120,24de847af52e..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -8042,7 -8271,7 +8042,11 @@@ static void vcpu_load_eoi_exitmap(struc
  }
  
  void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,
++<<<<<<< HEAD
 +		unsigned long start, unsigned long end)
++=======
+ 					    unsigned long start, unsigned long end)
++>>>>>>> e649b3f0188f (KVM: x86: Fix APIC page invalidation race)
  {
  	unsigned long apic_address;
  
diff --cc include/linux/kvm_host.h
index 7f2a8e5f98c9,e2f82131bb3e..000000000000
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@@ -1428,7 -1421,7 +1428,11 @@@ static inline long kvm_arch_vcpu_async_
  #endif /* CONFIG_HAVE_KVM_VCPU_ASYNC_IOCTL */
  
  void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,
++<<<<<<< HEAD
 +		unsigned long start, unsigned long end);
++=======
+ 					    unsigned long start, unsigned long end);
++>>>>>>> e649b3f0188f (KVM: x86: Fix APIC page invalidation race)
  
  #ifdef CONFIG_HAVE_KVM_VCPU_RUN_PID_CHANGE
  int kvm_arch_vcpu_run_pid_change(struct kvm_vcpu *vcpu);
diff --cc virt/kvm/kvm_main.c
index 5852813a6a6f,7b6013f2ba19..000000000000
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@@ -160,7 -156,7 +160,11 @@@ static unsigned long long kvm_createvm_
  static unsigned long long kvm_active_vms;
  
  __weak void kvm_arch_mmu_notifier_invalidate_range(struct kvm *kvm,
++<<<<<<< HEAD
 +		unsigned long start, unsigned long end)
++=======
+ 						   unsigned long start, unsigned long end)
++>>>>>>> e649b3f0188f (KVM: x86: Fix APIC page invalidation race)
  {
  }
  
@@@ -436,10 -435,9 +452,16 @@@ static void kvm_mmu_notifier_invalidate
  		kvm_flush_remote_tlbs(kvm);
  
  	spin_unlock(&kvm->mmu_lock);
++<<<<<<< HEAD
 +
 +	kvm_arch_mmu_notifier_invalidate_range(kvm, start, end);
 +
 +	srcu_read_unlock(&kvm->srcu, idx);
++=======
+ 	srcu_read_unlock(&kvm->srcu, idx);
+ 
+ 	return 0;
++>>>>>>> e649b3f0188f (KVM: x86: Fix APIC page invalidation race)
  }
  
  static void kvm_mmu_notifier_invalidate_range_end(struct mmu_notifier *mn,
@@@ -547,7 -543,7 +569,11 @@@ static void kvm_mmu_notifier_release(st
  }
  
  static const struct mmu_notifier_ops kvm_mmu_notifier_ops = {
++<<<<<<< HEAD
 +	.flags			= MMU_INVALIDATE_DOES_NOT_BLOCK,
++=======
+ 	.invalidate_range	= kvm_mmu_notifier_invalidate_range,
++>>>>>>> e649b3f0188f (KVM: x86: Fix APIC page invalidation race)
  	.invalidate_range_start	= kvm_mmu_notifier_invalidate_range_start,
  	.invalidate_range_end	= kvm_mmu_notifier_invalidate_range_end,
  	.clear_flush_young	= kvm_mmu_notifier_clear_flush_young,
* Unmerged path arch/x86/kvm/x86.c
* Unmerged path include/linux/kvm_host.h
* Unmerged path virt/kvm/kvm_main.c
