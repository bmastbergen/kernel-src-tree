net: phylink: split link_an_mode configured and current settings

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Russell King <rmk+kernel@armlinux.org.uk>
commit 24cf0e693bb50a61e3281009a329f7553a4fbd96
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/24cf0e69.failed

Split link_an_mode between the configured setting and the current
operating setting.  This is an important distinction to make when we
need to configure PHY mode for a plugged SFP+ module that does not
use in-band signalling.

	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: Russell King <rmk+kernel@armlinux.org.uk>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 24cf0e693bb50a61e3281009a329f7553a4fbd96)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phylink.c
diff --cc drivers/net/phy/phylink.c
index d2ef72edac49,bce530fc956d..000000000000
--- a/drivers/net/phy/phylink.c
+++ b/drivers/net/phy/phylink.c
@@@ -225,9 -262,9 +226,15 @@@ static int phylink_parse_mode(struct ph
  
  	if (fwnode_property_read_string(fwnode, "managed", &managed) == 0 &&
  	    strcmp(managed, "in-band-status") == 0) {
++<<<<<<< HEAD
 +		if (pl->link_an_mode == MLO_AN_FIXED) {
 +			netdev_err(pl->netdev,
 +				   "can't use both fixed-link and in-band-status\n");
++=======
+ 		if (pl->cfg_link_an_mode == MLO_AN_FIXED) {
+ 			phylink_err(pl,
+ 				    "can't use both fixed-link and in-band-status\n");
++>>>>>>> 24cf0e693bb5 (net: phylink: split link_an_mode configured and current settings)
  			return -EINVAL;
  		}
  
@@@ -295,16 -332,16 +302,29 @@@
  static void phylink_mac_config(struct phylink *pl,
  			       const struct phylink_link_state *state)
  {
++<<<<<<< HEAD
 +	netdev_dbg(pl->netdev,
 +		   "%s: mode=%s/%s/%s/%s adv=%*pb pause=%02x link=%u an=%u\n",
 +		   __func__, phylink_an_mode_str(pl->link_an_mode),
 +		   phy_modes(state->interface),
 +		   phy_speed_to_str(state->speed),
 +		   phy_duplex_to_str(state->duplex),
 +		   __ETHTOOL_LINK_MODE_MASK_NBITS, state->advertising,
 +		   state->pause, state->link, state->an_enabled);
 +
 +	pl->ops->mac_config(pl->netdev, pl->link_an_mode, state);
++=======
+ 	phylink_dbg(pl,
+ 		    "%s: mode=%s/%s/%s/%s adv=%*pb pause=%02x link=%u an=%u\n",
+ 		    __func__, phylink_an_mode_str(pl->cur_link_an_mode),
+ 		    phy_modes(state->interface),
+ 		    phy_speed_to_str(state->speed),
+ 		    phy_duplex_to_str(state->duplex),
+ 		    __ETHTOOL_LINK_MODE_MASK_NBITS, state->advertising,
+ 		    state->pause, state->link, state->an_enabled);
+ 
+ 	pl->ops->mac_config(pl->config, pl->cur_link_an_mode, state);
++>>>>>>> 24cf0e693bb5 (net: phylink: split link_an_mode configured and current settings)
  }
  
  static void phylink_mac_config_up(struct phylink *pl,
@@@ -400,6 -436,37 +420,40 @@@ static const char *phylink_pause_to_str
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void phylink_mac_link_up(struct phylink *pl,
+ 				struct phylink_link_state link_state)
+ {
+ 	struct net_device *ndev = pl->netdev;
+ 
+ 	pl->cur_interface = link_state.interface;
+ 	pl->ops->mac_link_up(pl->config, pl->cur_link_an_mode,
+ 			     pl->phy_state.interface,
+ 			     pl->phydev);
+ 
+ 	if (ndev)
+ 		netif_carrier_on(ndev);
+ 
+ 	phylink_info(pl,
+ 		     "Link is Up - %s/%s - flow control %s\n",
+ 		     phy_speed_to_str(link_state.speed),
+ 		     phy_duplex_to_str(link_state.duplex),
+ 		     phylink_pause_to_str(link_state.pause));
+ }
+ 
+ static void phylink_mac_link_down(struct phylink *pl)
+ {
+ 	struct net_device *ndev = pl->netdev;
+ 
+ 	if (ndev)
+ 		netif_carrier_off(ndev);
+ 	pl->ops->mac_link_down(pl->config, pl->cur_link_an_mode,
+ 			       pl->cur_interface);
+ 	phylink_info(pl, "Link is Down\n");
+ }
+ 
++>>>>>>> 24cf0e693bb5 (net: phylink: split link_an_mode configured and current settings)
  static void phylink_resolve(struct work_struct *w)
  {
  	struct phylink *pl = container_of(w, struct phylink, resolve);
@@@ -899,12 -964,13 +955,18 @@@ void phylink_start(struct phylink *pl
  {
  	ASSERT_RTNL();
  
++<<<<<<< HEAD
 +	netdev_info(pl->netdev, "configuring for %s/%s link mode\n",
 +		    phylink_an_mode_str(pl->link_an_mode),
 +		    phy_modes(pl->link_config.interface));
++=======
+ 	phylink_info(pl, "configuring for %s/%s link mode\n",
+ 		     phylink_an_mode_str(pl->cur_link_an_mode),
+ 		     phy_modes(pl->link_config.interface));
++>>>>>>> 24cf0e693bb5 (net: phylink: split link_an_mode configured and current settings)
  
  	/* Always set the carrier off */
 -	if (pl->netdev)
 -		netif_carrier_off(pl->netdev);
 +	netif_carrier_off(pl->netdev);
  
  	/* Apply the link configuration to the MAC when starting. This allows
  	 * a fixed-link to start with the correct parameters, and also
@@@ -1185,7 -1251,13 +1247,17 @@@ int phylink_ethtool_ksettings_set(struc
  	pl->link_config.duplex = our_kset.base.duplex;
  	pl->link_config.an_enabled = our_kset.base.autoneg != AUTONEG_DISABLE;
  
++<<<<<<< HEAD
 +	if (!test_bit(PHYLINK_DISABLE_STOPPED, &pl->phylink_disable_state)) {
++=======
+ 	/* If we have a PHY, phylib will call our link state function if the
+ 	 * mode has changed, which will trigger a resolve and update the MAC
+ 	 * configuration. For a fixed link, this isn't able to change any
+ 	 * parameters, which just leaves inband mode.
+ 	 */
+ 	if (pl->cur_link_an_mode == MLO_AN_INBAND &&
+ 	    !test_bit(PHYLINK_DISABLE_STOPPED, &pl->phylink_disable_state)) {
++>>>>>>> 24cf0e693bb5 (net: phylink: split link_an_mode configured and current settings)
  		phylink_mac_config(pl, &pl->link_config);
  		phylink_mac_an_restart(pl);
  	}
@@@ -1265,14 -1337,16 +1337,27 @@@ int phylink_ethtool_set_pauseparam(stru
  	if (pause->tx_pause)
  		config->pause |= MLO_PAUSE_TX;
  
++<<<<<<< HEAD
 +	if (!test_bit(PHYLINK_DISABLE_STOPPED, &pl->phylink_disable_state)) {
 +		switch (pl->link_an_mode) {
 +		case MLO_AN_PHY:
 +			/* Silently mark the carrier down, and then trigger a resolve */
 +			netif_carrier_off(pl->netdev);
 +			phylink_run_resolve(pl);
 +			break;
 +
++=======
+ 	/* If we have a PHY, phylib will call our link state function if the
+ 	 * mode has changed, which will trigger a resolve and update the MAC
+ 	 * configuration.
+ 	 */
+ 	if (pl->phydev) {
+ 		phy_set_asym_pause(pl->phydev, pause->rx_pause,
+ 				   pause->tx_pause);
+ 	} else if (!test_bit(PHYLINK_DISABLE_STOPPED,
+ 			     &pl->phylink_disable_state)) {
+ 		switch (pl->cur_link_an_mode) {
++>>>>>>> 24cf0e693bb5 (net: phylink: split link_an_mode configured and current settings)
  		case MLO_AN_FIXED:
  			/* Should we allow fixed links to change against the config? */
  			phylink_resolve_flow(pl, config);
* Unmerged path drivers/net/phy/phylink.c
