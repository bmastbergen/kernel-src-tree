ftrace/x86: Add a counter to test function_graph with direct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Steven Rostedt (VMware) <rostedt@goodmis.org>
commit a3ad1a7e39689005cb04a4f2adb82f9d55b4724f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a3ad1a7e.failed

As testing for direct calls from the function graph tracer adds a little
overhead (which is a lot when tracing every function), add a counter that
can be used to test if function_graph tracer needs to test for a direct
caller or not.

It would have been nicer if we could use a static branch, but the static
branch logic fails when used within the function graph tracer trampoline.

	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit a3ad1a7e39689005cb04a4f2adb82f9d55b4724f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/ftrace.c
#	include/linux/ftrace.h
#	kernel/trace/ftrace.c
diff --cc arch/x86/kernel/ftrace.c
index c0b4955db311,060a361d9d11..000000000000
--- a/arch/x86/kernel/ftrace.c
+++ b/arch/x86/kernel/ftrace.c
@@@ -1031,6 -1043,20 +1031,23 @@@ void prepare_ftrace_return(unsigned lon
  		return;
  
  	/*
++<<<<<<< HEAD
++=======
+ 	 * If the return location is actually pointing directly to
+ 	 * the start of a direct trampoline (if we trace the trampoline
+ 	 * it will still be offset by MCOUNT_INSN_SIZE), then the
+ 	 * return address is actually off by one word, and we
+ 	 * need to adjust for that.
+ 	 */
+ 	if (ftrace_direct_func_count) {
+ 		if (ftrace_find_direct_func(self_addr + MCOUNT_INSN_SIZE)) {
+ 			self_addr = *parent;
+ 			parent++;
+ 		}
+ 	}
+ 
+ 	/*
++>>>>>>> a3ad1a7e3968 (ftrace/x86: Add a counter to test function_graph with direct)
  	 * Protect against fault, even if it shouldn't
  	 * happen. This tool is too much intrusive to
  	 * ignore such a protection.
diff --cc include/linux/ftrace.h
index a0bdf45611c0,55647e185141..000000000000
--- a/include/linux/ftrace.h
+++ b/include/linux/ftrace.h
@@@ -243,6 -246,45 +243,48 @@@ static inline void ftrace_free_init_mem
  static inline void ftrace_free_mem(struct module *mod, void *start, void *end) { }
  #endif /* CONFIG_FUNCTION_TRACER */
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS
+ extern int ftrace_direct_func_count;
+ int register_ftrace_direct(unsigned long ip, unsigned long addr);
+ int unregister_ftrace_direct(unsigned long ip, unsigned long addr);
+ struct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr);
+ #else
+ # define ftrace_direct_func_count 0
+ static inline int register_ftrace_direct(unsigned long ip, unsigned long addr)
+ {
+ 	return -ENODEV;
+ }
+ static inline int unregister_ftrace_direct(unsigned long ip, unsigned long addr)
+ {
+ 	return -ENODEV;
+ }
+ static inline struct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr)
+ {
+ 	return NULL;
+ }
+ #endif /* CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS */
+ 
+ #ifndef CONFIG_HAVE_DYNAMIC_FTRACE_WITH_DIRECT_CALLS
+ /*
+  * This must be implemented by the architecture.
+  * It is the way the ftrace direct_ops helper, when called
+  * via ftrace (because there's other callbacks besides the
+  * direct call), can inform the architecture's trampoline that this
+  * routine has a direct caller, and what the caller is.
+  *
+  * For example, in x86, it returns the direct caller
+  * callback function via the regs->orig_ax parameter.
+  * Then in the ftrace trampoline, if this is set, it makes
+  * the return from the trampoline jump to the direct caller
+  * instead of going back to the function it just traced.
+  */
+ static inline void arch_ftrace_set_direct_caller(struct pt_regs *regs,
+ 						 unsigned long addr) { }
+ #endif /* CONFIG_HAVE_DYNAMIC_FTRACE_WITH_DIRECT_CALLS */
+ 
++>>>>>>> a3ad1a7e3968 (ftrace/x86: Add a counter to test function_graph with direct)
  #ifdef CONFIG_STACK_TRACER
  
  extern int stack_tracer_enabled;
diff --cc kernel/trace/ftrace.c
index ff6afd5bbf77,f9456346ec66..000000000000
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@@ -2359,6 -2360,52 +2359,55 @@@ ftrace_find_tramp_ops_new(struct dyn_ft
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS
+ /* Protected by rcu_tasks for reading, and direct_mutex for writing */
+ static struct ftrace_hash *direct_functions = EMPTY_HASH;
+ static DEFINE_MUTEX(direct_mutex);
+ int ftrace_direct_func_count;
+ 
+ /*
+  * Search the direct_functions hash to see if the given instruction pointer
+  * has a direct caller attached to it.
+  */
+ static unsigned long find_rec_direct(unsigned long ip)
+ {
+ 	struct ftrace_func_entry *entry;
+ 
+ 	entry = __ftrace_lookup_ip(direct_functions, ip);
+ 	if (!entry)
+ 		return 0;
+ 
+ 	return entry->direct;
+ }
+ 
+ static void call_direct_funcs(unsigned long ip, unsigned long pip,
+ 			      struct ftrace_ops *ops, struct pt_regs *regs)
+ {
+ 	unsigned long addr;
+ 
+ 	addr = find_rec_direct(ip);
+ 	if (!addr)
+ 		return;
+ 
+ 	arch_ftrace_set_direct_caller(regs, addr);
+ }
+ 
+ struct ftrace_ops direct_ops = {
+ 	.func		= call_direct_funcs,
+ 	.flags		= FTRACE_OPS_FL_IPMODIFY | FTRACE_OPS_FL_RECURSION_SAFE
+ 			  | FTRACE_OPS_FL_DIRECT | FTRACE_OPS_FL_SAVE_REGS
+ 			  | FTRACE_OPS_FL_PERMANENT,
+ };
+ #else
+ static inline unsigned long find_rec_direct(unsigned long ip)
+ {
+ 	return 0;
+ }
+ #endif /* CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS */
+ 
++>>>>>>> a3ad1a7e3968 (ftrace/x86: Add a counter to test function_graph with direct)
  /**
   * ftrace_get_addr_new - Get the call address to set to
   * @rec:  The ftrace record descriptor
@@@ -4797,9 -4935,226 +4846,229 @@@ static in
  ftrace_set_addr(struct ftrace_ops *ops, unsigned long ip, int remove,
  		int reset, int enable)
  {
 -	return ftrace_set_hash(ops, NULL, 0, ip, remove, reset, enable);
 +	return ftrace_set_hash(ops, 0, 0, ip, remove, reset, enable);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS
+ 
+ struct ftrace_direct_func {
+ 	struct list_head	next;
+ 	unsigned long		addr;
+ 	int			count;
+ };
+ 
+ static LIST_HEAD(ftrace_direct_funcs);
+ 
+ /**
+  * ftrace_find_direct_func - test an address if it is a registered direct caller
+  * @addr: The address of a registered direct caller
+  *
+  * This searches to see if a ftrace direct caller has been registered
+  * at a specific address, and if so, it returns a descriptor for it.
+  *
+  * This can be used by architecture code to see if an address is
+  * a direct caller (trampoline) attached to a fentry/mcount location.
+  * This is useful for the function_graph tracer, as it may need to
+  * do adjustments if it traced a location that also has a direct
+  * trampoline attached to it.
+  */
+ struct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr)
+ {
+ 	struct ftrace_direct_func *entry;
+ 	bool found = false;
+ 
+ 	/* May be called by fgraph trampoline (protected by rcu tasks) */
+ 	list_for_each_entry_rcu(entry, &ftrace_direct_funcs, next) {
+ 		if (entry->addr == addr) {
+ 			found = true;
+ 			break;
+ 		}
+ 	}
+ 	if (found)
+ 		return entry;
+ 
+ 	return NULL;
+ }
+ 
+ /**
+  * register_ftrace_direct - Call a custom trampoline directly
+  * @ip: The address of the nop at the beginning of a function
+  * @addr: The address of the trampoline to call at @ip
+  *
+  * This is used to connect a direct call from the nop location (@ip)
+  * at the start of ftrace traced functions. The location that it calls
+  * (@addr) must be able to handle a direct call, and save the parameters
+  * of the function being traced, and restore them (or inject new ones
+  * if needed), before returning.
+  *
+  * Returns:
+  *  0 on success
+  *  -EBUSY - Another direct function is already attached (there can be only one)
+  *  -ENODEV - @ip does not point to a ftrace nop location (or not supported)
+  *  -ENOMEM - There was an allocation failure.
+  */
+ int register_ftrace_direct(unsigned long ip, unsigned long addr)
+ {
+ 	struct ftrace_direct_func *direct;
+ 	struct ftrace_func_entry *entry;
+ 	struct ftrace_hash *free_hash = NULL;
+ 	struct dyn_ftrace *rec;
+ 	int ret = -EBUSY;
+ 
+ 	mutex_lock(&direct_mutex);
+ 
+ 	/* See if there's a direct function at @ip already */
+ 	if (find_rec_direct(ip))
+ 		goto out_unlock;
+ 
+ 	ret = -ENODEV;
+ 	rec = lookup_rec(ip, ip);
+ 	if (!rec)
+ 		goto out_unlock;
+ 
+ 	/*
+ 	 * Check if the rec says it has a direct call but we didn't
+ 	 * find one earlier?
+ 	 */
+ 	if (WARN_ON(rec->flags & FTRACE_FL_DIRECT))
+ 		goto out_unlock;
+ 
+ 	/* Make sure the ip points to the exact record */
+ 	ip = rec->ip;
+ 
+ 	ret = -ENOMEM;
+ 	if (ftrace_hash_empty(direct_functions) ||
+ 	    direct_functions->count > 2 * (1 << direct_functions->size_bits)) {
+ 		struct ftrace_hash *new_hash;
+ 		int size = ftrace_hash_empty(direct_functions) ? 0 :
+ 			direct_functions->count + 1;
+ 
+ 		if (size < 32)
+ 			size = 32;
+ 
+ 		new_hash = dup_hash(direct_functions, size);
+ 		if (!new_hash)
+ 			goto out_unlock;
+ 
+ 		free_hash = direct_functions;
+ 		direct_functions = new_hash;
+ 	}
+ 
+ 	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
+ 	if (!entry)
+ 		goto out_unlock;
+ 
+ 	direct = ftrace_find_direct_func(addr);
+ 	if (!direct) {
+ 		direct = kmalloc(sizeof(*direct), GFP_KERNEL);
+ 		if (!direct) {
+ 			kfree(entry);
+ 			goto out_unlock;
+ 		}
+ 		direct->addr = addr;
+ 		direct->count = 0;
+ 		list_add_rcu(&direct->next, &ftrace_direct_funcs);
+ 		ftrace_direct_func_count++;
+ 	}
+ 
+ 	entry->ip = ip;
+ 	entry->direct = addr;
+ 	__add_hash_entry(direct_functions, entry);
+ 
+ 	ret = ftrace_set_filter_ip(&direct_ops, ip, 0, 0);
+ 	if (ret)
+ 		remove_hash_entry(direct_functions, entry);
+ 
+ 	if (!ret && !(direct_ops.flags & FTRACE_OPS_FL_ENABLED)) {
+ 		ret = register_ftrace_function(&direct_ops);
+ 		if (ret)
+ 			ftrace_set_filter_ip(&direct_ops, ip, 1, 0);
+ 	}
+ 
+ 	if (ret) {
+ 		kfree(entry);
+ 		if (!direct->count) {
+ 			list_del_rcu(&direct->next);
+ 			synchronize_rcu_tasks();
+ 			kfree(direct);
+ 			if (free_hash)
+ 				free_ftrace_hash(free_hash);
+ 			free_hash = NULL;
+ 			ftrace_direct_func_count--;
+ 		}
+ 	} else {
+ 		if (!direct->count)
+ 			direct->count++;
+ 	}
+  out_unlock:
+ 	mutex_unlock(&direct_mutex);
+ 
+ 	if (free_hash) {
+ 		synchronize_rcu_tasks();
+ 		free_ftrace_hash(free_hash);
+ 	}
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(register_ftrace_direct);
+ 
+ int unregister_ftrace_direct(unsigned long ip, unsigned long addr)
+ {
+ 	struct ftrace_func_entry *entry;
+ 	struct ftrace_direct_func *direct;
+ 	struct dyn_ftrace *rec;
+ 	int ret = -ENODEV;
+ 
+ 	mutex_lock(&direct_mutex);
+ 
+ 	entry = __ftrace_lookup_ip(direct_functions, ip);
+ 	if (!entry) {
+ 		/* OK if it is off by a little */
+ 		rec = lookup_rec(ip, ip);
+ 		if (!rec || rec->ip == ip)
+ 			goto out_unlock;
+ 
+ 		entry = __ftrace_lookup_ip(direct_functions, rec->ip);
+ 		if (!entry) {
+ 			WARN_ON(rec->flags & FTRACE_FL_DIRECT);
+ 			goto out_unlock;
+ 		}
+ 
+ 		WARN_ON(!(rec->flags & FTRACE_FL_DIRECT));
+ 	}
+ 
+ 	if (direct_functions->count == 1)
+ 		unregister_ftrace_function(&direct_ops);
+ 
+ 	ret = ftrace_set_filter_ip(&direct_ops, ip, 1, 0);
+ 
+ 	WARN_ON(ret);
+ 
+ 	remove_hash_entry(direct_functions, entry);
+ 
+ 	direct = ftrace_find_direct_func(addr);
+ 	if (!WARN_ON(!direct)) {
+ 		/* This is the good path (see the ! before WARN) */
+ 		direct->count--;
+ 		WARN_ON(direct->count < 0);
+ 		if (!direct->count) {
+ 			list_del_rcu(&direct->next);
+ 			synchronize_rcu_tasks();
+ 			kfree(direct);
+ 			ftrace_direct_func_count--;
+ 		}
+ 	}
+  out_unlock:
+ 	mutex_unlock(&direct_mutex);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(unregister_ftrace_direct);
+ #endif /* CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS */
+ 
++>>>>>>> a3ad1a7e3968 (ftrace/x86: Add a counter to test function_graph with direct)
  /**
   * ftrace_set_filter_ip - set a function to filter on in ftrace by address
   * @ops - the ops to set the filter with
* Unmerged path arch/x86/kernel/ftrace.c
* Unmerged path include/linux/ftrace.h
* Unmerged path kernel/trace/ftrace.c
