powerpc/idle: Store PURR snapshot in a per-cpu global variable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Gautham R. Shenoy <ego@linux.vnet.ibm.com>
commit c4019198cfa81224d32846915cd401e981f81b81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c4019198.failed

Currently when CPU goes idle, we take a snapshot of PURR via
pseries_idle_prolog() which is used at the CPU idle exit to compute
the idle PURR cycles via the function pseries_idle_epilog().  Thus,
the value of idle PURR cycle thus read before pseries_idle_prolog() and
after pseries_idle_epilog() is always correct.

However, if we were to read the idle PURR cycles from an interrupt
context between pseries_idle_prolog() and pseries_idle_epilog() (this
will be done in a future patch), then, the value of the idle PURR thus
read will not include the cycles spent in the most recent idle period.
Thus, in that interrupt context, we will need access to the snapshot
of the PURR before going idle, in order to compute the idle PURR
cycles for the latest idle duration.

In this patch, we save the snapshot of PURR in pseries_idle_prolog()
in a per-cpu variable, instead of on the stack, so that it can be
accessed from an interrupt context.

	Signed-off-by: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/1586249263-14048-3-git-send-email-ego@linux.vnet.ibm.com
(cherry picked from commit c4019198cfa81224d32846915cd401e981f81b81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/idle.h
#	arch/powerpc/platforms/pseries/setup.c
#	drivers/cpuidle/cpuidle-pseries.c
diff --cc arch/powerpc/platforms/pseries/setup.c
index 16d0569700f5,4905c965e111..000000000000
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@@ -314,7 -330,7 +315,11 @@@ static void pseries_lpar_idle(void
  		return;
  
  	/* Indicate to hypervisor that we are idle. */
++<<<<<<< HEAD
 +	get_lppaca()->idle = 1;
++=======
+ 	pseries_idle_prolog();
++>>>>>>> c4019198cfa8 (powerpc/idle: Store PURR snapshot in a per-cpu global variable)
  
  	/*
  	 * Yield the processor to the hypervisor.  We return if
@@@ -325,7 -341,7 +330,11 @@@
  	 */
  	cede_processor();
  
++<<<<<<< HEAD
 +	get_lppaca()->idle = 0;
++=======
+ 	pseries_idle_epilog();
++>>>>>>> c4019198cfa8 (powerpc/idle: Store PURR snapshot in a per-cpu global variable)
  }
  
  /*
diff --cc drivers/cpuidle/cpuidle-pseries.c
index 74c247972bb3,6513ef2af66a..000000000000
--- a/drivers/cpuidle/cpuidle-pseries.c
+++ b/drivers/cpuidle/cpuidle-pseries.c
@@@ -63,7 -40,7 +62,11 @@@ static int snooze_loop(struct cpuidle_d
  
  	set_thread_flag(TIF_POLLING_NRFLAG);
  
++<<<<<<< HEAD
 +	idle_loop_prolog(&in_purr);
++=======
+ 	pseries_idle_prolog();
++>>>>>>> c4019198cfa8 (powerpc/idle: Store PURR snapshot in a per-cpu global variable)
  	local_irq_enable();
  	snooze_exit_time = get_tb() + snooze_timeout;
  
@@@ -87,7 -64,7 +90,11 @@@
  
  	local_irq_disable();
  
++<<<<<<< HEAD
 +	idle_loop_epilog(in_purr);
++=======
+ 	pseries_idle_epilog();
++>>>>>>> c4019198cfa8 (powerpc/idle: Store PURR snapshot in a per-cpu global variable)
  
  	return index;
  }
@@@ -113,9 -90,8 +120,12 @@@ static int dedicated_cede_loop(struct c
  				struct cpuidle_driver *drv,
  				int index)
  {
- 	unsigned long in_purr;
  
++<<<<<<< HEAD
 +	idle_loop_prolog(&in_purr);
++=======
+ 	pseries_idle_prolog();
++>>>>>>> c4019198cfa8 (powerpc/idle: Store PURR snapshot in a per-cpu global variable)
  	get_lppaca()->donate_dedicated_cpu = 1;
  
  	HMT_medium();
@@@ -124,7 -100,7 +134,11 @@@
  	local_irq_disable();
  	get_lppaca()->donate_dedicated_cpu = 0;
  
++<<<<<<< HEAD
 +	idle_loop_epilog(in_purr);
++=======
+ 	pseries_idle_epilog();
++>>>>>>> c4019198cfa8 (powerpc/idle: Store PURR snapshot in a per-cpu global variable)
  
  	return index;
  }
@@@ -133,9 -109,8 +147,12 @@@ static int shared_cede_loop(struct cpui
  			struct cpuidle_driver *drv,
  			int index)
  {
- 	unsigned long in_purr;
  
++<<<<<<< HEAD
 +	idle_loop_prolog(&in_purr);
++=======
+ 	pseries_idle_prolog();
++>>>>>>> c4019198cfa8 (powerpc/idle: Store PURR snapshot in a per-cpu global variable)
  
  	/*
  	 * Yield the processor to the hypervisor.  We return if
@@@ -147,7 -122,7 +164,11 @@@
  	check_and_cede_processor();
  
  	local_irq_disable();
++<<<<<<< HEAD
 +	idle_loop_epilog(in_purr);
++=======
+ 	pseries_idle_epilog();
++>>>>>>> c4019198cfa8 (powerpc/idle: Store PURR snapshot in a per-cpu global variable)
  
  	return index;
  }
* Unmerged path arch/powerpc/include/asm/idle.h
* Unmerged path arch/powerpc/include/asm/idle.h
* Unmerged path arch/powerpc/platforms/pseries/setup.c
* Unmerged path drivers/cpuidle/cpuidle-pseries.c
