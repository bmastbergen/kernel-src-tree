cpuidle: Pass exit latency limit to cpuidle_use_deepest_state()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Daniel Lezcano <daniel.lezcano@linaro.org>
commit 5aa9ba6312e36c18626e73506b92d1513d815435
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5aa9ba63.failed

Modify cpuidle_use_deepest_state() to take an additional exit latency
limit argument to be passed to find_deepest_idle_state() and make
cpuidle_idle_call() pass dev->forced_idle_latency_limit_ns to it for
forced idle.

	Suggested-by: Rafael J. Wysocki <rafael@kernel.org>
	Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
[ rjw: Rebase and rearrange code, subject & changelog ]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 5aa9ba6312e36c18626e73506b92d1513d815435)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpuidle/cpuidle.c
#	kernel/sched/idle.c
diff --cc drivers/cpuidle/cpuidle.c
index 08b37025da09,569dbac443bd..000000000000
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@@ -122,9 -123,10 +122,14 @@@ void cpuidle_use_deepest_state(bool ena
   * @dev: cpuidle device for the given CPU.
   */
  int cpuidle_find_deepest_state(struct cpuidle_driver *drv,
- 			       struct cpuidle_device *dev)
+ 			       struct cpuidle_device *dev,
+ 			       u64 latency_limit_ns)
  {
++<<<<<<< HEAD
 +	return find_deepest_state(drv, dev, UINT_MAX, 0, false);
++=======
+ 	return find_deepest_state(drv, dev, latency_limit_ns, 0, false);
++>>>>>>> 5aa9ba6312e3 (cpuidle: Pass exit latency limit to cpuidle_use_deepest_state())
  }
  
  #ifdef CONFIG_SUSPEND
diff --cc kernel/sched/idle.c
index b77157291d47,fc9604ddd802..000000000000
--- a/kernel/sched/idle.c
+++ b/kernel/sched/idle.c
@@@ -164,7 -165,9 +164,13 @@@ static void cpuidle_idle_call(void
  	 * until a proper wakeup interrupt happens.
  	 */
  
++<<<<<<< HEAD
 +	if (idle_should_enter_s2idle() || dev->use_deepest_state) {
++=======
+ 	if (idle_should_enter_s2idle() || dev->forced_idle_latency_limit_ns) {
+ 		u64 max_latency_ns;
+ 
++>>>>>>> 5aa9ba6312e3 (cpuidle: Pass exit latency limit to cpuidle_use_deepest_state())
  		if (idle_should_enter_s2idle()) {
  			rcu_idle_enter();
  
* Unmerged path drivers/cpuidle/cpuidle.c
diff --git a/include/linux/cpuidle.h b/include/linux/cpuidle.h
index a24a6cef6983..ec4ddcfe910d 100644
--- a/include/linux/cpuidle.h
+++ b/include/linux/cpuidle.h
@@ -235,13 +235,15 @@ static inline struct cpuidle_device *cpuidle_get_device(void) {return NULL; }
 
 #ifdef CONFIG_CPU_IDLE
 extern int cpuidle_find_deepest_state(struct cpuidle_driver *drv,
-				      struct cpuidle_device *dev);
+				      struct cpuidle_device *dev,
+				      u64 latency_limit_ns);
 extern int cpuidle_enter_s2idle(struct cpuidle_driver *drv,
 				struct cpuidle_device *dev);
 extern void cpuidle_use_deepest_state(bool enable);
 #else
 static inline int cpuidle_find_deepest_state(struct cpuidle_driver *drv,
-					     struct cpuidle_device *dev)
+					     struct cpuidle_device *dev,
+					     u64 latency_limit_ns)
 {return -ENODEV; }
 static inline int cpuidle_enter_s2idle(struct cpuidle_driver *drv,
 				       struct cpuidle_device *dev)
* Unmerged path kernel/sched/idle.c
