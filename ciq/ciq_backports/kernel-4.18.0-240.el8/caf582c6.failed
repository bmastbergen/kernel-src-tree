io_uring: optimise commit_sqring() for common case

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pavel Begunkov <asml.silence@gmail.com>
commit caf582c652feccd42c50923f0467c4f2dcef279e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/caf582c6.failed

It should be pretty rare to not submitting anything when there is
something in the ring. No need to keep heuristics for this case.

	Signed-off-by: Pavel Begunkov <asml.silence@gmail.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit caf582c652feccd42c50923f0467c4f2dcef279e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 28a601d08266,8613eae31f4c..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -2372,16 -4499,14 +2372,25 @@@ static void io_submit_state_start(struc
  
  static void io_commit_sqring(struct io_ring_ctx *ctx)
  {
 -	struct io_rings *rings = ctx->rings;
 +	struct io_sq_ring *ring = ctx->sq_ring;
  
++<<<<<<< HEAD
 +	if (ctx->cached_sq_head != READ_ONCE(ring->r.head)) {
 +		/*
 +		 * Ensure any loads from the SQEs are done at this point,
 +		 * since once we write the new head, the application could
 +		 * write new data to them.
 +		 */
 +		smp_store_release(&ring->r.head, ctx->cached_sq_head);
 +	}
++=======
+ 	/*
+ 	 * Ensure any loads from the SQEs are done at this point,
+ 	 * since once we write the new head, the application could
+ 	 * write new data to them.
+ 	 */
+ 	smp_store_release(&rings->sq.head, ctx->cached_sq_head);
++>>>>>>> caf582c652fe (io_uring: optimise commit_sqring() for common case)
  }
  
  /*
* Unmerged path fs/io_uring.c
