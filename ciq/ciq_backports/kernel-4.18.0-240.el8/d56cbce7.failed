drm/udl: Remove struct udl_gem_object and functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Thomas Zimmermann <tzimmermann@suse.de>
commit d56cbce7be1a310651bc293f0c2ccc1dfce994e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d56cbce7.failed

Simply removes all the obsolete GEM code from udl. No functional
changes.

	Signed-off-by: Thomas Zimmermann <tzimmermann@suse.de>
	Acked-by: Gerd Hoffmann <kraxel@redhat.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20191107094307.19870-5-tzimmermann@suse.de
(cherry picked from commit d56cbce7be1a310651bc293f0c2ccc1dfce994e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/udl/udl_dmabuf.c
#	drivers/gpu/drm/udl/udl_drv.h
#	drivers/gpu/drm/udl/udl_gem.c
diff --cc drivers/gpu/drm/udl/udl_drv.h
index 0fa4d8595d1a,987d99ae2dfa..000000000000
--- a/drivers/gpu/drm/udl/udl_drv.h
+++ b/drivers/gpu/drm/udl/udl_drv.h
@@@ -67,18 -73,9 +67,13 @@@ struct udl_device 
  
  #define to_udl(x) container_of(x, struct udl_device, drm)
  
- struct udl_gem_object {
- 	struct drm_gem_object base;
- 	struct page **pages;
- 	void *vmapping;
- 	struct sg_table *sg;
- };
- 
- #define to_udl_bo(x) container_of(x, struct udl_gem_object, base)
- 
  struct udl_framebuffer {
  	struct drm_framebuffer base;
++<<<<<<< HEAD
 +	struct udl_gem_object *obj;
++=======
+ 	struct drm_gem_shmem_object *shmem;
++>>>>>>> d56cbce7be1a (drm/udl: Remove struct udl_gem_object and functions)
  	bool active_16; /* active on the 16-bit channel */
  };
  
@@@ -113,26 -110,8 +108,31 @@@ int udl_render_hline(struct drm_device 
  		     u32 byte_offset, u32 device_byte_offset, u32 byte_width,
  		     int *ident_ptr, int *sent_ptr);
  
++<<<<<<< HEAD
 +int udl_dumb_create(struct drm_file *file_priv,
 +		    struct drm_device *dev,
 +		    struct drm_mode_create_dumb *args);
 +int udl_gem_mmap(struct drm_file *file_priv, struct drm_device *dev,
 +		 uint32_t handle, uint64_t *offset);
 +
 +void udl_gem_free_object(struct drm_gem_object *gem_obj);
 +struct udl_gem_object *udl_gem_alloc_object(struct drm_device *dev,
 +					    size_t size);
 +struct dma_buf *udl_gem_prime_export(struct drm_device *dev,
 +				     struct drm_gem_object *obj, int flags);
 +struct drm_gem_object *udl_gem_prime_import(struct drm_device *dev,
 +				struct dma_buf *dma_buf);
 +
 +int udl_gem_get_pages(struct udl_gem_object *obj);
 +void udl_gem_put_pages(struct udl_gem_object *obj);
 +int udl_gem_vmap(struct udl_gem_object *obj);
 +void udl_gem_vunmap(struct udl_gem_object *obj);
 +int udl_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma);
 +vm_fault_t udl_gem_fault(struct vm_fault *vmf);
++=======
+ struct drm_gem_object *udl_driver_gem_create_object(struct drm_device *dev,
+ 						    size_t size);
++>>>>>>> d56cbce7be1a (drm/udl: Remove struct udl_gem_object and functions)
  
  int udl_handle_damage(struct udl_framebuffer *fb, int x, int y,
  		      int width, int height);
diff --cc drivers/gpu/drm/udl/udl_gem.c
index 9e71f3272ed1,6eade6b4b0dc..000000000000
--- a/drivers/gpu/drm/udl/udl_gem.c
+++ b/drivers/gpu/drm/udl/udl_gem.c
@@@ -3,213 -3,120 +3,322 @@@
   * Copyright (C) 2012 Red Hat
   */
  
 +#include <drm/drmP.h>
 +#include "udl_drv.h"
++<<<<<<< HEAD
 +#include <linux/shmem_fs.h>
  #include <linux/dma-buf.h>
 -#include <linux/vmalloc.h>
  
 -#include <drm/drm_drv.h>
 -#include <drm/drm_gem_shmem_helper.h>
 -#include <drm/drm_mode.h>
 -#include <drm/drm_prime.h>
 +struct udl_gem_object *udl_gem_alloc_object(struct drm_device *dev,
 +					    size_t size)
 +{
 +	struct udl_gem_object *obj;
  
 -#include "udl_drv.h"
 +	obj = kzalloc(sizeof(*obj), GFP_KERNEL);
 +	if (obj == NULL)
 +		return NULL;
 +
 +	if (drm_gem_object_init(dev, &obj->base, size) != 0) {
 +		kfree(obj);
 +		return NULL;
 +	}
 +
 +	return obj;
 +}
 +
 +static int
 +udl_gem_create(struct drm_file *file,
 +	       struct drm_device *dev,
 +	       uint64_t size,
 +	       uint32_t *handle_p)
 +{
 +	struct udl_gem_object *obj;
 +	int ret;
 +	u32 handle;
 +
 +	size = roundup(size, PAGE_SIZE);
 +
 +	obj = udl_gem_alloc_object(dev, size);
 +	if (obj == NULL)
 +		return -ENOMEM;
 +
 +	ret = drm_gem_handle_create(file, &obj->base, &handle);
 +	if (ret) {
 +		drm_gem_object_release(&obj->base);
 +		kfree(obj);
 +		return ret;
 +	}
 +
 +	drm_gem_object_put_unlocked(&obj->base);
 +	*handle_p = handle;
 +	return 0;
 +}
 +
 +int udl_dumb_create(struct drm_file *file,
 +		    struct drm_device *dev,
 +		    struct drm_mode_create_dumb *args)
 +{
 +	args->pitch = args->width * DIV_ROUND_UP(args->bpp, 8);
 +	args->size = args->pitch * args->height;
 +	return udl_gem_create(file, dev,
 +			      args->size, &args->handle);
 +}
 +
 +int udl_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)
 +{
 +	struct drm_gem_object *obj;
 +	int ret;
 +
 +	ret = drm_gem_mmap(filp, vma);
 +	if (ret)
 +		return ret;
 +
 +	obj = vma->vm_private_data;
 +
 +	vma->vm_flags &= ~VM_PFNMAP;
 +	vma->vm_flags |= VM_MIXEDMAP;
 +
 +	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
 +	if (obj->import_attach)
 +		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
 +
 +	return ret;
 +}
 +
 +vm_fault_t udl_gem_fault(struct vm_fault *vmf)
 +{
 +	struct vm_area_struct *vma = vmf->vma;
 +	struct udl_gem_object *obj = to_udl_bo(vma->vm_private_data);
 +	struct page *page;
 +	unsigned int page_offset;
 +
 +	page_offset = (vmf->address - vma->vm_start) >> PAGE_SHIFT;
 +
 +	if (!obj->pages)
 +		return VM_FAULT_SIGBUS;
 +
 +	page = obj->pages[page_offset];
 +	return vmf_insert_page(vma, vmf->address, page);
 +}
 +
 +int udl_gem_get_pages(struct udl_gem_object *obj)
 +{
 +	struct page **pages;
 +
 +	if (obj->pages)
 +		return 0;
 +
 +	pages = drm_gem_get_pages(&obj->base);
 +	if (IS_ERR(pages))
 +		return PTR_ERR(pages);
 +
 +	obj->pages = pages;
++=======
+ 
+ /*
+  * GEM object funcs
+  */
+ 
+ static void udl_gem_object_free_object(struct drm_gem_object *obj)
+ {
+ 	struct drm_gem_shmem_object *shmem = to_drm_gem_shmem_obj(obj);
+ 
+ 	/* Fbdev emulation vmaps the buffer. Unmap it here for consistency
+ 	 * with the original udl GEM code.
+ 	 *
+ 	 * TODO: Switch to generic fbdev emulation and release the
+ 	 *       GEM object with drm_gem_shmem_free_object().
+ 	 */
+ 	if (shmem->vaddr)
+ 		drm_gem_shmem_vunmap(obj, shmem->vaddr);
+ 
+ 	drm_gem_shmem_free_object(obj);
+ }
+ 
+ static int udl_gem_object_mmap(struct drm_gem_object *obj,
+ 			       struct vm_area_struct *vma)
+ {
+ 	int ret;
+ 
+ 	ret = drm_gem_shmem_mmap(obj, vma);
+ 	if (ret)
+ 		return ret;
+ 
+ 	vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
+ 	if (obj->import_attach)
+ 		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+ 	vma->vm_page_prot = pgprot_decrypted(vma->vm_page_prot);
++>>>>>>> d56cbce7be1a (drm/udl: Remove struct udl_gem_object and functions)
  
  	return 0;
  }
  
++<<<<<<< HEAD
 +void udl_gem_put_pages(struct udl_gem_object *obj)
 +{
 +	if (obj->base.import_attach) {
 +		kvfree(obj->pages);
 +		obj->pages = NULL;
 +		return;
 +	}
 +
 +	drm_gem_put_pages(&obj->base, obj->pages, false, false);
 +	obj->pages = NULL;
 +}
 +
 +int udl_gem_vmap(struct udl_gem_object *obj)
 +{
 +	int page_count = obj->base.size / PAGE_SIZE;
 +	int ret;
 +
 +	if (obj->base.import_attach) {
 +		obj->vmapping = dma_buf_vmap(obj->base.import_attach->dmabuf);
 +		if (!obj->vmapping)
 +			return -ENOMEM;
 +		return 0;
 +	}
 +
 +	ret = udl_gem_get_pages(obj);
 +	if (ret)
 +		return ret;
 +
 +	obj->vmapping = vmap(obj->pages, page_count, 0, PAGE_KERNEL);
 +	if (!obj->vmapping)
 +		return -ENOMEM;
 +	return 0;
 +}
 +
 +void udl_gem_vunmap(struct udl_gem_object *obj)
 +{
 +	if (obj->base.import_attach) {
 +		dma_buf_vunmap(obj->base.import_attach->dmabuf, obj->vmapping);
 +		return;
 +	}
 +
 +	vunmap(obj->vmapping);
 +
 +	udl_gem_put_pages(obj);
 +}
 +
 +void udl_gem_free_object(struct drm_gem_object *gem_obj)
 +{
 +	struct udl_gem_object *obj = to_udl_bo(gem_obj);
 +
 +	if (obj->vmapping)
 +		udl_gem_vunmap(obj);
 +
 +	if (gem_obj->import_attach) {
 +		drm_prime_gem_destroy(gem_obj, obj->sg);
 +		put_device(gem_obj->dev->dev);
 +	}
 +
 +	if (obj->pages)
 +		udl_gem_put_pages(obj);
 +
 +	drm_gem_free_mmap_offset(gem_obj);
 +}
 +
 +/* the dumb interface doesn't work with the GEM straight MMAP
 +   interface, it expects to do MMAP on the drm fd, like normal */
 +int udl_gem_mmap(struct drm_file *file, struct drm_device *dev,
 +		 uint32_t handle, uint64_t *offset)
 +{
 +	struct udl_gem_object *gobj;
 +	struct drm_gem_object *obj;
 +	struct udl_device *udl = to_udl(dev);
 +	int ret = 0;
 +
 +	mutex_lock(&udl->gem_lock);
 +	obj = drm_gem_object_lookup(file, handle);
 +	if (obj == NULL) {
 +		ret = -ENOENT;
 +		goto unlock;
 +	}
 +	gobj = to_udl_bo(obj);
 +
 +	ret = udl_gem_get_pages(gobj);
 +	if (ret)
 +		goto out;
 +	ret = drm_gem_create_mmap_offset(obj);
 +	if (ret)
 +		goto out;
 +
 +	*offset = drm_vma_node_offset_addr(&gobj->base.vma_node);
 +
 +out:
 +	drm_gem_object_put_unlocked(&gobj->base);
 +unlock:
 +	mutex_unlock(&udl->gem_lock);
 +	return ret;
++=======
+ static void *udl_gem_object_vmap(struct drm_gem_object *obj)
+ {
+ 	struct drm_gem_shmem_object *shmem = to_drm_gem_shmem_obj(obj);
+ 	int ret;
+ 
+ 	ret = mutex_lock_interruptible(&shmem->vmap_lock);
+ 	if (ret)
+ 		return ERR_PTR(ret);
+ 
+ 	if (shmem->vmap_use_count++ > 0)
+ 		goto out;
+ 
+ 	ret = drm_gem_shmem_get_pages(shmem);
+ 	if (ret)
+ 		goto err_zero_use;
+ 
+ 	if (obj->import_attach)
+ 		shmem->vaddr = dma_buf_vmap(obj->import_attach->dmabuf);
+ 	else
+ 		shmem->vaddr = vmap(shmem->pages, obj->size >> PAGE_SHIFT,
+ 				    VM_MAP, PAGE_KERNEL);
+ 
+ 	if (!shmem->vaddr) {
+ 		DRM_DEBUG_KMS("Failed to vmap pages\n");
+ 		ret = -ENOMEM;
+ 		goto err_put_pages;
+ 	}
+ 
+ out:
+ 	mutex_unlock(&shmem->vmap_lock);
+ 	return shmem->vaddr;
+ 
+ err_put_pages:
+ 	drm_gem_shmem_put_pages(shmem);
+ err_zero_use:
+ 	shmem->vmap_use_count = 0;
+ 	mutex_unlock(&shmem->vmap_lock);
+ 	return ERR_PTR(ret);
+ }
+ 
+ static const struct drm_gem_object_funcs udl_gem_object_funcs = {
+ 	.free = udl_gem_object_free_object,
+ 	.print_info = drm_gem_shmem_print_info,
+ 	.pin = drm_gem_shmem_pin,
+ 	.unpin = drm_gem_shmem_unpin,
+ 	.get_sg_table = drm_gem_shmem_get_sg_table,
+ 	.vmap = udl_gem_object_vmap,
+ 	.vunmap = drm_gem_shmem_vunmap,
+ 	.mmap = udl_gem_object_mmap,
+ };
+ 
+ /*
+  * Helpers for struct drm_driver
+  */
+ 
+ struct drm_gem_object *udl_driver_gem_create_object(struct drm_device *dev,
+ 						    size_t size)
+ {
+ 	struct drm_gem_shmem_object *shmem;
+ 	struct drm_gem_object *obj;
+ 
+ 	shmem = kzalloc(sizeof(*shmem), GFP_KERNEL);
+ 	if (!shmem)
+ 		return NULL;
+ 
+ 	obj = &shmem->base;
+ 	obj->funcs = &udl_gem_object_funcs;
+ 
+ 	return obj;
++>>>>>>> d56cbce7be1a (drm/udl: Remove struct udl_gem_object and functions)
  }
* Unmerged path drivers/gpu/drm/udl/udl_dmabuf.c
diff --git a/drivers/gpu/drm/udl/Makefile b/drivers/gpu/drm/udl/Makefile
index e5bb6f757e11..9c42820ae33d 100644
--- a/drivers/gpu/drm/udl/Makefile
+++ b/drivers/gpu/drm/udl/Makefile
@@ -1,4 +1,4 @@
 # SPDX-License-Identifier: GPL-2.0-only
-udl-y := udl_drv.o udl_modeset.o udl_connector.o udl_encoder.o udl_main.o udl_fb.o udl_transfer.o udl_gem.o udl_dmabuf.o
+udl-y := udl_drv.o udl_modeset.o udl_connector.o udl_encoder.o udl_main.o udl_fb.o udl_transfer.o udl_gem.o
 
 obj-$(CONFIG_DRM_UDL) := udl.o
* Unmerged path drivers/gpu/drm/udl/udl_dmabuf.c
* Unmerged path drivers/gpu/drm/udl/udl_drv.h
* Unmerged path drivers/gpu/drm/udl/udl_gem.c
