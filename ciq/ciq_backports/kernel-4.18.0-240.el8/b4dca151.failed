swiotlb-xen: simplify cache maintainance

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Christoph Hellwig <hch@lst.de>
commit b4dca1512941aa8fec33c28939abc2bba4a2c78c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b4dca151.failed

Now that we know we always have the dma-noncoherent.h helpers available
if we are on an architecture with support for non-coherent devices,
we can just call them directly, and remove the calls to the dma-direct
routines, including the fact that we call the dma_direct_map_page
routines but ignore the value returned from it.  Instead we now have
Xen wrappers for the arch_sync_dma_for_{device,cpu} helpers that call
the special Xen versions of those routines for foreign pages.

Note that the new helpers get the physical address passed in addition
to the dma address to avoid another translation for the local cache
maintainance.  The pfn_valid checks remain on the dma address as in
the old code, even if that looks a little funny.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>
	Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
	Acked-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
(cherry picked from commit b4dca1512941aa8fec33c28939abc2bba4a2c78c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/xen/mm.c
#	include/xen/arm/page-coherent.h
diff --cc arch/arm/xen/mm.c
index 785d2a562a23,2b2c208408bb..000000000000
--- a/arch/arm/xen/mm.c
+++ b/arch/arm/xen/mm.c
@@@ -36,107 -35,58 +36,132 @@@ unsigned long xen_get_swiotlb_free_page
  	return __get_free_pages(flags, order);
  }
  
 +enum dma_cache_op {
 +       DMA_UNMAP,
 +       DMA_MAP,
 +};
  static bool hypercall_cflush = false;
  
 -/* buffers in highmem or foreign pages cannot cross page boundaries */
 -static void dma_cache_maint(dma_addr_t handle, size_t size, u32 op)
 +/* functions called by SWIOTLB */
 +
 +static void dma_cache_maint(dma_addr_t handle, unsigned long offset,
 +	size_t size, enum dma_data_direction dir, enum dma_cache_op op)
  {
  	struct gnttab_cache_flush cflush;
 +	unsigned long xen_pfn;
 +	size_t left = size;
  
 -	cflush.a.dev_bus_addr = handle & XEN_PAGE_MASK;
 -	cflush.offset = xen_offset_in_page(handle);
 -	cflush.op = op;
 +	xen_pfn = (handle >> XEN_PAGE_SHIFT) + offset / XEN_PAGE_SIZE;
 +	offset %= XEN_PAGE_SIZE;
  
  	do {
 -		if (size + cflush.offset > XEN_PAGE_SIZE)
 -			cflush.length = XEN_PAGE_SIZE - cflush.offset;
 -		else
 -			cflush.length = size;
 -
 -		HYPERVISOR_grant_table_op(GNTTABOP_cache_flush, &cflush, 1);
 +		size_t len = left;
 +	
 +		/* buffers in highmem or foreign pages cannot cross page
 +		 * boundaries */
 +		if (len + offset > XEN_PAGE_SIZE)
 +			len = XEN_PAGE_SIZE - offset;
 +
 +		cflush.op = 0;
 +		cflush.a.dev_bus_addr = xen_pfn << XEN_PAGE_SHIFT;
 +		cflush.offset = offset;
 +		cflush.length = len;
 +
 +		if (op == DMA_UNMAP && dir != DMA_TO_DEVICE)
 +			cflush.op = GNTTAB_CACHE_INVAL;
 +		if (op == DMA_MAP) {
 +			if (dir == DMA_FROM_DEVICE)
 +				cflush.op = GNTTAB_CACHE_INVAL;
 +			else
 +				cflush.op = GNTTAB_CACHE_CLEAN;
 +		}
 +		if (cflush.op)
 +			HYPERVISOR_grant_table_op(GNTTABOP_cache_flush, &cflush, 1);
  
 -		cflush.offset = 0;
 -		cflush.a.dev_bus_addr += cflush.length;
 -		size -= cflush.length;
 -	} while (size);
 +		offset = 0;
 +		xen_pfn++;
 +		left -= len;
 +	} while (left);
  }
  
- static void __xen_dma_page_dev_to_cpu(struct device *hwdev, dma_addr_t handle,
- 		size_t size, enum dma_data_direction dir)
+ /*
+  * Dom0 is mapped 1:1, and while the Linux page can span across multiple Xen
+  * pages, it is not possible for it to contain a mix of local and foreign Xen
+  * pages.  Calling pfn_valid on a foreign mfn will always return false, so if
+  * pfn_valid returns true the pages is local and we can use the native
+  * dma-direct functions, otherwise we call the Xen specific version.
+  */
+ void xen_dma_sync_for_cpu(struct device *dev, dma_addr_t handle,
+ 		phys_addr_t paddr, size_t size, enum dma_data_direction dir)
  {
++<<<<<<< HEAD
 +	dma_cache_maint(handle & PAGE_MASK, handle & ~PAGE_MASK, size, dir, DMA_UNMAP);
++=======
+ 	if (pfn_valid(PFN_DOWN(handle)))
+ 		arch_sync_dma_for_cpu(dev, paddr, size, dir);
+ 	else if (dir != DMA_TO_DEVICE)
+ 		dma_cache_maint(handle, size, GNTTAB_CACHE_INVAL);
++>>>>>>> b4dca1512941 (swiotlb-xen: simplify cache maintainance)
  }
  
- static void __xen_dma_page_cpu_to_dev(struct device *hwdev, dma_addr_t handle,
- 		size_t size, enum dma_data_direction dir)
+ void xen_dma_sync_for_device(struct device *dev, dma_addr_t handle,
+ 		phys_addr_t paddr, size_t size, enum dma_data_direction dir)
  {
++<<<<<<< HEAD
 +	dma_cache_maint(handle & PAGE_MASK, handle & ~PAGE_MASK, size, dir, DMA_MAP);
 +}
 +
 +void __xen_dma_map_page(struct device *hwdev, struct page *page,
 +	     dma_addr_t dev_addr, unsigned long offset, size_t size,
 +	     enum dma_data_direction dir, unsigned long attrs)
 +{
 +	if (is_device_dma_coherent(hwdev))
 +		return;
 +	if (attrs & DMA_ATTR_SKIP_CPU_SYNC)
 +		return;
 +
 +	__xen_dma_page_cpu_to_dev(hwdev, dev_addr, size, dir);
 +}
 +
 +void __xen_dma_unmap_page(struct device *hwdev, dma_addr_t handle,
 +		size_t size, enum dma_data_direction dir,
 +		unsigned long attrs)
 +
 +{
 +	if (is_device_dma_coherent(hwdev))
 +		return;
 +	if (attrs & DMA_ATTR_SKIP_CPU_SYNC)
 +		return;
 +
 +	__xen_dma_page_dev_to_cpu(hwdev, handle, size, dir);
 +}
 +
 +void __xen_dma_sync_single_for_cpu(struct device *hwdev,
 +		dma_addr_t handle, size_t size, enum dma_data_direction dir)
 +{
 +	if (is_device_dma_coherent(hwdev))
 +		return;
 +	__xen_dma_page_dev_to_cpu(hwdev, handle, size, dir);
 +}
 +
 +void __xen_dma_sync_single_for_device(struct device *hwdev,
 +		dma_addr_t handle, size_t size, enum dma_data_direction dir)
 +{
 +	if (is_device_dma_coherent(hwdev))
 +		return;
 +	__xen_dma_page_cpu_to_dev(hwdev, handle, size, dir);
 +}
 +
++=======
+ 	if (pfn_valid(PFN_DOWN(handle)))
+ 		arch_sync_dma_for_device(dev, paddr, size, dir);
+ 	else if (dir == DMA_FROM_DEVICE)
+ 		dma_cache_maint(handle, size, GNTTAB_CACHE_INVAL);
+ 	else
+ 		dma_cache_maint(handle, size, GNTTAB_CACHE_CLEAN);
+ }
+ 
++>>>>>>> b4dca1512941 (swiotlb-xen: simplify cache maintainance)
  bool xen_arch_need_swiotlb(struct device *dev,
  			   phys_addr_t phys,
  			   dma_addr_t dev_addr)
diff --cc include/xen/arm/page-coherent.h
index 59a260712a56,b9cc11e887ed..000000000000
--- a/include/xen/arm/page-coherent.h
+++ b/include/xen/arm/page-coherent.h
@@@ -1,30 -1,10 +1,33 @@@
  /* SPDX-License-Identifier: GPL-2.0 */
 -#ifndef _XEN_ARM_PAGE_COHERENT_H
 -#define _XEN_ARM_PAGE_COHERENT_H
 +#ifndef _ASM_ARM_XEN_PAGE_COHERENT_H
 +#define _ASM_ARM_XEN_PAGE_COHERENT_H
  
 -#include <linux/dma-mapping.h>
  #include <asm/page.h>
 +#include <asm/dma-mapping.h>
 +#include <linux/dma-mapping.h>
 +
 +static inline const struct dma_map_ops *xen_get_dma_ops(struct device *dev)
 +{
 +	if (dev && dev->archdata.dev_dma_ops)
 +		return dev->archdata.dev_dma_ops;
 +	return get_arch_dma_ops(NULL);
 +}
 +
++<<<<<<< HEAD
 +void __xen_dma_map_page(struct device *hwdev, struct page *page,
 +	     dma_addr_t dev_addr, unsigned long offset, size_t size,
 +	     enum dma_data_direction dir, unsigned long attrs);
 +void __xen_dma_unmap_page(struct device *hwdev, dma_addr_t handle,
 +		size_t size, enum dma_data_direction dir,
 +		unsigned long attrs);
 +void __xen_dma_sync_single_for_cpu(struct device *hwdev,
 +		dma_addr_t handle, size_t size, enum dma_data_direction dir);
  
 +void __xen_dma_sync_single_for_device(struct device *hwdev,
 +		dma_addr_t handle, size_t size, enum dma_data_direction dir);
 +
++=======
++>>>>>>> b4dca1512941 (swiotlb-xen: simplify cache maintainance)
  static inline void *xen_alloc_coherent_pages(struct device *hwdev, size_t size,
  		dma_addr_t *dma_handle, gfp_t flags, unsigned long attrs)
  {
@@@ -34,74 -14,7 +37,81 @@@
  static inline void xen_free_coherent_pages(struct device *hwdev, size_t size,
  		void *cpu_addr, dma_addr_t dma_handle, unsigned long attrs)
  {
++<<<<<<< HEAD
 +	xen_get_dma_ops(hwdev)->free(hwdev, size, cpu_addr, dma_handle, attrs);
 +}
 +
 +static inline void xen_dma_map_page(struct device *hwdev, struct page *page,
 +	     dma_addr_t dev_addr, unsigned long offset, size_t size,
 +	     enum dma_data_direction dir, unsigned long attrs)
 +{
 +	unsigned long page_pfn = page_to_xen_pfn(page);
 +	unsigned long dev_pfn = XEN_PFN_DOWN(dev_addr);
 +	unsigned long compound_pages =
 +		(1<<compound_order(page)) * XEN_PFN_PER_PAGE;
 +	bool local = (page_pfn <= dev_pfn) &&
 +		(dev_pfn - page_pfn < compound_pages);
 +
 +	/*
 +	 * Dom0 is mapped 1:1, while the Linux page can span across
 +	 * multiple Xen pages, it's not possible for it to contain a
 +	 * mix of local and foreign Xen pages. So if the first xen_pfn
 +	 * == mfn the page is local otherwise it's a foreign page
 +	 * grant-mapped in dom0. If the page is local we can safely
 +	 * call the native dma_ops function, otherwise we call the xen
 +	 * specific function.
 +	 */
 +	if (local)
 +		xen_get_dma_ops(hwdev)->map_page(hwdev, page, offset, size, dir, attrs);
 +	else
 +		__xen_dma_map_page(hwdev, page, dev_addr, offset, size, dir, attrs);
 +}
 +
 +static inline void xen_dma_unmap_page(struct device *hwdev, dma_addr_t handle,
 +		size_t size, enum dma_data_direction dir, unsigned long attrs)
 +{
 +	unsigned long pfn = PFN_DOWN(handle);
 +	/*
 +	 * Dom0 is mapped 1:1, while the Linux page can be spanned accross
 +	 * multiple Xen page, it's not possible to have a mix of local and
 +	 * foreign Xen page. Dom0 is mapped 1:1, so calling pfn_valid on a
 +	 * foreign mfn will always return false. If the page is local we can
 +	 * safely call the native dma_ops function, otherwise we call the xen
 +	 * specific function.
 +	 */
 +	if (pfn_valid(pfn)) {
 +		if (xen_get_dma_ops(hwdev)->unmap_page)
 +			xen_get_dma_ops(hwdev)->unmap_page(hwdev, handle, size, dir, attrs);
 +	} else
 +		__xen_dma_unmap_page(hwdev, handle, size, dir, attrs);
 +}
 +
 +static inline void xen_dma_sync_single_for_cpu(struct device *hwdev,
 +		dma_addr_t handle, size_t size, enum dma_data_direction dir)
 +{
 +	unsigned long pfn = PFN_DOWN(handle);
 +	if (pfn_valid(pfn)) {
 +		if (xen_get_dma_ops(hwdev)->sync_single_for_cpu)
 +			xen_get_dma_ops(hwdev)->sync_single_for_cpu(hwdev, handle, size, dir);
 +	} else
 +		__xen_dma_sync_single_for_cpu(hwdev, handle, size, dir);
 +}
 +
 +static inline void xen_dma_sync_single_for_device(struct device *hwdev,
 +		dma_addr_t handle, size_t size, enum dma_data_direction dir)
 +{
 +	unsigned long pfn = PFN_DOWN(handle);
 +	if (pfn_valid(pfn)) {
 +		if (xen_get_dma_ops(hwdev)->sync_single_for_device)
 +			xen_get_dma_ops(hwdev)->sync_single_for_device(hwdev, handle, size, dir);
 +	} else
 +		__xen_dma_sync_single_for_device(hwdev, handle, size, dir);
 +}
 +
 +#endif /* _ASM_ARM_XEN_PAGE_COHERENT_H */
++=======
+ 	dma_direct_free(hwdev, size, cpu_addr, dma_handle, attrs);
+ }
+ 
+ #endif /* _XEN_ARM_PAGE_COHERENT_H */
++>>>>>>> b4dca1512941 (swiotlb-xen: simplify cache maintainance)
* Unmerged path arch/arm/xen/mm.c
diff --git a/arch/x86/include/asm/xen/page-coherent.h b/arch/x86/include/asm/xen/page-coherent.h
index 116777e7f387..63cd41b2e17a 100644
--- a/arch/x86/include/asm/xen/page-coherent.h
+++ b/arch/x86/include/asm/xen/page-coherent.h
@@ -21,18 +21,4 @@ static inline void xen_free_coherent_pages(struct device *hwdev, size_t size,
 	free_pages((unsigned long) cpu_addr, get_order(size));
 }
 
-static inline void xen_dma_map_page(struct device *hwdev, struct page *page,
-	     dma_addr_t dev_addr, unsigned long offset, size_t size,
-	     enum dma_data_direction dir, unsigned long attrs) { }
-
-static inline void xen_dma_unmap_page(struct device *hwdev, dma_addr_t handle,
-		size_t size, enum dma_data_direction dir,
-		unsigned long attrs) { }
-
-static inline void xen_dma_sync_single_for_cpu(struct device *hwdev,
-		dma_addr_t handle, size_t size, enum dma_data_direction dir) { }
-
-static inline void xen_dma_sync_single_for_device(struct device *hwdev,
-		dma_addr_t handle, size_t size, enum dma_data_direction dir) { }
-
 #endif /* _ASM_X86_XEN_PAGE_COHERENT_H */
diff --git a/drivers/xen/swiotlb-xen.c b/drivers/xen/swiotlb-xen.c
index e920c075fbde..14448e4ea3e0 100644
--- a/drivers/xen/swiotlb-xen.c
+++ b/drivers/xen/swiotlb-xen.c
@@ -37,6 +37,7 @@
 
 #include <linux/bootmem.h>
 #include <linux/dma-direct.h>
+#include <linux/dma-noncoherent.h>
 #include <linux/export.h>
 #include <xen/swiotlb-xen.h>
 #include <xen/page.h>
@@ -394,6 +395,7 @@ static dma_addr_t xen_swiotlb_map_page(struct device *dev, struct page *page,
 	if (map == (phys_addr_t)DMA_MAPPING_ERROR)
 		return DMA_MAPPING_ERROR;
 
+	phys = map;
 	dev_addr = xen_phys_to_bus(map);
 
 	/*
@@ -405,14 +407,9 @@ static dma_addr_t xen_swiotlb_map_page(struct device *dev, struct page *page,
 		return DMA_MAPPING_ERROR;
 	}
 
-	page = pfn_to_page(map >> PAGE_SHIFT);
-	offset = map & ~PAGE_MASK;
 done:
-	/*
-	 * we are not interested in the dma_addr returned by xen_dma_map_page,
-	 * only in the potential cache flushes executed by the function.
-	 */
-	xen_dma_map_page(dev, page, dev_addr, offset, size, dir, attrs);
+	if (!dev_is_dma_coherent(dev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))
+		xen_dma_sync_for_device(dev, dev_addr, phys, size, dir);
 	return dev_addr;
 }
 
@@ -432,7 +429,8 @@ static void xen_unmap_single(struct device *hwdev, dma_addr_t dev_addr,
 
 	BUG_ON(dir == DMA_NONE);
 
-	xen_dma_unmap_page(hwdev, dev_addr, size, dir, attrs);
+	if (!dev_is_dma_coherent(hwdev) && !(attrs & DMA_ATTR_SKIP_CPU_SYNC))
+		xen_dma_sync_for_cpu(hwdev, dev_addr, paddr, size, dir);
 
 	/* NOTE: We use dev_addr here, not paddr! */
 	if (is_xen_swiotlb_buffer(dev_addr))
@@ -452,7 +450,8 @@ xen_swiotlb_sync_single_for_cpu(struct device *dev, dma_addr_t dma_addr,
 {
 	phys_addr_t paddr = xen_bus_to_phys(dma_addr);
 
-	xen_dma_sync_single_for_cpu(dev, dma_addr, size, dir);
+	if (!dev_is_dma_coherent(dev))
+		xen_dma_sync_for_cpu(dev, dma_addr, paddr, size, dir);
 
 	if (is_xen_swiotlb_buffer(dma_addr))
 		swiotlb_tbl_sync_single(dev, paddr, size, dir, SYNC_FOR_CPU);
@@ -467,7 +466,8 @@ xen_swiotlb_sync_single_for_device(struct device *dev, dma_addr_t dma_addr,
 	if (is_xen_swiotlb_buffer(dma_addr))
 		swiotlb_tbl_sync_single(dev, paddr, size, dir, SYNC_FOR_DEVICE);
 
-	xen_dma_sync_single_for_device(dev, dma_addr, size, dir);
+	if (!dev_is_dma_coherent(dev))
+		xen_dma_sync_for_device(dev, dma_addr, paddr, size, dir);
 }
 
 /*
* Unmerged path include/xen/arm/page-coherent.h
diff --git a/include/xen/swiotlb-xen.h b/include/xen/swiotlb-xen.h
index 5e4b83f83dbc..d71380f6ed0b 100644
--- a/include/xen/swiotlb-xen.h
+++ b/include/xen/swiotlb-xen.h
@@ -4,6 +4,11 @@
 
 #include <linux/swiotlb.h>
 
+void xen_dma_sync_for_cpu(struct device *dev, dma_addr_t handle,
+		phys_addr_t paddr, size_t size, enum dma_data_direction dir);
+void xen_dma_sync_for_device(struct device *dev, dma_addr_t handle,
+		phys_addr_t paddr, size_t size, enum dma_data_direction dir);
+
 extern int xen_swiotlb_init(int verbose, bool early);
 extern const struct dma_map_ops xen_swiotlb_dma_ops;
 
