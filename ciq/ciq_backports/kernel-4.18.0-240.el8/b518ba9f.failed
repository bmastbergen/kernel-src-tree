KVM: nSVM: implement check_nested_events for interrupts

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit b518ba9fa691a3066ee935f6f317f827295453f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b518ba9f.failed

The current implementation of physical interrupt delivery to a nested guest
is quite broken.  It relies on svm_interrupt_allowed returning false if
VINTR=1 so that the interrupt can be injected from enable_irq_window,
but this does not work for guests that do not intercept HLT or that rely
on clearing the host IF to block physical interrupts while L2 runs.

This patch can be split in two logical parts, but including only
one breaks tests so I am combining both changes together.

The first and easiest is simply to return true for svm_interrupt_allowed
if HF_VINTR_MASK is set and HIF is set.  This way the semantics of
svm_interrupt_allowed are respected: svm_interrupt_allowed being false
does not mean "call enable_irq_window", it means "interrupts cannot
be injected now".

After doing this, however, we need another place to inject the
interrupt, and fortunately we already have one, check_nested_events,
which nested SVM does not implement but which is meant exactly for this
purpose.  It is called before interrupts are injected, and it can
therefore do the L2->L1 switch while leaving inject_pending_event
none the wiser.

This patch was developed together with Cathy Avery, who wrote the
test and did a lot of the initial debugging.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b518ba9fa691a3066ee935f6f317f827295453f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm.c
diff --cc arch/x86/kvm/svm.c
index fb19b49b0c31,80f15a2483f4..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -5589,7 -5562,14 +5579,18 @@@ static void enable_irq_window(struct kv
  	 * enabled, the STGI interception will not occur. Enable the irq
  	 * window under the assumption that the hardware will set the GIF.
  	 */
++<<<<<<< HEAD
 +	if ((vgif_enabled(svm) || gif_set(svm)) && nested_svm_intr(svm)) {
++=======
+ 	if (vgif_enabled(svm) || gif_set(svm)) {
+ 		/*
+ 		 * IRQ window is not needed when AVIC is enabled,
+ 		 * unless we have pending ExtINT since it cannot be injected
+ 		 * via AVIC. In such case, we need to temporarily disable AVIC,
+ 		 * and fallback to injecting IRQ via V_IRQ.
+ 		 */
+ 		svm_toggle_avic_for_irq_window(vcpu, false);
++>>>>>>> b518ba9fa691 (KVM: nSVM: implement check_nested_events for interrupts)
  		svm_set_vintr(svm);
  	}
  }
* Unmerged path arch/x86/kvm/svm.c
