net/mlx5e: Export sharing of mod headers to a new file

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paul Blakey <paulb@mellanox.com>
commit b2fdf3d04714d4eea2f8a5c011cdd84b428c7df5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b2fdf3d0.failed

Refactor sharing of mod headers to new file and while there,
remove spin lock and flows list, as this is only used for warn on.

Use the generic API in the next patch to re-use tuple modify headers
for identical modify actions,

	Signed-off-by: Paul Blakey <paulb@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit b2fdf3d04714d4eea2f8a5c011cdd84b428c7df5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/Makefile
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/Makefile
index 8d3b7a3aee92,124caec65a34..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx5/core/Makefile
@@@ -32,9 -33,14 +32,20 @@@ mlx5_core-$(CONFIG_MLX5_CORE_EN) += en_
  mlx5_core-$(CONFIG_MLX5_EN_ARFS)     += en_arfs.o
  mlx5_core-$(CONFIG_MLX5_EN_RXNFC)    += en_fs_ethtool.o
  mlx5_core-$(CONFIG_MLX5_CORE_EN_DCB) += en_dcbnl.o en/port_buffer.o
++<<<<<<< HEAD
 +mlx5_core-$(CONFIG_MLX5_ESWITCH)     += en_rep.o en_tc.o en/tc_tun.o lib/port_tun.o lag_mp.o \
 +					lib/geneve.o en/tc_tun_vxlan.o en/tc_tun_gre.o \
 +					en/tc_tun_geneve.o
++=======
+ mlx5_core-$(CONFIG_PCI_HYPERV_INTERFACE) += en/hv_vhca_stats.o
+ mlx5_core-$(CONFIG_MLX5_ESWITCH)     += lag_mp.o lib/geneve.o lib/port_tun.o \
+ 					en_rep.o en/rep/bond.o en/mod_hdr.o
+ mlx5_core-$(CONFIG_MLX5_CLS_ACT)     += en_tc.o en/rep/tc.o en/rep/neigh.o \
+ 					en/mapping.o esw/chains.o en/tc_tun.o \
+ 					en/tc_tun_vxlan.o en/tc_tun_gre.o en/tc_tun_geneve.o \
+ 					en/tc_tun_mplsoudp.o diag/en_tc_tracepoint.o
+ mlx5_core-$(CONFIG_MLX5_TC_CT)	     += en/tc_ct.o
++>>>>>>> b2fdf3d04714 (net/mlx5e: Export sharing of mod headers to a new file)
  
  #
  # Core extra
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 23a1c21d8bab,3814c70b5230..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -54,8 -60,15 +54,14 @@@
  #include "fs_core.h"
  #include "en/port.h"
  #include "en/tc_tun.h"
++<<<<<<< HEAD
++=======
+ #include "en/mapping.h"
+ #include "en/tc_ct.h"
+ #include "en/mod_hdr.h"
++>>>>>>> b2fdf3d04714 (net/mlx5e: Export sharing of mod headers to a new file)
  #include "lib/devcom.h"
  #include "lib/geneve.h"
 -#include "diag/en_tc_tracepoint.h"
 -
 -#define MLX5_MH_ACT_SZ MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)
  
  struct mlx5_nic_flow_attr {
  	u32 action;
@@@ -183,31 -309,6 +188,34 @@@ struct mlx5e_hairpin_entry 
  	struct completion res_ready;
  };
  
++<<<<<<< HEAD
 +struct mod_hdr_key {
 +	int num_actions;
 +	void *actions;
 +};
 +
 +struct mlx5e_mod_hdr_entry {
 +	/* a node of a hash table which keeps all the mod_hdr entries */
 +	struct hlist_node mod_hdr_hlist;
 +
 +	/* protects flows list */
 +	spinlock_t flows_lock;
 +	/* flows sharing the same mod_hdr entry */
 +	struct list_head flows;
 +
 +	struct mod_hdr_key key;
 +
 +	struct mlx5_modify_hdr *modify_hdr;
 +
 +	refcount_t refcnt;
 +	struct completion res_ready;
 +	int compl_result;
 +};
 +
 +#define MLX5_MH_ACT_SZ MLX5_UN_SZ_BYTES(set_action_in_add_action_in_auto)
 +
++=======
++>>>>>>> b2fdf3d04714 (net/mlx5e: Export sharing of mod headers to a new file)
  static void mlx5e_tc_del_flow(struct mlx5e_priv *priv,
  			      struct mlx5e_tc_flow *flow);
  
@@@ -3573,8 -4329,8 +3473,7 @@@ mlx5e_alloc_flow(struct mlx5e_priv *pri
  	flow->priv = priv;
  	for (out_index = 0; out_index < MLX5_MAX_FLOW_FWD_VPORTS; out_index++)
  		INIT_LIST_HEAD(&flow->encaps[out_index].list);
- 	INIT_LIST_HEAD(&flow->mod_hdr);
  	INIT_LIST_HEAD(&flow->hairpin);
 -	INIT_LIST_HEAD(&flow->l3_to_l2_reformat);
  	refcount_set(&flow->refcnt, 1);
  	init_completion(&flow->init_done);
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 22d5efd4edec,b69f0e376ec0..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@@ -87,27 -122,46 +87,44 @@@ void mlx5e_put_encap_flow_list(struct m
  struct mlx5e_neigh_hash_entry;
  void mlx5e_tc_update_neigh_used_value(struct mlx5e_neigh_hash_entry *nhe);
  
 -void mlx5e_tc_reoffload_flows_work(struct work_struct *work);
 +int mlx5e_tc_num_filters(struct mlx5e_priv *priv, unsigned long flags);
  
 -enum mlx5e_tc_attr_to_reg {
 -	CHAIN_TO_REG,
 -	TUNNEL_TO_REG,
 -	CTSTATE_TO_REG,
 -	ZONE_TO_REG,
 -	ZONE_RESTORE_TO_REG,
 -	MARK_TO_REG,
 -	LABELS_TO_REG,
 -	FTEID_TO_REG,
 -};
 +void mlx5e_tc_reoffload_flows_work(struct work_struct *work);
  
 -struct mlx5e_tc_attr_to_reg_mapping {
 -	int mfield; /* rewrite field */
 -	int moffset; /* offset of mfield */
 -	int mlen; /* bytes to rewrite/match */
 +bool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,
 +				    struct net_device *out_dev);
  
 -	int soffset; /* offset of spec for match */
++<<<<<<< HEAD
 +struct mlx5e_tc_update_priv {
 +	struct net_device *tun_dev;
  };
  
 -extern struct mlx5e_tc_attr_to_reg_mapping mlx5e_tc_attr_to_reg_mappings[];
 +bool mlx5e_tc_rep_update_skb(struct mlx5_cqe64 *cqe, struct sk_buff *skb,
 +			     struct mlx5e_tc_update_priv *tc_priv);
  
 -bool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,
 -				    struct net_device *out_dev);
 +void mlx5_tc_rep_post_napi_receive(struct mlx5e_tc_update_priv *tc_priv);
  
 +struct mlx5e_tc_mod_hdr_acts {
 +	int num_actions;
 +	int max_actions;
 +	void *actions;
 +};
++=======
+ int mlx5e_tc_match_to_reg_set(struct mlx5_core_dev *mdev,
+ 			      struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,
+ 			      enum mlx5e_tc_attr_to_reg type,
+ 			      u32 data);
+ 
+ void mlx5e_tc_match_to_reg_match(struct mlx5_flow_spec *spec,
+ 				 enum mlx5e_tc_attr_to_reg type,
+ 				 u32 data,
+ 				 u32 mask);
+ 
+ void mlx5e_tc_match_to_reg_get_match(struct mlx5_flow_spec *spec,
+ 				     enum mlx5e_tc_attr_to_reg type,
+ 				     u32 *data,
+ 				     u32 *mask);
++>>>>>>> b2fdf3d04714 (net/mlx5e: Export sharing of mod headers to a new file)
  
  int alloc_mod_hdr_actions(struct mlx5_core_dev *mdev,
  			  int namespace,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 6b21d02803c5,c181f6b63f59..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -39,7 -40,9 +39,8 @@@
  #include "lib/eq.h"
  #include "eswitch.h"
  #include "fs_core.h"
 -#include "devlink.h"
  #include "ecpf.h"
+ #include "en/mod_hdr.h"
  
  enum {
  	MLX5_ACTION_NONE = 0,
@@@ -2028,10 -1749,13 +2029,16 @@@ int mlx5_eswitch_init(struct mlx5_core_
  
  	mutex_init(&esw->offloads.encap_tbl_lock);
  	hash_init(esw->offloads.encap_tbl);
++<<<<<<< HEAD
 +	mutex_init(&esw->offloads.mod_hdr.lock);
 +	hash_init(esw->offloads.mod_hdr.hlist);
++=======
+ 	mutex_init(&esw->offloads.decap_tbl_lock);
+ 	hash_init(esw->offloads.decap_tbl);
+ 	mlx5e_mod_hdr_tbl_init(&esw->offloads.mod_hdr);
++>>>>>>> b2fdf3d04714 (net/mlx5e: Export sharing of mod headers to a new file)
  	atomic64_set(&esw->offloads.num_flows, 0);
 -	ida_init(&esw->offloads.vport_metadata_ida);
  	mutex_init(&esw->state_lock);
 -	mutex_init(&esw->mode_lock);
  
  	mlx5_esw_for_all_vports(esw, i, vport) {
  		vport->vport = mlx5_eswitch_index_to_vport_num(esw, i);
@@@ -2066,9 -1790,12 +2073,14 @@@ void mlx5_eswitch_cleanup(struct mlx5_e
  	esw->dev->priv.eswitch = NULL;
  	destroy_workqueue(esw->work_queue);
  	esw_offloads_cleanup_reps(esw);
 -	mutex_destroy(&esw->mode_lock);
  	mutex_destroy(&esw->state_lock);
++<<<<<<< HEAD
 +	mutex_destroy(&esw->offloads.mod_hdr.lock);
++=======
+ 	ida_destroy(&esw->offloads.vport_metadata_ida);
+ 	mlx5e_mod_hdr_tbl_destroy(&esw->offloads.mod_hdr);
++>>>>>>> b2fdf3d04714 (net/mlx5e: Export sharing of mod headers to a new file)
  	mutex_destroy(&esw->offloads.encap_tbl_lock);
 -	mutex_destroy(&esw->offloads.decap_tbl_lock);
  	kfree(esw->vports);
  	kfree(esw);
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/Makefile
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
index 0416f7712109..ca55284fe623 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/fs.h
@@ -4,6 +4,8 @@
 #ifndef __MLX5E_FLOW_STEER_H__
 #define __MLX5E_FLOW_STEER_H__
 
+#include "mod_hdr.h"
+
 enum {
 	MLX5E_TC_FT_LEVEL = 0,
 	MLX5E_TC_TTC_FT_LEVEL,
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/mod_hdr.c b/drivers/net/ethernet/mellanox/mlx5/core/en/mod_hdr.c
new file mode 100644
index 000000000000..7edde4d536fd
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/mod_hdr.c
@@ -0,0 +1,157 @@
+// SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB
+// Copyright (c) 2020 Mellanox Technologies
+
+#include <linux/jhash.h>
+#include "mod_hdr.h"
+
+#define MLX5_MH_ACT_SZ MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)
+
+struct mod_hdr_key {
+	int num_actions;
+	void *actions;
+};
+
+struct mlx5e_mod_hdr_handle {
+	/* a node of a hash table which keeps all the mod_hdr entries */
+	struct hlist_node mod_hdr_hlist;
+
+	struct mod_hdr_key key;
+
+	struct mlx5_modify_hdr *modify_hdr;
+
+	refcount_t refcnt;
+	struct completion res_ready;
+	int compl_result;
+};
+
+static u32 hash_mod_hdr_info(struct mod_hdr_key *key)
+{
+	return jhash(key->actions,
+		     key->num_actions * MLX5_MH_ACT_SZ, 0);
+}
+
+static int cmp_mod_hdr_info(struct mod_hdr_key *a, struct mod_hdr_key *b)
+{
+	if (a->num_actions != b->num_actions)
+		return 1;
+
+	return memcmp(a->actions, b->actions,
+		      a->num_actions * MLX5_MH_ACT_SZ);
+}
+
+void mlx5e_mod_hdr_tbl_init(struct mod_hdr_tbl *tbl)
+{
+	mutex_init(&tbl->lock);
+	hash_init(tbl->hlist);
+}
+
+void mlx5e_mod_hdr_tbl_destroy(struct mod_hdr_tbl *tbl)
+{
+	mutex_destroy(&tbl->lock);
+}
+
+static struct mlx5e_mod_hdr_handle *mod_hdr_get(struct mod_hdr_tbl *tbl,
+						struct mod_hdr_key *key,
+						u32 hash_key)
+{
+	struct mlx5e_mod_hdr_handle *mh, *found = NULL;
+
+	hash_for_each_possible(tbl->hlist, mh, mod_hdr_hlist, hash_key) {
+		if (!cmp_mod_hdr_info(&mh->key, key)) {
+			refcount_inc(&mh->refcnt);
+			found = mh;
+			break;
+		}
+	}
+
+	return found;
+}
+
+struct mlx5e_mod_hdr_handle *
+mlx5e_mod_hdr_attach(struct mlx5_core_dev *mdev,
+		     struct mod_hdr_tbl *tbl,
+		     enum mlx5_flow_namespace_type namespace,
+		     struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts)
+{
+	int num_actions, actions_size, err;
+	struct mlx5e_mod_hdr_handle *mh;
+	struct mod_hdr_key key;
+	u32 hash_key;
+
+	num_actions  = mod_hdr_acts->num_actions;
+	actions_size = MLX5_MH_ACT_SZ * num_actions;
+
+	key.actions = mod_hdr_acts->actions;
+	key.num_actions = num_actions;
+
+	hash_key = hash_mod_hdr_info(&key);
+
+	mutex_lock(&tbl->lock);
+	mh = mod_hdr_get(tbl, &key, hash_key);
+	if (mh) {
+		mutex_unlock(&tbl->lock);
+		wait_for_completion(&mh->res_ready);
+
+		if (mh->compl_result < 0) {
+			err = -EREMOTEIO;
+			goto attach_header_err;
+		}
+		goto attach_header;
+	}
+
+	mh = kzalloc(sizeof(*mh) + actions_size, GFP_KERNEL);
+	if (!mh) {
+		mutex_unlock(&tbl->lock);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	mh->key.actions = (void *)mh + sizeof(*mh);
+	memcpy(mh->key.actions, key.actions, actions_size);
+	mh->key.num_actions = num_actions;
+	refcount_set(&mh->refcnt, 1);
+	init_completion(&mh->res_ready);
+
+	hash_add(tbl->hlist, &mh->mod_hdr_hlist, hash_key);
+	mutex_unlock(&tbl->lock);
+
+	mh->modify_hdr = mlx5_modify_header_alloc(mdev, namespace,
+						  mh->key.num_actions,
+						  mh->key.actions);
+	if (IS_ERR(mh->modify_hdr)) {
+		err = PTR_ERR(mh->modify_hdr);
+		mh->compl_result = err;
+		goto alloc_header_err;
+	}
+	mh->compl_result = 1;
+	complete_all(&mh->res_ready);
+
+attach_header:
+	return mh;
+
+alloc_header_err:
+	complete_all(&mh->res_ready);
+attach_header_err:
+	mlx5e_mod_hdr_detach(mdev, tbl, mh);
+	return ERR_PTR(err);
+}
+
+void mlx5e_mod_hdr_detach(struct mlx5_core_dev *mdev,
+			  struct mod_hdr_tbl *tbl,
+			  struct mlx5e_mod_hdr_handle *mh)
+{
+	if (!refcount_dec_and_mutex_lock(&mh->refcnt, &tbl->lock))
+		return;
+	hash_del(&mh->mod_hdr_hlist);
+	mutex_unlock(&tbl->lock);
+
+	if (mh->compl_result > 0)
+		mlx5_modify_header_dealloc(mdev, mh->modify_hdr);
+
+	kfree(mh);
+}
+
+struct mlx5_modify_hdr *mlx5e_mod_hdr_get(struct mlx5e_mod_hdr_handle *mh)
+{
+	return mh->modify_hdr;
+}
+
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/mod_hdr.h b/drivers/net/ethernet/mellanox/mlx5/core/en/mod_hdr.h
new file mode 100644
index 000000000000..33b23d8f9182
--- /dev/null
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/mod_hdr.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0 OR Linux-OpenIB */
+/* Copyright (c) 2020 Mellanox Technologies */
+
+#ifndef __MLX5E_EN_MOD_HDR_H__
+#define __MLX5E_EN_MOD_HDR_H__
+
+#include <linux/hashtable.h>
+#include <linux/mlx5/fs.h>
+
+struct mlx5e_mod_hdr_handle;
+
+struct mlx5e_tc_mod_hdr_acts {
+	int num_actions;
+	int max_actions;
+	void *actions;
+};
+
+struct mlx5e_mod_hdr_handle *
+mlx5e_mod_hdr_attach(struct mlx5_core_dev *mdev,
+		     struct mod_hdr_tbl *tbl,
+		     enum mlx5_flow_namespace_type namespace,
+		     struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts);
+void mlx5e_mod_hdr_detach(struct mlx5_core_dev *mdev,
+			  struct mod_hdr_tbl *tbl,
+			  struct mlx5e_mod_hdr_handle *mh);
+struct mlx5_modify_hdr *mlx5e_mod_hdr_get(struct mlx5e_mod_hdr_handle *mh);
+
+void mlx5e_mod_hdr_tbl_init(struct mod_hdr_tbl *tbl);
+void mlx5e_mod_hdr_tbl_destroy(struct mod_hdr_tbl *tbl);
+
+#endif /* __MLX5E_EN_MOD_HDR_H__ */
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
