ice: discover and store size of available flash

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit 81f07491e2bf264a871c319c70679c55230baebd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/81f07491.failed

When reading from the NVM using a flat address, it is useful to know the
upper bound on the size of the flash contents. This value is not stored
within the NVM.

We can determine the size by performing a bisection between upper and
lower bounds. It is known that the size cannot exceed 16 MB (offset of
0xFFFFFF).

Use a while loop to bisect the upper and lower bounds by reading one
byte at a time. On a failed read, lower the maximum bound. On
a successful read, increase the lower bound.

Save this as the flash_size in the ice_nvm_info structure that contains
data related to the NVM.

The size will be used in a future patch for implementing full NVM read
via ethtool's GEEPROM command.

The maximum possible size for the flash is bounded by the size limit for
the NVM AdminQ commands. Add a new macro, ICE_AQC_NVM_MAX_OFFSET, which
can be used to represent this upper bound.

	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Reviewed-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 81f07491e2bf264a871c319c70679c55230baebd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_nvm.c
diff --cc drivers/net/ethernet/intel/ice/ice_nvm.c
index 35790718b8d1,4cdce0370963..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_nvm.c
+++ b/drivers/net/ethernet/intel/ice/ice_nvm.c
@@@ -421,17 -472,38 +472,28 @@@ enum ice_status ice_init_nvm(struct ice
  
  	nvm->eetrack = (eetrack_hi << 16) | eetrack_lo;
  
++<<<<<<< HEAD
++=======
+ 	status = ice_discover_flash_size(hw);
+ 	if (status) {
+ 		ice_debug(hw, ICE_DBG_NVM,
+ 			  "NVM init error: failed to discover flash size.\n");
+ 		return status;
+ 	}
+ 
+ 	switch (hw->device_id) {
++>>>>>>> 81f07491e2bf (ice: discover and store size of available flash)
  	/* the following devices do not have boot_cfg_tlv yet */
 -	case ICE_DEV_ID_E823C_BACKPLANE:
 -	case ICE_DEV_ID_E823C_QSFP:
 -	case ICE_DEV_ID_E823C_SFP:
 -	case ICE_DEV_ID_E823C_10G_BASE_T:
 -	case ICE_DEV_ID_E823C_SGMII:
 -	case ICE_DEV_ID_E822C_BACKPLANE:
 -	case ICE_DEV_ID_E822C_QSFP:
 -	case ICE_DEV_ID_E822C_10G_BASE_T:
 -	case ICE_DEV_ID_E822C_SGMII:
 -	case ICE_DEV_ID_E822C_SFP:
 -	case ICE_DEV_ID_E822L_BACKPLANE:
 -	case ICE_DEV_ID_E822L_SFP:
 -	case ICE_DEV_ID_E822L_10G_BASE_T:
 -	case ICE_DEV_ID_E822L_SGMII:
 -	case ICE_DEV_ID_E823L_BACKPLANE:
 -	case ICE_DEV_ID_E823L_SFP:
 -	case ICE_DEV_ID_E823L_10G_BASE_T:
 -	case ICE_DEV_ID_E823L_1GBE:
 -	case ICE_DEV_ID_E823L_QSFP:
 +	if (hw->device_id == ICE_DEV_ID_E822C_BACKPLANE ||
 +	    hw->device_id == ICE_DEV_ID_E822C_QSFP ||
 +	    hw->device_id == ICE_DEV_ID_E822C_10G_BASE_T ||
 +	    hw->device_id == ICE_DEV_ID_E822C_SGMII ||
 +	    hw->device_id == ICE_DEV_ID_E822C_SFP ||
 +	    hw->device_id == ICE_DEV_ID_E822X_BACKPLANE ||
 +	    hw->device_id == ICE_DEV_ID_E822L_SFP ||
 +	    hw->device_id == ICE_DEV_ID_E822L_10G_BASE_T ||
 +	    hw->device_id == ICE_DEV_ID_E822L_SGMII)
  		return status;
 -	default:
 -		break;
 -	}
  
  	status = ice_get_orom_ver_info(hw);
  	if (status) {
diff --git a/drivers/net/ethernet/intel/ice/ice_adminq_cmd.h b/drivers/net/ethernet/intel/ice/ice_adminq_cmd.h
index 2240f226568f..0aaacdfd6ba5 100644
--- a/drivers/net/ethernet/intel/ice/ice_adminq_cmd.h
+++ b/drivers/net/ethernet/intel/ice/ice_adminq_cmd.h
@@ -1232,6 +1232,7 @@ struct ice_aqc_sff_eeprom {
  * NVM Update commands (indirect 0x0703)
  */
 struct ice_aqc_nvm {
+#define ICE_AQC_NVM_MAX_OFFSET		0xFFFFFF
 	__le16 offset_low;
 	u8 offset_high;
 	u8 cmd_flags;
@@ -1757,6 +1758,7 @@ enum ice_aq_err {
 	ICE_AQ_RC_ENOMEM	= 9,  /* Out of memory */
 	ICE_AQ_RC_EBUSY		= 12, /* Device or resource busy */
 	ICE_AQ_RC_EEXIST	= 13, /* Object already exists */
+	ICE_AQ_RC_EINVAL	= 14, /* Invalid argument */
 	ICE_AQ_RC_ENOSPC	= 16, /* No space left or allocation failure */
 	ICE_AQ_RC_ENOSYS	= 17, /* Function not implemented */
 	ICE_AQ_RC_ENOSEC	= 24, /* Missing security manifest */
* Unmerged path drivers/net/ethernet/intel/ice/ice_nvm.c
diff --git a/drivers/net/ethernet/intel/ice/ice_type.h b/drivers/net/ethernet/intel/ice/ice_type.h
index 28048b67cefb..93e687058e48 100644
--- a/drivers/net/ethernet/intel/ice/ice_type.h
+++ b/drivers/net/ethernet/intel/ice/ice_type.h
@@ -251,6 +251,7 @@ struct ice_nvm_info {
 	struct ice_orom_info orom;	/* Option ROM version info */
 	u32 eetrack;			/* NVM data version */
 	u16 sr_words;			/* Shadow RAM size in words */
+	u32 flash_size;			/* Size of available flash in bytes */
 	u8 major_ver;			/* major version of NVM package */
 	u8 minor_ver;			/* minor version of dev starter */
 	u8 blank_nvm_mode;        /* is NVM empty (no FW present) */
