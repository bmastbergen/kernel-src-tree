netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 303e0c5589592e4f623bfcaf4292a1ed816328ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/303e0c55.failed

after removal of the packet and invert function pointers, several
places do not need to lookup the l4proto structure anymore.

Remove those lookups.
The function nf_ct_invert_tuplepr becomes redundant, replace
it with nf_ct_invert_tuple everywhere.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 303e0c5589592e4f623bfcaf4292a1ed816328ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/nf_conntrack_proto_icmp.c
#	net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
#	net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
#	net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
#	net/netfilter/nf_conntrack_core.c
diff --cc net/ipv4/netfilter/nf_conntrack_proto_icmp.c
index da2ac2d71c9e,1007efae741d..000000000000
--- a/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
+++ b/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
@@@ -115,11 -105,10 +115,10 @@@ static bool icmp_new(struct nf_conn *ct
  
  /* Returns conntrack if it dealt with ICMP, and filled in skb fields */
  static int
 -icmp_error_message(struct nf_conn *tmpl, struct sk_buff *skb,
 -		   const struct nf_hook_state *state)
 +icmp_error_message(struct net *net, struct nf_conn *tmpl, struct sk_buff *skb,
 +		 unsigned int hooknum)
  {
  	struct nf_conntrack_tuple innertuple, origtuple;
- 	const struct nf_conntrack_l4proto *innerproto;
  	const struct nf_conntrack_tuple_hash *h;
  	const struct nf_conntrack_zone *zone;
  	enum ip_conntrack_info ctinfo;
@@@ -137,12 -126,9 +136,15 @@@
  		return -NF_ACCEPT;
  	}
  
++<<<<<<< HEAD:net/ipv4/netfilter/nf_conntrack_proto_icmp.c
 +	/* rcu_read_lock()ed by nf_hook_thresh */
 +	innerproto = __nf_ct_l4proto_find(PF_INET, origtuple.dst.protonum);
 +
++=======
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups):net/netfilter/nf_conntrack_proto_icmp.c
  	/* Ordinarily, we'd expect the inverted tupleproto, but it's
  	   been preserved inside the ICMP. */
- 	if (!nf_ct_invert_tuple(&innertuple, &origtuple, innerproto)) {
+ 	if (!nf_ct_invert_tuple(&innertuple, &origtuple)) {
  		pr_debug("icmp_error_message: no match\n");
  		return -NF_ACCEPT;
  	}
diff --cc net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
index 78a67f961d86,e26165af45cb..000000000000
--- a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
@@@ -232,9 -214,8 +232,14 @@@ int nf_nat_icmp_reply_translation(struc
  	}
  
  	/* Change outer to look like the reply to an incoming packet */
++<<<<<<< HEAD
 +	nf_ct_invert_tuplepr(&target, &ct->tuplehash[!dir].tuple);
 +	l4proto = __nf_nat_l4proto_find(NFPROTO_IPV4, 0);
 +	if (!nf_nat_ipv4_manip_pkt(skb, 0, l4proto, &target, manip))
++=======
+ 	nf_ct_invert_tuple(&target, &ct->tuplehash[!dir].tuple);
+ 	if (!nf_nat_ipv4_manip_pkt(skb, 0, &target, manip))
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups)
  		return 0;
  
  	return 1;
diff --cc net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
index 4b225a43a543,6c93c091a8dd..000000000000
--- a/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
@@@ -147,12 -145,9 +146,15 @@@ icmpv6_error_message(struct net *net, s
  		return -NF_ACCEPT;
  	}
  
++<<<<<<< HEAD:net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
 +	/* rcu_read_lock()ed by nf_hook_thresh */
 +	inproto = __nf_ct_l4proto_find(PF_INET6, origtuple.dst.protonum);
 +
++=======
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups):net/netfilter/nf_conntrack_proto_icmpv6.c
  	/* Ordinarily, we'd expect the inverted tupleproto, but it's
  	   been preserved inside the ICMP. */
- 	if (!nf_ct_invert_tuple(&intuple, &origtuple, inproto)) {
+ 	if (!nf_ct_invert_tuple(&intuple, &origtuple)) {
  		pr_debug("icmpv6_error: Can't invert tuple\n");
  		return -NF_ACCEPT;
  	}
diff --cc net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
index 9a3e0cf4290a,9c914db44bec..000000000000
--- a/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
+++ b/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
@@@ -244,9 -225,8 +244,14 @@@ int nf_nat_icmpv6_reply_translation(str
  						     skb->len - hdrlen, 0));
  	}
  
++<<<<<<< HEAD
 +	nf_ct_invert_tuplepr(&target, &ct->tuplehash[!dir].tuple);
 +	l4proto = __nf_nat_l4proto_find(NFPROTO_IPV6, IPPROTO_ICMPV6);
 +	if (!nf_nat_ipv6_manip_pkt(skb, 0, l4proto, &target, manip))
++=======
+ 	nf_ct_invert_tuple(&target, &ct->tuplehash[!dir].tuple);
+ 	if (!nf_nat_ipv6_manip_pkt(skb, 0, &target, manip))
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups)
  		return 0;
  
  	return 1;
diff --cc net/netfilter/nf_conntrack_core.c
index 680e0b0d92a5,728d2b5bdb1a..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -292,28 -373,14 +291,39 @@@ bool nf_ct_get_tuplepr(const struct sk_
  		       u_int16_t l3num,
  		       struct net *net, struct nf_conntrack_tuple *tuple)
  {
++<<<<<<< HEAD
 +	const struct nf_conntrack_l3proto *l3proto;
 +	const struct nf_conntrack_l4proto *l4proto;
 +	unsigned int protoff;
 +	u_int8_t protonum;
 +	int ret;
 +
 +	rcu_read_lock();
 +
 +	l3proto = __nf_ct_l3proto_find(l3num);
 +	ret = l3proto->get_l4proto(skb, nhoff, &protoff, &protonum);
 +	if (ret != NF_ACCEPT) {
 +		rcu_read_unlock();
++=======
+ 	u8 protonum;
+ 	int protoff;
+ 
+ 	protoff = get_l4proto(skb, nhoff, l3num, &protonum);
+ 	if (protoff <= 0)
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups)
  		return false;
- 	}
  
++<<<<<<< HEAD
 +	l4proto = __nf_ct_l4proto_find(l3num, protonum);
 +
 +	ret = nf_ct_get_tuple(skb, nhoff, protoff, l3num, protonum, net, tuple,
 +			      l4proto);
 +
 +	rcu_read_unlock();
 +	return ret;
++=======
+ 	return nf_ct_get_tuple(skb, nhoff, protoff, l3num, protonum, net, tuple);
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups)
  }
  EXPORT_SYMBOL_GPL(nf_ct_get_tuplepr);
  
@@@ -1330,9 -1351,8 +1338,9 @@@ init_conntrack(struct net *net, struct 
  	const struct nf_conntrack_zone *zone;
  	struct nf_conn_timeout *timeout_ext;
  	struct nf_conntrack_zone tmp;
 +	unsigned int *timeouts;
  
- 	if (!nf_ct_invert_tuple(&repl_tuple, tuple, l4proto)) {
+ 	if (!nf_ct_invert_tuple(&repl_tuple, tuple)) {
  		pr_debug("Can't invert tuple.\n");
  		return NULL;
  	}
@@@ -1424,12 -1430,11 +1432,16 @@@
  
  /* On success, returns 0, sets skb->_nfct | ctinfo */
  static int
 -resolve_normal_ct(struct nf_conn *tmpl,
 +resolve_normal_ct(struct net *net, struct nf_conn *tmpl,
  		  struct sk_buff *skb,
  		  unsigned int dataoff,
 +		  u_int16_t l3num,
  		  u_int8_t protonum,
++<<<<<<< HEAD
 +		  const struct nf_conntrack_l4proto *l4proto)
++=======
+ 		  const struct nf_hook_state *state)
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups)
  {
  	const struct nf_conntrack_zone *zone;
  	struct nf_conntrack_tuple tuple;
@@@ -1440,17 -1445,18 +1452,26 @@@
  	u32 hash;
  
  	if (!nf_ct_get_tuple(skb, skb_network_offset(skb),
++<<<<<<< HEAD
 +			     dataoff, l3num, protonum, net, &tuple, l4proto)) {
++=======
+ 			     dataoff, state->pf, protonum, state->net,
+ 			     &tuple)) {
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups)
  		pr_debug("Can't get tuple\n");
  		return 0;
  	}
  
  	/* look for tuple match */
  	zone = nf_ct_zone_tmpl(tmpl, skb, &tmp);
 -	hash = hash_conntrack_raw(&tuple, state->net);
 -	h = __nf_conntrack_find_get(state->net, zone, &tuple, hash);
 +	hash = hash_conntrack_raw(&tuple, net);
 +	h = __nf_conntrack_find_get(net, zone, &tuple, hash);
  	if (!h) {
++<<<<<<< HEAD
 +		h = init_conntrack(net, tmpl, &tuple, l4proto,
++=======
+ 		h = init_conntrack(state->net, tmpl, &tuple,
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups)
  				   skb, dataoff, hash);
  		if (!h)
  			return 0;
@@@ -1479,18 -1485,101 +1500,22 @@@
  	return 0;
  }
  
 -/*
 - * icmp packets need special treatment to handle error messages that are
 - * related to a connection.
 - *
 - * Callers need to check if skb has a conntrack assigned when this
 - * helper returns; in such case skb belongs to an already known connection.
 - */
 -static unsigned int __cold
 -nf_conntrack_handle_icmp(struct nf_conn *tmpl,
 -			 struct sk_buff *skb,
 -			 unsigned int dataoff,
 -			 u8 protonum,
 -			 const struct nf_hook_state *state)
 -{
 -	int ret;
 -
 -	if (state->pf == NFPROTO_IPV4 && protonum == IPPROTO_ICMP)
 -		ret = nf_conntrack_icmpv4_error(tmpl, skb, dataoff, state);
 -#if IS_ENABLED(CONFIG_IPV6)
 -	else if (state->pf == NFPROTO_IPV6 && protonum == IPPROTO_ICMPV6)
 -		ret = nf_conntrack_icmpv6_error(tmpl, skb, dataoff, state);
 -#endif
 -	else
 -		return NF_ACCEPT;
 -
 -	if (ret <= 0) {
 -		NF_CT_STAT_INC_ATOMIC(state->net, error);
 -		NF_CT_STAT_INC_ATOMIC(state->net, invalid);
 -	}
 -
 -	return ret;
 -}
 -
 -static int generic_packet(struct nf_conn *ct, struct sk_buff *skb,
 -			  enum ip_conntrack_info ctinfo)
 -{
 -	const unsigned int *timeout = nf_ct_timeout_lookup(ct);
 -
 -	if (!timeout)
 -		timeout = &nf_generic_pernet(nf_ct_net(ct))->timeout;
 -
 -	nf_ct_refresh_acct(ct, ctinfo, skb, *timeout);
 -	return NF_ACCEPT;
 -}
 -
 -/* Returns verdict for packet, or -1 for invalid. */
 -static int nf_conntrack_handle_packet(struct nf_conn *ct,
 -				      struct sk_buff *skb,
 -				      unsigned int dataoff,
 -				      enum ip_conntrack_info ctinfo,
 -				      const struct nf_hook_state *state)
 -{
 -	switch (nf_ct_protonum(ct)) {
 -	case IPPROTO_TCP:
 -		return nf_conntrack_tcp_packet(ct, skb, dataoff,
 -					       ctinfo, state);
 -	case IPPROTO_UDP:
 -		return nf_conntrack_udp_packet(ct, skb, dataoff,
 -					       ctinfo, state);
 -	case IPPROTO_ICMP:
 -		return nf_conntrack_icmp_packet(ct, skb, ctinfo, state);
 -	case IPPROTO_ICMPV6:
 -		return nf_conntrack_icmpv6_packet(ct, skb, ctinfo, state);
 -#ifdef CONFIG_NF_CT_PROTO_UDPLITE
 -	case IPPROTO_UDPLITE:
 -		return nf_conntrack_udplite_packet(ct, skb, dataoff,
 -						   ctinfo, state);
 -#endif
 -#ifdef CONFIG_NF_CT_PROTO_SCTP
 -	case IPPROTO_SCTP:
 -		return nf_conntrack_sctp_packet(ct, skb, dataoff,
 -						ctinfo, state);
 -#endif
 -#ifdef CONFIG_NF_CT_PROTO_DCCP
 -	case IPPROTO_DCCP:
 -		return nf_conntrack_dccp_packet(ct, skb, dataoff,
 -						ctinfo, state);
 -#endif
 -#ifdef CONFIG_NF_CT_PROTO_GRE
 -	case IPPROTO_GRE:
 -		return nf_conntrack_gre_packet(ct, skb, dataoff,
 -					       ctinfo, state);
 -#endif
 -	}
 -
 -	return generic_packet(ct, skb, ctinfo);
 -}
 -
  unsigned int
 -nf_conntrack_in(struct sk_buff *skb, const struct nf_hook_state *state)
 +nf_conntrack_in(struct net *net, u_int8_t pf, unsigned int hooknum,
 +		struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	const struct nf_conntrack_l3proto *l3proto;
 +	const struct nf_conntrack_l4proto *l4proto;
++=======
+ 	enum ip_conntrack_info ctinfo;
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups)
  	struct nf_conn *ct, *tmpl;
 +	enum ip_conntrack_info ctinfo;
 +	unsigned int *timeouts;
 +	unsigned int dataoff;
  	u_int8_t protonum;
 -	int dataoff, ret;
 +	int ret;
  
  	tmpl = nf_ct_get(skb, &ctinfo);
  	if (tmpl || ctinfo == IP_CT_UNTRACKED) {
@@@ -1515,16 -1602,10 +1540,22 @@@
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	l4proto = __nf_ct_l4proto_find(pf, protonum);
 +
 +	/* It may be an special packet, error, unclean...
 +	 * inverse of the return code tells to the netfilter
 +	 * core what to do with the packet. */
 +	if (l4proto->error != NULL) {
 +		ret = l4proto->error(net, tmpl, skb, dataoff, pf, hooknum);
++=======
+ 	if (protonum == IPPROTO_ICMP || protonum == IPPROTO_ICMPV6) {
+ 		ret = nf_conntrack_handle_icmp(tmpl, skb, dataoff,
+ 					       protonum, state);
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups)
  		if (ret <= 0) {
 +			NF_CT_STAT_INC_ATOMIC(net, error);
 +			NF_CT_STAT_INC_ATOMIC(net, invalid);
  			ret = -ret;
  			goto out;
  		}
@@@ -1533,10 -1614,11 +1564,15 @@@
  			goto out;
  	}
  repeat:
++<<<<<<< HEAD
 +	ret = resolve_normal_ct(net, tmpl, skb, dataoff, pf, protonum, l4proto);
++=======
+ 	ret = resolve_normal_ct(tmpl, skb, dataoff,
+ 				protonum, state);
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups)
  	if (ret < 0) {
  		/* Too stressed to deal. */
 -		NF_CT_STAT_INC_ATOMIC(state->net, drop);
 +		NF_CT_STAT_INC_ATOMIC(net, drop);
  		ret = NF_DROP;
  		goto out;
  	}
@@@ -1583,20 -1662,6 +1619,23 @@@ out
  }
  EXPORT_SYMBOL_GPL(nf_conntrack_in);
  
++<<<<<<< HEAD
 +bool nf_ct_invert_tuplepr(struct nf_conntrack_tuple *inverse,
 +			  const struct nf_conntrack_tuple *orig)
 +{
 +	bool ret;
 +
 +	rcu_read_lock();
 +	ret = nf_ct_invert_tuple(inverse, orig,
 +				 __nf_ct_l4proto_find(orig->src.l3num,
 +						      orig->dst.protonum));
 +	rcu_read_unlock();
 +	return ret;
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_invert_tuplepr);
 +
++=======
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups)
  /* Alter reply tuple (maybe alter helper).  This is for NAT, and is
     implicitly racy: see __nf_conntrack_confirm */
  void nf_conntrack_alter_reply(struct nf_conn *ct,
@@@ -1727,8 -1792,6 +1766,11 @@@ static void nf_conntrack_attach(struct 
  
  static int nf_conntrack_update(struct net *net, struct sk_buff *skb)
  {
++<<<<<<< HEAD
 +	const struct nf_conntrack_l3proto *l3proto;
 +	const struct nf_conntrack_l4proto *l4proto;
++=======
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups)
  	struct nf_conntrack_tuple_hash *h;
  	struct nf_conntrack_tuple tuple;
  	enum ip_conntrack_info ctinfo;
@@@ -1743,16 -1807,13 +1785,19 @@@
  		return 0;
  
  	l3num = nf_ct_l3num(ct);
 +	l3proto = nf_ct_l3proto_find_get(l3num);
  
 -	dataoff = get_l4proto(skb, skb_network_offset(skb), l3num, &l4num);
 -	if (dataoff <= 0)
 +	if (l3proto->get_l4proto(skb, skb_network_offset(skb), &dataoff,
 +				 &l4num) <= 0)
  		return -1;
  
++<<<<<<< HEAD
 +	l4proto = nf_ct_l4proto_find_get(l3num, l4num);
 +
++=======
++>>>>>>> 303e0c558959 (netfilter: conntrack: avoid unneeded nf_conntrack_l4proto lookups)
  	if (!nf_ct_get_tuple(skb, skb_network_offset(skb), dataoff, l3num,
- 			     l4num, net, &tuple, l4proto))
+ 			     l4num, net, &tuple))
  		return -1;
  
  	if (ct->status & IPS_SRC_NAT) {
diff --git a/include/net/netfilter/nf_conntrack.h b/include/net/netfilter/nf_conntrack.h
index 786883dd3806..740761afb45c 100644
--- a/include/net/netfilter/nf_conntrack.h
+++ b/include/net/netfilter/nf_conntrack.h
@@ -179,8 +179,6 @@ bool nf_ct_delete(struct nf_conn *ct, u32 pid, int report);
 bool nf_ct_get_tuplepr(const struct sk_buff *skb, unsigned int nhoff,
 		       u_int16_t l3num, struct net *net,
 		       struct nf_conntrack_tuple *tuple);
-bool nf_ct_invert_tuplepr(struct nf_conntrack_tuple *inverse,
-			  const struct nf_conntrack_tuple *orig);
 
 void __nf_ct_refresh_acct(struct nf_conn *ct, enum ip_conntrack_info ctinfo,
 			  const struct sk_buff *skb,
diff --git a/include/net/netfilter/nf_conntrack_core.h b/include/net/netfilter/nf_conntrack_core.h
index f5bc17885ca0..0acf57557cff 100644
--- a/include/net/netfilter/nf_conntrack_core.h
+++ b/include/net/netfilter/nf_conntrack_core.h
@@ -41,8 +41,7 @@ void nf_conntrack_init_end(void);
 void nf_conntrack_cleanup_end(void);
 
 bool nf_ct_invert_tuple(struct nf_conntrack_tuple *inverse,
-			const struct nf_conntrack_tuple *orig,
-			const struct nf_conntrack_l4proto *l4proto);
+			const struct nf_conntrack_tuple *orig);
 
 /* Find a connection corresponding to a tuple. */
 struct nf_conntrack_tuple_hash *
* Unmerged path net/ipv4/netfilter/nf_conntrack_proto_icmp.c
* Unmerged path net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
* Unmerged path net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
* Unmerged path net/netfilter/nf_conntrack_core.c
diff --git a/net/netfilter/nf_conntrack_pptp.c b/net/netfilter/nf_conntrack_pptp.c
index 11562f2a08bb..976f1dcb97f0 100644
--- a/net/netfilter/nf_conntrack_pptp.c
+++ b/net/netfilter/nf_conntrack_pptp.c
@@ -121,7 +121,7 @@ static void pptp_expectfn(struct nf_conn *ct,
 		struct nf_conntrack_expect *exp_other;
 
 		/* obviously this tuple inversion only works until you do NAT */
-		nf_ct_invert_tuplepr(&inv_t, &exp->tuple);
+		nf_ct_invert_tuple(&inv_t, &exp->tuple);
 		pr_debug("trying to unexpect other dir: ");
 		nf_ct_dump_tuple(&inv_t);
 
diff --git a/net/netfilter/nf_nat_core.c b/net/netfilter/nf_nat_core.c
index 275265d75be2..fb98d93ab25b 100644
--- a/net/netfilter/nf_nat_core.c
+++ b/net/netfilter/nf_nat_core.c
@@ -169,7 +169,7 @@ nf_nat_used_tuple(const struct nf_conntrack_tuple *tuple,
 	 */
 	struct nf_conntrack_tuple reply;
 
-	nf_ct_invert_tuplepr(&reply, tuple);
+	nf_ct_invert_tuple(&reply, tuple);
 	return nf_conntrack_tuple_taken(&reply, ignored_conntrack);
 }
 
@@ -226,7 +226,7 @@ find_appropriate_src(struct net *net,
 		    net_eq(net, nf_ct_net(ct)) &&
 		    nf_ct_zone_equal(ct, zone, IP_CT_DIR_ORIGINAL)) {
 			/* Copy source part from reply tuple. */
-			nf_ct_invert_tuplepr(result,
+			nf_ct_invert_tuple(result,
 				       &ct->tuplehash[IP_CT_DIR_REPLY].tuple);
 			result->dst = tuple->dst;
 
@@ -425,8 +425,8 @@ nf_nat_setup_info(struct nf_conn *ct,
 	 * manipulations (future optimization: if num_manips == 0,
 	 * orig_tp = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple)
 	 */
-	nf_ct_invert_tuplepr(&curr_tuple,
-			     &ct->tuplehash[IP_CT_DIR_REPLY].tuple);
+	nf_ct_invert_tuple(&curr_tuple,
+			   &ct->tuplehash[IP_CT_DIR_REPLY].tuple);
 
 	get_unique_tuple(&new_tuple, &curr_tuple, range, ct, maniptype);
 
@@ -434,7 +434,7 @@ nf_nat_setup_info(struct nf_conn *ct,
 		struct nf_conntrack_tuple reply;
 
 		/* Alter conntrack table so will recognize replies. */
-		nf_ct_invert_tuplepr(&reply, &new_tuple);
+		nf_ct_invert_tuple(&reply, &new_tuple);
 		nf_conntrack_alter_reply(ct, &reply);
 
 		/* Non-atomic: we own this at the moment. */
@@ -506,7 +506,7 @@ static unsigned int nf_nat_manip_pkt(struct sk_buff *skb, struct nf_conn *ct,
 	struct nf_conntrack_tuple target;
 
 	/* We are aiming to look like inverse of other direction. */
-	nf_ct_invert_tuplepr(&target, &ct->tuplehash[!dir].tuple);
+	nf_ct_invert_tuple(&target, &ct->tuplehash[!dir].tuple);
 
 	l3proto = __nf_nat_l3proto_find(target.src.l3num);
 	l4proto = __nf_nat_l4proto_find(target.src.l3num,
diff --git a/net/openvswitch/conntrack.c b/net/openvswitch/conntrack.c
index 7f5686829476..e432b35e2c7d 100644
--- a/net/openvswitch/conntrack.c
+++ b/net/openvswitch/conntrack.c
@@ -627,7 +627,7 @@ ovs_ct_find_existing(struct net *net, const struct nf_conntrack_zone *zone,
 	if (natted) {
 		struct nf_conntrack_tuple inverse;
 
-		if (!nf_ct_invert_tuplepr(&inverse, &tuple)) {
+		if (!nf_ct_invert_tuple(&inverse, &tuple)) {
 			pr_debug("ovs_ct_find_existing: Inversion failed!\n");
 			return NULL;
 		}
