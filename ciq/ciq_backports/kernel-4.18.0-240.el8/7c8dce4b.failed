bpftool: Make skeleton C code compilable with C++ compiler

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 7c8dce4b166113743adad131b5a24c4acc12f92c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7c8dce4b.failed

When auto-generated BPF skeleton C code is included from C++ application, it
triggers compilation error due to void * being implicitly casted to whatever
target pointer type. This is supported by C, but not C++. To solve this
problem, add explicit casts, where necessary.

To ensure issues like this are captured going forward, add skeleton usage in
test_cpp test.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Link: https://lore.kernel.org/bpf/20191226210253.3132060-1-andriin@fb.com
(cherry picked from commit 7c8dce4b166113743adad131b5a24c4acc12f92c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/bpf/bpftool/gen.c
#	tools/testing/selftests/bpf/Makefile
diff --cc tools/bpf/bpftool/gen.c
index fbac89cefb31,7ce09a9a6999..000000000000
--- a/tools/bpf/bpftool/gen.c
+++ b/tools/bpf/bpftool/gen.c
@@@ -352,14 -379,92 +352,96 @@@ static int do_skeleton(int argc, char *
  		\n\
  		};							    \n\
  									    \n\
++<<<<<<< HEAD
 +		static inline struct bpf_object_skeleton *		    \n\
 +		%1$s__create_skeleton(struct %1$s *obj, struct bpf_embed_data *embed)\n\
++=======
+ 		static void						    \n\
+ 		%1$s__destroy(struct %1$s *obj)				    \n\
+ 		{							    \n\
+ 			if (!obj)					    \n\
+ 				return;					    \n\
+ 			if (obj->skeleton)				    \n\
+ 				bpf_object__destroy_skeleton(obj->skeleton);\n\
+ 			free(obj);					    \n\
+ 		}							    \n\
+ 									    \n\
+ 		static inline int					    \n\
+ 		%1$s__create_skeleton(struct %1$s *obj);		    \n\
+ 									    \n\
+ 		static inline struct %1$s *				    \n\
+ 		%1$s__open_opts(const struct bpf_object_open_opts *opts)    \n\
+ 		{							    \n\
+ 			struct %1$s *obj;				    \n\
+ 									    \n\
+ 			obj = (typeof(obj))calloc(1, sizeof(*obj));	    \n\
+ 			if (!obj)					    \n\
+ 				return NULL;				    \n\
+ 			if (%1$s__create_skeleton(obj))			    \n\
+ 				goto err;				    \n\
+ 			if (bpf_object__open_skeleton(obj->skeleton, opts)) \n\
+ 				goto err;				    \n\
+ 									    \n\
+ 			return obj;					    \n\
+ 		err:							    \n\
+ 			%1$s__destroy(obj);				    \n\
+ 			return NULL;					    \n\
+ 		}							    \n\
+ 									    \n\
+ 		static inline struct %1$s *				    \n\
+ 		%1$s__open(void)					    \n\
+ 		{							    \n\
+ 			return %1$s__open_opts(NULL);			    \n\
+ 		}							    \n\
+ 									    \n\
+ 		static inline int					    \n\
+ 		%1$s__load(struct %1$s *obj)				    \n\
+ 		{							    \n\
+ 			return bpf_object__load_skeleton(obj->skeleton);    \n\
+ 		}							    \n\
+ 									    \n\
+ 		static inline struct %1$s *				    \n\
+ 		%1$s__open_and_load(void)				    \n\
+ 		{							    \n\
+ 			struct %1$s *obj;				    \n\
+ 									    \n\
+ 			obj = %1$s__open();				    \n\
+ 			if (!obj)					    \n\
+ 				return NULL;				    \n\
+ 			if (%1$s__load(obj)) {				    \n\
+ 				%1$s__destroy(obj);			    \n\
+ 				return NULL;				    \n\
+ 			}						    \n\
+ 			return obj;					    \n\
+ 		}							    \n\
+ 									    \n\
+ 		static inline int					    \n\
+ 		%1$s__attach(struct %1$s *obj)				    \n\
+ 		{							    \n\
+ 			return bpf_object__attach_skeleton(obj->skeleton);  \n\
+ 		}							    \n\
+ 									    \n\
+ 		static inline void					    \n\
+ 		%1$s__detach(struct %1$s *obj)				    \n\
+ 		{							    \n\
+ 			return bpf_object__detach_skeleton(obj->skeleton);  \n\
+ 		}							    \n\
+ 		",
+ 		obj_name
+ 	);
+ 
+ 	codegen("\
+ 		\n\
+ 									    \n\
+ 		static inline int					    \n\
+ 		%1$s__create_skeleton(struct %1$s *obj)			    \n\
++>>>>>>> 7c8dce4b1661 (bpftool: Make skeleton C code compilable with C++ compiler)
  		{							    \n\
  			struct bpf_object_skeleton *s;			    \n\
  									    \n\
- 			s = calloc(1, sizeof(*s));			    \n\
+ 			s = (typeof(s))calloc(1, sizeof(*s));		    \n\
  			if (!s)						    \n\
 -				return -1;				    \n\
 -			obj->skeleton = s;				    \n\
 +				return NULL;				    \n\
  									    \n\
  			s->sz = sizeof(*s);				    \n\
  			s->name = \"%1$s\";				    \n\
@@@ -434,87 -537,39 +516,115 @@@
  	codegen("\
  		\n\
  									    \n\
++<<<<<<< HEAD
 +			return s;					    \n\
++=======
+ 			s->data_sz = %d;				    \n\
+ 			s->data = (void *)\"\\				    \n\
+ 		",
+ 		file_sz);
+ 
+ 	/* embed contents of BPF object file */
+ 	for (i = 0, len = 0; i < file_sz; i++) {
+ 		int w = obj_data[i] ? 4 : 2;
+ 
+ 		len += w;
+ 		if (len > 78) {
+ 			printf("\\\n");
+ 			len = w;
+ 		}
+ 		if (!obj_data[i])
+ 			printf("\\0");
+ 		else
+ 			printf("\\x%02x", (unsigned char)obj_data[i]);
+ 	}
+ 
+ 	codegen("\
+ 		\n\
+ 		\";							    \n\
+ 									    \n\
+ 			return 0;					    \n\
++>>>>>>> 7c8dce4b1661 (bpftool: Make skeleton C code compilable with C++ compiler)
  		err:							    \n\
  			bpf_object__destroy_skeleton(s);		    \n\
 -			return -1;					    \n\
 +			return NULL;					    \n\
 +		}							    \n\
 +									    \n\
 +		static void						    \n\
 +		%1$s__destroy(struct %1$s *obj)				    \n\
 +		{							    \n\
 +			if (!obj)					    \n\
 +				return;					    \n\
 +			if (obj->skeleton)				    \n\
 +				bpf_object__destroy_skeleton(obj->skeleton);\n\
 +			free(obj);					    \n\
  		}							    \n\
  									    \n\
 -		#endif /* %s */						    \n\
 +		static inline struct %1$s *				    \n\
 +		%1$s__open_opts(struct bpf_embed_data *embed, const struct bpf_object_open_opts *opts)\n\
 +		{							    \n\
 +			struct %1$s *obj;				    \n\
 +									    \n\
 +			obj = calloc(1, sizeof(*obj));			    \n\
 +			if (!obj)					    \n\
 +				return NULL;				    \n\
 +									    \n\
 +			obj->skeleton = %1$s__create_skeleton(obj, embed);  \n\
 +			if (!obj->skeleton)				    \n\
 +				goto err;				    \n\
 +									    \n\
 +			if (bpf_object__open_skeleton(obj->skeleton, opts)) \n\
 +				goto err;				    \n\
 +									    \n\
 +			return obj;					    \n\
 +		err:							    \n\
 +			%1$s__destroy(obj);				    \n\
 +			return NULL;					    \n\
 +		}							    \n\
 +									    \n\
 +		static inline struct %1$s *				    \n\
 +		%1$s__open(struct bpf_embed_data *embed)		    \n\
 +		{							    \n\
 +			return %1$s__open_opts(embed, NULL);		    \n\
 +		}							    \n\
 +									    \n\
 +		static inline int					    \n\
 +		%1$s__load(struct %1$s *obj)				    \n\
 +		{							    \n\
 +			return bpf_object__load_skeleton(obj->skeleton);    \n\
 +		}							    \n\
 +									    \n\
 +		static inline struct %1$s *				    \n\
 +		%1$s__open_and_load(struct bpf_embed_data *embed)	    \n\
 +		{							    \n\
 +			struct %1$s *obj;				    \n\
 +									    \n\
 +			obj = %1$s__open(embed);			    \n\
 +			if (!obj)					    \n\
 +				return NULL;				    \n\
 +			if (%1$s__load(obj)) {				    \n\
 +				%1$s__destroy(obj);			    \n\
 +				return NULL;				    \n\
 +			}						    \n\
 +			return obj;					    \n\
 +		}							    \n\
 +									    \n\
 +		static inline int					    \n\
 +		%1$s__attach(struct %1$s *obj)				    \n\
 +		{							    \n\
 +			return bpf_object__attach_skeleton(obj->skeleton);  \n\
 +		}							    \n\
 +									    \n\
 +		static inline void					    \n\
 +		%1$s__detach(struct %1$s *obj)				    \n\
 +		{							    \n\
 +			return bpf_object__detach_skeleton(obj->skeleton);  \n\
 +		}							    \n\
 +									    \n\
 +		#endif /* %2$s */					    \n\
  		",
 -		header_guard);
 +		obj_name, header_guard
 +	);
  	err = 0;
  out:
  	bpf_object__close(obj);
diff --cc tools/testing/selftests/bpf/Makefile
index 1739bffedc44,41691fb067da..000000000000
--- a/tools/testing/selftests/bpf/Makefile
+++ b/tools/testing/selftests/bpf/Makefile
@@@ -276,11 -363,19 +276,23 @@@ $(VERIFIER_TESTS_H): $(VERIFIER_TEST_FI
  	$(shell ( cd verifier/; \
  		  echo '/* Generated header, do not edit */'; \
  		  echo '#ifdef FILL_ARRAY'; \
 -		  ls *.c 2> /dev/null | sed -e 's@\(.*\)@#include \"\1\"@'; \
 +		  ls *.c 2> /dev/null | \
 +			sed -e 's@\(.*\)@#include \"\1\"@'; \
  		  echo '#endif' \
 -		) > verifier/tests.h)
 -$(OUTPUT)/test_verifier: test_verifier.c verifier/tests.h $(BPFOBJ) | $(OUTPUT)
 -	$(call msg,     BINARY,,$@)
 -	$(CC) $(CFLAGS) $(filter %.a %.o %.c,$^) $(LDLIBS) -o $@
 +		 ) > $(VERIFIER_TESTS_H))
  
++<<<<<<< HEAD
 +EXTRA_CLEAN := $(TEST_CUSTOM_PROGS) $(ALU32_BUILD_DIR) $(BPF_GCC_BUILD_DIR) \
 +	$(VERIFIER_TESTS_H) $(PROG_TESTS_H) $(MAP_TESTS_H) \
 +	feature
++=======
+ # Make sure we are able to include and link libbpf against c++.
+ $(OUTPUT)/test_cpp: test_cpp.cpp $(OUTPUT)/test_core_extern.skel.h $(BPFOBJ)
+ 	$(call msg,        CXX,,$@)
+ 	$(CXX) $(CFLAGS) $^ $(LDLIBS) -o $@
+ 
+ EXTRA_CLEAN := $(TEST_CUSTOM_PROGS)					\
+ 	prog_tests/tests.h map_tests/tests.h verifier/tests.h		\
+ 	feature $(OUTPUT)/*.o $(OUTPUT)/no_alu32 $(OUTPUT)/bpf_gcc	\
+ 	tools *.skel.h
++>>>>>>> 7c8dce4b1661 (bpftool: Make skeleton C code compilable with C++ compiler)
* Unmerged path tools/bpf/bpftool/gen.c
diff --git a/tools/lib/bpf/test_libbpf.c b/tools/lib/bpf/test_libbpf.c
index f0eb2727b766..6fe23a10d48a 100644
--- a/tools/lib/bpf/test_libbpf.c
+++ b/tools/lib/bpf/test_libbpf.c
@@ -1,12 +1,16 @@
 /* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */
+#include <iostream>
 #include "libbpf.h"
 #include "bpf.h"
 #include "btf.h"
+#include "test_core_extern.skel.h"
 
 /* do nothing, just make sure we can link successfully */
 
 int main(int argc, char *argv[])
 {
+	struct test_core_extern *skel;
+
 	/* libbpf.h */
 	libbpf_set_print(NULL);
 
@@ -16,5 +20,11 @@ int main(int argc, char *argv[])
 	/* btf.h */
 	btf__new(NULL, 0);
 
+	/* BPF skeleton */
+	skel = test_core_extern__open_and_load();
+	test_core_extern__destroy(skel);
+
+	std::cout << "DONE!" << std::endl;
+
 	return 0;
 }
* Unmerged path tools/testing/selftests/bpf/Makefile
