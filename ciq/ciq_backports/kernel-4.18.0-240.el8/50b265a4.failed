KVM: nVMX: Add helper to handle TLB flushes on nested VM-Enter/VM-Exit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 50b265a4eee0d9fb9581f1a300742515b80dffda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/50b265a4.failed

Add a helper to determine whether or not a full TLB flush needs to be
performed on nested VM-Enter/VM-Exit, as the logic is identical for both
flows and needs a fairly beefy comment to boot.  This also provides a
common point to make future adjustments to the logic.

Handle vpid12 changes the new helper as well even though it is specific
to VM-Enter.  The vpid12 logic is an extension of the flushing logic,
and it's worth the extra bool parameter to provide a single location for
the flushing logic.

	Cc: Liran Alon <liran.alon@oracle.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200320212833.3507-24-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 50b265a4eee0d9fb9581f1a300742515b80dffda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/nested.c
diff --cc arch/x86/kvm/vmx/nested.c
index cd775c31a62d,ba1aedb535ef..000000000000
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@@ -2441,32 -2482,7 +2483,36 @@@ static int prepare_vmcs02(struct kvm_vc
  	if (kvm_has_tsc_control)
  		decache_tsc_multiplier(vmx);
  
++<<<<<<< HEAD
 +	if (enable_vpid) {
 +		/*
 +		 * There is no direct mapping between vpid02 and vpid12, the
 +		 * vpid02 is per-vCPU for L0 and reused while the value of
 +		 * vpid12 is changed w/ one invvpid during nested vmentry.
 +		 * The vpid12 is allocated by L1 for L2, so it will not
 +		 * influence global bitmap(for vpid01 and vpid02 allocation)
 +		 * even if spawn a lot of nested vCPUs.
 +		 */
 +		if (nested_cpu_has_vpid(vmcs12) && nested_has_guest_tlb_tag(vcpu)) {
 +			if (vmcs12->virtual_processor_id != vmx->nested.last_vpid) {
 +				vmx->nested.last_vpid = vmcs12->virtual_processor_id;
 +				vpid_sync_context(nested_get_vpid02(vcpu));
 +			}
 +		} else {
 +			/*
 +			 * If L1 use EPT, then L0 needs to execute INVEPT on
 +			 * EPTP02 instead of EPTP01. Therefore, delay TLB
 +			 * flush until vmcs02->eptp is fully updated by
 +			 * KVM_REQ_LOAD_CR3. Note that this assumes
 +			 * KVM_REQ_TLB_FLUSH is evaluated after
 +			 * KVM_REQ_LOAD_CR3 in vcpu_enter_guest().
 +			 */
 +			kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);
 +		}
 +	}
++=======
+ 	nested_vmx_transition_tlb_flush(vcpu, vmcs12, true);
++>>>>>>> 50b265a4eee0 (KVM: nVMX: Add helper to handle TLB flushes on nested VM-Enter/VM-Exit)
  
  	if (nested_cpu_has_ept(vmcs12))
  		nested_ept_init_mmu_context(vcpu);
@@@ -4034,24 -4050,7 +4080,28 @@@ static void load_vmcs12_host_state(stru
  	if (!enable_ept)
  		vcpu->arch.walk_mmu->inject_page_fault = kvm_inject_page_fault;
  
++<<<<<<< HEAD
 +	/*
 +	 * If vmcs01 doesn't use VPID, CPU flushes TLB on every
 +	 * VMEntry/VMExit. Thus, no need to flush TLB.
 +	 *
 +	 * If vmcs12 doesn't use VPID, L1 expects TLB to be
 +	 * flushed on every VMEntry/VMExit.
 +	 *
 +	 * Otherwise, we can preserve TLB entries as long as we are
 +	 * able to tag L1 TLB entries differently than L2 TLB entries.
 +	 *
 +	 * If vmcs12 uses EPT, we need to execute this flush on EPTP01
 +	 * and therefore we request the TLB flush to happen only after VMCS EPTP
 +	 * has been set by KVM_REQ_LOAD_CR3.
 +	 */
 +	if (enable_vpid &&
 +	    (!nested_cpu_has_vpid(vmcs12) || !nested_has_guest_tlb_tag(vcpu))) {
 +		kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);
 +	}
++=======
+ 	nested_vmx_transition_tlb_flush(vcpu, vmcs12, false);
++>>>>>>> 50b265a4eee0 (KVM: nVMX: Add helper to handle TLB flushes on nested VM-Enter/VM-Exit)
  
  	vmcs_write32(GUEST_SYSENTER_CS, vmcs12->host_ia32_sysenter_cs);
  	vmcs_writel(GUEST_SYSENTER_ESP, vmcs12->host_ia32_sysenter_esp);
* Unmerged path arch/x86/kvm/vmx/nested.c
