perf record: Add a function to test for kernel support for AUX area sampling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 9bca1a4ef5034f0a82861ac0375eb0272c5ce04e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9bca1a4e.failed

Architectures are expected to know if AUX area sampling is supported by
the hardware. Add a function perf_can_aux_sample() which will determine
whether the kernel supports it.

Committer notes:

I reported that this message was taking place on a kernel without the
required bits:

  # perf record --aux-sample -e '{intel_pt//u,branch-misses:u}'
  Error:
  The sys_perf_event_open() syscall returned with 7 (Argument list too long) for event (branch-misses:u).
  /bin/dmesg | grep -i perf may provide additional information.

Adrian sent a patch addressing it, with this explanation:

 ----
  perf_can_aux_sample_size() always returned true because it did not pass
  the attribute size to sys_perf_event_open, nor correctly check the
  return value and errno.
 ----

After applying it I get, later in the series, when --aux-sample is
added:

  # perf record --aux-sample -e '{intel_pt//u,branch-misses:u}'
  AUX area sampling is not supported by kernel

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
Link: http://lore.kernel.org/lkml/20191115124225.5247-4-adrian.hunter@intel.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 9bca1a4ef5034f0a82861ac0375eb0272c5ce04e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/evlist.h
#	tools/perf/util/record.c
diff --cc tools/perf/util/evlist.h
index 49354fe24d5f,3655b9ebb147..000000000000
--- a/tools/perf/util/evlist.h
+++ b/tools/perf/util/evlist.h
@@@ -155,7 -176,8 +155,12 @@@ void perf_evlist__set_id_pos(struct per
  bool perf_can_sample_identifier(void);
  bool perf_can_record_switch_events(void);
  bool perf_can_record_cpu_wide(void);
++<<<<<<< HEAD
 +void perf_evlist__config(struct perf_evlist *evlist, struct record_opts *opts,
++=======
+ bool perf_can_aux_sample(void);
+ void perf_evlist__config(struct evlist *evlist, struct record_opts *opts,
++>>>>>>> 9bca1a4ef503 (perf record: Add a function to test for kernel support for AUX area sampling)
  			 struct callchain_param *callchain);
  int record_opts__config(struct record_opts *opts);
  
diff --cc tools/perf/util/record.c
index 9cfc7bf16531,7def66168503..000000000000
--- a/tools/perf/util/record.c
+++ b/tools/perf/util/record.c
@@@ -132,10 -136,41 +132,45 @@@ bool perf_can_record_cpu_wide(void
  	return true;
  }
  
++<<<<<<< HEAD
 +void perf_evlist__config(struct perf_evlist *evlist, struct record_opts *opts,
++=======
+ /*
+  * Architectures are expected to know if AUX area sampling is supported by the
+  * hardware. Here we check for kernel support.
+  */
+ bool perf_can_aux_sample(void)
+ {
+ 	struct perf_event_attr attr = {
+ 		.size = sizeof(struct perf_event_attr),
+ 		.exclude_kernel = 1,
+ 		/*
+ 		 * Non-zero value causes the kernel to calculate the effective
+ 		 * attribute size up to that byte.
+ 		 */
+ 		.aux_sample_size = 1,
+ 	};
+ 	int fd;
+ 
+ 	fd = sys_perf_event_open(&attr, -1, 0, -1, 0);
+ 	/*
+ 	 * If the kernel attribute is big enough to contain aux_sample_size
+ 	 * then we assume that it is supported. We are relying on the kernel to
+ 	 * validate the attribute size before anything else that could be wrong.
+ 	 */
+ 	if (fd < 0 && errno == E2BIG)
+ 		return false;
+ 	if (fd >= 0)
+ 		close(fd);
+ 
+ 	return true;
+ }
+ 
+ void perf_evlist__config(struct evlist *evlist, struct record_opts *opts,
++>>>>>>> 9bca1a4ef503 (perf record: Add a function to test for kernel support for AUX area sampling)
  			 struct callchain_param *callchain)
  {
 -	struct evsel *evsel;
 +	struct perf_evsel *evsel;
  	bool use_sample_identifier = false;
  	bool use_comm_exec;
  	bool sample_id = opts->sample_id;
* Unmerged path tools/perf/util/evlist.h
* Unmerged path tools/perf/util/record.c
