dm integrity: fix logic bug in integrity tag testing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit 8267d8fb4819afa76b2a54dca48efdda6f0b1910
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8267d8fb.failed

If all the bytes are equal to DISCARD_FILLER, we want to accept the
buffer. If any of the bytes are different, we must do thorough
tag-by-tag checking.

The condition was inverted.

Fixes: 84597a44a9d8 ("dm integrity: add optional discard support")
	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 8267d8fb4819afa76b2a54dca48efdda6f0b1910)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-integrity.c
diff --cc drivers/md/dm-integrity.c
index cb7c54aa4969,4094c47eca7f..000000000000
--- a/drivers/md/dm-integrity.c
+++ b/drivers/md/dm-integrity.c
@@@ -1126,18 -1327,35 +1126,46 @@@ static int dm_integrity_rw_tag(struct d
  		} else if (op == TAG_WRITE) {
  			memcpy(dp, tag, to_copy);
  			dm_bufio_mark_partial_buffer_dirty(b, *metadata_offset, *metadata_offset + to_copy);
 -		} else {
 +		} else  {
  			/* e.g.: op == TAG_CMP */
 +			if (unlikely(memcmp(dp, tag, to_copy))) {
 +				unsigned i;
  
++<<<<<<< HEAD
 +				for (i = 0; i < to_copy; i++) {
 +					if (dp[i] != tag[i])
 +						break;
 +					total_size--;
++=======
+ 			if (likely(is_power_of_2(ic->tag_size))) {
+ 				if (unlikely(memcmp(dp, tag, to_copy)))
+ 					if (unlikely(!ic->discard) ||
+ 					    unlikely(memchr_inv(dp, DISCARD_FILLER, to_copy) != NULL)) {
+ 						goto thorough_test;
+ 				}
+ 			} else {
+ 				unsigned i, ts;
+ thorough_test:
+ 				ts = total_size;
+ 
+ 				for (i = 0; i < to_copy; i++, ts--) {
+ 					if (unlikely(dp[i] != tag[i]))
+ 						may_be &= ~MAY_BE_HASH;
+ 					if (likely(dp[i] != DISCARD_FILLER))
+ 						may_be &= ~MAY_BE_FILLER;
+ 					hash_offset++;
+ 					if (unlikely(hash_offset == ic->tag_size)) {
+ 						if (unlikely(!may_be)) {
+ 							dm_bufio_release(b);
+ 							return ts;
+ 						}
+ 						hash_offset = 0;
+ 						may_be = MAY_BE_HASH | (ic->discard ? MAY_BE_FILLER : 0);
+ 					}
++>>>>>>> 8267d8fb4819 (dm integrity: fix logic bug in integrity tag testing)
  				}
 +				dm_bufio_release(b);
 +				return total_size;
  			}
  		}
  		dm_bufio_release(b);
* Unmerged path drivers/md/dm-integrity.c
