netfilter: nat: don't register device notifier twice

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 46f7487e161b195a1bd7ddbd9c6aba9c93ec881a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/46f7487e.failed

Otherwise, we get notifier list corruption.

This is the most simple fix: remove the device notifier call chain
from the ipv6 masquerade register function and handle it only
in the ipv4 version.

The better fix is merge
nf_nat_masquerade_ipv4/6_(un)register_notifier
  into a single
nf_nat_masquerade_(un)register_notifiers

but to do this its needed to first merge the two masquerade modules
into a single xt_MASQUERADE.

Furthermore, we need to use different refcounts for ipv4/ipv6
until we can merge MASQUERADE.

Fixes: d1aca8ab3104a ("netfilter: nat: merge ipv4 and ipv6 masquerade functionality")
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 46f7487e161b195a1bd7ddbd9c6aba9c93ec881a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
diff --cc net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
index 41327bb99093,d85c4d902e7b..000000000000
--- a/net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
+++ b/net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
@@@ -9,17 -3,16 +9,25 @@@
  #include <linux/types.h>
  #include <linux/atomic.h>
  #include <linux/inetdevice.h>
 +#include <linux/ip.h>
 +#include <linux/timer.h>
  #include <linux/netfilter.h>
 +#include <net/protocol.h>
 +#include <net/ip.h>
 +#include <net/checksum.h>
 +#include <net/route.h>
  #include <linux/netfilter_ipv4.h>
 -#include <linux/netfilter_ipv6.h>
 -
 +#include <linux/netfilter/x_tables.h>
 +#include <net/netfilter/nf_nat.h>
  #include <net/netfilter/ipv4/nf_nat_masquerade.h>
++<<<<<<< HEAD:net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
++=======
+ #include <net/netfilter/ipv6/nf_nat_masquerade.h>
+ 
+ static DEFINE_MUTEX(masq_mutex);
+ static unsigned int masq_refcnt4 __read_mostly;
+ static unsigned int masq_refcnt6 __read_mostly;
++>>>>>>> 46f7487e161b (netfilter: nat: don't register device notifier twice):net/netfilter/nf_nat_masquerade.c
  
  unsigned int
  nf_nat_masquerade_ipv4(struct sk_buff *skb, unsigned int hooknum,
@@@ -194,3 -186,180 +207,183 @@@ out_unlock
  	mutex_unlock(&masq_mutex);
  }
  EXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv4_unregister_notifier);
++<<<<<<< HEAD:net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
++=======
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static atomic_t v6_worker_count __read_mostly;
+ 
+ static int
+ nat_ipv6_dev_get_saddr(struct net *net, const struct net_device *dev,
+ 		       const struct in6_addr *daddr, unsigned int srcprefs,
+ 		       struct in6_addr *saddr)
+ {
+ #ifdef CONFIG_IPV6_MODULE
+ 	const struct nf_ipv6_ops *v6_ops = nf_get_ipv6_ops();
+ 
+ 	if (!v6_ops)
+ 		return -EHOSTUNREACH;
+ 
+ 	return v6_ops->dev_get_saddr(net, dev, daddr, srcprefs, saddr);
+ #else
+ 	return ipv6_dev_get_saddr(net, dev, daddr, srcprefs, saddr);
+ #endif
+ }
+ 
+ unsigned int
+ nf_nat_masquerade_ipv6(struct sk_buff *skb, const struct nf_nat_range2 *range,
+ 		       const struct net_device *out)
+ {
+ 	enum ip_conntrack_info ctinfo;
+ 	struct nf_conn_nat *nat;
+ 	struct in6_addr src;
+ 	struct nf_conn *ct;
+ 	struct nf_nat_range2 newrange;
+ 
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	WARN_ON(!(ct && (ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ||
+ 			 ctinfo == IP_CT_RELATED_REPLY)));
+ 
+ 	if (nat_ipv6_dev_get_saddr(nf_ct_net(ct), out,
+ 				   &ipv6_hdr(skb)->daddr, 0, &src) < 0)
+ 		return NF_DROP;
+ 
+ 	nat = nf_ct_nat_ext_add(ct);
+ 	if (nat)
+ 		nat->masq_index = out->ifindex;
+ 
+ 	newrange.flags		= range->flags | NF_NAT_RANGE_MAP_IPS;
+ 	newrange.min_addr.in6	= src;
+ 	newrange.max_addr.in6	= src;
+ 	newrange.min_proto	= range->min_proto;
+ 	newrange.max_proto	= range->max_proto;
+ 
+ 	return nf_nat_setup_info(ct, &newrange, NF_NAT_MANIP_SRC);
+ }
+ EXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv6);
+ 
+ struct masq_dev_work {
+ 	struct work_struct work;
+ 	struct net *net;
+ 	struct in6_addr addr;
+ 	int ifindex;
+ };
+ 
+ static int inet6_cmp(struct nf_conn *ct, void *work)
+ {
+ 	struct masq_dev_work *w = (struct masq_dev_work *)work;
+ 	struct nf_conntrack_tuple *tuple;
+ 
+ 	if (!device_cmp(ct, (void *)(long)w->ifindex))
+ 		return 0;
+ 
+ 	tuple = &ct->tuplehash[IP_CT_DIR_REPLY].tuple;
+ 
+ 	return ipv6_addr_equal(&w->addr, &tuple->dst.u3.in6);
+ }
+ 
+ static void iterate_cleanup_work(struct work_struct *work)
+ {
+ 	struct masq_dev_work *w;
+ 
+ 	w = container_of(work, struct masq_dev_work, work);
+ 
+ 	nf_ct_iterate_cleanup_net(w->net, inet6_cmp, (void *)w, 0, 0);
+ 
+ 	put_net(w->net);
+ 	kfree(w);
+ 	atomic_dec(&v6_worker_count);
+ 	module_put(THIS_MODULE);
+ }
+ 
+ /* atomic notifier; can't call nf_ct_iterate_cleanup_net (it can sleep).
+  *
+  * Defer it to the system workqueue.
+  *
+  * As we can have 'a lot' of inet_events (depending on amount of ipv6
+  * addresses being deleted), we also need to limit work item queue.
+  */
+ static int masq_inet6_event(struct notifier_block *this,
+ 			    unsigned long event, void *ptr)
+ {
+ 	struct inet6_ifaddr *ifa = ptr;
+ 	const struct net_device *dev;
+ 	struct masq_dev_work *w;
+ 	struct net *net;
+ 
+ 	if (event != NETDEV_DOWN || atomic_read(&v6_worker_count) >= 16)
+ 		return NOTIFY_DONE;
+ 
+ 	dev = ifa->idev->dev;
+ 	net = maybe_get_net(dev_net(dev));
+ 	if (!net)
+ 		return NOTIFY_DONE;
+ 
+ 	if (!try_module_get(THIS_MODULE))
+ 		goto err_module;
+ 
+ 	w = kmalloc(sizeof(*w), GFP_ATOMIC);
+ 	if (w) {
+ 		atomic_inc(&v6_worker_count);
+ 
+ 		INIT_WORK(&w->work, iterate_cleanup_work);
+ 		w->ifindex = dev->ifindex;
+ 		w->net = net;
+ 		w->addr = ifa->addr;
+ 		schedule_work(&w->work);
+ 
+ 		return NOTIFY_DONE;
+ 	}
+ 
+ 	module_put(THIS_MODULE);
+  err_module:
+ 	put_net(net);
+ 	return NOTIFY_DONE;
+ }
+ 
+ static struct notifier_block masq_inet6_notifier = {
+ 	.notifier_call	= masq_inet6_event,
+ };
+ 
+ int nf_nat_masquerade_ipv6_register_notifier(void)
+ {
+ 	int ret = 0;
+ 
+ 	mutex_lock(&masq_mutex);
+ 	if (WARN_ON_ONCE(masq_refcnt6 == UINT_MAX)) {
+ 		ret = -EOVERFLOW;
+ 		goto out_unlock;
+ 	}
+ 
+ 	/* check if the notifier is already set */
+ 	if (++masq_refcnt6 > 1)
+ 		goto out_unlock;
+ 
+ 	ret = register_inet6addr_notifier(&masq_inet6_notifier);
+ 	if (ret)
+ 		goto err_dec;
+ 
+ 	mutex_unlock(&masq_mutex);
+ 	return ret;
+ err_dec:
+ 	masq_refcnt6--;
+ out_unlock:
+ 	mutex_unlock(&masq_mutex);
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv6_register_notifier);
+ 
+ void nf_nat_masquerade_ipv6_unregister_notifier(void)
+ {
+ 	mutex_lock(&masq_mutex);
+ 	/* check if the notifier still has clients */
+ 	if (--masq_refcnt6 > 0)
+ 		goto out_unlock;
+ 
+ 	unregister_inet6addr_notifier(&masq_inet6_notifier);
+ out_unlock:
+ 	mutex_unlock(&masq_mutex);
+ }
+ EXPORT_SYMBOL_GPL(nf_nat_masquerade_ipv6_unregister_notifier);
+ #endif
++>>>>>>> 46f7487e161b (netfilter: nat: don't register device notifier twice):net/netfilter/nf_nat_masquerade.c
* Unmerged path net/ipv4/netfilter/nf_nat_masquerade_ipv4.c
