libbpf: Poison kernel-only integer types

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 1d1a3bcffe360a56fd8cc287ed74d4c3066daf42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/1d1a3bcf.failed

It's been a recurring issue with types like u32 slipping into libbpf source
code accidentally. This is not detected during builds inside kernel source
tree, but becomes a compilation error in libbpf's Github repo. Libbpf is
supposed to use only __{s,u}{8,16,32,64} typedefs, so poison {s,u}{8,16,32,64}
explicitly in every .c file. Doing that in a bit more centralized way, e.g.,
inside libbpf_internal.h breaks selftests, which are both using kernel u32 and
libbpf_internal.h.

This patch also fixes a new u32 occurence in libbpf.c, added recently.

Fixes: 590a00888250 ("bpf: libbpf: Add STRUCT_OPS support")
	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
Link: https://lore.kernel.org/bpf/20200110181916.271446-1-andriin@fb.com
(cherry picked from commit 1d1a3bcffe360a56fd8cc287ed74d4c3066daf42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
diff --cc tools/lib/bpf/libbpf.c
index 3a32419a3814,0c229f00a67e..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -5202,6 -6446,227 +5205,230 @@@ int libbpf_prog_type_by_name(const cha
  	return -ESRCH;
  }
  
++<<<<<<< HEAD
++=======
+ static struct bpf_map *find_struct_ops_map_by_offset(struct bpf_object *obj,
+ 						     size_t offset)
+ {
+ 	struct bpf_map *map;
+ 	size_t i;
+ 
+ 	for (i = 0; i < obj->nr_maps; i++) {
+ 		map = &obj->maps[i];
+ 		if (!bpf_map__is_struct_ops(map))
+ 			continue;
+ 		if (map->sec_offset <= offset &&
+ 		    offset - map->sec_offset < map->def.value_size)
+ 			return map;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ /* Collect the reloc from ELF and populate the st_ops->progs[] */
+ static int bpf_object__collect_struct_ops_map_reloc(struct bpf_object *obj,
+ 						    GElf_Shdr *shdr,
+ 						    Elf_Data *data)
+ {
+ 	const struct btf_member *member;
+ 	struct bpf_struct_ops *st_ops;
+ 	struct bpf_program *prog;
+ 	unsigned int shdr_idx;
+ 	const struct btf *btf;
+ 	struct bpf_map *map;
+ 	Elf_Data *symbols;
+ 	unsigned int moff;
+ 	const char *name;
+ 	__u32 member_idx;
+ 	GElf_Sym sym;
+ 	GElf_Rel rel;
+ 	int i, nrels;
+ 
+ 	symbols = obj->efile.symbols;
+ 	btf = obj->btf;
+ 	nrels = shdr->sh_size / shdr->sh_entsize;
+ 	for (i = 0; i < nrels; i++) {
+ 		if (!gelf_getrel(data, i, &rel)) {
+ 			pr_warn("struct_ops reloc: failed to get %d reloc\n", i);
+ 			return -LIBBPF_ERRNO__FORMAT;
+ 		}
+ 
+ 		if (!gelf_getsym(symbols, GELF_R_SYM(rel.r_info), &sym)) {
+ 			pr_warn("struct_ops reloc: symbol %zx not found\n",
+ 				(size_t)GELF_R_SYM(rel.r_info));
+ 			return -LIBBPF_ERRNO__FORMAT;
+ 		}
+ 
+ 		name = elf_strptr(obj->efile.elf, obj->efile.strtabidx,
+ 				  sym.st_name) ? : "<?>";
+ 		map = find_struct_ops_map_by_offset(obj, rel.r_offset);
+ 		if (!map) {
+ 			pr_warn("struct_ops reloc: cannot find map at rel.r_offset %zu\n",
+ 				(size_t)rel.r_offset);
+ 			return -EINVAL;
+ 		}
+ 
+ 		moff = rel.r_offset - map->sec_offset;
+ 		shdr_idx = sym.st_shndx;
+ 		st_ops = map->st_ops;
+ 		pr_debug("struct_ops reloc %s: for %lld value %lld shdr_idx %u rel.r_offset %zu map->sec_offset %zu name %d (\'%s\')\n",
+ 			 map->name,
+ 			 (long long)(rel.r_info >> 32),
+ 			 (long long)sym.st_value,
+ 			 shdr_idx, (size_t)rel.r_offset,
+ 			 map->sec_offset, sym.st_name, name);
+ 
+ 		if (shdr_idx >= SHN_LORESERVE) {
+ 			pr_warn("struct_ops reloc %s: rel.r_offset %zu shdr_idx %u unsupported non-static function\n",
+ 				map->name, (size_t)rel.r_offset, shdr_idx);
+ 			return -LIBBPF_ERRNO__RELOC;
+ 		}
+ 
+ 		member = find_member_by_offset(st_ops->type, moff * 8);
+ 		if (!member) {
+ 			pr_warn("struct_ops reloc %s: cannot find member at moff %u\n",
+ 				map->name, moff);
+ 			return -EINVAL;
+ 		}
+ 		member_idx = member - btf_members(st_ops->type);
+ 		name = btf__name_by_offset(btf, member->name_off);
+ 
+ 		if (!resolve_func_ptr(btf, member->type, NULL)) {
+ 			pr_warn("struct_ops reloc %s: cannot relocate non func ptr %s\n",
+ 				map->name, name);
+ 			return -EINVAL;
+ 		}
+ 
+ 		prog = bpf_object__find_prog_by_idx(obj, shdr_idx);
+ 		if (!prog) {
+ 			pr_warn("struct_ops reloc %s: cannot find prog at shdr_idx %u to relocate func ptr %s\n",
+ 				map->name, shdr_idx, name);
+ 			return -EINVAL;
+ 		}
+ 
+ 		if (prog->type == BPF_PROG_TYPE_UNSPEC) {
+ 			const struct bpf_sec_def *sec_def;
+ 
+ 			sec_def = find_sec_def(prog->section_name);
+ 			if (sec_def &&
+ 			    sec_def->prog_type != BPF_PROG_TYPE_STRUCT_OPS) {
+ 				/* for pr_warn */
+ 				prog->type = sec_def->prog_type;
+ 				goto invalid_prog;
+ 			}
+ 
+ 			prog->type = BPF_PROG_TYPE_STRUCT_OPS;
+ 			prog->attach_btf_id = st_ops->type_id;
+ 			prog->expected_attach_type = member_idx;
+ 		} else if (prog->type != BPF_PROG_TYPE_STRUCT_OPS ||
+ 			   prog->attach_btf_id != st_ops->type_id ||
+ 			   prog->expected_attach_type != member_idx) {
+ 			goto invalid_prog;
+ 		}
+ 		st_ops->progs[member_idx] = prog;
+ 	}
+ 
+ 	return 0;
+ 
+ invalid_prog:
+ 	pr_warn("struct_ops reloc %s: cannot use prog %s in sec %s with type %u attach_btf_id %u expected_attach_type %u for func ptr %s\n",
+ 		map->name, prog->name, prog->section_name, prog->type,
+ 		prog->attach_btf_id, prog->expected_attach_type, name);
+ 	return -EINVAL;
+ }
+ 
+ #define BTF_PREFIX "btf_trace_"
+ int libbpf_find_vmlinux_btf_id(const char *name,
+ 			       enum bpf_attach_type attach_type)
+ {
+ 	struct btf *btf = bpf_find_kernel_btf();
+ 	char raw_tp_btf[128] = BTF_PREFIX;
+ 	char *dst = raw_tp_btf + sizeof(BTF_PREFIX) - 1;
+ 	const char *btf_name;
+ 	int err = -EINVAL;
+ 	__u32 kind;
+ 
+ 	if (IS_ERR(btf)) {
+ 		pr_warn("vmlinux BTF is not found\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (attach_type == BPF_TRACE_RAW_TP) {
+ 		/* prepend "btf_trace_" prefix per kernel convention */
+ 		strncat(dst, name, sizeof(raw_tp_btf) - sizeof(BTF_PREFIX));
+ 		btf_name = raw_tp_btf;
+ 		kind = BTF_KIND_TYPEDEF;
+ 	} else {
+ 		btf_name = name;
+ 		kind = BTF_KIND_FUNC;
+ 	}
+ 	err = btf__find_by_name_kind(btf, btf_name, kind);
+ 	btf__free(btf);
+ 	return err;
+ }
+ 
+ static int libbpf_find_prog_btf_id(const char *name, __u32 attach_prog_fd)
+ {
+ 	struct bpf_prog_info_linear *info_linear;
+ 	struct bpf_prog_info *info;
+ 	struct btf *btf = NULL;
+ 	int err = -EINVAL;
+ 
+ 	info_linear = bpf_program__get_prog_info_linear(attach_prog_fd, 0);
+ 	if (IS_ERR_OR_NULL(info_linear)) {
+ 		pr_warn("failed get_prog_info_linear for FD %d\n",
+ 			attach_prog_fd);
+ 		return -EINVAL;
+ 	}
+ 	info = &info_linear->info;
+ 	if (!info->btf_id) {
+ 		pr_warn("The target program doesn't have BTF\n");
+ 		goto out;
+ 	}
+ 	if (btf__get_from_id(info->btf_id, &btf)) {
+ 		pr_warn("Failed to get BTF of the program\n");
+ 		goto out;
+ 	}
+ 	err = btf__find_by_name_kind(btf, name, BTF_KIND_FUNC);
+ 	btf__free(btf);
+ 	if (err <= 0) {
+ 		pr_warn("%s is not found in prog's BTF\n", name);
+ 		goto out;
+ 	}
+ out:
+ 	free(info_linear);
+ 	return err;
+ }
+ 
+ static int libbpf_find_attach_btf_id(const char *name,
+ 				     enum bpf_attach_type attach_type,
+ 				     __u32 attach_prog_fd)
+ {
+ 	int i, err;
+ 
+ 	if (!name)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(section_defs); i++) {
+ 		if (!section_defs[i].is_attach_btf)
+ 			continue;
+ 		if (strncmp(name, section_defs[i].sec, section_defs[i].len))
+ 			continue;
+ 		if (attach_prog_fd)
+ 			err = libbpf_find_prog_btf_id(name + section_defs[i].len,
+ 						      attach_prog_fd);
+ 		else
+ 			err = libbpf_find_vmlinux_btf_id(name + section_defs[i].len,
+ 							 attach_type);
+ 		if (err <= 0)
+ 			pr_warn("%s is not found in vmlinux BTF\n", name);
+ 		return err;
+ 	}
+ 	pr_warn("failed to identify btf_id based on ELF section name '%s'\n", name);
+ 	return -ESRCH;
+ }
+ 
++>>>>>>> 1d1a3bcffe36 (libbpf: Poison kernel-only integer types)
  int libbpf_attach_type_by_name(const char *name,
  			       enum bpf_attach_type *attach_type)
  {
diff --git a/tools/lib/bpf/bpf.c b/tools/lib/bpf/bpf.c
index f9124e381f55..3cc2320c3880 100644
--- a/tools/lib/bpf/bpf.c
+++ b/tools/lib/bpf/bpf.c
@@ -32,6 +32,9 @@
 #include "libbpf.h"
 #include "libbpf_internal.h"
 
+/* make sure libbpf doesn't use kernel-only integer typedefs */
+#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64
+
 /*
  * When building perf, unistd.h is overridden. __NR_bpf is
  * required to be defined explicitly.
diff --git a/tools/lib/bpf/bpf_prog_linfo.c b/tools/lib/bpf/bpf_prog_linfo.c
index 3ed1a27b5f7c..bafca49cb1e6 100644
--- a/tools/lib/bpf/bpf_prog_linfo.c
+++ b/tools/lib/bpf/bpf_prog_linfo.c
@@ -8,6 +8,9 @@
 #include "libbpf.h"
 #include "libbpf_internal.h"
 
+/* make sure libbpf doesn't use kernel-only integer typedefs */
+#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64
+
 struct bpf_prog_linfo {
 	void *raw_linfo;
 	void *raw_jited_linfo;
diff --git a/tools/lib/bpf/btf.c b/tools/lib/bpf/btf.c
index 86a1847e4a9f..b1eb8eb9b6e9 100644
--- a/tools/lib/bpf/btf.c
+++ b/tools/lib/bpf/btf.c
@@ -17,6 +17,9 @@
 #include "libbpf_internal.h"
 #include "hashmap.h"
 
+/* make sure libbpf doesn't use kernel-only integer typedefs */
+#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64
+
 #define BTF_MAX_NR_TYPES 0x7fffffff
 #define BTF_MAX_STR_OFFSET 0x7fffffff
 
diff --git a/tools/lib/bpf/btf_dump.c b/tools/lib/bpf/btf_dump.c
index 613a4208127f..d016ca83fa79 100644
--- a/tools/lib/bpf/btf_dump.c
+++ b/tools/lib/bpf/btf_dump.c
@@ -18,6 +18,9 @@
 #include "libbpf.h"
 #include "libbpf_internal.h"
 
+/* make sure libbpf doesn't use kernel-only integer typedefs */
+#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64
+
 static const char PREFIXES[] = "\t\t\t\t\t\t\t\t\t\t\t\t\t";
 static const size_t PREFIX_CNT = sizeof(PREFIXES) - 1;
 
diff --git a/tools/lib/bpf/hashmap.c b/tools/lib/bpf/hashmap.c
index 6122272943e6..54c30c802070 100644
--- a/tools/lib/bpf/hashmap.c
+++ b/tools/lib/bpf/hashmap.c
@@ -12,6 +12,9 @@
 #include <linux/err.h>
 #include "hashmap.h"
 
+/* make sure libbpf doesn't use kernel-only integer typedefs */
+#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64
+
 /* start with 4 buckets */
 #define HASHMAP_MIN_CAP_BITS 2
 
* Unmerged path tools/lib/bpf/libbpf.c
diff --git a/tools/lib/bpf/libbpf_errno.c b/tools/lib/bpf/libbpf_errno.c
index 4343e40588c6..0afb51f7a919 100644
--- a/tools/lib/bpf/libbpf_errno.c
+++ b/tools/lib/bpf/libbpf_errno.c
@@ -13,6 +13,9 @@
 
 #include "libbpf.h"
 
+/* make sure libbpf doesn't use kernel-only integer typedefs */
+#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64
+
 #define ERRNO_OFFSET(e)		((e) - __LIBBPF_ERRNO__START)
 #define ERRCODE_OFFSET(c)	ERRNO_OFFSET(LIBBPF_ERRNO__##c)
 #define NR_ERRNO	(__LIBBPF_ERRNO__END - __LIBBPF_ERRNO__START)
diff --git a/tools/lib/bpf/libbpf_probes.c b/tools/lib/bpf/libbpf_probes.c
index 4b0b0364f5fc..00e97b740173 100644
--- a/tools/lib/bpf/libbpf_probes.c
+++ b/tools/lib/bpf/libbpf_probes.c
@@ -17,6 +17,9 @@
 #include "libbpf.h"
 #include "libbpf_internal.h"
 
+/* make sure libbpf doesn't use kernel-only integer typedefs */
+#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64
+
 static bool grep(const char *buffer, const char *pattern)
 {
 	return !!strstr(buffer, pattern);
diff --git a/tools/lib/bpf/netlink.c b/tools/lib/bpf/netlink.c
index 5065c1aa1061..431bd25c6cdb 100644
--- a/tools/lib/bpf/netlink.c
+++ b/tools/lib/bpf/netlink.c
@@ -15,6 +15,9 @@
 #include "libbpf_internal.h"
 #include "nlattr.h"
 
+/* make sure libbpf doesn't use kernel-only integer typedefs */
+#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64
+
 #ifndef SOL_NETLINK
 #define SOL_NETLINK 270
 #endif
diff --git a/tools/lib/bpf/nlattr.c b/tools/lib/bpf/nlattr.c
index 8db44bbfc66d..0ad41dfea8eb 100644
--- a/tools/lib/bpf/nlattr.c
+++ b/tools/lib/bpf/nlattr.c
@@ -13,6 +13,9 @@
 #include <string.h>
 #include <stdio.h>
 
+/* make sure libbpf doesn't use kernel-only integer typedefs */
+#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64
+
 static uint16_t nla_attr_minlen[LIBBPF_NLA_TYPE_MAX+1] = {
 	[LIBBPF_NLA_U8]		= sizeof(uint8_t),
 	[LIBBPF_NLA_U16]	= sizeof(uint16_t),
diff --git a/tools/lib/bpf/str_error.c b/tools/lib/bpf/str_error.c
index b8064eedc177..146da01979c7 100644
--- a/tools/lib/bpf/str_error.c
+++ b/tools/lib/bpf/str_error.c
@@ -4,6 +4,9 @@
 #include <stdio.h>
 #include "str_error.h"
 
+/* make sure libbpf doesn't use kernel-only integer typedefs */
+#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64
+
 /*
  * Wrapper to allow for building in non-GNU systems such as Alpine Linux's musl
  * libc, while checking strerror_r() return to avoid having to check this in
diff --git a/tools/lib/bpf/xsk.c b/tools/lib/bpf/xsk.c
index 3ef4c3df1d6f..ab905aedde2c 100644
--- a/tools/lib/bpf/xsk.c
+++ b/tools/lib/bpf/xsk.c
@@ -32,6 +32,9 @@
 #include "libbpf_internal.h"
 #include "xsk.h"
 
+/* make sure libbpf doesn't use kernel-only integer typedefs */
+#pragma GCC poison u8 u16 u32 u64 s8 s16 s32 s64
+
 #ifndef SOL_XDP
  #define SOL_XDP 283
 #endif
