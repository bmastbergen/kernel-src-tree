tracing: Use CONFIG_PREEMPTION

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 30c937043b2db09ae3408f5534824f9ececdb581
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/30c93704.failed

CONFIG_PREEMPTION is selected by CONFIG_PREEMPT and by
CONFIG_PREEMPT_RT. Both PREEMPT and PREEMPT_RT require the same
functionality which today depends on CONFIG_PREEMPT.

Switch the conditionals in the tracer over to CONFIG_PREEMPTION.

This is the first step to make the tracer work on RT. The other small
tweaks are submitted separately.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Masami Hiramatsu <mhiramat@kernel.org>
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Paul E. McKenney <paulmck@linux.ibm.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Steven Rostedt <rostedt@goodmis.org>
Link: http://lkml.kernel.org/r/20190726212124.409766323@linutronix.de
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 30c937043b2db09ae3408f5534824f9ececdb581)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/Kconfig
diff --cc kernel/trace/Kconfig
index dcc0166d1997,6a64d7772870..000000000000
--- a/kernel/trace/Kconfig
+++ b/kernel/trace/Kconfig
@@@ -159,8 -179,8 +159,13 @@@ config FUNCTION_GRAPH_TRACE
  config PREEMPTIRQ_EVENTS
  	bool "Enable trace events for preempt and irq disable/enable"
  	select TRACE_IRQFLAGS
++<<<<<<< HEAD
 +	depends on DEBUG_PREEMPT || !PROVE_LOCKING
 +	depends on TRACING
++=======
+ 	select TRACE_PREEMPT_TOGGLE if PREEMPTION
+ 	select GENERIC_TRACER
++>>>>>>> 30c937043b2d (tracing: Use CONFIG_PREEMPTION)
  	default n
  	help
  	  Enable tracing of disable and enable events for preemption and irqs.
* Unmerged path kernel/trace/Kconfig
diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c
index 5769e183957e..817fb17e241b 100644
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@ -2859,7 +2859,7 @@ static int ftrace_shutdown(struct ftrace_ops *ops, int command)
 		 * synchornize_rcu_tasks() will wait for those tasks to
 		 * execute and either schedule voluntarily or enter user space.
 		 */
-		if (IS_ENABLED(CONFIG_PREEMPT))
+		if (IS_ENABLED(CONFIG_PREEMPTION))
 			synchronize_rcu_tasks();
 
  free_ops:
diff --git a/kernel/trace/ring_buffer_benchmark.c b/kernel/trace/ring_buffer_benchmark.c
index 68ee79afe31c..04edbf11e081 100644
--- a/kernel/trace/ring_buffer_benchmark.c
+++ b/kernel/trace/ring_buffer_benchmark.c
@@ -266,7 +266,7 @@ static void ring_buffer_producer(void)
 		if (consumer && !(cnt % wakeup_interval))
 			wake_up_process(consumer);
 
-#ifndef CONFIG_PREEMPT
+#ifndef CONFIG_PREEMPTION
 		/*
 		 * If we are a non preempt kernel, the 10 second run will
 		 * stop everything while it runs. Instead, we will call
diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c
index 808cf29febe2..7e052a5fce39 100644
--- a/kernel/trace/trace_events.c
+++ b/kernel/trace/trace_events.c
@@ -262,12 +262,12 @@ void *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,
 	local_save_flags(fbuffer->flags);
 	fbuffer->pc = preempt_count();
 	/*
-	 * If CONFIG_PREEMPT is enabled, then the tracepoint itself disables
+	 * If CONFIG_PREEMPTION is enabled, then the tracepoint itself disables
 	 * preemption (adding one to the preempt_count). Since we are
 	 * interested in the preempt_count at the time the tracepoint was
 	 * hit, we need to subtract one to offset the increment.
 	 */
-	if (IS_ENABLED(CONFIG_PREEMPT))
+	if (IS_ENABLED(CONFIG_PREEMPTION))
 		fbuffer->pc--;
 	fbuffer->trace_file = trace_file;
 
