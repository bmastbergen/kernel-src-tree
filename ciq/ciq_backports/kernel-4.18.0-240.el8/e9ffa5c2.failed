io_uring: set -EINTR directly when a signal wakes up in io_cqring_wait

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jackie Liu <liuyun01@kylinos.cn>
commit e9ffa5c2b77edf2689f876b640318b16fc3ea2a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e9ffa5c2.failed

We didn't use -ERESTARTSYS to tell the application layer to restart the
system call, but instead return -EINTR. we can set -EINTR directly when
wakeup by the signal, which can help us save an assignment operation and
comparison operation.

	Reviewed-by: Bob Liu <bob.liu@oracle.com>
	Signed-off-by: Jackie Liu <liuyun01@kylinos.cn>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit e9ffa5c2b77edf2689f876b640318b16fc3ea2a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index fca9cdc96d77,a520c4262d85..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -2686,11 -2966,19 +2686,25 @@@ out
  static int io_cqring_wait(struct io_ring_ctx *ctx, int min_events,
  			  const sigset_t __user *sig, size_t sigsz)
  {
++<<<<<<< HEAD
 +	struct io_cq_ring *ring = ctx->cq_ring;
 +	sigset_t ksigmask, sigsaved;
 +	int ret;
++=======
+ 	struct io_wait_queue iowq = {
+ 		.wq = {
+ 			.private	= current,
+ 			.func		= io_wake_function,
+ 			.entry		= LIST_HEAD_INIT(iowq.wq.entry),
+ 		},
+ 		.ctx		= ctx,
+ 		.to_wait	= min_events,
+ 	};
+ 	struct io_rings *rings = ctx->rings;
+ 	int ret = 0;
++>>>>>>> e9ffa5c2b77e (io_uring: set -EINTR directly when a signal wakes up in io_cqring_wait)
  
 -	if (io_cqring_events(rings) >= min_events)
 +	if (io_cqring_events(ring) >= min_events)
  		return 0;
  
  	if (sig) {
@@@ -2707,15 -2994,24 +2721,34 @@@
  			return ret;
  	}
  
++<<<<<<< HEAD
 +	ret = wait_event_interruptible(ctx->wait, io_cqring_events(ring) >= min_events);
 +
 +	if (sig)
 +		restore_user_sigmask(sig, &sigsaved, ret == -ERESTARTSYS);
 +
 +	if (ret == -ERESTARTSYS)
 +		ret = -EINTR;
++=======
+ 	iowq.nr_timeouts = atomic_read(&ctx->cq_timeouts);
+ 	trace_io_uring_cqring_wait(ctx, min_events);
+ 	do {
+ 		prepare_to_wait_exclusive(&ctx->wait, &iowq.wq,
+ 						TASK_INTERRUPTIBLE);
+ 		if (io_should_wake(&iowq))
+ 			break;
+ 		schedule();
+ 		if (signal_pending(current)) {
+ 			ret = -EINTR;
+ 			break;
+ 		}
+ 	} while (1);
+ 	finish_wait(&ctx->wait, &iowq.wq);
+ 
+ 	restore_saved_sigmask_unless(ret == -EINTR);
++>>>>>>> e9ffa5c2b77e (io_uring: set -EINTR directly when a signal wakes up in io_cqring_wait)
  
 -	return READ_ONCE(rings->cq.head) == READ_ONCE(rings->cq.tail) ? ret : 0;
 +	return READ_ONCE(ring->r.head) == READ_ONCE(ring->r.tail) ? ret : 0;
  }
  
  static void __io_sqe_files_unregister(struct io_ring_ctx *ctx)
* Unmerged path fs/io_uring.c
