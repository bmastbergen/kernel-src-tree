Bluetooth: Move {min,max}_key_size debugfs into hci_debugfs_create_le

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] Bluetooth: Move {min, max}_key_size debugfs into hci_debugfs_create_le (Gopal Tiwari) [1838924]
Rebuild_FUZZ: 99.28%
commit-author Marcel Holtmann <marcel@holtmann.org>
commit 18f81241b74fb49d576c83fbbab9a0b6e3bb20d4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/18f81241.failed

The debugfs entries for {min,max}_key_size are created during SMP
registration and thus it might lead to multiple attempts to create the
same entries. Avoid this by moving them to the LE controller init
section.

	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
(cherry picked from commit 18f81241b74fb49d576c83fbbab9a0b6e3bb20d4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/hci_debugfs.c
#	net/bluetooth/smp.c
diff --cc net/bluetooth/hci_debugfs.c
index 0d8ab5b3c177,6b1314c738b8..000000000000
--- a/net/bluetooth/hci_debugfs.c
+++ b/net/bluetooth/hci_debugfs.c
@@@ -926,6 -990,91 +927,94 @@@ static int adv_max_interval_get(void *d
  DEFINE_SIMPLE_ATTRIBUTE(adv_max_interval_fops, adv_max_interval_get,
  			adv_max_interval_set, "%llu\n");
  
++<<<<<<< HEAD
++=======
+ static int min_key_size_set(void *data, u64 val)
+ {
+ 	struct hci_dev *hdev = data;
+ 
+ 	if (val > hdev->le_max_key_size || val < SMP_MIN_ENC_KEY_SIZE)
+ 		return -EINVAL;
+ 
+ 	hci_dev_lock(hdev);
+ 	hdev->le_min_key_size = val;
+ 	hci_dev_unlock(hdev);
+ 
+ 	return 0;
+ }
+ 
+ static int min_key_size_get(void *data, u64 *val)
+ {
+ 	struct hci_dev *hdev = data;
+ 
+ 	hci_dev_lock(hdev);
+ 	*val = hdev->le_min_key_size;
+ 	hci_dev_unlock(hdev);
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_SIMPLE_ATTRIBUTE(min_key_size_fops, min_key_size_get,
+ 			min_key_size_set, "%llu\n");
+ 
+ static int max_key_size_set(void *data, u64 val)
+ {
+ 	struct hci_dev *hdev = data;
+ 
+ 	if (val > SMP_MAX_ENC_KEY_SIZE || val < hdev->le_min_key_size)
+ 		return -EINVAL;
+ 
+ 	hci_dev_lock(hdev);
+ 	hdev->le_max_key_size = val;
+ 	hci_dev_unlock(hdev);
+ 
+ 	return 0;
+ }
+ 
+ static int max_key_size_get(void *data, u64 *val)
+ {
+ 	struct hci_dev *hdev = data;
+ 
+ 	hci_dev_lock(hdev);
+ 	*val = hdev->le_max_key_size;
+ 	hci_dev_unlock(hdev);
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_SIMPLE_ATTRIBUTE(max_key_size_fops, max_key_size_get,
+ 			max_key_size_set, "%llu\n");
+ 
+ static int auth_payload_timeout_set(void *data, u64 val)
+ {
+ 	struct hci_dev *hdev = data;
+ 
+ 	if (val < 0x0001 || val > 0xffff)
+ 		return -EINVAL;
+ 
+ 	hci_dev_lock(hdev);
+ 	hdev->auth_payload_timeout = val;
+ 	hci_dev_unlock(hdev);
+ 
+ 	return 0;
+ }
+ 
+ static int auth_payload_timeout_get(void *data, u64 *val)
+ {
+ 	struct hci_dev *hdev = data;
+ 
+ 	hci_dev_lock(hdev);
+ 	*val = hdev->auth_payload_timeout;
+ 	hci_dev_unlock(hdev);
+ 
+ 	return 0;
+ }
+ 
+ DEFINE_SIMPLE_ATTRIBUTE(auth_payload_timeout_fops,
+ 			auth_payload_timeout_get,
+ 			auth_payload_timeout_set, "%llu\n");
+ 
++>>>>>>> 18f81241b74f (Bluetooth: Move {min,max}_key_size debugfs into hci_debugfs_create_le)
  DEFINE_QUIRK_ATTRIBUTE(quirk_strict_duplicate_filter,
  		       HCI_QUIRK_STRICT_DUPLICATE_FILTER);
  DEFINE_QUIRK_ATTRIBUTE(quirk_simultaneous_discovery,
@@@ -975,6 -1128,12 +1064,15 @@@ void hci_debugfs_create_le(struct hci_d
  			    &adv_max_interval_fops);
  	debugfs_create_u16("discov_interleaved_timeout", 0644, hdev->debugfs,
  			   &hdev->discov_interleaved_timeout);
++<<<<<<< HEAD
++=======
+ 	debugfs_create_file("min_key_size", 0644, hdev->debugfs, hdev,
+ 			    &min_key_size_fops);
+ 	debugfs_create_file("max_key_size", 0644, hdev->debugfs, hdev,
+ 			    &max_key_size_fops);
+ 	debugfs_create_file("auth_payload_timeout", 0644, hdev->debugfs, hdev,
+ 			    &auth_payload_timeout_fops);
++>>>>>>> 18f81241b74f (Bluetooth: Move {min,max}_key_size debugfs into hci_debugfs_create_le)
  
  	debugfs_create_file("quirk_strict_duplicate_filter", 0644,
  			    hdev->debugfs, hdev,
diff --cc net/bluetooth/smp.c
index 5f4c9f8333fd,204f14f8b507..000000000000
--- a/net/bluetooth/smp.c
+++ b/net/bluetooth/smp.c
@@@ -3353,94 -3373,6 +3353,97 @@@ static const struct file_operations for
  	.llseek		= default_llseek,
  };
  
++<<<<<<< HEAD
 +static ssize_t le_min_key_size_read(struct file *file,
 +				     char __user *user_buf,
 +				     size_t count, loff_t *ppos)
 +{
 +	struct hci_dev *hdev = file->private_data;
 +	char buf[4];
 +
 +	snprintf(buf, sizeof(buf), "%2u\n", SMP_DEV(hdev)->min_key_size);
 +
 +	return simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));
 +}
 +
 +static ssize_t le_min_key_size_write(struct file *file,
 +				      const char __user *user_buf,
 +				      size_t count, loff_t *ppos)
 +{
 +	struct hci_dev *hdev = file->private_data;
 +	char buf[32];
 +	size_t buf_size = min(count, (sizeof(buf) - 1));
 +	u8 key_size;
 +
 +	if (copy_from_user(buf, user_buf, buf_size))
 +		return -EFAULT;
 +
 +	buf[buf_size] = '\0';
 +
 +	sscanf(buf, "%hhu", &key_size);
 +
 +	if (key_size > SMP_DEV(hdev)->max_key_size ||
 +	    key_size < SMP_MIN_ENC_KEY_SIZE)
 +		return -EINVAL;
 +
 +	SMP_DEV(hdev)->min_key_size = key_size;
 +
 +	return count;
 +}
 +
 +static const struct file_operations le_min_key_size_fops = {
 +	.open		= simple_open,
 +	.read		= le_min_key_size_read,
 +	.write		= le_min_key_size_write,
 +	.llseek		= default_llseek,
 +};
 +
 +static ssize_t le_max_key_size_read(struct file *file,
 +				     char __user *user_buf,
 +				     size_t count, loff_t *ppos)
 +{
 +	struct hci_dev *hdev = file->private_data;
 +	char buf[4];
 +
 +	snprintf(buf, sizeof(buf), "%2u\n", SMP_DEV(hdev)->max_key_size);
 +
 +	return simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));
 +}
 +
 +static ssize_t le_max_key_size_write(struct file *file,
 +				      const char __user *user_buf,
 +				      size_t count, loff_t *ppos)
 +{
 +	struct hci_dev *hdev = file->private_data;
 +	char buf[32];
 +	size_t buf_size = min(count, (sizeof(buf) - 1));
 +	u8 key_size;
 +
 +	if (copy_from_user(buf, user_buf, buf_size))
 +		return -EFAULT;
 +
 +	buf[buf_size] = '\0';
 +
 +	sscanf(buf, "%hhu", &key_size);
 +
 +	if (key_size > SMP_MAX_ENC_KEY_SIZE ||
 +	    key_size < SMP_DEV(hdev)->min_key_size)
 +		return -EINVAL;
 +
 +	SMP_DEV(hdev)->max_key_size = key_size;
 +
 +	return count;
 +}
 +
 +static const struct file_operations le_max_key_size_fops = {
 +	.open		= simple_open,
 +	.read		= le_max_key_size_read,
 +	.write		= le_max_key_size_write,
 +	.llseek		= default_llseek,
 +};
 +
++=======
++>>>>>>> 18f81241b74f (Bluetooth: Move {min,max}_key_size debugfs into hci_debugfs_create_le)
  int smp_register(struct hci_dev *hdev)
  {
  	struct l2cap_chan *chan;
* Unmerged path net/bluetooth/hci_debugfs.c
* Unmerged path net/bluetooth/smp.c
