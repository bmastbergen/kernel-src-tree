libperf: Add 'struct perf_mmap_param'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit e440979faf6ac8048e1792af383df6af78dd1cb0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e440979f.failed

Add libperf's version of mmap params 'struct perf_mmap_param' object
with the basics: 'prot' and 'mask'.  Encapsulate it in the current
'struct mmap_params' object.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lore.kernel.org/lkml/20191007125344.14268-3-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit e440979faf6ac8048e1792af383df6af78dd1cb0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/lib/include/internal/mmap.h
#	tools/perf/util/evlist.c
#	tools/perf/util/mmap.c
diff --cc tools/perf/util/evlist.c
index 29a998d183ce,3a19a7cb95b1..000000000000
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@@ -769,8 -667,8 +769,13 @@@ static int perf_evlist__mmap_per_evsel(
  		int fd;
  		int cpu;
  
++<<<<<<< HEAD
 +		mp->prot = PROT_READ | PROT_WRITE;
 +		if (evsel->attr.write_backward) {
++=======
+ 		mp->core.prot = PROT_READ | PROT_WRITE;
+ 		if (evsel->core.attr.write_backward) {
++>>>>>>> e440979faf6a (libperf: Add 'struct perf_mmap_param')
  			output = _output_overwrite;
  			maps = evlist->overwrite_mmap;
  
@@@ -782,13 -680,13 +787,13 @@@
  				if (evlist->bkw_mmap_state == BKW_MMAP_NOTREADY)
  					perf_evlist__toggle_bkw_mmap(evlist, BKW_MMAP_RUNNING);
  			}
- 			mp->prot &= ~PROT_WRITE;
+ 			mp->core.prot &= ~PROT_WRITE;
  		}
  
 -		if (evsel->core.system_wide && thread)
 +		if (evsel->system_wide && thread)
  			continue;
  
 -		cpu = perf_cpu_map__idx(evsel->core.cpus, evlist_cpu);
 +		cpu = cpu_map__idx(evsel->cpus, evlist_cpu);
  		if (cpu == -1)
  			continue;
  
@@@ -1023,22 -921,26 +1028,32 @@@ int perf_evlist__mmap_ex(struct perf_ev
  	 * Its value is decided by evsel's write_backward.
  	 * So &mp should not be passed through const pointer.
  	 */
- 	struct mmap_params mp = { .nr_cblocks = nr_cblocks, .affinity = affinity, .flush = flush,
- 				  .comp_level = comp_level };
+ 	struct mmap_params mp = {
+ 		.nr_cblocks	= nr_cblocks,
+ 		.affinity	= affinity,
+ 		.flush		= flush,
+ 		.comp_level	= comp_level
+ 	};
  
  	if (!evlist->mmap)
 -		evlist->mmap = evlist__alloc_mmap(evlist, false);
 +		evlist->mmap = perf_evlist__alloc_mmap(evlist, false);
  	if (!evlist->mmap)
  		return -ENOMEM;
  
 -	if (evlist->core.pollfd.entries == NULL && perf_evlist__alloc_pollfd(&evlist->core) < 0)
 +	if (evlist->pollfd.entries == NULL && perf_evlist__alloc_pollfd(evlist) < 0)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	evlist->mmap_len = perf_evlist__mmap_size(pages);
 +	pr_debug("mmap size %zuB\n", evlist->mmap_len);
 +	mp.mask = evlist->mmap_len - page_size - 1;
++=======
+ 	evlist->core.mmap_len = evlist__mmap_size(pages);
+ 	pr_debug("mmap size %zuB\n", evlist->core.mmap_len);
+ 	mp.core.mask = evlist->core.mmap_len - page_size - 1;
++>>>>>>> e440979faf6a (libperf: Add 'struct perf_mmap_param')
  
 -	auxtrace_mmap_params__init(&mp.auxtrace_mp, evlist->core.mmap_len,
 +	auxtrace_mmap_params__init(&mp.auxtrace_mp, evlist->mmap_len,
  				   auxtrace_pages, auxtrace_overwrite);
  
  	evlist__for_each_entry(evlist, evsel) {
diff --cc tools/perf/util/mmap.c
index 850493205040,a496ced5ed2a..000000000000
--- a/tools/perf/util/mmap.c
+++ b/tools/perf/util/mmap.c
@@@ -364,19 -368,19 +364,26 @@@ int perf_mmap__mmap(struct perf_mmap *m
  	 * evlist layer can't just drop it when filtering events in
  	 * perf_evlist__filter_pollfd().
  	 */
++<<<<<<< HEAD
 +	refcount_set(&map->refcnt, 2);
 +	map->prev = 0;
 +	map->mask = mp->mask;
 +	map->base = mmap(NULL, perf_mmap__mmap_len(map), mp->prot,
++=======
+ 	refcount_set(&map->core.refcnt, 2);
+ 	map->core.prev = 0;
+ 	map->core.mask = mp->core.mask;
+ 	map->core.base = mmap(NULL, perf_mmap__mmap_len(map), mp->core.prot,
++>>>>>>> e440979faf6a (libperf: Add 'struct perf_mmap_param')
  			 MAP_SHARED, fd, 0);
 -	if (map->core.base == MAP_FAILED) {
 +	if (map->base == MAP_FAILED) {
  		pr_debug2("failed to mmap perf event ring buffer, error %d\n",
  			  errno);
 -		map->core.base = NULL;
 +		map->base = NULL;
  		return -1;
  	}
 -	map->core.fd = fd;
 -	map->core.cpu = cpu;
 +	map->fd = fd;
 +	map->cpu = cpu;
  
  	perf_mmap__setup_affinity_mask(map, mp);
  
* Unmerged path tools/perf/lib/include/internal/mmap.h
* Unmerged path tools/perf/lib/include/internal/mmap.h
* Unmerged path tools/perf/util/evlist.c
* Unmerged path tools/perf/util/mmap.c
diff --git a/tools/perf/util/mmap.h b/tools/perf/util/mmap.h
index 274ce389cd84..8853abde1611 100644
--- a/tools/perf/util/mmap.h
+++ b/tools/perf/util/mmap.h
@@ -73,7 +73,8 @@ enum bkw_mmap_state {
 };
 
 struct mmap_params {
-	int prot, mask, nr_cblocks, affinity, flush, comp_level;
+	struct perf_mmap_param core;
+	int nr_cblocks, affinity, flush, comp_level;
 	struct auxtrace_mmap_params auxtrace_mp;
 };
 
