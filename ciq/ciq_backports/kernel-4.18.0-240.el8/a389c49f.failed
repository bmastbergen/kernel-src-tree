drm/i915: Prepare to extract gen specific functions from intel_can_enable_sagv

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
commit a389c49fac556cba82edee7a5724269ec2d28981
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a389c49f.failed

Addressing one of the comments, recommending to extract platform
specific code from intel_can_enable_sagv as a preparation, before
we are going to add support for tgl+.

v2: - Removed whitespace
v3: - Removed premature debug and new cycle introduction(Ville)
    - Added missing no active pipes check(Ville)
v4: - Fixed stupid mistake with plane_state caused by stupid macro change

	Signed-off-by: Stanislav Lisovskiy <stanislav.lisovskiy@intel.com>
	Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200415145740.28241-1-stanislav.lisovskiy@intel.com
(cherry picked from commit a389c49fac556cba82edee7a5724269ec2d28981)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index 8862271193ca,1e7f9be3cb71..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -3744,52 -3757,23 +3744,73 @@@ intel_disable_sagv(struct drm_i915_priv
  	return 0;
  }
  
++<<<<<<< HEAD
 +bool intel_can_enable_sagv(struct drm_atomic_state *state)
 +{
 +	struct drm_device *dev = state->dev;
 +	struct drm_i915_private *dev_priv = to_i915(dev);
 +	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);
 +	struct intel_crtc *crtc;
 +	struct intel_plane *plane;
 +	struct intel_crtc_state *cstate;
 +	enum pipe pipe;
++=======
+ static bool intel_crtc_can_enable_sagv(const struct intel_crtc_state *crtc_state)
+ {
+ 	struct drm_device *dev = crtc_state->uapi.crtc->dev;
+ 	struct drm_i915_private *dev_priv = to_i915(dev);
+ 	struct intel_crtc *crtc = to_intel_crtc(crtc_state->uapi.crtc);
+ 	struct intel_plane *plane;
++>>>>>>> a389c49fac55 (drm/i915: Prepare to extract gen specific functions from intel_can_enable_sagv)
  	int level, latency;
 +	int sagv_block_time_us;
 +
++<<<<<<< HEAD
 +	if (!intel_has_sagv(dev_priv))
 +		return false;
 +
 +	if (IS_GEN(dev_priv, 9))
 +		sagv_block_time_us = 30;
 +	else if (IS_GEN(dev_priv, 10))
 +		sagv_block_time_us = 20;
 +	else
 +		sagv_block_time_us = 10;
 +
 +	/*
 +	 * If there are no active CRTCs, no additional checks need be performed
 +	 */
 +	if (hweight32(intel_state->active_crtcs) == 0)
 +		return true;
 +
 +	/*
 +	 * SKL+ workaround: bspec recommends we disable SAGV when we have
 +	 * more then one pipe enabled
 +	 */
 +	if (hweight32(intel_state->active_crtcs) > 1)
 +		return false;
 +
 +	/* Since we're now guaranteed to only have one active CRTC... */
 +	pipe = ffs(intel_state->active_crtcs) - 1;
 +	crtc = intel_get_crtc_for_pipe(dev_priv, pipe);
 +	cstate = to_intel_crtc_state(crtc->base.state);
 +
 +	if (crtc->base.state->adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)
 +		return false;
  
 +	for_each_intel_plane_on_crtc(dev, crtc, plane) {
 +		struct skl_plane_wm *wm =
 +			&cstate->wm.skl.optimal.planes[plane->id];
++=======
+ 	if (!crtc_state->hw.active)
+ 		return true;
+ 
+ 	if (crtc_state->hw.adjusted_mode.flags & DRM_MODE_FLAG_INTERLACE)
+ 		return false;
+ 
+ 	for_each_intel_plane_on_crtc(dev, crtc, plane) {
+ 		const struct skl_plane_wm *wm =
+ 			&crtc_state->wm.skl.optimal.planes[plane->id];
++>>>>>>> a389c49fac55 (drm/i915: Prepare to extract gen specific functions from intel_can_enable_sagv)
  
  		/* Skip this plane if it's not enabled */
  		if (!wm->wm[0].plane_en)
@@@ -3819,17 -3803,63 +3840,73 @@@
  	return true;
  }
  
++<<<<<<< HEAD
 +static u16 intel_get_ddb_size(struct drm_i915_private *dev_priv,
 +			      const struct intel_crtc_state *cstate,
 +			      const u64 total_data_rate,
 +			      const int num_active,
 +			      struct skl_ddb_allocation *ddb)
++=======
+ bool intel_can_enable_sagv(struct intel_atomic_state *state)
+ {
+ 	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
+ 	struct intel_crtc *crtc;
+ 	const struct intel_crtc_state *crtc_state;
+ 	enum pipe pipe;
+ 
+ 	if (!intel_has_sagv(dev_priv))
+ 		return false;
+ 
+ 	/*
+ 	 * If there are no active CRTCs, no additional checks need be performed
+ 	 */
+ 	if (hweight8(state->active_pipes) == 0)
+ 		return true;
+ 
+ 	/*
+ 	 * SKL+ workaround: bspec recommends we disable SAGV when we have
+ 	 * more then one pipe enabled
+ 	 */
+ 	if (hweight8(state->active_pipes) > 1)
+ 		return false;
+ 
+ 	/* Since we're now guaranteed to only have one active CRTC... */
+ 	pipe = ffs(state->active_pipes) - 1;
+ 	crtc = intel_get_crtc_for_pipe(dev_priv, pipe);
+ 	crtc_state = to_intel_crtc_state(crtc->base.state);
+ 
+ 	return intel_crtc_can_enable_sagv(crtc_state);
+ }
+ 
+ /*
+  * Calculate initial DBuf slice offset, based on slice size
+  * and mask(i.e if slice size is 1024 and second slice is enabled
+  * offset would be 1024)
+  */
+ static unsigned int
+ icl_get_first_dbuf_slice_offset(u32 dbuf_slice_mask,
+ 				u32 slice_size,
+ 				u32 ddb_size)
+ {
+ 	unsigned int offset = 0;
+ 
+ 	if (!dbuf_slice_mask)
+ 		return 0;
+ 
+ 	offset = (ffs(dbuf_slice_mask) - 1) * slice_size;
+ 
+ 	WARN_ON(offset >= ddb_size);
+ 	return offset;
+ }
+ 
+ static u16 intel_get_ddb_size(struct drm_i915_private *dev_priv)
++>>>>>>> a389c49fac55 (drm/i915: Prepare to extract gen specific functions from intel_can_enable_sagv)
  {
 +	const struct drm_display_mode *adjusted_mode;
 +	u64 total_data_bw;
  	u16 ddb_size = INTEL_INFO(dev_priv)->ddb_size;
  
 -	drm_WARN_ON(&dev_priv->drm, ddb_size == 0);
 +	WARN_ON(ddb_size == 0);
  
  	if (INTEL_GEN(dev_priv) < 11)
  		return ddb_size - 4; /* 4 blocks for bypass path allocation */
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
