libperf: Move 'system_wide' from 'struct evsel' to 'struct perf_evsel'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit 648b5af3f3ae7f4fad7395c8dc84cb79eafe2ba9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/648b5af3.failed

Move the 'system_wide 'member from perf's evsel to libperf's perf_evsel.

Committer notes:

Added stdbool.h as we now use bool here.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lore.kernel.org/lkml/20190913132355.21634-20-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 648b5af3f3ae7f4fad7395c8dc84cb79eafe2ba9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/lib/include/internal/evsel.h
#	tools/perf/util/evlist.c
#	tools/perf/util/evsel.c
#	tools/perf/util/parse-events.c
diff --cc tools/perf/util/evlist.c
index 29a998d183ce,16866533745c..000000000000
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@@ -338,23 -316,23 +338,23 @@@ int perf_evlist__add_newtp(struct perf_
  	return 0;
  }
  
 -static int perf_evlist__nr_threads(struct evlist *evlist,
 -				   struct evsel *evsel)
 +static int perf_evlist__nr_threads(struct perf_evlist *evlist,
 +				   struct perf_evsel *evsel)
  {
- 	if (evsel->system_wide)
+ 	if (evsel->core.system_wide)
  		return 1;
  	else
 -		return perf_thread_map__nr(evlist->core.threads);
 +		return thread_map__nr(evlist->threads);
  }
  
 -void evlist__disable(struct evlist *evlist)
 +void perf_evlist__disable(struct perf_evlist *evlist)
  {
 -	struct evsel *pos;
 +	struct perf_evsel *pos;
  
  	evlist__for_each_entry(evlist, pos) {
 -		if (pos->disabled || !perf_evsel__is_group_leader(pos) || !pos->core.fd)
 +		if (pos->disabled || !perf_evsel__is_group_leader(pos) || !pos->fd)
  			continue;
 -		evsel__disable(pos);
 +		perf_evsel__disable(pos);
  	}
  
  	evlist->enabled = false;
@@@ -424,15 -402,15 +424,15 @@@ int perf_evlist__enable_event_idx(struc
  		return perf_evlist__enable_event_thread(evlist, evsel, idx);
  }
  
 -int perf_evlist__alloc_pollfd(struct evlist *evlist)
 +int perf_evlist__alloc_pollfd(struct perf_evlist *evlist)
  {
 -	int nr_cpus = perf_cpu_map__nr(evlist->core.cpus);
 -	int nr_threads = perf_thread_map__nr(evlist->core.threads);
 +	int nr_cpus = cpu_map__nr(evlist->cpus);
 +	int nr_threads = thread_map__nr(evlist->threads);
  	int nfds = 0;
 -	struct evsel *evsel;
 +	struct perf_evsel *evsel;
  
  	evlist__for_each_entry(evlist, evsel) {
- 		if (evsel->system_wide)
+ 		if (evsel->core.system_wide)
  			nfds += nr_cpus;
  		else
  			nfds += nr_cpus * nr_threads;
@@@ -554,12 -532,12 +554,17 @@@ static void perf_evlist__set_sid_idx(st
  {
  	struct perf_sample_id *sid = SID(evsel, cpu, thread);
  	sid->idx = idx;
 -	if (evlist->core.cpus && cpu >= 0)
 -		sid->cpu = evlist->core.cpus->map[cpu];
 +	if (evlist->cpus && cpu >= 0)
 +		sid->cpu = evlist->cpus->map[cpu];
  	else
  		sid->cpu = -1;
++<<<<<<< HEAD
 +	if (!evsel->system_wide && evlist->threads && thread >= 0)
 +		sid->tid = thread_map__pid(evlist->threads, thread);
++=======
+ 	if (!evsel->core.system_wide && evlist->core.threads && thread >= 0)
+ 		sid->tid = perf_thread_map__pid(evlist->core.threads, thread);
++>>>>>>> 648b5af3f3ae (libperf: Move 'system_wide' from 'struct evsel' to 'struct perf_evsel')
  	else
  		sid->tid = -1;
  }
@@@ -785,10 -763,10 +790,10 @@@ static int perf_evlist__mmap_per_evsel(
  			mp->prot &= ~PROT_WRITE;
  		}
  
- 		if (evsel->system_wide && thread)
+ 		if (evsel->core.system_wide && thread)
  			continue;
  
 -		cpu = perf_cpu_map__idx(evsel->core.cpus, evlist_cpu);
 +		cpu = cpu_map__idx(evsel->cpus, evlist_cpu);
  		if (cpu == -1)
  			continue;
  
diff --cc tools/perf/util/evsel.c
index 90bfc2303a40,566c9413246c..000000000000
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@@ -1912,8 -1819,8 +1912,13 @@@ retry_sample_id
  		for (thread = 0; thread < nthreads; thread++) {
  			int fd, group_fd;
  
++<<<<<<< HEAD
 +			if (!evsel->cgrp && !evsel->system_wide)
 +				pid = thread_map__pid(threads, thread);
++=======
+ 			if (!evsel->cgrp && !evsel->core.system_wide)
+ 				pid = perf_thread_map__pid(threads, thread);
++>>>>>>> 648b5af3f3ae (libperf: Move 'system_wide' from 'struct evsel' to 'struct perf_evsel')
  
  			group_fd = get_group_fd(evsel, cpu, thread);
  retry_open:
diff --cc tools/perf/util/parse-events.c
index 5941be0e92cc,d7aebe9b005d..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -331,9 -333,9 +331,15 @@@ __add_event(struct list_head *list, in
  		return NULL;
  
  	(*idx)++;
++<<<<<<< HEAD
 +	evsel->cpus        = cpu_map__get(cpus);
 +	evsel->own_cpus    = cpu_map__get(cpus);
 +	evsel->system_wide = pmu ? pmu->is_uncore : false;
++=======
+ 	evsel->core.cpus   = perf_cpu_map__get(cpus);
+ 	evsel->core.own_cpus = perf_cpu_map__get(cpus);
+ 	evsel->core.system_wide = pmu ? pmu->is_uncore : false;
++>>>>>>> 648b5af3f3ae (libperf: Move 'system_wide' from 'struct evsel' to 'struct perf_evsel')
  	evsel->auto_merge_stats = auto_merge_stats;
  
  	if (name)
* Unmerged path tools/perf/lib/include/internal/evsel.h
diff --git a/tools/perf/arch/x86/util/intel-pt.c b/tools/perf/arch/x86/util/intel-pt.c
index 3a851647e6f4..44ca95f5fa78 100644
--- a/tools/perf/arch/x86/util/intel-pt.c
+++ b/tools/perf/arch/x86/util/intel-pt.c
@@ -428,7 +428,7 @@ static int intel_pt_track_switches(struct perf_evlist *evlist)
 	perf_evsel__set_sample_bit(evsel, CPU);
 	perf_evsel__set_sample_bit(evsel, TIME);
 
-	evsel->system_wide = true;
+	evsel->core.system_wide = true;
 	evsel->no_aux_samples = true;
 	evsel->immediate = true;
 
@@ -706,7 +706,7 @@ static int intel_pt_recording_options(struct auxtrace_record *itr,
 				switch_evsel->attr.sample_period = 1;
 				switch_evsel->attr.context_switch = 1;
 
-				switch_evsel->system_wide = true;
+				switch_evsel->core.system_wide = true;
 				switch_evsel->no_aux_samples = true;
 				switch_evsel->immediate = true;
 
diff --git a/tools/perf/builtin-script.c b/tools/perf/builtin-script.c
index 315e8eb7f02d..24d4db52c773 100644
--- a/tools/perf/builtin-script.c
+++ b/tools/perf/builtin-script.c
@@ -1908,7 +1908,7 @@ static void __process_stat(struct perf_evsel *counter, u64 tstamp)
 	int cpu, thread;
 	static int header_printed;
 
-	if (counter->system_wide)
+	if (counter->core.system_wide)
 		nthreads = 1;
 
 	if (!header_printed) {
diff --git a/tools/perf/builtin-stat.c b/tools/perf/builtin-stat.c
index 2d9bd49f24d6..b0d505aa5022 100644
--- a/tools/perf/builtin-stat.c
+++ b/tools/perf/builtin-stat.c
@@ -276,7 +276,7 @@ static int read_counter(struct perf_evsel *counter, struct timespec *rs)
 	if (!counter->supported)
 		return -ENOENT;
 
-	if (counter->system_wide)
+	if (counter->core.system_wide)
 		nthreads = 1;
 
 	for (thread = 0; thread < nthreads; thread++) {
@@ -1681,7 +1681,7 @@ static void setup_system_wide(int forks)
 		struct perf_evsel *counter;
 
 		evlist__for_each_entry(evsel_list, counter) {
-			if (!counter->system_wide)
+			if (!counter->core.system_wide)
 				return;
 		}
 
* Unmerged path tools/perf/lib/include/internal/evsel.h
diff --git a/tools/perf/tests/switch-tracking.c b/tools/perf/tests/switch-tracking.c
index 6cdab5f4812a..bdebd8ca0abd 100644
--- a/tools/perf/tests/switch-tracking.c
+++ b/tools/perf/tests/switch-tracking.c
@@ -139,7 +139,7 @@ static int process_sample_event(struct perf_evlist *evlist,
 			return err;
 		/*
 		 * Check for no missing sched_switch events i.e. that the
-		 * evsel->system_wide flag has worked.
+		 * evsel->core.system_wide flag has worked.
 		 */
 		if (switch_tracking->tids[cpu] != -1 &&
 		    switch_tracking->tids[cpu] != prev_tid) {
@@ -311,7 +311,7 @@ static int process_events(struct perf_evlist *evlist,
  *
  * This function implements a test that checks that sched_switch events and
  * tracking events can be recorded for a workload (current process) using the
- * evsel->system_wide and evsel->tracking flags (respectively) with other events
+ * evsel->core.system_wide and evsel->tracking flags (respectively) with other events
  * sometimes enabled or disabled.
  */
 int test__switch_tracking(struct test *test __maybe_unused, int subtest __maybe_unused)
@@ -391,7 +391,7 @@ int test__switch_tracking(struct test *test __maybe_unused, int subtest __maybe_
 	perf_evsel__set_sample_bit(switch_evsel, CPU);
 	perf_evsel__set_sample_bit(switch_evsel, TIME);
 
-	switch_evsel->system_wide = true;
+	switch_evsel->core.system_wide = true;
 	switch_evsel->no_aux_samples = true;
 	switch_evsel->immediate = true;
 
* Unmerged path tools/perf/util/evlist.c
* Unmerged path tools/perf/util/evsel.c
diff --git a/tools/perf/util/evsel.h b/tools/perf/util/evsel.h
index fe84f1536094..701f365fb674 100644
--- a/tools/perf/util/evsel.h
+++ b/tools/perf/util/evsel.h
@@ -140,7 +140,6 @@ struct perf_evsel {
 	bool 			disabled;
 	bool			no_aux_samples;
 	bool			immediate;
-	bool			system_wide;
 	bool			tracking;
 	bool			per_pkg;
 	bool			precise_max;
* Unmerged path tools/perf/util/parse-events.c
diff --git a/tools/perf/util/stat.c b/tools/perf/util/stat.c
index 9b8d699cb791..464c242e6837 100644
--- a/tools/perf/util/stat.c
+++ b/tools/perf/util/stat.c
@@ -313,7 +313,7 @@ static int process_counter_maps(struct perf_stat_config *config,
 	int ncpus = perf_evsel__nr_cpus(counter);
 	int cpu, thread;
 
-	if (counter->system_wide)
+	if (counter->core.system_wide)
 		nthreads = 1;
 
 	for (thread = 0; thread < nthreads; thread++) {
