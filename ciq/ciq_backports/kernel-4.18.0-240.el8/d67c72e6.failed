ceph: request expedited service on session's last cap flush

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jeff Layton <jlayton@kernel.org>
commit d67c72e6cce99eab5ab9d62c599e33e5141ff8b4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d67c72e6.failed

When flushing a lot of caps to the MDS's at once (e.g. for syncfs),
we can end up waiting a substantial amount of time for MDS replies, due
to the fact that it may delay some of them so that it can batch them up
together in a single journal transaction. This can lead to stalls when
calling sync or syncfs.

What we'd really like to do is request expedited service on the _last_
cap we're flushing back to the server. If the CHECK_CAPS_FLUSH flag is
set on the request and the current inode was the last one on the
session->s_cap_dirty list, then mark the request with
CEPH_CLIENT_CAPS_SYNC.

Note that this heuristic is not perfect. New inodes can race onto the
list after we've started flushing, but it does seem to fix some common
use cases.

URL: https://tracker.ceph.com/issues/44744
	Reported-by: Jan Fajerski <jfajerski@suse.com>
	Signed-off-by: Jeff Layton <jlayton@kernel.org>
	Reviewed-by: "Yan, Zheng" <zyan@redhat.com>
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
(cherry picked from commit d67c72e6cce99eab5ab9d62c599e33e5141ff8b4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/caps.c
diff --cc fs/ceph/caps.c
index 2055ce309d44,2558fd14126a..000000000000
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@@ -2008,6 -1997,9 +2008,12 @@@ retry_locked
  	}
  
  	for (p = rb_first(&ci->i_caps); p; p = rb_next(p)) {
++<<<<<<< HEAD
++=======
+ 		int mflags = 0;
+ 		struct cap_msg_args arg;
+ 
++>>>>>>> d67c72e6cce9 (ceph: request expedited service on session's last cap flush)
  		cap = rb_entry(p, struct ceph_cap, ci_node);
  
  		/* avoid looping forever */
@@@ -2161,12 -2141,13 +2170,21 @@@ ack
  		}
  
  		mds = cap->mds;  /* remember mds, so we don't repeat */
 -
 +		sent++;
 +
++<<<<<<< HEAD
 +		/* __send_cap drops i_ceph_lock */
 +		delayed += __send_cap(mdsc, cap, CEPH_CAP_OP_UPDATE, 0,
 +				cap_used, want, retain, flushing,
 +				flush_tid, oldest_flush_tid);
++=======
+ 		__prep_cap(&arg, cap, CEPH_CAP_OP_UPDATE, mflags, cap_used,
+ 			   want, retain, flushing, flush_tid, oldest_flush_tid);
+ 		spin_unlock(&ci->i_ceph_lock);
+ 
+ 		__send_cap(mdsc, &arg, ci);
+ 
++>>>>>>> d67c72e6cce9 (ceph: request expedited service on session's last cap flush)
  		goto retry; /* retake i_ceph_lock and restart our cap scan. */
  	}
  
* Unmerged path fs/ceph/caps.c
