netfilter: nf_tables: merge ipv4 and ipv6 nat chain types

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit db8ab38880e06dedbfc879e75f5b0ddc495f4eb6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/db8ab388.failed

Merge the ipv4 and ipv6 nat chain type. This is the last
missing piece which allows to provide inet family support
for nat in a follow patch.

The kconfig knobs for ipv4/ipv6 nat chain are removed, the
nat chain type will be built unconditionally if NFT_NAT
expression is enabled.

Before:
   text	   data	    bss	    dec	    hex	filename
   1576     896       0    2472     9a8 nft_chain_nat_ipv4.ko
   1697     896       0    2593     a21 nft_chain_nat_ipv6.ko

After:
   text	   data	    bss	    dec	    hex	filename
   1832     896       0    2728     aa8 nft_chain_nat.ko

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit db8ab38880e06dedbfc879e75f5b0ddc495f4eb6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/Kconfig
#	net/ipv4/netfilter/nft_chain_nat_ipv4.c
#	net/ipv6/netfilter/Kconfig
#	net/ipv6/netfilter/nft_chain_nat_ipv6.c
diff --cc net/ipv4/netfilter/Kconfig
index d7ecae5e93ea,c98391d49200..000000000000
--- a/net/ipv4/netfilter/Kconfig
+++ b/net/ipv4/netfilter/Kconfig
@@@ -110,50 -94,7 +110,54 @@@ config NF_REJECT_IPV
  	tristate "IPv4 packet rejection"
  	default m if NETFILTER_ADVANCED=n
  
++<<<<<<< HEAD
 +config NF_NAT_IPV4
 +	tristate "IPv4 NAT"
 +	depends on NF_CONNTRACK_IPV4
 +	default m if NETFILTER_ADVANCED=n
 +	select NF_NAT
 +	help
 +	  The IPv4 NAT option allows masquerading, port forwarding and other
 +	  forms of full Network Address Port Translation. This can be
 +	  controlled by iptables or nft.
 +
 +if NF_NAT_IPV4
 +
 +config NF_NAT_MASQUERADE_IPV4
 +	bool
 +
 +if NF_TABLES
 +config NFT_CHAIN_NAT_IPV4
 +	depends on NF_TABLES_IPV4
 +	tristate "IPv4 nf_tables nat chain support"
 +	help
 +	  This option enables the "nat" chain for IPv4 in nf_tables. This
 +	  chain type is used to perform Network Address Translation (NAT)
 +	  packet transformations such as the source, destination address and
 +	  source and destination ports.
 +
 +config NFT_MASQ_IPV4
 +	tristate "IPv4 masquerading support for nf_tables"
 +	depends on NF_TABLES_IPV4
 +	depends on NFT_MASQ
 +	select NF_NAT_MASQUERADE_IPV4
 +	help
 +	  This is the expression that provides IPv4 masquerading support for
 +	  nf_tables.
 +
 +config NFT_REDIR_IPV4
 +	tristate "IPv4 redirect support for nf_tables"
 +	depends on NF_TABLES_IPV4
 +	depends on NFT_REDIR
 +	select NF_NAT_REDIRECT
 +	help
 +	  This is the expression that provides IPv4 redirect support for
 +	  nf_tables.
 +endif # NF_TABLES
 +
++=======
+ if NF_NAT
++>>>>>>> db8ab38880e0 (netfilter: nf_tables: merge ipv4 and ipv6 nat chain types)
  config NF_NAT_SNMP_BASIC
  	tristate "Basic SNMP-ALG support"
  	depends on NF_CONNTRACK_SNMP
diff --cc net/ipv6/netfilter/Kconfig
index fd93b5a5e481,ddc99a1653aa..000000000000
--- a/net/ipv6/netfilter/Kconfig
+++ b/net/ipv6/netfilter/Kconfig
@@@ -51,34 -31,6 +51,37 @@@ config NFT_CHAIN_ROUTE_IPV
  	  fields such as the source, destination, flowlabel, hop-limit and
  	  the packet mark.
  
++<<<<<<< HEAD
 +if NF_NAT_IPV6
 +
 +config NFT_CHAIN_NAT_IPV6
 +	tristate "IPv6 nf_tables nat chain support"
 +	help
 +	  This option enables the "nat" chain for IPv6 in nf_tables. This
 +	  chain type is used to perform Network Address Translation (NAT)
 +	  packet transformations such as the source, destination address and
 +	  source and destination ports.
 +
 +config NFT_MASQ_IPV6
 +	tristate "IPv6 masquerade support for nf_tables"
 +	depends on NFT_MASQ
 +	select NF_NAT_MASQUERADE_IPV6
 +	help
 +	  This is the expression that provides IPv4 masquerading support for
 +	  nf_tables.
 +
 +config NFT_REDIR_IPV6
 +	tristate "IPv6 redirect support for nf_tables"
 +	depends on NFT_REDIR
 +	select NF_NAT_REDIRECT
 +	help
 +	  This is the expression that provides IPv4 redirect support for
 +	  nf_tables.
 +
 +endif # NF_NAT_IPV6
 +
++=======
++>>>>>>> db8ab38880e0 (netfilter: nf_tables: merge ipv4 and ipv6 nat chain types)
  config NFT_REJECT_IPV6
  	select NF_REJECT_IPV6
  	default NFT_REJECT
* Unmerged path net/ipv4/netfilter/nft_chain_nat_ipv4.c
* Unmerged path net/ipv6/netfilter/nft_chain_nat_ipv6.c
* Unmerged path net/ipv4/netfilter/Kconfig
diff --git a/net/ipv4/netfilter/Makefile b/net/ipv4/netfilter/Makefile
index 8394c17c269f..5038f9ee68f5 100644
--- a/net/ipv4/netfilter/Makefile
+++ b/net/ipv4/netfilter/Makefile
@@ -38,7 +38,6 @@ obj-$(CONFIG_NF_NAT_SNMP_BASIC) += nf_nat_snmp_basic.o
 obj-$(CONFIG_NF_NAT_PROTO_GRE) += nf_nat_proto_gre.o
 
 obj-$(CONFIG_NFT_CHAIN_ROUTE_IPV4) += nft_chain_route_ipv4.o
-obj-$(CONFIG_NFT_CHAIN_NAT_IPV4) += nft_chain_nat_ipv4.o
 obj-$(CONFIG_NFT_REJECT_IPV4) += nft_reject_ipv4.o
 obj-$(CONFIG_NFT_FIB_IPV4) += nft_fib_ipv4.o
 obj-$(CONFIG_NFT_MASQ_IPV4) += nft_masq_ipv4.o
* Unmerged path net/ipv4/netfilter/nft_chain_nat_ipv4.c
* Unmerged path net/ipv6/netfilter/Kconfig
diff --git a/net/ipv6/netfilter/Makefile b/net/ipv6/netfilter/Makefile
index 10a5a1c87320..6372ffd2af76 100644
--- a/net/ipv6/netfilter/Makefile
+++ b/net/ipv6/netfilter/Makefile
@@ -38,7 +38,6 @@ obj-$(CONFIG_NF_DUP_IPV6) += nf_dup_ipv6.o
 
 # nf_tables
 obj-$(CONFIG_NFT_CHAIN_ROUTE_IPV6) += nft_chain_route_ipv6.o
-obj-$(CONFIG_NFT_CHAIN_NAT_IPV6) += nft_chain_nat_ipv6.o
 obj-$(CONFIG_NFT_REJECT_IPV6) += nft_reject_ipv6.o
 obj-$(CONFIG_NFT_MASQ_IPV6) += nft_masq_ipv6.o
 obj-$(CONFIG_NFT_REDIR_IPV6) += nft_redir_ipv6.o
* Unmerged path net/ipv6/netfilter/nft_chain_nat_ipv6.c
diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
index 0afbf3b2f362..d59a95e65805 100644
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -546,6 +546,7 @@ config NFT_REDIR
 config NFT_NAT
 	depends on NF_CONNTRACK
 	select NF_NAT
+	depends on NF_TABLES_IPV4 || NF_TABLES_IPV6
 	tristate "Netfilter nf_tables nat module"
 	help
 	  This option adds the "nat" expression that you can use to perform
diff --git a/net/netfilter/Makefile b/net/netfilter/Makefile
index c1b6a98afe92..3c7c534b4245 100644
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -109,6 +109,8 @@ obj-$(CONFIG_NFT_SOCKET)	+= nft_socket.o
 obj-$(CONFIG_NFT_TPROXY)	+= nft_tproxy.o
 obj-$(CONFIG_NFT_XFRM)		+= nft_xfrm.o
 
+obj-$(CONFIG_NFT_NAT)		+= nft_chain_nat.o
+
 # nf_tables netdev
 obj-$(CONFIG_NFT_DUP_NETDEV)	+= nft_dup_netdev.o
 obj-$(CONFIG_NFT_FWD_NETDEV)	+= nft_fwd_netdev.o
diff --git a/net/netfilter/nft_chain_nat.c b/net/netfilter/nft_chain_nat.c
new file mode 100644
index 000000000000..ee4852088d50
--- /dev/null
+++ b/net/netfilter/nft_chain_nat.c
@@ -0,0 +1,108 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/module.h>
+#include <linux/netfilter/nf_tables.h>
+#include <net/netfilter/nf_nat.h>
+#include <net/netfilter/nf_tables.h>
+#include <net/netfilter/nf_tables_ipv4.h>
+#include <net/netfilter/nf_tables_ipv6.h>
+
+static unsigned int nft_nat_do_chain(void *priv, struct sk_buff *skb,
+				     const struct nf_hook_state *state)
+{
+	struct nft_pktinfo pkt;
+
+	nft_set_pktinfo(&pkt, skb, state);
+
+	switch (state->pf) {
+#ifdef CONFIG_NF_TABLES_IPV4
+	case NFPROTO_IPV4:
+		nft_set_pktinfo_ipv4(&pkt, skb);
+		break;
+#endif
+#ifdef CONFIG_NF_TABLES_IPV6
+	case NFPROTO_IPV6:
+		nft_set_pktinfo_ipv6(&pkt, skb);
+		break;
+#endif
+	default:
+		break;
+	}
+
+	return nft_do_chain(&pkt, priv);
+}
+
+#ifdef CONFIG_NF_TABLES_IPV4
+static const struct nft_chain_type nft_chain_nat_ipv4 = {
+	.name		= "nat",
+	.type		= NFT_CHAIN_T_NAT,
+	.family		= NFPROTO_IPV4,
+	.owner		= THIS_MODULE,
+	.hook_mask	= (1 << NF_INET_PRE_ROUTING) |
+			  (1 << NF_INET_POST_ROUTING) |
+			  (1 << NF_INET_LOCAL_OUT) |
+			  (1 << NF_INET_LOCAL_IN),
+	.hooks		= {
+		[NF_INET_PRE_ROUTING]	= nft_nat_do_chain,
+		[NF_INET_POST_ROUTING]	= nft_nat_do_chain,
+		[NF_INET_LOCAL_OUT]	= nft_nat_do_chain,
+		[NF_INET_LOCAL_IN]	= nft_nat_do_chain,
+	},
+	.ops_register = nf_nat_ipv4_register_fn,
+	.ops_unregister = nf_nat_ipv4_unregister_fn,
+};
+#endif
+
+#ifdef CONFIG_NF_TABLES_IPV6
+static const struct nft_chain_type nft_chain_nat_ipv6 = {
+	.name		= "nat",
+	.type		= NFT_CHAIN_T_NAT,
+	.family		= NFPROTO_IPV6,
+	.owner		= THIS_MODULE,
+	.hook_mask	= (1 << NF_INET_PRE_ROUTING) |
+			  (1 << NF_INET_POST_ROUTING) |
+			  (1 << NF_INET_LOCAL_OUT) |
+			  (1 << NF_INET_LOCAL_IN),
+	.hooks		= {
+		[NF_INET_PRE_ROUTING]	= nft_nat_do_chain,
+		[NF_INET_POST_ROUTING]	= nft_nat_do_chain,
+		[NF_INET_LOCAL_OUT]	= nft_nat_do_chain,
+		[NF_INET_LOCAL_IN]	= nft_nat_do_chain,
+	},
+	.ops_register		= nf_nat_ipv6_register_fn,
+	.ops_unregister		= nf_nat_ipv6_unregister_fn,
+};
+#endif
+
+static int __init nft_chain_nat_init(void)
+{
+#ifdef CONFIG_NF_TABLES_IPV6
+	nft_register_chain_type(&nft_chain_nat_ipv6);
+#endif
+#ifdef CONFIG_NF_TABLES_IPV4
+	nft_register_chain_type(&nft_chain_nat_ipv4);
+#endif
+
+	return 0;
+}
+
+static void __exit nft_chain_nat_exit(void)
+{
+#ifdef CONFIG_NF_TABLES_IPV4
+	nft_unregister_chain_type(&nft_chain_nat_ipv4);
+#endif
+#ifdef CONFIG_NF_TABLES_IPV6
+	nft_unregister_chain_type(&nft_chain_nat_ipv6);
+#endif
+}
+
+module_init(nft_chain_nat_init);
+module_exit(nft_chain_nat_exit);
+
+MODULE_LICENSE("GPL");
+#ifdef CONFIG_NF_TABLES_IPV4
+MODULE_ALIAS_NFT_CHAIN(AF_INET, "nat");
+#endif
+#ifdef CONFIG_NF_TABLES_IPV6
+MODULE_ALIAS_NFT_CHAIN(AF_INET6, "nat");
+#endif
