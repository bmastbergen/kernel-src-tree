block: replace seq_zones_bitmap with conv_zones_bitmap

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Christoph Hellwig <hch@lst.de>
commit f216fdd77b5654f8c4f6fac6020d6aabc58878ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f216fdd7.failed

Invert the meaning of seq_zones_bitmap by keeping a bitmap of
conventional zones.  This allows not having a bitmap for devices
that do not have conventional zones.

	Reviewed-by: Javier Gonz√°lez <javier@javigon.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit f216fdd77b5654f8c4f6fac6020d6aabc58878ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-zoned.c
diff --cc block/blk-zoned.c
index dfece77e25b8,9c3931051f4f..000000000000
--- a/block/blk-zoned.c
+++ b/block/blk-zoned.c
@@@ -389,36 -330,101 +389,126 @@@ static inline unsigned long *blk_alloc_
  			    GFP_NOIO, node);
  }
  
 +/*
 + * Allocate an array of struct blk_zone to get nr_zones zone information.
 + * The allocated array may be smaller than nr_zones.
 + */
 +static struct blk_zone *blk_alloc_zones(int node, unsigned int *nr_zones)
 +{
 +	size_t size = *nr_zones * sizeof(struct blk_zone);
 +	struct page *page;
 +	int order;
 +
 +	for (order = get_order(size); order >= 0; order--) {
 +		page = alloc_pages_node(node, GFP_NOIO | __GFP_ZERO, order);
 +		if (page) {
 +			*nr_zones = min_t(unsigned int, *nr_zones,
 +				(PAGE_SIZE << order) / sizeof(struct blk_zone));
 +			return page_address(page);
 +		}
 +	}
 +
 +	return NULL;
 +}
 +
  void blk_queue_free_zone_bitmaps(struct request_queue *q)
  {
- 	kfree(q->seq_zones_bitmap);
- 	q->seq_zones_bitmap = NULL;
+ 	kfree(q->conv_zones_bitmap);
+ 	q->conv_zones_bitmap = NULL;
  	kfree(q->seq_zones_wlock);
  	q->seq_zones_wlock = NULL;
  }
  
++<<<<<<< HEAD
++=======
+ struct blk_revalidate_zone_args {
+ 	struct gendisk	*disk;
+ 	unsigned long	*conv_zones_bitmap;
+ 	unsigned long	*seq_zones_wlock;
+ 	sector_t	sector;
+ };
+ 
+ /*
+  * Helper function to check the validity of zones of a zoned block device.
+  */
+ static int blk_revalidate_zone_cb(struct blk_zone *zone, unsigned int idx,
+ 				  void *data)
+ {
+ 	struct blk_revalidate_zone_args *args = data;
+ 	struct gendisk *disk = args->disk;
+ 	struct request_queue *q = disk->queue;
+ 	sector_t zone_sectors = blk_queue_zone_sectors(q);
+ 	sector_t capacity = get_capacity(disk);
+ 
+ 	/*
+ 	 * All zones must have the same size, with the exception on an eventual
+ 	 * smaller last zone.
+ 	 */
+ 	if (zone->start + zone_sectors < capacity &&
+ 	    zone->len != zone_sectors) {
+ 		pr_warn("%s: Invalid zoned device with non constant zone size\n",
+ 			disk->disk_name);
+ 		return false;
+ 	}
+ 
+ 	if (zone->start + zone->len >= capacity &&
+ 	    zone->len > zone_sectors) {
+ 		pr_warn("%s: Invalid zoned device with larger last zone size\n",
+ 			disk->disk_name);
+ 		return -ENODEV;
+ 	}
+ 
+ 	/* Check for holes in the zone report */
+ 	if (zone->start != args->sector) {
+ 		pr_warn("%s: Zone gap at sectors %llu..%llu\n",
+ 			disk->disk_name, args->sector, zone->start);
+ 		return -ENODEV;
+ 	}
+ 
+ 	/* Check zone type */
+ 	switch (zone->type) {
+ 	case BLK_ZONE_TYPE_CONVENTIONAL:
+ 	case BLK_ZONE_TYPE_SEQWRITE_REQ:
+ 	case BLK_ZONE_TYPE_SEQWRITE_PREF:
+ 		break;
+ 	default:
+ 		pr_warn("%s: Invalid zone type 0x%x at sectors %llu\n",
+ 			disk->disk_name, (int)zone->type, zone->start);
+ 		return -ENODEV;
+ 	}
+ 
+ 	if (zone->type == BLK_ZONE_TYPE_CONVENTIONAL)
+ 		set_bit(idx, args->conv_zones_bitmap);
+ 
+ 	args->sector += zone->len;
+ 	return 0;
+ }
+ 
+ static int blk_update_zone_info(struct gendisk *disk, unsigned int nr_zones,
+ 				struct blk_revalidate_zone_args *args)
+ {
+ 	/*
+ 	 * Ensure that all memory allocations in this context are done as
+ 	 * if GFP_NOIO was specified.
+ 	 */
+ 	unsigned int noio_flag = memalloc_noio_save();
+ 	struct request_queue *q = disk->queue;
+ 	int ret;
+ 
+ 	args->seq_zones_wlock = blk_alloc_zone_bitmap(q->node, nr_zones);
+ 	if (!args->seq_zones_wlock)
+ 		return -ENOMEM;
+ 	args->conv_zones_bitmap = blk_alloc_zone_bitmap(q->node, nr_zones);
+ 	if (!args->conv_zones_bitmap)
+ 		return -ENOMEM;
+ 
+ 	ret = disk->fops->report_zones(disk, 0, nr_zones,
+ 				       blk_revalidate_zone_cb, args);
+ 	memalloc_noio_restore(noio_flag);
+ 	return ret;
+ }
+ 
++>>>>>>> f216fdd77b56 (block: replace seq_zones_bitmap with conv_zones_bitmap)
  /**
   * blk_revalidate_disk_zones - (re)allocate and initialize zone bitmaps
   * @disk:	Target disk
@@@ -494,24 -462,19 +584,40 @@@ update
  	 * bitmaps).
  	 */
  	blk_mq_freeze_queue(q);
++<<<<<<< HEAD
 +	q->nr_zones = nr_zones;
 +	swap(q->seq_zones_wlock, seq_zones_wlock);
 +	swap(q->seq_zones_bitmap, seq_zones_bitmap);
 +	blk_mq_unfreeze_queue(q);
 +
 +out:
 +	free_pages((unsigned long)zones,
 +		   get_order(rep_nr_zones * sizeof(struct blk_zone)));
 +	kfree(seq_zones_wlock);
 +	kfree(seq_zones_bitmap);
 +
 +	if (ret) {
 +		pr_warn("%s: failed to revalidate zones\n", disk->disk_name);
 +		blk_mq_freeze_queue(q);
 +		blk_queue_free_zone_bitmaps(q);
 +		blk_mq_unfreeze_queue(q);
 +	}
 +
++=======
+ 	if (ret >= 0) {
+ 		q->nr_zones = nr_zones;
+ 		swap(q->seq_zones_wlock, args.seq_zones_wlock);
+ 		swap(q->conv_zones_bitmap, args.conv_zones_bitmap);
+ 		ret = 0;
+ 	} else {
+ 		pr_warn("%s: failed to revalidate zones\n", disk->disk_name);
+ 		blk_queue_free_zone_bitmaps(q);
+ 	}
+ 	blk_mq_unfreeze_queue(q);
+ 
+ 	kfree(args.seq_zones_wlock);
+ 	kfree(args.conv_zones_bitmap);
++>>>>>>> f216fdd77b56 (block: replace seq_zones_bitmap with conv_zones_bitmap)
  	return ret;
  }
  EXPORT_SYMBOL_GPL(blk_revalidate_disk_zones);
* Unmerged path block/blk-zoned.c
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 8825c79cd84f..007f1ccbbe73 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -508,9 +508,9 @@ struct request_queue {
 	/*
 	 * Zoned block device information for request dispatch control.
 	 * nr_zones is the total number of zones of the device. This is always
-	 * 0 for regular block devices. seq_zones_bitmap is a bitmap of nr_zones
-	 * bits which indicates if a zone is conventional (bit clear) or
-	 * sequential (bit set). seq_zones_wlock is a bitmap of nr_zones
+	 * 0 for regular block devices. conv_zones_bitmap is a bitmap of nr_zones
+	 * bits which indicates if a zone is conventional (bit set) or
+	 * sequential (bit clear). seq_zones_wlock is a bitmap of nr_zones
 	 * bits which indicates if a zone is write locked, that is, if a write
 	 * request targeting the zone was dispatched. All three fields are
 	 * initialized by the low level device driver (e.g. scsi/sd.c).
@@ -523,7 +523,7 @@ struct request_queue {
 	 * blk_mq_unfreeze_queue().
 	 */
 	unsigned int		nr_zones;
-	unsigned long		*seq_zones_bitmap;
+	unsigned long		*conv_zones_bitmap;
 	unsigned long		*seq_zones_wlock;
 #endif /* CONFIG_BLK_DEV_ZONED */
 
@@ -741,9 +741,11 @@ static inline unsigned int blk_queue_zone_no(struct request_queue *q,
 static inline bool blk_queue_zone_is_seq(struct request_queue *q,
 					 sector_t sector)
 {
-	if (!blk_queue_is_zoned(q) || !q->seq_zones_bitmap)
+	if (!blk_queue_is_zoned(q))
 		return false;
-	return test_bit(blk_queue_zone_no(q, sector), q->seq_zones_bitmap);
+	if (!q->conv_zones_bitmap)
+		return true;
+	return !test_bit(blk_queue_zone_no(q, sector), q->conv_zones_bitmap);
 }
 #else /* CONFIG_BLK_DEV_ZONED */
 static inline unsigned int blk_queue_nr_zones(struct request_queue *q)
