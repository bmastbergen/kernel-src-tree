net: phy: dp83867: Rework delay rgmii delay handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Trent Piepho <tpiepho@impinj.com>
commit c11669a2757e285958e3d7647bad48807ae8e283
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c11669a2.failed

The code was assuming the reset default of the delay control register
was to have delay disabled.  This is what the datasheet shows as the
register's initial value.  However, that's not actually true: the
default is controlled by the PHY's pin strapping.

If the interface mode is selected as RX or TX delay only, insure the
other direction's delay is disabled.

If the interface mode is just "rgmii", with neither TX or RX internal
delay, one might expect that the driver should disable both delays.  But
this is not what the driver does.  It leaves the setting at the PHY's
strapping's default.  And that default, for no pins with strapping
resistors, is to have delay enabled and 2.00 ns.

Rather than change this behavior, I've kept it the same and documented
it.  No delay will most likely not work and will break ethernet on any
board using "rgmii" mode.  If the board is strapped to have a delay and
is configured to use "rgmii" mode a warning is generated that "rgmii-id"
should have been used.

Also validate the delay values and fail if they are not in range.

	Cc: Andrew Lunn <andrew@lunn.ch>
	Cc: Florian Fainelli <f.fainelli@gmail.com>
	Cc: Heiner Kallweit <hkallweit1@gmail.com>
	Signed-off-by: Trent Piepho <tpiepho@impinj.com>
	Reviewed-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c11669a2757e285958e3d7647bad48807ae8e283)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/dp83867.c
diff --cc drivers/net/phy/dp83867.c
index efda6a9ccdd1,fc5baa5d14d0..000000000000
--- a/drivers/net/phy/dp83867.c
+++ b/drivers/net/phy/dp83867.c
@@@ -26,18 -26,11 +26,19 @@@
  
  /* Extended Registers */
  #define DP83867_CFG4            0x0031
 +#define DP83867_CFG4_SGMII_ANEG_MASK (BIT(5) | BIT(6))
 +#define DP83867_CFG4_SGMII_ANEG_TIMER_11MS   (3 << 5)
 +#define DP83867_CFG4_SGMII_ANEG_TIMER_800US  (2 << 5)
 +#define DP83867_CFG4_SGMII_ANEG_TIMER_2US    (1 << 5)
 +#define DP83867_CFG4_SGMII_ANEG_TIMER_16MS   (0 << 5)
 +
  #define DP83867_RGMIICTL	0x0032
  #define DP83867_STRAP_STS1	0x006E
+ #define DP83867_STRAP_STS2	0x006f
  #define DP83867_RGMIIDCTL	0x0086
  #define DP83867_IO_MUX_CFG	0x0170
 +#define DP83867_10M_SGMII_CFG   0x016F
 +#define DP83867_10M_SGMII_RATE_ADAPT_MASK BIT(7)
  
  #define DP83867_SW_RESET	BIT(15)
  #define DP83867_SW_RESTART	BIT(14)
@@@ -265,10 -305,18 +313,21 @@@ static int dp83867_config_init(struct p
  		ret = phy_write(phydev, MII_DP83867_PHYCTRL, val);
  		if (ret)
  			return ret;
 -	}
  
++<<<<<<< HEAD
 +		/* Set up RGMII delays */
++=======
+ 	/* If rgmii mode with no internal delay is selected, we do NOT use
+ 	 * aligned mode as one might expect.  Instead we use the PHY's default
+ 	 * based on pin strapping.  And the "mode 0" default is to *use*
+ 	 * internal delay with a value of 7 (2.00 ns).
+ 	 */
+ 	if ((phydev->interface >= PHY_INTERFACE_MODE_RGMII_ID) &&
+ 	    (phydev->interface <= PHY_INTERFACE_MODE_RGMII_RXID)) {
++>>>>>>> c11669a2757e (net: phy: dp83867: Rework delay rgmii delay handling)
  		val = phy_read_mmd(phydev, DP83867_DEVADDR, DP83867_RGMIICTL);
  
+ 		val &= ~(DP83867_RGMII_TX_CLK_DELAY_EN | DP83867_RGMII_RX_CLK_DELAY_EN);
  		if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)
  			val |= (DP83867_RGMII_TX_CLK_DELAY_EN | DP83867_RGMII_RX_CLK_DELAY_EN);
  
* Unmerged path drivers/net/phy/dp83867.c
