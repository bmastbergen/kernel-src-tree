iwlwifi: scan: make new scan req versioning flow

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Shahar S Matityahu <shahar.s.matityahu@intel.com>
commit 687db6ff5b7075326a8a1fcd8b7c4037208663fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/687db6ff.failed

Implement a new versioning handling flow supported from version 11
onwards.

	Signed-off-by: Shahar S Matityahu <shahar.s.matityahu@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
	Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
(cherry picked from commit 687db6ff5b7075326a8a1fcd8b7c4037208663fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
#	drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
#	drivers/net/wireless/intel/iwlwifi/mvm/scan.c
diff --cc drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
index c0750ced5ac2,8180bfe8c62e..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
+++ b/drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
@@@ -638,6 -644,43 +638,46 @@@ enum iwl_umac_scan_general_flags2 
  };
  
  /**
++<<<<<<< HEAD
++=======
+  * enum iwl_umac_scan_general_flags_v2 - UMAC scan general flags version 2
+  *
+  * The FW flags were reordered and hence the driver introduce version 2
+  *
+  * @IWL_UMAC_SCAN_GEN_FLAGS_V2_PERIODIC: periodic or scheduled
+  * @IWL_UMAC_SCAN_GEN_FLAGS_V2_PASS_ALL: pass all probe responses and beacons
+  *                                       during scan iterations
+  * @IWL_UMAC_SCAN_GEN_FLAGS_V2_NTFY_ITER_COMPLETE: send complete notification
+  *      on every iteration instead of only once after the last iteration
+  * @IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC1: fragmented scan LMAC1
+  * @IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC2: fragmented scan LMAC2
+  * @IWL_UMAC_SCAN_GEN_FLAGS_V2_MATCH: does this scan check for profile matching
+  * @IWL_UMAC_SCAN_GEN_FLAGS_V2_USE_ALL_RX_CHAINS: use all valid chains for RX
+  * @IWL_UMAC_SCAN_GEN_FLAGS_V2_ADAPTIVE_DWELL: works with adaptive dwell
+  *                                             for active channel
+  * @IWL_UMAC_SCAN_GEN_FLAGS_V2_PREEMPTIVE: can be preempted by other requests
+  * @IWL_UMAC_SCAN_GEN_FLAGS_V2_NTF_START: send notification of scan start
+  * @IWL_UMAC_SCAN_GEN_FLAGS_V2_MULTI_SSID: matching on multiple SSIDs
+  * @IWL_UMAC_SCAN_GEN_FLAGS_V2_FORCE_PASSIVE: all the channels scanned
+  *                                           as passive
+  */
+ enum iwl_umac_scan_general_flags_v2 {
+ 	IWL_UMAC_SCAN_GEN_FLAGS_V2_PERIODIC             = BIT(0),
+ 	IWL_UMAC_SCAN_GEN_FLAGS_V2_PASS_ALL             = BIT(1),
+ 	IWL_UMAC_SCAN_GEN_FLAGS_V2_NTFY_ITER_COMPLETE   = BIT(2),
+ 	IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC1     = BIT(3),
+ 	IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC2     = BIT(4),
+ 	IWL_UMAC_SCAN_GEN_FLAGS_V2_MATCH                = BIT(5),
+ 	IWL_UMAC_SCAN_GEN_FLAGS_V2_USE_ALL_RX_CHAINS    = BIT(6),
+ 	IWL_UMAC_SCAN_GEN_FLAGS_V2_ADAPTIVE_DWELL       = BIT(7),
+ 	IWL_UMAC_SCAN_GEN_FLAGS_V2_PREEMPTIVE           = BIT(8),
+ 	IWL_UMAC_SCAN_GEN_FLAGS_V2_NTF_START            = BIT(9),
+ 	IWL_UMAC_SCAN_GEN_FLAGS_V2_MULTI_SSID           = BIT(10),
+ 	IWL_UMAC_SCAN_GEN_FLAGS_V2_FORCE_PASSIVE        = BIT(11),
+ };
+ 
+ /**
++>>>>>>> 687db6ff5b70 (iwlwifi: scan: make new scan req versioning flow)
   * struct iwl_scan_channel_cfg_umac
   * @flags:		bitmap - 0-19:	directed scan to i'th ssid.
   * @channel_num:	channel number 1-13 etc.
@@@ -831,6 -874,123 +871,126 @@@ struct iwl_scan_req_umac 
  #define IWL_SCAN_REQ_UMAC_SIZE_V1 36
  
  /**
++<<<<<<< HEAD
++=======
+  * struct iwl_scan_probe_params_v3
+  * @preq: scan probe request params
+  * @ssid_num: number of valid SSIDs in direct scan array
+  * @short_ssid_num: number of valid short SSIDs in short ssid array
+  * @bssid_num: number of valid bssid in bssids array
+  * @reserved: reserved
+  * @direct_scan: list of ssids
+  * @short_ssid: array of short ssids
+  * @bssid_array: array of bssids
+  */
+ struct iwl_scan_probe_params_v3 {
+ 	struct iwl_scan_probe_req preq;
+ 	u8 ssid_num;
+ 	u8 short_ssid_num;
+ 	u8 bssid_num;
+ 	u8 reserved;
+ 	struct iwl_ssid_ie direct_scan[PROBE_OPTION_MAX];
+ 	__le32 short_ssid[SCAN_SHORT_SSID_MAX_SIZE];
+ 	u8 bssid_array[ETH_ALEN][SCAN_BSSID_MAX_SIZE];
+ } __packed;
+ 
+ #define SCAN_MAX_NUM_CHANS_V3 67
+ 
+ /**
+  * struct iwl_scan_channel_params_v3
+  * @flags: channel flags &enum iwl_scan_channel_flags
+  * @count: num of channels in scan request
+  * @reserved: for future use and alignment
+  * @channel_config: array of explicit channel configurations
+  *                  for 2.4Ghz and 5.2Ghz bands
+  */
+ struct iwl_scan_channel_params_v3 {
+ 	u8 flags;
+ 	u8 count;
+ 	__le16 reserved;
+ 	struct iwl_scan_channel_cfg_umac channel_config[SCAN_MAX_NUM_CHANS_V3];
+ } __packed; /* SCAN_CHANNEL_PARAMS_API_S_VER_3 */
+ 
+ /**
+  * struct iwl_scan_general_params_v10
+  * @flags: &enum iwl_umac_scan_flags
+  * @reserved: reserved for future
+  * @scan_start_mac_id: report the scan start TSF time according to this mac TSF
+  * @active_dwell: dwell time for active scan per LMAC
+  * @adwell_default_2g: adaptive dwell default number of APs
+  *                        for 2.4GHz channel
+  * @adwell_default_5g: adaptive dwell default number of APs
+  *                        for 5GHz channels
+  * @adwell_default_social_chn: adaptive dwell default number of
+  *                             APs per social channel
+  * @reserved1: reserved for future
+  * @adwell_max_budget: the maximal number of TUs that adaptive dwell
+  *                     can add to the total scan time
+  * @max_out_of_time: max out of serving channel time, per LMAC
+  * @suspend_time: max suspend time, per LMAC
+  * @scan_priority: priority of the request
+  * @passive_dwell: continues dwell time for passive channel
+  *                 (without adaptive dwell)
+  * @num_of_fragments: number of fragments needed for full fragmented
+  *                    scan coverage.
+  */
+ struct iwl_scan_general_params_v10 {
+ 	__le16 flags;
+ 	u8 reserved;
+ 	u8 scan_start_mac_id;
+ 	u8 active_dwell[SCAN_TWO_LMACS];
+ 	u8 adwell_default_2g;
+ 	u8 adwell_default_5g;
+ 	u8 adwell_default_social_chn;
+ 	u8 reserved1;
+ 	__le16 adwell_max_budget;
+ 	__le32 max_out_of_time[SCAN_TWO_LMACS];
+ 	__le32 suspend_time[SCAN_TWO_LMACS];
+ 	__le32 scan_priority;
+ 	u8 passive_dwell[SCAN_TWO_LMACS];
+ 	u8 num_of_fragments[SCAN_TWO_LMACS];
+ } __packed; /* SCAN_GENERAL_PARAMS_API_S_VER_10 */
+ 
+ /**
+  * struct iwl_scan_periodic_parms_v1
+  * @schedule: can scheduling parameter
+  * @delay: initial delay of the periodic scan in seconds
+  * @reserved: reserved for future
+  */
+ struct iwl_scan_periodic_parms_v1 {
+ 	struct iwl_scan_umac_schedule schedule[IWL_MAX_SCHED_SCAN_PLANS];
+ 	__le16 delay;
+ 	__le16 reserved;
+ } __packed; /* SCAN_PERIODIC_PARAMS_API_S_VER_1 */
+ 
+ /**
+  * struct iwl_scan_req_params_v11
+  * @general_params: &struct iwl_scan_general_params_v10
+  * @channel_params: &struct iwl_scan_channel_params_v3
+  * @periodic_params: &struct iwl_scan_periodic_parms_v1
+  * @probe_params: &struct iwl_scan_probe_params_v3
+  */
+ struct iwl_scan_req_params_v11 {
+ 	struct iwl_scan_general_params_v10 general_params;
+ 	struct iwl_scan_channel_params_v3 channel_params;
+ 	struct iwl_scan_periodic_parms_v1 periodic_params;
+ 	struct iwl_scan_probe_params_v3 probe_params;
+ } __packed; /* SCAN_REQUEST_PARAMS_API_S_VER_11 */
+ 
+ /**
+  * struct iwl_scan_req_umac_v11
+  * @uid: scan id, &enum iwl_umac_scan_uid_offsets
+  * @ooc_priority: out of channel priority - &enum iwl_scan_priority
+  * @scan_params: scan parameters
+  */
+ struct iwl_scan_req_umac_v11 {
+ 	__le32 uid;
+ 	__le32 ooc_priority;
+ 	struct iwl_scan_req_params_v11 scan_params;
+ } __packed; /* SCAN_REQUEST_CMD_UMAC_API_S_VER_11 */
+ 
+ /**
++>>>>>>> 687db6ff5b70 (iwlwifi: scan: make new scan req versioning flow)
   * struct iwl_umac_scan_abort
   * @uid: scan id, &enum iwl_umac_scan_uid_offsets
   * @flags: reserved
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
index bed89af0768f,735436f5253f..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
@@@ -1415,6 -1416,12 +1415,15 @@@ static inline bool iwl_mvm_is_reduced_c
  			  IWL_UCODE_TLV_API_REDUCED_SCAN_CONFIG);
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool iwl_mvm_is_band_in_rx_supported(struct iwl_mvm *mvm)
+ {
+ 	return fw_has_api(&mvm->fw->ucode_capa,
+ 			   IWL_UCODE_TLV_API_BAND_IN_RX_DATA);
+ }
+ 
++>>>>>>> 687db6ff5b70 (iwlwifi: scan: make new scan req versioning flow)
  static inline bool iwl_mvm_has_new_rx_stats_api(struct iwl_mvm *mvm)
  {
  	return fw_has_api(&mvm->fw->ucode_capa,
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/scan.c
index 3e5455cef0ee,e034418553f9..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
@@@ -1405,6 -1403,62 +1401,65 @@@ static void iwl_mvm_scan_umac_dwell(str
  		cmd->ooc_priority = cpu_to_le32(IWL_SCAN_PRIORITY_EXT_2);
  }
  
++<<<<<<< HEAD
++=======
+ static u32 iwl_mvm_scan_umac_ooc_priority(struct iwl_mvm_scan_params *params)
+ {
+ 	return iwl_mvm_is_regular_scan(params) ?
+ 		IWL_SCAN_PRIORITY_EXT_6 :
+ 		IWL_SCAN_PRIORITY_EXT_2;
+ }
+ 
+ static void
+ iwl_mvm_scan_umac_dwell_v10(struct iwl_mvm *mvm,
+ 			    struct iwl_scan_general_params_v10 *general_params,
+ 			    struct iwl_mvm_scan_params *params)
+ {
+ 	struct iwl_mvm_scan_timing_params *timing, *hb_timing;
+ 	u8 active_dwell, passive_dwell;
+ 
+ 	timing = &scan_timing[params->type];
+ 	active_dwell = params->measurement_dwell ?
+ 		params->measurement_dwell : IWL_SCAN_DWELL_ACTIVE;
+ 	passive_dwell = params->measurement_dwell ?
+ 		params->measurement_dwell : IWL_SCAN_DWELL_PASSIVE;
+ 
+ 	general_params->adwell_default_social_chn =
+ 		IWL_SCAN_ADWELL_DEFAULT_N_APS_SOCIAL;
+ 	general_params->adwell_default_2g = IWL_SCAN_ADWELL_DEFAULT_LB_N_APS;
+ 	general_params->adwell_default_5g = IWL_SCAN_ADWELL_DEFAULT_HB_N_APS;
+ 
+ 	/* if custom max budget was configured with debugfs */
+ 	if (IWL_MVM_ADWELL_MAX_BUDGET)
+ 		general_params->adwell_max_budget =
+ 			cpu_to_le16(IWL_MVM_ADWELL_MAX_BUDGET);
+ 	else if (params->ssids && params->ssids[0].ssid_len)
+ 		general_params->adwell_max_budget =
+ 			cpu_to_le16(IWL_SCAN_ADWELL_MAX_BUDGET_DIRECTED_SCAN);
+ 	else
+ 		general_params->adwell_max_budget =
+ 			cpu_to_le16(IWL_SCAN_ADWELL_MAX_BUDGET_FULL_SCAN);
+ 
+ 	general_params->scan_priority = cpu_to_le32(IWL_SCAN_PRIORITY_EXT_6);
+ 	general_params->max_out_of_time[SCAN_LB_LMAC_IDX] =
+ 		cpu_to_le32(timing->max_out_time);
+ 	general_params->suspend_time[SCAN_LB_LMAC_IDX] =
+ 		cpu_to_le32(timing->suspend_time);
+ 
+ 	hb_timing = &scan_timing[params->hb_type];
+ 
+ 	general_params->max_out_of_time[SCAN_HB_LMAC_IDX] =
+ 		cpu_to_le32(hb_timing->max_out_time);
+ 	general_params->suspend_time[SCAN_HB_LMAC_IDX] =
+ 		cpu_to_le32(hb_timing->suspend_time);
+ 
+ 	general_params->active_dwell[SCAN_LB_LMAC_IDX] = active_dwell;
+ 	general_params->passive_dwell[SCAN_LB_LMAC_IDX] = passive_dwell;
+ 	general_params->active_dwell[SCAN_HB_LMAC_IDX] = active_dwell;
+ 	general_params->passive_dwell[SCAN_HB_LMAC_IDX] = passive_dwell;
+ }
+ 
++>>>>>>> 687db6ff5b70 (iwlwifi: scan: make new scan req versioning flow)
  static void
  iwl_mvm_umac_scan_cfg_channels(struct iwl_mvm *mvm,
  			       struct ieee80211_channel **channels,
@@@ -1634,6 -1738,82 +1681,85 @@@ static int iwl_mvm_scan_umac(struct iwl
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ iwl_mvm_scan_umac_fill_general_p_v10(struct iwl_mvm *mvm,
+ 				     struct iwl_mvm_scan_params *params,
+ 				     struct ieee80211_vif *vif,
+ 				     struct iwl_scan_general_params_v10 *gp,
+ 				     u16 gen_flags)
+ {
+ 	struct iwl_mvm_vif *scan_vif = iwl_mvm_vif_from_mac80211(vif);
+ 
+ 	iwl_mvm_scan_umac_dwell_v10(mvm, gp, params);
+ 
+ 	gp->flags = cpu_to_le16(gen_flags);
+ 
+ 	if (gen_flags & IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC1)
+ 		gp->num_of_fragments[SCAN_LB_LMAC_IDX] = IWL_SCAN_NUM_OF_FRAGS;
+ 	if (gen_flags & IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC2)
+ 		gp->num_of_fragments[SCAN_HB_LMAC_IDX] = IWL_SCAN_NUM_OF_FRAGS;
+ 
+ 	gp->scan_start_mac_id = scan_vif->id;
+ }
+ 
+ static void
+ iwl_mvm_scan_umac_fill_probe_p_v3(struct iwl_mvm_scan_params *params,
+ 				  struct iwl_scan_probe_params_v3 *pp)
+ {
+ 	pp->preq = params->preq;
+ 	pp->ssid_num = params->n_ssids;
+ 	iwl_scan_build_ssids(params, pp->direct_scan, NULL);
+ }
+ 
+ static void
+ iwl_mvm_scan_umac_fill_ch_p_v3(struct iwl_mvm *mvm,
+ 			       struct iwl_mvm_scan_params *params,
+ 			       struct ieee80211_vif *vif,
+ 			       struct iwl_scan_channel_params_v3 *cp)
+ {
+ 	cp->flags = iwl_mvm_scan_umac_chan_flags_v2(mvm, params, vif);
+ 	cp->count = params->n_channels;
+ 
+ 	iwl_mvm_umac_scan_cfg_channels(mvm, params->channels,
+ 				       params->n_channels, 0,
+ 				       cp->channel_config);
+ }
+ 
+ static int iwl_mvm_scan_umac_v11(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+ 				 struct iwl_mvm_scan_params *params, int type,
+ 				 int uid)
+ {
+ 	struct iwl_scan_req_umac_v11 *cmd = mvm->scan_cmd;
+ 	struct iwl_scan_req_params_v11 *scan_p = &cmd->scan_params;
+ 	int ret;
+ 	u16 gen_flags;
+ 
+ 	mvm->scan_uid_status[uid] = type;
+ 
+ 	cmd->ooc_priority = cpu_to_le32(iwl_mvm_scan_umac_ooc_priority(params));
+ 	cmd->uid = cpu_to_le32(uid);
+ 
+ 	gen_flags = iwl_mvm_scan_umac_flags_v2(mvm, params, vif, type);
+ 	iwl_mvm_scan_umac_fill_general_p_v10(mvm, params, vif,
+ 					     &scan_p->general_params,
+ 					     gen_flags);
+ 
+ 	 ret = iwl_mvm_fill_scan_sched_params(params,
+ 					      scan_p->periodic_params.schedule,
+ 					      &scan_p->periodic_params.delay);
+ 	if (ret)
+ 		return ret;
+ 
+ 	iwl_mvm_scan_umac_fill_probe_p_v3(params, &scan_p->probe_params);
+ 	iwl_mvm_scan_umac_fill_ch_p_v3(mvm, params, vif,
+ 				       &scan_p->channel_params);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 687db6ff5b70 (iwlwifi: scan: make new scan req versioning flow)
  static int iwl_mvm_num_scans(struct iwl_mvm *mvm)
  {
  	return hweight32(mvm->scan_status & IWL_MVM_SCAN_MASK);
@@@ -1742,12 -1937,38 +1883,44 @@@ static int iwl_mvm_build_scan_cmd(struc
  				  struct iwl_mvm_scan_params *params,
  				  int type)
  {
++<<<<<<< HEAD
 +	if (fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_UMAC_SCAN)) {
 +		hcmd->id = iwl_cmd_id(SCAN_REQ_UMAC, IWL_ALWAYS_LONG_GROUP, 0);
 +		return  iwl_mvm_scan_umac(mvm, vif, params, type);
++=======
+ 	int uid, i;
+ 	u8 scan_ver;
+ 
+ 	lockdep_assert_held(&mvm->mutex);
+ 	memset(mvm->scan_cmd, 0, ksize(mvm->scan_cmd));
+ 
+ 	if (!fw_has_capa(&mvm->fw->ucode_capa, IWL_UCODE_TLV_CAPA_UMAC_SCAN)) {
+ 		hcmd->id = SCAN_OFFLOAD_REQUEST_CMD;
+ 
+ 		return iwl_mvm_scan_lmac(mvm, vif, params);
++>>>>>>> 687db6ff5b70 (iwlwifi: scan: make new scan req versioning flow)
+ 	}
+ 
+ 	uid = iwl_mvm_scan_uid_by_status(mvm, 0);
+ 	if (uid < 0)
+ 		return uid;
+ 
+ 	hcmd->id = iwl_cmd_id(SCAN_REQ_UMAC, IWL_ALWAYS_LONG_GROUP, 0);
+ 
+ 	scan_ver = iwl_mvm_lookup_cmd_ver(mvm->fw, IWL_ALWAYS_LONG_GROUP,
+ 					  SCAN_REQ_UMAC);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(iwl_scan_umac_handlers); i++) {
+ 		const struct iwl_scan_umac_handler *ver_handler =
+ 			&iwl_scan_umac_handlers[i];
+ 
+ 		if (ver_handler->version != scan_ver)
+ 			continue;
+ 
+ 		return ver_handler->handler(mvm, vif, params, type, uid);
  	}
- 	hcmd->id = SCAN_OFFLOAD_REQUEST_CMD;
- 	return  iwl_mvm_scan_lmac(mvm, vif, params);
+ 
+ 	return iwl_mvm_scan_umac(mvm, vif, params, type, uid);
  }
  
  int iwl_mvm_reg_scan_start(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
@@@ -2057,11 -2278,30 +2230,33 @@@ static int iwl_mvm_scan_stop_wait(struc
  				     1 * HZ);
  }
  
+ #define IWL_SCAN_REQ_UMAC_HANDLE_SIZE(_ver) {				\
+ 	case (_ver): return sizeof(struct iwl_scan_req_umac_v##_ver);	\
+ }
+ 
+ static int iwl_scan_req_umac_get_size(u8 scan_ver)
+ {
+ 	switch (scan_ver) {
+ 		IWL_SCAN_REQ_UMAC_HANDLE_SIZE(11);
+ 	}
+ 
+ 	return 0;
+ }
+ 
  int iwl_mvm_scan_size(struct iwl_mvm *mvm)
  {
- 	int base_size = IWL_SCAN_REQ_UMAC_SIZE_V1;
- 	int tail_size;
+ 	int base_size, tail_size;
+ 	u8 scan_ver = iwl_mvm_lookup_cmd_ver(mvm->fw, IWL_ALWAYS_LONG_GROUP,
+ 					     SCAN_REQ_UMAC);
  
+ 	base_size = iwl_scan_req_umac_get_size(scan_ver);
+ 	if (base_size)
+ 		return base_size;
+ 
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> 687db6ff5b70 (iwlwifi: scan: make new scan req versioning flow)
  	if (iwl_mvm_is_adaptive_dwell_v2_supported(mvm))
  		base_size = IWL_SCAN_REQ_UMAC_SIZE_V8;
  	else if (iwl_mvm_is_adaptive_dwell_supported(mvm))
* Unmerged path drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/mvm.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/scan.c
