devlink: Fix reporter's recovery condition

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Aya Levin <ayal@mellanox.com>
commit bea0c5c942d3b4e9fb6ed45f6a7de74c6b112437
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/bea0c5c9.failed

Devlink health core conditions the reporter's recovery with the
expiration of the grace period. This is not relevant for the first
recovery. Explicitly demand that the grace period will only apply to
recoveries other than the first.

Fixes: c8e1da0bf923 ("devlink: Add health report functionality")
	Signed-off-by: Aya Levin <ayal@mellanox.com>
	Reviewed-by: Moshe Shemesh <moshe@mellanox.com>
	Reviewed-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bea0c5c942d3b4e9fb6ed45f6a7de74c6b112437)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/devlink.c
diff --cc net/core/devlink.c
index 05a3779588b8,899edcee7dab..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -5197,6 -5283,187 +5197,190 @@@ static void devlink_recover_notify(stru
  }
  
  void
++<<<<<<< HEAD
++=======
+ devlink_health_reporter_recovery_done(struct devlink_health_reporter *reporter)
+ {
+ 	reporter->recovery_count++;
+ 	reporter->last_recovery_ts = jiffies;
+ }
+ EXPORT_SYMBOL_GPL(devlink_health_reporter_recovery_done);
+ 
+ static int
+ devlink_health_reporter_recover(struct devlink_health_reporter *reporter,
+ 				void *priv_ctx, struct netlink_ext_ack *extack)
+ {
+ 	int err;
+ 
+ 	if (reporter->health_state == DEVLINK_HEALTH_REPORTER_STATE_HEALTHY)
+ 		return 0;
+ 
+ 	if (!reporter->ops->recover)
+ 		return -EOPNOTSUPP;
+ 
+ 	err = reporter->ops->recover(reporter, priv_ctx, extack);
+ 	if (err)
+ 		return err;
+ 
+ 	devlink_health_reporter_recovery_done(reporter);
+ 	reporter->health_state = DEVLINK_HEALTH_REPORTER_STATE_HEALTHY;
+ 	devlink_recover_notify(reporter, DEVLINK_CMD_HEALTH_REPORTER_RECOVER);
+ 
+ 	return 0;
+ }
+ 
+ static void
+ devlink_health_dump_clear(struct devlink_health_reporter *reporter)
+ {
+ 	if (!reporter->dump_fmsg)
+ 		return;
+ 	devlink_fmsg_free(reporter->dump_fmsg);
+ 	reporter->dump_fmsg = NULL;
+ }
+ 
+ static int devlink_health_do_dump(struct devlink_health_reporter *reporter,
+ 				  void *priv_ctx,
+ 				  struct netlink_ext_ack *extack)
+ {
+ 	int err;
+ 
+ 	if (!reporter->ops->dump)
+ 		return 0;
+ 
+ 	if (reporter->dump_fmsg)
+ 		return 0;
+ 
+ 	reporter->dump_fmsg = devlink_fmsg_alloc();
+ 	if (!reporter->dump_fmsg) {
+ 		err = -ENOMEM;
+ 		return err;
+ 	}
+ 
+ 	err = devlink_fmsg_obj_nest_start(reporter->dump_fmsg);
+ 	if (err)
+ 		goto dump_err;
+ 
+ 	err = reporter->ops->dump(reporter, reporter->dump_fmsg,
+ 				  priv_ctx, extack);
+ 	if (err)
+ 		goto dump_err;
+ 
+ 	err = devlink_fmsg_obj_nest_end(reporter->dump_fmsg);
+ 	if (err)
+ 		goto dump_err;
+ 
+ 	reporter->dump_ts = jiffies;
+ 	reporter->dump_real_ts = ktime_get_real_ns();
+ 
+ 	return 0;
+ 
+ dump_err:
+ 	devlink_health_dump_clear(reporter);
+ 	return err;
+ }
+ 
+ int devlink_health_report(struct devlink_health_reporter *reporter,
+ 			  const char *msg, void *priv_ctx)
+ {
+ 	enum devlink_health_reporter_state prev_health_state;
+ 	struct devlink *devlink = reporter->devlink;
+ 	unsigned long recover_ts_threshold;
+ 
+ 	/* write a log message of the current error */
+ 	WARN_ON(!msg);
+ 	trace_devlink_health_report(devlink, reporter->ops->name, msg);
+ 	reporter->error_count++;
+ 	prev_health_state = reporter->health_state;
+ 	reporter->health_state = DEVLINK_HEALTH_REPORTER_STATE_ERROR;
+ 	devlink_recover_notify(reporter, DEVLINK_CMD_HEALTH_REPORTER_RECOVER);
+ 
+ 	/* abort if the previous error wasn't recovered */
+ 	recover_ts_threshold = reporter->last_recovery_ts +
+ 			       msecs_to_jiffies(reporter->graceful_period);
+ 	if (reporter->auto_recover &&
+ 	    (prev_health_state != DEVLINK_HEALTH_REPORTER_STATE_HEALTHY ||
+ 	     (reporter->last_recovery_ts && reporter->recovery_count &&
+ 	      time_is_after_jiffies(recover_ts_threshold)))) {
+ 		trace_devlink_health_recover_aborted(devlink,
+ 						     reporter->ops->name,
+ 						     reporter->health_state,
+ 						     jiffies -
+ 						     reporter->last_recovery_ts);
+ 		return -ECANCELED;
+ 	}
+ 
+ 	reporter->health_state = DEVLINK_HEALTH_REPORTER_STATE_ERROR;
+ 
+ 	if (reporter->auto_dump) {
+ 		mutex_lock(&reporter->dump_lock);
+ 		/* store current dump of current error, for later analysis */
+ 		devlink_health_do_dump(reporter, priv_ctx, NULL);
+ 		mutex_unlock(&reporter->dump_lock);
+ 	}
+ 
+ 	if (reporter->auto_recover)
+ 		return devlink_health_reporter_recover(reporter,
+ 						       priv_ctx, NULL);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(devlink_health_report);
+ 
+ static struct devlink_health_reporter *
+ devlink_health_reporter_get_from_attrs(struct devlink *devlink,
+ 				       struct nlattr **attrs)
+ {
+ 	struct devlink_health_reporter *reporter;
+ 	char *reporter_name;
+ 
+ 	if (!attrs[DEVLINK_ATTR_HEALTH_REPORTER_NAME])
+ 		return NULL;
+ 
+ 	reporter_name = nla_data(attrs[DEVLINK_ATTR_HEALTH_REPORTER_NAME]);
+ 	mutex_lock(&devlink->reporters_lock);
+ 	reporter = devlink_health_reporter_find_by_name(devlink, reporter_name);
+ 	if (reporter)
+ 		refcount_inc(&reporter->refcount);
+ 	mutex_unlock(&devlink->reporters_lock);
+ 	return reporter;
+ }
+ 
+ static struct devlink_health_reporter *
+ devlink_health_reporter_get_from_info(struct devlink *devlink,
+ 				      struct genl_info *info)
+ {
+ 	return devlink_health_reporter_get_from_attrs(devlink, info->attrs);
+ }
+ 
+ static struct devlink_health_reporter *
+ devlink_health_reporter_get_from_cb(struct netlink_callback *cb)
+ {
+ 	const struct genl_dumpit_info *info = genl_dumpit_info(cb);
+ 	struct devlink_health_reporter *reporter;
+ 	struct nlattr **attrs = info->attrs;
+ 	struct devlink *devlink;
+ 
+ 	mutex_lock(&devlink_mutex);
+ 	devlink = devlink_get_from_attrs(sock_net(cb->skb->sk), attrs);
+ 	if (IS_ERR(devlink))
+ 		goto unlock;
+ 
+ 	reporter = devlink_health_reporter_get_from_attrs(devlink, attrs);
+ 	mutex_unlock(&devlink_mutex);
+ 	return reporter;
+ unlock:
+ 	mutex_unlock(&devlink_mutex);
+ 	return NULL;
+ }
+ 
+ static void
+ devlink_health_reporter_put(struct devlink_health_reporter *reporter)
+ {
+ 	refcount_dec(&reporter->refcount);
+ }
+ 
+ void
++>>>>>>> bea0c5c942d3 (devlink: Fix reporter's recovery condition)
  devlink_health_reporter_state_update(struct devlink_health_reporter *reporter,
  				     enum devlink_health_reporter_state state)
  {
* Unmerged path net/core/devlink.c
