crypto: chelsio - This fixes the libkcapi's cbc(aes) aio fail test cases

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ayush Sawal <ayush.sawal@chelsio.com>
commit 1c502e2e2d79b6a4c800c3806c70b58ad6ae784d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/1c502e2e.failed

The libkcapi "cbc(aes)" failed tests are
symmetric asynchronous cipher one shot multiple test,
symmetric asynchronous cipher stream multiple test,
Symmetric asynchronous cipher vmsplice multiple test

In this patch a wait_for_completion is added in the chcr_aes_encrypt function,
which completes when the response of comes from the hardware.
This adds serialization for encryption in cbc(aes) aio case.

	Signed-off-by: Ayush Sawal <ayush.sawal@chelsio.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 1c502e2e2d79b6a4c800c3806c70b58ad6ae784d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chcr_algo.c
diff --cc drivers/crypto/chelsio/chcr_algo.c
index 98b7bd23dee2,699e3053895a..000000000000
--- a/drivers/crypto/chelsio/chcr_algo.c
+++ b/drivers/crypto/chelsio/chcr_algo.c
@@@ -1107,10 -1098,11 +1107,15 @@@ static int chcr_final_cipher_iv(struct 
  
  }
  
 -static int chcr_handle_cipher_resp(struct skcipher_request *req,
 +static int chcr_handle_cipher_resp(struct ablkcipher_request *req,
  				   unsigned char *input, int err)
  {
++<<<<<<< HEAD
 +	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);
++=======
+ 	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
+ 	struct chcr_context *ctx = c_ctx(tfm);
++>>>>>>> 1c502e2e2d79 (crypto: chelsio - This fixes the libkcapi's cbc(aes) aio fail test cases)
  	struct uld_ctx *u_ctx = ULD_CTX(c_ctx(tfm));
  	struct ablk_ctx *ablkctx = ABLK_CTX(c_ctx(tfm));
  	struct sk_buff *skb;
@@@ -1295,9 -1297,10 +1310,14 @@@ error
  	return err;
  }
  
 -static int chcr_aes_encrypt(struct skcipher_request *req)
 +static int chcr_aes_encrypt(struct ablkcipher_request *req)
  {
++<<<<<<< HEAD
 +	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);
++=======
+ 	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
+ 	struct chcr_context *ctx;
++>>>>>>> 1c502e2e2d79 (crypto: chelsio - This fixes the libkcapi's cbc(aes) aio fail test cases)
  	struct chcr_dev *dev = c_ctx(tfm)->dev;
  	struct sk_buff *skb = NULL;
  	int err, isfull = 0;
@@@ -1398,37 -1407,28 +1424,42 @@@ out
  	return err;
  }
  
 -static int chcr_init_tfm(struct crypto_skcipher *tfm)
 +static int chcr_cra_init(struct crypto_tfm *tfm)
  {
 -	struct skcipher_alg *alg = crypto_skcipher_alg(tfm);
 -	struct chcr_context *ctx = crypto_skcipher_ctx(tfm);
 +	struct crypto_alg *alg = tfm->__crt_alg;
 +	struct chcr_context *ctx = crypto_tfm_ctx(tfm);
  	struct ablk_ctx *ablkctx = ABLK_CTX(ctx);
  
 -	ablkctx->sw_cipher = crypto_alloc_sync_skcipher(alg->base.cra_name, 0,
 -				CRYPTO_ALG_NEED_FALLBACK);
 +	ablkctx->sw_cipher = crypto_alloc_skcipher(alg->cra_name, 0,
 +				CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK);
  	if (IS_ERR(ablkctx->sw_cipher)) {
 -		pr_err("failed to allocate fallback for %s\n", alg->base.cra_name);
 +		pr_err("failed to allocate fallback for %s\n", alg->cra_name);
  		return PTR_ERR(ablkctx->sw_cipher);
  	}
++<<<<<<< HEAD
 +
 +	if (get_cryptoalg_subtype(tfm) == CRYPTO_ALG_SUB_TYPE_XTS) {
 +		/* To update tweak*/
 +		ablkctx->aes_generic = crypto_alloc_cipher("aes-generic", 0, 0);
 +		if (IS_ERR(ablkctx->aes_generic)) {
 +			pr_err("failed to allocate aes cipher for tweak\n");
 +			return PTR_ERR(ablkctx->aes_generic);
 +		}
 +	} else
 +		ablkctx->aes_generic = NULL;
++=======
+ 	init_completion(&ctx->cbc_aes_aio_done);
+ 	crypto_skcipher_set_reqsize(tfm, sizeof(struct chcr_skcipher_req_ctx));
++>>>>>>> 1c502e2e2d79 (crypto: chelsio - This fixes the libkcapi's cbc(aes) aio fail test cases)
  
 -	return chcr_device_init(ctx);
 +	tfm->crt_ablkcipher.reqsize =  sizeof(struct chcr_blkcipher_req_ctx);
 +	return chcr_device_init(crypto_tfm_ctx(tfm));
  }
  
 -static int chcr_rfc3686_init(struct crypto_skcipher *tfm)
 +static int chcr_rfc3686_init(struct crypto_tfm *tfm)
  {
 -	struct skcipher_alg *alg = crypto_skcipher_alg(tfm);
 -	struct chcr_context *ctx = crypto_skcipher_ctx(tfm);
 +	struct crypto_alg *alg = tfm->__crt_alg;
 +	struct chcr_context *ctx = crypto_tfm_ctx(tfm);
  	struct ablk_ctx *ablkctx = ABLK_CTX(ctx);
  
  	/*RFC3686 initialises IV counter value to 1, rfc3686(ctr(aes))
* Unmerged path drivers/crypto/chelsio/chcr_algo.c
diff --git a/drivers/crypto/chelsio/chcr_crypto.h b/drivers/crypto/chelsio/chcr_crypto.h
index e231e8b36624..43ba13ad943e 100644
--- a/drivers/crypto/chelsio/chcr_crypto.h
+++ b/drivers/crypto/chelsio/chcr_crypto.h
@@ -255,6 +255,7 @@ struct chcr_context {
 	unsigned char rx_qidx;
 	unsigned char tx_chan_id;
 	unsigned char pci_chan_id;
+	struct completion cbc_aes_aio_done;
 	struct __crypto_ctx crypto_ctx[0];
 };
 
