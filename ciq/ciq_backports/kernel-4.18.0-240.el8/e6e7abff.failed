blk-mq: simplify the blk_mq_get_request calling convention

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Christoph Hellwig <hch@lst.de>
commit e6e7abffe386b614a194ec32457a00c304c980f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e6e7abff.failed

The bio argument is entirely unused, and the request_queue can be passed
through the alloc_data, given that it needs to be filled out for the
low-level tag allocation anyway.  Also rename the function to
__blk_mq_alloc_request as the switch between get and alloc in the call
chains is rather confusing.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Johannes Thumshirn <johannes.thumshirn@wdc.com>
	Reviewed-by: Bart Van Assche <bvanassche@acm.org>
	Reviewed-by: Daniel Wagner <dwagner@suse.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit e6e7abffe386b614a194ec32457a00c304c980f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index f3fc03aa9f37,74ebab41f7d2..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -335,9 -339,12 +334,12 @@@ static struct request *__blk_mq_alloc_r
  	struct request *rq;
  	unsigned int tag;
  	bool clear_ctx_on_error = false;
 -	u64 alloc_time_ns = 0;
 -
 -	/* alloc_time includes depth and tag waits */
 -	if (blk_queue_rq_alloc_time(q))
 -		alloc_time_ns = ktime_get_ns();
  
++<<<<<<< HEAD
 +	blk_queue_enter_live(q);
 +	data->q = q;
++=======
++>>>>>>> e6e7abffe386 (blk-mq: simplify the blk_mq_get_request calling convention)
  	if (likely(!data->ctx)) {
  		data->ctx = blk_mq_get_ctx(q);
  		clear_ctx_on_error = true;
@@@ -398,10 -408,9 +404,10 @@@ struct request *blk_mq_alloc_request(st
  	if (ret)
  		return ERR_PTR(ret);
  
- 	rq = blk_mq_get_request(q, NULL, &alloc_data);
+ 	rq = __blk_mq_alloc_request(&data);
  	if (!rq)
 -		goto out_queue_exit;
 +		return ERR_PTR(-EWOULDBLOCK);
 +
  	rq->__data_len = 0;
  	rq->__sector = (sector_t) -1;
  	rq->bio = rq->biotail = NULL;
@@@ -437,21 -453,21 +447,37 @@@ struct request *blk_mq_alloc_request_hc
  	 * Check if the hardware context is actually mapped to anything.
  	 * If not tell the caller that it should skip this queue.
  	 */
++<<<<<<< HEAD
 +	alloc_data.hctx = q->queue_hw_ctx[hctx_idx];
 +	if (!blk_mq_hw_queue_mapped(alloc_data.hctx)) {
 +		blk_queue_exit(q);
 +		return ERR_PTR(-EXDEV);
 +	}
 +	cpu = cpumask_first_and(alloc_data.hctx->cpumask, cpu_online_mask);
 +	alloc_data.ctx = __blk_mq_get_ctx(q, cpu);
 +
 +	rq = blk_mq_get_request(q, NULL, &alloc_data);
++=======
+ 	ret = -EXDEV;
+ 	data.hctx = q->queue_hw_ctx[hctx_idx];
+ 	if (!blk_mq_hw_queue_mapped(data.hctx))
+ 		goto out_queue_exit;
+ 	cpu = cpumask_first_and(data.hctx->cpumask, cpu_online_mask);
+ 	data.ctx = __blk_mq_get_ctx(q, cpu);
+ 
+ 	ret = -EWOULDBLOCK;
+ 	rq = __blk_mq_alloc_request(&data);
+ 	if (!rq)
+ 		goto out_queue_exit;
+ 	return rq;
+ out_queue_exit:
++>>>>>>> e6e7abffe386 (blk-mq: simplify the blk_mq_get_request calling convention)
  	blk_queue_exit(q);
 -	return ERR_PTR(ret);
 +
 +	if (!rq)
 +		return ERR_PTR(-EWOULDBLOCK);
 +
 +	return rq;
  }
  EXPORT_SYMBOL_GPL(blk_mq_alloc_request_hctx);
  
* Unmerged path block/blk-mq.c
