iwlwifi: scan: support scan req cmd ver 12

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Shahar S Matityahu <shahar.s.matityahu@intel.com>
commit 5167ff45a503ee49ae314c0cff410efa1eb9a1b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5167ff45.failed

Implement scan request command version 12.

	Signed-off-by: Shahar S Matityahu <shahar.s.matityahu@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
	Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
(cherry picked from commit 5167ff45a503ee49ae314c0cff410efa1eb9a1b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
#	drivers/net/wireless/intel/iwlwifi/mvm/scan.c
diff --cc drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
index c0750ced5ac2,71883ca6a596..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
+++ b/drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
@@@ -831,6 -874,171 +831,174 @@@ struct iwl_scan_req_umac 
  #define IWL_SCAN_REQ_UMAC_SIZE_V1 36
  
  /**
++<<<<<<< HEAD
++=======
+  * struct iwl_scan_probe_params_v3
+  * @preq: scan probe request params
+  * @ssid_num: number of valid SSIDs in direct scan array
+  * @short_ssid_num: number of valid short SSIDs in short ssid array
+  * @bssid_num: number of valid bssid in bssids array
+  * @reserved: reserved
+  * @direct_scan: list of ssids
+  * @short_ssid: array of short ssids
+  * @bssid_array: array of bssids
+  */
+ struct iwl_scan_probe_params_v3 {
+ 	struct iwl_scan_probe_req preq;
+ 	u8 ssid_num;
+ 	u8 short_ssid_num;
+ 	u8 bssid_num;
+ 	u8 reserved;
+ 	struct iwl_ssid_ie direct_scan[PROBE_OPTION_MAX];
+ 	__le32 short_ssid[SCAN_SHORT_SSID_MAX_SIZE];
+ 	u8 bssid_array[ETH_ALEN][SCAN_BSSID_MAX_SIZE];
+ } __packed;
+ 
+ #define SCAN_MAX_NUM_CHANS_V3 67
+ 
+ /**
+  * struct iwl_scan_channel_params_v3
+  * @flags: channel flags &enum iwl_scan_channel_flags
+  * @count: num of channels in scan request
+  * @reserved: for future use and alignment
+  * @channel_config: array of explicit channel configurations
+  *                  for 2.4Ghz and 5.2Ghz bands
+  */
+ struct iwl_scan_channel_params_v3 {
+ 	u8 flags;
+ 	u8 count;
+ 	__le16 reserved;
+ 	struct iwl_scan_channel_cfg_umac channel_config[SCAN_MAX_NUM_CHANS_V3];
+ } __packed; /* SCAN_CHANNEL_PARAMS_API_S_VER_3 */
+ 
+ /**
+  * struct iwl_scan_channel_params_v4
+  * @flags: channel flags &enum iwl_scan_channel_flags
+  * @count: num of channels in scan request
+  * @num_of_aps_override: override the number of APs the FW uses to calculate
+  *	dwell time when adaptive dwell is used
+  * @reserved: for future use and alignment
+  * @channel_config: array of explicit channel configurations
+  *                  for 2.4Ghz and 5.2Ghz bands
+  * @adwell_ch_override_bitmap: when using adaptive dwell, override the number
+  *	of APs value with &num_of_aps_override for the channel.
+  *	To cast channel to index, use &iwl_mvm_scan_ch_and_band_to_idx
+  */
+ struct iwl_scan_channel_params_v4 {
+ 	u8 flags;
+ 	u8 count;
+ 	u8 num_of_aps_override;
+ 	u8 reserved;
+ 	struct iwl_scan_channel_cfg_umac channel_config[SCAN_MAX_NUM_CHANS_V3];
+ 	u8 adwell_ch_override_bitmap[16];
+ } __packed; /* SCAN_CHANNEL_PARAMS_API_S_VER_4 */
+ 
+ /**
+  * struct iwl_scan_general_params_v10
+  * @flags: &enum iwl_umac_scan_flags
+  * @reserved: reserved for future
+  * @scan_start_mac_id: report the scan start TSF time according to this mac TSF
+  * @active_dwell: dwell time for active scan per LMAC
+  * @adwell_default_2g: adaptive dwell default number of APs
+  *                        for 2.4GHz channel
+  * @adwell_default_5g: adaptive dwell default number of APs
+  *                        for 5GHz channels
+  * @adwell_default_social_chn: adaptive dwell default number of
+  *                             APs per social channel
+  * @reserved1: reserved for future
+  * @adwell_max_budget: the maximal number of TUs that adaptive dwell
+  *                     can add to the total scan time
+  * @max_out_of_time: max out of serving channel time, per LMAC
+  * @suspend_time: max suspend time, per LMAC
+  * @scan_priority: priority of the request
+  * @passive_dwell: continues dwell time for passive channel
+  *                 (without adaptive dwell)
+  * @num_of_fragments: number of fragments needed for full fragmented
+  *                    scan coverage.
+  */
+ struct iwl_scan_general_params_v10 {
+ 	__le16 flags;
+ 	u8 reserved;
+ 	u8 scan_start_mac_id;
+ 	u8 active_dwell[SCAN_TWO_LMACS];
+ 	u8 adwell_default_2g;
+ 	u8 adwell_default_5g;
+ 	u8 adwell_default_social_chn;
+ 	u8 reserved1;
+ 	__le16 adwell_max_budget;
+ 	__le32 max_out_of_time[SCAN_TWO_LMACS];
+ 	__le32 suspend_time[SCAN_TWO_LMACS];
+ 	__le32 scan_priority;
+ 	u8 passive_dwell[SCAN_TWO_LMACS];
+ 	u8 num_of_fragments[SCAN_TWO_LMACS];
+ } __packed; /* SCAN_GENERAL_PARAMS_API_S_VER_10 */
+ 
+ /**
+  * struct iwl_scan_periodic_parms_v1
+  * @schedule: can scheduling parameter
+  * @delay: initial delay of the periodic scan in seconds
+  * @reserved: reserved for future
+  */
+ struct iwl_scan_periodic_parms_v1 {
+ 	struct iwl_scan_umac_schedule schedule[IWL_MAX_SCHED_SCAN_PLANS];
+ 	__le16 delay;
+ 	__le16 reserved;
+ } __packed; /* SCAN_PERIODIC_PARAMS_API_S_VER_1 */
+ 
+ /**
+  * struct iwl_scan_req_params_v11
+  * @general_params: &struct iwl_scan_general_params_v10
+  * @channel_params: &struct iwl_scan_channel_params_v3
+  * @periodic_params: &struct iwl_scan_periodic_parms_v1
+  * @probe_params: &struct iwl_scan_probe_params_v3
+  */
+ struct iwl_scan_req_params_v11 {
+ 	struct iwl_scan_general_params_v10 general_params;
+ 	struct iwl_scan_channel_params_v3 channel_params;
+ 	struct iwl_scan_periodic_parms_v1 periodic_params;
+ 	struct iwl_scan_probe_params_v3 probe_params;
+ } __packed; /* SCAN_REQUEST_PARAMS_API_S_VER_11 */
+ 
+ /**
+  * struct iwl_scan_req_params_v12
+  * @general_params: &struct iwl_scan_general_params_v10
+  * @channel_params: &struct iwl_scan_channel_params_v4
+  * @periodic_params: &struct iwl_scan_periodic_parms_v1
+  * @probe_params: &struct iwl_scan_probe_params_v3
+  */
+ struct iwl_scan_req_params_v12 {
+ 	struct iwl_scan_general_params_v10 general_params;
+ 	struct iwl_scan_channel_params_v4 channel_params;
+ 	struct iwl_scan_periodic_parms_v1 periodic_params;
+ 	struct iwl_scan_probe_params_v3 probe_params;
+ } __packed; /* SCAN_REQUEST_PARAMS_API_S_VER_12 */
+ 
+ /**
+  * struct iwl_scan_req_umac_v11
+  * @uid: scan id, &enum iwl_umac_scan_uid_offsets
+  * @ooc_priority: out of channel priority - &enum iwl_scan_priority
+  * @scan_params: scan parameters
+  */
+ struct iwl_scan_req_umac_v11 {
+ 	__le32 uid;
+ 	__le32 ooc_priority;
+ 	struct iwl_scan_req_params_v11 scan_params;
+ } __packed; /* SCAN_REQUEST_CMD_UMAC_API_S_VER_11 */
+ 
+ /**
+  * struct iwl_scan_req_umac_v12
+  * @uid: scan id, &enum iwl_umac_scan_uid_offsets
+  * @ooc_priority: out of channel priority - &enum iwl_scan_priority
+  * @scan_params: scan parameters
+  */
+ struct iwl_scan_req_umac_v12 {
+ 	__le32 uid;
+ 	__le32 ooc_priority;
+ 	struct iwl_scan_req_params_v12 scan_params;
+ } __packed; /* SCAN_REQUEST_CMD_UMAC_API_S_VER_12 */
+ 
+ /**
++>>>>>>> 5167ff45a503 (iwlwifi: scan: support scan req cmd ver 12)
   * struct iwl_umac_scan_abort
   * @uid: scan id, &enum iwl_umac_scan_uid_offsets
   * @flags: reserved
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/scan.c
index 3e5455cef0ee,60db911f1aac..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
@@@ -1405,6 -1407,160 +1409,163 @@@ static void iwl_mvm_scan_umac_dwell(str
  		cmd->ooc_priority = cpu_to_le32(IWL_SCAN_PRIORITY_EXT_2);
  }
  
++<<<<<<< HEAD
++=======
+ static u32 iwl_mvm_scan_umac_ooc_priority(struct iwl_mvm_scan_params *params)
+ {
+ 	return iwl_mvm_is_regular_scan(params) ?
+ 		IWL_SCAN_PRIORITY_EXT_6 :
+ 		IWL_SCAN_PRIORITY_EXT_2;
+ }
+ 
+ static void
+ iwl_mvm_scan_umac_dwell_v10(struct iwl_mvm *mvm,
+ 			    struct iwl_scan_general_params_v10 *general_params,
+ 			    struct iwl_mvm_scan_params *params)
+ {
+ 	struct iwl_mvm_scan_timing_params *timing, *hb_timing;
+ 	u8 active_dwell, passive_dwell;
+ 
+ 	timing = &scan_timing[params->type];
+ 	active_dwell = params->measurement_dwell ?
+ 		params->measurement_dwell : IWL_SCAN_DWELL_ACTIVE;
+ 	passive_dwell = params->measurement_dwell ?
+ 		params->measurement_dwell : IWL_SCAN_DWELL_PASSIVE;
+ 
+ 	general_params->adwell_default_social_chn =
+ 		IWL_SCAN_ADWELL_DEFAULT_N_APS_SOCIAL;
+ 	general_params->adwell_default_2g = IWL_SCAN_ADWELL_DEFAULT_LB_N_APS;
+ 	general_params->adwell_default_5g = IWL_SCAN_ADWELL_DEFAULT_HB_N_APS;
+ 
+ 	/* if custom max budget was configured with debugfs */
+ 	if (IWL_MVM_ADWELL_MAX_BUDGET)
+ 		general_params->adwell_max_budget =
+ 			cpu_to_le16(IWL_MVM_ADWELL_MAX_BUDGET);
+ 	else if (params->ssids && params->ssids[0].ssid_len)
+ 		general_params->adwell_max_budget =
+ 			cpu_to_le16(IWL_SCAN_ADWELL_MAX_BUDGET_DIRECTED_SCAN);
+ 	else
+ 		general_params->adwell_max_budget =
+ 			cpu_to_le16(IWL_SCAN_ADWELL_MAX_BUDGET_FULL_SCAN);
+ 
+ 	general_params->scan_priority = cpu_to_le32(IWL_SCAN_PRIORITY_EXT_6);
+ 	general_params->max_out_of_time[SCAN_LB_LMAC_IDX] =
+ 		cpu_to_le32(timing->max_out_time);
+ 	general_params->suspend_time[SCAN_LB_LMAC_IDX] =
+ 		cpu_to_le32(timing->suspend_time);
+ 
+ 	hb_timing = &scan_timing[params->hb_type];
+ 
+ 	general_params->max_out_of_time[SCAN_HB_LMAC_IDX] =
+ 		cpu_to_le32(hb_timing->max_out_time);
+ 	general_params->suspend_time[SCAN_HB_LMAC_IDX] =
+ 		cpu_to_le32(hb_timing->suspend_time);
+ 
+ 	general_params->active_dwell[SCAN_LB_LMAC_IDX] = active_dwell;
+ 	general_params->passive_dwell[SCAN_LB_LMAC_IDX] = passive_dwell;
+ 	general_params->active_dwell[SCAN_HB_LMAC_IDX] = active_dwell;
+ 	general_params->passive_dwell[SCAN_HB_LMAC_IDX] = passive_dwell;
+ }
+ 
+ struct iwl_mvm_scan_channel_segment {
+ 	u8 start_idx;
+ 	u8 end_idx;
+ 	u8 first_channel_id;
+ 	u8 last_channel_id;
+ 	u8 channel_spacing_shift;
+ 	u8 band;
+ };
+ 
+ static const struct iwl_mvm_scan_channel_segment scan_channel_segments[] = {
+ 	{
+ 		.start_idx = 0,
+ 		.end_idx = 13,
+ 		.first_channel_id = 1,
+ 		.last_channel_id = 14,
+ 		.channel_spacing_shift = 0,
+ 		.band = PHY_BAND_24
+ 	},
+ 	{
+ 		.start_idx = 14,
+ 		.end_idx = 41,
+ 		.first_channel_id = 36,
+ 		.last_channel_id = 144,
+ 		.channel_spacing_shift = 2,
+ 		.band = PHY_BAND_5
+ 	},
+ 	{
+ 		.start_idx = 42,
+ 		.end_idx = 50,
+ 		.first_channel_id = 149,
+ 		.last_channel_id = 181,
+ 		.channel_spacing_shift = 2,
+ 		.band = PHY_BAND_5
+ 	},
+ };
+ 
+ static int iwl_mvm_scan_ch_and_band_to_idx(u8 channel_id, u8 band)
+ {
+ 	int i, index;
+ 
+ 	if (!channel_id)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(scan_channel_segments); i++) {
+ 		const struct iwl_mvm_scan_channel_segment *ch_segment =
+ 			&scan_channel_segments[i];
+ 		u32 ch_offset;
+ 
+ 		if (ch_segment->band != band ||
+ 		    ch_segment->first_channel_id > channel_id ||
+ 		    ch_segment->last_channel_id < channel_id)
+ 			continue;
+ 
+ 		ch_offset = (channel_id - ch_segment->first_channel_id) >>
+ 			ch_segment->channel_spacing_shift;
+ 
+ 		index = scan_channel_segments[i].start_idx + ch_offset;
+ 		if (index < IWL_SCAN_NUM_CHANNELS)
+ 			return index;
+ 
+ 		break;
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
+ static void iwl_mvm_scan_ch_add_n_aps_override(enum nl80211_iftype vif_type,
+ 					       u8 ch_id, u8 band, u8 *ch_bitmap,
+ 					       size_t bitmap_n_entries)
+ {
+ 	int i;
+ 	static const u8 p2p_go_friendly_chs[] = {
+ 		36, 40, 44, 48, 149, 153, 157, 161, 165,
+ 	};
+ 
+ 	if (vif_type != NL80211_IFTYPE_P2P_DEVICE)
+ 		return;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(p2p_go_friendly_chs); i++) {
+ 		if (p2p_go_friendly_chs[i] == ch_id) {
+ 			int ch_idx, bitmap_idx;
+ 
+ 			ch_idx = iwl_mvm_scan_ch_and_band_to_idx(ch_id, band);
+ 			if (ch_idx < 0)
+ 				return;
+ 
+ 			bitmap_idx = ch_idx / 8;
+ 			if (bitmap_idx >= bitmap_n_entries)
+ 				return;
+ 
+ 			ch_idx = ch_idx % 8;
+ 			ch_bitmap[bitmap_idx] |= BIT(ch_idx);
+ 
+ 			return;
+ 		}
+ 	}
+ }
+ 
++>>>>>>> 5167ff45a503 (iwlwifi: scan: support scan req cmd ver 12)
  static void
  iwl_mvm_umac_scan_cfg_channels(struct iwl_mvm *mvm,
  			       struct ieee80211_channel **channels,
@@@ -1430,6 -1586,93 +1591,96 @@@
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ iwl_mvm_umac_scan_cfg_channels_v4(struct iwl_mvm *mvm,
+ 				  struct ieee80211_channel **channels,
+ 				  struct iwl_scan_channel_params_v4 *cp,
+ 				  int n_channels, u32 flags,
+ 				  enum nl80211_iftype vif_type)
+ {
+ 	u8 *bitmap = cp->adwell_ch_override_bitmap;
+ 	size_t bitmap_n_entries = ARRAY_SIZE(cp->adwell_ch_override_bitmap);
+ 	int i;
+ 
+ 	for (i = 0; i < n_channels; i++) {
+ 		enum nl80211_band band = channels[i]->band;
+ 		struct iwl_scan_channel_cfg_umac *cfg =
+ 			&cp->channel_config[i];
+ 
+ 		cfg->flags = cpu_to_le32(flags);
+ 		cfg->v2.channel_num = channels[i]->hw_value;
+ 		cfg->v2.band = iwl_mvm_phy_band_from_nl80211(band);
+ 		cfg->v2.iter_count = 1;
+ 		cfg->v2.iter_interval = 0;
+ 
+ 		iwl_mvm_scan_ch_add_n_aps_override(vif_type,
+ 						   cfg->v2.channel_num,
+ 						   cfg->v2.band, bitmap,
+ 						   bitmap_n_entries);
+ 	}
+ }
+ 
+ static u8 iwl_mvm_scan_umac_chan_flags_v2(struct iwl_mvm *mvm,
+ 					  struct iwl_mvm_scan_params *params,
+ 					  struct ieee80211_vif *vif)
+ {
+ 	u8 flags = 0;
+ 
+ 	flags |= IWL_SCAN_CHANNEL_FLAG_ENABLE_CHAN_ORDER;
+ 
+ 	if (iwl_mvm_scan_use_ebs(mvm, vif))
+ 		flags |= IWL_SCAN_CHANNEL_FLAG_EBS |
+ 			IWL_SCAN_CHANNEL_FLAG_EBS_ACCURATE |
+ 			IWL_SCAN_CHANNEL_FLAG_CACHE_ADD;
+ 
+ 	/* set fragmented ebs for fragmented scan on HB channels */
+ 	if (iwl_mvm_is_scan_fragmented(params->hb_type))
+ 		flags |= IWL_SCAN_CHANNEL_FLAG_EBS_FRAG;
+ 
+ 	return flags;
+ }
+ 
+ static u16 iwl_mvm_scan_umac_flags_v2(struct iwl_mvm *mvm,
+ 				      struct iwl_mvm_scan_params *params,
+ 				      struct ieee80211_vif *vif,
+ 				      int type)
+ {
+ 	u16 flags = 0;
+ 
+ 	if (params->n_ssids == 0)
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_FORCE_PASSIVE;
+ 
+ 	if (iwl_mvm_is_scan_fragmented(params->type))
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC1;
+ 
+ 	if (iwl_mvm_is_scan_fragmented(params->hb_type))
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC2;
+ 
+ 	if (params->pass_all)
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_PASS_ALL;
+ 	else
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_MATCH;
+ 
+ 	if (!iwl_mvm_is_regular_scan(params))
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_PERIODIC;
+ 
+ 	if (params->measurement_dwell ||
+ 	    mvm->sched_scan_pass_all == SCHED_SCAN_PASS_ALL_ENABLED)
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_NTFY_ITER_COMPLETE;
+ 
+ 	if (IWL_MVM_ADWELL_ENABLE &&
+ 	    vif->type != NL80211_IFTYPE_P2P_DEVICE)
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_ADAPTIVE_DWELL;
+ 
+ 	if (type == IWL_MVM_SCAN_SCHED || type == IWL_MVM_SCAN_NETDETECT)
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_PREEMPTIVE;
+ 
+ 	return flags;
+ }
+ 
++>>>>>>> 5167ff45a503 (iwlwifi: scan: support scan req cmd ver 12)
  static u16 iwl_mvm_scan_umac_flags(struct iwl_mvm *mvm,
  				   struct iwl_mvm_scan_params *params,
  				   struct ieee80211_vif *vif)
@@@ -1634,6 -1869,128 +1885,131 @@@ static int iwl_mvm_scan_umac(struct iwl
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ iwl_mvm_scan_umac_fill_general_p_v10(struct iwl_mvm *mvm,
+ 				     struct iwl_mvm_scan_params *params,
+ 				     struct ieee80211_vif *vif,
+ 				     struct iwl_scan_general_params_v10 *gp,
+ 				     u16 gen_flags)
+ {
+ 	struct iwl_mvm_vif *scan_vif = iwl_mvm_vif_from_mac80211(vif);
+ 
+ 	iwl_mvm_scan_umac_dwell_v10(mvm, gp, params);
+ 
+ 	gp->flags = cpu_to_le16(gen_flags);
+ 
+ 	if (gen_flags & IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC1)
+ 		gp->num_of_fragments[SCAN_LB_LMAC_IDX] = IWL_SCAN_NUM_OF_FRAGS;
+ 	if (gen_flags & IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC2)
+ 		gp->num_of_fragments[SCAN_HB_LMAC_IDX] = IWL_SCAN_NUM_OF_FRAGS;
+ 
+ 	gp->scan_start_mac_id = scan_vif->id;
+ }
+ 
+ static void
+ iwl_mvm_scan_umac_fill_probe_p_v3(struct iwl_mvm_scan_params *params,
+ 				  struct iwl_scan_probe_params_v3 *pp)
+ {
+ 	pp->preq = params->preq;
+ 	pp->ssid_num = params->n_ssids;
+ 	iwl_scan_build_ssids(params, pp->direct_scan, NULL);
+ }
+ 
+ static void
+ iwl_mvm_scan_umac_fill_ch_p_v3(struct iwl_mvm *mvm,
+ 			       struct iwl_mvm_scan_params *params,
+ 			       struct ieee80211_vif *vif,
+ 			       struct iwl_scan_channel_params_v3 *cp)
+ {
+ 	cp->flags = iwl_mvm_scan_umac_chan_flags_v2(mvm, params, vif);
+ 	cp->count = params->n_channels;
+ 
+ 	iwl_mvm_umac_scan_cfg_channels(mvm, params->channels,
+ 				       params->n_channels, 0,
+ 				       cp->channel_config);
+ }
+ 
+ static void
+ iwl_mvm_scan_umac_fill_ch_p_v4(struct iwl_mvm *mvm,
+ 			       struct iwl_mvm_scan_params *params,
+ 			       struct ieee80211_vif *vif,
+ 			       struct iwl_scan_channel_params_v4 *cp)
+ {
+ 	cp->flags = iwl_mvm_scan_umac_chan_flags_v2(mvm, params, vif);
+ 	cp->count = params->n_channels;
+ 	cp->num_of_aps_override = IWL_SCAN_ADWELL_DEFAULT_N_APS_OVERRIDE;
+ 
+ 	iwl_mvm_umac_scan_cfg_channels_v4(mvm, params->channels, cp,
+ 					  params->n_channels, 0, vif->type);
+ }
+ 
+ static int iwl_mvm_scan_umac_v11(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+ 				 struct iwl_mvm_scan_params *params, int type,
+ 				 int uid)
+ {
+ 	struct iwl_scan_req_umac_v11 *cmd = mvm->scan_cmd;
+ 	struct iwl_scan_req_params_v11 *scan_p = &cmd->scan_params;
+ 	int ret;
+ 	u16 gen_flags;
+ 
+ 	mvm->scan_uid_status[uid] = type;
+ 
+ 	cmd->ooc_priority = cpu_to_le32(iwl_mvm_scan_umac_ooc_priority(params));
+ 	cmd->uid = cpu_to_le32(uid);
+ 
+ 	gen_flags = iwl_mvm_scan_umac_flags_v2(mvm, params, vif, type);
+ 	iwl_mvm_scan_umac_fill_general_p_v10(mvm, params, vif,
+ 					     &scan_p->general_params,
+ 					     gen_flags);
+ 
+ 	 ret = iwl_mvm_fill_scan_sched_params(params,
+ 					      scan_p->periodic_params.schedule,
+ 					      &scan_p->periodic_params.delay);
+ 	if (ret)
+ 		return ret;
+ 
+ 	iwl_mvm_scan_umac_fill_probe_p_v3(params, &scan_p->probe_params);
+ 	iwl_mvm_scan_umac_fill_ch_p_v3(mvm, params, vif,
+ 				       &scan_p->channel_params);
+ 
+ 	return 0;
+ }
+ 
+ static int iwl_mvm_scan_umac_v12(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+ 				 struct iwl_mvm_scan_params *params, int type,
+ 				 int uid)
+ {
+ 	struct iwl_scan_req_umac_v12 *cmd = mvm->scan_cmd;
+ 	struct iwl_scan_req_params_v12 *scan_p = &cmd->scan_params;
+ 	int ret;
+ 	u16 gen_flags;
+ 
+ 	mvm->scan_uid_status[uid] = type;
+ 
+ 	cmd->ooc_priority = cpu_to_le32(iwl_mvm_scan_umac_ooc_priority(params));
+ 	cmd->uid = cpu_to_le32(uid);
+ 
+ 	gen_flags = iwl_mvm_scan_umac_flags_v2(mvm, params, vif, type);
+ 	iwl_mvm_scan_umac_fill_general_p_v10(mvm, params, vif,
+ 					     &scan_p->general_params,
+ 					     gen_flags);
+ 
+ 	 ret = iwl_mvm_fill_scan_sched_params(params,
+ 					      scan_p->periodic_params.schedule,
+ 					      &scan_p->periodic_params.delay);
+ 	if (ret)
+ 		return ret;
+ 
+ 	iwl_mvm_scan_umac_fill_probe_p_v3(params, &scan_p->probe_params);
+ 	iwl_mvm_scan_umac_fill_ch_p_v4(mvm, params, vif,
+ 				       &scan_p->channel_params);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 5167ff45a503 (iwlwifi: scan: support scan req cmd ver 12)
  static int iwl_mvm_num_scans(struct iwl_mvm *mvm)
  {
  	return hweight32(mvm->scan_status & IWL_MVM_SCAN_MASK);
@@@ -1736,6 -2093,23 +2112,26 @@@ static void iwl_mvm_fill_scan_type(stru
  	}
  }
  
++<<<<<<< HEAD
++=======
+ struct iwl_scan_umac_handler {
+ 	u8 version;
+ 	int (*handler)(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+ 		       struct iwl_mvm_scan_params *params, int type, int uid);
+ };
+ 
+ #define IWL_SCAN_UMAC_HANDLER(_ver) {		\
+ 	.version = _ver,			\
+ 	.handler = iwl_mvm_scan_umac_v##_ver,	\
+ }
+ 
+ static const struct iwl_scan_umac_handler iwl_scan_umac_handlers[] = {
+ 	/* set the newest version first to shorten the list traverse time */
+ 	IWL_SCAN_UMAC_HANDLER(12),
+ 	IWL_SCAN_UMAC_HANDLER(11),
+ };
+ 
++>>>>>>> 5167ff45a503 (iwlwifi: scan: support scan req cmd ver 12)
  static int iwl_mvm_build_scan_cmd(struct iwl_mvm *mvm,
  				  struct ieee80211_vif *vif,
  				  struct iwl_host_cmd *hcmd,
@@@ -2057,10 -2457,30 +2453,27 @@@ static int iwl_mvm_scan_stop_wait(struc
  				     1 * HZ);
  }
  
++<<<<<<< HEAD
++=======
+ #define IWL_SCAN_REQ_UMAC_HANDLE_SIZE(_ver) {				\
+ 	case (_ver): return sizeof(struct iwl_scan_req_umac_v##_ver);	\
+ }
+ 
+ static int iwl_scan_req_umac_get_size(u8 scan_ver)
+ {
+ 	switch (scan_ver) {
+ 		IWL_SCAN_REQ_UMAC_HANDLE_SIZE(12);
+ 		IWL_SCAN_REQ_UMAC_HANDLE_SIZE(11);
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 5167ff45a503 (iwlwifi: scan: support scan req cmd ver 12)
  int iwl_mvm_scan_size(struct iwl_mvm *mvm)
  {
 -	int base_size, tail_size;
 -	u8 scan_ver = iwl_mvm_lookup_cmd_ver(mvm->fw, IWL_ALWAYS_LONG_GROUP,
 -					     SCAN_REQ_UMAC);
 -
 -	base_size = iwl_scan_req_umac_get_size(scan_ver);
 -	if (base_size)
 -		return base_size;
 -
 +	int base_size = IWL_SCAN_REQ_UMAC_SIZE_V1;
 +	int tail_size;
  
  	if (iwl_mvm_is_adaptive_dwell_v2_supported(mvm))
  		base_size = IWL_SCAN_REQ_UMAC_SIZE_V8;
* Unmerged path drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/scan.c
