scsi: lpfc: Fix scsi host template for SLI3 vports

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author James Smart <jsmart2021@gmail.com>
commit c90b448023582200c54595232e7c004c93d52ae1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c90b4480.failed

SCSI layer sends driver IOs with more s/g segments than driver can handle.
This results in "Too many sg segments from dma_map_sg. Config 64, seg_cnt
219" error messages from the lpfc_scsi_prep_dma_buf_s3() routine.

The was due to use the driver using individual templates for pport and
vport, host reset enabled or not, nvme vs scsi, etc. In the end, there was
a combination for a vport that didn't match the pport.

Rather than enumerating more templates and more discretionary assignments,
revert to a base template that is copied to a template specific to the
pport/vport. Then, based on role, attributes and sli type, modify the
fields that are different for that port.  Added a log message to
lpfc_create_port to validate values.

Link: https://lore.kernel.org/r/20200322181304.37655-5-jsmart2021@gmail.com
	Signed-off-by: James Smart <jsmart2021@gmail.com>
	Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit c90b448023582200c54595232e7c004c93d52ae1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_scsi.c
diff --cc drivers/scsi/lpfc/lpfc_scsi.c
index c734352c442f,be62795715f7..000000000000
--- a/drivers/scsi/lpfc/lpfc_scsi.c
+++ b/drivers/scsi/lpfc/lpfc_scsi.c
@@@ -6032,32 -6023,6 +6032,35 @@@ struct scsi_host_template lpfc_template
  	.track_queue_depth	= 0,
  };
  
++<<<<<<< HEAD
 +struct scsi_host_template lpfc_template_no_hr = {
 +	.module			= THIS_MODULE,
 +	.name			= LPFC_DRIVER_NAME,
 +	.proc_name		= LPFC_DRIVER_NAME,
 +	.info			= lpfc_info,
 +	.queuecommand		= lpfc_queuecommand,
 +	.eh_timed_out		= fc_eh_timed_out,
 +	.eh_abort_handler	= lpfc_abort_handler,
 +	.eh_device_reset_handler = lpfc_device_reset_handler,
 +	.eh_target_reset_handler = lpfc_target_reset_handler,
 +	.eh_bus_reset_handler	= lpfc_bus_reset_handler,
 +	.slave_alloc		= lpfc_slave_alloc,
 +	.slave_configure	= lpfc_slave_configure,
 +	.slave_destroy		= lpfc_slave_destroy,
 +	.scan_finished		= lpfc_scan_finished,
 +	.this_id		= -1,
 +	.sg_tablesize		= LPFC_DEFAULT_SG_SEG_CNT,
 +	.cmd_per_lun		= LPFC_CMD_PER_LUN,
 +	.use_clustering		= ENABLE_CLUSTERING,
 +	.shost_attrs		= lpfc_hba_attrs,
 +	.max_sectors		= 0xFFFFFFFF,
 +	.vendor_id		= LPFC_NL_VENDOR_ID,
 +	.change_queue_depth	= scsi_change_queue_depth,
 +	.track_queue_depth	= 1,
 +};
 +
++=======
++>>>>>>> c90b44802358 (scsi: lpfc: Fix scsi host template for SLI3 vports)
  struct scsi_host_template lpfc_template = {
  	.module			= THIS_MODULE,
  	.name			= LPFC_DRIVER_NAME,
@@@ -6084,27 -6048,3 +6087,30 @@@
  	.change_queue_depth	= scsi_change_queue_depth,
  	.track_queue_depth	= 1,
  };
++<<<<<<< HEAD
 +
 +struct scsi_host_template lpfc_vport_template = {
 +	.module			= THIS_MODULE,
 +	.name			= LPFC_DRIVER_NAME,
 +	.proc_name		= LPFC_DRIVER_NAME,
 +	.info			= lpfc_info,
 +	.queuecommand		= lpfc_queuecommand,
 +	.eh_timed_out		= fc_eh_timed_out,
 +	.eh_abort_handler	= lpfc_abort_handler,
 +	.eh_device_reset_handler = lpfc_device_reset_handler,
 +	.eh_target_reset_handler = lpfc_target_reset_handler,
 +	.slave_alloc		= lpfc_slave_alloc,
 +	.slave_configure	= lpfc_slave_configure,
 +	.slave_destroy		= lpfc_slave_destroy,
 +	.scan_finished		= lpfc_scan_finished,
 +	.this_id		= -1,
 +	.sg_tablesize		= LPFC_DEFAULT_SG_SEG_CNT,
 +	.cmd_per_lun		= LPFC_CMD_PER_LUN,
 +	.use_clustering		= ENABLE_CLUSTERING,
 +	.shost_attrs		= lpfc_vport_attrs,
 +	.max_sectors		= 0xFFFF,
 +	.change_queue_depth	= scsi_change_queue_depth,
 +	.track_queue_depth	= 1,
 +};
++=======
++>>>>>>> c90b44802358 (scsi: lpfc: Fix scsi host template for SLI3 vports)
diff --git a/drivers/scsi/lpfc/lpfc.h b/drivers/scsi/lpfc/lpfc.h
index 354d92f4338d..45657a7502f6 100644
--- a/drivers/scsi/lpfc/lpfc.h
+++ b/drivers/scsi/lpfc/lpfc.h
@@ -1232,6 +1232,11 @@ struct lpfc_hba {
 #define LPFC_POLL_SLOWPATH	1	/* called from slowpath */
 
 	char os_host_name[MAXHOSTNAMELEN];
+
+	/* SCSI host template information - for physical port */
+	struct scsi_host_template port_template;
+	/* SCSI host template information - for all vports */
+	struct scsi_host_template vport_template;
 };
 
 static inline struct Scsi_Host *
diff --git a/drivers/scsi/lpfc/lpfc_crtn.h b/drivers/scsi/lpfc/lpfc_crtn.h
index 76e291128d4e..37f8d8f8aa1c 100644
--- a/drivers/scsi/lpfc/lpfc_crtn.h
+++ b/drivers/scsi/lpfc/lpfc_crtn.h
@@ -404,9 +404,7 @@ void lpfc_free_sysfs_attr(struct lpfc_vport *);
 extern struct device_attribute *lpfc_hba_attrs[];
 extern struct device_attribute *lpfc_vport_attrs[];
 extern struct scsi_host_template lpfc_template;
-extern struct scsi_host_template lpfc_template_no_hr;
 extern struct scsi_host_template lpfc_template_nvme;
-extern struct scsi_host_template lpfc_vport_template;
 extern struct fc_function_template lpfc_transport_functions;
 extern struct fc_function_template lpfc_vport_transport_functions;
 
diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c
index 2d8134ee1cd8..fdb4dfe04b91 100644
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@ -4105,6 +4105,7 @@ lpfc_create_port(struct lpfc_hba *phba, int instance, struct device *dev)
 {
 	struct lpfc_vport *vport;
 	struct Scsi_Host  *shost = NULL;
+	struct scsi_host_template *template;
 	int error = 0;
 	int i;
 	uint64_t wwn;
@@ -4133,22 +4134,50 @@ lpfc_create_port(struct lpfc_hba *phba, int instance, struct device *dev)
 		}
 	}
 
-	if (phba->cfg_enable_fc4_type & LPFC_ENABLE_FCP) {
-		if (dev != &phba->pcidev->dev) {
-			shost = scsi_host_alloc(&lpfc_vport_template,
-						sizeof(struct lpfc_vport));
+	/* Seed template for SCSI host registration */
+	if (dev == &phba->pcidev->dev) {
+		template = &phba->port_template;
+
+		if (phba->cfg_enable_fc4_type & LPFC_ENABLE_FCP) {
+			/* Seed physical port template */
+			memcpy(template, &lpfc_template, sizeof(*template));
+
+			if (use_no_reset_hba) {
+				/* template is for a no reset SCSI Host */
+				template->max_sectors = 0xffff;
+				template->eh_host_reset_handler = NULL;
+			}
+
+			/* Template for all vports this physical port creates */
+			memcpy(&phba->vport_template, &lpfc_template,
+			       sizeof(*template));
+			phba->vport_template.max_sectors = 0xffff;
+			phba->vport_template.shost_attrs = lpfc_vport_attrs;
+			phba->vport_template.eh_bus_reset_handler = NULL;
+			phba->vport_template.eh_host_reset_handler = NULL;
+			phba->vport_template.vendor_id = 0;
+
+			/* Initialize the host templates with updated value */
+			if (phba->sli_rev == LPFC_SLI_REV4) {
+				template->sg_tablesize = phba->cfg_scsi_seg_cnt;
+				phba->vport_template.sg_tablesize =
+					phba->cfg_scsi_seg_cnt;
+			} else {
+				template->sg_tablesize = phba->cfg_sg_seg_cnt;
+				phba->vport_template.sg_tablesize =
+					phba->cfg_sg_seg_cnt;
+			}
+
 		} else {
-			if (!use_no_reset_hba)
-				shost = scsi_host_alloc(&lpfc_template,
-						sizeof(struct lpfc_vport));
-			else
-				shost = scsi_host_alloc(&lpfc_template_no_hr,
-						sizeof(struct lpfc_vport));
+			/* NVMET is for physical port only */
+			memcpy(template, &lpfc_template_nvme,
+			       sizeof(*template));
 		}
-	} else if (phba->cfg_enable_fc4_type & LPFC_ENABLE_NVME) {
-		shost = scsi_host_alloc(&lpfc_template_nvme,
-					sizeof(struct lpfc_vport));
+	} else {
+		template = &phba->vport_template;
 	}
+
+	shost = scsi_host_alloc(template, sizeof(struct lpfc_vport));
 	if (!shost)
 		goto out;
 
@@ -4203,6 +4232,12 @@ lpfc_create_port(struct lpfc_hba *phba, int instance, struct device *dev)
 		vport->port_type = LPFC_PHYSICAL_PORT;
 	}
 
+	lpfc_printf_log(phba, KERN_INFO, LOG_INIT | LOG_FCP,
+			"9081 CreatePort TMPLATE type %x TBLsize %d "
+			"SEGcnt %d/%d\n",
+			vport->port_type, shost->sg_tablesize,
+			phba->cfg_scsi_seg_cnt, phba->cfg_sg_seg_cnt);
+
 	/* Initialize all internally managed lists. */
 	INIT_LIST_HEAD(&vport->fc_nodes);
 	INIT_LIST_HEAD(&vport->rcv_buffer_list);
@@ -6145,11 +6180,6 @@ lpfc_sli_driver_resource_setup(struct lpfc_hba *phba)
 	 * used to create the sg_dma_buf_pool must be dynamically calculated.
 	 */
 
-	/* Initialize the host templates the configured values. */
-	lpfc_vport_template.sg_tablesize = phba->cfg_sg_seg_cnt;
-	lpfc_template_no_hr.sg_tablesize = phba->cfg_sg_seg_cnt;
-	lpfc_template.sg_tablesize = phba->cfg_sg_seg_cnt;
-
 	if (phba->sli_rev == LPFC_SLI_REV4)
 		entry_sz = sizeof(struct sli4_sge);
 	else
@@ -6190,7 +6220,7 @@ lpfc_sli_driver_resource_setup(struct lpfc_hba *phba)
 	}
 
 	lpfc_printf_log(phba, KERN_INFO, LOG_INIT | LOG_FCP,
-			"9088 sg_tablesize:%d dmabuf_size:%d total_bde:%d\n",
+			"9088 INIT sg_tablesize:%d dmabuf_size:%d total_bde:%d\n",
 			phba->cfg_sg_seg_cnt, phba->cfg_sg_dma_buf_size,
 			phba->cfg_total_seg_cnt);
 
@@ -6666,11 +6696,6 @@ lpfc_sli4_driver_resource_setup(struct lpfc_hba *phba)
 			phba->cfg_nvme_seg_cnt = phba->cfg_sg_seg_cnt;
 	}
 
-	/* Initialize the host templates with the updated values. */
-	lpfc_vport_template.sg_tablesize = phba->cfg_scsi_seg_cnt;
-	lpfc_template.sg_tablesize = phba->cfg_scsi_seg_cnt;
-	lpfc_template_no_hr.sg_tablesize = phba->cfg_scsi_seg_cnt;
-
 	lpfc_printf_log(phba, KERN_INFO, LOG_INIT | LOG_FCP,
 			"9087 sg_seg_cnt:%d dmabuf_size:%d "
 			"total:%d scsi:%d nvme:%d\n",
* Unmerged path drivers/scsi/lpfc/lpfc_scsi.c
