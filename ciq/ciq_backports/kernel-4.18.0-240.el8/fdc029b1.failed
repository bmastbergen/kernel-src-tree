memremap: remove the dev field in struct dev_pagemap

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Christoph Hellwig <hch@lst.de>
commit fdc029b19dfd190840d23e5c70bd231140b0e4a4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/fdc029b1.failed

The dev field in struct dev_pagemap is only used to print dev_name in two
places, which are at best nice to have.  Just remove the field and thus
the name in those two messages.

Link: https://lore.kernel.org/r/20190818090557.17853-3-hch@lst.de
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Ira Weiny <ira.weiny@intel.com>
	Reviewed-by: Dan Williams <dan.j.williams@intel.com>
	Tested-by: Bharata B Rao <bharata@linux.ibm.com>
	Reviewed-by: Jason Gunthorpe <jgg@mellanox.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit fdc029b19dfd190840d23e5c70bd231140b0e4a4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/memremap.h
#	mm/page_alloc.c
diff --cc include/linux/memremap.h
index 1154c9232ff2,8f0013e18e14..000000000000
--- a/include/linux/memremap.h
+++ b/include/linux/memremap.h
@@@ -122,20 -104,15 +122,25 @@@ struct dev_pagemap_ops 
   * @ops: method table
   */
  struct dev_pagemap {
 +	RH_KABI_DEPRECATE(dev_page_fault_t, page_fault)
 +	RH_KABI_DEPRECATE(dev_page_free_t, page_free)
  	struct vmem_altmap altmap;
 +	RH_KABI_DEPRECATE(bool, altmap_valid)
  	struct resource res;
  	struct percpu_ref *ref;
++<<<<<<< HEAD
 +	struct device *dev;
 +	RH_KABI_DEPRECATE(void *, data)
++=======
+ 	struct percpu_ref internal_ref;
+ 	struct completion done;
++>>>>>>> fdc029b19dfd (memremap: remove the dev field in struct dev_pagemap)
  	enum memory_type type;
 -	unsigned int flags;
  	u64 pci_p2pdma_bus_offset;
 -	const struct dev_pagemap_ops *ops;
 +	RH_KABI_EXTEND(const struct dev_pagemap_ops *ops)
 +	RH_KABI_EXTEND(unsigned int flags)
 +	RH_KABI_EXTEND(struct percpu_ref internal_ref)
 +	RH_KABI_EXTEND(struct completion done)
  };
  
  static inline struct vmem_altmap *pgmap_altmap(struct dev_pagemap *pgmap)
diff --cc mm/page_alloc.c
index da754b26a5b4,b39baa2b1faf..000000000000
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@@ -5740,7 -5983,7 +5740,11 @@@ void __ref memmap_init_zone_device(stru
  	}
  
  	pr_info("%s initialised %lu pages in %ums\n", __func__,
++<<<<<<< HEAD
 +		nr_pages, jiffies_to_msecs(jiffies - start));
++=======
+ 		size, jiffies_to_msecs(jiffies - start));
++>>>>>>> fdc029b19dfd (memremap: remove the dev field in struct dev_pagemap)
  }
  
  #endif
* Unmerged path include/linux/memremap.h
diff --git a/mm/memremap.c b/mm/memremap.c
index 2b401bc84cda..4d9d087026af 100644
--- a/mm/memremap.c
+++ b/mm/memremap.c
@@ -100,7 +100,6 @@ static void dev_pagemap_cleanup(struct dev_pagemap *pgmap)
 static void devm_memremap_pages_release(void *data)
 {
 	struct dev_pagemap *pgmap = data;
-	struct device *dev = pgmap->dev;
 	struct resource *res = &pgmap->res;
 	struct page *first_page;
 	unsigned long pfn;
@@ -132,8 +131,7 @@ static void devm_memremap_pages_release(void *data)
 
 	untrack_pfn(NULL, PHYS_PFN(res->start), resource_size(res));
 	pgmap_array_delete(res);
-	dev_WARN_ONCE(dev, pgmap->altmap.alloc,
-		      "%s: failed to free all reserved pages\n", __func__);
+	WARN_ONCE(pgmap->altmap.alloc, "failed to free all reserved pages\n");
 }
 
 static void dev_pagemap_percpu_release(struct percpu_ref *ref)
@@ -254,8 +252,6 @@ void *devm_memremap_pages(struct device *dev, struct dev_pagemap *pgmap)
 		goto err_array;
 	}
 
-	pgmap->dev = dev;
-
 	error = xa_err(xa_store_range(&pgmap_array, PHYS_PFN(res->start),
 				PHYS_PFN(res->end), pgmap, GFP_KERNEL));
 	if (error)
* Unmerged path mm/page_alloc.c
diff --git a/tools/testing/nvdimm/test/iomap.c b/tools/testing/nvdimm/test/iomap.c
index f4cd15b6f930..033d1c39e5ef 100644
--- a/tools/testing/nvdimm/test/iomap.c
+++ b/tools/testing/nvdimm/test/iomap.c
@@ -140,7 +140,6 @@ void *__wrap_devm_memremap_pages(struct device *dev, struct dev_pagemap *pgmap)
 	if (!nfit_res)
 		return devm_memremap_pages(dev, pgmap);
 
-	pgmap->dev = dev;
 	if (!pgmap->ref) {
 		if (pgmap->ops && (pgmap->ops->kill || pgmap->ops->cleanup))
 			return ERR_PTR(-EINVAL);
