io_uring: fix missing ->mm on exit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pavel Begunkov <asml.silence@gmail.com>
commit 8eb06d7e8dd853d70668617dda57de4f6cebe651
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8eb06d7e.failed

There is a fancy bug, where exiting user task may not have ->mm,
that makes task_works to try to do kthread_use_mm(ctx->sqo_mm).

Don't do that if sqo_mm is NULL.

[  290.460558] WARNING: CPU: 6 PID: 150933 at kernel/kthread.c:1238
	kthread_use_mm+0xf3/0x110
[  290.460579] CPU: 6 PID: 150933 Comm: read-write2 Tainted: G
	I E     5.8.0-rc2-00066-g9b21720607cf #531
[  290.460580] RIP: 0010:kthread_use_mm+0xf3/0x110
...
[  290.460584] Call Trace:
[  290.460584]  __io_sq_thread_acquire_mm.isra.0.part.0+0x25/0x30
[  290.460584]  __io_req_task_submit+0x64/0x80
[  290.460584]  io_req_task_submit+0x15/0x20
[  290.460585]  task_work_run+0x67/0xa0
[  290.460585]  do_exit+0x35d/0xb70
[  290.460585]  do_group_exit+0x43/0xa0
[  290.460585]  get_signal+0x140/0x900
[  290.460586]  do_signal+0x37/0x780
[  290.460586]  __prepare_exit_to_usermode+0x126/0x1c0
[  290.460586]  __syscall_return_slowpath+0x3b/0x1c0
[  290.460587]  do_syscall_64+0x5f/0xa0
[  290.460587]  entry_SYSCALL_64_after_hwframe+0x44/0xa9

following with faults.

	Signed-off-by: Pavel Begunkov <asml.silence@gmail.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 8eb06d7e8dd853d70668617dda57de4f6cebe651)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 0b681a205810,cfad2acd4d86..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -386,6 -930,76 +386,79 @@@ struct sock *io_uring_get_socket(struc
  }
  EXPORT_SYMBOL(io_uring_get_socket);
  
++<<<<<<< HEAD
++=======
+ static void io_get_req_task(struct io_kiocb *req)
+ {
+ 	if (req->flags & REQ_F_TASK_PINNED)
+ 		return;
+ 	get_task_struct(req->task);
+ 	req->flags |= REQ_F_TASK_PINNED;
+ }
+ 
+ /* not idempotent -- it doesn't clear REQ_F_TASK_PINNED */
+ static void __io_put_req_task(struct io_kiocb *req)
+ {
+ 	if (req->flags & REQ_F_TASK_PINNED)
+ 		put_task_struct(req->task);
+ }
+ 
+ static void io_sq_thread_drop_mm(struct io_ring_ctx *ctx)
+ {
+ 	struct mm_struct *mm = current->mm;
+ 
+ 	if (mm) {
+ 		kthread_unuse_mm(mm);
+ 		mmput(mm);
+ 	}
+ }
+ 
+ static int __io_sq_thread_acquire_mm(struct io_ring_ctx *ctx)
+ {
+ 	if (!current->mm) {
+ 		if (unlikely(!ctx->sqo_mm || !mmget_not_zero(ctx->sqo_mm)))
+ 			return -EFAULT;
+ 		kthread_use_mm(ctx->sqo_mm);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int io_sq_thread_acquire_mm(struct io_ring_ctx *ctx,
+ 				   struct io_kiocb *req)
+ {
+ 	if (!io_op_defs[req->opcode].needs_mm)
+ 		return 0;
+ 	return __io_sq_thread_acquire_mm(ctx);
+ }
+ 
+ static inline void req_set_fail_links(struct io_kiocb *req)
+ {
+ 	if ((req->flags & (REQ_F_LINK | REQ_F_HARDLINK)) == REQ_F_LINK)
+ 		req->flags |= REQ_F_FAIL_LINK;
+ }
+ 
+ static void io_file_put_work(struct work_struct *work);
+ 
+ /*
+  * Note: must call io_req_init_async() for the first time you
+  * touch any members of io_wq_work.
+  */
+ static inline void io_req_init_async(struct io_kiocb *req)
+ {
+ 	if (req->flags & REQ_F_WORK_INITIALIZED)
+ 		return;
+ 
+ 	memset(&req->work, 0, sizeof(req->work));
+ 	req->flags |= REQ_F_WORK_INITIALIZED;
+ }
+ 
+ static inline bool io_async_submit(struct io_ring_ctx *ctx)
+ {
+ 	return ctx->flags & IORING_SETUP_SQPOLL;
+ }
+ 
++>>>>>>> 8eb06d7e8dd8 (io_uring: fix missing ->mm on exit)
  static void io_ring_ctx_ref_free(struct percpu_ref *ref)
  {
  	struct io_ring_ctx *ctx = container_of(ref, struct io_ring_ctx, refs);
* Unmerged path fs/io_uring.c
