io_uring: mark us with IORING_FEAT_SUBMIT_STABLE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit da8c96906990f1108cb626ee7865e69267a3263b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/da8c9690.failed

If this flag is set, applications can be certain that any data for
async offload has been consumed when the kernel has consumed the
SQE.

	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit da8c96906990f1108cb626ee7865e69267a3263b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
#	include/uapi/linux/io_uring.h
diff --cc fs/io_uring.c
index 671f4f0982a1,c47a08afcee5..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -3844,22 -5077,9 +3844,28 @@@ static int io_uring_create(unsigned ent
  	if (ret < 0)
  		goto err;
  
++<<<<<<< HEAD
 +	memset(&p->sq_off, 0, sizeof(p->sq_off));
 +	p->sq_off.head = offsetof(struct io_sq_ring, r.head);
 +	p->sq_off.tail = offsetof(struct io_sq_ring, r.tail);
 +	p->sq_off.ring_mask = offsetof(struct io_sq_ring, ring_mask);
 +	p->sq_off.ring_entries = offsetof(struct io_sq_ring, ring_entries);
 +	p->sq_off.flags = offsetof(struct io_sq_ring, flags);
 +	p->sq_off.dropped = offsetof(struct io_sq_ring, dropped);
 +	p->sq_off.array = offsetof(struct io_sq_ring, array);
 +
 +	memset(&p->cq_off, 0, sizeof(p->cq_off));
 +	p->cq_off.head = offsetof(struct io_cq_ring, r.head);
 +	p->cq_off.tail = offsetof(struct io_cq_ring, r.tail);
 +	p->cq_off.ring_mask = offsetof(struct io_cq_ring, ring_mask);
 +	p->cq_off.ring_entries = offsetof(struct io_cq_ring, ring_entries);
 +	p->cq_off.overflow = offsetof(struct io_cq_ring, overflow);
 +	p->cq_off.cqes = offsetof(struct io_cq_ring, cqes);
++=======
+ 	p->features = IORING_FEAT_SINGLE_MMAP | IORING_FEAT_NODROP |
+ 			IORING_FEAT_SUBMIT_STABLE;
+ 	trace_io_uring_create(ret, ctx, p->sq_entries, p->cq_entries, p->flags);
++>>>>>>> da8c96906990 (io_uring: mark us with IORING_FEAT_SUBMIT_STABLE)
  	return ret;
  err:
  	io_ring_ctx_wait_and_kill(ctx);
diff --cc include/uapi/linux/io_uring.h
index ee8693aec163,eabccb46edd1..000000000000
--- a/include/uapi/linux/io_uring.h
+++ b/include/uapi/linux/io_uring.h
@@@ -135,6 -153,13 +135,16 @@@ struct io_uring_params 
  };
  
  /*
++<<<<<<< HEAD
++=======
+  * io_uring_params->features flags
+  */
+ #define IORING_FEAT_SINGLE_MMAP		(1U << 0)
+ #define IORING_FEAT_NODROP		(1U << 1)
+ #define IORING_FEAT_SUBMIT_STABLE	(1U << 2)
+ 
+ /*
++>>>>>>> da8c96906990 (io_uring: mark us with IORING_FEAT_SUBMIT_STABLE)
   * io_uring_register(2) opcodes and arguments
   */
  #define IORING_REGISTER_BUFFERS		0
* Unmerged path fs/io_uring.c
* Unmerged path include/uapi/linux/io_uring.h
