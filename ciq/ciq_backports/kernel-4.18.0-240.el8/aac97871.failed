drm/i915: Introduce intel_calc_active_pipes()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit aac978718bb480fee1b4a577727c0c06e7ae65db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/aac97871.failed

Extract a small helper to compute the active pipes bitmask
based on the old bitmask + the crtcs in the atomic state.
I want to decouple the cdclk state entirely from the current
global state so I want to track the active pipes also inside
the (to be introduced) full cdclk state.

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200120174728.21095-17-ville.syrjala@linux.intel.com
	Reviewed-by: Imre Deak <imre.deak@intel.com>
(cherry picked from commit aac978718bb480fee1b4a577727c0c06e7ae65db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display.c
#	drivers/gpu/drm/i915/display/intel_display.h
diff --cc drivers/gpu/drm/i915/display/intel_display.c
index 5c8c11deb857,c6d764b5dc44..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.c
+++ b/drivers/gpu/drm/i915/display/intel_display.c
@@@ -13274,153 -14540,42 +13274,180 @@@ static int haswell_mode_set_planes_work
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int intel_lock_all_pipes(struct drm_atomic_state *state)
 +{
 +	struct drm_crtc *crtc;
 +
 +	/* Add all pipes to the state */
 +	for_each_crtc(state->dev, crtc) {
 +		struct drm_crtc_state *crtc_state;
 +
 +		crtc_state = drm_atomic_get_crtc_state(state, crtc);
 +		if (IS_ERR(crtc_state))
 +			return PTR_ERR(crtc_state);
 +	}
 +
 +	return 0;
 +}
 +
 +static int intel_modeset_all_pipes(struct drm_atomic_state *state)
 +{
 +	struct drm_crtc *crtc;
 +
 +	/*
 +	 * Add all pipes to the state, and force
 +	 * a modeset on all the active ones.
 +	 */
 +	for_each_crtc(state->dev, crtc) {
 +		struct drm_crtc_state *crtc_state;
 +		int ret;
 +
 +		crtc_state = drm_atomic_get_crtc_state(state, crtc);
 +		if (IS_ERR(crtc_state))
 +			return PTR_ERR(crtc_state);
 +
 +		if (!crtc_state->active || needs_modeset(crtc_state))
 +			continue;
 +
 +		crtc_state->mode_changed = true;
 +
 +		ret = drm_atomic_add_affected_connectors(state, crtc);
 +		if (ret)
 +			return ret;
 +
 +		ret = drm_atomic_add_affected_planes(state, crtc);
 +		if (ret)
 +			return ret;
 +	}
 +
 +	return 0;
++=======
+ u8 intel_calc_active_pipes(struct intel_atomic_state *state,
+ 			   u8 active_pipes)
+ {
+ 	const struct intel_crtc_state *crtc_state;
+ 	struct intel_crtc *crtc;
+ 	int i;
+ 
+ 	for_each_new_intel_crtc_in_state(state, crtc, crtc_state, i) {
+ 		if (crtc_state->hw.active)
+ 			active_pipes |= BIT(crtc->pipe);
+ 		else
+ 			active_pipes &= ~BIT(crtc->pipe);
+ 	}
+ 
+ 	return active_pipes;
++>>>>>>> aac978718bb4 (drm/i915: Introduce intel_calc_active_pipes())
  }
  
  static int intel_modeset_checks(struct intel_atomic_state *state)
  {
  	struct drm_i915_private *dev_priv = to_i915(state->base.dev);
++<<<<<<< HEAD
 +	struct intel_crtc_state *old_crtc_state, *new_crtc_state;
 +	struct intel_crtc *crtc;
 +	int ret = 0, i;
 +
 +	if (!check_digital_port_conflicts(state)) {
 +		DRM_DEBUG_KMS("rejecting conflicting digital port configuration\n");
 +		return -EINVAL;
 +	}
 +
 +	/* keep the current setting */
 +	if (!state->cdclk.force_min_cdclk_changed)
 +		state->cdclk.force_min_cdclk = dev_priv->cdclk.force_min_cdclk;
 +
 +	state->modeset = true;
 +	state->active_crtcs = dev_priv->active_crtcs;
 +	state->cdclk.logical = dev_priv->cdclk.logical;
 +	state->cdclk.actual = dev_priv->cdclk.actual;
 +	state->cdclk.pipe = INVALID_PIPE;
 +
 +	for_each_oldnew_intel_crtc_in_state(state, crtc, old_crtc_state,
 +					    new_crtc_state, i) {
 +		if (new_crtc_state->base.active)
 +			state->active_crtcs |= 1 << i;
 +		else
 +			state->active_crtcs &= ~(1 << i);
 +
 +		if (old_crtc_state->base.active != new_crtc_state->base.active)
 +			state->active_pipe_changes |= drm_crtc_mask(&crtc->base);
 +	}
++=======
+ 	int ret;
+ 
+ 	state->modeset = true;
+ 	state->active_pipes = intel_calc_active_pipes(state, dev_priv->active_pipes);
+ 
+ 	state->active_pipe_changes = state->active_pipes ^ dev_priv->active_pipes;
++>>>>>>> aac978718bb4 (drm/i915: Introduce intel_calc_active_pipes())
  
 -	if (state->active_pipe_changes) {
 -		ret = _intel_atomic_lock_global_state(state);
 -		if (ret)
 +	/*
 +	 * See if the config requires any additional preparation, e.g.
 +	 * to adjust global state with pipes off.  We need to do this
 +	 * here so we can get the modeset_pipe updated config for the new
 +	 * mode set on this crtc.  For other crtcs we need to use the
 +	 * adjusted_mode bits in the crtc directly.
 +	 */
 +	if (dev_priv->display.modeset_calc_cdclk) {
 +		enum pipe pipe;
 +
 +		ret = dev_priv->display.modeset_calc_cdclk(state);
 +		if (ret < 0)
  			return ret;
 -	}
  
 -	ret = intel_modeset_calc_cdclk(state);
 -	if (ret)
 -		return ret;
 +		/*
 +		 * Writes to dev_priv->cdclk.logical must protected by
 +		 * holding all the crtc locks, even if we don't end up
 +		 * touching the hardware
 +		 */
 +		if (intel_cdclk_changed(&dev_priv->cdclk.logical,
 +					&state->cdclk.logical)) {
 +			ret = intel_lock_all_pipes(&state->base);
 +			if (ret < 0)
 +				return ret;
 +		}
 +
 +		if (is_power_of_2(state->active_crtcs)) {
 +			struct drm_crtc *crtc;
 +			struct drm_crtc_state *crtc_state;
 +
 +			pipe = ilog2(state->active_crtcs);
 +			crtc = &intel_get_crtc_for_pipe(dev_priv, pipe)->base;
 +			crtc_state = drm_atomic_get_new_crtc_state(&state->base, crtc);
 +			if (crtc_state && needs_modeset(crtc_state))
 +				pipe = INVALID_PIPE;
 +		} else {
 +			pipe = INVALID_PIPE;
 +		}
 +
 +		/* All pipes must be switched off while we change the cdclk. */
 +		if (pipe != INVALID_PIPE &&
 +		    intel_cdclk_needs_cd2x_update(dev_priv,
 +						  &dev_priv->cdclk.actual,
 +						  &state->cdclk.actual)) {
 +			ret = intel_lock_all_pipes(&state->base);
 +			if (ret < 0)
 +				return ret;
 +
 +			state->cdclk.pipe = pipe;
 +		} else if (intel_cdclk_needs_modeset(&dev_priv->cdclk.actual,
 +						     &state->cdclk.actual)) {
 +			ret = intel_modeset_all_pipes(&state->base);
 +			if (ret < 0)
 +				return ret;
 +
 +			state->cdclk.pipe = INVALID_PIPE;
 +		}
 +
 +		DRM_DEBUG_KMS("New cdclk calculated to be logical %u kHz, actual %u kHz\n",
 +			      state->cdclk.logical.cdclk,
 +			      state->cdclk.actual.cdclk);
 +		DRM_DEBUG_KMS("New voltage level calculated to be logical %u, actual %u\n",
 +			      state->cdclk.logical.voltage_level,
 +			      state->cdclk.actual.voltage_level);
 +	}
  
  	intel_modeset_clear_plls(state);
  
diff --cc drivers/gpu/drm/i915/display/intel_display.h
index 868914c6d9b5,75438a136d58..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display.h
+++ b/drivers/gpu/drm/i915/display/intel_display.h
@@@ -28,8 -28,34 +28,23 @@@
  #include <drm/drm_util.h>
  #include <drm/i915_drm.h>
  
 -enum link_m_n_set;
 -struct dpll;
 -struct drm_connector;
 -struct drm_device;
 -struct drm_display_mode;
 -struct drm_encoder;
 -struct drm_file;
 -struct drm_format_info;
 -struct drm_framebuffer;
 -struct drm_i915_error_state_buf;
 -struct drm_i915_gem_object;
  struct drm_i915_private;
++<<<<<<< HEAD
++=======
+ struct drm_modeset_acquire_ctx;
+ struct drm_plane;
+ struct drm_plane_state;
+ struct i915_ggtt_view;
+ struct intel_atomic_state;
+ struct intel_crtc;
+ struct intel_crtc_state;
+ struct intel_digital_port;
+ struct intel_dp;
+ struct intel_encoder;
+ struct intel_load_detect_pipe;
+ struct intel_plane;
++>>>>>>> aac978718bb4 (drm/i915: Introduce intel_calc_active_pipes())
  struct intel_plane_state;
 -struct intel_remapped_info;
 -struct intel_rotation_info;
 -struct intel_crtc_state;
  
  enum i915_gpio {
  	GPIOA,
@@@ -348,6 -445,33 +363,36 @@@ struct intel_link_m_n 
  	     (__i)++) \
  		for_each_if(crtc)
  
++<<<<<<< HEAD
++=======
+ #define for_each_oldnew_intel_crtc_in_state_reverse(__state, crtc, old_crtc_state, new_crtc_state, __i) \
+ 	for ((__i) = (__state)->base.dev->mode_config.num_crtc - 1; \
+ 	     (__i) >= 0  && \
+ 	     ((crtc) = to_intel_crtc((__state)->base.crtcs[__i].ptr), \
+ 	      (old_crtc_state) = to_intel_crtc_state((__state)->base.crtcs[__i].old_state), \
+ 	      (new_crtc_state) = to_intel_crtc_state((__state)->base.crtcs[__i].new_state), 1); \
+ 	     (__i)--) \
+ 		for_each_if(crtc)
+ 
+ #define intel_atomic_crtc_state_for_each_plane_state( \
+ 		  plane, plane_state, \
+ 		  crtc_state) \
+ 	for_each_intel_plane_mask(((crtc_state)->uapi.state->dev), (plane), \
+ 				((crtc_state)->uapi.plane_mask)) \
+ 		for_each_if ((plane_state = \
+ 			      to_intel_plane_state(__drm_atomic_get_current_plane_state((crtc_state)->uapi.state, &plane->base))))
+ 
+ #define for_each_new_intel_connector_in_state(__state, connector, new_connector_state, __i) \
+ 	for ((__i) = 0; \
+ 	     (__i) < (__state)->base.num_connector; \
+ 	     (__i)++) \
+ 		for_each_if ((__state)->base.connectors[__i].ptr && \
+ 			     ((connector) = to_intel_connector((__state)->base.connectors[__i].ptr), \
+ 			     (new_connector_state) = to_intel_digital_connector_state((__state)->base.connectors[__i].new_state), 1))
+ 
+ u8 intel_calc_active_pipes(struct intel_atomic_state *state,
+ 			   u8 active_pipes);
++>>>>>>> aac978718bb4 (drm/i915: Introduce intel_calc_active_pipes())
  void intel_link_compute_m_n(u16 bpp, int nlanes,
  			    int pixel_clock, int link_clock,
  			    struct intel_link_m_n *m_n,
* Unmerged path drivers/gpu/drm/i915/display/intel_display.c
* Unmerged path drivers/gpu/drm/i915/display/intel_display.h
