net/mlx5e: Fix ICOSQ recovery flow with Striding RQ

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Aya Levin <ayal@mellanox.com>
commit e239c6d686e1c37fb2ab143162dfb57471a8643f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e239c6d6.failed

In striding RQ mode, the buffers of an RX WQE are first
prepared and posted to the HW using a UMR WQEs via the ICOSQ.
We maintain the state of these in-progress WQEs in the RQ
SW struct.

In the flow of ICOSQ recovery, the corresponding RQ is not
in error state, hence:

- The buffers of the in-progress WQEs must be released
  and the RQ metadata should reflect it.
- Existing RX WQEs in the RQ should not be affected.

For this, wrap the dealloc of the in-progress WQEs in
a function, and use it in the ICOSQ recovery flow
instead of mlx5e_free_rx_descs().

Fixes: be5323c8379f ("net/mlx5e: Report and recover from CQE error on ICOSQ")
	Signed-off-by: Aya Levin <ayal@mellanox.com>
	Reviewed-by: Tariq Toukan <tariqt@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit e239c6d686e1c37fb2ab143162dfb57471a8643f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en.h
#	drivers/net/ethernet/mellanox/mlx5/core/en/reporter_rx.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_main.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en.h
index 2c27faf36aec,c9606b8ab6ef..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h
@@@ -1017,6 -1056,13 +1017,16 @@@ void mlx5e_set_rx_cq_mode_params(struc
  void mlx5e_set_rq_type(struct mlx5_core_dev *mdev, struct mlx5e_params *params);
  void mlx5e_init_rq_type_params(struct mlx5_core_dev *mdev,
  			       struct mlx5e_params *params);
++<<<<<<< HEAD
++=======
+ int mlx5e_modify_rq_state(struct mlx5e_rq *rq, int curr_state, int next_state);
+ void mlx5e_activate_rq(struct mlx5e_rq *rq);
+ void mlx5e_deactivate_rq(struct mlx5e_rq *rq);
+ void mlx5e_free_rx_descs(struct mlx5e_rq *rq);
+ void mlx5e_free_rx_in_progress_descs(struct mlx5e_rq *rq);
+ void mlx5e_activate_icosq(struct mlx5e_icosq *icosq);
+ void mlx5e_deactivate_icosq(struct mlx5e_icosq *icosq);
++>>>>>>> e239c6d686e1 (net/mlx5e: Fix ICOSQ recovery flow with Striding RQ)
  
  int mlx5e_modify_sq(struct mlx5_core_dev *mdev, u32 sqn,
  		    struct mlx5e_modify_sq_param *p);
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index af6dce841f45,4ef3dc79f73c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@@ -823,7 -812,31 +823,34 @@@ int mlx5e_wait_for_min_rx_wqes(struct m
  	return -ETIMEDOUT;
  }
  
++<<<<<<< HEAD
 +static void mlx5e_free_rx_descs(struct mlx5e_rq *rq)
++=======
+ void mlx5e_free_rx_in_progress_descs(struct mlx5e_rq *rq)
+ {
+ 	struct mlx5_wq_ll *wq;
+ 	u16 head;
+ 	int i;
+ 
+ 	if (rq->wq_type != MLX5_WQ_TYPE_LINKED_LIST_STRIDING_RQ)
+ 		return;
+ 
+ 	wq = &rq->mpwqe.wq;
+ 	head = wq->head;
+ 
+ 	/* Outstanding UMR WQEs (in progress) start at wq->head */
+ 	for (i = 0; i < rq->mpwqe.umr_in_progress; i++) {
+ 		rq->dealloc_wqe(rq, head);
+ 		head = mlx5_wq_ll_get_wqe_next_ix(wq, head);
+ 	}
+ 
+ 	rq->mpwqe.actual_wq_head = wq->head;
+ 	rq->mpwqe.umr_in_progress = 0;
+ 	rq->mpwqe.umr_completed = 0;
+ }
+ 
+ void mlx5e_free_rx_descs(struct mlx5e_rq *rq)
++>>>>>>> e239c6d686e1 (net/mlx5e: Fix ICOSQ recovery flow with Striding RQ)
  {
  	__be16 wqe_ix_be;
  	u16 wqe_ix;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/reporter_rx.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/reporter_rx.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_main.c
