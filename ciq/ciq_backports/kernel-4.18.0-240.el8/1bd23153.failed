pinctrl: intel: Allow to request locked pads

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 1bd231538c21d1cd691e71cbeeb4100fabc58068
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/1bd23153.failed

Some firmwares would like to protect pads from being modified by OS
and at the same time provide them to OS as a resource. So, the driver
in such circumstances may request pad and may not change its state.

	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
	Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 1bd231538c21d1cd691e71cbeeb4100fabc58068)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pinctrl/intel/pinctrl-intel.c
diff --cc drivers/pinctrl/intel/pinctrl-intel.c
index fb288c809f04,104dfaa78cb8..000000000000
--- a/drivers/pinctrl/intel/pinctrl-intel.c
+++ b/drivers/pinctrl/intel/pinctrl-intel.c
@@@ -219,12 -220,32 +219,36 @@@ static bool intel_pad_acpi_mode(struct 
  	return !(readl(hostown) & BIT(gpp_offset));
  }
  
++<<<<<<< HEAD
 +static bool intel_pad_locked(struct intel_pinctrl *pctrl, unsigned pin)
++=======
+ /**
+  * enum - Locking variants of the pad configuration
+  *
+  * @PAD_UNLOCKED:	pad is fully controlled by the configuration registers
+  * @PAD_LOCKED:		pad configuration registers, except TX state, are locked
+  * @PAD_LOCKED_TX:	pad configuration TX state is locked
+  * @PAD_LOCKED_FULL:	pad configuration registers are locked completely
+  *
+  * Locking is considered as read-only mode for corresponding registers and
+  * their respective fields. That said, TX state bit is locked separately from
+  * the main locking scheme.
+  */
+ enum {
+ 	PAD_UNLOCKED	= 0,
+ 	PAD_LOCKED	= 1,
+ 	PAD_LOCKED_TX	= 2,
+ 	PAD_LOCKED_FULL	= PAD_LOCKED | PAD_LOCKED_TX,
+ };
+ 
+ static int intel_pad_locked(struct intel_pinctrl *pctrl, unsigned int pin)
++>>>>>>> 1bd231538c21 (pinctrl: intel: Allow to request locked pads)
  {
  	struct intel_community *community;
  	const struct intel_padgroup *padgrp;
 -	unsigned int offset, gpp_offset;
 +	unsigned offset, gpp_offset;
  	u32 value;
+ 	int ret = PAD_UNLOCKED;
  
  	community = intel_get_community(pctrl, pin);
  	if (!community)
@@@ -251,15 -272,19 +275,19 @@@
  	offset = community->padcfglock_offset + 4 + padgrp->reg_num * 8;
  	value = readl(community->regs + offset);
  	if (value & BIT(gpp_offset))
- 		return true;
+ 		ret |= PAD_LOCKED_TX;
  
- 	return false;
+ 	return ret;
+ }
+ 
+ static bool intel_pad_is_unlocked(struct intel_pinctrl *pctrl, unsigned int pin)
+ {
+ 	return (intel_pad_locked(pctrl, pin) & PAD_LOCKED) == PAD_UNLOCKED;
  }
  
 -static bool intel_pad_usable(struct intel_pinctrl *pctrl, unsigned int pin)
 +static bool intel_pad_usable(struct intel_pinctrl *pctrl, unsigned pin)
  {
- 	return intel_pad_owned_by_host(pctrl, pin) &&
- 		!intel_pad_locked(pctrl, pin);
+ 	return intel_pad_owned_by_host(pctrl, pin) && intel_pad_is_unlocked(pctrl, pin);
  }
  
  static int intel_get_groups_count(struct pinctrl_dev *pctldev)
* Unmerged path drivers/pinctrl/intel/pinctrl-intel.c
