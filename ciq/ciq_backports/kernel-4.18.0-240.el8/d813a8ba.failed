KVM: x86: Move allocation of pio_data page down a few lines

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit d813a8ba54f94fd6a0276230bdf53c97b36c2101
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d813a8ba.failed

Allocate the pio_data page after creating the MMU and local APIC so that
all direct memory allocations are grouped together.  This allows setting
the return value to -ENOMEM prior to starting the allocations instead of
setting it in the fail path for every allocation.

The pio_data page is only consumed when KVM_RUN is invoked, i.e. moving
its allocation has no real functional impact.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit d813a8ba54f94fd6a0276230bdf53c97b36c2101)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index 28c9e8821b43,50110bca7d57..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -9508,11 -9538,22 +9506,25 @@@ int kvm_arch_vcpu_init(struct kvm_vcpu 
  	vcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;
  
  	if (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask,
- 				GFP_KERNEL_ACCOUNT)) {
- 		r = -ENOMEM;
+ 				GFP_KERNEL_ACCOUNT))
  		goto fail_free_mce_banks;
+ 
++<<<<<<< HEAD
++=======
+ 	vcpu->arch.user_fpu = kmem_cache_zalloc(x86_fpu_cache,
+ 						GFP_KERNEL_ACCOUNT);
+ 	if (!vcpu->arch.user_fpu) {
+ 		pr_err("kvm: failed to allocate userspace's fpu\n");
+ 		goto free_wbinvd_dirty_mask;
  	}
  
+ 	vcpu->arch.guest_fpu = kmem_cache_zalloc(x86_fpu_cache,
+ 						 GFP_KERNEL_ACCOUNT);
+ 	if (!vcpu->arch.guest_fpu) {
+ 		pr_err("kvm: failed to allocate vcpu's fpu\n");
+ 		goto free_user_fpu;
+ 	}
++>>>>>>> d813a8ba54f9 (KVM: x86: Move allocation of pio_data page down a few lines)
  	fx_init(vcpu);
  
  	vcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;
@@@ -9531,8 -9572,14 +9543,10 @@@
  
  	return 0;
  
 -free_user_fpu:
 -	kmem_cache_free(x86_fpu_cache, vcpu->arch.user_fpu);
 -free_wbinvd_dirty_mask:
 -	free_cpumask_var(vcpu->arch.wbinvd_dirty_mask);
  fail_free_mce_banks:
  	kfree(vcpu->arch.mce_banks);
+ fail_free_pio_data:
+ 	free_page((unsigned long)vcpu->arch.pio_data);
  fail_free_lapic:
  	kvm_free_lapic(vcpu);
  fail_mmu_destroy:
* Unmerged path arch/x86/kvm/x86.c
