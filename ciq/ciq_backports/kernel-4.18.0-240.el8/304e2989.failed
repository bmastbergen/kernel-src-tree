KVM: arm64: Move hyp_symbol_addr() to kvm_asm.h

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Marc Zyngier <maz@kernel.org>
commit 304e2989c93e941fa55b38c59c975d4acfb6e4a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/304e2989.failed

Recent refactoring of the arm64 code make it awkward to have
hyp_symbol_addr() in kvm_mmu.h. Instead, move it next to its
main user, which is __hyp_this_cpu_ptr().

	Signed-off-by: Marc Zyngier <maz@kernel.org>
(cherry picked from commit 304e2989c93e941fa55b38c59c975d4acfb6e4a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/kvm_asm.h
diff --cc arch/arm64/include/asm/kvm_asm.h
index 2964ee144a7a,352aaebf4198..000000000000
--- a/arch/arm64/include/asm/kvm_asm.h
+++ b/arch/arm64/include/asm/kvm_asm.h
@@@ -86,12 -79,41 +86,43 @@@ extern void __vgic_v3_init_lrs(void)
  
  extern u32 __kvm_get_mdcr_el2(void);
  
++<<<<<<< HEAD
 +/* Home-grown __this_cpu_{ptr,read} variants that always work at HYP */
++=======
+ extern char __smccc_workaround_1_smc[__SMCCC_WORKAROUND_1_SMC_SZ];
+ 
+ /*
+  * Obtain the PC-relative address of a kernel symbol
+  * s: symbol
+  *
+  * The goal of this macro is to return a symbol's address based on a
+  * PC-relative computation, as opposed to a loading the VA from a
+  * constant pool or something similar. This works well for HYP, as an
+  * absolute VA is guaranteed to be wrong. Only use this if trying to
+  * obtain the address of a symbol (i.e. not something you obtained by
+  * following a pointer).
+  */
+ #define hyp_symbol_addr(s)						\
+ 	({								\
+ 		typeof(s) *addr;					\
+ 		asm("adrp	%0, %1\n"				\
+ 		    "add	%0, %0, :lo12:%1\n"			\
+ 		    : "=r" (addr) : "S" (&s));				\
+ 		addr;							\
+ 	})
+ 
+ /*
+  * Home-grown __this_cpu_{ptr,read} variants that always work at HYP,
+  * provided that sym is really a *symbol* and not a pointer obtained from
+  * a data structure. As for SHIFT_PERCPU_PTR(), the creative casting keeps
+  * sparse quiet.
+  */
++>>>>>>> 304e2989c93e (KVM: arm64: Move hyp_symbol_addr() to kvm_asm.h)
  #define __hyp_this_cpu_ptr(sym)						\
  	({								\
 -		void *__ptr;						\
 -		__verify_pcpu_ptr(&sym);				\
 -		__ptr = hyp_symbol_addr(sym);				\
 +		void *__ptr = hyp_symbol_addr(sym);			\
  		__ptr += read_sysreg(tpidr_el2);			\
 -		(typeof(sym) __kernel __force *)__ptr;			\
 +		(typeof(&sym))__ptr;					\
  	 })
  
  #define __hyp_this_cpu_read(sym)					\
* Unmerged path arch/arm64/include/asm/kvm_asm.h
diff --git a/arch/arm64/include/asm/kvm_mmu.h b/arch/arm64/include/asm/kvm_mmu.h
index bf7998d0451d..90e7ec085633 100644
--- a/arch/arm64/include/asm/kvm_mmu.h
+++ b/arch/arm64/include/asm/kvm_mmu.h
@@ -118,26 +118,6 @@ static inline unsigned long __kern_hyp_va(unsigned long v)
 
 #define kern_hyp_va(v) 	((typeof(v))(__kern_hyp_va((unsigned long)(v))))
 
-/*
- * Obtain the PC-relative address of a kernel symbol
- * s: symbol
- *
- * The goal of this macro is to return a symbol's address based on a
- * PC-relative computation, as opposed to a loading the VA from a
- * constant pool or something similar. This works well for HYP, as an
- * absolute VA is guaranteed to be wrong. Only use this if trying to
- * obtain the address of a symbol (i.e. not something you obtained by
- * following a pointer).
- */
-#define hyp_symbol_addr(s)						\
-	({								\
-		typeof(s) *addr;					\
-		asm("adrp	%0, %1\n"				\
-		    "add	%0, %0, :lo12:%1\n"			\
-		    : "=r" (addr) : "S" (&s));				\
-		addr;							\
-	})
-
 /*
  * We currently support using a VM-specified IPA size. For backward
  * compatibility, the default IPA size is fixed to 40bits.
