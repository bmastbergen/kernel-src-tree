bpf: Add generic support for lookup batch op

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Brian Vazquez <brianvv@google.com>
commit cb4d03ab499d4c040f4ab6fd4389d2b49f42b5a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/cb4d03ab.failed

This commit introduces generic support for the bpf_map_lookup_batch.
This implementation can be used by almost all the bpf maps since its core
implementation is relying on the existing map_get_next_key and
map_lookup_elem. The bpf syscall subcommand introduced is:

  BPF_MAP_LOOKUP_BATCH

The UAPI attribute is:

  struct { /* struct used by BPF_MAP_*_BATCH commands */
         __aligned_u64   in_batch;       /* start batch,
                                          * NULL to start from beginning
                                          */
         __aligned_u64   out_batch;      /* output: next start batch */
         __aligned_u64   keys;
         __aligned_u64   values;
         __u32           count;          /* input/output:
                                          * input: # of key/value
                                          * elements
                                          * output: # of filled elements
                                          */
         __u32           map_fd;
         __u64           elem_flags;
         __u64           flags;
  } batch;

in_batch/out_batch are opaque values use to communicate between
user/kernel space, in_batch/out_batch must be of key_size length.

To start iterating from the beginning in_batch must be null,
count is the # of key/value elements to retrieve. Note that the 'keys'
buffer must be a buffer of key_size * count size and the 'values' buffer
must be value_size * count, where value_size must be aligned to 8 bytes
by userspace if it's dealing with percpu maps. 'count' will contain the
number of keys/values successfully retrieved. Note that 'count' is an
input/output variable and it can contain a lower value after a call.

If there's no more entries to retrieve, ENOENT will be returned. If error
is ENOENT, count might be > 0 in case it copied some values but there were
no more entries to retrieve.

Note that if the return code is an error and not -EFAULT,
count indicates the number of elements successfully processed.

	Suggested-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Brian Vazquez <brianvv@google.com>
	Signed-off-by: Yonghong Song <yhs@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200115184308.162644-3-brianvv@google.com
(cherry picked from commit cb4d03ab499d4c040f4ab6fd4389d2b49f42b5a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/syscall.c
diff --cc include/linux/bpf.h
index 602dd6841705,807744ecaa5a..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -41,7 -43,9 +41,13 @@@ struct bpf_map_ops 
  	void (*map_free)(struct bpf_map *map);
  	int (*map_get_next_key)(struct bpf_map *map, void *key, void *next_key);
  	void (*map_release_uref)(struct bpf_map *map);
++<<<<<<< HEAD
 +	RH_KABI_BROKEN_INSERT(void *(*map_lookup_elem_sys_only)(struct bpf_map *map, void *key))
++=======
+ 	void *(*map_lookup_elem_sys_only)(struct bpf_map *map, void *key);
+ 	int (*map_lookup_batch)(struct bpf_map *map, const union bpf_attr *attr,
+ 				union bpf_attr __user *uattr);
++>>>>>>> cb4d03ab499d (bpf: Add generic support for lookup batch op)
  
  	/* funcs callable from userspace and from eBPF programs */
  	void *(*map_lookup_elem)(struct bpf_map *map, void *key);
@@@ -696,8 -981,12 +702,11 @@@ void bpf_map_charge_finish(struct bpf_m
  void bpf_map_charge_move(struct bpf_map_memory *dst,
  			 struct bpf_map_memory *src);
  void *bpf_map_area_alloc(u64 size, int numa_node);
 -void *bpf_map_area_mmapable_alloc(u64 size, int numa_node);
  void bpf_map_area_free(void *base);
  void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr);
+ int  generic_map_lookup_batch(struct bpf_map *map,
+ 			      const union bpf_attr *attr,
+ 			      union bpf_attr __user *uattr);
  
  extern int sysctl_unprivileged_bpf_disabled;
  
diff --cc kernel/bpf/syscall.c
index 4aa6a47aa4b8,d604ddbb1afb..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -156,7 -129,153 +156,157 @@@ static struct bpf_map *find_and_alloc_m
  	return map;
  }
  
++<<<<<<< HEAD
 +void *bpf_map_area_alloc(u64 size, int numa_node)
++=======
+ static u32 bpf_map_value_size(struct bpf_map *map)
+ {
+ 	if (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||
+ 	    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||
+ 	    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||
+ 	    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)
+ 		return round_up(map->value_size, 8) * num_possible_cpus();
+ 	else if (IS_FD_MAP(map))
+ 		return sizeof(u32);
+ 	else
+ 		return  map->value_size;
+ }
+ 
+ static void maybe_wait_bpf_programs(struct bpf_map *map)
+ {
+ 	/* Wait for any running BPF programs to complete so that
+ 	 * userspace, when we return to it, knows that all programs
+ 	 * that could be running use the new map value.
+ 	 */
+ 	if (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||
+ 	    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)
+ 		synchronize_rcu();
+ }
+ 
+ static int bpf_map_update_value(struct bpf_map *map, struct fd f, void *key,
+ 				void *value, __u64 flags)
+ {
+ 	int err;
+ 
+ 	/* Need to create a kthread, thus must support schedule */
+ 	if (bpf_map_is_dev_bound(map)) {
+ 		return bpf_map_offload_update_elem(map, key, value, flags);
+ 	} else if (map->map_type == BPF_MAP_TYPE_CPUMAP ||
+ 		   map->map_type == BPF_MAP_TYPE_SOCKHASH ||
+ 		   map->map_type == BPF_MAP_TYPE_SOCKMAP ||
+ 		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
+ 		return map->ops->map_update_elem(map, key, value, flags);
+ 	} else if (IS_FD_PROG_ARRAY(map)) {
+ 		return bpf_fd_array_map_update_elem(map, f.file, key, value,
+ 						    flags);
+ 	}
+ 
+ 	/* must increment bpf_prog_active to avoid kprobe+bpf triggering from
+ 	 * inside bpf map update or delete otherwise deadlocks are possible
+ 	 */
+ 	preempt_disable();
+ 	__this_cpu_inc(bpf_prog_active);
+ 	if (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||
+ 	    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {
+ 		err = bpf_percpu_hash_update(map, key, value, flags);
+ 	} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {
+ 		err = bpf_percpu_array_update(map, key, value, flags);
+ 	} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {
+ 		err = bpf_percpu_cgroup_storage_update(map, key, value,
+ 						       flags);
+ 	} else if (IS_FD_ARRAY(map)) {
+ 		rcu_read_lock();
+ 		err = bpf_fd_array_map_update_elem(map, f.file, key, value,
+ 						   flags);
+ 		rcu_read_unlock();
+ 	} else if (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS) {
+ 		rcu_read_lock();
+ 		err = bpf_fd_htab_map_update_elem(map, f.file, key, value,
+ 						  flags);
+ 		rcu_read_unlock();
+ 	} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {
+ 		/* rcu_read_lock() is not needed */
+ 		err = bpf_fd_reuseport_array_update_elem(map, key, value,
+ 							 flags);
+ 	} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||
+ 		   map->map_type == BPF_MAP_TYPE_STACK) {
+ 		err = map->ops->map_push_elem(map, value, flags);
+ 	} else {
+ 		rcu_read_lock();
+ 		err = map->ops->map_update_elem(map, key, value, flags);
+ 		rcu_read_unlock();
+ 	}
+ 	__this_cpu_dec(bpf_prog_active);
+ 	preempt_enable();
+ 	maybe_wait_bpf_programs(map);
+ 
+ 	return err;
+ }
+ 
+ static int bpf_map_copy_value(struct bpf_map *map, void *key, void *value,
+ 			      __u64 flags)
+ {
+ 	void *ptr;
+ 	int err;
+ 
+ 	if (bpf_map_is_dev_bound(map))
+ 		return bpf_map_offload_lookup_elem(map, key, value);
+ 
+ 	preempt_disable();
+ 	this_cpu_inc(bpf_prog_active);
+ 	if (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||
+ 	    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {
+ 		err = bpf_percpu_hash_copy(map, key, value);
+ 	} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {
+ 		err = bpf_percpu_array_copy(map, key, value);
+ 	} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {
+ 		err = bpf_percpu_cgroup_storage_copy(map, key, value);
+ 	} else if (map->map_type == BPF_MAP_TYPE_STACK_TRACE) {
+ 		err = bpf_stackmap_copy(map, key, value);
+ 	} else if (IS_FD_ARRAY(map) || IS_FD_PROG_ARRAY(map)) {
+ 		err = bpf_fd_array_map_lookup_elem(map, key, value);
+ 	} else if (IS_FD_HASH(map)) {
+ 		err = bpf_fd_htab_map_lookup_elem(map, key, value);
+ 	} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {
+ 		err = bpf_fd_reuseport_array_lookup_elem(map, key, value);
+ 	} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||
+ 		   map->map_type == BPF_MAP_TYPE_STACK) {
+ 		err = map->ops->map_peek_elem(map, value);
+ 	} else if (map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
+ 		/* struct_ops map requires directly updating "value" */
+ 		err = bpf_struct_ops_map_sys_lookup_elem(map, key, value);
+ 	} else {
+ 		rcu_read_lock();
+ 		if (map->ops->map_lookup_elem_sys_only)
+ 			ptr = map->ops->map_lookup_elem_sys_only(map, key);
+ 		else
+ 			ptr = map->ops->map_lookup_elem(map, key);
+ 		if (IS_ERR(ptr)) {
+ 			err = PTR_ERR(ptr);
+ 		} else if (!ptr) {
+ 			err = -ENOENT;
+ 		} else {
+ 			err = 0;
+ 			if (flags & BPF_F_LOCK)
+ 				/* lock 'ptr' and copy everything but lock */
+ 				copy_map_value_locked(map, value, ptr, true);
+ 			else
+ 				copy_map_value(map, value, ptr);
+ 			/* mask lock, since value wasn't zero inited */
+ 			check_and_init_map_lock(map, value);
+ 		}
+ 		rcu_read_unlock();
+ 	}
+ 
+ 	this_cpu_dec(bpf_prog_active);
+ 	preempt_enable();
+ 	maybe_wait_bpf_programs(map);
+ 
+ 	return err;
+ }
+ 
+ static void *__bpf_map_area_alloc(u64 size, int numa_node, bool mmapable)
++>>>>>>> cb4d03ab499d (bpf: Add generic support for lookup batch op)
  {
  	/* We really just want to fail instead of triggering OOM killer
  	 * under memory pressure, therefore we set __GFP_NORETRY to kmalloc,
* Unmerged path include/linux/bpf.h
diff --git a/include/uapi/linux/bpf.h b/include/uapi/linux/bpf.h
index f26f93a554f1..edcbf13af58f 100644
--- a/include/uapi/linux/bpf.h
+++ b/include/uapi/linux/bpf.h
@@ -107,6 +107,7 @@ enum bpf_cmd {
 	BPF_MAP_LOOKUP_AND_DELETE_ELEM,
 	BPF_MAP_FREEZE,
 	BPF_BTF_GET_NEXT_ID,
+	BPF_MAP_LOOKUP_BATCH,
 };
 
 enum bpf_map_type {
@@ -401,6 +402,23 @@ union bpf_attr {
 		__u64		flags;
 	};
 
+	struct { /* struct used by BPF_MAP_*_BATCH commands */
+		__aligned_u64	in_batch;	/* start batch,
+						 * NULL to start from beginning
+						 */
+		__aligned_u64	out_batch;	/* output: next start batch */
+		__aligned_u64	keys;
+		__aligned_u64	values;
+		__u32		count;		/* input/output:
+						 * input: # of key/value
+						 * elements
+						 * output: # of filled elements
+						 */
+		__u32		map_fd;
+		__u64		elem_flags;
+		__u64		flags;
+	} batch;
+
 	struct { /* anonymous struct used by BPF_PROG_LOAD command */
 		__u32		prog_type;	/* one of enum bpf_prog_type */
 		__u32		insn_cnt;
* Unmerged path kernel/bpf/syscall.c
