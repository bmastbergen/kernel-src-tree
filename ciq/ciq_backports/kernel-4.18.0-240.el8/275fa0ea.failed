arm64: Workaround for Cortex-A55 erratum 1530923

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [arm64] Workaround for Cortex-A55 erratum 1530923 (Gavin Shan) [1814009]
Rebuild_FUZZ: 92.13%
commit-author Steven Price <steven.price@arm.com>
commit 275fa0ea2cf7a84450f9c0ec0d9e7ec168ed2e2d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/275fa0ea.failed

Cortex-A55 erratum 1530923 allows TLB entries to be allocated as a
result of a speculative AT instruction. This may happen in the middle of
a guest world switch while the relevant VMSA configuration is in an
inconsistent state, leading to erroneous content being allocated into
TLBs.

The same workaround as is used for Cortex-A76 erratum 1165522
(WORKAROUND_SPECULATIVE_AT_VHE) can be used here. Note that this
mandates the use of VHE on affected parts.

	Acked-by: Marc Zyngier <maz@kernel.org>
	Signed-off-by: Steven Price <steven.price@arm.com>
	Signed-off-by: Will Deacon <will@kernel.org>
(cherry picked from commit 275fa0ea2cf7a84450f9c0ec0d9e7ec168ed2e2d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/arm64/silicon-errata.rst
#	arch/arm64/kernel/cpu_errata.c
diff --cc arch/arm64/kernel/cpu_errata.c
index 9de4d99cff30,0bd2867f3248..000000000000
--- a/arch/arm64/kernel/cpu_errata.c
+++ b/arch/arm64/kernel/cpu_errata.c
@@@ -755,6 -730,47 +755,50 @@@ static const struct midr_range erratum_
  };
  #endif
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_ARM64_ERRATUM_845719
+ static const struct midr_range erratum_845719_list[] = {
+ 	/* Cortex-A53 r0p[01234] */
+ 	MIDR_REV_RANGE(MIDR_CORTEX_A53, 0, 0, 4),
+ 	/* Brahma-B53 r0p[0] */
+ 	MIDR_REV(MIDR_BRAHMA_B53, 0, 0),
+ 	{},
+ };
+ #endif
+ 
+ #ifdef CONFIG_ARM64_ERRATUM_843419
+ static const struct arm64_cpu_capabilities erratum_843419_list[] = {
+ 	{
+ 		/* Cortex-A53 r0p[01234] */
+ 		.matches = is_affected_midr_range,
+ 		ERRATA_MIDR_REV_RANGE(MIDR_CORTEX_A53, 0, 0, 4),
+ 		MIDR_FIXED(0x4, BIT(8)),
+ 	},
+ 	{
+ 		/* Brahma-B53 r0p[0] */
+ 		.matches = is_affected_midr_range,
+ 		ERRATA_MIDR_REV(MIDR_BRAHMA_B53, 0, 0),
+ 	},
+ 	{},
+ };
+ #endif
+ 
+ #ifdef CONFIG_ARM64_WORKAROUND_SPECULATIVE_AT_VHE
+ static const struct midr_range erratum_speculative_at_vhe_list[] = {
+ #ifdef CONFIG_ARM64_ERRATUM_1165522
+ 	/* Cortex A76 r0p0 to r2p0 */
+ 	MIDR_RANGE(MIDR_CORTEX_A76, 0, 0, 2, 0),
+ #endif
+ #ifdef CONFIG_ARM64_ERRATUM_1530923
+ 	/* Cortex A55 r0p0 to r2p0 */
+ 	MIDR_RANGE(MIDR_CORTEX_A55, 0, 0, 2, 0),
+ #endif
+ 	{},
+ };
+ #endif
+ 
++>>>>>>> 275fa0ea2cf7 (arm64: Workaround for Cortex-A55 erratum 1530923)
  const struct arm64_cpu_capabilities arm64_errata[] = {
  #ifdef CONFIG_ARM64_WORKAROUND_CLEAN_CACHE
  	{
@@@ -880,12 -897,19 +924,26 @@@
  		ERRATA_MIDR_RANGE_LIST(erratum_1418040_list),
  	},
  #endif
 -#ifdef CONFIG_ARM64_WORKAROUND_SPECULATIVE_AT_VHE
 +#ifdef CONFIG_ARM64_ERRATUM_1165522
  	{
++<<<<<<< HEAD
 +		/* Cortex-A76 r0p0 to r2p0 */
 +		.desc = "ARM erratum 1165522",
 +		.capability = ARM64_WORKAROUND_1165522,
 +		ERRATA_MIDR_RANGE(MIDR_CORTEX_A76, 0, 0, 2, 0),
++=======
+ 		.desc = "ARM errata 1165522, 1530923",
+ 		.capability = ARM64_WORKAROUND_SPECULATIVE_AT_VHE,
+ 		ERRATA_MIDR_RANGE_LIST(erratum_speculative_at_vhe_list),
+ 	},
+ #endif
+ #ifdef CONFIG_ARM64_ERRATUM_1463225
+ 	{
+ 		.desc = "ARM erratum 1463225",
+ 		.capability = ARM64_WORKAROUND_1463225,
+ 		.type = ARM64_CPUCAP_LOCAL_CPU_ERRATUM,
+ 		.matches = has_cortex_a76_erratum_1463225,
++>>>>>>> 275fa0ea2cf7 (arm64: Workaround for Cortex-A55 erratum 1530923)
  	},
  #endif
  #ifdef CONFIG_CAVIUM_TX2_ERRATUM_219
* Unmerged path Documentation/arm64/silicon-errata.rst
* Unmerged path Documentation/arm64/silicon-errata.rst
diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index d9a7ce52dbae..961ddd82a6f4 100644
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -522,6 +522,19 @@ config ARM64_ERRATUM_1165522
 
 	  If unsure, say Y.
 
+config ARM64_ERRATUM_1530923
+	bool "Cortex-A55: Speculative AT instruction using out-of-context translation regime could cause subsequent request to generate an incorrect translation"
+	default y
+	select ARM64_WORKAROUND_SPECULATIVE_AT_VHE
+	help
+	  This option adds a workaround for ARM Cortex-A55 erratum 1530923.
+
+	  Affected Cortex-A55 cores (r0p0, r0p1, r1p0, r2p0) could end-up with
+	  corrupted TLBs by speculating an AT instruction during a guest
+	  context switch.
+
+	  If unsure, say Y.
+
 config ARM64_ERRATUM_1286807
 	bool "Cortex-A76: Modification of the translation table for a virtual address might lead to read-after-read ordering violation"
 	default y
diff --git a/arch/arm64/include/asm/kvm_hyp.h b/arch/arm64/include/asm/kvm_hyp.h
index 53230290e8da..3f87cd279b0e 100644
--- a/arch/arm64/include/asm/kvm_hyp.h
+++ b/arch/arm64/include/asm/kvm_hyp.h
@@ -102,8 +102,8 @@ static __always_inline void __hyp_text __load_guest_stage2(struct kvm *kvm)
 	write_sysreg(kvm_get_vttbr(kvm), vttbr_el2);
 
 	/*
-	 * ARM erratum 1165522 requires the actual execution of the above
-	 * before we can switch to the EL1/EL0 translation regime used by
+	 * ARM errata 1165522 and 1530923 require the actual execution of the
+	 * above before we can switch to the EL1/EL0 translation regime used by
 	 * the guest.
 	 */
 	asm(ALTERNATIVE("nop", "isb", ARM64_WORKAROUND_1165522));
* Unmerged path arch/arm64/kernel/cpu_errata.c
diff --git a/arch/arm64/kvm/hyp/switch.c b/arch/arm64/kvm/hyp/switch.c
index b617da7815ad..2689bcb79243 100644
--- a/arch/arm64/kvm/hyp/switch.c
+++ b/arch/arm64/kvm/hyp/switch.c
@@ -176,8 +176,8 @@ static void deactivate_traps_vhe(void)
 	write_sysreg(HCR_HOST_VHE_FLAGS, hcr_el2);
 
 	/*
-	 * ARM erratum 1165522 requires the actual execution of the above
-	 * before we can switch to the EL2/EL0 translation regime used by
+	 * ARM errata 1165522 and 1530923 require the actual execution of the
+	 * above before we can switch to the EL2/EL0 translation regime used by
 	 * the host.
 	 */
 	asm(ALTERNATIVE("nop", "isb", ARM64_WORKAROUND_1165522));
diff --git a/arch/arm64/kvm/hyp/tlb.c b/arch/arm64/kvm/hyp/tlb.c
index e566bc96cab0..70de6edd7da9 100644
--- a/arch/arm64/kvm/hyp/tlb.c
+++ b/arch/arm64/kvm/hyp/tlb.c
@@ -36,8 +36,8 @@ static void __hyp_text __tlb_switch_to_guest_vhe(struct kvm *kvm,
 
 	if (cpus_have_const_cap(ARM64_WORKAROUND_1165522)) {
 		/*
-		 * For CPUs that are affected by ARM erratum 1165522, we
-		 * cannot trust stage-1 to be in a correct state at that
+		 * For CPUs that are affected by ARM errata 1165522 or 1530923,
+		 * we cannot trust stage-1 to be in a correct state at that
 		 * point. Since we do not want to force a full load of the
 		 * vcpu state, we prevent the EL1 page-table walker to
 		 * allocate new TLBs. This is done by setting the EPD bits
