Bluetooth: Remove adv set for directed advertising

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sathish Narsimman <nsathish41@gmail.com>
commit a9e45698b37d4235ec98b5c0327de59759cb2ef2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a9e45698.failed

Extended advertising Data is set during bluetooth initialization
by default which causes InvalidHCICommandParameters when setting
Extended advertising parameters.

As per Core Spec 5.2 Vol 2, PART E, Sec 7.8.53, for
advertising_event_property LE_LEGACY_ADV_DIRECT_IND does not
supports advertising data when the advertising set already
contains some, the controller shall return erroc code
'InvalidHCICommandParameters(0x12).

So it is required to remove adv set for handle 0x00. since we use
instance 0 for directed adv.

	Signed-off-by: Sathish Narsimman <sathish.narasimman@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit a9e45698b37d4235ec98b5c0327de59759cb2ef2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/bluetooth/hci.h
#	net/bluetooth/hci_conn.c
diff --cc include/net/bluetooth/hci.h
index 1668211297a9,29b638c6c934..000000000000
--- a/include/net/bluetooth/hci.h
+++ b/include/net/bluetooth/hci.h
@@@ -1506,6 -1604,216 +1506,219 @@@ struct hci_cp_le_set_default_phy 
  	__u8    rx_phys;
  } __packed;
  
++<<<<<<< HEAD
++=======
+ #define HCI_LE_SET_PHY_1M		0x01
+ #define HCI_LE_SET_PHY_2M		0x02
+ #define HCI_LE_SET_PHY_CODED		0x04
+ 
+ #define HCI_OP_LE_SET_EXT_SCAN_PARAMS   0x2041
+ struct hci_cp_le_set_ext_scan_params {
+ 	__u8    own_addr_type;
+ 	__u8    filter_policy;
+ 	__u8    scanning_phys;
+ 	__u8    data[];
+ } __packed;
+ 
+ #define LE_SCAN_PHY_1M		0x01
+ #define LE_SCAN_PHY_2M		0x02
+ #define LE_SCAN_PHY_CODED	0x04
+ 
+ struct hci_cp_le_scan_phy_params {
+ 	__u8    type;
+ 	__le16  interval;
+ 	__le16  window;
+ } __packed;
+ 
+ #define HCI_OP_LE_SET_EXT_SCAN_ENABLE   0x2042
+ struct hci_cp_le_set_ext_scan_enable {
+ 	__u8    enable;
+ 	__u8    filter_dup;
+ 	__le16  duration;
+ 	__le16  period;
+ } __packed;
+ 
+ #define HCI_OP_LE_EXT_CREATE_CONN    0x2043
+ struct hci_cp_le_ext_create_conn {
+ 	__u8      filter_policy;
+ 	__u8      own_addr_type;
+ 	__u8      peer_addr_type;
+ 	bdaddr_t  peer_addr;
+ 	__u8      phys;
+ 	__u8      data[];
+ } __packed;
+ 
+ struct hci_cp_le_ext_conn_param {
+ 	__le16 scan_interval;
+ 	__le16 scan_window;
+ 	__le16 conn_interval_min;
+ 	__le16 conn_interval_max;
+ 	__le16 conn_latency;
+ 	__le16 supervision_timeout;
+ 	__le16 min_ce_len;
+ 	__le16 max_ce_len;
+ } __packed;
+ 
+ #define HCI_OP_LE_READ_NUM_SUPPORTED_ADV_SETS	0x203b
+ struct hci_rp_le_read_num_supported_adv_sets {
+ 	__u8  status;
+ 	__u8  num_of_sets;
+ } __packed;
+ 
+ #define HCI_OP_LE_SET_EXT_ADV_PARAMS		0x2036
+ struct hci_cp_le_set_ext_adv_params {
+ 	__u8      handle;
+ 	__le16    evt_properties;
+ 	__u8      min_interval[3];
+ 	__u8      max_interval[3];
+ 	__u8      channel_map;
+ 	__u8      own_addr_type;
+ 	__u8      peer_addr_type;
+ 	bdaddr_t  peer_addr;
+ 	__u8      filter_policy;
+ 	__u8      tx_power;
+ 	__u8      primary_phy;
+ 	__u8      secondary_max_skip;
+ 	__u8      secondary_phy;
+ 	__u8      sid;
+ 	__u8      notif_enable;
+ } __packed;
+ 
+ #define HCI_ADV_PHY_1M		0X01
+ #define HCI_ADV_PHY_2M		0x02
+ #define HCI_ADV_PHY_CODED	0x03
+ 
+ struct hci_rp_le_set_ext_adv_params {
+ 	__u8  status;
+ 	__u8  tx_power;
+ } __packed;
+ 
+ #define HCI_OP_LE_SET_EXT_ADV_ENABLE		0x2039
+ struct hci_cp_le_set_ext_adv_enable {
+ 	__u8  enable;
+ 	__u8  num_of_sets;
+ 	__u8  data[];
+ } __packed;
+ 
+ struct hci_cp_ext_adv_set {
+ 	__u8  handle;
+ 	__le16 duration;
+ 	__u8  max_events;
+ } __packed;
+ 
+ #define HCI_OP_LE_SET_EXT_ADV_DATA		0x2037
+ struct hci_cp_le_set_ext_adv_data {
+ 	__u8  handle;
+ 	__u8  operation;
+ 	__u8  frag_pref;
+ 	__u8  length;
+ 	__u8  data[HCI_MAX_AD_LENGTH];
+ } __packed;
+ 
+ #define HCI_OP_LE_SET_EXT_SCAN_RSP_DATA		0x2038
+ struct hci_cp_le_set_ext_scan_rsp_data {
+ 	__u8  handle;
+ 	__u8  operation;
+ 	__u8  frag_pref;
+ 	__u8  length;
+ 	__u8  data[HCI_MAX_AD_LENGTH];
+ } __packed;
+ 
+ #define LE_SET_ADV_DATA_OP_COMPLETE	0x03
+ 
+ #define LE_SET_ADV_DATA_NO_FRAG		0x01
+ 
+ #define HCI_OP_LE_REMOVE_ADV_SET	0x203c
+ 
+ #define HCI_OP_LE_CLEAR_ADV_SETS	0x203d
+ 
+ #define HCI_OP_LE_SET_ADV_SET_RAND_ADDR	0x2035
+ struct hci_cp_le_set_adv_set_rand_addr {
+ 	__u8  handle;
+ 	bdaddr_t  bdaddr;
+ } __packed;
+ 
+ #define HCI_OP_LE_READ_BUFFER_SIZE_V2	0x2060
+ struct hci_rp_le_read_buffer_size_v2 {
+ 	__u8    status;
+ 	__le16  acl_mtu;
+ 	__u8    acl_max_pkt;
+ 	__le16  iso_mtu;
+ 	__u8    iso_max_pkt;
+ } __packed;
+ 
+ #define HCI_OP_LE_READ_ISO_TX_SYNC		0x2061
+ struct hci_cp_le_read_iso_tx_sync {
+ 	__le16  handle;
+ } __packed;
+ 
+ struct hci_rp_le_read_iso_tx_sync {
+ 	__u8    status;
+ 	__le16  handle;
+ 	__le16  seq;
+ 	__le32  imestamp;
+ 	__u8    offset[3];
+ } __packed;
+ 
+ #define HCI_OP_LE_SET_CIG_PARAMS		0x2062
+ struct hci_cis_params {
+ 	__u8    cis_id;
+ 	__le16  m_sdu;
+ 	__le16  s_sdu;
+ 	__u8    m_phy;
+ 	__u8    s_phy;
+ 	__u8    m_rtn;
+ 	__u8    s_rtn;
+ } __packed;
+ 
+ struct hci_cp_le_set_cig_params {
+ 	__u8    cig_id;
+ 	__u8    m_interval[3];
+ 	__u8    s_interval[3];
+ 	__u8    sca;
+ 	__u8    packing;
+ 	__u8    framing;
+ 	__le16  m_latency;
+ 	__le16  s_latency;
+ 	__u8    num_cis;
+ 	struct hci_cis_params cis[];
+ } __packed;
+ 
+ struct hci_rp_le_set_cig_params {
+ 	__u8    status;
+ 	__u8    cig_id;
+ 	__u8    num_handles;
+ 	__le16  handle[];
+ } __packed;
+ 
+ #define HCI_OP_LE_CREATE_CIS			0x2064
+ struct hci_cis {
+ 	__le16  cis_handle;
+ 	__le16  acl_handle;
+ } __packed;
+ 
+ struct hci_cp_le_create_cis {
+ 	__u8    num_cis;
+ 	struct hci_cis cis[];
+ } __packed;
+ 
+ #define HCI_OP_LE_REMOVE_CIG			0x2065
+ struct hci_cp_le_remove_cig {
+ 	__u8    cig_id;
+ } __packed;
+ 
+ #define HCI_OP_LE_ACCEPT_CIS			0x2066
+ struct hci_cp_le_accept_cis {
+ 	__le16  handle;
+ } __packed;
+ 
+ #define HCI_OP_LE_REJECT_CIS			0x2067
+ struct hci_cp_le_reject_cis {
+ 	__le16  handle;
+ 	__u8    reason;
+ } __packed;
+ 
++>>>>>>> a9e45698b37d (Bluetooth: Remove adv set for directed advertising)
  /* ---- HCI Events ---- */
  #define HCI_EV_INQUIRY_COMPLETE		0x01
  
diff --cc net/bluetooth/hci_conn.c
index e3a2217d7d3e,2731f0ad2a90..000000000000
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@@ -807,31 -874,96 +807,100 @@@ static void hci_req_directed_advertisin
  	u8 own_addr_type;
  	u8 enable;
  
 -	if (ext_adv_capable(hdev)) {
 -		struct hci_cp_le_set_ext_adv_params cp;
 -		bdaddr_t random_addr;
 -
 -		/* Set require_privacy to false so that the remote device has a
 -		 * chance of identifying us.
 -		 */
 -		if (hci_get_random_address(hdev, false, conn_use_rpa(conn), NULL,
 -					   &own_addr_type, &random_addr) < 0)
 -			return;
 -
 -		memset(&cp, 0, sizeof(cp));
 +	/* Clear the HCI_LE_ADV bit temporarily so that the
 +	 * hci_update_random_address knows that it's safe to go ahead
 +	 * and write a new random address. The flag will be set back on
 +	 * as soon as the SET_ADV_ENABLE HCI command completes.
 +	 */
 +	hci_dev_clear_flag(hdev, HCI_LE_ADV);
  
 -		cp.evt_properties = cpu_to_le16(LE_LEGACY_ADV_DIRECT_IND);
 -		cp.own_addr_type = own_addr_type;
 -		cp.channel_map = hdev->le_adv_channel_map;
 -		cp.tx_power = HCI_TX_POWER_INVALID;
 -		cp.primary_phy = HCI_ADV_PHY_1M;
 -		cp.secondary_phy = HCI_ADV_PHY_1M;
 -		cp.handle = 0; /* Use instance 0 for directed adv */
 -		cp.own_addr_type = own_addr_type;
 -		cp.peer_addr_type = conn->dst_type;
 -		bacpy(&cp.peer_addr, &conn->dst);
 +	/* Set require_privacy to false so that the remote device has a
 +	 * chance of identifying us.
 +	 */
 +	if (hci_update_random_address(req, false, conn_use_rpa(conn),
 +				      &own_addr_type) < 0)
 +		return;
  
 +	memset(&cp, 0, sizeof(cp));
 +	cp.type = LE_ADV_DIRECT_IND;
 +	cp.own_address_type = own_addr_type;
 +	cp.direct_addr_type = conn->dst_type;
 +	bacpy(&cp.direct_addr, &conn->dst);
 +	cp.channel_map = hdev->le_adv_channel_map;
 +
 +	hci_req_add(req, HCI_OP_LE_SET_ADV_PARAM, sizeof(cp), &cp);
 +
++<<<<<<< HEAD
 +	enable = 0x01;
 +	hci_req_add(req, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable), &enable);
++=======
+ 		/* As per Core Spec 5.2 Vol 2, PART E, Sec 7.8.53, for
+ 		 * advertising_event_property LE_LEGACY_ADV_DIRECT_IND
+ 		 * does not supports advertising data when the advertising set already
+ 		 * contains some, the controller shall return erroc code 'Invalid
+ 		 * HCI Command Parameters(0x12).
+ 		 * So it is required to remove adv set for handle 0x00. since we use
+ 		 * instance 0 for directed adv.
+ 		 */
+ 		hci_req_add(req, HCI_OP_LE_REMOVE_ADV_SET, sizeof(cp.handle), &cp.handle);
+ 
+ 		hci_req_add(req, HCI_OP_LE_SET_EXT_ADV_PARAMS, sizeof(cp), &cp);
+ 
+ 		if (own_addr_type == ADDR_LE_DEV_RANDOM &&
+ 		    bacmp(&random_addr, BDADDR_ANY) &&
+ 		    bacmp(&random_addr, &hdev->random_addr)) {
+ 			struct hci_cp_le_set_adv_set_rand_addr cp;
+ 
+ 			memset(&cp, 0, sizeof(cp));
+ 
+ 			cp.handle = 0;
+ 			bacpy(&cp.bdaddr, &random_addr);
+ 
+ 			hci_req_add(req,
+ 				    HCI_OP_LE_SET_ADV_SET_RAND_ADDR,
+ 				    sizeof(cp), &cp);
+ 		}
+ 
+ 		__hci_req_enable_ext_advertising(req, 0x00);
+ 	} else {
+ 		struct hci_cp_le_set_adv_param cp;
+ 
+ 		/* Clear the HCI_LE_ADV bit temporarily so that the
+ 		 * hci_update_random_address knows that it's safe to go ahead
+ 		 * and write a new random address. The flag will be set back on
+ 		 * as soon as the SET_ADV_ENABLE HCI command completes.
+ 		 */
+ 		hci_dev_clear_flag(hdev, HCI_LE_ADV);
+ 
+ 		/* Set require_privacy to false so that the remote device has a
+ 		 * chance of identifying us.
+ 		 */
+ 		if (hci_update_random_address(req, false, conn_use_rpa(conn),
+ 					      &own_addr_type) < 0)
+ 			return;
+ 
+ 		memset(&cp, 0, sizeof(cp));
+ 
+ 		/* Some controllers might reject command if intervals are not
+ 		 * within range for undirected advertising.
+ 		 * BCM20702A0 is known to be affected by this.
+ 		 */
+ 		cp.min_interval = cpu_to_le16(0x0020);
+ 		cp.max_interval = cpu_to_le16(0x0020);
+ 
+ 		cp.type = LE_ADV_DIRECT_IND;
+ 		cp.own_address_type = own_addr_type;
+ 		cp.direct_addr_type = conn->dst_type;
+ 		bacpy(&cp.direct_addr, &conn->dst);
+ 		cp.channel_map = hdev->le_adv_channel_map;
+ 
+ 		hci_req_add(req, HCI_OP_LE_SET_ADV_PARAM, sizeof(cp), &cp);
+ 
+ 		enable = 0x01;
+ 		hci_req_add(req, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),
+ 			    &enable);
+ 	}
++>>>>>>> a9e45698b37d (Bluetooth: Remove adv set for directed advertising)
  
  	conn->state = BT_CONNECT;
  }
* Unmerged path include/net/bluetooth/hci.h
* Unmerged path net/bluetooth/hci_conn.c
