io_uring: file switch work needs to get flushed on exit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit e46a7950d362231a4d0b078af5f4c109b8e5ac9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e46a7950.failed

We currently flush early, but if we have something in progress and a
new switch is scheduled, we need to ensure to flush after our teardown
as well.

	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit e46a7950d362231a4d0b078af5f4c109b8e5ac9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 28a601d08266,a0a58c181eaf..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -2753,14 -5072,40 +2753,28 @@@ static void __io_sqe_files_unregister(s
  #endif
  }
  
 -static void io_file_ref_kill(struct percpu_ref *ref)
 -{
 -	struct fixed_file_data *data;
 -
 -	data = container_of(ref, struct fixed_file_data, refs);
 -	complete(&data->done);
 -}
 -
  static int io_sqe_files_unregister(struct io_ring_ctx *ctx)
  {
 -	struct fixed_file_data *data = ctx->file_data;
 -	unsigned nr_tables, i;
 -
 -	if (!data)
 +	if (!ctx->user_files)
  		return -ENXIO;
  
++<<<<<<< HEAD
++=======
+ 	/* protect against inflight atomic switch, which drops the ref */
+ 	percpu_ref_get(&data->refs);
+ 	/* wait for existing switches */
+ 	flush_work(&data->ref_work);
+ 	percpu_ref_kill_and_confirm(&data->refs, io_file_ref_kill);
+ 	wait_for_completion(&data->done);
+ 	percpu_ref_put(&data->refs);
+ 	/* flush potential new switch */
+ 	flush_work(&data->ref_work);
+ 	percpu_ref_exit(&data->refs);
+ 
++>>>>>>> e46a7950d362 (io_uring: file switch work needs to get flushed on exit)
  	__io_sqe_files_unregister(ctx);
 -	nr_tables = DIV_ROUND_UP(ctx->nr_user_files, IORING_MAX_FILES_TABLE);
 -	for (i = 0; i < nr_tables; i++)
 -		kfree(data->table[i].files);
 -	kfree(data->table);
 -	kfree(data);
 -	ctx->file_data = NULL;
 +	kfree(ctx->user_files);
 +	ctx->user_files = NULL;
  	ctx->nr_user_files = 0;
  	return 0;
  }
* Unmerged path fs/io_uring.c
