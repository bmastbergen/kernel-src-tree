RDMA/bnxt_re: Refactor doorbell management functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Devesh Sharma <devesh.sharma@broadcom.com>
commit 6f53196bc5e7fd3c05337f24977cacb08e0f9753
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6f53196b.failed

Moving all the fast path doorbell functions at one place under
qplib_res.h. To pass doorbell record information a new structure
bnxt_qplib_db_info has been introduced.  Every roce object holds an
instance of this structure and doorbell information is initialized during
resource creation.

When DB is rung only the current queue index is read from hardware ring
and rest of the data is taken from pre-initialized dbinfo structure.

Link: https://lore.kernel.org/r/1581786665-23705-8-git-send-email-devesh.sharma@broadcom.com
	Signed-off-by: Devesh Sharma <devesh.sharma@broadcom.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 6f53196bc5e7fd3c05337f24977cacb08e0f9753)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/bnxt_re/qplib_fp.c
#	drivers/infiniband/hw/bnxt_re/qplib_fp.h
#	drivers/infiniband/hw/bnxt_re/qplib_rcfw.c
#	drivers/infiniband/hw/bnxt_re/qplib_rcfw.h
diff --cc drivers/infiniband/hw/bnxt_re/qplib_fp.c
index dff535996557,2ccf1c3708d1..000000000000
--- a/drivers/infiniband/hw/bnxt_re/qplib_fp.c
+++ b/drivers/infiniband/hw/bnxt_re/qplib_fp.c
@@@ -314,9 -314,7 +315,13 @@@ static void bnxt_qplib_service_nq(unsig
  	}
  	if (hwq->cons != raw_cons) {
  		hwq->cons = raw_cons;
++<<<<<<< HEAD
 +		bnxt_qplib_ring_nq_db_rearm(nq->bar_reg_iomem, hwq->cons,
 +					    hwq->max_elements, nq->ring_id,
 +					    gen_p5);
++=======
+ 		bnxt_qplib_ring_nq_db(&nq->nq_db.dbinfo, nq->res->cctx, true);
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  	}
  }
  
@@@ -340,18 -338,16 +345,24 @@@ static irqreturn_t bnxt_qplib_nq_irq(in
  
  void bnxt_qplib_nq_stop_irq(struct bnxt_qplib_nq *nq, bool kill)
  {
++<<<<<<< HEAD
 +	bool gen_p5 = bnxt_qplib_is_chip_gen_p5(nq->res->cctx);
 +	tasklet_disable(&nq->worker);
 +	/* Mask h/w interrupt */
 +	bnxt_qplib_ring_nq_db(nq->bar_reg_iomem, nq->hwq.cons,
 +			      nq->hwq.max_elements, nq->ring_id, gen_p5);
++=======
+ 	tasklet_disable(&nq->nq_tasklet);
+ 	/* Mask h/w interrupt */
+ 	bnxt_qplib_ring_nq_db(&nq->nq_db.dbinfo, nq->res->cctx, false);
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  	/* Sync with last running IRQ handler */
 -	synchronize_irq(nq->msix_vec);
 +	synchronize_irq(nq->vector);
  	if (kill)
 -		tasklet_kill(&nq->nq_tasklet);
 +		tasklet_kill(&nq->worker);
  	if (nq->requested) {
 -		irq_set_affinity_hint(nq->msix_vec, NULL);
 -		free_irq(nq->msix_vec, nq);
 +		irq_set_affinity_hint(nq->vector, NULL);
 +		free_irq(nq->vector, nq);
  		nq->requested = false;
  	}
  }
@@@ -364,12 -360,12 +375,19 @@@ void bnxt_qplib_disable_nq(struct bnxt_
  	}
  
  	/* Make sure the HW is stopped! */
 -	bnxt_qplib_nq_stop_irq(nq, true);
 +	if (nq->requested)
 +		bnxt_qplib_nq_stop_irq(nq, true);
  
++<<<<<<< HEAD
 +	if (nq->bar_reg_iomem)
 +		iounmap(nq->bar_reg_iomem);
 +	nq->bar_reg_iomem = NULL;
++=======
+ 	if (nq->nq_db.reg.bar_reg) {
+ 		iounmap(nq->nq_db.reg.bar_reg);
+ 		nq->nq_db.reg.bar_reg = NULL;
+ 	}
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  
  	nq->cqn_handler = NULL;
  	nq->srqn_handler = NULL;
@@@ -403,31 -398,61 +420,75 @@@ int bnxt_qplib_nq_start_irq(struct bnxt
  	if (rc) {
  		dev_warn(&nq->pdev->dev,
  			 "set affinity failed; vector: %d nq_idx: %d\n",
 -			 nq->msix_vec, nq_indx);
 +			 nq->vector, nq_indx);
  	}
  	nq->requested = true;
++<<<<<<< HEAD
 +	bnxt_qplib_ring_nq_db_rearm(nq->bar_reg_iomem, nq->hwq.cons,
 +				    nq->hwq.max_elements, nq->ring_id, gen_p5);
++=======
+ 	bnxt_qplib_ring_nq_db(&nq->nq_db.dbinfo, nq->res->cctx, true);
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static int bnxt_qplib_map_nq_db(struct bnxt_qplib_nq *nq,  u32 reg_offt)
+ {
+ 	resource_size_t reg_base;
+ 	struct bnxt_qplib_nq_db *nq_db;
+ 	struct pci_dev *pdev;
+ 	int rc = 0;
+ 
+ 	pdev = nq->pdev;
+ 	nq_db = &nq->nq_db;
+ 
+ 	nq_db->reg.bar_id = NQ_CONS_PCI_BAR_REGION;
+ 	nq_db->reg.bar_base = pci_resource_start(pdev, nq_db->reg.bar_id);
+ 	if (!nq_db->reg.bar_base) {
+ 		dev_err(&pdev->dev, "QPLIB: NQ BAR region %d resc start is 0!",
+ 			nq_db->reg.bar_id);
+ 		rc = -ENOMEM;
+ 		goto fail;
+ 	}
+ 
+ 	reg_base = nq_db->reg.bar_base + reg_offt;
+ 	/* Unconditionally map 8 bytes to support 57500 series */
+ 	nq_db->reg.len = 8;
+ 	nq_db->reg.bar_reg = ioremap(reg_base, nq_db->reg.len);
+ 	if (!nq_db->reg.bar_reg) {
+ 		dev_err(&pdev->dev, "QPLIB: NQ BAR region %d mapping failed",
+ 			nq_db->reg.bar_id);
+ 		rc = -ENOMEM;
+ 		goto fail;
+ 	}
+ 
+ 	nq_db->dbinfo.db = nq_db->reg.bar_reg;
+ 	nq_db->dbinfo.hwq = &nq->hwq;
+ 	nq_db->dbinfo.xid = nq->ring_id;
+ fail:
+ 	return rc;
+ }
+ 
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  int bnxt_qplib_enable_nq(struct pci_dev *pdev, struct bnxt_qplib_nq *nq,
  			 int nq_idx, int msix_vector, int bar_reg_offset,
 -			 cqn_handler_t cqn_handler,
 -			 srqn_handler_t srqn_handler)
 +			 int (*cqn_handler)(struct bnxt_qplib_nq *nq,
 +					    struct bnxt_qplib_cq *),
 +			 int (*srqn_handler)(struct bnxt_qplib_nq *nq,
 +					     struct bnxt_qplib_srq *,
 +					     u8 event))
  {
 +	resource_size_t nq_base;
  	int rc = -1;
  
 -	nq->pdev = pdev;
 -	nq->cqn_handler = cqn_handler;
 -	nq->srqn_handler = srqn_handler;
 +	if (cqn_handler)
 +		nq->cqn_handler = cqn_handler;
 +
 +	if (srqn_handler)
 +		nq->srqn_handler = srqn_handler;
  
  	/* Have a task to schedule CQ notifiers in post send case */
  	nq->cqn_wq  = create_singlethread_workqueue("bnxt_qplib_nq");
diff --cc drivers/infiniband/hw/bnxt_re/qplib_fp.h
index d3f080c18b27,9e8d1c5c3f4a..000000000000
--- a/drivers/infiniband/hw/bnxt_re/qplib_fp.h
+++ b/drivers/infiniband/hw/bnxt_re/qplib_fp.h
@@@ -433,66 -434,32 +434,78 @@@ struct bnxt_qplib_cq 
  					 NQ_DB_IDX_VALID |	\
  					 NQ_DB_IRQ_DIS)
  
++<<<<<<< HEAD
 +static inline void bnxt_qplib_ring_nq_db64(void __iomem *db, u32 index,
 +					   u32 xid, bool arm)
 +{
 +	u64 val;
 +
 +	val = xid & DBC_DBC_XID_MASK;
 +	val |= DBC_DBC_PATH_ROCE;
 +	val |= arm ? DBC_DBC_TYPE_NQ_ARM : DBC_DBC_TYPE_NQ;
 +	val <<= 32;
 +	val |= index & DBC_DBC_INDEX_MASK;
 +	writeq(val, db);
 +}
 +
 +static inline void bnxt_qplib_ring_nq_db_rearm(void __iomem *db, u32 raw_cons,
 +					       u32 max_elements, u32 xid,
 +					       bool gen_p5)
 +{
 +	u32 index = raw_cons & (max_elements - 1);
 +
 +	if (gen_p5)
 +		bnxt_qplib_ring_nq_db64(db, index, xid, true);
 +	else
 +		writel(NQ_DB_CP_FLAGS_REARM | (index & DBC_DBC32_XID_MASK), db);
 +}
 +
 +static inline void bnxt_qplib_ring_nq_db(void __iomem *db, u32 raw_cons,
 +					 u32 max_elements, u32 xid,
 +					 bool gen_p5)
 +{
 +	u32 index = raw_cons & (max_elements - 1);
 +
 +	if (gen_p5)
 +		bnxt_qplib_ring_nq_db64(db, index, xid, false);
 +	else
 +		writel(NQ_DB_CP_FLAGS | (index & DBC_DBC32_XID_MASK), db);
 +}
++=======
+ struct bnxt_qplib_nq_db {
+ 	struct bnxt_qplib_reg_desc	reg;
+ 	struct bnxt_qplib_db_info	dbinfo;
+ };
+ 
+ typedef int (*cqn_handler_t)(struct bnxt_qplib_nq *nq,
+ 		struct bnxt_qplib_cq *cq);
+ typedef int (*srqn_handler_t)(struct bnxt_qplib_nq *nq,
+ 		struct bnxt_qplib_srq *srq, u8 event);
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  
  struct bnxt_qplib_nq {
 -	struct pci_dev			*pdev;
 -	struct bnxt_qplib_res		*res;
 -	char				name[32];
 -	struct bnxt_qplib_hwq		hwq;
 -	struct bnxt_qplib_nq_db		nq_db;
 -	u16				ring_id;
 -	int				msix_vec;
 -	cpumask_t			mask;
 -	struct tasklet_struct		nq_tasklet;
 -	bool				requested;
 -	int				budget;
 -
 -	cqn_handler_t			cqn_handler;
 -	srqn_handler_t			srqn_handler;
 -	struct workqueue_struct		*cqn_wq;
 +	struct pci_dev		*pdev;
 +	struct bnxt_qplib_res	*res;
 +
 +	int			vector;
 +	cpumask_t		mask;
 +	int			budget;
 +	bool			requested;
 +	struct tasklet_struct	worker;
 +	struct bnxt_qplib_hwq	hwq;
 +
 +	u16			bar_reg;
 +	u32			bar_reg_off;
 +	u16			ring_id;
 +	void __iomem		*bar_reg_iomem;
 +
 +	int			(*cqn_handler)(struct bnxt_qplib_nq *nq,
 +					       struct bnxt_qplib_cq *cq);
 +	int			(*srqn_handler)(struct bnxt_qplib_nq *nq,
 +						struct bnxt_qplib_srq *srq,
 +						u8 event);
 +	struct workqueue_struct	*cqn_wq;
 +	char			name[32];
  };
  
  struct bnxt_qplib_nq_work {
diff --cc drivers/infiniband/hw/bnxt_re/qplib_rcfw.c
index c6b6e8363eb8,b0b050e5cd12..000000000000
--- a/drivers/infiniband/hw/bnxt_re/qplib_rcfw.c
+++ b/drivers/infiniband/hw/bnxt_re/qplib_rcfw.c
@@@ -365,10 -379,10 +365,14 @@@ static int bnxt_qplib_process_qp_event(
  static void bnxt_qplib_service_creq(unsigned long data)
  {
  	struct bnxt_qplib_rcfw *rcfw = (struct bnxt_qplib_rcfw *)data;
++<<<<<<< HEAD
 +	bool gen_p5 = bnxt_qplib_is_chip_gen_p5(rcfw->res->cctx);
 +	struct bnxt_qplib_hwq *creq = &rcfw->creq;
++=======
+ 	struct bnxt_qplib_creq_ctx *creq = &rcfw->creq;
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  	u32 type, budget = CREQ_ENTRY_POLL_BUDGET;
 -	struct bnxt_qplib_hwq *hwq = &creq->hwq;
 -	struct creq_base *creqe, **hwq_ptr;
 +	struct creq_base *creqe, **creq_ptr;
  	u32 sw_cons, raw_cons;
  	unsigned long flags;
  
@@@ -412,13 -426,12 +416,20 @@@
  		budget--;
  	}
  
++<<<<<<< HEAD
 +	if (creq->cons != raw_cons) {
 +		creq->cons = raw_cons;
 +		bnxt_qplib_ring_creq_db_rearm(rcfw->creq_bar_reg_iomem,
 +					      raw_cons, creq->max_elements,
 +					      rcfw->creq_ring_id, gen_p5);
++=======
+ 	if (hwq->cons != raw_cons) {
+ 		hwq->cons = raw_cons;
+ 		bnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo,
+ 				      rcfw->res->cctx, true);
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  	}
 -	spin_unlock_irqrestore(&hwq->lock, flags);
 +	spin_unlock_irqrestore(&creq->lock, flags);
  }
  
  static irqreturn_t bnxt_qplib_creq_irq(int irq, void *dev_instance)
@@@ -629,21 -658,20 +640,29 @@@ fail
  
  void bnxt_qplib_rcfw_stop_irq(struct bnxt_qplib_rcfw *rcfw, bool kill)
  {
++<<<<<<< HEAD
 +	bool gen_p5 = bnxt_qplib_is_chip_gen_p5(rcfw->res->cctx);
++=======
+ 	struct bnxt_qplib_creq_ctx *creq;
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  
 -	creq = &rcfw->creq;
 -	tasklet_disable(&creq->creq_tasklet);
 +	tasklet_disable(&rcfw->worker);
  	/* Mask h/w interrupts */
++<<<<<<< HEAD
 +	bnxt_qplib_ring_creq_db(rcfw->creq_bar_reg_iomem, rcfw->creq.cons,
 +				rcfw->creq.max_elements, rcfw->creq_ring_id,
 +				gen_p5);
++=======
+ 	bnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo, rcfw->res->cctx, false);
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  	/* Sync with last running IRQ-handler */
 -	synchronize_irq(creq->msix_vec);
 +	synchronize_irq(rcfw->vector);
  	if (kill)
 -		tasklet_kill(&creq->creq_tasklet);
 +		tasklet_kill(&rcfw->worker);
  
 -	if (creq->requested) {
 -		free_irq(creq->msix_vec, rcfw);
 -		creq->requested = false;
 +	if (rcfw->requested) {
 +		free_irq(rcfw->vector, rcfw);
 +		rcfw->requested = false;
  	}
  }
  
@@@ -672,30 -703,125 +691,137 @@@ void bnxt_qplib_disable_rcfw_channel(st
  int bnxt_qplib_rcfw_start_irq(struct bnxt_qplib_rcfw *rcfw, int msix_vector,
  			      bool need_init)
  {
++<<<<<<< HEAD
 +	bool gen_p5 = bnxt_qplib_is_chip_gen_p5(rcfw->res->cctx);
++=======
+ 	struct bnxt_qplib_creq_ctx *creq;
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  	int rc;
  
 -	creq = &rcfw->creq;
 -
 -	if (creq->requested)
 +	if (rcfw->requested)
  		return -EFAULT;
  
 -	creq->msix_vec = msix_vector;
 +	rcfw->vector = msix_vector;
  	if (need_init)
 -		tasklet_init(&creq->creq_tasklet,
 +		tasklet_init(&rcfw->worker,
  			     bnxt_qplib_service_creq, (unsigned long)rcfw);
  	else
 -		tasklet_enable(&creq->creq_tasklet);
 -	rc = request_irq(creq->msix_vec, bnxt_qplib_creq_irq, 0,
 +		tasklet_enable(&rcfw->worker);
 +	rc = request_irq(rcfw->vector, bnxt_qplib_creq_irq, 0,
  			 "bnxt_qplib_creq", rcfw);
  	if (rc)
  		return rc;
++<<<<<<< HEAD
 +	rcfw->requested = true;
 +	bnxt_qplib_ring_creq_db_rearm(rcfw->creq_bar_reg_iomem,
 +				      rcfw->creq.cons, rcfw->creq.max_elements,
 +				      rcfw->creq_ring_id, gen_p5);
++=======
+ 	creq->requested = true;
+ 
+ 	bnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo, rcfw->res->cctx, true);
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int bnxt_qplib_map_cmdq_mbox(struct bnxt_qplib_rcfw *rcfw, bool is_vf)
+ {
+ 	struct bnxt_qplib_cmdq_mbox *mbox;
+ 	resource_size_t bar_reg;
+ 	struct pci_dev *pdev;
+ 	u16 prod_offt;
+ 	int rc = 0;
+ 
+ 	pdev = rcfw->pdev;
+ 	mbox = &rcfw->cmdq.cmdq_mbox;
+ 
+ 	mbox->reg.bar_id = RCFW_COMM_PCI_BAR_REGION;
+ 	mbox->reg.len = RCFW_COMM_SIZE;
+ 	mbox->reg.bar_base = pci_resource_start(pdev, mbox->reg.bar_id);
+ 	if (!mbox->reg.bar_base) {
+ 		dev_err(&pdev->dev,
+ 			"QPLIB: CMDQ BAR region %d resc start is 0!\n",
+ 			mbox->reg.bar_id);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	bar_reg = mbox->reg.bar_base + RCFW_COMM_BASE_OFFSET;
+ 	mbox->reg.len = RCFW_COMM_SIZE;
+ 	mbox->reg.bar_reg = ioremap(bar_reg, mbox->reg.len);
+ 	if (!mbox->reg.bar_reg) {
+ 		dev_err(&pdev->dev,
+ 			"QPLIB: CMDQ BAR region %d mapping failed\n",
+ 			mbox->reg.bar_id);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	prod_offt = is_vf ? RCFW_VF_COMM_PROD_OFFSET :
+ 			    RCFW_PF_COMM_PROD_OFFSET;
+ 	mbox->prod = (void  __iomem *)(mbox->reg.bar_reg + prod_offt);
+ 	mbox->db = (void __iomem *)(mbox->reg.bar_reg + RCFW_COMM_TRIG_OFFSET);
+ 	return rc;
+ }
+ 
+ static int bnxt_qplib_map_creq_db(struct bnxt_qplib_rcfw *rcfw, u32 reg_offt)
+ {
+ 	struct bnxt_qplib_creq_db *creq_db;
+ 	resource_size_t bar_reg;
+ 	struct pci_dev *pdev;
+ 
+ 	pdev = rcfw->pdev;
+ 	creq_db = &rcfw->creq.creq_db;
+ 
+ 	creq_db->reg.bar_id = RCFW_COMM_CONS_PCI_BAR_REGION;
+ 	creq_db->reg.bar_base = pci_resource_start(pdev, creq_db->reg.bar_id);
+ 	if (!creq_db->reg.bar_id)
+ 		dev_err(&pdev->dev,
+ 			"QPLIB: CREQ BAR region %d resc start is 0!",
+ 			creq_db->reg.bar_id);
+ 
+ 	bar_reg = creq_db->reg.bar_base + reg_offt;
+ 	/* Unconditionally map 8 bytes to support 57500 series */
+ 	creq_db->reg.len = 8;
+ 	creq_db->reg.bar_reg = ioremap(bar_reg, creq_db->reg.len);
+ 	if (!creq_db->reg.bar_reg) {
+ 		dev_err(&pdev->dev,
+ 			"QPLIB: CREQ BAR region %d mapping failed",
+ 			creq_db->reg.bar_id);
+ 		return -ENOMEM;
+ 	}
+ 	creq_db->dbinfo.db = creq_db->reg.bar_reg;
+ 	creq_db->dbinfo.hwq = &rcfw->creq.hwq;
+ 	creq_db->dbinfo.xid = rcfw->creq.ring_id;
+ 	return 0;
+ }
+ 
+ static void bnxt_qplib_start_rcfw(struct bnxt_qplib_rcfw *rcfw)
+ {
+ 	struct bnxt_qplib_cmdq_ctx *cmdq;
+ 	struct bnxt_qplib_creq_ctx *creq;
+ 	struct bnxt_qplib_cmdq_mbox *mbox;
+ 	struct cmdq_init init = {0};
+ 
+ 	cmdq = &rcfw->cmdq;
+ 	creq = &rcfw->creq;
+ 	mbox = &cmdq->cmdq_mbox;
+ 
+ 	init.cmdq_pbl = cpu_to_le64(cmdq->hwq.pbl[PBL_LVL_0].pg_map_arr[0]);
+ 	init.cmdq_size_cmdq_lvl =
+ 			cpu_to_le16(((rcfw->cmdq_depth <<
+ 				      CMDQ_INIT_CMDQ_SIZE_SFT) &
+ 				    CMDQ_INIT_CMDQ_SIZE_MASK) |
+ 				    ((cmdq->hwq.level <<
+ 				      CMDQ_INIT_CMDQ_LVL_SFT) &
+ 				    CMDQ_INIT_CMDQ_LVL_MASK));
+ 	init.creq_ring_id = cpu_to_le16(creq->ring_id);
+ 	/* Write to the Bono mailbox register */
+ 	__iowrite32_copy(mbox->reg.bar_reg, &init, sizeof(init) / 4);
+ }
+ 
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  int bnxt_qplib_enable_rcfw_channel(struct bnxt_qplib_rcfw *rcfw,
  				   int msix_vector,
  				   int cp_bar_reg_off, int virt_fn,
diff --cc drivers/infiniband/hw/bnxt_re/qplib_rcfw.h
index ab1531c7e27f,411fce3493b6..000000000000
--- a/drivers/infiniband/hw/bnxt_re/qplib_rcfw.h
+++ b/drivers/infiniband/hw/bnxt_re/qplib_rcfw.h
@@@ -225,6 -226,46 +225,49 @@@ struct bnxt_qplib_qp_node 
  
  #define BNXT_QPLIB_OOS_COUNT_MASK 0xFFFFFFFF
  
++<<<<<<< HEAD
++=======
+ #define FIRMWARE_INITIALIZED_FLAG	(0)
+ #define FIRMWARE_FIRST_FLAG		(31)
+ #define FIRMWARE_TIMED_OUT		(3)
+ struct bnxt_qplib_cmdq_mbox {
+ 	struct bnxt_qplib_reg_desc	reg;
+ 	void __iomem			*prod;
+ 	void __iomem			*db;
+ };
+ 
+ struct bnxt_qplib_cmdq_ctx {
+ 	struct bnxt_qplib_hwq		hwq;
+ 	struct bnxt_qplib_cmdq_mbox	cmdq_mbox;
+ 	wait_queue_head_t		waitq;
+ 	unsigned long			flags;
+ 	unsigned long			*cmdq_bitmap;
+ 	u32				bmap_size;
+ 	u32				seq_num;
+ };
+ 
+ struct bnxt_qplib_creq_db {
+ 	struct bnxt_qplib_reg_desc	reg;
+ 	struct bnxt_qplib_db_info	dbinfo;
+ };
+ 
+ struct bnxt_qplib_creq_stat {
+ 	u64	creq_qp_event_processed;
+ 	u64	creq_func_event_processed;
+ };
+ 
+ struct bnxt_qplib_creq_ctx {
+ 	struct bnxt_qplib_hwq		hwq;
+ 	struct bnxt_qplib_creq_db	creq_db;
+ 	struct bnxt_qplib_creq_stat	stats;
+ 	struct tasklet_struct		creq_tasklet;
+ 	aeq_handler_t			aeq_handler;
+ 	u16				ring_id;
+ 	int				msix_vec;
+ 	bool				requested; /*irq handler installed */
+ };
+ 
++>>>>>>> 6f53196bc5e7 (RDMA/bnxt_re: Refactor doorbell management functions)
  /* RCFW Communication Channels */
  struct bnxt_qplib_rcfw {
  	struct pci_dev		*pdev;
* Unmerged path drivers/infiniband/hw/bnxt_re/qplib_fp.c
* Unmerged path drivers/infiniband/hw/bnxt_re/qplib_fp.h
* Unmerged path drivers/infiniband/hw/bnxt_re/qplib_rcfw.c
* Unmerged path drivers/infiniband/hw/bnxt_re/qplib_rcfw.h
diff --git a/drivers/infiniband/hw/bnxt_re/qplib_res.h b/drivers/infiniband/hw/bnxt_re/qplib_res.h
index fe8a6dd7aeb1..99a8e55d0422 100644
--- a/drivers/infiniband/hw/bnxt_re/qplib_res.h
+++ b/drivers/infiniband/hw/bnxt_re/qplib_res.h
@@ -126,6 +126,13 @@ struct bnxt_qplib_hwq {
 	u8				is_user;
 };
 
+struct bnxt_qplib_db_info {
+	void __iomem		*db;
+	void __iomem		*priv_db;
+	struct bnxt_qplib_hwq	*hwq;
+	u32			xid;
+};
+
 /* Tables */
 struct bnxt_qplib_pd_tbl {
 	unsigned long			*tbl;
@@ -283,4 +290,75 @@ void bnxt_qplib_free_ctx(struct bnxt_qplib_res *res,
 int bnxt_qplib_alloc_ctx(struct bnxt_qplib_res *res,
 			 struct bnxt_qplib_ctx *ctx,
 			 bool virt_fn, bool is_p5);
+
+static inline void bnxt_qplib_ring_db32(struct bnxt_qplib_db_info *info,
+					bool arm)
+{
+	u32 key;
+
+	key = info->hwq->cons & (info->hwq->max_elements - 1);
+	key |= (CMPL_DOORBELL_IDX_VALID |
+		(CMPL_DOORBELL_KEY_CMPL & CMPL_DOORBELL_KEY_MASK));
+	if (!arm)
+		key |= CMPL_DOORBELL_MASK;
+	writel(key, info->db);
+}
+
+static inline void bnxt_qplib_ring_db(struct bnxt_qplib_db_info *info,
+				      u32 type)
+{
+	u64 key = 0;
+
+	key = (info->xid & DBC_DBC_XID_MASK) | DBC_DBC_PATH_ROCE | type;
+	key <<= 32;
+	key |= (info->hwq->cons & (info->hwq->max_elements - 1)) &
+		DBC_DBC_INDEX_MASK;
+	writeq(key, info->db);
+}
+
+static inline void bnxt_qplib_ring_prod_db(struct bnxt_qplib_db_info *info,
+					   u32 type)
+{
+	u64 key = 0;
+
+	key = (info->xid & DBC_DBC_XID_MASK) | DBC_DBC_PATH_ROCE | type;
+	key <<= 32;
+	key |= (info->hwq->prod & (info->hwq->max_elements - 1)) &
+		DBC_DBC_INDEX_MASK;
+	writeq(key, info->db);
+}
+
+static inline void bnxt_qplib_armen_db(struct bnxt_qplib_db_info *info,
+				       u32 type)
+{
+	u64 key = 0;
+
+	key = (info->xid & DBC_DBC_XID_MASK) | DBC_DBC_PATH_ROCE | type;
+	key <<= 32;
+	writeq(key, info->priv_db);
+}
+
+static inline void bnxt_qplib_srq_arm_db(struct bnxt_qplib_db_info *info,
+					 u32 th)
+{
+	u64 key = 0;
+
+	key = (info->xid & DBC_DBC_XID_MASK) | DBC_DBC_PATH_ROCE | th;
+	key <<= 32;
+	key |=  th & DBC_DBC_INDEX_MASK;
+	writeq(key, info->priv_db);
+}
+
+static inline void bnxt_qplib_ring_nq_db(struct bnxt_qplib_db_info *info,
+					 struct bnxt_qplib_chip_ctx *cctx,
+					 bool arm)
+{
+	u32 type;
+
+	type = arm ? DBC_DBC_TYPE_NQ_ARM : DBC_DBC_TYPE_NQ;
+	if (bnxt_qplib_is_chip_gen_p5(cctx))
+		bnxt_qplib_ring_db(info, type);
+	else
+		bnxt_qplib_ring_db32(info, arm);
+}
 #endif /* __BNXT_QPLIB_RES_H__ */
