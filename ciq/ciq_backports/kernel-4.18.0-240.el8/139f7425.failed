kvm: x86: Use KVM CPU capabilities to determine CR4 reserved bits

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 139f7425fdf54f054463e7524b9f54c41af8407f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/139f7425.failed

Using CPUID data can be useful for the processor compatibility
check, but that's it.  Using it to compute guest-reserved bits
can have both false positives (such as LA57 and UMIP which we
are already handling) and false negatives: in particular, with
this patch we don't allow anymore a KVM guest to set CR4.PKE
when CR4.PKE is clear on the host.

Fixes: b9dd21e104bc ("KVM: x86: simplify handling of PKRU")
	Reported-by: Jim Mattson <jmattson@google.com>
	Tested-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 139f7425fdf54f054463e7524b9f54c41af8407f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index bef07866f41a,8d296e3d0d56..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -914,19 -926,6 +914,22 @@@ EXPORT_SYMBOL_GPL(kvm_set_xcr)
  	__reserved_bits;				\
  })
  
++<<<<<<< HEAD
 +static u64 kvm_host_cr4_reserved_bits(struct cpuinfo_x86 *c)
 +{
 +	u64 reserved_bits = __cr4_reserved_bits(cpu_has, c);
 +
 +	if (cpuid_ecx(0x7) & feature_bit(LA57))
 +		reserved_bits &= ~X86_CR4_LA57;
 +
 +	if (kvm_x86_ops->umip_emulated())
 +		reserved_bits &= ~X86_CR4_UMIP;
 +
 +	return reserved_bits;
 +}
 +
++=======
++>>>>>>> 139f7425fdf5 (kvm: x86: Use KVM CPU capabilities to determine CR4 reserved bits)
  static int kvm_valid_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
  {
  	if (cr4 & cr4_reserved_bits)
@@@ -9425,7 -9657,14 +9428,18 @@@ int kvm_arch_hardware_setup(void *opaqu
  	if (r != 0)
  		return r;
  
++<<<<<<< HEAD
 +	cr4_reserved_bits = kvm_host_cr4_reserved_bits(&boot_cpu_data);
++=======
+ 	memcpy(&kvm_x86_ops, ops->runtime_ops, sizeof(kvm_x86_ops));
+ 
+ 	if (!kvm_cpu_cap_has(X86_FEATURE_XSAVES))
+ 		supported_xss = 0;
+ 
+ #define __kvm_cpu_cap_has(UNUSED_, f) kvm_cpu_cap_has(f)
+ 	cr4_reserved_bits = __cr4_reserved_bits(__kvm_cpu_cap_has, UNUSED_);
+ #undef __kvm_cpu_cap_has
++>>>>>>> 139f7425fdf5 (kvm: x86: Use KVM CPU capabilities to determine CR4 reserved bits)
  
  	if (kvm_has_tsc_control) {
  		/*
@@@ -9459,10 -9695,12 +9473,11 @@@ int kvm_arch_check_processor_compat(voi
  
  	WARN_ON(!irqs_disabled());
  
- 	if (kvm_host_cr4_reserved_bits(c) != cr4_reserved_bits)
+ 	if (__cr4_reserved_bits(cpu_has, c) !=
+ 	    __cr4_reserved_bits(cpu_has, &boot_cpu_data))
  		return -EIO;
  
 -	return ops->check_processor_compatibility();
 +	return kvm_x86_ops->check_processor_compatibility();
  }
  
  bool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/x86.c
