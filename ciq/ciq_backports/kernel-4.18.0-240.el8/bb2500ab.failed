Bluetooth: hci_qca: Retry btsoc initialize when it fails

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Rocky Liao <rjliao@codeaurora.org>
commit bb2500ab0270aa0d1d39614f08f4f9a2dc0df8c1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/bb2500ab.failed

This patch adds the retry of btsoc initialization when it fails. There are
reports that the btsoc initialization may fail on some platforms but the
repro ratio is very low. The symptoms is the firmware downloading failed
due to the UART write timed out. The failure may be caused by UART,
platform HW or the btsoc itself but it's very difficlut to root cause,
given the repro ratio is very low. Add a retry for the btsoc initialization
can work around most of the failures and make Bluetooth finally works.

	Signed-off-by: Rocky Liao <rjliao@codeaurora.org>
	Reviewed-by: Matthias Kaehlcke <mka@chromium.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit bb2500ab0270aa0d1d39614f08f4f9a2dc0df8c1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/hci_qca.c
diff --cc drivers/bluetooth/hci_qca.c
index c7723b08787d,1139142e8eed..000000000000
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@@ -58,6 -52,27 +58,30 @@@
  /* susclk rate */
  #define SUSCLK_RATE_32KHZ	32768
  
++<<<<<<< HEAD
++=======
+ /* Controller debug log header */
+ #define QCA_DEBUG_HANDLE	0x2EDC
+ 
+ /* max retry count when init fails */
+ #define MAX_INIT_RETRIES 3
+ 
+ /* Controller dump header */
+ #define QCA_SSR_DUMP_HANDLE		0x0108
+ #define QCA_DUMP_PACKET_SIZE		255
+ #define QCA_LAST_SEQUENCE_NUM		0xFFFF
+ #define QCA_CRASHBYTE_PACKET_LEN	1096
+ #define QCA_MEMDUMP_BYTE		0xFB
+ 
+ enum qca_flags {
+ 	QCA_IBS_ENABLED,
+ 	QCA_DROP_VENDOR_EVENT,
+ 	QCA_SUSPENDING,
+ 	QCA_MEMDUMP_COLLECTION
+ };
+ 
+ 
++>>>>>>> bb2500ab0270 (Bluetooth: hci_qca: Retry btsoc initialize when it fails)
  /* HCI_IBS transmit side sleep protocol states */
  enum tx_ibs_states {
  	HCI_IBS_TX_ASLEEP,
@@@ -914,48 -1542,73 +938,79 @@@ static int qca_setup(struct hci_uart *h
  	struct hci_dev *hdev = hu->hdev;
  	struct qca_data *qca = hu->priv;
  	unsigned int speed, qca_baudrate = QCA_BAUDRATE_115200;
++<<<<<<< HEAD
++=======
+ 	unsigned int retries = 0;
+ 	enum qca_btsoc_type soc_type = qca_soc_type(hu);
+ 	const char *firmware_name = qca_get_firmware_name(hu);
++>>>>>>> bb2500ab0270 (Bluetooth: hci_qca: Retry btsoc initialize when it fails)
  	int ret;
 -	int soc_ver = 0;
  
 -	ret = qca_check_speeds(hu);
 -	if (ret)
 -		return ret;
 +	bt_dev_info(hdev, "ROME setup");
  
  	/* Patch downloading has to be done without IBS mode */
 -	clear_bit(QCA_IBS_ENABLED, &qca->flags);
 +	clear_bit(STATE_IN_BAND_SLEEP_ENABLED, &qca->flags);
  
 -	/* Enable controller to do both LE scan and BR/EDR inquiry
 -	 * simultaneously.
 -	 */
 -	set_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);
 +	/* Setup initial baudrate */
 +	speed = 0;
 +	if (hu->init_speed)
 +		speed = hu->init_speed;
 +	else if (hu->proto->init_speed)
 +		speed = hu->proto->init_speed;
  
++<<<<<<< HEAD
 +	if (speed)
 +		host_set_baudrate(hu, speed);
++=======
+ 	bt_dev_info(hdev, "setting up %s",
+ 		qca_is_wcn399x(soc_type) ? "wcn399x" : "ROME");
+ 
+ retry:
+ 	ret = qca_power_on(hdev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (qca_is_wcn399x(soc_type)) {
+ 		/* Enable NON_PERSISTENT_SETUP QUIRK to ensure to execute
+ 		 * setup for every hci up.
+ 		 */
+ 		set_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks);
+ 		set_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks);
+ 		hu->hdev->shutdown = qca_power_off;
+ 
+ 		ret = qca_read_soc_version(hdev, &soc_ver, soc_type);
+ 		if (ret)
+ 			return ret;
+ 	} else {
+ 		qca_set_speed(hu, QCA_INIT_SPEED);
+ 	}
++>>>>>>> bb2500ab0270 (Bluetooth: hci_qca: Retry btsoc initialize when it fails)
  
  	/* Setup user speed if needed */
 -	speed = qca_get_speed(hu, QCA_OPER_SPEED);
 -	if (speed) {
 -		ret = qca_set_speed(hu, QCA_OPER_SPEED);
 -		if (ret)
 -			return ret;
 +	speed = 0;
 +	if (hu->oper_speed)
 +		speed = hu->oper_speed;
 +	else if (hu->proto->oper_speed)
 +		speed = hu->proto->oper_speed;
  
 +	if (speed) {
  		qca_baudrate = qca_get_baudrate_value(speed);
 -	}
  
 -	if (!qca_is_wcn399x(soc_type)) {
 -		/* Get QCA version information */
 -		ret = qca_read_soc_version(hdev, &soc_ver, soc_type);
 -		if (ret)
 +		bt_dev_info(hdev, "Set UART speed to %d", speed);
 +		ret = qca_set_baudrate(hdev, qca_baudrate);
 +		if (ret) {
 +			bt_dev_err(hdev, "Failed to change the baud rate (%d)",
 +				   ret);
  			return ret;
 +		}
 +		host_set_baudrate(hu, speed);
  	}
  
 -	bt_dev_info(hdev, "QCA controller version 0x%08x", soc_ver);
  	/* Setup patch / NVM configurations */
 -	ret = qca_uart_setup(hdev, qca_baudrate, soc_type, soc_ver,
 -			firmware_name);
 +	ret = qca_uart_setup_rome(hdev, qca_baudrate);
  	if (!ret) {
 -		set_bit(QCA_IBS_ENABLED, &qca->flags);
 +		set_bit(STATE_IN_BAND_SLEEP_ENABLED, &qca->flags);
  		qca_debugfs_init(hdev);
 -		hu->hdev->hw_error = qca_hw_error;
 -		hu->hdev->cmd_timeout = qca_cmd_timeout;
  	} else if (ret == -ENOENT) {
  		/* No patch/nvm-config found, run with original fw/config */
  		ret = 0;
* Unmerged path drivers/bluetooth/hci_qca.c
