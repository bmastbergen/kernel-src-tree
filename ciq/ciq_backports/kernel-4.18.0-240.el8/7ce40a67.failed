drm/i915/tc: Skip ref held check for TC legacy aux power wells

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit 7ce40a671538c225ea8eb170830cad90b16ec211
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7ce40a67.failed

As part of ICL TC cold exit sequences we need to request aux power
well before lock the access to TC ports, so skiping the
intel_tc_port_ref_held() check for TC legacy ports.

	Reviewed-by: Imre Deak <imre.deak@intel.com>
	Tested-by: You-Sheng Yang <vicamo.yang@canonical.com>
	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200414194956.164323-5-jose.souza@intel.com
(cherry picked from commit 7ce40a671538c225ea8eb170830cad90b16ec211)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display_power.c
diff --cc drivers/gpu/drm/i915/display/intel_display_power.c
index dd1a43a366f2,3a4a378792f2..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display_power.c
+++ b/drivers/gpu/drm/i915/display/intel_display_power.c
@@@ -441,6 -524,82 +441,85 @@@ icl_combo_phy_aux_power_well_disable(st
  #define ICL_TBT_AUX_PW_TO_CH(pw_idx)	\
  	((pw_idx) - ICL_PW_CTL_IDX_AUX_TBT1 + AUX_CH_C)
  
++<<<<<<< HEAD
++=======
+ static enum aux_ch icl_tc_phy_aux_ch(struct drm_i915_private *dev_priv,
+ 				     struct i915_power_well *power_well)
+ {
+ 	int pw_idx = power_well->desc->hsw.idx;
+ 
+ 	return power_well->desc->hsw.is_tc_tbt ? ICL_TBT_AUX_PW_TO_CH(pw_idx) :
+ 						 ICL_AUX_PW_TO_CH(pw_idx);
+ }
+ 
+ #if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
+ 
+ static u64 async_put_domains_mask(struct i915_power_domains *power_domains);
+ 
+ static int power_well_async_ref_count(struct drm_i915_private *dev_priv,
+ 				      struct i915_power_well *power_well)
+ {
+ 	int refs = hweight64(power_well->desc->domains &
+ 			     async_put_domains_mask(&dev_priv->power_domains));
+ 
+ 	drm_WARN_ON(&dev_priv->drm, refs > power_well->count);
+ 
+ 	return refs;
+ }
+ 
+ static void icl_tc_port_assert_ref_held(struct drm_i915_private *dev_priv,
+ 					struct i915_power_well *power_well,
+ 					struct intel_digital_port *dig_port)
+ {
+ 	/* Bypass the check if all references are released asynchronously */
+ 	if (power_well_async_ref_count(dev_priv, power_well) ==
+ 	    power_well->count)
+ 		return;
+ 
+ 	if (drm_WARN_ON(&dev_priv->drm, !dig_port))
+ 		return;
+ 
+ 	if (INTEL_GEN(dev_priv) == 11 && dig_port->tc_legacy_port)
+ 		return;
+ 
+ 	drm_WARN_ON(&dev_priv->drm, !intel_tc_port_ref_held(dig_port));
+ }
+ 
+ #else
+ 
+ static void icl_tc_port_assert_ref_held(struct drm_i915_private *dev_priv,
+ 					struct i915_power_well *power_well,
+ 					struct intel_digital_port *dig_port)
+ {
+ }
+ 
+ #endif
+ 
+ #define TGL_AUX_PW_TO_TC_PORT(pw_idx)	((pw_idx) - TGL_PW_CTL_IDX_AUX_TC1)
+ 
+ static void icl_tc_cold_exit(struct drm_i915_private *i915)
+ {
+ 	int ret, tries = 0;
+ 
+ 	while (1) {
+ 		ret = sandybridge_pcode_write_timeout(i915,
+ 						      ICL_PCODE_EXIT_TCCOLD,
+ 						      0, 250, 1);
+ 		if (ret != -EAGAIN || ++tries == 3)
+ 			break;
+ 		msleep(1);
+ 	}
+ 
+ 	/* Spec states that TC cold exit can take up to 1ms to complete */
+ 	if (!ret)
+ 		msleep(1);
+ 
+ 	/* TODO: turn failure into a error as soon i915 CI updates ICL IFWI */
+ 	drm_dbg_kms(&i915->drm, "TC cold block %s\n", ret ? "failed" :
+ 		    "succeeded");
+ }
+ 
++>>>>>>> 7ce40a671538 (drm/i915/tc: Skip ref held check for TC legacy aux power wells)
  static void
  icl_tc_phy_aux_power_well_enable(struct drm_i915_private *dev_priv,
  				 struct i915_power_well *power_well)
* Unmerged path drivers/gpu/drm/i915/display/intel_display_power.c
