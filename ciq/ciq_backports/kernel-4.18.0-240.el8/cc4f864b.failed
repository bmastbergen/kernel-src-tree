libbpf: Add support for bpf_link-based cgroup attachment

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit cc4f864bb118e0ae7bf9f4e3418eaeb083aa34f2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/cc4f864b.failed

Add bpf_program__attach_cgroup(), which uses BPF_LINK_CREATE subcommand to
create an FD-based kernel bpf_link. Also add low-level bpf_link_create() API.

If expected_attach_type is not specified explicitly with
bpf_program__set_expected_attach_type(), libbpf will try to determine proper
attach type from BPF program's section definition.

Also add support for bpf_link's underlying BPF program replacement:
  - unconditional through high-level bpf_link__update_program() API;
  - cmpxchg-like with specifying expected current BPF program through
    low-level bpf_link_update() API.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200330030001.2312810-4-andriin@fb.com
(cherry picked from commit cc4f864bb118e0ae7bf9f4e3418eaeb083aa34f2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/include/uapi/linux/bpf.h
#	tools/lib/bpf/libbpf.c
#	tools/lib/bpf/libbpf.h
#	tools/lib/bpf/libbpf.map
diff --cc tools/include/uapi/linux/bpf.h
index 2bc35095902a,2e29a671d67e..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -107,6 -107,12 +107,15 @@@ enum bpf_cmd 
  	BPF_MAP_LOOKUP_AND_DELETE_ELEM,
  	BPF_MAP_FREEZE,
  	BPF_BTF_GET_NEXT_ID,
++<<<<<<< HEAD
++=======
+ 	BPF_MAP_LOOKUP_BATCH,
+ 	BPF_MAP_LOOKUP_AND_DELETE_BATCH,
+ 	BPF_MAP_UPDATE_BATCH,
+ 	BPF_MAP_DELETE_BATCH,
+ 	BPF_LINK_CREATE,
+ 	BPF_LINK_UPDATE,
++>>>>>>> cc4f864bb118 (libbpf: Add support for bpf_link-based cgroup attachment)
  };
  
  enum bpf_map_type {
@@@ -507,6 -571,24 +516,27 @@@ union bpf_attr 
  		__u64		probe_offset;	/* output: probe_offset */
  		__u64		probe_addr;	/* output: probe_addr */
  	} task_fd_query;
++<<<<<<< HEAD
++=======
+ 
+ 	struct { /* struct used by BPF_LINK_CREATE command */
+ 		__u32		prog_fd;	/* eBPF program to attach */
+ 		__u32		target_fd;	/* object to attach to */
+ 		__u32		attach_type;	/* attach type */
+ 		__u32		flags;		/* extra flags */
+ 	} link_create;
+ 
+ 	struct { /* struct used by BPF_LINK_UPDATE command */
+ 		__u32		link_fd;	/* link fd */
+ 		/* new program fd to update link with */
+ 		__u32		new_prog_fd;
+ 		__u32		flags;		/* extra flags */
+ 		/* expected link's program fd; is specified only if
+ 		 * BPF_F_REPLACE flag is set in flags */
+ 		__u32		old_prog_fd;
+ 	} link_update;
+ 
++>>>>>>> cc4f864bb118 (libbpf: Add support for bpf_link-based cgroup attachment)
  } __attribute__((aligned(8)));
  
  /* The description below is an attempt at providing documentation to eBPF
diff --cc tools/lib/bpf/libbpf.c
index 7277de638c6d,ff9174282a8c..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -5469,12 -6971,37 +5469,36 @@@ int bpf_prog_load_xattr(const struct bp
  }
  
  struct bpf_link {
 -	int (*detach)(struct bpf_link *link);
  	int (*destroy)(struct bpf_link *link);
 -	char *pin_path;		/* NULL, if not pinned */
 -	int fd;			/* hook FD, -1 if not applicable */
 -	bool disconnected;
  };
  
++<<<<<<< HEAD
++=======
+ /* Replace link's underlying BPF program with the new one */
+ int bpf_link__update_program(struct bpf_link *link, struct bpf_program *prog)
+ {
+ 	return bpf_link_update(bpf_link__fd(link), bpf_program__fd(prog), NULL);
+ }
+ 
+ /* Release "ownership" of underlying BPF resource (typically, BPF program
+  * attached to some BPF hook, e.g., tracepoint, kprobe, etc). Disconnected
+  * link, when destructed through bpf_link__destroy() call won't attempt to
+  * detach/unregisted that BPF resource. This is useful in situations where,
+  * say, attached BPF program has to outlive userspace program that attached it
+  * in the system. Depending on type of BPF program, though, there might be
+  * additional steps (like pinning BPF program in BPF FS) necessary to ensure
+  * exit of userspace program doesn't trigger automatic detachment and clean up
+  * inside the kernel.
+  */
+ void bpf_link__disconnect(struct bpf_link *link)
+ {
+ 	link->disconnected = true;
+ }
+ 
++>>>>>>> cc4f864bb118 (libbpf: Add support for bpf_link-based cgroup attachment)
  int bpf_link__destroy(struct bpf_link *link)
  {
 -	int err = 0;
 +	int err;
  
  	if (!link)
  		return 0;
@@@ -5833,6 -7477,170 +5857,133 @@@ struct bpf_link *bpf_program__attach_ra
  	return (struct bpf_link *)link;
  }
  
++<<<<<<< HEAD
++=======
+ struct bpf_link *bpf_program__attach_trace(struct bpf_program *prog)
+ {
+ 	return bpf_program__attach_btf_id(prog);
+ }
+ 
+ struct bpf_link *bpf_program__attach_lsm(struct bpf_program *prog)
+ {
+ 	return bpf_program__attach_btf_id(prog);
+ }
+ 
+ static struct bpf_link *attach_trace(const struct bpf_sec_def *sec,
+ 				     struct bpf_program *prog)
+ {
+ 	return bpf_program__attach_trace(prog);
+ }
+ 
+ static struct bpf_link *attach_lsm(const struct bpf_sec_def *sec,
+ 				   struct bpf_program *prog)
+ {
+ 	return bpf_program__attach_lsm(prog);
+ }
+ 
+ struct bpf_link *
+ bpf_program__attach_cgroup(struct bpf_program *prog, int cgroup_fd)
+ {
+ 	const struct bpf_sec_def *sec_def;
+ 	enum bpf_attach_type attach_type;
+ 	char errmsg[STRERR_BUFSIZE];
+ 	struct bpf_link *link;
+ 	int prog_fd, link_fd;
+ 
+ 	prog_fd = bpf_program__fd(prog);
+ 	if (prog_fd < 0) {
+ 		pr_warn("program '%s': can't attach before loaded\n",
+ 			bpf_program__title(prog, false));
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	link = calloc(1, sizeof(*link));
+ 	if (!link)
+ 		return ERR_PTR(-ENOMEM);
+ 	link->detach = &bpf_link__detach_fd;
+ 
+ 	attach_type = bpf_program__get_expected_attach_type(prog);
+ 	if (!attach_type) {
+ 		sec_def = find_sec_def(bpf_program__title(prog, false));
+ 		if (sec_def)
+ 			attach_type = sec_def->attach_type;
+ 	}
+ 	link_fd = bpf_link_create(prog_fd, cgroup_fd, attach_type, NULL);
+ 	if (link_fd < 0) {
+ 		link_fd = -errno;
+ 		free(link);
+ 		pr_warn("program '%s': failed to attach to cgroup: %s\n",
+ 			bpf_program__title(prog, false),
+ 			libbpf_strerror_r(link_fd, errmsg, sizeof(errmsg)));
+ 		return ERR_PTR(link_fd);
+ 	}
+ 	link->fd = link_fd;
+ 	return link;
+ }
+ 
+ struct bpf_link *bpf_program__attach(struct bpf_program *prog)
+ {
+ 	const struct bpf_sec_def *sec_def;
+ 
+ 	sec_def = find_sec_def(bpf_program__title(prog, false));
+ 	if (!sec_def || !sec_def->attach_fn)
+ 		return ERR_PTR(-ESRCH);
+ 
+ 	return sec_def->attach_fn(sec_def, prog);
+ }
+ 
+ static int bpf_link__detach_struct_ops(struct bpf_link *link)
+ {
+ 	__u32 zero = 0;
+ 
+ 	if (bpf_map_delete_elem(link->fd, &zero))
+ 		return -errno;
+ 
+ 	return 0;
+ }
+ 
+ struct bpf_link *bpf_map__attach_struct_ops(struct bpf_map *map)
+ {
+ 	struct bpf_struct_ops *st_ops;
+ 	struct bpf_link *link;
+ 	__u32 i, zero = 0;
+ 	int err;
+ 
+ 	if (!bpf_map__is_struct_ops(map) || map->fd == -1)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	link = calloc(1, sizeof(*link));
+ 	if (!link)
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	st_ops = map->st_ops;
+ 	for (i = 0; i < btf_vlen(st_ops->type); i++) {
+ 		struct bpf_program *prog = st_ops->progs[i];
+ 		void *kern_data;
+ 		int prog_fd;
+ 
+ 		if (!prog)
+ 			continue;
+ 
+ 		prog_fd = bpf_program__fd(prog);
+ 		kern_data = st_ops->kern_vdata + st_ops->kern_func_off[i];
+ 		*(unsigned long *)kern_data = prog_fd;
+ 	}
+ 
+ 	err = bpf_map_update_elem(map->fd, &zero, st_ops->kern_vdata, 0);
+ 	if (err) {
+ 		err = -errno;
+ 		free(link);
+ 		return ERR_PTR(err);
+ 	}
+ 
+ 	link->detach = bpf_link__detach_struct_ops;
+ 	link->fd = map->fd;
+ 
+ 	return link;
+ }
+ 
++>>>>>>> cc4f864bb118 (libbpf: Add support for bpf_link-based cgroup attachment)
  enum bpf_perf_event_ret
  bpf_perf_event_read_simple(void *mmap_mem, size_t mmap_size, size_t page_size,
  			   void **copy_mem, size_t *copy_size,
diff --cc tools/lib/bpf/libbpf.h
index e454ceec9fa2,44df1d3e7287..000000000000
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@@ -203,8 -219,18 +203,19 @@@ LIBBPF_API void bpf_program__unload(str
  
  struct bpf_link;
  
++<<<<<<< HEAD
++=======
+ LIBBPF_API struct bpf_link *bpf_link__open(const char *path);
+ LIBBPF_API int bpf_link__fd(const struct bpf_link *link);
+ LIBBPF_API const char *bpf_link__pin_path(const struct bpf_link *link);
+ LIBBPF_API int bpf_link__pin(struct bpf_link *link, const char *path);
+ LIBBPF_API int bpf_link__unpin(struct bpf_link *link);
+ LIBBPF_API int bpf_link__update_program(struct bpf_link *link,
+ 					struct bpf_program *prog);
+ LIBBPF_API void bpf_link__disconnect(struct bpf_link *link);
++>>>>>>> cc4f864bb118 (libbpf: Add support for bpf_link-based cgroup attachment)
  LIBBPF_API int bpf_link__destroy(struct bpf_link *link);
  
 -LIBBPF_API struct bpf_link *
 -bpf_program__attach(struct bpf_program *prog);
  LIBBPF_API struct bpf_link *
  bpf_program__attach_perf_event(struct bpf_program *prog, int pfd);
  LIBBPF_API struct bpf_link *
@@@ -221,6 -247,16 +232,19 @@@ bpf_program__attach_tracepoint(struct b
  LIBBPF_API struct bpf_link *
  bpf_program__attach_raw_tracepoint(struct bpf_program *prog,
  				   const char *tp_name);
++<<<<<<< HEAD
++=======
+ LIBBPF_API struct bpf_link *
+ bpf_program__attach_trace(struct bpf_program *prog);
+ LIBBPF_API struct bpf_link *
+ bpf_program__attach_lsm(struct bpf_program *prog);
+ LIBBPF_API struct bpf_link *
+ bpf_program__attach_cgroup(struct bpf_program *prog, int cgroup_fd);
+ 
+ struct bpf_map;
+ 
+ LIBBPF_API struct bpf_link *bpf_map__attach_struct_ops(struct bpf_map *map);
++>>>>>>> cc4f864bb118 (libbpf: Add support for bpf_link-based cgroup attachment)
  
  struct bpf_insn;
  
diff --cc tools/lib/bpf/libbpf.map
index 3ca7228af37e,bb8831605b25..000000000000
--- a/tools/lib/bpf/libbpf.map
+++ b/tools/lib/bpf/libbpf.map
@@@ -188,9 -197,60 +188,61 @@@ LIBBPF_0.0.4 
  		bpf_map__get_pin_path;
  		bpf_map__is_pinned;
  		bpf_map__set_pin_path;
 -		bpf_object__open_file;
 -		bpf_object__open_mem;
 -		bpf_program__attach_trace;
  		bpf_program__get_expected_attach_type;
  		bpf_program__get_type;
 -		bpf_program__is_tracing;
 -		bpf_program__set_tracing;
 +		bpf_get_link_xdp_info;
  		bpf_program__size;
++<<<<<<< HEAD
 +		bpf_btf_get_next_id;
 +} LIBBPF_0.0.3;
++=======
+ 		btf__find_by_name_kind;
+ 		libbpf_find_vmlinux_btf_id;
+ } LIBBPF_0.0.5;
+ 
+ LIBBPF_0.0.7 {
+ 	global:
+ 		btf_dump__emit_type_decl;
+ 		bpf_link__disconnect;
+ 		bpf_map__attach_struct_ops;
+ 		bpf_map_delete_batch;
+ 		bpf_map_lookup_and_delete_batch;
+ 		bpf_map_lookup_batch;
+ 		bpf_map_update_batch;
+ 		bpf_object__find_program_by_name;
+ 		bpf_object__attach_skeleton;
+ 		bpf_object__destroy_skeleton;
+ 		bpf_object__detach_skeleton;
+ 		bpf_object__load_skeleton;
+ 		bpf_object__open_skeleton;
+ 		bpf_probe_large_insn_limit;
+ 		bpf_prog_attach_xattr;
+ 		bpf_program__attach;
+ 		bpf_program__name;
+ 		bpf_program__is_extension;
+ 		bpf_program__is_struct_ops;
+ 		bpf_program__set_extension;
+ 		bpf_program__set_struct_ops;
+ 		btf__align_of;
+ 		libbpf_find_kernel_btf;
+ } LIBBPF_0.0.6;
+ 
+ LIBBPF_0.0.8 {
+ 	global:
+ 		bpf_link__fd;
+ 		bpf_link__open;
+ 		bpf_link__pin;
+ 		bpf_link__pin_path;
+ 		bpf_link__unpin;
+ 		bpf_link__update_program;
+ 		bpf_link_create;
+ 		bpf_link_update;
+ 		bpf_map__set_initial_value;
+ 		bpf_program__attach_cgroup;
+ 		bpf_program__attach_lsm;
+ 		bpf_program__is_lsm;
+ 		bpf_program__set_attach_target;
+ 		bpf_program__set_lsm;
+ 		bpf_set_link_xdp_fd_opts;
+ } LIBBPF_0.0.7;
++>>>>>>> cc4f864bb118 (libbpf: Add support for bpf_link-based cgroup attachment)
* Unmerged path tools/include/uapi/linux/bpf.h
diff --git a/tools/lib/bpf/bpf.c b/tools/lib/bpf/bpf.c
index f9124e381f55..2c5821891cea 100644
--- a/tools/lib/bpf/bpf.c
+++ b/tools/lib/bpf/bpf.c
@@ -499,6 +499,40 @@ int bpf_prog_detach2(int prog_fd, int target_fd, enum bpf_attach_type type)
 	return sys_bpf(BPF_PROG_DETACH, &attr, sizeof(attr));
 }
 
+int bpf_link_create(int prog_fd, int target_fd,
+		    enum bpf_attach_type attach_type,
+		    const struct bpf_link_create_opts *opts)
+{
+	union bpf_attr attr;
+
+	if (!OPTS_VALID(opts, bpf_link_create_opts))
+		return -EINVAL;
+
+	memset(&attr, 0, sizeof(attr));
+	attr.link_create.prog_fd = prog_fd;
+	attr.link_create.target_fd = target_fd;
+	attr.link_create.attach_type = attach_type;
+
+	return sys_bpf(BPF_LINK_CREATE, &attr, sizeof(attr));
+}
+
+int bpf_link_update(int link_fd, int new_prog_fd,
+		    const struct bpf_link_update_opts *opts)
+{
+	union bpf_attr attr;
+
+	if (!OPTS_VALID(opts, bpf_link_update_opts))
+		return -EINVAL;
+
+	memset(&attr, 0, sizeof(attr));
+	attr.link_update.link_fd = link_fd;
+	attr.link_update.new_prog_fd = new_prog_fd;
+	attr.link_update.flags = OPTS_GET(opts, flags, 0);
+	attr.link_update.old_prog_fd = OPTS_GET(opts, old_prog_fd, 0);
+
+	return sys_bpf(BPF_LINK_UPDATE, &attr, sizeof(attr));
+}
+
 int bpf_prog_query(int target_fd, enum bpf_attach_type type, __u32 query_flags,
 		   __u32 *attach_flags, __u32 *prog_ids, __u32 *prog_cnt)
 {
diff --git a/tools/lib/bpf/bpf.h b/tools/lib/bpf/bpf.h
index 2848c6333b5e..a9d934a2c4e5 100644
--- a/tools/lib/bpf/bpf.h
+++ b/tools/lib/bpf/bpf.h
@@ -126,6 +126,25 @@ LIBBPF_API int bpf_prog_detach(int attachable_fd, enum bpf_attach_type type);
 LIBBPF_API int bpf_prog_detach2(int prog_fd, int attachable_fd,
 				enum bpf_attach_type type);
 
+struct bpf_link_create_opts {
+	size_t sz; /* size of this struct for forward/backward compatibility */
+};
+#define bpf_link_create_opts__last_field sz
+
+LIBBPF_API int bpf_link_create(int prog_fd, int target_fd,
+			       enum bpf_attach_type attach_type,
+			       const struct bpf_link_create_opts *opts);
+
+struct bpf_link_update_opts {
+	size_t sz; /* size of this struct for forward/backward compatibility */
+	__u32 flags;	   /* extra flags */
+	__u32 old_prog_fd; /* expected old program FD */
+};
+#define bpf_link_update_opts__last_field old_prog_fd
+
+LIBBPF_API int bpf_link_update(int link_fd, int new_prog_fd,
+			       const struct bpf_link_update_opts *opts);
+
 struct bpf_prog_test_run_attr {
 	int prog_fd;
 	int repeat;
* Unmerged path tools/lib/bpf/libbpf.c
* Unmerged path tools/lib/bpf/libbpf.h
* Unmerged path tools/lib/bpf/libbpf.map
