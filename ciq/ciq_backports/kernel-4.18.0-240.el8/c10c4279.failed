ipv6: Notify newly added route if should be offloaded

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ido Schimmel <idosch@mellanox.com>
commit c10c4279c778df03f404a4d6906d7d4b840eb95f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c10c4279.failed

fib6_add_rt2node() takes care of adding a single route ('struct
fib6_info') to a FIB node. The route in question should only be notified
in case it is added as the first route in the node (lowest metric) or if
it is added as a sibling route to the first route in the node.

The first criterion can be tested by checking if the route is pointed to
by 'fn->leaf'. The second criterion can be tested by checking the new
'notify_sibling_rt' variable that is set when the route is added as a
sibling to the first route in the node.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Reviewed-by: Jiri Pirko <jiri@mellanox.com>
	Reviewed-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c10c4279c778df03f404a4d6906d7d4b840eb95f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_fib.c
diff --cc net/ipv6/ip6_fib.c
index 246c67f714a3,045bcaf5e770..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -1121,26 -1168,43 +1124,50 @@@ next_iter
  add:
  		nlflags |= NLM_F_CREATE;
  
++<<<<<<< HEAD
 +		err = call_fib6_entry_notifiers(info->nl_net,
 +						FIB_EVENT_ENTRY_ADD,
 +						rt, extack);
 +		if (err) {
 +			struct fib6_info *sibling, *next_sibling;
++=======
+ 		if (!info->skip_notify_kernel) {
+ 			enum fib_event_type fib_event;
+ 
+ 			if (notify_sibling_rt)
+ 				fib_event = FIB_EVENT_ENTRY_APPEND;
+ 			else
+ 				fib_event = FIB_EVENT_ENTRY_REPLACE_TMP;
+ 			/* The route should only be notified if it is the first
+ 			 * route in the node or if it is added as a sibling
+ 			 * route to the first route in the node.
+ 			 */
+ 			if (notify_sibling_rt || ins == &fn->leaf)
+ 				err = call_fib6_entry_notifiers(info->nl_net,
+ 								fib_event, rt,
+ 								extack);
+ 
+ 			err = call_fib6_entry_notifiers(info->nl_net,
+ 							FIB_EVENT_ENTRY_ADD,
+ 							rt, extack);
+ 			if (err) {
+ 				struct fib6_info *sibling, *next_sibling;
++>>>>>>> c10c4279c778 (ipv6: Notify newly added route if should be offloaded)
  
 -				/* If the route has siblings, then it first
 -				 * needs to be unlinked from them.
 -				 */
 -				if (!rt->fib6_nsiblings)
 -					return err;
 -
 -				list_for_each_entry_safe(sibling, next_sibling,
 -							 &rt->fib6_siblings,
 -							 fib6_siblings)
 -					sibling->fib6_nsiblings--;
 -				rt->fib6_nsiblings = 0;
 -				list_del_init(&rt->fib6_siblings);
 -				rt6_multipath_rebalance(next_sibling);
 +			/* If the route has siblings, then it first
 +			 * needs to be unlinked from them.
 +			 */
 +			if (!rt->fib6_nsiblings)
  				return err;
 -			}
 +
 +			list_for_each_entry_safe(sibling, next_sibling,
 +						 &rt->fib6_siblings,
 +						 fib6_siblings)
 +				sibling->fib6_nsiblings--;
 +			rt->fib6_nsiblings = 0;
 +			list_del_init(&rt->fib6_siblings);
 +			rt6_multipath_rebalance(next_sibling);
 +			return err;
  		}
  
  		rcu_assign_pointer(rt->fib6_next, iter);
* Unmerged path net/ipv6/ip6_fib.c
