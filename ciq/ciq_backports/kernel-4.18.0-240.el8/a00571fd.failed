libperf: Adopt perf_evsel__enable()/disable()/apply_filter() functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit a00571fda6091b5268d05e87d0797efe2db1920a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a00571fd.failed

Move the following functions:

  evsel__enable()
  evsel__disable()
  evsel__apply_filter()

to libperf with the following names:

  perf_evsel__enable()
  perf_evsel__disable()
  perf_evsel__apply_filter()

Export only perf_evsel__enable()/disable(), keeping the
perf_evsel__apply_filter() one private for the moment.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Alexey Budankov <alexey.budankov@linux.intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20190721112506.12306-66-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit a00571fda6091b5268d05e87d0797efe2db1920a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/lib/evsel.c
#	tools/perf/lib/include/internal/evsel.h
#	tools/perf/lib/include/perf/evsel.h
#	tools/perf/lib/libperf.map
#	tools/perf/util/evlist.c
#	tools/perf/util/evsel.c
#	tools/perf/util/evsel.h
diff --cc tools/perf/lib/libperf.map
index 3536242c545c,5bd491ac1762..000000000000
--- a/tools/perf/lib/libperf.map
+++ b/tools/perf/lib/libperf.map
@@@ -1,6 -1,31 +1,34 @@@
  LIBPERF_0.0.1 {
  	global:
  		libperf_set_print;
++<<<<<<< HEAD
++=======
+ 		perf_cpu_map__dummy_new;
+ 		perf_cpu_map__get;
+ 		perf_cpu_map__put;
+ 		perf_cpu_map__new;
+ 		perf_cpu_map__read;
+ 		perf_thread_map__new_dummy;
+ 		perf_thread_map__set_pid;
+ 		perf_thread_map__comm;
+ 		perf_thread_map__get;
+ 		perf_thread_map__put;
+ 		perf_evsel__new;
+ 		perf_evsel__delete;
+ 		perf_evsel__enable;
+ 		perf_evsel__disable;
+ 		perf_evsel__init;
+ 		perf_evsel__open;
+ 		perf_evsel__close;
+ 		perf_evsel__read;
+ 		perf_evlist__new;
+ 		perf_evlist__delete;
+ 		perf_evlist__init;
+ 		perf_evlist__add;
+ 		perf_evlist__remove;
+ 		perf_evlist__next;
+ 		perf_evlist__set_maps;
++>>>>>>> a00571fda609 (libperf: Adopt perf_evsel__enable()/disable()/apply_filter() functions)
  	local:
  		*;
  };
diff --cc tools/perf/util/evlist.c
index 4739b7914374,c4489a1ad6bc..000000000000
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@@ -1159,7 -1109,7 +1159,11 @@@ int perf_evlist__apply_filters(struct p
  		 * filters only work for tracepoint event, which doesn't have cpu limit.
  		 * So evlist and evsel should always be same.
  		 */
++<<<<<<< HEAD
 +		err = perf_evsel__apply_filter(evsel, evsel->filter);
++=======
+ 		err = perf_evsel__apply_filter(&evsel->core, evsel->filter);
++>>>>>>> a00571fda609 (libperf: Adopt perf_evsel__enable()/disable()/apply_filter() functions)
  		if (err) {
  			*err_evsel = evsel;
  			break;
diff --cc tools/perf/util/evsel.c
index e99257f738ba,64bc32ed6dfa..000000000000
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@@ -1154,48 -1153,7 +1154,52 @@@ void perf_evsel__config(struct perf_evs
  		perf_evsel__reset_sample_bit(evsel, BRANCH_STACK);
  }
  
++<<<<<<< HEAD
 +static int perf_evsel__alloc_fd(struct perf_evsel *evsel, int ncpus, int nthreads)
 +{
 +	evsel->fd = xyarray__new(ncpus, nthreads, sizeof(int));
 +
 +	if (evsel->fd) {
 +		int cpu, thread;
 +		for (cpu = 0; cpu < ncpus; cpu++) {
 +			for (thread = 0; thread < nthreads; thread++) {
 +				FD(evsel, cpu, thread) = -1;
 +			}
 +		}
 +	}
 +
 +	return evsel->fd != NULL ? 0 : -ENOMEM;
 +}
 +
 +static int perf_evsel__run_ioctl(struct perf_evsel *evsel,
 +			  int ioc,  void *arg)
 +{
 +	int cpu, thread;
 +
 +	for (cpu = 0; cpu < xyarray__max_x(evsel->fd); cpu++) {
 +		for (thread = 0; thread < xyarray__max_y(evsel->fd); thread++) {
 +			int fd = FD(evsel, cpu, thread),
 +			    err = ioctl(fd, ioc, arg);
 +
 +			if (err)
 +				return err;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +int perf_evsel__apply_filter(struct perf_evsel *evsel, const char *filter)
 +{
 +	return perf_evsel__run_ioctl(evsel,
 +				     PERF_EVENT_IOC_SET_FILTER,
 +				     (void *)filter);
 +}
 +
 +int perf_evsel__set_filter(struct perf_evsel *evsel, const char *filter)
++=======
+ int perf_evsel__set_filter(struct evsel *evsel, const char *filter)
++>>>>>>> a00571fda609 (libperf: Adopt perf_evsel__enable()/disable()/apply_filter() functions)
  {
  	char *new_filter = strdup(filter);
  
@@@ -1235,9 -1193,9 +1239,9 @@@ int perf_evsel__append_addr_filter(stru
  	return perf_evsel__append_filter(evsel, "%s,%s", filter);
  }
  
 -int evsel__enable(struct evsel *evsel)
 +int perf_evsel__enable(struct perf_evsel *evsel)
  {
- 	int err = perf_evsel__run_ioctl(evsel, PERF_EVENT_IOC_ENABLE, 0);
+ 	int err = perf_evsel__enable(&evsel->core);
  
  	if (!err)
  		evsel->disabled = false;
@@@ -1245,9 -1203,9 +1249,9 @@@
  	return err;
  }
  
 -int evsel__disable(struct evsel *evsel)
 +int perf_evsel__disable(struct perf_evsel *evsel)
  {
- 	int err = perf_evsel__run_ioctl(evsel, PERF_EVENT_IOC_DISABLE, 0);
+ 	int err = perf_evsel__disable(&evsel->core);
  	/*
  	 * We mark it disabled here so that tools that disable a event can
  	 * ignore events after they disable it. I.e. the ring buffer may have
diff --cc tools/perf/util/evsel.h
index b27935a6d36c,0989fb2eb1ec..000000000000
--- a/tools/perf/util/evsel.h
+++ b/tools/perf/util/evsel.h
@@@ -288,24 -280,23 +288,29 @@@ void __perf_evsel__reset_sample_bit(str
  #define perf_evsel__reset_sample_bit(evsel, bit) \
  	__perf_evsel__reset_sample_bit(evsel, PERF_SAMPLE_##bit)
  
 -void perf_evsel__set_sample_id(struct evsel *evsel,
 +void perf_evsel__set_sample_id(struct perf_evsel *evsel,
  			       bool use_sample_identifier);
  
 -int perf_evsel__set_filter(struct evsel *evsel, const char *filter);
 -int perf_evsel__append_tp_filter(struct evsel *evsel, const char *filter);
 -int perf_evsel__append_addr_filter(struct evsel *evsel,
 +int perf_evsel__set_filter(struct perf_evsel *evsel, const char *filter);
 +int perf_evsel__append_tp_filter(struct perf_evsel *evsel, const char *filter);
 +int perf_evsel__append_addr_filter(struct perf_evsel *evsel,
  				   const char *filter);
++<<<<<<< HEAD
 +int perf_evsel__apply_filter(struct perf_evsel *evsel, const char *filter);
 +int perf_evsel__enable(struct perf_evsel *evsel);
 +int perf_evsel__disable(struct perf_evsel *evsel);
++=======
+ int evsel__enable(struct evsel *evsel);
+ int evsel__disable(struct evsel *evsel);
++>>>>>>> a00571fda609 (libperf: Adopt perf_evsel__enable()/disable()/apply_filter() functions)
  
 -int perf_evsel__open_per_cpu(struct evsel *evsel,
 -			     struct perf_cpu_map *cpus);
 -int perf_evsel__open_per_thread(struct evsel *evsel,
 -				struct perf_thread_map *threads);
 -int evsel__open(struct evsel *evsel, struct perf_cpu_map *cpus,
 -		struct perf_thread_map *threads);
 -void evsel__close(struct evsel *evsel);
 +int perf_evsel__open_per_cpu(struct perf_evsel *evsel,
 +			     struct cpu_map *cpus);
 +int perf_evsel__open_per_thread(struct perf_evsel *evsel,
 +				struct thread_map *threads);
 +int perf_evsel__open(struct perf_evsel *evsel, struct cpu_map *cpus,
 +		     struct thread_map *threads);
 +void perf_evsel__close(struct perf_evsel *evsel);
  
  struct perf_sample;
  
* Unmerged path tools/perf/lib/evsel.c
* Unmerged path tools/perf/lib/include/internal/evsel.h
* Unmerged path tools/perf/lib/include/perf/evsel.h
* Unmerged path tools/perf/lib/evsel.c
* Unmerged path tools/perf/lib/include/internal/evsel.h
* Unmerged path tools/perf/lib/include/perf/evsel.h
* Unmerged path tools/perf/lib/libperf.map
* Unmerged path tools/perf/util/evlist.c
* Unmerged path tools/perf/util/evsel.c
* Unmerged path tools/perf/util/evsel.h
