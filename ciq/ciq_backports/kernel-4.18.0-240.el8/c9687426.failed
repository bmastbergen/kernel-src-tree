io_uring: fix zero len do_splice()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pavel Begunkov <asml.silence@gmail.com>
commit c96874265cd04b4bd4a8e114ac9af039a6d83cfe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c9687426.failed

do_splice() doesn't expect len to be 0. Just always return 0 in this
case as splice(2) does.

Fixes: 7d67af2c0134 ("io_uring: add splice(2) support")
	Reported-by: Jann Horn <jannh@google.com>
	Signed-off-by: Pavel Begunkov <asml.silence@gmail.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit c96874265cd04b4bd4a8e114ac9af039a6d83cfe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 2afa3b27779e,4c2fe06ae20b..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -1479,6 -2730,67 +1479,70 @@@ out_free
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int io_splice_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)
+ {
+ 	struct io_splice* sp = &req->splice;
+ 	unsigned int valid_flags = SPLICE_F_FD_IN_FIXED | SPLICE_F_ALL;
+ 	int ret;
+ 
+ 	if (req->flags & REQ_F_NEED_CLEANUP)
+ 		return 0;
+ 
+ 	sp->file_in = NULL;
+ 	sp->off_in = READ_ONCE(sqe->splice_off_in);
+ 	sp->off_out = READ_ONCE(sqe->off);
+ 	sp->len = READ_ONCE(sqe->len);
+ 	sp->flags = READ_ONCE(sqe->splice_flags);
+ 
+ 	if (unlikely(sp->flags & ~valid_flags))
+ 		return -EINVAL;
+ 
+ 	ret = io_file_get(NULL, req, READ_ONCE(sqe->splice_fd_in), &sp->file_in,
+ 			  (sp->flags & SPLICE_F_FD_IN_FIXED));
+ 	if (ret)
+ 		return ret;
+ 	req->flags |= REQ_F_NEED_CLEANUP;
+ 
+ 	if (!S_ISREG(file_inode(sp->file_in)->i_mode))
+ 		req->work.flags |= IO_WQ_WORK_UNBOUND;
+ 
+ 	return 0;
+ }
+ 
+ static int io_splice(struct io_kiocb *req, bool force_nonblock)
+ {
+ 	struct io_splice *sp = &req->splice;
+ 	struct file *in = sp->file_in;
+ 	struct file *out = sp->file_out;
+ 	unsigned int flags = sp->flags & ~SPLICE_F_FD_IN_FIXED;
+ 	loff_t *poff_in, *poff_out;
+ 	long ret = 0;
+ 
+ 	if (force_nonblock)
+ 		return -EAGAIN;
+ 
+ 	poff_in = (sp->off_in == -1) ? NULL : &sp->off_in;
+ 	poff_out = (sp->off_out == -1) ? NULL : &sp->off_out;
+ 
+ 	if (sp->len) {
+ 		ret = do_splice(in, poff_in, out, poff_out, sp->len, flags);
+ 		if (force_nonblock && ret == -EAGAIN)
+ 			return -EAGAIN;
+ 	}
+ 
+ 	io_put_file(req, in, (sp->flags & SPLICE_F_FD_IN_FIXED));
+ 	req->flags &= ~REQ_F_NEED_CLEANUP;
+ 
+ 	io_cqring_add_event(req, ret);
+ 	if (ret != sp->len)
+ 		req_set_fail_links(req);
+ 	io_put_req(req);
+ 	return 0;
+ }
+ 
++>>>>>>> c96874265cd0 (io_uring: fix zero len do_splice())
  /*
   * IORING_OP_NOP just posts a completion event, nothing else.
   */
* Unmerged path fs/io_uring.c
