bpf: Add bpf_link_new_file that doesn't install FD

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit babf3164095b0670435910340c2a1eec37757b57
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/babf3164.failed

Add bpf_link_new_file() API for cases when we need to ensure anon_inode is
successfully created before we proceed with expensive BPF program attachment
procedure, which will require equally (if not more so) expensive and
potentially failing compensation detachment procedure just because anon_inode
creation failed. This API allows to simplify code by ensuring first that
anon_inode is created and after BPF program is attached proceed with
fd_install() that can't fail.

After anon_inode file is created, link can't be just kfree()'d anymore,
because its destruction will be performed by deferred file_operations->release
call. For this, bpf_link API required specifying two separate operations:
release() and dealloc(), former performing detachment only, while the latter
frees memory used by bpf_link itself. dealloc() needs to be specified, because
struct bpf_link is frequently embedded into link type-specific container
struct (e.g., struct bpf_raw_tp_link), so bpf_link itself doesn't know how to
properly free the memory. In case when anon_inode file was successfully
created, but subsequent BPF attachment failed, bpf_link needs to be marked as
"defunct", so that file's release() callback will perform only memory
deallocation, but no detachment.

Convert raw tracepoint and tracing attachment to new API and eliminate
detachment from error handling path.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
Link: https://lore.kernel.org/bpf/20200309231051.1270337-1-andriin@fb.com
(cherry picked from commit babf3164095b0670435910340c2a1eec37757b57)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/syscall.c
diff --cc include/linux/bpf.h
index c1c99fdb999a,4fd91b7c95ea..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -734,6 -1066,22 +734,25 @@@ extern int sysctl_unprivileged_bpf_disa
  int bpf_map_new_fd(struct bpf_map *map, int flags);
  int bpf_prog_new_fd(struct bpf_prog *prog);
  
++<<<<<<< HEAD
++=======
+ struct bpf_link;
+ 
+ struct bpf_link_ops {
+ 	void (*release)(struct bpf_link *link);
+ 	void (*dealloc)(struct bpf_link *link);
+ };
+ 
+ void bpf_link_init(struct bpf_link *link, const struct bpf_link_ops *ops,
+ 		   struct bpf_prog *prog);
+ void bpf_link_defunct(struct bpf_link *link);
+ void bpf_link_inc(struct bpf_link *link);
+ void bpf_link_put(struct bpf_link *link);
+ int bpf_link_new_fd(struct bpf_link *link);
+ struct file *bpf_link_new_file(struct bpf_link *link, int *reserved_fd);
+ struct bpf_link *bpf_link_get_from_fd(u32 ufd);
+ 
++>>>>>>> babf3164095b (bpf: Add bpf_link_new_file that doesn't install FD)
  int bpf_obj_pin_user(u32 ufd, const char __user *pathname);
  int bpf_obj_get_user(const char __user *pathname, int flags);
  
diff --cc kernel/bpf/syscall.c
index b5b79e59cfd4,b2f73ecacced..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -1855,21 -2173,71 +1855,66 @@@ static int bpf_obj_get(const union bpf_
  				attr->file_flags);
  }
  
 -struct bpf_link {
 -	atomic64_t refcnt;
 -	const struct bpf_link_ops *ops;
 +struct bpf_raw_tracepoint {
 +	struct bpf_raw_event_map *btp;
  	struct bpf_prog *prog;
 -	struct work_struct work;
  };
  
 -void bpf_link_init(struct bpf_link *link, const struct bpf_link_ops *ops,
 -		   struct bpf_prog *prog)
 +static int bpf_raw_tracepoint_release(struct inode *inode, struct file *filp)
  {
 -	atomic64_set(&link->refcnt, 1);
 -	link->ops = ops;
 -	link->prog = prog;
 -}
 +	struct bpf_raw_tracepoint *raw_tp = filp->private_data;
  
++<<<<<<< HEAD
 +	if (raw_tp->prog) {
 +		bpf_probe_unregister(raw_tp->btp, raw_tp->prog);
 +		bpf_prog_put(raw_tp->prog);
++=======
+ void bpf_link_defunct(struct bpf_link *link)
+ {
+ 	link->prog = NULL;
+ }
+ 
+ void bpf_link_inc(struct bpf_link *link)
+ {
+ 	atomic64_inc(&link->refcnt);
+ }
+ 
+ /* bpf_link_free is guaranteed to be called from process context */
+ static void bpf_link_free(struct bpf_link *link)
+ {
+ 	if (link->prog) {
+ 		/* detach BPF program, clean up used resources */
+ 		link->ops->release(link);
+ 		bpf_prog_put(link->prog);
+ 	}
+ 	/* free bpf_link and its containing memory */
+ 	link->ops->dealloc(link);
+ }
+ 
+ static void bpf_link_put_deferred(struct work_struct *work)
+ {
+ 	struct bpf_link *link = container_of(work, struct bpf_link, work);
+ 
+ 	bpf_link_free(link);
+ }
+ 
+ /* bpf_link_put can be called from atomic context, but ensures that resources
+  * are freed from process context
+  */
+ void bpf_link_put(struct bpf_link *link)
+ {
+ 	if (!atomic64_dec_and_test(&link->refcnt))
+ 		return;
+ 
+ 	if (in_atomic()) {
+ 		INIT_WORK(&link->work, bpf_link_put_deferred);
+ 		schedule_work(&link->work);
+ 	} else {
+ 		bpf_link_free(link);
++>>>>>>> babf3164095b (bpf: Add bpf_link_new_file that doesn't install FD)
  	}
 -}
 -
 -static int bpf_link_release(struct inode *inode, struct file *filp)
 -{
 -	struct bpf_link *link = filp->private_data;
 -
 -	bpf_link_put(link);
 +	bpf_put_raw_tracepoint(raw_tp->btp);
 +	kfree(raw_tp);
  	return 0;
  }
  
@@@ -1879,65 -2280,237 +1924,241 @@@ static const struct file_operations bpf
  	.write		= bpf_dummy_write,
  };
  
++<<<<<<< HEAD
++=======
+ int bpf_link_new_fd(struct bpf_link *link)
+ {
+ 	return anon_inode_getfd("bpf-link", &bpf_link_fops, link, O_CLOEXEC);
+ }
+ 
+ /* Similar to bpf_link_new_fd, create anon_inode for given bpf_link, but
+  * instead of immediately installing fd in fdtable, just reserve it and
+  * return. Caller then need to either install it with fd_install(fd, file) or
+  * release with put_unused_fd(fd).
+  * This is useful for cases when bpf_link attachment/detachment are
+  * complicated and expensive operations and should be delayed until all the fd
+  * reservation and anon_inode creation succeeds.
+  */
+ struct file *bpf_link_new_file(struct bpf_link *link, int *reserved_fd)
+ {
+ 	struct file *file;
+ 	int fd;
+ 
+ 	fd = get_unused_fd_flags(O_CLOEXEC);
+ 	if (fd < 0)
+ 		return ERR_PTR(fd);
+ 
+ 	file = anon_inode_getfile("bpf_link", &bpf_link_fops, link, O_CLOEXEC);
+ 	if (IS_ERR(file)) {
+ 		put_unused_fd(fd);
+ 		return file;
+ 	}
+ 
+ 	*reserved_fd = fd;
+ 	return file;
+ }
+ 
+ struct bpf_link *bpf_link_get_from_fd(u32 ufd)
+ {
+ 	struct fd f = fdget(ufd);
+ 	struct bpf_link *link;
+ 
+ 	if (!f.file)
+ 		return ERR_PTR(-EBADF);
+ 	if (f.file->f_op != &bpf_link_fops) {
+ 		fdput(f);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	link = f.file->private_data;
+ 	bpf_link_inc(link);
+ 	fdput(f);
+ 
+ 	return link;
+ }
+ 
+ struct bpf_tracing_link {
+ 	struct bpf_link link;
+ };
+ 
+ static void bpf_tracing_link_release(struct bpf_link *link)
+ {
+ 	WARN_ON_ONCE(bpf_trampoline_unlink_prog(link->prog));
+ }
+ 
+ static void bpf_tracing_link_dealloc(struct bpf_link *link)
+ {
+ 	struct bpf_tracing_link *tr_link =
+ 		container_of(link, struct bpf_tracing_link, link);
+ 
+ 	kfree(tr_link);
+ }
+ 
+ static const struct bpf_link_ops bpf_tracing_link_lops = {
+ 	.release = bpf_tracing_link_release,
+ 	.dealloc = bpf_tracing_link_dealloc,
+ };
+ 
+ static int bpf_tracing_prog_attach(struct bpf_prog *prog)
+ {
+ 	struct bpf_tracing_link *link;
+ 	struct file *link_file;
+ 	int link_fd, err;
+ 
+ 	if (prog->expected_attach_type != BPF_TRACE_FENTRY &&
+ 	    prog->expected_attach_type != BPF_TRACE_FEXIT &&
+ 	    prog->expected_attach_type != BPF_MODIFY_RETURN &&
+ 	    prog->type != BPF_PROG_TYPE_EXT) {
+ 		err = -EINVAL;
+ 		goto out_put_prog;
+ 	}
+ 
+ 	link = kzalloc(sizeof(*link), GFP_USER);
+ 	if (!link) {
+ 		err = -ENOMEM;
+ 		goto out_put_prog;
+ 	}
+ 	bpf_link_init(&link->link, &bpf_tracing_link_lops, prog);
+ 
+ 	link_file = bpf_link_new_file(&link->link, &link_fd);
+ 	if (IS_ERR(link_file)) {
+ 		kfree(link);
+ 		err = PTR_ERR(link_file);
+ 		goto out_put_prog;
+ 	}
+ 
+ 	err = bpf_trampoline_link_prog(prog);
+ 	if (err) {
+ 		bpf_link_defunct(&link->link);
+ 		fput(link_file);
+ 		put_unused_fd(link_fd);
+ 		goto out_put_prog;
+ 	}
+ 
+ 	fd_install(link_fd, link_file);
+ 	return link_fd;
+ 
+ out_put_prog:
+ 	bpf_prog_put(prog);
+ 	return err;
+ }
+ 
+ struct bpf_raw_tp_link {
+ 	struct bpf_link link;
+ 	struct bpf_raw_event_map *btp;
+ };
+ 
+ static void bpf_raw_tp_link_release(struct bpf_link *link)
+ {
+ 	struct bpf_raw_tp_link *raw_tp =
+ 		container_of(link, struct bpf_raw_tp_link, link);
+ 
+ 	bpf_probe_unregister(raw_tp->btp, raw_tp->link.prog);
+ 	bpf_put_raw_tracepoint(raw_tp->btp);
+ }
+ 
+ static void bpf_raw_tp_link_dealloc(struct bpf_link *link)
+ {
+ 	struct bpf_raw_tp_link *raw_tp =
+ 		container_of(link, struct bpf_raw_tp_link, link);
+ 
+ 	kfree(raw_tp);
+ }
+ 
+ static const struct bpf_link_ops bpf_raw_tp_lops = {
+ 	.release = bpf_raw_tp_link_release,
+ 	.dealloc = bpf_raw_tp_link_dealloc,
+ };
+ 
++>>>>>>> babf3164095b (bpf: Add bpf_link_new_file that doesn't install FD)
  #define BPF_RAW_TRACEPOINT_OPEN_LAST_FIELD raw_tracepoint.prog_fd
  
  static int bpf_raw_tracepoint_open(const union bpf_attr *attr)
  {
++<<<<<<< HEAD
 +	struct bpf_raw_tracepoint *raw_tp;
++=======
+ 	struct bpf_raw_tp_link *link;
++>>>>>>> babf3164095b (bpf: Add bpf_link_new_file that doesn't install FD)
  	struct bpf_raw_event_map *btp;
+ 	struct file *link_file;
  	struct bpf_prog *prog;
 -	const char *tp_name;
 -	char buf[128];
 -	int link_fd, err;
 +	char tp_name[128];
 +	int tp_fd, err;
  
 -	if (CHECK_ATTR(BPF_RAW_TRACEPOINT_OPEN))
 -		return -EINVAL;
 +	rh_mark_used_feature("eBPF/rawtrace");
  
 -	prog = bpf_prog_get(attr->raw_tracepoint.prog_fd);
 -	if (IS_ERR(prog))
 -		return PTR_ERR(prog);
 +	if (strncpy_from_user(tp_name, u64_to_user_ptr(attr->raw_tracepoint.name),
 +			      sizeof(tp_name) - 1) < 0)
 +		return -EFAULT;
 +	tp_name[sizeof(tp_name) - 1] = 0;
 +
 +	btp = bpf_get_raw_tracepoint(tp_name);
 +	if (!btp)
 +		return -ENOENT;
  
- 	raw_tp = kzalloc(sizeof(*raw_tp), GFP_USER);
- 	if (!raw_tp) {
++	link = kzalloc(sizeof(*link), GFP_USER);
++	if (!link) {
 +		err = -ENOMEM;
 +		goto out_put_btp;
 +	}
++<<<<<<< HEAD
 +	raw_tp->btp = btp;
 +
 +	prog = bpf_prog_get(attr->raw_tracepoint.prog_fd);
 +	if (IS_ERR(prog)) {
 +		err = PTR_ERR(prog);
 +		goto out_free_tp;
 +	}
  	if (prog->type != BPF_PROG_TYPE_RAW_TRACEPOINT &&
 -	    prog->type != BPF_PROG_TYPE_TRACING &&
 -	    prog->type != BPF_PROG_TYPE_EXT &&
  	    prog->type != BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE) {
  		err = -EINVAL;
  		goto out_put_prog;
  	}
  
 -	if (prog->type == BPF_PROG_TYPE_TRACING ||
 -	    prog->type == BPF_PROG_TYPE_EXT) {
 -		if (attr->raw_tracepoint.name) {
 -			/* The attach point for this category of programs
 -			 * should be specified via btf_id during program load.
 -			 */
 -			err = -EINVAL;
 -			goto out_put_prog;
 -		}
 -		if (prog->expected_attach_type == BPF_TRACE_RAW_TP)
 -			tp_name = prog->aux->attach_func_name;
 -		else
 -			return bpf_tracing_prog_attach(prog);
 -	} else {
 -		if (strncpy_from_user(buf,
 -				      u64_to_user_ptr(attr->raw_tracepoint.name),
 -				      sizeof(buf) - 1) < 0) {
 -			err = -EFAULT;
 -			goto out_put_prog;
 -		}
 -		buf[sizeof(buf) - 1] = 0;
 -		tp_name = buf;
 -	}
 +	err = bpf_probe_register(raw_tp->btp, prog);
 +	if (err)
 +		goto out_put_prog;
  
 -	btp = bpf_get_raw_tracepoint(tp_name);
 -	if (!btp) {
 -		err = -ENOENT;
 +	raw_tp->prog = prog;
 +	tp_fd = anon_inode_getfd("bpf-raw-tracepoint", &bpf_raw_tp_fops, raw_tp,
 +				 O_CLOEXEC);
 +	if (tp_fd < 0) {
 +		bpf_probe_unregister(raw_tp->btp, prog);
 +		err = tp_fd;
  		goto out_put_prog;
  	}
 +	return tp_fd;
  
 -	link = kzalloc(sizeof(*link), GFP_USER);
 -	if (!link) {
 -		err = -ENOMEM;
 -		goto out_put_btp;
 -	}
 +out_put_prog:
 +	bpf_prog_put(prog);
 +out_free_tp:
 +	kfree(raw_tp);
++=======
+ 	bpf_link_init(&link->link, &bpf_raw_tp_lops, prog);
+ 	link->btp = btp;
+ 
+ 	link_file = bpf_link_new_file(&link->link, &link_fd);
+ 	if (IS_ERR(link_file)) {
+ 		kfree(link);
+ 		err = PTR_ERR(link_file);
+ 		goto out_put_btp;
+ 	}
+ 
+ 	err = bpf_probe_register(link->btp, prog);
+ 	if (err) {
+ 		bpf_link_defunct(&link->link);
+ 		fput(link_file);
+ 		put_unused_fd(link_fd);
+ 		goto out_put_btp;
+ 	}
+ 
+ 	fd_install(link_fd, link_file);
+ 	return link_fd;
+ 
++>>>>>>> babf3164095b (bpf: Add bpf_link_new_file that doesn't install FD)
  out_put_btp:
  	bpf_put_raw_tracepoint(btp);
 -out_put_prog:
 -	bpf_prog_put(prog);
  	return err;
  }
  
* Unmerged path include/linux/bpf.h
* Unmerged path kernel/bpf/syscall.c
