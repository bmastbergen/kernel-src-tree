Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Alex Lu <alex_lu@realsil.com.cn>
commit f1300c0340872d7d02617f439433d70c6f47700f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f1300c03.failed

These printing macros already add a trailing newline, so drop these
unnecessary additional newlines.

	Signed-off-by: Alex Lu <alex_lu@realsil.com.cn>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit f1300c0340872d7d02617f439433d70c6f47700f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btrtl.c
diff --cc drivers/bluetooth/btrtl.c
index 437f080deaab,0354e93e7a7c..000000000000
--- a/drivers/bluetooth/btrtl.c
+++ b/drivers/bluetooth/btrtl.c
@@@ -97,20 -207,20 +97,34 @@@ static int rtl_read_rom_version(struct 
  	/* Read RTL ROM version command */
  	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
  	if (IS_ERR(skb)) {
++<<<<<<< HEAD
 +		BT_ERR("%s: Read ROM version failed (%ld)",
 +		       hdev->name, PTR_ERR(skb));
++=======
+ 		rtl_dev_err(hdev, "Read ROM version failed (%ld)",
+ 			    PTR_ERR(skb));
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  		return PTR_ERR(skb);
  	}
  
  	if (skb->len != sizeof(*rom_version)) {
++<<<<<<< HEAD
 +		BT_ERR("%s: RTL version event length mismatch", hdev->name);
++=======
+ 		rtl_dev_err(hdev, "version event length mismatch");
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  		kfree_skb(skb);
  		return -EIO;
  	}
  
  	rom_version = (struct rtl_rom_version_evt *)skb->data;
++<<<<<<< HEAD
 +	bt_dev_info(hdev, "rom_version status=%x version=%x",
 +		    rom_version->status, rom_version->version);
++=======
+ 	rtl_dev_info(hdev, "rom_version status=%x version=%x",
+ 		     rom_version->status, rom_version->version);
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  
  	*version = rom_version->version;
  
@@@ -144,19 -254,16 +158,23 @@@ static int rtlbt_parse_firmware(struct 
  		{ RTL_ROM_LMP_8822B, 8 },
  		{ RTL_ROM_LMP_8723B, 9 },	/* 8723D */
  		{ RTL_ROM_LMP_8821A, 10 },	/* 8821C */
 -		{ RTL_ROM_LMP_8822B, 13 },	/* 8822C */
  	};
  
 +	ret = rtl_read_rom_version(hdev, &rom_version);
 +	if (ret)
 +		return ret;
 +
  	min_size = sizeof(struct rtl_epatch_header) + sizeof(extension_sig) + 3;
 -	if (btrtl_dev->fw_len < min_size)
 +	if (fw->size < min_size)
  		return -EINVAL;
  
 -	fwptr = btrtl_dev->fw_data + btrtl_dev->fw_len - sizeof(extension_sig);
 +	fwptr = fw->data + fw->size - sizeof(extension_sig);
  	if (memcmp(fwptr, extension_sig, sizeof(extension_sig)) != 0) {
++<<<<<<< HEAD
 +		BT_ERR("%s: extension section signature mismatch", hdev->name);
++=======
+ 		rtl_dev_err(hdev, "extension section signature mismatch");
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  		return -EINVAL;
  	}
  
@@@ -177,8 -284,7 +195,12 @@@
  			break;
  
  		if (length == 0) {
++<<<<<<< HEAD
 +			BT_ERR("%s: found instruction with length 0",
 +			       hdev->name);
++=======
+ 			rtl_dev_err(hdev, "found instruction with length 0");
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  			return -EINVAL;
  		}
  
@@@ -191,7 -297,7 +213,11 @@@
  	}
  
  	if (project_id < 0) {
++<<<<<<< HEAD
 +		BT_ERR("%s: failed to find version instruction", hdev->name);
++=======
+ 		rtl_dev_err(hdev, "failed to find version instruction");
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  		return -EINVAL;
  	}
  
@@@ -202,19 -308,21 +228,35 @@@
  	}
  
  	if (i >= ARRAY_SIZE(project_id_to_lmp_subver)) {
++<<<<<<< HEAD
 +		BT_ERR("%s: unknown project id %d", hdev->name, project_id);
 +		return -EINVAL;
 +	}
 +
 +	if (lmp_subver != project_id_to_lmp_subver[i].lmp_subver) {
 +		BT_ERR("%s: firmware is for %x but this is a %x", hdev->name,
 +		       project_id_to_lmp_subver[i].lmp_subver, lmp_subver);
++=======
+ 		rtl_dev_err(hdev, "unknown project id %d", project_id);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (btrtl_dev->ic_info->lmp_subver !=
+ 				project_id_to_lmp_subver[i].lmp_subver) {
+ 		rtl_dev_err(hdev, "firmware is for %x but this is a %x",
+ 			    project_id_to_lmp_subver[i].lmp_subver,
+ 			    btrtl_dev->ic_info->lmp_subver);
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  		return -EINVAL;
  	}
  
 -	epatch_info = (struct rtl_epatch_header *)btrtl_dev->fw_data;
 +	epatch_info = (struct rtl_epatch_header *)fw->data;
  	if (memcmp(epatch_info->signature, RTL_EPATCH_SIGNATURE, 8) != 0) {
++<<<<<<< HEAD
 +		BT_ERR("%s: bad EPATCH signature", hdev->name);
++=======
+ 		rtl_dev_err(hdev, "bad EPATCH signature");
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  		return -EINVAL;
  	}
  
@@@ -301,15 -412,14 +343,24 @@@ static int rtl_download_firmware(struc
  		skb = __hci_cmd_sync(hdev, 0xfc20, frag_len + 1, dl_cmd,
  				     HCI_INIT_TIMEOUT);
  		if (IS_ERR(skb)) {
++<<<<<<< HEAD
 +			BT_ERR("%s: download fw command failed (%ld)",
 +			       hdev->name, PTR_ERR(skb));
++=======
+ 			rtl_dev_err(hdev, "download fw command failed (%ld)",
+ 				    PTR_ERR(skb));
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  			ret = -PTR_ERR(skb);
  			goto out;
  		}
  
  		if (skb->len != sizeof(struct rtl_download_response)) {
++<<<<<<< HEAD
 +			BT_ERR("%s: download fw event length mismatch",
 +			       hdev->name);
++=======
+ 			rtl_dev_err(hdev, "download fw event length mismatch");
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  			kfree_skb(skb);
  			ret = -EIO;
  			goto out;
@@@ -329,7 -451,7 +380,11 @@@ static int rtl_load_config(struct hci_d
  	const struct firmware *fw;
  	int ret;
  
++<<<<<<< HEAD
 +	bt_dev_info(hdev, "rtl: loading %s", name);
++=======
+ 	rtl_dev_info(hdev, "loading %s", name);
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  	ret = request_firmware(&fw, name, &hdev->dev);
  	if (ret < 0)
  		return ret;
@@@ -363,71 -474,23 +418,76 @@@ static int btrtl_setup_rtl8723a(struct 
  	/* Check that the firmware doesn't have the epatch signature
  	 * (which is only for RTL8723B and newer).
  	 */
 -	if (!memcmp(btrtl_dev->fw_data, RTL_EPATCH_SIGNATURE, 8)) {
 -		rtl_dev_err(hdev, "unexpected EPATCH signature!");
 -		return -EINVAL;
++<<<<<<< HEAD
 +	if (!memcmp(fw->data, RTL_EPATCH_SIGNATURE, 8)) {
 +		BT_ERR("%s: unexpected EPATCH signature!", hdev->name);
 +		ret = -EINVAL;
 +		goto out;
  	}
  
 -	return rtl_download_firmware(hdev, btrtl_dev->fw_data,
 -				     btrtl_dev->fw_len);
 +	ret = rtl_download_firmware(hdev, fw->data, fw->size);
 +
 +out:
 +	release_firmware(fw);
 +	return ret;
  }
  
 -static int btrtl_setup_rtl8723b(struct hci_dev *hdev,
 -				struct btrtl_device_info *btrtl_dev)
 +static int btrtl_setup_rtl8723b(struct hci_dev *hdev, u16 hci_rev,
 +				u16 lmp_subver)
  {
  	unsigned char *fw_data = NULL;
 +	const struct firmware *fw;
  	int ret;
 +	int cfg_sz;
 +	u8 *cfg_buff = NULL;
  	u8 *tbuff;
 +	char *cfg_name = NULL;
 +	char *fw_name = NULL;
 +	int i;
 +
 +	for (i = 0; i < ARRAY_SIZE(ic_id_table); i++) {
 +		if ((ic_id_table[i].match_flags & IC_MATCH_FL_LMPSUBV) &&
 +		    (ic_id_table[i].lmp_subver != lmp_subver))
 +			continue;
 +		if ((ic_id_table[i].match_flags & IC_MATCH_FL_HCIREV) &&
 +		    (ic_id_table[i].hci_rev != hci_rev))
 +			continue;
 +
 +		break;
 +	}
 +
 +	if (i >= ARRAY_SIZE(ic_id_table)) {
 +		BT_ERR("%s: unknown IC info, lmp subver %04x, hci rev %04x",
 +		       hdev->name, lmp_subver, hci_rev);
++=======
++	if (!memcmp(btrtl_dev->fw_data, RTL_EPATCH_SIGNATURE, 8)) {
++		rtl_dev_err(hdev, "unexpected EPATCH signature!");
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
 +		return -EINVAL;
 +	}
 +
 +	cfg_name = ic_id_table[i].cfg_name;
 +
 +	if (cfg_name) {
 +		cfg_sz = rtl_load_config(hdev, cfg_name, &cfg_buff);
 +		if (cfg_sz < 0) {
 +			cfg_sz = 0;
 +			if (ic_id_table[i].config_needed)
 +				BT_ERR("Necessary config file %s not found\n",
 +				       cfg_name);
 +		}
 +	} else
 +		cfg_sz = 0;
  
 -	ret = rtlbt_parse_firmware(hdev, btrtl_dev, &fw_data);
 +	fw_name = ic_id_table[i].fw_name;
 +	bt_dev_info(hdev, "rtl: loading %s", fw_name);
 +	ret = request_firmware(&fw, fw_name, &hdev->dev);
 +	if (ret < 0) {
 +		BT_ERR("%s: Failed to load %s", hdev->name, fw_name);
 +		goto err_req_fw;
 +	}
 +
 +	ret = rtlbt_parse_firmware(hdev, lmp_subver, fw, &fw_data);
  	if (ret < 0)
  		goto out;
  
@@@ -447,7 -510,7 +507,11 @@@
  		fw_data = tbuff;
  	}
  
++<<<<<<< HEAD
 +	bt_dev_info(hdev, "cfg_sz %d, total size %d", cfg_sz, ret);
++=======
+ 	rtl_dev_info(hdev, "cfg_sz %d, total sz %d", btrtl_dev->cfg_len, ret);
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  
  	ret = rtl_download_firmware(hdev, fw_data, ret);
  
@@@ -460,70 -519,279 +524,278 @@@ err_req_fw
  	return ret;
  }
  
 -void btrtl_free(struct btrtl_device_info *btrtl_dev)
 +static struct sk_buff *btrtl_read_local_version(struct hci_dev *hdev)
  {
 -	kfree(btrtl_dev->fw_data);
 -	kfree(btrtl_dev->cfg_data);
 -	kfree(btrtl_dev);
 +	struct sk_buff *skb;
 +
 +	skb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,
 +			     HCI_INIT_TIMEOUT);
 +	if (IS_ERR(skb)) {
 +		BT_ERR("%s: HCI_OP_READ_LOCAL_VERSION failed (%ld)",
 +		       hdev->name, PTR_ERR(skb));
 +		return skb;
 +	}
 +
 +	if (skb->len != sizeof(struct hci_rp_read_local_version)) {
 +		BT_ERR("%s: HCI_OP_READ_LOCAL_VERSION event length mismatch",
 +		       hdev->name);
 +		kfree_skb(skb);
 +		return ERR_PTR(-EIO);
 +	}
 +
 +	return skb;
  }
 -EXPORT_SYMBOL_GPL(btrtl_free);
  
 -struct btrtl_device_info *btrtl_initialize(struct hci_dev *hdev,
 -					   const char *postfix)
 +int btrtl_setup_realtek(struct hci_dev *hdev)
  {
 -	struct btrtl_device_info *btrtl_dev;
  	struct sk_buff *skb;
  	struct hci_rp_read_local_version *resp;
 -	char cfg_name[40];
  	u16 hci_rev, lmp_subver;
 -	u8 hci_ver;
 -	int ret;
 -
 -	btrtl_dev = kzalloc(sizeof(*btrtl_dev), GFP_KERNEL);
 -	if (!btrtl_dev) {
 -		ret = -ENOMEM;
 -		goto err_alloc;
 -	}
  
  	skb = btrtl_read_local_version(hdev);
 -	if (IS_ERR(skb)) {
 -		ret = PTR_ERR(skb);
 -		goto err_free;
 -	}
 +	if (IS_ERR(skb))
 +		return -PTR_ERR(skb);
  
  	resp = (struct hci_rp_read_local_version *)skb->data;
++<<<<<<< HEAD
 +	bt_dev_info(hdev, "rtl: examining hci_ver=%02x hci_rev=%04x "
 +		    "lmp_ver=%02x lmp_subver=%04x",
 +		    resp->hci_ver, resp->hci_rev,
 +		    resp->lmp_ver, resp->lmp_subver);
++=======
+ 	rtl_dev_info(hdev, "examining hci_ver=%02x hci_rev=%04x lmp_ver=%02x lmp_subver=%04x",
+ 		     resp->hci_ver, resp->hci_rev,
+ 		     resp->lmp_ver, resp->lmp_subver);
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  
 -	hci_ver = resp->hci_ver;
  	hci_rev = le16_to_cpu(resp->hci_rev);
  	lmp_subver = le16_to_cpu(resp->lmp_subver);
  	kfree_skb(skb);
  
++<<<<<<< HEAD
++=======
+ 	btrtl_dev->ic_info = btrtl_match_ic(lmp_subver, hci_rev, hci_ver,
+ 					    hdev->bus);
+ 
+ 	if (!btrtl_dev->ic_info) {
+ 		rtl_dev_info(hdev, "unknown IC info, lmp subver %04x, hci rev %04x, hci ver %04x",
+ 			    lmp_subver, hci_rev, hci_ver);
+ 		return btrtl_dev;
+ 	}
+ 
+ 	if (btrtl_dev->ic_info->has_rom_version) {
+ 		ret = rtl_read_rom_version(hdev, &btrtl_dev->rom_version);
+ 		if (ret)
+ 			goto err_free;
+ 	}
+ 
+ 	btrtl_dev->fw_len = rtl_load_file(hdev, btrtl_dev->ic_info->fw_name,
+ 					  &btrtl_dev->fw_data);
+ 	if (btrtl_dev->fw_len < 0) {
+ 		rtl_dev_err(hdev, "firmware file %s not found",
+ 			    btrtl_dev->ic_info->fw_name);
+ 		ret = btrtl_dev->fw_len;
+ 		goto err_free;
+ 	}
+ 
+ 	if (btrtl_dev->ic_info->cfg_name) {
+ 		if (postfix) {
+ 			snprintf(cfg_name, sizeof(cfg_name), "%s-%s.bin",
+ 				 btrtl_dev->ic_info->cfg_name, postfix);
+ 		} else {
+ 			snprintf(cfg_name, sizeof(cfg_name), "%s.bin",
+ 				 btrtl_dev->ic_info->cfg_name);
+ 		}
+ 		btrtl_dev->cfg_len = rtl_load_file(hdev, cfg_name,
+ 						   &btrtl_dev->cfg_data);
+ 		if (btrtl_dev->ic_info->config_needed &&
+ 		    btrtl_dev->cfg_len <= 0) {
+ 			rtl_dev_err(hdev, "mandatory config file %s not found",
+ 				    btrtl_dev->ic_info->cfg_name);
+ 			ret = btrtl_dev->cfg_len;
+ 			goto err_free;
+ 		}
+ 	}
+ 
+ 	return btrtl_dev;
+ 
+ err_free:
+ 	btrtl_free(btrtl_dev);
+ err_alloc:
+ 	return ERR_PTR(ret);
+ }
+ EXPORT_SYMBOL_GPL(btrtl_initialize);
+ 
+ int btrtl_download_firmware(struct hci_dev *hdev,
+ 			    struct btrtl_device_info *btrtl_dev)
+ {
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  	/* Match a set of subver values that correspond to stock firmware,
  	 * which is not compatible with standard btusb.
  	 * If matched, upload an alternative firmware that does conform to
  	 * standard btusb. Once that firmware is uploaded, the subver changes
  	 * to a different value.
  	 */
++<<<<<<< HEAD
 +	switch (lmp_subver) {
++=======
+ 	if (!btrtl_dev->ic_info) {
+ 		rtl_dev_info(hdev, "assuming no firmware upload needed");
+ 		return 0;
+ 	}
+ 
+ 	switch (btrtl_dev->ic_info->lmp_subver) {
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  	case RTL_ROM_LMP_8723A:
  	case RTL_ROM_LMP_3499:
 -		return btrtl_setup_rtl8723a(hdev, btrtl_dev);
 +		return btrtl_setup_rtl8723a(hdev);
  	case RTL_ROM_LMP_8723B:
  	case RTL_ROM_LMP_8821A:
  	case RTL_ROM_LMP_8761A:
  	case RTL_ROM_LMP_8822B:
 -		return btrtl_setup_rtl8723b(hdev, btrtl_dev);
 +		return btrtl_setup_rtl8723b(hdev, hci_rev, lmp_subver);
  	default:
++<<<<<<< HEAD
 +		bt_dev_info(hdev, "rtl: assuming no firmware upload needed");
++=======
+ 		rtl_dev_info(hdev, "assuming no firmware upload needed");
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  		return 0;
  	}
  }
 -EXPORT_SYMBOL_GPL(btrtl_download_firmware);
 -
 -int btrtl_setup_realtek(struct hci_dev *hdev)
 -{
 -	struct btrtl_device_info *btrtl_dev;
 -	int ret;
 -
 -	btrtl_dev = btrtl_initialize(hdev, NULL);
 -	if (IS_ERR(btrtl_dev))
 -		return PTR_ERR(btrtl_dev);
 -
 -	ret = btrtl_download_firmware(hdev, btrtl_dev);
 -
 -	btrtl_free(btrtl_dev);
 -
 -	/* Enable controller to do both LE scan and BR/EDR inquiry
 -	 * simultaneously.
 -	 */
 -	set_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);
 -
 -	return ret;
 -}
  EXPORT_SYMBOL_GPL(btrtl_setup_realtek);
  
++<<<<<<< HEAD
++=======
+ int btrtl_shutdown_realtek(struct hci_dev *hdev)
+ {
+ 	struct sk_buff *skb;
+ 	int ret;
+ 
+ 	/* According to the vendor driver, BT must be reset on close to avoid
+ 	 * firmware crash.
+ 	 */
+ 	skb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);
+ 	if (IS_ERR(skb)) {
+ 		ret = PTR_ERR(skb);
+ 		bt_dev_err(hdev, "HCI reset during shutdown failed");
+ 		return ret;
+ 	}
+ 	kfree_skb(skb);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(btrtl_shutdown_realtek);
+ 
+ static unsigned int btrtl_convert_baudrate(u32 device_baudrate)
+ {
+ 	switch (device_baudrate) {
+ 	case 0x0252a00a:
+ 		return 230400;
+ 
+ 	case 0x05f75004:
+ 		return 921600;
+ 
+ 	case 0x00005004:
+ 		return 1000000;
+ 
+ 	case 0x04928002:
+ 	case 0x01128002:
+ 		return 1500000;
+ 
+ 	case 0x00005002:
+ 		return 2000000;
+ 
+ 	case 0x0000b001:
+ 		return 2500000;
+ 
+ 	case 0x04928001:
+ 		return 3000000;
+ 
+ 	case 0x052a6001:
+ 		return 3500000;
+ 
+ 	case 0x00005001:
+ 		return 4000000;
+ 
+ 	case 0x0252c014:
+ 	default:
+ 		return 115200;
+ 	}
+ }
+ 
+ int btrtl_get_uart_settings(struct hci_dev *hdev,
+ 			    struct btrtl_device_info *btrtl_dev,
+ 			    unsigned int *controller_baudrate,
+ 			    u32 *device_baudrate, bool *flow_control)
+ {
+ 	struct rtl_vendor_config *config;
+ 	struct rtl_vendor_config_entry *entry;
+ 	int i, total_data_len;
+ 	bool found = false;
+ 
+ 	total_data_len = btrtl_dev->cfg_len - sizeof(*config);
+ 	if (total_data_len <= 0) {
+ 		rtl_dev_warn(hdev, "no config loaded");
+ 		return -EINVAL;
+ 	}
+ 
+ 	config = (struct rtl_vendor_config *)btrtl_dev->cfg_data;
+ 	if (le32_to_cpu(config->signature) != RTL_CONFIG_MAGIC) {
+ 		rtl_dev_err(hdev, "invalid config magic");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (total_data_len < le16_to_cpu(config->total_len)) {
+ 		rtl_dev_err(hdev, "config is too short");
+ 		return -EINVAL;
+ 	}
+ 
+ 	for (i = 0; i < total_data_len; ) {
+ 		entry = ((void *)config->entry) + i;
+ 
+ 		switch (le16_to_cpu(entry->offset)) {
+ 		case 0xc:
+ 			if (entry->len < sizeof(*device_baudrate)) {
+ 				rtl_dev_err(hdev, "invalid UART config entry");
+ 				return -EINVAL;
+ 			}
+ 
+ 			*device_baudrate = get_unaligned_le32(entry->data);
+ 			*controller_baudrate = btrtl_convert_baudrate(
+ 							*device_baudrate);
+ 
+ 			if (entry->len >= 13)
+ 				*flow_control = !!(entry->data[12] & BIT(2));
+ 			else
+ 				*flow_control = false;
+ 
+ 			found = true;
+ 			break;
+ 
+ 		default:
+ 			rtl_dev_dbg(hdev, "skipping config entry 0x%x (len %u)",
+ 				   le16_to_cpu(entry->offset), entry->len);
+ 			break;
+ 		};
+ 
+ 		i += sizeof(*entry) + entry->len;
+ 	}
+ 
+ 	if (!found) {
+ 		rtl_dev_err(hdev, "no UART config entry found");
+ 		return -ENOENT;
+ 	}
+ 
+ 	rtl_dev_dbg(hdev, "device baudrate = 0x%08x", *device_baudrate);
+ 	rtl_dev_dbg(hdev, "controller baudrate = %u", *controller_baudrate);
+ 	rtl_dev_dbg(hdev, "flow control %d", *flow_control);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(btrtl_get_uart_settings);
+ 
++>>>>>>> f1300c034087 (Bluetooth: btrtl: Remove trailing newline from calls to rtl_dev macros)
  MODULE_AUTHOR("Daniel Drake <drake@endlessm.com>");
  MODULE_DESCRIPTION("Bluetooth support for Realtek devices ver " VERSION);
  MODULE_VERSION(VERSION);
* Unmerged path drivers/bluetooth/btrtl.c
