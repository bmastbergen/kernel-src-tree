crypto: chelsio - Recalculate iv only if it is needed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ayush Sawal <ayush.sawal@chelsio.com>
commit bed44d0c05d8efdda1ae98b1c7aa7b116abeadb2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/bed44d0c.failed

Recalculate iv only if it is needed i.e. if the last req to hw
was partial for aes-xts.

	Signed-off-by: Ayush Sawal <ayush.sawal@chelsio.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit bed44d0c05d8efdda1ae98b1c7aa7b116abeadb2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chcr_algo.c
diff --cc drivers/crypto/chelsio/chcr_algo.c
index 8d9f707b07ea,17ce6970dab4..000000000000
--- a/drivers/crypto/chelsio/chcr_algo.c
+++ b/drivers/crypto/chelsio/chcr_algo.c
@@@ -1093,10 -1084,14 +1093,14 @@@ static int chcr_final_cipher_iv(struct 
  	int ret = 0;
  
  	if (subtype == CRYPTO_ALG_SUB_TYPE_CTR)
 -		ctr_add_iv(iv, req->iv, DIV_ROUND_UP(reqctx->processed,
 +		ctr_add_iv(iv, req->info, DIV_ROUND_UP(reqctx->processed,
  						       AES_BLOCK_SIZE));
- 	else if (subtype == CRYPTO_ALG_SUB_TYPE_XTS)
- 		ret = chcr_update_tweak(req, iv, 1);
+ 	else if (subtype == CRYPTO_ALG_SUB_TYPE_XTS) {
+ 		if (!reqctx->partial_req)
+ 			memcpy(iv, reqctx->iv, AES_BLOCK_SIZE);
+ 		else
+ 			ret = chcr_update_tweak(req, iv, 1);
+ 	}
  	else if (subtype == CRYPTO_ALG_SUB_TYPE_CBC) {
  		/*Already updated for Decrypt*/
  		if (!reqctx->op)
@@@ -1197,13 -1203,14 +1201,18 @@@ static int process_cipher(struct ablkci
  	int bytes, err = -EINVAL;
  
  	reqctx->processed = 0;
++<<<<<<< HEAD
 +	if (!req->info)
++=======
+ 	reqctx->partial_req = 0;
+ 	if (!req->iv)
++>>>>>>> bed44d0c05d8 (crypto: chelsio - Recalculate iv only if it is needed)
  		goto error;
  	if ((ablkctx->enckey_len == 0) || (ivsize > AES_BLOCK_SIZE) ||
 -	    (req->cryptlen == 0) ||
 -	    (req->cryptlen % crypto_skcipher_blocksize(tfm))) {
 +	    (req->nbytes == 0) ||
 +	    (req->nbytes % crypto_ablkcipher_blocksize(tfm))) {
  		pr_err("AES: Invalid value of Key Len %d nbytes %d IV Len %d\n",
 -		       ablkctx->enckey_len, req->cryptlen, ivsize);
 +		       ablkctx->enckey_len, req->nbytes, ivsize);
  		goto error;
  	}
  
@@@ -1295,9 -1303,11 +1305,15 @@@ error
  	return err;
  }
  
 -static int chcr_aes_encrypt(struct skcipher_request *req)
 +static int chcr_aes_encrypt(struct ablkcipher_request *req)
  {
++<<<<<<< HEAD
 +	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);
++=======
+ 	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
+ 	struct chcr_skcipher_req_ctx *reqctx = skcipher_request_ctx(req);
+ 	struct chcr_context *ctx;
++>>>>>>> bed44d0c05d8 (crypto: chelsio - Recalculate iv only if it is needed)
  	struct chcr_dev *dev = c_ctx(tfm)->dev;
  	struct sk_buff *skb = NULL;
  	int err, isfull = 0;
@@@ -1322,6 -1332,13 +1338,16 @@@
  	skb->dev = u_ctx->lldi.ports[0];
  	set_wr_txq(skb, CPL_PRIORITY_DATA, c_ctx(tfm)->tx_qidx);
  	chcr_send_wr(skb);
++<<<<<<< HEAD
++=======
+ 	if (get_cryptoalg_subtype(tfm) ==
+ 		CRYPTO_ALG_SUB_TYPE_CBC && req->base.flags ==
+ 			CRYPTO_TFM_REQ_MAY_SLEEP ) {
+ 			ctx=c_ctx(tfm);
+ 			reqctx->partial_req = 1;
+ 			wait_for_completion(&ctx->cbc_aes_aio_done);
+         }
++>>>>>>> bed44d0c05d8 (crypto: chelsio - Recalculate iv only if it is needed)
  	return isfull ? -EBUSY : -EINPROGRESS;
  error:
  	chcr_dec_wrcount(dev);
* Unmerged path drivers/crypto/chelsio/chcr_algo.c
diff --git a/drivers/crypto/chelsio/chcr_crypto.h b/drivers/crypto/chelsio/chcr_crypto.h
index e231e8b36624..8c815d5d9df5 100644
--- a/drivers/crypto/chelsio/chcr_crypto.h
+++ b/drivers/crypto/chelsio/chcr_crypto.h
@@ -291,6 +291,7 @@ struct chcr_blkcipher_req_ctx {
 	struct scatterlist *dstsg;
 	unsigned int processed;
 	unsigned int last_req_len;
+	unsigned int partial_req;
 	struct scatterlist *srcsg;
 	unsigned int src_ofst;
 	unsigned int dst_ofst;
