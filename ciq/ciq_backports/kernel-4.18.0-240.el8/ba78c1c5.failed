perf tools: Basic support for CGROUP event

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Namhyung Kim <namhyung@kernel.org>
commit ba78c1c5461c2fc2f57b777e971b3a9ec0df5666
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ba78c1c5.failed

Implement basic functionality to support cgroup tracking.  Each cgroup
can be identified by inode number which can be read from userspace too.
The actual cgroup processing will come in the later patch.

	Reported-by: kernel test robot <rong.a.chen@intel.com>
	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
[ fix perf test failure on sampling parsing ]
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Mark Rutland <mark.rutland@arm.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lore.kernel.org/lkml/20200325124536.2800725-4-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit ba78c1c5461c2fc2f57b777e971b3a9ec0df5666)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/perf/include/perf/event.h
#	tools/perf/tests/sample-parsing.c
#	tools/perf/util/evsel.c
#	tools/perf/util/perf_event_attr_fprintf.c
#	tools/perf/util/synthetic-events.c
diff --cc tools/perf/tests/sample-parsing.c
index 361714e2583c,61865699c3f4..000000000000
--- a/tools/perf/tests/sample-parsing.c
+++ b/tools/perf/tests/sample-parsing.c
@@@ -148,6 -151,18 +148,21 @@@ static bool samples_same(const struct p
  	if (type & PERF_SAMPLE_PHYS_ADDR)
  		COMP(phys_addr);
  
++<<<<<<< HEAD
++=======
+ 	if (type & PERF_SAMPLE_CGROUP)
+ 		COMP(cgroup);
+ 
+ 	if (type & PERF_SAMPLE_AUX) {
+ 		COMP(aux_sample.size);
+ 		if (memcmp(s1->aux_sample.data, s2->aux_sample.data,
+ 			   s1->aux_sample.size)) {
+ 			pr_debug("Samples differ at 'aux_sample'\n");
+ 			return false;
+ 		}
+ 	}
+ 
++>>>>>>> ba78c1c5461c (perf tools: Basic support for CGROUP event)
  	return true;
  }
  
@@@ -214,6 -233,11 +229,14 @@@ static int do_test(u64 sample_type, u6
  			.regs	= regs,
  		},
  		.phys_addr	= 113,
++<<<<<<< HEAD
++=======
+ 		.cgroup		= 114,
+ 		.aux_sample	= {
+ 			.size	= sizeof(aux_data),
+ 			.data	= (void *)aux_data,
+ 		},
++>>>>>>> ba78c1c5461c (perf tools: Basic support for CGROUP event)
  	};
  	struct sample_read_value values[] = {{1, 5}, {9, 3}, {2, 7}, {6, 4},};
  	struct perf_sample sample_out;
@@@ -313,7 -340,7 +336,11 @@@ int test__sample_parsing(struct test *t
  	 * were added.  Please actually update the test rather than just change
  	 * the condition below.
  	 */
++<<<<<<< HEAD
 +	if (PERF_SAMPLE_MAX > PERF_SAMPLE_PHYS_ADDR << 1) {
++=======
+ 	if (PERF_SAMPLE_MAX > PERF_SAMPLE_CGROUP << 1) {
++>>>>>>> ba78c1c5461c (perf tools: Basic support for CGROUP event)
  		pr_debug("sample format has changed, some new PERF_SAMPLE_ bit was introduced - test needs updating\n");
  		return -1;
  	}
diff --cc tools/perf/util/evsel.c
index ebf7fb36e8ca,b766eb608b97..000000000000
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@@ -2469,6 -2267,25 +2469,28 @@@ int perf_evsel__parse_sample(struct per
  		array++;
  	}
  
++<<<<<<< HEAD
++=======
+ 	data->cgroup = 0;
+ 	if (type & PERF_SAMPLE_CGROUP) {
+ 		data->cgroup = *array;
+ 		array++;
+ 	}
+ 
+ 	if (type & PERF_SAMPLE_AUX) {
+ 		OVERFLOW_CHECK_u64(array);
+ 		sz = *array++;
+ 
+ 		OVERFLOW_CHECK(array, sz, max_size);
+ 		/* Undo swap of data */
+ 		if (swapped)
+ 			mem_bswap_64((char *)array, sz);
+ 		data->aux_sample.size = sz;
+ 		data->aux_sample.data = (char *)array;
+ 		array = (void *)array + sz;
+ 	}
+ 
++>>>>>>> ba78c1c5461c (perf tools: Basic support for CGROUP event)
  	return 0;
  }
  
* Unmerged path tools/lib/perf/include/perf/event.h
* Unmerged path tools/perf/util/perf_event_attr_fprintf.c
* Unmerged path tools/perf/util/synthetic-events.c
* Unmerged path tools/lib/perf/include/perf/event.h
diff --git a/tools/perf/builtin-diff.c b/tools/perf/builtin-diff.c
index 2a37211ce0ec..8103c4207f9e 100644
--- a/tools/perf/builtin-diff.c
+++ b/tools/perf/builtin-diff.c
@@ -454,6 +454,7 @@ static struct perf_diff pdiff = {
 		.fork	= perf_event__process_fork,
 		.lost	= perf_event__process_lost,
 		.namespaces = perf_event__process_namespaces,
+		.cgroup = perf_event__process_cgroup,
 		.ordered_events = true,
 		.ordering_requires_timestamps = true,
 	},
diff --git a/tools/perf/builtin-report.c b/tools/perf/builtin-report.c
index facddb2dfe53..00bfa66cff77 100644
--- a/tools/perf/builtin-report.c
+++ b/tools/perf/builtin-report.c
@@ -1048,6 +1048,7 @@ int cmd_report(int argc, const char **argv)
 			.mmap2		 = perf_event__process_mmap2,
 			.comm		 = perf_event__process_comm,
 			.namespaces	 = perf_event__process_namespaces,
+			.cgroup		 = perf_event__process_cgroup,
 			.exit		 = perf_event__process_exit,
 			.fork		 = perf_event__process_fork,
 			.lost		 = perf_event__process_lost,
* Unmerged path tools/perf/tests/sample-parsing.c
diff --git a/tools/perf/util/event.c b/tools/perf/util/event.c
index 8a8363d72082..093a10ab976b 100644
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@ -51,6 +51,7 @@ static const char *perf_event__names[] = {
 	[PERF_RECORD_NAMESPACES]		= "NAMESPACES",
 	[PERF_RECORD_KSYMBOL]			= "KSYMBOL",
 	[PERF_RECORD_BPF_EVENT]			= "BPF_EVENT",
+	[PERF_RECORD_CGROUP]			= "CGROUP",
 	[PERF_RECORD_HEADER_ATTR]		= "ATTR",
 	[PERF_RECORD_HEADER_EVENT_TYPE]		= "EVENT_TYPE",
 	[PERF_RECORD_HEADER_TRACING_DATA]	= "TRACING_DATA",
@@ -1279,6 +1280,12 @@ size_t perf_event__fprintf_namespaces(union perf_event *event, FILE *fp)
 	return ret;
 }
 
+size_t perf_event__fprintf_cgroup(union perf_event *event, FILE *fp)
+{
+	return fprintf(fp, " cgroup: %" PRI_lu64 " %s\n",
+		       event->cgroup.id, event->cgroup.path);
+}
+
 int perf_event__process_comm(struct perf_tool *tool __maybe_unused,
 			     union perf_event *event,
 			     struct perf_sample *sample,
@@ -1295,6 +1302,14 @@ int perf_event__process_namespaces(struct perf_tool *tool __maybe_unused,
 	return machine__process_namespaces_event(machine, event, sample);
 }
 
+int perf_event__process_cgroup(struct perf_tool *tool __maybe_unused,
+			       union perf_event *event,
+			       struct perf_sample *sample,
+			       struct machine *machine)
+{
+	return machine__process_cgroup_event(machine, event, sample);
+}
+
 int perf_event__process_lost(struct perf_tool *tool __maybe_unused,
 			     union perf_event *event,
 			     struct perf_sample *sample,
@@ -1517,6 +1532,9 @@ size_t perf_event__fprintf(union perf_event *event, FILE *fp)
 	case PERF_RECORD_NAMESPACES:
 		ret += perf_event__fprintf_namespaces(event, fp);
 		break;
+	case PERF_RECORD_CGROUP:
+		ret += perf_event__fprintf_cgroup(event, fp);
+		break;
 	case PERF_RECORD_MMAP2:
 		ret += perf_event__fprintf_mmap2(event, fp);
 		break;
diff --git a/tools/perf/util/event.h b/tools/perf/util/event.h
index ba0ec1b6aad3..80b8b339391e 100644
--- a/tools/perf/util/event.h
+++ b/tools/perf/util/event.h
@@ -128,6 +128,7 @@ struct perf_sample {
 	u32 raw_size;
 	u64 data_src;
 	u64 phys_addr;
+	u64 cgroup;
 	u32 flags;
 	u16 insn_len;
 	u8  cpumode;
@@ -668,6 +669,10 @@ int perf_event__process_namespaces(struct perf_tool *tool,
 				   union perf_event *event,
 				   struct perf_sample *sample,
 				   struct machine *machine);
+int perf_event__process_cgroup(struct perf_tool *tool,
+			       union perf_event *event,
+			       struct perf_sample *sample,
+			       struct machine *machine);
 int perf_event__process_mmap(struct perf_tool *tool,
 			     union perf_event *event,
 			     struct perf_sample *sample,
@@ -755,6 +760,7 @@ size_t perf_event__fprintf_switch(union perf_event *event, FILE *fp);
 size_t perf_event__fprintf_thread_map(union perf_event *event, FILE *fp);
 size_t perf_event__fprintf_cpu_map(union perf_event *event, FILE *fp);
 size_t perf_event__fprintf_namespaces(union perf_event *event, FILE *fp);
+size_t perf_event__fprintf_cgroup(union perf_event *event, FILE *fp);
 size_t perf_event__fprintf_ksymbol(union perf_event *event, FILE *fp);
 size_t perf_event__fprintf_bpf_event(union perf_event *event, FILE *fp);
 size_t perf_event__fprintf(union perf_event *event, FILE *fp);
* Unmerged path tools/perf/util/evsel.c
diff --git a/tools/perf/util/machine.c b/tools/perf/util/machine.c
index 40cbcc9a1474..621d82875424 100644
--- a/tools/perf/util/machine.c
+++ b/tools/perf/util/machine.c
@@ -646,6 +646,16 @@ int machine__process_namespaces_event(struct machine *machine __maybe_unused,
 	return err;
 }
 
+int machine__process_cgroup_event(struct machine *machine __maybe_unused,
+				  union perf_event *event,
+				  struct perf_sample *sample __maybe_unused)
+{
+	if (dump_trace)
+		perf_event__fprintf_cgroup(event, stdout);
+
+	return 0;
+}
+
 int machine__process_lost_event(struct machine *machine __maybe_unused,
 				union perf_event *event, struct perf_sample *sample __maybe_unused)
 {
@@ -1878,6 +1888,8 @@ int machine__process_event(struct machine *machine, union perf_event *event,
 		ret = machine__process_mmap_event(machine, event, sample); break;
 	case PERF_RECORD_NAMESPACES:
 		ret = machine__process_namespaces_event(machine, event, sample); break;
+	case PERF_RECORD_CGROUP:
+		ret = machine__process_cgroup_event(machine, event, sample); break;
 	case PERF_RECORD_MMAP2:
 		ret = machine__process_mmap2_event(machine, event, sample); break;
 	case PERF_RECORD_FORK:
diff --git a/tools/perf/util/machine.h b/tools/perf/util/machine.h
index 4dd10eefeebb..f4fec63d6649 100644
--- a/tools/perf/util/machine.h
+++ b/tools/perf/util/machine.h
@@ -126,6 +126,9 @@ int machine__process_switch_event(struct machine *machine,
 int machine__process_namespaces_event(struct machine *machine,
 				      union perf_event *event,
 				      struct perf_sample *sample);
+int machine__process_cgroup_event(struct machine *machine,
+				  union perf_event *event,
+				  struct perf_sample *sample);
 int machine__process_mmap_event(struct machine *machine, union perf_event *event,
 				struct perf_sample *sample);
 int machine__process_mmap2_event(struct machine *machine, union perf_event *event,
* Unmerged path tools/perf/util/perf_event_attr_fprintf.c
diff --git a/tools/perf/util/session.c b/tools/perf/util/session.c
index 308033d72f73..d0ca70846387 100644
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@ -462,6 +462,8 @@ void perf_tool__fill_defaults(struct perf_tool *tool)
 		tool->comm = process_event_stub;
 	if (tool->namespaces == NULL)
 		tool->namespaces = process_event_stub;
+	if (tool->cgroup == NULL)
+		tool->cgroup = process_event_stub;
 	if (tool->fork == NULL)
 		tool->fork = process_event_stub;
 	if (tool->exit == NULL)
@@ -1422,6 +1424,8 @@ static int machines__deliver_event(struct machines *machines,
 		return tool->comm(tool, event, sample, machine);
 	case PERF_RECORD_NAMESPACES:
 		return tool->namespaces(tool, event, sample, machine);
+	case PERF_RECORD_CGROUP:
+		return tool->cgroup(tool, event, sample, machine);
 	case PERF_RECORD_FORK:
 		return tool->fork(tool, event, sample, machine);
 	case PERF_RECORD_EXIT:
* Unmerged path tools/perf/util/synthetic-events.c
diff --git a/tools/perf/util/tool.h b/tools/perf/util/tool.h
index 9096a6e3de59..a78d95e737d1 100644
--- a/tools/perf/util/tool.h
+++ b/tools/perf/util/tool.h
@@ -46,6 +46,7 @@ struct perf_tool {
 			mmap2,
 			comm,
 			namespaces,
+			cgroup,
 			fork,
 			exit,
 			lost,
