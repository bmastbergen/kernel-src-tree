netfilter: conntrack: handle builtin l4proto packet functions via direct calls

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit a47c5404816254d6cc4787f335c4720066a538e6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a47c5404.failed

The l4 protocol trackers are invoked via indirect call: l4proto->packet().

With one exception (gre), all l4trackers are builtin, so we can make
.packet optional and use a direct call for most protocols.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit a47c5404816254d6cc4787f335c4720066a538e6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_conntrack_l4proto.h
#	net/ipv4/netfilter/nf_conntrack_proto_icmp.c
#	net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
#	net/netfilter/nf_conntrack_core.c
#	net/netfilter/nf_conntrack_proto_dccp.c
#	net/netfilter/nf_conntrack_proto_sctp.c
#	net/netfilter/nf_conntrack_proto_tcp.c
#	net/netfilter/nf_conntrack_proto_udp.c
diff --cc include/net/netfilter/nf_conntrack_l4proto.h
index 264f50873a3a,6ca4355ae3dc..000000000000
--- a/include/net/netfilter/nf_conntrack_l4proto.h
+++ b/include/net/netfilter/nf_conntrack_l4proto.h
@@@ -105,6 -90,52 +105,55 @@@ struct nf_conntrack_l4proto 
  	struct module *me;
  };
  
++<<<<<<< HEAD
++=======
+ int nf_conntrack_icmpv4_error(struct nf_conn *tmpl,
+ 			      struct sk_buff *skb,
+ 			      unsigned int dataoff,
+ 			      const struct nf_hook_state *state);
+ 
+ int nf_conntrack_icmpv6_error(struct nf_conn *tmpl,
+ 			      struct sk_buff *skb,
+ 			      unsigned int dataoff,
+ 			      const struct nf_hook_state *state);
+ 
+ int nf_conntrack_icmp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state);
+ 
+ int nf_conntrack_icmpv6_packet(struct nf_conn *ct,
+ 			       struct sk_buff *skb,
+ 			       enum ip_conntrack_info ctinfo,
+ 			       const struct nf_hook_state *state);
+ 
+ int nf_conntrack_udp_packet(struct nf_conn *ct,
+ 			    struct sk_buff *skb,
+ 			    unsigned int dataoff,
+ 			    enum ip_conntrack_info ctinfo,
+ 			    const struct nf_hook_state *state);
+ int nf_conntrack_udplite_packet(struct nf_conn *ct,
+ 				struct sk_buff *skb,
+ 				unsigned int dataoff,
+ 				enum ip_conntrack_info ctinfo,
+ 				const struct nf_hook_state *state);
+ int nf_conntrack_tcp_packet(struct nf_conn *ct,
+ 			    struct sk_buff *skb,
+ 			    unsigned int dataoff,
+ 			    enum ip_conntrack_info ctinfo,
+ 			    const struct nf_hook_state *state);
+ int nf_conntrack_dccp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     unsigned int dataoff,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state);
+ int nf_conntrack_sctp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     unsigned int dataoff,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state);
+ 
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls)
  /* Existing built-in generic protocol */
  extern const struct nf_conntrack_l4proto nf_conntrack_l4proto_generic;
  
diff --cc net/ipv4/netfilter/nf_conntrack_proto_icmp.c
index 7cdc1512bd55,381a7f3ea68a..000000000000
--- a/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
+++ b/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
@@@ -71,17 -67,11 +71,24 @@@ static bool icmp_invert_tuple(struct nf
  	return true;
  }
  
 +static unsigned int *icmp_get_timeouts(struct net *net)
 +{
 +	return &icmp_pernet(net)->timeout;
 +}
 +
  /* Returns verdict for packet, or -1 for invalid. */
++<<<<<<< HEAD:net/ipv4/netfilter/nf_conntrack_proto_icmp.c
 +static int icmp_packet(struct nf_conn *ct,
 +		       const struct sk_buff *skb,
 +		       unsigned int dataoff,
 +		       enum ip_conntrack_info ctinfo,
 +		       unsigned int *timeout)
++=======
+ int nf_conntrack_icmp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state)
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls):net/netfilter/nf_conntrack_proto_icmp.c
  {
  	/* Do not immediately delete the connection after the first
  	   successful reply to avoid excessive conntrackd traffic
@@@ -356,12 -349,6 +363,15 @@@ const struct nf_conntrack_l4proto nf_co
  	.l4proto		= IPPROTO_ICMP,
  	.pkt_to_tuple		= icmp_pkt_to_tuple,
  	.invert_tuple		= icmp_invert_tuple,
++<<<<<<< HEAD:net/ipv4/netfilter/nf_conntrack_proto_icmp.c
 +	.packet			= icmp_packet,
 +	.get_timeouts		= icmp_get_timeouts,
 +	.new			= icmp_new,
 +	.error			= icmp_error,
 +	.destroy		= NULL,
 +	.me			= NULL,
++=======
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls):net/netfilter/nf_conntrack_proto_icmp.c
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr	= icmp_tuple_to_nlattr,
  	.nlattr_tuple_size	= icmp_nlattr_tuple_size,
diff --cc net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
index 4b225a43a543,93f27d0bcb75..000000000000
--- a/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
@@@ -90,12 -86,35 +90,19 @@@ static unsigned int *icmpv6_get_timeout
  }
  
  /* Returns verdict for packet, or -1 for invalid. */
++<<<<<<< HEAD:net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
 +static int icmpv6_packet(struct nf_conn *ct,
 +		       const struct sk_buff *skb,
 +		       unsigned int dataoff,
 +		       enum ip_conntrack_info ctinfo,
 +		       unsigned int *timeout)
++=======
+ int nf_conntrack_icmpv6_packet(struct nf_conn *ct,
+ 			       struct sk_buff *skb,
+ 			       enum ip_conntrack_info ctinfo,
+ 			       const struct nf_hook_state *state)
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls):net/netfilter/nf_conntrack_proto_icmpv6.c
  {
 -	unsigned int *timeout = nf_ct_timeout_lookup(ct);
 -	static const u8 valid_new[] = {
 -		[ICMPV6_ECHO_REQUEST - 128] = 1,
 -		[ICMPV6_NI_QUERY - 128] = 1
 -	};
 -
 -	if (state->pf != NFPROTO_IPV6)
 -		return -NF_ACCEPT;
 -
 -	if (!nf_ct_is_confirmed(ct)) {
 -		int type = ct->tuplehash[0].tuple.dst.u.icmp.type - 128;
 -
 -		if (type < 0 || type >= sizeof(valid_new) || !valid_new[type]) {
 -			/* Can't create a new ICMPv6 `conn' with this. */
 -			pr_debug("icmpv6: can't create new conn with type %u\n",
 -				 type + 128);
 -			nf_ct_dump_tuple_ipv6(&ct->tuplehash[0].tuple);
 -			return -NF_ACCEPT;
 -		}
 -	}
 -
 -	if (!timeout)
 -		timeout = icmpv6_get_timeouts(nf_ct_net(ct));
 -
  	/* Do not immediately delete the connection after the first
  	   successful reply to avoid excessive conntrackd traffic
  	   and also to handle correctly ICMP echo reply duplicates. */
@@@ -357,10 -360,6 +364,13 @@@ const struct nf_conntrack_l4proto nf_co
  	.l4proto		= IPPROTO_ICMPV6,
  	.pkt_to_tuple		= icmpv6_pkt_to_tuple,
  	.invert_tuple		= icmpv6_invert_tuple,
++<<<<<<< HEAD:net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
 +	.packet			= icmpv6_packet,
 +	.get_timeouts		= icmpv6_get_timeouts,
 +	.new			= icmpv6_new,
 +	.error			= icmpv6_error,
++=======
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls):net/netfilter/nf_conntrack_proto_icmpv6.c
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr	= icmpv6_tuple_to_nlattr,
  	.nlattr_tuple_size	= icmpv6_nlattr_tuple_size,
diff --cc net/netfilter/nf_conntrack_core.c
index 397b134cecce,5dfd95ae510d..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -1479,18 -1489,86 +1479,93 @@@ resolve_normal_ct(struct net *net, stru
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * icmp packets need special treatment to handle error messages that are
+  * related to a connection.
+  *
+  * Callers need to check if skb has a conntrack assigned when this
+  * helper returns; in such case skb belongs to an already known connection.
+  */
+ static unsigned int __cold
+ nf_conntrack_handle_icmp(struct nf_conn *tmpl,
+ 			 struct sk_buff *skb,
+ 			 unsigned int dataoff,
+ 			 u8 protonum,
+ 			 const struct nf_hook_state *state)
+ {
+ 	int ret;
+ 
+ 	if (state->pf == NFPROTO_IPV4 && protonum == IPPROTO_ICMP)
+ 		ret = nf_conntrack_icmpv4_error(tmpl, skb, dataoff, state);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	else if (state->pf == NFPROTO_IPV6 && protonum == IPPROTO_ICMPV6)
+ 		ret = nf_conntrack_icmpv6_error(tmpl, skb, dataoff, state);
+ #endif
+ 	else
+ 		return NF_ACCEPT;
+ 
+ 	if (ret <= 0) {
+ 		NF_CT_STAT_INC_ATOMIC(state->net, error);
+ 		NF_CT_STAT_INC_ATOMIC(state->net, invalid);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ /* Returns verdict for packet, or -1 for invalid. */
+ static int nf_conntrack_handle_packet(struct nf_conn *ct,
+ 				      struct sk_buff *skb,
+ 				      unsigned int dataoff,
+ 				      enum ip_conntrack_info ctinfo,
+ 				      const struct nf_hook_state *state)
+ {
+ 	switch (nf_ct_protonum(ct)) {
+ 	case IPPROTO_TCP:
+ 		return nf_conntrack_tcp_packet(ct, skb, dataoff,
+ 					       ctinfo, state);
+ 	case IPPROTO_UDP:
+ 		return nf_conntrack_udp_packet(ct, skb, dataoff,
+ 					       ctinfo, state);
+ 	case IPPROTO_ICMP:
+ 		return nf_conntrack_icmp_packet(ct, skb, ctinfo, state);
+ 	case IPPROTO_ICMPV6:
+ 		return nf_conntrack_icmpv6_packet(ct, skb, ctinfo, state);
+ #ifdef CONFIG_NF_CT_PROTO_UDPLITE
+ 	case IPPROTO_UDPLITE:
+ 		return nf_conntrack_udplite_packet(ct, skb, dataoff,
+ 						   ctinfo, state);
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ 	case IPPROTO_SCTP:
+ 		return nf_conntrack_sctp_packet(ct, skb, dataoff,
+ 						ctinfo, state);
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 	case IPPROTO_DCCP:
+ 		return nf_conntrack_dccp_packet(ct, skb, dataoff,
+ 						ctinfo, state);
+ #endif
+ 	}
+ 
+ 	WARN_ON_ONCE(1);
+ 	return -NF_ACCEPT;
+ }
+ 
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls)
  unsigned int
 -nf_conntrack_in(struct sk_buff *skb, const struct nf_hook_state *state)
 +nf_conntrack_in(struct net *net, u_int8_t pf, unsigned int hooknum,
 +		struct sk_buff *skb)
  {
 +	const struct nf_conntrack_l3proto *l3proto;
  	const struct nf_conntrack_l4proto *l4proto;
 -	enum ip_conntrack_info ctinfo;
  	struct nf_conn *ct, *tmpl;
 +	enum ip_conntrack_info ctinfo;
 +	unsigned int *timeouts;
 +	unsigned int dataoff;
  	u_int8_t protonum;
 -	int dataoff, ret;
 +	int ret;
  
  	tmpl = nf_ct_get(skb, &ctinfo);
  	if (tmpl || ctinfo == IP_CT_UNTRACKED) {
@@@ -1549,10 -1622,11 +1624,18 @@@ repeat
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	/* Decide what timeout policy we want to apply to this flow. */
 +	timeouts = nf_ct_timeout_lookup(net, ct, l4proto);
 +
 +	ret = l4proto->packet(ct, skb, dataoff, ctinfo, timeouts);
++=======
+ 	if (l4proto->packet)
+ 		ret = l4proto->packet(ct, skb, dataoff, ctinfo, state);
+ 	else
+ 		ret = nf_conntrack_handle_packet(ct, skb, dataoff, ctinfo, state);
+ 
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls)
  	if (ret <= 0) {
  		/* Invalid: inverse of the return code tells
  		 * the netfilter core what to do */
diff --cc net/netfilter/nf_conntrack_proto_dccp.c
index 1b076e836394,84408ec80624..000000000000
--- a/net/netfilter/nf_conntrack_proto_dccp.c
+++ b/net/netfilter/nf_conntrack_proto_dccp.c
@@@ -437,14 -430,52 +437,21 @@@ static u64 dccp_ack_seq(const struct dc
  		     ntohl(dhack->dccph_ack_nr_low);
  }
  
 -static bool dccp_error(const struct dccp_hdr *dh,
 -		       struct sk_buff *skb, unsigned int dataoff,
 -		       const struct nf_hook_state *state)
 +static unsigned int *dccp_get_timeouts(struct net *net)
  {
 -	unsigned int dccp_len = skb->len - dataoff;
 -	unsigned int cscov;
 -	const char *msg;
 -
 -	if (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||
 -	    dh->dccph_doff * 4 > dccp_len) {
 -		msg = "nf_ct_dccp: truncated/malformed packet ";
 -		goto out_invalid;
 -	}
 -
 -	cscov = dccp_len;
 -	if (dh->dccph_cscov) {
 -		cscov = (dh->dccph_cscov - 1) * 4;
 -		if (cscov > dccp_len) {
 -			msg = "nf_ct_dccp: bad checksum coverage ";
 -			goto out_invalid;
 -		}
 -	}
 -
 -	if (state->hook == NF_INET_PRE_ROUTING &&
 -	    state->net->ct.sysctl_checksum &&
 -	    nf_checksum_partial(skb, state->hook, dataoff, cscov,
 -				IPPROTO_DCCP, state->pf)) {
 -		msg = "nf_ct_dccp: bad checksum ";
 -		goto out_invalid;
 -	}
 -
 -	if (dh->dccph_type >= DCCP_PKT_INVALID) {
 -		msg = "nf_ct_dccp: reserved packet type ";
 -		goto out_invalid;
 -	}
 -	return false;
 -out_invalid:
 -	nf_l4proto_log_invalid(skb, state->net, state->pf,
 -			       IPPROTO_DCCP, "%s", msg);
 -	return true;
 +	return dccp_pernet(net)->dccp_timeout;
  }
  
++<<<<<<< HEAD
 +static int dccp_packet(struct nf_conn *ct, const struct sk_buff *skb,
 +		       unsigned int dataoff, enum ip_conntrack_info ctinfo,
 +		       unsigned int *timeouts)
++=======
+ int nf_conntrack_dccp_packet(struct nf_conn *ct, struct sk_buff *skb,
+ 			     unsigned int dataoff,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state)
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls)
  {
  	enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
  	struct dccp_hdr _dh, *dh;
@@@ -848,47 -838,8 +855,50 @@@ static struct nf_proto_net *dccp_get_ne
  	return &net->ct.nf_ct_proto.dccp.pn;
  }
  
 -const struct nf_conntrack_l4proto nf_conntrack_l4proto_dccp = {
 +const struct nf_conntrack_l4proto nf_conntrack_l4proto_dccp4 = {
 +	.l3proto		= AF_INET,
 +	.l4proto		= IPPROTO_DCCP,
++<<<<<<< HEAD
 +	.new			= dccp_new,
 +	.packet			= dccp_packet,
 +	.get_timeouts		= dccp_get_timeouts,
 +	.error			= dccp_error,
++=======
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls)
 +	.can_early_drop		= dccp_can_early_drop,
 +#ifdef CONFIG_NF_CONNTRACK_PROCFS
 +	.print_conntrack	= dccp_print_conntrack,
 +#endif
 +#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 +	.nlattr_size		= DCCP_NLATTR_SIZE,
 +	.to_nlattr		= dccp_to_nlattr,
 +	.from_nlattr		= nlattr_to_dccp,
 +	.tuple_to_nlattr	= nf_ct_port_tuple_to_nlattr,
 +	.nlattr_tuple_size	= nf_ct_port_nlattr_tuple_size,
 +	.nlattr_to_tuple	= nf_ct_port_nlattr_to_tuple,
 +	.nla_policy		= nf_ct_port_nla_policy,
 +#endif
 +#ifdef CONFIG_NF_CONNTRACK_TIMEOUT
 +	.ctnl_timeout		= {
 +		.nlattr_to_obj	= dccp_timeout_nlattr_to_obj,
 +		.obj_to_nlattr	= dccp_timeout_obj_to_nlattr,
 +		.nlattr_max	= CTA_TIMEOUT_DCCP_MAX,
 +		.obj_size	= sizeof(unsigned int) * CT_DCCP_MAX,
 +		.nla_policy	= dccp_timeout_nla_policy,
 +	},
 +#endif /* CONFIG_NF_CONNTRACK_TIMEOUT */
 +	.init_net		= dccp_init_net,
 +	.get_net_proto		= dccp_get_net_proto,
 +};
 +EXPORT_SYMBOL_GPL(nf_conntrack_l4proto_dccp4);
 +
 +const struct nf_conntrack_l4proto nf_conntrack_l4proto_dccp6 = {
 +	.l3proto		= AF_INET6,
  	.l4proto		= IPPROTO_DCCP,
 +	.new			= dccp_new,
 +	.packet			= dccp_packet,
 +	.get_timeouts		= dccp_get_timeouts,
 +	.error			= dccp_error,
  	.can_early_drop		= dccp_can_early_drop,
  #ifdef CONFIG_NF_CONNTRACK_PROCFS
  	.print_conntrack	= dccp_print_conntrack,
diff --cc net/netfilter/nf_conntrack_proto_sctp.c
index d72492231b01,952f2cc0fd74..000000000000
--- a/net/netfilter/nf_conntrack_proto_sctp.c
+++ b/net/netfilter/nf_conntrack_proto_sctp.c
@@@ -278,11 -357,11 +278,19 @@@ static unsigned int *sctp_get_timeouts(
  }
  
  /* Returns verdict for packet, or -NF_ACCEPT for invalid. */
++<<<<<<< HEAD
 +static int sctp_packet(struct nf_conn *ct,
 +		       const struct sk_buff *skb,
 +		       unsigned int dataoff,
 +		       enum ip_conntrack_info ctinfo,
 +		       unsigned int *timeouts)
++=======
+ int nf_conntrack_sctp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     unsigned int dataoff,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state)
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls)
  {
  	enum sctp_conntrack new_state, old_state;
  	enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
@@@ -763,43 -754,7 +771,45 @@@ static struct nf_proto_net *sctp_get_ne
  	return &net->ct.nf_ct_proto.sctp.pn;
  }
  
 -const struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp = {
 +const struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp4 = {
 +	.l3proto		= PF_INET,
 +	.l4proto 		= IPPROTO_SCTP,
 +#ifdef CONFIG_NF_CONNTRACK_PROCFS
 +	.print_conntrack	= sctp_print_conntrack,
 +#endif
++<<<<<<< HEAD
 +	.packet 		= sctp_packet,
 +	.get_timeouts		= sctp_get_timeouts,
 +	.new 			= sctp_new,
 +	.error			= sctp_error,
++=======
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls)
 +	.can_early_drop		= sctp_can_early_drop,
- 	.me 			= THIS_MODULE,
 +#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 +	.nlattr_size		= SCTP_NLATTR_SIZE,
 +	.to_nlattr		= sctp_to_nlattr,
 +	.from_nlattr		= nlattr_to_sctp,
 +	.tuple_to_nlattr	= nf_ct_port_tuple_to_nlattr,
 +	.nlattr_tuple_size	= nf_ct_port_nlattr_tuple_size,
 +	.nlattr_to_tuple	= nf_ct_port_nlattr_to_tuple,
 +	.nla_policy		= nf_ct_port_nla_policy,
 +#endif
 +#ifdef CONFIG_NF_CONNTRACK_TIMEOUT
 +	.ctnl_timeout		= {
 +		.nlattr_to_obj	= sctp_timeout_nlattr_to_obj,
 +		.obj_to_nlattr	= sctp_timeout_obj_to_nlattr,
 +		.nlattr_max	= CTA_TIMEOUT_SCTP_MAX,
 +		.obj_size	= sizeof(unsigned int) * SCTP_CONNTRACK_MAX,
 +		.nla_policy	= sctp_timeout_nla_policy,
 +	},
 +#endif /* CONFIG_NF_CONNTRACK_TIMEOUT */
 +	.init_net		= sctp_init_net,
 +	.get_net_proto		= sctp_get_net_proto,
 +};
 +EXPORT_SYMBOL_GPL(nf_conntrack_l4proto_sctp4);
 +
 +const struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp6 = {
 +	.l3proto		= PF_INET6,
  	.l4proto 		= IPPROTO_SCTP,
  #ifdef CONFIG_NF_CONNTRACK_PROCFS
  	.print_conntrack	= sctp_print_conntrack,
diff --cc net/netfilter/nf_conntrack_proto_tcp.c
index c603fa83f3e5,32aac9a835d4..000000000000
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@@ -776,16 -829,17 +776,24 @@@ static unsigned int *tcp_get_timeouts(s
  }
  
  /* Returns verdict for packet, or -1 for invalid. */
++<<<<<<< HEAD
 +static int tcp_packet(struct nf_conn *ct,
 +		      const struct sk_buff *skb,
 +		      unsigned int dataoff,
 +		      enum ip_conntrack_info ctinfo,
 +		      unsigned int *timeouts)
++=======
+ int nf_conntrack_tcp_packet(struct nf_conn *ct,
+ 			    struct sk_buff *skb,
+ 			    unsigned int dataoff,
+ 			    enum ip_conntrack_info ctinfo,
+ 			    const struct nf_hook_state *state)
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls)
  {
  	struct net *net = nf_ct_net(ct);
 -	struct nf_tcp_net *tn = nf_tcp_pernet(net);
 +	struct nf_tcp_net *tn = tcp_pernet(net);
  	struct nf_conntrack_tuple *tuple;
  	enum tcp_conntrack new_state, old_state;
 -	unsigned int index, *timeouts;
  	enum ip_conntrack_dir dir;
  	const struct tcphdr *th;
  	struct tcphdr _tcph;
@@@ -1546,10 -1535,6 +1554,13 @@@ const struct nf_conntrack_l4proto nf_co
  #ifdef CONFIG_NF_CONNTRACK_PROCFS
  	.print_conntrack 	= tcp_print_conntrack,
  #endif
++<<<<<<< HEAD
 +	.packet 		= tcp_packet,
 +	.get_timeouts		= tcp_get_timeouts,
 +	.new 			= tcp_new,
 +	.error			= tcp_error,
++=======
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls)
  	.can_early_drop		= tcp_can_early_drop,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.to_nlattr		= tcp_to_nlattr,
diff --cc net/netfilter/nf_conntrack_proto_udp.c
index ce9ce85bf0c7,e1f409aa0006..000000000000
--- a/net/netfilter/nf_conntrack_proto_udp.c
+++ b/net/netfilter/nf_conntrack_proto_udp.c
@@@ -28,26 -29,169 +28,136 @@@
  
  static const unsigned int udp_timeouts[UDP_CT_MAX] = {
  	[UDP_CT_UNREPLIED]	= 30*HZ,
 -	[UDP_CT_REPLIED]	= 120*HZ,
 +	[UDP_CT_REPLIED]	= 180*HZ,
  };
  
 -static unsigned int *udp_get_timeouts(struct net *net)
 +static inline struct nf_udp_net *udp_pernet(struct net *net)
  {
 -	return nf_udp_pernet(net)->timeouts;
 +	return &net->ct.nf_ct_proto.udp;
  }
  
 -static void udp_error_log(const struct sk_buff *skb,
 -			  const struct nf_hook_state *state,
 -			  const char *msg)
 +static unsigned int *udp_get_timeouts(struct net *net)
  {
 -	nf_l4proto_log_invalid(skb, state->net, state->pf,
 -			       IPPROTO_UDP, "%s", msg);
 +	return udp_pernet(net)->timeouts;
  }
  
 -static bool udp_error(struct sk_buff *skb,
 +/* Returns verdict for packet, and may modify conntracktype */
++<<<<<<< HEAD
 +static int udp_packet(struct nf_conn *ct,
 +		      const struct sk_buff *skb,
  		      unsigned int dataoff,
 -		      const struct nf_hook_state *state)
 +		      enum ip_conntrack_info ctinfo,
 +		      unsigned int *timeouts)
  {
 -	unsigned int udplen = skb->len - dataoff;
 -	const struct udphdr *hdr;
 -	struct udphdr _hdr;
 -
 -	/* Header is too small? */
 -	hdr = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);
 -	if (!hdr) {
 -		udp_error_log(skb, state, "short packet");
 -		return true;
 -	}
 -
 -	/* Truncated/malformed packets */
 -	if (ntohs(hdr->len) > udplen || ntohs(hdr->len) < sizeof(*hdr)) {
 -		udp_error_log(skb, state, "truncated/malformed packet");
 -		return true;
 -	}
 -
 -	/* Packet with no checksum */
 -	if (!hdr->check)
 -		return false;
 -
 -	/* Checksum invalid? Ignore.
 -	 * We skip checking packets on the outgoing path
 -	 * because the checksum is assumed to be correct.
 -	 * FIXME: Source route IP option packets --RR */
 -	if (state->hook == NF_INET_PRE_ROUTING &&
 -	    state->net->ct.sysctl_checksum &&
 -	    nf_checksum(skb, state->hook, dataoff, IPPROTO_UDP, state->pf)) {
 -		udp_error_log(skb, state, "bad checksum");
 -		return true;
 -	}
 -
 -	return false;
 -}
 -
 -/* Returns verdict for packet, and may modify conntracktype */
++=======
+ int nf_conntrack_udp_packet(struct nf_conn *ct,
+ 			    struct sk_buff *skb,
+ 			    unsigned int dataoff,
+ 			    enum ip_conntrack_info ctinfo,
+ 			    const struct nf_hook_state *state)
+ {
+ 	unsigned int *timeouts;
+ 
+ 	if (udp_error(skb, dataoff, state))
+ 		return -NF_ACCEPT;
+ 
+ 	timeouts = nf_ct_timeout_lookup(ct);
+ 	if (!timeouts)
+ 		timeouts = udp_get_timeouts(nf_ct_net(ct));
+ 
+ 	if (!nf_ct_is_confirmed(ct))
+ 		ct->proto.udp.stream_ts = 2 * HZ + jiffies;
+ 
+ 	/* If we've seen traffic both ways, this is some kind of UDP
+ 	 * stream. Set Assured.
+ 	 */
+ 	if (test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {
+ 		unsigned long extra = timeouts[UDP_CT_UNREPLIED];
+ 
+ 		/* Still active after two seconds? Extend timeout. */
+ 		if (time_after(jiffies, ct->proto.udp.stream_ts))
+ 			extra = timeouts[UDP_CT_REPLIED];
+ 
+ 		nf_ct_refresh_acct(ct, ctinfo, skb, extra);
+ 
+ 		/* Also, more likely to be important, and not a probe */
+ 		if (!test_and_set_bit(IPS_ASSURED_BIT, &ct->status))
+ 			nf_conntrack_event_cache(IPCT_ASSURED, ct);
+ 	} else {
+ 		nf_ct_refresh_acct(ct, ctinfo, skb,
+ 				   timeouts[UDP_CT_UNREPLIED]);
+ 	}
+ 	return NF_ACCEPT;
+ }
+ 
+ #ifdef CONFIG_NF_CT_PROTO_UDPLITE
+ static void udplite_error_log(const struct sk_buff *skb,
+ 			      const struct nf_hook_state *state,
+ 			      const char *msg)
+ {
+ 	nf_l4proto_log_invalid(skb, state->net, state->pf,
+ 			       IPPROTO_UDPLITE, "%s", msg);
+ }
+ 
+ static bool udplite_error(struct sk_buff *skb,
+ 			  unsigned int dataoff,
+ 			  const struct nf_hook_state *state)
+ {
+ 	unsigned int udplen = skb->len - dataoff;
+ 	const struct udphdr *hdr;
+ 	struct udphdr _hdr;
+ 	unsigned int cscov;
+ 
+ 	/* Header is too small? */
+ 	hdr = skb_header_pointer(skb, dataoff, sizeof(_hdr), &_hdr);
+ 	if (!hdr) {
+ 		udplite_error_log(skb, state, "short packet");
+ 		return true;
+ 	}
+ 
+ 	cscov = ntohs(hdr->len);
+ 	if (cscov == 0) {
+ 		cscov = udplen;
+ 	} else if (cscov < sizeof(*hdr) || cscov > udplen) {
+ 		udplite_error_log(skb, state, "invalid checksum coverage");
+ 		return true;
+ 	}
+ 
+ 	/* UDPLITE mandates checksums */
+ 	if (!hdr->check) {
+ 		udplite_error_log(skb, state, "checksum missing");
+ 		return true;
+ 	}
+ 
+ 	/* Checksum invalid? Ignore. */
+ 	if (state->hook == NF_INET_PRE_ROUTING &&
+ 	    state->net->ct.sysctl_checksum &&
+ 	    nf_checksum_partial(skb, state->hook, dataoff, cscov, IPPROTO_UDP,
+ 				state->pf)) {
+ 		udplite_error_log(skb, state, "bad checksum");
+ 		return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ /* Returns verdict for packet, and may modify conntracktype */
+ int nf_conntrack_udplite_packet(struct nf_conn *ct,
+ 				struct sk_buff *skb,
+ 				unsigned int dataoff,
+ 				enum ip_conntrack_info ctinfo,
+ 				const struct nf_hook_state *state)
+ {
+ 	unsigned int *timeouts;
+ 
+ 	if (udplite_error(skb, dataoff, state))
+ 		return -NF_ACCEPT;
+ 
+ 	timeouts = nf_ct_timeout_lookup(ct);
+ 	if (!timeouts)
+ 		timeouts = udp_get_timeouts(nf_ct_net(ct));
+ 
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls)
  	/* If we've seen traffic both ways, this is some kind of UDP
  	   stream.  Extend timeout. */
  	if (test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {
@@@ -269,75 -315,10 +379,81 @@@ static struct nf_proto_net *udp_get_net
  	return &net->ct.nf_ct_proto.udp.pn;
  }
  
 -const struct nf_conntrack_l4proto nf_conntrack_l4proto_udp =
 +const struct nf_conntrack_l4proto nf_conntrack_l4proto_udp4 =
 +{
 +	.l3proto		= PF_INET,
 +	.l4proto		= IPPROTO_UDP,
 +	.allow_clash		= true,
++<<<<<<< HEAD
 +	.packet			= udp_packet,
 +	.get_timeouts		= udp_get_timeouts,
 +	.new			= udp_new,
 +	.error			= udp_error,
++=======
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls)
 +#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 +	.tuple_to_nlattr	= nf_ct_port_tuple_to_nlattr,
 +	.nlattr_to_tuple	= nf_ct_port_nlattr_to_tuple,
 +	.nlattr_tuple_size	= nf_ct_port_nlattr_tuple_size,
 +	.nla_policy		= nf_ct_port_nla_policy,
 +#endif
 +#ifdef CONFIG_NF_CONNTRACK_TIMEOUT
 +	.ctnl_timeout		= {
 +		.nlattr_to_obj	= udp_timeout_nlattr_to_obj,
 +		.obj_to_nlattr	= udp_timeout_obj_to_nlattr,
 +		.nlattr_max	= CTA_TIMEOUT_UDP_MAX,
 +		.obj_size	= sizeof(unsigned int) * CTA_TIMEOUT_UDP_MAX,
 +		.nla_policy	= udp_timeout_nla_policy,
 +	},
 +#endif /* CONFIG_NF_CONNTRACK_TIMEOUT */
 +	.init_net		= udp_init_net,
 +	.get_net_proto		= udp_get_net_proto,
 +};
 +EXPORT_SYMBOL_GPL(nf_conntrack_l4proto_udp4);
 +
 +#ifdef CONFIG_NF_CT_PROTO_UDPLITE
 +const struct nf_conntrack_l4proto nf_conntrack_l4proto_udplite4 =
 +{
 +	.l3proto		= PF_INET,
 +	.l4proto		= IPPROTO_UDPLITE,
 +	.allow_clash		= true,
++<<<<<<< HEAD
 +	.packet			= udp_packet,
 +	.get_timeouts		= udp_get_timeouts,
 +	.new			= udp_new,
 +	.error			= udplite_error,
++=======
++>>>>>>> a47c54048162 (netfilter: conntrack: handle builtin l4proto packet functions via direct calls)
 +#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 +	.tuple_to_nlattr	= nf_ct_port_tuple_to_nlattr,
 +	.nlattr_to_tuple	= nf_ct_port_nlattr_to_tuple,
 +	.nlattr_tuple_size	= nf_ct_port_nlattr_tuple_size,
 +	.nla_policy		= nf_ct_port_nla_policy,
 +#endif
 +#ifdef CONFIG_NF_CONNTRACK_TIMEOUT
 +	.ctnl_timeout		= {
 +		.nlattr_to_obj	= udp_timeout_nlattr_to_obj,
 +		.obj_to_nlattr	= udp_timeout_obj_to_nlattr,
 +		.nlattr_max	= CTA_TIMEOUT_UDP_MAX,
 +		.obj_size	= sizeof(unsigned int) * CTA_TIMEOUT_UDP_MAX,
 +		.nla_policy	= udp_timeout_nla_policy,
 +	},
 +#endif /* CONFIG_NF_CONNTRACK_TIMEOUT */
 +	.init_net		= udp_init_net,
 +	.get_net_proto		= udp_get_net_proto,
 +};
 +EXPORT_SYMBOL_GPL(nf_conntrack_l4proto_udplite4);
 +#endif
 +
 +const struct nf_conntrack_l4proto nf_conntrack_l4proto_udp6 =
  {
 +	.l3proto		= PF_INET6,
  	.l4proto		= IPPROTO_UDP,
  	.allow_clash		= true,
 +	.packet			= udp_packet,
 +	.get_timeouts		= udp_get_timeouts,
 +	.new			= udp_new,
 +	.error			= udp_error,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr	= nf_ct_port_tuple_to_nlattr,
  	.nlattr_to_tuple	= nf_ct_port_nlattr_to_tuple,
* Unmerged path include/net/netfilter/nf_conntrack_l4proto.h
* Unmerged path net/ipv4/netfilter/nf_conntrack_proto_icmp.c
* Unmerged path net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
* Unmerged path net/netfilter/nf_conntrack_core.c
* Unmerged path net/netfilter/nf_conntrack_proto_dccp.c
* Unmerged path net/netfilter/nf_conntrack_proto_sctp.c
* Unmerged path net/netfilter/nf_conntrack_proto_tcp.c
* Unmerged path net/netfilter/nf_conntrack_proto_udp.c
