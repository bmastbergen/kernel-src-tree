drivers: media: Call cpu_latency_qos_*() instead of pm_qos_*()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 7c51a06b2560b2ecd6cd01251dc478fce4bd6938
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7c51a06b.failed

Call cpu_latency_qos_add/remove_request() instead of
pm_qos_add/remove_request(), respectively, because the
latter are going to be dropped.

No intentional functional impact.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
	Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
	Reviewed-by: Amit Kucheria <amit.kucheria@linaro.org>
	Tested-by: Amit Kucheria <amit.kucheria@linaro.org>
(cherry picked from commit 7c51a06b2560b2ecd6cd01251dc478fce4bd6938)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/media/platform/via-camera.c
diff --cc drivers/media/platform/via-camera.c
index c8bb82fe0b9d,1cd4f7be88dd..000000000000
--- a/drivers/media/platform/via-camera.c
+++ b/drivers/media/platform/via-camera.c
@@@ -595,63 -618,67 +595,85 @@@ static int viacam_vb_buf_setup(struct v
  	return 0;
  }
  
 -static int viacam_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)
 +/*
 + * Prepare a buffer.
 + */
 +static int viacam_vb_buf_prepare(struct videobuf_queue *q,
 +		struct videobuf_buffer *vb, enum v4l2_field field)
  {
 -	struct via_camera *cam = vb2_get_drv_priv(vq);
 -	struct via_buffer *buf, *tmp;
 -	int ret = 0;
 -
 -	if (cam->opstate != S_IDLE) {
 -		ret = -EBUSY;
 -		goto out;
 -	}
 -	/*
 -	 * Configure things if need be.
 -	 */
 -	if (test_bit(CF_CONFIG_NEEDED, &cam->flags)) {
 -		ret = viacam_configure_sensor(cam);
 +	struct via_camera *cam = q->priv_data;
 +
 +	vb->size = cam->user_format.sizeimage;
 +	vb->width = cam->user_format.width; /* bytesperline???? */
 +	vb->height = cam->user_format.height;
 +	vb->field = field;
 +	if (vb->state == VIDEOBUF_NEEDS_INIT) {
 +		int ret = videobuf_iolock(q, vb, NULL);
  		if (ret)
 -			goto out;
 -		ret = viacam_config_controller(cam);
 -		if (ret)
 -			goto out;
 +			return ret;
  	}
++<<<<<<< HEAD
 +	vb->state = VIDEOBUF_PREPARED;
++=======
+ 	cam->sequence = 0;
+ 	/*
+ 	 * If the CPU goes into C3, the DMA transfer gets corrupted and
+ 	 * users start filing unsightly bug reports.  Put in a "latency"
+ 	 * requirement which will keep the CPU out of the deeper sleep
+ 	 * states.
+ 	 */
+ 	cpu_latency_qos_add_request(&cam->qos_request, 50);
+ 	viacam_start_engine(cam);
++>>>>>>> 7c51a06b2560 (drivers: media: Call cpu_latency_qos_*() instead of pm_qos_*())
  	return 0;
 -out:
 -	list_for_each_entry_safe(buf, tmp, &cam->buffer_queue, queue) {
 -		list_del(&buf->queue);
 -		vb2_buffer_done(&buf->vbuf.vb2_buf, VB2_BUF_STATE_QUEUED);
 -	}
 -	return ret;
  }
  
 -static void viacam_vb2_stop_streaming(struct vb2_queue *vq)
 +/*
 + * We've got a buffer to put data into.
 + *
 + * FIXME: check for a running engine and valid buffers?
 + */
 +static void viacam_vb_buf_queue(struct videobuf_queue *q,
 +		struct videobuf_buffer *vb)
  {
 -	struct via_camera *cam = vb2_get_drv_priv(vq);
 -	struct via_buffer *buf, *tmp;
 +	struct via_camera *cam = q->priv_data;
  
++<<<<<<< HEAD
 +	/*
 +	 * Note that videobuf holds the lock when it calls
 +	 * us, so we need not (indeed, cannot) take it here.
 +	 */
 +	vb->state = VIDEOBUF_QUEUED;
 +	list_add_tail(&vb->queue, &cam->buffer_queue);
++=======
+ 	cpu_latency_qos_remove_request(&cam->qos_request);
+ 	viacam_stop_engine(cam);
+ 
+ 	list_for_each_entry_safe(buf, tmp, &cam->buffer_queue, queue) {
+ 		list_del(&buf->queue);
+ 		vb2_buffer_done(&buf->vbuf.vb2_buf, VB2_BUF_STATE_ERROR);
+ 	}
++>>>>>>> 7c51a06b2560 (drivers: media: Call cpu_latency_qos_*() instead of pm_qos_*())
  }
  
 -static const struct vb2_ops viacam_vb2_ops = {
 -	.queue_setup		= viacam_vb2_queue_setup,
 -	.buf_queue		= viacam_vb2_queue,
 -	.buf_prepare		= viacam_vb2_prepare,
 -	.start_streaming	= viacam_vb2_start_streaming,
 -	.stop_streaming		= viacam_vb2_stop_streaming,
 -	.wait_prepare		= vb2_ops_wait_prepare,
 -	.wait_finish		= vb2_ops_wait_finish,
 +/*
 + * Free a buffer.
 + */
 +static void viacam_vb_buf_release(struct videobuf_queue *q,
 +		struct videobuf_buffer *vb)
 +{
 +	struct via_camera *cam = q->priv_data;
 +
 +	videobuf_dma_unmap(&cam->platdev->dev, videobuf_to_dma(vb));
 +	videobuf_dma_free(videobuf_to_dma(vb));
 +	vb->state = VIDEOBUF_NEEDS_INIT;
 +}
 +
 +static const struct videobuf_queue_ops viacam_vb_ops = {
 +	.buf_setup	= viacam_vb_buf_setup,
 +	.buf_prepare	= viacam_vb_buf_prepare,
 +	.buf_queue	= viacam_vb_buf_queue,
 +	.buf_release	= viacam_vb_buf_release,
  };
  
  /* --------------------------------------------------------------------------*/
diff --git a/drivers/media/pci/saa7134/saa7134-video.c b/drivers/media/pci/saa7134/saa7134-video.c
index 1a50ec9d084f..c21c1edde0d3 100644
--- a/drivers/media/pci/saa7134/saa7134-video.c
+++ b/drivers/media/pci/saa7134/saa7134-video.c
@@ -1031,8 +1031,7 @@ int saa7134_vb2_start_streaming(struct vb2_queue *vq, unsigned int count)
 	 */
 	if ((dmaq == &dev->video_q && !vb2_is_streaming(&dev->vbi_vbq)) ||
 	    (dmaq == &dev->vbi_q && !vb2_is_streaming(&dev->video_vbq)))
-		pm_qos_add_request(&dev->qos_request,
-			PM_QOS_CPU_DMA_LATENCY, 20);
+		cpu_latency_qos_add_request(&dev->qos_request, 20);
 	dmaq->seq_nr = 0;
 
 	return 0;
@@ -1047,7 +1046,7 @@ void saa7134_vb2_stop_streaming(struct vb2_queue *vq)
 
 	if ((dmaq == &dev->video_q && !vb2_is_streaming(&dev->vbi_vbq)) ||
 	    (dmaq == &dev->vbi_q && !vb2_is_streaming(&dev->video_vbq)))
-		pm_qos_remove_request(&dev->qos_request);
+		cpu_latency_qos_remove_request(&dev->qos_request);
 }
 
 static const struct vb2_ops vb2_qops = {
* Unmerged path drivers/media/platform/via-camera.c
