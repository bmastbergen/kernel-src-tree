net: sched: Make FIFO Qdisc offloadable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] sched: Make FIFO Qdisc offloadable (Ivan Vecera) [1824071]
Rebuild_FUZZ: 93.15%
commit-author Petr Machata <petrm@mellanox.com>
commit aaca9408078914380fbfd8aef3c38a34b515a654
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/aaca9408.failed

Invoke ndo_setup_tc() as appropriate to signal init / replacement,
destroying and dumping of pFIFO / bFIFO Qdisc.

A lot of the FIFO logic is used for pFIFO_head_drop as well, but that's a
semantically very different Qdisc that isn't really in the same boat as
pFIFO / bFIFO. Split some of the functions to keep the Qdisc intact.

	Signed-off-by: Petr Machata <petrm@mellanox.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit aaca9408078914380fbfd8aef3c38a34b515a654)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	include/net/pkt_cls.h
diff --cc include/linux/netdevice.h
index 4bd94d67974c,654808bfad83..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -869,6 -850,10 +869,13 @@@ enum tc_setup_type 
  	TC_SETUP_ROOT_QDISC,
  	TC_SETUP_QDISC_GRED,
  	TC_SETUP_QDISC_TAPRIO,
++<<<<<<< HEAD
++=======
+ 	TC_SETUP_FT,
+ 	TC_SETUP_QDISC_ETS,
+ 	TC_SETUP_QDISC_TBF,
+ 	TC_SETUP_QDISC_FIFO,
++>>>>>>> aaca94080789 (net: sched: Make FIFO Qdisc offloadable)
  };
  
  /* These structures hold the attributes of bpf state that are being passed
diff --cc include/net/pkt_cls.h
index e113c3227a24,341a66af8d59..000000000000
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@@ -841,4 -828,72 +841,75 @@@ struct tc_root_qopt_offload 
  	bool ingress;
  };
  
++<<<<<<< HEAD
++=======
+ enum tc_ets_command {
+ 	TC_ETS_REPLACE,
+ 	TC_ETS_DESTROY,
+ 	TC_ETS_STATS,
+ 	TC_ETS_GRAFT,
+ };
+ 
+ struct tc_ets_qopt_offload_replace_params {
+ 	unsigned int bands;
+ 	u8 priomap[TC_PRIO_MAX + 1];
+ 	unsigned int quanta[TCQ_ETS_MAX_BANDS];	/* 0 for strict bands. */
+ 	unsigned int weights[TCQ_ETS_MAX_BANDS];
+ 	struct gnet_stats_queue *qstats;
+ };
+ 
+ struct tc_ets_qopt_offload_graft_params {
+ 	u8 band;
+ 	u32 child_handle;
+ };
+ 
+ struct tc_ets_qopt_offload {
+ 	enum tc_ets_command command;
+ 	u32 handle;
+ 	u32 parent;
+ 	union {
+ 		struct tc_ets_qopt_offload_replace_params replace_params;
+ 		struct tc_qopt_offload_stats stats;
+ 		struct tc_ets_qopt_offload_graft_params graft_params;
+ 	};
+ };
+ 
+ enum tc_tbf_command {
+ 	TC_TBF_REPLACE,
+ 	TC_TBF_DESTROY,
+ 	TC_TBF_STATS,
+ };
+ 
+ struct tc_tbf_qopt_offload_replace_params {
+ 	struct psched_ratecfg rate;
+ 	u32 max_size;
+ 	struct gnet_stats_queue *qstats;
+ };
+ 
+ struct tc_tbf_qopt_offload {
+ 	enum tc_tbf_command command;
+ 	u32 handle;
+ 	u32 parent;
+ 	union {
+ 		struct tc_tbf_qopt_offload_replace_params replace_params;
+ 		struct tc_qopt_offload_stats stats;
+ 	};
+ };
+ 
+ enum tc_fifo_command {
+ 	TC_FIFO_REPLACE,
+ 	TC_FIFO_DESTROY,
+ 	TC_FIFO_STATS,
+ };
+ 
+ struct tc_fifo_qopt_offload {
+ 	enum tc_fifo_command command;
+ 	u32 handle;
+ 	u32 parent;
+ 	union {
+ 		struct tc_qopt_offload_stats stats;
+ 	};
+ };
+ 
++>>>>>>> aaca94080789 (net: sched: Make FIFO Qdisc offloadable)
  #endif
* Unmerged path include/linux/netdevice.h
* Unmerged path include/net/pkt_cls.h
diff --git a/net/sched/sch_fifo.c b/net/sched/sch_fifo.c
index 3809c9bf8896..df9e0471c161 100644
--- a/net/sched/sch_fifo.c
+++ b/net/sched/sch_fifo.c
@@ -16,6 +16,7 @@
 #include <linux/errno.h>
 #include <linux/skbuff.h>
 #include <net/pkt_sched.h>
+#include <net/pkt_cls.h>
 
 /* 1 band FIFO pseudo-"scheduler" */
 
@@ -55,8 +56,49 @@ static int pfifo_tail_enqueue(struct sk_buff *skb, struct Qdisc *sch,
 	return NET_XMIT_CN;
 }
 
-static int fifo_init(struct Qdisc *sch, struct nlattr *opt,
-		     struct netlink_ext_ack *extack)
+static void fifo_offload_init(struct Qdisc *sch)
+{
+	struct net_device *dev = qdisc_dev(sch);
+	struct tc_fifo_qopt_offload qopt;
+
+	if (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)
+		return;
+
+	qopt.command = TC_FIFO_REPLACE;
+	qopt.handle = sch->handle;
+	qopt.parent = sch->parent;
+	dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_FIFO, &qopt);
+}
+
+static void fifo_offload_destroy(struct Qdisc *sch)
+{
+	struct net_device *dev = qdisc_dev(sch);
+	struct tc_fifo_qopt_offload qopt;
+
+	if (!tc_can_offload(dev) || !dev->netdev_ops->ndo_setup_tc)
+		return;
+
+	qopt.command = TC_FIFO_DESTROY;
+	qopt.handle = sch->handle;
+	qopt.parent = sch->parent;
+	dev->netdev_ops->ndo_setup_tc(dev, TC_SETUP_QDISC_FIFO, &qopt);
+}
+
+static int fifo_offload_dump(struct Qdisc *sch)
+{
+	struct tc_fifo_qopt_offload qopt;
+
+	qopt.command = TC_FIFO_STATS;
+	qopt.handle = sch->handle;
+	qopt.parent = sch->parent;
+	qopt.stats.bstats = &sch->bstats;
+	qopt.stats.qstats = &sch->qstats;
+
+	return qdisc_offload_dump_helper(sch, TC_SETUP_QDISC_FIFO, &qopt);
+}
+
+static int __fifo_init(struct Qdisc *sch, struct nlattr *opt,
+		       struct netlink_ext_ack *extack)
 {
 	bool bypass;
 	bool is_bfifo = sch->ops == &bfifo_qdisc_ops;
@@ -86,10 +128,35 @@ static int fifo_init(struct Qdisc *sch, struct nlattr *opt,
 		sch->flags |= TCQ_F_CAN_BYPASS;
 	else
 		sch->flags &= ~TCQ_F_CAN_BYPASS;
+
 	return 0;
 }
 
-static int fifo_dump(struct Qdisc *sch, struct sk_buff *skb)
+static int fifo_init(struct Qdisc *sch, struct nlattr *opt,
+		     struct netlink_ext_ack *extack)
+{
+	int err;
+
+	err = __fifo_init(sch, opt, extack);
+	if (err)
+		return err;
+
+	fifo_offload_init(sch);
+	return 0;
+}
+
+static int fifo_hd_init(struct Qdisc *sch, struct nlattr *opt,
+			struct netlink_ext_ack *extack)
+{
+	return __fifo_init(sch, opt, extack);
+}
+
+static void fifo_destroy(struct Qdisc *sch)
+{
+	fifo_offload_destroy(sch);
+}
+
+static int __fifo_dump(struct Qdisc *sch, struct sk_buff *skb)
 {
 	struct tc_fifo_qopt opt = { .limit = sch->limit };
 
@@ -101,6 +168,22 @@ static int fifo_dump(struct Qdisc *sch, struct sk_buff *skb)
 	return -1;
 }
 
+static int fifo_dump(struct Qdisc *sch, struct sk_buff *skb)
+{
+	int err;
+
+	err = fifo_offload_dump(sch);
+	if (err)
+		return err;
+
+	return __fifo_dump(sch, skb);
+}
+
+static int fifo_hd_dump(struct Qdisc *sch, struct sk_buff *skb)
+{
+	return __fifo_dump(sch, skb);
+}
+
 struct Qdisc_ops pfifo_qdisc_ops __read_mostly = {
 	.id		=	"pfifo",
 	.priv_size	=	0,
@@ -108,6 +191,7 @@ struct Qdisc_ops pfifo_qdisc_ops __read_mostly = {
 	.dequeue	=	qdisc_dequeue_head,
 	.peek		=	qdisc_peek_head,
 	.init		=	fifo_init,
+	.destroy	=	fifo_destroy,
 	.reset		=	qdisc_reset_queue,
 	.change		=	fifo_init,
 	.dump		=	fifo_dump,
@@ -122,6 +206,7 @@ struct Qdisc_ops bfifo_qdisc_ops __read_mostly = {
 	.dequeue	=	qdisc_dequeue_head,
 	.peek		=	qdisc_peek_head,
 	.init		=	fifo_init,
+	.destroy	=	fifo_destroy,
 	.reset		=	qdisc_reset_queue,
 	.change		=	fifo_init,
 	.dump		=	fifo_dump,
@@ -135,10 +220,10 @@ struct Qdisc_ops pfifo_head_drop_qdisc_ops __read_mostly = {
 	.enqueue	=	pfifo_tail_enqueue,
 	.dequeue	=	qdisc_dequeue_head,
 	.peek		=	qdisc_peek_head,
-	.init		=	fifo_init,
+	.init		=	fifo_hd_init,
 	.reset		=	qdisc_reset_queue,
-	.change		=	fifo_init,
-	.dump		=	fifo_dump,
+	.change		=	fifo_hd_init,
+	.dump		=	fifo_hd_dump,
 	.owner		=	THIS_MODULE,
 };
 
