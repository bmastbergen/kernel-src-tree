efi/tpm: Don't access event->count when it isn't mapped

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Peter Jones <pjones@redhat.com>
commit 047d50aee341d940350897c85799e56ae57c3849
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/047d50ae.failed

Some machines generate a lot of event log entries.  When we're
iterating over them, the code removes the old mapping and adds a
new one, so once we cross the page boundary we're unmapping the page
with the count on it.  Hilarity ensues.

This patch keeps the info from the header in local variables so we don't
need to access that page again or keep track of if it's mapped.

	Tested-by: Lyude Paul <lyude@redhat.com>
	Signed-off-by: Peter Jones <pjones@redhat.com>
	Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
	Acked-by: Matthew Garrett <mjg59@google.com>
	Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Cc: Ben Dooks <ben.dooks@codethink.co.uk>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Jerry Snitselaar <jsnitsel@redhat.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Lukas Wunner <lukas@wunner.de>
	Cc: Octavian Purdila <octavian.purdila@intel.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Scott Talbert <swt@techie.net>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: linux-efi@vger.kernel.org
	Cc: linux-integrity@vger.kernel.org
	Cc: stable@vger.kernel.org
Fixes: 44038bc514a2 ("tpm: Abstract crypto agile event size calculations")
Link: https://lkml.kernel.org/r/20191002165904.8819-4-ard.biesheuvel@linaro.org
[ Minor edits. ]
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 047d50aee341d940350897c85799e56ae57c3849)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/tpm_eventlog.h
diff --cc include/linux/tpm_eventlog.h
index 6a86144e13f1,b50cc3adca18..000000000000
--- a/include/linux/tpm_eventlog.h
+++ b/include/linux/tpm_eventlog.h
@@@ -148,16 -177,55 +149,47 @@@ static inline int __calc_tpm2_event_siz
  	marker = marker + sizeof(event->pcr_idx) + sizeof(event->event_type)
  		+ sizeof(event->count);
  
++<<<<<<< HEAD
 +	efispecid = (struct tcg_efi_specid_event_head *)event_header->event;
 +
 +	/* Check if event is malformed. */
 +	if (event->count > efispecid->num_algs)
 +		return 0;
++=======
+ 	/* Map the event header */
+ 	if (do_mapping) {
+ 		mapping_size = marker - marker_start;
+ 		mapping = TPM_MEMREMAP((unsigned long)marker_start,
+ 				       mapping_size);
+ 		if (!mapping) {
+ 			size = 0;
+ 			goto out;
+ 		}
+ 	} else {
+ 		mapping = marker_start;
+ 	}
+ 
+ 	event = (struct tcg_pcr_event2_head *)mapping;
+ 	/*
+ 	 * The loop below will unmap these fields if the log is larger than
+ 	 * one page, so save them here for reference:
+ 	 */
+ 	count = READ_ONCE(event->count);
+ 	event_type = READ_ONCE(event->event_type);
+ 
+ 	efispecid = (struct tcg_efi_specid_event_head *)event_header->event;
  
- 	for (i = 0; i < event->count; i++) {
+ 	/* Check if event is malformed. */
+ 	if (count > efispecid->num_algs) {
+ 		size = 0;
+ 		goto out;
+ 	}
++>>>>>>> 047d50aee341 (efi/tpm: Don't access event->count when it isn't mapped)
+ 
+ 	for (i = 0; i < count; i++) {
  		halg_size = sizeof(event->digests[i].alg_id);
 -
 -		/* Map the digest's algorithm identifier */
 -		if (do_mapping) {
 -			TPM_MEMUNMAP(mapping, mapping_size);
 -			mapping_size = halg_size;
 -			mapping = TPM_MEMREMAP((unsigned long)marker,
 -					     mapping_size);
 -			if (!mapping) {
 -				size = 0;
 -				goto out;
 -			}
 -		} else {
 -			mapping = marker;
 -		}
 -
 -		memcpy(&halg, mapping, halg_size);
 +		memcpy(&halg, marker, halg_size);
  		marker = marker + halg_size;
 -
  		for (j = 0; j < efispecid->num_algs; j++) {
  			if (halg == efispecid->digest_sizes[j].alg_id) {
  				marker +=
@@@ -175,9 -263,13 +207,18 @@@
  		+ event_field->event_size;
  	size = marker - marker_start;
  
++<<<<<<< HEAD
 +	if ((event->event_type == 0) && (event_field->event_size == 0))
 +		return 0;
 +
++=======
+ 	if (event_type == 0 && event_field->event_size == 0)
+ 		size = 0;
+ 
+ out:
+ 	if (do_mapping)
+ 		TPM_MEMUNMAP(mapping, mapping_size);
++>>>>>>> 047d50aee341 (efi/tpm: Don't access event->count when it isn't mapped)
  	return size;
  }
 -
  #endif
* Unmerged path include/linux/tpm_eventlog.h
