net/tls: add skeleton of MIB statistics

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] tls: add skeleton of MIB statistics (Sabrina Dubroca) [1819627]
Rebuild_FUZZ: 94.59%
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit d26b698dd3cd52f5a3277446a87e5e0198c99cd0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d26b698d.failed

Add a skeleton structure for adding TLS statistics.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d26b698dd3cd52f5a3277446a87e5e0198c99cd0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tls.h
#	net/tls/Makefile
#	net/tls/tls_main.c
diff --cc include/net/tls.h
index 355cc88fb8ed,24c37bffc961..000000000000
--- a/include/net/tls.h
+++ b/include/net/tls.h
@@@ -77,30 -74,14 +78,41 @@@
   */
  #define TLS_AES_CCM_IV_B0_BYTE		2
  
++<<<<<<< HEAD
 +/*
 + * This structure defines the routines for Inline TLS driver.
 + * The following routines are optional and filled with a
 + * null pointer if not defined.
 + *
 + * @name: Its the name of registered Inline tls device
 + * @dev_list: Inline tls device list
 + * int (*feature)(struct tls_device *device);
 + *     Called to return Inline TLS driver capability
 + *
 + * int (*hash)(struct tls_device *device, struct sock *sk);
 + *     This function sets Inline driver for listen and program
 + *     device specific functioanlity as required
 + *
 + * void (*unhash)(struct tls_device *device, struct sock *sk);
 + *     This function cleans listen state set by Inline TLS driver
 + */
 +struct tls_device {
 +	char name[TLS_DEVICE_NAME_MAX];
 +	struct list_head dev_list;
 +	int  (*feature)(struct tls_device *device);
 +	int  (*hash)(struct tls_device *device, struct sock *sk);
 +	void (*unhash)(struct tls_device *device, struct sock *sk);
 +};
++=======
+ #define __TLS_INC_STATS(net, field)				\
+ 	__SNMP_INC_STATS((net)->mib.tls_statistics, field)
+ #define TLS_INC_STATS(net, field)				\
+ 	SNMP_INC_STATS((net)->mib.tls_statistics, field)
+ #define __TLS_DEC_STATS(net, field)				\
+ 	__SNMP_DEC_STATS((net)->mib.tls_statistics, field)
+ #define TLS_DEC_STATS(net, field)				\
+ 	SNMP_DEC_STATS((net)->mib.tls_statistics, field)
++>>>>>>> d26b698dd3cd (net/tls: add skeleton of MIB statistics)
  
  enum {
  	TLS_BASE,
@@@ -648,10 -615,11 +660,13 @@@ static inline bool tls_offload_tx_resyn
  	return ret;
  }
  
+ int __net_init tls_proc_init(struct net *net);
+ void __net_exit tls_proc_fini(struct net *net);
+ 
  int tls_proccess_cmsg(struct sock *sk, struct msghdr *msg,
  		      unsigned char *record_type);
 +void tls_register_device(struct tls_device *device);
 +void tls_unregister_device(struct tls_device *device);
  int decrypt_skb(struct sock *sk, struct sk_buff *skb,
  		struct scatterlist *sgout);
  struct sk_buff *tls_encrypt_skb(struct sk_buff *skb);
diff --cc net/tls/Makefile
index 4d6b728a67d0,f1ffbfe8968d..000000000000
--- a/net/tls/Makefile
+++ b/net/tls/Makefile
@@@ -2,8 -3,11 +2,12 @@@
  # Makefile for the TLS subsystem.
  #
  
 -CFLAGS_trace.o := -I$(src)
 -
  obj-$(CONFIG_TLS) += tls.o
  
++<<<<<<< HEAD
 +tls-y := tls_main.o tls_sw.o
++=======
+ tls-y := tls_main.o tls_sw.o tls_proc.o trace.o
++>>>>>>> d26b698dd3cd (net/tls: add skeleton of MIB statistics)
  
 -tls-$(CONFIG_TLS_TOE) += tls_toe.o
  tls-$(CONFIG_TLS_DEVICE) += tls_device.o tls_device_fallback.o
diff --cc net/tls/tls_main.c
index f7a147ae7fd3,686eba0df590..000000000000
--- a/net/tls/tls_main.c
+++ b/net/tls/tls_main.c
@@@ -41,7 -41,9 +41,8 @@@
  #include <linux/inetdevice.h>
  #include <linux/inet_diag.h>
  
+ #include <net/snmp.h>
  #include <net/tls.h>
 -#include <net/tls_toe.h>
  
  MODULE_AUTHOR("Mellanox Technologies");
  MODULE_DESCRIPTION("Transport Layer Security Support");
@@@ -885,21 -796,34 +886,52 @@@ static size_t tls_get_info_size(const s
  	return size;
  }
  
++<<<<<<< HEAD
 +void tls_register_device(struct tls_device *device)
 +{
 +	mutex_lock(&device_mutex);
 +	list_add_tail(&device->dev_list, &device_list);
 +	mutex_unlock(&device_mutex);
 +}
 +EXPORT_SYMBOL(tls_register_device);
 +
 +void tls_unregister_device(struct tls_device *device)
 +{
 +	mutex_lock(&device_mutex);
 +	list_del(&device->dev_list);
 +	mutex_unlock(&device_mutex);
 +}
 +EXPORT_SYMBOL(tls_unregister_device);
++=======
+ static int __net_init tls_init_net(struct net *net)
+ {
+ 	int err;
+ 
+ 	net->mib.tls_statistics = alloc_percpu(struct linux_tls_mib);
+ 	if (!net->mib.tls_statistics)
+ 		return -ENOMEM;
+ 
+ 	err = tls_proc_init(net);
+ 	if (err)
+ 		goto err_free_stats;
+ 
+ 	return 0;
+ err_free_stats:
+ 	free_percpu(net->mib.tls_statistics);
+ 	return err;
+ }
+ 
+ static void __net_exit tls_exit_net(struct net *net)
+ {
+ 	tls_proc_fini(net);
+ 	free_percpu(net->mib.tls_statistics);
+ }
+ 
+ static struct pernet_operations tls_proc_ops = {
+ 	.init = tls_init_net,
+ 	.exit = tls_exit_net,
+ };
++>>>>>>> d26b698dd3cd (net/tls: add skeleton of MIB statistics)
  
  static struct tcp_ulp_ops tcp_tls_ulp_ops __read_mostly = {
  	.name			= "tls",
@@@ -912,8 -836,11 +944,16 @@@
  
  static int __init tls_register(void)
  {
++<<<<<<< HEAD
 +	BUILD_BUG_ON(sizeof(union tls_crypto_context) >
 +		     RH_KABI_TLS_CRYPT_CONTEXT_SIZE);
++=======
+ 	int err;
+ 
+ 	err = register_pernet_subsys(&tls_proc_ops);
+ 	if (err)
+ 		return err;
++>>>>>>> d26b698dd3cd (net/tls: add skeleton of MIB statistics)
  
  	tls_sw_proto_ops = inet_stream_ops;
  	tls_sw_proto_ops.splice_read = tls_sw_splice_read;
diff --git a/Documentation/networking/tls.rst b/Documentation/networking/tls.rst
index 5bcbf75e2025..a6ee595630ed 100644
--- a/Documentation/networking/tls.rst
+++ b/Documentation/networking/tls.rst
@@ -213,3 +213,9 @@ A patchset to OpenSSL to use ktls as the record layer is
 of calling send directly after a handshake using gnutls.
 Since it doesn't implement a full record layer, control
 messages are not supported.
+
+Statistics
+==========
+
+TLS implementation exposes the following per-namespace statistics
+(``/proc/net/tls_stat``):
diff --git a/include/net/netns/mib.h b/include/net/netns/mib.h
index 830bdf345b17..b5fdb108d602 100644
--- a/include/net/netns/mib.h
+++ b/include/net/netns/mib.h
@@ -24,6 +24,9 @@ struct netns_mib {
 #ifdef CONFIG_XFRM_STATISTICS
 	DEFINE_SNMP_STAT(struct linux_xfrm_mib, xfrm_statistics);
 #endif
+#if IS_ENABLED(CONFIG_TLS)
+	DEFINE_SNMP_STAT(struct linux_tls_mib, tls_statistics);
+#endif
 };
 
 #endif
diff --git a/include/net/snmp.h b/include/net/snmp.h
index c9228ad7ee91..503c445b99e9 100644
--- a/include/net/snmp.h
+++ b/include/net/snmp.h
@@ -116,6 +116,12 @@ struct linux_xfrm_mib {
 	unsigned long	mibs[LINUX_MIB_XFRMMAX];
 };
 
+/* Linux TLS */
+#define LINUX_MIB_TLSMAX	__LINUX_MIB_TLSMAX
+struct linux_tls_mib {
+	unsigned long	mibs[LINUX_MIB_TLSMAX];
+};
+
 #define DEFINE_SNMP_STAT(type, name)	\
 	__typeof__(type) __percpu *name
 #define DEFINE_SNMP_STAT_ATOMIC(type, name)	\
* Unmerged path include/net/tls.h
diff --git a/include/uapi/linux/snmp.h b/include/uapi/linux/snmp.h
index 0b7605eafbdb..c8d1713c3db2 100644
--- a/include/uapi/linux/snmp.h
+++ b/include/uapi/linux/snmp.h
@@ -322,4 +322,11 @@ enum
 	__LINUX_MIB_XFRMMAX
 };
 
+/* linux TLS mib definitions */
+enum
+{
+	LINUX_MIB_TLSNUM = 0,
+	__LINUX_MIB_TLSMAX
+};
+
 #endif	/* _LINUX_SNMP_H */
* Unmerged path net/tls/Makefile
* Unmerged path net/tls/tls_main.c
diff --git a/net/tls/tls_proc.c b/net/tls/tls_proc.c
new file mode 100644
index 000000000000..4ecc7c35d2f7
--- /dev/null
+++ b/net/tls/tls_proc.c
@@ -0,0 +1,37 @@
+// SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+/* Copyright (C) 2019 Netronome Systems, Inc. */
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <net/snmp.h>
+#include <net/tls.h>
+
+static const struct snmp_mib tls_mib_list[] = {
+	SNMP_MIB_SENTINEL
+};
+
+static int tls_statistics_seq_show(struct seq_file *seq, void *v)
+{
+	unsigned long buf[LINUX_MIB_TLSMAX] = {};
+	struct net *net = seq->private;
+	int i;
+
+	snmp_get_cpu_field_batch(buf, tls_mib_list, net->mib.tls_statistics);
+	for (i = 0; tls_mib_list[i].name; i++)
+		seq_printf(seq, "%-32s\t%lu\n", tls_mib_list[i].name, buf[i]);
+
+	return 0;
+}
+
+int __net_init tls_proc_init(struct net *net)
+{
+	if (!proc_create_net_single("tls_stat", 0444, net->proc_net,
+				    tls_statistics_seq_show, NULL))
+		return -ENOMEM;
+	return 0;
+}
+
+void __net_exit tls_proc_fini(struct net *net)
+{
+	remove_proc_entry("tls_stat", net->proc_net);
+}
