xfrm: esp6: fix the location of the transport header with encapsulation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sabrina Dubroca <sd@queasysnail.net>
commit d5dba1376e2bafec0f4408dc65706c5908964083
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d5dba137.failed

commit 17175d1a27c6 ("xfrm: esp6: fix encapsulation header offset
computation") changed esp6_input_done2 to correctly find the size of
the IPv6 header that precedes the TCP/UDP encapsulation header, but
didn't adjust the final call to skb_set_transport_header, which I
assumed was correct in using skb_network_header_len.

Xiumei Mu reported that when we create xfrm states that include port
numbers in the selector, traffic from the user sockets is dropped. It
turns out that we get a state mismatch in __xfrm_policy_check, because
we end up trying to compare the encapsulation header's ports with the
selector that's based on user traffic ports.

Fixes: 0146dca70b87 ("xfrm: add support for UDPv6 encapsulation of ESP")
Fixes: 26333c37fc28 ("xfrm: add IPv6 support for espintcp")
	Reported-by: Xiumei Mu <xmu@redhat.com>
	Signed-off-by: Sabrina Dubroca <sd@queasysnail.net>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit d5dba1376e2bafec0f4408dc65706c5908964083)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/esp6.c
diff --cc net/ipv6/esp6.c
index 9fa1a7270fe0,52c2f063529f..000000000000
--- a/net/ipv6/esp6.c
+++ b/net/ipv6/esp6.c
@@@ -528,6 -803,67 +528,70 @@@ int esp6_input_done2(struct sk_buff *sk
  	if (unlikely(err < 0))
  		goto out;
  
++<<<<<<< HEAD
++=======
+ 	if (x->encap) {
+ 		const struct ipv6hdr *ip6h = ipv6_hdr(skb);
+ 		int offset = skb_network_offset(skb) + sizeof(*ip6h);
+ 		struct xfrm_encap_tmpl *encap = x->encap;
+ 		u8 nexthdr = ip6h->nexthdr;
+ 		__be16 frag_off, source;
+ 		struct udphdr *uh;
+ 		struct tcphdr *th;
+ 
+ 		offset = ipv6_skip_exthdr(skb, offset, &nexthdr, &frag_off);
+ 		uh = (void *)(skb->data + offset);
+ 		th = (void *)(skb->data + offset);
+ 		hdr_len += offset;
+ 
+ 		switch (x->encap->encap_type) {
+ 		case TCP_ENCAP_ESPINTCP:
+ 			source = th->source;
+ 			break;
+ 		case UDP_ENCAP_ESPINUDP:
+ 		case UDP_ENCAP_ESPINUDP_NON_IKE:
+ 			source = uh->source;
+ 			break;
+ 		default:
+ 			WARN_ON_ONCE(1);
+ 			err = -EINVAL;
+ 			goto out;
+ 		}
+ 
+ 		/*
+ 		 * 1) if the NAT-T peer's IP or port changed then
+ 		 *    advertize the change to the keying daemon.
+ 		 *    This is an inbound SA, so just compare
+ 		 *    SRC ports.
+ 		 */
+ 		if (!ipv6_addr_equal(&ip6h->saddr, &x->props.saddr.in6) ||
+ 		    source != encap->encap_sport) {
+ 			xfrm_address_t ipaddr;
+ 
+ 			memcpy(&ipaddr.a6, &ip6h->saddr.s6_addr, sizeof(ipaddr.a6));
+ 			km_new_mapping(x, &ipaddr, source);
+ 
+ 			/* XXX: perhaps add an extra
+ 			 * policy check here, to see
+ 			 * if we should allow or
+ 			 * reject a packet from a
+ 			 * different source
+ 			 * address/port.
+ 			 */
+ 		}
+ 
+ 		/*
+ 		 * 2) ignore UDP/TCP checksums in case
+ 		 *    of NAT-T in Transport Mode, or
+ 		 *    perform other post-processing fixes
+ 		 *    as per draft-ietf-ipsec-udp-encaps-06,
+ 		 *    section 3.1.2
+ 		 */
+ 		if (x->props.mode == XFRM_MODE_TRANSPORT)
+ 			skb->ip_summed = CHECKSUM_UNNECESSARY;
+ 	}
+ 
++>>>>>>> d5dba1376e2b (xfrm: esp6: fix the location of the transport header with encapsulation)
  	skb_postpull_rcsum(skb, skb_network_header(skb),
  			   skb_network_header_len(skb));
  	skb_pull_rcsum(skb, hlen);
* Unmerged path net/ipv6/esp6.c
