netfilter: flowtable: Use rw sem as flow block lock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paul Blakey <paulb@mellanox.com>
commit 422c032afcf57d5e8109a54912e22ffc53d99068
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/422c032a.failed

Currently flow offload threads are synchronized by the flow block mutex.
Use rw lock instead to increase flow insertion (read) concurrency.

	Signed-off-by: Paul Blakey <paulb@mellanox.com>
	Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 422c032afcf57d5e8109a54912e22ffc53d99068)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_flow_table.h
#	net/netfilter/nf_flow_table_core.c
#	net/netfilter/nf_flow_table_offload.c
diff --cc include/net/netfilter/nf_flow_table.h
index ebceddb778ea,6bf69652f57d..000000000000
--- a/include/net/netfilter/nf_flow_table.h
+++ b/include/net/netfilter/nf_flow_table.h
@@@ -26,8 -72,17 +26,15 @@@ struct nf_flowtable 
  	int				priority;
  	const struct nf_flowtable_type	*type;
  	struct delayed_work		gc_work;
++<<<<<<< HEAD
++=======
+ 	unsigned int			flags;
+ 	struct flow_block		flow_block;
+ 	struct rw_semaphore		flow_block_lock; /* Guards flow_block */
+ 	possible_net_t			net;
++>>>>>>> 422c032afcf5 (netfilter: flowtable: Use rw sem as flow block lock)
  };
  
 -static inline bool nf_flowtable_hw_offload(struct nf_flowtable *flowtable)
 -{
 -	return flowtable->flags & NF_FLOWTABLE_HW_OFFLOAD;
 -}
 -
  enum flow_offload_tuple_dir {
  	FLOW_OFFLOAD_DIR_ORIGINAL = IP_CT_DIR_ORIGINAL,
  	FLOW_OFFLOAD_DIR_REPLY = IP_CT_DIR_REPLY,
diff --cc net/netfilter/nf_flow_table_core.c
index b5916ad46e76,9399bb2df295..000000000000
--- a/net/netfilter/nf_flow_table_core.c
+++ b/net/netfilter/nf_flow_table_core.c
@@@ -362,6 -385,50 +362,53 @@@ static void nf_flow_offload_work_gc(str
  	queue_delayed_work(system_power_efficient_wq, &flow_table->gc_work, HZ);
  }
  
++<<<<<<< HEAD
++=======
+ int nf_flow_table_offload_add_cb(struct nf_flowtable *flow_table,
+ 				 flow_setup_cb_t *cb, void *cb_priv)
+ {
+ 	struct flow_block *block = &flow_table->flow_block;
+ 	struct flow_block_cb *block_cb;
+ 	int err = 0;
+ 
+ 	down_write(&flow_table->flow_block_lock);
+ 	block_cb = flow_block_cb_lookup(block, cb, cb_priv);
+ 	if (block_cb) {
+ 		err = -EEXIST;
+ 		goto unlock;
+ 	}
+ 
+ 	block_cb = flow_block_cb_alloc(cb, cb_priv, cb_priv, NULL);
+ 	if (IS_ERR(block_cb)) {
+ 		err = PTR_ERR(block_cb);
+ 		goto unlock;
+ 	}
+ 
+ 	list_add_tail(&block_cb->list, &block->cb_list);
+ 
+ unlock:
+ 	up_write(&flow_table->flow_block_lock);
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(nf_flow_table_offload_add_cb);
+ 
+ void nf_flow_table_offload_del_cb(struct nf_flowtable *flow_table,
+ 				  flow_setup_cb_t *cb, void *cb_priv)
+ {
+ 	struct flow_block *block = &flow_table->flow_block;
+ 	struct flow_block_cb *block_cb;
+ 
+ 	down_write(&flow_table->flow_block_lock);
+ 	block_cb = flow_block_cb_lookup(block, cb, cb_priv);
+ 	if (block_cb)
+ 		list_del(&block_cb->list);
+ 	else
+ 		WARN_ON(true);
+ 	up_write(&flow_table->flow_block_lock);
+ }
+ EXPORT_SYMBOL_GPL(nf_flow_table_offload_del_cb);
+ 
++>>>>>>> 422c032afcf5 (netfilter: flowtable: Use rw sem as flow block lock)
  static int nf_flow_nat_port_tcp(struct sk_buff *skb, unsigned int thoff,
  				__be16 port, __be16 new_port)
  {
@@@ -483,6 -550,8 +530,11 @@@ int nf_flow_table_init(struct nf_flowta
  	int err;
  
  	INIT_DEFERRABLE_WORK(&flowtable->gc_work, nf_flow_offload_work_gc);
++<<<<<<< HEAD
++=======
+ 	flow_block_init(&flowtable->flow_block);
+ 	init_rwsem(&flowtable->flow_block_lock);
++>>>>>>> 422c032afcf5 (netfilter: flowtable: Use rw sem as flow block lock)
  
  	err = rhashtable_init(&flowtable->rhashtable,
  			      &nf_flow_offload_rhash_params);
* Unmerged path net/netfilter/nf_flow_table_offload.c
* Unmerged path include/net/netfilter/nf_flow_table.h
* Unmerged path net/netfilter/nf_flow_table_core.c
* Unmerged path net/netfilter/nf_flow_table_offload.c
