NFSv4.1: fix handling of backchannel binding in BIND_CONN_TO_SESSION

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Olga Kornievskaia <olga.kornievskaia@gmail.com>
commit dff58530c4ca8ce7ee5a74db431c6e35362cf682
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dff58530.failed

Currently, if the client sends BIND_CONN_TO_SESSION with
NFS4_CDFC4_FORE_OR_BOTH but only gets NFS4_CDFS4_FORE back it ignores
that it wasn't able to enable a backchannel.

To make sure, the client sends BIND_CONN_TO_SESSION as the first
operation on the connections (ie., no other session compounds haven't
been sent before), and if the client's request to bind the backchannel
is not satisfied, then reset the connection and retry.

	Cc: stable@vger.kernel.org
	Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit dff58530c4ca8ce7ee5a74db431c6e35362cf682)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/sunrpc/clnt.h
diff --cc include/linux/sunrpc/clnt.h
index 47d4debc6d94,02e7a5863d28..000000000000
--- a/include/linux/sunrpc/clnt.h
+++ b/include/linux/sunrpc/clnt.h
@@@ -230,5 -242,9 +230,13 @@@ static inline int rpc_reply_expected(st
  		(task->tk_msg.rpc_proc->p_decode != NULL);
  }
  
++<<<<<<< HEAD
 +#endif /* __KERNEL__ */
++=======
+ static inline void rpc_task_close_connection(struct rpc_task *task)
+ {
+ 	if (task->tk_xprt)
+ 		xprt_force_disconnect(task->tk_xprt);
+ }
++>>>>>>> dff58530c4ca (NFSv4.1: fix handling of backchannel binding in BIND_CONN_TO_SESSION)
  #endif /* _LINUX_SUNRPC_CLNT_H */
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index 60f02e0557a2..da35cbb4eb4d 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -7647,6 +7647,7 @@ static void
 nfs4_bind_one_conn_to_session_done(struct rpc_task *task, void *calldata)
 {
 	struct nfs41_bind_conn_to_session_args *args = task->tk_msg.rpc_argp;
+	struct nfs41_bind_conn_to_session_res *res = task->tk_msg.rpc_resp;
 	struct nfs_client *clp = args->client;
 
 	switch (task->tk_status) {
@@ -7655,6 +7656,12 @@ nfs4_bind_one_conn_to_session_done(struct rpc_task *task, void *calldata)
 		nfs4_schedule_session_recovery(clp->cl_session,
 				task->tk_status);
 	}
+	if (args->dir == NFS4_CDFC4_FORE_OR_BOTH &&
+			res->dir != NFS4_CDFS4_BOTH) {
+		rpc_task_close_connection(task);
+		if (args->retries++ < MAX_BIND_CONN_TO_SESSION_RETRIES)
+			rpc_restart_call(task);
+	}
 }
 
 static const struct rpc_call_ops nfs4_bind_one_conn_to_session_ops = {
@@ -7677,6 +7684,7 @@ int nfs4_proc_bind_one_conn_to_session(struct rpc_clnt *clnt,
 	struct nfs41_bind_conn_to_session_args args = {
 		.client = clp,
 		.dir = NFS4_CDFC4_FORE_OR_BOTH,
+		.retries = 0,
 	};
 	struct nfs41_bind_conn_to_session_res res;
 	struct rpc_message msg = {
diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 16ab88dcbadf..8af22bbe696c 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1297,11 +1297,13 @@ struct nfs41_impl_id {
 	struct nfstime4			date;
 };
 
+#define MAX_BIND_CONN_TO_SESSION_RETRIES 3
 struct nfs41_bind_conn_to_session_args {
 	struct nfs_client		*client;
 	struct nfs4_sessionid		sessionid;
 	u32				dir;
 	bool				use_conn_in_rdma_mode;
+	int				retries;
 };
 
 struct nfs41_bind_conn_to_session_res {
* Unmerged path include/linux/sunrpc/clnt.h
