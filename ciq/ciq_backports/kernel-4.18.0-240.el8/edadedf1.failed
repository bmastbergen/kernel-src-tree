tipc: fix incorrect increasing of link window

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Tuong Lien <tuong.t.lien@dektech.com.au>
commit edadedf1c5b4e4404192a0a4c3c0c05e3b7672ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/edadedf1.failed

In commit 16ad3f4022bb ("tipc: introduce variable window congestion
control"), we allow link window to change with the congestion avoidance
algorithm. However, there is a bug that during the slow-start if packet
retransmission occurs, the link will enter the fast-recovery phase, set
its window to the 'ssthresh' which is never less than 300, so the link
window suddenly increases to that limit instead of decreasing.

Consequently, two issues have been observed:

- For broadcast-link: it can leave a gap between the link queues that a
new packet will be inserted and sent before the previous ones, i.e. not
in-order.

- For unicast: the algorithm does not work as expected, the link window
jumps to the slow-start threshold whereas packet retransmission occurs.

This commit fixes the issues by avoiding such the link window increase,
but still decreasing if the 'ssthresh' is lowered.

Fixes: 16ad3f4022bb ("tipc: introduce variable window congestion control")
	Acked-by: Jon Maloy <jmaloy@redhat.com>
	Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit edadedf1c5b4e4404192a0a4c3c0c05e3b7672ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tipc/link.c
diff --cc net/tipc/link.c
index 91be69d1779e,d4675e922a8f..000000000000
--- a/net/tipc/link.c
+++ b/net/tipc/link.c
@@@ -1025,6 -1054,48 +1025,51 @@@ int tipc_link_xmit(struct tipc_link *l
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ static void tipc_link_update_cwin(struct tipc_link *l, int released,
+ 				  bool retransmitted)
+ {
+ 	int bklog_len = skb_queue_len(&l->backlogq);
+ 	struct sk_buff_head *txq = &l->transmq;
+ 	int txq_len = skb_queue_len(txq);
+ 	u16 cwin = l->window;
+ 
+ 	/* Enter fast recovery */
+ 	if (unlikely(retransmitted)) {
+ 		l->ssthresh = max_t(u16, l->window / 2, 300);
+ 		l->window = min_t(u16, l->ssthresh, l->window);
+ 		return;
+ 	}
+ 	/* Enter slow start */
+ 	if (unlikely(!released)) {
+ 		l->ssthresh = max_t(u16, l->window / 2, 300);
+ 		l->window = l->min_win;
+ 		return;
+ 	}
+ 	/* Don't increase window if no pressure on the transmit queue */
+ 	if (txq_len + bklog_len < cwin)
+ 		return;
+ 
+ 	/* Don't increase window if there are holes the transmit queue */
+ 	if (txq_len && l->snd_nxt - buf_seqno(skb_peek(txq)) != txq_len)
+ 		return;
+ 
+ 	l->cong_acks += released;
+ 
+ 	/* Slow start  */
+ 	if (cwin <= l->ssthresh) {
+ 		l->window = min_t(u16, cwin + released, l->max_win);
+ 		return;
+ 	}
+ 	/* Congestion avoidance */
+ 	if (l->cong_acks < cwin)
+ 		return;
+ 	l->window = min_t(u16, ++cwin, l->max_win);
+ 	l->cong_acks = 0;
+ }
+ 
++>>>>>>> edadedf1c5b4 (tipc: fix incorrect increasing of link window)
  static void tipc_link_advance_backlog(struct tipc_link *l,
  				      struct sk_buff_head *xmitq)
  {
* Unmerged path net/tipc/link.c
