cxgb4/chcr: Enable ktls settings at run time

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Rohit Maheshwari <rohitm@chelsio.com>
commit a3ac249a1ab57552cb2a63e70556ee87610a591d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a3ac249a.failed

Current design enables ktls setting from start, which is not
efficient. Now the feature will be enabled when user demands
TLS offload on any interface.

v1->v2:
- taking ULD module refcount till any single connection exists.
- taking rtnl_lock() before clearing tls_devops.

v2->v3:
- cxgb4 is now registering to tlsdev_ops.
- module refcount inc/dec in chcr.
- refcount is only for connections.
- removed new code from cxgb_set_feature().

v3->v4:
- fixed warning message.

	Signed-off-by: Rohit Maheshwari <rohitm@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a3ac249a1ab57552cb2a63e70556ee87610a591d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/chelsio/chcr_core.c
#	drivers/crypto/chelsio/chcr_core.h
#	drivers/crypto/chelsio/chcr_ktls.c
#	drivers/crypto/chelsio/chcr_ktls.h
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c
#	drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
diff --cc drivers/crypto/chelsio/chcr_core.c
index 850a3f4e837b,bd8dac806e7a..000000000000
--- a/drivers/crypto/chelsio/chcr_core.c
+++ b/drivers/crypto/chelsio/chcr_core.c
@@@ -33,8 -33,23 +33,22 @@@ static int cpl_fw6_pld_handler(struct c
  static void *chcr_uld_add(const struct cxgb4_lld_info *lld);
  static int chcr_uld_state_change(void *handle, enum cxgb4_state state);
  
++<<<<<<< HEAD
++=======
+ #if defined(CONFIG_CHELSIO_TLS_DEVICE)
+ static const struct tlsdev_ops chcr_ktls_ops = {
+ 	.tls_dev_add = chcr_ktls_dev_add,
+ 	.tls_dev_del = chcr_ktls_dev_del,
+ };
+ #endif
+ 
+ #ifdef CONFIG_CHELSIO_IPSEC_INLINE
+ static void update_netdev_features(void);
+ #endif /* CONFIG_CHELSIO_IPSEC_INLINE */
+ 
++>>>>>>> a3ac249a1ab5 (cxgb4/chcr: Enable ktls settings at run time)
  static chcr_handler_func work_handlers[NUM_CPL_CMDS] = {
  	[CPL_FW6_PLD] = cpl_fw6_pld_handler,
 -#ifdef CONFIG_CHELSIO_TLS_DEVICE
 -	[CPL_ACT_OPEN_RPL] = chcr_ktls_cpl_act_open_rpl,
 -	[CPL_SET_TCB_RPL] = chcr_ktls_cpl_set_tcb_rpl,
 -#endif
  };
  
  static struct cxgb4_uld_info chcr_uld_info = {
@@@ -45,9 -60,12 +59,16 @@@
  	.add = chcr_uld_add,
  	.state_change = chcr_uld_state_change,
  	.rx_handler = chcr_uld_rx_handler,
 -#if defined(CONFIG_CHELSIO_IPSEC_INLINE) || defined(CONFIG_CHELSIO_TLS_DEVICE)
 +#ifdef CONFIG_CHELSIO_IPSEC_INLINE
  	.tx_handler = chcr_uld_tx_handler,
++<<<<<<< HEAD
 +#endif /* CONFIG_CHELSIO_IPSEC_INLINE */
++=======
+ #endif /* CONFIG_CHELSIO_IPSEC_INLINE || CONFIG_CHELSIO_TLS_DEVICE */
+ #if defined(CONFIG_CHELSIO_TLS_DEVICE)
+ 	.tlsdev_ops = &chcr_ktls_ops,
+ #endif
++>>>>>>> a3ac249a1ab5 (cxgb4/chcr: Enable ktls settings at run time)
  };
  
  static void detach_work_fn(struct work_struct *work)
@@@ -200,10 -217,6 +221,13 @@@ static void *chcr_uld_add(const struct 
  	}
  	u_ctx->lldi = *lld;
  	chcr_dev_init(u_ctx);
++<<<<<<< HEAD
 +#ifdef CONFIG_CHELSIO_IPSEC_INLINE
 +	if (lld->crypto & ULP_CRYPTO_IPSEC_INLINE)
 +		chcr_add_xfrmops(lld);
 +#endif /* CONFIG_CHELSIO_IPSEC_INLINE */
++=======
++>>>>>>> a3ac249a1ab5 (cxgb4/chcr: Enable ktls settings at run time)
  out:
  	return u_ctx;
  }
diff --cc drivers/crypto/chelsio/chcr_core.h
index b41ef1abfe74,67d77abd6775..000000000000
--- a/drivers/crypto/chelsio/chcr_core.h
+++ b/drivers/crypto/chelsio/chcr_core.h
@@@ -223,4 -223,16 +224,19 @@@ int chcr_handle_resp(struct crypto_asyn
  		     int err);
  int chcr_ipsec_xmit(struct sk_buff *skb, struct net_device *dev);
  void chcr_add_xfrmops(const struct cxgb4_lld_info *lld);
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_CHELSIO_TLS_DEVICE
+ int chcr_ktls_cpl_act_open_rpl(struct adapter *adap, unsigned char *input);
+ int chcr_ktls_cpl_set_tcb_rpl(struct adapter *adap, unsigned char *input);
+ int chcr_ktls_xmit(struct sk_buff *skb, struct net_device *dev);
+ extern int chcr_ktls_dev_add(struct net_device *netdev, struct sock *sk,
+ 			     enum tls_offload_ctx_dir direction,
+ 			     struct tls_crypto_info *crypto_info,
+ 			     u32 start_offload_tcp_sn);
+ extern void chcr_ktls_dev_del(struct net_device *netdev,
+ 			      struct tls_context *tls_ctx,
+ 			      enum tls_offload_ctx_dir direction);
+ #endif
++>>>>>>> a3ac249a1ab5 (cxgb4/chcr: Enable ktls settings at run time)
  #endif /* __CHCR_CORE_H__ */
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
index d3322d75bfbf,41315712deb8..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
@@@ -3497,6 -3489,43 +3497,46 @@@ static int chcr_stats_show(struct seq_f
  		   atomic_read(&adap->chcr_stats.tls_pdu_rx));
  	seq_printf(seq, "TLS Keys (DDR) Count: %10u\n",
  		   atomic_read(&adap->chcr_stats.tls_key));
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_CHELSIO_TLS_DEVICE
+ 	seq_puts(seq, "\nChelsio KTLS Crypto Accelerator Stats\n");
+ 	seq_printf(seq, "Tx TLS offload refcount:          %20u\n",
+ 		   refcount_read(&adap->chcr_ktls.ktls_refcount));
+ 	seq_printf(seq, "Tx HW offload contexts added:     %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_ctx));
+ 	seq_printf(seq, "Tx connection created:            %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_connection_open));
+ 	seq_printf(seq, "Tx connection failed:             %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_connection_fail));
+ 	seq_printf(seq, "Tx connection closed:             %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_connection_close));
+ 	seq_printf(seq, "Packets passed for encryption :   %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_encrypted_packets));
+ 	seq_printf(seq, "Bytes passed for encryption :     %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_encrypted_bytes));
+ 	seq_printf(seq, "Tx records send:                  %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_send_records));
+ 	seq_printf(seq, "Tx partial start of records:      %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_start_pkts));
+ 	seq_printf(seq, "Tx partial middle of records:     %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_middle_pkts));
+ 	seq_printf(seq, "Tx partial end of record:         %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_end_pkts));
+ 	seq_printf(seq, "Tx complete records:              %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_complete_pkts));
+ 	seq_printf(seq, "TX trim pkts :                    %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_trimmed_pkts));
+ 	seq_printf(seq, "Tx out of order packets:          %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_ooo));
+ 	seq_printf(seq, "Tx drop pkts before HW offload:   %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_skip_no_sync_data));
+ 	seq_printf(seq, "Tx drop not synced packets:       %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_drop_no_sync_data));
+ 	seq_printf(seq, "Tx drop bypass req:               %20llu\n",
+ 		   atomic64_read(&adap->chcr_stats.ktls_tx_drop_bypass_req));
+ #endif
++>>>>>>> a3ac249a1ab5 (cxgb4/chcr: Enable ktls settings at run time)
  
  	return 0;
  }
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c
index e6f03d67a758,0307e9c69a47..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c
@@@ -663,6 -663,129 +663,132 @@@ static int uld_attach(struct adapter *a
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static bool cxgb4_uld_in_use(struct adapter *adap)
+ {
+ 	const struct tid_info *t = &adap->tids;
+ 
+ 	return (atomic_read(&t->conns_in_use) || t->stids_in_use);
+ }
+ 
+ #ifdef CONFIG_CHELSIO_TLS_DEVICE
+ /* cxgb4_set_ktls_feature: request FW to enable/disable ktls settings.
+  * @adap: adapter info
+  * @enable: 1 to enable / 0 to disable ktls settings.
+  */
+ int cxgb4_set_ktls_feature(struct adapter *adap, bool enable)
+ {
+ 	int ret = 0;
+ 	u32 params =
+ 		FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |
+ 		FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_KTLS_HW) |
+ 		FW_PARAMS_PARAM_Y_V(enable) |
+ 		FW_PARAMS_PARAM_Z_V(FW_PARAMS_PARAM_DEV_KTLS_HW_USER_ENABLE);
+ 
+ 	if (enable) {
+ 		if (!refcount_read(&adap->chcr_ktls.ktls_refcount)) {
+ 			/* At this moment if ULD connection are up means, other
+ 			 * ULD is/are already active, return failure.
+ 			 */
+ 			if (cxgb4_uld_in_use(adap)) {
+ 				dev_warn(adap->pdev_dev,
+ 					 "ULD connections (tid/stid) active. Can't enable kTLS\n");
+ 				return -EINVAL;
+ 			}
+ 			ret = t4_set_params(adap, adap->mbox, adap->pf,
+ 					    0, 1, &params, &params);
+ 			if (ret)
+ 				return ret;
+ 			refcount_set(&adap->chcr_ktls.ktls_refcount, 1);
+ 			pr_info("kTLS has been enabled. Restrictions placed on ULD support\n");
+ 		} else {
+ 			/* ktls settings already up, just increment refcount. */
+ 			refcount_inc(&adap->chcr_ktls.ktls_refcount);
+ 		}
+ 	} else {
+ 		/* return failure if refcount is already 0. */
+ 		if (!refcount_read(&adap->chcr_ktls.ktls_refcount))
+ 			return -EINVAL;
+ 		/* decrement refcount and test, if 0, disable ktls feature,
+ 		 * else return command success.
+ 		 */
+ 		if (refcount_dec_and_test(&adap->chcr_ktls.ktls_refcount)) {
+ 			ret = t4_set_params(adap, adap->mbox, adap->pf,
+ 					    0, 1, &params, &params);
+ 			if (ret)
+ 				return ret;
+ 			pr_info("kTLS is disabled. Restrictions on ULD support removed\n");
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ #endif
+ 
+ static void cxgb4_uld_alloc_resources(struct adapter *adap,
+ 				      enum cxgb4_uld type,
+ 				      const struct cxgb4_uld_info *p)
+ {
+ 	int ret = 0;
+ 
+ 	if ((type == CXGB4_ULD_CRYPTO && !is_pci_uld(adap)) ||
+ 	    (type != CXGB4_ULD_CRYPTO && !is_offload(adap)))
+ 		return;
+ 	if (type == CXGB4_ULD_ISCSIT && is_t4(adap->params.chip))
+ 		return;
+ 	ret = cfg_queues_uld(adap, type, p);
+ 	if (ret)
+ 		goto out;
+ 	ret = setup_sge_queues_uld(adap, type, p->lro);
+ 	if (ret)
+ 		goto free_queues;
+ 	if (adap->flags & CXGB4_USING_MSIX) {
+ 		ret = request_msix_queue_irqs_uld(adap, type);
+ 		if (ret)
+ 			goto free_rxq;
+ 	}
+ 	if (adap->flags & CXGB4_FULL_INIT_DONE)
+ 		enable_rx_uld(adap, type);
+ 	if (adap->uld[type].add)
+ 		goto free_irq;
+ 	ret = setup_sge_txq_uld(adap, type, p);
+ 	if (ret)
+ 		goto free_irq;
+ 	adap->uld[type] = *p;
+ 	ret = uld_attach(adap, type);
+ 	if (ret)
+ 		goto free_txq;
+ 	return;
+ free_txq:
+ 	release_sge_txq_uld(adap, type);
+ free_irq:
+ 	if (adap->flags & CXGB4_FULL_INIT_DONE)
+ 		quiesce_rx_uld(adap, type);
+ 	if (adap->flags & CXGB4_USING_MSIX)
+ 		free_msix_queue_irqs_uld(adap, type);
+ free_rxq:
+ 	free_sge_queues_uld(adap, type);
+ free_queues:
+ 	free_queues_uld(adap, type);
+ out:
+ 	dev_warn(adap->pdev_dev,
+ 		 "ULD registration failed for uld type %d\n", type);
+ }
+ 
+ void cxgb4_uld_enable(struct adapter *adap)
+ {
+ 	struct cxgb4_uld_list *uld_entry;
+ 
+ 	mutex_lock(&uld_mutex);
+ 	list_add_tail(&adap->list_node, &adapter_list);
+ 	list_for_each_entry(uld_entry, &uld_list, list_node)
+ 		cxgb4_uld_alloc_resources(adap, uld_entry->uld_type,
+ 					  &uld_entry->uld_info);
+ 	mutex_unlock(&uld_mutex);
+ }
+ 
++>>>>>>> a3ac249a1ab5 (cxgb4/chcr: Enable ktls settings at run time)
  /* cxgb4_register_uld - register an upper-layer driver
   * @type: the ULD type
   * @p: the ULD methods
@@@ -751,6 -841,13 +877,16 @@@ int cxgb4_unregister_uld(enum cxgb4_ul
  			continue;
  
  		cxgb4_shutdown_uld_adapter(adap, type);
++<<<<<<< HEAD
++=======
+ 	}
+ 
+ 	list_for_each_entry_safe(uld_entry, tmp, &uld_list, list_node) {
+ 		if (uld_entry->uld_type == type) {
+ 			list_del(&uld_entry->list_node);
+ 			kfree(uld_entry);
+ 		}
++>>>>>>> a3ac249a1ab5 (cxgb4/chcr: Enable ktls settings at run time)
  	}
  	mutex_unlock(&uld_mutex);
  
diff --cc drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
index accad1101ad1,0a326c054707..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
@@@ -1205,6 -1205,7 +1205,10 @@@ enum fw_caps_config_crypto 
  	FW_CAPS_CONFIG_CRYPTO_LOOKASIDE = 0x00000001,
  	FW_CAPS_CONFIG_TLS_INLINE = 0x00000002,
  	FW_CAPS_CONFIG_IPSEC_INLINE = 0x00000004,
++<<<<<<< HEAD
++=======
+ 	FW_CAPS_CONFIG_TLS_HW = 0x00000008,
++>>>>>>> a3ac249a1ab5 (cxgb4/chcr: Enable ktls settings at run time)
  };
  
  enum fw_caps_config_fcoe {
@@@ -1328,6 -1329,7 +1332,10 @@@ enum fw_params_param_dev 
  	FW_PARAMS_PARAM_DEV_DBQ_TIMERTICK = 0x2A,
  	FW_PARAMS_PARAM_DEV_NUM_TM_CLASS = 0x2B,
  	FW_PARAMS_PARAM_DEV_FILTER = 0x2E,
++<<<<<<< HEAD
++=======
+ 	FW_PARAMS_PARAM_DEV_KTLS_HW = 0x31,
++>>>>>>> a3ac249a1ab5 (cxgb4/chcr: Enable ktls settings at run time)
  };
  
  /*
* Unmerged path drivers/crypto/chelsio/chcr_ktls.c
* Unmerged path drivers/crypto/chelsio/chcr_ktls.h
* Unmerged path drivers/crypto/chelsio/chcr_core.c
* Unmerged path drivers/crypto/chelsio/chcr_core.h
* Unmerged path drivers/crypto/chelsio/chcr_ktls.c
* Unmerged path drivers/crypto/chelsio/chcr_ktls.h
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
index 974f7b0b4991..6aa77d39b32b 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4.h
@@ -1092,6 +1092,7 @@ struct adapter {
 
 	/* TC u32 offload */
 	struct cxgb4_tc_u32_table *tc_u32;
+	struct chcr_ktls chcr_ktls;
 	struct chcr_stats_debug chcr_stats;
 
 	/* TC flower offload */
@@ -2054,4 +2055,7 @@ int cxgb_open(struct net_device *dev);
 int cxgb_close(struct net_device *dev);
 void cxgb4_enable_rx(struct adapter *adap, struct sge_rspq *q);
 void cxgb4_quiesce_rx(struct sge_rspq *q);
+#ifdef CONFIG_CHELSIO_TLS_DEVICE
+int cxgb4_set_ktls_feature(struct adapter *adap, bool enable);
+#endif
 #endif /* __CXGB4_H__ */
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_debugfs.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index 6fb23dd56a69..55e92e371211 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@ -66,6 +66,9 @@
 #include <linux/crash_dump.h>
 #include <net/udp_tunnel.h>
 #include <net/xfrm.h>
+#if defined(CONFIG_CHELSIO_TLS_DEVICE)
+#include <net/tls.h>
+#endif
 
 #include "cxgb4.h"
 #include "cxgb4_filter.h"
@@ -6072,6 +6075,79 @@ static int cxgb4_iov_configure(struct pci_dev *pdev, int num_vfs)
 }
 #endif /* CONFIG_PCI_IOV */
 
+#if defined(CONFIG_CHELSIO_TLS_DEVICE)
+
+static int cxgb4_ktls_dev_add(struct net_device *netdev, struct sock *sk,
+			      enum tls_offload_ctx_dir direction,
+			      struct tls_crypto_info *crypto_info,
+			      u32 tcp_sn)
+{
+	struct adapter *adap = netdev2adap(netdev);
+	int ret = 0;
+
+	mutex_lock(&uld_mutex);
+	if (!adap->uld[CXGB4_ULD_CRYPTO].handle) {
+		dev_err(adap->pdev_dev, "chcr driver is not loaded\n");
+		ret = -EOPNOTSUPP;
+		goto out_unlock;
+	}
+
+	if (!adap->uld[CXGB4_ULD_CRYPTO].tlsdev_ops) {
+		dev_err(adap->pdev_dev,
+			"chcr driver has no registered tlsdev_ops()\n");
+		ret = -EOPNOTSUPP;
+		goto out_unlock;
+	}
+
+	ret = cxgb4_set_ktls_feature(adap, FW_PARAMS_PARAM_DEV_KTLS_HW_ENABLE);
+	if (ret)
+		goto out_unlock;
+
+	ret = adap->uld[CXGB4_ULD_CRYPTO].tlsdev_ops->tls_dev_add(netdev, sk,
+								  direction,
+								  crypto_info,
+								  tcp_sn);
+	/* if there is a failure, clear the refcount */
+	if (ret)
+		cxgb4_set_ktls_feature(adap,
+				       FW_PARAMS_PARAM_DEV_KTLS_HW_DISABLE);
+out_unlock:
+	mutex_unlock(&uld_mutex);
+	return ret;
+}
+
+static void cxgb4_ktls_dev_del(struct net_device *netdev,
+			       struct tls_context *tls_ctx,
+			       enum tls_offload_ctx_dir direction)
+{
+	struct adapter *adap = netdev2adap(netdev);
+
+	mutex_lock(&uld_mutex);
+	if (!adap->uld[CXGB4_ULD_CRYPTO].handle) {
+		dev_err(adap->pdev_dev, "chcr driver is not loaded\n");
+		goto out_unlock;
+	}
+
+	if (!adap->uld[CXGB4_ULD_CRYPTO].tlsdev_ops) {
+		dev_err(adap->pdev_dev,
+			"chcr driver has no registered tlsdev_ops\n");
+		goto out_unlock;
+	}
+
+	adap->uld[CXGB4_ULD_CRYPTO].tlsdev_ops->tls_dev_del(netdev, tls_ctx,
+							    direction);
+	cxgb4_set_ktls_feature(adap, FW_PARAMS_PARAM_DEV_KTLS_HW_DISABLE);
+
+out_unlock:
+	mutex_unlock(&uld_mutex);
+}
+
+static const struct tlsdev_ops cxgb4_ktls_ops = {
+	.tls_dev_add = cxgb4_ktls_dev_add,
+	.tls_dev_del = cxgb4_ktls_dev_del,
+};
+#endif /* CONFIG_CHELSIO_TLS_DEVICE */
+
 static int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	struct net_device *netdev;
@@ -6325,7 +6401,14 @@ static int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 			netdev->hw_features |= NETIF_F_HIGHDMA;
 		netdev->features |= netdev->hw_features;
 		netdev->vlan_features = netdev->features & VLAN_FEAT;
-
+#if defined(CONFIG_CHELSIO_TLS_DEVICE)
+		if (pi->adapter->params.crypto & FW_CAPS_CONFIG_TLS_HW) {
+			netdev->hw_features |= NETIF_F_HW_TLS_TX;
+			netdev->tlsdev_ops = &cxgb4_ktls_ops;
+			/* initialize the refcount */
+			refcount_set(&pi->adapter->chcr_ktls.ktls_refcount, 0);
+		}
+#endif
 		netdev->priv_flags |= IFF_UNICAST_FLT;
 
 		/* MTU range: 81 - 9600 */
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h
index 6f922a133729..ddd2a65f3200 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.h
@@ -268,6 +268,10 @@ struct filter_ctx {
 	u32 tid;			/* to store tid */
 };
 
+struct chcr_ktls {
+	refcount_t ktls_refcount;
+};
+
 struct ch_filter_specification;
 
 int cxgb4_get_free_ftid(struct net_device *dev, u8 family, bool hash_en,
@@ -443,6 +447,9 @@ struct cxgb4_uld_info {
 			      struct napi_struct *napi);
 	void (*lro_flush)(struct t4_lro_mgr *);
 	int (*tx_handler)(struct sk_buff *skb, struct net_device *dev);
+#if IS_ENABLED(CONFIG_TLS_DEVICE)
+	const struct tlsdev_ops *tlsdev_ops;
+#endif
 };
 
 void cxgb4_register_uld(enum cxgb4_uld type, const struct cxgb4_uld_info *p);
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/t4fw_api.h
