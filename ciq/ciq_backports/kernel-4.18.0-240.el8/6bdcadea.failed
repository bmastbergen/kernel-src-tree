gfs2: Minor gfs2_lookup_by_inum cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 6bdcadea75768bbd1cd8f6f13011978e1e19a53b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6bdcadea.failed

Use a zero no_formal_ino instead of a NULL pointer to indicate that any inode
generation number will qualify: a valid inode never has a zero no_formal_ino.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 6bdcadea75768bbd1cd8f6f13011978e1e19a53b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index 76c32d90eaaf,b6078b0e74b9..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -682,7 -828,22 +682,26 @@@ static void delete_work_func(struct wor
  	if (test_bit(GLF_INODE_CREATING, &gl->gl_flags))
  		goto out;
  
++<<<<<<< HEAD
 +	inode = gfs2_lookup_by_inum(sdp, no_addr, NULL, GFS2_BLKST_UNLINKED);
++=======
+ 	if (test_bit(GLF_DEMOTE, &gl->gl_flags)) {
+ 		/*
+ 		 * If we can evict the inode, give the remote node trying to
+ 		 * delete the inode some time before verifying that the delete
+ 		 * has happened.  Otherwise, if we cause contention on the inode glock
+ 		 * immediately, the remote node will think that we still have
+ 		 * the inode in use, and so it will give up waiting.
+ 		 */
+ 		if (gfs2_try_evict(gl)) {
+ 			if (gfs2_queue_delete_work(gl, 5 * HZ))
+ 				return;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	inode = gfs2_lookup_by_inum(sdp, no_addr, 0, GFS2_BLKST_UNLINKED);
++>>>>>>> 6bdcadea7576 (gfs2: Minor gfs2_lookup_by_inum cleanup)
  	if (!IS_ERR_OR_NULL(inode)) {
  		d_prune_aliases(inode);
  		iput(inode);
diff --git a/fs/gfs2/export.c b/fs/gfs2/export.c
index a332f3cd925e..6745948335c9 100644
--- a/fs/gfs2/export.c
+++ b/fs/gfs2/export.c
@@ -137,7 +137,9 @@ static struct dentry *gfs2_get_dentry(struct super_block *sb,
 	struct gfs2_sbd *sdp = sb->s_fs_info;
 	struct inode *inode;
 
-	inode = gfs2_lookup_by_inum(sdp, inum->no_addr, &inum->no_formal_ino,
+	if (!inum->no_formal_ino)
+		return ERR_PTR(-ESTALE);
+	inode = gfs2_lookup_by_inum(sdp, inum->no_addr, inum->no_formal_ino,
 				    GFS2_BLKST_DINODE);
 	if (IS_ERR(inode))
 		return ERR_CAST(inode);
* Unmerged path fs/gfs2/glock.c
diff --git a/fs/gfs2/inode.c b/fs/gfs2/inode.c
index b0d12e170499..73dc20670f52 100644
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@ -209,8 +209,15 @@ struct inode *gfs2_inode_lookup(struct super_block *sb, unsigned int type,
 	return ERR_PTR(error);
 }
 
+/**
+ * gfs2_lookup_by_inum - look up an inode by inode number
+ * @sdp: The super block
+ * @no_addr: The inode number
+ * @no_formal_ino: The inode generation number (0 for any)
+ * @blktype: Requested block type (see gfs2_inode_lookup)
+ */
 struct inode *gfs2_lookup_by_inum(struct gfs2_sbd *sdp, u64 no_addr,
-				  u64 *no_formal_ino, unsigned int blktype)
+				  u64 no_formal_ino, unsigned int blktype)
 {
 	struct super_block *sb = sdp->sd_vfs;
 	struct inode *inode;
@@ -223,7 +230,7 @@ struct inode *gfs2_lookup_by_inum(struct gfs2_sbd *sdp, u64 no_addr,
 	/* Two extra checks for NFS only */
 	if (no_formal_ino) {
 		error = -ESTALE;
-		if (GFS2_I(inode)->i_no_formal_ino != *no_formal_ino)
+		if (GFS2_I(inode)->i_no_formal_ino != no_formal_ino)
 			goto fail_iput;
 
 		error = -EIO;
diff --git a/fs/gfs2/inode.h b/fs/gfs2/inode.h
index b5b6341a4f5c..39b30ae9d8b2 100644
--- a/fs/gfs2/inode.h
+++ b/fs/gfs2/inode.h
@@ -97,7 +97,7 @@ extern struct inode *gfs2_inode_lookup(struct super_block *sb, unsigned type,
 				       u64 no_addr, u64 no_formal_ino,
 				       unsigned int blktype);
 extern struct inode *gfs2_lookup_by_inum(struct gfs2_sbd *sdp, u64 no_addr,
-					 u64 *no_formal_ino,
+					 u64 no_formal_ino,
 					 unsigned int blktype);
 
 extern int gfs2_inode_refresh(struct gfs2_inode *ip);
