mm/compaction.c: clear total_{migrate,free}_scanned before scanning a new zone

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [mm] mm/compaction.c: clear total_{migrate, free}_scanned before scanning a new zone (Rafael Aquini) [1809698]
Rebuild_FUZZ: 99.36%
commit-author Yafang Shao <laoar.shao@gmail.com>
commit a94b525241c0fff3598809131d7cfcfe1d572d8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a94b5252.failed

total_{migrate,free}_scanned will be added to COMPACTMIGRATE_SCANNED and
COMPACTFREE_SCANNED in compact_zone().  We should clear them before
scanning a new zone.  In the proc triggered compaction, we forgot clearing
them.

[laoar.shao@gmail.com: introduce a helper compact_zone_counters_init()]
  Link: http://lkml.kernel.org/r/1563869295-25748-1-git-send-email-laoar.shao@gmail.com
[akpm@linux-foundation.org: expand compact_zone_counters_init() into its single callsite, per mhocko]
[vbabka@suse.cz: squash compact_zone() list_head init as well]
  Link: http://lkml.kernel.org/r/1fb6f7da-f776-9e42-22f8-bbb79b030b98@suse.cz
[akpm@linux-foundation.org: kcompactd_do_work(): avoid unnecessary initialization of cc.zone]
Link: http://lkml.kernel.org/r/1563789275-9639-1-git-send-email-laoar.shao@gmail.com
Fixes: 7f354a548d1c ("mm, compaction: add vmstats for kcompactd work")
	Signed-off-by: Yafang Shao <laoar.shao@gmail.com>
	Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
	Reviewed-by: Vlastimil Babka <vbabka@suse.cz>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Yafang Shao <shaoyafang@didiglobal.com>
	Cc: Mel Gorman <mgorman@techsingularity.net>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit a94b525241c0fff3598809131d7cfcfe1d572d8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/compaction.c
diff --cc mm/compaction.c
index 44adbfa073b3,d99d59412c75..000000000000
--- a/mm/compaction.c
+++ b/mm/compaction.c
@@@ -1534,15 -2068,29 +1534,26 @@@ bool compaction_zonelist_suitable(struc
  	return false;
  }
  
 -static enum compact_result
 -compact_zone(struct compact_control *cc, struct capture_control *capc)
 +static enum compact_result compact_zone(struct zone *zone, struct compact_control *cc)
  {
  	enum compact_result ret;
 -	unsigned long start_pfn = cc->zone->zone_start_pfn;
 -	unsigned long end_pfn = zone_end_pfn(cc->zone);
 -	unsigned long last_migrated_pfn;
 +	unsigned long start_pfn = zone->zone_start_pfn;
 +	unsigned long end_pfn = zone_end_pfn(zone);
  	const bool sync = cc->mode != MIGRATE_ASYNC;
 -	bool update_cached;
  
+ 	/*
+ 	 * These counters track activities during zone compaction.  Initialize
+ 	 * them before compacting a new zone.
+ 	 */
+ 	cc->total_migrate_scanned = 0;
+ 	cc->total_free_scanned = 0;
+ 	cc->nr_migratepages = 0;
+ 	cc->nr_freepages = 0;
+ 	INIT_LIST_HEAD(&cc->freepages);
+ 	INIT_LIST_HEAD(&cc->migratepages);
+ 
  	cc->migratetype = gfpflags_to_migratetype(cc->gfp_mask);
 -	ret = compaction_suitable(cc->zone, cc->order, cc->alloc_flags,
 +	ret = compaction_suitable(zone, cc->order, cc->alloc_flags,
  							cc->classzone_idx);
  	/* Compaction is likely to fail */
  	if (ret == COMPACT_SUCCESS || ret == COMPACT_SKIPPED)
@@@ -1704,11 -2292,8 +1715,7 @@@ static enum compact_result compact_zone
  {
  	enum compact_result ret;
  	struct compact_control cc = {
- 		.nr_freepages = 0,
- 		.nr_migratepages = 0,
- 		.total_migrate_scanned = 0,
- 		.total_free_scanned = 0,
  		.order = order,
 -		.search_order = order,
  		.gfp_mask = gfp_mask,
  		.zone = zone,
  		.mode = (prio == COMPACT_PRIO_ASYNC) ?
@@@ -1720,10 -2305,15 +1727,20 @@@
  		.ignore_skip_hint = (prio == MIN_COMPACT_PRIORITY),
  		.ignore_block_suitable = (prio == MIN_COMPACT_PRIORITY)
  	};
++<<<<<<< HEAD
 +	INIT_LIST_HEAD(&cc.freepages);
 +	INIT_LIST_HEAD(&cc.migratepages);
++=======
+ 	struct capture_control capc = {
+ 		.cc = &cc,
+ 		.page = NULL,
+ 	};
+ 
+ 	if (capture)
+ 		current->capture_control = &capc;
++>>>>>>> a94b525241c0 (mm/compaction.c: clear total_{migrate,free}_scanned before scanning a new zone)
  
 -	ret = compact_zone(&cc, &capc);
 +	ret = compact_zone(zone, &cc);
  
  	VM_BUG_ON(!list_empty(&cc.freepages));
  	VM_BUG_ON(!list_empty(&cc.migratepages));
@@@ -1835,13 -2426,9 +1850,9 @@@ static void compact_node(int nid
  		if (!populated_zone(zone))
  			continue;
  
- 		cc.nr_freepages = 0;
- 		cc.nr_migratepages = 0;
  		cc.zone = zone;
- 		INIT_LIST_HEAD(&cc.freepages);
- 		INIT_LIST_HEAD(&cc.migratepages);
  
 -		compact_zone(&cc, NULL);
 +		compact_zone(zone, &cc);
  
  		VM_BUG_ON(!list_empty(&cc.freepages));
  		VM_BUG_ON(!list_empty(&cc.migratepages));
@@@ -1948,8 -2527,7 +1959,12 @@@ static void kcompactd_do_work(pg_data_
  	struct zone *zone;
  	struct compact_control cc = {
  		.order = pgdat->kcompactd_max_order,
++<<<<<<< HEAD
 +		.total_migrate_scanned = 0,
 +		.total_free_scanned = 0,
++=======
+ 		.search_order = pgdat->kcompactd_max_order,
++>>>>>>> a94b525241c0 (mm/compaction.c: clear total_{migrate,free}_scanned before scanning a new zone)
  		.classzone_idx = pgdat->kcompactd_classzone_idx,
  		.mode = MIGRATE_SYNC_LIGHT,
  		.ignore_skip_hint = false,
@@@ -1973,17 -2551,11 +1988,15 @@@
  							COMPACT_CONTINUE)
  			continue;
  
- 		cc.nr_freepages = 0;
- 		cc.nr_migratepages = 0;
- 		cc.total_migrate_scanned = 0;
- 		cc.total_free_scanned = 0;
- 		cc.zone = zone;
- 		INIT_LIST_HEAD(&cc.freepages);
- 		INIT_LIST_HEAD(&cc.migratepages);
- 
  		if (kthread_should_stop())
  			return;
++<<<<<<< HEAD
 +		status = compact_zone(zone, &cc);
++=======
+ 
+ 		cc.zone = zone;
+ 		status = compact_zone(&cc, NULL);
++>>>>>>> a94b525241c0 (mm/compaction.c: clear total_{migrate,free}_scanned before scanning a new zone)
  
  		if (status == COMPACT_SUCCESS) {
  			compaction_defer_reset(zone, cc.order, false);
* Unmerged path mm/compaction.c
