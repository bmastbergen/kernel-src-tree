net: phy: sfp-bus.c: get rid of docs warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
commit 6497ca07f5e91131c6c05e4564d7f98a780aa02b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6497ca07.failed

The indentation for the returned values are weird, causing those
warnings:

	./drivers/net/phy/sfp-bus.c:579: WARNING: Unexpected indentation.
	./drivers/net/phy/sfp-bus.c:619: WARNING: Unexpected indentation.

Use a list and change the identation for it to be properly
parsed by the documentation toolchain.

	Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6497ca07f5e91131c6c05e4564d7f98a780aa02b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/sfp-bus.c
diff --cc drivers/net/phy/sfp-bus.c
index 7cf07411130e,6900c68260e0..000000000000
--- a/drivers/net/phy/sfp-bus.c
+++ b/drivers/net/phy/sfp-bus.c
@@@ -514,64 -565,115 +514,121 @@@ static void sfp_upstream_clear(struct s
  }
  
  /**
++<<<<<<< HEAD
 + * sfp_register_upstream() - Register the neighbouring device
 + * @fwnode: firmware node for the SFP bus
++=======
+  * sfp_bus_find_fwnode() - parse and locate the SFP bus from fwnode
+  * @fwnode: firmware node for the parent device (MAC or PHY)
+  *
+  * Parse the parent device's firmware node for a SFP bus, and locate
+  * the sfp_bus structure, incrementing its reference count.  This must
+  * be put via sfp_bus_put() when done.
+  *
+  * Returns:
+  * 	    - on success, a pointer to the sfp_bus structure,
+  *	    - %NULL if no SFP is specified,
+  * 	    - on failure, an error pointer value:
+  *
+  * 	      - corresponding to the errors detailed for
+  * 	        fwnode_property_get_reference_args().
+  * 	      - %-ENOMEM if we failed to allocate the bus.
+  *	      - an error from the upstream's connect_phy() method.
+  */
+ struct sfp_bus *sfp_bus_find_fwnode(struct fwnode_handle *fwnode)
+ {
+ 	struct fwnode_reference_args ref;
+ 	struct sfp_bus *bus;
+ 	int ret;
+ 
+ 	ret = fwnode_property_get_reference_args(fwnode, "sfp", NULL,
+ 						 0, 0, &ref);
+ 	if (ret == -ENOENT)
+ 		return NULL;
+ 	else if (ret < 0)
+ 		return ERR_PTR(ret);
+ 
+ 	bus = sfp_bus_get(ref.fwnode);
+ 	fwnode_handle_put(ref.fwnode);
+ 	if (!bus)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	return bus;
+ }
+ EXPORT_SYMBOL_GPL(sfp_bus_find_fwnode);
+ 
+ /**
+  * sfp_bus_add_upstream() - parse and register the neighbouring device
+  * @bus: the &struct sfp_bus found via sfp_bus_find_fwnode()
++>>>>>>> 6497ca07f5e9 (net: phy: sfp-bus.c: get rid of docs warnings)
   * @upstream: the upstream private data
   * @ops: the upstream's &struct sfp_upstream_ops
   *
 - * Add upstream driver for the SFP bus, and if the bus is complete, register
 - * the SFP bus using sfp_register_upstream().  This takes a reference on the
 - * bus, so it is safe to put the bus after this call.
 + * Register the upstream device (eg, PHY) with the SFP bus. MAC drivers
 + * should use phylink, which will call this function for them. Returns
 + * a pointer to the allocated &struct sfp_bus.
   *
++<<<<<<< HEAD
 + * On error, returns %NULL.
++=======
+  * Returns:
+  * 	    - on success, a pointer to the sfp_bus structure,
+  *	    - %NULL if no SFP is specified,
+  * 	    - on failure, an error pointer value:
+  *
+  * 	      - corresponding to the errors detailed for
+  * 	        fwnode_property_get_reference_args().
+  * 	      - %-ENOMEM if we failed to allocate the bus.
+  *	      - an error from the upstream's connect_phy() method.
++>>>>>>> 6497ca07f5e9 (net: phy: sfp-bus.c: get rid of docs warnings)
   */
 -int sfp_bus_add_upstream(struct sfp_bus *bus, void *upstream,
 -			 const struct sfp_upstream_ops *ops)
 +struct sfp_bus *sfp_register_upstream(struct fwnode_handle *fwnode,
 +				      void *upstream,
 +				      const struct sfp_upstream_ops *ops)
  {
 -	int ret;
 +	struct sfp_bus *bus = sfp_bus_get(fwnode);
 +	int ret = 0;
  
 -	/* If no bus, return success */
 -	if (!bus)
 -		return 0;
 +	if (bus) {
 +		rtnl_lock();
 +		bus->upstream_ops = ops;
 +		bus->upstream = upstream;
  
 -	rtnl_lock();
 -	kref_get(&bus->kref);
 -	bus->upstream_ops = ops;
 -	bus->upstream = upstream;
 -
 -	if (bus->sfp) {
 -		ret = sfp_register_bus(bus);
 -		if (ret)
 -			sfp_upstream_clear(bus);
 -	} else {
 -		ret = 0;
 +		if (bus->sfp) {
 +			ret = sfp_register_bus(bus);
 +			if (ret)
 +				sfp_upstream_clear(bus);
 +		}
 +		rtnl_unlock();
  	}
 -	rtnl_unlock();
  
 -	if (ret)
 +	if (ret) {
  		sfp_bus_put(bus);
 +		bus = NULL;
 +	}
  
 -	return ret;
 +	return bus;
  }
 -EXPORT_SYMBOL_GPL(sfp_bus_add_upstream);
 +EXPORT_SYMBOL_GPL(sfp_register_upstream);
  
  /**
 - * sfp_bus_del_upstream() - Delete a sfp bus
 + * sfp_unregister_upstream() - Unregister sfp bus
   * @bus: a pointer to the &struct sfp_bus structure for the sfp module
   *
 - * Delete a previously registered upstream connection for the SFP
 - * module. @bus should have been added by sfp_bus_add_upstream().
 + * Unregister a previously registered upstream connection for the SFP
 + * module. @bus is returned from sfp_register_upstream().
   */
 -void sfp_bus_del_upstream(struct sfp_bus *bus)
 +void sfp_unregister_upstream(struct sfp_bus *bus)
  {
 -	if (bus) {
 -		rtnl_lock();
 -		if (bus->sfp)
 -			sfp_unregister_bus(bus);
 -		sfp_upstream_clear(bus);
 -		rtnl_unlock();
 +	rtnl_lock();
 +	if (bus->sfp)
 +		sfp_unregister_bus(bus);
 +	sfp_upstream_clear(bus);
 +	rtnl_unlock();
  
 -		sfp_bus_put(bus);
 -	}
 +	sfp_bus_put(bus);
  }
 -EXPORT_SYMBOL_GPL(sfp_bus_del_upstream);
 +EXPORT_SYMBOL_GPL(sfp_unregister_upstream);
  
  /* Socket driver entry points */
  int sfp_add_phy(struct sfp_bus *bus, struct phy_device *phydev)
* Unmerged path drivers/net/phy/sfp-bus.c
