net/mlx5: E-switch, Legacy introduce and use per vport acl tables APIs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Parav Pandit <parav@mellanox.com>
commit f5d0c01d65adba2b898836894d200e85c8a8def3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f5d0c01d.failed

Introduce and use per vport ACL tables creation and destroy APIs, so that
subsequently patch can use them during enabling/disabling a vport in
unified way for legacy vs offloads mode.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit f5d0c01d65adba2b898836894d200e85c8a8def3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 7ecf89103bc8,47555e272dda..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1654,15 -1663,9 +1654,9 @@@ static void esw_apply_vport_conf(struc
  		SET_VLAN_STRIP | SET_VLAN_INSERT : 0;
  	modify_esw_vport_cvlan(esw->dev, vport_num, vport->info.vlan, vport->info.qos,
  			       flags);
- 
- 	/* Only legacy mode needs ACLs */
- 	if (esw->mode == MLX5_ESWITCH_LEGACY) {
- 		esw_vport_ingress_config(esw, vport);
- 		esw_vport_egress_config(esw, vport);
- 	}
  }
  
 -static void esw_legacy_vport_create_drop_counters(struct mlx5_vport *vport)
 +static void esw_vport_create_drop_counters(struct mlx5_vport *vport)
  {
  	struct mlx5_core_dev *dev = vport->dev;
  
@@@ -1691,16 -1694,65 +1685,70 @@@ static void esw_vport_destroy_drop_coun
  {
  	struct mlx5_core_dev *dev = vport->dev;
  
 -	if (vport->ingress.legacy.drop_counter)
 -		mlx5_fc_destroy(dev, vport->ingress.legacy.drop_counter);
 -	if (vport->egress.legacy.drop_counter)
 -		mlx5_fc_destroy(dev, vport->egress.legacy.drop_counter);
 +	if (vport->ingress.drop_counter)
 +		mlx5_fc_destroy(dev, vport->ingress.drop_counter);
 +	if (vport->egress.drop_counter)
 +		mlx5_fc_destroy(dev, vport->egress.drop_counter);
  }
  
++<<<<<<< HEAD
 +static void esw_enable_vport(struct mlx5_eswitch *esw, struct mlx5_vport *vport,
 +			     enum mlx5_eswitch_vport_event enabled_events)
++=======
+ static int esw_vport_create_legacy_acl_tables(struct mlx5_eswitch *esw,
+ 					      struct mlx5_vport *vport)
+ {
+ 	int ret;
+ 
+ 	/* Only non manager vports need ACL in legacy mode */
+ 	if (mlx5_esw_is_manager_vport(esw, vport->vport))
+ 		return 0;
+ 
+ 	ret = esw_vport_ingress_config(esw, vport);
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = esw_vport_egress_config(esw, vport);
+ 	if (ret)
+ 		esw_vport_disable_ingress_acl(esw, vport);
+ 
+ 	return ret;
+ }
+ 
+ static int esw_vport_setup_acl(struct mlx5_eswitch *esw,
+ 			       struct mlx5_vport *vport)
+ {
+ 	if (esw->mode == MLX5_ESWITCH_LEGACY)
+ 		return esw_vport_create_legacy_acl_tables(esw, vport);
+ 
+ 	return 0;
+ }
+ 
+ static void esw_vport_destroy_legacy_acl_tables(struct mlx5_eswitch *esw,
+ 						struct mlx5_vport *vport)
+ 
+ {
+ 	if (mlx5_esw_is_manager_vport(esw, vport->vport))
+ 		return;
+ 
+ 	esw_vport_disable_egress_acl(esw, vport);
+ 	esw_vport_disable_ingress_acl(esw, vport);
+ 	esw_legacy_vport_destroy_drop_counters(vport);
+ }
+ 
+ static void esw_vport_cleanup_acl(struct mlx5_eswitch *esw,
+ 				  struct mlx5_vport *vport)
+ {
+ 	if (esw->mode == MLX5_ESWITCH_LEGACY)
+ 		esw_vport_destroy_legacy_acl_tables(esw, vport);
+ }
+ 
+ static int esw_enable_vport(struct mlx5_eswitch *esw, struct mlx5_vport *vport,
+ 			    enum mlx5_eswitch_vport_event enabled_events)
++>>>>>>> f5d0c01d65ad (net/mlx5: E-switch, Legacy introduce and use per vport acl tables APIs)
  {
  	u16 vport_num = vport->vport;
+ 	int ret;
  
  	mutex_lock(&esw->state_lock);
  	WARN_ON(vport->enabled);
@@@ -1734,7 -1791,9 +1786,12 @@@
  
  	esw->enabled_vports++;
  	esw_debug(esw->dev, "Enabled VPORT(%d)\n", vport_num);
+ done:
  	mutex_unlock(&esw->state_lock);
++<<<<<<< HEAD
++=======
+ 	return ret;
++>>>>>>> f5d0c01d65ad (net/mlx5: E-switch, Legacy introduce and use per vport acl tables APIs)
  }
  
  static void esw_disable_vport(struct mlx5_eswitch *esw,
@@@ -1759,16 -1818,15 +1816,27 @@@
  	esw_vport_change_handle_locked(vport);
  	vport->enabled_events = 0;
  	esw_vport_disable_qos(esw, vport);
++<<<<<<< HEAD
 +	if (esw->manager_vport != vport_num &&
 +	    esw->mode == MLX5_ESWITCH_LEGACY) {
++=======
+ 
+ 	if (!mlx5_esw_is_manager_vport(esw, vport->vport) &&
+ 	    esw->mode == MLX5_ESWITCH_LEGACY)
++>>>>>>> f5d0c01d65ad (net/mlx5: E-switch, Legacy introduce and use per vport acl tables APIs)
  		mlx5_modify_vport_admin_state(esw->dev,
  					      MLX5_VPORT_STATE_OP_MOD_ESW_VPORT,
  					      vport_num, 1,
  					      MLX5_VPORT_ADMIN_STATE_DOWN);
++<<<<<<< HEAD
 +		esw_vport_disable_egress_acl(esw, vport);
 +		esw_vport_disable_ingress_acl(esw, vport);
 +		esw_vport_destroy_drop_counters(vport);
 +	}
++=======
+ 
+ 	esw_vport_cleanup_acl(esw, vport);
++>>>>>>> f5d0c01d65ad (net/mlx5: E-switch, Legacy introduce and use per vport acl tables APIs)
  	esw->enabled_vports--;
  
  done:
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
