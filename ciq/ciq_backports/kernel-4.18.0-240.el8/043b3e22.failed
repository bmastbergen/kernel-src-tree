devlink: let kernel allocate region snapshot id

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jakub Kicinski <kuba@kernel.org>
commit 043b3e22768d5d909cb1474fc21ae2fbaf026c0c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/043b3e22.failed

Currently users have to choose a free snapshot id before
calling DEVLINK_CMD_REGION_NEW. This is potentially racy
and inconvenient.

Make the DEVLINK_ATTR_REGION_SNAPSHOT_ID optional and try
to allocate id automatically. Send a message back to the
caller with the snapshot info.

Example use:
$ devlink region new netdevsim/netdevsim1/dummy
netdevsim/netdevsim1/dummy: snapshot 1

$ id=$(devlink -j region new netdevsim/netdevsim1/dummy | \
       jq '.[][][][]')
$ devlink region dump netdevsim/netdevsim1/dummy snapshot $id
[...]
$ devlink region del netdevsim/netdevsim1/dummy snapshot $id

v4:
 - inline the notification code
v3:
 - send the notification only once snapshot creation completed.
v2:
 - don't wrap the line containing extack;
 - add a few sentences to the docs.

	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
	Reviewed-by: Jacob Keller <jacob.e.keller@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 043b3e22768d5d909cb1474fc21ae2fbaf026c0c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/networking/devlink/devlink-region.rst
#	net/core/devlink.c
#	tools/testing/selftests/drivers/net/netdevsim/devlink.sh
diff --cc net/core/devlink.c
index 05a3779588b8,43a9d5be73ca..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -3853,6 -4082,102 +3853,105 @@@ static int devlink_nl_cmd_region_del(st
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ devlink_nl_cmd_region_new(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct devlink *devlink = info->user_ptr[0];
+ 	struct devlink_snapshot *snapshot;
+ 	struct nlattr *snapshot_id_attr;
+ 	struct devlink_region *region;
+ 	const char *region_name;
+ 	u32 snapshot_id;
+ 	u8 *data;
+ 	int err;
+ 
+ 	if (!info->attrs[DEVLINK_ATTR_REGION_NAME]) {
+ 		NL_SET_ERR_MSG_MOD(info->extack, "No region name provided");
+ 		return -EINVAL;
+ 	}
+ 
+ 	region_name = nla_data(info->attrs[DEVLINK_ATTR_REGION_NAME]);
+ 	region = devlink_region_get_by_name(devlink, region_name);
+ 	if (!region) {
+ 		NL_SET_ERR_MSG_MOD(info->extack, "The requested region does not exist");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!region->ops->snapshot) {
+ 		NL_SET_ERR_MSG_MOD(info->extack, "The requested region does not support taking an immediate snapshot");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	if (region->cur_snapshots == region->max_snapshots) {
+ 		NL_SET_ERR_MSG_MOD(info->extack, "The region has reached the maximum number of stored snapshots");
+ 		return -ENOSPC;
+ 	}
+ 
+ 	snapshot_id_attr = info->attrs[DEVLINK_ATTR_REGION_SNAPSHOT_ID];
+ 	if (snapshot_id_attr) {
+ 		snapshot_id = nla_get_u32(snapshot_id_attr);
+ 
+ 		if (devlink_region_snapshot_get_by_id(region, snapshot_id)) {
+ 			NL_SET_ERR_MSG_MOD(info->extack, "The requested snapshot id is already in use");
+ 			return -EEXIST;
+ 		}
+ 
+ 		err = __devlink_snapshot_id_insert(devlink, snapshot_id);
+ 		if (err)
+ 			return err;
+ 	} else {
+ 		err = __devlink_region_snapshot_id_get(devlink, &snapshot_id);
+ 		if (err) {
+ 			NL_SET_ERR_MSG_MOD(info->extack, "Failed to allocate a new snapshot id");
+ 			return err;
+ 		}
+ 	}
+ 
+ 	err = region->ops->snapshot(devlink, info->extack, &data);
+ 	if (err)
+ 		goto err_snapshot_capture;
+ 
+ 	err = __devlink_region_snapshot_create(region, data, snapshot_id);
+ 	if (err)
+ 		goto err_snapshot_create;
+ 
+ 	if (!snapshot_id_attr) {
+ 		struct sk_buff *msg;
+ 
+ 		snapshot = devlink_region_snapshot_get_by_id(region,
+ 							     snapshot_id);
+ 		if (WARN_ON(!snapshot))
+ 			return -EINVAL;
+ 
+ 		msg = devlink_nl_region_notify_build(region, snapshot,
+ 						     DEVLINK_CMD_REGION_NEW,
+ 						     info->snd_portid,
+ 						     info->snd_seq);
+ 		err = PTR_ERR_OR_ZERO(msg);
+ 		if (err)
+ 			goto err_notify;
+ 
+ 		err = genlmsg_reply(msg, info);
+ 		if (err)
+ 			goto err_notify;
+ 	}
+ 
+ 	return 0;
+ 
+ err_snapshot_create:
+ 	region->ops->destructor(data);
+ err_snapshot_capture:
+ 	__devlink_snapshot_id_decrement(devlink, snapshot_id);
+ 	return err;
+ 
+ err_notify:
+ 	devlink_region_snapshot_del(region, snapshot);
+ 	return err;
+ }
+ 
++>>>>>>> 043b3e22768d (devlink: let kernel allocate region snapshot id)
  static int devlink_nl_cmd_region_read_chunk_fill(struct sk_buff *msg,
  						 struct devlink *devlink,
  						 u8 *chunk, u32 chunk_size,
diff --cc tools/testing/selftests/drivers/net/netdevsim/devlink.sh
index 6a67eb8c24b0,ad539eccddcb..000000000000
--- a/tools/testing/selftests/drivers/net/netdevsim/devlink.sh
+++ b/tools/testing/selftests/drivers/net/netdevsim/devlink.sh
@@@ -140,6 -141,29 +140,32 @@@ regions_test(
  
  	check_region_snapshot_count dummy post-first-delete 2
  
++<<<<<<< HEAD
++=======
+ 	devlink region new $DL_HANDLE/dummy snapshot 25
+ 	check_err $? "Failed to create a new snapshot with id 25"
+ 
+ 	check_region_snapshot_count dummy post-first-request 3
+ 
+ 	devlink region del $DL_HANDLE/dummy snapshot 25
+ 	check_err $? "Failed to delete snapshot with id 25"
+ 
+ 	check_region_snapshot_count dummy post-second-delete 2
+ 
+ 	sid=$(devlink -j region new $DL_HANDLE/dummy | jq '.[][][][]')
+ 	check_err $? "Failed to create a new snapshot with id allocated by the kernel"
+ 
+ 	check_region_snapshot_count dummy post-first-request 3
+ 
+ 	devlink region dump $DL_HANDLE/dummy snapshot $sid >> /dev/null
+ 	check_err $? "Failed to dump a snapshot with id allocated by the kernel"
+ 
+ 	devlink region del $DL_HANDLE/dummy snapshot $sid
+ 	check_err $? "Failed to delete snapshot with id allocated by the kernel"
+ 
+ 	check_region_snapshot_count dummy post-first-request 2
+ 
++>>>>>>> 043b3e22768d (devlink: let kernel allocate region snapshot id)
  	log_test "regions test"
  }
  
* Unmerged path Documentation/networking/devlink/devlink-region.rst
* Unmerged path Documentation/networking/devlink/devlink-region.rst
* Unmerged path net/core/devlink.c
* Unmerged path tools/testing/selftests/drivers/net/netdevsim/devlink.sh
