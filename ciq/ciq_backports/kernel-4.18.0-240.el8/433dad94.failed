xfs: refactor the ioend merging code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 433dad94ec5d6b90385b56a8bc8718dd9542b289
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/433dad94.failed

Introduce two nicely abstracted helper, which can be moved to the iomap
code later.  Also use list_first_entry_or_null to simplify the code a
bit.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 433dad94ec5d6b90385b56a8bc8718dd9542b289)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_aops.c
diff --cc fs/xfs/xfs_aops.c
index add26533d923,c29ef69d1e51..000000000000
--- a/fs/xfs/xfs_aops.c
+++ b/fs/xfs/xfs_aops.c
@@@ -273,15 -290,8 +288,20 @@@ xfs_end_ioend
  done:
  	if (ioend->io_append_trans)
  		error = xfs_setfilesize_ioend(ioend, error);
++<<<<<<< HEAD
 +	list_replace_init(&ioend->io_list, &ioend_list);
 +	xfs_destroy_ioend(ioend, error);
 +
 +	while (!list_empty(&ioend_list)) {
 +		ioend = list_first_entry(&ioend_list, struct xfs_ioend,
 +				io_list);
 +		list_del_init(&ioend->io_list);
 +		xfs_destroy_ioend(ioend, error);
 +	}
++=======
+ 	xfs_destroy_ioends(ioend, error);
+ 	memalloc_nofs_restore(nofs_flag);
++>>>>>>> 433dad94ec5d (xfs: refactor the ioend merging code)
  }
  
  /*
@@@ -316,26 -339,18 +336,41 @@@ xfs_ioend_try_merge
  	struct xfs_ioend	*ioend,
  	struct list_head	*more_ioends)
  {
++<<<<<<< HEAD
 +	struct xfs_ioend	*next_ioend;
 +	int			ioend_error;
 +	int			error;
 +
 +	if (list_empty(more_ioends))
 +		return;
 +
 +	ioend_error = blk_status_to_errno(ioend->io_bio->bi_status);
 +
 +	while (!list_empty(more_ioends)) {
 +		next_ioend = list_first_entry(more_ioends, struct xfs_ioend,
 +				io_list);
 +		if (!xfs_ioend_can_merge(ioend, ioend_error, next_ioend))
 +			break;
 +		list_move_tail(&next_ioend->io_list, &ioend->io_list);
 +		ioend->io_size += next_ioend->io_size;
 +		if (ioend->io_append_trans) {
 +			error = xfs_setfilesize_ioend(next_ioend, 1);
 +			ASSERT(error == 1);
 +		}
++=======
+ 	struct xfs_ioend	*next;
+ 
+ 	INIT_LIST_HEAD(&ioend->io_list);
+ 
+ 	while ((next = list_first_entry_or_null(more_ioends, struct xfs_ioend,
+ 			io_list))) {
+ 		if (!xfs_ioend_can_merge(ioend, next))
+ 			break;
+ 		list_move_tail(&next->io_list, &ioend->io_list);
+ 		ioend->io_size += next->io_size;
+ 		if (next->io_append_trans)
+ 			xfs_ioend_merge_append_transactions(ioend, next);
++>>>>>>> 433dad94ec5d (xfs: refactor the ioend merging code)
  	}
  }
  
* Unmerged path fs/xfs/xfs_aops.c
