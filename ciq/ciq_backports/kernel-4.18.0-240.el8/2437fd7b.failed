tipc: make three functions static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Chen Wandun <chenwandun@huawei.com>
commit 2437fd7baf299c7b8a39fa3e727755e84ee7c4ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/2437fd7b.failed

Fix the following sparse warning:

net/tipc/node.c:281:6: warning: symbol 'tipc_node_free' was not declared. Should it be static?
net/tipc/node.c:2801:5: warning: symbol '__tipc_nl_node_set_key' was not declared. Should it be static?
net/tipc/node.c:2878:5: warning: symbol '__tipc_nl_node_flush_key' was not declared. Should it be static?

Fixes: fc1b6d6de220 ("tipc: introduce TIPC encryption & authentication")
Fixes: e1f32190cf7d ("tipc: add support for AEAD key setting via netlink")

	Signed-off-by: Chen Wandun <chenwandun@huawei.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2437fd7baf299c7b8a39fa3e727755e84ee7c4ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tipc/node.c
diff --cc net/tipc/node.c
index 3fe27ab13350,0c88778c88b5..000000000000
--- a/net/tipc/node.c
+++ b/net/tipc/node.c
@@@ -235,6 -252,42 +235,45 @@@ u16 tipc_node_get_capabilities(struct n
  	return caps;
  }
  
++<<<<<<< HEAD
++=======
+ u32 tipc_node_get_addr(struct tipc_node *node)
+ {
+ 	return (node) ? node->addr : 0;
+ }
+ 
+ char *tipc_node_get_id_str(struct tipc_node *node)
+ {
+ 	return node->peer_id_string;
+ }
+ 
+ #ifdef CONFIG_TIPC_CRYPTO
+ /**
+  * tipc_node_crypto_rx - Retrieve crypto RX handle from node
+  * Note: node ref counter must be held first!
+  */
+ struct tipc_crypto *tipc_node_crypto_rx(struct tipc_node *__n)
+ {
+ 	return (__n) ? __n->crypto_rx : NULL;
+ }
+ 
+ struct tipc_crypto *tipc_node_crypto_rx_by_list(struct list_head *pos)
+ {
+ 	return container_of(pos, struct tipc_node, list)->crypto_rx;
+ }
+ #endif
+ 
+ static void tipc_node_free(struct rcu_head *rp)
+ {
+ 	struct tipc_node *n = container_of(rp, struct tipc_node, rcu);
+ 
+ #ifdef CONFIG_TIPC_CRYPTO
+ 	tipc_crypto_stop(&n->crypto_rx);
+ #endif
+ 	kfree(n);
+ }
+ 
++>>>>>>> 2437fd7baf29 (tipc: make three functions static)
  static void tipc_node_kref_release(struct kref *kref)
  {
  	struct tipc_node *n = container_of(kref, struct tipc_node, kref);
@@@ -2546,11 -2768,142 +2585,134 @@@ int tipc_nl_node_dump_monitor_peer(stru
  	return skb->len;
  }
  
 -#ifdef CONFIG_TIPC_CRYPTO
 -static int tipc_nl_retrieve_key(struct nlattr **attrs,
 -				struct tipc_aead_key **key)
 +u32 tipc_node_get_addr(struct tipc_node *node)
  {
 -	struct nlattr *attr = attrs[TIPC_NLA_NODE_KEY];
 -
 -	if (!attr)
 -		return -ENODATA;
 -
 -	*key = (struct tipc_aead_key *)nla_data(attr);
 -	if (nla_len(attr) < tipc_aead_key_size(*key))
 -		return -EINVAL;
 -
 -	return 0;
 +	return (node) ? node->addr : 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int tipc_nl_retrieve_nodeid(struct nlattr **attrs, u8 **node_id)
+ {
+ 	struct nlattr *attr = attrs[TIPC_NLA_NODE_ID];
+ 
+ 	if (!attr)
+ 		return -ENODATA;
+ 
+ 	if (nla_len(attr) < TIPC_NODEID_LEN)
+ 		return -EINVAL;
+ 
+ 	*node_id = (u8 *)nla_data(attr);
+ 	return 0;
+ }
+ 
+ static int __tipc_nl_node_set_key(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct nlattr *attrs[TIPC_NLA_NODE_MAX + 1];
+ 	struct net *net = sock_net(skb->sk);
+ 	struct tipc_net *tn = tipc_net(net);
+ 	struct tipc_node *n = NULL;
+ 	struct tipc_aead_key *ukey;
+ 	struct tipc_crypto *c;
+ 	u8 *id, *own_id;
+ 	int rc = 0;
+ 
+ 	if (!info->attrs[TIPC_NLA_NODE])
+ 		return -EINVAL;
+ 
+ 	rc = nla_parse_nested(attrs, TIPC_NLA_NODE_MAX,
+ 			      info->attrs[TIPC_NLA_NODE],
+ 			      tipc_nl_node_policy, info->extack);
+ 	if (rc)
+ 		goto exit;
+ 
+ 	own_id = tipc_own_id(net);
+ 	if (!own_id) {
+ 		rc = -EPERM;
+ 		goto exit;
+ 	}
+ 
+ 	rc = tipc_nl_retrieve_key(attrs, &ukey);
+ 	if (rc)
+ 		goto exit;
+ 
+ 	rc = tipc_aead_key_validate(ukey);
+ 	if (rc)
+ 		goto exit;
+ 
+ 	rc = tipc_nl_retrieve_nodeid(attrs, &id);
+ 	switch (rc) {
+ 	case -ENODATA:
+ 		/* Cluster key mode */
+ 		rc = tipc_crypto_key_init(tn->crypto_tx, ukey, CLUSTER_KEY);
+ 		break;
+ 	case 0:
+ 		/* Per-node key mode */
+ 		if (!memcmp(id, own_id, NODE_ID_LEN)) {
+ 			c = tn->crypto_tx;
+ 		} else {
+ 			n = tipc_node_find_by_id(net, id) ?:
+ 				tipc_node_create(net, 0, id, 0xffffu, 0, true);
+ 			if (unlikely(!n)) {
+ 				rc = -ENOMEM;
+ 				break;
+ 			}
+ 			c = n->crypto_rx;
+ 		}
+ 
+ 		rc = tipc_crypto_key_init(c, ukey, PER_NODE_KEY);
+ 		if (n)
+ 			tipc_node_put(n);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ exit:
+ 	return (rc < 0) ? rc : 0;
+ }
+ 
+ int tipc_nl_node_set_key(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	int err;
+ 
+ 	rtnl_lock();
+ 	err = __tipc_nl_node_set_key(skb, info);
+ 	rtnl_unlock();
+ 
+ 	return err;
+ }
+ 
+ static int __tipc_nl_node_flush_key(struct sk_buff *skb,
+ 				    struct genl_info *info)
+ {
+ 	struct net *net = sock_net(skb->sk);
+ 	struct tipc_net *tn = tipc_net(net);
+ 	struct tipc_node *n;
+ 
+ 	tipc_crypto_key_flush(tn->crypto_tx);
+ 	rcu_read_lock();
+ 	list_for_each_entry_rcu(n, &tn->node_list, list)
+ 		tipc_crypto_key_flush(n->crypto_rx);
+ 	rcu_read_unlock();
+ 
+ 	pr_info("All keys are flushed!\n");
+ 	return 0;
+ }
+ 
+ int tipc_nl_node_flush_key(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	int err;
+ 
+ 	rtnl_lock();
+ 	err = __tipc_nl_node_flush_key(skb, info);
+ 	rtnl_unlock();
+ 
+ 	return err;
+ }
+ #endif
+ 
++>>>>>>> 2437fd7baf29 (tipc: make three functions static)
  /**
   * tipc_node_dump - dump TIPC node data
   * @n: tipc node to be dumped
* Unmerged path net/tipc/node.c
