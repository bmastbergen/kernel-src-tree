KVM: VMX: Introduce vmx_flush_tlb_current()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 33d19ec9b14c0e304f5d44a0dd1403539360968b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/33d19ec9.failed

Add a helper to flush TLB entries only for the current EPTP/VPID context
and use it for the existing direct invocations of vmx_flush_tlb().  TLB
flushes that are specific to the current vCPU state do not need to flush
other contexts.

Note, both converted call sites happen to be related to the APIC access
page, this is purely coincidental.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200320212833.3507-21-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 33d19ec9b14c0e304f5d44a0dd1403539360968b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index dbadf7ce3b2f,0f1dfbae649f..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -2931,6 -2838,47 +2931,50 @@@ static void exit_lmode(struct kvm_vcpu 
  
  #endif
  
++<<<<<<< HEAD
++=======
+ static void vmx_flush_tlb(struct kvm_vcpu *vcpu)
+ {
+ 	struct vcpu_vmx *vmx = to_vmx(vcpu);
+ 
+ 	/*
+ 	 * Flush all EPTP/VPID contexts, as the TLB flush _may_ have been
+ 	 * invoked via kvm_flush_remote_tlbs().  Flushing remote TLBs requires
+ 	 * all contexts to be flushed, not just the active context.
+ 	 *
+ 	 * Note, this also ensures a deferred TLB flush with VPID enabled and
+ 	 * EPT disabled invalidates the "correct" VPID, by nuking both L1 and
+ 	 * L2's VPIDs.
+ 	 */
+ 	if (enable_ept) {
+ 		ept_sync_global();
+ 	} else if (enable_vpid) {
+ 		if (cpu_has_vmx_invvpid_global()) {
+ 			vpid_sync_vcpu_global();
+ 		} else {
+ 			vpid_sync_vcpu_single(vmx->vpid);
+ 			vpid_sync_vcpu_single(vmx->nested.vpid02);
+ 		}
+ 	}
+ }
+ 
+ static void vmx_flush_tlb_current(struct kvm_vcpu *vcpu)
+ {
+ 	u64 root_hpa = vcpu->arch.mmu->root_hpa;
+ 
+ 	/* No flush required if the current context is invalid. */
+ 	if (!VALID_PAGE(root_hpa))
+ 		return;
+ 
+ 	if (enable_ept)
+ 		ept_sync_context(construct_eptp(vcpu, root_hpa));
+ 	else if (!is_guest_mode(vcpu))
+ 		vpid_sync_context(to_vmx(vcpu)->vpid);
+ 	else
+ 		vpid_sync_context(nested_get_vpid02(vcpu));
+ }
+ 
++>>>>>>> 33d19ec9b14c (KVM: VMX: Introduce vmx_flush_tlb_current())
  static void vmx_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t addr)
  {
  	/*
@@@ -6184,7 -6124,7 +6228,11 @@@ void vmx_set_virtual_apic_mode(struct k
  		if (flexpriority_enabled) {
  			sec_exec_control |=
  				SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
++<<<<<<< HEAD
 +			vmx_flush_tlb(vcpu, true);
++=======
+ 			vmx_flush_tlb_current(vcpu);
++>>>>>>> 33d19ec9b14c (KVM: VMX: Introduce vmx_flush_tlb_current())
  		}
  		break;
  	case LAPIC_MODE_X2APIC:
@@@ -6202,7 -6142,7 +6250,11 @@@ static void vmx_set_apic_access_page_ad
  {
  	if (!is_guest_mode(vcpu)) {
  		vmcs_write64(APIC_ACCESS_ADDR, hpa);
++<<<<<<< HEAD
 +		vmx_flush_tlb(vcpu, true);
++=======
+ 		vmx_flush_tlb_current(vcpu);
++>>>>>>> 33d19ec9b14c (KVM: VMX: Introduce vmx_flush_tlb_current())
  	}
  }
  
* Unmerged path arch/x86/kvm/vmx/vmx.c
