mlxsw: spectrum_trap: Prepare policers for registration with devlink

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ido Schimmel <idosch@mellanox.com>
commit 4561705b174314876c5fa9a8696f26dcdd9542f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/4561705b.failed

Prepare an array of policer IDs to register with devlink and their
associated parameters.

The array is composed from both policers that are currently bound to
exposed trap groups and policers that are not bound to any trap group.

v2:
* Provide max/min rate/burst size when registering policers

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Reviewed-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4561705b174314876c5fa9a8696f26dcdd9542f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.h
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
index 13424366f1bb,7f10e9cd7870..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
@@@ -106,11 -167,23 +107,23 @@@ static void mlxsw_sp_rx_exception_liste
  	MLXSW_RXL(mlxsw_sp_rx_exception_listener, _id,			      \
  		   _action, false, SP_##_group_id, SET_FW_DEFAULT)
  
+ #define MLXSW_SP_TRAP_POLICER(_id, _rate, _burst)			      \
+ 	DEVLINK_TRAP_POLICER(_id, _rate, _burst,			      \
+ 			     MLXSW_REG_QPCR_HIGHEST_CIR,		      \
+ 			     MLXSW_REG_QPCR_LOWEST_CIR,			      \
+ 			     1 << MLXSW_REG_QPCR_HIGHEST_CBS,		      \
+ 			     1 << MLXSW_REG_QPCR_LOWEST_CBS)
+ 
+ /* Ordered by policer identifier */
+ static const struct devlink_trap_policer mlxsw_sp_trap_policers_arr[] = {
+ 	MLXSW_SP_TRAP_POLICER(1, 10 * 1024, 128),
+ };
+ 
  static const struct devlink_trap_group mlxsw_sp_trap_groups_arr[] = {
 -	DEVLINK_TRAP_GROUP_GENERIC(L2_DROPS, 0),
 -	DEVLINK_TRAP_GROUP_GENERIC(L3_DROPS, 0),
 -	DEVLINK_TRAP_GROUP_GENERIC(TUNNEL_DROPS, 0),
 -	DEVLINK_TRAP_GROUP_GENERIC(ACL_DROPS, 0),
 +	DEVLINK_TRAP_GROUP_GENERIC(L2_DROPS),
 +	DEVLINK_TRAP_GROUP_GENERIC(L3_DROPS),
 +	DEVLINK_TRAP_GROUP_GENERIC(TUNNEL_DROPS),
 +	DEVLINK_TRAP_GROUP_GENERIC(ACL_DROPS),
  };
  
  static const struct devlink_trap mlxsw_sp_traps_arr[] = {
@@@ -202,8 -295,101 +215,95 @@@ static const u16 mlxsw_sp_listener_devl
  	DEVLINK_TRAP_GENERIC_ID_UNRESOLVED_NEIGH,
  	DEVLINK_TRAP_GENERIC_ID_IPV4_LPM_UNICAST_MISS,
  	DEVLINK_TRAP_GENERIC_ID_IPV6_LPM_UNICAST_MISS,
 -	DEVLINK_MLXSW_TRAP_ID_IRIF_DISABLED,
 -	DEVLINK_MLXSW_TRAP_ID_ERIF_DISABLED,
 -	DEVLINK_TRAP_GENERIC_ID_NON_ROUTABLE,
 -	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR,
 -	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR,
 -	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR,
 -	DEVLINK_TRAP_GENERIC_ID_OVERLAY_SMAC_MC,
 -	DEVLINK_TRAP_GENERIC_ID_INGRESS_FLOW_ACTION_DROP,
 -	DEVLINK_TRAP_GENERIC_ID_EGRESS_FLOW_ACTION_DROP,
  };
  
++<<<<<<< HEAD
++=======
+ #define MLXSW_SP_DISCARD_POLICER_ID	(MLXSW_REG_HTGT_TRAP_GROUP_MAX + 1)
+ #define MLXSW_SP_THIN_POLICER_ID	(MLXSW_SP_DISCARD_POLICER_ID + 1)
+ 
+ static int mlxsw_sp_trap_cpu_policers_set(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	char qpcr_pl[MLXSW_REG_QPCR_LEN];
+ 	int err;
+ 
+ 	mlxsw_reg_qpcr_pack(qpcr_pl, MLXSW_SP_DISCARD_POLICER_ID,
+ 			    MLXSW_REG_QPCR_IR_UNITS_M, false, 10 * 1024, 7);
+ 	err = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpcr), qpcr_pl);
+ 	if (err)
+ 		return err;
+ 
+ 	/* The purpose of "thin" policer is to drop as many packets
+ 	 * as possible. The dummy group is using it.
+ 	 */
+ 	__set_bit(MLXSW_SP_THIN_POLICER_ID, mlxsw_sp->trap->policers_usage);
+ 	mlxsw_reg_qpcr_pack(qpcr_pl, MLXSW_SP_THIN_POLICER_ID,
+ 			    MLXSW_REG_QPCR_IR_UNITS_M, false, 1, 4);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpcr), qpcr_pl);
+ }
+ 
+ static int mlxsw_sp_trap_dummy_group_init(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	char htgt_pl[MLXSW_REG_HTGT_LEN];
+ 
+ 	mlxsw_reg_htgt_pack(htgt_pl, MLXSW_REG_HTGT_TRAP_GROUP_SP_DUMMY,
+ 			    MLXSW_SP_THIN_POLICER_ID, 0, 1);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(htgt), htgt_pl);
+ }
+ 
+ static int mlxsw_sp_trap_policers_init(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	struct mlxsw_sp_trap *trap = mlxsw_sp->trap;
+ 	u64 free_policers = 0;
+ 	u32 last_id = 0;
+ 	int i;
+ 
+ 	for_each_clear_bit(i, trap->policers_usage, trap->max_policers)
+ 		free_policers++;
+ 
+ 	if (ARRAY_SIZE(mlxsw_sp_trap_policers_arr) > free_policers) {
+ 		dev_err(mlxsw_sp->bus_info->dev, "Exceeded number of supported packet trap policers\n");
+ 		return -ENOBUFS;
+ 	}
+ 
+ 	trap->policers_arr = kcalloc(free_policers,
+ 				     sizeof(struct devlink_trap_policer),
+ 				     GFP_KERNEL);
+ 	if (!trap->policers_arr)
+ 		return -ENOMEM;
+ 
+ 	trap->policers_count = free_policers;
+ 
+ 	for (i = 0; i < free_policers; i++) {
+ 		const struct devlink_trap_policer *policer;
+ 
+ 		if (i < ARRAY_SIZE(mlxsw_sp_trap_policers_arr)) {
+ 			policer = &mlxsw_sp_trap_policers_arr[i];
+ 			trap->policers_arr[i] = *policer;
+ 			last_id = policer->id;
+ 		} else {
+ 			/* Use parameters set for first policer and override
+ 			 * relevant ones.
+ 			 */
+ 			policer = &mlxsw_sp_trap_policers_arr[0];
+ 			trap->policers_arr[i] = *policer;
+ 			trap->policers_arr[i].id = ++last_id;
+ 			trap->policers_arr[i].init_rate = 1;
+ 			trap->policers_arr[i].init_burst = 16;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void mlxsw_sp_trap_policers_fini(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	struct mlxsw_sp_trap *trap = mlxsw_sp->trap;
+ 
+ 	kfree(trap->policers_arr);
+ }
+ 
++>>>>>>> 4561705b1743 (mlxsw: spectrum_trap: Prepare policers for registration with devlink)
  int mlxsw_sp_devlink_traps_init(struct mlxsw_sp *mlxsw_sp)
  {
  	size_t groups_count = ARRAY_SIZE(mlxsw_sp_trap_groups_arr);
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.h
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.h
