xdp: Move devmap bulk queue into struct net_device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Toke Høiland-Jørgensen <toke@redhat.com>
commit 75ccae62cb8d42a619323a85c577107b8b37d797
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/75ccae62.failed

Commit 96360004b862 ("xdp: Make devmap flush_list common for all map
instances"), changed devmap flushing to be a global operation instead of a
per-map operation. However, the queue structure used for bulking was still
allocated as part of the containing map.

This patch moves the devmap bulk queue into struct net_device. The
motivation for this is reusing it for the non-map variant of XDP_REDIRECT,
which will be changed in a subsequent commit.  To avoid other fields of
struct net_device moving to different cache lines, we also move a couple of
other members around.

We defer the actual allocation of the bulk queue structure until the
NETDEV_REGISTER notification devmap.c. This makes it possible to check for
ndo_xdp_xmit support before allocating the structure, which is not possible
at the time struct net_device is allocated. However, we keep the freeing in
free_netdev() to avoid adding another RCU callback on NETDEV_UNREGISTER.

Because of this change, we lose the reference back to the map that
originated the redirect, so change the tracepoint to always return 0 as the
map ID and index. Otherwise no functional change is intended with this
patch.

After this patch, the relevant part of struct net_device looks like this,
according to pahole:

	/* --- cacheline 14 boundary (896 bytes) --- */
	struct netdev_queue *      _tx __attribute__((__aligned__(64))); /*   896     8 */
	unsigned int               num_tx_queues;        /*   904     4 */
	unsigned int               real_num_tx_queues;   /*   908     4 */
	struct Qdisc *             qdisc;                /*   912     8 */
	unsigned int               tx_queue_len;         /*   920     4 */
	spinlock_t                 tx_global_lock;       /*   924     4 */
	struct xdp_dev_bulk_queue * xdp_bulkq;           /*   928     8 */
	struct xps_dev_maps *      xps_cpus_map;         /*   936     8 */
	struct xps_dev_maps *      xps_rxqs_map;         /*   944     8 */
	struct mini_Qdisc *        miniq_egress;         /*   952     8 */
	/* --- cacheline 15 boundary (960 bytes) --- */
	struct hlist_head  qdisc_hash[16];               /*   960   128 */
	/* --- cacheline 17 boundary (1088 bytes) --- */
	struct timer_list  watchdog_timer;               /*  1088    40 */

	/* XXX last struct has 4 bytes of padding */

	int                        watchdog_timeo;       /*  1128     4 */

	/* XXX 4 bytes hole, try to pack */

	struct list_head   todo_list;                    /*  1136    16 */
	/* --- cacheline 18 boundary (1152 bytes) --- */

	Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Björn Töpel <bjorn.topel@intel.com>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
Link: https://lore.kernel.org/bpf/157918768397.1458396.12673224324627072349.stgit@toke.dk
(cherry picked from commit 75ccae62cb8d42a619323a85c577107b8b37d797)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netdevice.h
#	kernel/bpf/devmap.c
diff --cc include/linux/netdevice.h
index 4bd94d67974c,5ec3537fbdb1..000000000000
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@@ -2092,27 -1986,29 +2093,36 @@@ struct net_device 
  	struct netdev_queue	*_tx ____cacheline_aligned_in_smp;
  	unsigned int		num_tx_queues;
  	unsigned int		real_num_tx_queues;
++<<<<<<< HEAD
 +	RH_KABI_EXCLUDE(struct Qdisc		*qdisc)
 +#ifdef CONFIG_NET_SCHED
 +	DECLARE_HASHTABLE	(qdisc_hash, 4);
 +#endif
++=======
+ 	struct Qdisc		*qdisc;
++>>>>>>> 75ccae62cb8d (xdp: Move devmap bulk queue into struct net_device)
  	unsigned int		tx_queue_len;
  	spinlock_t		tx_global_lock;
- 	int			watchdog_timeo;
+ 
+ 	struct xdp_dev_bulk_queue __percpu *xdp_bulkq;
  
  #ifdef CONFIG_XPS
  	struct xps_dev_maps __rcu *xps_cpus_map;
  	struct xps_dev_maps __rcu *xps_rxqs_map;
  #endif
  #ifdef CONFIG_NET_CLS_ACT
 -	struct mini_Qdisc __rcu	*miniq_egress;
 +	RH_KABI_EXCLUDE(struct mini_Qdisc __rcu	*miniq_egress)
  #endif
  
+ #ifdef CONFIG_NET_SCHED
+ 	DECLARE_HASHTABLE	(qdisc_hash, 4);
+ #endif
  	/* These may be needed for future network-power-down code. */
  	struct timer_list	watchdog_timer;
+ 	int			watchdog_timeo;
  
- 	int __percpu		*pcpu_refcnt;
  	struct list_head	todo_list;
+ 	int __percpu		*pcpu_refcnt;
  
  	struct list_head	link_watch_list;
  
diff --cc kernel/bpf/devmap.c
index cfc445b29247,030d125c3839..000000000000
--- a/kernel/bpf/devmap.c
+++ b/kernel/bpf/devmap.c
@@@ -67,10 -63,10 +65,9 @@@ struct xdp_dev_bulk_queue 
  
  struct bpf_dtab_netdev {
  	struct net_device *dev; /* must be first member, due to tracepoint */
 -	struct hlist_node index_hlist;
  	struct bpf_dtab *dtab;
- 	struct xdp_bulk_queue __percpu *bulkq;
  	struct rcu_head rcu;
- 	unsigned int idx; /* keep track of map index for tracepoint */
+ 	unsigned int idx;
  };
  
  struct bpf_dtab {
@@@ -180,32 -206,37 +177,58 @@@ static void dev_map_free(struct bpf_ma
  	/* Make sure prior __dev_map_entry_free() have completed. */
  	rcu_barrier();
  
 -	if (dtab->map.map_type == BPF_MAP_TYPE_DEVMAP_HASH) {
 -		for (i = 0; i < dtab->n_buckets; i++) {
 -			struct bpf_dtab_netdev *dev;
 -			struct hlist_head *head;
 -			struct hlist_node *next;
 +	/* To ensure all pending flush operations have completed wait for flush
 +	 * list to empty on _all_ cpus.
 +	 * Because the above synchronize_rcu() ensures the map is disconnected
 +	 * from the program we can assume no new items will be added.
 +	 */
 +	for_each_online_cpu(cpu) {
 +		struct list_head *flush_list = per_cpu_ptr(dtab->flush_list, cpu);
  
++<<<<<<< HEAD
 +		while (!list_empty(flush_list))
 +			cond_resched();
++=======
+ 			head = dev_map_index_hash(dtab, i);
+ 
+ 			hlist_for_each_entry_safe(dev, next, head, index_hlist) {
+ 				hlist_del_rcu(&dev->index_hlist);
+ 				dev_put(dev->dev);
+ 				kfree(dev);
+ 			}
+ 		}
+ 
+ 		kfree(dtab->dev_index_head);
+ 	} else {
+ 		for (i = 0; i < dtab->map.max_entries; i++) {
+ 			struct bpf_dtab_netdev *dev;
+ 
+ 			dev = dtab->netdev_map[i];
+ 			if (!dev)
+ 				continue;
+ 
+ 			dev_put(dev->dev);
+ 			kfree(dev);
+ 		}
+ 
+ 		bpf_map_area_free(dtab->netdev_map);
++>>>>>>> 75ccae62cb8d (xdp: Move devmap bulk queue into struct net_device)
  	}
  
 +	for (i = 0; i < dtab->map.max_entries; i++) {
 +		struct bpf_dtab_netdev *dev;
 +
 +		dev = dtab->netdev_map[i];
 +		if (!dev)
 +			continue;
 +
 +		free_percpu(dev->bulkq);
 +		dev_put(dev->dev);
 +		kfree(dev);
 +	}
 +
 +	free_percpu(dtab->flush_list);
 +	bpf_map_area_free(dtab->netdev_map);
  	kfree(dtab);
  }
  
@@@ -226,11 -257,67 +249,72 @@@ static int dev_map_get_next_key(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int bq_xmit_all(struct xdp_bulk_queue *bq, u32 flags,
 +		       bool in_napi_ctx)
++=======
+ struct bpf_dtab_netdev *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key)
+ {
+ 	struct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);
+ 	struct hlist_head *head = dev_map_index_hash(dtab, key);
+ 	struct bpf_dtab_netdev *dev;
+ 
+ 	hlist_for_each_entry_rcu(dev, head, index_hlist)
+ 		if (dev->idx == key)
+ 			return dev;
+ 
+ 	return NULL;
+ }
+ 
+ static int dev_map_hash_get_next_key(struct bpf_map *map, void *key,
+ 				    void *next_key)
  {
- 	struct bpf_dtab_netdev *obj = bq->obj;
- 	struct net_device *dev = obj->dev;
+ 	struct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);
+ 	u32 idx, *next = next_key;
+ 	struct bpf_dtab_netdev *dev, *next_dev;
+ 	struct hlist_head *head;
+ 	int i = 0;
+ 
+ 	if (!key)
+ 		goto find_first;
+ 
+ 	idx = *(u32 *)key;
+ 
+ 	dev = __dev_map_hash_lookup_elem(map, idx);
+ 	if (!dev)
+ 		goto find_first;
+ 
+ 	next_dev = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu(&dev->index_hlist)),
+ 				    struct bpf_dtab_netdev, index_hlist);
+ 
+ 	if (next_dev) {
+ 		*next = next_dev->idx;
+ 		return 0;
+ 	}
+ 
+ 	i = idx & (dtab->n_buckets - 1);
+ 	i++;
+ 
+  find_first:
+ 	for (; i < dtab->n_buckets; i++) {
+ 		head = dev_map_index_hash(dtab, i);
+ 
+ 		next_dev = hlist_entry_safe(rcu_dereference_raw(hlist_first_rcu(head)),
+ 					    struct bpf_dtab_netdev,
+ 					    index_hlist);
+ 		if (next_dev) {
+ 			*next = next_dev->idx;
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	return -ENOENT;
+ }
+ 
+ static int bq_xmit_all(struct xdp_dev_bulk_queue *bq, u32 flags)
++>>>>>>> 75ccae62cb8d (xdp: Move devmap bulk queue into struct net_device)
+ {
+ 	struct net_device *dev = bq->dev;
  	int sent = 0, drops = 0, err = 0;
  	int i;
  
@@@ -282,11 -364,10 +365,16 @@@ error
   * net device can be torn down. On devmap tear down we ensure the flush list
   * is empty before completing to ensure all flush operations have completed.
   */
 -void __dev_map_flush(void)
 +void __dev_map_flush(struct bpf_map *map)
  {
++<<<<<<< HEAD
 +	struct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);
 +	struct list_head *flush_list = this_cpu_ptr(dtab->flush_list);
 +	struct xdp_bulk_queue *bq, *tmp;
++=======
+ 	struct list_head *flush_list = this_cpu_ptr(&dev_map_flush_list);
+ 	struct xdp_dev_bulk_queue *bq, *tmp;
++>>>>>>> 75ccae62cb8d (xdp: Move devmap bulk queue into struct net_device)
  
  	rcu_read_lock();
  	list_for_each_entry_safe(bq, tmp, flush_list, flush_node)
@@@ -317,11 -398,11 +405,16 @@@ static int bq_enqueue(struct net_devic
  		      struct net_device *dev_rx)
  
  {
++<<<<<<< HEAD
 +	struct list_head *flush_list = this_cpu_ptr(obj->dtab->flush_list);
 +	struct xdp_bulk_queue *bq = this_cpu_ptr(obj->bulkq);
++=======
+ 	struct list_head *flush_list = this_cpu_ptr(&dev_map_flush_list);
+ 	struct xdp_dev_bulk_queue *bq = this_cpu_ptr(dev->xdp_bulkq);
++>>>>>>> 75ccae62cb8d (xdp: Move devmap bulk queue into struct net_device)
  
  	if (unlikely(bq->count == DEV_MAP_BULK_SIZE))
 -		bq_xmit_all(bq, 0);
 +		bq_xmit_all(bq, 0, true);
  
  	/* Ingress dev_rx will be the same for all xdp_frame's in
  	 * bulk_queue, because bq stored per-CPU and must be flushed
@@@ -401,8 -476,6 +494,11 @@@ static void __dev_map_entry_free(struc
  	struct bpf_dtab_netdev *dev;
  
  	dev = container_of(rcu, struct bpf_dtab_netdev, rcu);
++<<<<<<< HEAD
 +	dev_map_flush_old(dev);
 +	free_percpu(dev->bulkq);
++=======
++>>>>>>> 75ccae62cb8d (xdp: Move devmap bulk queue into struct net_device)
  	dev_put(dev->dev);
  	kfree(dev);
  }
* Unmerged path include/linux/netdevice.h
diff --git a/include/trace/events/xdp.h b/include/trace/events/xdp.h
index 42362fb56f08..1f06f7959936 100644
--- a/include/trace/events/xdp.h
+++ b/include/trace/events/xdp.h
@@ -277,7 +277,7 @@ TRACE_EVENT(xdp_devmap_xmit,
 	),
 
 	TP_fast_assign(
-		__entry->map_id		= map->id;
+		__entry->map_id		= map ? map->id : 0;
 		__entry->act		= XDP_REDIRECT;
 		__entry->map_index	= map_index;
 		__entry->drops		= drops;
* Unmerged path kernel/bpf/devmap.c
diff --git a/net/core/dev.c b/net/core/dev.c
index 1a8bca927008..96842f104477 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -9377,6 +9377,8 @@ void free_netdev(struct net_device *dev)
 
 	free_percpu(dev->pcpu_refcnt);
 	dev->pcpu_refcnt = NULL;
+	free_percpu(dev->xdp_bulkq);
+	dev->xdp_bulkq = NULL;
 
 	/*  Compatibility with error handling in drivers */
 	if (dev->reg_state == NETREG_UNINITIALIZED) {
