net/mlx5: Add new chain for netfilter flow table offload

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paul Blakey <paulb@mellanox.com>
commit 975b992fdd4b38028d7c1dcf38286d6e7991c1b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/975b992f.failed

Netfilter tables (nftables) implements a software datapath that
comes after tc ingress datapath. The datapath supports offloading
such rules via the flow table offload API.

This API is currently only used by NFT and it doesn't provide the
global priority in regards to tc offload, so we assume offloading such
rules must come after tc. It does provide a flow table priority
parameter, so we need to provide some supported priority range.

For that, split fastpath prio to two, flow table offload and tc offload,
with one dedicated priority chain for flow table offload.

Next patch will re-use the multi chain API to access this chain by
allowing access to this chain by the fdb_sub_namespace.

	Signed-off-by: Paul Blakey <paulb@mellanox.com>
	Reviewed-by: Mark Bloch <markb@mellanox.com>
	Acked-by: Pablo Neira Ayuso <pablo@netfilter.org>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 975b992fdd4b38028d7c1dcf38286d6e7991c1b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 38a4321bf0aa,2b563700c664..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -43,9 -43,15 +43,21 @@@
  #include <linux/mlx5/fs.h>
  #include "lib/mpfs.h"
  
++<<<<<<< HEAD
 +#define FDB_MAX_CHAIN 3
 +#define FDB_SLOW_PATH_CHAIN (FDB_MAX_CHAIN + 1)
 +#define FDB_MAX_PRIO 16
++=======
+ #define FDB_TC_MAX_CHAIN 3
+ #define FDB_FT_CHAIN (FDB_TC_MAX_CHAIN + 1)
+ #define FDB_TC_SLOW_PATH_CHAIN (FDB_FT_CHAIN + 1)
+ 
+ /* The index of the last real chain (FT) + 1 as chain zero is valid as well */
+ #define FDB_NUM_CHAINS (FDB_FT_CHAIN + 1)
+ 
+ #define FDB_TC_MAX_PRIO 16
+ #define FDB_TC_LEVELS_PER_PRIO 2
++>>>>>>> 975b992fdd4b (net/mlx5: Add new chain for netfilter flow table offload)
  
  #ifdef CONFIG_MLX5_ESWITCH
  
@@@ -168,7 -178,7 +180,11 @@@ struct mlx5_eswitch_fdb 
  			struct {
  				struct mlx5_flow_table *fdb;
  				u32 num_rules;
++<<<<<<< HEAD
 +			} fdb_prio[FDB_MAX_CHAIN + 1][FDB_MAX_PRIO + 1][PRIO_LEVELS];
++=======
+ 			} fdb_prio[FDB_NUM_CHAINS][FDB_TC_MAX_PRIO + 1][FDB_TC_LEVELS_PER_PRIO];
++>>>>>>> 975b992fdd4b (net/mlx5: Add new chain for netfilter flow table offload)
  			/* Protects fdb_prio table */
  			struct mutex fdb_prio_lock;
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index d64993b85979,84e90b21e148..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@@ -2545,21 -2544,108 +2545,109 @@@ static int init_rdma_rx_root_ns(struct 
  	if (!steering->rdma_rx_root_ns)
  		return -ENOMEM;
  
 -	err = init_root_tree(steering, &rdma_rx_root_fs,
 -			     &steering->rdma_rx_root_ns->ns.node);
 -	if (err)
 -		goto out_err;
 -
 -	set_prio_attrs(steering->rdma_rx_root_ns);
 +	steering->rdma_rx_root_ns->def_miss_action =
 +		MLX5_FLOW_TABLE_MISS_ACTION_SWITCH_DOMAIN;
  
 -	return 0;
 -
 -out_err:
 -	cleanup_root_ns(steering->rdma_rx_root_ns);
 -	steering->rdma_rx_root_ns = NULL;
 -	return err;
 +	/* Create single prio */
 +	prio = fs_create_prio(&steering->rdma_rx_root_ns->ns, 0, 1);
 +	return PTR_ERR_OR_ZERO(prio);
  }
++<<<<<<< HEAD
++=======
+ 
+ /* FT and tc chains are stored in the same array so we can re-use the
+  * mlx5_get_fdb_sub_ns() and tc api for FT chains.
+  * When creating a new ns for each chain store it in the first available slot.
+  * Assume tc chains are created and stored first and only then the FT chain.
+  */
+ static void store_fdb_sub_ns_prio_chain(struct mlx5_flow_steering *steering,
+ 					struct mlx5_flow_namespace *ns)
+ {
+ 	int chain = 0;
+ 
+ 	while (steering->fdb_sub_ns[chain])
+ 		++chain;
+ 
+ 	steering->fdb_sub_ns[chain] = ns;
+ }
+ 
+ static int create_fdb_sub_ns_prio_chain(struct mlx5_flow_steering *steering,
+ 					struct fs_prio *maj_prio)
+ {
+ 	struct mlx5_flow_namespace *ns;
+ 	struct fs_prio *min_prio;
+ 	int prio;
+ 
+ 	ns = fs_create_namespace(maj_prio, MLX5_FLOW_TABLE_MISS_ACTION_DEF);
+ 	if (IS_ERR(ns))
+ 		return PTR_ERR(ns);
+ 
+ 	for (prio = 0; prio < FDB_TC_MAX_PRIO; prio++) {
+ 		min_prio = fs_create_prio(ns, prio, FDB_TC_LEVELS_PER_PRIO);
+ 		if (IS_ERR(min_prio))
+ 			return PTR_ERR(min_prio);
+ 	}
+ 
+ 	store_fdb_sub_ns_prio_chain(steering, ns);
+ 
+ 	return 0;
+ }
+ 
+ static int create_fdb_chains(struct mlx5_flow_steering *steering,
+ 			     int fs_prio,
+ 			     int chains)
+ {
+ 	struct fs_prio *maj_prio;
+ 	int levels;
+ 	int chain;
+ 	int err;
+ 
+ 	levels = FDB_TC_LEVELS_PER_PRIO * FDB_TC_MAX_PRIO * chains;
+ 	maj_prio = fs_create_prio_chained(&steering->fdb_root_ns->ns,
+ 					  fs_prio,
+ 					  levels);
+ 	if (IS_ERR(maj_prio))
+ 		return PTR_ERR(maj_prio);
+ 
+ 	for (chain = 0; chain < chains; chain++) {
+ 		err = create_fdb_sub_ns_prio_chain(steering, maj_prio);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int create_fdb_fast_path(struct mlx5_flow_steering *steering)
+ {
+ 	int err;
+ 
+ 	steering->fdb_sub_ns = kcalloc(FDB_NUM_CHAINS,
+ 				       sizeof(*steering->fdb_sub_ns),
+ 				       GFP_KERNEL);
+ 	if (!steering->fdb_sub_ns)
+ 		return -ENOMEM;
+ 
+ 	err = create_fdb_chains(steering, FDB_TC_OFFLOAD, FDB_TC_MAX_CHAIN + 1);
+ 	if (err)
+ 		return err;
+ 
+ 	err = create_fdb_chains(steering, FDB_FT_OFFLOAD, 1);
+ 	if (err)
+ 		return err;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 975b992fdd4b (net/mlx5: Add new chain for netfilter flow table offload)
  static int init_fdb_root_ns(struct mlx5_flow_steering *steering)
  {
 +	struct mlx5_flow_namespace *ns;
  	struct fs_prio *maj_prio;
 +	struct fs_prio *min_prio;
 +	int levels;
 +	int chain;
 +	int prio;
  	int err;
  
  	steering->fdb_root_ns = create_root_ns(steering, FS_FT_FDB);
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
diff --git a/include/linux/mlx5/fs.h b/include/linux/mlx5/fs.h
index a008e9b63b78..276c7217474c 100644
--- a/include/linux/mlx5/fs.h
+++ b/include/linux/mlx5/fs.h
@@ -79,7 +79,8 @@ enum mlx5_flow_namespace_type {
 
 enum {
 	FDB_BYPASS_PATH,
-	FDB_FAST_PATH,
+	FDB_TC_OFFLOAD,
+	FDB_FT_OFFLOAD,
 	FDB_SLOW_PATH,
 };
 
