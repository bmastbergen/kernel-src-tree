ipv4: Add "offload" and "trap" indications to routes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ido Schimmel <idosch@mellanox.com>
commit 90b93f1b31f86dcde2fa3c57f1ae33d28d87a1f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/90b93f1b.failed

When performing L3 offload, routes and nexthops are usually programmed
into two different tables in the underlying device. Therefore, the fact
that a nexthop resides in hardware does not necessarily mean that all
the associated routes also reside in hardware and vice-versa.

While the kernel can signal to user space the presence of a nexthop in
hardware (via 'RTNH_F_OFFLOAD'), it does not have a corresponding flag
for routes. In addition, the fact that a route resides in hardware does
not necessarily mean that the traffic is offloaded. For example,
unreachable routes (i.e., 'RTN_UNREACHABLE') are programmed to trap
packets to the CPU so that the kernel will be able to generate the
appropriate ICMP error packet.

This patch adds an "offload" and "trap" indications to IPv4 routes, so
that users will have better visibility into the offload process.

'struct fib_alias' is extended with two new fields that indicate if the
route resides in hardware or not and if it is offloading traffic from
the kernel or trapping packets to it. Note that the new fields are added
in the 6 bytes hole and therefore the struct still fits in a single
cache line [1].

Capable drivers are expected to invoke fib_alias_hw_flags_set() with the
route's key in order to set the flags.

The indications are dumped to user space via a new flags (i.e.,
'RTM_F_OFFLOAD' and 'RTM_F_TRAP') in the 'rtm_flags' field in the
ancillary header.

v2:
* Make use of 'struct fib_rt_info' in fib_alias_hw_flags_set()

[1]
struct fib_alias {
        struct hlist_node  fa_list;                      /*     0    16 */
        struct fib_info *          fa_info;              /*    16     8 */
        u8                         fa_tos;               /*    24     1 */
        u8                         fa_type;              /*    25     1 */
        u8                         fa_state;             /*    26     1 */
        u8                         fa_slen;              /*    27     1 */
        u32                        tb_id;                /*    28     4 */
        s16                        fa_default;           /*    32     2 */
        u8                         offload:1;            /*    34: 0  1 */
        u8                         trap:1;               /*    34: 1  1 */
        u8                         unused:6;             /*    34: 2  1 */

        /* XXX 5 bytes hole, try to pack */

        struct callback_head rcu __attribute__((__aligned__(8))); /*    40    16 */

        /* size: 56, cachelines: 1, members: 12 */
        /* sum members: 50, holes: 1, sum holes: 5 */
        /* sum bitfield members: 8 bits (1 bytes) */
        /* forced alignments: 1, forced holes: 1, sum forced holes: 5 */
        /* last cacheline: 56 bytes */
} __attribute__((__aligned__(8)));

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Reviewed-by: David Ahern <dsahern@gmail.com>
	Reviewed-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 90b93f1b31f86dcde2fa3c57f1ae33d28d87a1f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip_fib.h
#	net/ipv4/fib_semantics.c
#	net/ipv4/fib_trie.c
#	net/ipv4/route.c
diff --cc include/net/ip_fib.h
index cf0696685354,6a1ae49809de..000000000000
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@@ -173,19 -196,25 +173,33 @@@ struct fib_result_nl 
  #define FIB_TABLE_HASHSZ 2
  #endif
  
 -__be32 fib_info_update_nhc_saddr(struct net *net, struct fib_nh_common *nhc,
 -				 unsigned char scope);
 -__be32 fib_result_prefsrc(struct net *net, struct fib_result *res);
 -
 -#define FIB_RES_NHC(res)		((res).nhc)
 -#define FIB_RES_DEV(res)	(FIB_RES_NHC(res)->nhc_dev)
 -#define FIB_RES_OIF(res)	(FIB_RES_NHC(res)->nhc_oif)
 -
 +__be32 fib_info_update_nh_saddr(struct net *net, struct fib_nh *nh);
 +
 +#define FIB_RES_SADDR(net, res)				\
 +	((FIB_RES_NH(res).nh_saddr_genid ==		\
 +	  atomic_read(&(net)->ipv4.dev_addr_genid)) ?	\
 +	 FIB_RES_NH(res).nh_saddr :			\
 +	 fib_info_update_nh_saddr((net), &FIB_RES_NH(res)))
 +#define FIB_RES_GW(res)			(FIB_RES_NH(res).nh_gw)
 +#define FIB_RES_DEV(res)		(FIB_RES_NH(res).nh_dev)
 +#define FIB_RES_OIF(res)		(FIB_RES_NH(res).nh_oif)
 +
++<<<<<<< HEAD
 +#define FIB_RES_PREFSRC(net, res)	((res).fi->fib_prefsrc ? : \
 +					 FIB_RES_SADDR(net, res))
++=======
+ struct fib_rt_info {
+ 	struct fib_info		*fi;
+ 	u32			tb_id;
+ 	__be32			dst;
+ 	int			dst_len;
+ 	u8			tos;
+ 	u8			type;
+ 	u8			offload:1,
+ 				trap:1,
+ 				unused:6;
+ };
++>>>>>>> 90b93f1b31f8 (ipv4: Add "offload" and "trap" indications to routes)
  
  struct fib_entry_notifier_info {
  	struct fib_notifier_info info; /* must be first */
@@@ -418,7 -466,17 +432,8 @@@ void fib_select_multipath(struct fib_re
  void fib_select_path(struct net *net, struct fib_result *res,
  		     struct flowi4 *fl4, const struct sk_buff *skb);
  
 -int fib_nh_init(struct net *net, struct fib_nh *fib_nh,
 -		struct fib_config *cfg, int nh_weight,
 -		struct netlink_ext_ack *extack);
 -void fib_nh_release(struct net *net, struct fib_nh *fib_nh);
 -int fib_nh_common_init(struct fib_nh_common *nhc, struct nlattr *fc_encap,
 -		       u16 fc_encap_type, void *cfg, gfp_t gfp_flags,
 -		       struct netlink_ext_ack *extack);
 -void fib_nh_common_release(struct fib_nh_common *nhc);
 -
  /* Exported by fib_trie.c */
+ void fib_alias_hw_flags_set(struct net *net, const struct fib_rt_info *fri);
  void fib_trie_init(void);
  struct fib_table *fib_trie_table(u32 id, struct fib_table *alias);
  
diff --cc net/ipv4/fib_semantics.c
index a0c8cdcf0152,a803cdd9400a..000000000000
--- a/net/ipv4/fib_semantics.c
+++ b/net/ipv4/fib_semantics.c
@@@ -416,9 -513,15 +416,21 @@@ void rtmsg_fib(int event, __be32 key, s
  	if (!skb)
  		goto errout;
  
++<<<<<<< HEAD
 +	err = fib_dump_info(skb, info->portid, seq, event, tb_id,
 +			    fa->fa_type, key, dst_len,
 +			    fa->fa_tos, fa->fa_info, nlm_flags);
++=======
+ 	fri.fi = fa->fa_info;
+ 	fri.tb_id = tb_id;
+ 	fri.dst = key;
+ 	fri.dst_len = dst_len;
+ 	fri.tos = fa->fa_tos;
+ 	fri.type = fa->fa_type;
+ 	fri.offload = fa->offload;
+ 	fri.trap = fa->trap;
+ 	err = fib_dump_info(skb, info->portid, seq, event, &fri, nlm_flags);
++>>>>>>> 90b93f1b31f8 (ipv4: Add "offload" and "trap" indications to routes)
  	if (err < 0) {
  		/* -EMSGSIZE implies BUG in fib_nlmsg_size() */
  		WARN_ON(err == -EMSGSIZE);
@@@ -1390,18 -1796,18 +1402,26 @@@ int fib_dump_info(struct sk_buff *skb, 
  			if (nh->nh_tclassid &&
  			    nla_put_u32(skb, RTA_FLOW, nh->nh_tclassid))
  				goto nla_put_failure;
 -		}
  #endif
 -	} else {
 -		if (fib_add_multipath(skb, fi) < 0)
 -			goto nla_put_failure;
 -	}
 +			if (nh->nh_lwtstate &&
 +			    lwtunnel_fill_encap(skb, nh->nh_lwtstate) < 0)
 +				goto nla_put_failure;
 +
++<<<<<<< HEAD
 +			/* length of rtnetlink header + attributes */
 +			rtnh->rtnh_len = nlmsg_get_pos(skb) - (void *) rtnh;
 +		} endfor_nexthops(fi);
  
 +		nla_nest_end(skb, mp);
 +	}
 +#endif
++=======
+ 	if (fri->offload)
+ 		rtm->rtm_flags |= RTM_F_OFFLOAD;
+ 	if (fri->trap)
+ 		rtm->rtm_flags |= RTM_F_TRAP;
+ 
++>>>>>>> 90b93f1b31f8 (ipv4: Add "offload" and "trap" indications to routes)
  	nlmsg_end(skb, nlh);
  	return 0;
  
diff --cc net/ipv4/fib_trie.c
index 011339ee20a0,6ce1f2bbffd0..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -2116,6 -2244,16 +2166,19 @@@ static int fn_trie_dump_leaf(struct key
  
  		if (filter->dump_routes) {
  			if (!s_fa) {
++<<<<<<< HEAD
++=======
+ 				struct fib_rt_info fri;
+ 
+ 				fri.fi = fi;
+ 				fri.tb_id = tb->tb_id;
+ 				fri.dst = xkey;
+ 				fri.dst_len = KEYLENGTH - fa->fa_slen;
+ 				fri.tos = fa->fa_tos;
+ 				fri.type = fa->fa_type;
+ 				fri.offload = fa->offload;
+ 				fri.trap = fa->trap;
++>>>>>>> 90b93f1b31f8 (ipv4: Add "offload" and "trap" indications to routes)
  				err = fib_dump_info(skb,
  						    NETLINK_CB(cb->skb).portid,
  						    cb->nlh->nlmsg_seq,
diff --cc net/ipv4/route.c
index ba9644ed198b,2010888e68ca..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -3083,10 -3231,33 +3083,38 @@@ static int inet_rtm_getroute(struct sk_
  				err = -EHOSTUNREACH;
  			goto errout_rcu;
  		}
++<<<<<<< HEAD
++=======
+ 		fri.fi = res.fi;
+ 		fri.tb_id = table_id;
+ 		fri.dst = res.prefix;
+ 		fri.dst_len = res.prefixlen;
+ 		fri.tos = fl4.flowi4_tos;
+ 		fri.type = rt->rt_type;
+ 		fri.offload = 0;
+ 		fri.trap = 0;
+ 		if (res.fa_head) {
+ 			struct fib_alias *fa;
+ 
+ 			hlist_for_each_entry_rcu(fa, res.fa_head, fa_list) {
+ 				u8 slen = 32 - fri.dst_len;
+ 
+ 				if (fa->fa_slen == slen &&
+ 				    fa->tb_id == fri.tb_id &&
+ 				    fa->fa_tos == fri.tos &&
+ 				    fa->fa_info == res.fi &&
+ 				    fa->fa_type == fri.type) {
+ 					fri.offload = fa->offload;
+ 					fri.trap = fa->trap;
+ 					break;
+ 				}
+ 			}
+ 		}
++>>>>>>> 90b93f1b31f8 (ipv4: Add "offload" and "trap" indications to routes)
  		err = fib_dump_info(skb, NETLINK_CB(in_skb).portid,
 -				    nlh->nlmsg_seq, RTM_NEWROUTE, &fri, 0);
 +				    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,
 +				    rt->rt_type, res.prefix, res.prefixlen,
 +				    fl4.flowi4_tos, res.fi, 0);
  	} else {
  		err = rt_fill_info(net, dst, src, rt, table_id, &fl4, skb,
  				   NETLINK_CB(in_skb).portid,
* Unmerged path include/net/ip_fib.h
diff --git a/include/uapi/linux/rtnetlink.h b/include/uapi/linux/rtnetlink.h
index ce2a623abb75..801e1c4aaba2 100644
--- a/include/uapi/linux/rtnetlink.h
+++ b/include/uapi/linux/rtnetlink.h
@@ -302,6 +302,8 @@ enum rt_scope_t {
 #define RTM_F_PREFIX		0x800	/* Prefix addresses		*/
 #define RTM_F_LOOKUP_TABLE	0x1000	/* set rtm_table to FIB lookup result */
 #define RTM_F_FIB_MATCH	        0x2000	/* return full fib lookup match */
+#define RTM_F_OFFLOAD		0x4000	/* route is offloaded */
+#define RTM_F_TRAP		0x8000	/* route is trapping packets */
 
 /* Reserved table identifiers */
 
diff --git a/net/ipv4/fib_lookup.h b/net/ipv4/fib_lookup.h
index e6ff282bb7f4..7c86f1dd1d2a 100644
--- a/net/ipv4/fib_lookup.h
+++ b/net/ipv4/fib_lookup.h
@@ -15,6 +15,9 @@ struct fib_alias {
 	u8			fa_slen;
 	u32			tb_id;
 	s16			fa_default;
+	u8			offload:1,
+				trap:1,
+				unused:6;
 	struct rcu_head		rcu;
 };
 
* Unmerged path net/ipv4/fib_semantics.c
* Unmerged path net/ipv4/fib_trie.c
* Unmerged path net/ipv4/route.c
