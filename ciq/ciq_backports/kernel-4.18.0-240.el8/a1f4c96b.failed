gpiolib: of: Make of_gpio_spi_cs_get_count static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author YueHaibing <yuehaibing@huawei.com>
commit a1f4c96b799b80118b50bd47320deb9013b7ff40
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a1f4c96b.failed

Fix sparse warning:

drivers/gpio/gpiolib-of.c:35:5: warning:
 symbol 'of_gpio_spi_cs_get_count' was not declared. Should it be static?

	Reported-by: Hulk Robot <hulkci@huawei.com>
	Signed-off-by: YueHaibing <yuehaibing@huawei.com>
	Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
Link: https://lore.kernel.org/r/20191130012828.14504-1-yuehaibing@huawei.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit a1f4c96b799b80118b50bd47320deb9013b7ff40)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib-of.c
diff --cc drivers/gpio/gpiolib-of.c
index f90ba3c6ac6b,f90a161ca97a..000000000000
--- a/drivers/gpio/gpiolib-of.c
+++ b/drivers/gpio/gpiolib-of.c
@@@ -21,6 -21,61 +21,64 @@@
  #include <linux/gpio/machine.h>
  
  #include "gpiolib.h"
++<<<<<<< HEAD
++=======
+ #include "gpiolib-of.h"
+ 
+ /**
+  * of_gpio_spi_cs_get_count() - special GPIO counting for SPI
+  * Some elder GPIO controllers need special quirks. Currently we handle
+  * the Freescale GPIO controller with bindings that doesn't use the
+  * established "cs-gpios" for chip selects but instead rely on
+  * "gpios" for the chip select lines. If we detect this, we redirect
+  * the counting of "cs-gpios" to count "gpios" transparent to the
+  * driver.
+  */
+ static int of_gpio_spi_cs_get_count(struct device *dev, const char *con_id)
+ {
+ 	struct device_node *np = dev->of_node;
+ 
+ 	if (!IS_ENABLED(CONFIG_SPI_MASTER))
+ 		return 0;
+ 	if (!con_id || strcmp(con_id, "cs"))
+ 		return 0;
+ 	if (!of_device_is_compatible(np, "fsl,spi") &&
+ 	    !of_device_is_compatible(np, "aeroflexgaisler,spictrl"))
+ 		return 0;
+ 	return of_gpio_named_count(np, "gpios");
+ }
+ 
+ /*
+  * This is used by external users of of_gpio_count() from <linux/of_gpio.h>
+  *
+  * FIXME: get rid of those external users by converting them to GPIO
+  * descriptors and let them all use gpiod_get_count()
+  */
+ int of_gpio_get_count(struct device *dev, const char *con_id)
+ {
+ 	int ret;
+ 	char propname[32];
+ 	unsigned int i;
+ 
+ 	ret = of_gpio_spi_cs_get_count(dev, con_id);
+ 	if (ret > 0)
+ 		return ret;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(gpio_suffixes); i++) {
+ 		if (con_id)
+ 			snprintf(propname, sizeof(propname), "%s-%s",
+ 				 con_id, gpio_suffixes[i]);
+ 		else
+ 			snprintf(propname, sizeof(propname), "%s",
+ 				 gpio_suffixes[i]);
+ 
+ 		ret = of_gpio_named_count(dev->of_node, propname);
+ 		if (ret > 0)
+ 			break;
+ 	}
+ 	return ret ? ret : -ENOENT;
+ }
++>>>>>>> a1f4c96b799b (gpiolib: of: Make of_gpio_spi_cs_get_count static)
  
  static int of_gpiochip_match_node_and_xlate(struct gpio_chip *chip, void *data)
  {
* Unmerged path drivers/gpio/gpiolib-of.c
