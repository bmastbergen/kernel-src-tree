gpio: Use callback presence to determine need of valid_mask

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Linus Walleij <linus.walleij@linaro.org>
commit eb1e8bd6e3900e3a3b9776cd1b09ecfc05573619
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/eb1e8bd6.failed

After we switched the two drivers that have .need_valid_mask
set to use the callback for setting up the .valid_mask,
we can just use the presence of the .init_valid_mask()
callback (or the OF reserved ranges, nota bene) to determine
whether to allocate the mask or not and we can drop the
.need_valid_mask field altogether.

	Cc: Benjamin Gaignard <benjamin.gaignard@st.com>
	Cc: Amelie Delaunay <amelie.delaunay@st.com>
	Cc: Stephen Boyd <swboyd@chromium.org>
	Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
Link: https://lore.kernel.org/r/20190819093058.10863-1-linus.walleij@linaro.org
(cherry picked from commit eb1e8bd6e3900e3a3b9776cd1b09ecfc05573619)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib.c
#	drivers/pinctrl/pinctrl-stmfx.c
diff --cc drivers/gpio/gpiolib.c
index e17af7d89361,01aa5440454c..000000000000
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@@ -360,22 -361,13 +360,26 @@@ static unsigned long *gpiochip_allocate
  	return p;
  }
  
 -static int gpiochip_alloc_valid_mask(struct gpio_chip *gc)
 +static int gpiochip_alloc_valid_mask(struct gpio_chip *gpiochip)
  {
++<<<<<<< HEAD
 +#ifdef CONFIG_OF_GPIO
 +	int size;
 +	struct device_node *np = gpiochip->of_node;
 +
 +	size = of_property_count_u32_elems(np,  "gpio-reserved-ranges");
 +	if (size > 0 && size % 2 == 0)
 +		gpiochip->need_valid_mask = true;
 +#endif
 +
 +	if (!gpiochip->need_valid_mask)
++=======
+ 	if (!(of_gpio_need_valid_mask(gc) || gc->init_valid_mask))
++>>>>>>> eb1e8bd6e390 (gpio: Use callback presence to determine need of valid_mask)
  		return 0;
  
 -	gc->valid_mask = gpiochip_allocate_mask(gc);
 -	if (!gc->valid_mask)
 +	gpiochip->valid_mask = gpiochip_allocate_mask(gpiochip);
 +	if (!gpiochip->valid_mask)
  		return -ENOMEM;
  
  	return 0;
* Unmerged path drivers/pinctrl/pinctrl-stmfx.c
* Unmerged path drivers/gpio/gpiolib.c
* Unmerged path drivers/pinctrl/pinctrl-stmfx.c
diff --git a/drivers/pinctrl/qcom/pinctrl-msm.c b/drivers/pinctrl/qcom/pinctrl-msm.c
index d4d949b548bb..da288ca99278 100644
--- a/drivers/pinctrl/qcom/pinctrl-msm.c
+++ b/drivers/pinctrl/qcom/pinctrl-msm.c
@@ -603,7 +603,6 @@ static const struct gpio_chip msm_gpio_template = {
 	.request          = gpiochip_generic_request,
 	.free             = gpiochip_generic_free,
 	.dbg_show         = msm_gpio_dbg_show,
-	.init_valid_mask  = msm_gpio_init_valid_mask,
 };
 
 /* For dual-edge interrupts in software, since some hardware has no
@@ -881,7 +880,8 @@ static int msm_gpio_init(struct msm_pinctrl *pctrl)
 	chip->parent = pctrl->dev;
 	chip->owner = THIS_MODULE;
 	chip->of_node = pctrl->dev->of_node;
-	chip->need_valid_mask = msm_gpio_needs_valid_mask(pctrl);
+	if (msm_gpio_needs_valid_mask(pctrl))
+		chip->init_valid_mask = msm_gpio_init_valid_mask;
 
 	pctrl->irq_chip.name = "msmgpio";
 	pctrl->irq_chip.irq_mask = msm_gpio_irq_mask;
diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 07332890d9f4..a214b0e36a3b 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -314,15 +314,6 @@ struct gpio_chip {
 	struct gpio_irq_chip irq;
 #endif /* CONFIG_GPIOLIB_IRQCHIP */
 
-	/**
-	 * @need_valid_mask:
-	 *
-	 * If set core allocates @valid_mask with all its values initialized
-	 * with init_valid_mask() or set to one if init_valid_mask() is not
-	 * defined
-	 */
-	bool need_valid_mask;
-
 	/**
 	 * @valid_mask:
 	 *
