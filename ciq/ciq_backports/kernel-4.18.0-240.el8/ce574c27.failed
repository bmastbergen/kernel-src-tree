iommu: Move iommu_group_create_direct_mappings() out of iommu_group_add_device()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Joerg Roedel <jroedel@suse.de>
commit ce574c27ae275bc51b6437883fc9cd1c46b498e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ce574c27.failed

After the previous changes the iommu group may not have a default
domain when iommu_group_add_device() is called. With no default domain
iommu_group_create_direct_mappings() will do nothing and no direct
mappings will be created.

Rename iommu_group_create_direct_mappings() to
iommu_create_device_direct_mappings() to better reflect that the
function creates direct mappings only for one device and not for all
devices in the group. Then move the call to the places where a default
domain actually exists.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
	Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
	Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
Link: https://lore.kernel.org/r/20200429133712.31431-13-joro@8bytes.org
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit ce574c27ae275bc51b6437883fc9cd1c46b498e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
diff --cc drivers/iommu/iommu.c
index 7997fcb701e0,834a45da0ed0..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -91,6 -80,18 +91,21 @@@ static bool iommu_cmd_line_dma_api(void
  	return !!(iommu_cmd_line & IOMMU_CMD_LINE_DMA_API);
  }
  
++<<<<<<< HEAD
++=======
+ static int iommu_alloc_default_domain(struct device *dev);
+ static struct iommu_domain *__iommu_domain_alloc(struct bus_type *bus,
+ 						 unsigned type);
+ static int __iommu_attach_device(struct iommu_domain *domain,
+ 				 struct device *dev);
+ static int __iommu_attach_group(struct iommu_domain *domain,
+ 				struct iommu_group *group);
+ static void __iommu_detach_group(struct iommu_domain *domain,
+ 				 struct iommu_group *group);
+ static int iommu_create_device_direct_mappings(struct iommu_group *group,
+ 					       struct device *dev);
+ 
++>>>>>>> ce574c27ae27 (iommu: Move iommu_group_create_direct_mappings() out of iommu_group_add_device())
  #define IOMMU_GROUP_ATTR(_name, _mode, _show, _store)		\
  struct iommu_group_attribute iommu_group_attr_##_name =		\
  	__ATTR(_name, _mode, _show, _store)
@@@ -161,17 -163,146 +176,156 @@@ void iommu_device_unregister(struct iom
  	list_del(&iommu->list);
  	spin_unlock(&iommu_device_lock);
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL_GPL(iommu_device_unregister);
+ 
+ static struct dev_iommu *dev_iommu_get(struct device *dev)
+ {
+ 	struct dev_iommu *param = dev->iommu;
+ 
+ 	if (param)
+ 		return param;
+ 
+ 	param = kzalloc(sizeof(*param), GFP_KERNEL);
+ 	if (!param)
+ 		return NULL;
+ 
+ 	mutex_init(&param->lock);
+ 	dev->iommu = param;
+ 	return param;
+ }
+ 
+ static void dev_iommu_free(struct device *dev)
+ {
+ 	kfree(dev->iommu);
+ 	dev->iommu = NULL;
+ }
+ 
+ static int __iommu_probe_device(struct device *dev, struct list_head *group_list)
+ {
+ 	const struct iommu_ops *ops = dev->bus->iommu_ops;
+ 	struct iommu_device *iommu_dev;
+ 	struct iommu_group *group;
+ 	int ret;
+ 
+ 	iommu_dev = ops->probe_device(dev);
+ 	if (IS_ERR(iommu_dev))
+ 		return PTR_ERR(iommu_dev);
+ 
+ 	dev->iommu->iommu_dev = iommu_dev;
+ 
+ 	group = iommu_group_get_for_dev(dev);
+ 	if (IS_ERR(group)) {
+ 		ret = PTR_ERR(group);
+ 		goto out_release;
+ 	}
+ 	iommu_group_put(group);
+ 
+ 	if (group_list && !group->default_domain && list_empty(&group->entry))
+ 		list_add_tail(&group->entry, group_list);
+ 
+ 	iommu_device_link(iommu_dev, dev);
+ 
+ 	return 0;
+ 
+ out_release:
+ 	ops->release_device(dev);
+ 
+ 	return ret;
+ }
+ 
+ static int __iommu_probe_device_helper(struct device *dev)
+ {
+ 	const struct iommu_ops *ops = dev->bus->iommu_ops;
+ 	struct iommu_group *group;
+ 	int ret;
+ 
+ 	ret = __iommu_probe_device(dev, NULL);
+ 	if (ret)
+ 		goto err_out;
+ 
+ 	/*
+ 	 * Try to allocate a default domain - needs support from the
+ 	 * IOMMU driver. There are still some drivers which don't
+ 	 * support default domains, so the return value is not yet
+ 	 * checked.
+ 	 */
+ 	iommu_alloc_default_domain(dev);
+ 
+ 	group = iommu_group_get(dev);
+ 	if (!group)
+ 		goto err_release;
+ 
+ 	if (group->default_domain)
+ 		ret = __iommu_attach_device(group->default_domain, dev);
+ 
+ 	iommu_create_device_direct_mappings(group, dev);
+ 
+ 	iommu_group_put(group);
+ 
+ 	if (ret)
+ 		goto err_release;
+ 
+ 	if (ops->probe_finalize)
+ 		ops->probe_finalize(dev);
+ 
+ 	return 0;
+ 
+ err_release:
+ 	iommu_release_device(dev);
+ err_out:
+ 	return ret;
+ 
+ }
++>>>>>>> ce574c27ae27 (iommu: Move iommu_group_create_direct_mappings() out of iommu_group_add_device())
  
  int iommu_probe_device(struct device *dev)
  {
  	const struct iommu_ops *ops = dev->bus->iommu_ops;
++<<<<<<< HEAD
 +	int ret = -EINVAL;
++=======
+ 	struct iommu_group *group;
+ 	int ret;
++>>>>>>> ce574c27ae27 (iommu: Move iommu_group_create_direct_mappings() out of iommu_group_add_device())
  
  	WARN_ON(dev->iommu_group);
  
 -	if (!ops)
 -		return -EINVAL;
 +	if (ops)
 +		ret = ops->add_device(dev);
  
++<<<<<<< HEAD
++=======
+ 	if (!dev_iommu_get(dev))
+ 		return -ENOMEM;
+ 
+ 	if (!try_module_get(ops->owner)) {
+ 		ret = -EINVAL;
+ 		goto err_free_dev_param;
+ 	}
+ 
+ 	if (ops->probe_device)
+ 		return __iommu_probe_device_helper(dev);
+ 
+ 	ret = ops->add_device(dev);
+ 	if (ret)
+ 		goto err_module_put;
+ 
+ 	group = iommu_group_get(dev);
+ 	iommu_create_device_direct_mappings(group, dev);
+ 	iommu_group_put(group);
+ 
+ 	if (ops->probe_finalize)
+ 		ops->probe_finalize(dev);
+ 
+ 	return 0;
+ 
+ err_module_put:
+ 	module_put(ops->owner);
+ err_free_dev_param:
+ 	dev_iommu_free(dev);
++>>>>>>> ce574c27ae27 (iommu: Move iommu_group_create_direct_mappings() out of iommu_group_add_device())
  	return ret;
  }
  
@@@ -717,11 -850,9 +871,9 @@@ rename
  
  	dev->iommu_group = group;
  
- 	iommu_group_create_direct_mappings(group, dev);
- 
  	mutex_lock(&group->mutex);
  	list_add_tail(&device->list, &group->devices);
 -	if (group->domain)
 +	if (group->domain  && !iommu_is_attach_deferred(group->domain, dev))
  		ret = __iommu_attach_device(group->domain, dev);
  	mutex_unlock(&group->mutex);
  	if (ret)
@@@ -1283,10 -1696,145 +1435,148 @@@ static int iommu_bus_notifier(struct no
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ struct __group_domain_type {
+ 	struct device *dev;
+ 	unsigned int type;
+ };
+ 
+ static int probe_get_default_domain_type(struct device *dev, void *data)
+ {
+ 	const struct iommu_ops *ops = dev->bus->iommu_ops;
+ 	struct __group_domain_type *gtype = data;
+ 	unsigned int type = 0;
+ 
+ 	if (ops->def_domain_type)
+ 		type = ops->def_domain_type(dev);
+ 
+ 	if (type) {
+ 		if (gtype->type && gtype->type != type) {
+ 			dev_warn(dev, "Device needs domain type %s, but device %s in the same iommu group requires type %s - using default\n",
+ 				 iommu_domain_type_str(type),
+ 				 dev_name(gtype->dev),
+ 				 iommu_domain_type_str(gtype->type));
+ 			gtype->type = 0;
+ 		}
+ 
+ 		if (!gtype->dev) {
+ 			gtype->dev  = dev;
+ 			gtype->type = type;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void probe_alloc_default_domain(struct bus_type *bus,
+ 				       struct iommu_group *group)
+ {
+ 	struct __group_domain_type gtype;
+ 
+ 	memset(&gtype, 0, sizeof(gtype));
+ 
+ 	/* Ask for default domain requirements of all devices in the group */
+ 	__iommu_group_for_each_dev(group, &gtype,
+ 				   probe_get_default_domain_type);
+ 
+ 	if (!gtype.type)
+ 		gtype.type = iommu_def_domain_type;
+ 
+ 	iommu_group_alloc_default_domain(bus, group, gtype.type);
+ 
+ }
+ 
+ static int iommu_group_do_dma_attach(struct device *dev, void *data)
+ {
+ 	struct iommu_domain *domain = data;
+ 	const struct iommu_ops *ops;
+ 	int ret;
+ 
+ 	ret = __iommu_attach_device(domain, dev);
+ 
+ 	ops = domain->ops;
+ 
+ 	if (ret == 0 && ops->probe_finalize)
+ 		ops->probe_finalize(dev);
+ 
+ 	return ret;
+ }
+ 
+ static int __iommu_group_dma_attach(struct iommu_group *group)
+ {
+ 	return __iommu_group_for_each_dev(group, group->default_domain,
+ 					  iommu_group_do_dma_attach);
+ }
+ 
+ static int iommu_do_create_direct_mappings(struct device *dev, void *data)
+ {
+ 	struct iommu_group *group = data;
+ 
+ 	iommu_create_device_direct_mappings(group, dev);
+ 
+ 	return 0;
+ }
+ 
+ static int iommu_group_create_direct_mappings(struct iommu_group *group)
+ {
+ 	return __iommu_group_for_each_dev(group, group,
+ 					  iommu_do_create_direct_mappings);
+ }
+ 
+ static int bus_iommu_probe(struct bus_type *bus)
+ {
+ 	const struct iommu_ops *ops = bus->iommu_ops;
+ 	int ret;
+ 
+ 	if (ops->probe_device) {
+ 		struct iommu_group *group, *next;
+ 		LIST_HEAD(group_list);
+ 
+ 		/*
+ 		 * This code-path does not allocate the default domain when
+ 		 * creating the iommu group, so do it after the groups are
+ 		 * created.
+ 		 */
+ 		ret = bus_for_each_dev(bus, NULL, &group_list, probe_iommu_group);
+ 		if (ret)
+ 			return ret;
+ 
+ 		list_for_each_entry_safe(group, next, &group_list, entry) {
+ 			/* Remove item from the list */
+ 			list_del_init(&group->entry);
+ 
+ 			mutex_lock(&group->mutex);
+ 
+ 			/* Try to allocate default domain */
+ 			probe_alloc_default_domain(bus, group);
+ 
+ 			if (!group->default_domain) {
+ 				mutex_unlock(&group->mutex);
+ 				continue;
+ 			}
+ 
+ 			iommu_group_create_direct_mappings(group);
+ 
+ 			ret = __iommu_group_dma_attach(group);
+ 
+ 			mutex_unlock(&group->mutex);
+ 
+ 			if (ret)
+ 				break;
+ 		}
+ 	} else {
+ 		ret = bus_for_each_dev(bus, NULL, NULL, add_iommu_group);
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> ce574c27ae27 (iommu: Move iommu_group_create_direct_mappings() out of iommu_group_add_device())
  static int iommu_bus_init(struct bus_type *bus, const struct iommu_ops *ops)
  {
 -	struct notifier_block *nb;
  	int err;
 +	struct notifier_block *nb;
  
  	nb = kzalloc(sizeof(struct notifier_block), GFP_KERNEL);
  	if (!nb)
* Unmerged path drivers/iommu/iommu.c
