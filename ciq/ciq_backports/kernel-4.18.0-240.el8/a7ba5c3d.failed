drivers/iommu: Export core IOMMU API symbols to permit modular drivers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Will Deacon <will@kernel.org>
commit a7ba5c3d008dd78d881a1658eae5a2275ebd5087
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a7ba5c3d.failed

Building IOMMU drivers as modules requires that the core IOMMU API
symbols are exported as GPL symbols.

	Signed-off-by: Will Deacon <will@kernel.org>
	Tested-by: John Garry <john.garry@huawei.com> # smmu v3
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit a7ba5c3d008dd78d881a1658eae5a2275ebd5087)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
diff --cc drivers/iommu/iommu.c
index b1509d26c35f,3abe19ecbcd1..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -161,7 -149,30 +162,8 @@@ void iommu_device_unregister(struct iom
  	list_del(&iommu->list);
  	spin_unlock(&iommu_device_lock);
  }
+ EXPORT_SYMBOL_GPL(iommu_device_unregister);
  
 -static struct iommu_param *iommu_get_dev_param(struct device *dev)
 -{
 -	struct iommu_param *param = dev->iommu_param;
 -
 -	if (param)
 -		return param;
 -
 -	param = kzalloc(sizeof(*param), GFP_KERNEL);
 -	if (!param)
 -		return NULL;
 -
 -	mutex_init(&param->lock);
 -	dev->iommu_param = param;
 -	return param;
 -}
 -
 -static void iommu_free_dev_param(struct device *dev)
 -{
 -	kfree(dev->iommu_param);
 -	dev->iommu_param = NULL;
 -}
 -
  int iommu_probe_device(struct device *dev)
  {
  	const struct iommu_ops *ops = dev->bus->iommu_ops;
@@@ -1110,7 -1330,21 +1114,24 @@@ struct iommu_group *pci_device_group(st
  	/* No shared group found, allocate new */
  	return iommu_group_alloc();
  }
+ EXPORT_SYMBOL_GPL(pci_device_group);
  
++<<<<<<< HEAD
++=======
+ /* Get the IOMMU group for device on fsl-mc bus */
+ struct iommu_group *fsl_mc_device_group(struct device *dev)
+ {
+ 	struct device *cont_dev = fsl_mc_cont_dev(dev);
+ 	struct iommu_group *group;
+ 
+ 	group = iommu_group_get(cont_dev);
+ 	if (!group)
+ 		group = iommu_group_alloc();
+ 	return group;
+ }
+ EXPORT_SYMBOL_GPL(fsl_mc_device_group);
+ 
++>>>>>>> a7ba5c3d008d (drivers/iommu: Export core IOMMU API symbols to permit modular drivers)
  /**
   * iommu_group_get_for_dev - Find or create the IOMMU group for a device
   * @dev: target device
diff --git a/drivers/iommu/iommu-sysfs.c b/drivers/iommu/iommu-sysfs.c
index 44127d54e943..9550105ce83b 100644
--- a/drivers/iommu/iommu-sysfs.c
+++ b/drivers/iommu/iommu-sysfs.c
@@ -90,6 +90,7 @@ int iommu_device_sysfs_add(struct iommu_device *iommu,
 	put_device(iommu->dev);
 	return ret;
 }
+EXPORT_SYMBOL_GPL(iommu_device_sysfs_add);
 
 void iommu_device_sysfs_remove(struct iommu_device *iommu)
 {
@@ -97,6 +98,8 @@ void iommu_device_sysfs_remove(struct iommu_device *iommu)
 	device_unregister(iommu->dev);
 	iommu->dev = NULL;
 }
+EXPORT_SYMBOL_GPL(iommu_device_sysfs_remove);
+
 /*
  * IOMMU drivers can indicate a device is managed by a given IOMMU using
  * this interface.  A link to the device will be created in the "devices"
@@ -122,6 +125,7 @@ int iommu_device_link(struct iommu_device *iommu, struct device *link)
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(iommu_device_link);
 
 void iommu_device_unlink(struct iommu_device *iommu, struct device *link)
 {
@@ -131,3 +135,4 @@ void iommu_device_unlink(struct iommu_device *iommu, struct device *link)
 	sysfs_remove_link(&link->kobj, "iommu");
 	sysfs_remove_link_from_group(&iommu->dev->kobj, "devices", dev_name(link));
 }
+EXPORT_SYMBOL_GPL(iommu_device_unlink);
* Unmerged path drivers/iommu/iommu.c
