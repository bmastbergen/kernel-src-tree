sched/core: Optimize pick_next_task()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit 5d7d605642b28a5911198a405a6072f091bfbee6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5d7d6056.failed

Ever since we moved the sched_class definitions into their own files,
the constant expression {fair,idle}_sched_class.pick_next_task() is
not in fact a compile time constant anymore and results in an indirect
call (barring LTO).

Fix that by exposing pick_next_task_{fair,idle}() directly, this gets
rid of the indirect call (and RETPOLINE) on the fast path.

Also remove the unlikely() from the idle case, it is in fact /the/ way
we select idle -- and that is a very common thing to do.

Performance for will-it-scale/sched_yield improves by 2% (as reported
by 0-day).

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: bsegall@google.com
	Cc: dietmar.eggemann@arm.com
	Cc: juri.lelli@redhat.com
	Cc: ktkhai@virtuozzo.com
	Cc: mgorman@suse.de
	Cc: qais.yousef@arm.com
	Cc: qperret@google.com
	Cc: rostedt@goodmis.org
	Cc: valentin.schneider@arm.com
	Cc: vincent.guittot@linaro.org
Link: https://lkml.kernel.org/r/20191108131909.603037345@infradead.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 5d7d605642b28a5911198a405a6072f091bfbee6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/core.c
diff --cc kernel/sched/core.c
index 9079f8ce0c0d,7cf65474fa26..000000000000
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@@ -3339,13 -3917,15 +3339,20 @@@ pick_next_task(struct rq *rq, struct ta
  		    prev->sched_class == &fair_sched_class) &&
  		   rq->nr_running == rq->cfs.h_nr_running)) {
  
- 		p = fair_sched_class.pick_next_task(rq, prev, rf);
+ 		p = pick_next_task_fair(rq, prev, rf);
  		if (unlikely(p == RETRY_TASK))
 -			goto restart;
 +			goto again;
  
  		/* Assumes fair_sched_class->next == idle_sched_class */
++<<<<<<< HEAD
 +		if (unlikely(!p))
 +			p = idle_sched_class.pick_next_task(rq, prev, rf);
++=======
+ 		if (!p) {
+ 			put_prev_task(rq, prev);
+ 			p = pick_next_task_idle(rq, NULL, NULL);
+ 		}
++>>>>>>> 5d7d605642b2 (sched/core: Optimize pick_next_task())
  
  		return p;
  	}
* Unmerged path kernel/sched/core.c
diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index 9b5a5e15e495..466dc035973c 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -6667,7 +6667,7 @@ static void check_preempt_wakeup(struct rq *rq, struct task_struct *p, int wake_
 		set_last_buddy(se);
 }
 
-static struct task_struct *
+struct task_struct *
 pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
 {
 	struct cfs_rq *cfs_rq = &rq->cfs;
diff --git a/kernel/sched/idle.c b/kernel/sched/idle.c
index b77157291d47..7244018870f8 100644
--- a/kernel/sched/idle.c
+++ b/kernel/sched/idle.c
@@ -398,7 +398,7 @@ static void set_next_task_idle(struct rq *rq, struct task_struct *next)
 	schedstat_inc(rq->sched_goidle);
 }
 
-static struct task_struct *
+struct task_struct *
 pick_next_task_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
 {
 	struct task_struct *next = rq->idle;
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index 53610e62107c..40b5d0992e8f 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -1762,6 +1762,9 @@ extern const struct sched_class fair_sched_class;
 extern const struct sched_class idle_sched_class;
 
 
+extern struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);
+extern struct task_struct *pick_next_task_idle(struct rq *rq, struct task_struct *prev, struct rq_flags *rf);
+
 #ifdef CONFIG_SMP
 
 extern void update_group_capacity(struct sched_domain *sd, int cpu);
