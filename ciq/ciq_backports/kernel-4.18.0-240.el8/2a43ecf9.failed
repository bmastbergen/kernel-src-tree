netfilter: nf_tables: avoid global info storage

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 2a43ecf96ba6a6eed70dbcd99d0888fc0ad3b82b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/2a43ecf9.failed

This works because all accesses are currently serialized by nfnl
nf_tables subsys mutex.

If we want to have per-netns locking, we need to make this scratch
area pernetns or allocate it on demand.

This does the latter, its ~28kbyte but we can fallback to vmalloc
so it should be fine.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 2a43ecf96ba6a6eed70dbcd99d0888fc0ad3b82b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 6c3c56b8f3d5,68436edd9cdf..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -2583,13 -2452,8 +2583,11 @@@ static int nft_table_validate(struct ne
  	return 0;
  }
  
 +static struct nft_rule *nft_rule_lookup_byid(const struct net *net,
 +					     const struct nlattr *nla);
 +
  #define NFT_RULE_MAXEXPRS	128
  
- static struct nft_expr_info *info;
- 
  static int nf_tables_newrule(struct net *net, struct sock *nlsk,
  			     struct sk_buff *skb, const struct nlmsghdr *nlh,
  			     const struct nlattr * const nla[],
@@@ -7500,51 -7208,21 +7507,67 @@@ static int __init nf_tables_module_init
  {
  	int err;
  
 -	nft_chain_filter_init();
 +	err = register_pernet_subsys(&nf_tables_net_ops);
 +	if (err < 0)
 +		return err;
 +
 +	err = nft_chain_filter_init();
 +	if (err < 0)
 +		goto err1;
 +
++<<<<<<< HEAD
 +	info = kmalloc_array(NFT_RULE_MAXEXPRS, sizeof(struct nft_expr_info),
 +			     GFP_KERNEL);
 +	if (info == NULL) {
 +		err = -ENOMEM;
 +		goto err2;
 +	}
  
 +	err = nf_tables_core_module_init();
 +	if (err < 0)
 +		goto err3;
++=======
+ 	err = nf_tables_core_module_init();
+ 	if (err < 0)
+ 		return err;
+ 
+ 	err = nfnetlink_subsys_register(&nf_tables_subsys);
+ 	if (err < 0)
+ 		goto err;
++>>>>>>> 2a43ecf96ba6 (netfilter: nf_tables: avoid global info storage)
  
 -	register_netdevice_notifier(&nf_tables_flowtable_notifier);
 +	err = register_netdevice_notifier(&nf_tables_flowtable_notifier);
 +	if (err < 0)
 +		goto err4;
 +
++<<<<<<< HEAD
 +	err = rhltable_init(&nft_objname_ht, &nft_objname_ht_params);
 +	if (err < 0)
 +		goto err5;
 +
 +	/* must be last */
 +	err = nfnetlink_subsys_register(&nf_tables_subsys);
 +	if (err < 0)
 +		goto err6;
  
 +	return err;
 +err6:
 +	rhltable_destroy(&nft_objname_ht);
 +err5:
 +	unregister_netdevice_notifier(&nf_tables_flowtable_notifier);
 +err4:
 +	nf_tables_core_module_exit();
 +err3:
 +	kfree(info);
 +err2:
 +	nft_chain_filter_fini();
 +err1:
 +	unregister_pernet_subsys(&nf_tables_net_ops);
++=======
+ 	return register_pernet_subsys(&nf_tables_net_ops);
+ err:
+ 	nf_tables_core_module_exit();
++>>>>>>> 2a43ecf96ba6 (netfilter: nf_tables: avoid global info storage)
  	return err;
  }
  
@@@ -7555,9 -7233,7 +7578,8 @@@ static void __exit nf_tables_module_exi
  	nft_chain_filter_fini();
  	unregister_pernet_subsys(&nf_tables_net_ops);
  	rcu_barrier();
 +	rhltable_destroy(&nft_objname_ht);
  	nf_tables_core_module_exit();
- 	kfree(info);
  }
  
  module_init(nf_tables_module_init);
* Unmerged path net/netfilter/nf_tables_api.c
