libbpf: Add BPF_EMBED_OBJ macro for embedding BPF .o files

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 917f6b7b07a46e53fa73e112d23c97d1b201a877
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/917f6b7b.failed

Add a convenience macro BPF_EMBED_OBJ, which allows to embed other files
(typically used to embed BPF .o files) into a hosting userspace programs. To
C program it is exposed as struct bpf_embed_data, containing a pointer to
raw data and its size in bytes.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
Link: https://lore.kernel.org/bpf/20191214014341.3442258-5-andriin@fb.com
(cherry picked from commit 917f6b7b07a46e53fa73e112d23c97d1b201a877)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/prog_tests/attach_probe.c
diff --cc tools/testing/selftests/bpf/prog_tests/attach_probe.c
index fad615c22e4d,b2e7c1424b07..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/attach_probe.c
+++ b/tools/testing/selftests/bpf/prog_tests/attach_probe.c
@@@ -22,6 -21,8 +22,11 @@@ ssize_t get_base_addr() 
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ BPF_EMBED_OBJ(probe, "test_attach_probe.o");
+ 
++>>>>>>> 917f6b7b07a4 (libbpf: Add BPF_EMBED_OBJ macro for embedding BPF .o files)
  void test_attach_probe(void)
  {
  	const char *kprobe_name = "kprobe/sys_nanosleep";
@@@ -49,11 -54,17 +54,18 @@@
  		return;
  	uprobe_offset = (size_t)&get_base_addr - base_addr;
  
++<<<<<<< HEAD
 +	/* load programs */
 +	err = bpf_prog_load(file, BPF_PROG_TYPE_KPROBE, &obj, &prog_fd);
 +	if (CHECK(err, "obj_load", "err %d errno %d\n", err, errno))
++=======
+ 	/* open object */
+ 	obj = bpf_object__open_mem(probe_embed.data, probe_embed.size,
+ 				   &open_opts);
+ 	if (CHECK(IS_ERR(obj), "obj_open_mem", "err %ld\n", PTR_ERR(obj)))
++>>>>>>> 917f6b7b07a4 (libbpf: Add BPF_EMBED_OBJ macro for embedding BPF .o files)
  		return;
  
 -	if (CHECK(strcmp(bpf_object__name(obj), obj_name), "obj_name",
 -		  "wrong obj name '%s', expected '%s'\n",
 -		  bpf_object__name(obj), obj_name))
 -		goto cleanup;
 -
  	kprobe_prog = bpf_object__find_program_by_title(obj, kprobe_name);
  	if (CHECK(!kprobe_prog, "find_probe",
  		  "prog '%s' not found\n", kprobe_name))
diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index d74566ebaff3..f22f3a8f20ee 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -606,6 +606,41 @@ bpf_program__bpil_offs_to_addr(struct bpf_prog_info_linear *info_linear);
  */
 LIBBPF_API int libbpf_num_possible_cpus(void);
 
+struct bpf_embed_data {
+	void *data;
+	size_t size;
+};
+
+#define BPF_EMBED_OBJ_DECLARE(NAME)					\
+extern struct bpf_embed_data NAME##_embed;				\
+extern char NAME##_data[];						\
+extern char NAME##_data_end[];
+
+#define __BPF_EMBED_OBJ(NAME, PATH, SZ, ASM_TYPE)			\
+asm (									\
+"	.pushsection \".rodata\", \"a\", @progbits		\n"	\
+"	.global "#NAME"_data					\n"	\
+#NAME"_data:							\n"	\
+"	.incbin \"" PATH "\"					\n"	\
+"	.global "#NAME"_data_end				\n"	\
+#NAME"_data_end:						\n"	\
+"	.global "#NAME"_embed					\n"	\
+"	.type "#NAME"_embed, @object				\n"	\
+"	.size "#NAME"_size, "#SZ"				\n"	\
+"	.align 8,						\n"	\
+#NAME"_embed:							\n"	\
+"	"ASM_TYPE" "#NAME"_data					\n"	\
+"	"ASM_TYPE" "#NAME"_data_end - "#NAME"_data 		\n"	\
+"	.popsection						\n"	\
+);									\
+BPF_EMBED_OBJ_DECLARE(NAME)
+
+#if __SIZEOF_POINTER__ == 4
+#define BPF_EMBED_OBJ(NAME, PATH) __BPF_EMBED_OBJ(NAME, PATH, 8, ".long")
+#else
+#define BPF_EMBED_OBJ(NAME, PATH) __BPF_EMBED_OBJ(NAME, PATH, 16, ".quad")
+#endif
+
 #ifdef __cplusplus
 } /* extern "C" */
 #endif
* Unmerged path tools/testing/selftests/bpf/prog_tests/attach_probe.c
