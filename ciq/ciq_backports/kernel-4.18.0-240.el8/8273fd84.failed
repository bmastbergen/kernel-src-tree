net: devlink: export devlink net setter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] devlink: export devlink net setter (Petr Oros) [1805958]
Rebuild_FUZZ: 93.15%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 8273fd845447820c26b38821c8ac297f40a65260
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8273fd84.failed

For newly allocated devlink instance allow drivers to set net struct

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8273fd845447820c26b38821c8ac297f40a65260)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/devlink.c
diff --cc net/core/devlink.c
index 81068caea3dc,76d835581687..000000000000
--- a/net/core/devlink.c
+++ b/net/core/devlink.c
@@@ -2688,6 -2700,72 +2696,75 @@@ devlink_resources_validate(struct devli
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static struct net *devlink_netns_get(struct sk_buff *skb,
+ 				     struct genl_info *info)
+ {
+ 	struct nlattr *netns_pid_attr = info->attrs[DEVLINK_ATTR_NETNS_PID];
+ 	struct nlattr *netns_fd_attr = info->attrs[DEVLINK_ATTR_NETNS_FD];
+ 	struct nlattr *netns_id_attr = info->attrs[DEVLINK_ATTR_NETNS_ID];
+ 	struct net *net;
+ 
+ 	if (!!netns_pid_attr + !!netns_fd_attr + !!netns_id_attr > 1) {
+ 		NL_SET_ERR_MSG(info->extack, "multiple netns identifying attributes specified");
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+ 	if (netns_pid_attr) {
+ 		net = get_net_ns_by_pid(nla_get_u32(netns_pid_attr));
+ 	} else if (netns_fd_attr) {
+ 		net = get_net_ns_by_fd(nla_get_u32(netns_fd_attr));
+ 	} else if (netns_id_attr) {
+ 		net = get_net_ns_by_id(sock_net(skb->sk),
+ 				       nla_get_u32(netns_id_attr));
+ 		if (!net)
+ 			net = ERR_PTR(-EINVAL);
+ 	} else {
+ 		WARN_ON(1);
+ 		net = ERR_PTR(-EINVAL);
+ 	}
+ 	if (IS_ERR(net)) {
+ 		NL_SET_ERR_MSG(info->extack, "Unknown network namespace");
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 	if (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN)) {
+ 		put_net(net);
+ 		return ERR_PTR(-EPERM);
+ 	}
+ 	return net;
+ }
+ 
+ static void devlink_param_notify(struct devlink *devlink,
+ 				 unsigned int port_index,
+ 				 struct devlink_param_item *param_item,
+ 				 enum devlink_command cmd);
+ 
+ static void devlink_reload_netns_change(struct devlink *devlink,
+ 					struct net *dest_net)
+ {
+ 	struct devlink_param_item *param_item;
+ 
+ 	/* Userspace needs to be notified about devlink objects
+ 	 * removed from original and entering new network namespace.
+ 	 * The rest of the devlink objects are re-created during
+ 	 * reload process so the notifications are generated separatelly.
+ 	 */
+ 
+ 	list_for_each_entry(param_item, &devlink->param_list, list)
+ 		devlink_param_notify(devlink, 0, param_item,
+ 				     DEVLINK_CMD_PARAM_DEL);
+ 	devlink_notify(devlink, DEVLINK_CMD_DEL);
+ 
+ 	__devlink_net_set(devlink, dest_net);
+ 
+ 	devlink_notify(devlink, DEVLINK_CMD_NEW);
+ 	list_for_each_entry(param_item, &devlink->param_list, list)
+ 		devlink_param_notify(devlink, 0, param_item,
+ 				     DEVLINK_CMD_PARAM_NEW);
+ }
+ 
++>>>>>>> 8273fd845447 (net: devlink: export devlink net setter)
  static bool devlink_reload_supported(struct devlink *devlink)
  {
  	return devlink->ops->reload_down && devlink->ops->reload_up;
diff --git a/include/net/devlink.h b/include/net/devlink.h
index 1be9e4aa74a5..0c45b74dffd7 100644
--- a/include/net/devlink.h
+++ b/include/net/devlink.h
@@ -43,6 +43,7 @@ struct devlink {
 	possible_net_t _net;
 	struct mutex lock;
 	bool reload_failed;
+	bool registered;
 	char priv[0] __aligned(NETDEV_ALIGN);
 };
 
@@ -770,6 +771,7 @@ static inline struct devlink *netdev_to_devlink(struct net_device *dev)
 struct ib_device;
 
 struct net *devlink_net(const struct devlink *devlink);
+void devlink_net_set(struct devlink *devlink, struct net *net);
 struct devlink *devlink_alloc(const struct devlink_ops *ops, size_t priv_size);
 int devlink_register(struct devlink *devlink, struct device *dev);
 void devlink_unregister(struct devlink *devlink);
* Unmerged path net/core/devlink.c
