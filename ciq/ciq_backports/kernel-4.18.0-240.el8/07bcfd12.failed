drm/i915/gen12: Disable preemption timeout

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Tvrtko Ursulin <tvrtko.ursulin@intel.com>
commit 07bcfd1291de77ffa9b627b4442783aba1335229
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/07bcfd12.failed

Allow super long OpenCL workloads which cannot be preempted within
the default timeout to run out of the box.

v2:
 * Make it stick out more and apply only to RCS. (Chris)

v3:
 * Mention platform override in kconfig. (Joonas)

	Signed-off-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
	Cc: Chris Wilson <chris@chris-wilson.co.uk>
	Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
	Cc: Michal Mrozek <michal.mrozek@intel.com>
	Cc: <stable@vger.kernel.org> # v5.6+
	Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
	Acked-by: Michal Mrozek <Michal.mrozek@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200312115748.29970-1-tvrtko.ursulin@linux.intel.com
(cherry picked from commit 07bcfd1291de77ffa9b627b4442783aba1335229)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/Kconfig.profile
#	drivers/gpu/drm/i915/gt/intel_engine_cs.c
diff --cc drivers/gpu/drm/i915/Kconfig.profile
index 48df8889a88a,0bfd276c19fe..000000000000
--- a/drivers/gpu/drm/i915/Kconfig.profile
+++ b/drivers/gpu/drm/i915/Kconfig.profile
@@@ -12,9 -12,42 +12,48 @@@ config DRM_I915_USERFAULT_AUTOSUSPEN
  	  May be 0 to disable the extra delay and solely use the device level
  	  runtime pm autosuspend delay tunable.
  
++<<<<<<< HEAD
 +config DRM_I915_SPIN_REQUEST
 +	int "Busywait for request completion (us)"
 +	default 5 # microseconds
++=======
+ config DRM_I915_HEARTBEAT_INTERVAL
+ 	int "Interval between heartbeat pulses (ms)"
+ 	default 2500 # milliseconds
+ 	help
+ 	  The driver sends a periodic heartbeat down all active engines to
+ 	  check the health of the GPU and undertake regular house-keeping of
+ 	  internal driver state.
+ 
+ 	  This is adjustable via
+ 	  /sys/class/drm/card?/engine/*/heartbeat_interval_ms
+ 
+ 	  May be 0 to disable heartbeats and therefore disable automatic GPU
+ 	  hang detection.
+ 
+ config DRM_I915_PREEMPT_TIMEOUT
+ 	int "Preempt timeout (ms, jiffy granularity)"
+ 	default 640 # milliseconds
+ 	help
+ 	  How long to wait (in milliseconds) for a preemption event to occur
+ 	  when submitting a new context via execlists. If the current context
+ 	  does not hit an arbitration point and yield to HW before the timer
+ 	  expires, the HW will be reset to allow the more important context
+ 	  to execute.
+ 
+ 	  This is adjustable via
+ 	  /sys/class/drm/card?/engine/*/preempt_timeout_ms
+ 
+ 	  May be 0 to disable the timeout.
+ 
+ 	  The compiled in default may get overridden at driver probe time on
+ 	  certain platforms and certain engines which will be reflected in the
+ 	  sysfs control.
+ 
+ config DRM_I915_MAX_REQUEST_BUSYWAIT
+ 	int "Busywait for request completion limit (ns)"
+ 	default 8000 # nanoseconds
++>>>>>>> 07bcfd1291de (drm/i915/gen12: Disable preemption timeout)
  	help
  	  Before sleeping waiting for a request (GPU operation) to complete,
  	  we may spend some time polling for its completion. As the IRQ may
diff --cc drivers/gpu/drm/i915/gt/intel_engine_cs.c
index f25632c9b292,3aa8a652c16d..000000000000
--- a/drivers/gpu/drm/i915/gt/intel_engine_cs.c
+++ b/drivers/gpu/drm/i915/gt/intel_engine_cs.c
@@@ -283,15 -272,12 +283,16 @@@ static void intel_engine_sanitize_mmio(
  	intel_engine_set_hwsp_writemask(engine, ~0u);
  }
  
 -static int intel_engine_setup(struct intel_gt *gt, enum intel_engine_id id)
 +static int
 +intel_engine_setup(struct drm_i915_private *dev_priv,
 +		   enum intel_engine_id id)
  {
  	const struct engine_info *info = &intel_engines[id];
+ 	struct drm_i915_private *i915 = gt->i915;
  	struct intel_engine_cs *engine;
  
 +	GEM_BUG_ON(info->class >= ARRAY_SIZE(intel_engine_classes));
 +
  	BUILD_BUG_ON(MAX_ENGINE_CLASS >= BIT(GEN11_ENGINE_CLASS_WIDTH));
  	BUILD_BUG_ON(MAX_ENGINE_INSTANCE >= BIT(GEN11_ENGINE_INSTANCE_WIDTH));
  
@@@ -312,29 -300,38 +313,50 @@@
  	BUILD_BUG_ON(BITS_PER_TYPE(engine->mask) < I915_NUM_ENGINES);
  
  	engine->id = id;
 -	engine->legacy_idx = INVALID_ENGINE;
  	engine->mask = BIT(id);
++<<<<<<< HEAD
 +	engine->i915 = dev_priv;
 +	engine->uncore = &dev_priv->uncore;
 +	__sprint_engine_name(engine->name, info);
 +	engine->hw_id = engine->guc_id = info->hw_id;
 +	engine->mmio_base = __engine_mmio_base(dev_priv, info->mmio_bases);
++=======
+ 	engine->i915 = i915;
+ 	engine->gt = gt;
+ 	engine->uncore = gt->uncore;
+ 	engine->hw_id = engine->guc_id = info->hw_id;
+ 	engine->mmio_base = __engine_mmio_base(i915, info->mmio_bases);
+ 
++>>>>>>> 07bcfd1291de (drm/i915/gen12: Disable preemption timeout)
  	engine->class = info->class;
  	engine->instance = info->instance;
 -	__sprint_engine_name(engine);
 -
 -	engine->props.heartbeat_interval_ms =
 -		CONFIG_DRM_I915_HEARTBEAT_INTERVAL;
 -	engine->props.max_busywait_duration_ns =
 -		CONFIG_DRM_I915_MAX_REQUEST_BUSYWAIT;
 -	engine->props.preempt_timeout_ms =
 -		CONFIG_DRM_I915_PREEMPT_TIMEOUT;
 -	engine->props.stop_timeout_ms =
 -		CONFIG_DRM_I915_STOP_TIMEOUT;
 -	engine->props.timeslice_duration_ms =
 -		CONFIG_DRM_I915_TIMESLICE_DURATION;
  
 +	/*
 +	 * To be overridden by the backend on setup. However to facilitate
 +	 * cleanup on error during setup, we always provide the destroy vfunc.
 +	 */
 +	engine->destroy = (typeof(engine->destroy))kfree;
 +
++<<<<<<< HEAD
 +	engine->uabi_class = intel_engine_classes[info->class].uabi_class;
 +
 +	engine->context_size = intel_engine_context_size(dev_priv,
 +							 engine->class);
 +	if (WARN_ON(engine->context_size > BIT(20)))
 +		engine->context_size = 0;
 +	if (engine->context_size)
 +		DRIVER_CAPS(dev_priv)->has_logical_contexts = true;
++=======
+ 	/* Override to uninterruptible for OpenCL workloads. */
+ 	if (INTEL_GEN(i915) == 12 && engine->class == RENDER_CLASS)
+ 		engine->props.preempt_timeout_ms = 0;
+ 
+ 	engine->context_size = intel_engine_context_size(gt, engine->class);
+ 	if (WARN_ON(engine->context_size > BIT(20)))
+ 		engine->context_size = 0;
+ 	if (engine->context_size)
+ 		DRIVER_CAPS(i915)->has_logical_contexts = true;
++>>>>>>> 07bcfd1291de (drm/i915/gen12: Disable preemption timeout)
  
  	/* Nothing to do here, execute in order of dependencies */
  	engine->schedule = NULL;
@@@ -346,8 -344,11 +368,16 @@@
  	/* Scrub mmio state on takeover */
  	intel_engine_sanitize_mmio(engine);
  
++<<<<<<< HEAD
 +	dev_priv->engine_class[info->class][info->instance] = engine;
 +	dev_priv->engine[id] = engine;
++=======
+ 	gt->engine_class[info->class][info->instance] = engine;
+ 	gt->engine[id] = engine;
+ 
+ 	i915->engine[id] = engine;
+ 
++>>>>>>> 07bcfd1291de (drm/i915/gen12: Disable preemption timeout)
  	return 0;
  }
  
* Unmerged path drivers/gpu/drm/i915/Kconfig.profile
* Unmerged path drivers/gpu/drm/i915/gt/intel_engine_cs.c
