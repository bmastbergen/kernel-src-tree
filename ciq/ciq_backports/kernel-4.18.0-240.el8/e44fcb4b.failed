sched/vtime: Rename vtime_accounting_cpu_enabled() to vtime_accounting_enabled_this_cpu()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Frederic Weisbecker <frederic@kernel.org>
commit e44fcb4b7a299602fb300b82a546c0b8a50d9d90
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e44fcb4b.failed

Standardize the naming on top of the vtime_accounting_enabled_*() base.
Also make it clear we are checking the vtime state of the
*current* CPU with this function. We'll need to add an API to check that
state on remote CPUs as well, so we must disambiguate the naming.

	Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Jacek Anaszewski <jacek.anaszewski@gmail.com>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Pavel Machek <pavel@ucw.cz>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Rafael J . Wysocki <rjw@rjwysocki.net>
	Cc: Rik van Riel <riel@surriel.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Viresh Kumar <viresh.kumar@linaro.org>
	Cc: Wanpeng Li <wanpengli@tencent.com>
	Cc: Yauheni Kaliuta <yauheni.kaliuta@redhat.com>
Link: https://lkml.kernel.org/r/20191016025700.31277-9-frederic@kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit e44fcb4b7a299602fb300b82a546c0b8a50d9d90)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/vtime.h
diff --cc include/linux/vtime.h
index a26ed10a4eac,eb2e7a19054b..000000000000
--- a/include/linux/vtime.h
+++ b/include/linux/vtime.h
@@@ -11,11 -11,15 +11,18 @@@
  struct task_struct;
  
  /*
-  * vtime_accounting_cpu_enabled() definitions/declarations
+  * vtime_accounting_enabled_this_cpu() definitions/declarations
   */
  #if defined(CONFIG_VIRT_CPU_ACCOUNTING_NATIVE)
++<<<<<<< HEAD
 +static inline bool vtime_accounting_cpu_enabled(void) { return true; }
++=======
+ 
+ static inline bool vtime_accounting_enabled_this_cpu(void) { return true; }
+ extern void vtime_task_switch(struct task_struct *prev);
+ 
++>>>>>>> e44fcb4b7a29 (sched/vtime: Rename vtime_accounting_cpu_enabled() to vtime_accounting_enabled_this_cpu())
  #elif defined(CONFIG_VIRT_CPU_ACCOUNTING_GEN)
 -
  /*
   * Checks if vtime is enabled on some CPU. Cputime readers want to be careful
   * in that case and compute the tickless cputime.
@@@ -24,23 -28,34 +31,40 @@@
   */
  static inline bool vtime_accounting_enabled(void)
  {
 -	return context_tracking_enabled();
 +	return context_tracking_is_enabled();
  }
  
- static inline bool vtime_accounting_cpu_enabled(void)
+ static inline bool vtime_accounting_enabled_this_cpu(void)
  {
  	if (vtime_accounting_enabled()) {
 -		if (context_tracking_enabled_this_cpu())
 +		if (context_tracking_cpu_is_enabled())
  			return true;
  	}
  
  	return false;
  }
++<<<<<<< HEAD
 +#else /* !CONFIG_VIRT_CPU_ACCOUNTING */
 +static inline bool vtime_accounting_cpu_enabled(void) { return false; }
++=======
+ 
+ extern void vtime_task_switch_generic(struct task_struct *prev);
+ 
+ static inline void vtime_task_switch(struct task_struct *prev)
+ {
+ 	if (vtime_accounting_enabled_this_cpu())
+ 		vtime_task_switch_generic(prev);
+ }
+ 
+ #else /* !CONFIG_VIRT_CPU_ACCOUNTING */
+ 
+ static inline bool vtime_accounting_enabled_this_cpu(void) { return false; }
+ static inline void vtime_task_switch(struct task_struct *prev) { }
+ 
++>>>>>>> e44fcb4b7a29 (sched/vtime: Rename vtime_accounting_cpu_enabled() to vtime_accounting_enabled_this_cpu())
  #endif
  
 +
  /*
   * Common vtime APIs
   */
diff --git a/include/linux/context_tracking.h b/include/linux/context_tracking.h
index d05609ad329d..130577b771b5 100644
--- a/include/linux/context_tracking.h
+++ b/include/linux/context_tracking.h
@@ -103,7 +103,7 @@ static inline void context_tracking_init(void) { }
 /* must be called with irqs disabled */
 static inline void guest_enter_irqoff(void)
 {
-	if (vtime_accounting_cpu_enabled())
+	if (vtime_accounting_enabled_this_cpu())
 		vtime_guest_enter(current);
 	else
 		current->flags |= PF_VCPU;
@@ -127,7 +127,7 @@ static inline void guest_exit_irqoff(void)
 	if (context_tracking_is_enabled())
 		__context_tracking_exit(CONTEXT_GUEST);
 
-	if (vtime_accounting_cpu_enabled())
+	if (vtime_accounting_enabled_this_cpu())
 		vtime_guest_exit(current);
 	else
 		current->flags &= ~PF_VCPU;
* Unmerged path include/linux/vtime.h
diff --git a/kernel/sched/cputime.c b/kernel/sched/cputime.c
index 1bbe60828d47..cd6d20abbe25 100644
--- a/kernel/sched/cputime.c
+++ b/kernel/sched/cputime.c
@@ -476,7 +476,7 @@ void account_process_tick(struct task_struct *p, int user_tick)
 	u64 cputime, steal;
 	struct rq *rq = this_rq();
 
-	if (vtime_accounting_cpu_enabled())
+	if (vtime_accounting_enabled_this_cpu())
 		return;
 
 	if (sched_clock_irqtime) {
diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c
index 4380af8ac923..07b98421bb80 100644
--- a/kernel/time/tick-sched.c
+++ b/kernel/time/tick-sched.c
@@ -1119,7 +1119,7 @@ static void tick_nohz_account_idle_ticks(struct tick_sched *ts)
 #ifndef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE
 	unsigned long ticks;
 
-	if (vtime_accounting_cpu_enabled())
+	if (vtime_accounting_enabled_this_cpu())
 		return;
 	/*
 	 * We stopped the tick in idle. Update process times would miss the
