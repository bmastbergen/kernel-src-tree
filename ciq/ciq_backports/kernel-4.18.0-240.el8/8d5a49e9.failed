net/tls: add helper for testing if socket is RX offloaded

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] tls: add helper for testing if socket is RX offloaded (Sabrina Dubroca) [1819627]
Rebuild_FUZZ: 96.36%
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 8d5a49e9e31ba1ddd34a54b2351d068a90c78707
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8d5a49e9.failed

There is currently no way for driver to reliably check that
the socket it has looked up is in fact RX offloaded. Add
a helper. This allows drivers to catch misbehaving firmware.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8d5a49e9e31ba1ddd34a54b2351d068a90c78707)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tls.h
diff --cc include/net/tls.h
index e16711eaf9b0,bf9eb4823933..000000000000
--- a/include/net/tls.h
+++ b/include/net/tls.h
@@@ -671,7 -647,17 +672,21 @@@ void tls_device_free_resources_tx(struc
  int tls_set_device_offload_rx(struct sock *sk, struct tls_context *ctx);
  void tls_device_offload_cleanup_rx(struct sock *sk);
  void tls_device_rx_resync_new_rec(struct sock *sk, u32 rcd_len, u32 seq);
++<<<<<<< HEAD
 +int tls_device_decrypted(struct sock *sk, struct sk_buff *skb);
++=======
+ void tls_offload_tx_resync_request(struct sock *sk, u32 got_seq, u32 exp_seq);
+ int tls_device_decrypted(struct sock *sk, struct tls_context *tls_ctx,
+ 			 struct sk_buff *skb, struct strp_msg *rxm);
+ 
+ static inline bool tls_is_sk_rx_device_offloaded(struct sock *sk)
+ {
+ 	if (!sk_fullsock(sk) ||
+ 	    smp_load_acquire(&sk->sk_destruct) != tls_device_sk_destruct)
+ 		return false;
+ 	return tls_get_ctx(sk)->rx_conf == TLS_HW;
+ }
++>>>>>>> 8d5a49e9e31b (net/tls: add helper for testing if socket is RX offloaded)
  #else
  static inline void tls_device_init(void) {}
  static inline void tls_device_cleanup(void) {}
* Unmerged path include/net/tls.h
diff --git a/net/tls/tls_device.c b/net/tls/tls_device.c
index b93c96318ef9..d40155dc809c 100644
--- a/net/tls/tls_device.c
+++ b/net/tls/tls_device.c
@@ -176,7 +176,7 @@ static void tls_icsk_clean_acked(struct sock *sk, u32 acked_seq)
  * socket and no in-flight SKBs associated with this
  * socket, so it is safe to free all the resources.
  */
-static void tls_device_sk_destruct(struct sock *sk)
+void tls_device_sk_destruct(struct sock *sk)
 {
 	struct tls_context *tls_ctx = tls_get_ctx(sk);
 	struct tls_offload_context_tx *ctx = tls_offload_ctx_tx(tls_ctx);
@@ -194,6 +194,7 @@ static void tls_device_sk_destruct(struct sock *sk)
 	if (refcount_dec_and_test(&tls_ctx->refcount))
 		tls_device_queue_ctx_destruction(tls_ctx);
 }
+EXPORT_SYMBOL_GPL(tls_device_sk_destruct);
 
 void tls_device_free_resources_tx(struct sock *sk)
 {
@@ -878,7 +879,7 @@ static void tls_device_attach(struct tls_context *ctx, struct sock *sk,
 		spin_unlock_irq(&tls_device_lock);
 
 		ctx->sk_destruct = sk->sk_destruct;
-		sk->sk_destruct = tls_device_sk_destruct;
+		smp_store_release(&sk->sk_destruct, tls_device_sk_destruct);
 	}
 }
 
