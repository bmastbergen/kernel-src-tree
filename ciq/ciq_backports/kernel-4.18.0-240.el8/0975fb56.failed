timers: Remove must_forward_clk

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Frederic Weisbecker <frederic@kernel.org>
commit 0975fb565b8b8f9e0c96d0de39fcb954833ea5e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0975fb56.failed

There is no reason to keep this guard around. The code makes sure that
base->clk remains sane and won't be forwarded beyond jiffies nor set
backward.

	Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Juri Lelli <juri.lelli@redhat.com>
Link: https://lkml.kernel.org/r/20200717140551.29076-12-frederic@kernel.org

(cherry picked from commit 0975fb565b8b8f9e0c96d0de39fcb954833ea5e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/timer.c
diff --cc kernel/time/timer.c
index a75a103821b7,8b3fb52d8c47..000000000000
--- a/kernel/time/timer.c
+++ b/kernel/time/timer.c
@@@ -884,19 -887,13 +883,29 @@@ get_target_base(struct timer_base *base
  
  static inline void forward_timer_base(struct timer_base *base)
  {
++<<<<<<< HEAD
 +#ifdef CONFIG_NO_HZ_COMMON
 +	unsigned long jnow;
 +
 +	/*
 +	 * We only forward the base when we are idle or have just come out of
 +	 * idle (must_forward_clk logic), and have a delta between base clock
 +	 * and jiffies. In the common case, run_timers will take care of it.
 +	 */
 +	if (likely(!base->must_forward_clk))
 +		return;
 +
 +	jnow = READ_ONCE(jiffies);
 +	base->must_forward_clk = base->is_idle;
++=======
+ 	unsigned long jnow = READ_ONCE(jiffies);
+ 
+ 	/*
+ 	 * No need to forward if we are close enough below jiffies.
+ 	 * Also while executing timers, base->clk is 1 offset ahead
+ 	 * of jiffies to avoid endless requeuing to current jffies.
+ 	 */
++>>>>>>> 0975fb565b8b (timers: Remove must_forward_clk)
  	if ((long)(jnow - base->clk) < 2)
  		return;
  
@@@ -1643,35 -1719,20 +1652,40 @@@ static inline void __run_timers(struct 
  	if (time_before(jiffies, base->next_expiry))
  		return;
  
 -	timer_base_lock_expiry(base);
  	raw_spin_lock_irq(&base->lock);
  
++<<<<<<< HEAD
 +	/*
 +	 * timer_base::must_forward_clk must be cleared before running
 +	 * timers so that any timer functions that call mod_timer() will
 +	 * not try to forward the base. Idle tracking / clock forwarding
 +	 * logic is only used with BASE_STD timers.
 +	 *
 +	 * The must_forward_clk flag is cleared unconditionally also for
 +	 * the deferrable base. The deferrable base is not affected by idle
 +	 * tracking and never forwarded, so clearing the flag is a NOOP.
 +	 *
 +	 * The fact that the deferrable base is never forwarded can cause
 +	 * large variations in granularity for deferrable timers, but they
 +	 * can be deferred for long periods due to idle anyway.
 +	 */
 +	base->must_forward_clk = false;
 +
++=======
++>>>>>>> 0975fb565b8b (timers: Remove must_forward_clk)
  	while (time_after_eq(jiffies, base->clk) &&
  	       time_after_eq(jiffies, base->next_expiry)) {
- 
  		levels = collect_expired_timers(base, heads);
  		base->clk++;
 -		base->next_expiry = __next_timer_interrupt(base);
  
  		while (levels--)
  			expire_timers(base, heads + levels);
  	}
++<<<<<<< HEAD
 +	base->running_timer = NULL;
++=======
++>>>>>>> 0975fb565b8b (timers: Remove must_forward_clk)
  	raw_spin_unlock_irq(&base->lock);
 -	timer_base_unlock_expiry(base);
  }
  
  /*
* Unmerged path kernel/time/timer.c
