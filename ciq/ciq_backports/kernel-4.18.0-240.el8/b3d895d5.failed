KVM: x86: Move XSAVES CPUID adjust to VMX's KVM cpu cap update

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit b3d895d5c4154156894fd1df2158d82f94fb5527
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b3d895d5.failed

Move the clearing of the XSAVES CPUID bit into VMX, which has a separate
VMCS control to enable XSAVES in non-root, to eliminate the last ugly
renmant of the undesirable "unsigned f_* = *_supported ? F(*) : 0"
pattern in the common CPUID handling code.

Drop ->xsaves_supported(), CPUID adjustment was the only user.

No functional change intended.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit b3d895d5c4154156894fd1df2158d82f94fb5527)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/cpuid.c
#	arch/x86/kvm/svm.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/include/asm/kvm_host.h
index 69418e1a3a68,d05138058a07..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -1165,14 -1172,13 +1165,18 @@@ struct kvm_x86_ops 
  
  	int (*check_intercept)(struct kvm_vcpu *vcpu,
  			       struct x86_instruction_info *info,
 -			       enum x86_intercept_stage stage,
 -			       struct x86_exception *exception);
 +			       enum x86_intercept_stage stage);
  	void (*handle_exit_irqoff)(struct kvm_vcpu *vcpu,
  		enum exit_fastpath_completion *exit_fastpath);
++<<<<<<< HEAD
 +	bool (*mpx_supported)(void);
 +	bool (*xsaves_supported)(void);
++=======
+ 
++>>>>>>> b3d895d5c415 (KVM: x86: Move XSAVES CPUID adjust to VMX's KVM cpu cap update)
  	bool (*umip_emulated)(void);
  	bool (*pt_supported)(void);
 +	bool (*pku_supported)(void);
  
  	int (*check_nested_events)(struct kvm_vcpu *vcpu);
  	void (*request_immediate_exit)(struct kvm_vcpu *vcpu);
diff --cc arch/x86/kvm/cpuid.c
index d4472786ed92,d0121199a231..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -651,10 -628,9 +651,14 @@@ static inline int __do_cpuid_func(struc
  		if (!entry)
  			goto out;
  
++<<<<<<< HEAD
 +		entry->eax &= kvm_cpuid_D_1_eax_x86_features;
 +		cpuid_mask(&entry->eax, CPUID_D_1_EAX);
++=======
+ 		cpuid_entry_mask(entry, CPUID_D_1_EAX);
++>>>>>>> b3d895d5c415 (KVM: x86: Move XSAVES CPUID adjust to VMX's KVM cpu cap update)
  		if (entry->eax & (F(XSAVES)|F(XSAVEC)))
 -			entry->ebx = xstate_required_size(supported_xcr0, true);
 +			entry->ebx = xstate_required_size(supported, true);
  		else
  			entry->ebx = 0;
  		/* Saving XSS controlled state via XSAVES isn't supported. */
diff --cc arch/x86/kvm/svm.c
index 2c7c88ef7253,30e1745c04a1..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -6091,21 -6089,6 +6091,24 @@@ static bool svm_rdtscp_supported(void
  	return boot_cpu_has(X86_FEATURE_RDTSCP);
  }
  
++<<<<<<< HEAD
 +static bool svm_invpcid_supported(void)
 +{
 +	return false;
 +}
 +
 +static bool svm_mpx_supported(void)
 +{
 +	return false;
 +}
 +
 +static bool svm_xsaves_supported(void)
 +{
 +	return boot_cpu_has(X86_FEATURE_XSAVES);
 +}
 +
++=======
++>>>>>>> b3d895d5c415 (KVM: x86: Move XSAVES CPUID adjust to VMX's KVM cpu cap update)
  static bool svm_umip_emulated(void)
  {
  	return false;
@@@ -7465,12 -7461,8 +7468,15 @@@ static struct kvm_x86_ops svm_x86_ops _
  	.cpuid_update = svm_cpuid_update,
  
  	.rdtscp_supported = svm_rdtscp_supported,
++<<<<<<< HEAD
 +	.invpcid_supported = svm_invpcid_supported,
 +	.mpx_supported = svm_mpx_supported,
 +	.xsaves_supported = svm_xsaves_supported,
++=======
++>>>>>>> b3d895d5c415 (KVM: x86: Move XSAVES CPUID adjust to VMX's KVM cpu cap update)
  	.umip_emulated = svm_umip_emulated,
  	.pt_supported = svm_pt_supported,
 +	.pku_supported = svm_pku_supported,
  
  	.set_supported_cpuid = svm_set_supported_cpuid,
  
diff --cc arch/x86/kvm/vmx/vmx.c
index b4f527d117f1,b68660916ec1..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -7251,10 -7123,52 +7251,52 @@@ static void vmx_cpuid_update(struct kvm
  	}
  }
  
 -/*
 - * Vendor specific emulation must be handled via ->set_supported_cpuid(), not
 - * vmx_set_cpu_caps(), as capabilities configured during hardware_setup() are
 - * masked against hardware/kernel support, i.e. they'd be lost.
 - */
 -static void vmx_set_supported_cpuid(struct kvm_cpuid_entry2 *entry)
 +static void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
  {
++<<<<<<< HEAD
 +	if (func == 1 && nested)
 +		entry->ecx |= feature_bit(VMX);
++=======
+ 	switch (entry->function) {
+ 	case 0x7:
+ 		if (vmx_umip_emulated())
+ 			cpuid_entry_set(entry, X86_FEATURE_UMIP);
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ }
+ 
+ static __init void vmx_set_cpu_caps(void)
+ {
+ 	kvm_set_cpu_caps();
+ 
+ 	/* CPUID 0x1 */
+ 	if (nested)
+ 		kvm_cpu_cap_set(X86_FEATURE_VMX);
+ 
+ 	/* CPUID 0x7 */
+ 	if (boot_cpu_has(X86_FEATURE_MPX) && kvm_mpx_supported())
+ 		kvm_cpu_cap_set(X86_FEATURE_MPX);
+ 	if (boot_cpu_has(X86_FEATURE_INVPCID) && cpu_has_vmx_invpcid())
+ 		kvm_cpu_cap_set(X86_FEATURE_INVPCID);
+ 	if (boot_cpu_has(X86_FEATURE_INTEL_PT) &&
+ 	    vmx_pt_mode_is_host_guest())
+ 		kvm_cpu_cap_set(X86_FEATURE_INTEL_PT);
+ 
+ 	/* PKU is not yet implemented for shadow paging. */
+ 	if (enable_ept && boot_cpu_has(X86_FEATURE_PKU) &&
+ 	    boot_cpu_has(X86_FEATURE_OSPKE))
+ 		kvm_cpu_cap_set(X86_FEATURE_PKU);
+ 
+ 	/* CPUID 0xD.1 */
+ 	if (!vmx_xsaves_supported())
+ 		kvm_cpu_cap_clear(X86_FEATURE_XSAVES);
+ 
+ 	/* CPUID 0x80000001 */
+ 	if (!cpu_has_vmx_rdtscp())
+ 		kvm_cpu_cap_clear(X86_FEATURE_RDTSCP);
++>>>>>>> b3d895d5c415 (KVM: x86: Move XSAVES CPUID adjust to VMX's KVM cpu cap update)
  }
  
  static void vmx_request_immediate_exit(struct kvm_vcpu *vcpu)
@@@ -7990,11 -7965,8 +8032,14 @@@ static struct kvm_x86_ops vmx_x86_ops _
  
  	.check_intercept = vmx_check_intercept,
  	.handle_exit_irqoff = vmx_handle_exit_irqoff,
++<<<<<<< HEAD
 +	.mpx_supported = vmx_mpx_supported,
 +	.xsaves_supported = vmx_xsaves_supported,
++=======
++>>>>>>> b3d895d5c415 (KVM: x86: Move XSAVES CPUID adjust to VMX's KVM cpu cap update)
  	.umip_emulated = vmx_umip_emulated,
  	.pt_supported = vmx_pt_supported,
 +	.pku_supported = vmx_pku_supported,
  
  	.request_immediate_exit = vmx_request_immediate_exit,
  
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/cpuid.c
* Unmerged path arch/x86/kvm/svm.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
