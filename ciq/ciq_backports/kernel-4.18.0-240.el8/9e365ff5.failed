mptcp: drop MP_JOIN request sock on syn cookies

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 9e365ff576b7c1623bbc5ef31ec652c533e2f65e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9e365ff5.failed

Currently any MPTCP socket using syn cookies will fallback to
TCP at 3rd ack time. In case of MP_JOIN requests, the RFC mandate
closing the child and sockets, but the existing error paths
do not handle the syncookie scenario correctly.

Address the issue always forcing the child shutdown in case of
MP_JOIN fallback.

Fixes: ae2dd7164943 ("mptcp: handle tcp fallback when using syn cookies")
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9e365ff576b7c1623bbc5ef31ec652c533e2f65e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/subflow.c
diff --cc net/mptcp/subflow.c
index c928ab97b1e2,3838a0b3a21f..000000000000
--- a/net/mptcp/subflow.c
+++ b/net/mptcp/subflow.c
@@@ -381,16 -430,23 +381,33 @@@ static struct sock *subflow_syn_recv_so
  {
  	struct mptcp_subflow_context *listener = mptcp_subflow_ctx(sk);
  	struct mptcp_subflow_request_sock *subflow_req;
++<<<<<<< HEAD
 +	struct tcp_options_received opt_rx;
 +	bool fallback_is_fatal = false;
++=======
+ 	struct mptcp_options_received mp_opt;
+ 	bool fallback, fallback_is_fatal;
++>>>>>>> 9e365ff576b7 (mptcp: drop MP_JOIN request sock on syn cookies)
  	struct sock *new_msk = NULL;
- 	bool fallback = false;
  	struct sock *child;
  
  	pr_debug("listener=%p, req=%p, conn=%p", listener, req, listener->conn);
  
++<<<<<<< HEAD
 +	opt_rx.mptcp.mp_capable = 0;
 +	if (tcp_rsk(req)->is_mptcp == 0)
++=======
+ 	/* After child creation we must look for 'mp_capable' even when options
+ 	 * are not parsed
+ 	 */
+ 	mp_opt.mp_capable = 0;
+ 
+ 	/* hopefully temporary handling for MP_JOIN+syncookie */
+ 	subflow_req = mptcp_subflow_rsk(req);
+ 	fallback_is_fatal = subflow_req->mp_join;
+ 	fallback = !tcp_rsk(req)->is_mptcp;
+ 	if (fallback)
++>>>>>>> 9e365ff576b7 (mptcp: drop MP_JOIN request sock on syn cookies)
  		goto create_child;
  
  	/* if the sk is MP_CAPABLE, we try to fetch the client key */
@@@ -415,12 -470,12 +431,21 @@@ create_msk
  		if (!new_msk)
  			fallback = true;
  	} else if (subflow_req->mp_join) {
++<<<<<<< HEAD
 +		fallback_is_fatal = true;
 +		opt_rx.mptcp.mp_join = 0;
 +		mptcp_get_options(skb, &opt_rx);
 +		if (!opt_rx.mptcp.mp_join ||
 +		    !subflow_hmac_valid(req, &opt_rx))
 +			return NULL;
++=======
+ 		mptcp_get_options(skb, &mp_opt);
+ 		if (!mp_opt.mp_join ||
+ 		    !subflow_hmac_valid(req, &mp_opt)) {
+ 			SUBFLOW_REQ_INC_STATS(req, MPTCP_MIB_JOINACKMAC);
+ 			fallback = true;
+ 		}
++>>>>>>> 9e365ff576b7 (mptcp: drop MP_JOIN request sock on syn cookies)
  	}
  
  create_child:
* Unmerged path net/mptcp/subflow.c
