netfilter: flowtable: refresh flow if hardware offload fails

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit f698fe40829b21088d323c8b0a7c626571528fc6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f698fe40.failed

If nf_flow_offload_add() fails to add the flow to hardware, then the
NF_FLOW_HW_REFRESH flag bit is set and the flow remains in the flowtable
software path.

If flowtable hardware offload is enabled, this patch enqueues a new
request to offload this flow to hardware.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit f698fe40829b21088d323c8b0a7c626571528fc6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_flow_table.h
#	net/netfilter/nf_flow_table_core.c
#	net/netfilter/nf_flow_table_offload.c
diff --cc include/net/netfilter/nf_flow_table.h
index ebceddb778ea,e0f709d9d547..000000000000
--- a/include/net/netfilter/nf_flow_table.h
+++ b/include/net/netfilter/nf_flow_table.h
@@@ -64,10 -88,15 +64,22 @@@ struct flow_offload_tuple_rhash 
  	struct flow_offload_tuple	tuple;
  };
  
++<<<<<<< HEAD
 +#define FLOW_OFFLOAD_SNAT	0x1
 +#define FLOW_OFFLOAD_DNAT	0x2
 +#define FLOW_OFFLOAD_DYING	0x4
 +#define FLOW_OFFLOAD_TEARDOWN	0x8
++=======
+ enum nf_flow_flags {
+ 	NF_FLOW_SNAT,
+ 	NF_FLOW_DNAT,
+ 	NF_FLOW_TEARDOWN,
+ 	NF_FLOW_HW,
+ 	NF_FLOW_HW_DYING,
+ 	NF_FLOW_HW_DEAD,
+ 	NF_FLOW_HW_REFRESH,
+ };
++>>>>>>> f698fe40829b (netfilter: flowtable: refresh flow if hardware offload fails)
  
  enum flow_offload_type {
  	NF_FLOW_OFFLOAD_UNSPEC	= 0,
diff --cc net/netfilter/nf_flow_table_core.c
index 4ccaaabe1a6c,7e91989a1b55..000000000000
--- a/net/netfilter/nf_flow_table_core.c
+++ b/net/netfilter/nf_flow_table_core.c
@@@ -248,6 -243,11 +248,14 @@@ int flow_offload_add(struct nf_flowtabl
  		return err;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (nf_flowtable_hw_offload(flow_table)) {
+ 		__set_bit(NF_FLOW_HW, &flow->flags);
+ 		nf_flow_offload_add(flow_table, flow);
+ 	}
+ 
++>>>>>>> f698fe40829b (netfilter: flowtable: refresh flow if hardware offload fails)
  	return 0;
  }
  EXPORT_SYMBOL_GPL(flow_offload_add);
* Unmerged path net/netfilter/nf_flow_table_offload.c
* Unmerged path include/net/netfilter/nf_flow_table.h
* Unmerged path net/netfilter/nf_flow_table_core.c
diff --git a/net/netfilter/nf_flow_table_ip.c b/net/netfilter/nf_flow_table_ip.c
index f8ba07c473d4..978655a21f11 100644
--- a/net/netfilter/nf_flow_table_ip.c
+++ b/net/netfilter/nf_flow_table_ip.c
@@ -231,6 +231,13 @@ static unsigned int nf_flow_xmit_xfrm(struct sk_buff *skb,
 	return NF_STOLEN;
 }
 
+static bool nf_flow_offload_refresh(struct nf_flowtable *flow_table,
+				    struct flow_offload *flow)
+{
+	return nf_flowtable_hw_offload(flow_table) &&
+	       test_and_clear_bit(NF_FLOW_HW_REFRESH, &flow->flags);
+}
+
 unsigned int
 nf_flow_offload_ip_hook(void *priv, struct sk_buff *skb,
 			const struct nf_hook_state *state)
@@ -271,6 +278,9 @@ nf_flow_offload_ip_hook(void *priv, struct sk_buff *skb,
 	if (nf_flow_state_check(flow, ip_hdr(skb)->protocol, skb, thoff))
 		return NF_ACCEPT;
 
+	if (unlikely(nf_flow_offload_refresh(flow_table, flow)))
+		nf_flow_offload_add(flow_table, flow);
+
 	if (nf_flow_offload_dst_check(&rt->dst)) {
 		flow_offload_teardown(flow);
 		return NF_ACCEPT;
@@ -497,6 +507,9 @@ nf_flow_offload_ipv6_hook(void *priv, struct sk_buff *skb,
 				sizeof(*ip6h)))
 		return NF_ACCEPT;
 
+	if (unlikely(nf_flow_offload_refresh(flow_table, flow)))
+		nf_flow_offload_add(flow_table, flow);
+
 	if (nf_flow_offload_dst_check(&rt->dst)) {
 		flow_offload_teardown(flow);
 		return NF_ACCEPT;
* Unmerged path net/netfilter/nf_flow_table_offload.c
