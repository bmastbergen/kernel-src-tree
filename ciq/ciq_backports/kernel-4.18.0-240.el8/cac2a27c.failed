ice: Support IPv4 Flow Director filters

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Henry Tieman <henry.w.tieman@intel.com>
commit cac2a27cd9ab1638e21df11ec583d2bc919a3ae3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/cac2a27c.failed

Support the addition and deletion of IPv4 filters.

Supported fields are: src-ip, dst-ip, src-port, and dst-port
Supported flow-types are: tcp4, udp4, sctp4, ip4

Example usage:

ethtool -N eth0 flow-type tcp4 src-ip 192.168.0.55 dst-ip 172.16.0.55 \
src-port 16 dst-port 12 action 32

	Signed-off-by: Henry Tieman <henry.w.tieman@intel.com>
	Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit cac2a27cd9ab1638e21df11ec583d2bc919a3ae3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice.h
#	drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
#	drivers/net/ethernet/intel/ice/ice_fdir.c
#	drivers/net/ethernet/intel/ice/ice_fdir.h
#	drivers/net/ethernet/intel/ice/ice_flex_pipe.c
#	drivers/net/ethernet/intel/ice/ice_hw_autogen.h
#	drivers/net/ethernet/intel/ice/ice_txrx.c
#	drivers/net/ethernet/intel/ice/ice_txrx.h
#	drivers/net/ethernet/intel/ice/ice_type.h
diff --cc drivers/net/ethernet/intel/ice/ice.h
index 4f1d07a3de0e,298a65a3799c..000000000000
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@@ -214,7 -217,10 +215,8 @@@ enum ice_state 
  	__ICE_CFG_BUSY,
  	__ICE_SERVICE_SCHED,
  	__ICE_SERVICE_DIS,
+ 	__ICE_FD_FLUSH_REQ,
  	__ICE_OICR_INTR_DIS,		/* Global OICR interrupt disabled */
 -	__ICE_MDD_VF_PRINT_PENDING,	/* set when MDD event handle */
 -	__ICE_VF_RESETS_DISABLED,	/* disable resets during ice_remove */
  	__ICE_STATE_NBITS		/* must be last */
  };
  
@@@ -517,6 -556,17 +519,20 @@@ int ice_get_rss(struct ice_vsi *vsi, u
  void ice_fill_rss_lut(u8 *lut, u16 rss_table_size, u16 rss_size);
  int ice_schedule_reset(struct ice_pf *pf, enum ice_reset_req reset);
  void ice_print_link_msg(struct ice_vsi *vsi, bool isup);
++<<<<<<< HEAD
++=======
+ const char *ice_stat_str(enum ice_status stat_err);
+ const char *ice_aq_str(enum ice_aq_err aq_err);
+ void ice_vsi_manage_fdir(struct ice_vsi *vsi, bool ena);
+ int ice_add_fdir_ethtool(struct ice_vsi *vsi, struct ethtool_rxnfc *cmd);
+ int ice_del_fdir_ethtool(struct ice_vsi *vsi, struct ethtool_rxnfc *cmd);
+ int ice_get_ethtool_fdir_entry(struct ice_hw *hw, struct ethtool_rxnfc *cmd);
+ int
+ ice_get_fdir_fltr_ids(struct ice_hw *hw, struct ethtool_rxnfc *cmd,
+ 		      u32 *rule_locs);
+ void ice_fdir_release_flows(struct ice_hw *hw);
+ int ice_fdir_create_dflt_rules(struct ice_pf *pf);
++>>>>>>> cac2a27cd9ab (ice: Support IPv4 Flow Director filters)
  int ice_open(struct net_device *netdev);
  int ice_stop(struct net_device *netdev);
  
diff --cc drivers/net/ethernet/intel/ice/ice_flex_pipe.c
index 285db9da3af2,16d2f599bd70..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
+++ b/drivers/net/ethernet/intel/ice/ice_flex_pipe.c
@@@ -2329,9 -2357,16 +2357,19 @@@ ice_find_prof_id(struct ice_hw *hw, enu
  		 struct ice_fv_word *fv, u8 *prof_id)
  {
  	struct ice_es *es = &hw->blk[blk].es;
 -	u16 off;
 -	u8 i;
 +	u16 off, i;
  
++<<<<<<< HEAD
 +	for (i = 0; i < es->count; i++) {
++=======
+ 	/* For FD, we don't want to re-use a existed profile with the same
+ 	 * field vector and mask. This will cause rule interference.
+ 	 */
+ 	if (blk == ICE_BLK_FD)
+ 		return ICE_ERR_DOES_NOT_EXIST;
+ 
+ 	for (i = 0; i < (u8)es->count; i++) {
++>>>>>>> cac2a27cd9ab (ice: Support IPv4 Flow Director filters)
  		off = i * es->fvw;
  
  		if (memcmp(&es->t[off], fv, es->fvw * sizeof(*fv)))
diff --cc drivers/net/ethernet/intel/ice/ice_hw_autogen.h
index 0f5121db1671,c8b037d25053..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_hw_autogen.h
+++ b/drivers/net/ethernet/intel/ice/ice_hw_autogen.h
@@@ -288,6 -290,22 +288,25 @@@
  #define GL_PWR_MODE_CTL				0x000B820C
  #define GL_PWR_MODE_CTL_CAR_MAX_BW_S		30
  #define GL_PWR_MODE_CTL_CAR_MAX_BW_M		ICE_M(0x3, 30)
++<<<<<<< HEAD
++=======
+ #define GLQF_FD_CNT				0x00460018
+ #define GLQF_FD_CNT_FD_BCNT_S			16
+ #define GLQF_FD_CNT_FD_BCNT_M			ICE_M(0x7FFF, 16)
+ #define GLQF_FD_SIZE				0x00460010
+ #define GLQF_FD_SIZE_FD_GSIZE_S			0
+ #define GLQF_FD_SIZE_FD_GSIZE_M			ICE_M(0x7FFF, 0)
+ #define GLQF_FD_SIZE_FD_BSIZE_S			16
+ #define GLQF_FD_SIZE_FD_BSIZE_M			ICE_M(0x7FFF, 16)
+ #define GLQF_FDINSET(_i, _j)			(0x00412000 + ((_i) * 4 + (_j) * 512))
+ #define GLQF_FDMASK_SEL(_i)			(0x00410400 + ((_i) * 4))
+ #define GLQF_FDSWAP(_i, _j)			(0x00413000 + ((_i) * 4 + (_j) * 512))
+ #define PFQF_FD_ENA				0x0043A000
+ #define PFQF_FD_ENA_FD_ENA_M			BIT(0)
+ #define PFQF_FD_SIZE				0x00460100
+ #define GLDCB_RTCTQ_RXQNUM_S			0
+ #define GLDCB_RTCTQ_RXQNUM_M			ICE_M(0x7FF, 0)
++>>>>>>> cac2a27cd9ab (ice: Support IPv4 Flow Director filters)
  #define GLPRT_BPRCL(_i)				(0x00381380 + ((_i) * 8))
  #define GLPRT_BPTCL(_i)				(0x00381240 + ((_i) * 8))
  #define GLPRT_CRCERRS(_i)			(0x00380100 + ((_i) * 8))
diff --cc drivers/net/ethernet/intel/ice/ice_txrx.c
index 7d646aaea571,cda7e05bd8ae..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_txrx.c
+++ b/drivers/net/ethernet/intel/ice/ice_txrx.c
@@@ -15,6 -15,90 +15,93 @@@
  
  #define ICE_RX_HDR_SIZE		256
  
++<<<<<<< HEAD
++=======
+ #define FDIR_DESC_RXDID 0x40
+ #define ICE_FDIR_CLEAN_DELAY 10
+ 
+ /**
+  * ice_prgm_fdir_fltr - Program a Flow Director filter
+  * @vsi: VSI to send dummy packet
+  * @fdir_desc: flow director descriptor
+  * @raw_packet: allocated buffer for flow director
+  */
+ int
+ ice_prgm_fdir_fltr(struct ice_vsi *vsi, struct ice_fltr_desc *fdir_desc,
+ 		   u8 *raw_packet)
+ {
+ 	struct ice_tx_buf *tx_buf, *first;
+ 	struct ice_fltr_desc *f_desc;
+ 	struct ice_tx_desc *tx_desc;
+ 	struct ice_ring *tx_ring;
+ 	struct device *dev;
+ 	dma_addr_t dma;
+ 	u32 td_cmd;
+ 	u16 i;
+ 
+ 	/* VSI and Tx ring */
+ 	if (!vsi)
+ 		return -ENOENT;
+ 	tx_ring = vsi->tx_rings[0];
+ 	if (!tx_ring || !tx_ring->desc)
+ 		return -ENOENT;
+ 	dev = tx_ring->dev;
+ 
+ 	/* we are using two descriptors to add/del a filter and we can wait */
+ 	for (i = ICE_FDIR_CLEAN_DELAY; ICE_DESC_UNUSED(tx_ring) < 2; i--) {
+ 		if (!i)
+ 			return -EAGAIN;
+ 		msleep_interruptible(1);
+ 	}
+ 
+ 	dma = dma_map_single(dev, raw_packet, ICE_FDIR_MAX_RAW_PKT_SIZE,
+ 			     DMA_TO_DEVICE);
+ 
+ 	if (dma_mapping_error(dev, dma))
+ 		return -EINVAL;
+ 
+ 	/* grab the next descriptor */
+ 	i = tx_ring->next_to_use;
+ 	first = &tx_ring->tx_buf[i];
+ 	f_desc = ICE_TX_FDIRDESC(tx_ring, i);
+ 	memcpy(f_desc, fdir_desc, sizeof(*f_desc));
+ 
+ 	i++;
+ 	i = (i < tx_ring->count) ? i : 0;
+ 	tx_desc = ICE_TX_DESC(tx_ring, i);
+ 	tx_buf = &tx_ring->tx_buf[i];
+ 
+ 	i++;
+ 	tx_ring->next_to_use = (i < tx_ring->count) ? i : 0;
+ 
+ 	memset(tx_buf, 0, sizeof(*tx_buf));
+ 	dma_unmap_len_set(tx_buf, len, ICE_FDIR_MAX_RAW_PKT_SIZE);
+ 	dma_unmap_addr_set(tx_buf, dma, dma);
+ 
+ 	tx_desc->buf_addr = cpu_to_le64(dma);
+ 	td_cmd = ICE_TXD_LAST_DESC_CMD | ICE_TX_DESC_CMD_DUMMY |
+ 		 ICE_TX_DESC_CMD_RE;
+ 
+ 	tx_buf->tx_flags = ICE_TX_FLAGS_DUMMY_PKT;
+ 	tx_buf->raw_buf = raw_packet;
+ 
+ 	tx_desc->cmd_type_offset_bsz =
+ 		ice_build_ctob(td_cmd, 0, ICE_FDIR_MAX_RAW_PKT_SIZE, 0);
+ 
+ 	/* Force memory write to complete before letting h/w know
+ 	 * there are new descriptors to fetch.
+ 	 */
+ 	wmb();
+ 
+ 	/* mark the data descriptor to be watched */
+ 	first->next_to_watch = tx_desc;
+ 
+ 	writel(tx_ring->next_to_use, tx_ring->tail);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> cac2a27cd9ab (ice: Support IPv4 Flow Director filters)
  /**
   * ice_unmap_and_free_tx_buf - Release a Tx buffer
   * @ring: the ring that owns the buffer
diff --cc drivers/net/ethernet/intel/ice/ice_txrx.h
index 83b8a1f1b3b5,7c4030caeea4..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_txrx.h
+++ b/drivers/net/ethernet/intel/ice/ice_txrx.h
@@@ -376,5 -380,9 +376,13 @@@ int ice_setup_rx_ring(struct ice_ring *
  void ice_free_tx_ring(struct ice_ring *tx_ring);
  void ice_free_rx_ring(struct ice_ring *rx_ring);
  int ice_napi_poll(struct napi_struct *napi, int budget);
- 
++<<<<<<< HEAD
++
++=======
+ int
+ ice_prgm_fdir_fltr(struct ice_vsi *vsi, struct ice_fltr_desc *fdir_desc,
+ 		   u8 *raw_packet);
+ int ice_clean_rx_irq(struct ice_ring *rx_ring, int budget);
+ void ice_clean_ctrl_tx_irq(struct ice_ring *tx_ring);
++>>>>>>> cac2a27cd9ab (ice: Support IPv4 Flow Director filters)
  #endif /* _ICE_TXRX_H_ */
diff --cc drivers/net/ethernet/intel/ice/ice_type.h
index 7074afdaa83b,fcf1f7853a41..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_type.h
+++ b/drivers/net/ethernet/intel/ice/ice_type.h
@@@ -575,6 -621,21 +575,24 @@@ struct ice_hw 
  	struct ice_blk_info blk[ICE_BLK_COUNT];
  	struct mutex fl_profs_locks[ICE_BLK_COUNT];	/* lock fltr profiles */
  	struct list_head fl_profs[ICE_BLK_COUNT];
++<<<<<<< HEAD
++=======
+ 
+ 	/* Flow Director filter info */
+ 	int fdir_active_fltr;
+ 
+ 	struct mutex fdir_fltr_lock;	/* protect Flow Director */
+ 	struct list_head fdir_list_head;
+ 
+ 	/* Book-keeping of side-band filter count per flow-type.
+ 	 * This is used to detect and handle input set changes for
+ 	 * respective flow-type.
+ 	 */
+ 	u16 fdir_fltr_cnt[ICE_FLTR_PTYPE_MAX];
+ 
+ 	struct ice_fd_hw_prof **fdir_prof;
+ 	DECLARE_BITMAP(fdir_perfect_fltr, ICE_FLTR_PTYPE_MAX);
++>>>>>>> cac2a27cd9ab (ice: Support IPv4 Flow Director filters)
  	struct mutex rss_locks;	/* protect RSS configuration */
  	struct list_head rss_list_head;
  };
* Unmerged path drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_fdir.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_fdir.h
* Unmerged path drivers/net/ethernet/intel/ice/ice.h
diff --git a/drivers/net/ethernet/intel/ice/ice_ethtool.c b/drivers/net/ethernet/intel/ice/ice_ethtool.c
index c9dd76a663e5..0d7b15251e0c 100644
--- a/drivers/net/ethernet/intel/ice/ice_ethtool.c
+++ b/drivers/net/ethernet/intel/ice/ice_ethtool.c
@@ -2525,6 +2525,10 @@ static int ice_set_rxnfc(struct net_device *netdev, struct ethtool_rxnfc *cmd)
 	struct ice_vsi *vsi = np->vsi;
 
 	switch (cmd->cmd) {
+	case ETHTOOL_SRXCLSRLINS:
+		return ice_add_fdir_ethtool(vsi, cmd);
+	case ETHTOOL_SRXCLSRLDEL:
+		return ice_del_fdir_ethtool(vsi, cmd);
 	case ETHTOOL_SRXFH:
 		return ice_set_rss_hash_opt(vsi, cmd);
 	default:
* Unmerged path drivers/net/ethernet/intel/ice/ice_ethtool_fdir.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_fdir.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_fdir.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_flex_pipe.c
diff --git a/drivers/net/ethernet/intel/ice/ice_flex_pipe.h b/drivers/net/ethernet/intel/ice/ice_flex_pipe.h
index 70db213c9fe3..568ea519af51 100644
--- a/drivers/net/ethernet/intel/ice/ice_flex_pipe.h
+++ b/drivers/net/ethernet/intel/ice/ice_flex_pipe.h
@@ -18,6 +18,9 @@
 
 #define ICE_PKG_CNT 4
 
+bool
+ice_get_open_tunnel_port(struct ice_hw *hw, enum ice_tunnel_type type,
+			 u16 *port);
 enum ice_status
 ice_create_tunnel(struct ice_hw *hw, enum ice_tunnel_type type, u16 port);
 enum ice_status ice_destroy_tunnel(struct ice_hw *hw, u16 port, bool all);
* Unmerged path drivers/net/ethernet/intel/ice/ice_hw_autogen.h
diff --git a/drivers/net/ethernet/intel/ice/ice_lan_tx_rx.h b/drivers/net/ethernet/intel/ice/ice_lan_tx_rx.h
index c10c7cf2af19..f426cbae4f07 100644
--- a/drivers/net/ethernet/intel/ice/ice_lan_tx_rx.h
+++ b/drivers/net/ethernet/intel/ice/ice_lan_tx_rx.h
@@ -40,6 +40,104 @@ union ice_32byte_rx_desc {
 	} wb; /* writeback */
 };
 
+struct ice_fltr_desc {
+	__le64 qidx_compq_space_stat;
+	__le64 dtype_cmd_vsi_fdid;
+};
+
+#define ICE_FXD_FLTR_QW0_QINDEX_S	0
+#define ICE_FXD_FLTR_QW0_QINDEX_M	(0x7FFULL << ICE_FXD_FLTR_QW0_QINDEX_S)
+#define ICE_FXD_FLTR_QW0_COMP_Q_S	11
+#define ICE_FXD_FLTR_QW0_COMP_Q_M	BIT_ULL(ICE_FXD_FLTR_QW0_COMP_Q_S)
+#define ICE_FXD_FLTR_QW0_COMP_Q_ZERO	0x0ULL
+
+#define ICE_FXD_FLTR_QW0_COMP_REPORT_S	12
+#define ICE_FXD_FLTR_QW0_COMP_REPORT_M	\
+				(0x3ULL << ICE_FXD_FLTR_QW0_COMP_REPORT_S)
+#define ICE_FXD_FLTR_QW0_COMP_REPORT_SW_FAIL	0x1ULL
+
+#define ICE_FXD_FLTR_QW0_FD_SPACE_S	14
+#define ICE_FXD_FLTR_QW0_FD_SPACE_M	(0x3ULL << ICE_FXD_FLTR_QW0_FD_SPACE_S)
+#define ICE_FXD_FLTR_QW0_FD_SPACE_GUAR_BEST		0x2ULL
+
+#define ICE_FXD_FLTR_QW0_STAT_CNT_S	16
+#define ICE_FXD_FLTR_QW0_STAT_CNT_M	\
+				(0x1FFFULL << ICE_FXD_FLTR_QW0_STAT_CNT_S)
+#define ICE_FXD_FLTR_QW0_STAT_ENA_S	29
+#define ICE_FXD_FLTR_QW0_STAT_ENA_M	(0x3ULL << ICE_FXD_FLTR_QW0_STAT_ENA_S)
+#define ICE_FXD_FLTR_QW0_STAT_ENA_PKTS		0x1ULL
+
+#define ICE_FXD_FLTR_QW0_EVICT_ENA_S	31
+#define ICE_FXD_FLTR_QW0_EVICT_ENA_M	BIT_ULL(ICE_FXD_FLTR_QW0_EVICT_ENA_S)
+#define ICE_FXD_FLTR_QW0_EVICT_ENA_FALSE	0x0ULL
+#define ICE_FXD_FLTR_QW0_EVICT_ENA_TRUE		0x1ULL
+
+#define ICE_FXD_FLTR_QW0_TO_Q_S		32
+#define ICE_FXD_FLTR_QW0_TO_Q_M		(0x7ULL << ICE_FXD_FLTR_QW0_TO_Q_S)
+#define ICE_FXD_FLTR_QW0_TO_Q_EQUALS_QINDEX	0x0ULL
+
+#define ICE_FXD_FLTR_QW0_TO_Q_PRI_S	35
+#define ICE_FXD_FLTR_QW0_TO_Q_PRI_M	(0x7ULL << ICE_FXD_FLTR_QW0_TO_Q_PRI_S)
+#define ICE_FXD_FLTR_QW0_TO_Q_PRIO1	0x1ULL
+
+#define ICE_FXD_FLTR_QW0_DPU_RECIPE_S	38
+#define ICE_FXD_FLTR_QW0_DPU_RECIPE_M	\
+			(0x3ULL << ICE_FXD_FLTR_QW0_DPU_RECIPE_S)
+#define ICE_FXD_FLTR_QW0_DPU_RECIPE_DFLT	0x0ULL
+
+#define ICE_FXD_FLTR_QW0_DROP_S		40
+#define ICE_FXD_FLTR_QW0_DROP_M		BIT_ULL(ICE_FXD_FLTR_QW0_DROP_S)
+#define ICE_FXD_FLTR_QW0_DROP_NO	0x0ULL
+#define ICE_FXD_FLTR_QW0_DROP_YES	0x1ULL
+
+#define ICE_FXD_FLTR_QW0_FLEX_PRI_S	41
+#define ICE_FXD_FLTR_QW0_FLEX_PRI_M	(0x7ULL << ICE_FXD_FLTR_QW0_FLEX_PRI_S)
+#define ICE_FXD_FLTR_QW0_FLEX_PRI_NONE	0x0ULL
+
+#define ICE_FXD_FLTR_QW0_FLEX_MDID_S	44
+#define ICE_FXD_FLTR_QW0_FLEX_MDID_M	(0xFULL << ICE_FXD_FLTR_QW0_FLEX_MDID_S)
+#define ICE_FXD_FLTR_QW0_FLEX_MDID0	0x0ULL
+
+#define ICE_FXD_FLTR_QW0_FLEX_VAL_S	48
+#define ICE_FXD_FLTR_QW0_FLEX_VAL_M	\
+				(0xFFFFULL << ICE_FXD_FLTR_QW0_FLEX_VAL_S)
+#define ICE_FXD_FLTR_QW0_FLEX_VAL0	0x0ULL
+
+#define ICE_FXD_FLTR_QW1_DTYPE_S	0
+#define ICE_FXD_FLTR_QW1_DTYPE_M	(0xFULL << ICE_FXD_FLTR_QW1_DTYPE_S)
+#define ICE_FXD_FLTR_QW1_PCMD_S		4
+#define ICE_FXD_FLTR_QW1_PCMD_M		BIT_ULL(ICE_FXD_FLTR_QW1_PCMD_S)
+#define ICE_FXD_FLTR_QW1_PCMD_ADD	0x0ULL
+#define ICE_FXD_FLTR_QW1_PCMD_REMOVE	0x1ULL
+
+#define ICE_FXD_FLTR_QW1_PROF_PRI_S	5
+#define ICE_FXD_FLTR_QW1_PROF_PRI_M	(0x7ULL << ICE_FXD_FLTR_QW1_PROF_PRI_S)
+#define ICE_FXD_FLTR_QW1_PROF_PRIO_ZERO	0x0ULL
+
+#define ICE_FXD_FLTR_QW1_PROF_S		8
+#define ICE_FXD_FLTR_QW1_PROF_M		(0x3FULL << ICE_FXD_FLTR_QW1_PROF_S)
+#define ICE_FXD_FLTR_QW1_PROF_ZERO	0x0ULL
+
+#define ICE_FXD_FLTR_QW1_FD_VSI_S	14
+#define ICE_FXD_FLTR_QW1_FD_VSI_M	(0x3FFULL << ICE_FXD_FLTR_QW1_FD_VSI_S)
+#define ICE_FXD_FLTR_QW1_SWAP_S		24
+#define ICE_FXD_FLTR_QW1_SWAP_M		BIT_ULL(ICE_FXD_FLTR_QW1_SWAP_S)
+#define ICE_FXD_FLTR_QW1_SWAP_NOT_SET	0x0ULL
+#define ICE_FXD_FLTR_QW1_SWAP_SET	0x1ULL
+
+#define ICE_FXD_FLTR_QW1_FDID_PRI_S	25
+#define ICE_FXD_FLTR_QW1_FDID_PRI_M	(0x7ULL << ICE_FXD_FLTR_QW1_FDID_PRI_S)
+#define ICE_FXD_FLTR_QW1_FDID_PRI_ONE	0x1ULL
+
+#define ICE_FXD_FLTR_QW1_FDID_MDID_S	28
+#define ICE_FXD_FLTR_QW1_FDID_MDID_M	(0xFULL << ICE_FXD_FLTR_QW1_FDID_MDID_S)
+#define ICE_FXD_FLTR_QW1_FDID_MDID_FD	0x05ULL
+
+#define ICE_FXD_FLTR_QW1_FDID_S		32
+#define ICE_FXD_FLTR_QW1_FDID_M		\
+			(0xFFFFFFFFULL << ICE_FXD_FLTR_QW1_FDID_S)
+#define ICE_FXD_FLTR_QW1_FDID_ZERO	0x0ULL
+
 struct ice_rx_ptype_decoded {
 	u32 ptype:10;
 	u32 known:1;
@@ -346,6 +444,7 @@ struct ice_tx_desc {
 enum ice_tx_desc_dtype_value {
 	ICE_TX_DESC_DTYPE_DATA		= 0x0,
 	ICE_TX_DESC_DTYPE_CTX		= 0x1,
+	ICE_TX_DESC_DTYPE_FLTR_PROG	= 0x8,
 	/* DESC_DONE - HW has completed write-back of descriptor */
 	ICE_TX_DESC_DTYPE_DESC_DONE	= 0xF,
 };
@@ -357,12 +456,14 @@ enum ice_tx_desc_cmd_bits {
 	ICE_TX_DESC_CMD_EOP			= 0x0001,
 	ICE_TX_DESC_CMD_RS			= 0x0002,
 	ICE_TX_DESC_CMD_IL2TAG1			= 0x0008,
+	ICE_TX_DESC_CMD_DUMMY			= 0x0010,
 	ICE_TX_DESC_CMD_IIPT_IPV6		= 0x0020,
 	ICE_TX_DESC_CMD_IIPT_IPV4		= 0x0040,
 	ICE_TX_DESC_CMD_IIPT_IPV4_CSUM		= 0x0060,
 	ICE_TX_DESC_CMD_L4T_EOFT_TCP		= 0x0100,
 	ICE_TX_DESC_CMD_L4T_EOFT_SCTP		= 0x0200,
 	ICE_TX_DESC_CMD_L4T_EOFT_UDP		= 0x0300,
+	ICE_TX_DESC_CMD_RE			= 0x0400,
 };
 
 #define ICE_TXD_QW1_OFFSET_S	16
* Unmerged path drivers/net/ethernet/intel/ice/ice_txrx.c
* Unmerged path drivers/net/ethernet/intel/ice/ice_txrx.h
* Unmerged path drivers/net/ethernet/intel/ice/ice_type.h
