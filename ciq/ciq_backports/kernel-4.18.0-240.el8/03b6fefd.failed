tipc: add support for broadcast rcv stats dumping

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Tuong Lien <tuong.t.lien@dektech.com.au>
commit 03b6fefd9bb4844c75faeb10df8496794e2fd5da
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/03b6fefd.failed

This commit enables dumping the statistics of a broadcast-receiver link
like the traditional 'broadcast-link' one (which is for broadcast-
sender). The link dumping can be triggered via netlink (e.g. the
iproute2/tipc tool) by the link flag - 'TIPC_NLA_LINK_BROADCAST' as the
indicator.

The name of a broadcast-receiver link of a specific peer will be in the
format: 'broadcast-link:<peer-id>'.

For example:

Link <broadcast-link:1001002>
  Window:50 packets
  RX packets:7841 fragments:2408/440 bundles:0/0
  TX packets:0 fragments:0/0 bundles:0/0
  RX naks:0 defs:124 dups:0
  TX naks:21 acks:0 retrans:0
  Congestion link:0  Send queue max:0 avg:0

In addition, the broadcast-receiver link statistics can be reset in the
usual way via netlink by specifying that link name in command.

Note: the 'tipc_link_name_ext()' is removed because the link name can
now be retrieved simply via the 'l->name'.

	Acked-by: Ying Xue <ying.xue@windriver.com>
	Acked-by: Jon Maloy <jmaloy@redhat.com>
	Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 03b6fefd9bb4844c75faeb10df8496794e2fd5da)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tipc/bcast.h
#	net/tipc/link.c
#	net/tipc/link.h
#	net/tipc/node.c
diff --cc net/tipc/bcast.h
index 9e847d9617d3,4240c95188b1..000000000000
--- a/net/tipc/bcast.h
+++ b/net/tipc/bcast.h
@@@ -93,10 -94,12 +93,17 @@@ int tipc_bcast_rcv(struct net *net, str
  void tipc_bcast_ack_rcv(struct net *net, struct tipc_link *l,
  			struct tipc_msg *hdr);
  int tipc_bcast_sync_rcv(struct net *net, struct tipc_link *l,
++<<<<<<< HEAD
 +			struct tipc_msg *hdr);
 +int tipc_nl_add_bc_link(struct net *net, struct tipc_nl_msg *msg);
++=======
+ 			struct tipc_msg *hdr,
+ 			struct sk_buff_head *retrq);
+ int tipc_nl_add_bc_link(struct net *net, struct tipc_nl_msg *msg,
+ 			struct tipc_link *bcl);
++>>>>>>> 03b6fefd9bb4 (tipc: add support for broadcast rcv stats dumping)
  int tipc_nl_bc_link_set(struct net *net, struct nlattr *attrs[]);
- int tipc_bclink_reset_stats(struct net *net);
+ int tipc_bclink_reset_stats(struct net *net, struct tipc_link *l);
  
  u32 tipc_bcast_get_broadcast_mode(struct net *net);
  u32 tipc_bcast_get_broadcast_ratio(struct net *net);
diff --cc net/tipc/link.c
index 91be69d1779e,ee3b8d0576b8..000000000000
--- a/net/tipc/link.c
+++ b/net/tipc/link.c
@@@ -512,8 -539,8 +512,13 @@@ bool tipc_link_create(struct net *net, 
   *
   * Returns true if link was created, otherwise false
   */
++<<<<<<< HEAD
 +bool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer,
 +			 int mtu, int window, u16 peer_caps,
++=======
+ bool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer, u8 *peer_id,
+ 			 int mtu, u32 min_win, u32 max_win, u16 peer_caps,
++>>>>>>> 03b6fefd9bb4 (tipc: add support for broadcast rcv stats dumping)
  			 struct sk_buff_head *inputq,
  			 struct sk_buff_head *namedq,
  			 struct tipc_link *bc_sndlink,
@@@ -1363,11 -1420,13 +1379,21 @@@ static u16 tipc_build_gap_ack_blks(stru
  	skb_queue_walk(&l->deferdq, skb) {
  		seqno = buf_seqno(skb);
  		if (unlikely(more(seqno, expect))) {
++<<<<<<< HEAD
 +			ga->gacks[n].ack = htons(expect - 1);
 +			ga->gacks[n].gap = htons(seqno - expect);
 +			if (++n >= MAX_GAP_ACK_BLKS) {
 +				pr_info_ratelimited("Too few Gap ACK blocks!\n");
 +				goto exit;
++=======
+ 			gacks[n].ack = htons(expect - 1);
+ 			gacks[n].gap = htons(seqno - expect);
+ 			if (++n >= MAX_GAP_ACK_BLKS / 2) {
+ 				pr_info_ratelimited("Gacks on %s: %d, ql: %d!\n",
+ 						    l->name, n,
+ 						    skb_queue_len(&l->deferdq));
+ 				return n;
++>>>>>>> 03b6fefd9bb4 (tipc: add support for broadcast rcv stats dumping)
  			}
  		} else if (unlikely(less(seqno, expect))) {
  			pr_warn("Unexpected skb in deferdq!\n");
@@@ -1440,7 -1595,9 +1466,13 @@@ next_gap_ack
  			_skb->priority = TC_PRIO_CONTROL;
  			__skb_queue_tail(xmitq, _skb);
  			l->stats.retransmitted++;
++<<<<<<< HEAD
 +
++=======
+ 			if (!is_uc)
+ 				r->stats.retransmitted++;
+ 			*retransmitted = true;
++>>>>>>> 03b6fefd9bb4 (tipc: add support for broadcast rcv stats dumping)
  			/* Increase actual retrans counter & mark first time */
  			if (!TIPC_SKB_CB(skb)->retr_cnt++)
  				TIPC_SKB_CB(skb)->retr_stamp = jiffies;
@@@ -2233,38 -2410,34 +2267,48 @@@ int tipc_link_bc_sync_rcv(struct tipc_l
  	return 0;
  }
  
 -int tipc_link_bc_ack_rcv(struct tipc_link *r, u16 acked, u16 gap,
 -			 struct tipc_gap_ack_blks *ga,
 -			 struct sk_buff_head *xmitq,
 -			 struct sk_buff_head *retrq)
 +void tipc_link_bc_ack_rcv(struct tipc_link *l, u16 acked,
 +			  struct sk_buff_head *xmitq)
  {
 -	struct tipc_link *l = r->bc_sndlink;
 -	bool unused = false;
 -	int rc = 0;
 +	struct sk_buff *skb, *tmp;
 +	struct tipc_link *snd_l = l->bc_sndlink;
  
 -	if (!link_is_up(r) || !r->bc_peer_is_up)
 -		return 0;
 +	if (!link_is_up(l) || !l->bc_peer_is_up)
 +		return;
  
++<<<<<<< HEAD
 +	if (!more(acked, l->acked))
 +		return;
++=======
+ 	if (gap) {
+ 		l->stats.recv_nacks++;
+ 		r->stats.recv_nacks++;
+ 	}
+ 
+ 	if (less(acked, r->acked) || (acked == r->acked && !gap && !ga))
+ 		return 0;
++>>>>>>> 03b6fefd9bb4 (tipc: add support for broadcast rcv stats dumping)
  
 -	trace_tipc_link_bc_ack(r, acked, gap, &l->transmq);
 -	tipc_link_advance_transmq(l, r, acked, gap, ga, retrq, &unused, &rc);
 -
 -	tipc_link_advance_backlog(l, xmitq);
 -	if (unlikely(!skb_queue_empty(&l->wakeupq)))
 -		link_prepare_wakeup(l);
 +	trace_tipc_link_bc_ack(l, l->acked, acked, &snd_l->transmq);
 +	/* Skip over packets peer has already acked */
 +	skb_queue_walk(&snd_l->transmq, skb) {
 +		if (more(buf_seqno(skb), l->acked))
 +			break;
 +	}
  
 -	return rc;
 +	/* Update/release the packets peer is acking now */
 +	skb_queue_walk_from_safe(&snd_l->transmq, skb, tmp) {
 +		if (more(buf_seqno(skb), acked))
 +			break;
 +		if (!--TIPC_SKB_CB(skb)->ackers) {
 +			__skb_unlink(skb, &snd_l->transmq);
 +			kfree_skb(skb);
 +		}
 +	}
 +	l->acked = acked;
 +	tipc_link_advance_backlog(snd_l, xmitq);
 +	if (unlikely(!skb_queue_empty(&snd_l->wakeupq)))
 +		link_prepare_wakeup(snd_l);
  }
  
  /* tipc_link_bc_nack_rcv(): receive broadcast nack message
diff --cc net/tipc/link.h
index adcad65e761c,fc07232c9a12..000000000000
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@@ -80,8 -80,8 +80,13 @@@ bool tipc_link_create(struct net *net, 
  		      struct sk_buff_head *inputq,
  		      struct sk_buff_head *namedq,
  		      struct tipc_link **link);
++<<<<<<< HEAD
 +bool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer,
 +			 int mtu, int window, u16 peer_caps,
++=======
+ bool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer, u8 *peer_id,
+ 			 int mtu, u32 min_win, u32 max_win, u16 peer_caps,
++>>>>>>> 03b6fefd9bb4 (tipc: add support for broadcast rcv stats dumping)
  			 struct sk_buff_head *inputq,
  			 struct sk_buff_head *namedq,
  			 struct tipc_link *bc_sndlink,
diff --cc net/tipc/node.c
index 3fe27ab13350,0312fb181d94..000000000000
--- a/net/tipc/node.c
+++ b/net/tipc/node.c
@@@ -1014,6 -1135,22 +1014,25 @@@ void tipc_node_check_dest(struct net *n
  		return;
  
  	tipc_node_write_lock(n);
++<<<<<<< HEAD
++=======
+ 	if (unlikely(!n->bc_entry.link)) {
+ 		snd_l = tipc_bc_sndlink(net);
+ 		if (!tipc_link_bc_create(net, tipc_own_addr(net),
+ 					 addr, peer_id, U16_MAX,
+ 					 tipc_link_min_win(snd_l),
+ 					 tipc_link_max_win(snd_l),
+ 					 n->capabilities,
+ 					 &n->bc_entry.inputq1,
+ 					 &n->bc_entry.namedq, snd_l,
+ 					 &n->bc_entry.link)) {
+ 			pr_warn("Broadcast rcv link creation failed, no mem\n");
+ 			tipc_node_write_unlock_fast(n);
+ 			tipc_node_put(n);
+ 			return;
+ 		}
+ 	}
++>>>>>>> 03b6fefd9bb4 (tipc: add support for broadcast rcv stats dumping)
  
  	le = &n->links[b->identity];
  
diff --git a/net/tipc/bcast.c b/net/tipc/bcast.c
index 588c2709f7d2..5c04b2abf703 100644
--- a/net/tipc/bcast.c
+++ b/net/tipc/bcast.c
@@ -553,10 +553,8 @@ void tipc_bcast_remove_peer(struct net *net, struct tipc_link *rcv_l)
 		tipc_sk_rcv(net, inputq);
 }
 
-int tipc_bclink_reset_stats(struct net *net)
+int tipc_bclink_reset_stats(struct net *net, struct tipc_link *l)
 {
-	struct tipc_link *l = tipc_bc_sndlink(net);
-
 	if (!l)
 		return -ENOPROTOOPT;
 
@@ -684,7 +682,7 @@ int tipc_bcast_init(struct net *net)
 	tn->bcbase = bb;
 	spin_lock_init(&tipc_net(net)->bclock);
 
-	if (!tipc_link_bc_create(net, 0, 0,
+	if (!tipc_link_bc_create(net, 0, 0, NULL,
 				 FB_MTU,
 				 BCLINK_WIN_DEFAULT,
 				 0,
* Unmerged path net/tipc/bcast.h
* Unmerged path net/tipc/link.c
* Unmerged path net/tipc/link.h
diff --git a/net/tipc/msg.c b/net/tipc/msg.c
index 6e9f2ea550f9..2869829e102e 100644
--- a/net/tipc/msg.c
+++ b/net/tipc/msg.c
@@ -811,19 +811,19 @@ bool tipc_msg_pskb_copy(u32 dst, struct sk_buff_head *msg,
  * @seqno: sequence number of buffer to add
  * @skb: buffer to add
  */
-void __tipc_skb_queue_sorted(struct sk_buff_head *list, u16 seqno,
+bool __tipc_skb_queue_sorted(struct sk_buff_head *list, u16 seqno,
 			     struct sk_buff *skb)
 {
 	struct sk_buff *_skb, *tmp;
 
 	if (skb_queue_empty(list) || less(seqno, buf_seqno(skb_peek(list)))) {
 		__skb_queue_head(list, skb);
-		return;
+		return true;
 	}
 
 	if (more(seqno, buf_seqno(skb_peek_tail(list)))) {
 		__skb_queue_tail(list, skb);
-		return;
+		return true;
 	}
 
 	skb_queue_walk_safe(list, _skb, tmp) {
@@ -832,9 +832,10 @@ void __tipc_skb_queue_sorted(struct sk_buff_head *list, u16 seqno,
 		if (seqno == buf_seqno(_skb))
 			break;
 		__skb_queue_before(list, _skb, skb);
-		return;
+		return true;
 	}
 	kfree_skb(skb);
+	return false;
 }
 
 void tipc_skb_reject(struct net *net, int err, struct sk_buff *skb,
diff --git a/net/tipc/msg.h b/net/tipc/msg.h
index 842e18155758..e0195cf6e3f1 100644
--- a/net/tipc/msg.h
+++ b/net/tipc/msg.h
@@ -1091,7 +1091,7 @@ bool tipc_msg_assemble(struct sk_buff_head *list);
 bool tipc_msg_reassemble(struct sk_buff_head *list, struct sk_buff_head *rcvq);
 bool tipc_msg_pskb_copy(u32 dst, struct sk_buff_head *msg,
 			struct sk_buff_head *cpy);
-void __tipc_skb_queue_sorted(struct sk_buff_head *list, u16 seqno,
+bool __tipc_skb_queue_sorted(struct sk_buff_head *list, u16 seqno,
 			     struct sk_buff *skb);
 bool tipc_msg_skb_clone(struct sk_buff_head *msg, struct sk_buff_head *cpy);
 
diff --git a/net/tipc/netlink.c b/net/tipc/netlink.c
index e9bbf4a00881..0b9fa3a5d9d0 100644
--- a/net/tipc/netlink.c
+++ b/net/tipc/netlink.c
@@ -182,7 +182,7 @@ static const struct genl_ops tipc_genl_v2_ops[] = {
 	},
 	{
 		.cmd	= TIPC_NL_LINK_GET,
-		.validate = GENL_DONT_VALIDATE_STRICT | GENL_DONT_VALIDATE_DUMP,
+		.validate = GENL_DONT_VALIDATE_STRICT,
 		.doit   = tipc_nl_node_get_link,
 		.dumpit	= tipc_nl_node_dump_link,
 	},
* Unmerged path net/tipc/node.c
diff --git a/net/tipc/trace.h b/net/tipc/trace.h
index 4d8e00483afc..71c328d7cce0 100644
--- a/net/tipc/trace.h
+++ b/net/tipc/trace.h
@@ -255,7 +255,7 @@ DECLARE_EVENT_CLASS(tipc_link_class,
 
 	TP_fast_assign(
 		__assign_str(header, header);
-		tipc_link_name_ext(l, __entry->name);
+		memcpy(__entry->name, tipc_link_name(l), TIPC_MAX_LINK_NAME);
 		tipc_link_dump(l, dqueues, __get_str(buf));
 	),
 
@@ -295,7 +295,7 @@ DECLARE_EVENT_CLASS(tipc_link_transmq_class,
 	),
 
 	TP_fast_assign(
-		tipc_link_name_ext(r, __entry->name);
+		memcpy(__entry->name, tipc_link_name(r), TIPC_MAX_LINK_NAME);
 		__entry->from = f;
 		__entry->to = t;
 		__entry->len = skb_queue_len(tq);
