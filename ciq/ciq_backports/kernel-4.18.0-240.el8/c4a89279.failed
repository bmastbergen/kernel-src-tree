crypto: ccp - Add a module parameter to specify a queue count

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Hook, Gary <Gary.Hook@amd.com>
commit c4a89279086e9c98eba659d7665b1732e0d5e3e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c4a89279.failed

Add a module parameter to limit the number of queues per CCP. The default
value (nqueues=0) is to set up every available queue on each device.

The count of queues starts from the first one found on the device (which
varies based on the device ID).

	Signed-off-by: Gary R Hook <gary.hook@amd.com>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit c4a89279086e9c98eba659d7665b1732e0d5e3e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/crypto/ccp/ccp-dev-v5.c
diff --cc drivers/crypto/ccp/ccp-dev-v5.c
index 6011165305b8,f146b51a23a5..000000000000
--- a/drivers/crypto/ccp/ccp-dev-v5.c
+++ b/drivers/crypto/ccp/ccp-dev-v5.c
@@@ -792,20 -790,7 +790,24 @@@ static int ccp5_init(struct ccp_device 
  
  	/* Find available queues */
  	qmr = ioread32(ccp->io_regs + Q_MASK_REG);
++<<<<<<< HEAD
 +	/*
 +	 * Check for a access to the registers.  If this read returns
 +	 * 0xffffffff, it's likely that the system is running a broken
 +	 * BIOS which disallows access to the device. Stop here and fail
 +	 * the initialization (but not the load, as the PSP could get
 +	 * properly initialized).
 +	 */
 +	if (qmr == 0xffffffff) {
 +		dev_notice(dev, "ccp: unable to access the device: you might be running a broken BIOS.\n");
 +		return 1;
 +	}
 +
 +	for (i = 0; i < MAX_HW_QUEUES; i++) {
 +
++=======
+ 	for (i = 0; (i < MAX_HW_QUEUES) && (ccp->cmd_q_count < ccp->max_q_count); i++) {
++>>>>>>> c4a89279086e (crypto: ccp - Add a module parameter to specify a queue count)
  		if (!(qmr & (1 << i)))
  			continue;
  
diff --git a/drivers/crypto/ccp/ccp-dev-v3.c b/drivers/crypto/ccp/ccp-dev-v3.c
index 2339a8101a52..16bc45717198 100644
--- a/drivers/crypto/ccp/ccp-dev-v3.c
+++ b/drivers/crypto/ccp/ccp-dev-v3.c
@@ -379,7 +379,7 @@ static int ccp_init(struct ccp_device *ccp)
 	/* Find available queues */
 	ccp->qim = 0;
 	qmr = ioread32(ccp->io_regs + Q_MASK_REG);
-	for (i = 0; i < MAX_HW_QUEUES; i++) {
+	for (i = 0; (i < MAX_HW_QUEUES) && (ccp->cmd_q_count < ccp->max_q_count); i++) {
 		if (!(qmr & (1 << i)))
 			continue;
 
* Unmerged path drivers/crypto/ccp/ccp-dev-v5.c
diff --git a/drivers/crypto/ccp/ccp-dev.c b/drivers/crypto/ccp/ccp-dev.c
index 3ea52a1d4b4f..cb0f5399aa8b 100644
--- a/drivers/crypto/ccp/ccp-dev.c
+++ b/drivers/crypto/ccp/ccp-dev.c
@@ -8,6 +8,7 @@
  * Author: Gary R Hook <gary.hook@amd.com>
  */
 
+#include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/kthread.h>
 #include <linux/sched.h>
@@ -26,6 +27,11 @@
 
 #include "ccp-dev.h"
 
+/* Limit CCP use to a specifed number of queues per device */
+static unsigned int nqueues = 0;
+module_param(nqueues, uint, 0444);
+MODULE_PARM_DESC(nqueues, "Number of queues per CCP (minimum 1; default: all available)");
+
 struct ccp_tasklet_data {
 	struct completion completion;
 	struct ccp_cmd *cmd;
@@ -600,6 +606,11 @@ int ccp_dev_init(struct sp_device *sp)
 		goto e_err;
 	sp->ccp_data = ccp;
 
+	if (!nqueues || (nqueues > MAX_HW_QUEUES))
+		ccp->max_q_count = MAX_HW_QUEUES;
+	else
+		ccp->max_q_count = nqueues;
+
 	ccp->vdata = (struct ccp_vdata *)sp->dev_vdata->ccp_vdata;
 	if (!ccp->vdata || !ccp->vdata->version) {
 		ret = -ENODEV;
diff --git a/drivers/crypto/ccp/ccp-dev.h b/drivers/crypto/ccp/ccp-dev.h
index 4a54e731f836..5c96d348ec09 100644
--- a/drivers/crypto/ccp/ccp-dev.h
+++ b/drivers/crypto/ccp/ccp-dev.h
@@ -379,6 +379,7 @@ struct ccp_device {
 	 */
 	struct ccp_cmd_queue cmd_q[MAX_HW_QUEUES];
 	unsigned int cmd_q_count;
+	unsigned int max_q_count;
 
 	/* Support for the CCP True RNG
 	 */
