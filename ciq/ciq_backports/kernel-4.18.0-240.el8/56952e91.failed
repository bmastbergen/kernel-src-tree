io_uring: reap poll completions while waiting for refs to drop on exit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 56952e91acc93ed624fe9da840900defb75f1323
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/56952e91.failed

If we're doing polled IO and end up having requests being submitted
async, then completions can come in while we're waiting for refs to
drop. We need to reap these manually, as nobody else will be looking
for them.

Break the wait into 1/20th of a second time waits, and check for done
poll completions if we time out. Otherwise we can have done poll
completions sitting in ctx->poll_list, which needs us to reap them but
we're just waiting for them.

	Cc: stable@vger.kernel.org
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 56952e91acc93ed624fe9da840900defb75f1323)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 0b681a205810,2038d52c5450..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -3565,6 -7344,39 +3565,42 @@@ static int io_uring_fasync(int fd, stru
  	return fasync_helper(fd, file, on, &ctx->cq_fasync);
  }
  
++<<<<<<< HEAD
++=======
+ static int io_remove_personalities(int id, void *p, void *data)
+ {
+ 	struct io_ring_ctx *ctx = data;
+ 	const struct cred *cred;
+ 
+ 	cred = idr_remove(&ctx->personality_idr, id);
+ 	if (cred)
+ 		put_cred(cred);
+ 	return 0;
+ }
+ 
+ static void io_ring_exit_work(struct work_struct *work)
+ {
+ 	struct io_ring_ctx *ctx;
+ 
+ 	ctx = container_of(work, struct io_ring_ctx, exit_work);
+ 	if (ctx->rings)
+ 		io_cqring_overflow_flush(ctx, true);
+ 
+ 	/*
+ 	 * If we're doing polled IO and end up having requests being
+ 	 * submitted async (out-of-line), then completions can come in while
+ 	 * we're waiting for refs to drop. We need to reap these manually,
+ 	 * as nobody else will be looking for them.
+ 	 */
+ 	while (!wait_for_completion_timeout(&ctx->ref_comp, HZ/20)) {
+ 		io_iopoll_reap_events(ctx);
+ 		if (ctx->rings)
+ 			io_cqring_overflow_flush(ctx, true);
+ 	}
+ 	io_ring_ctx_free(ctx);
+ }
+ 
++>>>>>>> 56952e91acc9 (io_uring: reap poll completions while waiting for refs to drop on exit)
  static void io_ring_ctx_wait_and_kill(struct io_ring_ctx *ctx)
  {
  	mutex_lock(&ctx->uring_lock);
* Unmerged path fs/io_uring.c
