iommu/vt-d: Convert to probe/release_device() call-backs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Joerg Roedel <jroedel@suse.de>
commit e5d1841f18b2401c8b449c024817cd243e363934
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e5d1841f.failed

Convert the Intel IOMMU driver to use the probe_device() and
release_device() call-backs of iommu_ops, so that the iommu core code
does the group and sysfs setup.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
	Reviewed-by: Lu Baolu <baolu.lu@linux.intel.com>
Link: https://lore.kernel.org/r/20200429133712.31431-17-joro@8bytes.org
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit e5d1841f18b2401c8b449c024817cd243e363934)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index b02ab04588c1,b906727f5b85..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -5397,55 -5793,15 +5391,64 @@@ static struct iommu_device *intel_iommu
  	if (translation_pre_enabled(iommu))
  		dev->archdata.iommu = DEFER_DEVICE_DOMAIN_INFO;
  
++<<<<<<< HEAD
 +	group = iommu_group_get_for_dev(dev);
 +
 +	if (IS_ERR(group)) {
 +		ret = PTR_ERR(group);
 +		goto unlink;
 +	}
 +
 +	iommu_group_put(group);
 +
 +	domain = iommu_get_domain_for_dev(dev);
 +	dmar_domain = to_dmar_domain(domain);
 +	if (domain->type == IOMMU_DOMAIN_DMA) {
 +		if (device_def_domain_type(dev) == IOMMU_DOMAIN_IDENTITY) {
 +			ret = iommu_request_dm_for_dev(dev);
 +			if (ret) {
 +				dmar_remove_one_dev_info(dev);
 +				dmar_domain->flags |= DOMAIN_FLAG_LOSE_CHILDREN;
 +				domain_add_dev_info(si_domain, dev);
 +				dev_info(dev,
 +					 "Device uses a private identity domain.\n");
 +			}
 +		}
 +	} else {
 +		if (device_def_domain_type(dev) == IOMMU_DOMAIN_DMA) {
 +			ret = iommu_request_dma_domain_for_dev(dev);
 +			if (ret) {
 +				dmar_remove_one_dev_info(dev);
 +				dmar_domain->flags |= DOMAIN_FLAG_LOSE_CHILDREN;
 +				if (!get_private_domain_for_dev(dev)) {
 +					dev_warn(dev,
 +						 "Failed to get a private domain.\n");
 +					ret = -ENOMEM;
 +					goto unlink;
 +				}
 +
 +				dev_info(dev,
 +					 "Device uses a private dma domain.\n");
 +			}
 +		}
 +	}
 +
 +	return 0;
 +
 +unlink:
 +	iommu_device_unlink(&iommu->iommu, dev);
 +	return ret;
++=======
+ 	if (device_needs_bounce(dev)) {
+ 		dev_info(dev, "Use Intel IOMMU bounce page dma_ops\n");
+ 		set_dma_ops(dev, &bounce_dma_ops);
+ 	}
+ 
+ 	return &iommu->iommu;
++>>>>>>> e5d1841f18b2 (iommu/vt-d: Convert to probe/release_device() call-backs)
  }
  
- static void intel_iommu_remove_device(struct device *dev)
+ static void intel_iommu_release_device(struct device *dev)
  {
  	struct intel_iommu *iommu;
  	u8 bus, devfn;
@@@ -5456,9 -5812,8 +5459,14 @@@
  
  	dmar_remove_one_dev_info(dev);
  
++<<<<<<< HEAD
 +	iommu_group_remove_device(dev);
 +
 +	iommu_device_unlink(&iommu->iommu, dev);
++=======
+ 	if (device_needs_bounce(dev))
+ 		set_dma_ops(dev, NULL);
++>>>>>>> e5d1841f18b2 (iommu/vt-d: Convert to probe/release_device() call-backs)
  }
  
  static void intel_iommu_get_resv_regions(struct device *device,
* Unmerged path drivers/iommu/intel-iommu.c
