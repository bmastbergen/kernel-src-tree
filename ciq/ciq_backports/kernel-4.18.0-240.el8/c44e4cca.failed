powerpc/eeh: Refactor around eeh_probe_devices()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sam Bobroff <sbobroff@linux.ibm.com>
commit c44e4ccadaca5884ac82b6dfffbd693bec3b583e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c44e4cca.failed

Now that EEH support for all devices (on PowerNV and pSeries) is
provided by the pcibios bus add device hooks, eeh_probe_devices() and
eeh_addr_cache_build() are redundant and can be removed.

Move the EEH enabled message into it's own function so that it can be
called from multiple places.

Note that previously on pSeries, useless EEH sysfs files were created
for some devices that did not have EEH support and this change
prevents them from being created.

	Signed-off-by: Sam Bobroff <sbobroff@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/33b0a6339d5ac88693de092d6fba984f2a5add66.1565930772.git.sbobroff@linux.ibm.com
(cherry picked from commit c44e4ccadaca5884ac82b6dfffbd693bec3b583e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/eeh_cache.c
diff --cc arch/powerpc/kernel/eeh_cache.c
index fa2287145f02,1e47cd04a1bd..000000000000
--- a/arch/powerpc/kernel/eeh_cache.c
+++ b/arch/powerpc/kernel/eeh_cache.c
@@@ -277,39 -268,28 +277,66 @@@ void eeh_addr_cache_init(void
  	spin_lock_init(&pci_io_addr_cache_root.piar_lock);
  }
  
++<<<<<<< HEAD
 +/**
 + * eeh_addr_cache_build - Build a cache of I/O addresses
 + *
 + * Build a cache of pci i/o addresses.  This cache will be used to
 + * find the pci device that corresponds to a given address.
 + * This routine scans all pci busses to build the cache.
 + * Must be run late in boot process, after the pci controllers
 + * have been scanned for devices (after all device resources are known).
 + */
 +void eeh_addr_cache_build(void)
 +{
 +	struct pci_dn *pdn;
 +	struct eeh_dev *edev;
 +	struct pci_dev *dev = NULL;
 +
 +	for_each_pci_dev(dev) {
 +		pdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);
 +		if (!pdn)
 +			continue;
 +
 +		edev = pdn_to_eeh_dev(pdn);
 +		if (!edev)
 +			continue;
 +
 +		dev->dev.archdata.edev = edev;
 +		edev->pdev = dev;
 +
 +		eeh_addr_cache_insert_dev(dev);
 +		eeh_sysfs_add_device(dev);
 +	}
 +
 +#ifdef DEBUG
 +	/* Verify tree built up above, echo back the list of addrs. */
 +	eeh_addr_cache_print(&pci_io_addr_cache_root);
 +#endif
++=======
+ static int eeh_addr_cache_show(struct seq_file *s, void *v)
+ {
+ 	struct pci_io_addr_range *piar;
+ 	struct rb_node *n;
+ 
+ 	spin_lock(&pci_io_addr_cache_root.piar_lock);
+ 	for (n = rb_first(&pci_io_addr_cache_root.rb_root); n; n = rb_next(n)) {
+ 		piar = rb_entry(n, struct pci_io_addr_range, rb_node);
+ 
+ 		seq_printf(s, "%s addr range [%pap-%pap]: %s\n",
+ 		       (piar->flags & IORESOURCE_IO) ? "i/o" : "mem",
+ 		       &piar->addr_lo, &piar->addr_hi, pci_name(piar->pcidev));
+ 	}
+ 	spin_unlock(&pci_io_addr_cache_root.piar_lock);
+ 
+ 	return 0;
+ }
+ DEFINE_SHOW_ATTRIBUTE(eeh_addr_cache);
+ 
+ void eeh_cache_debugfs_init(void)
+ {
+ 	debugfs_create_file_unsafe("eeh_address_cache", 0400,
+ 			powerpc_debugfs_root, NULL,
+ 			&eeh_addr_cache_fops);
++>>>>>>> c44e4ccadaca (powerpc/eeh: Refactor around eeh_probe_devices())
  }
diff --git a/arch/powerpc/include/asm/eeh.h b/arch/powerpc/include/asm/eeh.h
index a3749a772c38..ee969de302ea 100644
--- a/arch/powerpc/include/asm/eeh.h
+++ b/arch/powerpc/include/asm/eeh.h
@@ -296,13 +296,12 @@ struct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe);
 
 struct eeh_dev *eeh_dev_init(struct pci_dn *pdn);
 void eeh_dev_phb_init_dynamic(struct pci_controller *phb);
-void eeh_probe_devices(void);
+void eeh_show_enabled(void);
 int __init eeh_ops_register(struct eeh_ops *ops);
 int __exit eeh_ops_unregister(const char *name);
 int eeh_check_failure(const volatile void __iomem *token);
 int eeh_dev_check_failure(struct eeh_dev *edev);
 void eeh_addr_cache_init(void);
-void eeh_addr_cache_build(void);
 void eeh_add_device_early(struct pci_dn *);
 void eeh_add_device_tree_early(struct pci_dn *);
 void eeh_add_device_late(struct pci_dev *);
@@ -344,7 +343,7 @@ static inline bool eeh_enabled(void)
         return false;
 }
 
-static inline void eeh_probe_devices(void) { }
+static inline void eeh_show_enabled(void) { }
 
 static inline void *eeh_dev_init(struct pci_dn *pdn, void *data)
 {
@@ -362,8 +361,6 @@ static inline int eeh_check_failure(const volatile void __iomem *token)
 
 static inline void eeh_addr_cache_init(void) { }
 
-static inline void eeh_addr_cache_build(void) { }
-
 static inline void eeh_add_device_early(struct pci_dn *pdn) { }
 
 static inline void eeh_add_device_tree_early(struct pci_dn *pdn) { }
diff --git a/arch/powerpc/kernel/eeh.c b/arch/powerpc/kernel/eeh.c
index c8008926dde8..a533da9252c4 100644
--- a/arch/powerpc/kernel/eeh.c
+++ b/arch/powerpc/kernel/eeh.c
@@ -156,6 +156,16 @@ static int __init eeh_setup(char *str)
 }
 __setup("eeh=", eeh_setup);
 
+void eeh_show_enabled(void)
+{
+	if (eeh_has_flag(EEH_FORCE_DISABLED))
+		pr_info("EEH: Recovery disabled by kernel parameter.\n");
+	else if (eeh_has_flag(EEH_ENABLED))
+		pr_info("EEH: Capable adapter found: recovery enabled.\n");
+	else
+		pr_info("EEH: No capable adapters found: recovery disabled.\n");
+}
+
 /*
  * This routine captures assorted PCI configuration space data
  * for the indicated PCI device, and puts them into a buffer
@@ -1053,23 +1063,6 @@ static struct notifier_block eeh_reboot_nb = {
 	.notifier_call = eeh_reboot_notifier,
 };
 
-void eeh_probe_devices(void)
-{
-	struct pci_controller *hose, *tmp;
-	struct pci_dn *pdn;
-
-	/* Enable EEH for all adapters */
-	list_for_each_entry_safe(hose, tmp, &hose_list, list_node) {
-		pdn = hose->pci_data;
-		traverse_pci_dn(pdn, eeh_ops->probe, NULL);
-	}
-	if (eeh_enabled())
-		pr_info("EEH: PCI Enhanced I/O Error Handling Enabled\n");
-	else
-		pr_info("EEH: No capable adapters found\n");
-
-}
-
 /**
  * eeh_init - EEH initialization
  *
* Unmerged path arch/powerpc/kernel/eeh_cache.c
diff --git a/arch/powerpc/platforms/powernv/eeh-powernv.c b/arch/powerpc/platforms/powernv/eeh-powernv.c
index 06958131a19d..10c0ba91e446 100644
--- a/arch/powerpc/platforms/powernv/eeh-powernv.c
+++ b/arch/powerpc/platforms/powernv/eeh-powernv.c
@@ -236,9 +236,7 @@ int pnv_eeh_post_init(void)
 	struct pnv_phb *phb;
 	int ret = 0;
 
-	/* Probe devices & build address cache */
-	eeh_probe_devices();
-	eeh_addr_cache_build();
+	eeh_show_enabled();
 
 	/* Register OPAL event notifier */
 	eeh_event_irq = opal_event_request(ilog2(OPAL_EVENT_PCI_ERROR));
diff --git a/arch/powerpc/platforms/pseries/pci.c b/arch/powerpc/platforms/pseries/pci.c
index 37a77e57893e..d6a5f4f27507 100644
--- a/arch/powerpc/platforms/pseries/pci.c
+++ b/arch/powerpc/platforms/pseries/pci.c
@@ -242,8 +242,7 @@ void __init pSeries_final_fixup(void)
 
 	pSeries_request_regions();
 
-	eeh_probe_devices();
-	eeh_addr_cache_build();
+	eeh_show_enabled();
 
 #ifdef CONFIG_PCI_IOV
 	ppc_md.pcibios_sriov_enable = pseries_pcibios_sriov_enable;
