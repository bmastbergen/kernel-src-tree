ice: Wait for VF to be reset/ready before configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Brett Creeley <brett.creeley@intel.com>
commit c54d209c78b8a3d0a75e710993833ebe1eb3273b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c54d209c.failed

The configuration/command below is failing when the VF in the xml
file is already bound to the host iavf driver.

pci_0000_af_0_0.xml:

<interface type='hostdev' managed='yes'>
<source>
<address type='pci' domain='0x0000' bus='0xaf' slot='0x0' function='0x0'/>
</source>
<mac address='00:de:ad:00:11:01'/>
</interface>

> virsh attach-device domain_name pci_0000_af_0_0.xml
error: Failed to attach device from pci_0000_af_0_0.xml
error: Cannot set interface MAC/vlanid to 00:de:ad:00:11:01/0 for
	ifname ens1f1 vf 0: Device or resource busy

This is failing because the VF has not been completely removed/reset
after being unbound (via the virsh command above) from the host iavf
driver and ice_set_vf_mac() checks if the VF is disabled before waiting
for the reset to finish.

Fix this by waiting for the VF remove/reset process to happen before
checking if the VF is disabled. Also, since many functions for VF
administration on the PF were more or less calling the same 3 functions
(ice_wait_on_vf_reset(), ice_is_vf_disabled(), and ice_check_vf_init())
move these into the helper function ice_check_vf_ready_for_cfg(). Then
call this function in any flow that attempts to configure/query a VF
from the PF.

Lastly, increase the maximum wait time in ice_wait_on_vf_reset() to
800ms, and modify/add the #define(s) that determine the wait time.
This was done for robustness because in rare/stress cases VF removal can
take a max of ~800ms and previously the wait was a max of ~300ms.

	Signed-off-by: Brett Creeley <brett.creeley@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit c54d209c78b8a3d0a75e710993833ebe1eb3273b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
index 2eac2e9db5ee,75c70d432c72..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
@@@ -2721,8 -2738,7 +2763,12 @@@ ice_set_vf_port_vlan(struct net_device 
  	struct ice_vsi *vsi;
  	struct device *dev;
  	struct ice_vf *vf;
++<<<<<<< HEAD
 +	u16 vlanprio;
 +	int ret = 0;
++=======
+ 	int ret;
++>>>>>>> c54d209c78b8 (ice: Wait for VF to be reset/ready before configuration)
  
  	dev = ice_pf_to_dev(pf);
  	if (ice_validate_vf_id(pf, vf_id))
@@@ -2741,25 -2756,23 +2787,27 @@@
  
  	vf = &pf->vf[vf_id];
  	vsi = pf->vsi[vf->lan_vsi_idx];
- 	if (ice_check_vf_init(pf, vf))
- 		return -EBUSY;
+ 
+ 	ret = ice_check_vf_ready_for_cfg(vf);
+ 	if (ret)
+ 		return ret;
  
 -	if (le16_to_cpu(vsi->info.pvid) == vlanprio) {
 +	vlanprio = vlan_id | (qos << VLAN_PRIO_SHIFT);
 +
 +	if (vf->port_vlan_info == vlanprio) {
  		/* duplicate request, so just return success */
  		dev_dbg(dev, "Duplicate pvid %d request\n", vlanprio);
- 		return ret;
+ 		return 0;
  	}
  
 -	/* If PVID, then remove all filters on the old VLAN */
 -	if (vsi->info.pvid)
 -		ice_vsi_kill_vlan(vsi, (le16_to_cpu(vsi->info.pvid) &
 -				  VLAN_VID_MASK));
 -
  	if (vlan_id || qos) {
 +		/* remove VLAN 0 filter set by default when transitioning from
 +		 * no port VLAN to a port VLAN. No change to old port VLAN on
 +		 * failure.
 +		 */
 +		ret = ice_vsi_kill_vlan(vsi, 0);
 +		if (ret)
 +			return ret;
  		ret = ice_vsi_manage_pvid(vsi, vlanprio, true);
  		if (ret)
  			return ret;
@@@ -2779,20 -2785,18 +2827,28 @@@
  		dev_info(dev, "Setting VLAN %d, QoS 0x%x on VF %d\n",
  			 vlan_id, qos, vf_id);
  
 -		/* add new VLAN filter for each MAC */
 +		/* add VLAN filter for the port VLAN */
  		ret = ice_vsi_add_vlan(vsi, vlan_id);
  		if (ret)
++<<<<<<< HEAD
 +			goto error_manage_pvid;
++=======
+ 			return ret;
++>>>>>>> c54d209c78b8 (ice: Wait for VF to be reset/ready before configuration)
  	}
 +	/* remove old port VLAN filter with valid VLAN ID or QoS fields */
 +	if (vf->port_vlan_info)
 +		ice_vsi_kill_vlan(vsi, vf->port_vlan_info & VLAN_VID_MASK);
  
 -	/* The Port VLAN needs to be saved across resets the same as the
 -	 * default LAN MAC address.
 -	 */
 -	vf->port_vlan_id = le16_to_cpu(vsi->info.pvid);
 +	/* keep port VLAN information persistent on resets */
 +	vf->port_vlan_info = le16_to_cpu(vsi->info.pvid);
  
++<<<<<<< HEAD
 +error_manage_pvid:
 +	return ret;
++=======
+ 	return 0;
++>>>>>>> c54d209c78b8 (ice: Wait for VF to be reset/ready before configuration)
  }
  
  /**
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
diff --git a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
index 807fb154e59b..6273bc74d85a 100644
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
@@ -33,7 +33,8 @@
 #define ICE_MAX_POLICY_INTR_PER_VF	33
 #define ICE_MIN_INTR_PER_VF		(ICE_MIN_QS_PER_VF + 1)
 #define ICE_DFLT_INTR_PER_VF		(ICE_DFLT_QS_PER_VF + 1)
-#define ICE_MAX_VF_RESET_WAIT		15
+#define ICE_MAX_VF_RESET_TRIES		40
+#define ICE_MAX_VF_RESET_SLEEP_MS	20
 
 #define ice_for_each_vf(pf, i) \
 	for ((i) = 0; (i) < (pf)->num_alloc_vfs; (i)++)
