netdev: pass the stuck queue to the timeout handler

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [netdev] pass the stuck queue to the timeout handler (Ivan Vecera) [1811203]
Rebuild_FUZZ: 91.49%
commit-author Michael S. Tsirkin <mst@redhat.com>
commit 0290bd291cc0e0488e35e66bf39efcd7d9d9122b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0290bd29.failed

This allows incrementing the correct timeout statistic without any mess.
Down the road, devices can learn to reset just the specific queue.

The patch was generated with the following script:

use strict;
use warnings;

our $^I = '.bak';

my @work = (
["arch/m68k/emu/nfeth.c", "nfeth_tx_timeout"],
["arch/um/drivers/net_kern.c", "uml_net_tx_timeout"],
["arch/um/drivers/vector_kern.c", "vector_net_tx_timeout"],
["arch/xtensa/platforms/iss/network.c", "iss_net_tx_timeout"],
["drivers/char/pcmcia/synclink_cs.c", "hdlcdev_tx_timeout"],
["drivers/infiniband/ulp/ipoib/ipoib_main.c", "ipoib_timeout"],
["drivers/infiniband/ulp/ipoib/ipoib_main.c", "ipoib_timeout"],
["drivers/message/fusion/mptlan.c", "mpt_lan_tx_timeout"],
["drivers/misc/sgi-xp/xpnet.c", "xpnet_dev_tx_timeout"],
["drivers/net/appletalk/cops.c", "cops_timeout"],
["drivers/net/arcnet/arcdevice.h", "arcnet_timeout"],
["drivers/net/arcnet/arcnet.c", "arcnet_timeout"],
["drivers/net/arcnet/com20020.c", "arcnet_timeout"],
["drivers/net/ethernet/3com/3c509.c", "el3_tx_timeout"],
["drivers/net/ethernet/3com/3c515.c", "corkscrew_timeout"],
["drivers/net/ethernet/3com/3c574_cs.c", "el3_tx_timeout"],
["drivers/net/ethernet/3com/3c589_cs.c", "el3_tx_timeout"],
["drivers/net/ethernet/3com/3c59x.c", "vortex_tx_timeout"],
["drivers/net/ethernet/3com/3c59x.c", "vortex_tx_timeout"],
["drivers/net/ethernet/3com/typhoon.c", "typhoon_tx_timeout"],
["drivers/net/ethernet/8390/8390.h", "ei_tx_timeout"],
["drivers/net/ethernet/8390/8390.h", "eip_tx_timeout"],
["drivers/net/ethernet/8390/8390.c", "ei_tx_timeout"],
["drivers/net/ethernet/8390/8390p.c", "eip_tx_timeout"],
["drivers/net/ethernet/8390/ax88796.c", "ax_ei_tx_timeout"],
["drivers/net/ethernet/8390/axnet_cs.c", "axnet_tx_timeout"],
["drivers/net/ethernet/8390/etherh.c", "__ei_tx_timeout"],
["drivers/net/ethernet/8390/hydra.c", "__ei_tx_timeout"],
["drivers/net/ethernet/8390/mac8390.c", "__ei_tx_timeout"],
["drivers/net/ethernet/8390/mcf8390.c", "__ei_tx_timeout"],
["drivers/net/ethernet/8390/lib8390.c", "__ei_tx_timeout"],
["drivers/net/ethernet/8390/ne2k-pci.c", "ei_tx_timeout"],
["drivers/net/ethernet/8390/pcnet_cs.c", "ei_tx_timeout"],
["drivers/net/ethernet/8390/smc-ultra.c", "ei_tx_timeout"],
["drivers/net/ethernet/8390/wd.c", "ei_tx_timeout"],
["drivers/net/ethernet/8390/zorro8390.c", "__ei_tx_timeout"],
["drivers/net/ethernet/adaptec/starfire.c", "tx_timeout"],
["drivers/net/ethernet/agere/et131x.c", "et131x_tx_timeout"],
["drivers/net/ethernet/allwinner/sun4i-emac.c", "emac_timeout"],
["drivers/net/ethernet/alteon/acenic.c", "ace_watchdog"],
["drivers/net/ethernet/amazon/ena/ena_netdev.c", "ena_tx_timeout"],
["drivers/net/ethernet/amd/7990.h", "lance_tx_timeout"],
["drivers/net/ethernet/amd/7990.c", "lance_tx_timeout"],
["drivers/net/ethernet/amd/a2065.c", "lance_tx_timeout"],
["drivers/net/ethernet/amd/am79c961a.c", "am79c961_timeout"],
["drivers/net/ethernet/amd/amd8111e.c", "amd8111e_tx_timeout"],
["drivers/net/ethernet/amd/ariadne.c", "ariadne_tx_timeout"],
["drivers/net/ethernet/amd/atarilance.c", "lance_tx_timeout"],
["drivers/net/ethernet/amd/au1000_eth.c", "au1000_tx_timeout"],
["drivers/net/ethernet/amd/declance.c", "lance_tx_timeout"],
["drivers/net/ethernet/amd/lance.c", "lance_tx_timeout"],
["drivers/net/ethernet/amd/mvme147.c", "lance_tx_timeout"],
["drivers/net/ethernet/amd/ni65.c", "ni65_timeout"],
["drivers/net/ethernet/amd/nmclan_cs.c", "mace_tx_timeout"],
["drivers/net/ethernet/amd/pcnet32.c", "pcnet32_tx_timeout"],
["drivers/net/ethernet/amd/sunlance.c", "lance_tx_timeout"],
["drivers/net/ethernet/amd/xgbe/xgbe-drv.c", "xgbe_tx_timeout"],
["drivers/net/ethernet/apm/xgene-v2/main.c", "xge_timeout"],
["drivers/net/ethernet/apm/xgene/xgene_enet_main.c", "xgene_enet_timeout"],
["drivers/net/ethernet/apple/macmace.c", "mace_tx_timeout"],
["drivers/net/ethernet/atheros/ag71xx.c", "ag71xx_tx_timeout"],
["drivers/net/ethernet/atheros/alx/main.c", "alx_tx_timeout"],
["drivers/net/ethernet/atheros/atl1c/atl1c_main.c", "atl1c_tx_timeout"],
["drivers/net/ethernet/atheros/atl1e/atl1e_main.c", "atl1e_tx_timeout"],
["drivers/net/ethernet/atheros/atlx/atl.c", "atlx_tx_timeout"],
["drivers/net/ethernet/atheros/atlx/atl1.c", "atlx_tx_timeout"],
["drivers/net/ethernet/atheros/atlx/atl2.c", "atl2_tx_timeout"],
["drivers/net/ethernet/broadcom/b44.c", "b44_tx_timeout"],
["drivers/net/ethernet/broadcom/bcmsysport.c", "bcm_sysport_tx_timeout"],
["drivers/net/ethernet/broadcom/bnx2.c", "bnx2_tx_timeout"],
["drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h", "bnx2x_tx_timeout"],
["drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c", "bnx2x_tx_timeout"],
["drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c", "bnx2x_tx_timeout"],
["drivers/net/ethernet/broadcom/bnxt/bnxt.c", "bnxt_tx_timeout"],
["drivers/net/ethernet/broadcom/genet/bcmgenet.c", "bcmgenet_timeout"],
["drivers/net/ethernet/broadcom/sb1250-mac.c", "sbmac_tx_timeout"],
["drivers/net/ethernet/broadcom/tg3.c", "tg3_tx_timeout"],
["drivers/net/ethernet/calxeda/xgmac.c", "xgmac_tx_timeout"],
["drivers/net/ethernet/cavium/liquidio/lio_main.c", "liquidio_tx_timeout"],
["drivers/net/ethernet/cavium/liquidio/lio_vf_main.c", "liquidio_tx_timeout"],
["drivers/net/ethernet/cavium/liquidio/lio_vf_rep.c", "lio_vf_rep_tx_timeout"],
["drivers/net/ethernet/cavium/thunder/nicvf_main.c", "nicvf_tx_timeout"],
["drivers/net/ethernet/cirrus/cs89x0.c", "net_timeout"],
["drivers/net/ethernet/cisco/enic/enic_main.c", "enic_tx_timeout"],
["drivers/net/ethernet/cisco/enic/enic_main.c", "enic_tx_timeout"],
["drivers/net/ethernet/cortina/gemini.c", "gmac_tx_timeout"],
["drivers/net/ethernet/davicom/dm9000.c", "dm9000_timeout"],
["drivers/net/ethernet/dec/tulip/de2104x.c", "de_tx_timeout"],
["drivers/net/ethernet/dec/tulip/tulip_core.c", "tulip_tx_timeout"],
["drivers/net/ethernet/dec/tulip/winbond-840.c", "tx_timeout"],
["drivers/net/ethernet/dlink/dl2k.c", "rio_tx_timeout"],
["drivers/net/ethernet/dlink/sundance.c", "tx_timeout"],
["drivers/net/ethernet/emulex/benet/be_main.c", "be_tx_timeout"],
["drivers/net/ethernet/ethoc.c", "ethoc_tx_timeout"],
["drivers/net/ethernet/faraday/ftgmac100.c", "ftgmac100_tx_timeout"],
["drivers/net/ethernet/fealnx.c", "fealnx_tx_timeout"],
["drivers/net/ethernet/freescale/dpaa/dpaa_eth.c", "dpaa_tx_timeout"],
["drivers/net/ethernet/freescale/fec_main.c", "fec_timeout"],
["drivers/net/ethernet/freescale/fec_mpc52xx.c", "mpc52xx_fec_tx_timeout"],
["drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c", "fs_timeout"],
["drivers/net/ethernet/freescale/gianfar.c", "gfar_timeout"],
["drivers/net/ethernet/freescale/ucc_geth.c", "ucc_geth_timeout"],
["drivers/net/ethernet/fujitsu/fmvj18x_cs.c", "fjn_tx_timeout"],
["drivers/net/ethernet/google/gve/gve_main.c", "gve_tx_timeout"],
["drivers/net/ethernet/hisilicon/hip04_eth.c", "hip04_timeout"],
["drivers/net/ethernet/hisilicon/hix5hd2_gmac.c", "hix5hd2_net_timeout"],
["drivers/net/ethernet/hisilicon/hns/hns_enet.c", "hns_nic_net_timeout"],
["drivers/net/ethernet/hisilicon/hns3/hns3_enet.c", "hns3_nic_net_timeout"],
["drivers/net/ethernet/huawei/hinic/hinic_main.c", "hinic_tx_timeout"],
["drivers/net/ethernet/i825xx/82596.c", "i596_tx_timeout"],
["drivers/net/ethernet/i825xx/ether1.c", "ether1_timeout"],
["drivers/net/ethernet/i825xx/lib82596.c", "i596_tx_timeout"],
["drivers/net/ethernet/i825xx/sun3_82586.c", "sun3_82586_timeout"],
["drivers/net/ethernet/ibm/ehea/ehea_main.c", "ehea_tx_watchdog"],
["drivers/net/ethernet/ibm/emac/core.c", "emac_tx_timeout"],
["drivers/net/ethernet/ibm/emac/core.c", "emac_tx_timeout"],
["drivers/net/ethernet/ibm/ibmvnic.c", "ibmvnic_tx_timeout"],
["drivers/net/ethernet/intel/e100.c", "e100_tx_timeout"],
["drivers/net/ethernet/intel/e1000/e1000_main.c", "e1000_tx_timeout"],
["drivers/net/ethernet/intel/e1000e/netdev.c", "e1000_tx_timeout"],
["drivers/net/ethernet/intel/fm10k/fm10k_netdev.c", "fm10k_tx_timeout"],
["drivers/net/ethernet/intel/i40e/i40e_main.c", "i40e_tx_timeout"],
["drivers/net/ethernet/intel/iavf/iavf_main.c", "iavf_tx_timeout"],
["drivers/net/ethernet/intel/ice/ice_main.c", "ice_tx_timeout"],
["drivers/net/ethernet/intel/ice/ice_main.c", "ice_tx_timeout"],
["drivers/net/ethernet/intel/igb/igb_main.c", "igb_tx_timeout"],
["drivers/net/ethernet/intel/igbvf/netdev.c", "igbvf_tx_timeout"],
["drivers/net/ethernet/intel/ixgb/ixgb_main.c", "ixgb_tx_timeout"],
["drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c", "adapter->netdev->netdev_ops->ndo_tx_timeout(adapter->netdev);"],
["drivers/net/ethernet/intel/ixgbe/ixgbe_main.c", "ixgbe_tx_timeout"],
["drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c", "ixgbevf_tx_timeout"],
["drivers/net/ethernet/jme.c", "jme_tx_timeout"],
["drivers/net/ethernet/korina.c", "korina_tx_timeout"],
["drivers/net/ethernet/lantiq_etop.c", "ltq_etop_tx_timeout"],
["drivers/net/ethernet/marvell/mv643xx_eth.c", "mv643xx_eth_tx_timeout"],
["drivers/net/ethernet/marvell/pxa168_eth.c", "pxa168_eth_tx_timeout"],
["drivers/net/ethernet/marvell/skge.c", "skge_tx_timeout"],
["drivers/net/ethernet/marvell/sky2.c", "sky2_tx_timeout"],
["drivers/net/ethernet/marvell/sky2.c", "sky2_tx_timeout"],
["drivers/net/ethernet/mediatek/mtk_eth_soc.c", "mtk_tx_timeout"],
["drivers/net/ethernet/mellanox/mlx4/en_netdev.c", "mlx4_en_tx_timeout"],
["drivers/net/ethernet/mellanox/mlx4/en_netdev.c", "mlx4_en_tx_timeout"],
["drivers/net/ethernet/mellanox/mlx5/core/en_main.c", "mlx5e_tx_timeout"],
["drivers/net/ethernet/micrel/ks8842.c", "ks8842_tx_timeout"],
["drivers/net/ethernet/micrel/ksz884x.c", "netdev_tx_timeout"],
["drivers/net/ethernet/microchip/enc28j60.c", "enc28j60_tx_timeout"],
["drivers/net/ethernet/microchip/encx24j600.c", "encx24j600_tx_timeout"],
["drivers/net/ethernet/natsemi/sonic.h", "sonic_tx_timeout"],
["drivers/net/ethernet/natsemi/sonic.c", "sonic_tx_timeout"],
["drivers/net/ethernet/natsemi/jazzsonic.c", "sonic_tx_timeout"],
["drivers/net/ethernet/natsemi/macsonic.c", "sonic_tx_timeout"],
["drivers/net/ethernet/natsemi/natsemi.c", "ns_tx_timeout"],
["drivers/net/ethernet/natsemi/ns83820.c", "ns83820_tx_timeout"],
["drivers/net/ethernet/natsemi/xtsonic.c", "sonic_tx_timeout"],
["drivers/net/ethernet/neterion/s2io.h", "s2io_tx_watchdog"],
["drivers/net/ethernet/neterion/s2io.c", "s2io_tx_watchdog"],
["drivers/net/ethernet/neterion/vxge/vxge-main.c", "vxge_tx_watchdog"],
["drivers/net/ethernet/netronome/nfp/nfp_net_common.c", "nfp_net_tx_timeout"],
["drivers/net/ethernet/nvidia/forcedeth.c", "nv_tx_timeout"],
["drivers/net/ethernet/nvidia/forcedeth.c", "nv_tx_timeout"],
["drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c", "pch_gbe_tx_timeout"],
["drivers/net/ethernet/packetengines/hamachi.c", "hamachi_tx_timeout"],
["drivers/net/ethernet/packetengines/yellowfin.c", "yellowfin_tx_timeout"],
["drivers/net/ethernet/pensando/ionic/ionic_lif.c", "ionic_tx_timeout"],
["drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c", "netxen_tx_timeout"],
["drivers/net/ethernet/qlogic/qla3xxx.c", "ql3xxx_tx_timeout"],
["drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c", "qlcnic_tx_timeout"],
["drivers/net/ethernet/qualcomm/emac/emac.c", "emac_tx_timeout"],
["drivers/net/ethernet/qualcomm/qca_spi.c", "qcaspi_netdev_tx_timeout"],
["drivers/net/ethernet/qualcomm/qca_uart.c", "qcauart_netdev_tx_timeout"],
["drivers/net/ethernet/rdc/r6040.c", "r6040_tx_timeout"],
["drivers/net/ethernet/realtek/8139cp.c", "cp_tx_timeout"],
["drivers/net/ethernet/realtek/8139too.c", "rtl8139_tx_timeout"],
["drivers/net/ethernet/realtek/atp.c", "tx_timeout"],
["drivers/net/ethernet/realtek/r8169_main.c", "rtl8169_tx_timeout"],
["drivers/net/ethernet/renesas/ravb_main.c", "ravb_tx_timeout"],
["drivers/net/ethernet/renesas/sh_eth.c", "sh_eth_tx_timeout"],
["drivers/net/ethernet/renesas/sh_eth.c", "sh_eth_tx_timeout"],
["drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c", "sxgbe_tx_timeout"],
["drivers/net/ethernet/seeq/ether3.c", "ether3_timeout"],
["drivers/net/ethernet/seeq/sgiseeq.c", "timeout"],
["drivers/net/ethernet/sfc/efx.c", "efx_watchdog"],
["drivers/net/ethernet/sfc/falcon/efx.c", "ef4_watchdog"],
["drivers/net/ethernet/sgi/ioc3-eth.c", "ioc3_timeout"],
["drivers/net/ethernet/sgi/meth.c", "meth_tx_timeout"],
["drivers/net/ethernet/silan/sc92031.c", "sc92031_tx_timeout"],
["drivers/net/ethernet/sis/sis190.c", "sis190_tx_timeout"],
["drivers/net/ethernet/sis/sis900.c", "sis900_tx_timeout"],
["drivers/net/ethernet/smsc/epic100.c", "epic_tx_timeout"],
["drivers/net/ethernet/smsc/smc911x.c", "smc911x_timeout"],
["drivers/net/ethernet/smsc/smc9194.c", "smc_timeout"],
["drivers/net/ethernet/smsc/smc91c92_cs.c", "smc_tx_timeout"],
["drivers/net/ethernet/smsc/smc91x.c", "smc_timeout"],
["drivers/net/ethernet/stmicro/stmmac/stmmac_main.c", "stmmac_tx_timeout"],
["drivers/net/ethernet/sun/cassini.c", "cas_tx_timeout"],
["drivers/net/ethernet/sun/ldmvsw.c", "sunvnet_tx_timeout_common"],
["drivers/net/ethernet/sun/niu.c", "niu_tx_timeout"],
["drivers/net/ethernet/sun/sunbmac.c", "bigmac_tx_timeout"],
["drivers/net/ethernet/sun/sungem.c", "gem_tx_timeout"],
["drivers/net/ethernet/sun/sunhme.c", "happy_meal_tx_timeout"],
["drivers/net/ethernet/sun/sunqe.c", "qe_tx_timeout"],
["drivers/net/ethernet/sun/sunvnet.c", "sunvnet_tx_timeout_common"],
["drivers/net/ethernet/sun/sunvnet_common.c", "sunvnet_tx_timeout_common"],
["drivers/net/ethernet/sun/sunvnet_common.h", "sunvnet_tx_timeout_common"],
["drivers/net/ethernet/synopsys/dwc-xlgmac-net.c", "xlgmac_tx_timeout"],
["drivers/net/ethernet/ti/cpmac.c", "cpmac_tx_timeout"],
["drivers/net/ethernet/ti/cpsw.c", "cpsw_ndo_tx_timeout"],
["drivers/net/ethernet/ti/cpsw_priv.c", "cpsw_ndo_tx_timeout"],
["drivers/net/ethernet/ti/cpsw_priv.h", "cpsw_ndo_tx_timeout"],
["drivers/net/ethernet/ti/davinci_emac.c", "emac_dev_tx_timeout"],
["drivers/net/ethernet/ti/netcp_core.c", "netcp_ndo_tx_timeout"],
["drivers/net/ethernet/ti/tlan.c", "tlan_tx_timeout"],
["drivers/net/ethernet/toshiba/ps3_gelic_net.h", "gelic_net_tx_timeout"],
["drivers/net/ethernet/toshiba/ps3_gelic_net.c", "gelic_net_tx_timeout"],
["drivers/net/ethernet/toshiba/ps3_gelic_wireless.c", "gelic_net_tx_timeout"],
["drivers/net/ethernet/toshiba/spider_net.c", "spider_net_tx_timeout"],
["drivers/net/ethernet/toshiba/tc35815.c", "tc35815_tx_timeout"],
["drivers/net/ethernet/via/via-rhine.c", "rhine_tx_timeout"],
["drivers/net/ethernet/wiznet/w5100.c", "w5100_tx_timeout"],
["drivers/net/ethernet/wiznet/w5300.c", "w5300_tx_timeout"],
["drivers/net/ethernet/xilinx/xilinx_emaclite.c", "xemaclite_tx_timeout"],
["drivers/net/ethernet/xircom/xirc2ps_cs.c", "xirc_tx_timeout"],
["drivers/net/fjes/fjes_main.c", "fjes_tx_retry"],
["drivers/net/slip/slip.c", "sl_tx_timeout"],
["include/linux/usb/usbnet.h", "usbnet_tx_timeout"],
["drivers/net/usb/aqc111.c", "usbnet_tx_timeout"],
["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
["drivers/net/usb/asix_devices.c", "usbnet_tx_timeout"],
["drivers/net/usb/ax88172a.c", "usbnet_tx_timeout"],
["drivers/net/usb/ax88179_178a.c", "usbnet_tx_timeout"],
["drivers/net/usb/catc.c", "catc_tx_timeout"],
["drivers/net/usb/cdc_mbim.c", "usbnet_tx_timeout"],
["drivers/net/usb/cdc_ncm.c", "usbnet_tx_timeout"],
["drivers/net/usb/dm9601.c", "usbnet_tx_timeout"],
["drivers/net/usb/hso.c", "hso_net_tx_timeout"],
["drivers/net/usb/int51x1.c", "usbnet_tx_timeout"],
["drivers/net/usb/ipheth.c", "ipheth_tx_timeout"],
["drivers/net/usb/kaweth.c", "kaweth_tx_timeout"],
["drivers/net/usb/lan78xx.c", "lan78xx_tx_timeout"],
["drivers/net/usb/mcs7830.c", "usbnet_tx_timeout"],
["drivers/net/usb/pegasus.c", "pegasus_tx_timeout"],
["drivers/net/usb/qmi_wwan.c", "usbnet_tx_timeout"],
["drivers/net/usb/r8152.c", "rtl8152_tx_timeout"],
["drivers/net/usb/rndis_host.c", "usbnet_tx_timeout"],
["drivers/net/usb/rtl8150.c", "rtl8150_tx_timeout"],
["drivers/net/usb/sierra_net.c", "usbnet_tx_timeout"],
["drivers/net/usb/smsc75xx.c", "usbnet_tx_timeout"],
["drivers/net/usb/smsc95xx.c", "usbnet_tx_timeout"],
["drivers/net/usb/sr9700.c", "usbnet_tx_timeout"],
["drivers/net/usb/sr9800.c", "usbnet_tx_timeout"],
["drivers/net/usb/usbnet.c", "usbnet_tx_timeout"],
["drivers/net/vmxnet3/vmxnet3_drv.c", "vmxnet3_tx_timeout"],
["drivers/net/wan/cosa.c", "cosa_net_timeout"],
["drivers/net/wan/farsync.c", "fst_tx_timeout"],
["drivers/net/wan/fsl_ucc_hdlc.c", "uhdlc_tx_timeout"],
["drivers/net/wan/lmc/lmc_main.c", "lmc_driver_timeout"],
["drivers/net/wan/x25_asy.c", "x25_asy_timeout"],
["drivers/net/wimax/i2400m/netdev.c", "i2400m_tx_timeout"],
["drivers/net/wireless/intel/ipw2x00/ipw2100.c", "ipw2100_tx_timeout"],
["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
["drivers/net/wireless/intersil/hostap/hostap_main.c", "prism2_tx_timeout"],
["drivers/net/wireless/intersil/orinoco/main.c", "orinoco_tx_timeout"],
["drivers/net/wireless/intersil/orinoco/orinoco_usb.c", "orinoco_tx_timeout"],
["drivers/net/wireless/intersil/orinoco/orinoco.h", "orinoco_tx_timeout"],
["drivers/net/wireless/intersil/prism54/islpci_dev.c", "islpci_eth_tx_timeout"],
["drivers/net/wireless/intersil/prism54/islpci_eth.c", "islpci_eth_tx_timeout"],
["drivers/net/wireless/intersil/prism54/islpci_eth.h", "islpci_eth_tx_timeout"],
["drivers/net/wireless/marvell/mwifiex/main.c", "mwifiex_tx_timeout"],
["drivers/net/wireless/quantenna/qtnfmac/core.c", "qtnf_netdev_tx_timeout"],
["drivers/net/wireless/quantenna/qtnfmac/core.h", "qtnf_netdev_tx_timeout"],
["drivers/net/wireless/rndis_wlan.c", "usbnet_tx_timeout"],
["drivers/net/wireless/wl3501_cs.c", "wl3501_tx_timeout"],
["drivers/net/wireless/zydas/zd1201.c", "zd1201_tx_timeout"],
["drivers/s390/net/qeth_core.h", "qeth_tx_timeout"],
["drivers/s390/net/qeth_core_main.c", "qeth_tx_timeout"],
["drivers/s390/net/qeth_l2_main.c", "qeth_tx_timeout"],
["drivers/s390/net/qeth_l2_main.c", "qeth_tx_timeout"],
["drivers/s390/net/qeth_l3_main.c", "qeth_tx_timeout"],
["drivers/s390/net/qeth_l3_main.c", "qeth_tx_timeout"],
["drivers/staging/ks7010/ks_wlan_net.c", "ks_wlan_tx_timeout"],
["drivers/staging/qlge/qlge_main.c", "qlge_tx_timeout"],
["drivers/staging/rtl8192e/rtl8192e/rtl_core.c", "_rtl92e_tx_timeout"],
["drivers/staging/rtl8192u/r8192U_core.c", "tx_timeout"],
["drivers/staging/unisys/visornic/visornic_main.c", "visornic_xmit_timeout"],
["drivers/staging/wlan-ng/p80211netdev.c", "p80211knetdev_tx_timeout"],
["drivers/tty/n_gsm.c", "gsm_mux_net_tx_timeout"],
["drivers/tty/synclink.c", "hdlcdev_tx_timeout"],
["drivers/tty/synclink_gt.c", "hdlcdev_tx_timeout"],
["drivers/tty/synclinkmp.c", "hdlcdev_tx_timeout"],
["net/atm/lec.c", "lec_tx_timeout"],
["net/bluetooth/bnep/netdev.c", "bnep_net_timeout"]
);

for my $p (@work) {
	my @pair = @$p;
	my $file = $pair[0];
	my $func = $pair[1];
	print STDERR $file , ": ", $func,"\n";
	our @ARGV = ($file);
	while (<ARGV>) {
		if (m/($func\s*\(struct\s+net_device\s+\*[A-Za-z_]?[A-Za-z-0-9_]*)(\))/) {
			print STDERR "found $1+$2 in $file\n";
		}
		if (s/($func\s*\(struct\s+net_device\s+\*[A-Za-z_]?[A-Za-z-0-9_]*)(\))/$1, unsigned int txqueue$2/) {
			print STDERR "$func found in $file\n";
		}
		print;
	}
}

where the list of files and functions is simply from:

git grep ndo_tx_timeout, with manual addition of headers
in the rare cases where the function is from a header,
then manually changing the few places which actually
call ndo_tx_timeout.

	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
	Acked-by: Heiner Kallweit <hkallweit1@gmail.com>
	Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Acked-by: Shannon Nelson <snelson@pensando.io>
	Reviewed-by: Martin Habets <mhabets@solarflare.com>

changes from v9:
	fixup a forward declaration
changes from v9:
	more leftovers from v3 change
changes from v8:
        fix up a missing direct call to timeout
        rebased on net-next
changes from v7:
	fixup leftovers from v3 change
changes from v6:
	fix typo in rtl driver
changes from v5:
	add missing files (allow any net device argument name)
changes from v4:
	add a missing driver header
changes from v3:
        change queue # to unsigned
Changes from v2:
        added headers
Changes from v1:
        Fix errors found by kbuild:
        generalize the pattern a bit, to pick up
        a couple of instances missed by the previous
        version.

	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0290bd291cc0e0488e35e66bf39efcd7d9d9122b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/amazon/ena/ena_netdev.c
#	drivers/net/ethernet/atheros/ag71xx.c
#	drivers/net/ethernet/cavium/liquidio/lio_vf_rep.c
#	drivers/net/ethernet/freescale/gianfar.c
#	drivers/net/ethernet/hisilicon/hns/hns_enet.c
#	drivers/net/ethernet/pensando/ionic/ionic_lif.c
#	drivers/net/ethernet/sgi/ioc3-eth.c
#	drivers/net/ethernet/sun/sunvnet_common.h
#	drivers/net/ethernet/ti/cpsw_priv.c
#	drivers/net/ethernet/ti/cpsw_priv.h
#	drivers/net/wan/fsl_ucc_hdlc.c
diff --cc drivers/net/ethernet/amazon/ena/ena_netdev.c
index b22c02236edf,26954fde4766..000000000000
--- a/drivers/net/ethernet/amazon/ena/ena_netdev.c
+++ b/drivers/net/ethernet/amazon/ena/ena_netdev.c
@@@ -79,7 -78,37 +79,41 @@@ static void check_for_admin_com_state(s
  static void ena_destroy_device(struct ena_adapter *adapter, bool graceful);
  static int ena_restore_device(struct ena_adapter *adapter);
  
++<<<<<<< HEAD
 +static void ena_tx_timeout(struct net_device *dev)
++=======
+ static void ena_init_io_rings(struct ena_adapter *adapter,
+ 			      int first_index, int count);
+ static void ena_init_napi_in_range(struct ena_adapter *adapter, int first_index,
+ 				   int count);
+ static void ena_del_napi_in_range(struct ena_adapter *adapter, int first_index,
+ 				  int count);
+ static int ena_setup_tx_resources(struct ena_adapter *adapter, int qid);
+ static int ena_setup_tx_resources_in_range(struct ena_adapter *adapter,
+ 					   int first_index,
+ 					   int count);
+ static int ena_create_io_tx_queue(struct ena_adapter *adapter, int qid);
+ static void ena_free_tx_resources(struct ena_adapter *adapter, int qid);
+ static int ena_clean_xdp_irq(struct ena_ring *xdp_ring, u32 budget);
+ static void ena_destroy_all_tx_queues(struct ena_adapter *adapter);
+ static void ena_free_all_io_tx_resources(struct ena_adapter *adapter);
+ static void ena_napi_disable_in_range(struct ena_adapter *adapter,
+ 				      int first_index, int count);
+ static void ena_napi_enable_in_range(struct ena_adapter *adapter,
+ 				     int first_index, int count);
+ static int ena_up(struct ena_adapter *adapter);
+ static void ena_down(struct ena_adapter *adapter);
+ static void ena_unmask_interrupt(struct ena_ring *tx_ring,
+ 				 struct ena_ring *rx_ring);
+ static void ena_update_ring_numa_node(struct ena_ring *tx_ring,
+ 				      struct ena_ring *rx_ring);
+ static void ena_unmap_tx_buff(struct ena_ring *tx_ring,
+ 			      struct ena_tx_buffer *tx_info);
+ static int ena_create_io_tx_queues_in_range(struct ena_adapter *adapter,
+ 					    int first_index, int count);
+ 
+ static void ena_tx_timeout(struct net_device *dev, unsigned int txqueue)
++>>>>>>> 0290bd291cc0 (netdev: pass the stuck queue to the timeout handler)
  {
  	struct ena_adapter *adapter = netdev_priv(dev);
  
diff --cc drivers/net/ethernet/cavium/liquidio/lio_vf_rep.c
index d3021665c974,600de587d7a9..000000000000
--- a/drivers/net/ethernet/cavium/liquidio/lio_vf_rep.c
+++ b/drivers/net/ethernet/cavium/liquidio/lio_vf_rep.c
@@@ -30,8 -29,9 +30,14 @@@
  
  static int lio_vf_rep_open(struct net_device *ndev);
  static int lio_vf_rep_stop(struct net_device *ndev);
++<<<<<<< HEAD
 +static int lio_vf_rep_pkt_xmit(struct sk_buff *skb, struct net_device *ndev);
 +static void lio_vf_rep_tx_timeout(struct net_device *netdev);
++=======
+ static netdev_tx_t lio_vf_rep_pkt_xmit(struct sk_buff *skb,
+ 				       struct net_device *ndev);
+ static void lio_vf_rep_tx_timeout(struct net_device *netdev, unsigned int txqueue);
++>>>>>>> 0290bd291cc0 (netdev: pass the stuck queue to the timeout handler)
  static int lio_vf_rep_phys_port_name(struct net_device *dev,
  				     char *buf, size_t len);
  static void lio_vf_rep_get_stats64(struct net_device *dev,
diff --cc drivers/net/ethernet/freescale/gianfar.c
index 9c9f91cc3db5,b636d83a7ee9..000000000000
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@@ -1138,6 -969,2183 +1138,2186 @@@ static void gfar_detect_errata(struct g
  			 priv->errata);
  }
  
++<<<<<<< HEAD
++=======
+ static void gfar_init_addr_hash_table(struct gfar_private *priv)
+ {
+ 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+ 
+ 	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_EXTENDED_HASH) {
+ 		priv->extended_hash = 1;
+ 		priv->hash_width = 9;
+ 
+ 		priv->hash_regs[0] = &regs->igaddr0;
+ 		priv->hash_regs[1] = &regs->igaddr1;
+ 		priv->hash_regs[2] = &regs->igaddr2;
+ 		priv->hash_regs[3] = &regs->igaddr3;
+ 		priv->hash_regs[4] = &regs->igaddr4;
+ 		priv->hash_regs[5] = &regs->igaddr5;
+ 		priv->hash_regs[6] = &regs->igaddr6;
+ 		priv->hash_regs[7] = &regs->igaddr7;
+ 		priv->hash_regs[8] = &regs->gaddr0;
+ 		priv->hash_regs[9] = &regs->gaddr1;
+ 		priv->hash_regs[10] = &regs->gaddr2;
+ 		priv->hash_regs[11] = &regs->gaddr3;
+ 		priv->hash_regs[12] = &regs->gaddr4;
+ 		priv->hash_regs[13] = &regs->gaddr5;
+ 		priv->hash_regs[14] = &regs->gaddr6;
+ 		priv->hash_regs[15] = &regs->gaddr7;
+ 
+ 	} else {
+ 		priv->extended_hash = 0;
+ 		priv->hash_width = 8;
+ 
+ 		priv->hash_regs[0] = &regs->gaddr0;
+ 		priv->hash_regs[1] = &regs->gaddr1;
+ 		priv->hash_regs[2] = &regs->gaddr2;
+ 		priv->hash_regs[3] = &regs->gaddr3;
+ 		priv->hash_regs[4] = &regs->gaddr4;
+ 		priv->hash_regs[5] = &regs->gaddr5;
+ 		priv->hash_regs[6] = &regs->gaddr6;
+ 		priv->hash_regs[7] = &regs->gaddr7;
+ 	}
+ }
+ 
+ static int __gfar_is_rx_idle(struct gfar_private *priv)
+ {
+ 	u32 res;
+ 
+ 	/* Normaly TSEC should not hang on GRS commands, so we should
+ 	 * actually wait for IEVENT_GRSC flag.
+ 	 */
+ 	if (!gfar_has_errata(priv, GFAR_ERRATA_A002))
+ 		return 0;
+ 
+ 	/* Read the eTSEC register at offset 0xD1C. If bits 7-14 are
+ 	 * the same as bits 23-30, the eTSEC Rx is assumed to be idle
+ 	 * and the Rx can be safely reset.
+ 	 */
+ 	res = gfar_read((void __iomem *)priv->gfargrp[0].regs + 0xd1c);
+ 	res &= 0x7f807f80;
+ 	if ((res & 0xffff) == (res >> 16))
+ 		return 1;
+ 
+ 	return 0;
+ }
+ 
+ /* Halt the receive and transmit queues */
+ static void gfar_halt_nodisable(struct gfar_private *priv)
+ {
+ 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+ 	u32 tempval;
+ 	unsigned int timeout;
+ 	int stopped;
+ 
+ 	gfar_ints_disable(priv);
+ 
+ 	if (gfar_is_dma_stopped(priv))
+ 		return;
+ 
+ 	/* Stop the DMA, and wait for it to stop */
+ 	tempval = gfar_read(&regs->dmactrl);
+ 	tempval |= (DMACTRL_GRS | DMACTRL_GTS);
+ 	gfar_write(&regs->dmactrl, tempval);
+ 
+ retry:
+ 	timeout = 1000;
+ 	while (!(stopped = gfar_is_dma_stopped(priv)) && timeout) {
+ 		cpu_relax();
+ 		timeout--;
+ 	}
+ 
+ 	if (!timeout)
+ 		stopped = gfar_is_dma_stopped(priv);
+ 
+ 	if (!stopped && !gfar_is_rx_dma_stopped(priv) &&
+ 	    !__gfar_is_rx_idle(priv))
+ 		goto retry;
+ }
+ 
+ /* Halt the receive and transmit queues */
+ static void gfar_halt(struct gfar_private *priv)
+ {
+ 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+ 	u32 tempval;
+ 
+ 	/* Dissable the Rx/Tx hw queues */
+ 	gfar_write(&regs->rqueue, 0);
+ 	gfar_write(&regs->tqueue, 0);
+ 
+ 	mdelay(10);
+ 
+ 	gfar_halt_nodisable(priv);
+ 
+ 	/* Disable Rx/Tx DMA */
+ 	tempval = gfar_read(&regs->maccfg1);
+ 	tempval &= ~(MACCFG1_RX_EN | MACCFG1_TX_EN);
+ 	gfar_write(&regs->maccfg1, tempval);
+ }
+ 
+ static void free_skb_tx_queue(struct gfar_priv_tx_q *tx_queue)
+ {
+ 	struct txbd8 *txbdp;
+ 	struct gfar_private *priv = netdev_priv(tx_queue->dev);
+ 	int i, j;
+ 
+ 	txbdp = tx_queue->tx_bd_base;
+ 
+ 	for (i = 0; i < tx_queue->tx_ring_size; i++) {
+ 		if (!tx_queue->tx_skbuff[i])
+ 			continue;
+ 
+ 		dma_unmap_single(priv->dev, be32_to_cpu(txbdp->bufPtr),
+ 				 be16_to_cpu(txbdp->length), DMA_TO_DEVICE);
+ 		txbdp->lstatus = 0;
+ 		for (j = 0; j < skb_shinfo(tx_queue->tx_skbuff[i])->nr_frags;
+ 		     j++) {
+ 			txbdp++;
+ 			dma_unmap_page(priv->dev, be32_to_cpu(txbdp->bufPtr),
+ 				       be16_to_cpu(txbdp->length),
+ 				       DMA_TO_DEVICE);
+ 		}
+ 		txbdp++;
+ 		dev_kfree_skb_any(tx_queue->tx_skbuff[i]);
+ 		tx_queue->tx_skbuff[i] = NULL;
+ 	}
+ 	kfree(tx_queue->tx_skbuff);
+ 	tx_queue->tx_skbuff = NULL;
+ }
+ 
+ static void free_skb_rx_queue(struct gfar_priv_rx_q *rx_queue)
+ {
+ 	int i;
+ 
+ 	struct rxbd8 *rxbdp = rx_queue->rx_bd_base;
+ 
+ 	dev_kfree_skb(rx_queue->skb);
+ 
+ 	for (i = 0; i < rx_queue->rx_ring_size; i++) {
+ 		struct	gfar_rx_buff *rxb = &rx_queue->rx_buff[i];
+ 
+ 		rxbdp->lstatus = 0;
+ 		rxbdp->bufPtr = 0;
+ 		rxbdp++;
+ 
+ 		if (!rxb->page)
+ 			continue;
+ 
+ 		dma_unmap_page(rx_queue->dev, rxb->dma,
+ 			       PAGE_SIZE, DMA_FROM_DEVICE);
+ 		__free_page(rxb->page);
+ 
+ 		rxb->page = NULL;
+ 	}
+ 
+ 	kfree(rx_queue->rx_buff);
+ 	rx_queue->rx_buff = NULL;
+ }
+ 
+ /* If there are any tx skbs or rx skbs still around, free them.
+  * Then free tx_skbuff and rx_skbuff
+  */
+ static void free_skb_resources(struct gfar_private *priv)
+ {
+ 	struct gfar_priv_tx_q *tx_queue = NULL;
+ 	struct gfar_priv_rx_q *rx_queue = NULL;
+ 	int i;
+ 
+ 	/* Go through all the buffer descriptors and free their data buffers */
+ 	for (i = 0; i < priv->num_tx_queues; i++) {
+ 		struct netdev_queue *txq;
+ 
+ 		tx_queue = priv->tx_queue[i];
+ 		txq = netdev_get_tx_queue(tx_queue->dev, tx_queue->qindex);
+ 		if (tx_queue->tx_skbuff)
+ 			free_skb_tx_queue(tx_queue);
+ 		netdev_tx_reset_queue(txq);
+ 	}
+ 
+ 	for (i = 0; i < priv->num_rx_queues; i++) {
+ 		rx_queue = priv->rx_queue[i];
+ 		if (rx_queue->rx_buff)
+ 			free_skb_rx_queue(rx_queue);
+ 	}
+ 
+ 	dma_free_coherent(priv->dev,
+ 			  sizeof(struct txbd8) * priv->total_tx_ring_size +
+ 			  sizeof(struct rxbd8) * priv->total_rx_ring_size,
+ 			  priv->tx_queue[0]->tx_bd_base,
+ 			  priv->tx_queue[0]->tx_bd_dma_base);
+ }
+ 
+ void stop_gfar(struct net_device *dev)
+ {
+ 	struct gfar_private *priv = netdev_priv(dev);
+ 
+ 	netif_tx_stop_all_queues(dev);
+ 
+ 	smp_mb__before_atomic();
+ 	set_bit(GFAR_DOWN, &priv->state);
+ 	smp_mb__after_atomic();
+ 
+ 	disable_napi(priv);
+ 
+ 	/* disable ints and gracefully shut down Rx/Tx DMA */
+ 	gfar_halt(priv);
+ 
+ 	phy_stop(dev->phydev);
+ 
+ 	free_skb_resources(priv);
+ }
+ 
+ static void gfar_start(struct gfar_private *priv)
+ {
+ 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+ 	u32 tempval;
+ 	int i = 0;
+ 
+ 	/* Enable Rx/Tx hw queues */
+ 	gfar_write(&regs->rqueue, priv->rqueue);
+ 	gfar_write(&regs->tqueue, priv->tqueue);
+ 
+ 	/* Initialize DMACTRL to have WWR and WOP */
+ 	tempval = gfar_read(&regs->dmactrl);
+ 	tempval |= DMACTRL_INIT_SETTINGS;
+ 	gfar_write(&regs->dmactrl, tempval);
+ 
+ 	/* Make sure we aren't stopped */
+ 	tempval = gfar_read(&regs->dmactrl);
+ 	tempval &= ~(DMACTRL_GRS | DMACTRL_GTS);
+ 	gfar_write(&regs->dmactrl, tempval);
+ 
+ 	for (i = 0; i < priv->num_grps; i++) {
+ 		regs = priv->gfargrp[i].regs;
+ 		/* Clear THLT/RHLT, so that the DMA starts polling now */
+ 		gfar_write(&regs->tstat, priv->gfargrp[i].tstat);
+ 		gfar_write(&regs->rstat, priv->gfargrp[i].rstat);
+ 	}
+ 
+ 	/* Enable Rx/Tx DMA */
+ 	tempval = gfar_read(&regs->maccfg1);
+ 	tempval |= (MACCFG1_RX_EN | MACCFG1_TX_EN);
+ 	gfar_write(&regs->maccfg1, tempval);
+ 
+ 	gfar_ints_enable(priv);
+ 
+ 	netif_trans_update(priv->ndev); /* prevent tx timeout */
+ }
+ 
+ static bool gfar_new_page(struct gfar_priv_rx_q *rxq, struct gfar_rx_buff *rxb)
+ {
+ 	struct page *page;
+ 	dma_addr_t addr;
+ 
+ 	page = dev_alloc_page();
+ 	if (unlikely(!page))
+ 		return false;
+ 
+ 	addr = dma_map_page(rxq->dev, page, 0, PAGE_SIZE, DMA_FROM_DEVICE);
+ 	if (unlikely(dma_mapping_error(rxq->dev, addr))) {
+ 		__free_page(page);
+ 
+ 		return false;
+ 	}
+ 
+ 	rxb->dma = addr;
+ 	rxb->page = page;
+ 	rxb->page_offset = 0;
+ 
+ 	return true;
+ }
+ 
+ static void gfar_rx_alloc_err(struct gfar_priv_rx_q *rx_queue)
+ {
+ 	struct gfar_private *priv = netdev_priv(rx_queue->ndev);
+ 	struct gfar_extra_stats *estats = &priv->extra_stats;
+ 
+ 	netdev_err(rx_queue->ndev, "Can't alloc RX buffers\n");
+ 	atomic64_inc(&estats->rx_alloc_err);
+ }
+ 
+ static void gfar_alloc_rx_buffs(struct gfar_priv_rx_q *rx_queue,
+ 				int alloc_cnt)
+ {
+ 	struct rxbd8 *bdp;
+ 	struct gfar_rx_buff *rxb;
+ 	int i;
+ 
+ 	i = rx_queue->next_to_use;
+ 	bdp = &rx_queue->rx_bd_base[i];
+ 	rxb = &rx_queue->rx_buff[i];
+ 
+ 	while (alloc_cnt--) {
+ 		/* try reuse page */
+ 		if (unlikely(!rxb->page)) {
+ 			if (unlikely(!gfar_new_page(rx_queue, rxb))) {
+ 				gfar_rx_alloc_err(rx_queue);
+ 				break;
+ 			}
+ 		}
+ 
+ 		/* Setup the new RxBD */
+ 		gfar_init_rxbdp(rx_queue, bdp,
+ 				rxb->dma + rxb->page_offset + RXBUF_ALIGNMENT);
+ 
+ 		/* Update to the next pointer */
+ 		bdp++;
+ 		rxb++;
+ 
+ 		if (unlikely(++i == rx_queue->rx_ring_size)) {
+ 			i = 0;
+ 			bdp = rx_queue->rx_bd_base;
+ 			rxb = rx_queue->rx_buff;
+ 		}
+ 	}
+ 
+ 	rx_queue->next_to_use = i;
+ 	rx_queue->next_to_alloc = i;
+ }
+ 
+ static void gfar_init_bds(struct net_device *ndev)
+ {
+ 	struct gfar_private *priv = netdev_priv(ndev);
+ 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+ 	struct gfar_priv_tx_q *tx_queue = NULL;
+ 	struct gfar_priv_rx_q *rx_queue = NULL;
+ 	struct txbd8 *txbdp;
+ 	u32 __iomem *rfbptr;
+ 	int i, j;
+ 
+ 	for (i = 0; i < priv->num_tx_queues; i++) {
+ 		tx_queue = priv->tx_queue[i];
+ 		/* Initialize some variables in our dev structure */
+ 		tx_queue->num_txbdfree = tx_queue->tx_ring_size;
+ 		tx_queue->dirty_tx = tx_queue->tx_bd_base;
+ 		tx_queue->cur_tx = tx_queue->tx_bd_base;
+ 		tx_queue->skb_curtx = 0;
+ 		tx_queue->skb_dirtytx = 0;
+ 
+ 		/* Initialize Transmit Descriptor Ring */
+ 		txbdp = tx_queue->tx_bd_base;
+ 		for (j = 0; j < tx_queue->tx_ring_size; j++) {
+ 			txbdp->lstatus = 0;
+ 			txbdp->bufPtr = 0;
+ 			txbdp++;
+ 		}
+ 
+ 		/* Set the last descriptor in the ring to indicate wrap */
+ 		txbdp--;
+ 		txbdp->status = cpu_to_be16(be16_to_cpu(txbdp->status) |
+ 					    TXBD_WRAP);
+ 	}
+ 
+ 	rfbptr = &regs->rfbptr0;
+ 	for (i = 0; i < priv->num_rx_queues; i++) {
+ 		rx_queue = priv->rx_queue[i];
+ 
+ 		rx_queue->next_to_clean = 0;
+ 		rx_queue->next_to_use = 0;
+ 		rx_queue->next_to_alloc = 0;
+ 
+ 		/* make sure next_to_clean != next_to_use after this
+ 		 * by leaving at least 1 unused descriptor
+ 		 */
+ 		gfar_alloc_rx_buffs(rx_queue, gfar_rxbd_unused(rx_queue));
+ 
+ 		rx_queue->rfbptr = rfbptr;
+ 		rfbptr += 2;
+ 	}
+ }
+ 
+ static int gfar_alloc_skb_resources(struct net_device *ndev)
+ {
+ 	void *vaddr;
+ 	dma_addr_t addr;
+ 	int i, j;
+ 	struct gfar_private *priv = netdev_priv(ndev);
+ 	struct device *dev = priv->dev;
+ 	struct gfar_priv_tx_q *tx_queue = NULL;
+ 	struct gfar_priv_rx_q *rx_queue = NULL;
+ 
+ 	priv->total_tx_ring_size = 0;
+ 	for (i = 0; i < priv->num_tx_queues; i++)
+ 		priv->total_tx_ring_size += priv->tx_queue[i]->tx_ring_size;
+ 
+ 	priv->total_rx_ring_size = 0;
+ 	for (i = 0; i < priv->num_rx_queues; i++)
+ 		priv->total_rx_ring_size += priv->rx_queue[i]->rx_ring_size;
+ 
+ 	/* Allocate memory for the buffer descriptors */
+ 	vaddr = dma_alloc_coherent(dev,
+ 				   (priv->total_tx_ring_size *
+ 				    sizeof(struct txbd8)) +
+ 				   (priv->total_rx_ring_size *
+ 				    sizeof(struct rxbd8)),
+ 				   &addr, GFP_KERNEL);
+ 	if (!vaddr)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < priv->num_tx_queues; i++) {
+ 		tx_queue = priv->tx_queue[i];
+ 		tx_queue->tx_bd_base = vaddr;
+ 		tx_queue->tx_bd_dma_base = addr;
+ 		tx_queue->dev = ndev;
+ 		/* enet DMA only understands physical addresses */
+ 		addr  += sizeof(struct txbd8) * tx_queue->tx_ring_size;
+ 		vaddr += sizeof(struct txbd8) * tx_queue->tx_ring_size;
+ 	}
+ 
+ 	/* Start the rx descriptor ring where the tx ring leaves off */
+ 	for (i = 0; i < priv->num_rx_queues; i++) {
+ 		rx_queue = priv->rx_queue[i];
+ 		rx_queue->rx_bd_base = vaddr;
+ 		rx_queue->rx_bd_dma_base = addr;
+ 		rx_queue->ndev = ndev;
+ 		rx_queue->dev = dev;
+ 		addr  += sizeof(struct rxbd8) * rx_queue->rx_ring_size;
+ 		vaddr += sizeof(struct rxbd8) * rx_queue->rx_ring_size;
+ 	}
+ 
+ 	/* Setup the skbuff rings */
+ 	for (i = 0; i < priv->num_tx_queues; i++) {
+ 		tx_queue = priv->tx_queue[i];
+ 		tx_queue->tx_skbuff =
+ 			kmalloc_array(tx_queue->tx_ring_size,
+ 				      sizeof(*tx_queue->tx_skbuff),
+ 				      GFP_KERNEL);
+ 		if (!tx_queue->tx_skbuff)
+ 			goto cleanup;
+ 
+ 		for (j = 0; j < tx_queue->tx_ring_size; j++)
+ 			tx_queue->tx_skbuff[j] = NULL;
+ 	}
+ 
+ 	for (i = 0; i < priv->num_rx_queues; i++) {
+ 		rx_queue = priv->rx_queue[i];
+ 		rx_queue->rx_buff = kcalloc(rx_queue->rx_ring_size,
+ 					    sizeof(*rx_queue->rx_buff),
+ 					    GFP_KERNEL);
+ 		if (!rx_queue->rx_buff)
+ 			goto cleanup;
+ 	}
+ 
+ 	gfar_init_bds(ndev);
+ 
+ 	return 0;
+ 
+ cleanup:
+ 	free_skb_resources(priv);
+ 	return -ENOMEM;
+ }
+ 
+ /* Bring the controller up and running */
+ int startup_gfar(struct net_device *ndev)
+ {
+ 	struct gfar_private *priv = netdev_priv(ndev);
+ 	int err;
+ 
+ 	gfar_mac_reset(priv);
+ 
+ 	err = gfar_alloc_skb_resources(ndev);
+ 	if (err)
+ 		return err;
+ 
+ 	gfar_init_tx_rx_base(priv);
+ 
+ 	smp_mb__before_atomic();
+ 	clear_bit(GFAR_DOWN, &priv->state);
+ 	smp_mb__after_atomic();
+ 
+ 	/* Start Rx/Tx DMA and enable the interrupts */
+ 	gfar_start(priv);
+ 
+ 	/* force link state update after mac reset */
+ 	priv->oldlink = 0;
+ 	priv->oldspeed = 0;
+ 	priv->oldduplex = -1;
+ 
+ 	phy_start(ndev->phydev);
+ 
+ 	enable_napi(priv);
+ 
+ 	netif_tx_wake_all_queues(ndev);
+ 
+ 	return 0;
+ }
+ 
+ static u32 gfar_get_flowctrl_cfg(struct gfar_private *priv)
+ {
+ 	struct net_device *ndev = priv->ndev;
+ 	struct phy_device *phydev = ndev->phydev;
+ 	u32 val = 0;
+ 
+ 	if (!phydev->duplex)
+ 		return val;
+ 
+ 	if (!priv->pause_aneg_en) {
+ 		if (priv->tx_pause_en)
+ 			val |= MACCFG1_TX_FLOW;
+ 		if (priv->rx_pause_en)
+ 			val |= MACCFG1_RX_FLOW;
+ 	} else {
+ 		u16 lcl_adv, rmt_adv;
+ 		u8 flowctrl;
+ 		/* get link partner capabilities */
+ 		rmt_adv = 0;
+ 		if (phydev->pause)
+ 			rmt_adv = LPA_PAUSE_CAP;
+ 		if (phydev->asym_pause)
+ 			rmt_adv |= LPA_PAUSE_ASYM;
+ 
+ 		lcl_adv = linkmode_adv_to_lcl_adv_t(phydev->advertising);
+ 		flowctrl = mii_resolve_flowctrl_fdx(lcl_adv, rmt_adv);
+ 		if (flowctrl & FLOW_CTRL_TX)
+ 			val |= MACCFG1_TX_FLOW;
+ 		if (flowctrl & FLOW_CTRL_RX)
+ 			val |= MACCFG1_RX_FLOW;
+ 	}
+ 
+ 	return val;
+ }
+ 
+ static noinline void gfar_update_link_state(struct gfar_private *priv)
+ {
+ 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+ 	struct net_device *ndev = priv->ndev;
+ 	struct phy_device *phydev = ndev->phydev;
+ 	struct gfar_priv_rx_q *rx_queue = NULL;
+ 	int i;
+ 
+ 	if (unlikely(test_bit(GFAR_RESETTING, &priv->state)))
+ 		return;
+ 
+ 	if (phydev->link) {
+ 		u32 tempval1 = gfar_read(&regs->maccfg1);
+ 		u32 tempval = gfar_read(&regs->maccfg2);
+ 		u32 ecntrl = gfar_read(&regs->ecntrl);
+ 		u32 tx_flow_oldval = (tempval1 & MACCFG1_TX_FLOW);
+ 
+ 		if (phydev->duplex != priv->oldduplex) {
+ 			if (!(phydev->duplex))
+ 				tempval &= ~(MACCFG2_FULL_DUPLEX);
+ 			else
+ 				tempval |= MACCFG2_FULL_DUPLEX;
+ 
+ 			priv->oldduplex = phydev->duplex;
+ 		}
+ 
+ 		if (phydev->speed != priv->oldspeed) {
+ 			switch (phydev->speed) {
+ 			case 1000:
+ 				tempval =
+ 				    ((tempval & ~(MACCFG2_IF)) | MACCFG2_GMII);
+ 
+ 				ecntrl &= ~(ECNTRL_R100);
+ 				break;
+ 			case 100:
+ 			case 10:
+ 				tempval =
+ 				    ((tempval & ~(MACCFG2_IF)) | MACCFG2_MII);
+ 
+ 				/* Reduced mode distinguishes
+ 				 * between 10 and 100
+ 				 */
+ 				if (phydev->speed == SPEED_100)
+ 					ecntrl |= ECNTRL_R100;
+ 				else
+ 					ecntrl &= ~(ECNTRL_R100);
+ 				break;
+ 			default:
+ 				netif_warn(priv, link, priv->ndev,
+ 					   "Ack!  Speed (%d) is not 10/100/1000!\n",
+ 					   phydev->speed);
+ 				break;
+ 			}
+ 
+ 			priv->oldspeed = phydev->speed;
+ 		}
+ 
+ 		tempval1 &= ~(MACCFG1_TX_FLOW | MACCFG1_RX_FLOW);
+ 		tempval1 |= gfar_get_flowctrl_cfg(priv);
+ 
+ 		/* Turn last free buffer recording on */
+ 		if ((tempval1 & MACCFG1_TX_FLOW) && !tx_flow_oldval) {
+ 			for (i = 0; i < priv->num_rx_queues; i++) {
+ 				u32 bdp_dma;
+ 
+ 				rx_queue = priv->rx_queue[i];
+ 				bdp_dma = gfar_rxbd_dma_lastfree(rx_queue);
+ 				gfar_write(rx_queue->rfbptr, bdp_dma);
+ 			}
+ 
+ 			priv->tx_actual_en = 1;
+ 		}
+ 
+ 		if (unlikely(!(tempval1 & MACCFG1_TX_FLOW) && tx_flow_oldval))
+ 			priv->tx_actual_en = 0;
+ 
+ 		gfar_write(&regs->maccfg1, tempval1);
+ 		gfar_write(&regs->maccfg2, tempval);
+ 		gfar_write(&regs->ecntrl, ecntrl);
+ 
+ 		if (!priv->oldlink)
+ 			priv->oldlink = 1;
+ 
+ 	} else if (priv->oldlink) {
+ 		priv->oldlink = 0;
+ 		priv->oldspeed = 0;
+ 		priv->oldduplex = -1;
+ 	}
+ 
+ 	if (netif_msg_link(priv))
+ 		phy_print_status(phydev);
+ }
+ 
+ /* Called every time the controller might need to be made
+  * aware of new link state.  The PHY code conveys this
+  * information through variables in the phydev structure, and this
+  * function converts those variables into the appropriate
+  * register values, and can bring down the device if needed.
+  */
+ static void adjust_link(struct net_device *dev)
+ {
+ 	struct gfar_private *priv = netdev_priv(dev);
+ 	struct phy_device *phydev = dev->phydev;
+ 
+ 	if (unlikely(phydev->link != priv->oldlink ||
+ 		     (phydev->link && (phydev->duplex != priv->oldduplex ||
+ 				       phydev->speed != priv->oldspeed))))
+ 		gfar_update_link_state(priv);
+ }
+ 
+ /* Initialize TBI PHY interface for communicating with the
+  * SERDES lynx PHY on the chip.  We communicate with this PHY
+  * through the MDIO bus on each controller, treating it as a
+  * "normal" PHY at the address found in the TBIPA register.  We assume
+  * that the TBIPA register is valid.  Either the MDIO bus code will set
+  * it to a value that doesn't conflict with other PHYs on the bus, or the
+  * value doesn't matter, as there are no other PHYs on the bus.
+  */
+ static void gfar_configure_serdes(struct net_device *dev)
+ {
+ 	struct gfar_private *priv = netdev_priv(dev);
+ 	struct phy_device *tbiphy;
+ 
+ 	if (!priv->tbi_node) {
+ 		dev_warn(&dev->dev, "error: SGMII mode requires that the "
+ 				    "device tree specify a tbi-handle\n");
+ 		return;
+ 	}
+ 
+ 	tbiphy = of_phy_find_device(priv->tbi_node);
+ 	if (!tbiphy) {
+ 		dev_err(&dev->dev, "error: Could not get TBI device\n");
+ 		return;
+ 	}
+ 
+ 	/* If the link is already up, we must already be ok, and don't need to
+ 	 * configure and reset the TBI<->SerDes link.  Maybe U-Boot configured
+ 	 * everything for us?  Resetting it takes the link down and requires
+ 	 * several seconds for it to come back.
+ 	 */
+ 	if (phy_read(tbiphy, MII_BMSR) & BMSR_LSTATUS) {
+ 		put_device(&tbiphy->mdio.dev);
+ 		return;
+ 	}
+ 
+ 	/* Single clk mode, mii mode off(for serdes communication) */
+ 	phy_write(tbiphy, MII_TBICON, TBICON_CLK_SELECT);
+ 
+ 	phy_write(tbiphy, MII_ADVERTISE,
+ 		  ADVERTISE_1000XFULL | ADVERTISE_1000XPAUSE |
+ 		  ADVERTISE_1000XPSE_ASYM);
+ 
+ 	phy_write(tbiphy, MII_BMCR,
+ 		  BMCR_ANENABLE | BMCR_ANRESTART | BMCR_FULLDPLX |
+ 		  BMCR_SPEED1000);
+ 
+ 	put_device(&tbiphy->mdio.dev);
+ }
+ 
+ /* Initializes driver's PHY state, and attaches to the PHY.
+  * Returns 0 on success.
+  */
+ static int init_phy(struct net_device *dev)
+ {
+ 	__ETHTOOL_DECLARE_LINK_MODE_MASK(mask) = { 0, };
+ 	struct gfar_private *priv = netdev_priv(dev);
+ 	phy_interface_t interface = priv->interface;
+ 	struct phy_device *phydev;
+ 	struct ethtool_eee edata;
+ 
+ 	linkmode_set_bit_array(phy_10_100_features_array,
+ 			       ARRAY_SIZE(phy_10_100_features_array),
+ 			       mask);
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_Autoneg_BIT, mask);
+ 	linkmode_set_bit(ETHTOOL_LINK_MODE_MII_BIT, mask);
+ 	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_GIGABIT)
+ 		linkmode_set_bit(ETHTOOL_LINK_MODE_1000baseT_Full_BIT, mask);
+ 
+ 	priv->oldlink = 0;
+ 	priv->oldspeed = 0;
+ 	priv->oldduplex = -1;
+ 
+ 	phydev = of_phy_connect(dev, priv->phy_node, &adjust_link, 0,
+ 				interface);
+ 	if (!phydev) {
+ 		dev_err(&dev->dev, "could not attach to PHY\n");
+ 		return -ENODEV;
+ 	}
+ 
+ 	if (interface == PHY_INTERFACE_MODE_SGMII)
+ 		gfar_configure_serdes(dev);
+ 
+ 	/* Remove any features not supported by the controller */
+ 	linkmode_and(phydev->supported, phydev->supported, mask);
+ 	linkmode_copy(phydev->advertising, phydev->supported);
+ 
+ 	/* Add support for flow control */
+ 	phy_support_asym_pause(phydev);
+ 
+ 	/* disable EEE autoneg, EEE not supported by eTSEC */
+ 	memset(&edata, 0, sizeof(struct ethtool_eee));
+ 	phy_ethtool_set_eee(phydev, &edata);
+ 
+ 	return 0;
+ }
+ 
+ static inline struct txfcb *gfar_add_fcb(struct sk_buff *skb)
+ {
+ 	struct txfcb *fcb = skb_push(skb, GMAC_FCB_LEN);
+ 
+ 	memset(fcb, 0, GMAC_FCB_LEN);
+ 
+ 	return fcb;
+ }
+ 
+ static inline void gfar_tx_checksum(struct sk_buff *skb, struct txfcb *fcb,
+ 				    int fcb_length)
+ {
+ 	/* If we're here, it's a IP packet with a TCP or UDP
+ 	 * payload.  We set it to checksum, using a pseudo-header
+ 	 * we provide
+ 	 */
+ 	u8 flags = TXFCB_DEFAULT;
+ 
+ 	/* Tell the controller what the protocol is
+ 	 * And provide the already calculated phcs
+ 	 */
+ 	if (ip_hdr(skb)->protocol == IPPROTO_UDP) {
+ 		flags |= TXFCB_UDP;
+ 		fcb->phcs = (__force __be16)(udp_hdr(skb)->check);
+ 	} else
+ 		fcb->phcs = (__force __be16)(tcp_hdr(skb)->check);
+ 
+ 	/* l3os is the distance between the start of the
+ 	 * frame (skb->data) and the start of the IP hdr.
+ 	 * l4os is the distance between the start of the
+ 	 * l3 hdr and the l4 hdr
+ 	 */
+ 	fcb->l3os = (u8)(skb_network_offset(skb) - fcb_length);
+ 	fcb->l4os = skb_network_header_len(skb);
+ 
+ 	fcb->flags = flags;
+ }
+ 
+ static inline void gfar_tx_vlan(struct sk_buff *skb, struct txfcb *fcb)
+ {
+ 	fcb->flags |= TXFCB_VLN;
+ 	fcb->vlctl = cpu_to_be16(skb_vlan_tag_get(skb));
+ }
+ 
+ static inline struct txbd8 *skip_txbd(struct txbd8 *bdp, int stride,
+ 				      struct txbd8 *base, int ring_size)
+ {
+ 	struct txbd8 *new_bd = bdp + stride;
+ 
+ 	return (new_bd >= (base + ring_size)) ? (new_bd - ring_size) : new_bd;
+ }
+ 
+ static inline struct txbd8 *next_txbd(struct txbd8 *bdp, struct txbd8 *base,
+ 				      int ring_size)
+ {
+ 	return skip_txbd(bdp, 1, base, ring_size);
+ }
+ 
+ /* eTSEC12: csum generation not supported for some fcb offsets */
+ static inline bool gfar_csum_errata_12(struct gfar_private *priv,
+ 				       unsigned long fcb_addr)
+ {
+ 	return (gfar_has_errata(priv, GFAR_ERRATA_12) &&
+ 	       (fcb_addr % 0x20) > 0x18);
+ }
+ 
+ /* eTSEC76: csum generation for frames larger than 2500 may
+  * cause excess delays before start of transmission
+  */
+ static inline bool gfar_csum_errata_76(struct gfar_private *priv,
+ 				       unsigned int len)
+ {
+ 	return (gfar_has_errata(priv, GFAR_ERRATA_76) &&
+ 	       (len > 2500));
+ }
+ 
+ /* This is called by the kernel when a frame is ready for transmission.
+  * It is pointed to by the dev->hard_start_xmit function pointer
+  */
+ static netdev_tx_t gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct gfar_private *priv = netdev_priv(dev);
+ 	struct gfar_priv_tx_q *tx_queue = NULL;
+ 	struct netdev_queue *txq;
+ 	struct gfar __iomem *regs = NULL;
+ 	struct txfcb *fcb = NULL;
+ 	struct txbd8 *txbdp, *txbdp_start, *base, *txbdp_tstamp = NULL;
+ 	u32 lstatus;
+ 	skb_frag_t *frag;
+ 	int i, rq = 0;
+ 	int do_tstamp, do_csum, do_vlan;
+ 	u32 bufaddr;
+ 	unsigned int nr_frags, nr_txbds, bytes_sent, fcb_len = 0;
+ 
+ 	rq = skb->queue_mapping;
+ 	tx_queue = priv->tx_queue[rq];
+ 	txq = netdev_get_tx_queue(dev, rq);
+ 	base = tx_queue->tx_bd_base;
+ 	regs = tx_queue->grp->regs;
+ 
+ 	do_csum = (CHECKSUM_PARTIAL == skb->ip_summed);
+ 	do_vlan = skb_vlan_tag_present(skb);
+ 	do_tstamp = (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&
+ 		    priv->hwts_tx_en;
+ 
+ 	if (do_csum || do_vlan)
+ 		fcb_len = GMAC_FCB_LEN;
+ 
+ 	/* check if time stamp should be generated */
+ 	if (unlikely(do_tstamp))
+ 		fcb_len = GMAC_FCB_LEN + GMAC_TXPAL_LEN;
+ 
+ 	/* make space for additional header when fcb is needed */
+ 	if (fcb_len && unlikely(skb_headroom(skb) < fcb_len)) {
+ 		struct sk_buff *skb_new;
+ 
+ 		skb_new = skb_realloc_headroom(skb, fcb_len);
+ 		if (!skb_new) {
+ 			dev->stats.tx_errors++;
+ 			dev_kfree_skb_any(skb);
+ 			return NETDEV_TX_OK;
+ 		}
+ 
+ 		if (skb->sk)
+ 			skb_set_owner_w(skb_new, skb->sk);
+ 		dev_consume_skb_any(skb);
+ 		skb = skb_new;
+ 	}
+ 
+ 	/* total number of fragments in the SKB */
+ 	nr_frags = skb_shinfo(skb)->nr_frags;
+ 
+ 	/* calculate the required number of TxBDs for this skb */
+ 	if (unlikely(do_tstamp))
+ 		nr_txbds = nr_frags + 2;
+ 	else
+ 		nr_txbds = nr_frags + 1;
+ 
+ 	/* check if there is space to queue this packet */
+ 	if (nr_txbds > tx_queue->num_txbdfree) {
+ 		/* no space, stop the queue */
+ 		netif_tx_stop_queue(txq);
+ 		dev->stats.tx_fifo_errors++;
+ 		return NETDEV_TX_BUSY;
+ 	}
+ 
+ 	/* Update transmit stats */
+ 	bytes_sent = skb->len;
+ 	tx_queue->stats.tx_bytes += bytes_sent;
+ 	/* keep Tx bytes on wire for BQL accounting */
+ 	GFAR_CB(skb)->bytes_sent = bytes_sent;
+ 	tx_queue->stats.tx_packets++;
+ 
+ 	txbdp = txbdp_start = tx_queue->cur_tx;
+ 	lstatus = be32_to_cpu(txbdp->lstatus);
+ 
+ 	/* Add TxPAL between FCB and frame if required */
+ 	if (unlikely(do_tstamp)) {
+ 		skb_push(skb, GMAC_TXPAL_LEN);
+ 		memset(skb->data, 0, GMAC_TXPAL_LEN);
+ 	}
+ 
+ 	/* Add TxFCB if required */
+ 	if (fcb_len) {
+ 		fcb = gfar_add_fcb(skb);
+ 		lstatus |= BD_LFLAG(TXBD_TOE);
+ 	}
+ 
+ 	/* Set up checksumming */
+ 	if (do_csum) {
+ 		gfar_tx_checksum(skb, fcb, fcb_len);
+ 
+ 		if (unlikely(gfar_csum_errata_12(priv, (unsigned long)fcb)) ||
+ 		    unlikely(gfar_csum_errata_76(priv, skb->len))) {
+ 			__skb_pull(skb, GMAC_FCB_LEN);
+ 			skb_checksum_help(skb);
+ 			if (do_vlan || do_tstamp) {
+ 				/* put back a new fcb for vlan/tstamp TOE */
+ 				fcb = gfar_add_fcb(skb);
+ 			} else {
+ 				/* Tx TOE not used */
+ 				lstatus &= ~(BD_LFLAG(TXBD_TOE));
+ 				fcb = NULL;
+ 			}
+ 		}
+ 	}
+ 
+ 	if (do_vlan)
+ 		gfar_tx_vlan(skb, fcb);
+ 
+ 	bufaddr = dma_map_single(priv->dev, skb->data, skb_headlen(skb),
+ 				 DMA_TO_DEVICE);
+ 	if (unlikely(dma_mapping_error(priv->dev, bufaddr)))
+ 		goto dma_map_err;
+ 
+ 	txbdp_start->bufPtr = cpu_to_be32(bufaddr);
+ 
+ 	/* Time stamp insertion requires one additional TxBD */
+ 	if (unlikely(do_tstamp))
+ 		txbdp_tstamp = txbdp = next_txbd(txbdp, base,
+ 						 tx_queue->tx_ring_size);
+ 
+ 	if (likely(!nr_frags)) {
+ 		if (likely(!do_tstamp))
+ 			lstatus |= BD_LFLAG(TXBD_LAST | TXBD_INTERRUPT);
+ 	} else {
+ 		u32 lstatus_start = lstatus;
+ 
+ 		/* Place the fragment addresses and lengths into the TxBDs */
+ 		frag = &skb_shinfo(skb)->frags[0];
+ 		for (i = 0; i < nr_frags; i++, frag++) {
+ 			unsigned int size;
+ 
+ 			/* Point at the next BD, wrapping as needed */
+ 			txbdp = next_txbd(txbdp, base, tx_queue->tx_ring_size);
+ 
+ 			size = skb_frag_size(frag);
+ 
+ 			lstatus = be32_to_cpu(txbdp->lstatus) | size |
+ 				  BD_LFLAG(TXBD_READY);
+ 
+ 			/* Handle the last BD specially */
+ 			if (i == nr_frags - 1)
+ 				lstatus |= BD_LFLAG(TXBD_LAST | TXBD_INTERRUPT);
+ 
+ 			bufaddr = skb_frag_dma_map(priv->dev, frag, 0,
+ 						   size, DMA_TO_DEVICE);
+ 			if (unlikely(dma_mapping_error(priv->dev, bufaddr)))
+ 				goto dma_map_err;
+ 
+ 			/* set the TxBD length and buffer pointer */
+ 			txbdp->bufPtr = cpu_to_be32(bufaddr);
+ 			txbdp->lstatus = cpu_to_be32(lstatus);
+ 		}
+ 
+ 		lstatus = lstatus_start;
+ 	}
+ 
+ 	/* If time stamping is requested one additional TxBD must be set up. The
+ 	 * first TxBD points to the FCB and must have a data length of
+ 	 * GMAC_FCB_LEN. The second TxBD points to the actual frame data with
+ 	 * the full frame length.
+ 	 */
+ 	if (unlikely(do_tstamp)) {
+ 		u32 lstatus_ts = be32_to_cpu(txbdp_tstamp->lstatus);
+ 
+ 		bufaddr = be32_to_cpu(txbdp_start->bufPtr);
+ 		bufaddr += fcb_len;
+ 
+ 		lstatus_ts |= BD_LFLAG(TXBD_READY) |
+ 			      (skb_headlen(skb) - fcb_len);
+ 		if (!nr_frags)
+ 			lstatus_ts |= BD_LFLAG(TXBD_LAST | TXBD_INTERRUPT);
+ 
+ 		txbdp_tstamp->bufPtr = cpu_to_be32(bufaddr);
+ 		txbdp_tstamp->lstatus = cpu_to_be32(lstatus_ts);
+ 		lstatus |= BD_LFLAG(TXBD_CRC | TXBD_READY) | GMAC_FCB_LEN;
+ 
+ 		/* Setup tx hardware time stamping */
+ 		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+ 		fcb->ptp = 1;
+ 	} else {
+ 		lstatus |= BD_LFLAG(TXBD_CRC | TXBD_READY) | skb_headlen(skb);
+ 	}
+ 
+ 	netdev_tx_sent_queue(txq, bytes_sent);
+ 
+ 	gfar_wmb();
+ 
+ 	txbdp_start->lstatus = cpu_to_be32(lstatus);
+ 
+ 	gfar_wmb(); /* force lstatus write before tx_skbuff */
+ 
+ 	tx_queue->tx_skbuff[tx_queue->skb_curtx] = skb;
+ 
+ 	/* Update the current skb pointer to the next entry we will use
+ 	 * (wrapping if necessary)
+ 	 */
+ 	tx_queue->skb_curtx = (tx_queue->skb_curtx + 1) &
+ 			      TX_RING_MOD_MASK(tx_queue->tx_ring_size);
+ 
+ 	tx_queue->cur_tx = next_txbd(txbdp, base, tx_queue->tx_ring_size);
+ 
+ 	/* We can work in parallel with gfar_clean_tx_ring(), except
+ 	 * when modifying num_txbdfree. Note that we didn't grab the lock
+ 	 * when we were reading the num_txbdfree and checking for available
+ 	 * space, that's because outside of this function it can only grow.
+ 	 */
+ 	spin_lock_bh(&tx_queue->txlock);
+ 	/* reduce TxBD free count */
+ 	tx_queue->num_txbdfree -= (nr_txbds);
+ 	spin_unlock_bh(&tx_queue->txlock);
+ 
+ 	/* If the next BD still needs to be cleaned up, then the bds
+ 	 * are full.  We need to tell the kernel to stop sending us stuff.
+ 	 */
+ 	if (!tx_queue->num_txbdfree) {
+ 		netif_tx_stop_queue(txq);
+ 
+ 		dev->stats.tx_fifo_errors++;
+ 	}
+ 
+ 	/* Tell the DMA to go go go */
+ 	gfar_write(&regs->tstat, TSTAT_CLEAR_THALT >> tx_queue->qindex);
+ 
+ 	return NETDEV_TX_OK;
+ 
+ dma_map_err:
+ 	txbdp = next_txbd(txbdp_start, base, tx_queue->tx_ring_size);
+ 	if (do_tstamp)
+ 		txbdp = next_txbd(txbdp, base, tx_queue->tx_ring_size);
+ 	for (i = 0; i < nr_frags; i++) {
+ 		lstatus = be32_to_cpu(txbdp->lstatus);
+ 		if (!(lstatus & BD_LFLAG(TXBD_READY)))
+ 			break;
+ 
+ 		lstatus &= ~BD_LFLAG(TXBD_READY);
+ 		txbdp->lstatus = cpu_to_be32(lstatus);
+ 		bufaddr = be32_to_cpu(txbdp->bufPtr);
+ 		dma_unmap_page(priv->dev, bufaddr, be16_to_cpu(txbdp->length),
+ 			       DMA_TO_DEVICE);
+ 		txbdp = next_txbd(txbdp, base, tx_queue->tx_ring_size);
+ 	}
+ 	gfar_wmb();
+ 	dev_kfree_skb_any(skb);
+ 	return NETDEV_TX_OK;
+ }
+ 
+ /* Changes the mac address if the controller is not running. */
+ static int gfar_set_mac_address(struct net_device *dev)
+ {
+ 	gfar_set_mac_for_addr(dev, 0, dev->dev_addr);
+ 
+ 	return 0;
+ }
+ 
+ static int gfar_change_mtu(struct net_device *dev, int new_mtu)
+ {
+ 	struct gfar_private *priv = netdev_priv(dev);
+ 
+ 	while (test_and_set_bit_lock(GFAR_RESETTING, &priv->state))
+ 		cpu_relax();
+ 
+ 	if (dev->flags & IFF_UP)
+ 		stop_gfar(dev);
+ 
+ 	dev->mtu = new_mtu;
+ 
+ 	if (dev->flags & IFF_UP)
+ 		startup_gfar(dev);
+ 
+ 	clear_bit_unlock(GFAR_RESETTING, &priv->state);
+ 
+ 	return 0;
+ }
+ 
+ static void reset_gfar(struct net_device *ndev)
+ {
+ 	struct gfar_private *priv = netdev_priv(ndev);
+ 
+ 	while (test_and_set_bit_lock(GFAR_RESETTING, &priv->state))
+ 		cpu_relax();
+ 
+ 	stop_gfar(ndev);
+ 	startup_gfar(ndev);
+ 
+ 	clear_bit_unlock(GFAR_RESETTING, &priv->state);
+ }
+ 
+ /* gfar_reset_task gets scheduled when a packet has not been
+  * transmitted after a set amount of time.
+  * For now, assume that clearing out all the structures, and
+  * starting over will fix the problem.
+  */
+ static void gfar_reset_task(struct work_struct *work)
+ {
+ 	struct gfar_private *priv = container_of(work, struct gfar_private,
+ 						 reset_task);
+ 	reset_gfar(priv->ndev);
+ }
+ 
+ static void gfar_timeout(struct net_device *dev, unsigned int txqueue)
+ {
+ 	struct gfar_private *priv = netdev_priv(dev);
+ 
+ 	dev->stats.tx_errors++;
+ 	schedule_work(&priv->reset_task);
+ }
+ 
+ static int gfar_hwtstamp_set(struct net_device *netdev, struct ifreq *ifr)
+ {
+ 	struct hwtstamp_config config;
+ 	struct gfar_private *priv = netdev_priv(netdev);
+ 
+ 	if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+ 		return -EFAULT;
+ 
+ 	/* reserved for future extensions */
+ 	if (config.flags)
+ 		return -EINVAL;
+ 
+ 	switch (config.tx_type) {
+ 	case HWTSTAMP_TX_OFF:
+ 		priv->hwts_tx_en = 0;
+ 		break;
+ 	case HWTSTAMP_TX_ON:
+ 		if (!(priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER))
+ 			return -ERANGE;
+ 		priv->hwts_tx_en = 1;
+ 		break;
+ 	default:
+ 		return -ERANGE;
+ 	}
+ 
+ 	switch (config.rx_filter) {
+ 	case HWTSTAMP_FILTER_NONE:
+ 		if (priv->hwts_rx_en) {
+ 			priv->hwts_rx_en = 0;
+ 			reset_gfar(netdev);
+ 		}
+ 		break;
+ 	default:
+ 		if (!(priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER))
+ 			return -ERANGE;
+ 		if (!priv->hwts_rx_en) {
+ 			priv->hwts_rx_en = 1;
+ 			reset_gfar(netdev);
+ 		}
+ 		config.rx_filter = HWTSTAMP_FILTER_ALL;
+ 		break;
+ 	}
+ 
+ 	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
+ 		-EFAULT : 0;
+ }
+ 
+ static int gfar_hwtstamp_get(struct net_device *netdev, struct ifreq *ifr)
+ {
+ 	struct hwtstamp_config config;
+ 	struct gfar_private *priv = netdev_priv(netdev);
+ 
+ 	config.flags = 0;
+ 	config.tx_type = priv->hwts_tx_en ? HWTSTAMP_TX_ON : HWTSTAMP_TX_OFF;
+ 	config.rx_filter = (priv->hwts_rx_en ?
+ 			    HWTSTAMP_FILTER_ALL : HWTSTAMP_FILTER_NONE);
+ 
+ 	return copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?
+ 		-EFAULT : 0;
+ }
+ 
+ static int gfar_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+ {
+ 	struct phy_device *phydev = dev->phydev;
+ 
+ 	if (!netif_running(dev))
+ 		return -EINVAL;
+ 
+ 	if (cmd == SIOCSHWTSTAMP)
+ 		return gfar_hwtstamp_set(dev, rq);
+ 	if (cmd == SIOCGHWTSTAMP)
+ 		return gfar_hwtstamp_get(dev, rq);
+ 
+ 	if (!phydev)
+ 		return -ENODEV;
+ 
+ 	return phy_mii_ioctl(phydev, rq, cmd);
+ }
+ 
+ /* Interrupt Handler for Transmit complete */
+ static void gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
+ {
+ 	struct net_device *dev = tx_queue->dev;
+ 	struct netdev_queue *txq;
+ 	struct gfar_private *priv = netdev_priv(dev);
+ 	struct txbd8 *bdp, *next = NULL;
+ 	struct txbd8 *lbdp = NULL;
+ 	struct txbd8 *base = tx_queue->tx_bd_base;
+ 	struct sk_buff *skb;
+ 	int skb_dirtytx;
+ 	int tx_ring_size = tx_queue->tx_ring_size;
+ 	int frags = 0, nr_txbds = 0;
+ 	int i;
+ 	int howmany = 0;
+ 	int tqi = tx_queue->qindex;
+ 	unsigned int bytes_sent = 0;
+ 	u32 lstatus;
+ 	size_t buflen;
+ 
+ 	txq = netdev_get_tx_queue(dev, tqi);
+ 	bdp = tx_queue->dirty_tx;
+ 	skb_dirtytx = tx_queue->skb_dirtytx;
+ 
+ 	while ((skb = tx_queue->tx_skbuff[skb_dirtytx])) {
+ 
+ 		frags = skb_shinfo(skb)->nr_frags;
+ 
+ 		/* When time stamping, one additional TxBD must be freed.
+ 		 * Also, we need to dma_unmap_single() the TxPAL.
+ 		 */
+ 		if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS))
+ 			nr_txbds = frags + 2;
+ 		else
+ 			nr_txbds = frags + 1;
+ 
+ 		lbdp = skip_txbd(bdp, nr_txbds - 1, base, tx_ring_size);
+ 
+ 		lstatus = be32_to_cpu(lbdp->lstatus);
+ 
+ 		/* Only clean completed frames */
+ 		if ((lstatus & BD_LFLAG(TXBD_READY)) &&
+ 		    (lstatus & BD_LENGTH_MASK))
+ 			break;
+ 
+ 		if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS)) {
+ 			next = next_txbd(bdp, base, tx_ring_size);
+ 			buflen = be16_to_cpu(next->length) +
+ 				 GMAC_FCB_LEN + GMAC_TXPAL_LEN;
+ 		} else
+ 			buflen = be16_to_cpu(bdp->length);
+ 
+ 		dma_unmap_single(priv->dev, be32_to_cpu(bdp->bufPtr),
+ 				 buflen, DMA_TO_DEVICE);
+ 
+ 		if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS)) {
+ 			struct skb_shared_hwtstamps shhwtstamps;
+ 			u64 *ns = (u64 *)(((uintptr_t)skb->data + 0x10) &
+ 					  ~0x7UL);
+ 
+ 			memset(&shhwtstamps, 0, sizeof(shhwtstamps));
+ 			shhwtstamps.hwtstamp = ns_to_ktime(be64_to_cpu(*ns));
+ 			skb_pull(skb, GMAC_FCB_LEN + GMAC_TXPAL_LEN);
+ 			skb_tstamp_tx(skb, &shhwtstamps);
+ 			gfar_clear_txbd_status(bdp);
+ 			bdp = next;
+ 		}
+ 
+ 		gfar_clear_txbd_status(bdp);
+ 		bdp = next_txbd(bdp, base, tx_ring_size);
+ 
+ 		for (i = 0; i < frags; i++) {
+ 			dma_unmap_page(priv->dev, be32_to_cpu(bdp->bufPtr),
+ 				       be16_to_cpu(bdp->length),
+ 				       DMA_TO_DEVICE);
+ 			gfar_clear_txbd_status(bdp);
+ 			bdp = next_txbd(bdp, base, tx_ring_size);
+ 		}
+ 
+ 		bytes_sent += GFAR_CB(skb)->bytes_sent;
+ 
+ 		dev_kfree_skb_any(skb);
+ 
+ 		tx_queue->tx_skbuff[skb_dirtytx] = NULL;
+ 
+ 		skb_dirtytx = (skb_dirtytx + 1) &
+ 			      TX_RING_MOD_MASK(tx_ring_size);
+ 
+ 		howmany++;
+ 		spin_lock(&tx_queue->txlock);
+ 		tx_queue->num_txbdfree += nr_txbds;
+ 		spin_unlock(&tx_queue->txlock);
+ 	}
+ 
+ 	/* If we freed a buffer, we can restart transmission, if necessary */
+ 	if (tx_queue->num_txbdfree &&
+ 	    netif_tx_queue_stopped(txq) &&
+ 	    !(test_bit(GFAR_DOWN, &priv->state)))
+ 		netif_wake_subqueue(priv->ndev, tqi);
+ 
+ 	/* Update dirty indicators */
+ 	tx_queue->skb_dirtytx = skb_dirtytx;
+ 	tx_queue->dirty_tx = bdp;
+ 
+ 	netdev_tx_completed_queue(txq, howmany, bytes_sent);
+ }
+ 
+ static void count_errors(u32 lstatus, struct net_device *ndev)
+ {
+ 	struct gfar_private *priv = netdev_priv(ndev);
+ 	struct net_device_stats *stats = &ndev->stats;
+ 	struct gfar_extra_stats *estats = &priv->extra_stats;
+ 
+ 	/* If the packet was truncated, none of the other errors matter */
+ 	if (lstatus & BD_LFLAG(RXBD_TRUNCATED)) {
+ 		stats->rx_length_errors++;
+ 
+ 		atomic64_inc(&estats->rx_trunc);
+ 
+ 		return;
+ 	}
+ 	/* Count the errors, if there were any */
+ 	if (lstatus & BD_LFLAG(RXBD_LARGE | RXBD_SHORT)) {
+ 		stats->rx_length_errors++;
+ 
+ 		if (lstatus & BD_LFLAG(RXBD_LARGE))
+ 			atomic64_inc(&estats->rx_large);
+ 		else
+ 			atomic64_inc(&estats->rx_short);
+ 	}
+ 	if (lstatus & BD_LFLAG(RXBD_NONOCTET)) {
+ 		stats->rx_frame_errors++;
+ 		atomic64_inc(&estats->rx_nonoctet);
+ 	}
+ 	if (lstatus & BD_LFLAG(RXBD_CRCERR)) {
+ 		atomic64_inc(&estats->rx_crcerr);
+ 		stats->rx_crc_errors++;
+ 	}
+ 	if (lstatus & BD_LFLAG(RXBD_OVERRUN)) {
+ 		atomic64_inc(&estats->rx_overrun);
+ 		stats->rx_over_errors++;
+ 	}
+ }
+ 
+ static irqreturn_t gfar_receive(int irq, void *grp_id)
+ {
+ 	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
+ 	unsigned long flags;
+ 	u32 imask, ievent;
+ 
+ 	ievent = gfar_read(&grp->regs->ievent);
+ 
+ 	if (unlikely(ievent & IEVENT_FGPI)) {
+ 		gfar_write(&grp->regs->ievent, IEVENT_FGPI);
+ 		return IRQ_HANDLED;
+ 	}
+ 
+ 	if (likely(napi_schedule_prep(&grp->napi_rx))) {
+ 		spin_lock_irqsave(&grp->grplock, flags);
+ 		imask = gfar_read(&grp->regs->imask);
+ 		imask &= IMASK_RX_DISABLED;
+ 		gfar_write(&grp->regs->imask, imask);
+ 		spin_unlock_irqrestore(&grp->grplock, flags);
+ 		__napi_schedule(&grp->napi_rx);
+ 	} else {
+ 		/* Clear IEVENT, so interrupts aren't called again
+ 		 * because of the packets that have already arrived.
+ 		 */
+ 		gfar_write(&grp->regs->ievent, IEVENT_RX_MASK);
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ /* Interrupt Handler for Transmit complete */
+ static irqreturn_t gfar_transmit(int irq, void *grp_id)
+ {
+ 	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
+ 	unsigned long flags;
+ 	u32 imask;
+ 
+ 	if (likely(napi_schedule_prep(&grp->napi_tx))) {
+ 		spin_lock_irqsave(&grp->grplock, flags);
+ 		imask = gfar_read(&grp->regs->imask);
+ 		imask &= IMASK_TX_DISABLED;
+ 		gfar_write(&grp->regs->imask, imask);
+ 		spin_unlock_irqrestore(&grp->grplock, flags);
+ 		__napi_schedule(&grp->napi_tx);
+ 	} else {
+ 		/* Clear IEVENT, so interrupts aren't called again
+ 		 * because of the packets that have already arrived.
+ 		 */
+ 		gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
+ 	}
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ static bool gfar_add_rx_frag(struct gfar_rx_buff *rxb, u32 lstatus,
+ 			     struct sk_buff *skb, bool first)
+ {
+ 	int size = lstatus & BD_LENGTH_MASK;
+ 	struct page *page = rxb->page;
+ 
+ 	if (likely(first)) {
+ 		skb_put(skb, size);
+ 	} else {
+ 		/* the last fragments' length contains the full frame length */
+ 		if (lstatus & BD_LFLAG(RXBD_LAST))
+ 			size -= skb->len;
+ 
+ 		skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,
+ 				rxb->page_offset + RXBUF_ALIGNMENT,
+ 				size, GFAR_RXB_TRUESIZE);
+ 	}
+ 
+ 	/* try reuse page */
+ 	if (unlikely(page_count(page) != 1 || page_is_pfmemalloc(page)))
+ 		return false;
+ 
+ 	/* change offset to the other half */
+ 	rxb->page_offset ^= GFAR_RXB_TRUESIZE;
+ 
+ 	page_ref_inc(page);
+ 
+ 	return true;
+ }
+ 
+ static void gfar_reuse_rx_page(struct gfar_priv_rx_q *rxq,
+ 			       struct gfar_rx_buff *old_rxb)
+ {
+ 	struct gfar_rx_buff *new_rxb;
+ 	u16 nta = rxq->next_to_alloc;
+ 
+ 	new_rxb = &rxq->rx_buff[nta];
+ 
+ 	/* find next buf that can reuse a page */
+ 	nta++;
+ 	rxq->next_to_alloc = (nta < rxq->rx_ring_size) ? nta : 0;
+ 
+ 	/* copy page reference */
+ 	*new_rxb = *old_rxb;
+ 
+ 	/* sync for use by the device */
+ 	dma_sync_single_range_for_device(rxq->dev, old_rxb->dma,
+ 					 old_rxb->page_offset,
+ 					 GFAR_RXB_TRUESIZE, DMA_FROM_DEVICE);
+ }
+ 
+ static struct sk_buff *gfar_get_next_rxbuff(struct gfar_priv_rx_q *rx_queue,
+ 					    u32 lstatus, struct sk_buff *skb)
+ {
+ 	struct gfar_rx_buff *rxb = &rx_queue->rx_buff[rx_queue->next_to_clean];
+ 	struct page *page = rxb->page;
+ 	bool first = false;
+ 
+ 	if (likely(!skb)) {
+ 		void *buff_addr = page_address(page) + rxb->page_offset;
+ 
+ 		skb = build_skb(buff_addr, GFAR_SKBFRAG_SIZE);
+ 		if (unlikely(!skb)) {
+ 			gfar_rx_alloc_err(rx_queue);
+ 			return NULL;
+ 		}
+ 		skb_reserve(skb, RXBUF_ALIGNMENT);
+ 		first = true;
+ 	}
+ 
+ 	dma_sync_single_range_for_cpu(rx_queue->dev, rxb->dma, rxb->page_offset,
+ 				      GFAR_RXB_TRUESIZE, DMA_FROM_DEVICE);
+ 
+ 	if (gfar_add_rx_frag(rxb, lstatus, skb, first)) {
+ 		/* reuse the free half of the page */
+ 		gfar_reuse_rx_page(rx_queue, rxb);
+ 	} else {
+ 		/* page cannot be reused, unmap it */
+ 		dma_unmap_page(rx_queue->dev, rxb->dma,
+ 			       PAGE_SIZE, DMA_FROM_DEVICE);
+ 	}
+ 
+ 	/* clear rxb content */
+ 	rxb->page = NULL;
+ 
+ 	return skb;
+ }
+ 
+ static inline void gfar_rx_checksum(struct sk_buff *skb, struct rxfcb *fcb)
+ {
+ 	/* If valid headers were found, and valid sums
+ 	 * were verified, then we tell the kernel that no
+ 	 * checksumming is necessary.  Otherwise, it is [FIXME]
+ 	 */
+ 	if ((be16_to_cpu(fcb->flags) & RXFCB_CSUM_MASK) ==
+ 	    (RXFCB_CIP | RXFCB_CTU))
+ 		skb->ip_summed = CHECKSUM_UNNECESSARY;
+ 	else
+ 		skb_checksum_none_assert(skb);
+ }
+ 
+ /* gfar_process_frame() -- handle one incoming packet if skb isn't NULL. */
+ static void gfar_process_frame(struct net_device *ndev, struct sk_buff *skb)
+ {
+ 	struct gfar_private *priv = netdev_priv(ndev);
+ 	struct rxfcb *fcb = NULL;
+ 
+ 	/* fcb is at the beginning if exists */
+ 	fcb = (struct rxfcb *)skb->data;
+ 
+ 	/* Remove the FCB from the skb
+ 	 * Remove the padded bytes, if there are any
+ 	 */
+ 	if (priv->uses_rxfcb)
+ 		skb_pull(skb, GMAC_FCB_LEN);
+ 
+ 	/* Get receive timestamp from the skb */
+ 	if (priv->hwts_rx_en) {
+ 		struct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);
+ 		u64 *ns = (u64 *) skb->data;
+ 
+ 		memset(shhwtstamps, 0, sizeof(*shhwtstamps));
+ 		shhwtstamps->hwtstamp = ns_to_ktime(be64_to_cpu(*ns));
+ 	}
+ 
+ 	if (priv->padding)
+ 		skb_pull(skb, priv->padding);
+ 
+ 	/* Trim off the FCS */
+ 	pskb_trim(skb, skb->len - ETH_FCS_LEN);
+ 
+ 	if (ndev->features & NETIF_F_RXCSUM)
+ 		gfar_rx_checksum(skb, fcb);
+ 
+ 	/* There's need to check for NETIF_F_HW_VLAN_CTAG_RX here.
+ 	 * Even if vlan rx accel is disabled, on some chips
+ 	 * RXFCB_VLN is pseudo randomly set.
+ 	 */
+ 	if (ndev->features & NETIF_F_HW_VLAN_CTAG_RX &&
+ 	    be16_to_cpu(fcb->flags) & RXFCB_VLN)
+ 		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
+ 				       be16_to_cpu(fcb->vlctl));
+ }
+ 
+ /* gfar_clean_rx_ring() -- Processes each frame in the rx ring
+  * until the budget/quota has been reached. Returns the number
+  * of frames handled
+  */
+ static int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue,
+ 			      int rx_work_limit)
+ {
+ 	struct net_device *ndev = rx_queue->ndev;
+ 	struct gfar_private *priv = netdev_priv(ndev);
+ 	struct rxbd8 *bdp;
+ 	int i, howmany = 0;
+ 	struct sk_buff *skb = rx_queue->skb;
+ 	int cleaned_cnt = gfar_rxbd_unused(rx_queue);
+ 	unsigned int total_bytes = 0, total_pkts = 0;
+ 
+ 	/* Get the first full descriptor */
+ 	i = rx_queue->next_to_clean;
+ 
+ 	while (rx_work_limit--) {
+ 		u32 lstatus;
+ 
+ 		if (cleaned_cnt >= GFAR_RX_BUFF_ALLOC) {
+ 			gfar_alloc_rx_buffs(rx_queue, cleaned_cnt);
+ 			cleaned_cnt = 0;
+ 		}
+ 
+ 		bdp = &rx_queue->rx_bd_base[i];
+ 		lstatus = be32_to_cpu(bdp->lstatus);
+ 		if (lstatus & BD_LFLAG(RXBD_EMPTY))
+ 			break;
+ 
+ 		/* order rx buffer descriptor reads */
+ 		rmb();
+ 
+ 		/* fetch next to clean buffer from the ring */
+ 		skb = gfar_get_next_rxbuff(rx_queue, lstatus, skb);
+ 		if (unlikely(!skb))
+ 			break;
+ 
+ 		cleaned_cnt++;
+ 		howmany++;
+ 
+ 		if (unlikely(++i == rx_queue->rx_ring_size))
+ 			i = 0;
+ 
+ 		rx_queue->next_to_clean = i;
+ 
+ 		/* fetch next buffer if not the last in frame */
+ 		if (!(lstatus & BD_LFLAG(RXBD_LAST)))
+ 			continue;
+ 
+ 		if (unlikely(lstatus & BD_LFLAG(RXBD_ERR))) {
+ 			count_errors(lstatus, ndev);
+ 
+ 			/* discard faulty buffer */
+ 			dev_kfree_skb(skb);
+ 			skb = NULL;
+ 			rx_queue->stats.rx_dropped++;
+ 			continue;
+ 		}
+ 
+ 		gfar_process_frame(ndev, skb);
+ 
+ 		/* Increment the number of packets */
+ 		total_pkts++;
+ 		total_bytes += skb->len;
+ 
+ 		skb_record_rx_queue(skb, rx_queue->qindex);
+ 
+ 		skb->protocol = eth_type_trans(skb, ndev);
+ 
+ 		/* Send the packet up the stack */
+ 		napi_gro_receive(&rx_queue->grp->napi_rx, skb);
+ 
+ 		skb = NULL;
+ 	}
+ 
+ 	/* Store incomplete frames for completion */
+ 	rx_queue->skb = skb;
+ 
+ 	rx_queue->stats.rx_packets += total_pkts;
+ 	rx_queue->stats.rx_bytes += total_bytes;
+ 
+ 	if (cleaned_cnt)
+ 		gfar_alloc_rx_buffs(rx_queue, cleaned_cnt);
+ 
+ 	/* Update Last Free RxBD pointer for LFC */
+ 	if (unlikely(priv->tx_actual_en)) {
+ 		u32 bdp_dma = gfar_rxbd_dma_lastfree(rx_queue);
+ 
+ 		gfar_write(rx_queue->rfbptr, bdp_dma);
+ 	}
+ 
+ 	return howmany;
+ }
+ 
+ static int gfar_poll_rx_sq(struct napi_struct *napi, int budget)
+ {
+ 	struct gfar_priv_grp *gfargrp =
+ 		container_of(napi, struct gfar_priv_grp, napi_rx);
+ 	struct gfar __iomem *regs = gfargrp->regs;
+ 	struct gfar_priv_rx_q *rx_queue = gfargrp->rx_queue;
+ 	int work_done = 0;
+ 
+ 	/* Clear IEVENT, so interrupts aren't called again
+ 	 * because of the packets that have already arrived
+ 	 */
+ 	gfar_write(&regs->ievent, IEVENT_RX_MASK);
+ 
+ 	work_done = gfar_clean_rx_ring(rx_queue, budget);
+ 
+ 	if (work_done < budget) {
+ 		u32 imask;
+ 		napi_complete_done(napi, work_done);
+ 		/* Clear the halt bit in RSTAT */
+ 		gfar_write(&regs->rstat, gfargrp->rstat);
+ 
+ 		spin_lock_irq(&gfargrp->grplock);
+ 		imask = gfar_read(&regs->imask);
+ 		imask |= IMASK_RX_DEFAULT;
+ 		gfar_write(&regs->imask, imask);
+ 		spin_unlock_irq(&gfargrp->grplock);
+ 	}
+ 
+ 	return work_done;
+ }
+ 
+ static int gfar_poll_tx_sq(struct napi_struct *napi, int budget)
+ {
+ 	struct gfar_priv_grp *gfargrp =
+ 		container_of(napi, struct gfar_priv_grp, napi_tx);
+ 	struct gfar __iomem *regs = gfargrp->regs;
+ 	struct gfar_priv_tx_q *tx_queue = gfargrp->tx_queue;
+ 	u32 imask;
+ 
+ 	/* Clear IEVENT, so interrupts aren't called again
+ 	 * because of the packets that have already arrived
+ 	 */
+ 	gfar_write(&regs->ievent, IEVENT_TX_MASK);
+ 
+ 	/* run Tx cleanup to completion */
+ 	if (tx_queue->tx_skbuff[tx_queue->skb_dirtytx])
+ 		gfar_clean_tx_ring(tx_queue);
+ 
+ 	napi_complete(napi);
+ 
+ 	spin_lock_irq(&gfargrp->grplock);
+ 	imask = gfar_read(&regs->imask);
+ 	imask |= IMASK_TX_DEFAULT;
+ 	gfar_write(&regs->imask, imask);
+ 	spin_unlock_irq(&gfargrp->grplock);
+ 
+ 	return 0;
+ }
+ 
+ static int gfar_poll_rx(struct napi_struct *napi, int budget)
+ {
+ 	struct gfar_priv_grp *gfargrp =
+ 		container_of(napi, struct gfar_priv_grp, napi_rx);
+ 	struct gfar_private *priv = gfargrp->priv;
+ 	struct gfar __iomem *regs = gfargrp->regs;
+ 	struct gfar_priv_rx_q *rx_queue = NULL;
+ 	int work_done = 0, work_done_per_q = 0;
+ 	int i, budget_per_q = 0;
+ 	unsigned long rstat_rxf;
+ 	int num_act_queues;
+ 
+ 	/* Clear IEVENT, so interrupts aren't called again
+ 	 * because of the packets that have already arrived
+ 	 */
+ 	gfar_write(&regs->ievent, IEVENT_RX_MASK);
+ 
+ 	rstat_rxf = gfar_read(&regs->rstat) & RSTAT_RXF_MASK;
+ 
+ 	num_act_queues = bitmap_weight(&rstat_rxf, MAX_RX_QS);
+ 	if (num_act_queues)
+ 		budget_per_q = budget/num_act_queues;
+ 
+ 	for_each_set_bit(i, &gfargrp->rx_bit_map, priv->num_rx_queues) {
+ 		/* skip queue if not active */
+ 		if (!(rstat_rxf & (RSTAT_CLEAR_RXF0 >> i)))
+ 			continue;
+ 
+ 		rx_queue = priv->rx_queue[i];
+ 		work_done_per_q =
+ 			gfar_clean_rx_ring(rx_queue, budget_per_q);
+ 		work_done += work_done_per_q;
+ 
+ 		/* finished processing this queue */
+ 		if (work_done_per_q < budget_per_q) {
+ 			/* clear active queue hw indication */
+ 			gfar_write(&regs->rstat,
+ 				   RSTAT_CLEAR_RXF0 >> i);
+ 			num_act_queues--;
+ 
+ 			if (!num_act_queues)
+ 				break;
+ 		}
+ 	}
+ 
+ 	if (!num_act_queues) {
+ 		u32 imask;
+ 		napi_complete_done(napi, work_done);
+ 
+ 		/* Clear the halt bit in RSTAT */
+ 		gfar_write(&regs->rstat, gfargrp->rstat);
+ 
+ 		spin_lock_irq(&gfargrp->grplock);
+ 		imask = gfar_read(&regs->imask);
+ 		imask |= IMASK_RX_DEFAULT;
+ 		gfar_write(&regs->imask, imask);
+ 		spin_unlock_irq(&gfargrp->grplock);
+ 	}
+ 
+ 	return work_done;
+ }
+ 
+ static int gfar_poll_tx(struct napi_struct *napi, int budget)
+ {
+ 	struct gfar_priv_grp *gfargrp =
+ 		container_of(napi, struct gfar_priv_grp, napi_tx);
+ 	struct gfar_private *priv = gfargrp->priv;
+ 	struct gfar __iomem *regs = gfargrp->regs;
+ 	struct gfar_priv_tx_q *tx_queue = NULL;
+ 	int has_tx_work = 0;
+ 	int i;
+ 
+ 	/* Clear IEVENT, so interrupts aren't called again
+ 	 * because of the packets that have already arrived
+ 	 */
+ 	gfar_write(&regs->ievent, IEVENT_TX_MASK);
+ 
+ 	for_each_set_bit(i, &gfargrp->tx_bit_map, priv->num_tx_queues) {
+ 		tx_queue = priv->tx_queue[i];
+ 		/* run Tx cleanup to completion */
+ 		if (tx_queue->tx_skbuff[tx_queue->skb_dirtytx]) {
+ 			gfar_clean_tx_ring(tx_queue);
+ 			has_tx_work = 1;
+ 		}
+ 	}
+ 
+ 	if (!has_tx_work) {
+ 		u32 imask;
+ 		napi_complete(napi);
+ 
+ 		spin_lock_irq(&gfargrp->grplock);
+ 		imask = gfar_read(&regs->imask);
+ 		imask |= IMASK_TX_DEFAULT;
+ 		gfar_write(&regs->imask, imask);
+ 		spin_unlock_irq(&gfargrp->grplock);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* GFAR error interrupt handler */
+ static irqreturn_t gfar_error(int irq, void *grp_id)
+ {
+ 	struct gfar_priv_grp *gfargrp = grp_id;
+ 	struct gfar __iomem *regs = gfargrp->regs;
+ 	struct gfar_private *priv= gfargrp->priv;
+ 	struct net_device *dev = priv->ndev;
+ 
+ 	/* Save ievent for future reference */
+ 	u32 events = gfar_read(&regs->ievent);
+ 
+ 	/* Clear IEVENT */
+ 	gfar_write(&regs->ievent, events & IEVENT_ERR_MASK);
+ 
+ 	/* Magic Packet is not an error. */
+ 	if ((priv->device_flags & FSL_GIANFAR_DEV_HAS_MAGIC_PACKET) &&
+ 	    (events & IEVENT_MAG))
+ 		events &= ~IEVENT_MAG;
+ 
+ 	/* Hmm... */
+ 	if (netif_msg_rx_err(priv) || netif_msg_tx_err(priv))
+ 		netdev_dbg(dev,
+ 			   "error interrupt (ievent=0x%08x imask=0x%08x)\n",
+ 			   events, gfar_read(&regs->imask));
+ 
+ 	/* Update the error counters */
+ 	if (events & IEVENT_TXE) {
+ 		dev->stats.tx_errors++;
+ 
+ 		if (events & IEVENT_LC)
+ 			dev->stats.tx_window_errors++;
+ 		if (events & IEVENT_CRL)
+ 			dev->stats.tx_aborted_errors++;
+ 		if (events & IEVENT_XFUN) {
+ 			netif_dbg(priv, tx_err, dev,
+ 				  "TX FIFO underrun, packet dropped\n");
+ 			dev->stats.tx_dropped++;
+ 			atomic64_inc(&priv->extra_stats.tx_underrun);
+ 
+ 			schedule_work(&priv->reset_task);
+ 		}
+ 		netif_dbg(priv, tx_err, dev, "Transmit Error\n");
+ 	}
+ 	if (events & IEVENT_BSY) {
+ 		dev->stats.rx_over_errors++;
+ 		atomic64_inc(&priv->extra_stats.rx_bsy);
+ 
+ 		netif_dbg(priv, rx_err, dev, "busy error (rstat: %x)\n",
+ 			  gfar_read(&regs->rstat));
+ 	}
+ 	if (events & IEVENT_BABR) {
+ 		dev->stats.rx_errors++;
+ 		atomic64_inc(&priv->extra_stats.rx_babr);
+ 
+ 		netif_dbg(priv, rx_err, dev, "babbling RX error\n");
+ 	}
+ 	if (events & IEVENT_EBERR) {
+ 		atomic64_inc(&priv->extra_stats.eberr);
+ 		netif_dbg(priv, rx_err, dev, "bus error\n");
+ 	}
+ 	if (events & IEVENT_RXC)
+ 		netif_dbg(priv, rx_status, dev, "control frame\n");
+ 
+ 	if (events & IEVENT_BABT) {
+ 		atomic64_inc(&priv->extra_stats.tx_babt);
+ 		netif_dbg(priv, tx_err, dev, "babbling TX error\n");
+ 	}
+ 	return IRQ_HANDLED;
+ }
+ 
+ /* The interrupt handler for devices with one interrupt */
+ static irqreturn_t gfar_interrupt(int irq, void *grp_id)
+ {
+ 	struct gfar_priv_grp *gfargrp = grp_id;
+ 
+ 	/* Save ievent for future reference */
+ 	u32 events = gfar_read(&gfargrp->regs->ievent);
+ 
+ 	/* Check for reception */
+ 	if (events & IEVENT_RX_MASK)
+ 		gfar_receive(irq, grp_id);
+ 
+ 	/* Check for transmit completion */
+ 	if (events & IEVENT_TX_MASK)
+ 		gfar_transmit(irq, grp_id);
+ 
+ 	/* Check for errors */
+ 	if (events & IEVENT_ERR_MASK)
+ 		gfar_error(irq, grp_id);
+ 
+ 	return IRQ_HANDLED;
+ }
+ 
+ #ifdef CONFIG_NET_POLL_CONTROLLER
+ /* Polling 'interrupt' - used by things like netconsole to send skbs
+  * without having to re-enable interrupts. It's not called while
+  * the interrupt routine is executing.
+  */
+ static void gfar_netpoll(struct net_device *dev)
+ {
+ 	struct gfar_private *priv = netdev_priv(dev);
+ 	int i;
+ 
+ 	/* If the device has multiple interrupts, run tx/rx */
+ 	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_MULTI_INTR) {
+ 		for (i = 0; i < priv->num_grps; i++) {
+ 			struct gfar_priv_grp *grp = &priv->gfargrp[i];
+ 
+ 			disable_irq(gfar_irq(grp, TX)->irq);
+ 			disable_irq(gfar_irq(grp, RX)->irq);
+ 			disable_irq(gfar_irq(grp, ER)->irq);
+ 			gfar_interrupt(gfar_irq(grp, TX)->irq, grp);
+ 			enable_irq(gfar_irq(grp, ER)->irq);
+ 			enable_irq(gfar_irq(grp, RX)->irq);
+ 			enable_irq(gfar_irq(grp, TX)->irq);
+ 		}
+ 	} else {
+ 		for (i = 0; i < priv->num_grps; i++) {
+ 			struct gfar_priv_grp *grp = &priv->gfargrp[i];
+ 
+ 			disable_irq(gfar_irq(grp, TX)->irq);
+ 			gfar_interrupt(gfar_irq(grp, TX)->irq, grp);
+ 			enable_irq(gfar_irq(grp, TX)->irq);
+ 		}
+ 	}
+ }
+ #endif
+ 
+ static void free_grp_irqs(struct gfar_priv_grp *grp)
+ {
+ 	free_irq(gfar_irq(grp, TX)->irq, grp);
+ 	free_irq(gfar_irq(grp, RX)->irq, grp);
+ 	free_irq(gfar_irq(grp, ER)->irq, grp);
+ }
+ 
+ static int register_grp_irqs(struct gfar_priv_grp *grp)
+ {
+ 	struct gfar_private *priv = grp->priv;
+ 	struct net_device *dev = priv->ndev;
+ 	int err;
+ 
+ 	/* If the device has multiple interrupts, register for
+ 	 * them.  Otherwise, only register for the one
+ 	 */
+ 	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_MULTI_INTR) {
+ 		/* Install our interrupt handlers for Error,
+ 		 * Transmit, and Receive
+ 		 */
+ 		err = request_irq(gfar_irq(grp, ER)->irq, gfar_error, 0,
+ 				  gfar_irq(grp, ER)->name, grp);
+ 		if (err < 0) {
+ 			netif_err(priv, intr, dev, "Can't get IRQ %d\n",
+ 				  gfar_irq(grp, ER)->irq);
+ 
+ 			goto err_irq_fail;
+ 		}
+ 		enable_irq_wake(gfar_irq(grp, ER)->irq);
+ 
+ 		err = request_irq(gfar_irq(grp, TX)->irq, gfar_transmit, 0,
+ 				  gfar_irq(grp, TX)->name, grp);
+ 		if (err < 0) {
+ 			netif_err(priv, intr, dev, "Can't get IRQ %d\n",
+ 				  gfar_irq(grp, TX)->irq);
+ 			goto tx_irq_fail;
+ 		}
+ 		err = request_irq(gfar_irq(grp, RX)->irq, gfar_receive, 0,
+ 				  gfar_irq(grp, RX)->name, grp);
+ 		if (err < 0) {
+ 			netif_err(priv, intr, dev, "Can't get IRQ %d\n",
+ 				  gfar_irq(grp, RX)->irq);
+ 			goto rx_irq_fail;
+ 		}
+ 		enable_irq_wake(gfar_irq(grp, RX)->irq);
+ 
+ 	} else {
+ 		err = request_irq(gfar_irq(grp, TX)->irq, gfar_interrupt, 0,
+ 				  gfar_irq(grp, TX)->name, grp);
+ 		if (err < 0) {
+ 			netif_err(priv, intr, dev, "Can't get IRQ %d\n",
+ 				  gfar_irq(grp, TX)->irq);
+ 			goto err_irq_fail;
+ 		}
+ 		enable_irq_wake(gfar_irq(grp, TX)->irq);
+ 	}
+ 
+ 	return 0;
+ 
+ rx_irq_fail:
+ 	free_irq(gfar_irq(grp, TX)->irq, grp);
+ tx_irq_fail:
+ 	free_irq(gfar_irq(grp, ER)->irq, grp);
+ err_irq_fail:
+ 	return err;
+ 
+ }
+ 
+ static void gfar_free_irq(struct gfar_private *priv)
+ {
+ 	int i;
+ 
+ 	/* Free the IRQs */
+ 	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_MULTI_INTR) {
+ 		for (i = 0; i < priv->num_grps; i++)
+ 			free_grp_irqs(&priv->gfargrp[i]);
+ 	} else {
+ 		for (i = 0; i < priv->num_grps; i++)
+ 			free_irq(gfar_irq(&priv->gfargrp[i], TX)->irq,
+ 				 &priv->gfargrp[i]);
+ 	}
+ }
+ 
+ static int gfar_request_irq(struct gfar_private *priv)
+ {
+ 	int err, i, j;
+ 
+ 	for (i = 0; i < priv->num_grps; i++) {
+ 		err = register_grp_irqs(&priv->gfargrp[i]);
+ 		if (err) {
+ 			for (j = 0; j < i; j++)
+ 				free_grp_irqs(&priv->gfargrp[j]);
+ 			return err;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /* Called when something needs to use the ethernet device
+  * Returns 0 for success.
+  */
+ static int gfar_enet_open(struct net_device *dev)
+ {
+ 	struct gfar_private *priv = netdev_priv(dev);
+ 	int err;
+ 
+ 	err = init_phy(dev);
+ 	if (err)
+ 		return err;
+ 
+ 	err = gfar_request_irq(priv);
+ 	if (err)
+ 		return err;
+ 
+ 	err = startup_gfar(dev);
+ 	if (err)
+ 		return err;
+ 
+ 	return err;
+ }
+ 
+ /* Stops the kernel queue, and halts the controller */
+ static int gfar_close(struct net_device *dev)
+ {
+ 	struct gfar_private *priv = netdev_priv(dev);
+ 
+ 	cancel_work_sync(&priv->reset_task);
+ 	stop_gfar(dev);
+ 
+ 	/* Disconnect from the PHY */
+ 	phy_disconnect(dev->phydev);
+ 
+ 	gfar_free_irq(priv);
+ 
+ 	return 0;
+ }
+ 
+ /* Clears each of the exact match registers to zero, so they
+  * don't interfere with normal reception
+  */
+ static void gfar_clear_exact_match(struct net_device *dev)
+ {
+ 	int idx;
+ 	static const u8 zero_arr[ETH_ALEN] = {0, 0, 0, 0, 0, 0};
+ 
+ 	for (idx = 1; idx < GFAR_EM_NUM + 1; idx++)
+ 		gfar_set_mac_for_addr(dev, idx, zero_arr);
+ }
+ 
+ /* Update the hash table based on the current list of multicast
+  * addresses we subscribe to.  Also, change the promiscuity of
+  * the device based on the flags (this function is called
+  * whenever dev->flags is changed
+  */
+ static void gfar_set_multi(struct net_device *dev)
+ {
+ 	struct netdev_hw_addr *ha;
+ 	struct gfar_private *priv = netdev_priv(dev);
+ 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+ 	u32 tempval;
+ 
+ 	if (dev->flags & IFF_PROMISC) {
+ 		/* Set RCTRL to PROM */
+ 		tempval = gfar_read(&regs->rctrl);
+ 		tempval |= RCTRL_PROM;
+ 		gfar_write(&regs->rctrl, tempval);
+ 	} else {
+ 		/* Set RCTRL to not PROM */
+ 		tempval = gfar_read(&regs->rctrl);
+ 		tempval &= ~(RCTRL_PROM);
+ 		gfar_write(&regs->rctrl, tempval);
+ 	}
+ 
+ 	if (dev->flags & IFF_ALLMULTI) {
+ 		/* Set the hash to rx all multicast frames */
+ 		gfar_write(&regs->igaddr0, 0xffffffff);
+ 		gfar_write(&regs->igaddr1, 0xffffffff);
+ 		gfar_write(&regs->igaddr2, 0xffffffff);
+ 		gfar_write(&regs->igaddr3, 0xffffffff);
+ 		gfar_write(&regs->igaddr4, 0xffffffff);
+ 		gfar_write(&regs->igaddr5, 0xffffffff);
+ 		gfar_write(&regs->igaddr6, 0xffffffff);
+ 		gfar_write(&regs->igaddr7, 0xffffffff);
+ 		gfar_write(&regs->gaddr0, 0xffffffff);
+ 		gfar_write(&regs->gaddr1, 0xffffffff);
+ 		gfar_write(&regs->gaddr2, 0xffffffff);
+ 		gfar_write(&regs->gaddr3, 0xffffffff);
+ 		gfar_write(&regs->gaddr4, 0xffffffff);
+ 		gfar_write(&regs->gaddr5, 0xffffffff);
+ 		gfar_write(&regs->gaddr6, 0xffffffff);
+ 		gfar_write(&regs->gaddr7, 0xffffffff);
+ 	} else {
+ 		int em_num;
+ 		int idx;
+ 
+ 		/* zero out the hash */
+ 		gfar_write(&regs->igaddr0, 0x0);
+ 		gfar_write(&regs->igaddr1, 0x0);
+ 		gfar_write(&regs->igaddr2, 0x0);
+ 		gfar_write(&regs->igaddr3, 0x0);
+ 		gfar_write(&regs->igaddr4, 0x0);
+ 		gfar_write(&regs->igaddr5, 0x0);
+ 		gfar_write(&regs->igaddr6, 0x0);
+ 		gfar_write(&regs->igaddr7, 0x0);
+ 		gfar_write(&regs->gaddr0, 0x0);
+ 		gfar_write(&regs->gaddr1, 0x0);
+ 		gfar_write(&regs->gaddr2, 0x0);
+ 		gfar_write(&regs->gaddr3, 0x0);
+ 		gfar_write(&regs->gaddr4, 0x0);
+ 		gfar_write(&regs->gaddr5, 0x0);
+ 		gfar_write(&regs->gaddr6, 0x0);
+ 		gfar_write(&regs->gaddr7, 0x0);
+ 
+ 		/* If we have extended hash tables, we need to
+ 		 * clear the exact match registers to prepare for
+ 		 * setting them
+ 		 */
+ 		if (priv->extended_hash) {
+ 			em_num = GFAR_EM_NUM + 1;
+ 			gfar_clear_exact_match(dev);
+ 			idx = 1;
+ 		} else {
+ 			idx = 0;
+ 			em_num = 0;
+ 		}
+ 
+ 		if (netdev_mc_empty(dev))
+ 			return;
+ 
+ 		/* Parse the list, and set the appropriate bits */
+ 		netdev_for_each_mc_addr(ha, dev) {
+ 			if (idx < em_num) {
+ 				gfar_set_mac_for_addr(dev, idx, ha->addr);
+ 				idx++;
+ 			} else
+ 				gfar_set_hash_for_addr(dev, ha->addr);
+ 		}
+ 	}
+ }
+ 
++>>>>>>> 0290bd291cc0 (netdev: pass the stuck queue to the timeout handler)
  void gfar_mac_reset(struct gfar_private *priv)
  {
  	struct gfar __iomem *regs = priv->gfargrp[0].regs;
diff --cc drivers/net/ethernet/hisilicon/hns/hns_enet.c
index 1ef259ec565f,e45553ec114a..000000000000
--- a/drivers/net/ethernet/hisilicon/hns/hns_enet.c
+++ b/drivers/net/ethernet/hisilicon/hns/hns_enet.c
@@@ -1503,7 -1484,8 +1503,12 @@@ static int hns_nic_net_stop(struct net_
  }
  
  static void hns_tx_timeout_reset(struct hns_nic_priv *priv);
++<<<<<<< HEAD
 +static void hns_nic_net_timeout(struct net_device *ndev)
++=======
+ #define HNS_TX_TIMEO_LIMIT (40 * HZ)
+ static void hns_nic_net_timeout(struct net_device *ndev, unsigned int txqueue)
++>>>>>>> 0290bd291cc0 (netdev: pass the stuck queue to the timeout handler)
  {
  	struct hns_nic_priv *priv = netdev_priv(ndev);
  
diff --cc drivers/net/ethernet/sgi/ioc3-eth.c
index 18d533fdf14c,06637b03deed..000000000000
--- a/drivers/net/ethernet/sgi/ioc3-eth.c
+++ b/drivers/net/ethernet/sgi/ioc3-eth.c
@@@ -99,11 -113,15 +99,16 @@@ struct ioc3_private 
  
  static int ioc3_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
  static void ioc3_set_multicast_list(struct net_device *dev);
++<<<<<<< HEAD
 +static int ioc3_start_xmit(struct sk_buff *skb, struct net_device *dev);
 +static void ioc3_timeout(struct net_device *dev);
++=======
+ static netdev_tx_t ioc3_start_xmit(struct sk_buff *skb, struct net_device *dev);
+ static void ioc3_timeout(struct net_device *dev, unsigned int txqueue);
++>>>>>>> 0290bd291cc0 (netdev: pass the stuck queue to the timeout handler)
  static inline unsigned int ioc3_hash(const unsigned char *addr);
 -static void ioc3_start(struct ioc3_private *ip);
  static inline void ioc3_stop(struct ioc3_private *ip);
  static void ioc3_init(struct net_device *dev);
 -static int ioc3_alloc_rx_bufs(struct net_device *dev);
 -static void ioc3_free_rx_bufs(struct ioc3_private *ip);
 -static inline void ioc3_clean_tx_ring(struct ioc3_private *ip);
  
  static const char ioc3_str[] = "IOC3 Ethernet";
  static const struct ethtool_ops ioc3_ethtool_ops;
diff --cc drivers/net/ethernet/sun/sunvnet_common.h
index 1ea0b016580a,5416a3cb9e7d..000000000000
--- a/drivers/net/ethernet/sun/sunvnet_common.h
+++ b/drivers/net/ethernet/sun/sunvnet_common.h
@@@ -135,10 -135,11 +135,18 @@@ int sunvnet_open_common(struct net_devi
  int sunvnet_close_common(struct net_device *dev);
  void sunvnet_set_rx_mode_common(struct net_device *dev, struct vnet *vp);
  int sunvnet_set_mac_addr_common(struct net_device *dev, void *p);
++<<<<<<< HEAD
 +void sunvnet_tx_timeout_common(struct net_device *dev);
 +int sunvnet_start_xmit_common(struct sk_buff *skb, struct net_device *dev,
 +			   struct vnet_port *(*vnet_tx_port)
 +			   (struct sk_buff *, struct net_device *));
++=======
+ void sunvnet_tx_timeout_common(struct net_device *dev, unsigned int txqueue);
+ netdev_tx_t
+ sunvnet_start_xmit_common(struct sk_buff *skb, struct net_device *dev,
+ 			  struct vnet_port *(*vnet_tx_port)
+ 			  (struct sk_buff *, struct net_device *));
++>>>>>>> 0290bd291cc0 (netdev: pass the stuck queue to the timeout handler)
  #ifdef CONFIG_NET_POLL_CONTROLLER
  void sunvnet_poll_controller_common(struct net_device *dev, struct vnet *vp);
  #endif
diff --cc drivers/net/wan/fsl_ucc_hdlc.c
index 9b09c9d0d0fb,308384756e6f..000000000000
--- a/drivers/net/wan/fsl_ucc_hdlc.c
+++ b/drivers/net/wan/fsl_ucc_hdlc.c
@@@ -987,6 -1039,11 +987,14 @@@ static const struct dev_pm_ops uhdlc_pm
  #define HDLC_PM_OPS NULL
  
  #endif
++<<<<<<< HEAD
++=======
+ static void uhdlc_tx_timeout(struct net_device *ndev, unsigned int txqueue)
+ {
+ 	netdev_err(ndev, "%s\n", __func__);
+ }
+ 
++>>>>>>> 0290bd291cc0 (netdev: pass the stuck queue to the timeout handler)
  static const struct net_device_ops uhdlc_ops = {
  	.ndo_open       = uhdlc_open,
  	.ndo_stop       = uhdlc_close,
* Unmerged path drivers/net/ethernet/atheros/ag71xx.c
* Unmerged path drivers/net/ethernet/pensando/ionic/ionic_lif.c
* Unmerged path drivers/net/ethernet/ti/cpsw_priv.c
* Unmerged path drivers/net/ethernet/ti/cpsw_priv.h
diff --git a/arch/m68k/emu/nfeth.c b/arch/m68k/emu/nfeth.c
index e45ce4243aaa..54612c3c8023 100644
--- a/arch/m68k/emu/nfeth.c
+++ b/arch/m68k/emu/nfeth.c
@@ -171,7 +171,7 @@ static int nfeth_xmit(struct sk_buff *skb, struct net_device *dev)
 	return 0;
 }
 
-static void nfeth_tx_timeout(struct net_device *dev)
+static void nfeth_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	dev->stats.tx_errors++;
 	netif_wake_queue(dev);
diff --git a/arch/um/drivers/net_kern.c b/arch/um/drivers/net_kern.c
index 3ef1b48e064a..5c0c3e17354a 100644
--- a/arch/um/drivers/net_kern.c
+++ b/arch/um/drivers/net_kern.c
@@ -249,7 +249,7 @@ static void uml_net_set_multicast_list(struct net_device *dev)
 	return;
 }
 
-static void uml_net_tx_timeout(struct net_device *dev)
+static void uml_net_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	netif_trans_update(dev);
 	netif_wake_queue(dev);
diff --git a/arch/um/drivers/vector_kern.c b/arch/um/drivers/vector_kern.c
index d516cb6e1dd2..c4c6e12ec05c 100644
--- a/arch/um/drivers/vector_kern.c
+++ b/arch/um/drivers/vector_kern.c
@@ -1274,7 +1274,7 @@ static void vector_net_set_multicast_list(struct net_device *dev)
 	return;
 }
 
-static void vector_net_tx_timeout(struct net_device *dev)
+static void vector_net_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct vector_private *vp = netdev_priv(dev);
 
diff --git a/arch/xtensa/platforms/iss/network.c b/arch/xtensa/platforms/iss/network.c
index d027dddc41ca..4a2f0a36175d 100644
--- a/arch/xtensa/platforms/iss/network.c
+++ b/arch/xtensa/platforms/iss/network.c
@@ -460,7 +460,7 @@ static void iss_net_set_multicast_list(struct net_device *dev)
 {
 }
 
-static void iss_net_tx_timeout(struct net_device *dev)
+static void iss_net_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 }
 
diff --git a/drivers/char/pcmcia/synclink_cs.c b/drivers/char/pcmcia/synclink_cs.c
index 66b04194aa9f..138cccd9ab36 100644
--- a/drivers/char/pcmcia/synclink_cs.c
+++ b/drivers/char/pcmcia/synclink_cs.c
@@ -4170,7 +4170,7 @@ static int hdlcdev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
  *
  * dev  pointer to network device structure
  */
-static void hdlcdev_tx_timeout(struct net_device *dev)
+static void hdlcdev_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	MGSLPC_INFO *info = dev_to_port(dev);
 	unsigned long flags;
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c
index e5f438ab716c..4a0d3a9e72e1 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -1182,7 +1182,7 @@ static netdev_tx_t ipoib_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	return NETDEV_TX_OK;
 }
 
-static void ipoib_timeout(struct net_device *dev)
+static void ipoib_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct ipoib_dev_priv *priv = ipoib_priv(dev);
 
diff --git a/drivers/message/fusion/mptlan.c b/drivers/message/fusion/mptlan.c
index ebc00d47abf5..7d3784aa20e5 100644
--- a/drivers/message/fusion/mptlan.c
+++ b/drivers/message/fusion/mptlan.c
@@ -552,7 +552,7 @@ mpt_lan_close(struct net_device *dev)
 /*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
 /* Tx timeout handler. */
 static void
-mpt_lan_tx_timeout(struct net_device *dev)
+mpt_lan_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct mpt_lan_priv *priv = netdev_priv(dev);
 	MPT_ADAPTER *mpt_dev = priv->mpt_dev;
diff --git a/drivers/misc/sgi-xp/xpnet.c b/drivers/misc/sgi-xp/xpnet.c
index 44d750d98bc8..92ed2f2f133d 100644
--- a/drivers/misc/sgi-xp/xpnet.c
+++ b/drivers/misc/sgi-xp/xpnet.c
@@ -496,7 +496,7 @@ xpnet_dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
  * Deal with transmit timeouts coming from the network layer.
  */
 static void
-xpnet_dev_tx_timeout(struct net_device *dev)
+xpnet_dev_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	dev->stats.tx_errors++;
 }
diff --git a/drivers/net/appletalk/cops.c b/drivers/net/appletalk/cops.c
index bb49f6e40a19..3b90c44c6f49 100644
--- a/drivers/net/appletalk/cops.c
+++ b/drivers/net/appletalk/cops.c
@@ -189,7 +189,7 @@ static int  cops_nodeid (struct net_device *dev, int nodeid);
 
 static irqreturn_t cops_interrupt (int irq, void *dev_id);
 static void cops_poll(struct timer_list *t);
-static void cops_timeout(struct net_device *dev);
+static void cops_timeout(struct net_device *dev, unsigned int txqueue);
 static void cops_rx (struct net_device *dev);
 static netdev_tx_t  cops_send_packet (struct sk_buff *skb,
 					    struct net_device *dev);
@@ -847,7 +847,7 @@ static void cops_rx(struct net_device *dev)
         netif_rx(skb);
 }
 
-static void cops_timeout(struct net_device *dev)
+static void cops_timeout(struct net_device *dev, unsigned int txqueue)
 {
         struct cops_local *lp = netdev_priv(dev);
         int ioaddr = dev->base_addr;
diff --git a/drivers/net/arcnet/arcdevice.h b/drivers/net/arcnet/arcdevice.h
index d09b2b46ab63..61cb3a38f097 100644
--- a/drivers/net/arcnet/arcdevice.h
+++ b/drivers/net/arcnet/arcdevice.h
@@ -361,7 +361,7 @@ int arcnet_open(struct net_device *dev);
 int arcnet_close(struct net_device *dev);
 netdev_tx_t arcnet_send_packet(struct sk_buff *skb,
 			       struct net_device *dev);
-void arcnet_timeout(struct net_device *dev);
+void arcnet_timeout(struct net_device *dev, unsigned int txqueue);
 
 /* I/O equivalents */
 
diff --git a/drivers/net/arcnet/arcnet.c b/drivers/net/arcnet/arcnet.c
index 8459115d9d4e..3c853f01e049 100644
--- a/drivers/net/arcnet/arcnet.c
+++ b/drivers/net/arcnet/arcnet.c
@@ -763,7 +763,7 @@ static int go_tx(struct net_device *dev)
 }
 
 /* Called by the kernel when transmit times out */
-void arcnet_timeout(struct net_device *dev)
+void arcnet_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	unsigned long flags;
 	struct arcnet_local *lp = netdev_priv(dev);
diff --git a/drivers/net/ethernet/3com/3c509.c b/drivers/net/ethernet/3com/3c509.c
index b223769d6a5e..2563e54fc58d 100644
--- a/drivers/net/ethernet/3com/3c509.c
+++ b/drivers/net/ethernet/3com/3c509.c
@@ -196,7 +196,7 @@ static struct net_device_stats *el3_get_stats(struct net_device *dev);
 static int el3_rx(struct net_device *dev);
 static int el3_close(struct net_device *dev);
 static void set_multicast_list(struct net_device *dev);
-static void el3_tx_timeout (struct net_device *dev);
+static void el3_tx_timeout (struct net_device *dev, unsigned int txqueue);
 static void el3_down(struct net_device *dev);
 static void el3_up(struct net_device *dev);
 static const struct ethtool_ops ethtool_ops;
@@ -689,7 +689,7 @@ el3_open(struct net_device *dev)
 }
 
 static void
-el3_tx_timeout (struct net_device *dev)
+el3_tx_timeout (struct net_device *dev, unsigned int txqueue)
 {
 	int ioaddr = dev->base_addr;
 
diff --git a/drivers/net/ethernet/3com/3c515.c b/drivers/net/ethernet/3com/3c515.c
index b648e3f95c01..2653631810b3 100644
--- a/drivers/net/ethernet/3com/3c515.c
+++ b/drivers/net/ethernet/3com/3c515.c
@@ -371,7 +371,7 @@ static void corkscrew_timer(struct timer_list *t);
 static netdev_tx_t corkscrew_start_xmit(struct sk_buff *skb,
 					struct net_device *dev);
 static int corkscrew_rx(struct net_device *dev);
-static void corkscrew_timeout(struct net_device *dev);
+static void corkscrew_timeout(struct net_device *dev, unsigned int txqueue);
 static int boomerang_rx(struct net_device *dev);
 static irqreturn_t corkscrew_interrupt(int irq, void *dev_id);
 static int corkscrew_close(struct net_device *dev);
@@ -961,7 +961,7 @@ static void corkscrew_timer(struct timer_list *t)
 #endif				/* AUTOMEDIA */
 }
 
-static void corkscrew_timeout(struct net_device *dev)
+static void corkscrew_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	int i;
 	struct corkscrew_private *vp = netdev_priv(dev);
diff --git a/drivers/net/ethernet/3com/3c574_cs.c b/drivers/net/ethernet/3com/3c574_cs.c
index 3044a6f35f04..ef1c3151fbb2 100644
--- a/drivers/net/ethernet/3com/3c574_cs.c
+++ b/drivers/net/ethernet/3com/3c574_cs.c
@@ -234,7 +234,7 @@ static void update_stats(struct net_device *dev);
 static struct net_device_stats *el3_get_stats(struct net_device *dev);
 static int el3_rx(struct net_device *dev, int worklimit);
 static int el3_close(struct net_device *dev);
-static void el3_tx_timeout(struct net_device *dev);
+static void el3_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static int el3_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 static void set_rx_mode(struct net_device *dev);
 static void set_multicast_list(struct net_device *dev);
@@ -690,7 +690,7 @@ static int el3_open(struct net_device *dev)
 	return 0;
 }
 
-static void el3_tx_timeout(struct net_device *dev)
+static void el3_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	unsigned int ioaddr = dev->base_addr;
 	
diff --git a/drivers/net/ethernet/3com/3c589_cs.c b/drivers/net/ethernet/3com/3c589_cs.c
index 2b2695311bda..d47cde6c5f08 100644
--- a/drivers/net/ethernet/3com/3c589_cs.c
+++ b/drivers/net/ethernet/3com/3c589_cs.c
@@ -173,7 +173,7 @@ static void update_stats(struct net_device *dev);
 static struct net_device_stats *el3_get_stats(struct net_device *dev);
 static int el3_rx(struct net_device *dev);
 static int el3_close(struct net_device *dev);
-static void el3_tx_timeout(struct net_device *dev);
+static void el3_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void set_rx_mode(struct net_device *dev);
 static void set_multicast_list(struct net_device *dev);
 static const struct ethtool_ops netdev_ethtool_ops;
@@ -526,7 +526,7 @@ static int el3_open(struct net_device *dev)
 	return 0;
 }
 
-static void el3_tx_timeout(struct net_device *dev)
+static void el3_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	unsigned int ioaddr = dev->base_addr;
 
diff --git a/drivers/net/ethernet/3com/3c59x.c b/drivers/net/ethernet/3com/3c59x.c
index 5bc168314ea2..9e8b5261c99d 100644
--- a/drivers/net/ethernet/3com/3c59x.c
+++ b/drivers/net/ethernet/3com/3c59x.c
@@ -776,7 +776,7 @@ static void set_rx_mode(struct net_device *dev);
 #ifdef CONFIG_PCI
 static int vortex_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 #endif
-static void vortex_tx_timeout(struct net_device *dev);
+static void vortex_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void acpi_set_WOL(struct net_device *dev);
 static const struct ethtool_ops vortex_ethtool_ops;
 static void set_8021q_mode(struct net_device *dev, int enable);
@@ -1879,7 +1879,7 @@ vortex_timer(struct timer_list *t)
 		iowrite16(FakeIntr, ioaddr + EL3_CMD);
 }
 
-static void vortex_tx_timeout(struct net_device *dev)
+static void vortex_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct vortex_private *vp = netdev_priv(dev);
 	void __iomem *ioaddr = vp->ioaddr;
diff --git a/drivers/net/ethernet/3com/typhoon.c b/drivers/net/ethernet/3com/typhoon.c
index be823c186517..14fce6658106 100644
--- a/drivers/net/ethernet/3com/typhoon.c
+++ b/drivers/net/ethernet/3com/typhoon.c
@@ -2013,7 +2013,7 @@ typhoon_stop_runtime(struct typhoon *tp, int wait_type)
 }
 
 static void
-typhoon_tx_timeout(struct net_device *dev)
+typhoon_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct typhoon *tp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/8390/8390.c b/drivers/net/ethernet/8390/8390.c
index a43544af257b..9c033a372cd3 100644
--- a/drivers/net/ethernet/8390/8390.c
+++ b/drivers/net/ethernet/8390/8390.c
@@ -35,9 +35,9 @@ void ei_set_multicast_list(struct net_device *dev)
 }
 EXPORT_SYMBOL(ei_set_multicast_list);
 
-void ei_tx_timeout(struct net_device *dev)
+void ei_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
-	__ei_tx_timeout(dev);
+	__ei_tx_timeout(dev, txqueue);
 }
 EXPORT_SYMBOL(ei_tx_timeout);
 
diff --git a/drivers/net/ethernet/8390/8390.h b/drivers/net/ethernet/8390/8390.h
index 3e2f2c2e7b58..529c728f334a 100644
--- a/drivers/net/ethernet/8390/8390.h
+++ b/drivers/net/ethernet/8390/8390.h
@@ -32,7 +32,7 @@ void NS8390_init(struct net_device *dev, int startp);
 int ei_open(struct net_device *dev);
 int ei_close(struct net_device *dev);
 irqreturn_t ei_interrupt(int irq, void *dev_id);
-void ei_tx_timeout(struct net_device *dev);
+void ei_tx_timeout(struct net_device *dev, unsigned int txqueue);
 netdev_tx_t ei_start_xmit(struct sk_buff *skb, struct net_device *dev);
 void ei_set_multicast_list(struct net_device *dev);
 struct net_device_stats *ei_get_stats(struct net_device *dev);
@@ -50,7 +50,7 @@ void NS8390p_init(struct net_device *dev, int startp);
 int eip_open(struct net_device *dev);
 int eip_close(struct net_device *dev);
 irqreturn_t eip_interrupt(int irq, void *dev_id);
-void eip_tx_timeout(struct net_device *dev);
+void eip_tx_timeout(struct net_device *dev, unsigned int txqueue);
 netdev_tx_t eip_start_xmit(struct sk_buff *skb, struct net_device *dev);
 void eip_set_multicast_list(struct net_device *dev);
 struct net_device_stats *eip_get_stats(struct net_device *dev);
diff --git a/drivers/net/ethernet/8390/8390p.c b/drivers/net/ethernet/8390/8390p.c
index 46d2257c4430..3a3f86691bb6 100644
--- a/drivers/net/ethernet/8390/8390p.c
+++ b/drivers/net/ethernet/8390/8390p.c
@@ -40,9 +40,9 @@ void eip_set_multicast_list(struct net_device *dev)
 }
 EXPORT_SYMBOL(eip_set_multicast_list);
 
-void eip_tx_timeout(struct net_device *dev)
+void eip_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
-	__ei_tx_timeout(dev);
+	__ei_tx_timeout(dev, txqueue);
 }
 EXPORT_SYMBOL(eip_tx_timeout);
 
diff --git a/drivers/net/ethernet/8390/axnet_cs.c b/drivers/net/ethernet/8390/axnet_cs.c
index d422a124cd7c..080a5eb42291 100644
--- a/drivers/net/ethernet/8390/axnet_cs.c
+++ b/drivers/net/ethernet/8390/axnet_cs.c
@@ -83,7 +83,7 @@ static netdev_tx_t axnet_start_xmit(struct sk_buff *skb,
 					  struct net_device *dev);
 static struct net_device_stats *get_stats(struct net_device *dev);
 static void set_multicast_list(struct net_device *dev);
-static void axnet_tx_timeout(struct net_device *dev);
+static void axnet_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static irqreturn_t ei_irq_wrapper(int irq, void *dev_id);
 static void ei_watchdog(struct timer_list *t);
 static void axnet_reset_8390(struct net_device *dev);
@@ -902,7 +902,7 @@ static int ax_close(struct net_device *dev)
  * completed (or failed) - i.e. never posted a Tx related interrupt.
  */
 
-static void axnet_tx_timeout(struct net_device *dev)
+static void axnet_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	long e8390_base = dev->base_addr;
 	struct ei_device *ei_local = netdev_priv(dev);
diff --git a/drivers/net/ethernet/8390/lib8390.c b/drivers/net/ethernet/8390/lib8390.c
index c9c55c9eab9f..babc92e2692e 100644
--- a/drivers/net/ethernet/8390/lib8390.c
+++ b/drivers/net/ethernet/8390/lib8390.c
@@ -251,7 +251,7 @@ static int __ei_close(struct net_device *dev)
  * completed (or failed) - i.e. never posted a Tx related interrupt.
  */
 
-static void __ei_tx_timeout(struct net_device *dev)
+static void __ei_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	unsigned long e8390_base = dev->base_addr;
 	struct ei_device *ei_local = netdev_priv(dev);
diff --git a/drivers/net/ethernet/adaptec/starfire.c b/drivers/net/ethernet/adaptec/starfire.c
index 3872ab96b80a..265400c7061b 100644
--- a/drivers/net/ethernet/adaptec/starfire.c
+++ b/drivers/net/ethernet/adaptec/starfire.c
@@ -576,7 +576,7 @@ static int	mdio_read(struct net_device *dev, int phy_id, int location);
 static void	mdio_write(struct net_device *dev, int phy_id, int location, int value);
 static int	netdev_open(struct net_device *dev);
 static void	check_duplex(struct net_device *dev);
-static void	tx_timeout(struct net_device *dev);
+static void	tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void	init_ring(struct net_device *dev);
 static netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev);
 static irqreturn_t intr_handler(int irq, void *dev_instance);
@@ -1105,7 +1105,7 @@ static void check_duplex(struct net_device *dev)
 }
 
 
-static void tx_timeout(struct net_device *dev)
+static void tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct netdev_private *np = netdev_priv(dev);
 	void __iomem *ioaddr = np->base;
diff --git a/drivers/net/ethernet/agere/et131x.c b/drivers/net/ethernet/agere/et131x.c
index ea34bcb868b5..5dd5d1e3449f 100644
--- a/drivers/net/ethernet/agere/et131x.c
+++ b/drivers/net/ethernet/agere/et131x.c
@@ -3811,7 +3811,7 @@ static netdev_tx_t et131x_tx(struct sk_buff *skb, struct net_device *netdev)
  * specified by the 'tx_timeo" element in the net_device structure (see
  * et131x_alloc_device() to see how this value is set).
  */
-static void et131x_tx_timeout(struct net_device *netdev)
+static void et131x_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct et131x_adapter *adapter = netdev_priv(netdev);
 	struct tx_ring *tx_ring = &adapter->tx_ring;
diff --git a/drivers/net/ethernet/allwinner/sun4i-emac.c b/drivers/net/ethernet/allwinner/sun4i-emac.c
index e1acafa82214..7b54c4472fb3 100644
--- a/drivers/net/ethernet/allwinner/sun4i-emac.c
+++ b/drivers/net/ethernet/allwinner/sun4i-emac.c
@@ -407,7 +407,7 @@ static void emac_init_device(struct net_device *dev)
 }
 
 /* Our watchdog timed out. Called by the networking layer */
-static void emac_timeout(struct net_device *dev)
+static void emac_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct emac_board_info *db = netdev_priv(dev);
 	unsigned long flags;
diff --git a/drivers/net/ethernet/alteon/acenic.c b/drivers/net/ethernet/alteon/acenic.c
index 8f71b79b4949..30e03970eb4f 100644
--- a/drivers/net/ethernet/alteon/acenic.c
+++ b/drivers/net/ethernet/alteon/acenic.c
@@ -441,7 +441,7 @@ static const struct ethtool_ops ace_ethtool_ops = {
 	.set_link_ksettings = ace_set_link_ksettings,
 };
 
-static void ace_watchdog(struct net_device *dev);
+static void ace_watchdog(struct net_device *dev, unsigned int txqueue);
 
 static const struct net_device_ops ace_netdev_ops = {
 	.ndo_open		= ace_open,
@@ -1545,7 +1545,7 @@ static void ace_set_rxtx_parms(struct net_device *dev, int jumbo)
 }
 
 
-static void ace_watchdog(struct net_device *data)
+static void ace_watchdog(struct net_device *data, unsigned int txqueue)
 {
 	struct net_device *dev = data;
 	struct ace_private *ap = netdev_priv(dev);
* Unmerged path drivers/net/ethernet/amazon/ena/ena_netdev.c
diff --git a/drivers/net/ethernet/amd/7990.c b/drivers/net/ethernet/amd/7990.c
index dc57f2759f44..7462d5515fed 100644
--- a/drivers/net/ethernet/amd/7990.c
+++ b/drivers/net/ethernet/amd/7990.c
@@ -526,7 +526,7 @@ int lance_close(struct net_device *dev)
 }
 EXPORT_SYMBOL_GPL(lance_close);
 
-void lance_tx_timeout(struct net_device *dev)
+void lance_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	printk("lance_tx_timeout\n");
 	lance_reset(dev);
diff --git a/drivers/net/ethernet/amd/7990.h b/drivers/net/ethernet/amd/7990.h
index 741cdc392c6b..8266b3c1fefc 100644
--- a/drivers/net/ethernet/amd/7990.h
+++ b/drivers/net/ethernet/amd/7990.h
@@ -243,7 +243,7 @@ int lance_open(struct net_device *dev);
 int lance_close(struct net_device *dev);
 int lance_start_xmit(struct sk_buff *skb, struct net_device *dev);
 void lance_set_multicast(struct net_device *dev);
-void lance_tx_timeout(struct net_device *dev);
+void lance_tx_timeout(struct net_device *dev, unsigned int txqueue);
 #ifdef CONFIG_NET_POLL_CONTROLLER
 void lance_poll(struct net_device *dev);
 #endif
diff --git a/drivers/net/ethernet/amd/a2065.c b/drivers/net/ethernet/amd/a2065.c
index 212fe72a190b..a3faf4feb204 100644
--- a/drivers/net/ethernet/amd/a2065.c
+++ b/drivers/net/ethernet/amd/a2065.c
@@ -522,7 +522,7 @@ static inline int lance_reset(struct net_device *dev)
 	return status;
 }
 
-static void lance_tx_timeout(struct net_device *dev)
+static void lance_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct lance_private *lp = netdev_priv(dev);
 	volatile struct lance_regs *ll = lp->ll;
diff --git a/drivers/net/ethernet/amd/am79c961a.c b/drivers/net/ethernet/amd/am79c961a.c
index 01d132c02ff9..6cec55285490 100644
--- a/drivers/net/ethernet/amd/am79c961a.c
+++ b/drivers/net/ethernet/amd/am79c961a.c
@@ -425,7 +425,7 @@ static void am79c961_setmulticastlist (struct net_device *dev)
 	spin_unlock_irqrestore(&priv->chip_lock, flags);
 }
 
-static void am79c961_timeout(struct net_device *dev)
+static void am79c961_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	printk(KERN_WARNING "%s: transmit timed out, network cable problem?\n",
 		dev->name);
diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index a90080f12e67..28a8629efeed 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1582,7 +1582,7 @@ static int amd8111e_enable_link_change(struct amd8111e_priv *lp)
  * failed or the interface is locked up. This function will reinitialize
  * the hardware.
  */
-static void amd8111e_tx_timeout(struct net_device *dev)
+static void amd8111e_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct amd8111e_priv *lp = netdev_priv(dev);
 	int err;
diff --git a/drivers/net/ethernet/amd/ariadne.c b/drivers/net/ethernet/amd/ariadne.c
index 4b6a5cb85dd2..5e0f645f5bde 100644
--- a/drivers/net/ethernet/amd/ariadne.c
+++ b/drivers/net/ethernet/amd/ariadne.c
@@ -530,7 +530,7 @@ static inline void ariadne_reset(struct net_device *dev)
 	netif_start_queue(dev);
 }
 
-static void ariadne_tx_timeout(struct net_device *dev)
+static void ariadne_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	volatile struct Am79C960 *lance = (struct Am79C960 *)dev->base_addr;
 
diff --git a/drivers/net/ethernet/amd/atarilance.c b/drivers/net/ethernet/amd/atarilance.c
index c5b81268c284..0ac2e0c7d280 100644
--- a/drivers/net/ethernet/amd/atarilance.c
+++ b/drivers/net/ethernet/amd/atarilance.c
@@ -345,7 +345,7 @@ static int lance_rx( struct net_device *dev );
 static int lance_close( struct net_device *dev );
 static void set_multicast_list( struct net_device *dev );
 static int lance_set_mac_address( struct net_device *dev, void *addr );
-static void lance_tx_timeout (struct net_device *dev);
+static void lance_tx_timeout (struct net_device *dev, unsigned int txqueue);
 
 /************************* End of Prototypes **************************/
 
@@ -726,7 +726,7 @@ static void lance_init_ring( struct net_device *dev )
 /* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */
 
 
-static void lance_tx_timeout (struct net_device *dev)
+static void lance_tx_timeout (struct net_device *dev, unsigned int txqueue)
 {
 	struct lance_private *lp = netdev_priv(dev);
 	struct lance_ioreg	 *IO = lp->iobase;
diff --git a/drivers/net/ethernet/amd/au1000_eth.c b/drivers/net/ethernet/amd/au1000_eth.c
index 7c1eb304c27e..eabdf8eeeb9e 100644
--- a/drivers/net/ethernet/amd/au1000_eth.c
+++ b/drivers/net/ethernet/amd/au1000_eth.c
@@ -1034,7 +1034,7 @@ static netdev_tx_t au1000_tx(struct sk_buff *skb, struct net_device *dev)
  * The Tx ring has been full longer than the watchdog timeout
  * value. The transmitter must be hung?
  */
-static void au1000_tx_timeout(struct net_device *dev)
+static void au1000_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	netdev_err(dev, "au1000_tx_timeout: dev=%p\n", dev);
 	au1000_reset_mac(dev);
diff --git a/drivers/net/ethernet/amd/declance.c b/drivers/net/ethernet/amd/declance.c
index 116997a8b593..89c3c10f0c11 100644
--- a/drivers/net/ethernet/amd/declance.c
+++ b/drivers/net/ethernet/amd/declance.c
@@ -883,7 +883,7 @@ static inline int lance_reset(struct net_device *dev)
 	return status;
 }
 
-static void lance_tx_timeout(struct net_device *dev)
+static void lance_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct lance_private *lp = netdev_priv(dev);
 	volatile struct lance_regs *ll = lp->ll;
diff --git a/drivers/net/ethernet/amd/lance.c b/drivers/net/ethernet/amd/lance.c
index b56d84c7df46..68802969f1bb 100644
--- a/drivers/net/ethernet/amd/lance.c
+++ b/drivers/net/ethernet/amd/lance.c
@@ -306,7 +306,7 @@ static irqreturn_t lance_interrupt(int irq, void *dev_id);
 static int lance_close(struct net_device *dev);
 static struct net_device_stats *lance_get_stats(struct net_device *dev);
 static void set_multicast_list(struct net_device *dev);
-static void lance_tx_timeout (struct net_device *dev);
+static void lance_tx_timeout (struct net_device *dev, unsigned int txqueue);
 
 
 
@@ -913,7 +913,7 @@ lance_restart(struct net_device *dev, unsigned int csr0_bits, int must_reinit)
 }
 
 
-static void lance_tx_timeout (struct net_device *dev)
+static void lance_tx_timeout (struct net_device *dev, unsigned int txqueue)
 {
 	struct lance_private *lp = (struct lance_private *) dev->ml_priv;
 	int ioaddr = dev->base_addr;
diff --git a/drivers/net/ethernet/amd/ni65.c b/drivers/net/ethernet/amd/ni65.c
index e248d1ab3e47..5131b6a9056c 100644
--- a/drivers/net/ethernet/amd/ni65.c
+++ b/drivers/net/ethernet/amd/ni65.c
@@ -254,7 +254,7 @@ static int  ni65_lance_reinit(struct net_device *dev);
 static void ni65_init_lance(struct priv *p,unsigned char*,int,int);
 static netdev_tx_t ni65_send_packet(struct sk_buff *skb,
 				    struct net_device *dev);
-static void  ni65_timeout(struct net_device *dev);
+static void  ni65_timeout(struct net_device *dev, unsigned int txqueue);
 static int  ni65_close(struct net_device *dev);
 static int  ni65_alloc_buffer(struct net_device *dev);
 static void ni65_free_buffer(struct priv *p);
@@ -1137,7 +1137,7 @@ static void ni65_recv_intr(struct net_device *dev,int csr0)
  * kick xmitter ..
  */
 
-static void ni65_timeout(struct net_device *dev)
+static void ni65_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	int i;
 	struct priv *p = dev->ml_priv;
diff --git a/drivers/net/ethernet/amd/nmclan_cs.c b/drivers/net/ethernet/amd/nmclan_cs.c
index 9c152d85840d..023aecf6ab30 100644
--- a/drivers/net/ethernet/amd/nmclan_cs.c
+++ b/drivers/net/ethernet/amd/nmclan_cs.c
@@ -407,7 +407,7 @@ static int mace_open(struct net_device *dev);
 static int mace_close(struct net_device *dev);
 static netdev_tx_t mace_start_xmit(struct sk_buff *skb,
 					 struct net_device *dev);
-static void mace_tx_timeout(struct net_device *dev);
+static void mace_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static irqreturn_t mace_interrupt(int irq, void *dev_id);
 static struct net_device_stats *mace_get_stats(struct net_device *dev);
 static int mace_rx(struct net_device *dev, unsigned char RxCnt);
@@ -837,7 +837,7 @@ mace_start_xmit
 	failed, put skb back into a list."
 ---------------------------------------------------------------------------- */
 
-static void mace_tx_timeout(struct net_device *dev)
+static void mace_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
   mace_private *lp = netdev_priv(dev);
   struct pcmcia_device *link = lp->p_dev;
diff --git a/drivers/net/ethernet/amd/pcnet32.c b/drivers/net/ethernet/amd/pcnet32.c
index be198cc0b10c..ccda526ab99a 100644
--- a/drivers/net/ethernet/amd/pcnet32.c
+++ b/drivers/net/ethernet/amd/pcnet32.c
@@ -314,7 +314,7 @@ static int pcnet32_open(struct net_device *);
 static int pcnet32_init_ring(struct net_device *);
 static netdev_tx_t pcnet32_start_xmit(struct sk_buff *,
 				      struct net_device *);
-static void pcnet32_tx_timeout(struct net_device *dev);
+static void pcnet32_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static irqreturn_t pcnet32_interrupt(int, void *);
 static int pcnet32_close(struct net_device *);
 static struct net_device_stats *pcnet32_get_stats(struct net_device *);
@@ -2455,7 +2455,7 @@ static void pcnet32_restart(struct net_device *dev, unsigned int csr0_bits)
 	lp->a->write_csr(ioaddr, CSR0, csr0_bits);
 }
 
-static void pcnet32_tx_timeout(struct net_device *dev)
+static void pcnet32_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct pcnet32_private *lp = netdev_priv(dev);
 	unsigned long ioaddr = dev->base_addr, flags;
diff --git a/drivers/net/ethernet/amd/sunlance.c b/drivers/net/ethernet/amd/sunlance.c
index cdd7a611479b..f6297146f114 100644
--- a/drivers/net/ethernet/amd/sunlance.c
+++ b/drivers/net/ethernet/amd/sunlance.c
@@ -1096,7 +1096,7 @@ static void lance_piozero(void __iomem *dest, int len)
 		sbus_writeb(0, piobuf);
 }
 
-static void lance_tx_timeout(struct net_device *dev)
+static void lance_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct lance_private *lp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
index 24f1053b8785..724a3a43c70e 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c
@@ -2153,7 +2153,7 @@ static int xgbe_change_mtu(struct net_device *netdev, int mtu)
 	return 0;
 }
 
-static void xgbe_tx_timeout(struct net_device *netdev)
+static void xgbe_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct xgbe_prv_data *pdata = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/apm/xgene-v2/main.c b/drivers/net/ethernet/apm/xgene-v2/main.c
index 0f2ad50f3bd7..44f8d4e82751 100644
--- a/drivers/net/ethernet/apm/xgene-v2/main.c
+++ b/drivers/net/ethernet/apm/xgene-v2/main.c
@@ -589,7 +589,7 @@ static void xge_free_pending_skb(struct net_device *ndev)
 	}
 }
 
-static void xge_timeout(struct net_device *ndev)
+static void xge_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct xge_pdata *pdata = netdev_priv(ndev);
 
diff --git a/drivers/net/ethernet/apm/xgene/xgene_enet_main.c b/drivers/net/ethernet/apm/xgene/xgene_enet_main.c
index 3b889efddf78..c98730df10e8 100644
--- a/drivers/net/ethernet/apm/xgene/xgene_enet_main.c
+++ b/drivers/net/ethernet/apm/xgene/xgene_enet_main.c
@@ -873,7 +873,7 @@ static int xgene_enet_napi(struct napi_struct *napi, const int budget)
 	return processed;
 }
 
-static void xgene_enet_timeout(struct net_device *ndev)
+static void xgene_enet_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct xgene_enet_pdata *pdata = netdev_priv(ndev);
 	struct netdev_queue *txq;
diff --git a/drivers/net/ethernet/apple/macmace.c b/drivers/net/ethernet/apple/macmace.c
index 137cbb470af2..03d1265763e9 100644
--- a/drivers/net/ethernet/apple/macmace.c
+++ b/drivers/net/ethernet/apple/macmace.c
@@ -95,7 +95,7 @@ static int mace_set_address(struct net_device *dev, void *addr);
 static void mace_reset(struct net_device *dev);
 static irqreturn_t mace_interrupt(int irq, void *dev_id);
 static irqreturn_t mace_dma_intr(int irq, void *dev_id);
-static void mace_tx_timeout(struct net_device *dev);
+static void mace_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void __mace_set_address(struct net_device *dev, void *addr);
 
 /*
@@ -604,7 +604,7 @@ static irqreturn_t mace_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static void mace_tx_timeout(struct net_device *dev)
+static void mace_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct mace_data *mp = netdev_priv(dev);
 	volatile struct mace *mb = mp->mace;
* Unmerged path drivers/net/ethernet/atheros/ag71xx.c
diff --git a/drivers/net/ethernet/atheros/alx/main.c b/drivers/net/ethernet/atheros/alx/main.c
index f6db9caa7325..eb662d1742d5 100644
--- a/drivers/net/ethernet/atheros/alx/main.c
+++ b/drivers/net/ethernet/atheros/alx/main.c
@@ -1558,7 +1558,7 @@ static netdev_tx_t alx_start_xmit(struct sk_buff *skb,
 	return alx_start_xmit_ring(skb, alx_tx_queue_mapping(alx, skb));
 }
 
-static void alx_tx_timeout(struct net_device *dev)
+static void alx_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct alx_priv *alx = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/atheros/atl1c/atl1c_main.c b/drivers/net/ethernet/atheros/atl1c/atl1c_main.c
index 7087b88550db..28c3c83c1043 100644
--- a/drivers/net/ethernet/atheros/atl1c/atl1c_main.c
+++ b/drivers/net/ethernet/atheros/atl1c/atl1c_main.c
@@ -363,7 +363,7 @@ static void atl1c_del_timer(struct atl1c_adapter *adapter)
  * atl1c_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
  */
-static void atl1c_tx_timeout(struct net_device *netdev)
+static void atl1c_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct atl1c_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/atheros/atl1e/atl1e_main.c b/drivers/net/ethernet/atheros/atl1e/atl1e_main.c
index 9dc6da039a6d..616f21059d94 100644
--- a/drivers/net/ethernet/atheros/atl1e/atl1e_main.c
+++ b/drivers/net/ethernet/atheros/atl1e/atl1e_main.c
@@ -264,7 +264,7 @@ static void atl1e_cancel_work(struct atl1e_adapter *adapter)
  * atl1e_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
  */
-static void atl1e_tx_timeout(struct net_device *netdev)
+static void atl1e_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct atl1e_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/atheros/atlx/atl2.c b/drivers/net/ethernet/atheros/atlx/atl2.c
index 960407f1758f..884cc7572720 100644
--- a/drivers/net/ethernet/atheros/atlx/atl2.c
+++ b/drivers/net/ethernet/atheros/atlx/atl2.c
@@ -1015,7 +1015,7 @@ static int atl2_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
  * atl2_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
  */
-static void atl2_tx_timeout(struct net_device *netdev)
+static void atl2_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct atl2_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/atheros/atlx/atlx.c b/drivers/net/ethernet/atheros/atlx/atlx.c
index 46a622cceee4..55408f40541b 100644
--- a/drivers/net/ethernet/atheros/atlx/atlx.c
+++ b/drivers/net/ethernet/atheros/atlx/atlx.c
@@ -196,7 +196,7 @@ static void atlx_clear_phy_int(struct atlx_adapter *adapter)
  * atlx_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
  */
-static void atlx_tx_timeout(struct net_device *netdev)
+static void atlx_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct atlx_adapter *adapter = netdev_priv(netdev);
 	/* Do the reset outside of interrupt context */
diff --git a/drivers/net/ethernet/broadcom/b44.c b/drivers/net/ethernet/broadcom/b44.c
index f44808959ff3..fd1cba28c595 100644
--- a/drivers/net/ethernet/broadcom/b44.c
+++ b/drivers/net/ethernet/broadcom/b44.c
@@ -951,7 +951,7 @@ static irqreturn_t b44_interrupt(int irq, void *dev_id)
 	return IRQ_RETVAL(handled);
 }
 
-static void b44_tx_timeout(struct net_device *dev)
+static void b44_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct b44 *bp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/broadcom/bcmsysport.c b/drivers/net/ethernet/broadcom/bcmsysport.c
index 4a7c7f00dcb0..d46eb0b0a6da 100644
--- a/drivers/net/ethernet/broadcom/bcmsysport.c
+++ b/drivers/net/ethernet/broadcom/bcmsysport.c
@@ -1338,7 +1338,7 @@ static netdev_tx_t bcm_sysport_xmit(struct sk_buff *skb,
 	return ret;
 }
 
-static void bcm_sysport_tx_timeout(struct net_device *dev)
+static void bcm_sysport_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	netdev_warn(dev, "transmit timeout!\n");
 
diff --git a/drivers/net/ethernet/broadcom/bnx2.c b/drivers/net/ethernet/broadcom/bnx2.c
index 9ed0d9ab67a8..05b92ed39b86 100644
--- a/drivers/net/ethernet/broadcom/bnx2.c
+++ b/drivers/net/ethernet/broadcom/bnx2.c
@@ -6575,7 +6575,7 @@ bnx2_dump_state(struct bnx2 *bp)
 }
 
 static void
-bnx2_tx_timeout(struct net_device *dev)
+bnx2_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct bnx2 *bp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
index 4e0bed89d78d..cfda368d14d4 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
@@ -4971,7 +4971,7 @@ int bnx2x_set_features(struct net_device *dev, netdev_features_t features)
 	return 0;
 }
 
-void bnx2x_tx_timeout(struct net_device *dev)
+void bnx2x_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct bnx2x *bp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
index a47b85257b85..a070aeb82c12 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.h
@@ -618,7 +618,7 @@ int bnx2x_set_features(struct net_device *dev, netdev_features_t features);
  *
  * @dev:	net device
  */
-void bnx2x_tx_timeout(struct net_device *dev);
+void bnx2x_tx_timeout(struct net_device *dev, unsigned int txqueue);
 
 /** bnx2x_get_c2s_mapping - read inner-to-outer vlan configuration
  * c2s_map should have BNX2X_MAX_PRIORITY entries.
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index f0c5e8e2615a..499cacde74cc 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -9961,7 +9961,7 @@ static void bnxt_reset_task(struct bnxt *bp, bool silent)
 	}
 }
 
-static void bnxt_tx_timeout(struct net_device *dev)
+static void bnxt_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct bnxt *bp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/broadcom/genet/bcmgenet.c b/drivers/net/ethernet/broadcom/genet/bcmgenet.c
index 3f674c9b0354..9e5b0d45e310 100644
--- a/drivers/net/ethernet/broadcom/genet/bcmgenet.c
+++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.c
@@ -3052,7 +3052,7 @@ static void bcmgenet_dump_tx_queue(struct bcmgenet_tx_ring *ring)
 		  ring->cb_ptr, ring->end_ptr);
 }
 
-static void bcmgenet_timeout(struct net_device *dev)
+static void bcmgenet_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct bcmgenet_priv *priv = netdev_priv(dev);
 	u32 int0_enable = 0;
diff --git a/drivers/net/ethernet/broadcom/sb1250-mac.c b/drivers/net/ethernet/broadcom/sb1250-mac.c
index 53acbbb36637..bc2693bf4138 100644
--- a/drivers/net/ethernet/broadcom/sb1250-mac.c
+++ b/drivers/net/ethernet/broadcom/sb1250-mac.c
@@ -307,7 +307,7 @@ static int sbmac_set_duplex(struct sbmac_softc *s, enum sbmac_duplex duplex,
 			    enum sbmac_fc fc);
 
 static int sbmac_open(struct net_device *dev);
-static void sbmac_tx_timeout (struct net_device *dev);
+static void sbmac_tx_timeout (struct net_device *dev, unsigned int txqueue);
 static void sbmac_set_rx_mode(struct net_device *dev);
 static int sbmac_mii_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 static int sbmac_close(struct net_device *dev);
@@ -2432,7 +2432,7 @@ static void sbmac_mii_poll(struct net_device *dev)
 }
 
 
-static void sbmac_tx_timeout (struct net_device *dev)
+static void sbmac_tx_timeout (struct net_device *dev, unsigned int txqueue)
 {
 	struct sbmac_softc *sc = netdev_priv(dev);
 	unsigned long flags;
diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c
index 416405b4edf4..060f16b61c1b 100644
--- a/drivers/net/ethernet/broadcom/tg3.c
+++ b/drivers/net/ethernet/broadcom/tg3.c
@@ -7640,7 +7640,7 @@ static void tg3_poll_controller(struct net_device *dev)
 }
 #endif
 
-static void tg3_tx_timeout(struct net_device *dev)
+static void tg3_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct tg3 *tp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/calxeda/xgmac.c b/drivers/net/ethernet/calxeda/xgmac.c
index 2c63afff1382..5de07bb4f248 100644
--- a/drivers/net/ethernet/calxeda/xgmac.c
+++ b/drivers/net/ethernet/calxeda/xgmac.c
@@ -1261,7 +1261,7 @@ static int xgmac_poll(struct napi_struct *napi, int budget)
  *   netdev structure and arrange for the device to be reset to a sane state
  *   in order to transmit a new packet.
  */
-static void xgmac_tx_timeout(struct net_device *dev)
+static void xgmac_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct xgmac_priv *priv = netdev_priv(dev);
 	schedule_work(&priv->tx_timeout_work);
diff --git a/drivers/net/ethernet/cavium/liquidio/lio_main.c b/drivers/net/ethernet/cavium/liquidio/lio_main.c
index f9bbd939deb3..09d40722ba67 100644
--- a/drivers/net/ethernet/cavium/liquidio/lio_main.c
+++ b/drivers/net/ethernet/cavium/liquidio/lio_main.c
@@ -2568,7 +2568,7 @@ static int liquidio_xmit(struct sk_buff *skb, struct net_device *netdev)
 /** \brief Network device Tx timeout
  * @param netdev    pointer to network device
  */
-static void liquidio_tx_timeout(struct net_device *netdev)
+static void liquidio_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct lio *lio;
 
diff --git a/drivers/net/ethernet/cavium/liquidio/lio_vf_main.c b/drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
index 376476371d2a..cc3cf34d9433 100644
--- a/drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
+++ b/drivers/net/ethernet/cavium/liquidio/lio_vf_main.c
@@ -1618,7 +1618,7 @@ static int liquidio_xmit(struct sk_buff *skb, struct net_device *netdev)
 /** \brief Network device Tx timeout
  * @param netdev    pointer to network device
  */
-static void liquidio_tx_timeout(struct net_device *netdev)
+static void liquidio_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct lio *lio;
 
* Unmerged path drivers/net/ethernet/cavium/liquidio/lio_vf_rep.c
diff --git a/drivers/net/ethernet/cavium/thunder/nicvf_main.c b/drivers/net/ethernet/cavium/thunder/nicvf_main.c
index 3c3c16299bcb..d2012a49cf9c 100644
--- a/drivers/net/ethernet/cavium/thunder/nicvf_main.c
+++ b/drivers/net/ethernet/cavium/thunder/nicvf_main.c
@@ -1728,7 +1728,7 @@ static void nicvf_get_stats64(struct net_device *netdev,
 
 }
 
-static void nicvf_tx_timeout(struct net_device *dev)
+static void nicvf_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct nicvf *nic = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/cirrus/cs89x0.c b/drivers/net/ethernet/cirrus/cs89x0.c
index b3e7fafee3df..a27e86d5a00b 100644
--- a/drivers/net/ethernet/cirrus/cs89x0.c
+++ b/drivers/net/ethernet/cirrus/cs89x0.c
@@ -1128,7 +1128,7 @@ net_get_stats(struct net_device *dev)
 	return &dev->stats;
 }
 
-static void net_timeout(struct net_device *dev)
+static void net_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	/* If we get here, some higher level has decided we are broken.
 	   There should really be a "kick me" function call instead. */
diff --git a/drivers/net/ethernet/cisco/enic/enic_main.c b/drivers/net/ethernet/cisco/enic/enic_main.c
index acb2856936d2..bbd7b3175f09 100644
--- a/drivers/net/ethernet/cisco/enic/enic_main.c
+++ b/drivers/net/ethernet/cisco/enic/enic_main.c
@@ -1095,7 +1095,7 @@ static void enic_set_rx_mode(struct net_device *netdev)
 }
 
 /* netif_tx_lock held, BHs disabled */
-static void enic_tx_timeout(struct net_device *netdev)
+static void enic_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct enic *enic = netdev_priv(netdev);
 	schedule_work(&enic->tx_hang_reset);
diff --git a/drivers/net/ethernet/cortina/gemini.c b/drivers/net/ethernet/cortina/gemini.c
index 40992af84318..d9a7739f2937 100644
--- a/drivers/net/ethernet/cortina/gemini.c
+++ b/drivers/net/ethernet/cortina/gemini.c
@@ -1262,7 +1262,7 @@ static int gmac_start_xmit(struct sk_buff *skb, struct net_device *netdev)
 	return NETDEV_TX_OK;
 }
 
-static void gmac_tx_timeout(struct net_device *netdev)
+static void gmac_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	netdev_err(netdev, "Tx timeout\n");
 	gmac_dump_dma_state(netdev);
diff --git a/drivers/net/ethernet/davicom/dm9000.c b/drivers/net/ethernet/davicom/dm9000.c
index 50222b7b81f3..1ea29122e1f2 100644
--- a/drivers/net/ethernet/davicom/dm9000.c
+++ b/drivers/net/ethernet/davicom/dm9000.c
@@ -972,7 +972,7 @@ dm9000_init_dm9000(struct net_device *dev)
 }
 
 /* Our watchdog timed out. Called by the networking layer */
-static void dm9000_timeout(struct net_device *dev)
+static void dm9000_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct board_info *db = netdev_priv(dev);
 	u8 reg_save;
diff --git a/drivers/net/ethernet/dec/tulip/de2104x.c b/drivers/net/ethernet/dec/tulip/de2104x.c
index 13430f75496c..dda2ba735a7e 100644
--- a/drivers/net/ethernet/dec/tulip/de2104x.c
+++ b/drivers/net/ethernet/dec/tulip/de2104x.c
@@ -1436,7 +1436,7 @@ static int de_close (struct net_device *dev)
 	return 0;
 }
 
-static void de_tx_timeout (struct net_device *dev)
+static void de_tx_timeout (struct net_device *dev, unsigned int txqueue)
 {
 	struct de_private *de = netdev_priv(dev);
 	const int irq = de->pdev->irq;
diff --git a/drivers/net/ethernet/dec/tulip/tulip_core.c b/drivers/net/ethernet/dec/tulip/tulip_core.c
index 00d02a0967d0..6dc60eec09ae 100644
--- a/drivers/net/ethernet/dec/tulip/tulip_core.c
+++ b/drivers/net/ethernet/dec/tulip/tulip_core.c
@@ -255,7 +255,7 @@ MODULE_DEVICE_TABLE(pci, tulip_pci_tbl);
 const char tulip_media_cap[32] =
 {0,0,0,16,  3,19,16,24,  27,4,7,5, 0,20,23,20,  28,31,0,0, };
 
-static void tulip_tx_timeout(struct net_device *dev);
+static void tulip_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void tulip_init_ring(struct net_device *dev);
 static void tulip_free_ring(struct net_device *dev);
 static netdev_tx_t tulip_start_xmit(struct sk_buff *skb,
@@ -534,7 +534,7 @@ tulip_open(struct net_device *dev)
 }
 
 
-static void tulip_tx_timeout(struct net_device *dev)
+static void tulip_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct tulip_private *tp = netdev_priv(dev);
 	void __iomem *ioaddr = tp->base_addr;
diff --git a/drivers/net/ethernet/dec/tulip/winbond-840.c b/drivers/net/ethernet/dec/tulip/winbond-840.c
index 70cb2d689c2c..7f136488e67c 100644
--- a/drivers/net/ethernet/dec/tulip/winbond-840.c
+++ b/drivers/net/ethernet/dec/tulip/winbond-840.c
@@ -331,7 +331,7 @@ static void netdev_timer(struct timer_list *t);
 static void init_rxtx_rings(struct net_device *dev);
 static void free_rxtx_rings(struct netdev_private *np);
 static void init_registers(struct net_device *dev);
-static void tx_timeout(struct net_device *dev);
+static void tx_timeout(struct net_device *dev, unsigned int txqueue);
 static int alloc_ringdesc(struct net_device *dev);
 static void free_ringdesc(struct netdev_private *np);
 static netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev);
@@ -921,7 +921,7 @@ static void init_registers(struct net_device *dev)
 	iowrite32(0, ioaddr + RxStartDemand);
 }
 
-static void tx_timeout(struct net_device *dev)
+static void tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct netdev_private *np = netdev_priv(dev);
 	void __iomem *ioaddr = np->base_addr;
diff --git a/drivers/net/ethernet/dlink/dl2k.c b/drivers/net/ethernet/dlink/dl2k.c
index 3cae596fd50f..e2395c128aa7 100644
--- a/drivers/net/ethernet/dlink/dl2k.c
+++ b/drivers/net/ethernet/dlink/dl2k.c
@@ -69,7 +69,7 @@ static const int multicast_filter_limit = 0x40;
 
 static int rio_open (struct net_device *dev);
 static void rio_timer (struct timer_list *t);
-static void rio_tx_timeout (struct net_device *dev);
+static void rio_tx_timeout (struct net_device *dev, unsigned int txqueue);
 static netdev_tx_t start_xmit (struct sk_buff *skb, struct net_device *dev);
 static irqreturn_t rio_interrupt (int irq, void *dev_instance);
 static void rio_free_tx (struct net_device *dev, int irq);
@@ -701,7 +701,7 @@ rio_timer (struct timer_list *t)
 }
 
 static void
-rio_tx_timeout (struct net_device *dev)
+rio_tx_timeout (struct net_device *dev, unsigned int txqueue)
 {
 	struct netdev_private *np = netdev_priv(dev);
 	void __iomem *ioaddr = np->ioaddr;
diff --git a/drivers/net/ethernet/dlink/sundance.c b/drivers/net/ethernet/dlink/sundance.c
index 1a27176381fb..3442bf79fc11 100644
--- a/drivers/net/ethernet/dlink/sundance.c
+++ b/drivers/net/ethernet/dlink/sundance.c
@@ -432,7 +432,7 @@ static int  mdio_wait_link(struct net_device *dev, int wait);
 static int  netdev_open(struct net_device *dev);
 static void check_duplex(struct net_device *dev);
 static void netdev_timer(struct timer_list *t);
-static void tx_timeout(struct net_device *dev);
+static void tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void init_ring(struct net_device *dev);
 static netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev);
 static int reset_tx (struct net_device *dev);
@@ -969,7 +969,7 @@ static void netdev_timer(struct timer_list *t)
 	add_timer(&np->timer);
 }
 
-static void tx_timeout(struct net_device *dev)
+static void tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct netdev_private *np = netdev_priv(dev);
 	void __iomem *ioaddr = np->base;
diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c
index 39eb7d525043..56f59db6ebf2 100644
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@ -1417,7 +1417,7 @@ static netdev_tx_t be_xmit(struct sk_buff *skb, struct net_device *netdev)
 	return NETDEV_TX_OK;
 }
 
-static void be_tx_timeout(struct net_device *netdev)
+static void be_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct be_adapter *adapter = netdev_priv(netdev);
 	struct device *dev = &adapter->pdev->dev;
diff --git a/drivers/net/ethernet/ethoc.c b/drivers/net/ethernet/ethoc.c
index 3914757b7a06..c0c7a35d0af6 100644
--- a/drivers/net/ethernet/ethoc.c
+++ b/drivers/net/ethernet/ethoc.c
@@ -872,7 +872,7 @@ static int ethoc_change_mtu(struct net_device *dev, int new_mtu)
 	return -ENOSYS;
 }
 
-static void ethoc_tx_timeout(struct net_device *dev)
+static void ethoc_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct ethoc *priv = netdev_priv(dev);
 	u32 pending = ethoc_read(priv, INT_SOURCE);
diff --git a/drivers/net/ethernet/faraday/ftgmac100.c b/drivers/net/ethernet/faraday/ftgmac100.c
index d8ead7e4177e..e4431a01ea29 100644
--- a/drivers/net/ethernet/faraday/ftgmac100.c
+++ b/drivers/net/ethernet/faraday/ftgmac100.c
@@ -1557,7 +1557,7 @@ static int ftgmac100_do_ioctl(struct net_device *netdev, struct ifreq *ifr, int
 	return phy_mii_ioctl(netdev->phydev, ifr, cmd);
 }
 
-static void ftgmac100_tx_timeout(struct net_device *netdev)
+static void ftgmac100_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct ftgmac100 *priv = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/fealnx.c b/drivers/net/ethernet/fealnx.c
index ae55da60ed0e..e3f92d38464f 100644
--- a/drivers/net/ethernet/fealnx.c
+++ b/drivers/net/ethernet/fealnx.c
@@ -428,7 +428,7 @@ static void getlinktype(struct net_device *dev);
 static void getlinkstatus(struct net_device *dev);
 static void netdev_timer(struct timer_list *t);
 static void reset_timer(struct timer_list *t);
-static void fealnx_tx_timeout(struct net_device *dev);
+static void fealnx_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void init_ring(struct net_device *dev);
 static netdev_tx_t start_tx(struct sk_buff *skb, struct net_device *dev);
 static irqreturn_t intr_handler(int irq, void *dev_instance);
@@ -1191,7 +1191,7 @@ static void reset_timer(struct timer_list *t)
 }
 
 
-static void fealnx_tx_timeout(struct net_device *dev)
+static void fealnx_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct netdev_private *np = netdev_priv(dev);
 	void __iomem *ioaddr = np->mem;
diff --git a/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
index 5245d8bcda27..15fe3d780457 100644
--- a/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
@@ -308,7 +308,7 @@ static int dpaa_stop(struct net_device *net_dev)
 	return err;
 }
 
-static void dpaa_tx_timeout(struct net_device *net_dev)
+static void dpaa_tx_timeout(struct net_device *net_dev, unsigned int txqueue)
 {
 	struct dpaa_percpu_priv *percpu_priv;
 	const struct dpaa_priv	*priv;
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index b5bc36b2389c..9b9290d8b514 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -1135,7 +1135,7 @@ fec_stop(struct net_device *ndev)
 
 
 static void
-fec_timeout(struct net_device *ndev)
+fec_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct fec_enet_private *fep = netdev_priv(ndev);
 
diff --git a/drivers/net/ethernet/freescale/fec_mpc52xx.c b/drivers/net/ethernet/freescale/fec_mpc52xx.c
index 6d7269d87a85..dc20614b8f44 100644
--- a/drivers/net/ethernet/freescale/fec_mpc52xx.c
+++ b/drivers/net/ethernet/freescale/fec_mpc52xx.c
@@ -84,7 +84,7 @@ static int debug = -1;	/* the above default */
 module_param(debug, int, 0);
 MODULE_PARM_DESC(debug, "debugging messages level");
 
-static void mpc52xx_fec_tx_timeout(struct net_device *dev)
+static void mpc52xx_fec_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct mpc52xx_fec_priv *priv = netdev_priv(dev);
 	unsigned long flags;
diff --git a/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c b/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
index 2c2976a2dda6..8379ab1dc6e3 100644
--- a/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
+++ b/drivers/net/ethernet/freescale/fs_enet/fs_enet-main.c
@@ -640,7 +640,7 @@ static void fs_timeout_work(struct work_struct *work)
 		netif_wake_queue(dev);
 }
 
-static void fs_timeout(struct net_device *dev)
+static void fs_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct fs_enet_private *fep = netdev_priv(dev);
 
* Unmerged path drivers/net/ethernet/freescale/gianfar.c
diff --git a/drivers/net/ethernet/freescale/ucc_geth.c b/drivers/net/ethernet/freescale/ucc_geth.c
index 5cd57517f439..2e8e7a2fde71 100644
--- a/drivers/net/ethernet/freescale/ucc_geth.c
+++ b/drivers/net/ethernet/freescale/ucc_geth.c
@@ -3538,7 +3538,7 @@ static void ucc_geth_timeout_work(struct work_struct *work)
  * ucc_geth_timeout gets called when a packet has not been
  * transmitted after a set amount of time.
  */
-static void ucc_geth_timeout(struct net_device *dev)
+static void ucc_geth_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct ucc_geth_private *ugeth = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/fujitsu/fmvj18x_cs.c b/drivers/net/ethernet/fujitsu/fmvj18x_cs.c
index a69cd19a55ae..dc90c61fc827 100644
--- a/drivers/net/ethernet/fujitsu/fmvj18x_cs.c
+++ b/drivers/net/ethernet/fujitsu/fmvj18x_cs.c
@@ -93,7 +93,7 @@ static irqreturn_t fjn_interrupt(int irq, void *dev_id);
 static void fjn_rx(struct net_device *dev);
 static void fjn_reset(struct net_device *dev);
 static void set_rx_mode(struct net_device *dev);
-static void fjn_tx_timeout(struct net_device *dev);
+static void fjn_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static const struct ethtool_ops netdev_ethtool_ops;
 
 /*
@@ -769,7 +769,7 @@ static irqreturn_t fjn_interrupt(int dummy, void *dev_id)
 
 /*====================================================================*/
 
-static void fjn_tx_timeout(struct net_device *dev)
+static void fjn_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
     struct local_info *lp = netdev_priv(dev);
     unsigned int ioaddr = dev->base_addr;
diff --git a/drivers/net/ethernet/google/gve/gve_main.c b/drivers/net/ethernet/google/gve/gve_main.c
index 9b7a8db9860f..e032563ceefd 100644
--- a/drivers/net/ethernet/google/gve/gve_main.c
+++ b/drivers/net/ethernet/google/gve/gve_main.c
@@ -845,7 +845,7 @@ static void gve_turnup(struct gve_priv *priv)
 	gve_set_napi_enabled(priv);
 }
 
-static void gve_tx_timeout(struct net_device *dev)
+static void gve_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct gve_priv *priv = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/hisilicon/hip04_eth.c b/drivers/net/ethernet/hisilicon/hip04_eth.c
index 340e28211135..54f00fa75385 100644
--- a/drivers/net/ethernet/hisilicon/hip04_eth.c
+++ b/drivers/net/ethernet/hisilicon/hip04_eth.c
@@ -685,7 +685,7 @@ static int hip04_mac_stop(struct net_device *ndev)
 	return 0;
 }
 
-static void hip04_timeout(struct net_device *ndev)
+static void hip04_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct hip04_priv *priv = netdev_priv(ndev);
 
diff --git a/drivers/net/ethernet/hisilicon/hix5hd2_gmac.c b/drivers/net/ethernet/hisilicon/hix5hd2_gmac.c
index 25a6c8722eca..1d55968d4e6b 100644
--- a/drivers/net/ethernet/hisilicon/hix5hd2_gmac.c
+++ b/drivers/net/ethernet/hisilicon/hix5hd2_gmac.c
@@ -897,7 +897,7 @@ static void hix5hd2_tx_timeout_task(struct work_struct *work)
 	hix5hd2_net_open(priv->netdev);
 }
 
-static void hix5hd2_net_timeout(struct net_device *dev)
+static void hix5hd2_net_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct hix5hd2_priv *priv = netdev_priv(dev);
 
* Unmerged path drivers/net/ethernet/hisilicon/hns/hns_enet.c
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c b/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
index 583bd6f9b033..669442d0326c 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3_enet.c
@@ -1583,7 +1583,7 @@ static bool hns3_get_tx_timeo_queue_info(struct net_device *ndev)
 	return true;
 }
 
-static void hns3_nic_net_timeout(struct net_device *ndev)
+static void hns3_nic_net_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct hns3_nic_priv *priv = netdev_priv(ndev);
 	struct hnae3_handle *h = priv->ae_handle;
diff --git a/drivers/net/ethernet/huawei/hinic/hinic_main.c b/drivers/net/ethernet/huawei/hinic/hinic_main.c
index 87ee796398ea..756d6aa92389 100644
--- a/drivers/net/ethernet/huawei/hinic/hinic_main.c
+++ b/drivers/net/ethernet/huawei/hinic/hinic_main.c
@@ -759,7 +759,7 @@ static void hinic_set_rx_mode(struct net_device *netdev)
 	queue_work(nic_dev->workq, &rx_mode_work->work);
 }
 
-static void hinic_tx_timeout(struct net_device *netdev)
+static void hinic_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct hinic_dev *nic_dev = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/i825xx/82596.c b/drivers/net/ethernet/i825xx/82596.c
index d719668a6684..394811b1edbd 100644
--- a/drivers/net/ethernet/i825xx/82596.c
+++ b/drivers/net/ethernet/i825xx/82596.c
@@ -363,7 +363,7 @@ static netdev_tx_t i596_start_xmit(struct sk_buff *skb, struct net_device *dev);
 static irqreturn_t i596_interrupt(int irq, void *dev_id);
 static int i596_close(struct net_device *dev);
 static void i596_add_cmd(struct net_device *dev, struct i596_cmd *cmd);
-static void i596_tx_timeout (struct net_device *dev);
+static void i596_tx_timeout (struct net_device *dev, unsigned int txqueue);
 static void print_eth(unsigned char *buf, char *str);
 static void set_multicast_list(struct net_device *dev);
 
@@ -1019,7 +1019,7 @@ static int i596_open(struct net_device *dev)
 	return res;
 }
 
-static void i596_tx_timeout (struct net_device *dev)
+static void i596_tx_timeout (struct net_device *dev, unsigned int txqueue)
 {
 	struct i596_private *lp = dev->ml_priv;
 	int ioaddr = dev->base_addr;
diff --git a/drivers/net/ethernet/i825xx/ether1.c b/drivers/net/ethernet/i825xx/ether1.c
index dc983450354b..ff82f05d256c 100644
--- a/drivers/net/ethernet/i825xx/ether1.c
+++ b/drivers/net/ethernet/i825xx/ether1.c
@@ -68,7 +68,7 @@ static int ether1_sendpacket(struct sk_buff *skb, struct net_device *dev);
 static irqreturn_t ether1_interrupt(int irq, void *dev_id);
 static int ether1_close(struct net_device *dev);
 static void ether1_setmulticastlist(struct net_device *dev);
-static void ether1_timeout(struct net_device *dev);
+static void ether1_timeout(struct net_device *dev, unsigned int txqueue);
 
 /* ------------------------------------------------------------------------- */
 
@@ -652,7 +652,7 @@ ether1_open (struct net_device *dev)
 }
 
 static void
-ether1_timeout(struct net_device *dev)
+ether1_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	printk(KERN_WARNING "%s: transmit timeout, network cable problem?\n",
 		dev->name);
diff --git a/drivers/net/ethernet/i825xx/lib82596.c b/drivers/net/ethernet/i825xx/lib82596.c
index f00a1dc2128c..c1cf66f8c668 100644
--- a/drivers/net/ethernet/i825xx/lib82596.c
+++ b/drivers/net/ethernet/i825xx/lib82596.c
@@ -351,7 +351,7 @@ static int i596_start_xmit(struct sk_buff *skb, struct net_device *dev);
 static irqreturn_t i596_interrupt(int irq, void *dev_id);
 static int i596_close(struct net_device *dev);
 static void i596_add_cmd(struct net_device *dev, struct i596_cmd *cmd);
-static void i596_tx_timeout (struct net_device *dev);
+static void i596_tx_timeout (struct net_device *dev, unsigned int txqueue);
 static void print_eth(unsigned char *buf, char *str);
 static void set_multicast_list(struct net_device *dev);
 static inline void ca(struct net_device *dev);
@@ -936,7 +936,7 @@ static int i596_open(struct net_device *dev)
 	return -EAGAIN;
 }
 
-static void i596_tx_timeout (struct net_device *dev)
+static void i596_tx_timeout (struct net_device *dev, unsigned int txqueue)
 {
 	struct i596_private *lp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/i825xx/sun3_82586.c b/drivers/net/ethernet/i825xx/sun3_82586.c
index 8bb15a8c2a40..eff693badbfb 100644
--- a/drivers/net/ethernet/i825xx/sun3_82586.c
+++ b/drivers/net/ethernet/i825xx/sun3_82586.c
@@ -124,7 +124,7 @@ static int     sun3_82586_close(struct net_device *dev);
 static int     sun3_82586_send_packet(struct sk_buff *,struct net_device *);
 static struct  net_device_stats *sun3_82586_get_stats(struct net_device *dev);
 static void    set_multicast_list(struct net_device *dev);
-static void    sun3_82586_timeout(struct net_device *dev);
+static void    sun3_82586_timeout(struct net_device *dev, unsigned int txqueue);
 #if 0
 static void    sun3_82586_dump(struct net_device *,void *);
 #endif
@@ -964,7 +964,7 @@ static void startrecv586(struct net_device *dev)
 	WAIT_4_SCB_CMD_RUC();	/* wait for accept cmd. (no timeout!!) */
 }
 
-static void sun3_82586_timeout(struct net_device *dev)
+static void sun3_82586_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct priv *p = netdev_priv(dev);
 #ifndef NO_NOPCOMMANDS
diff --git a/drivers/net/ethernet/ibm/ehea/ehea_main.c b/drivers/net/ethernet/ibm/ehea/ehea_main.c
index ba580bfae512..5e685edea4b4 100644
--- a/drivers/net/ethernet/ibm/ehea/ehea_main.c
+++ b/drivers/net/ethernet/ibm/ehea/ehea_main.c
@@ -2816,7 +2816,7 @@ static void ehea_rereg_mrs(void)
 	return;
 }
 
-static void ehea_tx_watchdog(struct net_device *dev)
+static void ehea_tx_watchdog(struct net_device *dev, unsigned int txqueue)
 {
 	struct ehea_port *port = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/ibm/emac/core.c b/drivers/net/ethernet/ibm/emac/core.c
index 838d5bf675b3..4c848733f562 100644
--- a/drivers/net/ethernet/ibm/emac/core.c
+++ b/drivers/net/ethernet/ibm/emac/core.c
@@ -781,7 +781,7 @@ static void emac_reset_work(struct work_struct *work)
 	mutex_unlock(&dev->link_lock);
 }
 
-static void emac_tx_timeout(struct net_device *ndev)
+static void emac_tx_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct emac_instance *dev = netdev_priv(ndev);
 
diff --git a/drivers/net/ethernet/ibm/ibmvnic.c b/drivers/net/ethernet/ibm/ibmvnic.c
index 2725bf789f4e..67748eb0e006 100644
--- a/drivers/net/ethernet/ibm/ibmvnic.c
+++ b/drivers/net/ethernet/ibm/ibmvnic.c
@@ -2298,7 +2298,7 @@ static int ibmvnic_reset(struct ibmvnic_adapter *adapter,
 	return -ret;
 }
 
-static void ibmvnic_tx_timeout(struct net_device *dev)
+static void ibmvnic_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct ibmvnic_adapter *adapter = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/intel/e100.c b/drivers/net/ethernet/intel/e100.c
index 27d5f27163d2..a44db63d4f00 100644
--- a/drivers/net/ethernet/intel/e100.c
+++ b/drivers/net/ethernet/intel/e100.c
@@ -2314,7 +2314,7 @@ static void e100_down(struct nic *nic)
 	e100_rx_clean_list(nic);
 }
 
-static void e100_tx_timeout(struct net_device *netdev)
+static void e100_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct nic *nic = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/intel/e1000/e1000_main.c b/drivers/net/ethernet/intel/e1000/e1000_main.c
index 4c648174ae76..365daf821777 100644
--- a/drivers/net/ethernet/intel/e1000/e1000_main.c
+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c
@@ -134,7 +134,7 @@ static int e1000_mii_ioctl(struct net_device *netdev, struct ifreq *ifr,
 			   int cmd);
 static void e1000_enter_82542_rst(struct e1000_adapter *adapter);
 static void e1000_leave_82542_rst(struct e1000_adapter *adapter);
-static void e1000_tx_timeout(struct net_device *dev);
+static void e1000_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void e1000_reset_task(struct work_struct *work);
 static void e1000_smartspeed(struct e1000_adapter *adapter);
 static int e1000_82547_fifo_workaround(struct e1000_adapter *adapter,
@@ -3495,7 +3495,7 @@ static void e1000_dump(struct e1000_adapter *adapter)
  * e1000_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
  **/
-static void e1000_tx_timeout(struct net_device *netdev)
+static void e1000_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct e1000_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c
index 20965b5d9780..272258051963 100644
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@ -5929,7 +5929,7 @@ static netdev_tx_t e1000_xmit_frame(struct sk_buff *skb,
  * e1000_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
  **/
-static void e1000_tx_timeout(struct net_device *netdev)
+static void e1000_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct e1000_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c b/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
index d3e85480f46d..7375f59a82ac 100644
--- a/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
+++ b/drivers/net/ethernet/intel/fm10k/fm10k_netdev.c
@@ -698,7 +698,7 @@ static netdev_tx_t fm10k_xmit_frame(struct sk_buff *skb, struct net_device *dev)
  * fm10k_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
  **/
-static void fm10k_tx_timeout(struct net_device *netdev)
+static void fm10k_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct fm10k_intfc *interface = netdev_priv(netdev);
 	bool real_tx_hang = false;
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index c492885b06a2..779457a618e9 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -301,7 +301,7 @@ void i40e_service_event_schedule(struct i40e_pf *pf)
  * device is munged, not just the one netdev port, so go for the full
  * reset.
  **/
-static void i40e_tx_timeout(struct net_device *netdev)
+static void i40e_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct i40e_netdev_priv *np = netdev_priv(netdev);
 	struct i40e_vsi *vsi = np->vsi;
diff --git a/drivers/net/ethernet/intel/iavf/iavf_main.c b/drivers/net/ethernet/intel/iavf/iavf_main.c
index 8e16be960e96..62fe56ddcb6e 100644
--- a/drivers/net/ethernet/intel/iavf/iavf_main.c
+++ b/drivers/net/ethernet/intel/iavf/iavf_main.c
@@ -159,7 +159,7 @@ void iavf_schedule_reset(struct iavf_adapter *adapter)
  * iavf_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
  **/
-static void iavf_tx_timeout(struct net_device *netdev)
+static void iavf_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct iavf_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/intel/ice/ice_main.c b/drivers/net/ethernet/intel/ice/ice_main.c
index 713f184b43f1..3f50eb18fdaa 100644
--- a/drivers/net/ethernet/intel/ice/ice_main.c
+++ b/drivers/net/ethernet/intel/ice/ice_main.c
@@ -4627,7 +4627,7 @@ ice_bridge_setlink(struct net_device *dev, struct nlmsghdr *nlh,
  * ice_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
  */
-static void ice_tx_timeout(struct net_device *netdev)
+static void ice_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct ice_netdev_priv *np = netdev_priv(netdev);
 	struct ice_ring *tx_ring = NULL;
diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index d28dd25b8ef0..b5c2259c40b3 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -146,7 +146,7 @@ static int igb_poll(struct napi_struct *, int);
 static bool igb_clean_tx_irq(struct igb_q_vector *, int);
 static int igb_clean_rx_irq(struct igb_q_vector *, int);
 static int igb_ioctl(struct net_device *, struct ifreq *, int cmd);
-static void igb_tx_timeout(struct net_device *);
+static void igb_tx_timeout(struct net_device *, unsigned int txqueue);
 static void igb_reset_task(struct work_struct *);
 static void igb_vlan_mode(struct net_device *netdev,
 			  netdev_features_t features);
@@ -6203,7 +6203,7 @@ static netdev_tx_t igb_xmit_frame(struct sk_buff *skb,
  *  igb_tx_timeout - Respond to a Tx Hang
  *  @netdev: network interface device structure
  **/
-static void igb_tx_timeout(struct net_device *netdev)
+static void igb_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct igb_adapter *adapter = netdev_priv(netdev);
 	struct e1000_hw *hw = &adapter->hw;
diff --git a/drivers/net/ethernet/intel/igbvf/netdev.c b/drivers/net/ethernet/intel/igbvf/netdev.c
index 0f2b68f4bb0f..5721ddf124c4 100644
--- a/drivers/net/ethernet/intel/igbvf/netdev.c
+++ b/drivers/net/ethernet/intel/igbvf/netdev.c
@@ -2375,7 +2375,7 @@ static netdev_tx_t igbvf_xmit_frame(struct sk_buff *skb,
  * igbvf_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
  **/
-static void igbvf_tx_timeout(struct net_device *netdev)
+static void igbvf_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct igbvf_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/intel/ixgb/ixgb_main.c b/drivers/net/ethernet/intel/ixgb/ixgb_main.c
index 43664adf7a3c..29e479b62992 100644
--- a/drivers/net/ethernet/intel/ixgb/ixgb_main.c
+++ b/drivers/net/ethernet/intel/ixgb/ixgb_main.c
@@ -70,7 +70,7 @@ static int ixgb_clean(struct napi_struct *, int);
 static bool ixgb_clean_rx_irq(struct ixgb_adapter *, int *, int);
 static void ixgb_alloc_rx_buffers(struct ixgb_adapter *, int);
 
-static void ixgb_tx_timeout(struct net_device *dev);
+static void ixgb_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void ixgb_tx_timeout_task(struct work_struct *work);
 
 static void ixgb_vlan_strip_enable(struct ixgb_adapter *adapter);
@@ -1549,7 +1549,7 @@ ixgb_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
  **/
 
 static void
-ixgb_tx_timeout(struct net_device *netdev)
+ixgb_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct ixgb_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c
index 171cdc552961..5b1cf49df3d3 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c
@@ -166,7 +166,9 @@ static ssize_t ixgbe_dbg_netdev_ops_write(struct file *filp,
 	ixgbe_dbg_netdev_ops_buf[len] = '\0';
 
 	if (strncmp(ixgbe_dbg_netdev_ops_buf, "tx_timeout", 10) == 0) {
-		adapter->netdev->netdev_ops->ndo_tx_timeout(adapter->netdev);
+		/* TX Queue number below is wrong, but ixgbe does not use it */
+		adapter->netdev->netdev_ops->ndo_tx_timeout(adapter->netdev,
+							    UINT_MAX);
 		e_dev_info("tx_timeout called\n");
 	} else {
 		e_dev_info("Unknown command: %s\n", ixgbe_dbg_netdev_ops_buf);
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 9ed75d2a8ac2..9e308bdaf308 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -6158,7 +6158,7 @@ static void ixgbe_set_eee_capable(struct ixgbe_adapter *adapter)
  * ixgbe_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
  **/
-static void ixgbe_tx_timeout(struct net_device *netdev)
+static void ixgbe_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c
index e490e15ba360..d2706ee68c00 100644
--- a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c
+++ b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c
@@ -250,7 +250,7 @@ static void ixgbevf_tx_timeout_reset(struct ixgbevf_adapter *adapter)
  * ixgbevf_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
  **/
-static void ixgbevf_tx_timeout(struct net_device *netdev)
+static void ixgbevf_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct ixgbevf_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/jme.c b/drivers/net/ethernet/jme.c
index 5edc7d2b8562..6c65175dd53c 100644
--- a/drivers/net/ethernet/jme.c
+++ b/drivers/net/ethernet/jme.c
@@ -2357,7 +2357,7 @@ jme_change_mtu(struct net_device *netdev, int new_mtu)
 }
 
 static void
-jme_tx_timeout(struct net_device *netdev)
+jme_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct jme_adapter *jme = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/korina.c b/drivers/net/ethernet/korina.c
index ae195f8adff5..f98d9d627c71 100644
--- a/drivers/net/ethernet/korina.c
+++ b/drivers/net/ethernet/korina.c
@@ -917,7 +917,7 @@ static void korina_restart_task(struct work_struct *work)
 	enable_irq(lp->rx_irq);
 }
 
-static void korina_tx_timeout(struct net_device *dev)
+static void korina_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct korina_private *lp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/lantiq_etop.c b/drivers/net/ethernet/lantiq_etop.c
index 7b25ba957d3f..cfb32bd488b8 100644
--- a/drivers/net/ethernet/lantiq_etop.c
+++ b/drivers/net/ethernet/lantiq_etop.c
@@ -600,7 +600,7 @@ ltq_etop_init(struct net_device *dev)
 }
 
 static void
-ltq_etop_tx_timeout(struct net_device *dev)
+ltq_etop_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	int err;
 
diff --git a/drivers/net/ethernet/marvell/mv643xx_eth.c b/drivers/net/ethernet/marvell/mv643xx_eth.c
index 010b7987ce55..6179bef41ec6 100644
--- a/drivers/net/ethernet/marvell/mv643xx_eth.c
+++ b/drivers/net/ethernet/marvell/mv643xx_eth.c
@@ -2602,7 +2602,7 @@ static void tx_timeout_task(struct work_struct *ugly)
 	}
 }
 
-static void mv643xx_eth_tx_timeout(struct net_device *dev)
+static void mv643xx_eth_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct mv643xx_eth_private *mp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/marvell/pxa168_eth.c b/drivers/net/ethernet/marvell/pxa168_eth.c
index b406395bbb37..8acd668c1a43 100644
--- a/drivers/net/ethernet/marvell/pxa168_eth.c
+++ b/drivers/net/ethernet/marvell/pxa168_eth.c
@@ -753,7 +753,7 @@ static int txq_reclaim(struct net_device *dev, int force)
 	return released;
 }
 
-static void pxa168_eth_tx_timeout(struct net_device *dev)
+static void pxa168_eth_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct pxa168_eth_private *pep = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/marvell/skge.c b/drivers/net/ethernet/marvell/skge.c
index 9c08c3650c02..da9c3d9e607b 100644
--- a/drivers/net/ethernet/marvell/skge.c
+++ b/drivers/net/ethernet/marvell/skge.c
@@ -2896,7 +2896,7 @@ static void skge_tx_clean(struct net_device *dev)
 	skge->tx_ring.to_clean = e;
 }
 
-static void skge_tx_timeout(struct net_device *dev)
+static void skge_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct skge_port *skge = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/marvell/sky2.c b/drivers/net/ethernet/marvell/sky2.c
index 6e25dde7ab0d..8c97c8439230 100644
--- a/drivers/net/ethernet/marvell/sky2.c
+++ b/drivers/net/ethernet/marvell/sky2.c
@@ -2369,7 +2369,7 @@ static void sky2_qlink_intr(struct sky2_hw *hw)
 /* Transmit timeout is only called if we are running, carrier is up
  * and tx queue is full (stopped).
  */
-static void sky2_tx_timeout(struct net_device *dev)
+static void sky2_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct sky2_port *sky2 = netdev_priv(dev);
 	struct sky2_hw *hw = sky2->hw;
diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.c b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
index 560978b71c31..e558deb9449b 100644
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -1732,7 +1732,7 @@ static void mtk_dma_free(struct mtk_eth *eth)
 	kfree(eth->scratch_head);
 }
 
-static void mtk_tx_timeout(struct net_device *dev)
+static void mtk_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct mtk_mac *mac = netdev_priv(dev);
 	struct mtk_eth *eth = mac->hw;
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 200463bd7173..f7b0b8fe9271 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -1364,7 +1364,7 @@ static void mlx4_en_delete_rss_steer_rules(struct mlx4_en_priv *priv)
 	}
 }
 
-static void mlx4_en_tx_timeout(struct net_device *dev)
+static void mlx4_en_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct mlx4_en_priv *priv = netdev_priv(dev);
 	struct mlx4_en_dev *mdev = priv->mdev;
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
index 00ef0cd3ca13..d6a628a62a91 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c
@@ -4299,7 +4299,7 @@ static void mlx5e_tx_timeout_work(struct work_struct *work)
 	rtnl_unlock();
 }
 
-static void mlx5e_tx_timeout(struct net_device *dev)
+static void mlx5e_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct mlx5e_priv *priv = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/micrel/ks8842.c b/drivers/net/ethernet/micrel/ks8842.c
index e3d7c74d47bb..8e6e0b501a37 100644
--- a/drivers/net/ethernet/micrel/ks8842.c
+++ b/drivers/net/ethernet/micrel/ks8842.c
@@ -1117,7 +1117,7 @@ static void ks8842_tx_timeout_work(struct work_struct *work)
 		__ks8842_start_new_rx_dma(netdev);
 }
 
-static void ks8842_tx_timeout(struct net_device *netdev)
+static void ks8842_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct ks8842_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/micrel/ksz884x.c b/drivers/net/ethernet/micrel/ksz884x.c
index b72d1bd11296..c7e62c514832 100644
--- a/drivers/net/ethernet/micrel/ksz884x.c
+++ b/drivers/net/ethernet/micrel/ksz884x.c
@@ -4907,7 +4907,7 @@ static netdev_tx_t netdev_tx(struct sk_buff *skb, struct net_device *dev)
  * triggered to free up resources so that the transmit routine can continue
  * sending out packets.  The hardware is reset to correct the problem.
  */
-static void netdev_tx_timeout(struct net_device *dev)
+static void netdev_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	static unsigned long last_reset;
 
diff --git a/drivers/net/ethernet/microchip/enc28j60.c b/drivers/net/ethernet/microchip/enc28j60.c
index f6ecfa778660..c992e0b87547 100644
--- a/drivers/net/ethernet/microchip/enc28j60.c
+++ b/drivers/net/ethernet/microchip/enc28j60.c
@@ -1332,7 +1332,7 @@ static irqreturn_t enc28j60_irq(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static void enc28j60_tx_timeout(struct net_device *ndev)
+static void enc28j60_tx_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct enc28j60_net *priv = netdev_priv(ndev);
 
diff --git a/drivers/net/ethernet/microchip/encx24j600.c b/drivers/net/ethernet/microchip/encx24j600.c
index f831238d9793..a4b2ea279493 100644
--- a/drivers/net/ethernet/microchip/encx24j600.c
+++ b/drivers/net/ethernet/microchip/encx24j600.c
@@ -897,7 +897,7 @@ static netdev_tx_t encx24j600_tx(struct sk_buff *skb, struct net_device *dev)
 }
 
 /* Deal with a transmit timeout */
-static void encx24j600_tx_timeout(struct net_device *dev)
+static void encx24j600_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct encx24j600_priv *priv = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/natsemi/natsemi.c b/drivers/net/ethernet/natsemi/natsemi.c
index b9a1a9f999ea..04f2d7b88f15 100644
--- a/drivers/net/ethernet/natsemi/natsemi.c
+++ b/drivers/net/ethernet/natsemi/natsemi.c
@@ -612,7 +612,7 @@ static void undo_cable_magic(struct net_device *dev);
 static void check_link(struct net_device *dev);
 static void netdev_timer(struct timer_list *t);
 static void dump_ring(struct net_device *dev);
-static void ns_tx_timeout(struct net_device *dev);
+static void ns_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static int alloc_ring(struct net_device *dev);
 static void refill_rx(struct net_device *dev);
 static void init_ring(struct net_device *dev);
@@ -1881,7 +1881,7 @@ static void dump_ring(struct net_device *dev)
 	}
 }
 
-static void ns_tx_timeout(struct net_device *dev)
+static void ns_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct netdev_private *np = netdev_priv(dev);
 	void __iomem * ioaddr = ns_ioaddr(dev);
diff --git a/drivers/net/ethernet/natsemi/ns83820.c b/drivers/net/ethernet/natsemi/ns83820.c
index 958fced4dacf..c201148bb69c 100644
--- a/drivers/net/ethernet/natsemi/ns83820.c
+++ b/drivers/net/ethernet/natsemi/ns83820.c
@@ -1563,7 +1563,7 @@ static int ns83820_stop(struct net_device *ndev)
 	return 0;
 }
 
-static void ns83820_tx_timeout(struct net_device *ndev)
+static void ns83820_tx_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct ns83820 *dev = PRIV(ndev);
         u32 tx_done_idx;
@@ -1617,7 +1617,7 @@ static void ns83820_tx_watch(struct timer_list *t)
 			ndev->name,
 			dev->tx_done_idx, dev->tx_free_idx,
 			atomic_read(&dev->nr_tx_skbs));
-		ns83820_tx_timeout(ndev);
+		ns83820_tx_timeout(ndev, UINT_MAX);
 	}
 
 	mod_timer(&dev->tx_watchdog, jiffies + 2*HZ);
diff --git a/drivers/net/ethernet/natsemi/sonic.c b/drivers/net/ethernet/natsemi/sonic.c
index c805dcbebd02..d3c98fe9b9b8 100644
--- a/drivers/net/ethernet/natsemi/sonic.c
+++ b/drivers/net/ethernet/natsemi/sonic.c
@@ -160,7 +160,7 @@ static int sonic_close(struct net_device *dev)
 	return 0;
 }
 
-static void sonic_tx_timeout(struct net_device *dev)
+static void sonic_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct sonic_local *lp = netdev_priv(dev);
 	int i;
diff --git a/drivers/net/ethernet/natsemi/sonic.h b/drivers/net/ethernet/natsemi/sonic.h
index 2b27f7049acb..f1544481aac1 100644
--- a/drivers/net/ethernet/natsemi/sonic.h
+++ b/drivers/net/ethernet/natsemi/sonic.h
@@ -336,7 +336,7 @@ static int sonic_close(struct net_device *dev);
 static struct net_device_stats *sonic_get_stats(struct net_device *dev);
 static void sonic_multicast_list(struct net_device *dev);
 static int sonic_init(struct net_device *dev);
-static void sonic_tx_timeout(struct net_device *dev);
+static void sonic_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void sonic_msg_init(struct net_device *dev);
 
 /* Internal inlines for reading/writing DMA buffers.  Note that bus
diff --git a/drivers/net/ethernet/neterion/s2io.c b/drivers/net/ethernet/neterion/s2io.c
index de5144d0c6af..7545eaf07d74 100644
--- a/drivers/net/ethernet/neterion/s2io.c
+++ b/drivers/net/ethernet/neterion/s2io.c
@@ -7240,7 +7240,7 @@ static void s2io_restart_nic(struct work_struct *work)
  *  void
  */
 
-static void s2io_tx_watchdog(struct net_device *dev)
+static void s2io_tx_watchdog(struct net_device *dev, unsigned int txqueue)
 {
 	struct s2io_nic *sp = netdev_priv(dev);
 	struct swStat *swstats = &sp->mac_control.stats_info->sw_stat;
diff --git a/drivers/net/ethernet/neterion/s2io.h b/drivers/net/ethernet/neterion/s2io.h
index 1a24a7218794..b908cbed15d3 100644
--- a/drivers/net/ethernet/neterion/s2io.h
+++ b/drivers/net/ethernet/neterion/s2io.h
@@ -1085,7 +1085,7 @@ static void s2io_txpic_intr_handle(struct s2io_nic *sp);
 static void tx_intr_handler(struct fifo_info *fifo_data);
 static void s2io_handle_errors(void * dev_id);
 
-static void s2io_tx_watchdog(struct net_device *dev);
+static void s2io_tx_watchdog(struct net_device *dev, unsigned int txqueue);
 static void s2io_set_multicast(struct net_device *dev);
 static int rx_osm_handler(struct ring_info *ring_data, struct RxD_t * rxdp);
 static void s2io_link(struct s2io_nic * sp, int link);
diff --git a/drivers/net/ethernet/neterion/vxge/vxge-main.c b/drivers/net/ethernet/neterion/vxge/vxge-main.c
index 0193969bef10..115dc3a9da42 100644
--- a/drivers/net/ethernet/neterion/vxge/vxge-main.c
+++ b/drivers/net/ethernet/neterion/vxge/vxge-main.c
@@ -3273,7 +3273,7 @@ static int vxge_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
  * This function is triggered if the Tx Queue is stopped
  * for a pre-defined amount of time when the Interface is still up.
  */
-static void vxge_tx_watchdog(struct net_device *dev)
+static void vxge_tx_watchdog(struct net_device *dev, unsigned int txqueue)
 {
 	struct vxgedev *vdev;
 
diff --git a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
index 053761bd2ef9..d3981979372d 100644
--- a/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
+++ b/drivers/net/ethernet/netronome/nfp/nfp_net_common.c
@@ -1199,7 +1199,7 @@ nfp_net_tx_ring_reset(struct nfp_net_dp *dp, struct nfp_net_tx_ring *tx_ring)
 	netdev_tx_reset_queue(nd_q);
 }
 
-static void nfp_net_tx_timeout(struct net_device *netdev)
+static void nfp_net_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct nfp_net *nn = netdev_priv(netdev);
 	int i;
diff --git a/drivers/net/ethernet/nvidia/forcedeth.c b/drivers/net/ethernet/nvidia/forcedeth.c
index 7cbd0174459c..6f7dc5e0999b 100644
--- a/drivers/net/ethernet/nvidia/forcedeth.c
+++ b/drivers/net/ethernet/nvidia/forcedeth.c
@@ -2673,7 +2673,7 @@ static int nv_tx_done_optimized(struct net_device *dev, int limit)
  * nv_tx_timeout: dev->tx_timeout function
  * Called with netif_tx_lock held.
  */
-static void nv_tx_timeout(struct net_device *dev)
+static void nv_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct fe_priv *np = netdev_priv(dev);
 	u8 __iomem *base = get_hwbase(dev);
diff --git a/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c b/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c
index 3872e3ba9d0d..7b091837e2fe 100644
--- a/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c
+++ b/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_main.c
@@ -2323,7 +2323,7 @@ static int pch_gbe_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
  * pch_gbe_tx_timeout - Respond to a Tx Hang
  * @netdev:   Network interface device structure
  */
-static void pch_gbe_tx_timeout(struct net_device *netdev)
+static void pch_gbe_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct pch_gbe_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/packetengines/hamachi.c b/drivers/net/ethernet/packetengines/hamachi.c
index c9529c29a0a7..b7940e5ebb3c 100644
--- a/drivers/net/ethernet/packetengines/hamachi.c
+++ b/drivers/net/ethernet/packetengines/hamachi.c
@@ -548,7 +548,7 @@ static void mdio_write(struct net_device *dev, int phy_id, int location, int val
 static int hamachi_open(struct net_device *dev);
 static int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 static void hamachi_timer(struct timer_list *t);
-static void hamachi_tx_timeout(struct net_device *dev);
+static void hamachi_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void hamachi_init_ring(struct net_device *dev);
 static netdev_tx_t hamachi_start_xmit(struct sk_buff *skb,
 				      struct net_device *dev);
@@ -1042,7 +1042,7 @@ static void hamachi_timer(struct timer_list *t)
 	add_timer(&hmp->timer);
 }
 
-static void hamachi_tx_timeout(struct net_device *dev)
+static void hamachi_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	int i;
 	struct hamachi_private *hmp = netdev_priv(dev);
diff --git a/drivers/net/ethernet/packetengines/yellowfin.c b/drivers/net/ethernet/packetengines/yellowfin.c
index 54224d1822e3..f68801152128 100644
--- a/drivers/net/ethernet/packetengines/yellowfin.c
+++ b/drivers/net/ethernet/packetengines/yellowfin.c
@@ -344,7 +344,7 @@ static void mdio_write(void __iomem *ioaddr, int phy_id, int location, int value
 static int netdev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 static int yellowfin_open(struct net_device *dev);
 static void yellowfin_timer(struct timer_list *t);
-static void yellowfin_tx_timeout(struct net_device *dev);
+static void yellowfin_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static int yellowfin_init_ring(struct net_device *dev);
 static netdev_tx_t yellowfin_start_xmit(struct sk_buff *skb,
 					struct net_device *dev);
@@ -677,7 +677,7 @@ static void yellowfin_timer(struct timer_list *t)
 	add_timer(&yp->timer);
 }
 
-static void yellowfin_tx_timeout(struct net_device *dev)
+static void yellowfin_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct yellowfin_private *yp = netdev_priv(dev);
 	void __iomem *ioaddr = yp->base;
* Unmerged path drivers/net/ethernet/pensando/ionic/ionic_lif.c
diff --git a/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c b/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c
index d5b7d45d18d4..d82035f24be2 100644
--- a/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c
+++ b/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c
@@ -65,7 +65,7 @@ static int netxen_nic_open(struct net_device *netdev);
 static int netxen_nic_close(struct net_device *netdev);
 static netdev_tx_t netxen_nic_xmit_frame(struct sk_buff *,
 					       struct net_device *);
-static void netxen_tx_timeout(struct net_device *netdev);
+static void netxen_tx_timeout(struct net_device *netdev, unsigned int txqueue);
 static void netxen_tx_timeout_task(struct work_struct *work);
 static void netxen_fw_poll_work(struct work_struct *work);
 static void netxen_schedule_work(struct netxen_adapter *adapter,
@@ -2246,7 +2246,7 @@ static void netxen_nic_handle_phy_intr(struct netxen_adapter *adapter)
 	netxen_advert_link_change(adapter, linkup);
 }
 
-static void netxen_tx_timeout(struct net_device *netdev)
+static void netxen_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct netxen_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/qlogic/qla3xxx.c b/drivers/net/ethernet/qlogic/qla3xxx.c
index c9df3485941e..79b6c48434f3 100644
--- a/drivers/net/ethernet/qlogic/qla3xxx.c
+++ b/drivers/net/ethernet/qlogic/qla3xxx.c
@@ -3603,7 +3603,7 @@ static int ql3xxx_set_mac_address(struct net_device *ndev, void *p)
 	return 0;
 }
 
-static void ql3xxx_tx_timeout(struct net_device *ndev)
+static void ql3xxx_tx_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct ql3_adapter *qdev = netdev_priv(ndev);
 
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index 885283dcc023..d1f9b6a5d505 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@ -56,7 +56,7 @@ static int qlcnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent);
 static void qlcnic_remove(struct pci_dev *pdev);
 static int qlcnic_open(struct net_device *netdev);
 static int qlcnic_close(struct net_device *netdev);
-static void qlcnic_tx_timeout(struct net_device *netdev);
+static void qlcnic_tx_timeout(struct net_device *netdev, unsigned int txqueue);
 static void qlcnic_attach_work(struct work_struct *work);
 static void qlcnic_fwinit_work(struct work_struct *work);
 #ifdef CONFIG_NET_POLL_CONTROLLER
@@ -3076,7 +3076,7 @@ static void qlcnic_dump_rings(struct qlcnic_adapter *adapter)
 
 }
 
-static void qlcnic_tx_timeout(struct net_device *netdev)
+static void qlcnic_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct qlcnic_adapter *adapter = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/qlogic/qlge/qlge_main.c b/drivers/net/ethernet/qlogic/qlge/qlge_main.c
index 8758f134eaac..4af9126ab928 100644
--- a/drivers/net/ethernet/qlogic/qlge/qlge_main.c
+++ b/drivers/net/ethernet/qlogic/qlge/qlge_main.c
@@ -4442,7 +4442,7 @@ static int qlge_set_mac_address(struct net_device *ndev, void *p)
 	return status;
 }
 
-static void qlge_tx_timeout(struct net_device *ndev)
+static void qlge_tx_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct ql_adapter *qdev = netdev_priv(ndev);
 	ql_queue_asic_error(qdev);
diff --git a/drivers/net/ethernet/qualcomm/emac/emac.c b/drivers/net/ethernet/qualcomm/emac/emac.c
index 2a0cbc535a2e..36f4564d0b72 100644
--- a/drivers/net/ethernet/qualcomm/emac/emac.c
+++ b/drivers/net/ethernet/qualcomm/emac/emac.c
@@ -290,7 +290,7 @@ static int emac_close(struct net_device *netdev)
 }
 
 /* Respond to a TX hang */
-static void emac_tx_timeout(struct net_device *netdev)
+static void emac_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct emac_adapter *adpt = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/qualcomm/qca_spi.c b/drivers/net/ethernet/qualcomm/qca_spi.c
index 206f0266463e..3a210be357a9 100644
--- a/drivers/net/ethernet/qualcomm/qca_spi.c
+++ b/drivers/net/ethernet/qualcomm/qca_spi.c
@@ -751,7 +751,7 @@ qcaspi_netdev_xmit(struct sk_buff *skb, struct net_device *dev)
 }
 
 static void
-qcaspi_netdev_tx_timeout(struct net_device *dev)
+qcaspi_netdev_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct qcaspi *qca = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/qualcomm/qca_uart.c b/drivers/net/ethernet/qualcomm/qca_uart.c
index db6068cd7a1f..9d60b90939e6 100644
--- a/drivers/net/ethernet/qualcomm/qca_uart.c
+++ b/drivers/net/ethernet/qualcomm/qca_uart.c
@@ -248,7 +248,7 @@ qcauart_netdev_xmit(struct sk_buff *skb, struct net_device *dev)
 	return NETDEV_TX_OK;
 }
 
-static void qcauart_netdev_tx_timeout(struct net_device *dev)
+static void qcauart_netdev_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct qcauart *qca = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/rdc/r6040.c b/drivers/net/ethernet/rdc/r6040.c
index ad335bca3273..25b4c8152b43 100644
--- a/drivers/net/ethernet/rdc/r6040.c
+++ b/drivers/net/ethernet/rdc/r6040.c
@@ -424,7 +424,7 @@ static void r6040_init_mac_regs(struct net_device *dev)
 	iowrite16(TM2TX, ioaddr + MTPR);
 }
 
-static void r6040_tx_timeout(struct net_device *dev)
+static void r6040_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct r6040_private *priv = netdev_priv(dev);
 	void __iomem *ioaddr = priv->base;
diff --git a/drivers/net/ethernet/realtek/8139cp.c b/drivers/net/ethernet/realtek/8139cp.c
index 81045dfa1cd8..76255c26afe6 100644
--- a/drivers/net/ethernet/realtek/8139cp.c
+++ b/drivers/net/ethernet/realtek/8139cp.c
@@ -1230,7 +1230,7 @@ static int cp_close (struct net_device *dev)
 	return 0;
 }
 
-static void cp_tx_timeout(struct net_device *dev)
+static void cp_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct cp_private *cp = netdev_priv(dev);
 	unsigned long flags;
diff --git a/drivers/net/ethernet/realtek/8139too.c b/drivers/net/ethernet/realtek/8139too.c
index 69d752f0b621..a481c12b8ce8 100644
--- a/drivers/net/ethernet/realtek/8139too.c
+++ b/drivers/net/ethernet/realtek/8139too.c
@@ -641,7 +641,7 @@ static int mdio_read (struct net_device *dev, int phy_id, int location);
 static void mdio_write (struct net_device *dev, int phy_id, int location,
 			int val);
 static void rtl8139_start_thread(struct rtl8139_private *tp);
-static void rtl8139_tx_timeout (struct net_device *dev);
+static void rtl8139_tx_timeout (struct net_device *dev, unsigned int txqueue);
 static void rtl8139_init_ring (struct net_device *dev);
 static netdev_tx_t rtl8139_start_xmit (struct sk_buff *skb,
 				       struct net_device *dev);
@@ -1699,7 +1699,7 @@ static void rtl8139_tx_timeout_task (struct work_struct *work)
 	spin_unlock_bh(&tp->rx_lock);
 }
 
-static void rtl8139_tx_timeout (struct net_device *dev)
+static void rtl8139_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct rtl8139_private *tp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/realtek/atp.c b/drivers/net/ethernet/realtek/atp.c
index 7e011c1c1e6e..89e88b03c784 100644
--- a/drivers/net/ethernet/realtek/atp.c
+++ b/drivers/net/ethernet/realtek/atp.c
@@ -204,7 +204,7 @@ static void net_rx(struct net_device *dev);
 static void read_block(long ioaddr, int length, unsigned char *buffer, int data_mode);
 static int net_close(struct net_device *dev);
 static void set_rx_mode(struct net_device *dev);
-static void tx_timeout(struct net_device *dev);
+static void tx_timeout(struct net_device *dev, unsigned int txqueue);
 
 
 /* A list of all installed ATP devices, for removing the driver module. */
@@ -533,7 +533,7 @@ static void write_packet(long ioaddr, int length, unsigned char *packet, int pad
     outb(Ctrl_HNibWrite | Ctrl_SelData | Ctrl_IRQEN, ioaddr + PAR_CONTROL);
 }
 
-static void tx_timeout(struct net_device *dev)
+static void tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	long ioaddr = dev->base_addr;
 
diff --git a/drivers/net/ethernet/realtek/r8169_main.c b/drivers/net/ethernet/realtek/r8169_main.c
index 1cc1b20b20cd..5deccb9361a3 100644
--- a/drivers/net/ethernet/realtek/r8169_main.c
+++ b/drivers/net/ethernet/realtek/r8169_main.c
@@ -5412,7 +5412,7 @@ static void rtl_reset_work(struct rtl8169_private *tp)
 	netif_wake_queue(dev);
 }
 
-static void rtl8169_tx_timeout(struct net_device *dev)
+static void rtl8169_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct rtl8169_private *tp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/renesas/ravb_main.c b/drivers/net/ethernet/renesas/ravb_main.c
index 11bd741c2b65..2763ef5c80b3 100644
--- a/drivers/net/ethernet/renesas/ravb_main.c
+++ b/drivers/net/ethernet/renesas/ravb_main.c
@@ -1436,7 +1436,7 @@ static int ravb_open(struct net_device *ndev)
 }
 
 /* Timeout function for Ethernet AVB */
-static void ravb_tx_timeout(struct net_device *ndev)
+static void ravb_tx_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct ravb_private *priv = netdev_priv(ndev);
 
diff --git a/drivers/net/ethernet/renesas/sh_eth.c b/drivers/net/ethernet/renesas/sh_eth.c
index 6b25e158ee72..d3bb8450ca29 100644
--- a/drivers/net/ethernet/renesas/sh_eth.c
+++ b/drivers/net/ethernet/renesas/sh_eth.c
@@ -2430,7 +2430,7 @@ static int sh_eth_open(struct net_device *ndev)
 }
 
 /* Timeout function */
-static void sh_eth_tx_timeout(struct net_device *ndev)
+static void sh_eth_tx_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct sh_eth_private *mdp = netdev_priv(ndev);
 	struct sh_eth_rxdesc *rxdesc;
diff --git a/drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c b/drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c
index 690aee88f0eb..340a334207f5 100644
--- a/drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c
+++ b/drivers/net/ethernet/samsung/sxgbe/sxgbe_main.c
@@ -1575,7 +1575,7 @@ static int sxgbe_poll(struct napi_struct *napi, int budget)
  *   netdev structure and arrange for the device to be reset to a sane state
  *   in order to transmit a new packet.
  */
-static void sxgbe_tx_timeout(struct net_device *dev)
+static void sxgbe_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct sxgbe_priv_data *priv = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/seeq/ether3.c b/drivers/net/ethernet/seeq/ether3.c
index c5bc124b41a9..4a83796e40e0 100644
--- a/drivers/net/ethernet/seeq/ether3.c
+++ b/drivers/net/ethernet/seeq/ether3.c
@@ -81,7 +81,7 @@ static int	ether3_sendpacket (struct sk_buff *skb, struct net_device *dev);
 static irqreturn_t ether3_interrupt (int irq, void *dev_id);
 static int	ether3_close (struct net_device *dev);
 static void	ether3_setmulticastlist (struct net_device *dev);
-static void	ether3_timeout(struct net_device *dev);
+static void	ether3_timeout(struct net_device *dev, unsigned int txqueue);
 
 #define BUS_16		2
 #define BUS_8		1
@@ -452,7 +452,7 @@ static void ether3_setmulticastlist(struct net_device *dev)
 	ether3_outw(priv(dev)->regs.config1 | CFG1_LOCBUFMEM, REG_CONFIG1);
 }
 
-static void ether3_timeout(struct net_device *dev)
+static void ether3_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	unsigned long flags;
 
diff --git a/drivers/net/ethernet/seeq/sgiseeq.c b/drivers/net/ethernet/seeq/sgiseeq.c
index 573691bc3b71..af4f50dbabcb 100644
--- a/drivers/net/ethernet/seeq/sgiseeq.c
+++ b/drivers/net/ethernet/seeq/sgiseeq.c
@@ -643,7 +643,7 @@ static int sgiseeq_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	return NETDEV_TX_OK;
 }
 
-static void timeout(struct net_device *dev)
+static void timeout(struct net_device *dev, unsigned int txqueue)
 {
 	printk(KERN_NOTICE "%s: transmit timed out, resetting\n", dev->name);
 	sgiseeq_reset(dev);
diff --git a/drivers/net/ethernet/sfc/efx.c b/drivers/net/ethernet/sfc/efx.c
index 0633876573df..256807c28ff7 100644
--- a/drivers/net/ethernet/sfc/efx.c
+++ b/drivers/net/ethernet/sfc/efx.c
@@ -618,7 +618,7 @@ int efx_net_stop(struct net_device *net_dev)
 }
 
 /* Context: netif_tx_lock held, BHs disabled. */
-static void efx_watchdog(struct net_device *net_dev)
+static void efx_watchdog(struct net_device *net_dev, unsigned int txqueue)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 
diff --git a/drivers/net/ethernet/sfc/falcon/efx.c b/drivers/net/ethernet/sfc/falcon/efx.c
index ad9fb38b9934..9b3e9c077611 100644
--- a/drivers/net/ethernet/sfc/falcon/efx.c
+++ b/drivers/net/ethernet/sfc/falcon/efx.c
@@ -2131,7 +2131,7 @@ static void ef4_net_stats(struct net_device *net_dev,
 }
 
 /* Context: netif_tx_lock held, BHs disabled. */
-static void ef4_watchdog(struct net_device *net_dev)
+static void ef4_watchdog(struct net_device *net_dev, unsigned int txqueue)
 {
 	struct ef4_nic *efx = netdev_priv(net_dev);
 
* Unmerged path drivers/net/ethernet/sgi/ioc3-eth.c
diff --git a/drivers/net/ethernet/sgi/meth.c b/drivers/net/ethernet/sgi/meth.c
index ea55abd62ec7..3e39b90d01e9 100644
--- a/drivers/net/ethernet/sgi/meth.c
+++ b/drivers/net/ethernet/sgi/meth.c
@@ -92,7 +92,7 @@ struct meth_private {
 	spinlock_t meth_lock;
 };
 
-static void meth_tx_timeout(struct net_device *dev);
+static void meth_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static irqreturn_t meth_interrupt(int irq, void *dev_id);
 
 /* global, initialized in ip32-setup.c */
@@ -728,7 +728,7 @@ static int meth_tx(struct sk_buff *skb, struct net_device *dev)
 /*
  * Deal with a transmit timeout.
  */
-static void meth_tx_timeout(struct net_device *dev)
+static void meth_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct meth_private *priv = netdev_priv(dev);
 	unsigned long flags;
diff --git a/drivers/net/ethernet/silan/sc92031.c b/drivers/net/ethernet/silan/sc92031.c
index 02b3962b0e63..489c58d21ea6 100644
--- a/drivers/net/ethernet/silan/sc92031.c
+++ b/drivers/net/ethernet/silan/sc92031.c
@@ -1077,7 +1077,7 @@ static void sc92031_set_multicast_list(struct net_device *dev)
 	spin_unlock_bh(&priv->lock);
 }
 
-static void sc92031_tx_timeout(struct net_device *dev)
+static void sc92031_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct sc92031_priv *priv = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/sis/sis190.c b/drivers/net/ethernet/sis/sis190.c
index 808cf9816673..a0ee171e23df 100644
--- a/drivers/net/ethernet/sis/sis190.c
+++ b/drivers/net/ethernet/sis/sis190.c
@@ -1538,7 +1538,7 @@ static struct net_device *sis190_init_board(struct pci_dev *pdev)
 	goto out;
 }
 
-static void sis190_tx_timeout(struct net_device *dev)
+static void sis190_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct sis190_private *tp = netdev_priv(dev);
 	void __iomem *ioaddr = tp->mmio_addr;
diff --git a/drivers/net/ethernet/sis/sis900.c b/drivers/net/ethernet/sis/sis900.c
index 4bb89f74742c..c50a8834f80e 100644
--- a/drivers/net/ethernet/sis/sis900.c
+++ b/drivers/net/ethernet/sis/sis900.c
@@ -220,7 +220,7 @@ static int mdio_read(struct net_device *net_dev, int phy_id, int location);
 static void mdio_write(struct net_device *net_dev, int phy_id, int location, int val);
 static void sis900_timer(struct timer_list *t);
 static void sis900_check_mode (struct net_device *net_dev, struct mii_phy *mii_phy);
-static void sis900_tx_timeout(struct net_device *net_dev);
+static void sis900_tx_timeout(struct net_device *net_dev, unsigned int txqueue);
 static void sis900_init_tx_ring(struct net_device *net_dev);
 static void sis900_init_rx_ring(struct net_device *net_dev);
 static netdev_tx_t sis900_start_xmit(struct sk_buff *skb,
@@ -1533,7 +1533,7 @@ static void sis900_read_mode(struct net_device *net_dev, int *speed, int *duplex
  *	disable interrupts and do some tasks
  */
 
-static void sis900_tx_timeout(struct net_device *net_dev)
+static void sis900_tx_timeout(struct net_device *net_dev, unsigned int txqueue)
 {
 	struct sis900_private *sis_priv = netdev_priv(net_dev);
 	void __iomem *ioaddr = sis_priv->ioaddr;
diff --git a/drivers/net/ethernet/smsc/epic100.c b/drivers/net/ethernet/smsc/epic100.c
index 949aaef390b6..4a570f8f2b1e 100644
--- a/drivers/net/ethernet/smsc/epic100.c
+++ b/drivers/net/ethernet/smsc/epic100.c
@@ -291,7 +291,7 @@ static int mdio_read(struct net_device *dev, int phy_id, int location);
 static void mdio_write(struct net_device *dev, int phy_id, int loc, int val);
 static void epic_restart(struct net_device *dev);
 static void epic_timer(struct timer_list *t);
-static void epic_tx_timeout(struct net_device *dev);
+static void epic_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void epic_init_ring(struct net_device *dev);
 static netdev_tx_t epic_start_xmit(struct sk_buff *skb,
 				   struct net_device *dev);
@@ -863,7 +863,7 @@ static void epic_timer(struct timer_list *t)
 	add_timer(&ep->timer);
 }
 
-static void epic_tx_timeout(struct net_device *dev)
+static void epic_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct epic_private *ep = netdev_priv(dev);
 	void __iomem *ioaddr = ep->ioaddr;
diff --git a/drivers/net/ethernet/smsc/smc911x.c b/drivers/net/ethernet/smsc/smc911x.c
index 05157442a980..1e178d16d010 100644
--- a/drivers/net/ethernet/smsc/smc911x.c
+++ b/drivers/net/ethernet/smsc/smc911x.c
@@ -1256,7 +1256,7 @@ static void smc911x_poll_controller(struct net_device *dev)
 #endif
 
 /* Our watchdog timed out. Called by the networking layer */
-static void smc911x_timeout(struct net_device *dev)
+static void smc911x_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct smc911x_local *lp = netdev_priv(dev);
 	int status, mask;
diff --git a/drivers/net/ethernet/smsc/smc9194.c b/drivers/net/ethernet/smsc/smc9194.c
index d3bb2ba51f40..4b2330deed47 100644
--- a/drivers/net/ethernet/smsc/smc9194.c
+++ b/drivers/net/ethernet/smsc/smc9194.c
@@ -216,7 +216,7 @@ static int smc_open(struct net_device *dev);
 /*
  . Our watchdog timed out. Called by the networking layer
 */
-static void smc_timeout(struct net_device *dev);
+static void smc_timeout(struct net_device *dev, unsigned int txqueue);
 
 /*
  . This is called by the kernel in response to 'ifconfig ethX down'.  It
@@ -1094,7 +1094,7 @@ static int smc_open(struct net_device *dev)
  .--------------------------------------------------------
 */
 
-static void smc_timeout(struct net_device *dev)
+static void smc_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	/* If we get here, some higher level has decided we are broken.
 	   There should really be a "kick me" function call instead. */
diff --git a/drivers/net/ethernet/smsc/smc91c92_cs.c b/drivers/net/ethernet/smsc/smc91c92_cs.c
index a55f430f6a7b..f2a50eb3c1e0 100644
--- a/drivers/net/ethernet/smsc/smc91c92_cs.c
+++ b/drivers/net/ethernet/smsc/smc91c92_cs.c
@@ -271,7 +271,7 @@ static void smc91c92_release(struct pcmcia_device *link);
 static int smc_open(struct net_device *dev);
 static int smc_close(struct net_device *dev);
 static int smc_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
-static void smc_tx_timeout(struct net_device *dev);
+static void smc_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static netdev_tx_t smc_start_xmit(struct sk_buff *skb,
 					struct net_device *dev);
 static irqreturn_t smc_interrupt(int irq, void *dev_id);
@@ -1178,7 +1178,7 @@ static void smc_hardware_send_packet(struct net_device * dev)
 
 /*====================================================================*/
 
-static void smc_tx_timeout(struct net_device *dev)
+static void smc_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
     struct smc_private *smc = netdev_priv(dev);
     unsigned int ioaddr = dev->base_addr;
diff --git a/drivers/net/ethernet/smsc/smc91x.c b/drivers/net/ethernet/smsc/smc91x.c
index 080428762858..73197f4bac07 100644
--- a/drivers/net/ethernet/smsc/smc91x.c
+++ b/drivers/net/ethernet/smsc/smc91x.c
@@ -1333,7 +1333,7 @@ static void smc_poll_controller(struct net_device *dev)
 #endif
 
 /* Our watchdog timed out. Called by the networking layer */
-static void smc_timeout(struct net_device *dev)
+static void smc_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct smc_local *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 20365ad53956..d5fa32fe835c 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -3528,7 +3528,7 @@ static int stmmac_poll(struct napi_struct *napi, int budget)
  *   netdev structure and arrange for the device to be reset to a sane state
  *   in order to transmit a new packet.
  */
-static void stmmac_tx_timeout(struct net_device *dev)
+static void stmmac_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct stmmac_priv *priv = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/sun/cassini.c b/drivers/net/ethernet/sun/cassini.c
index 9020b084b953..ef5ea865fc96 100644
--- a/drivers/net/ethernet/sun/cassini.c
+++ b/drivers/net/ethernet/sun/cassini.c
@@ -2679,7 +2679,7 @@ static void cas_netpoll(struct net_device *dev)
 }
 #endif
 
-static void cas_tx_timeout(struct net_device *dev)
+static void cas_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct cas *cp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/sun/niu.c b/drivers/net/ethernet/sun/niu.c
index 88c12474a0c3..120a932ae896 100644
--- a/drivers/net/ethernet/sun/niu.c
+++ b/drivers/net/ethernet/sun/niu.c
@@ -6535,7 +6535,7 @@ static void niu_reset_task(struct work_struct *work)
 	spin_unlock_irqrestore(&np->lock, flags);
 }
 
-static void niu_tx_timeout(struct net_device *dev)
+static void niu_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct niu *np = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/sun/sunbmac.c b/drivers/net/ethernet/sun/sunbmac.c
index f047b2797156..e504c0df0b83 100644
--- a/drivers/net/ethernet/sun/sunbmac.c
+++ b/drivers/net/ethernet/sun/sunbmac.c
@@ -941,7 +941,7 @@ static int bigmac_close(struct net_device *dev)
 	return 0;
 }
 
-static void bigmac_tx_timeout(struct net_device *dev)
+static void bigmac_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct bigmac *bp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/sun/sungem.c b/drivers/net/ethernet/sun/sungem.c
index b9221fc1674d..be0f868a619b 100644
--- a/drivers/net/ethernet/sun/sungem.c
+++ b/drivers/net/ethernet/sun/sungem.c
@@ -970,7 +970,7 @@ static void gem_poll_controller(struct net_device *dev)
 }
 #endif
 
-static void gem_tx_timeout(struct net_device *dev)
+static void gem_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct gem *gp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/sun/sunhme.c b/drivers/net/ethernet/sun/sunhme.c
index 06da2f59fcbf..af6f82f5ce6e 100644
--- a/drivers/net/ethernet/sun/sunhme.c
+++ b/drivers/net/ethernet/sun/sunhme.c
@@ -2246,7 +2246,7 @@ static int happy_meal_close(struct net_device *dev)
 #define SXD(x)
 #endif
 
-static void happy_meal_tx_timeout(struct net_device *dev)
+static void happy_meal_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct happy_meal *hp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/sun/sunqe.c b/drivers/net/ethernet/sun/sunqe.c
index 7fe0d5e33922..d39a0de7aca0 100644
--- a/drivers/net/ethernet/sun/sunqe.c
+++ b/drivers/net/ethernet/sun/sunqe.c
@@ -544,7 +544,7 @@ static void qe_tx_reclaim(struct sunqe *qep)
 	qep->tx_old = elem;
 }
 
-static void qe_tx_timeout(struct net_device *dev)
+static void qe_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct sunqe *qep = netdev_priv(dev);
 	int tx_full;
diff --git a/drivers/net/ethernet/sun/sunvnet_common.c b/drivers/net/ethernet/sun/sunvnet_common.c
index d8f4c3f28150..37eee3f0b2c7 100644
--- a/drivers/net/ethernet/sun/sunvnet_common.c
+++ b/drivers/net/ethernet/sun/sunvnet_common.c
@@ -1538,7 +1538,7 @@ int sunvnet_start_xmit_common(struct sk_buff *skb, struct net_device *dev,
 }
 EXPORT_SYMBOL_GPL(sunvnet_start_xmit_common);
 
-void sunvnet_tx_timeout_common(struct net_device *dev)
+void sunvnet_tx_timeout_common(struct net_device *dev, unsigned int txqueue)
 {
 	/* XXX Implement me XXX */
 }
* Unmerged path drivers/net/ethernet/sun/sunvnet_common.h
diff --git a/drivers/net/ethernet/synopsys/dwc-xlgmac-net.c b/drivers/net/ethernet/synopsys/dwc-xlgmac-net.c
index 1f8e9601592a..4391efad5cba 100644
--- a/drivers/net/ethernet/synopsys/dwc-xlgmac-net.c
+++ b/drivers/net/ethernet/synopsys/dwc-xlgmac-net.c
@@ -689,7 +689,7 @@ static int xlgmac_close(struct net_device *netdev)
 	return 0;
 }
 
-static void xlgmac_tx_timeout(struct net_device *netdev)
+static void xlgmac_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct xlgmac_pdata *pdata = netdev_priv(netdev);
 
diff --git a/drivers/net/ethernet/ti/cpmac.c b/drivers/net/ethernet/ti/cpmac.c
index 9b8a30bf939b..a6b785730ede 100644
--- a/drivers/net/ethernet/ti/cpmac.c
+++ b/drivers/net/ethernet/ti/cpmac.c
@@ -809,7 +809,7 @@ static irqreturn_t cpmac_irq(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static void cpmac_tx_timeout(struct net_device *dev)
+static void cpmac_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct cpmac_priv *priv = netdev_priv(dev);
 
* Unmerged path drivers/net/ethernet/ti/cpsw_priv.c
* Unmerged path drivers/net/ethernet/ti/cpsw_priv.h
diff --git a/drivers/net/ethernet/ti/davinci_emac.c b/drivers/net/ethernet/ti/davinci_emac.c
index 61e0f8c6be5f..aaafbc73988b 100644
--- a/drivers/net/ethernet/ti/davinci_emac.c
+++ b/drivers/net/ethernet/ti/davinci_emac.c
@@ -997,7 +997,7 @@ static int emac_dev_xmit(struct sk_buff *skb, struct net_device *ndev)
  * error and re-initialize the TX channel for hardware operation
  *
  */
-static void emac_dev_tx_timeout(struct net_device *ndev)
+static void emac_dev_tx_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct emac_priv *priv = netdev_priv(ndev);
 	struct device *emac_dev = &ndev->dev;
diff --git a/drivers/net/ethernet/ti/netcp_core.c b/drivers/net/ethernet/ti/netcp_core.c
index 2c455bdd6cae..10d9b08ed584 100644
--- a/drivers/net/ethernet/ti/netcp_core.c
+++ b/drivers/net/ethernet/ti/netcp_core.c
@@ -1825,7 +1825,7 @@ static int netcp_ndo_ioctl(struct net_device *ndev,
 	return (ret == 0) ? 0 : err;
 }
 
-static void netcp_ndo_tx_timeout(struct net_device *ndev)
+static void netcp_ndo_tx_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct netcp_intf *netcp = netdev_priv(ndev);
 	unsigned int descs = knav_pool_count(netcp->tx_pool);
diff --git a/drivers/net/ethernet/ti/tlan.c b/drivers/net/ethernet/ti/tlan.c
index c769cd9d11e7..fd2dba0e1792 100644
--- a/drivers/net/ethernet/ti/tlan.c
+++ b/drivers/net/ethernet/ti/tlan.c
@@ -159,7 +159,7 @@ static void	tlan_set_multicast_list(struct net_device *);
 static int	tlan_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 static int      tlan_probe1(struct pci_dev *pdev, long ioaddr,
 			    int irq, int rev, const struct pci_device_id *ent);
-static void	tlan_tx_timeout(struct net_device *dev);
+static void	tlan_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void	tlan_tx_timeout_work(struct work_struct *work);
 static int	tlan_init_one(struct pci_dev *pdev,
 			      const struct pci_device_id *ent);
@@ -995,7 +995,7 @@ static int tlan_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
  *
  **************************************************************/
 
-static void tlan_tx_timeout(struct net_device *dev)
+static void tlan_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 
 	TLAN_DBG(TLAN_DEBUG_GNRL, "%s: Transmit timed out.\n", dev->name);
@@ -1026,7 +1026,7 @@ static void tlan_tx_timeout_work(struct work_struct *work)
 	struct tlan_priv	*priv =
 		container_of(work, struct tlan_priv, tlan_tqueue);
 
-	tlan_tx_timeout(priv->dev);
+	tlan_tx_timeout(priv->dev, UINT_MAX);
 }
 
 
diff --git a/drivers/net/ethernet/toshiba/ps3_gelic_net.c b/drivers/net/ethernet/toshiba/ps3_gelic_net.c
index 88d74aef218a..4b624357467b 100644
--- a/drivers/net/ethernet/toshiba/ps3_gelic_net.c
+++ b/drivers/net/ethernet/toshiba/ps3_gelic_net.c
@@ -1418,7 +1418,7 @@ static void gelic_net_tx_timeout_task(struct work_struct *work)
  *
  * called, if tx hangs. Schedules a task that resets the interface
  */
-void gelic_net_tx_timeout(struct net_device *netdev)
+void gelic_net_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct gelic_card *card;
 
diff --git a/drivers/net/ethernet/toshiba/ps3_gelic_net.h b/drivers/net/ethernet/toshiba/ps3_gelic_net.h
index 003d0452d9cb..0da239f11633 100644
--- a/drivers/net/ethernet/toshiba/ps3_gelic_net.h
+++ b/drivers/net/ethernet/toshiba/ps3_gelic_net.h
@@ -372,7 +372,7 @@ int gelic_net_open(struct net_device *netdev);
 int gelic_net_stop(struct net_device *netdev);
 int gelic_net_xmit(struct sk_buff *skb, struct net_device *netdev);
 void gelic_net_set_multi(struct net_device *netdev);
-void gelic_net_tx_timeout(struct net_device *netdev);
+void gelic_net_tx_timeout(struct net_device *netdev, unsigned int txqueue);
 int gelic_net_setup_netdev(struct net_device *netdev, struct gelic_card *card);
 
 /* shared ethtool ops */
diff --git a/drivers/net/ethernet/toshiba/spider_net.c b/drivers/net/ethernet/toshiba/spider_net.c
index d925b8203996..36649bea232e 100644
--- a/drivers/net/ethernet/toshiba/spider_net.c
+++ b/drivers/net/ethernet/toshiba/spider_net.c
@@ -2192,7 +2192,7 @@ spider_net_tx_timeout_task(struct work_struct *work)
  * called, if tx hangs. Schedules a task that resets the interface
  */
 static void
-spider_net_tx_timeout(struct net_device *netdev)
+spider_net_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct spider_net_card *card;
 
diff --git a/drivers/net/ethernet/toshiba/tc35815.c b/drivers/net/ethernet/toshiba/tc35815.c
index 4efdae5ba483..b802ba8746ae 100644
--- a/drivers/net/ethernet/toshiba/tc35815.c
+++ b/drivers/net/ethernet/toshiba/tc35815.c
@@ -482,7 +482,7 @@ static void	tc35815_txdone(struct net_device *dev);
 static int	tc35815_close(struct net_device *dev);
 static struct	net_device_stats *tc35815_get_stats(struct net_device *dev);
 static void	tc35815_set_multicast_list(struct net_device *dev);
-static void	tc35815_tx_timeout(struct net_device *dev);
+static void	tc35815_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static int	tc35815_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 #ifdef CONFIG_NET_POLL_CONTROLLER
 static void	tc35815_poll_controller(struct net_device *dev);
@@ -1188,7 +1188,7 @@ static void tc35815_schedule_restart(struct net_device *dev)
 	spin_unlock_irqrestore(&lp->lock, flags);
 }
 
-static void tc35815_tx_timeout(struct net_device *dev)
+static void tc35815_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct tc35815_regs __iomem *tr =
 		(struct tc35815_regs __iomem *)dev->base_addr;
diff --git a/drivers/net/ethernet/via/via-rhine.c b/drivers/net/ethernet/via/via-rhine.c
index ab55416a10fa..7fe6d9ebf3af 100644
--- a/drivers/net/ethernet/via/via-rhine.c
+++ b/drivers/net/ethernet/via/via-rhine.c
@@ -506,7 +506,7 @@ static void mdio_write(struct net_device *dev, int phy_id, int location, int val
 static int  rhine_open(struct net_device *dev);
 static void rhine_reset_task(struct work_struct *work);
 static void rhine_slow_event_task(struct work_struct *work);
-static void rhine_tx_timeout(struct net_device *dev);
+static void rhine_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static netdev_tx_t rhine_start_tx(struct sk_buff *skb,
 				  struct net_device *dev);
 static irqreturn_t rhine_interrupt(int irq, void *dev_instance);
@@ -1763,7 +1763,7 @@ static void rhine_reset_task(struct work_struct *work)
 	mutex_unlock(&rp->task_lock);
 }
 
-static void rhine_tx_timeout(struct net_device *dev)
+static void rhine_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct rhine_private *rp = netdev_priv(dev);
 	void __iomem *ioaddr = rp->base;
diff --git a/drivers/net/ethernet/wiznet/w5100.c b/drivers/net/ethernet/wiznet/w5100.c
index 2459419ef2eb..ca2d4c1abe1e 100644
--- a/drivers/net/ethernet/wiznet/w5100.c
+++ b/drivers/net/ethernet/wiznet/w5100.c
@@ -791,7 +791,7 @@ static void w5100_restart_work(struct work_struct *work)
 	w5100_restart(priv->ndev);
 }
 
-static void w5100_tx_timeout(struct net_device *ndev)
+static void w5100_tx_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct w5100_priv *priv = netdev_priv(ndev);
 
diff --git a/drivers/net/ethernet/wiznet/w5300.c b/drivers/net/ethernet/wiznet/w5300.c
index c3c60c85c91b..0d13299cc2c8 100644
--- a/drivers/net/ethernet/wiznet/w5300.c
+++ b/drivers/net/ethernet/wiznet/w5300.c
@@ -342,7 +342,7 @@ static void w5300_get_regs(struct net_device *ndev,
 	}
 }
 
-static void w5300_tx_timeout(struct net_device *ndev)
+static void w5300_tx_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct w5300_priv *priv = netdev_priv(ndev);
 
diff --git a/drivers/net/ethernet/xilinx/xilinx_emaclite.c b/drivers/net/ethernet/xilinx/xilinx_emaclite.c
index 3721c0f1ef69..b1700225a984 100644
--- a/drivers/net/ethernet/xilinx/xilinx_emaclite.c
+++ b/drivers/net/ethernet/xilinx/xilinx_emaclite.c
@@ -515,7 +515,7 @@ static int xemaclite_set_mac_address(struct net_device *dev, void *address)
  *
  * This function is called when Tx time out occurs for Emaclite device.
  */
-static void xemaclite_tx_timeout(struct net_device *dev)
+static void xemaclite_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct net_local *lp = netdev_priv(dev);
 	unsigned long flags;
diff --git a/drivers/net/ethernet/xircom/xirc2ps_cs.c b/drivers/net/ethernet/xircom/xirc2ps_cs.c
index fd5288ff53b5..480ab7251515 100644
--- a/drivers/net/ethernet/xircom/xirc2ps_cs.c
+++ b/drivers/net/ethernet/xircom/xirc2ps_cs.c
@@ -288,7 +288,7 @@ struct local_info {
  */
 static netdev_tx_t do_start_xmit(struct sk_buff *skb,
 				       struct net_device *dev);
-static void xirc_tx_timeout(struct net_device *dev);
+static void xirc_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static void xirc2ps_tx_timeout_task(struct work_struct *work);
 static void set_addresses(struct net_device *dev);
 static void set_multicast_list(struct net_device *dev);
@@ -1203,7 +1203,7 @@ xirc2ps_tx_timeout_task(struct work_struct *work)
 }
 
 static void
-xirc_tx_timeout(struct net_device *dev)
+xirc_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
     struct local_info *lp = netdev_priv(dev);
     dev->stats.tx_errors++;
diff --git a/drivers/net/fjes/fjes_main.c b/drivers/net/fjes/fjes_main.c
index 750954be5a74..4675bae595be 100644
--- a/drivers/net/fjes/fjes_main.c
+++ b/drivers/net/fjes/fjes_main.c
@@ -63,7 +63,7 @@ static void fjes_get_stats64(struct net_device *, struct rtnl_link_stats64 *);
 static int fjes_change_mtu(struct net_device *, int);
 static int fjes_vlan_rx_add_vid(struct net_device *, __be16 proto, u16);
 static int fjes_vlan_rx_kill_vid(struct net_device *, __be16 proto, u16);
-static void fjes_tx_retry(struct net_device *);
+static void fjes_tx_retry(struct net_device *, unsigned int txqueue);
 
 static int fjes_acpi_add(struct acpi_device *);
 static int fjes_acpi_remove(struct acpi_device *);
@@ -807,7 +807,7 @@ fjes_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
 	return ret;
 }
 
-static void fjes_tx_retry(struct net_device *netdev)
+static void fjes_tx_retry(struct net_device *netdev, unsigned int txqueue)
 {
 	struct netdev_queue *queue = netdev_get_tx_queue(netdev, 0);
 
diff --git a/drivers/net/slip/slip.c b/drivers/net/slip/slip.c
index 09075a9660d5..dfad58bf2c54 100644
--- a/drivers/net/slip/slip.c
+++ b/drivers/net/slip/slip.c
@@ -464,7 +464,7 @@ static void slip_write_wakeup(struct tty_struct *tty)
 	rcu_read_unlock();
 }
 
-static void sl_tx_timeout(struct net_device *dev)
+static void sl_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct slip *sl = netdev_priv(dev);
 
diff --git a/drivers/net/usb/catc.c b/drivers/net/usb/catc.c
index 424053bd8b21..1bb5a82f05be 100644
--- a/drivers/net/usb/catc.c
+++ b/drivers/net/usb/catc.c
@@ -458,7 +458,7 @@ static netdev_tx_t catc_start_xmit(struct sk_buff *skb,
 	return NETDEV_TX_OK;
 }
 
-static void catc_tx_timeout(struct net_device *netdev)
+static void catc_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct catc *catc = netdev_priv(netdev);
 
diff --git a/drivers/net/usb/hso.c b/drivers/net/usb/hso.c
index 3cf3eddff735..f79b53e44cdf 100644
--- a/drivers/net/usb/hso.c
+++ b/drivers/net/usb/hso.c
@@ -834,7 +834,7 @@ static const struct ethtool_ops ops = {
 };
 
 /* called when a packet did not ack after watchdogtimeout */
-static void hso_net_tx_timeout(struct net_device *net)
+static void hso_net_tx_timeout(struct net_device *net, unsigned int txqueue)
 {
 	struct hso_net *odev = netdev_priv(net);
 
diff --git a/drivers/net/usb/ipheth.c b/drivers/net/usb/ipheth.c
index 7275761a1177..ad6fdb8d171b 100644
--- a/drivers/net/usb/ipheth.c
+++ b/drivers/net/usb/ipheth.c
@@ -455,7 +455,7 @@ static int ipheth_tx(struct sk_buff *skb, struct net_device *net)
 	return NETDEV_TX_OK;
 }
 
-static void ipheth_tx_timeout(struct net_device *net)
+static void ipheth_tx_timeout(struct net_device *net, unsigned int txqueue)
 {
 	struct ipheth_device *dev = netdev_priv(net);
 
diff --git a/drivers/net/usb/kaweth.c b/drivers/net/usb/kaweth.c
index 913e50bab0a2..ff89bd9becdf 100644
--- a/drivers/net/usb/kaweth.c
+++ b/drivers/net/usb/kaweth.c
@@ -906,7 +906,7 @@ static void kaweth_async_set_rx_mode(struct kaweth_device *kaweth)
 /****************************************************************
  *     kaweth_tx_timeout
  ****************************************************************/
-static void kaweth_tx_timeout(struct net_device *net)
+static void kaweth_tx_timeout(struct net_device *net, unsigned int txqueue)
 {
 	struct kaweth_device *kaweth = netdev_priv(net);
 
diff --git a/drivers/net/usb/lan78xx.c b/drivers/net/usb/lan78xx.c
index 4276b74a8ede..6dd43a1c1a41 100644
--- a/drivers/net/usb/lan78xx.c
+++ b/drivers/net/usb/lan78xx.c
@@ -3681,7 +3681,7 @@ static void lan78xx_disconnect(struct usb_interface *intf)
 	usb_put_dev(udev);
 }
 
-static void lan78xx_tx_timeout(struct net_device *net)
+static void lan78xx_tx_timeout(struct net_device *net, unsigned int txqueue)
 {
 	struct lan78xx_net *dev = netdev_priv(net);
 
diff --git a/drivers/net/usb/pegasus.c b/drivers/net/usb/pegasus.c
index 6514c86f043e..5cd5c777c2e9 100644
--- a/drivers/net/usb/pegasus.c
+++ b/drivers/net/usb/pegasus.c
@@ -696,7 +696,7 @@ static void intr_callback(struct urb *urb)
 			  "can't resubmit interrupt urb, %d\n", res);
 }
 
-static void pegasus_tx_timeout(struct net_device *net)
+static void pegasus_tx_timeout(struct net_device *net, unsigned int txqueue)
 {
 	pegasus_t *pegasus = netdev_priv(net);
 	netif_warn(pegasus, timer, net, "tx timeout\n");
diff --git a/drivers/net/usb/r8152.c b/drivers/net/usb/r8152.c
index 85aef0c4c6c4..62b7f029a30c 100644
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@ -2129,7 +2129,7 @@ static void rtl_drop_queued_tx(struct r8152 *tp)
 	}
 }
 
-static void rtl8152_tx_timeout(struct net_device *netdev)
+static void rtl8152_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct r8152 *tp = netdev_priv(netdev);
 
diff --git a/drivers/net/usb/rtl8150.c b/drivers/net/usb/rtl8150.c
index 80373a9171dd..eefd595b9938 100644
--- a/drivers/net/usb/rtl8150.c
+++ b/drivers/net/usb/rtl8150.c
@@ -661,7 +661,7 @@ static void disable_net_traffic(rtl8150_t * dev)
 	set_registers(dev, CR, 1, &cr);
 }
 
-static void rtl8150_tx_timeout(struct net_device *netdev)
+static void rtl8150_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	rtl8150_t *dev = netdev_priv(netdev);
 	dev_warn(&netdev->dev, "Tx timeout.\n");
diff --git a/drivers/net/usb/usbnet.c b/drivers/net/usb/usbnet.c
index d6b3833c292d..bec710a1fcd8 100644
--- a/drivers/net/usb/usbnet.c
+++ b/drivers/net/usb/usbnet.c
@@ -1296,7 +1296,7 @@ static void tx_complete (struct urb *urb)
 
 /*-------------------------------------------------------------------------*/
 
-void usbnet_tx_timeout (struct net_device *net)
+void usbnet_tx_timeout (struct net_device *net, unsigned int txqueue)
 {
 	struct usbnet		*dev = netdev_priv(net);
 
diff --git a/drivers/net/vmxnet3/vmxnet3_drv.c b/drivers/net/vmxnet3/vmxnet3_drv.c
index 02a54d5b86aa..08edaf177bae 100644
--- a/drivers/net/vmxnet3/vmxnet3_drv.c
+++ b/drivers/net/vmxnet3/vmxnet3_drv.c
@@ -3199,7 +3199,7 @@ vmxnet3_free_intr_resources(struct vmxnet3_adapter *adapter)
 
 
 static void
-vmxnet3_tx_timeout(struct net_device *netdev)
+vmxnet3_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct vmxnet3_adapter *adapter = netdev_priv(netdev);
 	adapter->tx_timeout_count++;
diff --git a/drivers/net/wan/cosa.c b/drivers/net/wan/cosa.c
index f6b000ddcd15..c48267e9ef07 100644
--- a/drivers/net/wan/cosa.c
+++ b/drivers/net/wan/cosa.c
@@ -281,7 +281,7 @@ static int cosa_net_attach(struct net_device *dev, unsigned short encoding,
 			   unsigned short parity);
 static int cosa_net_open(struct net_device *d);
 static int cosa_net_close(struct net_device *d);
-static void cosa_net_timeout(struct net_device *d);
+static void cosa_net_timeout(struct net_device *d, unsigned int txqueue);
 static netdev_tx_t cosa_net_tx(struct sk_buff *skb, struct net_device *d);
 static char *cosa_net_setup_rx(struct channel_data *channel, int size);
 static int cosa_net_rx_done(struct channel_data *channel);
@@ -683,7 +683,7 @@ static netdev_tx_t cosa_net_tx(struct sk_buff *skb,
 	return NETDEV_TX_OK;
 }
 
-static void cosa_net_timeout(struct net_device *dev)
+static void cosa_net_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct channel_data *chan = dev_to_chan(dev);
 
diff --git a/drivers/net/wan/farsync.c b/drivers/net/wan/farsync.c
index bd46b2552980..e5078a25156b 100644
--- a/drivers/net/wan/farsync.c
+++ b/drivers/net/wan/farsync.c
@@ -2245,7 +2245,7 @@ fst_attach(struct net_device *dev, unsigned short encoding, unsigned short parit
 }
 
 static void
-fst_tx_timeout(struct net_device *dev)
+fst_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct fst_port_info *port;
 	struct fst_card_info *card;
* Unmerged path drivers/net/wan/fsl_ucc_hdlc.c
diff --git a/drivers/net/wan/lmc/lmc_main.c b/drivers/net/wan/lmc/lmc_main.c
index b3a1b6f5c406..39c2a0d57763 100644
--- a/drivers/net/wan/lmc/lmc_main.c
+++ b/drivers/net/wan/lmc/lmc_main.c
@@ -102,7 +102,7 @@ static int lmc_ifdown(struct net_device * const);
 static void lmc_watchdog(struct timer_list *t);
 static void lmc_reset(lmc_softc_t * const sc);
 static void lmc_dec_reset(lmc_softc_t * const sc);
-static void lmc_driver_timeout(struct net_device *dev);
+static void lmc_driver_timeout(struct net_device *dev, unsigned int txqueue);
 
 /*
  * linux reserves 16 device specific IOCTLs.  We call them
@@ -2050,7 +2050,7 @@ static void lmc_initcsrs(lmc_softc_t * const sc, lmc_csrptr_t csr_base, /*fold00
     lmc_trace(sc->lmc_device, "lmc_initcsrs out");
 }
 
-static void lmc_driver_timeout(struct net_device *dev)
+static void lmc_driver_timeout(struct net_device *dev, unsigned int txqueue)
 {
     lmc_softc_t *sc = dev_to_sc(dev);
     u32 csr6;
diff --git a/drivers/net/wan/x25_asy.c b/drivers/net/wan/x25_asy.c
index 74c06a5f586f..cbc39f7b11a1 100644
--- a/drivers/net/wan/x25_asy.c
+++ b/drivers/net/wan/x25_asy.c
@@ -276,7 +276,7 @@ static void x25_asy_write_wakeup(struct tty_struct *tty)
 	sl->xhead += actual;
 }
 
-static void x25_asy_timeout(struct net_device *dev)
+static void x25_asy_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct x25_asy *sl = netdev_priv(dev);
 
diff --git a/drivers/net/wimax/i2400m/netdev.c b/drivers/net/wimax/i2400m/netdev.c
index a654687b5fa2..c5ac58dbc75c 100644
--- a/drivers/net/wimax/i2400m/netdev.c
+++ b/drivers/net/wimax/i2400m/netdev.c
@@ -395,7 +395,7 @@ netdev_tx_t i2400m_hard_start_xmit(struct sk_buff *skb,
 
 
 static
-void i2400m_tx_timeout(struct net_device *net_dev)
+void i2400m_tx_timeout(struct net_device *net_dev, unsigned int txqueue)
 {
 	/*
 	 * We might want to kick the device
diff --git a/drivers/net/wireless/intel/ipw2x00/ipw2100.c b/drivers/net/wireless/intel/ipw2x00/ipw2100.c
index a01fb2c26276..c31787b39545 100644
--- a/drivers/net/wireless/intel/ipw2x00/ipw2100.c
+++ b/drivers/net/wireless/intel/ipw2x00/ipw2100.c
@@ -5840,7 +5840,7 @@ static int ipw2100_close(struct net_device *dev)
 /*
  * TODO:  Fix this function... its just wrong
  */
-static void ipw2100_tx_timeout(struct net_device *dev)
+static void ipw2100_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct ipw2100_priv *priv = libipw_priv(dev);
 
diff --git a/drivers/net/wireless/intersil/hostap/hostap_main.c b/drivers/net/wireless/intersil/hostap/hostap_main.c
index 05466281afb6..de97b3304115 100644
--- a/drivers/net/wireless/intersil/hostap/hostap_main.c
+++ b/drivers/net/wireless/intersil/hostap/hostap_main.c
@@ -761,7 +761,7 @@ static void hostap_set_multicast_list(struct net_device *dev)
 }
 
 
-static void prism2_tx_timeout(struct net_device *dev)
+static void prism2_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct hostap_interface *iface;
 	local_info_t *local;
diff --git a/drivers/net/wireless/intersil/orinoco/main.c b/drivers/net/wireless/intersil/orinoco/main.c
index 28dac36d7c4c..00264a14e52c 100644
--- a/drivers/net/wireless/intersil/orinoco/main.c
+++ b/drivers/net/wireless/intersil/orinoco/main.c
@@ -647,7 +647,7 @@ static void __orinoco_ev_txexc(struct net_device *dev, struct hermes *hw)
 	netif_wake_queue(dev);
 }
 
-void orinoco_tx_timeout(struct net_device *dev)
+void orinoco_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct orinoco_private *priv = ndev_priv(dev);
 	struct net_device_stats *stats = &dev->stats;
diff --git a/drivers/net/wireless/intersil/orinoco/orinoco.h b/drivers/net/wireless/intersil/orinoco/orinoco.h
index 430862a6a24b..cdd026af100b 100644
--- a/drivers/net/wireless/intersil/orinoco/orinoco.h
+++ b/drivers/net/wireless/intersil/orinoco/orinoco.h
@@ -207,7 +207,7 @@ int orinoco_open(struct net_device *dev);
 int orinoco_stop(struct net_device *dev);
 void orinoco_set_multicast_list(struct net_device *dev);
 int orinoco_change_mtu(struct net_device *dev, int new_mtu);
-void orinoco_tx_timeout(struct net_device *dev);
+void orinoco_tx_timeout(struct net_device *dev, unsigned int txqueue);
 
 /********************************************************************/
 /* Locking and synchronization functions                            */
diff --git a/drivers/net/wireless/intersil/prism54/islpci_eth.c b/drivers/net/wireless/intersil/prism54/islpci_eth.c
index b277113b33d3..eecdf6db8e77 100644
--- a/drivers/net/wireless/intersil/prism54/islpci_eth.c
+++ b/drivers/net/wireless/intersil/prism54/islpci_eth.c
@@ -484,7 +484,7 @@ islpci_do_reset_and_wake(struct work_struct *work)
 }
 
 void
-islpci_eth_tx_timeout(struct net_device *ndev)
+islpci_eth_tx_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	islpci_private *priv = netdev_priv(ndev);
 
diff --git a/drivers/net/wireless/intersil/prism54/islpci_eth.h b/drivers/net/wireless/intersil/prism54/islpci_eth.h
index 80f50f1bc6f2..8342b1f169c2 100644
--- a/drivers/net/wireless/intersil/prism54/islpci_eth.h
+++ b/drivers/net/wireless/intersil/prism54/islpci_eth.h
@@ -65,7 +65,7 @@ struct avs_80211_1_header {
 void islpci_eth_cleanup_transmit(islpci_private *, isl38xx_control_block *);
 netdev_tx_t islpci_eth_transmit(struct sk_buff *, struct net_device *);
 int islpci_eth_receive(islpci_private *);
-void islpci_eth_tx_timeout(struct net_device *);
+void islpci_eth_tx_timeout(struct net_device *, unsigned int txqueue);
 void islpci_do_reset_and_wake(struct work_struct *);
 
 #endif				/* _ISL_GEN_H */
diff --git a/drivers/net/wireless/marvell/mwifiex/main.c b/drivers/net/wireless/marvell/mwifiex/main.c
index 4fbc8940530f..9e90a1a9620e 100644
--- a/drivers/net/wireless/marvell/mwifiex/main.c
+++ b/drivers/net/wireless/marvell/mwifiex/main.c
@@ -1019,7 +1019,7 @@ static void mwifiex_set_multicast_list(struct net_device *dev)
  * CFG802.11 network device handler for transmission timeout.
  */
 static void
-mwifiex_tx_timeout(struct net_device *dev)
+mwifiex_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct mwifiex_private *priv = mwifiex_netdev_get_priv(dev);
 
diff --git a/drivers/net/wireless/quantenna/qtnfmac/core.c b/drivers/net/wireless/quantenna/qtnfmac/core.c
index a6a450984f9a..8928b9a5c5b8 100644
--- a/drivers/net/wireless/quantenna/qtnfmac/core.c
+++ b/drivers/net/wireless/quantenna/qtnfmac/core.c
@@ -155,7 +155,7 @@ static void qtnf_netdev_get_stats64(struct net_device *ndev,
 
 /* Netdev handler for transmission timeout.
  */
-static void qtnf_netdev_tx_timeout(struct net_device *ndev)
+static void qtnf_netdev_tx_timeout(struct net_device *ndev, unsigned int txqueue)
 {
 	struct qtnf_vif *vif = qtnf_netdev_get_priv(ndev);
 	struct qtnf_wmac *mac;
diff --git a/drivers/net/wireless/wl3501_cs.c b/drivers/net/wireless/wl3501_cs.c
index da62220b9c01..c0dc11ad18da 100644
--- a/drivers/net/wireless/wl3501_cs.c
+++ b/drivers/net/wireless/wl3501_cs.c
@@ -1286,7 +1286,7 @@ static int wl3501_reset(struct net_device *dev)
 	return rc;
 }
 
-static void wl3501_tx_timeout(struct net_device *dev)
+static void wl3501_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct net_device_stats *stats = &dev->stats;
 	int rc;
diff --git a/drivers/net/wireless/zydas/zd1201.c b/drivers/net/wireless/zydas/zd1201.c
index 9e6018ed429a..15da9d8f0cec 100644
--- a/drivers/net/wireless/zydas/zd1201.c
+++ b/drivers/net/wireless/zydas/zd1201.c
@@ -830,7 +830,7 @@ static netdev_tx_t zd1201_hard_start_xmit(struct sk_buff *skb,
 	return NETDEV_TX_OK;
 }
 
-static void zd1201_tx_timeout(struct net_device *dev)
+static void zd1201_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct zd1201 *zd = netdev_priv(dev);
 
diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h
index 871d44746f5c..a23875a4fa2b 100644
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@ -1076,7 +1076,7 @@ void qeth_clear_working_pool_list(struct qeth_card *);
 void qeth_drain_output_queues(struct qeth_card *card);
 void qeth_setadp_promisc_mode(struct qeth_card *card, bool enable);
 int qeth_setadpparms_change_macaddr(struct qeth_card *);
-void qeth_tx_timeout(struct net_device *);
+void qeth_tx_timeout(struct net_device *, unsigned int txqueue);
 void qeth_prepare_ipa_cmd(struct qeth_card *card, struct qeth_cmd_buffer *iob,
 			  u16 cmd_length);
 int qeth_query_switch_attributes(struct qeth_card *card,
diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c
index 518e88e8e9bc..0f5274b0ace4 100644
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -4317,7 +4317,7 @@ int qeth_set_access_ctrl_online(struct qeth_card *card, int fallback)
 }
 EXPORT_SYMBOL_GPL(qeth_set_access_ctrl_online);
 
-void qeth_tx_timeout(struct net_device *dev)
+void qeth_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct qeth_card *card;
 
diff --git a/drivers/staging/ks7010/ks_wlan_net.c b/drivers/staging/ks7010/ks_wlan_net.c
index dc5459ae0b51..78ffeb4ad18f 100644
--- a/drivers/staging/ks7010/ks_wlan_net.c
+++ b/drivers/staging/ks7010/ks_wlan_net.c
@@ -45,7 +45,7 @@ struct wep_key {
  *	function prototypes
  */
 static int ks_wlan_open(struct net_device *dev);
-static void ks_wlan_tx_timeout(struct net_device *dev);
+static void ks_wlan_tx_timeout(struct net_device *dev, unsigned int txqueue);
 static int ks_wlan_start_xmit(struct sk_buff *skb, struct net_device *dev);
 static int ks_wlan_close(struct net_device *dev);
 static void ks_wlan_set_rx_mode(struct net_device *dev);
@@ -2498,7 +2498,7 @@ int ks_wlan_set_mac_address(struct net_device *dev, void *addr)
 }
 
 static
-void ks_wlan_tx_timeout(struct net_device *dev)
+void ks_wlan_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct ks_wlan_private *priv = netdev_priv(dev);
 
diff --git a/drivers/staging/rtl8192e/rtl8192e/rtl_core.c b/drivers/staging/rtl8192e/rtl8192e/rtl_core.c
index d2605158546b..33155a03cf76 100644
--- a/drivers/staging/rtl8192e/rtl8192e/rtl_core.c
+++ b/drivers/staging/rtl8192e/rtl8192e/rtl_core.c
@@ -278,7 +278,7 @@ static short _rtl92e_check_nic_enough_desc(struct net_device *dev, int prio)
 	return 0;
 }
 
-static void _rtl92e_tx_timeout(struct net_device *dev)
+static void _rtl92e_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct r8192_priv *priv = rtllib_priv(dev);
 
diff --git a/drivers/staging/rtl8192u/r8192U_core.c b/drivers/staging/rtl8192u/r8192U_core.c
index 8b17400f6c13..87d46bc2c17e 100644
--- a/drivers/staging/rtl8192u/r8192U_core.c
+++ b/drivers/staging/rtl8192u/r8192U_core.c
@@ -684,7 +684,7 @@ short check_nic_enough_desc(struct net_device *dev, int queue_index)
 	return (used < MAX_TX_URB);
 }
 
-static void tx_timeout(struct net_device *dev)
+static void tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct r8192_priv *priv = ieee80211_priv(dev);
 
diff --git a/drivers/staging/unisys/visornic/visornic_main.c b/drivers/staging/unisys/visornic/visornic_main.c
index 5eeb4b93b45b..55735d180c22 100644
--- a/drivers/staging/unisys/visornic/visornic_main.c
+++ b/drivers/staging/unisys/visornic/visornic_main.c
@@ -1080,7 +1080,7 @@ static void visornic_set_multi(struct net_device *netdev)
  * Queue the work and return. Make sure we have not already been informed that
  * the IO Partition is gone; if so, we will have already timed-out the xmits.
  */
-static void visornic_xmit_timeout(struct net_device *netdev)
+static void visornic_xmit_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct visornic_devdata *devdata = netdev_priv(netdev);
 	unsigned long flags;
diff --git a/drivers/staging/wlan-ng/p80211netdev.c b/drivers/staging/wlan-ng/p80211netdev.c
index 8258cb5a335d..67d4abdf0a9a 100644
--- a/drivers/staging/wlan-ng/p80211netdev.c
+++ b/drivers/staging/wlan-ng/p80211netdev.c
@@ -101,7 +101,7 @@ static void p80211knetdev_set_multicast_list(struct net_device *dev);
 static int p80211knetdev_do_ioctl(struct net_device *dev, struct ifreq *ifr,
 				  int cmd);
 static int p80211knetdev_set_mac_address(struct net_device *dev, void *addr);
-static void p80211knetdev_tx_timeout(struct net_device *netdev);
+static void p80211knetdev_tx_timeout(struct net_device *netdev, unsigned int txqueue);
 static int p80211_rx_typedrop(struct wlandevice *wlandev, u16 fc);
 
 int wlan_watchdog = 5000;
@@ -1078,7 +1078,7 @@ static int p80211_rx_typedrop(struct wlandevice *wlandev, u16 fc)
 	return drop;
 }
 
-static void p80211knetdev_tx_timeout(struct net_device *netdev)
+static void p80211knetdev_tx_timeout(struct net_device *netdev, unsigned int txqueue)
 {
 	struct wlandevice *wlandev = netdev->ml_priv;
 
diff --git a/drivers/tty/n_gsm.c b/drivers/tty/n_gsm.c
index 86b7e20ffd7f..f4af82c4f03e 100644
--- a/drivers/tty/n_gsm.c
+++ b/drivers/tty/n_gsm.c
@@ -2693,7 +2693,7 @@ static netdev_tx_t gsm_mux_net_start_xmit(struct sk_buff *skb,
 }
 
 /* called when a packet did not ack after watchdogtimeout */
-static void gsm_mux_net_tx_timeout(struct net_device *net)
+static void gsm_mux_net_tx_timeout(struct net_device *net, unsigned int txqueue)
 {
 	/* Tell syslog we are hosed. */
 	dev_dbg(&net->dev, "Tx timed out.\n");
diff --git a/drivers/tty/synclink.c b/drivers/tty/synclink.c
index fbdf4d01c6a9..a571c8b2631b 100644
--- a/drivers/tty/synclink.c
+++ b/drivers/tty/synclink.c
@@ -7892,7 +7892,7 @@ static int hdlcdev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
  *
  * dev  pointer to network device structure
  */
-static void hdlcdev_tx_timeout(struct net_device *dev)
+static void hdlcdev_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct mgsl_struct *info = dev_to_port(dev);
 	unsigned long flags;
diff --git a/drivers/tty/synclink_gt.c b/drivers/tty/synclink_gt.c
index a94086597ebd..e2ecc0d40fcc 100644
--- a/drivers/tty/synclink_gt.c
+++ b/drivers/tty/synclink_gt.c
@@ -1691,7 +1691,7 @@ static int hdlcdev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
  *
  * dev  pointer to network device structure
  */
-static void hdlcdev_tx_timeout(struct net_device *dev)
+static void hdlcdev_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	struct slgt_info *info = dev_to_port(dev);
 	unsigned long flags;
diff --git a/drivers/tty/synclinkmp.c b/drivers/tty/synclinkmp.c
index 1e4d5b9c981a..b1d120848aae 100644
--- a/drivers/tty/synclinkmp.c
+++ b/drivers/tty/synclinkmp.c
@@ -1808,7 +1808,7 @@ static int hdlcdev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
  *
  * dev  pointer to network device structure
  */
-static void hdlcdev_tx_timeout(struct net_device *dev)
+static void hdlcdev_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	SLMP_INFO *info = dev_to_port(dev);
 	unsigned long flags;
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 4bd94d67974c..7f313d5ccc7e 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1070,7 +1070,7 @@ struct devlink;
  *	Called when a user wants to change the Maximum Transfer Unit
  *	of a device.
  *
- * void (*ndo_tx_timeout)(struct net_device *dev);
+ * void (*ndo_tx_timeout)(struct net_device *dev, unsigned int txqueue);
  *	Callback used when the transmitter has not made any progress
  *	for dev->watchdog ticks.
  *
@@ -1332,7 +1332,8 @@ struct net_device_ops {
 						  int new_mtu);
 	int			(*ndo_neigh_setup)(struct net_device *dev,
 						   struct neigh_parms *);
-	void			(*ndo_tx_timeout) (struct net_device *dev);
+	void			(*ndo_tx_timeout) (struct net_device *dev,
+						   unsigned int txqueue);
 
 	void			(*ndo_get_stats64)(struct net_device *dev,
 						   struct rtnl_link_stats64 *storage);
diff --git a/include/linux/usb/usbnet.h b/include/linux/usb/usbnet.h
index d8860f2d0976..b0bff3083278 100644
--- a/include/linux/usb/usbnet.h
+++ b/include/linux/usb/usbnet.h
@@ -253,7 +253,7 @@ extern int usbnet_open(struct net_device *net);
 extern int usbnet_stop(struct net_device *net);
 extern netdev_tx_t usbnet_start_xmit(struct sk_buff *skb,
 				     struct net_device *net);
-extern void usbnet_tx_timeout(struct net_device *net);
+extern void usbnet_tx_timeout(struct net_device *net, unsigned int txqueue);
 extern int usbnet_change_mtu(struct net_device *net, int new_mtu);
 
 extern int usbnet_get_endpoints(struct usbnet *, struct usb_interface *);
diff --git a/net/atm/lec.c b/net/atm/lec.c
index ad4f829193f0..1e67398ab914 100644
--- a/net/atm/lec.c
+++ b/net/atm/lec.c
@@ -193,7 +193,7 @@ lec_send(struct atm_vcc *vcc, struct sk_buff *skb)
 	dev->stats.tx_bytes += skb->len;
 }
 
-static void lec_tx_timeout(struct net_device *dev)
+static void lec_tx_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	pr_info("%s\n", dev->name);
 	netif_trans_update(dev);
diff --git a/net/bluetooth/bnep/netdev.c b/net/bluetooth/bnep/netdev.c
index 1d4d7d415730..cc1cff63194f 100644
--- a/net/bluetooth/bnep/netdev.c
+++ b/net/bluetooth/bnep/netdev.c
@@ -112,7 +112,7 @@ static int bnep_net_set_mac_addr(struct net_device *dev, void *arg)
 	return 0;
 }
 
-static void bnep_net_timeout(struct net_device *dev)
+static void bnep_net_timeout(struct net_device *dev, unsigned int txqueue)
 {
 	BT_DBG("net_timeout");
 	netif_wake_queue(dev);
diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c
index 02b134d0a084..94474b251c4b 100644
--- a/net/sched/sch_generic.c
+++ b/net/sched/sch_generic.c
@@ -445,7 +445,7 @@ static void dev_watchdog(struct timer_list *t)
 				trace_net_dev_xmit_timeout(dev, i);
 				WARN_ONCE(1, KERN_INFO "NETDEV WATCHDOG: %s (%s): transmit queue %u timed out\n",
 				       dev->name, netdev_drivername(dev), i);
-				dev->netdev_ops->ndo_tx_timeout(dev);
+				dev->netdev_ops->ndo_tx_timeout(dev, i);
 			}
 			if (!mod_timer(&dev->watchdog_timer,
 				       round_jiffies(jiffies +
