bpf: Make btf_check_func_type_match() static

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Hongbo Yao <yaohongbo@huawei.com>
commit 2bf0eb9b3b0d099b20b2c4736436b666d78b94d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/2bf0eb9b.failed

Fix the following sparse warning:

kernel/bpf/btf.c:4131:5: warning: symbol 'btf_check_func_type_match' was
not declared. Should it be static?

	Reported-by: Hulk Robot <hulkci@huawei.com>
	Signed-off-by: Hongbo Yao <yaohongbo@huawei.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
Link: https://lore.kernel.org/bpf/20200210011441.147102-1-yaohongbo@huawei.com
(cherry picked from commit 2bf0eb9b3b0d099b20b2c4736436b666d78b94d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/btf.c
diff --cc kernel/bpf/btf.c
index 0b6e1b3569aa,787140095e58..000000000000
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@@ -3811,6 -3966,511 +3811,514 @@@ again
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ static int __btf_resolve_helper_id(struct bpf_verifier_log *log, void *fn,
+ 				   int arg)
+ {
+ 	char fnname[KSYM_SYMBOL_LEN + 4] = "btf_";
+ 	const struct btf_param *args;
+ 	const struct btf_type *t;
+ 	const char *tname, *sym;
+ 	u32 btf_id, i;
+ 
+ 	if (IS_ERR(btf_vmlinux)) {
+ 		bpf_log(log, "btf_vmlinux is malformed\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	sym = kallsyms_lookup((long)fn, NULL, NULL, NULL, fnname + 4);
+ 	if (!sym) {
+ 		bpf_log(log, "kernel doesn't have kallsyms\n");
+ 		return -EFAULT;
+ 	}
+ 
+ 	for (i = 1; i <= btf_vmlinux->nr_types; i++) {
+ 		t = btf_type_by_id(btf_vmlinux, i);
+ 		if (BTF_INFO_KIND(t->info) != BTF_KIND_TYPEDEF)
+ 			continue;
+ 		tname = __btf_name_by_offset(btf_vmlinux, t->name_off);
+ 		if (!strcmp(tname, fnname))
+ 			break;
+ 	}
+ 	if (i > btf_vmlinux->nr_types) {
+ 		bpf_log(log, "helper %s type is not found\n", fnname);
+ 		return -ENOENT;
+ 	}
+ 
+ 	t = btf_type_by_id(btf_vmlinux, t->type);
+ 	if (!btf_type_is_ptr(t))
+ 		return -EFAULT;
+ 	t = btf_type_by_id(btf_vmlinux, t->type);
+ 	if (!btf_type_is_func_proto(t))
+ 		return -EFAULT;
+ 
+ 	args = (const struct btf_param *)(t + 1);
+ 	if (arg >= btf_type_vlen(t)) {
+ 		bpf_log(log, "bpf helper %s doesn't have %d-th argument\n",
+ 			fnname, arg);
+ 		return -EINVAL;
+ 	}
+ 
+ 	t = btf_type_by_id(btf_vmlinux, args[arg].type);
+ 	if (!btf_type_is_ptr(t) || !t->type) {
+ 		/* anything but the pointer to struct is a helper config bug */
+ 		bpf_log(log, "ARG_PTR_TO_BTF is misconfigured\n");
+ 		return -EFAULT;
+ 	}
+ 	btf_id = t->type;
+ 	t = btf_type_by_id(btf_vmlinux, t->type);
+ 	/* skip modifiers */
+ 	while (btf_type_is_modifier(t)) {
+ 		btf_id = t->type;
+ 		t = btf_type_by_id(btf_vmlinux, t->type);
+ 	}
+ 	if (!btf_type_is_struct(t)) {
+ 		bpf_log(log, "ARG_PTR_TO_BTF is not a struct\n");
+ 		return -EFAULT;
+ 	}
+ 	bpf_log(log, "helper %s arg%d has btf_id %d struct %s\n", fnname + 4,
+ 		arg, btf_id, __btf_name_by_offset(btf_vmlinux, t->name_off));
+ 	return btf_id;
+ }
+ 
+ int btf_resolve_helper_id(struct bpf_verifier_log *log,
+ 			  const struct bpf_func_proto *fn, int arg)
+ {
+ 	int *btf_id = &fn->btf_id[arg];
+ 	int ret;
+ 
+ 	if (fn->arg_type[arg] != ARG_PTR_TO_BTF_ID)
+ 		return -EINVAL;
+ 
+ 	ret = READ_ONCE(*btf_id);
+ 	if (ret)
+ 		return ret;
+ 	/* ok to race the search. The result is the same */
+ 	ret = __btf_resolve_helper_id(log, fn->func, arg);
+ 	if (!ret) {
+ 		/* Function argument cannot be type 'void' */
+ 		bpf_log(log, "BTF resolution bug\n");
+ 		return -EFAULT;
+ 	}
+ 	WRITE_ONCE(*btf_id, ret);
+ 	return ret;
+ }
+ 
+ static int __get_type_size(struct btf *btf, u32 btf_id,
+ 			   const struct btf_type **bad_type)
+ {
+ 	const struct btf_type *t;
+ 
+ 	if (!btf_id)
+ 		/* void */
+ 		return 0;
+ 	t = btf_type_by_id(btf, btf_id);
+ 	while (t && btf_type_is_modifier(t))
+ 		t = btf_type_by_id(btf, t->type);
+ 	if (!t) {
+ 		*bad_type = btf->types[0];
+ 		return -EINVAL;
+ 	}
+ 	if (btf_type_is_ptr(t))
+ 		/* kernel size of pointer. Not BPF's size of pointer*/
+ 		return sizeof(void *);
+ 	if (btf_type_is_int(t) || btf_type_is_enum(t))
+ 		return t->size;
+ 	*bad_type = t;
+ 	return -EINVAL;
+ }
+ 
+ int btf_distill_func_proto(struct bpf_verifier_log *log,
+ 			   struct btf *btf,
+ 			   const struct btf_type *func,
+ 			   const char *tname,
+ 			   struct btf_func_model *m)
+ {
+ 	const struct btf_param *args;
+ 	const struct btf_type *t;
+ 	u32 i, nargs;
+ 	int ret;
+ 
+ 	if (!func) {
+ 		/* BTF function prototype doesn't match the verifier types.
+ 		 * Fall back to 5 u64 args.
+ 		 */
+ 		for (i = 0; i < 5; i++)
+ 			m->arg_size[i] = 8;
+ 		m->ret_size = 8;
+ 		m->nr_args = 5;
+ 		return 0;
+ 	}
+ 	args = (const struct btf_param *)(func + 1);
+ 	nargs = btf_type_vlen(func);
+ 	if (nargs >= MAX_BPF_FUNC_ARGS) {
+ 		bpf_log(log,
+ 			"The function %s has %d arguments. Too many.\n",
+ 			tname, nargs);
+ 		return -EINVAL;
+ 	}
+ 	ret = __get_type_size(btf, func->type, &t);
+ 	if (ret < 0) {
+ 		bpf_log(log,
+ 			"The function %s return type %s is unsupported.\n",
+ 			tname, btf_kind_str[BTF_INFO_KIND(t->info)]);
+ 		return -EINVAL;
+ 	}
+ 	m->ret_size = ret;
+ 
+ 	for (i = 0; i < nargs; i++) {
+ 		ret = __get_type_size(btf, args[i].type, &t);
+ 		if (ret < 0) {
+ 			bpf_log(log,
+ 				"The function %s arg%d type %s is unsupported.\n",
+ 				tname, i, btf_kind_str[BTF_INFO_KIND(t->info)]);
+ 			return -EINVAL;
+ 		}
+ 		m->arg_size[i] = ret;
+ 	}
+ 	m->nr_args = nargs;
+ 	return 0;
+ }
+ 
+ /* Compare BTFs of two functions assuming only scalars and pointers to context.
+  * t1 points to BTF_KIND_FUNC in btf1
+  * t2 points to BTF_KIND_FUNC in btf2
+  * Returns:
+  * EINVAL - function prototype mismatch
+  * EFAULT - verifier bug
+  * 0 - 99% match. The last 1% is validated by the verifier.
+  */
+ static int btf_check_func_type_match(struct bpf_verifier_log *log,
+ 				     struct btf *btf1, const struct btf_type *t1,
+ 				     struct btf *btf2, const struct btf_type *t2)
+ {
+ 	const struct btf_param *args1, *args2;
+ 	const char *fn1, *fn2, *s1, *s2;
+ 	u32 nargs1, nargs2, i;
+ 
+ 	fn1 = btf_name_by_offset(btf1, t1->name_off);
+ 	fn2 = btf_name_by_offset(btf2, t2->name_off);
+ 
+ 	if (btf_func_linkage(t1) != BTF_FUNC_GLOBAL) {
+ 		bpf_log(log, "%s() is not a global function\n", fn1);
+ 		return -EINVAL;
+ 	}
+ 	if (btf_func_linkage(t2) != BTF_FUNC_GLOBAL) {
+ 		bpf_log(log, "%s() is not a global function\n", fn2);
+ 		return -EINVAL;
+ 	}
+ 
+ 	t1 = btf_type_by_id(btf1, t1->type);
+ 	if (!t1 || !btf_type_is_func_proto(t1))
+ 		return -EFAULT;
+ 	t2 = btf_type_by_id(btf2, t2->type);
+ 	if (!t2 || !btf_type_is_func_proto(t2))
+ 		return -EFAULT;
+ 
+ 	args1 = (const struct btf_param *)(t1 + 1);
+ 	nargs1 = btf_type_vlen(t1);
+ 	args2 = (const struct btf_param *)(t2 + 1);
+ 	nargs2 = btf_type_vlen(t2);
+ 
+ 	if (nargs1 != nargs2) {
+ 		bpf_log(log, "%s() has %d args while %s() has %d args\n",
+ 			fn1, nargs1, fn2, nargs2);
+ 		return -EINVAL;
+ 	}
+ 
+ 	t1 = btf_type_skip_modifiers(btf1, t1->type, NULL);
+ 	t2 = btf_type_skip_modifiers(btf2, t2->type, NULL);
+ 	if (t1->info != t2->info) {
+ 		bpf_log(log,
+ 			"Return type %s of %s() doesn't match type %s of %s()\n",
+ 			btf_type_str(t1), fn1,
+ 			btf_type_str(t2), fn2);
+ 		return -EINVAL;
+ 	}
+ 
+ 	for (i = 0; i < nargs1; i++) {
+ 		t1 = btf_type_skip_modifiers(btf1, args1[i].type, NULL);
+ 		t2 = btf_type_skip_modifiers(btf2, args2[i].type, NULL);
+ 
+ 		if (t1->info != t2->info) {
+ 			bpf_log(log, "arg%d in %s() is %s while %s() has %s\n",
+ 				i, fn1, btf_type_str(t1),
+ 				fn2, btf_type_str(t2));
+ 			return -EINVAL;
+ 		}
+ 		if (btf_type_has_size(t1) && t1->size != t2->size) {
+ 			bpf_log(log,
+ 				"arg%d in %s() has size %d while %s() has %d\n",
+ 				i, fn1, t1->size,
+ 				fn2, t2->size);
+ 			return -EINVAL;
+ 		}
+ 
+ 		/* global functions are validated with scalars and pointers
+ 		 * to context only. And only global functions can be replaced.
+ 		 * Hence type check only those types.
+ 		 */
+ 		if (btf_type_is_int(t1) || btf_type_is_enum(t1))
+ 			continue;
+ 		if (!btf_type_is_ptr(t1)) {
+ 			bpf_log(log,
+ 				"arg%d in %s() has unrecognized type\n",
+ 				i, fn1);
+ 			return -EINVAL;
+ 		}
+ 		t1 = btf_type_skip_modifiers(btf1, t1->type, NULL);
+ 		t2 = btf_type_skip_modifiers(btf2, t2->type, NULL);
+ 		if (!btf_type_is_struct(t1)) {
+ 			bpf_log(log,
+ 				"arg%d in %s() is not a pointer to context\n",
+ 				i, fn1);
+ 			return -EINVAL;
+ 		}
+ 		if (!btf_type_is_struct(t2)) {
+ 			bpf_log(log,
+ 				"arg%d in %s() is not a pointer to context\n",
+ 				i, fn2);
+ 			return -EINVAL;
+ 		}
+ 		/* This is an optional check to make program writing easier.
+ 		 * Compare names of structs and report an error to the user.
+ 		 * btf_prepare_func_args() already checked that t2 struct
+ 		 * is a context type. btf_prepare_func_args() will check
+ 		 * later that t1 struct is a context type as well.
+ 		 */
+ 		s1 = btf_name_by_offset(btf1, t1->name_off);
+ 		s2 = btf_name_by_offset(btf2, t2->name_off);
+ 		if (strcmp(s1, s2)) {
+ 			bpf_log(log,
+ 				"arg%d %s(struct %s *) doesn't match %s(struct %s *)\n",
+ 				i, fn1, s1, fn2, s2);
+ 			return -EINVAL;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ /* Compare BTFs of given program with BTF of target program */
+ int btf_check_type_match(struct bpf_verifier_env *env, struct bpf_prog *prog,
+ 			 struct btf *btf2, const struct btf_type *t2)
+ {
+ 	struct btf *btf1 = prog->aux->btf;
+ 	const struct btf_type *t1;
+ 	u32 btf_id = 0;
+ 
+ 	if (!prog->aux->func_info) {
+ 		bpf_log(&env->log, "Program extension requires BTF\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	btf_id = prog->aux->func_info[0].type_id;
+ 	if (!btf_id)
+ 		return -EFAULT;
+ 
+ 	t1 = btf_type_by_id(btf1, btf_id);
+ 	if (!t1 || !btf_type_is_func(t1))
+ 		return -EFAULT;
+ 
+ 	return btf_check_func_type_match(&env->log, btf1, t1, btf2, t2);
+ }
+ 
+ /* Compare BTF of a function with given bpf_reg_state.
+  * Returns:
+  * EFAULT - there is a verifier bug. Abort verification.
+  * EINVAL - there is a type mismatch or BTF is not available.
+  * 0 - BTF matches with what bpf_reg_state expects.
+  * Only PTR_TO_CTX and SCALAR_VALUE states are recognized.
+  */
+ int btf_check_func_arg_match(struct bpf_verifier_env *env, int subprog,
+ 			     struct bpf_reg_state *reg)
+ {
+ 	struct bpf_verifier_log *log = &env->log;
+ 	struct bpf_prog *prog = env->prog;
+ 	struct btf *btf = prog->aux->btf;
+ 	const struct btf_param *args;
+ 	const struct btf_type *t;
+ 	u32 i, nargs, btf_id;
+ 	const char *tname;
+ 
+ 	if (!prog->aux->func_info)
+ 		return -EINVAL;
+ 
+ 	btf_id = prog->aux->func_info[subprog].type_id;
+ 	if (!btf_id)
+ 		return -EFAULT;
+ 
+ 	if (prog->aux->func_info_aux[subprog].unreliable)
+ 		return -EINVAL;
+ 
+ 	t = btf_type_by_id(btf, btf_id);
+ 	if (!t || !btf_type_is_func(t)) {
+ 		/* These checks were already done by the verifier while loading
+ 		 * struct bpf_func_info
+ 		 */
+ 		bpf_log(log, "BTF of func#%d doesn't point to KIND_FUNC\n",
+ 			subprog);
+ 		return -EFAULT;
+ 	}
+ 	tname = btf_name_by_offset(btf, t->name_off);
+ 
+ 	t = btf_type_by_id(btf, t->type);
+ 	if (!t || !btf_type_is_func_proto(t)) {
+ 		bpf_log(log, "Invalid BTF of func %s\n", tname);
+ 		return -EFAULT;
+ 	}
+ 	args = (const struct btf_param *)(t + 1);
+ 	nargs = btf_type_vlen(t);
+ 	if (nargs > 5) {
+ 		bpf_log(log, "Function %s has %d > 5 args\n", tname, nargs);
+ 		goto out;
+ 	}
+ 	/* check that BTF function arguments match actual types that the
+ 	 * verifier sees.
+ 	 */
+ 	for (i = 0; i < nargs; i++) {
+ 		t = btf_type_by_id(btf, args[i].type);
+ 		while (btf_type_is_modifier(t))
+ 			t = btf_type_by_id(btf, t->type);
+ 		if (btf_type_is_int(t) || btf_type_is_enum(t)) {
+ 			if (reg[i + 1].type == SCALAR_VALUE)
+ 				continue;
+ 			bpf_log(log, "R%d is not a scalar\n", i + 1);
+ 			goto out;
+ 		}
+ 		if (btf_type_is_ptr(t)) {
+ 			if (reg[i + 1].type == SCALAR_VALUE) {
+ 				bpf_log(log, "R%d is not a pointer\n", i + 1);
+ 				goto out;
+ 			}
+ 			/* If function expects ctx type in BTF check that caller
+ 			 * is passing PTR_TO_CTX.
+ 			 */
+ 			if (btf_get_prog_ctx_type(log, btf, t, prog->type, i)) {
+ 				if (reg[i + 1].type != PTR_TO_CTX) {
+ 					bpf_log(log,
+ 						"arg#%d expected pointer to ctx, but got %s\n",
+ 						i, btf_kind_str[BTF_INFO_KIND(t->info)]);
+ 					goto out;
+ 				}
+ 				if (check_ctx_reg(env, &reg[i + 1], i + 1))
+ 					goto out;
+ 				continue;
+ 			}
+ 		}
+ 		bpf_log(log, "Unrecognized arg#%d type %s\n",
+ 			i, btf_kind_str[BTF_INFO_KIND(t->info)]);
+ 		goto out;
+ 	}
+ 	return 0;
+ out:
+ 	/* Compiler optimizations can remove arguments from static functions
+ 	 * or mismatched type can be passed into a global function.
+ 	 * In such cases mark the function as unreliable from BTF point of view.
+ 	 */
+ 	prog->aux->func_info_aux[subprog].unreliable = true;
+ 	return -EINVAL;
+ }
+ 
+ /* Convert BTF of a function into bpf_reg_state if possible
+  * Returns:
+  * EFAULT - there is a verifier bug. Abort verification.
+  * EINVAL - cannot convert BTF.
+  * 0 - Successfully converted BTF into bpf_reg_state
+  * (either PTR_TO_CTX or SCALAR_VALUE).
+  */
+ int btf_prepare_func_args(struct bpf_verifier_env *env, int subprog,
+ 			  struct bpf_reg_state *reg)
+ {
+ 	struct bpf_verifier_log *log = &env->log;
+ 	struct bpf_prog *prog = env->prog;
+ 	enum bpf_prog_type prog_type = prog->type;
+ 	struct btf *btf = prog->aux->btf;
+ 	const struct btf_param *args;
+ 	const struct btf_type *t;
+ 	u32 i, nargs, btf_id;
+ 	const char *tname;
+ 
+ 	if (!prog->aux->func_info ||
+ 	    prog->aux->func_info_aux[subprog].linkage != BTF_FUNC_GLOBAL) {
+ 		bpf_log(log, "Verifier bug\n");
+ 		return -EFAULT;
+ 	}
+ 
+ 	btf_id = prog->aux->func_info[subprog].type_id;
+ 	if (!btf_id) {
+ 		bpf_log(log, "Global functions need valid BTF\n");
+ 		return -EFAULT;
+ 	}
+ 
+ 	t = btf_type_by_id(btf, btf_id);
+ 	if (!t || !btf_type_is_func(t)) {
+ 		/* These checks were already done by the verifier while loading
+ 		 * struct bpf_func_info
+ 		 */
+ 		bpf_log(log, "BTF of func#%d doesn't point to KIND_FUNC\n",
+ 			subprog);
+ 		return -EFAULT;
+ 	}
+ 	tname = btf_name_by_offset(btf, t->name_off);
+ 
+ 	if (log->level & BPF_LOG_LEVEL)
+ 		bpf_log(log, "Validating %s() func#%d...\n",
+ 			tname, subprog);
+ 
+ 	if (prog->aux->func_info_aux[subprog].unreliable) {
+ 		bpf_log(log, "Verifier bug in function %s()\n", tname);
+ 		return -EFAULT;
+ 	}
+ 	if (prog_type == BPF_PROG_TYPE_EXT)
+ 		prog_type = prog->aux->linked_prog->type;
+ 
+ 	t = btf_type_by_id(btf, t->type);
+ 	if (!t || !btf_type_is_func_proto(t)) {
+ 		bpf_log(log, "Invalid type of function %s()\n", tname);
+ 		return -EFAULT;
+ 	}
+ 	args = (const struct btf_param *)(t + 1);
+ 	nargs = btf_type_vlen(t);
+ 	if (nargs > 5) {
+ 		bpf_log(log, "Global function %s() with %d > 5 args. Buggy compiler.\n",
+ 			tname, nargs);
+ 		return -EINVAL;
+ 	}
+ 	/* check that function returns int */
+ 	t = btf_type_by_id(btf, t->type);
+ 	while (btf_type_is_modifier(t))
+ 		t = btf_type_by_id(btf, t->type);
+ 	if (!btf_type_is_int(t) && !btf_type_is_enum(t)) {
+ 		bpf_log(log,
+ 			"Global function %s() doesn't return scalar. Only those are supported.\n",
+ 			tname);
+ 		return -EINVAL;
+ 	}
+ 	/* Convert BTF function arguments into verifier types.
+ 	 * Only PTR_TO_CTX and SCALAR are supported atm.
+ 	 */
+ 	for (i = 0; i < nargs; i++) {
+ 		t = btf_type_by_id(btf, args[i].type);
+ 		while (btf_type_is_modifier(t))
+ 			t = btf_type_by_id(btf, t->type);
+ 		if (btf_type_is_int(t) || btf_type_is_enum(t)) {
+ 			reg[i + 1].type = SCALAR_VALUE;
+ 			continue;
+ 		}
+ 		if (btf_type_is_ptr(t) &&
+ 		    btf_get_prog_ctx_type(log, btf, t, prog_type, i)) {
+ 			reg[i + 1].type = PTR_TO_CTX;
+ 			continue;
+ 		}
+ 		bpf_log(log, "Arg#%d type %s in %s() is not supported yet.\n",
+ 			i, btf_kind_str[BTF_INFO_KIND(t->info)], tname);
+ 		return -EINVAL;
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 2bf0eb9b3b0d (bpf: Make btf_check_func_type_match() static)
  void btf_type_seq_show(const struct btf *btf, u32 type_id, void *obj,
  		       struct seq_file *m)
  {
* Unmerged path kernel/bpf/btf.c
