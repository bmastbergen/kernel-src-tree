scsi: zfcp: trace FC Endpoint Security of FCP devices and connections

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Remus <jremus@linux.ibm.com>
commit 616da39e0060f3b8bbc0f36f7d911bb5abb31746
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/616da39e.failed

Trace changes in Fibre Channel Endpoint Security capabilities of FCP
devices as well as changes in Fibre Channel Endpoint Security state of
their connections to FC remote ports as FC Endpoint Security changes with
trace level 3 in HBA DBF.

A change in FC Endpoint Security capabilities of FCP devices is traced as
response to FSF command FSF_QTCB_EXCHANGE_PORT_DATA with a trace tag of
"fsfcesa" and a WWPN of ZFCP_DBF_INVALID_WWPN = 0x0000000000000000 (see
FC-FS-4 ยง18 "Name_Identifier Formats", NAA field).

A change in FC Endpoint Security state of connections between FCP devices
and FC remote ports is traced as response to FSF command
FSF_QTCB_OPEN_PORT_WITH_DID with a trace tag of "fsfcesp".

Example trace record of FC Endpoint Security capability change of FCP
device formatted with zfcpdbf from s390-tools:

Timestamp      : ...
Area           : HBA
Subarea        : 00
Level          : 3
Exception      : -
CPU ID         : ...
Caller         : 0x...
Record ID      : 5                    ZFCP_DBF_HBA_FCES
Tag            : fsfcesa              FSF FC Endpoint Security adapter
Request ID     : 0x...
Request status : 0x00000010
FSF cmnd       : 0x0000000e           FSF_QTCB_EXCHANGE_PORT_DATA
FSF sequence no: 0x...
FSF issued     : ...
FSF stat       : 0x00000000           FSF_GOOD
FSF stat qual  : n/a
Prot stat      : n/a
Prot stat qual : n/a
Port handle    : 0x00000000           none (invalid)
LUN handle     : n/a
WWPN           : 0x0000000000000000   ZFCP_DBF_INVALID_WWPN
FCES old       : 0x00000000           old FC Endpoint Security
FCES new       : 0x00000007           new FC Endpoint Security

Example trace record of FC Endpoint Security change of connection to
FC remote port formatted with zfcpdbf from s390-tools:

Timestamp      : ...
Area           : HBA
Subarea        : 00
Level          : 3
Exception      : -
CPU ID         : ...
Caller         : 0x...
Record ID      : 5                    ZFCP_DBF_HBA_FCES
Tag            : fsfcesp              FSF FC Endpoint Security port
Request ID     : 0x...
Request status : 0x00000010
FSF cmnd       : 0x00000005           FSF_QTCB_OPEN_PORT_WITH_DID
FSF sequence no: 0x...
FSF issued     : ...
FSF stat       : 0x00000000           FSF_GOOD
FSF stat qual  : n/a
Prot stat      : n/a
Prot stat qual : n/a
Port handle    : 0x...
WWPN           : 0x500507630401120c   WWPN
FCES old       : 0x00000000           old FC Endpoint Security
FCES new       : 0x00000004           new FC Endpoint Security

Link: https://lore.kernel.org/r/20200312174505.51294-9-maier@linux.ibm.com
	Reviewed-by: Steffen Maier <maier@linux.ibm.com>
	Signed-off-by: Jens Remus <jremus@linux.ibm.com>
	Signed-off-by: Steffen Maier <maier@linux.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 616da39e0060f3b8bbc0f36f7d911bb5abb31746)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/scsi/zfcp_dbf.h
#	drivers/s390/scsi/zfcp_def.h
#	drivers/s390/scsi/zfcp_fsf.c
diff --cc drivers/s390/scsi/zfcp_dbf.h
index d116c07ed77a,4d1435c573bc..000000000000
--- a/drivers/s390/scsi/zfcp_dbf.h
+++ b/drivers/s390/scsi/zfcp_dbf.h
@@@ -158,6 -182,8 +178,11 @@@ struct zfcp_dbf_hba_fces 
   * @ZFCP_DBF_HBA_RES: response trace record
   * @ZFCP_DBF_HBA_USS: unsolicited status trace record
   * @ZFCP_DBF_HBA_BIT: bit error trace record
++<<<<<<< HEAD
++=======
+  * @ZFCP_DBF_HBA_BASIC: basic adapter event, only trace tag, no other data
+  * @ZFCP_DBF_HBA_FCES: FC Endpoint Security trace record
++>>>>>>> 616da39e0060 (scsi: zfcp: trace FC Endpoint Security of FCP devices and connections)
   */
  enum zfcp_dbf_hba_id {
  	ZFCP_DBF_HBA_RES	= 1,
@@@ -176,6 -203,10 +202,13 @@@
   * @fsf_seq_no: fsf sequence number
   * @pl_len: length of payload stored as zfcp_dbf_pay
   * @u: record type specific data
++<<<<<<< HEAD
++=======
+  * @u.res:  data for fsf responses
+  * @u.uss:  data for unsolicited status buffer
+  * @u.be:   data for bit error unsolicited status buffer
+  * @u.fces: data for FC Endpoint Security
++>>>>>>> 616da39e0060 (scsi: zfcp: trace FC Endpoint Security of FCP devices and connections)
   */
  struct zfcp_dbf_hba {
  	u8 id;
diff --cc drivers/s390/scsi/zfcp_def.h
index 3396a47721a7,da8a5ceb615c..000000000000
--- a/drivers/s390/scsi/zfcp_def.h
+++ b/drivers/s390/scsi/zfcp_def.h
@@@ -154,6 -158,8 +154,11 @@@ struct zfcp_adapter 
  	u32			adapter_features;  /* FCP channel features */
  	u32			connection_features; /* host connection features */
          u32			hardware_version;  /* of FCP channel */
++<<<<<<< HEAD
++=======
+ 	u32			fc_security_algorithms; /* of FCP channel */
+ 	u32			fc_security_algorithms_old; /* of FCP channel */
++>>>>>>> 616da39e0060 (scsi: zfcp: trace FC Endpoint Security of FCP devices and connections)
  	u16			timer_ticks;       /* time int for a tick */
  	struct Scsi_Host	*scsi_host;	   /* Pointer to mid-layer */
  	struct list_head	port_list;	   /* remote port list */
diff --cc drivers/s390/scsi/zfcp_fsf.c
index aaa4066c5699,1d3eac12a8c6..000000000000
--- a/drivers/s390/scsi/zfcp_fsf.c
+++ b/drivers/s390/scsi/zfcp_fsf.c
@@@ -623,6 -664,99 +623,102 @@@ static void zfcp_fsf_exchange_config_da
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Mapping of FC Endpoint Security flag masks to mnemonics
+  *
+  * NOTE: Update macro ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH when making any
+  *       changes.
+  */
+ static const struct {
+ 	u32	mask;
+ 	char	*name;
+ } zfcp_fsf_fc_security_mnemonics[] = {
+ 	{ FSF_FC_SECURITY_AUTH,		"Authentication" },
+ 	{ FSF_FC_SECURITY_ENC_FCSP2 |
+ 	  FSF_FC_SECURITY_ENC_ERAS,	"Encryption" },
+ };
+ 
+ /* maximum strlen(zfcp_fsf_fc_security_mnemonics[...].name) + 1 */
+ #define ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH 15
+ 
+ /**
+  * zfcp_fsf_scnprint_fc_security() - translate FC Endpoint Security flags into
+  *                                   mnemonics and place in a buffer
+  * @buf        : the buffer to place the translated FC Endpoint Security flag(s)
+  *               into
+  * @size       : the size of the buffer, including the trailing null space
+  * @fc_security: one or more FC Endpoint Security flags, or zero
+  * @fmt        : specifies whether a list or a single item is to be put into the
+  *               buffer
+  *
+  * The Fibre Channel (FC) Endpoint Security flags are translated into mnemonics.
+  * If the FC Endpoint Security flags are zero "none" is placed into the buffer.
+  *
+  * With ZFCP_FSF_PRINT_FMT_LIST the mnemonics are placed as a list separated by
+  * a comma followed by a space into the buffer. If one or more FC Endpoint
+  * Security flags cannot be translated into a mnemonic, as they are undefined
+  * in zfcp_fsf_fc_security_mnemonics, their bitwise ORed value in hexadecimal
+  * representation is placed into the buffer.
+  *
+  * With ZFCP_FSF_PRINT_FMT_SINGLEITEM only one single mnemonic is placed into
+  * the buffer. If the FC Endpoint Security flag cannot be translated, as it is
+  * undefined in zfcp_fsf_fc_security_mnemonics, its value in hexadecimal
+  * representation is placed into the buffer. If more than one FC Endpoint
+  * Security flag was specified, their value in hexadecimal representation is
+  * placed into the buffer. The macro ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH
+  * can be used to define a buffer that is large enough to hold one mnemonic.
+  *
+  * Return: The number of characters written into buf not including the trailing
+  *         '\0'. If size is == 0 the function returns 0.
+  */
+ ssize_t zfcp_fsf_scnprint_fc_security(char *buf, size_t size, u32 fc_security,
+ 				      enum zfcp_fsf_print_fmt fmt)
+ {
+ 	const char *prefix = "";
+ 	ssize_t len = 0;
+ 	int i;
+ 
+ 	if (fc_security == 0)
+ 		return scnprintf(buf, size, "none");
+ 	if (fmt == ZFCP_FSF_PRINT_FMT_SINGLEITEM && hweight32(fc_security) != 1)
+ 		return scnprintf(buf, size, "0x%08x", fc_security);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(zfcp_fsf_fc_security_mnemonics); i++) {
+ 		if (!(fc_security & zfcp_fsf_fc_security_mnemonics[i].mask))
+ 			continue;
+ 
+ 		len += scnprintf(buf + len, size - len, "%s%s", prefix,
+ 				 zfcp_fsf_fc_security_mnemonics[i].name);
+ 		prefix = ", ";
+ 		fc_security &= ~zfcp_fsf_fc_security_mnemonics[i].mask;
+ 	}
+ 
+ 	if (fc_security != 0)
+ 		len += scnprintf(buf + len, size - len, "%s0x%08x",
+ 				 prefix, fc_security);
+ 
+ 	return len;
+ }
+ 
+ static void zfcp_fsf_dbf_adapter_fc_security(struct zfcp_adapter *adapter,
+ 					     struct zfcp_fsf_req *req)
+ {
+ 	if (adapter->fc_security_algorithms ==
+ 	    adapter->fc_security_algorithms_old) {
+ 		/* no change, no trace */
+ 		return;
+ 	}
+ 
+ 	zfcp_dbf_hba_fsf_fces("fsfcesa", req, ZFCP_DBF_INVALID_WWPN,
+ 			      adapter->fc_security_algorithms_old,
+ 			      adapter->fc_security_algorithms);
+ 
+ 	adapter->fc_security_algorithms_old = adapter->fc_security_algorithms;
+ }
+ 
++>>>>>>> 616da39e0060 (scsi: zfcp: trace FC Endpoint Security of FCP devices and connections)
  static void zfcp_fsf_exchange_port_evaluate(struct zfcp_fsf_req *req)
  {
  	struct zfcp_adapter *adapter = req->adapter;
@@@ -643,6 -774,12 +739,15 @@@
  	       FC_FC4_LIST_SIZE);
  	memcpy(fc_host_active_fc4s(shost), bottom->active_fc4_types,
  	       FC_FC4_LIST_SIZE);
++<<<<<<< HEAD
++=======
+ 	if (adapter->adapter_features & FSF_FEATURE_FC_SECURITY)
+ 		adapter->fc_security_algorithms =
+ 			bottom->fc_security_algorithms;
+ 	else
+ 		adapter->fc_security_algorithms = 0;
+ 	zfcp_fsf_dbf_adapter_fc_security(adapter, req);
++>>>>>>> 616da39e0060 (scsi: zfcp: trace FC Endpoint Security of FCP devices and connections)
  }
  
  static void zfcp_fsf_exchange_port_data_handler(struct zfcp_fsf_req *req)
@@@ -1388,6 -1596,55 +1493,58 @@@ out_unlock
  	return retval;
  }
  
++<<<<<<< HEAD
++=======
+ static void zfcp_fsf_log_port_fc_security(struct zfcp_port *port,
+ 					  struct zfcp_fsf_req *req)
+ {
+ 	char mnemonic_old[ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH];
+ 	char mnemonic_new[ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH];
+ 
+ 	if (port->connection_info == port->connection_info_old) {
+ 		/* no change, no log nor trace */
+ 		return;
+ 	}
+ 
+ 	zfcp_dbf_hba_fsf_fces("fsfcesp", req, port->wwpn,
+ 			      port->connection_info_old,
+ 			      port->connection_info);
+ 
+ 	zfcp_fsf_scnprint_fc_security(mnemonic_old, sizeof(mnemonic_old),
+ 				      port->connection_info_old,
+ 				      ZFCP_FSF_PRINT_FMT_SINGLEITEM);
+ 	zfcp_fsf_scnprint_fc_security(mnemonic_new, sizeof(mnemonic_new),
+ 				      port->connection_info,
+ 				      ZFCP_FSF_PRINT_FMT_SINGLEITEM);
+ 
+ 	if (strncmp(mnemonic_old, mnemonic_new,
+ 		    ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH) == 0) {
+ 		/* no change in string representation, no log */
+ 		goto out;
+ 	}
+ 
+ 	if (port->connection_info_old == 0) {
+ 		/* activation */
+ 		dev_info(&port->adapter->ccw_device->dev,
+ 			 "FC Endpoint Security of connection to remote port 0x%16llx enabled: %s\n",
+ 			 port->wwpn, mnemonic_new);
+ 	} else if (port->connection_info == 0) {
+ 		/* deactivation */
+ 		dev_warn(&port->adapter->ccw_device->dev,
+ 			 "FC Endpoint Security of connection to remote port 0x%16llx disabled: was %s\n",
+ 			 port->wwpn, mnemonic_old);
+ 	} else {
+ 		/* change */
+ 		dev_warn(&port->adapter->ccw_device->dev,
+ 			 "FC Endpoint Security of connection to remote port 0x%16llx changed: from %s to %s\n",
+ 			 port->wwpn, mnemonic_old, mnemonic_new);
+ 	}
+ 
+ out:
+ 	port->connection_info_old = port->connection_info;
+ }
+ 
++>>>>>>> 616da39e0060 (scsi: zfcp: trace FC Endpoint Security of FCP devices and connections)
  static void zfcp_fsf_open_port_handler(struct zfcp_fsf_req *req)
  {
  	struct zfcp_adapter *adapter = req->adapter;
@@@ -1424,6 -1681,11 +1581,14 @@@
  		break;
  	case FSF_GOOD:
  		port->handle = header->port_handle;
++<<<<<<< HEAD
++=======
+ 		if (adapter->adapter_features & FSF_FEATURE_FC_SECURITY)
+ 			port->connection_info = bottom->connection_info;
+ 		else
+ 			port->connection_info = 0;
+ 		zfcp_fsf_log_port_fc_security(port, req);
++>>>>>>> 616da39e0060 (scsi: zfcp: trace FC Endpoint Security of FCP devices and connections)
  		atomic_or(ZFCP_STATUS_COMMON_OPEN |
  				ZFCP_STATUS_PORT_PHYS_OPEN, &port->status);
  		atomic_andnot(ZFCP_STATUS_COMMON_ACCESS_BOXED,
diff --git a/drivers/s390/scsi/zfcp_dbf.c b/drivers/s390/scsi/zfcp_dbf.c
index 3b368fcf13f4..bb849ab43957 100644
--- a/drivers/s390/scsi/zfcp_dbf.c
+++ b/drivers/s390/scsi/zfcp_dbf.c
@@ -4,7 +4,7 @@
  *
  * Debug traces for zfcp.
  *
- * Copyright IBM Corp. 2002, 2018
+ * Copyright IBM Corp. 2002, 2020
  */
 
 #define KMSG_COMPONENT "zfcp"
@@ -104,6 +104,48 @@ void zfcp_dbf_hba_fsf_res(char *tag, int level, struct zfcp_fsf_req *req)
 	spin_unlock_irqrestore(&dbf->hba_lock, flags);
 }
 
+/**
+ * zfcp_dbf_hba_fsf_fces - trace event for fsf responses related to
+ *			   FC Endpoint Security (FCES)
+ * @tag: tag indicating which kind of FC Endpoint Security event has occurred
+ * @req: request for which a response was received
+ * @wwpn: remote port or ZFCP_DBF_INVALID_WWPN
+ * @fc_security_old: old FC Endpoint Security of FCP device or connection
+ * @fc_security_new: new FC Endpoint Security of FCP device or connection
+ */
+void zfcp_dbf_hba_fsf_fces(char *tag, const struct zfcp_fsf_req *req, u64 wwpn,
+			   u32 fc_security_old, u32 fc_security_new)
+{
+	struct zfcp_dbf *dbf = req->adapter->dbf;
+	struct fsf_qtcb_prefix *q_pref = &req->qtcb->prefix;
+	struct fsf_qtcb_header *q_head = &req->qtcb->header;
+	struct zfcp_dbf_hba *rec = &dbf->hba_buf;
+	static int const level = 3;
+	unsigned long flags;
+
+	if (unlikely(!debug_level_enabled(dbf->hba, level)))
+		return;
+
+	spin_lock_irqsave(&dbf->hba_lock, flags);
+	memset(rec, 0, sizeof(*rec));
+
+	memcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);
+	rec->id = ZFCP_DBF_HBA_FCES;
+	rec->fsf_req_id = req->req_id;
+	rec->fsf_req_status = req->status;
+	rec->fsf_cmd = q_head->fsf_command;
+	rec->fsf_seq_no = q_pref->req_seq_no;
+	rec->u.fces.req_issued = req->issued;
+	rec->u.fces.fsf_status = q_head->fsf_status;
+	rec->u.fces.port_handle = q_head->port_handle;
+	rec->u.fces.wwpn = wwpn;
+	rec->u.fces.fc_security_old = fc_security_old;
+	rec->u.fces.fc_security_new = fc_security_new;
+
+	debug_event(dbf->hba, level, rec, sizeof(*rec));
+	spin_unlock_irqrestore(&dbf->hba_lock, flags);
+}
+
 /**
  * zfcp_dbf_hba_fsf_uss - trace event for an unsolicited status buffer
  * @tag: tag indicating which kind of unsolicited status has been received
* Unmerged path drivers/s390/scsi/zfcp_dbf.h
* Unmerged path drivers/s390/scsi/zfcp_def.h
diff --git a/drivers/s390/scsi/zfcp_ext.h b/drivers/s390/scsi/zfcp_ext.h
index f75d5680e5ba..1f38373e95a7 100644
--- a/drivers/s390/scsi/zfcp_ext.h
+++ b/drivers/s390/scsi/zfcp_ext.h
@@ -44,6 +44,9 @@ extern void zfcp_dbf_rec_run_lvl(int level, char *tag,
 extern void zfcp_dbf_rec_run_wka(char *, struct zfcp_fc_wka_port *, u64);
 extern void zfcp_dbf_hba_fsf_uss(char *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_fsf_res(char *, int, struct zfcp_fsf_req *);
+extern void zfcp_dbf_hba_fsf_fces(char *tag, const struct zfcp_fsf_req *req,
+				  u64 wwpn, u32 fc_security_old,
+				  u32 fc_security_new);
 extern void zfcp_dbf_hba_bit_err(char *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_def_err(struct zfcp_adapter *, u64, u16, void **);
 extern void zfcp_dbf_hba_basic(char *, struct zfcp_adapter *);
* Unmerged path drivers/s390/scsi/zfcp_fsf.c
