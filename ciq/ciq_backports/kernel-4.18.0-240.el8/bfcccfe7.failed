netdevsim: drop code duplicated by a merge

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit bfcccfe78b361f5f6ef48554aed5bcd30c72f67f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/bfcccfe7.failed

Looks like the port adding loop makes a re-appearance on net-next
after net was merged back into it (even though it doesn't feature
in the merge diff).

The ports are already added in nsim_dev_create() so when we try
to add them again get EEXIST, and see:

netdevsim: probe of netdevsim0 failed with error -17

in the logs. When we remove the loop again the nsim_dev_probe()
and nsim_dev_remove() become a wrapper of nsim_dev_create() and
nsim_dev_destroy(). Remove this layer of indirection.

Fixes: d31e95585ca6 ("Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net")
	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bfcccfe78b361f5f6ef48554aed5bcd30c72f67f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/netdevsim/dev.c
diff --cc drivers/net/netdevsim/dev.c
index 863a10803cdb,3da96c7e8265..000000000000
--- a/drivers/net/netdevsim/dev.c
+++ b/drivers/net/netdevsim/dev.c
@@@ -810,39 -688,192 +810,227 @@@ static void nsim_dev_port_del_all(struc
  	mutex_unlock(&nsim_dev->port_list_lock);
  }
  
++<<<<<<< HEAD
 +int nsim_dev_probe(struct nsim_bus_dev *nsim_bus_dev)
 +{
 +	struct nsim_dev *nsim_dev;
 +	int i;
 +	int err;
 +
 +	nsim_dev = nsim_dev_create(nsim_bus_dev, nsim_bus_dev->port_count);
 +	if (IS_ERR(nsim_dev))
 +		return PTR_ERR(nsim_dev);
 +	dev_set_drvdata(&nsim_bus_dev->dev, nsim_dev);
 +
 +	mutex_lock(&nsim_dev->port_list_lock);
 +	for (i = 0; i < nsim_bus_dev->port_count; i++) {
++=======
+ static int nsim_dev_port_add_all(struct nsim_dev *nsim_dev,
+ 				 unsigned int port_count)
+ {
+ 	int i, err;
+ 
+ 	for (i = 0; i < port_count; i++) {
++>>>>>>> bfcccfe78b36 (netdevsim: drop code duplicated by a merge)
  		err = __nsim_dev_port_add(nsim_dev, i);
  		if (err)
  			goto err_port_del_all;
  	}
++<<<<<<< HEAD
 +	mutex_unlock(&nsim_dev->port_list_lock);
 +	return 0;
 +
 +err_port_del_all:
 +	mutex_unlock(&nsim_dev->port_list_lock);
 +	nsim_dev_port_del_all(nsim_dev);
 +	nsim_dev_destroy(nsim_dev);
 +	return err;
 +}
 +
 +void nsim_dev_remove(struct nsim_bus_dev *nsim_bus_dev)
 +{
 +	struct nsim_dev *nsim_dev = dev_get_drvdata(&nsim_bus_dev->dev);
 +
 +	nsim_dev_port_del_all(nsim_dev);
 +	nsim_dev_destroy(nsim_dev);
++=======
+ 	return 0;
+ 
+ err_port_del_all:
+ 	nsim_dev_port_del_all(nsim_dev);
+ 	return err;
+ }
+ 
+ static int nsim_dev_reload_create(struct nsim_dev *nsim_dev,
+ 				  struct netlink_ext_ack *extack)
+ {
+ 	struct nsim_bus_dev *nsim_bus_dev = nsim_dev->nsim_bus_dev;
+ 	struct devlink *devlink;
+ 	int err;
+ 
+ 	devlink = priv_to_devlink(nsim_dev);
+ 	nsim_dev = devlink_priv(devlink);
+ 	INIT_LIST_HEAD(&nsim_dev->port_list);
+ 	mutex_init(&nsim_dev->port_list_lock);
+ 	nsim_dev->fw_update_status = true;
+ 
+ 	nsim_dev->fib_data = nsim_fib_create(devlink, extack);
+ 	if (IS_ERR(nsim_dev->fib_data))
+ 		return PTR_ERR(nsim_dev->fib_data);
+ 
+ 	nsim_devlink_param_load_driverinit_values(devlink);
+ 
+ 	err = nsim_dev_dummy_region_init(nsim_dev, devlink);
+ 	if (err)
+ 		goto err_fib_destroy;
+ 
+ 	err = nsim_dev_traps_init(devlink);
+ 	if (err)
+ 		goto err_dummy_region_exit;
+ 
+ 	err = nsim_dev_health_init(nsim_dev, devlink);
+ 	if (err)
+ 		goto err_traps_exit;
+ 
+ 	err = nsim_dev_port_add_all(nsim_dev, nsim_bus_dev->port_count);
+ 	if (err)
+ 		goto err_health_exit;
+ 
+ 	return 0;
+ 
+ err_health_exit:
+ 	nsim_dev_health_exit(nsim_dev);
+ err_traps_exit:
+ 	nsim_dev_traps_exit(devlink);
+ err_dummy_region_exit:
+ 	nsim_dev_dummy_region_exit(nsim_dev);
+ err_fib_destroy:
+ 	nsim_fib_destroy(devlink, nsim_dev->fib_data);
+ 	return err;
+ }
+ 
+ int nsim_dev_probe(struct nsim_bus_dev *nsim_bus_dev)
+ {
+ 	struct nsim_dev *nsim_dev;
+ 	struct devlink *devlink;
+ 	int err;
+ 
+ 	devlink = devlink_alloc(&nsim_dev_devlink_ops, sizeof(*nsim_dev));
+ 	if (!devlink)
+ 		return -ENOMEM;
+ 	devlink_net_set(devlink, nsim_bus_dev->initial_net);
+ 	nsim_dev = devlink_priv(devlink);
+ 	nsim_dev->nsim_bus_dev = nsim_bus_dev;
+ 	nsim_dev->switch_id.id_len = sizeof(nsim_dev->switch_id.id);
+ 	get_random_bytes(nsim_dev->switch_id.id, nsim_dev->switch_id.id_len);
+ 	INIT_LIST_HEAD(&nsim_dev->port_list);
+ 	mutex_init(&nsim_dev->port_list_lock);
+ 	nsim_dev->fw_update_status = true;
+ 	nsim_dev->max_macs = NSIM_DEV_MAX_MACS_DEFAULT;
+ 	nsim_dev->test1 = NSIM_DEV_TEST1_DEFAULT;
+ 
+ 	dev_set_drvdata(&nsim_bus_dev->dev, nsim_dev);
+ 
+ 	err = nsim_dev_resources_register(devlink);
+ 	if (err)
+ 		goto err_devlink_free;
+ 
+ 	nsim_dev->fib_data = nsim_fib_create(devlink, NULL);
+ 	if (IS_ERR(nsim_dev->fib_data)) {
+ 		err = PTR_ERR(nsim_dev->fib_data);
+ 		goto err_resources_unregister;
+ 	}
+ 
+ 	err = devlink_register(devlink, &nsim_bus_dev->dev);
+ 	if (err)
+ 		goto err_fib_destroy;
+ 
+ 	err = devlink_params_register(devlink, nsim_devlink_params,
+ 				      ARRAY_SIZE(nsim_devlink_params));
+ 	if (err)
+ 		goto err_dl_unregister;
+ 	nsim_devlink_set_params_init_values(nsim_dev, devlink);
+ 
+ 	err = nsim_dev_dummy_region_init(nsim_dev, devlink);
+ 	if (err)
+ 		goto err_params_unregister;
+ 
+ 	err = nsim_dev_traps_init(devlink);
+ 	if (err)
+ 		goto err_dummy_region_exit;
+ 
+ 	err = nsim_dev_debugfs_init(nsim_dev);
+ 	if (err)
+ 		goto err_traps_exit;
+ 
+ 	err = nsim_dev_health_init(nsim_dev, devlink);
+ 	if (err)
+ 		goto err_debugfs_exit;
+ 
+ 	err = nsim_bpf_dev_init(nsim_dev);
+ 	if (err)
+ 		goto err_health_exit;
+ 
+ 	err = nsim_dev_port_add_all(nsim_dev, nsim_bus_dev->port_count);
+ 	if (err)
+ 		goto err_bpf_dev_exit;
+ 
+ 	devlink_params_publish(devlink);
+ 	return 0;
+ 
+ err_bpf_dev_exit:
+ 	nsim_bpf_dev_exit(nsim_dev);
+ err_health_exit:
+ 	nsim_dev_health_exit(nsim_dev);
+ err_debugfs_exit:
+ 	nsim_dev_debugfs_exit(nsim_dev);
+ err_traps_exit:
+ 	nsim_dev_traps_exit(devlink);
+ err_dummy_region_exit:
+ 	nsim_dev_dummy_region_exit(nsim_dev);
+ err_params_unregister:
+ 	devlink_params_unregister(devlink, nsim_devlink_params,
+ 				  ARRAY_SIZE(nsim_devlink_params));
+ err_dl_unregister:
+ 	devlink_unregister(devlink);
+ err_fib_destroy:
+ 	nsim_fib_destroy(devlink, nsim_dev->fib_data);
+ err_resources_unregister:
+ 	devlink_resources_unregister(devlink, NULL);
+ err_devlink_free:
+ 	devlink_free(devlink);
+ 	return err;
+ }
+ 
+ static void nsim_dev_reload_destroy(struct nsim_dev *nsim_dev)
+ {
+ 	struct devlink *devlink = priv_to_devlink(nsim_dev);
+ 
+ 	if (devlink_is_reload_failed(devlink))
+ 		return;
+ 	nsim_dev_port_del_all(nsim_dev);
+ 	nsim_dev_health_exit(nsim_dev);
+ 	nsim_dev_traps_exit(devlink);
+ 	nsim_dev_dummy_region_exit(nsim_dev);
+ 	mutex_destroy(&nsim_dev->port_list_lock);
+ 	nsim_fib_destroy(devlink, nsim_dev->fib_data);
+ }
+ 
+ void nsim_dev_remove(struct nsim_bus_dev *nsim_bus_dev)
+ {
+ 	struct nsim_dev *nsim_dev = dev_get_drvdata(&nsim_bus_dev->dev);
+ 	struct devlink *devlink = priv_to_devlink(nsim_dev);
+ 
+ 	nsim_dev_reload_destroy(nsim_dev);
+ 
+ 	nsim_bpf_dev_exit(nsim_dev);
+ 	nsim_dev_debugfs_exit(nsim_dev);
+ 	devlink_params_unregister(devlink, nsim_devlink_params,
+ 				  ARRAY_SIZE(nsim_devlink_params));
+ 	devlink_unregister(devlink);
+ 	devlink_resources_unregister(devlink, NULL);
+ 	devlink_free(devlink);
++>>>>>>> bfcccfe78b36 (netdevsim: drop code duplicated by a merge)
  }
  
  static struct nsim_dev_port *
* Unmerged path drivers/net/netdevsim/dev.c
