kernel: add panic_on_taint

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Rafael Aquini <aquini@redhat.com>
commit db38d5c106dfdd7cb7207c83267d82fdf4950b61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/db38d5c1.failed

Analogously to the introduction of panic_on_warn, this patch introduces
a kernel option named panic_on_taint in order to provide a simple and
generic way to stop execution and catch a coredump when the kernel gets
tainted by any given flag.

This is useful for debugging sessions as it avoids having to rebuild the
kernel to explicitly add calls to panic() into the code sites that
introduce the taint flags of interest.

For instance, if one is interested in proceeding with a post-mortem
analysis at the point a given code path is hitting a bad page (i.e.
unaccount_page_cache_page(), or slab_bug()), a coredump can be collected
by rebooting the kernel with 'panic_on_taint=0x20' amended to the
command line.

Another, perhaps less frequent, use for this option would be as a means
for assuring a security policy case where only a subset of taints, or no
single taint (in paranoid mode), is allowed for the running system.  The
optional switch 'nousertaint' is handy in this particular scenario, as
it will avoid userspace induced crashes by writes to sysctl interface
/proc/sys/kernel/tainted causing false positive hits for such policies.

[akpm@linux-foundation.org: tweak kernel-parameters.txt wording]

	Suggested-by: Qian Cai <cai@lca.pw>
	Signed-off-by: Rafael Aquini <aquini@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Luis Chamberlain <mcgrof@kernel.org>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: Baoquan He <bhe@redhat.com>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Kees Cook <keescook@chromium.org>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: "Theodore Ts'o" <tytso@mit.edu>
	Cc: Adrian Bunk <bunk@kernel.org>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Laura Abbott <labbott@redhat.com>
	Cc: Jeff Mahoney <jeffm@suse.com>
	Cc: Jiri Kosina <jikos@kernel.org>
	Cc: Takashi Iwai <tiwai@suse.de>
Link: http://lkml.kernel.org/r/20200515175502.146720-1-aquini@redhat.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit db38d5c106dfdd7cb7207c83267d82fdf4950b61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/admin-guide/sysctl/kernel.rst
#	include/linux/kernel.h
#	kernel/sysctl.c
diff --cc include/linux/kernel.h
index e00b6c98fb5b,f7835db7102e..000000000000
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@@ -597,23 -597,8 +599,28 @@@ extern enum system_states 
  #define TAINT_LIVEPATCH			15
  #define TAINT_AUX			16
  #define TAINT_RANDSTRUCT		17
++<<<<<<< HEAD
 +#define TAINT_18			18
 +#define TAINT_19			19
 +#define TAINT_20			20
 +#define TAINT_21			21
 +#define TAINT_22			22
 +#define TAINT_23			23
 +#define TAINT_24			24
 +#define TAINT_25			25
 +#define TAINT_26			26
 +/* Start of Red Hat-specific taint flags */
 +#define TAINT_SUPPORT_REMOVED		27
 +#define TAINT_28			28
 +#define TAINT_TECH_PREVIEW		29
 +#define TAINT_UNPRIVILEGED_BPF		30
 +#define TAINT_31			31
 +/* End of Red Hat-specific taint flags */
 +#define TAINT_FLAGS_COUNT		32
++=======
+ #define TAINT_FLAGS_COUNT		18
+ #define TAINT_FLAGS_MAX			((1UL << TAINT_FLAGS_COUNT) - 1)
++>>>>>>> db38d5c106df (kernel: add panic_on_taint)
  
  struct taint_flag {
  	char c_true;	/* character printed when tainted */
diff --cc kernel/sysctl.c
index feda26850ef0,587ed0494f2f..000000000000
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@@ -310,6 -200,1459 +310,1462 @@@ static int min_extfrag_threshold
  static int max_extfrag_threshold = 1000;
  #endif
  
++<<<<<<< HEAD
++=======
+ #endif /* CONFIG_SYSCTL */
+ 
+ #if defined(CONFIG_BPF_SYSCALL) && defined(CONFIG_SYSCTL)
+ static int bpf_stats_handler(struct ctl_table *table, int write,
+ 			     void __user *buffer, size_t *lenp,
+ 			     loff_t *ppos)
+ {
+ 	struct static_key *key = (struct static_key *)table->data;
+ 	static int saved_val;
+ 	int val, ret;
+ 	struct ctl_table tmp = {
+ 		.data   = &val,
+ 		.maxlen = sizeof(val),
+ 		.mode   = table->mode,
+ 		.extra1 = SYSCTL_ZERO,
+ 		.extra2 = SYSCTL_ONE,
+ 	};
+ 
+ 	if (write && !capable(CAP_SYS_ADMIN))
+ 		return -EPERM;
+ 
+ 	mutex_lock(&bpf_stats_enabled_mutex);
+ 	val = saved_val;
+ 	ret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);
+ 	if (write && !ret && val != saved_val) {
+ 		if (val)
+ 			static_key_slow_inc(key);
+ 		else
+ 			static_key_slow_dec(key);
+ 		saved_val = val;
+ 	}
+ 	mutex_unlock(&bpf_stats_enabled_mutex);
+ 	return ret;
+ }
+ #endif
+ 
+ /*
+  * /proc/sys support
+  */
+ 
+ #ifdef CONFIG_PROC_SYSCTL
+ 
+ static int _proc_do_string(char *data, int maxlen, int write,
+ 		char *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	size_t len;
+ 	char c, *p;
+ 
+ 	if (!data || !maxlen || !*lenp) {
+ 		*lenp = 0;
+ 		return 0;
+ 	}
+ 
+ 	if (write) {
+ 		if (sysctl_writes_strict == SYSCTL_WRITES_STRICT) {
+ 			/* Only continue writes not past the end of buffer. */
+ 			len = strlen(data);
+ 			if (len > maxlen - 1)
+ 				len = maxlen - 1;
+ 
+ 			if (*ppos > len)
+ 				return 0;
+ 			len = *ppos;
+ 		} else {
+ 			/* Start writing from beginning of buffer. */
+ 			len = 0;
+ 		}
+ 
+ 		*ppos += *lenp;
+ 		p = buffer;
+ 		while ((p - buffer) < *lenp && len < maxlen - 1) {
+ 			c = *(p++);
+ 			if (c == 0 || c == '\n')
+ 				break;
+ 			data[len++] = c;
+ 		}
+ 		data[len] = 0;
+ 	} else {
+ 		len = strlen(data);
+ 		if (len > maxlen)
+ 			len = maxlen;
+ 
+ 		if (*ppos > len) {
+ 			*lenp = 0;
+ 			return 0;
+ 		}
+ 
+ 		data += *ppos;
+ 		len  -= *ppos;
+ 
+ 		if (len > *lenp)
+ 			len = *lenp;
+ 		if (len)
+ 			memcpy(buffer, data, len);
+ 		if (len < *lenp) {
+ 			buffer[len] = '\n';
+ 			len++;
+ 		}
+ 		*lenp = len;
+ 		*ppos += len;
+ 	}
+ 	return 0;
+ }
+ 
+ static void warn_sysctl_write(struct ctl_table *table)
+ {
+ 	pr_warn_once("%s wrote to %s when file position was not 0!\n"
+ 		"This will not be supported in the future. To silence this\n"
+ 		"warning, set kernel.sysctl_writes_strict = -1\n",
+ 		current->comm, table->procname);
+ }
+ 
+ /**
+  * proc_first_pos_non_zero_ignore - check if first position is allowed
+  * @ppos: file position
+  * @table: the sysctl table
+  *
+  * Returns true if the first position is non-zero and the sysctl_writes_strict
+  * mode indicates this is not allowed for numeric input types. String proc
+  * handlers can ignore the return value.
+  */
+ static bool proc_first_pos_non_zero_ignore(loff_t *ppos,
+ 					   struct ctl_table *table)
+ {
+ 	if (!*ppos)
+ 		return false;
+ 
+ 	switch (sysctl_writes_strict) {
+ 	case SYSCTL_WRITES_STRICT:
+ 		return true;
+ 	case SYSCTL_WRITES_WARN:
+ 		warn_sysctl_write(table);
+ 		return false;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ /**
+  * proc_dostring - read a string sysctl
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes a string from/to the user buffer. If the kernel
+  * buffer provided is not large enough to hold the string, the
+  * string is truncated. The copied string is %NULL-terminated.
+  * If the string is being read by the user process, it is copied
+  * and a newline '\n' is added. It is truncated if the buffer is
+  * not large enough.
+  *
+  * Returns 0 on success.
+  */
+ int proc_dostring(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	if (write)
+ 		proc_first_pos_non_zero_ignore(ppos, table);
+ 
+ 	return _proc_do_string(table->data, table->maxlen, write, buffer, lenp,
+ 			ppos);
+ }
+ 
+ static size_t proc_skip_spaces(char **buf)
+ {
+ 	size_t ret;
+ 	char *tmp = skip_spaces(*buf);
+ 	ret = tmp - *buf;
+ 	*buf = tmp;
+ 	return ret;
+ }
+ 
+ static void proc_skip_char(char **buf, size_t *size, const char v)
+ {
+ 	while (*size) {
+ 		if (**buf != v)
+ 			break;
+ 		(*size)--;
+ 		(*buf)++;
+ 	}
+ }
+ 
+ /**
+  * strtoul_lenient - parse an ASCII formatted integer from a buffer and only
+  *                   fail on overflow
+  *
+  * @cp: kernel buffer containing the string to parse
+  * @endp: pointer to store the trailing characters
+  * @base: the base to use
+  * @res: where the parsed integer will be stored
+  *
+  * In case of success 0 is returned and @res will contain the parsed integer,
+  * @endp will hold any trailing characters.
+  * This function will fail the parse on overflow. If there wasn't an overflow
+  * the function will defer the decision what characters count as invalid to the
+  * caller.
+  */
+ static int strtoul_lenient(const char *cp, char **endp, unsigned int base,
+ 			   unsigned long *res)
+ {
+ 	unsigned long long result;
+ 	unsigned int rv;
+ 
+ 	cp = _parse_integer_fixup_radix(cp, &base);
+ 	rv = _parse_integer(cp, base, &result);
+ 	if ((rv & KSTRTOX_OVERFLOW) || (result != (unsigned long)result))
+ 		return -ERANGE;
+ 
+ 	cp += rv;
+ 
+ 	if (endp)
+ 		*endp = (char *)cp;
+ 
+ 	*res = (unsigned long)result;
+ 	return 0;
+ }
+ 
+ #define TMPBUFLEN 22
+ /**
+  * proc_get_long - reads an ASCII formatted integer from a user buffer
+  *
+  * @buf: a kernel buffer
+  * @size: size of the kernel buffer
+  * @val: this is where the number will be stored
+  * @neg: set to %TRUE if number is negative
+  * @perm_tr: a vector which contains the allowed trailers
+  * @perm_tr_len: size of the perm_tr vector
+  * @tr: pointer to store the trailer character
+  *
+  * In case of success %0 is returned and @buf and @size are updated with
+  * the amount of bytes read. If @tr is non-NULL and a trailing
+  * character exists (size is non-zero after returning from this
+  * function), @tr is updated with the trailing character.
+  */
+ static int proc_get_long(char **buf, size_t *size,
+ 			  unsigned long *val, bool *neg,
+ 			  const char *perm_tr, unsigned perm_tr_len, char *tr)
+ {
+ 	int len;
+ 	char *p, tmp[TMPBUFLEN];
+ 
+ 	if (!*size)
+ 		return -EINVAL;
+ 
+ 	len = *size;
+ 	if (len > TMPBUFLEN - 1)
+ 		len = TMPBUFLEN - 1;
+ 
+ 	memcpy(tmp, *buf, len);
+ 
+ 	tmp[len] = 0;
+ 	p = tmp;
+ 	if (*p == '-' && *size > 1) {
+ 		*neg = true;
+ 		p++;
+ 	} else
+ 		*neg = false;
+ 	if (!isdigit(*p))
+ 		return -EINVAL;
+ 
+ 	if (strtoul_lenient(p, &p, 0, val))
+ 		return -EINVAL;
+ 
+ 	len = p - tmp;
+ 
+ 	/* We don't know if the next char is whitespace thus we may accept
+ 	 * invalid integers (e.g. 1234...a) or two integers instead of one
+ 	 * (e.g. 123...1). So lets not allow such large numbers. */
+ 	if (len == TMPBUFLEN - 1)
+ 		return -EINVAL;
+ 
+ 	if (len < *size && perm_tr_len && !memchr(perm_tr, *p, perm_tr_len))
+ 		return -EINVAL;
+ 
+ 	if (tr && (len < *size))
+ 		*tr = *p;
+ 
+ 	*buf += len;
+ 	*size -= len;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * proc_put_long - converts an integer to a decimal ASCII formatted string
+  *
+  * @buf: the user buffer
+  * @size: the size of the user buffer
+  * @val: the integer to be converted
+  * @neg: sign of the number, %TRUE for negative
+  *
+  * In case of success @buf and @size are updated with the amount of bytes
+  * written.
+  */
+ static void proc_put_long(void **buf, size_t *size, unsigned long val, bool neg)
+ {
+ 	int len;
+ 	char tmp[TMPBUFLEN], *p = tmp;
+ 
+ 	sprintf(p, "%s%lu", neg ? "-" : "", val);
+ 	len = strlen(tmp);
+ 	if (len > *size)
+ 		len = *size;
+ 	memcpy(*buf, tmp, len);
+ 	*size -= len;
+ 	*buf += len;
+ }
+ #undef TMPBUFLEN
+ 
+ static void proc_put_char(void **buf, size_t *size, char c)
+ {
+ 	if (*size) {
+ 		char **buffer = (char **)buf;
+ 		**buffer = c;
+ 
+ 		(*size)--;
+ 		(*buffer)++;
+ 		*buf = *buffer;
+ 	}
+ }
+ 
+ static int do_proc_dointvec_conv(bool *negp, unsigned long *lvalp,
+ 				 int *valp,
+ 				 int write, void *data)
+ {
+ 	if (write) {
+ 		if (*negp) {
+ 			if (*lvalp > (unsigned long) INT_MAX + 1)
+ 				return -EINVAL;
+ 			*valp = -*lvalp;
+ 		} else {
+ 			if (*lvalp > (unsigned long) INT_MAX)
+ 				return -EINVAL;
+ 			*valp = *lvalp;
+ 		}
+ 	} else {
+ 		int val = *valp;
+ 		if (val < 0) {
+ 			*negp = true;
+ 			*lvalp = -(unsigned long)val;
+ 		} else {
+ 			*negp = false;
+ 			*lvalp = (unsigned long)val;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
+ static int do_proc_douintvec_conv(unsigned long *lvalp,
+ 				  unsigned int *valp,
+ 				  int write, void *data)
+ {
+ 	if (write) {
+ 		if (*lvalp > UINT_MAX)
+ 			return -EINVAL;
+ 		*valp = *lvalp;
+ 	} else {
+ 		unsigned int val = *valp;
+ 		*lvalp = (unsigned long)val;
+ 	}
+ 	return 0;
+ }
+ 
+ static const char proc_wspace_sep[] = { ' ', '\t', '\n' };
+ 
+ static int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,
+ 		  int write, void *buffer,
+ 		  size_t *lenp, loff_t *ppos,
+ 		  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,
+ 			      int write, void *data),
+ 		  void *data)
+ {
+ 	int *i, vleft, first = 1, err = 0;
+ 	size_t left;
+ 	char *p;
+ 	
+ 	if (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {
+ 		*lenp = 0;
+ 		return 0;
+ 	}
+ 	
+ 	i = (int *) tbl_data;
+ 	vleft = table->maxlen / sizeof(*i);
+ 	left = *lenp;
+ 
+ 	if (!conv)
+ 		conv = do_proc_dointvec_conv;
+ 
+ 	if (write) {
+ 		if (proc_first_pos_non_zero_ignore(ppos, table))
+ 			goto out;
+ 
+ 		if (left > PAGE_SIZE - 1)
+ 			left = PAGE_SIZE - 1;
+ 		p = buffer;
+ 	}
+ 
+ 	for (; left && vleft--; i++, first=0) {
+ 		unsigned long lval;
+ 		bool neg;
+ 
+ 		if (write) {
+ 			left -= proc_skip_spaces(&p);
+ 
+ 			if (!left)
+ 				break;
+ 			err = proc_get_long(&p, &left, &lval, &neg,
+ 					     proc_wspace_sep,
+ 					     sizeof(proc_wspace_sep), NULL);
+ 			if (err)
+ 				break;
+ 			if (conv(&neg, &lval, i, 1, data)) {
+ 				err = -EINVAL;
+ 				break;
+ 			}
+ 		} else {
+ 			if (conv(&neg, &lval, i, 0, data)) {
+ 				err = -EINVAL;
+ 				break;
+ 			}
+ 			if (!first)
+ 				proc_put_char(&buffer, &left, '\t');
+ 			proc_put_long(&buffer, &left, lval, neg);
+ 		}
+ 	}
+ 
+ 	if (!write && !first && left && !err)
+ 		proc_put_char(&buffer, &left, '\n');
+ 	if (write && !err && left)
+ 		left -= proc_skip_spaces(&p);
+ 	if (write && first)
+ 		return err ? : -EINVAL;
+ 	*lenp -= left;
+ out:
+ 	*ppos += *lenp;
+ 	return err;
+ }
+ 
+ static int do_proc_dointvec(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos,
+ 		  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,
+ 			      int write, void *data),
+ 		  void *data)
+ {
+ 	return __do_proc_dointvec(table->data, table, write,
+ 			buffer, lenp, ppos, conv, data);
+ }
+ 
+ static int do_proc_douintvec_w(unsigned int *tbl_data,
+ 			       struct ctl_table *table,
+ 			       void *buffer,
+ 			       size_t *lenp, loff_t *ppos,
+ 			       int (*conv)(unsigned long *lvalp,
+ 					   unsigned int *valp,
+ 					   int write, void *data),
+ 			       void *data)
+ {
+ 	unsigned long lval;
+ 	int err = 0;
+ 	size_t left;
+ 	bool neg;
+ 	char *p = buffer;
+ 
+ 	left = *lenp;
+ 
+ 	if (proc_first_pos_non_zero_ignore(ppos, table))
+ 		goto bail_early;
+ 
+ 	if (left > PAGE_SIZE - 1)
+ 		left = PAGE_SIZE - 1;
+ 
+ 	left -= proc_skip_spaces(&p);
+ 	if (!left) {
+ 		err = -EINVAL;
+ 		goto out_free;
+ 	}
+ 
+ 	err = proc_get_long(&p, &left, &lval, &neg,
+ 			     proc_wspace_sep,
+ 			     sizeof(proc_wspace_sep), NULL);
+ 	if (err || neg) {
+ 		err = -EINVAL;
+ 		goto out_free;
+ 	}
+ 
+ 	if (conv(&lval, tbl_data, 1, data)) {
+ 		err = -EINVAL;
+ 		goto out_free;
+ 	}
+ 
+ 	if (!err && left)
+ 		left -= proc_skip_spaces(&p);
+ 
+ out_free:
+ 	if (err)
+ 		return -EINVAL;
+ 
+ 	return 0;
+ 
+ 	/* This is in keeping with old __do_proc_dointvec() */
+ bail_early:
+ 	*ppos += *lenp;
+ 	return err;
+ }
+ 
+ static int do_proc_douintvec_r(unsigned int *tbl_data, void *buffer,
+ 			       size_t *lenp, loff_t *ppos,
+ 			       int (*conv)(unsigned long *lvalp,
+ 					   unsigned int *valp,
+ 					   int write, void *data),
+ 			       void *data)
+ {
+ 	unsigned long lval;
+ 	int err = 0;
+ 	size_t left;
+ 
+ 	left = *lenp;
+ 
+ 	if (conv(&lval, tbl_data, 0, data)) {
+ 		err = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	proc_put_long(&buffer, &left, lval, false);
+ 	if (!left)
+ 		goto out;
+ 
+ 	proc_put_char(&buffer, &left, '\n');
+ 
+ out:
+ 	*lenp -= left;
+ 	*ppos += *lenp;
+ 
+ 	return err;
+ }
+ 
+ static int __do_proc_douintvec(void *tbl_data, struct ctl_table *table,
+ 			       int write, void *buffer,
+ 			       size_t *lenp, loff_t *ppos,
+ 			       int (*conv)(unsigned long *lvalp,
+ 					   unsigned int *valp,
+ 					   int write, void *data),
+ 			       void *data)
+ {
+ 	unsigned int *i, vleft;
+ 
+ 	if (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {
+ 		*lenp = 0;
+ 		return 0;
+ 	}
+ 
+ 	i = (unsigned int *) tbl_data;
+ 	vleft = table->maxlen / sizeof(*i);
+ 
+ 	/*
+ 	 * Arrays are not supported, keep this simple. *Do not* add
+ 	 * support for them.
+ 	 */
+ 	if (vleft != 1) {
+ 		*lenp = 0;
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!conv)
+ 		conv = do_proc_douintvec_conv;
+ 
+ 	if (write)
+ 		return do_proc_douintvec_w(i, table, buffer, lenp, ppos,
+ 					   conv, data);
+ 	return do_proc_douintvec_r(i, buffer, lenp, ppos, conv, data);
+ }
+ 
+ static int do_proc_douintvec(struct ctl_table *table, int write,
+ 			     void *buffer, size_t *lenp, loff_t *ppos,
+ 			     int (*conv)(unsigned long *lvalp,
+ 					 unsigned int *valp,
+ 					 int write, void *data),
+ 			     void *data)
+ {
+ 	return __do_proc_douintvec(table->data, table, write,
+ 				   buffer, lenp, ppos, conv, data);
+ }
+ 
+ /**
+  * proc_dointvec - read a vector of integers
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
+  * values from/to the user buffer, treated as an ASCII string. 
+  *
+  * Returns 0 on success.
+  */
+ int proc_dointvec(struct ctl_table *table, int write, void *buffer,
+ 		  size_t *lenp, loff_t *ppos)
+ {
+ 	return do_proc_dointvec(table, write, buffer, lenp, ppos, NULL, NULL);
+ }
+ 
+ #ifdef CONFIG_COMPACTION
+ static int proc_dointvec_minmax_warn_RT_change(struct ctl_table *table,
+ 		int write, void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int ret, old;
+ 
+ 	if (!IS_ENABLED(CONFIG_PREEMPT_RT) || !write)
+ 		return proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+ 
+ 	old = *(int *)table->data;
+ 	ret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+ 	if (ret)
+ 		return ret;
+ 	if (old != *(int *)table->data)
+ 		pr_warn_once("sysctl attribute %s changed by %s[%d]\n",
+ 			     table->procname, current->comm,
+ 			     task_pid_nr(current));
+ 	return ret;
+ }
+ #endif
+ 
+ /**
+  * proc_douintvec - read a vector of unsigned integers
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) unsigned integer
+  * values from/to the user buffer, treated as an ASCII string.
+  *
+  * Returns 0 on success.
+  */
+ int proc_douintvec(struct ctl_table *table, int write, void *buffer,
+ 		size_t *lenp, loff_t *ppos)
+ {
+ 	return do_proc_douintvec(table, write, buffer, lenp, ppos,
+ 				 do_proc_douintvec_conv, NULL);
+ }
+ 
+ /*
+  * Taint values can only be increased
+  * This means we can safely use a temporary.
+  */
+ static int proc_taint(struct ctl_table *table, int write,
+ 			       void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	struct ctl_table t;
+ 	unsigned long tmptaint = get_taint();
+ 	int err;
+ 
+ 	if (write && !capable(CAP_SYS_ADMIN))
+ 		return -EPERM;
+ 
+ 	t = *table;
+ 	t.data = &tmptaint;
+ 	err = proc_doulongvec_minmax(&t, write, buffer, lenp, ppos);
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (write) {
+ 		int i;
+ 
+ 		/*
+ 		 * If we are relying on panic_on_taint not producing
+ 		 * false positives due to userspace input, bail out
+ 		 * before setting the requested taint flags.
+ 		 */
+ 		if (panic_on_taint_nousertaint && (tmptaint & panic_on_taint))
+ 			return -EINVAL;
+ 
+ 		/*
+ 		 * Poor man's atomic or. Not worth adding a primitive
+ 		 * to everyone's atomic.h for this
+ 		 */
+ 		for (i = 0; i < BITS_PER_LONG && tmptaint >> i; i++) {
+ 			if ((tmptaint >> i) & 1)
+ 				add_taint(i, LOCKDEP_STILL_OK);
+ 		}
+ 	}
+ 
+ 	return err;
+ }
+ 
+ #ifdef CONFIG_PRINTK
+ static int proc_dointvec_minmax_sysadmin(struct ctl_table *table, int write,
+ 				void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	if (write && !capable(CAP_SYS_ADMIN))
+ 		return -EPERM;
+ 
+ 	return proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+ }
+ #endif
+ 
+ /**
+  * struct do_proc_dointvec_minmax_conv_param - proc_dointvec_minmax() range checking structure
+  * @min: pointer to minimum allowable value
+  * @max: pointer to maximum allowable value
+  *
+  * The do_proc_dointvec_minmax_conv_param structure provides the
+  * minimum and maximum values for doing range checking for those sysctl
+  * parameters that use the proc_dointvec_minmax() handler.
+  */
+ struct do_proc_dointvec_minmax_conv_param {
+ 	int *min;
+ 	int *max;
+ };
+ 
+ static int do_proc_dointvec_minmax_conv(bool *negp, unsigned long *lvalp,
+ 					int *valp,
+ 					int write, void *data)
+ {
+ 	int tmp, ret;
+ 	struct do_proc_dointvec_minmax_conv_param *param = data;
+ 	/*
+ 	 * If writing, first do so via a temporary local int so we can
+ 	 * bounds-check it before touching *valp.
+ 	 */
+ 	int *ip = write ? &tmp : valp;
+ 
+ 	ret = do_proc_dointvec_conv(negp, lvalp, ip, write, data);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (write) {
+ 		if ((param->min && *param->min > tmp) ||
+ 		    (param->max && *param->max < tmp))
+ 			return -EINVAL;
+ 		*valp = tmp;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * proc_dointvec_minmax - read a vector of integers with min/max values
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
+  * values from/to the user buffer, treated as an ASCII string.
+  *
+  * This routine will ensure the values are within the range specified by
+  * table->extra1 (min) and table->extra2 (max).
+  *
+  * Returns 0 on success or -EINVAL on write when the range check fails.
+  */
+ int proc_dointvec_minmax(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	struct do_proc_dointvec_minmax_conv_param param = {
+ 		.min = (int *) table->extra1,
+ 		.max = (int *) table->extra2,
+ 	};
+ 	return do_proc_dointvec(table, write, buffer, lenp, ppos,
+ 				do_proc_dointvec_minmax_conv, &param);
+ }
+ 
+ /**
+  * struct do_proc_douintvec_minmax_conv_param - proc_douintvec_minmax() range checking structure
+  * @min: pointer to minimum allowable value
+  * @max: pointer to maximum allowable value
+  *
+  * The do_proc_douintvec_minmax_conv_param structure provides the
+  * minimum and maximum values for doing range checking for those sysctl
+  * parameters that use the proc_douintvec_minmax() handler.
+  */
+ struct do_proc_douintvec_minmax_conv_param {
+ 	unsigned int *min;
+ 	unsigned int *max;
+ };
+ 
+ static int do_proc_douintvec_minmax_conv(unsigned long *lvalp,
+ 					 unsigned int *valp,
+ 					 int write, void *data)
+ {
+ 	int ret;
+ 	unsigned int tmp;
+ 	struct do_proc_douintvec_minmax_conv_param *param = data;
+ 	/* write via temporary local uint for bounds-checking */
+ 	unsigned int *up = write ? &tmp : valp;
+ 
+ 	ret = do_proc_douintvec_conv(lvalp, up, write, data);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (write) {
+ 		if ((param->min && *param->min > tmp) ||
+ 		    (param->max && *param->max < tmp))
+ 			return -ERANGE;
+ 
+ 		*valp = tmp;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * proc_douintvec_minmax - read a vector of unsigned ints with min/max values
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) unsigned integer
+  * values from/to the user buffer, treated as an ASCII string. Negative
+  * strings are not allowed.
+  *
+  * This routine will ensure the values are within the range specified by
+  * table->extra1 (min) and table->extra2 (max). There is a final sanity
+  * check for UINT_MAX to avoid having to support wrap around uses from
+  * userspace.
+  *
+  * Returns 0 on success or -ERANGE on write when the range check fails.
+  */
+ int proc_douintvec_minmax(struct ctl_table *table, int write,
+ 			  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	struct do_proc_douintvec_minmax_conv_param param = {
+ 		.min = (unsigned int *) table->extra1,
+ 		.max = (unsigned int *) table->extra2,
+ 	};
+ 	return do_proc_douintvec(table, write, buffer, lenp, ppos,
+ 				 do_proc_douintvec_minmax_conv, &param);
+ }
+ 
+ static int do_proc_dopipe_max_size_conv(unsigned long *lvalp,
+ 					unsigned int *valp,
+ 					int write, void *data)
+ {
+ 	if (write) {
+ 		unsigned int val;
+ 
+ 		val = round_pipe_size(*lvalp);
+ 		if (val == 0)
+ 			return -EINVAL;
+ 
+ 		*valp = val;
+ 	} else {
+ 		unsigned int val = *valp;
+ 		*lvalp = (unsigned long) val;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int proc_dopipe_max_size(struct ctl_table *table, int write,
+ 				void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return do_proc_douintvec(table, write, buffer, lenp, ppos,
+ 				 do_proc_dopipe_max_size_conv, NULL);
+ }
+ 
+ static void validate_coredump_safety(void)
+ {
+ #ifdef CONFIG_COREDUMP
+ 	if (suid_dumpable == SUID_DUMP_ROOT &&
+ 	    core_pattern[0] != '/' && core_pattern[0] != '|') {
+ 		printk(KERN_WARNING
+ "Unsafe core_pattern used with fs.suid_dumpable=2.\n"
+ "Pipe handler or fully qualified core dump path required.\n"
+ "Set kernel.core_pattern before fs.suid_dumpable.\n"
+ 		);
+ 	}
+ #endif
+ }
+ 
+ static int proc_dointvec_minmax_coredump(struct ctl_table *table, int write,
+ 		void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int error = proc_dointvec_minmax(table, write, buffer, lenp, ppos);
+ 	if (!error)
+ 		validate_coredump_safety();
+ 	return error;
+ }
+ 
+ #ifdef CONFIG_COREDUMP
+ static int proc_dostring_coredump(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int error = proc_dostring(table, write, buffer, lenp, ppos);
+ 	if (!error)
+ 		validate_coredump_safety();
+ 	return error;
+ }
+ #endif
+ 
+ #ifdef CONFIG_MAGIC_SYSRQ
+ static int sysrq_sysctl_handler(struct ctl_table *table, int write,
+ 				void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int tmp, ret;
+ 
+ 	tmp = sysrq_mask();
+ 
+ 	ret = __do_proc_dointvec(&tmp, table, write, buffer,
+ 			       lenp, ppos, NULL, NULL);
+ 	if (ret || !write)
+ 		return ret;
+ 
+ 	if (write)
+ 		sysrq_toggle_support(tmp);
+ 
+ 	return 0;
+ }
+ #endif
+ 
+ static int __do_proc_doulongvec_minmax(void *data, struct ctl_table *table,
+ 		int write, void *buffer, size_t *lenp, loff_t *ppos,
+ 		unsigned long convmul, unsigned long convdiv)
+ {
+ 	unsigned long *i, *min, *max;
+ 	int vleft, first = 1, err = 0;
+ 	size_t left;
+ 	char *p;
+ 
+ 	if (!data || !table->maxlen || !*lenp || (*ppos && !write)) {
+ 		*lenp = 0;
+ 		return 0;
+ 	}
+ 
+ 	i = (unsigned long *) data;
+ 	min = (unsigned long *) table->extra1;
+ 	max = (unsigned long *) table->extra2;
+ 	vleft = table->maxlen / sizeof(unsigned long);
+ 	left = *lenp;
+ 
+ 	if (write) {
+ 		if (proc_first_pos_non_zero_ignore(ppos, table))
+ 			goto out;
+ 
+ 		if (left > PAGE_SIZE - 1)
+ 			left = PAGE_SIZE - 1;
+ 		p = buffer;
+ 	}
+ 
+ 	for (; left && vleft--; i++, first = 0) {
+ 		unsigned long val;
+ 
+ 		if (write) {
+ 			bool neg;
+ 
+ 			left -= proc_skip_spaces(&p);
+ 			if (!left)
+ 				break;
+ 
+ 			err = proc_get_long(&p, &left, &val, &neg,
+ 					     proc_wspace_sep,
+ 					     sizeof(proc_wspace_sep), NULL);
+ 			if (err)
+ 				break;
+ 			if (neg)
+ 				continue;
+ 			val = convmul * val / convdiv;
+ 			if ((min && val < *min) || (max && val > *max)) {
+ 				err = -EINVAL;
+ 				break;
+ 			}
+ 			*i = val;
+ 		} else {
+ 			val = convdiv * (*i) / convmul;
+ 			if (!first)
+ 				proc_put_char(&buffer, &left, '\t');
+ 			proc_put_long(&buffer, &left, val, false);
+ 		}
+ 	}
+ 
+ 	if (!write && !first && left && !err)
+ 		proc_put_char(&buffer, &left, '\n');
+ 	if (write && !err)
+ 		left -= proc_skip_spaces(&p);
+ 	if (write && first)
+ 		return err ? : -EINVAL;
+ 	*lenp -= left;
+ out:
+ 	*ppos += *lenp;
+ 	return err;
+ }
+ 
+ static int do_proc_doulongvec_minmax(struct ctl_table *table, int write,
+ 		void *buffer, size_t *lenp, loff_t *ppos, unsigned long convmul,
+ 		unsigned long convdiv)
+ {
+ 	return __do_proc_doulongvec_minmax(table->data, table, write,
+ 			buffer, lenp, ppos, convmul, convdiv);
+ }
+ 
+ /**
+  * proc_doulongvec_minmax - read a vector of long integers with min/max values
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long
+  * values from/to the user buffer, treated as an ASCII string.
+  *
+  * This routine will ensure the values are within the range specified by
+  * table->extra1 (min) and table->extra2 (max).
+  *
+  * Returns 0 on success.
+  */
+ int proc_doulongvec_minmax(struct ctl_table *table, int write,
+ 			   void *buffer, size_t *lenp, loff_t *ppos)
+ {
+     return do_proc_doulongvec_minmax(table, write, buffer, lenp, ppos, 1l, 1l);
+ }
+ 
+ /**
+  * proc_doulongvec_ms_jiffies_minmax - read a vector of millisecond values with min/max values
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned long) unsigned long
+  * values from/to the user buffer, treated as an ASCII string. The values
+  * are treated as milliseconds, and converted to jiffies when they are stored.
+  *
+  * This routine will ensure the values are within the range specified by
+  * table->extra1 (min) and table->extra2 (max).
+  *
+  * Returns 0 on success.
+  */
+ int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,
+ 				      void *buffer, size_t *lenp, loff_t *ppos)
+ {
+     return do_proc_doulongvec_minmax(table, write, buffer,
+ 				     lenp, ppos, HZ, 1000l);
+ }
+ 
+ 
+ static int do_proc_dointvec_jiffies_conv(bool *negp, unsigned long *lvalp,
+ 					 int *valp,
+ 					 int write, void *data)
+ {
+ 	if (write) {
+ 		if (*lvalp > INT_MAX / HZ)
+ 			return 1;
+ 		*valp = *negp ? -(*lvalp*HZ) : (*lvalp*HZ);
+ 	} else {
+ 		int val = *valp;
+ 		unsigned long lval;
+ 		if (val < 0) {
+ 			*negp = true;
+ 			lval = -(unsigned long)val;
+ 		} else {
+ 			*negp = false;
+ 			lval = (unsigned long)val;
+ 		}
+ 		*lvalp = lval / HZ;
+ 	}
+ 	return 0;
+ }
+ 
+ static int do_proc_dointvec_userhz_jiffies_conv(bool *negp, unsigned long *lvalp,
+ 						int *valp,
+ 						int write, void *data)
+ {
+ 	if (write) {
+ 		if (USER_HZ < HZ && *lvalp > (LONG_MAX / HZ) * USER_HZ)
+ 			return 1;
+ 		*valp = clock_t_to_jiffies(*negp ? -*lvalp : *lvalp);
+ 	} else {
+ 		int val = *valp;
+ 		unsigned long lval;
+ 		if (val < 0) {
+ 			*negp = true;
+ 			lval = -(unsigned long)val;
+ 		} else {
+ 			*negp = false;
+ 			lval = (unsigned long)val;
+ 		}
+ 		*lvalp = jiffies_to_clock_t(lval);
+ 	}
+ 	return 0;
+ }
+ 
+ static int do_proc_dointvec_ms_jiffies_conv(bool *negp, unsigned long *lvalp,
+ 					    int *valp,
+ 					    int write, void *data)
+ {
+ 	if (write) {
+ 		unsigned long jif = msecs_to_jiffies(*negp ? -*lvalp : *lvalp);
+ 
+ 		if (jif > INT_MAX)
+ 			return 1;
+ 		*valp = (int)jif;
+ 	} else {
+ 		int val = *valp;
+ 		unsigned long lval;
+ 		if (val < 0) {
+ 			*negp = true;
+ 			lval = -(unsigned long)val;
+ 		} else {
+ 			*negp = false;
+ 			lval = (unsigned long)val;
+ 		}
+ 		*lvalp = jiffies_to_msecs(lval);
+ 	}
+ 	return 0;
+ }
+ 
+ /**
+  * proc_dointvec_jiffies - read a vector of integers as seconds
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
+  * values from/to the user buffer, treated as an ASCII string. 
+  * The values read are assumed to be in seconds, and are converted into
+  * jiffies.
+  *
+  * Returns 0 on success.
+  */
+ int proc_dointvec_jiffies(struct ctl_table *table, int write,
+ 			  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+     return do_proc_dointvec(table,write,buffer,lenp,ppos,
+ 		    	    do_proc_dointvec_jiffies_conv,NULL);
+ }
+ 
+ /**
+  * proc_dointvec_userhz_jiffies - read a vector of integers as 1/USER_HZ seconds
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: pointer to the file position
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
+  * values from/to the user buffer, treated as an ASCII string. 
+  * The values read are assumed to be in 1/USER_HZ seconds, and 
+  * are converted into jiffies.
+  *
+  * Returns 0 on success.
+  */
+ int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,
+ 				 void *buffer, size_t *lenp, loff_t *ppos)
+ {
+     return do_proc_dointvec(table,write,buffer,lenp,ppos,
+ 		    	    do_proc_dointvec_userhz_jiffies_conv,NULL);
+ }
+ 
+ /**
+  * proc_dointvec_ms_jiffies - read a vector of integers as 1 milliseconds
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  * @ppos: the current position in the file
+  *
+  * Reads/writes up to table->maxlen/sizeof(unsigned int) integer
+  * values from/to the user buffer, treated as an ASCII string. 
+  * The values read are assumed to be in 1/1000 seconds, and 
+  * are converted into jiffies.
+  *
+  * Returns 0 on success.
+  */
+ int proc_dointvec_ms_jiffies(struct ctl_table *table, int write, void *buffer,
+ 		size_t *lenp, loff_t *ppos)
+ {
+ 	return do_proc_dointvec(table, write, buffer, lenp, ppos,
+ 				do_proc_dointvec_ms_jiffies_conv, NULL);
+ }
+ 
+ static int proc_do_cad_pid(struct ctl_table *table, int write, void *buffer,
+ 		size_t *lenp, loff_t *ppos)
+ {
+ 	struct pid *new_pid;
+ 	pid_t tmp;
+ 	int r;
+ 
+ 	tmp = pid_vnr(cad_pid);
+ 
+ 	r = __do_proc_dointvec(&tmp, table, write, buffer,
+ 			       lenp, ppos, NULL, NULL);
+ 	if (r || !write)
+ 		return r;
+ 
+ 	new_pid = find_get_pid(tmp);
+ 	if (!new_pid)
+ 		return -ESRCH;
+ 
+ 	put_pid(xchg(&cad_pid, new_pid));
+ 	return 0;
+ }
+ 
+ /**
+  * proc_do_large_bitmap - read/write from/to a large bitmap
+  * @table: the sysctl table
+  * @write: %TRUE if this is a write to the sysctl file
+  * @buffer: the user buffer
+  * @lenp: the size of the user buffer
+  * @ppos: file position
+  *
+  * The bitmap is stored at table->data and the bitmap length (in bits)
+  * in table->maxlen.
+  *
+  * We use a range comma separated format (e.g. 1,3-4,10-10) so that
+  * large bitmaps may be represented in a compact manner. Writing into
+  * the file will clear the bitmap then update it with the given input.
+  *
+  * Returns 0 on success.
+  */
+ int proc_do_large_bitmap(struct ctl_table *table, int write,
+ 			 void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	int err = 0;
+ 	bool first = 1;
+ 	size_t left = *lenp;
+ 	unsigned long bitmap_len = table->maxlen;
+ 	unsigned long *bitmap = *(unsigned long **) table->data;
+ 	unsigned long *tmp_bitmap = NULL;
+ 	char tr_a[] = { '-', ',', '\n' }, tr_b[] = { ',', '\n', 0 }, c;
+ 
+ 	if (!bitmap || !bitmap_len || !left || (*ppos && !write)) {
+ 		*lenp = 0;
+ 		return 0;
+ 	}
+ 
+ 	if (write) {
+ 		char *p = buffer;
+ 		size_t skipped = 0;
+ 
+ 		if (left > PAGE_SIZE - 1) {
+ 			left = PAGE_SIZE - 1;
+ 			/* How much of the buffer we'll skip this pass */
+ 			skipped = *lenp - left;
+ 		}
+ 
+ 		tmp_bitmap = bitmap_zalloc(bitmap_len, GFP_KERNEL);
+ 		if (!tmp_bitmap)
+ 			return -ENOMEM;
+ 		proc_skip_char(&p, &left, '\n');
+ 		while (!err && left) {
+ 			unsigned long val_a, val_b;
+ 			bool neg;
+ 			size_t saved_left;
+ 
+ 			/* In case we stop parsing mid-number, we can reset */
+ 			saved_left = left;
+ 			err = proc_get_long(&p, &left, &val_a, &neg, tr_a,
+ 					     sizeof(tr_a), &c);
+ 			/*
+ 			 * If we consumed the entirety of a truncated buffer or
+ 			 * only one char is left (may be a "-"), then stop here,
+ 			 * reset, & come back for more.
+ 			 */
+ 			if ((left <= 1) && skipped) {
+ 				left = saved_left;
+ 				break;
+ 			}
+ 
+ 			if (err)
+ 				break;
+ 			if (val_a >= bitmap_len || neg) {
+ 				err = -EINVAL;
+ 				break;
+ 			}
+ 
+ 			val_b = val_a;
+ 			if (left) {
+ 				p++;
+ 				left--;
+ 			}
+ 
+ 			if (c == '-') {
+ 				err = proc_get_long(&p, &left, &val_b,
+ 						     &neg, tr_b, sizeof(tr_b),
+ 						     &c);
+ 				/*
+ 				 * If we consumed all of a truncated buffer or
+ 				 * then stop here, reset, & come back for more.
+ 				 */
+ 				if (!left && skipped) {
+ 					left = saved_left;
+ 					break;
+ 				}
+ 
+ 				if (err)
+ 					break;
+ 				if (val_b >= bitmap_len || neg ||
+ 				    val_a > val_b) {
+ 					err = -EINVAL;
+ 					break;
+ 				}
+ 				if (left) {
+ 					p++;
+ 					left--;
+ 				}
+ 			}
+ 
+ 			bitmap_set(tmp_bitmap, val_a, val_b - val_a + 1);
+ 			first = 0;
+ 			proc_skip_char(&p, &left, '\n');
+ 		}
+ 		left += skipped;
+ 	} else {
+ 		unsigned long bit_a, bit_b = 0;
+ 
+ 		while (left) {
+ 			bit_a = find_next_bit(bitmap, bitmap_len, bit_b);
+ 			if (bit_a >= bitmap_len)
+ 				break;
+ 			bit_b = find_next_zero_bit(bitmap, bitmap_len,
+ 						   bit_a + 1) - 1;
+ 
+ 			if (!first)
+ 				proc_put_char(&buffer, &left, ',');
+ 			proc_put_long(&buffer, &left, bit_a, false);
+ 			if (bit_a != bit_b) {
+ 				proc_put_char(&buffer, &left, '-');
+ 				proc_put_long(&buffer, &left, bit_b, false);
+ 			}
+ 
+ 			first = 0; bit_b++;
+ 		}
+ 		proc_put_char(&buffer, &left, '\n');
+ 	}
+ 
+ 	if (!err) {
+ 		if (write) {
+ 			if (*ppos)
+ 				bitmap_or(bitmap, bitmap, tmp_bitmap, bitmap_len);
+ 			else
+ 				bitmap_copy(bitmap, tmp_bitmap, bitmap_len);
+ 		}
+ 		*lenp -= left;
+ 		*ppos += *lenp;
+ 	}
+ 
+ 	bitmap_free(tmp_bitmap);
+ 	return err;
+ }
+ 
+ #else /* CONFIG_PROC_SYSCTL */
+ 
+ int proc_dostring(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_dointvec(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_douintvec(struct ctl_table *table, int write,
+ 		  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_dointvec_minmax(struct ctl_table *table, int write,
+ 		    void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_douintvec_minmax(struct ctl_table *table, int write,
+ 			  void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_dointvec_jiffies(struct ctl_table *table, int write,
+ 		    void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,
+ 		    void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_dointvec_ms_jiffies(struct ctl_table *table, int write,
+ 			     void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_doulongvec_minmax(struct ctl_table *table, int write,
+ 		    void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,
+ 				      void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ int proc_do_large_bitmap(struct ctl_table *table, int write,
+ 			 void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ #endif /* CONFIG_PROC_SYSCTL */
+ 
+ #if defined(CONFIG_SYSCTL)
+ int proc_do_static_key(struct ctl_table *table, int write,
+ 		       void *buffer, size_t *lenp, loff_t *ppos)
+ {
+ 	struct static_key *key = (struct static_key *)table->data;
+ 	static DEFINE_MUTEX(static_key_mutex);
+ 	int val, ret;
+ 	struct ctl_table tmp = {
+ 		.data   = &val,
+ 		.maxlen = sizeof(val),
+ 		.mode   = table->mode,
+ 		.extra1 = SYSCTL_ZERO,
+ 		.extra2 = SYSCTL_ONE,
+ 	};
+ 
+ 	if (write && !capable(CAP_SYS_ADMIN))
+ 		return -EPERM;
+ 
+ 	mutex_lock(&static_key_mutex);
+ 	val = static_key_enabled(key);
+ 	ret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);
+ 	if (write && !ret) {
+ 		if (val)
+ 			static_key_enable(key);
+ 		else
+ 			static_key_disable(key);
+ 	}
+ 	mutex_unlock(&static_key_mutex);
+ 	return ret;
+ }
+ 
++>>>>>>> db38d5c106df (kernel: add panic_on_taint)
  static struct ctl_table kern_table[] = {
  	{
  		.procname	= "sched_child_runs_first",
* Unmerged path Documentation/admin-guide/sysctl/kernel.rst
diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
index 1516724676e4..9fd56d79ad61 100644
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -3257,6 +3257,19 @@
 			bit 4: print ftrace buffer
 			bit 5: print all printk messages in buffer
 
+	panic_on_taint=	Bitmask for conditionally calling panic() in add_taint()
+			Format: <hex>[,nousertaint]
+			Hexadecimal bitmask representing the set of TAINT flags
+			that will cause the kernel to panic when add_taint() is
+			called with any of the flags in this set.
+			The optional switch "nousertaint" can be utilized to
+			prevent userspace forced crashes by writing to sysctl
+			/proc/sys/kernel/tainted any flagset matching with the
+			bitmask set on panic_on_taint.
+			See Documentation/admin-guide/tainted-kernels.rst for
+			extra details on the taint flags that users can pick
+			to compose the bitmask to assign to panic_on_taint.
+
 	panic_on_warn	panic() instead of WARN().  Useful to cause kdump
 			on a WARN().
 
* Unmerged path Documentation/admin-guide/sysctl/kernel.rst
diff --git a/Documentation/kdump/kdump.txt b/Documentation/kdump/kdump.txt
index 4e98e6722d38..d4058485cb92 100644
--- a/Documentation/kdump/kdump.txt
+++ b/Documentation/kdump/kdump.txt
@@ -512,6 +512,14 @@ will cause a kdump to occur at the panic() call.  In cases where a user wants
 to specify this during runtime, /proc/sys/kernel/panic_on_warn can be set to 1
 to achieve the same behaviour.
 
+Trigger Kdump on add_taint()
+============================
+
+The kernel parameter panic_on_taint facilitates a conditional call to panic()
+from within add_taint() whenever the value set in this bitmask matches with the
+bit flag being set by add_taint().
+This will cause a kdump to occur at the add_taint()->panic() call.
+
 Contact
 =======
 
* Unmerged path include/linux/kernel.h
diff --git a/kernel/panic.c b/kernel/panic.c
index f4ddadfb28ae..bbdb710e63ff 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -42,6 +42,8 @@ static int pause_on_oops_flag;
 static DEFINE_SPINLOCK(pause_on_oops_lock);
 bool crash_kexec_post_notifiers;
 int panic_on_warn __read_mostly;
+unsigned long panic_on_taint;
+bool panic_on_taint_nousertaint = false;
 
 int panic_timeout = CONFIG_PANIC_TIMEOUT;
 EXPORT_SYMBOL_GPL(panic_timeout);
@@ -434,6 +436,11 @@ void add_taint(unsigned flag, enum lockdep_ok lockdep_ok)
 		pr_warn("Disabling lock debugging due to kernel taint\n");
 
 	set_bit(flag, &tainted_mask);
+
+	if (tainted_mask & panic_on_taint) {
+		panic_on_taint = 0;
+		panic("panic_on_taint set ...");
+	}
 }
 EXPORT_SYMBOL(add_taint);
 
@@ -713,3 +720,30 @@ static int __init oops_setup(char *s)
 	return 0;
 }
 early_param("oops", oops_setup);
+
+static int __init panic_on_taint_setup(char *s)
+{
+	char *taint_str;
+
+	if (!s)
+		return -EINVAL;
+
+	taint_str = strsep(&s, ",");
+	if (kstrtoul(taint_str, 16, &panic_on_taint))
+		return -EINVAL;
+
+	/* make sure panic_on_taint doesn't hold out-of-range TAINT flags */
+	panic_on_taint &= TAINT_FLAGS_MAX;
+
+	if (!panic_on_taint)
+		return -EINVAL;
+
+	if (s && !strcmp(s, "nousertaint"))
+		panic_on_taint_nousertaint = true;
+
+	pr_info("panic_on_taint: bitmask=0x%lx nousertaint_mode=%sabled\n",
+		panic_on_taint, panic_on_taint_nousertaint ? "en" : "dis");
+
+	return 0;
+}
+early_param("panic_on_taint", panic_on_taint_setup);
* Unmerged path kernel/sysctl.c
