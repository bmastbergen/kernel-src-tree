ASoC: au1x: Use managed buffer allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: au1x: Use managed buffer allocation (Jaroslav Kysela) [1797509]
Rebuild_FUZZ: 93.18%
commit-author Takashi Iwai <tiwai@suse.de>
commit fe9912ac58e4fa205faabcccc980eb834cc5f1aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/fe9912ac.failed

Clean up the drivers with the new managed buffer allocation API.
The superfluous snd_pcm_lib_malloc_pages() and
snd_pcm_lib_free_pages() calls are dropped.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
Link: https://lore.kernel.org/r/20191210142614.19405-3-tiwai@suse.de
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit fe9912ac58e4fa205faabcccc980eb834cc5f1aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/au1x/dma.c
diff --cc sound/soc/au1x/dma.c
index a010067c5313,c9a038a5e2d3..000000000000
--- a/sound/soc/au1x/dma.c
+++ b/sound/soc/au1x/dma.c
@@@ -292,8 -283,8 +283,13 @@@ static int alchemy_pcm_new(struct snd_s
  {
  	struct snd_pcm *pcm = rtd->pcm;
  
++<<<<<<< HEAD
 +	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
 +		snd_dma_continuous_data(GFP_KERNEL), 65536, (4096 * 1024) - 1);
++=======
+ 	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,
+ 				       NULL, 65536, (4096 * 1024) - 1);
++>>>>>>> fe9912ac58e4 (ASoC: au1x: Use managed buffer allocation)
  
  	return 0;
  }
diff --git a/sound/soc/au1x/dbdma2.c b/sound/soc/au1x/dbdma2.c
index 4c74698d31b3..8f855644c6b4 100644
--- a/sound/soc/au1x/dbdma2.c
+++ b/sound/soc/au1x/dbdma2.c
@@ -197,10 +197,6 @@ static int au1xpsc_pcm_hw_params(struct snd_soc_component *component,
 	struct au1xpsc_audio_dmadata *pcd;
 	int stype, ret;
 
-	ret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
-	if (ret < 0)
-		goto out;
-
 	stype = substream->stream;
 	pcd = to_dmadata(substream, component);
 
@@ -232,13 +228,6 @@ static int au1xpsc_pcm_hw_params(struct snd_soc_component *component,
 	return ret;
 }
 
-static int au1xpsc_pcm_hw_free(struct snd_soc_component *component,
-			       struct snd_pcm_substream *substream)
-{
-	snd_pcm_lib_free_pages(substream);
-	return 0;
-}
-
 static int au1xpsc_pcm_prepare(struct snd_soc_component *component,
 			       struct snd_pcm_substream *substream)
 {
@@ -315,7 +304,7 @@ static int au1xpsc_pcm_new(struct snd_soc_component *component,
 	struct snd_card *card = rtd->card->snd_card;
 	struct snd_pcm *pcm = rtd->pcm;
 
-	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,
+	snd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_DEV,
 		card->dev, AU1XPSC_BUFFER_MIN_BYTES, (4096 * 1024) - 1);
 
 	return 0;
@@ -327,7 +316,6 @@ static struct snd_soc_component_driver au1xpsc_soc_component = {
 	.open		= au1xpsc_pcm_open,
 	.close		= au1xpsc_pcm_close,
 	.hw_params	= au1xpsc_pcm_hw_params,
-	.hw_free	= au1xpsc_pcm_hw_free,
 	.prepare	= au1xpsc_pcm_prepare,
 	.trigger	= au1xpsc_pcm_trigger,
 	.pointer	= au1xpsc_pcm_pointer,
* Unmerged path sound/soc/au1x/dma.c
