netfilter: conntrack: add nf_{tcp,udp,sctp,icmp,dccp,icmpv6,generic}_pernet()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] netfilter: conntrack: add nf_{tcp, udp, sctp, icmp, dccp, icmpv6, generic}_pernet() (Florian Westphal) [1822085]
Rebuild_FUZZ: 96.25%
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit a95a7774d51e13f9cf4b7285666829b68852f07a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a95a7774.failed

Expose these functions to access conntrack protocol tracker netns area,
nfnetlink_cttimeout needs this.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit a95a7774d51e13f9cf4b7285666829b68852f07a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/nf_conntrack_proto_icmp.c
#	net/netfilter/nf_conntrack_proto_dccp.c
#	net/netfilter/nf_conntrack_proto_generic.c
#	net/netfilter/nf_conntrack_proto_sctp.c
#	net/netfilter/nf_conntrack_proto_tcp.c
diff --cc net/ipv4/netfilter/nf_conntrack_proto_icmp.c
index 7cdc1512bd55,de64d8a5fdfd..000000000000
--- a/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
+++ b/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
@@@ -108,9 -94,14 +103,18 @@@ static bool icmp_new(struct nf_conn *ct
  		pr_debug("icmp: can't create new conn with type %u\n",
  			 ct->tuplehash[0].tuple.dst.u.icmp.type);
  		nf_ct_dump_tuple_ip(&ct->tuplehash[0].tuple);
 -		return -NF_ACCEPT;
 +		return false;
  	}
++<<<<<<< HEAD:net/ipv4/netfilter/nf_conntrack_proto_icmp.c
 +	return true;
++=======
+ 
+ 	if (!timeout)
+ 		timeout = &nf_icmp_pernet(nf_ct_net(ct))->timeout;
+ 
+ 	nf_ct_refresh_acct(ct, ctinfo, skb, *timeout);
+ 	return NF_ACCEPT;
++>>>>>>> a95a7774d51e (netfilter: conntrack: add nf_{tcp,udp,sctp,icmp,dccp,icmpv6,generic}_pernet()):net/netfilter/nf_conntrack_proto_icmp.c
  }
  
  /* Returns conntrack if it dealt with ICMP, and filled in skb fields */
@@@ -277,12 -270,14 +281,12 @@@ static int icmp_timeout_nlattr_to_obj(s
  				      struct net *net, void *data)
  {
  	unsigned int *timeout = data;
- 	struct nf_icmp_net *in = icmp_pernet(net);
+ 	struct nf_icmp_net *in = nf_icmp_pernet(net);
  
  	if (tb[CTA_TIMEOUT_ICMP_TIMEOUT]) {
 -		if (!timeout)
 -			timeout = &in->timeout;
  		*timeout =
  			ntohl(nla_get_be32(tb[CTA_TIMEOUT_ICMP_TIMEOUT])) * HZ;
 -	} else if (timeout) {
 +	} else {
  		/* Set default ICMP timeout. */
  		*timeout = in->timeout;
  	}
diff --cc net/netfilter/nf_conntrack_proto_dccp.c
index 1b076e836394,023c1445bc39..000000000000
--- a/net/netfilter/nf_conntrack_proto_dccp.c
+++ b/net/netfilter/nf_conntrack_proto_dccp.c
@@@ -383,13 -384,9 +383,19 @@@ dccp_state_table[CT_DCCP_ROLE_MAX + 1][
  	},
  };
  
++<<<<<<< HEAD
 +static inline struct nf_dccp_net *dccp_pernet(struct net *net)
 +{
 +	return &net->ct.nf_ct_proto.dccp;
 +}
 +
 +static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,
 +		     unsigned int dataoff, unsigned int *timeouts)
++=======
+ static noinline bool
+ dccp_new(struct nf_conn *ct, const struct sk_buff *skb,
+ 	 const struct dccp_hdr *dh)
++>>>>>>> a95a7774d51e (netfilter: conntrack: add nf_{tcp,udp,sctp,icmp,dccp,icmpv6,generic}_pernet())
  {
  	struct net *net = nf_ct_net(ct);
  	struct nf_dccp_net *dn;
@@@ -523,6 -561,9 +529,12 @@@ static int dccp_packet(struct nf_conn *
  	if (new_state != old_state)
  		nf_conntrack_event_cache(IPCT_PROTOINFO, ct);
  
++<<<<<<< HEAD
++=======
+ 	timeouts = nf_ct_timeout_lookup(ct);
+ 	if (!timeouts)
+ 		timeouts = nf_dccp_pernet(nf_ct_net(ct))->dccp_timeout;
++>>>>>>> a95a7774d51e (netfilter: conntrack: add nf_{tcp,udp,sctp,icmp,dccp,icmpv6,generic}_pernet())
  	nf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);
  
  	return NF_ACCEPT;
diff --cc net/netfilter/nf_conntrack_proto_generic.c
index 5ceb58c2c816,5da19d5fbc76..000000000000
--- a/net/netfilter/nf_conntrack_proto_generic.c
+++ b/net/netfilter/nf_conntrack_proto_generic.c
@@@ -41,18 -37,24 +36,32 @@@ static bool generic_pkt_to_tuple(const 
  	return true;
  }
  
 +static unsigned int *generic_get_timeouts(struct net *net)
 +{
 +	return &(generic_pernet(net)->timeout);
 +}
 +
  /* Returns verdict for packet, or -1 for invalid. */
  static int generic_packet(struct nf_conn *ct,
 -			  struct sk_buff *skb,
 +			  const struct sk_buff *skb,
  			  unsigned int dataoff,
  			  enum ip_conntrack_info ctinfo,
 -			  const struct nf_hook_state *state)
 +			  unsigned int *timeout)
  {
++<<<<<<< HEAD
++=======
+ 	const unsigned int *timeout = nf_ct_timeout_lookup(ct);
+ 
+ 	if (!nf_generic_should_process(nf_ct_protonum(ct))) {
+ 		pr_warn_once("conntrack: generic helper won't handle protocol %d. Please consider loading the specific helper module.\n",
+ 			     nf_ct_protonum(ct));
+ 		return -NF_ACCEPT;
+ 	}
+ 
+ 	if (!timeout)
+ 		timeout = &nf_generic_pernet(nf_ct_net(ct))->timeout;
+ 
++>>>>>>> a95a7774d51e (netfilter: conntrack: add nf_{tcp,udp,sctp,icmp,dccp,icmpv6,generic}_pernet())
  	nf_ct_refresh_acct(ct, ctinfo, skb, *timeout);
  	return NF_ACCEPT;
  }
@@@ -78,8 -67,11 +87,12 @@@ static bool generic_new(struct nf_conn 
  static int generic_timeout_nlattr_to_obj(struct nlattr *tb[],
  					 struct net *net, void *data)
  {
++<<<<<<< HEAD
++=======
+ 	struct nf_generic_net *gn = nf_generic_pernet(net);
++>>>>>>> a95a7774d51e (netfilter: conntrack: add nf_{tcp,udp,sctp,icmp,dccp,icmpv6,generic}_pernet())
  	unsigned int *timeout = data;
 -
 -	if (!timeout)
 -		timeout = &gn->timeout;
 +	struct nf_generic_net *gn = generic_pernet(net);
  
  	if (tb[CTA_TIMEOUT_GENERIC_TIMEOUT])
  		*timeout =
diff --cc net/netfilter/nf_conntrack_proto_sctp.c
index d72492231b01,d53e3e78f605..000000000000
--- a/net/netfilter/nf_conntrack_proto_sctp.c
+++ b/net/netfilter/nf_conntrack_proto_sctp.c
@@@ -379,6 -473,10 +374,13 @@@ static int sctp_packet(struct nf_conn *
  	}
  	spin_unlock_bh(&ct->lock);
  
++<<<<<<< HEAD
++=======
+ 	timeouts = nf_ct_timeout_lookup(ct);
+ 	if (!timeouts)
+ 		timeouts = nf_sctp_pernet(nf_ct_net(ct))->timeouts;
+ 
++>>>>>>> a95a7774d51e (netfilter: conntrack: add nf_{tcp,udp,sctp,icmp,dccp,icmpv6,generic}_pernet())
  	nf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);
  
  	if (old_state == SCTP_CONNTRACK_COOKIE_ECHOED &&
@@@ -600,12 -594,9 +602,12 @@@ static int sctp_timeout_nlattr_to_obj(s
  				      struct net *net, void *data)
  {
  	unsigned int *timeouts = data;
- 	struct nf_sctp_net *sn = sctp_pernet(net);
+ 	struct nf_sctp_net *sn = nf_sctp_pernet(net);
  	int i;
  
 +	if (!timeouts)
 +		timeouts = sn->timeouts;
 +
  	/* set default SCTP timeouts. */
  	for (i=0; i<SCTP_CONNTRACK_MAX; i++)
  		timeouts[i] = sn->timeouts[i];
diff --cc net/netfilter/nf_conntrack_proto_tcp.c
index c603fa83f3e5,4dcbd51a8e97..000000000000
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@@ -763,29 -749,97 +758,98 @@@ static int tcp_error(struct net *net, s
  	/* Check TCP flags. */
  	tcpflags = (tcp_flag_byte(th) & ~(TCPHDR_ECE|TCPHDR_CWR|TCPHDR_PSH));
  	if (!tcp_valid_flags[tcpflags]) {
 -		tcp_error_log(skb, state, "invalid tcp flag combination");
 -		return true;
 +		tcp_error_log(skb, net, pf, "invalid tcp flag combination");
 +		return -NF_ACCEPT;
  	}
  
 -	return false;
 +	return NF_ACCEPT;
  }
  
 -static noinline bool tcp_new(struct nf_conn *ct, const struct sk_buff *skb,
 -			     unsigned int dataoff,
 -			     const struct tcphdr *th)
 +static unsigned int *tcp_get_timeouts(struct net *net)
  {
++<<<<<<< HEAD
 +	return tcp_pernet(net)->timeouts;
++=======
+ 	enum tcp_conntrack new_state;
+ 	struct net *net = nf_ct_net(ct);
+ 	const struct nf_tcp_net *tn = nf_tcp_pernet(net);
+ 	const struct ip_ct_tcp_state *sender = &ct->proto.tcp.seen[0];
+ 	const struct ip_ct_tcp_state *receiver = &ct->proto.tcp.seen[1];
+ 
+ 	/* Don't need lock here: this conntrack not in circulation yet */
+ 	new_state = tcp_conntracks[0][get_conntrack_index(th)][TCP_CONNTRACK_NONE];
+ 
+ 	/* Invalid: delete conntrack */
+ 	if (new_state >= TCP_CONNTRACK_MAX) {
+ 		pr_debug("nf_ct_tcp: invalid new deleting.\n");
+ 		return false;
+ 	}
+ 
+ 	if (new_state == TCP_CONNTRACK_SYN_SENT) {
+ 		memset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));
+ 		/* SYN packet */
+ 		ct->proto.tcp.seen[0].td_end =
+ 			segment_seq_plus_len(ntohl(th->seq), skb->len,
+ 					     dataoff, th);
+ 		ct->proto.tcp.seen[0].td_maxwin = ntohs(th->window);
+ 		if (ct->proto.tcp.seen[0].td_maxwin == 0)
+ 			ct->proto.tcp.seen[0].td_maxwin = 1;
+ 		ct->proto.tcp.seen[0].td_maxend =
+ 			ct->proto.tcp.seen[0].td_end;
+ 
+ 		tcp_options(skb, dataoff, th, &ct->proto.tcp.seen[0]);
+ 	} else if (tn->tcp_loose == 0) {
+ 		/* Don't try to pick up connections. */
+ 		return false;
+ 	} else {
+ 		memset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));
+ 		/*
+ 		 * We are in the middle of a connection,
+ 		 * its history is lost for us.
+ 		 * Let's try to use the data from the packet.
+ 		 */
+ 		ct->proto.tcp.seen[0].td_end =
+ 			segment_seq_plus_len(ntohl(th->seq), skb->len,
+ 					     dataoff, th);
+ 		ct->proto.tcp.seen[0].td_maxwin = ntohs(th->window);
+ 		if (ct->proto.tcp.seen[0].td_maxwin == 0)
+ 			ct->proto.tcp.seen[0].td_maxwin = 1;
+ 		ct->proto.tcp.seen[0].td_maxend =
+ 			ct->proto.tcp.seen[0].td_end +
+ 			ct->proto.tcp.seen[0].td_maxwin;
+ 
+ 		/* We assume SACK and liberal window checking to handle
+ 		 * window scaling */
+ 		ct->proto.tcp.seen[0].flags =
+ 		ct->proto.tcp.seen[1].flags = IP_CT_TCP_FLAG_SACK_PERM |
+ 					      IP_CT_TCP_FLAG_BE_LIBERAL;
+ 	}
+ 
+ 	/* tcp_packet will set them */
+ 	ct->proto.tcp.last_index = TCP_NONE_SET;
+ 
+ 	pr_debug("%s: sender end=%u maxend=%u maxwin=%u scale=%i "
+ 		 "receiver end=%u maxend=%u maxwin=%u scale=%i\n",
+ 		 __func__,
+ 		 sender->td_end, sender->td_maxend, sender->td_maxwin,
+ 		 sender->td_scale,
+ 		 receiver->td_end, receiver->td_maxend, receiver->td_maxwin,
+ 		 receiver->td_scale);
+ 	return true;
++>>>>>>> a95a7774d51e (netfilter: conntrack: add nf_{tcp,udp,sctp,icmp,dccp,icmpv6,generic}_pernet())
  }
  
  /* Returns verdict for packet, or -1 for invalid. */
  static int tcp_packet(struct nf_conn *ct,
 -		      struct sk_buff *skb,
 +		      const struct sk_buff *skb,
  		      unsigned int dataoff,
  		      enum ip_conntrack_info ctinfo,
 -		      const struct nf_hook_state *state)
 +		      unsigned int *timeouts)
  {
  	struct net *net = nf_ct_net(ct);
- 	struct nf_tcp_net *tn = tcp_pernet(net);
+ 	struct nf_tcp_net *tn = nf_tcp_pernet(net);
  	struct nf_conntrack_tuple *tuple;
  	enum tcp_conntrack new_state, old_state;
 -	unsigned int index, *timeouts;
  	enum ip_conntrack_dir dir;
  	const struct tcphdr *th;
  	struct tcphdr _tcph;
@@@ -1290,10 -1278,12 +1354,14 @@@ static unsigned int tcp_nlattr_tuple_si
  static int tcp_timeout_nlattr_to_obj(struct nlattr *tb[],
  				     struct net *net, void *data)
  {
++<<<<<<< HEAD
++=======
+ 	struct nf_tcp_net *tn = nf_tcp_pernet(net);
++>>>>>>> a95a7774d51e (netfilter: conntrack: add nf_{tcp,udp,sctp,icmp,dccp,icmpv6,generic}_pernet())
  	unsigned int *timeouts = data;
 +	struct nf_tcp_net *tn = tcp_pernet(net);
  	int i;
  
 -	if (!timeouts)
 -		timeouts = tn->timeouts;
  	/* set default TCP timeouts. */
  	for (i=0; i<TCP_CONNTRACK_TIMEOUT_MAX; i++)
  		timeouts[i] = tn->timeouts[i];
diff --git a/include/net/netfilter/nf_conntrack_l4proto.h b/include/net/netfilter/nf_conntrack_l4proto.h
index 264f50873a3a..617620209b58 100644
--- a/include/net/netfilter/nf_conntrack_l4proto.h
+++ b/include/net/netfilter/nf_conntrack_l4proto.h
@@ -165,4 +165,43 @@ void nf_ct_l4proto_log_invalid(const struct sk_buff *skb,
 			       const char *fmt, ...) { }
 #endif /* CONFIG_SYSCTL */
 
+static inline struct nf_generic_net *nf_generic_pernet(struct net *net)
+{
+       return &net->ct.nf_ct_proto.generic;
+}
+
+static inline struct nf_tcp_net *nf_tcp_pernet(struct net *net)
+{
+       return &net->ct.nf_ct_proto.tcp;
+}
+
+static inline struct nf_udp_net *nf_udp_pernet(struct net *net)
+{
+       return &net->ct.nf_ct_proto.udp;
+}
+
+static inline struct nf_icmp_net *nf_icmp_pernet(struct net *net)
+{
+       return &net->ct.nf_ct_proto.icmp;
+}
+
+static inline struct nf_icmp_net *nf_icmpv6_pernet(struct net *net)
+{
+       return &net->ct.nf_ct_proto.icmpv6;
+}
+
+#ifdef CONFIG_NF_CT_PROTO_DCCP
+static inline struct nf_dccp_net *nf_dccp_pernet(struct net *net)
+{
+       return &net->ct.nf_ct_proto.dccp;
+}
+#endif
+
+#ifdef CONFIG_NF_CT_PROTO_SCTP
+static inline struct nf_sctp_net *nf_sctp_pernet(struct net *net)
+{
+       return &net->ct.nf_ct_proto.sctp;
+}
+#endif
+
 #endif /*_NF_CONNTRACK_PROTOCOL_H*/
* Unmerged path net/ipv4/netfilter/nf_conntrack_proto_icmp.c
diff --git a/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c b/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
index 4b225a43a543..c0cef136360c 100644
--- a/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
@@ -29,11 +29,6 @@
 
 static const unsigned int nf_ct_icmpv6_timeout = 30*HZ;
 
-static inline struct nf_icmp_net *icmpv6_pernet(struct net *net)
-{
-	return &net->ct.nf_ct_proto.icmpv6;
-}
-
 static bool icmpv6_pkt_to_tuple(const struct sk_buff *skb,
 				unsigned int dataoff,
 				struct net *net,
@@ -86,7 +81,7 @@ static bool icmpv6_invert_tuple(struct nf_conntrack_tuple *tuple,
 
 static unsigned int *icmpv6_get_timeouts(struct net *net)
 {
-	return &icmpv6_pernet(net)->timeout;
+	return &nf_icmpv6_pernet(net)->timeout;
 }
 
 /* Returns verdict for packet, or -1 for invalid. */
@@ -278,7 +273,7 @@ static int icmpv6_timeout_nlattr_to_obj(struct nlattr *tb[],
 					struct net *net, void *data)
 {
 	unsigned int *timeout = data;
-	struct nf_icmp_net *in = icmpv6_pernet(net);
+	struct nf_icmp_net *in = nf_icmpv6_pernet(net);
 
 	if (tb[CTA_TIMEOUT_ICMPV6_TIMEOUT]) {
 		*timeout =
@@ -338,7 +333,7 @@ static int icmpv6_kmemdup_sysctl_table(struct nf_proto_net *pn,
 
 static int icmpv6_init_net(struct net *net)
 {
-	struct nf_icmp_net *in = icmpv6_pernet(net);
+	struct nf_icmp_net *in = nf_icmpv6_pernet(net);
 	struct nf_proto_net *pn = &in->pn;
 
 	in->timeout = nf_ct_icmpv6_timeout;
* Unmerged path net/netfilter/nf_conntrack_proto_dccp.c
* Unmerged path net/netfilter/nf_conntrack_proto_generic.c
* Unmerged path net/netfilter/nf_conntrack_proto_sctp.c
* Unmerged path net/netfilter/nf_conntrack_proto_tcp.c
diff --git a/net/netfilter/nf_conntrack_proto_udp.c b/net/netfilter/nf_conntrack_proto_udp.c
index ce9ce85bf0c7..e096783c8f94 100644
--- a/net/netfilter/nf_conntrack_proto_udp.c
+++ b/net/netfilter/nf_conntrack_proto_udp.c
@@ -31,14 +31,9 @@ static const unsigned int udp_timeouts[UDP_CT_MAX] = {
 	[UDP_CT_REPLIED]	= 180*HZ,
 };
 
-static inline struct nf_udp_net *udp_pernet(struct net *net)
-{
-	return &net->ct.nf_ct_proto.udp;
-}
-
 static unsigned int *udp_get_timeouts(struct net *net)
 {
-	return udp_pernet(net)->timeouts;
+	return nf_udp_pernet(net)->timeouts;
 }
 
 /* Returns verdict for packet, and may modify conntracktype */
@@ -174,7 +169,7 @@ static int udp_timeout_nlattr_to_obj(struct nlattr *tb[],
 				     struct net *net, void *data)
 {
 	unsigned int *timeouts = data;
-	struct nf_udp_net *un = udp_pernet(net);
+	struct nf_udp_net *un = nf_udp_pernet(net);
 
 	/* set default timeouts for UDP. */
 	timeouts[UDP_CT_UNREPLIED] = un->timeouts[UDP_CT_UNREPLIED];
@@ -251,7 +246,7 @@ static int udp_kmemdup_sysctl_table(struct nf_proto_net *pn,
 
 static int udp_init_net(struct net *net)
 {
-	struct nf_udp_net *un = udp_pernet(net);
+	struct nf_udp_net *un = nf_udp_pernet(net);
 	struct nf_proto_net *pn = &un->pn;
 
 	if (!pn->users) {
