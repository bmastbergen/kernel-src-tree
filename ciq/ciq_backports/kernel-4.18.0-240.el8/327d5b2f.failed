iommu/vt-d: Allow 32bit devices to uses DMA domain

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Lu Baolu <baolu.lu@linux.intel.com>
commit 327d5b2fee91c404a3956c324193892cf2cc9528
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/327d5b2f.failed

Currently, if a 32bit device initially uses an identity domain, Intel
IOMMU driver will convert it forcibly to a DMA one if its address
capability is not enough for the whole system memory. The motivation was
to overcome the overhead caused by possible bounced buffer.

Unfortunately, this improvement has led to many problems. For example,
some 32bit devices are required to use an identity domain, forcing them
to use DMA domain will cause the device not to work anymore. On the
other hand, the VMD sub-devices share a domain but each sub-device might
have different address capability. Forcing a VMD sub-device to use DMA
domain blindly will impact the operation of other sub-devices without
any notification. Further more, PCI aliased devices (PCI bridge and all
devices beneath it, VMD devices and various devices quirked with
pci_add_dma_alias()) must use the same domain. Forcing one device to
switch to DMA domain during runtime will cause in-fligh DMAs for other
devices to abort or target to other memory which might cause undefind
system behavior.

With the last private domain usage in iommu_need_mapping() removed, all
private domain helpers are also cleaned in this patch. Otherwise, the
compiler will complain that some functions are defined but not used.

	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
	Tested-by: Daniel Drake <drake@endlessm.com>
	Reviewed-by: Jon Derrick <jonathan.derrick@intel.com>
	Reviewed-by: Jerry Snitselaar <jsnitsel@redhat.com>
	Cc: Daniel Drake <drake@endlessm.com>
	Cc: Derrick Jonathan <jonathan.derrick@intel.com>
	Cc: Jerry Snitselaar <jsnitsel@redhat.com>
Link: https://lore.kernel.org/r/20200506015947.28662-2-baolu.lu@linux.intel.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 327d5b2fee91c404a3956c324193892cf2cc9528)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index b02ab04588c1,16ba7add0f72..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -346,13 -355,10 +346,8 @@@ static void domain_exit(struct dmar_dom
  static void domain_remove_dev_info(struct dmar_domain *domain);
  static void dmar_remove_one_dev_info(struct device *dev);
  static void __dmar_remove_one_dev_info(struct device_domain_info *info);
- static void domain_context_clear(struct intel_iommu *iommu,
- 				 struct device *dev);
- static int domain_detach_iommu(struct dmar_domain *domain,
- 			       struct intel_iommu *iommu);
- static bool device_is_rmrr_locked(struct device *dev);
  static int intel_iommu_attach_device(struct iommu_domain *domain,
  				     struct device *dev);
 -static phys_addr_t intel_iommu_iova_to_phys(struct iommu_domain *domain,
 -					    dma_addr_t iova);
  
  #ifdef CONFIG_INTEL_IOMMU_DEFAULT_ON
  int dmar_disabled = 0;
@@@ -3464,39 -3349,7 +3223,43 @@@ static bool iommu_need_mapping(struct d
  	if (unlikely(attach_deferred(dev)))
  		do_deferred_attach(dev);
  
++<<<<<<< HEAD
 +	ret = identity_mapping(dev);
 +	if (ret) {
 +		u64 dma_mask = *dev->dma_mask;
 +
 +		if (dev->coherent_dma_mask && dev->coherent_dma_mask < dma_mask)
 +			dma_mask = dev->coherent_dma_mask;
 +
 +		if (dma_mask >= dma_get_required_mask(dev))
 +			return false;
 +
 +		/*
 +		 * 32 bit DMA is removed from si_domain and fall back to
 +		 * non-identity mapping.
 +		 */
 +		dmar_remove_one_dev_info(dev);
 +		ret = iommu_request_dma_domain_for_dev(dev);
 +		if (ret) {
 +			struct iommu_domain *domain;
 +			struct dmar_domain *dmar_domain;
 +
 +			domain = iommu_get_domain_for_dev(dev);
 +			if (domain) {
 +				dmar_domain = to_dmar_domain(domain);
 +				dmar_domain->flags |= DOMAIN_FLAG_LOSE_CHILDREN;
 +			}
 +			dmar_remove_one_dev_info(dev);
 +			get_private_domain_for_dev(dev);
 +		}
 +
 +		dev_info(dev, "32bit DMA uses non-identity mapping\n");
 +	}
 +
 +	return true;
++=======
+ 	return !identity_mapping(dev);
++>>>>>>> 327d5b2fee91 (iommu/vt-d: Allow 32bit devices to uses DMA domain)
  }
  
  static dma_addr_t __intel_map_single(struct device *dev, phys_addr_t paddr,
* Unmerged path drivers/iommu/intel-iommu.c
