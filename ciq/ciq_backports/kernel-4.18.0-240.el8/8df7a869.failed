libperf: Add 'overwrite' to 'struct perf_mmap'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit 8df7a869818ec278969d34e4792985f12b24f23d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8df7a869.failed

Move 'overwrite' from tools/perf's mmap to libperf's perf_mmap struct.

Committer notes:

Add stdbool.h as we start using 'bool'.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lore.kernel.org/lkml/20190913132355.21634-17-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 8df7a869818ec278969d34e4792985f12b24f23d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/lib/include/internal/mmap.h
#	tools/perf/util/evlist.c
#	tools/perf/util/mmap.c
#	tools/perf/util/mmap.h
diff --cc tools/perf/util/evlist.c
index 29a998d183ce,16d47a420bc2..000000000000
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@@ -730,8 -708,8 +730,13 @@@ static struct perf_mmap *perf_evlist__a
  		return NULL;
  
  	for (i = 0; i < evlist->nr_mmaps; i++) {
++<<<<<<< HEAD
 +		map[i].fd = -1;
 +		map[i].overwrite = overwrite;
++=======
+ 		map[i].core.fd = -1;
+ 		map[i].core.overwrite = overwrite;
++>>>>>>> 8df7a869818e (libperf: Add 'overwrite' to 'struct perf_mmap')
  		/*
  		 * When the perf_mmap() call is made we grab one refcount, plus
  		 * one extra to let perf_mmap__consume() get the last
diff --cc tools/perf/util/mmap.c
index 850493205040,a8850ce2c2ff..000000000000
--- a/tools/perf/util/mmap.c
+++ b/tools/perf/util/mmap.c
@@@ -90,13 -93,13 +90,23 @@@ union perf_event *perf_mmap__read_event
  		return NULL;
  
  	/* non-overwirte doesn't pause the ringbuffer */
++<<<<<<< HEAD
 +	if (!map->overwrite)
 +		map->end = perf_mmap__read_head(map);
++=======
+ 	if (!map->core.overwrite)
+ 		map->core.end = perf_mmap__read_head(map);
++>>>>>>> 8df7a869818e (libperf: Add 'overwrite' to 'struct perf_mmap')
  
 -	event = perf_mmap__read(map, &map->core.start, map->core.end);
 +	event = perf_mmap__read(map, &map->start, map->end);
  
++<<<<<<< HEAD
 +	if (!map->overwrite)
 +		map->prev = map->start;
++=======
+ 	if (!map->core.overwrite)
+ 		map->core.prev = map->core.start;
++>>>>>>> 8df7a869818e (libperf: Add 'overwrite' to 'struct perf_mmap')
  
  	return event;
  }
@@@ -119,10 -122,10 +129,15 @@@ void perf_mmap__put(struct perf_mmap *m
  		perf_mmap__munmap(map);
  }
  
 -void perf_mmap__consume(struct mmap *map)
 +void perf_mmap__consume(struct perf_mmap *map)
  {
++<<<<<<< HEAD
 +	if (!map->overwrite) {
 +		u64 old = map->prev;
++=======
+ 	if (!map->core.overwrite) {
+ 		u64 old = map->core.prev;
++>>>>>>> 8df7a869818e (libperf: Add 'overwrite' to 'struct perf_mmap')
  
  		perf_mmap__write_tail(map, old);
  	}
@@@ -437,25 -440,25 +452,36 @@@ static int overwrite_rb_find_range(voi
  /*
   * Report the start and end of the available data in ringbuffer
   */
 -static int __perf_mmap__read_init(struct mmap *md)
 +static int __perf_mmap__read_init(struct perf_mmap *md)
  {
  	u64 head = perf_mmap__read_head(md);
 -	u64 old = md->core.prev;
 -	unsigned char *data = md->core.base + page_size;
 +	u64 old = md->prev;
 +	unsigned char *data = md->base + page_size;
  	unsigned long size;
  
++<<<<<<< HEAD
 +	md->start = md->overwrite ? head : old;
 +	md->end = md->overwrite ? old : head;
++=======
+ 	md->core.start = md->core.overwrite ? head : old;
+ 	md->core.end = md->core.overwrite ? old : head;
++>>>>>>> 8df7a869818e (libperf: Add 'overwrite' to 'struct perf_mmap')
  
 -	if ((md->core.end - md->core.start) < md->flush)
 +	if ((md->end - md->start) < md->flush)
  		return -EAGAIN;
  
++<<<<<<< HEAD
 +	size = md->end - md->start;
 +	if (size > (unsigned long)(md->mask) + 1) {
 +		if (!md->overwrite) {
++=======
+ 	size = md->core.end - md->core.start;
+ 	if (size > (unsigned long)(md->core.mask) + 1) {
+ 		if (!md->core.overwrite) {
++>>>>>>> 8df7a869818e (libperf: Add 'overwrite' to 'struct perf_mmap')
  			WARN_ONCE(1, "failed to keep up with mmap data. (warn only once)\n");
  
 -			md->core.prev = head;
 +			md->prev = head;
  			perf_mmap__consume(md);
  			return -EAGAIN;
  		}
diff --cc tools/perf/util/mmap.h
index 274ce389cd84,d3e74c8da51a..000000000000
--- a/tools/perf/util/mmap.h
+++ b/tools/perf/util/mmap.h
@@@ -18,16 -20,8 +18,21 @@@ struct aiocb
   *
   * @refcnt - e.g. code using PERF_EVENT_IOC_SET_OUTPUT to share this
   */
++<<<<<<< HEAD
 +struct perf_mmap {
 +	void		 *base;
 +	int		 mask;
 +	int		 fd;
 +	int		 cpu;
 +	refcount_t	 refcnt;
 +	u64		 prev;
 +	u64		 start;
 +	u64		 end;
 +	bool		 overwrite;
++=======
+ struct mmap {
+ 	struct perf_mmap	core;
++>>>>>>> 8df7a869818e (libperf: Add 'overwrite' to 'struct perf_mmap')
  	struct auxtrace_mmap auxtrace_mmap;
  	char		 event_copy[PERF_SAMPLE_MAX_SIZE] __aligned(8);
  #ifdef HAVE_AIO_SUPPORT
* Unmerged path tools/perf/lib/include/internal/mmap.h
* Unmerged path tools/perf/lib/include/internal/mmap.h
* Unmerged path tools/perf/util/evlist.c
* Unmerged path tools/perf/util/mmap.c
* Unmerged path tools/perf/util/mmap.h
