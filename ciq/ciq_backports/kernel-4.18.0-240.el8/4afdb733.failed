io-uring: drop completion when removing file

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Hillf Danton <hdanton@sina.com>
commit 4afdb733b1606c6cb86e7833f9335f4870cf7ddd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/4afdb733.failed

A case of task hung was reported by syzbot,

INFO: task syz-executor975:9880 blocked for more than 143 seconds.
      Not tainted 5.6.0-rc6-syzkaller #0
"echo 0 > /proc/sys/kernel/hung_task_timeout_secs" disables this message.
syz-executor975 D27576  9880   9878 0x80004000
Call Trace:
 schedule+0xd0/0x2a0 kernel/sched/core.c:4154
 schedule_timeout+0x6db/0xba0 kernel/time/timer.c:1871
 do_wait_for_common kernel/sched/completion.c:83 [inline]
 __wait_for_common kernel/sched/completion.c:104 [inline]
 wait_for_common kernel/sched/completion.c:115 [inline]
 wait_for_completion+0x26a/0x3c0 kernel/sched/completion.c:136
 io_queue_file_removal+0x1af/0x1e0 fs/io_uring.c:5826
 __io_sqe_files_update.isra.0+0x3a1/0xb00 fs/io_uring.c:5867
 io_sqe_files_update fs/io_uring.c:5918 [inline]
 __io_uring_register+0x377/0x2c00 fs/io_uring.c:7131
 __do_sys_io_uring_register fs/io_uring.c:7202 [inline]
 __se_sys_io_uring_register fs/io_uring.c:7184 [inline]
 __x64_sys_io_uring_register+0x192/0x560 fs/io_uring.c:7184
 do_syscall_64+0xf6/0x7d0 arch/x86/entry/common.c:294
 entry_SYSCALL_64_after_hwframe+0x49/0xbe

and bisect pointed to 05f3fb3c5397 ("io_uring: avoid ring quiesce for
fixed file set unregister and update").

It is down to the order that we wait for work done before flushing it
while nobody is likely going to wake us up.

We can drop that completion on stack as flushing work itself is a sync
operation we need and no more is left behind it.

To that end, io_file_put::done is re-used for indicating if it can be
freed in the workqueue worker context.

Reported-and-Inspired-by: syzbot <syzbot+538d1957ce178382a394@syzkaller.appspotmail.com>
	Signed-off-by: Hillf Danton <hdanton@sina.com>

Rename ->done to ->free_pfile

	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 4afdb733b1606c6cb86e7833f9335f4870cf7ddd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 7842c6de7135,c2dbef1e3272..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -3021,6 -6346,160 +3021,163 @@@ static void io_sqe_file_unregister(stru
  #endif
  }
  
++<<<<<<< HEAD
++=======
+ struct io_file_put {
+ 	struct llist_node llist;
+ 	struct file *file;
+ 	bool free_pfile;
+ };
+ 
+ static void io_ring_file_ref_flush(struct fixed_file_data *data)
+ {
+ 	struct io_file_put *pfile, *tmp;
+ 	struct llist_node *node;
+ 
+ 	while ((node = llist_del_all(&data->put_llist)) != NULL) {
+ 		llist_for_each_entry_safe(pfile, tmp, node, llist) {
+ 			io_ring_file_put(data->ctx, pfile->file);
+ 			if (pfile->free_pfile)
+ 				kfree(pfile);
+ 		}
+ 	}
+ }
+ 
+ static void io_ring_file_ref_switch(struct work_struct *work)
+ {
+ 	struct fixed_file_data *data;
+ 
+ 	data = container_of(work, struct fixed_file_data, ref_work);
+ 	io_ring_file_ref_flush(data);
+ 	percpu_ref_switch_to_percpu(&data->refs);
+ }
+ 
+ static void io_file_data_ref_zero(struct percpu_ref *ref)
+ {
+ 	struct fixed_file_data *data;
+ 
+ 	data = container_of(ref, struct fixed_file_data, refs);
+ 
+ 	/*
+ 	 * We can't safely switch from inside this context, punt to wq. If
+ 	 * the table ref is going away, the table is being unregistered.
+ 	 * Don't queue up the async work for that case, the caller will
+ 	 * handle it.
+ 	 */
+ 	if (!percpu_ref_is_dying(&data->refs))
+ 		queue_work(system_wq, &data->ref_work);
+ }
+ 
+ static int io_sqe_files_register(struct io_ring_ctx *ctx, void __user *arg,
+ 				 unsigned nr_args)
+ {
+ 	__s32 __user *fds = (__s32 __user *) arg;
+ 	unsigned nr_tables;
+ 	struct file *file;
+ 	int fd, ret = 0;
+ 	unsigned i;
+ 
+ 	if (ctx->file_data)
+ 		return -EBUSY;
+ 	if (!nr_args)
+ 		return -EINVAL;
+ 	if (nr_args > IORING_MAX_FIXED_FILES)
+ 		return -EMFILE;
+ 
+ 	ctx->file_data = kzalloc(sizeof(*ctx->file_data), GFP_KERNEL);
+ 	if (!ctx->file_data)
+ 		return -ENOMEM;
+ 	ctx->file_data->ctx = ctx;
+ 	init_completion(&ctx->file_data->done);
+ 
+ 	nr_tables = DIV_ROUND_UP(nr_args, IORING_MAX_FILES_TABLE);
+ 	ctx->file_data->table = kcalloc(nr_tables,
+ 					sizeof(struct fixed_file_table),
+ 					GFP_KERNEL);
+ 	if (!ctx->file_data->table) {
+ 		kfree(ctx->file_data);
+ 		ctx->file_data = NULL;
+ 		return -ENOMEM;
+ 	}
+ 
+ 	if (percpu_ref_init(&ctx->file_data->refs, io_file_data_ref_zero,
+ 				PERCPU_REF_ALLOW_REINIT, GFP_KERNEL)) {
+ 		kfree(ctx->file_data->table);
+ 		kfree(ctx->file_data);
+ 		ctx->file_data = NULL;
+ 		return -ENOMEM;
+ 	}
+ 	ctx->file_data->put_llist.first = NULL;
+ 	INIT_WORK(&ctx->file_data->ref_work, io_ring_file_ref_switch);
+ 
+ 	if (io_sqe_alloc_file_tables(ctx, nr_tables, nr_args)) {
+ 		percpu_ref_exit(&ctx->file_data->refs);
+ 		kfree(ctx->file_data->table);
+ 		kfree(ctx->file_data);
+ 		ctx->file_data = NULL;
+ 		return -ENOMEM;
+ 	}
+ 
+ 	for (i = 0; i < nr_args; i++, ctx->nr_user_files++) {
+ 		struct fixed_file_table *table;
+ 		unsigned index;
+ 
+ 		ret = -EFAULT;
+ 		if (copy_from_user(&fd, &fds[i], sizeof(fd)))
+ 			break;
+ 		/* allow sparse sets */
+ 		if (fd == -1) {
+ 			ret = 0;
+ 			continue;
+ 		}
+ 
+ 		table = &ctx->file_data->table[i >> IORING_FILE_TABLE_SHIFT];
+ 		index = i & IORING_FILE_TABLE_MASK;
+ 		file = fget(fd);
+ 
+ 		ret = -EBADF;
+ 		if (!file)
+ 			break;
+ 
+ 		/*
+ 		 * Don't allow io_uring instances to be registered. If UNIX
+ 		 * isn't enabled, then this causes a reference cycle and this
+ 		 * instance can never get freed. If UNIX is enabled we'll
+ 		 * handle it just fine, but there's still no point in allowing
+ 		 * a ring fd as it doesn't support regular read/write anyway.
+ 		 */
+ 		if (file->f_op == &io_uring_fops) {
+ 			fput(file);
+ 			break;
+ 		}
+ 		ret = 0;
+ 		table->files[index] = file;
+ 	}
+ 
+ 	if (ret) {
+ 		for (i = 0; i < ctx->nr_user_files; i++) {
+ 			file = io_file_from_index(ctx, i);
+ 			if (file)
+ 				fput(file);
+ 		}
+ 		for (i = 0; i < nr_tables; i++)
+ 			kfree(ctx->file_data->table[i].files);
+ 
+ 		kfree(ctx->file_data->table);
+ 		kfree(ctx->file_data);
+ 		ctx->file_data = NULL;
+ 		ctx->nr_user_files = 0;
+ 		return ret;
+ 	}
+ 
+ 	ret = io_sqe_files_scm(ctx);
+ 	if (ret)
+ 		io_sqe_files_unregister(ctx);
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 4afdb733b160 (io-uring: drop completion when removing file)
  static int io_sqe_file_register(struct io_ring_ctx *ctx, struct file *file,
  				int index)
  {
@@@ -3064,10 -6543,54 +3221,59 @@@
  #endif
  }
  
 -static void io_atomic_switch(struct percpu_ref *ref)
 +static int io_sqe_files_update(struct io_ring_ctx *ctx, void __user *arg,
 +			       unsigned nr_args)
  {
++<<<<<<< HEAD
 +	struct io_uring_files_update up;
++=======
+ 	struct fixed_file_data *data;
+ 
+ 	/*
+ 	 * Juggle reference to ensure we hit zero, if needed, so we can
+ 	 * switch back to percpu mode
+ 	 */
+ 	data = container_of(ref, struct fixed_file_data, refs);
+ 	percpu_ref_put(&data->refs);
+ 	percpu_ref_get(&data->refs);
+ }
+ 
+ static bool io_queue_file_removal(struct fixed_file_data *data,
+ 				  struct file *file)
+ {
+ 	struct io_file_put *pfile, pfile_stack;
+ 
+ 	/*
+ 	 * If we fail allocating the struct we need for doing async reomval
+ 	 * of this file, just punt to sync and wait for it.
+ 	 */
+ 	pfile = kzalloc(sizeof(*pfile), GFP_KERNEL);
+ 	if (!pfile) {
+ 		pfile = &pfile_stack;
+ 		pfile->free_pfile = false;
+ 	} else
+ 		pfile->free_pfile = true;
+ 
+ 	pfile->file = file;
+ 	llist_add(&pfile->llist, &data->put_llist);
+ 
+ 	if (pfile == &pfile_stack) {
+ 		percpu_ref_switch_to_atomic(&data->refs, io_atomic_switch);
+ 		flush_work(&data->ref_work);
+ 		return false;
+ 	}
+ 
+ 	return true;
+ }
+ 
+ static int __io_sqe_files_update(struct io_ring_ctx *ctx,
+ 				 struct io_uring_files_update *up,
+ 				 unsigned nr_args)
+ {
+ 	struct fixed_file_data *data = ctx->file_data;
+ 	bool ref_switch = false;
+ 	struct file *file;
++>>>>>>> 4afdb733b160 (io-uring: drop completion when removing file)
  	__s32 __user *fds;
  	int fd, i, err;
  	__u32 done;
* Unmerged path fs/io_uring.c
