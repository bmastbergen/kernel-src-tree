KVM: VMX: Introduce generic fastpath handler

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Wanpeng Li <wanpengli@tencent.com>
commit dcf068da7eb29362adf13f20e5c44a18d98ed9a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dcf068da.failed

Introduce generic fastpath handler to handle MSR fastpath, VMX-preemption
timer fastpath etc; move it after vmx_complete_interrupts() in order to
catch events delivered to the guest, and abort the fast path in later
patches.  While at it, move the kvm_exit tracepoint so that it is printed
for fastpath vmexits as well.

There is no observed performance effect for the IPI fastpath after this patch.

	Tested-by: Haiwei Li <lihaiwei@tencent.com>
	Cc: Haiwei Li <lihaiwei@tencent.com>
	Signed-off-by: Wanpeng Li <wanpengli@tencent.com>
	Suggested-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <1588055009-12677-2-git-send-email-wanpengli@tencent.com>
	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit dcf068da7eb29362adf13f20e5c44a18d98ed9a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index 539026efd9e1,d883fbb63566..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -6630,10 -6628,21 +6628,20 @@@ void vmx_update_host_rsp(struct vcpu_vm
  	}
  }
  
+ static enum exit_fastpath_completion vmx_exit_handlers_fastpath(struct kvm_vcpu *vcpu)
+ {
+ 	switch (to_vmx(vcpu)->exit_reason) {
+ 	case EXIT_REASON_MSR_WRITE:
+ 		return handle_fastpath_set_msr_irqoff(vcpu);
+ 	default:
+ 		return EXIT_FASTPATH_NONE;
+ 	}
+ }
+ 
  bool __vmx_vcpu_run(struct vcpu_vmx *vmx, unsigned long *regs, bool launched);
  
 -static enum exit_fastpath_completion vmx_vcpu_run(struct kvm_vcpu *vcpu)
 +static void vmx_vcpu_run(struct kvm_vcpu *vcpu)
  {
 -	enum exit_fastpath_completion exit_fastpath;
  	struct vcpu_vmx *vmx = to_vmx(vcpu);
  	unsigned long cr3, cr4;
  
@@@ -6783,28 -6792,22 +6791,42 @@@
  	if (unlikely((u16)vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY))
  		kvm_machine_check();
  
+ 	trace_kvm_exit(vmx->exit_reason, vcpu, KVM_ISA_VMX);
+ 
  	if (unlikely(vmx->exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY))
++<<<<<<< HEAD
 +		return;
++=======
+ 		return EXIT_FASTPATH_NONE;
++>>>>>>> dcf068da7eb2 (KVM: VMX: Introduce generic fastpath handler)
  
  	vmx->loaded_vmcs->launched = 1;
  	vmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);
  
  	vmx_recover_nmi_blocking(vmx);
  	vmx_complete_interrupts(vmx);
 +}
 +
++<<<<<<< HEAD
 +static struct kvm *vmx_vm_alloc(void)
 +{
 +	BUILD_BUG_ON(offsetof(struct kvm_vmx, kvm) != 0);
 +
 +	return __vmalloc(sizeof(struct kvm_vmx),
 +			 GFP_KERNEL_ACCOUNT | __GFP_ZERO, PAGE_KERNEL);
 +}
  
 +static void vmx_vm_free(struct kvm *kvm)
 +{
 +	kfree(kvm->arch.hyperv.hv_pa_pg);
 +	vfree(kvm);
++=======
+ 	if (is_guest_mode(vcpu))
+ 		return EXIT_FASTPATH_NONE;
+ 
+ 	exit_fastpath = vmx_exit_handlers_fastpath(vcpu);
+ 	return exit_fastpath;
++>>>>>>> dcf068da7eb2 (KVM: VMX: Introduce generic fastpath handler)
  }
  
  static void vmx_free_vcpu(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/vmx/vmx.c
