ASoC: SOF: Introduce state machine for FW boot

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: SOF: Introduce state machine for FW boot (Jaroslav Kysela) [1797509]
Rebuild_FUZZ: 93.88%
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit 6ca5cecbd1c1758666ab79446f19e0e61ed11444
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6ca5cecb.failed

Add a state machine for FW boot to track the
different stages of FW boot and replace the boot_complete
field with fw_state field in struct snd_sof_dev.
This will be used to determine the actions to be performed
during system suspend.

One of the main motivations for adding this change is the
fact that errors during the top-level SOF device probe cannot
be propagated and therefore suspending the SOF device normally
during system suspend could potentially run into errors.
For example, with the current flow, if the FW boot failed
for some reason and the system suspends, the SOF device
suspend could fail because the CTX_SAVE IPC would be attempted
even though the FW never really booted successfully causing it
to time out. Another scenario that the state machine fixes
is when the runtime suspend for the SOF device fails and
the DSP is powered down nevertheless, the CTX_SAVE IPC during
system suspend would timeout because the DSP is already
powered down.

	Reviewed-by: Curtis Malainey <cujomalainey@chromium.org>
	Reviewed-by: Daniel Baluta <daniel.baluta@nxp.com>
	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Link: https://lore.kernel.org/r/20191218002616.7652-2-pierre-louis.bossart@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 6ca5cecbd1c1758666ab79446f19e0e61ed11444)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/core.c
#	sound/soc/sof/sof-priv.h
diff --cc sound/soc/sof/core.c
index d8446fb9fdde,44f9c04d54aa..000000000000
--- a/sound/soc/sof/core.c
+++ b/sound/soc/sof/core.c
@@@ -213,39 -93,44 +213,80 @@@ out
  EXPORT_SYMBOL(snd_sof_get_status);
  
  /*
++<<<<<<< HEAD
 + * SOF Driver enumeration.
 + */
 +static int sof_machine_check(struct snd_sof_dev *sdev)
 +{
 +	struct snd_sof_pdata *plat_data = sdev->pdata;
 +#if IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC)
 +	struct snd_soc_acpi_mach *machine;
 +	int ret;
 +#endif
 +
 +	if (plat_data->machine)
 +		return 0;
 +
 +#if !IS_ENABLED(CONFIG_SND_SOC_SOF_NOCODEC)
 +	dev_err(sdev->dev, "error: no matching ASoC machine driver found - aborting probe\n");
 +	return -ENODEV;
 +#else
 +	/* fallback to nocodec mode */
 +	dev_warn(sdev->dev, "No ASoC machine driver found - using nocodec\n");
 +	machine = devm_kzalloc(sdev->dev, sizeof(*machine), GFP_KERNEL);
 +	if (!machine)
 +		return -ENOMEM;
 +
 +	ret = sof_nocodec_setup(sdev->dev, plat_data, machine,
 +				plat_data->desc, plat_data->desc->ops);
 +	if (ret < 0)
 +		return ret;
 +
 +	plat_data->machine = machine;
 +
 +	return 0;
 +#endif
 +}
++=======
+  *			FW Boot State Transition Diagram
+  *
+  *    +-----------------------------------------------------------------------+
+  *    |									      |
+  * ------------------	     ------------------				      |
+  * |		    |	     |		      |				      |
+  * |   BOOT_FAILED  |	     |  READY_FAILED  |-------------------------+     |
+  * |		    |	     |	              |				|     |
+  * ------------------	     ------------------				|     |
+  *	^			    ^					|     |
+  *	|			    |					|     |
+  * (FW Boot Timeout)		(FW_READY FAIL)				|     |
+  *	|			    |					|     |
+  *	|			    |					|     |
+  * ------------------		    |		   ------------------	|     |
+  * |		    |		    |		   |		    |	|     |
+  * |   IN_PROGRESS  |---------------+------------->|    COMPLETE    |	|     |
+  * |		    | (FW Boot OK)   (FW_READY OK) |		    |	|     |
+  * ------------------				   ------------------	|     |
+  *	^						|		|     |
+  *	|						|		|     |
+  * (FW Loading OK)			       (System Suspend/Runtime Suspend)
+  *	|						|		|     |
+  *	|						|		|     |
+  * ------------------		------------------	|		|     |
+  * |		    |		|		 |<-----+		|     |
+  * |   PREPARE	    |		|   NOT_STARTED  |<---------------------+     |
+  * |		    |		|		 |<---------------------------+
+  * ------------------		------------------
+  *    |	    ^			    |	   ^
+  *    |	    |			    |	   |
+  *    |	    +-----------------------+	   |
+  *    |		(DSP Probe OK)		   |
+  *    |					   |
+  *    |					   |
+  *    +------------------------------------+
+  *	(System Suspend/Runtime Suspend)
+  */
++>>>>>>> 6ca5cecbd1c1 (ASoC: SOF: Introduce state machine for FW boot)
  
  static int sof_probe_continue(struct snd_sof_dev *sdev)
  {
diff --cc sound/soc/sof/sof-priv.h
index d6f26a1a0cdb,220b35141c34..000000000000
--- a/sound/soc/sof/sof-priv.h
+++ b/sound/soc/sof/sof-priv.h
@@@ -304,88 -298,13 +304,98 @@@ struct snd_sof_ipc_msg 
  	bool ipc_complete;
  };
  
++<<<<<<< HEAD
 +/* PCM stream, mapped to FW component  */
 +struct snd_sof_pcm_stream {
 +	u32 comp_id;
 +	struct snd_dma_buffer page_table;
 +	struct sof_ipc_stream_posn posn;
 +	struct snd_pcm_substream *substream;
 +	struct work_struct period_elapsed_work;
 +	bool d0i3_compatible; /* DSP can be in D0I3 when this pcm is opened */
 +	/*
 +	 * flag to indicate that the DSP pipelines should be kept
 +	 * active or not while suspending the stream
 +	 */
 +	bool suspend_ignored;
 +};
 +
 +/* ALSA SOF PCM device */
 +struct snd_sof_pcm {
 +	struct snd_sof_dev *sdev;
 +	struct snd_soc_tplg_pcm pcm;
 +	struct snd_sof_pcm_stream stream[2];
 +	struct list_head list;	/* list in sdev pcm list */
 +	struct snd_pcm_hw_params params[2];
 +	bool prepared[2]; /* PCM_PARAMS set successfully */
 +};
 +
 +struct snd_sof_led_control {
 +	unsigned int use_led;
 +	unsigned int direction;
 +	unsigned int led_value;
 +};
 +
 +/* ALSA SOF Kcontrol device */
 +struct snd_sof_control {
 +	struct snd_sof_dev *sdev;
 +	int comp_id;
 +	int min_volume_step; /* min volume step for volume_table */
 +	int max_volume_step; /* max volume step for volume_table */
 +	int num_channels;
 +	u32 readback_offset; /* offset to mmaped data if used */
 +	struct sof_ipc_ctrl_data *control_data;
 +	u32 size;	/* cdata size */
 +	enum sof_ipc_ctrl_cmd cmd;
 +	u32 *volume_table; /* volume table computed from tlv data*/
 +
 +	struct list_head list;	/* list in sdev control list */
 +
 +	struct snd_sof_led_control led_ctl;
 +};
 +
 +/* ASoC SOF DAPM widget */
 +struct snd_sof_widget {
 +	struct snd_sof_dev *sdev;
 +	int comp_id;
 +	int pipeline_id;
 +	int complete;
 +	int id;
 +
 +	struct snd_soc_dapm_widget *widget;
 +	struct list_head list;	/* list in sdev widget list */
 +
 +	void *private;		/* core does not touch this */
 +};
 +
 +/* ASoC SOF DAPM route */
 +struct snd_sof_route {
 +	struct snd_sof_dev *sdev;
 +
 +	struct snd_soc_dapm_route *route;
 +	struct list_head list;	/* list in sdev route list */
 +
 +	void *private;
 +};
 +
 +/* ASoC DAI device */
 +struct snd_sof_dai {
 +	struct snd_sof_dev *sdev;
 +	const char *name;
 +	const char *cpu_dai_name;
 +
 +	struct sof_ipc_comp_dai comp_dai;
 +	struct sof_ipc_dai_config *dai_config;
 +	struct list_head list;	/* list in sdev dai list */
++=======
+ enum snd_sof_fw_state {
+ 	SOF_FW_BOOT_NOT_STARTED = 0,
+ 	SOF_FW_BOOT_PREPARE,
+ 	SOF_FW_BOOT_IN_PROGRESS,
+ 	SOF_FW_BOOT_FAILED,
+ 	SOF_FW_BOOT_READY_FAILED, /* firmware booted but fw_ready op failed */
+ 	SOF_FW_BOOT_COMPLETE,
++>>>>>>> 6ca5cecbd1c1 (ASoC: SOF: Introduce state machine for FW boot)
  };
  
  /*
* Unmerged path sound/soc/sof/core.c
diff --git a/sound/soc/sof/intel/hda-loader.c b/sound/soc/sof/intel/hda-loader.c
index b1783360fe10..1782f5092639 100644
--- a/sound/soc/sof/intel/hda-loader.c
+++ b/sound/soc/sof/intel/hda-loader.c
@@ -295,7 +295,6 @@ int hda_dsp_cl_boot_firmware(struct snd_sof_dev *sdev)
 
 	/* init for booting wait */
 	init_waitqueue_head(&sdev->boot_wait);
-	sdev->boot_complete = false;
 
 	/* prepare DMA for code loader stream */
 	tag = cl_stream_prepare(sdev, 0x40, stripped_firmware.size,
diff --git a/sound/soc/sof/intel/hda.c b/sound/soc/sof/intel/hda.c
index bfdb817b3780..c39f78f1c9b7 100644
--- a/sound/soc/sof/intel/hda.c
+++ b/sound/soc/sof/intel/hda.c
@@ -168,7 +168,7 @@ void hda_dsp_dump_skl(struct snd_sof_dev *sdev, u32 flags)
 	panic = snd_sof_dsp_read(sdev, HDA_DSP_BAR,
 				 HDA_ADSP_ERROR_CODE_SKL + 0x4);
 
-	if (sdev->boot_complete) {
+	if (sdev->fw_state == SOF_FW_BOOT_COMPLETE) {
 		hda_dsp_get_registers(sdev, &xoops, &panic_info, stack,
 				      HDA_DSP_STACK_DUMP_SIZE);
 		snd_sof_get_status(sdev, status, panic, &xoops, &panic_info,
@@ -195,7 +195,7 @@ void hda_dsp_dump(struct snd_sof_dev *sdev, u32 flags)
 				  HDA_DSP_SRAM_REG_FW_STATUS);
 	panic = snd_sof_dsp_read(sdev, HDA_DSP_BAR, HDA_DSP_SRAM_REG_FW_TRACEP);
 
-	if (sdev->boot_complete) {
+	if (sdev->fw_state == SOF_FW_BOOT_COMPLETE) {
 		hda_dsp_get_registers(sdev, &xoops, &panic_info, stack,
 				      HDA_DSP_STACK_DUMP_SIZE);
 		snd_sof_get_status(sdev, status, panic, &xoops, &panic_info,
diff --git a/sound/soc/sof/ipc.c b/sound/soc/sof/ipc.c
index 8c93ffa209b8..aedcfd49c809 100644
--- a/sound/soc/sof/ipc.c
+++ b/sound/soc/sof/ipc.c
@@ -346,19 +346,12 @@ void snd_sof_ipc_msgs_rx(struct snd_sof_dev *sdev)
 		break;
 	case SOF_IPC_FW_READY:
 		/* check for FW boot completion */
-		if (!sdev->boot_complete) {
+		if (sdev->fw_state == SOF_FW_BOOT_IN_PROGRESS) {
 			err = sof_ops(sdev)->fw_ready(sdev, cmd);
-			if (err < 0) {
-				/*
-				 * this indicates a mismatch in ABI
-				 * between the driver and fw
-				 */
-				dev_err(sdev->dev, "error: ABI mismatch %d\n",
-					err);
-			} else {
-				/* firmware boot completed OK */
-				sdev->boot_complete = true;
-			}
+			if (err < 0)
+				sdev->fw_state = SOF_FW_BOOT_READY_FAILED;
+			else
+				sdev->fw_state = SOF_FW_BOOT_COMPLETE;
 
 			/* wake up firmware loader */
 			wake_up(&sdev->boot_wait);
diff --git a/sound/soc/sof/loader.c b/sound/soc/sof/loader.c
index 432d12bd4937..31847aa3975d 100644
--- a/sound/soc/sof/loader.c
+++ b/sound/soc/sof/loader.c
@@ -512,7 +512,6 @@ int snd_sof_run_firmware(struct snd_sof_dev *sdev)
 	int init_core_mask;
 
 	init_waitqueue_head(&sdev->boot_wait);
-	sdev->boot_complete = false;
 
 	/* create read-only fw_version debugfs to store boot version info */
 	if (sdev->first_boot) {
@@ -544,19 +543,27 @@ int snd_sof_run_firmware(struct snd_sof_dev *sdev)
 
 	init_core_mask = ret;
 
-	/* now wait for the DSP to boot */
-	ret = wait_event_timeout(sdev->boot_wait, sdev->boot_complete,
+	/*
+	 * now wait for the DSP to boot. There are 3 possible outcomes:
+	 * 1. Boot wait times out indicating FW boot failure.
+	 * 2. FW boots successfully and fw_ready op succeeds.
+	 * 3. FW boots but fw_ready op fails.
+	 */
+	ret = wait_event_timeout(sdev->boot_wait,
+				 sdev->fw_state > SOF_FW_BOOT_IN_PROGRESS,
 				 msecs_to_jiffies(sdev->boot_timeout));
 	if (ret == 0) {
 		dev_err(sdev->dev, "error: firmware boot failure\n");
 		snd_sof_dsp_dbg_dump(sdev, SOF_DBG_REGS | SOF_DBG_MBOX |
 			SOF_DBG_TEXT | SOF_DBG_PCI);
-		/* after this point FW_READY msg should be ignored */
-		sdev->boot_complete = true;
+		sdev->fw_state = SOF_FW_BOOT_FAILED;
 		return -EIO;
 	}
 
-	dev_info(sdev->dev, "firmware boot complete\n");
+	if (sdev->fw_state == SOF_FW_BOOT_COMPLETE)
+		dev_info(sdev->dev, "firmware boot complete\n");
+	else
+		return -EIO; /* FW boots but fw_ready op failed */
 
 	/* perform post fw run operations */
 	ret = snd_sof_dsp_post_fw_run(sdev);
diff --git a/sound/soc/sof/pm.c b/sound/soc/sof/pm.c
index 0fd5567237a8..ff1ff68e8b26 100644
--- a/sound/soc/sof/pm.c
+++ b/sound/soc/sof/pm.c
@@ -283,6 +283,8 @@ static int sof_resume(struct device *dev, bool runtime_resume)
 		return ret;
 	}
 
+	sdev->fw_state = SOF_FW_BOOT_PREPARE;
+
 	/* load the firmware */
 	ret = snd_sof_load_firmware(sdev);
 	if (ret < 0) {
@@ -292,7 +294,12 @@ static int sof_resume(struct device *dev, bool runtime_resume)
 		return ret;
 	}
 
-	/* boot the firmware */
+	sdev->fw_state = SOF_FW_BOOT_IN_PROGRESS;
+
+	/*
+	 * Boot the firmware. The FW boot status will be modified
+	 * in snd_sof_run_firmware() depending on the outcome.
+	 */
 	ret = snd_sof_run_firmware(sdev);
 	if (ret < 0) {
 		dev_err(sdev->dev,
@@ -341,6 +348,9 @@ static int sof_suspend(struct device *dev, bool runtime_suspend)
 	if (!sof_ops(sdev)->suspend)
 		return 0;
 
+	if (sdev->fw_state != SOF_FW_BOOT_COMPLETE)
+		goto power_down;
+
 	/* release trace */
 	snd_sof_release_trace(sdev);
 
@@ -378,6 +388,12 @@ static int sof_suspend(struct device *dev, bool runtime_suspend)
 			 ret);
 	}
 
+power_down:
+
+	/* return if the DSP was not probed successfully */
+	if (sdev->fw_state == SOF_FW_BOOT_NOT_STARTED)
+		return 0;
+
 	/* power down all DSP cores */
 	if (runtime_suspend)
 		ret = snd_sof_dsp_runtime_suspend(sdev);
@@ -388,6 +404,9 @@ static int sof_suspend(struct device *dev, bool runtime_suspend)
 			"error: failed to power down DSP during suspend %d\n",
 			ret);
 
+	/* reset FW state */
+	sdev->fw_state = SOF_FW_BOOT_NOT_STARTED;
+
 	return ret;
 }
 
* Unmerged path sound/soc/sof/sof-priv.h
