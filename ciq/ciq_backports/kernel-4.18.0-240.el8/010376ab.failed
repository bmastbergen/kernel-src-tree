Bluetooth: hci_qca: wait for Pre shutdown complete event before sending the Power off pulse

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Harish Bandi <c-hbandi@codeaurora.org>
commit 010376ab7fd788a0eddb86b6de5869b3045b97e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/010376ab.failed

When SoC receives pre shut down command, it share the same
with other COEX shared clients. So SoC needs a short time
after sending VS pre shutdown command before turning off
the regulators and sending the power off pulse. Along with
short delay, needs to wait for command complete event for
Pre shutdown VS command

	Signed-off-by: Harish Bandi <c-hbandi@codeaurora.org>
	Reviewed-by: Balakrishna Godavarthi <bgodavar@codeaurora.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 010376ab7fd788a0eddb86b6de5869b3045b97e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btqca.c
#	drivers/bluetooth/hci_qca.c
diff --cc drivers/bluetooth/btqca.c
index 8219816c54a0,8cc21ad7cf29..000000000000
--- a/drivers/bluetooth/btqca.c
+++ b/drivers/bluetooth/btqca.c
@@@ -108,7 -99,29 +108,33 @@@ static int rome_reset(struct hci_dev *h
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void rome_tlv_check_data(struct rome_config *config,
++=======
+ int qca_send_pre_shutdown_cmd(struct hci_dev *hdev)
+ {
+ 	struct sk_buff *skb;
+ 	int err;
+ 
+ 	bt_dev_dbg(hdev, "QCA pre shutdown cmd");
+ 
+ 	skb = __hci_cmd_sync_ev(hdev, QCA_PRE_SHUTDOWN_CMD, 0,
+ 				NULL, HCI_EV_CMD_COMPLETE, HCI_INIT_TIMEOUT);
+ 
+ 	if (IS_ERR(skb)) {
+ 		err = PTR_ERR(skb);
+ 		bt_dev_err(hdev, "QCA preshutdown_cmd failed (%d)", err);
+ 		return err;
+ 	}
+ 
+ 	kfree_skb(skb);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(qca_send_pre_shutdown_cmd);
+ 
+ static void qca_tlv_check_data(struct rome_config *config,
++>>>>>>> 010376ab7fd7 (Bluetooth: hci_qca: wait for Pre shutdown complete event before sending the Power off pulse)
  				const struct firmware *fw)
  {
  	const u8 *data;
diff --cc drivers/bluetooth/hci_qca.c
index c7723b08787d,d33828fef89f..000000000000
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@@ -988,6 -1327,153 +988,156 @@@ static const struct hci_uart_proto qca_
  	.dequeue	= qca_dequeue,
  };
  
++<<<<<<< HEAD
++=======
+ static const struct qca_vreg_data qca_soc_data_wcn3990 = {
+ 	.soc_type = QCA_WCN3990,
+ 	.vregs = (struct qca_vreg []) {
+ 		{ "vddio",   1800000, 1900000,  15000  },
+ 		{ "vddxo",   1800000, 1900000,  80000  },
+ 		{ "vddrf",   1300000, 1350000,  300000 },
+ 		{ "vddch0",  3300000, 3400000,  450000 },
+ 	},
+ 	.num_vregs = 4,
+ };
+ 
+ static const struct qca_vreg_data qca_soc_data_wcn3998 = {
+ 	.soc_type = QCA_WCN3998,
+ 	.vregs = (struct qca_vreg []) {
+ 		{ "vddio",   1800000, 1900000,  10000  },
+ 		{ "vddxo",   1800000, 1900000,  80000  },
+ 		{ "vddrf",   1300000, 1352000,  300000 },
+ 		{ "vddch0",  3300000, 3300000,  450000 },
+ 	},
+ 	.num_vregs = 4,
+ };
+ 
+ static void qca_power_shutdown(struct hci_uart *hu)
+ {
+ 	struct qca_data *qca = hu->priv;
+ 	unsigned long flags;
+ 
+ 	/* From this point we go into power off state. But serial port is
+ 	 * still open, stop queueing the IBS data and flush all the buffered
+ 	 * data in skb's.
+ 	 */
+ 	spin_lock_irqsave(&qca->hci_ibs_lock, flags);
+ 	clear_bit(QCA_IBS_ENABLED, &qca->flags);
+ 	qca_flush(hu);
+ 	spin_unlock_irqrestore(&qca->hci_ibs_lock, flags);
+ 
+ 	host_set_baudrate(hu, 2400);
+ 	qca_send_power_pulse(hu, false);
+ 	qca_power_setup(hu, false);
+ }
+ 
+ static int qca_power_off(struct hci_dev *hdev)
+ {
+ 	struct hci_uart *hu = hci_get_drvdata(hdev);
+ 
+ 	/* Perform pre shutdown command */
+ 	qca_send_pre_shutdown_cmd(hdev);
+ 
+ 	usleep_range(8000, 10000);
+ 
+ 	qca_power_shutdown(hu);
+ 	return 0;
+ }
+ 
+ static int qca_enable_regulator(struct qca_vreg vregs,
+ 				struct regulator *regulator)
+ {
+ 	int ret;
+ 
+ 	ret = regulator_set_voltage(regulator, vregs.min_uV,
+ 				    vregs.max_uV);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (vregs.load_uA)
+ 		ret = regulator_set_load(regulator,
+ 					 vregs.load_uA);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	return regulator_enable(regulator);
+ 
+ }
+ 
+ static void qca_disable_regulator(struct qca_vreg vregs,
+ 				  struct regulator *regulator)
+ {
+ 	regulator_disable(regulator);
+ 	regulator_set_voltage(regulator, 0, vregs.max_uV);
+ 	if (vregs.load_uA)
+ 		regulator_set_load(regulator, 0);
+ 
+ }
+ 
+ static int qca_power_setup(struct hci_uart *hu, bool on)
+ {
+ 	struct qca_vreg *vregs;
+ 	struct regulator_bulk_data *vreg_bulk;
+ 	struct qca_serdev *qcadev;
+ 	int i, num_vregs, ret = 0;
+ 
+ 	qcadev = serdev_device_get_drvdata(hu->serdev);
+ 	if (!qcadev || !qcadev->bt_power || !qcadev->bt_power->vreg_data ||
+ 	    !qcadev->bt_power->vreg_bulk)
+ 		return -EINVAL;
+ 
+ 	vregs = qcadev->bt_power->vreg_data->vregs;
+ 	vreg_bulk = qcadev->bt_power->vreg_bulk;
+ 	num_vregs = qcadev->bt_power->vreg_data->num_vregs;
+ 	BT_DBG("on: %d", on);
+ 	if (on && !qcadev->bt_power->vregs_on) {
+ 		for (i = 0; i < num_vregs; i++) {
+ 			ret = qca_enable_regulator(vregs[i],
+ 						   vreg_bulk[i].consumer);
+ 			if (ret)
+ 				break;
+ 		}
+ 
+ 		if (ret) {
+ 			BT_ERR("failed to enable regulator:%s", vregs[i].name);
+ 			/* turn off regulators which are enabled */
+ 			for (i = i - 1; i >= 0; i--)
+ 				qca_disable_regulator(vregs[i],
+ 						      vreg_bulk[i].consumer);
+ 		} else {
+ 			qcadev->bt_power->vregs_on = true;
+ 		}
+ 	} else if (!on && qcadev->bt_power->vregs_on) {
+ 		/* turn off regulator in reverse order */
+ 		i = qcadev->bt_power->vreg_data->num_vregs - 1;
+ 		for ( ; i >= 0; i--)
+ 			qca_disable_regulator(vregs[i], vreg_bulk[i].consumer);
+ 
+ 		qcadev->bt_power->vregs_on = false;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int qca_init_regulators(struct qca_power *qca,
+ 				const struct qca_vreg *vregs, size_t num_vregs)
+ {
+ 	int i;
+ 
+ 	qca->vreg_bulk = devm_kcalloc(qca->dev, num_vregs,
+ 				      sizeof(struct regulator_bulk_data),
+ 				      GFP_KERNEL);
+ 	if (!qca->vreg_bulk)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < num_vregs; i++)
+ 		qca->vreg_bulk[i].supply = vregs[i].name;
+ 
+ 	return devm_regulator_bulk_get(qca->dev, num_vregs, qca->vreg_bulk);
+ }
+ 
++>>>>>>> 010376ab7fd7 (Bluetooth: hci_qca: wait for Pre shutdown complete event before sending the Power off pulse)
  static int qca_serdev_probe(struct serdev_device *serdev)
  {
  	struct qca_serdev *qcadev;
* Unmerged path drivers/bluetooth/btqca.c
* Unmerged path drivers/bluetooth/hci_qca.c
