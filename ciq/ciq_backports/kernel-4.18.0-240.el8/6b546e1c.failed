x86/tss: Fix and move VMX BUILD_BUG_ON()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [x86] tss: Fix and move VMX BUILD_BUG_ON() (Vitaly Kuznetsov) [1813987]
Rebuild_FUZZ: 94.74%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 6b546e1c9ad2a25f874f8bc6077d0f55f9446414
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6b546e1c.failed

The BUILD_BUG_ON(IO_BITMAP_OFFSET - 1 == 0x67) in the VMX code is bogus in
two aspects:

1) This wants to be in generic x86 code simply to catch issues even when
   VMX is disabled in Kconfig.

2) The IO_BITMAP_OFFSET is not the right thing to check because it makes
   asssumptions about the layout of tss_struct. Nothing requires that the
   I/O bitmap is placed right after x86_tss, which is the hardware mandated
   tss structure. It pointlessly makes restrictions on the struct
   tss_struct layout.

The proper thing to check is:

    - Offset of x86_tss in tss_struct is 0
    - Size of x86_tss == 0x68

Move it to the other build time TSS checks and make it do the right thing.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Acked-by: Paolo Bonzini <pbonzini@redhat.com>
	Acked-by: Andy Lutomirski <luto@kernel.org>

(cherry picked from commit 6b546e1c9ad2a25f874f8bc6077d0f55f9446414)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/cpu_entry_area.c
diff --cc arch/x86/mm/cpu_entry_area.c
index 12d7e7fb4efd,2c1d4223a343..000000000000
--- a/arch/x86/mm/cpu_entry_area.c
+++ b/arch/x86/mm/cpu_entry_area.c
@@@ -128,8 -161,15 +128,20 @@@ static void __init setup_cpu_entry_area
  	BUILD_BUG_ON((offsetof(struct tss_struct, x86_tss) ^
  		      offsetofend(struct tss_struct, x86_tss)) & PAGE_MASK);
  	BUILD_BUG_ON(sizeof(struct tss_struct) % PAGE_SIZE != 0);
++<<<<<<< HEAD
 +	cea_map_percpu_pages(&get_cpu_entry_area(cpu)->tss,
 +			     &per_cpu(cpu_tss_rw, cpu),
++=======
+ 	/*
+ 	 * VMX changes the host TR limit to 0x67 after a VM exit. This is
+ 	 * okay, since 0x67 covers the size of struct x86_hw_tss. Make sure
+ 	 * that this is correct.
+ 	 */
+ 	BUILD_BUG_ON(offsetof(struct tss_struct, x86_tss) != 0);
+ 	BUILD_BUG_ON(sizeof(struct x86_hw_tss) != 0x68);
+ 
+ 	cea_map_percpu_pages(&cea->tss, &per_cpu(cpu_tss_rw, cpu),
++>>>>>>> 6b546e1c9ad2 (x86/tss: Fix and move VMX BUILD_BUG_ON())
  			     sizeof(struct tss_struct) / PAGE_SIZE, tss_prot);
  
  #ifdef CONFIG_X86_32
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index aa30cdc38a35..b5e7fe25864e 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -1372,14 +1372,6 @@ void vmx_vcpu_load_vmcs(struct kvm_vcpu *vcpu, int cpu)
 			    (unsigned long)&get_cpu_entry_area(cpu)->tss.x86_tss);
 		vmcs_writel(HOST_GDTR_BASE, (unsigned long)gdt);   /* 22.2.4 */
 
-		/*
-		 * VM exits change the host TR limit to 0x67 after a VM
-		 * exit.  This is okay, since 0x67 covers everything except
-		 * the IO bitmap and have have code to handle the IO bitmap
-		 * being lost after a VM exit.
-		 */
-		BUILD_BUG_ON(IO_BITMAP_OFFSET - 1 != 0x67);
-
 		rdmsrl(MSR_IA32_SYSENTER_ESP, sysenter_esp);
 		vmcs_writel(HOST_IA32_SYSENTER_ESP, sysenter_esp); /* 22.2.3 */
 
* Unmerged path arch/x86/mm/cpu_entry_area.c
