dm writecache: implement gradual cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit 3923d4854e189d84c6ec22e66d536d3498f2747c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/3923d485.failed

If a block is stored in the cache for too long, it will now be
written to the underlying device and cleaned up.

Add a new option "max_age" that specifies the maximum age of a block
in milliseconds.

	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 3923d4854e189d84c6ec22e66d536d3498f2747c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-writecache.c
diff --cc drivers/md/dm-writecache.c
index adfec9d8e315,e5c7b9072dd0..000000000000
--- a/drivers/md/dm-writecache.c
+++ b/drivers/md/dm-writecache.c
@@@ -622,7 -633,23 +629,27 @@@ static void writecache_add_to_freelist(
  	wc->freelist_size++;
  }
  
++<<<<<<< HEAD
 +static struct wc_entry *writecache_pop_from_freelist(struct dm_writecache *wc)
++=======
+ static inline void writecache_verify_watermark(struct dm_writecache *wc)
+ {
+ 	if (unlikely(wc->freelist_size + wc->writeback_size <= wc->freelist_high_watermark))
+ 		queue_work(wc->writeback_wq, &wc->writeback_work);
+ }
+ 
+ static void writecache_max_age_timer(struct timer_list *t)
+ {
+ 	struct dm_writecache *wc = from_timer(wc, t, max_age_timer);
+ 
+ 	if (!dm_suspended(wc->ti) && !writecache_has_error(wc)) {
+ 		queue_work(wc->writeback_wq, &wc->writeback_work);
+ 		mod_timer(&wc->max_age_timer, jiffies + wc->max_age / MAX_AGE_DIV);
+ 	}
+ }
+ 
+ static struct wc_entry *writecache_pop_from_freelist(struct dm_writecache *wc, sector_t expected_sector)
++>>>>>>> 3923d4854e18 (dm writecache: implement gradual cleanup)
  {
  	struct wc_entry *e;
  
@@@ -958,9 -987,14 +986,17 @@@ erase_this
  
  	if (need_flush) {
  		writecache_flush_all_metadata(wc);
 -		writecache_commit_flushed(wc, false);
 +		writecache_commit_flushed(wc);
  	}
  
++<<<<<<< HEAD
++=======
+ 	writecache_verify_watermark(wc);
+ 
+ 	if (wc->max_age != MAX_AGE_UNSPECIFIED)
+ 		mod_timer(&wc->max_age_timer, jiffies + wc->max_age / MAX_AGE_DIV);
+ 
++>>>>>>> 3923d4854e18 (dm writecache: implement gradual cleanup)
  	wc_unlock(wc);
  }
  
@@@ -2042,6 -2125,16 +2082,19 @@@ static int writecache_ctr(struct dm_tar
  				goto invalid_optional;
  			wc->autocommit_jiffies = msecs_to_jiffies(autocommit_msecs);
  			wc->autocommit_time_set = true;
++<<<<<<< HEAD
++=======
+ 		} else if (!strcasecmp(string, "max_age") && opt_params >= 1) {
+ 			unsigned max_age_msecs;
+ 			string = dm_shift_arg(&as), opt_params--;
+ 			if (sscanf(string, "%u%c", &max_age_msecs, &dummy) != 1)
+ 				goto invalid_optional;
+ 			if (max_age_msecs > 86400000)
+ 				goto invalid_optional;
+ 			wc->max_age = msecs_to_jiffies(max_age_msecs);
+ 		} else if (!strcasecmp(string, "cleaner")) {
+ 			wc->cleaner = true;
++>>>>>>> 3923d4854e18 (dm writecache: implement gradual cleanup)
  		} else if (!strcasecmp(string, "fua")) {
  			if (WC_MODE_PMEM(wc)) {
  				wc->writeback_fua = true;
@@@ -2296,6 -2394,10 +2349,13 @@@ static void writecache_status(struct dm
  			DMEMIT(" autocommit_blocks %u", wc->autocommit_blocks);
  		if (wc->autocommit_time_set)
  			DMEMIT(" autocommit_time %u", jiffies_to_msecs(wc->autocommit_jiffies));
++<<<<<<< HEAD
++=======
+ 		if (wc->max_age != MAX_AGE_UNSPECIFIED)
+ 			DMEMIT(" max_age %u", jiffies_to_msecs(wc->max_age));
+ 		if (wc->cleaner)
+ 			DMEMIT(" cleaner");
++>>>>>>> 3923d4854e18 (dm writecache: implement gradual cleanup)
  		if (wc->writeback_fua_set)
  			DMEMIT(" %sfua", wc->writeback_fua ? "" : "no");
  		break;
* Unmerged path drivers/md/dm-writecache.c
