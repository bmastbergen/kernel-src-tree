rtw88: use shorter delay time to poll PS state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Yan-Hsuan Chuang <yhchuang@realtek.com>
commit 6b6c150b8464e91af26be805f88d5e58c6d626ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6b6c150b.failed

When TX packet arrives, driver should leave deep PS state to make
sure the DMA is working. After requested to leave deep PS state,
driver needs to poll the PS state to check if the mode has been
changed successfully. The driver used to check the state of the
hardware every 20 msecs, which means upon the first failure of
state check, the CPU is delayed 20 msecs for next check. This is
harmful for some time-sensitive applications such as media players.

So, use shorter delay time each check from 20 msecs to 100 usecs.
The state should be changed in several tries. But we still need
to reserve ~15 msecs in total in case of the state just took too
long to be changed successfully. If the states of driver and the
hardware is not synchronized, the power state could be locked
forever, which mean we could never enter/leave the PS state.

	Signed-off-by: Yan-Hsuan Chuang <yhchuang@realtek.com>
	Reviewed-by: Chris Chiu <chiu@endlessm.com>
	Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
(cherry picked from commit 6b6c150b8464e91af26be805f88d5e58c6d626ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/realtek/rtw88/ps.c
diff --cc drivers/net/wireless/realtek/rtw88/ps.c
index d3ee9ac49ec8,7a189a9926fe..000000000000
--- a/drivers/net/wireless/realtek/rtw88/ps.c
+++ b/drivers/net/wireless/realtek/rtw88/ps.c
@@@ -71,48 -71,45 +71,56 @@@ void rtw_power_mode_change(struct rtw_d
  	u8 polling_cnt;
  	u8 retry_cnt = 0;
  
 -	for (retry_cnt = 0; retry_cnt < 3; retry_cnt++) {
 -		request = rtw_read8(rtwdev, rtwdev->hci.rpwm_addr);
 -		confirm = rtw_read8(rtwdev, rtwdev->hci.cpwm_addr);
 -
 -		/* toggle to request power mode, others remain 0 */
 -		request ^= request | BIT_RPWM_TOGGLE;
 -		if (!enter) {
 -			request |= POWER_MODE_ACK;
 -		} else {
 -			request |= POWER_MODE_LCLK;
 -			if (rtw_fw_lps_deep_mode == LPS_DEEP_MODE_PG)
 -				request |= POWER_MODE_PG;
 -		}
 +retry:
 +	request = rtw_read8(rtwdev, rtwdev->hci.rpwm_addr);
 +	confirm = rtw_read8(rtwdev, rtwdev->hci.cpwm_addr);
 +
 +	/* toggle to request power mode, others remain 0 */
 +	request ^= request | BIT_RPWM_TOGGLE;
 +	if (!enter) {
 +		request |= POWER_MODE_ACK;
 +	} else {
 +		request |= POWER_MODE_LCLK;
 +		if (rtw_fw_lps_deep_mode == LPS_DEEP_MODE_PG)
 +			request |= POWER_MODE_PG;
 +	}
  
 -		rtw_write8(rtwdev, rtwdev->hci.rpwm_addr, request);
 +	rtw_write8(rtwdev, rtwdev->hci.rpwm_addr, request);
  
++<<<<<<< HEAD
 +	/* check confirm power mode has left power save state */
 +	if (!enter) {
 +		for (polling_cnt = 0; polling_cnt < 3; polling_cnt++) {
++=======
+ 		if (enter)
+ 			return;
+ 
+ 		/* check confirm power mode has left power save state */
+ 		for (polling_cnt = 0; polling_cnt < 50; polling_cnt++) {
++>>>>>>> 6b6c150b8464 (rtw88: use shorter delay time to poll PS state)
  			polling = rtw_read8(rtwdev, rtwdev->hci.cpwm_addr);
  			if ((polling ^ confirm) & BIT_RPWM_TOGGLE)
  				return;
- 			mdelay(20);
+ 			udelay(100);
  		}
  
 -		/* in case of fw/hw missed the request, retry */
 -		rtw_warn(rtwdev, "failed to leave deep PS, retry=%d\n",
 -			 retry_cnt);
 -	}
 +		/* in case of fw/hw missed the request, retry 3 times */
 +		if (retry_cnt < 3) {
 +			rtw_warn(rtwdev, "failed to leave deep PS, retry=%d\n",
 +				 retry_cnt);
 +			retry_cnt++;
 +			goto retry;
 +		}
  
 -	/* Hit here means that driver failed to change hardware power mode to
 -	 * active state after retry 3 times. If the power state is locked at
 -	 * Deep sleep, most of the hardware circuits is not working, even
 -	 * register read/write. It should be treated as fatal error and
 -	 * requires an entire analysis about the firmware/hardware
 -	 */
 -	WARN(1, "Hardware power state locked\n");
 +		/* Hit here means that driver failed to change hardware
 +		 * power mode to active state after retry 3 times.
 +		 * If the power state is locked at Deep sleep, most of
 +		 * the hardware circuits is not working, even register
 +		 * read/write. It should be treated as fatal error and
 +		 * requires an entire analysis about the firmware/hardware
 +		 */
 +		WARN_ON("Hardware power state locked\n");
 +	}
  }
  EXPORT_SYMBOL(rtw_power_mode_change);
  
* Unmerged path drivers/net/wireless/realtek/rtw88/ps.c
