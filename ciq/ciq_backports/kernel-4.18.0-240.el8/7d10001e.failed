ptp: add VMware virtual PTP clock driver

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Vivek Thampi <vithampi@vmware.com>
commit 7d10001e20e46ad6ad95622164686bc2cbfc9802
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7d10001e.failed

Add a PTP clock driver called ptp_vmw, for guests running on VMware ESXi
hypervisor. The driver attaches to a VMware virtual device called
"precision clock" that provides a mechanism for querying host system time.
Similar to existing virtual PTP clock drivers (e.g. ptp_kvm), ptp_vmw
utilizes the kernel's PTP hardware clock API to implement a clock device
that can be used as a reference in Chrony for synchronizing guest time with
host.

The driver is only applicable to x86 guests running in VMware virtual
machines with precision clock virtual device present. It uses a VMware
specific hypercall mechanism to read time from the device.

	Reviewed-by: Thomas Hellstrom <thellstrom@vmware.com>
	Signed-off-by: Vivek Thampi <vithampi@vmware.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7d10001e20e46ad6ad95622164686bc2cbfc9802)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ptp/Kconfig
#	drivers/ptp/Makefile
diff --cc drivers/ptp/Kconfig
index 474c988d2e95,86400c708150..000000000000
--- a/drivers/ptp/Kconfig
+++ b/drivers/ptp/Kconfig
@@@ -118,4 -115,40 +118,43 @@@ config PTP_1588_CLOCK_KV
  	  To compile this driver as a module, choose M here: the module
  	  will be called ptp_kvm.
  
++<<<<<<< HEAD
++=======
+ config PTP_1588_CLOCK_IDT82P33
+ 	tristate "IDT 82P33xxx PTP clock"
+ 	depends on PTP_1588_CLOCK && I2C
+ 	default n
+ 	help
+ 	  This driver adds support for using the IDT 82P33xxx as a PTP
+ 	  clock. This clock is only useful if your time stamping MAC
+ 	  is connected to the IDT chip.
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called ptp_idt82p33.
+ 
+ config PTP_1588_CLOCK_IDTCM
+ 	tristate "IDT CLOCKMATRIX as PTP clock"
+ 	depends on PTP_1588_CLOCK && I2C
+ 	default n
+ 	help
+ 	  This driver adds support for using IDT CLOCKMATRIX(TM) as a PTP
+ 	  clock. This clock is only useful if your time stamping MAC
+ 	  is connected to the IDT chip.
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called ptp_clockmatrix.
+ 
+ config PTP_1588_CLOCK_VMW
+ 	tristate "VMware virtual PTP clock"
+ 	depends on ACPI && HYPERVISOR_GUEST && X86
+ 	depends on PTP_1588_CLOCK
+ 	help
+ 	  This driver adds support for using VMware virtual precision
+ 	  clock device as a PTP clock. This is only useful in virtual
+ 	  machines running on VMware virtual infrastructure.
+ 
+ 	  To compile this driver as a module, choose M here: the module
+ 	  will be called ptp_vmw.
+ 
++>>>>>>> 7d10001e20e4 (ptp: add VMware virtual PTP clock driver)
  endmenu
diff --cc drivers/ptp/Makefile
index 19efa9cfa950,7aff75f745dc..000000000000
--- a/drivers/ptp/Makefile
+++ b/drivers/ptp/Makefile
@@@ -6,7 -6,12 +6,16 @@@
  ptp-y					:= ptp_clock.o ptp_chardev.o ptp_sysfs.o
  obj-$(CONFIG_PTP_1588_CLOCK)		+= ptp.o
  obj-$(CONFIG_PTP_1588_CLOCK_DTE)	+= ptp_dte.o
 -obj-$(CONFIG_PTP_1588_CLOCK_INES)	+= ptp_ines.o
 +obj-$(CONFIG_PTP_1588_CLOCK_IXP46X)	+= ptp_ixp46x.o
  obj-$(CONFIG_PTP_1588_CLOCK_PCH)	+= ptp_pch.o
  obj-$(CONFIG_PTP_1588_CLOCK_KVM)	+= ptp_kvm.o
++<<<<<<< HEAD
 +obj-$(CONFIG_PTP_1588_CLOCK_QORIQ)	+= ptp_qoriq.o
++=======
+ obj-$(CONFIG_PTP_1588_CLOCK_QORIQ)	+= ptp-qoriq.o
+ ptp-qoriq-y				+= ptp_qoriq.o
+ ptp-qoriq-$(CONFIG_DEBUG_FS)		+= ptp_qoriq_debugfs.o
+ obj-$(CONFIG_PTP_1588_CLOCK_IDTCM)	+= ptp_clockmatrix.o
+ obj-$(CONFIG_PTP_1588_CLOCK_IDT82P33)	+= ptp_idt82p33.o
+ obj-$(CONFIG_PTP_1588_CLOCK_VMW)	+= ptp_vmw.o
++>>>>>>> 7d10001e20e4 (ptp: add VMware virtual PTP clock driver)
diff --git a/MAINTAINERS b/MAINTAINERS
index 097c8c7d2df1..4f477bd5303d 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -15501,6 +15501,13 @@ L:	virtualization@lists.linux-foundation.org
 S:	Supported
 F:	arch/x86/kernel/cpu/vmware.c
 
+VMWARE VIRTUAL PTP CLOCK DRIVER
+M:	Vivek Thampi <vithampi@vmware.com>
+M:	"VMware, Inc." <pv-drivers@vmware.com>
+L:	netdev@vger.kernel.org
+S:	Supported
+F:	drivers/ptp/ptp_vmw.c
+
 VMWARE PVRDMA DRIVER
 M:	Adit Ranadive <aditr@vmware.com>
 M:	VMware PV-Drivers <pv-drivers@vmware.com>
* Unmerged path drivers/ptp/Kconfig
* Unmerged path drivers/ptp/Makefile
diff --git a/drivers/ptp/ptp_vmw.c b/drivers/ptp/ptp_vmw.c
new file mode 100644
index 000000000000..5dca26e14bdc
--- /dev/null
+++ b/drivers/ptp/ptp_vmw.c
@@ -0,0 +1,144 @@
+// SPDX-License-Identifier: GPL-2.0 OR BSD-2-Clause
+/*
+ * Copyright (C) 2020 VMware, Inc., Palo Alto, CA., USA
+ *
+ * PTP clock driver for VMware precision clock virtual device.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/acpi.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/ptp_clock_kernel.h>
+#include <asm/hypervisor.h>
+#include <asm/vmware.h>
+
+#define VMWARE_MAGIC 0x564D5868
+#define VMWARE_CMD_PCLK(nr) ((nr << 16) | 97)
+#define VMWARE_CMD_PCLK_GETTIME VMWARE_CMD_PCLK(0)
+
+static struct acpi_device *ptp_vmw_acpi_device;
+static struct ptp_clock *ptp_vmw_clock;
+
+
+static int ptp_vmw_pclk_read(u64 *ns)
+{
+	u32 ret, nsec_hi, nsec_lo, unused1, unused2, unused3;
+
+	asm volatile (VMWARE_HYPERCALL :
+		"=a"(ret), "=b"(nsec_hi), "=c"(nsec_lo), "=d"(unused1),
+		"=S"(unused2), "=D"(unused3) :
+		"a"(VMWARE_MAGIC), "b"(0),
+		"c"(VMWARE_CMD_PCLK_GETTIME), "d"(0) :
+		"memory");
+
+	if (ret == 0)
+		*ns = ((u64)nsec_hi << 32) | nsec_lo;
+	return ret;
+}
+
+/*
+ * PTP clock ops.
+ */
+
+static int ptp_vmw_adjtime(struct ptp_clock_info *info, s64 delta)
+{
+	return -EOPNOTSUPP;
+}
+
+static int ptp_vmw_adjfreq(struct ptp_clock_info *info, s32 delta)
+{
+	return -EOPNOTSUPP;
+}
+
+static int ptp_vmw_gettime(struct ptp_clock_info *info, struct timespec64 *ts)
+{
+	u64 ns;
+
+	if (ptp_vmw_pclk_read(&ns) != 0)
+		return -EIO;
+	*ts = ns_to_timespec64(ns);
+	return 0;
+}
+
+static int ptp_vmw_settime(struct ptp_clock_info *info,
+			  const struct timespec64 *ts)
+{
+	return -EOPNOTSUPP;
+}
+
+static int ptp_vmw_enable(struct ptp_clock_info *info,
+			 struct ptp_clock_request *request, int on)
+{
+	return -EOPNOTSUPP;
+}
+
+static struct ptp_clock_info ptp_vmw_clock_info = {
+	.owner		= THIS_MODULE,
+	.name		= "ptp_vmw",
+	.max_adj	= 0,
+	.adjtime	= ptp_vmw_adjtime,
+	.adjfreq	= ptp_vmw_adjfreq,
+	.gettime64	= ptp_vmw_gettime,
+	.settime64	= ptp_vmw_settime,
+	.enable		= ptp_vmw_enable,
+};
+
+/*
+ * ACPI driver ops for VMware "precision clock" virtual device.
+ */
+
+static int ptp_vmw_acpi_add(struct acpi_device *device)
+{
+	ptp_vmw_clock = ptp_clock_register(&ptp_vmw_clock_info, NULL);
+	if (IS_ERR(ptp_vmw_clock)) {
+		pr_err("failed to register ptp clock\n");
+		return PTR_ERR(ptp_vmw_clock);
+	}
+
+	ptp_vmw_acpi_device = device;
+	return 0;
+}
+
+static int ptp_vmw_acpi_remove(struct acpi_device *device)
+{
+	ptp_clock_unregister(ptp_vmw_clock);
+	return 0;
+}
+
+static const struct acpi_device_id ptp_vmw_acpi_device_ids[] = {
+	{ "VMW0005", 0 },
+	{ "", 0 },
+};
+
+MODULE_DEVICE_TABLE(acpi, ptp_vmw_acpi_device_ids);
+
+static struct acpi_driver ptp_vmw_acpi_driver = {
+	.name = "ptp_vmw",
+	.ids = ptp_vmw_acpi_device_ids,
+	.ops = {
+		.add = ptp_vmw_acpi_add,
+		.remove	= ptp_vmw_acpi_remove
+	},
+	.owner	= THIS_MODULE
+};
+
+static int __init ptp_vmw_init(void)
+{
+	if (x86_hyper_type != X86_HYPER_VMWARE)
+		return -1;
+	return acpi_bus_register_driver(&ptp_vmw_acpi_driver);
+}
+
+static void __exit ptp_vmw_exit(void)
+{
+	acpi_bus_unregister_driver(&ptp_vmw_acpi_driver);
+}
+
+module_init(ptp_vmw_init);
+module_exit(ptp_vmw_exit);
+
+MODULE_DESCRIPTION("VMware virtual PTP clock driver");
+MODULE_AUTHOR("VMware, Inc.");
+MODULE_LICENSE("Dual BSD/GPL");
