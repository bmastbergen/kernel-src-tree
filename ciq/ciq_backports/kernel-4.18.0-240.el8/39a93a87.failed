KVM: ARM: Move all vcpu init code into kvm_arch_vcpu_create()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 39a93a8794719a37a37140460865c4edaff795a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/39a93a87.failed

Fold init() into create() now that the two are called back-to-back by
common KVM code (kvm_vcpu_init() calls kvm_arch_vcpu_init() as its last
action, and kvm_vm_ioctl_create_vcpu() calls kvm_arch_vcpu_create()
immediately thereafter).  This paves the way for removing
kvm_arch_vcpu_{un}init() entirely.

Note, there is no associated unwinding in kvm_arch_vcpu_uninit() that
needs to be relocated (to kvm_arch_vcpu_destroy()).

No functional change intended.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 39a93a8794719a37a37140460865c4edaff795a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	virt/kvm/arm/arm.c
diff --cc virt/kvm/arm/arm.c
index f41a18f358a9,94616725b97e..000000000000
--- a/virt/kvm/arm/arm.c
+++ b/virt/kvm/arm/arm.c
@@@ -265,42 -279,39 +265,67 @@@ void kvm_arch_free_vm(struct kvm *kvm
  		vfree(kvm);
  }
  
 -int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id)
 +struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)
  {
 -	if (irqchip_in_kernel(kvm) && vgic_initialized(kvm))
 -		return -EBUSY;
 +	int err;
 +	struct kvm_vcpu *vcpu;
  
 -	if (id >= kvm->arch.max_vcpus)
 -		return -EINVAL;
 +	if (irqchip_in_kernel(kvm) && vgic_initialized(kvm)) {
 +		err = -EBUSY;
 +		goto out;
 +	}
  
 -	return 0;
 -}
 +	if (id >= kvm->arch.max_vcpus) {
 +		err = -EINVAL;
 +		goto out;
 +	}
 +
++<<<<<<< HEAD
 +	vcpu = kmem_cache_zalloc(kvm_vcpu_cache, GFP_KERNEL);
 +	if (!vcpu) {
 +		err = -ENOMEM;
 +		goto out;
 +	}
  
 +	err = kvm_vcpu_init(vcpu, kvm, id);
 +	if (err)
 +		goto free_vcpu;
 +
 +	err = create_hyp_mappings(vcpu, vcpu + 1, PAGE_HYP);
 +	if (err)
 +		goto vcpu_uninit;
 +
 +	return vcpu;
 +vcpu_uninit:
 +	kvm_vcpu_uninit(vcpu);
 +free_vcpu:
 +	kmem_cache_free(kvm_vcpu_cache, vcpu);
 +out:
 +	return ERR_PTR(err);
++=======
+ int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)
+ {
+ 	int err;
+ 
+ 	/* Force users to call KVM_ARM_VCPU_INIT */
+ 	vcpu->arch.target = -1;
+ 	bitmap_zero(vcpu->arch.features, KVM_VCPU_MAX_FEATURES);
+ 
+ 	/* Set up the timer */
+ 	kvm_timer_vcpu_init(vcpu);
+ 
+ 	kvm_pmu_vcpu_init(vcpu);
+ 
+ 	kvm_arm_reset_debug_ptr(vcpu);
+ 
+ 	kvm_arm_pvtime_vcpu_init(&vcpu->arch);
+ 
+ 	err = kvm_vgic_vcpu_init(vcpu);
+ 	if (err)
+ 		return err;
+ 
+ 	return create_hyp_mappings(vcpu, vcpu + 1, PAGE_HYP);
++>>>>>>> 39a93a879471 (KVM: ARM: Move all vcpu init code into kvm_arch_vcpu_create())
  }
  
  void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)
@@@ -351,18 -360,7 +376,22 @@@ void kvm_arch_vcpu_unblocking(struct kv
  
  int kvm_arch_vcpu_init(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	/* Force users to call KVM_ARM_VCPU_INIT */
 +	vcpu->arch.target = -1;
 +	bitmap_zero(vcpu->arch.features, KVM_VCPU_MAX_FEATURES);
 +
 +	/* Set up the timer */
 +	kvm_timer_vcpu_init(vcpu);
 +
 +	kvm_pmu_vcpu_init(vcpu);
 +
 +	kvm_arm_reset_debug_ptr(vcpu);
 +
 +	return kvm_vgic_vcpu_init(vcpu);
++=======
+ 	return 0;
++>>>>>>> 39a93a879471 (KVM: ARM: Move all vcpu init code into kvm_arch_vcpu_create())
  }
  
  void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
* Unmerged path virt/kvm/arm/arm.c
