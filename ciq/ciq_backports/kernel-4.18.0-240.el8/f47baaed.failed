KVM: nVMX: Pull exit_reason from vcpu_vmx in nested_vmx_reflect_vmexit()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit f47baaed4fef3e31baa750cf337fe62bfcaca31f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f47baaed.failed

Grab the exit reason from the vcpu struct in nested_vmx_reflect_vmexit()
instead of having the exit reason explicitly passed from the caller.
This fixes a discrepancy between VM-Fail and VM-Exit handling, as the
VM-Fail case is already handled by checking vcpu_vmx, e.g. the exit
reason previously passed on the stack is bogus if vmx->fail is set.

Not taking the exit reason on the stack also avoids having to document
that nested_vmx_reflect_vmexit() requires the full exit reason, as
opposed to just the basic exit reason, which is not at all obvious since
the only usages of the full exit reason are for tracing and way down in
prepare_vmcs12() where it's propagated to vmcs12.

No functional change intended.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200415175519.14230-8-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit f47baaed4fef3e31baa750cf337fe62bfcaca31f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/nested.c
#	arch/x86/kvm/vmx/nested.h
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/nested.c
index 14550eccb946,67d27bc40143..000000000000
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@@ -5761,6 -5822,66 +5761,69 @@@ bool nested_vmx_exit_reflected(struct k
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Conditionally reflect a VM-Exit into L1.  Returns %true if the VM-Exit was
+  * reflected into L1.
+  */
+ bool nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu)
+ {
+ 	struct vcpu_vmx *vmx = to_vmx(vcpu);
+ 	u32 exit_reason = vmx->exit_reason;
+ 	u32 exit_intr_info, exit_qual;
+ 
+ 	WARN_ON_ONCE(vmx->nested.nested_run_pending);
+ 
+ 	/*
+ 	 * Late nested VM-Fail shares the same flow as nested VM-Exit since KVM
+ 	 * has already loaded L2's state.
+ 	 */
+ 	if (unlikely(vmx->fail)) {
+ 		trace_kvm_nested_vmenter_failed(
+ 			"hardware VM-instruction error: ",
+ 			vmcs_read32(VM_INSTRUCTION_ERROR));
+ 		exit_intr_info = 0;
+ 		exit_qual = 0;
+ 		goto reflect_vmexit;
+ 	}
+ 
+ 	exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);
+ 	exit_qual = vmcs_readl(EXIT_QUALIFICATION);
+ 
+ 	trace_kvm_nested_vmexit(kvm_rip_read(vcpu), exit_reason, exit_qual,
+ 				vmx->idt_vectoring_info, exit_intr_info,
+ 				vmcs_read32(VM_EXIT_INTR_ERROR_CODE),
+ 				KVM_ISA_VMX);
+ 
+ 	/* If L0 (KVM) wants the exit, it trumps L1's desires. */
+ 	if (nested_vmx_l0_wants_exit(vcpu, exit_reason))
+ 		return false;
+ 
+ 	/* If L1 doesn't want the exit, handle it in L0. */
+ 	if (!nested_vmx_l1_wants_exit(vcpu, exit_reason))
+ 		return false;
+ 
+ 	/*
+ 	 * vmcs.VM_EXIT_INTR_INFO is only valid for EXCEPTION_NMI exits.  For
+ 	 * EXTERNAL_INTERRUPT, the value for vmcs12->vm_exit_intr_info would
+ 	 * need to be synthesized by querying the in-kernel LAPIC, but external
+ 	 * interrupts are never reflected to L1 so it's a non-issue.
+ 	 */
+ 	if ((exit_intr_info &
+ 	     (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) ==
+ 	    (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) {
+ 		struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
+ 
+ 		vmcs12->vm_exit_intr_error_code =
+ 			vmcs_read32(VM_EXIT_INTR_ERROR_CODE);
+ 	}
+ 
+ reflect_vmexit:
+ 	nested_vmx_vmexit(vcpu, exit_reason, exit_intr_info, exit_qual);
+ 	return true;
+ }
++>>>>>>> f47baaed4fef (KVM: nVMX: Pull exit_reason from vcpu_vmx in nested_vmx_reflect_vmexit())
  
  static int vmx_get_nested_state(struct kvm_vcpu *vcpu,
  				struct kvm_nested_state __user *user_kvm_nested_state,
diff --cc arch/x86/kvm/vmx/nested.h
index 22c93a1e37fb,61cafee13ece..000000000000
--- a/arch/x86/kvm/vmx/nested.h
+++ b/arch/x86/kvm/vmx/nested.h
@@@ -25,7 -25,7 +25,11 @@@ void nested_vmx_set_vmcs_shadowing_bitm
  void nested_vmx_free_vcpu(struct kvm_vcpu *vcpu);
  enum nvmx_vmentry_status nested_vmx_enter_non_root_mode(struct kvm_vcpu *vcpu,
  						     bool from_vmentry);
++<<<<<<< HEAD
 +bool nested_vmx_exit_reflected(struct kvm_vcpu *vcpu, u32 exit_reason);
++=======
+ bool nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu);
++>>>>>>> f47baaed4fef (KVM: nVMX: Pull exit_reason from vcpu_vmx in nested_vmx_reflect_vmexit())
  void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,
  		       u32 exit_intr_info, unsigned long exit_qualification);
  void nested_sync_vmcs12_to_shadow(struct kvm_vcpu *vcpu);
diff --cc arch/x86/kvm/vmx/vmx.c
index dbadf7ce3b2f,19a82f846e8e..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -5970,8 -5891,23 +5970,28 @@@ static int vmx_handle_exit(struct kvm_v
  	if (vmx->emulation_required)
  		return handle_invalid_guest_state(vcpu);
  
++<<<<<<< HEAD
 +	if (is_guest_mode(vcpu) && nested_vmx_exit_reflected(vcpu, exit_reason))
 +		return nested_vmx_reflect_vmexit(vcpu, exit_reason);
++=======
+ 	if (is_guest_mode(vcpu)) {
+ 		/*
+ 		 * The host physical addresses of some pages of guest memory
+ 		 * are loaded into the vmcs02 (e.g. vmcs12's Virtual APIC
+ 		 * Page). The CPU may write to these pages via their host
+ 		 * physical address while L2 is running, bypassing any
+ 		 * address-translation-based dirty tracking (e.g. EPT write
+ 		 * protection).
+ 		 *
+ 		 * Mark them dirty on every exit from L2 to prevent them from
+ 		 * getting out of sync with dirty tracking.
+ 		 */
+ 		nested_mark_vmcs12_pages_dirty(vcpu);
+ 
+ 		if (nested_vmx_reflect_vmexit(vcpu))
+ 			return 1;
+ 	}
++>>>>>>> f47baaed4fef (KVM: nVMX: Pull exit_reason from vcpu_vmx in nested_vmx_reflect_vmexit())
  
  	if (exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY) {
  		dump_vmcs();
* Unmerged path arch/x86/kvm/vmx/nested.c
* Unmerged path arch/x86/kvm/vmx/nested.h
* Unmerged path arch/x86/kvm/vmx/vmx.c
