PM: QoS: Drop PM_QOS_CPU_DMA_LATENCY notifier chain

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 3a4a0042228a854d9b1073050620820b4a977e6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/3a4a0042.failed

Notice that pm_qos_remove_notifier() is not used at all and the only
caller of pm_qos_add_notifier() is the cpuidle core, which only needs
the PM_QOS_CPU_DMA_LATENCY notifier to invoke wake_up_all_idle_cpus()
upon changes of the PM_QOS_CPU_DMA_LATENCY target value.

First, to ensure that wake_up_all_idle_cpus() will be called
whenever the PM_QOS_CPU_DMA_LATENCY target value changes, modify the
pm_qos_add/update/remove_request() family of functions to check if
the effective constraint for the PM_QOS_CPU_DMA_LATENCY has changed
and call wake_up_all_idle_cpus() directly in that case.

Next, drop the PM_QOS_CPU_DMA_LATENCY notifier from cpuidle as it is
not necessary any more.

Finally, drop both pm_qos_add_notifier() and pm_qos_remove_notifier(),
as they have no callers now, along with cpu_dma_lat_notifier which is
only used by them.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Ulf Hansson <ulf.hansson@linaro.org>
	Reviewed-by: Amit Kucheria <amit.kucheria@linaro.org>
	Tested-by: Amit Kucheria <amit.kucheria@linaro.org>
(cherry picked from commit 3a4a0042228a854d9b1073050620820b4a977e6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/power/qos.c
diff --cc kernel/power/qos.c
index 61dc8358d615,201b43bc6457..000000000000
--- a/kernel/power/qos.c
+++ b/kernel/power/qos.c
@@@ -53,34 -54,15 +53,36 @@@
   * or pm_qos_object list and pm_qos_objects need to happen with pm_qos_lock
   * held, taken with _irqsave.  One lock to rule them all
   */
 +struct pm_qos_object {
 +	struct pm_qos_constraints *constraints;
 +	struct miscdevice pm_qos_power_miscdev;
 +	char *name;
 +};
 +
  static DEFINE_SPINLOCK(pm_qos_lock);
  
++<<<<<<< HEAD
 +static struct pm_qos_object null_pm_qos;
 +
 +static BLOCKING_NOTIFIER_HEAD(cpu_dma_lat_notifier);
++=======
++>>>>>>> 3a4a0042228a (PM: QoS: Drop PM_QOS_CPU_DMA_LATENCY notifier chain)
  static struct pm_qos_constraints cpu_dma_constraints = {
  	.list = PLIST_HEAD_INIT(cpu_dma_constraints.list),
  	.target_value = PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE,
  	.default_value = PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE,
  	.no_constraint_value = PM_QOS_CPU_DMA_LAT_DEFAULT_VALUE,
  	.type = PM_QOS_MIN,
- 	.notifiers = &cpu_dma_lat_notifier,
  };
 +static struct pm_qos_object cpu_dma_pm_qos = {
 +	.constraints = &cpu_dma_constraints,
 +	.name = "cpu_dma_latency",
 +};
 +
 +static struct pm_qos_object *pm_qos_array[] = {
 +	&null_pm_qos,
 +	&cpu_dma_pm_qos,
 +};
  
  /**
   * pm_qos_read_value - Return the current effective constraint value.
@@@ -263,15 -245,12 +265,24 @@@ int pm_qos_request_active(struct pm_qos
  }
  EXPORT_SYMBOL_GPL(pm_qos_request_active);
  
++<<<<<<< HEAD
 +static void __pm_qos_update_request(struct pm_qos_request *req,
 +			   s32 new_value)
 +{
 +	trace_pm_qos_update_request(req->pm_qos_class, new_value);
 +
 +	if (new_value != req->node.prio)
 +		pm_qos_update_target(
 +			pm_qos_array[req->pm_qos_class]->constraints,
 +			&req->node, PM_QOS_UPDATE_REQ, new_value);
++=======
+ static void cpu_latency_qos_update(struct pm_qos_request *req,
+ 				   enum pm_qos_req_action action, s32 value)
+ {
+ 	int ret = pm_qos_update_target(req->qos, &req->node, action, value);
+ 	if (ret > 0)
+ 		wake_up_all_idle_cpus();
++>>>>>>> 3a4a0042228a (PM: QoS: Drop PM_QOS_CPU_DMA_LATENCY notifier chain)
  }
  
  /**
@@@ -297,10 -275,11 +308,18 @@@ void pm_qos_add_request(struct pm_qos_r
  		WARN(1, KERN_ERR "pm_qos_add_request() called for already added request\n");
  		return;
  	}
++<<<<<<< HEAD
 +	req->pm_qos_class = pm_qos_class;
 +	trace_pm_qos_add_request(pm_qos_class, value);
 +	pm_qos_update_target(pm_qos_array[pm_qos_class]->constraints,
 +			     &req->node, PM_QOS_ADD_REQ, value);
++=======
+ 
+ 	trace_pm_qos_add_request(PM_QOS_CPU_DMA_LATENCY, value);
+ 
+ 	req->qos = &cpu_dma_constraints;
+ 	cpu_latency_qos_update(req, PM_QOS_ADD_REQ, value);
++>>>>>>> 3a4a0042228a (PM: QoS: Drop PM_QOS_CPU_DMA_LATENCY notifier chain)
  }
  EXPORT_SYMBOL_GPL(pm_qos_add_request);
  
@@@ -325,7 -303,12 +344,16 @@@ void pm_qos_update_request(struct pm_qo
  		return;
  	}
  
++<<<<<<< HEAD
 +	__pm_qos_update_request(req, new_value);
++=======
+ 	trace_pm_qos_update_request(PM_QOS_CPU_DMA_LATENCY, new_value);
+ 
+ 	if (new_value == req->node.prio)
+ 		return;
+ 
+ 	cpu_latency_qos_update(req, PM_QOS_UPDATE_REQ, new_value);
++>>>>>>> 3a4a0042228a (PM: QoS: Drop PM_QOS_CPU_DMA_LATENCY notifier chain)
  }
  EXPORT_SYMBOL_GPL(pm_qos_update_request);
  
@@@ -348,54 -331,13 +376,63 @@@ void pm_qos_remove_request(struct pm_qo
  		return;
  	}
  
++<<<<<<< HEAD
 +	trace_pm_qos_remove_request(req->pm_qos_class, PM_QOS_DEFAULT_VALUE);
 +	pm_qos_update_target(pm_qos_array[req->pm_qos_class]->constraints,
 +			     &req->node, PM_QOS_REMOVE_REQ,
 +			     PM_QOS_DEFAULT_VALUE);
++=======
+ 	trace_pm_qos_remove_request(PM_QOS_CPU_DMA_LATENCY, PM_QOS_DEFAULT_VALUE);
+ 
+ 	cpu_latency_qos_update(req, PM_QOS_REMOVE_REQ, PM_QOS_DEFAULT_VALUE);
++>>>>>>> 3a4a0042228a (PM: QoS: Drop PM_QOS_CPU_DMA_LATENCY notifier chain)
  	memset(req, 0, sizeof(*req));
  }
  EXPORT_SYMBOL_GPL(pm_qos_remove_request);
  
++<<<<<<< HEAD
 +/**
 + * pm_qos_add_notifier - sets notification entry for changes to target value
 + * @pm_qos_class: identifies which qos target changes should be notified.
 + * @notifier: notifier block managed by caller.
 + *
 + * will register the notifier into a notification chain that gets called
 + * upon changes to the pm_qos_class target value.
 + */
 +int pm_qos_add_notifier(int pm_qos_class, struct notifier_block *notifier)
 +{
 +	int retval;
 +
 +	retval = blocking_notifier_chain_register(
 +			pm_qos_array[pm_qos_class]->constraints->notifiers,
 +			notifier);
 +
 +	return retval;
 +}
 +EXPORT_SYMBOL_GPL(pm_qos_add_notifier);
 +
 +/**
 + * pm_qos_remove_notifier - deletes notification entry from chain.
 + * @pm_qos_class: identifies which qos target changes are notified.
 + * @notifier: notifier block to be removed.
 + *
 + * will remove the notifier from the notification chain that gets called
 + * upon changes to the pm_qos_class target value.
 + */
 +int pm_qos_remove_notifier(int pm_qos_class, struct notifier_block *notifier)
 +{
 +	int retval;
 +
 +	retval = blocking_notifier_chain_unregister(
 +			pm_qos_array[pm_qos_class]->constraints->notifiers,
 +			notifier);
 +
 +	return retval;
 +}
 +EXPORT_SYMBOL_GPL(pm_qos_remove_notifier);
 +
++=======
++>>>>>>> 3a4a0042228a (PM: QoS: Drop PM_QOS_CPU_DMA_LATENCY notifier chain)
  /* User space interface to global PM QoS via misc device. */
  
  static int pm_qos_power_open(struct inode *inode, struct file *filp)
diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c
index 08b37025da09..a702054ee7b0 100644
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@ -728,53 +728,15 @@ int cpuidle_register(struct cpuidle_driver *drv,
 }
 EXPORT_SYMBOL_GPL(cpuidle_register);
 
-#ifdef CONFIG_SMP
-
-/*
- * This function gets called when a part of the kernel has a new latency
- * requirement.  This means we need to get all processors out of their C-state,
- * and then recalculate a new suitable C-state. Just do a cross-cpu IPI; that
- * wakes them all right up.
- */
-static int cpuidle_latency_notify(struct notifier_block *b,
-		unsigned long l, void *v)
-{
-	wake_up_all_idle_cpus();
-	return NOTIFY_OK;
-}
-
-static struct notifier_block cpuidle_latency_notifier = {
-	.notifier_call = cpuidle_latency_notify,
-};
-
-static inline void latency_notifier_init(struct notifier_block *n)
-{
-	pm_qos_add_notifier(PM_QOS_CPU_DMA_LATENCY, n);
-}
-
-#else /* CONFIG_SMP */
-
-#define latency_notifier_init(x) do { } while (0)
-
-#endif /* CONFIG_SMP */
-
 /**
  * cpuidle_init - core initializer
  */
 static int __init cpuidle_init(void)
 {
-	int ret;
-
 	if (cpuidle_disabled())
 		return -ENODEV;
 
-	ret = cpuidle_add_interface(cpu_subsys.dev_root);
-	if (ret)
-		return ret;
-
-	latency_notifier_init(&cpuidle_latency_notifier);
-
-	return 0;
+	return cpuidle_add_interface(cpu_subsys.dev_root);
 }
 
 module_param(off, int, 0444);
diff --git a/include/linux/pm_qos.h b/include/linux/pm_qos.h
index 7df56233f298..388047da7b84 100644
--- a/include/linux/pm_qos.h
+++ b/include/linux/pm_qos.h
@@ -120,8 +120,6 @@ void pm_qos_update_request(struct pm_qos_request *req,
 void pm_qos_remove_request(struct pm_qos_request *req);
 
 int pm_qos_request(int pm_qos_class);
-int pm_qos_add_notifier(int pm_qos_class, struct notifier_block *notifier);
-int pm_qos_remove_notifier(int pm_qos_class, struct notifier_block *notifier);
 int pm_qos_request_active(struct pm_qos_request *req);
 s32 pm_qos_read_value(struct pm_qos_constraints *c);
 
* Unmerged path kernel/power/qos.c
