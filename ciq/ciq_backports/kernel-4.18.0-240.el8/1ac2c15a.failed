dm integrity: allow resize of the integrity device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit 1ac2c15a7bf859b92de269ba58597c94ce10811f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/1ac2c15a.failed

If the size of the underlying device changes, change the size of the
integrity device too.

	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 1ac2c15a7bf859b92de269ba58597c94ce10811f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-integrity.c
diff --cc drivers/md/dm-integrity.c
index cb7c54aa4969,fafd9ec1d56c..000000000000
--- a/drivers/md/dm-integrity.c
+++ b/drivers/md/dm-integrity.c
@@@ -2433,11 -2833,97 +2433,83 @@@ static void dm_integrity_postsuspend(st
  static void dm_integrity_resume(struct dm_target *ti)
  {
  	struct dm_integrity_c *ic = (struct dm_integrity_c *)ti->private;
++<<<<<<< HEAD
 +
 +	replay_journal(ic);
++=======
+ 	__u64 old_provided_data_sectors = le64_to_cpu(ic->sb->provided_data_sectors);
+ 	int r;
+ 
+ 	DEBUG_print("resume\n");
+ 
+ 	if (ic->provided_data_sectors != old_provided_data_sectors) {
+ 		if (ic->provided_data_sectors > old_provided_data_sectors &&
+ 		    ic->mode == 'B' &&
+ 		    ic->sb->log2_blocks_per_bitmap_bit == ic->log2_blocks_per_bitmap_bit) {
+ 			rw_journal_sectors(ic, REQ_OP_READ, 0, 0,
+ 					   ic->n_bitmap_blocks * (BITMAP_BLOCK_SIZE >> SECTOR_SHIFT), NULL);
+ 			block_bitmap_op(ic, ic->journal, old_provided_data_sectors,
+ 					ic->provided_data_sectors - old_provided_data_sectors, BITMAP_OP_SET);
+ 			rw_journal_sectors(ic, REQ_OP_WRITE, REQ_FUA | REQ_SYNC, 0,
+ 					   ic->n_bitmap_blocks * (BITMAP_BLOCK_SIZE >> SECTOR_SHIFT), NULL);
+ 		}
+ 
+ 		ic->sb->provided_data_sectors = cpu_to_le64(ic->provided_data_sectors);
+ 		r = sync_rw_sb(ic, REQ_OP_WRITE, REQ_FUA);
+ 		if (unlikely(r))
+ 			dm_integrity_io_error(ic, "writing superblock", r);
+ 	}
+ 
+ 	if (ic->sb->flags & cpu_to_le32(SB_FLAG_DIRTY_BITMAP)) {
+ 		DEBUG_print("resume dirty_bitmap\n");
+ 		rw_journal_sectors(ic, REQ_OP_READ, 0, 0,
+ 				   ic->n_bitmap_blocks * (BITMAP_BLOCK_SIZE >> SECTOR_SHIFT), NULL);
+ 		if (ic->mode == 'B') {
+ 			if (ic->sb->log2_blocks_per_bitmap_bit == ic->log2_blocks_per_bitmap_bit) {
+ 				block_bitmap_copy(ic, ic->recalc_bitmap, ic->journal);
+ 				block_bitmap_copy(ic, ic->may_write_bitmap, ic->journal);
+ 				if (!block_bitmap_op(ic, ic->journal, 0, ic->provided_data_sectors,
+ 						     BITMAP_OP_TEST_ALL_CLEAR)) {
+ 					ic->sb->flags |= cpu_to_le32(SB_FLAG_RECALCULATING);
+ 					ic->sb->recalc_sector = cpu_to_le64(0);
+ 				}
+ 			} else {
+ 				DEBUG_print("non-matching blocks_per_bitmap_bit: %u, %u\n",
+ 					    ic->sb->log2_blocks_per_bitmap_bit, ic->log2_blocks_per_bitmap_bit);
+ 				ic->sb->log2_blocks_per_bitmap_bit = ic->log2_blocks_per_bitmap_bit;
+ 				block_bitmap_op(ic, ic->recalc_bitmap, 0, ic->provided_data_sectors, BITMAP_OP_SET);
+ 				block_bitmap_op(ic, ic->may_write_bitmap, 0, ic->provided_data_sectors, BITMAP_OP_SET);
+ 				block_bitmap_op(ic, ic->journal, 0, ic->provided_data_sectors, BITMAP_OP_SET);
+ 				rw_journal_sectors(ic, REQ_OP_WRITE, REQ_FUA | REQ_SYNC, 0,
+ 						   ic->n_bitmap_blocks * (BITMAP_BLOCK_SIZE >> SECTOR_SHIFT), NULL);
+ 				ic->sb->flags |= cpu_to_le32(SB_FLAG_RECALCULATING);
+ 				ic->sb->recalc_sector = cpu_to_le64(0);
+ 			}
+ 		} else {
+ 			if (!(ic->sb->log2_blocks_per_bitmap_bit == ic->log2_blocks_per_bitmap_bit &&
+ 			      block_bitmap_op(ic, ic->journal, 0, ic->provided_data_sectors, BITMAP_OP_TEST_ALL_CLEAR))) {
+ 				ic->sb->flags |= cpu_to_le32(SB_FLAG_RECALCULATING);
+ 				ic->sb->recalc_sector = cpu_to_le64(0);
+ 			}
+ 			init_journal(ic, 0, ic->journal_sections, 0);
+ 			replay_journal(ic);
+ 			ic->sb->flags &= ~cpu_to_le32(SB_FLAG_DIRTY_BITMAP);
+ 		}
+ 		r = sync_rw_sb(ic, REQ_OP_WRITE, REQ_FUA);
+ 		if (unlikely(r))
+ 			dm_integrity_io_error(ic, "writing superblock", r);
+ 	} else {
+ 		replay_journal(ic);
+ 		if (ic->mode == 'B') {
+ 			ic->sb->flags |= cpu_to_le32(SB_FLAG_DIRTY_BITMAP);
+ 			ic->sb->log2_blocks_per_bitmap_bit = ic->log2_blocks_per_bitmap_bit;
+ 			r = sync_rw_sb(ic, REQ_OP_WRITE, REQ_FUA);
+ 			if (unlikely(r))
+ 				dm_integrity_io_error(ic, "writing superblock", r);
++>>>>>>> 1ac2c15a7bf8 (dm integrity: allow resize of the integrity device)
  
 -			block_bitmap_op(ic, ic->journal, 0, ic->provided_data_sectors, BITMAP_OP_CLEAR);
 -			block_bitmap_op(ic, ic->recalc_bitmap, 0, ic->provided_data_sectors, BITMAP_OP_CLEAR);
 -			block_bitmap_op(ic, ic->may_write_bitmap, 0, ic->provided_data_sectors, BITMAP_OP_CLEAR);
 -			if (ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING) &&
 -			    le64_to_cpu(ic->sb->recalc_sector) < ic->provided_data_sectors) {
 -				block_bitmap_op(ic, ic->journal, le64_to_cpu(ic->sb->recalc_sector),
 -						ic->provided_data_sectors - le64_to_cpu(ic->sb->recalc_sector), BITMAP_OP_SET);
 -				block_bitmap_op(ic, ic->recalc_bitmap, le64_to_cpu(ic->sb->recalc_sector),
 -						ic->provided_data_sectors - le64_to_cpu(ic->sb->recalc_sector), BITMAP_OP_SET);
 -				block_bitmap_op(ic, ic->may_write_bitmap, le64_to_cpu(ic->sb->recalc_sector),
 -						ic->provided_data_sectors - le64_to_cpu(ic->sb->recalc_sector), BITMAP_OP_SET);
 -			}
 -			rw_journal_sectors(ic, REQ_OP_WRITE, REQ_FUA | REQ_SYNC, 0,
 -					   ic->n_bitmap_blocks * (BITMAP_BLOCK_SIZE >> SECTOR_SHIFT), NULL);
 -		}
 -	}
 -
 -	DEBUG_print("testing recalc: %x\n", ic->sb->flags);
 -	if (ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING)) {
 +	if (ic->recalc_wq && ic->sb->flags & cpu_to_le32(SB_FLAG_RECALCULATING)) {
  		__u64 recalc_pos = le64_to_cpu(ic->sb->recalc_sector);
 -		DEBUG_print("recalc pos: %llx / %llx\n", recalc_pos, ic->provided_data_sectors);
  		if (recalc_pos < ic->provided_data_sectors) {
  			queue_work(ic->recalc_wq, &ic->recalc_work);
  		} else if (recalc_pos > ic->provided_data_sectors) {
@@@ -3619,7 -4239,7 +3691,11 @@@ static void dm_integrity_dtr(struct dm_
  
  static struct target_type integrity_target = {
  	.name			= "integrity",
++<<<<<<< HEAD
 +	.version		= {1, 2, 0},
++=======
+ 	.version		= {1, 6, 0},
++>>>>>>> 1ac2c15a7bf8 (dm integrity: allow resize of the integrity device)
  	.module			= THIS_MODULE,
  	.features		= DM_TARGET_SINGLETON | DM_TARGET_INTEGRITY,
  	.ctr			= dm_integrity_ctr,
* Unmerged path drivers/md/dm-integrity.c
