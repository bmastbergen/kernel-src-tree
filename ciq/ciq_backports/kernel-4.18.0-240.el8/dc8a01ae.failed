dm writecache: optimize superblock write

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit dc8a01ae1dbd7bac98368da4d8f81632512429f5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dc8a01ae.failed

If we write a superblock in writecache_flush, we don't need to set bit and
scan the bitmap for it - we can just write the superblock directly. Also,
we can set the flag REQ_FUA on the write bio, so that we don't need to
submit a flush bio afterwards.

	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit dc8a01ae1dbd7bac98368da4d8f81632512429f5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-writecache.c
diff --cc drivers/md/dm-writecache.c
index adfec9d8e315,e274e5a4d425..000000000000
--- a/drivers/md/dm-writecache.c
+++ b/drivers/md/dm-writecache.c
@@@ -493,7 -509,35 +493,39 @@@ static void ssd_commit_flushed(struct d
  	memset(wc->dirty_bitmap, 0, wc->dirty_bitmap_size);
  }
  
++<<<<<<< HEAD
 +static void writecache_commit_flushed(struct dm_writecache *wc)
++=======
+ static void ssd_commit_superblock(struct dm_writecache *wc)
+ {
+ 	int r;
+ 	struct dm_io_region region;
+ 	struct dm_io_request req;
+ 
+ 	region.bdev = wc->ssd_dev->bdev;
+ 	region.sector = 0;
+ 	region.count = PAGE_SIZE;
+ 
+ 	if (unlikely(region.sector + region.count > wc->metadata_sectors))
+ 		region.count = wc->metadata_sectors - region.sector;
+ 
+ 	region.sector += wc->start_sector;
+ 
+ 	req.bi_op = REQ_OP_WRITE;
+ 	req.bi_op_flags = REQ_SYNC | REQ_FUA;
+ 	req.mem.type = DM_IO_VMA;
+ 	req.mem.ptr.vma = (char *)wc->memory_map;
+ 	req.client = wc->dm_io;
+ 	req.notify.fn = NULL;
+ 	req.notify.context = NULL;
+ 
+ 	r = dm_io(&req, 1, &region, NULL);
+ 	if (unlikely(r))
+ 		writecache_error(wc, r, "error writing superblock");
+ }
+ 
+ static void writecache_commit_flushed(struct dm_writecache *wc, bool wait_for_ios)
++>>>>>>> dc8a01ae1dbd (dm writecache: optimize superblock write)
  {
  	if (WC_MODE_PMEM(wc))
  		wmb();
@@@ -731,8 -787,10 +763,15 @@@ static void writecache_flush(struct dm_
  
  	wc->seq_count++;
  	pmem_assign(sb(wc)->seq_count, cpu_to_le64(wc->seq_count));
++<<<<<<< HEAD
 +	writecache_flush_region(wc, &sb(wc)->seq_count, sizeof sb(wc)->seq_count);
 +	writecache_commit_flushed(wc);
++=======
+ 	if (WC_MODE_PMEM(wc))
+ 		writecache_commit_flushed(wc, false);
+ 	else
+ 		ssd_commit_superblock(wc);
++>>>>>>> dc8a01ae1dbd (dm writecache: optimize superblock write)
  
  	wc->overwrote_committed = false;
  
* Unmerged path drivers/md/dm-writecache.c
