bpf: inet_diag: Dump bpf_sk_storages in inet_diag_dump()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Martin KaFai Lau <kafai@fb.com>
commit 085c20cacf2b72991ce1c9d99a5e2f1d9e73bb68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/085c20ca.failed

This patch will dump out the bpf_sk_storages of a sk
if the request has the INET_DIAG_REQ_SK_BPF_STORAGES nlattr.

An array of SK_DIAG_BPF_STORAGE_REQ_MAP_FD can be specified in
INET_DIAG_REQ_SK_BPF_STORAGES to select which bpf_sk_storage to dump.
If no map_fd is specified, all bpf_sk_storages of a sk will be dumped.

bpf_sk_storages can be added to the system at runtime.  It is difficult
to find a proper static value for cb->min_dump_alloc.

This patch learns the nlattr size required to dump the bpf_sk_storages
of a sk.  If it happens to be the very first nlmsg of a dump and it
cannot fit the needed bpf_sk_storages,  it will try to expand the
skb by "pskb_expand_head()".

Instead of expanding it in inet_sk_diag_fill(), it is expanded at a
sleepable context in __inet_diag_dump() so __GFP_DIRECT_RECLAIM can
be used.  In __inet_diag_dump(), it will retry as long as the
skb is empty and the cb->min_dump_alloc becomes larger than before.
cb->min_dump_alloc is bounded by KMALLOC_MAX_SIZE.  The min_dump_alloc
is also changed from 'u16' to 'u32' to accommodate a sk that may have
a few large bpf_sk_storages.

The updated cb->min_dump_alloc will also be used to allocate the skb in
the next dump.  This logic already exists in netlink_dump().

Here is the sample output of a locally modified 'ss' and it could be made
more readable by using BTF later:
[root@arch-fb-vm1 ~]# ss --bpf-map-id 14 --bpf-map-id 13 -t6an 'dst [::1]:8989'
State Recv-Q Send-Q Local Address:Port  Peer Address:PortProcess
ESTAB 0      0              [::1]:51072        [::1]:8989
	 bpf_map_id:14 value:[ 3feb ]
	 bpf_map_id:13 value:[ 3f ]
ESTAB 0      0              [::1]:51070        [::1]:8989
	 bpf_map_id:14 value:[ 3feb ]
	 bpf_map_id:13 value:[ 3f ]

[root@arch-fb-vm1 ~]# ~/devshare/github/iproute2/misc/ss --bpf-maps -t6an 'dst [::1]:8989'
State         Recv-Q         Send-Q                   Local Address:Port                    Peer Address:Port         Process
ESTAB         0              0                                [::1]:51072                          [::1]:8989
	 bpf_map_id:14 value:[ 3feb ]
	 bpf_map_id:13 value:[ 3f ]
	 bpf_map_id:12 value:[ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000... total:65407 ]
ESTAB         0              0                                [::1]:51070                          [::1]:8989
	 bpf_map_id:14 value:[ 3feb ]
	 bpf_map_id:13 value:[ 3f ]
	 bpf_map_id:12 value:[ 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000... total:65407 ]

	Signed-off-by: Martin KaFai Lau <kafai@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Song Liu <songliubraving@fb.com>
Link: https://lore.kernel.org/bpf/20200225230427.1976129-1-kafai@fb.com
(cherry picked from commit 085c20cacf2b72991ce1c9d99a5e2f1d9e73bb68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netlink.h
#	net/ipv4/inet_diag.c
diff --cc include/linux/netlink.h
index 0fc3b78afa18,788969ccbbde..000000000000
--- a/include/linux/netlink.h
+++ b/include/linux/netlink.h
@@@ -187,21 -186,20 +187,30 @@@ struct netlink_callback 
  	void			*data;
  	/* the module that dump function belong to */
  	struct module		*module;
 -	struct netlink_ext_ack	*extack;
  	u16			family;
++<<<<<<< HEAD
 +	u16			min_dump_alloc;
 +	unsigned int		prev_seq, seq;
 +	RH_KABI_REPLACE(long	args[6],
 +		        union {
 +		                u8              ctx[48];
++=======
+ 	u16			answer_flags;
+ 	u32			min_dump_alloc;
+ 	unsigned int		prev_seq, seq;
+ 	bool			strict_check;
+ 	union {
+ 		u8		ctx[48];
 -
 -		/* args is deprecated. Cast a struct over ctx instead
 -		 * for proper type safety.
 -		 */
 -		long		args[6];
 -	};
++>>>>>>> 085c20cacf2b (bpf: inet_diag: Dump bpf_sk_storages in inet_diag_dump())
 +
 +				/* args is deprecated. Cast a struct over ctx instead
 +		                 * for proper type safety.
 +		                 */
 +		                long            args[6];
 +		        };)
 +	RH_KABI_EXTEND(struct netlink_ext_ack *extack)
 +	RH_KABI_EXTEND(bool strict_check)
 +	RH_KABI_EXTEND(u16 answer_flags)
  };
  
  struct netlink_notify {
diff --cc net/ipv4/inet_diag.c
index 572c31678df4,e1cad25909df..000000000000
--- a/net/ipv4/inet_diag.c
+++ b/net/ipv4/inet_diag.c
@@@ -302,6 -289,66 +307,69 @@@ int inet_sk_diag_fill(struct sock *sk, 
  			goto errout;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (ext & (1 << (INET_DIAG_CLASS_ID - 1)) ||
+ 	    ext & (1 << (INET_DIAG_TCLASS - 1))) {
+ 		u32 classid = 0;
+ 
+ #ifdef CONFIG_SOCK_CGROUP_DATA
+ 		classid = sock_cgroup_classid(&sk->sk_cgrp_data);
+ #endif
+ 		/* Fallback to socket priority if class id isn't set.
+ 		 * Classful qdiscs use it as direct reference to class.
+ 		 * For cgroup2 classid is always zero.
+ 		 */
+ 		if (!classid)
+ 			classid = sk->sk_priority;
+ 
+ 		if (nla_put_u32(skb, INET_DIAG_CLASS_ID, classid))
+ 			goto errout;
+ 	}
+ 
+ 	/* Keep it at the end for potential retry with a larger skb,
+ 	 * or else do best-effort fitting, which is only done for the
+ 	 * first_nlmsg.
+ 	 */
+ 	if (cb_data->bpf_stg_diag) {
+ 		bool first_nlmsg = ((unsigned char *)nlh == skb->data);
+ 		unsigned int prev_min_dump_alloc;
+ 		unsigned int total_nla_size = 0;
+ 		unsigned int msg_len;
+ 		int err;
+ 
+ 		msg_len = skb_tail_pointer(skb) - (unsigned char *)nlh;
+ 		err = bpf_sk_storage_diag_put(cb_data->bpf_stg_diag, sk, skb,
+ 					      INET_DIAG_SK_BPF_STORAGES,
+ 					      &total_nla_size);
+ 
+ 		if (!err)
+ 			goto out;
+ 
+ 		total_nla_size += msg_len;
+ 		prev_min_dump_alloc = cb->min_dump_alloc;
+ 		if (total_nla_size > prev_min_dump_alloc)
+ 			cb->min_dump_alloc = min_t(u32, total_nla_size,
+ 						   MAX_DUMP_ALLOC_SIZE);
+ 
+ 		if (!first_nlmsg)
+ 			goto errout;
+ 
+ 		if (cb->min_dump_alloc > prev_min_dump_alloc)
+ 			/* Retry with pskb_expand_head() with
+ 			 * __GFP_DIRECT_RECLAIM
+ 			 */
+ 			goto errout;
+ 
+ 		WARN_ON_ONCE(total_nla_size <= prev_min_dump_alloc);
+ 
+ 		/* Send what we have for this sk
+ 		 * and move on to the next sk in the following
+ 		 * dump()
+ 		 */
+ 	}
+ 
++>>>>>>> 085c20cacf2b (bpf: inet_diag: Dump bpf_sk_storages in inet_diag_dump())
  out:
  	nlmsg_end(skb, nlh);
  	return 0;
diff --git a/include/linux/inet_diag.h b/include/linux/inet_diag.h
index 22e1ccb27ca9..ce9ed1c0602f 100644
--- a/include/linux/inet_diag.h
+++ b/include/linux/inet_diag.h
@@ -33,9 +33,13 @@ struct inet_diag_handler {
 	__u16		idiag_info_size;
 };
 
+struct bpf_sk_storage_diag;
 struct inet_diag_dump_data {
 	struct nlattr *req_nlas[__INET_DIAG_REQ_MAX];
 #define inet_diag_nla_bc req_nlas[INET_DIAG_REQ_BYTECODE]
+#define inet_diag_nla_bpf_stgs req_nlas[INET_DIAG_REQ_SK_BPF_STORAGES]
+
+	struct bpf_sk_storage_diag *bpf_stg_diag;
 };
 
 struct inet_connection_sock;
* Unmerged path include/linux/netlink.h
diff --git a/include/uapi/linux/inet_diag.h b/include/uapi/linux/inet_diag.h
index 1b0031982ca1..57cc429a9177 100644
--- a/include/uapi/linux/inet_diag.h
+++ b/include/uapi/linux/inet_diag.h
@@ -64,6 +64,7 @@ struct inet_diag_req_raw {
 enum {
 	INET_DIAG_REQ_NONE,
 	INET_DIAG_REQ_BYTECODE,
+	INET_DIAG_REQ_SK_BPF_STORAGES,
 	__INET_DIAG_REQ_MAX,
 };
 
@@ -155,6 +156,7 @@ enum {
 	INET_DIAG_CLASS_ID,	/* request as INET_DIAG_TCLASS */
 	INET_DIAG_MD5SIG,
 	INET_DIAG_ULP_INFO,
+	INET_DIAG_SK_BPF_STORAGES,
 	__INET_DIAG_MAX,
 };
 
* Unmerged path net/ipv4/inet_diag.c
