timers: Move trigger_dyntick_cpu() to enqueue_timer()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Frederic Weisbecker <frederic@kernel.org>
commit 9a2b764b06c880678416d803d027f575ae40ec99
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9a2b764b.failed

Consolidate the code by calling trigger_dyntick_cpu() from
enqueue_timer() instead of calling it from all its callers.

	Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Juri Lelli <juri.lelli@redhat.com>
Link: https://lkml.kernel.org/r/20200717140551.29076-5-frederic@kernel.org

(cherry picked from commit 9a2b764b06c880678416d803d027f575ae40ec99)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/timer.c
diff --cc kernel/time/timer.c
index a7c5c50bce77,2af08a169564..000000000000
--- a/kernel/time/timer.c
+++ b/kernel/time/timer.c
@@@ -527,31 -533,9 +527,34 @@@ static int calc_wheel_index(unsigned lo
  	return idx;
  }
  
++<<<<<<< HEAD
 +/*
 + * Enqueue the timer into the hash bucket, mark it pending in
 + * the bitmap and store the index in the timer flags.
 + */
 +static void enqueue_timer(struct timer_base *base, struct timer_list *timer,
 +			  unsigned int idx)
 +{
 +	hlist_add_head(&timer->entry, base->vectors + idx);
 +	__set_bit(idx, base->pending_map);
 +	timer_set_idx(timer, idx);
 +
 +	trace_timer_start(timer, timer->expires, timer->flags);
 +}
 +
  static void
 -trigger_dyntick_cpu(struct timer_base *base, struct timer_list *timer,
 -		    unsigned long bucket_expiry)
 +__internal_add_timer(struct timer_base *base, struct timer_list *timer)
 +{
 +	unsigned int idx;
 +
 +	idx = calc_wheel_index(timer->expires, base->clk);
 +	enqueue_timer(base, timer, idx);
 +}
 +
++=======
++>>>>>>> 9a2b764b06c8 (timers: Move trigger_dyntick_cpu() to enqueue_timer())
 +static void
 +trigger_dyntick_cpu(struct timer_base *base, struct timer_list *timer)
  {
  	if (!is_timers_nohz_active())
  		return;
@@@ -582,15 -570,33 +585,38 @@@
  	 * Set the next expiry time and kick the CPU so it can reevaluate the
  	 * wheel:
  	 */
 -	base->next_expiry = bucket_expiry;
 -	wake_up_nohz_cpu(base->cpu);
 +	base->next_expiry = timer->expires;
 +		wake_up_nohz_cpu(base->cpu);
  }
  
- static void
- internal_add_timer(struct timer_base *base, struct timer_list *timer)
+ /*
+  * Enqueue the timer into the hash bucket, mark it pending in
+  * the bitmap, store the index in the timer flags then wake up
+  * the target CPU if needed.
+  */
+ static void enqueue_timer(struct timer_base *base, struct timer_list *timer,
+ 			  unsigned int idx, unsigned long bucket_expiry)
  {
+ 	hlist_add_head(&timer->entry, base->vectors + idx);
+ 	__set_bit(idx, base->pending_map);
+ 	timer_set_idx(timer, idx);
+ 
+ 	trace_timer_start(timer, timer->expires, timer->flags);
+ 	trigger_dyntick_cpu(base, timer, bucket_expiry);
+ }
+ 
+ static void internal_add_timer(struct timer_base *base, struct timer_list *timer)
+ {
++<<<<<<< HEAD
 +	__internal_add_timer(base, timer);
 +	trigger_dyntick_cpu(base, timer);
++=======
+ 	unsigned long bucket_expiry;
+ 	unsigned int idx;
+ 
+ 	idx = calc_wheel_index(timer->expires, base->clk, &bucket_expiry);
+ 	enqueue_timer(base, timer, idx, bucket_expiry);
++>>>>>>> 9a2b764b06c8 (timers: Move trigger_dyntick_cpu() to enqueue_timer())
  }
  
  #ifdef CONFIG_DEBUG_OBJECTS_TIMERS
@@@ -1039,16 -1049,13 +1065,20 @@@ __mod_timer(struct timer_list *timer, u
  	/*
  	 * If 'idx' was calculated above and the base time did not advance
  	 * between calculating 'idx' and possibly switching the base, only
- 	 * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise
- 	 * we need to (re)calculate the wheel index via
- 	 * internal_add_timer().
+ 	 * enqueue_timer() is required. Otherwise we need to (re)calculate
+ 	 * the wheel index via internal_add_timer().
  	 */
++<<<<<<< HEAD
 +	if (idx != UINT_MAX && clk == base->clk) {
 +		enqueue_timer(base, timer, idx);
 +		trigger_dyntick_cpu(base, timer);
 +	} else {
++=======
+ 	if (idx != UINT_MAX && clk == base->clk)
+ 		enqueue_timer(base, timer, idx, bucket_expiry);
+ 	else
++>>>>>>> 9a2b764b06c8 (timers: Move trigger_dyntick_cpu() to enqueue_timer())
  		internal_add_timer(base, timer);
- 	}
  
  out_unlock:
  	raw_spin_unlock_irqrestore(&base->lock, flags);
* Unmerged path kernel/time/timer.c
