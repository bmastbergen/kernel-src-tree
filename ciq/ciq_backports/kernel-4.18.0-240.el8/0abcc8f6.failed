KVM: VMX: enable X86_FEATURE_WAITPKG in KVM capabilities

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Maxim Levitsky <mlevitsk@redhat.com>
commit 0abcc8f65cc23b65bc8d1614cc64b02b1641ed7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0abcc8f6.failed

Even though we might not allow the guest to use WAITPKG's new
instructions, we should tell KVM that the feature is supported by the
host CPU.

Note that vmx_waitpkg_supported checks that WAITPKG _can_ be set in
secondary execution controls as specified by VMX capability MSR, rather
that we actually enable it for a guest.

	Cc: stable@vger.kernel.org
Fixes: e69e72faa3a0 ("KVM: x86: Add support for user wait instructions")
	Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Maxim Levitsky <mlevitsk@redhat.com>
Message-Id: <20200523161455.3940-2-mlevitsk@redhat.com>
	Reviewed-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 0abcc8f65cc23b65bc8d1614cc64b02b1641ed7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index 539026efd9e1,9b63ac8d97ee..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -7261,10 -7107,40 +7261,45 @@@ static void vmx_cpuid_update(struct kvm
  	}
  }
  
 -static __init void vmx_set_cpu_caps(void)
 +static void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
  {
++<<<<<<< HEAD
 +	if (func == 1 && nested)
 +		entry->ecx |= feature_bit(VMX);
++=======
+ 	kvm_set_cpu_caps();
+ 
+ 	/* CPUID 0x1 */
+ 	if (nested)
+ 		kvm_cpu_cap_set(X86_FEATURE_VMX);
+ 
+ 	/* CPUID 0x7 */
+ 	if (kvm_mpx_supported())
+ 		kvm_cpu_cap_check_and_set(X86_FEATURE_MPX);
+ 	if (cpu_has_vmx_invpcid())
+ 		kvm_cpu_cap_check_and_set(X86_FEATURE_INVPCID);
+ 	if (vmx_pt_mode_is_host_guest())
+ 		kvm_cpu_cap_check_and_set(X86_FEATURE_INTEL_PT);
+ 
+ 	/* PKU is not yet implemented for shadow paging. */
+ 	if (enable_ept && boot_cpu_has(X86_FEATURE_OSPKE))
+ 		kvm_cpu_cap_check_and_set(X86_FEATURE_PKU);
+ 
+ 	if (vmx_umip_emulated())
+ 		kvm_cpu_cap_set(X86_FEATURE_UMIP);
+ 
+ 	/* CPUID 0xD.1 */
+ 	supported_xss = 0;
+ 	if (!vmx_xsaves_supported())
+ 		kvm_cpu_cap_clear(X86_FEATURE_XSAVES);
+ 
+ 	/* CPUID 0x80000001 */
+ 	if (!cpu_has_vmx_rdtscp())
+ 		kvm_cpu_cap_clear(X86_FEATURE_RDTSCP);
+ 
+ 	if (vmx_waitpkg_supported())
+ 		kvm_cpu_cap_check_and_set(X86_FEATURE_WAITPKG);
++>>>>>>> 0abcc8f65cc2 (KVM: VMX: enable X86_FEATURE_WAITPKG in KVM capabilities)
  }
  
  static void vmx_request_immediate_exit(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/vmx/vmx.c
