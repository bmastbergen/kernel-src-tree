NFS: finish_automount() requires us to hold 2 refs to the mount record

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Trond Myklebust <trond.myklebust@hammerspace.com>
commit 75da98586af75eb80664714a67a9895bf0a5517e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/75da9858.failed

We must not return from nfs_d_automount() without holding 2 references
to the mount record. Doing so, will trigger the BUG() in finish_automount().
Also ensure that we don't try to reschedule the automount timer with
a negative or zero timeout value.

Fixes: 22a1ae9a93fb ("NFS: If nfs_mountpoint_expiry_timeout < 0, do not expire submounts")
	Cc: stable@vger.kernel.org # v5.5+
	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
(cherry picked from commit 75da98586af75eb80664714a67a9895bf0a5517e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/namespace.c
diff --cc fs/nfs/namespace.c
index c33aaaa708bb,fe19ae280262..000000000000
--- a/fs/nfs/namespace.c
+++ b/fs/nfs/namespace.c
@@@ -138,34 -140,66 +138,45 @@@ EXPORT_SYMBOL_GPL(nfs_path)
   */
  struct vfsmount *nfs_d_automount(struct path *path)
  {
 -	struct nfs_fs_context *ctx;
 -	struct fs_context *fc;
 -	struct vfsmount *mnt = ERR_PTR(-ENOMEM);
 +	struct vfsmount *mnt;
  	struct nfs_server *server = NFS_SERVER(d_inode(path->dentry));
++<<<<<<< HEAD
 +	struct nfs_fh *fh = NULL;
 +	struct nfs_fattr *fattr = NULL;
++=======
+ 	struct nfs_client *client = server->nfs_client;
+ 	int timeout = READ_ONCE(nfs_mountpoint_expiry_timeout);
+ 	int ret;
++>>>>>>> 75da98586af7 (NFS: finish_automount() requires us to hold 2 refs to the mount record)
  
  	if (IS_ROOT(path->dentry))
  		return ERR_PTR(-ESTALE);
  
 -	/* Open a new filesystem context, transferring parameters from the
 -	 * parent superblock, including the network namespace.
 -	 */
 -	fc = fs_context_for_submount(path->mnt->mnt_sb->s_type, path->dentry);
 -	if (IS_ERR(fc))
 -		return ERR_CAST(fc);
 +	mnt = ERR_PTR(-ENOMEM);
 +	fh = nfs_alloc_fhandle();
 +	fattr = nfs_alloc_fattr();
 +	if (fh == NULL || fattr == NULL)
 +		goto out;
  
 -	ctx = nfs_fc2context(fc);
 -	ctx->clone_data.dentry	= path->dentry;
 -	ctx->clone_data.sb	= path->dentry->d_sb;
 -	ctx->clone_data.fattr	= nfs_alloc_fattr();
 -	if (!ctx->clone_data.fattr)
 -		goto out_fc;
 -
 -	if (fc->net_ns != client->cl_net) {
 -		put_net(fc->net_ns);
 -		fc->net_ns = get_net(client->cl_net);
 -	}
 -
 -	/* for submounts we want the same server; referrals will reassign */
 -	memcpy(&ctx->nfs_server.address, &client->cl_addr, client->cl_addrlen);
 -	ctx->nfs_server.addrlen	= client->cl_addrlen;
 -	ctx->nfs_server.port	= server->port;
 -
 -	ctx->version		= client->rpc_ops->version;
 -	ctx->minorversion	= client->cl_minorversion;
 -	ctx->nfs_mod		= client->cl_nfs_mod;
 -	__module_get(ctx->nfs_mod->owner);
 -
 -	ret = client->rpc_ops->submount(fc, server);
 -	if (ret < 0) {
 -		mnt = ERR_PTR(ret);
 -		goto out_fc;
 -	}
 -
 -	up_write(&fc->root->d_sb->s_umount);
 -	mnt = vfs_create_mount(fc);
 +	mnt = server->nfs_client->rpc_ops->submount(server, path->dentry, fh, fattr);
  	if (IS_ERR(mnt))
 -		goto out_fc;
 +		goto out;
  
++<<<<<<< HEAD
 +	if (nfs_mountpoint_expiry_timeout < 0)
 +		goto out;
- 
++=======
  	mntget(mnt); /* prevent immediate expiration */
+ 	if (timeout <= 0)
+ 		goto out_fc;
++>>>>>>> 75da98586af7 (NFS: finish_automount() requires us to hold 2 refs to the mount record)
+ 
  	mnt_set_expiry(mnt, &nfs_automount_list);
- 	schedule_delayed_work(&nfs_automount_task, nfs_mountpoint_expiry_timeout);
+ 	schedule_delayed_work(&nfs_automount_task, timeout);
  
 -out_fc:
 -	put_fs_context(fc);
 +out:
 +	nfs_free_fattr(fattr);
 +	nfs_free_fhandle(fh);
  	return mnt;
  }
  
* Unmerged path fs/nfs/namespace.c
