Bluetooth: Replace zero-length array with flexible-array member

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Gustavo A. R. Silva <gustavo@embeddedor.com>
commit a7e454542bf8d57c75f59e7e7326c21db3d0bb3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a7e45454.failed

The current codebase makes use of the zero-length array language
extension to the C90 standard, but the preferred mechanism to declare
variable-length types such as these ones is a flexible array member[1][2],
introduced in C99:

struct foo {
        int stuff;
        struct boo array[];
};

By making use of the mechanism above, we will get a compiler warning
in case the flexible array does not occur last in the structure, which
will help us prevent some kind of undefined behavior bugs from being
inadvertently introduced[3] to the codebase from now on.

Also, notice that, dynamic memory allocations won't be affected by
this change:

"Flexible array members have incomplete type, and so the sizeof operator
may not be applied. As a quirk of the original implementation of
zero-length arrays, sizeof evaluates to zero."[1]

This issue was found with the help of Coccinelle.

[1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
[2] https://github.com/KSPP/linux/issues/21
[3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")

	Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit a7e454542bf8d57c75f59e7e7326c21db3d0bb3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btrtl.h
#	include/net/bluetooth/hci.h
diff --cc drivers/bluetooth/btrtl.h
index 38ffe4890cd1,2a582682136d..000000000000
--- a/drivers/bluetooth/btrtl.h
+++ b/drivers/bluetooth/btrtl.h
@@@ -38,9 -35,31 +38,24 @@@ struct rtl_epatch_header 
  	__le16 num_patches;
  } __packed;
  
++<<<<<<< HEAD
++=======
+ struct rtl_vendor_config_entry {
+ 	__le16 offset;
+ 	__u8 len;
+ 	__u8 data[];
+ } __packed;
+ 
+ struct rtl_vendor_config {
+ 	__le32 signature;
+ 	__le16 total_len;
+ 	struct rtl_vendor_config_entry entry[];
+ } __packed;
+ 
++>>>>>>> a7e454542bf8 (Bluetooth: Replace zero-length array with flexible-array member)
  #if IS_ENABLED(CONFIG_BT_RTL)
  
 -struct btrtl_device_info *btrtl_initialize(struct hci_dev *hdev,
 -					   const char *postfix);
 -void btrtl_free(struct btrtl_device_info *btrtl_dev);
 -int btrtl_download_firmware(struct hci_dev *hdev,
 -			    struct btrtl_device_info *btrtl_dev);
  int btrtl_setup_realtek(struct hci_dev *hdev);
 -int btrtl_shutdown_realtek(struct hci_dev *hdev);
 -int btrtl_get_uart_settings(struct hci_dev *hdev,
 -			    struct btrtl_device_info *btrtl_dev,
 -			    unsigned int *controller_baudrate,
 -			    u32 *device_baudrate, bool *flow_control);
  
  #else
  
diff --cc include/net/bluetooth/hci.h
index 1668211297a9,d878bf8dce20..000000000000
--- a/include/net/bluetooth/hci.h
+++ b/include/net/bluetooth/hci.h
@@@ -1506,6 -1604,214 +1506,217 @@@ struct hci_cp_le_set_default_phy 
  	__u8    rx_phys;
  } __packed;
  
++<<<<<<< HEAD
++=======
+ #define HCI_LE_SET_PHY_1M		0x01
+ #define HCI_LE_SET_PHY_2M		0x02
+ #define HCI_LE_SET_PHY_CODED		0x04
+ 
+ #define HCI_OP_LE_SET_EXT_SCAN_PARAMS   0x2041
+ struct hci_cp_le_set_ext_scan_params {
+ 	__u8    own_addr_type;
+ 	__u8    filter_policy;
+ 	__u8    scanning_phys;
+ 	__u8    data[];
+ } __packed;
+ 
+ #define LE_SCAN_PHY_1M		0x01
+ #define LE_SCAN_PHY_2M		0x02
+ #define LE_SCAN_PHY_CODED	0x04
+ 
+ struct hci_cp_le_scan_phy_params {
+ 	__u8    type;
+ 	__le16  interval;
+ 	__le16  window;
+ } __packed;
+ 
+ #define HCI_OP_LE_SET_EXT_SCAN_ENABLE   0x2042
+ struct hci_cp_le_set_ext_scan_enable {
+ 	__u8    enable;
+ 	__u8    filter_dup;
+ 	__le16  duration;
+ 	__le16  period;
+ } __packed;
+ 
+ #define HCI_OP_LE_EXT_CREATE_CONN    0x2043
+ struct hci_cp_le_ext_create_conn {
+ 	__u8      filter_policy;
+ 	__u8      own_addr_type;
+ 	__u8      peer_addr_type;
+ 	bdaddr_t  peer_addr;
+ 	__u8      phys;
+ 	__u8      data[];
+ } __packed;
+ 
+ struct hci_cp_le_ext_conn_param {
+ 	__le16 scan_interval;
+ 	__le16 scan_window;
+ 	__le16 conn_interval_min;
+ 	__le16 conn_interval_max;
+ 	__le16 conn_latency;
+ 	__le16 supervision_timeout;
+ 	__le16 min_ce_len;
+ 	__le16 max_ce_len;
+ } __packed;
+ 
+ #define HCI_OP_LE_READ_NUM_SUPPORTED_ADV_SETS	0x203b
+ struct hci_rp_le_read_num_supported_adv_sets {
+ 	__u8  status;
+ 	__u8  num_of_sets;
+ } __packed;
+ 
+ #define HCI_OP_LE_SET_EXT_ADV_PARAMS		0x2036
+ struct hci_cp_le_set_ext_adv_params {
+ 	__u8      handle;
+ 	__le16    evt_properties;
+ 	__u8      min_interval[3];
+ 	__u8      max_interval[3];
+ 	__u8      channel_map;
+ 	__u8      own_addr_type;
+ 	__u8      peer_addr_type;
+ 	bdaddr_t  peer_addr;
+ 	__u8      filter_policy;
+ 	__u8      tx_power;
+ 	__u8      primary_phy;
+ 	__u8      secondary_max_skip;
+ 	__u8      secondary_phy;
+ 	__u8      sid;
+ 	__u8      notif_enable;
+ } __packed;
+ 
+ #define HCI_ADV_PHY_1M		0X01
+ #define HCI_ADV_PHY_2M		0x02
+ #define HCI_ADV_PHY_CODED	0x03
+ 
+ struct hci_rp_le_set_ext_adv_params {
+ 	__u8  status;
+ 	__u8  tx_power;
+ } __packed;
+ 
+ #define HCI_OP_LE_SET_EXT_ADV_ENABLE		0x2039
+ struct hci_cp_le_set_ext_adv_enable {
+ 	__u8  enable;
+ 	__u8  num_of_sets;
+ 	__u8  data[];
+ } __packed;
+ 
+ struct hci_cp_ext_adv_set {
+ 	__u8  handle;
+ 	__le16 duration;
+ 	__u8  max_events;
+ } __packed;
+ 
+ #define HCI_OP_LE_SET_EXT_ADV_DATA		0x2037
+ struct hci_cp_le_set_ext_adv_data {
+ 	__u8  handle;
+ 	__u8  operation;
+ 	__u8  frag_pref;
+ 	__u8  length;
+ 	__u8  data[HCI_MAX_AD_LENGTH];
+ } __packed;
+ 
+ #define HCI_OP_LE_SET_EXT_SCAN_RSP_DATA		0x2038
+ struct hci_cp_le_set_ext_scan_rsp_data {
+ 	__u8  handle;
+ 	__u8  operation;
+ 	__u8  frag_pref;
+ 	__u8  length;
+ 	__u8  data[HCI_MAX_AD_LENGTH];
+ } __packed;
+ 
+ #define LE_SET_ADV_DATA_OP_COMPLETE	0x03
+ 
+ #define LE_SET_ADV_DATA_NO_FRAG		0x01
+ 
+ #define HCI_OP_LE_CLEAR_ADV_SETS	0x203d
+ 
+ #define HCI_OP_LE_SET_ADV_SET_RAND_ADDR	0x2035
+ struct hci_cp_le_set_adv_set_rand_addr {
+ 	__u8  handle;
+ 	bdaddr_t  bdaddr;
+ } __packed;
+ 
+ #define HCI_OP_LE_READ_BUFFER_SIZE_V2	0x2060
+ struct hci_rp_le_read_buffer_size_v2 {
+ 	__u8    status;
+ 	__le16  acl_mtu;
+ 	__u8    acl_max_pkt;
+ 	__le16  iso_mtu;
+ 	__u8    iso_max_pkt;
+ } __packed;
+ 
+ #define HCI_OP_LE_READ_ISO_TX_SYNC		0x2061
+ struct hci_cp_le_read_iso_tx_sync {
+ 	__le16  handle;
+ } __packed;
+ 
+ struct hci_rp_le_read_iso_tx_sync {
+ 	__u8    status;
+ 	__le16  handle;
+ 	__le16  seq;
+ 	__le32  imestamp;
+ 	__u8    offset[3];
+ } __packed;
+ 
+ #define HCI_OP_LE_SET_CIG_PARAMS		0x2062
+ struct hci_cis_params {
+ 	__u8    cis_id;
+ 	__le16  m_sdu;
+ 	__le16  s_sdu;
+ 	__u8    m_phy;
+ 	__u8    s_phy;
+ 	__u8    m_rtn;
+ 	__u8    s_rtn;
+ } __packed;
+ 
+ struct hci_cp_le_set_cig_params {
+ 	__u8    cig_id;
+ 	__u8    m_interval[3];
+ 	__u8    s_interval[3];
+ 	__u8    sca;
+ 	__u8    packing;
+ 	__u8    framing;
+ 	__le16  m_latency;
+ 	__le16  s_latency;
+ 	__u8    num_cis;
+ 	struct hci_cis_params cis[];
+ } __packed;
+ 
+ struct hci_rp_le_set_cig_params {
+ 	__u8    status;
+ 	__u8    cig_id;
+ 	__u8    num_handles;
+ 	__le16  handle[];
+ } __packed;
+ 
+ #define HCI_OP_LE_CREATE_CIS			0x2064
+ struct hci_cis {
+ 	__le16  cis_handle;
+ 	__le16  acl_handle;
+ } __packed;
+ 
+ struct hci_cp_le_create_cis {
+ 	__u8    num_cis;
+ 	struct hci_cis cis[];
+ } __packed;
+ 
+ #define HCI_OP_LE_REMOVE_CIG			0x2065
+ struct hci_cp_le_remove_cig {
+ 	__u8    cig_id;
+ } __packed;
+ 
+ #define HCI_OP_LE_ACCEPT_CIS			0x2066
+ struct hci_cp_le_accept_cis {
+ 	__le16  handle;
+ } __packed;
+ 
+ #define HCI_OP_LE_REJECT_CIS			0x2067
+ struct hci_cp_le_reject_cis {
+ 	__le16  handle;
+ 	__u8    reason;
+ } __packed;
+ 
++>>>>>>> a7e454542bf8 (Bluetooth: Replace zero-length array with flexible-array member)
  /* ---- HCI Events ---- */
  #define HCI_EV_INQUIRY_COMPLETE		0x01
  
@@@ -1957,6 -2280,84 +2168,87 @@@ struct hci_ev_le_direct_adv_info 
  	__s8	 rssi;
  } __packed;
  
++<<<<<<< HEAD
++=======
+ #define HCI_EV_LE_PHY_UPDATE_COMPLETE	0x0c
+ struct hci_ev_le_phy_update_complete {
+ 	__u8  status;
+ 	__le16 handle;
+ 	__u8  tx_phy;
+ 	__u8  rx_phy;
+ } __packed;
+ 
+ #define HCI_EV_LE_EXT_ADV_REPORT    0x0d
+ struct hci_ev_le_ext_adv_report {
+ 	__le16 	 evt_type;
+ 	__u8	 bdaddr_type;
+ 	bdaddr_t bdaddr;
+ 	__u8	 primary_phy;
+ 	__u8	 secondary_phy;
+ 	__u8	 sid;
+ 	__u8	 tx_power;
+ 	__s8	 rssi;
+ 	__le16 	 interval;
+ 	__u8  	 direct_addr_type;
+ 	bdaddr_t direct_addr;
+ 	__u8  	 length;
+ 	__u8	 data[];
+ } __packed;
+ 
+ #define HCI_EV_LE_ENHANCED_CONN_COMPLETE    0x0a
+ struct hci_ev_le_enh_conn_complete {
+ 	__u8      status;
+ 	__le16    handle;
+ 	__u8      role;
+ 	__u8      bdaddr_type;
+ 	bdaddr_t  bdaddr;
+ 	bdaddr_t  local_rpa;
+ 	bdaddr_t  peer_rpa;
+ 	__le16    interval;
+ 	__le16    latency;
+ 	__le16    supervision_timeout;
+ 	__u8      clk_accurancy;
+ } __packed;
+ 
+ #define HCI_EV_LE_EXT_ADV_SET_TERM	0x12
+ struct hci_evt_le_ext_adv_set_term {
+ 	__u8	status;
+ 	__u8	handle;
+ 	__le16	conn_handle;
+ 	__u8	num_evts;
+ } __packed;
+ 
+ #define HCI_EVT_LE_CIS_ESTABLISHED	0x19
+ struct hci_evt_le_cis_established {
+ 	__u8  status;
+ 	__le16 handle;
+ 	__u8  cig_sync_delay[3];
+ 	__u8  cis_sync_delay[3];
+ 	__u8  m_latency[3];
+ 	__u8  s_latency[3];
+ 	__u8  m_phy;
+ 	__u8  s_phy;
+ 	__u8  nse;
+ 	__u8  m_bn;
+ 	__u8  s_bn;
+ 	__u8  m_ft;
+ 	__u8  s_ft;
+ 	__le16 m_mtu;
+ 	__le16 s_mtu;
+ 	__le16 interval;
+ } __packed;
+ 
+ #define HCI_EVT_LE_CIS_REQ		0x1a
+ struct hci_evt_le_cis_req {
+ 	__le16 acl_handle;
+ 	__le16 cis_handle;
+ 	__u8  cig_id;
+ 	__u8  cis_id;
+ } __packed;
+ 
+ #define HCI_EV_VENDOR			0xff
+ 
++>>>>>>> a7e454542bf8 (Bluetooth: Replace zero-length array with flexible-array member)
  /* Internal events generated by Bluetooth stack */
  #define HCI_EV_STACK_INTERNAL	0xfd
  struct hci_ev_stack_internal {
@@@ -2004,6 -2406,30 +2296,33 @@@ struct hci_sco_hdr 
  	__u8	dlen;
  } __packed;
  
++<<<<<<< HEAD
++=======
+ struct hci_iso_hdr {
+ 	__le16	handle;
+ 	__le16	dlen;
+ 	__u8	data[];
+ } __packed;
+ 
+ /* ISO data packet status flags */
+ #define HCI_ISO_STATUS_VALID	0x00
+ #define HCI_ISO_STATUS_INVALID	0x01
+ #define HCI_ISO_STATUS_NOP	0x02
+ 
+ #define HCI_ISO_DATA_HDR_SIZE	4
+ struct hci_iso_data_hdr {
+ 	__le16	sn;
+ 	__le16	slen;
+ };
+ 
+ #define HCI_ISO_TS_DATA_HDR_SIZE 8
+ struct hci_iso_ts_data_hdr {
+ 	__le32	ts;
+ 	__le16	sn;
+ 	__le16	slen;
+ };
+ 
++>>>>>>> a7e454542bf8 (Bluetooth: Replace zero-length array with flexible-array member)
  static inline struct hci_event_hdr *hci_event_hdr(const struct sk_buff *skb)
  {
  	return (struct hci_event_hdr *) skb->data;
diff --git a/drivers/bluetooth/btqca.h b/drivers/bluetooth/btqca.h
index 13d77fd873b6..a9e00615aa1c 100644
--- a/drivers/bluetooth/btqca.h
+++ b/drivers/bluetooth/btqca.h
@@ -83,7 +83,7 @@ struct rome_config {
 struct edl_event_hdr {
 	__u8 cresp;
 	__u8 rtype;
-	__u8 data[0];
+	__u8 data[];
 } __packed;
 
 struct rome_version {
@@ -116,12 +116,12 @@ struct tlv_type_nvm {
 	__le16 tag_len;
 	__le32 reserve1;
 	__le32 reserve2;
-	__u8   data[0];
+	__u8   data[];
 } __packed;
 
 struct tlv_type_hdr {
 	__le32 type_len;
-	__u8   data[0];
+	__u8   data[];
 } __packed;
 
 #if IS_ENABLED(CONFIG_BT_QCA)
* Unmerged path drivers/bluetooth/btrtl.h
* Unmerged path include/net/bluetooth/hci.h
diff --git a/include/net/bluetooth/hci_sock.h b/include/net/bluetooth/hci_sock.h
index 8e9138acdae1..9352bb1bf34c 100644
--- a/include/net/bluetooth/hci_sock.h
+++ b/include/net/bluetooth/hci_sock.h
@@ -144,19 +144,19 @@ struct hci_dev_req {
 
 struct hci_dev_list_req {
 	__u16  dev_num;
-	struct hci_dev_req dev_req[0];	/* hci_dev_req structures */
+	struct hci_dev_req dev_req[];	/* hci_dev_req structures */
 };
 
 struct hci_conn_list_req {
 	__u16  dev_id;
 	__u16  conn_num;
-	struct hci_conn_info conn_info[0];
+	struct hci_conn_info conn_info[];
 };
 
 struct hci_conn_info_req {
 	bdaddr_t bdaddr;
 	__u8     type;
-	struct   hci_conn_info conn_info[0];
+	struct   hci_conn_info conn_info[];
 };
 
 struct hci_auth_info_req {
diff --git a/include/net/bluetooth/l2cap.h b/include/net/bluetooth/l2cap.h
index 0697fd413087..a11cc8f5a491 100644
--- a/include/net/bluetooth/l2cap.h
+++ b/include/net/bluetooth/l2cap.h
@@ -292,14 +292,14 @@ struct l2cap_conn_rsp {
 struct l2cap_conf_req {
 	__le16     dcid;
 	__le16     flags;
-	__u8       data[0];
+	__u8       data[];
 } __packed;
 
 struct l2cap_conf_rsp {
 	__le16     scid;
 	__le16     flags;
 	__le16     result;
-	__u8       data[0];
+	__u8       data[];
 } __packed;
 
 #define L2CAP_CONF_SUCCESS	0x0000
@@ -315,7 +315,7 @@ struct l2cap_conf_rsp {
 struct l2cap_conf_opt {
 	__u8       type;
 	__u8       len;
-	__u8       val[0];
+	__u8       val[];
 } __packed;
 #define L2CAP_CONF_OPT_SIZE	2
 
@@ -385,7 +385,7 @@ struct l2cap_info_req {
 struct l2cap_info_rsp {
 	__le16      type;
 	__le16      result;
-	__u8        data[0];
+	__u8        data[];
 } __packed;
 
 struct l2cap_create_chan_req {
diff --git a/include/net/bluetooth/rfcomm.h b/include/net/bluetooth/rfcomm.h
index 8d65d2a0b9b4..99d26879b02a 100644
--- a/include/net/bluetooth/rfcomm.h
+++ b/include/net/bluetooth/rfcomm.h
@@ -355,7 +355,7 @@ struct rfcomm_dev_info {
 
 struct rfcomm_dev_list_req {
 	u16      dev_num;
-	struct   rfcomm_dev_info dev_info[0];
+	struct   rfcomm_dev_info dev_info[];
 };
 
 int  rfcomm_dev_ioctl(struct sock *sk, unsigned int cmd, void __user *arg);
diff --git a/net/bluetooth/a2mp.h b/net/bluetooth/a2mp.h
index a4ff3ea9b38a..ad0d415a77d7 100644
--- a/net/bluetooth/a2mp.h
+++ b/net/bluetooth/a2mp.h
@@ -43,14 +43,14 @@ struct a2mp_cmd {
 	__u8	code;
 	__u8	ident;
 	__le16	len;
-	__u8	data[0];
+	__u8	data[];
 } __packed;
 
 /* A2MP command codes */
 #define A2MP_COMMAND_REJ         0x01
 struct a2mp_cmd_rej {
 	__le16	reason;
-	__u8	data[0];
+	__u8	data[];
 } __packed;
 
 #define A2MP_DISCOVER_REQ        0x02
@@ -69,7 +69,7 @@ struct a2mp_cl {
 struct a2mp_discov_rsp {
 	__le16     mtu;
 	__le16     ext_feat;
-	struct a2mp_cl cl[0];
+	struct a2mp_cl cl[];
 } __packed;
 
 #define A2MP_CHANGE_NOTIFY       0x04
@@ -100,7 +100,7 @@ struct a2mp_amp_assoc_req {
 struct a2mp_amp_assoc_rsp {
 	__u8	id;
 	__u8	status;
-	__u8	amp_assoc[0];
+	__u8	amp_assoc[];
 } __packed;
 
 #define A2MP_CREATEPHYSLINK_REQ  0x0A
@@ -108,7 +108,7 @@ struct a2mp_amp_assoc_rsp {
 struct a2mp_physlink_req {
 	__u8	local_id;
 	__u8	remote_id;
-	__u8	amp_assoc[0];
+	__u8	amp_assoc[];
 } __packed;
 
 #define A2MP_CREATEPHYSLINK_RSP  0x0B
diff --git a/net/bluetooth/bnep/bnep.h b/net/bluetooth/bnep/bnep.h
index 40854c99bc1e..b660a11fd1f5 100644
--- a/net/bluetooth/bnep/bnep.h
+++ b/net/bluetooth/bnep/bnep.h
@@ -84,14 +84,14 @@ struct bnep_setup_conn_req {
 	__u8 type;
 	__u8 ctrl;
 	__u8 uuid_size;
-	__u8 service[0];
+	__u8 service[];
 } __packed;
 
 struct bnep_set_filter_req {
 	__u8 type;
 	__u8 ctrl;
 	__be16 len;
-	__u8 list[0];
+	__u8 list[];
 } __packed;
 
 struct bnep_control_rsp {
@@ -103,7 +103,7 @@ struct bnep_control_rsp {
 struct bnep_ext_hdr {
 	__u8 type;
 	__u8 len;
-	__u8 data[0];
+	__u8 data[];
 } __packed;
 
 /* BNEP ioctl defines */
