net/smc: map and register buffers for a new link

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Karsten Graul <kgraul@linux.ibm.com>
commit fb33d27727254618aaf6bc2fedcb0fda1d5c0239
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/fb33d277.failed

Introduce support to map and register all current buffers for a new
link. smcr_buf_map_lgr() will map used buffers for a new link and
smcr_buf_reg_lgr() can be called to register used buffers on the
IB device of the new link.

	Signed-off-by: Karsten Graul <kgraul@linux.ibm.com>
	Reviewed-by: Ursula Braun <ubraun@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit fb33d27727254618aaf6bc2fedcb0fda1d5c0239)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/smc/smc_core.c
#	net/smc/smc_core.h
diff --cc net/smc/smc_core.c
index 8d7f08e469be,0e87f652caea..000000000000
--- a/net/smc/smc_core.c
+++ b/net/smc/smc_core.c
@@@ -1126,6 -1169,82 +1126,85 @@@ free_table
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ /* register a new rmb on IB device */
+ int smcr_link_reg_rmb(struct smc_link *link, struct smc_buf_desc *rmb_desc)
+ {
+ 	if (list_empty(&link->lgr->list))
+ 		return -ENOLINK;
+ 	if (!rmb_desc->is_reg_mr[link->link_idx]) {
+ 		/* register memory region for new rmb */
+ 		if (smc_wr_reg_send(link, rmb_desc->mr_rx[link->link_idx])) {
+ 			rmb_desc->is_reg_err = true;
+ 			return -EFAULT;
+ 		}
+ 		rmb_desc->is_reg_mr[link->link_idx] = true;
+ 	}
+ 	return 0;
+ }
+ 
+ static int _smcr_buf_map_lgr(struct smc_link *lnk, struct mutex *lock,
+ 			     struct list_head *lst, bool is_rmb)
+ {
+ 	struct smc_buf_desc *buf_desc, *bf;
+ 	int rc = 0;
+ 
+ 	mutex_lock(lock);
+ 	list_for_each_entry_safe(buf_desc, bf, lst, list) {
+ 		if (!buf_desc->used)
+ 			continue;
+ 		rc = smcr_buf_map_link(buf_desc, is_rmb, lnk);
+ 		if (rc)
+ 			goto out;
+ 	}
+ out:
+ 	mutex_unlock(lock);
+ 	return rc;
+ }
+ 
+ /* map all used buffers of lgr for a new link */
+ int smcr_buf_map_lgr(struct smc_link *lnk)
+ {
+ 	struct smc_link_group *lgr = lnk->lgr;
+ 	int i, rc = 0;
+ 
+ 	for (i = 0; i < SMC_RMBE_SIZES; i++) {
+ 		rc = _smcr_buf_map_lgr(lnk, &lgr->rmbs_lock,
+ 				       &lgr->rmbs[i], true);
+ 		if (rc)
+ 			return rc;
+ 		rc = _smcr_buf_map_lgr(lnk, &lgr->sndbufs_lock,
+ 				       &lgr->sndbufs[i], false);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 	return 0;
+ }
+ 
+ /* register all used buffers of lgr for a new link */
+ int smcr_buf_reg_lgr(struct smc_link *lnk)
+ {
+ 	struct smc_link_group *lgr = lnk->lgr;
+ 	struct smc_buf_desc *buf_desc, *bf;
+ 	int i, rc = 0;
+ 
+ 	mutex_lock(&lgr->rmbs_lock);
+ 	for (i = 0; i < SMC_RMBE_SIZES; i++) {
+ 		list_for_each_entry_safe(buf_desc, bf, &lgr->rmbs[i], list) {
+ 			if (!buf_desc->used)
+ 				continue;
+ 			rc = smcr_link_reg_rmb(lnk, buf_desc);
+ 			if (rc)
+ 				goto out;
+ 		}
+ 	}
+ out:
+ 	mutex_unlock(&lgr->rmbs_lock);
+ 	return rc;
+ }
+ 
++>>>>>>> fb33d2772725 (net/smc: map and register buffers for a new link)
  static struct smc_buf_desc *smcr_new_buf_create(struct smc_link_group *lgr,
  						bool is_rmb, int bufsize)
  {
diff --cc net/smc/smc_core.h
index dbb7446cbf6a,61ddb5264936..000000000000
--- a/net/smc/smc_core.h
+++ b/net/smc/smc_core.h
@@@ -335,6 -367,10 +335,13 @@@ void smc_lgr_schedule_free_work_fast(st
  int smc_core_init(void);
  void smc_core_exit(void);
  
++<<<<<<< HEAD
++=======
+ void smcr_link_clear(struct smc_link *lnk);
+ int smcr_buf_map_lgr(struct smc_link *lnk);
+ int smcr_buf_reg_lgr(struct smc_link *lnk);
+ int smcr_link_reg_rmb(struct smc_link *link, struct smc_buf_desc *rmb_desc);
++>>>>>>> fb33d2772725 (net/smc: map and register buffers for a new link)
  static inline struct smc_link_group *smc_get_lgr(struct smc_link *link)
  {
  	return link->lgr;
* Unmerged path net/smc/smc_core.c
* Unmerged path net/smc/smc_core.h
