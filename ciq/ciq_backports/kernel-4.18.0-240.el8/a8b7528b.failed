gfs2: Fix error exit in do_xmote

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Bob Peterson <rpeterso@redhat.com>
commit a8b7528b69d4dc7e94d0338851ff8c929231fc4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a8b7528b.failed

Before this patch, if an error was detected from glock function go_sync
by function do_xmote, it would return.  But the function had temporarily
unlocked the gl_lockref spin_lock, and it never re-locked it.  When the
caller of do_xmote tried to unlock it again, it was already unlocked,
which resulted in a corrupted spin_lock value.

This patch makes sure the gl_lockref spin_lock is re-locked after it is
unlocked.

Thanks to Wu Bo <wubo40@huawei.com> for reporting this problem.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit a8b7528b69d4dc7e94d0338851ff8c929231fc4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/glock.c
diff --cc fs/gfs2/glock.c
index 68e6cbbd885b,a1c5f245553f..000000000000
--- a/fs/gfs2/glock.c
+++ b/fs/gfs2/glock.c
@@@ -566,13 -602,64 +566,43 @@@ __acquires(&gl->gl_lockref.lock
  	    (lck_flags & (LM_FLAG_TRY|LM_FLAG_TRY_1CB)))
  		clear_bit(GLF_BLOCKING, &gl->gl_flags);
  	spin_unlock(&gl->gl_lockref.lock);
++<<<<<<< HEAD
 +	if (glops->go_sync)
 +		glops->go_sync(gl);
 +	if (test_bit(GLF_INVALIDATE_IN_PROGRESS, &gl->gl_flags))
++=======
+ 	if (glops->go_sync) {
+ 		ret = glops->go_sync(gl);
+ 		/* If we had a problem syncing (due to io errors or whatever,
+ 		 * we should not invalidate the metadata or tell dlm to
+ 		 * release the glock to other nodes.
+ 		 */
+ 		if (ret) {
+ 			if (cmpxchg(&sdp->sd_log_error, 0, ret)) {
+ 				fs_err(sdp, "Error %d syncing glock \n", ret);
+ 				gfs2_dump_glock(NULL, gl, true);
+ 			}
+ 			goto out;
+ 		}
+ 	}
+ 	if (test_bit(GLF_INVALIDATE_IN_PROGRESS, &gl->gl_flags)) {
+ 		/*
+ 		 * The call to go_sync should have cleared out the ail list.
+ 		 * If there are still items, we have a problem. We ought to
+ 		 * withdraw, but we can't because the withdraw code also uses
+ 		 * glocks. Warn about the error, dump the glock, then fall
+ 		 * through and wait for logd to do the withdraw for us.
+ 		 */
+ 		if ((atomic_read(&gl->gl_ail_count) != 0) &&
+ 		    (!cmpxchg(&sdp->sd_log_error, 0, -EIO))) {
+ 			gfs2_assert_warn(sdp, !atomic_read(&gl->gl_ail_count));
+ 			gfs2_dump_glock(NULL, gl, true);
+ 		}
++>>>>>>> a8b7528b69d4 (gfs2: Fix error exit in do_xmote)
  		glops->go_inval(gl, target == LM_ST_DEFERRED ? 0 : DIO_METADATA);
 -		clear_bit(GLF_INVALIDATE_IN_PROGRESS, &gl->gl_flags);
 -	}
 +	clear_bit(GLF_INVALIDATE_IN_PROGRESS, &gl->gl_flags);
  
  	gfs2_glock_hold(gl);
 -	/*
 -	 * Check for an error encountered since we called go_sync and go_inval.
 -	 * If so, we can't withdraw from the glock code because the withdraw
 -	 * code itself uses glocks (see function signal_our_withdraw) to
 -	 * change the mount to read-only. Most importantly, we must not call
 -	 * dlm to unlock the glock until the journal is in a known good state
 -	 * (after journal replay) otherwise other nodes may use the object
 -	 * (rgrp or dinode) and then later, journal replay will corrupt the
 -	 * file system. The best we can do here is wait for the logd daemon
 -	 * to see sd_log_error and withdraw, and in the meantime, requeue the
 -	 * work for later.
 -	 *
 -	 * However, if we're just unlocking the lock (say, for unmount, when
 -	 * gfs2_gl_hash_clear calls clear_glock) and recovery is complete
 -	 * then it's okay to tell dlm to unlock it.
 -	 */
 -	if (unlikely(sdp->sd_log_error && !gfs2_withdrawn(sdp)))
 -		gfs2_withdraw_delayed(sdp);
 -	if (glock_blocked_by_withdraw(gl)) {
 -		if (target != LM_ST_UNLOCKED ||
 -		    test_bit(SDF_WITHDRAW_RECOVERY, &sdp->sd_flags)) {
 -			gfs2_glock_queue_work(gl, GL_GLOCK_DFT_HOLD);
 -			goto out;
 -		}
 -	}
 -
  	if (sdp->sd_lockstruct.ls_ops->lm_lock)	{
  		/* lock_dlm */
  		ret = sdp->sd_lockstruct.ls_ops->lm_lock(gl, target, lck_flags);
* Unmerged path fs/gfs2/glock.c
