libbpf: Add support for attaching BPF programs to other BPF programs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Alexei Starovoitov <ast@kernel.org>
commit e7bf94dbb882b7d679a6a18e40e4f28076eb249f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e7bf94db.failed

Extend libbpf api to pass attach_prog_fd into bpf_object__open.

	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Song Liu <songliubraving@fb.com>
Link: https://lore.kernel.org/bpf/20191114185720.1641606-19-ast@kernel.org
(cherry picked from commit e7bf94dbb882b7d679a6a18e40e4f28076eb249f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/include/uapi/linux/bpf.h
#	tools/lib/bpf/bpf.c
#	tools/lib/bpf/bpf.h
#	tools/lib/bpf/libbpf.c
diff --cc tools/include/uapi/linux/bpf.h
index 4c50a38c7288,4842a134b202..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -417,6 -424,8 +417,11 @@@ union bpf_attr 
  		__u32		line_info_rec_size;	/* userspace bpf_line_info size */
  		__aligned_u64	line_info;	/* line info */
  		__u32		line_info_cnt;	/* number of bpf_line_info records */
++<<<<<<< HEAD
++=======
+ 		__u32		attach_btf_id;	/* in-kernel BTF type id to attach to */
+ 		__u32		attach_prog_fd; /* 0 to attach to vmlinux */
++>>>>>>> e7bf94dbb882 (libbpf: Add support for attaching BPF programs to other BPF programs)
  	};
  
  	struct { /* anonymous struct used by BPF_OBJ_* commands */
diff --cc tools/lib/bpf/bpf.c
index f9124e381f55,98596e15390f..000000000000
--- a/tools/lib/bpf/bpf.c
+++ b/tools/lib/bpf/bpf.c
@@@ -228,9 -228,13 +228,19 @@@ int bpf_load_program_xattr(const struc
  	memset(&attr, 0, sizeof(attr));
  	attr.prog_type = load_attr->prog_type;
  	attr.expected_attach_type = load_attr->expected_attach_type;
++<<<<<<< HEAD
 +	if (attr.prog_type == BPF_PROG_TYPE_RAW_TRACEPOINT)
 +		/* expected_attach_type is ignored for tracing progs */
 +		attr.attach_btf_id = attr.expected_attach_type;
++=======
+ 	if (attr.prog_type == BPF_PROG_TYPE_TRACING) {
+ 		attr.attach_btf_id = load_attr->attach_btf_id;
+ 		attr.attach_prog_fd = load_attr->attach_prog_fd;
+ 	} else {
+ 		attr.prog_ifindex = load_attr->prog_ifindex;
+ 		attr.kern_version = load_attr->kern_version;
+ 	}
++>>>>>>> e7bf94dbb882 (libbpf: Add support for attaching BPF programs to other BPF programs)
  	attr.insn_cnt = (__u32)load_attr->insns_cnt;
  	attr.insns = ptr_to_u64(load_attr->insns);
  	attr.license = ptr_to_u64(load_attr->license);
@@@ -244,8 -248,6 +254,11 @@@
  		attr.log_size = 0;
  	}
  
++<<<<<<< HEAD
 +	attr.kern_version = load_attr->kern_version;
 +	attr.prog_ifindex = load_attr->prog_ifindex;
++=======
++>>>>>>> e7bf94dbb882 (libbpf: Add support for attaching BPF programs to other BPF programs)
  	attr.prog_btf_fd = load_attr->prog_btf_fd;
  	attr.func_info_rec_size = load_attr->func_info_rec_size;
  	attr.func_info_cnt = load_attr->func_info_cnt;
diff --cc tools/lib/bpf/bpf.h
index 0db01334740f,3c791fa8e68e..000000000000
--- a/tools/lib/bpf/bpf.h
+++ b/tools/lib/bpf/bpf.h
@@@ -77,8 -77,14 +77,19 @@@ struct bpf_load_program_attr 
  	const struct bpf_insn *insns;
  	size_t insns_cnt;
  	const char *license;
++<<<<<<< HEAD
 +	__u32 kern_version;
 +	__u32 prog_ifindex;
++=======
+ 	union {
+ 		__u32 kern_version;
+ 		__u32 attach_prog_fd;
+ 	};
+ 	union {
+ 		__u32 prog_ifindex;
+ 		__u32 attach_btf_id;
+ 	};
++>>>>>>> e7bf94dbb882 (libbpf: Add support for attaching BPF programs to other BPF programs)
  	__u32 prog_btf_fd;
  	__u32 func_info_rec_size;
  	const void *func_info;
diff --cc tools/lib/bpf/libbpf.c
index 513144ecbe5c,7132c6bdec02..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -188,6 -188,8 +188,11 @@@ struct bpf_program 
  	bpf_program_clear_priv_t clear_priv;
  
  	enum bpf_attach_type expected_attach_type;
++<<<<<<< HEAD
++=======
+ 	__u32 attach_btf_id;
+ 	__u32 attach_prog_fd;
++>>>>>>> e7bf94dbb882 (libbpf: Add support for attaching BPF programs to other BPF programs)
  	void *func_info;
  	__u32 func_info_rec_size;
  	__u32 func_info_cnt;
@@@ -3886,6 -3861,9 +3896,12 @@@ bpf_object__load_progs(struct bpf_objec
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int libbpf_find_attach_btf_id(const char *name,
+ 				     enum bpf_attach_type attach_type,
+ 				     __u32 attach_prog_fd);
++>>>>>>> e7bf94dbb882 (libbpf: Add support for attaching BPF programs to other BPF programs)
  static struct bpf_object *
  __bpf_object__open(const char *path, const void *obj_buf, size_t obj_buf_sz,
  		   struct bpf_object_open_opts *opts)
@@@ -3949,6 -3929,15 +3967,18 @@@
  
  		bpf_program__set_type(prog, prog_type);
  		bpf_program__set_expected_attach_type(prog, attach_type);
++<<<<<<< HEAD
++=======
+ 		if (prog_type == BPF_PROG_TYPE_TRACING) {
+ 			err = libbpf_find_attach_btf_id(prog->section_name,
+ 							attach_type,
+ 							attach_prog_fd);
+ 			if (err <= 0)
+ 				goto out;
+ 			prog->attach_btf_id = err;
+ 			prog->attach_prog_fd = attach_prog_fd;
+ 		}
++>>>>>>> e7bf94dbb882 (libbpf: Add support for attaching BPF programs to other BPF programs)
  	}
  
  	return obj;
@@@ -5090,6 -5065,97 +5120,100 @@@ int libbpf_prog_type_by_name(const cha
  	return -ESRCH;
  }
  
++<<<<<<< HEAD
++=======
+ #define BTF_PREFIX "btf_trace_"
+ int libbpf_find_vmlinux_btf_id(const char *name,
+ 			       enum bpf_attach_type attach_type)
+ {
+ 	struct btf *btf = bpf_core_find_kernel_btf();
+ 	char raw_tp_btf[128] = BTF_PREFIX;
+ 	char *dst = raw_tp_btf + sizeof(BTF_PREFIX) - 1;
+ 	const char *btf_name;
+ 	int err = -EINVAL;
+ 	u32 kind;
+ 
+ 	if (IS_ERR(btf)) {
+ 		pr_warn("vmlinux BTF is not found\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (attach_type == BPF_TRACE_RAW_TP) {
+ 		/* prepend "btf_trace_" prefix per kernel convention */
+ 		strncat(dst, name, sizeof(raw_tp_btf) - sizeof(BTF_PREFIX));
+ 		btf_name = raw_tp_btf;
+ 		kind = BTF_KIND_TYPEDEF;
+ 	} else {
+ 		btf_name = name;
+ 		kind = BTF_KIND_FUNC;
+ 	}
+ 	err = btf__find_by_name_kind(btf, btf_name, kind);
+ 	btf__free(btf);
+ 	return err;
+ }
+ 
+ static int libbpf_find_prog_btf_id(const char *name, __u32 attach_prog_fd)
+ {
+ 	struct bpf_prog_info_linear *info_linear;
+ 	struct bpf_prog_info *info;
+ 	struct btf *btf = NULL;
+ 	int err = -EINVAL;
+ 
+ 	info_linear = bpf_program__get_prog_info_linear(attach_prog_fd, 0);
+ 	if (IS_ERR_OR_NULL(info_linear)) {
+ 		pr_warn("failed get_prog_info_linear for FD %d\n",
+ 			attach_prog_fd);
+ 		return -EINVAL;
+ 	}
+ 	info = &info_linear->info;
+ 	if (!info->btf_id) {
+ 		pr_warn("The target program doesn't have BTF\n");
+ 		goto out;
+ 	}
+ 	if (btf__get_from_id(info->btf_id, &btf)) {
+ 		pr_warn("Failed to get BTF of the program\n");
+ 		goto out;
+ 	}
+ 	err = btf__find_by_name_kind(btf, name, BTF_KIND_FUNC);
+ 	btf__free(btf);
+ 	if (err <= 0) {
+ 		pr_warn("%s is not found in prog's BTF\n", name);
+ 		goto out;
+ 	}
+ out:
+ 	free(info_linear);
+ 	return err;
+ }
+ 
+ static int libbpf_find_attach_btf_id(const char *name,
+ 				     enum bpf_attach_type attach_type,
+ 				     __u32 attach_prog_fd)
+ {
+ 	int i, err;
+ 
+ 	if (!name)
+ 		return -EINVAL;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(section_names); i++) {
+ 		if (!section_names[i].is_attach_btf)
+ 			continue;
+ 		if (strncmp(name, section_names[i].sec, section_names[i].len))
+ 			continue;
+ 		if (attach_prog_fd)
+ 			err = libbpf_find_prog_btf_id(name + section_names[i].len,
+ 						      attach_prog_fd);
+ 		else
+ 			err = libbpf_find_vmlinux_btf_id(name + section_names[i].len,
+ 							 attach_type);
+ 		if (err <= 0)
+ 			pr_warn("%s is not found in vmlinux BTF\n", name);
+ 		return err;
+ 	}
+ 	pr_warn("failed to identify btf_id based on ELF section name '%s'\n", name);
+ 	return -ESRCH;
+ }
+ 
++>>>>>>> e7bf94dbb882 (libbpf: Add support for attaching BPF programs to other BPF programs)
  int libbpf_attach_type_by_name(const char *name,
  			       enum bpf_attach_type *attach_type)
  {
* Unmerged path tools/include/uapi/linux/bpf.h
* Unmerged path tools/lib/bpf/bpf.c
* Unmerged path tools/lib/bpf/bpf.h
* Unmerged path tools/lib/bpf/libbpf.c
diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index cb530c336c94..cfe8363506c8 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -108,8 +108,9 @@ struct bpf_object_open_opts {
 	 * auto-pinned to that path on load; defaults to "/sys/fs/bpf".
 	 */
 	const char *pin_root_path;
+	__u32 attach_prog_fd;
 };
-#define bpf_object_open_opts__last_field pin_root_path
+#define bpf_object_open_opts__last_field attach_prog_fd
 
 LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
 LIBBPF_API struct bpf_object *
