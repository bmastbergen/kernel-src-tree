libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit 9c3516d1b850ea938b074df33e4c86d721c77720
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9c3516d1.failed

Moving the following functions from tools/perf:

  cpu_map__new()
  cpu_map__read()

to libperf with the following names:

  perf_cpu_map__new()
  perf_cpu_map__read()

Committer notes:

Fixed up this one:

  tools/perf/arch/arm/util/cs-etm.c

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Alexey Budankov <alexey.budankov@linux.intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20190721112506.12306-44-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 9c3516d1b850ea938b074df33e4c86d721c77720)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/arch/arm/util/cs-etm.c
#	tools/perf/builtin-ftrace.c
#	tools/perf/lib/cpumap.c
#	tools/perf/lib/include/internal/cpumap.h
#	tools/perf/lib/include/perf/cpumap.h
#	tools/perf/lib/libperf.map
#	tools/perf/tests/bitmap.c
#	tools/perf/tests/cpumap.c
#	tools/perf/tests/mem2node.c
#	tools/perf/util/cpumap.c
#	tools/perf/util/cpumap.h
#	tools/perf/util/evlist.c
#	tools/perf/util/parse-events.c
#	tools/perf/util/record.c
diff --cc tools/perf/arch/arm/util/cs-etm.c
index 4208974c24f8,c25bc1528b96..000000000000
--- a/tools/perf/arch/arm/util/cs-etm.c
+++ b/tools/perf/arch/arm/util/cs-etm.c
@@@ -152,11 -152,11 +152,16 @@@ out
  }
  
  static int cs_etm_set_option(struct auxtrace_record *itr,
 -			     struct evsel *evsel, u32 option)
 +			     struct perf_evsel *evsel, u32 option)
  {
  	int i, err = -EINVAL;
++<<<<<<< HEAD
 +	struct cpu_map *event_cpus = evsel->evlist->cpus;
 +	struct cpu_map *online_cpus = cpu_map__new(NULL);
++=======
+ 	struct perf_cpu_map *event_cpus = evsel->evlist->cpus;
+ 	struct perf_cpu_map *online_cpus = perf_cpu_map__new(NULL);
++>>>>>>> 9c3516d1b850 (libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions)
  
  	/* Set option of each CPU we have */
  	for (i = 0; i < cpu__max_cpu(); i++) {
@@@ -489,8 -489,8 +494,13 @@@ cs_etm_info_priv_size(struct auxtrace_r
  {
  	int i;
  	int etmv3 = 0, etmv4 = 0;
++<<<<<<< HEAD
 +	struct cpu_map *event_cpus = evlist->cpus;
 +	struct cpu_map *online_cpus = cpu_map__new(NULL);
++=======
+ 	struct perf_cpu_map *event_cpus = evlist->cpus;
+ 	struct perf_cpu_map *online_cpus = perf_cpu_map__new(NULL);
++>>>>>>> 9c3516d1b850 (libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions)
  
  	/* cpu map is not empty, we have specific CPUs to work with */
  	if (!cpu_map__empty(event_cpus)) {
@@@ -635,9 -635,9 +645,15 @@@ static int cs_etm_info_fill(struct auxt
  	int i;
  	u32 offset;
  	u64 nr_cpu, type;
++<<<<<<< HEAD
 +	struct cpu_map *cpu_map;
 +	struct cpu_map *event_cpus = session->evlist->cpus;
 +	struct cpu_map *online_cpus = cpu_map__new(NULL);
++=======
+ 	struct perf_cpu_map *cpu_map;
+ 	struct perf_cpu_map *event_cpus = session->evlist->cpus;
+ 	struct perf_cpu_map *online_cpus = perf_cpu_map__new(NULL);
++>>>>>>> 9c3516d1b850 (libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions)
  	struct cs_etm_recording *ptr =
  			container_of(itr, struct cs_etm_recording, itr);
  	struct perf_pmu *cs_etm_pmu = ptr->cs_etm_pmu;
diff --cc tools/perf/builtin-ftrace.c
index f0a576403ecd,77989254fdd8..000000000000
--- a/tools/perf/builtin-ftrace.c
+++ b/tools/perf/builtin-ftrace.c
@@@ -203,7 -202,7 +203,11 @@@ static int set_tracing_cpu(struct perf_
  
  static int reset_tracing_cpu(void)
  {
++<<<<<<< HEAD
 +	struct cpu_map *cpumap = cpu_map__new(NULL);
++=======
+ 	struct perf_cpu_map *cpumap = perf_cpu_map__new(NULL);
++>>>>>>> 9c3516d1b850 (libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions)
  	int ret;
  
  	ret = set_tracing_cpumask(cpumap);
diff --cc tools/perf/lib/libperf.map
index 3536242c545c,e38473a8f32f..000000000000
--- a/tools/perf/lib/libperf.map
+++ b/tools/perf/lib/libperf.map
@@@ -1,6 -1,20 +1,23 @@@
  LIBPERF_0.0.1 {
  	global:
  		libperf_set_print;
++<<<<<<< HEAD
++=======
+ 		perf_cpu_map__dummy_new;
+ 		perf_cpu_map__get;
+ 		perf_cpu_map__put;
+ 		perf_cpu_map__new;
+ 		perf_cpu_map__read;
+ 		perf_thread_map__new_dummy;
+ 		perf_thread_map__set_pid;
+ 		perf_thread_map__comm;
+ 		perf_thread_map__get;
+ 		perf_thread_map__put;
+ 		perf_evsel__init;
+ 		perf_evlist__init;
+ 		perf_evlist__add;
+ 		perf_evlist__remove;
++>>>>>>> 9c3516d1b850 (libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions)
  	local:
  		*;
  };
diff --cc tools/perf/tests/bitmap.c
index 96e7fc1ad3f9,db2aadff3708..000000000000
--- a/tools/perf/tests/bitmap.c
+++ b/tools/perf/tests/bitmap.c
@@@ -9,7 -10,7 +10,11 @@@
  
  static unsigned long *get_bitmap(const char *str, int nbits)
  {
++<<<<<<< HEAD
 +	struct cpu_map *map = cpu_map__new(str);
++=======
+ 	struct perf_cpu_map *map = perf_cpu_map__new(str);
++>>>>>>> 9c3516d1b850 (libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions)
  	unsigned long *bm = NULL;
  	int i;
  
diff --cc tools/perf/tests/cpumap.c
index e78b897677bd,b71fe09a8087..000000000000
--- a/tools/perf/tests/cpumap.c
+++ b/tools/perf/tests/cpumap.c
@@@ -75,18 -76,18 +76,18 @@@ static int process_event_cpus(struct pe
  
  int test__cpu_map_synthesize(struct test *test __maybe_unused, int subtest __maybe_unused)
  {
 -	struct perf_cpu_map *cpus;
 +	struct cpu_map *cpus;
  
  	/* This one is better stores in mask. */
- 	cpus = cpu_map__new("0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19");
+ 	cpus = perf_cpu_map__new("0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19");
  
  	TEST_ASSERT_VAL("failed to synthesize map",
  		!perf_event__synthesize_cpu_map(NULL, cpus, process_event_mask, NULL));
  
 -	perf_cpu_map__put(cpus);
 +	cpu_map__put(cpus);
  
  	/* This one is better stores in cpu values. */
- 	cpus = cpu_map__new("1,256");
+ 	cpus = perf_cpu_map__new("1,256");
  
  	TEST_ASSERT_VAL("failed to synthesize map",
  		!perf_event__synthesize_cpu_map(NULL, cpus, process_event_cpus, NULL));
@@@ -97,7 -98,7 +98,11 @@@
  
  static int cpu_map_print(const char *str)
  {
++<<<<<<< HEAD
 +	struct cpu_map *map = cpu_map__new(str);
++=======
+ 	struct perf_cpu_map *map = perf_cpu_map__new(str);
++>>>>>>> 9c3516d1b850 (libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions)
  	char buf[100];
  
  	if (!map)
diff --cc tools/perf/tests/mem2node.c
index 520cc91af256,5ec193f7968d..000000000000
--- a/tools/perf/tests/mem2node.c
+++ b/tools/perf/tests/mem2node.c
@@@ -19,7 -20,7 +20,11 @@@ static struct node 
  
  static unsigned long *get_bitmap(const char *str, int nbits)
  {
++<<<<<<< HEAD
 +	struct cpu_map *map = cpu_map__new(str);
++=======
+ 	struct perf_cpu_map *map = perf_cpu_map__new(str);
++>>>>>>> 9c3516d1b850 (libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions)
  	unsigned long *bm = NULL;
  	int i;
  
diff --cc tools/perf/util/cpumap.c
index 77925b3c8d91,71d4d7b35a57..000000000000
--- a/tools/perf/util/cpumap.c
+++ b/tools/perf/util/cpumap.c
@@@ -17,194 -17,9 +17,198 @@@ static int max_present_cpu_num
  static int max_node_num;
  static int *cpunode_map;
  
++<<<<<<< HEAD
 +static struct cpu_map *cpu_map__default_new(void)
 +{
 +	struct cpu_map *cpus;
 +	int nr_cpus;
 +
 +	nr_cpus = sysconf(_SC_NPROCESSORS_ONLN);
 +	if (nr_cpus < 0)
 +		return NULL;
 +
 +	cpus = malloc(sizeof(*cpus) + nr_cpus * sizeof(int));
 +	if (cpus != NULL) {
 +		int i;
 +		for (i = 0; i < nr_cpus; ++i)
 +			cpus->map[i] = i;
 +
 +		cpus->nr = nr_cpus;
 +		refcount_set(&cpus->refcnt, 1);
 +	}
 +
 +	return cpus;
 +}
 +
 +static struct cpu_map *cpu_map__trim_new(int nr_cpus, int *tmp_cpus)
 +{
 +	size_t payload_size = nr_cpus * sizeof(int);
 +	struct cpu_map *cpus = malloc(sizeof(*cpus) + payload_size);
 +
 +	if (cpus != NULL) {
 +		cpus->nr = nr_cpus;
 +		memcpy(cpus->map, tmp_cpus, payload_size);
 +		refcount_set(&cpus->refcnt, 1);
 +	}
 +
 +	return cpus;
 +}
 +
 +struct cpu_map *cpu_map__read(FILE *file)
 +{
 +	struct cpu_map *cpus = NULL;
 +	int nr_cpus = 0;
 +	int *tmp_cpus = NULL, *tmp;
 +	int max_entries = 0;
 +	int n, cpu, prev;
 +	char sep;
 +
 +	sep = 0;
 +	prev = -1;
 +	for (;;) {
 +		n = fscanf(file, "%u%c", &cpu, &sep);
 +		if (n <= 0)
 +			break;
 +		if (prev >= 0) {
 +			int new_max = nr_cpus + cpu - prev - 1;
 +
 +			WARN_ONCE(new_max >= MAX_NR_CPUS, "Perf can support %d CPUs. "
 +							  "Consider raising MAX_NR_CPUS\n", MAX_NR_CPUS);
 +
 +			if (new_max >= max_entries) {
 +				max_entries = new_max + MAX_NR_CPUS / 2;
 +				tmp = realloc(tmp_cpus, max_entries * sizeof(int));
 +				if (tmp == NULL)
 +					goto out_free_tmp;
 +				tmp_cpus = tmp;
 +			}
 +
 +			while (++prev < cpu)
 +				tmp_cpus[nr_cpus++] = prev;
 +		}
 +		if (nr_cpus == max_entries) {
 +			max_entries += MAX_NR_CPUS;
 +			tmp = realloc(tmp_cpus, max_entries * sizeof(int));
 +			if (tmp == NULL)
 +				goto out_free_tmp;
 +			tmp_cpus = tmp;
 +		}
 +
 +		tmp_cpus[nr_cpus++] = cpu;
 +		if (n == 2 && sep == '-')
 +			prev = cpu;
 +		else
 +			prev = -1;
 +		if (n == 1 || sep == '\n')
 +			break;
 +	}
 +
 +	if (nr_cpus > 0)
 +		cpus = cpu_map__trim_new(nr_cpus, tmp_cpus);
 +	else
 +		cpus = cpu_map__default_new();
 +out_free_tmp:
 +	free(tmp_cpus);
 +	return cpus;
 +}
 +
 +static struct cpu_map *cpu_map__read_all_cpu_map(void)
 +{
 +	struct cpu_map *cpus = NULL;
 +	FILE *onlnf;
 +
 +	onlnf = fopen("/sys/devices/system/cpu/online", "r");
 +	if (!onlnf)
 +		return cpu_map__default_new();
 +
 +	cpus = cpu_map__read(onlnf);
 +	fclose(onlnf);
 +	return cpus;
 +}
 +
 +struct cpu_map *cpu_map__new(const char *cpu_list)
 +{
 +	struct cpu_map *cpus = NULL;
 +	unsigned long start_cpu, end_cpu = 0;
 +	char *p = NULL;
 +	int i, nr_cpus = 0;
 +	int *tmp_cpus = NULL, *tmp;
 +	int max_entries = 0;
 +
 +	if (!cpu_list)
 +		return cpu_map__read_all_cpu_map();
 +
 +	/*
 +	 * must handle the case of empty cpumap to cover
 +	 * TOPOLOGY header for NUMA nodes with no CPU
 +	 * ( e.g., because of CPU hotplug)
 +	 */
 +	if (!isdigit(*cpu_list) && *cpu_list != '\0')
 +		goto out;
 +
 +	while (isdigit(*cpu_list)) {
 +		p = NULL;
 +		start_cpu = strtoul(cpu_list, &p, 0);
 +		if (start_cpu >= INT_MAX
 +		    || (*p != '\0' && *p != ',' && *p != '-'))
 +			goto invalid;
 +
 +		if (*p == '-') {
 +			cpu_list = ++p;
 +			p = NULL;
 +			end_cpu = strtoul(cpu_list, &p, 0);
 +
 +			if (end_cpu >= INT_MAX || (*p != '\0' && *p != ','))
 +				goto invalid;
 +
 +			if (end_cpu < start_cpu)
 +				goto invalid;
 +		} else {
 +			end_cpu = start_cpu;
 +		}
 +
 +		WARN_ONCE(end_cpu >= MAX_NR_CPUS, "Perf can support %d CPUs. "
 +						  "Consider raising MAX_NR_CPUS\n", MAX_NR_CPUS);
 +
 +		for (; start_cpu <= end_cpu; start_cpu++) {
 +			/* check for duplicates */
 +			for (i = 0; i < nr_cpus; i++)
 +				if (tmp_cpus[i] == (int)start_cpu)
 +					goto invalid;
 +
 +			if (nr_cpus == max_entries) {
 +				max_entries += MAX_NR_CPUS;
 +				tmp = realloc(tmp_cpus, max_entries * sizeof(int));
 +				if (tmp == NULL)
 +					goto invalid;
 +				tmp_cpus = tmp;
 +			}
 +			tmp_cpus[nr_cpus++] = (int)start_cpu;
 +		}
 +		if (*p)
 +			++p;
 +
 +		cpu_list = p;
 +	}
 +
 +	if (nr_cpus > 0)
 +		cpus = cpu_map__trim_new(nr_cpus, tmp_cpus);
 +	else if (*cpu_list != '\0')
 +		cpus = cpu_map__default_new();
 +	else
 +		cpus = cpu_map__dummy_new();
 +invalid:
 +	free(tmp_cpus);
 +out:
 +	return cpus;
 +}
 +
 +static struct cpu_map *cpu_map__from_entries(struct cpu_map_entries *cpus)
++=======
+ static struct perf_cpu_map *cpu_map__from_entries(struct cpu_map_entries *cpus)
++>>>>>>> 9c3516d1b850 (libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions)
  {
 -	struct perf_cpu_map *map;
 +	struct cpu_map *map;
  
  	map = cpu_map__empty_new(cpus->nr);
  	if (map) {
@@@ -790,12 -567,12 +794,12 @@@ size_t cpu_map__snprint_mask(struct cpu
  	return ptr - buf;
  }
  
 -const struct perf_cpu_map *cpu_map__online(void) /* thread unsafe */
 +const struct cpu_map *cpu_map__online(void) /* thread unsafe */
  {
 -	static const struct perf_cpu_map *online = NULL;
 +	static const struct cpu_map *online = NULL;
  
  	if (!online)
- 		online = cpu_map__new(NULL); /* from /sys/devices/system/cpu/online */
+ 		online = perf_cpu_map__new(NULL); /* from /sys/devices/system/cpu/online */
  
  	return online;
  }
diff --cc tools/perf/util/cpumap.h
index 1265f0e33920,a3d27f4131be..000000000000
--- a/tools/perf/util/cpumap.h
+++ b/tools/perf/util/cpumap.h
@@@ -9,35 -11,23 +9,53 @@@
  #include "perf.h"
  #include "util/debug.h"
  
++<<<<<<< HEAD
 +struct cpu_map {
 +	refcount_t refcnt;
 +	int nr;
 +	int map[];
 +};
++=======
+ struct perf_cpu_map *cpu_map__empty_new(int nr);
+ struct perf_cpu_map *cpu_map__new_data(struct cpu_map_data *data);
+ size_t cpu_map__snprint(struct perf_cpu_map *map, char *buf, size_t size);
+ size_t cpu_map__snprint_mask(struct perf_cpu_map *map, char *buf, size_t size);
+ size_t cpu_map__fprintf(struct perf_cpu_map *map, FILE *fp);
+ int cpu_map__get_socket_id(int cpu);
+ int cpu_map__get_socket(struct perf_cpu_map *map, int idx, void *data);
+ int cpu_map__get_die_id(int cpu);
+ int cpu_map__get_die(struct perf_cpu_map *map, int idx, void *data);
+ int cpu_map__get_core_id(int cpu);
+ int cpu_map__get_core(struct perf_cpu_map *map, int idx, void *data);
+ int cpu_map__build_socket_map(struct perf_cpu_map *cpus, struct perf_cpu_map **sockp);
+ int cpu_map__build_die_map(struct perf_cpu_map *cpus, struct perf_cpu_map **diep);
+ int cpu_map__build_core_map(struct perf_cpu_map *cpus, struct perf_cpu_map **corep);
+ const struct perf_cpu_map *cpu_map__online(void); /* thread unsafe */
++>>>>>>> 9c3516d1b850 (libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions)
  
 -static inline int cpu_map__socket(struct perf_cpu_map *sock, int s)
 +struct cpu_map *cpu_map__new(const char *cpu_list);
 +struct cpu_map *cpu_map__empty_new(int nr);
 +struct cpu_map *cpu_map__dummy_new(void);
 +struct cpu_map *cpu_map__new_data(struct cpu_map_data *data);
 +struct cpu_map *cpu_map__read(FILE *file);
 +size_t cpu_map__snprint(struct cpu_map *map, char *buf, size_t size);
 +size_t cpu_map__snprint_mask(struct cpu_map *map, char *buf, size_t size);
 +size_t cpu_map__fprintf(struct cpu_map *map, FILE *fp);
 +int cpu_map__get_socket_id(int cpu);
 +int cpu_map__get_socket(struct cpu_map *map, int idx, void *data);
 +int cpu_map__get_die_id(int cpu);
 +int cpu_map__get_die(struct cpu_map *map, int idx, void *data);
 +int cpu_map__get_core_id(int cpu);
 +int cpu_map__get_core(struct cpu_map *map, int idx, void *data);
 +int cpu_map__build_socket_map(struct cpu_map *cpus, struct cpu_map **sockp);
 +int cpu_map__build_die_map(struct cpu_map *cpus, struct cpu_map **diep);
 +int cpu_map__build_core_map(struct cpu_map *cpus, struct cpu_map **corep);
 +const struct cpu_map *cpu_map__online(void); /* thread unsafe */
 +
 +struct cpu_map *cpu_map__get(struct cpu_map *map);
 +void cpu_map__put(struct cpu_map *map);
 +
 +static inline int cpu_map__socket(struct cpu_map *sock, int s)
  {
  	if (!sock || s > sock->nr || s < 0)
  		return 0;
diff --cc tools/perf/util/evlist.c
index 4739b7914374,67c67e9a38cd..000000000000
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@@ -34,6 -33,8 +34,11 @@@
  #include <linux/log2.h>
  #include <linux/err.h>
  #include <linux/zalloc.h>
++<<<<<<< HEAD
++=======
+ #include <perf/evlist.h>
+ #include <perf/cpumap.h>
++>>>>>>> 9c3516d1b850 (libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions)
  
  #ifdef LACKS_SIGQUEUE_PROTOTYPE
  int sigqueue(pid_t pid, int sig, const union sigval value);
@@@ -1087,9 -1088,9 +1092,9 @@@ int perf_evlist__create_maps(struct per
  		return -1;
  
  	if (target__uses_dummy_map(target))
 -		cpus = perf_cpu_map__dummy_new();
 +		cpus = cpu_map__dummy_new();
  	else
- 		cpus = cpu_map__new(target->cpu_list);
+ 		cpus = perf_cpu_map__new(target->cpu_list);
  
  	if (!cpus)
  		goto out_delete_threads;
diff --cc tools/perf/util/parse-events.c
index 0540303e5e97,db2460d6b625..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -321,9 -322,9 +322,15 @@@ __add_event(struct list_head *list, in
  	    struct list_head *config_terms, bool auto_merge_stats,
  	    const char *cpu_list)
  {
++<<<<<<< HEAD
 +	struct perf_evsel *evsel;
 +	struct cpu_map *cpus = pmu ? pmu->cpus :
 +			       cpu_list ? cpu_map__new(cpu_list) : NULL;
++=======
+ 	struct evsel *evsel;
+ 	struct perf_cpu_map *cpus = pmu ? pmu->cpus :
+ 			       cpu_list ? perf_cpu_map__new(cpu_list) : NULL;
++>>>>>>> 9c3516d1b850 (libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions)
  
  	event_attr_init(attr);
  
diff --cc tools/perf/util/record.c
index 9cfc7bf16531,03dcdb3f33a7..000000000000
--- a/tools/perf/util/record.c
+++ b/tools/perf/util/record.c
@@@ -60,10 -61,10 +61,10 @@@ out_delete
  static bool perf_probe_api(setup_probe_fn_t fn)
  {
  	const char *try[] = {"cycles:u", "instructions:u", "cpu-clock:u", NULL};
 -	struct perf_cpu_map *cpus;
 +	struct cpu_map *cpus;
  	int cpu, ret, i = 0;
  
- 	cpus = cpu_map__new(NULL);
+ 	cpus = perf_cpu_map__new(NULL);
  	if (!cpus)
  		return false;
  	cpu = cpus->map[0];
@@@ -115,10 -116,10 +116,10 @@@ bool perf_can_record_cpu_wide(void
  		.config = PERF_COUNT_SW_CPU_CLOCK,
  		.exclude_kernel = 1,
  	};
 -	struct perf_cpu_map *cpus;
 +	struct cpu_map *cpus;
  	int cpu, fd;
  
- 	cpus = cpu_map__new(NULL);
+ 	cpus = perf_cpu_map__new(NULL);
  	if (!cpus)
  		return false;
  	cpu = cpus->map[0];
@@@ -275,10 -276,10 +276,14 @@@ bool perf_evlist__can_select_event(stru
  	evsel = perf_evlist__last(temp_evlist);
  
  	if (!evlist || cpu_map__empty(evlist->cpus)) {
++<<<<<<< HEAD
 +		struct cpu_map *cpus = cpu_map__new(NULL);
++=======
+ 		struct perf_cpu_map *cpus = perf_cpu_map__new(NULL);
++>>>>>>> 9c3516d1b850 (libperf: Add perf_cpu_map__new()/perf_cpu_map__read() functions)
  
  		cpu =  cpus ? cpus->map[0] : 0;
 -		perf_cpu_map__put(cpus);
 +		cpu_map__put(cpus);
  	} else {
  		cpu = evlist->cpus->map[0];
  	}
* Unmerged path tools/perf/lib/cpumap.c
* Unmerged path tools/perf/lib/include/internal/cpumap.h
* Unmerged path tools/perf/lib/include/perf/cpumap.h
* Unmerged path tools/perf/arch/arm/util/cs-etm.c
diff --git a/tools/perf/arch/x86/tests/perf-time-to-tsc.c b/tools/perf/arch/x86/tests/perf-time-to-tsc.c
index 7a7721604b86..2a8fdaaa3dfd 100644
--- a/tools/perf/arch/x86/tests/perf-time-to-tsc.c
+++ b/tools/perf/arch/x86/tests/perf-time-to-tsc.c
@@ -5,6 +5,7 @@
 #include <unistd.h>
 #include <linux/types.h>
 #include <sys/prctl.h>
+#include <perf/cpumap.h>
 
 #include "parse-events.h"
 #include "evlist.h"
@@ -65,7 +66,7 @@ int test__perf_time_to_tsc(struct test *test __maybe_unused, int subtest __maybe
 	threads = thread_map__new(-1, getpid(), UINT_MAX);
 	CHECK_NOT_NULL__(threads);
 
-	cpus = cpu_map__new(NULL);
+	cpus = perf_cpu_map__new(NULL);
 	CHECK_NOT_NULL__(cpus);
 
 	evlist = perf_evlist__new();
diff --git a/tools/perf/bench/epoll-ctl.c b/tools/perf/bench/epoll-ctl.c
index 2af067859966..7d1495d8c7e1 100644
--- a/tools/perf/bench/epoll-ctl.c
+++ b/tools/perf/bench/epoll-ctl.c
@@ -20,6 +20,7 @@
 #include <sys/resource.h>
 #include <sys/epoll.h>
 #include <sys/eventfd.h>
+#include <perf/cpumap.h>
 
 #include "../util/stat.h"
 #include <subcmd/parse-options.h>
@@ -315,7 +316,7 @@ int bench_epoll_ctl(int argc, const char **argv)
 	act.sa_sigaction = toggle_done;
 	sigaction(SIGINT, &act, NULL);
 
-	cpu = cpu_map__new(NULL);
+	cpu = perf_cpu_map__new(NULL);
 	if (!cpu)
 		goto errmem;
 
diff --git a/tools/perf/bench/epoll-wait.c b/tools/perf/bench/epoll-wait.c
index fe85448abd45..6ac2be4fbd27 100644
--- a/tools/perf/bench/epoll-wait.c
+++ b/tools/perf/bench/epoll-wait.c
@@ -75,6 +75,7 @@
 #include <sys/epoll.h>
 #include <sys/eventfd.h>
 #include <sys/types.h>
+#include <perf/cpumap.h>
 
 #include "../util/stat.h"
 #include <subcmd/parse-options.h>
@@ -429,7 +430,7 @@ int bench_epoll_wait(int argc, const char **argv)
 	act.sa_sigaction = toggle_done;
 	sigaction(SIGINT, &act, NULL);
 
-	cpu = cpu_map__new(NULL);
+	cpu = perf_cpu_map__new(NULL);
 	if (!cpu)
 		goto errmem;
 
diff --git a/tools/perf/bench/futex-hash.c b/tools/perf/bench/futex-hash.c
index a80797763e1f..ede1e5894f9c 100644
--- a/tools/perf/bench/futex-hash.c
+++ b/tools/perf/bench/futex-hash.c
@@ -20,6 +20,7 @@
 #include <linux/kernel.h>
 #include <linux/zalloc.h>
 #include <sys/time.h>
+#include <perf/cpumap.h>
 
 #include "../util/stat.h"
 #include <subcmd/parse-options.h>
@@ -132,7 +133,7 @@ int bench_futex_hash(int argc, const char **argv)
 		exit(EXIT_FAILURE);
 	}
 
-	cpu = cpu_map__new(NULL);
+	cpu = perf_cpu_map__new(NULL);
 	if (!cpu)
 		goto errmem;
 
diff --git a/tools/perf/bench/futex-lock-pi.c b/tools/perf/bench/futex-lock-pi.c
index d02330a69745..d59b95323bab 100644
--- a/tools/perf/bench/futex-lock-pi.c
+++ b/tools/perf/bench/futex-lock-pi.c
@@ -14,6 +14,7 @@
 #include <linux/kernel.h>
 #include <linux/zalloc.h>
 #include <errno.h>
+#include <perf/cpumap.h>
 #include "bench.h"
 #include "futex.h"
 #include "cpumap.h"
@@ -156,7 +157,7 @@ int bench_futex_lock_pi(int argc, const char **argv)
 	if (argc)
 		goto err;
 
-	cpu = cpu_map__new(NULL);
+	cpu = perf_cpu_map__new(NULL);
 	if (!cpu)
 		err(EXIT_FAILURE, "calloc");
 
diff --git a/tools/perf/bench/futex-requeue.c b/tools/perf/bench/futex-requeue.c
index fc692efa0c05..f85ca4750b1a 100644
--- a/tools/perf/bench/futex-requeue.c
+++ b/tools/perf/bench/futex-requeue.c
@@ -20,6 +20,7 @@
 #include <linux/kernel.h>
 #include <linux/time64.h>
 #include <errno.h>
+#include <perf/cpumap.h>
 #include "bench.h"
 #include "futex.h"
 #include "cpumap.h"
@@ -123,7 +124,7 @@ int bench_futex_requeue(int argc, const char **argv)
 	if (argc)
 		goto err;
 
-	cpu = cpu_map__new(NULL);
+	cpu = perf_cpu_map__new(NULL);
 	if (!cpu)
 		err(EXIT_FAILURE, "cpu_map__new");
 
diff --git a/tools/perf/bench/futex-wake-parallel.c b/tools/perf/bench/futex-wake-parallel.c
index 69d8fdc87315..bb83107485ef 100644
--- a/tools/perf/bench/futex-wake-parallel.c
+++ b/tools/perf/bench/futex-wake-parallel.c
@@ -237,7 +237,7 @@ int bench_futex_wake_parallel(int argc, const char **argv)
 	act.sa_sigaction = toggle_done;
 	sigaction(SIGINT, &act, NULL);
 
-	cpu = cpu_map__new(NULL);
+	cpu = perf_cpu_map__new(NULL);
 	if (!cpu)
 		err(EXIT_FAILURE, "calloc");
 
diff --git a/tools/perf/bench/futex-wake.c b/tools/perf/bench/futex-wake.c
index e8181ad7d088..732707d0c7f6 100644
--- a/tools/perf/bench/futex-wake.c
+++ b/tools/perf/bench/futex-wake.c
@@ -20,6 +20,7 @@
 #include <linux/kernel.h>
 #include <linux/time64.h>
 #include <errno.h>
+#include <perf/cpumap.h>
 #include "bench.h"
 #include "futex.h"
 #include "cpumap.h"
@@ -131,7 +132,7 @@ int bench_futex_wake(int argc, const char **argv)
 		exit(EXIT_FAILURE);
 	}
 
-	cpu = cpu_map__new(NULL);
+	cpu = perf_cpu_map__new(NULL);
 	if (!cpu)
 		err(EXIT_FAILURE, "calloc");
 
* Unmerged path tools/perf/builtin-ftrace.c
diff --git a/tools/perf/builtin-sched.c b/tools/perf/builtin-sched.c
index d17a75eb69b7..7acf1e20d575 100644
--- a/tools/perf/builtin-sched.c
+++ b/tools/perf/builtin-sched.c
@@ -3184,7 +3184,7 @@ static int setup_map_cpus(struct perf_sched *sched)
 	if (!sched->map.cpus_str)
 		return 0;
 
-	map = cpu_map__new(sched->map.cpus_str);
+	map = perf_cpu_map__new(sched->map.cpus_str);
 	if (!map) {
 		pr_err("failed to get cpus map from %s\n", sched->map.cpus_str);
 		return -1;
@@ -3218,7 +3218,7 @@ static int setup_color_cpus(struct perf_sched *sched)
 	if (!sched->map.color_cpus_str)
 		return 0;
 
-	map = cpu_map__new(sched->map.color_cpus_str);
+	map = perf_cpu_map__new(sched->map.color_cpus_str);
 	if (!map) {
 		pr_err("failed to get thread map from %s\n", sched->map.color_cpus_str);
 		return -1;
* Unmerged path tools/perf/lib/cpumap.c
* Unmerged path tools/perf/lib/include/internal/cpumap.h
* Unmerged path tools/perf/lib/include/perf/cpumap.h
* Unmerged path tools/perf/lib/libperf.map
* Unmerged path tools/perf/tests/bitmap.c
diff --git a/tools/perf/tests/code-reading.c b/tools/perf/tests/code-reading.c
index aa6df122b175..b7d0496e3da2 100644
--- a/tools/perf/tests/code-reading.c
+++ b/tools/perf/tests/code-reading.c
@@ -8,6 +8,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <sys/param.h>
+#include <perf/cpumap.h>
 
 #include "parse-events.h"
 #include "evlist.h"
@@ -613,9 +614,9 @@ static int do_test_code_reading(bool try_kcore)
 		goto out_put;
 	}
 
-	cpus = cpu_map__new(NULL);
+	cpus = perf_cpu_map__new(NULL);
 	if (!cpus) {
-		pr_debug("cpu_map__new failed\n");
+		pr_debug("perf_cpu_map__new failed\n");
 		goto out_put;
 	}
 
* Unmerged path tools/perf/tests/cpumap.c
diff --git a/tools/perf/tests/event-times.c b/tools/perf/tests/event-times.c
index 1a2686f1fcf0..b4c80c3c72fd 100644
--- a/tools/perf/tests/event-times.c
+++ b/tools/perf/tests/event-times.c
@@ -4,6 +4,7 @@
 #include <inttypes.h>
 #include <string.h>
 #include <sys/wait.h>
+#include <perf/cpumap.h>
 #include "tests.h"
 #include "evlist.h"
 #include "evsel.h"
@@ -115,9 +116,9 @@ static int attach__cpu_disabled(struct perf_evlist *evlist)
 
 	pr_debug("attaching to CPU 0 as enabled\n");
 
-	cpus = cpu_map__new("0");
+	cpus = perf_cpu_map__new("0");
 	if (cpus == NULL) {
-		pr_debug("failed to call cpu_map__new\n");
+		pr_debug("failed to call perf_cpu_map__new\n");
 		return -1;
 	}
 
@@ -144,9 +145,9 @@ static int attach__cpu_enabled(struct perf_evlist *evlist)
 
 	pr_debug("attaching to CPU 0 as enabled\n");
 
-	cpus = cpu_map__new("0");
+	cpus = perf_cpu_map__new("0");
 	if (cpus == NULL) {
-		pr_debug("failed to call cpu_map__new\n");
+		pr_debug("failed to call perf_cpu_map__new\n");
 		return -1;
 	}
 
diff --git a/tools/perf/tests/event_update.c b/tools/perf/tests/event_update.c
index f14dcd613438..08d86350803f 100644
--- a/tools/perf/tests/event_update.c
+++ b/tools/perf/tests/event_update.c
@@ -1,5 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
 #include <linux/compiler.h>
+#include <perf/cpumap.h>
 #include "evlist.h"
 #include "evsel.h"
 #include "machine.h"
@@ -108,7 +109,7 @@ int test__event_update(struct test *test __maybe_unused, int subtest __maybe_unu
 	TEST_ASSERT_VAL("failed to synthesize attr update name",
 			!perf_event__synthesize_event_update_name(&tmp.tool, evsel, process_event_name));
 
-	evsel->own_cpus = cpu_map__new("1,2,3");
+	evsel->own_cpus = perf_cpu_map__new("1,2,3");
 
 	TEST_ASSERT_VAL("failed to synthesize attr update cpus",
 			!perf_event__synthesize_event_update_cpus(&tmp.tool, evsel, process_event_cpus));
diff --git a/tools/perf/tests/keep-tracking.c b/tools/perf/tests/keep-tracking.c
index 17c46f3e6f1e..9cf857797ae2 100644
--- a/tools/perf/tests/keep-tracking.c
+++ b/tools/perf/tests/keep-tracking.c
@@ -2,6 +2,7 @@
 #include <linux/types.h>
 #include <unistd.h>
 #include <sys/prctl.h>
+#include <perf/cpumap.h>
 
 #include "parse-events.h"
 #include "evlist.h"
@@ -75,7 +76,7 @@ int test__keep_tracking(struct test *test __maybe_unused, int subtest __maybe_un
 	threads = thread_map__new(-1, getpid(), UINT_MAX);
 	CHECK_NOT_NULL__(threads);
 
-	cpus = cpu_map__new(NULL);
+	cpus = perf_cpu_map__new(NULL);
 	CHECK_NOT_NULL__(cpus);
 
 	evlist = perf_evlist__new();
* Unmerged path tools/perf/tests/mem2node.c
diff --git a/tools/perf/tests/mmap-basic.c b/tools/perf/tests/mmap-basic.c
index 0919b0793e5b..c56c2e78e5fa 100644
--- a/tools/perf/tests/mmap-basic.c
+++ b/tools/perf/tests/mmap-basic.c
@@ -3,6 +3,7 @@
 #include <inttypes.h>
 /* For the CLR_() macros */
 #include <pthread.h>
+#include <perf/cpumap.h>
 
 #include "evlist.h"
 #include "evsel.h"
@@ -46,7 +47,7 @@ int test__basic_mmap(struct test *test __maybe_unused, int subtest __maybe_unuse
 		return -1;
 	}
 
-	cpus = cpu_map__new(NULL);
+	cpus = perf_cpu_map__new(NULL);
 	if (cpus == NULL) {
 		pr_debug("cpu_map__new\n");
 		goto out_free_threads;
diff --git a/tools/perf/tests/openat-syscall-all-cpus.c b/tools/perf/tests/openat-syscall-all-cpus.c
index 493ecb611540..0e633b0de0be 100644
--- a/tools/perf/tests/openat-syscall-all-cpus.c
+++ b/tools/perf/tests/openat-syscall-all-cpus.c
@@ -33,7 +33,7 @@ int test__openat_syscall_event_on_all_cpus(struct test *test __maybe_unused, int
 		return -1;
 	}
 
-	cpus = cpu_map__new(NULL);
+	cpus = perf_cpu_map__new(NULL);
 	if (cpus == NULL) {
 		pr_debug("cpu_map__new\n");
 		goto out_thread_map_delete;
diff --git a/tools/perf/tests/switch-tracking.c b/tools/perf/tests/switch-tracking.c
index 6cdab5f4812a..48566038ef09 100644
--- a/tools/perf/tests/switch-tracking.c
+++ b/tools/perf/tests/switch-tracking.c
@@ -5,6 +5,7 @@
 #include <time.h>
 #include <stdlib.h>
 #include <linux/zalloc.h>
+#include <perf/cpumap.h>
 
 #include "parse-events.h"
 #include "evlist.h"
@@ -341,9 +342,9 @@ int test__switch_tracking(struct test *test __maybe_unused, int subtest __maybe_
 		goto out_err;
 	}
 
-	cpus = cpu_map__new(NULL);
+	cpus = perf_cpu_map__new(NULL);
 	if (!cpus) {
-		pr_debug("cpu_map__new failed!\n");
+		pr_debug("perf_cpu_map__new failed!\n");
 		goto out_err;
 	}
 
diff --git a/tools/perf/tests/topology.c b/tools/perf/tests/topology.c
index c22c9d8190e8..02962b3fe4d9 100644
--- a/tools/perf/tests/topology.c
+++ b/tools/perf/tests/topology.c
@@ -2,6 +2,7 @@
 #include <string.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <perf/cpumap.h>
 #include "tests.h"
 #include "util.h"
 #include "session.h"
@@ -127,7 +128,7 @@ int test__session_topology(struct test *test __maybe_unused, int subtest __maybe
 	if (session_write_header(path))
 		goto free_path;
 
-	map = cpu_map__new(NULL);
+	map = perf_cpu_map__new(NULL);
 	if (map == NULL) {
 		pr_debug("failed to get system cpumap\n");
 		goto free_path;
* Unmerged path tools/perf/util/cpumap.c
* Unmerged path tools/perf/util/cpumap.h
diff --git a/tools/perf/util/cputopo.c b/tools/perf/util/cputopo.c
index 64336a280967..92109b3eef69 100644
--- a/tools/perf/util/cputopo.c
+++ b/tools/perf/util/cputopo.c
@@ -5,6 +5,7 @@
 #include <stdlib.h>
 #include <api/fs/fs.h>
 #include <linux/zalloc.h>
+#include <perf/cpumap.h>
 
 #include "cputopo.h"
 #include "cpumap.h"
@@ -182,7 +183,7 @@ struct cpu_topology *cpu_topology__new(void)
 	ncpus = cpu__max_present_cpu();
 
 	/* build online CPU map */
-	map = cpu_map__new(NULL);
+	map = perf_cpu_map__new(NULL);
 	if (map == NULL) {
 		pr_debug("failed to get system cpumap\n");
 		return NULL;
@@ -312,7 +313,7 @@ struct numa_topology *numa_topology__new(void)
 	if (c)
 		*c = '\0';
 
-	node_map = cpu_map__new(buf);
+	node_map = perf_cpu_map__new(buf);
 	if (!node_map)
 		goto out;
 
* Unmerged path tools/perf/util/evlist.c
diff --git a/tools/perf/util/header.c b/tools/perf/util/header.c
index c3fbdc63c78a..c730a069712a 100644
--- a/tools/perf/util/header.c
+++ b/tools/perf/util/header.c
@@ -20,6 +20,7 @@
 #include <linux/time64.h>
 #include <dirent.h>
 #include <bpf/libbpf.h>
+#include <perf/cpumap.h>
 
 #include "evlist.h"
 #include "evsel.h"
@@ -2340,7 +2341,7 @@ static int process_numa_topology(struct feat_fd *ff, void *data __maybe_unused)
 		if (!str)
 			goto error;
 
-		n->map = cpu_map__new(str);
+		n->map = perf_cpu_map__new(str);
 		if (!n->map)
 			goto error;
 
* Unmerged path tools/perf/util/parse-events.c
diff --git a/tools/perf/util/pmu.c b/tools/perf/util/pmu.c
index f32b710347db..6a4339162c24 100644
--- a/tools/perf/util/pmu.c
+++ b/tools/perf/util/pmu.c
@@ -15,6 +15,7 @@
 #include <api/fs/fs.h>
 #include <locale.h>
 #include <regex.h>
+#include <perf/cpumap.h>
 #include "pmu.h"
 #include "parse-events.h"
 #include "cpumap.h"
@@ -581,7 +582,7 @@ static struct cpu_map *__pmu_cpumask(const char *path)
 	if (!file)
 		return NULL;
 
-	cpus = cpu_map__read(file);
+	cpus = perf_cpu_map__read(file);
 	fclose(file);
 	return cpus;
 }
diff --git a/tools/perf/util/python.c b/tools/perf/util/python.c
index 1e5b6718dcea..937dd18e8029 100644
--- a/tools/perf/util/python.c
+++ b/tools/perf/util/python.c
@@ -4,6 +4,7 @@
 #include <inttypes.h>
 #include <poll.h>
 #include <linux/err.h>
+#include <perf/cpumap.h>
 #include "evlist.h"
 #include "callchain.h"
 #include "evsel.h"
@@ -549,7 +550,7 @@ static int pyrf_cpu_map__init(struct pyrf_cpu_map *pcpus,
 					 kwlist, &cpustr))
 		return -1;
 
-	pcpus->cpus = cpu_map__new(cpustr);
+	pcpus->cpus = perf_cpu_map__new(cpustr);
 	if (pcpus->cpus == NULL)
 		return -1;
 	return 0;
* Unmerged path tools/perf/util/record.c
diff --git a/tools/perf/util/session.c b/tools/perf/util/session.c
index 8e7c741a2b51..006fe180306c 100644
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@ -10,6 +10,7 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/mman.h>
+#include <perf/cpumap.h>
 
 #include "evlist.h"
 #include "evsel.h"
@@ -2297,7 +2298,7 @@ int perf_session__cpu_bitmap(struct perf_session *session,
 		}
 	}
 
-	map = cpu_map__new(cpu_list);
+	map = perf_cpu_map__new(cpu_list);
 	if (map == NULL) {
 		pr_err("Invalid cpu_list\n");
 		return -1;
diff --git a/tools/perf/util/svghelper.c b/tools/perf/util/svghelper.c
index 4d2e6c811b98..e4b2bca9fbf9 100644
--- a/tools/perf/util/svghelper.c
+++ b/tools/perf/util/svghelper.c
@@ -20,6 +20,7 @@
 #include <linux/bitmap.h>
 #include <linux/time64.h>
 #include <linux/zalloc.h>
+#include <perf/cpumap.h>
 
 #include "env.h"
 #include "perf.h"
@@ -733,7 +734,7 @@ static int str_to_bitmap(char *s, cpumask_t *b, int nr_cpus)
 	struct cpu_map *m;
 	int c;
 
-	m = cpu_map__new(s);
+	m = perf_cpu_map__new(s);
 	if (!m)
 		return -1;
 
