atomics: Prepare for atomic64_fetch_add_unless()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mark Rutland <mark.rutland@arm.com>
commit 0ae1d994020d75ac065fd42ac4cbf5ac6ce9b255
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0ae1d994.failed

Currently all architectures must implement atomic_fetch_add_unless(),
with common code providing atomic_add_unless(). Architectures must also
implement atomic64_add_unless() directly, with no corresponding
atomic64_fetch_add_unless().

This divergence is unfortunate, and means that the APIs for atomic_t,
atomic64_t, and atomic_long_t differ.

In preparation for unifying things, with architectures providing
atomic64_fetch_add_unless, this patch adds a generic
atomic64_add_unless() which will use atomic64_fetch_add_unless(). The
instrumented atomics are updated to take this case into account.

There should be no functional change as a result of this patch.

	Signed-off-by: Mark Rutland <mark.rutland@arm.com>
	Reviewed-by: Will Deacon <will.deacon@arm.com>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Albert Ou <albert@sifive.com>
	Cc: Arnd Bergmann <arnd@arndb.de>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Boqun Feng <boqun.feng@gmail.com>
	Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Matt Turner <mattst88@gmail.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Palmer Dabbelt <palmer@sifive.com>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Richard Henderson <rth@twiddle.net>
	Cc: Russell King <linux@armlinux.org.uk>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vineet Gupta <vgupta@synopsys.com>
Link: https://lore.kernel.org/lkml/20180621121321.4761-8-mark.rutland@arm.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 0ae1d994020d75ac065fd42ac4cbf5ac6ce9b255)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/atomic.h
diff --cc include/linux/atomic.h
index 6ebab115d8ad,3c03de648007..000000000000
--- a/include/linux/atomic.h
+++ b/include/linux/atomic.h
@@@ -1019,6 -1042,33 +1019,36 @@@ static inline int atomic_dec_if_positiv
  #define atomic64_try_cmpxchg_release	atomic64_try_cmpxchg
  #endif /* atomic64_try_cmpxchg */
  
++<<<<<<< HEAD
++=======
+ /**
+  * atomic64_add_unless - add unless the number is already a given value
+  * @v: pointer of type atomic_t
+  * @a: the amount to add to v...
+  * @u: ...unless v is equal to u.
+  *
+  * Atomically adds @a to @v, if @v was not already @u.
+  * Returns true if the addition was done.
+  */
+ #ifdef atomic64_fetch_add_unless
+ static inline bool atomic64_add_unless(atomic64_t *v, long long a, long long u)
+ {
+ 	return atomic64_fetch_add_unless(v, a, u) != u;
+ }
+ #endif
+ 
+ /**
+  * atomic64_inc_not_zero - increment unless the number is zero
+  * @v: pointer of type atomic64_t
+  *
+  * Atomically increments @v by 1, if @v is non-zero.
+  * Returns true if the increment was done.
+  */
+ #ifndef atomic64_inc_not_zero
+ #define atomic64_inc_not_zero(v)	atomic64_add_unless((v), 1, 0)
+ #endif
+ 
++>>>>>>> 0ae1d994020d (atomics: Prepare for atomic64_fetch_add_unless())
  #ifndef atomic64_andnot
  static inline void atomic64_andnot(long long i, atomic64_t *v)
  {
diff --git a/include/asm-generic/atomic-instrumented.h b/include/asm-generic/atomic-instrumented.h
index cfee349ddd5a..98cff8a977d8 100644
--- a/include/asm-generic/atomic-instrumented.h
+++ b/include/asm-generic/atomic-instrumented.h
@@ -91,11 +91,20 @@ static __always_inline int __atomic_add_unless(atomic_t *v, int a, int u)
 }
 
 
+#ifdef arch_atomic64_fetch_add_unless
+#define atomic64_fetch_add_unless atomic64_fetch_add_unless
+static __always_inline s64 atomic64_fetch_add_unless(atomic64_t *v, s64 a, s64 u)
+{
+	kasan_check_write(v, sizeof(*v));
+	return arch_atomic64_fetch_add_unless(v, a, u);
+}
+#else
 static __always_inline bool atomic64_add_unless(atomic64_t *v, s64 a, s64 u)
 {
 	kasan_check_write(v, sizeof(*v));
 	return arch_atomic64_add_unless(v, a, u);
 }
+#endif
 
 static __always_inline void atomic_inc(atomic_t *v)
 {
* Unmerged path include/linux/atomic.h
