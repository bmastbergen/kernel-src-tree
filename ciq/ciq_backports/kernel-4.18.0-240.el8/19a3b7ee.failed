ipv6: export function to send route updates

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author David Ahern <dsahern@gmail.com>
commit 19a3b7eea42402accf52bcb9ddb51bfdb4d7a13b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/19a3b7ee.failed

Add fib6_rt_update to send RTM_NEWROUTE with NLM_F_REPLACE set. This
helper will be used by the nexthop code to notify userspace of routes
that are impacted when a nexthop config is updated via replace.

This notification is needed for legacy apps that do not understand
the new nexthop object. Apps that are nexthop aware can use the
RTA_NH_ID attribute in the route notification to just ignore it.

In the future this should be wrapped in a sysctl to allow OS'es that
are fully updated to avoid the notificaton storm.

	Signed-off-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 19a3b7eea42402accf52bcb9ddb51bfdb4d7a13b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ipv6_stubs.h
#	net/ipv6/af_inet6.c
diff --cc include/net/ipv6_stubs.h
index 44a56078b6fb,5c93e942c50b..000000000000
--- a/include/net/ipv6_stubs.h
+++ b/include/net/ipv6_stubs.h
@@@ -28,20 -29,27 +28,32 @@@ struct ipv6_stub 
  	int (*ipv6_route_input)(struct sk_buff *skb);
  
  	struct fib6_table *(*fib6_get_table)(struct net *net, u32 id);
 -	int (*fib6_lookup)(struct net *net, int oif, struct flowi6 *fl6,
 -			   struct fib6_result *res, int flags);
 -	int (*fib6_table_lookup)(struct net *net, struct fib6_table *table,
 -				 int oif, struct flowi6 *fl6,
 -				 struct fib6_result *res, int flags);
 -	void (*fib6_select_path)(const struct net *net, struct fib6_result *res,
 -				 struct flowi6 *fl6, int oif, bool oif_match,
 -				 const struct sk_buff *skb, int strict);
 -	u32 (*ip6_mtu_from_fib6)(const struct fib6_result *res,
 -				 const struct in6_addr *daddr,
 -				 const struct in6_addr *saddr);
 +	struct fib6_info *(*fib6_lookup)(struct net *net, int oif,
 +					 struct flowi6 *fl6, int flags);
 +	struct fib6_info *(*fib6_table_lookup)(struct net *net,
 +					      struct fib6_table *table,
 +					      int oif, struct flowi6 *fl6,
 +					      int flags);
 +	struct fib6_info *(*fib6_multipath_select)(const struct net *net,
 +						   struct fib6_info *f6i,
 +						   struct flowi6 *fl6, int oif,
 +						   const struct sk_buff *skb,
 +						   int strict);
 +	u32 (*ip6_mtu_from_fib6)(struct fib6_info *f6i, struct in6_addr *daddr,
 +				 struct in6_addr *saddr);
  
++<<<<<<< HEAD
++=======
+ 	int (*fib6_nh_init)(struct net *net, struct fib6_nh *fib6_nh,
+ 			    struct fib6_config *cfg, gfp_t gfp_flags,
+ 			    struct netlink_ext_ack *extack);
+ 	void (*fib6_nh_release)(struct fib6_nh *fib6_nh);
+ 	void (*fib6_update_sernum)(struct net *net, struct fib6_info *rt);
+ 	int (*ip6_del_rt)(struct net *net, struct fib6_info *rt);
+ 	void (*fib6_rt_update)(struct net *net, struct fib6_info *rt,
+ 			       struct nl_info *info);
+ 
++>>>>>>> 19a3b7eea424 (ipv6: export function to send route updates)
  	void (*udpv6_encap_enable)(void);
  	void (*ndisc_send_na)(struct net_device *dev, const struct in6_addr *daddr,
  			      const struct in6_addr *solicited_addr,
diff --cc net/ipv6/af_inet6.c
index 40b7087fe6d1,cc6f8d0c625a..000000000000
--- a/net/ipv6/af_inet6.c
+++ b/net/ipv6/af_inet6.c
@@@ -916,8 -922,13 +916,16 @@@ static const struct ipv6_stub ipv6_stub
  	.fib6_get_table	   = fib6_get_table,
  	.fib6_table_lookup = fib6_table_lookup,
  	.fib6_lookup       = fib6_lookup,
 -	.fib6_select_path  = fib6_select_path,
 +	.fib6_multipath_select = fib6_multipath_select,
  	.ip6_mtu_from_fib6 = ip6_mtu_from_fib6,
++<<<<<<< HEAD
++=======
+ 	.fib6_nh_init	   = fib6_nh_init,
+ 	.fib6_nh_release   = fib6_nh_release,
+ 	.fib6_update_sernum = fib6_update_sernum_stub,
+ 	.fib6_rt_update	   = fib6_rt_update,
+ 	.ip6_del_rt	   = ip6_del_rt,
++>>>>>>> 19a3b7eea424 (ipv6: export function to send route updates)
  	.udpv6_encap_enable = udpv6_encap_enable,
  	.ndisc_send_na = ndisc_send_na,
  	.nd_tbl	= &nd_tbl,
diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h
index 390067ba9e95..8e56f7e059b6 100644
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@ -433,6 +433,12 @@ struct lwtunnel_state *fib6_info_nh_lwt(const struct fib6_info *f6i)
 	return f6i->fib6_nh.nh_lwtstate;
 }
 
+int call_fib6_entry_notifiers(struct net *net,
+			      enum fib_event_type event_type,
+			      struct fib6_info *rt,
+			      struct netlink_ext_ack *extack);
+void fib6_rt_update(struct net *net, struct fib6_info *rt,
+		    struct nl_info *info);
 void inet6_rt_notify(int event, struct fib6_info *rt, struct nl_info *info,
 		     unsigned int flags);
 
* Unmerged path include/net/ipv6_stubs.h
* Unmerged path net/ipv6/af_inet6.c
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index f7014e41a454..3945de5229aa 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -401,10 +401,10 @@ static int call_fib6_entry_notifier(struct notifier_block *nb, struct net *net,
 	return call_fib6_notifier(nb, net, event_type, &info.info);
 }
 
-static int call_fib6_entry_notifiers(struct net *net,
-				     enum fib_event_type event_type,
-				     struct fib6_info *rt,
-				     struct netlink_ext_ack *extack)
+int call_fib6_entry_notifiers(struct net *net,
+			      enum fib_event_type event_type,
+			      struct fib6_info *rt,
+			      struct netlink_ext_ack *extack)
 {
 	struct fib6_entry_notifier_info info = {
 		.info.extack = extack,
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index 4c25bb1e4dd5..1233f0e720e8 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -5221,6 +5221,38 @@ void inet6_rt_notify(int event, struct fib6_info *rt, struct nl_info *info,
 		rtnl_set_sk_err(net, RTNLGRP_IPV6_ROUTE, err);
 }
 
+void fib6_rt_update(struct net *net, struct fib6_info *rt,
+		    struct nl_info *info)
+{
+	u32 seq = info->nlh ? info->nlh->nlmsg_seq : 0;
+	struct sk_buff *skb;
+	int err = -ENOBUFS;
+
+	/* call_fib6_entry_notifiers will be removed when in-kernel notifier
+	 * is implemented and supported for nexthop objects
+	 */
+	call_fib6_entry_notifiers(net, FIB_EVENT_ENTRY_REPLACE, rt, NULL);
+
+	skb = nlmsg_new(rt6_nlmsg_size(rt), gfp_any());
+	if (!skb)
+		goto errout;
+
+	err = rt6_fill_node(net, skb, rt, NULL, NULL, NULL, 0,
+			    RTM_NEWROUTE, info->portid, seq, NLM_F_REPLACE);
+	if (err < 0) {
+		/* -EMSGSIZE implies BUG in rt6_nlmsg_size() */
+		WARN_ON(err == -EMSGSIZE);
+		kfree_skb(skb);
+		goto errout;
+	}
+	rtnl_notify(skb, net, info->portid, RTNLGRP_IPV6_ROUTE,
+		    info->nlh, gfp_any());
+	return;
+errout:
+	if (err < 0)
+		rtnl_set_sk_err(net, RTNLGRP_IPV6_ROUTE, err);
+}
+
 static int ip6_route_dev_notify(struct notifier_block *this,
 				unsigned long event, void *ptr)
 {
