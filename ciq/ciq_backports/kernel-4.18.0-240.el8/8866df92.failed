netfilter: nfnetlink_cttimeout: pass default timeout policy to obj_to_nlattr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 8866df9264a34e675b4ee8a151db819b87cce2d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8866df92.failed

Otherwise, we hit a NULL pointer deference since handlers always assume
default timeout policy is passed.

  netlink: 24 bytes leftover after parsing attributes in process `syz-executor2'.
  kasan: CONFIG_KASAN_INLINE enabled
  kasan: GPF could be caused by NULL-ptr deref or user memory access
  general protection fault: 0000 [#1] PREEMPT SMP KASAN
  CPU: 0 PID: 9575 Comm: syz-executor1 Not tainted 4.19.0+ #312
  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
  RIP: 0010:icmp_timeout_obj_to_nlattr+0x77/0x170 net/netfilter/nf_conntrack_proto_icmp.c:297

Fixes: c779e849608a ("netfilter: conntrack: remove get_timeout() indirection")
	Reported-by: Eric Dumazet <eric.dumazet@gmail.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 8866df9264a34e675b4ee8a151db819b87cce2d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nfnetlink_cttimeout.c
diff --cc net/netfilter/nfnetlink_cttimeout.c
index 6720dbb70442,a518eb162344..000000000000
--- a/net/netfilter/nfnetlink_cttimeout.c
+++ b/net/netfilter/nfnetlink_cttimeout.c
@@@ -397,8 -381,9 +397,14 @@@ err
  
  static int
  cttimeout_default_fill_info(struct net *net, struct sk_buff *skb, u32 portid,
++<<<<<<< HEAD
 +			    u32 seq, u32 type, int event,
 +			    const struct nf_conntrack_l4proto *l4proto)
++=======
+ 			    u32 seq, u32 type, int event, u16 l3num,
+ 			    const struct nf_conntrack_l4proto *l4proto,
+ 			    const unsigned int *timeouts)
++>>>>>>> 8866df9264a3 (netfilter: nfnetlink_cttimeout: pass default timeout policy to obj_to_nlattr)
  {
  	struct nlmsghdr *nlh;
  	struct nfgenmsg *nfmsg;
@@@ -418,21 -405,15 +424,27 @@@
  	    nla_put_u8(skb, CTA_TIMEOUT_L4PROTO, l4proto->l4proto))
  		goto nla_put_failure;
  
 -	nest_parms = nla_nest_start(skb, CTA_TIMEOUT_DATA | NLA_F_NESTED);
 -	if (!nest_parms)
 -		goto nla_put_failure;
 +	if (likely(l4proto->ctnl_timeout.obj_to_nlattr)) {
 +		struct nlattr *nest_parms;
 +		unsigned int *timeouts = l4proto->get_timeouts(net);
 +		int ret;
  
++<<<<<<< HEAD
 +		nest_parms = nla_nest_start(skb, CTA_TIMEOUT_DATA);
 +		if (!nest_parms)
 +			goto nla_put_failure;
++=======
+ 	ret = l4proto->ctnl_timeout.obj_to_nlattr(skb, timeouts);
+ 	if (ret < 0)
+ 		goto nla_put_failure;
++>>>>>>> 8866df9264a3 (netfilter: nfnetlink_cttimeout: pass default timeout policy to obj_to_nlattr)
 +
 +		ret = l4proto->ctnl_timeout.obj_to_nlattr(skb, timeouts);
 +		if (ret < 0)
 +			goto nla_put_failure;
  
 -	nla_nest_end(skb, nest_parms);
 +		nla_nest_end(skb, nest_parms);
 +	}
  
  	nlmsg_end(skb, nlh);
  	return skb->len;
@@@ -460,14 -442,46 +473,46 @@@ static int cttimeout_default_get(struc
  
  	l3num = ntohs(nla_get_be16(cda[CTA_TIMEOUT_L3PROTO]));
  	l4num = nla_get_u8(cda[CTA_TIMEOUT_L4PROTO]);
 -	l4proto = nf_ct_l4proto_find_get(l4num);
 +	l4proto = nf_ct_l4proto_find_get(l3num, l4num);
  
- 	/* This protocol is not supported, skip. */
- 	if (l4proto->l4proto != l4num) {
- 		err = -EOPNOTSUPP;
+ 	err = -EOPNOTSUPP;
+ 	if (l4proto->l4proto != l4num)
  		goto err;
+ 
+ 	switch (l4proto->l4proto) {
+ 	case IPPROTO_ICMP:
+ 		timeouts = &nf_icmp_pernet(net)->timeout;
+ 		break;
+ 	case IPPROTO_TCP:
+ 		timeouts = nf_tcp_pernet(net)->timeouts;
+ 		break;
+ 	case IPPROTO_UDP:
+ 		timeouts = nf_udp_pernet(net)->timeouts;
+ 		break;
+ 	case IPPROTO_DCCP:
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 		timeouts = nf_dccp_pernet(net)->dccp_timeout;
+ #endif
+ 		break;
+ 	case IPPROTO_ICMPV6:
+ 		timeouts = &nf_icmpv6_pernet(net)->timeout;
+ 		break;
+ 	case IPPROTO_SCTP:
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ 		timeouts = nf_sctp_pernet(net)->timeouts;
+ #endif
+ 		break;
+ 	case 255:
+ 		timeouts = &nf_generic_pernet(net)->timeout;
+ 		break;
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		break;
  	}
  
+ 	if (!timeouts)
+ 		goto err;
+ 
  	skb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
  	if (skb2 == NULL) {
  		err = -ENOMEM;
@@@ -478,7 -492,7 +523,11 @@@
  					  nlh->nlmsg_seq,
  					  NFNL_MSG_TYPE(nlh->nlmsg_type),
  					  IPCTNL_MSG_TIMEOUT_DEFAULT_SET,
++<<<<<<< HEAD
 +					  l4proto);
++=======
+ 					  l3num, l4proto, timeouts);
++>>>>>>> 8866df9264a3 (netfilter: nfnetlink_cttimeout: pass default timeout policy to obj_to_nlattr)
  	if (ret <= 0) {
  		kfree_skb(skb2);
  		err = -ENOMEM;
* Unmerged path net/netfilter/nfnetlink_cttimeout.c
