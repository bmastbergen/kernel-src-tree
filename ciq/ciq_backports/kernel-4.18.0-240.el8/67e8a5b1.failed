iommu/vt-d: Don't apply gfx quirks to untrusted devices

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Rajat Jain <rajatja@google.com>
commit 67e8a5b18d41af9298db5c17193f671f235cce01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/67e8a5b1.failed

Currently, an external malicious PCI device can masquerade the VID:PID
of faulty gfx devices, and thus apply iommu quirks to effectively
disable the IOMMU restrictions for itself.

Thus we need to ensure that the device we are applying quirks to, is
indeed an internal trusted device.

	Signed-off-by: Rajat Jain <rajatja@google.com>
	Reviewed-by: Ashok Raj <ashok.raj@intel.com>
	Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Acked-by: Lu Baolu <baolu.lu@linux.intel.com>
Link: https://lore.kernel.org/r/20200622231345.29722-4-baolu.lu@linux.intel.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 67e8a5b18d41af9298db5c17193f671f235cce01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index e339a5e3c53b,66d07b1a3be2..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -5719,6 -5989,54 +5719,57 @@@ static bool intel_iommu_is_attach_defer
  	return attach_deferred(dev);
  }
  
++<<<<<<< HEAD:drivers/iommu/intel-iommu.c
++=======
+ static int
+ intel_iommu_domain_set_attr(struct iommu_domain *domain,
+ 			    enum iommu_attr attr, void *data)
+ {
+ 	struct dmar_domain *dmar_domain = to_dmar_domain(domain);
+ 	unsigned long flags;
+ 	int ret = 0;
+ 
+ 	if (domain->type != IOMMU_DOMAIN_UNMANAGED)
+ 		return -EINVAL;
+ 
+ 	switch (attr) {
+ 	case DOMAIN_ATTR_NESTING:
+ 		spin_lock_irqsave(&device_domain_lock, flags);
+ 		if (nested_mode_support() &&
+ 		    list_empty(&dmar_domain->devices)) {
+ 			dmar_domain->flags |= DOMAIN_FLAG_NESTING_MODE;
+ 			dmar_domain->flags &= ~DOMAIN_FLAG_USE_FIRST_LEVEL;
+ 		} else {
+ 			ret = -ENODEV;
+ 		}
+ 		spin_unlock_irqrestore(&device_domain_lock, flags);
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ /*
+  * Check that the device does not live on an external facing PCI port that is
+  * marked as untrusted. Such devices should not be able to apply quirks and
+  * thus not be able to bypass the IOMMU restrictions.
+  */
+ static bool risky_device(struct pci_dev *pdev)
+ {
+ 	if (pdev->untrusted) {
+ 		pci_info(pdev,
+ 			 "Skipping IOMMU quirk for dev [%04X:%04X] on untrusted PCI link\n",
+ 			 pdev->vendor, pdev->device);
+ 		pci_info(pdev, "Please check with your BIOS/Platform vendor about this\n");
+ 		return true;
+ 	}
+ 	return false;
+ }
+ 
++>>>>>>> 67e8a5b18d41 (iommu/vt-d: Don't apply gfx quirks to untrusted devices):drivers/iommu/intel/iommu.c
  const struct iommu_ops intel_iommu_ops = {
  	.capable		= intel_iommu_capable,
  	.domain_alloc		= intel_iommu_domain_alloc,
* Unmerged path drivers/iommu/intel-iommu.c
