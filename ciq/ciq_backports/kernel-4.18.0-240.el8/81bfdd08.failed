libbpf: Put Kconfig externs into .kconfig section

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 81bfdd087bf31a87c5ff25cc7004d5308954a35c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/81bfdd08.failed

Move Kconfig-provided externs into custom .kconfig section. Add __kconfig into
bpf_helpers.h for user convenience. Update selftests accordingly.

	Suggested-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20191219002837.3074619-2-andriin@fb.com
(cherry picked from commit 81bfdd087bf31a87c5ff25cc7004d5308954a35c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/bpf/bpftool/gen.c
#	tools/lib/bpf/bpf_helpers.h
#	tools/lib/bpf/libbpf.c
diff --cc tools/bpf/bpftool/gen.c
index fbac89cefb31,a14d8bc5d31d..000000000000
--- a/tools/bpf/bpftool/gen.c
+++ b/tools/bpf/bpftool/gen.c
@@@ -82,6 -83,8 +82,11 @@@ static const char *get_map_ident(const 
  		return "rodata";
  	else if (str_has_suffix(name, ".bss"))
  		return "bss";
++<<<<<<< HEAD
++=======
+ 	else if (str_has_suffix(name, ".kconfig"))
+ 		return "kconfig";
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  	else
  		return NULL;
  }
@@@ -109,6 -112,8 +114,11 @@@ static int codegen_datasec_def(struct b
  		sec_ident = "bss";
  	else if (strcmp(sec_name, ".rodata") == 0)
  		sec_ident = "rodata";
++<<<<<<< HEAD
++=======
+ 	else if (strcmp(sec_name, ".kconfig") == 0)
+ 		sec_ident = "kconfig";
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  	else
  		return 0;
  
diff --cc tools/lib/bpf/bpf_helpers.h
index 0c7d28292898,f69cc208778a..000000000000
--- a/tools/lib/bpf/bpf_helpers.h
+++ b/tools/lib/bpf/bpf_helpers.h
@@@ -44,4 -47,12 +44,15 @@@ enum libbpf_pin_type 
  	LIBBPF_PIN_BY_NAME,
  };
  
++<<<<<<< HEAD
++=======
+ enum libbpf_tristate {
+ 	TRI_NO = 0,
+ 	TRI_YES = 1,
+ 	TRI_MODULE = 2,
+ };
+ 
+ #define __kconfig __attribute__((section(".kconfig")))
+ 
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  #endif
diff --cc tools/lib/bpf/libbpf.c
index a22c75b6283d,0772eb3254e2..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -231,18 -231,21 +231,30 @@@ struct bpf_program 
  #define DATA_SEC ".data"
  #define BSS_SEC ".bss"
  #define RODATA_SEC ".rodata"
++<<<<<<< HEAD
++=======
+ #define KCONFIG_SEC ".kconfig"
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  
  enum libbpf_map_type {
  	LIBBPF_MAP_UNSPEC,
  	LIBBPF_MAP_DATA,
  	LIBBPF_MAP_BSS,
  	LIBBPF_MAP_RODATA,
++<<<<<<< HEAD
++=======
+ 	LIBBPF_MAP_KCONFIG,
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  };
  
  static const char * const libbpf_type_to_btf_name[] = {
  	[LIBBPF_MAP_DATA]	= DATA_SEC,
  	[LIBBPF_MAP_BSS]	= BSS_SEC,
  	[LIBBPF_MAP_RODATA]	= RODATA_SEC,
++<<<<<<< HEAD
++=======
+ 	[LIBBPF_MAP_KCONFIG]	= KCONFIG_SEC,
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  };
  
  struct bpf_map {
@@@ -277,6 -302,11 +289,14 @@@ struct bpf_object 
  	size_t nr_maps;
  	size_t maps_cap;
  
++<<<<<<< HEAD
++=======
+ 	char *kconfig_path;
+ 	struct extern_desc *externs;
+ 	int nr_extern;
+ 	int kconfig_map_idx;
+ 
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  	bool loaded;
  	bool has_pseudo_calls;
  	bool relaxed_core_relocs;
@@@ -575,6 -606,7 +595,10 @@@ static struct bpf_object *bpf_object__n
  	obj->efile.data_shndx = -1;
  	obj->efile.rodata_shndx = -1;
  	obj->efile.bss_shndx = -1;
++<<<<<<< HEAD
++=======
+ 	obj->kconfig_map_idx = -1;
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  
  	obj->kern_version = get_kernel_version();
  	obj->loaded = false;
@@@ -899,12 -943,12 +935,18 @@@ bpf_object__init_internal_map(struct bp
  	def->key_size = sizeof(int);
  	def->value_size = data_sz;
  	def->max_entries = 1;
++<<<<<<< HEAD
 +	def->map_flags = type == LIBBPF_MAP_RODATA ? BPF_F_RDONLY_PROG : 0;
 +	if (obj->caps.array_mmap)
 +		def->map_flags |= BPF_F_MMAPABLE;
++=======
+ 	def->map_flags = type == LIBBPF_MAP_RODATA || type == LIBBPF_MAP_KCONFIG
+ 			 ? BPF_F_RDONLY_PROG : 0;
+ 	def->map_flags |= BPF_F_MMAPABLE;
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  
  	pr_debug("map '%s' (global data): at sec_idx %d, offset %zu, flags %x.\n",
- 		 map_name, map->sec_idx, map->sec_offset, def->map_flags);
+ 		 map->name, map->sec_idx, map->sec_offset, def->map_flags);
  
  	map->mmaped = mmap(NULL, bpf_map_mmap_sz(map), PROT_READ | PROT_WRITE,
  			   MAP_SHARED | MAP_ANONYMOUS, -1, 0);
@@@ -960,6 -1002,271 +1002,274 @@@ static int bpf_object__init_global_data
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ 
+ static struct extern_desc *find_extern_by_name(const struct bpf_object *obj,
+ 					       const void *name)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < obj->nr_extern; i++) {
+ 		if (strcmp(obj->externs[i].name, name) == 0)
+ 			return &obj->externs[i];
+ 	}
+ 	return NULL;
+ }
+ 
+ static int set_ext_value_tri(struct extern_desc *ext, void *ext_val,
+ 			     char value)
+ {
+ 	switch (ext->type) {
+ 	case EXT_BOOL:
+ 		if (value == 'm') {
+ 			pr_warn("extern %s=%c should be tristate or char\n",
+ 				ext->name, value);
+ 			return -EINVAL;
+ 		}
+ 		*(bool *)ext_val = value == 'y' ? true : false;
+ 		break;
+ 	case EXT_TRISTATE:
+ 		if (value == 'y')
+ 			*(enum libbpf_tristate *)ext_val = TRI_YES;
+ 		else if (value == 'm')
+ 			*(enum libbpf_tristate *)ext_val = TRI_MODULE;
+ 		else /* value == 'n' */
+ 			*(enum libbpf_tristate *)ext_val = TRI_NO;
+ 		break;
+ 	case EXT_CHAR:
+ 		*(char *)ext_val = value;
+ 		break;
+ 	case EXT_UNKNOWN:
+ 	case EXT_INT:
+ 	case EXT_CHAR_ARR:
+ 	default:
+ 		pr_warn("extern %s=%c should be bool, tristate, or char\n",
+ 			ext->name, value);
+ 		return -EINVAL;
+ 	}
+ 	ext->is_set = true;
+ 	return 0;
+ }
+ 
+ static int set_ext_value_str(struct extern_desc *ext, char *ext_val,
+ 			     const char *value)
+ {
+ 	size_t len;
+ 
+ 	if (ext->type != EXT_CHAR_ARR) {
+ 		pr_warn("extern %s=%s should char array\n", ext->name, value);
+ 		return -EINVAL;
+ 	}
+ 
+ 	len = strlen(value);
+ 	if (value[len - 1] != '"') {
+ 		pr_warn("extern '%s': invalid string config '%s'\n",
+ 			ext->name, value);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* strip quotes */
+ 	len -= 2;
+ 	if (len >= ext->sz) {
+ 		pr_warn("extern '%s': long string config %s of (%zu bytes) truncated to %d bytes\n",
+ 			ext->name, value, len, ext->sz - 1);
+ 		len = ext->sz - 1;
+ 	}
+ 	memcpy(ext_val, value + 1, len);
+ 	ext_val[len] = '\0';
+ 	ext->is_set = true;
+ 	return 0;
+ }
+ 
+ static int parse_u64(const char *value, __u64 *res)
+ {
+ 	char *value_end;
+ 	int err;
+ 
+ 	errno = 0;
+ 	*res = strtoull(value, &value_end, 0);
+ 	if (errno) {
+ 		err = -errno;
+ 		pr_warn("failed to parse '%s' as integer: %d\n", value, err);
+ 		return err;
+ 	}
+ 	if (*value_end) {
+ 		pr_warn("failed to parse '%s' as integer completely\n", value);
+ 		return -EINVAL;
+ 	}
+ 	return 0;
+ }
+ 
+ static bool is_ext_value_in_range(const struct extern_desc *ext, __u64 v)
+ {
+ 	int bit_sz = ext->sz * 8;
+ 
+ 	if (ext->sz == 8)
+ 		return true;
+ 
+ 	/* Validate that value stored in u64 fits in integer of `ext->sz`
+ 	 * bytes size without any loss of information. If the target integer
+ 	 * is signed, we rely on the following limits of integer type of
+ 	 * Y bits and subsequent transformation:
+ 	 *
+ 	 *     -2^(Y-1) <= X           <= 2^(Y-1) - 1
+ 	 *            0 <= X + 2^(Y-1) <= 2^Y - 1
+ 	 *            0 <= X + 2^(Y-1) <  2^Y
+ 	 *
+ 	 *  For unsigned target integer, check that all the (64 - Y) bits are
+ 	 *  zero.
+ 	 */
+ 	if (ext->is_signed)
+ 		return v + (1ULL << (bit_sz - 1)) < (1ULL << bit_sz);
+ 	else
+ 		return (v >> bit_sz) == 0;
+ }
+ 
+ static int set_ext_value_num(struct extern_desc *ext, void *ext_val,
+ 			     __u64 value)
+ {
+ 	if (ext->type != EXT_INT && ext->type != EXT_CHAR) {
+ 		pr_warn("extern %s=%llu should be integer\n",
+ 			ext->name, value);
+ 		return -EINVAL;
+ 	}
+ 	if (!is_ext_value_in_range(ext, value)) {
+ 		pr_warn("extern %s=%llu value doesn't fit in %d bytes\n",
+ 			ext->name, value, ext->sz);
+ 		return -ERANGE;
+ 	}
+ 	switch (ext->sz) {
+ 		case 1: *(__u8 *)ext_val = value; break;
+ 		case 2: *(__u16 *)ext_val = value; break;
+ 		case 4: *(__u32 *)ext_val = value; break;
+ 		case 8: *(__u64 *)ext_val = value; break;
+ 		default:
+ 			return -EINVAL;
+ 	}
+ 	ext->is_set = true;
+ 	return 0;
+ }
+ 
+ static int bpf_object__read_kernel_config(struct bpf_object *obj,
+ 					  const char *config_path,
+ 					  void *data)
+ {
+ 	char buf[PATH_MAX], *sep, *value;
+ 	struct extern_desc *ext;
+ 	int len, err = 0;
+ 	void *ext_val;
+ 	__u64 num;
+ 	gzFile file;
+ 
+ 	if (config_path) {
+ 		file = gzopen(config_path, "r");
+ 	} else {
+ 		struct utsname uts;
+ 
+ 		uname(&uts);
+ 		len = snprintf(buf, PATH_MAX, "/boot/config-%s", uts.release);
+ 		if (len < 0)
+ 			return -EINVAL;
+ 		else if (len >= PATH_MAX)
+ 			return -ENAMETOOLONG;
+ 		/* gzopen also accepts uncompressed files. */
+ 		file = gzopen(buf, "r");
+ 		if (!file)
+ 			file = gzopen("/proc/config.gz", "r");
+ 	}
+ 	if (!file) {
+ 		pr_warn("failed to read kernel config at '%s'\n", config_path);
+ 		return -ENOENT;
+ 	}
+ 
+ 	while (gzgets(file, buf, sizeof(buf))) {
+ 		if (strncmp(buf, "CONFIG_", 7))
+ 			continue;
+ 
+ 		sep = strchr(buf, '=');
+ 		if (!sep) {
+ 			err = -EINVAL;
+ 			pr_warn("failed to parse '%s': no separator\n", buf);
+ 			goto out;
+ 		}
+ 		/* Trim ending '\n' */
+ 		len = strlen(buf);
+ 		if (buf[len - 1] == '\n')
+ 			buf[len - 1] = '\0';
+ 		/* Split on '=' and ensure that a value is present. */
+ 		*sep = '\0';
+ 		if (!sep[1]) {
+ 			err = -EINVAL;
+ 			*sep = '=';
+ 			pr_warn("failed to parse '%s': no value\n", buf);
+ 			goto out;
+ 		}
+ 
+ 		ext = find_extern_by_name(obj, buf);
+ 		if (!ext)
+ 			continue;
+ 		if (ext->is_set) {
+ 			err = -EINVAL;
+ 			pr_warn("re-defining extern '%s' not allowed\n", buf);
+ 			goto out;
+ 		}
+ 
+ 		ext_val = data + ext->data_off;
+ 		value = sep + 1;
+ 
+ 		switch (*value) {
+ 		case 'y': case 'n': case 'm':
+ 			err = set_ext_value_tri(ext, ext_val, *value);
+ 			break;
+ 		case '"':
+ 			err = set_ext_value_str(ext, ext_val, value);
+ 			break;
+ 		default:
+ 			/* assume integer */
+ 			err = parse_u64(value, &num);
+ 			if (err) {
+ 				pr_warn("extern %s=%s should be integer\n",
+ 					ext->name, value);
+ 				goto out;
+ 			}
+ 			err = set_ext_value_num(ext, ext_val, num);
+ 			break;
+ 		}
+ 		if (err)
+ 			goto out;
+ 		pr_debug("extern %s=%s\n", ext->name, value);
+ 	}
+ 
+ out:
+ 	gzclose(file);
+ 	return err;
+ }
+ 
+ static int bpf_object__init_kconfig_map(struct bpf_object *obj)
+ {
+ 	struct extern_desc *last_ext;
+ 	size_t map_sz;
+ 	int err;
+ 
+ 	if (obj->nr_extern == 0)
+ 		return 0;
+ 
+ 	last_ext = &obj->externs[obj->nr_extern - 1];
+ 	map_sz = last_ext->data_off + last_ext->sz;
+ 
+ 	err = bpf_object__init_internal_map(obj, LIBBPF_MAP_KCONFIG,
+ 					    obj->efile.symbols_shndx,
+ 					    NULL, map_sz);
+ 	if (err)
+ 		return err;
+ 
+ 	obj->kconfig_map_idx = obj->nr_maps - 1;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  static int bpf_object__init_user_maps(struct bpf_object *obj, bool strict)
  {
  	Elf_Data *symbols = obj->efile.symbols;
@@@ -1434,21 -1741,20 +1744,27 @@@ static int bpf_object__init_user_btf_ma
  	return 0;
  }
  
 -static int bpf_object__init_maps(struct bpf_object *obj,
 -				 const struct bpf_object_open_opts *opts)
 +static int bpf_object__init_maps(struct bpf_object *obj, bool relaxed_maps,
 +				 const char *pin_root_path)
  {
 -	const char *pin_root_path;
 -	bool strict;
 +	bool strict = !relaxed_maps;
  	int err;
  
 -	strict = !OPTS_GET(opts, relaxed_maps, false);
 -	pin_root_path = OPTS_GET(opts, pin_root_path, NULL);
 -
  	err = bpf_object__init_user_maps(obj, strict);
++<<<<<<< HEAD
 +	if (err)
 +		return err;
 +
 +	err = bpf_object__init_user_btf_maps(obj, strict, pin_root_path);
 +	if (err)
 +		return err;
 +
 +	err = bpf_object__init_global_data_maps(obj);
++=======
+ 	err = err ?: bpf_object__init_user_btf_maps(obj, strict, pin_root_path);
+ 	err = err ?: bpf_object__init_global_data_maps(obj);
+ 	err = err ?: bpf_object__init_kconfig_map(obj);
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  	if (err)
  		return err;
  
@@@ -1770,14 -2095,217 +2086,228 @@@ static int bpf_object__elf_collect(stru
  		pr_warn("Corrupted ELF file: index of strtab invalid\n");
  		return -LIBBPF_ERRNO__FORMAT;
  	}
++<<<<<<< HEAD
 +	err = bpf_object__init_btf(obj, btf_data, btf_ext_data);
 +	if (!err)
 +		err = bpf_object__init_maps(obj, relaxed_maps, pin_root_path);
 +	if (!err)
 +		err = bpf_object__sanitize_and_load_btf(obj);
 +	if (!err)
 +		err = bpf_object__init_prog_names(obj);
 +	return err;
++=======
+ 	return bpf_object__init_btf(obj, btf_data, btf_ext_data);
+ }
+ 
+ static bool sym_is_extern(const GElf_Sym *sym)
+ {
+ 	int bind = GELF_ST_BIND(sym->st_info);
+ 	/* externs are symbols w/ type=NOTYPE, bind=GLOBAL|WEAK, section=UND */
+ 	return sym->st_shndx == SHN_UNDEF &&
+ 	       (bind == STB_GLOBAL || bind == STB_WEAK) &&
+ 	       GELF_ST_TYPE(sym->st_info) == STT_NOTYPE;
+ }
+ 
+ static int find_extern_btf_id(const struct btf *btf, const char *ext_name)
+ {
+ 	const struct btf_type *t;
+ 	const char *var_name;
+ 	int i, n;
+ 
+ 	if (!btf)
+ 		return -ESRCH;
+ 
+ 	n = btf__get_nr_types(btf);
+ 	for (i = 1; i <= n; i++) {
+ 		t = btf__type_by_id(btf, i);
+ 
+ 		if (!btf_is_var(t))
+ 			continue;
+ 
+ 		var_name = btf__name_by_offset(btf, t->name_off);
+ 		if (strcmp(var_name, ext_name))
+ 			continue;
+ 
+ 		if (btf_var(t)->linkage != BTF_VAR_GLOBAL_EXTERN)
+ 			return -EINVAL;
+ 
+ 		return i;
+ 	}
+ 
+ 	return -ENOENT;
+ }
+ 
+ static enum extern_type find_extern_type(const struct btf *btf, int id,
+ 					 bool *is_signed)
+ {
+ 	const struct btf_type *t;
+ 	const char *name;
+ 
+ 	t = skip_mods_and_typedefs(btf, id, NULL);
+ 	name = btf__name_by_offset(btf, t->name_off);
+ 
+ 	if (is_signed)
+ 		*is_signed = false;
+ 	switch (btf_kind(t)) {
+ 	case BTF_KIND_INT: {
+ 		int enc = btf_int_encoding(t);
+ 
+ 		if (enc & BTF_INT_BOOL)
+ 			return t->size == 1 ? EXT_BOOL : EXT_UNKNOWN;
+ 		if (is_signed)
+ 			*is_signed = enc & BTF_INT_SIGNED;
+ 		if (t->size == 1)
+ 			return EXT_CHAR;
+ 		if (t->size < 1 || t->size > 8 || (t->size & (t->size - 1)))
+ 			return EXT_UNKNOWN;
+ 		return EXT_INT;
+ 	}
+ 	case BTF_KIND_ENUM:
+ 		if (t->size != 4)
+ 			return EXT_UNKNOWN;
+ 		if (strcmp(name, "libbpf_tristate"))
+ 			return EXT_UNKNOWN;
+ 		return EXT_TRISTATE;
+ 	case BTF_KIND_ARRAY:
+ 		if (btf_array(t)->nelems == 0)
+ 			return EXT_UNKNOWN;
+ 		if (find_extern_type(btf, btf_array(t)->type, NULL) != EXT_CHAR)
+ 			return EXT_UNKNOWN;
+ 		return EXT_CHAR_ARR;
+ 	default:
+ 		return EXT_UNKNOWN;
+ 	}
+ }
+ 
+ static int cmp_externs(const void *_a, const void *_b)
+ {
+ 	const struct extern_desc *a = _a;
+ 	const struct extern_desc *b = _b;
+ 
+ 	/* descending order by alignment requirements */
+ 	if (a->align != b->align)
+ 		return a->align > b->align ? -1 : 1;
+ 	/* ascending order by size, within same alignment class */
+ 	if (a->sz != b->sz)
+ 		return a->sz < b->sz ? -1 : 1;
+ 	/* resolve ties by name */
+ 	return strcmp(a->name, b->name);
+ }
+ 
+ static int bpf_object__collect_externs(struct bpf_object *obj)
+ {
+ 	const struct btf_type *t;
+ 	struct extern_desc *ext;
+ 	int i, n, off, btf_id;
+ 	struct btf_type *sec;
+ 	const char *ext_name;
+ 	Elf_Scn *scn;
+ 	GElf_Shdr sh;
+ 
+ 	if (!obj->efile.symbols)
+ 		return 0;
+ 
+ 	scn = elf_getscn(obj->efile.elf, obj->efile.symbols_shndx);
+ 	if (!scn)
+ 		return -LIBBPF_ERRNO__FORMAT;
+ 	if (gelf_getshdr(scn, &sh) != &sh)
+ 		return -LIBBPF_ERRNO__FORMAT;
+ 	n = sh.sh_size / sh.sh_entsize;
+ 
+ 	pr_debug("looking for externs among %d symbols...\n", n);
+ 	for (i = 0; i < n; i++) {
+ 		GElf_Sym sym;
+ 
+ 		if (!gelf_getsym(obj->efile.symbols, i, &sym))
+ 			return -LIBBPF_ERRNO__FORMAT;
+ 		if (!sym_is_extern(&sym))
+ 			continue;
+ 		ext_name = elf_strptr(obj->efile.elf, obj->efile.strtabidx,
+ 				      sym.st_name);
+ 		if (!ext_name || !ext_name[0])
+ 			continue;
+ 
+ 		ext = obj->externs;
+ 		ext = reallocarray(ext, obj->nr_extern + 1, sizeof(*ext));
+ 		if (!ext)
+ 			return -ENOMEM;
+ 		obj->externs = ext;
+ 		ext = &ext[obj->nr_extern];
+ 		memset(ext, 0, sizeof(*ext));
+ 		obj->nr_extern++;
+ 
+ 		ext->btf_id = find_extern_btf_id(obj->btf, ext_name);
+ 		if (ext->btf_id <= 0) {
+ 			pr_warn("failed to find BTF for extern '%s': %d\n",
+ 				ext_name, ext->btf_id);
+ 			return ext->btf_id;
+ 		}
+ 		t = btf__type_by_id(obj->btf, ext->btf_id);
+ 		ext->name = btf__name_by_offset(obj->btf, t->name_off);
+ 		ext->sym_idx = i;
+ 		ext->is_weak = GELF_ST_BIND(sym.st_info) == STB_WEAK;
+ 		ext->sz = btf__resolve_size(obj->btf, t->type);
+ 		if (ext->sz <= 0) {
+ 			pr_warn("failed to resolve size of extern '%s': %d\n",
+ 				ext_name, ext->sz);
+ 			return ext->sz;
+ 		}
+ 		ext->align = btf__align_of(obj->btf, t->type);
+ 		if (ext->align <= 0) {
+ 			pr_warn("failed to determine alignment of extern '%s': %d\n",
+ 				ext_name, ext->align);
+ 			return -EINVAL;
+ 		}
+ 		ext->type = find_extern_type(obj->btf, t->type,
+ 					     &ext->is_signed);
+ 		if (ext->type == EXT_UNKNOWN) {
+ 			pr_warn("extern '%s' type is unsupported\n", ext_name);
+ 			return -ENOTSUP;
+ 		}
+ 	}
+ 	pr_debug("collected %d externs total\n", obj->nr_extern);
+ 
+ 	if (!obj->nr_extern)
+ 		return 0;
+ 
+ 	/* sort externs by (alignment, size, name) and calculate their offsets
+ 	 * within a map */
+ 	qsort(obj->externs, obj->nr_extern, sizeof(*ext), cmp_externs);
+ 	off = 0;
+ 	for (i = 0; i < obj->nr_extern; i++) {
+ 		ext = &obj->externs[i];
+ 		ext->data_off = roundup(off, ext->align);
+ 		off = ext->data_off + ext->sz;
+ 		pr_debug("extern #%d: symbol %d, off %u, name %s\n",
+ 			 i, ext->sym_idx, ext->data_off, ext->name);
+ 	}
+ 
+ 	btf_id = btf__find_by_name(obj->btf, KCONFIG_SEC);
+ 	if (btf_id <= 0) {
+ 		pr_warn("no BTF info found for '%s' datasec\n", KCONFIG_SEC);
+ 		return -ESRCH;
+ 	}
+ 
+ 	sec = (struct btf_type *)btf__type_by_id(obj->btf, btf_id);
+ 	sec->size = off;
+ 	n = btf_vlen(sec);
+ 	for (i = 0; i < n; i++) {
+ 		struct btf_var_secinfo *vs = btf_var_secinfos(sec) + i;
+ 
+ 		t = btf__type_by_id(obj->btf, vs->type);
+ 		ext_name = btf__name_by_offset(obj->btf, t->name_off);
+ 		ext = find_extern_by_name(obj, ext_name);
+ 		if (!ext) {
+ 			pr_warn("failed to find extern definition for BTF var '%s'\n",
+ 				ext_name);
+ 			return -ESRCH;
+ 		}
+ 		vs->offset = ext->data_off;
+ 		btf_var(t)->linkage = BTF_VAR_GLOBAL_ALLOCATED;
+ 	}
+ 
+ 	return 0;
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  }
  
  static struct bpf_program *
@@@ -1831,6 -2372,8 +2361,11 @@@ bpf_object__section_to_libbpf_map_type(
  		return LIBBPF_MAP_BSS;
  	else if (shndx == obj->efile.rodata_shndx)
  		return LIBBPF_MAP_RODATA;
++<<<<<<< HEAD
++=======
+ 	else if (shndx == obj->efile.symbols_shndx)
+ 		return LIBBPF_MAP_KCONFIG;
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  	else
  		return LIBBPF_MAP_UNSPEC;
  }
@@@ -2357,8 -2920,8 +2892,13 @@@ bpf_object__populate_internal_map(struc
  		return err;
  	}
  
++<<<<<<< HEAD
 +	/* Freeze .rodata map as read-only from syscall side. */
 +	if (map->libbpf_type == LIBBPF_MAP_RODATA) {
++=======
+ 	/* Freeze .rodata and .kconfig map as read-only from syscall side. */
+ 	if (map_type == LIBBPF_MAP_RODATA || map_type == LIBBPF_MAP_KCONFIG) {
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  		err = bpf_map_freeze(map->fd);
  		if (err) {
  			err = -errno;
@@@ -3722,24 -4256,30 +4262,39 @@@ bpf_program__relocate(struct bpf_progra
  
  	for (i = 0; i < prog->nr_reloc; i++) {
  		struct reloc_desc *relo = &prog->reloc_desc[i];
 -		struct bpf_insn *insn = &prog->insns[relo->insn_idx];
  
 -		if (relo->insn_idx + 1 >= (int)prog->insns_cnt) {
 -			pr_warn("relocation out of range: '%s'\n",
 -				prog->section_name);
 -			return -LIBBPF_ERRNO__RELOC;
 -		}
 +		if (relo->type == RELO_LD64 || relo->type == RELO_DATA) {
 +			struct bpf_insn *insn = &prog->insns[relo->insn_idx];
 +
 +			if (relo->insn_idx + 1 >= (int)prog->insns_cnt) {
 +				pr_warn("relocation out of range: '%s'\n",
 +					prog->section_name);
 +				return -LIBBPF_ERRNO__RELOC;
 +			}
  
 -		switch (relo->type) {
 -		case RELO_LD64:
 -			insn[0].src_reg = BPF_PSEUDO_MAP_FD;
 +			if (relo->type != RELO_DATA) {
 +				insn[0].src_reg = BPF_PSEUDO_MAP_FD;
 +			} else {
 +				insn[0].src_reg = BPF_PSEUDO_MAP_VALUE;
 +				insn[1].imm = insn[0].imm + relo->sym_off;
 +			}
  			insn[0].imm = obj->maps[relo->map_idx].fd;
++<<<<<<< HEAD
 +		} else if (relo->type == RELO_CALL) {
++=======
+ 			break;
+ 		case RELO_DATA:
+ 			insn[0].src_reg = BPF_PSEUDO_MAP_VALUE;
+ 			insn[1].imm = insn[0].imm + relo->sym_off;
+ 			insn[0].imm = obj->maps[relo->map_idx].fd;
+ 			break;
+ 		case RELO_EXTERN:
+ 			insn[0].src_reg = BPF_PSEUDO_MAP_VALUE;
+ 			insn[0].imm = obj->maps[obj->kconfig_map_idx].fd;
+ 			insn[1].imm = relo->sym_off;
+ 			break;
+ 		case RELO_CALL:
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  			err = bpf_program__reloc_text(prog, obj, relo);
  			if (err)
  				return err;
@@@ -4160,6 -4726,79 +4715,82 @@@ int bpf_object__unload(struct bpf_objec
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int bpf_object__sanitize_maps(struct bpf_object *obj)
+ {
+ 	struct bpf_map *m;
+ 
+ 	bpf_object__for_each_map(m, obj) {
+ 		if (!bpf_map__is_internal(m))
+ 			continue;
+ 		if (!obj->caps.global_data) {
+ 			pr_warn("kernel doesn't support global data\n");
+ 			return -ENOTSUP;
+ 		}
+ 		if (!obj->caps.array_mmap)
+ 			m->def.map_flags ^= BPF_F_MMAPABLE;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int bpf_object__resolve_externs(struct bpf_object *obj,
+ 				       const char *config_path)
+ {
+ 	bool need_config = false;
+ 	struct extern_desc *ext;
+ 	int err, i;
+ 	void *data;
+ 
+ 	if (obj->nr_extern == 0)
+ 		return 0;
+ 
+ 	data = obj->maps[obj->kconfig_map_idx].mmaped;
+ 
+ 	for (i = 0; i < obj->nr_extern; i++) {
+ 		ext = &obj->externs[i];
+ 
+ 		if (strcmp(ext->name, "LINUX_KERNEL_VERSION") == 0) {
+ 			void *ext_val = data + ext->data_off;
+ 			__u32 kver = get_kernel_version();
+ 
+ 			if (!kver) {
+ 				pr_warn("failed to get kernel version\n");
+ 				return -EINVAL;
+ 			}
+ 			err = set_ext_value_num(ext, ext_val, kver);
+ 			if (err)
+ 				return err;
+ 			pr_debug("extern %s=0x%x\n", ext->name, kver);
+ 		} else if (strncmp(ext->name, "CONFIG_", 7) == 0) {
+ 			need_config = true;
+ 		} else {
+ 			pr_warn("unrecognized extern '%s'\n", ext->name);
+ 			return -EINVAL;
+ 		}
+ 	}
+ 	if (need_config) {
+ 		err = bpf_object__read_kernel_config(obj, config_path, data);
+ 		if (err)
+ 			return -EINVAL;
+ 	}
+ 	for (i = 0; i < obj->nr_extern; i++) {
+ 		ext = &obj->externs[i];
+ 
+ 		if (!ext->is_set && !ext->is_weak) {
+ 			pr_warn("extern %s (strong) not resolved\n", ext->name);
+ 			return -ESRCH;
+ 		} else if (!ext->is_set) {
+ 			pr_debug("extern %s (weak) not resolved, defaulting to zero\n",
+ 				 ext->name);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
  int bpf_object__load_xattr(struct bpf_object_load_attr *attr)
  {
  	struct bpf_object *obj;
@@@ -6620,3 -7515,165 +7251,168 @@@ int libbpf_num_possible_cpus(void
  	WRITE_ONCE(cpus, tmp_cpus);
  	return tmp_cpus;
  }
++<<<<<<< HEAD
++=======
+ 
+ int bpf_object__open_skeleton(struct bpf_object_skeleton *s,
+ 			      const struct bpf_object_open_opts *opts)
+ {
+ 	DECLARE_LIBBPF_OPTS(bpf_object_open_opts, skel_opts,
+ 		.object_name = s->name,
+ 	);
+ 	struct bpf_object *obj;
+ 	int i;
+ 
+ 	/* Attempt to preserve opts->object_name, unless overriden by user
+ 	 * explicitly. Overwriting object name for skeletons is discouraged,
+ 	 * as it breaks global data maps, because they contain object name
+ 	 * prefix as their own map name prefix. When skeleton is generated,
+ 	 * bpftool is making an assumption that this name will stay the same.
+ 	 */
+ 	if (opts) {
+ 		memcpy(&skel_opts, opts, sizeof(*opts));
+ 		if (!opts->object_name)
+ 			skel_opts.object_name = s->name;
+ 	}
+ 
+ 	obj = bpf_object__open_mem(s->data, s->data_sz, &skel_opts);
+ 	if (IS_ERR(obj)) {
+ 		pr_warn("failed to initialize skeleton BPF object '%s': %ld\n",
+ 			s->name, PTR_ERR(obj));
+ 		return PTR_ERR(obj);
+ 	}
+ 
+ 	*s->obj = obj;
+ 
+ 	for (i = 0; i < s->map_cnt; i++) {
+ 		struct bpf_map **map = s->maps[i].map;
+ 		const char *name = s->maps[i].name;
+ 		void **mmaped = s->maps[i].mmaped;
+ 
+ 		*map = bpf_object__find_map_by_name(obj, name);
+ 		if (!*map) {
+ 			pr_warn("failed to find skeleton map '%s'\n", name);
+ 			return -ESRCH;
+ 		}
+ 
+ 		/* externs shouldn't be pre-setup from user code */
+ 		if (mmaped && (*map)->libbpf_type != LIBBPF_MAP_KCONFIG)
+ 			*mmaped = (*map)->mmaped;
+ 	}
+ 
+ 	for (i = 0; i < s->prog_cnt; i++) {
+ 		struct bpf_program **prog = s->progs[i].prog;
+ 		const char *name = s->progs[i].name;
+ 
+ 		*prog = bpf_object__find_program_by_name(obj, name);
+ 		if (!*prog) {
+ 			pr_warn("failed to find skeleton program '%s'\n", name);
+ 			return -ESRCH;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int bpf_object__load_skeleton(struct bpf_object_skeleton *s)
+ {
+ 	int i, err;
+ 
+ 	err = bpf_object__load(*s->obj);
+ 	if (err) {
+ 		pr_warn("failed to load BPF skeleton '%s': %d\n", s->name, err);
+ 		return err;
+ 	}
+ 
+ 	for (i = 0; i < s->map_cnt; i++) {
+ 		struct bpf_map *map = *s->maps[i].map;
+ 		size_t mmap_sz = bpf_map_mmap_sz(map);
+ 		int prot, map_fd = bpf_map__fd(map);
+ 		void **mmaped = s->maps[i].mmaped;
+ 
+ 		if (!mmaped)
+ 			continue;
+ 
+ 		if (!(map->def.map_flags & BPF_F_MMAPABLE)) {
+ 			*mmaped = NULL;
+ 			continue;
+ 		}
+ 
+ 		if (map->def.map_flags & BPF_F_RDONLY_PROG)
+ 			prot = PROT_READ;
+ 		else
+ 			prot = PROT_READ | PROT_WRITE;
+ 
+ 		/* Remap anonymous mmap()-ed "map initialization image" as
+ 		 * a BPF map-backed mmap()-ed memory, but preserving the same
+ 		 * memory address. This will cause kernel to change process'
+ 		 * page table to point to a different piece of kernel memory,
+ 		 * but from userspace point of view memory address (and its
+ 		 * contents, being identical at this point) will stay the
+ 		 * same. This mapping will be released by bpf_object__close()
+ 		 * as per normal clean up procedure, so we don't need to worry
+ 		 * about it from skeleton's clean up perspective.
+ 		 */
+ 		*mmaped = mmap(map->mmaped, mmap_sz, prot,
+ 				MAP_SHARED | MAP_FIXED, map_fd, 0);
+ 		if (*mmaped == MAP_FAILED) {
+ 			err = -errno;
+ 			*mmaped = NULL;
+ 			pr_warn("failed to re-mmap() map '%s': %d\n",
+ 				 bpf_map__name(map), err);
+ 			return err;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int bpf_object__attach_skeleton(struct bpf_object_skeleton *s)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < s->prog_cnt; i++) {
+ 		struct bpf_program *prog = *s->progs[i].prog;
+ 		struct bpf_link **link = s->progs[i].link;
+ 		const struct bpf_sec_def *sec_def;
+ 		const char *sec_name = bpf_program__title(prog, false);
+ 
+ 		sec_def = find_sec_def(sec_name);
+ 		if (!sec_def || !sec_def->attach_fn)
+ 			continue;
+ 
+ 		*link = sec_def->attach_fn(sec_def, prog);
+ 		if (IS_ERR(*link)) {
+ 			pr_warn("failed to auto-attach program '%s': %ld\n",
+ 				bpf_program__name(prog), PTR_ERR(*link));
+ 			return PTR_ERR(*link);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ void bpf_object__detach_skeleton(struct bpf_object_skeleton *s)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < s->prog_cnt; i++) {
+ 		struct bpf_link **link = s->progs[i].link;
+ 
+ 		if (!IS_ERR_OR_NULL(*link))
+ 			bpf_link__destroy(*link);
+ 		*link = NULL;
+ 	}
+ }
+ 
+ void bpf_object__destroy_skeleton(struct bpf_object_skeleton *s)
+ {
+ 	if (s->progs)
+ 		bpf_object__detach_skeleton(s);
+ 	if (s->obj)
+ 		bpf_object__close(*s->obj);
+ 	free(s->maps);
+ 	free(s->progs);
+ 	free(s);
+ }
++>>>>>>> 81bfdd087bf3 (libbpf: Put Kconfig externs into .kconfig section)
* Unmerged path tools/bpf/bpftool/gen.c
* Unmerged path tools/lib/bpf/bpf_helpers.h
* Unmerged path tools/lib/bpf/libbpf.c
diff --git a/tools/testing/selftests/bpf/prog_tests/skeleton.c b/tools/testing/selftests/bpf/prog_tests/skeleton.c
index 151cdad3ad0d..50496625d066 100644
--- a/tools/testing/selftests/bpf/prog_tests/skeleton.c
+++ b/tools/testing/selftests/bpf/prog_tests/skeleton.c
@@ -17,20 +17,18 @@ void test_skeleton(void)
 	int duration = 0, err;
 	struct test_skeleton* skel;
 	struct test_skeleton__bss *bss;
-	struct test_skeleton__externs *exts;
+	struct test_skeleton__kconfig *kcfg;
 
 	skel = test_skeleton__open(&skeleton_embed);
 	if (CHECK(!skel, "skel_open", "failed to open skeleton\n"))
 		return;
 
-	printf("EXTERNS BEFORE: %p\n", skel->externs);
-	if (CHECK(skel->externs, "skel_externs", "externs are mmaped()!\n"))
+	if (CHECK(skel->kconfig, "skel_kconfig", "kconfig is mmaped()!\n"))
 		goto cleanup;
 
 	err = test_skeleton__load(skel);
 	if (CHECK(err, "skel_load", "failed to load skeleton: %d\n", err))
 		goto cleanup;
-	printf("EXTERNS AFTER: %p\n", skel->externs);
 
 	bss = skel->bss;
 	bss->in1 = 1;
@@ -39,7 +37,7 @@ void test_skeleton(void)
 	bss->in4 = 4;
 	bss->in5.a = 5;
 	bss->in5.b = 6;
-	exts = skel->externs;
+	kcfg = skel->kconfig;
 
 	err = test_skeleton__attach(skel);
 	if (CHECK(err, "skel_attach", "skeleton attach failed: %d\n", err))
@@ -57,10 +55,10 @@ void test_skeleton(void)
 	CHECK(bss->handler_out5.b != 6, "res6", "got %lld != exp %d\n",
 	      bss->handler_out5.b, 6);
 
-	CHECK(bss->bpf_syscall != exts->CONFIG_BPF_SYSCALL, "ext1",
-	      "got %d != exp %d\n", bss->bpf_syscall, exts->CONFIG_BPF_SYSCALL);
-	CHECK(bss->kern_ver != exts->LINUX_KERNEL_VERSION, "ext2",
-	      "got %d != exp %d\n", bss->kern_ver, exts->LINUX_KERNEL_VERSION);
+	CHECK(bss->bpf_syscall != kcfg->CONFIG_BPF_SYSCALL, "ext1",
+	      "got %d != exp %d\n", bss->bpf_syscall, kcfg->CONFIG_BPF_SYSCALL);
+	CHECK(bss->kern_ver != kcfg->LINUX_KERNEL_VERSION, "ext2",
+	      "got %d != exp %d\n", bss->kern_ver, kcfg->LINUX_KERNEL_VERSION);
 
 cleanup:
 	test_skeleton__destroy(skel);
diff --git a/tools/testing/selftests/bpf/progs/test_core_extern.c b/tools/testing/selftests/bpf/progs/test_core_extern.c
index e12f09f9e881..9bfc91d9d004 100644
--- a/tools/testing/selftests/bpf/progs/test_core_extern.c
+++ b/tools/testing/selftests/bpf/progs/test_core_extern.c
@@ -10,16 +10,16 @@
 /* non-existing BPF helper, to test dead code elimination */
 static int (*bpf_missing_helper)(const void *arg1, int arg2) = (void *) 999;
 
-extern int LINUX_KERNEL_VERSION;
-extern bool CONFIG_BPF_SYSCALL; /* strong */
-extern enum libbpf_tristate CONFIG_TRISTATE __weak;
-extern bool CONFIG_BOOL __weak;
-extern char CONFIG_CHAR __weak;
-extern uint16_t CONFIG_USHORT __weak;
-extern int CONFIG_INT __weak;
-extern uint64_t CONFIG_ULONG __weak;
-extern const char CONFIG_STR[8] __weak;
-extern uint64_t CONFIG_MISSING __weak;
+extern int LINUX_KERNEL_VERSION __kconfig;
+extern bool CONFIG_BPF_SYSCALL __kconfig; /* strong */
+extern enum libbpf_tristate CONFIG_TRISTATE __kconfig __weak;
+extern bool CONFIG_BOOL __kconfig __weak;
+extern char CONFIG_CHAR __kconfig __weak;
+extern uint16_t CONFIG_USHORT __kconfig __weak;
+extern int CONFIG_INT __kconfig __weak;
+extern uint64_t CONFIG_ULONG __kconfig __weak;
+extern const char CONFIG_STR[8] __kconfig __weak;
+extern uint64_t CONFIG_MISSING __kconfig __weak;
 
 uint64_t kern_ver = -1;
 uint64_t bpf_syscall = -1;
diff --git a/tools/testing/selftests/bpf/progs/test_skeleton.c b/tools/testing/selftests/bpf/progs/test_skeleton.c
index 9caa44758ea2..4f69aac5635f 100644
--- a/tools/testing/selftests/bpf/progs/test_skeleton.c
+++ b/tools/testing/selftests/bpf/progs/test_skeleton.c
@@ -21,8 +21,8 @@ char out3 = 0;
 long long out4 = 0;
 int out1 = 0;
 
-extern bool CONFIG_BPF_SYSCALL;
-extern int LINUX_KERNEL_VERSION;
+extern bool CONFIG_BPF_SYSCALL __kconfig;
+extern int LINUX_KERNEL_VERSION __kconfig;
 bool bpf_syscall = 0;
 int kern_ver = 0;
 
