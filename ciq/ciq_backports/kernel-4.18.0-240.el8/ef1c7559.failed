crypto/chcr: error seen if CONFIG_CHELSIO_TLS_DEVICE isn't set

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Rohit Maheshwari <rohitm@chelsio.com>
commit ef1c75593e770aff8749e902aa0deb6855a3f485
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ef1c7559.failed

cxgb4_uld_in_use() is used only by cxgb4_ktls_det_feature() which
is under CONFIG_CHELSIO_TLS_DEVICE macro.

Fixes: a3ac249a1ab5 ("cxgb4/chcr: Enable ktls settings at run time")
	Signed-off-by: Rohit Maheshwari <rohitm@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit ef1c75593e770aff8749e902aa0deb6855a3f485)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c
diff --cc drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c
index e6f03d67a758,08439e215efe..000000000000
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c
@@@ -663,6 -663,129 +663,132 @@@ static int uld_attach(struct adapter *a
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_CHELSIO_TLS_DEVICE
+ static bool cxgb4_uld_in_use(struct adapter *adap)
+ {
+ 	const struct tid_info *t = &adap->tids;
+ 
+ 	return (atomic_read(&t->conns_in_use) || t->stids_in_use);
+ }
+ 
+ /* cxgb4_set_ktls_feature: request FW to enable/disable ktls settings.
+  * @adap: adapter info
+  * @enable: 1 to enable / 0 to disable ktls settings.
+  */
+ int cxgb4_set_ktls_feature(struct adapter *adap, bool enable)
+ {
+ 	int ret = 0;
+ 	u32 params =
+ 		FW_PARAMS_MNEM_V(FW_PARAMS_MNEM_DEV) |
+ 		FW_PARAMS_PARAM_X_V(FW_PARAMS_PARAM_DEV_KTLS_HW) |
+ 		FW_PARAMS_PARAM_Y_V(enable) |
+ 		FW_PARAMS_PARAM_Z_V(FW_PARAMS_PARAM_DEV_KTLS_HW_USER_ENABLE);
+ 
+ 	if (enable) {
+ 		if (!refcount_read(&adap->chcr_ktls.ktls_refcount)) {
+ 			/* At this moment if ULD connection are up means, other
+ 			 * ULD is/are already active, return failure.
+ 			 */
+ 			if (cxgb4_uld_in_use(adap)) {
+ 				dev_warn(adap->pdev_dev,
+ 					 "ULD connections (tid/stid) active. Can't enable kTLS\n");
+ 				return -EINVAL;
+ 			}
+ 			ret = t4_set_params(adap, adap->mbox, adap->pf,
+ 					    0, 1, &params, &params);
+ 			if (ret)
+ 				return ret;
+ 			refcount_set(&adap->chcr_ktls.ktls_refcount, 1);
+ 			pr_info("kTLS has been enabled. Restrictions placed on ULD support\n");
+ 		} else {
+ 			/* ktls settings already up, just increment refcount. */
+ 			refcount_inc(&adap->chcr_ktls.ktls_refcount);
+ 		}
+ 	} else {
+ 		/* return failure if refcount is already 0. */
+ 		if (!refcount_read(&adap->chcr_ktls.ktls_refcount))
+ 			return -EINVAL;
+ 		/* decrement refcount and test, if 0, disable ktls feature,
+ 		 * else return command success.
+ 		 */
+ 		if (refcount_dec_and_test(&adap->chcr_ktls.ktls_refcount)) {
+ 			ret = t4_set_params(adap, adap->mbox, adap->pf,
+ 					    0, 1, &params, &params);
+ 			if (ret)
+ 				return ret;
+ 			pr_info("kTLS is disabled. Restrictions on ULD support removed\n");
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ #endif
+ 
+ static void cxgb4_uld_alloc_resources(struct adapter *adap,
+ 				      enum cxgb4_uld type,
+ 				      const struct cxgb4_uld_info *p)
+ {
+ 	int ret = 0;
+ 
+ 	if ((type == CXGB4_ULD_CRYPTO && !is_pci_uld(adap)) ||
+ 	    (type != CXGB4_ULD_CRYPTO && !is_offload(adap)))
+ 		return;
+ 	if (type == CXGB4_ULD_ISCSIT && is_t4(adap->params.chip))
+ 		return;
+ 	ret = cfg_queues_uld(adap, type, p);
+ 	if (ret)
+ 		goto out;
+ 	ret = setup_sge_queues_uld(adap, type, p->lro);
+ 	if (ret)
+ 		goto free_queues;
+ 	if (adap->flags & CXGB4_USING_MSIX) {
+ 		ret = request_msix_queue_irqs_uld(adap, type);
+ 		if (ret)
+ 			goto free_rxq;
+ 	}
+ 	if (adap->flags & CXGB4_FULL_INIT_DONE)
+ 		enable_rx_uld(adap, type);
+ 	if (adap->uld[type].add)
+ 		goto free_irq;
+ 	ret = setup_sge_txq_uld(adap, type, p);
+ 	if (ret)
+ 		goto free_irq;
+ 	adap->uld[type] = *p;
+ 	ret = uld_attach(adap, type);
+ 	if (ret)
+ 		goto free_txq;
+ 	return;
+ free_txq:
+ 	release_sge_txq_uld(adap, type);
+ free_irq:
+ 	if (adap->flags & CXGB4_FULL_INIT_DONE)
+ 		quiesce_rx_uld(adap, type);
+ 	if (adap->flags & CXGB4_USING_MSIX)
+ 		free_msix_queue_irqs_uld(adap, type);
+ free_rxq:
+ 	free_sge_queues_uld(adap, type);
+ free_queues:
+ 	free_queues_uld(adap, type);
+ out:
+ 	dev_warn(adap->pdev_dev,
+ 		 "ULD registration failed for uld type %d\n", type);
+ }
+ 
+ void cxgb4_uld_enable(struct adapter *adap)
+ {
+ 	struct cxgb4_uld_list *uld_entry;
+ 
+ 	mutex_lock(&uld_mutex);
+ 	list_add_tail(&adap->list_node, &adapter_list);
+ 	list_for_each_entry(uld_entry, &uld_list, list_node)
+ 		cxgb4_uld_alloc_resources(adap, uld_entry->uld_type,
+ 					  &uld_entry->uld_info);
+ 	mutex_unlock(&uld_mutex);
+ }
+ 
++>>>>>>> ef1c75593e77 (crypto/chcr: error seen if CONFIG_CHELSIO_TLS_DEVICE isn't set)
  /* cxgb4_register_uld - register an upper-layer driver
   * @type: the ULD type
   * @p: the ULD methods
* Unmerged path drivers/net/ethernet/chelsio/cxgb4/cxgb4_uld.c
