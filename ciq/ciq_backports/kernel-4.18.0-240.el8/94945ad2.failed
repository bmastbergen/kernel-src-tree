netfilter: conntrack: comparison of unsigned in cthelper confirmation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 94945ad2b330207cded0fd8d4abebde43a776dfb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/94945ad2.failed

net/netfilter/nf_conntrack_core.c: In function nf_confirm_cthelper:
net/netfilter/nf_conntrack_core.c:2117:15: warning: comparison of unsigned expression in < 0 is always false [-Wtype-limits]
 2117 |   if (protoff < 0 || (frag_off & htons(~0x7)) != 0)
      |               ^

ipv6_skip_exthdr() returns a signed integer.

	Reported-by: Colin Ian King <colin.king@canonical.com>
Fixes: 703acd70f249 ("netfilter: nfnetlink_cthelper: unbreak userspace helper support")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 94945ad2b330207cded0fd8d4abebde43a776dfb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_core.c
diff --cc net/netfilter/nf_conntrack_core.c
index 680e0b0d92a5,bb72ca5f3999..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -1801,6 -2084,76 +1801,79 @@@ static int nf_conntrack_update(struct n
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* This packet is coming from userspace via nf_queue, complete the packet
+  * processing after the helper invocation in nf_confirm().
+  */
+ static int nf_confirm_cthelper(struct sk_buff *skb, struct nf_conn *ct,
+ 			       enum ip_conntrack_info ctinfo)
+ {
+ 	const struct nf_conntrack_helper *helper;
+ 	const struct nf_conn_help *help;
+ 	int protoff;
+ 
+ 	help = nfct_help(ct);
+ 	if (!help)
+ 		return 0;
+ 
+ 	helper = rcu_dereference(help->helper);
+ 	if (!(helper->flags & NF_CT_HELPER_F_USERSPACE))
+ 		return 0;
+ 
+ 	switch (nf_ct_l3num(ct)) {
+ 	case NFPROTO_IPV4:
+ 		protoff = skb_network_offset(skb) + ip_hdrlen(skb);
+ 		break;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case NFPROTO_IPV6: {
+ 		__be16 frag_off;
+ 		u8 pnum;
+ 
+ 		pnum = ipv6_hdr(skb)->nexthdr;
+ 		protoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &pnum,
+ 					   &frag_off);
+ 		if (protoff < 0 || (frag_off & htons(~0x7)) != 0)
+ 			return 0;
+ 		break;
+ 	}
+ #endif
+ 	default:
+ 		return 0;
+ 	}
+ 
+ 	if (test_bit(IPS_SEQ_ADJUST_BIT, &ct->status) &&
+ 	    !nf_is_loopback_packet(skb)) {
+ 		if (!nf_ct_seq_adjust(skb, ct, ctinfo, protoff)) {
+ 			NF_CT_STAT_INC_ATOMIC(nf_ct_net(ct), drop);
+ 			return -1;
+ 		}
+ 	}
+ 
+ 	/* We've seen it coming out the other side: confirm it */
+ 	return nf_conntrack_confirm(skb) == NF_DROP ? - 1 : 0;
+ }
+ 
+ static int nf_conntrack_update(struct net *net, struct sk_buff *skb)
+ {
+ 	enum ip_conntrack_info ctinfo;
+ 	struct nf_conn *ct;
+ 	int err;
+ 
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct)
+ 		return 0;
+ 
+ 	if (!nf_ct_is_confirmed(ct)) {
+ 		err = __nf_conntrack_update(net, skb, ct, ctinfo);
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	return nf_confirm_cthelper(skb, ct, ctinfo);
+ }
+ 
++>>>>>>> 94945ad2b330 (netfilter: conntrack: comparison of unsigned in cthelper confirmation)
  static bool nf_conntrack_get_tuple_skb(struct nf_conntrack_tuple *dst_tuple,
  				       const struct sk_buff *skb)
  {
* Unmerged path net/netfilter/nf_conntrack_core.c
