KVM: arm64: Clean up cpu_init_hyp_mode()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author David Brazdil <dbrazdil@google.com>
commit 71b3ec5f221b8b3ff545639be83ddfcd5d7c9800
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/71b3ec5f.failed

Pull bits of code to the only place where it is used. Remove empty function
__cpu_init_stage2(). Remove redundant has_vhe() check since this function is
nVHE-only. No functional changes intended.

	Signed-off-by: David Brazdil <dbrazdil@google.com>
	Signed-off-by: Marc Zyngier <maz@kernel.org>
Link: https://lore.kernel.org/r/20200515152056.83158-1-dbrazdil@google.com
(cherry picked from commit 71b3ec5f221b8b3ff545639be83ddfcd5d7c9800)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/kvm_host.h
diff --cc arch/arm64/include/asm/kvm_host.h
index bf90a6e7997d,69a338a390a6..000000000000
--- a/arch/arm64/include/asm/kvm_host.h
+++ b/arch/arm64/include/asm/kvm_host.h
@@@ -509,39 -533,6 +509,42 @@@ static inline void kvm_init_host_cpu_co
  	cpu_ctxt->sys_regs[MPIDR_EL1] = read_cpuid_mpidr();
  }
  
++<<<<<<< HEAD
 +void __kvm_enable_ssbs(void);
 +
 +static inline void __cpu_init_hyp_mode(phys_addr_t pgd_ptr,
 +				       unsigned long hyp_stack_ptr,
 +				       unsigned long vector_ptr)
 +{
 +	/*
 +	 * Calculate the raw per-cpu offset without a translation from the
 +	 * kernel's mapping to the linear mapping, and store it in tpidr_el2
 +	 * so that we can use adr_l to access per-cpu variables in EL2.
 +	 */
 +	u64 tpidr_el2 = ((u64)this_cpu_ptr(&kvm_host_data) -
 +			 (u64)kvm_ksym_ref(kvm_host_data));
 +
 +	/*
 +	 * Call initialization code, and switch to the full blown HYP code.
 +	 * If the cpucaps haven't been finalized yet, something has gone very
 +	 * wrong, and hyp will crash and burn when it uses any
 +	 * cpus_have_const_cap() wrapper.
 +	 */
 +	BUG_ON(!static_branch_likely(&arm64_const_caps_ready));
 +	__kvm_call_hyp((void *)pgd_ptr, hyp_stack_ptr, vector_ptr, tpidr_el2);
 +
 +	/*
 +	 * Disabling SSBD on a non-VHE system requires us to enable SSBS
 +	 * at EL2.
 +	 */
 +	if (!has_vhe() && this_cpu_has_cap(ARM64_SSBS) &&
 +	    arm64_get_ssbd_state() == ARM64_SSBD_FORCE_DISABLE) {
 +		kvm_call_hyp(__kvm_enable_ssbs);
 +	}
 +}
 +
++=======
++>>>>>>> 71b3ec5f221b (KVM: arm64: Clean up cpu_init_hyp_mode())
  static inline bool kvm_arch_requires_vhe(void)
  {
  	/*
diff --git a/arch/arm64/include/asm/kvm_asm.h b/arch/arm64/include/asm/kvm_asm.h
index 2964ee144a7a..d08ab9ca4434 100644
--- a/arch/arm64/include/asm/kvm_asm.h
+++ b/arch/arm64/include/asm/kvm_asm.h
@@ -79,6 +79,8 @@ extern int kvm_vcpu_run_vhe(struct kvm_vcpu *vcpu);
 
 extern int __kvm_vcpu_run_nvhe(struct kvm_vcpu *vcpu);
 
+extern void __kvm_enable_ssbs(void);
+
 extern u64 __vgic_v3_get_ich_vtr_el2(void);
 extern u64 __vgic_v3_read_vmcr(void);
 extern void __vgic_v3_write_vmcr(u32 vmcr);
* Unmerged path arch/arm64/include/asm/kvm_host.h
diff --git a/virt/kvm/arm/arm.c b/virt/kvm/arm/arm.c
index a1a3d39bd66e..9b22420e0d53 100644
--- a/virt/kvm/arm/arm.c
+++ b/virt/kvm/arm/arm.c
@@ -1289,19 +1289,41 @@ static void cpu_init_hyp_mode(void)
 {
 	phys_addr_t pgd_ptr;
 	unsigned long hyp_stack_ptr;
-	unsigned long stack_page;
 	unsigned long vector_ptr;
+	unsigned long tpidr_el2;
 
 	/* Switch from the HYP stub to our own HYP init vector */
 	__hyp_set_vectors(kvm_get_idmap_vector());
 
+	/*
+	 * Calculate the raw per-cpu offset without a translation from the
+	 * kernel's mapping to the linear mapping, and store it in tpidr_el2
+	 * so that we can use adr_l to access per-cpu variables in EL2.
+	 */
+	tpidr_el2 = ((unsigned long)this_cpu_ptr(&kvm_host_data) -
+		     (unsigned long)kvm_ksym_ref(kvm_host_data));
+
 	pgd_ptr = kvm_mmu_get_httbr();
-	stack_page = __this_cpu_read(kvm_arm_hyp_stack_page);
-	hyp_stack_ptr = stack_page + PAGE_SIZE;
+	hyp_stack_ptr = __this_cpu_read(kvm_arm_hyp_stack_page) + PAGE_SIZE;
 	vector_ptr = (unsigned long)kvm_get_hyp_vector();
 
-	__cpu_init_hyp_mode(pgd_ptr, hyp_stack_ptr, vector_ptr);
-	__cpu_init_stage2();
+	/*
+	 * Call initialization code, and switch to the full blown HYP code.
+	 * If the cpucaps haven't been finalized yet, something has gone very
+	 * wrong, and hyp will crash and burn when it uses any
+	 * cpus_have_const_cap() wrapper.
+	 */
+	BUG_ON(!system_capabilities_finalized());
+	__kvm_call_hyp((void *)pgd_ptr, hyp_stack_ptr, vector_ptr, tpidr_el2);
+
+	/*
+	 * Disabling SSBD on a non-VHE system requires us to enable SSBS
+	 * at EL2.
+	 */
+	if (this_cpu_has_cap(ARM64_SSBS) &&
+	    arm64_get_ssbd_state() == ARM64_SSBD_FORCE_DISABLE) {
+		kvm_call_hyp(__kvm_enable_ssbs);
+	}
 }
 
 static void cpu_hyp_reset(void)
