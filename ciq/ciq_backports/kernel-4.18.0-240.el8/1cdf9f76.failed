nvmet: cleanups the loop in nvmet_async_events_process

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author David Milburn <dmilburn@redhat.com>
commit 1cdf9f7670a7d74e27177d5c390c2f8b3b9ba338
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/1cdf9f76.failed

Based-on-a-patch-by: Christoph Hellwig <hch@infradead.org>
	Tested-by: Yi Zhang <yi.zhang@redhat.com>
	Signed-off-by: David Milburn <dmilburn@redhat.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 1cdf9f7670a7d74e27177d5c390c2f8b3b9ba338)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/target/core.c
diff --cc drivers/nvme/target/core.c
index 95fd5ac37be9,6392bcd30bd7..000000000000
--- a/drivers/nvme/target/core.c
+++ b/drivers/nvme/target/core.c
@@@ -161,26 -134,45 +161,40 @@@ static void nvmet_async_event_work(stru
  	struct nvmet_async_event *aen;
  	struct nvmet_req *req;
  
++<<<<<<< HEAD
 +	while (1) {
 +		mutex_lock(&ctrl->lock);
 +		aen = list_first_entry_or_null(&ctrl->async_events,
 +				struct nvmet_async_event, entry);
 +		if (!aen || !ctrl->nr_async_event_cmds) {
 +			mutex_unlock(&ctrl->lock);
 +			return;
 +		}
 +
++=======
+ 	mutex_lock(&ctrl->lock);
+ 	while (ctrl->nr_async_event_cmds && !list_empty(&ctrl->async_events)) {
+ 		aen = list_first_entry(&ctrl->async_events,
+ 				       struct nvmet_async_event, entry);
++>>>>>>> 1cdf9f7670a7 (nvmet: cleanups the loop in nvmet_async_events_process)
  		req = ctrl->async_event_cmds[--ctrl->nr_async_event_cmds];
 -		if (status == 0)
 -			nvmet_set_result(req, nvmet_async_event_result(aen));
 +		nvmet_set_result(req, nvmet_async_event_result(aen));
  
  		list_del(&aen->entry);
  		kfree(aen);
  
  		mutex_unlock(&ctrl->lock);
++<<<<<<< HEAD
 +		nvmet_req_complete(req, 0);
++=======
+ 		trace_nvmet_async_event(ctrl, req->cqe->result.u32);
+ 		nvmet_req_complete(req, status);
+ 		mutex_lock(&ctrl->lock);
++>>>>>>> 1cdf9f7670a7 (nvmet: cleanups the loop in nvmet_async_events_process)
  	}
+ 	mutex_unlock(&ctrl->lock);
  }
  
 -static void nvmet_async_events_free(struct nvmet_ctrl *ctrl)
 -{
 -	struct nvmet_async_event *aen, *tmp;
 -
 -	mutex_lock(&ctrl->lock);
 -	list_for_each_entry_safe(aen, tmp, &ctrl->async_events, entry) {
 -		list_del(&aen->entry);
 -		kfree(aen);
 -	}
 -	mutex_unlock(&ctrl->lock);
 -}
 -
 -static void nvmet_async_event_work(struct work_struct *work)
 -{
 -	struct nvmet_ctrl *ctrl =
 -		container_of(work, struct nvmet_ctrl, async_event_work);
 -
 -	nvmet_async_events_process(ctrl, 0);
 -}
 -
  void nvmet_add_async_event(struct nvmet_ctrl *ctrl, u8 event_type,
  		u8 event_info, u8 log_page)
  {
* Unmerged path drivers/nvme/target/core.c
