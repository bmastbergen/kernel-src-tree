bpf: Fix build in minimal configurations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Alexei Starovoitov <ast@kernel.org>
commit ce27709b8162e5c501bc54292b8bf6bdecc4bbd4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ce27709b.failed

Some kconfigs can have BPF enabled without a single valid program type.
In such configurations the build will fail with:
./kernel/bpf/btf.c:3466:1: error: empty enum is invalid

Fix it by adding unused value to the enum.

	Reported-by: Randy Dunlap <rdunlap@infradead.org>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Randy Dunlap <rdunlap@infradead.org> # build-tested
Link: https://lore.kernel.org/bpf/20191128043508.2346723-1-ast@kernel.org
(cherry picked from commit ce27709b8162e5c501bc54292b8bf6bdecc4bbd4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/btf.c
diff --cc kernel/bpf/btf.c
index dc1f2324f36a,7d40da240891..000000000000
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@@ -3459,6 -3444,106 +3459,109 @@@ errout
  
  extern char __weak _binary__btf_vmlinux_bin_start[];
  extern char __weak _binary__btf_vmlinux_bin_end[];
++<<<<<<< HEAD
++=======
+ extern struct btf *btf_vmlinux;
+ 
+ #define BPF_MAP_TYPE(_id, _ops)
+ static union {
+ 	struct bpf_ctx_convert {
+ #define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \
+ 	prog_ctx_type _id##_prog; \
+ 	kern_ctx_type _id##_kern;
+ #include <linux/bpf_types.h>
+ #undef BPF_PROG_TYPE
+ 	} *__t;
+ 	/* 't' is written once under lock. Read many times. */
+ 	const struct btf_type *t;
+ } bpf_ctx_convert;
+ enum {
+ #define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \
+ 	__ctx_convert##_id,
+ #include <linux/bpf_types.h>
+ #undef BPF_PROG_TYPE
+ 	__ctx_convert_unused, /* to avoid empty enum in extreme .config */
+ };
+ static u8 bpf_ctx_convert_map[] = {
+ #define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type) \
+ 	[_id] = __ctx_convert##_id,
+ #include <linux/bpf_types.h>
+ #undef BPF_PROG_TYPE
+ };
+ #undef BPF_MAP_TYPE
+ 
+ static const struct btf_member *
+ btf_get_prog_ctx_type(struct bpf_verifier_log *log, struct btf *btf,
+ 		      const struct btf_type *t, enum bpf_prog_type prog_type)
+ {
+ 	const struct btf_type *conv_struct;
+ 	const struct btf_type *ctx_struct;
+ 	const struct btf_member *ctx_type;
+ 	const char *tname, *ctx_tname;
+ 
+ 	conv_struct = bpf_ctx_convert.t;
+ 	if (!conv_struct) {
+ 		bpf_log(log, "btf_vmlinux is malformed\n");
+ 		return NULL;
+ 	}
+ 	t = btf_type_by_id(btf, t->type);
+ 	while (btf_type_is_modifier(t))
+ 		t = btf_type_by_id(btf, t->type);
+ 	if (!btf_type_is_struct(t)) {
+ 		/* Only pointer to struct is supported for now.
+ 		 * That means that BPF_PROG_TYPE_TRACEPOINT with BTF
+ 		 * is not supported yet.
+ 		 * BPF_PROG_TYPE_RAW_TRACEPOINT is fine.
+ 		 */
+ 		bpf_log(log, "BPF program ctx type is not a struct\n");
+ 		return NULL;
+ 	}
+ 	tname = btf_name_by_offset(btf, t->name_off);
+ 	if (!tname) {
+ 		bpf_log(log, "BPF program ctx struct doesn't have a name\n");
+ 		return NULL;
+ 	}
+ 	/* prog_type is valid bpf program type. No need for bounds check. */
+ 	ctx_type = btf_type_member(conv_struct) + bpf_ctx_convert_map[prog_type] * 2;
+ 	/* ctx_struct is a pointer to prog_ctx_type in vmlinux.
+ 	 * Like 'struct __sk_buff'
+ 	 */
+ 	ctx_struct = btf_type_by_id(btf_vmlinux, ctx_type->type);
+ 	if (!ctx_struct)
+ 		/* should not happen */
+ 		return NULL;
+ 	ctx_tname = btf_name_by_offset(btf_vmlinux, ctx_struct->name_off);
+ 	if (!ctx_tname) {
+ 		/* should not happen */
+ 		bpf_log(log, "Please fix kernel include/linux/bpf_types.h\n");
+ 		return NULL;
+ 	}
+ 	/* only compare that prog's ctx type name is the same as
+ 	 * kernel expects. No need to compare field by field.
+ 	 * It's ok for bpf prog to do:
+ 	 * struct __sk_buff {};
+ 	 * int socket_filter_bpf_prog(struct __sk_buff *skb)
+ 	 * { // no fields of skb are ever used }
+ 	 */
+ 	if (strcmp(ctx_tname, tname))
+ 		return NULL;
+ 	return ctx_type;
+ }
+ 
+ static int btf_translate_to_vmlinux(struct bpf_verifier_log *log,
+ 				     struct btf *btf,
+ 				     const struct btf_type *t,
+ 				     enum bpf_prog_type prog_type)
+ {
+ 	const struct btf_member *prog_ctx_type, *kern_ctx_type;
+ 
+ 	prog_ctx_type = btf_get_prog_ctx_type(log, btf, t, prog_type);
+ 	if (!prog_ctx_type)
+ 		return -ENOENT;
+ 	kern_ctx_type = prog_ctx_type + 1;
+ 	return kern_ctx_type->type;
+ }
++>>>>>>> ce27709b8162 (bpf: Fix build in minimal configurations)
  
  struct btf *btf_parse_vmlinux(void)
  {
* Unmerged path kernel/bpf/btf.c
