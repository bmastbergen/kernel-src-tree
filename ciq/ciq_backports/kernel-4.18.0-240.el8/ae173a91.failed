selftests/bpf: support BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Stanislav Fomichev <sdf@google.com>
commit ae173a915785e55574c1fc54edf58b9b87b28c22
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ae173a91.failed

bpf_flow.c: exit early unless BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG is
passed in flags. Also, set ip_proto earlier, this makes sure we have
correct value with fragmented packets.

Add selftest cases to test ipv4/ipv6 fragments and skip eth_get_headlen
tests that don't have BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG flag.

eth_get_headlen calls flow dissector with
BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG flag so we can't run tests that
have different set of input flags against it.

v2:
 * sefltests -> selftests (Willem de Bruijn)
 * Reword a comment about eth_get_headlen flags (Song Liu)

	Acked-by: Petar Penkov <ppenkov@google.com>
	Acked-by: Willem de Bruijn <willemb@google.com>
	Acked-by: Song Liu <songliubraving@fb.com>
	Cc: Song Liu <songliubraving@fb.com>
	Cc: Willem de Bruijn <willemb@google.com>
	Cc: Petar Penkov <ppenkov@google.com>
	Signed-off-by: Stanislav Fomichev <sdf@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
(cherry picked from commit ae173a915785e55574c1fc54edf58b9b87b28c22)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/prog_tests/flow_dissector.c
diff --cc tools/testing/selftests/bpf/prog_tests/flow_dissector.c
index 716094eeb3a9,8e8c18aced9b..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/flow_dissector.c
+++ b/tools/testing/selftests/bpf/prog_tests/flow_dissector.c
@@@ -155,10 -159,104 +173,106 @@@ struct test tests[] = 
  			.addr_proto = ETH_P_IPV6,
  			.ip_proto = IPPROTO_TCP,
  			.n_proto = __bpf_constant_htons(ETH_P_IPV6),
 +			.sport = 80,
 +			.dport = 8080,
  		},
  	},
+ 	{
+ 		.name = "ipv4-frag",
+ 		.pkt.ipv4 = {
+ 			.eth.h_proto = __bpf_constant_htons(ETH_P_IP),
+ 			.iph.ihl = 5,
+ 			.iph.protocol = IPPROTO_TCP,
+ 			.iph.tot_len = __bpf_constant_htons(MAGIC_BYTES),
+ 			.iph.frag_off = __bpf_constant_htons(IP_MF),
+ 			.tcp.doff = 5,
+ 			.tcp.source = 80,
+ 			.tcp.dest = 8080,
+ 		},
+ 		.keys = {
+ 			.flags = BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG,
+ 			.nhoff = ETH_HLEN,
+ 			.thoff = ETH_HLEN + sizeof(struct iphdr),
+ 			.addr_proto = ETH_P_IP,
+ 			.ip_proto = IPPROTO_TCP,
+ 			.n_proto = __bpf_constant_htons(ETH_P_IP),
+ 			.is_frag = true,
+ 			.is_first_frag = true,
+ 			.sport = 80,
+ 			.dport = 8080,
+ 		},
+ 		.flags = BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG,
+ 	},
+ 	{
+ 		.name = "ipv4-no-frag",
+ 		.pkt.ipv4 = {
+ 			.eth.h_proto = __bpf_constant_htons(ETH_P_IP),
+ 			.iph.ihl = 5,
+ 			.iph.protocol = IPPROTO_TCP,
+ 			.iph.tot_len = __bpf_constant_htons(MAGIC_BYTES),
+ 			.iph.frag_off = __bpf_constant_htons(IP_MF),
+ 			.tcp.doff = 5,
+ 			.tcp.source = 80,
+ 			.tcp.dest = 8080,
+ 		},
+ 		.keys = {
+ 			.nhoff = ETH_HLEN,
+ 			.thoff = ETH_HLEN + sizeof(struct iphdr),
+ 			.addr_proto = ETH_P_IP,
+ 			.ip_proto = IPPROTO_TCP,
+ 			.n_proto = __bpf_constant_htons(ETH_P_IP),
+ 			.is_frag = true,
+ 			.is_first_frag = true,
+ 		},
+ 	},
+ 	{
+ 		.name = "ipv6-frag",
+ 		.pkt.ipv6_frag = {
+ 			.eth.h_proto = __bpf_constant_htons(ETH_P_IPV6),
+ 			.iph.nexthdr = IPPROTO_FRAGMENT,
+ 			.iph.payload_len = __bpf_constant_htons(MAGIC_BYTES),
+ 			.ipf.nexthdr = IPPROTO_TCP,
+ 			.tcp.doff = 5,
+ 			.tcp.source = 80,
+ 			.tcp.dest = 8080,
+ 		},
+ 		.keys = {
+ 			.flags = BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG,
+ 			.nhoff = ETH_HLEN,
+ 			.thoff = ETH_HLEN + sizeof(struct ipv6hdr) +
+ 				sizeof(struct frag_hdr),
+ 			.addr_proto = ETH_P_IPV6,
+ 			.ip_proto = IPPROTO_TCP,
+ 			.n_proto = __bpf_constant_htons(ETH_P_IPV6),
+ 			.is_frag = true,
+ 			.is_first_frag = true,
+ 			.sport = 80,
+ 			.dport = 8080,
+ 		},
+ 		.flags = BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG,
+ 	},
+ 	{
+ 		.name = "ipv6-no-frag",
+ 		.pkt.ipv6_frag = {
+ 			.eth.h_proto = __bpf_constant_htons(ETH_P_IPV6),
+ 			.iph.nexthdr = IPPROTO_FRAGMENT,
+ 			.iph.payload_len = __bpf_constant_htons(MAGIC_BYTES),
+ 			.ipf.nexthdr = IPPROTO_TCP,
+ 			.tcp.doff = 5,
+ 			.tcp.source = 80,
+ 			.tcp.dest = 8080,
+ 		},
+ 		.keys = {
+ 			.nhoff = ETH_HLEN,
+ 			.thoff = ETH_HLEN + sizeof(struct ipv6hdr) +
+ 				sizeof(struct frag_hdr),
+ 			.addr_proto = ETH_P_IPV6,
+ 			.ip_proto = IPPROTO_TCP,
+ 			.n_proto = __bpf_constant_htons(ETH_P_IPV6),
+ 			.is_frag = true,
+ 			.is_first_frag = true,
+ 		},
+ 	},
  };
  
  static int create_tap(const char *ifname)
@@@ -267,10 -372,19 +388,24 @@@ void test_flow_dissector(void
  	CHECK(err, "ifup", "err %d errno %d\n", err, errno);
  
  	for (i = 0; i < ARRAY_SIZE(tests); i++) {
- 		struct bpf_flow_keys flow_keys = {};
+ 		/* Keep in sync with 'flags' from eth_get_headlen. */
+ 		__u32 eth_get_headlen_flags =
+ 			BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG;
  		struct bpf_prog_test_run_attr tattr = {};
++<<<<<<< HEAD
 +		__u32 key = (__u32)(tests[i].keys.sport) << 16 |
 +			    tests[i].keys.dport;
++=======
+ 		struct bpf_flow_keys flow_keys = {};
+ 		__u32 key = 0;
++>>>>>>> ae173a915785 (selftests/bpf: support BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG)
+ 
+ 		/* For skb-less case we can't pass input flags; run
+ 		 * only the tests that have a matching set of flags.
+ 		 */
+ 
+ 		if (tests[i].flags != eth_get_headlen_flags)
+ 			continue;
  
  		err = tx_tap(tap_fd, &tests[i].pkt, sizeof(tests[i].pkt));
  		CHECK(err < 0, "tx_tap", "err %d errno %d\n", err, errno);
* Unmerged path tools/testing/selftests/bpf/prog_tests/flow_dissector.c
diff --git a/tools/testing/selftests/bpf/progs/bpf_flow.c b/tools/testing/selftests/bpf/progs/bpf_flow.c
index 12a50a707149..7a2722ef47db 100644
--- a/tools/testing/selftests/bpf/progs/bpf_flow.c
+++ b/tools/testing/selftests/bpf/progs/bpf_flow.c
@@ -152,7 +152,6 @@ static __always_inline int parse_ip_proto(struct __sk_buff *skb, __u8 proto)
 	struct tcphdr *tcp, _tcp;
 	struct udphdr *udp, _udp;
 
-	keys->ip_proto = proto;
 	switch (proto) {
 	case IPPROTO_ICMP:
 		icmp = bpf_flow_dissect_get_header(skb, sizeof(*icmp), &_icmp);
@@ -230,7 +229,6 @@ static __always_inline int parse_ipv6_proto(struct __sk_buff *skb, __u8 nexthdr)
 {
 	struct bpf_flow_keys *keys = skb->flow_keys;
 
-	keys->ip_proto = nexthdr;
 	switch (nexthdr) {
 	case IPPROTO_HOPOPTS:
 	case IPPROTO_DSTOPTS:
@@ -265,6 +263,7 @@ PROG(IP)(struct __sk_buff *skb)
 	keys->addr_proto = ETH_P_IP;
 	keys->ipv4_src = iph->saddr;
 	keys->ipv4_dst = iph->daddr;
+	keys->ip_proto = iph->protocol;
 
 	keys->thoff += iph->ihl << 2;
 	if (data + keys->thoff > data_end)
@@ -272,13 +271,20 @@ PROG(IP)(struct __sk_buff *skb)
 
 	if (iph->frag_off & bpf_htons(IP_MF | IP_OFFSET)) {
 		keys->is_frag = true;
-		if (iph->frag_off & bpf_htons(IP_OFFSET))
+		if (iph->frag_off & bpf_htons(IP_OFFSET)) {
 			/* From second fragment on, packets do not have headers
 			 * we can parse.
 			 */
 			done = true;
-		else
+		} else {
 			keys->is_first_frag = true;
+			/* No need to parse fragmented packet unless
+			 * explicitly asked for.
+			 */
+			if (!(keys->flags &
+			      BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG))
+				done = true;
+		}
 	}
 
 	if (done)
@@ -300,6 +306,7 @@ PROG(IPV6)(struct __sk_buff *skb)
 	memcpy(&keys->ipv6_src, &ip6h->saddr, 2*sizeof(ip6h->saddr));
 
 	keys->thoff += sizeof(struct ipv6hdr);
+	keys->ip_proto = ip6h->nexthdr;
 
 	return parse_ipv6_proto(skb, ip6h->nexthdr);
 }
@@ -316,7 +323,8 @@ PROG(IPV6OP)(struct __sk_buff *skb)
 	/* hlen is in 8-octets and does not include the first 8 bytes
 	 * of the header
 	 */
-	skb->flow_keys->thoff += (1 + ip6h->hdrlen) << 3;
+	keys->thoff += (1 + ip6h->hdrlen) << 3;
+	keys->ip_proto = ip6h->nexthdr;
 
 	return parse_ipv6_proto(skb, ip6h->nexthdr);
 }
@@ -332,9 +340,18 @@ PROG(IPV6FR)(struct __sk_buff *skb)
 
 	keys->thoff += sizeof(*fragh);
 	keys->is_frag = true;
-	if (!(fragh->frag_off & bpf_htons(IP6_OFFSET)))
+	keys->ip_proto = fragh->nexthdr;
+
+	if (!(fragh->frag_off & bpf_htons(IP6_OFFSET))) {
 		keys->is_first_frag = true;
 
+		/* No need to parse fragmented packet unless
+		 * explicitly asked for.
+		 */
+		if (!(keys->flags & BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG))
+			return export_flow_keys(keys, BPF_OK);
+	}
+
 	return parse_ipv6_proto(skb, fragh->nexthdr);
 }
 
