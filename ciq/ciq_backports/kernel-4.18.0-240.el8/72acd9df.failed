iommu: Move iommu_fwspec to struct dev_iommu

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Joerg Roedel <jroedel@suse.de>
commit 72acd9df18f12420001f901493c54b7364f34d60
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/72acd9df.failed

Move the iommu_fwspec pointer in struct device into struct dev_iommu.
This is a step in the effort to reduce the iommu related pointers in
struct device to one.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
	Tested-by: Will Deacon <will@kernel.org> # arm-smmu
	Reviewed-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Link: https://lore.kernel.org/r/20200326150841.10083-7-joro@8bytes.org
(cherry picked from commit 72acd9df18f12420001f901493c54b7364f34d60)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
#	include/linux/device.h
#	include/linux/iommu.h
diff --cc drivers/iommu/iommu.c
index be043063e8fb,2b471419e26c..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -2096,7 -2405,11 +2096,15 @@@ int iommu_fwspec_init(struct device *de
  	if (fwspec)
  		return ops == fwspec->ops ? 0 : -EINVAL;
  
++<<<<<<< HEAD
 +	fwspec = kzalloc(sizeof(*fwspec), GFP_KERNEL);
++=======
+ 	if (!dev_iommu_get(dev))
+ 		return -ENOMEM;
+ 
+ 	/* Preallocate for the overwhelmingly common case of 1 ID */
+ 	fwspec = kzalloc(struct_size(fwspec, ids, 1), GFP_KERNEL);
++>>>>>>> 72acd9df18f1 (iommu: Move iommu_fwspec to struct dev_iommu)
  	if (!fwspec)
  		return -ENOMEM;
  
diff --cc include/linux/device.h
index a7e07e1be4e6,9610d0accd88..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -41,321 -42,8 +41,320 @@@ struct device_node
  struct fwnode_handle;
  struct iommu_ops;
  struct iommu_group;
- struct iommu_fwspec;
  struct dev_pin_info;
 -struct dev_iommu;
 +struct iommu_param;
 +
 +struct bus_attribute {
 +	struct attribute	attr;
 +	ssize_t (*show)(struct bus_type *bus, char *buf);
 +	ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);
 +};
 +
 +#define BUS_ATTR(_name, _mode, _show, _store)	\
 +	struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store)
 +#define BUS_ATTR_RW(_name) \
 +	struct bus_attribute bus_attr_##_name = __ATTR_RW(_name)
 +#define BUS_ATTR_RO(_name) \
 +	struct bus_attribute bus_attr_##_name = __ATTR_RO(_name)
 +#define BUS_ATTR_WO(_name) \
 +	struct bus_attribute bus_attr_##_name = __ATTR_WO(_name)
 +
 +extern int __must_check bus_create_file(struct bus_type *,
 +					struct bus_attribute *);
 +extern void bus_remove_file(struct bus_type *, struct bus_attribute *);
 +
 +/**
 + * struct bus_type - The bus type of the device
 + *
 + * @name:	The name of the bus.
 + * @dev_name:	Used for subsystems to enumerate devices like ("foo%u", dev->id).
 + * @dev_root:	Default device to use as the parent.
 + * @bus_groups:	Default attributes of the bus.
 + * @dev_groups:	Default attributes of the devices on the bus.
 + * @drv_groups: Default attributes of the device drivers on the bus.
 + * @match:	Called, perhaps multiple times, whenever a new device or driver
 + *		is added for this bus. It should return a positive value if the
 + *		given device can be handled by the given driver and zero
 + *		otherwise. It may also return error code if determining that
 + *		the driver supports the device is not possible. In case of
 + *		-EPROBE_DEFER it will queue the device for deferred probing.
 + * @uevent:	Called when a device is added, removed, or a few other things
 + *		that generate uevents to add the environment variables.
 + * @probe:	Called when a new device or driver add to this bus, and callback
 + *		the specific driver's probe to initial the matched device.
 + * @remove:	Called when a device removed from this bus.
 + * @shutdown:	Called at shut-down time to quiesce the device.
 + *
 + * @online:	Called to put the device back online (after offlining it).
 + * @offline:	Called to put the device offline for hot-removal. May fail.
 + *
 + * @suspend:	Called when a device on this bus wants to go to sleep mode.
 + * @resume:	Called to bring a device on this bus out of sleep mode.
 + * @num_vf:	Called to find out how many virtual functions a device on this
 + *		bus supports.
 + * @dma_configure:	Called to setup DMA configuration on a device on
 + *			this bus.
 + * @pm:		Power management operations of this bus, callback the specific
 + *		device driver's pm-ops.
 + * @iommu_ops:  IOMMU specific operations for this bus, used to attach IOMMU
 + *              driver implementations to a bus and allow the driver to do
 + *              bus-specific setup
 + * @p:		The private data of the driver core, only the driver core can
 + *		touch this.
 + * @lock_key:	Lock class key for use by the lock validator
 + * @need_parent_lock:	When probing or removing a device on this bus, the
 + *			device core should lock the device's parent.
 + *
 + * A bus is a channel between the processor and one or more devices. For the
 + * purposes of the device model, all devices are connected via a bus, even if
 + * it is an internal, virtual, "platform" bus. Buses can plug into each other.
 + * A USB controller is usually a PCI device, for example. The device model
 + * represents the actual connections between buses and the devices they control.
 + * A bus is represented by the bus_type structure. It contains the name, the
 + * default attributes, the bus' methods, PM operations, and the driver core's
 + * private data.
 + */
 +struct bus_type {
 +	const char		*name;
 +	const char		*dev_name;
 +	struct device		*dev_root;
 +	const struct attribute_group **bus_groups;
 +	const struct attribute_group **dev_groups;
 +	const struct attribute_group **drv_groups;
 +
 +	int (*match)(struct device *dev, struct device_driver *drv);
 +	int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
 +	int (*probe)(struct device *dev);
 +	int (*remove)(struct device *dev);
 +	void (*shutdown)(struct device *dev);
 +
 +	int (*online)(struct device *dev);
 +	int (*offline)(struct device *dev);
 +
 +	int (*suspend)(struct device *dev, pm_message_t state);
 +	int (*resume)(struct device *dev);
 +
 +	int (*num_vf)(struct device *dev);
 +
 +	int (*dma_configure)(struct device *dev);
 +
 +	const struct dev_pm_ops *pm;
 +
 +	const struct iommu_ops *iommu_ops;
 +
 +	struct subsys_private *p;
 +	struct lock_class_key lock_key;
 +
 +	bool need_parent_lock;
 +};
 +
 +extern int __must_check bus_register(struct bus_type *bus);
 +
 +extern void bus_unregister(struct bus_type *bus);
 +
 +extern int __must_check bus_rescan_devices(struct bus_type *bus);
 +
 +/* iterator helpers for buses */
 +struct subsys_dev_iter {
 +	struct klist_iter		ki;
 +	const struct device_type	*type;
 +};
 +void subsys_dev_iter_init(struct subsys_dev_iter *iter,
 +			 struct bus_type *subsys,
 +			 struct device *start,
 +			 const struct device_type *type);
 +struct device *subsys_dev_iter_next(struct subsys_dev_iter *iter);
 +void subsys_dev_iter_exit(struct subsys_dev_iter *iter);
 +
 +int bus_for_each_dev(struct bus_type *bus, struct device *start, void *data,
 +		     int (*fn)(struct device *dev, void *data));
 +struct device *bus_find_device(struct bus_type *bus, struct device *start,
 +			       const void *data,
 +			       int (*match)(struct device *dev, const void *data));
 +struct device *bus_find_device_by_name(struct bus_type *bus,
 +				       struct device *start,
 +				       const char *name);
 +struct device *subsys_find_device_by_id(struct bus_type *bus, unsigned int id,
 +					struct device *hint);
 +int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,
 +		     void *data, int (*fn)(struct device_driver *, void *));
 +void bus_sort_breadthfirst(struct bus_type *bus,
 +			   int (*compare)(const struct device *a,
 +					  const struct device *b));
 +/*
 + * Bus notifiers: Get notified of addition/removal of devices
 + * and binding/unbinding of drivers to devices.
 + * In the long run, it should be a replacement for the platform
 + * notify hooks.
 + */
 +struct notifier_block;
 +
 +extern int bus_register_notifier(struct bus_type *bus,
 +				 struct notifier_block *nb);
 +extern int bus_unregister_notifier(struct bus_type *bus,
 +				   struct notifier_block *nb);
 +
 +/* All 4 notifers below get called with the target struct device *
 + * as an argument. Note that those functions are likely to be called
 + * with the device lock held in the core, so be careful.
 + */
 +#define BUS_NOTIFY_ADD_DEVICE		0x00000001 /* device added */
 +#define BUS_NOTIFY_DEL_DEVICE		0x00000002 /* device to be removed */
 +#define BUS_NOTIFY_REMOVED_DEVICE	0x00000003 /* device removed */
 +#define BUS_NOTIFY_BIND_DRIVER		0x00000004 /* driver about to be
 +						      bound */
 +#define BUS_NOTIFY_BOUND_DRIVER		0x00000005 /* driver bound to device */
 +#define BUS_NOTIFY_UNBIND_DRIVER	0x00000006 /* driver about to be
 +						      unbound */
 +#define BUS_NOTIFY_UNBOUND_DRIVER	0x00000007 /* driver is unbound
 +						      from the device */
 +#define BUS_NOTIFY_DRIVER_NOT_BOUND	0x00000008 /* driver fails to be bound */
 +
 +extern struct kset *bus_get_kset(struct bus_type *bus);
 +extern struct klist *bus_get_device_klist(struct bus_type *bus);
 +
 +/**
 + * enum probe_type - device driver probe type to try
 + *	Device drivers may opt in for special handling of their
 + *	respective probe routines. This tells the core what to
 + *	expect and prefer.
 + *
 + * @PROBE_DEFAULT_STRATEGY: Used by drivers that work equally well
 + *	whether probed synchronously or asynchronously.
 + * @PROBE_PREFER_ASYNCHRONOUS: Drivers for "slow" devices which
 + *	probing order is not essential for booting the system may
 + *	opt into executing their probes asynchronously.
 + * @PROBE_FORCE_SYNCHRONOUS: Use this to annotate drivers that need
 + *	their probe routines to run synchronously with driver and
 + *	device registration (with the exception of -EPROBE_DEFER
 + *	handling - re-probing always ends up being done asynchronously).
 + *
 + * Note that the end goal is to switch the kernel to use asynchronous
 + * probing by default, so annotating drivers with
 + * %PROBE_PREFER_ASYNCHRONOUS is a temporary measure that allows us
 + * to speed up boot process while we are validating the rest of the
 + * drivers.
 + */
 +enum probe_type {
 +	PROBE_DEFAULT_STRATEGY,
 +	PROBE_PREFER_ASYNCHRONOUS,
 +	PROBE_FORCE_SYNCHRONOUS,
 +};
 +
 +/**
 + * struct device_driver_rh - Red Hat KABI extension struct
 + */
 +struct device_driver_rh {
 +};
 +
 +/**
 + * struct device_driver - The basic device driver structure
 + * @name:	Name of the device driver.
 + * @bus:	The bus which the device of this driver belongs to.
 + * @owner:	The module owner.
 + * @mod_name:	Used for built-in modules.
 + * @suppress_bind_attrs: Disables bind/unbind via sysfs.
 + * @probe_type:	Type of the probe (synchronous or asynchronous) to use.
 + * @of_match_table: The open firmware table.
 + * @acpi_match_table: The ACPI match table.
 + * @probe:	Called to query the existence of a specific device,
 + *		whether this driver can work with it, and bind the driver
 + *		to a specific device.
 + * @remove:	Called when the device is removed from the system to
 + *		unbind a device from this driver.
 + * @shutdown:	Called at shut-down time to quiesce the device.
 + * @suspend:	Called to put the device to sleep mode. Usually to a
 + *		low power state.
 + * @resume:	Called to bring a device from sleep mode.
 + * @groups:	Default attributes that get created by the driver core
 + *		automatically.
 + * @pm:		Power management operations of the device which matched
 + *		this driver.
 + * @coredump:	Called when sysfs entry is written to. The device driver
 + *		is expected to call the dev_coredump API resulting in a
 + *		uevent.
 + * @p:		Driver core's private data, no one other than the driver
 + *		core can touch this.
 + *
 + * The device driver-model tracks all of the drivers known to the system.
 + * The main reason for this tracking is to enable the driver core to match
 + * up drivers with new devices. Once drivers are known objects within the
 + * system, however, a number of other things become possible. Device drivers
 + * can export information and configuration variables that are independent
 + * of any specific device.
 + */
 +struct device_driver {
 +	const char		*name;
 +	struct bus_type		*bus;
 +
 +	struct module		*owner;
 +	const char		*mod_name;	/* used for built-in modules */
 +
 +	bool suppress_bind_attrs;	/* disables bind/unbind via sysfs */
 +	enum probe_type probe_type;
 +
 +	const struct of_device_id	*of_match_table;
 +	const struct acpi_device_id	*acpi_match_table;
 +
 +	int (*probe) (struct device *dev);
 +	int (*remove) (struct device *dev);
 +	void (*shutdown) (struct device *dev);
 +	int (*suspend) (struct device *dev, pm_message_t state);
 +	int (*resume) (struct device *dev);
 +	const struct attribute_group **groups;
 +
 +	const struct dev_pm_ops *pm;
 +	void (*coredump) (struct device *dev);
 +
 +	struct driver_private *p;
 +	RH_KABI_RESERVE(1)
 +	RH_KABI_RESERVE(2)
 +	RH_KABI_RESERVE(3)
 +	RH_KABI_RESERVE(4)
 +	RH_KABI_SIZE_AND_EXTEND_PTR(device_driver);
 +};
 +
 +
 +extern int __must_check driver_register(struct device_driver *drv);
 +extern void driver_unregister(struct device_driver *drv);
 +
 +extern struct device_driver *driver_find(const char *name,
 +					 struct bus_type *bus);
 +extern int driver_probe_done(void);
 +extern void wait_for_device_probe(void);
 +
 +/* sysfs interface for exporting driver attributes */
 +
 +struct driver_attribute {
 +	struct attribute attr;
 +	ssize_t (*show)(struct device_driver *driver, char *buf);
 +	ssize_t (*store)(struct device_driver *driver, const char *buf,
 +			 size_t count);
 +};
 +
 +#define DRIVER_ATTR_RW(_name) \
 +	struct driver_attribute driver_attr_##_name = __ATTR_RW(_name)
 +#define DRIVER_ATTR_RO(_name) \
 +	struct driver_attribute driver_attr_##_name = __ATTR_RO(_name)
 +#define DRIVER_ATTR_WO(_name) \
 +	struct driver_attribute driver_attr_##_name = __ATTR_WO(_name)
 +
 +extern int __must_check driver_create_file(struct device_driver *driver,
 +					const struct driver_attribute *attr);
 +extern void driver_remove_file(struct device_driver *driver,
 +			       const struct driver_attribute *attr);
 +
 +extern int __must_check driver_for_each_device(struct device_driver *drv,
 +					       struct device *start,
 +					       void *data,
 +					       int (*fn)(struct device *dev,
 +							 void *));
 +struct device *driver_find_device(struct device_driver *drv,
 +				  struct device *start, void *data,
 +				  int (*match)(struct device *dev, void *data));
 +
 +int driver_deferred_probe_check_state(struct device *dev);
 +int driver_deferred_probe_check_state_continue(struct device *dev);
  
  /**
   * struct subsys_interface - interfaces to device functions
@@@ -953,8 -512,7 +952,12 @@@ struct device_extended_rh 
   * 		gone away. This should be set by the allocator of the
   * 		device (i.e. the bus driver that discovered the device).
   * @iommu_group: IOMMU group the device belongs to.
++<<<<<<< HEAD
 + * @iommu_fwspec: IOMMU-specific properties supplied by firmware.
 + * @iommu_param: Per device generic IOMMU runtime data
++=======
+  * @iommu:	Per device generic IOMMU runtime data
++>>>>>>> 72acd9df18f1 (iommu: Move iommu_fwspec to struct dev_iommu)
   *
   * @offline_disabled: If set, the device is permanently online.
   * @offline:	Set after successful invocation of bus type's .offline().
@@@ -1046,10 -611,8 +1049,14 @@@ struct device 
  
  	void	(*release)(struct device *dev);
  	struct iommu_group	*iommu_group;
++<<<<<<< HEAD
 +	struct iommu_fwspec	*iommu_fwspec;
 +	struct iommu_param	*iommu_param;
++=======
+ 	struct dev_iommu	*iommu;
++>>>>>>> 72acd9df18f1 (iommu: Move iommu_fwspec to struct dev_iommu)
  
 +	/* RHEL8 kabi note: Total of 64-bits of bool can be defined. */
  	bool			offline_disabled:1;
  	bool			offline:1;
  	bool			of_node_reused:1;
diff --cc include/linux/iommu.h
index 8e26403172ec,d031ddc0596b..000000000000
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@@ -343,6 -336,49 +343,52 @@@ struct iommu_device 
  	struct device *dev;
  };
  
++<<<<<<< HEAD
++=======
+ /**
+  * struct iommu_fault_event - Generic fault event
+  *
+  * Can represent recoverable faults such as a page requests or
+  * unrecoverable faults such as DMA or IRQ remapping faults.
+  *
+  * @fault: fault descriptor
+  * @list: pending fault event list, used for tracking responses
+  */
+ struct iommu_fault_event {
+ 	struct iommu_fault fault;
+ 	struct list_head list;
+ };
+ 
+ /**
+  * struct iommu_fault_param - per-device IOMMU fault data
+  * @handler: Callback function to handle IOMMU faults at device level
+  * @data: handler private data
+  * @faults: holds the pending faults which needs response
+  * @lock: protect pending faults list
+  */
+ struct iommu_fault_param {
+ 	iommu_dev_fault_handler_t handler;
+ 	void *data;
+ 	struct list_head faults;
+ 	struct mutex lock;
+ };
+ 
+ /**
+  * struct dev_iommu - Collection of per-device IOMMU data
+  *
+  * @fault_param: IOMMU detected device fault reporting data
+  * @fwspec:	 IOMMU fwspec data
+  *
+  * TODO: migrate other per device data pointers under iommu_dev_data, e.g.
+  *	struct iommu_group	*iommu_group;
+  */
+ struct dev_iommu {
+ 	struct mutex lock;
+ 	struct iommu_fault_param	*fault_param;
+ 	struct iommu_fwspec		*fwspec;
+ };
+ 
++>>>>>>> 72acd9df18f1 (iommu: Move iommu_fwspec to struct dev_iommu)
  int  iommu_device_register(struct iommu_device *iommu);
  void iommu_device_unregister(struct iommu_device *iommu);
  int  iommu_device_sysfs_add(struct iommu_device *iommu,
* Unmerged path drivers/iommu/iommu.c
* Unmerged path include/linux/device.h
* Unmerged path include/linux/iommu.h
