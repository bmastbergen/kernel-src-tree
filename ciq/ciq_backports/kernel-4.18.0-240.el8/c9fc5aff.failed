gpio: Pass mask and size with the init_valid_mask()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Linus Walleij <linus.walleij@linaro.org>
commit c9fc5aff217267a9ef3a76450760534488870c69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c9fc5aff.failed

It is more helpful for drivers to have the affected fields
directly available when we use the callback to set up the
valid mask. Change this and switch over the only user
(MSM) to use the passed parameters. If we do this we can
also move the mask out of publicly visible struct fields.

	Cc: Stephen Boyd <swboyd@chromium.org>
	Cc: Bjorn Andersson <bjorn.andersson@linaro.org>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
Link: https://lore.kernel.org/r/20190819084904.30027-1-linus.walleij@linaro.or
	Reviewed-by: Stephen Boyd <swboyd@chromium.org>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit c9fc5aff217267a9ef3a76450760534488870c69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pinctrl/qcom/pinctrl-msm.c
diff --cc drivers/pinctrl/qcom/pinctrl-msm.c
index d4d949b548bb,a5d8f75da4a7..000000000000
--- a/drivers/pinctrl/qcom/pinctrl-msm.c
+++ b/drivers/pinctrl/qcom/pinctrl-msm.c
@@@ -558,14 -593,30 +558,36 @@@ static void msm_gpio_dbg_show(struct se
  #define msm_gpio_dbg_show NULL
  #endif
  
- static int msm_gpio_init_valid_mask(struct gpio_chip *chip)
+ static int msm_gpio_init_valid_mask(struct gpio_chip *gc,
+ 				    unsigned long *valid_mask,
+ 				    unsigned int ngpios)
  {
- 	struct msm_pinctrl *pctrl = gpiochip_get_data(chip);
+ 	struct msm_pinctrl *pctrl = gpiochip_get_data(gc);
  	int ret;
  	unsigned int len, i;
++<<<<<<< HEAD
 +	unsigned int max_gpios = pctrl->soc->ngpios;
 +	u16 *tmp;
 +
++=======
+ 	const int *reserved = pctrl->soc->reserved_gpios;
+ 	u16 *tmp;
+ 
+ 	/* Driver provided reserved list overrides DT and ACPI */
+ 	if (reserved) {
+ 		bitmap_fill(valid_mask, ngpios);
+ 		for (i = 0; reserved[i] >= 0; i++) {
+ 			if (i >= ngpios || reserved[i] >= ngpios) {
+ 				dev_err(pctrl->dev, "invalid list of reserved GPIOs\n");
+ 				return -EINVAL;
+ 			}
+ 			clear_bit(reserved[i], valid_mask);
+ 		}
+ 
+ 		return 0;
+ 	}
+ 
++>>>>>>> c9fc5aff2172 (gpio: Pass mask and size with the init_valid_mask())
  	/* The number of GPIOs in the ACPI tables */
  	len = ret = device_property_read_u16_array(pctrl->dev, "gpios", NULL,
  						   0);
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index e17af7d89361..73452de97cc4 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -381,10 +381,12 @@ static int gpiochip_alloc_valid_mask(struct gpio_chip *gpiochip)
 	return 0;
 }
 
-static int gpiochip_init_valid_mask(struct gpio_chip *gpiochip)
+static int gpiochip_init_valid_mask(struct gpio_chip *gc)
 {
-	if (gpiochip->init_valid_mask)
-		return gpiochip->init_valid_mask(gpiochip);
+	if (gc->init_valid_mask)
+		return gc->init_valid_mask(gc,
+					   gc->valid_mask,
+					   gc->ngpio);
 
 	return 0;
 }
* Unmerged path drivers/pinctrl/qcom/pinctrl-msm.c
diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 07332890d9f4..96957a0c00b0 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -276,7 +276,9 @@ struct gpio_chip {
 	void			(*dbg_show)(struct seq_file *s,
 						struct gpio_chip *chip);
 
-	int			(*init_valid_mask)(struct gpio_chip *chip);
+	int			(*init_valid_mask)(struct gpio_chip *chip,
+						   unsigned long *valid_mask,
+						   unsigned int ngpios);
 
 	int			base;
 	u16			ngpio;
