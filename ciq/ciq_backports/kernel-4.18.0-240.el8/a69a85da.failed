netfilter: nft_payload: fix missing check for matching length in offloads

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author wenxu <wenxu@ucloud.cn>
commit a69a85da458f79088c38a38db034a4d64d9c32c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a69a85da.failed

Payload offload rule should also check the length of the match.
Moreover, check for unsupported link-layer fields:

 nft --debug=netlink add rule firewall zones vlan id 100
 ...
 [ payload load 2b @ link header + 0 => reg 1 ]

this loads 2byte base on ll header and offset 0.

This also fixes unsupported raw payload match.

Fixes: 92ad6325cb89 ("netfilter: nf_tables: add hardware offload support")
	Signed-off-by: wenxu <wenxu@ucloud.cn>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit a69a85da458f79088c38a38db034a4d64d9c32c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_payload.c
diff --cc net/netfilter/nft_payload.c
index e110b0ebbf58,5cb2d8908d2a..000000000000
--- a/net/netfilter/nft_payload.c
+++ b/net/netfilter/nft_payload.c
@@@ -153,6 -153,226 +153,229 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int nft_payload_offload_ll(struct nft_offload_ctx *ctx,
+ 				  struct nft_flow_rule *flow,
+ 				  const struct nft_payload *priv)
+ {
+ 	struct nft_offload_reg *reg = &ctx->regs[priv->dreg];
+ 
+ 	switch (priv->offset) {
+ 	case offsetof(struct ethhdr, h_source):
+ 		if (priv->len != ETH_ALEN)
+ 			return -EOPNOTSUPP;
+ 
+ 		NFT_OFFLOAD_MATCH(FLOW_DISSECTOR_KEY_ETH_ADDRS, eth_addrs,
+ 				  src, ETH_ALEN, reg);
+ 		break;
+ 	case offsetof(struct ethhdr, h_dest):
+ 		if (priv->len != ETH_ALEN)
+ 			return -EOPNOTSUPP;
+ 
+ 		NFT_OFFLOAD_MATCH(FLOW_DISSECTOR_KEY_ETH_ADDRS, eth_addrs,
+ 				  dst, ETH_ALEN, reg);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int nft_payload_offload_ip(struct nft_offload_ctx *ctx,
+ 				  struct nft_flow_rule *flow,
+ 				  const struct nft_payload *priv)
+ {
+ 	struct nft_offload_reg *reg = &ctx->regs[priv->dreg];
+ 
+ 	switch (priv->offset) {
+ 	case offsetof(struct iphdr, saddr):
+ 		if (priv->len != sizeof(struct in_addr))
+ 			return -EOPNOTSUPP;
+ 
+ 		NFT_OFFLOAD_MATCH(FLOW_DISSECTOR_KEY_IPV4_ADDRS, ipv4, src,
+ 				  sizeof(struct in_addr), reg);
+ 		break;
+ 	case offsetof(struct iphdr, daddr):
+ 		if (priv->len != sizeof(struct in_addr))
+ 			return -EOPNOTSUPP;
+ 
+ 		NFT_OFFLOAD_MATCH(FLOW_DISSECTOR_KEY_IPV4_ADDRS, ipv4, dst,
+ 				  sizeof(struct in_addr), reg);
+ 		break;
+ 	case offsetof(struct iphdr, protocol):
+ 		if (priv->len != sizeof(__u8))
+ 			return -EOPNOTSUPP;
+ 
+ 		NFT_OFFLOAD_MATCH(FLOW_DISSECTOR_KEY_BASIC, basic, ip_proto,
+ 				  sizeof(__u8), reg);
+ 		nft_offload_set_dependency(ctx, NFT_OFFLOAD_DEP_TRANSPORT);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int nft_payload_offload_ip6(struct nft_offload_ctx *ctx,
+ 				  struct nft_flow_rule *flow,
+ 				  const struct nft_payload *priv)
+ {
+ 	struct nft_offload_reg *reg = &ctx->regs[priv->dreg];
+ 
+ 	switch (priv->offset) {
+ 	case offsetof(struct ipv6hdr, saddr):
+ 		if (priv->len != sizeof(struct in6_addr))
+ 			return -EOPNOTSUPP;
+ 
+ 		NFT_OFFLOAD_MATCH(FLOW_DISSECTOR_KEY_IPV6_ADDRS, ipv6, src,
+ 				  sizeof(struct in6_addr), reg);
+ 		break;
+ 	case offsetof(struct ipv6hdr, daddr):
+ 		if (priv->len != sizeof(struct in6_addr))
+ 			return -EOPNOTSUPP;
+ 
+ 		NFT_OFFLOAD_MATCH(FLOW_DISSECTOR_KEY_IPV6_ADDRS, ipv6, dst,
+ 				  sizeof(struct in6_addr), reg);
+ 		break;
+ 	case offsetof(struct ipv6hdr, nexthdr):
+ 		if (priv->len != sizeof(__u8))
+ 			return -EOPNOTSUPP;
+ 
+ 		NFT_OFFLOAD_MATCH(FLOW_DISSECTOR_KEY_BASIC, basic, ip_proto,
+ 				  sizeof(__u8), reg);
+ 		nft_offload_set_dependency(ctx, NFT_OFFLOAD_DEP_TRANSPORT);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int nft_payload_offload_nh(struct nft_offload_ctx *ctx,
+ 				  struct nft_flow_rule *flow,
+ 				  const struct nft_payload *priv)
+ {
+ 	int err;
+ 
+ 	switch (ctx->dep.l3num) {
+ 	case htons(ETH_P_IP):
+ 		err = nft_payload_offload_ip(ctx, flow, priv);
+ 		break;
+ 	case htons(ETH_P_IPV6):
+ 		err = nft_payload_offload_ip6(ctx, flow, priv);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static int nft_payload_offload_tcp(struct nft_offload_ctx *ctx,
+ 				   struct nft_flow_rule *flow,
+ 				   const struct nft_payload *priv)
+ {
+ 	struct nft_offload_reg *reg = &ctx->regs[priv->dreg];
+ 
+ 	switch (priv->offset) {
+ 	case offsetof(struct tcphdr, source):
+ 		if (priv->len != sizeof(__be16))
+ 			return -EOPNOTSUPP;
+ 
+ 		NFT_OFFLOAD_MATCH(FLOW_DISSECTOR_KEY_PORTS, tp, src,
+ 				  sizeof(__be16), reg);
+ 		break;
+ 	case offsetof(struct tcphdr, dest):
+ 		if (priv->len != sizeof(__be16))
+ 			return -EOPNOTSUPP;
+ 
+ 		NFT_OFFLOAD_MATCH(FLOW_DISSECTOR_KEY_PORTS, tp, dst,
+ 				  sizeof(__be16), reg);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int nft_payload_offload_udp(struct nft_offload_ctx *ctx,
+ 				   struct nft_flow_rule *flow,
+ 				   const struct nft_payload *priv)
+ {
+ 	struct nft_offload_reg *reg = &ctx->regs[priv->dreg];
+ 
+ 	switch (priv->offset) {
+ 	case offsetof(struct udphdr, source):
+ 		if (priv->len != sizeof(__be16))
+ 			return -EOPNOTSUPP;
+ 
+ 		NFT_OFFLOAD_MATCH(FLOW_DISSECTOR_KEY_PORTS, tp, src,
+ 				  sizeof(__be16), reg);
+ 		break;
+ 	case offsetof(struct udphdr, dest):
+ 		if (priv->len != sizeof(__be16))
+ 			return -EOPNOTSUPP;
+ 
+ 		NFT_OFFLOAD_MATCH(FLOW_DISSECTOR_KEY_PORTS, tp, dst,
+ 				  sizeof(__be16), reg);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int nft_payload_offload_th(struct nft_offload_ctx *ctx,
+ 				  struct nft_flow_rule *flow,
+ 				  const struct nft_payload *priv)
+ {
+ 	int err;
+ 
+ 	switch (ctx->dep.protonum) {
+ 	case IPPROTO_TCP:
+ 		err = nft_payload_offload_tcp(ctx, flow, priv);
+ 		break;
+ 	case IPPROTO_UDP:
+ 		err = nft_payload_offload_udp(ctx, flow, priv);
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static int nft_payload_offload(struct nft_offload_ctx *ctx,
+ 			       struct nft_flow_rule *flow,
+ 			       const struct nft_expr *expr)
+ {
+ 	const struct nft_payload *priv = nft_expr_priv(expr);
+ 	int err;
+ 
+ 	switch (priv->base) {
+ 	case NFT_PAYLOAD_LL_HEADER:
+ 		err = nft_payload_offload_ll(ctx, flow, priv);
+ 		break;
+ 	case NFT_PAYLOAD_NETWORK_HEADER:
+ 		err = nft_payload_offload_nh(ctx, flow, priv);
+ 		break;
+ 	case NFT_PAYLOAD_TRANSPORT_HEADER:
+ 		err = nft_payload_offload_th(ctx, flow, priv);
+ 		break;
+ 	default:
+ 		err = -EOPNOTSUPP;
+ 		break;
+ 	}
+ 	return err;
+ }
+ 
++>>>>>>> a69a85da458f (netfilter: nft_payload: fix missing check for matching length in offloads)
  static const struct nft_expr_ops nft_payload_ops = {
  	.type		= &nft_payload_type,
  	.size		= NFT_EXPR_SIZE(sizeof(struct nft_payload)),
* Unmerged path net/netfilter/nft_payload.c
