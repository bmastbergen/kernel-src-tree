gfs2: Grab glock reference sooner in gfs2_add_revoke

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit f4e2f5e1a527ce58fc9f85145b03704779a3123e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f4e2f5e1.failed

This patch rearranges gfs2_add_revoke so that the extra glock
reference is added earlier on in the function to avoid races in which
the glock is freed before the new reference is taken.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
(cherry picked from commit f4e2f5e1a527ce58fc9f85145b03704779a3123e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/log.c
diff --cc fs/gfs2/log.c
index 5a2ff16daaae,0644e58c6191..000000000000
--- a/fs/gfs2/log.c
+++ b/fs/gfs2/log.c
@@@ -605,34 -676,36 +608,37 @@@ void gfs2_add_revoke(struct gfs2_sbd *s
  	bd->bd_blkno = bh->b_blocknr;
  	gfs2_remove_from_ail(bd); /* drops ref on bh */
  	bd->bd_bh = NULL;
++<<<<<<< HEAD
 +	bd->bd_ops = &gfs2_revoke_lops;
 +	sdp->sd_log_num_revoke++;
 +	atomic_inc(&gl->gl_revokes);
++=======
++>>>>>>> f4e2f5e1a527 (gfs2: Grab glock reference sooner in gfs2_add_revoke)
  	set_bit(GLF_LFLUSH, &gl->gl_flags);
 -	list_add(&bd->bd_list, &sdp->sd_log_revokes);
 +	list_add(&bd->bd_list, &sdp->sd_log_le_revoke);
  }
  
 -void gfs2_glock_remove_revoke(struct gfs2_glock *gl)
 -{
 -	if (atomic_dec_return(&gl->gl_revokes) == 0) {
 -		clear_bit(GLF_LFLUSH, &gl->gl_flags);
 -		gfs2_glock_queue_put(gl);
 -	}
 -}
 -
 -/**
 - * gfs2_write_revokes - Add as many revokes to the system transaction as we can
 - * @sdp: The GFS2 superblock
 - *
 - * Our usual strategy is to defer writing revokes as much as we can in the hope
 - * that we'll eventually overwrite the journal, which will make those revokes
 - * go away.  This changes when we flush the log: at that point, there will
 - * likely be some left-over space in the last revoke block of that transaction.
 - * We can fill that space with additional revokes for blocks that have already
 - * been written back.  This will basically come at no cost now, and will save
 - * us from having to keep track of those blocks on the AIL2 list later.
 - */
  void gfs2_write_revokes(struct gfs2_sbd *sdp)
  {
 -	/* number of revokes we still have room for */
 +	struct gfs2_trans *tr;
 +	struct gfs2_bufdata *bd, *tmp;
 +	int have_revokes = 0;
  	int max_revokes = (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_log_descriptor)) / sizeof(u64);
  
 -	gfs2_log_lock(sdp);
 +	gfs2_ail1_empty(sdp);
 +	spin_lock(&sdp->sd_ail_lock);
 +	list_for_each_entry_reverse(tr, &sdp->sd_ail1_list, tr_list) {
 +		list_for_each_entry(bd, &tr->tr_ail2_list, bd_ail_st_list) {
 +			if (list_empty(&bd->bd_list)) {
 +				have_revokes = 1;
 +				goto done;
 +			}
 +		}
 +	}
 +done:
 +	spin_unlock(&sdp->sd_ail_lock);
 +	if (have_revokes == 0)
 +		return;
  	while (sdp->sd_log_num_revoke > max_revokes)
  		max_revokes += (sdp->sd_sb.sb_bsize - sizeof(struct gfs2_meta_header)) / sizeof(u64);
  	max_revokes -= sdp->sd_log_num_revoke;
* Unmerged path fs/gfs2/log.c
