netfilter: conntrack: pass nf_hook_state to packet and error handlers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 93e66024b0249cec81e91328c55a754efd3192e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/93e66024.failed

nf_hook_state contains all the hook meta-information: netns, protocol family,
hook location, and so on.

Instead of only passing selected information, pass a pointer to entire
structure.

This will allow to merge the error and the packet handlers and remove
the ->new() function in followup patches.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 93e66024b0249cec81e91328c55a754efd3192e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_conntrack_l4proto.h
#	net/ipv4/netfilter/nf_conntrack_proto_icmp.c
#	net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
#	net/netfilter/nf_conntrack_core.c
#	net/netfilter/nf_conntrack_proto.c
#	net/netfilter/nf_conntrack_proto_dccp.c
#	net/netfilter/nf_conntrack_proto_generic.c
#	net/netfilter/nf_conntrack_proto_gre.c
#	net/netfilter/nf_conntrack_proto_sctp.c
#	net/netfilter/nf_conntrack_proto_tcp.c
#	net/netfilter/nf_conntrack_proto_udp.c
diff --cc include/net/netfilter/nf_conntrack_l4proto.h
index 771e9d473ecd,a857a0adfb31..000000000000
--- a/include/net/netfilter/nf_conntrack_l4proto.h
+++ b/include/net/netfilter/nf_conntrack_l4proto.h
@@@ -46,7 -46,7 +46,11 @@@ struct nf_conntrack_l4proto 
  		      const struct sk_buff *skb,
  		      unsigned int dataoff,
  		      enum ip_conntrack_info ctinfo,
++<<<<<<< HEAD
 +		      unsigned int *timeouts);
++=======
+ 		      const struct nf_hook_state *state);
++>>>>>>> 93e66024b024 (netfilter: conntrack: pass nf_hook_state to packet and error handlers)
  
  	/* Called when a new connection for this protocol found;
  	 * returns TRUE if it's OK.  If so, packet() called next. */
diff --cc net/ipv4/netfilter/nf_conntrack_proto_icmp.c
index 34095949a003,c3a304b53245..000000000000
--- a/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
+++ b/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
@@@ -81,7 -82,7 +81,11 @@@ static int icmp_packet(struct nf_conn *
  		       const struct sk_buff *skb,
  		       unsigned int dataoff,
  		       enum ip_conntrack_info ctinfo,
++<<<<<<< HEAD:net/ipv4/netfilter/nf_conntrack_proto_icmp.c
 +		       unsigned int *timeout)
++=======
+ 		       const struct nf_hook_state *state)
++>>>>>>> 93e66024b024 (netfilter: conntrack: pass nf_hook_state to packet and error handlers):net/netfilter/nf_conntrack_proto_icmp.c
  {
  	/* Do not immediately delete the connection after the first
  	   successful reply to avoid excessive conntrackd traffic
diff --cc net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
index 8bcbc2f15bd5,bb5c98b0af89..000000000000
--- a/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
@@@ -94,8 -95,13 +94,12 @@@ static int icmpv6_packet(struct nf_con
  		       const struct sk_buff *skb,
  		       unsigned int dataoff,
  		       enum ip_conntrack_info ctinfo,
++<<<<<<< HEAD:net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
 +		       unsigned int *timeout)
++=======
+ 		       const struct nf_hook_state *state)
++>>>>>>> 93e66024b024 (netfilter: conntrack: pass nf_hook_state to packet and error handlers):net/netfilter/nf_conntrack_proto_icmpv6.c
  {
 -	unsigned int *timeout = nf_ct_timeout_lookup(ct);
 -
 -	if (!timeout)
 -		timeout = icmpv6_get_timeouts(nf_ct_net(ct));
 -
  	/* Do not immediately delete the connection after the first
  	   successful reply to avoid excessive conntrackd traffic
  	   and also to handle correctly ICMP echo reply duplicates. */
diff --cc net/netfilter/nf_conntrack_core.c
index 397b134cecce,8e275f4cdcdd..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -1480,17 -1493,13 +1481,19 @@@ resolve_normal_ct(struct nf_conn *tmpl
  }
  
  unsigned int
- nf_conntrack_in(struct net *net, u_int8_t pf, unsigned int hooknum,
- 		struct sk_buff *skb)
+ nf_conntrack_in(struct sk_buff *skb, const struct nf_hook_state *state)
  {
 +	const struct nf_conntrack_l3proto *l3proto;
  	const struct nf_conntrack_l4proto *l4proto;
- 	struct nf_conn *ct, *tmpl;
  	enum ip_conntrack_info ctinfo;
++<<<<<<< HEAD
 +	unsigned int *timeouts;
 +	unsigned int dataoff;
++=======
+ 	struct nf_conn *ct, *tmpl;
++>>>>>>> 93e66024b024 (netfilter: conntrack: pass nf_hook_state to packet and error handlers)
  	u_int8_t protonum;
 -	int dataoff, ret;
 +	int ret;
  
  	tmpl = nf_ct_get(skb, &ctinfo);
  	if (tmpl || ctinfo == IP_CT_UNTRACKED) {
@@@ -1504,14 -1513,12 +1507,23 @@@
  	}
  
  	/* rcu_read_lock()ed by nf_hook_thresh */
++<<<<<<< HEAD
 +	l3proto = __nf_ct_l3proto_find(pf);
 +	ret = l3proto->get_l4proto(skb, skb_network_offset(skb),
 +				   &dataoff, &protonum);
 +	if (ret <= 0) {
 +		pr_debug("not prepared to track yet or error occurred\n");
 +		NF_CT_STAT_INC_ATOMIC(net, error);
 +		NF_CT_STAT_INC_ATOMIC(net, invalid);
 +		ret = -ret;
++=======
+ 	dataoff = get_l4proto(skb, skb_network_offset(skb), state->pf, &protonum);
+ 	if (dataoff <= 0) {
+ 		pr_debug("not prepared to track yet or error occurred\n");
+ 		NF_CT_STAT_INC_ATOMIC(state->net, error);
+ 		NF_CT_STAT_INC_ATOMIC(state->net, invalid);
+ 		ret = NF_ACCEPT;
++>>>>>>> 93e66024b024 (netfilter: conntrack: pass nf_hook_state to packet and error handlers)
  		goto out;
  	}
  
@@@ -1549,10 -1557,7 +1562,14 @@@ repeat
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	/* Decide what timeout policy we want to apply to this flow. */
 +	timeouts = nf_ct_timeout_lookup(net, ct, l4proto);
 +
 +	ret = l4proto->packet(ct, skb, dataoff, ctinfo, timeouts);
++=======
+ 	ret = l4proto->packet(ct, skb, dataoff, ctinfo, state);
++>>>>>>> 93e66024b024 (netfilter: conntrack: pass nf_hook_state to packet and error handlers)
  	if (ret <= 0) {
  		/* Invalid: inverse of the return code tells
  		 * the netfilter core what to do */
diff --cc net/netfilter/nf_conntrack_proto.c
index 928ff492bf36,4896ba44becb..000000000000
--- a/net/netfilter/nf_conntrack_proto.c
+++ b/net/netfilter/nf_conntrack_proto.c
@@@ -570,6 -400,588 +570,591 @@@ void nf_ct_l4proto_pernet_unregister(st
  }
  EXPORT_SYMBOL_GPL(nf_ct_l4proto_pernet_unregister);
  
++<<<<<<< HEAD
++=======
+ static unsigned int ipv4_helper(void *priv,
+ 				struct sk_buff *skb,
+ 				const struct nf_hook_state *state)
+ {
+ 	struct nf_conn *ct;
+ 	enum ip_conntrack_info ctinfo;
+ 	const struct nf_conn_help *help;
+ 	const struct nf_conntrack_helper *helper;
+ 
+ 	/* This is where we call the helper: as the packet goes out. */
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct || ctinfo == IP_CT_RELATED_REPLY)
+ 		return NF_ACCEPT;
+ 
+ 	help = nfct_help(ct);
+ 	if (!help)
+ 		return NF_ACCEPT;
+ 
+ 	/* rcu_read_lock()ed by nf_hook_thresh */
+ 	helper = rcu_dereference(help->helper);
+ 	if (!helper)
+ 		return NF_ACCEPT;
+ 
+ 	return helper->help(skb, skb_network_offset(skb) + ip_hdrlen(skb),
+ 			    ct, ctinfo);
+ }
+ 
+ static unsigned int ipv4_confirm(void *priv,
+ 				 struct sk_buff *skb,
+ 				 const struct nf_hook_state *state)
+ {
+ 	struct nf_conn *ct;
+ 	enum ip_conntrack_info ctinfo;
+ 
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct || ctinfo == IP_CT_RELATED_REPLY)
+ 		goto out;
+ 
+ 	/* adjust seqs for loopback traffic only in outgoing direction */
+ 	if (test_bit(IPS_SEQ_ADJUST_BIT, &ct->status) &&
+ 	    !nf_is_loopback_packet(skb)) {
+ 		if (!nf_ct_seq_adjust(skb, ct, ctinfo, ip_hdrlen(skb))) {
+ 			NF_CT_STAT_INC_ATOMIC(nf_ct_net(ct), drop);
+ 			return NF_DROP;
+ 		}
+ 	}
+ out:
+ 	/* We've seen it coming out the other side: confirm it */
+ 	return nf_conntrack_confirm(skb);
+ }
+ 
+ static unsigned int ipv4_conntrack_in(void *priv,
+ 				      struct sk_buff *skb,
+ 				      const struct nf_hook_state *state)
+ {
+ 	return nf_conntrack_in(skb, state);
+ }
+ 
+ static unsigned int ipv4_conntrack_local(void *priv,
+ 					 struct sk_buff *skb,
+ 					 const struct nf_hook_state *state)
+ {
+ 	if (ip_is_fragment(ip_hdr(skb))) { /* IP_NODEFRAG setsockopt set */
+ 		enum ip_conntrack_info ctinfo;
+ 		struct nf_conn *tmpl;
+ 
+ 		tmpl = nf_ct_get(skb, &ctinfo);
+ 		if (tmpl && nf_ct_is_template(tmpl)) {
+ 			/* when skipping ct, clear templates to avoid fooling
+ 			 * later targets/matches
+ 			 */
+ 			skb->_nfct = 0;
+ 			nf_ct_put(tmpl);
+ 		}
+ 		return NF_ACCEPT;
+ 	}
+ 
+ 	return nf_conntrack_in(skb, state);
+ }
+ 
+ /* Connection tracking may drop packets, but never alters them, so
+  * make it the first hook.
+  */
+ static const struct nf_hook_ops ipv4_conntrack_ops[] = {
+ 	{
+ 		.hook		= ipv4_conntrack_in,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_PRE_ROUTING,
+ 		.priority	= NF_IP_PRI_CONNTRACK,
+ 	},
+ 	{
+ 		.hook		= ipv4_conntrack_local,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_LOCAL_OUT,
+ 		.priority	= NF_IP_PRI_CONNTRACK,
+ 	},
+ 	{
+ 		.hook		= ipv4_helper,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP_PRI_CONNTRACK_HELPER,
+ 	},
+ 	{
+ 		.hook		= ipv4_confirm,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM,
+ 	},
+ 	{
+ 		.hook		= ipv4_helper,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP_PRI_CONNTRACK_HELPER,
+ 	},
+ 	{
+ 		.hook		= ipv4_confirm,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM,
+ 	},
+ };
+ 
+ /* Fast function for those who don't want to parse /proc (and I don't
+  * blame them).
+  * Reversing the socket's dst/src point of view gives us the reply
+  * mapping.
+  */
+ static int
+ getorigdst(struct sock *sk, int optval, void __user *user, int *len)
+ {
+ 	const struct inet_sock *inet = inet_sk(sk);
+ 	const struct nf_conntrack_tuple_hash *h;
+ 	struct nf_conntrack_tuple tuple;
+ 
+ 	memset(&tuple, 0, sizeof(tuple));
+ 
+ 	lock_sock(sk);
+ 	tuple.src.u3.ip = inet->inet_rcv_saddr;
+ 	tuple.src.u.tcp.port = inet->inet_sport;
+ 	tuple.dst.u3.ip = inet->inet_daddr;
+ 	tuple.dst.u.tcp.port = inet->inet_dport;
+ 	tuple.src.l3num = PF_INET;
+ 	tuple.dst.protonum = sk->sk_protocol;
+ 	release_sock(sk);
+ 
+ 	/* We only do TCP and SCTP at the moment: is there a better way? */
+ 	if (tuple.dst.protonum != IPPROTO_TCP &&
+ 	    tuple.dst.protonum != IPPROTO_SCTP) {
+ 		pr_debug("SO_ORIGINAL_DST: Not a TCP/SCTP socket\n");
+ 		return -ENOPROTOOPT;
+ 	}
+ 
+ 	if ((unsigned int)*len < sizeof(struct sockaddr_in)) {
+ 		pr_debug("SO_ORIGINAL_DST: len %d not %zu\n",
+ 			 *len, sizeof(struct sockaddr_in));
+ 		return -EINVAL;
+ 	}
+ 
+ 	h = nf_conntrack_find_get(sock_net(sk), &nf_ct_zone_dflt, &tuple);
+ 	if (h) {
+ 		struct sockaddr_in sin;
+ 		struct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);
+ 
+ 		sin.sin_family = AF_INET;
+ 		sin.sin_port = ct->tuplehash[IP_CT_DIR_ORIGINAL]
+ 			.tuple.dst.u.tcp.port;
+ 		sin.sin_addr.s_addr = ct->tuplehash[IP_CT_DIR_ORIGINAL]
+ 			.tuple.dst.u3.ip;
+ 		memset(sin.sin_zero, 0, sizeof(sin.sin_zero));
+ 
+ 		pr_debug("SO_ORIGINAL_DST: %pI4 %u\n",
+ 			 &sin.sin_addr.s_addr, ntohs(sin.sin_port));
+ 		nf_ct_put(ct);
+ 		if (copy_to_user(user, &sin, sizeof(sin)) != 0)
+ 			return -EFAULT;
+ 		else
+ 			return 0;
+ 	}
+ 	pr_debug("SO_ORIGINAL_DST: Can't find %pI4/%u-%pI4/%u.\n",
+ 		 &tuple.src.u3.ip, ntohs(tuple.src.u.tcp.port),
+ 		 &tuple.dst.u3.ip, ntohs(tuple.dst.u.tcp.port));
+ 	return -ENOENT;
+ }
+ 
+ static struct nf_sockopt_ops so_getorigdst = {
+ 	.pf		= PF_INET,
+ 	.get_optmin	= SO_ORIGINAL_DST,
+ 	.get_optmax	= SO_ORIGINAL_DST + 1,
+ 	.get		= getorigdst,
+ 	.owner		= THIS_MODULE,
+ };
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static int
+ ipv6_getorigdst(struct sock *sk, int optval, void __user *user, int *len)
+ {
+ 	struct nf_conntrack_tuple tuple = { .src.l3num = NFPROTO_IPV6 };
+ 	const struct ipv6_pinfo *inet6 = inet6_sk(sk);
+ 	const struct inet_sock *inet = inet_sk(sk);
+ 	const struct nf_conntrack_tuple_hash *h;
+ 	struct sockaddr_in6 sin6;
+ 	struct nf_conn *ct;
+ 	__be32 flow_label;
+ 	int bound_dev_if;
+ 
+ 	lock_sock(sk);
+ 	tuple.src.u3.in6 = sk->sk_v6_rcv_saddr;
+ 	tuple.src.u.tcp.port = inet->inet_sport;
+ 	tuple.dst.u3.in6 = sk->sk_v6_daddr;
+ 	tuple.dst.u.tcp.port = inet->inet_dport;
+ 	tuple.dst.protonum = sk->sk_protocol;
+ 	bound_dev_if = sk->sk_bound_dev_if;
+ 	flow_label = inet6->flow_label;
+ 	release_sock(sk);
+ 
+ 	if (tuple.dst.protonum != IPPROTO_TCP &&
+ 	    tuple.dst.protonum != IPPROTO_SCTP)
+ 		return -ENOPROTOOPT;
+ 
+ 	if (*len < 0 || (unsigned int)*len < sizeof(sin6))
+ 		return -EINVAL;
+ 
+ 	h = nf_conntrack_find_get(sock_net(sk), &nf_ct_zone_dflt, &tuple);
+ 	if (!h) {
+ 		pr_debug("IP6T_SO_ORIGINAL_DST: Can't find %pI6c/%u-%pI6c/%u.\n",
+ 			 &tuple.src.u3.ip6, ntohs(tuple.src.u.tcp.port),
+ 			 &tuple.dst.u3.ip6, ntohs(tuple.dst.u.tcp.port));
+ 		return -ENOENT;
+ 	}
+ 
+ 	ct = nf_ct_tuplehash_to_ctrack(h);
+ 
+ 	sin6.sin6_family = AF_INET6;
+ 	sin6.sin6_port = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.tcp.port;
+ 	sin6.sin6_flowinfo = flow_label & IPV6_FLOWINFO_MASK;
+ 	memcpy(&sin6.sin6_addr,
+ 	       &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.in6,
+ 	       sizeof(sin6.sin6_addr));
+ 
+ 	nf_ct_put(ct);
+ 	sin6.sin6_scope_id = ipv6_iface_scope_id(&sin6.sin6_addr, bound_dev_if);
+ 	return copy_to_user(user, &sin6, sizeof(sin6)) ? -EFAULT : 0;
+ }
+ 
+ static struct nf_sockopt_ops so_getorigdst6 = {
+ 	.pf		= NFPROTO_IPV6,
+ 	.get_optmin	= IP6T_SO_ORIGINAL_DST,
+ 	.get_optmax	= IP6T_SO_ORIGINAL_DST + 1,
+ 	.get		= ipv6_getorigdst,
+ 	.owner		= THIS_MODULE,
+ };
+ 
+ static unsigned int ipv6_confirm(void *priv,
+ 				 struct sk_buff *skb,
+ 				 const struct nf_hook_state *state)
+ {
+ 	struct nf_conn *ct;
+ 	enum ip_conntrack_info ctinfo;
+ 	unsigned char pnum = ipv6_hdr(skb)->nexthdr;
+ 	int protoff;
+ 	__be16 frag_off;
+ 
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct || ctinfo == IP_CT_RELATED_REPLY)
+ 		goto out;
+ 
+ 	protoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &pnum,
+ 				   &frag_off);
+ 	if (protoff < 0 || (frag_off & htons(~0x7)) != 0) {
+ 		pr_debug("proto header not found\n");
+ 		goto out;
+ 	}
+ 
+ 	/* adjust seqs for loopback traffic only in outgoing direction */
+ 	if (test_bit(IPS_SEQ_ADJUST_BIT, &ct->status) &&
+ 	    !nf_is_loopback_packet(skb)) {
+ 		if (!nf_ct_seq_adjust(skb, ct, ctinfo, protoff)) {
+ 			NF_CT_STAT_INC_ATOMIC(nf_ct_net(ct), drop);
+ 			return NF_DROP;
+ 		}
+ 	}
+ out:
+ 	/* We've seen it coming out the other side: confirm it */
+ 	return nf_conntrack_confirm(skb);
+ }
+ 
+ static unsigned int ipv6_conntrack_in(void *priv,
+ 				      struct sk_buff *skb,
+ 				      const struct nf_hook_state *state)
+ {
+ 	return nf_conntrack_in(skb, state);
+ }
+ 
+ static unsigned int ipv6_conntrack_local(void *priv,
+ 					 struct sk_buff *skb,
+ 					 const struct nf_hook_state *state)
+ {
+ 	return nf_conntrack_in(skb, state);
+ }
+ 
+ static unsigned int ipv6_helper(void *priv,
+ 				struct sk_buff *skb,
+ 				const struct nf_hook_state *state)
+ {
+ 	struct nf_conn *ct;
+ 	const struct nf_conn_help *help;
+ 	const struct nf_conntrack_helper *helper;
+ 	enum ip_conntrack_info ctinfo;
+ 	__be16 frag_off;
+ 	int protoff;
+ 	u8 nexthdr;
+ 
+ 	/* This is where we call the helper: as the packet goes out. */
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct || ctinfo == IP_CT_RELATED_REPLY)
+ 		return NF_ACCEPT;
+ 
+ 	help = nfct_help(ct);
+ 	if (!help)
+ 		return NF_ACCEPT;
+ 	/* rcu_read_lock()ed by nf_hook_thresh */
+ 	helper = rcu_dereference(help->helper);
+ 	if (!helper)
+ 		return NF_ACCEPT;
+ 
+ 	nexthdr = ipv6_hdr(skb)->nexthdr;
+ 	protoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &nexthdr,
+ 				   &frag_off);
+ 	if (protoff < 0 || (frag_off & htons(~0x7)) != 0) {
+ 		pr_debug("proto header not found\n");
+ 		return NF_ACCEPT;
+ 	}
+ 
+ 	return helper->help(skb, protoff, ct, ctinfo);
+ }
+ 
+ static const struct nf_hook_ops ipv6_conntrack_ops[] = {
+ 	{
+ 		.hook		= ipv6_conntrack_in,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_PRE_ROUTING,
+ 		.priority	= NF_IP6_PRI_CONNTRACK,
+ 	},
+ 	{
+ 		.hook		= ipv6_conntrack_local,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_LOCAL_OUT,
+ 		.priority	= NF_IP6_PRI_CONNTRACK,
+ 	},
+ 	{
+ 		.hook		= ipv6_helper,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP6_PRI_CONNTRACK_HELPER,
+ 	},
+ 	{
+ 		.hook		= ipv6_confirm,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP6_PRI_LAST,
+ 	},
+ 	{
+ 		.hook		= ipv6_helper,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP6_PRI_CONNTRACK_HELPER,
+ 	},
+ 	{
+ 		.hook		= ipv6_confirm,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP6_PRI_LAST - 1,
+ 	},
+ };
+ #endif
+ 
+ static int nf_ct_tcp_fixup(struct nf_conn *ct, void *_nfproto)
+ {
+ 	u8 nfproto = (unsigned long)_nfproto;
+ 
+ 	if (nf_ct_l3num(ct) != nfproto)
+ 		return 0;
+ 
+ 	if (nf_ct_protonum(ct) == IPPROTO_TCP &&
+ 	    ct->proto.tcp.state == TCP_CONNTRACK_ESTABLISHED) {
+ 		ct->proto.tcp.seen[0].td_maxwin = 0;
+ 		ct->proto.tcp.seen[1].td_maxwin = 0;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int nf_ct_netns_do_get(struct net *net, u8 nfproto)
+ {
+ 	struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
+ 	bool fixup_needed = false;
+ 	int err = 0;
+ 
+ 	mutex_lock(&nf_ct_proto_mutex);
+ 
+ 	switch (nfproto) {
+ 	case NFPROTO_IPV4:
+ 		cnet->users4++;
+ 		if (cnet->users4 > 1)
+ 			goto out_unlock;
+ 		err = nf_defrag_ipv4_enable(net);
+ 		if (err) {
+ 			cnet->users4 = 0;
+ 			goto out_unlock;
+ 		}
+ 
+ 		err = nf_register_net_hooks(net, ipv4_conntrack_ops,
+ 					    ARRAY_SIZE(ipv4_conntrack_ops));
+ 		if (err)
+ 			cnet->users4 = 0;
+ 		else
+ 			fixup_needed = true;
+ 		break;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case NFPROTO_IPV6:
+ 		cnet->users6++;
+ 		if (cnet->users6 > 1)
+ 			goto out_unlock;
+ 		err = nf_defrag_ipv6_enable(net);
+ 		if (err < 0) {
+ 			cnet->users6 = 0;
+ 			goto out_unlock;
+ 		}
+ 
+ 		err = nf_register_net_hooks(net, ipv6_conntrack_ops,
+ 					    ARRAY_SIZE(ipv6_conntrack_ops));
+ 		if (err)
+ 			cnet->users6 = 0;
+ 		else
+ 			fixup_needed = true;
+ 		break;
+ #endif
+ 	default:
+ 		err = -EPROTO;
+ 		break;
+ 	}
+  out_unlock:
+ 	mutex_unlock(&nf_ct_proto_mutex);
+ 
+ 	if (fixup_needed)
+ 		nf_ct_iterate_cleanup_net(net, nf_ct_tcp_fixup,
+ 					  (void *)(unsigned long)nfproto, 0, 0);
+ 
+ 	return err;
+ }
+ 
+ static void nf_ct_netns_do_put(struct net *net, u8 nfproto)
+ {
+ 	struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
+ 
+ 	mutex_lock(&nf_ct_proto_mutex);
+ 	switch (nfproto) {
+ 	case NFPROTO_IPV4:
+ 		if (cnet->users4 && (--cnet->users4 == 0))
+ 			nf_unregister_net_hooks(net, ipv4_conntrack_ops,
+ 						ARRAY_SIZE(ipv4_conntrack_ops));
+ 		break;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case NFPROTO_IPV6:
+ 		if (cnet->users6 && (--cnet->users6 == 0))
+ 			nf_unregister_net_hooks(net, ipv6_conntrack_ops,
+ 						ARRAY_SIZE(ipv6_conntrack_ops));
+ 		break;
+ #endif
+ 	}
+ 
+ 	mutex_unlock(&nf_ct_proto_mutex);
+ }
+ 
+ int nf_ct_netns_get(struct net *net, u8 nfproto)
+ {
+ 	int err;
+ 
+ 	if (nfproto == NFPROTO_INET) {
+ 		err = nf_ct_netns_do_get(net, NFPROTO_IPV4);
+ 		if (err < 0)
+ 			goto err1;
+ 		err = nf_ct_netns_do_get(net, NFPROTO_IPV6);
+ 		if (err < 0)
+ 			goto err2;
+ 	} else {
+ 		err = nf_ct_netns_do_get(net, nfproto);
+ 		if (err < 0)
+ 			goto err1;
+ 	}
+ 	return 0;
+ 
+ err2:
+ 	nf_ct_netns_put(net, NFPROTO_IPV4);
+ err1:
+ 	return err;
+ }
+ EXPORT_SYMBOL_GPL(nf_ct_netns_get);
+ 
+ void nf_ct_netns_put(struct net *net, uint8_t nfproto)
+ {
+ 	if (nfproto == NFPROTO_INET) {
+ 		nf_ct_netns_do_put(net, NFPROTO_IPV4);
+ 		nf_ct_netns_do_put(net, NFPROTO_IPV6);
+ 	} else {
+ 		nf_ct_netns_do_put(net, nfproto);
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(nf_ct_netns_put);
+ 
+ static const struct nf_conntrack_l4proto * const builtin_l4proto[] = {
+ 	&nf_conntrack_l4proto_tcp4,
+ 	&nf_conntrack_l4proto_udp4,
+ 	&nf_conntrack_l4proto_icmp,
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 	&nf_conntrack_l4proto_dccp4,
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ 	&nf_conntrack_l4proto_sctp4,
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_UDPLITE
+ 	&nf_conntrack_l4proto_udplite4,
+ #endif
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	&nf_conntrack_l4proto_tcp6,
+ 	&nf_conntrack_l4proto_udp6,
+ 	&nf_conntrack_l4proto_icmpv6,
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 	&nf_conntrack_l4proto_dccp6,
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ 	&nf_conntrack_l4proto_sctp6,
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_UDPLITE
+ 	&nf_conntrack_l4proto_udplite6,
+ #endif
+ #endif /* CONFIG_IPV6 */
+ };
+ 
+ int nf_conntrack_proto_init(void)
+ {
+ 	int ret = 0;
+ 
+ 	ret = nf_register_sockopt(&so_getorigdst);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	ret = nf_register_sockopt(&so_getorigdst6);
+ 	if (ret < 0)
+ 		goto cleanup_sockopt;
+ #endif
+ 	ret = nf_ct_l4proto_register(builtin_l4proto,
+ 				     ARRAY_SIZE(builtin_l4proto));
+ 	if (ret < 0)
+ 		goto cleanup_sockopt2;
+ 
+ 	return ret;
+ cleanup_sockopt2:
+ 	nf_unregister_sockopt(&so_getorigdst);
+ #if IS_ENABLED(CONFIG_IPV6)
+ cleanup_sockopt:
+ 	nf_unregister_sockopt(&so_getorigdst6);
+ #endif
+ 	return ret;
+ }
+ 
+ void nf_conntrack_proto_fini(void)
+ {
+ 	unsigned int i;
+ 
+ 	nf_unregister_sockopt(&so_getorigdst);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	nf_unregister_sockopt(&so_getorigdst6);
+ #endif
+ 	/* No need to call nf_ct_l4proto_unregister(), the register
+ 	 * tables are free'd here anyway.
+ 	 */
+ 	for (i = 0; i < ARRAY_SIZE(nf_ct_protos); i++)
+ 		kfree(nf_ct_protos[i]);
+ }
+ 
++>>>>>>> 93e66024b024 (netfilter: conntrack: pass nf_hook_state to packet and error handlers)
  int nf_conntrack_proto_pernet_init(struct net *net)
  {
  	int err;
diff --cc net/netfilter/nf_conntrack_proto_dccp.c
index eb1729f3a62d,8595c79742a2..000000000000
--- a/net/netfilter/nf_conntrack_proto_dccp.c
+++ b/net/netfilter/nf_conntrack_proto_dccp.c
@@@ -437,14 -438,9 +437,18 @@@ static u64 dccp_ack_seq(const struct dc
  		     ntohl(dhack->dccph_ack_nr_low);
  }
  
 +static unsigned int *dccp_get_timeouts(struct net *net)
 +{
 +	return dccp_pernet(net)->dccp_timeout;
 +}
 +
  static int dccp_packet(struct nf_conn *ct, const struct sk_buff *skb,
  		       unsigned int dataoff, enum ip_conntrack_info ctinfo,
++<<<<<<< HEAD
 +		       unsigned int *timeouts)
++=======
+ 		       const struct nf_hook_state *state)
++>>>>>>> 93e66024b024 (netfilter: conntrack: pass nf_hook_state to packet and error handlers)
  {
  	enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
  	struct dccp_hdr _dh, *dh;
diff --cc net/netfilter/nf_conntrack_proto_generic.c
index 4dfe40aa9446,9940161cfef1..000000000000
--- a/net/netfilter/nf_conntrack_proto_generic.c
+++ b/net/netfilter/nf_conntrack_proto_generic.c
@@@ -51,8 -47,13 +51,12 @@@ static int generic_packet(struct nf_con
  			  const struct sk_buff *skb,
  			  unsigned int dataoff,
  			  enum ip_conntrack_info ctinfo,
++<<<<<<< HEAD
 +			  unsigned int *timeout)
++=======
+ 			  const struct nf_hook_state *state)
++>>>>>>> 93e66024b024 (netfilter: conntrack: pass nf_hook_state to packet and error handlers)
  {
 -	const unsigned int *timeout = nf_ct_timeout_lookup(ct);
 -
 -	if (!timeout)
 -		timeout = &generic_pernet(nf_ct_net(ct))->timeout;
 -
  	nf_ct_refresh_acct(ct, ctinfo, skb, *timeout);
  	return NF_ACCEPT;
  }
diff --cc net/netfilter/nf_conntrack_proto_gre.c
index 0bd40eb06b55,85313a191456..000000000000
--- a/net/netfilter/nf_conntrack_proto_gre.c
+++ b/net/netfilter/nf_conntrack_proto_gre.c
@@@ -235,7 -236,7 +235,11 @@@ static int gre_packet(struct nf_conn *c
  		      const struct sk_buff *skb,
  		      unsigned int dataoff,
  		      enum ip_conntrack_info ctinfo,
++<<<<<<< HEAD
 +		      unsigned int *timeouts)
++=======
+ 		      const struct nf_hook_state *state)
++>>>>>>> 93e66024b024 (netfilter: conntrack: pass nf_hook_state to packet and error handlers)
  {
  	/* If we've seen traffic both ways, this is a GRE connection.
  	 * Extend timeout. */
diff --cc net/netfilter/nf_conntrack_proto_sctp.c
index 97f184cfbcc5,34b80cea4a56..000000000000
--- a/net/netfilter/nf_conntrack_proto_sctp.c
+++ b/net/netfilter/nf_conntrack_proto_sctp.c
@@@ -282,7 -278,7 +282,11 @@@ static int sctp_packet(struct nf_conn *
  		       const struct sk_buff *skb,
  		       unsigned int dataoff,
  		       enum ip_conntrack_info ctinfo,
++<<<<<<< HEAD
 +		       unsigned int *timeouts)
++=======
+ 		       const struct nf_hook_state *state)
++>>>>>>> 93e66024b024 (netfilter: conntrack: pass nf_hook_state to packet and error handlers)
  {
  	enum sctp_conntrack new_state, old_state;
  	enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
diff --cc net/netfilter/nf_conntrack_proto_tcp.c
index b84677545355,5128f0a79ed4..000000000000
--- a/net/netfilter/nf_conntrack_proto_tcp.c
+++ b/net/netfilter/nf_conntrack_proto_tcp.c
@@@ -780,7 -775,7 +781,11 @@@ static int tcp_packet(struct nf_conn *c
  		      const struct sk_buff *skb,
  		      unsigned int dataoff,
  		      enum ip_conntrack_info ctinfo,
++<<<<<<< HEAD
 +		      unsigned int *timeouts)
++=======
+ 		      const struct nf_hook_state *state)
++>>>>>>> 93e66024b024 (netfilter: conntrack: pass nf_hook_state to packet and error handlers)
  {
  	struct net *net = nf_ct_net(ct);
  	struct nf_tcp_net *tn = tcp_pernet(net);
diff --cc net/netfilter/nf_conntrack_proto_udp.c
index 8b435d70ffe3,bf59d32bba98..000000000000
--- a/net/netfilter/nf_conntrack_proto_udp.c
+++ b/net/netfilter/nf_conntrack_proto_udp.c
@@@ -46,8 -47,14 +46,12 @@@ static int udp_packet(struct nf_conn *c
  		      const struct sk_buff *skb,
  		      unsigned int dataoff,
  		      enum ip_conntrack_info ctinfo,
++<<<<<<< HEAD
 +		      unsigned int *timeouts)
++=======
+ 		      const struct nf_hook_state *state)
++>>>>>>> 93e66024b024 (netfilter: conntrack: pass nf_hook_state to packet and error handlers)
  {
 -	unsigned int *timeouts;
 -
 -	timeouts = nf_ct_timeout_lookup(ct);
 -	if (!timeouts)
 -		timeouts = udp_get_timeouts(nf_ct_net(ct));
 -
  	/* If we've seen traffic both ways, this is some kind of UDP
  	   stream.  Extend timeout. */
  	if (test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {
diff --git a/include/net/netfilter/nf_conntrack_core.h b/include/net/netfilter/nf_conntrack_core.h
index f5bc17885ca0..4e68bb01ab5e 100644
--- a/include/net/netfilter/nf_conntrack_core.h
+++ b/include/net/netfilter/nf_conntrack_core.h
@@ -21,8 +21,7 @@
 /* This header is used to share core functionality between the
    standalone connection tracking module, and the compatibility layer's use
    of connection tracking. */
-unsigned int nf_conntrack_in(struct net *net, u_int8_t pf, unsigned int hooknum,
-			     struct sk_buff *skb);
+unsigned int nf_conntrack_in(struct sk_buff *skb, const struct nf_hook_state *state);
 
 int nf_conntrack_init_net(struct net *net);
 void nf_conntrack_cleanup_net(struct net *net);
* Unmerged path include/net/netfilter/nf_conntrack_l4proto.h
* Unmerged path net/ipv4/netfilter/nf_conntrack_proto_icmp.c
* Unmerged path net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
* Unmerged path net/netfilter/nf_conntrack_core.c
* Unmerged path net/netfilter/nf_conntrack_proto.c
* Unmerged path net/netfilter/nf_conntrack_proto_dccp.c
* Unmerged path net/netfilter/nf_conntrack_proto_generic.c
* Unmerged path net/netfilter/nf_conntrack_proto_gre.c
* Unmerged path net/netfilter/nf_conntrack_proto_sctp.c
* Unmerged path net/netfilter/nf_conntrack_proto_tcp.c
* Unmerged path net/netfilter/nf_conntrack_proto_udp.c
diff --git a/net/openvswitch/conntrack.c b/net/openvswitch/conntrack.c
index 7f5686829476..d6dcad5841cc 100644
--- a/net/openvswitch/conntrack.c
+++ b/net/openvswitch/conntrack.c
@@ -949,6 +949,11 @@ static int __ovs_ct_lookup(struct net *net, struct sw_flow_key *key,
 	struct nf_conn *ct;
 
 	if (!cached) {
+		struct nf_hook_state state = {
+			.hook = NF_INET_PRE_ROUTING,
+			.pf = info->family,
+			.net = net,
+		};
 		struct nf_conn *tmpl = info->ct;
 		int err;
 
@@ -960,8 +965,7 @@ static int __ovs_ct_lookup(struct net *net, struct sw_flow_key *key,
 			nf_ct_set(skb, tmpl, IP_CT_NEW);
 		}
 
-		err = nf_conntrack_in(net, info->family,
-				      NF_INET_PRE_ROUTING, skb);
+		err = nf_conntrack_in(skb, &state);
 		if (err != NF_ACCEPT)
 			return -ENOENT;
 
