netfilter: conntrack: remove module owner field

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit b184356d0a003ac5e82b4adf37f2d334df1d213c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b184356d.failed

No need to get/put module owner reference, none of these can be removed
anymore.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit b184356d0a003ac5e82b4adf37f2d334df1d213c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_conntrack_l4proto.h
#	net/netfilter/nf_conntrack_proto.c
#	net/netfilter/nft_ct.c
diff --cc include/net/netfilter/nf_conntrack_l4proto.h
index 264f50873a3a,fd8954429e87..000000000000
--- a/include/net/netfilter/nf_conntrack_l4proto.h
+++ b/include/net/netfilter/nf_conntrack_l4proto.h
@@@ -100,22 -74,77 +100,23 @@@ struct nf_conntrack_l4proto 
  
  	/* Return the per-net protocol part. */
  	struct nf_proto_net *(*get_net_proto)(struct net *net);
- 
- 	/* Module (if any) which this is connected to. */
- 	struct module *me;
  };
  
 -bool icmp_pkt_to_tuple(const struct sk_buff *skb,
 -		       unsigned int dataoff,
 -		       struct net *net,
 -		       struct nf_conntrack_tuple *tuple);
 -
 -bool icmpv6_pkt_to_tuple(const struct sk_buff *skb,
 -			 unsigned int dataoff,
 -			 struct net *net,
 -			 struct nf_conntrack_tuple *tuple);
 -
 -bool nf_conntrack_invert_icmp_tuple(struct nf_conntrack_tuple *tuple,
 -				    const struct nf_conntrack_tuple *orig);
 -bool nf_conntrack_invert_icmpv6_tuple(struct nf_conntrack_tuple *tuple,
 -				      const struct nf_conntrack_tuple *orig);
 -
 -int nf_conntrack_icmpv4_error(struct nf_conn *tmpl,
 -			      struct sk_buff *skb,
 -			      unsigned int dataoff,
 -			      const struct nf_hook_state *state);
 -
 -int nf_conntrack_icmpv6_error(struct nf_conn *tmpl,
 -			      struct sk_buff *skb,
 -			      unsigned int dataoff,
 -			      const struct nf_hook_state *state);
 -
 -int nf_conntrack_icmp_packet(struct nf_conn *ct,
 -			     struct sk_buff *skb,
 -			     enum ip_conntrack_info ctinfo,
 -			     const struct nf_hook_state *state);
 -
 -int nf_conntrack_icmpv6_packet(struct nf_conn *ct,
 -			       struct sk_buff *skb,
 -			       enum ip_conntrack_info ctinfo,
 -			       const struct nf_hook_state *state);
 -
 -int nf_conntrack_udp_packet(struct nf_conn *ct,
 -			    struct sk_buff *skb,
 -			    unsigned int dataoff,
 -			    enum ip_conntrack_info ctinfo,
 -			    const struct nf_hook_state *state);
 -int nf_conntrack_udplite_packet(struct nf_conn *ct,
 -				struct sk_buff *skb,
 -				unsigned int dataoff,
 -				enum ip_conntrack_info ctinfo,
 -				const struct nf_hook_state *state);
 -int nf_conntrack_tcp_packet(struct nf_conn *ct,
 -			    struct sk_buff *skb,
 -			    unsigned int dataoff,
 -			    enum ip_conntrack_info ctinfo,
 -			    const struct nf_hook_state *state);
 -int nf_conntrack_dccp_packet(struct nf_conn *ct,
 -			     struct sk_buff *skb,
 -			     unsigned int dataoff,
 -			     enum ip_conntrack_info ctinfo,
 -			     const struct nf_hook_state *state);
 -int nf_conntrack_sctp_packet(struct nf_conn *ct,
 -			     struct sk_buff *skb,
 -			     unsigned int dataoff,
 -			     enum ip_conntrack_info ctinfo,
 -			     const struct nf_hook_state *state);
 -
  /* Existing built-in generic protocol */
  extern const struct nf_conntrack_l4proto nf_conntrack_l4proto_generic;
  
 -#define MAX_NF_CT_PROTO IPPROTO_UDPLITE
 +#define MAX_NF_CT_PROTO 256
  
 -const struct nf_conntrack_l4proto *__nf_ct_l4proto_find(u8 l4proto);
 +const struct nf_conntrack_l4proto *__nf_ct_l4proto_find(u_int16_t l3proto,
 +						  u_int8_t l4proto);
  
++<<<<<<< HEAD
 +const struct nf_conntrack_l4proto *nf_ct_l4proto_find_get(u_int16_t l3proto,
 +						    u_int8_t l4proto);
 +void nf_ct_l4proto_put(const struct nf_conntrack_l4proto *p);
++=======
+ const struct nf_conntrack_l4proto *nf_ct_l4proto_find_get(u8 l4proto);
++>>>>>>> b184356d0a00 (netfilter: conntrack: remove module owner field)
  
  /* Protocol pernet registration. */
  int nf_ct_l4proto_pernet_register_one(struct net *net,
diff --cc net/netfilter/nf_conntrack_proto.c
index baa1f4cdedbb,3455f993cc68..000000000000
--- a/net/netfilter/nf_conntrack_proto.c
+++ b/net/netfilter/nf_conntrack_proto.c
@@@ -122,216 -133,24 +122,229 @@@ __nf_ct_l4proto_find(u_int16_t l3proto
  }
  EXPORT_SYMBOL_GPL(__nf_ct_l4proto_find);
  
 -const struct nf_conntrack_l4proto *nf_ct_l4proto_find_get(u8 l4num)
 +/* this is guaranteed to always return a valid protocol helper, since
 + * it falls back to generic_protocol */
 +const struct nf_conntrack_l3proto *
 +nf_ct_l3proto_find_get(u_int16_t l3proto)
  {
 -	const struct nf_conntrack_l4proto *p;
 +	struct nf_conntrack_l3proto *p;
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	p = __nf_ct_l3proto_find(l3proto);
 +	if (!try_module_get(p->me))
 +		p = &nf_conntrack_l3proto_generic;
++=======
+ 	p = __nf_ct_l4proto_find(l4num);
++>>>>>>> b184356d0a00 (netfilter: conntrack: remove module owner field)
  	rcu_read_unlock();
  
  	return p;
  }
 -EXPORT_SYMBOL_GPL(nf_ct_l4proto_find_get);
 +EXPORT_SYMBOL_GPL(nf_ct_l3proto_find_get);
  
++<<<<<<< HEAD
 +int
 +nf_ct_l3proto_try_module_get(unsigned short l3proto)
 +{
 +	const struct nf_conntrack_l3proto *p;
 +	int ret;
 +
 +retry:	p = nf_ct_l3proto_find_get(l3proto);
 +	if (p == &nf_conntrack_l3proto_generic) {
 +		ret = request_module("nf_conntrack-%d", l3proto);
 +		if (!ret)
 +			goto retry;
++=======
+ static int kill_l4proto(struct nf_conn *i, void *data)
+ {
+ 	const struct nf_conntrack_l4proto *l4proto;
+ 	l4proto = data;
+ 	return nf_ct_protonum(i) == l4proto->l4proto;
+ }
++>>>>>>> b184356d0a00 (netfilter: conntrack: remove module owner field)
 +
 +		return -EPROTOTYPE;
 +	}
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_l3proto_try_module_get);
 +
 +void nf_ct_l3proto_module_put(unsigned short l3proto)
 +{
 +	struct nf_conntrack_l3proto *p;
 +
 +	/* rcu_read_lock not necessary since the caller holds a reference, but
 +	 * taken anyways to avoid lockdep warnings in __nf_ct_l3proto_find()
 +	 */
 +	rcu_read_lock();
 +	p = __nf_ct_l3proto_find(l3proto);
 +	module_put(p->me);
 +	rcu_read_unlock();
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_l3proto_module_put);
 +
 +static int nf_ct_netns_do_get(struct net *net, u8 nfproto)
 +{
 +	const struct nf_conntrack_l3proto *l3proto;
 +	int ret;
 +
 +	might_sleep();
 +
 +	ret = nf_ct_l3proto_try_module_get(nfproto);
 +	if (ret < 0)
 +		return ret;
 +
 +	/* we already have a reference, can't fail */
 +	rcu_read_lock();
 +	l3proto = __nf_ct_l3proto_find(nfproto);
 +	rcu_read_unlock();
 +
 +	if (!l3proto->net_ns_get)
 +		return 0;
 +
 +	ret = l3proto->net_ns_get(net);
 +	if (ret < 0)
 +		nf_ct_l3proto_module_put(nfproto);
 +
 +	return ret;
 +}
 +
 +int nf_ct_netns_get(struct net *net, u8 nfproto)
 +{
 +	int err;
 +
 +	if (nfproto == NFPROTO_INET) {
 +		err = nf_ct_netns_do_get(net, NFPROTO_IPV4);
 +		if (err < 0)
 +			goto err1;
 +		err = nf_ct_netns_do_get(net, NFPROTO_IPV6);
 +		if (err < 0)
 +			goto err2;
 +	} else {
 +		err = nf_ct_netns_do_get(net, nfproto);
 +		if (err < 0)
 +			goto err1;
 +	}
 +	return 0;
 +
 +err2:
 +	nf_ct_netns_put(net, NFPROTO_IPV4);
 +err1:
 +	return err;
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_netns_get);
 +
 +static void nf_ct_netns_do_put(struct net *net, u8 nfproto)
 +{
 +	const struct nf_conntrack_l3proto *l3proto;
 +
 +	might_sleep();
 +
 +	/* same as nf_conntrack_netns_get(), reference assumed */
 +	rcu_read_lock();
 +	l3proto = __nf_ct_l3proto_find(nfproto);
 +	rcu_read_unlock();
 +
 +	if (WARN_ON(!l3proto))
 +		return;
 +
 +	if (l3proto->net_ns_put)
 +		l3proto->net_ns_put(net);
 +
 +	nf_ct_l3proto_module_put(nfproto);
 +}
 +
 +void nf_ct_netns_put(struct net *net, uint8_t nfproto)
 +{
 +	if (nfproto == NFPROTO_INET) {
 +		nf_ct_netns_do_put(net, NFPROTO_IPV4);
 +		nf_ct_netns_do_put(net, NFPROTO_IPV6);
 +	} else
 +		nf_ct_netns_do_put(net, nfproto);
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_netns_put);
 +
 +const struct nf_conntrack_l4proto *
 +nf_ct_l4proto_find_get(u_int16_t l3num, u_int8_t l4num)
 +{
 +	const struct nf_conntrack_l4proto *p;
 +
 +	rcu_read_lock();
 +	p = __nf_ct_l4proto_find(l3num, l4num);
 +	if (!try_module_get(p->me))
 +		p = &nf_conntrack_l4proto_generic;
 +	rcu_read_unlock();
 +
 +	return p;
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_l4proto_find_get);
 +
 +void nf_ct_l4proto_put(const struct nf_conntrack_l4proto *p)
 +{
 +	module_put(p->me);
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_l4proto_put);
 +
 +static int kill_l3proto(struct nf_conn *i, void *data)
 +{
 +	return nf_ct_l3num(i) == ((const struct nf_conntrack_l3proto *)data)->l3proto;
 +}
 +
 +static int kill_l4proto(struct nf_conn *i, void *data)
 +{
 +	const struct nf_conntrack_l4proto *l4proto;
 +	l4proto = data;
 +	return nf_ct_protonum(i) == l4proto->l4proto &&
 +	       nf_ct_l3num(i) == l4proto->l3proto;
 +}
 +
 +int nf_ct_l3proto_register(const struct nf_conntrack_l3proto *proto)
 +{
 +	int ret = 0;
 +	struct nf_conntrack_l3proto *old;
 +
 +	if (proto->l3proto >= NFPROTO_NUMPROTO)
 +		return -EBUSY;
 +#if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 +	if (proto->tuple_to_nlattr && proto->nla_size == 0)
 +		return -EINVAL;
 +#endif
 +	mutex_lock(&nf_ct_proto_mutex);
 +	old = rcu_dereference_protected(nf_ct_l3protos[proto->l3proto],
 +					lockdep_is_held(&nf_ct_proto_mutex));
 +	if (old != &nf_conntrack_l3proto_generic) {
 +		ret = -EBUSY;
 +		goto out_unlock;
 +	}
 +
 +	rcu_assign_pointer(nf_ct_l3protos[proto->l3proto], proto);
 +
 +out_unlock:
 +	mutex_unlock(&nf_ct_proto_mutex);
 +	return ret;
 +
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_l3proto_register);
 +
 +void nf_ct_l3proto_unregister(const struct nf_conntrack_l3proto *proto)
 +{
 +	BUG_ON(proto->l3proto >= NFPROTO_NUMPROTO);
 +
 +	mutex_lock(&nf_ct_proto_mutex);
 +	BUG_ON(rcu_dereference_protected(nf_ct_l3protos[proto->l3proto],
 +					 lockdep_is_held(&nf_ct_proto_mutex)
 +					 ) != proto);
 +	rcu_assign_pointer(nf_ct_l3protos[proto->l3proto],
 +			   &nf_conntrack_l3proto_generic);
 +	mutex_unlock(&nf_ct_proto_mutex);
 +
 +	synchronize_rcu();
 +	/* Remove all contrack entries for this protocol */
 +	nf_ct_iterate_destroy(kill_l3proto, (void*)proto);
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_l3proto_unregister);
  
  static struct nf_proto_net *nf_ct_l4proto_net(struct net *net,
  				const struct nf_conntrack_l4proto *l4proto)
diff --cc net/netfilter/nft_ct.c
index bbdb1e219edb,3249cc059048..000000000000
--- a/net/netfilter/nft_ct.c
+++ b/net/netfilter/nft_ct.c
@@@ -780,6 -782,189 +780,192 @@@ static struct nft_expr_type nft_notrack
  	.owner		= THIS_MODULE,
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NF_CONNTRACK_TIMEOUT
+ static int
+ nft_ct_timeout_parse_policy(void *timeouts,
+ 			    const struct nf_conntrack_l4proto *l4proto,
+ 			    struct net *net, const struct nlattr *attr)
+ {
+ 	struct nlattr **tb;
+ 	int ret = 0;
+ 
+ 	tb = kcalloc(l4proto->ctnl_timeout.nlattr_max + 1, sizeof(*tb),
+ 		     GFP_KERNEL);
+ 
+ 	if (!tb)
+ 		return -ENOMEM;
+ 
+ 	ret = nla_parse_nested(tb, l4proto->ctnl_timeout.nlattr_max,
+ 			       attr, l4proto->ctnl_timeout.nla_policy,
+ 			       NULL);
+ 	if (ret < 0)
+ 		goto err;
+ 
+ 	ret = l4proto->ctnl_timeout.nlattr_to_obj(tb, net, timeouts);
+ 
+ err:
+ 	kfree(tb);
+ 	return ret;
+ }
+ 
+ struct nft_ct_timeout_obj {
+ 	struct nf_ct_timeout    *timeout;
+ 	u8			l4proto;
+ };
+ 
+ static void nft_ct_timeout_obj_eval(struct nft_object *obj,
+ 				    struct nft_regs *regs,
+ 				    const struct nft_pktinfo *pkt)
+ {
+ 	const struct nft_ct_timeout_obj *priv = nft_obj_data(obj);
+ 	struct nf_conn *ct = (struct nf_conn *)skb_nfct(pkt->skb);
+ 	struct nf_conn_timeout *timeout;
+ 	const unsigned int *values;
+ 
+ 	if (priv->l4proto != pkt->tprot)
+ 		return;
+ 
+ 	if (!ct || nf_ct_is_template(ct) || nf_ct_is_confirmed(ct))
+ 		return;
+ 
+ 	timeout = nf_ct_timeout_find(ct);
+ 	if (!timeout) {
+ 		timeout = nf_ct_timeout_ext_add(ct, priv->timeout, GFP_ATOMIC);
+ 		if (!timeout) {
+ 			regs->verdict.code = NF_DROP;
+ 			return;
+ 		}
+ 	}
+ 
+ 	rcu_assign_pointer(timeout->timeout, priv->timeout);
+ 
+ 	/* adjust the timeout as per 'new' state. ct is unconfirmed,
+ 	 * so the current timestamp must not be added.
+ 	 */
+ 	values = nf_ct_timeout_data(timeout);
+ 	if (values)
+ 		nf_ct_refresh(ct, pkt->skb, values[0]);
+ }
+ 
+ static int nft_ct_timeout_obj_init(const struct nft_ctx *ctx,
+ 				   const struct nlattr * const tb[],
+ 				   struct nft_object *obj)
+ {
+ 	struct nft_ct_timeout_obj *priv = nft_obj_data(obj);
+ 	const struct nf_conntrack_l4proto *l4proto;
+ 	struct nf_ct_timeout *timeout;
+ 	int l3num = ctx->family;
+ 	__u8 l4num;
+ 	int ret;
+ 
+ 	if (!tb[NFTA_CT_TIMEOUT_L4PROTO] ||
+ 	    !tb[NFTA_CT_TIMEOUT_DATA])
+ 		return -EINVAL;
+ 
+ 	if (tb[NFTA_CT_TIMEOUT_L3PROTO])
+ 		l3num = ntohs(nla_get_be16(tb[NFTA_CT_TIMEOUT_L3PROTO]));
+ 
+ 	l4num = nla_get_u8(tb[NFTA_CT_TIMEOUT_L4PROTO]);
+ 	priv->l4proto = l4num;
+ 
+ 	l4proto = nf_ct_l4proto_find_get(l4num);
+ 
+ 	if (l4proto->l4proto != l4num) {
+ 		ret = -EOPNOTSUPP;
+ 		goto err_proto_put;
+ 	}
+ 
+ 	timeout = kzalloc(sizeof(struct nf_ct_timeout) +
+ 			  l4proto->ctnl_timeout.obj_size, GFP_KERNEL);
+ 	if (timeout == NULL) {
+ 		ret = -ENOMEM;
+ 		goto err_proto_put;
+ 	}
+ 
+ 	ret = nft_ct_timeout_parse_policy(&timeout->data, l4proto, ctx->net,
+ 					  tb[NFTA_CT_TIMEOUT_DATA]);
+ 	if (ret < 0)
+ 		goto err_free_timeout;
+ 
+ 	timeout->l3num = l3num;
+ 	timeout->l4proto = l4proto;
+ 
+ 	ret = nf_ct_netns_get(ctx->net, ctx->family);
+ 	if (ret < 0)
+ 		goto err_free_timeout;
+ 
+ 	priv->timeout = timeout;
+ 	return 0;
+ 
+ err_free_timeout:
+ 	kfree(timeout);
+ err_proto_put:
+ 	return ret;
+ }
+ 
+ static void nft_ct_timeout_obj_destroy(const struct nft_ctx *ctx,
+ 				       struct nft_object *obj)
+ {
+ 	struct nft_ct_timeout_obj *priv = nft_obj_data(obj);
+ 	struct nf_ct_timeout *timeout = priv->timeout;
+ 
+ 	nf_ct_untimeout(ctx->net, timeout);
+ 	nf_ct_netns_put(ctx->net, ctx->family);
+ 	kfree(priv->timeout);
+ }
+ 
+ static int nft_ct_timeout_obj_dump(struct sk_buff *skb,
+ 				   struct nft_object *obj, bool reset)
+ {
+ 	const struct nft_ct_timeout_obj *priv = nft_obj_data(obj);
+ 	const struct nf_ct_timeout *timeout = priv->timeout;
+ 	struct nlattr *nest_params;
+ 	int ret;
+ 
+ 	if (nla_put_u8(skb, NFTA_CT_TIMEOUT_L4PROTO, timeout->l4proto->l4proto) ||
+ 	    nla_put_be16(skb, NFTA_CT_TIMEOUT_L3PROTO, htons(timeout->l3num)))
+ 		return -1;
+ 
+ 	nest_params = nla_nest_start(skb, NFTA_CT_TIMEOUT_DATA | NLA_F_NESTED);
+ 	if (!nest_params)
+ 		return -1;
+ 
+ 	ret = timeout->l4proto->ctnl_timeout.obj_to_nlattr(skb, &timeout->data);
+ 	if (ret < 0)
+ 		return -1;
+ 	nla_nest_end(skb, nest_params);
+ 	return 0;
+ }
+ 
+ static const struct nla_policy nft_ct_timeout_policy[NFTA_CT_TIMEOUT_MAX + 1] = {
+ 	[NFTA_CT_TIMEOUT_L3PROTO] = {.type = NLA_U16 },
+ 	[NFTA_CT_TIMEOUT_L4PROTO] = {.type = NLA_U8 },
+ 	[NFTA_CT_TIMEOUT_DATA]	  = {.type = NLA_NESTED },
+ };
+ 
+ static struct nft_object_type nft_ct_timeout_obj_type;
+ 
+ static const struct nft_object_ops nft_ct_timeout_obj_ops = {
+ 	.type		= &nft_ct_timeout_obj_type,
+ 	.size		= sizeof(struct nft_ct_timeout_obj),
+ 	.eval		= nft_ct_timeout_obj_eval,
+ 	.init		= nft_ct_timeout_obj_init,
+ 	.destroy	= nft_ct_timeout_obj_destroy,
+ 	.dump		= nft_ct_timeout_obj_dump,
+ };
+ 
+ static struct nft_object_type nft_ct_timeout_obj_type __read_mostly = {
+ 	.type		= NFT_OBJECT_CT_TIMEOUT,
+ 	.ops		= &nft_ct_timeout_obj_ops,
+ 	.maxattr	= NFTA_CT_TIMEOUT_MAX,
+ 	.policy		= nft_ct_timeout_policy,
+ 	.owner		= THIS_MODULE,
+ };
+ #endif /* CONFIG_NF_CONNTRACK_TIMEOUT */
+ 
++>>>>>>> b184356d0a00 (netfilter: conntrack: remove module owner field)
  static int nft_ct_helper_obj_init(const struct nft_ctx *ctx,
  				  const struct nlattr * const tb[],
  				  struct nft_object *obj)
* Unmerged path include/net/netfilter/nf_conntrack_l4proto.h
* Unmerged path net/netfilter/nf_conntrack_proto.c
diff --git a/net/netfilter/nf_conntrack_proto_gre.c b/net/netfilter/nf_conntrack_proto_gre.c
index c9e1b1061af6..f069b223a2ee 100644
--- a/net/netfilter/nf_conntrack_proto_gre.c
+++ b/net/netfilter/nf_conntrack_proto_gre.c
@@ -354,7 +354,6 @@ static const struct nf_conntrack_l4proto nf_conntrack_l4proto_gre4 = {
 	.packet		 = gre_packet,
 	.new		 = gre_new,
 	.destroy	 = gre_destroy,
-	.me 		 = THIS_MODULE,
 #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
 	.tuple_to_nlattr = nf_ct_port_tuple_to_nlattr,
 	.nlattr_tuple_size = nf_ct_port_nlattr_tuple_size,
diff --git a/net/netfilter/nfnetlink_cttimeout.c b/net/netfilter/nfnetlink_cttimeout.c
index 6720dbb70442..8afe768c439c 100644
--- a/net/netfilter/nfnetlink_cttimeout.c
+++ b/net/netfilter/nfnetlink_cttimeout.c
@@ -159,7 +159,6 @@ static int cttimeout_new_timeout(struct net *net, struct sock *ctnl,
 err:
 	kfree(timeout);
 err_proto_put:
-	nf_ct_l4proto_put(l4proto);
 	return ret;
 }
 
@@ -313,7 +312,6 @@ static int ctnl_timeout_try_del(struct net *net, struct ctnl_timeout *timeout)
 	if (refcount_dec_if_one(&timeout->refcnt)) {
 		/* We are protected by nfnl mutex. */
 		list_del_rcu(&timeout->head);
-		nf_ct_l4proto_put(timeout->timeout.l4proto);
 		nf_ct_untimeout(net, &timeout->timeout);
 		kfree_rcu(timeout, rcu_head);
 	} else {
@@ -388,10 +386,8 @@ static int cttimeout_default_set(struct net *net, struct sock *ctnl,
 	if (ret < 0)
 		goto err;
 
-	nf_ct_l4proto_put(l4proto);
 	return 0;
 err:
-	nf_ct_l4proto_put(l4proto);
 	return ret;
 }
 
@@ -491,7 +487,6 @@ static int cttimeout_default_get(struct net *net, struct sock *ctnl,
 	/* this avoids a loop in nfnetlink. */
 	return ret == -EAGAIN ? -ENOBUFS : ret;
 err:
-	nf_ct_l4proto_put(l4proto);
 	return err;
 }
 
@@ -574,7 +569,6 @@ static void __net_exit cttimeout_net_exit(struct net *net)
 
 	list_for_each_entry_safe(cur, tmp, &net->nfct_timeout_list, head) {
 		list_del_rcu(&cur->head);
-		nf_ct_l4proto_put(cur->timeout.l4proto);
 
 		if (refcount_dec_and_test(&cur->refcnt))
 			kfree_rcu(cur, rcu_head);
* Unmerged path net/netfilter/nft_ct.c
