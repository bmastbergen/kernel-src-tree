netfilter: conntrack: remove pernet l4 proto register interface

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit edf0338dabf0f330873f7a9f84ea9f9ac431c0a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/edf0338d.failed

No used anymore.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit edf0338dabf0f330873f7a9f84ea9f9ac431c0a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_proto.c
diff --cc net/netfilter/nf_conntrack_proto.c
index baa1f4cdedbb,13b782cc6a7a..000000000000
--- a/net/netfilter/nf_conntrack_proto.c
+++ b/net/netfilter/nf_conntrack_proto.c
@@@ -137,21 -143,528 +137,531 @@@ nf_ct_l3proto_find_get(u_int16_t l3prot
  
  	return p;
  }
 -EXPORT_SYMBOL_GPL(nf_ct_l4proto_find_get);
 -
 -static int kill_l4proto(struct nf_conn *i, void *data)
 -{
 -	const struct nf_conntrack_l4proto *l4proto;
 -	l4proto = data;
 -	return nf_ct_protonum(i) == l4proto->l4proto;
 -}
 +EXPORT_SYMBOL_GPL(nf_ct_l3proto_find_get);
  
 -static struct nf_proto_net *nf_ct_l4proto_net(struct net *net,
 -				const struct nf_conntrack_l4proto *l4proto)
 +int
 +nf_ct_l3proto_try_module_get(unsigned short l3proto)
  {
 -	if (l4proto->get_net_proto)
 -		return l4proto->get_net_proto(net);
 -
 +	const struct nf_conntrack_l3proto *p;
 +	int ret;
 +
 +retry:	p = nf_ct_l3proto_find_get(l3proto);
 +	if (p == &nf_conntrack_l3proto_generic) {
 +		ret = request_module("nf_conntrack-%d", l3proto);
 +		if (!ret)
 +			goto retry;
 +
++<<<<<<< HEAD
 +		return -EPROTOTYPE;
++=======
+ 	return NULL;
+ }
+ 
+ static
+ int nf_ct_l4proto_register_sysctl(struct net *net,
+ 				  struct nf_proto_net *pn)
+ {
+ 	int err = 0;
+ 
+ #ifdef CONFIG_SYSCTL
+ 	if (pn->ctl_table != NULL) {
+ 		err = nf_ct_register_sysctl(net,
+ 					    &pn->ctl_table_header,
+ 					    "net/netfilter",
+ 					    pn->ctl_table);
+ 		if (err < 0) {
+ 			if (!pn->users) {
+ 				kfree(pn->ctl_table);
+ 				pn->ctl_table = NULL;
+ 			}
+ 		}
+ 	}
+ #endif /* CONFIG_SYSCTL */
+ 	return err;
+ }
+ 
+ static
+ void nf_ct_l4proto_unregister_sysctl(struct nf_proto_net *pn)
+ {
+ #ifdef CONFIG_SYSCTL
+ 	if (pn->ctl_table_header != NULL)
+ 		nf_ct_unregister_sysctl(&pn->ctl_table_header,
+ 					&pn->ctl_table,
+ 					pn->users);
+ #endif /* CONFIG_SYSCTL */
+ }
+ 
+ /* FIXME: Allow NULL functions and sub in pointers to generic for
+    them. --RR */
+ int nf_ct_l4proto_register_one(const struct nf_conntrack_l4proto *l4proto)
+ {
+ 	int ret = 0;
+ 
+ 	if ((l4proto->to_nlattr && l4proto->nlattr_size == 0) ||
+ 	    (l4proto->tuple_to_nlattr && !l4proto->nlattr_tuple_size))
+ 		return -EINVAL;
+ 
+ 	mutex_lock(&nf_ct_proto_mutex);
+ 	if (rcu_dereference_protected(
+ 			nf_ct_protos[l4proto->l4proto],
+ 			lockdep_is_held(&nf_ct_proto_mutex)
+ 			) != &nf_conntrack_l4proto_generic) {
+ 		ret = -EBUSY;
+ 		goto out_unlock;
+ 	}
+ 
+ 	rcu_assign_pointer(nf_ct_protos[l4proto->l4proto], l4proto);
+ out_unlock:
+ 	mutex_unlock(&nf_ct_proto_mutex);
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(nf_ct_l4proto_register_one);
+ 
+ static int nf_ct_l4proto_pernet_register_one(struct net *net,
+ 					     const struct nf_conntrack_l4proto *l4proto)
+ {
+ 	int ret = 0;
+ 	struct nf_proto_net *pn = NULL;
+ 
+ 	if (l4proto->init_net) {
+ 		ret = l4proto->init_net(net);
+ 		if (ret < 0)
+ 			goto out;
+ 	}
+ 
+ 	pn = nf_ct_l4proto_net(net, l4proto);
+ 	if (pn == NULL)
+ 		goto out;
+ 
+ 	ret = nf_ct_l4proto_register_sysctl(net, pn);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	pn->users++;
+ out:
+ 	return ret;
+ }
+ 
+ static void __nf_ct_l4proto_unregister_one(const struct nf_conntrack_l4proto *l4proto)
+ 
+ {
+ 	BUG_ON(l4proto->l4proto >= ARRAY_SIZE(nf_ct_protos));
+ 
+ 	BUG_ON(rcu_dereference_protected(
+ 			nf_ct_protos[l4proto->l4proto],
+ 			lockdep_is_held(&nf_ct_proto_mutex)
+ 			) != l4proto);
+ 	rcu_assign_pointer(nf_ct_protos[l4proto->l4proto],
+ 			   &nf_conntrack_l4proto_generic);
+ }
+ 
+ void nf_ct_l4proto_unregister_one(const struct nf_conntrack_l4proto *l4proto)
+ {
+ 	mutex_lock(&nf_ct_proto_mutex);
+ 	__nf_ct_l4proto_unregister_one(l4proto);
+ 	mutex_unlock(&nf_ct_proto_mutex);
+ 
+ 	synchronize_net();
+ 	/* Remove all contrack entries for this protocol */
+ 	nf_ct_iterate_destroy(kill_l4proto, (void *)l4proto);
+ }
+ EXPORT_SYMBOL_GPL(nf_ct_l4proto_unregister_one);
+ 
+ static void nf_ct_l4proto_pernet_unregister_one(struct net *net,
+ 				const struct nf_conntrack_l4proto *l4proto)
+ {
+ 	struct nf_proto_net *pn = nf_ct_l4proto_net(net, l4proto);
+ 
+ 	if (pn == NULL)
+ 		return;
+ 
+ 	pn->users--;
+ 	nf_ct_l4proto_unregister_sysctl(pn);
+ }
+ 
+ static void
+ nf_ct_l4proto_unregister(const struct nf_conntrack_l4proto * const l4proto[],
+ 			 unsigned int num_proto)
+ {
+ 	int i;
+ 
+ 	mutex_lock(&nf_ct_proto_mutex);
+ 	for (i = 0; i < num_proto; i++)
+ 		__nf_ct_l4proto_unregister_one(l4proto[i]);
+ 	mutex_unlock(&nf_ct_proto_mutex);
+ 
+ 	synchronize_net();
+ 
+ 	for (i = 0; i < num_proto; i++)
+ 		nf_ct_iterate_destroy(kill_l4proto, (void *)l4proto[i]);
+ }
+ 
+ static int
+ nf_ct_l4proto_register(const struct nf_conntrack_l4proto * const l4proto[],
+ 		       unsigned int num_proto)
+ {
+ 	int ret = -EINVAL;
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < num_proto; i++) {
+ 		ret = nf_ct_l4proto_register_one(l4proto[i]);
+ 		if (ret < 0)
+ 			break;
+ 	}
+ 	if (i != num_proto) {
+ 		pr_err("nf_conntrack: can't register l4 %d proto.\n",
+ 		       l4proto[i]->l4proto);
+ 		nf_ct_l4proto_unregister(l4proto, i);
+ 	}
+ 	return ret;
+ }
+ 
+ static void nf_ct_l4proto_pernet_unregister(struct net *net,
+ 				const struct nf_conntrack_l4proto *const l4proto[],
+ 				unsigned int num_proto)
+ {
+ 	while (num_proto-- != 0)
+ 		nf_ct_l4proto_pernet_unregister_one(net, l4proto[num_proto]);
+ }
+ 
+ static int nf_ct_l4proto_pernet_register(struct net *net,
+ 				  const struct nf_conntrack_l4proto *const l4proto[],
+ 				  unsigned int num_proto)
+ {
+ 	int ret = -EINVAL;
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < num_proto; i++) {
+ 		ret = nf_ct_l4proto_pernet_register_one(net, l4proto[i]);
+ 		if (ret < 0)
+ 			break;
+ 	}
+ 	if (i != num_proto) {
+ 		pr_err("nf_conntrack %d: pernet registration failed\n",
+ 		       l4proto[i]->l4proto);
+ 		nf_ct_l4proto_pernet_unregister(net, l4proto, i);
+ 	}
+ 	return ret;
+ }
+ 
+ static unsigned int nf_confirm(struct sk_buff *skb,
+ 			       unsigned int protoff,
+ 			       struct nf_conn *ct,
+ 			       enum ip_conntrack_info ctinfo)
+ {
+ 	const struct nf_conn_help *help;
+ 
+ 	help = nfct_help(ct);
+ 	if (help) {
+ 		const struct nf_conntrack_helper *helper;
+ 		int ret;
+ 
+ 		/* rcu_read_lock()ed by nf_hook_thresh */
+ 		helper = rcu_dereference(help->helper);
+ 		if (helper) {
+ 			ret = helper->help(skb,
+ 					   protoff,
+ 					   ct, ctinfo);
+ 			if (ret != NF_ACCEPT)
+ 				return ret;
+ 		}
+ 	}
+ 
+ 	if (test_bit(IPS_SEQ_ADJUST_BIT, &ct->status) &&
+ 	    !nf_is_loopback_packet(skb)) {
+ 		if (!nf_ct_seq_adjust(skb, ct, ctinfo, protoff)) {
+ 			NF_CT_STAT_INC_ATOMIC(nf_ct_net(ct), drop);
+ 			return NF_DROP;
+ 		}
+ 	}
+ 
+ 	/* We've seen it coming out the other side: confirm it */
+ 	return nf_conntrack_confirm(skb);
+ }
+ 
+ static unsigned int ipv4_confirm(void *priv,
+ 				 struct sk_buff *skb,
+ 				 const struct nf_hook_state *state)
+ {
+ 	enum ip_conntrack_info ctinfo;
+ 	struct nf_conn *ct;
+ 
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct || ctinfo == IP_CT_RELATED_REPLY)
+ 		return nf_conntrack_confirm(skb);
+ 
+ 	return nf_confirm(skb,
+ 			  skb_network_offset(skb) + ip_hdrlen(skb),
+ 			  ct, ctinfo);
+ }
+ 
+ static unsigned int ipv4_conntrack_in(void *priv,
+ 				      struct sk_buff *skb,
+ 				      const struct nf_hook_state *state)
+ {
+ 	return nf_conntrack_in(skb, state);
+ }
+ 
+ static unsigned int ipv4_conntrack_local(void *priv,
+ 					 struct sk_buff *skb,
+ 					 const struct nf_hook_state *state)
+ {
+ 	if (ip_is_fragment(ip_hdr(skb))) { /* IP_NODEFRAG setsockopt set */
+ 		enum ip_conntrack_info ctinfo;
+ 		struct nf_conn *tmpl;
+ 
+ 		tmpl = nf_ct_get(skb, &ctinfo);
+ 		if (tmpl && nf_ct_is_template(tmpl)) {
+ 			/* when skipping ct, clear templates to avoid fooling
+ 			 * later targets/matches
+ 			 */
+ 			skb->_nfct = 0;
+ 			nf_ct_put(tmpl);
+ 		}
+ 		return NF_ACCEPT;
+ 	}
+ 
+ 	return nf_conntrack_in(skb, state);
+ }
+ 
+ /* Connection tracking may drop packets, but never alters them, so
+  * make it the first hook.
+  */
+ static const struct nf_hook_ops ipv4_conntrack_ops[] = {
+ 	{
+ 		.hook		= ipv4_conntrack_in,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_PRE_ROUTING,
+ 		.priority	= NF_IP_PRI_CONNTRACK,
+ 	},
+ 	{
+ 		.hook		= ipv4_conntrack_local,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_LOCAL_OUT,
+ 		.priority	= NF_IP_PRI_CONNTRACK,
+ 	},
+ 	{
+ 		.hook		= ipv4_confirm,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM,
+ 	},
+ 	{
+ 		.hook		= ipv4_confirm,
+ 		.pf		= NFPROTO_IPV4,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP_PRI_CONNTRACK_CONFIRM,
+ 	},
+ };
+ 
+ /* Fast function for those who don't want to parse /proc (and I don't
+  * blame them).
+  * Reversing the socket's dst/src point of view gives us the reply
+  * mapping.
+  */
+ static int
+ getorigdst(struct sock *sk, int optval, void __user *user, int *len)
+ {
+ 	const struct inet_sock *inet = inet_sk(sk);
+ 	const struct nf_conntrack_tuple_hash *h;
+ 	struct nf_conntrack_tuple tuple;
+ 
+ 	memset(&tuple, 0, sizeof(tuple));
+ 
+ 	lock_sock(sk);
+ 	tuple.src.u3.ip = inet->inet_rcv_saddr;
+ 	tuple.src.u.tcp.port = inet->inet_sport;
+ 	tuple.dst.u3.ip = inet->inet_daddr;
+ 	tuple.dst.u.tcp.port = inet->inet_dport;
+ 	tuple.src.l3num = PF_INET;
+ 	tuple.dst.protonum = sk->sk_protocol;
+ 	release_sock(sk);
+ 
+ 	/* We only do TCP and SCTP at the moment: is there a better way? */
+ 	if (tuple.dst.protonum != IPPROTO_TCP &&
+ 	    tuple.dst.protonum != IPPROTO_SCTP) {
+ 		pr_debug("SO_ORIGINAL_DST: Not a TCP/SCTP socket\n");
+ 		return -ENOPROTOOPT;
+ 	}
+ 
+ 	if ((unsigned int)*len < sizeof(struct sockaddr_in)) {
+ 		pr_debug("SO_ORIGINAL_DST: len %d not %zu\n",
+ 			 *len, sizeof(struct sockaddr_in));
+ 		return -EINVAL;
+ 	}
+ 
+ 	h = nf_conntrack_find_get(sock_net(sk), &nf_ct_zone_dflt, &tuple);
+ 	if (h) {
+ 		struct sockaddr_in sin;
+ 		struct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);
+ 
+ 		sin.sin_family = AF_INET;
+ 		sin.sin_port = ct->tuplehash[IP_CT_DIR_ORIGINAL]
+ 			.tuple.dst.u.tcp.port;
+ 		sin.sin_addr.s_addr = ct->tuplehash[IP_CT_DIR_ORIGINAL]
+ 			.tuple.dst.u3.ip;
+ 		memset(sin.sin_zero, 0, sizeof(sin.sin_zero));
+ 
+ 		pr_debug("SO_ORIGINAL_DST: %pI4 %u\n",
+ 			 &sin.sin_addr.s_addr, ntohs(sin.sin_port));
+ 		nf_ct_put(ct);
+ 		if (copy_to_user(user, &sin, sizeof(sin)) != 0)
+ 			return -EFAULT;
+ 		else
+ 			return 0;
+ 	}
+ 	pr_debug("SO_ORIGINAL_DST: Can't find %pI4/%u-%pI4/%u.\n",
+ 		 &tuple.src.u3.ip, ntohs(tuple.src.u.tcp.port),
+ 		 &tuple.dst.u3.ip, ntohs(tuple.dst.u.tcp.port));
+ 	return -ENOENT;
+ }
+ 
+ static struct nf_sockopt_ops so_getorigdst = {
+ 	.pf		= PF_INET,
+ 	.get_optmin	= SO_ORIGINAL_DST,
+ 	.get_optmax	= SO_ORIGINAL_DST + 1,
+ 	.get		= getorigdst,
+ 	.owner		= THIS_MODULE,
+ };
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static int
+ ipv6_getorigdst(struct sock *sk, int optval, void __user *user, int *len)
+ {
+ 	struct nf_conntrack_tuple tuple = { .src.l3num = NFPROTO_IPV6 };
+ 	const struct ipv6_pinfo *inet6 = inet6_sk(sk);
+ 	const struct inet_sock *inet = inet_sk(sk);
+ 	const struct nf_conntrack_tuple_hash *h;
+ 	struct sockaddr_in6 sin6;
+ 	struct nf_conn *ct;
+ 	__be32 flow_label;
+ 	int bound_dev_if;
+ 
+ 	lock_sock(sk);
+ 	tuple.src.u3.in6 = sk->sk_v6_rcv_saddr;
+ 	tuple.src.u.tcp.port = inet->inet_sport;
+ 	tuple.dst.u3.in6 = sk->sk_v6_daddr;
+ 	tuple.dst.u.tcp.port = inet->inet_dport;
+ 	tuple.dst.protonum = sk->sk_protocol;
+ 	bound_dev_if = sk->sk_bound_dev_if;
+ 	flow_label = inet6->flow_label;
+ 	release_sock(sk);
+ 
+ 	if (tuple.dst.protonum != IPPROTO_TCP &&
+ 	    tuple.dst.protonum != IPPROTO_SCTP)
+ 		return -ENOPROTOOPT;
+ 
+ 	if (*len < 0 || (unsigned int)*len < sizeof(sin6))
+ 		return -EINVAL;
+ 
+ 	h = nf_conntrack_find_get(sock_net(sk), &nf_ct_zone_dflt, &tuple);
+ 	if (!h) {
+ 		pr_debug("IP6T_SO_ORIGINAL_DST: Can't find %pI6c/%u-%pI6c/%u.\n",
+ 			 &tuple.src.u3.ip6, ntohs(tuple.src.u.tcp.port),
+ 			 &tuple.dst.u3.ip6, ntohs(tuple.dst.u.tcp.port));
+ 		return -ENOENT;
+ 	}
+ 
+ 	ct = nf_ct_tuplehash_to_ctrack(h);
+ 
+ 	sin6.sin6_family = AF_INET6;
+ 	sin6.sin6_port = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.tcp.port;
+ 	sin6.sin6_flowinfo = flow_label & IPV6_FLOWINFO_MASK;
+ 	memcpy(&sin6.sin6_addr,
+ 	       &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.in6,
+ 	       sizeof(sin6.sin6_addr));
+ 
+ 	nf_ct_put(ct);
+ 	sin6.sin6_scope_id = ipv6_iface_scope_id(&sin6.sin6_addr, bound_dev_if);
+ 	return copy_to_user(user, &sin6, sizeof(sin6)) ? -EFAULT : 0;
+ }
+ 
+ static struct nf_sockopt_ops so_getorigdst6 = {
+ 	.pf		= NFPROTO_IPV6,
+ 	.get_optmin	= IP6T_SO_ORIGINAL_DST,
+ 	.get_optmax	= IP6T_SO_ORIGINAL_DST + 1,
+ 	.get		= ipv6_getorigdst,
+ 	.owner		= THIS_MODULE,
+ };
+ 
+ static unsigned int ipv6_confirm(void *priv,
+ 				 struct sk_buff *skb,
+ 				 const struct nf_hook_state *state)
+ {
+ 	struct nf_conn *ct;
+ 	enum ip_conntrack_info ctinfo;
+ 	unsigned char pnum = ipv6_hdr(skb)->nexthdr;
+ 	__be16 frag_off;
+ 	int protoff;
+ 
+ 	ct = nf_ct_get(skb, &ctinfo);
+ 	if (!ct || ctinfo == IP_CT_RELATED_REPLY)
+ 		return nf_conntrack_confirm(skb);
+ 
+ 	protoff = ipv6_skip_exthdr(skb, sizeof(struct ipv6hdr), &pnum,
+ 				   &frag_off);
+ 	if (protoff < 0 || (frag_off & htons(~0x7)) != 0) {
+ 		pr_debug("proto header not found\n");
+ 		return nf_conntrack_confirm(skb);
+ 	}
+ 
+ 	return nf_confirm(skb, protoff, ct, ctinfo);
+ }
+ 
+ static unsigned int ipv6_conntrack_in(void *priv,
+ 				      struct sk_buff *skb,
+ 				      const struct nf_hook_state *state)
+ {
+ 	return nf_conntrack_in(skb, state);
+ }
+ 
+ static unsigned int ipv6_conntrack_local(void *priv,
+ 					 struct sk_buff *skb,
+ 					 const struct nf_hook_state *state)
+ {
+ 	return nf_conntrack_in(skb, state);
+ }
+ 
+ static const struct nf_hook_ops ipv6_conntrack_ops[] = {
+ 	{
+ 		.hook		= ipv6_conntrack_in,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_PRE_ROUTING,
+ 		.priority	= NF_IP6_PRI_CONNTRACK,
+ 	},
+ 	{
+ 		.hook		= ipv6_conntrack_local,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_LOCAL_OUT,
+ 		.priority	= NF_IP6_PRI_CONNTRACK,
+ 	},
+ 	{
+ 		.hook		= ipv6_confirm,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_POST_ROUTING,
+ 		.priority	= NF_IP6_PRI_LAST,
+ 	},
+ 	{
+ 		.hook		= ipv6_confirm,
+ 		.pf		= NFPROTO_IPV6,
+ 		.hooknum	= NF_INET_LOCAL_IN,
+ 		.priority	= NF_IP6_PRI_LAST - 1,
+ 	},
+ };
+ #endif
+ 
+ static int nf_ct_tcp_fixup(struct nf_conn *ct, void *_nfproto)
+ {
+ 	u8 nfproto = (unsigned long)_nfproto;
+ 
+ 	if (nf_ct_l3num(ct) != nfproto)
+ 		return 0;
+ 
+ 	if (nf_ct_protonum(ct) == IPPROTO_TCP &&
+ 	    ct->proto.tcp.state == TCP_CONNTRACK_ESTABLISHED) {
+ 		ct->proto.tcp.seen[0].td_maxwin = 0;
+ 		ct->proto.tcp.seen[1].td_maxwin = 0;
++>>>>>>> edf0338dabf0 (netfilter: conntrack: remove pernet l4 proto register interface)
  	}
  
  	return 0;
diff --git a/include/net/netfilter/nf_conntrack_l4proto.h b/include/net/netfilter/nf_conntrack_l4proto.h
index 264f50873a3a..d58fecf7c6ba 100644
--- a/include/net/netfilter/nf_conntrack_l4proto.h
+++ b/include/net/netfilter/nf_conntrack_l4proto.h
@@ -117,18 +117,6 @@ const struct nf_conntrack_l4proto *nf_ct_l4proto_find_get(u_int16_t l3proto,
 						    u_int8_t l4proto);
 void nf_ct_l4proto_put(const struct nf_conntrack_l4proto *p);
 
-/* Protocol pernet registration. */
-int nf_ct_l4proto_pernet_register_one(struct net *net,
-				const struct nf_conntrack_l4proto *proto);
-void nf_ct_l4proto_pernet_unregister_one(struct net *net,
-				const struct nf_conntrack_l4proto *proto);
-int nf_ct_l4proto_pernet_register(struct net *net,
-				  const struct nf_conntrack_l4proto *const proto[],
-				  unsigned int num_proto);
-void nf_ct_l4proto_pernet_unregister(struct net *net,
-				const struct nf_conntrack_l4proto *const proto[],
-				unsigned int num_proto);
-
 /* Protocol global registration. */
 int nf_ct_l4proto_register_one(const struct nf_conntrack_l4proto *proto);
 void nf_ct_l4proto_unregister_one(const struct nf_conntrack_l4proto *proto);
* Unmerged path net/netfilter/nf_conntrack_proto.c
