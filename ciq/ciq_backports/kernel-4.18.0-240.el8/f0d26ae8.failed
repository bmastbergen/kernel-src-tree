scsi: zfcp: log FC Endpoint Security of connections

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Remus <jremus@linux.ibm.com>
commit f0d26ae847489850509b793ef3f74be62f69ab0f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f0d26ae8.failed

Log the usage of and subsequent changes in FC Endpoint Security of
connections between FCP devices and FC remote ports to the kernel ring
buffer. Activation of FC Endpoint Security is logged as informational.
Change and deactivation are logged as warning.

No logging takes place, if FC Endpoint Security is not used (i.e. never
activated) on a connection or if it does not change during reopen of a port
(e.g. due to adapter or port recovery).

Link: https://lore.kernel.org/r/20200312174505.51294-8-maier@linux.ibm.com
	Reviewed-by: Steffen Maier <maier@linux.ibm.com>
	Reviewed-by: Fedor Loshakov <loshakov@linux.ibm.com>
	Signed-off-by: Jens Remus <jremus@linux.ibm.com>
	Signed-off-by: Steffen Maier <maier@linux.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit f0d26ae847489850509b793ef3f74be62f69ab0f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/scsi/zfcp_def.h
#	drivers/s390/scsi/zfcp_fsf.c
diff --cc drivers/s390/scsi/zfcp_def.h
index 3396a47721a7,b6af4a93681c..000000000000
--- a/drivers/s390/scsi/zfcp_def.h
+++ b/drivers/s390/scsi/zfcp_def.h
@@@ -213,6 -219,8 +213,11 @@@ struct zfcp_port 
          atomic_t               erp_counter;
  	u32                    maxframe_size;
  	u32                    supported_classes;
++<<<<<<< HEAD
++=======
+ 	u32                    connection_info;
+ 	u32                    connection_info_old;
++>>>>>>> f0d26ae84748 (scsi: zfcp: log FC Endpoint Security of connections)
  	struct work_struct     gid_pn_work;
  	struct work_struct     test_link_work;
  	struct work_struct     rport_work;
diff --cc drivers/s390/scsi/zfcp_fsf.c
index aaa4066c5699,08ce0fa04665..000000000000
--- a/drivers/s390/scsi/zfcp_fsf.c
+++ b/drivers/s390/scsi/zfcp_fsf.c
@@@ -623,6 -664,83 +623,86 @@@ static void zfcp_fsf_exchange_config_da
  	}
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Mapping of FC Endpoint Security flag masks to mnemonics
+  *
+  * NOTE: Update macro ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH when making any
+  *       changes.
+  */
+ static const struct {
+ 	u32	mask;
+ 	char	*name;
+ } zfcp_fsf_fc_security_mnemonics[] = {
+ 	{ FSF_FC_SECURITY_AUTH,		"Authentication" },
+ 	{ FSF_FC_SECURITY_ENC_FCSP2 |
+ 	  FSF_FC_SECURITY_ENC_ERAS,	"Encryption" },
+ };
+ 
+ /* maximum strlen(zfcp_fsf_fc_security_mnemonics[...].name) + 1 */
+ #define ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH 15
+ 
+ /**
+  * zfcp_fsf_scnprint_fc_security() - translate FC Endpoint Security flags into
+  *                                   mnemonics and place in a buffer
+  * @buf        : the buffer to place the translated FC Endpoint Security flag(s)
+  *               into
+  * @size       : the size of the buffer, including the trailing null space
+  * @fc_security: one or more FC Endpoint Security flags, or zero
+  * @fmt        : specifies whether a list or a single item is to be put into the
+  *               buffer
+  *
+  * The Fibre Channel (FC) Endpoint Security flags are translated into mnemonics.
+  * If the FC Endpoint Security flags are zero "none" is placed into the buffer.
+  *
+  * With ZFCP_FSF_PRINT_FMT_LIST the mnemonics are placed as a list separated by
+  * a comma followed by a space into the buffer. If one or more FC Endpoint
+  * Security flags cannot be translated into a mnemonic, as they are undefined
+  * in zfcp_fsf_fc_security_mnemonics, their bitwise ORed value in hexadecimal
+  * representation is placed into the buffer.
+  *
+  * With ZFCP_FSF_PRINT_FMT_SINGLEITEM only one single mnemonic is placed into
+  * the buffer. If the FC Endpoint Security flag cannot be translated, as it is
+  * undefined in zfcp_fsf_fc_security_mnemonics, its value in hexadecimal
+  * representation is placed into the buffer. If more than one FC Endpoint
+  * Security flag was specified, their value in hexadecimal representation is
+  * placed into the buffer. The macro ZFCP_FSF_MAX_FC_SECURITY_MNEMONIC_LENGTH
+  * can be used to define a buffer that is large enough to hold one mnemonic.
+  *
+  * Return: The number of characters written into buf not including the trailing
+  *         '\0'. If size is == 0 the function returns 0.
+  */
+ ssize_t zfcp_fsf_scnprint_fc_security(char *buf, size_t size, u32 fc_security,
+ 				      enum zfcp_fsf_print_fmt fmt)
+ {
+ 	const char *prefix = "";
+ 	ssize_t len = 0;
+ 	int i;
+ 
+ 	if (fc_security == 0)
+ 		return scnprintf(buf, size, "none");
+ 	if (fmt == ZFCP_FSF_PRINT_FMT_SINGLEITEM && hweight32(fc_security) != 1)
+ 		return scnprintf(buf, size, "0x%08x", fc_security);
+ 
+ 	for (i = 0; i < ARRAY_SIZE(zfcp_fsf_fc_security_mnemonics); i++) {
+ 		if (!(fc_security & zfcp_fsf_fc_security_mnemonics[i].mask))
+ 			continue;
+ 
+ 		len += scnprintf(buf + len, size - len, "%s%s", prefix,
+ 				 zfcp_fsf_fc_security_mnemonics[i].name);
+ 		prefix = ", ";
+ 		fc_security &= ~zfcp_fsf_fc_security_mnemonics[i].mask;
+ 	}
+ 
+ 	if (fc_security != 0)
+ 		len += scnprintf(buf + len, size - len, "%s0x%08x",
+ 				 prefix, fc_security);
+ 
+ 	return len;
+ }
+ 
++>>>>>>> f0d26ae84748 (scsi: zfcp: log FC Endpoint Security of connections)
  static void zfcp_fsf_exchange_port_evaluate(struct zfcp_fsf_req *req)
  {
  	struct zfcp_adapter *adapter = req->adapter;
@@@ -1424,6 -1659,11 +1548,14 @@@ static void zfcp_fsf_open_port_handler(
  		break;
  	case FSF_GOOD:
  		port->handle = header->port_handle;
++<<<<<<< HEAD
++=======
+ 		if (adapter->adapter_features & FSF_FEATURE_FC_SECURITY)
+ 			port->connection_info = bottom->connection_info;
+ 		else
+ 			port->connection_info = 0;
+ 		zfcp_fsf_log_port_fc_security(port);
++>>>>>>> f0d26ae84748 (scsi: zfcp: log FC Endpoint Security of connections)
  		atomic_or(ZFCP_STATUS_COMMON_OPEN |
  				ZFCP_STATUS_PORT_PHYS_OPEN, &port->status);
  		atomic_andnot(ZFCP_STATUS_COMMON_ACCESS_BOXED,
* Unmerged path drivers/s390/scsi/zfcp_def.h
* Unmerged path drivers/s390/scsi/zfcp_fsf.c
