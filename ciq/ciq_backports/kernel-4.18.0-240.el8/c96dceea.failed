jbd2: do not clear the BH_Mapped flag when forgetting a metadata buffer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author zhangyi (F) <yi.zhang@huawei.com>
commit c96dceeabf765d0b1b1f29c3bf50a5c01315b820
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c96dceea.failed

Commit 904cdbd41d74 ("jbd2: clear dirty flag when revoking a buffer from
an older transaction") set the BH_Freed flag when forgetting a metadata
buffer which belongs to the committing transaction, it indicate the
committing process clear dirty bits when it is done with the buffer. But
it also clear the BH_Mapped flag at the same time, which may trigger
below NULL pointer oops when block_size < PAGE_SIZE.

rmdir 1             kjournald2                 mkdir 2
                    jbd2_journal_commit_transaction
		    commit transaction N
jbd2_journal_forget
set_buffer_freed(bh1)
                    jbd2_journal_commit_transaction
                     commit transaction N+1
                     ...
                     clear_buffer_mapped(bh1)
                                               ext4_getblk(bh2 ummapped)
                                               ...
                                               grow_dev_page
                                                init_page_buffers
                                                 bh1->b_private=NULL
                                                 bh2->b_private=NULL
                     jbd2_journal_put_journal_head(jh1)
                      __journal_remove_journal_head(hb1)
		       jh1 is NULL and trigger oops

*) Dir entry block bh1 and bh2 belongs to one page, and the bh2 has
   already been unmapped.

For the metadata buffer we forgetting, we should always keep the mapped
flag and clear the dirty flags is enough, so this patch pick out the
these buffers and keep their BH_Mapped flag.

Link: https://lore.kernel.org/r/20200213063821.30455-3-yi.zhang@huawei.com
Fixes: 904cdbd41d74 ("jbd2: clear dirty flag when revoking a buffer from an older transaction")
	Reviewed-by: Jan Kara <jack@suse.cz>
	Signed-off-by: zhangyi (F) <yi.zhang@huawei.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@kernel.org
(cherry picked from commit c96dceeabf765d0b1b1f29c3bf50a5c01315b820)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/jbd2/commit.c
diff --cc fs/jbd2/commit.c
index 132fb92098c7,27373f5792a4..000000000000
--- a/fs/jbd2/commit.c
+++ b/fs/jbd2/commit.c
@@@ -972,29 -976,33 +972,59 @@@ restart_loop
  		 * it. */
  
  		/*
++<<<<<<< HEAD
 +		* A buffer which has been freed while still being journaled by
 +		* a previous transaction.
 +		*/
 +		if (buffer_freed(bh)) {
 +			/*
 +			 * If the running transaction is the one containing
 +			 * "add to orphan" operation (b_next_transaction !=
 +			 * NULL), we have to wait for that transaction to
 +			 * commit before we can really get rid of the buffer.
 +			 * So just clear b_modified to not confuse transaction
 +			 * credit accounting and refile the buffer to
 +			 * BJ_Forget of the running transaction. If the just
 +			 * committed transaction contains "add to orphan"
 +			 * operation, we can completely invalidate the buffer
 +			 * now. We are rather through in that since the
 +			 * buffer may be still accessible when blocksize <
 +			 * pagesize and it is attached to the last partial
 +			 * page.
 +			 */
 +			jh->b_modified = 0;
 +			if (!jh->b_next_transaction) {
 +				clear_buffer_freed(bh);
 +				clear_buffer_jbddirty(bh);
++=======
+ 		 * A buffer which has been freed while still being journaled
+ 		 * by a previous transaction, refile the buffer to BJ_Forget of
+ 		 * the running transaction. If the just committed transaction
+ 		 * contains "add to orphan" operation, we can completely
+ 		 * invalidate the buffer now. We are rather through in that
+ 		 * since the buffer may be still accessible when blocksize <
+ 		 * pagesize and it is attached to the last partial page.
+ 		 */
+ 		if (buffer_freed(bh) && !jh->b_next_transaction) {
+ 			struct address_space *mapping;
+ 
+ 			clear_buffer_freed(bh);
+ 			clear_buffer_jbddirty(bh);
+ 
+ 			/*
+ 			 * Block device buffers need to stay mapped all the
+ 			 * time, so it is enough to clear buffer_jbddirty and
+ 			 * buffer_freed bits. For the file mapping buffers (i.e.
+ 			 * journalled data) we need to unmap buffer and clear
+ 			 * more bits. We also need to be careful about the check
+ 			 * because the data page mapping can get cleared under
+ 			 * out hands, which alse need not to clear more bits
+ 			 * because the page and buffers will be freed and can
+ 			 * never be reused once we are done with them.
+ 			 */
+ 			mapping = READ_ONCE(bh->b_page->mapping);
+ 			if (mapping && !sb_is_blkdev_sb(mapping->host->i_sb)) {
++>>>>>>> c96dceeabf76 (jbd2: do not clear the BH_Mapped flag when forgetting a metadata buffer)
  				clear_buffer_mapped(bh);
  				clear_buffer_new(bh);
  				clear_buffer_req(bh);
* Unmerged path fs/jbd2/commit.c
