drm/amd/display: Fix incorrectly pruned modes with deep color

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Stylon Wang <stylon.wang@amd.com>
commit cbd14ae7ea934fd9d9f95103a0601a7fea243573
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/cbd14ae7.failed

[Why]
When "max bpc" is set to enable deep color, some modes are removed from
the list if they fail validation on max bpc. These modes should be kept
if they validates fine with lower bpc.

[How]
- Retry with lower bpc in mode validation.
- Same in atomic commit to apply working bpc, not necessarily max bpc.

	Signed-off-by: Stylon Wang <stylon.wang@amd.com>
	Reviewed-by: Nicholas Kazlauskas <Nicholas.Kazlauskas@amd.com>
	Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit cbd14ae7ea934fd9d9f95103a0601a7fea243573)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
diff --cc drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
index 3a8489bf308b,dfb6fbaf01e9..000000000000
--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
@@@ -3140,17 -3840,27 +3140,18 @@@ static void update_stream_scaling_setti
  
  static enum dc_color_depth
  convert_color_depth_from_display_info(const struct drm_connector *connector,
++<<<<<<< HEAD
 +				      const struct drm_connector_state *state)
++=======
+ 				      bool is_y420, int requested_bpc)
++>>>>>>> cbd14ae7ea93 (drm/amd/display: Fix incorrectly pruned modes with deep color)
  {
 -	uint8_t bpc;
 +	uint8_t bpc = (uint8_t)connector->display_info.bpc;
  
 -	if (is_y420) {
 -		bpc = 8;
 -
 -		/* Cap display bpc based on HDMI 2.0 HF-VSDB */
 -		if (connector->display_info.hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_48)
 -			bpc = 16;
 -		else if (connector->display_info.hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_36)
 -			bpc = 12;
 -		else if (connector->display_info.hdmi.y420_dc_modes & DRM_EDID_YCBCR420_DC_30)
 -			bpc = 10;
 -	} else {
 -		bpc = (uint8_t)connector->display_info.bpc;
 -		/* Assume 8 bpc by default if no bpc is specified. */
 -		bpc = bpc ? bpc : 8;
 -	}
 +	/* Assume 8 bpc by default if no bpc is specified. */
 +	bpc = bpc ? bpc : 8;
  
- 	if (!state)
- 		state = connector->state;
- 
- 	if (state) {
+ 	if (requested_bpc > 0) {
  		/*
  		 * Cap display bpc based on the user requested value.
  		 *
@@@ -3309,7 -4022,9 +3311,13 @@@ static void fill_stream_properties_from
  
  	timing_out->timing_3d_format = TIMING_3D_FORMAT_NONE;
  	timing_out->display_color_depth = convert_color_depth_from_display_info(
++<<<<<<< HEAD
 +		connector, connector_state);
++=======
+ 		connector,
+ 		(timing_out->pixel_encoding == PIXEL_ENCODING_YCBCR420),
+ 		requested_bpc);
++>>>>>>> cbd14ae7ea93 (drm/amd/display: Fix incorrectly pruned modes with deep color)
  	timing_out->scan_type = SCANNING_TYPE_NODATA;
  	timing_out->hdmi_vic = 0;
  
@@@ -3580,24 -4316,34 +3589,24 @@@ create_stream_for_sink(struct amdgpu_dm
  	*/
  	if (!scale || mode_refresh != preferred_refresh)
  		fill_stream_properties_from_drm_display_mode(stream,
- 			&mode, &aconnector->base, con_state, NULL);
+ 			&mode, &aconnector->base, con_state, NULL, requested_bpc);
  	else
  		fill_stream_properties_from_drm_display_mode(stream,
- 			&mode, &aconnector->base, con_state, old_stream);
+ 			&mode, &aconnector->base, con_state, old_stream, requested_bpc);
  
 -	stream->timing.flags.DSC = 0;
 -
 -	if (aconnector->dc_link && sink->sink_signal == SIGNAL_TYPE_DISPLAY_PORT) {
 -#if defined(CONFIG_DRM_AMD_DC_DCN)
 -		dc_dsc_parse_dsc_dpcd(aconnector->dc_link->ctx->dc,
 -				      aconnector->dc_link->dpcd_caps.dsc_caps.dsc_basic_caps.raw,
 -				      aconnector->dc_link->dpcd_caps.dsc_caps.dsc_ext_caps.raw,
 -				      &dsc_caps);
 -#endif
 -		link_bandwidth_kbps = dc_link_bandwidth_kbps(aconnector->dc_link,
 -							     dc_link_get_link_cap(aconnector->dc_link));
 -
 -#if defined(CONFIG_DRM_AMD_DC_DCN)
 -		if (dsc_caps.is_dsc_supported)
 -			if (dc_dsc_compute_config(aconnector->dc_link->ctx->dc->res_pool->dscs[0],
 -						  &dsc_caps,
 -						  aconnector->dc_link->ctx->dc->debug.dsc_min_slice_height_override,
 -						  link_bandwidth_kbps,
 -						  &stream->timing,
 -						  &stream->timing.dsc_cfg))
 -				stream->timing.flags.DSC = 1;
 +#ifdef CONFIG_DRM_AMD_DC_DSC_SUPPORT
 +	/* stream->timing.flags.DSC = 0; */
 +        /*  */
 +	/* if (aconnector->dc_link && */
 +	/* 		aconnector->dc_link->connector_signal == SIGNAL_TYPE_DISPLAY_PORT #<{(|&& */
 +	/* 		aconnector->dc_link->dpcd_caps.dsc_caps.dsc_basic_caps.is_dsc_supported|)}>#) */
 +	/* 	if (dc_dsc_compute_config(aconnector->dc_link->ctx->dc, */
 +	/* 			&aconnector->dc_link->dpcd_caps.dsc_caps, */
 +	/* 			dc_link_bandwidth_kbps(aconnector->dc_link, dc_link_get_link_cap(aconnector->dc_link)), */
 +	/* 			&stream->timing, */
 +	/* 			&stream->timing.dsc_cfg)) */
 +	/* 		stream->timing.flags.DSC = 1; */
  #endif
 -	}
  
  	update_stream_scaling_settings(&mode, dm_state, stream);
  
@@@ -4070,24 -4906,11 +4117,22 @@@ enum drm_mode_status amdgpu_dm_connecto
  		goto fail;
  	}
  
- 	stream = create_stream_for_sink(aconnector, mode, NULL, NULL);
- 	if (stream == NULL) {
- 		DRM_ERROR("Failed to create stream for sink!\n");
- 		goto fail;
- 	}
- 
- 	dc_result = dc_validate_stream(adev->dm.dc, stream);
- 
- 	if (dc_result == DC_OK)
+ 	stream = create_validate_stream_for_sink(aconnector, mode, NULL, NULL);
+ 	if (stream) {
+ 		dc_stream_release(stream);
  		result = MODE_OK;
++<<<<<<< HEAD
 +	else
 +		DRM_DEBUG_KMS("Mode %dx%d (clk %d) failed DC validation with error %d\n",
 +			      mode->vdisplay,
 +			      mode->hdisplay,
 +			      mode->clock,
 +			      dc_result);
 +
 +	dc_stream_release(stream);
++=======
+ 	}
++>>>>>>> cbd14ae7ea93 (drm/amd/display: Fix incorrectly pruned modes with deep color)
  
  fail:
  	/* TODO: error handling*/
@@@ -4367,6 -5212,46 +4412,49 @@@ static int dm_encoder_helper_atomic_che
  					  struct drm_crtc_state *crtc_state,
  					  struct drm_connector_state *conn_state)
  {
++<<<<<<< HEAD
++=======
+ 	struct drm_atomic_state *state = crtc_state->state;
+ 	struct drm_connector *connector = conn_state->connector;
+ 	struct amdgpu_dm_connector *aconnector = to_amdgpu_dm_connector(connector);
+ 	struct dm_connector_state *dm_new_connector_state = to_dm_connector_state(conn_state);
+ 	const struct drm_display_mode *adjusted_mode = &crtc_state->adjusted_mode;
+ 	struct drm_dp_mst_topology_mgr *mst_mgr;
+ 	struct drm_dp_mst_port *mst_port;
+ 	enum dc_color_depth color_depth;
+ 	int clock, bpp = 0;
+ 	bool is_y420 = false;
+ 
+ 	if (!aconnector->port || !aconnector->dc_sink)
+ 		return 0;
+ 
+ 	mst_port = aconnector->port;
+ 	mst_mgr = &aconnector->mst_port->mst_mgr;
+ 
+ 	if (!crtc_state->connectors_changed && !crtc_state->mode_changed)
+ 		return 0;
+ 
+ 	if (!state->duplicated) {
+ 		int max_bpc = conn_state->max_requested_bpc;
+ 		is_y420 = drm_mode_is_420_also(&connector->display_info, adjusted_mode) &&
+ 				aconnector->force_yuv420_output;
+ 		color_depth = convert_color_depth_from_display_info(connector,
+ 								    is_y420,
+ 								    max_bpc);
+ 		bpp = convert_dc_color_depth_into_bpc(color_depth) * 3;
+ 		clock = adjusted_mode->clock;
+ 		dm_new_connector_state->pbn = drm_dp_calc_pbn_mode(clock, bpp, false);
+ 	}
+ 	dm_new_connector_state->vcpi_slots = drm_dp_atomic_find_vcpi_slots(state,
+ 									   mst_mgr,
+ 									   mst_port,
+ 									   dm_new_connector_state->pbn,
+ 									   0);
+ 	if (dm_new_connector_state->vcpi_slots < 0) {
+ 		DRM_DEBUG_ATOMIC("failed finding vcpi slots: %d\n", (int)dm_new_connector_state->vcpi_slots);
+ 		return dm_new_connector_state->vcpi_slots;
+ 	}
++>>>>>>> cbd14ae7ea93 (drm/amd/display: Fix incorrectly pruned modes with deep color)
  	return 0;
  }
  
* Unmerged path drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
