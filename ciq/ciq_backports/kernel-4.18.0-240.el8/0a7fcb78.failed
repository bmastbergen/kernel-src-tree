net/mlx5e: Support inner header rewrite with goto action

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paul Blakey <paulb@mellanox.com>
commit 0a7fcb78cc21d339c4eba2827df846e69cec1d07
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0a7fcb78.failed

The hardware supports header rewrite of outer headers only.
To perform header rewrite on inner headers, we must first
decapsulate the packet.

Currently, the hardware decap action is explicitly set by the tc
tunnel_key unset action. However, with goto action the user won't
use the tunnel_key unset action. In addition, header rewrites actions
will not apply to the inner header as done by the software model.

To support this, we will map each tunnel matches seen on a tc rule to
a unique tunnel id, implicity add a decap action on tc chain 0 flows,
and mark the packets with this unique tunnel id. Tunnel matches on
the decapsulated tunnel on later chains will match on this unique id
instead of the actual packet.

We will also use this mapping to restore the tunnel info metadata
on miss.

	Signed-off-by: Paul Blakey <paulb@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Reviewed-by: Oz Shlomo <ozsh@mellanox.com>
	Reviewed-by: Mark Bloch <markb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 0a7fcb78cc21d339c4eba2827df846e69cec1d07)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 2ba74ea284e2,3f1b8124ef26..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -54,9 -54,14 +54,12 @@@
  #include "fs_core.h"
  #include "en/port.h"
  #include "en/tc_tun.h"
+ #include "en/mapping.h"
  #include "lib/devcom.h"
  #include "lib/geneve.h"
 -#include "diag/en_tc_tracepoint.h"
  
+ #define MLX5_MH_ACT_SZ MLX5_UN_SZ_BYTES(set_action_in_add_action_in_auto)
+ 
  struct mlx5_nic_flow_attr {
  	u32 action;
  	u32 flow_tag;
@@@ -149,6 -156,105 +154,108 @@@ struct mlx5e_tc_flow_parse_attr 
  #define MLX5E_TC_TABLE_NUM_GROUPS 4
  #define MLX5E_TC_TABLE_MAX_GROUP_SIZE BIT(16)
  
++<<<<<<< HEAD
++=======
+ struct tunnel_match_key {
+ 	struct flow_dissector_key_control enc_control;
+ 	struct flow_dissector_key_keyid enc_key_id;
+ 	struct flow_dissector_key_ports enc_tp;
+ 	struct flow_dissector_key_ip enc_ip;
+ 	union {
+ 		struct flow_dissector_key_ipv4_addrs enc_ipv4;
+ 		struct flow_dissector_key_ipv6_addrs enc_ipv6;
+ 	};
+ 
+ 	int filter_ifindex;
+ };
+ 
+ /* Tunnel_id mapping is TUNNEL_INFO_BITS + ENC_OPTS_BITS.
+  * Upper TUNNEL_INFO_BITS for general tunnel info.
+  * Lower ENC_OPTS_BITS bits for enc_opts.
+  */
+ #define TUNNEL_INFO_BITS 6
+ #define TUNNEL_INFO_BITS_MASK GENMASK(TUNNEL_INFO_BITS - 1, 0)
+ #define ENC_OPTS_BITS 2
+ #define ENC_OPTS_BITS_MASK GENMASK(ENC_OPTS_BITS - 1, 0)
+ #define TUNNEL_ID_BITS (TUNNEL_INFO_BITS + ENC_OPTS_BITS)
+ #define TUNNEL_ID_MASK GENMASK(TUNNEL_ID_BITS - 1, 0)
+ 
+ struct mlx5e_tc_attr_to_reg_mapping mlx5e_tc_attr_to_reg_mappings[] = {
+ 	[CHAIN_TO_REG] = {
+ 		.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_0,
+ 		.moffset = 0,
+ 		.mlen = 2,
+ 	},
+ 	[TUNNEL_TO_REG] = {
+ 		.mfield = MLX5_ACTION_IN_FIELD_METADATA_REG_C_1,
+ 		.moffset = 3,
+ 		.mlen = 1,
+ 		.soffset = MLX5_BYTE_OFF(fte_match_param,
+ 					 misc_parameters_2.metadata_reg_c_1),
+ 	},
+ };
+ 
+ static void mlx5e_put_flow_tunnel_id(struct mlx5e_tc_flow *flow);
+ 
+ void
+ mlx5e_tc_match_to_reg_match(struct mlx5_flow_spec *spec,
+ 			    enum mlx5e_tc_attr_to_reg type,
+ 			    u32 data,
+ 			    u32 mask)
+ {
+ 	int soffset = mlx5e_tc_attr_to_reg_mappings[type].soffset;
+ 	int match_len = mlx5e_tc_attr_to_reg_mappings[type].mlen;
+ 	void *headers_c = spec->match_criteria;
+ 	void *headers_v = spec->match_value;
+ 	void *fmask, *fval;
+ 
+ 	fmask = headers_c + soffset;
+ 	fval = headers_v + soffset;
+ 
+ 	mask = cpu_to_be32(mask) >> (32 - (match_len * 8));
+ 	data = cpu_to_be32(data) >> (32 - (match_len * 8));
+ 
+ 	memcpy(fmask, &mask, match_len);
+ 	memcpy(fval, &data, match_len);
+ 
+ 	spec->match_criteria_enable |= MLX5_MATCH_MISC_PARAMETERS_2;
+ }
+ 
+ int
+ mlx5e_tc_match_to_reg_set(struct mlx5_core_dev *mdev,
+ 			  struct mlx5e_tc_mod_hdr_acts *mod_hdr_acts,
+ 			  enum mlx5e_tc_attr_to_reg type,
+ 			  u32 data)
+ {
+ 	int moffset = mlx5e_tc_attr_to_reg_mappings[type].moffset;
+ 	int mfield = mlx5e_tc_attr_to_reg_mappings[type].mfield;
+ 	int mlen = mlx5e_tc_attr_to_reg_mappings[type].mlen;
+ 	char *modact;
+ 	int err;
+ 
+ 	err = alloc_mod_hdr_actions(mdev, MLX5_FLOW_NAMESPACE_FDB,
+ 				    mod_hdr_acts);
+ 	if (err)
+ 		return err;
+ 
+ 	modact = mod_hdr_acts->actions +
+ 		 (mod_hdr_acts->num_actions * MLX5_MH_ACT_SZ);
+ 
+ 	/* Firmware has 5bit length field and 0 means 32bits */
+ 	if (mlen == 4)
+ 		mlen = 0;
+ 
+ 	MLX5_SET(set_action_in, modact, action_type, MLX5_ACTION_TYPE_SET);
+ 	MLX5_SET(set_action_in, modact, field, mfield);
+ 	MLX5_SET(set_action_in, modact, offset, moffset * 8);
+ 	MLX5_SET(set_action_in, modact, length, mlen * 8);
+ 	MLX5_SET(set_action_in, modact, data, data);
+ 	mod_hdr_acts->num_actions++;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 0a7fcb78cc21 (net/mlx5e: Support inner header rewrite with goto action)
  struct mlx5e_hairpin {
  	struct mlx5_hairpin *pair;
  
@@@ -3186,11 -3568,12 +3520,17 @@@ static int parse_tc_fdb_actions(struct 
  	struct mlx5e_tc_flow_parse_attr *parse_attr = attr->parse_attr;
  	struct mlx5e_rep_priv *rpriv = priv->ppriv;
  	const struct ip_tunnel_info *info = NULL;
 -	int ifindexes[MLX5_MAX_FLOW_FWD_VPORTS];
  	bool ft_flow = mlx5e_is_ft_flow(flow);
  	const struct flow_action_entry *act;
++<<<<<<< HEAD
 +	bool encap = false;
 +	u32 action = 0;
 +	int err, i;
++=======
+ 	bool encap = false, decap = false;
+ 	u32 action = attr->action;
+ 	int err, i, if_count = 0;
++>>>>>>> 0a7fcb78cc21 (net/mlx5e: Support inner header rewrite with goto action)
  
  	if (!flow_action_has_entries(flow_action))
  		return -EINVAL;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
index 0b15bcfe09fe,2fab76b0bec5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
@@@ -91,6 -91,21 +91,24 @@@ int mlx5e_tc_num_filters(struct mlx5e_p
  
  void mlx5e_tc_reoffload_flows_work(struct work_struct *work);
  
++<<<<<<< HEAD
++=======
+ enum mlx5e_tc_attr_to_reg {
+ 	CHAIN_TO_REG,
+ 	TUNNEL_TO_REG,
+ };
+ 
+ struct mlx5e_tc_attr_to_reg_mapping {
+ 	int mfield; /* rewrite field */
+ 	int moffset; /* offset of mfield */
+ 	int mlen; /* bytes to rewrite/match */
+ 
+ 	int soffset; /* offset of spec for match */
+ };
+ 
+ extern struct mlx5e_tc_attr_to_reg_mapping mlx5e_tc_attr_to_reg_mappings[];
+ 
++>>>>>>> 0a7fcb78cc21 (net/mlx5e: Support inner header rewrite with goto action)
  bool mlx5e_is_valid_eswitch_fwd_dev(struct mlx5e_priv *priv,
  				    struct net_device *out_dev);
  
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
index a8f7d6030f73..2bbdbdc8ea7e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.h
@@ -81,6 +81,11 @@ struct mlx5_rep_uplink_priv {
 	struct mutex                unready_flows_lock;
 	struct list_head            unready_flows;
 	struct work_struct          reoffload_flows_work;
+
+	/* maps tun_info to a unique id*/
+	struct mapping_ctx *tunnel_mapping;
+	/* maps tun_enc_opts to a unique id*/
+	struct mapping_ctx *tunnel_enc_opts_mapping;
 };
 
 struct mlx5e_rep_priv {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.h
