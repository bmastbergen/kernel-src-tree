ipv6: Extend notifier info for multipath routes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ido Schimmel <idosch@mellanox.com>
commit d4b96c7b51e8fe9bcf94c8ab8cd5717d2f005b04
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d4b96c7b.failed

Extend the IPv6 FIB notifier info with number of sibling routes being
notified.

This will later allow listeners to process one notification for a
multipath routes instead of N, where N is the number of nexthops.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Reviewed-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d4b96c7b51e8fe9bcf94c8ab8cd5717d2f005b04)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip6_fib.h
diff --cc include/net/ip6_fib.h
index 390067ba9e95,7c3d5ab05879..000000000000
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@@ -422,17 -424,41 +424,31 @@@ int fib6_add(struct fib6_node *root, st
  	     struct nl_info *info, struct netlink_ext_ack *extack);
  int fib6_del(struct fib6_info *rt, struct nl_info *info);
  
 -static inline
 -void rt6_get_prefsrc(const struct rt6_info *rt, struct in6_addr *addr)
 +static inline struct net_device *fib6_info_nh_dev(const struct fib6_info *f6i)
  {
 -	const struct fib6_info *from;
 -
 -	rcu_read_lock();
 -
 -	from = rcu_dereference(rt->from);
 -	if (from) {
 -		*addr = from->fib6_prefsrc.addr;
 -	} else {
 -		struct in6_addr in6_zero = {};
 -
 -		*addr = in6_zero;
 -	}
 -
 -	rcu_read_unlock();
 +	return f6i->fib6_nh.nh_dev;
  }
  
 -int fib6_nh_init(struct net *net, struct fib6_nh *fib6_nh,
 -		 struct fib6_config *cfg, gfp_t gfp_flags,
 -		 struct netlink_ext_ack *extack);
 -void fib6_nh_release(struct fib6_nh *fib6_nh);
 +static inline
 +struct lwtunnel_state *fib6_info_nh_lwt(const struct fib6_info *f6i)
 +{
 +	return f6i->fib6_nh.nh_lwtstate;
 +}
  
++<<<<<<< HEAD
++=======
+ int call_fib6_entry_notifiers(struct net *net,
+ 			      enum fib_event_type event_type,
+ 			      struct fib6_info *rt,
+ 			      struct netlink_ext_ack *extack);
+ int call_fib6_multipath_entry_notifiers(struct net *net,
+ 					enum fib_event_type event_type,
+ 					struct fib6_info *rt,
+ 					unsigned int nsiblings,
+ 					struct netlink_ext_ack *extack);
+ void fib6_rt_update(struct net *net, struct fib6_info *rt,
+ 		    struct nl_info *info);
++>>>>>>> d4b96c7b51e8 (ipv6: Extend notifier info for multipath routes)
  void inet6_rt_notify(int event, struct fib6_info *rt, struct nl_info *info,
  		     unsigned int flags);
  
* Unmerged path include/net/ip6_fib.h
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index f7014e41a454..148c6ea8972a 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -415,6 +415,23 @@ static int call_fib6_entry_notifiers(struct net *net,
 	return call_fib6_notifiers(net, event_type, &info.info);
 }
 
+int call_fib6_multipath_entry_notifiers(struct net *net,
+					enum fib_event_type event_type,
+					struct fib6_info *rt,
+					unsigned int nsiblings,
+					struct netlink_ext_ack *extack)
+{
+	struct fib6_entry_notifier_info info = {
+		.info.extack = extack,
+		.rt = rt,
+		.nsiblings = nsiblings,
+		.multipath_rt = true,
+	};
+
+	rt->fib6_table->fib_seq++;
+	return call_fib6_notifiers(net, event_type, &info.info);
+}
+
 struct fib6_dump_arg {
 	struct net *net;
 	struct notifier_block *nb;
