fs: move guard_bio_eod() after bio_set_op_attrs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 83c9c547168e8b914ea6398430473a4de68c52cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/83c9c547.failed

Commit 85a8ce62c2ea ("block: add bio_truncate to fix guard_bio_eod")
adds bio_truncate() for handling bio EOD. However, bio_truncate()
doesn't use the passed 'op' parameter from guard_bio_eod's callers.

So bio_trunacate() may retrieve wrong 'op', and zering pages may
not be done for READ bio.

Fixes this issue by moving guard_bio_eod() after bio_set_op_attrs()
in submit_bh_wbc() so that bio_truncate() can always retrieve correct
op info.

Meantime remove the 'op' parameter from guard_bio_eod() because it isn't
used any more.

	Cc: Carlos Maiolino <cmaiolino@redhat.com>
	Cc: linux-fsdevel@vger.kernel.org
Fixes: 85a8ce62c2ea ("block: add bio_truncate to fix guard_bio_eod")
	Signed-off-by: Ming Lei <ming.lei@redhat.com>

Fold in kerneldoc and bio_op() change.

	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 83c9c547168e8b914ea6398430473a4de68c52cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/bio.c
diff --cc block/bio.c
index 3e689ffa003b,94d697217887..000000000000
--- a/block/bio.c
+++ b/block/bio.c
@@@ -551,6 -538,55 +551,58 @@@ void zero_fill_bio_iter(struct bio *bio
  }
  EXPORT_SYMBOL(zero_fill_bio_iter);
  
++<<<<<<< HEAD
++=======
+ /**
+  * bio_truncate - truncate the bio to small size of @new_size
+  * @bio:	the bio to be truncated
+  * @new_size:	new size for truncating the bio
+  *
+  * Description:
+  *   Truncate the bio to new size of @new_size. If bio_op(bio) is
+  *   REQ_OP_READ, zero the truncated part. This function should only
+  *   be used for handling corner cases, such as bio eod.
+  */
+ void bio_truncate(struct bio *bio, unsigned new_size)
+ {
+ 	struct bio_vec bv;
+ 	struct bvec_iter iter;
+ 	unsigned int done = 0;
+ 	bool truncated = false;
+ 
+ 	if (new_size >= bio->bi_iter.bi_size)
+ 		return;
+ 
+ 	if (bio_op(bio) != REQ_OP_READ)
+ 		goto exit;
+ 
+ 	bio_for_each_segment(bv, bio, iter) {
+ 		if (done + bv.bv_len > new_size) {
+ 			unsigned offset;
+ 
+ 			if (!truncated)
+ 				offset = new_size - done;
+ 			else
+ 				offset = 0;
+ 			zero_user(bv.bv_page, offset, bv.bv_len - offset);
+ 			truncated = true;
+ 		}
+ 		done += bv.bv_len;
+ 	}
+ 
+  exit:
+ 	/*
+ 	 * Don't touch bvec table here and make it really immutable, since
+ 	 * fs bio user has to retrieve all pages via bio_for_each_segment_all
+ 	 * in its .end_bio() callback.
+ 	 *
+ 	 * It is enough to truncate bio by updating .bi_size since we can make
+ 	 * correct bvec with the updated .bi_size for drivers.
+ 	 */
+ 	bio->bi_iter.bi_size = new_size;
+ }
+ 
++>>>>>>> 83c9c547168e (fs: move guard_bio_eod() after bio_set_op_attrs)
  /**
   * bio_put - release a reference to a bio
   * @bio:   bio to release reference to
* Unmerged path block/bio.c
diff --git a/fs/buffer.c b/fs/buffer.c
index 25002a11c7c4..668294d155d8 100644
--- a/fs/buffer.c
+++ b/fs/buffer.c
@@ -2990,7 +2990,7 @@ static void end_bio_bh_io_sync(struct bio *bio)
  * errors, this only handles the "we need to be able to
  * do IO at the final sector" case.
  */
-void guard_bio_eod(int op, struct bio *bio)
+void guard_bio_eod(struct bio *bio)
 {
 	sector_t maxsector;
 	struct bio_vec *bvec = bio_last_bvec_all(bio);
@@ -3074,15 +3074,15 @@ static int submit_bh_wbc(int op, int op_flags, struct buffer_head *bh,
 	bio->bi_end_io = end_bio_bh_io_sync;
 	bio->bi_private = bh;
 
-	/* Take care of bh's that straddle the end of the device */
-	guard_bio_eod(op, bio);
-
 	if (buffer_meta(bh))
 		op_flags |= REQ_META;
 	if (buffer_prio(bh))
 		op_flags |= REQ_PRIO;
 	bio_set_op_attrs(bio, op, op_flags);
 
+	/* Take care of bh's that straddle the end of the device */
+	guard_bio_eod(bio);
+
 	if (wbc) {
 		wbc_init_bio(wbc, bio);
 		wbc_account_io(wbc, bh->b_page, bh->b_size);
diff --git a/fs/internal.h b/fs/internal.h
index e54ad4361d0d..a0b79e8b1c9a 100644
--- a/fs/internal.h
+++ b/fs/internal.h
@@ -40,7 +40,7 @@ static inline int __sync_blockdev(struct block_device *bdev, int wait)
 /*
  * buffer.c
  */
-extern void guard_bio_eod(int rw, struct bio *bio);
+extern void guard_bio_eod(struct bio *bio);
 extern int __block_write_begin_int(struct page *page, loff_t pos, unsigned len,
 		get_block_t *get_block, struct iomap *iomap);
 
diff --git a/fs/mpage.c b/fs/mpage.c
index b73638db9866..4731c779a660 100644
--- a/fs/mpage.c
+++ b/fs/mpage.c
@@ -62,7 +62,7 @@ static struct bio *mpage_bio_submit(int op, int op_flags, struct bio *bio)
 {
 	bio->bi_end_io = mpage_end_io;
 	bio_set_op_attrs(bio, op, op_flags);
-	guard_bio_eod(op, bio);
+	guard_bio_eod(bio);
 	submit_bio(bio);
 	return NULL;
 }
