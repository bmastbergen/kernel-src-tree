iwlwifi: scan: remove support for fw scan api v11

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Tova Mussai <tova.mussai@intel.com>
commit 5b5b9d35e05a01afacda745a0877105d33f7a768
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5b5b9d35.failed

The fw already support scan api v12,
v11 is not needed anymore.

	Signed-off-by: Tova Mussai <tova.mussai@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
(cherry picked from commit 5b5b9d35e05a01afacda745a0877105d33f7a768)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
#	drivers/net/wireless/intel/iwlwifi/mvm/scan.c
diff --cc drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
index c0750ced5ac2,1b2b5fa56e19..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
+++ b/drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
@@@ -831,6 -878,176 +831,179 @@@ struct iwl_scan_req_umac 
  #define IWL_SCAN_REQ_UMAC_SIZE_V1 36
  
  /**
++<<<<<<< HEAD
++=======
+  * struct iwl_scan_probe_params_v3
+  * @preq: scan probe request params
+  * @ssid_num: number of valid SSIDs in direct scan array
+  * @short_ssid_num: number of valid short SSIDs in short ssid array
+  * @bssid_num: number of valid bssid in bssids array
+  * @reserved: reserved
+  * @direct_scan: list of ssids
+  * @short_ssid: array of short ssids
+  * @bssid_array: array of bssids
+  */
+ struct iwl_scan_probe_params_v3 {
+ 	struct iwl_scan_probe_req preq;
+ 	u8 ssid_num;
+ 	u8 short_ssid_num;
+ 	u8 bssid_num;
+ 	u8 reserved;
+ 	struct iwl_ssid_ie direct_scan[PROBE_OPTION_MAX];
+ 	__le32 short_ssid[SCAN_SHORT_SSID_MAX_SIZE];
+ 	u8 bssid_array[ETH_ALEN][SCAN_BSSID_MAX_SIZE];
+ } __packed; /* SCAN_PROBE_PARAMS_API_S_VER_3 */
+ 
+ /**
+  * struct iwl_scan_probe_params_v4
+  * @preq: scan probe request params
+  * @short_ssid_num: number of valid short SSIDs in short ssid array
+  * @bssid_num: number of valid bssid in bssids array
+  * @reserved: reserved
+  * @direct_scan: list of ssids
+  * @short_ssid: array of short ssids
+  * @bssid_array: array of bssids
+  */
+ struct iwl_scan_probe_params_v4 {
+ 	struct iwl_scan_probe_req preq;
+ 	u8 short_ssid_num;
+ 	u8 bssid_num;
+ 	__le16 reserved;
+ 	struct iwl_ssid_ie direct_scan[PROBE_OPTION_MAX];
+ 	__le32 short_ssid[SCAN_SHORT_SSID_MAX_SIZE];
+ 	u8 bssid_array[ETH_ALEN][SCAN_BSSID_MAX_SIZE];
+ } __packed; /* SCAN_PROBE_PARAMS_API_S_VER_4 */
+ 
+ #define SCAN_MAX_NUM_CHANS_V3 67
+ 
+ /**
+  * struct iwl_scan_channel_params_v4
+  * @flags: channel flags &enum iwl_scan_channel_flags
+  * @count: num of channels in scan request
+  * @num_of_aps_override: override the number of APs the FW uses to calculate
+  *	dwell time when adaptive dwell is used
+  * @reserved: for future use and alignment
+  * @channel_config: array of explicit channel configurations
+  *                  for 2.4Ghz and 5.2Ghz bands
+  * @adwell_ch_override_bitmap: when using adaptive dwell, override the number
+  *	of APs value with &num_of_aps_override for the channel.
+  *	To cast channel to index, use &iwl_mvm_scan_ch_and_band_to_idx
+  */
+ struct iwl_scan_channel_params_v4 {
+ 	u8 flags;
+ 	u8 count;
+ 	u8 num_of_aps_override;
+ 	u8 reserved;
+ 	struct iwl_scan_channel_cfg_umac channel_config[SCAN_MAX_NUM_CHANS_V3];
+ 	u8 adwell_ch_override_bitmap[16];
+ } __packed; /* SCAN_CHANNEL_PARAMS_API_S_VER_4 also
+ 	       SCAN_CHANNEL_PARAMS_API_S_VER_5 */
+ /**
+  * struct iwl_scan_general_params_v10
+  * @flags: &enum iwl_umac_scan_flags
+  * @reserved: reserved for future
+  * @scan_start_mac_id: report the scan start TSF time according to this mac TSF
+  * @active_dwell: dwell time for active scan per LMAC
+  * @adwell_default_2g: adaptive dwell default number of APs
+  *                        for 2.4GHz channel
+  * @adwell_default_5g: adaptive dwell default number of APs
+  *                        for 5GHz channels
+  * @adwell_default_social_chn: adaptive dwell default number of
+  *                             APs per social channel
+  * @reserved1: reserved for future
+  * @adwell_max_budget: the maximal number of TUs that adaptive dwell
+  *                     can add to the total scan time
+  * @max_out_of_time: max out of serving channel time, per LMAC
+  * @suspend_time: max suspend time, per LMAC
+  * @scan_priority: priority of the request
+  * @passive_dwell: continues dwell time for passive channel
+  *                 (without adaptive dwell)
+  * @num_of_fragments: number of fragments needed for full fragmented
+  *                    scan coverage.
+  */
+ struct iwl_scan_general_params_v10 {
+ 	__le16 flags;
+ 	u8 reserved;
+ 	u8 scan_start_mac_id;
+ 	u8 active_dwell[SCAN_TWO_LMACS];
+ 	u8 adwell_default_2g;
+ 	u8 adwell_default_5g;
+ 	u8 adwell_default_social_chn;
+ 	u8 reserved1;
+ 	__le16 adwell_max_budget;
+ 	__le32 max_out_of_time[SCAN_TWO_LMACS];
+ 	__le32 suspend_time[SCAN_TWO_LMACS];
+ 	__le32 scan_priority;
+ 	u8 passive_dwell[SCAN_TWO_LMACS];
+ 	u8 num_of_fragments[SCAN_TWO_LMACS];
+ } __packed; /* SCAN_GENERAL_PARAMS_API_S_VER_10 */
+ 
+ /**
+  * struct iwl_scan_periodic_parms_v1
+  * @schedule: can scheduling parameter
+  * @delay: initial delay of the periodic scan in seconds
+  * @reserved: reserved for future
+  */
+ struct iwl_scan_periodic_parms_v1 {
+ 	struct iwl_scan_umac_schedule schedule[IWL_MAX_SCHED_SCAN_PLANS];
+ 	__le16 delay;
+ 	__le16 reserved;
+ } __packed; /* SCAN_PERIODIC_PARAMS_API_S_VER_1 */
+ 
+ /**
+  * struct iwl_scan_req_params_v12
+  * @general_params: &struct iwl_scan_general_params_v10
+  * @channel_params: &struct iwl_scan_channel_params_v4
+  * @periodic_params: &struct iwl_scan_periodic_parms_v1
+  * @probe_params: &struct iwl_scan_probe_params_v3
+  */
+ struct iwl_scan_req_params_v12 {
+ 	struct iwl_scan_general_params_v10 general_params;
+ 	struct iwl_scan_channel_params_v4 channel_params;
+ 	struct iwl_scan_periodic_parms_v1 periodic_params;
+ 	struct iwl_scan_probe_params_v3 probe_params;
+ } __packed; /* SCAN_REQUEST_PARAMS_API_S_VER_12 */
+ 
+ /**
+  * struct iwl_scan_req_params_v13
+  * @general_params: &struct iwl_scan_general_params_v10
+  * @channel_params: &struct iwl_scan_channel_params_v4
+  * @periodic_params: &struct iwl_scan_periodic_parms_v1
+  * @probe_params: &struct iwl_scan_probe_params_v4
+  */
+ struct iwl_scan_req_params_v13 {
+ 	struct iwl_scan_general_params_v10 general_params;
+ 	struct iwl_scan_channel_params_v4 channel_params;
+ 	struct iwl_scan_periodic_parms_v1 periodic_params;
+ 	struct iwl_scan_probe_params_v4 probe_params;
+ } __packed; /* SCAN_REQUEST_PARAMS_API_S_VER_13 */
+ 
+ /**
+  * struct iwl_scan_req_umac_v12
+  * @uid: scan id, &enum iwl_umac_scan_uid_offsets
+  * @ooc_priority: out of channel priority - &enum iwl_scan_priority
+  * @scan_params: scan parameters
+  */
+ struct iwl_scan_req_umac_v12 {
+ 	__le32 uid;
+ 	__le32 ooc_priority;
+ 	struct iwl_scan_req_params_v12 scan_params;
+ } __packed; /* SCAN_REQUEST_CMD_UMAC_API_S_VER_12 */
+ 
+ /**
+  * struct iwl_scan_req_umac_v13
+  * @uid: scan id, &enum iwl_umac_scan_uid_offsets
+  * @ooc_priority: out of channel priority - &enum iwl_scan_priority
+  * @scan_params: scan parameters
+  */
+ struct iwl_scan_req_umac_v13 {
+ 	__le32 uid;
+ 	__le32 ooc_priority;
+ 	struct iwl_scan_req_params_v13 scan_params;
+ } __packed; /* SCAN_REQUEST_CMD_UMAC_API_S_VER_13 */
+ 
+ /**
++>>>>>>> 5b5b9d35e05a (iwlwifi: scan: remove support for fw scan api v11)
   * struct iwl_umac_scan_abort
   * @uid: scan id, &enum iwl_umac_scan_uid_offsets
   * @flags: reserved
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/scan.c
index 5973517b74a9,c0c89d460700..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
@@@ -1634,6 -1867,129 +1634,132 @@@ static int iwl_mvm_scan_umac(struct iwl
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ iwl_mvm_scan_umac_fill_general_p_v10(struct iwl_mvm *mvm,
+ 				     struct iwl_mvm_scan_params *params,
+ 				     struct ieee80211_vif *vif,
+ 				     struct iwl_scan_general_params_v10 *gp,
+ 				     u16 gen_flags)
+ {
+ 	struct iwl_mvm_vif *scan_vif = iwl_mvm_vif_from_mac80211(vif);
+ 
+ 	iwl_mvm_scan_umac_dwell_v10(mvm, gp, params);
+ 
+ 	gp->flags = cpu_to_le16(gen_flags);
+ 
+ 	if (gen_flags & IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC1)
+ 		gp->num_of_fragments[SCAN_LB_LMAC_IDX] = IWL_SCAN_NUM_OF_FRAGS;
+ 	if (gen_flags & IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC2)
+ 		gp->num_of_fragments[SCAN_HB_LMAC_IDX] = IWL_SCAN_NUM_OF_FRAGS;
+ 
+ 	gp->scan_start_mac_id = scan_vif->id;
+ }
+ 
+ static void
+ iwl_mvm_scan_umac_fill_probe_p_v3(struct iwl_mvm_scan_params *params,
+ 				  struct iwl_scan_probe_params_v3 *pp)
+ {
+ 	pp->preq = params->preq;
+ 	pp->ssid_num = params->n_ssids;
+ 	iwl_scan_build_ssids(params, pp->direct_scan, NULL);
+ }
+ 
+ static void
+ iwl_mvm_scan_umac_fill_probe_p_v4(struct iwl_mvm_scan_params *params,
+ 				  struct iwl_scan_probe_params_v4 *pp,
+ 				  u32 *bitmap_ssid)
+ {
+ 	pp->preq = params->preq;
+ 	iwl_scan_build_ssids(params, pp->direct_scan, bitmap_ssid);
+ }
+ 
+ static void
+ iwl_mvm_scan_umac_fill_ch_p_v4(struct iwl_mvm *mvm,
+ 			       struct iwl_mvm_scan_params *params,
+ 			       struct ieee80211_vif *vif,
+ 			       struct iwl_scan_channel_params_v4 *cp,
+ 			       u32 channel_cfg_flags)
+ {
+ 	cp->flags = iwl_mvm_scan_umac_chan_flags_v2(mvm, params, vif);
+ 	cp->count = params->n_channels;
+ 	cp->num_of_aps_override = IWL_SCAN_ADWELL_DEFAULT_N_APS_OVERRIDE;
+ 
+ 	iwl_mvm_umac_scan_cfg_channels_v4(mvm, params->channels, cp,
+ 					  params->n_channels,
+ 					  channel_cfg_flags,
+ 					  vif->type);
+ }
+ 
+ 
+ static int iwl_mvm_scan_umac_v12(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+ 				 struct iwl_mvm_scan_params *params, int type,
+ 				 int uid)
+ {
+ 	struct iwl_scan_req_umac_v12 *cmd = mvm->scan_cmd;
+ 	struct iwl_scan_req_params_v12 *scan_p = &cmd->scan_params;
+ 	int ret;
+ 	u16 gen_flags;
+ 
+ 	mvm->scan_uid_status[uid] = type;
+ 
+ 	cmd->ooc_priority = cpu_to_le32(iwl_mvm_scan_umac_ooc_priority(params));
+ 	cmd->uid = cpu_to_le32(uid);
+ 
+ 	gen_flags = iwl_mvm_scan_umac_flags_v2(mvm, params, vif, type);
+ 	iwl_mvm_scan_umac_fill_general_p_v10(mvm, params, vif,
+ 					     &scan_p->general_params,
+ 					     gen_flags);
+ 
+ 	 ret = iwl_mvm_fill_scan_sched_params(params,
+ 					      scan_p->periodic_params.schedule,
+ 					      &scan_p->periodic_params.delay);
+ 	if (ret)
+ 		return ret;
+ 
+ 	iwl_mvm_scan_umac_fill_probe_p_v3(params, &scan_p->probe_params);
+ 	iwl_mvm_scan_umac_fill_ch_p_v4(mvm, params, vif,
+ 				       &scan_p->channel_params, 0);
+ 
+ 	return 0;
+ }
+ 
+ static int iwl_mvm_scan_umac_v13(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+ 				 struct iwl_mvm_scan_params *params, int type,
+ 				 int uid)
+ {
+ 	struct iwl_scan_req_umac_v13 *cmd = mvm->scan_cmd;
+ 	struct iwl_scan_req_params_v13 *scan_p = &cmd->scan_params;
+ 	int ret;
+ 	u16 gen_flags;
+ 	u32 bitmap_ssid = 0;
+ 
+ 	mvm->scan_uid_status[uid] = type;
+ 
+ 	cmd->ooc_priority = cpu_to_le32(iwl_mvm_scan_umac_ooc_priority(params));
+ 	cmd->uid = cpu_to_le32(uid);
+ 
+ 	gen_flags = iwl_mvm_scan_umac_flags_v2(mvm, params, vif, type);
+ 	iwl_mvm_scan_umac_fill_general_p_v10(mvm, params, vif,
+ 					     &scan_p->general_params,
+ 					     gen_flags);
+ 
+ 	 ret = iwl_mvm_fill_scan_sched_params(params,
+ 					      scan_p->periodic_params.schedule,
+ 					      &scan_p->periodic_params.delay);
+ 	if (ret)
+ 		return ret;
+ 
+ 	iwl_mvm_scan_umac_fill_probe_p_v4(params, &scan_p->probe_params,
+ 					  &bitmap_ssid);
+ 	iwl_mvm_scan_umac_fill_ch_p_v4(mvm, params, vif,
+ 				       &scan_p->channel_params, bitmap_ssid);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 5b5b9d35e05a (iwlwifi: scan: remove support for fw scan api v11)
  static int iwl_mvm_num_scans(struct iwl_mvm *mvm)
  {
  	return hweight32(mvm->scan_status & IWL_MVM_SCAN_MASK);
@@@ -1736,6 -2092,23 +1862,26 @@@ static void iwl_mvm_fill_scan_type(stru
  	}
  }
  
++<<<<<<< HEAD
++=======
+ struct iwl_scan_umac_handler {
+ 	u8 version;
+ 	int (*handler)(struct iwl_mvm *mvm, struct ieee80211_vif *vif,
+ 		       struct iwl_mvm_scan_params *params, int type, int uid);
+ };
+ 
+ #define IWL_SCAN_UMAC_HANDLER(_ver) {		\
+ 	.version = _ver,			\
+ 	.handler = iwl_mvm_scan_umac_v##_ver,	\
+ }
+ 
+ static const struct iwl_scan_umac_handler iwl_scan_umac_handlers[] = {
+ 	/* set the newest version first to shorten the list traverse time */
+ 	IWL_SCAN_UMAC_HANDLER(13),
+ 	IWL_SCAN_UMAC_HANDLER(12),
+ };
+ 
++>>>>>>> 5b5b9d35e05a (iwlwifi: scan: remove support for fw scan api v11)
  static int iwl_mvm_build_scan_cmd(struct iwl_mvm *mvm,
  				  struct ieee80211_vif *vif,
  				  struct iwl_host_cmd *hcmd,
@@@ -2057,10 -2456,30 +2203,27 @@@ static int iwl_mvm_scan_stop_wait(struc
  				     1 * HZ);
  }
  
++<<<<<<< HEAD
++=======
+ #define IWL_SCAN_REQ_UMAC_HANDLE_SIZE(_ver) {				\
+ 	case (_ver): return sizeof(struct iwl_scan_req_umac_v##_ver);	\
+ }
+ 
+ static int iwl_scan_req_umac_get_size(u8 scan_ver)
+ {
+ 	switch (scan_ver) {
+ 		IWL_SCAN_REQ_UMAC_HANDLE_SIZE(13);
+ 		IWL_SCAN_REQ_UMAC_HANDLE_SIZE(12);
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 5b5b9d35e05a (iwlwifi: scan: remove support for fw scan api v11)
  int iwl_mvm_scan_size(struct iwl_mvm *mvm)
  {
 -	int base_size, tail_size;
 -	u8 scan_ver = iwl_mvm_lookup_cmd_ver(mvm->fw, IWL_ALWAYS_LONG_GROUP,
 -					     SCAN_REQ_UMAC);
 -
 -	base_size = iwl_scan_req_umac_get_size(scan_ver);
 -	if (base_size)
 -		return base_size;
 -
 +	int base_size = IWL_SCAN_REQ_UMAC_SIZE_V1;
 +	int tail_size;
  
  	if (iwl_mvm_is_adaptive_dwell_v2_supported(mvm))
  		base_size = IWL_SCAN_REQ_UMAC_SIZE_V8;
* Unmerged path drivers/net/wireless/intel/iwlwifi/fw/api/scan.h
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/scan.c
