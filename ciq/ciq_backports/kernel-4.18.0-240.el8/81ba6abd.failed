block: loop: mark bvec as ITER_BVEC_FLAG_NO_REF

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 81ba6abd2bcd2812974bd3a4c43d1d032acfa751
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/81ba6abd.failed

loop is one block device, for any bio submitted to this device,
the upper layer does guarantee that pages added to loop's bio won't
go away when the bio is in-flight.

So mark loop's bvec as ITER_BVEC_FLAG_NO_REF then get_page/put_page
can be saved for serving loop's IO.

	Cc: linux-fsdevel@vger.kernel.org
	Cc: Christoph Hellwig <hch@infradead.org>
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 81ba6abd2bcd2812974bd3a4c43d1d032acfa751)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/loop.c
diff --cc drivers/block/loop.c
index 528a17eaf418,102d79575895..000000000000
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@@ -555,7 -563,7 +563,11 @@@ static int lo_rw_aio(struct loop_devic
  	}
  	atomic_set(&cmd->ref, 2);
  
++<<<<<<< HEAD
 +	iov_iter_bvec(&iter, rw, bvec, segments, blk_rq_bytes(rq));
++=======
+ 	loop_iov_iter_bvec(&iter, rw, bvec, nr_bvec, blk_rq_bytes(rq));
++>>>>>>> 81ba6abd2bcd (block: loop: mark bvec as ITER_BVEC_FLAG_NO_REF)
  	iter.iov_offset = offset;
  
  	cmd->iocb.ki_pos = pos;
* Unmerged path drivers/block/loop.c
