KVM: x86: Initialize tdp_level during vCPU creation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 7d2e8748af62b0de7c7bbcb0d62f937e88fd7027
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7d2e8748.failed

Initialize vcpu->arch.tdp_level during vCPU creation to avoid consuming
garbage if userspace calls KVM_RUN without first calling KVM_SET_CPUID.

Fixes: e93fd3b3e89e9 ("KVM: x86/mmu: Capture TDP level when updating CPUID")
	Reported-by: syzbot+904752567107eefb728c@syzkaller.appspotmail.com
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200527085400.23759-1-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 7d2e8748af62b0de7c7bbcb0d62f937e88fd7027)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index c6d2c69f3cd9,329bdd2eb2cf..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -9196,36 -9348,92 +9196,103 @@@ static void fx_init(struct kvm_vcpu *vc
  	vcpu->arch.cr0 |= X86_CR0_ET;
  }
  
 -int kvm_arch_vcpu_precreate(struct kvm *kvm, unsigned int id)
 +void kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)
  {
 -	if (kvm_check_tsc_unstable() && atomic_read(&kvm->online_vcpus) != 0)
 -		pr_warn_once("kvm: SMP vm created on host with unstable TSC; "
 -			     "guest TSC will not be reliable\n");
 +	void *wbinvd_dirty_mask = vcpu->arch.wbinvd_dirty_mask;
 +	struct gfn_to_pfn_cache *cache = &vcpu->arch.st.cache;
  
 -	return 0;
 +	kvm_release_pfn(cache->pfn, cache->dirty, cache);
 +
 +	kvmclock_reset(vcpu);
 +
 +	kvm_x86_ops->vcpu_free(vcpu);
 +	free_cpumask_var(wbinvd_dirty_mask);
  }
  
 -int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)
 +struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,
 +						unsigned int id)
  {
 -	struct page *page;
 -	int r;
 +	struct kvm_vcpu *vcpu;
  
 -	if (!irqchip_in_kernel(vcpu->kvm) || kvm_vcpu_is_reset_bsp(vcpu))
 -		vcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;
 -	else
 -		vcpu->arch.mp_state = KVM_MP_STATE_UNINITIALIZED;
 +	if (kvm_check_tsc_unstable() && atomic_read(&kvm->online_vcpus) != 0)
 +		printk_once(KERN_WARNING
 +		"kvm: SMP vm created on host with unstable TSC; "
 +		"guest TSC will not be reliable\n");
  
 -	kvm_set_tsc_khz(vcpu, max_tsc_khz);
 +	vcpu = kvm_x86_ops->vcpu_create(kvm, id);
  
++<<<<<<< HEAD
 +	return vcpu;
 +}
++=======
+ 	r = kvm_mmu_create(vcpu);
+ 	if (r < 0)
+ 		return r;
+ 
+ 	if (irqchip_in_kernel(vcpu->kvm)) {
+ 		r = kvm_create_lapic(vcpu, lapic_timer_advance_ns);
+ 		if (r < 0)
+ 			goto fail_mmu_destroy;
+ 		if (kvm_apicv_activated(vcpu->kvm))
+ 			vcpu->arch.apicv_active = true;
+ 	} else
+ 		static_key_slow_inc(&kvm_no_apic_vcpu);
+ 
+ 	r = -ENOMEM;
+ 
+ 	page = alloc_page(GFP_KERNEL | __GFP_ZERO);
+ 	if (!page)
+ 		goto fail_free_lapic;
+ 	vcpu->arch.pio_data = page_address(page);
+ 
+ 	vcpu->arch.mce_banks = kzalloc(KVM_MAX_MCE_BANKS * sizeof(u64) * 4,
+ 				       GFP_KERNEL_ACCOUNT);
+ 	if (!vcpu->arch.mce_banks)
+ 		goto fail_free_pio_data;
+ 	vcpu->arch.mcg_cap = KVM_MAX_MCE_BANKS;
+ 
+ 	if (!zalloc_cpumask_var(&vcpu->arch.wbinvd_dirty_mask,
+ 				GFP_KERNEL_ACCOUNT))
+ 		goto fail_free_mce_banks;
+ 
+ 	if (!alloc_emulate_ctxt(vcpu))
+ 		goto free_wbinvd_dirty_mask;
+ 
+ 	vcpu->arch.user_fpu = kmem_cache_zalloc(x86_fpu_cache,
+ 						GFP_KERNEL_ACCOUNT);
+ 	if (!vcpu->arch.user_fpu) {
+ 		pr_err("kvm: failed to allocate userspace's fpu\n");
+ 		goto free_emulate_ctxt;
+ 	}
+ 
+ 	vcpu->arch.guest_fpu = kmem_cache_zalloc(x86_fpu_cache,
+ 						 GFP_KERNEL_ACCOUNT);
+ 	if (!vcpu->arch.guest_fpu) {
+ 		pr_err("kvm: failed to allocate vcpu's fpu\n");
+ 		goto free_user_fpu;
+ 	}
+ 	fx_init(vcpu);
+ 
+ 	vcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);
+ 	vcpu->arch.tdp_level = kvm_x86_ops.get_tdp_level(vcpu);
+ 
+ 	vcpu->arch.pat = MSR_IA32_CR_PAT_DEFAULT;
+ 
+ 	kvm_async_pf_hash_reset(vcpu);
+ 	kvm_pmu_init(vcpu);
+ 
+ 	vcpu->arch.pending_external_vector = -1;
+ 	vcpu->arch.preempted_in_kernel = false;
+ 
+ 	kvm_hv_vcpu_init(vcpu);
+ 
+ 	r = kvm_x86_ops.vcpu_create(vcpu);
+ 	if (r)
+ 		goto free_guest_fpu;
++>>>>>>> 7d2e8748af62 (KVM: x86: Initialize tdp_level during vCPU creation)
  
 +int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)
 +{
  	vcpu->arch.arch_capabilities = kvm_get_arch_capabilities();
  	vcpu->arch.msr_platform_info = MSR_PLATFORM_INFO_CPUID_FAULT;
  	kvm_vcpu_mtrr_init(vcpu);
* Unmerged path arch/x86/kvm/x86.c
