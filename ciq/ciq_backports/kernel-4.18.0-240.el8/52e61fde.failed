scsi: zfcp: Move fc_host updates during xport data handling into fenced function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Benjamin Block <bblock@linux.ibm.com>
commit 52e61fde5ec95cb4011784fb0bc6b436e16fcaa8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/52e61fde.failed

When executing exchange port data for a FCP device for the first time, or
after an adapter recovery, we update several properties of the fibre
channel host object which represents that FCP device.

When moving the scsi host object allocation and registration - and thus
also the fibre channel host object allocation - to after the first exchange
config and exchange port data, this is not possible for the former case.

Move all these update into separate, and fenced function that first checks
whether the scsi host object already exists or not, before making the
updates.

During the first ever exchange port data in the adapter life cycle this
will make the exchange port data handler skip over this update step, but we
can repeat it later, after we allocated the scsi host object.

For any further recovery of that adapter the work flow is only changed
slightly because then the scsi host object already exists and we don't free
it until we release the adapter completely at the end of its life cycle.

Link: https://lore.kernel.org/r/ae454c2dc6da0b02907c489af91d0b211d331825.1588956679.git.bblock@linux.ibm.com
	Reviewed-by: Steffen Maier <maier@linux.ibm.com>
	Signed-off-by: Benjamin Block <bblock@linux.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 52e61fde5ec95cb4011784fb0bc6b436e16fcaa8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/scsi/zfcp_ext.h
#	drivers/s390/scsi/zfcp_fsf.c
#	drivers/s390/scsi/zfcp_scsi.c
diff --cc drivers/s390/scsi/zfcp_ext.h
index f75d5680e5ba,5dc9bdc5803f..000000000000
--- a/drivers/s390/scsi/zfcp_ext.h
+++ b/drivers/s390/scsi/zfcp_ext.h
@@@ -157,6 -172,13 +157,16 @@@ extern void zfcp_scsi_schedule_rport_bl
  extern void zfcp_scsi_schedule_rports_block(struct zfcp_adapter *);
  extern void zfcp_scsi_set_prot(struct zfcp_adapter *);
  extern void zfcp_scsi_dif_sense_error(struct scsi_cmnd *, int);
++<<<<<<< HEAD
++=======
+ extern void zfcp_scsi_shost_update_config_data(
+ 	struct zfcp_adapter *const adapter,
+ 	const struct fsf_qtcb_bottom_config *const bottom,
+ 	const bool bottom_incomplete);
+ extern void zfcp_scsi_shost_update_port_data(
+ 	struct zfcp_adapter *const adapter,
+ 	const struct fsf_qtcb_bottom_port *const bottom);
++>>>>>>> 52e61fde5ec9 (scsi: zfcp: Move fc_host updates during xport data handling into fenced function)
  
  /* zfcp_sysfs.c */
  extern const struct attribute_group *zfcp_unit_attr_groups[];
diff --cc drivers/s390/scsi/zfcp_fsf.c
index 1ed6f3c18039,bfb567a1d7bf..000000000000
--- a/drivers/s390/scsi/zfcp_fsf.c
+++ b/drivers/s390/scsi/zfcp_fsf.c
@@@ -648,17 -729,12 +647,26 @@@ static void zfcp_fsf_exchange_port_eval
  	if (req->data)
  		memcpy(req->data, bottom, sizeof(*bottom));
  
++<<<<<<< HEAD
 +	if (adapter->connection_features & FSF_FEATURE_NPIV_MODE) {
 +		fc_host_permanent_port_name(shost) = bottom->wwpn;
 +	} else
 +		fc_host_permanent_port_name(shost) = fc_host_port_name(shost);
 +	fc_host_maxframe_size(shost) = bottom->maximum_frame_size;
 +	fc_host_supported_speeds(shost) =
 +		zfcp_fsf_convert_portspeed(bottom->supported_speed);
 +	memcpy(fc_host_supported_fc4s(shost), bottom->supported_fc4_types,
 +	       FC_FC4_LIST_SIZE);
 +	memcpy(fc_host_active_fc4s(shost), bottom->active_fc4_types,
 +	       FC_FC4_LIST_SIZE);
++=======
+ 	if (adapter->adapter_features & FSF_FEATURE_FC_SECURITY)
+ 		adapter->fc_security_algorithms =
+ 			bottom->fc_security_algorithms;
+ 	else
+ 		adapter->fc_security_algorithms = 0;
+ 	zfcp_fsf_dbf_adapter_fc_security(adapter, req);
++>>>>>>> 52e61fde5ec9 (scsi: zfcp: Move fc_host updates during xport data handling into fenced function)
  }
  
  static void zfcp_fsf_exchange_port_data_handler(struct zfcp_fsf_req *req)
@@@ -670,12 -749,24 +678,28 @@@
  
  	switch (qtcb->header.fsf_status) {
  	case FSF_GOOD:
++<<<<<<< HEAD
++=======
+ 		/*
+ 		 * usually we wait with an update till the cache is too old,
+ 		 * but because we have the data available, update it anyway
+ 		 */
+ 		zfcp_diag_update_xdata(diag_hdr, bottom, false);
+ 
+ 		zfcp_scsi_shost_update_port_data(req->adapter, bottom);
++>>>>>>> 52e61fde5ec9 (scsi: zfcp: Move fc_host updates during xport data handling into fenced function)
  		zfcp_fsf_exchange_port_evaluate(req);
  		break;
  	case FSF_EXCHANGE_CONFIG_DATA_INCOMPLETE:
 -		zfcp_diag_update_xdata(diag_hdr, bottom, true);
 -		req->status |= ZFCP_STATUS_FSFREQ_XDATAINCOMPLETE;
 -
 +		zfcp_fsf_exchange_port_evaluate(req);
  		zfcp_fsf_link_down_info_eval(req,
  			&qtcb->header.fsf_status_qual.link_down_info);
++<<<<<<< HEAD
++=======
+ 
+ 		zfcp_scsi_shost_update_port_data(req->adapter, bottom);
+ 		zfcp_fsf_exchange_port_evaluate(req);
++>>>>>>> 52e61fde5ec9 (scsi: zfcp: Move fc_host updates during xport data handling into fenced function)
  		break;
  	}
  }
diff --cc drivers/s390/scsi/zfcp_scsi.c
index fa5705ae73c1,f98e4015a0ed..000000000000
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@@ -838,6 -841,95 +838,98 @@@ void zfcp_scsi_dif_sense_error(struct s
  	set_host_byte(scmd, DID_SOFT_ERROR);
  }
  
++<<<<<<< HEAD
++=======
+ void zfcp_scsi_shost_update_config_data(
+ 	struct zfcp_adapter *const adapter,
+ 	const struct fsf_qtcb_bottom_config *const bottom,
+ 	const bool bottom_incomplete)
+ {
+ 	struct Scsi_Host *const shost = adapter->scsi_host;
+ 	const struct fc_els_flogi *nsp, *plogi;
+ 
+ 	if (shost == NULL)
+ 		return;
+ 
+ 	snprintf(fc_host_firmware_version(shost), FC_VERSION_STRING_SIZE,
+ 		 "0x%08x", bottom->lic_version);
+ 
+ 	if (adapter->adapter_features & FSF_FEATURE_HBAAPI_MANAGEMENT) {
+ 		snprintf(fc_host_hardware_version(shost),
+ 			 FC_VERSION_STRING_SIZE,
+ 			 "0x%08x", bottom->hardware_version);
+ 		memcpy(fc_host_serial_number(shost), bottom->serial_number,
+ 		       min(FC_SERIAL_NUMBER_SIZE, 17));
+ 		EBCASC(fc_host_serial_number(shost),
+ 		       min(FC_SERIAL_NUMBER_SIZE, 17));
+ 	}
+ 
+ 	/* adjust pointers for missing command code */
+ 	nsp = (struct fc_els_flogi *) ((u8 *)&bottom->nport_serv_param
+ 					- sizeof(u32));
+ 	plogi = (struct fc_els_flogi *) ((u8 *)&bottom->plogi_payload
+ 					- sizeof(u32));
+ 
+ 	snprintf(fc_host_manufacturer(shost), FC_SERIAL_NUMBER_SIZE, "%s",
+ 		 "IBM");
+ 	fc_host_port_name(shost) = be64_to_cpu(nsp->fl_wwpn);
+ 	fc_host_node_name(shost) = be64_to_cpu(nsp->fl_wwnn);
+ 	fc_host_supported_classes(shost) = FC_COS_CLASS2 | FC_COS_CLASS3;
+ 
+ 	zfcp_scsi_set_prot(adapter);
+ 
+ 	/* do not evaluate invalid fields */
+ 	if (bottom_incomplete)
+ 		return;
+ 
+ 	fc_host_port_id(shost) = ntoh24(bottom->s_id);
+ 	fc_host_speed(shost) =
+ 		zfcp_fsf_convert_portspeed(bottom->fc_link_speed);
+ 
+ 	snprintf(fc_host_model(shost), FC_SYMBOLIC_NAME_SIZE, "0x%04x",
+ 		 bottom->adapter_type);
+ 
+ 	switch (bottom->fc_topology) {
+ 	case FSF_TOPO_P2P:
+ 		fc_host_port_type(shost) = FC_PORTTYPE_PTP;
+ 		fc_host_fabric_name(shost) = 0;
+ 		break;
+ 	case FSF_TOPO_FABRIC:
+ 		fc_host_fabric_name(shost) = be64_to_cpu(plogi->fl_wwnn);
+ 		if (bottom->connection_features & FSF_FEATURE_NPIV_MODE)
+ 			fc_host_port_type(shost) = FC_PORTTYPE_NPIV;
+ 		else
+ 			fc_host_port_type(shost) = FC_PORTTYPE_NPORT;
+ 		break;
+ 	case FSF_TOPO_AL:
+ 		fc_host_port_type(shost) = FC_PORTTYPE_NLPORT;
+ 		fallthrough;
+ 	default:
+ 		fc_host_fabric_name(shost) = 0;
+ 		break;
+ 	}
+ }
+ 
+ void zfcp_scsi_shost_update_port_data(
+ 	struct zfcp_adapter *const adapter,
+ 	const struct fsf_qtcb_bottom_port *const bottom)
+ {
+ 	struct Scsi_Host *const shost = adapter->scsi_host;
+ 
+ 	if (shost == NULL)
+ 		return;
+ 
+ 	fc_host_permanent_port_name(shost) = bottom->wwpn;
+ 	fc_host_maxframe_size(shost) = bottom->maximum_frame_size;
+ 	fc_host_supported_speeds(shost) =
+ 		zfcp_fsf_convert_portspeed(bottom->supported_speed);
+ 	memcpy(fc_host_supported_fc4s(shost), bottom->supported_fc4_types,
+ 	       FC_FC4_LIST_SIZE);
+ 	memcpy(fc_host_active_fc4s(shost), bottom->active_fc4_types,
+ 	       FC_FC4_LIST_SIZE);
+ }
+ 
++>>>>>>> 52e61fde5ec9 (scsi: zfcp: Move fc_host updates during xport data handling into fenced function)
  struct fc_function_template zfcp_transport_functions = {
  	.show_starget_port_id = 1,
  	.show_starget_port_name = 1,
* Unmerged path drivers/s390/scsi/zfcp_ext.h
* Unmerged path drivers/s390/scsi/zfcp_fsf.c
* Unmerged path drivers/s390/scsi/zfcp_scsi.c
