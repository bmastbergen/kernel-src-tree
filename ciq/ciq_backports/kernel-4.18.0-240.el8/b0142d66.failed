cpuidle: Fix cpuidle_driver_state_disabled()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit b0142d66f4edb8578b7772d6d7ad731836b82ddb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b0142d66.failed

It turns out that cpuidle_driver_state_disabled() can be called
before registering the cpufreq driver on some platforms, which
was not expected when it was introduced and which leads to a NULL
pointer dereference when trying to walk the CPUs associated with
the given cpuidle driver.

Fix the problem by making cpuidle_driver_state_disabled() check if
the driver's mask of CPUs associated with it is present and to set
CPUIDLE_FLAG_UNUSABLE for the given idle state in the driver's states
list if that is not the case to cause __cpuidle_register_device() to
set CPUIDLE_STATE_DISABLED_BY_DRIVER for that state for all cpuidle
devices registered by it later.

Fixes: cbda56d5fefc ("cpuidle: Introduce cpuidle_driver_state_disabled() for driver quirks")
	Reported-by: Daniel Lezcano <daniel.lezcano@linaro.org>
	Tested-by: Daniel Lezcano <daniel.lezcano@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit b0142d66f4edb8578b7772d6d7ad731836b82ddb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpuidle/driver.c
diff --cc drivers/cpuidle/driver.c
index 1dfb0518a1b3,ce6a5f80fb83..000000000000
--- a/drivers/cpuidle/driver.c
+++ b/drivers/cpuidle/driver.c
@@@ -394,3 -389,41 +394,44 @@@ void cpuidle_driver_unref(void
  
  	spin_unlock(&cpuidle_driver_lock);
  }
++<<<<<<< HEAD
++=======
+ 
+ /**
+  * cpuidle_driver_state_disabled - Disable or enable an idle state
+  * @drv: cpuidle driver owning the state
+  * @idx: State index
+  * @disable: Whether or not to disable the state
+  */
+ void cpuidle_driver_state_disabled(struct cpuidle_driver *drv, int idx,
+ 				 bool disable)
+ {
+ 	unsigned int cpu;
+ 
+ 	mutex_lock(&cpuidle_lock);
+ 
+ 	spin_lock(&cpuidle_driver_lock);
+ 
+ 	if (!drv->cpumask) {
+ 		drv->states[idx].flags |= CPUIDLE_FLAG_UNUSABLE;
+ 		goto unlock;
+ 	}
+ 
+ 	for_each_cpu(cpu, drv->cpumask) {
+ 		struct cpuidle_device *dev = per_cpu(cpuidle_devices, cpu);
+ 
+ 		if (!dev)
+ 			continue;
+ 
+ 		if (disable)
+ 			dev->states_usage[idx].disable |= CPUIDLE_STATE_DISABLED_BY_DRIVER;
+ 		else
+ 			dev->states_usage[idx].disable &= ~CPUIDLE_STATE_DISABLED_BY_DRIVER;
+ 	}
+ 
+ unlock:
+ 	spin_unlock(&cpuidle_driver_lock);
+ 
+ 	mutex_unlock(&cpuidle_lock);
+ }
++>>>>>>> b0142d66f4ed (cpuidle: Fix cpuidle_driver_state_disabled())
* Unmerged path drivers/cpuidle/driver.c
