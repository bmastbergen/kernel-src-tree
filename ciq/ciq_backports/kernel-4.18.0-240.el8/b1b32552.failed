netfilter: conntrack: place confirm-bit setting in a helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit b1b32552c1d81f0cf6a8e79043a2a47e769ff071
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b1b32552.failed

... so it can be re-used from clash resolution in followup patch.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit b1b32552c1d81f0cf6a8e79043a2a47e769ff071)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_core.c
diff --cc net/netfilter/nf_conntrack_core.c
index fc498c249518,5fda5bd10160..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -734,11 -894,46 +734,52 @@@ static void nf_ct_acct_merge(struct nf_
  	}
  }
  
++<<<<<<< HEAD
 +/* Resolve race on insertion if this protocol allows this. */
++=======
+ static void __nf_conntrack_insert_prepare(struct nf_conn *ct)
+ {
+ 	struct nf_conn_tstamp *tstamp;
+ 
+ 	atomic_inc(&ct->ct_general.use);
+ 	ct->status |= IPS_CONFIRMED;
+ 
+ 	/* set conntrack timestamp, if enabled. */
+ 	tstamp = nf_conn_tstamp_find(ct);
+ 	if (tstamp)
+ 		tstamp->start = ktime_get_real_ns();
+ }
+ 
+ /**
+  * nf_ct_resolve_clash - attempt to handle clash without packet drop
+  *
+  * @skb: skb that causes the clash
+  * @h: tuplehash of the clashing entry already in table
+  *
+  * A conntrack entry can be inserted to the connection tracking table
+  * if there is no existing entry with an identical tuple.
+  *
+  * If there is one, @skb (and the assocated, unconfirmed conntrack) has
+  * to be dropped.  In case @skb is retransmitted, next conntrack lookup
+  * will find the already-existing entry.
+  *
+  * The major problem with such packet drop is the extra delay added by
+  * the packet loss -- it will take some time for a retransmit to occur
+  * (or the sender to time out when waiting for a reply).
+  *
+  * This function attempts to handle the situation without packet drop.
+  *
+  * If @skb has no NAT transformation or if the colliding entries are
+  * exactly the same, only the to-be-confirmed conntrack entry is discarded
+  * and @skb is associated with the conntrack entry already in the table.
+  *
+  * Returns NF_DROP if the clash could not be resolved.
+  */
++>>>>>>> b1b32552c1d8 (netfilter: conntrack: place confirm-bit setting in a helper)
  static __cold noinline int
 -nf_ct_resolve_clash(struct sk_buff *skb, struct nf_conntrack_tuple_hash *h)
 +nf_ct_resolve_clash(struct net *net, struct sk_buff *skb,
 +		    enum ip_conntrack_info ctinfo,
 +		    struct nf_conntrack_tuple_hash *h)
  {
  	/* This is the conntrack entry already in hashes that won race. */
  	struct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);
* Unmerged path net/netfilter/nf_conntrack_core.c
