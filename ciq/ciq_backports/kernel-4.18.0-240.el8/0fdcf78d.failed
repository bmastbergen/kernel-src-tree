net: use flow_indr_dev_setup_offload()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] use flow_indr_dev_setup_offload() (Marcelo Leitner) [1841300]
Rebuild_FUZZ: 92.96%
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 0fdcf78d59737939ea449b512d02c3733a22c8e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0fdcf78d.failed

Update existing frontends to use flow_indr_dev_setup_offload().

This new function must be called if ->ndo_setup_tc is unset to deal
with tunnel devices.

If there is no driver that is subscribed to new tunnel device
flow_block bindings, then this function bails out with EOPNOTSUPP.

If the driver module is removed, the ->cleanup() callback removes the
entries that belong to this tunnel device. This cleanup procedures is
triggered when the device unregisters the tunnel device offload handler.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0fdcf78d59737939ea449b512d02c3733a22c8e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_flow_table_offload.c
#	net/netfilter/nf_tables_offload.c
#	net/sched/cls_api.c
diff --cc net/sched/cls_api.c
index 5254d5149eb2,760e51d852f5..000000000000
--- a/net/sched/cls_api.c
+++ b/net/sched/cls_api.c
@@@ -713,24 -709,26 +713,31 @@@ static void tcf_block_offload_init(stru
  	INIT_LIST_HEAD(&bo->cb_list);
  }
  
- static void tc_indr_block_call(struct tcf_block *block,
- 			       struct net_device *dev,
- 			       struct tcf_block_ext_info *ei,
- 			       enum flow_block_command command,
- 			       struct netlink_ext_ack *extack)
- {
- 	struct flow_block_offload bo = {
- 		.command	= command,
- 		.binder_type	= ei->binder_type,
- 		.net		= dev_net(dev),
- 		.block		= &block->flow_block,
- 		.block_shared	= tcf_block_shared(block),
- 		.extack		= extack,
- 	};
- 	INIT_LIST_HEAD(&bo.cb_list);
+ static void tcf_block_unbind(struct tcf_block *block,
+ 			     struct flow_block_offload *bo);
  
++<<<<<<< HEAD
 +	flow_indr_block_call(dev, &bo, command);
 +	tcf_block_setup(block, &bo);
++=======
+ static void tc_block_indr_cleanup(struct flow_block_cb *block_cb)
+ {
+ 	struct tcf_block *block = block_cb->indr.data;
+ 	struct net_device *dev = block_cb->indr.dev;
+ 	struct netlink_ext_ack extack = {};
+ 	struct flow_block_offload bo;
+ 
+ 	tcf_block_offload_init(&bo, dev, FLOW_BLOCK_UNBIND,
+ 			       block_cb->indr.binder_type,
+ 			       &block->flow_block, tcf_block_shared(block),
+ 			       &extack);
+ 	down_write(&block->cb_lock);
+ 	list_move(&block_cb->list, &bo.cb_list);
+ 	up_write(&block->cb_lock);
+ 	rtnl_lock();
+ 	tcf_block_unbind(block, &bo);
+ 	rtnl_unlock();
++>>>>>>> 0fdcf78d5973 (net: use flow_indr_dev_setup_offload())
  }
  
  static bool tcf_block_offload_in_use(struct tcf_block *block)
* Unmerged path net/netfilter/nf_flow_table_offload.c
* Unmerged path net/netfilter/nf_tables_offload.c
* Unmerged path net/netfilter/nf_flow_table_offload.c
* Unmerged path net/netfilter/nf_tables_offload.c
* Unmerged path net/sched/cls_api.c
