KVM: x86: Handle Intel PT CPUID adjustment in VMX code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit dbd068040c64162fbbfa278eb63ef64704190612
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dbd06804.failed

Move the Processor Trace CPUID adjustment into VMX code to eliminate
an instance of the undesirable "unsigned f_* = *_supported ? F(*) : 0"
pattern in the common CPUID handling code, and to pave the way toward
eventually removing ->pt_supported().

No functional change intended.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit dbd068040c64162fbbfa278eb63ef64704190612)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/cpuid.c
index d4472786ed92,26955c724571..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -368,20 -331,15 +368,23 @@@ static int __do_cpuid_func_emulated(str
  
  static inline void do_cpuid_7_mask(struct kvm_cpuid_entry2 *entry)
  {
++<<<<<<< HEAD
 +	unsigned f_invpcid = kvm_x86_ops->invpcid_supported() ? F(INVPCID) : 0;
 +	unsigned f_mpx = kvm_mpx_supported() ? F(MPX) : 0;
 +	unsigned f_umip = kvm_x86_ops->umip_emulated() ? F(UMIP) : 0;
 +	unsigned f_intel_pt = kvm_x86_ops->pt_supported() ? F(INTEL_PT) : 0;
++=======
++>>>>>>> dbd068040c64 (KVM: x86: Handle Intel PT CPUID adjustment in VMX code)
  	unsigned f_la57;
 +	unsigned f_pku = kvm_x86_ops->pku_supported() ? F(PKU) : 0;
  
  	/* cpuid 7.0.ebx */
  	const u32 kvm_cpuid_7_0_ebx_x86_features =
  		F(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |
 -		F(BMI2) | F(ERMS) | 0 /*INVPCID*/ | F(RTM) | 0 /*MPX*/ | F(RDSEED) |
 +		F(BMI2) | F(ERMS) | f_invpcid | F(RTM) | f_mpx | F(RDSEED) |
  		F(ADX) | F(SMAP) | F(AVX512IFMA) | F(AVX512F) | F(AVX512PF) |
  		F(AVX512ER) | F(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(AVX512DQ) |
- 		F(SHA_NI) | F(AVX512BW) | F(AVX512VL) | f_intel_pt;
+ 		F(SHA_NI) | F(AVX512BW) | F(AVX512VL) | 0 /*INTEL_PT*/;
  
  	/* cpuid 7.0.ecx*/
  	const u32 kvm_cpuid_7_0_ecx_x86_features =
diff --cc arch/x86/kvm/vmx/vmx.c
index b4f527d117f1,bf27cb8ac3fc..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -7251,10 -7123,36 +7251,41 @@@ static void vmx_cpuid_update(struct kvm
  	}
  }
  
 -static void vmx_set_supported_cpuid(struct kvm_cpuid_entry2 *entry)
 +static void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
  {
++<<<<<<< HEAD
 +	if (func == 1 && nested)
 +		entry->ecx |= feature_bit(VMX);
++=======
+ 	switch (entry->function) {
+ 	case 0x1:
+ 		if (nested)
+ 			cpuid_entry_set(entry, X86_FEATURE_VMX);
+ 		break;
+ 	case 0x7:
+ 		if (boot_cpu_has(X86_FEATURE_MPX) && kvm_mpx_supported())
+ 			cpuid_entry_set(entry, X86_FEATURE_MPX);
+ 		if (boot_cpu_has(X86_FEATURE_INVPCID) && cpu_has_vmx_invpcid())
+ 			cpuid_entry_set(entry, X86_FEATURE_INVPCID);
+ 		if (boot_cpu_has(X86_FEATURE_INTEL_PT) &&
+ 		    vmx_pt_mode_is_host_guest())
+ 			cpuid_entry_set(entry, X86_FEATURE_INTEL_PT);
+ 		if (vmx_umip_emulated())
+ 			cpuid_entry_set(entry, X86_FEATURE_UMIP);
+ 
+ 		/* PKU is not yet implemented for shadow paging. */
+ 		if (enable_ept && boot_cpu_has(X86_FEATURE_PKU) &&
+ 		    boot_cpu_has(X86_FEATURE_OSPKE))
+ 			cpuid_entry_set(entry, X86_FEATURE_PKU);
+ 		break;
+ 	case 0x80000001:
+ 		if (!cpu_has_vmx_rdtscp())
+ 			cpuid_entry_clear(entry, X86_FEATURE_RDTSCP);
+ 		break;
+ 	default:
+ 		break;
+ 	}
++>>>>>>> dbd068040c64 (KVM: x86: Handle Intel PT CPUID adjustment in VMX code)
  }
  
  static void vmx_request_immediate_exit(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/cpuid.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
