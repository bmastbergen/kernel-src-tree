drm/i915: Introduce intel_connector_hpd_pin()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 012ee690372ccc370d4c13cb137dd2e17e2cfc6b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/012ee690.failed

Simplify the hotplug code connector->encoder->hpd_pin handling
by introducing a helper for exactly this purpose.

In the helper we can neatly deal with the potential lack of an
attached encoder on fresh MST connectors leaving the rest of the
hpd code oblivious to such details.

	Cc: Lyude Paul <lyude@redhat.com>
	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200121171100.4370-3-ville.syrjala@linux.intel.com
	Reviewed-by: Jani Nikula <jani.nikula@intel.com>
(cherry picked from commit 012ee690372ccc370d4c13cb137dd2e17e2cfc6b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_hotplug.c
diff --cc drivers/gpu/drm/i915/display/intel_hotplug.c
index ea3de4acc850,127a2f28c1ac..000000000000
--- a/drivers/gpu/drm/i915/display/intel_hotplug.c
+++ b/drivers/gpu/drm/i915/display/intel_hotplug.c
@@@ -112,7 -118,22 +112,21 @@@ enum hpd_pin intel_hpd_pin_default(stru
  
  #define HPD_STORM_DETECT_PERIOD		1000
  #define HPD_STORM_REENABLE_DELAY	(2 * 60 * 1000)
 -#define HPD_RETRY_DELAY			1000
  
+ static enum hpd_pin
+ intel_connector_hpd_pin(struct intel_connector *connector)
+ {
+ 	struct intel_encoder *encoder = intel_attached_encoder(connector);
+ 
+ 	/*
+ 	 * MST connectors get their encoder attached dynamically
+ 	 * so need to make sure we have an encoder here. But since
+ 	 * MST encoders have their hpd_pin set to HPD_NONE we don't
+ 	 * have to special case them beyond that.
+ 	 */
+ 	return encoder ? encoder->hpd_pin : HPD_NONE;
+ }
+ 
  /**
   * intel_hpd_irq_storm_detect - gather stats and detect HPD IRQ storm on a pin
   * @dev_priv: private driver data pointer
@@@ -188,16 -206,13 +202,26 @@@ intel_hpd_irq_storm_switch_to_polling(s
  	lockdep_assert_held(&dev_priv->irq_lock);
  
  	drm_connector_list_iter_begin(dev, &conn_iter);
++<<<<<<< HEAD
 +	drm_for_each_connector_iter(connector, &conn_iter) {
 +		if (connector->polled != DRM_CONNECTOR_POLL_HPD)
 +			continue;
 +
 +		intel_connector = to_intel_connector(connector);
 +		intel_encoder = intel_connector->encoder;
 +		if (!intel_encoder)
 +			continue;
 +
 +		pin = intel_encoder->hpd_pin;
++=======
+ 	for_each_intel_connector_iter(connector, &conn_iter) {
+ 		enum hpd_pin pin;
+ 
+ 		if (connector->base.polled != DRM_CONNECTOR_POLL_HPD)
+ 			continue;
+ 
+ 		pin = intel_connector_hpd_pin(connector);
++>>>>>>> 012ee690372c (drm/i915: Introduce intel_connector_hpd_pin())
  		if (pin == HPD_NONE ||
  		    dev_priv->hotplug.stats[pin].state != HPD_MARK_DISABLED)
  			continue;
@@@ -243,18 -258,14 +267,24 @@@ static void intel_hpd_irq_storm_reenabl
  		dev_priv->hotplug.stats[pin].state = HPD_ENABLED;
  
  		drm_connector_list_iter_begin(dev, &conn_iter);
++<<<<<<< HEAD
 +		drm_for_each_connector_iter(connector, &conn_iter) {
 +			struct intel_connector *intel_connector = to_intel_connector(connector);
 +
 +			/* Don't check MST ports, they don't have pins */
 +			if (!intel_connector->mst_port &&
 +			    intel_connector->encoder->hpd_pin == pin) {
 +				if (connector->polled != intel_connector->polled)
++=======
+ 		for_each_intel_connector_iter(connector, &conn_iter) {
+ 			if (intel_connector_hpd_pin(connector) == pin) {
+ 				if (connector->base.polled != connector->polled)
++>>>>>>> 012ee690372c (drm/i915: Introduce intel_connector_hpd_pin())
  					DRM_DEBUG_DRIVER("Reenabling HPD on connector %s\n",
 -							 connector->base.name);
 -				connector->base.polled = connector->polled;
 -				if (!connector->base.polled)
 -					connector->base.polled = DRM_CONNECTOR_POLL_HPD;
 +							 connector->name);
 +				connector->polled = intel_connector->polled;
 +				if (!connector->polled)
 +					connector->polled = DRM_CONNECTOR_POLL_HPD;
  			}
  		}
  		drm_connector_list_iter_end(&conn_iter);
@@@ -372,17 -387,33 +402,35 @@@ static void i915_hotplug_work_func(stru
  	spin_unlock_irq(&dev_priv->irq_lock);
  
  	drm_connector_list_iter_begin(dev, &conn_iter);
++<<<<<<< HEAD
 +	drm_for_each_connector_iter(connector, &conn_iter) {
 +		intel_connector = to_intel_connector(connector);
 +		if (!intel_connector->encoder)
 +			continue;
 +		intel_encoder = intel_connector->encoder;
 +		if (hpd_event_bits & (1 << intel_encoder->hpd_pin)) {
 +			DRM_DEBUG_KMS("Connector %s (pin %i) received hotplug event.\n",
 +				      connector->name, intel_encoder->hpd_pin);
++=======
+ 	for_each_intel_connector_iter(connector, &conn_iter) {
+ 		enum hpd_pin pin;
+ 		u32 hpd_bit;
+ 
+ 		pin = intel_connector_hpd_pin(connector);
+ 		if (pin == HPD_NONE)
+ 			continue;
+ 
+ 		hpd_bit = BIT(pin);
+ 		if ((hpd_event_bits | hpd_retry_bits) & hpd_bit) {
+ 			struct intel_encoder *encoder =
+ 				intel_attached_encoder(connector);
+ 
+ 			DRM_DEBUG_KMS("Connector %s (pin %i) received hotplug event.\n",
+ 				      connector->base.name, pin);
++>>>>>>> 012ee690372c (drm/i915: Introduce intel_connector_hpd_pin())
  
 -			switch (encoder->hotplug(encoder, connector,
 -						 hpd_event_bits & hpd_bit)) {
 -			case INTEL_HOTPLUG_UNCHANGED:
 -				break;
 -			case INTEL_HOTPLUG_CHANGED:
 -				changed |= hpd_bit;
 -				break;
 -			case INTEL_HOTPLUG_RETRY:
 -				retry |= hpd_bit;
 -				break;
 -			}
 +			changed |= intel_encoder->hotplug(intel_encoder,
 +							  intel_connector);
  		}
  	}
  	drm_connector_list_iter_end(&conn_iter);
@@@ -572,19 -616,14 +620,30 @@@ static void i915_hpd_poll_init_work(str
  	enabled = READ_ONCE(dev_priv->hotplug.poll_enabled);
  
  	drm_connector_list_iter_begin(dev, &conn_iter);
++<<<<<<< HEAD
 +	drm_for_each_connector_iter(connector, &conn_iter) {
 +		struct intel_connector *intel_connector =
 +			to_intel_connector(connector);
 +		connector->polled = intel_connector->polled;
 +
 +		/* MST has a dynamic intel_connector->encoder and it's reprobing
 +		 * is all handled by the MST helpers. */
 +		if (intel_connector->mst_port)
 +			continue;
 +
 +		if (!connector->polled && I915_HAS_HOTPLUG(dev_priv) &&
 +		    intel_connector->encoder->hpd_pin > HPD_NONE) {
 +			connector->polled = enabled ?
++=======
+ 	for_each_intel_connector_iter(connector, &conn_iter) {
+ 		enum hpd_pin pin = intel_connector_hpd_pin(connector);
+ 
+ 		connector->base.polled = connector->polled;
+ 
+ 		if (pin != HPD_NONE && I915_HAS_HOTPLUG(dev_priv) &&
+ 		    !connector->base.polled)
+ 			connector->base.polled = enabled ?
++>>>>>>> 012ee690372c (drm/i915: Introduce intel_connector_hpd_pin())
  				DRM_CONNECTOR_POLL_CONNECT |
  				DRM_CONNECTOR_POLL_DISCONNECT :
  				DRM_CONNECTOR_POLL_HPD;
* Unmerged path drivers/gpu/drm/i915/display/intel_hotplug.c
