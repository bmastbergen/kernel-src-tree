scsi: zfcp: report FC Endpoint Security in sysfs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Remus <jremus@linux.ibm.com>
commit a17c78460093aad8fb97fc6905c22355b7d1c923
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a17c7846.failed

Add an interface to read Fibre Channel Endpoint Security information of FCP
channels and their connections to FC remote ports. It comes in the form of
new sysfs attributes that are attached to the CCW device representing the
FCP device and its zfcp port objects.

The read-only sysfs attribute "fc_security" of a CCW device representing a
FCP device shows the FC Endpoint Security capabilities of the device.
Possible values are: "unknown", "unsupported", "none", or a comma-
separated list of one or more mnemonics and/or one hexadecimal value
representing the supported FC Endpoint Security:

  Authentication: Authentication supported
  Encryption    : Encryption supported

The read-only sysfs attribute "fc_security" of a zfcp port object shows the
FC Endpoint Security used on the connection between its parent FCP device
and the FC remote port. Possible values are: "unknown", "unsupported",
"none", or a mnemonic or hexadecimal value representing the FC Endpoint
Security used:

  Authentication: Connection has been authenticated
  Encryption    : Connection is encrypted

Both sysfs attributes may return hexadecimal values instead of mnemonics,
if the mnemonic lookup table does not contain an entry for the FC Endpoint
Security reported by the FCP device.

Link: https://lore.kernel.org/r/20200312174505.51294-7-maier@linux.ibm.com
	Reviewed-by: Fedor Loshakov <loshakov@linux.ibm.com>
	Reviewed-by: Steffen Maier <maier@linux.ibm.com>
	Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
	Signed-off-by: Jens Remus <jremus@linux.ibm.com>
	Signed-off-by: Steffen Maier <maier@linux.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit a17c78460093aad8fb97fc6905c22355b7d1c923)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/scsi/zfcp_def.h
#	drivers/s390/scsi/zfcp_fsf.h
#	drivers/s390/scsi/zfcp_sysfs.c
diff --cc drivers/s390/scsi/zfcp_def.h
index 3396a47721a7,861ddc1ef2a9..000000000000
--- a/drivers/s390/scsi/zfcp_def.h
+++ b/drivers/s390/scsi/zfcp_def.h
@@@ -4,7 -4,7 +4,11 @@@
   *
   * Global definitions for the zfcp device driver.
   *
++<<<<<<< HEAD
 + * Copyright IBM Corp. 2002, 2010
++=======
+  * Copyright IBM Corp. 2002, 2020
++>>>>>>> a17c78460093 (scsi: zfcp: report FC Endpoint Security in sysfs)
   */
  
  #ifndef ZFCP_DEF_H
diff --cc drivers/s390/scsi/zfcp_fsf.h
index 535628b92f0a,66de1708973d..000000000000
--- a/drivers/s390/scsi/zfcp_fsf.h
+++ b/drivers/s390/scsi/zfcp_fsf.h
@@@ -163,6 -163,9 +163,12 @@@
  #define FSF_FEATURE_ELS_CT_CHAINED_SBALS	0x00000020
  #define FSF_FEATURE_UPDATE_ALERT		0x00000100
  #define FSF_FEATURE_MEASUREMENT_DATA		0x00000200
++<<<<<<< HEAD
++=======
+ #define FSF_FEATURE_REQUEST_SFP_DATA		0x00000200
+ #define FSF_FEATURE_REPORT_SFP_DATA		0x00000800
+ #define FSF_FEATURE_FC_SECURITY			0x00001000
++>>>>>>> a17c78460093 (scsi: zfcp: report FC Endpoint Security in sysfs)
  #define FSF_FEATURE_DIF_PROT_TYPE1		0x00010000
  #define FSF_FEATURE_DIX_PROT_TCPIP		0x00020000
  
@@@ -407,7 -416,25 +419,29 @@@ struct fsf_qtcb_bottom_port 
  	u8 cp_util;
  	u8 cb_util;
  	u8 a_util;
++<<<<<<< HEAD
 +	u8 res2[253];
++=======
+ 	u8 res2;
+ 	u16 temperature;
+ 	u16 vcc;
+ 	u16 tx_bias;
+ 	u16 tx_power;
+ 	u16 rx_power;
+ 	union {
+ 		u16 raw;
+ 		struct {
+ 			u16 fec_active		:1;
+ 			u16:7;
+ 			u16 connector_type	:2;
+ 			u16 sfp_invalid		:1;
+ 			u16 optical_port	:1;
+ 			u16 port_tx_type	:4;
+ 		};
+ 	} sfp_flags;
+ 	u32 fc_security_algorithms;
+ 	u8 res3[236];
++>>>>>>> a17c78460093 (scsi: zfcp: report FC Endpoint Security in sysfs)
  } __attribute__ ((packed));
  
  union fsf_qtcb_bottom {
diff --cc drivers/s390/scsi/zfcp_sysfs.c
index af197e2b3e69,45d53166d0d1..000000000000
--- a/drivers/s390/scsi/zfcp_sysfs.c
+++ b/drivers/s390/scsi/zfcp_sysfs.c
@@@ -325,6 -326,86 +325,89 @@@ static ssize_t zfcp_sysfs_port_remove_s
  static ZFCP_DEV_ATTR(adapter, port_remove, S_IWUSR, NULL,
  		     zfcp_sysfs_port_remove_store);
  
++<<<<<<< HEAD
++=======
+ static ssize_t
+ zfcp_sysfs_adapter_diag_max_age_show(struct device *dev,
+ 				     struct device_attribute *attr, char *buf)
+ {
+ 	struct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(to_ccwdev(dev));
+ 	ssize_t rc;
+ 
+ 	if (!adapter)
+ 		return -ENODEV;
+ 
+ 	/* ceil(log(2^64 - 1) / log(10)) = 20 */
+ 	rc = scnprintf(buf, 20 + 2, "%lu\n", adapter->diagnostics->max_age);
+ 
+ 	zfcp_ccw_adapter_put(adapter);
+ 	return rc;
+ }
+ 
+ static ssize_t
+ zfcp_sysfs_adapter_diag_max_age_store(struct device *dev,
+ 				      struct device_attribute *attr,
+ 				      const char *buf, size_t count)
+ {
+ 	struct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(to_ccwdev(dev));
+ 	unsigned long max_age;
+ 	ssize_t rc;
+ 
+ 	if (!adapter)
+ 		return -ENODEV;
+ 
+ 	rc = kstrtoul(buf, 10, &max_age);
+ 	if (rc != 0)
+ 		goto out;
+ 
+ 	adapter->diagnostics->max_age = max_age;
+ 
+ 	rc = count;
+ out:
+ 	zfcp_ccw_adapter_put(adapter);
+ 	return rc;
+ }
+ static ZFCP_DEV_ATTR(adapter, diag_max_age, 0644,
+ 		     zfcp_sysfs_adapter_diag_max_age_show,
+ 		     zfcp_sysfs_adapter_diag_max_age_store);
+ 
+ static ssize_t zfcp_sysfs_adapter_fc_security_show(
+ 	struct device *dev, struct device_attribute *attr, char *buf)
+ {
+ 	struct ccw_device *cdev = to_ccwdev(dev);
+ 	struct zfcp_adapter *adapter = zfcp_ccw_adapter_by_cdev(cdev);
+ 	unsigned int status;
+ 	int i;
+ 
+ 	if (!adapter)
+ 		return -ENODEV;
+ 
+ 	/*
+ 	 * Adapter status COMMON_OPEN implies xconf data and xport data
+ 	 * was done. Adapter FC Endpoint Security capability remains
+ 	 * unchanged in case of COMMON_ERP_FAILED (e.g. due to local link
+ 	 * down).
+ 	 */
+ 	status = atomic_read(&adapter->status);
+ 	if (0 == (status & ZFCP_STATUS_COMMON_OPEN))
+ 		i = sprintf(buf, "unknown\n");
+ 	else if (!(adapter->adapter_features & FSF_FEATURE_FC_SECURITY))
+ 		i = sprintf(buf, "unsupported\n");
+ 	else {
+ 		i = zfcp_fsf_scnprint_fc_security(
+ 			buf, PAGE_SIZE - 1, adapter->fc_security_algorithms,
+ 			ZFCP_FSF_PRINT_FMT_LIST);
+ 		i += scnprintf(buf + i, PAGE_SIZE - i, "\n");
+ 	}
+ 
+ 	zfcp_ccw_adapter_put(adapter);
+ 	return i;
+ }
+ static ZFCP_DEV_ATTR(adapter, fc_security, S_IRUGO,
+ 		     zfcp_sysfs_adapter_fc_security_show,
+ 		     NULL);
+ 
++>>>>>>> a17c78460093 (scsi: zfcp: report FC Endpoint Security in sysfs)
  static struct attribute *zfcp_adapter_attrs[] = {
  	&dev_attr_adapter_failed.attr,
  	&dev_attr_adapter_in_recovery.attr,
@@@ -337,6 -418,8 +420,11 @@@
  	&dev_attr_adapter_lic_version.attr,
  	&dev_attr_adapter_status.attr,
  	&dev_attr_adapter_hardware_version.attr,
++<<<<<<< HEAD
++=======
+ 	&dev_attr_adapter_diag_max_age.attr,
+ 	&dev_attr_adapter_fc_security.attr,
++>>>>>>> a17c78460093 (scsi: zfcp: report FC Endpoint Security in sysfs)
  	NULL
  };
  
* Unmerged path drivers/s390/scsi/zfcp_def.h
diff --git a/drivers/s390/scsi/zfcp_ext.h b/drivers/s390/scsi/zfcp_ext.h
index f75d5680e5ba..a491c02b06a4 100644
--- a/drivers/s390/scsi/zfcp_ext.h
+++ b/drivers/s390/scsi/zfcp_ext.h
@@ -4,7 +4,7 @@
  *
  * External function declarations.
  *
- * Copyright IBM Corp. 2002, 2018
+ * Copyright IBM Corp. 2002, 2020
  */
 
 #ifndef ZFCP_EXT_H
@@ -133,6 +133,13 @@ extern struct zfcp_fsf_req *zfcp_fsf_fcp_task_mgmt(struct scsi_device *sdev,
 						   u8 tm_flags);
 extern struct zfcp_fsf_req *zfcp_fsf_abort_fcp_cmnd(struct scsi_cmnd *);
 extern void zfcp_fsf_reqid_check(struct zfcp_qdio *, int);
+enum zfcp_fsf_print_fmt {
+	ZFCP_FSF_PRINT_FMT_LIST,
+	ZFCP_FSF_PRINT_FMT_SINGLEITEM,
+};
+extern ssize_t zfcp_fsf_scnprint_fc_security(char *buf, size_t size,
+					     u32 fc_security,
+					     enum zfcp_fsf_print_fmt fmt);
 
 /* zfcp_qdio.c */
 extern int zfcp_qdio_setup(struct zfcp_adapter *);
diff --git a/drivers/s390/scsi/zfcp_fsf.c b/drivers/s390/scsi/zfcp_fsf.c
index aaa4066c5699..937ced9299f7 100644
--- a/drivers/s390/scsi/zfcp_fsf.c
+++ b/drivers/s390/scsi/zfcp_fsf.c
@@ -623,6 +623,76 @@ static void zfcp_fsf_exchange_config_data_handler(struct zfcp_fsf_req *req)
 	}
 }
 
+/*
+ * Mapping of FC Endpoint Security flag masks to mnemonics
+ */
+static const struct {
+	u32	mask;
+	char	*name;
+} zfcp_fsf_fc_security_mnemonics[] = {
+	{ FSF_FC_SECURITY_AUTH,		"Authentication" },
+	{ FSF_FC_SECURITY_ENC_FCSP2 |
+	  FSF_FC_SECURITY_ENC_ERAS,	"Encryption" },
+};
+
+/**
+ * zfcp_fsf_scnprint_fc_security() - translate FC Endpoint Security flags into
+ *                                   mnemonics and place in a buffer
+ * @buf        : the buffer to place the translated FC Endpoint Security flag(s)
+ *               into
+ * @size       : the size of the buffer, including the trailing null space
+ * @fc_security: one or more FC Endpoint Security flags, or zero
+ * @fmt        : specifies whether a list or a single item is to be put into the
+ *               buffer
+ *
+ * The Fibre Channel (FC) Endpoint Security flags are translated into mnemonics.
+ * If the FC Endpoint Security flags are zero "none" is placed into the buffer.
+ *
+ * With ZFCP_FSF_PRINT_FMT_LIST the mnemonics are placed as a list separated by
+ * a comma followed by a space into the buffer. If one or more FC Endpoint
+ * Security flags cannot be translated into a mnemonic, as they are undefined
+ * in zfcp_fsf_fc_security_mnemonics, their bitwise ORed value in hexadecimal
+ * representation is placed into the buffer.
+ *
+ * With ZFCP_FSF_PRINT_FMT_SINGLEITEM only one single mnemonic is placed into
+ * the buffer. If the FC Endpoint Security flag cannot be translated, as it is
+ * undefined in zfcp_fsf_fc_security_mnemonics, its value in hexadecimal
+ * representation is placed into the buffer. If more than one FC Endpoint
+ * Security flag was specified, their value in hexadecimal representation is
+ * placed into the buffer.
+ *
+ * Return: The number of characters written into buf not including the trailing
+ *         '\0'. If size is == 0 the function returns 0.
+ */
+ssize_t zfcp_fsf_scnprint_fc_security(char *buf, size_t size, u32 fc_security,
+				      enum zfcp_fsf_print_fmt fmt)
+{
+	const char *prefix = "";
+	ssize_t len = 0;
+	int i;
+
+	if (fc_security == 0)
+		return scnprintf(buf, size, "none");
+	if (fmt == ZFCP_FSF_PRINT_FMT_SINGLEITEM && hweight32(fc_security) != 1)
+		return scnprintf(buf, size, "0x%08x", fc_security);
+
+	for (i = 0; i < ARRAY_SIZE(zfcp_fsf_fc_security_mnemonics); i++) {
+		if (!(fc_security & zfcp_fsf_fc_security_mnemonics[i].mask))
+			continue;
+
+		len += scnprintf(buf + len, size - len, "%s%s", prefix,
+				 zfcp_fsf_fc_security_mnemonics[i].name);
+		prefix = ", ";
+		fc_security &= ~zfcp_fsf_fc_security_mnemonics[i].mask;
+	}
+
+	if (fc_security != 0)
+		len += scnprintf(buf + len, size - len, "%s0x%08x",
+				 prefix, fc_security);
+
+	return len;
+}
+
 static void zfcp_fsf_exchange_port_evaluate(struct zfcp_fsf_req *req)
 {
 	struct zfcp_adapter *adapter = req->adapter;
@@ -643,6 +713,11 @@ static void zfcp_fsf_exchange_port_evaluate(struct zfcp_fsf_req *req)
 	       FC_FC4_LIST_SIZE);
 	memcpy(fc_host_active_fc4s(shost), bottom->active_fc4_types,
 	       FC_FC4_LIST_SIZE);
+	if (adapter->adapter_features & FSF_FEATURE_FC_SECURITY)
+		adapter->fc_security_algorithms =
+			bottom->fc_security_algorithms;
+	else
+		adapter->fc_security_algorithms = 0;
 }
 
 static void zfcp_fsf_exchange_port_data_handler(struct zfcp_fsf_req *req)
@@ -1424,6 +1499,10 @@ static void zfcp_fsf_open_port_handler(struct zfcp_fsf_req *req)
 		break;
 	case FSF_GOOD:
 		port->handle = header->port_handle;
+		if (adapter->adapter_features & FSF_FEATURE_FC_SECURITY)
+			port->connection_info = bottom->connection_info;
+		else
+			port->connection_info = 0;
 		atomic_or(ZFCP_STATUS_COMMON_OPEN |
 				ZFCP_STATUS_PORT_PHYS_OPEN, &port->status);
 		atomic_andnot(ZFCP_STATUS_COMMON_ACCESS_BOXED,
* Unmerged path drivers/s390/scsi/zfcp_fsf.h
* Unmerged path drivers/s390/scsi/zfcp_sysfs.c
