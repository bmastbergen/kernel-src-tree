KVM: X86: correct meaningless kvm_apicv_activated() check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 8e205a6b2a06764a4c2bfc9e1a6a8a8e7920faf8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8e205a6b.failed

After test_and_set_bit() for kvm->arch.apicv_inhibit_reasons, we will
always get false when calling kvm_apicv_activated() because it's sure
apicv_inhibit_reasons do not equal to 0.

What the code wants to do, is check whether APICv was *already* active
and if so skip the costly request; we can do this using cmpxchg.

	Reported-by: Miaohe Lin <linmiaohe@huawei.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 8e205a6b2a06764a4c2bfc9e1a6a8a8e7920faf8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index d84116c1b5a2,e54c6ad628a8..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -7947,6 -8029,54 +7947,57 @@@ void kvm_make_scan_ioapic_request(struc
  	kvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);
  }
  
++<<<<<<< HEAD
++=======
+ void kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu)
+ {
+ 	if (!lapic_in_kernel(vcpu))
+ 		return;
+ 
+ 	vcpu->arch.apicv_active = kvm_apicv_activated(vcpu->kvm);
+ 	kvm_apic_update_apicv(vcpu);
+ 	kvm_x86_ops->refresh_apicv_exec_ctrl(vcpu);
+ }
+ EXPORT_SYMBOL_GPL(kvm_vcpu_update_apicv);
+ 
+ /*
+  * NOTE: Do not hold any lock prior to calling this.
+  *
+  * In particular, kvm_request_apicv_update() expects kvm->srcu not to be
+  * locked, because it calls __x86_set_memory_region() which does
+  * synchronize_srcu(&kvm->srcu).
+  */
+ void kvm_request_apicv_update(struct kvm *kvm, bool activate, ulong bit)
+ {
+ 	unsigned long old, new, expected;
+ 
+ 	if (!kvm_x86_ops->check_apicv_inhibit_reasons ||
+ 	    !kvm_x86_ops->check_apicv_inhibit_reasons(bit))
+ 		return;
+ 
+ 	old = READ_ONCE(kvm->arch.apicv_inhibit_reasons);
+ 	do {
+ 		expected = new = old;
+ 		if (activate)
+ 			__clear_bit(bit, &new);
+ 		else
+ 			__set_bit(bit, &new);
+ 		if (new == old)
+ 			break;
+ 		old = cmpxchg(&kvm->arch.apicv_inhibit_reasons, expected, new);
+ 	} while (old != expected);
+ 
+ 	if (!!old == !!new)
+ 		return;
+ 
+ 	trace_kvm_apicv_update_request(activate, bit);
+ 	if (kvm_x86_ops->pre_update_apicv_exec_ctrl)
+ 		kvm_x86_ops->pre_update_apicv_exec_ctrl(kvm, activate);
+ 	kvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);
+ }
+ EXPORT_SYMBOL_GPL(kvm_request_apicv_update);
+ 
++>>>>>>> 8e205a6b2a06 (KVM: X86: correct meaningless kvm_apicv_activated() check)
  static void vcpu_scan_ioapic(struct kvm_vcpu *vcpu)
  {
  	if (!kvm_apic_present(vcpu))
* Unmerged path arch/x86/kvm/x86.c
