Bluetooth: L2CAP: Add initial code for Enhanced Credit Based Mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
commit 15f02b91056253e8cdc592888f431da0731337b8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/15f02b91.failed

This adds the initial code for Enhanced Credit Based Mode which
introduces a new socket mode called L2CAP_MODE_EXT_FLOWCTL, which for
the most part work the same as L2CAP_MODE_LE_FLOWCTL but uses different
PDUs to setup the connections and also works over BR/EDR.

	Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 15f02b91056253e8cdc592888f431da0731337b8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/bluetooth/l2cap.h
#	net/bluetooth/l2cap_core.c
diff --cc include/net/bluetooth/l2cap.h
index 0697fd413087,f466cdcc6742..000000000000
--- a/include/net/bluetooth/l2cap.h
+++ b/include/net/bluetooth/l2cap.h
@@@ -277,12 -281,21 +277,30 @@@ struct l2cap_conn_rsp 
  #define L2CAP_CR_SEC_BLOCK	0x0003
  #define L2CAP_CR_NO_MEM		0x0004
  #define L2CAP_CR_BAD_AMP	0x0005
++<<<<<<< HEAD
 +#define L2CAP_CR_AUTHENTICATION	0x0005
 +#define L2CAP_CR_AUTHORIZATION	0x0006
 +#define L2CAP_CR_BAD_KEY_SIZE	0x0007
 +#define L2CAP_CR_ENCRYPTION	0x0008
 +#define L2CAP_CR_INVALID_SCID	0x0009
 +#define L2CAP_CR_SCID_IN_USE	0x000A
++=======
+ #define L2CAP_CR_INVALID_SCID	0x0006
+ #define L2CAP_CR_SCID_IN_USE	0x0007
+ 
+ /* credit based connect results */
+ #define L2CAP_CR_LE_SUCCESS		0x0000
+ #define L2CAP_CR_LE_BAD_PSM		0x0002
+ #define L2CAP_CR_LE_NO_MEM		0x0004
+ #define L2CAP_CR_LE_AUTHENTICATION	0x0005
+ #define L2CAP_CR_LE_AUTHORIZATION	0x0006
+ #define L2CAP_CR_LE_BAD_KEY_SIZE	0x0007
+ #define L2CAP_CR_LE_ENCRYPTION		0x0008
+ #define L2CAP_CR_LE_INVALID_SCID	0x0009
+ #define L2CAP_CR_LE_SCID_IN_USE		0X000A
+ #define L2CAP_CR_LE_UNACCEPT_PARAMS	0X000B
+ #define L2CAP_CR_LE_INVALID_PARAMS	0X000C
++>>>>>>> 15f02b910562 (Bluetooth: L2CAP: Add initial code for Enhanced Credit Based Mode)
  
  /* connect/create channel status */
  #define L2CAP_CS_NO_INFO	0x0000
diff --cc net/bluetooth/l2cap_core.c
index 06771e4d280a,6b24db77b5df..000000000000
--- a/net/bluetooth/l2cap_core.c
+++ b/net/bluetooth/l2cap_core.c
@@@ -6722,13 -7291,12 +7198,22 @@@ static void l2cap_chan_le_send_credits(
  	struct l2cap_le_credits pkt;
  	u16 return_credits;
  
++<<<<<<< HEAD
 +	/* We return more credits to the sender only after the amount of
 +	 * credits falls below half of the initial amount.
 +	 */
 +	if (chan->rx_credits >= (le_max_credits + 1) / 2)
 +		return;
 +
 +	return_credits = le_max_credits - chan->rx_credits;
++=======
+ 	return_credits = (chan->imtu / chan->mps) + 1;
+ 
+ 	if (chan->rx_credits >= return_credits)
+ 		return;
+ 
+ 	return_credits -= chan->rx_credits;
++>>>>>>> 15f02b910562 (Bluetooth: L2CAP: Add initial code for Enhanced Credit Based Mode)
  
  	BT_DBG("chan %p returning %u credits to sender", chan, return_credits);
  
@@@ -6742,7 -7310,22 +7227,26 @@@
  	l2cap_send_cmd(conn, chan->ident, L2CAP_LE_CREDITS, sizeof(pkt), &pkt);
  }
  
++<<<<<<< HEAD
 +static int l2cap_le_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)
++=======
+ static int l2cap_ecred_recv(struct l2cap_chan *chan, struct sk_buff *skb)
+ {
+ 	int err;
+ 
+ 	BT_DBG("SDU reassemble complete: chan %p skb->len %u", chan, skb->len);
+ 
+ 	/* Wait recv to confirm reception before updating the credits */
+ 	err = chan->ops->recv(chan, skb);
+ 
+ 	/* Update credits whenever an SDU is received */
+ 	l2cap_chan_le_send_credits(chan);
+ 
+ 	return err;
+ }
+ 
+ static int l2cap_ecred_data_rcv(struct l2cap_chan *chan, struct sk_buff *skb)
++>>>>>>> 15f02b910562 (Bluetooth: L2CAP: Add initial code for Enhanced Credit Based Mode)
  {
  	int err;
  
@@@ -6786,7 -7373,7 +7290,11 @@@
  		}
  
  		if (skb->len == sdu_len)
++<<<<<<< HEAD
 +			return chan->ops->recv(chan, skb);
++=======
+ 			return l2cap_ecred_recv(chan, skb);
++>>>>>>> 15f02b910562 (Bluetooth: L2CAP: Add initial code for Enhanced Credit Based Mode)
  
  		chan->sdu = skb;
  		chan->sdu_len = sdu_len;
@@@ -6808,7 -7405,7 +7316,11 @@@
  	skb = NULL;
  
  	if (chan->sdu->len == chan->sdu_len) {
++<<<<<<< HEAD
 +		err = chan->ops->recv(chan, chan->sdu);
++=======
+ 		err = l2cap_ecred_recv(chan, chan->sdu);
++>>>>>>> 15f02b910562 (Bluetooth: L2CAP: Add initial code for Enhanced Credit Based Mode)
  		if (!err) {
  			chan->sdu = NULL;
  			chan->sdu_last_frag = NULL;
@@@ -7125,7 -7723,7 +7638,11 @@@ int l2cap_chan_connect(struct l2cap_cha
  	case L2CAP_MODE_BASIC:
  		break;
  	case L2CAP_MODE_LE_FLOWCTL:
++<<<<<<< HEAD
 +		l2cap_le_flowctl_init(chan);
++=======
+ 	case L2CAP_MODE_EXT_FLOWCTL:
++>>>>>>> 15f02b910562 (Bluetooth: L2CAP: Add initial code for Enhanced Credit Based Mode)
  		break;
  	case L2CAP_MODE_ERTM:
  	case L2CAP_MODE_STREAMING:
* Unmerged path include/net/bluetooth/l2cap.h
* Unmerged path net/bluetooth/l2cap_core.c
diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c
index e980d3fce548..72d56fce4a96 100644
--- a/net/bluetooth/l2cap_sock.c
+++ b/net/bluetooth/l2cap_sock.c
@@ -232,7 +232,7 @@ static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr,
 			return -EINVAL;
 	}
 
-	if (chan->psm && bdaddr_type_is_le(chan->src_type))
+	if (chan->psm && bdaddr_type_is_le(chan->src_type) && !chan->mode)
 		chan->mode = L2CAP_MODE_LE_FLOWCTL;
 
 	err = l2cap_chan_connect(chan, la.l2_psm, __le16_to_cpu(la.l2_cid),
@@ -273,6 +273,7 @@ static int l2cap_sock_listen(struct socket *sock, int backlog)
 	switch (chan->mode) {
 	case L2CAP_MODE_BASIC:
 	case L2CAP_MODE_LE_FLOWCTL:
+	case L2CAP_MODE_EXT_FLOWCTL:
 		break;
 	case L2CAP_MODE_ERTM:
 	case L2CAP_MODE_STREAMING:
@@ -427,6 +428,8 @@ static int l2cap_sock_getsockopt_old(struct socket *sock, int optname,
 		opts.max_tx   = chan->max_tx;
 		opts.txwin_size = chan->tx_win;
 
+		BT_DBG("mode 0x%2.2x", chan->mode);
+
 		len = min_t(unsigned int, len, sizeof(opts));
 		if (copy_to_user(optval, (char *) &opts, len))
 			err = -EFAULT;
@@ -707,6 +710,8 @@ static int l2cap_sock_setsockopt_old(struct socket *sock, int optname,
 			break;
 		}
 
+		BT_DBG("mode 0x%2.2x", chan->mode);
+
 		chan->imtu = opts.imtu;
 		chan->omtu = opts.omtu;
 		chan->fcs  = opts.fcs;
@@ -936,7 +941,8 @@ static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname,
 			break;
 		}
 
-		if (sk->sk_state == BT_CONNECTED) {
+		if (chan->mode == L2CAP_MODE_LE_FLOWCTL &&
+		    sk->sk_state == BT_CONNECTED) {
 			err = -EISCONN;
 			break;
 		}
@@ -946,7 +952,12 @@ static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname,
 			break;
 		}
 
-		chan->imtu = opt;
+		if (chan->mode == L2CAP_MODE_EXT_FLOWCTL &&
+		    sk->sk_state == BT_CONNECTED)
+			err = l2cap_chan_reconfigure(chan, opt);
+		else
+			chan->imtu = opt;
+
 		break;
 
 	default:
@@ -1001,7 +1012,11 @@ static int l2cap_sock_recvmsg(struct socket *sock, struct msghdr *msg,
 
 	if (sk->sk_state == BT_CONNECT2 && test_bit(BT_SK_DEFER_SETUP,
 						    &bt_sk(sk)->flags)) {
-		if (bdaddr_type_is_le(pi->chan->src_type)) {
+		if (pi->chan->mode == L2CAP_MODE_EXT_FLOWCTL) {
+			sk->sk_state = BT_CONNECTED;
+			pi->chan->state = BT_CONNECTED;
+			__l2cap_ecred_conn_rsp_defer(pi->chan);
+		} if (bdaddr_type_is_le(pi->chan->src_type)) {
 			sk->sk_state = BT_CONNECTED;
 			pi->chan->state = BT_CONNECTED;
 			__l2cap_le_connect_rsp_defer(pi->chan);
