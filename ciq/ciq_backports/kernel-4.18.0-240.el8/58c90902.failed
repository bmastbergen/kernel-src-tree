efi: Support for MOK variable config table

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Lenny Szubowicz <lszubowi@redhat.com>
commit 58c909022a5a56cd1d9e89c8c5461fd1f6a27bb5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/58c90902.failed

Because of system-specific EFI firmware limitations, EFI volatile
variables may not be capable of holding the required contents of
the Machine Owner Key (MOK) certificate store when the certificate
list grows above some size. Therefore, an EFI boot loader may pass
the MOK certs via a EFI configuration table created specifically for
this purpose to avoid this firmware limitation.

An EFI configuration table is a much more primitive mechanism
compared to EFI variables and is well suited for one-way passage
of static information from a pre-OS environment to the kernel.

This patch adds initial kernel support to recognize, parse,
and validate the EFI MOK configuration table, where named
entries contain the same data that would otherwise be provided
in similarly named EFI variables.

Additionally, this patch creates a sysfs binary file for each
EFI MOK configuration table entry found. These files are read-only
to root and are provided for use by user space utilities such as
mokutil.

A subsequent patch will load MOK certs into the trusted platform
key ring using this infrastructure.

	Signed-off-by: Lenny Szubowicz <lszubowi@redhat.com>
Link: https://lore.kernel.org/r/20200905013107.10457-2-lszubowi@redhat.com
	Signed-off-by: Ard Biesheuvel <ardb@kernel.org>
(cherry picked from commit 58c909022a5a56cd1d9e89c8c5461fd1f6a27bb5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/setup.c
#	arch/x86/platform/efi/efi.c
#	drivers/firmware/efi/Makefile
#	drivers/firmware/efi/efi-init.c
#	drivers/firmware/efi/efi.c
#	include/linux/efi.h
diff --cc arch/x86/kernel/setup.c
index 8bc25613b46c,d41be0df72f8..000000000000
--- a/arch/x86/kernel/setup.c
+++ b/arch/x86/kernel/setup.c
@@@ -1332,17 -1074,16 +1332,24 @@@ void __init setup_arch(char **cmdline_p
  
  	reserve_bios_regions();
  
++<<<<<<< HEAD
 +	if (efi_enabled(EFI_MEMMAP)) {
 +		efi_fake_memmap();
 +		efi_find_mirror();
 +		efi_esrt_init();
++=======
+ 	efi_fake_memmap();
+ 	efi_find_mirror();
+ 	efi_esrt_init();
+ 	efi_mokvar_table_init();
++>>>>>>> 58c909022a5a (efi: Support for MOK variable config table)
  
 -	/*
 -	 * The EFI specification says that boot service code won't be
 -	 * called after ExitBootServices(). This is, in fact, a lie.
 -	 */
 -	efi_reserve_boot_services();
 +		/*
 +		 * The EFI specification says that boot service code won't be
 +		 * called after ExitBootServices(). This is, in fact, a lie.
 +		 */
 +		efi_reserve_boot_services();
 +	}
  
  	/* preallocate 4k for mptable mpc */
  	e820__memblock_alloc_reserved_mpc_new();
diff --cc arch/x86/platform/efi/efi.c
index 335a62e74a2e,6961bedc6503..000000000000
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@@ -55,14 -54,46 +55,44 @@@
  #include <asm/x86_init.h>
  #include <asm/uv/uv.h>
  
 -static unsigned long efi_systab_phys __initdata;
 -static unsigned long prop_phys = EFI_INVALID_TABLE_ADDR;
 -static unsigned long uga_phys = EFI_INVALID_TABLE_ADDR;
 -static unsigned long efi_runtime, efi_nr_tables;
 -
 -unsigned long efi_fw_vendor, efi_config_table;
 +static struct efi efi_phys __initdata;
 +static efi_system_table_t efi_systab __initdata;
  
 -static const efi_config_table_type_t arch_tables[] __initconst = {
 -	{EFI_PROPERTIES_TABLE_GUID,	&prop_phys,		"PROP"		},
 -	{UGA_IO_PROTOCOL_GUID,		&uga_phys,		"UGA"		},
 +static efi_config_table_type_t arch_tables[] __initdata = {
  #ifdef CONFIG_X86_UV
 -	{UV_SYSTEM_TABLE_GUID,		&uv_systab_phys,	"UVsystab"	},
 +	{UV_SYSTEM_TABLE_GUID, "UVsystab", &efi.uv_systab},
  #endif
++<<<<<<< HEAD
 +	{NULL_GUID, NULL, NULL},
++=======
+ 	{},
+ };
+ 
+ static const unsigned long * const efi_tables[] = {
+ 	&efi.acpi,
+ 	&efi.acpi20,
+ 	&efi.smbios,
+ 	&efi.smbios3,
+ 	&uga_phys,
+ #ifdef CONFIG_X86_UV
+ 	&uv_systab_phys,
+ #endif
+ 	&efi_fw_vendor,
+ 	&efi_runtime,
+ 	&efi_config_table,
+ 	&efi.esrt,
+ 	&prop_phys,
+ 	&efi_mem_attr_table,
+ #ifdef CONFIG_EFI_RCI2_TABLE
+ 	&rci2_table_phys,
+ #endif
+ 	&efi.tpm_log,
+ 	&efi.tpm_final_log,
+ 	&efi_rng_seed,
+ #ifdef CONFIG_LOAD_UEFI_KEYS
+ 	&efi.mokvar_table,
+ #endif
++>>>>>>> 58c909022a5a (efi: Support for MOK variable config table)
  };
  
  u64 efi_setup;		/* efi setup_data physical address */
diff --cc drivers/firmware/efi/Makefile
index d9d1b7876542,e8da782280b6..000000000000
--- a/drivers/firmware/efi/Makefile
+++ b/drivers/firmware/efi/Makefile
@@@ -24,11 -25,15 +24,16 @@@ obj-$(CONFIG_EFI_FAKE_MEMMAP)		+= fake_
  obj-$(CONFIG_EFI_BOOTLOADER_CONTROL)	+= efibc.o
  obj-$(CONFIG_EFI_TEST)			+= test/
  obj-$(CONFIG_EFI_DEV_PATH_PARSER)	+= dev-path-parser.o
 +obj-$(CONFIG_EFI)			+= secureboot.o
  obj-$(CONFIG_APPLE_PROPERTIES)		+= apple-properties.o
  obj-$(CONFIG_EFI_RCI2_TABLE)		+= rci2-table.o
++<<<<<<< HEAD
++=======
+ obj-$(CONFIG_EFI_EMBEDDED_FIRMWARE)	+= embedded-firmware.o
+ obj-$(CONFIG_LOAD_UEFI_KEYS)		+= mokvar-table.o
++>>>>>>> 58c909022a5a (efi: Support for MOK variable config table)
  
 -fake_map-y				+= fake_mem.o
 -fake_map-$(CONFIG_X86)			+= x86_fake_mem.o
 -
 -arm-obj-$(CONFIG_EFI)			:= efi-init.o arm-runtime.o
 +arm-obj-$(CONFIG_EFI)			:= arm-init.o arm-runtime.o
  obj-$(CONFIG_ARM)			+= $(arm-obj-y)
  obj-$(CONFIG_ARM64)			+= $(arm-obj-y)
  obj-$(CONFIG_EFI_CAPSULE_LOADER)	+= capsule-loader.o
diff --cc drivers/firmware/efi/efi.c
index 51fed49851da,820f5b1dfba3..000000000000
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@@ -41,20 -40,12 +41,27 @@@ struct efi __read_mostly efi = 
  	.acpi20			= EFI_INVALID_TABLE_ADDR,
  	.smbios			= EFI_INVALID_TABLE_ADDR,
  	.smbios3		= EFI_INVALID_TABLE_ADDR,
 +	.sal_systab		= EFI_INVALID_TABLE_ADDR,
 +	.boot_info		= EFI_INVALID_TABLE_ADDR,
 +	.hcdp			= EFI_INVALID_TABLE_ADDR,
 +	.uga			= EFI_INVALID_TABLE_ADDR,
 +	.uv_systab		= EFI_INVALID_TABLE_ADDR,
 +	.fw_vendor		= EFI_INVALID_TABLE_ADDR,
 +	.runtime		= EFI_INVALID_TABLE_ADDR,
 +	.config_table		= EFI_INVALID_TABLE_ADDR,
  	.esrt			= EFI_INVALID_TABLE_ADDR,
 +	.properties_table	= EFI_INVALID_TABLE_ADDR,
 +	.mem_attr_table		= EFI_INVALID_TABLE_ADDR,
 +	.rng_seed		= EFI_INVALID_TABLE_ADDR,
  	.tpm_log		= EFI_INVALID_TABLE_ADDR,
++<<<<<<< HEAD
 +	.mem_reserve		= EFI_INVALID_TABLE_ADDR,
++=======
+ 	.tpm_final_log		= EFI_INVALID_TABLE_ADDR,
+ #ifdef CONFIG_LOAD_UEFI_KEYS
+ 	.mokvar_table		= EFI_INVALID_TABLE_ADDR,
+ #endif
++>>>>>>> 58c909022a5a (efi: Support for MOK variable config table)
  };
  EXPORT_SYMBOL(efi);
  
@@@ -486,30 -505,30 +493,37 @@@ void __init efi_mem_reserve(phys_addr_
  	efi_arch_mem_reserve(addr, size);
  }
  
 -static const efi_config_table_type_t common_tables[] __initconst = {
 -	{ACPI_20_TABLE_GUID,			&efi.acpi20,		"ACPI 2.0"	},
 -	{ACPI_TABLE_GUID,			&efi.acpi,		"ACPI"		},
 -	{SMBIOS_TABLE_GUID,			&efi.smbios,		"SMBIOS"	},
 -	{SMBIOS3_TABLE_GUID,			&efi.smbios3,		"SMBIOS 3.0"	},
 -	{EFI_SYSTEM_RESOURCE_TABLE_GUID,	&efi.esrt,		"ESRT"		},
 -	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID,	&efi_mem_attr_table,	"MEMATTR"	},
 -	{LINUX_EFI_RANDOM_SEED_TABLE_GUID,	&efi_rng_seed,		"RNG"		},
 -	{LINUX_EFI_TPM_EVENT_LOG_GUID,		&efi.tpm_log,		"TPMEventLog"	},
 -	{LINUX_EFI_TPM_FINAL_LOG_GUID,		&efi.tpm_final_log,	"TPMFinalLog"	},
 -	{LINUX_EFI_MEMRESERVE_TABLE_GUID,	&mem_reserve,		"MEMRESERVE"	},
 -	{EFI_RT_PROPERTIES_TABLE_GUID,		&rt_prop,		"RTPROP"	},
 +static __initdata efi_config_table_type_t common_tables[] = {
 +	{ACPI_20_TABLE_GUID, "ACPI 2.0", &efi.acpi20},
 +	{ACPI_TABLE_GUID, "ACPI", &efi.acpi},
 +	{HCDP_TABLE_GUID, "HCDP", &efi.hcdp},
 +	{MPS_TABLE_GUID, "MPS", &efi.mps},
 +	{SAL_SYSTEM_TABLE_GUID, "SALsystab", &efi.sal_systab},
 +	{SMBIOS_TABLE_GUID, "SMBIOS", &efi.smbios},
 +	{SMBIOS3_TABLE_GUID, "SMBIOS 3.0", &efi.smbios3},
 +	{UGA_IO_PROTOCOL_GUID, "UGA", &efi.uga},
 +	{EFI_SYSTEM_RESOURCE_TABLE_GUID, "ESRT", &efi.esrt},
 +	{EFI_PROPERTIES_TABLE_GUID, "PROP", &efi.properties_table},
 +	{EFI_MEMORY_ATTRIBUTES_TABLE_GUID, "MEMATTR", &efi.mem_attr_table},
 +	{LINUX_EFI_RANDOM_SEED_TABLE_GUID, "RNG", &efi.rng_seed},
 +	{LINUX_EFI_TPM_EVENT_LOG_GUID, "TPMEventLog", &efi.tpm_log},
 +	{LINUX_EFI_MEMRESERVE_TABLE_GUID, "MEMRESERVE", &efi.mem_reserve},
  #ifdef CONFIG_EFI_RCI2_TABLE
 -	{DELLEMC_EFI_RCI2_TABLE_GUID,		&rci2_table_phys			},
 +	{DELLEMC_EFI_RCI2_TABLE_GUID, NULL, &rci2_table_phys},
  #endif
++<<<<<<< HEAD
 +	{NULL_GUID, NULL, NULL},
++=======
+ #ifdef CONFIG_LOAD_UEFI_KEYS
+ 	{LINUX_EFI_MOK_VARIABLE_TABLE_GUID,	&efi.mokvar_table,	"MOKvar"	},
+ #endif
+ 	{},
++>>>>>>> 58c909022a5a (efi: Support for MOK variable config table)
  };
  
 -static __init int match_config_table(const efi_guid_t *guid,
 +static __init int match_config_table(efi_guid_t *guid,
  				     unsigned long table,
 -				     const efi_config_table_type_t *table_types)
 +				     efi_config_table_type_t *table_types)
  {
  	int i;
  
diff --cc include/linux/efi.h
index 215834abdb1f,4a2332f146eb..000000000000
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@@ -677,7 -353,11 +677,12 @@@ void efi_native_runtime_setup(void)
  #define LINUX_EFI_LOADER_ENTRY_GUID		EFI_GUID(0x4a67b082, 0x0a4c, 0x41cf,  0xb6, 0xc7, 0x44, 0x0b, 0x29, 0xbb, 0x8c, 0x4f)
  #define LINUX_EFI_RANDOM_SEED_TABLE_GUID	EFI_GUID(0x1ce1e5bc, 0x7ceb, 0x42f2,  0x81, 0xe5, 0x8a, 0xad, 0xf1, 0x80, 0xf5, 0x7b)
  #define LINUX_EFI_TPM_EVENT_LOG_GUID		EFI_GUID(0xb7799cb0, 0xeca2, 0x4943,  0x96, 0x67, 0x1f, 0xae, 0x07, 0xb7, 0x47, 0xfa)
 -#define LINUX_EFI_TPM_FINAL_LOG_GUID		EFI_GUID(0x1e2ed096, 0x30e2, 0x4254,  0xbd, 0x89, 0x86, 0x3b, 0xbe, 0xf8, 0x23, 0x25)
  #define LINUX_EFI_MEMRESERVE_TABLE_GUID		EFI_GUID(0x888eb0c6, 0x8ede, 0x4ff5,  0xa8, 0xf0, 0x9a, 0xee, 0x5c, 0xb9, 0x77, 0xc2)
++<<<<<<< HEAD
++=======
+ #define LINUX_EFI_INITRD_MEDIA_GUID		EFI_GUID(0x5568e427, 0x68fc, 0x4f3d,  0xac, 0x74, 0xca, 0x55, 0x52, 0x31, 0xcc, 0x68)
+ #define LINUX_EFI_MOK_VARIABLE_TABLE_GUID	EFI_GUID(0xc451ed2b, 0x9694, 0x45d3,  0xba, 0xba, 0xed, 0x9f, 0x89, 0x88, 0xa3, 0x89)
++>>>>>>> 58c909022a5a (efi: Support for MOK variable config table)
  
  /* OEM GUIDs */
  #define DELLEMC_EFI_RCI2_TABLE_GUID		EFI_GUID(0x2d9f28a2, 0xa886, 0x456a,  0x97, 0xa8, 0xf1, 0x1e, 0xf2, 0x4f, 0xf4, 0x55)
@@@ -957,46 -536,58 +962,79 @@@ typedef struct 
   * All runtime access to EFI goes through this structure:
   */
  extern struct efi {
++<<<<<<< HEAD
 +	efi_system_table_t *systab;	/* EFI system table */
 +	unsigned int runtime_version;	/* Runtime services version */
 +	unsigned long mps;		/* MPS table */
 +	unsigned long acpi;		/* ACPI table  (IA64 ext 0.71) */
 +	unsigned long acpi20;		/* ACPI table  (ACPI 2.0) */
 +	unsigned long smbios;		/* SMBIOS table (32 bit entry point) */
 +	unsigned long smbios3;		/* SMBIOS table (64 bit entry point) */
 +	unsigned long sal_systab;	/* SAL system table */
 +	unsigned long boot_info;	/* boot info table */
 +	unsigned long hcdp;		/* HCDP table */
 +	unsigned long uga;		/* UGA table */
 +	unsigned long uv_systab;	/* UV system table */
 +	unsigned long fw_vendor;	/* fw_vendor */
 +	unsigned long runtime;		/* runtime table */
 +	unsigned long config_table;	/* config tables */
 +	unsigned long esrt;		/* ESRT table */
 +	unsigned long properties_table;	/* properties table */
 +	unsigned long mem_attr_table;	/* memory attributes table */
 +	unsigned long rng_seed;		/* UEFI firmware random seed */
 +	unsigned long tpm_log;		/* TPM2 Event Log table */
 +	unsigned long mem_reserve;	/* Linux EFI memreserve table */
 +	efi_get_time_t *get_time;
 +	efi_set_time_t *set_time;
 +	efi_get_wakeup_time_t *get_wakeup_time;
 +	efi_set_wakeup_time_t *set_wakeup_time;
 +	efi_get_variable_t *get_variable;
 +	efi_get_next_variable_t *get_next_variable;
 +	efi_set_variable_t *set_variable;
 +	efi_set_variable_t *set_variable_nonblocking;
 +	efi_query_variable_info_t *query_variable_info;
 +	efi_query_variable_info_t *query_variable_info_nonblocking;
 +	efi_update_capsule_t *update_capsule;
 +	efi_query_capsule_caps_t *query_capsule_caps;
 +	efi_get_next_high_mono_count_t *get_next_high_mono_count;
 +	efi_reset_system_t *reset_system;
 +	efi_set_virtual_address_map_t *set_virtual_address_map;
 +	struct efi_memory_map memmap;
 +	unsigned long flags;
++=======
+ 	const efi_runtime_services_t	*runtime;		/* EFI runtime services table */
+ 	unsigned int			runtime_version;	/* Runtime services version */
+ 	unsigned int			runtime_supported_mask;
+ 
+ 	unsigned long			acpi;			/* ACPI table  (IA64 ext 0.71) */
+ 	unsigned long			acpi20;			/* ACPI table  (ACPI 2.0) */
+ 	unsigned long			smbios;			/* SMBIOS table (32 bit entry point) */
+ 	unsigned long			smbios3;		/* SMBIOS table (64 bit entry point) */
+ 	unsigned long			esrt;			/* ESRT table */
+ 	unsigned long			tpm_log;		/* TPM2 Event Log table */
+ 	unsigned long			tpm_final_log;		/* TPM2 Final Events Log table */
+ 	unsigned long			mokvar_table;		/* MOK variable config table */
+ 
+ 	efi_get_time_t			*get_time;
+ 	efi_set_time_t			*set_time;
+ 	efi_get_wakeup_time_t		*get_wakeup_time;
+ 	efi_set_wakeup_time_t		*set_wakeup_time;
+ 	efi_get_variable_t		*get_variable;
+ 	efi_get_next_variable_t		*get_next_variable;
+ 	efi_set_variable_t		*set_variable;
+ 	efi_set_variable_t		*set_variable_nonblocking;
+ 	efi_query_variable_info_t	*query_variable_info;
+ 	efi_query_variable_info_t	*query_variable_info_nonblocking;
+ 	efi_update_capsule_t		*update_capsule;
+ 	efi_query_capsule_caps_t	*query_capsule_caps;
+ 	efi_get_next_high_mono_count_t	*get_next_high_mono_count;
+ 	efi_reset_system_t		*reset_system;
+ 
+ 	struct efi_memory_map		memmap;
+ 	unsigned long			flags;
++>>>>>>> 58c909022a5a (efi: Support for MOK variable config table)
  } efi;
  
 -#define EFI_RT_SUPPORTED_GET_TIME 				0x0001
 -#define EFI_RT_SUPPORTED_SET_TIME 				0x0002
 -#define EFI_RT_SUPPORTED_GET_WAKEUP_TIME			0x0004
 -#define EFI_RT_SUPPORTED_SET_WAKEUP_TIME			0x0008
 -#define EFI_RT_SUPPORTED_GET_VARIABLE				0x0010
 -#define EFI_RT_SUPPORTED_GET_NEXT_VARIABLE_NAME			0x0020
 -#define EFI_RT_SUPPORTED_SET_VARIABLE				0x0040
 -#define EFI_RT_SUPPORTED_SET_VIRTUAL_ADDRESS_MAP		0x0080
 -#define EFI_RT_SUPPORTED_CONVERT_POINTER			0x0100
 -#define EFI_RT_SUPPORTED_GET_NEXT_HIGH_MONOTONIC_COUNT		0x0200
 -#define EFI_RT_SUPPORTED_RESET_SYSTEM				0x0400
 -#define EFI_RT_SUPPORTED_UPDATE_CAPSULE				0x0800
 -#define EFI_RT_SUPPORTED_QUERY_CAPSULE_CAPABILITIES		0x1000
 -#define EFI_RT_SUPPORTED_QUERY_VARIABLE_INFO			0x2000
 -
 -#define EFI_RT_SUPPORTED_ALL					0x3fff
 -
 -#define EFI_RT_SUPPORTED_TIME_SERVICES				0x000f
 -#define EFI_RT_SUPPORTED_VARIABLE_SERVICES			0x0070
 -
  extern struct mm_struct efi_mm;
  
  static inline int
@@@ -1765,13 -1244,46 +1803,45 @@@ struct linux_efi_memreserve 
  	struct {
  		phys_addr_t	base;
  		phys_addr_t	size;
 -	} entry[];
 +	} entry[0];
  };
  
 -#define EFI_MEMRESERVE_COUNT(size) (((size) - sizeof(struct linux_efi_memreserve)) \
 -	/ sizeof_field(struct linux_efi_memreserve, entry[0]))
 -
 -void __init efi_arch_mem_reserve(phys_addr_t addr, u64 size);
 +#define EFI_MEMRESERVE_SIZE(count) (sizeof(struct linux_efi_memreserve) + \
 +	(count) * sizeof(((struct linux_efi_memreserve *)0)->entry[0]))
  
 -char *efi_systab_show_arch(char *str);
 +#define EFI_MEMRESERVE_COUNT(size) (((size) - sizeof(struct linux_efi_memreserve)) \
 +	/ sizeof(((struct linux_efi_memreserve *)0)->entry[0]))
  
+ /*
+  * The LINUX_EFI_MOK_VARIABLE_TABLE_GUID config table can be provided
+  * to the kernel by an EFI boot loader. The table contains a packed
+  * sequence of these entries, one for each named MOK variable.
+  * The sequence is terminated by an entry with a completely NULL
+  * name and 0 data size.
+  */
+ struct efi_mokvar_table_entry {
+ 	char name[256];
+ 	u64 data_size;
+ 	u8 data[];
+ } __attribute((packed));
+ 
+ #ifdef CONFIG_LOAD_UEFI_KEYS
+ extern void __init efi_mokvar_table_init(void);
+ extern struct efi_mokvar_table_entry *efi_mokvar_entry_next(
+ 			struct efi_mokvar_table_entry **mokvar_entry);
+ extern struct efi_mokvar_table_entry *efi_mokvar_entry_find(const char *name);
+ #else
+ static inline void efi_mokvar_table_init(void) { }
+ static inline struct efi_mokvar_table_entry *efi_mokvar_entry_next(
+ 			struct efi_mokvar_table_entry **mokvar_entry)
+ {
+ 	return NULL;
+ }
+ static inline struct efi_mokvar_table_entry *efi_mokvar_entry_find(
+ 			const char *name)
+ {
+ 	return NULL;
+ }
+ #endif
+ 
  #endif /* _LINUX_EFI_H */
* Unmerged path drivers/firmware/efi/efi-init.c
* Unmerged path arch/x86/kernel/setup.c
* Unmerged path arch/x86/platform/efi/efi.c
* Unmerged path drivers/firmware/efi/Makefile
* Unmerged path drivers/firmware/efi/efi-init.c
* Unmerged path drivers/firmware/efi/efi.c
diff --git a/drivers/firmware/efi/mokvar-table.c b/drivers/firmware/efi/mokvar-table.c
new file mode 100644
index 000000000000..b1cd49893d4d
--- /dev/null
+++ b/drivers/firmware/efi/mokvar-table.c
@@ -0,0 +1,360 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * mokvar-table.c
+ *
+ * Copyright (c) 2020 Red Hat
+ * Author: Lenny Szubowicz <lszubowi@redhat.com>
+ *
+ * This module contains the kernel support for the Linux EFI Machine
+ * Owner Key (MOK) variable configuration table, which is identified by
+ * the LINUX_EFI_MOK_VARIABLE_TABLE_GUID.
+ *
+ * This EFI configuration table provides a more robust alternative to
+ * EFI volatile variables by which an EFI boot loader can pass the
+ * contents of the Machine Owner Key (MOK) certificate stores to the
+ * kernel during boot. If both the EFI MOK config table and corresponding
+ * EFI MOK variables are present, the table should be considered as
+ * more authoritative.
+ *
+ * This module includes code that validates and maps the EFI MOK table,
+ * if it's presence was detected very early in boot.
+ *
+ * Kernel interface routines are provided to walk through all the
+ * entries in the MOK config table or to search for a specific named
+ * entry.
+ *
+ * The contents of the individual named MOK config table entries are
+ * made available to user space via read-only sysfs binary files under:
+ *
+ * /sys/firmware/efi/mok-variables/
+ *
+ */
+#define pr_fmt(fmt) "mokvar: " fmt
+
+#include <linux/capability.h>
+#include <linux/efi.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/kobject.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+
+/*
+ * The LINUX_EFI_MOK_VARIABLE_TABLE_GUID config table is a packed
+ * sequence of struct efi_mokvar_table_entry, one for each named
+ * MOK variable. The sequence is terminated by an entry with a
+ * completely NULL name and 0 data size.
+ *
+ * efi_mokvar_table_size is set to the computed size of the
+ * MOK config table by efi_mokvar_table_init(). This will be
+ * non-zero if and only if the table if present and has been
+ * validated by efi_mokvar_table_init().
+ */
+static size_t efi_mokvar_table_size;
+
+/*
+ * efi_mokvar_table_va is the kernel virtual address at which the
+ * EFI MOK config table has been mapped by efi_mokvar_sysfs_init().
+ */
+static struct efi_mokvar_table_entry *efi_mokvar_table_va;
+
+/*
+ * Each /sys/firmware/efi/mok-variables/ sysfs file is represented by
+ * an instance of struct efi_mokvar_sysfs_attr on efi_mokvar_sysfs_list.
+ * bin_attr.private points to the associated EFI MOK config table entry.
+ *
+ * This list is created during boot and then remains unchanged.
+ * So no synchronization is currently required to walk the list.
+ */
+struct efi_mokvar_sysfs_attr {
+	struct bin_attribute bin_attr;
+	struct list_head node;
+};
+
+static LIST_HEAD(efi_mokvar_sysfs_list);
+static struct kobject *mokvar_kobj;
+
+/*
+ * efi_mokvar_table_init() - Early boot validation of EFI MOK config table
+ *
+ * If present, validate and compute the size of the EFI MOK variable
+ * configuration table. This table may be provided by an EFI boot loader
+ * as an alternative to ordinary EFI variables, due to platform-dependent
+ * limitations. The memory occupied by this table is marked as reserved.
+ *
+ * This routine must be called before efi_free_boot_services() in order
+ * to guarantee that it can mark the table as reserved.
+ *
+ * Implicit inputs:
+ * efi.mokvar_table:	Physical address of EFI MOK variable config table
+ *			or special value that indicates no such table.
+ *
+ * Implicit outputs:
+ * efi_mokvar_table_size: Computed size of EFI MOK variable config table.
+ *			The table is considered present and valid if this
+ *			is non-zero.
+ */
+void __init efi_mokvar_table_init(void)
+{
+	efi_memory_desc_t md;
+	u64 end_pa;
+	void *va = NULL;
+	size_t cur_offset = 0;
+	size_t offset_limit;
+	size_t map_size = 0;
+	size_t map_size_needed = 0;
+	size_t size;
+	struct efi_mokvar_table_entry *mokvar_entry;
+	int err = -EINVAL;
+
+	if (!efi_enabled(EFI_MEMMAP))
+		return;
+
+	if (efi.mokvar_table == EFI_INVALID_TABLE_ADDR)
+		return;
+	/*
+	 * The EFI MOK config table must fit within a single EFI memory
+	 * descriptor range.
+	 */
+	err = efi_mem_desc_lookup(efi.mokvar_table, &md);
+	if (err) {
+		pr_warn("EFI MOKvar config table is not within the EFI memory map\n");
+		return;
+	}
+	end_pa = efi_mem_desc_end(&md);
+	if (efi.mokvar_table >= end_pa) {
+		pr_err("EFI memory descriptor containing MOKvar config table is invalid\n");
+		return;
+	}
+	offset_limit = end_pa - efi.mokvar_table;
+	/*
+	 * Validate the MOK config table. Since there is no table header
+	 * from which we could get the total size of the MOK config table,
+	 * we compute the total size as we validate each variably sized
+	 * entry, remapping as necessary.
+	 */
+	while (cur_offset + sizeof(*mokvar_entry) <= offset_limit) {
+		mokvar_entry = va + cur_offset;
+		map_size_needed = cur_offset + sizeof(*mokvar_entry);
+		if (map_size_needed > map_size) {
+			if (va)
+				early_memunmap(va, map_size);
+			/*
+			 * Map a little more than the fixed size entry
+			 * header, anticipating some data. It's safe to
+			 * do so as long as we stay within current memory
+			 * descriptor.
+			 */
+			map_size = min(map_size_needed + 2*EFI_PAGE_SIZE,
+				       offset_limit);
+			va = early_memremap(efi.mokvar_table, map_size);
+			if (!va) {
+				pr_err("Failed to map EFI MOKvar config table pa=0x%lx, size=%zu.\n",
+				       efi.mokvar_table, map_size);
+				return;
+			}
+			mokvar_entry = va + cur_offset;
+		}
+
+		/* Check for last sentinel entry */
+		if (mokvar_entry->name[0] == '\0') {
+			if (mokvar_entry->data_size != 0)
+				break;
+			err = 0;
+			break;
+		}
+
+		/* Sanity check that the name is null terminated */
+		size = strnlen(mokvar_entry->name,
+			       sizeof(mokvar_entry->name));
+		if (size >= sizeof(mokvar_entry->name))
+			break;
+
+		/* Advance to the next entry */
+		cur_offset = map_size_needed + mokvar_entry->data_size;
+	}
+
+	if (va)
+		early_memunmap(va, map_size);
+	if (err) {
+		pr_err("EFI MOKvar config table is not valid\n");
+		return;
+	}
+	efi_mem_reserve(efi.mokvar_table, map_size_needed);
+	efi_mokvar_table_size = map_size_needed;
+}
+
+/*
+ * efi_mokvar_entry_next() - Get next entry in the EFI MOK config table
+ *
+ * mokvar_entry:	Pointer to current EFI MOK config table entry
+ *			or null. Null indicates get first entry.
+ *			Passed by reference. This is updated to the
+ *			same value as the return value.
+ *
+ * Returns:		Pointer to next EFI MOK config table entry
+ *			or null, if there are no more entries.
+ *			Same value is returned in the mokvar_entry
+ *			parameter.
+ *
+ * This routine depends on the EFI MOK config table being entirely
+ * mapped with it's starting virtual address in efi_mokvar_table_va.
+ */
+struct efi_mokvar_table_entry *efi_mokvar_entry_next(
+			struct efi_mokvar_table_entry **mokvar_entry)
+{
+	struct efi_mokvar_table_entry *mokvar_cur;
+	struct efi_mokvar_table_entry *mokvar_next;
+	size_t size_cur;
+
+	mokvar_cur = *mokvar_entry;
+	*mokvar_entry = NULL;
+
+	if (efi_mokvar_table_va == NULL)
+		return NULL;
+
+	if (mokvar_cur == NULL) {
+		mokvar_next = efi_mokvar_table_va;
+	} else {
+		if (mokvar_cur->name[0] == '\0')
+			return NULL;
+		size_cur = sizeof(*mokvar_cur) + mokvar_cur->data_size;
+		mokvar_next = (void *)mokvar_cur + size_cur;
+	}
+
+	if (mokvar_next->name[0] == '\0')
+		return NULL;
+
+	*mokvar_entry = mokvar_next;
+	return mokvar_next;
+}
+
+/*
+ * efi_mokvar_entry_find() - Find EFI MOK config entry by name
+ *
+ * name:	Name of the entry to look for.
+ *
+ * Returns:	Pointer to EFI MOK config table entry if found;
+ *		null otherwise.
+ *
+ * This routine depends on the EFI MOK config table being entirely
+ * mapped with it's starting virtual address in efi_mokvar_table_va.
+ */
+struct efi_mokvar_table_entry *efi_mokvar_entry_find(const char *name)
+{
+	struct efi_mokvar_table_entry *mokvar_entry = NULL;
+
+	while (efi_mokvar_entry_next(&mokvar_entry)) {
+		if (!strncmp(name, mokvar_entry->name,
+			     sizeof(mokvar_entry->name)))
+			return mokvar_entry;
+	}
+	return NULL;
+}
+
+/*
+ * efi_mokvar_sysfs_read() - sysfs binary file read routine
+ *
+ * Returns:	Count of bytes read.
+ *
+ * Copy EFI MOK config table entry data for this mokvar sysfs binary file
+ * to the supplied buffer, starting at the specified offset into mokvar table
+ * entry data, for the specified count bytes. The copy is limited by the
+ * amount of data in this mokvar config table entry.
+ */
+static ssize_t efi_mokvar_sysfs_read(struct file *file, struct kobject *kobj,
+				 struct bin_attribute *bin_attr, char *buf,
+				 loff_t off, size_t count)
+{
+	struct efi_mokvar_table_entry *mokvar_entry = bin_attr->private;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return 0;
+
+	if (off >= mokvar_entry->data_size)
+		return 0;
+	if (count >  mokvar_entry->data_size - off)
+		count = mokvar_entry->data_size - off;
+
+	memcpy(buf, mokvar_entry->data + off, count);
+	return count;
+}
+
+/*
+ * efi_mokvar_sysfs_init() - Map EFI MOK config table and create sysfs
+ *
+ * Map the EFI MOK variable config table for run-time use by the kernel
+ * and create the sysfs entries in /sys/firmware/efi/mok-variables/
+ *
+ * This routine just returns if a valid EFI MOK variable config table
+ * was not found earlier during boot.
+ *
+ * This routine must be called during a "middle" initcall phase, i.e.
+ * after efi_mokvar_table_init() but before UEFI certs are loaded
+ * during late init.
+ *
+ * Implicit inputs:
+ * efi.mokvar_table:	Physical address of EFI MOK variable config table
+ *			or special value that indicates no such table.
+ *
+ * efi_mokvar_table_size: Computed size of EFI MOK variable config table.
+ *			The table is considered present and valid if this
+ *			is non-zero.
+ *
+ * Implicit outputs:
+ * efi_mokvar_table_va:	Start virtual address of the EFI MOK config table.
+ */
+static int __init efi_mokvar_sysfs_init(void)
+{
+	void *config_va;
+	struct efi_mokvar_table_entry *mokvar_entry = NULL;
+	struct efi_mokvar_sysfs_attr *mokvar_sysfs = NULL;
+	int err = 0;
+
+	if (efi_mokvar_table_size == 0)
+		return -ENOENT;
+
+	config_va = memremap(efi.mokvar_table, efi_mokvar_table_size,
+			     MEMREMAP_WB);
+	if (!config_va) {
+		pr_err("Failed to map EFI MOKvar config table\n");
+		return -ENOMEM;
+	}
+	efi_mokvar_table_va = config_va;
+
+	mokvar_kobj = kobject_create_and_add("mok-variables", efi_kobj);
+	if (!mokvar_kobj) {
+		pr_err("Failed to create EFI mok-variables sysfs entry\n");
+		return -ENOMEM;
+	}
+
+	while (efi_mokvar_entry_next(&mokvar_entry)) {
+		mokvar_sysfs = kzalloc(sizeof(*mokvar_sysfs), GFP_KERNEL);
+		if (!mokvar_sysfs) {
+			err = -ENOMEM;
+			break;
+		}
+
+		sysfs_bin_attr_init(&mokvar_sysfs->bin_attr);
+		mokvar_sysfs->bin_attr.private = mokvar_entry;
+		mokvar_sysfs->bin_attr.attr.name = mokvar_entry->name;
+		mokvar_sysfs->bin_attr.attr.mode = 0400;
+		mokvar_sysfs->bin_attr.size = mokvar_entry->data_size;
+		mokvar_sysfs->bin_attr.read = efi_mokvar_sysfs_read;
+
+		err = sysfs_create_bin_file(mokvar_kobj,
+					   &mokvar_sysfs->bin_attr);
+		if (err)
+			break;
+
+		list_add_tail(&mokvar_sysfs->node, &efi_mokvar_sysfs_list);
+	}
+
+	if (err) {
+		pr_err("Failed to create some EFI mok-variables sysfs entries\n");
+		kfree(mokvar_sysfs);
+	}
+	return err;
+}
+device_initcall(efi_mokvar_sysfs_init);
* Unmerged path include/linux/efi.h
