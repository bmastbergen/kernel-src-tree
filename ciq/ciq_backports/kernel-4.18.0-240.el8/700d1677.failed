ASoC: SOF: pm: Introduce DSP power states

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: SOF: pm: Introduce DSP power states (Jaroslav Kysela) [1797509]
Rebuild_FUZZ: 93.18%
commit-author Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
commit 700d167739a099cdf12ed15c25fec7f4cb563d42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/700d1677.failed

Add a new enum sof_dsp_power_states for all the possible
the DSP device states. The SOF driver currently handles
only the D0 and D3 states and support for other states
will be added later as needed.

Also, add a helper to determine the target DSP power state
based on the system suspend target.
The snd_sof_dsp_d0i3_on_suspend() function is renamed to
snd_sof_stream_suspend_ignored() to be more indicative
of what it does and it used to determine the target
DSP state during system suspend.

	Signed-off-by: Ranjani Sridharan <ranjani.sridharan@linux.intel.com>
	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Link: https://lore.kernel.org/r/20200129220726.31792-5-pierre-louis.bossart@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 700d167739a099cdf12ed15c25fec7f4cb563d42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/pm.c
#	sound/soc/sof/sof-audio.c
#	sound/soc/sof/sof-audio.h
#	sound/soc/sof/sof-priv.h
diff --cc sound/soc/sof/pm.c
index 349af485a3a0,bec25cb6beec..000000000000
--- a/sound/soc/sof/pm.c
+++ b/sound/soc/sof/pm.c
@@@ -10,193 -10,44 +10,229 @@@
  
  #include "ops.h"
  #include "sof-priv.h"
 -#include "sof-audio.h"
 +
 +static int sof_restore_kcontrols(struct snd_sof_dev *sdev)
 +{
 +	struct snd_sof_control *scontrol;
 +	int ipc_cmd, ctrl_type;
 +	int ret = 0;
 +
 +	/* restore kcontrol values */
 +	list_for_each_entry(scontrol, &sdev->kcontrol_list, list) {
 +		/* reset readback offset for scontrol after resuming */
 +		scontrol->readback_offset = 0;
 +
 +		/* notify DSP of kcontrol values */
 +		switch (scontrol->cmd) {
 +		case SOF_CTRL_CMD_VOLUME:
 +		case SOF_CTRL_CMD_ENUM:
 +		case SOF_CTRL_CMD_SWITCH:
 +			ipc_cmd = SOF_IPC_COMP_SET_VALUE;
 +			ctrl_type = SOF_CTRL_TYPE_VALUE_CHAN_SET;
 +			ret = snd_sof_ipc_set_get_comp_data(sdev->ipc, scontrol,
 +							    ipc_cmd, ctrl_type,
 +							    scontrol->cmd,
 +							    true);
 +			break;
 +		case SOF_CTRL_CMD_BINARY:
 +			ipc_cmd = SOF_IPC_COMP_SET_DATA;
 +			ctrl_type = SOF_CTRL_TYPE_DATA_SET;
 +			ret = snd_sof_ipc_set_get_comp_data(sdev->ipc, scontrol,
 +							    ipc_cmd, ctrl_type,
 +							    scontrol->cmd,
 +							    true);
 +			break;
 +
 +		default:
 +			break;
 +		}
 +
 +		if (ret < 0) {
 +			dev_err(sdev->dev,
 +				"error: failed kcontrol value set for widget: %d\n",
 +				scontrol->comp_id);
 +
 +			return ret;
 +		}
 +	}
 +
 +	return 0;
 +}
 +
 +static int sof_restore_pipelines(struct snd_sof_dev *sdev)
 +{
 +	struct snd_sof_widget *swidget;
 +	struct snd_sof_route *sroute;
 +	struct sof_ipc_pipe_new *pipeline;
 +	struct snd_sof_dai *dai;
 +	struct sof_ipc_comp_dai *comp_dai;
 +	struct sof_ipc_cmd_hdr *hdr;
 +	int ret;
 +
 +	/* restore pipeline components */
 +	list_for_each_entry_reverse(swidget, &sdev->widget_list, list) {
 +		struct sof_ipc_comp_reply r;
 +
 +		/* skip if there is no private data */
 +		if (!swidget->private)
 +			continue;
 +
 +		switch (swidget->id) {
 +		case snd_soc_dapm_dai_in:
 +		case snd_soc_dapm_dai_out:
 +			dai = swidget->private;
 +			comp_dai = &dai->comp_dai;
 +			ret = sof_ipc_tx_message(sdev->ipc,
 +						 comp_dai->comp.hdr.cmd,
 +						 comp_dai, sizeof(*comp_dai),
 +						 &r, sizeof(r));
 +			break;
 +		case snd_soc_dapm_scheduler:
 +
 +			/*
 +			 * During suspend, all DSP cores are powered off.
 +			 * Therefore upon resume, create the pipeline comp
 +			 * and power up the core that the pipeline is
 +			 * scheduled on.
 +			 */
 +			pipeline = swidget->private;
 +			ret = sof_load_pipeline_ipc(sdev, pipeline, &r);
 +			break;
 +		default:
 +			hdr = swidget->private;
 +			ret = sof_ipc_tx_message(sdev->ipc, hdr->cmd,
 +						 swidget->private, hdr->size,
 +						 &r, sizeof(r));
 +			break;
 +		}
 +		if (ret < 0) {
 +			dev_err(sdev->dev,
 +				"error: failed to load widget type %d with ID: %d\n",
 +				swidget->widget->id, swidget->comp_id);
 +
 +			return ret;
 +		}
 +	}
 +
 +	/* restore pipeline connections */
 +	list_for_each_entry_reverse(sroute, &sdev->route_list, list) {
 +		struct sof_ipc_pipe_comp_connect *connect;
 +		struct sof_ipc_reply reply;
 +
 +		/* skip if there's no private data */
 +		if (!sroute->private)
 +			continue;
 +
 +		connect = sroute->private;
 +
 +		/* send ipc */
 +		ret = sof_ipc_tx_message(sdev->ipc,
 +					 connect->hdr.cmd,
 +					 connect, sizeof(*connect),
 +					 &reply, sizeof(reply));
 +		if (ret < 0) {
 +			dev_err(sdev->dev,
 +				"error: failed to load route sink %s control %s source %s\n",
 +				sroute->route->sink,
 +				sroute->route->control ? sroute->route->control
 +					: "none",
 +				sroute->route->source);
 +
 +			return ret;
 +		}
 +	}
 +
 +	/* restore dai links */
 +	list_for_each_entry_reverse(dai, &sdev->dai_list, list) {
 +		struct sof_ipc_reply reply;
 +		struct sof_ipc_dai_config *config = dai->dai_config;
 +
 +		if (!config) {
 +			dev_err(sdev->dev, "error: no config for DAI %s\n",
 +				dai->name);
 +			continue;
 +		}
 +
 +		/*
 +		 * The link DMA channel would be invalidated for running
 +		 * streams but not for streams that were in the PAUSED
 +		 * state during suspend. So invalidate it here before setting
 +		 * the dai config in the DSP.
 +		 */
 +		if (config->type == SOF_DAI_INTEL_HDA)
 +			config->hda.link_dma_ch = DMA_CHAN_INVALID;
 +
 +		ret = sof_ipc_tx_message(sdev->ipc,
 +					 config->hdr.cmd, config,
 +					 config->hdr.size,
 +					 &reply, sizeof(reply));
 +
 +		if (ret < 0) {
 +			dev_err(sdev->dev,
 +				"error: failed to set dai config for %s\n",
 +				dai->name);
 +
 +			return ret;
 +		}
 +	}
 +
 +	/* complete pipeline */
 +	list_for_each_entry(swidget, &sdev->widget_list, list) {
 +		switch (swidget->id) {
 +		case snd_soc_dapm_scheduler:
 +			swidget->complete =
 +				snd_sof_complete_pipeline(sdev, swidget);
 +			break;
 +		default:
 +			break;
 +		}
 +	}
 +
 +	/* restore pipeline kcontrols */
 +	ret = sof_restore_kcontrols(sdev);
 +	if (ret < 0)
 +		dev_err(sdev->dev,
 +			"error: restoring kcontrols after resume\n");
 +
 +	return ret;
 +}
  
+ /*
+  * Helper function to determine the target DSP state during
+  * system suspend. This function only cares about the device
+  * D-states. Platform-specific substates, if any, should be
+  * handled by the platform-specific parts.
+  */
+ static u32 snd_sof_dsp_power_target(struct snd_sof_dev *sdev)
+ {
+ 	u32 target_dsp_state;
+ 
+ 	switch (sdev->system_suspend_target) {
+ 	case SOF_SUSPEND_S3:
+ 		/* DSP should be in D3 if the system is suspending to S3 */
+ 		target_dsp_state = SOF_DSP_PM_D3;
+ 		break;
+ 	case SOF_SUSPEND_S0IX:
+ 		/*
+ 		 * Currently, the only criterion for retaining the DSP in D0
+ 		 * is that there are streams that ignored the suspend trigger.
+ 		 * Additional criteria such Soundwire clock-stop mode and
+ 		 * device suspend latency considerations will be added later.
+ 		 */
+ 		if (snd_sof_stream_suspend_ignored(sdev))
+ 			target_dsp_state = SOF_DSP_PM_D0;
+ 		else
+ 			target_dsp_state = SOF_DSP_PM_D3;
+ 		break;
+ 	default:
+ 		/* This case would be during runtime suspend */
+ 		target_dsp_state = SOF_DSP_PM_D3;
+ 		break;
+ 	}
+ 
+ 	return target_dsp_state;
+ }
+ 
  static int sof_send_pm_ctx_ipc(struct snd_sof_dev *sdev, int cmd)
  {
  	struct sof_ipc_pm_ctx pm_ctx;
@@@ -355,6 -205,22 +391,25 @@@ static int sof_suspend(struct device *d
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (snd_sof_dsp_power_target(sdev) == SOF_DSP_PM_D0) {
+ 		/* suspend to D0i3 */
+ 		ret = snd_sof_set_d0_substate(sdev, SOF_DSP_D0I3);
+ 		if (ret < 0) {
+ 			dev_err(sdev->dev, "error: failed to enter D0I3, %d\n",
+ 				ret);
+ 			return ret;
+ 		}
+ 
+ 		/* Skip to platform-specific suspend if DSP is entering D0I3 */
+ 		goto suspend;
+ 	}
+ 
+ 	/* release trace */
+ 	snd_sof_release_trace(sdev);
+ 
++>>>>>>> 700d167739a0 (ASoC: SOF: pm: Introduce DSP power states)
  #if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE)
  	/* cache debugfs contents during runtime suspend */
  	if (runtime_suspend)
diff --cc sound/soc/sof/sof-priv.h
index b6c2f9374075,a7c6109acd98..000000000000
--- a/sound/soc/sof/sof-priv.h
+++ b/sound/soc/sof/sof-priv.h
@@@ -66,7 -54,15 +66,19 @@@ extern int sof_core_debug
  	(IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_ENABLE_DEBUGFS_CACHE) || \
  	 IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST))
  
++<<<<<<< HEAD
 +#define DMA_CHAN_INVALID	0xFFFFFFFF
++=======
+ /* DSP power state */
+ enum sof_dsp_power_states {
+ 	SOF_DSP_PM_D0,
+ 	SOF_DSP_PM_D1,
+ 	SOF_DSP_PM_D2,
+ 	SOF_DSP_PM_D3_HOT,
+ 	SOF_DSP_PM_D3,
+ 	SOF_DSP_PM_D3_COLD,
+ };
++>>>>>>> 700d167739a0 (ASoC: SOF: pm: Introduce DSP power states)
  
  /* DSP D0ix sub-state */
  enum sof_d0_substate {
* Unmerged path sound/soc/sof/sof-audio.c
* Unmerged path sound/soc/sof/sof-audio.h
* Unmerged path sound/soc/sof/pm.c
* Unmerged path sound/soc/sof/sof-audio.c
* Unmerged path sound/soc/sof/sof-audio.h
* Unmerged path sound/soc/sof/sof-priv.h
