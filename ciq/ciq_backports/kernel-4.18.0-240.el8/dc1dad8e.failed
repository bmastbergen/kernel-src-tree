rbd: compression_hint option

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ilya Dryomov <idryomov@gmail.com>
commit dc1dad8e1a612650b1e786e992cb0c6e101e226a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dc1dad8e.failed

Allow hinting to bluestore if the data should/should not be compressed.
The default is to not hint (compression_hint=none).

	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
	Reviewed-by: Jason Dillaman <dillaman@redhat.com>
(cherry picked from commit dc1dad8e1a612650b1e786e992cb0c6e101e226a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/rbd.c
diff --cc drivers/block/rbd.c
index 6a6ed999b02e,7420648a1de6..000000000000
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@@ -835,34 -834,45 +835,69 @@@ enum 
  	Opt_queue_depth,
  	Opt_alloc_size,
  	Opt_lock_timeout,
 +	Opt_last_int,
  	/* int args above */
  	Opt_pool_ns,
++<<<<<<< HEAD
 +	Opt_last_string,
++=======
+ 	Opt_compression_hint,
++>>>>>>> dc1dad8e1a61 (rbd: compression_hint option)
  	/* string args above */
  	Opt_read_only,
  	Opt_read_write,
  	Opt_lock_on_read,
  	Opt_exclusive,
  	Opt_notrim,
 +	Opt_err
  };
  
++<<<<<<< HEAD
 +static match_table_t rbd_opts_tokens = {
 +	{Opt_queue_depth, "queue_depth=%d"},
 +	{Opt_alloc_size, "alloc_size=%d"},
 +	{Opt_lock_timeout, "lock_timeout=%d"},
 +	/* int args above */
 +	{Opt_pool_ns, "_pool_ns=%s"},
 +	/* string args above */
 +	{Opt_read_only, "read_only"},
 +	{Opt_read_only, "ro"},		/* Alternate spelling */
 +	{Opt_read_write, "read_write"},
 +	{Opt_read_write, "rw"},		/* Alternate spelling */
 +	{Opt_lock_on_read, "lock_on_read"},
 +	{Opt_exclusive, "exclusive"},
 +	{Opt_notrim, "notrim"},
 +	{Opt_err, NULL}
++=======
+ enum {
+ 	Opt_compression_hint_none,
+ 	Opt_compression_hint_compressible,
+ 	Opt_compression_hint_incompressible,
+ };
+ 
+ static const struct constant_table rbd_param_compression_hint[] = {
+ 	{"none",		Opt_compression_hint_none},
+ 	{"compressible",	Opt_compression_hint_compressible},
+ 	{"incompressible",	Opt_compression_hint_incompressible},
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec rbd_parameters[] = {
+ 	fsparam_u32	("alloc_size",			Opt_alloc_size),
+ 	fsparam_enum	("compression_hint",		Opt_compression_hint,
+ 			 rbd_param_compression_hint),
+ 	fsparam_flag	("exclusive",			Opt_exclusive),
+ 	fsparam_flag	("lock_on_read",		Opt_lock_on_read),
+ 	fsparam_u32	("lock_timeout",		Opt_lock_timeout),
+ 	fsparam_flag	("notrim",			Opt_notrim),
+ 	fsparam_string	("_pool_ns",			Opt_pool_ns),
+ 	fsparam_u32	("queue_depth",			Opt_queue_depth),
+ 	fsparam_flag	("read_only",			Opt_read_only),
+ 	fsparam_flag	("read_write",			Opt_read_write),
+ 	fsparam_flag	("ro",				Opt_read_only),
+ 	fsparam_flag	("rw",				Opt_read_write),
+ 	{}
++>>>>>>> dc1dad8e1a61 (rbd: compression_hint option)
  };
  
  struct rbd_options {
@@@ -6368,6 -6305,141 +6405,144 @@@ static inline char *dup_token(const cha
  	return dup;
  }
  
++<<<<<<< HEAD
++=======
+ static int rbd_parse_param(struct fs_parameter *param,
+ 			    struct rbd_parse_opts_ctx *pctx)
+ {
+ 	struct rbd_options *opt = pctx->opts;
+ 	struct fs_parse_result result;
+ 	struct p_log log = {.prefix = "rbd"};
+ 	int token, ret;
+ 
+ 	ret = ceph_parse_param(param, pctx->copts, NULL);
+ 	if (ret != -ENOPARAM)
+ 		return ret;
+ 
+ 	token = __fs_parse(&log, rbd_parameters, param, &result);
+ 	dout("%s fs_parse '%s' token %d\n", __func__, param->key, token);
+ 	if (token < 0) {
+ 		if (token == -ENOPARAM)
+ 			return inval_plog(&log, "Unknown parameter '%s'",
+ 					  param->key);
+ 		return token;
+ 	}
+ 
+ 	switch (token) {
+ 	case Opt_queue_depth:
+ 		if (result.uint_32 < 1)
+ 			goto out_of_range;
+ 		opt->queue_depth = result.uint_32;
+ 		break;
+ 	case Opt_alloc_size:
+ 		if (result.uint_32 < SECTOR_SIZE)
+ 			goto out_of_range;
+ 		if (!is_power_of_2(result.uint_32))
+ 			return inval_plog(&log, "alloc_size must be a power of 2");
+ 		opt->alloc_size = result.uint_32;
+ 		break;
+ 	case Opt_lock_timeout:
+ 		/* 0 is "wait forever" (i.e. infinite timeout) */
+ 		if (result.uint_32 > INT_MAX / 1000)
+ 			goto out_of_range;
+ 		opt->lock_timeout = msecs_to_jiffies(result.uint_32 * 1000);
+ 		break;
+ 	case Opt_pool_ns:
+ 		kfree(pctx->spec->pool_ns);
+ 		pctx->spec->pool_ns = param->string;
+ 		param->string = NULL;
+ 		break;
+ 	case Opt_compression_hint:
+ 		switch (result.uint_32) {
+ 		case Opt_compression_hint_none:
+ 			opt->alloc_hint_flags &=
+ 			    ~(CEPH_OSD_ALLOC_HINT_FLAG_COMPRESSIBLE |
+ 			      CEPH_OSD_ALLOC_HINT_FLAG_INCOMPRESSIBLE);
+ 			break;
+ 		case Opt_compression_hint_compressible:
+ 			opt->alloc_hint_flags |=
+ 			    CEPH_OSD_ALLOC_HINT_FLAG_COMPRESSIBLE;
+ 			opt->alloc_hint_flags &=
+ 			    ~CEPH_OSD_ALLOC_HINT_FLAG_INCOMPRESSIBLE;
+ 			break;
+ 		case Opt_compression_hint_incompressible:
+ 			opt->alloc_hint_flags |=
+ 			    CEPH_OSD_ALLOC_HINT_FLAG_INCOMPRESSIBLE;
+ 			opt->alloc_hint_flags &=
+ 			    ~CEPH_OSD_ALLOC_HINT_FLAG_COMPRESSIBLE;
+ 			break;
+ 		default:
+ 			BUG();
+ 		}
+ 		break;
+ 	case Opt_read_only:
+ 		opt->read_only = true;
+ 		break;
+ 	case Opt_read_write:
+ 		opt->read_only = false;
+ 		break;
+ 	case Opt_lock_on_read:
+ 		opt->lock_on_read = true;
+ 		break;
+ 	case Opt_exclusive:
+ 		opt->exclusive = true;
+ 		break;
+ 	case Opt_notrim:
+ 		opt->trim = false;
+ 		break;
+ 	default:
+ 		BUG();
+ 	}
+ 
+ 	return 0;
+ 
+ out_of_range:
+ 	return inval_plog(&log, "%s out of range", param->key);
+ }
+ 
+ /*
+  * This duplicates most of generic_parse_monolithic(), untying it from
+  * fs_context and skipping standard superblock and security options.
+  */
+ static int rbd_parse_options(char *options, struct rbd_parse_opts_ctx *pctx)
+ {
+ 	char *key;
+ 	int ret = 0;
+ 
+ 	dout("%s '%s'\n", __func__, options);
+ 	while ((key = strsep(&options, ",")) != NULL) {
+ 		if (*key) {
+ 			struct fs_parameter param = {
+ 				.key	= key,
+ 				.type	= fs_value_is_flag,
+ 			};
+ 			char *value = strchr(key, '=');
+ 			size_t v_len = 0;
+ 
+ 			if (value) {
+ 				if (value == key)
+ 					continue;
+ 				*value++ = 0;
+ 				v_len = strlen(value);
+ 				param.string = kmemdup_nul(value, v_len,
+ 							   GFP_KERNEL);
+ 				if (!param.string)
+ 					return -ENOMEM;
+ 				param.type = fs_value_is_string;
+ 			}
+ 			param.size = v_len;
+ 
+ 			ret = rbd_parse_param(&param, pctx);
+ 			kfree(param.string);
+ 			if (ret)
+ 				break;
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> dc1dad8e1a61 (rbd: compression_hint option)
  /*
   * Parse the options provided for an "rbd add" (i.e., rbd image
   * mapping) request.  These arrive via a write to /sys/bus/rbd/add,
* Unmerged path drivers/block/rbd.c
