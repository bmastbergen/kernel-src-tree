vmalloc: fix remap_vmalloc_range() bounds checks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jann Horn <jannh@google.com>
commit bdebd6a2831b6fab69eb85cee74a8ba77f1a1cc2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/bdebd6a2.failed

remap_vmalloc_range() has had various issues with the bounds checks it
promises to perform ("This function checks that addr is a valid
vmalloc'ed area, and that it is big enough to cover the vma") over time,
e.g.:

 - not detecting pgoff<<PAGE_SHIFT overflow

 - not detecting (pgoff<<PAGE_SHIFT)+usize overflow

 - not checking whether addr and addr+(pgoff<<PAGE_SHIFT) are the same
   vmalloc allocation

 - comparing a potentially wildly out-of-bounds pointer with the end of
   the vmalloc region

In particular, since commit fc9702273e2e ("bpf: Add mmap() support for
BPF_MAP_TYPE_ARRAY"), unprivileged users can cause kernel null pointer
dereferences by calling mmap() on a BPF map with a size that is bigger
than the distance from the start of the BPF map to the end of the
address space.

This could theoretically be used as a kernel ASLR bypass, by using
whether mmap() with a given offset oopses or returns an error code to
perform a binary search over the possible address range.

To allow remap_vmalloc_range_partial() to verify that addr and
addr+(pgoff<<PAGE_SHIFT) are in the same vmalloc region, pass the offset
to remap_vmalloc_range_partial() instead of adding it to the pointer in
remap_vmalloc_range().

In remap_vmalloc_range_partial(), fix the check against
get_vm_area_size() by using size comparisons instead of pointer
comparisons, and add checks for pgoff.

Fixes: 833423143c3a ("[PATCH] mm: introduce remap_vmalloc_range()")
	Signed-off-by: Jann Horn <jannh@google.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Cc: stable@vger.kernel.org
	Cc: Alexei Starovoitov <ast@kernel.org>
	Cc: Daniel Borkmann <daniel@iogearbox.net>
	Cc: Martin KaFai Lau <kafai@fb.com>
	Cc: Song Liu <songliubraving@fb.com>
	Cc: Yonghong Song <yhs@fb.com>
	Cc: Andrii Nakryiko <andriin@fb.com>
	Cc: John Fastabend <john.fastabend@gmail.com>
	Cc: KP Singh <kpsingh@chromium.org>
Link: http://lkml.kernel.org/r/20200415222312.236431-1-jannh@google.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit bdebd6a2831b6fab69eb85cee74a8ba77f1a1cc2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/vmalloc.c
diff --cc mm/vmalloc.c
index 2ee9f1677a60,9a8227afa073..000000000000
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@@ -32,6 -33,8 +32,11 @@@
  #include <linux/compiler.h>
  #include <linux/llist.h>
  #include <linux/bitops.h>
++<<<<<<< HEAD
++=======
+ #include <linux/rbtree_augmented.h>
+ #include <linux/overflow.h>
++>>>>>>> bdebd6a2831b (vmalloc: fix remap_vmalloc_range() bounds checks)
  
  #include <linux/uaccess.h>
  #include <asm/tlbflush.h>
@@@ -2294,25 -3051,32 +2299,40 @@@ finished
  }
  
  /**
++<<<<<<< HEAD
 + *	remap_vmalloc_range_partial  -  map vmalloc pages to userspace
 + *	@vma:		vma to cover
 + *	@uaddr:		target user address to start at
 + *	@kaddr:		virtual address of vmalloc kernel memory
 + *	@size:		size of map area
++=======
+  * remap_vmalloc_range_partial - map vmalloc pages to userspace
+  * @vma:		vma to cover
+  * @uaddr:		target user address to start at
+  * @kaddr:		virtual address of vmalloc kernel memory
+  * @pgoff:		offset from @kaddr to start at
+  * @size:		size of map area
++>>>>>>> bdebd6a2831b (vmalloc: fix remap_vmalloc_range() bounds checks)
   *
 - * Returns:	0 for success, -Exxx on failure
 + *	Returns:	0 for success, -Exxx on failure
   *
 - * This function checks that @kaddr is a valid vmalloc'ed area,
 - * and that it is big enough to cover the range starting at
 - * @uaddr in @vma. Will return failure if that criteria isn't
 - * met.
 + *	This function checks that @kaddr is a valid vmalloc'ed area,
 + *	and that it is big enough to cover the range starting at
 + *	@uaddr in @vma. Will return failure if that criteria isn't
 + *	met.
   *
 - * Similar to remap_pfn_range() (see mm/memory.c)
 + *	Similar to remap_pfn_range() (see mm/memory.c)
   */
  int remap_vmalloc_range_partial(struct vm_area_struct *vma, unsigned long uaddr,
- 				void *kaddr, unsigned long size)
+ 				void *kaddr, unsigned long pgoff,
+ 				unsigned long size)
  {
  	struct vm_struct *area;
+ 	unsigned long off;
+ 	unsigned long end_index;
+ 
+ 	if (check_shl_overflow(pgoff, PAGE_SHIFT, &off))
+ 		return -EINVAL;
  
  	size = PAGE_ALIGN(size);
  
@@@ -2323,11 -3087,13 +2343,17 @@@
  	if (!area)
  		return -EINVAL;
  
 -	if (!(area->flags & (VM_USERMAP | VM_DMA_COHERENT)))
 +	if (!(area->flags & VM_USERMAP))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (kaddr + size > area->addr + area->size)
++=======
+ 	if (check_add_overflow(size, off, &end_index) ||
+ 	    end_index > get_vm_area_size(area))
++>>>>>>> bdebd6a2831b (vmalloc: fix remap_vmalloc_range() bounds checks)
  		return -EINVAL;
+ 	kaddr += off;
  
  	do {
  		struct page *page = vmalloc_to_page(kaddr);
diff --git a/fs/proc/vmcore.c b/fs/proc/vmcore.c
index 08c1c430ea44..a3fbd9454866 100644
--- a/fs/proc/vmcore.c
+++ b/fs/proc/vmcore.c
@@ -264,7 +264,8 @@ static int vmcoredd_mmap_dumps(struct vm_area_struct *vma, unsigned long dst,
 		if (start < offset + dump->size) {
 			tsz = min(offset + (u64)dump->size - start, (u64)size);
 			buf = dump->buf + start - offset;
-			if (remap_vmalloc_range_partial(vma, dst, buf, tsz)) {
+			if (remap_vmalloc_range_partial(vma, dst, buf, 0,
+							tsz)) {
 				ret = -EFAULT;
 				goto out_unlock;
 			}
@@ -621,7 +622,7 @@ static int mmap_vmcore(struct file *file, struct vm_area_struct *vma)
 		tsz = min(elfcorebuf_sz + elfnotes_sz - (size_t)start, size);
 		kaddr = elfnotes_buf + start - elfcorebuf_sz - vmcoredd_orig_sz;
 		if (remap_vmalloc_range_partial(vma, vma->vm_start + len,
-						kaddr, tsz))
+						kaddr, 0, tsz))
 			goto fail;
 
 		size -= tsz;
diff --git a/include/linux/vmalloc.h b/include/linux/vmalloc.h
index c6eebb839552..1b452fad6a4f 100644
--- a/include/linux/vmalloc.h
+++ b/include/linux/vmalloc.h
@@ -108,7 +108,7 @@ extern void vunmap(const void *addr);
 
 extern int remap_vmalloc_range_partial(struct vm_area_struct *vma,
 				       unsigned long uaddr, void *kaddr,
-				       unsigned long size);
+				       unsigned long pgoff, unsigned long size);
 
 extern int remap_vmalloc_range(struct vm_area_struct *vma, void *addr,
 							unsigned long pgoff);
* Unmerged path mm/vmalloc.c
diff --git a/samples/vfio-mdev/mdpy.c b/samples/vfio-mdev/mdpy.c
index 96e7969c473a..d774717cd906 100644
--- a/samples/vfio-mdev/mdpy.c
+++ b/samples/vfio-mdev/mdpy.c
@@ -418,7 +418,7 @@ static int mdpy_mmap(struct mdev_device *mdev, struct vm_area_struct *vma)
 		return -EINVAL;
 
 	return remap_vmalloc_range_partial(vma, vma->vm_start,
-					   mdev_state->memblk,
+					   mdev_state->memblk, 0,
 					   vma->vm_end - vma->vm_start);
 }
 
