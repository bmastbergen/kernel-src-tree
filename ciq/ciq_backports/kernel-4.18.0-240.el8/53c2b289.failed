netfilter: flowtable: add counter support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 53c2b2899af7e6a29c0cf8bfa8a554721398a4b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/53c2b289.failed

Add a new flag to turn on flowtable counters which are stored in the
conntrack entry.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 53c2b2899af7e6a29c0cf8bfa8a554721398a4b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_flow_table.h
#	include/uapi/linux/netfilter/nf_tables.h
diff --cc include/net/netfilter/nf_flow_table.h
index ebceddb778ea,4a2ec6fd9ad2..000000000000
--- a/include/net/netfilter/nf_flow_table.h
+++ b/include/net/netfilter/nf_flow_table.h
@@@ -20,6 -61,11 +20,14 @@@ struct nf_flowtable_type 
  	struct module			*owner;
  };
  
++<<<<<<< HEAD
++=======
+ enum nf_flowtable_flags {
+ 	NF_FLOWTABLE_HW_OFFLOAD		= 0x1,	/* NFT_FLOWTABLE_HW_OFFLOAD */
+ 	NF_FLOWTABLE_COUNTER		= 0x2,	/* NFT_FLOWTABLE_COUNTER */
+ };
+ 
++>>>>>>> 53c2b2899af7 (netfilter: flowtable: add counter support)
  struct nf_flowtable {
  	struct list_head		list;
  	struct rhashtable		rhashtable;
diff --cc include/uapi/linux/netfilter/nf_tables.h
index 8a0bf59999aa,30f2a87270dc..000000000000
--- a/include/uapi/linux/netfilter/nf_tables.h
+++ b/include/uapi/linux/netfilter/nf_tables.h
@@@ -1484,6 -1554,19 +1484,22 @@@ enum nft_object_attributes 
  #define NFTA_OBJ_MAX		(__NFTA_OBJ_MAX - 1)
  
  /**
++<<<<<<< HEAD
++=======
+  * enum nft_flowtable_flags - nf_tables flowtable flags
+  *
+  * @NFT_FLOWTABLE_HW_OFFLOAD: flowtable hardware offload is enabled
+  * @NFT_FLOWTABLE_COUNTER: enable flow counters
+  */
+ enum nft_flowtable_flags {
+ 	NFT_FLOWTABLE_HW_OFFLOAD	= 0x1,
+ 	NFT_FLOWTABLE_COUNTER		= 0x2,
+ 	NFT_FLOWTABLE_MASK		= (NFT_FLOWTABLE_HW_OFFLOAD |
+ 					   NFT_FLOWTABLE_COUNTER)
+ };
+ 
+ /**
++>>>>>>> 53c2b2899af7 (netfilter: flowtable: add counter support)
   * enum nft_flowtable_attributes - nf_tables flow table netlink attributes
   *
   * @NFTA_FLOWTABLE_TABLE: name of the table containing the expression (NLA_STRING)
* Unmerged path include/net/netfilter/nf_flow_table.h
* Unmerged path include/uapi/linux/netfilter/nf_tables.h
diff --git a/net/netfilter/nf_flow_table_ip.c b/net/netfilter/nf_flow_table_ip.c
index c6d37764c587..3dca81088abf 100644
--- a/net/netfilter/nf_flow_table_ip.c
+++ b/net/netfilter/nf_flow_table_ip.c
@@ -11,6 +11,7 @@
 #include <net/ip6_route.h>
 #include <net/neighbour.h>
 #include <net/netfilter/nf_flow_table.h>
+#include <net/netfilter/nf_conntrack_acct.h>
 /* For layer 4 checksum field offset. */
 #include <linux/tcp.h>
 #include <linux/udp.h>
@@ -285,6 +286,9 @@ nf_flow_offload_ip_hook(void *priv, struct sk_buff *skb,
 	ip_decrease_ttl(iph);
 	skb->tstamp = 0;
 
+	if (flow_table->flags & NF_FLOWTABLE_COUNTER)
+		nf_ct_acct_update(flow->ct, tuplehash->tuple.dir, skb->len);
+
 	if (unlikely(dst_xfrm(&rt->dst))) {
 		memset(skb->cb, 0, sizeof(struct inet_skb_parm));
 		IPCB(skb)->iif = skb->dev->ifindex;
@@ -515,6 +519,9 @@ nf_flow_offload_ipv6_hook(void *priv, struct sk_buff *skb,
 	ip6h->hop_limit--;
 	skb->tstamp = 0;
 
+	if (flow_table->flags & NF_FLOWTABLE_COUNTER)
+		nf_ct_acct_update(flow->ct, tuplehash->tuple.dir, skb->len);
+
 	if (unlikely(dst_xfrm(&rt->dst))) {
 		memset(skb->cb, 0, sizeof(struct inet6_skb_parm));
 		IP6CB(skb)->iif = skb->dev->ifindex;
