netfilter: flowtable: reload ip{v6}h in nf_flow_nat_ip{v6}

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Haishuang Yan <yanhaishuang@cmss.chinamobile.com>
commit 61abaf02d2ec3d4575c66fa1b4a863877736b932
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/61abaf02.failed

Since nf_flow_snat_port and nf_flow_snat_ip{v6} call pskb_may_pull()
which may change skb->data, so we need to reload ip{v6}h at the right
place.

Fixes: a908fdec3dda ("netfilter: nf_flow_table: move ipv6 offload hook code to nf_flow_table")
Fixes: 7d2086871762 ("netfilter: nf_flow_table: move ipv4 offload hook code to nf_flow_table")
	Signed-off-by: Haishuang Yan <yanhaishuang@cmss.chinamobile.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 61abaf02d2ec3d4575c66fa1b4a863877736b932)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_flow_table_ip.c
diff --cc net/netfilter/nf_flow_table_ip.c
index f8ba07c473d4,22caab7bb755..000000000000
--- a/net/netfilter/nf_flow_table_ip.c
+++ b/net/netfilter/nf_flow_table_ip.c
@@@ -143,13 -144,15 +143,19 @@@ static int nf_flow_nat_ip(const struct 
  {
  	struct iphdr *iph = ip_hdr(skb);
  
 -	if (test_bit(NF_FLOW_SNAT, &flow->flags) &&
 +	if (flow->flags & FLOW_OFFLOAD_SNAT &&
  	    (nf_flow_snat_port(flow, skb, thoff, iph->protocol, dir) < 0 ||
- 	     nf_flow_snat_ip(flow, skb, iph, thoff, dir) < 0))
+ 	     nf_flow_snat_ip(flow, skb, ip_hdr(skb), thoff, dir) < 0))
  		return -1;
++<<<<<<< HEAD
 +	if (flow->flags & FLOW_OFFLOAD_DNAT &&
++=======
+ 
+ 	iph = ip_hdr(skb);
+ 	if (test_bit(NF_FLOW_DNAT, &flow->flags) &&
++>>>>>>> 61abaf02d2ec (netfilter: flowtable: reload ip{v6}h in nf_flow_nat_ip{v6})
  	    (nf_flow_dnat_port(flow, skb, thoff, iph->protocol, dir) < 0 ||
- 	     nf_flow_dnat_ip(flow, skb, iph, thoff, dir) < 0))
+ 	     nf_flow_dnat_ip(flow, skb, ip_hdr(skb), thoff, dir) < 0))
  		return -1;
  
  	return 0;
@@@ -413,13 -426,15 +419,19 @@@ static int nf_flow_nat_ipv6(const struc
  	struct ipv6hdr *ip6h = ipv6_hdr(skb);
  	unsigned int thoff = sizeof(*ip6h);
  
 -	if (test_bit(NF_FLOW_SNAT, &flow->flags) &&
 +	if (flow->flags & FLOW_OFFLOAD_SNAT &&
  	    (nf_flow_snat_port(flow, skb, thoff, ip6h->nexthdr, dir) < 0 ||
- 	     nf_flow_snat_ipv6(flow, skb, ip6h, thoff, dir) < 0))
+ 	     nf_flow_snat_ipv6(flow, skb, ipv6_hdr(skb), thoff, dir) < 0))
  		return -1;
++<<<<<<< HEAD
 +	if (flow->flags & FLOW_OFFLOAD_DNAT &&
++=======
+ 
+ 	ip6h = ipv6_hdr(skb);
+ 	if (test_bit(NF_FLOW_DNAT, &flow->flags) &&
++>>>>>>> 61abaf02d2ec (netfilter: flowtable: reload ip{v6}h in nf_flow_nat_ip{v6})
  	    (nf_flow_dnat_port(flow, skb, thoff, ip6h->nexthdr, dir) < 0 ||
- 	     nf_flow_dnat_ipv6(flow, skb, ip6h, thoff, dir) < 0))
+ 	     nf_flow_dnat_ipv6(flow, skb, ipv6_hdr(skb), thoff, dir) < 0))
  		return -1;
  
  	return 0;
* Unmerged path net/netfilter/nf_flow_table_ip.c
