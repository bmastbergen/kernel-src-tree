drm/amd/display: Force watermark value propagation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Joshua Aberback <joshua.aberback@amd.com>
commit 868149c9a072cbdc22a73ce25a487f9fbfa171ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/868149c9.failed

[Why]
The HUBBUB watermark registers are in an area that cannot be power
gated, but the HUBP copies of the watermark values are in areas that can
be power gated. When we power on a pipe, it will not automatically take
the HUBBUB values, we need to force propagation by writing to a
watermark register.

[How]
 - new HUBBUB function to re-write current value in a WM register
 - touch WM register after enabling the plane in program_pipe

	Signed-off-by: Joshua Aberback <joshua.aberback@amd.com>
	Reviewed-by: Jun Lei <Jun.Lei@amd.com>
	Acked-by: Rodrigo Siqueira <Rodrigo.Siqueira@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 868149c9a072cbdc22a73ce25a487f9fbfa171ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hwseq.c
#	drivers/gpu/drm/amd/display/dc/inc/hw/dchubbub.h
diff --cc drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hwseq.c
index fbbf9758dc66,efc7fb4cf44d..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hwseq.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hwseq.c
@@@ -1312,79 -1151,474 +1312,150 @@@ void dcn20_pipe_control_lock
  	}
  }
  
 -static void dcn20_detect_pipe_changes(struct pipe_ctx *old_pipe, struct pipe_ctx *new_pipe)
 -{
 -	new_pipe->update_flags.raw = 0;
 -
 -	/* Exit on unchanged, unused pipe */
 -	if (!old_pipe->plane_state && !new_pipe->plane_state)
 -		return;
 -	/* Detect pipe enable/disable */
 -	if (!old_pipe->plane_state && new_pipe->plane_state) {
 -		new_pipe->update_flags.bits.enable = 1;
 -		new_pipe->update_flags.bits.mpcc = 1;
 -		new_pipe->update_flags.bits.dppclk = 1;
 -		new_pipe->update_flags.bits.hubp_interdependent = 1;
 -		new_pipe->update_flags.bits.hubp_rq_dlg_ttu = 1;
 -		new_pipe->update_flags.bits.gamut_remap = 1;
 -		new_pipe->update_flags.bits.scaler = 1;
 -		new_pipe->update_flags.bits.viewport = 1;
 -		if (!new_pipe->top_pipe && !new_pipe->prev_odm_pipe) {
 -			new_pipe->update_flags.bits.odm = 1;
 -			new_pipe->update_flags.bits.global_sync = 1;
 -		}
 -		return;
 -	}
 -	if (old_pipe->plane_state && !new_pipe->plane_state) {
 -		new_pipe->update_flags.bits.disable = 1;
 -		return;
 -	}
 -
 -	/* Detect top pipe only changes */
 -	if (!new_pipe->top_pipe && !new_pipe->prev_odm_pipe) {
 -		/* Detect odm changes */
 -		if ((old_pipe->next_odm_pipe && new_pipe->next_odm_pipe
 -			&& old_pipe->next_odm_pipe->pipe_idx != new_pipe->next_odm_pipe->pipe_idx)
 -				|| (!old_pipe->next_odm_pipe && new_pipe->next_odm_pipe)
 -				|| (old_pipe->next_odm_pipe && !new_pipe->next_odm_pipe)
 -				|| old_pipe->stream_res.opp != new_pipe->stream_res.opp)
 -			new_pipe->update_flags.bits.odm = 1;
 -
 -		/* Detect global sync changes */
 -		if (old_pipe->pipe_dlg_param.vready_offset != new_pipe->pipe_dlg_param.vready_offset
 -				|| old_pipe->pipe_dlg_param.vstartup_start != new_pipe->pipe_dlg_param.vstartup_start
 -				|| old_pipe->pipe_dlg_param.vupdate_offset != new_pipe->pipe_dlg_param.vupdate_offset
 -				|| old_pipe->pipe_dlg_param.vupdate_width != new_pipe->pipe_dlg_param.vupdate_width)
 -			new_pipe->update_flags.bits.global_sync = 1;
 -	}
 -
 -	/*
 -	 * Detect opp / tg change, only set on change, not on enable
 -	 * Assume mpcc inst = pipe index, if not this code needs to be updated
 -	 * since mpcc is what is affected by these. In fact all of our sequence
 -	 * makes this assumption at the moment with how hubp reset is matched to
 -	 * same index mpcc reset.
 -	 */
 -	if (old_pipe->stream_res.opp != new_pipe->stream_res.opp)
 -		new_pipe->update_flags.bits.opp_changed = 1;
 -	if (old_pipe->stream_res.tg != new_pipe->stream_res.tg)
 -		new_pipe->update_flags.bits.tg_changed = 1;
 -
 -	/* Detect mpcc blending changes, only dpp inst and bot matter here */
 -	if (old_pipe->plane_res.dpp != new_pipe->plane_res.dpp
 -			|| old_pipe->stream_res.opp != new_pipe->stream_res.opp
 -			|| (!old_pipe->bottom_pipe && new_pipe->bottom_pipe)
 -			|| (old_pipe->bottom_pipe && !new_pipe->bottom_pipe)
 -			|| (old_pipe->bottom_pipe && new_pipe->bottom_pipe
 -				&& old_pipe->bottom_pipe->plane_res.mpcc_inst
 -					!= new_pipe->bottom_pipe->plane_res.mpcc_inst))
 -		new_pipe->update_flags.bits.mpcc = 1;
 -
 -	/* Detect dppclk change */
 -	if (old_pipe->plane_res.bw.dppclk_khz != new_pipe->plane_res.bw.dppclk_khz)
 -		new_pipe->update_flags.bits.dppclk = 1;
 -
 -	/* Check for scl update */
 -	if (memcmp(&old_pipe->plane_res.scl_data, &new_pipe->plane_res.scl_data, sizeof(struct scaler_data)))
 -			new_pipe->update_flags.bits.scaler = 1;
 -	/* Check for vp update */
 -	if (memcmp(&old_pipe->plane_res.scl_data.viewport, &new_pipe->plane_res.scl_data.viewport, sizeof(struct rect))
 -			|| memcmp(&old_pipe->plane_res.scl_data.viewport_c,
 -				&new_pipe->plane_res.scl_data.viewport_c, sizeof(struct rect)))
 -		new_pipe->update_flags.bits.viewport = 1;
 -
 -	/* Detect dlg/ttu/rq updates */
 -	{
 -		struct _vcs_dpi_display_dlg_regs_st old_dlg_attr = old_pipe->dlg_regs;
 -		struct _vcs_dpi_display_ttu_regs_st old_ttu_attr = old_pipe->ttu_regs;
 -		struct _vcs_dpi_display_dlg_regs_st *new_dlg_attr = &new_pipe->dlg_regs;
 -		struct _vcs_dpi_display_ttu_regs_st *new_ttu_attr = &new_pipe->ttu_regs;
 -
 -		/* Detect pipe interdependent updates */
 -		if (old_dlg_attr.dst_y_prefetch != new_dlg_attr->dst_y_prefetch ||
 -				old_dlg_attr.vratio_prefetch != new_dlg_attr->vratio_prefetch ||
 -				old_dlg_attr.vratio_prefetch_c != new_dlg_attr->vratio_prefetch_c ||
 -				old_dlg_attr.dst_y_per_vm_vblank != new_dlg_attr->dst_y_per_vm_vblank ||
 -				old_dlg_attr.dst_y_per_row_vblank != new_dlg_attr->dst_y_per_row_vblank ||
 -				old_dlg_attr.dst_y_per_vm_flip != new_dlg_attr->dst_y_per_vm_flip ||
 -				old_dlg_attr.dst_y_per_row_flip != new_dlg_attr->dst_y_per_row_flip ||
 -				old_dlg_attr.refcyc_per_meta_chunk_vblank_l != new_dlg_attr->refcyc_per_meta_chunk_vblank_l ||
 -				old_dlg_attr.refcyc_per_meta_chunk_vblank_c != new_dlg_attr->refcyc_per_meta_chunk_vblank_c ||
 -				old_dlg_attr.refcyc_per_meta_chunk_flip_l != new_dlg_attr->refcyc_per_meta_chunk_flip_l ||
 -				old_dlg_attr.refcyc_per_line_delivery_pre_l != new_dlg_attr->refcyc_per_line_delivery_pre_l ||
 -				old_dlg_attr.refcyc_per_line_delivery_pre_c != new_dlg_attr->refcyc_per_line_delivery_pre_c ||
 -				old_ttu_attr.refcyc_per_req_delivery_pre_l != new_ttu_attr->refcyc_per_req_delivery_pre_l ||
 -				old_ttu_attr.refcyc_per_req_delivery_pre_c != new_ttu_attr->refcyc_per_req_delivery_pre_c ||
 -				old_ttu_attr.refcyc_per_req_delivery_pre_cur0 != new_ttu_attr->refcyc_per_req_delivery_pre_cur0 ||
 -				old_ttu_attr.refcyc_per_req_delivery_pre_cur1 != new_ttu_attr->refcyc_per_req_delivery_pre_cur1 ||
 -				old_ttu_attr.min_ttu_vblank != new_ttu_attr->min_ttu_vblank ||
 -				old_ttu_attr.qos_level_flip != new_ttu_attr->qos_level_flip) {
 -			old_dlg_attr.dst_y_prefetch = new_dlg_attr->dst_y_prefetch;
 -			old_dlg_attr.vratio_prefetch = new_dlg_attr->vratio_prefetch;
 -			old_dlg_attr.vratio_prefetch_c = new_dlg_attr->vratio_prefetch_c;
 -			old_dlg_attr.dst_y_per_vm_vblank = new_dlg_attr->dst_y_per_vm_vblank;
 -			old_dlg_attr.dst_y_per_row_vblank = new_dlg_attr->dst_y_per_row_vblank;
 -			old_dlg_attr.dst_y_per_vm_flip = new_dlg_attr->dst_y_per_vm_flip;
 -			old_dlg_attr.dst_y_per_row_flip = new_dlg_attr->dst_y_per_row_flip;
 -			old_dlg_attr.refcyc_per_meta_chunk_vblank_l = new_dlg_attr->refcyc_per_meta_chunk_vblank_l;
 -			old_dlg_attr.refcyc_per_meta_chunk_vblank_c = new_dlg_attr->refcyc_per_meta_chunk_vblank_c;
 -			old_dlg_attr.refcyc_per_meta_chunk_flip_l = new_dlg_attr->refcyc_per_meta_chunk_flip_l;
 -			old_dlg_attr.refcyc_per_line_delivery_pre_l = new_dlg_attr->refcyc_per_line_delivery_pre_l;
 -			old_dlg_attr.refcyc_per_line_delivery_pre_c = new_dlg_attr->refcyc_per_line_delivery_pre_c;
 -			old_ttu_attr.refcyc_per_req_delivery_pre_l = new_ttu_attr->refcyc_per_req_delivery_pre_l;
 -			old_ttu_attr.refcyc_per_req_delivery_pre_c = new_ttu_attr->refcyc_per_req_delivery_pre_c;
 -			old_ttu_attr.refcyc_per_req_delivery_pre_cur0 = new_ttu_attr->refcyc_per_req_delivery_pre_cur0;
 -			old_ttu_attr.refcyc_per_req_delivery_pre_cur1 = new_ttu_attr->refcyc_per_req_delivery_pre_cur1;
 -			old_ttu_attr.min_ttu_vblank = new_ttu_attr->min_ttu_vblank;
 -			old_ttu_attr.qos_level_flip = new_ttu_attr->qos_level_flip;
 -			new_pipe->update_flags.bits.hubp_interdependent = 1;
 -		}
 -		/* Detect any other updates to ttu/rq/dlg */
 -		if (memcmp(&old_dlg_attr, &new_pipe->dlg_regs, sizeof(old_dlg_attr)) ||
 -				memcmp(&old_ttu_attr, &new_pipe->ttu_regs, sizeof(old_ttu_attr)) ||
 -				memcmp(&old_pipe->rq_regs, &new_pipe->rq_regs, sizeof(old_pipe->rq_regs)))
 -			new_pipe->update_flags.bits.hubp_rq_dlg_ttu = 1;
 -	}
 -}
 -
 -static void dcn20_update_dchubp_dpp(
 -	struct dc *dc,
 -	struct pipe_ctx *pipe_ctx,
 -	struct dc_state *context)
 -{
 -	struct dce_hwseq *hws = dc->hwseq;
 -	struct hubp *hubp = pipe_ctx->plane_res.hubp;
 -	struct dpp *dpp = pipe_ctx->plane_res.dpp;
 -	struct dc_plane_state *plane_state = pipe_ctx->plane_state;
 -	bool viewport_changed = false;
 -
 -	if (pipe_ctx->update_flags.bits.dppclk)
 -		dpp->funcs->dpp_dppclk_control(dpp, false, true);
 -
 -	/* TODO: Need input parameter to tell current DCHUB pipe tie to which OTG
 -	 * VTG is within DCHUBBUB which is commond block share by each pipe HUBP.
 -	 * VTG is 1:1 mapping with OTG. Each pipe HUBP will select which VTG
 -	 */
 -	if (pipe_ctx->update_flags.bits.hubp_rq_dlg_ttu) {
 -		hubp->funcs->hubp_vtg_sel(hubp, pipe_ctx->stream_res.tg->inst);
 -
 -		hubp->funcs->hubp_setup(
 -			hubp,
 -			&pipe_ctx->dlg_regs,
 -			&pipe_ctx->ttu_regs,
 -			&pipe_ctx->rq_regs,
 -			&pipe_ctx->pipe_dlg_param);
 -	}
 -	if (pipe_ctx->update_flags.bits.hubp_interdependent)
 -		hubp->funcs->hubp_setup_interdependent(
 -			hubp,
 -			&pipe_ctx->dlg_regs,
 -			&pipe_ctx->ttu_regs);
 -
 -	if (pipe_ctx->update_flags.bits.enable ||
 -			plane_state->update_flags.bits.bpp_change ||
 -			plane_state->update_flags.bits.input_csc_change ||
 -			plane_state->update_flags.bits.color_space_change ||
 -			plane_state->update_flags.bits.coeff_reduction_change) {
 -		struct dc_bias_and_scale bns_params = {0};
 -
 -		// program the input csc
 -		dpp->funcs->dpp_setup(dpp,
 -				plane_state->format,
 -				EXPANSION_MODE_ZERO,
 -				plane_state->input_csc_color_matrix,
 -				plane_state->color_space,
 -				NULL);
 -
 -		if (dpp->funcs->dpp_program_bias_and_scale) {
 -			//TODO :for CNVC set scale and bias registers if necessary
 -			build_prescale_params(&bns_params, plane_state);
 -			dpp->funcs->dpp_program_bias_and_scale(dpp, &bns_params);
 -		}
 -	}
 -
 -	if (pipe_ctx->update_flags.bits.mpcc
 -			|| plane_state->update_flags.bits.global_alpha_change
 -			|| plane_state->update_flags.bits.per_pixel_alpha_change) {
 -		// MPCC inst is equal to pipe index in practice
 -		int mpcc_inst = hubp->inst;
 -		int opp_inst;
 -		int opp_count = dc->res_pool->pipe_count;
 -
 -		for (opp_inst = 0; opp_inst < opp_count; opp_inst++) {
 -			if (dc->res_pool->opps[opp_inst]->mpcc_disconnect_pending[mpcc_inst]) {
 -				dc->res_pool->mpc->funcs->wait_for_idle(dc->res_pool->mpc, mpcc_inst);
 -				dc->res_pool->opps[opp_inst]->mpcc_disconnect_pending[mpcc_inst] = false;
 -				break;
 -			}
 -		}
 -		hws->funcs.update_mpcc(dc, pipe_ctx);
 -	}
 -
 -	if (pipe_ctx->update_flags.bits.scaler ||
 -			plane_state->update_flags.bits.scaling_change ||
 -			plane_state->update_flags.bits.position_change ||
 -			plane_state->update_flags.bits.per_pixel_alpha_change ||
 -			pipe_ctx->stream->update_flags.bits.scaling) {
 -		pipe_ctx->plane_res.scl_data.lb_params.alpha_en = pipe_ctx->plane_state->per_pixel_alpha;
 -		ASSERT(pipe_ctx->plane_res.scl_data.lb_params.depth == LB_PIXEL_DEPTH_30BPP);
 -		/* scaler configuration */
 -		pipe_ctx->plane_res.dpp->funcs->dpp_set_scaler(
 -				pipe_ctx->plane_res.dpp, &pipe_ctx->plane_res.scl_data);
 -	}
 -
 -	if (pipe_ctx->update_flags.bits.viewport ||
 -			(context == dc->current_state && plane_state->update_flags.bits.position_change) ||
 -			(context == dc->current_state && plane_state->update_flags.bits.scaling_change) ||
 -			(context == dc->current_state && pipe_ctx->stream->update_flags.bits.scaling)) {
 -
 -		hubp->funcs->mem_program_viewport(
 -			hubp,
 -			&pipe_ctx->plane_res.scl_data.viewport,
 -			&pipe_ctx->plane_res.scl_data.viewport_c);
 -		viewport_changed = true;
 -	}
 -
 -	/* Any updates are handled in dc interface, just need to apply existing for plane enable */
 -	if ((pipe_ctx->update_flags.bits.enable || pipe_ctx->update_flags.bits.opp_changed ||
 -			pipe_ctx->update_flags.bits.scaler || pipe_ctx->update_flags.bits.viewport)
 -			&& pipe_ctx->stream->cursor_attributes.address.quad_part != 0) {
 -		dc->hwss.set_cursor_position(pipe_ctx);
 -		dc->hwss.set_cursor_attribute(pipe_ctx);
 -
 -		if (dc->hwss.set_cursor_sdr_white_level)
 -			dc->hwss.set_cursor_sdr_white_level(pipe_ctx);
 -	}
 -
 -	/* Any updates are handled in dc interface, just need
 -	 * to apply existing for plane enable / opp change */
 -	if (pipe_ctx->update_flags.bits.enable || pipe_ctx->update_flags.bits.opp_changed
 -			|| pipe_ctx->stream->update_flags.bits.gamut_remap
 -			|| pipe_ctx->stream->update_flags.bits.out_csc) {
 -			/* dpp/cm gamut remap*/
 -			dc->hwss.program_gamut_remap(pipe_ctx);
 -
 -		/*call the dcn2 method which uses mpc csc*/
 -		dc->hwss.program_output_csc(dc,
 -				pipe_ctx,
 -				pipe_ctx->stream->output_color_space,
 -				pipe_ctx->stream->csc_color_matrix.matrix,
 -				hubp->opp_id);
 -	}
 -
 -	if (pipe_ctx->update_flags.bits.enable ||
 -			pipe_ctx->update_flags.bits.opp_changed ||
 -			plane_state->update_flags.bits.pixel_format_change ||
 -			plane_state->update_flags.bits.horizontal_mirror_change ||
 -			plane_state->update_flags.bits.rotation_change ||
 -			plane_state->update_flags.bits.swizzle_change ||
 -			plane_state->update_flags.bits.dcc_change ||
 -			plane_state->update_flags.bits.bpp_change ||
 -			plane_state->update_flags.bits.scaling_change ||
 -			plane_state->update_flags.bits.plane_size_change) {
 -		struct plane_size size = plane_state->plane_size;
 -
 -		size.surface_size = pipe_ctx->plane_res.scl_data.viewport;
 -		hubp->funcs->hubp_program_surface_config(
 -			hubp,
 -			plane_state->format,
 -			&plane_state->tiling_info,
 -			&size,
 -			plane_state->rotation,
 -			&plane_state->dcc,
 -			plane_state->horizontal_mirror,
 -			0);
 -		hubp->power_gated = false;
 -	}
 -
 -	if (hubp->funcs->apply_PLAT_54186_wa && viewport_changed)
 -		hubp->funcs->apply_PLAT_54186_wa(hubp, &plane_state->address);
 -
 -	if (pipe_ctx->update_flags.bits.enable || plane_state->update_flags.bits.addr_update)
 -		hws->funcs.update_plane_addr(dc, pipe_ctx);
 -
 -
 -
 -	if (pipe_ctx->update_flags.bits.enable)
 -		hubp->funcs->set_blank(hubp, false);
 -}
 -
 -
 -static void dcn20_program_pipe(
 +static void dcn20_apply_ctx_for_surface(
  		struct dc *dc,
 -		struct pipe_ctx *pipe_ctx,
 +		const struct dc_stream_state *stream,
 +		int num_planes,
  		struct dc_state *context)
  {
 -	struct dce_hwseq *hws = dc->hwseq;
 -	/* Only need to unblank on top pipe */
 -	if ((pipe_ctx->update_flags.bits.enable || pipe_ctx->stream->update_flags.bits.abm_level)
 -			&& !pipe_ctx->top_pipe && !pipe_ctx->prev_odm_pipe)
 -		hws->funcs.blank_pixel_data(dc, pipe_ctx, !pipe_ctx->plane_state->visible);
  
++<<<<<<< HEAD
++=======
+ 	if (pipe_ctx->update_flags.bits.global_sync) {
+ 		pipe_ctx->stream_res.tg->funcs->program_global_sync(
+ 				pipe_ctx->stream_res.tg,
+ 				pipe_ctx->pipe_dlg_param.vready_offset,
+ 				pipe_ctx->pipe_dlg_param.vstartup_start,
+ 				pipe_ctx->pipe_dlg_param.vupdate_offset,
+ 				pipe_ctx->pipe_dlg_param.vupdate_width);
+ 
+ 		pipe_ctx->stream_res.tg->funcs->set_vtg_params(
+ 				pipe_ctx->stream_res.tg, &pipe_ctx->stream->timing);
+ 
+ 		if (hws->funcs.setup_vupdate_interrupt)
+ 			hws->funcs.setup_vupdate_interrupt(dc, pipe_ctx);
+ 	}
+ 
+ 	if (pipe_ctx->update_flags.bits.odm)
+ 		hws->funcs.update_odm(dc, context, pipe_ctx);
+ 
+ 	if (pipe_ctx->update_flags.bits.enable) {
+ 		dcn20_enable_plane(dc, pipe_ctx, context);
+ 		if (dc->res_pool->hubbub->funcs->force_wm_propagate_to_pipes)
+ 			dc->res_pool->hubbub->funcs->force_wm_propagate_to_pipes(dc->res_pool->hubbub);
+ 	}
+ 
+ 	if (pipe_ctx->update_flags.raw || pipe_ctx->plane_state->update_flags.raw || pipe_ctx->stream->update_flags.raw)
+ 		dcn20_update_dchubp_dpp(dc, pipe_ctx, context);
+ 
+ 	if (pipe_ctx->update_flags.bits.enable
+ 			|| pipe_ctx->plane_state->update_flags.bits.hdr_mult)
+ 		hws->funcs.set_hdr_multiplier(pipe_ctx);
+ 
+ 	if (pipe_ctx->update_flags.bits.enable ||
+ 			pipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||
+ 			pipe_ctx->plane_state->update_flags.bits.gamma_change)
+ 		hws->funcs.set_input_transfer_func(dc, pipe_ctx, pipe_ctx->plane_state);
+ 
+ 	/* dcn10_translate_regamma_to_hw_format takes 750us to finish
+ 	 * only do gamma programming for powering on, internal memcmp to avoid
+ 	 * updating on slave planes
+ 	 */
+ 	if (pipe_ctx->update_flags.bits.enable || pipe_ctx->stream->update_flags.bits.out_tf)
+ 		hws->funcs.set_output_transfer_func(dc, pipe_ctx, pipe_ctx->stream);
+ 
+ 	/* If the pipe has been enabled or has a different opp, we
+ 	 * should reprogram the fmt. This deals with cases where
+ 	 * interation between mpc and odm combine on different streams
+ 	 * causes a different pipe to be chosen to odm combine with.
+ 	 */
+ 	if (pipe_ctx->update_flags.bits.enable
+ 	    || pipe_ctx->update_flags.bits.opp_changed) {
+ 
+ 		pipe_ctx->stream_res.opp->funcs->opp_set_dyn_expansion(
+ 			pipe_ctx->stream_res.opp,
+ 			COLOR_SPACE_YCBCR601,
+ 			pipe_ctx->stream->timing.display_color_depth,
+ 			pipe_ctx->stream->signal);
+ 
+ 		pipe_ctx->stream_res.opp->funcs->opp_program_fmt(
+ 			pipe_ctx->stream_res.opp,
+ 			&pipe_ctx->stream->bit_depth_params,
+ 			&pipe_ctx->stream->clamping);
+ 	}
+ }
+ 
+ void dcn20_program_front_end_for_ctx(
+ 		struct dc *dc,
+ 		struct dc_state *context)
+ {
++>>>>>>> 868149c9a072 (drm/amd/display: Force watermark value propagation)
  	int i;
 -	struct dce_hwseq *hws = dc->hwseq;
 +	struct timing_generator *tg;
 +	bool removed_pipe[6] = { false };
 +	bool interdependent_update = false;
 +	struct pipe_ctx *top_pipe_to_program =
 +			find_top_pipe_for_stream(dc, context, stream);
  	DC_LOGGER_INIT(dc->ctx->logger);
  
 +	if (!top_pipe_to_program)
 +		return;
 +
 +	/* Carry over GSL groups in case the context is changing. */
  	for (i = 0; i < dc->res_pool->pipe_count; i++) {
  		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 +		struct pipe_ctx *old_pipe_ctx =
 +			&dc->current_state->res_ctx.pipe_ctx[i];
  
 -		if (!pipe_ctx->top_pipe && !pipe_ctx->prev_odm_pipe && pipe_ctx->plane_state) {
 -			ASSERT(!pipe_ctx->plane_state->triplebuffer_flips);
 -			if (dc->hwss.program_triplebuffer != NULL &&
 -				!dc->debug.disable_tri_buf) {
 -				/*turn off triple buffer for full update*/
 -				dc->hwss.program_triplebuffer(
 -					dc, pipe_ctx, pipe_ctx->plane_state->triplebuffer_flips);
 -			}
 -		}
 +		if (pipe_ctx->stream == stream &&
 +		    pipe_ctx->stream == old_pipe_ctx->stream)
 +			pipe_ctx->stream_res.gsl_group =
 +				old_pipe_ctx->stream_res.gsl_group;
  	}
  
 -	/* Set pipe update flags and lock pipes */
 -	for (i = 0; i < dc->res_pool->pipe_count; i++)
 -		dcn20_detect_pipe_changes(&dc->current_state->res_ctx.pipe_ctx[i],
 -				&context->res_ctx.pipe_ctx[i]);
 +	tg = top_pipe_to_program->stream_res.tg;
  
 -	/* OTG blank before disabling all front ends */
 -	for (i = 0; i < dc->res_pool->pipe_count; i++)
 -		if (context->res_ctx.pipe_ctx[i].update_flags.bits.disable
 -				&& !context->res_ctx.pipe_ctx[i].top_pipe
 -				&& !context->res_ctx.pipe_ctx[i].prev_odm_pipe
 -				&& context->res_ctx.pipe_ctx[i].stream)
 -			hws->funcs.blank_pixel_data(dc, &context->res_ctx.pipe_ctx[i], true);
 +	interdependent_update = top_pipe_to_program->plane_state &&
 +		top_pipe_to_program->plane_state->update_flags.bits.full_update;
  
 -	/* Disconnect mpcc */
 -	for (i = 0; i < dc->res_pool->pipe_count; i++)
 -		if (context->res_ctx.pipe_ctx[i].update_flags.bits.disable
 -				|| context->res_ctx.pipe_ctx[i].update_flags.bits.opp_changed) {
 -			hws->funcs.plane_atomic_disconnect(dc, &dc->current_state->res_ctx.pipe_ctx[i]);
 -			DC_LOG_DC("Reset mpcc for pipe %d\n", dc->current_state->res_ctx.pipe_ctx[i].pipe_idx);
 -		}
 -
 -	/*
 -	 * Program all updated pipes, order matters for mpcc setup. Start with
 -	 * top pipe and program all pipes that follow in order
 -	 */
 -	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 -		struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];
 +	if (interdependent_update)
 +		lock_all_pipes(dc, context, true);
 +	else
 +		dcn20_pipe_control_lock(dc, top_pipe_to_program, true);
  
 -		if (pipe->plane_state && !pipe->top_pipe) {
 -			while (pipe) {
 -				dcn20_program_pipe(dc, pipe, context);
 -				pipe = pipe->bottom_pipe;
 -			}
 -			/* Program secondary blending tree and writeback pipes */
 -			pipe = &context->res_ctx.pipe_ctx[i];
 -			if (!pipe->prev_odm_pipe && pipe->stream->num_wb_info > 0
 -					&& (pipe->update_flags.raw || pipe->plane_state->update_flags.raw || pipe->stream->update_flags.raw)
 -					&& hws->funcs.program_all_writeback_pipes_in_tree)
 -				hws->funcs.program_all_writeback_pipes_in_tree(dc, pipe->stream, context);
 -		}
 +	if (num_planes == 0) {
 +		/* OTG blank before remove all front end */
 +		dc->hwss.blank_pixel_data(dc, top_pipe_to_program, true);
  	}
 -}
 -
 -void dcn20_post_unlock_program_front_end(
 -		struct dc *dc,
 -		struct dc_state *context)
 -{
 -	int i;
 -	const unsigned int TIMEOUT_FOR_PIPE_ENABLE_MS = 100;
 -	struct dce_hwseq *hwseq = dc->hwseq;
  
 -	DC_LOGGER_INIT(dc->ctx->logger);
 -
 -	for (i = 0; i < dc->res_pool->pipe_count; i++)
 -		if (context->res_ctx.pipe_ctx[i].update_flags.bits.disable)
 -			dc->hwss.disable_plane(dc, &dc->current_state->res_ctx.pipe_ctx[i]);
 -
 -	/*
 -	 * If we are enabling a pipe, we need to wait for pending clear as this is a critical
 -	 * part of the enable operation otherwise, DM may request an immediate flip which
 -	 * will cause HW to perform an "immediate enable" (as opposed to "vsync enable") which
 -	 * is unsupported on DCN.
 -	 */
 +	/* Disconnect unused mpcc */
  	for (i = 0; i < dc->res_pool->pipe_count; i++) {
 -		struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];
 +		struct pipe_ctx *pipe_ctx = &context->res_ctx.pipe_ctx[i];
 +		struct pipe_ctx *old_pipe_ctx =
 +				&dc->current_state->res_ctx.pipe_ctx[i];
 +		/*
 +		 * Powergate reused pipes that are not powergated
 +		 * fairly hacky right now, using opp_id as indicator
 +		 * TODO: After move dc_post to dc_update, this will
 +		 * be removed.
 +		 */
 +		if (pipe_ctx->plane_state && !old_pipe_ctx->plane_state) {
 +			if (old_pipe_ctx->stream_res.tg == tg &&
 +			    old_pipe_ctx->plane_res.hubp &&
 +			    old_pipe_ctx->plane_res.hubp->opp_id != OPP_ID_INVALID)
 +				dcn20_disable_plane(dc, old_pipe_ctx);
 +		}
 +
 +		if ((!pipe_ctx->plane_state ||
 +		     pipe_ctx->stream_res.tg != old_pipe_ctx->stream_res.tg) &&
 +		     old_pipe_ctx->plane_state &&
 +		     old_pipe_ctx->stream_res.tg == tg) {
  
 -		if (pipe->plane_state && !pipe->top_pipe && pipe->update_flags.bits.enable) {
 -			struct hubp *hubp = pipe->plane_res.hubp;
 -			int j = 0;
 +			dc->hwss.plane_atomic_disconnect(dc, old_pipe_ctx);
 +			removed_pipe[i] = true;
  
 -			for (j = 0; j < TIMEOUT_FOR_PIPE_ENABLE_MS*1000
 -					&& hubp->funcs->hubp_is_flip_pending(hubp); j++)
 -				mdelay(1);
 +			DC_LOG_DC("Reset mpcc for pipe %d\n",
 +					old_pipe_ctx->pipe_idx);
  		}
  	}
  
diff --cc drivers/gpu/drm/amd/display/dc/inc/hw/dchubbub.h
index 9502478c4a1b,47a566d82d6e..000000000000
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/dchubbub.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/dchubbub.h
@@@ -141,6 -139,13 +141,16 @@@ struct hubbub_funcs 
  			struct dcn_watermark_set *watermarks,
  			unsigned int refclk_mhz,
  			bool safe_to_lower);
++<<<<<<< HEAD
++=======
+ 
+ 	bool (*is_allow_self_refresh_enabled)(struct hubbub *hubbub);
+ 	void (*allow_self_refresh_control)(struct hubbub *hubbub, bool allow);
+ 
+ 	void (*apply_DEDCN21_147_wa)(struct hubbub *hubbub);
+ 
+ 	void (*force_wm_propagate_to_pipes)(struct hubbub *hubbub);
++>>>>>>> 868149c9a072 (drm/amd/display: Force watermark value propagation)
  };
  
  struct hubbub {
* Unmerged path drivers/gpu/drm/amd/display/dc/dcn20/dcn20_hwseq.c
* Unmerged path drivers/gpu/drm/amd/display/dc/inc/hw/dchubbub.h
