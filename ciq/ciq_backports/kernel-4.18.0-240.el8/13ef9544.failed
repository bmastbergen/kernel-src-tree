iomap: Allow forcing of waiting for running DIO in iomap_dio_rw()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jan Kara <jack@suse.cz>
commit 13ef954445df4fd1d7c003a500ec5ce49573e14b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/13ef9544.failed

Filesystems do not support doing IO as asynchronous in some cases. For
example in case of unaligned writes or in case file size needs to be
extended (e.g. for ext4). Instead of forcing filesystem to wait for AIO
in such cases, add argument to iomap_dio_rw() which makes the function
wait for IO completion. This also results in executing
iomap_dio_complete() inline in iomap_dio_rw() providing its return value
to the caller as for ordinary sync IO.

	Signed-off-by: Jan Kara <jack@suse.cz>
	Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
	Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
(cherry picked from commit 13ef954445df4fd1d7c003a500ec5ce49573e14b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/iomap/direct-io.c
#	fs/xfs/xfs_file.c
#	include/linux/iomap.h
diff --cc fs/xfs/xfs_file.c
index c9c7bcb69ae3,0739ba72a82e..000000000000
--- a/fs/xfs/xfs_file.c
+++ b/fs/xfs/xfs_file.c
@@@ -536,7 -547,8 +536,12 @@@ xfs_file_dio_aio_write
  	}
  
  	trace_xfs_file_direct_write(ip, count, iocb->ki_pos);
++<<<<<<< HEAD
 +	ret = iomap_dio_rw(iocb, from, &xfs_iomap_ops, xfs_dio_write_end_io);
++=======
+ 	ret = iomap_dio_rw(iocb, from, &xfs_iomap_ops, &xfs_dio_write_ops,
+ 			   is_sync_kiocb(iocb));
++>>>>>>> 13ef954445df (iomap: Allow forcing of waiting for running DIO in iomap_dio_rw())
  
  	/*
  	 * If unaligned, this is the only IO in-flight. If it has not yet
diff --cc include/linux/iomap.h
index 960967bb5048,76b14cb729dc..000000000000
--- a/include/linux/iomap.h
+++ b/include/linux/iomap.h
@@@ -179,10 -188,15 +179,15 @@@ sector_t iomap_bmap(struct address_spac
   */
  #define IOMAP_DIO_UNWRITTEN	(1 << 0)	/* covers unwritten extent(s) */
  #define IOMAP_DIO_COW		(1 << 1)	/* covers COW extent(s) */
 -
 -struct iomap_dio_ops {
 -	int (*end_io)(struct kiocb *iocb, ssize_t size, int error,
 -		      unsigned flags);
 -};
 -
 +typedef int (iomap_dio_end_io_t)(struct kiocb *iocb, ssize_t ret,
 +		unsigned flags);
  ssize_t iomap_dio_rw(struct kiocb *iocb, struct iov_iter *iter,
++<<<<<<< HEAD
 +		const struct iomap_ops *ops, iomap_dio_end_io_t end_io);
++=======
+ 		const struct iomap_ops *ops, const struct iomap_dio_ops *dops,
+ 		bool wait_for_completion);
++>>>>>>> 13ef954445df (iomap: Allow forcing of waiting for running DIO in iomap_dio_rw())
  int iomap_dio_iopoll(struct kiocb *kiocb, bool spin);
  
  #ifdef CONFIG_SWAP
* Unmerged path fs/iomap/direct-io.c
diff --git a/fs/gfs2/file.c b/fs/gfs2/file.c
index a25b1766d059..70504fc9bb8d 100644
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@ -706,7 +706,8 @@ static ssize_t gfs2_file_direct_read(struct kiocb *iocb, struct iov_iter *to)
 	if (ret)
 		goto out_uninit;
 
-	ret = iomap_dio_rw(iocb, to, &gfs2_iomap_ops, NULL);
+	ret = iomap_dio_rw(iocb, to, &gfs2_iomap_ops, NULL,
+			   is_sync_kiocb(iocb));
 
 	gfs2_glock_dq(&gh);
 out_uninit:
@@ -741,7 +742,8 @@ static ssize_t gfs2_file_direct_write(struct kiocb *iocb, struct iov_iter *from)
 	if (offset + len > i_size_read(&ip->i_inode))
 		goto out;
 
-	ret = iomap_dio_rw(iocb, from, &gfs2_iomap_ops, NULL);
+	ret = iomap_dio_rw(iocb, from, &gfs2_iomap_ops, NULL,
+			   is_sync_kiocb(iocb));
 
 out:
 	gfs2_glock_dq(&gh);
* Unmerged path fs/iomap/direct-io.c
* Unmerged path fs/xfs/xfs_file.c
* Unmerged path include/linux/iomap.h
