drm/i915: split i915_driver_modeset_probe() to pre/post irq install

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jani Nikula <jani.nikula@intel.com>
commit b664259f3fe2c7a967e9fa4ba6d3af6a2addaa99
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b664259f.failed

Pair the irq install and uninstall in the same layer. There are no
functional changes in the happy day scenario. The cleanup paths are
currently a mess though.

Note that modeset probe pre-irq + post-irq install are matched by
modeset driver remove pre-irq + post-irq uninstall, together, but not
independently. They are not symmetric pairs.

v2: don't add a new probe failure point here

	Cc: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Reviewed-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200219133756.13224-1-jani.nikula@intel.com
(cherry picked from commit b664259f3fe2c7a967e9fa4ba6d3af6a2addaa99)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_drv.c
diff --cc drivers/gpu/drm/i915/i915_drv.c
index 1aa474313525,2cea760f06fe..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@@ -625,112 -212,49 +625,130 @@@ intel_teardown_mchbar(struct drm_i915_p
  		release_resource(&dev_priv->mch_res);
  }
  
++<<<<<<< HEAD
 +/* true = enable decode, false = disable decoder */
 +static unsigned int i915_vga_set_decode(void *cookie, bool state)
++=======
+ /* part #1: call before irq install */
+ static int i915_driver_modeset_probe_noirq(struct drm_i915_private *i915)
++>>>>>>> b664259f3fe2 (drm/i915: split i915_driver_modeset_probe() to pre/post irq install)
 +{
 +	struct drm_i915_private *dev_priv = cookie;
 +
 +	intel_modeset_vga_set_state(dev_priv, state);
 +	if (state)
 +		return VGA_RSRC_LEGACY_IO | VGA_RSRC_LEGACY_MEM |
 +		       VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
 +	else
 +		return VGA_RSRC_NORMAL_IO | VGA_RSRC_NORMAL_MEM;
 +}
 +
 +static int i915_resume_switcheroo(struct drm_device *dev);
 +static int i915_suspend_switcheroo(struct drm_device *dev, pm_message_t state);
 +
 +static void i915_switcheroo_set_state(struct pci_dev *pdev, enum vga_switcheroo_state state)
 +{
 +	struct drm_device *dev = pci_get_drvdata(pdev);
 +	pm_message_t pmm = { .event = PM_EVENT_SUSPEND };
 +
 +	if (state == VGA_SWITCHEROO_ON) {
 +		pr_info("switched on\n");
 +		dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;
 +		/* i915 resume handler doesn't set to D0 */
 +		pci_set_power_state(pdev, PCI_D0);
 +		i915_resume_switcheroo(dev);
 +		dev->switch_power_state = DRM_SWITCH_POWER_ON;
 +	} else {
 +		pr_info("switched off\n");
 +		dev->switch_power_state = DRM_SWITCH_POWER_CHANGING;
 +		i915_suspend_switcheroo(dev, pmm);
 +		dev->switch_power_state = DRM_SWITCH_POWER_OFF;
 +	}
 +}
 +
 +static bool i915_switcheroo_can_switch(struct pci_dev *pdev)
 +{
 +	struct drm_device *dev = pci_get_drvdata(pdev);
 +
 +	/*
 +	 * FIXME: open_count is protected by drm_global_mutex but that would lead to
 +	 * locking inversion with the driver load path. And the access here is
 +	 * completely racy anyway. So don't bother with locking for now.
 +	 */
 +	return dev->open_count == 0;
 +}
 +
 +static const struct vga_switcheroo_client_ops i915_switcheroo_ops = {
 +	.set_gpu_state = i915_switcheroo_set_state,
 +	.reprobe = NULL,
 +	.can_switch = i915_switcheroo_can_switch,
 +};
 +
 +static int i915_load_modeset_init(struct drm_device *dev)
  {
 +	struct drm_i915_private *dev_priv = to_i915(dev);
 +	struct pci_dev *pdev = dev_priv->drm.pdev;
  	int ret;
  
 -	if (i915_inject_probe_failure(i915))
 +	if (i915_inject_load_failure())
  		return -ENODEV;
  
 -	if (HAS_DISPLAY(i915) && INTEL_DISPLAY_ENABLED(i915)) {
 -		ret = drm_vblank_init(&i915->drm,
 -				      INTEL_NUM_PIPES(i915));
 +	if (HAS_DISPLAY(dev_priv)) {
 +		ret = drm_vblank_init(&dev_priv->drm,
 +				      INTEL_INFO(dev_priv)->num_pipes);
  		if (ret)
  			goto out;
  	}
  
 -	intel_bios_init(i915);
 +	intel_bios_init(dev_priv);
  
 -	ret = intel_vga_register(i915);
 -	if (ret)
 +	/* If we have > 1 VGA cards, then we need to arbitrate access
 +	 * to the common VGA resources.
 +	 *
 +	 * If we are a secondary display controller (!PCI_DISPLAY_CLASS_VGA),
 +	 * then we do not take part in VGA arbitration and the
 +	 * vga_client_register() fails with -ENODEV.
 +	 */
 +	ret = vga_client_register(pdev, dev_priv, NULL, i915_vga_set_decode);
 +	if (ret && ret != -ENODEV)
  		goto out;
  
 -	intel_power_domains_init_hw(i915, false);
 +	intel_register_dsm_handler();
 +
 +	ret = vga_switcheroo_register_client(pdev, &i915_switcheroo_ops, false);
 +	if (ret)
 +		goto cleanup_vga_client;
 +
++<<<<<<< HEAD
 +	intel_power_domains_init_hw(dev_priv, false);
  
 -	intel_csr_ucode_init(i915);
 +	intel_csr_ucode_init(dev_priv);
  
 +	ret = intel_irq_install(dev_priv);
 +	if (ret)
 +		goto cleanup_csr;
++=======
+ 	return 0;
+ 
+ out:
+ 	return ret;
+ }
+ 
+ /* part #2: call after irq install */
+ static int i915_driver_modeset_probe(struct drm_i915_private *i915)
+ {
+ 	int ret;
++>>>>>>> b664259f3fe2 (drm/i915: split i915_driver_modeset_probe() to pre/post irq install)
 +
 +	intel_gmbus_setup(dev_priv);
  
  	/* Important: The output setup functions called by modeset_init need
  	 * working irqs for e.g. gmbus and dp aux transfers. */
 -	ret = intel_modeset_init(i915);
 +	ret = intel_modeset_init(dev);
  	if (ret)
- 		goto cleanup_irq;
+ 		goto out;
  
 -	ret = i915_gem_init(i915);
 +	ret = i915_gem_init(dev_priv);
  	if (ret)
  		goto cleanup_modeset;
  
@@@ -751,20 -275,14 +769,27 @@@
  	return 0;
  
  cleanup_gem:
 -	i915_gem_suspend(i915);
 -	i915_gem_driver_remove(i915);
 -	i915_gem_driver_release(i915);
 +	i915_gem_suspend(dev_priv);
 +	i915_gem_fini_hw(dev_priv);
 +	i915_gem_fini(dev_priv);
  cleanup_modeset:
++<<<<<<< HEAD
 +	intel_modeset_cleanup(dev);
 +cleanup_irq:
 +	drm_irq_uninstall(dev);
 +	intel_gmbus_teardown(dev_priv);
 +cleanup_csr:
 +	intel_csr_ucode_fini(dev_priv);
 +	intel_power_domains_fini_hw(dev_priv);
 +	vga_switcheroo_unregister_client(pdev);
 +cleanup_vga_client:
 +	vga_client_register(pdev, NULL, NULL, NULL);
++=======
+ 	/* FIXME */
+ 	intel_modeset_driver_remove(i915);
+ 	intel_irq_uninstall(i915);
+ 	intel_modeset_driver_remove_noirq(i915);
++>>>>>>> b664259f3fe2 (drm/i915: split i915_driver_modeset_probe() to pre/post irq install)
  out:
  	return ret;
  }
@@@ -1915,26 -1461,39 +1940,46 @@@ int i915_driver_load(struct pci_dev *pd
  	if (ret < 0)
  		goto out_cleanup_mmio;
  
++<<<<<<< HEAD
 +	ret = i915_load_modeset_init(&dev_priv->drm);
 +	if (ret < 0)
 +		goto out_cleanup_hw;
 +
 +	i915_driver_register(dev_priv);
++=======
+ 	ret = i915_driver_modeset_probe_noirq(i915);
+ 	if (ret < 0)
+ 		goto out_cleanup_hw;
+ 
+ 	ret = intel_irq_install(i915);
+ 	if (ret)
+ 		goto out_cleanup_modeset;
+ 
+ 	ret = i915_driver_modeset_probe(i915);
+ 	if (ret < 0)
+ 		goto out_cleanup_irq;
+ 
+ 	i915_driver_register(i915);
++>>>>>>> b664259f3fe2 (drm/i915: split i915_driver_modeset_probe() to pre/post irq install)
  
 -	enable_rpm_wakeref_asserts(&i915->runtime_pm);
 +	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
  
 -	i915_welcome_messages(i915);
 +	i915_welcome_messages(dev_priv);
  
  	return 0;
  
+ out_cleanup_irq:
+ 	intel_irq_uninstall(i915);
+ out_cleanup_modeset:
+ 	/* FIXME */
  out_cleanup_hw:
 -	i915_driver_hw_remove(i915);
 -	intel_memory_regions_driver_release(i915);
 -	i915_ggtt_driver_release(i915);
 +	i915_driver_cleanup_hw(dev_priv);
 +	i915_ggtt_cleanup_hw(dev_priv);
  out_cleanup_mmio:
 -	i915_driver_mmio_release(i915);
 +	i915_driver_cleanup_mmio(dev_priv);
  out_runtime_pm_put:
 -	enable_rpm_wakeref_asserts(&i915->runtime_pm);
 -	i915_driver_late_release(i915);
 +	enable_rpm_wakeref_asserts(&dev_priv->runtime_pm);
 +	i915_driver_cleanup_early(dev_priv);
  out_pci_disable:
  	pci_disable_device(pdev);
  out_fini:
* Unmerged path drivers/gpu/drm/i915/i915_drv.c
