bpf: Fix handling of XADD on BTF memory

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jann Horn <jannh@google.com>
commit 8ff3571f7e1bf3f293cc5e3dc14f2943f4fa7fcf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8ff3571f.failed

check_xadd() can cause check_ptr_to_btf_access() to be executed with
atype==BPF_READ and value_regno==-1 (meaning "just check whether the access
is okay, don't tell me what type it will result in").
Handle that case properly and skip writing type information, instead of
indexing into the registers at index -1 and writing into out-of-bounds
memory.

Note that at least at the moment, you can't actually write through a BTF
pointer, so check_xadd() will reject the program after calling
check_ptr_to_btf_access with atype==BPF_WRITE; but that's after the
verifier has already corrupted memory.

This patch assumes that BTF pointers are not available in unprivileged
programs.

Fixes: 9e15db66136a ("bpf: Implement accurate raw_tp context access via BTF")
	Signed-off-by: Jann Horn <jannh@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200417000007.10734-2-jannh@google.com
(cherry picked from commit 8ff3571f7e1bf3f293cc5e3dc14f2943f4fa7fcf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/verifier.c
index a2c1dcade9ad,9382609147f5..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -2880,13 -3099,16 +2880,24 @@@ static int check_ptr_to_btf_access(stru
  	if (ret < 0)
  		return ret;
  
++<<<<<<< HEAD
 +	if (ret == SCALAR_VALUE) {
 +		mark_reg_unknown(env, regs, value_regno);
 +		return 0;
++=======
+ 	if (atype == BPF_READ && value_regno >= 0) {
+ 		if (ret == SCALAR_VALUE) {
+ 			mark_reg_unknown(env, regs, value_regno);
+ 			return 0;
+ 		}
+ 		mark_reg_known_zero(env, regs, value_regno);
+ 		regs[value_regno].type = PTR_TO_BTF_ID;
+ 		regs[value_regno].btf_id = btf_id;
++>>>>>>> 8ff3571f7e1b (bpf: Fix handling of XADD on BTF memory)
  	}
 -
 +	mark_reg_known_zero(env, regs, value_regno);
 +	regs[value_regno].type = PTR_TO_BTF_ID;
 +	regs[value_regno].btf_id = btf_id;
  	return 0;
  }
  
* Unmerged path kernel/bpf/verifier.c
