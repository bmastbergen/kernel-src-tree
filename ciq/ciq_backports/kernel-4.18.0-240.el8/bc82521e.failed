mlxsw: spectrum_trap: Do not initialize dedicated discard policer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ido Schimmel <idosch@mellanox.com>
commit bc82521e3b8e8cfa7e0136080c75a3af3a1b448a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/bc82521e.failed

The policer is now initialized as part of the registration with devlink,
so there is no need to initialize it before the registration.

Remove the initialization.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Reviewed-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bc82521e3b8e8cfa7e0136080c75a3af3a1b448a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
index 13424366f1bb,579f1164ad5d..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
@@@ -202,8 -296,123 +202,117 @@@ static const u16 mlxsw_sp_listener_devl
  	DEVLINK_TRAP_GENERIC_ID_UNRESOLVED_NEIGH,
  	DEVLINK_TRAP_GENERIC_ID_IPV4_LPM_UNICAST_MISS,
  	DEVLINK_TRAP_GENERIC_ID_IPV6_LPM_UNICAST_MISS,
 -	DEVLINK_MLXSW_TRAP_ID_IRIF_DISABLED,
 -	DEVLINK_MLXSW_TRAP_ID_ERIF_DISABLED,
 -	DEVLINK_TRAP_GENERIC_ID_NON_ROUTABLE,
 -	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR,
 -	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR,
 -	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR,
 -	DEVLINK_TRAP_GENERIC_ID_OVERLAY_SMAC_MC,
 -	DEVLINK_TRAP_GENERIC_ID_INGRESS_FLOW_ACTION_DROP,
 -	DEVLINK_TRAP_GENERIC_ID_EGRESS_FLOW_ACTION_DROP,
  };
  
++<<<<<<< HEAD
++=======
+ #define MLXSW_SP_THIN_POLICER_ID	(MLXSW_REG_HTGT_TRAP_GROUP_MAX + 1)
+ 
+ static struct mlxsw_sp_trap_policer_item *
+ mlxsw_sp_trap_policer_item_lookup(struct mlxsw_sp *mlxsw_sp, u32 id)
+ {
+ 	struct mlxsw_sp_trap_policer_item *policer_item;
+ 	struct mlxsw_sp_trap *trap = mlxsw_sp->trap;
+ 
+ 	list_for_each_entry(policer_item, &trap->policer_item_list, list) {
+ 		if (policer_item->id == id)
+ 			return policer_item;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static int mlxsw_sp_trap_cpu_policers_set(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	char qpcr_pl[MLXSW_REG_QPCR_LEN];
+ 
+ 	/* The purpose of "thin" policer is to drop as many packets
+ 	 * as possible. The dummy group is using it.
+ 	 */
+ 	__set_bit(MLXSW_SP_THIN_POLICER_ID, mlxsw_sp->trap->policers_usage);
+ 	mlxsw_reg_qpcr_pack(qpcr_pl, MLXSW_SP_THIN_POLICER_ID,
+ 			    MLXSW_REG_QPCR_IR_UNITS_M, false, 1, 4);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpcr), qpcr_pl);
+ }
+ 
+ static int mlxsw_sp_trap_dummy_group_init(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	char htgt_pl[MLXSW_REG_HTGT_LEN];
+ 
+ 	mlxsw_reg_htgt_pack(htgt_pl, MLXSW_REG_HTGT_TRAP_GROUP_SP_DUMMY,
+ 			    MLXSW_SP_THIN_POLICER_ID, 0, 1);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(htgt), htgt_pl);
+ }
+ 
+ static int mlxsw_sp_trap_policers_init(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	struct devlink *devlink = priv_to_devlink(mlxsw_sp->core);
+ 	struct mlxsw_sp_trap *trap = mlxsw_sp->trap;
+ 	u64 free_policers = 0;
+ 	u32 last_id = 0;
+ 	int err, i;
+ 
+ 	for_each_clear_bit(i, trap->policers_usage, trap->max_policers)
+ 		free_policers++;
+ 
+ 	if (ARRAY_SIZE(mlxsw_sp_trap_policers_arr) > free_policers) {
+ 		dev_err(mlxsw_sp->bus_info->dev, "Exceeded number of supported packet trap policers\n");
+ 		return -ENOBUFS;
+ 	}
+ 
+ 	trap->policers_arr = kcalloc(free_policers,
+ 				     sizeof(struct devlink_trap_policer),
+ 				     GFP_KERNEL);
+ 	if (!trap->policers_arr)
+ 		return -ENOMEM;
+ 
+ 	trap->policers_count = free_policers;
+ 
+ 	for (i = 0; i < free_policers; i++) {
+ 		const struct devlink_trap_policer *policer;
+ 
+ 		if (i < ARRAY_SIZE(mlxsw_sp_trap_policers_arr)) {
+ 			policer = &mlxsw_sp_trap_policers_arr[i];
+ 			trap->policers_arr[i] = *policer;
+ 			last_id = policer->id;
+ 		} else {
+ 			/* Use parameters set for first policer and override
+ 			 * relevant ones.
+ 			 */
+ 			policer = &mlxsw_sp_trap_policers_arr[0];
+ 			trap->policers_arr[i] = *policer;
+ 			trap->policers_arr[i].id = ++last_id;
+ 			trap->policers_arr[i].init_rate = 1;
+ 			trap->policers_arr[i].init_burst = 16;
+ 		}
+ 	}
+ 
+ 	INIT_LIST_HEAD(&trap->policer_item_list);
+ 
+ 	err = devlink_trap_policers_register(devlink, trap->policers_arr,
+ 					     trap->policers_count);
+ 	if (err)
+ 		goto err_trap_policers_register;
+ 
+ 	return 0;
+ 
+ err_trap_policers_register:
+ 	kfree(trap->policers_arr);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_trap_policers_fini(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	struct devlink *devlink = priv_to_devlink(mlxsw_sp->core);
+ 	struct mlxsw_sp_trap *trap = mlxsw_sp->trap;
+ 
+ 	devlink_trap_policers_unregister(devlink, trap->policers_arr,
+ 					 trap->policers_count);
+ 	WARN_ON(!list_empty(&trap->policer_item_list));
+ 	kfree(trap->policers_arr);
+ }
+ 
++>>>>>>> bc82521e3b8e (mlxsw: spectrum_trap: Do not initialize dedicated discard policer)
  int mlxsw_sp_devlink_traps_init(struct mlxsw_sp *mlxsw_sp)
  {
  	size_t groups_count = ARRAY_SIZE(mlxsw_sp_trap_groups_arr);
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
