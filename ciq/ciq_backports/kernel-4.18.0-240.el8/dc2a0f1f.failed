timers: Always keep track of next expiry

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Frederic Weisbecker <frederic@kernel.org>
commit dc2a0f1fb2a06df09f5094f29aea56b763aa7cca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dc2a0f1f.failed

So far next expiry was only tracked while the CPU was in nohz_idle mode
in order to cope with missing ticks that can't increment the base->clk
periodically anymore.

This logic is going to be expanded beyond nohz in order to spare timer
softirqs so do it unconditionally.

	Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Tested-by: Juri Lelli <juri.lelli@redhat.com>
Link: https://lkml.kernel.org/r/20200717140551.29076-8-frederic@kernel.org

(cherry picked from commit dc2a0f1fb2a06df09f5094f29aea56b763aa7cca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/timer.c
diff --cc kernel/time/timer.c
index 052ebc0cd072,76fd9644638b..000000000000
--- a/kernel/time/timer.c
+++ b/kernel/time/timer.c
@@@ -537,30 -543,7 +537,33 @@@ static int calc_wheel_index(unsigned lo
  	return idx;
  }
  
 +/*
 + * Enqueue the timer into the hash bucket, mark it pending in
 + * the bitmap and store the index in the timer flags.
 + */
 +static void enqueue_timer(struct timer_base *base, struct timer_list *timer,
 +			  unsigned int idx)
 +{
 +	hlist_add_head(&timer->entry, base->vectors + idx);
 +	__set_bit(idx, base->pending_map);
 +	timer_set_idx(timer, idx);
 +
 +	trace_timer_start(timer, timer->expires, timer->flags);
 +}
 +
 +static void
++<<<<<<< HEAD
 +__internal_add_timer(struct timer_base *base, struct timer_list *timer)
 +{
 +	unsigned int idx;
 +
 +	idx = calc_wheel_index(timer->expires, base->clk);
 +	enqueue_timer(base, timer, idx);
 +}
 +
  static void
++=======
++>>>>>>> dc2a0f1fb2a0 (timers: Always keep track of next expiry)
  trigger_dyntick_cpu(struct timer_base *base, struct timer_list *timer)
  {
  	if (!is_timers_nohz_active())
@@@ -581,26 -564,47 +584,62 @@@
  	 * timer is not deferrable. If the other CPU is on the way to idle
  	 * then it can't set base->is_idle as we hold the base lock:
  	 */
++<<<<<<< HEAD
 +	if (!base->is_idle)
 +		return;
 +
 +	/* Check whether this is the new first expiring timer: */
 +	if (time_after_eq(timer->expires, base->next_expiry))
 +		return;
 +
 +	/*
 +	 * Set the next expiry time and kick the CPU so it can reevaluate the
 +	 * wheel:
 +	 */
 +	base->next_expiry = timer->expires;
++=======
+ 	if (base->is_idle)
++>>>>>>> dc2a0f1fb2a0 (timers: Always keep track of next expiry)
  		wake_up_nohz_cpu(base->cpu);
  }
  
 -/*
 - * Enqueue the timer into the hash bucket, mark it pending in
 - * the bitmap, store the index in the timer flags then wake up
 - * the target CPU if needed.
 - */
 -static void enqueue_timer(struct timer_base *base, struct timer_list *timer,
 -			  unsigned int idx, unsigned long bucket_expiry)
 +static void
 +internal_add_timer(struct timer_base *base, struct timer_list *timer)
  {
++<<<<<<< HEAD
 +	__internal_add_timer(base, timer);
 +	trigger_dyntick_cpu(base, timer);
++=======
+ 
+ 	hlist_add_head(&timer->entry, base->vectors + idx);
+ 	__set_bit(idx, base->pending_map);
+ 	timer_set_idx(timer, idx);
+ 
+ 	trace_timer_start(timer, timer->expires, timer->flags);
+ 
+ 	/*
+ 	 * Check whether this is the new first expiring timer. The
+ 	 * effective expiry time of the timer is required here
+ 	 * (bucket_expiry) instead of timer->expires.
+ 	 */
+ 	if (time_before(bucket_expiry, base->next_expiry)) {
+ 		/*
+ 		 * Set the next expiry time and kick the CPU so it
+ 		 * can reevaluate the wheel:
+ 		 */
+ 		base->next_expiry = bucket_expiry;
+ 		trigger_dyntick_cpu(base, timer);
+ 	}
+ }
+ 
+ static void internal_add_timer(struct timer_base *base, struct timer_list *timer)
+ {
+ 	unsigned long bucket_expiry;
+ 	unsigned int idx;
+ 
+ 	idx = calc_wheel_index(timer->expires, base->clk, &bucket_expiry);
+ 	enqueue_timer(base, timer, idx, bucket_expiry);
++>>>>>>> dc2a0f1fb2a0 (timers: Always keep track of next expiry)
  }
  
  #ifdef CONFIG_DEBUG_OBJECTS_TIMERS
@@@ -1951,6 -2041,8 +1991,11 @@@ static void __init init_timer_cpu(int c
  		base->cpu = cpu;
  		raw_spin_lock_init(&base->lock);
  		base->clk = jiffies;
++<<<<<<< HEAD
++=======
+ 		base->next_expiry = base->clk + NEXT_TIMER_MAX_DELTA;
+ 		timer_base_init_expiry_lock(base);
++>>>>>>> dc2a0f1fb2a0 (timers: Always keep track of next expiry)
  	}
  }
  
* Unmerged path kernel/time/timer.c
