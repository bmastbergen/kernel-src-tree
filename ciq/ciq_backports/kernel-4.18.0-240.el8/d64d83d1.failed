KVM: x86: Handle PKU CPUID adjustment in VMX code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit d64d83d1e026f9fea9c8f18bf97b9529f7e4189c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d64d83d1.failed

Move the setting of the PKU CPUID bit into VMX to eliminate an instance
of the undesirable "unsigned f_* = *_supported ? F(*) : 0" pattern in
the common CPUID handling code.  Drop ->pku_supported(), CPUID
adjustment was the only user.

Note, some AMD CPUs now support PKU, but SVM doesn't yet support
exposing it to a guest.

No functional change intended.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit d64d83d1e026f9fea9c8f18bf97b9529f7e4189c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/cpuid.c
index d4472786ed92,3413fed22289..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -368,12 -331,8 +368,11 @@@ static int __do_cpuid_func_emulated(str
  
  static inline void do_cpuid_7_mask(struct kvm_cpuid_entry2 *entry)
  {
 +	unsigned f_invpcid = kvm_x86_ops->invpcid_supported() ? F(INVPCID) : 0;
 +	unsigned f_mpx = kvm_mpx_supported() ? F(MPX) : 0;
 +	unsigned f_umip = kvm_x86_ops->umip_emulated() ? F(UMIP) : 0;
  	unsigned f_intel_pt = kvm_x86_ops->pt_supported() ? F(INTEL_PT) : 0;
  	unsigned f_la57;
- 	unsigned f_pku = kvm_x86_ops->pku_supported() ? F(PKU) : 0;
  
  	/* cpuid 7.0.ebx */
  	const u32 kvm_cpuid_7_0_ebx_x86_features =
@@@ -410,23 -369,18 +409,26 @@@
  
  		entry->ecx &= kvm_cpuid_7_0_ecx_x86_features;
  		f_la57 = cpuid_entry_get(entry, X86_FEATURE_LA57);
 -		cpuid_entry_mask(entry, CPUID_7_ECX);
 +		cpuid_mask(&entry->ecx, CPUID_7_ECX);
  		/* Set LA57 based on hardware capability. */
  		entry->ecx |= f_la57;
++<<<<<<< HEAD
 +		entry->ecx |= f_umip;
 +		entry->ecx |= f_pku;
 +		/* PKU is not yet implemented for shadow paging. */
 +		if (!tdp_enabled || !boot_cpu_has(X86_FEATURE_OSPKE))
 +			entry->ecx &= ~F(PKU);
++=======
++>>>>>>> d64d83d1e026 (KVM: x86: Handle PKU CPUID adjustment in VMX code)
  
  		entry->edx &= kvm_cpuid_7_0_edx_x86_features;
 -		cpuid_entry_mask(entry, CPUID_7_EDX);
 +		cpuid_mask(&entry->edx, CPUID_7_EDX);
  		if (boot_cpu_has(X86_FEATURE_IBPB) && boot_cpu_has(X86_FEATURE_IBRS))
 -			cpuid_entry_set(entry, X86_FEATURE_SPEC_CTRL);
 +			entry->edx |= F(SPEC_CTRL);
  		if (boot_cpu_has(X86_FEATURE_STIBP))
 -			cpuid_entry_set(entry, X86_FEATURE_INTEL_STIBP);
 +			entry->edx |= F(INTEL_STIBP);
  		if (boot_cpu_has(X86_FEATURE_AMD_SSBD))
 -			cpuid_entry_set(entry, X86_FEATURE_SPEC_CTRL_SSBD);
 +			entry->edx |= F(SPEC_CTRL_SSBD);
  		/*
  		 * We emulate ARCH_CAPABILITIES in software even
  		 * if the host doesn't support it.
diff --cc arch/x86/kvm/vmx/vmx.c
index b4f527d117f1,60a6ef3ee3b4..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -7251,10 -7123,29 +7251,34 @@@ static void vmx_cpuid_update(struct kvm
  	}
  }
  
 -static void vmx_set_supported_cpuid(struct kvm_cpuid_entry2 *entry)
 +static void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
  {
++<<<<<<< HEAD
 +	if (func == 1 && nested)
 +		entry->ecx |= feature_bit(VMX);
++=======
+ 	switch (entry->function) {
+ 	case 0x1:
+ 		if (nested)
+ 			cpuid_entry_set(entry, X86_FEATURE_VMX);
+ 		break;
+ 	case 0x7:
+ 		if (boot_cpu_has(X86_FEATURE_MPX) && kvm_mpx_supported())
+ 			cpuid_entry_set(entry, X86_FEATURE_MPX);
+ 		if (boot_cpu_has(X86_FEATURE_INVPCID) && cpu_has_vmx_invpcid())
+ 			cpuid_entry_set(entry, X86_FEATURE_INVPCID);
+ 		if (vmx_umip_emulated())
+ 			cpuid_entry_set(entry, X86_FEATURE_UMIP);
+ 
+ 		/* PKU is not yet implemented for shadow paging. */
+ 		if (enable_ept && boot_cpu_has(X86_FEATURE_PKU) &&
+ 		    boot_cpu_has(X86_FEATURE_OSPKE))
+ 			cpuid_entry_set(entry, X86_FEATURE_PKU);
+ 		break;
+ 	default:
+ 		break;
+ 	}
++>>>>>>> d64d83d1e026 (KVM: x86: Handle PKU CPUID adjustment in VMX code)
  }
  
  static void vmx_request_immediate_exit(struct kvm_vcpu *vcpu)
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 69418e1a3a68..fc3939969212 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -1172,7 +1172,6 @@ struct kvm_x86_ops {
 	bool (*xsaves_supported)(void);
 	bool (*umip_emulated)(void);
 	bool (*pt_supported)(void);
-	bool (*pku_supported)(void);
 
 	int (*check_nested_events)(struct kvm_vcpu *vcpu);
 	void (*request_immediate_exit)(struct kvm_vcpu *vcpu);
* Unmerged path arch/x86/kvm/cpuid.c
diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c
index 2c7c88ef7253..67435f3888f2 100644
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -6121,11 +6121,6 @@ static bool svm_has_wbinvd_exit(void)
 	return true;
 }
 
-static bool svm_pku_supported(void)
-{
-	return false;
-}
-
 #define PRE_EX(exit)  { .exit_code = (exit), \
 			.stage = X86_ICPT_PRE_EXCEPT, }
 #define POST_EX(exit) { .exit_code = (exit), \
@@ -7470,7 +7465,6 @@ static struct kvm_x86_ops svm_x86_ops __ro_after_init = {
 	.xsaves_supported = svm_xsaves_supported,
 	.umip_emulated = svm_umip_emulated,
 	.pt_supported = svm_pt_supported,
-	.pku_supported = svm_pku_supported,
 
 	.set_supported_cpuid = svm_set_supported_cpuid,
 
diff --git a/arch/x86/kvm/vmx/capabilities.h b/arch/x86/kvm/vmx/capabilities.h
index cabf43f9e681..51d2e885fefd 100644
--- a/arch/x86/kvm/vmx/capabilities.h
+++ b/arch/x86/kvm/vmx/capabilities.h
@@ -147,11 +147,6 @@ static inline bool vmx_umip_emulated(void)
 		SECONDARY_EXEC_DESC;
 }
 
-static inline bool vmx_pku_supported(void)
-{
-	return boot_cpu_has(X86_FEATURE_PKU);
-}
-
 static inline bool cpu_has_vmx_rdtscp(void)
 {
 	return vmcs_config.cpu_based_2nd_exec_ctrl &
* Unmerged path arch/x86/kvm/vmx/vmx.c
