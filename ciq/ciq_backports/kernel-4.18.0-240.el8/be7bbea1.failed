net/tls: use the full sk_proto pointer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] tls: use the full sk_proto pointer (Sabrina Dubroca) [1819627]
Rebuild_FUZZ: 94.44%
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit be7bbea114d6ab2688b9e59cd24a306d21e51c27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/be7bbea1.failed

Since we already have the pointer to the full original sk_proto
stored use that instead of storing all individual callback
pointers as well.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: John Hurley <john.hurley@netronome.com>
	Reviewed-by: Dirk van der Merwe <dirk.vandermerwe@netronome.com>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit be7bbea114d6ab2688b9e59cd24a306d21e51c27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tls/tls_main.c
diff --cc net/tls/tls_main.c
index f7a147ae7fd3,2df1ae8b77fa..000000000000
--- a/net/tls/tls_main.c
+++ b/net/tls/tls_main.c
@@@ -611,12 -625,8 +613,9 @@@ static struct tls_context *create_ctx(s
  	if (!ctx)
  		return NULL;
  
 +	mutex_init(&ctx->tx_lock);
  	rcu_assign_pointer(icsk->icsk_ulp_data, ctx);
- 	ctx->setsockopt = sk->sk_prot->setsockopt;
- 	ctx->getsockopt = sk->sk_prot->getsockopt;
- 	ctx->sk_proto_close = sk->sk_prot->close;
- 	ctx->unhash = sk->sk_prot->unhash;
+ 	ctx->sk_proto = sk->sk_prot;
  	return ctx;
  }
  
@@@ -672,13 -680,8 +671,10 @@@ static int tls_hw_prot(struct sock *sk
  			if (!ctx)
  				goto out;
  
 +#if 0
  			spin_unlock_bh(&device_spinlock);
 +#endif
  			tls_build_proto(sk);
- 			ctx->hash = sk->sk_prot->hash;
- 			ctx->unhash = sk->sk_prot->unhash;
- 			ctx->sk_proto_close = sk->sk_prot->close;
  			ctx->sk_destruct = sk->sk_destruct;
  			sk->sk_destruct = tls_hw_sk_destruct;
  			ctx->rx_conf = TLS_HW_RECORD;
@@@ -701,13 -702,18 +697,18 @@@ static void tls_hw_unhash(struct sock *
  	struct tls_context *ctx = tls_get_ctx(sk);
  	struct tls_device *dev;
  
 -	spin_lock_bh(&device_spinlock);
 +	mutex_lock(&device_mutex);
  	list_for_each_entry(dev, &device_list, dev_list) {
 -		if (dev->unhash) {
 -			kref_get(&dev->kref);
 -			spin_unlock_bh(&device_spinlock);
 +		if (dev->unhash)
  			dev->unhash(dev, sk);
 -			kref_put(&dev->kref, dev->release);
 -			spin_lock_bh(&device_spinlock);
 -		}
  	}
++<<<<<<< HEAD
 +	mutex_unlock(&device_mutex);
 +	ctx->unhash(sk);
++=======
+ 	spin_unlock_bh(&device_spinlock);
+ 	ctx->sk_proto->unhash(sk);
++>>>>>>> be7bbea114d6 (net/tls: use the full sk_proto pointer)
  }
  
  static int tls_hw_hash(struct sock *sk)
@@@ -716,13 -722,18 +717,18 @@@
  	struct tls_device *dev;
  	int err;
  
++<<<<<<< HEAD
 +	err = ctx->hash(sk);
 +	mutex_lock(&device_mutex);
++=======
+ 	err = ctx->sk_proto->hash(sk);
+ 	spin_lock_bh(&device_spinlock);
++>>>>>>> be7bbea114d6 (net/tls: use the full sk_proto pointer)
  	list_for_each_entry(dev, &device_list, dev_list) {
 -		if (dev->hash) {
 -			kref_get(&dev->kref);
 -			spin_unlock_bh(&device_spinlock);
 +		if (dev->hash)
  			err |= dev->hash(dev, sk);
 -			kref_put(&dev->kref, dev->release);
 -			spin_lock_bh(&device_spinlock);
 -		}
  	}
 -	spin_unlock_bh(&device_spinlock);
 +	mutex_unlock(&device_mutex);
  
  	if (err)
  		tls_hw_unhash(sk);
@@@ -814,14 -823,10 +819,21 @@@ static void tls_update(struct sock *sk
  	struct tls_context *ctx;
  
  	ctx = tls_get_ctx(sk);
++<<<<<<< HEAD
 +	if (likely(ctx)) {
 +		ctx->sk_proto_close = p->close;
 +		ctx->sk_write_space = write_space;
++=======
+ 	if (likely(ctx))
++>>>>>>> be7bbea114d6 (net/tls: use the full sk_proto pointer)
  		ctx->sk_proto = p;
- 	} else {
+ 	else
  		sk->sk_prot = p;
++<<<<<<< HEAD
 +		sk->sk_write_space = write_space;
 +	}
++=======
++>>>>>>> be7bbea114d6 (net/tls: use the full sk_proto pointer)
  }
  
  static int tls_get_info(const struct sock *sk, struct sk_buff *skb)
diff --git a/drivers/crypto/chelsio/chtls/chtls_main.c b/drivers/crypto/chelsio/chtls/chtls_main.c
index f63294c8a97a..d958a33f737c 100644
--- a/drivers/crypto/chelsio/chtls/chtls_main.c
+++ b/drivers/crypto/chelsio/chtls/chtls_main.c
@@ -466,7 +466,8 @@ static int chtls_getsockopt(struct sock *sk, int level, int optname,
 	struct tls_context *ctx = tls_get_ctx(sk);
 
 	if (level != SOL_TLS)
-		return ctx->getsockopt(sk, level, optname, optval, optlen);
+		return ctx->sk_proto->getsockopt(sk, level,
+						 optname, optval, optlen);
 
 	return do_chtls_getsockopt(sk, optval, optlen);
 }
@@ -533,7 +534,8 @@ static int chtls_setsockopt(struct sock *sk, int level, int optname,
 	struct tls_context *ctx = tls_get_ctx(sk);
 
 	if (level != SOL_TLS)
-		return ctx->setsockopt(sk, level, optname, optval, optlen);
+		return ctx->sk_proto->setsockopt(sk, level,
+						 optname, optval, optlen);
 
 	return do_chtls_setsockopt(sk, optname, optval, optlen);
 }
diff --git a/include/net/tls.h b/include/net/tls.h
index 355cc88fb8ed..75df66fa297e 100644
--- a/include/net/tls.h
+++ b/include/net/tls.h
@@ -288,16 +288,6 @@ struct tls_context {
 	struct proto *sk_proto;
 
 	void (*sk_destruct)(struct sock *sk);
-	void (*sk_proto_close)(struct sock *sk, long timeout);
-
-	int  (*setsockopt)(struct sock *sk, int level,
-			   int optname, char __user *optval,
-			   unsigned int optlen);
-	int  (*getsockopt)(struct sock *sk, int level,
-			   int optname, char __user *optval,
-			   int __user *optlen);
-	int  (*hash)(struct sock *sk);
-	void (*unhash)(struct sock *sk);
 
 	union tls_crypto_context crypto_send;
 	union tls_crypto_context crypto_recv;
* Unmerged path net/tls/tls_main.c
