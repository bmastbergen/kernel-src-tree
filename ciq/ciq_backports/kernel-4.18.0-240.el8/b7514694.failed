subflow: explicitly check for plain tcp rsk

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit b7514694ed2952684a1e4fc44d83682140fd8cef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b7514694.failed

When syncookie are in use, the TCP stack may feed into
subflow_syn_recv_sock() plain TCP request sockets. We can't
access mptcp_subflow_request_sock-specific fields on such
sockets. Explicitly check the rsk ops to do safe accesses.

	Reviewed-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Tested-by: Christoph Paasch <cpaasch@apple.com>
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b7514694ed2952684a1e4fc44d83682140fd8cef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/subflow.c
diff --cc net/mptcp/subflow.c
index 98a512655df1,3ef445f59556..000000000000
--- a/net/mptcp/subflow.c
+++ b/net/mptcp/subflow.c
@@@ -390,8 -408,16 +390,21 @@@ static struct sock *subflow_syn_recv_so
  
  	pr_debug("listener=%p, req=%p, conn=%p", listener, req, listener->conn);
  
++<<<<<<< HEAD
 +	opt_rx.mptcp.mp_capable = 0;
 +	if (tcp_rsk(req)->is_mptcp == 0)
++=======
+ 	/* After child creation we must look for 'mp_capable' even when options
+ 	 * are not parsed
+ 	 */
+ 	mp_opt.mp_capable = 0;
+ 
+ 	/* hopefully temporary handling for MP_JOIN+syncookie */
+ 	subflow_req = mptcp_subflow_rsk(req);
+ 	fallback_is_fatal = tcp_rsk(req)->is_mptcp && subflow_req->mp_join;
+ 	fallback = !tcp_rsk(req)->is_mptcp;
+ 	if (fallback)
++>>>>>>> b7514694ed29 (subflow: explicitly check for plain tcp rsk)
  		goto create_child;
  
  	/* if the sk is MP_CAPABLE, we try to fetch the client key */
* Unmerged path net/mptcp/subflow.c
