cpufreq: Fix policy initialization for internal governor drivers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit f5739cb0b56590d68d8df8a44659893b6d0084c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f5739cb0.failed

Before commit 1e4f63aecb53 ("cpufreq: Avoid creating excessively
large stack frames") the initial value of the policy field in struct
cpufreq_policy set by the driver's ->init() callback was implicitly
passed from cpufreq_init_policy() to cpufreq_set_policy() if the
default governor was neither "performance" nor "powersave".  After
that commit, however, cpufreq_init_policy() must take that case into
consideration explicitly and handle it as appropriate, so make that
happen.

Fixes: 1e4f63aecb53 ("cpufreq: Avoid creating excessively large stack frames")
Link: https://lore.kernel.org/linux-pm/39fb762880c27da110086741315ca8b111d781cd.camel@gmail.com/
	Reported-by: Artem Bityutskiy <dedekind1@gmail.com>
	Cc: 5.4+ <stable@vger.kernel.org> # 5.4+
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
(cherry picked from commit f5739cb0b56590d68d8df8a44659893b6d0084c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index c12069858e13,808874bccf4a..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -1081,15 -1073,23 +1081,31 @@@ static int cpufreq_init_policy(struct c
  	} else {
  		/* Use the default policy if there is no last_policy. */
  		if (policy->last_policy) {
++<<<<<<< HEAD
 +			new_policy.policy = policy->last_policy;
 +		} else {
 +			if (!def_gov)
 +				return -ENODATA;
 +			cpufreq_parse_policy(def_gov->name, &new_policy);
++=======
+ 			pol = policy->last_policy;
+ 		} else if (def_gov) {
+ 			pol = cpufreq_parse_policy(def_gov->name);
+ 			/*
+ 			 * In case the default governor is neiter "performance"
+ 			 * nor "powersave", fall back to the initial policy
+ 			 * value set by the driver.
+ 			 */
+ 			if (pol == CPUFREQ_POLICY_UNKNOWN)
+ 				pol = policy->policy;
++>>>>>>> f5739cb0b565 (cpufreq: Fix policy initialization for internal governor drivers)
  		}
+ 		if (pol != CPUFREQ_POLICY_PERFORMANCE &&
+ 		    pol != CPUFREQ_POLICY_POWERSAVE)
+ 			return -ENODATA;
  	}
  
 -	return cpufreq_set_policy(policy, gov, pol);
 +	return cpufreq_set_policy(policy, &new_policy);
  }
  
  static int cpufreq_add_policy_cpu(struct cpufreq_policy *policy, unsigned int cpu)
* Unmerged path drivers/cpufreq/cpufreq.c
