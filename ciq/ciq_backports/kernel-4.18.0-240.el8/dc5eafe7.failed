ALSA: usb-audio: Support PCM sync_stop

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Takashi Iwai <tiwai@suse.de>
commit dc5eafe7787c6c4ffab6c6b8a5f78859a249880e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dc5eafe7.failed

USB-audio driver had some implementation of its own sync-stop
mechanism.  This patch moved a part of it to the common PCM sync_stop
ops.

Link: https://lore.kernel.org/r/20191210063454.31603-56-tiwai@suse.de
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit dc5eafe7787c6c4ffab6c6b8a5f78859a249880e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/usb/pcm.c
diff --cc sound/usb/pcm.c
index bb039c27fad7,8a52996041e9..000000000000
--- a/sound/usb/pcm.c
+++ b/sound/usb/pcm.c
@@@ -1329,7 -1349,7 +1341,11 @@@ static int snd_usb_pcm_close(struct snd
  	struct snd_usb_substream *subs = &as->substream[direction];
  	int ret;
  
++<<<<<<< HEAD
 +	stop_endpoints(subs, true);
++=======
+ 	snd_media_stop_pipeline(subs);
++>>>>>>> dc5eafe7787c (ALSA: usb-audio: Support PCM sync_stop)
  
  	if (!as->chip->keep_iface &&
  	    subs->interface >= 0 &&
@@@ -1758,8 -1778,8 +1774,9 @@@ static const struct snd_pcm_ops snd_usb
  	.hw_free =	snd_usb_hw_free,
  	.prepare =	snd_usb_pcm_prepare,
  	.trigger =	snd_usb_substream_playback_trigger,
+ 	.sync_stop =	snd_usb_pcm_sync_stop,
  	.pointer =	snd_usb_pcm_pointer,
 +	.page =		snd_pcm_lib_get_vmalloc_page,
  };
  
  static const struct snd_pcm_ops snd_usb_capture_ops = {
@@@ -1769,32 -1789,8 +1786,33 @@@
  	.hw_free =	snd_usb_hw_free,
  	.prepare =	snd_usb_pcm_prepare,
  	.trigger =	snd_usb_substream_capture_trigger,
+ 	.sync_stop =	snd_usb_pcm_sync_stop,
  	.pointer =	snd_usb_pcm_pointer,
 +	.page =		snd_pcm_lib_get_vmalloc_page,
 +};
 +
 +static const struct snd_pcm_ops snd_usb_playback_dev_ops = {
 +	.open =		snd_usb_pcm_open,
 +	.close =	snd_usb_pcm_close,
 +	.ioctl =	snd_pcm_lib_ioctl,
 +	.hw_params =	snd_usb_hw_params,
 +	.hw_free =	snd_usb_hw_free,
 +	.prepare =	snd_usb_pcm_prepare,
 +	.trigger =	snd_usb_substream_playback_trigger,
 +	.pointer =	snd_usb_pcm_pointer,
 +	.page =		snd_pcm_sgbuf_ops_page,
 +};
 +
 +static const struct snd_pcm_ops snd_usb_capture_dev_ops = {
 +	.open =		snd_usb_pcm_open,
 +	.close =	snd_usb_pcm_close,
 +	.ioctl =	snd_pcm_lib_ioctl,
 +	.hw_params =	snd_usb_hw_params,
 +	.hw_free =	snd_usb_hw_free,
 +	.prepare =	snd_usb_pcm_prepare,
 +	.trigger =	snd_usb_substream_capture_trigger,
 +	.pointer =	snd_usb_pcm_pointer,
 +	.page =		snd_pcm_sgbuf_ops_page,
  };
  
  void snd_usb_set_pcm_ops(struct snd_pcm *pcm, int stream)
* Unmerged path sound/usb/pcm.c
