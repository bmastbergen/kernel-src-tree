io_uring: expose single mmap capability

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit ac90f249e15cd2a850daa9e36e15f81ce1ff6550
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ac90f249.failed

After commit 75b28affdd6a we can get by with just a single mmap to
map both the sq and cq ring. However, userspace doesn't know that.

Add a features variable to io_uring_params, and notify userspace
that the kernel has this ability. This can then be used in liburing
(or in applications directly) to avoid the second mmap.

	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit ac90f249e15cd2a850daa9e36e15f81ce1ff6550)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 56d0d5127584,be24596e90d7..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -3383,21 -3376,23 +3383,32 @@@ static int io_uring_create(unsigned ent
  		goto err;
  
  	memset(&p->sq_off, 0, sizeof(p->sq_off));
 -	p->sq_off.head = offsetof(struct io_rings, sq.head);
 -	p->sq_off.tail = offsetof(struct io_rings, sq.tail);
 -	p->sq_off.ring_mask = offsetof(struct io_rings, sq_ring_mask);
 -	p->sq_off.ring_entries = offsetof(struct io_rings, sq_ring_entries);
 -	p->sq_off.flags = offsetof(struct io_rings, sq_flags);
 -	p->sq_off.dropped = offsetof(struct io_rings, sq_dropped);
 -	p->sq_off.array = (char *)ctx->sq_array - (char *)ctx->rings;
 +	p->sq_off.head = offsetof(struct io_sq_ring, r.head);
 +	p->sq_off.tail = offsetof(struct io_sq_ring, r.tail);
 +	p->sq_off.ring_mask = offsetof(struct io_sq_ring, ring_mask);
 +	p->sq_off.ring_entries = offsetof(struct io_sq_ring, ring_entries);
 +	p->sq_off.flags = offsetof(struct io_sq_ring, flags);
 +	p->sq_off.dropped = offsetof(struct io_sq_ring, dropped);
 +	p->sq_off.array = offsetof(struct io_sq_ring, array);
  
  	memset(&p->cq_off, 0, sizeof(p->cq_off));
++<<<<<<< HEAD
 +	p->cq_off.head = offsetof(struct io_cq_ring, r.head);
 +	p->cq_off.tail = offsetof(struct io_cq_ring, r.tail);
 +	p->cq_off.ring_mask = offsetof(struct io_cq_ring, ring_mask);
 +	p->cq_off.ring_entries = offsetof(struct io_cq_ring, ring_entries);
 +	p->cq_off.overflow = offsetof(struct io_cq_ring, overflow);
 +	p->cq_off.cqes = offsetof(struct io_cq_ring, cqes);
++=======
+ 	p->cq_off.head = offsetof(struct io_rings, cq.head);
+ 	p->cq_off.tail = offsetof(struct io_rings, cq.tail);
+ 	p->cq_off.ring_mask = offsetof(struct io_rings, cq_ring_mask);
+ 	p->cq_off.ring_entries = offsetof(struct io_rings, cq_ring_entries);
+ 	p->cq_off.overflow = offsetof(struct io_rings, cq_overflow);
+ 	p->cq_off.cqes = offsetof(struct io_rings, cqes);
+ 
+ 	p->features = IORING_FEAT_SINGLE_MMAP;
++>>>>>>> ac90f249e15c (io_uring: expose single mmap capability)
  	return ret;
  err:
  	io_ring_ctx_wait_and_kill(ctx);
* Unmerged path fs/io_uring.c
diff --git a/include/uapi/linux/io_uring.h b/include/uapi/linux/io_uring.h
index 1e1652f25cc1..96ee9d94b73e 100644
--- a/include/uapi/linux/io_uring.h
+++ b/include/uapi/linux/io_uring.h
@@ -128,11 +128,17 @@ struct io_uring_params {
 	__u32 flags;
 	__u32 sq_thread_cpu;
 	__u32 sq_thread_idle;
-	__u32 resv[5];
+	__u32 features;
+	__u32 resv[4];
 	struct io_sqring_offsets sq_off;
 	struct io_cqring_offsets cq_off;
 };
 
+/*
+ * io_uring_params->features flags
+ */
+#define IORING_FEAT_SINGLE_MMAP		(1U << 0)
+
 /*
  * io_uring_register(2) opcodes and arguments
  */
