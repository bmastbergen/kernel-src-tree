ice: cleanup vf_id signedness

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jesse Brandeburg <jesse.brandeburg@intel.com>
commit 53bb66983f34d4ff0af179fe228e2c55e1e45921
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/53bb6698.failed

The vf_id variable is dealt with in the code in inconsistent
ways of sign usage, preventing compilation with -Werror=sign-compare.
Fix this problem in the code by always treating vf_id as unsigned, since
there are no valid values of vf_id that are negative.

	Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 53bb66983f34d4ff0af179fe228e2c55e1e45921)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
diff --cc drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
index 4c35e5f2a915,9fb74a390b8c..000000000000
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
@@@ -1527,6 -1548,72 +1528,75 @@@ static void ice_vc_reset_vf(struct ice_
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * ice_get_vf_from_pfq - get the VF who owns the PF space queue passed in
+  * @pf: PF used to index all VFs
+  * @pfq: queue index relative to the PF's function space
+  *
+  * If no VF is found who owns the pfq then return NULL, otherwise return a
+  * pointer to the VF who owns the pfq
+  */
+ static struct ice_vf *ice_get_vf_from_pfq(struct ice_pf *pf, u16 pfq)
+ {
+ 	unsigned int vf_id;
+ 
+ 	ice_for_each_vf(pf, vf_id) {
+ 		struct ice_vf *vf = &pf->vf[vf_id];
+ 		struct ice_vsi *vsi;
+ 		u16 rxq_idx;
+ 
+ 		vsi = pf->vsi[vf->lan_vsi_idx];
+ 
+ 		ice_for_each_rxq(vsi, rxq_idx)
+ 			if (vsi->rxq_map[rxq_idx] == pfq)
+ 				return vf;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ /**
+  * ice_globalq_to_pfq - convert from global queue index to PF space queue index
+  * @pf: PF used for conversion
+  * @globalq: global queue index used to convert to PF space queue index
+  */
+ static u32 ice_globalq_to_pfq(struct ice_pf *pf, u32 globalq)
+ {
+ 	return globalq - pf->hw.func_caps.common_cap.rxq_first_id;
+ }
+ 
+ /**
+  * ice_vf_lan_overflow_event - handle LAN overflow event for a VF
+  * @pf: PF that the LAN overflow event happened on
+  * @event: structure holding the event information for the LAN overflow event
+  *
+  * Determine if the LAN overflow event was caused by a VF queue. If it was not
+  * caused by a VF, do nothing. If a VF caused this LAN overflow event trigger a
+  * reset on the offending VF.
+  */
+ void
+ ice_vf_lan_overflow_event(struct ice_pf *pf, struct ice_rq_event_info *event)
+ {
+ 	u32 gldcb_rtctq, queue;
+ 	struct ice_vf *vf;
+ 
+ 	gldcb_rtctq = le32_to_cpu(event->desc.params.lan_overflow.prtdcb_ruptq);
+ 	dev_dbg(ice_pf_to_dev(pf), "GLDCB_RTCTQ: 0x%08x\n", gldcb_rtctq);
+ 
+ 	/* event returns device global Rx queue number */
+ 	queue = (gldcb_rtctq & GLDCB_RTCTQ_RXQNUM_M) >>
+ 		GLDCB_RTCTQ_RXQNUM_S;
+ 
+ 	vf = ice_get_vf_from_pfq(pf, ice_globalq_to_pfq(pf, queue));
+ 	if (!vf)
+ 		return;
+ 
+ 	ice_vc_reset_vf(vf);
+ }
+ 
+ /**
++>>>>>>> 53bb66983f34 (ice: cleanup vf_id signedness)
   * ice_vc_send_msg_to_vf - Send message to VF
   * @vf: pointer to the VF info
   * @v_opcode: virtual channel opcode
diff --git a/drivers/net/ethernet/intel/ice/ice.h b/drivers/net/ethernet/intel/ice/ice.h
index 4f1d07a3de0e..aad89c761d51 100644
--- a/drivers/net/ethernet/intel/ice/ice.h
+++ b/drivers/net/ethernet/intel/ice/ice.h
@@ -362,7 +362,7 @@ struct ice_pf {
 	struct ice_sw *first_sw;	/* first switch created by firmware */
 	/* Virtchnl/SR-IOV config info */
 	struct ice_vf *vf;
-	int num_alloc_vfs;		/* actual number of VFs allocated */
+	u16 num_alloc_vfs;		/* actual number of VFs allocated */
 	u16 num_vfs_supported;		/* num VFs supported for this PF */
 	u16 num_vf_qps;			/* num queue pairs per VF */
 	u16 num_vf_msix;		/* num vectors per VF */
* Unmerged path drivers/net/ethernet/intel/ice/ice_virtchnl_pf.c
diff --git a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
index 807fb154e59b..f22c352c15f8 100644
--- a/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
+++ b/drivers/net/ethernet/intel/ice/ice_virtchnl_pf.h
@@ -59,7 +59,7 @@ enum ice_virtchnl_cap {
 struct ice_vf {
 	struct ice_pf *pf;
 
-	s16 vf_id;			/* VF ID in the PF space */
+	u16 vf_id;			/* VF ID in the PF space */
 	u16 lan_vsi_idx;		/* index into PF struct */
 	/* first vector index of this VF in the PF space */
 	int first_vector_idx;
