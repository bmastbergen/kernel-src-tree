io_uring: remove dead check in io_splice()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 948a7749454b1712f1b2f2429f9493eb3e4a89b0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/948a7749.failed

We checked for 'force_nonblock' higher up, so it's definitely false
at this point. Kill the check, it's a remnant of when we tried to do
inline splice without always punting to async context.

Fixes: 2fb3e82284fc ("io_uring: punt splice async because of inode mutex")
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 948a7749454b1712f1b2f2429f9493eb3e4a89b0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 047c6a5f549f,ecfd7f054ef6..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -1480,6 -2727,64 +1480,67 @@@ out_free
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int io_splice_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)
+ {
+ 	struct io_splice* sp = &req->splice;
+ 	unsigned int valid_flags = SPLICE_F_FD_IN_FIXED | SPLICE_F_ALL;
+ 	int ret;
+ 
+ 	if (req->flags & REQ_F_NEED_CLEANUP)
+ 		return 0;
+ 
+ 	sp->file_in = NULL;
+ 	sp->off_in = READ_ONCE(sqe->splice_off_in);
+ 	sp->off_out = READ_ONCE(sqe->off);
+ 	sp->len = READ_ONCE(sqe->len);
+ 	sp->flags = READ_ONCE(sqe->splice_flags);
+ 
+ 	if (unlikely(sp->flags & ~valid_flags))
+ 		return -EINVAL;
+ 
+ 	ret = io_file_get(NULL, req, READ_ONCE(sqe->splice_fd_in), &sp->file_in,
+ 			  (sp->flags & SPLICE_F_FD_IN_FIXED));
+ 	if (ret)
+ 		return ret;
+ 	req->flags |= REQ_F_NEED_CLEANUP;
+ 
+ 	if (!S_ISREG(file_inode(sp->file_in)->i_mode))
+ 		req->work.flags |= IO_WQ_WORK_UNBOUND;
+ 
+ 	return 0;
+ }
+ 
+ static int io_splice(struct io_kiocb *req, bool force_nonblock)
+ {
+ 	struct io_splice *sp = &req->splice;
+ 	struct file *in = sp->file_in;
+ 	struct file *out = sp->file_out;
+ 	unsigned int flags = sp->flags & ~SPLICE_F_FD_IN_FIXED;
+ 	loff_t *poff_in, *poff_out;
+ 	long ret = 0;
+ 
+ 	if (force_nonblock)
+ 		return -EAGAIN;
+ 
+ 	poff_in = (sp->off_in == -1) ? NULL : &sp->off_in;
+ 	poff_out = (sp->off_out == -1) ? NULL : &sp->off_out;
+ 
+ 	if (sp->len)
+ 		ret = do_splice(in, poff_in, out, poff_out, sp->len, flags);
+ 
+ 	io_put_file(req, in, (sp->flags & SPLICE_F_FD_IN_FIXED));
+ 	req->flags &= ~REQ_F_NEED_CLEANUP;
+ 
+ 	io_cqring_add_event(req, ret);
+ 	if (ret != sp->len)
+ 		req_set_fail_links(req);
+ 	io_put_req(req);
+ 	return 0;
+ }
+ 
++>>>>>>> 948a7749454b (io_uring: remove dead check in io_splice())
  /*
   * IORING_OP_NOP just posts a completion event, nothing else.
   */
* Unmerged path fs/io_uring.c
