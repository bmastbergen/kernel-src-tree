Bluetooth: btrtl: Use kvmalloc for FW allocations

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Maxim Mikityanskiy <maxtram95@gmail.com>
commit 268d3636dfb22254324774de1f8875174b3be064
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/268d3636.failed

Currently, kmemdup is applied to the firmware data, and it invokes
kmalloc under the hood. The firmware size and patch_length are big (more
than PAGE_SIZE), and on some low-end systems (like ASUS E202SA) kmalloc
may fail to allocate a contiguous chunk under high memory usage and
fragmentation:

Bluetooth: hci0: RTL: examining hci_ver=06 hci_rev=000a lmp_ver=06 lmp_subver=8821
Bluetooth: hci0: RTL: rom_version status=0 version=1
Bluetooth: hci0: RTL: loading rtl_bt/rtl8821a_fw.bin
kworker/u9:2: page allocation failure: order:4, mode:0x40cc0(GFP_KERNEL|__GFP_COMP), nodemask=(null),cpuset=/,mems_allowed=0
<stack trace follows>

As firmware load happens on each resume, Bluetooth will stop working
after several iterations, when the kernel fails to allocate an order-4
page.

This patch replaces kmemdup with kvmalloc+memcpy. It's not required to
have a contiguous chunk here, because it's not mapped to the device
directly.

	Signed-off-by: Maxim Mikityanskiy <maxtram95@gmail.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 268d3636dfb22254324774de1f8875174b3be064)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btrtl.c
diff --cc drivers/bluetooth/btrtl.c
index 8307e5845311,577cfa3329db..000000000000
--- a/drivers/bluetooth/btrtl.c
+++ b/drivers/bluetooth/btrtl.c
@@@ -262,7 -370,7 +262,11 @@@ static int rtlbt_parse_firmware(struct 
  	 * the end.
  	 */
  	len = patch_length;
++<<<<<<< HEAD
 +	buf = kmemdup(fw->data + patch_offset, patch_length, GFP_KERNEL);
++=======
+ 	buf = kvmalloc(patch_length, GFP_KERNEL);
++>>>>>>> 268d3636dfb2 (Bluetooth: btrtl: Use kvmalloc for FW allocations)
  	if (!buf)
  		return -ENOMEM;
  
@@@ -435,18 -500,18 +442,23 @@@ static int btrtl_setup_rtl8723b(struct 
  	if (ret < 0)
  		goto out;
  
++<<<<<<< HEAD
 +	if (cfg_sz) {
 +		tbuff = kzalloc(ret + cfg_sz, GFP_KERNEL);
++=======
+ 	if (btrtl_dev->cfg_len > 0) {
+ 		tbuff = kvzalloc(ret + btrtl_dev->cfg_len, GFP_KERNEL);
++>>>>>>> 268d3636dfb2 (Bluetooth: btrtl: Use kvmalloc for FW allocations)
  		if (!tbuff) {
  			ret = -ENOMEM;
  			goto out;
  		}
  
  		memcpy(tbuff, fw_data, ret);
- 		kfree(fw_data);
+ 		kvfree(fw_data);
  
 -		memcpy(tbuff + ret, btrtl_dev->cfg_data, btrtl_dev->cfg_len);
 -		ret += btrtl_dev->cfg_len;
 +		memcpy(tbuff + ret, cfg_buff, cfg_sz);
 +		ret += cfg_sz;
  
  		fw_data = tbuff;
  	}
@@@ -456,52 -521,47 +468,64 @@@
  	ret = rtl_download_firmware(hdev, fw_data, ret);
  
  out:
++<<<<<<< HEAD
 +	release_firmware(fw);
 +	kfree(fw_data);
 +err_req_fw:
 +	if (cfg_sz)
 +		kfree(cfg_buff);
++=======
+ 	kvfree(fw_data);
++>>>>>>> 268d3636dfb2 (Bluetooth: btrtl: Use kvmalloc for FW allocations)
  	return ret;
  }
  
 -void btrtl_free(struct btrtl_device_info *btrtl_dev)
 +static struct sk_buff *btrtl_read_local_version(struct hci_dev *hdev)
  {
++<<<<<<< HEAD
 +	struct sk_buff *skb;
++=======
+ 	kvfree(btrtl_dev->fw_data);
+ 	kvfree(btrtl_dev->cfg_data);
+ 	kfree(btrtl_dev);
+ }
+ EXPORT_SYMBOL_GPL(btrtl_free);
++>>>>>>> 268d3636dfb2 (Bluetooth: btrtl: Use kvmalloc for FW allocations)
 +
 +	skb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,
 +			     HCI_INIT_TIMEOUT);
 +	if (IS_ERR(skb)) {
 +		BT_ERR("%s: HCI_OP_READ_LOCAL_VERSION failed (%ld)",
 +		       hdev->name, PTR_ERR(skb));
 +		return skb;
 +	}
  
 -struct btrtl_device_info *btrtl_initialize(struct hci_dev *hdev,
 -					   const char *postfix)
 +	if (skb->len != sizeof(struct hci_rp_read_local_version)) {
 +		BT_ERR("%s: HCI_OP_READ_LOCAL_VERSION event length mismatch",
 +		       hdev->name);
 +		kfree_skb(skb);
 +		return ERR_PTR(-EIO);
 +	}
 +
 +	return skb;
 +}
 +
 +int btrtl_setup_realtek(struct hci_dev *hdev)
  {
 -	struct btrtl_device_info *btrtl_dev;
  	struct sk_buff *skb;
  	struct hci_rp_read_local_version *resp;
 -	char cfg_name[40];
  	u16 hci_rev, lmp_subver;
 -	u8 hci_ver;
 -	int ret;
 -
 -	btrtl_dev = kzalloc(sizeof(*btrtl_dev), GFP_KERNEL);
 -	if (!btrtl_dev) {
 -		ret = -ENOMEM;
 -		goto err_alloc;
 -	}
  
  	skb = btrtl_read_local_version(hdev);
 -	if (IS_ERR(skb)) {
 -		ret = PTR_ERR(skb);
 -		goto err_free;
 -	}
 +	if (IS_ERR(skb))
 +		return -PTR_ERR(skb);
  
  	resp = (struct hci_rp_read_local_version *)skb->data;
 -	rtl_dev_info(hdev, "examining hci_ver=%02x hci_rev=%04x lmp_ver=%02x lmp_subver=%04x",
 -		     resp->hci_ver, resp->hci_rev,
 -		     resp->lmp_ver, resp->lmp_subver);
 +	bt_dev_info(hdev, "rtl: examining hci_ver=%02x hci_rev=%04x "
 +		    "lmp_ver=%02x lmp_subver=%04x",
 +		    resp->hci_ver, resp->hci_rev,
 +		    resp->lmp_ver, resp->lmp_subver);
  
 -	hci_ver = resp->hci_ver;
  	hci_rev = le16_to_cpu(resp->hci_rev);
  	lmp_subver = le16_to_cpu(resp->lmp_subver);
  	kfree_skb(skb);
* Unmerged path drivers/bluetooth/btrtl.c
