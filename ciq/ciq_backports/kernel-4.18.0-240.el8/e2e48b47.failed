netfilter: conntrack: handle icmp pkt_to_tuple helper via direct calls

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit e2e48b471634faa6958718c27208d366b13fe878
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e2e48b47.failed

rather than handling them via indirect call, use a direct one instead.
This leaves GRE as the last user of this indirect call facility.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit e2e48b471634faa6958718c27208d366b13fe878)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_conntrack_l4proto.h
#	net/ipv4/netfilter/nf_conntrack_proto_icmp.c
#	net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
diff --cc include/net/netfilter/nf_conntrack_l4proto.h
index 264f50873a3a,46d554806eb3..000000000000
--- a/include/net/netfilter/nf_conntrack_l4proto.h
+++ b/include/net/netfilter/nf_conntrack_l4proto.h
@@@ -105,6 -90,62 +105,65 @@@ struct nf_conntrack_l4proto 
  	struct module *me;
  };
  
++<<<<<<< HEAD
++=======
+ bool icmp_pkt_to_tuple(const struct sk_buff *skb,
+ 		       unsigned int dataoff,
+ 		       struct net *net,
+ 		       struct nf_conntrack_tuple *tuple);
+ 
+ bool icmpv6_pkt_to_tuple(const struct sk_buff *skb,
+ 			 unsigned int dataoff,
+ 			 struct net *net,
+ 			 struct nf_conntrack_tuple *tuple);
+ 
+ int nf_conntrack_icmpv4_error(struct nf_conn *tmpl,
+ 			      struct sk_buff *skb,
+ 			      unsigned int dataoff,
+ 			      const struct nf_hook_state *state);
+ 
+ int nf_conntrack_icmpv6_error(struct nf_conn *tmpl,
+ 			      struct sk_buff *skb,
+ 			      unsigned int dataoff,
+ 			      const struct nf_hook_state *state);
+ 
+ int nf_conntrack_icmp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state);
+ 
+ int nf_conntrack_icmpv6_packet(struct nf_conn *ct,
+ 			       struct sk_buff *skb,
+ 			       enum ip_conntrack_info ctinfo,
+ 			       const struct nf_hook_state *state);
+ 
+ int nf_conntrack_udp_packet(struct nf_conn *ct,
+ 			    struct sk_buff *skb,
+ 			    unsigned int dataoff,
+ 			    enum ip_conntrack_info ctinfo,
+ 			    const struct nf_hook_state *state);
+ int nf_conntrack_udplite_packet(struct nf_conn *ct,
+ 				struct sk_buff *skb,
+ 				unsigned int dataoff,
+ 				enum ip_conntrack_info ctinfo,
+ 				const struct nf_hook_state *state);
+ int nf_conntrack_tcp_packet(struct nf_conn *ct,
+ 			    struct sk_buff *skb,
+ 			    unsigned int dataoff,
+ 			    enum ip_conntrack_info ctinfo,
+ 			    const struct nf_hook_state *state);
+ int nf_conntrack_dccp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     unsigned int dataoff,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state);
+ int nf_conntrack_sctp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     unsigned int dataoff,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state);
+ 
++>>>>>>> e2e48b471634 (netfilter: conntrack: handle icmp pkt_to_tuple helper via direct calls)
  /* Existing built-in generic protocol */
  extern const struct nf_conntrack_l4proto nf_conntrack_l4proto_generic;
  
diff --cc net/ipv4/netfilter/nf_conntrack_proto_icmp.c
index 7cdc1512bd55,805c1fe5b837..000000000000
--- a/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
+++ b/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
@@@ -24,13 -25,8 +24,18 @@@
  
  static const unsigned int nf_ct_icmp_timeout = 30*HZ;
  
++<<<<<<< HEAD:net/ipv4/netfilter/nf_conntrack_proto_icmp.c
 +static inline struct nf_icmp_net *icmp_pernet(struct net *net)
 +{
 +	return &net->ct.nf_ct_proto.icmp;
 +}
 +
 +static bool icmp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,
 +			      struct net *net, struct nf_conntrack_tuple *tuple)
++=======
+ bool icmp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,
+ 		       struct net *net, struct nf_conntrack_tuple *tuple)
++>>>>>>> e2e48b471634 (netfilter: conntrack: handle icmp pkt_to_tuple helper via direct calls):net/netfilter/nf_conntrack_proto_icmp.c
  {
  	const struct icmphdr *hp;
  	struct icmphdr _hdr;
@@@ -352,16 -346,8 +357,15 @@@ static struct nf_proto_net *icmp_get_ne
  
  const struct nf_conntrack_l4proto nf_conntrack_l4proto_icmp =
  {
 +	.l3proto		= PF_INET,
  	.l4proto		= IPPROTO_ICMP,
- 	.pkt_to_tuple		= icmp_pkt_to_tuple,
  	.invert_tuple		= icmp_invert_tuple,
 +	.packet			= icmp_packet,
 +	.get_timeouts		= icmp_get_timeouts,
 +	.new			= icmp_new,
 +	.error			= icmp_error,
 +	.destroy		= NULL,
 +	.me			= NULL,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr	= icmp_tuple_to_nlattr,
  	.nlattr_tuple_size	= icmp_nlattr_tuple_size,
diff --cc net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
index 4b225a43a543,20cd55e55e41..000000000000
--- a/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
@@@ -29,15 -30,10 +29,22 @@@
  
  static const unsigned int nf_ct_icmpv6_timeout = 30*HZ;
  
++<<<<<<< HEAD:net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
 +static inline struct nf_icmp_net *icmpv6_pernet(struct net *net)
 +{
 +	return &net->ct.nf_ct_proto.icmpv6;
 +}
 +
 +static bool icmpv6_pkt_to_tuple(const struct sk_buff *skb,
 +				unsigned int dataoff,
 +				struct net *net,
 +				struct nf_conntrack_tuple *tuple)
++=======
+ bool icmpv6_pkt_to_tuple(const struct sk_buff *skb,
+ 			 unsigned int dataoff,
+ 			 struct net *net,
+ 			 struct nf_conntrack_tuple *tuple)
++>>>>>>> e2e48b471634 (netfilter: conntrack: handle icmp pkt_to_tuple helper via direct calls):net/netfilter/nf_conntrack_proto_icmpv6.c
  {
  	const struct icmp6hdr *hp;
  	struct icmp6hdr _hdr;
@@@ -353,14 -357,8 +360,13 @@@ static struct nf_proto_net *icmpv6_get_
  
  const struct nf_conntrack_l4proto nf_conntrack_l4proto_icmpv6 =
  {
 +	.l3proto		= PF_INET6,
  	.l4proto		= IPPROTO_ICMPV6,
- 	.pkt_to_tuple		= icmpv6_pkt_to_tuple,
  	.invert_tuple		= icmpv6_invert_tuple,
 +	.packet			= icmpv6_packet,
 +	.get_timeouts		= icmpv6_get_timeouts,
 +	.new			= icmpv6_new,
 +	.error			= icmpv6_error,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr	= icmpv6_tuple_to_nlattr,
  	.nlattr_tuple_size	= icmpv6_nlattr_tuple_size,
* Unmerged path include/net/netfilter/nf_conntrack_l4proto.h
* Unmerged path net/ipv4/netfilter/nf_conntrack_proto_icmp.c
* Unmerged path net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index 397b134cecce..d8277b08026c 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -275,6 +275,12 @@ nf_ct_get_tuple(const struct sk_buff *skb,
 	tuple->dst.protonum = protonum;
 	tuple->dst.dir = IP_CT_DIR_ORIGINAL;
 
+	switch (protonum) {
+	case IPPROTO_ICMPV6:
+		return icmpv6_pkt_to_tuple(skb, dataoff, net, tuple);
+	case IPPROTO_ICMP:
+		return icmp_pkt_to_tuple(skb, dataoff, net, tuple);
+	}
 	if (unlikely(l4proto->pkt_to_tuple))
 		return l4proto->pkt_to_tuple(skb, dataoff, net, tuple);
 
