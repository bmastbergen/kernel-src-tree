intel_idle: Use ACPI _CST for processor models without C-state tables

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 18734958e9bfbc055805d110a38dc76307eba742
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/18734958.failed

Modify the intel_idle driver to get the C-states information from ACPI
_CST if the processor model is not recognized by it.

The processor is still required to support MWAIT and the information
from ACPI _CST will only be used if all of the C-states listed by
_CST are of the ACPI_CSTATE_FFH type (which means that they are
expected to be entered via MWAIT).

Moreover, the driver assumes that the _CST information is the same
for all CPUs in the system, so it is sufficient to evaluate _CST for
one of them and extract the common list of C-states from there.
Also _CST is evaluated once at the system initialization time and
the driver does not respond to _CST change notifications (that can
be changed in the future).

The main functional difference between intel_idle with this change
and the ACPI processor driver is that the former sets the target
residency to be equal to the exit latency (provided by _CST) for
C1-type C-states and to 3 times the exit latency value for the other
C-state types, whereas the latter obtains the target residency by
multiplying the exit latency by the same number (2 by default) for
all C-state types.  Therefore it is expected that in general using
the former instead of the latter on the same system will lead to
improved energy-efficiency.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 18734958e9bfbc055805d110a38dc76307eba742)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/idle/intel_idle.c
diff --cc drivers/idle/intel_idle.c
index 076189997131,28812d93d59a..000000000000
--- a/drivers/idle/intel_idle.c
+++ b/drivers/idle/intel_idle.c
@@@ -1329,45 -1458,22 +1454,47 @@@ static void intel_idle_state_table_upda
  	}
  }
  
- /*
-  * intel_idle_cpuidle_driver_init()
-  * allocate, initialize cpuidle_states
-  */
- static void __init intel_idle_cpuidle_driver_init(void)
+ static void intel_idle_init_cstates_icpu(struct cpuidle_driver *drv)
  {
  	int cstate;
- 	struct cpuidle_driver *drv = &intel_idle_driver;
- 
- 	intel_idle_state_table_update();
- 
- 	cpuidle_poll_state_init(drv);
- 	drv->state_count = 1;
  
  	for (cstate = 0; cstate < CPUIDLE_STATE_MAX; ++cstate) {
 -		unsigned int mwait_hint;
 +		int num_substates, mwait_hint, mwait_cstate;
 +
++<<<<<<< HEAD
 +		if ((cpuidle_state_table[cstate].enter == NULL) &&
 +		    (cpuidle_state_table[cstate].enter_s2idle == NULL))
 +			break;
  
 +		if (cstate + 1 > max_cstate) {
 +			pr_info("max_cstate %d reached\n", max_cstate);
 +			break;
 +		}
 +
 +		mwait_hint = flg2MWAIT(cpuidle_state_table[cstate].flags);
 +		mwait_cstate = MWAIT_HINT2CSTATE(mwait_hint);
 +
 +		/* number of sub-states for this state in CPUID.MWAIT */
 +		num_substates = (mwait_substates >> ((mwait_cstate + 1) * 4))
 +					& MWAIT_SUBSTATE_MASK;
 +
 +		/* if NO sub-states for this state in CPUID, skip it */
 +		if (num_substates == 0)
 +			continue;
 +
 +		/* if state marked as disabled, skip it */
 +		if (cpuidle_state_table[cstate].disabled != 0) {
++=======
+ 		if (intel_idle_max_cstate_reached(cstate))
+ 			break;
+ 
+ 		if (!cpuidle_state_table[cstate].enter &&
+ 		    !cpuidle_state_table[cstate].enter_s2idle)
+ 			break;
+ 
+ 		/* If marked as unusable, skip this state. */
+ 		if (cpuidle_state_table[cstate].flags & CPUIDLE_FLAG_UNUSABLE) {
++>>>>>>> 18734958e9bf (intel_idle: Use ACPI _CST for processor models without C-state tables)
  			pr_debug("state %s is disabled\n",
  				 cpuidle_state_table[cstate].name);
  			continue;
* Unmerged path drivers/idle/intel_idle.c
