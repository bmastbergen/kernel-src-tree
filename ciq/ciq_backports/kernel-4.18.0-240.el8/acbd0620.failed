selftests/bpf: Add vmlinux.h selftest exercising tracing of syscalls

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit acbd06206bbbe59ffd2415c0b902dd244910e42e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/acbd0620.failed

Add vmlinux.h generation to selftest/bpf's Makefile. Use it from newly added
test_vmlinux to trace nanosleep syscall using 5 different types of programs:
  - tracepoint;
  - raw tracepoint;
  - raw tracepoint w/ direct memory reads (tp_btf);
  - kprobe;
  - fentry.

These programs are realistic variants of real-life tracing programs,
excercising vmlinux.h's usage with tracing applications.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
Link: https://lore.kernel.org/bpf/20200313172336.1879637-5-andriin@fb.com
(cherry picked from commit acbd06206bbbe59ffd2415c0b902dd244910e42e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/Makefile
diff --cc tools/testing/selftests/bpf/Makefile
index a1d9b7ae56bd,7729892e0b04..000000000000
--- a/tools/testing/selftests/bpf/Makefile
+++ b/tools/testing/selftests/bpf/Makefile
@@@ -95,21 -119,31 +95,30 @@@ $(notdir $(TEST_GEN_PROGS)						
  	 $(TEST_GEN_PROGS_EXTENDED)					\
  	 $(TEST_CUSTOM_PROGS)): %: $(OUTPUT)/% ;
  
 -$(OUTPUT)/%:%.c
 -	$(call msg,BINARY,,$@)
 -	$(LINK.c) $^ $(LDLIBS) -o $@
 +# NOTE: $(OUTPUT) won't get default value if used before lib.mk
 +TEST_CUSTOM_PROGS = $(OUTPUT)/urandom_read
 +all: $(TEST_CUSTOM_PROGS)
  
 -$(OUTPUT)/urandom_read: urandom_read.c
 -	$(call msg,BINARY,,$@)
 -	$(CC) $(LDFLAGS) -o $@ $< $(LDLIBS) -Wl,--build-id
 +$(OUTPUT)/urandom_read: $(OUTPUT)/%: %.c
 +	$(CC) -o $@ $< -Wl,--build-id
  
 -$(OUTPUT)/test_stub.o: test_stub.c $(BPFOBJ)
 -	$(call msg,CC,,$@)
 -	$(CC) -c $(CFLAGS) -o $@ $<
 +$(OUTPUT)/test_stub.o: test_stub.c
 +	$(CC) $(TEST_PROGS_CFLAGS) $(CFLAGS) -c -o $@ $<
  
++<<<<<<< HEAD
 +BPFOBJ := $(OUTPUT)/libbpf.a
++=======
+ VMLINUX_BTF_PATHS := $(if $(O),$(O)/vmlinux)				\
+ 		     $(if $(KBUILD_OUTPUT),$(KBUILD_OUTPUT)/vmlinux)	\
+ 		     ../../../../vmlinux				\
+ 		     /sys/kernel/btf/vmlinux				\
+ 		     /boot/vmlinux-$(shell uname -r)
+ VMLINUX_BTF := $(abspath $(firstword $(wildcard $(VMLINUX_BTF_PATHS))))
++>>>>>>> acbd06206bbb (selftests/bpf: Add vmlinux.h selftest exercising tracing of syscalls)
  
 -$(OUTPUT)/runqslower: $(BPFOBJ)
 -	$(Q)$(MAKE) $(submake_extras) -C $(TOOLSDIR)/bpf/runqslower	\
 -		    OUTPUT=$(SCRATCH_DIR)/ VMLINUX_BTF=$(VMLINUX_BTF)   \
 -		    BPFOBJ=$(BPFOBJ) BPF_INCLUDE=$(INCLUDE_DIR)
 +$(TEST_GEN_PROGS): $(OUTPUT)/test_stub.o $(BPFOBJ)
  
 -$(TEST_GEN_PROGS) $(TEST_GEN_PROGS_EXTENDED): $(OUTPUT)/test_stub.o $(BPFOBJ)
 +$(TEST_GEN_PROGS_EXTENDED): $(OUTPUT)/test_stub.o $(OUTPUT)/libbpf.a
  
  $(OUTPUT)/test_dev_cgroup: cgroup_helpers.c
  $(OUTPUT)/test_skb_cgroup_id_user: cgroup_helpers.c
@@@ -125,20 -158,29 +134,24 @@@ $(OUTPUT)/test_cgroup_storage: cgroup_h
  $(OUTPUT)/test_netcnt: cgroup_helpers.c
  $(OUTPUT)/test_sock_fields: cgroup_helpers.c
  $(OUTPUT)/test_sysctl: cgroup_helpers.c
 +$(OUTPUT)/test_cgroup_attach: cgroup_helpers.c
 +$(OUTPUT)/test_sockopt: cgroup_helpers.c
 +$(OUTPUT)/test_sockopt_sk: cgroup_helpers.c
 +$(OUTPUT)/test_sockopt_multi: cgroup_helpers.c
 +$(OUTPUT)/test_tcp_rtt: cgroup_helpers.c
  
 -DEFAULT_BPFTOOL := $(SCRATCH_DIR)/sbin/bpftool
 -BPFTOOL ?= $(DEFAULT_BPFTOOL)
 -$(DEFAULT_BPFTOOL): $(wildcard $(BPFTOOLDIR)/*.[ch] $(BPFTOOLDIR)/Makefile)    \
 -		    $(BPFOBJ) | $(BUILD_DIR)/bpftool
 -	$(Q)$(MAKE) $(submake_extras)  -C $(BPFTOOLDIR)			       \
 -		    OUTPUT=$(BUILD_DIR)/bpftool/			       \
 -		    prefix= DESTDIR=$(SCRATCH_DIR)/ install
 -
 -$(BPFOBJ): $(wildcard $(BPFDIR)/*.[ch] $(BPFDIR)/Makefile)		       \
 -	   ../../../include/uapi/linux/bpf.h                                   \
 -	   | $(INCLUDE_DIR) $(BUILD_DIR)/libbpf
 -	$(Q)$(MAKE) $(submake_extras) -C $(BPFDIR) OUTPUT=$(BUILD_DIR)/libbpf/ \
 -		    DESTDIR=$(SCRATCH_DIR) prefix= all install_headers
 -
 -$(BUILD_DIR)/libbpf $(BUILD_DIR)/bpftool $(INCLUDE_DIR):
 -	$(call msg,MKDIR,,$@)
 -	mkdir -p $@
 +.PHONY: force
 +
 +# force a rebuild of BPFOBJ when its dependencies are updated
 +force:
 +
 +$(BPFOBJ): force
 +	$(MAKE) -C $(BPFDIR) OUTPUT=$(OUTPUT)/
  
+ $(INCLUDE_DIR)/vmlinux.h: $(VMLINUX_BTF) | $(BPFTOOL) $(INCLUDE_DIR)
+ 	$(call msg,GEN,,$@)
+ 	$(BPFTOOL) btf dump file $(VMLINUX_BTF) format c > $@
+ 
  # Get Clang's default includes on this system, as opposed to those seen by
  # '-target bpf'. This fixes "missing" files on some architectures/distros,
  # such as asm/byteorder.h, asm/socket.h, asm/sockios.h, sys/cdefs.h etc.
@@@ -161,119 -209,185 +174,206 @@@ $(OUTPUT)/test_l4lb_noinline.o: BPF_CFL
  $(OUTPUT)/test_xdp_noinline.o: BPF_CFLAGS += -fno-inline
  
  $(OUTPUT)/flow_dissector_load.o: flow_dissector_load.h
 +$(OUTPUT)/test_progs.o: flow_dissector_load.h
  
 -# Build BPF object using Clang
 -# $1 - input .c file
 -# $2 - output .o file
 -# $3 - CFLAGS
 -# $4 - LDFLAGS
 -define CLANG_BPF_BUILD_RULE
 -	$(call msg,CLNG-LLC,$(TRUNNER_BINARY),$2)
 -	($(CLANG) $3 -O2 -target bpf -emit-llvm				\
 -		-c $1 -o - || echo "BPF obj compilation failed") | 	\
 -	$(LLC) -mattr=dwarfris -march=bpf -mcpu=v3 $4 -filetype=obj -o $2
 -endef
 -# Similar to CLANG_BPF_BUILD_RULE, but with disabled alu32
 -define CLANG_NOALU32_BPF_BUILD_RULE
 -	$(call msg,CLNG-LLC,$(TRUNNER_BINARY),$2)
 -	($(CLANG) $3 -O2 -target bpf -emit-llvm				\
 -		-c $1 -o - || echo "BPF obj compilation failed") | 	\
 -	$(LLC) -march=bpf -mcpu=v2 $4 -filetype=obj -o $2
 -endef
 -# Similar to CLANG_BPF_BUILD_RULE, but using native Clang and bpf LLC
 -define CLANG_NATIVE_BPF_BUILD_RULE
 -	$(call msg,CLNG-BPF,$(TRUNNER_BINARY),$2)
 -	($(CLANG) $3 -O2 -emit-llvm					\
 -		-c $1 -o - || echo "BPF obj compilation failed") | 	\
 -	$(LLC) -march=bpf -mcpu=v3 $4 -filetype=obj -o $2
 -endef
 -# Build BPF object using GCC
 -define GCC_BPF_BUILD_RULE
 -	$(call msg,GCC-BPF,$(TRUNNER_BINARY),$2)
 -	$(BPF_GCC) $3 $4 -O2 -c $1 -o $2
 -endef
 -
 -SKEL_BLACKLIST := btf__% test_pinning_invalid.c
 -
 -# Set up extra TRUNNER_XXX "temporary" variables in the environment (relies on
 -# $eval()) and pass control to DEFINE_TEST_RUNNER_RULES.
 -# Parameters:
 -# $1 - test runner base binary name (e.g., test_progs)
 -# $2 - test runner extra "flavor" (e.g., no_alu32, gcc-bpf, etc)
 -define DEFINE_TEST_RUNNER
 -
 -TRUNNER_OUTPUT := $(OUTPUT)$(if $2,/)$2
 -TRUNNER_BINARY := $1$(if $2,-)$2
 -TRUNNER_TEST_OBJS := $$(patsubst %.c,$$(TRUNNER_OUTPUT)/%.test.o,	\
 -				 $$(notdir $$(wildcard $(TRUNNER_TESTS_DIR)/*.c)))
 -TRUNNER_EXTRA_OBJS := $$(patsubst %.c,$$(TRUNNER_OUTPUT)/%.o,		\
 -				 $$(filter %.c,$(TRUNNER_EXTRA_SOURCES)))
 -TRUNNER_EXTRA_HDRS := $$(filter %.h,$(TRUNNER_EXTRA_SOURCES))
 -TRUNNER_TESTS_HDR := $(TRUNNER_TESTS_DIR)/tests.h
 -TRUNNER_BPF_SRCS := $$(notdir $$(wildcard $(TRUNNER_BPF_PROGS_DIR)/*.c))
 -TRUNNER_BPF_OBJS := $$(patsubst %.c,$$(TRUNNER_OUTPUT)/%.o, $$(TRUNNER_BPF_SRCS))
 -TRUNNER_BPF_SKELS := $$(patsubst %.c,$$(TRUNNER_OUTPUT)/%.skel.h,	\
 -				 $$(filter-out $(SKEL_BLACKLIST),	\
 -					       $$(TRUNNER_BPF_SRCS)))
 -
 -# Evaluate rules now with extra TRUNNER_XXX variables above already defined
 -$$(eval $$(call DEFINE_TEST_RUNNER_RULES,$1,$2))
 +TEST_PROGS_CFLAGS := -I. -I$(OUTPUT)
 +TEST_MAPS_CFLAGS := -I. -I$(OUTPUT)
 +TEST_VERIFIER_CFLAGS := -I. -I$(OUTPUT) -Iverifier
  
 -endef
 +ifneq ($(SUBREG_CODEGEN),)
 +ALU32_BUILD_DIR = $(OUTPUT)/alu32
 +TEST_CUSTOM_PROGS += $(ALU32_BUILD_DIR)/test_progs_32
 +$(ALU32_BUILD_DIR):
 +	mkdir -p $@
  
 -# Using TRUNNER_XXX variables, provided by callers of DEFINE_TEST_RUNNER and
 -# set up by DEFINE_TEST_RUNNER itself, create test runner build rules with:
 -# $1 - test runner base binary name (e.g., test_progs)
 -# $2 - test runner extra "flavor" (e.g., no_alu32, gcc-bpf, etc)
 -define DEFINE_TEST_RUNNER_RULES
 -
 -ifeq ($($(TRUNNER_OUTPUT)-dir),)
 -$(TRUNNER_OUTPUT)-dir := y
 -$(TRUNNER_OUTPUT):
 -	$$(call msg,MKDIR,,$$@)
 -	mkdir -p $$@
 +$(ALU32_BUILD_DIR)/urandom_read: $(OUTPUT)/urandom_read | $(ALU32_BUILD_DIR)
 +	cp $< $@
 +
 +$(ALU32_BUILD_DIR)/test_progs_32: test_progs.c $(OUTPUT)/libbpf.a\
 +						$(ALU32_BUILD_DIR)/urandom_read \
 +						| $(ALU32_BUILD_DIR)
 +	$(CC) $(TEST_PROGS_CFLAGS) $(CFLAGS) \
 +		-o $(ALU32_BUILD_DIR)/test_progs_32 \
 +		test_progs.c test_stub.c trace_helpers.c prog_tests/*.c \
 +		$(OUTPUT)/libbpf.a $(LDLIBS)
 +
 +$(ALU32_BUILD_DIR)/test_progs_32: $(PROG_TESTS_H)
 +$(ALU32_BUILD_DIR)/test_progs_32: prog_tests/*.c
 +
 +$(ALU32_BUILD_DIR)/%.o: progs/%.c $(ALU32_BUILD_DIR)/test_progs_32 \
 +					| $(ALU32_BUILD_DIR)
 +	($(CLANG) $(BPF_CFLAGS) $(CLANG_CFLAGS) -O2 -target bpf -emit-llvm \
 +		-c $< -o - || echo "clang failed") | \
 +	$(LLC) -march=bpf -mcpu=probe -mattr=+alu32 $(LLC_FLAGS) \
 +		-filetype=obj -o $@
  endif
  
++<<<<<<< HEAD
++=======
+ # ensure we set up BPF objects generation rule just once for a given
+ # input/output directory combination
+ ifeq ($($(TRUNNER_BPF_PROGS_DIR)$(if $2,-)$2-bpfobjs),)
+ $(TRUNNER_BPF_PROGS_DIR)$(if $2,-)$2-bpfobjs := y
+ $(TRUNNER_BPF_OBJS): $(TRUNNER_OUTPUT)/%.o:				\
+ 		     $(TRUNNER_BPF_PROGS_DIR)/%.c			\
+ 		     $(TRUNNER_BPF_PROGS_DIR)/*.h			\
+ 		     $$(INCLUDE_DIR)/vmlinux.h				\
+ 		     $$(BPFOBJ) | $(TRUNNER_OUTPUT)
+ 	$$(call $(TRUNNER_BPF_BUILD_RULE),$$<,$$@,			\
+ 					  $(TRUNNER_BPF_CFLAGS),	\
+ 					  $(TRUNNER_BPF_LDFLAGS))
+ 
+ $(TRUNNER_BPF_SKELS): $(TRUNNER_OUTPUT)/%.skel.h:			\
+ 		      $(TRUNNER_OUTPUT)/%.o				\
+ 		      | $(BPFTOOL) $(TRUNNER_OUTPUT)
+ 	$$(call msg,GEN-SKEL,$(TRUNNER_BINARY),$$@)
+ 	$$(BPFTOOL) gen skeleton $$< > $$@
+ endif
+ 
+ # ensure we set up tests.h header generation rule just once
+ ifeq ($($(TRUNNER_TESTS_DIR)-tests-hdr),)
+ $(TRUNNER_TESTS_DIR)-tests-hdr := y
+ $(TRUNNER_TESTS_HDR): $(TRUNNER_TESTS_DIR)/*.c
+ 	$$(call msg,TEST-HDR,$(TRUNNER_BINARY),$$@)
+ 	$$(shell ( cd $(TRUNNER_TESTS_DIR);				\
+ 		  echo '/* Generated header, do not edit */';		\
+ 		  ls *.c 2> /dev/null |					\
+ 			sed -e 's@\([^\.]*\)\.c@DEFINE_TEST(\1)@';	\
+ 		 ) > $$@)
+ endif
+ 
+ # compile individual test files
+ # Note: we cd into output directory to ensure embedded BPF object is found
+ $(TRUNNER_TEST_OBJS): $(TRUNNER_OUTPUT)/%.test.o:			\
+ 		      $(TRUNNER_TESTS_DIR)/%.c				\
+ 		      $(TRUNNER_EXTRA_HDRS)				\
+ 		      $(TRUNNER_BPF_OBJS)				\
+ 		      $(TRUNNER_BPF_SKELS)				\
+ 		      $$(BPFOBJ) | $(TRUNNER_OUTPUT)
+ 	$$(call msg,TEST-OBJ,$(TRUNNER_BINARY),$$@)
+ 	cd $$(@D) && $$(CC) $$(CFLAGS) -c $(CURDIR)/$$< $$(LDLIBS) -o $$(@F)
+ 
+ $(TRUNNER_EXTRA_OBJS): $(TRUNNER_OUTPUT)/%.o:				\
+ 		       %.c						\
+ 		       $(TRUNNER_EXTRA_HDRS)				\
+ 		       $(TRUNNER_TESTS_HDR)				\
+ 		       $$(BPFOBJ) | $(TRUNNER_OUTPUT)
+ 	$$(call msg,EXT-OBJ,$(TRUNNER_BINARY),$$@)
+ 	$$(CC) $$(CFLAGS) -c $$< $$(LDLIBS) -o $$@
+ 
+ # only copy extra resources if in flavored build
+ $(TRUNNER_BINARY)-extras: $(TRUNNER_EXTRA_FILES) | $(TRUNNER_OUTPUT)
+ ifneq ($2,)
+ 	$$(call msg,EXT-COPY,$(TRUNNER_BINARY),$(TRUNNER_EXTRA_FILES))
+ 	cp -a $$^ $(TRUNNER_OUTPUT)/
+ endif
+ 
+ $(OUTPUT)/$(TRUNNER_BINARY): $(TRUNNER_TEST_OBJS)			\
+ 			     $(TRUNNER_EXTRA_OBJS) $$(BPFOBJ)		\
+ 			     | $(TRUNNER_BINARY)-extras
+ 	$$(call msg,BINARY,,$$@)
+ 	$$(CC) $$(CFLAGS) $$(filter %.a %.o,$$^) $$(LDLIBS) -o $$@
+ 
+ endef
+ 
+ # Define test_progs test runner.
+ TRUNNER_TESTS_DIR := prog_tests
+ TRUNNER_BPF_PROGS_DIR := progs
+ TRUNNER_EXTRA_SOURCES := test_progs.c cgroup_helpers.c trace_helpers.c	\
+ 			 flow_dissector_load.h
+ TRUNNER_EXTRA_FILES := $(OUTPUT)/urandom_read				\
+ 		       $(wildcard progs/btf_dump_test_case_*.c)
+ TRUNNER_BPF_BUILD_RULE := CLANG_BPF_BUILD_RULE
+ TRUNNER_BPF_CFLAGS := $(BPF_CFLAGS) $(CLANG_CFLAGS)
+ TRUNNER_BPF_LDFLAGS := -mattr=+alu32
+ $(eval $(call DEFINE_TEST_RUNNER,test_progs))
+ 
+ # Define test_progs-no_alu32 test runner.
+ TRUNNER_BPF_BUILD_RULE := CLANG_NOALU32_BPF_BUILD_RULE
+ TRUNNER_BPF_LDFLAGS :=
+ $(eval $(call DEFINE_TEST_RUNNER,test_progs,no_alu32))
+ 
+ # Define test_progs BPF-GCC-flavored test runner.
++>>>>>>> acbd06206bbb (selftests/bpf: Add vmlinux.h selftest exercising tracing of syscalls)
  ifneq ($(BPF_GCC),)
 -TRUNNER_BPF_BUILD_RULE := GCC_BPF_BUILD_RULE
 -TRUNNER_BPF_CFLAGS := $(BPF_CFLAGS) $(call get_sys_includes,gcc)
 -TRUNNER_BPF_LDFLAGS :=
 -$(eval $(call DEFINE_TEST_RUNNER,test_progs,bpf_gcc))
 +GCC_SYS_INCLUDES = $(call get_sys_includes,gcc)
 +IS_LITTLE_ENDIAN = $(shell $(CC) -dM -E - </dev/null | \
 +			grep 'define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__')
 +ifeq ($(IS_LITTLE_ENDIAN),)
 +MENDIAN=-mbig-endian
 +else
 +MENDIAN=-mlittle-endian
  endif
 +BPF_GCC_CFLAGS = $(GCC_SYS_INCLUDES) $(MENDIAN)
 +BPF_GCC_BUILD_DIR = $(OUTPUT)/bpf_gcc
 +TEST_CUSTOM_PROGS += $(BPF_GCC_BUILD_DIR)/test_progs_bpf_gcc
 +$(BPF_GCC_BUILD_DIR):
 +	mkdir -p $@
  
 -# Define test_maps test runner.
 -TRUNNER_TESTS_DIR := map_tests
 -TRUNNER_BPF_PROGS_DIR := progs
 -TRUNNER_EXTRA_SOURCES := test_maps.c
 -TRUNNER_EXTRA_FILES :=
 -TRUNNER_BPF_BUILD_RULE := $$(error no BPF objects should be built)
 -TRUNNER_BPF_CFLAGS :=
 -TRUNNER_BPF_LDFLAGS :=
 -$(eval $(call DEFINE_TEST_RUNNER,test_maps))
 +$(BPF_GCC_BUILD_DIR)/urandom_read: $(OUTPUT)/urandom_read | $(BPF_GCC_BUILD_DIR)
 +	cp $< $@
  
 -# Define test_verifier test runner.
 -# It is much simpler than test_maps/test_progs and sufficiently different from
 -# them (e.g., test.h is using completely pattern), that it's worth just
 -# explicitly defining all the rules explicitly.
 -verifier/tests.h: verifier/*.c
 +$(BPF_GCC_BUILD_DIR)/test_progs_bpf_gcc: $(OUTPUT)/test_progs \
 +					 | $(BPF_GCC_BUILD_DIR)
 +	cp $< $@
 +
 +$(BPF_GCC_BUILD_DIR)/%.o: progs/%.c $(BPF_GCC_BUILD_DIR)/test_progs_bpf_gcc \
 +			  | $(BPF_GCC_BUILD_DIR)
 +	$(BPF_GCC) $(BPF_CFLAGS) $(BPF_GCC_CFLAGS) -O2 -c $< -o $@
 +endif
 +
 +# Have one program compiled without "-target bpf" to test whether libbpf loads
 +# it successfully
 +$(OUTPUT)/test_xdp.o: progs/test_xdp.c
 +	($(CLANG) $(BPF_CFLAGS) $(CLANG_CFLAGS) -O2 -emit-llvm -c $< -o - || \
 +		echo "clang failed") | \
 +	$(LLC) -march=bpf -mcpu=probe $(LLC_FLAGS) -filetype=obj -o $@
 +
 +# libbpf has to be built before BPF programs due to bpf_helper_defs.h
 +$(OUTPUT)/%.o: progs/%.c | $(BPFOBJ)
 +	($(CLANG) $(BPF_CFLAGS) $(CLANG_CFLAGS) -O2 -target bpf -emit-llvm \
 +		-c $< -o - || echo "clang failed") | \
 +	$(LLC) -march=bpf -mcpu=probe $(LLC_FLAGS) -filetype=obj -o $@
 +
 +PROG_TESTS_DIR = $(OUTPUT)/prog_tests
 +$(PROG_TESTS_DIR):
 +	mkdir -p $@
 +PROG_TESTS_H := $(PROG_TESTS_DIR)/tests.h
 +PROG_TESTS_FILES := $(wildcard prog_tests/*.c)
 +test_progs.c: $(PROG_TESTS_H)
 +$(OUTPUT)/test_progs: CFLAGS += $(TEST_PROGS_CFLAGS)
 +$(OUTPUT)/test_progs: test_progs.c $(PROG_TESTS_FILES) | $(OUTPUT)/test_attach_probe.o $(PROG_TESTS_H)
 +$(PROG_TESTS_H): $(PROG_TESTS_FILES) | $(PROG_TESTS_DIR)
 +	$(shell ( cd prog_tests/; \
 +		  echo '/* Generated header, do not edit */'; \
 +		  ls *.c 2> /dev/null | \
 +			sed -e 's@\([^\.]*\)\.c@DEFINE_TEST(\1)@'; \
 +		 ) > $(PROG_TESTS_H))
 +
 +MAP_TESTS_DIR = $(OUTPUT)/map_tests
 +$(MAP_TESTS_DIR):
 +	mkdir -p $@
 +MAP_TESTS_H := $(MAP_TESTS_DIR)/tests.h
 +MAP_TESTS_FILES := $(wildcard map_tests/*.c)
 +test_maps.c: $(MAP_TESTS_H)
 +$(OUTPUT)/test_maps: CFLAGS += $(TEST_MAPS_CFLAGS)
 +$(OUTPUT)/test_maps: test_maps.c $(MAP_TESTS_FILES) | $(MAP_TESTS_H)
 +$(MAP_TESTS_H): $(MAP_TESTS_FILES) | $(MAP_TESTS_DIR)
 +	$(shell ( cd map_tests/; \
 +		  echo '/* Generated header, do not edit */'; \
 +		  ls *.c 2> /dev/null | \
 +			sed -e 's@\([^\.]*\)\.c@DEFINE_TEST(\1)@'; \
 +		 ) > $(MAP_TESTS_H))
 +
 +VERIFIER_TESTS_DIR = $(OUTPUT)/verifier
 +$(VERIFIER_TESTS_DIR):
 +	mkdir -p $@
 +VERIFIER_TESTS_H := $(VERIFIER_TESTS_DIR)/tests.h
 +VERIFIER_TEST_FILES := $(wildcard verifier/*.c)
 +test_verifier.c: $(VERIFIER_TESTS_H)
 +$(OUTPUT)/test_verifier: CFLAGS += $(TEST_VERIFIER_CFLAGS)
 +$(OUTPUT)/test_verifier: test_verifier.c | $(VERIFIER_TEST_FILES) $(VERIFIER_TESTS_H)
 +$(VERIFIER_TESTS_H): $(VERIFIER_TEST_FILES) | $(VERIFIER_TESTS_DIR)
  	$(shell ( cd verifier/; \
  		  echo '/* Generated header, do not edit */'; \
  		  echo '#ifdef FILL_ARRAY'; \
* Unmerged path tools/testing/selftests/bpf/Makefile
diff --git a/tools/testing/selftests/bpf/prog_tests/vmlinux.c b/tools/testing/selftests/bpf/prog_tests/vmlinux.c
new file mode 100644
index 000000000000..04939eda1325
--- /dev/null
+++ b/tools/testing/selftests/bpf/prog_tests/vmlinux.c
@@ -0,0 +1,43 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2020 Facebook */
+
+#include <test_progs.h>
+#include <time.h>
+#include "test_vmlinux.skel.h"
+
+#define MY_TV_NSEC 1337
+
+static void nsleep()
+{
+	struct timespec ts = { .tv_nsec = MY_TV_NSEC };
+
+	(void)nanosleep(&ts, NULL);
+}
+
+void test_vmlinux(void)
+{
+	int duration = 0, err;
+	struct test_vmlinux* skel;
+	struct test_vmlinux__bss *bss;
+
+	skel = test_vmlinux__open_and_load();
+	if (CHECK(!skel, "skel_open", "failed to open skeleton\n"))
+		return;
+	bss = skel->bss;
+
+	err = test_vmlinux__attach(skel);
+	if (CHECK(err, "skel_attach", "skeleton attach failed: %d\n", err))
+		goto cleanup;
+
+	/* trigger everything */
+	nsleep();
+
+	CHECK(!bss->tp_called, "tp", "not called\n");
+	CHECK(!bss->raw_tp_called, "raw_tp", "not called\n");
+	CHECK(!bss->tp_btf_called, "tp_btf", "not called\n");
+	CHECK(!bss->kprobe_called, "kprobe", "not called\n");
+	CHECK(!bss->fentry_called, "fentry", "not called\n");
+
+cleanup:
+	test_vmlinux__destroy(skel);
+}
diff --git a/tools/testing/selftests/bpf/progs/test_vmlinux.c b/tools/testing/selftests/bpf/progs/test_vmlinux.c
new file mode 100644
index 000000000000..5611b564d3b1
--- /dev/null
+++ b/tools/testing/selftests/bpf/progs/test_vmlinux.c
@@ -0,0 +1,84 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2020 Facebook */
+
+#include "vmlinux.h"
+#include <asm/unistd.h>
+#include <bpf/bpf_helpers.h>
+#include <bpf/bpf_tracing.h>
+#include <bpf/bpf_core_read.h>
+
+#define MY_TV_NSEC 1337
+
+bool tp_called = false;
+bool raw_tp_called = false;
+bool tp_btf_called = false;
+bool kprobe_called = false;
+bool fentry_called = false;
+
+SEC("tp/syscalls/sys_enter_nanosleep")
+int handle__tp(struct trace_event_raw_sys_enter *args)
+{
+	struct __kernel_timespec *ts;
+
+	if (args->id != __NR_nanosleep)
+		return 0;
+
+	ts = (void *)args->args[0];
+	if (BPF_CORE_READ(ts, tv_nsec) != MY_TV_NSEC)
+		return 0;
+
+	tp_called = true;
+	return 0;
+}
+
+SEC("raw_tp/sys_enter")
+int BPF_PROG(handle__raw_tp, struct pt_regs *regs, long id)
+{
+	struct __kernel_timespec *ts;
+
+	if (id != __NR_nanosleep)
+		return 0;
+
+	ts = (void *)PT_REGS_PARM1_CORE(regs);
+	if (BPF_CORE_READ(ts, tv_nsec) != MY_TV_NSEC)
+		return 0;
+
+	raw_tp_called = true;
+	return 0;
+}
+
+SEC("tp_btf/sys_enter")
+int BPF_PROG(handle__tp_btf, struct pt_regs *regs, long id)
+{
+	struct __kernel_timespec *ts;
+
+	if (id != __NR_nanosleep)
+		return 0;
+
+	ts = (void *)PT_REGS_PARM1_CORE(regs);
+	if (BPF_CORE_READ(ts, tv_nsec) != MY_TV_NSEC)
+		return 0;
+
+	tp_btf_called = true;
+	return 0;
+}
+
+SEC("kprobe/hrtimer_nanosleep")
+int BPF_KPROBE(handle__kprobe,
+	       ktime_t rqtp, enum hrtimer_mode mode, clockid_t clockid)
+{
+	if (rqtp == MY_TV_NSEC)
+		kprobe_called = true;
+	return 0;
+}
+
+SEC("fentry/hrtimer_nanosleep")
+int BPF_PROG(handle__fentry,
+	     ktime_t rqtp, enum hrtimer_mode mode, clockid_t clockid)
+{
+	if (rqtp == MY_TV_NSEC)
+		fentry_called = true;
+	return 0;
+}
+
+char _license[] SEC("license") = "GPL";
