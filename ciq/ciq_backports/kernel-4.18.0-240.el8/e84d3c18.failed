RDMA/efa: Use the common mmap_xa helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Michal Kalderon <michal.kalderon@marvell.com>
commit e84d3c184e7967559d511e4569c111a02d64031e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e84d3c18.failed

Remove the functions related to managing the mmap_xa database.  This code
was replaced with common code in ib_core.

Link: https://lore.kernel.org/r/20191030094417.16866-5-michal.kalderon@marvell.com
	Signed-off-by: Ariel Elior <ariel.elior@marvell.com>
	Signed-off-by: Michal Kalderon <michal.kalderon@marvell.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit e84d3c184e7967559d511e4569c111a02d64031e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/efa/efa_verbs.c
diff --cc drivers/infiniband/hw/efa/efa_verbs.c
index f36071a92f97,b242ea7a3bc8..000000000000
--- a/drivers/infiniband/hw/efa/efa_verbs.c
+++ b/drivers/infiniband/hw/efa/efa_verbs.c
@@@ -33,13 -29,32 +29,40 @@@ struct efa_user_mmap_entry 
  	u8 mmap_flag;
  };
  
++<<<<<<< HEAD
 +static inline u64 get_mmap_key(const struct efa_mmap_entry *efa)
 +{
 +	return ((u64)efa->mmap_flag << EFA_MMAP_FLAG_SHIFT) |
 +	       ((u64)efa->mmap_page << PAGE_SHIFT);
 +}
++=======
+ #define EFA_DEFINE_STATS(op) \
+ 	op(EFA_TX_BYTES, "tx_bytes") \
+ 	op(EFA_TX_PKTS, "tx_pkts") \
+ 	op(EFA_RX_BYTES, "rx_bytes") \
+ 	op(EFA_RX_PKTS, "rx_pkts") \
+ 	op(EFA_RX_DROPS, "rx_drops") \
+ 	op(EFA_SUBMITTED_CMDS, "submitted_cmds") \
+ 	op(EFA_COMPLETED_CMDS, "completed_cmds") \
+ 	op(EFA_NO_COMPLETION_CMDS, "no_completion_cmds") \
+ 	op(EFA_KEEP_ALIVE_RCVD, "keep_alive_rcvd") \
+ 	op(EFA_ALLOC_PD_ERR, "alloc_pd_err") \
+ 	op(EFA_CREATE_QP_ERR, "create_qp_err") \
+ 	op(EFA_REG_MR_ERR, "reg_mr_err") \
+ 	op(EFA_ALLOC_UCONTEXT_ERR, "alloc_ucontext_err") \
+ 	op(EFA_CREATE_AH_ERR, "create_ah_err")
+ 
+ #define EFA_STATS_ENUM(ename, name) ename,
+ #define EFA_STATS_STR(ename, name) [ename] = name,
+ 
+ enum efa_hw_stats {
+ 	EFA_DEFINE_STATS(EFA_STATS_ENUM)
+ };
+ 
+ static const char *const efa_stats_names[] = {
+ 	EFA_DEFINE_STATS(EFA_STATS_STR)
+ };
++>>>>>>> e84d3c184e79 (RDMA/efa: Use the common mmap_xa helpers)
  
  #define EFA_CHUNK_PAYLOAD_SHIFT       12
  #define EFA_CHUNK_PAYLOAD_SIZE        BIT(EFA_CHUNK_PAYLOAD_SHIFT)
@@@ -120,8 -135,14 +143,14 @@@ static inline struct efa_ah *to_eah(str
  	return container_of(ibah, struct efa_ah, ibah);
  }
  
+ static inline struct efa_user_mmap_entry *
+ to_emmap(struct rdma_user_mmap_entry *rdma_entry)
+ {
+ 	return container_of(rdma_entry, struct efa_user_mmap_entry, rdma_entry);
+ }
+ 
  #define field_avail(x, fld, sz) (offsetof(typeof(x), fld) + \
 -				 FIELD_SIZEOF(typeof(x), fld) <= (sz))
 +				 sizeof(((typeof(x) *)0)->fld) <= (sz))
  
  #define is_reserved_cleared(reserved) \
  	!memchr_inv(reserved, 0, sizeof(reserved))
@@@ -1586,12 -1572,16 +1582,25 @@@ static int __efa_mmap(struct efa_dev *d
  	pfn = entry->address >> PAGE_SHIFT;
  	switch (entry->mmap_flag) {
  	case EFA_MMAP_IO_NC:
++<<<<<<< HEAD
 +		err = rdma_user_mmap_io(&ucontext->ibucontext, vma, pfn, length,
 +					pgprot_noncached(vma->vm_page_prot));
 +		break;
 +	case EFA_MMAP_IO_WC:
 +		err = rdma_user_mmap_io(&ucontext->ibucontext, vma, pfn, length,
 +					pgprot_writecombine(vma->vm_page_prot));
++=======
+ 		err = rdma_user_mmap_io(&ucontext->ibucontext, vma, pfn,
+ 					entry->rdma_entry.npages * PAGE_SIZE,
+ 					pgprot_noncached(vma->vm_page_prot),
+ 					rdma_entry);
+ 		break;
+ 	case EFA_MMAP_IO_WC:
+ 		err = rdma_user_mmap_io(&ucontext->ibucontext, vma, pfn,
+ 					entry->rdma_entry.npages * PAGE_SIZE,
+ 					pgprot_writecombine(vma->vm_page_prot),
+ 					rdma_entry);
++>>>>>>> e84d3c184e79 (RDMA/efa: Use the common mmap_xa helpers)
  		break;
  	case EFA_MMAP_DMA_PAGE:
  		for (va = vma->vm_start; va < vma->vm_end;
diff --git a/drivers/infiniband/hw/efa/efa.h b/drivers/infiniband/hw/efa/efa.h
index 119f8efec564..7cffdd51512a 100644
--- a/drivers/infiniband/hw/efa/efa.h
+++ b/drivers/infiniband/hw/efa/efa.h
@@ -71,8 +71,6 @@ struct efa_dev {
 
 struct efa_ucontext {
 	struct ib_ucontext ibucontext;
-	struct xarray mmap_xa;
-	u32 mmap_xa_page;
 	u16 uarn;
 };
 
@@ -91,6 +89,7 @@ struct efa_cq {
 	struct efa_ucontext *ucontext;
 	dma_addr_t dma_addr;
 	void *cpu_addr;
+	struct rdma_user_mmap_entry *mmap_entry;
 	size_t size;
 	u16 cq_idx;
 };
@@ -101,6 +100,13 @@ struct efa_qp {
 	void *rq_cpu_addr;
 	size_t rq_size;
 	enum ib_qp_state state;
+
+	/* Used for saving mmap_xa entries */
+	struct rdma_user_mmap_entry *sq_db_mmap_entry;
+	struct rdma_user_mmap_entry *llq_desc_mmap_entry;
+	struct rdma_user_mmap_entry *rq_db_mmap_entry;
+	struct rdma_user_mmap_entry *rq_mmap_entry;
+
 	u32 qp_handle;
 	u32 max_send_wr;
 	u32 max_recv_wr;
@@ -147,6 +153,7 @@ int efa_alloc_ucontext(struct ib_ucontext *ibucontext, struct ib_udata *udata);
 void efa_dealloc_ucontext(struct ib_ucontext *ibucontext);
 int efa_mmap(struct ib_ucontext *ibucontext,
 	     struct vm_area_struct *vma);
+void efa_mmap_free(struct rdma_user_mmap_entry *rdma_entry);
 int efa_create_ah(struct ib_ah *ibah,
 		  struct rdma_ah_attr *ah_attr,
 		  u32 flags,
diff --git a/drivers/infiniband/hw/efa/efa_main.c b/drivers/infiniband/hw/efa/efa_main.c
index dd1c6d49466f..65508c73accd 100644
--- a/drivers/infiniband/hw/efa/efa_main.c
+++ b/drivers/infiniband/hw/efa/efa_main.c
@@ -215,6 +215,7 @@ static const struct ib_device_ops efa_dev_ops = {
 	.get_link_layer = efa_port_link_layer,
 	.get_port_immutable = efa_get_port_immutable,
 	.mmap = efa_mmap,
+	.mmap_free = efa_mmap_free,
 	.modify_qp = efa_modify_qp,
 	.query_device = efa_query_device,
 	.query_gid = efa_query_gid,
* Unmerged path drivers/infiniband/hw/efa/efa_verbs.c
