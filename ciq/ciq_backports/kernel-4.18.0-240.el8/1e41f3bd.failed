nvme: just check the status code type in nvme_is_path_error

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 1e41f3bd26f79463c07aebf062a0a77f1fd39b2b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/1e41f3bd.failed

Check the SCT sub-field for a path related status instead of enumerating
invididual status code.  As of NVMe 1.4 this adds "Internal Path Error"
and "Controller Pathing Error" to the list, but it also future proofs for
additional status codes added to the category.

	Suggested-by: Chao Leng <lengchao@huawei.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Mike Snitzer <snitzer@redhat.com>
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 1e41f3bd26f79463c07aebf062a0a77f1fd39b2b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/nvme.h
diff --cc drivers/nvme/host/nvme.h
index 09ed30add536,e9cf29449dd1..000000000000
--- a/drivers/nvme/host/nvme.h
+++ b/drivers/nvme/host/nvme.h
@@@ -404,12 -499,55 +404,56 @@@ static inline int nvme_reset_subsystem(
  	return ctrl->ops->reg_write32(ctrl, NVME_REG_NSSR, 0x4E564D65);
  }
  
 -/*
 - * Convert a 512B sector number to a device logical block number.
 - */
 -static inline u64 nvme_sect_to_lba(struct nvme_ns *ns, sector_t sector)
 +static inline u64 nvme_block_nr(struct nvme_ns *ns, sector_t sector)
  {
 -	return sector >> (ns->lba_shift - SECTOR_SHIFT);
 +	return (sector >> (ns->lba_shift - 9));
  }
  
++<<<<<<< HEAD
 +static inline void nvme_end_request(struct request *req, __le16 status,
++=======
+ /*
+  * Convert a device logical block number to a 512B sector number.
+  */
+ static inline sector_t nvme_lba_to_sect(struct nvme_ns *ns, u64 lba)
+ {
+ 	return lba << (ns->lba_shift - SECTOR_SHIFT);
+ }
+ 
+ /*
+  * Convert byte length to nvme's 0-based num dwords
+  */
+ static inline u32 nvme_bytes_to_numd(size_t len)
+ {
+ 	return (len >> 2) - 1;
+ }
+ 
+ static inline bool nvme_is_ana_error(u16 status)
+ {
+ 	switch (status & 0x7ff) {
+ 	case NVME_SC_ANA_TRANSITION:
+ 	case NVME_SC_ANA_INACCESSIBLE:
+ 	case NVME_SC_ANA_PERSISTENT_LOSS:
+ 		return true;
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static inline bool nvme_is_path_error(u16 status)
+ {
+ 	/* check for a status code type of 'path related status' */
+ 	return (status & 0x700) == 0x300;
+ }
+ 
+ /*
+  * Fill in the status and result information from the CQE, and then figure out
+  * if blk-mq will need to use IPI magic to complete the request, and if yes do
+  * so.  If not let the caller complete the request without an indirect function
+  * call.
+  */
+ static inline bool nvme_try_complete_req(struct request *req, __le16 status,
++>>>>>>> 1e41f3bd26f7 (nvme: just check the status code type in nvme_is_path_error)
  		union nvme_result result)
  {
  	struct nvme_request *rq = nvme_req(req);
* Unmerged path drivers/nvme/host/nvme.h
