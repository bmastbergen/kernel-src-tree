iommu: Do not probe devices on IOMMU-less busses

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Thierry Reding <treding@nvidia.com>
commit f38338cf0691b5fae5f9a46d188eef92ab9e6296
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f38338cf.failed

The host1x bus implemented on Tegra SoCs is primarily an abstraction to
create logical device from multiple platform devices. Since the devices
in such a setup are typically hierarchical, DMA setup still needs to be
done so that DMA masks can be properly inherited, but we don't actually
want to attach the host1x logical devices to any IOMMU. The platform
devices that make up the logical device are responsible for memory bus
transactions, so it is them that will need to be attached to the IOMMU.

Add a check to __iommu_probe_device() that aborts IOMMU setup early for
busses that don't have the IOMMU operations pointer set since they will
cause a crash otherwise.

	Signed-off-by: Thierry Reding <treding@nvidia.com>
Link: https://lore.kernel.org/r/20200511161000.3853342-1-thierry.reding@gmail.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit f38338cf0691b5fae5f9a46d188eef92ab9e6296)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
diff --cc drivers/iommu/iommu.c
index 7997fcb701e0,9d1d917e1050..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -161,6 -164,81 +161,84 @@@ void iommu_device_unregister(struct iom
  	list_del(&iommu->list);
  	spin_unlock(&iommu_device_lock);
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL_GPL(iommu_device_unregister);
+ 
+ static struct dev_iommu *dev_iommu_get(struct device *dev)
+ {
+ 	struct dev_iommu *param = dev->iommu;
+ 
+ 	if (param)
+ 		return param;
+ 
+ 	param = kzalloc(sizeof(*param), GFP_KERNEL);
+ 	if (!param)
+ 		return NULL;
+ 
+ 	mutex_init(&param->lock);
+ 	dev->iommu = param;
+ 	return param;
+ }
+ 
+ static void dev_iommu_free(struct device *dev)
+ {
+ 	kfree(dev->iommu);
+ 	dev->iommu = NULL;
+ }
+ 
+ static int __iommu_probe_device(struct device *dev, struct list_head *group_list)
+ {
+ 	const struct iommu_ops *ops = dev->bus->iommu_ops;
+ 	struct iommu_device *iommu_dev;
+ 	struct iommu_group *group;
+ 	int ret;
+ 
+ 	if (!ops)
+ 		return -ENODEV;
+ 
+ 	if (!dev_iommu_get(dev))
+ 		return -ENOMEM;
+ 
+ 	if (!try_module_get(ops->owner)) {
+ 		ret = -EINVAL;
+ 		goto err_free;
+ 	}
+ 
+ 	iommu_dev = ops->probe_device(dev);
+ 	if (IS_ERR(iommu_dev)) {
+ 		ret = PTR_ERR(iommu_dev);
+ 		goto out_module_put;
+ 	}
+ 
+ 	dev->iommu->iommu_dev = iommu_dev;
+ 
+ 	group = iommu_group_get_for_dev(dev);
+ 	if (IS_ERR(group)) {
+ 		ret = PTR_ERR(group);
+ 		goto out_release;
+ 	}
+ 	iommu_group_put(group);
+ 
+ 	if (group_list && !group->default_domain && list_empty(&group->entry))
+ 		list_add_tail(&group->entry, group_list);
+ 
+ 	iommu_device_link(iommu_dev, dev);
+ 
+ 	return 0;
+ 
+ out_release:
+ 	ops->release_device(dev);
+ 
+ out_module_put:
+ 	module_put(ops->owner);
+ 
+ err_free:
+ 	dev_iommu_free(dev);
+ 
+ 	return ret;
+ }
++>>>>>>> f38338cf0691 (iommu: Do not probe devices on IOMMU-less busses)
  
  int iommu_probe_device(struct device *dev)
  {
* Unmerged path drivers/iommu/iommu.c
