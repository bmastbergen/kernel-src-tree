ext4: unsigned int compared against zero

jira LE-1907
cve CVE-2019-19319
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Colin Ian King <colin.king@canonical.com>
commit fbbbbd2f28aec991f3fbc248df211550fbdfd58c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/fbbbbd2f.failed

There are two cases where u32 variables n and err are being checked
for less than zero error values, the checks is always false because
the variables are not signed. Fix this by making the variables ints.

Addresses-Coverity: ("Unsigned compared against 0")
Fixes: 345c0dbf3a30 ("ext4: protect journal inode's blocks using block_validity")
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
(cherry picked from commit fbbbbd2f28aec991f3fbc248df211550fbdfd58c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/block_validity.c
diff --cc fs/ext4/block_validity.c
index 64c1310e4364,8d03550aaae3..000000000000
--- a/fs/ext4/block_validity.c
+++ b/fs/ext4/block_validity.c
@@@ -137,6 -137,49 +137,52 @@@ static void debug_print_tree(struct ext
  	printk(KERN_CONT "\n");
  }
  
++<<<<<<< HEAD
++=======
+ static int ext4_protect_reserved_inode(struct super_block *sb, u32 ino)
+ {
+ 	struct inode *inode;
+ 	struct ext4_sb_info *sbi = EXT4_SB(sb);
+ 	struct ext4_map_blocks map;
+ 	u32 i = 0, num;
+ 	int err = 0, n;
+ 
+ 	if ((ino < EXT4_ROOT_INO) ||
+ 	    (ino > le32_to_cpu(sbi->s_es->s_inodes_count)))
+ 		return -EINVAL;
+ 	inode = ext4_iget(sb, ino, EXT4_IGET_SPECIAL);
+ 	if (IS_ERR(inode))
+ 		return PTR_ERR(inode);
+ 	num = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
+ 	while (i < num) {
+ 		map.m_lblk = i;
+ 		map.m_len = num - i;
+ 		n = ext4_map_blocks(NULL, inode, &map, 0);
+ 		if (n < 0) {
+ 			err = n;
+ 			break;
+ 		}
+ 		if (n == 0) {
+ 			i++;
+ 		} else {
+ 			if (!ext4_data_block_valid(sbi, map.m_pblk, n)) {
+ 				ext4_error(sb, "blocks %llu-%llu from inode %u "
+ 					   "overlap system zone", map.m_pblk,
+ 					   map.m_pblk + map.m_len - 1, ino);
+ 				err = -EFSCORRUPTED;
+ 				break;
+ 			}
+ 			err = add_system_zone(sbi, map.m_pblk, n);
+ 			if (err < 0)
+ 				break;
+ 			i += n;
+ 		}
+ 	}
+ 	iput(inode);
+ 	return err;
+ }
+ 
++>>>>>>> fbbbbd2f28ae (ext4: unsigned int compared against zero)
  int ext4_setup_system_zone(struct super_block *sb)
  {
  	ext4_group_t ngroups = ext4_get_groups_count(sb);
* Unmerged path fs/ext4/block_validity.c
