cpuidle: Allow idle injection to apply exit latency limit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Daniel Lezcano <daniel.lezcano@linaro.org>
commit c55b51a06b01d67a99457bb82a8c31081c7faa23
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c55b51a0.failed

In some cases it may be useful to specify an exit latency limit for
the idle state to be used during CPU idle time injection.

Instead of duplicating the information in struct cpuidle_device
or propagating the latency limit in the call stack, replace the
use_deepest_state field with forced_latency_limit_ns to represent
that limit, so that the deepest idle state with exit latency within
that limit is forced (i.e. no governors) when it is set.

A zero exit latency limit for forced idle means to use governors in
the usual way (analogous to use_deepest_state equal to "false" before
this change).

Additionally, add play_idle_precise() taking two arguments, the
duration of forced idle and the idle state exit latency limit, both
in nanoseconds, and redefine play_idle() as a wrapper around that
new function.

This change is preparatory, no functional impact is expected.

	Suggested-by: Rafael J. Wysocki <rafael@kernel.org>
	Signed-off-by: Daniel Lezcano <daniel.lezcano@linaro.org>
[ rjw: Subject, changelog, cpuidle_use_deepest_state() kerneldoc, whitespace ]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit c55b51a06b01d67a99457bb82a8c31081c7faa23)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/cpu.h
#	include/linux/cpuidle.h
#	kernel/sched/idle.c
diff --cc include/linux/cpu.h
index 65280c4bb84d,cc03a7848b63..000000000000
--- a/include/linux/cpu.h
+++ b/include/linux/cpu.h
@@@ -184,7 -179,12 +184,16 @@@ void arch_cpu_idle_dead(void)
  int cpu_report_state(int cpu);
  int cpu_check_up_prepare(int cpu);
  void cpu_set_state_online(int cpu);
++<<<<<<< HEAD
 +void play_idle(unsigned long duration_ms);
++=======
+ void play_idle_precise(u64 duration_ns, u64 latency_ns);
+ 
+ static inline void play_idle(unsigned long duration_us)
+ {
+ 	play_idle_precise(duration_us * NSEC_PER_USEC, U64_MAX);
+ }
++>>>>>>> c55b51a06b01 (cpuidle: Allow idle injection to apply exit latency limit)
  
  #ifdef CONFIG_HOTPLUG_CPU
  bool cpu_wait_death(unsigned int cpu, int seconds);
diff --cc include/linux/cpuidle.h
index a24a6cef6983,72b26ff1de4b..000000000000
--- a/include/linux/cpuidle.h
+++ b/include/linux/cpuidle.h
@@@ -112,12 -85,14 +112,23 @@@ struct cpuidle_driver_kobj
  struct cpuidle_device {
  	unsigned int		registered:1;
  	unsigned int		enabled:1;
++<<<<<<< HEAD
 +	unsigned int		use_deepest_state:1;
 +	RH_KABI_FILL_HOLE(unsigned int             poll_time_limit:1)
++=======
+ 	unsigned int		poll_time_limit:1;
++>>>>>>> c55b51a06b01 (cpuidle: Allow idle injection to apply exit latency limit)
  	unsigned int		cpu;
 -	ktime_t			next_hrtimer;
  
++<<<<<<< HEAD
 +	int			last_residency;
 +	RH_KABI_FILL_HOLE(int			last_state_idx)
++=======
+ 	int			last_state_idx;
+ 	u64			last_residency_ns;
+ 	u64			poll_limit_ns;
+ 	u64			forced_idle_latency_limit_ns;
++>>>>>>> c55b51a06b01 (cpuidle: Allow idle injection to apply exit latency limit)
  	struct cpuidle_state_usage	states_usage[CPUIDLE_STATE_MAX];
  	struct cpuidle_state_kobj *kobjs[CPUIDLE_STATE_MAX];
  	struct cpuidle_driver_kobj *kobj_driver;
diff --cc kernel/sched/idle.c
index b77157291d47,cd05ffa0abfe..000000000000
--- a/kernel/sched/idle.c
+++ b/kernel/sched/idle.c
@@@ -310,7 -311,7 +310,11 @@@ static enum hrtimer_restart idle_inject
  	return HRTIMER_NORESTART;
  }
  
++<<<<<<< HEAD
 +void play_idle(unsigned long duration_ms)
++=======
+ void play_idle_precise(u64 duration_ns, u64 latency_ns)
++>>>>>>> c55b51a06b01 (cpuidle: Allow idle injection to apply exit latency limit)
  {
  	struct idle_timer it;
  
@@@ -322,7 -323,7 +326,11 @@@
  	WARN_ON_ONCE(current->nr_cpus_allowed != 1);
  	WARN_ON_ONCE(!(current->flags & PF_KTHREAD));
  	WARN_ON_ONCE(!(current->flags & PF_NO_SETAFFINITY));
++<<<<<<< HEAD
 +	WARN_ON_ONCE(!duration_ms);
++=======
+ 	WARN_ON_ONCE(!duration_ns);
++>>>>>>> c55b51a06b01 (cpuidle: Allow idle injection to apply exit latency limit)
  
  	rcu_sleep_check();
  	preempt_disable();
@@@ -332,7 -333,8 +340,12 @@@
  	it.done = 0;
  	hrtimer_init_on_stack(&it.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
  	it.timer.function = idle_inject_timer_fn;
++<<<<<<< HEAD
 +	hrtimer_start(&it.timer, ms_to_ktime(duration_ms), HRTIMER_MODE_REL_PINNED);
++=======
+ 	hrtimer_start(&it.timer, ns_to_ktime(duration_ns),
+ 		      HRTIMER_MODE_REL_PINNED);
++>>>>>>> c55b51a06b01 (cpuidle: Allow idle injection to apply exit latency limit)
  
  	while (!READ_ONCE(it.done))
  		do_idle();
diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c
index 08b37025da09..c24c3345a114 100644
--- a/drivers/cpuidle/cpuidle.c
+++ b/drivers/cpuidle/cpuidle.c
@@ -99,20 +99,21 @@ static int find_deepest_state(struct cpuidle_driver *drv,
 }
 
 /**
- * cpuidle_use_deepest_state - Set/clear governor override flag.
- * @enable: New value of the flag.
+ * cpuidle_use_deepest_state - Set/unset governor override mode.
+ * @latency_limit_ns: Idle state exit latency limit (or no override if 0).
  *
- * Set/unset the current CPU to use the deepest idle state (override governors
- * going forward if set).
+ * If @latency_limit_ns is nonzero, set the current CPU to use the deepest idle
+ * state with exit latency within @latency_limit_ns (override governors going
+ * forward), or do not override governors if it is zero.
  */
-void cpuidle_use_deepest_state(bool enable)
+void cpuidle_use_deepest_state(u64 latency_limit_ns)
 {
 	struct cpuidle_device *dev;
 
 	preempt_disable();
 	dev = cpuidle_get_device();
 	if (dev)
-		dev->use_deepest_state = enable;
+		dev->forced_idle_latency_limit_ns = latency_limit_ns;
 	preempt_enable();
 }
 
* Unmerged path include/linux/cpu.h
* Unmerged path include/linux/cpuidle.h
* Unmerged path kernel/sched/idle.c
