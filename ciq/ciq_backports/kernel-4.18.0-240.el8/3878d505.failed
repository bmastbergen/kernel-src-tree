ima: Define ima-modsig template

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Thiago Jung Bauermann <bauerman@linux.ibm.com>
commit 3878d505aa718bcc7b1eb4089ab9b9fb27dee957
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/3878d505.failed

Define new "d-modsig" template field which holds the digest that is
expected to match the one contained in the modsig, and also new "modsig"
template field which holds the appended file signature.

Add a new "ima-modsig" defined template descriptor with the new fields as
well as the ones from the "ima-sig" descriptor.

Change ima_store_measurement() to accept a struct modsig * argument so that
it can be passed along to the templates via struct ima_event_data.

	Suggested-by: Mimi Zohar <zohar@linux.ibm.com>
	Signed-off-by: Thiago Jung Bauermann <bauerman@linux.ibm.com>
	Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>
(cherry picked from commit 3878d505aa718bcc7b1eb4089ab9b9fb27dee957)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/integrity/ima/ima.h
#	security/integrity/ima/ima_modsig.c
diff --cc security/integrity/ima/ima.h
index 837eb0799374,cfc8b0887776..000000000000
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@@ -306,11 -310,47 +307,53 @@@ static inline int ima_read_xattr(struc
  
  #ifdef CONFIG_IMA_APPRAISE_MODSIG
  bool ima_hook_supports_modsig(enum ima_hooks func);
++<<<<<<< HEAD
++=======
+ int ima_read_modsig(enum ima_hooks func, const void *buf, loff_t buf_len,
+ 		    struct modsig **modsig);
+ void ima_collect_modsig(struct modsig *modsig, const void *buf, loff_t size);
+ int ima_get_modsig_digest(const struct modsig *modsig, enum hash_algo *algo,
+ 			  const u8 **digest, u32 *digest_size);
+ int ima_get_raw_modsig(const struct modsig *modsig, const void **data,
+ 		       u32 *data_len);
+ void ima_free_modsig(struct modsig *modsig);
++>>>>>>> 3878d505aa71 (ima: Define ima-modsig template)
  #else
  static inline bool ima_hook_supports_modsig(enum ima_hooks func)
  {
  	return false;
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline int ima_read_modsig(enum ima_hooks func, const void *buf,
+ 				  loff_t buf_len, struct modsig **modsig)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline void ima_collect_modsig(struct modsig *modsig, const void *buf,
+ 				      loff_t size)
+ {
+ }
+ 
+ static inline int ima_get_modsig_digest(const struct modsig *modsig,
+ 					enum hash_algo *algo, const u8 **digest,
+ 					u32 *digest_size)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline int ima_get_raw_modsig(const struct modsig *modsig,
+ 				     const void **data, u32 *data_len)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline void ima_free_modsig(struct modsig *modsig)
+ {
+ }
++>>>>>>> 3878d505aa71 (ima: Define ima-modsig template)
  #endif /* CONFIG_IMA_APPRAISE_MODSIG */
  
  /* LSM based policy rules require audit */
diff --cc security/integrity/ima/ima_modsig.c
index 87503bfe8c8b,c412e31d1714..000000000000
--- a/security/integrity/ima/ima_modsig.c
+++ b/security/integrity/ima/ima_modsig.c
@@@ -29,3 -51,117 +29,120 @@@ bool ima_hook_supports_modsig(enum ima_
  		return false;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * ima_read_modsig - Read modsig from buf.
+  *
+  * Return: 0 on success, error code otherwise.
+  */
+ int ima_read_modsig(enum ima_hooks func, const void *buf, loff_t buf_len,
+ 		    struct modsig **modsig)
+ {
+ 	const size_t marker_len = strlen(MODULE_SIG_STRING);
+ 	const struct module_signature *sig;
+ 	struct modsig *hdr;
+ 	size_t sig_len;
+ 	const void *p;
+ 	int rc;
+ 
+ 	if (buf_len <= marker_len + sizeof(*sig))
+ 		return -ENOENT;
+ 
+ 	p = buf + buf_len - marker_len;
+ 	if (memcmp(p, MODULE_SIG_STRING, marker_len))
+ 		return -ENOENT;
+ 
+ 	buf_len -= marker_len;
+ 	sig = (const struct module_signature *)(p - sizeof(*sig));
+ 
+ 	rc = mod_check_sig(sig, buf_len, func_tokens[func]);
+ 	if (rc)
+ 		return rc;
+ 
+ 	sig_len = be32_to_cpu(sig->sig_len);
+ 	buf_len -= sig_len + sizeof(*sig);
+ 
+ 	/* Allocate sig_len additional bytes to hold the raw PKCS#7 data. */
+ 	hdr = kzalloc(sizeof(*hdr) + sig_len, GFP_KERNEL);
+ 	if (!hdr)
+ 		return -ENOMEM;
+ 
+ 	hdr->pkcs7_msg = pkcs7_parse_message(buf + buf_len, sig_len);
+ 	if (IS_ERR(hdr->pkcs7_msg)) {
+ 		kfree(hdr);
+ 		return PTR_ERR(hdr->pkcs7_msg);
+ 	}
+ 
+ 	memcpy(hdr->raw_pkcs7, buf + buf_len, sig_len);
+ 	hdr->raw_pkcs7_len = sig_len;
+ 
+ 	/* We don't know the hash algorithm yet. */
+ 	hdr->hash_algo = HASH_ALGO__LAST;
+ 
+ 	*modsig = hdr;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ima_collect_modsig - Calculate the file hash without the appended signature.
+  *
+  * Since the modsig is part of the file contents, the hash used in its signature
+  * isn't the same one ordinarily calculated by IMA. Therefore PKCS7 code
+  * calculates a separate one for signature verification.
+  */
+ void ima_collect_modsig(struct modsig *modsig, const void *buf, loff_t size)
+ {
+ 	int rc;
+ 
+ 	/*
+ 	 * Provide the file contents (minus the appended sig) so that the PKCS7
+ 	 * code can calculate the file hash.
+ 	 */
+ 	size -= modsig->raw_pkcs7_len + strlen(MODULE_SIG_STRING) +
+ 		sizeof(struct module_signature);
+ 	rc = pkcs7_supply_detached_data(modsig->pkcs7_msg, buf, size);
+ 	if (rc)
+ 		return;
+ 
+ 	/* Ask the PKCS7 code to calculate the file hash. */
+ 	rc = pkcs7_get_digest(modsig->pkcs7_msg, &modsig->digest,
+ 			      &modsig->digest_size, &modsig->hash_algo);
+ }
+ 
+ int ima_modsig_verify(struct key *keyring, const struct modsig *modsig)
+ {
+ 	return verify_pkcs7_message_sig(NULL, 0, modsig->pkcs7_msg, keyring,
+ 					VERIFYING_MODULE_SIGNATURE, NULL, NULL);
+ }
+ 
+ int ima_get_modsig_digest(const struct modsig *modsig, enum hash_algo *algo,
+ 			  const u8 **digest, u32 *digest_size)
+ {
+ 	*algo = modsig->hash_algo;
+ 	*digest = modsig->digest;
+ 	*digest_size = modsig->digest_size;
+ 
+ 	return 0;
+ }
+ 
+ int ima_get_raw_modsig(const struct modsig *modsig, const void **data,
+ 		       u32 *data_len)
+ {
+ 	*data = &modsig->raw_pkcs7;
+ 	*data_len = modsig->raw_pkcs7_len;
+ 
+ 	return 0;
+ }
+ 
+ void ima_free_modsig(struct modsig *modsig)
+ {
+ 	if (!modsig)
+ 		return;
+ 
+ 	pkcs7_free_message(modsig->pkcs7_msg);
+ 	kfree(modsig);
+ }
++>>>>>>> 3878d505aa71 (ima: Define ima-modsig template)
diff --git a/Documentation/security/IMA-templates.rst b/Documentation/security/IMA-templates.rst
index 3d1cca287aa4..c5a8432972ef 100644
--- a/Documentation/security/IMA-templates.rst
+++ b/Documentation/security/IMA-templates.rst
@@ -68,8 +68,10 @@ descriptors by adding their identifier to the format string
  - 'd-ng': the digest of the event, calculated with an arbitrary hash
    algorithm (field format: [<hash algo>:]digest, where the digest
    prefix is shown only if the hash algorithm is not SHA1 or MD5);
+ - 'd-modsig': the digest of the event without the appended modsig;
  - 'n-ng': the name of the event, without size limitations;
  - 'sig': the file signature;
+ - 'modsig' the appended file signature;
  - 'buf': the buffer data that was used to generate the hash without size limitations;
 
 
@@ -79,6 +81,7 @@ Below, there is the list of defined template descriptors:
  - "ima-ng" (default): its format is ``d-ng|n-ng``;
  - "ima-sig": its format is ``d-ng|n-ng|sig``;
  - "ima-buf": its format is ``d-ng|n-ng|buf``;
+ - "ima-modsig": its format is ``d-ng|n-ng|sig|d-modsig|modsig``;
 
 
 Use
* Unmerged path security/integrity/ima/ima.h
diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index d426d4d1fe04..6b0b9f017fec 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -289,7 +289,7 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 void ima_store_measurement(struct integrity_iint_cache *iint,
 			   struct file *file, const unsigned char *filename,
 			   struct evm_ima_xattr_data *xattr_value,
-			   int xattr_len, int pcr,
+			   int xattr_len, const struct modsig *modsig, int pcr,
 			   struct ima_template_desc *template_desc)
 {
 	static const char op[] = "add_template_measure";
@@ -301,7 +301,8 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 					     .file = file,
 					     .filename = filename,
 					     .xattr_value = xattr_value,
-					     .xattr_len = xattr_len };
+					     .xattr_len = xattr_len,
+					     .modsig = modsig };
 	int violation = 0;
 
 	if (iint->measured_pcrs & (0x1 << pcr))
diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index b7dd38fbfd04..0aa4d39a386d 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -292,7 +292,7 @@ static int process_measurement(struct file *file, const struct cred *cred,
 
 	if (action & IMA_MEASURE)
 		ima_store_measurement(iint, file, pathname,
-				      xattr_value, xattr_len, pcr,
+				      xattr_value, xattr_len, modsig, pcr,
 				      template_desc);
 	if (rc == 0 && (action & IMA_APPRAISE_SUBMASK)) {
 		inode_lock(inode);
* Unmerged path security/integrity/ima/ima_modsig.c
diff --git a/security/integrity/ima/ima_policy.c b/security/integrity/ima/ima_policy.c
index c09b6213c4c8..3c5df2973211 100644
--- a/security/integrity/ima/ima_policy.c
+++ b/security/integrity/ima/ima_policy.c
@@ -10,6 +10,9 @@
  *	- initialize default measure policy rules
  *
  */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/fs.h>
@@ -771,6 +774,38 @@ static void ima_log_string(struct audit_buffer *ab, char *key, char *value)
 	ima_log_string_op(ab, key, value, NULL);
 }
 
+/*
+ * Validating the appended signature included in the measurement list requires
+ * the file hash calculated without the appended signature (i.e., the 'd-modsig'
+ * field). Therefore, notify the user if they have the 'modsig' field but not
+ * the 'd-modsig' field in the template.
+ */
+static void check_template_modsig(const struct ima_template_desc *template)
+{
+#define MSG "template with 'modsig' field also needs 'd-modsig' field\n"
+	bool has_modsig, has_dmodsig;
+	static bool checked;
+	int i;
+
+	/* We only need to notify the user once. */
+	if (checked)
+		return;
+
+	has_modsig = has_dmodsig = false;
+	for (i = 0; i < template->num_fields; i++) {
+		if (!strcmp(template->fields[i]->field_id, "modsig"))
+			has_modsig = true;
+		else if (!strcmp(template->fields[i]->field_id, "d-modsig"))
+			has_dmodsig = true;
+	}
+
+	if (has_modsig && !has_dmodsig)
+		pr_notice(MSG);
+
+	checked = true;
+#undef MSG
+}
+
 static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 {
 	struct audit_buffer *ab;
@@ -1109,6 +1144,12 @@ static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 	else if (entry->action == APPRAISE)
 		temp_ima_appraise |= ima_appraise_flag(entry->func);
 
+	if (!result && entry->flags & IMA_MODSIG_ALLOWED) {
+		template_desc = entry->template ? entry->template :
+						  ima_template_desc_current();
+		check_template_modsig(template_desc);
+	}
+
 	audit_log_format(ab, "res=%d", !result);
 	audit_log_end(ab);
 	return result;
diff --git a/security/integrity/ima/ima_template.c b/security/integrity/ima/ima_template.c
index 7343e8e0ae2f..ac526b34973f 100644
--- a/security/integrity/ima/ima_template.c
+++ b/security/integrity/ima/ima_template.c
@@ -27,6 +27,7 @@ static struct ima_template_desc builtin_templates[] = {
 	{.name = "ima-ng", .fmt = "d-ng|n-ng"},
 	{.name = "ima-sig", .fmt = "d-ng|n-ng|sig"},
 	{.name = "ima-buf", .fmt = "d-ng|n-ng|buf"},
+	{.name = "ima-modsig", .fmt = "d-ng|n-ng|sig|d-modsig|modsig"},
 	{.name = "", .fmt = ""},	/* placeholder for a custom format */
 };
 
@@ -46,6 +47,10 @@ static const struct ima_template_field supported_fields[] = {
 	 .field_show = ima_show_template_sig},
 	{.field_id = "buf", .field_init = ima_eventbuf_init,
 	 .field_show = ima_show_template_buf},
+	{.field_id = "d-modsig", .field_init = ima_eventdigest_modsig_init,
+	 .field_show = ima_show_template_digest_ng},
+	{.field_id = "modsig", .field_init = ima_eventmodsig_init,
+	 .field_show = ima_show_template_sig},
 };
 
 /*
@@ -53,7 +58,7 @@ static const struct ima_template_field supported_fields[] = {
  * need to be accounted for since they shouldn't be defined in the same template
  * description as 'd-ng' and 'n-ng' respectively.
  */
-#define MAX_TEMPLATE_NAME_LEN sizeof("d-ng|n-ng|sig|buf")
+#define MAX_TEMPLATE_NAME_LEN sizeof("d-ng|n-ng|sig|buf|d-modisg|modsig")
 
 static struct ima_template_desc *ima_template;
 
diff --git a/security/integrity/ima/ima_template_lib.c b/security/integrity/ima/ima_template_lib.c
index b6852b020d9c..b809f1d767b7 100644
--- a/security/integrity/ima/ima_template_lib.c
+++ b/security/integrity/ima/ima_template_lib.c
@@ -228,7 +228,8 @@ int ima_parse_buf(void *bufstartp, void *bufendp, void **bufcurp,
 	return 0;
 }
 
-static int ima_eventdigest_init_common(u8 *digest, u32 digestsize, u8 hash_algo,
+static int ima_eventdigest_init_common(const u8 *digest, u32 digestsize,
+				       u8 hash_algo,
 				       struct ima_field_data *field_data)
 {
 	/*
@@ -331,6 +332,41 @@ int ima_eventdigest_ng_init(struct ima_event_data *event_data,
 					   hash_algo, field_data);
 }
 
+/*
+ * This function writes the digest of the file which is expected to match the
+ * digest contained in the file's appended signature.
+ */
+int ima_eventdigest_modsig_init(struct ima_event_data *event_data,
+				struct ima_field_data *field_data)
+{
+	enum hash_algo hash_algo;
+	const u8 *cur_digest;
+	u32 cur_digestsize;
+
+	if (!event_data->modsig)
+		return 0;
+
+	if (event_data->violation) {
+		/* Recording a violation. */
+		hash_algo = HASH_ALGO_SHA1;
+		cur_digest = NULL;
+		cur_digestsize = 0;
+	} else {
+		int rc;
+
+		rc = ima_get_modsig_digest(event_data->modsig, &hash_algo,
+					   &cur_digest, &cur_digestsize);
+		if (rc)
+			return rc;
+		else if (hash_algo == HASH_ALGO__LAST || cur_digestsize == 0)
+			/* There was some error collecting the digest. */
+			return -EINVAL;
+	}
+
+	return ima_eventdigest_init_common(cur_digest, cur_digestsize,
+					   hash_algo, field_data);
+}
+
 static int ima_eventname_init_common(struct ima_event_data *event_data,
 				     struct ima_field_data *field_data,
 				     bool size_limit)
@@ -409,3 +445,29 @@ int ima_eventbuf_init(struct ima_event_data *event_data,
 					     event_data->buf_len, DATA_FMT_HEX,
 					     field_data);
 }
+
+/*
+ *  ima_eventmodsig_init - include the appended file signature as part of the
+ *  template data
+ */
+int ima_eventmodsig_init(struct ima_event_data *event_data,
+			 struct ima_field_data *field_data)
+{
+	const void *data;
+	u32 data_len;
+	int rc;
+
+	if (!event_data->modsig)
+		return 0;
+
+	/*
+	 * modsig is a runtime structure containing pointers. Get its raw data
+	 * instead.
+	 */
+	rc = ima_get_raw_modsig(event_data->modsig, &data, &data_len);
+	if (rc)
+		return rc;
+
+	return ima_write_template_field_data(data, data_len, DATA_FMT_HEX,
+					     field_data);
+}
diff --git a/security/integrity/ima/ima_template_lib.h b/security/integrity/ima/ima_template_lib.h
index 12f1a8578b31..6544eac1c77d 100644
--- a/security/integrity/ima/ima_template_lib.h
+++ b/security/integrity/ima/ima_template_lib.h
@@ -40,10 +40,14 @@ int ima_eventname_init(struct ima_event_data *event_data,
 		       struct ima_field_data *field_data);
 int ima_eventdigest_ng_init(struct ima_event_data *event_data,
 			    struct ima_field_data *field_data);
+int ima_eventdigest_modsig_init(struct ima_event_data *event_data,
+				struct ima_field_data *field_data);
 int ima_eventname_ng_init(struct ima_event_data *event_data,
 			  struct ima_field_data *field_data);
 int ima_eventsig_init(struct ima_event_data *event_data,
 		      struct ima_field_data *field_data);
 int ima_eventbuf_init(struct ima_event_data *event_data,
 		      struct ima_field_data *field_data);
+int ima_eventmodsig_init(struct ima_event_data *event_data,
+			 struct ima_field_data *field_data);
 #endif /* __LINUX_IMA_TEMPLATE_LIB_H */
