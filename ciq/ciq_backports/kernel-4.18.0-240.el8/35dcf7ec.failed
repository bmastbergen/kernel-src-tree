net/smc: remember PNETID of IB device for later device matching

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Karsten Graul <kgraul@linux.ibm.com>
commit 35dcf7ec02dcff16504bc52a368822254f889f00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/35dcf7ec.failed

The PNETID is needed to find an alternate link for a link group.
Save the PNETID of the link that is used to create the link group for
later device matching.

	Signed-off-by: Karsten Graul <kgraul@linux.ibm.com>
	Reviewed-by: Ursula Braun <ubraun@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 35dcf7ec02dcff16504bc52a368822254f889f00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/smc/smc_core.c
#	net/smc/smc_core.h
diff --cc net/smc/smc_core.c
index 8d7f08e469be,d7ab92fc5b15..000000000000
--- a/net/smc/smc_core.c
+++ b/net/smc/smc_core.c
@@@ -409,6 -413,9 +409,12 @@@ static int smc_lgr_create(struct smc_so
  		lgr->role = smc->listen_smc ? SMC_SERV : SMC_CLNT;
  		memcpy(lgr->peer_systemid, ini->ib_lcl->id_for_peer,
  		       SMC_SYSTEMID_LEN);
++<<<<<<< HEAD
++=======
+ 		memcpy(lgr->pnet_id, ini->ib_dev->pnetid[ini->ib_port - 1],
+ 		       SMC_MAX_PNETID_LEN);
+ 		smc_llc_lgr_init(lgr, smc);
++>>>>>>> 35dcf7ec02dc (net/smc: remember PNETID of IB device for later device matching)
  
  		link_idx = SMC_SINGLE_LINK;
  		lnk = &lgr->lnk[link_idx];
diff --cc net/smc/smc_core.h
index dbb7446cbf6a,413eaad50c7f..000000000000
--- a/net/smc/smc_core.h
+++ b/net/smc/smc_core.h
@@@ -232,6 -242,30 +232,33 @@@ struct smc_link_group 
  			DECLARE_BITMAP(rtokens_used_mask, SMC_RMBS_PER_LGR_MAX);
  						/* used rtoken elements */
  			u8			next_link_id;
++<<<<<<< HEAD
++=======
+ 			enum smc_lgr_type	type;
+ 						/* redundancy state */
+ 			u8			pnet_id[SMC_MAX_PNETID_LEN + 1];
+ 						/* pnet id of this lgr */
+ 			struct list_head	llc_event_q;
+ 						/* queue for llc events */
+ 			spinlock_t		llc_event_q_lock;
+ 						/* protects llc_event_q */
+ 			struct mutex		llc_conf_mutex;
+ 						/* protects lgr reconfig. */
+ 			struct work_struct	llc_event_work;
+ 						/* llc event worker */
+ 			wait_queue_head_t	llc_waiter;
+ 						/* w4 next llc event */
+ 			struct smc_llc_flow	llc_flow_lcl;
+ 						/* llc local control field */
+ 			struct smc_llc_flow	llc_flow_rmt;
+ 						/* llc remote control field */
+ 			struct smc_llc_qentry	*delayed_event;
+ 						/* arrived when flow active */
+ 			spinlock_t		llc_flow_lock;
+ 						/* protects llc flow */
+ 			int			llc_testlink_time;
+ 						/* link keep alive time */
++>>>>>>> 35dcf7ec02dc (net/smc: remember PNETID of IB device for later device matching)
  		};
  		struct { /* SMC-D */
  			u64			peer_gid;
* Unmerged path net/smc/smc_core.c
* Unmerged path net/smc/smc_core.h
