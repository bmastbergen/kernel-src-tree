drm/i915: do AUD_FREQ_CNTRL state save on all gen9+ platforms

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Kai Vehmanen <kai.vehmanen@linux.intel.com>
commit f26f1db5d2be446324140ec096cc9a31e7e7c891
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f26f1db5.failed

Replace the TGL/ICL specific platform checks with a more generic check
using INTEL_GEN(). Fixes bug with broken audio after S3 resume on JSL
platforms.

An initial version of state save and restore of AUD_FREQ_CNTRL register
was added for subset of platforms in commit 87c1694533c9
("drm/i915: save AUD_FREQ_CNTRL state at audio domain suspend"). The state
save has proven to work well and it is needed in newer platforms, so needs
to be extended. Although the logic is not in practise needed on GEN9/10
systems, follow the hardware specification and apply state and restore on
all gen9+ platforms.

Bspec: 49281
Link: https://github.com/thesofproject/linux/issues/1719
	Signed-off-by: Kai Vehmanen <kai.vehmanen@linux.intel.com>
	Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200330144421.11632-1-kai.vehmanen@linux.intel.com
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
(cherry picked from commit f26f1db5d2be446324140ec096cc9a31e7e7c891)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_audio.c
diff --cc drivers/gpu/drm/i915/display/intel_audio.c
index 8119e0d36d13,57b80971ae78..000000000000
--- a/drivers/gpu/drm/i915/display/intel_audio.c
+++ b/drivers/gpu/drm/i915/display/intel_audio.c
@@@ -795,11 -892,24 +795,25 @@@ static unsigned long i915_audio_compone
  
  	ret = intel_display_power_get(dev_priv, POWER_DOMAIN_AUDIO);
  
++<<<<<<< HEAD
 +	/* Force CDCLK to 2*BCLK as long as we need audio to be powered. */
 +	if (dev_priv->audio_power_refcount++ == 0)
 +		if (IS_CANNONLAKE(dev_priv) || IS_GEMINILAKE(dev_priv))
++=======
+ 	if (dev_priv->audio_power_refcount++ == 0) {
+ 		if (INTEL_GEN(dev_priv) >= 9) {
+ 			intel_de_write(dev_priv, AUD_FREQ_CNTRL,
+ 				       dev_priv->audio_freq_cntrl);
+ 			drm_dbg_kms(&dev_priv->drm,
+ 				    "restored AUD_FREQ_CNTRL to 0x%x\n",
+ 				    dev_priv->audio_freq_cntrl);
+ 		}
+ 
+ 		/* Force CDCLK to 2*BCLK as long as we need audio powered. */
+ 		if (IS_GEMINILAKE(dev_priv))
++>>>>>>> f26f1db5d2be (drm/i915: do AUD_FREQ_CNTRL state save on all gen9+ platforms)
  			glk_force_audio_cdclk(dev_priv, true);
  
 -		if (INTEL_GEN(dev_priv) >= 10 || IS_GEMINILAKE(dev_priv))
 -			intel_de_write(dev_priv, AUD_PIN_BUF_CTL,
 -				       (intel_de_read(dev_priv, AUD_PIN_BUF_CTL) | AUD_PIN_BUF_ENABLE));
 -	}
 -
  	return ret;
  }
  
@@@ -1059,6 -1175,14 +1073,17 @@@ static void i915_audio_component_init(s
  		return;
  	}
  
++<<<<<<< HEAD
++=======
+ 	if (INTEL_GEN(dev_priv) >= 9) {
+ 		dev_priv->audio_freq_cntrl = intel_de_read(dev_priv,
+ 							   AUD_FREQ_CNTRL);
+ 		drm_dbg_kms(&dev_priv->drm,
+ 			    "init value of AUD_FREQ_CNTRL of 0x%x\n",
+ 			    dev_priv->audio_freq_cntrl);
+ 	}
+ 
++>>>>>>> f26f1db5d2be (drm/i915: do AUD_FREQ_CNTRL state save on all gen9+ platforms)
  	dev_priv->audio_component_registered = true;
  }
  
* Unmerged path drivers/gpu/drm/i915/display/intel_audio.c
