netfilter: flowtable: set NF_FLOW_TEARDOWN flag on entry expiration

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 9ed81c8e0deb7bd2aa0d69371e4a0f9a7b31205d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9ed81c8e.failed

If the flow timer expires, the gc sets on the NF_FLOW_TEARDOWN flag.
Otherwise, the flowtable software path might race to refresh the
timeout, leaving the state machine in inconsistent state.

Fixes: c29f74e0df7a ("netfilter: nf_flow_table: hardware offload support")
	Reported-by: Paul Blakey <paulb@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 9ed81c8e0deb7bd2aa0d69371e4a0f9a7b31205d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_flow_table_core.c
diff --cc net/netfilter/nf_flow_table_core.c
index b5916ad46e76,42da6e337276..000000000000
--- a/net/netfilter/nf_flow_table_core.c
+++ b/net/netfilter/nf_flow_table_core.c
@@@ -271,7 -284,7 +271,11 @@@ static void flow_offload_del(struct nf_
  
  	if (nf_flow_has_expired(flow))
  		flow_offload_fixup_ct(flow->ct);
++<<<<<<< HEAD
 +	else if (flow->flags & FLOW_OFFLOAD_TEARDOWN)
++=======
+ 	else
++>>>>>>> 9ed81c8e0deb (netfilter: flowtable: set NF_FLOW_TEARDOWN flag on entry expiration)
  		flow_offload_fixup_ct_timeout(flow->ct);
  
  	flow_offload_free(flow);
@@@ -348,9 -361,21 +352,27 @@@ static void nf_flow_offload_gc_step(str
  {
  	struct nf_flowtable *flow_table = data;
  
++<<<<<<< HEAD
 +	if (nf_flow_has_expired(flow) || nf_ct_is_dying(flow->ct) ||
 +	    (flow->flags & (FLOW_OFFLOAD_DYING | FLOW_OFFLOAD_TEARDOWN)))
 +		flow_offload_del(flow_table, flow);
++=======
+ 	if (nf_flow_has_expired(flow) || nf_ct_is_dying(flow->ct))
+ 		set_bit(NF_FLOW_TEARDOWN, &flow->flags);
+ 
+ 	if (test_bit(NF_FLOW_TEARDOWN, &flow->flags)) {
+ 		if (test_bit(NF_FLOW_HW, &flow->flags)) {
+ 			if (!test_bit(NF_FLOW_HW_DYING, &flow->flags))
+ 				nf_flow_offload_del(flow_table, flow);
+ 			else if (test_bit(NF_FLOW_HW_DEAD, &flow->flags))
+ 				flow_offload_del(flow_table, flow);
+ 		} else {
+ 			flow_offload_del(flow_table, flow);
+ 		}
+ 	} else if (test_bit(NF_FLOW_HW, &flow->flags)) {
+ 		nf_flow_offload_stats(flow_table, flow);
+ 	}
++>>>>>>> 9ed81c8e0deb (netfilter: flowtable: set NF_FLOW_TEARDOWN flag on entry expiration)
  }
  
  static void nf_flow_offload_work_gc(struct work_struct *work)
* Unmerged path net/netfilter/nf_flow_table_core.c
