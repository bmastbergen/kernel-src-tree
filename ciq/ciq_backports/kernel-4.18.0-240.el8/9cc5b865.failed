isolcpus: Affine unbound kernel threads to housekeeping cpus

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Marcelo Tosatti <mtosatti@redhat.com>
commit 9cc5b8656892a72438ee7deb5e80f5be47643b8b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9cc5b865.failed

This is a kernel enhancement that configures the cpu affinity of kernel
threads via kernel boot option nohz_full=.

When this option is specified, the cpumask is immediately applied upon
kthread launch. This does not affect kernel threads that specify cpu
and node.

This allows CPU isolation (that is not allowing certain threads
to execute on certain CPUs) without using the isolcpus=domain parameter,
making it possible to enable load balancing on such CPUs
during runtime (see kernel-parameters.txt).

Note-1: this is based off on Wind River's patch at
https://github.com/starlingx-staging/stx-integ/blob/master/kernel/kernel-std/centos/patches/affine-compute-kernel-threads.patch

Difference being that this patch is limited to modifying kernel thread
cpumask. Behaviour of other threads can be controlled via cgroups or
sched_setaffinity.

Note-2: Wind River's patch was based off Christoph Lameter's patch at
https://lwn.net/Articles/565932/ with the only difference being
the kernel parameter changed from kthread to kthread_cpus.

	Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
	Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20200527142909.23372-3-frederic@kernel.org
(cherry picked from commit 9cc5b8656892a72438ee7deb5e80f5be47643b8b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/kthread.c
diff --cc kernel/kthread.c
index 780f075cb1a5,032b610912b0..000000000000
--- a/kernel/kthread.c
+++ b/kernel/kthread.c
@@@ -21,8 -26,11 +21,13 @@@
  #include <linux/freezer.h>
  #include <linux/ptrace.h>
  #include <linux/uaccess.h>
++<<<<<<< HEAD
++=======
+ #include <linux/numa.h>
+ #include <linux/sched/isolation.h>
++>>>>>>> 9cc5b8656892 (isolcpus: Affine unbound kernel threads to housekeeping cpus)
  #include <trace/events/sched.h>
  
 -
  static DEFINE_SPINLOCK(kthread_create_lock);
  static LIST_HEAD(kthread_create_list);
  struct task_struct *kthreadd_task;
diff --git a/include/linux/sched/isolation.h b/include/linux/sched/isolation.h
index 461e1f6ab3eb..dfffbc98a63f 100644
--- a/include/linux/sched/isolation.h
+++ b/include/linux/sched/isolation.h
@@ -14,6 +14,7 @@ enum hk_flags {
 	HK_FLAG_DOMAIN		= (1 << 5),
 	HK_FLAG_WQ		= (1 << 6),
 	HK_FLAG_MANAGED_IRQ	= (1 << 7),
+	HK_FLAG_KTHREAD		= (1 << 8),
 };
 
 #ifdef CONFIG_CPU_ISOLATION
* Unmerged path kernel/kthread.c
diff --git a/kernel/sched/isolation.c b/kernel/sched/isolation.c
index f4ecd714265d..e02a43386575 100644
--- a/kernel/sched/isolation.c
+++ b/kernel/sched/isolation.c
@@ -131,7 +131,8 @@ static int __init housekeeping_nohz_full_setup(char *str)
 {
 	unsigned int flags;
 
-	flags = HK_FLAG_TICK | HK_FLAG_WQ | HK_FLAG_TIMER | HK_FLAG_RCU | HK_FLAG_MISC;
+	flags = HK_FLAG_TICK | HK_FLAG_WQ | HK_FLAG_TIMER | HK_FLAG_RCU |
+		HK_FLAG_MISC | HK_FLAG_KTHREAD;
 
 	return housekeeping_setup(str, flags);
 }
