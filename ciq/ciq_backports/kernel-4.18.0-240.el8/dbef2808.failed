KVM: VMX: fix crash cleanup when KVM wasn't used

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit dbef2808af6c594922fe32833b30f55f35e9da6d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dbef2808.failed

If KVM wasn't used at all before we crash the cleanup procedure fails with
 BUG: unable to handle page fault for address: ffffffffffffffc8
 #PF: supervisor read access in kernel mode
 #PF: error_code(0x0000) - not-present page
 PGD 23215067 P4D 23215067 PUD 23217067 PMD 0
 Oops: 0000 [#8] SMP PTI
 CPU: 0 PID: 3542 Comm: bash Kdump: loaded Tainted: G      D           5.6.0-rc2+ #823
 RIP: 0010:crash_vmclear_local_loaded_vmcss.cold+0x19/0x51 [kvm_intel]

The root cause is that loaded_vmcss_on_cpu list is not yet initialized,
we initialize it in hardware_enable() but this only happens when we start
a VM.

Previously, we used to have a bitmap with enabled CPUs and that was
preventing [masking] the issue.

Initialized loaded_vmcss_on_cpu list earlier, right before we assign
crash_vmclear_loaded_vmcss pointer. blocked_vcpu_on_cpu list and
blocked_vcpu_on_cpu_lock are moved altogether for consistency.

Fixes: 31603d4fc2bb ("KVM: VMX: Always VMCLEAR in-use VMCSes during crash with kexec support")
	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Message-Id: <20200401081348.1345307-1-vkuznets@redhat.com>
	Reviewed-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit dbef2808af6c594922fe32833b30f55f35e9da6d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index 833b3f7d7961,8959514eaf0f..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -2331,33 -2261,10 +2331,39 @@@ static int hardware_enable(void
  	    !hv_get_vp_assist_page(cpu))
  		return -EFAULT;
  
++<<<<<<< HEAD
 +	INIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));
 +	INIT_LIST_HEAD(&per_cpu(blocked_vcpu_on_cpu, cpu));
 +	spin_lock_init(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));
 +
 +	/*
 +	 * Now we can enable the vmclear operation in kdump
 +	 * since the loaded_vmcss_on_cpu list on this cpu
 +	 * has been initialized.
 +	 *
 +	 * Though the cpu is not in VMX operation now, there
 +	 * is no problem to enable the vmclear operation
 +	 * for the loaded_vmcss_on_cpu list is empty!
 +	 */
 +	crash_enable_local_vmclear(cpu);
++=======
+ 	r = kvm_cpu_vmxon(phys_addr);
+ 	if (r)
+ 		return r;
++>>>>>>> dbef2808af6c (KVM: VMX: fix crash cleanup when KVM wasn't used)
  
 +	rdmsrl(MSR_IA32_FEATURE_CONTROL, old);
 +
 +	test_bits = FEATURE_CONTROL_LOCKED;
 +	test_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;
 +	if (tboot_enabled())
 +		test_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;
 +
 +	if ((old & test_bits) != test_bits) {
 +		/* enable and lock */
 +		wrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);
 +	}
 +	kvm_cpu_vmxon(phys_addr);
  	if (enable_ept)
  		ept_sync_global();
  
* Unmerged path arch/x86/kvm/vmx/vmx.c
