selftests/bpf: Add BPF skeletons selftests and convert attach_probe.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit f3c926a4df2cddf6230c3f56b1f43e439552cdad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f3c926a4.failed

Add BPF skeleton generation to selftest/bpf's Makefile. Convert attach_probe.c
to use skeleton.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
Link: https://lore.kernel.org/bpf/20191214014341.3442258-15-andriin@fb.com
(cherry picked from commit f3c926a4df2cddf6230c3f56b1f43e439552cdad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/.gitignore
#	tools/testing/selftests/bpf/Makefile
#	tools/testing/selftests/bpf/prog_tests/attach_probe.c
diff --cc tools/testing/selftests/bpf/.gitignore
index f9d8aed126b8,ce5af95ede42..000000000000
--- a/tools/testing/selftests/bpf/.gitignore
+++ b/tools/testing/selftests/bpf/.gitignore
@@@ -21,5 -21,24 +21,26 @@@ test_lirc_mode2_use
  get_cgroup_id_user
  test_skb_cgroup_id_user
  test_socket_cookie
 -test_cgroup_attach
  test_cgroup_storage
  test_select_reuseport
++<<<<<<< HEAD
++=======
+ test_flow_dissector
+ flow_dissector_load
+ test_netcnt
+ test_section_names
+ test_tcpnotify_user
+ test_libbpf
+ test_tcp_check_syncookie_user
+ test_sysctl
+ libbpf.pc
+ libbpf.so.*
+ test_hashmap
+ test_btf_dump
+ xdping
+ test_cpp
+ *.skel.h
+ /no_alu32
+ /bpf_gcc
+ /tools
++>>>>>>> f3c926a4df2c (selftests/bpf: Add BPF skeletons selftests and convert attach_probe.c)
diff --cc tools/testing/selftests/bpf/Makefile
index 1739bffedc44,f70c8e735120..000000000000
--- a/tools/testing/selftests/bpf/Makefile
+++ b/tools/testing/selftests/bpf/Makefile
@@@ -2,10 -2,14 +2,21 @@@
  include ../../../../scripts/Kbuild.include
  include ../../../scripts/Makefile.arch
  
++<<<<<<< HEAD
 +LIBDIR := ../../../lib
 +BPFDIR := $(LIBDIR)/bpf
 +APIDIR := ../../../include/uapi
 +GENDIR := ../../../../include/generated
++=======
+ CURDIR := $(abspath .)
+ TOOLSDIR := $(abspath ../../..)
+ LIBDIR := $(TOOLSDIR)/lib
+ BPFDIR := $(LIBDIR)/bpf
+ TOOLSINCDIR := $(TOOLSDIR)/include
+ BPFTOOLDIR := $(TOOLSDIR)/bpf/bpftool
+ APIDIR := $(TOOLSINCDIR)/uapi
+ GENDIR := $(abspath ../../../../include/generated)
++>>>>>>> f3c926a4df2c (selftests/bpf: Add BPF skeletons selftests and convert attach_probe.c)
  GENHDR := $(GENDIR)/autoconf.h
  
  ifneq ($(wildcard $(GENHDR)),)
@@@ -16,8 -20,9 +27,14 @@@ CLANG		?= clan
  LLC		?= llc
  LLVM_OBJCOPY	?= llvm-objcopy
  BPF_GCC		?= $(shell command -v bpf-gcc;)
++<<<<<<< HEAD
 +CFLAGS += -g -Wall -O2 -I$(APIDIR) -I$(LIBDIR) -I$(BPFDIR) -I$(GENDIR) $(GENFLAGS) -I../../../include \
 +	  -Dbpf_prog_load=bpf_prog_test_load \
++=======
+ CFLAGS += -g -Wall -O2 $(GENFLAGS) -I$(APIDIR) -I$(LIBDIR) -I$(BPFDIR)	\
+ 	  -I$(GENDIR) -I$(TOOLSINCDIR) -I$(CURDIR)			\
+ 	  -Dbpf_prog_load=bpf_prog_test_load				\
++>>>>>>> f3c926a4df2c (selftests/bpf: Add BPF skeletons selftests and convert attach_probe.c)
  	  -Dbpf_load_program=bpf_test_load_program
  LDLIBS += -lcap -lelf -lrt -lpthread
  
@@@ -160,127 -160,187 +183,243 @@@ $(OUTPUT)/test_l4lb_noinline.o: BPF_CFL
  $(OUTPUT)/test_xdp_noinline.o: BPF_CFLAGS += -fno-inline
  
  $(OUTPUT)/flow_dissector_load.o: flow_dissector_load.h
 -
 -# Build BPF object using Clang
 -# $1 - input .c file
 -# $2 - output .o file
 -# $3 - CFLAGS
 -# $4 - LDFLAGS
 -define CLANG_BPF_BUILD_RULE
 -	($(CLANG) $3 -O2 -target bpf -emit-llvm				\
 -		-c $1 -o - || echo "BPF obj compilation failed") | 	\
 -	$(LLC) -mattr=dwarfris -march=bpf -mcpu=probe $4 -filetype=obj -o $2
 -endef
 -# Similar to CLANG_BPF_BUILD_RULE, but with disabled alu32
 -define CLANG_NOALU32_BPF_BUILD_RULE
 -	($(CLANG) $3 -O2 -target bpf -emit-llvm				\
 -		-c $1 -o - || echo "BPF obj compilation failed") | 	\
 -	$(LLC) -march=bpf -mcpu=v2 $4 -filetype=obj -o $2
 -endef
 -# Similar to CLANG_BPF_BUILD_RULE, but using native Clang and bpf LLC
 -define CLANG_NATIVE_BPF_BUILD_RULE
 -	($(CLANG) $3 -O2 -emit-llvm					\
 -		-c $1 -o - || echo "BPF obj compilation failed") | 	\
 -	$(LLC) -march=bpf -mcpu=probe $4 -filetype=obj -o $2
 -endef
 -# Build BPF object using GCC
 -define GCC_BPF_BUILD_RULE
 -	$(BPF_GCC) $3 $4 -O2 -c $1 -o $2
 -endef
 -
 +$(OUTPUT)/test_progs.o: flow_dissector_load.h
 +
 +TEST_PROGS_CFLAGS := -I. -I$(OUTPUT)
 +TEST_MAPS_CFLAGS := -I. -I$(OUTPUT)
 +TEST_VERIFIER_CFLAGS := -I. -I$(OUTPUT) -Iverifier
 +
++<<<<<<< HEAD
 +ifneq ($(SUBREG_CODEGEN),)
 +ALU32_BUILD_DIR = $(OUTPUT)/alu32
 +TEST_CUSTOM_PROGS += $(ALU32_BUILD_DIR)/test_progs_32
 +$(ALU32_BUILD_DIR):
 +	mkdir -p $@
 +
 +$(ALU32_BUILD_DIR)/urandom_read: $(OUTPUT)/urandom_read | $(ALU32_BUILD_DIR)
 +	cp $< $@
++=======
+ SKEL_BLACKLIST := btf__% test_pinning_invalid.c
+ 
+ # Set up extra TRUNNER_XXX "temporary" variables in the environment (relies on
+ # $eval()) and pass control to DEFINE_TEST_RUNNER_RULES.
+ # Parameters:
+ # $1 - test runner base binary name (e.g., test_progs)
+ # $2 - test runner extra "flavor" (e.g., no_alu32, gcc-bpf, etc)
+ define DEFINE_TEST_RUNNER
+ 
+ TRUNNER_OUTPUT := $(OUTPUT)$(if $2,/)$2
+ TRUNNER_BINARY := $1$(if $2,-)$2
+ TRUNNER_TEST_OBJS := $$(patsubst %.c,$$(TRUNNER_OUTPUT)/%.test.o,	\
+ 				 $$(notdir $$(wildcard $(TRUNNER_TESTS_DIR)/*.c)))
+ TRUNNER_EXTRA_OBJS := $$(patsubst %.c,$$(TRUNNER_OUTPUT)/%.o,		\
+ 				 $$(filter %.c,$(TRUNNER_EXTRA_SOURCES)))
+ TRUNNER_EXTRA_HDRS := $$(filter %.h,$(TRUNNER_EXTRA_SOURCES))
+ TRUNNER_TESTS_HDR := $(TRUNNER_TESTS_DIR)/tests.h
+ TRUNNER_BPF_SRCS := $$(notdir $$(wildcard $(TRUNNER_BPF_PROGS_DIR)/*.c))
+ TRUNNER_BPF_OBJS := $$(patsubst %.c,$$(TRUNNER_OUTPUT)/%.o, $$(TRUNNER_BPF_SRCS))
+ TRUNNER_BPF_SKELS := $$(patsubst %.c,$$(TRUNNER_OUTPUT)/%.skel.h,	\
+ 				 $$(filter-out $(SKEL_BLACKLIST),	\
+ 					       $$(TRUNNER_BPF_SRCS)))
 -
 -# Evaluate rules now with extra TRUNNER_XXX variables above already defined
 -$$(eval $$(call DEFINE_TEST_RUNNER_RULES,$1,$2))
 -
 -endef
 -
 -# Using TRUNNER_XXX variables, provided by callers of DEFINE_TEST_RUNNER and
 -# set up by DEFINE_TEST_RUNNER itself, create test runner build rules with:
 -# $1 - test runner base binary name (e.g., test_progs)
 -# $2 - test runner extra "flavor" (e.g., no_alu32, gcc-bpf, etc)
 -define DEFINE_TEST_RUNNER_RULES
 -
 -ifeq ($($(TRUNNER_OUTPUT)-dir),)
 -$(TRUNNER_OUTPUT)-dir := y
 -$(TRUNNER_OUTPUT):
 -	mkdir -p $$@
++>>>>>>> f3c926a4df2c (selftests/bpf: Add BPF skeletons selftests and convert attach_probe.c)
 +
 +$(ALU32_BUILD_DIR)/test_progs_32: test_progs.c $(OUTPUT)/libbpf.a\
 +						$(ALU32_BUILD_DIR)/urandom_read \
 +						| $(ALU32_BUILD_DIR)
 +	$(CC) $(TEST_PROGS_CFLAGS) $(CFLAGS) \
 +		-o $(ALU32_BUILD_DIR)/test_progs_32 \
 +		test_progs.c test_stub.c trace_helpers.c prog_tests/*.c \
 +		$(OUTPUT)/libbpf.a $(LDLIBS)
 +
 +$(ALU32_BUILD_DIR)/test_progs_32: $(PROG_TESTS_H)
 +$(ALU32_BUILD_DIR)/test_progs_32: prog_tests/*.c
 +
 +$(ALU32_BUILD_DIR)/%.o: progs/%.c $(ALU32_BUILD_DIR)/test_progs_32 \
 +					| $(ALU32_BUILD_DIR)
 +	($(CLANG) $(BPF_CFLAGS) $(CLANG_CFLAGS) -O2 -target bpf -emit-llvm \
 +		-c $< -o - || echo "clang failed") | \
 +	$(LLC) -march=bpf -mcpu=probe -mattr=+alu32 $(LLC_FLAGS) \
 +		-filetype=obj -o $@
  endif
  
++<<<<<<< HEAD
++=======
+ # ensure we set up BPF objects generation rule just once for a given
+ # input/output directory combination
+ ifeq ($($(TRUNNER_BPF_PROGS_DIR)$(if $2,-)$2-bpfobjs),)
+ $(TRUNNER_BPF_PROGS_DIR)$(if $2,-)$2-bpfobjs := y
+ $(TRUNNER_BPF_OBJS): $(TRUNNER_OUTPUT)/%.o:				\
+ 		     $(TRUNNER_BPF_PROGS_DIR)/%.c			\
+ 		     $(TRUNNER_BPF_PROGS_DIR)/*.h			\
+ 		     $$(BPF_HELPERS) | $(TRUNNER_OUTPUT)
+ 	$$(call $(TRUNNER_BPF_BUILD_RULE),$$<,$$@,			\
+ 					  $(TRUNNER_BPF_CFLAGS),	\
+ 					  $(TRUNNER_BPF_LDFLAGS))
+ 
+ $(TRUNNER_BPF_SKELS): $(TRUNNER_OUTPUT)/%.skel.h:			\
+ 		      $(TRUNNER_OUTPUT)/%.o				\
+ 		      | $(BPFTOOL) $(TRUNNER_OUTPUT)
+ 	$$(BPFTOOL) gen skeleton $$< > $$@
+ endif
+ 
+ # ensure we set up tests.h header generation rule just once
+ ifeq ($($(TRUNNER_TESTS_DIR)-tests-hdr),)
+ $(TRUNNER_TESTS_DIR)-tests-hdr := y
+ $(TRUNNER_TESTS_HDR): $(TRUNNER_TESTS_DIR)/*.c
+ 	$$(shell ( cd $(TRUNNER_TESTS_DIR);				\
+ 		  echo '/* Generated header, do not edit */';		\
+ 		  ls *.c 2> /dev/null |					\
+ 			sed -e 's@\([^\.]*\)\.c@DEFINE_TEST(\1)@';	\
+ 		 ) > $$@)
+ endif
+ 
+ # compile individual test files
+ # Note: we cd into output directory to ensure embedded BPF object is found
+ $(TRUNNER_TEST_OBJS): $(TRUNNER_OUTPUT)/%.test.o:			\
+ 		      $(TRUNNER_TESTS_DIR)/%.c				\
+ 		      $(TRUNNER_EXTRA_HDRS)				\
+ 		      $(TRUNNER_BPF_OBJS)				\
+ 		      $(TRUNNER_BPF_SKELS)				\
+ 		      $$(BPFOBJ) | $(TRUNNER_OUTPUT)
+ 	cd $$(@D) && $$(CC) $$(CFLAGS) -c $(CURDIR)/$$< $$(LDLIBS) -o $$(@F)
+ 
+ $(TRUNNER_EXTRA_OBJS): $(TRUNNER_OUTPUT)/%.o:				\
+ 		       %.c						\
+ 		       $(TRUNNER_EXTRA_HDRS)				\
+ 		       $(TRUNNER_TESTS_HDR)				\
+ 		       $$(BPFOBJ) | $(TRUNNER_OUTPUT)
+ 	$$(CC) $$(CFLAGS) -c $$< $$(LDLIBS) -o $$@
+ 
+ # only copy extra resources if in flavored build
+ $(TRUNNER_BINARY)-extras: $(TRUNNER_EXTRA_FILES) | $(TRUNNER_OUTPUT)
+ ifneq ($2,)
+ 	cp -a $$^ $(TRUNNER_OUTPUT)/
+ endif
+ 
+ $(OUTPUT)/$(TRUNNER_BINARY): $(TRUNNER_TEST_OBJS)			\
+ 			     $(TRUNNER_EXTRA_OBJS) $$(BPFOBJ)		\
+ 			     | $(TRUNNER_BINARY)-extras
+ 	$$(CC) $$(CFLAGS) $$(filter %.a %.o,$$^) $$(LDLIBS) -o $$@
+ 
+ endef
+ 
+ # Define test_progs test runner.
+ TRUNNER_TESTS_DIR := prog_tests
+ TRUNNER_BPF_PROGS_DIR := progs
+ TRUNNER_EXTRA_SOURCES := test_progs.c cgroup_helpers.c trace_helpers.c	\
+ 			 flow_dissector_load.h
+ TRUNNER_EXTRA_FILES := $(OUTPUT)/urandom_read				\
+ 		       $(wildcard progs/btf_dump_test_case_*.c)
+ TRUNNER_BPF_BUILD_RULE := CLANG_BPF_BUILD_RULE
+ TRUNNER_BPF_CFLAGS := -I. -I$(OUTPUT) $(BPF_CFLAGS) $(CLANG_CFLAGS)
+ TRUNNER_BPF_LDFLAGS := -mattr=+alu32
+ $(eval $(call DEFINE_TEST_RUNNER,test_progs))
+ 
+ # Define test_progs-no_alu32 test runner.
+ TRUNNER_BPF_BUILD_RULE := CLANG_NOALU32_BPF_BUILD_RULE
+ TRUNNER_BPF_LDFLAGS :=
+ $(eval $(call DEFINE_TEST_RUNNER,test_progs,no_alu32))
+ 
+ # Define test_progs BPF-GCC-flavored test runner.
++>>>>>>> f3c926a4df2c (selftests/bpf: Add BPF skeletons selftests and convert attach_probe.c)
  ifneq ($(BPF_GCC),)
 -TRUNNER_BPF_BUILD_RULE := GCC_BPF_BUILD_RULE
 -TRUNNER_BPF_CFLAGS := $(BPF_CFLAGS) $(call get_sys_includes,gcc)
 -TRUNNER_BPF_LDFLAGS :=
 -$(eval $(call DEFINE_TEST_RUNNER,test_progs,bpf_gcc))
 +GCC_SYS_INCLUDES = $(call get_sys_includes,gcc)
 +IS_LITTLE_ENDIAN = $(shell $(CC) -dM -E - </dev/null | \
 +			grep 'define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__')
 +ifeq ($(IS_LITTLE_ENDIAN),)
 +MENDIAN=-mbig-endian
 +else
 +MENDIAN=-mlittle-endian
 +endif
 +BPF_GCC_CFLAGS = $(GCC_SYS_INCLUDES) $(MENDIAN)
 +BPF_GCC_BUILD_DIR = $(OUTPUT)/bpf_gcc
 +TEST_CUSTOM_PROGS += $(BPF_GCC_BUILD_DIR)/test_progs_bpf_gcc
 +$(BPF_GCC_BUILD_DIR):
 +	mkdir -p $@
 +
 +$(BPF_GCC_BUILD_DIR)/urandom_read: $(OUTPUT)/urandom_read | $(BPF_GCC_BUILD_DIR)
 +	cp $< $@
 +
 +$(BPF_GCC_BUILD_DIR)/test_progs_bpf_gcc: $(OUTPUT)/test_progs \
 +					 | $(BPF_GCC_BUILD_DIR)
 +	cp $< $@
 +
 +$(BPF_GCC_BUILD_DIR)/%.o: progs/%.c $(BPF_GCC_BUILD_DIR)/test_progs_bpf_gcc \
 +			  | $(BPF_GCC_BUILD_DIR)
 +	$(BPF_GCC) $(BPF_CFLAGS) $(BPF_GCC_CFLAGS) -O2 -c $< -o $@
  endif
  
 -# Define test_maps test runner.
 -TRUNNER_TESTS_DIR := map_tests
 -TRUNNER_BPF_PROGS_DIR := progs
 -TRUNNER_EXTRA_SOURCES := test_maps.c
 -TRUNNER_EXTRA_FILES :=
 -TRUNNER_BPF_BUILD_RULE := $$(error no BPF objects should be built)
 -TRUNNER_BPF_CFLAGS :=
 -TRUNNER_BPF_LDFLAGS :=
 -$(eval $(call DEFINE_TEST_RUNNER,test_maps))
 -
 -# Define test_verifier test runner.
 -# It is much simpler than test_maps/test_progs and sufficiently different from
 -# them (e.g., test.h is using completely pattern), that it's worth just
 -# explicitly defining all the rules explicitly.
 -verifier/tests.h: verifier/*.c
 +# Have one program compiled without "-target bpf" to test whether libbpf loads
 +# it successfully
 +$(OUTPUT)/test_xdp.o: progs/test_xdp.c
 +	($(CLANG) $(BPF_CFLAGS) $(CLANG_CFLAGS) -O2 -emit-llvm -c $< -o - || \
 +		echo "clang failed") | \
 +	$(LLC) -march=bpf -mcpu=probe $(LLC_FLAGS) -filetype=obj -o $@
 +
 +# libbpf has to be built before BPF programs due to bpf_helper_defs.h
 +$(OUTPUT)/%.o: progs/%.c | $(BPFOBJ)
 +	($(CLANG) $(BPF_CFLAGS) $(CLANG_CFLAGS) -O2 -target bpf -emit-llvm \
 +		-c $< -o - || echo "clang failed") | \
 +	$(LLC) -march=bpf -mcpu=probe $(LLC_FLAGS) -filetype=obj -o $@
 +
 +PROG_TESTS_DIR = $(OUTPUT)/prog_tests
 +$(PROG_TESTS_DIR):
 +	mkdir -p $@
 +PROG_TESTS_H := $(PROG_TESTS_DIR)/tests.h
 +PROG_TESTS_FILES := $(wildcard prog_tests/*.c)
 +test_progs.c: $(PROG_TESTS_H)
 +$(OUTPUT)/test_progs: CFLAGS += $(TEST_PROGS_CFLAGS)
 +$(OUTPUT)/test_progs: test_progs.c $(PROG_TESTS_FILES) | $(OUTPUT)/test_attach_probe.o $(PROG_TESTS_H)
 +$(PROG_TESTS_H): $(PROG_TESTS_FILES) | $(PROG_TESTS_DIR)
 +	$(shell ( cd prog_tests/; \
 +		  echo '/* Generated header, do not edit */'; \
 +		  ls *.c 2> /dev/null | \
 +			sed -e 's@\([^\.]*\)\.c@DEFINE_TEST(\1)@'; \
 +		 ) > $(PROG_TESTS_H))
 +
 +MAP_TESTS_DIR = $(OUTPUT)/map_tests
 +$(MAP_TESTS_DIR):
 +	mkdir -p $@
 +MAP_TESTS_H := $(MAP_TESTS_DIR)/tests.h
 +MAP_TESTS_FILES := $(wildcard map_tests/*.c)
 +test_maps.c: $(MAP_TESTS_H)
 +$(OUTPUT)/test_maps: CFLAGS += $(TEST_MAPS_CFLAGS)
 +$(OUTPUT)/test_maps: test_maps.c $(MAP_TESTS_FILES) | $(MAP_TESTS_H)
 +$(MAP_TESTS_H): $(MAP_TESTS_FILES) | $(MAP_TESTS_DIR)
 +	$(shell ( cd map_tests/; \
 +		  echo '/* Generated header, do not edit */'; \
 +		  ls *.c 2> /dev/null | \
 +			sed -e 's@\([^\.]*\)\.c@DEFINE_TEST(\1)@'; \
 +		 ) > $(MAP_TESTS_H))
 +
 +VERIFIER_TESTS_DIR = $(OUTPUT)/verifier
 +$(VERIFIER_TESTS_DIR):
 +	mkdir -p $@
 +VERIFIER_TESTS_H := $(VERIFIER_TESTS_DIR)/tests.h
 +VERIFIER_TEST_FILES := $(wildcard verifier/*.c)
 +test_verifier.c: $(VERIFIER_TESTS_H)
 +$(OUTPUT)/test_verifier: CFLAGS += $(TEST_VERIFIER_CFLAGS)
 +$(OUTPUT)/test_verifier: test_verifier.c | $(VERIFIER_TEST_FILES) $(VERIFIER_TESTS_H)
 +$(VERIFIER_TESTS_H): $(VERIFIER_TEST_FILES) | $(VERIFIER_TESTS_DIR)
  	$(shell ( cd verifier/; \
  		  echo '/* Generated header, do not edit */'; \
  		  echo '#ifdef FILL_ARRAY'; \
 -		  ls *.c 2> /dev/null | sed -e 's@\(.*\)@#include \"\1\"@'; \
 +		  ls *.c 2> /dev/null | \
 +			sed -e 's@\(.*\)@#include \"\1\"@'; \
  		  echo '#endif' \
 -		) > verifier/tests.h)
 -$(OUTPUT)/test_verifier: test_verifier.c verifier/tests.h $(BPFOBJ) | $(OUTPUT)
 -	$(CC) $(CFLAGS) $(filter %.a %.o %.c,$^) $(LDLIBS) -o $@
 +		 ) > $(VERIFIER_TESTS_H))
  
++<<<<<<< HEAD
 +EXTRA_CLEAN := $(TEST_CUSTOM_PROGS) $(ALU32_BUILD_DIR) $(BPF_GCC_BUILD_DIR) \
 +	$(VERIFIER_TESTS_H) $(PROG_TESTS_H) $(MAP_TESTS_H) \
 +	feature
++=======
+ # Make sure we are able to include and link libbpf against c++.
+ $(OUTPUT)/test_cpp: test_cpp.cpp $(BPFOBJ)
+ 	$(CXX) $(CFLAGS) $^ $(LDLIBS) -o $@
+ 
+ EXTRA_CLEAN := $(TEST_CUSTOM_PROGS)					\
+ 	prog_tests/tests.h map_tests/tests.h verifier/tests.h		\
+ 	feature $(OUTPUT)/*.o $(OUTPUT)/no_alu32 $(OUTPUT)/bpf_gcc	\
+ 	tools *.skel.h
++>>>>>>> f3c926a4df2c (selftests/bpf: Add BPF skeletons selftests and convert attach_probe.c)
diff --cc tools/testing/selftests/bpf/prog_tests/attach_probe.c
index fad615c22e4d,60da1d08daa0..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/attach_probe.c
+++ b/tools/testing/selftests/bpf/prog_tests/attach_probe.c
@@@ -1,8 -1,9 +1,9 @@@
  // SPDX-License-Identifier: GPL-2.0
  #include <test_progs.h>
+ #include "test_attach_probe.skel.h"
  
  ssize_t get_base_addr() {
 -	size_t start;
 +	size_t start, offset;
  	char buf[256];
  	FILE *f;
  
@@@ -22,24 -22,14 +23,31 @@@
  	return -EINVAL;
  }
  
 -BPF_EMBED_OBJ(probe, "test_attach_probe.o");
 -
  void test_attach_probe(void)
  {
++<<<<<<< HEAD
 +	const char *kprobe_name = "kprobe/sys_nanosleep";
 +	const char *kretprobe_name = "kretprobe/sys_nanosleep";
 +	const char *uprobe_name = "uprobe/trigger_func";
 +	const char *uretprobe_name = "uretprobe/trigger_func";
 +	const int kprobe_idx = 0, kretprobe_idx = 1;
 +	const int uprobe_idx = 2, uretprobe_idx = 3;
 +	const char *file = "./test_attach_probe.o";
 +	struct bpf_program *kprobe_prog, *kretprobe_prog;
 +	struct bpf_program *uprobe_prog, *uretprobe_prog;
 +	struct bpf_object *obj;
 +	int err, prog_fd, duration = 0, res;
 +	struct bpf_link *kprobe_link = NULL;
 +	struct bpf_link *kretprobe_link = NULL;
 +	struct bpf_link *uprobe_link = NULL;
 +	struct bpf_link *uretprobe_link = NULL;
 +	int results_map_fd;
++=======
+ 	int duration = 0;
+ 	struct bpf_link *kprobe_link, *kretprobe_link;
+ 	struct bpf_link *uprobe_link, *uretprobe_link;
+ 	struct test_attach_probe* skel;
++>>>>>>> f3c926a4df2c (selftests/bpf: Add BPF skeletons selftests and convert attach_probe.c)
  	size_t uprobe_offset;
  	ssize_t base_addr;
  
@@@ -49,35 -39,13 +57,45 @@@
  		return;
  	uprobe_offset = (size_t)&get_base_addr - base_addr;
  
++<<<<<<< HEAD
 +	/* load programs */
 +	err = bpf_prog_load(file, BPF_PROG_TYPE_KPROBE, &obj, &prog_fd);
 +	if (CHECK(err, "obj_load", "err %d errno %d\n", err, errno))
 +		return;
 +
 +	kprobe_prog = bpf_object__find_program_by_title(obj, kprobe_name);
 +	if (CHECK(!kprobe_prog, "find_probe",
 +		  "prog '%s' not found\n", kprobe_name))
 +		goto cleanup;
 +	kretprobe_prog = bpf_object__find_program_by_title(obj, kretprobe_name);
 +	if (CHECK(!kretprobe_prog, "find_probe",
 +		  "prog '%s' not found\n", kretprobe_name))
 +		goto cleanup;
 +	uprobe_prog = bpf_object__find_program_by_title(obj, uprobe_name);
 +	if (CHECK(!uprobe_prog, "find_probe",
 +		  "prog '%s' not found\n", uprobe_name))
 +		goto cleanup;
 +	uretprobe_prog = bpf_object__find_program_by_title(obj, uretprobe_name);
 +	if (CHECK(!uretprobe_prog, "find_probe",
 +		  "prog '%s' not found\n", uretprobe_name))
 +		goto cleanup;
 +
 +	/* load maps */
 +	results_map_fd = bpf_find_map(__func__, obj, "results_map");
 +	if (CHECK(results_map_fd < 0, "find_results_map",
 +		  "err %d\n", results_map_fd))
 +		goto cleanup;
 +
 +	kprobe_link = bpf_program__attach_kprobe(kprobe_prog,
++=======
+ 	skel = test_attach_probe__open_and_load(&probe_embed);
+ 	if (CHECK(!skel, "skel_open", "failed to open skeleton\n"))
+ 		return;
+ 	if (CHECK(!skel->bss, "check_bss", ".bss wasn't mmap()-ed\n"))
+ 		goto cleanup;
+ 
+ 	kprobe_link = bpf_program__attach_kprobe(skel->progs.handle_kprobe,
++>>>>>>> f3c926a4df2c (selftests/bpf: Add BPF skeletons selftests and convert attach_probe.c)
  						 false /* retprobe */,
  						 SYS_NANOSLEEP_KPROBE_NAME);
  	if (CHECK(IS_ERR(kprobe_link), "attach_kprobe",
* Unmerged path tools/testing/selftests/bpf/.gitignore
* Unmerged path tools/testing/selftests/bpf/Makefile
* Unmerged path tools/testing/selftests/bpf/prog_tests/attach_probe.c
diff --git a/tools/testing/selftests/bpf/progs/test_attach_probe.c b/tools/testing/selftests/bpf/progs/test_attach_probe.c
index 534621e38906..221b69700625 100644
--- a/tools/testing/selftests/bpf/progs/test_attach_probe.c
+++ b/tools/testing/selftests/bpf/progs/test_attach_probe.c
@@ -5,46 +5,36 @@
 #include <linux/bpf.h>
 #include "bpf_helpers.h"
 
-struct {
-	__uint(type, BPF_MAP_TYPE_ARRAY);
-	__uint(max_entries, 4);
-	__type(key, int);
-	__type(value, int);
-} results_map SEC(".maps");
+int kprobe_res = 0;
+int kretprobe_res = 0;
+int uprobe_res = 0;
+int uretprobe_res = 0;
 
 SEC("kprobe/sys_nanosleep")
-int handle_sys_nanosleep_entry(struct pt_regs *ctx)
+int handle_kprobe(struct pt_regs *ctx)
 {
-	const int key = 0, value = 1;
-
-	bpf_map_update_elem(&results_map, &key, &value, 0);
+	kprobe_res = 1;
 	return 0;
 }
 
 SEC("kretprobe/sys_nanosleep")
-int handle_sys_getpid_return(struct pt_regs *ctx)
+int handle_kretprobe(struct pt_regs *ctx)
 {
-	const int key = 1, value = 2;
-
-	bpf_map_update_elem(&results_map, &key, &value, 0);
+	kretprobe_res = 2;
 	return 0;
 }
 
 SEC("uprobe/trigger_func")
-int handle_uprobe_entry(struct pt_regs *ctx)
+int handle_uprobe(struct pt_regs *ctx)
 {
-	const int key = 2, value = 3;
-
-	bpf_map_update_elem(&results_map, &key, &value, 0);
+	uprobe_res = 3;
 	return 0;
 }
 
 SEC("uretprobe/trigger_func")
-int handle_uprobe_return(struct pt_regs *ctx)
+int handle_uretprobe(struct pt_regs *ctx)
 {
-	const int key = 3, value = 4;
-
-	bpf_map_update_elem(&results_map, &key, &value, 0);
+	uretprobe_res = 4;
 	return 0;
 }
 
