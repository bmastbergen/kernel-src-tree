bpf: btf: Fix arg verification in btf_ctx_access()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author KP Singh <kpsingh@google.com>
commit f50b49a0bfcaf53e6394a873b588bc4cca2aab78
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f50b49a0.failed

The bounds checking for the arguments accessed in the BPF program breaks
when the expected_attach_type is not BPF_TRACE_FEXIT, BPF_LSM_MAC or
BPF_MODIFY_RETURN resulting in no check being done for the default case
(the programs which do not receive the return value of the attached
function in its arguments) when the index of the argument being accessed
is equal to the number of arguments (nr_args).

This was a result of a misplaced "else if" block  introduced by the
Commit 6ba43b761c41 ("bpf: Attachment verification for
BPF_MODIFY_RETURN")

Fixes: 6ba43b761c41 ("bpf: Attachment verification for BPF_MODIFY_RETURN")
	Reported-by: Jann Horn <jannh@google.com>
	Signed-off-by: KP Singh <kpsingh@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200330144246.338-1-kpsingh@chromium.org
(cherry picked from commit f50b49a0bfcaf53e6394a873b588bc4cca2aab78)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/btf.c
diff --cc kernel/bpf/btf.c
index d659110c662a,3b6dcfb6ea49..000000000000
--- a/kernel/bpf/btf.c
+++ b/kernel/bpf/btf.c
@@@ -3574,20 -3701,72 +3574,85 @@@ bool btf_ctx_access(int off, int size, 
  	}
  	arg = off / 8;
  	args = (const struct btf_param *)(t + 1);
++<<<<<<< HEAD
 +	/* skip first 'void *__data' argument in btf_trace_##name typedef */
 +	args++;
 +	nr_args = btf_type_vlen(t) - 1;
 +	if (arg >= nr_args) {
 +		bpf_log(log, "raw_tp '%s' doesn't have %d-th argument\n",
 +			tname, arg);
 +		return false;
 +	}
 +
 +	t = btf_type_by_id(btf_vmlinux, args[arg].type);
++=======
+ 	/* if (t == NULL) Fall back to default BPF prog with 5 u64 arguments */
+ 	nr_args = t ? btf_type_vlen(t) : 5;
+ 	if (prog->aux->attach_btf_trace) {
+ 		/* skip first 'void *__data' argument in btf_trace_##name typedef */
+ 		args++;
+ 		nr_args--;
+ 	}
+ 
+ 	if (arg > nr_args) {
+ 		bpf_log(log, "func '%s' doesn't have %d-th argument\n",
+ 			tname, arg + 1);
+ 		return false;
+ 	}
+ 
+ 	if (arg == nr_args) {
+ 		switch (prog->expected_attach_type) {
+ 		case BPF_LSM_MAC:
+ 		case BPF_TRACE_FEXIT:
+ 			/* When LSM programs are attached to void LSM hooks
+ 			 * they use FEXIT trampolines and when attached to
+ 			 * int LSM hooks, they use MODIFY_RETURN trampolines.
+ 			 *
+ 			 * While the LSM programs are BPF_MODIFY_RETURN-like
+ 			 * the check:
+ 			 *
+ 			 *	if (ret_type != 'int')
+ 			 *		return -EINVAL;
+ 			 *
+ 			 * is _not_ done here. This is still safe as LSM hooks
+ 			 * have only void and int return types.
+ 			 */
+ 			if (!t)
+ 				return true;
+ 			t = btf_type_by_id(btf, t->type);
+ 			break;
+ 		case BPF_MODIFY_RETURN:
+ 			/* For now the BPF_MODIFY_RETURN can only be attached to
+ 			 * functions that return an int.
+ 			 */
+ 			if (!t)
+ 				return false;
+ 
+ 			t = btf_type_skip_modifiers(btf, t->type, NULL);
+ 			if (!btf_type_is_int(t)) {
+ 				bpf_log(log,
+ 					"ret type %s not allowed for fmod_ret\n",
+ 					btf_kind_str[BTF_INFO_KIND(t->info)]);
+ 				return false;
+ 			}
+ 			break;
+ 		default:
+ 			bpf_log(log, "func '%s' doesn't have %d-th argument\n",
+ 				tname, arg + 1);
+ 			return false;
+ 		}
+ 	} else {
+ 		if (!t)
+ 			/* Default prog with 5 args */
+ 			return true;
+ 		t = btf_type_by_id(btf, args[arg].type);
+ 	}
+ 
++>>>>>>> f50b49a0bfca (bpf: btf: Fix arg verification in btf_ctx_access())
  	/* skip modifiers */
  	while (btf_type_is_modifier(t))
 -		t = btf_type_by_id(btf, t->type);
 -	if (btf_type_is_int(t) || btf_type_is_enum(t))
 +		t = btf_type_by_id(btf_vmlinux, t->type);
 +	if (btf_type_is_int(t))
  		/* accessing a scalar */
  		return true;
  	if (!btf_type_is_ptr(t)) {
* Unmerged path kernel/bpf/btf.c
