libperf: Adopt perf_mmap__read_event() from tools/perf

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit 151ed5d70da87720022e4171227733a008b3c719
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/151ed5d7.failed

Move perf_mmap__read_event() from tools/perf to libperf and export it in
the perf/mmap.h header.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lore.kernel.org/lkml/20191007125344.14268-13-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 151ed5d70da87720022e4171227733a008b3c719)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/lib/include/perf/mmap.h
#	tools/perf/lib/libperf.map
#	tools/perf/lib/mmap.c
#	tools/perf/tests/backward-ring-buffer.c
#	tools/perf/util/evlist.c
#	tools/perf/util/mmap.c
#	tools/perf/util/mmap.h
diff --cc tools/perf/lib/libperf.map
index 3536242c545c,8bb0d73e0c6c..000000000000
--- a/tools/perf/lib/libperf.map
+++ b/tools/perf/lib/libperf.map
@@@ -1,6 -1,49 +1,53 @@@
  LIBPERF_0.0.1 {
  	global:
++<<<<<<< HEAD
 +		libperf_set_print;
++=======
+ 		libperf_init;
+ 		perf_cpu_map__dummy_new;
+ 		perf_cpu_map__get;
+ 		perf_cpu_map__put;
+ 		perf_cpu_map__new;
+ 		perf_cpu_map__read;
+ 		perf_cpu_map__nr;
+ 		perf_cpu_map__cpu;
+ 		perf_cpu_map__empty;
+ 		perf_cpu_map__max;
+ 		perf_thread_map__new_dummy;
+ 		perf_thread_map__set_pid;
+ 		perf_thread_map__comm;
+ 		perf_thread_map__nr;
+ 		perf_thread_map__pid;
+ 		perf_thread_map__get;
+ 		perf_thread_map__put;
+ 		perf_evsel__new;
+ 		perf_evsel__delete;
+ 		perf_evsel__enable;
+ 		perf_evsel__disable;
+ 		perf_evsel__init;
+ 		perf_evsel__open;
+ 		perf_evsel__close;
+ 		perf_evsel__read;
+ 		perf_evsel__cpus;
+ 		perf_evsel__threads;
+ 		perf_evsel__attr;
+ 		perf_evlist__new;
+ 		perf_evlist__delete;
+ 		perf_evlist__open;
+ 		perf_evlist__close;
+ 		perf_evlist__enable;
+ 		perf_evlist__disable;
+ 		perf_evlist__init;
+ 		perf_evlist__add;
+ 		perf_evlist__remove;
+ 		perf_evlist__next;
+ 		perf_evlist__set_maps;
+ 		perf_evlist__poll;
+ 		perf_mmap__consume;
+ 		perf_mmap__read_init;
+ 		perf_mmap__read_done;
+ 		perf_mmap__read_event;
++>>>>>>> 151ed5d70da8 (libperf: Adopt perf_mmap__read_event() from tools/perf)
  	local:
  		*;
  };
diff --cc tools/perf/tests/backward-ring-buffer.c
index 1a9c3becf5ff,a4cd30c0beb3..000000000000
--- a/tools/perf/tests/backward-ring-buffer.c
+++ b/tools/perf/tests/backward-ring-buffer.c
@@@ -30,12 -34,12 +30,17 @@@ static int count_samples(struct perf_ev
  {
  	int i;
  
 -	for (i = 0; i < evlist->core.nr_mmaps; i++) {
 -		struct mmap *map = &evlist->overwrite_mmap[i];
 +	for (i = 0; i < evlist->nr_mmaps; i++) {
 +		struct perf_mmap *map = &evlist->overwrite_mmap[i];
  		union perf_event *event;
  
++<<<<<<< HEAD
 +		perf_mmap__read_init(map);
 +		while ((event = perf_mmap__read_event(map)) != NULL) {
++=======
+ 		perf_mmap__read_init(&map->core);
+ 		while ((event = perf_mmap__read_event(&map->core)) != NULL) {
++>>>>>>> 151ed5d70da8 (libperf: Adopt perf_mmap__read_event() from tools/perf)
  			const u32 type = event->header.type;
  
  			switch (type) {
diff --cc tools/perf/util/evlist.c
index 29a998d183ce,a9b189ac859b..000000000000
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@@ -1890,16 -1803,16 +1890,21 @@@ static void *perf_evlist__poll_thread(v
  			draining = true;
  
  		if (!draining)
 -			evlist__poll(evlist, 1000);
 +			perf_evlist__poll(evlist, 1000);
  
 -		for (i = 0; i < evlist->core.nr_mmaps; i++) {
 -			struct mmap *map = &evlist->mmap[i];
 +		for (i = 0; i < evlist->nr_mmaps; i++) {
 +			struct perf_mmap *map = &evlist->mmap[i];
  			union perf_event *event;
  
 -			if (perf_mmap__read_init(&map->core))
 +			if (perf_mmap__read_init(map))
  				continue;
++<<<<<<< HEAD
 +			while ((event = perf_mmap__read_event(map)) != NULL) {
 +				struct perf_evsel *evsel = perf_evlist__event2evsel(evlist, event);
++=======
+ 			while ((event = perf_mmap__read_event(&map->core)) != NULL) {
+ 				struct evsel *evsel = perf_evlist__event2evsel(evlist, event);
++>>>>>>> 151ed5d70da8 (libperf: Adopt perf_mmap__read_event() from tools/perf)
  
  				if (evsel && evsel->side_band.cb)
  					evsel->side_band.cb(event, evsel->side_band.data);
diff --cc tools/perf/util/mmap.c
index 850493205040,2a8bf0ab861c..000000000000
--- a/tools/perf/util/mmap.c
+++ b/tools/perf/util/mmap.c
@@@ -17,120 -20,15 +17,123 @@@
  #include "debug.h"
  #include "event.h"
  #include "mmap.h"
 -#include "../perf.h"
 -#include <internal/lib.h> /* page_size */
 +#include "util.h" /* page_size */
  
 -size_t mmap__mmap_len(struct mmap *map)
 +size_t perf_mmap__mmap_len(struct perf_mmap *map)
  {
 -	return perf_mmap__mmap_len(&map->core);
 +	return map->mask + 1 + page_size;
 +}
 +
++<<<<<<< HEAD
 +/* When check_messup is true, 'end' must points to a good entry */
 +static union perf_event *perf_mmap__read(struct perf_mmap *map,
 +					 u64 *startp, u64 end)
 +{
 +	unsigned char *data = map->base + page_size;
 +	union perf_event *event = NULL;
 +	int diff = end - *startp;
 +
 +	if (diff >= (int)sizeof(event->header)) {
 +		size_t size;
 +
 +		event = (union perf_event *)&data[*startp & map->mask];
 +		size = event->header.size;
 +
 +		if (size < sizeof(event->header) || diff < (int)size)
 +			return NULL;
 +
 +		/*
 +		 * Event straddles the mmap boundary -- header should always
 +		 * be inside due to u64 alignment of output.
 +		 */
 +		if ((*startp & map->mask) + size != ((*startp + size) & map->mask)) {
 +			unsigned int offset = *startp;
 +			unsigned int len = min(sizeof(*event), size), cpy;
 +			void *dst = map->event_copy;
 +
 +			do {
 +				cpy = min(map->mask + 1 - (offset & map->mask), len);
 +				memcpy(dst, &data[offset & map->mask], cpy);
 +				offset += cpy;
 +				dst += cpy;
 +				len -= cpy;
 +			} while (len);
 +
 +			event = (union perf_event *)map->event_copy;
 +		}
 +
 +		*startp += size;
 +	}
 +
 +	return event;
  }
  
 +/*
 + * Read event from ring buffer one by one.
 + * Return one event for each call.
 + *
 + * Usage:
 + * perf_mmap__read_init()
 + * while(event = perf_mmap__read_event()) {
 + *	//process the event
 + *	perf_mmap__consume()
 + * }
 + * perf_mmap__read_done()
 + */
 +union perf_event *perf_mmap__read_event(struct perf_mmap *map)
 +{
 +	union perf_event *event;
 +
 +	/*
 +	 * Check if event was unmapped due to a POLLHUP/POLLERR.
 +	 */
 +	if (!refcount_read(&map->refcnt))
 +		return NULL;
 +
 +	/* non-overwirte doesn't pause the ringbuffer */
 +	if (!map->overwrite)
 +		map->end = perf_mmap__read_head(map);
 +
 +	event = perf_mmap__read(map, &map->start, map->end);
 +
 +	if (!map->overwrite)
 +		map->prev = map->start;
 +
 +	return event;
 +}
 +
 +static bool perf_mmap__empty(struct perf_mmap *map)
 +{
 +	return perf_mmap__read_head(map) == map->prev && !map->auxtrace_mmap.base;
 +}
 +
 +void perf_mmap__get(struct perf_mmap *map)
 +{
 +	refcount_inc(&map->refcnt);
 +}
 +
 +void perf_mmap__put(struct perf_mmap *map)
 +{
 +	BUG_ON(map->base && refcount_read(&map->refcnt) == 0);
 +
 +	if (refcount_dec_and_test(&map->refcnt))
 +		perf_mmap__munmap(map);
 +}
 +
 +void perf_mmap__consume(struct perf_mmap *map)
 +{
 +	if (!map->overwrite) {
 +		u64 old = map->prev;
 +
 +		perf_mmap__write_tail(map, old);
 +	}
 +
 +	if (refcount_read(&map->refcnt) == 1 && perf_mmap__empty(map))
 +		perf_mmap__put(map);
 +}
 +
++=======
++>>>>>>> 151ed5d70da8 (libperf: Adopt perf_mmap__read_event() from tools/perf)
  int __weak auxtrace_mmap__mmap(struct auxtrace_mmap *mm __maybe_unused,
  			       struct auxtrace_mmap_params *mp __maybe_unused,
  			       void *userpg __maybe_unused,
diff --cc tools/perf/util/mmap.h
index 274ce389cd84,bee4e83f7109..000000000000
--- a/tools/perf/util/mmap.h
+++ b/tools/perf/util/mmap.h
@@@ -77,33 -42,14 +77,38 @@@ struct mmap_params 
  	struct auxtrace_mmap_params auxtrace_mp;
  };
  
 -int mmap__mmap(struct mmap *map, struct mmap_params *mp, int fd, int cpu);
 -void mmap__munmap(struct mmap *map);
 +int perf_mmap__mmap(struct perf_mmap *map, struct mmap_params *mp, int fd, int cpu);
 +void perf_mmap__munmap(struct perf_mmap *map);
  
 -union perf_event *perf_mmap__read_forward(struct mmap *map);
 +void perf_mmap__get(struct perf_mmap *map);
 +void perf_mmap__put(struct perf_mmap *map);
  
++<<<<<<< HEAD
 +void perf_mmap__consume(struct perf_mmap *map);
 +
 +static inline u64 perf_mmap__read_head(struct perf_mmap *mm)
 +{
 +	return ring_buffer_read_head(mm->base);
 +}
++=======
+ int perf_mmap__push(struct mmap *md, void *to,
+ 		    int push(struct mmap *map, void *to, void *buf, size_t size));
++>>>>>>> 151ed5d70da8 (libperf: Adopt perf_mmap__read_event() from tools/perf)
 +
 +static inline void perf_mmap__write_tail(struct perf_mmap *md, u64 tail)
 +{
 +	ring_buffer_write_tail(md->base, tail);
 +}
 +
 +union perf_event *perf_mmap__read_forward(struct perf_mmap *map);
 +
 +union perf_event *perf_mmap__read_event(struct perf_mmap *map);
 +
 +int perf_mmap__push(struct perf_mmap *md, void *to,
 +		    int push(struct perf_mmap *map, void *to, void *buf, size_t size));
  
 -size_t mmap__mmap_len(struct mmap *map);
 +size_t perf_mmap__mmap_len(struct perf_mmap *map);
  
 +int perf_mmap__read_init(struct perf_mmap *md);
 +void perf_mmap__read_done(struct perf_mmap *map);
  #endif /*__PERF_MMAP_H */
* Unmerged path tools/perf/lib/include/perf/mmap.h
* Unmerged path tools/perf/lib/mmap.c
diff --git a/tools/perf/arch/x86/tests/perf-time-to-tsc.c b/tools/perf/arch/x86/tests/perf-time-to-tsc.c
index 7a7721604b86..ae4e8c09de0c 100644
--- a/tools/perf/arch/x86/tests/perf-time-to-tsc.c
+++ b/tools/perf/arch/x86/tests/perf-time-to-tsc.c
@@ -114,7 +114,7 @@ int test__perf_time_to_tsc(struct test *test __maybe_unused, int subtest __maybe
 		if (perf_mmap__read_init(md) < 0)
 			continue;
 
-		while ((event = perf_mmap__read_event(md)) != NULL) {
+		while ((event = perf_mmap__read_event(&md->core)) != NULL) {
 			struct perf_sample sample;
 
 			if (event->header.type != PERF_RECORD_COMM ||
diff --git a/tools/perf/builtin-kvm.c b/tools/perf/builtin-kvm.c
index 0b1c94b91443..cfe1e31c3068 100644
--- a/tools/perf/builtin-kvm.c
+++ b/tools/perf/builtin-kvm.c
@@ -758,7 +758,7 @@ static s64 perf_kvm__mmap_read_idx(struct perf_kvm_stat *kvm, int idx,
 	if (err < 0)
 		return (err == -EAGAIN) ? 0 : -1;
 
-	while ((event = perf_mmap__read_event(md)) != NULL) {
+	while ((event = perf_mmap__read_event(&md->core)) != NULL) {
 		err = perf_evlist__parse_sample_timestamp(evlist, event, &timestamp);
 		if (err) {
 			perf_mmap__consume(md);
diff --git a/tools/perf/builtin-top.c b/tools/perf/builtin-top.c
index 68f3bdeb4246..90a19f4a7b39 100644
--- a/tools/perf/builtin-top.c
+++ b/tools/perf/builtin-top.c
@@ -875,7 +875,7 @@ static void perf_top__mmap_read_idx(struct perf_top *top, int idx)
 	if (perf_mmap__read_init(md) < 0)
 		return;
 
-	while ((event = perf_mmap__read_event(md)) != NULL) {
+	while ((event = perf_mmap__read_event(&md->core)) != NULL) {
 		int ret;
 
 		ret = perf_evlist__parse_sample_timestamp(evlist, event, &last_timestamp);
diff --git a/tools/perf/builtin-trace.c b/tools/perf/builtin-trace.c
index 8a34b71ac3d6..3dc0640f96da 100644
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@ -3685,7 +3685,7 @@ static int trace__run(struct trace *trace, int argc, const char **argv)
 		if (perf_mmap__read_init(md) < 0)
 			continue;
 
-		while ((event = perf_mmap__read_event(md)) != NULL) {
+		while ((event = perf_mmap__read_event(&md->core)) != NULL) {
 			++trace->nr_events;
 
 			err = trace__deliver_event(trace, event);
* Unmerged path tools/perf/lib/include/perf/mmap.h
* Unmerged path tools/perf/lib/libperf.map
* Unmerged path tools/perf/lib/mmap.c
* Unmerged path tools/perf/tests/backward-ring-buffer.c
diff --git a/tools/perf/tests/bpf.c b/tools/perf/tests/bpf.c
index c9e4cdc4c9c8..4039f960ecf4 100644
--- a/tools/perf/tests/bpf.c
+++ b/tools/perf/tests/bpf.c
@@ -183,7 +183,7 @@ static int do_test(struct bpf_object *obj, int (*func)(void),
 		if (perf_mmap__read_init(md) < 0)
 			continue;
 
-		while ((event = perf_mmap__read_event(md)) != NULL) {
+		while ((event = perf_mmap__read_event(&md->core)) != NULL) {
 			const u32 type = event->header.type;
 
 			if (type == PERF_RECORD_SAMPLE)
diff --git a/tools/perf/tests/code-reading.c b/tools/perf/tests/code-reading.c
index aa6df122b175..65550005968d 100644
--- a/tools/perf/tests/code-reading.c
+++ b/tools/perf/tests/code-reading.c
@@ -420,7 +420,7 @@ static int process_events(struct machine *machine, struct perf_evlist *evlist,
 		if (perf_mmap__read_init(md) < 0)
 			continue;
 
-		while ((event = perf_mmap__read_event(md)) != NULL) {
+		while ((event = perf_mmap__read_event(&md->core)) != NULL) {
 			ret = process_event(machine, evlist, event, state);
 			perf_mmap__consume(md);
 			if (ret < 0)
diff --git a/tools/perf/tests/keep-tracking.c b/tools/perf/tests/keep-tracking.c
index 17c46f3e6f1e..b9bb3499b716 100644
--- a/tools/perf/tests/keep-tracking.c
+++ b/tools/perf/tests/keep-tracking.c
@@ -35,7 +35,7 @@ static int find_comm(struct perf_evlist *evlist, const char *comm)
 		md = &evlist->mmap[i];
 		if (perf_mmap__read_init(md) < 0)
 			continue;
-		while ((event = perf_mmap__read_event(md)) != NULL) {
+		while ((event = perf_mmap__read_event(&md->core)) != NULL) {
 			if (event->header.type == PERF_RECORD_COMM &&
 			    (pid_t)event->comm.pid == getpid() &&
 			    (pid_t)event->comm.tid == getpid() &&
diff --git a/tools/perf/tests/mmap-basic.c b/tools/perf/tests/mmap-basic.c
index 0919b0793e5b..cfc6f3e34380 100644
--- a/tools/perf/tests/mmap-basic.c
+++ b/tools/perf/tests/mmap-basic.c
@@ -111,7 +111,7 @@ int test__basic_mmap(struct test *test __maybe_unused, int subtest __maybe_unuse
 	if (perf_mmap__read_init(md) < 0)
 		goto out_init;
 
-	while ((event = perf_mmap__read_event(md)) != NULL) {
+	while ((event = perf_mmap__read_event(&md->core)) != NULL) {
 		struct perf_sample sample;
 
 		if (event->header.type != PERF_RECORD_SAMPLE) {
diff --git a/tools/perf/tests/openat-syscall-tp-fields.c b/tools/perf/tests/openat-syscall-tp-fields.c
index 344dc3ac2469..855771dd13c5 100644
--- a/tools/perf/tests/openat-syscall-tp-fields.c
+++ b/tools/perf/tests/openat-syscall-tp-fields.c
@@ -92,7 +92,7 @@ int test__syscall_openat_tp_fields(struct test *test __maybe_unused, int subtest
 			if (perf_mmap__read_init(md) < 0)
 				continue;
 
-			while ((event = perf_mmap__read_event(md)) != NULL) {
+			while ((event = perf_mmap__read_event(&md->core)) != NULL) {
 				const u32 type = event->header.type;
 				int tp_flags;
 				struct perf_sample sample;
diff --git a/tools/perf/tests/perf-record.c b/tools/perf/tests/perf-record.c
index 07f6bd8ed719..84e6552b40ae 100644
--- a/tools/perf/tests/perf-record.c
+++ b/tools/perf/tests/perf-record.c
@@ -171,7 +171,7 @@ int test__PERF_RECORD(struct test *test __maybe_unused, int subtest __maybe_unus
 			if (perf_mmap__read_init(md) < 0)
 				continue;
 
-			while ((event = perf_mmap__read_event(md)) != NULL) {
+			while ((event = perf_mmap__read_event(&md->core)) != NULL) {
 				const u32 type = event->header.type;
 				const char *name = perf_event__name(type);
 
diff --git a/tools/perf/tests/sw-clock.c b/tools/perf/tests/sw-clock.c
index f9490b237893..f59b2b958519 100644
--- a/tools/perf/tests/sw-clock.c
+++ b/tools/perf/tests/sw-clock.c
@@ -98,7 +98,7 @@ static int __test__sw_clock_freq(enum perf_sw_ids clock_id)
 	if (perf_mmap__read_init(md) < 0)
 		goto out_init;
 
-	while ((event = perf_mmap__read_event(md)) != NULL) {
+	while ((event = perf_mmap__read_event(&md->core)) != NULL) {
 		struct perf_sample sample;
 
 		if (event->header.type != PERF_RECORD_SAMPLE)
diff --git a/tools/perf/tests/switch-tracking.c b/tools/perf/tests/switch-tracking.c
index 6cdab5f4812a..ee1959c9a162 100644
--- a/tools/perf/tests/switch-tracking.c
+++ b/tools/perf/tests/switch-tracking.c
@@ -267,7 +267,7 @@ static int process_events(struct perf_evlist *evlist,
 		if (perf_mmap__read_init(md) < 0)
 			continue;
 
-		while ((event = perf_mmap__read_event(md)) != NULL) {
+		while ((event = perf_mmap__read_event(&md->core)) != NULL) {
 			cnt += 1;
 			ret = add_event(evlist, &events, event);
 			 perf_mmap__consume(md);
diff --git a/tools/perf/tests/task-exit.c b/tools/perf/tests/task-exit.c
index e92fa6029ac7..1938a83d18d7 100644
--- a/tools/perf/tests/task-exit.c
+++ b/tools/perf/tests/task-exit.c
@@ -115,7 +115,7 @@ int test__task_exit(struct test *test __maybe_unused, int subtest __maybe_unused
 	if (perf_mmap__read_init(md) < 0)
 		goto out_init;
 
-	while ((event = perf_mmap__read_event(md)) != NULL) {
+	while ((event = perf_mmap__read_event(&md->core)) != NULL) {
 		if (event->header.type == PERF_RECORD_EXIT)
 			nr_exit++;
 
* Unmerged path tools/perf/util/evlist.c
* Unmerged path tools/perf/util/mmap.c
* Unmerged path tools/perf/util/mmap.h
diff --git a/tools/perf/util/python.c b/tools/perf/util/python.c
index 9c3b43665909..2bf1b5475fab 100644
--- a/tools/perf/util/python.c
+++ b/tools/perf/util/python.c
@@ -1014,7 +1014,7 @@ static PyObject *pyrf_evlist__read_on_cpu(struct pyrf_evlist *pevlist,
 	if (perf_mmap__read_init(md) < 0)
 		goto end;
 
-	event = perf_mmap__read_event(md);
+	event = perf_mmap__read_event(&md->core);
 	if (event != NULL) {
 		PyObject *pyevent = pyrf_event__new(event);
 		struct pyrf_event *pevent = (struct pyrf_event *)pyevent;
