block: respect queue limit of max discard segment

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ming Lei <ming.lei@redhat.com>
commit 943b40c832beb71115e38a1c4d99b640b5342738
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/943b40c8.failed

When queue_max_discard_segments(q) is 1, blk_discard_mergable() will
return false for discard request, then normal request merge is applied.
However, only queue_max_segments() is checked, so max discard segment
limit isn't respected.

Check max discard segment limit in the request merge code for fixing
the issue.

Discard request failure of virtio_blk is fixed.

Fixes: 69840466086d ("block: fix the DISCARD request merge")
	Signed-off-by: Ming Lei <ming.lei@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Cc: Stefano Garzarella <sgarzare@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 943b40c832beb71115e38a1c4d99b640b5342738)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-merge.c
diff --cc block/blk-merge.c
index ae96bb6dc401,7af1f3668a91..000000000000
--- a/block/blk-merge.c
+++ b/block/blk-merge.c
@@@ -502,18 -531,22 +502,32 @@@ int blk_rq_map_sg(struct request_queue 
  
  	return nsegs;
  }
 -EXPORT_SYMBOL(__blk_rq_map_sg);
 +EXPORT_SYMBOL(blk_rq_map_sg);
  
++<<<<<<< HEAD
 +static inline int ll_new_hw_segment(struct request_queue *q,
 +				    struct request *req,
 +				    struct bio *bio)
 +{
 +	int nr_phys_segs = bio_phys_segments(q, bio);
 +
 +	if (req->nr_phys_segments + nr_phys_segs > queue_max_segments(q))
++=======
+ static inline unsigned int blk_rq_get_max_segments(struct request *rq)
+ {
+ 	if (req_op(rq) == REQ_OP_DISCARD)
+ 		return queue_max_discard_segments(rq->q);
+ 	return queue_max_segments(rq->q);
+ }
+ 
+ static inline int ll_new_hw_segment(struct request *req, struct bio *bio,
+ 		unsigned int nr_phys_segs)
+ {
+ 	if (req->nr_phys_segments + nr_phys_segs > blk_rq_get_max_segments(req))
++>>>>>>> 943b40c832be (block: respect queue limit of max discard segment)
  		goto no_merge;
  
 -	if (blk_integrity_merge_bio(req->q, req, bio) == false)
 +	if (blk_integrity_merge_bio(q, req, bio) == false)
  		goto no_merge;
  
  	/*
@@@ -607,15 -631,7 +621,19 @@@ static int ll_merge_requests_fn(struct 
  		return 0;
  
  	total_phys_segments = req->nr_phys_segments + next->nr_phys_segments;
++<<<<<<< HEAD
 +	if (blk_phys_contig_segment(q, req->biotail, next->bio)) {
 +		if (req->nr_phys_segments == 1)
 +			req->bio->bi_seg_front_size = seg_size;
 +		if (next->nr_phys_segments == 1)
 +			next->biotail->bi_seg_back_size = seg_size;
 +		total_phys_segments--;
 +	}
 +
 +	if (total_phys_segments > queue_max_segments(q))
++=======
+ 	if (total_phys_segments > blk_rq_get_max_segments(req))
++>>>>>>> 943b40c832be (block: respect queue limit of max discard segment)
  		return 0;
  
  	if (blk_integrity_merge_rq(q, req, next) == false)
* Unmerged path block/blk-merge.c
