netfilter: conntrack: gre: switch module to be built-in

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 22fc4c4c9fd60427bcda00878cee94e7622cfa7a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/22fc4c4c.failed

This makes the last of the modular l4 trackers 'bool'.

After this, all infrastructure to handle dynamic l4 protocol registration
becomes obsolete and can be removed in followup patches.

Old:
302824 net/netfilter/nf_conntrack.ko
 21504 net/netfilter/nf_conntrack_proto_gre.ko

New:
313728 net/netfilter/nf_conntrack.ko

Old:
   text	   data	    bss	    dec	    hex	filename
   6281	   1732	      4	   8017	   1f51	nf_conntrack_proto_gre.ko
 108356	  20613	    236	 129205	  1f8b5	nf_conntrack.ko
New:
 112095	  21381	    240	 133716	  20a54	nf_conntrack.ko

The size increase is only temporary.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 22fc4c4c9fd60427bcda00878cee94e7622cfa7a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/nf_conntrack_proto_gre.h
#	include/net/netfilter/nf_conntrack_l4proto.h
#	net/netfilter/nf_conntrack_proto.c
#	net/netfilter/nf_conntrack_proto_gre.c
#	net/netfilter/nfnetlink_cttimeout.c
diff --cc include/linux/netfilter/nf_conntrack_proto_gre.h
index b8d95564bd53,59714e9ee4ef..000000000000
--- a/include/linux/netfilter/nf_conntrack_proto_gre.h
+++ b/include/linux/netfilter/nf_conntrack_proto_gre.h
@@@ -19,6 -19,7 +19,10 @@@ struct nf_conn
  struct nf_ct_gre_keymap {
  	struct list_head list;
  	struct nf_conntrack_tuple tuple;
++<<<<<<< HEAD
++=======
+ 	struct rcu_head rcu;
++>>>>>>> 22fc4c4c9fd6 (netfilter: conntrack: gre: switch module to be built-in)
  };
  
  /* add new tuple->key_reply pair to keymap */
diff --cc include/net/netfilter/nf_conntrack_l4proto.h
index 264f50873a3a,fded3f164dcc..000000000000
--- a/include/net/netfilter/nf_conntrack_l4proto.h
+++ b/include/net/netfilter/nf_conntrack_l4proto.h
@@@ -165,4 -200,50 +165,53 @@@ void nf_ct_l4proto_log_invalid(const st
  			       const char *fmt, ...) { }
  #endif /* CONFIG_SYSCTL */
  
++<<<<<<< HEAD
++=======
+ static inline struct nf_generic_net *nf_generic_pernet(struct net *net)
+ {
+        return &net->ct.nf_ct_proto.generic;
+ }
+ 
+ static inline struct nf_tcp_net *nf_tcp_pernet(struct net *net)
+ {
+        return &net->ct.nf_ct_proto.tcp;
+ }
+ 
+ static inline struct nf_udp_net *nf_udp_pernet(struct net *net)
+ {
+        return &net->ct.nf_ct_proto.udp;
+ }
+ 
+ static inline struct nf_icmp_net *nf_icmp_pernet(struct net *net)
+ {
+        return &net->ct.nf_ct_proto.icmp;
+ }
+ 
+ static inline struct nf_icmp_net *nf_icmpv6_pernet(struct net *net)
+ {
+        return &net->ct.nf_ct_proto.icmpv6;
+ }
+ 
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ static inline struct nf_dccp_net *nf_dccp_pernet(struct net *net)
+ {
+        return &net->ct.nf_ct_proto.dccp;
+ }
+ #endif
+ 
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ static inline struct nf_sctp_net *nf_sctp_pernet(struct net *net)
+ {
+        return &net->ct.nf_ct_proto.sctp;
+ }
+ #endif
+ 
+ #ifdef CONFIG_NF_CT_PROTO_GRE
+ static inline struct nf_gre_net *nf_gre_pernet(struct net *net)
+ {
+ 	return &net->ct.nf_ct_proto.gre;
+ }
+ #endif
+ 
++>>>>>>> 22fc4c4c9fd6 (netfilter: conntrack: gre: switch module to be built-in)
  #endif /*_NF_CONNTRACK_PROTOCOL_H*/
diff --cc net/netfilter/nf_conntrack_proto.c
index baa1f4cdedbb,e113bb2dc88d..000000000000
--- a/net/netfilter/nf_conntrack_proto.c
+++ b/net/netfilter/nf_conntrack_proto.c
@@@ -122,139 -133,7 +122,164 @@@ __nf_ct_l4proto_find(u_int16_t l3proto
  }
  EXPORT_SYMBOL_GPL(__nf_ct_l4proto_find);
  
 -const struct nf_conntrack_l4proto *nf_ct_l4proto_find_get(u8 l4num)
 +/* this is guaranteed to always return a valid protocol helper, since
 + * it falls back to generic_protocol */
 +const struct nf_conntrack_l3proto *
 +nf_ct_l3proto_find_get(u_int16_t l3proto)
 +{
 +	struct nf_conntrack_l3proto *p;
 +
 +	rcu_read_lock();
 +	p = __nf_ct_l3proto_find(l3proto);
 +	if (!try_module_get(p->me))
 +		p = &nf_conntrack_l3proto_generic;
 +	rcu_read_unlock();
 +
 +	return p;
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_l3proto_find_get);
 +
 +int
 +nf_ct_l3proto_try_module_get(unsigned short l3proto)
 +{
 +	const struct nf_conntrack_l3proto *p;
 +	int ret;
 +
 +retry:	p = nf_ct_l3proto_find_get(l3proto);
 +	if (p == &nf_conntrack_l3proto_generic) {
 +		ret = request_module("nf_conntrack-%d", l3proto);
 +		if (!ret)
 +			goto retry;
 +
 +		return -EPROTOTYPE;
 +	}
 +
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_l3proto_try_module_get);
 +
 +void nf_ct_l3proto_module_put(unsigned short l3proto)
 +{
 +	struct nf_conntrack_l3proto *p;
 +
 +	/* rcu_read_lock not necessary since the caller holds a reference, but
 +	 * taken anyways to avoid lockdep warnings in __nf_ct_l3proto_find()
 +	 */
 +	rcu_read_lock();
 +	p = __nf_ct_l3proto_find(l3proto);
 +	module_put(p->me);
 +	rcu_read_unlock();
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_l3proto_module_put);
 +
 +static int nf_ct_netns_do_get(struct net *net, u8 nfproto)
 +{
 +	const struct nf_conntrack_l3proto *l3proto;
 +	int ret;
 +
 +	might_sleep();
 +
 +	ret = nf_ct_l3proto_try_module_get(nfproto);
 +	if (ret < 0)
 +		return ret;
 +
 +	/* we already have a reference, can't fail */
 +	rcu_read_lock();
 +	l3proto = __nf_ct_l3proto_find(nfproto);
 +	rcu_read_unlock();
 +
 +	if (!l3proto->net_ns_get)
 +		return 0;
 +
 +	ret = l3proto->net_ns_get(net);
 +	if (ret < 0)
 +		nf_ct_l3proto_module_put(nfproto);
 +
 +	return ret;
 +}
 +
 +int nf_ct_netns_get(struct net *net, u8 nfproto)
 +{
 +	int err;
 +
 +	if (nfproto == NFPROTO_INET) {
 +		err = nf_ct_netns_do_get(net, NFPROTO_IPV4);
 +		if (err < 0)
 +			goto err1;
 +		err = nf_ct_netns_do_get(net, NFPROTO_IPV6);
 +		if (err < 0)
 +			goto err2;
 +	} else {
 +		err = nf_ct_netns_do_get(net, nfproto);
 +		if (err < 0)
 +			goto err1;
 +	}
 +	return 0;
 +
 +err2:
 +	nf_ct_netns_put(net, NFPROTO_IPV4);
 +err1:
 +	return err;
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_netns_get);
 +
 +static void nf_ct_netns_do_put(struct net *net, u8 nfproto)
 +{
 +	const struct nf_conntrack_l3proto *l3proto;
 +
 +	might_sleep();
 +
 +	/* same as nf_conntrack_netns_get(), reference assumed */
 +	rcu_read_lock();
 +	l3proto = __nf_ct_l3proto_find(nfproto);
 +	rcu_read_unlock();
 +
 +	if (WARN_ON(!l3proto))
 +		return;
 +
 +	if (l3proto->net_ns_put)
 +		l3proto->net_ns_put(net);
 +
 +	nf_ct_l3proto_module_put(nfproto);
 +}
 +
 +void nf_ct_netns_put(struct net *net, uint8_t nfproto)
 +{
 +	if (nfproto == NFPROTO_INET) {
 +		nf_ct_netns_do_put(net, NFPROTO_IPV4);
 +		nf_ct_netns_do_put(net, NFPROTO_IPV6);
 +	} else
 +		nf_ct_netns_do_put(net, nfproto);
 +}
 +EXPORT_SYMBOL_GPL(nf_ct_netns_put);
 +
++<<<<<<< HEAD
 +const struct nf_conntrack_l4proto *
 +nf_ct_l4proto_find_get(u_int16_t l3num, u_int8_t l4num)
++=======
++static const struct nf_conntrack_l4proto * const builtin_l4proto[] = {
++	&nf_conntrack_l4proto_tcp,
++	&nf_conntrack_l4proto_udp,
++	&nf_conntrack_l4proto_icmp,
++#ifdef CONFIG_NF_CT_PROTO_DCCP
++	&nf_conntrack_l4proto_dccp,
++#endif
++#ifdef CONFIG_NF_CT_PROTO_SCTP
++	&nf_conntrack_l4proto_sctp,
++#endif
++#ifdef CONFIG_NF_CT_PROTO_UDPLITE
++	&nf_conntrack_l4proto_udplite,
++#endif
++#ifdef CONFIG_NF_CT_PROTO_GRE
++	&nf_conntrack_l4proto_gre,
++#endif
++#if IS_ENABLED(CONFIG_IPV6)
++	&nf_conntrack_l4proto_icmpv6,
++#endif /* CONFIG_IPV6 */
++};
++
++int nf_conntrack_proto_init(void)
++>>>>>>> 22fc4c4c9fd6 (netfilter: conntrack: gre: switch module to be built-in)
  {
  	const struct nf_conntrack_l4proto *p;
  
@@@ -594,25 -896,19 +619,41 @@@ void nf_conntrack_proto_pernet_fini(str
  	struct nf_proto_net *pn = nf_ct_l4proto_net(net,
  					&nf_conntrack_l4proto_generic);
  
 -	nf_ct_l4proto_pernet_unregister(net, builtin_l4proto,
 -					ARRAY_SIZE(builtin_l4proto));
  	pn->users--;
++<<<<<<< HEAD
 +	nf_ct_l4proto_unregister_sysctl(net,
 +					pn,
 +					&nf_conntrack_l4proto_generic);
 +}
 +
 +int nf_conntrack_proto_init(void)
 +{
 +	unsigned int i;
 +	for (i = 0; i < NFPROTO_NUMPROTO; i++)
 +		rcu_assign_pointer(nf_ct_l3protos[i],
 +				   &nf_conntrack_l3proto_generic);
 +	return 0;
 +}
 +
 +void nf_conntrack_proto_fini(void)
 +{
 +	unsigned int i;
 +	/* free l3proto protocol tables */
 +	for (i = 0; i < ARRAY_SIZE(nf_ct_protos); i++)
 +		kfree(nf_ct_protos[i]);
 +}
++=======
+ 	nf_ct_l4proto_unregister_sysctl(pn);
+ #ifdef CONFIG_NF_CT_PROTO_GRE
+ 	nf_ct_gre_keymap_flush(net);
+ #endif
+ }
+ 
+ module_param_call(hashsize, nf_conntrack_set_hashsize, param_get_uint,
+ 		  &nf_conntrack_htable_size, 0600);
+ 
+ MODULE_ALIAS("ip_conntrack");
+ MODULE_ALIAS("nf_conntrack-" __stringify(AF_INET));
+ MODULE_ALIAS("nf_conntrack-" __stringify(AF_INET6));
+ MODULE_LICENSE("GPL");
++>>>>>>> 22fc4c4c9fd6 (netfilter: conntrack: gre: switch module to be built-in)
diff --cc net/netfilter/nf_conntrack_proto_gre.c
index c9e1b1061af6,68f9bfb79c4e..000000000000
--- a/net/netfilter/nf_conntrack_proto_gre.c
+++ b/net/netfilter/nf_conntrack_proto_gre.c
@@@ -53,30 -48,25 +53,35 @@@ static const unsigned int gre_timeouts[
  	[GRE_CT_REPLIED]	= 180*HZ,
  };
  
++<<<<<<< HEAD
 +static unsigned int proto_gre_net_id __read_mostly;
 +struct netns_proto_gre {
 +	struct nf_proto_net	nf;
 +	rwlock_t		keymap_lock;
 +	struct list_head	keymap_list;
 +	unsigned int		gre_timeouts[GRE_CT_MAX];
 +};
++=======
+ /* used when expectation is added */
+ static DEFINE_SPINLOCK(keymap_lock);
++>>>>>>> 22fc4c4c9fd6 (netfilter: conntrack: gre: switch module to be built-in)
  
- static inline struct netns_proto_gre *gre_pernet(struct net *net)
+ static inline struct nf_gre_net *gre_pernet(struct net *net)
  {
- 	return net_generic(net, proto_gre_net_id);
+ 	return &net->ct.nf_ct_proto.gre;
  }
  
- static void nf_ct_gre_keymap_flush(struct net *net)
+ void nf_ct_gre_keymap_flush(struct net *net)
  {
- 	struct netns_proto_gre *net_gre = gre_pernet(net);
+ 	struct nf_gre_net *net_gre = gre_pernet(net);
  	struct nf_ct_gre_keymap *km, *tmp;
  
 -	spin_lock_bh(&keymap_lock);
 +	write_lock_bh(&net_gre->keymap_lock);
  	list_for_each_entry_safe(km, tmp, &net_gre->keymap_list, list) {
 -		list_del_rcu(&km->list);
 -		kfree_rcu(km, rcu);
 +		list_del(&km->list);
 +		kfree(km);
  	}
 -	spin_unlock_bh(&keymap_lock);
 +	write_unlock_bh(&net_gre->keymap_lock);
  }
  
  static inline int gre_key_cmpfn(const struct nf_ct_gre_keymap *km,
@@@ -289,11 -271,13 +294,11 @@@ static int gre_timeout_nlattr_to_obj(st
  				     struct net *net, void *data)
  {
  	unsigned int *timeouts = data;
- 	struct netns_proto_gre *net_gre = gre_pernet(net);
+ 	struct nf_gre_net *net_gre = gre_pernet(net);
  
 -	if (!timeouts)
 -		timeouts = gre_get_timeouts(net);
  	/* set default timeouts for GRE. */
- 	timeouts[GRE_CT_UNREPLIED] = net_gre->gre_timeouts[GRE_CT_UNREPLIED];
- 	timeouts[GRE_CT_REPLIED] = net_gre->gre_timeouts[GRE_CT_REPLIED];
+ 	timeouts[GRE_CT_UNREPLIED] = net_gre->timeouts[GRE_CT_UNREPLIED];
+ 	timeouts[GRE_CT_REPLIED] = net_gre->timeouts[GRE_CT_REPLIED];
  
  	if (tb[CTA_TIMEOUT_GRE_UNREPLIED]) {
  		timeouts[GRE_CT_UNREPLIED] =
@@@ -329,22 -313,60 +334,76 @@@ gre_timeout_nla_policy[CTA_TIMEOUT_GRE_
  };
  #endif /* CONFIG_NF_CONNTRACK_TIMEOUT */
  
++<<<<<<< HEAD
 +static int gre_init_net(struct net *net)
 +{
 +	struct netns_proto_gre *net_gre = gre_pernet(net);
++=======
+ #ifdef CONFIG_SYSCTL
+ static struct ctl_table gre_sysctl_table[] = {
+ 	{
+ 		.procname       = "nf_conntrack_gre_timeout",
+ 		.maxlen         = sizeof(unsigned int),
+ 		.mode           = 0644,
+ 		.proc_handler   = proc_dointvec_jiffies,
+ 	},
+ 	{
+ 		.procname       = "nf_conntrack_gre_timeout_stream",
+ 		.maxlen         = sizeof(unsigned int),
+ 		.mode           = 0644,
+ 		.proc_handler   = proc_dointvec_jiffies,
+ 	},
+ 	{}
+ };
+ #endif
+ 
+ static int gre_kmemdup_sysctl_table(struct net *net)
+ {
+ #ifdef CONFIG_SYSCTL
+ 	struct nf_gre_net *net_gre = gre_pernet(net);
+ 	struct nf_proto_net *nf = &net_gre->nf;
+ 	int i;
+ 
+ 	if (nf->ctl_table)
+ 		return 0;
+ 
+ 	nf->ctl_table = kmemdup(gre_sysctl_table,
+ 				sizeof(gre_sysctl_table),
+ 				GFP_KERNEL);
+ 	if (!nf->ctl_table)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < GRE_CT_MAX; i++)
+ 		nf->ctl_table[i].data = &net_gre->timeouts[i];
+ #endif
+ 	return 0;
+ }
+ 
+ static int gre_init_net(struct net *net)
+ {
+ 	struct nf_gre_net *net_gre = gre_pernet(net);
++>>>>>>> 22fc4c4c9fd6 (netfilter: conntrack: gre: switch module to be built-in)
  	int i;
  
 +	rwlock_init(&net_gre->keymap_lock);
  	INIT_LIST_HEAD(&net_gre->keymap_list);
  	for (i = 0; i < GRE_CT_MAX; i++)
- 		net_gre->gre_timeouts[i] = gre_timeouts[i];
+ 		net_gre->timeouts[i] = gre_timeouts[i];
  
++<<<<<<< HEAD
 +	return 0;
 +}
 +
 +/* protocol helper struct */
 +static const struct nf_conntrack_l4proto nf_conntrack_l4proto_gre4 = {
 +	.l3proto	 = AF_INET,
++=======
+ 	return gre_kmemdup_sysctl_table(net);
+ }
+ 
+ /* protocol helper struct */
+ const struct nf_conntrack_l4proto nf_conntrack_l4proto_gre = {
++>>>>>>> 22fc4c4c9fd6 (netfilter: conntrack: gre: switch module to be built-in)
  	.l4proto	 = IPPROTO_GRE,
  	.pkt_to_tuple	 = gre_pkt_to_tuple,
  #ifdef CONFIG_NF_CONNTRACK_PROCFS
@@@ -370,59 -390,5 +429,61 @@@
  		.nla_policy	= gre_timeout_nla_policy,
  	},
  #endif /* CONFIG_NF_CONNTRACK_TIMEOUT */
- 	.net_id		= &proto_gre_net_id,
  	.init_net	= gre_init_net,
  };
++<<<<<<< HEAD
 +
 +static int proto_gre_net_init(struct net *net)
 +{
 +	int ret = 0;
 +
 +	ret = nf_ct_l4proto_pernet_register_one(net,
 +						&nf_conntrack_l4proto_gre4);
 +	if (ret < 0)
 +		pr_err("nf_conntrack_gre4: pernet registration failed.\n");
 +	return ret;
 +}
 +
 +static void proto_gre_net_exit(struct net *net)
 +{
 +	nf_ct_l4proto_pernet_unregister_one(net, &nf_conntrack_l4proto_gre4);
 +	nf_ct_gre_keymap_flush(net);
 +}
 +
 +static struct pernet_operations proto_gre_net_ops = {
 +	.init = proto_gre_net_init,
 +	.exit = proto_gre_net_exit,
 +	.id   = &proto_gre_net_id,
 +	.size = sizeof(struct netns_proto_gre),
 +};
 +
 +static int __init nf_ct_proto_gre_init(void)
 +{
 +	int ret;
 +
 +	ret = register_pernet_subsys(&proto_gre_net_ops);
 +	if (ret < 0)
 +		goto out_pernet;
 +	ret = nf_ct_l4proto_register_one(&nf_conntrack_l4proto_gre4);
 +	if (ret < 0)
 +		goto out_gre4;
 +
 +	return 0;
 +out_gre4:
 +	unregister_pernet_subsys(&proto_gre_net_ops);
 +out_pernet:
 +	return ret;
 +}
 +
 +static void __exit nf_ct_proto_gre_fini(void)
 +{
 +	nf_ct_l4proto_unregister_one(&nf_conntrack_l4proto_gre4);
 +	unregister_pernet_subsys(&proto_gre_net_ops);
 +}
 +
 +module_init(nf_ct_proto_gre_init);
 +module_exit(nf_ct_proto_gre_fini);
 +
 +MODULE_LICENSE("GPL");
++=======
++>>>>>>> 22fc4c4c9fd6 (netfilter: conntrack: gre: switch module to be built-in)
diff --cc net/netfilter/nfnetlink_cttimeout.c
index 6720dbb70442,0e3e1a018206..000000000000
--- a/net/netfilter/nfnetlink_cttimeout.c
+++ b/net/netfilter/nfnetlink_cttimeout.c
@@@ -460,14 -442,52 +460,53 @@@ static int cttimeout_default_get(struc
  
  	l3num = ntohs(nla_get_be16(cda[CTA_TIMEOUT_L3PROTO]));
  	l4num = nla_get_u8(cda[CTA_TIMEOUT_L4PROTO]);
 -	l4proto = nf_ct_l4proto_find_get(l4num);
 +	l4proto = nf_ct_l4proto_find_get(l3num, l4num);
  
 -	err = -EOPNOTSUPP;
 -	if (l4proto->l4proto != l4num)
 +	/* This protocol is not supported, skip. */
 +	if (l4proto->l4proto != l4num) {
 +		err = -EOPNOTSUPP;
  		goto err;
++<<<<<<< HEAD
++=======
+ 
+ 	switch (l4proto->l4proto) {
+ 	case IPPROTO_ICMP:
+ 		timeouts = &nf_icmp_pernet(net)->timeout;
+ 		break;
+ 	case IPPROTO_TCP:
+ 		timeouts = nf_tcp_pernet(net)->timeouts;
+ 		break;
+ 	case IPPROTO_UDP: /* fallthrough */
+ 	case IPPROTO_UDPLITE:
+ 		timeouts = nf_udp_pernet(net)->timeouts;
+ 		break;
+ 	case IPPROTO_DCCP:
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 		timeouts = nf_dccp_pernet(net)->dccp_timeout;
+ #endif
+ 		break;
+ 	case IPPROTO_ICMPV6:
+ 		timeouts = &nf_icmpv6_pernet(net)->timeout;
+ 		break;
+ 	case IPPROTO_SCTP:
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ 		timeouts = nf_sctp_pernet(net)->timeouts;
+ #endif
+ 		break;
+ 	case IPPROTO_GRE:
+ #ifdef CONFIG_NF_CT_PROTO_GRE
+ 		timeouts = nf_gre_pernet(net)->timeouts;
+ #endif
+ 		break;
+ 	case 255:
+ 		timeouts = &nf_generic_pernet(net)->timeout;
+ 		break;
+ 	default:
+ 		WARN_ONCE(1, "Missing timeouts for proto %d", l4proto->l4proto);
+ 		break;
++>>>>>>> 22fc4c4c9fd6 (netfilter: conntrack: gre: switch module to be built-in)
  	}
  
 -	if (!timeouts)
 -		goto err;
 -
  	skb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
  	if (skb2 == NULL) {
  		err = -ENOMEM;
* Unmerged path include/linux/netfilter/nf_conntrack_proto_gre.h
diff --git a/include/net/netfilter/ipv4/nf_conntrack_ipv4.h b/include/net/netfilter/ipv4/nf_conntrack_ipv4.h
index 73f825732326..439e1b5b78c5 100644
--- a/include/net/netfilter/ipv4/nf_conntrack_ipv4.h
+++ b/include/net/netfilter/ipv4/nf_conntrack_ipv4.h
@@ -25,6 +25,9 @@ extern const struct nf_conntrack_l4proto nf_conntrack_l4proto_sctp4;
 #ifdef CONFIG_NF_CT_PROTO_UDPLITE
 extern const struct nf_conntrack_l4proto nf_conntrack_l4proto_udplite4;
 #endif
+#ifdef CONFIG_NF_CT_PROTO_GRE
+extern const struct nf_conntrack_l4proto nf_conntrack_l4proto_gre;
+#endif
 
 int nf_conntrack_ipv4_compat_init(void);
 void nf_conntrack_ipv4_compat_fini(void);
* Unmerged path include/net/netfilter/nf_conntrack_l4proto.h
diff --git a/include/net/netns/conntrack.h b/include/net/netns/conntrack.h
index 9795d628a127..a8233fc69c98 100644
--- a/include/net/netns/conntrack.h
+++ b/include/net/netns/conntrack.h
@@ -70,6 +70,20 @@ struct nf_sctp_net {
 };
 #endif
 
+#ifdef CONFIG_NF_CT_PROTO_GRE
+enum gre_conntrack {
+	GRE_CT_UNREPLIED,
+	GRE_CT_REPLIED,
+	GRE_CT_MAX
+};
+
+struct nf_gre_net {
+	struct nf_proto_net	nf;
+	struct list_head	keymap_list;
+	unsigned int		timeouts[GRE_CT_MAX];
+};
+#endif
+
 struct nf_ip_net {
 	struct nf_generic_net   generic;
 	struct nf_tcp_net	tcp;
@@ -82,6 +96,9 @@ struct nf_ip_net {
 #ifdef CONFIG_NF_CT_PROTO_SCTP
 	struct nf_sctp_net	sctp;
 #endif
+#ifdef CONFIG_NF_CT_PROTO_GRE
+	struct nf_gre_net	gre;
+#endif
 };
 
 struct ct_pcpu {
diff --git a/net/netfilter/Kconfig b/net/netfilter/Kconfig
index 0afbf3b2f362..363ec371e62a 100644
--- a/net/netfilter/Kconfig
+++ b/net/netfilter/Kconfig
@@ -164,7 +164,7 @@ config NF_CT_PROTO_DCCP
 	  If unsure, say Y.
 
 config NF_CT_PROTO_GRE
-	tristate
+	bool
 
 config NF_CT_PROTO_SCTP
 	bool 'SCTP protocol connection tracking support'
diff --git a/net/netfilter/Makefile b/net/netfilter/Makefile
index c1b6a98afe92..8ccdc65c6063 100644
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@ -8,6 +8,7 @@ nf_conntrack-$(CONFIG_NF_CONNTRACK_EVENTS) += nf_conntrack_ecache.o
 nf_conntrack-$(CONFIG_NF_CONNTRACK_LABELS) += nf_conntrack_labels.o
 nf_conntrack-$(CONFIG_NF_CT_PROTO_DCCP) += nf_conntrack_proto_dccp.o
 nf_conntrack-$(CONFIG_NF_CT_PROTO_SCTP) += nf_conntrack_proto_sctp.o
+nf_conntrack-$(CONFIG_NF_CT_PROTO_GRE) += nf_conntrack_proto_gre.o
 
 obj-$(CONFIG_NETFILTER) = netfilter.o
 
@@ -19,8 +20,6 @@ obj-$(CONFIG_NETFILTER_NETLINK_LOG) += nfnetlink_log.o
 # connection tracking
 obj-$(CONFIG_NF_CONNTRACK) += nf_conntrack.o
 
-obj-$(CONFIG_NF_CT_PROTO_GRE) += nf_conntrack_proto_gre.o
-
 # netlink interface for nf_conntrack
 obj-$(CONFIG_NF_CT_NETLINK) += nf_conntrack_netlink.o
 obj-$(CONFIG_NF_CT_NETLINK_TIMEOUT) += nfnetlink_cttimeout.o
* Unmerged path net/netfilter/nf_conntrack_proto.c
* Unmerged path net/netfilter/nf_conntrack_proto_gre.c
* Unmerged path net/netfilter/nfnetlink_cttimeout.c
