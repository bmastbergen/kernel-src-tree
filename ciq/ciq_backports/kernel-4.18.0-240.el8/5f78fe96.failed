net/smc: simplify normal link termination

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Karsten Graul <kgraul@linux.ibm.com>
commit 5f78fe968d76902944534db85c4fb244dedc87f4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5f78fe96.failed

smc_lgr_terminate() and smc_lgr_terminate_sched() both result in soft
link termination, smc_lgr_terminate_sched() is scheduling a worker for
this task. Take out complexity by always using the termination worker
and getting rid of smc_lgr_terminate() completely.

	Signed-off-by: Karsten Graul <kgraul@linux.ibm.com>
	Signed-off-by: Ursula Braun <ubraun@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5f78fe968d76902944534db85c4fb244dedc87f4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/smc/smc_clc.c
#	net/smc/smc_core.c
#	net/smc/smc_core.h
#	net/smc/smc_llc.c
diff --cc net/smc/smc_clc.c
index 86cccc24e52e,3e16b887cfcf..000000000000
--- a/net/smc/smc_clc.c
+++ b/net/smc/smc_clc.c
@@@ -349,7 -349,7 +349,11 @@@ int smc_clc_wait_msg(struct smc_sock *s
  		smc->peer_diagnosis = ntohl(dclc->peer_diagnosis);
  		if (((struct smc_clc_msg_decline *)buf)->hdr.flag) {
  			smc->conn.lgr->sync_err = 1;
++<<<<<<< HEAD
 +			smc_lgr_terminate(smc->conn.lgr, true);
++=======
+ 			smc_lgr_terminate_sched(smc->conn.lgr);
++>>>>>>> 5f78fe968d76 (net/smc: simplify normal link termination)
  		}
  	}
  
diff --cc net/smc/smc_core.c
index 1e15eaf5ae93,1bbce5531014..000000000000
--- a/net/smc/smc_core.c
+++ b/net/smc/smc_core.c
@@@ -240,7 -230,7 +241,11 @@@ static void smc_lgr_terminate_work(stru
  	struct smc_link_group *lgr = container_of(work, struct smc_link_group,
  						  terminate_work);
  
++<<<<<<< HEAD
 +	smc_lgr_terminate(lgr, true);
++=======
+ 	__smc_lgr_terminate(lgr, true);
++>>>>>>> 5f78fe968d76 (net/smc: simplify normal link termination)
  }
  
  /* create a new SMC link group */
@@@ -630,11 -623,8 +635,16 @@@ static void __smc_lgr_terminate(struct 
  		smc_lgr_free(lgr);
  }
  
++<<<<<<< HEAD
 +/* unlink and terminate link group
 + * @soft: true if link group shutdown can take its time
 + *	  false if immediate link group shutdown is required
 + */
 +void smc_lgr_terminate(struct smc_link_group *lgr, bool soft)
++=======
+ /* unlink link group and schedule termination */
+ void smc_lgr_terminate_sched(struct smc_link_group *lgr)
++>>>>>>> 5f78fe968d76 (net/smc: simplify normal link termination)
  {
  	spinlock_t *lgr_lock;
  
@@@ -644,11 -634,9 +654,15 @@@
  		spin_unlock_bh(lgr_lock);
  		return;	/* lgr already terminating */
  	}
 +	if (!soft)
 +		lgr->freeing = 1;
  	list_del_init(&lgr->list);
  	spin_unlock_bh(lgr_lock);
++<<<<<<< HEAD
 +	__smc_lgr_terminate(lgr, soft);
++=======
+ 	schedule_work(&lgr->terminate_work);
++>>>>>>> 5f78fe968d76 (net/smc: simplify normal link termination)
  }
  
  /* Called when IB port is terminated */
diff --cc net/smc/smc_core.h
index 234ae25f0025,5695c7bc639e..000000000000
--- a/net/smc/smc_core.h
+++ b/net/smc/smc_core.h
@@@ -296,8 -290,7 +290,12 @@@ struct smc_clc_msg_accept_confirm
  struct smc_clc_msg_local;
  
  void smc_lgr_forget(struct smc_link_group *lgr);
++<<<<<<< HEAD
 +void smc_lgr_cleanup_early(struct smc_connection *conn);
 +void smc_lgr_terminate(struct smc_link_group *lgr, bool soft);
++=======
+ void smc_lgr_terminate_sched(struct smc_link_group *lgr);
++>>>>>>> 5f78fe968d76 (net/smc: simplify normal link termination)
  void smc_port_terminate(struct smc_ib_device *smcibdev, u8 ibport);
  void smc_smcd_terminate(struct smcd_dev *dev, u64 peer_gid,
  			unsigned short vlan);
diff --cc net/smc/smc_llc.c
index a9f6431dd69a,0e52aab53d97..000000000000
--- a/net/smc/smc_llc.c
+++ b/net/smc/smc_llc.c
@@@ -614,7 -614,7 +614,11 @@@ static void smc_llc_testlink_work(struc
  	rc = wait_for_completion_interruptible_timeout(&link->llc_testlink_resp,
  						       SMC_LLC_WAIT_TIME);
  	if (rc <= 0) {
++<<<<<<< HEAD
 +		smc_lgr_terminate(smc_get_lgr(link), true);
++=======
+ 		smc_lgr_terminate_sched(smc_get_lgr(link));
++>>>>>>> 5f78fe968d76 (net/smc: simplify normal link termination)
  		return;
  	}
  	next_interval = link->llc_testlink_time;
* Unmerged path net/smc/smc_clc.c
* Unmerged path net/smc/smc_core.c
* Unmerged path net/smc/smc_core.h
* Unmerged path net/smc/smc_llc.c
