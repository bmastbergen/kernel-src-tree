s390/qeth: cancel RX reclaim work earlier

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 0e635c2a8713e3e013b4adcb7cb7e28a048b7c42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0e635c2a.failed

When qeth's napi poll code fails to refill an entirely empty RX ring, it
kicks off buffer_reclaim_work to try again later.

Make sure that this worker is cancelled when setting the qeth device
offline. Otherwise a RX refill action can unexpectedly end up running
concurrently to bigger re-configurations (eg. resizing the buffer pool),
without any locking.

Fixes: b333293058aa ("qeth: add support for af_iucv HiperSockets transport")
	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0e635c2a8713e3e013b4adcb7cb7e28a048b7c42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_l2_main.c
#	drivers/s390/net/qeth_l3_main.c
diff --cc drivers/s390/net/qeth_l2_main.c
index 36bc065802db,8fb29371788b..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -284,11 -283,8 +284,15 @@@ static void qeth_l2_stop_card(struct qe
  
  	if (card->state == CARD_STATE_SOFTSETUP) {
  		qeth_clear_ipacmd_list(card);
 +		card->state = CARD_STATE_HARDSETUP;
 +	}
 +	if (card->state == CARD_STATE_HARDSETUP) {
  		qeth_drain_output_queues(card);
++<<<<<<< HEAD
 +		qeth_clear_working_pool_list(card);
++=======
+ 		cancel_delayed_work_sync(&card->buffer_reclaim_work);
++>>>>>>> 0e635c2a8713 (s390/qeth: cancel RX reclaim work earlier)
  		card->state = CARD_STATE_DOWN;
  	}
  
diff --cc drivers/s390/net/qeth_l3_main.c
index 935fc014dd72,82f800d1d7b3..000000000000
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@@ -1306,11 -1177,8 +1306,15 @@@ static void qeth_l3_stop_card(struct qe
  	if (card->state == CARD_STATE_SOFTSETUP) {
  		qeth_l3_clear_ip_htable(card, 1);
  		qeth_clear_ipacmd_list(card);
 +		card->state = CARD_STATE_HARDSETUP;
 +	}
 +	if (card->state == CARD_STATE_HARDSETUP) {
  		qeth_drain_output_queues(card);
++<<<<<<< HEAD
 +		qeth_clear_working_pool_list(card);
++=======
+ 		cancel_delayed_work_sync(&card->buffer_reclaim_work);
++>>>>>>> 0e635c2a8713 (s390/qeth: cancel RX reclaim work earlier)
  		card->state = CARD_STATE_DOWN;
  	}
  
diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c
index bd154899d429..ca86ceff4594 100644
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -2402,7 +2402,6 @@ static void qeth_free_qdio_queues(struct qeth_card *card)
 		return;
 
 	qeth_free_cq(card);
-	cancel_delayed_work_sync(&card->buffer_reclaim_work);
 	for (j = 0; j < QDIO_MAX_BUFFERS_PER_Q; ++j) {
 		if (card->qdio.in_q->bufs[j].rx_skb)
 			dev_kfree_skb_any(card->qdio.in_q->bufs[j].rx_skb);
* Unmerged path drivers/s390/net/qeth_l2_main.c
* Unmerged path drivers/s390/net/qeth_l3_main.c
