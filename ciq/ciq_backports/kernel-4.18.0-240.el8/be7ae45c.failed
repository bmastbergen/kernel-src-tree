gpio: fix getting nonexclusive gpiods from DT

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Marco Felsch <m.felsch@pengutronix.de>
commit be7ae45cfea97e787234e00e1a9eb341acacd84e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/be7ae45c.failed

Since commit ec757001c818 ("gpio: Enable nonexclusive gpiods from DT
nodes") we are able to get GPIOD_FLAGS_BIT_NONEXCLUSIVE marked gpios.
Currently the gpiolib uses the wrong flags variable for the check. We
need to check the gpiod_flags instead of the of_gpio_flags else we
return -EBUSY for GPIOD_FLAGS_BIT_NONEXCLUSIVE marked and requested
gpiod's.

Fixes: ec757001c818 gpio: Enable nonexclusive gpiods from DT nodes
	Cc: stable@vger.kernel.org
	Signed-off-by: Marco Felsch <m.felsch@pengutronix.de>
[Bartosz: the function was moved to gpiolib-of.c so updated the patch]
	Signed-off-by: Bartosz Golaszewski <bgolaszewski@baylibre.com>
(cherry picked from commit be7ae45cfea97e787234e00e1a9eb341acacd84e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib-of.c
diff --cc drivers/gpio/gpiolib-of.c
index 85809bb5b516,80ea49f570f4..000000000000
--- a/drivers/gpio/gpiolib-of.c
+++ b/drivers/gpio/gpiolib-of.c
@@@ -229,7 -274,76 +229,80 @@@ int of_get_named_gpio_flags(struct devi
  	else
  		return desc_to_gpio(desc);
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL(of_get_named_gpio_flags);
++=======
+ EXPORT_SYMBOL_GPL(of_get_named_gpio_flags);
+ 
+ /**
+  * gpiod_get_from_of_node() - obtain a GPIO from an OF node
+  * @node:	handle of the OF node
+  * @propname:	name of the DT property representing the GPIO
+  * @index:	index of the GPIO to obtain for the consumer
+  * @dflags:	GPIO initialization flags
+  * @label:	label to attach to the requested GPIO
+  *
+  * Returns:
+  * On successful request the GPIO pin is configured in accordance with
+  * provided @dflags.
+  *
+  * In case of error an ERR_PTR() is returned.
+  */
+ struct gpio_desc *gpiod_get_from_of_node(struct device_node *node,
+ 					 const char *propname, int index,
+ 					 enum gpiod_flags dflags,
+ 					 const char *label)
+ {
+ 	unsigned long lflags = GPIO_LOOKUP_FLAGS_DEFAULT;
+ 	struct gpio_desc *desc;
+ 	enum of_gpio_flags flags;
+ 	bool active_low = false;
+ 	bool single_ended = false;
+ 	bool open_drain = false;
+ 	bool transitory = false;
+ 	int ret;
+ 
+ 	desc = of_get_named_gpiod_flags(node, propname,
+ 					index, &flags);
+ 
+ 	if (!desc || IS_ERR(desc)) {
+ 		return desc;
+ 	}
+ 
+ 	active_low = flags & OF_GPIO_ACTIVE_LOW;
+ 	single_ended = flags & OF_GPIO_SINGLE_ENDED;
+ 	open_drain = flags & OF_GPIO_OPEN_DRAIN;
+ 	transitory = flags & OF_GPIO_TRANSITORY;
+ 
+ 	ret = gpiod_request(desc, label);
+ 	if (ret == -EBUSY && (dflags & GPIOD_FLAGS_BIT_NONEXCLUSIVE))
+ 		return desc;
+ 	if (ret)
+ 		return ERR_PTR(ret);
+ 
+ 	if (active_low)
+ 		lflags |= GPIO_ACTIVE_LOW;
+ 
+ 	if (single_ended) {
+ 		if (open_drain)
+ 			lflags |= GPIO_OPEN_DRAIN;
+ 		else
+ 			lflags |= GPIO_OPEN_SOURCE;
+ 	}
+ 
+ 	if (transitory)
+ 		lflags |= GPIO_TRANSITORY;
+ 
+ 	ret = gpiod_configure_flags(desc, propname, lflags, dflags);
+ 	if (ret < 0) {
+ 		gpiod_put(desc);
+ 		return ERR_PTR(ret);
+ 	}
+ 
+ 	return desc;
+ }
+ EXPORT_SYMBOL_GPL(gpiod_get_from_of_node);
++>>>>>>> be7ae45cfea9 (gpio: fix getting nonexclusive gpiods from DT)
  
  /*
   * The SPI GPIO bindings happened before we managed to establish that GPIO
* Unmerged path drivers/gpio/gpiolib-of.c
