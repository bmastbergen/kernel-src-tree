perf thread: Rename thread->mg to thread->maps

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit fe87797dea79b59e97a4ea67441bf91f2905bf23
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/fe87797d.failed

One more step on the merge of 'struct maps' with 'struct map_groups'.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
Link: https://lkml.kernel.org/n/tip-69vcr8pubpym90skxhmbwhiw@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit fe87797dea79b59e97a4ea67441bf91f2905bf23)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/arch/arm/tests/dwarf-unwind.c
#	tools/perf/arch/arm64/tests/dwarf-unwind.c
#	tools/perf/arch/powerpc/tests/dwarf-unwind.c
#	tools/perf/arch/x86/tests/dwarf-unwind.c
#	tools/perf/builtin-report.c
#	tools/perf/ui/stdio/hist.c
#	tools/perf/util/event.c
#	tools/perf/util/machine.c
#	tools/perf/util/map.c
#	tools/perf/util/thread.c
#	tools/perf/util/thread.h
#	tools/perf/util/vdso.c
diff --cc tools/perf/arch/arm/tests/dwarf-unwind.c
index 2c35e532bc9a,ff0bea660cf9..000000000000
--- a/tools/perf/arch/arm/tests/dwarf-unwind.c
+++ b/tools/perf/arch/arm/tests/dwarf-unwind.c
@@@ -26,7 -26,7 +26,11 @@@ static int sample_ustack(struct perf_sa
  
  	sp = (unsigned long) regs[PERF_REG_ARM_SP];
  
++<<<<<<< HEAD
 +	map = map_groups__find(thread->mg, (u64)sp);
++=======
+ 	map = maps__find(thread->maps, (u64)sp);
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  	if (!map) {
  		pr_debug("failed to get stack map\n");
  		free(buf);
diff --cc tools/perf/arch/arm64/tests/dwarf-unwind.c
index a6a407fa1b8b,85108437b3af..000000000000
--- a/tools/perf/arch/arm64/tests/dwarf-unwind.c
+++ b/tools/perf/arch/arm64/tests/dwarf-unwind.c
@@@ -26,7 -26,7 +26,11 @@@ static int sample_ustack(struct perf_sa
  
  	sp = (unsigned long) regs[PERF_REG_ARM64_SP];
  
++<<<<<<< HEAD
 +	map = map_groups__find(thread->mg, (u64)sp);
++=======
+ 	map = maps__find(thread->maps, (u64)sp);
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  	if (!map) {
  		pr_debug("failed to get stack map\n");
  		free(buf);
diff --cc tools/perf/arch/powerpc/tests/dwarf-unwind.c
index 5c178e4a1995,30658e3b32b2..000000000000
--- a/tools/perf/arch/powerpc/tests/dwarf-unwind.c
+++ b/tools/perf/arch/powerpc/tests/dwarf-unwind.c
@@@ -27,7 -27,7 +27,11 @@@ static int sample_ustack(struct perf_sa
  
  	sp = (unsigned long) regs[PERF_REG_POWERPC_R1];
  
++<<<<<<< HEAD
 +	map = map_groups__find(thread->mg, (u64)sp);
++=======
+ 	map = maps__find(thread->maps, (u64)sp);
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  	if (!map) {
  		pr_debug("failed to get stack map\n");
  		free(buf);
diff --cc tools/perf/arch/x86/tests/dwarf-unwind.c
index 6ad0a1cedb13,418969cd64e9..000000000000
--- a/tools/perf/arch/x86/tests/dwarf-unwind.c
+++ b/tools/perf/arch/x86/tests/dwarf-unwind.c
@@@ -27,7 -27,7 +27,11 @@@ static int sample_ustack(struct perf_sa
  
  	sp = (unsigned long) regs[PERF_REG_X86_SP];
  
++<<<<<<< HEAD
 +	map = map_groups__find(thread->mg, (u64)sp);
++=======
+ 	map = maps__find(thread->maps, (u64)sp);
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  	if (!map) {
  		pr_debug("failed to get stack map\n");
  		free(buf);
diff --cc tools/perf/builtin-report.c
index 914e3c341a48,830d563de889..000000000000
--- a/tools/perf/builtin-report.c
+++ b/tools/perf/builtin-report.c
@@@ -752,7 -790,7 +752,11 @@@ static void task__print_level(struct ta
  
  	fprintf(fp, "%s\n", thread__comm_str(thread));
  
++<<<<<<< HEAD
 +	map_groups__fprintf_task(thread->mg, comm_indent, fp);
++=======
+ 	maps__fprintf_task(thread->maps, comm_indent, fp);
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  
  	if (!list_empty(&task->children)) {
  		list_for_each_entry(child, &task->children, list)
diff --cc tools/perf/ui/stdio/hist.c
index 51ed67548b83,161d8342ce05..000000000000
--- a/tools/perf/ui/stdio/hist.c
+++ b/tools/perf/ui/stdio/hist.c
@@@ -856,7 -885,7 +856,11 @@@ size_t hists__fprintf(struct hists *his
  		}
  
  		if (h->ms.map == NULL && verbose > 1) {
++<<<<<<< HEAD
 +			map_groups__fprintf(h->thread->mg, fp);
++=======
+ 			maps__fprintf(h->thread->maps, fp);
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  			fprintf(fp, "%.10s end\n", graph_dotted_line);
  		}
  	}
diff --cc tools/perf/util/event.c
index 8a8363d72082,2f0b77366cc0..000000000000
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@@ -1557,7 -457,7 +1557,11 @@@ int perf_event__process(struct perf_too
  struct map *thread__find_map(struct thread *thread, u8 cpumode, u64 addr,
  			     struct addr_location *al)
  {
++<<<<<<< HEAD
 +	struct map_groups *mg = thread->mg;
++=======
+ 	struct maps *mg = thread->maps;
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  	struct machine *machine = mg->machine;
  	bool load_map = false;
  
diff --cc tools/perf/util/machine.c
index 97b56c40a5df,b351476407e6..000000000000
--- a/tools/perf/util/machine.c
+++ b/tools/perf/util/machine.c
@@@ -403,28 -412,28 +403,43 @@@ static void machine__update_thread_pid(
  	if (!leader)
  		goto out_err;
  
++<<<<<<< HEAD
 +	if (!leader->mg)
 +		leader->mg = map_groups__new(machine);
++=======
+ 	if (!leader->maps)
+ 		leader->maps = maps__new(machine);
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  
- 	if (!leader->mg)
+ 	if (!leader->maps)
  		goto out_err;
  
- 	if (th->mg == leader->mg)
+ 	if (th->maps == leader->maps)
  		return;
  
- 	if (th->mg) {
+ 	if (th->maps) {
  		/*
  		 * Maps are created from MMAP events which provide the pid and
  		 * tid.  Consequently there never should be any maps on a thread
  		 * with an unknown pid.  Just print an error if there are.
  		 */
++<<<<<<< HEAD
 +		if (!map_groups__empty(th->mg))
 +			pr_err("Discarding thread maps for %d:%d\n",
 +			       th->pid_, th->tid);
 +		map_groups__put(th->mg);
 +	}
 +
 +	th->mg = map_groups__get(leader->mg);
++=======
+ 		if (!maps__empty(th->maps))
+ 			pr_err("Discarding thread maps for %d:%d\n",
+ 			       th->pid_, th->tid);
+ 		maps__put(th->maps);
+ 	}
+ 
+ 	th->maps = maps__get(leader->maps);
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  out_put:
  	thread__put(leader);
  	return;
diff --cc tools/perf/util/map.c
index be8418d003b5,39bfed48b7f5..000000000000
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@@ -817,16 -817,15 +817,20 @@@ out
  /*
   * XXX This should not really _copy_ te maps, but refcount them.
   */
 -int maps__clone(struct thread *thread, struct maps *parent)
 +int map_groups__clone(struct thread *thread, struct map_groups *parent)
  {
++<<<<<<< HEAD
 +	struct map_groups *mg = thread->mg;
++=======
+ 	struct maps *mg = thread->maps;
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  	int err = -ENOMEM;
  	struct map *map;
 +	struct maps *maps = &parent->maps;
  
 -	down_read(&parent->lock);
 +	down_read(&maps->lock);
  
 -	maps__for_each_entry(parent, map) {
 +	for (map = maps__first(maps); map; map = map__next(map)) {
  		struct map *new = map__clone(map);
  		if (new == NULL)
  			goto out_unlock;
diff --cc tools/perf/util/thread.c
index d6742492492c,28b719388028..000000000000
--- a/tools/perf/util/thread.c
+++ b/tools/perf/util/thread.c
@@@ -23,11 -24,11 +23,19 @@@ int thread__init_map_groups(struct thre
  	pid_t pid = thread->pid_;
  
  	if (pid == thread->tid || pid == -1) {
++<<<<<<< HEAD
 +		thread->mg = map_groups__new(machine);
 +	} else {
 +		struct thread *leader = __machine__findnew_thread(machine, pid, pid);
 +		if (leader) {
 +			thread->mg = map_groups__get(leader->mg);
++=======
+ 		thread->maps = maps__new(machine);
+ 	} else {
+ 		struct thread *leader = __machine__findnew_thread(machine, pid, pid);
+ 		if (leader) {
+ 			thread->maps = maps__get(leader->maps);
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  			thread__put(leader);
  		}
  	}
@@@ -85,9 -86,9 +93,15 @@@ void thread__delete(struct thread *thre
  
  	thread_stack__free(thread);
  
++<<<<<<< HEAD
 +	if (thread->mg) {
 +		map_groups__put(thread->mg);
 +		thread->mg = NULL;
++=======
+ 	if (thread->maps) {
+ 		maps__put(thread->maps);
+ 		thread->maps = NULL;
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  	}
  	down_write(&thread->namespaces_lock);
  	list_for_each_entry_safe(namespaces, tmp_namespaces,
@@@ -323,7 -324,7 +337,11 @@@ int thread__comm_len(struct thread *thr
  size_t thread__fprintf(struct thread *thread, FILE *fp)
  {
  	return fprintf(fp, "Thread %d %s\n", thread->tid, thread__comm_str(thread)) +
++<<<<<<< HEAD
 +	       map_groups__fprintf(thread->mg, fp);
++=======
+ 	       maps__fprintf(thread->maps, fp);
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  }
  
  int thread__insert_map(struct thread *thread, struct map *map)
@@@ -334,8 -335,8 +352,13 @@@
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
 +	map_groups__fixup_overlappings(thread->mg, map, stderr);
 +	map_groups__insert(thread->mg, map);
++=======
+ 	maps__fixup_overlappings(thread->maps, map, stderr);
+ 	maps__insert(thread->maps, map);
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  
  	return 0;
  }
@@@ -344,13 -345,13 +367,22 @@@ static int __thread__prepare_access(str
  {
  	bool initialized = false;
  	int err = 0;
++<<<<<<< HEAD
 +	struct maps *maps = &thread->mg->maps;
++=======
+ 	struct maps *maps = thread->maps;
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  	struct map *map;
  
  	down_read(&maps->lock);
  
++<<<<<<< HEAD
 +	for (map = maps__first(maps); map; map = map__next(map)) {
 +		err = unwind__prepare_access(thread->mg, map, &initialized);
++=======
+ 	maps__for_each_entry(maps, map) {
+ 		err = unwind__prepare_access(thread->maps, map, &initialized);
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  		if (err || initialized)
  			break;
  	}
@@@ -384,7 -383,7 +416,11 @@@ static int thread__clone_map_groups(str
  		return 0;
  	}
  	/* But this one is new process, copy maps. */
++<<<<<<< HEAD
 +	return do_maps_clone ? map_groups__clone(thread, parent->mg) : 0;
++=======
+ 	return do_maps_clone ? maps__clone(thread, parent->maps) : 0;
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  }
  
  int thread__fork(struct thread *thread, struct thread *parent, u64 timestamp, bool do_maps_clone)
diff --cc tools/perf/util/thread.h
index bf06113be4f3,20b96b5d1f15..000000000000
--- a/tools/perf/util/thread.h
+++ b/tools/perf/util/thread.h
@@@ -25,7 -25,7 +25,11 @@@ struct thread 
  		struct rb_node	 rb_node;
  		struct list_head node;
  	};
++<<<<<<< HEAD
 +	struct map_groups	*mg;
++=======
+ 	struct maps		*maps;
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  	pid_t			pid_; /* Not all tools update this */
  	pid_t			tid;
  	pid_t			ppid;
diff --cc tools/perf/util/vdso.c
index 0f8820b1784b,3cc91ad048ea..000000000000
--- a/tools/perf/util/vdso.c
+++ b/tools/perf/util/vdso.c
@@@ -143,7 -144,7 +143,11 @@@ static enum dso_type machine__thread_ds
  	enum dso_type dso_type = DSO__TYPE_UNKNOWN;
  	struct map *map;
  
++<<<<<<< HEAD
 +	map_groups__for_each_entry(thread->mg, map) {
++=======
+ 	maps__for_each_entry(thread->maps, map) {
++>>>>>>> fe87797dea79 (perf thread: Rename thread->mg to thread->maps)
  		struct dso *dso = map->dso;
  		if (!dso || dso->long_name[0] != '/')
  			continue;
* Unmerged path tools/perf/arch/arm/tests/dwarf-unwind.c
* Unmerged path tools/perf/arch/arm64/tests/dwarf-unwind.c
* Unmerged path tools/perf/arch/powerpc/tests/dwarf-unwind.c
* Unmerged path tools/perf/arch/x86/tests/dwarf-unwind.c
* Unmerged path tools/perf/builtin-report.c
diff --git a/tools/perf/tests/code-reading.c b/tools/perf/tests/code-reading.c
index aa6df122b175..2ff2058ed3fe 100644
--- a/tools/perf/tests/code-reading.c
+++ b/tools/perf/tests/code-reading.c
@@ -267,7 +267,7 @@ static int read_object_code(u64 addr, size_t len, u8 cpumode,
 		len = al.map->end - addr;
 
 	/* Read the object code using perf */
-	ret_len = dso__data_read_offset(al.map->dso, thread->mg->machine,
+	ret_len = dso__data_read_offset(al.map->dso, thread->maps->machine,
 					al.addr, buf1, len);
 	if (ret_len != len) {
 		pr_debug("dso__data_read_offset failed\n");
diff --git a/tools/perf/tests/thread-mg-share.c b/tools/perf/tests/thread-mg-share.c
index cbac71716dec..08dab1be4477 100644
--- a/tools/perf/tests/thread-mg-share.c
+++ b/tools/perf/tests/thread-mg-share.c
@@ -42,13 +42,13 @@ int test__thread_mg_share(struct test *test __maybe_unused, int subtest __maybe_
 	TEST_ASSERT_VAL("failed to create threads",
 			leader && t1 && t2 && t3 && other);
 
-	mg = leader->mg;
+	mg = leader->maps;
 	TEST_ASSERT_EQUAL("wrong refcnt", refcount_read(&mg->refcnt), 4);
 
 	/* test the map groups pointer is shared */
-	TEST_ASSERT_VAL("map groups don't match", mg == t1->mg);
-	TEST_ASSERT_VAL("map groups don't match", mg == t2->mg);
-	TEST_ASSERT_VAL("map groups don't match", mg == t3->mg);
+	TEST_ASSERT_VAL("map groups don't match", mg == t1->maps);
+	TEST_ASSERT_VAL("map groups don't match", mg == t2->maps);
+	TEST_ASSERT_VAL("map groups don't match", mg == t3->maps);
 
 	/*
 	 * Verify the other leader was created by previous call.
@@ -70,10 +70,10 @@ int test__thread_mg_share(struct test *test __maybe_unused, int subtest __maybe_
 	machine__remove_thread(machine, other);
 	machine__remove_thread(machine, other_leader);
 
-	other_mg = other->mg;
+	other_mg = other->maps;
 	TEST_ASSERT_EQUAL("wrong refcnt", refcount_read(&other_mg->refcnt), 2);
 
-	TEST_ASSERT_VAL("map groups don't match", other_mg == other_leader->mg);
+	TEST_ASSERT_VAL("map groups don't match", other_mg == other_leader->maps);
 
 	/* release thread group */
 	thread__put(leader);
* Unmerged path tools/perf/ui/stdio/hist.c
diff --git a/tools/perf/util/db-export.c b/tools/perf/util/db-export.c
index ef945a31d692..985e85eaa950 100644
--- a/tools/perf/util/db-export.c
+++ b/tools/perf/util/db-export.c
@@ -259,7 +259,7 @@ static struct call_path *call_path_from_sample(struct db_export *dbe,
 		 */
 		al.sym = node->ms.sym;
 		al.map = node->ms.map;
-		al.mg  = thread->mg;
+		al.mg  = thread->maps;
 		al.addr = node->ip;
 
 		if (al.map && !al.sym)
* Unmerged path tools/perf/util/event.c
* Unmerged path tools/perf/util/machine.c
* Unmerged path tools/perf/util/map.c
diff --git a/tools/perf/util/thread-stack.c b/tools/perf/util/thread-stack.c
index 3d07eb27d803..26619372b165 100644
--- a/tools/perf/util/thread-stack.c
+++ b/tools/perf/util/thread-stack.c
@@ -142,8 +142,8 @@ static int thread_stack__init(struct thread_stack *ts, struct thread *thread,
 	if (err)
 		return err;
 
-	if (thread->mg && thread->mg->machine) {
-		struct machine *machine = thread->mg->machine;
+	if (thread->maps && thread->maps->machine) {
+		struct machine *machine = thread->maps->machine;
 		const char *arch = perf_env__arch(machine->env);
 
 		ts->kernel_start = machine__kernel_start(machine);
* Unmerged path tools/perf/util/thread.c
* Unmerged path tools/perf/util/thread.h
diff --git a/tools/perf/util/unwind-libdw.c b/tools/perf/util/unwind-libdw.c
index c1679f08d22f..431ac6caf58a 100644
--- a/tools/perf/util/unwind-libdw.c
+++ b/tools/perf/util/unwind-libdw.c
@@ -199,7 +199,7 @@ int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
 	struct unwind_info *ui, ui_buf = {
 		.sample		= data,
 		.thread		= thread,
-		.machine	= thread->mg->machine,
+		.machine	= thread->maps->machine,
 		.cb		= cb,
 		.arg		= arg,
 		.max_stack	= max_stack,
diff --git a/tools/perf/util/unwind-libunwind-local.c b/tools/perf/util/unwind-libunwind-local.c
index aaf7a445c595..792aa014b7a8 100644
--- a/tools/perf/util/unwind-libunwind-local.c
+++ b/tools/perf/util/unwind-libunwind-local.c
@@ -660,7 +660,7 @@ static int get_entries(struct unwind_info *ui, unwind_entry_cb_t cb,
 	 */
 	if (max_stack - 1 > 0) {
 		WARN_ONCE(!ui->thread, "WARNING: ui->thread is NULL");
-		addr_space = ui->thread->mg->addr_space;
+		addr_space = ui->thread->maps->addr_space;
 
 		if (addr_space == NULL)
 			return -1;
@@ -709,7 +709,7 @@ static int _unwind__get_entries(unwind_entry_cb_t cb, void *arg,
 	struct unwind_info ui = {
 		.sample       = data,
 		.thread       = thread,
-		.machine      = thread->mg->machine,
+		.machine      = thread->maps->machine,
 	};
 
 	if (!data->user_regs.regs)
diff --git a/tools/perf/util/unwind-libunwind.c b/tools/perf/util/unwind-libunwind.c
index 6499b22b158b..0d1201d9e754 100644
--- a/tools/perf/util/unwind-libunwind.c
+++ b/tools/perf/util/unwind-libunwind.c
@@ -83,7 +83,7 @@ int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
 			 struct thread *thread,
 			 struct perf_sample *data, int max_stack)
 {
-	if (thread->mg->unwind_libunwind_ops)
-		return thread->mg->unwind_libunwind_ops->get_entries(cb, arg, thread, data, max_stack);
+	if (thread->maps->unwind_libunwind_ops)
+		return thread->maps->unwind_libunwind_ops->get_entries(cb, arg, thread, data, max_stack);
 	return 0;
 }
* Unmerged path tools/perf/util/vdso.c
