nvme: redirect commands on dying queue

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Chao Leng <lengchao@huawei.com>
commit 5eac5f3342b20825260d3800e7f5f74f12bac931
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5eac5f33.failed

If a command send through nvme-multipath failed on a dying queue, resend it
on another path.

	Signed-off-by: Chao Leng <lengchao@huawei.com>
[hch: rebased on top of the completion refactoring]
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Reviewed-by: Mike Snitzer <snitzer@redhat.com>
	Signed-off-by: Sagi Grimberg <sagi@grimberg.me>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 5eac5f3342b20825260d3800e7f5f74f12bac931)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index 54bfa09c007b,c9826ecf80e2..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -259,11 -257,51 +259,55 @@@ static void nvme_retry_req(struct reque
  	blk_mq_delay_kick_requeue_list(req->q, delay);
  }
  
++<<<<<<< HEAD
++=======
+ enum nvme_disposition {
+ 	COMPLETE,
+ 	RETRY,
+ 	FAILOVER,
+ };
+ 
+ static inline enum nvme_disposition nvme_decide_disposition(struct request *req)
+ {
+ 	if (likely(nvme_req(req)->status == 0))
+ 		return COMPLETE;
+ 
+ 	if (blk_noretry_request(req) ||
+ 	    (nvme_req(req)->status & NVME_SC_DNR) ||
+ 	    nvme_req(req)->retries >= nvme_max_retries)
+ 		return COMPLETE;
+ 
+ 	if (req->cmd_flags & REQ_NVME_MPATH) {
+ 		if (nvme_is_path_error(nvme_req(req)->status) ||
+ 		    blk_queue_dying(req->q))
+ 			return FAILOVER;
+ 	} else {
+ 		if (blk_queue_dying(req->q))
+ 			return COMPLETE;
+ 	}
+ 
+ 	return RETRY;
+ }
+ 
+ static inline void nvme_end_req(struct request *req)
+ {
+ 	blk_status_t status = nvme_error_status(nvme_req(req)->status);
+ 
+ 	if (IS_ENABLED(CONFIG_BLK_DEV_ZONED) &&
+ 	    req_op(req) == REQ_OP_ZONE_APPEND)
+ 		req->__sector = nvme_lba_to_sect(req->q->queuedata,
+ 			le64_to_cpu(nvme_req(req)->result.u64));
+ 
+ 	nvme_trace_bio_complete(req, status);
+ 	blk_mq_end_request(req, status);
+ }
+ 
++>>>>>>> 5eac5f3342b2 (nvme: redirect commands on dying queue)
  void nvme_complete_rq(struct request *req)
  {
 +	blk_status_t status = nvme_error_status(req);
 +
  	trace_nvme_complete_rq(req);
 -	nvme_cleanup_cmd(req);
  
  	if (nvme_req(req)->ctrl->kas)
  		nvme_req(req)->ctrl->comp_seen = true;
* Unmerged path drivers/nvme/host/core.c
