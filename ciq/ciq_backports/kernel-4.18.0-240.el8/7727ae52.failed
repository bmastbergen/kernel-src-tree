ext4: fix potential use after free after remounting with noblock_validity

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author zhangyi (F) <yi.zhang@huawei.com>
commit 7727ae52975d4f4ef7ff69ed8e6e25f6a4168158
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7727ae52.failed

Remount process will release system zone which was allocated before if
"noblock_validity" is specified. If we mount an ext4 file system to two
mountpoints with default mount options, and then remount one of them
with "noblock_validity", it may trigger a use after free problem when
someone accessing the other one.

 # mount /dev/sda foo
 # mount /dev/sda bar

User access mountpoint "foo"   |   Remount mountpoint "bar"
                               |
ext4_map_blocks()              |   ext4_remount()
check_block_validity()         |   ext4_setup_system_zone()
ext4_data_block_valid()        |   ext4_release_system_zone()
                               |   free system_blks rb nodes
access system_blks rb nodes    |
trigger use after free         |

This problem can also be reproduced by one mountpint, At the same time,
add_system_zone() can get called during remount as well so there can be
racing ext4_data_block_valid() reading the rbtree at the same time.

This patch add RCU to protect system zone from releasing or building
when doing a remount which inverse current "noblock_validity" mount
option. It assign the rbtree after the whole tree was complete and
do actual freeing after rcu grace period, avoid any intermediate state.

	Reported-by: syzbot+1e470567330b7ad711d5@syzkaller.appspotmail.com
	Signed-off-by: zhangyi (F) <yi.zhang@huawei.com>
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Reviewed-by: Jan Kara <jack@suse.cz>
(cherry picked from commit 7727ae52975d4f4ef7ff69ed8e6e25f6a4168158)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/block_validity.c
diff --cc fs/ext4/block_validity.c
index 64c1310e4364,d4d4fdfac1a6..000000000000
--- a/fs/ext4/block_validity.c
+++ b/fs/ext4/block_validity.c
@@@ -137,6 -147,108 +147,111 @@@ static void debug_print_tree(struct ext
  	printk(KERN_CONT "\n");
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Returns 1 if the passed-in block region (start_blk,
+  * start_blk+count) is valid; 0 if some part of the block region
+  * overlaps with filesystem metadata blocks.
+  */
+ static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,
+ 				     struct ext4_system_blocks *system_blks,
+ 				     ext4_fsblk_t start_blk,
+ 				     unsigned int count)
+ {
+ 	struct ext4_system_zone *entry;
+ 	struct rb_node *n;
+ 
+ 	if ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
+ 	    (start_blk + count < start_blk) ||
+ 	    (start_blk + count > ext4_blocks_count(sbi->s_es))) {
+ 		sbi->s_es->s_last_error_block = cpu_to_le64(start_blk);
+ 		return 0;
+ 	}
+ 
+ 	if (system_blks == NULL)
+ 		return 1;
+ 
+ 	n = system_blks->root.rb_node;
+ 	while (n) {
+ 		entry = rb_entry(n, struct ext4_system_zone, node);
+ 		if (start_blk + count - 1 < entry->start_blk)
+ 			n = n->rb_left;
+ 		else if (start_blk >= (entry->start_blk + entry->count))
+ 			n = n->rb_right;
+ 		else {
+ 			sbi->s_es->s_last_error_block = cpu_to_le64(start_blk);
+ 			return 0;
+ 		}
+ 	}
+ 	return 1;
+ }
+ 
+ static int ext4_protect_reserved_inode(struct super_block *sb,
+ 				       struct ext4_system_blocks *system_blks,
+ 				       u32 ino)
+ {
+ 	struct inode *inode;
+ 	struct ext4_sb_info *sbi = EXT4_SB(sb);
+ 	struct ext4_map_blocks map;
+ 	u32 i = 0, num;
+ 	int err = 0, n;
+ 
+ 	if ((ino < EXT4_ROOT_INO) ||
+ 	    (ino > le32_to_cpu(sbi->s_es->s_inodes_count)))
+ 		return -EINVAL;
+ 	inode = ext4_iget(sb, ino, EXT4_IGET_SPECIAL);
+ 	if (IS_ERR(inode))
+ 		return PTR_ERR(inode);
+ 	num = (inode->i_size + sb->s_blocksize - 1) >> sb->s_blocksize_bits;
+ 	while (i < num) {
+ 		map.m_lblk = i;
+ 		map.m_len = num - i;
+ 		n = ext4_map_blocks(NULL, inode, &map, 0);
+ 		if (n < 0) {
+ 			err = n;
+ 			break;
+ 		}
+ 		if (n == 0) {
+ 			i++;
+ 		} else {
+ 			if (!ext4_data_block_valid_rcu(sbi, system_blks,
+ 						map.m_pblk, n)) {
+ 				ext4_error(sb, "blocks %llu-%llu from inode %u "
+ 					   "overlap system zone", map.m_pblk,
+ 					   map.m_pblk + map.m_len - 1, ino);
+ 				err = -EFSCORRUPTED;
+ 				break;
+ 			}
+ 			err = add_system_zone(system_blks, map.m_pblk, n);
+ 			if (err < 0)
+ 				break;
+ 			i += n;
+ 		}
+ 	}
+ 	iput(inode);
+ 	return err;
+ }
+ 
+ static void ext4_destroy_system_zone(struct rcu_head *rcu)
+ {
+ 	struct ext4_system_blocks *system_blks;
+ 
+ 	system_blks = container_of(rcu, struct ext4_system_blocks, rcu);
+ 	release_system_zone(system_blks);
+ 	kfree(system_blks);
+ }
+ 
+ /*
+  * Build system zone rbtree which is used for block validity checking.
+  *
+  * The update of system_blks pointer in this function is protected by
+  * sb->s_umount semaphore. However we have to be careful as we can be
+  * racing with ext4_data_block_valid() calls reading system_blks rbtree
+  * protected only by RCU. That's why we first build the rbtree and then
+  * swap it in place.
+  */
++>>>>>>> 7727ae52975d (ext4: fix potential use after free after remounting with noblock_validity)
  int ext4_setup_system_zone(struct super_block *sb)
  {
  	ext4_group_t ngroups = ext4_get_groups_count(sb);
@@@ -158,20 -275,37 +278,40 @@@
  		cond_resched();
  		if (ext4_bg_has_super(sb, i) &&
  		    ((i < 5) || ((i % flex_size) == 0)))
- 			add_system_zone(sbi, ext4_group_first_block_no(sb, i),
+ 			add_system_zone(system_blks,
+ 					ext4_group_first_block_no(sb, i),
  					ext4_bg_num_gdb(sb, i) + 1);
  		gdp = ext4_get_group_desc(sb, i, NULL);
- 		ret = add_system_zone(sbi, ext4_block_bitmap(sb, gdp), 1);
+ 		ret = add_system_zone(system_blks,
+ 				ext4_block_bitmap(sb, gdp), 1);
  		if (ret)
- 			return ret;
- 		ret = add_system_zone(sbi, ext4_inode_bitmap(sb, gdp), 1);
+ 			goto err;
+ 		ret = add_system_zone(system_blks,
+ 				ext4_inode_bitmap(sb, gdp), 1);
  		if (ret)
- 			return ret;
- 		ret = add_system_zone(sbi, ext4_inode_table(sb, gdp),
+ 			goto err;
+ 		ret = add_system_zone(system_blks,
+ 				ext4_inode_table(sb, gdp),
  				sbi->s_itb_per_group);
  		if (ret)
- 			return ret;
+ 			goto err;
  	}
++<<<<<<< HEAD
++=======
+ 	if (ext4_has_feature_journal(sb) && sbi->s_es->s_journal_inum) {
+ 		ret = ext4_protect_reserved_inode(sb, system_blks,
+ 				le32_to_cpu(sbi->s_es->s_journal_inum));
+ 		if (ret)
+ 			goto err;
+ 	}
++>>>>>>> 7727ae52975d (ext4: fix potential use after free after remounting with noblock_validity)
+ 
+ 	/*
+ 	 * System blks rbtree complete, announce it once to prevent racing
+ 	 * with ext4_data_block_valid() accessing the rbtree at the same
+ 	 * time.
+ 	 */
+ 	rcu_assign_pointer(sbi->system_blks, system_blks);
  
  	if (test_opt(sb, DEBUG))
  		debug_print_tree(sbi);
* Unmerged path fs/ext4/block_validity.c
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 37f20cbe92a9..a16dac0ef362 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -183,6 +183,14 @@ struct ext4_map_blocks {
 	unsigned int m_flags;
 };
 
+/*
+ * Block validity checking, system zone rbtree.
+ */
+struct ext4_system_blocks {
+	struct rb_root root;
+	struct rcu_head rcu;
+};
+
 /*
  * Flags for ext4_io_end->flags
  */
@@ -1406,7 +1414,7 @@ struct ext4_sb_info {
 	int s_jquota_fmt;			/* Format of quota to use */
 #endif
 	unsigned int s_want_extra_isize; /* New inodes should reserve # bytes */
-	struct rb_root system_blks;
+	struct ext4_system_blocks __rcu *system_blks;
 
 #ifdef EXTENTS_STATS
 	/* ext4 extents stats */
