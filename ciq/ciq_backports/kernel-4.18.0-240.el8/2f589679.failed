cifs: multichannel: try to rebind when reconnecting a channel

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Aurelien Aptel <aaptel@suse.com>
commit 2f58967979409ea3ec799343aa35e9007f735a3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/2f589679.failed

first steps in trying to make channels properly reconnect.

* add cifs_ses_find_chan() function to find the enclosing cifs_chan
  struct it belongs to
* while we have the session lock and are redoing negprot and
  sess.setup in smb2_reconnect() redo the binding of channels.

	Signed-off-by: Aurelien Aptel <aaptel@suse.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 2f58967979409ea3ec799343aa35e9007f735a3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/smb2pdu.c
diff --cc fs/cifs/smb2pdu.c
index 3bd929177290,ded96b529a4d..000000000000
--- a/fs/cifs/smb2pdu.c
+++ b/fs/cifs/smb2pdu.c
@@@ -355,9 -375,30 +355,33 @@@ smb2_reconnect(__le16 smb2_command, str
  		goto out;
  	}
  
+ 	/*
+ 	 * If we are reconnecting an extra channel, bind
+ 	 */
+ 	if (server->is_channel) {
+ 		ses->binding = true;
+ 		ses->binding_chan = cifs_ses_find_chan(ses, server);
+ 	}
+ 
  	rc = cifs_negotiate_protocol(0, tcon->ses);
 -	if (!rc && tcon->ses->need_reconnect) {
 +	if (!rc && tcon->ses->need_reconnect)
  		rc = cifs_setup_session(0, tcon->ses, nls_codepage);
++<<<<<<< HEAD
++=======
+ 		if ((rc == -EACCES) && !tcon->retry) {
+ 			rc = -EHOSTDOWN;
+ 			ses->binding = false;
+ 			ses->binding_chan = NULL;
+ 			mutex_unlock(&tcon->ses->session_mutex);
+ 			goto failed;
+ 		}
+ 	}
+ 	/*
+ 	 * End of channel binding
+ 	 */
+ 	ses->binding = false;
+ 	ses->binding_chan = NULL;
++>>>>>>> 2f5896797940 (cifs: multichannel: try to rebind when reconnecting a channel)
  
  	if (rc || !tcon->need_reconnect) {
  		mutex_unlock(&tcon->ses->session_mutex);
diff --git a/fs/cifs/cifsproto.h b/fs/cifs/cifsproto.h
index 8fd44645e9b5..5852d74c1dde 100644
--- a/fs/cifs/cifsproto.h
+++ b/fs/cifs/cifsproto.h
@@ -592,6 +592,8 @@ void cifs_free_hash(struct crypto_shash **shash, struct sdesc **sdesc);
 
 extern void rqst_page_get_length(struct smb_rqst *rqst, unsigned int page,
 				unsigned int *len, unsigned int *offset);
+struct cifs_chan *
+cifs_ses_find_chan(struct cifs_ses *ses, struct TCP_Server_Info *server);
 int cifs_try_adding_channels(struct cifs_ses *ses);
 int cifs_ses_add_channel(struct cifs_ses *ses,
 				struct cifs_server_iface *iface);
diff --git a/fs/cifs/sess.c b/fs/cifs/sess.c
index 9a426db21fae..ae6a8125e8cf 100644
--- a/fs/cifs/sess.c
+++ b/fs/cifs/sess.c
@@ -150,6 +150,22 @@ int cifs_try_adding_channels(struct cifs_ses *ses)
 	return ses->chan_count - old_chan_count;
 }
 
+/*
+ * If server is a channel of ses, return the corresponding enclosing
+ * cifs_chan otherwise return NULL.
+ */
+struct cifs_chan *
+cifs_ses_find_chan(struct cifs_ses *ses, struct TCP_Server_Info *server)
+{
+	int i;
+
+	for (i = 0; i < ses->chan_count; i++) {
+		if (ses->chans[i].server == server)
+			return &ses->chans[i];
+	}
+	return NULL;
+}
+
 int
 cifs_ses_add_channel(struct cifs_ses *ses, struct cifs_server_iface *iface)
 {
* Unmerged path fs/cifs/smb2pdu.c
