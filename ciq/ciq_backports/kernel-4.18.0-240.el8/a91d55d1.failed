tipc: enable broadcast retrans via unicast

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Tuong Lien <tuong.t.lien@dektech.com.au>
commit a91d55d162b86fb983b88f44296149752db7efbd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a91d55d1.failed

In some environment, broadcast traffic is suppressed at high rate (i.e.
a kind of bandwidth limit setting). When it is applied, TIPC broadcast
can still run successfully. However, when it comes to a high load, some
packets will be dropped first and TIPC tries to retransmit them but the
packet retransmission is intentionally broadcast too, so making things
worse and not helpful at all.

This commit enables the broadcast retransmission via unicast which only
retransmits packets to the specific peer that has really reported a gap
i.e. not broadcasting to all nodes in the cluster, so will prevent from
being suppressed, and also reduce some overheads on the other peers due
to duplicates, finally improve the overall TIPC broadcast performance.

Note: the functionality can be turned on/off via the sysctl file:

echo 1 > /proc/sys/net/tipc/bc_retruni
echo 0 > /proc/sys/net/tipc/bc_retruni

Default is '0', i.e. the broadcast retransmission still works as usual.

	Acked-by: Ying Xue <ying.xue@windriver.com>
	Acked-by: Jon Maloy <jmaloy@redhat.com>
	Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a91d55d162b86fb983b88f44296149752db7efbd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/tipc/bcast.c
#	net/tipc/link.c
#	net/tipc/link.h
#	net/tipc/sysctl.c
diff --cc net/tipc/bcast.c
index 588c2709f7d2,50a16f8bebd9..000000000000
--- a/net/tipc/bcast.c
+++ b/net/tipc/bcast.c
@@@ -472,7 -475,7 +473,11 @@@ void tipc_bcast_ack_rcv(struct net *net
  	__skb_queue_head_init(&xmitq);
  
  	tipc_bcast_lock(net);
++<<<<<<< HEAD
 +	tipc_link_bc_ack_rcv(l, acked, &xmitq);
++=======
+ 	tipc_link_bc_ack_rcv(l, acked, 0, NULL, &xmitq, NULL);
++>>>>>>> a91d55d162b8 (tipc: enable broadcast retrans via unicast)
  	tipc_bcast_unlock(net);
  
  	tipc_bcbase_xmit(net, &xmitq);
@@@ -487,9 -490,11 +492,10 @@@
   * RCU is locked, no other locks set
   */
  int tipc_bcast_sync_rcv(struct net *net, struct tipc_link *l,
- 			struct tipc_msg *hdr)
+ 			struct tipc_msg *hdr,
+ 			struct sk_buff_head *retrq)
  {
  	struct sk_buff_head *inputq = &tipc_bc_base(net)->inputq;
 -	struct tipc_gap_ack_blks *ga;
  	struct sk_buff_head xmitq;
  	int rc = 0;
  
@@@ -499,8 -504,13 +505,18 @@@
  	if (msg_type(hdr) != STATE_MSG) {
  		tipc_link_bc_init_rcv(l, hdr);
  	} else if (!msg_bc_ack_invalid(hdr)) {
++<<<<<<< HEAD
 +		tipc_link_bc_ack_rcv(l, msg_bcast_ack(hdr), &xmitq);
 +		rc = tipc_link_bc_sync_rcv(l, hdr, &xmitq);
++=======
+ 		tipc_get_gap_ack_blks(&ga, l, hdr, false);
+ 		if (!sysctl_tipc_bc_retruni)
+ 			retrq = &xmitq;
+ 		rc = tipc_link_bc_ack_rcv(l, msg_bcast_ack(hdr),
+ 					  msg_bc_gap(hdr), ga, &xmitq,
+ 					  retrq);
+ 		rc |= tipc_link_bc_sync_rcv(l, hdr, &xmitq);
++>>>>>>> a91d55d162b8 (tipc: enable broadcast retrans via unicast)
  	}
  	tipc_bcast_unlock(net);
  
diff --cc net/tipc/link.c
index 91be69d1779e,af352391e2ab..000000000000
--- a/net/tipc/link.c
+++ b/net/tipc/link.c
@@@ -358,7 -375,7 +358,11 @@@ void tipc_link_remove_bc_peer(struct ti
  	snd_l->ackers--;
  	rcv_l->bc_peer_is_up = true;
  	rcv_l->state = LINK_ESTABLISHED;
++<<<<<<< HEAD
 +	tipc_link_bc_ack_rcv(rcv_l, ack, xmitq);
++=======
+ 	tipc_link_bc_ack_rcv(rcv_l, ack, 0, NULL, xmitq, NULL);
++>>>>>>> a91d55d162b8 (tipc: enable broadcast retrans via unicast)
  	trace_tipc_link_reset(rcv_l, TIPC_DUMP_ALL, "bclink removed!");
  	tipc_link_reset(rcv_l);
  	rcv_l->state = LINK_RESET;
@@@ -2233,38 -2398,29 +2237,50 @@@ int tipc_link_bc_sync_rcv(struct tipc_l
  	return 0;
  }
  
++<<<<<<< HEAD
 +void tipc_link_bc_ack_rcv(struct tipc_link *l, u16 acked,
 +			  struct sk_buff_head *xmitq)
++=======
+ int tipc_link_bc_ack_rcv(struct tipc_link *r, u16 acked, u16 gap,
+ 			 struct tipc_gap_ack_blks *ga,
+ 			 struct sk_buff_head *xmitq,
+ 			 struct sk_buff_head *retrq)
++>>>>>>> a91d55d162b8 (tipc: enable broadcast retrans via unicast)
  {
 -	struct tipc_link *l = r->bc_sndlink;
 -	bool unused = false;
 -	int rc = 0;
 +	struct sk_buff *skb, *tmp;
 +	struct tipc_link *snd_l = l->bc_sndlink;
  
 -	if (!link_is_up(r) || !r->bc_peer_is_up)
 -		return 0;
 +	if (!link_is_up(l) || !l->bc_peer_is_up)
 +		return;
  
 -	if (less(acked, r->acked) || (acked == r->acked && !gap && !ga))
 -		return 0;
 +	if (!more(acked, l->acked))
 +		return;
  
++<<<<<<< HEAD
 +	trace_tipc_link_bc_ack(l, l->acked, acked, &snd_l->transmq);
 +	/* Skip over packets peer has already acked */
 +	skb_queue_walk(&snd_l->transmq, skb) {
 +		if (more(buf_seqno(skb), l->acked))
 +			break;
 +	}
++=======
+ 	trace_tipc_link_bc_ack(r, acked, gap, &l->transmq);
+ 	tipc_link_advance_transmq(l, r, acked, gap, ga, retrq, &unused, &rc);
++>>>>>>> a91d55d162b8 (tipc: enable broadcast retrans via unicast)
  
 -	tipc_link_advance_backlog(l, xmitq);
 -	if (unlikely(!skb_queue_empty(&l->wakeupq)))
 -		link_prepare_wakeup(l);
 -
 -	return rc;
 +	/* Update/release the packets peer is acking now */
 +	skb_queue_walk_from_safe(&snd_l->transmq, skb, tmp) {
 +		if (more(buf_seqno(skb), acked))
 +			break;
 +		if (!--TIPC_SKB_CB(skb)->ackers) {
 +			__skb_unlink(skb, &snd_l->transmq);
 +			kfree_skb(skb);
 +		}
 +	}
 +	l->acked = acked;
 +	tipc_link_advance_backlog(snd_l, xmitq);
 +	if (unlikely(!skb_queue_empty(&snd_l->wakeupq)))
 +		link_prepare_wakeup(snd_l);
  }
  
  /* tipc_link_bc_nack_rcv(): receive broadcast nack message
@@@ -2292,8 -2448,8 +2308,13 @@@ int tipc_link_bc_nack_rcv(struct tipc_l
  		return 0;
  
  	if (dnode == tipc_own_addr(l->net)) {
++<<<<<<< HEAD
 +		tipc_link_bc_ack_rcv(l, acked, xmitq);
 +		rc = tipc_link_bc_retrans(l->bc_sndlink, l, from, to, xmitq);
++=======
+ 		rc = tipc_link_bc_ack_rcv(l, acked, to - acked, NULL, xmitq,
+ 					  xmitq);
++>>>>>>> a91d55d162b8 (tipc: enable broadcast retrans via unicast)
  		l->stats.recv_nacks++;
  		return rc;
  	}
diff --cc net/tipc/link.h
index adcad65e761c,4d0768cf91d5..000000000000
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@@ -141,8 -142,13 +141,18 @@@ void tipc_link_remove_bc_peer(struct ti
  int tipc_link_bc_peers(struct tipc_link *l);
  void tipc_link_set_mtu(struct tipc_link *l, int mtu);
  int tipc_link_mtu(struct tipc_link *l);
++<<<<<<< HEAD
 +void tipc_link_bc_ack_rcv(struct tipc_link *l, u16 acked,
 +			  struct sk_buff_head *xmitq);
++=======
+ int tipc_link_mss(struct tipc_link *l);
+ u16 tipc_get_gap_ack_blks(struct tipc_gap_ack_blks **ga, struct tipc_link *l,
+ 			  struct tipc_msg *hdr, bool uc);
+ int tipc_link_bc_ack_rcv(struct tipc_link *l, u16 acked, u16 gap,
+ 			 struct tipc_gap_ack_blks *ga,
+ 			 struct sk_buff_head *xmitq,
+ 			 struct sk_buff_head *retrq);
++>>>>>>> a91d55d162b8 (tipc: enable broadcast retrans via unicast)
  void tipc_link_build_bc_sync_msg(struct tipc_link *l,
  				 struct sk_buff_head *xmitq);
  void tipc_link_bc_init_rcv(struct tipc_link *l, struct tipc_msg *hdr);
diff --cc net/tipc/sysctl.c
index 6159d327db76,97a6264a2993..000000000000
--- a/net/tipc/sysctl.c
+++ b/net/tipc/sysctl.c
@@@ -35,7 -35,8 +35,12 @@@
  
  #include "core.h"
  #include "trace.h"
++<<<<<<< HEAD
 +
++=======
+ #include "crypto.h"
+ #include "bcast.h"
++>>>>>>> a91d55d162b8 (tipc: enable broadcast retrans via unicast)
  #include <linux/sysctl.h>
  
  static struct ctl_table_header *tipc_ctl_hdr;
@@@ -64,6 -65,23 +69,26 @@@ static struct ctl_table tipc_table[] = 
  		.mode           = 0644,
  		.proc_handler   = proc_doulongvec_minmax,
  	},
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_TIPC_CRYPTO
+ 	{
+ 		.procname	= "max_tfms",
+ 		.data		= &sysctl_tipc_max_tfms,
+ 		.maxlen		= sizeof(sysctl_tipc_max_tfms),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_minmax,
+ 		.extra1         = SYSCTL_ONE,
+ 	},
+ #endif
+ 	{
+ 		.procname	= "bc_retruni",
+ 		.data		= &sysctl_tipc_bc_retruni,
+ 		.maxlen		= sizeof(sysctl_tipc_bc_retruni),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_doulongvec_minmax,
+ 	},
++>>>>>>> a91d55d162b8 (tipc: enable broadcast retrans via unicast)
  	{}
  };
  
* Unmerged path net/tipc/bcast.c
diff --git a/net/tipc/bcast.h b/net/tipc/bcast.h
index 9e847d9617d3..97d3cf9d3e4d 100644
--- a/net/tipc/bcast.h
+++ b/net/tipc/bcast.h
@@ -45,6 +45,7 @@ struct tipc_nl_msg;
 struct tipc_nlist;
 struct tipc_nitem;
 extern const char tipc_bclink_name[];
+extern unsigned long sysctl_tipc_bc_retruni;
 
 #define TIPC_METHOD_EXPIRE msecs_to_jiffies(5000)
 
@@ -93,7 +94,8 @@ int tipc_bcast_rcv(struct net *net, struct tipc_link *l, struct sk_buff *skb);
 void tipc_bcast_ack_rcv(struct net *net, struct tipc_link *l,
 			struct tipc_msg *hdr);
 int tipc_bcast_sync_rcv(struct net *net, struct tipc_link *l,
-			struct tipc_msg *hdr);
+			struct tipc_msg *hdr,
+			struct sk_buff_head *retrq);
 int tipc_nl_add_bc_link(struct net *net, struct tipc_nl_msg *msg);
 int tipc_nl_bc_link_set(struct net *net, struct nlattr *attrs[]);
 int tipc_bclink_reset_stats(struct net *net);
* Unmerged path net/tipc/link.c
* Unmerged path net/tipc/link.h
diff --git a/net/tipc/node.c b/net/tipc/node.c
index 3fe27ab13350..84828bf53a03 100644
--- a/net/tipc/node.c
+++ b/net/tipc/node.c
@@ -1567,7 +1567,7 @@ static void tipc_node_bc_sync_rcv(struct tipc_node *n, struct tipc_msg *hdr,
 	struct tipc_link *ucl;
 	int rc;
 
-	rc = tipc_bcast_sync_rcv(n->net, n->bc_entry.link, hdr);
+	rc = tipc_bcast_sync_rcv(n->net, n->bc_entry.link, hdr, xmitq);
 
 	if (rc & TIPC_LINK_DOWN_EVT) {
 		tipc_node_reset_links(n);
* Unmerged path net/tipc/sysctl.c
