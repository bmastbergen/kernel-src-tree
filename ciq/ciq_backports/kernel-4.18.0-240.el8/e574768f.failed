KVM: x86: Handle UMIP emulation CPUID adjustment in VMX code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit e574768f841ba600009da06b3027d9413dba868f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e574768f.failed

Move the CPUID adjustment for UMIP emulation into VMX code to eliminate
an instance of the undesirable "unsigned f_* = *_supported ? F(*) : 0"
pattern in the common CPUID handling code.

No functional change intended.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit e574768f841ba600009da06b3027d9413dba868f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/cpuid.c
index d4472786ed92,d7b3db024edc..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -368,9 -331,6 +368,12 @@@ static int __do_cpuid_func_emulated(str
  
  static inline void do_cpuid_7_mask(struct kvm_cpuid_entry2 *entry)
  {
++<<<<<<< HEAD
 +	unsigned f_invpcid = kvm_x86_ops->invpcid_supported() ? F(INVPCID) : 0;
 +	unsigned f_mpx = kvm_mpx_supported() ? F(MPX) : 0;
 +	unsigned f_umip = kvm_x86_ops->umip_emulated() ? F(UMIP) : 0;
++=======
++>>>>>>> e574768f841b (KVM: x86: Handle UMIP emulation CPUID adjustment in VMX code)
  	unsigned f_intel_pt = kvm_x86_ops->pt_supported() ? F(INTEL_PT) : 0;
  	unsigned f_la57;
  	unsigned f_pku = kvm_x86_ops->pku_supported() ? F(PKU) : 0;
@@@ -410,10 -370,9 +413,9 @@@
  
  		entry->ecx &= kvm_cpuid_7_0_ecx_x86_features;
  		f_la57 = cpuid_entry_get(entry, X86_FEATURE_LA57);
 -		cpuid_entry_mask(entry, CPUID_7_ECX);
 +		cpuid_mask(&entry->ecx, CPUID_7_ECX);
  		/* Set LA57 based on hardware capability. */
  		entry->ecx |= f_la57;
- 		entry->ecx |= f_umip;
  		entry->ecx |= f_pku;
  		/* PKU is not yet implemented for shadow paging. */
  		if (!tdp_enabled || !boot_cpu_has(X86_FEATURE_OSPKE))
diff --cc arch/x86/kvm/vmx/vmx.c
index b4f527d117f1,2f0897f296fb..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -7251,10 -7123,24 +7251,29 @@@ static void vmx_cpuid_update(struct kvm
  	}
  }
  
 -static void vmx_set_supported_cpuid(struct kvm_cpuid_entry2 *entry)
 +static void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
  {
++<<<<<<< HEAD
 +	if (func == 1 && nested)
 +		entry->ecx |= feature_bit(VMX);
++=======
+ 	switch (entry->function) {
+ 	case 0x1:
+ 		if (nested)
+ 			cpuid_entry_set(entry, X86_FEATURE_VMX);
+ 		break;
+ 	case 0x7:
+ 		if (boot_cpu_has(X86_FEATURE_MPX) && kvm_mpx_supported())
+ 			cpuid_entry_set(entry, X86_FEATURE_MPX);
+ 		if (boot_cpu_has(X86_FEATURE_INVPCID) && cpu_has_vmx_invpcid())
+ 			cpuid_entry_set(entry, X86_FEATURE_INVPCID);
+ 		if (vmx_umip_emulated())
+ 			cpuid_entry_set(entry, X86_FEATURE_UMIP);
+ 		break;
+ 	default:
+ 		break;
+ 	}
++>>>>>>> e574768f841b (KVM: x86: Handle UMIP emulation CPUID adjustment in VMX code)
  }
  
  static void vmx_request_immediate_exit(struct kvm_vcpu *vcpu)
* Unmerged path arch/x86/kvm/cpuid.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
