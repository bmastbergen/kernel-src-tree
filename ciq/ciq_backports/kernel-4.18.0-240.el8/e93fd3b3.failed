KVM: x86/mmu: Capture TDP level when updating CPUID

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit e93fd3b3e89e9664039281fe7e56e6f764f2a909
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e93fd3b3.failed

Snapshot the TDP level now that it's invariant (SVM) or dependent only
on host capabilities and guest CPUID (VMX).  This avoids having to call
kvm_x86_ops.get_tdp_level() when initializing a TDP MMU and/or
calculating the page role, and thus avoids the associated retpoline.

Drop the WARN in vmx_get_tdp_level() as updating CPUID while L2 is
active is legal, if dodgy.

No functional change intended.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200502043234.12481-11-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit e93fd3b3e89e9664039281fe7e56e6f764f2a909)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
#	arch/x86/kvm/svm/nested.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/mmu/mmu.c
index 5cde79442311,10cb8db54cd0..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -4958,7 -4894,7 +4958,11 @@@ kvm_calc_tdp_mmu_root_page_role(struct 
  	union kvm_mmu_role role = kvm_calc_mmu_role_common(vcpu, base_only);
  
  	role.base.ad_disabled = (shadow_accessed_mask == 0);
++<<<<<<< HEAD
 +	role.base.level = kvm_x86_ops->get_tdp_level(vcpu);
++=======
+ 	role.base.level = vcpu->arch.tdp_level;
++>>>>>>> e93fd3b3e89e (KVM: x86/mmu: Capture TDP level when updating CPUID)
  	role.base.direct = true;
  	role.base.gpte_is_8_bytes = true;
  
@@@ -4977,11 -4913,10 +4981,15 @@@ static void init_kvm_tdp_mmu(struct kvm
  	context->mmu_role.as_u64 = new_role.as_u64;
  	context->page_fault = kvm_tdp_page_fault;
  	context->sync_page = nonpaging_sync_page;
 -	context->invlpg = NULL;
 +	context->invlpg = nonpaging_invlpg;
  	context->update_pte = nonpaging_update_pte;
++<<<<<<< HEAD
 +	context->shadow_root_level = kvm_x86_ops->get_tdp_level(vcpu);
++=======
+ 	context->shadow_root_level = vcpu->arch.tdp_level;
++>>>>>>> e93fd3b3e89e (KVM: x86/mmu: Capture TDP level when updating CPUID)
  	context->direct_map = true;
 +	context->set_cr3 = kvm_x86_ops->set_tdp_cr3;
  	context->get_guest_pgd = get_cr3;
  	context->get_pdptr = kvm_pdptr_read;
  	context->inject_page_fault = kvm_inject_page_fault;
@@@ -5709,7 -5680,7 +5717,11 @@@ static int alloc_mmu_pages(struct kvm_v
  	 * SVM's 32-bit NPT support, TDP paging doesn't use PAE paging and can
  	 * skip allocating the PDP table.
  	 */
++<<<<<<< HEAD
 +	if (tdp_enabled && kvm_x86_ops->get_tdp_level(vcpu) > PT32E_ROOT_LEVEL)
++=======
+ 	if (tdp_enabled && vcpu->arch.tdp_level > PT32E_ROOT_LEVEL)
++>>>>>>> e93fd3b3e89e (KVM: x86/mmu: Capture TDP level when updating CPUID)
  		return 0;
  
  	page = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_DMA32);
diff --cc arch/x86/kvm/vmx/vmx.c
index d3ab0cabbd21,93b2a708b1da..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -3080,6 -3023,13 +3080,16 @@@ void vmx_set_cr0(struct kvm_vcpu *vcpu
  	vmx->emulation_required = emulation_required(vcpu);
  }
  
++<<<<<<< HEAD
++=======
+ static int vmx_get_tdp_level(struct kvm_vcpu *vcpu)
+ {
+ 	if (cpu_has_vmx_ept_5levels() && (cpuid_maxphyaddr(vcpu) > 48))
+ 		return 5;
+ 	return 4;
+ }
+ 
++>>>>>>> e93fd3b3e89e (KVM: x86/mmu: Capture TDP level when updating CPUID)
  static int get_ept_level(struct kvm_vcpu *vcpu)
  {
  	if (is_guest_mode(vcpu) && nested_cpu_has_ept(get_vmcs12(vcpu)))
* Unmerged path arch/x86/kvm/svm/nested.c
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 8e755c9a81df..78c2a8c891a1 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -682,6 +682,7 @@ struct kvm_vcpu_arch {
 	struct kvm_cpuid_entry2 cpuid_entries[KVM_MAX_CPUID_ENTRIES];
 
 	int maxphyaddr;
+	int tdp_level;
 
 	/* emulate context */
 
diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c
index 6821e9af6e76..59a776ed8b79 100644
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@ -148,8 +148,9 @@ int kvm_update_cpuid(struct kvm_vcpu *vcpu)
 		}
 	}
 
-	/* Update physical-address width */
+	/* Note, maxphyaddr must be updated before tdp_level. */
 	vcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);
+	vcpu->arch.tdp_level = kvm_x86_ops.get_tdp_level(vcpu);
 	kvm_mmu_reset_context(vcpu);
 
 	kvm_pmu_refresh(vcpu);
* Unmerged path arch/x86/kvm/mmu/mmu.c
* Unmerged path arch/x86/kvm/svm/nested.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
