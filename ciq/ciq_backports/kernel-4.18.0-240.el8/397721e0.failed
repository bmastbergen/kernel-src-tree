libperf: Add perf_cpu_map__dummy_new() function

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit 397721e06e52d017cfdd403f63284ed0995d4caf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/397721e0.failed

Move cpu_map__dummy_new() to libperf as perf_cpu_map__dummy_new() function.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Alexey Budankov <alexey.budankov@linux.intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20190721112506.12306-30-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 397721e06e52d017cfdd403f63284ed0995d4caf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/lib/cpumap.c
#	tools/perf/lib/include/perf/cpumap.h
#	tools/perf/util/cpumap.c
#	tools/perf/util/cpumap.h
diff --cc tools/perf/util/cpumap.c
index 77925b3c8d91,acda9bfb4002..000000000000
--- a/tools/perf/util/cpumap.c
+++ b/tools/perf/util/cpumap.c
@@@ -262,22 -256,9 +262,26 @@@ size_t cpu_map__fprintf(struct cpu_map 
  #undef BUFSIZE
  }
  
++<<<<<<< HEAD
 +struct cpu_map *cpu_map__dummy_new(void)
 +{
 +	struct cpu_map *cpus = malloc(sizeof(*cpus) + sizeof(int));
 +
 +	if (cpus != NULL) {
 +		cpus->nr = 1;
 +		cpus->map[0] = -1;
 +		refcount_set(&cpus->refcnt, 1);
 +	}
 +
 +	return cpus;
 +}
 +
 +struct cpu_map *cpu_map__empty_new(int nr)
++=======
+ struct perf_cpu_map *cpu_map__empty_new(int nr)
++>>>>>>> 397721e06e52 (libperf: Add perf_cpu_map__dummy_new() function)
  {
 -	struct perf_cpu_map *cpus = malloc(sizeof(*cpus) + sizeof(int) * nr);
 +	struct cpu_map *cpus = malloc(sizeof(*cpus) + sizeof(int) * nr);
  
  	if (cpus != NULL) {
  		int i;
diff --cc tools/perf/util/cpumap.h
index 1265f0e33920,0ce3f6bd9449..000000000000
--- a/tools/perf/util/cpumap.h
+++ b/tools/perf/util/cpumap.h
@@@ -5,39 -5,34 +5,54 @@@
  #include <stdio.h>
  #include <stdbool.h>
  #include <linux/refcount.h>
++<<<<<<< HEAD
++=======
+ #include <internal/cpumap.h>
+ #include <perf/cpumap.h>
++>>>>>>> 397721e06e52 (libperf: Add perf_cpu_map__dummy_new() function)
  
  #include "perf.h"
  #include "util/debug.h"
  
++<<<<<<< HEAD
 +struct cpu_map {
 +	refcount_t refcnt;
 +	int nr;
 +	int map[];
 +};
 +
 +struct cpu_map *cpu_map__new(const char *cpu_list);
 +struct cpu_map *cpu_map__empty_new(int nr);
 +struct cpu_map *cpu_map__dummy_new(void);
 +struct cpu_map *cpu_map__new_data(struct cpu_map_data *data);
 +struct cpu_map *cpu_map__read(FILE *file);
 +size_t cpu_map__snprint(struct cpu_map *map, char *buf, size_t size);
 +size_t cpu_map__snprint_mask(struct cpu_map *map, char *buf, size_t size);
 +size_t cpu_map__fprintf(struct cpu_map *map, FILE *fp);
++=======
+ struct perf_cpu_map *cpu_map__new(const char *cpu_list);
+ struct perf_cpu_map *cpu_map__empty_new(int nr);
+ struct perf_cpu_map *cpu_map__new_data(struct cpu_map_data *data);
+ struct perf_cpu_map *cpu_map__read(FILE *file);
+ size_t cpu_map__snprint(struct perf_cpu_map *map, char *buf, size_t size);
+ size_t cpu_map__snprint_mask(struct perf_cpu_map *map, char *buf, size_t size);
+ size_t cpu_map__fprintf(struct perf_cpu_map *map, FILE *fp);
++>>>>>>> 397721e06e52 (libperf: Add perf_cpu_map__dummy_new() function)
  int cpu_map__get_socket_id(int cpu);
 -int cpu_map__get_socket(struct perf_cpu_map *map, int idx, void *data);
 +int cpu_map__get_socket(struct cpu_map *map, int idx, void *data);
  int cpu_map__get_die_id(int cpu);
 -int cpu_map__get_die(struct perf_cpu_map *map, int idx, void *data);
 +int cpu_map__get_die(struct cpu_map *map, int idx, void *data);
  int cpu_map__get_core_id(int cpu);
 -int cpu_map__get_core(struct perf_cpu_map *map, int idx, void *data);
 -int cpu_map__build_socket_map(struct perf_cpu_map *cpus, struct perf_cpu_map **sockp);
 -int cpu_map__build_die_map(struct perf_cpu_map *cpus, struct perf_cpu_map **diep);
 -int cpu_map__build_core_map(struct perf_cpu_map *cpus, struct perf_cpu_map **corep);
 -const struct perf_cpu_map *cpu_map__online(void); /* thread unsafe */
 +int cpu_map__get_core(struct cpu_map *map, int idx, void *data);
 +int cpu_map__build_socket_map(struct cpu_map *cpus, struct cpu_map **sockp);
 +int cpu_map__build_die_map(struct cpu_map *cpus, struct cpu_map **diep);
 +int cpu_map__build_core_map(struct cpu_map *cpus, struct cpu_map **corep);
 +const struct cpu_map *cpu_map__online(void); /* thread unsafe */
  
 -struct perf_cpu_map *cpu_map__get(struct perf_cpu_map *map);
 -void cpu_map__put(struct perf_cpu_map *map);
 +struct cpu_map *cpu_map__get(struct cpu_map *map);
 +void cpu_map__put(struct cpu_map *map);
  
 -static inline int cpu_map__socket(struct perf_cpu_map *sock, int s)
 +static inline int cpu_map__socket(struct cpu_map *sock, int s)
  {
  	if (!sock || s > sock->nr || s < 0)
  		return 0;
* Unmerged path tools/perf/lib/cpumap.c
* Unmerged path tools/perf/lib/include/perf/cpumap.h
* Unmerged path tools/perf/lib/cpumap.c
* Unmerged path tools/perf/lib/include/perf/cpumap.h
diff --git a/tools/perf/lib/libperf.map b/tools/perf/lib/libperf.map
index 3536242c545c..65201c6cbe7e 100644
--- a/tools/perf/lib/libperf.map
+++ b/tools/perf/lib/libperf.map
@@ -1,6 +1,7 @@
 LIBPERF_0.0.1 {
 	global:
 		libperf_set_print;
+		perf_cpu_map__dummy_new;
 	local:
 		*;
 };
diff --git a/tools/perf/tests/sw-clock.c b/tools/perf/tests/sw-clock.c
index f9490b237893..0cf9aa232505 100644
--- a/tools/perf/tests/sw-clock.c
+++ b/tools/perf/tests/sw-clock.c
@@ -56,7 +56,7 @@ static int __test__sw_clock_freq(enum perf_sw_ids clock_id)
 	}
 	perf_evlist__add(evlist, evsel);
 
-	cpus = cpu_map__dummy_new();
+	cpus = perf_cpu_map__dummy_new();
 	threads = thread_map__new_by_tid(getpid());
 	if (!cpus || !threads) {
 		err = -ENOMEM;
diff --git a/tools/perf/tests/task-exit.c b/tools/perf/tests/task-exit.c
index e92fa6029ac7..3dfc31af9ac6 100644
--- a/tools/perf/tests/task-exit.c
+++ b/tools/perf/tests/task-exit.c
@@ -63,7 +63,7 @@ int test__task_exit(struct test *test __maybe_unused, int subtest __maybe_unused
 	 * perf_evlist__prepare_workload we'll fill in the only thread
 	 * we're monitoring, the one forked there.
 	 */
-	cpus = cpu_map__dummy_new();
+	cpus = perf_cpu_map__dummy_new();
 	threads = thread_map__new_by_tid(-1);
 	if (!cpus || !threads) {
 		err = -ENOMEM;
* Unmerged path tools/perf/util/cpumap.c
* Unmerged path tools/perf/util/cpumap.h
diff --git a/tools/perf/util/evlist.c b/tools/perf/util/evlist.c
index 4739b7914374..06ac33a27903 100644
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@ -1087,7 +1087,7 @@ int perf_evlist__create_maps(struct perf_evlist *evlist, struct target *target)
 		return -1;
 
 	if (target__uses_dummy_map(target))
-		cpus = cpu_map__dummy_new();
+		cpus = perf_cpu_map__dummy_new();
 	else
 		cpus = cpu_map__new(target->cpu_list);
 
diff --git a/tools/perf/util/evsel.c b/tools/perf/util/evsel.c
index e99257f738ba..58c6fd1e6ce1 100644
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@ -1841,7 +1841,7 @@ int perf_evsel__open(struct perf_evsel *evsel, struct cpu_map *cpus,
 		static struct cpu_map *empty_cpu_map;
 
 		if (empty_cpu_map == NULL) {
-			empty_cpu_map = cpu_map__dummy_new();
+			empty_cpu_map = perf_cpu_map__dummy_new();
 			if (empty_cpu_map == NULL)
 				return -ENOMEM;
 		}
