x86/hyperv: Suspend/resume the hypercall page for hibernation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [x86] hyperv: Suspend/resume the hypercall page for hibernation (Mohammed Gamal) [1815475]
Rebuild_FUZZ: 96.61%
commit-author Dexuan Cui <decui@microsoft.com>
commit 05bd330a7fd8875c423fc07d8ddcad73c10e556e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/05bd330a.failed

For hibernation the hypercall page must be disabled before the hibernation
image is created so that subsequent hypercall operations fail safely. On
resume the hypercall page has to be restored and reenabled to ensure proper
operation of the resumed kernel.

Implement the necessary suspend/resume callbacks.

[ tglx: Decrypted changelog ]

	Signed-off-by: Dexuan Cui <decui@microsoft.com>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Michael Kelley <mikelley@microsoft.com>
Link: https://lore.kernel.org/r/1578350559-130275-1-git-send-email-decui@microsoft.com

(cherry picked from commit 05bd330a7fd8875c423fc07d8ddcad73c10e556e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/hyperv/hv_init.c
diff --cc arch/x86/hyperv/hv_init.c
index 346ed6001be8,b0da5320bcff..000000000000
--- a/arch/x86/hyperv/hv_init.c
+++ b/arch/x86/hyperv/hv_init.c
@@@ -32,61 -21,15 +32,69 @@@
  #include <linux/hyperv.h>
  #include <linux/slab.h>
  #include <linux/cpuhotplug.h>
++<<<<<<< HEAD
 +
 +#ifdef CONFIG_HYPERV_TSCPAGE
 +
 +static struct ms_hyperv_tsc_page *tsc_pg;
 +
 +struct ms_hyperv_tsc_page *hv_get_tsc_page(void)
 +{
 +	return tsc_pg;
 +}
 +EXPORT_SYMBOL_GPL(hv_get_tsc_page);
 +
 +static u64 read_hv_clock_tsc(struct clocksource *arg)
 +{
 +	u64 current_tick = hv_read_tsc_page(tsc_pg);
 +
 +	if (current_tick == U64_MAX)
 +		rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
 +
 +	return current_tick;
 +}
 +
 +static struct clocksource hyperv_cs_tsc = {
 +		.name		= "hyperv_clocksource_tsc_page",
 +		.rating		= 400,
 +		.read		= read_hv_clock_tsc,
 +		.mask		= CLOCKSOURCE_MASK(64),
 +		.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 +};
 +#endif
 +
 +static u64 read_hv_clock_msr(struct clocksource *arg)
 +{
 +	u64 current_tick;
 +	/*
 +	 * Read the partition counter to get the current tick count. This count
 +	 * is set to 0 when the partition is created and is incremented in
 +	 * 100 nanosecond units.
 +	 */
 +	rdmsrl(HV_X64_MSR_TIME_REF_COUNT, current_tick);
 +	return current_tick;
 +}
 +
 +static struct clocksource hyperv_cs_msr = {
 +	.name		= "hyperv_clocksource_msr",
 +	.rating		= 400,
 +	.read		= read_hv_clock_msr,
 +	.mask		= CLOCKSOURCE_MASK(64),
 +	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 +};
++=======
+ #include <linux/syscore_ops.h>
+ #include <clocksource/hyperv_timer.h>
++>>>>>>> 05bd330a7fd8 (x86/hyperv: Suspend/resume the hypercall page for hibernation)
  
  void *hv_hypercall_pg;
  EXPORT_SYMBOL_GPL(hv_hypercall_pg);
 +struct clocksource *hyperv_cs;
 +EXPORT_SYMBOL_GPL(hyperv_cs);
  
+ /* Storage to save the hypercall page temporarily for hibernation */
+ static void *hv_hypercall_pg_saved;
+ 
  u32 *hv_vp_index;
  EXPORT_SYMBOL_GPL(hv_vp_index);
  
@@@ -381,45 -366,17 +431,49 @@@ void __init hyperv_init(void
  	hypercall_msr.guest_physical_address = vmalloc_to_pfn(hv_hypercall_pg);
  	wrmsrl(HV_X64_MSR_HYPERCALL, hypercall_msr.as_uint64);
  
 +	hv_apic_init();
 +
 +	x86_init.pci.arch_init = hv_pci_init;
 +
++<<<<<<< HEAD
  	/*
 -	 * Ignore any errors in setting up stimer clockevents
 -	 * as we can run with the LAPIC timer as a fallback.
 +	 * Register Hyper-V specific clocksource.
  	 */
 -	(void)hv_stimer_alloc();
 +#ifdef CONFIG_HYPERV_TSCPAGE
 +	if (ms_hyperv.features & HV_MSR_REFERENCE_TSC_AVAILABLE) {
 +		union hv_x64_msr_hypercall_contents tsc_msr;
  
 -	hv_apic_init();
 +		tsc_pg = __vmalloc(PAGE_SIZE, GFP_KERNEL, PAGE_KERNEL);
 +		if (!tsc_pg)
 +			goto register_msr_cs;
  
 -	x86_init.pci.arch_init = hv_pci_init;
 +		hyperv_cs = &hyperv_cs_tsc;
 +
 +		rdmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
 +
 +		tsc_msr.enable = 1;
 +		tsc_msr.guest_physical_address = vmalloc_to_pfn(tsc_pg);
 +
 +		wrmsrl(HV_X64_MSR_REFERENCE_TSC, tsc_msr.as_uint64);
 +
 +		hyperv_cs_tsc.archdata.vclock_mode = VCLOCK_HVCLOCK;
 +
 +		clocksource_register_hz(&hyperv_cs_tsc, NSEC_PER_SEC/100);
 +		return;
 +	}
 +register_msr_cs:
 +#endif
 +	/*
 +	 * For 32 bit guests just use the MSR based mechanism for reading
 +	 * the partition counter.
 +	 */
  
 +	hyperv_cs = &hyperv_cs_msr;
 +	if (ms_hyperv.features & HV_MSR_TIME_REF_COUNT_AVAILABLE)
 +		clocksource_register_hz(&hyperv_cs_msr, NSEC_PER_SEC/100);
++=======
+ 	register_syscore_ops(&hv_syscore_ops);
++>>>>>>> 05bd330a7fd8 (x86/hyperv: Suspend/resume the hypercall page for hibernation)
  
  	return;
  
* Unmerged path arch/x86/hyperv/hv_init.c
