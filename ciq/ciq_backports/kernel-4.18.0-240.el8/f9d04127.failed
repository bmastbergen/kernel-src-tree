bpf: Refactor bpf_link update handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit f9d041271cf44ca02eed0cc82e1a6d8c814c53ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f9d04127.failed

Make bpf_link update support more generic by making it into another
bpf_link_ops methods. This allows generic syscall handling code to be agnostic
to various conditionally compiled features (e.g., the case of
CONFIG_CGROUP_BPF). This also allows to keep link type-specific code to remain
static within respective code base. Refactor existing bpf_cgroup_link code and
take advantage of this.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200429001614.1544-2-andriin@fb.com
(cherry picked from commit f9d041271cf44ca02eed0cc82e1a6d8c814c53ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf-cgroup.h
#	include/linux/bpf.h
#	kernel/bpf/cgroup.c
#	kernel/bpf/syscall.c
#	kernel/cgroup/cgroup.c
diff --cc include/linux/bpf-cgroup.h
index 63c168a1495a,a9cb9a5bf8e9..000000000000
--- a/include/linux/bpf-cgroup.h
+++ b/include/linux/bpf-cgroup.h
@@@ -124,10 -104,12 +124,14 @@@ int __cgroup_bpf_query(struct cgroup *c
  		       union bpf_attr __user *uattr);
  
  /* Wrapper for __cgroup_bpf_*() protected by cgroup_mutex */
 -int cgroup_bpf_attach(struct cgroup *cgrp,
 -		      struct bpf_prog *prog, struct bpf_prog *replace_prog,
 -		      struct bpf_cgroup_link *link, enum bpf_attach_type type,
 -		      u32 flags);
 +int cgroup_bpf_attach(struct cgroup *cgrp, struct bpf_prog *prog,
 +		      enum bpf_attach_type type, u32 flags);
  int cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,
++<<<<<<< HEAD
 +		      enum bpf_attach_type type, u32 flags);
++=======
+ 		      enum bpf_attach_type type);
++>>>>>>> f9d041271cf4 (bpf: Refactor bpf_link update handling)
  int cgroup_bpf_query(struct cgroup *cgrp, const union bpf_attr *attr,
  		     union bpf_attr __user *uattr);
  
@@@ -384,6 -366,12 +388,15 @@@ static inline int cgroup_bpf_prog_detac
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ static inline int cgroup_bpf_link_attach(const union bpf_attr *attr,
+ 					 struct bpf_prog *prog)
+ {
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> f9d041271cf4 (bpf: Refactor bpf_link update handling)
  static inline int cgroup_bpf_prog_query(const union bpf_attr *attr,
  					union bpf_attr __user *uattr)
  {
diff --cc include/linux/bpf.h
index c1c99fdb999a,81c8620cb4c4..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -734,6 -1083,30 +734,33 @@@ extern int sysctl_unprivileged_bpf_disa
  int bpf_map_new_fd(struct bpf_map *map, int flags);
  int bpf_prog_new_fd(struct bpf_prog *prog);
  
++<<<<<<< HEAD
++=======
+ struct bpf_link {
+ 	atomic64_t refcnt;
+ 	const struct bpf_link_ops *ops;
+ 	struct bpf_prog *prog;
+ 	struct work_struct work;
+ };
+ 
+ struct bpf_link_ops {
+ 	void (*release)(struct bpf_link *link);
+ 	void (*dealloc)(struct bpf_link *link);
+ 	int (*update_prog)(struct bpf_link *link, struct bpf_prog *new_prog,
+ 			   struct bpf_prog *old_prog);
+ };
+ 
+ void bpf_link_init(struct bpf_link *link, const struct bpf_link_ops *ops,
+ 		   struct bpf_prog *prog);
+ void bpf_link_cleanup(struct bpf_link *link, struct file *link_file,
+ 		      int link_fd);
+ void bpf_link_inc(struct bpf_link *link);
+ void bpf_link_put(struct bpf_link *link);
+ int bpf_link_new_fd(struct bpf_link *link);
+ struct file *bpf_link_new_file(struct bpf_link *link, int *reserved_fd);
+ struct bpf_link *bpf_link_get_from_fd(u32 ufd);
+ 
++>>>>>>> f9d041271cf4 (bpf: Refactor bpf_link update handling)
  int bpf_obj_pin_user(u32 ufd, const char __user *pathname);
  int bpf_obj_get_user(const char __user *pathname, int flags);
  
diff --cc kernel/bpf/cgroup.c
index 5b8da1ceafe3,da6e48e802b2..000000000000
--- a/kernel/bpf/cgroup.c
+++ b/kernel/bpf/cgroup.c
@@@ -407,8 -503,145 +407,104 @@@ cleanup
  	return err;
  }
  
 -/* Swap updated BPF program for given link in effective program arrays across
 - * all descendant cgroups. This function is guaranteed to succeed.
 - */
 -static void replace_effective_prog(struct cgroup *cgrp,
 -				   enum bpf_attach_type type,
 -				   struct bpf_cgroup_link *link)
 -{
 -	struct bpf_prog_array_item *item;
 -	struct cgroup_subsys_state *css;
 -	struct bpf_prog_array *progs;
 -	struct bpf_prog_list *pl;
 -	struct list_head *head;
 -	struct cgroup *cg;
 -	int pos;
 -
 -	css_for_each_descendant_pre(css, &cgrp->self) {
 -		struct cgroup *desc = container_of(css, struct cgroup, self);
 -
 -		if (percpu_ref_is_zero(&desc->bpf.refcnt))
 -			continue;
 -
 -		/* find position of link in effective progs array */
 -		for (pos = 0, cg = desc; cg; cg = cgroup_parent(cg)) {
 -			if (pos && !(cg->bpf.flags[type] & BPF_F_ALLOW_MULTI))
 -				continue;
 -
 -			head = &cg->bpf.progs[type];
 -			list_for_each_entry(pl, head, node) {
 -				if (!prog_list_prog(pl))
 -					continue;
 -				if (pl->link == link)
 -					goto found;
 -				pos++;
 -			}
 -		}
 -found:
 -		BUG_ON(!cg);
 -		progs = rcu_dereference_protected(
 -				desc->bpf.effective[type],
 -				lockdep_is_held(&cgroup_mutex));
 -		item = &progs->items[pos];
 -		WRITE_ONCE(item->prog, link->link.prog);
 -	}
 -}
 -
  /**
++<<<<<<< HEAD
 + * __cgroup_bpf_detach() - Detach the program from a cgroup, and
++=======
+  * __cgroup_bpf_replace() - Replace link's program and propagate the change
+  *                          to descendants
+  * @cgrp: The cgroup which descendants to traverse
+  * @link: A link for which to replace BPF program
+  * @type: Type of attach operation
+  *
+  * Must be called with cgroup_mutex held.
+  */
+ static int __cgroup_bpf_replace(struct cgroup *cgrp,
+ 				struct bpf_cgroup_link *link,
+ 				struct bpf_prog *new_prog)
+ {
+ 	struct list_head *progs = &cgrp->bpf.progs[link->type];
+ 	struct bpf_prog *old_prog;
+ 	struct bpf_prog_list *pl;
+ 	bool found = false;
+ 
+ 	if (link->link.prog->type != new_prog->type)
+ 		return -EINVAL;
+ 
+ 	list_for_each_entry(pl, progs, node) {
+ 		if (pl->link == link) {
+ 			found = true;
+ 			break;
+ 		}
+ 	}
+ 	if (!found)
+ 		return -ENOENT;
+ 
+ 	old_prog = xchg(&link->link.prog, new_prog);
+ 	replace_effective_prog(cgrp, link->type, link);
+ 	bpf_prog_put(old_prog);
+ 	return 0;
+ }
+ 
+ static int cgroup_bpf_replace(struct bpf_link *link, struct bpf_prog *new_prog,
+ 			      struct bpf_prog *old_prog)
+ {
+ 	struct bpf_cgroup_link *cg_link;
+ 	int ret;
+ 
+ 	cg_link = container_of(link, struct bpf_cgroup_link, link);
+ 
+ 	mutex_lock(&cgroup_mutex);
+ 	/* link might have been auto-released by dying cgroup, so fail */
+ 	if (!cg_link->cgroup) {
+ 		ret = -EINVAL;
+ 		goto out_unlock;
+ 	}
+ 	if (old_prog && link->prog != old_prog) {
+ 		ret = -EPERM;
+ 		goto out_unlock;
+ 	}
+ 	ret = __cgroup_bpf_replace(cg_link->cgroup, cg_link, new_prog);
+ out_unlock:
+ 	mutex_unlock(&cgroup_mutex);
+ 	return ret;
+ }
+ 
+ static struct bpf_prog_list *find_detach_entry(struct list_head *progs,
+ 					       struct bpf_prog *prog,
+ 					       struct bpf_cgroup_link *link,
+ 					       bool allow_multi)
+ {
+ 	struct bpf_prog_list *pl;
+ 
+ 	if (!allow_multi) {
+ 		if (list_empty(progs))
+ 			/* report error when trying to detach and nothing is attached */
+ 			return ERR_PTR(-ENOENT);
+ 
+ 		/* to maintain backward compatibility NONE and OVERRIDE cgroups
+ 		 * allow detaching with invalid FD (prog==NULL) in legacy mode
+ 		 */
+ 		return list_first_entry(progs, typeof(*pl), node);
+ 	}
+ 
+ 	if (!prog && !link)
+ 		/* to detach MULTI prog the user has to specify valid FD
+ 		 * of the program or link to be detached
+ 		 */
+ 		return ERR_PTR(-EINVAL);
+ 
+ 	/* find the prog or link and detach it */
+ 	list_for_each_entry(pl, progs, node) {
+ 		if (pl->prog == prog && pl->link == link)
+ 			return pl;
+ 	}
+ 	return ERR_PTR(-ENOENT);
+ }
+ 
+ /**
+  * __cgroup_bpf_detach() - Detach the program or link from a cgroup, and
++>>>>>>> f9d041271cf4 (bpf: Refactor bpf_link update handling)
   *                         propagate the change to descendants
   * @cgrp: The cgroup which descendants to traverse
   * @prog: A program to detach or NULL
@@@ -574,6 -799,91 +670,94 @@@ int cgroup_bpf_prog_detach(const union 
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void bpf_cgroup_link_release(struct bpf_link *link)
+ {
+ 	struct bpf_cgroup_link *cg_link =
+ 		container_of(link, struct bpf_cgroup_link, link);
+ 
+ 	/* link might have been auto-detached by dying cgroup already,
+ 	 * in that case our work is done here
+ 	 */
+ 	if (!cg_link->cgroup)
+ 		return;
+ 
+ 	mutex_lock(&cgroup_mutex);
+ 
+ 	/* re-check cgroup under lock again */
+ 	if (!cg_link->cgroup) {
+ 		mutex_unlock(&cgroup_mutex);
+ 		return;
+ 	}
+ 
+ 	WARN_ON(__cgroup_bpf_detach(cg_link->cgroup, NULL, cg_link,
+ 				    cg_link->type));
+ 
+ 	mutex_unlock(&cgroup_mutex);
+ 	cgroup_put(cg_link->cgroup);
+ }
+ 
+ static void bpf_cgroup_link_dealloc(struct bpf_link *link)
+ {
+ 	struct bpf_cgroup_link *cg_link =
+ 		container_of(link, struct bpf_cgroup_link, link);
+ 
+ 	kfree(cg_link);
+ }
+ 
+ const struct bpf_link_ops bpf_cgroup_link_lops = {
+ 	.release = bpf_cgroup_link_release,
+ 	.dealloc = bpf_cgroup_link_dealloc,
+ 	.update_prog = cgroup_bpf_replace,
+ };
+ 
+ int cgroup_bpf_link_attach(const union bpf_attr *attr, struct bpf_prog *prog)
+ {
+ 	struct bpf_cgroup_link *link;
+ 	struct file *link_file;
+ 	struct cgroup *cgrp;
+ 	int err, link_fd;
+ 
+ 	if (attr->link_create.flags)
+ 		return -EINVAL;
+ 
+ 	cgrp = cgroup_get_from_fd(attr->link_create.target_fd);
+ 	if (IS_ERR(cgrp))
+ 		return PTR_ERR(cgrp);
+ 
+ 	link = kzalloc(sizeof(*link), GFP_USER);
+ 	if (!link) {
+ 		err = -ENOMEM;
+ 		goto out_put_cgroup;
+ 	}
+ 	bpf_link_init(&link->link, &bpf_cgroup_link_lops, prog);
+ 	link->cgroup = cgrp;
+ 	link->type = attr->link_create.attach_type;
+ 
+ 	link_file = bpf_link_new_file(&link->link, &link_fd);
+ 	if (IS_ERR(link_file)) {
+ 		kfree(link);
+ 		err = PTR_ERR(link_file);
+ 		goto out_put_cgroup;
+ 	}
+ 
+ 	err = cgroup_bpf_attach(cgrp, NULL, NULL, link, link->type,
+ 				BPF_F_ALLOW_MULTI);
+ 	if (err) {
+ 		bpf_link_cleanup(&link->link, link_file, link_fd);
+ 		goto out_put_cgroup;
+ 	}
+ 
+ 	fd_install(link_fd, link_file);
+ 	return link_fd;
+ 
+ out_put_cgroup:
+ 	cgroup_put(cgrp);
+ 	return err;
+ }
+ 
++>>>>>>> f9d041271cf4 (bpf: Refactor bpf_link update handling)
  int cgroup_bpf_prog_query(const union bpf_attr *attr,
  			  union bpf_attr __user *uattr)
  {
diff --cc kernel/bpf/syscall.c
index c66cb8c29897,f5358e1462eb..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -2910,6 -3503,163 +2910,166 @@@ out
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ #define BPF_MAP_BATCH_LAST_FIELD batch.flags
+ 
+ #define BPF_DO_BATCH(fn)			\
+ 	do {					\
+ 		if (!fn) {			\
+ 			err = -ENOTSUPP;	\
+ 			goto err_put;		\
+ 		}				\
+ 		err = fn(map, attr, uattr);	\
+ 	} while (0)
+ 
+ static int bpf_map_do_batch(const union bpf_attr *attr,
+ 			    union bpf_attr __user *uattr,
+ 			    int cmd)
+ {
+ 	struct bpf_map *map;
+ 	int err, ufd;
+ 	struct fd f;
+ 
+ 	if (CHECK_ATTR(BPF_MAP_BATCH))
+ 		return -EINVAL;
+ 
+ 	ufd = attr->batch.map_fd;
+ 	f = fdget(ufd);
+ 	map = __bpf_map_get(f);
+ 	if (IS_ERR(map))
+ 		return PTR_ERR(map);
+ 
+ 	if ((cmd == BPF_MAP_LOOKUP_BATCH ||
+ 	     cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH) &&
+ 	    !(map_get_sys_perms(map, f) & FMODE_CAN_READ)) {
+ 		err = -EPERM;
+ 		goto err_put;
+ 	}
+ 
+ 	if (cmd != BPF_MAP_LOOKUP_BATCH &&
+ 	    !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
+ 		err = -EPERM;
+ 		goto err_put;
+ 	}
+ 
+ 	if (cmd == BPF_MAP_LOOKUP_BATCH)
+ 		BPF_DO_BATCH(map->ops->map_lookup_batch);
+ 	else if (cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH)
+ 		BPF_DO_BATCH(map->ops->map_lookup_and_delete_batch);
+ 	else if (cmd == BPF_MAP_UPDATE_BATCH)
+ 		BPF_DO_BATCH(map->ops->map_update_batch);
+ 	else
+ 		BPF_DO_BATCH(map->ops->map_delete_batch);
+ 
+ err_put:
+ 	fdput(f);
+ 	return err;
+ }
+ 
+ #define BPF_LINK_CREATE_LAST_FIELD link_create.flags
+ static int link_create(union bpf_attr *attr)
+ {
+ 	enum bpf_prog_type ptype;
+ 	struct bpf_prog *prog;
+ 	int ret;
+ 
+ 	if (!capable(CAP_NET_ADMIN))
+ 		return -EPERM;
+ 
+ 	if (CHECK_ATTR(BPF_LINK_CREATE))
+ 		return -EINVAL;
+ 
+ 	ptype = attach_type_to_prog_type(attr->link_create.attach_type);
+ 	if (ptype == BPF_PROG_TYPE_UNSPEC)
+ 		return -EINVAL;
+ 
+ 	prog = bpf_prog_get_type(attr->link_create.prog_fd, ptype);
+ 	if (IS_ERR(prog))
+ 		return PTR_ERR(prog);
+ 
+ 	ret = bpf_prog_attach_check_attach_type(prog,
+ 						attr->link_create.attach_type);
+ 	if (ret)
+ 		goto err_out;
+ 
+ 	switch (ptype) {
+ 	case BPF_PROG_TYPE_CGROUP_SKB:
+ 	case BPF_PROG_TYPE_CGROUP_SOCK:
+ 	case BPF_PROG_TYPE_CGROUP_SOCK_ADDR:
+ 	case BPF_PROG_TYPE_SOCK_OPS:
+ 	case BPF_PROG_TYPE_CGROUP_DEVICE:
+ 	case BPF_PROG_TYPE_CGROUP_SYSCTL:
+ 	case BPF_PROG_TYPE_CGROUP_SOCKOPT:
+ 		ret = cgroup_bpf_link_attach(attr, prog);
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 	}
+ 
+ err_out:
+ 	if (ret < 0)
+ 		bpf_prog_put(prog);
+ 	return ret;
+ }
+ 
+ #define BPF_LINK_UPDATE_LAST_FIELD link_update.old_prog_fd
+ 
+ static int link_update(union bpf_attr *attr)
+ {
+ 	struct bpf_prog *old_prog = NULL, *new_prog;
+ 	struct bpf_link *link;
+ 	u32 flags;
+ 	int ret;
+ 
+ 	if (!capable(CAP_NET_ADMIN))
+ 		return -EPERM;
+ 
+ 	if (CHECK_ATTR(BPF_LINK_UPDATE))
+ 		return -EINVAL;
+ 
+ 	flags = attr->link_update.flags;
+ 	if (flags & ~BPF_F_REPLACE)
+ 		return -EINVAL;
+ 
+ 	link = bpf_link_get_from_fd(attr->link_update.link_fd);
+ 	if (IS_ERR(link))
+ 		return PTR_ERR(link);
+ 
+ 	new_prog = bpf_prog_get(attr->link_update.new_prog_fd);
+ 	if (IS_ERR(new_prog)) {
+ 		ret = PTR_ERR(new_prog);
+ 		goto out_put_link;
+ 	}
+ 
+ 	if (flags & BPF_F_REPLACE) {
+ 		old_prog = bpf_prog_get(attr->link_update.old_prog_fd);
+ 		if (IS_ERR(old_prog)) {
+ 			ret = PTR_ERR(old_prog);
+ 			old_prog = NULL;
+ 			goto out_put_progs;
+ 		}
+ 	} else if (attr->link_update.old_prog_fd) {
+ 		ret = -EINVAL;
+ 		goto out_put_progs;
+ 	}
+ 
+ 	if (link->ops->update_prog)
+ 		ret = link->ops->update_prog(link, new_prog, old_prog);
+ 	else
+ 		ret = EINVAL;
+ 
+ out_put_progs:
+ 	if (old_prog)
+ 		bpf_prog_put(old_prog);
+ 	if (ret)
+ 		bpf_prog_put(new_prog);
+ out_put_link:
+ 	bpf_link_put(link);
+ 	return ret;
+ }
+ 
++>>>>>>> f9d041271cf4 (bpf: Refactor bpf_link update handling)
  SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)
  {
  	union bpf_attr attr;
diff --cc kernel/cgroup/cgroup.c
index 0ae03b38e5a0,557a9b9d2244..000000000000
--- a/kernel/cgroup/cgroup.c
+++ b/kernel/cgroup/cgroup.c
@@@ -6335,8 -6507,9 +6335,12 @@@ int cgroup_bpf_attach(struct cgroup *cg
  	mutex_unlock(&cgroup_mutex);
  	return ret;
  }
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> f9d041271cf4 (bpf: Refactor bpf_link update handling)
  int cgroup_bpf_detach(struct cgroup *cgrp, struct bpf_prog *prog,
 -		      enum bpf_attach_type type)
 +		      enum bpf_attach_type type, u32 flags)
  {
  	int ret;
  
* Unmerged path include/linux/bpf-cgroup.h
* Unmerged path include/linux/bpf.h
* Unmerged path kernel/bpf/cgroup.c
* Unmerged path kernel/bpf/syscall.c
* Unmerged path kernel/cgroup/cgroup.c
