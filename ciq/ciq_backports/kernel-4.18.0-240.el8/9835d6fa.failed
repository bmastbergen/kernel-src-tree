io_uring: add likely/unlikely in io_get_sqring()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pavel Begunkov <asml.silence@gmail.com>
commit 9835d6fafba58e6d9386a6d5af800789bdb52e5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9835d6fa.failed

The number of SQEs to submit is specified by a user, so io_get_sqring()
in most of the cases succeeds. Hint compilers about that.

Checking ASM genereted by gcc 9.2.0 for x64, there is one branch
misprediction.

	Signed-off-by: Pavel Begunkov <asml.silence@gmail.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 9835d6fafba58e6d9386a6d5af800789bdb52e5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 66de1d702552,63e0448f3f8d..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -2391,11 -3129,12 +2391,20 @@@ static bool io_get_sqring(struct io_rin
  	 */
  	head = ctx->cached_sq_head;
  	/* make sure SQ entry isn't read before tail */
++<<<<<<< HEAD
 +	if (head == smp_load_acquire(&ring->r.tail))
 +		return false;
 +
 +	head = READ_ONCE(ring->array[head & ctx->sq_mask]);
 +	if (head < ctx->sq_entries) {
++=======
+ 	if (unlikely(head == smp_load_acquire(&rings->sq.tail)))
+ 		return false;
+ 
+ 	head = READ_ONCE(sq_array[head & ctx->sq_mask]);
+ 	if (likely(head < ctx->sq_entries)) {
+ 		s->ring_file = NULL;
++>>>>>>> 9835d6fafba5 (io_uring: add likely/unlikely in io_get_sqring())
  		s->sqe = &ctx->sq_sqes[head];
  		s->sequence = ctx->cached_sq_head;
  		ctx->cached_sq_head++;
* Unmerged path fs/io_uring.c
