ASoC: SOF: Intel: hda: initial SoundWire machine driver autodetect

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: SOF: Intel: hda: initial SoundWire machine driver autodetect (Jaroslav Kysela) [1797509]
Rebuild_FUZZ: 95.65%
commit-author Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
commit b9ddd81bad19ef7b0955156e7590130127cfdaae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b9ddd81b.failed

For now we have a limited number of machine driver configurations, and
we can detect them based on the link configuration returned after
checking hardware and firmware (BIOS) configurations.

The link configuration is checked with a link_mask as well as a list
of _ADR descriptors for each link.

There is a chance that in extreme cases where the BIOS contains too
much information we would need to detect which Slave devices actually
report as 'attached'. This would be more accurate than static
table-based solutions, but it also introduces timing dependencies
since we don't know when those devices might become attached, so will
only be only be looked at if we see limitations with static methods
and the usual quirks based e.g. on DMI information.

	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
	Signed-off-by: Bard Liao <yung-chuan.liao@linux.intel.com>
	Signed-off-by: Rander Wang <rander.wang@intel.com>
Link: https://lore.kernel.org/r/20200325215027.28716-6-pierre-louis.bossart@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit b9ddd81bad19ef7b0955156e7590130127cfdaae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/intel/hda.c
diff --cc sound/soc/sof/intel/hda.c
index e20431686d1c,dea3c385b664..000000000000
--- a/sound/soc/sof/intel/hda.c
+++ b/sound/soc/sof/intel/hda.c
@@@ -18,7 -18,10 +18,12 @@@
  #include <sound/hdaudio_ext.h>
  #include <sound/hda_register.h>
  
 -#include <linux/acpi.h>
  #include <linux/module.h>
++<<<<<<< HEAD
++=======
+ #include <linux/soundwire/sdw.h>
+ #include <linux/soundwire/sdw_intel.h>
++>>>>>>> b9ddd81bad19 (ASoC: SOF: Intel: hda: initial SoundWire machine driver autodetect)
  #include <sound/intel-nhlt.h>
  #include <sound/sof.h>
  #include <sound/sof/xtensa.h>
@@@ -34,6 -38,168 +39,171 @@@
  
  #define EXCEPT_MAX_HDR_SIZE	0x400
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL_SOUNDWIRE)
+ 
+ static int sdw_params_stream(struct device *dev,
+ 			     struct sdw_intel_stream_params_data *params_data)
+ {
+ 	struct snd_sof_dev *sdev = dev_get_drvdata(dev);
+ 	struct snd_soc_dai *d = params_data->dai;
+ 	struct sof_ipc_dai_config config;
+ 	struct sof_ipc_reply reply;
+ 	int link_id = params_data->link_id;
+ 	int alh_stream_id = params_data->alh_stream_id;
+ 	int ret;
+ 	u32 size = sizeof(config);
+ 
+ 	memset(&config, 0, size);
+ 	config.hdr.size = size;
+ 	config.hdr.cmd = SOF_IPC_GLB_DAI_MSG | SOF_IPC_DAI_CONFIG;
+ 	config.type = SOF_DAI_INTEL_ALH;
+ 	config.dai_index = (link_id << 8) | (d->id);
+ 	config.alh.stream_id = alh_stream_id;
+ 
+ 	/* send message to DSP */
+ 	ret = sof_ipc_tx_message(sdev->ipc,
+ 				 config.hdr.cmd, &config, size, &reply,
+ 				 sizeof(reply));
+ 	if (ret < 0) {
+ 		dev_err(sdev->dev,
+ 			"error: failed to set DAI hw_params for link %d dai->id %d ALH %d\n",
+ 			link_id, d->id, alh_stream_id);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int sdw_free_stream(struct device *dev,
+ 			   struct sdw_intel_stream_free_data *free_data)
+ {
+ 	struct snd_sof_dev *sdev = dev_get_drvdata(dev);
+ 	struct snd_soc_dai *d = free_data->dai;
+ 	struct sof_ipc_dai_config config;
+ 	struct sof_ipc_reply reply;
+ 	int link_id = free_data->link_id;
+ 	int ret;
+ 	u32 size = sizeof(config);
+ 
+ 	memset(&config, 0, size);
+ 	config.hdr.size = size;
+ 	config.hdr.cmd = SOF_IPC_GLB_DAI_MSG | SOF_IPC_DAI_CONFIG;
+ 	config.type = SOF_DAI_INTEL_ALH;
+ 	config.dai_index = (link_id << 8) | d->id;
+ 	config.alh.stream_id = 0xFFFF; /* invalid value on purpose */
+ 
+ 	/* send message to DSP */
+ 	ret = sof_ipc_tx_message(sdev->ipc,
+ 				 config.hdr.cmd, &config, size, &reply,
+ 				 sizeof(reply));
+ 	if (ret < 0) {
+ 		dev_err(sdev->dev,
+ 			"error: failed to free stream for link %d dai->id %d\n",
+ 			link_id, d->id);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static const struct sdw_intel_ops sdw_callback = {
+ 	.params_stream = sdw_params_stream,
+ 	.free_stream = sdw_free_stream,
+ };
+ 
+ void hda_sdw_int_enable(struct snd_sof_dev *sdev, bool enable)
+ {
+ 	sdw_intel_enable_irq(sdev->bar[HDA_DSP_BAR], enable);
+ }
+ 
+ static int hda_sdw_acpi_scan(struct snd_sof_dev *sdev)
+ {
+ 	struct sof_intel_hda_dev *hdev;
+ 	acpi_handle handle;
+ 	int ret;
+ 
+ 	handle = ACPI_HANDLE(sdev->dev);
+ 
+ 	/* save ACPI info for the probe step */
+ 	hdev = sdev->pdata->hw_pdata;
+ 
+ 	ret = sdw_intel_acpi_scan(handle, &hdev->info);
+ 	if (ret < 0) {
+ 		dev_err(sdev->dev, "%s failed\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int hda_sdw_probe(struct snd_sof_dev *sdev)
+ {
+ 	struct sof_intel_hda_dev *hdev;
+ 	struct sdw_intel_res res;
+ 	void *sdw;
+ 
+ 	hdev = sdev->pdata->hw_pdata;
+ 
+ 	memset(&res, 0, sizeof(res));
+ 
+ 	res.mmio_base = sdev->bar[HDA_DSP_BAR];
+ 	res.irq = sdev->ipc_irq;
+ 	res.handle = hdev->info.handle;
+ 	res.parent = sdev->dev;
+ 	res.ops = &sdw_callback;
+ 	res.dev = sdev->dev;
+ 
+ 	/*
+ 	 * ops and arg fields are not populated for now,
+ 	 * they will be needed when the DAI callbacks are
+ 	 * provided
+ 	 */
+ 
+ 	/* we could filter links here if needed, e.g for quirks */
+ 	res.count = hdev->info.count;
+ 	res.link_mask = hdev->info.link_mask;
+ 
+ 	sdw = sdw_intel_probe(&res);
+ 	if (!sdw) {
+ 		dev_err(sdev->dev, "error: SoundWire probe failed\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* save context */
+ 	hdev->sdw = sdw;
+ 
+ 	return 0;
+ }
+ 
+ int hda_sdw_startup(struct snd_sof_dev *sdev)
+ {
+ 	struct sof_intel_hda_dev *hdev;
+ 
+ 	hdev = sdev->pdata->hw_pdata;
+ 
+ 	if (!hdev->sdw)
+ 		return 0;
+ 
+ 	return sdw_intel_startup(hdev->sdw);
+ }
+ 
+ static int hda_sdw_exit(struct snd_sof_dev *sdev)
+ {
+ 	struct sof_intel_hda_dev *hdev;
+ 
+ 	hdev = sdev->pdata->hw_pdata;
+ 
+ 	hda_sdw_int_enable(sdev, false);
+ 
+ 	if (hdev->sdw)
+ 		sdw_intel_exit(hdev->sdw);
+ 	hdev->sdw = NULL;
+ 
+ 	return 0;
+ }
+ #endif
+ 
++>>>>>>> b9ddd81bad19 (ASoC: SOF: Intel: hda: initial SoundWire machine driver autodetect)
  /*
   * Debug
   */
@@@ -380,6 -534,34 +550,37 @@@ static int hda_init_caps(struct snd_sof
  		return ret;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* scan SoundWire capabilities exposed by DSDT */
+ 	ret = hda_sdw_acpi_scan(sdev);
+ 	if (ret < 0) {
+ 		dev_dbg(sdev->dev, "skipping SoundWire, ACPI scan error\n");
+ 		goto skip_soundwire;
+ 	}
+ 
+ 	link_mask = hdev->info.link_mask;
+ 	if (!link_mask) {
+ 		dev_dbg(sdev->dev, "skipping SoundWire, no links enabled\n");
+ 		goto skip_soundwire;
+ 	}
+ 
+ 	/*
+ 	 * probe/allocate SoundWire resources.
+ 	 * The hardware configuration takes place in hda_sdw_startup
+ 	 * after power rails are enabled.
+ 	 * It's entirely possible to have a mix of I2S/DMIC/SoundWire
+ 	 * devices, so we allocate the resources in all cases.
+ 	 */
+ 	ret = hda_sdw_probe(sdev);
+ 	if (ret < 0) {
+ 		dev_err(sdev->dev, "error: SoundWire probe error\n");
+ 		return ret;
+ 	}
+ 
+ skip_soundwire:
+ 
++>>>>>>> b9ddd81bad19 (ASoC: SOF: Intel: hda: initial SoundWire machine driver autodetect)
  #if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA)
  	if (bus->mlcap)
  		snd_hdac_ext_bus_get_ml_capabilities(bus);
@@@ -761,4 -860,262 +962,262 @@@ int hda_dsp_remove(struct snd_sof_dev *
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #if IS_ENABLED(CONFIG_SND_SOC_SOF_HDA)
+ static int hda_generic_machine_select(struct snd_sof_dev *sdev)
+ {
+ 	struct hdac_bus *bus = sof_to_bus(sdev);
+ 	struct snd_soc_acpi_mach_params *mach_params;
+ 	struct snd_soc_acpi_mach *hda_mach;
+ 	struct snd_sof_pdata *pdata = sdev->pdata;
+ 	const char *tplg_filename;
+ 	const char *idisp_str;
+ 	const char *dmic_str;
+ 	int dmic_num = 0;
+ 	int codec_num = 0;
+ 	int i;
+ 
+ 	/* codec detection */
+ 	if (!bus->codec_mask) {
+ 		dev_info(bus->dev, "no hda codecs found!\n");
+ 	} else {
+ 		dev_info(bus->dev, "hda codecs found, mask %lx\n",
+ 			 bus->codec_mask);
+ 
+ 		for (i = 0; i < HDA_MAX_CODECS; i++) {
+ 			if (bus->codec_mask & (1 << i))
+ 				codec_num++;
+ 		}
+ 
+ 		/*
+ 		 * If no machine driver is found, then:
+ 		 *
+ 		 * generic hda machine driver can handle:
+ 		 *  - one HDMI codec, and/or
+ 		 *  - one external HDAudio codec
+ 		 */
+ 		if (!pdata->machine && codec_num <= 2) {
+ 			hda_mach = snd_soc_acpi_intel_hda_machines;
+ 
+ 			/* topology: use the info from hda_machines */
+ 			pdata->tplg_filename =
+ 				hda_mach->sof_tplg_filename;
+ 
+ 			dev_info(bus->dev, "using HDA machine driver %s now\n",
+ 				 hda_mach->drv_name);
+ 
+ 			if (codec_num == 1 && HDA_IDISP_CODEC(bus->codec_mask))
+ 				idisp_str = "-idisp";
+ 			else
+ 				idisp_str = "";
+ 
+ 			/* first check NHLT for DMICs */
+ 			dmic_num = check_nhlt_dmic(sdev);
+ 
+ 			/* allow for module parameter override */
+ 			if (hda_dmic_num != -1)
+ 				dmic_num = hda_dmic_num;
+ 
+ 			switch (dmic_num) {
+ 			case 2:
+ 				dmic_str = "-2ch";
+ 				break;
+ 			case 4:
+ 				dmic_str = "-4ch";
+ 				break;
+ 			default:
+ 				dmic_num = 0;
+ 				dmic_str = "";
+ 				break;
+ 			}
+ 
+ 			tplg_filename = pdata->tplg_filename;
+ 			tplg_filename = fixup_tplg_name(sdev, tplg_filename,
+ 							idisp_str, dmic_str);
+ 			if (!tplg_filename)
+ 				return -EINVAL;
+ 
+ 			pdata->machine = hda_mach;
+ 			pdata->tplg_filename = tplg_filename;
+ 		}
+ 	}
+ 
+ 	/* used by hda machine driver to create dai links */
+ 	if (pdata->machine) {
+ 		mach_params = (struct snd_soc_acpi_mach_params *)
+ 			&pdata->machine->mach_params;
+ 		mach_params->codec_mask = bus->codec_mask;
+ 		mach_params->common_hdmi_codec_drv = hda_codec_use_common_hdmi;
+ 		mach_params->dmic_num = dmic_num;
+ 	}
+ 
+ 	return 0;
+ }
+ #else
+ static int hda_generic_machine_select(struct snd_sof_dev *sdev)
+ {
+ 	return 0;
+ }
+ #endif
+ 
+ #if IS_ENABLED(CONFIG_SND_SOC_SOF_INTEL_SOUNDWIRE)
+ /* Check if all Slaves defined on the link can be found */
+ static bool link_slaves_found(struct snd_sof_dev *sdev,
+ 			      const struct snd_soc_acpi_link_adr *link,
+ 			      struct sdw_intel_ctx *sdw)
+ {
+ 	struct hdac_bus *bus = sof_to_bus(sdev);
+ 	struct sdw_intel_slave_id *ids = sdw->ids;
+ 	int num_slaves = sdw->num_slaves;
+ 	unsigned int part_id, link_id, unique_id, mfg_id;
+ 	int i, j;
+ 
+ 	for (i = 0; i < link->num_adr; i++) {
+ 		u64 adr = link->adr_d[i].adr;
+ 
+ 		mfg_id = SDW_MFG_ID(adr);
+ 		part_id = SDW_PART_ID(adr);
+ 		link_id = SDW_DISCO_LINK_ID(adr);
+ 		for (j = 0; j < num_slaves; j++) {
+ 			if (ids[j].link_id != link_id ||
+ 			    ids[j].id.part_id != part_id ||
+ 			    ids[j].id.mfg_id != mfg_id)
+ 				continue;
+ 			/*
+ 			 * we have to check unique id
+ 			 * if there is more than one
+ 			 * Slave on the link
+ 			 */
+ 			unique_id = SDW_UNIQUE_ID(adr);
+ 			if (link->num_adr == 1 ||
+ 			    ids[j].id.unique_id == SDW_IGNORED_UNIQUE_ID ||
+ 			    ids[j].id.unique_id == unique_id) {
+ 				dev_dbg(bus->dev,
+ 					"found %x at link %d\n",
+ 					part_id, link_id);
+ 				break;
+ 			}
+ 		}
+ 		if (j == num_slaves) {
+ 			dev_dbg(bus->dev,
+ 				"Slave %x not found\n",
+ 				part_id);
+ 			return false;
+ 		}
+ 	}
+ 	return true;
+ }
+ 
+ static int hda_sdw_machine_select(struct snd_sof_dev *sdev)
+ {
+ 	struct snd_sof_pdata *pdata = sdev->pdata;
+ 	const struct snd_soc_acpi_link_adr *link;
+ 	struct hdac_bus *bus = sof_to_bus(sdev);
+ 	struct snd_soc_acpi_mach *mach;
+ 	struct sof_intel_hda_dev *hdev;
+ 	u32 link_mask;
+ 	int i;
+ 
+ 	hdev = pdata->hw_pdata;
+ 	link_mask = hdev->info.link_mask;
+ 
+ 	/*
+ 	 * Select SoundWire machine driver if needed using the
+ 	 * alternate tables. This case deals with SoundWire-only
+ 	 * machines, for mixed cases with I2C/I2S the detection relies
+ 	 * on the HID list.
+ 	 */
+ 	if (link_mask && !pdata->machine) {
+ 		for (mach = pdata->desc->alt_machines;
+ 		     mach && mach->link_mask; mach++) {
+ 			if (mach->link_mask != link_mask)
+ 				continue;
+ 
+ 			/* No need to match adr if there is no links defined */
+ 			if (!mach->links)
+ 				break;
+ 
+ 			link = mach->links;
+ 			for (i = 0; i < hdev->info.count && link->num_adr;
+ 			     i++, link++) {
+ 				/*
+ 				 * Try next machine if any expected Slaves
+ 				 * are not found on this link.
+ 				 */
+ 				if (!link_slaves_found(sdev, link, hdev->sdw))
+ 					break;
+ 			}
+ 			/* Found if all Slaves are checked */
+ 			if (i == hdev->info.count || !link->num_adr)
+ 				break;
+ 		}
+ 		if (mach && mach->link_mask) {
+ 			dev_dbg(bus->dev,
+ 				"SoundWire machine driver %s topology %s\n",
+ 				mach->drv_name,
+ 				mach->sof_tplg_filename);
+ 			pdata->machine = mach;
+ 			mach->mach_params.links = mach->links;
+ 			mach->mach_params.link_mask = mach->link_mask;
+ 			mach->mach_params.platform = dev_name(sdev->dev);
+ 			pdata->fw_filename = mach->sof_fw_filename;
+ 			pdata->tplg_filename = mach->sof_tplg_filename;
+ 		} else {
+ 			dev_info(sdev->dev,
+ 				 "No SoundWire machine driver found\n");
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ #else
+ static int hda_sdw_machine_select(struct snd_sof_dev *sdev)
+ {
+ 	return 0;
+ }
+ #endif
+ 
+ void hda_set_mach_params(const struct snd_soc_acpi_mach *mach,
+ 			 struct device *dev)
+ {
+ 	struct snd_soc_acpi_mach_params *mach_params;
+ 
+ 	mach_params = (struct snd_soc_acpi_mach_params *)&mach->mach_params;
+ 	mach_params->platform = dev_name(dev);
+ }
+ 
+ void hda_machine_select(struct snd_sof_dev *sdev)
+ {
+ 	struct snd_sof_pdata *sof_pdata = sdev->pdata;
+ 	const struct sof_dev_desc *desc = sof_pdata->desc;
+ 	struct snd_soc_acpi_mach *mach;
+ 
+ 	mach = snd_soc_acpi_find_machine(desc->machines);
+ 	if (mach) {
+ 		sof_pdata->tplg_filename = mach->sof_tplg_filename;
+ 		sof_pdata->machine = mach;
+ 
+ 		if (mach->link_mask) {
+ 			mach->mach_params.links = mach->links;
+ 			mach->mach_params.link_mask = mach->link_mask;
+ 		}
+ 	}
+ 
+ 	/*
+ 	 * If I2S fails, try SoundWire
+ 	 */
+ 	hda_sdw_machine_select(sdev);
+ 
+ 	/*
+ 	 * Choose HDA generic machine driver if mach is NULL.
+ 	 * Otherwise, set certain mach params.
+ 	 */
+ 	hda_generic_machine_select(sdev);
+ 
+ 	if (!sof_pdata->machine)
+ 		dev_warn(sdev->dev, "warning: No matching ASoC machine driver found\n");
+ }
+ 
++>>>>>>> b9ddd81bad19 (ASoC: SOF: Intel: hda: initial SoundWire machine driver autodetect)
  MODULE_LICENSE("Dual BSD/GPL");
 -MODULE_IMPORT_NS(SND_SOC_SOF_HDA_AUDIO_CODEC);
 -MODULE_IMPORT_NS(SND_SOC_SOF_HDA_AUDIO_CODEC_I915);
 -MODULE_IMPORT_NS(SND_SOC_SOF_XTENSA);
* Unmerged path sound/soc/sof/intel/hda.c
