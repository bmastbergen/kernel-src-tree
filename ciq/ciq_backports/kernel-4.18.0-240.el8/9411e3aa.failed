gpiolib: Initialize the hardware with a callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 9411e3aaa6342eb730daa55cf3377463a37d2aa7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9411e3aa.failed

After changing the drivers to use GPIO core to add an IRQ chip
it appears that some of them requires a hardware initialization
before adding the IRQ chip.

Add an optional callback ->init_hw() to allow that drivers
to initialize hardware if needed.

This change is a part of the fix NULL pointer dereference
brought to the several drivers recently.

	Cc: Hans de Goede <hdegoede@redhat.com>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 9411e3aaa6342eb730daa55cf3377463a37d2aa7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib.c
#	include/linux/gpio/driver.h
diff --cc drivers/gpio/gpiolib.c
index df0d87866af5,104ed299d5ea..000000000000
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@@ -1376,6 -1407,18 +1377,21 @@@ int gpiochip_add_data_with_key(struct g
  
  	machine_gpiochip_add(chip);
  
++<<<<<<< HEAD
++=======
+ 	ret = gpiochip_irqchip_init_hw(chip);
+ 	if (ret)
+ 		goto err_remove_acpi_chip;
+ 
+ 	ret = gpiochip_irqchip_init_valid_mask(chip);
+ 	if (ret)
+ 		goto err_remove_acpi_chip;
+ 
+ 	ret = gpiochip_add_irqchip(chip, lock_key, request_key);
+ 	if (ret)
+ 		goto err_remove_irqchip_mask;
+ 
++>>>>>>> 9411e3aaa634 (gpiolib: Initialize the hardware with a callback)
  	/*
  	 * By first adding the chardev, and then adding the device,
  	 * we get a device node entry in sysfs under
@@@ -1609,15 -1627,29 +1625,29 @@@ static struct gpio_chip *find_chip_by_n
   * The following is irqchip helper code for gpiochips.
   */
  
++<<<<<<< HEAD
 +static int gpiochip_irqchip_init_valid_mask(struct gpio_chip *gpiochip)
++=======
+ static int gpiochip_irqchip_init_hw(struct gpio_chip *gc)
+ {
+ 	struct gpio_irq_chip *girq = &gc->irq;
+ 
+ 	if (!girq->init_hw)
+ 		return 0;
+ 
+ 	return girq->init_hw(gc);
+ }
+ 
+ static int gpiochip_irqchip_init_valid_mask(struct gpio_chip *gc)
++>>>>>>> 9411e3aaa634 (gpiolib: Initialize the hardware with a callback)
  {
 -	struct gpio_irq_chip *girq = &gc->irq;
 -
 -	if (!girq->init_valid_mask)
 +	if (!gpiochip->irq.need_valid_mask)
  		return 0;
  
 -	girq->valid_mask = gpiochip_allocate_mask(gc);
 -	if (!girq->valid_mask)
 +	gpiochip->irq.valid_mask = gpiochip_allocate_mask(gpiochip);
 +	if (!gpiochip->irq.valid_mask)
  		return -ENOMEM;
  
 -	girq->init_valid_mask(gc, girq->valid_mask, gc->ngpio);
 -
  	return 0;
  }
  
diff --cc include/linux/gpio/driver.h
index 92cc189f3371,5dd9c982e2cb..000000000000
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@@ -117,11 -202,25 +117,29 @@@ struct gpio_irq_chip 
  	bool threaded;
  
  	/**
++<<<<<<< HEAD
 +	 * @need_valid_mask:
 +	 *
 +	 * If set core allocates @valid_mask with all bits set to one.
++=======
+ 	 * @init_hw: optional routine to initialize hardware before
+ 	 * an IRQ chip will be added. This is quite useful when
+ 	 * a particular driver wants to clear IRQ related registers
+ 	 * in order to avoid undesired events.
+ 	 */
+ 	int (*init_hw)(struct gpio_chip *chip);
+ 
+ 	/**
+ 	 * @init_valid_mask: optional routine to initialize @valid_mask, to be
+ 	 * used if not all GPIO lines are valid interrupts. Sometimes some
+ 	 * lines just cannot fire interrupts, and this routine, when defined,
+ 	 * is passed a bitmap in "valid_mask" and it will have ngpios
+ 	 * bits from 0..(ngpios-1) set to "1" as in valid. The callback can
+ 	 * then directly set some bits to "0" if they cannot be used for
+ 	 * interrupts.
++>>>>>>> 9411e3aaa634 (gpiolib: Initialize the hardware with a callback)
  	 */
 -	void (*init_valid_mask)(struct gpio_chip *chip,
 -				unsigned long *valid_mask,
 -				unsigned int ngpios);
 +	bool need_valid_mask;
  
  	/**
  	 * @valid_mask:
* Unmerged path drivers/gpio/gpiolib.c
* Unmerged path include/linux/gpio/driver.h
