efi: Common enable/disable infrastructure for EFI soft reservation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Dan Williams <dan.j.williams@intel.com>
commit b617c5266eedbef2ccbb90931bb9175faa4ae0bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b617c526.failed

UEFI 2.8 defines an EFI_MEMORY_SP attribute bit to augment the
interpretation of the EFI Memory Types as "reserved for a specific
purpose".

The proposed Linux behavior for specific purpose memory is that it is
reserved for direct-access (device-dax) by default and not available for
any kernel usage, not even as an OOM fallback.  Later, through udev
scripts or another init mechanism, these device-dax claimed ranges can
be reconfigured and hot-added to the available System-RAM with a unique
node identifier. This device-dax management scheme implements "soft" in
the "soft reserved" designation by allowing some or all of the
reservation to be recovered as typical memory. This policy can be
disabled at compile-time with CONFIG_EFI_SOFT_RESERVE=n, or runtime with
efi=nosoftreserve.

As for this patch, define the common helpers to determine if the
EFI_MEMORY_SP attribute should be honored. The determination needs to be
made early to prevent the kernel from being loaded into soft-reserved
memory, or otherwise allowing early allocations to land there. Follow-on
changes are needed per architecture to leverage these helpers in their
respective mem-init paths.

	Reviewed-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Acked-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit b617c5266eedbef2ccbb90931bb9175faa4ae0bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/firmware/efi/libstub/efi-stub-helper.c
#	include/linux/efi.h
diff --cc drivers/firmware/efi/libstub/efi-stub-helper.c
index 2edf4a348084,e02579907f2e..000000000000
--- a/drivers/firmware/efi/libstub/efi-stub-helper.c
+++ b/drivers/firmware/efi/libstub/efi-stub-helper.c
@@@ -34,6 -31,8 +34,11 @@@ static unsigned long __chunk_size = EFI
  
  static int __section(.data) __nokaslr;
  static int __section(.data) __quiet;
++<<<<<<< HEAD
++=======
+ static int __section(.data) __novamap;
+ static bool __section(.data) efi_nosoftreserve;
++>>>>>>> b617c5266eed (efi: Common enable/disable infrastructure for EFI soft reservation)
  
  int __pure nokaslr(void)
  {
@@@ -43,6 -42,14 +48,17 @@@ int __pure is_quiet(void
  {
  	return __quiet;
  }
++<<<<<<< HEAD
++=======
+ int __pure novamap(void)
+ {
+ 	return __novamap;
+ }
+ bool __pure __efi_soft_reserve_enabled(void)
+ {
+ 	return !efi_nosoftreserve;
+ }
++>>>>>>> b617c5266eed (efi: Common enable/disable infrastructure for EFI soft reservation)
  
  #define EFI_MMAP_NR_SLACK_SLOTS	8
  
@@@ -449,6 -492,17 +473,20 @@@ efi_status_t efi_parse_options(char con
  			__chunk_size = -1UL;
  		}
  
++<<<<<<< HEAD
++=======
+ 		if (!strncmp(str, "novamap", 7)) {
+ 			str += strlen("novamap");
+ 			__novamap = 1;
+ 		}
+ 
+ 		if (IS_ENABLED(CONFIG_EFI_SOFT_RESERVE) &&
+ 		    !strncmp(str, "nosoftreserve", 7)) {
+ 			str += strlen("nosoftreserve");
+ 			efi_nosoftreserve = 1;
+ 		}
+ 
++>>>>>>> b617c5266eed (efi: Common enable/disable infrastructure for EFI soft reservation)
  		/* Group words together, delimited by "," */
  		while (*str && *str != ' ' && *str != ',')
  			str++;
diff --cc include/linux/efi.h
index 215834abdb1f,88654910ce29..000000000000
--- a/include/linux/efi.h
+++ b/include/linux/efi.h
@@@ -1183,14 -1202,7 +1183,18 @@@ extern int __init efi_setup_pcdp_consol
  #define EFI_DBG			8	/* Print additional debug info at runtime */
  #define EFI_NX_PE_DATA		9	/* Can runtime data regions be mapped non-executable? */
  #define EFI_MEM_ATTR		10	/* Did firmware publish an EFI_MEMORY_ATTRIBUTES table? */
++<<<<<<< HEAD
 +#define EFI_SECURE_BOOT		11	/* Are we in Secure Boot mode? */
 +
 +enum efi_secureboot_mode {
 +	efi_secureboot_mode_unset,
 +	efi_secureboot_mode_unknown,
 +	efi_secureboot_mode_disabled,
 +	efi_secureboot_mode_enabled,
 +};
++=======
+ #define EFI_MEM_NO_SOFT_RESERVE	11	/* Is the kernel configured to ignore soft reservations? */
++>>>>>>> b617c5266eed (efi: Common enable/disable infrastructure for EFI soft reservation)
  
  #ifdef CONFIG_EFI
  /*
@@@ -1202,8 -1214,13 +1206,18 @@@ static inline bool efi_enabled(int feat
  }
  extern void efi_reboot(enum reboot_mode reboot_mode, const char *__unused);
  
++<<<<<<< HEAD
 +extern bool efi_is_table_address(unsigned long phys_addr);
 +extern void __init efi_set_secure_boot(enum efi_secureboot_mode mode);
++=======
+ bool __pure __efi_soft_reserve_enabled(void);
+ 
+ static inline bool __pure efi_soft_reserve_enabled(void)
+ {
+ 	return IS_ENABLED(CONFIG_EFI_SOFT_RESERVE)
+ 		&& __efi_soft_reserve_enabled();
+ }
++>>>>>>> b617c5266eed (efi: Common enable/disable infrastructure for EFI soft reservation)
  #else
  static inline bool efi_enabled(int feature)
  {
@@@ -1218,12 -1235,10 +1232,19 @@@ efi_capsule_pending(int *reset_type
  	return false;
  }
  
++<<<<<<< HEAD
 +static inline bool efi_is_table_address(unsigned long phys_addr)
 +{
 +	return false;
 +}
 +
 +static inline void efi_set_secure_boot(enum efi_secureboot_mode mode) {}
++=======
+ static inline bool efi_soft_reserve_enabled(void)
+ {
+ 	return false;
+ }
++>>>>>>> b617c5266eed (efi: Common enable/disable infrastructure for EFI soft reservation)
  #endif
  
  extern int efi_status_to_err(efi_status_t status);
diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt
index 1516724676e4..56aef537338f 100644
--- a/Documentation/admin-guide/kernel-parameters.txt
+++ b/Documentation/admin-guide/kernel-parameters.txt
@@ -1129,7 +1129,8 @@
 			Format: {"off" | "on" | "skip[mbr]"}
 
 	efi=		[EFI]
-			Format: { "old_map", "nochunk", "noruntime", "debug" }
+			Format: { "old_map", "nochunk", "noruntime", "debug",
+				  "nosoftreserve" }
 			old_map [X86-64]: switch to the old ioremap-based EFI
 			runtime services mapping. 32-bit still uses this one by
 			default.
@@ -1138,6 +1139,12 @@
 			firmware implementations.
 			noruntime : disable EFI runtime services support
 			debug: enable misc debug output
+			nosoftreserve: The EFI_MEMORY_SP (Specific Purpose)
+			attribute may cause the kernel to reserve the
+			memory range for a memory mapping driver to
+			claim. Specify efi=nosoftreserve to disable this
+			reservation and treat the memory by its base type
+			(i.e. EFI_CONVENTIONAL_MEMORY / "System RAM").
 
 	efi_no_storage_paranoia [EFI; X86]
 			Using this parameter you can use more than 50% of
diff --git a/drivers/firmware/efi/Kconfig b/drivers/firmware/efi/Kconfig
index 8816a625623f..56be4f55a92b 100644
--- a/drivers/firmware/efi/Kconfig
+++ b/drivers/firmware/efi/Kconfig
@@ -74,6 +74,27 @@ config EFI_MAX_FAKE_MEM
 	  Ranges can be set up to this value using comma-separated list.
 	  The default value is 8.
 
+config EFI_SOFT_RESERVE
+	bool "Reserve EFI Specific Purpose Memory"
+	depends on EFI && EFI_STUB && ACPI_HMAT
+	default ACPI_HMAT
+	help
+	  On systems that have mixed performance classes of memory EFI
+	  may indicate specific purpose memory with an attribute (See
+	  EFI_MEMORY_SP in UEFI 2.8). A memory range tagged with this
+	  attribute may have unique performance characteristics compared
+	  to the system's general purpose "System RAM" pool. On the
+	  expectation that such memory has application specific usage,
+	  and its base EFI memory type is "conventional" answer Y to
+	  arrange for the kernel to reserve it as a "Soft Reserved"
+	  resource, and set aside for direct-access (device-dax) by
+	  default. The memory range can later be optionally assigned to
+	  the page allocator by system administrator policy via the
+	  device-dax kmem facility. Say N to have the kernel treat this
+	  memory as "System RAM" by default.
+
+	  If unsure, say Y.
+
 config EFI_PARAMS_FROM_FDT
 	bool
 	help
diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c
index 067d8a7fcd7a..a682049e14fc 100644
--- a/drivers/firmware/efi/efi.c
+++ b/drivers/firmware/efi/efi.c
@@ -104,6 +104,11 @@ bool efi_runtime_disabled(void)
 	return disable_runtime;
 }
 
+bool __pure __efi_soft_reserve_enabled(void)
+{
+	return !efi_enabled(EFI_MEM_NO_SOFT_RESERVE);
+}
+
 static int __init parse_efi_cmdline(char *str)
 {
 	if (!str) {
@@ -117,6 +122,9 @@ static int __init parse_efi_cmdline(char *str)
 	if (parse_option_str(str, "noruntime"))
 		disable_runtime = true;
 
+	if (parse_option_str(str, "nosoftreserve"))
+		set_bit(EFI_MEM_NO_SOFT_RESERVE, &efi.flags);
+
 	return 0;
 }
 early_param("efi", parse_efi_cmdline);
* Unmerged path drivers/firmware/efi/libstub/efi-stub-helper.c
* Unmerged path include/linux/efi.h
