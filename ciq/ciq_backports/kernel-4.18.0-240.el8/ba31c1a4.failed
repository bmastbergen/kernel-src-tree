futex: Move futex exit handling into futex code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit ba31c1a48538992316cc71ce94fa9cd3e7b427c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ba31c1a4.failed

The futex exit handling is #ifdeffed into mm_release() which is not pretty
to begin with. But upcoming changes to address futex exit races need to add
more functionality to this exit code.

Split it out into a function, move it into futex code and make the various
futex exit functions static.

Preparatory only and no functional change.

Folded build fix from Borislav.

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Reviewed-by: Ingo Molnar <mingo@kernel.org>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Link: https://lkml.kernel.org/r/20191106224556.049705556@linutronix.de


(cherry picked from commit ba31c1a48538992316cc71ce94fa9cd3e7b427c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/futex.c
diff --cc kernel/futex.c
index ec3cc9521f31,f8f00d47c821..000000000000
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@@ -3608,11 -3654,30 +3615,29 @@@ static void exit_robust_list(struct tas
  		cond_resched();
  	}
  
 -	if (pending) {
 +	if (pending)
  		handle_futex_death((void __user *)pending + futex_offset,
 -				   curr, pip, HANDLE_DEATH_PENDING);
 -	}
 +				   curr, pip);
  }
  
+ void futex_mm_release(struct task_struct *tsk)
+ {
+ 	if (unlikely(tsk->robust_list)) {
+ 		exit_robust_list(tsk);
+ 		tsk->robust_list = NULL;
+ 	}
+ 
+ #ifdef CONFIG_COMPAT
+ 	if (unlikely(tsk->compat_robust_list)) {
+ 		compat_exit_robust_list(tsk);
+ 		tsk->compat_robust_list = NULL;
+ 	}
+ #endif
+ 
+ 	if (unlikely(!list_empty(&tsk->pi_state_list)))
+ 		exit_pi_state_list(tsk);
+ }
+ 
  long do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,
  		u32 __user *uaddr2, u32 val2, u32 val3)
  {
@@@ -3708,6 -3773,195 +3733,198 @@@ SYSCALL_DEFINE6(futex, u32 __user *, ua
  	return do_futex(uaddr, op, val, tp, uaddr2, val2, val3);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_COMPAT
+ /*
+  * Fetch a robust-list pointer. Bit 0 signals PI futexes:
+  */
+ static inline int
+ compat_fetch_robust_entry(compat_uptr_t *uentry, struct robust_list __user **entry,
+ 		   compat_uptr_t __user *head, unsigned int *pi)
+ {
+ 	if (get_user(*uentry, head))
+ 		return -EFAULT;
+ 
+ 	*entry = compat_ptr((*uentry) & ~1);
+ 	*pi = (unsigned int)(*uentry) & 1;
+ 
+ 	return 0;
+ }
+ 
+ static void __user *futex_uaddr(struct robust_list __user *entry,
+ 				compat_long_t futex_offset)
+ {
+ 	compat_uptr_t base = ptr_to_compat(entry);
+ 	void __user *uaddr = compat_ptr(base + futex_offset);
+ 
+ 	return uaddr;
+ }
+ 
+ /*
+  * Walk curr->robust_list (very carefully, it's a userspace list!)
+  * and mark any locks found there dead, and notify any waiters.
+  *
+  * We silently return on any sign of list-walking problem.
+  */
+ static void compat_exit_robust_list(struct task_struct *curr)
+ {
+ 	struct compat_robust_list_head __user *head = curr->compat_robust_list;
+ 	struct robust_list __user *entry, *next_entry, *pending;
+ 	unsigned int limit = ROBUST_LIST_LIMIT, pi, pip;
+ 	unsigned int uninitialized_var(next_pi);
+ 	compat_uptr_t uentry, next_uentry, upending;
+ 	compat_long_t futex_offset;
+ 	int rc;
+ 
+ 	if (!futex_cmpxchg_enabled)
+ 		return;
+ 
+ 	/*
+ 	 * Fetch the list head (which was registered earlier, via
+ 	 * sys_set_robust_list()):
+ 	 */
+ 	if (compat_fetch_robust_entry(&uentry, &entry, &head->list.next, &pi))
+ 		return;
+ 	/*
+ 	 * Fetch the relative futex offset:
+ 	 */
+ 	if (get_user(futex_offset, &head->futex_offset))
+ 		return;
+ 	/*
+ 	 * Fetch any possibly pending lock-add first, and handle it
+ 	 * if it exists:
+ 	 */
+ 	if (compat_fetch_robust_entry(&upending, &pending,
+ 			       &head->list_op_pending, &pip))
+ 		return;
+ 
+ 	next_entry = NULL;	/* avoid warning with gcc */
+ 	while (entry != (struct robust_list __user *) &head->list) {
+ 		/*
+ 		 * Fetch the next entry in the list before calling
+ 		 * handle_futex_death:
+ 		 */
+ 		rc = compat_fetch_robust_entry(&next_uentry, &next_entry,
+ 			(compat_uptr_t __user *)&entry->next, &next_pi);
+ 		/*
+ 		 * A pending lock might already be on the list, so
+ 		 * dont process it twice:
+ 		 */
+ 		if (entry != pending) {
+ 			void __user *uaddr = futex_uaddr(entry, futex_offset);
+ 
+ 			if (handle_futex_death(uaddr, curr, pi,
+ 					       HANDLE_DEATH_LIST))
+ 				return;
+ 		}
+ 		if (rc)
+ 			return;
+ 		uentry = next_uentry;
+ 		entry = next_entry;
+ 		pi = next_pi;
+ 		/*
+ 		 * Avoid excessively long or circular lists:
+ 		 */
+ 		if (!--limit)
+ 			break;
+ 
+ 		cond_resched();
+ 	}
+ 	if (pending) {
+ 		void __user *uaddr = futex_uaddr(pending, futex_offset);
+ 
+ 		handle_futex_death(uaddr, curr, pip, HANDLE_DEATH_PENDING);
+ 	}
+ }
+ 
+ COMPAT_SYSCALL_DEFINE2(set_robust_list,
+ 		struct compat_robust_list_head __user *, head,
+ 		compat_size_t, len)
+ {
+ 	if (!futex_cmpxchg_enabled)
+ 		return -ENOSYS;
+ 
+ 	if (unlikely(len != sizeof(*head)))
+ 		return -EINVAL;
+ 
+ 	current->compat_robust_list = head;
+ 
+ 	return 0;
+ }
+ 
+ COMPAT_SYSCALL_DEFINE3(get_robust_list, int, pid,
+ 			compat_uptr_t __user *, head_ptr,
+ 			compat_size_t __user *, len_ptr)
+ {
+ 	struct compat_robust_list_head __user *head;
+ 	unsigned long ret;
+ 	struct task_struct *p;
+ 
+ 	if (!futex_cmpxchg_enabled)
+ 		return -ENOSYS;
+ 
+ 	rcu_read_lock();
+ 
+ 	ret = -ESRCH;
+ 	if (!pid)
+ 		p = current;
+ 	else {
+ 		p = find_task_by_vpid(pid);
+ 		if (!p)
+ 			goto err_unlock;
+ 	}
+ 
+ 	ret = -EPERM;
+ 	if (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))
+ 		goto err_unlock;
+ 
+ 	head = p->compat_robust_list;
+ 	rcu_read_unlock();
+ 
+ 	if (put_user(sizeof(*head), len_ptr))
+ 		return -EFAULT;
+ 	return put_user(ptr_to_compat(head), head_ptr);
+ 
+ err_unlock:
+ 	rcu_read_unlock();
+ 
+ 	return ret;
+ }
+ #endif /* CONFIG_COMPAT */
+ 
+ #ifdef CONFIG_COMPAT_32BIT_TIME
+ SYSCALL_DEFINE6(futex_time32, u32 __user *, uaddr, int, op, u32, val,
+ 		struct old_timespec32 __user *, utime, u32 __user *, uaddr2,
+ 		u32, val3)
+ {
+ 	struct timespec64 ts;
+ 	ktime_t t, *tp = NULL;
+ 	int val2 = 0;
+ 	int cmd = op & FUTEX_CMD_MASK;
+ 
+ 	if (utime && (cmd == FUTEX_WAIT || cmd == FUTEX_LOCK_PI ||
+ 		      cmd == FUTEX_WAIT_BITSET ||
+ 		      cmd == FUTEX_WAIT_REQUEUE_PI)) {
+ 		if (get_old_timespec32(&ts, utime))
+ 			return -EFAULT;
+ 		if (!timespec64_valid(&ts))
+ 			return -EINVAL;
+ 
+ 		t = timespec64_to_ktime(ts);
+ 		if (cmd == FUTEX_WAIT)
+ 			t = ktime_add_safe(ktime_get(), t);
+ 		tp = &t;
+ 	}
+ 	if (cmd == FUTEX_REQUEUE || cmd == FUTEX_CMP_REQUEUE ||
+ 	    cmd == FUTEX_CMP_REQUEUE_PI || cmd == FUTEX_WAKE_OP)
+ 		val2 = (int) (unsigned long) utime;
+ 
+ 	return do_futex(uaddr, op, val, tp, uaddr2, val2, val3);
+ }
+ #endif /* CONFIG_COMPAT_32BIT_TIME */
+ 
++>>>>>>> ba31c1a48538 (futex: Move futex exit handling into futex code)
  static void __init futex_detect_cmpxchg(void)
  {
  #ifndef CONFIG_HAVE_FUTEX_CMPXCHG
diff --git a/include/linux/compat.h b/include/linux/compat.h
index 190b7c77cc5a..43a1973555fe 100644
--- a/include/linux/compat.h
+++ b/include/linux/compat.h
@@ -455,8 +455,6 @@ struct compat_kexec_segment;
 struct compat_mq_attr;
 struct compat_msgbuf;
 
-extern void compat_exit_robust_list(struct task_struct *curr);
-
 #define BITS_PER_COMPAT_LONG    (8*sizeof(compat_long_t))
 
 #define BITS_TO_COMPAT_LONGS(bits) DIV_ROUND_UP(bits, BITS_PER_COMPAT_LONG)
diff --git a/include/linux/futex.h b/include/linux/futex.h
index 821ae502d3d8..14927bc0fecc 100644
--- a/include/linux/futex.h
+++ b/include/linux/futex.h
@@ -2,7 +2,9 @@
 #ifndef _LINUX_FUTEX_H
 #define _LINUX_FUTEX_H
 
+#include <linux/sched.h>
 #include <linux/ktime.h>
+
 #include <uapi/linux/futex.h>
 
 struct inode;
@@ -51,7 +53,18 @@ union futex_key {
 #define FUTEX_KEY_INIT (union futex_key) { .both = { .ptr = NULL } }
 
 #ifdef CONFIG_FUTEX
-extern void exit_robust_list(struct task_struct *curr);
+
+static inline void futex_init_task(struct task_struct *tsk)
+{
+	tsk->robust_list = NULL;
+#ifdef CONFIG_COMPAT
+	tsk->compat_robust_list = NULL;
+#endif
+	INIT_LIST_HEAD(&tsk->pi_state_list);
+	tsk->pi_state_cache = NULL;
+}
+
+void futex_mm_release(struct task_struct *tsk);
 
 long do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,
 	      u32 __user *uaddr2, u32 val2, u32 val3);
@@ -61,10 +74,8 @@ long do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,
 extern int futex_cmpxchg_enabled;
 #endif
 #else
-static inline void exit_robust_list(struct task_struct *curr)
-{
-}
-
+static inline void futex_init_task(struct task_struct *tsk) { }
+static inline void futex_mm_release(struct task_struct *tsk) { }
 static inline long do_futex(u32 __user *uaddr, int op, u32 val,
 			    ktime_t *timeout, u32 __user *uaddr2,
 			    u32 val2, u32 val3)
@@ -73,12 +84,4 @@ static inline long do_futex(u32 __user *uaddr, int op, u32 val,
 }
 #endif
 
-#ifdef CONFIG_FUTEX_PI
-extern void exit_pi_state_list(struct task_struct *curr);
-#else
-static inline void exit_pi_state_list(struct task_struct *curr)
-{
-}
-#endif
-
 #endif
diff --git a/kernel/fork.c b/kernel/fork.c
index 388cbbc896ae..21b84b599f35 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1266,20 +1266,7 @@ static int wait_for_vfork_done(struct task_struct *child,
 void mm_release(struct task_struct *tsk, struct mm_struct *mm)
 {
 	/* Get rid of any futexes when releasing the mm */
-#ifdef CONFIG_FUTEX
-	if (unlikely(tsk->robust_list)) {
-		exit_robust_list(tsk);
-		tsk->robust_list = NULL;
-	}
-#ifdef CONFIG_COMPAT
-	if (unlikely(tsk->compat_robust_list)) {
-		compat_exit_robust_list(tsk);
-		tsk->compat_robust_list = NULL;
-	}
-#endif
-	if (unlikely(!list_empty(&tsk->pi_state_list)))
-		exit_pi_state_list(tsk);
-#endif
+	futex_mm_release(tsk);
 
 	uprobe_free_utask(tsk);
 
@@ -1971,14 +1958,8 @@ static __latent_entropy struct task_struct *copy_process(
 #ifdef CONFIG_BLOCK
 	p->plug = NULL;
 #endif
-#ifdef CONFIG_FUTEX
-	p->robust_list = NULL;
-#ifdef CONFIG_COMPAT
-	p->compat_robust_list = NULL;
-#endif
-	INIT_LIST_HEAD(&p->pi_state_list);
-	p->pi_state_cache = NULL;
-#endif
+	futex_init_task(p);
+
 	/*
 	 * sigaltstack should be cleared when sharing the same VM
 	 */
* Unmerged path kernel/futex.c
