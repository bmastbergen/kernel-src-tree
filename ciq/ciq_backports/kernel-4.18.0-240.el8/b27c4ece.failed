libperf: Include perf_evsel in evsel object

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit b27c4ece725a7f2225f76ad05dc6f3f5463fe893
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b27c4ece.failed

Including perf_evsel in evsel object, will continue to move other
generic things into libperf's perf_evsel struct.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Alexey Budankov <alexey.budankov@linux.intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20190721112506.12306-36-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit b27c4ece725a7f2225f76ad05dc6f3f5463fe893)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/ui/browsers/hists.c
#	tools/perf/util/evlist.c
#	tools/perf/util/evlist.h
#	tools/perf/util/evsel.h
#	tools/perf/util/parse-events.c
diff --cc tools/perf/ui/browsers/hists.c
index a94eb0755e8b,280347499c50..000000000000
--- a/tools/perf/ui/browsers/hists.c
+++ b/tools/perf/ui/browsers/hists.c
@@@ -3210,9 -3210,9 +3210,15 @@@ struct perf_evsel_menu 
  static void perf_evsel_menu__write(struct ui_browser *browser,
  				   void *entry, int row)
  {
++<<<<<<< HEAD
 +	struct perf_evsel_menu *menu = container_of(browser,
 +						    struct perf_evsel_menu, b);
 +	struct perf_evsel *evsel = list_entry(entry, struct perf_evsel, node);
++=======
+ 	struct evsel_menu *menu = container_of(browser,
+ 						    struct evsel_menu, b);
+ 	struct evsel *evsel = list_entry(entry, struct evsel, core.node);
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  	struct hists *hists = evsel__hists(evsel);
  	bool current_entry = ui_browser__is_current_entry(browser, row);
  	unsigned long nr_events = hists->stats.nr_events[PERF_RECORD_SAMPLE];
@@@ -3351,7 -3351,7 +3357,11 @@@ out
  static bool filter_group_entries(struct ui_browser *browser __maybe_unused,
  				 void *entry)
  {
++<<<<<<< HEAD
 +	struct perf_evsel *evsel = list_entry(entry, struct perf_evsel, node);
++=======
+ 	struct evsel *evsel = list_entry(entry, struct evsel, core.node);
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  
  	if (symbol_conf.event_group && !perf_evsel__is_group_leader(evsel))
  		return true;
diff --cc tools/perf/util/evlist.c
index 4739b7914374,227576bf16c0..000000000000
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@@ -115,14 -114,14 +115,14 @@@ static void perf_evlist__update_id_pos(
  	perf_evlist__set_id_pos(evlist);
  }
  
 -static void perf_evlist__purge(struct evlist *evlist)
 +static void perf_evlist__purge(struct perf_evlist *evlist)
  {
 -	struct evsel *pos, *n;
 +	struct perf_evsel *pos, *n;
  
  	evlist__for_each_entry_safe(evlist, n, pos) {
- 		list_del_init(&pos->node);
+ 		list_del_init(&pos->core.node);
  		pos->evlist = NULL;
 -		evsel__delete(pos);
 +		perf_evsel__delete(pos);
  	}
  
  	evlist->nr_entries = 0;
@@@ -178,10 -177,10 +178,10 @@@ static void perf_evlist__propagate_maps
  		__perf_evlist__propagate_maps(evlist, evsel);
  }
  
 -void evlist__add(struct evlist *evlist, struct evsel *entry)
 +void perf_evlist__add(struct perf_evlist *evlist, struct perf_evsel *entry)
  {
  	entry->evlist = evlist;
- 	list_add_tail(&entry->node, &evlist->entries);
+ 	list_add_tail(&entry->core.node, &evlist->entries);
  	entry->idx = evlist->nr_entries;
  	entry->tracking = !entry->idx;
  
@@@ -191,30 -190,30 +191,40 @@@
  	__perf_evlist__propagate_maps(evlist, entry);
  }
  
 -void evlist__remove(struct evlist *evlist, struct evsel *evsel)
 +void perf_evlist__remove(struct perf_evlist *evlist, struct perf_evsel *evsel)
  {
  	evsel->evlist = NULL;
- 	list_del_init(&evsel->node);
+ 	list_del_init(&evsel->core.node);
  	evlist->nr_entries -= 1;
  }
  
 -void perf_evlist__splice_list_tail(struct evlist *evlist,
 +void perf_evlist__splice_list_tail(struct perf_evlist *evlist,
  				   struct list_head *list)
  {
 -	struct evsel *evsel, *temp;
 +	struct perf_evsel *evsel, *temp;
  
  	__evlist__for_each_entry_safe(list, temp, evsel) {
++<<<<<<< HEAD
 +		list_del_init(&evsel->node);
 +		perf_evlist__add(evlist, evsel);
++=======
+ 		list_del_init(&evsel->core.node);
+ 		evlist__add(evlist, evsel);
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  	}
  }
  
  void __perf_evlist__set_leader(struct list_head *list)
  {
 -	struct evsel *evsel, *leader;
 +	struct perf_evsel *evsel, *leader;
  
++<<<<<<< HEAD
 +	leader = list_entry(list->next, struct perf_evsel, node);
 +	evsel = list_entry(list->prev, struct perf_evsel, node);
++=======
+ 	leader = list_entry(list->next, struct evsel, core.node);
+ 	evsel = list_entry(list->prev, struct evsel, core.node);
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  
  	leader->nr_members = evsel->idx - leader->idx + 1;
  
diff --cc tools/perf/util/evlist.h
index 49354fe24d5f,1315e64ad69e..000000000000
--- a/tools/perf/util/evlist.h
+++ b/tools/perf/util/evlist.h
@@@ -228,24 -228,24 +228,32 @@@ static inline bool perf_evlist__empty(s
  	return list_empty(&evlist->entries);
  }
  
 -static inline struct evsel *perf_evlist__first(struct evlist *evlist)
 +static inline struct perf_evsel *perf_evlist__first(struct perf_evlist *evlist)
  {
++<<<<<<< HEAD
 +	return list_entry(evlist->entries.next, struct perf_evsel, node);
++=======
+ 	return list_entry(evlist->entries.next, struct evsel, core.node);
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  }
  
 -static inline struct evsel *perf_evlist__last(struct evlist *evlist)
 +static inline struct perf_evsel *perf_evlist__last(struct perf_evlist *evlist)
  {
++<<<<<<< HEAD
 +	return list_entry(evlist->entries.prev, struct perf_evsel, node);
++=======
+ 	return list_entry(evlist->entries.prev, struct evsel, core.node);
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  }
  
 -size_t perf_evlist__fprintf(struct evlist *evlist, FILE *fp);
 +size_t perf_evlist__fprintf(struct perf_evlist *evlist, FILE *fp);
  
 -int perf_evlist__strerror_open(struct evlist *evlist, int err, char *buf, size_t size);
 -int perf_evlist__strerror_mmap(struct evlist *evlist, int err, char *buf, size_t size);
 +int perf_evlist__strerror_open(struct perf_evlist *evlist, int err, char *buf, size_t size);
 +int perf_evlist__strerror_mmap(struct perf_evlist *evlist, int err, char *buf, size_t size);
  
 -bool perf_evlist__can_select_event(struct evlist *evlist, const char *str);
 -void perf_evlist__to_front(struct evlist *evlist,
 -			   struct evsel *move_evsel);
 +bool perf_evlist__can_select_event(struct perf_evlist *evlist, const char *str);
 +void perf_evlist__to_front(struct perf_evlist *evlist,
 +			   struct perf_evsel *move_evsel);
  
  /**
   * __evlist__for_each_entry - iterate thru all the evsels
diff --cc tools/perf/util/evsel.h
index b27935a6d36c,d74cac6fe306..000000000000
--- a/tools/perf/util/evsel.h
+++ b/tools/perf/util/evsel.h
@@@ -84,11 -85,10 +85,10 @@@ enum perf_tool_event 
  
  struct bpf_object;
  
 -/** struct evsel - event selector
 +/** struct perf_evsel - event selector
   *
   * @evlist - evlist this evsel is in, if it is in one.
-  * @node - To insert it into evlist->entries or in other list_heads, say in
-  *         the event parsing routines.
+  * @core - libperf evsel object
   * @name - Can be set to retain the original event name passed by the user,
   *         so that when showing results in tools such as 'perf stat', we
   *         show the name used, not some alias.
@@@ -100,9 -100,9 +100,15 @@@
   *          is used there is an id sample appended to non-sample events
   * @priv:   And what is in its containing unnamed union are tool specific
   */
++<<<<<<< HEAD
 +struct perf_evsel {
 +	struct list_head	node;
 +	struct perf_evlist	*evlist;
++=======
+ struct evsel {
+ 	struct perf_evsel	core;
+ 	struct evlist	*evlist;
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  	struct perf_event_attr	attr;
  	char			*filter;
  	struct xyarray		*fd;
@@@ -385,14 -384,14 +391,22 @@@ int perf_evsel__parse_sample_timestamp(
  				       union perf_event *event,
  				       u64 *timestamp);
  
 -static inline struct evsel *perf_evsel__next(struct evsel *evsel)
 +static inline struct perf_evsel *perf_evsel__next(struct perf_evsel *evsel)
  {
++<<<<<<< HEAD
 +	return list_entry(evsel->node.next, struct perf_evsel, node);
++=======
+ 	return list_entry(evsel->core.node.next, struct evsel, core.node);
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  }
  
 -static inline struct evsel *perf_evsel__prev(struct evsel *evsel)
 +static inline struct perf_evsel *perf_evsel__prev(struct perf_evsel *evsel)
  {
++<<<<<<< HEAD
 +	return list_entry(evsel->node.prev, struct perf_evsel, node);
++=======
+ 	return list_entry(evsel->core.node.prev, struct evsel, core.node);
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  }
  
  /**
@@@ -479,17 -478,17 +493,27 @@@ static inline int perf_evsel__group_idx
  
  /* Iterates group WITHOUT the leader. */
  #define for_each_group_member(_evsel, _leader) 					\
++<<<<<<< HEAD
 +for ((_evsel) = list_entry((_leader)->node.next, struct perf_evsel, node); 	\
 +     (_evsel) && (_evsel)->leader == (_leader);					\
 +     (_evsel) = list_entry((_evsel)->node.next, struct perf_evsel, node))
++=======
+ for ((_evsel) = list_entry((_leader)->core.node.next, struct evsel, core.node); \
+      (_evsel) && (_evsel)->leader == (_leader);					\
+      (_evsel) = list_entry((_evsel)->core.node.next, struct evsel, core.node))
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  
  /* Iterates group WITH the leader. */
  #define for_each_group_evsel(_evsel, _leader) 					\
  for ((_evsel) = _leader; 							\
       (_evsel) && (_evsel)->leader == (_leader);					\
++<<<<<<< HEAD
 +     (_evsel) = list_entry((_evsel)->node.next, struct perf_evsel, node))
++=======
+      (_evsel) = list_entry((_evsel)->core.node.next, struct evsel, core.node))
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  
 -static inline bool perf_evsel__has_branch_callstack(const struct evsel *evsel)
 +static inline bool perf_evsel__has_branch_callstack(const struct perf_evsel *evsel)
  {
  	return evsel->attr.branch_sample_type & PERF_SAMPLE_BRANCH_CALL_STACK;
  }
diff --cc tools/perf/util/parse-events.c
index 0540303e5e97,e111c0e0a5ac..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -660,9 -660,9 +660,15 @@@ static int add_bpf_event(const char *gr
  
  		pr_debug("Failed to add BPF event %s:%s\n",
  			 group, event);
++<<<<<<< HEAD
 +		list_for_each_entry_safe(evsel, tmp, &new_evsels, node) {
 +			list_del_init(&evsel->node);
 +			perf_evsel__delete(evsel);
++=======
+ 		list_for_each_entry_safe(evsel, tmp, &new_evsels, core.node) {
+ 			list_del_init(&evsel->core.node);
+ 			evsel__delete(evsel);
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  		}
  		return err;
  	}
@@@ -1458,8 -1458,8 +1464,13 @@@ parse_events__set_leader_for_uncore_ali
  	bool is_leader = true;
  	int i, nr_pmu = 0, total_members, ret = 0;
  
++<<<<<<< HEAD
 +	leader = list_first_entry(list, struct perf_evsel, node);
 +	evsel = list_last_entry(list, struct perf_evsel, node);
++=======
+ 	leader = list_first_entry(list, struct evsel, core.node);
+ 	evsel = list_last_entry(list, struct evsel, core.node);
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  	total_members = evsel->idx - leader->idx + 1;
  
  	leaders = calloc(total_members, sizeof(uintptr_t));
@@@ -1555,7 -1555,7 +1566,11 @@@ void parse_events__set_leader(char *nam
  		return;
  
  	__perf_evlist__set_leader(list);
++<<<<<<< HEAD
 +	leader = list_entry(list->next, struct perf_evsel, node);
++=======
+ 	leader = list_entry(list->next, struct evsel, core.node);
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  	leader->group_name = name ? strdup(name) : NULL;
  }
  
@@@ -2050,9 -2050,9 +2065,13 @@@ foreach_evsel_in_last_glob(struct perf_
  		if (!last)
  			return 0;
  
- 		if (last->node.prev == &evlist->entries)
+ 		if (last->core.node.prev == &evlist->entries)
  			return 0;
++<<<<<<< HEAD
 +		last = list_entry(last->node.prev, struct perf_evsel, node);
++=======
+ 		last = list_entry(last->core.node.prev, struct evsel, core.node);
++>>>>>>> b27c4ece725a (libperf: Include perf_evsel in evsel object)
  	} while (!last->cmdline_group_boundary);
  
  	return 0;
diff --git a/tools/perf/builtin-sched.c b/tools/perf/builtin-sched.c
index d17a75eb69b7..88b6c0865db7 100644
--- a/tools/perf/builtin-sched.c
+++ b/tools/perf/builtin-sched.c
@@ -2930,7 +2930,7 @@ static int timehist_check_attr(struct perf_sched *sched,
 	struct perf_evsel *evsel;
 	struct evsel_runtime *er;
 
-	list_for_each_entry(evsel, &evlist->entries, node) {
+	list_for_each_entry(evsel, &evlist->entries, core.node) {
 		er = perf_evsel__get_runtime(evsel);
 		if (er == NULL) {
 			pr_err("Failed to allocate memory for evsel runtime data\n");
diff --git a/tools/perf/builtin-trace.c b/tools/perf/builtin-trace.c
index 9f9c869e0f26..6b0af1b28b28 100644
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@ -2636,7 +2636,7 @@ static bool perf_evlist__add_vfs_getname(struct perf_evlist *evlist)
 			continue;
 		}
 
-		list_del_init(&evsel->node);
+		list_del_init(&evsel->core.node);
 		evsel->evlist = NULL;
 		perf_evsel__delete(evsel);
 	}
* Unmerged path tools/perf/ui/browsers/hists.c
* Unmerged path tools/perf/util/evlist.c
* Unmerged path tools/perf/util/evlist.h
diff --git a/tools/perf/util/evsel.c b/tools/perf/util/evsel.c
index e99257f738ba..15feb85be639 100644
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@ -237,7 +237,7 @@ void perf_evsel__init(struct perf_evsel *evsel,
 	evsel->evlist	   = NULL;
 	evsel->bpf_obj	   = NULL;
 	evsel->bpf_fd	   = -1;
-	INIT_LIST_HEAD(&evsel->node);
+	INIT_LIST_HEAD(&evsel->core.node);
 	INIT_LIST_HEAD(&evsel->config_terms);
 	perf_evsel__object.init(evsel);
 	evsel->sample_size = __perf_evsel__sample_size(attr->sample_type);
@@ -1319,7 +1319,7 @@ void perf_evsel__close_fd(struct perf_evsel *evsel)
 
 void perf_evsel__exit(struct perf_evsel *evsel)
 {
-	assert(list_empty(&evsel->node));
+	assert(list_empty(&evsel->core.node));
 	assert(evsel->evlist == NULL);
 	perf_evsel__free_counts(evsel);
 	perf_evsel__free_fd(evsel);
* Unmerged path tools/perf/util/evsel.h
* Unmerged path tools/perf/util/parse-events.c
diff --git a/tools/perf/util/stat-display.c b/tools/perf/util/stat-display.c
index 58df6a0dbb9f..0df797b390a7 100644
--- a/tools/perf/util/stat-display.c
+++ b/tools/perf/util/stat-display.c
@@ -548,8 +548,8 @@ static void collect_all_aliases(struct perf_stat_config *config, struct perf_evs
 	struct perf_evlist *evlist = counter->evlist;
 	struct perf_evsel *alias;
 
-	alias = list_prepare_entry(counter, &(evlist->entries), node);
-	list_for_each_entry_continue (alias, &evlist->entries, node) {
+	alias = list_prepare_entry(counter, &(evlist->entries), core.node);
+	list_for_each_entry_continue (alias, &evlist->entries, core.node) {
 		if (strcmp(perf_evsel__name(alias), perf_evsel__name(counter)) ||
 		    alias->scale != counter->scale ||
 		    alias->cgrp != counter->cgrp ||
diff --git a/tools/perf/util/trace-event-info.c b/tools/perf/util/trace-event-info.c
index 76a460ff7867..672f03192606 100644
--- a/tools/perf/util/trace-event-info.c
+++ b/tools/perf/util/trace-event-info.c
@@ -424,7 +424,7 @@ get_tracepoints_path(struct list_head *pattrs)
 	struct perf_evsel *pos;
 	int nr_tracepoints = 0;
 
-	list_for_each_entry(pos, pattrs, node) {
+	list_for_each_entry(pos, pattrs, core.node) {
 		if (pos->attr.type != PERF_TYPE_TRACEPOINT)
 			continue;
 		++nr_tracepoints;
@@ -459,7 +459,7 @@ bool have_tracepoints(struct list_head *pattrs)
 {
 	struct perf_evsel *pos;
 
-	list_for_each_entry(pos, pattrs, node)
+	list_for_each_entry(pos, pattrs, core.node)
 		if (pos->attr.type == PERF_TYPE_TRACEPOINT)
 			return true;
 
