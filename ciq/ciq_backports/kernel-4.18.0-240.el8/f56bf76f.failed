nvme-fc: Ensure private pointers are NULL if no data

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author James Smart <jsmart2021@gmail.com>
commit f56bf76f79f3dc15f17433dda1b567d34f18e699
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f56bf76f.failed

Ensure that when allocations are done, and the lldd options indicate
no private data is needed, that private pointers will be set to NULL
(catches driver error that forgot to set private data size).

Slightly reorg the allocations so that private data follows allocations
for LS request/response buffers. Ensures better alignments for the buffers
as well as the private pointer.

	Signed-off-by: James Smart <jsmart2021@gmail.com>
	Reviewed-by: Sagi Grimberg <sagi@grimberg.me>
	Reviewed-by: Hannes Reinecke <hare@suse.de>
	Reviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit f56bf76f79f3dc15f17433dda1b567d34f18e699)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/fc.c
diff --cc drivers/nvme/host/fc.c
index abf753478680,bf80b941d739..000000000000
--- a/drivers/nvme/host/fc.c
+++ b/drivers/nvme/host/fc.c
@@@ -1420,21 -1402,25 +1436,34 @@@ nvme_fc_xmt_disconnect_assoc(struct nvm
  	int ret;
  
  	lsop = kzalloc((sizeof(*lsop) +
- 			 ctrl->lport->ops->lsrqst_priv_sz +
- 			 sizeof(*discon_rqst) + sizeof(*discon_acc)),
- 			GFP_KERNEL);
- 	if (!lsop)
- 		/* couldn't sent it... too bad */
+ 			sizeof(*discon_rqst) + sizeof(*discon_acc) +
+ 			ctrl->lport->ops->lsrqst_priv_sz), GFP_KERNEL);
+ 	if (!lsop) {
+ 		dev_info(ctrl->ctrl.device,
+ 			"NVME-FC{%d}: send Disconnect Association "
+ 			"failed: ENOMEM\n",
+ 			ctrl->cnum);
  		return;
+ 	}
  
++<<<<<<< HEAD
 +	lsreq = &lsop->ls_req;
 +
 +	lsreq->private = (void *)&lsop[1];
 +	discon_rqst = (struct fcnvme_ls_disconnect_rqst *)
 +			(lsreq->private + ctrl->lport->ops->lsrqst_priv_sz);
 +	discon_acc = (struct fcnvme_ls_disconnect_acc *)&discon_rqst[1];
++=======
+ 	discon_rqst = (struct fcnvme_ls_disconnect_assoc_rqst *)&lsop[1];
+ 	discon_acc = (struct fcnvme_ls_disconnect_assoc_acc *)&discon_rqst[1];
+ 	lsreq = &lsop->ls_req;
+ 	if (ctrl->lport->ops->lsrqst_priv_sz)
+ 		lsreq->private = (void *)&discon_acc[1];
+ 	else
+ 		lsreq->private = NULL;
++>>>>>>> f56bf76f79f3 (nvme-fc: Ensure private pointers are NULL if no data)
  
 -	discon_rqst->w0.ls_cmd = FCNVME_LS_DISCONNECT_ASSOC;
 +	discon_rqst->w0.ls_cmd = FCNVME_LS_DISCONNECT;
  	discon_rqst->desc_list_len = cpu_to_be32(
  				sizeof(struct fcnvme_lsdesc_assoc_id) +
  				sizeof(struct fcnvme_lsdesc_disconn_cmd));
* Unmerged path drivers/nvme/host/fc.c
diff --git a/drivers/nvme/target/fc.c b/drivers/nvme/target/fc.c
index b13d2535eb6a..1930c20e4e06 100644
--- a/drivers/nvme/target/fc.c
+++ b/drivers/nvme/target/fc.c
@@ -1067,7 +1067,10 @@ nvmet_fc_register_targetport(struct nvmet_fc_port_info *pinfo,
 
 	newrec->fc_target_port.node_name = pinfo->node_name;
 	newrec->fc_target_port.port_name = pinfo->port_name;
-	newrec->fc_target_port.private = &newrec[1];
+	if (template->target_priv_sz)
+		newrec->fc_target_port.private = &newrec[1];
+	else
+		newrec->fc_target_port.private = NULL;
 	newrec->fc_target_port.port_id = pinfo->port_id;
 	newrec->fc_target_port.port_num = idx;
 	INIT_LIST_HEAD(&newrec->tgt_list);
