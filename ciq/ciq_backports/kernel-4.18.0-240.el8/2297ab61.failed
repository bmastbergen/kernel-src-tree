gfs2: Fix problems regarding gfs2_qa_get and _put

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Bob Peterson <rpeterso@redhat.com>
commit 2297ab6144c2e85c418d0fd47b2f24e294b55dca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/2297ab61.failed

This patch fixes a couple of places in which gfs2_qa_get and gfs2_qa_put are
not balanced: we now keep references around whenever a file is open for writing
(see gfs2_open_common and gfs2_release), so we need to put all references we
grab in function gfs2_create_inode.  This was broken in the successful case and
on one error path.

This also means that we don't have a reference to put in gfs2_evict_inode.

In addition, gfs2_qa_put was called for the wrong inode in gfs2_link.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 2297ab6144c2e85c418d0fd47b2f24e294b55dca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/inode.c
#	fs/gfs2/super.c
diff --cc fs/gfs2/inode.c
index 867d3237b9a9,5acd3ce30759..000000000000
--- a/fs/gfs2/inode.c
+++ b/fs/gfs2/inode.c
@@@ -762,13 -757,18 +762,19 @@@ static int gfs2_create_inode(struct ino
  
  	mark_inode_dirty(inode);
  	d_instantiate(dentry, inode);
 -	/* After instantiate, errors should result in evict which will destroy
 -	 * both inode and iopen glocks properly. */
  	if (file) {
 -		file->f_mode |= FMODE_CREATED;
 -		error = finish_open(file, dentry, gfs2_open_common);
 +		*opened |= FILE_CREATED;
 +		error = finish_open(file, dentry, gfs2_open_common, opened);
  	}
  	gfs2_glock_dq_uninit(ghs);
+ 	gfs2_qa_put(ip);
  	gfs2_glock_dq_uninit(ghs + 1);
  	clear_bit(GLF_INODE_CREATING, &io_gl->gl_flags);
++<<<<<<< HEAD
++=======
+ 	gfs2_glock_put(io_gl);
+ 	gfs2_qa_put(dip);
++>>>>>>> 2297ab6144c2 (gfs2: Fix problems regarding gfs2_qa_get and _put)
  	return error;
  
  fail_gunlock3:
@@@ -1006,6 -1006,7 +1012,10 @@@ out_gunlock
  out_child:
  	gfs2_glock_dq(ghs);
  out_parent:
++<<<<<<< HEAD
++=======
+ 	gfs2_qa_put(dip);
++>>>>>>> 2297ab6144c2 (gfs2: Fix problems regarding gfs2_qa_get and _put)
  	gfs2_holder_uninit(ghs);
  	gfs2_holder_uninit(ghs + 1);
  	return error;
diff --cc fs/gfs2/super.c
index 54e9fed68925,956fced0a8ec..000000000000
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@@ -1693,9 -1400,10 +1693,15 @@@ out_unlock
  	if (error && error != GLR_TRYFAILED && error != -EROFS)
  		fs_warn(sdp, "gfs2_evict_inode: %d\n", error);
  out:
 +	/* Case 3 starts here */
  	truncate_inode_pages_final(&inode->i_data);
++<<<<<<< HEAD
 +	gfs2_rsqa_delete(ip, NULL);
++=======
+ 	if (ip->i_qadata)
+ 		gfs2_assert_warn(sdp, ip->i_qadata->qa_ref == 0);
+ 	gfs2_rs_delete(ip, NULL);
++>>>>>>> 2297ab6144c2 (gfs2: Fix problems regarding gfs2_qa_get and _put)
  	gfs2_ordered_del_inode(ip);
  	clear_inode(inode);
  	gfs2_dir_hash_inval(ip);
* Unmerged path fs/gfs2/inode.c
* Unmerged path fs/gfs2/super.c
