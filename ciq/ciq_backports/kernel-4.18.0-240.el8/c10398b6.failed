KVM: x86: Use KVM cpu caps to mark CR4.LA57 as not-reserved

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit c10398b6d0ddb9c8234890828ab83341e11f9840
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c10398b6.failed

Add accessor(s) for KVM cpu caps and use said accessor to detect
hardware support for LA57 instead of manually querying CPUID.

Note, the explicit conversion to bool via '!!' in kvm_cpu_cap_has() is
technically unnecessary, but it gives people a warm fuzzy feeling.

No functional change intended.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c10398b6d0ddb9c8234890828ab83341e11f9840)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.h
diff --cc arch/x86/kvm/cpuid.h
index a2335b92a9a0,e3dc0f02ad5c..000000000000
--- a/arch/x86/kvm/cpuid.h
+++ b/arch/x86/kvm/cpuid.h
@@@ -223,4 -266,39 +223,42 @@@ static inline bool cpuid_fault_enabled(
  		  MSR_MISC_FEATURES_ENABLES_CPUID_FAULT;
  }
  
++<<<<<<< HEAD
++=======
+ static __always_inline void kvm_cpu_cap_clear(unsigned int x86_feature)
+ {
+ 	unsigned int x86_leaf = x86_feature / 32;
+ 
+ 	reverse_cpuid_check(x86_leaf);
+ 	kvm_cpu_caps[x86_leaf] &= ~__feature_bit(x86_feature);
+ }
+ 
+ static __always_inline void kvm_cpu_cap_set(unsigned int x86_feature)
+ {
+ 	unsigned int x86_leaf = x86_feature / 32;
+ 
+ 	reverse_cpuid_check(x86_leaf);
+ 	kvm_cpu_caps[x86_leaf] |= __feature_bit(x86_feature);
+ }
+ 
+ static __always_inline u32 kvm_cpu_cap_get(unsigned int x86_feature)
+ {
+ 	unsigned int x86_leaf = x86_feature / 32;
+ 
+ 	reverse_cpuid_check(x86_leaf);
+ 	return kvm_cpu_caps[x86_leaf] & __feature_bit(x86_feature);
+ }
+ 
+ static __always_inline bool kvm_cpu_cap_has(unsigned int x86_feature)
+ {
+ 	return !!kvm_cpu_cap_get(x86_feature);
+ }
+ 
+ static __always_inline void kvm_cpu_cap_check_and_set(unsigned int x86_feature)
+ {
+ 	if (boot_cpu_has(x86_feature))
+ 		kvm_cpu_cap_set(x86_feature);
+ }
+ 
++>>>>>>> c10398b6d0dd (KVM: x86: Use KVM cpu caps to mark CR4.LA57 as not-reserved)
  #endif
* Unmerged path arch/x86/kvm/cpuid.h
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 4ad9e50bf3f6..db91eb3b420c 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -905,7 +905,7 @@ static u64 kvm_host_cr4_reserved_bits(struct cpuinfo_x86 *c)
 {
 	u64 reserved_bits = __cr4_reserved_bits(cpu_has, c);
 
-	if (cpuid_ecx(0x7) & feature_bit(LA57))
+	if (kvm_cpu_cap_has(X86_FEATURE_LA57))
 		reserved_bits &= ~X86_CR4_LA57;
 
 	if (kvm_x86_ops->umip_emulated())
