Bluetooth: btusb: Edit the logical value for Realtek Bluetooth reset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Max Chou <max.chou@realtek.com>
commit 34682110abc50ffea7e002b0c2fd7ea9e0000ccc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/34682110.failed

It should be pull low and pull high on the physical line for the Realtek
Bluetooth reset. gpiod_set_value_cansleep() takes ACTIVE_LOW status for
the logical value settings, so the original commit should be corrected.

	Signed-off-by: Max Chou <max.chou@realtek.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 34682110abc50ffea7e002b0c2fd7ea9e0000ccc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btusb.c
diff --cc drivers/bluetooth/btusb.c
index 5171f004a6a7,82fb2e7b2892..000000000000
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@@ -490,8 -492,71 +490,73 @@@ struct btusb_data 
  	int (*setup_on_usb)(struct hci_dev *hdev);
  
  	int oob_wake_irq;   /* irq for out-of-band wake-on-bt */
 -	unsigned cmd_timeout_cnt;
  };
  
++<<<<<<< HEAD
++=======
+ 
+ static void btusb_intel_cmd_timeout(struct hci_dev *hdev)
+ {
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 	struct gpio_desc *reset_gpio = data->reset_gpio;
+ 
+ 	if (++data->cmd_timeout_cnt < 5)
+ 		return;
+ 
+ 	if (!reset_gpio) {
+ 		bt_dev_err(hdev, "No way to reset. Ignoring and continuing");
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * Toggle the hard reset line if the platform provides one. The reset
+ 	 * is going to yank the device off the USB and then replug. So doing
+ 	 * once is enough. The cleanup is handled correctly on the way out
+ 	 * (standard USB disconnect), and the new device is detected cleanly
+ 	 * and bound to the driver again like it should be.
+ 	 */
+ 	if (test_and_set_bit(BTUSB_HW_RESET_ACTIVE, &data->flags)) {
+ 		bt_dev_err(hdev, "last reset failed? Not resetting again");
+ 		return;
+ 	}
+ 
+ 	bt_dev_err(hdev, "Initiating HW reset via gpio");
+ 	gpiod_set_value_cansleep(reset_gpio, 1);
+ 	msleep(100);
+ 	gpiod_set_value_cansleep(reset_gpio, 0);
+ }
+ 
+ static void btusb_rtl_cmd_timeout(struct hci_dev *hdev)
+ {
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 	struct gpio_desc *reset_gpio = data->reset_gpio;
+ 
+ 	if (++data->cmd_timeout_cnt < 5)
+ 		return;
+ 
+ 	if (!reset_gpio) {
+ 		bt_dev_err(hdev, "No gpio to reset Realtek device, ignoring");
+ 		return;
+ 	}
+ 
+ 	/* Toggle the hard reset line. The Realtek device is going to
+ 	 * yank itself off the USB and then replug. The cleanup is handled
+ 	 * correctly on the way out (standard USB disconnect), and the new
+ 	 * device is detected cleanly and bound to the driver again like
+ 	 * it should be.
+ 	 */
+ 	if (test_and_set_bit(BTUSB_HW_RESET_ACTIVE, &data->flags)) {
+ 		bt_dev_err(hdev, "last reset failed? Not resetting again");
+ 		return;
+ 	}
+ 
+ 	bt_dev_err(hdev, "Reset Realtek device via gpio");
+ 	gpiod_set_value_cansleep(reset_gpio, 1);
+ 	msleep(200);
+ 	gpiod_set_value_cansleep(reset_gpio, 0);
+ }
+ 
++>>>>>>> 34682110abc5 (Bluetooth: btusb: Edit the logical value for Realtek Bluetooth reset)
  static inline void btusb_free_frags(struct btusb_data *data)
  {
  	unsigned long flags;
* Unmerged path drivers/bluetooth/btusb.c
