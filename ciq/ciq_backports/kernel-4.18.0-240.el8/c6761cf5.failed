vxlan: fix unexpected failure of vxlan_changelink()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Taehee Yoo <ap420073@gmail.com>
commit c6761cf521f9bffbdcbb619dba665ebf3bcefb1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c6761cf5.failed

After commit 0ce1822c2a08 ("vxlan: add adjacent link to limit depth
level"), vxlan_changelink() could fail because of
netdev_adjacent_change_prepare().
netdev_adjacent_change_prepare() returns -EEXIST when old lower device
and new lower device are same.
(old lower device is "dst->remote_dev" and new lower device is "lowerdev")
So, before calling it, lowerdev should be NULL if these devices are same.

Test command1:
    ip link add dummy0 type dummy
    ip link add vxlan0 type vxlan dev dummy0 dstport 4789 vni 1
    ip link set vxlan0 type vxlan ttl 5
    RTNETLINK answers: File exists

	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
Fixes: 0ce1822c2a08 ("vxlan: add adjacent link to limit depth level")
	Signed-off-by: Taehee Yoo <ap420073@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c6761cf521f9bffbdcbb619dba665ebf3bcefb1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index b5e4c39e4c74,8869154fad88..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -3813,9 -3967,19 +3813,20 @@@ static int vxlan_changelink(struct net_
  	if (err)
  		return err;
  
++<<<<<<< HEAD
++=======
+ 	if (dst->remote_dev == lowerdev)
+ 		lowerdev = NULL;
+ 
+ 	err = netdev_adjacent_change_prepare(dst->remote_dev, lowerdev, dev,
+ 					     extack);
+ 	if (err)
+ 		return err;
+ 
++>>>>>>> c6761cf521f9 (vxlan: fix unexpected failure of vxlan_changelink())
  	/* handle default dst entry */
  	if (!vxlan_addr_equal(&conf.remote_ip, &dst->remote_ip)) {
 -		u32 hash_index = fdb_head_index(vxlan, all_zeros_mac, conf.vni);
 -
 -		spin_lock_bh(&vxlan->hash_lock[hash_index]);
 +		spin_lock_bh(&vxlan->hash_lock);
  		if (!vxlan_addr_any(&conf.remote_ip)) {
  			err = vxlan_fdb_update(vxlan, all_zeros_mac,
  					       &conf.remote_ip,
@@@ -3844,6 -4010,11 +3855,14 @@@
  	if (conf.age_interval != vxlan->cfg.age_interval)
  		mod_timer(&vxlan->age_timer, jiffies);
  
++<<<<<<< HEAD
++=======
+ 	netdev_adjacent_change_commit(dst->remote_dev, lowerdev, dev);
+ 	if (lowerdev && lowerdev != dst->remote_dev) {
+ 		dst->remote_dev = lowerdev;
+ 		netdev_update_lockdep_key(lowerdev);
+ 	}
++>>>>>>> c6761cf521f9 (vxlan: fix unexpected failure of vxlan_changelink())
  	vxlan_config_apply(dev, &conf, lowerdev, vxlan->net, true);
  	return 0;
  }
* Unmerged path drivers/net/vxlan.c
