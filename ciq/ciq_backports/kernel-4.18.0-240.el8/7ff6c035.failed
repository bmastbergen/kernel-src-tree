KVM: x86: Remove stateful CPUID handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 7ff6c0350315248bb58b074c90c4683f0e415669
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7ff6c035.failed

Remove the code for handling stateful CPUID 0x2 and mark the associated
flags as deprecated.  WARN if host CPUID 0x2.0.AL > 1, i.e. if by some
miracle a host with stateful CPUID 0x2 is encountered.

No known CPU exists that supports hardware accelerated virtualization
_and_ a stateful CPUID 0x2.  Barring an extremely contrived nested
virtualization scenario, stateful CPUID support is dead code.

	Suggested-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 7ff6c0350315248bb58b074c90c4683f0e415669)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/virt/kvm/api.txt
diff --cc Documentation/virt/kvm/api.txt
index 7f54395369d4,b7d4180605ab..000000000000
--- a/Documentation/virt/kvm/api.txt
+++ b/Documentation/virt/kvm/api.txt
@@@ -1404,13 -1571,13 +1404,19 @@@ struct kvm_cpuid2 
  	__u32 nent;
  	__u32 padding;
  	struct kvm_cpuid_entry2 entries[0];
 -  };
 +};
  
++<<<<<<< HEAD:Documentation/virt/kvm/api.txt
 +#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX		BIT(0)
 +#define KVM_CPUID_FLAG_STATEFUL_FUNC		BIT(1)
 +#define KVM_CPUID_FLAG_STATE_READ_NEXT		BIT(2)
++=======
+   #define KVM_CPUID_FLAG_SIGNIFCANT_INDEX		BIT(0)
+   #define KVM_CPUID_FLAG_STATEFUL_FUNC		BIT(1) /* deprecated */
+   #define KVM_CPUID_FLAG_STATE_READ_NEXT		BIT(2) /* deprecated */
++>>>>>>> 7ff6c0350315 (KVM: x86: Remove stateful CPUID handling):Documentation/virt/kvm/api.rst
  
 -  struct kvm_cpuid_entry2 {
 +struct kvm_cpuid_entry2 {
  	__u32 function;
  	__u32 index;
  	__u32 flags;
@@@ -1447,20 -1614,21 +1453,26 @@@ with unknown or unsupported features ma
  x2apic), may not be present in the host cpu, but are exposed by kvm if it can
  emulate them efficiently. The fields in each entry are defined as follows:
  
 -  function:
 -         the eax value used to obtain the entry
 -
 -  index:
 -         the ecx value used to obtain the entry (for entries that are
 +  function: the eax value used to obtain the entry
 +  index: the ecx value used to obtain the entry (for entries that are
           affected by ecx)
 -
 -  flags:
 -     an OR of zero or more of the following:
 -
 +  flags: an OR of zero or more of the following:
          KVM_CPUID_FLAG_SIGNIFCANT_INDEX:
             if the index field is valid
++<<<<<<< HEAD:Documentation/virt/kvm/api.txt
 +        KVM_CPUID_FLAG_STATEFUL_FUNC:
 +           if cpuid for this function returns different values for successive
 +           invocations; there will be several entries with the same function,
 +           all with this flag set
 +        KVM_CPUID_FLAG_STATE_READ_NEXT:
 +           for KVM_CPUID_FLAG_STATEFUL_FUNC entries, set if this entry is
 +           the first entry to be read by a cpu
 +   eax, ebx, ecx, edx: the values returned by the cpuid instruction for
++=======
+ 
+    eax, ebx, ecx, edx:
+          the values returned by the cpuid instruction for
++>>>>>>> 7ff6c0350315 (KVM: x86: Remove stateful CPUID handling):Documentation/virt/kvm/api.rst
           this function/index combination
  
  The TSC deadline timer feature (CPUID leaf 1, ecx[24]) is always returned
@@@ -2986,11 -3337,13 +2998,19 @@@ struct kvm_cpuid2 
  
  The member 'flags' is used for passing flags from userspace.
  
 -::
 +#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX		BIT(0)
 +#define KVM_CPUID_FLAG_STATEFUL_FUNC		BIT(1)
 +#define KVM_CPUID_FLAG_STATE_READ_NEXT		BIT(2)
  
++<<<<<<< HEAD:Documentation/virt/kvm/api.txt
 +struct kvm_cpuid_entry2 {
++=======
+   #define KVM_CPUID_FLAG_SIGNIFCANT_INDEX		BIT(0)
+   #define KVM_CPUID_FLAG_STATEFUL_FUNC		BIT(1) /* deprecated */
+   #define KVM_CPUID_FLAG_STATE_READ_NEXT		BIT(2) /* deprecated */
+ 
+   struct kvm_cpuid_entry2 {
++>>>>>>> 7ff6c0350315 (KVM: x86: Remove stateful CPUID handling):Documentation/virt/kvm/api.rst
  	__u32 function;
  	__u32 index;
  	__u32 flags;
@@@ -3024,20 -3377,20 +3044,27 @@@ emulated efficiently and thus not inclu
  
  The fields in each entry are defined as follows:
  
 -  function:
 -	 the eax value used to obtain the entry
 -  index:
 -	 the ecx value used to obtain the entry (for entries that are
 +  function: the eax value used to obtain the entry
 +  index: the ecx value used to obtain the entry (for entries that are
           affected by ecx)
 -  flags:
 -    an OR of zero or more of the following:
 -
 +  flags: an OR of zero or more of the following:
          KVM_CPUID_FLAG_SIGNIFCANT_INDEX:
             if the index field is valid
++<<<<<<< HEAD:Documentation/virt/kvm/api.txt
 +        KVM_CPUID_FLAG_STATEFUL_FUNC:
 +           if cpuid for this function returns different values for successive
 +           invocations; there will be several entries with the same function,
 +           all with this flag set
 +        KVM_CPUID_FLAG_STATE_READ_NEXT:
 +           for KVM_CPUID_FLAG_STATEFUL_FUNC entries, set if this entry is
 +           the first entry to be read by a cpu
 +   eax, ebx, ecx, edx: the values returned by the cpuid instruction for
++=======
+ 
+    eax, ebx, ecx, edx:
+ 
+          the values returned by the cpuid instruction for
++>>>>>>> 7ff6c0350315 (KVM: x86: Remove stateful CPUID handling):Documentation/virt/kvm/api.rst
           this function/index combination
  
  4.89 KVM_S390_MEM_OP
* Unmerged path Documentation/virt/kvm/api.txt
diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c
index 70fb27088e0c..60741a24d3fd 100644
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@ -549,25 +549,16 @@ static inline int __do_cpuid_func(struct kvm_cpuid_array *array, u32 function)
 		 * time, with the least-significant byte in EAX enumerating the
 		 * number of times software should do CPUID(2, 0).
 		 *
-		 * Modern CPUs (quite likely every CPU KVM has *ever* run on)
-		 * are less idiotic.  Intel's SDM states that EAX & 0xff "will
-		 * always return 01H. Software should ignore this value and not
+		 * Modern CPUs, i.e. every CPU KVM has *ever* run on are less
+		 * idiotic.  Intel's SDM states that EAX & 0xff "will always
+		 * return 01H. Software should ignore this value and not
 		 * interpret it as an informational descriptor", while AMD's
 		 * APM states that CPUID(2) is reserved.
+		 *
+		 * WARN if a frankenstein CPU that supports virtualization and
+		 * a stateful CPUID.0x2 is encountered.
 		 */
-		max_idx = entry->eax & 0xff;
-		if (likely(max_idx <= 1))
-			break;
-
-		entry->flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;
-		entry->flags |= KVM_CPUID_FLAG_STATE_READ_NEXT;
-
-		for (i = 1; i < max_idx; ++i) {
-			entry = do_host_cpuid(array, function, 0);
-			if (!entry)
-				goto out;
-			entry->flags |= KVM_CPUID_FLAG_STATEFUL_FUNC;
-		}
+		WARN_ON_ONCE((entry->eax & 0xff) > 1);
 		break;
 	/* functions 4 and 0x8000001d have additional index. */
 	case 4:
@@ -938,58 +929,20 @@ int kvm_dev_ioctl_get_cpuid(struct kvm_cpuid2 *cpuid,
 	return r;
 }
 
-static int move_to_next_stateful_cpuid_entry(struct kvm_vcpu *vcpu, int i)
-{
-	struct kvm_cpuid_entry2 *e = &vcpu->arch.cpuid_entries[i];
-	struct kvm_cpuid_entry2 *ej;
-	int j = i;
-	int nent = vcpu->arch.cpuid_nent;
-
-	e->flags &= ~KVM_CPUID_FLAG_STATE_READ_NEXT;
-	/* when no next entry is found, the current entry[i] is reselected */
-	do {
-		j = (j + 1) % nent;
-		ej = &vcpu->arch.cpuid_entries[j];
-	} while (ej->function != e->function);
-
-	ej->flags |= KVM_CPUID_FLAG_STATE_READ_NEXT;
-
-	return j;
-}
-
-/* find an entry with matching function, matching index (if needed), and that
- * should be read next (if it's stateful) */
-static int is_matching_cpuid_entry(struct kvm_cpuid_entry2 *e,
-	u32 function, u32 index)
-{
-	if (e->function != function)
-		return 0;
-	if ((e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX) && e->index != index)
-		return 0;
-	if (unlikely(e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC) &&
-	    !(e->flags & KVM_CPUID_FLAG_STATE_READ_NEXT))
-		return 0;
-	return 1;
-}
-
 struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,
 					      u32 function, u32 index)
 {
+	struct kvm_cpuid_entry2 *e;
 	int i;
-	struct kvm_cpuid_entry2 *best = NULL;
 
 	for (i = 0; i < vcpu->arch.cpuid_nent; ++i) {
-		struct kvm_cpuid_entry2 *e;
-
 		e = &vcpu->arch.cpuid_entries[i];
-		if (is_matching_cpuid_entry(e, function, index)) {
-			if (unlikely(e->flags & KVM_CPUID_FLAG_STATEFUL_FUNC))
-				move_to_next_stateful_cpuid_entry(vcpu, i);
-			best = e;
-			break;
-		}
+
+		if (e->function == function && (e->index == index ||
+		    !(e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX)))
+			return e;
 	}
-	return best;
+	return NULL;
 }
 EXPORT_SYMBOL_GPL(kvm_find_cpuid_entry);
 
