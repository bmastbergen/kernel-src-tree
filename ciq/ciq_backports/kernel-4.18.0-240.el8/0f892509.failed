drm/i915/tc: Do not warn when aux power well of static TC ports timeout

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit 0f8925090ac7ad451ed9e803662ebe3214dc8072
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0f892509.failed

This is a expected timeout of static TC ports not conneceted, so
not throwing warnings that would taint CI.

v3:
- moved checks to tc_phy_aux_timeout_expected()

v4:
- moved and add comments to tc_phy_aux_timeout_expected()

v5:
- only checking tc_legacy_port for TC ports

	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
	Reviewed-by: Imre Deak <imre.deak@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200414194956.164323-8-jose.souza@intel.com
(cherry picked from commit 0f8925090ac7ad451ed9e803662ebe3214dc8072)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display_power.c
diff --cc drivers/gpu/drm/i915/display/intel_display_power.c
index dd1a43a366f2,f72b8ed095ca..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display_power.c
+++ b/drivers/gpu/drm/i915/display/intel_display_power.c
@@@ -13,11 -11,17 +13,13 @@@
  #include "intel_cdclk.h"
  #include "intel_combo_phy.h"
  #include "intel_csr.h"
 -#include "intel_display_power.h"
 -#include "intel_display_types.h"
  #include "intel_dpio_phy.h"
 +#include "intel_drv.h"
  #include "intel_hotplug.h"
 -#include "intel_pm.h"
  #include "intel_sideband.h"
 -#include "intel_tc.h"
 -#include "intel_vga.h"
  
+ static const struct i915_power_well_ops icl_tc_phy_aux_power_well_ops;
+ 
  bool intel_display_power_well_is_enabled(struct drm_i915_private *dev_priv,
  					 enum i915_power_well_id power_well_id);
  
@@@ -262,6 -286,70 +264,73 @@@ static void hsw_power_well_pre_disable(
  		gen8_irq_power_well_pre_disable(dev_priv, irq_pipe_mask);
  }
  
++<<<<<<< HEAD
++=======
+ #define ICL_AUX_PW_TO_CH(pw_idx)	\
+ 	((pw_idx) - ICL_PW_CTL_IDX_AUX_A + AUX_CH_A)
+ 
+ #define ICL_TBT_AUX_PW_TO_CH(pw_idx)	\
+ 	((pw_idx) - ICL_PW_CTL_IDX_AUX_TBT1 + AUX_CH_C)
+ 
+ static enum aux_ch icl_tc_phy_aux_ch(struct drm_i915_private *dev_priv,
+ 				     struct i915_power_well *power_well)
+ {
+ 	int pw_idx = power_well->desc->hsw.idx;
+ 
+ 	return power_well->desc->hsw.is_tc_tbt ? ICL_TBT_AUX_PW_TO_CH(pw_idx) :
+ 						 ICL_AUX_PW_TO_CH(pw_idx);
+ }
+ 
+ static struct intel_digital_port *
+ aux_ch_to_digital_port(struct drm_i915_private *dev_priv,
+ 		       enum aux_ch aux_ch)
+ {
+ 	struct intel_digital_port *dig_port = NULL;
+ 	struct intel_encoder *encoder;
+ 
+ 	for_each_intel_encoder(&dev_priv->drm, encoder) {
+ 		/* We'll check the MST primary port */
+ 		if (encoder->type == INTEL_OUTPUT_DP_MST)
+ 			continue;
+ 
+ 		dig_port = enc_to_dig_port(encoder);
+ 		if (!dig_port)
+ 			continue;
+ 
+ 		if (dig_port->aux_ch != aux_ch) {
+ 			dig_port = NULL;
+ 			continue;
+ 		}
+ 
+ 		break;
+ 	}
+ 
+ 	return dig_port;
+ }
+ 
+ static bool tc_phy_aux_timeout_expected(struct drm_i915_private *dev_priv,
+ 					struct i915_power_well *power_well)
+ {
+ 	/* An AUX timeout is expected if the TBT DP tunnel is down. */
+ 	if (power_well->desc->hsw.is_tc_tbt)
+ 		return true;
+ 
+ 	/*
+ 	 * An AUX timeout is expected because we enable TC legacy port aux
+ 	 * to hold port out of TC cold
+ 	 */
+ 	if (INTEL_GEN(dev_priv) == 11 &&
+ 	    power_well->desc->ops == &icl_tc_phy_aux_power_well_ops) {
+ 		enum aux_ch aux_ch = icl_tc_phy_aux_ch(dev_priv, power_well);
+ 		struct intel_digital_port *dig_port = aux_ch_to_digital_port(dev_priv, aux_ch);
+ 
+ 		return dig_port->tc_legacy_port;
+ 	}
+ 
+ 	return false;
+ }
+ 
++>>>>>>> 0f8925090ac7 (drm/i915/tc: Do not warn when aux power well of static TC ports timeout)
  static void hsw_wait_for_power_well_enable(struct drm_i915_private *dev_priv,
  					   struct i915_power_well *power_well)
  {
@@@ -269,11 -357,15 +338,23 @@@
  	int pw_idx = power_well->desc->hsw.idx;
  
  	/* Timeout for PW1:10 us, AUX:not specified, other PWs:20 us. */
++<<<<<<< HEAD
 +	WARN_ON(intel_wait_for_register(&dev_priv->uncore,
 +					regs->driver,
 +					HSW_PWR_WELL_CTL_STATE(pw_idx),
 +					HSW_PWR_WELL_CTL_STATE(pw_idx),
 +					1));
++=======
+ 	if (intel_de_wait_for_set(dev_priv, regs->driver,
+ 				  HSW_PWR_WELL_CTL_STATE(pw_idx), 1)) {
+ 		drm_dbg_kms(&dev_priv->drm, "%s power well enable timeout\n",
+ 			    power_well->desc->name);
+ 
+ 		drm_WARN_ON(&dev_priv->drm,
+ 			    !tc_phy_aux_timeout_expected(dev_priv, power_well));
+ 
+ 	}
++>>>>>>> 0f8925090ac7 (drm/i915/tc: Do not warn when aux power well of static TC ports timeout)
  }
  
  static u32 hsw_power_well_requesters(struct drm_i915_private *dev_priv,
@@@ -435,11 -560,72 +516,80 @@@ icl_combo_phy_aux_power_well_disable(st
  	hsw_wait_for_power_well_disable(dev_priv, power_well);
  }
  
++<<<<<<< HEAD
 +#define ICL_AUX_PW_TO_CH(pw_idx)	\
 +	((pw_idx) - ICL_PW_CTL_IDX_AUX_A + AUX_CH_A)
 +
 +#define ICL_TBT_AUX_PW_TO_CH(pw_idx)	\
 +	((pw_idx) - ICL_PW_CTL_IDX_AUX_TBT1 + AUX_CH_C)
++=======
+ #if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
+ 
+ static u64 async_put_domains_mask(struct i915_power_domains *power_domains);
+ 
+ static int power_well_async_ref_count(struct drm_i915_private *dev_priv,
+ 				      struct i915_power_well *power_well)
+ {
+ 	int refs = hweight64(power_well->desc->domains &
+ 			     async_put_domains_mask(&dev_priv->power_domains));
+ 
+ 	drm_WARN_ON(&dev_priv->drm, refs > power_well->count);
+ 
+ 	return refs;
+ }
+ 
+ static void icl_tc_port_assert_ref_held(struct drm_i915_private *dev_priv,
+ 					struct i915_power_well *power_well,
+ 					struct intel_digital_port *dig_port)
+ {
+ 	/* Bypass the check if all references are released asynchronously */
+ 	if (power_well_async_ref_count(dev_priv, power_well) ==
+ 	    power_well->count)
+ 		return;
+ 
+ 	if (drm_WARN_ON(&dev_priv->drm, !dig_port))
+ 		return;
+ 
+ 	if (INTEL_GEN(dev_priv) == 11 && dig_port->tc_legacy_port)
+ 		return;
+ 
+ 	drm_WARN_ON(&dev_priv->drm, !intel_tc_port_ref_held(dig_port));
+ }
+ 
+ #else
+ 
+ static void icl_tc_port_assert_ref_held(struct drm_i915_private *dev_priv,
+ 					struct i915_power_well *power_well,
+ 					struct intel_digital_port *dig_port)
+ {
+ }
+ 
+ #endif
+ 
+ #define TGL_AUX_PW_TO_TC_PORT(pw_idx)	((pw_idx) - TGL_PW_CTL_IDX_AUX_TC1)
+ 
+ static void icl_tc_cold_exit(struct drm_i915_private *i915)
+ {
+ 	int ret, tries = 0;
+ 
+ 	while (1) {
+ 		ret = sandybridge_pcode_write_timeout(i915,
+ 						      ICL_PCODE_EXIT_TCCOLD,
+ 						      0, 250, 1);
+ 		if (ret != -EAGAIN || ++tries == 3)
+ 			break;
+ 		msleep(1);
+ 	}
+ 
+ 	/* Spec states that TC cold exit can take up to 1ms to complete */
+ 	if (!ret)
+ 		msleep(1);
+ 
+ 	/* TODO: turn failure into a error as soon i915 CI updates ICL IFWI */
+ 	drm_dbg_kms(&i915->drm, "TC cold block %s\n", ret ? "failed" :
+ 		    "succeeded");
+ }
++>>>>>>> 0f8925090ac7 (drm/i915/tc: Do not warn when aux power well of static TC ports timeout)
  
  static void
  icl_tc_phy_aux_power_well_enable(struct drm_i915_private *dev_priv,
* Unmerged path drivers/gpu/drm/i915/display/intel_display_power.c
