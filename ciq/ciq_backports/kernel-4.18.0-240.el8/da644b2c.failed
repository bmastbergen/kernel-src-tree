null_blk: add zone open, close, and finish support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ajay Joshi <ajay.joshi@wdc.com>
commit da644b2cc1a4664ff7f75d3ae50e3fcf638580d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/da644b2c.failed

Implement REQ_OP_ZONE_OPEN, REQ_OP_ZONE_CLOSE and REQ_OP_ZONE_FINISH
support to allow explicit control of zone states.

Contains contributions from Matias Bjorling, Hans Holmberg,
Keith Busch and Damien Le Moal.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Ajay Joshi <ajay.joshi@wdc.com>
	Signed-off-by: Matias Bjorling <matias.bjorling@wdc.com>
	Signed-off-by: Hans Holmberg <hans.holmberg@wdc.com>
	Signed-off-by: Keith Busch <kbusch@kernel.org>
	Signed-off-by: Damien Le Moal <damien.lemoal@wdc.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit da644b2cc1a4664ff7f75d3ae50e3fcf638580d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/null_blk_zoned.c
diff --cc drivers/block/null_blk_zoned.c
index 176ae5c83b71,be7646205b8c..000000000000
--- a/drivers/block/null_blk_zoned.c
+++ b/drivers/block/null_blk_zoned.c
@@@ -116,19 -131,19 +116,24 @@@ void null_zone_write(struct nullb_cmd *
  		break;
  	default:
  		/* Invalid zone condition */
 -		return BLK_STS_IOERR;
 +		cmd->error = BLK_STS_IOERR;
 +		break;
  	}
 -	return BLK_STS_OK;
  }
  
++<<<<<<< HEAD
 +void null_zone_reset(struct nullb_cmd *cmd, sector_t sector)
++=======
+ static blk_status_t null_zone_mgmt(struct nullb_cmd *cmd, enum req_opf op,
+ 				   sector_t sector)
++>>>>>>> da644b2cc1a4 (null_blk: add zone open, close, and finish support)
  {
  	struct nullb_device *dev = cmd->nq->dev;
 -	struct blk_zone *zone = &dev->zones[null_zone_no(dev, sector)];
 +	unsigned int zno = null_zone_no(dev, sector);
 +	struct blk_zone *zone = &dev->zones[zno];
  	size_t i;
  
- 	switch (req_op(cmd->rq)) {
+ 	switch (op) {
  	case REQ_OP_ZONE_RESET_ALL:
  		for (i = 0; i < dev->nr_zones; i++) {
  			if (zone[i].type == BLK_ZONE_TYPE_CONVENTIONAL)
@@@ -146,7 -159,49 +151,53 @@@
  		zone->cond = BLK_ZONE_COND_EMPTY;
  		zone->wp = zone->start;
  		break;
+ 	case REQ_OP_ZONE_OPEN:
+ 		if (zone->type == BLK_ZONE_TYPE_CONVENTIONAL)
+ 			return BLK_STS_IOERR;
+ 		if (zone->cond == BLK_ZONE_COND_FULL)
+ 			return BLK_STS_IOERR;
+ 
+ 		zone->cond = BLK_ZONE_COND_EXP_OPEN;
+ 		break;
+ 	case REQ_OP_ZONE_CLOSE:
+ 		if (zone->type == BLK_ZONE_TYPE_CONVENTIONAL)
+ 			return BLK_STS_IOERR;
+ 		if (zone->cond == BLK_ZONE_COND_FULL)
+ 			return BLK_STS_IOERR;
+ 
+ 		zone->cond = BLK_ZONE_COND_CLOSED;
+ 		break;
+ 	case REQ_OP_ZONE_FINISH:
+ 		if (zone->type == BLK_ZONE_TYPE_CONVENTIONAL)
+ 			return BLK_STS_IOERR;
+ 
+ 		zone->cond = BLK_ZONE_COND_FULL;
+ 		zone->wp = zone->start + zone->len;
+ 		break;
  	default:
++<<<<<<< HEAD
 +		return BLK_STS_NOTSUPP;
++=======
+ 		cmd->error = BLK_STS_NOTSUPP;
+ 		break;
+ 	}
+ 	return BLK_STS_OK;
+ }
+ 
+ blk_status_t null_handle_zoned(struct nullb_cmd *cmd, enum req_opf op,
+ 			       sector_t sector, sector_t nr_sectors)
+ {
+ 	switch (op) {
+ 	case REQ_OP_WRITE:
+ 		return null_zone_write(cmd, sector, nr_sectors);
+ 	case REQ_OP_ZONE_RESET:
+ 	case REQ_OP_ZONE_RESET_ALL:
+ 	case REQ_OP_ZONE_OPEN:
+ 	case REQ_OP_ZONE_CLOSE:
+ 	case REQ_OP_ZONE_FINISH:
+ 		return null_zone_mgmt(cmd, op, sector);
+ 	default:
+ 		return BLK_STS_OK;
++>>>>>>> da644b2cc1a4 (null_blk: add zone open, close, and finish support)
  	}
  }
* Unmerged path drivers/block/null_blk_zoned.c
