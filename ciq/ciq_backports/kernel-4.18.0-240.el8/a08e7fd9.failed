net: Fix typo of SKB_SGO_CB_OFFSET

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] Fix typo of SKB_SGO_CB_OFFSET (Guillaume Nault) [1822148]
Rebuild_FUZZ: 92.06%
commit-author Cambda Zhu <cambda@linux.alibaba.com>
commit a08e7fd9123d85dfdf8d1dc61dbe321c8359d25f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a08e7fd9.failed

The SKB_SGO_CB_OFFSET should be SKB_GSO_CB_OFFSET which means the
offset of the GSO in skb cb. This patch fixes the typo.

Fixes: 9207f9d45b0a ("net: preserve IP control block during GSO segmentation")
	Signed-off-by: Cambda Zhu <cambda@linux.alibaba.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a08e7fd9123d85dfdf8d1dc61dbe321c8359d25f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp.c
diff --cc net/ipv4/udp.c
index 50f5c7dfecad,7ea90eb4a1ba..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -2076,6 -2101,26 +2076,29 @@@ drop
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
+ {
+ 	struct sk_buff *next, *segs;
+ 	int ret;
+ 
+ 	if (likely(!udp_unexpected_gso(sk, skb)))
+ 		return udp_queue_rcv_one_skb(sk, skb);
+ 
+ 	BUILD_BUG_ON(sizeof(struct udp_skb_cb) > SKB_GSO_CB_OFFSET);
+ 	__skb_push(skb, -skb_mac_offset(skb));
+ 	segs = udp_rcv_segment(sk, skb, true);
+ 	skb_list_walk_safe(segs, skb, next) {
+ 		__skb_pull(skb, skb_transport_offset(skb));
+ 		ret = udp_queue_rcv_one_skb(sk, skb);
+ 		if (ret > 0)
+ 			ip_protocol_deliver_rcu(dev_net(skb->dev), skb, -ret);
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> a08e7fd9123d (net: Fix typo of SKB_SGO_CB_OFFSET)
  /* For TCP sockets, sk_rx_dst is protected by socket lock
   * For UDP, we use xchg() to guard against concurrent changes.
   */
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index b56676cd0603..6f0f3bba45a2 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -4388,8 +4388,8 @@ struct skb_gso_cb {
 	__wsum	csum;
 	__u16	csum_start;
 };
-#define SKB_SGO_CB_OFFSET	32
-#define SKB_GSO_CB(skb) ((struct skb_gso_cb *)((skb)->cb + SKB_SGO_CB_OFFSET))
+#define SKB_GSO_CB_OFFSET	32
+#define SKB_GSO_CB(skb) ((struct skb_gso_cb *)((skb)->cb + SKB_GSO_CB_OFFSET))
 
 static inline int skb_tnl_header_len(const struct sk_buff *inner_skb)
 {
diff --git a/net/core/dev.c b/net/core/dev.c
index 9d0ad76edcdb..ade364a4724b 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -3053,7 +3053,7 @@ static inline bool skb_needs_check(struct sk_buff *skb, bool tx_path)
  *	It may return NULL if the skb requires no segmentation.  This is
  *	only possible when GSO is used for verifying header integrity.
  *
- *	Segmentation preserves SKB_SGO_CB_OFFSET bytes of previous skb cb.
+ *	Segmentation preserves SKB_GSO_CB_OFFSET bytes of previous skb cb.
  */
 struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
 				  netdev_features_t features, bool tx_path)
@@ -3082,7 +3082,7 @@ struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
 			features &= ~NETIF_F_GSO_PARTIAL;
 	}
 
-	BUILD_BUG_ON(SKB_SGO_CB_OFFSET +
+	BUILD_BUG_ON(SKB_GSO_CB_OFFSET +
 		     sizeof(*SKB_GSO_CB(skb)) > sizeof(skb->cb));
 
 	SKB_GSO_CB(skb)->mac_offset = skb_headroom(skb);
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index 4f210b30c3bc..719de5e655ec 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -265,7 +265,7 @@ static int ip_finish_output_gso(struct net *net, struct sock *sk,
 	 *    insufficent MTU.
 	 */
 	features = netif_skb_features(skb);
-	BUILD_BUG_ON(sizeof(*IPCB(skb)) > SKB_SGO_CB_OFFSET);
+	BUILD_BUG_ON(sizeof(*IPCB(skb)) > SKB_GSO_CB_OFFSET);
 	segs = skb_gso_segment(skb, features & ~NETIF_F_GSO_MASK);
 	if (IS_ERR_OR_NULL(segs)) {
 		kfree_skb(skb);
* Unmerged path net/ipv4/udp.c
diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c
index f25e1151f2f0..e0625d60682d 100644
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@ -317,7 +317,7 @@ static int queue_gso_packets(struct datapath *dp, struct sk_buff *skb,
 	struct sk_buff *segs, *nskb;
 	int err;
 
-	BUILD_BUG_ON(sizeof(*OVS_CB(skb)) > SKB_SGO_CB_OFFSET);
+	BUILD_BUG_ON(sizeof(*OVS_CB(skb)) > SKB_GSO_CB_OFFSET);
 	segs = __skb_gso_segment(skb, NETIF_F_SG, false);
 	if (IS_ERR(segs))
 		return PTR_ERR(segs);
diff --git a/net/xfrm/xfrm_output.c b/net/xfrm/xfrm_output.c
index 6d20fbcde000..d5749a695181 100644
--- a/net/xfrm/xfrm_output.c
+++ b/net/xfrm/xfrm_output.c
@@ -181,8 +181,8 @@ static int xfrm_output_gso(struct net *net, struct sock *sk, struct sk_buff *skb
 {
 	struct sk_buff *segs;
 
-	BUILD_BUG_ON(sizeof(*IPCB(skb)) > SKB_SGO_CB_OFFSET);
-	BUILD_BUG_ON(sizeof(*IP6CB(skb)) > SKB_SGO_CB_OFFSET);
+	BUILD_BUG_ON(sizeof(*IPCB(skb)) > SKB_GSO_CB_OFFSET);
+	BUILD_BUG_ON(sizeof(*IP6CB(skb)) > SKB_GSO_CB_OFFSET);
 	segs = skb_gso_segment(skb, 0);
 	kfree_skb(skb);
 	if (IS_ERR(segs))
