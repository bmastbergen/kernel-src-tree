KVM: x86: drop superfluous mmu_check_root() from fast_pgd_switch()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit fe9304d31831c9ee3943f9a6f72b7cea16d4bc11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/fe9304d3.failed

The mmu_check_root() check in fast_pgd_switch() seems to be
superfluous: when GPA is outside of the visible range
cached_root_available() will fail for non-direct roots
(as we can't have a matching one on the list) and we don't
seem to care for direct ones.

Also, raising #TF immediately when a non-existent GFN is written to CR3
doesn't seem to mach architectural behavior. Drop the check.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Message-Id: <20200710141157.1640173-10-vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit fe9304d31831c9ee3943f9a6f72b7cea16d4bc11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
diff --cc arch/x86/kvm/mmu/mmu.c
index 78a7db187b32,613c33149428..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -4353,39 -4242,8 +4353,44 @@@ static bool fast_cr3_switch(struct kvm_
  	 * later if necessary.
  	 */
  	if (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&
++<<<<<<< HEAD
 +	    mmu->root_level >= PT64_ROOT_4LEVEL) {
 +		if (mmu_check_root(vcpu, new_cr3 >> PAGE_SHIFT))
 +			return false;
 +
 +		if (cached_root_available(vcpu, new_cr3, new_role)) {
 +			/*
 +			 * It is possible that the cached previous root page is
 +			 * obsolete because of a change in the MMU generation
 +			 * number. However, changing the generation number is
 +			 * accompanied by KVM_REQ_MMU_RELOAD, which will free
 +			 * the root set here and allocate a new one.
 +			 */
 +			kvm_make_request(KVM_REQ_LOAD_CR3, vcpu);
 +			if (!skip_tlb_flush) {
 +				kvm_make_request(KVM_REQ_MMU_SYNC, vcpu);
 +				kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);
 +			}
 +
 +			/*
 +			 * The last MMIO access's GVA and GPA are cached in the
 +			 * VCPU. When switching to a new CR3, that GVA->GPA
 +			 * mapping may no longer be valid. So clear any cached
 +			 * MMIO info even when we don't need to sync the shadow
 +			 * page tables.
 +			 */
 +			vcpu_clear_mmio_info(vcpu, MMIO_GVA_ANY);
 +
 +			__clear_sp_write_flooding_count(
 +				page_header(mmu->root_hpa));
 +
 +			return true;
 +		}
 +	}
++=======
+ 	    mmu->root_level >= PT64_ROOT_4LEVEL)
+ 		return cached_root_available(vcpu, new_pgd, new_role);
++>>>>>>> fe9304d31831 (KVM: x86: drop superfluous mmu_check_root() from fast_pgd_switch())
  
  	return false;
  }
* Unmerged path arch/x86/kvm/mmu/mmu.c
