io_uring: file set registration should use interruptible waits

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit c150368b496837cb207712e78f903ccfd7633b93
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c150368b.failed

If an application attempts to register a set with unbounded requests
pending, we can be stuck here forever if they don't complete. We can
make this wait interruptible, and just abort if we get signaled.

	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit c150368b496837cb207712e78f903ccfd7633b93)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 28a601d08266,2c036972930f..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -3942,18 -6511,27 +3942,38 @@@ static int __io_uring_register(struct i
  	if (percpu_ref_is_dying(&ctx->refs))
  		return -ENXIO;
  
 -	if (opcode != IORING_UNREGISTER_FILES &&
 -	    opcode != IORING_REGISTER_FILES_UPDATE) {
 -		percpu_ref_kill(&ctx->refs);
 +	percpu_ref_kill(&ctx->refs);
  
++<<<<<<< HEAD
 +	/*
 +	 * Drop uring mutex before waiting for references to exit. If another
 +	 * thread is currently inside io_uring_enter() it might need to grab
 +	 * the uring_lock to make progress. If we hold it here across the drain
 +	 * wait, then we can deadlock. It's safe to drop the mutex here, since
 +	 * no new references will come in after we've killed the percpu ref.
 +	 */
 +	mutex_unlock(&ctx->uring_lock);
 +	wait_for_completion(&ctx->ctx_done);
 +	mutex_lock(&ctx->uring_lock);
++=======
+ 		/*
+ 		 * Drop uring mutex before waiting for references to exit. If
+ 		 * another thread is currently inside io_uring_enter() it might
+ 		 * need to grab the uring_lock to make progress. If we hold it
+ 		 * here across the drain wait, then we can deadlock. It's safe
+ 		 * to drop the mutex here, since no new references will come in
+ 		 * after we've killed the percpu ref.
+ 		 */
+ 		mutex_unlock(&ctx->uring_lock);
+ 		ret = wait_for_completion_interruptible(&ctx->completions[0]);
+ 		mutex_lock(&ctx->uring_lock);
+ 		if (ret) {
+ 			percpu_ref_resurrect(&ctx->refs);
+ 			ret = -EINTR;
+ 			goto out;
+ 		}
+ 	}
++>>>>>>> c150368b4968 (io_uring: file set registration should use interruptible waits)
  
  	switch (opcode) {
  	case IORING_REGISTER_BUFFERS:
@@@ -3994,9 -6572,14 +4014,20 @@@
  		break;
  	}
  
++<<<<<<< HEAD
 +	/* bring the ctx back to life */
 +	reinit_completion(&ctx->ctx_done);
 +	percpu_ref_reinit(&ctx->refs);
++=======
+ 
+ 	if (opcode != IORING_UNREGISTER_FILES &&
+ 	    opcode != IORING_REGISTER_FILES_UPDATE) {
+ 		/* bring the ctx back to life */
+ 		percpu_ref_reinit(&ctx->refs);
+ out:
+ 		reinit_completion(&ctx->completions[0]);
+ 	}
++>>>>>>> c150368b4968 (io_uring: file set registration should use interruptible waits)
  	return ret;
  }
  
* Unmerged path fs/io_uring.c
