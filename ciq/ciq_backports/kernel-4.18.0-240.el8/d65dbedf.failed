net/mlx5: Add support for COPY steering action

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Huy Nguyen <huyn@mellanox.com>
commit d65dbedfd298344747033f17c1efd2afc8082bc7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d65dbedf.failed

Add COPY type to modify_header action. IPsec feature is the first
feature that needs COPY steering action.

	Signed-off-by: Huy Nguyen <huyn@mellanox.com>
	Signed-off-by: Raed Salem <raeds@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Acked-by: Leon Romanovsky <leonro@mellanox.com>
(cherry picked from commit d65dbedfd298344747033f17c1efd2afc8082bc7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	drivers/net/ethernet/mellanox/mlx5/core/esw/chains.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 23a1c21d8bab,12c5ca5b93ca..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -54,8 -54,14 +54,14 @@@
  #include "fs_core.h"
  #include "en/port.h"
  #include "en/tc_tun.h"
 -#include "en/mapping.h"
 -#include "en/tc_ct.h"
  #include "lib/devcom.h"
  #include "lib/geneve.h"
++<<<<<<< HEAD
++=======
+ #include "diag/en_tc_tracepoint.h"
+ 
+ #define MLX5_MH_ACT_SZ MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)
++>>>>>>> d65dbedfd298 (net/mlx5: Add support for COPY steering action)
  
  struct mlx5_nic_flow_attr {
  	u32 action;
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 98ef84b15725,703f307c5967..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1370,6 -1438,148 +1370,151 @@@ out
  	return flow_rule;
  }
  
++<<<<<<< HEAD
++=======
+ 
+ static int mlx5_eswitch_inline_mode_get(const struct mlx5_eswitch *esw, u8 *mode)
+ {
+ 	u8 prev_mlx5_mode, mlx5_mode = MLX5_INLINE_MODE_L2;
+ 	struct mlx5_core_dev *dev = esw->dev;
+ 	int vport;
+ 
+ 	if (!MLX5_CAP_GEN(dev, vport_group_manager))
+ 		return -EOPNOTSUPP;
+ 
+ 	if (esw->mode == MLX5_ESWITCH_NONE)
+ 		return -EOPNOTSUPP;
+ 
+ 	switch (MLX5_CAP_ETH(dev, wqe_inline_mode)) {
+ 	case MLX5_CAP_INLINE_MODE_NOT_REQUIRED:
+ 		mlx5_mode = MLX5_INLINE_MODE_NONE;
+ 		goto out;
+ 	case MLX5_CAP_INLINE_MODE_L2:
+ 		mlx5_mode = MLX5_INLINE_MODE_L2;
+ 		goto out;
+ 	case MLX5_CAP_INLINE_MODE_VPORT_CONTEXT:
+ 		goto query_vports;
+ 	}
+ 
+ query_vports:
+ 	mlx5_query_nic_vport_min_inline(dev, esw->first_host_vport, &prev_mlx5_mode);
+ 	mlx5_esw_for_each_host_func_vport(esw, vport, esw->esw_funcs.num_vfs) {
+ 		mlx5_query_nic_vport_min_inline(dev, vport, &mlx5_mode);
+ 		if (prev_mlx5_mode != mlx5_mode)
+ 			return -EINVAL;
+ 		prev_mlx5_mode = mlx5_mode;
+ 	}
+ 
+ out:
+ 	*mode = mlx5_mode;
+ 	return 0;
+ }
+ 
+ static void esw_destroy_restore_table(struct mlx5_eswitch *esw)
+ {
+ 	struct mlx5_esw_offload *offloads = &esw->offloads;
+ 
+ 	if (!mlx5_eswitch_reg_c1_loopback_supported(esw))
+ 		return;
+ 
+ 	mlx5_modify_header_dealloc(esw->dev, offloads->restore_copy_hdr_id);
+ 	mlx5_destroy_flow_group(offloads->restore_group);
+ 	mlx5_destroy_flow_table(offloads->ft_offloads_restore);
+ }
+ 
+ static int esw_create_restore_table(struct mlx5_eswitch *esw)
+ {
+ 	u8 modact[MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)] = {};
+ 	int inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);
+ 	struct mlx5_flow_table_attr ft_attr = {};
+ 	struct mlx5_core_dev *dev = esw->dev;
+ 	struct mlx5_flow_namespace *ns;
+ 	struct mlx5_modify_hdr *mod_hdr;
+ 	void *match_criteria, *misc;
+ 	struct mlx5_flow_table *ft;
+ 	struct mlx5_flow_group *g;
+ 	u32 *flow_group_in;
+ 	int err = 0;
+ 
+ 	if (!mlx5_eswitch_reg_c1_loopback_supported(esw))
+ 		return 0;
+ 
+ 	ns = mlx5_get_flow_namespace(dev, MLX5_FLOW_NAMESPACE_OFFLOADS);
+ 	if (!ns) {
+ 		esw_warn(esw->dev, "Failed to get offloads flow namespace\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	flow_group_in = kvzalloc(inlen, GFP_KERNEL);
+ 	if (!flow_group_in) {
+ 		err = -ENOMEM;
+ 		goto out_free;
+ 	}
+ 
+ 	ft_attr.max_fte = 1 << ESW_CHAIN_TAG_METADATA_BITS;
+ 	ft = mlx5_create_flow_table(ns, &ft_attr);
+ 	if (IS_ERR(ft)) {
+ 		err = PTR_ERR(ft);
+ 		esw_warn(esw->dev, "Failed to create restore table, err %d\n",
+ 			 err);
+ 		goto out_free;
+ 	}
+ 
+ 	memset(flow_group_in, 0, inlen);
+ 	match_criteria = MLX5_ADDR_OF(create_flow_group_in, flow_group_in,
+ 				      match_criteria);
+ 	misc = MLX5_ADDR_OF(fte_match_param, match_criteria,
+ 			    misc_parameters_2);
+ 
+ 	MLX5_SET(fte_match_set_misc2, misc, metadata_reg_c_0,
+ 		 ESW_CHAIN_TAG_METADATA_MASK);
+ 	MLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, 0);
+ 	MLX5_SET(create_flow_group_in, flow_group_in, end_flow_index,
+ 		 ft_attr.max_fte - 1);
+ 	MLX5_SET(create_flow_group_in, flow_group_in, match_criteria_enable,
+ 		 MLX5_MATCH_MISC_PARAMETERS_2);
+ 	g = mlx5_create_flow_group(ft, flow_group_in);
+ 	if (IS_ERR(g)) {
+ 		err = PTR_ERR(g);
+ 		esw_warn(dev, "Failed to create restore flow group, err: %d\n",
+ 			 err);
+ 		goto err_group;
+ 	}
+ 
+ 	MLX5_SET(copy_action_in, modact, action_type, MLX5_ACTION_TYPE_COPY);
+ 	MLX5_SET(copy_action_in, modact, src_field,
+ 		 MLX5_ACTION_IN_FIELD_METADATA_REG_C_1);
+ 	MLX5_SET(copy_action_in, modact, dst_field,
+ 		 MLX5_ACTION_IN_FIELD_METADATA_REG_B);
+ 	mod_hdr = mlx5_modify_header_alloc(esw->dev,
+ 					   MLX5_FLOW_NAMESPACE_KERNEL, 1,
+ 					   modact);
+ 	if (IS_ERR(mod_hdr)) {
+ 		esw_warn(dev, "Failed to create restore mod header, err: %d\n",
+ 			 err);
+ 		err = PTR_ERR(mod_hdr);
+ 		goto err_mod_hdr;
+ 	}
+ 
+ 	esw->offloads.ft_offloads_restore = ft;
+ 	esw->offloads.restore_group = g;
+ 	esw->offloads.restore_copy_hdr_id = mod_hdr;
+ 
+ 	kvfree(flow_group_in);
+ 
+ 	return 0;
+ 
+ err_mod_hdr:
+ 	mlx5_destroy_flow_group(g);
+ err_group:
+ 	mlx5_destroy_flow_table(ft);
+ out_free:
+ 	kvfree(flow_group_in);
+ 
+ 	return err;
+ }
+ 
++>>>>>>> d65dbedfd298 (net/mlx5: Add support for COPY steering action)
  static int esw_offloads_start(struct mlx5_eswitch *esw,
  			      struct netlink_ext_ack *extack)
  {
@@@ -1818,8 -1900,7 +1963,12 @@@ out_no_mem
  static int esw_vport_add_ingress_acl_modify_metadata(struct mlx5_eswitch *esw,
  						     struct mlx5_vport *vport)
  {
++<<<<<<< HEAD
 +	u8 action[MLX5_UN_SZ_BYTES(set_action_in_add_action_in_auto)] = {};
 +	static const struct mlx5_flow_spec spec = {};
++=======
+ 	u8 action[MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto)] = {};
++>>>>>>> d65dbedfd298 (net/mlx5: Add support for COPY steering action)
  	struct mlx5_flow_act flow_act = {};
  	int err = 0;
  	u32 key;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/chains.c
diff --git a/drivers/infiniband/hw/mlx5/flow.c b/drivers/infiniband/hw/mlx5/flow.c
index b198ff10cde9..7fae97c3a611 100644
--- a/drivers/infiniband/hw/mlx5/flow.c
+++ b/drivers/infiniband/hw/mlx5/flow.c
@@ -403,7 +403,7 @@ static int UVERBS_HANDLER(MLX5_IB_METHOD_FLOW_ACTION_CREATE_MODIFY_HEADER)(
 
 	num_actions = uverbs_attr_ptr_get_array_size(
 		attrs, MLX5_IB_ATTR_CREATE_MODIFY_HEADER_ACTIONS_PRM,
-		MLX5_UN_SZ_BYTES(set_action_in_add_action_in_auto));
+		MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto));
 	if (num_actions < 0)
 		return num_actions;
 
@@ -620,7 +620,7 @@ DECLARE_UVERBS_NAMED_METHOD(
 			UA_MANDATORY),
 	UVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_CREATE_MODIFY_HEADER_ACTIONS_PRM,
 			   UVERBS_ATTR_MIN_SIZE(MLX5_UN_SZ_BYTES(
-				   set_action_in_add_action_in_auto)),
+				   set_add_copy_action_in_auto)),
 			   UA_MANDATORY,
 			   UA_ALLOC_AND_COPY),
 	UVERBS_ATTR_CONST_IN(MLX5_IB_ATTR_CREATE_MODIFY_HEADER_FT_TYPE,
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en/tc_ct.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/esw/chains.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
index ace989dccecb..f31a4541257a 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_cmd.c
@@ -806,7 +806,7 @@ static int mlx5_cmd_modify_header_alloc(struct mlx5_flow_root_namespace *ns,
 		return -EOPNOTSUPP;
 	}
 
-	actions_size = MLX5_UN_SZ_BYTES(set_action_in_add_action_in_auto) * num_actions;
+	actions_size = MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto) * num_actions;
 	inlen = MLX5_ST_SZ_BYTES(alloc_modify_header_context_in) + actions_size;
 
 	in = kzalloc(inlen, GFP_KERNEL);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/steering/fs_dr.c b/drivers/net/ethernet/mellanox/mlx5/core/steering/fs_dr.c
index d12d3a2d46ab..9bcabe329dcf 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/steering/fs_dr.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/steering/fs_dr.c
@@ -564,7 +564,7 @@ static int mlx5_cmd_dr_modify_header_alloc(struct mlx5_flow_root_namespace *ns,
 	struct mlx5dr_action *action;
 	size_t actions_sz;
 
-	actions_sz = MLX5_UN_SZ_BYTES(set_action_in_add_action_in_auto) *
+	actions_sz = MLX5_UN_SZ_BYTES(set_add_copy_action_in_auto) *
 		num_actions;
 	action = mlx5dr_action_create_modify_header(dr_domain, 0,
 						    actions_sz,
diff --git a/include/linux/mlx5/mlx5_ifc.h b/include/linux/mlx5/mlx5_ifc.h
index c5fe218be7e9..5da4fbb9e978 100644
--- a/include/linux/mlx5/mlx5_ifc.h
+++ b/include/linux/mlx5/mlx5_ifc.h
@@ -5664,9 +5664,9 @@ struct mlx5_ifc_copy_action_in_bits {
 	u8         reserved_at_38[0x8];
 };
 
-union mlx5_ifc_set_action_in_add_action_in_auto_bits {
-	struct mlx5_ifc_set_action_in_bits set_action_in;
-	struct mlx5_ifc_add_action_in_bits add_action_in;
+union mlx5_ifc_set_add_copy_action_in_auto_bits {
+	struct mlx5_ifc_set_action_in_bits  set_action_in;
+	struct mlx5_ifc_add_action_in_bits  add_action_in;
 	struct mlx5_ifc_copy_action_in_bits copy_action_in;
 	u8         reserved_at_0[0x40];
 };
@@ -5740,7 +5740,7 @@ struct mlx5_ifc_alloc_modify_header_context_in_bits {
 	u8         reserved_at_68[0x10];
 	u8         num_of_actions[0x8];
 
-	union mlx5_ifc_set_action_in_add_action_in_auto_bits actions[0];
+	union mlx5_ifc_set_add_copy_action_in_auto_bits actions[0];
 };
 
 struct mlx5_ifc_dealloc_modify_header_context_out_bits {
