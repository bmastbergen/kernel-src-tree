io_uring: retry raw bdev writes if we hit -EOPNOTSUPP

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit faac996ccd5da95bc56b91aa80f2643c2d0a1c56
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/faac996c.failed

For non-blocking issue, we set IOCB_NOWAIT in the kiocb. However, on a
raw block device, this yields an -EOPNOTSUPP return, as non-blocking
writes aren't supported. Turn this -EOPNOTSUPP into -EAGAIN, so we retry
from blocking context with IOCB_NOWAIT cleared.

	Cc: stable@vger.kernel.org # 5.5
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit faac996ccd5da95bc56b91aa80f2643c2d0a1c56)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index ffb8e9d82a6a,1a3ca6577a10..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -1444,20 -2336,25 +1444,30 @@@ static int io_write(struct io_kiocb *re
  		}
  		kiocb->ki_flags |= IOCB_WRITE;
  
 -		if (req->file->f_op->write_iter)
 -			ret2 = call_write_iter(req->file, kiocb, &iter);
 +		if (file->f_op->write_iter)
 +			ret2 = call_write_iter(file, kiocb, &iter);
  		else
++<<<<<<< HEAD
 +			ret2 = loop_rw_iter(WRITE, file, kiocb, &iter);
++=======
+ 			ret2 = loop_rw_iter(WRITE, req->file, kiocb, &iter);
+ 		/*
+ 		 * Raw bdev writes will -EOPNOTSUPP for IOCB_NOWAIT. Just
+ 		 * retry them without IOCB_NOWAIT.
+ 		 */
+ 		if (ret2 == -EOPNOTSUPP && (kiocb->ki_flags & IOCB_NOWAIT))
+ 			ret2 = -EAGAIN;
++>>>>>>> faac996ccd5d (io_uring: retry raw bdev writes if we hit -EOPNOTSUPP)
  		if (!force_nonblock || ret2 != -EAGAIN) {
 -			kiocb_done(kiocb, ret2, nxt, req->in_async);
 +			io_rw_done(kiocb, ret2);
  		} else {
 -copy_iov:
 -			ret = io_setup_async_rw(req, io_size, iovec,
 -						inline_vecs, &iter);
 -			if (ret)
 -				goto out_free;
 -			return -EAGAIN;
 +			/*
 +			 * If ->needs_lock is true, we're already in async
 +			 * context.
 +			 */
 +			if (!s->needs_lock)
 +				io_async_list_note(WRITE, req, iov_count);
 +			ret = -EAGAIN;
  		}
  	}
  out_free:
* Unmerged path fs/io_uring.c
