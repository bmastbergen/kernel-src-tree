kvm: x86: Move IA32_XSS to kvm_{get,set}_msr_common

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [x86] kvm: x86: Move IA32_XSS to kvm_{get, set}_msr_common (Vitaly Kuznetsov) [1813987]
Rebuild_FUZZ: 99.03%
commit-author Aaron Lewis <aaronlewis@google.com>
commit 864e2ab2b46db1ac266c46a7c9cefe6cc893029d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/864e2ab2.failed

Hoist support for RDMSR/WRMSR of IA32_XSS from vmx into common code so
that it can be used for svm as well.

Right now, kvm only allows the guest IA32_XSS to be zero,
so the guest's usage of XSAVES will be exactly the same as XSAVEC.

	Reviewed-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Aaron Lewis <aaronlewis@google.com>
Change-Id: Ie4b0f777d71e428fbee6e82071ac2d7618e9bb40
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 864e2ab2b46db1ac266c46a7c9cefe6cc893029d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index 5de81d2ea4ca,31ce6bc2c371..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -1847,26 -1825,8 +1847,31 @@@ static int vmx_get_msr(struct kvm_vcpu 
  	case MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:
  		if (!nested_vmx_allowed(vcpu))
  			return 1;
++<<<<<<< HEAD
 +		if (vmx_get_vmx_msr(&vmx->nested.msrs, msr_info->index,
 +				    &msr_info->data))
 +			return 1;
 +		/*
 +		 * Enlightened VMCS v1 doesn't have certain fields, but buggy
 +		 * Hyper-V versions are still trying to use corresponding
 +		 * features when they are exposed. Filter out the essential
 +		 * minimum.
 +		 */
 +		if (!msr_info->host_initiated &&
 +		    vmx->nested.enlightened_vmcs_enabled)
 +			nested_evmcs_filter_control_msr(msr_info->index,
 +							&msr_info->data);
 +		break;
 +	case MSR_IA32_XSS:
 +		if (!msr_info->host_initiated &&
 +		    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))
 +			return 1;
 +		msr_info->data = vcpu->arch.ia32_xss;
 +		break;
++=======
+ 		return vmx_get_vmx_msr(&vmx->nested.msrs, msr_info->index,
+ 				       &msr_info->data);
++>>>>>>> 864e2ab2b46d (kvm: x86: Move IA32_XSS to kvm_{get,set}_msr_common)
  	case MSR_IA32_RTIT_CTL:
  		if (pt_mode != PT_MODE_HOST_GUEST)
  			return 1;
* Unmerged path arch/x86/kvm/vmx/vmx.c
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 2ee5083117a3..7cf5e387bf78 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -2717,6 +2717,20 @@ int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 	case MSR_IA32_TSC:
 		kvm_write_tsc(vcpu, msr_info);
 		break;
+	case MSR_IA32_XSS:
+		if (!msr_info->host_initiated &&
+		    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))
+			return 1;
+		/*
+		 * We do support PT if kvm_x86_ops->pt_supported(), but we do
+		 * not support IA32_XSS[bit 8]. Guests will have to use
+		 * RDMSR/WRMSR rather than XSAVES/XRSTORS to save/restore PT
+		 * MSRs.
+		 */
+		if (data != 0)
+			return 1;
+		vcpu->arch.ia32_xss = data;
+		break;
 	case MSR_SMI_COUNT:
 		if (!msr_info->host_initiated)
 			return 1;
@@ -3044,6 +3058,12 @@ int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)
 	case MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:
 		return get_msr_mce(vcpu, msr_info->index, &msr_info->data,
 				   msr_info->host_initiated);
+	case MSR_IA32_XSS:
+		if (!msr_info->host_initiated &&
+		    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))
+			return 1;
+		msr_info->data = vcpu->arch.ia32_xss;
+		break;
 	case MSR_K7_CLK_CTL:
 		/*
 		 * Provide expected ramp-up count for K7. All other
