libbpf: Reduce log level for custom section names

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 4a3d6c6a6e4d652808729e7a2a8c3774a5a5c814
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/4a3d6c6a.failed

Libbpf is trying to recognize BPF program type based on its section name
during bpf_object__open() phase. This is not strictly enforced and user code
has ability to specify/override correct BPF program type after open.  But if
BPF program is using custom section name, libbpf will still emit warnings,
which can be quite annoying to users. This patch reduces log level of
information messages emitted by libbpf if section name is not canonical. User
can still get a list of all supported section names as debug-level message.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20191217234228.1739308-1-andriin@fb.com
(cherry picked from commit 4a3d6c6a6e4d652808729e7a2a8c3774a5a5c814)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
diff --cc tools/lib/bpf/libbpf.c
index a22c75b6283d,906bbbf7b2e4..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -5177,35 -5876,14 +5177,40 @@@ int libbpf_prog_type_by_name(const cha
  	if (!name)
  		return -EINVAL;
  
 -	sec_def = find_sec_def(name);
 -	if (sec_def) {
 -		*prog_type = sec_def->prog_type;
 -		*expected_attach_type = sec_def->expected_attach_type;
 +	for (i = 0; i < ARRAY_SIZE(section_names); i++) {
 +		if (strncmp(name, section_names[i].sec, section_names[i].len))
 +			continue;
 +		*prog_type = section_names[i].prog_type;
 +		*expected_attach_type = section_names[i].expected_attach_type;
 +		if (section_names[i].is_attach_btf) {
 +			struct btf *btf = bpf_core_find_kernel_btf();
 +			char raw_tp_btf_name[128] = "btf_trace_";
 +			char *dst = raw_tp_btf_name + sizeof("btf_trace_") - 1;
 +			int ret;
 +
 +			if (IS_ERR(btf)) {
 +				pr_warning("vmlinux BTF is not found\n");
 +				return -EINVAL;
 +			}
 +			/* prepend "btf_trace_" prefix per kernel convention */
 +			strncat(dst, name + section_names[i].len,
 +				sizeof(raw_tp_btf_name) - sizeof("btf_trace_"));
 +			ret = btf__find_by_name(btf, raw_tp_btf_name);
 +			btf__free(btf);
 +			if (ret <= 0) {
 +				pr_warning("%s is not found in vmlinux BTF\n", dst);
 +				return -EINVAL;
 +			}
 +			*expected_attach_type = ret;
 +		}
  		return 0;
  	}
++<<<<<<< HEAD
 +	pr_warn("failed to guess program type from ELF section '%s'\n", name);
++=======
+ 
+ 	pr_debug("failed to guess program type from ELF section '%s'\n", name);
++>>>>>>> 4a3d6c6a6e4d (libbpf: Reduce log level for custom section names)
  	type_names = libbpf_get_type_names(false);
  	if (type_names != NULL) {
  		pr_debug("supported section(type) names are:%s\n", type_names);
@@@ -5224,18 -5993,18 +5229,18 @@@ int libbpf_attach_type_by_name(const ch
  	if (!name)
  		return -EINVAL;
  
 -	for (i = 0; i < ARRAY_SIZE(section_defs); i++) {
 -		if (strncmp(name, section_defs[i].sec, section_defs[i].len))
 +	for (i = 0; i < ARRAY_SIZE(section_names); i++) {
 +		if (strncmp(name, section_names[i].sec, section_names[i].len))
  			continue;
 -		if (!section_defs[i].is_attachable)
 +		if (!section_names[i].is_attachable)
  			return -EINVAL;
 -		*attach_type = section_defs[i].attach_type;
 +		*attach_type = section_names[i].attach_type;
  		return 0;
  	}
- 	pr_warn("failed to guess attach type based on ELF section name '%s'\n", name);
+ 	pr_debug("failed to guess attach type based on ELF section name '%s'\n", name);
  	type_names = libbpf_get_type_names(true);
  	if (type_names != NULL) {
- 		pr_info("attachable section(type) names are:%s\n", type_names);
+ 		pr_debug("attachable section(type) names are:%s\n", type_names);
  		free(type_names);
  	}
  
* Unmerged path tools/lib/bpf/libbpf.c
