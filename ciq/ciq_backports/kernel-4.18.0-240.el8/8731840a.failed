Bluetooth: Restore running state if suspend fails

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
commit 8731840a345fb7ebfd0174ecc29aa21623bc2899
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8731840a.failed

If Bluetooth fails to enter the suspended state correctly, restore the
state to running (re-enabling scans). PM_POST_SUSPEND is only sent to
notifiers that successfully return from PM_PREPARE_SUSPEND notification
so we should recover gracefully if it fails.

	Signed-off-by: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 8731840a345fb7ebfd0174ecc29aa21623bc2899)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/hci_core.c
diff --cc net/bluetooth/hci_core.c
index 2d71e1f91ae8,2e7bc2da8371..000000000000
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@@ -2960,6 -3269,94 +2960,97 @@@ void hci_copy_identity_address(struct h
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int hci_suspend_wait_event(struct hci_dev *hdev)
+ {
+ #define WAKE_COND                                                              \
+ 	(find_first_bit(hdev->suspend_tasks, __SUSPEND_NUM_TASKS) ==           \
+ 	 __SUSPEND_NUM_TASKS)
+ 
+ 	int i;
+ 	int ret = wait_event_timeout(hdev->suspend_wait_q,
+ 				     WAKE_COND, SUSPEND_NOTIFIER_TIMEOUT);
+ 
+ 	if (ret == 0) {
+ 		bt_dev_dbg(hdev, "Timed out waiting for suspend");
+ 		for (i = 0; i < __SUSPEND_NUM_TASKS; ++i) {
+ 			if (test_bit(i, hdev->suspend_tasks))
+ 				bt_dev_dbg(hdev, "Bit %d is set", i);
+ 			clear_bit(i, hdev->suspend_tasks);
+ 		}
+ 
+ 		ret = -ETIMEDOUT;
+ 	} else {
+ 		ret = 0;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static void hci_prepare_suspend(struct work_struct *work)
+ {
+ 	struct hci_dev *hdev =
+ 		container_of(work, struct hci_dev, suspend_prepare);
+ 
+ 	hci_dev_lock(hdev);
+ 	hci_req_prepare_suspend(hdev, hdev->suspend_state_next);
+ 	hci_dev_unlock(hdev);
+ }
+ 
+ static int hci_change_suspend_state(struct hci_dev *hdev,
+ 				    enum suspended_state next)
+ {
+ 	hdev->suspend_state_next = next;
+ 	set_bit(SUSPEND_PREPARE_NOTIFIER, hdev->suspend_tasks);
+ 	queue_work(hdev->req_workqueue, &hdev->suspend_prepare);
+ 	return hci_suspend_wait_event(hdev);
+ }
+ 
+ static int hci_suspend_notifier(struct notifier_block *nb, unsigned long action,
+ 				void *data)
+ {
+ 	struct hci_dev *hdev =
+ 		container_of(nb, struct hci_dev, suspend_notifier);
+ 	int ret = 0;
+ 
+ 	/* If powering down, wait for completion. */
+ 	if (mgmt_powering_down(hdev)) {
+ 		set_bit(SUSPEND_POWERING_DOWN, hdev->suspend_tasks);
+ 		ret = hci_suspend_wait_event(hdev);
+ 		if (ret)
+ 			goto done;
+ 	}
+ 
+ 	/* Suspend notifier should only act on events when powered. */
+ 	if (!hdev_is_powered(hdev))
+ 		goto done;
+ 
+ 	if (action == PM_SUSPEND_PREPARE) {
+ 		/* Suspend consists of two actions:
+ 		 *  - First, disconnect everything and make the controller not
+ 		 *    connectable (disabling scanning)
+ 		 *  - Second, program event filter/whitelist and enable scan
+ 		 */
+ 		ret = hci_change_suspend_state(hdev, BT_SUSPEND_DISCONNECT);
+ 
+ 		/* Only configure whitelist if disconnect succeeded */
+ 		if (!ret)
+ 			ret = hci_change_suspend_state(hdev,
+ 						       BT_SUSPEND_COMPLETE);
+ 	} else if (action == PM_POST_SUSPEND) {
+ 		ret = hci_change_suspend_state(hdev, BT_RUNNING);
+ 	}
+ 
+ 	/* If suspend failed, restore it to running */
+ 	if (ret && action == PM_SUSPEND_PREPARE)
+ 		hci_change_suspend_state(hdev, BT_RUNNING);
+ 
+ done:
+ 	return ret ? notifier_from_errno(-EBUSY) : NOTIFY_STOP;
+ }
+ 
++>>>>>>> 8731840a345f (Bluetooth: Restore running state if suspend fails)
  /* Alloc HCI device */
  struct hci_dev *hci_alloc_dev(void)
  {
* Unmerged path net/bluetooth/hci_core.c
