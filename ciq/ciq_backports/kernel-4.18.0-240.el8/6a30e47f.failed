nfsd: Add tracepoints for update of the expkey and export cache entries

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Trond Myklebust <trondmy@gmail.com>
commit 6a30e47fa0c358cc84002e6a429f5f229e0b7b07
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6a30e47f.failed

	Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
(cherry picked from commit 6a30e47fa0c358cc84002e6a429f5f229e0b7b07)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfsd/trace.h
diff --cc fs/nfsd/trace.h
index 8dd372f9b54a,78c574251c60..000000000000
--- a/fs/nfsd/trace.h
+++ b/fs/nfsd/trace.h
@@@ -80,6 -81,97 +80,100 @@@ DEFINE_EVENT(nfsd_fh_err_class, nfsd_##
  DEFINE_NFSD_FH_ERR_EVENT(set_fh_dentry_badexport);
  DEFINE_NFSD_FH_ERR_EVENT(set_fh_dentry_badhandle);
  
++<<<<<<< HEAD
++=======
+ TRACE_EVENT(nfsd_exp_find_key,
+ 	TP_PROTO(const struct svc_expkey *key,
+ 		 int status),
+ 	TP_ARGS(key, status),
+ 	TP_STRUCT__entry(
+ 		__field(int, fsidtype)
+ 		__array(u32, fsid, 6)
+ 		__string(auth_domain, key->ek_client->name)
+ 		__field(int, status)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->fsidtype = key->ek_fsidtype;
+ 		memcpy(__entry->fsid, key->ek_fsid, 4*6);
+ 		__assign_str(auth_domain, key->ek_client->name);
+ 		__entry->status = status;
+ 	),
+ 	TP_printk("fsid=%x::%s domain=%s status=%d",
+ 		__entry->fsidtype,
+ 		__print_array(__entry->fsid, 6, 4),
+ 		__get_str(auth_domain),
+ 		__entry->status
+ 	)
+ );
+ 
+ TRACE_EVENT(nfsd_expkey_update,
+ 	TP_PROTO(const struct svc_expkey *key, const char *exp_path),
+ 	TP_ARGS(key, exp_path),
+ 	TP_STRUCT__entry(
+ 		__field(int, fsidtype)
+ 		__array(u32, fsid, 6)
+ 		__string(auth_domain, key->ek_client->name)
+ 		__string(path, exp_path)
+ 		__field(bool, cache)
+ 	),
+ 	TP_fast_assign(
+ 		__entry->fsidtype = key->ek_fsidtype;
+ 		memcpy(__entry->fsid, key->ek_fsid, 4*6);
+ 		__assign_str(auth_domain, key->ek_client->name);
+ 		__assign_str(path, exp_path);
+ 		__entry->cache = !test_bit(CACHE_NEGATIVE, &key->h.flags);
+ 	),
+ 	TP_printk("fsid=%x::%s domain=%s path=%s cache=%s",
+ 		__entry->fsidtype,
+ 		__print_array(__entry->fsid, 6, 4),
+ 		__get_str(auth_domain),
+ 		__get_str(path),
+ 		__entry->cache ? "pos" : "neg"
+ 	)
+ );
+ 
+ TRACE_EVENT(nfsd_exp_get_by_name,
+ 	TP_PROTO(const struct svc_export *key,
+ 		 int status),
+ 	TP_ARGS(key, status),
+ 	TP_STRUCT__entry(
+ 		__string(path, key->ex_path.dentry->d_name.name)
+ 		__string(auth_domain, key->ex_client->name)
+ 		__field(int, status)
+ 	),
+ 	TP_fast_assign(
+ 		__assign_str(path, key->ex_path.dentry->d_name.name);
+ 		__assign_str(auth_domain, key->ex_client->name);
+ 		__entry->status = status;
+ 	),
+ 	TP_printk("path=%s domain=%s status=%d",
+ 		__get_str(path),
+ 		__get_str(auth_domain),
+ 		__entry->status
+ 	)
+ );
+ 
+ TRACE_EVENT(nfsd_export_update,
+ 	TP_PROTO(const struct svc_export *key),
+ 	TP_ARGS(key),
+ 	TP_STRUCT__entry(
+ 		__string(path, key->ex_path.dentry->d_name.name)
+ 		__string(auth_domain, key->ex_client->name)
+ 		__field(bool, cache)
+ 	),
+ 	TP_fast_assign(
+ 		__assign_str(path, key->ex_path.dentry->d_name.name);
+ 		__assign_str(auth_domain, key->ex_client->name);
+ 		__entry->cache = !test_bit(CACHE_NEGATIVE, &key->h.flags);
+ 	),
+ 	TP_printk("path=%s domain=%s cache=%s",
+ 		__get_str(path),
+ 		__get_str(auth_domain),
+ 		__entry->cache ? "pos" : "neg"
+ 	)
+ );
+ 
++>>>>>>> 6a30e47fa0c3 (nfsd: Add tracepoints for update of the expkey and export cache entries)
  DECLARE_EVENT_CLASS(nfsd_io_class,
  	TP_PROTO(struct svc_rqst *rqstp,
  		 struct svc_fh	*fhp,
diff --git a/fs/nfsd/export.c b/fs/nfsd/export.c
index baa01956a5b3..a12b1eafadb0 100644
--- a/fs/nfsd/export.c
+++ b/fs/nfsd/export.c
@@ -139,7 +139,9 @@ static int expkey_parse(struct cache_detail *cd, char *mesg, int mlen)
 	if (len == 0) {
 		set_bit(CACHE_NEGATIVE, &key.h.flags);
 		ek = svc_expkey_update(cd, &key, ek);
-		if (!ek)
+		if (ek)
+			trace_nfsd_expkey_update(ek, NULL);
+		else
 			err = -ENOMEM;
 	} else {
 		err = kern_path(buf, 0, &key.ek_path);
@@ -149,7 +151,9 @@ static int expkey_parse(struct cache_detail *cd, char *mesg, int mlen)
 		dprintk("Found the path %s\n", buf);
 
 		ek = svc_expkey_update(cd, &key, ek);
-		if (!ek)
+		if (ek)
+			trace_nfsd_expkey_update(ek, buf);
+		else
 			err = -ENOMEM;
 		path_put(&key.ek_path);
 	}
@@ -630,15 +634,17 @@ static int svc_export_parse(struct cache_detail *cd, char *mesg, int mlen)
 	}
 
 	expp = svc_export_lookup(&exp);
-	if (expp)
-		expp = svc_export_update(&exp, expp);
-	else
-		err = -ENOMEM;
-	cache_flush();
-	if (expp == NULL)
+	if (!expp) {
 		err = -ENOMEM;
-	else
+		goto out4;
+	}
+	expp = svc_export_update(&exp, expp);
+	if (expp) {
+		trace_nfsd_export_update(expp);
+		cache_flush();
 		exp_put(expp);
+	} else
+		err = -ENOMEM;
 out4:
 	nfsd4_fslocs_free(&exp.ex_fslocs);
 	kfree(exp.ex_uuid);
* Unmerged path fs/nfsd/trace.h
