perf auxtrace: Add auxtrace_record__read_finish()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit ad60ba0c2e6da6ff573c5ac57708fbc443bbb473
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ad60ba0c.failed

All ->read_finish() implementations are doing the same thing. Add a
helper function so that they can share the same implementation.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Reviewed-by: Leo Yan <leo.yan@linaro.org>
	Tested-by: Leo Yan <leo.yan@linaro.org>
	Reviewed-by: Mathieu Poirier <mathieu.poirier@linaro.org>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Kim Phillips <kim.phillips@arm.com>
	Cc: Wei Li <liwei391@huawei.com>
Link: http://lore.kernel.org/lkml/20200217082300.6301-1-adrian.hunter@intel.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit ad60ba0c2e6da6ff573c5ac57708fbc443bbb473)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/arch/arm/util/cs-etm.c
#	tools/perf/arch/arm64/util/arm-spe.c
#	tools/perf/arch/x86/util/intel-bts.c
#	tools/perf/arch/x86/util/intel-pt.c
#	tools/perf/util/auxtrace.c
#	tools/perf/util/auxtrace.h
diff --cc tools/perf/arch/arm/util/cs-etm.c
index 4208974c24f8,941f814820b8..000000000000
--- a/tools/perf/arch/arm/util/cs-etm.c
+++ b/tools/perf/arch/arm/util/cs-etm.c
@@@ -854,21 -858,6 +854,24 @@@ static void cs_etm_recording_free(struc
  	free(ptr);
  }
  
++<<<<<<< HEAD
 +static int cs_etm_read_finish(struct auxtrace_record *itr, int idx)
 +{
 +	struct cs_etm_recording *ptr =
 +			container_of(itr, struct cs_etm_recording, itr);
 +	struct perf_evsel *evsel;
 +
 +	evlist__for_each_entry(ptr->evlist, evsel) {
 +		if (evsel->attr.type == ptr->cs_etm_pmu->type)
 +			return perf_evlist__enable_event_idx(ptr->evlist,
 +							     evsel, idx);
 +	}
 +
 +	return -EINVAL;
 +}
 +
++=======
++>>>>>>> ad60ba0c2e6d (perf auxtrace: Add auxtrace_record__read_finish())
  struct auxtrace_record *cs_etm_record_init(int *err)
  {
  	struct perf_pmu *cs_etm_pmu;
diff --cc tools/perf/arch/arm64/util/arm-spe.c
index 2c009aa74633,8d6821d9c3f6..000000000000
--- a/tools/perf/arch/arm64/util/arm-spe.c
+++ b/tools/perf/arch/arm64/util/arm-spe.c
@@@ -156,20 -158,6 +156,23 @@@ static void arm_spe_recording_free(stru
  	free(sper);
  }
  
++<<<<<<< HEAD
 +static int arm_spe_read_finish(struct auxtrace_record *itr, int idx)
 +{
 +	struct arm_spe_recording *sper =
 +			container_of(itr, struct arm_spe_recording, itr);
 +	struct perf_evsel *evsel;
 +
 +	evlist__for_each_entry(sper->evlist, evsel) {
 +		if (evsel->attr.type == sper->arm_spe_pmu->type)
 +			return perf_evlist__enable_event_idx(sper->evlist,
 +							     evsel, idx);
 +	}
 +	return -EINVAL;
 +}
 +
++=======
++>>>>>>> ad60ba0c2e6d (perf auxtrace: Add auxtrace_record__read_finish())
  struct auxtrace_record *arm_spe_recording_init(int *err,
  					       struct perf_pmu *arm_spe_pmu)
  {
diff --cc tools/perf/arch/x86/util/intel-bts.c
index 7aa8dcee0a73,26cee1052179..000000000000
--- a/tools/perf/arch/x86/util/intel-bts.c
+++ b/tools/perf/arch/x86/util/intel-bts.c
@@@ -418,20 -413,6 +418,23 @@@ out_err
  	return err;
  }
  
++<<<<<<< HEAD
 +static int intel_bts_read_finish(struct auxtrace_record *itr, int idx)
 +{
 +	struct intel_bts_recording *btsr =
 +			container_of(itr, struct intel_bts_recording, itr);
 +	struct perf_evsel *evsel;
 +
 +	evlist__for_each_entry(btsr->evlist, evsel) {
 +		if (evsel->attr.type == btsr->intel_bts_pmu->type)
 +			return perf_evlist__enable_event_idx(btsr->evlist,
 +							     evsel, idx);
 +	}
 +	return -EINVAL;
 +}
 +
++=======
++>>>>>>> ad60ba0c2e6d (perf auxtrace: Add auxtrace_record__read_finish())
  struct auxtrace_record *intel_bts_recording_init(int *err)
  {
  	struct perf_pmu *intel_bts_pmu = perf_pmu__find(INTEL_BTS_PMU_NAME);
diff --cc tools/perf/arch/x86/util/intel-pt.c
index 3a851647e6f4,7eea4fd7ce58..000000000000
--- a/tools/perf/arch/x86/util/intel-pt.c
+++ b/tools/perf/arch/x86/util/intel-pt.c
@@@ -1075,20 -1166,6 +1075,23 @@@ static u64 intel_pt_reference(struct au
  	return rdtsc();
  }
  
++<<<<<<< HEAD
 +static int intel_pt_read_finish(struct auxtrace_record *itr, int idx)
 +{
 +	struct intel_pt_recording *ptr =
 +			container_of(itr, struct intel_pt_recording, itr);
 +	struct perf_evsel *evsel;
 +
 +	evlist__for_each_entry(ptr->evlist, evsel) {
 +		if (evsel->attr.type == ptr->intel_pt_pmu->type)
 +			return perf_evlist__enable_event_idx(ptr->evlist, evsel,
 +							     idx);
 +	}
 +	return -EINVAL;
 +}
 +
++=======
++>>>>>>> ad60ba0c2e6d (perf auxtrace: Add auxtrace_record__read_finish())
  struct auxtrace_record *intel_pt_recording_init(int *err)
  {
  	struct perf_pmu *intel_pt_pmu = perf_pmu__find(INTEL_PT_PMU_NAME);
@@@ -1118,6 -1196,11 +1122,15 @@@
  	ptr->itr.find_snapshot = intel_pt_find_snapshot;
  	ptr->itr.parse_snapshot_options = intel_pt_parse_snapshot_options;
  	ptr->itr.reference = intel_pt_reference;
++<<<<<<< HEAD
 +	ptr->itr.read_finish = intel_pt_read_finish;
++=======
+ 	ptr->itr.read_finish = auxtrace_record__read_finish;
+ 	/*
+ 	 * Decoding starts at a PSB packet. Minimum PSB period is 2K so 4K
+ 	 * should give at least 1 PSB per sample.
+ 	 */
+ 	ptr->itr.default_aux_sample_size = 4096;
++>>>>>>> ad60ba0c2e6d (perf auxtrace: Add auxtrace_record__read_finish())
  	return &ptr->itr;
  }
diff --cc tools/perf/util/auxtrace.c
index 130597309e55,3571ce72ca28..000000000000
--- a/tools/perf/util/auxtrace.c
+++ b/tools/perf/util/auxtrace.c
@@@ -565,11 -626,13 +565,13 @@@ int auxtrace_record__find_snapshot(stru
  }
  
  int auxtrace_record__options(struct auxtrace_record *itr,
 -			     struct evlist *evlist,
 +			     struct perf_evlist *evlist,
  			     struct record_opts *opts)
  {
- 	if (itr)
+ 	if (itr) {
+ 		itr->evlist = evlist;
  		return itr->recording_options(itr, evlist, opts);
+ 	}
  	return 0;
  }
  
@@@ -603,8 -666,152 +605,155 @@@ int auxtrace_parse_snapshot_options(str
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
++=======
+ int auxtrace_record__read_finish(struct auxtrace_record *itr, int idx)
+ {
+ 	struct evsel *evsel;
+ 
+ 	if (!itr->evlist || !itr->pmu)
+ 		return -EINVAL;
+ 
+ 	evlist__for_each_entry(itr->evlist, evsel) {
+ 		if (evsel->core.attr.type == itr->pmu->type) {
+ 			if (evsel->disabled)
+ 				return 0;
+ 			return perf_evlist__enable_event_idx(itr->evlist, evsel,
+ 							     idx);
+ 		}
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ /*
+  * Event record size is 16-bit which results in a maximum size of about 64KiB.
+  * Allow about 4KiB for the rest of the sample record, to give a maximum
+  * AUX area sample size of 60KiB.
+  */
+ #define MAX_AUX_SAMPLE_SIZE (60 * 1024)
+ 
+ /* Arbitrary default size if no other default provided */
+ #define DEFAULT_AUX_SAMPLE_SIZE (4 * 1024)
+ 
+ static int auxtrace_validate_aux_sample_size(struct evlist *evlist,
+ 					     struct record_opts *opts)
+ {
+ 	struct evsel *evsel;
+ 	bool has_aux_leader = false;
+ 	u32 sz;
+ 
+ 	evlist__for_each_entry(evlist, evsel) {
+ 		sz = evsel->core.attr.aux_sample_size;
+ 		if (perf_evsel__is_group_leader(evsel)) {
+ 			has_aux_leader = perf_evsel__is_aux_event(evsel);
+ 			if (sz) {
+ 				if (has_aux_leader)
+ 					pr_err("Cannot add AUX area sampling to an AUX area event\n");
+ 				else
+ 					pr_err("Cannot add AUX area sampling to a group leader\n");
+ 				return -EINVAL;
+ 			}
+ 		}
+ 		if (sz > MAX_AUX_SAMPLE_SIZE) {
+ 			pr_err("AUX area sample size %u too big, max. %d\n",
+ 			       sz, MAX_AUX_SAMPLE_SIZE);
+ 			return -EINVAL;
+ 		}
+ 		if (sz) {
+ 			if (!has_aux_leader) {
+ 				pr_err("Cannot add AUX area sampling because group leader is not an AUX area event\n");
+ 				return -EINVAL;
+ 			}
+ 			perf_evsel__set_sample_bit(evsel, AUX);
+ 			opts->auxtrace_sample_mode = true;
+ 		} else {
+ 			perf_evsel__reset_sample_bit(evsel, AUX);
+ 		}
+ 	}
+ 
+ 	if (!opts->auxtrace_sample_mode) {
+ 		pr_err("AUX area sampling requires an AUX area event group leader plus other events to which to add samples\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!perf_can_aux_sample()) {
+ 		pr_err("AUX area sampling is not supported by kernel\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int auxtrace_parse_sample_options(struct auxtrace_record *itr,
+ 				  struct evlist *evlist,
+ 				  struct record_opts *opts, const char *str)
+ {
+ 	struct perf_evsel_config_term *term;
+ 	struct evsel *aux_evsel;
+ 	bool has_aux_sample_size = false;
+ 	bool has_aux_leader = false;
+ 	struct evsel *evsel;
+ 	char *endptr;
+ 	unsigned long sz;
+ 
+ 	if (!str)
+ 		goto no_opt;
+ 
+ 	if (!itr) {
+ 		pr_err("No AUX area event to sample\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	sz = strtoul(str, &endptr, 0);
+ 	if (*endptr || sz > UINT_MAX) {
+ 		pr_err("Bad AUX area sampling option: '%s'\n", str);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!sz)
+ 		sz = itr->default_aux_sample_size;
+ 
+ 	if (!sz)
+ 		sz = DEFAULT_AUX_SAMPLE_SIZE;
+ 
+ 	/* Set aux_sample_size based on --aux-sample option */
+ 	evlist__for_each_entry(evlist, evsel) {
+ 		if (perf_evsel__is_group_leader(evsel)) {
+ 			has_aux_leader = perf_evsel__is_aux_event(evsel);
+ 		} else if (has_aux_leader) {
+ 			evsel->core.attr.aux_sample_size = sz;
+ 		}
+ 	}
+ no_opt:
+ 	aux_evsel = NULL;
+ 	/* Override with aux_sample_size from config term */
+ 	evlist__for_each_entry(evlist, evsel) {
+ 		if (perf_evsel__is_aux_event(evsel))
+ 			aux_evsel = evsel;
+ 		term = perf_evsel__get_config_term(evsel, AUX_SAMPLE_SIZE);
+ 		if (term) {
+ 			has_aux_sample_size = true;
+ 			evsel->core.attr.aux_sample_size = term->val.aux_sample_size;
+ 			/* If possible, group with the AUX event */
+ 			if (aux_evsel && evsel->core.attr.aux_sample_size)
+ 				perf_evlist__regroup(evlist, aux_evsel, evsel);
+ 		}
+ 	}
+ 
+ 	if (!str && !has_aux_sample_size)
+ 		return 0;
+ 
+ 	if (!itr) {
+ 		pr_err("No AUX area event to sample\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return auxtrace_validate_aux_sample_size(evlist, opts);
+ }
+ 
++>>>>>>> ad60ba0c2e6d (perf auxtrace: Add auxtrace_record__read_finish())
  struct auxtrace_record *__weak
 -auxtrace_record__init(struct evlist *evlist __maybe_unused, int *err)
 +auxtrace_record__init(struct perf_evlist *evlist __maybe_unused, int *err)
  {
  	*err = 0;
  	return NULL;
diff --cc tools/perf/util/auxtrace.h
index f02a86ad68b3,e58ef160b599..000000000000
--- a/tools/perf/util/auxtrace.h
+++ b/tools/perf/util/auxtrace.h
@@@ -38,9 -26,16 +38,10 @@@ struct perf_mmap
  struct perf_sample;
  struct option;
  struct record_opts;
 -struct perf_record_auxtrace_error;
 -struct perf_record_auxtrace_info;
 +struct auxtrace_info_event;
  struct events_stats;
+ struct perf_pmu;
  
 -enum auxtrace_error_type {
 -       PERF_AUXTRACE_ERROR_ITRACE  = 1,
 -       PERF_AUXTRACE_ERROR_MAX
 -};
 -
  /* Auxtrace records must have the same alignment as perf event records */
  #define PERF_AUXTRACE_RECORD_ALIGNMENT 8
  
@@@ -319,6 -322,9 +320,12 @@@ struct auxtrace_mmap_params 
   * @reference: provide a 64-bit reference number for auxtrace_event
   * @read_finish: called after reading from an auxtrace mmap
   * @alignment: alignment (if any) for AUX area data
++<<<<<<< HEAD
++=======
+  * @default_aux_sample_size: default sample size for --aux sample option
+  * @pmu: associated pmu
+  * @evlist: selected events list
++>>>>>>> ad60ba0c2e6d (perf auxtrace: Add auxtrace_record__read_finish())
   */
  struct auxtrace_record {
  	int (*recording_options)(struct auxtrace_record *itr,
@@@ -342,6 -348,9 +349,12 @@@
  	u64 (*reference)(struct auxtrace_record *itr);
  	int (*read_finish)(struct auxtrace_record *itr, int idx);
  	unsigned int alignment;
++<<<<<<< HEAD
++=======
+ 	unsigned int default_aux_sample_size;
+ 	struct perf_pmu *pmu;
+ 	struct evlist *evlist;
++>>>>>>> ad60ba0c2e6d (perf auxtrace: Add auxtrace_record__read_finish())
  };
  
  /**
* Unmerged path tools/perf/arch/arm/util/cs-etm.c
* Unmerged path tools/perf/arch/arm64/util/arm-spe.c
* Unmerged path tools/perf/arch/x86/util/intel-bts.c
* Unmerged path tools/perf/arch/x86/util/intel-pt.c
* Unmerged path tools/perf/util/auxtrace.c
* Unmerged path tools/perf/util/auxtrace.h
