KVM: x86: track manually whether an event has been injected

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit c6b22f59d694d0caf61aefb262d9639b3d9661d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c6b22f59.failed

Instead of calling kvm_event_needs_reinjection, track its
future return value in a variable.  This will be useful in
the next patch.

	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c6b22f59d694d0caf61aefb262d9639b3d9661d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index c6d2c69f3cd9,77b9b4e66673..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -7622,8 -7721,10 +7623,15 @@@ static int inject_pending_event(struct 
  
  	/* try to reinject previous events if any */
  
++<<<<<<< HEAD
 +	if (vcpu->arch.exception.injected)
 +		kvm_x86_ops->queue_exception(vcpu);
++=======
+ 	if (vcpu->arch.exception.injected) {
+ 		kvm_x86_ops.queue_exception(vcpu);
+ 		can_inject = false;
+ 	}
++>>>>>>> c6b22f59d694 (KVM: x86: track manually whether an event has been injected)
  	/*
  	 * Do not inject an NMI or interrupt if there is a pending
  	 * exception.  Exceptions and interrupts are recognized at
@@@ -7639,10 -7740,13 +7647,20 @@@
  	 * fully complete the previous instruction.
  	 */
  	else if (!vcpu->arch.exception.pending) {
++<<<<<<< HEAD
 +		if (vcpu->arch.nmi_injected)
 +			kvm_x86_ops->set_nmi(vcpu);
 +		else if (vcpu->arch.interrupt.injected)
 +			kvm_x86_ops->set_irq(vcpu);
++=======
+ 		if (vcpu->arch.nmi_injected) {
+ 			kvm_x86_ops.set_nmi(vcpu);
+ 			can_inject = false;
+ 		} else if (vcpu->arch.interrupt.injected) {
+ 			kvm_x86_ops.set_irq(vcpu);
+ 			can_inject = false;
+ 		}
++>>>>>>> c6b22f59d694 (KVM: x86: track manually whether an event has been injected)
  	}
  
  	WARN_ON_ONCE(vcpu->arch.exception.injected &&
@@@ -7691,15 -7795,16 +7709,20 @@@
  			}
  		}
  
++<<<<<<< HEAD
 +		kvm_x86_ops->queue_exception(vcpu);
++=======
+ 		kvm_x86_ops.queue_exception(vcpu);
+ 		can_inject = false;
++>>>>>>> c6b22f59d694 (KVM: x86: track manually whether an event has been injected)
  	}
  
- 	/* Don't consider new event if we re-injected an event */
- 	if (kvm_event_needs_reinjection(vcpu))
+ 	/* Finish re-injection before considering new events */
+ 	if (!can_inject)
  		return 0;
  
 -	if (vcpu->arch.smi_pending &&
 -	    kvm_x86_ops.smi_allowed(vcpu, true)) {
 +	if (vcpu->arch.smi_pending && !is_smm(vcpu) &&
 +	    kvm_x86_ops->smi_allowed(vcpu)) {
  		vcpu->arch.smi_pending = false;
  		++vcpu->arch.smi_count;
  		enter_smm(vcpu);
* Unmerged path arch/x86/kvm/x86.c
