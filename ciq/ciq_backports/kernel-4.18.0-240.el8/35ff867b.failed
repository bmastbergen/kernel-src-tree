PCI/IOV: Serialize sysfs sriov_numvfs reads vs writes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pierre Crégut <pierre.cregut@orange.com>
commit 35ff867b76576e32f34c698ccd11343f7d616204
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/35ff867b.failed

When sriov_numvfs is being updated, we call the driver->sriov_configure()
function, which may enable VFs and call probe functions, which may make new
devices visible.  This all happens before before sriov_numvfs_store()
updates sriov->num_VFs, so previously, concurrent sysfs reads of
sriov_numvfs returned stale values.

Serialize the sysfs read vs the write so the read returns the correct
num_VFs value.

[bhelgaas: hold device_lock instead of checking mutex_is_locked()]
Link: https://bugzilla.kernel.org/show_bug.cgi?id=202991
Link: https://lore.kernel.org/r/20190911072736.32091-1-pierre.cregut@orange.com
	Signed-off-by: Pierre Crégut <pierre.cregut@orange.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 35ff867b76576e32f34c698ccd11343f7d616204)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/iov.c
diff --cc drivers/pci/iov.c
index 9b48818ced01,1d3de1ea081d..000000000000
--- a/drivers/pci/iov.c
+++ b/drivers/pci/iov.c
@@@ -240,6 -240,179 +240,182 @@@ void pci_iov_remove_virtfn(struct pci_d
  	pci_dev_put(dev);
  }
  
++<<<<<<< HEAD
++=======
+ static ssize_t sriov_totalvfs_show(struct device *dev,
+ 				   struct device_attribute *attr,
+ 				   char *buf)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 
+ 	return sprintf(buf, "%u\n", pci_sriov_get_totalvfs(pdev));
+ }
+ 
+ static ssize_t sriov_numvfs_show(struct device *dev,
+ 				 struct device_attribute *attr,
+ 				 char *buf)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 	u16 num_vfs;
+ 
+ 	/* Serialize vs sriov_numvfs_store() so readers see valid num_VFs */
+ 	device_lock(&pdev->dev);
+ 	num_vfs = pdev->sriov->num_VFs;
+ 	device_unlock(&pdev->dev);
+ 
+ 	return sprintf(buf, "%u\n", num_vfs);
+ }
+ 
+ /*
+  * num_vfs > 0; number of VFs to enable
+  * num_vfs = 0; disable all VFs
+  *
+  * Note: SRIOV spec does not allow partial VF
+  *	 disable, so it's all or none.
+  */
+ static ssize_t sriov_numvfs_store(struct device *dev,
+ 				  struct device_attribute *attr,
+ 				  const char *buf, size_t count)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 	int ret;
+ 	u16 num_vfs;
+ 
+ 	ret = kstrtou16(buf, 0, &num_vfs);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	if (num_vfs > pci_sriov_get_totalvfs(pdev))
+ 		return -ERANGE;
+ 
+ 	device_lock(&pdev->dev);
+ 
+ 	if (num_vfs == pdev->sriov->num_VFs)
+ 		goto exit;
+ 
+ 	/* is PF driver loaded w/callback */
+ 	if (!pdev->driver || !pdev->driver->sriov_configure) {
+ 		pci_info(pdev, "Driver does not support SRIOV configuration via sysfs\n");
+ 		ret = -ENOENT;
+ 		goto exit;
+ 	}
+ 
+ 	if (num_vfs == 0) {
+ 		/* disable VFs */
+ 		ret = pdev->driver->sriov_configure(pdev, 0);
+ 		goto exit;
+ 	}
+ 
+ 	/* enable VFs */
+ 	if (pdev->sriov->num_VFs) {
+ 		pci_warn(pdev, "%d VFs already enabled. Disable before enabling %d VFs\n",
+ 			 pdev->sriov->num_VFs, num_vfs);
+ 		ret = -EBUSY;
+ 		goto exit;
+ 	}
+ 
+ 	ret = pdev->driver->sriov_configure(pdev, num_vfs);
+ 	if (ret < 0)
+ 		goto exit;
+ 
+ 	if (ret != num_vfs)
+ 		pci_warn(pdev, "%d VFs requested; only %d enabled\n",
+ 			 num_vfs, ret);
+ 
+ exit:
+ 	device_unlock(&pdev->dev);
+ 
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	return count;
+ }
+ 
+ static ssize_t sriov_offset_show(struct device *dev,
+ 				 struct device_attribute *attr,
+ 				 char *buf)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 
+ 	return sprintf(buf, "%u\n", pdev->sriov->offset);
+ }
+ 
+ static ssize_t sriov_stride_show(struct device *dev,
+ 				 struct device_attribute *attr,
+ 				 char *buf)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 
+ 	return sprintf(buf, "%u\n", pdev->sriov->stride);
+ }
+ 
+ static ssize_t sriov_vf_device_show(struct device *dev,
+ 				    struct device_attribute *attr,
+ 				    char *buf)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 
+ 	return sprintf(buf, "%x\n", pdev->sriov->vf_device);
+ }
+ 
+ static ssize_t sriov_drivers_autoprobe_show(struct device *dev,
+ 					    struct device_attribute *attr,
+ 					    char *buf)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 
+ 	return sprintf(buf, "%u\n", pdev->sriov->drivers_autoprobe);
+ }
+ 
+ static ssize_t sriov_drivers_autoprobe_store(struct device *dev,
+ 					     struct device_attribute *attr,
+ 					     const char *buf, size_t count)
+ {
+ 	struct pci_dev *pdev = to_pci_dev(dev);
+ 	bool drivers_autoprobe;
+ 
+ 	if (kstrtobool(buf, &drivers_autoprobe) < 0)
+ 		return -EINVAL;
+ 
+ 	pdev->sriov->drivers_autoprobe = drivers_autoprobe;
+ 
+ 	return count;
+ }
+ 
+ static DEVICE_ATTR_RO(sriov_totalvfs);
+ static DEVICE_ATTR_RW(sriov_numvfs);
+ static DEVICE_ATTR_RO(sriov_offset);
+ static DEVICE_ATTR_RO(sriov_stride);
+ static DEVICE_ATTR_RO(sriov_vf_device);
+ static DEVICE_ATTR_RW(sriov_drivers_autoprobe);
+ 
+ static struct attribute *sriov_dev_attrs[] = {
+ 	&dev_attr_sriov_totalvfs.attr,
+ 	&dev_attr_sriov_numvfs.attr,
+ 	&dev_attr_sriov_offset.attr,
+ 	&dev_attr_sriov_stride.attr,
+ 	&dev_attr_sriov_vf_device.attr,
+ 	&dev_attr_sriov_drivers_autoprobe.attr,
+ 	NULL,
+ };
+ 
+ static umode_t sriov_attrs_are_visible(struct kobject *kobj,
+ 				       struct attribute *a, int n)
+ {
+ 	struct device *dev = kobj_to_dev(kobj);
+ 
+ 	if (!dev_is_pf(dev))
+ 		return 0;
+ 
+ 	return a->mode;
+ }
+ 
+ const struct attribute_group sriov_dev_attr_group = {
+ 	.attrs = sriov_dev_attrs,
+ 	.is_visible = sriov_attrs_are_visible,
+ };
+ 
++>>>>>>> 35ff867b7657 (PCI/IOV: Serialize sysfs sriov_numvfs reads vs writes)
  int __weak pcibios_sriov_enable(struct pci_dev *pdev, u16 num_vfs)
  {
  	return 0;
* Unmerged path drivers/pci/iov.c
