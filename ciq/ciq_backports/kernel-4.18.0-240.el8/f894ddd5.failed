memremap: add an owner field to struct dev_pagemap

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Christoph Hellwig <hch@lst.de>
commit f894ddd5ff01d3bb48faf4dc533536bf5269c17a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f894ddd5.failed

Add a new opaque owner field to struct dev_pagemap, which will allow the
hmm and migrate_vma code to identify who owns ZONE_DEVICE memory, and
refuse to work on mappings not owned by the calling entity.

Link: https://lore.kernel.org/r/20200316193216.920734-2-hch@lst.de
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Ralph Campbell <rcampbell@nvidia.com>
	Tested-by: Bharata B Rao <bharata@linux.ibm.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit f894ddd5ff01d3bb48faf4dc533536bf5269c17a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_hv_uvmem.c
#	include/linux/memremap.h
diff --cc include/linux/memremap.h
index 1154c9232ff2,60d97e8fd3c0..000000000000
--- a/include/linux/memremap.h
+++ b/include/linux/memremap.h
@@@ -120,22 -103,20 +120,31 @@@ struct dev_pagemap_ops 
   * @type: memory type: see MEMORY_* in memory_hotplug.h
   * @flags: PGMAP_* flags to specify defailed behavior
   * @ops: method table
+  * @owner: an opaque pointer identifying the entity that manages this
+  *	instance.  Used by various helpers to make sure that no
+  *	foreign ZONE_DEVICE memory is accessed.
   */
  struct dev_pagemap {
 +	RH_KABI_DEPRECATE(dev_page_fault_t, page_fault)
 +	RH_KABI_DEPRECATE(dev_page_free_t, page_free)
  	struct vmem_altmap altmap;
 +	RH_KABI_DEPRECATE(bool, altmap_valid)
  	struct resource res;
  	struct percpu_ref *ref;
 -	struct percpu_ref internal_ref;
 -	struct completion done;
 +	struct device *dev;
 +	RH_KABI_DEPRECATE(void *, data)
  	enum memory_type type;
++<<<<<<< HEAD
 +	u64 pci_p2pdma_bus_offset;
 +	RH_KABI_EXTEND(const struct dev_pagemap_ops *ops)
 +	RH_KABI_EXTEND(unsigned int flags)
 +	RH_KABI_EXTEND(struct percpu_ref internal_ref)
 +	RH_KABI_EXTEND(struct completion done)
++=======
+ 	unsigned int flags;
+ 	const struct dev_pagemap_ops *ops;
+ 	void *owner;
++>>>>>>> f894ddd5ff01 (memremap: add an owner field to struct dev_pagemap)
  };
  
  static inline struct vmem_altmap *pgmap_altmap(struct dev_pagemap *pgmap)
* Unmerged path arch/powerpc/kvm/book3s_hv_uvmem.c
* Unmerged path arch/powerpc/kvm/book3s_hv_uvmem.c
diff --git a/drivers/gpu/drm/nouveau/nouveau_dmem.c b/drivers/gpu/drm/nouveau/nouveau_dmem.c
index 98c1d07bfd14..6713001cc433 100644
--- a/drivers/gpu/drm/nouveau/nouveau_dmem.c
+++ b/drivers/gpu/drm/nouveau/nouveau_dmem.c
@@ -611,6 +611,7 @@ nouveau_dmem_init(struct nouveau_drm *drm)
 	drm->dmem->pagemap.type = MEMORY_DEVICE_PRIVATE;
 	drm->dmem->pagemap.res = *res;
 	drm->dmem->pagemap.ops = &nouveau_dmem_pagemap_ops;
+	drm->dmem->pagemap.owner = drm->dev;
 	if (IS_ERR(devm_memremap_pages(device, &drm->dmem->pagemap)))
 		goto out_free;
 
* Unmerged path include/linux/memremap.h
diff --git a/mm/memremap.c b/mm/memremap.c
index 8251979327a0..983665de7ca0 100644
--- a/mm/memremap.c
+++ b/mm/memremap.c
@@ -189,6 +189,10 @@ void *devm_memremap_pages(struct device *dev, struct dev_pagemap *pgmap)
 			WARN(1, "Missing migrate_to_ram method\n");
 			return ERR_PTR(-EINVAL);
 		}
+		if (!pgmap->owner) {
+			WARN(1, "Missing owner\n");
+			return ERR_PTR(-EINVAL);
+		}
 		break;
 	case MEMORY_DEVICE_FS_DAX:
 		if (!IS_ENABLED(CONFIG_ZONE_DEVICE) ||
