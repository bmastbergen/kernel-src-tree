KVM: nVMX: Skip MMU sync on nested VMX transition when possible

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 41fab65e7c44ab1c3aa4b962e6f95649354db419
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/41fab65e.failed

Skip the MMU sync when reusing a cached root if EPT is enabled or L1
enabled VPID for L2.

If EPT is enabled, guest-physical mappings aren't flushed even if VPID
is disabled, i.e. L1 can't expect stale TLB entries to be flushed if it
has enabled EPT and L0 isn't shadowing PTEs (for L1 or L2) if L1 has
EPT disabled.

If VPID is enabled (and EPT is disabled), then L1 can't expect stale TLB
entries to be flushed (for itself or L2).

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200320212833.3507-34-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 41fab65e7c44ab1c3aa4b962e6f95649354db419)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu/mmu.c
#	arch/x86/kvm/vmx/nested.c
diff --cc arch/x86/kvm/mmu/mmu.c
index dbd97923dc2c,34c015461c35..000000000000
--- a/arch/x86/kvm/mmu/mmu.c
+++ b/arch/x86/kvm/mmu/mmu.c
@@@ -5099,7 -5034,7 +5099,11 @@@ void kvm_init_shadow_ept_mmu(struct kvm
  		kvm_calc_shadow_ept_root_page_role(vcpu, accessed_dirty,
  						   execonly, level);
  
++<<<<<<< HEAD
 +	__kvm_mmu_new_cr3(vcpu, new_eptp, new_role.base, false);
++=======
+ 	__kvm_mmu_new_cr3(vcpu, new_eptp, new_role.base, false, true);
++>>>>>>> 41fab65e7c44 (KVM: nVMX: Skip MMU sync on nested VMX transition when possible)
  
  	if (new_role.as_u64 == context->mmu_role.as_u64)
  		return;
diff --cc arch/x86/kvm/vmx/nested.c
index cd775c31a62d,a8290954caa7..000000000000
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@@ -1101,8 -1142,12 +1143,16 @@@ static int nested_vmx_load_cr3(struct k
  		}
  	}
  
+ 	/*
+ 	 * See nested_vmx_transition_mmu_sync for details on skipping the MMU sync.
+ 	 */
  	if (!nested_ept)
++<<<<<<< HEAD
 +		kvm_mmu_new_cr3(vcpu, cr3, false);
++=======
+ 		kvm_mmu_new_cr3(vcpu, cr3, false,
+ 				!nested_vmx_transition_mmu_sync(vcpu));
++>>>>>>> 41fab65e7c44 (KVM: nVMX: Skip MMU sync on nested VMX transition when possible)
  
  	vcpu->arch.cr3 = cr3;
  	kvm_register_mark_available(vcpu, VCPU_EXREG_CR3);
* Unmerged path arch/x86/kvm/mmu/mmu.c
* Unmerged path arch/x86/kvm/vmx/nested.c
