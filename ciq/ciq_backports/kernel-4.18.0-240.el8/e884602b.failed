perf parse: Refactor 'struct perf_evsel_config_term'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Leo Yan <leo.yan@linaro.org>
commit e884602b57c07fae54ff357e4b996b2053b47c1e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e884602b.failed

The struct perf_evsel_config_term::val is a union which contains fields
'callgraph', 'drv_cfg' and 'branch' as string pointers.  This leads to
the complex code logic for handling every type's string separately, and
it's hard to release string as a general way.

This patch refactors the structure to add a common field 'str' in the
'val' union as string pointer and remove the other three fields
'callgraph', 'drv_cfg' and 'branch'.  Without passing field name, the
patch simplifies the string handling with macro ADD_CONFIG_TERM_STR()
for string pointer assignment.

This patch fixes multiple warnings of line over 80 characters detected
by checkpatch tool.

	Signed-off-by: Leo Yan <leo.yan@linaro.org>
	Reviewed-by: Andi Kleen <ak@linux.intel.com>
	Acked-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Ian Rogers <irogers@google.com>
	Cc: Mark Rutland <mark.rutland@arm.com>
	Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
	Cc: Mike Leach <mike.leach@linaro.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Suzuki Poulouse <suzuki.poulose@arm.com>
	Cc: linux-arm-kernel@lists.infradead.org
Link: http://lore.kernel.org/lkml/20200117055251.24058-1-leo.yan@linaro.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit e884602b57c07fae54ff357e4b996b2053b47c1e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/evsel_config.h
#	tools/perf/util/parse-events.c
diff --cc tools/perf/util/parse-events.c
index ce2e8d2dbd45,f59f3c8da473..000000000000
--- a/tools/perf/util/parse-events.c
+++ b/tools/perf/util/parse-events.c
@@@ -1208,56 -1248,101 +1217,108 @@@ do {								
  	list_for_each_entry(term, head_config, list) {
  		switch (term->type_term) {
  		case PARSE_EVENTS__TERM_TYPE_SAMPLE_PERIOD:
- 			ADD_CONFIG_TERM(PERIOD, period, term->val.num);
+ 			ADD_CONFIG_TERM_VAL(PERIOD, period, term->val.num);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_SAMPLE_FREQ:
- 			ADD_CONFIG_TERM(FREQ, freq, term->val.num);
+ 			ADD_CONFIG_TERM_VAL(FREQ, freq, term->val.num);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_TIME:
- 			ADD_CONFIG_TERM(TIME, time, term->val.num);
+ 			ADD_CONFIG_TERM_VAL(TIME, time, term->val.num);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_CALLGRAPH:
- 			ADD_CONFIG_TERM(CALLGRAPH, callgraph, term->val.str);
+ 			ADD_CONFIG_TERM_STR(CALLGRAPH, term->val.str);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_BRANCH_SAMPLE_TYPE:
- 			ADD_CONFIG_TERM(BRANCH, branch, term->val.str);
+ 			ADD_CONFIG_TERM_STR(BRANCH, term->val.str);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_STACKSIZE:
- 			ADD_CONFIG_TERM(STACK_USER, stack_user, term->val.num);
+ 			ADD_CONFIG_TERM_VAL(STACK_USER, stack_user,
+ 					    term->val.num);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_INHERIT:
- 			ADD_CONFIG_TERM(INHERIT, inherit, term->val.num ? 1 : 0);
+ 			ADD_CONFIG_TERM_VAL(INHERIT, inherit,
+ 					    term->val.num ? 1 : 0);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_NOINHERIT:
- 			ADD_CONFIG_TERM(INHERIT, inherit, term->val.num ? 0 : 1);
+ 			ADD_CONFIG_TERM_VAL(INHERIT, inherit,
+ 					    term->val.num ? 0 : 1);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_MAX_STACK:
- 			ADD_CONFIG_TERM(MAX_STACK, max_stack, term->val.num);
+ 			ADD_CONFIG_TERM_VAL(MAX_STACK, max_stack,
+ 					    term->val.num);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_MAX_EVENTS:
- 			ADD_CONFIG_TERM(MAX_EVENTS, max_events, term->val.num);
+ 			ADD_CONFIG_TERM_VAL(MAX_EVENTS, max_events,
+ 					    term->val.num);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_OVERWRITE:
- 			ADD_CONFIG_TERM(OVERWRITE, overwrite, term->val.num ? 1 : 0);
+ 			ADD_CONFIG_TERM_VAL(OVERWRITE, overwrite,
+ 					    term->val.num ? 1 : 0);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_NOOVERWRITE:
- 			ADD_CONFIG_TERM(OVERWRITE, overwrite, term->val.num ? 0 : 1);
+ 			ADD_CONFIG_TERM_VAL(OVERWRITE, overwrite,
+ 					    term->val.num ? 0 : 1);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_DRV_CFG:
- 			ADD_CONFIG_TERM(DRV_CFG, drv_cfg, term->val.str);
+ 			ADD_CONFIG_TERM_STR(DRV_CFG, term->val.str);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_PERCORE:
- 			ADD_CONFIG_TERM(PERCORE, percore,
- 					term->val.num ? true : false);
+ 			ADD_CONFIG_TERM_VAL(PERCORE, percore,
+ 					    term->val.num ? true : false);
  			break;
  		case PARSE_EVENTS__TERM_TYPE_AUX_OUTPUT:
- 			ADD_CONFIG_TERM(AUX_OUTPUT, aux_output, term->val.num ? 1 : 0);
+ 			ADD_CONFIG_TERM_VAL(AUX_OUTPUT, aux_output,
+ 					    term->val.num ? 1 : 0);
+ 			break;
++<<<<<<< HEAD
++=======
+ 		case PARSE_EVENTS__TERM_TYPE_AUX_SAMPLE_SIZE:
+ 			ADD_CONFIG_TERM_VAL(AUX_SAMPLE_SIZE, aux_sample_size,
+ 					    term->val.num);
  			break;
++>>>>>>> e884602b57c0 (perf parse: Refactor 'struct perf_evsel_config_term')
  		default:
  			break;
  		}
  	}
++<<<<<<< HEAD
 +#undef ADD_EVSEL_CONFIG
++=======
+ 	return 0;
+ }
+ 
+ /*
+  * Add PERF_EVSEL__CONFIG_TERM_CFG_CHG where cfg_chg will have a bit set for
+  * each bit of attr->config that the user has changed.
+  */
+ static int get_config_chgs(struct perf_pmu *pmu, struct list_head *head_config,
+ 			   struct list_head *head_terms)
+ {
+ 	struct parse_events_term *term;
+ 	u64 bits = 0;
+ 	int type;
+ 
+ 	list_for_each_entry(term, head_config, list) {
+ 		switch (term->type_term) {
+ 		case PARSE_EVENTS__TERM_TYPE_USER:
+ 			type = perf_pmu__format_type(&pmu->format, term->config);
+ 			if (type != PERF_PMU_FORMAT_VALUE_CONFIG)
+ 				continue;
+ 			bits |= perf_pmu__format_bits(&pmu->format, term->config);
+ 			break;
+ 		case PARSE_EVENTS__TERM_TYPE_CONFIG:
+ 			bits = ~(u64)0;
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (bits)
+ 		ADD_CONFIG_TERM_VAL(CFG_CHG, cfg_chg, bits);
+ 
+ #undef ADD_CONFIG_TERM
++>>>>>>> e884602b57c0 (perf parse: Refactor 'struct perf_evsel_config_term')
  	return 0;
  }
  
* Unmerged path tools/perf/util/evsel_config.h
diff --git a/tools/perf/arch/arm/util/cs-etm.c b/tools/perf/arch/arm/util/cs-etm.c
index 4208974c24f8..ac1bb5216f04 100644
--- a/tools/perf/arch/arm/util/cs-etm.c
+++ b/tools/perf/arch/arm/util/cs-etm.c
@@ -222,7 +222,7 @@ static int cs_etm_set_sink_attr(struct perf_pmu *pmu,
 		if (term->type != PERF_EVSEL__CONFIG_TERM_DRV_CFG)
 			continue;
 
-		sink = term->val.drv_cfg;
+		sink = term->val.str;
 		snprintf(path, PATH_MAX, "sinks/%s", sink);
 
 		ret = perf_pmu__scan_file(pmu, path, "%x", &hash);
diff --git a/tools/perf/util/evsel.c b/tools/perf/util/evsel.c
index c59d310d3797..a51cdc1ee2ce 100644
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@ -799,12 +799,12 @@ static void apply_config_terms(struct perf_evsel *evsel,
 				perf_evsel__reset_sample_bit(evsel, TIME);
 			break;
 		case PERF_EVSEL__CONFIG_TERM_CALLGRAPH:
-			callgraph_buf = term->val.callgraph;
+			callgraph_buf = term->val.str;
 			break;
 		case PERF_EVSEL__CONFIG_TERM_BRANCH:
-			if (term->val.branch && strcmp(term->val.branch, "no")) {
+			if (term->val.str && strcmp(term->val.str, "no")) {
 				perf_evsel__set_sample_bit(evsel, BRANCH_STACK);
-				parse_branch_str(term->val.branch,
+				parse_branch_str(term->val.str,
 						 &attr->branch_sample_type);
 			} else
 				perf_evsel__reset_sample_bit(evsel, BRANCH_STACK);
* Unmerged path tools/perf/util/evsel_config.h
* Unmerged path tools/perf/util/parse-events.c
