Bluetooth: btusb: Use cmd_timeout to reset Realtek device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Alex Lu <alex_lu@realsil.com.cn>
commit d7ef0d1e39685b38c97b30daa6de0d50df004839
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d7ef0d1e.failed

Realtek Bluetooth controller provides a BT_DIS reset pin for hardware
reset of it. The cmd_timeout is helpful on Realtek bluetooth controller
where the firmware gets stuck.

	Signed-off-by: Alex Lu <alex_lu@realsil.com.cn>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit d7ef0d1e39685b38c97b30daa6de0d50df004839)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btusb.c
diff --cc drivers/bluetooth/btusb.c
index 559321547f03,ed455de598ea..000000000000
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@@ -490,8 -489,71 +490,73 @@@ struct btusb_data 
  	int (*setup_on_usb)(struct hci_dev *hdev);
  
  	int oob_wake_irq;   /* irq for out-of-band wake-on-bt */
 -	unsigned cmd_timeout_cnt;
  };
  
++<<<<<<< HEAD
++=======
+ 
+ static void btusb_intel_cmd_timeout(struct hci_dev *hdev)
+ {
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 	struct gpio_desc *reset_gpio = data->reset_gpio;
+ 
+ 	if (++data->cmd_timeout_cnt < 5)
+ 		return;
+ 
+ 	if (!reset_gpio) {
+ 		bt_dev_err(hdev, "No way to reset. Ignoring and continuing");
+ 		return;
+ 	}
+ 
+ 	/*
+ 	 * Toggle the hard reset line if the platform provides one. The reset
+ 	 * is going to yank the device off the USB and then replug. So doing
+ 	 * once is enough. The cleanup is handled correctly on the way out
+ 	 * (standard USB disconnect), and the new device is detected cleanly
+ 	 * and bound to the driver again like it should be.
+ 	 */
+ 	if (test_and_set_bit(BTUSB_HW_RESET_ACTIVE, &data->flags)) {
+ 		bt_dev_err(hdev, "last reset failed? Not resetting again");
+ 		return;
+ 	}
+ 
+ 	bt_dev_err(hdev, "Initiating HW reset via gpio");
+ 	gpiod_set_value_cansleep(reset_gpio, 1);
+ 	msleep(100);
+ 	gpiod_set_value_cansleep(reset_gpio, 0);
+ }
+ 
+ static void btusb_rtl_cmd_timeout(struct hci_dev *hdev)
+ {
+ 	struct btusb_data *data = hci_get_drvdata(hdev);
+ 	struct gpio_desc *reset_gpio = data->reset_gpio;
+ 
+ 	if (++data->cmd_timeout_cnt < 5)
+ 		return;
+ 
+ 	if (!reset_gpio) {
+ 		bt_dev_err(hdev, "No gpio to reset Realtek device, ignoring");
+ 		return;
+ 	}
+ 
+ 	/* Toggle the hard reset line. The Realtek device is going to
+ 	 * yank itself off the USB and then replug. The cleanup is handled
+ 	 * correctly on the way out (standard USB disconnect), and the new
+ 	 * device is detected cleanly and bound to the driver again like
+ 	 * it should be.
+ 	 */
+ 	if (test_and_set_bit(BTUSB_HW_RESET_ACTIVE, &data->flags)) {
+ 		bt_dev_err(hdev, "last reset failed? Not resetting again");
+ 		return;
+ 	}
+ 
+ 	bt_dev_err(hdev, "Reset Realtek device via gpio");
+ 	gpiod_set_value_cansleep(reset_gpio, 0);
+ 	msleep(200);
+ 	gpiod_set_value_cansleep(reset_gpio, 1);
+ }
+ 
++>>>>>>> d7ef0d1e3968 (Bluetooth: btusb: Use cmd_timeout to reset Realtek device)
  static inline void btusb_free_frags(struct btusb_data *data)
  {
  	unsigned long flags;
@@@ -3113,12 -3812,14 +3178,17 @@@ static int btusb_probe(struct usb_inter
  #ifdef CONFIG_BT_HCIBTUSB_RTL
  	if (id->driver_info & BTUSB_REALTEK) {
  		hdev->setup = btrtl_setup_realtek;
++<<<<<<< HEAD
++=======
+ 		hdev->shutdown = btrtl_shutdown_realtek;
+ 		hdev->cmd_timeout = btusb_rtl_cmd_timeout;
++>>>>>>> d7ef0d1e3968 (Bluetooth: btusb: Use cmd_timeout to reset Realtek device)
  
 -		/* Realtek devices lose their updated firmware over global
 -		 * suspend that means host doesn't send SET_FEATURE
 -		 * (DEVICE_REMOTE_WAKEUP)
 +		/* Realtek devices lose their updated firmware over suspend,
 +		 * but the USB hub doesn't notice any status change.
 +		 * Explicitly request a device reset on resume.
  		 */
 -		set_bit(BTUSB_WAKEUP_DISABLE, &data->flags);
 +		interface_to_usbdev(intf)->quirks |= USB_QUIRK_RESET_RESUME;
  	}
  #endif
  
* Unmerged path drivers/bluetooth/btusb.c
