mptcp: fix races between shutdown and recvmsg

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 5969856ae8ce29c9d523a1a6145cbd9e87f7046c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5969856a.failed

The msk sk_shutdown flag is set by a workqueue, possibly
introducing some delay in user-space notification. If the last
subflow carries some data with the fin packet, the user space
can wake-up before RCV_SHUTDOWN is set. If it executes unblocking
recvmsg(), it may return with an error instead of eof.

Address the issue explicitly checking for eof in recvmsg(), when
no data is found.

Fixes: 59832e246515 ("mptcp: subflow: check parent mptcp socket on subflow state change")
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Reviewed-by: Matthieu Baerts <matthieu.baerts@tessares.net>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5969856ae8ce29c9d523a1a6145cbd9e87f7046c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
diff --cc net/mptcp/protocol.c
index 0ab57e20dcf2,3980fbb6f31e..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -347,6 -365,36 +347,39 @@@ void mptcp_data_acked(struct sock *sk
  		sock_hold(sk);
  }
  
++<<<<<<< HEAD
++=======
+ void mptcp_subflow_eof(struct sock *sk)
+ {
+ 	struct mptcp_sock *msk = mptcp_sk(sk);
+ 
+ 	if (!test_and_set_bit(MPTCP_WORK_EOF, &msk->flags) &&
+ 	    schedule_work(&msk->work))
+ 		sock_hold(sk);
+ }
+ 
+ static void mptcp_check_for_eof(struct mptcp_sock *msk)
+ {
+ 	struct mptcp_subflow_context *subflow;
+ 	struct sock *sk = (struct sock *)msk;
+ 	int receivers = 0;
+ 
+ 	mptcp_for_each_subflow(msk, subflow)
+ 		receivers += !subflow->rx_eof;
+ 
+ 	if (!receivers && !(sk->sk_shutdown & RCV_SHUTDOWN)) {
+ 		/* hopefully temporary hack: propagate shutdown status
+ 		 * to msk, when all subflows agree on it
+ 		 */
+ 		sk->sk_shutdown |= RCV_SHUTDOWN;
+ 
+ 		smp_mb__before_atomic(); /* SHUTDOWN must be visible first */
+ 		set_bit(MPTCP_DATA_READY, &msk->flags);
+ 		sk->sk_data_ready(sk);
+ 	}
+ }
+ 
++>>>>>>> 5969856ae8ce (mptcp: fix races between shutdown and recvmsg)
  static void mptcp_stop_timer(struct sock *sk)
  {
  	struct inet_connection_sock *icsk = inet_csk(sk);
@@@ -1120,6 -1167,11 +1156,14 @@@ static void __mptcp_close_ssk(struct so
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static unsigned int mptcp_sync_mss(struct sock *sk, u32 pmtu)
+ {
+ 	return 0;
+ }
+ 
++>>>>>>> 5969856ae8ce (mptcp: fix races between shutdown and recvmsg)
  static void mptcp_worker(struct work_struct *work)
  {
  	struct mptcp_sock *msk = container_of(work, struct mptcp_sock, work);
* Unmerged path net/mptcp/protocol.c
