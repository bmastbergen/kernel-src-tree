ftrace: Fix memory leak caused by not freeing entry in unregister_ftrace_direct()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Steven Rostedt (VMware) <rostedt@goodmis.org>
commit 353da87921a5ec654e7e9024e083f099f1b33c97
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/353da879.failed

kmemleak reported the following:

unreferenced object 0xffff90d47127a920 (size 32):
  comm "modprobe", pid 1766, jiffies 4294792031 (age 162.568s)
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 22 01 00 00 00 00 ad de  ........".......
    00 78 12 a7 ff ff ff ff 00 00 b6 c0 ff ff ff ff  .x..............
  backtrace:
    [<00000000bb79e72e>] register_ftrace_direct+0xcb/0x3a0
    [<00000000295e4f79>] do_one_initcall+0x72/0x340
    [<00000000873ead18>] do_init_module+0x5a/0x220
    [<00000000974d9de5>] load_module+0x2235/0x2550
    [<0000000059c3d6ce>] __do_sys_finit_module+0xc0/0x120
    [<000000005a8611b4>] do_syscall_64+0x60/0x230
    [<00000000a0cdc49e>] entry_SYSCALL_64_after_hwframe+0x49/0xb3

The entry used to save the direct descriptor needs to be freed
when unregistering.

	Signed-off-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
(cherry picked from commit 353da87921a5ec654e7e9024e083f099f1b33c97)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/ftrace.c
diff --cc kernel/trace/ftrace.c
index 3bd9dedf1818,bd030b1b9514..000000000000
--- a/kernel/trace/ftrace.c
+++ b/kernel/trace/ftrace.c
@@@ -4804,9 -4938,370 +4804,373 @@@ static in
  ftrace_set_addr(struct ftrace_ops *ops, unsigned long ip, int remove,
  		int reset, int enable)
  {
 -	return ftrace_set_hash(ops, NULL, 0, ip, remove, reset, enable);
 +	return ftrace_set_hash(ops, 0, 0, ip, remove, reset, enable);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS
+ 
+ struct ftrace_direct_func {
+ 	struct list_head	next;
+ 	unsigned long		addr;
+ 	int			count;
+ };
+ 
+ static LIST_HEAD(ftrace_direct_funcs);
+ 
+ /**
+  * ftrace_find_direct_func - test an address if it is a registered direct caller
+  * @addr: The address of a registered direct caller
+  *
+  * This searches to see if a ftrace direct caller has been registered
+  * at a specific address, and if so, it returns a descriptor for it.
+  *
+  * This can be used by architecture code to see if an address is
+  * a direct caller (trampoline) attached to a fentry/mcount location.
+  * This is useful for the function_graph tracer, as it may need to
+  * do adjustments if it traced a location that also has a direct
+  * trampoline attached to it.
+  */
+ struct ftrace_direct_func *ftrace_find_direct_func(unsigned long addr)
+ {
+ 	struct ftrace_direct_func *entry;
+ 	bool found = false;
+ 
+ 	/* May be called by fgraph trampoline (protected by rcu tasks) */
+ 	list_for_each_entry_rcu(entry, &ftrace_direct_funcs, next) {
+ 		if (entry->addr == addr) {
+ 			found = true;
+ 			break;
+ 		}
+ 	}
+ 	if (found)
+ 		return entry;
+ 
+ 	return NULL;
+ }
+ 
+ /**
+  * register_ftrace_direct - Call a custom trampoline directly
+  * @ip: The address of the nop at the beginning of a function
+  * @addr: The address of the trampoline to call at @ip
+  *
+  * This is used to connect a direct call from the nop location (@ip)
+  * at the start of ftrace traced functions. The location that it calls
+  * (@addr) must be able to handle a direct call, and save the parameters
+  * of the function being traced, and restore them (or inject new ones
+  * if needed), before returning.
+  *
+  * Returns:
+  *  0 on success
+  *  -EBUSY - Another direct function is already attached (there can be only one)
+  *  -ENODEV - @ip does not point to a ftrace nop location (or not supported)
+  *  -ENOMEM - There was an allocation failure.
+  */
+ int register_ftrace_direct(unsigned long ip, unsigned long addr)
+ {
+ 	struct ftrace_direct_func *direct;
+ 	struct ftrace_func_entry *entry;
+ 	struct ftrace_hash *free_hash = NULL;
+ 	struct dyn_ftrace *rec;
+ 	int ret = -EBUSY;
+ 
+ 	mutex_lock(&direct_mutex);
+ 
+ 	/* See if there's a direct function at @ip already */
+ 	if (ftrace_find_rec_direct(ip))
+ 		goto out_unlock;
+ 
+ 	ret = -ENODEV;
+ 	rec = lookup_rec(ip, ip);
+ 	if (!rec)
+ 		goto out_unlock;
+ 
+ 	/*
+ 	 * Check if the rec says it has a direct call but we didn't
+ 	 * find one earlier?
+ 	 */
+ 	if (WARN_ON(rec->flags & FTRACE_FL_DIRECT))
+ 		goto out_unlock;
+ 
+ 	/* Make sure the ip points to the exact record */
+ 	if (ip != rec->ip) {
+ 		ip = rec->ip;
+ 		/* Need to check this ip for a direct. */
+ 		if (ftrace_find_rec_direct(ip))
+ 			goto out_unlock;
+ 	}
+ 
+ 	ret = -ENOMEM;
+ 	if (ftrace_hash_empty(direct_functions) ||
+ 	    direct_functions->count > 2 * (1 << direct_functions->size_bits)) {
+ 		struct ftrace_hash *new_hash;
+ 		int size = ftrace_hash_empty(direct_functions) ? 0 :
+ 			direct_functions->count + 1;
+ 
+ 		if (size < 32)
+ 			size = 32;
+ 
+ 		new_hash = dup_hash(direct_functions, size);
+ 		if (!new_hash)
+ 			goto out_unlock;
+ 
+ 		free_hash = direct_functions;
+ 		direct_functions = new_hash;
+ 	}
+ 
+ 	entry = kmalloc(sizeof(*entry), GFP_KERNEL);
+ 	if (!entry)
+ 		goto out_unlock;
+ 
+ 	direct = ftrace_find_direct_func(addr);
+ 	if (!direct) {
+ 		direct = kmalloc(sizeof(*direct), GFP_KERNEL);
+ 		if (!direct) {
+ 			kfree(entry);
+ 			goto out_unlock;
+ 		}
+ 		direct->addr = addr;
+ 		direct->count = 0;
+ 		list_add_rcu(&direct->next, &ftrace_direct_funcs);
+ 		ftrace_direct_func_count++;
+ 	}
+ 
+ 	entry->ip = ip;
+ 	entry->direct = addr;
+ 	__add_hash_entry(direct_functions, entry);
+ 
+ 	ret = ftrace_set_filter_ip(&direct_ops, ip, 0, 0);
+ 	if (ret)
+ 		remove_hash_entry(direct_functions, entry);
+ 
+ 	if (!ret && !(direct_ops.flags & FTRACE_OPS_FL_ENABLED)) {
+ 		ret = register_ftrace_function(&direct_ops);
+ 		if (ret)
+ 			ftrace_set_filter_ip(&direct_ops, ip, 1, 0);
+ 	}
+ 
+ 	if (ret) {
+ 		kfree(entry);
+ 		if (!direct->count) {
+ 			list_del_rcu(&direct->next);
+ 			synchronize_rcu_tasks();
+ 			kfree(direct);
+ 			if (free_hash)
+ 				free_ftrace_hash(free_hash);
+ 			free_hash = NULL;
+ 			ftrace_direct_func_count--;
+ 		}
+ 	} else {
+ 		direct->count++;
+ 	}
+  out_unlock:
+ 	mutex_unlock(&direct_mutex);
+ 
+ 	if (free_hash) {
+ 		synchronize_rcu_tasks();
+ 		free_ftrace_hash(free_hash);
+ 	}
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(register_ftrace_direct);
+ 
+ static struct ftrace_func_entry *find_direct_entry(unsigned long *ip,
+ 						   struct dyn_ftrace **recp)
+ {
+ 	struct ftrace_func_entry *entry;
+ 	struct dyn_ftrace *rec;
+ 
+ 	rec = lookup_rec(*ip, *ip);
+ 	if (!rec)
+ 		return NULL;
+ 
+ 	entry = __ftrace_lookup_ip(direct_functions, rec->ip);
+ 	if (!entry) {
+ 		WARN_ON(rec->flags & FTRACE_FL_DIRECT);
+ 		return NULL;
+ 	}
+ 
+ 	WARN_ON(!(rec->flags & FTRACE_FL_DIRECT));
+ 
+ 	/* Passed in ip just needs to be on the call site */
+ 	*ip = rec->ip;
+ 
+ 	if (recp)
+ 		*recp = rec;
+ 
+ 	return entry;
+ }
+ 
+ int unregister_ftrace_direct(unsigned long ip, unsigned long addr)
+ {
+ 	struct ftrace_direct_func *direct;
+ 	struct ftrace_func_entry *entry;
+ 	int ret = -ENODEV;
+ 
+ 	mutex_lock(&direct_mutex);
+ 
+ 	entry = find_direct_entry(&ip, NULL);
+ 	if (!entry)
+ 		goto out_unlock;
+ 
+ 	if (direct_functions->count == 1)
+ 		unregister_ftrace_function(&direct_ops);
+ 
+ 	ret = ftrace_set_filter_ip(&direct_ops, ip, 1, 0);
+ 
+ 	WARN_ON(ret);
+ 
+ 	remove_hash_entry(direct_functions, entry);
+ 
+ 	direct = ftrace_find_direct_func(addr);
+ 	if (!WARN_ON(!direct)) {
+ 		/* This is the good path (see the ! before WARN) */
+ 		direct->count--;
+ 		WARN_ON(direct->count < 0);
+ 		if (!direct->count) {
+ 			list_del_rcu(&direct->next);
+ 			synchronize_rcu_tasks();
+ 			kfree(direct);
+ 			kfree(entry);
+ 			ftrace_direct_func_count--;
+ 		}
+ 	}
+  out_unlock:
+ 	mutex_unlock(&direct_mutex);
+ 
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(unregister_ftrace_direct);
+ 
+ static struct ftrace_ops stub_ops = {
+ 	.func		= ftrace_stub,
+ };
+ 
+ /**
+  * ftrace_modify_direct_caller - modify ftrace nop directly
+  * @entry: The ftrace hash entry of the direct helper for @rec
+  * @rec: The record representing the function site to patch
+  * @old_addr: The location that the site at @rec->ip currently calls
+  * @new_addr: The location that the site at @rec->ip should call
+  *
+  * An architecture may overwrite this function to optimize the
+  * changing of the direct callback on an ftrace nop location.
+  * This is called with the ftrace_lock mutex held, and no other
+  * ftrace callbacks are on the associated record (@rec). Thus,
+  * it is safe to modify the ftrace record, where it should be
+  * currently calling @old_addr directly, to call @new_addr.
+  *
+  * Safety checks should be made to make sure that the code at
+  * @rec->ip is currently calling @old_addr. And this must
+  * also update entry->direct to @new_addr.
+  */
+ int __weak ftrace_modify_direct_caller(struct ftrace_func_entry *entry,
+ 				       struct dyn_ftrace *rec,
+ 				       unsigned long old_addr,
+ 				       unsigned long new_addr)
+ {
+ 	unsigned long ip = rec->ip;
+ 	int ret;
+ 
+ 	/*
+ 	 * The ftrace_lock was used to determine if the record
+ 	 * had more than one registered user to it. If it did,
+ 	 * we needed to prevent that from changing to do the quick
+ 	 * switch. But if it did not (only a direct caller was attached)
+ 	 * then this function is called. But this function can deal
+ 	 * with attached callers to the rec that we care about, and
+ 	 * since this function uses standard ftrace calls that take
+ 	 * the ftrace_lock mutex, we need to release it.
+ 	 */
+ 	mutex_unlock(&ftrace_lock);
+ 
+ 	/*
+ 	 * By setting a stub function at the same address, we force
+ 	 * the code to call the iterator and the direct_ops helper.
+ 	 * This means that @ip does not call the direct call, and
+ 	 * we can simply modify it.
+ 	 */
+ 	ret = ftrace_set_filter_ip(&stub_ops, ip, 0, 0);
+ 	if (ret)
+ 		goto out_lock;
+ 
+ 	ret = register_ftrace_function(&stub_ops);
+ 	if (ret) {
+ 		ftrace_set_filter_ip(&stub_ops, ip, 1, 0);
+ 		goto out_lock;
+ 	}
+ 
+ 	entry->direct = new_addr;
+ 
+ 	/*
+ 	 * By removing the stub, we put back the direct call, calling
+ 	 * the @new_addr.
+ 	 */
+ 	unregister_ftrace_function(&stub_ops);
+ 	ftrace_set_filter_ip(&stub_ops, ip, 1, 0);
+ 
+  out_lock:
+ 	mutex_lock(&ftrace_lock);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * modify_ftrace_direct - Modify an existing direct call to call something else
+  * @ip: The instruction pointer to modify
+  * @old_addr: The address that the current @ip calls directly
+  * @new_addr: The address that the @ip should call
+  *
+  * This modifies a ftrace direct caller at an instruction pointer without
+  * having to disable it first. The direct call will switch over to the
+  * @new_addr without missing anything.
+  *
+  * Returns: zero on success. Non zero on error, which includes:
+  *  -ENODEV : the @ip given has no direct caller attached
+  *  -EINVAL : the @old_addr does not match the current direct caller
+  */
+ int modify_ftrace_direct(unsigned long ip,
+ 			 unsigned long old_addr, unsigned long new_addr)
+ {
+ 	struct ftrace_func_entry *entry;
+ 	struct dyn_ftrace *rec;
+ 	int ret = -ENODEV;
+ 
+ 	mutex_lock(&direct_mutex);
+ 
+ 	mutex_lock(&ftrace_lock);
+ 	entry = find_direct_entry(&ip, &rec);
+ 	if (!entry)
+ 		goto out_unlock;
+ 
+ 	ret = -EINVAL;
+ 	if (entry->direct != old_addr)
+ 		goto out_unlock;
+ 
+ 	/*
+ 	 * If there's no other ftrace callback on the rec->ip location,
+ 	 * then it can be changed directly by the architecture.
+ 	 * If there is another caller, then we just need to change the
+ 	 * direct caller helper to point to @new_addr.
+ 	 */
+ 	if (ftrace_rec_count(rec) == 1) {
+ 		ret = ftrace_modify_direct_caller(entry, rec, old_addr, new_addr);
+ 	} else {
+ 		entry->direct = new_addr;
+ 		ret = 0;
+ 	}
+ 
+  out_unlock:
+ 	mutex_unlock(&ftrace_lock);
+ 	mutex_unlock(&direct_mutex);
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(modify_ftrace_direct);
+ #endif /* CONFIG_DYNAMIC_FTRACE_WITH_DIRECT_CALLS */
+ 
++>>>>>>> 353da87921a5 (ftrace: Fix memory leak caused by not freeing entry in unregister_ftrace_direct())
  /**
   * ftrace_set_filter_ip - set a function to filter on in ftrace by address
   * @ops - the ops to set the filter with
* Unmerged path kernel/trace/ftrace.c
