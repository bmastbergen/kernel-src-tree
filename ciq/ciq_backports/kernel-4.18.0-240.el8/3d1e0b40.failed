netfilter: conntrack: remove two args from resolve_clash

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 3d1e0b406de16508de96f4a07fc3f94cfc678372
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/3d1e0b40.failed

ctinfo is whats taken from the skb, i.e.
ct = nf_ct_get(skb, &ctinfo).

We do not pass 'ct' and instead re-fetch it from the skb.
Just do the same for both netns and ctinfo.

Also add a comment on what clash resolution is supposed to do.
While at it, one indent level can be removed.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 3d1e0b406de16508de96f4a07fc3f94cfc678372)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_core.c
diff --cc net/netfilter/nf_conntrack_core.c
index 686f6a679bd8,5e332b01f3c0..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -743,22 -925,33 +765,48 @@@ nf_ct_resolve_clash(struct sk_buff *skb
  	/* This is the conntrack entry already in hashes that won race. */
  	struct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);
  	const struct nf_conntrack_l4proto *l4proto;
- 	enum ip_conntrack_info oldinfo;
- 	struct nf_conn *loser_ct = nf_ct_get(skb, &oldinfo);
+ 	enum ip_conntrack_info ctinfo;
+ 	struct nf_conn *loser_ct;
+ 	struct net *net;
+ 
+ 	loser_ct = nf_ct_get(skb, &ctinfo);
  
++<<<<<<< HEAD
 +	l4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));
 +	if (l4proto->allow_clash &&
 +	    !nf_ct_is_dying(ct) &&
 +	    atomic_inc_not_zero(&ct->ct_general.use)) {
 +		if (((ct->status & IPS_NAT_DONE_MASK) == 0) ||
 +		    nf_ct_match(ct, loser_ct)) {
 +			nf_ct_acct_merge(ct, ctinfo, loser_ct);
 +			nf_conntrack_put(&loser_ct->ct_general);
 +			nf_ct_set(skb, ct, oldinfo);
 +			return NF_ACCEPT;
 +		}
 +		nf_ct_put(ct);
++=======
+ 	l4proto = nf_ct_l4proto_find(nf_ct_protonum(ct));
+ 	if (!l4proto->allow_clash)
+ 		goto drop;
+ 
+ 	if (nf_ct_is_dying(ct))
+ 		goto drop;
+ 
+ 	if (!atomic_inc_not_zero(&ct->ct_general.use))
+ 		goto drop;
+ 
+ 	if (((ct->status & IPS_NAT_DONE_MASK) == 0) ||
+ 	    nf_ct_match(ct, loser_ct)) {
+ 		nf_ct_acct_merge(ct, ctinfo, loser_ct);
+ 		nf_conntrack_put(&loser_ct->ct_general);
+ 		nf_ct_set(skb, ct, ctinfo);
+ 		return NF_ACCEPT;
++>>>>>>> 3d1e0b406de1 (netfilter: conntrack: remove two args from resolve_clash)
  	}
+ 
+ 	nf_ct_put(ct);
+ drop:
+ 	net = nf_ct_net(loser_ct);
  	NF_CT_STAT_INC(net, drop);
  	return NF_DROP;
  }
* Unmerged path net/netfilter/nf_conntrack_core.c
