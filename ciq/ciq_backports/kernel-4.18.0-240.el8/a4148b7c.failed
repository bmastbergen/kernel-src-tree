KVM: VMX: Retrieve APIC access page HPA only when necessary

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit a4148b7ca2a5afe1295a41b5e30048cabcb74f8d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a4148b7c.failed

Move the retrieval of the HPA associated with L1's APIC access page into
VMX code to avoid unnecessarily calling gfn_to_page(), e.g. when the
vCPU is in guest mode (L2).  Alternatively, the optimization logic in
VMX could be mirrored into the common x86 code, but that will get ugly
fast when further optimizations are introduced.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200320212833.3507-29-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit a4148b7ca2a5afe1295a41b5e30048cabcb74f8d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/vmx/vmx.c
index dbadf7ce3b2f,8550da629a61..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -6198,12 -6140,28 +6198,35 @@@ void vmx_set_virtual_apic_mode(struct k
  	vmx_update_msr_bitmap(vcpu);
  }
  
- static void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu, hpa_t hpa)
+ static void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	if (!is_guest_mode(vcpu)) {
 +		vmcs_write64(APIC_ACCESS_ADDR, hpa);
 +		vmx_flush_tlb(vcpu, true);
 +	}
++=======
+ 	struct page *page;
+ 
+ 	/* Defer reload until vmcs01 is the current VMCS. */
+ 	if (is_guest_mode(vcpu)) {
+ 		to_vmx(vcpu)->nested.reload_vmcs01_apic_access_page = true;
+ 		return;
+ 	}
+ 
+ 	page = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);
+ 	if (is_error_page(page))
+ 		return;
+ 
+ 	vmcs_write64(APIC_ACCESS_ADDR, page_to_phys(page));
+ 	vmx_flush_tlb_current(vcpu);
+ 
+ 	/*
+ 	 * Do not pin apic access page in memory, the MMU notifier
+ 	 * will call us again if it is migrated or swapped out.
+ 	 */
+ 	put_page(page);
++>>>>>>> a4148b7ca2a5 (KVM: VMX: Retrieve APIC access page HPA only when necessary)
  }
  
  static void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)
diff --cc arch/x86/kvm/x86.c
index 0a8a4dd82886,90aa4abbc0a6..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -8028,21 -8160,10 +8028,23 @@@ void kvm_vcpu_reload_apic_access_page(s
  	if (!lapic_in_kernel(vcpu))
  		return;
  
 -	if (!kvm_x86_ops.set_apic_access_page_addr)
 +	if (!kvm_x86_ops->set_apic_access_page_addr)
 +		return;
 +
++<<<<<<< HEAD
 +	page = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);
 +	if (is_error_page(page))
  		return;
 +	kvm_x86_ops->set_apic_access_page_addr(vcpu, page_to_phys(page));
  
 +	/*
 +	 * Do not pin apic access page in memory, the MMU notifier
 +	 * will call us again if it is migrated or swapped out.
 +	 */
 +	put_page(page);
++=======
+ 	kvm_x86_ops.set_apic_access_page_addr(vcpu);
++>>>>>>> a4148b7ca2a5 (KVM: VMX: Retrieve APIC access page HPA only when necessary)
  }
  
  void __kvm_request_immediate_exit(struct kvm_vcpu *vcpu)
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 10275c160b4e..483c2dc32e06 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -1146,7 +1146,7 @@ struct kvm_x86_ops {
 	bool (*guest_apic_has_interrupt)(struct kvm_vcpu *vcpu);
 	void (*load_eoi_exitmap)(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap);
 	void (*set_virtual_apic_mode)(struct kvm_vcpu *vcpu);
-	void (*set_apic_access_page_addr)(struct kvm_vcpu *vcpu, hpa_t hpa);
+	void (*set_apic_access_page_addr)(struct kvm_vcpu *vcpu);
 	int (*deliver_posted_interrupt)(struct kvm_vcpu *vcpu, int vector);
 	int (*sync_pir_to_irr)(struct kvm_vcpu *vcpu);
 	int (*set_tss_addr)(struct kvm *kvm, unsigned int addr);
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/x86.c
