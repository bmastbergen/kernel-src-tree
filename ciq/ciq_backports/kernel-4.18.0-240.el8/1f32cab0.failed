timers: Use only bucket expiry for base->next_expiry value

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Anna-Maria Behnsen <anna-maria@linutronix.de>
commit 1f32cab0db4bdf6491eb4a60838f278e01c31698
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/1f32cab0.failed

The bucket expiry time is the effective expriy time of timers and is
greater than or equal to the requested timer expiry time. This is due
to the guarantee that timers never expire early and the reduced expiry
granularity in the secondary wheel levels.

When a timer is enqueued, trigger_dyntick_cpu() checks whether the
timer is the new first timer. This check compares next_expiry with
the requested timer expiry value and not with the effective expiry
value of the bucket into which the timer was queued.

Storing the requested timer expiry value in base->next_expiry can lead
to base->clk going backwards if the requested timer expiry value is
smaller than base->clk. Commit 30c66fc30ee7 ("timer: Prevent base->clk
from moving backward") worked around this by preventing the store when
timer->expiry is before base->clk, but did not fix the underlying
problem.

Use the expiry value of the bucket into which the timer is queued to
do the new first timer check. This fixes the base->clk going backward
problem.

The workaround of commit 30c66fc30ee7 ("timer: Prevent base->clk from
moving backward") in trigger_dyntick_cpu() is not longer necessary as the
timers bucket expiry is guaranteed to be greater than or equal base->clk.

	Signed-off-by: Anna-Maria Behnsen <anna-maria@linutronix.de>
	Signed-off-by: Frederic Weisbecker <frederic@kernel.org>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lkml.kernel.org/r/20200717140551.29076-4-frederic@kernel.org

(cherry picked from commit 1f32cab0db4bdf6491eb4a60838f278e01c31698)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/timer.c
diff --cc kernel/time/timer.c
index a7c5c50bce77,a7a3cf737411..000000000000
--- a/kernel/time/timer.c
+++ b/kernel/time/timer.c
@@@ -582,8 -594,8 +592,13 @@@ trigger_dyntick_cpu(struct timer_base *
  	 * Set the next expiry time and kick the CPU so it can reevaluate the
  	 * wheel:
  	 */
++<<<<<<< HEAD
 +	base->next_expiry = timer->expires;
 +		wake_up_nohz_cpu(base->cpu);
++=======
+ 	base->next_expiry = bucket_expiry;
+ 	wake_up_nohz_cpu(base->cpu);
++>>>>>>> 1f32cab0db4b (timers: Use only bucket expiry for base->next_expiry value)
  }
  
  static void
* Unmerged path kernel/time/timer.c
