netfilter: conntrack: remove error callback and handle icmp from core

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 6fe78fa484a5dad030b24e33e0cedc5d5bbd0fde
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6fe78fa4.failed

icmp(v6) are the only two layer four protocols that need the error()
callback (to handle icmp errors that are related to an established
connections, e.g. packet too big, port unreachable and the like).

Remove the error callback and handle these two special cases from the core.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 6fe78fa484a5dad030b24e33e0cedc5d5bbd0fde)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_conntrack_l4proto.h
#	net/ipv4/netfilter/nf_conntrack_proto_icmp.c
#	net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
#	net/netfilter/nf_conntrack_core.c
diff --cc include/net/netfilter/nf_conntrack_l4proto.h
index 771e9d473ecd,7fdb4b95bba4..000000000000
--- a/include/net/netfilter/nf_conntrack_l4proto.h
+++ b/include/net/netfilter/nf_conntrack_l4proto.h
@@@ -56,10 -51,6 +56,13 @@@ struct nf_conntrack_l4proto 
  	/* Called when a conntrack entry is destroyed */
  	void (*destroy)(struct nf_conn *ct);
  
++<<<<<<< HEAD
 +	int (*error)(struct net *net, struct nf_conn *tmpl, struct sk_buff *skb,
 +		     unsigned int dataoff,
 +		     u_int8_t pf, unsigned int hooknum);
 +
++=======
++>>>>>>> 6fe78fa484a5 (netfilter: conntrack: remove error callback and handle icmp from core)
  	/* called by gc worker if table is full */
  	bool (*can_early_drop)(const struct nf_conn *ct);
  
diff --cc net/ipv4/netfilter/nf_conntrack_proto_icmp.c
index f2bc6a47243a,2c981622b674..000000000000
--- a/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
+++ b/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
@@@ -170,10 -165,9 +170,16 @@@ static void icmp_error_log(const struc
  }
  
  /* Small and modified version of icmp_rcv */
++<<<<<<< HEAD:net/ipv4/netfilter/nf_conntrack_proto_icmp.c
 +static int
 +icmp_error(struct net *net, struct nf_conn *tmpl,
 +	   struct sk_buff *skb, unsigned int dataoff,
 +	   u8 pf, unsigned int hooknum)
++=======
+ int nf_conntrack_icmpv4_error(struct nf_conn *tmpl,
+ 			      struct sk_buff *skb, unsigned int dataoff,
+ 			      const struct nf_hook_state *state)
++>>>>>>> 6fe78fa484a5 (netfilter: conntrack: remove error callback and handle icmp from core):net/netfilter/nf_conntrack_proto_icmp.c
  {
  	const struct icmphdr *icmph;
  	struct icmphdr _ih;
@@@ -357,9 -354,6 +363,12 @@@ const struct nf_conntrack_l4proto nf_co
  	.pkt_to_tuple		= icmp_pkt_to_tuple,
  	.invert_tuple		= icmp_invert_tuple,
  	.packet			= icmp_packet,
++<<<<<<< HEAD:net/ipv4/netfilter/nf_conntrack_proto_icmp.c
 +	.get_timeouts		= icmp_get_timeouts,
 +	.new			= icmp_new,
 +	.error			= icmp_error,
++=======
++>>>>>>> 6fe78fa484a5 (netfilter: conntrack: remove error callback and handle icmp from core):net/netfilter/nf_conntrack_proto_icmp.c
  	.destroy		= NULL,
  	.me			= NULL,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
diff --cc net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
index c3ab22bf84b8,effac451c7e0..000000000000
--- a/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
@@@ -174,16 -176,18 +174,23 @@@ icmpv6_error_message(struct net *net, s
  	return NF_ACCEPT;
  }
  
 -static void icmpv6_error_log(const struct sk_buff *skb,
 -			     const struct nf_hook_state *state,
 -			     const char *msg)
 +static void icmpv6_error_log(const struct sk_buff *skb, struct net *net,
 +			     u8 pf, const char *msg)
  {
 -	nf_l4proto_log_invalid(skb, state->net, state->pf,
 -			       IPPROTO_ICMPV6, "%s", msg);
 +	nf_l4proto_log_invalid(skb, net, pf, IPPROTO_ICMPV6, "%s", msg);
  }
  
++<<<<<<< HEAD:net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
 +static int
 +icmpv6_error(struct net *net, struct nf_conn *tmpl,
 +	     struct sk_buff *skb, unsigned int dataoff,
 +	     u8 pf, unsigned int hooknum)
++=======
+ int nf_conntrack_icmpv6_error(struct nf_conn *tmpl,
+ 			      struct sk_buff *skb,
+ 			      unsigned int dataoff,
+ 			      const struct nf_hook_state *state)
++>>>>>>> 6fe78fa484a5 (netfilter: conntrack: remove error callback and handle icmp from core):net/netfilter/nf_conntrack_proto_icmpv6.c
  {
  	const struct icmp6hdr *icmp6h;
  	struct icmp6hdr _ih;
@@@ -358,9 -365,6 +365,12 @@@ const struct nf_conntrack_l4proto nf_co
  	.pkt_to_tuple		= icmpv6_pkt_to_tuple,
  	.invert_tuple		= icmpv6_invert_tuple,
  	.packet			= icmpv6_packet,
++<<<<<<< HEAD:net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
 +	.get_timeouts		= icmpv6_get_timeouts,
 +	.new			= icmpv6_new,
 +	.error			= icmpv6_error,
++=======
++>>>>>>> 6fe78fa484a5 (netfilter: conntrack: remove error callback and handle icmp from core):net/netfilter/nf_conntrack_proto_icmpv6.c
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr	= icmpv6_tuple_to_nlattr,
  	.nlattr_tuple_size	= icmpv6_nlattr_tuple_size,
diff --cc net/netfilter/nf_conntrack_core.c
index 397b134cecce,087bf63826fb..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -1479,18 -1486,47 +1479,51 @@@ resolve_normal_ct(struct net *net, stru
  	return 0;
  }
  
+ /*
+  * icmp packets need special treatment to handle error messages that are
+  * related to a connection.
+  *
+  * Callers need to check if skb has a conntrack assigned when this
+  * helper returns; in such case skb belongs to an already known connection.
+  */
+ static unsigned int __cold
+ nf_conntrack_handle_icmp(struct nf_conn *tmpl,
+ 			 struct sk_buff *skb,
+ 			 unsigned int dataoff,
+ 			 u8 protonum,
+ 			 const struct nf_hook_state *state)
+ {
+ 	int ret;
+ 
+ 	if (state->pf == NFPROTO_IPV4 && protonum == IPPROTO_ICMP)
+ 		ret = nf_conntrack_icmpv4_error(tmpl, skb, dataoff, state);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	else if (state->pf == NFPROTO_IPV6 && protonum == IPPROTO_ICMPV6)
+ 		ret = nf_conntrack_icmpv6_error(tmpl, skb, dataoff, state);
+ #endif
+ 	else
+ 		return NF_ACCEPT;
+ 
+ 	if (ret <= 0) {
+ 		NF_CT_STAT_INC_ATOMIC(state->net, error);
+ 		NF_CT_STAT_INC_ATOMIC(state->net, invalid);
+ 	}
+ 
+ 	return ret;
+ }
+ 
  unsigned int
 -nf_conntrack_in(struct sk_buff *skb, const struct nf_hook_state *state)
 +nf_conntrack_in(struct net *net, u_int8_t pf, unsigned int hooknum,
 +		struct sk_buff *skb)
  {
 +	const struct nf_conntrack_l3proto *l3proto;
  	const struct nf_conntrack_l4proto *l4proto;
 -	enum ip_conntrack_info ctinfo;
  	struct nf_conn *ct, *tmpl;
 +	enum ip_conntrack_info ctinfo;
 +	unsigned int *timeouts;
 +	unsigned int dataoff;
  	u_int8_t protonum;
 -	int dataoff, ret;
 +	int ret;
  
  	tmpl = nf_ct_get(skb, &ctinfo);
  	if (tmpl || ctinfo == IP_CT_UNTRACKED) {
@@@ -1515,16 -1549,12 +1548,23 @@@
  		goto out;
  	}
  
 -	l4proto = __nf_ct_l4proto_find(state->pf, protonum);
 +	l4proto = __nf_ct_l4proto_find(pf, protonum);
  
++<<<<<<< HEAD
 +	/* It may be an special packet, error, unclean...
 +	 * inverse of the return code tells to the netfilter
 +	 * core what to do with the packet. */
 +	if (l4proto->error != NULL) {
 +		ret = l4proto->error(net, tmpl, skb, dataoff, pf, hooknum);
 +		if (ret <= 0) {
 +			NF_CT_STAT_INC_ATOMIC(net, error);
 +			NF_CT_STAT_INC_ATOMIC(net, invalid);
++=======
+ 	if (protonum == IPPROTO_ICMP || protonum == IPPROTO_ICMPV6) {
+ 		ret = nf_conntrack_handle_icmp(tmpl, skb, dataoff,
+ 					       protonum, state);
+ 		if (ret <= 0) {
++>>>>>>> 6fe78fa484a5 (netfilter: conntrack: remove error callback and handle icmp from core)
  			ret = -ret;
  			goto out;
  		}
* Unmerged path include/net/netfilter/nf_conntrack_l4proto.h
* Unmerged path net/ipv4/netfilter/nf_conntrack_proto_icmp.c
* Unmerged path net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
* Unmerged path net/netfilter/nf_conntrack_core.c
