drm/i915/display: Load DP_TP_CTL/STATUS offset before use it

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit edcb9028d66b44d74ba4f8b9daa379b004dc1f85
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/edcb9028.failed

Right now dp.regs.dp_tp_ctl/status are only set during the encoder
pre_enable() hook, what is causing all reads and writes to those
registers to go to offset 0x0 before pre_enable() is executed.

So if i915 takes the BIOS state and don't do a modeset any following
link retraing will fail.

In the case that i915 needs to do a modeset, the DDI disable sequence
will write to a wrong register not disabling DP 'Transport Enable' in
DP_TP_CTL, making a HDMI modeset in the same port/transcoder to
not light up the monitor.

So here for GENs older than 12, that have those registers fixed at
port offset range it is loading at encoder/port init while for GEN12
it will keep setting it at encoder pre_enable() and during HW state
readout.

Fixes: 4444df6e205b ("drm/i915/tgl: move DP_TP_* to transcoder")
	Cc: Matt Roper <matthew.d.roper@intel.com>
	Cc: Lucas De Marchi <lucas.demarchi@intel.com>
	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
	Reviewed-by: Matt Roper <matthew.d.roper@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200414230442.262092-1-jose.souza@intel.com
(cherry picked from commit edcb9028d66b44d74ba4f8b9daa379b004dc1f85)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_ddi.c
diff --cc drivers/gpu/drm/i915/display/intel_ddi.c
index fd58aa20d02e,1aab93a94f40..000000000000
--- a/drivers/gpu/drm/i915/display/intel_ddi.c
+++ b/drivers/gpu/drm/i915/display/intel_ddi.c
@@@ -3762,16 -4056,23 +3762,31 @@@ void intel_ddi_get_config(struct intel_
  			  struct intel_crtc_state *pipe_config)
  {
  	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 -	struct intel_crtc *intel_crtc = to_intel_crtc(pipe_config->uapi.crtc);
 +	struct intel_crtc *intel_crtc = to_intel_crtc(pipe_config->base.crtc);
  	enum transcoder cpu_transcoder = pipe_config->cpu_transcoder;
++<<<<<<< HEAD
 +	struct intel_digital_port *intel_dig_port;
++=======
+ 	struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
++>>>>>>> edcb9028d66b (drm/i915/display: Load DP_TP_CTL/STATUS offset before use it)
  	u32 temp, flags = 0;
  
  	/* XXX: DSI transcoder paranoia */
 -	if (drm_WARN_ON(&dev_priv->drm, transcoder_is_dsi(cpu_transcoder)))
 +	if (WARN_ON(transcoder_is_dsi(cpu_transcoder)))
  		return;
  
++<<<<<<< HEAD
 +	temp = I915_READ(TRANS_DDI_FUNC_CTL(cpu_transcoder));
++=======
+ 	if (INTEL_GEN(dev_priv) >= 12) {
+ 		intel_dp->regs.dp_tp_ctl = TGL_DP_TP_CTL(cpu_transcoder);
+ 		intel_dp->regs.dp_tp_status = TGL_DP_TP_STATUS(cpu_transcoder);
+ 	}
+ 
+ 	intel_dsc_get_config(encoder, pipe_config);
+ 
+ 	temp = intel_de_read(dev_priv, TRANS_DDI_FUNC_CTL(cpu_transcoder));
++>>>>>>> edcb9028d66b (drm/i915/display: Load DP_TP_CTL/STATUS offset before use it)
  	if (temp & TRANS_DDI_PHSYNC)
  		flags |= DRM_MODE_FLAG_PHSYNC;
  	else
* Unmerged path drivers/gpu/drm/i915/display/intel_ddi.c
diff --git a/drivers/gpu/drm/i915/display/intel_dp.c b/drivers/gpu/drm/i915/display/intel_dp.c
index 9ec0808f141e..b8a569ee5cae 100644
--- a/drivers/gpu/drm/i915/display/intel_dp.c
+++ b/drivers/gpu/drm/i915/display/intel_dp.c
@@ -7506,6 +7506,8 @@ bool intel_dp_init(struct drm_i915_private *dev_priv,
 
 	intel_dig_port->dp.output_reg = output_reg;
 	intel_dig_port->max_lanes = 4;
+	intel_dig_port->dp.regs.dp_tp_ctl = DP_TP_CTL(port);
+	intel_dig_port->dp.regs.dp_tp_status = DP_TP_STATUS(port);
 
 	intel_encoder->type = INTEL_OUTPUT_DP;
 	intel_encoder->power_domain = intel_port_to_power_domain(port);
