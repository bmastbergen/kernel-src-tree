net/mlx5: Restrict metadata disablement to offloads mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Parav Pandit <parav@mellanox.com>
commit a962d7a61e2404cda6a89bfa5cc193c62223bb5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a962d7a6.failed

Now that there is clear separation for acl setup/cleanup between legacy
and offloads mode, limit metdata disablement to offloads mode.

	Signed-off-by: Parav Pandit <parav@mellanox.com>
	Reviewed-by: Vu Pham <vuhuong@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit a962d7a61e2404cda6a89bfa5cc193c62223bb5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 7ecf89103bc8,61459c06f56c..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@@ -1197,16 -1205,15 +1197,21 @@@ out
  void esw_vport_cleanup_ingress_rules(struct mlx5_eswitch *esw,
  				     struct mlx5_vport *vport)
  {
 -	if (!IS_ERR_OR_NULL(vport->ingress.legacy.drop_rule)) {
 -		mlx5_del_flow_rules(vport->ingress.legacy.drop_rule);
 -		vport->ingress.legacy.drop_rule = NULL;
 -	}
 +	if (!IS_ERR_OR_NULL(vport->ingress.drop_rule))
 +		mlx5_del_flow_rules(vport->ingress.drop_rule);
  
 -	if (!IS_ERR_OR_NULL(vport->ingress.allow_rule)) {
 +	if (!IS_ERR_OR_NULL(vport->ingress.allow_rule))
  		mlx5_del_flow_rules(vport->ingress.allow_rule);
++<<<<<<< HEAD
 +
 +	vport->ingress.drop_rule = NULL;
 +	vport->ingress.allow_rule = NULL;
 +
 +	esw_vport_del_ingress_acl_modify_metadata(esw, vport);
++=======
+ 		vport->ingress.allow_rule = NULL;
+ 	}
++>>>>>>> a962d7a61e24 (net/mlx5: Restrict metadata disablement to offloads mode)
  }
  
  void esw_vport_disable_ingress_acl(struct mlx5_eswitch *esw,
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 00d126fa6e02,b536c8fa0061..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -1952,53 -1950,47 +1952,76 @@@ esw_check_vport_match_metadata_supporte
  	return true;
  }
  
 -int
 -esw_vport_create_offloads_acl_tables(struct mlx5_eswitch *esw,
 -				     struct mlx5_vport *vport)
 +static bool
 +esw_check_vport_match_metadata_mandatory(const struct mlx5_eswitch *esw)
  {
++<<<<<<< HEAD
 +	return mlx5_core_mp_enabled(esw->dev);
++=======
+ 	int err;
+ 
+ 	err = esw_vport_ingress_config(esw, vport);
+ 	if (err)
+ 		return err;
+ 
+ 	if (mlx5_eswitch_is_vf_vport(esw, vport->vport)) {
+ 		err = esw_vport_egress_config(esw, vport);
+ 		if (err) {
+ 			esw_vport_del_ingress_acl_modify_metadata(esw, vport);
+ 			esw_vport_disable_ingress_acl(esw, vport);
+ 		}
+ 	}
+ 	return err;
++>>>>>>> a962d7a61e24 (net/mlx5: Restrict metadata disablement to offloads mode)
  }
  
 -void
 -esw_vport_destroy_offloads_acl_tables(struct mlx5_eswitch *esw,
 -				      struct mlx5_vport *vport)
 +static bool esw_use_vport_metadata(const struct mlx5_eswitch *esw)
  {
++<<<<<<< HEAD
 +	return esw_check_vport_match_metadata_mandatory(esw) &&
 +	       esw_check_vport_match_metadata_supported(esw);
++=======
+ 	esw_vport_disable_egress_acl(esw, vport);
+ 	esw_vport_del_ingress_acl_modify_metadata(esw, vport);
+ 	esw_vport_disable_ingress_acl(esw, vport);
++>>>>>>> a962d7a61e24 (net/mlx5: Restrict metadata disablement to offloads mode)
  }
  
 -static int esw_create_uplink_offloads_acl_tables(struct mlx5_eswitch *esw)
 +static int esw_create_offloads_acl_tables(struct mlx5_eswitch *esw)
  {
  	struct mlx5_vport *vport;
 +	int i, j;
  	int err;
  
 -	if (esw_check_vport_match_metadata_supported(esw))
 +	if (esw_use_vport_metadata(esw))
  		esw->flags |= MLX5_ESWITCH_VPORT_MATCH_METADATA;
  
 -	vport = mlx5_eswitch_get_vport(esw, MLX5_VPORT_UPLINK);
 -	err = esw_vport_create_offloads_acl_tables(esw, vport);
 -	if (err)
 -		esw->flags &= ~MLX5_ESWITCH_VPORT_MATCH_METADATA;
 +	mlx5_esw_for_all_vports(esw, i, vport) {
 +		err = esw_vport_ingress_config(esw, vport);
 +		if (err)
 +			goto err_ingress;
 +
 +		if (mlx5_eswitch_is_vf_vport(esw, vport->vport)) {
 +			err = esw_vport_egress_config(esw, vport);
 +			if (err)
 +				goto err_egress;
 +		}
 +	}
 +
 +	if (mlx5_eswitch_vport_match_metadata_enabled(esw))
 +		esw_info(esw->dev, "Use metadata reg_c as source vport to match\n");
 +
 +	return 0;
 +
 +err_egress:
 +	esw_vport_disable_ingress_acl(esw, vport);
 +err_ingress:
 +	for (j = MLX5_VPORT_PF; j < i; j++) {
 +		vport = &esw->vports[j];
 +		esw_vport_disable_egress_acl(esw, vport);
 +		esw_vport_disable_ingress_acl(esw, vport);
 +	}
 +
  	return err;
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index ab76b9d1f8c7..5e252cd82fa9 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -263,8 +263,6 @@ void esw_vport_disable_egress_acl(struct mlx5_eswitch *esw,
 				  struct mlx5_vport *vport);
 void esw_vport_disable_ingress_acl(struct mlx5_eswitch *esw,
 				   struct mlx5_vport *vport);
-void esw_vport_del_ingress_acl_modify_metadata(struct mlx5_eswitch *esw,
-					       struct mlx5_vport *vport);
 int mlx5_esw_modify_vport_rate(struct mlx5_eswitch *esw, u16 vport_num,
 			       u32 rate_mbps);
 
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
