powerpc/papr_scm: Implement support for PAPR_PDSM_HEALTH

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Vaibhav Jain <vaibhav@linux.ibm.com>
commit d35f18b554be015b6fa89fad6447c6fce8e6ad66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d35f18b5.failed

This patch implements support for PDSM request 'PAPR_PDSM_HEALTH'
that returns a newly introduced 'struct nd_papr_pdsm_health' instance
containing dimm health information back to user space in response to
ND_CMD_CALL. This functionality is implemented in newly introduced
papr_pdsm_health() that queries the nvdimm health information and
then copies this information to the package payload whose layout is
defined by 'struct nd_papr_pdsm_health'.

	Signed-off-by: Vaibhav Jain <vaibhav@linux.ibm.com>
	Cc: "Aneesh Kumar K . V" <aneesh.kumar@linux.ibm.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Ira Weiny <ira.weiny@intel.com>
Link: https://lore.kernel.org/r/20200615124407.32596-7-vaibhav@linux.ibm.com
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit d35f18b554be015b6fa89fad6447c6fce8e6ad66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/uapi/asm/papr_pdsm.h
#	arch/powerpc/platforms/pseries/papr_scm.c
diff --cc arch/powerpc/platforms/pseries/papr_scm.c
index ff5a5974d78e,9c569078a09f..000000000000
--- a/arch/powerpc/platforms/pseries/papr_scm.c
+++ b/arch/powerpc/platforms/pseries/papr_scm.c
@@@ -256,6 -368,230 +256,233 @@@ int papr_scm_ndctl(struct nvdimm_bus_de
  	if (!nvdimm)
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	/* get the provider data from struct nvdimm */
+ 	p = nvdimm_provider_data(nvdimm);
+ 
+ 	if (!test_bit(cmd, &cmd_mask)) {
+ 		dev_dbg(&p->pdev->dev, "Unsupported cmd=%u\n", cmd);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* For CMD_CALL verify pdsm request */
+ 	if (cmd == ND_CMD_CALL) {
+ 		/* Verify the envelope and envelop size */
+ 		if (!buf ||
+ 		    buf_len < (sizeof(struct nd_cmd_pkg) + ND_PDSM_HDR_SIZE)) {
+ 			dev_dbg(&p->pdev->dev, "Invalid pkg size=%u\n",
+ 				buf_len);
+ 			return -EINVAL;
+ 		}
+ 
+ 		/* Verify that the nd_cmd_pkg.nd_family is correct */
+ 		nd_cmd = (struct nd_cmd_pkg *)buf;
+ 
+ 		if (nd_cmd->nd_family != NVDIMM_FAMILY_PAPR) {
+ 			dev_dbg(&p->pdev->dev, "Invalid pkg family=0x%llx\n",
+ 				nd_cmd->nd_family);
+ 			return -EINVAL;
+ 		}
+ 
+ 		pdsm = (enum papr_pdsm)nd_cmd->nd_command;
+ 
+ 		/* Verify if the pdsm command is valid */
+ 		if (pdsm <= PAPR_PDSM_MIN || pdsm >= PAPR_PDSM_MAX) {
+ 			dev_dbg(&p->pdev->dev, "PDSM[0x%x]: Invalid PDSM\n",
+ 				pdsm);
+ 			return -EINVAL;
+ 		}
+ 
+ 		/* Have enough space to hold returned 'nd_pkg_pdsm' header */
+ 		if (nd_cmd->nd_size_out < ND_PDSM_HDR_SIZE) {
+ 			dev_dbg(&p->pdev->dev, "PDSM[0x%x]: Invalid payload\n",
+ 				pdsm);
+ 			return -EINVAL;
+ 		}
+ 	}
+ 
+ 	/* Let the command be further processed */
+ 	return 0;
+ }
+ 
+ /* Fetch the DIMM health info and populate it in provided package. */
+ static int papr_pdsm_health(struct papr_scm_priv *p,
+ 			    union nd_pdsm_payload *payload)
+ {
+ 	int rc;
+ 
+ 	/* Ensure dimm health mutex is taken preventing concurrent access */
+ 	rc = mutex_lock_interruptible(&p->health_mutex);
+ 	if (rc)
+ 		goto out;
+ 
+ 	/* Always fetch upto date dimm health data ignoring cached values */
+ 	rc = __drc_pmem_query_health(p);
+ 	if (rc) {
+ 		mutex_unlock(&p->health_mutex);
+ 		goto out;
+ 	}
+ 
+ 	/* update health struct with various flags derived from health bitmap */
+ 	payload->health = (struct nd_papr_pdsm_health) {
+ 		.extension_flags = 0,
+ 		.dimm_unarmed = !!(p->health_bitmap & PAPR_PMEM_UNARMED_MASK),
+ 		.dimm_bad_shutdown = !!(p->health_bitmap & PAPR_PMEM_BAD_SHUTDOWN_MASK),
+ 		.dimm_bad_restore = !!(p->health_bitmap & PAPR_PMEM_BAD_RESTORE_MASK),
+ 		.dimm_scrubbed = !!(p->health_bitmap & PAPR_PMEM_SCRUBBED_AND_LOCKED),
+ 		.dimm_locked = !!(p->health_bitmap & PAPR_PMEM_SCRUBBED_AND_LOCKED),
+ 		.dimm_encrypted = !!(p->health_bitmap & PAPR_PMEM_ENCRYPTED),
+ 		.dimm_health = PAPR_PDSM_DIMM_HEALTHY,
+ 	};
+ 
+ 	/* Update field dimm_health based on health_bitmap flags */
+ 	if (p->health_bitmap & PAPR_PMEM_HEALTH_FATAL)
+ 		payload->health.dimm_health = PAPR_PDSM_DIMM_FATAL;
+ 	else if (p->health_bitmap & PAPR_PMEM_HEALTH_CRITICAL)
+ 		payload->health.dimm_health = PAPR_PDSM_DIMM_CRITICAL;
+ 	else if (p->health_bitmap & PAPR_PMEM_HEALTH_UNHEALTHY)
+ 		payload->health.dimm_health = PAPR_PDSM_DIMM_UNHEALTHY;
+ 
+ 	/* struct populated hence can release the mutex now */
+ 	mutex_unlock(&p->health_mutex);
+ 	rc = sizeof(struct nd_papr_pdsm_health);
+ 
+ out:
+ 	return rc;
+ }
+ 
+ /*
+  * 'struct pdsm_cmd_desc'
+  * Identifies supported PDSMs' expected length of in/out payloads
+  * and pdsm service function.
+  *
+  * size_in	: Size of input payload if any in the PDSM request.
+  * size_out	: Size of output payload if any in the PDSM request.
+  * service	: Service function for the PDSM request. Return semantics:
+  *		  rc < 0 : Error servicing PDSM and rc indicates the error.
+  *		  rc >=0 : Serviced successfully and 'rc' indicate number of
+  *			bytes written to payload.
+  */
+ struct pdsm_cmd_desc {
+ 	u32 size_in;
+ 	u32 size_out;
+ 	int (*service)(struct papr_scm_priv *dimm,
+ 		       union nd_pdsm_payload *payload);
+ };
+ 
+ /* Holds all supported PDSMs' command descriptors */
+ static const struct pdsm_cmd_desc __pdsm_cmd_descriptors[] = {
+ 	[PAPR_PDSM_MIN] = {
+ 		.size_in = 0,
+ 		.size_out = 0,
+ 		.service = NULL,
+ 	},
+ 	/* New PDSM command descriptors to be added below */
+ 
+ 	[PAPR_PDSM_HEALTH] = {
+ 		.size_in = 0,
+ 		.size_out = sizeof(struct nd_papr_pdsm_health),
+ 		.service = papr_pdsm_health,
+ 	},
+ 	/* Empty */
+ 	[PAPR_PDSM_MAX] = {
+ 		.size_in = 0,
+ 		.size_out = 0,
+ 		.service = NULL,
+ 	},
+ };
+ 
+ /* Given a valid pdsm cmd return its command descriptor else return NULL */
+ static inline const struct pdsm_cmd_desc *pdsm_cmd_desc(enum papr_pdsm cmd)
+ {
+ 	if (cmd >= 0 || cmd < ARRAY_SIZE(__pdsm_cmd_descriptors))
+ 		return &__pdsm_cmd_descriptors[cmd];
+ 
+ 	return NULL;
+ }
+ 
+ /*
+  * For a given pdsm request call an appropriate service function.
+  * Returns errors if any while handling the pdsm command package.
+  */
+ static int papr_scm_service_pdsm(struct papr_scm_priv *p,
+ 				 struct nd_cmd_pkg *pkg)
+ {
+ 	/* Get the PDSM header and PDSM command */
+ 	struct nd_pkg_pdsm *pdsm_pkg = (struct nd_pkg_pdsm *)pkg->nd_payload;
+ 	enum papr_pdsm pdsm = (enum papr_pdsm)pkg->nd_command;
+ 	const struct pdsm_cmd_desc *pdsc;
+ 	int rc;
+ 
+ 	/* Fetch corresponding pdsm descriptor for validation and servicing */
+ 	pdsc = pdsm_cmd_desc(pdsm);
+ 
+ 	/* Validate pdsm descriptor */
+ 	/* Ensure that reserved fields are 0 */
+ 	if (pdsm_pkg->reserved[0] || pdsm_pkg->reserved[1]) {
+ 		dev_dbg(&p->pdev->dev, "PDSM[0x%x]: Invalid reserved field\n",
+ 			pdsm);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* If pdsm expects some input, then ensure that the size_in matches */
+ 	if (pdsc->size_in &&
+ 	    pkg->nd_size_in != (pdsc->size_in + ND_PDSM_HDR_SIZE)) {
+ 		dev_dbg(&p->pdev->dev, "PDSM[0x%x]: Mismatched size_in=%d\n",
+ 			pdsm, pkg->nd_size_in);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* If pdsm wants to return data, then ensure that  size_out matches */
+ 	if (pdsc->size_out &&
+ 	    pkg->nd_size_out != (pdsc->size_out + ND_PDSM_HDR_SIZE)) {
+ 		dev_dbg(&p->pdev->dev, "PDSM[0x%x]: Mismatched size_out=%d\n",
+ 			pdsm, pkg->nd_size_out);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* Service the pdsm */
+ 	if (pdsc->service) {
+ 		dev_dbg(&p->pdev->dev, "PDSM[0x%x]: Servicing..\n", pdsm);
+ 
+ 		rc = pdsc->service(p, &pdsm_pkg->payload);
+ 
+ 		if (rc < 0) {
+ 			/* error encountered while servicing pdsm */
+ 			pdsm_pkg->cmd_status = rc;
+ 			pkg->nd_fw_size = ND_PDSM_HDR_SIZE;
+ 		} else {
+ 			/* pdsm serviced and 'rc' bytes written to payload */
+ 			pdsm_pkg->cmd_status = 0;
+ 			pkg->nd_fw_size = ND_PDSM_HDR_SIZE + rc;
+ 		}
+ 	} else {
+ 		dev_dbg(&p->pdev->dev, "PDSM[0x%x]: Unsupported PDSM request\n",
+ 			pdsm);
+ 		pdsm_pkg->cmd_status = -ENOENT;
+ 		pkg->nd_fw_size = ND_PDSM_HDR_SIZE;
+ 	}
+ 
+ 	return pdsm_pkg->cmd_status;
+ }
+ 
+ static int papr_scm_ndctl(struct nvdimm_bus_descriptor *nd_desc,
+ 			  struct nvdimm *nvdimm, unsigned int cmd, void *buf,
+ 			  unsigned int buf_len, int *cmd_rc)
+ {
+ 	struct nd_cmd_get_config_size *get_size_hdr;
+ 	struct nd_cmd_pkg *call_pkg = NULL;
+ 	struct papr_scm_priv *p;
+ 	int rc;
+ 
+ 	rc = is_cmd_valid(nvdimm, cmd, buf, buf_len);
+ 	if (rc) {
+ 		pr_debug("Invalid cmd=0x%x. Err=%d\n", cmd, rc);
+ 		return rc;
+ 	}
+ 
++>>>>>>> d35f18b554be (powerpc/papr_scm: Implement support for PAPR_PDSM_HEALTH)
  	/* Use a local variable in case cmd_rc pointer is NULL */
  	if (!cmd_rc)
  		cmd_rc = &rc;
* Unmerged path arch/powerpc/include/uapi/asm/papr_pdsm.h
* Unmerged path arch/powerpc/include/uapi/asm/papr_pdsm.h
* Unmerged path arch/powerpc/platforms/pseries/papr_scm.c
