selftests/bpf: Test for map update access from within EXT programs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Udip Pant <udippant@fb.com>
commit 1410620cf20e7e23cce17983e9a81af659b28583
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/1410620c.failed

This adds further tests to ensure access permissions and restrictions
are applied properly for some map types such as sock-map.
It also adds another negative tests to assert static functions cannot be
replaced. In the 'unreliable' mode it still fails with error 'tracing progs
cannot use bpf_spin_lock yet' with the change in the verifier

	Signed-off-by: Udip Pant <udippant@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20200825232003.2877030-5-udippant@fb.com
(cherry picked from commit 1410620cf20e7e23cce17983e9a81af659b28583)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/prog_tests/fexit_bpf2bpf.c
diff --cc tools/testing/selftests/bpf/prog_tests/fexit_bpf2bpf.c
index 7d3740d38965,a550dab9ba7a..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/fexit_bpf2bpf.c
+++ b/tools/testing/selftests/bpf/prog_tests/fexit_bpf2bpf.c
@@@ -103,11 -110,109 +103,116 @@@ static void test_target_yes_callees(voi
  	test_fexit_bpf2bpf_common("./fexit_bpf2bpf.o",
  				  "./test_pkt_access.o",
  				  ARRAY_SIZE(prog_name),
++<<<<<<< HEAD
 +				  prog_name);
++=======
+ 				  prog_name, true);
+ }
+ 
+ static void test_func_replace(void)
+ {
+ 	const char *prog_name[] = {
+ 		"fexit/test_pkt_access",
+ 		"fexit/test_pkt_access_subprog1",
+ 		"fexit/test_pkt_access_subprog2",
+ 		"fexit/test_pkt_access_subprog3",
+ 		"freplace/get_skb_len",
+ 		"freplace/get_skb_ifindex",
+ 		"freplace/get_constant",
+ 		"freplace/test_pkt_write_access_subprog",
+ 	};
+ 	test_fexit_bpf2bpf_common("./fexit_bpf2bpf.o",
+ 				  "./test_pkt_access.o",
+ 				  ARRAY_SIZE(prog_name),
+ 				  prog_name, true);
+ }
+ 
+ static void test_func_replace_verify(void)
+ {
+ 	const char *prog_name[] = {
+ 		"freplace/do_bind",
+ 	};
+ 	test_fexit_bpf2bpf_common("./freplace_connect4.o",
+ 				  "./connect4_prog.o",
+ 				  ARRAY_SIZE(prog_name),
+ 				  prog_name, false);
+ }
+ 
+ static void test_func_sockmap_update(void)
+ {
+ 	const char *prog_name[] = {
+ 		"freplace/cls_redirect",
+ 	};
+ 	test_fexit_bpf2bpf_common("./freplace_cls_redirect.o",
+ 				  "./test_cls_redirect.o",
+ 				  ARRAY_SIZE(prog_name),
+ 				  prog_name, false);
+ }
+ 
+ static void test_obj_load_failure_common(const char *obj_file,
+ 					  const char *target_obj_file)
+ 
+ {
+ 	/*
+ 	 * standalone test that asserts failure to load freplace prog
+ 	 * because of invalid return code.
+ 	 */
+ 	struct bpf_object *obj = NULL, *pkt_obj;
+ 	int err, pkt_fd;
+ 	__u32 duration = 0;
+ 
+ 	err = bpf_prog_load(target_obj_file, BPF_PROG_TYPE_UNSPEC,
+ 			    &pkt_obj, &pkt_fd);
+ 	/* the target prog should load fine */
+ 	if (CHECK(err, "tgt_prog_load", "file %s err %d errno %d\n",
+ 		  target_obj_file, err, errno))
+ 		return;
+ 	DECLARE_LIBBPF_OPTS(bpf_object_open_opts, opts,
+ 			    .attach_prog_fd = pkt_fd,
+ 			   );
+ 
+ 	obj = bpf_object__open_file(obj_file, &opts);
+ 	if (CHECK(IS_ERR_OR_NULL(obj), "obj_open",
+ 		  "failed to open %s: %ld\n", obj_file,
+ 		  PTR_ERR(obj)))
+ 		goto close_prog;
+ 
+ 	/* It should fail to load the program */
+ 	err = bpf_object__load(obj);
+ 	if (CHECK(!err, "bpf_obj_load should fail", "err %d\n", err))
+ 		goto close_prog;
+ 
+ close_prog:
+ 	if (!IS_ERR_OR_NULL(obj))
+ 		bpf_object__close(obj);
+ 	bpf_object__close(pkt_obj);
++>>>>>>> 1410620cf20e (selftests/bpf: Test for map update access from within EXT programs)
+ }
+ 
+ static void test_func_replace_return_code(void)
+ {
+ 	/* test invalid return code in the replaced program */
+ 	test_obj_load_failure_common("./freplace_connect_v4_prog.o",
+ 				     "./connect4_prog.o");
+ }
+ 
+ static void test_func_map_prog_compatibility(void)
+ {
+ 	/* test with spin lock map value in the replaced program */
+ 	test_obj_load_failure_common("./freplace_attach_probe.o",
+ 				     "./test_attach_probe.o");
  }
  
  void test_fexit_bpf2bpf(void)
  {
  	test_target_no_callees();
  	test_target_yes_callees();
++<<<<<<< HEAD
++=======
+ 	test_func_replace();
+ 	test_func_replace_verify();
+ 	test_func_sockmap_update();
+ 	test_func_replace_return_code();
+ 	test_func_map_prog_compatibility();
++>>>>>>> 1410620cf20e (selftests/bpf: Test for map update access from within EXT programs)
  }
* Unmerged path tools/testing/selftests/bpf/prog_tests/fexit_bpf2bpf.c
diff --git a/tools/testing/selftests/bpf/progs/freplace_attach_probe.c b/tools/testing/selftests/bpf/progs/freplace_attach_probe.c
new file mode 100644
index 000000000000..bb2a77c5b62b
--- /dev/null
+++ b/tools/testing/selftests/bpf/progs/freplace_attach_probe.c
@@ -0,0 +1,40 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2020 Facebook
+
+#include <linux/ptrace.h>
+#include <linux/bpf.h>
+#include <bpf/bpf_helpers.h>
+#include <bpf/bpf_tracing.h>
+
+#define VAR_NUM 2
+
+struct hmap_elem {
+	struct bpf_spin_lock lock;
+	int var[VAR_NUM];
+};
+
+struct {
+	__uint(type, BPF_MAP_TYPE_HASH);
+	__uint(max_entries, 1);
+	__type(key, __u32);
+	__type(value, struct hmap_elem);
+} hash_map SEC(".maps");
+
+SEC("freplace/handle_kprobe")
+int new_handle_kprobe(struct pt_regs *ctx)
+{
+	struct hmap_elem zero = {}, *val;
+	int key = 0;
+
+	val = bpf_map_lookup_elem(&hash_map, &key);
+	if (!val)
+		return 1;
+	/* spin_lock in hash map */
+	bpf_spin_lock(&val->lock);
+	val->var[0] = 99;
+	bpf_spin_unlock(&val->lock);
+
+	return 0;
+}
+
+char _license[] SEC("license") = "GPL";
diff --git a/tools/testing/selftests/bpf/progs/freplace_cls_redirect.c b/tools/testing/selftests/bpf/progs/freplace_cls_redirect.c
new file mode 100644
index 000000000000..68a5a9db928a
--- /dev/null
+++ b/tools/testing/selftests/bpf/progs/freplace_cls_redirect.c
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2020 Facebook
+
+#include <linux/stddef.h>
+#include <linux/bpf.h>
+#include <linux/pkt_cls.h>
+#include <bpf/bpf_endian.h>
+#include <bpf/bpf_helpers.h>
+
+struct bpf_map_def SEC("maps") sock_map = {
+	.type = BPF_MAP_TYPE_SOCKMAP,
+	.key_size = sizeof(int),
+	.value_size = sizeof(int),
+	.max_entries = 2,
+};
+
+SEC("freplace/cls_redirect")
+int freplace_cls_redirect_test(struct __sk_buff *skb)
+{
+	int ret = 0;
+	const int zero = 0;
+	struct bpf_sock *sk;
+
+	sk = bpf_map_lookup_elem(&sock_map, &zero);
+	if (!sk)
+		return TC_ACT_SHOT;
+
+	ret = bpf_map_update_elem(&sock_map, &zero, sk, 0);
+	bpf_sk_release(sk);
+
+	return ret == 0 ? TC_ACT_OK : TC_ACT_SHOT;
+}
+
+char _license[] SEC("license") = "GPL";
