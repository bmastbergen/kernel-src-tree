netfilter: nat: remove l3proto struct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit d6c4c8ffb5e54b0516742f3386ea9e329e019455
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d6c4c8ff.failed

All l3proto function pointers have been removed.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit d6c4c8ffb5e54b0516742f3386ea9e329e019455)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_nat_l3proto.h
#	net/netfilter/nf_nat_core.c
#	net/netfilter/nf_nat_proto.c
diff --cc include/net/netfilter/nf_nat_l3proto.h
index d300b8f03972,9a68f2b53a9e..000000000000
--- a/include/net/netfilter/nf_nat_l3proto.h
+++ b/include/net/netfilter/nf_nat_l3proto.h
@@@ -2,43 -2,12 +2,48 @@@
  #ifndef _NF_NAT_L3PROTO_H
  #define _NF_NAT_L3PROTO_H
  
++<<<<<<< HEAD
 +struct nf_nat_l4proto;
 +struct nf_nat_l3proto {
 +	u8	l3proto;
 +
 +	bool	(*in_range)(const struct nf_conntrack_tuple *t,
 +			    const struct nf_nat_range2 *range);
 +
 +	u32 	(*secure_port)(const struct nf_conntrack_tuple *t, __be16);
 +
 +	bool	(*manip_pkt)(struct sk_buff *skb,
 +			     unsigned int iphdroff,
 +			     const struct nf_nat_l4proto *l4proto,
 +			     const struct nf_conntrack_tuple *target,
 +			     enum nf_nat_manip_type maniptype);
 +
 +	void	(*csum_update)(struct sk_buff *skb, unsigned int iphdroff,
 +			       __sum16 *check,
 +			       const struct nf_conntrack_tuple *t,
 +			       enum nf_nat_manip_type maniptype);
 +
 +	void	(*csum_recalc)(struct sk_buff *skb, u8 proto,
 +			       void *data, __sum16 *check,
 +			       int datalen, int oldlen);
 +
 +	void	(*decode_session)(struct sk_buff *skb,
 +				  const struct nf_conn *ct,
 +				  enum ip_conntrack_dir dir,
 +				  unsigned long statusbit,
 +				  struct flowi *fl);
 +
 +	int	(*nlattr_to_range)(struct nlattr *tb[],
 +				   struct nf_nat_range2 *range);
 +};
- 
- int nf_nat_l3proto_register(const struct nf_nat_l3proto *);
- void nf_nat_l3proto_unregister(const struct nf_nat_l3proto *);
- const struct nf_nat_l3proto *__nf_nat_l3proto_find(u8 l3proto);
++=======
+ unsigned int nf_nat_manip_pkt(struct sk_buff *skb, struct nf_conn *ct,
+ 			      enum nf_nat_manip_type mtype,
+ 			      enum ip_conntrack_dir dir);
+ void nf_nat_csum_recalc(struct sk_buff *skb,
+ 			u8 nfproto, u8 proto, void *data, __sum16 *check,
+ 			int datalen, int oldlen);
++>>>>>>> d6c4c8ffb5e5 (netfilter: nat: remove l3proto struct)
  
  int nf_nat_icmp_reply_translation(struct sk_buff *skb, struct nf_conn *ct,
  				  enum ip_conntrack_info ctinfo,
diff --cc net/netfilter/nf_nat_core.c
index 275265d75be2,d9b70e560007..000000000000
--- a/net/netfilter/nf_nat_core.c
+++ b/net/netfilter/nf_nat_core.c
@@@ -37,10 -35,6 +37,13 @@@
  static spinlock_t nf_nat_locks[CONNTRACK_LOCKS];
  
  static DEFINE_MUTEX(nf_nat_proto_mutex);
++<<<<<<< HEAD
 +static const struct nf_nat_l3proto __rcu *nf_nat_l3protos[NFPROTO_NUMPROTO]
 +						__read_mostly;
 +static const struct nf_nat_l4proto __rcu **nf_nat_l4protos[NFPROTO_NUMPROTO]
 +						__read_mostly;
++=======
++>>>>>>> d6c4c8ffb5e5 (netfilter: nat: remove l3proto struct)
  static unsigned int nat_net_id __read_mostly;
  
  static struct hlist_head *nf_nat_bysource __read_mostly;
@@@ -62,23 -56,75 +65,26 @@@ struct nat_net 
  	struct nf_nat_hooks_net nat_proto_net[NFPROTO_NUMPROTO];
  };
  
 -#ifdef CONFIG_XFRM
 -static void nf_nat_ipv4_decode_session(struct sk_buff *skb,
 -				       const struct nf_conn *ct,
 -				       enum ip_conntrack_dir dir,
 -				       unsigned long statusbit,
 -				       struct flowi *fl)
++<<<<<<< HEAD
 +inline const struct nf_nat_l3proto *
 +__nf_nat_l3proto_find(u8 family)
  {
 -	const struct nf_conntrack_tuple *t = &ct->tuplehash[dir].tuple;
 -	struct flowi4 *fl4 = &fl->u.ip4;
 -
 -	if (ct->status & statusbit) {
 -		fl4->daddr = t->dst.u3.ip;
 -		if (t->dst.protonum == IPPROTO_TCP ||
 -		    t->dst.protonum == IPPROTO_UDP ||
 -		    t->dst.protonum == IPPROTO_UDPLITE ||
 -		    t->dst.protonum == IPPROTO_DCCP ||
 -		    t->dst.protonum == IPPROTO_SCTP)
 -			fl4->fl4_dport = t->dst.u.all;
 -	}
 -
 -	statusbit ^= IPS_NAT_MASK;
 -
 -	if (ct->status & statusbit) {
 -		fl4->saddr = t->src.u3.ip;
 -		if (t->dst.protonum == IPPROTO_TCP ||
 -		    t->dst.protonum == IPPROTO_UDP ||
 -		    t->dst.protonum == IPPROTO_UDPLITE ||
 -		    t->dst.protonum == IPPROTO_DCCP ||
 -		    t->dst.protonum == IPPROTO_SCTP)
 -			fl4->fl4_sport = t->src.u.all;
 -	}
 +	return rcu_dereference(nf_nat_l3protos[family]);
  }
  
 -static void nf_nat_ipv6_decode_session(struct sk_buff *skb,
 -				       const struct nf_conn *ct,
 -				       enum ip_conntrack_dir dir,
 -				       unsigned long statusbit,
 -				       struct flowi *fl)
 +inline const struct nf_nat_l4proto *
 +__nf_nat_l4proto_find(u8 family, u8 protonum)
  {
 -#if IS_ENABLED(CONFIG_IPV6)
 -	const struct nf_conntrack_tuple *t = &ct->tuplehash[dir].tuple;
 -	struct flowi6 *fl6 = &fl->u.ip6;
 -
 -	if (ct->status & statusbit) {
 -		fl6->daddr = t->dst.u3.in6;
 -		if (t->dst.protonum == IPPROTO_TCP ||
 -		    t->dst.protonum == IPPROTO_UDP ||
 -		    t->dst.protonum == IPPROTO_UDPLITE ||
 -		    t->dst.protonum == IPPROTO_DCCP ||
 -		    t->dst.protonum == IPPROTO_SCTP)
 -			fl6->fl6_dport = t->dst.u.all;
 -	}
 -
 -	statusbit ^= IPS_NAT_MASK;
 -
 -	if (ct->status & statusbit) {
 -		fl6->saddr = t->src.u3.in6;
 -		if (t->dst.protonum == IPPROTO_TCP ||
 -		    t->dst.protonum == IPPROTO_UDP ||
 -		    t->dst.protonum == IPPROTO_UDPLITE ||
 -		    t->dst.protonum == IPPROTO_DCCP ||
 -		    t->dst.protonum == IPPROTO_SCTP)
 -			fl6->fl6_sport = t->src.u.all;
 -	}
 -#endif
 +	return rcu_dereference(nf_nat_l4protos[family][protonum]);
  }
 +EXPORT_SYMBOL_GPL(__nf_nat_l4proto_find);
  
++=======
++>>>>>>> d6c4c8ffb5e5 (netfilter: nat: remove l3proto struct)
 +#ifdef CONFIG_XFRM
  static void __nf_nat_decode_session(struct sk_buff *skb, struct flowi *fl)
  {
 +	const struct nf_nat_l3proto *l3proto;
  	const struct nf_conn *ct;
  	enum ip_conntrack_info ctinfo;
  	enum ip_conntrack_dir dir;
@@@ -667,124 -841,6 +673,127 @@@ static int nf_nat_proto_clean(struct nf
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void nf_nat_l4proto_clean(u8 l3proto, u8 l4proto)
 +{
 +	struct nf_nat_proto_clean clean = {
 +		.l3proto = l3proto,
 +		.l4proto = l4proto,
 +	};
 +
 +	nf_ct_iterate_destroy(nf_nat_proto_remove, &clean);
 +}
 +
 +static void nf_nat_l3proto_clean(u8 l3proto)
 +{
 +	struct nf_nat_proto_clean clean = {
 +		.l3proto = l3proto,
 +	};
 +
 +	nf_ct_iterate_destroy(nf_nat_proto_remove, &clean);
 +}
 +
 +/* Protocol registration. */
 +int nf_nat_l4proto_register(u8 l3proto, const struct nf_nat_l4proto *l4proto)
 +{
 +	const struct nf_nat_l4proto **l4protos;
 +	unsigned int i;
 +	int ret = 0;
 +
 +	mutex_lock(&nf_nat_proto_mutex);
 +	if (nf_nat_l4protos[l3proto] == NULL) {
 +		l4protos = kmalloc_array(IPPROTO_MAX,
 +					 sizeof(struct nf_nat_l4proto *),
 +					 GFP_KERNEL);
 +		if (l4protos == NULL) {
 +			ret = -ENOMEM;
 +			goto out;
 +		}
 +
 +		for (i = 0; i < IPPROTO_MAX; i++)
 +			RCU_INIT_POINTER(l4protos[i], &nf_nat_l4proto_unknown);
 +
 +		/* Before making proto_array visible to lockless readers,
 +		 * we must make sure its content is committed to memory.
 +		 */
 +		smp_wmb();
 +
 +		nf_nat_l4protos[l3proto] = l4protos;
 +	}
 +
 +	if (rcu_dereference_protected(
 +			nf_nat_l4protos[l3proto][l4proto->l4proto],
 +			lockdep_is_held(&nf_nat_proto_mutex)
 +			) != &nf_nat_l4proto_unknown) {
 +		ret = -EBUSY;
 +		goto out;
 +	}
 +	RCU_INIT_POINTER(nf_nat_l4protos[l3proto][l4proto->l4proto], l4proto);
 + out:
 +	mutex_unlock(&nf_nat_proto_mutex);
 +	return ret;
 +}
 +EXPORT_SYMBOL_GPL(nf_nat_l4proto_register);
 +
 +/* No one stores the protocol anywhere; simply delete it. */
 +void nf_nat_l4proto_unregister(u8 l3proto, const struct nf_nat_l4proto *l4proto)
 +{
 +	mutex_lock(&nf_nat_proto_mutex);
 +	RCU_INIT_POINTER(nf_nat_l4protos[l3proto][l4proto->l4proto],
 +			 &nf_nat_l4proto_unknown);
 +	mutex_unlock(&nf_nat_proto_mutex);
 +	synchronize_rcu();
 +
 +	nf_nat_l4proto_clean(l3proto, l4proto->l4proto);
 +}
 +EXPORT_SYMBOL_GPL(nf_nat_l4proto_unregister);
 +
 +int nf_nat_l3proto_register(const struct nf_nat_l3proto *l3proto)
 +{
 +	int err;
 +
 +	err = nf_ct_l3proto_try_module_get(l3proto->l3proto);
 +	if (err < 0)
 +		return err;
 +
 +	mutex_lock(&nf_nat_proto_mutex);
 +	RCU_INIT_POINTER(nf_nat_l4protos[l3proto->l3proto][IPPROTO_TCP],
 +			 &nf_nat_l4proto_tcp);
 +	RCU_INIT_POINTER(nf_nat_l4protos[l3proto->l3proto][IPPROTO_UDP],
 +			 &nf_nat_l4proto_udp);
 +#ifdef CONFIG_NF_NAT_PROTO_DCCP
 +	RCU_INIT_POINTER(nf_nat_l4protos[l3proto->l3proto][IPPROTO_DCCP],
 +			 &nf_nat_l4proto_dccp);
 +#endif
 +#ifdef CONFIG_NF_NAT_PROTO_SCTP
 +	RCU_INIT_POINTER(nf_nat_l4protos[l3proto->l3proto][IPPROTO_SCTP],
 +			 &nf_nat_l4proto_sctp);
 +#endif
 +#ifdef CONFIG_NF_NAT_PROTO_UDPLITE
 +	RCU_INIT_POINTER(nf_nat_l4protos[l3proto->l3proto][IPPROTO_UDPLITE],
 +			 &nf_nat_l4proto_udplite);
 +#endif
 +	mutex_unlock(&nf_nat_proto_mutex);
 +
 +	RCU_INIT_POINTER(nf_nat_l3protos[l3proto->l3proto], l3proto);
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(nf_nat_l3proto_register);
 +
 +void nf_nat_l3proto_unregister(const struct nf_nat_l3proto *l3proto)
 +{
 +	mutex_lock(&nf_nat_proto_mutex);
 +	RCU_INIT_POINTER(nf_nat_l3protos[l3proto->l3proto], NULL);
 +	mutex_unlock(&nf_nat_proto_mutex);
 +	synchronize_rcu();
 +
 +	nf_nat_l3proto_clean(l3proto->l3proto);
 +	nf_ct_l3proto_module_put(l3proto->l3proto);
 +}
 +EXPORT_SYMBOL_GPL(nf_nat_l3proto_unregister);
 +
++=======
++>>>>>>> d6c4c8ffb5e5 (netfilter: nat: remove l3proto struct)
  /* No one using conntrack by the time this called. */
  static void nf_nat_cleanup_conntrack(struct nf_conn *ct)
  {
* Unmerged path net/netfilter/nf_nat_proto.c
* Unmerged path include/net/netfilter/nf_nat_l3proto.h
* Unmerged path net/netfilter/nf_nat_core.c
* Unmerged path net/netfilter/nf_nat_proto.c
