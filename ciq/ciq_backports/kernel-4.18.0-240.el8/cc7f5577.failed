KVM: SVM: Inhibit APIC virtualization for X2APIC guest

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Oliver Upton <oupton@google.com>
commit cc7f5577adfc766de8613b71e9ae52c053fcca01
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/cc7f5577.failed

The AVIC does not support guest use of the x2APIC interface. Currently,
KVM simply chooses to squash the x2APIC feature in the guest's CPUID
If the AVIC is enabled. Doing so prevents KVM from running a guest
with greater than 255 vCPUs, as such a guest necessitates the use
of the x2APIC interface.

Instead, inhibit AVIC enablement on a per-VM basis whenever the x2APIC
feature is set in the guest's CPUID.

	Signed-off-by: Oliver Upton <oupton@google.com>
	Reviewed-by: Jim Mattson <jmattson@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit cc7f5577adfc766de8613b71e9ae52c053fcca01)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/svm.c
diff --cc arch/x86/include/asm/kvm_host.h
index e2bd7dd0377e,f58861e2ece5..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -882,6 -881,13 +882,16 @@@ enum kvm_irqchip_mode 
  	KVM_IRQCHIP_SPLIT,        /* created with KVM_CAP_SPLIT_IRQCHIP */
  };
  
++<<<<<<< HEAD
++=======
+ #define APICV_INHIBIT_REASON_DISABLE    0
+ #define APICV_INHIBIT_REASON_HYPERV     1
+ #define APICV_INHIBIT_REASON_NESTED     2
+ #define APICV_INHIBIT_REASON_IRQWIN     3
+ #define APICV_INHIBIT_REASON_PIT_REINJ  4
+ #define APICV_INHIBIT_REASON_X2APIC	5
+ 
++>>>>>>> cc7f5577adfc (KVM: SVM: Inhibit APIC virtualization for X2APIC guest)
  struct kvm_arch {
  	unsigned long n_used_mmu_pages;
  	unsigned long n_requested_mmu_pages;
diff --cc arch/x86/kvm/svm.c
index 2ed3eaf9120c,0d417276653b..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -6041,7 -6014,21 +6041,25 @@@ static void svm_cpuid_update(struct kvm
  	if (!kvm_vcpu_apicv_active(vcpu))
  		return;
  
++<<<<<<< HEAD
 +	guest_cpuid_clear(vcpu, X86_FEATURE_X2APIC);
++=======
+ 	/*
+ 	 * AVIC does not work with an x2APIC mode guest. If the X2APIC feature
+ 	 * is exposed to the guest, disable AVIC.
+ 	 */
+ 	if (guest_cpuid_has(vcpu, X86_FEATURE_X2APIC))
+ 		kvm_request_apicv_update(vcpu->kvm, false,
+ 					 APICV_INHIBIT_REASON_X2APIC);
+ 
+ 	/*
+ 	 * Currently, AVIC does not work with nested virtualization.
+ 	 * So, we disable AVIC when cpuid for SVM is set in the L1 guest.
+ 	 */
+ 	if (nested && guest_cpuid_has(vcpu, X86_FEATURE_SVM))
+ 		kvm_request_apicv_update(vcpu->kvm, false,
+ 					 APICV_INHIBIT_REASON_NESTED);
++>>>>>>> cc7f5577adfc (KVM: SVM: Inhibit APIC virtualization for X2APIC guest)
  }
  
  #define F feature_bit
@@@ -7371,6 -7353,23 +7385,26 @@@ static bool svm_apic_init_signal_blocke
  		   (svm->vmcb->control.intercept & (1ULL << INTERCEPT_INIT));
  }
  
++<<<<<<< HEAD
++=======
+ static bool svm_check_apicv_inhibit_reasons(ulong bit)
+ {
+ 	ulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |
+ 			  BIT(APICV_INHIBIT_REASON_HYPERV) |
+ 			  BIT(APICV_INHIBIT_REASON_NESTED) |
+ 			  BIT(APICV_INHIBIT_REASON_IRQWIN) |
+ 			  BIT(APICV_INHIBIT_REASON_PIT_REINJ) |
+ 			  BIT(APICV_INHIBIT_REASON_X2APIC);
+ 
+ 	return supported & BIT(bit);
+ }
+ 
+ static void svm_pre_update_apicv_exec_ctrl(struct kvm *kvm, bool activate)
+ {
+ 	avic_update_access_page(kvm, activate);
+ }
+ 
++>>>>>>> cc7f5577adfc (KVM: SVM: Inhibit APIC virtualization for X2APIC guest)
  static struct kvm_x86_ops svm_x86_ops __ro_after_init = {
  	.cpu_has_kvm_support = has_svm,
  	.disabled_by_bios = is_disabled,
* Unmerged path arch/x86/include/asm/kvm_host.h
* Unmerged path arch/x86/kvm/svm.c
