perf trace: Support tracepoint dynamic char arrays

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit c5e006cdbd278a8a5185a3a56acdba161cf159ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c5e006cd.failed

Things like:

  # grep __data_loc /sys/kernel/debug/tracing/events/sched/sched_process_exec/format
	field:__data_loc char[] filename;	offset:8;	size:4;	signed:1;
  #

That, at that offset (8) and with that size(8) have an integer that
contains the real length and offset for the contents of that array.

Now this works:

  # perf trace --max-events 1 -e sched:*exec -a
     0.000 sed/19441 sched:sched_process_exec(filename: "/usr/bin/sync", pid: 19441 (sync), old_pid: 19441 (sync))
  #

As when using the libtraceevent based beautifier:

  # perf trace --libtraceevent --max-events 1 -e sched:*exec -a
     0.000 sync/19463 sched:sched_process_exec(filename=/usr/bin/sync pid=19463 old_pid=19463)
  #

I.e. that 'filename' is implemented as a dynamic char array.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Luis Cláudio Gonçalves <lclaudio@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
Link: https://lkml.kernel.org/n/tip-950p0m842fe6n7sxsdwqj5i2@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit c5e006cdbd278a8a5185a3a56acdba161cf159ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-trace.c
diff --cc tools/perf/builtin-trace.c
index 048db06ff0b7,907eaf316f5b..000000000000
--- a/tools/perf/builtin-trace.c
+++ b/tools/perf/builtin-trace.c
@@@ -2485,7 -2497,81 +2485,85 @@@ static void bpf_output__fprintf(struct 
  	++trace->nr_events_printed;
  }
  
++<<<<<<< HEAD
 +static int trace__event_handler(struct trace *trace, struct perf_evsel *evsel,
++=======
+ static size_t trace__fprintf_tp_fields(struct trace *trace, struct evsel *evsel, struct perf_sample *sample,
+ 				       struct thread *thread, void *augmented_args, int augmented_args_size)
+ {
+ 	char bf[2048];
+ 	size_t size = sizeof(bf);
+ 	struct tep_format_field *field = evsel->tp_format->format.fields;
+ 	struct syscall_arg_fmt *arg = evsel->priv;
+ 	size_t printed = 0;
+ 	unsigned long val;
+ 	u8 bit = 1;
+ 	struct syscall_arg syscall_arg = {
+ 		.augmented = {
+ 			.size = augmented_args_size,
+ 			.args = augmented_args,
+ 		},
+ 		.idx	= 0,
+ 		.mask	= 0,
+ 		.trace  = trace,
+ 		.thread = thread,
+ 		.show_string_prefix = trace->show_string_prefix,
+ 	};
+ 
+ 	for (; field && arg; field = field->next, ++syscall_arg.idx, bit <<= 1, ++arg) {
+ 		if (syscall_arg.mask & bit)
+ 			continue;
+ 
+ 		syscall_arg.len = 0;
+ 		syscall_arg.fmt = arg;
+ 		if (field->flags & TEP_FIELD_IS_ARRAY) {
+ 			int offset = field->offset;
+ 
+ 			if (field->flags & TEP_FIELD_IS_DYNAMIC) {
+ 				offset = format_field__intval(field, sample, evsel->needs_swap);
+ 				syscall_arg.len = offset >> 16;
+ 				offset &= 0xffff;
+ 			}
+ 
+ 			val = (uintptr_t)(sample->raw_data + offset);
+ 		} else
+ 			val = format_field__intval(field, sample, evsel->needs_swap);
+ 		/*
+ 		 * Some syscall args need some mask, most don't and
+ 		 * return val untouched.
+ 		 */
+ 		val = syscall_arg_fmt__mask_val(arg, &syscall_arg, val);
+ 
+ 		/*
+ 		 * Suppress this argument if its value is zero and
+ 		 * and we don't have a string associated in an
+ 		 * strarray for it.
+ 		 */
+ 		if (val == 0 &&
+ 		    !trace->show_zeros &&
+ 		    !((arg->show_zero ||
+ 		       arg->scnprintf == SCA_STRARRAY ||
+ 		       arg->scnprintf == SCA_STRARRAYS) &&
+ 		      arg->parm))
+ 			continue;
+ 
+ 		printed += scnprintf(bf + printed, size - printed, "%s", printed ? ", " : "");
+ 
+ 		/*
+ 		 * XXX Perhaps we should have a show_tp_arg_names,
+ 		 * leaving show_arg_names just for syscalls?
+ 		 */
+ 		if (1 || trace->show_arg_names)
+ 			printed += scnprintf(bf + printed, size - printed, "%s: ", field->name);
+ 
+ 		printed += syscall_arg_fmt__scnprintf_val(arg, bf + printed, size - printed, &syscall_arg, val);
+ 	}
+ 
+ 	return printed + fprintf(trace->output, "%s", bf);
+ }
+ 
+ static int trace__event_handler(struct trace *trace, struct evsel *evsel,
++>>>>>>> c5e006cdbd27 (perf trace: Support tracepoint dynamic char arrays)
  				union perf_event *event __maybe_unused,
  				struct perf_sample *sample)
  {
* Unmerged path tools/perf/builtin-trace.c
diff --git a/tools/perf/trace/beauty/beauty.h b/tools/perf/trace/beauty/beauty.h
index 6b4fd3f0c0be..abb2ad664ca0 100644
--- a/tools/perf/trace/beauty/beauty.h
+++ b/tools/perf/trace/beauty/beauty.h
@@ -87,6 +87,7 @@ struct syscall_arg_fmt;
 
 /**
  * @val: value of syscall argument being formatted
+ * @len: for tracepoint dynamic arrays, if fmt->nr_entries == 0, then its not a fixed array, look at arg->len
  * @args: All the args, use syscall_args__val(arg, nth) to access one
  * @augmented_args: Extra data that can be collected, for instance, with eBPF for expanding the pathname for open, etc
  * @augmented_args_size: augmented_args total payload size
@@ -109,6 +110,7 @@ struct syscall_arg {
 	struct thread *thread;
 	struct trace  *trace;
 	void	      *parm;
+	u16	      len;
 	u8	      idx;
 	u8	      mask;
 	bool	      show_string_prefix;
