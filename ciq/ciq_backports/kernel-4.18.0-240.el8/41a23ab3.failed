KVM: selftests: do not substitute SVM/VMX check with KVM_CAP_NESTED_STATE check

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 41a23ab336fbf4d01036e1aa6369d7364aa29b4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/41a23ab3.failed

state_test/smm_test use KVM_CAP_NESTED_STATE check as an indicator for
nested VMX/SVM presence and this is incorrect. Check for the required
features dirrectly.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Message-Id: <20200610135847.754289-2-vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 41a23ab336fbf4d01036e1aa6369d7364aa29b4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/lib/x86_64/svm.c
#	tools/testing/selftests/kvm/lib/x86_64/vmx.c
#	tools/testing/selftests/kvm/x86_64/smm_test.c
#	tools/testing/selftests/kvm/x86_64/state_test.c
diff --cc tools/testing/selftests/kvm/lib/x86_64/svm.c
index 6e05a8fc3fe0,3a5c72ed2b79..000000000000
--- a/tools/testing/selftests/kvm/lib/x86_64/svm.c
+++ b/tools/testing/selftests/kvm/lib/x86_64/svm.c
@@@ -153,8 -153,13 +153,18 @@@ bool nested_svm_supported(void
  	struct kvm_cpuid_entry2 *entry =
  		kvm_get_supported_cpuid_entry(0x80000001);
  
++<<<<<<< HEAD
 +	if (!(entry->ecx & CPUID_SVM)) {
 +		fprintf(stderr, "nested SVM not enabled, skipping test\n");
++=======
+ 	return entry->ecx & CPUID_SVM;
+ }
+ 
+ void nested_svm_check_supported(void)
+ {
+ 	if (!nested_svm_supported()) {
+ 		print_skip("nested SVM not enabled");
++>>>>>>> 41a23ab336fb (KVM: selftests: do not substitute SVM/VMX check with KVM_CAP_NESTED_STATE check)
  		exit(KSFT_SKIP);
  	}
  }
diff --cc tools/testing/selftests/kvm/lib/x86_64/vmx.c
index 742b1962824c,f1e00d43eea2..000000000000
--- a/tools/testing/selftests/kvm/lib/x86_64/vmx.c
+++ b/tools/testing/selftests/kvm/lib/x86_64/vmx.c
@@@ -384,8 -383,13 +384,18 @@@ bool nested_vmx_supported(void
  {
  	struct kvm_cpuid_entry2 *entry = kvm_get_supported_cpuid_entry(1);
  
++<<<<<<< HEAD
 +	if (!(entry->ecx & CPUID_VMX)) {
 +		fprintf(stderr, "nested VMX not enabled, skipping test\n");
++=======
+ 	return entry->ecx & CPUID_VMX;
+ }
+ 
+ void nested_vmx_check_supported(void)
+ {
+ 	if (!nested_vmx_supported()) {
+ 		print_skip("nested VMX not enabled");
++>>>>>>> 41a23ab336fb (KVM: selftests: do not substitute SVM/VMX check with KVM_CAP_NESTED_STATE check)
  		exit(KSFT_SKIP);
  	}
  }
diff --cc tools/testing/selftests/kvm/x86_64/smm_test.c
index 01a9d98e977a,36314152943d..000000000000
--- a/tools/testing/selftests/kvm/x86_64/smm_test.c
+++ b/tools/testing/selftests/kvm/x86_64/smm_test.c
@@@ -118,16 -118,17 +118,24 @@@ int main(int argc, char *argv[]
  	vcpu_set_msr(vm, VCPU_ID, MSR_IA32_SMBASE, SMRAM_GPA);
  
  	if (kvm_check_cap(KVM_CAP_NESTED_STATE)) {
- 		if (kvm_get_supported_cpuid_entry(0x80000001)->ecx & CPUID_SVM)
+ 		if (nested_svm_supported())
  			vcpu_alloc_svm(vm, &nested_gva);
- 		else
+ 		else if (nested_vmx_supported())
  			vcpu_alloc_vmx(vm, &nested_gva);
++<<<<<<< HEAD
 +		vcpu_args_set(vm, VCPU_ID, 1, nested_gva);
 +	} else {
 +		printf("will skip SMM test with VMX enabled\n");
 +		vcpu_args_set(vm, VCPU_ID, 1, 0);
++=======
++>>>>>>> 41a23ab336fb (KVM: selftests: do not substitute SVM/VMX check with KVM_CAP_NESTED_STATE check)
  	}
  
+ 	if (!nested_gva)
+ 		pr_info("will skip SMM test with VMX enabled\n");
+ 
+ 	vcpu_args_set(vm, VCPU_ID, 1, nested_gva);
+ 
  	for (stage = 1;; stage++) {
  		_vcpu_run(vm, VCPU_ID);
  		TEST_ASSERT(run->exit_reason == KVM_EXIT_IO,
diff --cc tools/testing/selftests/kvm/x86_64/state_test.c
index 5f3b8f364376,f6c8b9042f8a..000000000000
--- a/tools/testing/selftests/kvm/x86_64/state_test.c
+++ b/tools/testing/selftests/kvm/x86_64/state_test.c
@@@ -172,16 -171,17 +172,24 @@@ int main(int argc, char *argv[]
  	vcpu_regs_get(vm, VCPU_ID, &regs1);
  
  	if (kvm_check_cap(KVM_CAP_NESTED_STATE)) {
- 		if (kvm_get_supported_cpuid_entry(0x80000001)->ecx & CPUID_SVM)
+ 		if (nested_svm_supported())
  			vcpu_alloc_svm(vm, &nested_gva);
- 		else
+ 		else if (nested_vmx_supported())
  			vcpu_alloc_vmx(vm, &nested_gva);
++<<<<<<< HEAD
 +		vcpu_args_set(vm, VCPU_ID, 1, nested_gva);
 +	} else {
 +		printf("will skip nested state checks\n");
 +		vcpu_args_set(vm, VCPU_ID, 1, 0);
++=======
++>>>>>>> 41a23ab336fb (KVM: selftests: do not substitute SVM/VMX check with KVM_CAP_NESTED_STATE check)
  	}
  
+ 	if (!nested_gva)
+ 		pr_info("will skip nested state checks\n");
+ 
+ 	vcpu_args_set(vm, VCPU_ID, 1, nested_gva);
+ 
  	for (stage = 1;; stage++) {
  		_vcpu_run(vm, VCPU_ID);
  		TEST_ASSERT(run->exit_reason == KVM_EXIT_IO,
diff --git a/tools/testing/selftests/kvm/include/x86_64/svm_util.h b/tools/testing/selftests/kvm/include/x86_64/svm_util.h
index 674151d24fcf..b7531c83b8ae 100644
--- a/tools/testing/selftests/kvm/include/x86_64/svm_util.h
+++ b/tools/testing/selftests/kvm/include/x86_64/svm_util.h
@@ -33,6 +33,7 @@ struct svm_test_data {
 struct svm_test_data *vcpu_alloc_svm(struct kvm_vm *vm, vm_vaddr_t *p_svm_gva);
 void generic_svm_setup(struct svm_test_data *svm, void *guest_rip, void *guest_rsp);
 void run_guest(struct vmcb *vmcb, uint64_t vmcb_gpa);
+bool nested_svm_supported(void);
 void nested_svm_check_supported(void);
 
 static inline bool cpu_has_svm(void)
diff --git a/tools/testing/selftests/kvm/include/x86_64/vmx.h b/tools/testing/selftests/kvm/include/x86_64/vmx.h
index 433c43cce2ea..110db040156b 100644
--- a/tools/testing/selftests/kvm/include/x86_64/vmx.h
+++ b/tools/testing/selftests/kvm/include/x86_64/vmx.h
@@ -582,6 +582,7 @@ bool prepare_for_vmx_operation(struct vmx_pages *vmx);
 void prepare_vmcs(struct vmx_pages *vmx, void *guest_rip, void *guest_rsp);
 bool load_vmcs(struct vmx_pages *vmx);
 
+bool nested_vmx_supported(void);
 void nested_vmx_check_supported(void);
 
 void nested_pg_map(struct vmx_pages *vmx, struct kvm_vm *vm,
* Unmerged path tools/testing/selftests/kvm/lib/x86_64/svm.c
* Unmerged path tools/testing/selftests/kvm/lib/x86_64/vmx.c
* Unmerged path tools/testing/selftests/kvm/x86_64/smm_test.c
* Unmerged path tools/testing/selftests/kvm/x86_64/state_test.c
