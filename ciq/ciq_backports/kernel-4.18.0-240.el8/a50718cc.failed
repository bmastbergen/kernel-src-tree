KVM: nSVM: Expose SVM features to L1 iff nested is enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit a50718cc3f43f12e6e33b098b5e2a9eb19f13158
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a50718cc.failed

Set SVM feature bits in KVM capabilities if and only if nested=true, KVM
shouldn't advertise features that realistically can't be used.  Use
kvm_cpu_cap_has(X86_FEATURE_SVM) to indirectly query "nested" in
svm_set_supported_cpuid() in anticipation of moving CPUID 0x8000000A
adjustments into common x86 code.

	Suggested-by: Paolo Bonzini <pbonzini@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit a50718cc3f43f12e6e33b098b5e2a9eb19f13158)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm.c
diff --cc arch/x86/kvm/svm.c
index 720353d5a356,76a480a37f1d..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -1372,6 -1367,27 +1372,30 @@@ static void svm_hardware_teardown(void
  	iopm_base = 0;
  }
  
++<<<<<<< HEAD
++=======
+ static __init void svm_set_cpu_caps(void)
+ {
+ 	kvm_set_cpu_caps();
+ 
+ 	/* CPUID 0x80000001 and 0x8000000A (SVM features) */
+ 	if (nested) {
+ 		kvm_cpu_cap_set(X86_FEATURE_SVM);
+ 
+ 		if (boot_cpu_has(X86_FEATURE_NRIPS))
+ 			kvm_cpu_cap_set(X86_FEATURE_NRIPS);
+ 
+ 		if (npt_enabled)
+ 			kvm_cpu_cap_set(X86_FEATURE_NPT);
+ 	}
+ 
+ 	/* CPUID 0x80000008 */
+ 	if (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) ||
+ 	    boot_cpu_has(X86_FEATURE_AMD_SSBD))
+ 		kvm_cpu_cap_set(X86_FEATURE_VIRT_SSBD);
+ }
+ 
++>>>>>>> a50718cc3f43 (KVM: nSVM: Expose SVM features to L1 iff nested is enabled)
  static __init int svm_hardware_setup(void)
  {
  	int cpu;
@@@ -6036,28 -6034,31 +6060,32 @@@ static void svm_cpuid_update(struct kvm
  	if (!kvm_vcpu_apicv_active(vcpu))
  		return;
  
 -	/*
 -	 * AVIC does not work with an x2APIC mode guest. If the X2APIC feature
 -	 * is exposed to the guest, disable AVIC.
 -	 */
 -	if (guest_cpuid_has(vcpu, X86_FEATURE_X2APIC))
 -		kvm_request_apicv_update(vcpu->kvm, false,
 -					 APICV_INHIBIT_REASON_X2APIC);
 -
 -	/*
 -	 * Currently, AVIC does not work with nested virtualization.
 -	 * So, we disable AVIC when cpuid for SVM is set in the L1 guest.
 -	 */
 -	if (nested && guest_cpuid_has(vcpu, X86_FEATURE_SVM))
 -		kvm_request_apicv_update(vcpu->kvm, false,
 -					 APICV_INHIBIT_REASON_NESTED);
 +	guest_cpuid_clear(vcpu, X86_FEATURE_X2APIC);
  }
  
 -static void svm_set_supported_cpuid(struct kvm_cpuid_entry2 *entry)
 +#define F feature_bit
 +
 +static void svm_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
  {
 -	switch (entry->function) {
 +	switch (func) {
 +	case 0x1:
 +		if (avic)
 +			entry->ecx &= ~F(X2APIC);
 +		break;
 +	case 0x80000001:
 +		if (nested)
 +			entry->ecx |= (1 << 2); /* Set SVM bit */
 +		break;
 +	case 0x80000008:
 +		if (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) ||
 +		     boot_cpu_has(X86_FEATURE_AMD_SSBD))
 +			entry->ebx |= F(VIRT_SSBD);
 +		break;
  	case 0x8000000A:
+ 		if (!kvm_cpu_cap_has(X86_FEATURE_SVM)) {
+ 			entry->eax = entry->ebx = entry->ecx = entry->edx = 0;
+ 			break;
+ 		}
  		entry->eax = 1; /* SVM revision 1 */
  		entry->ebx = 8; /* Lets support 8 ASIDs in case we add proper
  				   ASID emulation to nested SVM */
* Unmerged path arch/x86/kvm/svm.c
