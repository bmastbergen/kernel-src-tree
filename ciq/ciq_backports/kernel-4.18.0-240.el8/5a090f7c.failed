powerpc/pseries: PCIE PHB reset

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Wen Xiong <wenxiong@linux.vnet.ibm.com>
commit 5a090f7c363fdc09b99222eae679506a58e7cc68
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5a090f7c.failed

Several device drivers hit EEH(Extended Error handling) when
triggering kdump on Pseries PowerVM. This patch implemented a reset of
the PHBs in pci general code when triggering kdump. PHB reset stop all
PCI transactions from normal kernel. We have tested the patch in
several enviroments:
  - direct slot adapters
  - adapters under the switch
  - a VF adapter in PowerVM
  - a VF adapter/adapter in KVM guest.

	Signed-off-by: Wen Xiong <wenxiong@linux.vnet.ibm.com>
[mpe: Fix broken whitespace, subject & SOB formatting]
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/1594651173-32166-1-git-send-email-wenxiong@linux.vnet.ibm.com
(cherry picked from commit 5a090f7c363fdc09b99222eae679506a58e7cc68)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/pseries/eeh_pseries.c
diff --cc arch/powerpc/platforms/pseries/eeh_pseries.c
index a11b447e14ca,47760fb515cc..000000000000
--- a/arch/powerpc/platforms/pseries/eeh_pseries.c
+++ b/arch/powerpc/platforms/pseries/eeh_pseries.c
@@@ -90,9 -78,155 +91,155 @@@ void pseries_pcibios_bus_add_device(str
  		eeh_add_to_parent_pe(edev);   /* Add as VF PE type */
  	}
  #endif
 -	eeh_probe_device(pdev);
 +	eeh_add_device_late(pdev);
  }
  
+ 
+ /**
+  * pseries_eeh_get_config_addr - Retrieve config address
+  *
+  * Retrieve the assocated config address. Actually, there're 2 RTAS
+  * function calls dedicated for the purpose. We need implement
+  * it through the new function and then the old one. Besides,
+  * you should make sure the config address is figured out from
+  * FDT node before calling the function.
+  *
+  * It's notable that zero'ed return value means invalid PE config
+  * address.
+  */
+ static int pseries_eeh_get_config_addr(struct pci_controller *phb, int config_addr)
+ {
+ 	int ret = 0;
+ 	int rets[3];
+ 
+ 	if (ibm_get_config_addr_info2 != RTAS_UNKNOWN_SERVICE) {
+ 		/*
+ 		 * First of all, we need to make sure there has one PE
+ 		 * associated with the device. Otherwise, PE address is
+ 		 * meaningless.
+ 		 */
+ 		ret = rtas_call(ibm_get_config_addr_info2, 4, 2, rets,
+ 				config_addr, BUID_HI(phb->buid),
+ 				BUID_LO(phb->buid), 1);
+ 		if (ret || (rets[0] == 0))
+ 			return 0;
+ 
+ 		/* Retrieve the associated PE config address */
+ 		ret = rtas_call(ibm_get_config_addr_info2, 4, 2, rets,
+ 				config_addr, BUID_HI(phb->buid),
+ 				BUID_LO(phb->buid), 0);
+ 		if (ret) {
+ 			pr_warn("%s: Failed to get address for PHB#%x-PE#%x\n",
+ 				__func__, phb->global_number, config_addr);
+ 			return 0;
+ 		}
+ 
+ 		return rets[0];
+ 	}
+ 
+ 	if (ibm_get_config_addr_info != RTAS_UNKNOWN_SERVICE) {
+ 		ret = rtas_call(ibm_get_config_addr_info, 4, 2, rets,
+ 				config_addr, BUID_HI(phb->buid),
+ 				BUID_LO(phb->buid), 0);
+ 		if (ret) {
+ 			pr_warn("%s: Failed to get address for PHB#%x-PE#%x\n",
+ 				__func__, phb->global_number, config_addr);
+ 			return 0;
+ 		}
+ 
+ 		return rets[0];
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * pseries_eeh_phb_reset - Reset the specified PHB
+  * @phb: PCI controller
+  * @config_adddr: the associated config address
+  * @option: reset option
+  *
+  * Reset the specified PHB/PE
+  */
+ static int pseries_eeh_phb_reset(struct pci_controller *phb, int config_addr, int option)
+ {
+ 	int ret;
+ 
+ 	/* Reset PE through RTAS call */
+ 	ret = rtas_call(ibm_set_slot_reset, 4, 1, NULL,
+ 			config_addr, BUID_HI(phb->buid),
+ 			BUID_LO(phb->buid), option);
+ 
+ 	/* If fundamental-reset not supported, try hot-reset */
+ 	if (option == EEH_RESET_FUNDAMENTAL &&
+ 	    ret == -8) {
+ 		option = EEH_RESET_HOT;
+ 		ret = rtas_call(ibm_set_slot_reset, 4, 1, NULL,
+ 				config_addr, BUID_HI(phb->buid),
+ 				BUID_LO(phb->buid), option);
+ 	}
+ 
+ 	/* We need reset hold or settlement delay */
+ 	if (option == EEH_RESET_FUNDAMENTAL ||
+ 	    option == EEH_RESET_HOT)
+ 		msleep(EEH_PE_RST_HOLD_TIME);
+ 	else
+ 		msleep(EEH_PE_RST_SETTLE_TIME);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * pseries_eeh_phb_configure_bridge - Configure PCI bridges in the indicated PE
+  * @phb: PCI controller
+  * @config_adddr: the associated config address
+  *
+  * The function will be called to reconfigure the bridges included
+  * in the specified PE so that the mulfunctional PE would be recovered
+  * again.
+  */
+ static int pseries_eeh_phb_configure_bridge(struct pci_controller *phb, int config_addr)
+ {
+ 	int ret;
+ 	/* Waiting 0.2s maximum before skipping configuration */
+ 	int max_wait = 200;
+ 
+ 	while (max_wait > 0) {
+ 		ret = rtas_call(ibm_configure_pe, 3, 1, NULL,
+ 				config_addr, BUID_HI(phb->buid),
+ 				BUID_LO(phb->buid));
+ 
+ 		if (!ret)
+ 			return ret;
+ 		if (ret < 0)
+ 			break;
+ 
+ 		/*
+ 		 * If RTAS returns a delay value that's above 100ms, cut it
+ 		 * down to 100ms in case firmware made a mistake.  For more
+ 		 * on how these delay values work see rtas_busy_delay_time
+ 		 */
+ 		if (ret > RTAS_EXTENDED_DELAY_MIN+2 &&
+ 		    ret <= RTAS_EXTENDED_DELAY_MAX)
+ 			ret = RTAS_EXTENDED_DELAY_MIN+2;
+ 
+ 		max_wait -= rtas_busy_delay_time(ret);
+ 
+ 		if (max_wait < 0)
+ 			break;
+ 
+ 		rtas_busy_delay(ret);
+ 	}
+ 
+ 	pr_warn("%s: Unable to configure bridge PHB#%x-PE#%x (%d)\n",
+ 		__func__, phb->global_number, config_addr, ret);
+ 	/* PAPR defines -3 as "Parameter Error" for this function: */
+ 	if (ret == -3)
+ 		return -EINVAL;
+ 	else
+ 		return -EIO;
+ }
+ 
  /*
   * Buffer for reporting slot-error-detail rtas calls. Its here
   * in BSS, and not dynamically alloced, so that it ends up in
@@@ -612,34 -796,7 +751,38 @@@ static int pseries_eeh_configure_bridge
  	if (pe->addr)
  		config_addr = pe->addr;
  
++<<<<<<< HEAD
 +	while (max_wait > 0) {
 +		ret = rtas_call(ibm_configure_pe, 3, 1, NULL,
 +				config_addr, BUID_HI(pe->phb->buid),
 +				BUID_LO(pe->phb->buid));
 +
 +		if (!ret)
 +			return ret;
 +
 +		/*
 +		 * If RTAS returns a delay value that's above 100ms, cut it
 +		 * down to 100ms in case firmware made a mistake.  For more
 +		 * on how these delay values work see rtas_busy_delay_time
 +		 */
 +		if (ret > RTAS_EXTENDED_DELAY_MIN+2 &&
 +		    ret <= RTAS_EXTENDED_DELAY_MAX)
 +			ret = RTAS_EXTENDED_DELAY_MIN+2;
 +
 +		max_wait -= rtas_busy_delay_time(ret);
 +
 +		if (max_wait < 0)
 +			break;
 +
 +		rtas_busy_delay(ret);
 +	}
 +
 +	pr_warn("%s: Unable to configure bridge PHB#%x-PE#%x (%d)\n",
 +		__func__, pe->phb->global_number, pe->addr, ret);
 +	return ret;
++=======
+ 	return pseries_eeh_phb_configure_bridge(pe->phb, config_addr);
++>>>>>>> 5a090f7c363f (powerpc/pseries: PCIE PHB reset)
  }
  
  /**
* Unmerged path arch/powerpc/platforms/pseries/eeh_pseries.c
