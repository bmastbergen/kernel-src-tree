libbpf: Support libbpf-provided extern variables

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 166750bc1dd256b2184b22588fb9fe6d3fbb93ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/166750bc.failed

Add support for extern variables, provided to BPF program by libbpf. Currently
the following extern variables are supported:
  - LINUX_KERNEL_VERSION; version of a kernel in which BPF program is
    executing, follows KERNEL_VERSION() macro convention, can be 4- and 8-byte
    long;
  - CONFIG_xxx values; a set of values of actual kernel config. Tristate,
    boolean, strings, and integer values are supported.

Set of possible values is determined by declared type of extern variable.
Supported types of variables are:
- Tristate values. Are represented as `enum libbpf_tristate`. Accepted values
  are **strictly** 'y', 'n', or 'm', which are represented as TRI_YES, TRI_NO,
  or TRI_MODULE, respectively.
- Boolean values. Are represented as bool (_Bool) types. Accepted values are
  'y' and 'n' only, turning into true/false values, respectively.
- Single-character values. Can be used both as a substritute for
  bool/tristate, or as a small-range integer:
  - 'y'/'n'/'m' are represented as is, as characters 'y', 'n', or 'm';
  - integers in a range [-128, 127] or [0, 255] (depending on signedness of
    char in target architecture) are recognized and represented with
    respective values of char type.
- Strings. String values are declared as fixed-length char arrays. String of
  up to that length will be accepted and put in first N bytes of char array,
  with the rest of bytes zeroed out. If config string value is longer than
  space alloted, it will be truncated and warning message emitted. Char array
  is always zero terminated. String literals in config have to be enclosed in
  double quotes, just like C-style string literals.
- Integers. 8-, 16-, 32-, and 64-bit integers are supported, both signed and
  unsigned variants. Libbpf enforces parsed config value to be in the
  supported range of corresponding integer type. Integers values in config can
  be:
  - decimal integers, with optional + and - signs;
  - hexadecimal integers, prefixed with 0x or 0X;
  - octal integers, starting with 0.

Config file itself is searched in /boot/config-$(uname -r) location with
fallback to /proc/config.gz, unless config path is specified explicitly
through bpf_object_open_opts' kernel_config_path option. Both gzipped and
plain text formats are supported. Libbpf adds explicit dependency on zlib
because of this, but this shouldn't be a problem, given libelf already depends
on zlib.

All detected extern variables, are put into a separate .extern internal map.
It, similarly to .rodata map, is marked as read-only from BPF program side, as
well as is frozen on load. This allows BPF verifier to track extern values as
constants and perform enhanced branch prediction and dead code elimination.
This can be relied upon for doing kernel version/feature detection and using
potentially unsupported field relocations or BPF helpers in a CO-RE-based BPF
program, while still having a single version of BPF program running on old and
new kernels. Selftests are validating this explicitly for unexisting BPF
helper.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
Link: https://lore.kernel.org/bpf/20191214014710.3449601-3-andriin@fb.com
(cherry picked from commit 166750bc1dd256b2184b22588fb9fe6d3fbb93ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/Makefile
#	tools/lib/bpf/libbpf.c
#	tools/lib/bpf/libbpf.h
diff --cc tools/lib/bpf/Makefile
index e6fcbcad3199,a3718cb275f2..000000000000
--- a/tools/lib/bpf/Makefile
+++ b/tools/lib/bpf/Makefile
@@@ -149,7 -160,7 +149,11 @@@ all: fixde
  
  all_cmd: $(CMD_TARGETS) check
  
++<<<<<<< HEAD
 +$(BPF_IN): force elfdep bpfdep bpf_helper_defs.h
++=======
+ $(BPF_IN_SHARED): force elfdep zdep bpfdep bpf_helper_defs.h
++>>>>>>> 166750bc1dd2 (libbpf: Support libbpf-provided extern variables)
  	@(test -f ../../include/uapi/linux/bpf.h -a -f ../../../include/uapi/linux/bpf.h && ( \
  	(diff -B ../../include/uapi/linux/bpf.h ../../../include/uapi/linux/bpf.h >/dev/null) || \
  	echo "Warning: Kernel ABI header at 'tools/include/uapi/linux/bpf.h' differs from latest version at 'include/uapi/linux/bpf.h'" >&2 )) || true
@@@ -165,7 -176,10 +169,14 @@@
  	@(test -f ../../include/uapi/linux/if_xdp.h -a -f ../../../include/uapi/linux/if_xdp.h && ( \
  	(diff -B ../../include/uapi/linux/if_xdp.h ../../../include/uapi/linux/if_xdp.h >/dev/null) || \
  	echo "Warning: Kernel ABI header at 'tools/include/uapi/linux/if_xdp.h' differs from latest version at 'include/uapi/linux/if_xdp.h'" >&2 )) || true
++<<<<<<< HEAD
 +	$(Q)$(MAKE) $(build)=libbpf
++=======
+ 	$(Q)$(MAKE) $(build)=libbpf OUTPUT=$(SHARED_OBJDIR) CFLAGS="$(CFLAGS) $(SHLIB_FLAGS)"
+ 
+ $(BPF_IN_STATIC): force elfdep zdep bpfdep bpf_helper_defs.h
+ 	$(Q)$(MAKE) $(build)=libbpf OUTPUT=$(STATIC_OBJDIR)
++>>>>>>> 166750bc1dd2 (libbpf: Support libbpf-provided extern variables)
  
  bpf_helper_defs.h: $(srctree)/tools/include/uapi/linux/bpf.h
  	$(Q)$(srctree)/scripts/bpf_helpers_doc.py --header 		\
@@@ -173,10 -187,10 +184,10 @@@
  
  $(OUTPUT)libbpf.so: $(OUTPUT)libbpf.so.$(LIBBPF_VERSION)
  
 -$(OUTPUT)libbpf.so.$(LIBBPF_VERSION): $(BPF_IN_SHARED)
 +$(OUTPUT)libbpf.so.$(LIBBPF_VERSION): $(BPF_IN)
  	$(QUIET_LINK)$(CC) $(LDFLAGS) \
  		--shared -Wl,-soname,libbpf.so.$(LIBBPF_MAJOR_VERSION) \
- 		-Wl,--version-script=$(VERSION_SCRIPT) $^ -lelf -o $@
+ 		-Wl,--version-script=$(VERSION_SCRIPT) $^ -lelf -lz -o $@
  	@ln -sf $(@F) $(OUTPUT)libbpf.so
  	@ln -sf $(@F) $(OUTPUT)libbpf.so.$(LIBBPF_MAJOR_VERSION)
  
@@@ -265,7 -279,7 +276,11 @@@ clean
  
  
  
++<<<<<<< HEAD
 +PHONY += force elfdep bpfdep
++=======
+ PHONY += force elfdep zdep bpfdep cscope tags
++>>>>>>> 166750bc1dd2 (libbpf: Support libbpf-provided extern variables)
  force:
  
  elfdep:
diff --cc tools/lib/bpf/libbpf.c
index 0511939b7897,26144706ba0b..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -872,9 -904,9 +910,15 @@@ bpf_object__init_internal_map(struct bp
  	def->key_size = sizeof(int);
  	def->value_size = data_sz;
  	def->max_entries = 1;
++<<<<<<< HEAD
 +	def->map_flags = type == LIBBPF_MAP_RODATA ? BPF_F_RDONLY_PROG : 0;
 +	if (obj->caps.array_mmap)
 +		def->map_flags |= BPF_F_MMAPABLE;
++=======
+ 	def->map_flags = type == LIBBPF_MAP_RODATA || type == LIBBPF_MAP_EXTERN
+ 			 ? BPF_F_RDONLY_PROG : 0;
+ 	def->map_flags |= BPF_F_MMAPABLE;
++>>>>>>> 166750bc1dd2 (libbpf: Support libbpf-provided extern variables)
  
  	pr_debug("map '%s' (global data): at sec_idx %d, offset %zu, flags %x.\n",
  		 map_name, map->sec_idx, map->sec_offset, def->map_flags);
@@@ -1407,21 -1702,20 +1716,24 @@@ static int bpf_object__init_user_btf_ma
  	return 0;
  }
  
 -static int bpf_object__init_maps(struct bpf_object *obj,
 -				 const struct bpf_object_open_opts *opts)
 +static int bpf_object__init_maps(struct bpf_object *obj, bool relaxed_maps,
 +				 const char *pin_root_path)
  {
++<<<<<<< HEAD
 +	bool strict = !relaxed_maps;
++=======
+ 	const char *pin_root_path;
+ 	bool strict;
++>>>>>>> 166750bc1dd2 (libbpf: Support libbpf-provided extern variables)
  	int err;
  
- 	err = bpf_object__init_user_maps(obj, strict);
- 	if (err)
- 		return err;
- 
- 	err = bpf_object__init_user_btf_maps(obj, strict, pin_root_path);
- 	if (err)
- 		return err;
+ 	strict = !OPTS_GET(opts, relaxed_maps, false);
+ 	pin_root_path = OPTS_GET(opts, pin_root_path, NULL);
  
- 	err = bpf_object__init_global_data_maps(obj);
+ 	err = bpf_object__init_user_maps(obj, strict);
+ 	err = err ?: bpf_object__init_user_btf_maps(obj, strict, pin_root_path);
+ 	err = err ?: bpf_object__init_global_data_maps(obj);
+ 	err = err ?: bpf_object__init_extern_map(obj);
  	if (err)
  		return err;
  
@@@ -1743,16 -2056,219 +2075,226 @@@ static int bpf_object__elf_collect(stru
  		pr_warn("Corrupted ELF file: index of strtab invalid\n");
  		return -LIBBPF_ERRNO__FORMAT;
  	}
 -	return bpf_object__init_btf(obj, btf_data, btf_ext_data);
 +	err = bpf_object__init_btf(obj, btf_data, btf_ext_data);
 +	if (!err)
 +		err = bpf_object__init_maps(obj, relaxed_maps, pin_root_path);
 +	if (!err)
 +		err = bpf_object__sanitize_and_load_btf(obj);
 +	if (!err)
 +		err = bpf_object__init_prog_names(obj);
 +	return err;
  }
  
+ static bool sym_is_extern(const GElf_Sym *sym)
+ {
+ 	int bind = GELF_ST_BIND(sym->st_info);
+ 	/* externs are symbols w/ type=NOTYPE, bind=GLOBAL|WEAK, section=UND */
+ 	return sym->st_shndx == SHN_UNDEF &&
+ 	       (bind == STB_GLOBAL || bind == STB_WEAK) &&
+ 	       GELF_ST_TYPE(sym->st_info) == STT_NOTYPE;
+ }
+ 
+ static int find_extern_btf_id(const struct btf *btf, const char *ext_name)
+ {
+ 	const struct btf_type *t;
+ 	const char *var_name;
+ 	int i, n;
+ 
+ 	if (!btf)
+ 		return -ESRCH;
+ 
+ 	n = btf__get_nr_types(btf);
+ 	for (i = 1; i <= n; i++) {
+ 		t = btf__type_by_id(btf, i);
+ 
+ 		if (!btf_is_var(t))
+ 			continue;
+ 
+ 		var_name = btf__name_by_offset(btf, t->name_off);
+ 		if (strcmp(var_name, ext_name))
+ 			continue;
+ 
+ 		if (btf_var(t)->linkage != BTF_VAR_GLOBAL_EXTERN)
+ 			return -EINVAL;
+ 
+ 		return i;
+ 	}
+ 
+ 	return -ENOENT;
+ }
+ 
+ static enum extern_type find_extern_type(const struct btf *btf, int id,
+ 					 bool *is_signed)
+ {
+ 	const struct btf_type *t;
+ 	const char *name;
+ 
+ 	t = skip_mods_and_typedefs(btf, id, NULL);
+ 	name = btf__name_by_offset(btf, t->name_off);
+ 
+ 	if (is_signed)
+ 		*is_signed = false;
+ 	switch (btf_kind(t)) {
+ 	case BTF_KIND_INT: {
+ 		int enc = btf_int_encoding(t);
+ 
+ 		if (enc & BTF_INT_BOOL)
+ 			return t->size == 1 ? EXT_BOOL : EXT_UNKNOWN;
+ 		if (is_signed)
+ 			*is_signed = enc & BTF_INT_SIGNED;
+ 		if (t->size == 1)
+ 			return EXT_CHAR;
+ 		if (t->size < 1 || t->size > 8 || (t->size & (t->size - 1)))
+ 			return EXT_UNKNOWN;
+ 		return EXT_INT;
+ 	}
+ 	case BTF_KIND_ENUM:
+ 		if (t->size != 4)
+ 			return EXT_UNKNOWN;
+ 		if (strcmp(name, "libbpf_tristate"))
+ 			return EXT_UNKNOWN;
+ 		return EXT_TRISTATE;
+ 	case BTF_KIND_ARRAY:
+ 		if (btf_array(t)->nelems == 0)
+ 			return EXT_UNKNOWN;
+ 		if (find_extern_type(btf, btf_array(t)->type, NULL) != EXT_CHAR)
+ 			return EXT_UNKNOWN;
+ 		return EXT_CHAR_ARR;
+ 	default:
+ 		return EXT_UNKNOWN;
+ 	}
+ }
+ 
+ static int cmp_externs(const void *_a, const void *_b)
+ {
+ 	const struct extern_desc *a = _a;
+ 	const struct extern_desc *b = _b;
+ 
+ 	/* descending order by alignment requirements */
+ 	if (a->align != b->align)
+ 		return a->align > b->align ? -1 : 1;
+ 	/* ascending order by size, within same alignment class */
+ 	if (a->sz != b->sz)
+ 		return a->sz < b->sz ? -1 : 1;
+ 	/* resolve ties by name */
+ 	return strcmp(a->name, b->name);
+ }
+ 
+ static int bpf_object__collect_externs(struct bpf_object *obj)
+ {
+ 	const struct btf_type *t;
+ 	struct extern_desc *ext;
+ 	int i, n, off, btf_id;
+ 	struct btf_type *sec;
+ 	const char *ext_name;
+ 	Elf_Scn *scn;
+ 	GElf_Shdr sh;
+ 
+ 	if (!obj->efile.symbols)
+ 		return 0;
+ 
+ 	scn = elf_getscn(obj->efile.elf, obj->efile.symbols_shndx);
+ 	if (!scn)
+ 		return -LIBBPF_ERRNO__FORMAT;
+ 	if (gelf_getshdr(scn, &sh) != &sh)
+ 		return -LIBBPF_ERRNO__FORMAT;
+ 	n = sh.sh_size / sh.sh_entsize;
+ 
+ 	pr_debug("looking for externs among %d symbols...\n", n);
+ 	for (i = 0; i < n; i++) {
+ 		GElf_Sym sym;
+ 
+ 		if (!gelf_getsym(obj->efile.symbols, i, &sym))
+ 			return -LIBBPF_ERRNO__FORMAT;
+ 		if (!sym_is_extern(&sym))
+ 			continue;
+ 		ext_name = elf_strptr(obj->efile.elf, obj->efile.strtabidx,
+ 				      sym.st_name);
+ 		if (!ext_name || !ext_name[0])
+ 			continue;
+ 
+ 		ext = obj->externs;
+ 		ext = reallocarray(ext, obj->nr_extern + 1, sizeof(*ext));
+ 		if (!ext)
+ 			return -ENOMEM;
+ 		obj->externs = ext;
+ 		ext = &ext[obj->nr_extern];
+ 		memset(ext, 0, sizeof(*ext));
+ 		obj->nr_extern++;
+ 
+ 		ext->btf_id = find_extern_btf_id(obj->btf, ext_name);
+ 		if (ext->btf_id <= 0) {
+ 			pr_warn("failed to find BTF for extern '%s': %d\n",
+ 				ext_name, ext->btf_id);
+ 			return ext->btf_id;
+ 		}
+ 		t = btf__type_by_id(obj->btf, ext->btf_id);
+ 		ext->name = btf__name_by_offset(obj->btf, t->name_off);
+ 		ext->sym_idx = i;
+ 		ext->is_weak = GELF_ST_BIND(sym.st_info) == STB_WEAK;
+ 		ext->sz = btf__resolve_size(obj->btf, t->type);
+ 		if (ext->sz <= 0) {
+ 			pr_warn("failed to resolve size of extern '%s': %d\n",
+ 				ext_name, ext->sz);
+ 			return ext->sz;
+ 		}
+ 		ext->align = btf__align_of(obj->btf, t->type);
+ 		if (ext->align <= 0) {
+ 			pr_warn("failed to determine alignment of extern '%s': %d\n",
+ 				ext_name, ext->align);
+ 			return -EINVAL;
+ 		}
+ 		ext->type = find_extern_type(obj->btf, t->type,
+ 					     &ext->is_signed);
+ 		if (ext->type == EXT_UNKNOWN) {
+ 			pr_warn("extern '%s' type is unsupported\n", ext_name);
+ 			return -ENOTSUP;
+ 		}
+ 	}
+ 	pr_debug("collected %d externs total\n", obj->nr_extern);
+ 
+ 	if (!obj->nr_extern)
+ 		return 0;
+ 
+ 	/* sort externs by (alignment, size, name) and calculate their offsets
+ 	 * within a map */
+ 	qsort(obj->externs, obj->nr_extern, sizeof(*ext), cmp_externs);
+ 	off = 0;
+ 	for (i = 0; i < obj->nr_extern; i++) {
+ 		ext = &obj->externs[i];
+ 		ext->data_off = roundup(off, ext->align);
+ 		off = ext->data_off + ext->sz;
+ 		pr_debug("extern #%d: symbol %d, off %u, name %s\n",
+ 			 i, ext->sym_idx, ext->data_off, ext->name);
+ 	}
+ 
+ 	btf_id = btf__find_by_name(obj->btf, EXTERN_SEC);
+ 	if (btf_id <= 0) {
+ 		pr_warn("no BTF info found for '%s' datasec\n", EXTERN_SEC);
+ 		return -ESRCH;
+ 	}
+ 
+ 	sec = (struct btf_type *)btf__type_by_id(obj->btf, btf_id);
+ 	sec->size = off;
+ 	n = btf_vlen(sec);
+ 	for (i = 0; i < n; i++) {
+ 		struct btf_var_secinfo *vs = btf_var_secinfos(sec) + i;
+ 
+ 		t = btf__type_by_id(obj->btf, vs->type);
+ 		ext_name = btf__name_by_offset(obj->btf, t->name_off);
+ 		ext = find_extern_by_name(obj, ext_name);
+ 		if (!ext) {
+ 			pr_warn("failed to find extern definition for BTF var '%s'\n",
+ 				ext_name);
+ 			return -ESRCH;
+ 		}
+ 		vs->offset = ext->data_off;
+ 		btf_var(t)->linkage = BTF_VAR_GLOBAL_ALLOCATED;
+ 	}
+ 
+ 	return 0;
+ }
+ 
  static struct bpf_program *
  bpf_object__find_prog_by_idx(struct bpf_object *obj, int idx)
  {
@@@ -3954,14 -4500,12 +4530,20 @@@ bpf_object__load_progs(struct bpf_objec
  
  static struct bpf_object *
  __bpf_object__open(const char *path, const void *obj_buf, size_t obj_buf_sz,
 -		   const struct bpf_object_open_opts *opts)
 +		   struct bpf_object_open_opts *opts)
  {
++<<<<<<< HEAD
 +	const char *pin_root_path;
++=======
+ 	const char *obj_name, *kconfig_path;
++>>>>>>> 166750bc1dd2 (libbpf: Support libbpf-provided extern variables)
  	struct bpf_program *prog;
  	struct bpf_object *obj;
- 	const char *obj_name;
  	char tmp_name[64];
++<<<<<<< HEAD
 +	bool relaxed_maps;
++=======
++>>>>>>> 166750bc1dd2 (libbpf: Support libbpf-provided extern variables)
  	int err;
  
  	if (elf_version(EV_CURRENT) == EV_NONE) {
@@@ -3990,15 -4534,23 +4572,35 @@@
  		return obj;
  
  	obj->relaxed_core_relocs = OPTS_GET(opts, relaxed_core_relocs, false);
++<<<<<<< HEAD
 +	relaxed_maps = OPTS_GET(opts, relaxed_maps, false);
 +	pin_root_path = OPTS_GET(opts, pin_root_path, NULL);
 +
 +	CHECK_ERR(bpf_object__elf_init(obj), err, out);
 +	CHECK_ERR(bpf_object__check_endianness(obj), err, out);
 +	CHECK_ERR(bpf_object__probe_caps(obj), err, out);
 +	CHECK_ERR(bpf_object__elf_collect(obj, relaxed_maps, pin_root_path),
 +		  err, out);
 +	CHECK_ERR(bpf_object__collect_reloc(obj), err, out);
++=======
+ 	kconfig_path = OPTS_GET(opts, kconfig_path, NULL);
+ 	if (kconfig_path) {
+ 		obj->kconfig_path = strdup(kconfig_path);
+ 		if (!obj->kconfig_path)
+ 			return ERR_PTR(-ENOMEM);
+ 	}
+ 
+ 	err = bpf_object__elf_init(obj);
+ 	err = err ? : bpf_object__check_endianness(obj);
+ 	err = err ? : bpf_object__elf_collect(obj);
+ 	err = err ? : bpf_object__collect_externs(obj);
+ 	err = err ? : bpf_object__finalize_btf(obj);
+ 	err = err ? : bpf_object__init_maps(obj, opts);
+ 	err = err ? : bpf_object__init_prog_names(obj);
+ 	err = err ? : bpf_object__collect_reloc(obj);
+ 	if (err)
+ 		goto out;
++>>>>>>> 166750bc1dd2 (libbpf: Support libbpf-provided extern variables)
  	bpf_object__elf_finish(obj);
  
  	bpf_object__for_each_program(prog, obj) {
@@@ -4015,6 -4567,8 +4617,11 @@@
  
  		bpf_program__set_type(prog, prog_type);
  		bpf_program__set_expected_attach_type(prog, attach_type);
++<<<<<<< HEAD
++=======
+ 		if (prog_type == BPF_PROG_TYPE_TRACING)
+ 			prog->attach_prog_fd = OPTS_GET(opts, attach_prog_fd, 0);
++>>>>>>> 166750bc1dd2 (libbpf: Support libbpf-provided extern variables)
  	}
  
  	return obj;
@@@ -4107,6 -4661,79 +4714,82 @@@ int bpf_object__unload(struct bpf_objec
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int bpf_object__sanitize_maps(struct bpf_object *obj)
+ {
+ 	struct bpf_map *m;
+ 
+ 	bpf_object__for_each_map(m, obj) {
+ 		if (!bpf_map__is_internal(m))
+ 			continue;
+ 		if (!obj->caps.global_data) {
+ 			pr_warn("kernel doesn't support global data\n");
+ 			return -ENOTSUP;
+ 		}
+ 		if (!obj->caps.array_mmap)
+ 			m->def.map_flags ^= BPF_F_MMAPABLE;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int bpf_object__resolve_externs(struct bpf_object *obj,
+ 				       const char *config_path)
+ {
+ 	bool need_config = false;
+ 	struct extern_desc *ext;
+ 	int err, i;
+ 	void *data;
+ 
+ 	if (obj->nr_extern == 0)
+ 		return 0;
+ 
+ 	data = obj->maps[obj->extern_map_idx].mmaped;
+ 
+ 	for (i = 0; i < obj->nr_extern; i++) {
+ 		ext = &obj->externs[i];
+ 
+ 		if (strcmp(ext->name, "LINUX_KERNEL_VERSION") == 0) {
+ 			void *ext_val = data + ext->data_off;
+ 			__u32 kver = get_kernel_version();
+ 
+ 			if (!kver) {
+ 				pr_warn("failed to get kernel version\n");
+ 				return -EINVAL;
+ 			}
+ 			err = set_ext_value_num(ext, ext_val, kver);
+ 			if (err)
+ 				return err;
+ 			pr_debug("extern %s=0x%x\n", ext->name, kver);
+ 		} else if (strncmp(ext->name, "CONFIG_", 7) == 0) {
+ 			need_config = true;
+ 		} else {
+ 			pr_warn("unrecognized extern '%s'\n", ext->name);
+ 			return -EINVAL;
+ 		}
+ 	}
+ 	if (need_config) {
+ 		err = bpf_object__read_kernel_config(obj, config_path, data);
+ 		if (err)
+ 			return -EINVAL;
+ 	}
+ 	for (i = 0; i < obj->nr_extern; i++) {
+ 		ext = &obj->externs[i];
+ 
+ 		if (!ext->is_set && !ext->is_weak) {
+ 			pr_warn("extern %s (strong) not resolved\n", ext->name);
+ 			return -ESRCH;
+ 		} else if (!ext->is_set) {
+ 			pr_debug("extern %s (weak) not resolved, defaulting to zero\n",
+ 				 ext->name);
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 166750bc1dd2 (libbpf: Support libbpf-provided extern variables)
  int bpf_object__load_xattr(struct bpf_object_load_attr *attr)
  {
  	struct bpf_object *obj;
@@@ -4125,9 -4752,15 +4808,21 @@@
  
  	obj->loaded = true;
  
++<<<<<<< HEAD
 +	CHECK_ERR(bpf_object__create_maps(obj), err, out);
 +	CHECK_ERR(bpf_object__relocate(obj, attr->target_btf_path), err, out);
 +	CHECK_ERR(bpf_object__load_progs(obj, attr->log_level), err, out);
++=======
+ 	err = bpf_object__probe_caps(obj);
+ 	err = err ? : bpf_object__resolve_externs(obj, obj->kconfig_path);
+ 	err = err ? : bpf_object__sanitize_and_load_btf(obj);
+ 	err = err ? : bpf_object__sanitize_maps(obj);
+ 	err = err ? : bpf_object__create_maps(obj);
+ 	err = err ? : bpf_object__relocate(obj, attr->target_btf_path);
+ 	err = err ? : bpf_object__load_progs(obj, attr->log_level);
+ 	if (err)
+ 		goto out;
++>>>>>>> 166750bc1dd2 (libbpf: Support libbpf-provided extern variables)
  
  	return 0;
  out:
diff --cc tools/lib/bpf/libbpf.h
index e454ceec9fa2,6340823871e2..000000000000
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@@ -84,8 -84,13 +84,18 @@@ struct bpf_object_open_opts 
  	 * auto-pinned to that path on load; defaults to "/sys/fs/bpf".
  	 */
  	const char *pin_root_path;
++<<<<<<< HEAD
 +};
 +#define bpf_object_open_opts__last_field pin_root_path
++=======
+ 	__u32 attach_prog_fd;
+ 	/* kernel config file path override (for CONFIG_ externs); can point
+ 	 * to either uncompressed text file or .gz file
+ 	 */
+ 	const char *kconfig_path;
+ };
+ #define bpf_object_open_opts__last_field kconfig_path
++>>>>>>> 166750bc1dd2 (libbpf: Support libbpf-provided extern variables)
  
  LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
  LIBBPF_API struct bpf_object *
@@@ -582,6 -600,85 +592,88 @@@ bpf_program__bpil_offs_to_addr(struct b
   */
  LIBBPF_API int libbpf_num_possible_cpus(void);
  
++<<<<<<< HEAD
++=======
+ struct bpf_embed_data {
+ 	void *data;
+ 	size_t size;
+ };
+ 
+ #define BPF_EMBED_OBJ_DECLARE(NAME)					\
+ extern struct bpf_embed_data NAME##_embed;				\
+ extern char NAME##_data[];						\
+ extern char NAME##_data_end[];
+ 
+ #define __BPF_EMBED_OBJ(NAME, PATH, SZ, ASM_TYPE)			\
+ asm (									\
+ "	.pushsection \".rodata\", \"a\", @progbits		\n"	\
+ "	.global "#NAME"_data					\n"	\
+ #NAME"_data:							\n"	\
+ "	.incbin \"" PATH "\"					\n"	\
+ "	.global "#NAME"_data_end				\n"	\
+ #NAME"_data_end:						\n"	\
+ "	.global "#NAME"_embed					\n"	\
+ "	.type "#NAME"_embed, @object				\n"	\
+ "	.size "#NAME"_size, "#SZ"				\n"	\
+ "	.align 8,						\n"	\
+ #NAME"_embed:							\n"	\
+ "	"ASM_TYPE" "#NAME"_data					\n"	\
+ "	"ASM_TYPE" "#NAME"_data_end - "#NAME"_data 		\n"	\
+ "	.popsection						\n"	\
+ );									\
+ BPF_EMBED_OBJ_DECLARE(NAME)
+ 
+ #if __SIZEOF_POINTER__ == 4
+ #define BPF_EMBED_OBJ(NAME, PATH) __BPF_EMBED_OBJ(NAME, PATH, 8, ".long")
+ #else
+ #define BPF_EMBED_OBJ(NAME, PATH) __BPF_EMBED_OBJ(NAME, PATH, 16, ".quad")
+ #endif
+ 
+ struct bpf_map_skeleton {
+ 	const char *name;
+ 	struct bpf_map **map;
+ 	void **mmaped;
+ };
+ 
+ struct bpf_prog_skeleton {
+ 	const char *name;
+ 	struct bpf_program **prog;
+ 	struct bpf_link **link;
+ };
+ 
+ struct bpf_object_skeleton {
+ 	size_t sz; /* size of this struct, for forward/backward compatibility */
+ 
+ 	const char *name;
+ 	void *data;
+ 	size_t data_sz;
+ 
+ 	struct bpf_object **obj;
+ 
+ 	int map_cnt;
+ 	int map_skel_sz; /* sizeof(struct bpf_skeleton_map) */
+ 	struct bpf_map_skeleton *maps;
+ 
+ 	int prog_cnt;
+ 	int prog_skel_sz; /* sizeof(struct bpf_skeleton_prog) */
+ 	struct bpf_prog_skeleton *progs;
+ };
+ 
+ LIBBPF_API int
+ bpf_object__open_skeleton(struct bpf_object_skeleton *s,
+ 			  const struct bpf_object_open_opts *opts);
+ LIBBPF_API int bpf_object__load_skeleton(struct bpf_object_skeleton *s);
+ LIBBPF_API int bpf_object__attach_skeleton(struct bpf_object_skeleton *s);
+ LIBBPF_API void bpf_object__detach_skeleton(struct bpf_object_skeleton *s);
+ LIBBPF_API void bpf_object__destroy_skeleton(struct bpf_object_skeleton *s);
+ 
+ enum libbpf_tristate {
+ 	TRI_NO = 0,
+ 	TRI_YES = 1,
+ 	TRI_MODULE = 2,
+ };
+ 
++>>>>>>> 166750bc1dd2 (libbpf: Support libbpf-provided extern variables)
  #ifdef __cplusplus
  } /* extern "C" */
  #endif
diff --git a/include/uapi/linux/btf.h b/include/uapi/linux/btf.h
index c02dec97e1ce..1a2898c482ee 100644
--- a/include/uapi/linux/btf.h
+++ b/include/uapi/linux/btf.h
@@ -142,7 +142,8 @@ struct btf_param {
 
 enum {
 	BTF_VAR_STATIC = 0,
-	BTF_VAR_GLOBAL_ALLOCATED,
+	BTF_VAR_GLOBAL_ALLOCATED = 1,
+	BTF_VAR_GLOBAL_EXTERN = 2,
 };
 
 /* BTF_KIND_VAR is followed by a single "struct btf_var" to describe
diff --git a/tools/include/uapi/linux/btf.h b/tools/include/uapi/linux/btf.h
index 63ae4a39e58b..1a2898c482ee 100644
--- a/tools/include/uapi/linux/btf.h
+++ b/tools/include/uapi/linux/btf.h
@@ -22,9 +22,9 @@ struct btf_header {
 };
 
 /* Max # of type identifier */
-#define BTF_MAX_TYPE	0x0000ffff
+#define BTF_MAX_TYPE	0x000fffff
 /* Max offset into the string section */
-#define BTF_MAX_NAME_OFFSET	0x0000ffff
+#define BTF_MAX_NAME_OFFSET	0x00ffffff
 /* Max # of struct/union/enum members or func args */
 #define BTF_MAX_VLEN	0xffff
 
@@ -142,7 +142,8 @@ struct btf_param {
 
 enum {
 	BTF_VAR_STATIC = 0,
-	BTF_VAR_GLOBAL_ALLOCATED,
+	BTF_VAR_GLOBAL_ALLOCATED = 1,
+	BTF_VAR_GLOBAL_EXTERN = 2,
 };
 
 /* BTF_KIND_VAR is followed by a single "struct btf_var" to describe
* Unmerged path tools/lib/bpf/Makefile
diff --git a/tools/lib/bpf/bpf_helpers.h b/tools/lib/bpf/bpf_helpers.h
index 0c7d28292898..aa46700075e1 100644
--- a/tools/lib/bpf/bpf_helpers.h
+++ b/tools/lib/bpf/bpf_helpers.h
@@ -25,6 +25,9 @@
 #ifndef __always_inline
 #define __always_inline __attribute__((always_inline))
 #endif
+#ifndef __weak
+#define __weak __attribute__((weak))
+#endif
 
 /*
  * Helper structure used by eBPF C program
@@ -44,4 +47,10 @@ enum libbpf_pin_type {
 	LIBBPF_PIN_BY_NAME,
 };
 
+enum libbpf_tristate {
+	TRI_NO = 0,
+	TRI_YES = 1,
+	TRI_MODULE = 2,
+};
+
 #endif
diff --git a/tools/lib/bpf/btf.c b/tools/lib/bpf/btf.c
index 86a1847e4a9f..bdb4bbc11e02 100644
--- a/tools/lib/bpf/btf.c
+++ b/tools/lib/bpf/btf.c
@@ -517,6 +517,12 @@ static int btf_fixup_datasec(struct bpf_object *obj, struct btf *btf,
 		return -ENOENT;
 	}
 
+	/* .extern datasec size and var offsets were set correctly during
+	 * extern collection step, so just skip straight to sorting variables
+	 */
+	if (t->size)
+		goto sort_vars;
+
 	ret = bpf_object__section_size(obj, name, &size);
 	if (ret || !size || (t->size && t->size != size)) {
 		pr_debug("Invalid size for section %s: %u bytes\n", name, size);
@@ -553,7 +559,8 @@ static int btf_fixup_datasec(struct bpf_object *obj, struct btf *btf,
 		vsi->offset = off;
 	}
 
-	qsort(t + 1, vars, sizeof(*vsi), compare_vsi_off);
+sort_vars:
+	qsort(btf_var_secinfos(t), vars, sizeof(*vsi), compare_vsi_off);
 	return 0;
 }
 
* Unmerged path tools/lib/bpf/libbpf.c
* Unmerged path tools/lib/bpf/libbpf.h
diff --git a/tools/testing/selftests/bpf/Makefile b/tools/testing/selftests/bpf/Makefile
index 1739bffedc44..c4d4b76f7a10 100644
--- a/tools/testing/selftests/bpf/Makefile
+++ b/tools/testing/selftests/bpf/Makefile
@@ -19,7 +19,7 @@ BPF_GCC		?= $(shell command -v bpf-gcc;)
 CFLAGS += -g -Wall -O2 -I$(APIDIR) -I$(LIBDIR) -I$(BPFDIR) -I$(GENDIR) $(GENFLAGS) -I../../../include \
 	  -Dbpf_prog_load=bpf_prog_test_load \
 	  -Dbpf_load_program=bpf_test_load_program
-LDLIBS += -lcap -lelf -lrt -lpthread
+LDLIBS += -lcap -lelf -lz -lrt -lpthread
 
 # Order correspond to 'make run_tests' order
 TEST_GEN_PROGS = test_verifier test_tag test_maps test_lru_map test_lpm_map test_progs \
