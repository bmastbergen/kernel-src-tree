io_uring: flush overflowed CQ events in the io_uring_poll()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Stefano Garzarella <sgarzare@redhat.com>
commit 63e5d81f72af1bf370bf8a6745b0a8d71a7bb37d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/63e5d81f.failed

In io_uring_poll() we must flush overflowed CQ events before to
check if there are CQ events available, to avoid missing events.

We call the io_cqring_events() that checks and flushes any overflow
and returns the number of CQ events available.

	Signed-off-by: Stefano Garzarella <sgarzare@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 63e5d81f72af1bf370bf8a6745b0a8d71a7bb37d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index ffb8e9d82a6a,2954a8bdf824..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -3541,10 -6280,10 +3541,14 @@@ static __poll_t io_uring_poll(struct fi
  	 * io_commit_cqring
  	 */
  	smp_rmb();
 -	if (READ_ONCE(ctx->rings->sq.tail) - ctx->cached_sq_head !=
 -	    ctx->rings->sq_ring_entries)
 +	if (READ_ONCE(ctx->sq_ring->r.tail) - ctx->cached_sq_head !=
 +	    ctx->sq_ring->ring_entries)
  		mask |= EPOLLOUT | EPOLLWRNORM;
++<<<<<<< HEAD
 +	if (READ_ONCE(ctx->cq_ring->r.head) != ctx->cached_cq_tail)
++=======
+ 	if (io_cqring_events(ctx, false))
++>>>>>>> 63e5d81f72af (io_uring: flush overflowed CQ events in the io_uring_poll())
  		mask |= EPOLLIN | EPOLLRDNORM;
  
  	return mask;
* Unmerged path fs/io_uring.c
