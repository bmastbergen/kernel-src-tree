iommu: Export bus_iommu_probe() and make is safe for re-probing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Joerg Roedel <jroedel@suse.de>
commit 5012c3968537e2ffecbdb2eba3479bf9fb9e5597
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5012c396.failed

Add a check to the bus_iommu_probe() call-path to make sure it ignores
devices which have already been successfully probed. Then export the
bus_iommu_probe() function so it can be used by IOMMU drivers.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
	Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
	Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
Link: https://lore.kernel.org/r/20200429133712.31431-14-joro@8bytes.org
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 5012c3968537e2ffecbdb2eba3479bf9fb9e5597)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
diff --cc drivers/iommu/iommu.c
index 7997fcb701e0,397fd4fd0c32..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -1224,6 -1606,45 +1224,48 @@@ static int add_iommu_group(struct devic
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int probe_iommu_group(struct device *dev, void *data)
+ {
+ 	const struct iommu_ops *ops = dev->bus->iommu_ops;
+ 	struct list_head *group_list = data;
+ 	struct iommu_group *group;
+ 	int ret;
+ 
+ 	if (!dev_iommu_get(dev))
+ 		return -ENOMEM;
+ 
+ 	/* Device is probed already if in a group */
+ 	group = iommu_group_get(dev);
+ 	if (group) {
+ 		iommu_group_put(group);
+ 		return 0;
+ 	}
+ 
+ 	if (!try_module_get(ops->owner)) {
+ 		ret = -EINVAL;
+ 		goto err_free_dev_iommu;
+ 	}
+ 
+ 	ret = __iommu_probe_device(dev, group_list);
+ 	if (ret)
+ 		goto err_module_put;
+ 
+ 	return 0;
+ 
+ err_module_put:
+ 	module_put(ops->owner);
+ err_free_dev_iommu:
+ 	dev_iommu_free(dev);
+ 
+ 	if (ret == -ENODEV)
+ 		ret = 0;
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 5012c3968537 (iommu: Export bus_iommu_probe() and make is safe for re-probing)
  static int remove_iommu_group(struct device *dev, void *data)
  {
  	iommu_release_device(dev);
@@@ -1283,10 -1704,145 +1325,148 @@@ static int iommu_bus_notifier(struct no
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ struct __group_domain_type {
+ 	struct device *dev;
+ 	unsigned int type;
+ };
+ 
+ static int probe_get_default_domain_type(struct device *dev, void *data)
+ {
+ 	const struct iommu_ops *ops = dev->bus->iommu_ops;
+ 	struct __group_domain_type *gtype = data;
+ 	unsigned int type = 0;
+ 
+ 	if (ops->def_domain_type)
+ 		type = ops->def_domain_type(dev);
+ 
+ 	if (type) {
+ 		if (gtype->type && gtype->type != type) {
+ 			dev_warn(dev, "Device needs domain type %s, but device %s in the same iommu group requires type %s - using default\n",
+ 				 iommu_domain_type_str(type),
+ 				 dev_name(gtype->dev),
+ 				 iommu_domain_type_str(gtype->type));
+ 			gtype->type = 0;
+ 		}
+ 
+ 		if (!gtype->dev) {
+ 			gtype->dev  = dev;
+ 			gtype->type = type;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void probe_alloc_default_domain(struct bus_type *bus,
+ 				       struct iommu_group *group)
+ {
+ 	struct __group_domain_type gtype;
+ 
+ 	memset(&gtype, 0, sizeof(gtype));
+ 
+ 	/* Ask for default domain requirements of all devices in the group */
+ 	__iommu_group_for_each_dev(group, &gtype,
+ 				   probe_get_default_domain_type);
+ 
+ 	if (!gtype.type)
+ 		gtype.type = iommu_def_domain_type;
+ 
+ 	iommu_group_alloc_default_domain(bus, group, gtype.type);
+ 
+ }
+ 
+ static int iommu_group_do_dma_attach(struct device *dev, void *data)
+ {
+ 	struct iommu_domain *domain = data;
+ 	const struct iommu_ops *ops;
+ 	int ret;
+ 
+ 	ret = __iommu_attach_device(domain, dev);
+ 
+ 	ops = domain->ops;
+ 
+ 	if (ret == 0 && ops->probe_finalize)
+ 		ops->probe_finalize(dev);
+ 
+ 	return ret;
+ }
+ 
+ static int __iommu_group_dma_attach(struct iommu_group *group)
+ {
+ 	return __iommu_group_for_each_dev(group, group->default_domain,
+ 					  iommu_group_do_dma_attach);
+ }
+ 
+ static int iommu_do_create_direct_mappings(struct device *dev, void *data)
+ {
+ 	struct iommu_group *group = data;
+ 
+ 	iommu_create_device_direct_mappings(group, dev);
+ 
+ 	return 0;
+ }
+ 
+ static int iommu_group_create_direct_mappings(struct iommu_group *group)
+ {
+ 	return __iommu_group_for_each_dev(group, group,
+ 					  iommu_do_create_direct_mappings);
+ }
+ 
+ int bus_iommu_probe(struct bus_type *bus)
+ {
+ 	const struct iommu_ops *ops = bus->iommu_ops;
+ 	int ret;
+ 
+ 	if (ops->probe_device) {
+ 		struct iommu_group *group, *next;
+ 		LIST_HEAD(group_list);
+ 
+ 		/*
+ 		 * This code-path does not allocate the default domain when
+ 		 * creating the iommu group, so do it after the groups are
+ 		 * created.
+ 		 */
+ 		ret = bus_for_each_dev(bus, NULL, &group_list, probe_iommu_group);
+ 		if (ret)
+ 			return ret;
+ 
+ 		list_for_each_entry_safe(group, next, &group_list, entry) {
+ 			/* Remove item from the list */
+ 			list_del_init(&group->entry);
+ 
+ 			mutex_lock(&group->mutex);
+ 
+ 			/* Try to allocate default domain */
+ 			probe_alloc_default_domain(bus, group);
+ 
+ 			if (!group->default_domain) {
+ 				mutex_unlock(&group->mutex);
+ 				continue;
+ 			}
+ 
+ 			iommu_group_create_direct_mappings(group);
+ 
+ 			ret = __iommu_group_dma_attach(group);
+ 
+ 			mutex_unlock(&group->mutex);
+ 
+ 			if (ret)
+ 				break;
+ 		}
+ 	} else {
+ 		ret = bus_for_each_dev(bus, NULL, NULL, add_iommu_group);
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 5012c3968537 (iommu: Export bus_iommu_probe() and make is safe for re-probing)
  static int iommu_bus_init(struct bus_type *bus, const struct iommu_ops *ops)
  {
 -	struct notifier_block *nb;
  	int err;
 +	struct notifier_block *nb;
  
  	nb = kzalloc(sizeof(struct notifier_block), GFP_KERNEL);
  	if (!nb)
* Unmerged path drivers/iommu/iommu.c
diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index c0752afea934..162de61228b0 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -385,6 +385,7 @@ static inline void iommu_iotlb_gather_init(struct iommu_iotlb_gather *gather)
 #define IOMMU_GROUP_NOTIFY_UNBOUND_DRIVER	6 /* Post Driver unbind */
 
 extern int bus_set_iommu(struct bus_type *bus, const struct iommu_ops *ops);
+extern int bus_iommu_probe(struct bus_type *bus);
 extern bool iommu_present(struct bus_type *bus);
 extern bool iommu_capable(struct bus_type *bus, enum iommu_cap cap);
 extern struct iommu_domain *iommu_domain_alloc(struct bus_type *bus);
