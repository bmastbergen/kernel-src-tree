drm/amd/display: Do not disable pipe split if mode is not supported

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sung Lee <sung.lee@amd.com>
commit 1dfedb39d38f813357885e19badd1971c17f79a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/1dfedb39.failed

[WHY]
If mode is not supported, pipe split should not be disabled.
This may cause more modes to fail.

[HOW]
Check for mode support before disabling pipe split.

This commit was previously reverted as it was thought to
have problems, but those issues have been resolved.

	Signed-off-by: Sung Lee <sung.lee@amd.com>
	Reviewed-by: Yongqiang Sun <yongqiang.sun@amd.com>
	Acked-by: Aurabindo Pillai <aurabindo.pillai@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit 1dfedb39d38f813357885e19badd1971c17f79a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c
diff --cc drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c
index 3cf504d27335,f41fc322d50a..000000000000
--- a/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c
@@@ -2059,16 -2590,150 +2059,159 @@@ bool dcn20_validate_bandwidth(struct d
  		if (pipe->plane_state)
  			resource_build_scaling_params(pipe);
  	}
 -}
  
++<<<<<<< HEAD
 +	if (dc->res_pool->funcs->populate_dml_pipes)
 +		pipe_cnt = dc->res_pool->funcs->populate_dml_pipes(dc,
 +			&context->res_ctx, pipes);
 +	else
 +		pipe_cnt = dcn20_populate_dml_pipes_from_context(dc,
 +			&context->res_ctx, pipes);
++=======
+ int dcn20_validate_apply_pipe_split_flags(
+ 		struct dc *dc,
+ 		struct dc_state *context,
+ 		int vlevel,
+ 		bool *split,
+ 		bool *merge)
+ {
+ 	int i, pipe_idx, vlevel_split;
+ 	int plane_count = 0;
+ 	bool force_split = false;
+ 	bool avoid_split = dc->debug.pipe_split_policy == MPC_SPLIT_AVOID;
+ 
+ 	if (context->stream_count > 1) {
+ 		if (dc->debug.pipe_split_policy == MPC_SPLIT_AVOID_MULT_DISP)
+ 			avoid_split = true;
+ 	} else if (dc->debug.force_single_disp_pipe_split)
+ 			force_split = true;
+ 
+ 	/* TODO: fix dc bugs and remove this split threshold thing */
+ 	for (i = 0; i < dc->res_pool->pipe_count; i++) {
+ 		struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];
+ 
+ 		if (pipe->stream && !pipe->prev_odm_pipe &&
+ 				(!pipe->top_pipe || pipe->top_pipe->plane_state != pipe->plane_state))
+ 			++plane_count;
+ 	}
+ 	if (plane_count > dc->res_pool->pipe_count / 2)
+ 		avoid_split = true;
+ 
+ 	/* Avoid split loop looks for lowest voltage level that allows most unsplit pipes possible */
+ 	if (avoid_split) {
+ 		int max_mpc_comb = context->bw_ctx.dml.vba.maxMpcComb;
+ 
+ 		for (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {
+ 			if (!context->res_ctx.pipe_ctx[i].stream)
+ 				continue;
+ 
+ 			for (vlevel_split = vlevel; vlevel <= context->bw_ctx.dml.soc.num_states; vlevel++)
+ 				if (context->bw_ctx.dml.vba.NoOfDPP[vlevel][0][pipe_idx] == 1 &&
+ 						context->bw_ctx.dml.vba.ModeSupport[vlevel][0])
+ 					break;
+ 			/* Impossible to not split this pipe */
+ 			if (vlevel > context->bw_ctx.dml.soc.num_states)
+ 				vlevel = vlevel_split;
+ 			else
+ 				max_mpc_comb = 0;
+ 			pipe_idx++;
+ 		}
+ 		context->bw_ctx.dml.vba.maxMpcComb = max_mpc_comb;
+ 	}
+ 
+ 	/* Split loop sets which pipe should be split based on dml outputs and dc flags */
+ 	for (i = 0, pipe_idx = 0; i < dc->res_pool->pipe_count; i++) {
+ 		struct pipe_ctx *pipe = &context->res_ctx.pipe_ctx[i];
+ 		int pipe_plane = context->bw_ctx.dml.vba.pipe_plane[pipe_idx];
+ 
+ 		if (!context->res_ctx.pipe_ctx[i].stream)
+ 			continue;
+ 
+ 		if (force_split || context->bw_ctx.dml.vba.NoOfDPP[vlevel][context->bw_ctx.dml.vba.maxMpcComb][pipe_plane] > 1)
+ 			split[i] = true;
+ 		if ((pipe->stream->view_format ==
+ 				VIEW_3D_FORMAT_SIDE_BY_SIDE ||
+ 				pipe->stream->view_format ==
+ 				VIEW_3D_FORMAT_TOP_AND_BOTTOM) &&
+ 				(pipe->stream->timing.timing_3d_format ==
+ 				TIMING_3D_FORMAT_TOP_AND_BOTTOM ||
+ 				 pipe->stream->timing.timing_3d_format ==
+ 				TIMING_3D_FORMAT_SIDE_BY_SIDE))
+ 			split[i] = true;
+ 		if (dc->debug.force_odm_combine & (1 << pipe->stream_res.tg->inst)) {
+ 			split[i] = true;
+ 			context->bw_ctx.dml.vba.ODMCombineEnablePerState[vlevel][pipe_plane] = dm_odm_combine_mode_2to1;
+ 		}
+ 		context->bw_ctx.dml.vba.ODMCombineEnabled[pipe_plane] =
+ 			context->bw_ctx.dml.vba.ODMCombineEnablePerState[vlevel][pipe_plane];
+ 
+ 		if (pipe->prev_odm_pipe && context->bw_ctx.dml.vba.ODMCombineEnabled[pipe_plane] != dm_odm_combine_mode_disabled) {
+ 			/*Already split odm pipe tree, don't try to split again*/
+ 			split[i] = false;
+ 			split[pipe->prev_odm_pipe->pipe_idx] = false;
+ 		} else if (pipe->top_pipe && pipe->plane_state == pipe->top_pipe->plane_state
+ 				&& context->bw_ctx.dml.vba.ODMCombineEnabled[pipe_plane] == dm_odm_combine_mode_disabled) {
+ 			/*Already split mpc tree, don't try to split again, assumes only 2x mpc combine*/
+ 			split[i] = false;
+ 			split[pipe->top_pipe->pipe_idx] = false;
+ 		} else if (pipe->prev_odm_pipe || (pipe->top_pipe && pipe->plane_state == pipe->top_pipe->plane_state)) {
+ 			if (split[i] == false) {
+ 				/*Exiting mpc/odm combine*/
+ 				merge[i] = true;
+ 				if (pipe->prev_odm_pipe) {
+ 					ASSERT(0); /*should not actually happen yet*/
+ 					merge[pipe->prev_odm_pipe->pipe_idx] = true;
+ 				} else
+ 					merge[pipe->top_pipe->pipe_idx] = true;
+ 			} else {
+ 				/*Transition from mpc combine to odm combine or vice versa*/
+ 				ASSERT(0); /*should not actually happen yet*/
+ 				split[i] = true;
+ 				merge[i] = true;
+ 				if (pipe->prev_odm_pipe) {
+ 					split[pipe->prev_odm_pipe->pipe_idx] = true;
+ 					merge[pipe->prev_odm_pipe->pipe_idx] = true;
+ 				} else {
+ 					split[pipe->top_pipe->pipe_idx] = true;
+ 					merge[pipe->top_pipe->pipe_idx] = true;
+ 				}
+ 			}
+ 		}
+ 
+ 		/* Adjust dppclk when split is forced, do not bother with dispclk */
+ 		if (split[i] && context->bw_ctx.dml.vba.NoOfDPP[vlevel][context->bw_ctx.dml.vba.maxMpcComb][pipe_idx] == 1)
+ 			context->bw_ctx.dml.vba.RequiredDPPCLK[vlevel][context->bw_ctx.dml.vba.maxMpcComb][pipe_idx] /= 2;
+ 		pipe_idx++;
+ 	}
+ 
+ 	return vlevel;
+ }
+ 
+ bool dcn20_fast_validate_bw(
+ 		struct dc *dc,
+ 		struct dc_state *context,
+ 		display_e2e_pipe_params_st *pipes,
+ 		int *pipe_cnt_out,
+ 		int *pipe_split_from,
+ 		int *vlevel_out)
+ {
+ 	bool out = false;
+ 	bool split[MAX_PIPES] = { false };
+ 	int pipe_cnt, i, pipe_idx, vlevel;
+ 
+ 	ASSERT(pipes);
+ 	if (!pipes)
+ 		return false;
+ 
+ 	dcn20_merge_pipes_for_validate(dc, context);
+ 
+ 	pipe_cnt = dc->res_pool->funcs->populate_dml_pipes(dc, context, pipes);
+ 
+ 	*pipe_cnt_out = pipe_cnt;
++>>>>>>> 1dfedb39d38f (drm/amd/display: Do not disable pipe split if mode is not supported)
  
  	if (!pipe_cnt) {
 +		BW_VAL_TRACE_SKIP(pass);
  		out = true;
  		goto validate_out;
  	}
* Unmerged path drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c
