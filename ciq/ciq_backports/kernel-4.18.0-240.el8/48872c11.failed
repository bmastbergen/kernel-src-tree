net_sched: sch_fq: add dctcp-like marking

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Eric Dumazet <edumazet@google.com>
commit 48872c11b77271ef9b070bdc50afe6655c4eb9aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/48872c11.failed

Similar to 80ba92fa1a92 ("codel: add ce_threshold attribute")

After EDT adoption, it became easier to implement DCTCP-like CE marking.

In many cases, queues are not building in the network fabric but on
the hosts themselves.

If packets leaving fq missed their Earliest Departure Time by XXX usec,
we mark them with ECN CE. This gives a feedback (after one RTT) to
the sender to slow down and find better operating mode.

Example :

tc qd replace dev eth0 root fq ce_threshold 2.5ms

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 48872c11b77271ef9b070bdc50afe6655c4eb9aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sched/sch_fq.c
diff --cc net/sched/sch_fq.c
index f3a0ec615e61,3671eab91107..000000000000
--- a/net/sched/sch_fq.c
+++ b/net/sched/sch_fq.c
@@@ -92,8 -92,9 +92,13 @@@ struct fq_sched_data 
  	u32		quantum;
  	u32		initial_quantum;
  	u32		flow_refill_delay;
 +	u32		flow_max_rate;	/* optional max rate per flow */
  	u32		flow_plimit;	/* max packets per flow */
++<<<<<<< HEAD
++=======
+ 	unsigned long	flow_max_rate;	/* optional max rate per flow */
+ 	u64		ce_threshold;
++>>>>>>> 48872c11b772 (net_sched: sch_fq: add dctcp-like marking)
  	u32		orphan_mask;	/* mask for orphaned skb */
  	u32		low_rate_threshold;
  	struct rb_root	*fq_root;
@@@ -442,11 -446,21 +448,29 @@@ begin
  	}
  
  	skb = f->head;
++<<<<<<< HEAD
 +	if (unlikely(skb && now < f->time_next_packet &&
 +		     !skb_is_tcp_pure_ack(skb))) {
 +		head->first = f->next;
 +		fq_flow_set_throttled(q, f);
 +		goto begin;
++=======
+ 	if (skb) {
+ 		u64 time_next_packet = max_t(u64, ktime_to_ns(skb->tstamp),
+ 					     f->time_next_packet);
+ 
+ 		if (now < time_next_packet) {
+ 			head->first = f->next;
+ 			f->time_next_packet = time_next_packet;
+ 			fq_flow_set_throttled(q, f);
+ 			goto begin;
+ 		}
+ 		if (time_next_packet &&
+ 		    (s64)(now - time_next_packet - q->ce_threshold) > 0) {
+ 			INET_ECN_set_ce(skb);
+ 			q->stat_ce_mark++;
+ 		}
++>>>>>>> 48872c11b772 (net_sched: sch_fq: add dctcp-like marking)
  	}
  
  	skb = fq_dequeue_head(sch, f);
@@@ -777,7 -791,11 +806,15 @@@ static int fq_init(struct Qdisc *sch, s
  	q->fq_trees_log		= ilog2(1024);
  	q->orphan_mask		= 1024 - 1;
  	q->low_rate_threshold	= 550000 / 8;
++<<<<<<< HEAD
 +	qdisc_watchdog_init(&q->watchdog, sch);
++=======
+ 
+ 	/* Default ce_threshold of 4294 seconds */
+ 	q->ce_threshold		= (u64)NSEC_PER_USEC * ~0U;
+ 
+ 	qdisc_watchdog_init_clockid(&q->watchdog, sch, CLOCK_MONOTONIC);
++>>>>>>> 48872c11b772 (net_sched: sch_fq: add dctcp-like marking)
  
  	if (opt)
  		err = fq_change(sch, opt, extack);
@@@ -790,9 -808,10 +827,10 @@@
  static int fq_dump(struct Qdisc *sch, struct sk_buff *skb)
  {
  	struct fq_sched_data *q = qdisc_priv(sch);
+ 	u64 ce_threshold = q->ce_threshold;
  	struct nlattr *opts;
  
 -	opts = nla_nest_start(skb, TCA_OPTIONS);
 +	opts = nla_nest_start_noflag(skb, TCA_OPTIONS);
  	if (opts == NULL)
  		goto nla_put_failure;
  
diff --git a/include/uapi/linux/pkt_sched.h b/include/uapi/linux/pkt_sched.h
index 3a6e8a2da314..5011259b8f67 100644
--- a/include/uapi/linux/pkt_sched.h
+++ b/include/uapi/linux/pkt_sched.h
@@ -892,6 +892,8 @@ enum {
 
 	TCA_FQ_LOW_RATE_THRESHOLD, /* per packet delay under this rate */
 
+	TCA_FQ_CE_THRESHOLD,	/* DCTCP-like CE-marking threshold */
+
 	__TCA_FQ_MAX
 };
 
@@ -910,6 +912,7 @@ struct tc_fq_qd_stats {
 	__u32	inactive_flows;
 	__u32	throttled_flows;
 	__u32	unthrottle_latency_ns;
+	__u64	ce_mark;		/* packets above ce_threshold */
 };
 
 /* Heavy-Hitter Filter */
* Unmerged path net/sched/sch_fq.c
