i2c: replace i2c_new_probed_device with an ERR_PTR variant

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Wolfram Sang <wsa+renesas@sang-engineering.com>
commit c1d084759c95ecd0ef08274654a1f6c4f343cdcd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c1d08475.failed

In the general move to have i2c_new_*_device functions which return
ERR_PTR instead of NULL, this patch converts i2c_new_probed_device().

There are only few users, so this patch converts the I2C core and all
users in one go. The function gets renamed to i2c_new_scanned_device()
so out-of-tree users will get a build failure to understand they need to
adapt their error checking code.

	Signed-off-by: Wolfram Sang <wsa+renesas@sang-engineering.com>
	Reviewed-by: Luca Ceresoli <luca@lucaceresoli.net>
	Reviewed-by: Max Staudt <max@enpas.org>
	Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
(cherry picked from commit c1d084759c95ecd0ef08274654a1f6c4f343cdcd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/i2c/instantiating-devices
diff --cc Documentation/i2c/instantiating-devices
index 0d85ac1935b7,875ebe9e78e3..000000000000
--- a/Documentation/i2c/instantiating-devices
+++ b/Documentation/i2c/instantiating-devices
@@@ -122,14 -123,14 +122,14 @@@ present or not (for example for an opti
  on cheap variants of a board but you have no way to tell them apart), or
  it may have different addresses from one board to the next (manufacturer
  changing its design without notice). In this case, you can call
- i2c_new_probed_device() instead of i2c_new_device().
+ i2c_new_scanned_device() instead of i2c_new_device().
  
 -Example (from the nxp OHCI driver)::
 +Example (from the nxp OHCI driver):
  
 -  static const unsigned short normal_i2c[] = { 0x2c, 0x2d, I2C_CLIENT_END };
 +static const unsigned short normal_i2c[] = { 0x2c, 0x2d, I2C_CLIENT_END };
  
 -  static int usb_hcd_nxp_probe(struct platform_device *pdev)
 -  {
 +static int usb_hcd_nxp_probe(struct platform_device *pdev)
 +{
  	(...)
  	struct i2c_adapter *i2c_adap;
  	struct i2c_board_info i2c_info;
@@@ -137,12 -138,12 +137,18 @@@
  	(...)
  	i2c_adap = i2c_get_adapter(2);
  	memset(&i2c_info, 0, sizeof(struct i2c_board_info));
++<<<<<<< HEAD:Documentation/i2c/instantiating-devices
 +	strlcpy(i2c_info.type, "isp1301_nxp", I2C_NAME_SIZE);
 +	isp1301_i2c_client = i2c_new_probed_device(i2c_adap, &i2c_info,
 +						   normal_i2c, NULL);
++=======
+ 	strscpy(i2c_info.type, "isp1301_nxp", sizeof(i2c_info.type));
+ 	isp1301_i2c_client = i2c_new_scanned_device(i2c_adap, &i2c_info,
+ 						    normal_i2c, NULL);
++>>>>>>> c1d084759c95 (i2c: replace i2c_new_probed_device with an ERR_PTR variant):Documentation/i2c/instantiating-devices.rst
  	i2c_put_adapter(i2c_adap);
  	(...)
 -  }
 +}
  
  The above code instantiates up to 1 I2C device on the I2C bus which is on
  the OHCI adapter in question. It first tries at address 0x2c, if nothing
* Unmerged path Documentation/i2c/instantiating-devices
diff --git a/Documentation/i2c/writing-clients b/Documentation/i2c/writing-clients
index a755b141fa4a..c290ab142f39 100644
--- a/Documentation/i2c/writing-clients
+++ b/Documentation/i2c/writing-clients
@@ -175,14 +175,14 @@ Sometimes you know that a device is connected to a given I2C bus, but you
 don't know the exact address it uses.  This happens on TV adapters for
 example, where the same driver supports dozens of slightly different
 models, and I2C device addresses change from one model to the next.  In
-that case, you can use the i2c_new_probed_device() variant, which is
+that case, you can use the i2c_new_scanned_device() variant, which is
 similar to i2c_new_device(), except that it takes an additional list of
 possible I2C addresses to probe.  A device is created for the first
 responsive address in the list.  If you expect more than one device to be
-present in the address range, simply call i2c_new_probed_device() that
+present in the address range, simply call i2c_new_scanned_device() that
 many times.
 
-The call to i2c_new_device() or i2c_new_probed_device() typically happens
+The call to i2c_new_device() or i2c_new_scanned_device() typically happens
 in the I2C bus driver. You may want to save the returned i2c_client
 reference for later use.
 
@@ -227,7 +227,7 @@ Device Deletion
 ---------------
 
 Each I2C device which has been created using i2c_new_device() or
-i2c_new_probed_device() can be unregistered by calling
+i2c_new_scanned_device() can be unregistered by calling
 i2c_unregister_device().  If you don't call it explicitly, it will be
 called automatically before the underlying I2C bus itself is removed, as a
 device can't survive its parent in the device driver model.
diff --git a/drivers/i2c/i2c-core-base.c b/drivers/i2c/i2c-core-base.c
index 5d0c3ed709bb..a61641912ee7 100644
--- a/drivers/i2c/i2c-core-base.c
+++ b/drivers/i2c/i2c-core-base.c
@@ -2236,10 +2236,10 @@ int i2c_probe_func_quick_read(struct i2c_adapter *adap, unsigned short addr)
 EXPORT_SYMBOL_GPL(i2c_probe_func_quick_read);
 
 struct i2c_client *
-i2c_new_probed_device(struct i2c_adapter *adap,
-		      struct i2c_board_info *info,
-		      unsigned short const *addr_list,
-		      int (*probe)(struct i2c_adapter *adap, unsigned short addr))
+i2c_new_scanned_device(struct i2c_adapter *adap,
+		       struct i2c_board_info *info,
+		       unsigned short const *addr_list,
+		       int (*probe)(struct i2c_adapter *adap, unsigned short addr))
 {
 	int i;
 
@@ -2269,11 +2269,24 @@ i2c_new_probed_device(struct i2c_adapter *adap,
 
 	if (addr_list[i] == I2C_CLIENT_END) {
 		dev_dbg(&adap->dev, "Probing failed, no device found\n");
-		return NULL;
+		return ERR_PTR(-ENODEV);
 	}
 
 	info->addr = addr_list[i];
-	return i2c_new_device(adap, info);
+	return i2c_new_client_device(adap, info);
+}
+EXPORT_SYMBOL_GPL(i2c_new_scanned_device);
+
+struct i2c_client *
+i2c_new_probed_device(struct i2c_adapter *adap,
+		      struct i2c_board_info *info,
+		      unsigned short const *addr_list,
+		      int (*probe)(struct i2c_adapter *adap, unsigned short addr))
+{
+	struct i2c_client *client;
+
+	client = i2c_new_scanned_device(adap, info, addr_list, probe);
+	return IS_ERR(client) ? NULL : client;
 }
 EXPORT_SYMBOL_GPL(i2c_new_probed_device);
 
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 56153566d653..5abc280c14a6 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -469,10 +469,16 @@ i2c_new_client_device(struct i2c_adapter *adap, struct i2c_board_info const *inf
  * a default probing method is used.
  */
 extern struct i2c_client *
+i2c_new_scanned_device(struct i2c_adapter *adap,
+		       struct i2c_board_info *info,
+		       unsigned short const *addr_list,
+		       int (*probe)(struct i2c_adapter *adap, unsigned short addr));
+
+extern struct i2c_client *
 i2c_new_probed_device(struct i2c_adapter *adap,
-		      struct i2c_board_info *info,
-		      unsigned short const *addr_list,
-		      int (*probe)(struct i2c_adapter *adap, unsigned short addr));
+		       struct i2c_board_info *info,
+		       unsigned short const *addr_list,
+		       int (*probe)(struct i2c_adapter *adap, unsigned short addr));
 
 /* Common custom probe functions */
 extern int i2c_probe_func_quick_read(struct i2c_adapter *adap, unsigned short addr);
