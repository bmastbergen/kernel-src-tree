netfilter: nf_tables: fix base chain stat rcu_dereference usage

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit edbd82c5fba009f68d20b5db585be1e667c605f6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/edbd82c5.failed

Following splat gets triggered when nfnetlink monitor is running while
xtables-nft selftests are running:

net/netfilter/nf_tables_api.c:1272 suspicious rcu_dereference_check() usage!
other info that might help us debug this:

1 lock held by xtables-nft-mul/27006:
 #0: 00000000e0f85be9 (&net->nft.commit_mutex){+.+.}, at: nf_tables_valid_genid+0x1a/0x50
Call Trace:
 nf_tables_fill_chain_info.isra.45+0x6cc/0x6e0
 nf_tables_chain_notify+0xf8/0x1a0
 nf_tables_commit+0x165c/0x1740

nf_tables_fill_chain_info() can be called both from dumps (rcu read locked)
or from the transaction path if a userspace process subscribed to nftables
notifications.

In the 'table dump' case, rcu_access_pointer() cannot be used: We do not
hold transaction mutex so the pointer can be NULLed right after the check.
Just unconditionally fetch the value, then have the helper return
immediately if its NULL.

In the notification case we don't hold the rcu read lock, but updates are
prevented due to transaction mutex. Use rcu_dereference_check() to make lockdep
aware of this.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit edbd82c5fba009f68d20b5db585be1e667c605f6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index 3949c819cc35,e4f6ecac48c3..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -1238,9 -1250,10 +1241,10 @@@ static int nf_tables_fill_chain_info(st
  	if (nft_is_base_chain(chain)) {
  		const struct nft_base_chain *basechain = nft_base_chain(chain);
  		const struct nf_hook_ops *ops = &basechain->ops;
+ 		struct nft_stats __percpu *stats;
  		struct nlattr *nest;
  
 -		nest = nla_nest_start(skb, NFTA_CHAIN_HOOK);
 +		nest = nla_nest_start_noflag(skb, NFTA_CHAIN_HOOK);
  		if (nest == NULL)
  			goto nla_put_failure;
  		if (nla_put_be32(skb, NFTA_HOOK_HOOKNUM, htonl(ops->hooknum)))
@@@ -1259,7 -1272,9 +1263,13 @@@
  		if (nla_put_string(skb, NFTA_CHAIN_TYPE, basechain->type->name))
  			goto nla_put_failure;
  
++<<<<<<< HEAD
 +		if (basechain->stats && nft_dump_stats(skb, basechain->stats))
++=======
+ 		stats = rcu_dereference_check(basechain->stats,
+ 					      lockdep_commit_lock_is_held(net));
+ 		if (nft_dump_stats(skb, stats))
++>>>>>>> edbd82c5fba0 (netfilter: nf_tables: fix base chain stat rcu_dereference usage)
  			goto nla_put_failure;
  	}
  
* Unmerged path net/netfilter/nf_tables_api.c
