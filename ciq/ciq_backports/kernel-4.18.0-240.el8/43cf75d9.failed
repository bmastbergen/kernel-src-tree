exit: panic before exit_mm() on global init exit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author chenqiwu <chenqiwu@xiaomi.com>
commit 43cf75d96409a20ef06b756877a2e72b10a026fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/43cf75d9.failed

Currently, when global init and all threads in its thread-group have exited
we panic via:
do_exit()
-> exit_notify()
   -> forget_original_parent()
      -> find_child_reaper()
This makes it hard to extract a useable coredump for global init from a
kernel crashdump because by the time we panic exit_mm() will have already
released global init's mm.
This patch moves the panic futher up before exit_mm() is called. As was the
case previously, we only panic when global init and all its threads in the
thread-group have exited.

	Signed-off-by: chenqiwu <chenqiwu@xiaomi.com>
	Acked-by: Christian Brauner <christian.brauner@ubuntu.com>
	Acked-by: Oleg Nesterov <oleg@redhat.com>
[christian.brauner@ubuntu.com: fix typo, rewrite commit message]
Link: https://lore.kernel.org/r/1576736993-10121-1-git-send-email-qiwuchen55@gmail.com
	Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
(cherry picked from commit 43cf75d96409a20ef06b756877a2e72b10a026fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/exit.c
diff --cc kernel/exit.c
index 3fb7be001964,fc364272759d..000000000000
--- a/kernel/exit.c
+++ b/kernel/exit.c
@@@ -575,10 -517,12 +575,19 @@@ static struct task_struct *find_child_r
  	}
  
  	write_unlock_irq(&tasklist_lock);
++<<<<<<< HEAD
 +	if (unlikely(pid_ns == &init_pid_ns)) {
 +		panic("Attempted to kill init! exitcode=0x%08x\n",
 +			father->signal->group_exit_code ?: father->exit_code);
 +	}
++=======
+ 
+ 	list_for_each_entry_safe(p, n, dead, ptrace_entry) {
+ 		list_del_init(&p->ptrace_entry);
+ 		release_task(p);
+ 	}
+ 
++>>>>>>> 43cf75d96409 (exit: panic before exit_mm() on global init exit)
  	zap_pid_ns_processes(pid_ns);
  	write_lock_irq(&tasklist_lock);
  
* Unmerged path kernel/exit.c
