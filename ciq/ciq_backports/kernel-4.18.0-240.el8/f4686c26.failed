gfs2: read journal in large chunks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Abhi Das <adas@redhat.com>
commit f4686c26ecc34e8e458b8235f0af5198c9b13bfd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f4686c26.failed

Use bios to read in the journal into the address space of the journal inode
(jd_inode), sequentially and in large chunks.  This is faster for locating the
journal head that the previous binary search approach.  When performing
recovery, we keep the journal in the address space until recovery is done,
which further speeds up things.

	Signed-off-by: Abhi Das <adas@redhat.com>
	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit f4686c26ecc34e8e458b8235f0af5198c9b13bfd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/log.c
#	fs/gfs2/lops.c
#	fs/gfs2/lops.h
diff --cc fs/gfs2/log.c
index 5a2ff16daaae,a2e1df488df0..000000000000
--- a/fs/gfs2/log.c
+++ b/fs/gfs2/log.c
@@@ -742,7 -744,7 +742,11 @@@ void gfs2_write_log_header(struct gfs2_
  	lh->lh_crc = cpu_to_be32(crc);
  
  	gfs2_log_write(sdp, page, sb->s_blocksize, 0, dblock);
++<<<<<<< HEAD
 +	gfs2_log_flush_bio(sdp, REQ_OP_WRITE, op_flags);
++=======
+ 	gfs2_log_submit_bio(&sdp->sd_log_bio, REQ_OP_WRITE | op_flags);
++>>>>>>> f4686c26ecc3 (gfs2: read journal in large chunks)
  	log_flush_wait(sdp);
  }
  
@@@ -819,7 -821,7 +823,11 @@@ void gfs2_log_flush(struct gfs2_sbd *sd
  
  	gfs2_ordered_write(sdp);
  	lops_before_commit(sdp, tr);
++<<<<<<< HEAD
 +	gfs2_log_flush_bio(sdp, REQ_OP_WRITE, 0);
++=======
+ 	gfs2_log_submit_bio(&sdp->sd_log_bio, REQ_OP_WRITE);
++>>>>>>> f4686c26ecc3 (gfs2: read journal in large chunks)
  
  	if (sdp->sd_log_head != sdp->sd_log_flush_head) {
  		log_flush_wait(sdp);
diff --cc fs/gfs2/lops.c
index dfac677e2663,ce048a9e058d..000000000000
--- a/fs/gfs2/lops.c
+++ b/fs/gfs2/lops.c
@@@ -228,22 -231,23 +229,38 @@@ static void gfs2_end_log_write(struct b
  }
  
  /**
++<<<<<<< HEAD
 + * gfs2_log_flush_bio - Submit any pending log bio
 + * @sdp: The superblock
 + * @op: REQ_OP
 + * @op_flags: req_flag_bits
++=======
+  * gfs2_log_submit_bio - Submit any pending log bio
+  * @biop: Address of the bio pointer
+  * @opf: REQ_OP | op_flags
++>>>>>>> f4686c26ecc3 (gfs2: read journal in large chunks)
   *
   * Submit any pending part-built or full bio to the block device. If
   * there is no pending bio, then this is a no-op.
   */
  
++<<<<<<< HEAD
 +void gfs2_log_flush_bio(struct gfs2_sbd *sdp, int op, int op_flags)
++=======
+ void gfs2_log_submit_bio(struct bio **biop, int opf)
++>>>>>>> f4686c26ecc3 (gfs2: read journal in large chunks)
  {
 -	struct bio *bio = *biop;
 -	if (bio) {
 -		struct gfs2_sbd *sdp = bio->bi_private;
 +	if (sdp->sd_log_bio) {
  		atomic_inc(&sdp->sd_log_in_flight);
++<<<<<<< HEAD
 +		bio_set_op_attrs(sdp->sd_log_bio, op, op_flags);
 +		submit_bio(sdp->sd_log_bio);
 +		sdp->sd_log_bio = NULL;
++=======
+ 		bio->bi_opf = opf;
+ 		submit_bio(bio);
+ 		*biop = NULL;
++>>>>>>> f4686c26ecc3 (gfs2: read journal in large chunks)
  	}
  }
  
@@@ -291,20 -293,24 +308,24 @@@ static struct bio *gfs2_log_alloc_bio(s
   * Returns: The bio to use for log writes
   */
  
 -static struct bio *gfs2_log_get_bio(struct gfs2_sbd *sdp, u64 blkno,
 -				    struct bio **biop, int op,
 -				    bio_end_io_t *end_io, bool flush)
 +static struct bio *gfs2_log_get_bio(struct gfs2_sbd *sdp, u64 blkno)
  {
 -	struct bio *bio = *biop;
 +	struct bio *bio = sdp->sd_log_bio;
 +	u64 nblk;
  
  	if (bio) {
 -		u64 nblk;
 -
  		nblk = bio_end_sector(bio);
  		nblk >>= sdp->sd_fsb2bb_shift;
 -		if (blkno == nblk && !flush)
 +		if (blkno == nblk)
  			return bio;
++<<<<<<< HEAD
 +		gfs2_log_flush_bio(sdp, REQ_OP_WRITE, 0);
++=======
+ 		gfs2_log_submit_bio(biop, op);
++>>>>>>> f4686c26ecc3 (gfs2: read journal in large chunks)
  	}
  
 -	*biop = gfs2_log_alloc_bio(sdp, blkno, end_io);
 -	return *biop;
 +	return gfs2_log_alloc_bio(sdp, blkno);
  }
  
  /**
diff --cc fs/gfs2/lops.h
index 7deadcf9fbb9,f195ffb435ac..000000000000
--- a/fs/gfs2/lops.h
+++ b/fs/gfs2/lops.h
@@@ -30,8 -25,10 +30,14 @@@ extern u64 gfs2_log_bmap(struct gfs2_sb
  extern void gfs2_log_write(struct gfs2_sbd *sdp, struct page *page,
  			   unsigned size, unsigned offset, u64 blkno);
  extern void gfs2_log_write_page(struct gfs2_sbd *sdp, struct page *page);
++<<<<<<< HEAD
 +extern void gfs2_log_flush_bio(struct gfs2_sbd *sdp, int op, int op_flags);
++=======
+ extern void gfs2_log_submit_bio(struct bio **biop, int opf);
++>>>>>>> f4686c26ecc3 (gfs2: read journal in large chunks)
  extern void gfs2_pin(struct gfs2_sbd *sdp, struct buffer_head *bh);
+ extern int gfs2_find_jhead(struct gfs2_jdesc *jd,
+ 			   struct gfs2_log_header_host *head, bool keep_cache);
  
  static inline unsigned int buf_limit(struct gfs2_sbd *sdp)
  {
diff --git a/fs/gfs2/glops.c b/fs/gfs2/glops.c
index c63bee9adb6a..7a056b7facda 100644
--- a/fs/gfs2/glops.c
+++ b/fs/gfs2/glops.c
@@ -28,6 +28,7 @@
 #include "util.h"
 #include "trans.h"
 #include "dir.h"
+#include "lops.h"
 
 struct workqueue_struct *gfs2_freeze_wq;
 
@@ -523,7 +524,7 @@ static int freeze_go_xmote_bh(struct gfs2_glock *gl, struct gfs2_holder *gh)
 	if (test_bit(SDF_JOURNAL_LIVE, &sdp->sd_flags)) {
 		j_gl->gl_ops->go_inval(j_gl, DIO_METADATA);
 
-		error = gfs2_find_jhead(sdp->sd_jdesc, &head);
+		error = gfs2_find_jhead(sdp->sd_jdesc, &head, false);
 		if (error)
 			gfs2_consist(sdp);
 		if (!(head.lh_flags & GFS2_LOG_HEAD_UNMOUNT))
* Unmerged path fs/gfs2/log.c
* Unmerged path fs/gfs2/lops.c
* Unmerged path fs/gfs2/lops.h
diff --git a/fs/gfs2/ops_fstype.c b/fs/gfs2/ops_fstype.c
index f709e79d43e7..be78385f883f 100644
--- a/fs/gfs2/ops_fstype.c
+++ b/fs/gfs2/ops_fstype.c
@@ -41,6 +41,7 @@
 #include "dir.h"
 #include "meta_io.h"
 #include "trace_gfs2.h"
+#include "lops.h"
 
 #define DO 0
 #define UNDO 1
@@ -625,7 +626,7 @@ static int check_journal_clean(struct gfs2_sbd *sdp, struct gfs2_jdesc *jd)
 		fs_err(sdp, "Error checking journal for spectator mount.\n");
 		goto out_unlock;
 	}
-	error = gfs2_find_jhead(jd, &head);
+	error = gfs2_find_jhead(jd, &head, false);
 	if (error) {
 		fs_err(sdp, "Error parsing journal for spectator mount.\n");
 		goto out_unlock;
diff --git a/fs/gfs2/recovery.c b/fs/gfs2/recovery.c
index fa575d1676b9..389b3ef77e20 100644
--- a/fs/gfs2/recovery.c
+++ b/fs/gfs2/recovery.c
@@ -181,129 +181,6 @@ static int get_log_header(struct gfs2_jdesc *jd, unsigned int blk,
 	return error;
 }
 
-/**
- * find_good_lh - find a good log header
- * @jd: the journal
- * @blk: the segment to start searching from
- * @lh: the log header to fill in
- * @forward: if true search forward in the log, else search backward
- *
- * Call get_log_header() to get a log header for a segment, but if the
- * segment is bad, either scan forward or backward until we find a good one.
- *
- * Returns: errno
- */
-
-static int find_good_lh(struct gfs2_jdesc *jd, unsigned int *blk,
-			struct gfs2_log_header_host *head)
-{
-	unsigned int orig_blk = *blk;
-	int error;
-
-	for (;;) {
-		error = get_log_header(jd, *blk, head);
-		if (error <= 0)
-			return error;
-
-		if (++*blk == jd->jd_blocks)
-			*blk = 0;
-
-		if (*blk == orig_blk) {
-			gfs2_consist_inode(GFS2_I(jd->jd_inode));
-			return -EIO;
-		}
-	}
-}
-
-/**
- * jhead_scan - make sure we've found the head of the log
- * @jd: the journal
- * @head: this is filled in with the log descriptor of the head
- *
- * At this point, seg and lh should be either the head of the log or just
- * before.  Scan forward until we find the head.
- *
- * Returns: errno
- */
-
-static int jhead_scan(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)
-{
-	unsigned int blk = head->lh_blkno;
-	struct gfs2_log_header_host lh;
-	int error;
-
-	for (;;) {
-		if (++blk == jd->jd_blocks)
-			blk = 0;
-
-		error = get_log_header(jd, blk, &lh);
-		if (error < 0)
-			return error;
-		if (error == 1)
-			continue;
-
-		if (lh.lh_sequence == head->lh_sequence) {
-			gfs2_consist_inode(GFS2_I(jd->jd_inode));
-			return -EIO;
-		}
-		if (lh.lh_sequence < head->lh_sequence)
-			break;
-
-		*head = lh;
-	}
-
-	return 0;
-}
-
-/**
- * gfs2_find_jhead - find the head of a log
- * @jd: the journal
- * @head: the log descriptor for the head of the log is returned here
- *
- * Do a binary search of a journal and find the valid log entry with the
- * highest sequence number.  (i.e. the log head)
- *
- * Returns: errno
- */
-
-int gfs2_find_jhead(struct gfs2_jdesc *jd, struct gfs2_log_header_host *head)
-{
-	struct gfs2_log_header_host lh_1, lh_m;
-	u32 blk_1, blk_2, blk_m;
-	int error;
-
-	blk_1 = 0;
-	blk_2 = jd->jd_blocks - 1;
-
-	for (;;) {
-		blk_m = (blk_1 + blk_2) / 2;
-
-		error = find_good_lh(jd, &blk_1, &lh_1);
-		if (error)
-			return error;
-
-		error = find_good_lh(jd, &blk_m, &lh_m);
-		if (error)
-			return error;
-
-		if (blk_1 == blk_m || blk_m == blk_2)
-			break;
-
-		if (lh_1.lh_sequence <= lh_m.lh_sequence)
-			blk_1 = blk_m;
-		else
-			blk_2 = blk_m;
-	}
-
-	error = jhead_scan(jd, &lh_1);
-	if (error)
-		return error;
-
-	*head = lh_1;
-
-	return error;
-}
-
 /**
  * foreach_descriptor - go through the active part of the log
  * @jd: the journal
@@ -469,7 +346,7 @@ void gfs2_recover_func(struct work_struct *work)
 	if (error)
 		goto fail_gunlock_ji;
 
-	error = gfs2_find_jhead(jd, &head);
+	error = gfs2_find_jhead(jd, &head, true);
 	if (error)
 		goto fail_gunlock_ji;
 	t_jhd = ktime_get();
diff --git a/fs/gfs2/recovery.h b/fs/gfs2/recovery.h
index 5932d4b6f43e..1831a1974c8c 100644
--- a/fs/gfs2/recovery.h
+++ b/fs/gfs2/recovery.h
@@ -27,8 +27,6 @@ extern int gfs2_revoke_add(struct gfs2_jdesc *jd, u64 blkno, unsigned int where)
 extern int gfs2_revoke_check(struct gfs2_jdesc *jd, u64 blkno, unsigned int where);
 extern void gfs2_revoke_clean(struct gfs2_jdesc *jd);
 
-extern int gfs2_find_jhead(struct gfs2_jdesc *jd,
-		    struct gfs2_log_header_host *head);
 extern int gfs2_recover_journal(struct gfs2_jdesc *gfs2_jd, bool wait);
 extern void gfs2_recover_func(struct work_struct *work);
 extern int __get_log_header(struct gfs2_sbd *sdp,
diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c
index 54e9fed68925..bdd23e199661 100644
--- a/fs/gfs2/super.c
+++ b/fs/gfs2/super.c
@@ -45,6 +45,7 @@
 #include "util.h"
 #include "sys.h"
 #include "xattr.h"
+#include "lops.h"
 
 #define args_neq(a1, a2, x) ((a1)->ar_##x != (a2)->ar_##x)
 
@@ -425,7 +426,7 @@ int gfs2_make_fs_rw(struct gfs2_sbd *sdp)
 
 	j_gl->gl_ops->go_inval(j_gl, DIO_METADATA);
 
-	error = gfs2_find_jhead(sdp->sd_jdesc, &head);
+	error = gfs2_find_jhead(sdp->sd_jdesc, &head, false);
 	if (error)
 		goto fail;
 
@@ -680,7 +681,7 @@ static int gfs2_lock_fs_check_clean(struct gfs2_sbd *sdp,
 		error = gfs2_jdesc_check(jd);
 		if (error)
 			break;
-		error = gfs2_find_jhead(jd, &lh);
+		error = gfs2_find_jhead(jd, &lh, false);
 		if (error)
 			break;
 		if (!(lh.lh_flags & GFS2_LOG_HEAD_UNMOUNT)) {
