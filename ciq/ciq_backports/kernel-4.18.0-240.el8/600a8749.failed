Bluetooth: Implementation of MGMT_OP_SET_BLOCKED_KEYS.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] Bluetooth: Implementation of MGMT_OP_SET_BLOCKED_KEYS (Gopal Tiwari) [1838924]
Rebuild_FUZZ: 99.07%
commit-author Alain Michaud <alainm@chromium.org>
commit 600a87490ff9823d065fc15e86c709e707033ecc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/600a8749.failed

MGMT command is added to receive the list of blocked keys from
user-space.

The list is used to:
1) Block keys from being distributed by the device during
   the ke distribution phase of SMP.
2) Filter out any keys that were previously saved so
   they are no longer used.

	Signed-off-by: Alain Michaud <alainm@chromium.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 600a87490ff9823d065fc15e86c709e707033ecc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/bluetooth/mgmt.h
#	net/bluetooth/mgmt.c
diff --cc include/net/bluetooth/mgmt.h
index e7303eee65cd,a90666af05bd..000000000000
--- a/include/net/bluetooth/mgmt.h
+++ b/include/net/bluetooth/mgmt.h
@@@ -604,6 -611,66 +604,69 @@@ struct mgmt_cp_set_appearance 
  } __packed;
  #define MGMT_SET_APPEARANCE_SIZE	2
  
++<<<<<<< HEAD
++=======
+ #define MGMT_OP_GET_PHY_CONFIGURATION	0x0044
+ struct mgmt_rp_get_phy_confguration {
+ 	__le32	supported_phys;
+ 	__le32	configurable_phys;
+ 	__le32	selected_phys;
+ } __packed;
+ #define MGMT_GET_PHY_CONFIGURATION_SIZE	0
+ 
+ #define MGMT_PHY_BR_1M_1SLOT	0x00000001
+ #define MGMT_PHY_BR_1M_3SLOT	0x00000002
+ #define MGMT_PHY_BR_1M_5SLOT	0x00000004
+ #define MGMT_PHY_EDR_2M_1SLOT	0x00000008
+ #define MGMT_PHY_EDR_2M_3SLOT	0x00000010
+ #define MGMT_PHY_EDR_2M_5SLOT	0x00000020
+ #define MGMT_PHY_EDR_3M_1SLOT	0x00000040
+ #define MGMT_PHY_EDR_3M_3SLOT	0x00000080
+ #define MGMT_PHY_EDR_3M_5SLOT	0x00000100
+ #define MGMT_PHY_LE_1M_TX		0x00000200
+ #define MGMT_PHY_LE_1M_RX		0x00000400
+ #define MGMT_PHY_LE_2M_TX		0x00000800
+ #define MGMT_PHY_LE_2M_RX		0x00001000
+ #define MGMT_PHY_LE_CODED_TX	0x00002000
+ #define MGMT_PHY_LE_CODED_RX	0x00004000
+ 
+ #define MGMT_PHY_BREDR_MASK (MGMT_PHY_BR_1M_1SLOT | MGMT_PHY_BR_1M_3SLOT | \
+ 			     MGMT_PHY_BR_1M_5SLOT | MGMT_PHY_EDR_2M_1SLOT | \
+ 			     MGMT_PHY_EDR_2M_3SLOT | MGMT_PHY_EDR_2M_5SLOT | \
+ 			     MGMT_PHY_EDR_3M_1SLOT | MGMT_PHY_EDR_3M_3SLOT | \
+ 			     MGMT_PHY_EDR_3M_5SLOT)
+ #define MGMT_PHY_LE_MASK (MGMT_PHY_LE_1M_TX | MGMT_PHY_LE_1M_RX | \
+ 			  MGMT_PHY_LE_2M_TX | MGMT_PHY_LE_2M_RX | \
+ 			  MGMT_PHY_LE_CODED_TX | MGMT_PHY_LE_CODED_RX)
+ #define MGMT_PHY_LE_TX_MASK (MGMT_PHY_LE_1M_TX | MGMT_PHY_LE_2M_TX | \
+ 			     MGMT_PHY_LE_CODED_TX)
+ #define MGMT_PHY_LE_RX_MASK (MGMT_PHY_LE_1M_RX | MGMT_PHY_LE_2M_RX | \
+ 			     MGMT_PHY_LE_CODED_RX)
+ 
+ #define MGMT_OP_SET_PHY_CONFIGURATION	0x0045
+ struct mgmt_cp_set_phy_confguration {
+ 	__le32	selected_phys;
+ } __packed;
+ #define MGMT_SET_PHY_CONFIGURATION_SIZE	4
+ 
+ #define MGMT_OP_SET_BLOCKED_KEYS	0x0046
+ 
+ #define HCI_BLOCKED_KEY_TYPE_LINKKEY	0x00
+ #define HCI_BLOCKED_KEY_TYPE_LTK	0x01
+ #define HCI_BLOCKED_KEY_TYPE_IRK	0x02
+ 
+ struct mgmt_blocked_key_info {
+ 	__u8 type;
+ 	__u8 val[16];
+ } __packed;
+ 
+ struct mgmt_cp_set_blocked_keys {
+ 	__le16 key_count;
+ 	struct mgmt_blocked_key_info keys[0];
+ } __packed;
+ #define MGMT_OP_SET_BLOCKED_KEYS_SIZE 2
+ 
++>>>>>>> 600a87490ff9 (Bluetooth: Implementation of MGMT_OP_SET_BLOCKED_KEYS.)
  #define MGMT_EV_CMD_COMPLETE		0x0001
  struct mgmt_ev_cmd_complete {
  	__le16	opcode;
diff --cc net/bluetooth/mgmt.c
index 267d30edbce5,339c762eb6fd..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -3182,6 -3321,274 +3191,277 @@@ static int set_appearance(struct sock *
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int get_phy_configuration(struct sock *sk, struct hci_dev *hdev,
+ 				 void *data, u16 len)
+ {
+ 	struct mgmt_rp_get_phy_confguration rp;
+ 
+ 	BT_DBG("sock %p %s", sk, hdev->name);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	memset(&rp, 0, sizeof(rp));
+ 
+ 	rp.supported_phys = cpu_to_le32(get_supported_phys(hdev));
+ 	rp.selected_phys = cpu_to_le32(get_selected_phys(hdev));
+ 	rp.configurable_phys = cpu_to_le32(get_configurable_phys(hdev));
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_PHY_CONFIGURATION, 0,
+ 				 &rp, sizeof(rp));
+ }
+ 
+ int mgmt_phy_configuration_changed(struct hci_dev *hdev, struct sock *skip)
+ {
+ 	struct mgmt_ev_phy_configuration_changed ev;
+ 
+ 	memset(&ev, 0, sizeof(ev));
+ 
+ 	ev.selected_phys = cpu_to_le32(get_selected_phys(hdev));
+ 
+ 	return mgmt_event(MGMT_EV_PHY_CONFIGURATION_CHANGED, hdev, &ev,
+ 			  sizeof(ev), skip);
+ }
+ 
+ static void set_default_phy_complete(struct hci_dev *hdev, u8 status,
+ 				     u16 opcode, struct sk_buff *skb)
+ {
+ 	struct mgmt_pending_cmd *cmd;
+ 
+ 	BT_DBG("status 0x%02x", status);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	cmd = pending_find(MGMT_OP_SET_PHY_CONFIGURATION, hdev);
+ 	if (!cmd)
+ 		goto unlock;
+ 
+ 	if (status) {
+ 		mgmt_cmd_status(cmd->sk, hdev->id,
+ 				MGMT_OP_SET_PHY_CONFIGURATION,
+ 				mgmt_status(status));
+ 	} else {
+ 		mgmt_cmd_complete(cmd->sk, hdev->id,
+ 				  MGMT_OP_SET_PHY_CONFIGURATION, 0,
+ 				  NULL, 0);
+ 
+ 		mgmt_phy_configuration_changed(hdev, cmd->sk);
+ 	}
+ 
+ 	mgmt_pending_remove(cmd);
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ }
+ 
+ static int set_phy_configuration(struct sock *sk, struct hci_dev *hdev,
+ 				 void *data, u16 len)
+ {
+ 	struct mgmt_cp_set_phy_confguration *cp = data;
+ 	struct hci_cp_le_set_default_phy cp_phy;
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct hci_request req;
+ 	u32 selected_phys, configurable_phys, supported_phys, unconfigure_phys;
+ 	u16 pkt_type = (HCI_DH1 | HCI_DM1);
+ 	bool changed = false;
+ 	int err;
+ 
+ 	BT_DBG("sock %p %s", sk, hdev->name);
+ 
+ 	configurable_phys = get_configurable_phys(hdev);
+ 	supported_phys = get_supported_phys(hdev);
+ 	selected_phys = __le32_to_cpu(cp->selected_phys);
+ 
+ 	if (selected_phys & ~supported_phys)
+ 		return mgmt_cmd_status(sk, hdev->id,
+ 				       MGMT_OP_SET_PHY_CONFIGURATION,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	unconfigure_phys = supported_phys & ~configurable_phys;
+ 
+ 	if ((selected_phys & unconfigure_phys) != unconfigure_phys)
+ 		return mgmt_cmd_status(sk, hdev->id,
+ 				       MGMT_OP_SET_PHY_CONFIGURATION,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	if (selected_phys == get_selected_phys(hdev))
+ 		return mgmt_cmd_complete(sk, hdev->id,
+ 					 MGMT_OP_SET_PHY_CONFIGURATION,
+ 					 0, NULL, 0);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (!hdev_is_powered(hdev)) {
+ 		err = mgmt_cmd_status(sk, hdev->id,
+ 				      MGMT_OP_SET_PHY_CONFIGURATION,
+ 				      MGMT_STATUS_REJECTED);
+ 		goto unlock;
+ 	}
+ 
+ 	if (pending_find(MGMT_OP_SET_PHY_CONFIGURATION, hdev)) {
+ 		err = mgmt_cmd_status(sk, hdev->id,
+ 				      MGMT_OP_SET_PHY_CONFIGURATION,
+ 				      MGMT_STATUS_BUSY);
+ 		goto unlock;
+ 	}
+ 
+ 	if (selected_phys & MGMT_PHY_BR_1M_3SLOT)
+ 		pkt_type |= (HCI_DH3 | HCI_DM3);
+ 	else
+ 		pkt_type &= ~(HCI_DH3 | HCI_DM3);
+ 
+ 	if (selected_phys & MGMT_PHY_BR_1M_5SLOT)
+ 		pkt_type |= (HCI_DH5 | HCI_DM5);
+ 	else
+ 		pkt_type &= ~(HCI_DH5 | HCI_DM5);
+ 
+ 	if (selected_phys & MGMT_PHY_EDR_2M_1SLOT)
+ 		pkt_type &= ~HCI_2DH1;
+ 	else
+ 		pkt_type |= HCI_2DH1;
+ 
+ 	if (selected_phys & MGMT_PHY_EDR_2M_3SLOT)
+ 		pkt_type &= ~HCI_2DH3;
+ 	else
+ 		pkt_type |= HCI_2DH3;
+ 
+ 	if (selected_phys & MGMT_PHY_EDR_2M_5SLOT)
+ 		pkt_type &= ~HCI_2DH5;
+ 	else
+ 		pkt_type |= HCI_2DH5;
+ 
+ 	if (selected_phys & MGMT_PHY_EDR_3M_1SLOT)
+ 		pkt_type &= ~HCI_3DH1;
+ 	else
+ 		pkt_type |= HCI_3DH1;
+ 
+ 	if (selected_phys & MGMT_PHY_EDR_3M_3SLOT)
+ 		pkt_type &= ~HCI_3DH3;
+ 	else
+ 		pkt_type |= HCI_3DH3;
+ 
+ 	if (selected_phys & MGMT_PHY_EDR_3M_5SLOT)
+ 		pkt_type &= ~HCI_3DH5;
+ 	else
+ 		pkt_type |= HCI_3DH5;
+ 
+ 	if (pkt_type != hdev->pkt_type) {
+ 		hdev->pkt_type = pkt_type;
+ 		changed = true;
+ 	}
+ 
+ 	if ((selected_phys & MGMT_PHY_LE_MASK) ==
+ 	    (get_selected_phys(hdev) & MGMT_PHY_LE_MASK)) {
+ 		if (changed)
+ 			mgmt_phy_configuration_changed(hdev, sk);
+ 
+ 		err = mgmt_cmd_complete(sk, hdev->id,
+ 					MGMT_OP_SET_PHY_CONFIGURATION,
+ 					0, NULL, 0);
+ 
+ 		goto unlock;
+ 	}
+ 
+ 	cmd = mgmt_pending_add(sk, MGMT_OP_SET_PHY_CONFIGURATION, hdev, data,
+ 			       len);
+ 	if (!cmd) {
+ 		err = -ENOMEM;
+ 		goto unlock;
+ 	}
+ 
+ 	hci_req_init(&req, hdev);
+ 
+ 	memset(&cp_phy, 0, sizeof(cp_phy));
+ 
+ 	if (!(selected_phys & MGMT_PHY_LE_TX_MASK))
+ 		cp_phy.all_phys |= 0x01;
+ 
+ 	if (!(selected_phys & MGMT_PHY_LE_RX_MASK))
+ 		cp_phy.all_phys |= 0x02;
+ 
+ 	if (selected_phys & MGMT_PHY_LE_1M_TX)
+ 		cp_phy.tx_phys |= HCI_LE_SET_PHY_1M;
+ 
+ 	if (selected_phys & MGMT_PHY_LE_2M_TX)
+ 		cp_phy.tx_phys |= HCI_LE_SET_PHY_2M;
+ 
+ 	if (selected_phys & MGMT_PHY_LE_CODED_TX)
+ 		cp_phy.tx_phys |= HCI_LE_SET_PHY_CODED;
+ 
+ 	if (selected_phys & MGMT_PHY_LE_1M_RX)
+ 		cp_phy.rx_phys |= HCI_LE_SET_PHY_1M;
+ 
+ 	if (selected_phys & MGMT_PHY_LE_2M_RX)
+ 		cp_phy.rx_phys |= HCI_LE_SET_PHY_2M;
+ 
+ 	if (selected_phys & MGMT_PHY_LE_CODED_RX)
+ 		cp_phy.rx_phys |= HCI_LE_SET_PHY_CODED;
+ 
+ 	hci_req_add(&req, HCI_OP_LE_SET_DEFAULT_PHY, sizeof(cp_phy), &cp_phy);
+ 
+ 	err = hci_req_run_skb(&req, set_default_phy_complete);
+ 	if (err < 0)
+ 		mgmt_pending_remove(cmd);
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 
+ 	return err;
+ }
+ 
+ static int set_blocked_keys(struct sock *sk, struct hci_dev *hdev, void *data,
+ 			    u16 len)
+ {
+ 	int err = MGMT_STATUS_SUCCESS;
+ 	struct mgmt_cp_set_blocked_keys *keys = data;
+ 	const u16 max_key_count = ((U16_MAX - sizeof(*keys)) /
+ 				   sizeof(struct mgmt_blocked_key_info));
+ 	u16 key_count, expected_len;
+ 	int i;
+ 
+ 	BT_DBG("request for %s", hdev->name);
+ 
+ 	key_count = __le16_to_cpu(keys->key_count);
+ 	if (key_count > max_key_count) {
+ 		bt_dev_err(hdev, "too big key_count value %u", key_count);
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 	}
+ 
+ 	expected_len = struct_size(keys, keys, key_count);
+ 	if (expected_len != len) {
+ 		bt_dev_err(hdev, "expected %u bytes, got %u bytes",
+ 			   expected_len, len);
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 	}
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	hci_blocked_keys_clear(hdev);
+ 
+ 	for (i = 0; i < keys->key_count; ++i) {
+ 		struct blocked_key *b = kzalloc(sizeof(*b), GFP_KERNEL);
+ 
+ 		if (!b) {
+ 			err = MGMT_STATUS_NO_RESOURCES;
+ 			break;
+ 		}
+ 
+ 		b->type = keys->keys[i].type;
+ 		memcpy(b->val, keys->keys[i].val, sizeof(b->val));
+ 		list_add_rcu(&b->list, &hdev->blocked_keys);
+ 	}
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
+ 				err, NULL, 0);
+ }
+ 
++>>>>>>> 600a87490ff9 (Bluetooth: Implementation of MGMT_OP_SET_BLOCKED_KEYS.)
  static void read_local_oob_data_complete(struct hci_dev *hdev, u8 status,
  				         u16 opcode, struct sk_buff *skb)
  {
@@@ -6542,6 -6986,10 +6838,13 @@@ static const struct hci_mgmt_handler mg
  	{ read_ext_controller_info,MGMT_READ_EXT_INFO_SIZE,
  						HCI_MGMT_UNTRUSTED },
  	{ set_appearance,	   MGMT_SET_APPEARANCE_SIZE },
++<<<<<<< HEAD
++=======
+ 	{ get_phy_configuration,   MGMT_GET_PHY_CONFIGURATION_SIZE },
+ 	{ set_phy_configuration,   MGMT_SET_PHY_CONFIGURATION_SIZE },
+ 	{ set_blocked_keys,	   MGMT_OP_SET_BLOCKED_KEYS_SIZE,
+ 						HCI_MGMT_VAR_LEN },
++>>>>>>> 600a87490ff9 (Bluetooth: Implementation of MGMT_OP_SET_BLOCKED_KEYS.)
  };
  
  void mgmt_index_added(struct hci_dev *hdev)
diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 00925c9f4194..6b3a8f889e8d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -110,6 +110,13 @@ struct bt_uuid {
 	u8 svc_hint;
 };
 
+struct blocked_key {
+	struct list_head list;
+	struct rcu_head rcu;
+	u8 type;
+	u8 val[16];
+};
+
 struct smp_csrk {
 	bdaddr_t bdaddr;
 	u8 bdaddr_type;
@@ -373,6 +380,7 @@ struct hci_dev {
 	struct list_head	le_conn_params;
 	struct list_head	pend_le_conns;
 	struct list_head	pend_le_reports;
+	struct list_head	blocked_keys;
 
 	struct hci_dev_stats	stat;
 
@@ -1088,6 +1096,8 @@ struct smp_irk *hci_find_irk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
 struct smp_irk *hci_add_irk(struct hci_dev *hdev, bdaddr_t *bdaddr,
 			    u8 addr_type, u8 val[16], bdaddr_t *rpa);
 void hci_remove_irk(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 addr_type);
+bool hci_is_blocked_key(struct hci_dev *hdev, u8 type, u8 val[16]);
+void hci_blocked_keys_clear(struct hci_dev *hdev);
 void hci_smp_irks_clear(struct hci_dev *hdev);
 
 bool hci_bdaddr_is_paired(struct hci_dev *hdev, bdaddr_t *bdaddr, u8 type);
* Unmerged path include/net/bluetooth/mgmt.h
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index af17f2e4031d..f4bd7fc77fe8 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -2189,6 +2189,33 @@ void hci_smp_irks_clear(struct hci_dev *hdev)
 	}
 }
 
+void hci_blocked_keys_clear(struct hci_dev *hdev)
+{
+	struct blocked_key *b;
+
+	list_for_each_entry_rcu(b, &hdev->blocked_keys, list) {
+		list_del_rcu(&b->list);
+		kfree_rcu(b, rcu);
+	}
+}
+
+bool hci_is_blocked_key(struct hci_dev *hdev, u8 type, u8 val[16])
+{
+	bool blocked = false;
+	struct blocked_key *b;
+
+	rcu_read_lock();
+	list_for_each_entry(b, &hdev->blocked_keys, list) {
+		if (b->type == type && !memcmp(b->val, val, sizeof(b->val))) {
+			blocked = true;
+			break;
+		}
+	}
+
+	rcu_read_unlock();
+	return blocked;
+}
+
 struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr)
 {
 	struct link_key *k;
@@ -2197,6 +2224,16 @@ struct link_key *hci_find_link_key(struct hci_dev *hdev, bdaddr_t *bdaddr)
 	list_for_each_entry_rcu(k, &hdev->link_keys, list) {
 		if (bacmp(bdaddr, &k->bdaddr) == 0) {
 			rcu_read_unlock();
+
+			if (hci_is_blocked_key(hdev,
+					       HCI_BLOCKED_KEY_TYPE_LINKKEY,
+					       k->val)) {
+				bt_dev_warn_ratelimited(hdev,
+							"Link key blocked for %pMR",
+							&k->bdaddr);
+				return NULL;
+			}
+
 			return k;
 		}
 	}
@@ -2265,6 +2302,15 @@ struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,
 
 		if (smp_ltk_is_sc(k) || ltk_role(k->type) == role) {
 			rcu_read_unlock();
+
+			if (hci_is_blocked_key(hdev, HCI_BLOCKED_KEY_TYPE_LTK,
+					       k->val)) {
+				bt_dev_warn_ratelimited(hdev,
+							"LTK blocked for %pMR",
+							&k->bdaddr);
+				return NULL;
+			}
+
 			return k;
 		}
 	}
@@ -2275,31 +2321,42 @@ struct smp_ltk *hci_find_ltk(struct hci_dev *hdev, bdaddr_t *bdaddr,
 
 struct smp_irk *hci_find_irk_by_rpa(struct hci_dev *hdev, bdaddr_t *rpa)
 {
+	struct smp_irk *irk_to_return = NULL;
 	struct smp_irk *irk;
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(irk, &hdev->identity_resolving_keys, list) {
 		if (!bacmp(&irk->rpa, rpa)) {
-			rcu_read_unlock();
-			return irk;
+			irk_to_return = irk;
+			goto done;
 		}
 	}
 
 	list_for_each_entry_rcu(irk, &hdev->identity_resolving_keys, list) {
 		if (smp_irk_matches(hdev, irk->val, rpa)) {
 			bacpy(&irk->rpa, rpa);
-			rcu_read_unlock();
-			return irk;
+			irk_to_return = irk;
+			goto done;
 		}
 	}
+
+done:
+	if (irk_to_return && hci_is_blocked_key(hdev, HCI_BLOCKED_KEY_TYPE_IRK,
+						irk_to_return->val)) {
+		bt_dev_warn_ratelimited(hdev, "Identity key blocked for %pMR",
+					&irk_to_return->bdaddr);
+		irk_to_return = NULL;
+	}
+
 	rcu_read_unlock();
 
-	return NULL;
+	return irk_to_return;
 }
 
 struct smp_irk *hci_find_irk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
 				     u8 addr_type)
 {
+	struct smp_irk *irk_to_return = NULL;
 	struct smp_irk *irk;
 
 	/* Identity Address must be public or static random */
@@ -2310,13 +2367,23 @@ struct smp_irk *hci_find_irk_by_addr(struct hci_dev *hdev, bdaddr_t *bdaddr,
 	list_for_each_entry_rcu(irk, &hdev->identity_resolving_keys, list) {
 		if (addr_type == irk->addr_type &&
 		    bacmp(bdaddr, &irk->bdaddr) == 0) {
-			rcu_read_unlock();
-			return irk;
+			irk_to_return = irk;
+			goto done;
 		}
 	}
+
+done:
+
+	if (irk_to_return && hci_is_blocked_key(hdev, HCI_BLOCKED_KEY_TYPE_IRK,
+						irk_to_return->val)) {
+		bt_dev_warn_ratelimited(hdev, "Identity key blocked for %pMR",
+					&irk_to_return->bdaddr);
+		irk_to_return = NULL;
+	}
+
 	rcu_read_unlock();
 
-	return NULL;
+	return irk_to_return;
 }
 
 struct link_key *hci_add_link_key(struct hci_dev *hdev, struct hci_conn *conn,
@@ -3022,6 +3089,7 @@ struct hci_dev *hci_alloc_dev(void)
 	INIT_LIST_HEAD(&hdev->pend_le_reports);
 	INIT_LIST_HEAD(&hdev->conn_hash.list);
 	INIT_LIST_HEAD(&hdev->adv_instances);
+	INIT_LIST_HEAD(&hdev->blocked_keys);
 
 	INIT_WORK(&hdev->rx_work, hci_rx_work);
 	INIT_WORK(&hdev->cmd_work, hci_cmd_work);
@@ -3220,6 +3288,7 @@ void hci_unregister_dev(struct hci_dev *hdev)
 	hci_bdaddr_list_clear(&hdev->le_white_list);
 	hci_conn_params_clear_all(hdev);
 	hci_discovery_filter_clear(hdev);
+	hci_blocked_keys_clear(hdev);
 	hci_dev_unlock(hdev);
 
 	hci_dev_put(hdev);
diff --git a/net/bluetooth/hci_debugfs.c b/net/bluetooth/hci_debugfs.c
index 0d8ab5b3c177..28a7883e5271 100644
--- a/net/bluetooth/hci_debugfs.c
+++ b/net/bluetooth/hci_debugfs.c
@@ -152,6 +152,21 @@ static int blacklist_show(struct seq_file *f, void *p)
 
 DEFINE_SHOW_ATTRIBUTE(blacklist);
 
+static int blocked_keys_show(struct seq_file *f, void *p)
+{
+	struct hci_dev *hdev = f->private;
+	struct blocked_key *key;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(key, &hdev->blocked_keys, list)
+		seq_printf(f, "%u %*phN\n", key->type, 16, key->val);
+	rcu_read_unlock();
+
+	return 0;
+}
+
+DEFINE_SHOW_ATTRIBUTE(blocked_keys);
+
 static int uuids_show(struct seq_file *f, void *p)
 {
 	struct hci_dev *hdev = f->private;
@@ -308,6 +323,8 @@ void hci_debugfs_create_common(struct hci_dev *hdev)
 			    &device_list_fops);
 	debugfs_create_file("blacklist", 0444, hdev->debugfs, hdev,
 			    &blacklist_fops);
+	debugfs_create_file("blocked_keys", 0444, hdev->debugfs, hdev,
+			    &blocked_keys_fops);
 	debugfs_create_file("uuids", 0444, hdev->debugfs, hdev, &uuids_fops);
 	debugfs_create_file("remote_oob", 0400, hdev->debugfs, hdev,
 			    &remote_oob_fops);
* Unmerged path net/bluetooth/mgmt.c
diff --git a/net/bluetooth/smp.c b/net/bluetooth/smp.c
index 5f4c9f8333fd..97251883ffc8 100644
--- a/net/bluetooth/smp.c
+++ b/net/bluetooth/smp.c
@@ -2456,6 +2456,15 @@ static int smp_cmd_encrypt_info(struct l2cap_conn *conn, struct sk_buff *skb)
 	if (skb->len < sizeof(*rp))
 		return SMP_INVALID_PARAMS;
 
+	/* Pairing is aborted if any blocked keys are distributed */
+	if (hci_is_blocked_key(conn->hcon->hdev, HCI_BLOCKED_KEY_TYPE_LTK,
+			       rp->ltk)) {
+		bt_dev_warn_ratelimited(conn->hcon->hdev,
+					"LTK blocked for %pMR",
+					&conn->hcon->dst);
+		return SMP_INVALID_PARAMS;
+	}
+
 	SMP_ALLOW_CMD(smp, SMP_CMD_MASTER_IDENT);
 
 	skb_pull(skb, sizeof(*rp));
@@ -2512,6 +2521,15 @@ static int smp_cmd_ident_info(struct l2cap_conn *conn, struct sk_buff *skb)
 	if (skb->len < sizeof(*info))
 		return SMP_INVALID_PARAMS;
 
+	/* Pairing is aborted if any blocked keys are distributed */
+	if (hci_is_blocked_key(conn->hcon->hdev, HCI_BLOCKED_KEY_TYPE_IRK,
+			       info->irk)) {
+		bt_dev_warn_ratelimited(conn->hcon->hdev,
+					"Identity key blocked for %pMR",
+					&conn->hcon->dst);
+		return SMP_INVALID_PARAMS;
+	}
+
 	SMP_ALLOW_CMD(smp, SMP_CMD_IDENT_ADDR_INFO);
 
 	skb_pull(skb, sizeof(*info));
