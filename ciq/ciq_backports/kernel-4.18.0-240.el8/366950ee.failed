gpiolib: Lower verbosity when allocating hierarchy irq

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Kevin Hao <haokexin@gmail.com>
commit 366950eeb6ee7ba6693129899452e0ba890cbe4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/366950ee.failed

In the current codes, the following 3 lines would be output to
the console for each irq line.
  gpio gpiochip0: (gpio_thunderx): allocate IRQ 10, hwirq 0
  gpio gpiochip0: (gpio_thunderx): found parent hwirq 245784
  gpio gpiochip0: (gpio_thunderx): alloc_irqs_parent for 10 parent hwirq 245784

In general, there are about tens of irq lines for each gpio chip,
and then it would emit so many insignificant log in the boot process.
These infos are more suitable for the dbg purpose. So change these
to the dbg level. With this change, about 200 lines are suppressed
on my Marvell cn96xx board.

	Signed-off-by: Kevin Hao <haokexin@gmail.com>
Link: https://lore.kernel.org/r/20200120095625.25164-1-haokexin@gmail.com
	Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
(cherry picked from commit 366950eeb6ee7ba6693129899452e0ba890cbe4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpio/gpiolib.c
diff --cc drivers/gpio/gpiolib.c
index 72d23519e4c9,e48461ced552..000000000000
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@@ -1759,6 -1880,293 +1759,296 @@@ void gpiochip_set_nested_irqchip(struc
  }
  EXPORT_SYMBOL_GPL(gpiochip_set_nested_irqchip);
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_IRQ_DOMAIN_HIERARCHY
+ 
+ /**
+  * gpiochip_set_hierarchical_irqchip() - connects a hierarchical irqchip
+  * to a gpiochip
+  * @gc: the gpiochip to set the irqchip hierarchical handler to
+  * @irqchip: the irqchip to handle this level of the hierarchy, the interrupt
+  * will then percolate up to the parent
+  */
+ static void gpiochip_set_hierarchical_irqchip(struct gpio_chip *gc,
+ 					      struct irq_chip *irqchip)
+ {
+ 	/* DT will deal with mapping each IRQ as we go along */
+ 	if (is_of_node(gc->irq.fwnode))
+ 		return;
+ 
+ 	/*
+ 	 * This is for legacy and boardfile "irqchip" fwnodes: allocate
+ 	 * irqs upfront instead of dynamically since we don't have the
+ 	 * dynamic type of allocation that hardware description languages
+ 	 * provide. Once all GPIO drivers using board files are gone from
+ 	 * the kernel we can delete this code, but for a transitional period
+ 	 * it is necessary to keep this around.
+ 	 */
+ 	if (is_fwnode_irqchip(gc->irq.fwnode)) {
+ 		int i;
+ 		int ret;
+ 
+ 		for (i = 0; i < gc->ngpio; i++) {
+ 			struct irq_fwspec fwspec;
+ 			unsigned int parent_hwirq;
+ 			unsigned int parent_type;
+ 			struct gpio_irq_chip *girq = &gc->irq;
+ 
+ 			/*
+ 			 * We call the child to parent translation function
+ 			 * only to check if the child IRQ is valid or not.
+ 			 * Just pick the rising edge type here as that is what
+ 			 * we likely need to support.
+ 			 */
+ 			ret = girq->child_to_parent_hwirq(gc, i,
+ 							  IRQ_TYPE_EDGE_RISING,
+ 							  &parent_hwirq,
+ 							  &parent_type);
+ 			if (ret) {
+ 				chip_err(gc, "skip set-up on hwirq %d\n",
+ 					 i);
+ 				continue;
+ 			}
+ 
+ 			fwspec.fwnode = gc->irq.fwnode;
+ 			/* This is the hwirq for the GPIO line side of things */
+ 			fwspec.param[0] = girq->child_offset_to_irq(gc, i);
+ 			/* Just pick something */
+ 			fwspec.param[1] = IRQ_TYPE_EDGE_RISING;
+ 			fwspec.param_count = 2;
+ 			ret = __irq_domain_alloc_irqs(gc->irq.domain,
+ 						      /* just pick something */
+ 						      -1,
+ 						      1,
+ 						      NUMA_NO_NODE,
+ 						      &fwspec,
+ 						      false,
+ 						      NULL);
+ 			if (ret < 0) {
+ 				chip_err(gc,
+ 					 "can not allocate irq for GPIO line %d parent hwirq %d in hierarchy domain: %d\n",
+ 					 i, parent_hwirq,
+ 					 ret);
+ 			}
+ 		}
+ 	}
+ 
+ 	chip_err(gc, "%s unknown fwnode type proceed anyway\n", __func__);
+ 
+ 	return;
+ }
+ 
+ static int gpiochip_hierarchy_irq_domain_translate(struct irq_domain *d,
+ 						   struct irq_fwspec *fwspec,
+ 						   unsigned long *hwirq,
+ 						   unsigned int *type)
+ {
+ 	/* We support standard DT translation */
+ 	if (is_of_node(fwspec->fwnode) && fwspec->param_count == 2) {
+ 		return irq_domain_translate_twocell(d, fwspec, hwirq, type);
+ 	}
+ 
+ 	/* This is for board files and others not using DT */
+ 	if (is_fwnode_irqchip(fwspec->fwnode)) {
+ 		int ret;
+ 
+ 		ret = irq_domain_translate_twocell(d, fwspec, hwirq, type);
+ 		if (ret)
+ 			return ret;
+ 		WARN_ON(*type == IRQ_TYPE_NONE);
+ 		return 0;
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ static int gpiochip_hierarchy_irq_domain_alloc(struct irq_domain *d,
+ 					       unsigned int irq,
+ 					       unsigned int nr_irqs,
+ 					       void *data)
+ {
+ 	struct gpio_chip *gc = d->host_data;
+ 	irq_hw_number_t hwirq;
+ 	unsigned int type = IRQ_TYPE_NONE;
+ 	struct irq_fwspec *fwspec = data;
+ 	void *parent_arg;
+ 	unsigned int parent_hwirq;
+ 	unsigned int parent_type;
+ 	struct gpio_irq_chip *girq = &gc->irq;
+ 	int ret;
+ 
+ 	/*
+ 	 * The nr_irqs parameter is always one except for PCI multi-MSI
+ 	 * so this should not happen.
+ 	 */
+ 	WARN_ON(nr_irqs != 1);
+ 
+ 	ret = gc->irq.child_irq_domain_ops.translate(d, fwspec, &hwirq, &type);
+ 	if (ret)
+ 		return ret;
+ 
+ 	chip_dbg(gc, "allocate IRQ %d, hwirq %lu\n", irq,  hwirq);
+ 
+ 	ret = girq->child_to_parent_hwirq(gc, hwirq, type,
+ 					  &parent_hwirq, &parent_type);
+ 	if (ret) {
+ 		chip_err(gc, "can't look up hwirq %lu\n", hwirq);
+ 		return ret;
+ 	}
+ 	chip_dbg(gc, "found parent hwirq %u\n", parent_hwirq);
+ 
+ 	/*
+ 	 * We set handle_bad_irq because the .set_type() should
+ 	 * always be invoked and set the right type of handler.
+ 	 */
+ 	irq_domain_set_info(d,
+ 			    irq,
+ 			    hwirq,
+ 			    gc->irq.chip,
+ 			    gc,
+ 			    girq->handler,
+ 			    NULL, NULL);
+ 	irq_set_probe(irq);
+ 
+ 	/* This parent only handles asserted level IRQs */
+ 	parent_arg = girq->populate_parent_alloc_arg(gc, parent_hwirq, parent_type);
+ 	if (!parent_arg)
+ 		return -ENOMEM;
+ 
+ 	chip_dbg(gc, "alloc_irqs_parent for %d parent hwirq %d\n",
+ 		  irq, parent_hwirq);
+ 	irq_set_lockdep_class(irq, gc->irq.lock_key, gc->irq.request_key);
+ 	ret = irq_domain_alloc_irqs_parent(d, irq, 1, parent_arg);
+ 	/*
+ 	 * If the parent irqdomain is msi, the interrupts have already
+ 	 * been allocated, so the EEXIST is good.
+ 	 */
+ 	if (irq_domain_is_msi(d->parent) && (ret == -EEXIST))
+ 		ret = 0;
+ 	if (ret)
+ 		chip_err(gc,
+ 			 "failed to allocate parent hwirq %d for hwirq %lu\n",
+ 			 parent_hwirq, hwirq);
+ 
+ 	kfree(parent_arg);
+ 	return ret;
+ }
+ 
+ static unsigned int gpiochip_child_offset_to_irq_noop(struct gpio_chip *chip,
+ 						      unsigned int offset)
+ {
+ 	return offset;
+ }
+ 
+ static void gpiochip_hierarchy_setup_domain_ops(struct irq_domain_ops *ops)
+ {
+ 	ops->activate = gpiochip_irq_domain_activate;
+ 	ops->deactivate = gpiochip_irq_domain_deactivate;
+ 	ops->alloc = gpiochip_hierarchy_irq_domain_alloc;
+ 	ops->free = irq_domain_free_irqs_common;
+ 
+ 	/*
+ 	 * We only allow overriding the translate() function for
+ 	 * hierarchical chips, and this should only be done if the user
+ 	 * really need something other than 1:1 translation.
+ 	 */
+ 	if (!ops->translate)
+ 		ops->translate = gpiochip_hierarchy_irq_domain_translate;
+ }
+ 
+ static int gpiochip_hierarchy_add_domain(struct gpio_chip *gc)
+ {
+ 	if (!gc->irq.child_to_parent_hwirq ||
+ 	    !gc->irq.fwnode) {
+ 		chip_err(gc, "missing irqdomain vital data\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!gc->irq.child_offset_to_irq)
+ 		gc->irq.child_offset_to_irq = gpiochip_child_offset_to_irq_noop;
+ 
+ 	if (!gc->irq.populate_parent_alloc_arg)
+ 		gc->irq.populate_parent_alloc_arg =
+ 			gpiochip_populate_parent_fwspec_twocell;
+ 
+ 	gpiochip_hierarchy_setup_domain_ops(&gc->irq.child_irq_domain_ops);
+ 
+ 	gc->irq.domain = irq_domain_create_hierarchy(
+ 		gc->irq.parent_domain,
+ 		0,
+ 		gc->ngpio,
+ 		gc->irq.fwnode,
+ 		&gc->irq.child_irq_domain_ops,
+ 		gc);
+ 
+ 	if (!gc->irq.domain)
+ 		return -ENOMEM;
+ 
+ 	gpiochip_set_hierarchical_irqchip(gc, gc->irq.chip);
+ 
+ 	return 0;
+ }
+ 
+ static bool gpiochip_hierarchy_is_hierarchical(struct gpio_chip *gc)
+ {
+ 	return !!gc->irq.parent_domain;
+ }
+ 
+ void *gpiochip_populate_parent_fwspec_twocell(struct gpio_chip *chip,
+ 					     unsigned int parent_hwirq,
+ 					     unsigned int parent_type)
+ {
+ 	struct irq_fwspec *fwspec;
+ 
+ 	fwspec = kmalloc(sizeof(*fwspec), GFP_KERNEL);
+ 	if (!fwspec)
+ 		return NULL;
+ 
+ 	fwspec->fwnode = chip->irq.parent_domain->fwnode;
+ 	fwspec->param_count = 2;
+ 	fwspec->param[0] = parent_hwirq;
+ 	fwspec->param[1] = parent_type;
+ 
+ 	return fwspec;
+ }
+ EXPORT_SYMBOL_GPL(gpiochip_populate_parent_fwspec_twocell);
+ 
+ void *gpiochip_populate_parent_fwspec_fourcell(struct gpio_chip *chip,
+ 					      unsigned int parent_hwirq,
+ 					      unsigned int parent_type)
+ {
+ 	struct irq_fwspec *fwspec;
+ 
+ 	fwspec = kmalloc(sizeof(*fwspec), GFP_KERNEL);
+ 	if (!fwspec)
+ 		return NULL;
+ 
+ 	fwspec->fwnode = chip->irq.parent_domain->fwnode;
+ 	fwspec->param_count = 4;
+ 	fwspec->param[0] = 0;
+ 	fwspec->param[1] = parent_hwirq;
+ 	fwspec->param[2] = 0;
+ 	fwspec->param[3] = parent_type;
+ 
+ 	return fwspec;
+ }
+ EXPORT_SYMBOL_GPL(gpiochip_populate_parent_fwspec_fourcell);
+ 
+ #else
+ 
+ static int gpiochip_hierarchy_add_domain(struct gpio_chip *gc)
+ {
+ 	return -EINVAL;
+ }
+ 
+ static bool gpiochip_hierarchy_is_hierarchical(struct gpio_chip *gc)
+ {
+ 	return false;
+ }
+ 
+ #endif /* CONFIG_IRQ_DOMAIN_HIERARCHY */
+ 
++>>>>>>> 366950eeb6ee (gpiolib: Lower verbosity when allocating hierarchy irq)
  /**
   * gpiochip_irq_map() - maps an IRQ into a GPIO irqchip
   * @d: the irqdomain used by this irqchip
* Unmerged path drivers/gpio/gpiolib.c
