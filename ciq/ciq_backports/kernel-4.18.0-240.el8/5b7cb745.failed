net/mlx5: E-Switch, Enable reg c1 loopback when possible

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paul Blakey <paulb@mellanox.com>
commit 5b7cb7451585f83d414512a70b79b2086b8c6ed1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5b7cb745.failed

Enable reg c1 loopback if firmware reports it's supported,
as this is needed for restoring packet metadata (e.g chain).

Also define helper to query if it is enabled.

	Signed-off-by: Paul Blakey <paulb@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5b7cb7451585f83d414512a70b79b2086b8c6ed1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index 1f7d3f1673cb,5e751d7749db..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -610,16 -785,19 +617,25 @@@ static int esw_set_passing_vport_metada
  	if (err)
  		return err;
  
- 	fdb_to_vport_reg_c_id = MLX5_GET(query_esw_vport_context_out, out,
- 					 esw_vport_context.fdb_to_vport_reg_c_id);
+ 	curr = MLX5_GET(query_esw_vport_context_out, out,
+ 			esw_vport_context.fdb_to_vport_reg_c_id);
+ 	wanted = MLX5_FDB_TO_VPORT_REG_C_0;
+ 	if (mlx5_eswitch_reg_c1_loopback_supported(esw))
+ 		wanted |= MLX5_FDB_TO_VPORT_REG_C_1;
  
  	if (enable)
++<<<<<<< HEAD
 +		fdb_to_vport_reg_c_id |= MLX5_FDB_TO_VPORT_REG_C_0;
 +	else
 +		fdb_to_vport_reg_c_id &= ~MLX5_FDB_TO_VPORT_REG_C_0;
++=======
+ 		curr |= wanted;
+ 	else
+ 		curr &= ~wanted;
++>>>>>>> 5b7cb7451585 (net/mlx5: E-Switch, Enable reg c1 loopback when possible)
  
  	MLX5_SET(modify_esw_vport_context_in, in,
- 		 esw_vport_context.fdb_to_vport_reg_c_id, fdb_to_vport_reg_c_id);
+ 		 esw_vport_context.fdb_to_vport_reg_c_id, curr);
  
  	MLX5_SET(modify_esw_vport_context_in, in,
  		 field_select.fdb_to_vport_reg_c_id, 1);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 9c629f913b96..b4ed62977966 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@ -214,6 +214,7 @@ struct mlx5_esw_functions {
 
 enum {
 	MLX5_ESWITCH_VPORT_MATCH_METADATA = BIT(0),
+	MLX5_ESWITCH_REG_C1_LOOPBACK_ENABLED = BIT(1),
 };
 
 struct mlx5_eswitch {
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
diff --git a/include/linux/mlx5/eswitch.h b/include/linux/mlx5/eswitch.h
index dd1333f29f6e..d18f4a5fada4 100644
--- a/include/linux/mlx5/eswitch.h
+++ b/include/linux/mlx5/eswitch.h
@@ -70,6 +70,7 @@ u16 mlx5_eswitch_get_total_vports(const struct mlx5_core_dev *dev);
 enum devlink_eswitch_encap_mode
 mlx5_eswitch_get_encap_mode(const struct mlx5_core_dev *dev);
 
+bool mlx5_eswitch_reg_c1_loopback_enabled(const struct mlx5_eswitch *esw);
 bool mlx5_eswitch_vport_match_metadata_enabled(const struct mlx5_eswitch *esw);
 
 /* Reg C0 usage:
@@ -106,6 +107,12 @@ mlx5_eswitch_get_encap_mode(const struct mlx5_core_dev *dev)
 	return DEVLINK_ESWITCH_ENCAP_MODE_NONE;
 }
 
+static inline bool
+mlx5_eswitch_reg_c1_loopback_enabled(const struct mlx5_eswitch *esw)
+{
+	return false;
+};
+
 static inline bool
 mlx5_eswitch_vport_match_metadata_enabled(const struct mlx5_eswitch *esw)
 {
