compat_ioctl: move rtc handling into drivers/rtc/dev.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Arnd Bergmann <arnd@arndb.de>
commit 076ff658628678f73d2349a699c3431877c1a075
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/076ff658.failed

We no longer need the rtc compat handling to be in common code, now that
all drivers are either moved to the rtc-class framework, or (rarely)
exist in drivers/char for architectures without compat mode (m68k,
alpha and ia64, respectively).

I checked the list of ioctl commands in drivers, and the ones that are
not already handled are all compatible, again with the one exception of
m68k driver, which implements RTC_PLL_GET and RTC_PLL_SET, but has no
compat mode.

Unlike earlier versions of this patch, I'm now adding a separate
compat_ioctl handler that takes care of RTC_IRQP_READ32/RTC_IRQP_SET32
and treats all other commands as compatible, leaving the native
behavior unchanged.

The old conversion handler also deals with RTC_EPOCH_READ and
RTC_EPOCH_SET, which are not handled in rtc-dev.c but only in a single
device driver (rtc-vr41xx), so I'm adding the compat version in the same
place. I don't expect other drivers to need those commands in the future.

	Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
	Reviewed-by: Ben Hutchings <ben.hutchings@codethink.co.uk>
	Signed-off-by: Arnd Bergmann <arnd@arndb.de>
---
v4: handle RTC_EPOCH_SET32 in rtc_dev_compat_ioctl
v3: handle RTC_IRQP_READ32/RTC_IRQP_SET32 in rtc_dev_compat_ioctl
v2: merge compat handler into ioctl function to avoid the
    compat_alloc_user_space() roundtrip, based on feedback
    from Al Viro.
(cherry picked from commit 076ff658628678f73d2349a699c3431877c1a075)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/compat_ioctl.c
diff --cc fs/compat_ioctl.c
index 52e8324e4cf7,47da220f95b1..000000000000
--- a/fs/compat_ioctl.c
+++ b/fs/compat_ioctl.c
@@@ -40,19 -30,12 +40,22 @@@
  #include <linux/mtio.h>
  #include <linux/tty.h>
  #include <linux/vt_kern.h>
 +#include <linux/fb.h>
 +#include <linux/videodev2.h>
 +#include <linux/netdevice.h>
  #include <linux/raw.h>
  #include <linux/blkdev.h>
++<<<<<<< HEAD
 +#include <linux/elevator.h>
 +#include <linux/rtc.h>
++=======
++>>>>>>> 076ff6586286 (compat_ioctl: move rtc handling into drivers/rtc/dev.c)
  #include <linux/pci.h>
  #include <linux/serial.h>
 +#include <linux/if_tun.h>
  #include <linux/ctype.h>
  #include <linux/syscalls.h>
 +#include <linux/atalk.h>
  #include <linux/gfp.h>
  #include <linux/cec.h>
  
@@@ -572,116 -435,6 +575,119 @@@ static int mt_ioctl_trans(struct file *
  #define HCIUARTSETFLAGS		_IOW('U', 203, int)
  #define HCIUARTGETFLAGS		_IOR('U', 204, int)
  
++<<<<<<< HEAD
 +#define BNEPCONNADD	_IOW('B', 200, int)
 +#define BNEPCONNDEL	_IOW('B', 201, int)
 +#define BNEPGETCONNLIST	_IOR('B', 210, int)
 +#define BNEPGETCONNINFO	_IOR('B', 211, int)
 +#define BNEPGETSUPPFEAT	_IOR('B', 212, int)
 +
 +#define CMTPCONNADD	_IOW('C', 200, int)
 +#define CMTPCONNDEL	_IOW('C', 201, int)
 +#define CMTPGETCONNLIST	_IOR('C', 210, int)
 +#define CMTPGETCONNINFO	_IOR('C', 211, int)
 +
 +#define HIDPCONNADD	_IOW('H', 200, int)
 +#define HIDPCONNDEL	_IOW('H', 201, int)
 +#define HIDPGETCONNLIST	_IOR('H', 210, int)
 +#define HIDPGETCONNINFO	_IOR('H', 211, int)
 +
 +
 +struct serial_struct32 {
 +        compat_int_t    type;
 +        compat_int_t    line;
 +        compat_uint_t   port;
 +        compat_int_t    irq;
 +        compat_int_t    flags;
 +        compat_int_t    xmit_fifo_size;
 +        compat_int_t    custom_divisor;
 +        compat_int_t    baud_base;
 +        unsigned short  close_delay;
 +        char    io_type;
 +        char    reserved_char[1];
 +        compat_int_t    hub6;
 +        unsigned short  closing_wait; /* time to wait before closing */
 +        unsigned short  closing_wait2; /* no longer used... */
 +        compat_uint_t   iomem_base;
 +        unsigned short  iomem_reg_shift;
 +        unsigned int    port_high;
 +     /* compat_ulong_t  iomap_base FIXME */
 +        compat_int_t    reserved[1];
 +};
 +
 +static int serial_struct_ioctl(struct file *file,
 +		unsigned cmd, struct serial_struct32 __user *ss32)
 +{
 +        typedef struct serial_struct32 SS32;
 +        int err;
 +	struct serial_struct __user *ss = compat_alloc_user_space(sizeof(*ss));
 +        __u32 udata;
 +	unsigned int base;
 +	unsigned char *iomem_base;
 +
 +	if (ss == NULL)
 +		return -EFAULT;
 +        if (cmd == TIOCSSERIAL) {
 +		if (copy_in_user(ss, ss32, offsetof(SS32, iomem_base)) ||
 +		    get_user(udata, &ss32->iomem_base))
 +			return -EFAULT;
 +		iomem_base = compat_ptr(udata);
 +		if (put_user(iomem_base, &ss->iomem_base) ||
 +		    convert_in_user(&ss32->iomem_reg_shift,
 +		      &ss->iomem_reg_shift) ||
 +		    convert_in_user(&ss32->port_high, &ss->port_high) ||
 +		    put_user(0UL, &ss->iomap_base))
 +			return -EFAULT;
 +        }
 +	err = do_ioctl(file, cmd, (unsigned long)ss);
 +        if (cmd == TIOCGSERIAL && err >= 0) {
 +		if (copy_in_user(ss32, ss, offsetof(SS32, iomem_base)) ||
 +		    get_user(iomem_base, &ss->iomem_base))
 +			return -EFAULT;
 +		base = (unsigned long)iomem_base  >> 32 ?
 +			0xffffffff : (unsigned)(unsigned long)iomem_base;
 +		if (put_user(base, &ss32->iomem_base) ||
 +		    convert_in_user(&ss->iomem_reg_shift,
 +		      &ss32->iomem_reg_shift) ||
 +		    convert_in_user(&ss->port_high, &ss32->port_high))
 +			return -EFAULT;
 +        }
 +        return err;
 +}
 +
 +#define RTC_IRQP_READ32		_IOR('p', 0x0b, compat_ulong_t)
 +#define RTC_IRQP_SET32		_IOW('p', 0x0c, compat_ulong_t)
 +#define RTC_EPOCH_READ32	_IOR('p', 0x0d, compat_ulong_t)
 +#define RTC_EPOCH_SET32		_IOW('p', 0x0e, compat_ulong_t)
 +
 +static int rtc_ioctl(struct file *file,
 +		unsigned cmd, void __user *argp)
 +{
 +	unsigned long __user *valp = compat_alloc_user_space(sizeof(*valp));
 +	int ret;
 +
 +	if (valp == NULL)
 +		return -EFAULT;
 +	switch (cmd) {
 +	case RTC_IRQP_READ32:
 +	case RTC_EPOCH_READ32:
 +		ret = do_ioctl(file, (cmd == RTC_IRQP_READ32) ?
 +					RTC_IRQP_READ : RTC_EPOCH_READ,
 +					(unsigned long)valp);
 +		if (ret)
 +			return ret;
 +		return convert_in_user(valp, (unsigned int __user *)argp);
 +	case RTC_IRQP_SET32:
 +		return do_ioctl(file, RTC_IRQP_SET, (unsigned long)argp);
 +	case RTC_EPOCH_SET32:
 +		return do_ioctl(file, RTC_EPOCH_SET, (unsigned long)argp);
 +	}
 +
 +	return -ENOIOCTLCMD;
 +}
 +
++=======
++>>>>>>> 076ff6586286 (compat_ioctl: move rtc handling into drivers/rtc/dev.c)
  /*
   * simple reversible transform to make our table more evenly
   * distributed after sorting.
@@@ -1296,24 -850,6 +1287,27 @@@ static long do_ioctl_trans(unsigned in
  	case MTIOCPOS32:
  		return mt_ioctl_trans(file, cmd, argp);
  #endif
++<<<<<<< HEAD
 +	/* Serial */
 +	case TIOCGSERIAL:
 +	case TIOCSSERIAL:
 +		return serial_struct_ioctl(file, cmd, argp);
 +	/* Not implemented in the native kernel */
 +	case RTC_IRQP_READ32:
 +	case RTC_IRQP_SET32:
 +	case RTC_EPOCH_READ32:
 +	case RTC_EPOCH_SET32:
 +		return rtc_ioctl(file, cmd, argp);
 +
 +	/* dvb */
 +	case VIDEO_GET_EVENT:
 +		return do_video_get_event(file, cmd, argp);
 +	case VIDEO_STILLPICTURE:
 +		return do_video_stillpicture(file, cmd, argp);
 +	case VIDEO_SET_SPU_PALETTE:
 +		return do_video_set_spu_palette(file, cmd, argp);
++=======
++>>>>>>> 076ff6586286 (compat_ioctl: move rtc handling into drivers/rtc/dev.c)
  	}
  
  	/*
diff --git a/drivers/rtc/rtc-dev.c b/drivers/rtc/rtc-dev.c
index efa221e8bc22..5a8112411a03 100644
--- a/drivers/rtc/rtc-dev.c
+++ b/drivers/rtc/rtc-dev.c
@@ -13,6 +13,7 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <linux/compat.h>
 #include <linux/module.h>
 #include <linux/rtc.h>
 #include <linux/sched/signal.h>
@@ -367,7 +368,6 @@ static long rtc_dev_ioctl(struct file *file,
 	case RTC_IRQP_SET:
 		err = rtc_irq_set_freq(rtc, NULL, arg);
 		break;
-
 	case RTC_IRQP_READ:
 		err = put_user(rtc->irq_freq, (unsigned long __user *)uarg);
 		break;
@@ -405,6 +405,34 @@ static long rtc_dev_ioctl(struct file *file,
 	return err;
 }
 
+#ifdef CONFIG_COMPAT
+#define RTC_IRQP_SET32		_IOW('p', 0x0c, __u32)
+#define RTC_IRQP_READ32		_IOR('p', 0x0b, __u32)
+#define RTC_EPOCH_SET32		_IOW('p', 0x0e, __u32)
+
+static long rtc_dev_compat_ioctl(struct file *file,
+				 unsigned int cmd, unsigned long arg)
+{
+	struct rtc_device *rtc = file->private_data;
+	void __user *uarg = compat_ptr(arg);
+
+	switch (cmd) {
+	case RTC_IRQP_READ32:
+		return put_user(rtc->irq_freq, (__u32 __user *)uarg);
+
+	case RTC_IRQP_SET32:
+		/* arg is a plain integer, not pointer */
+		return rtc_dev_ioctl(file, RTC_IRQP_SET, arg);
+
+	case RTC_EPOCH_SET32:
+		/* arg is a plain integer, not pointer */
+		return rtc_dev_ioctl(file, RTC_EPOCH_SET, arg);
+	}
+
+	return rtc_dev_ioctl(file, cmd, (unsigned long)uarg);
+}
+#endif
+
 static int rtc_dev_fasync(int fd, struct file *file, int on)
 {
 	struct rtc_device *rtc = file->private_data;
@@ -439,6 +467,9 @@ static const struct file_operations rtc_dev_fops = {
 	.read		= rtc_dev_read,
 	.poll		= rtc_dev_poll,
 	.unlocked_ioctl	= rtc_dev_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= rtc_dev_compat_ioctl,
+#endif
 	.open		= rtc_dev_open,
 	.release	= rtc_dev_release,
 	.fasync		= rtc_dev_fasync,
diff --git a/drivers/rtc/rtc-vr41xx.c b/drivers/rtc/rtc-vr41xx.c
index 70f013e692b0..42137f1da90e 100644
--- a/drivers/rtc/rtc-vr41xx.c
+++ b/drivers/rtc/rtc-vr41xx.c
@@ -17,6 +17,7 @@
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
+#include <linux/compat.h>
 #include <linux/err.h>
 #include <linux/fs.h>
 #include <linux/init.h>
@@ -79,6 +80,9 @@ static void __iomem *rtc2_base;
 #define rtc2_read(offset)		readw(rtc2_base + (offset))
 #define rtc2_write(offset, value)	writew((value), rtc2_base + (offset))
 
+/* 32-bit compat for ioctls that nobody else uses */
+#define RTC_EPOCH_READ32	_IOR('p', 0x0d, __u32)
+
 static unsigned long epoch = 1970;	/* Jan 1 1970 00:00:00 */
 
 static DEFINE_SPINLOCK(rtc_lock);
@@ -195,6 +199,10 @@ static int vr41xx_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long
 	switch (cmd) {
 	case RTC_EPOCH_READ:
 		return put_user(epoch, (unsigned long __user *)arg);
+#ifdef CONFIG_64BIT
+	case RTC_EPOCH_READ32:
+		return put_user(epoch, (unsigned int __user *)arg);
+#endif
 	case RTC_EPOCH_SET:
 		/* Doesn't support before 1900 */
 		if (arg < 1900)
* Unmerged path fs/compat_ioctl.c
