io_uring: don't touch ctx in setup after ring fd install

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 044c1ab399afbe9f2ebef49a3204ef1509826dc7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/044c1ab3.failed

syzkaller reported an issue where it looks like a malicious app can
trigger a use-after-free of reading the ctx ->sq_array and ->rings
value right after having installed the ring fd in the process file
table.

Defer ring fd installation until after we're done reading those
values.

Fixes: 75b28affdd6a ("io_uring: allocate the two rings together")
	Reported-by: syzbot+6f03d895a6cd0d06187f@syzkaller.appspotmail.com
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 044c1ab399afbe9f2ebef49a3204ef1509826dc7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index e78c4294f4a5,c11c4157a4c2..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -3616,26 -3829,32 +3616,41 @@@ static int io_uring_create(unsigned ent
  	if (ret)
  		goto err;
  
- 	ret = io_uring_get_fd(ctx);
- 	if (ret < 0)
- 		goto err;
- 
  	memset(&p->sq_off, 0, sizeof(p->sq_off));
 -	p->sq_off.head = offsetof(struct io_rings, sq.head);
 -	p->sq_off.tail = offsetof(struct io_rings, sq.tail);
 -	p->sq_off.ring_mask = offsetof(struct io_rings, sq_ring_mask);
 -	p->sq_off.ring_entries = offsetof(struct io_rings, sq_ring_entries);
 -	p->sq_off.flags = offsetof(struct io_rings, sq_flags);
 -	p->sq_off.dropped = offsetof(struct io_rings, sq_dropped);
 -	p->sq_off.array = (char *)ctx->sq_array - (char *)ctx->rings;
 +	p->sq_off.head = offsetof(struct io_sq_ring, r.head);
 +	p->sq_off.tail = offsetof(struct io_sq_ring, r.tail);
 +	p->sq_off.ring_mask = offsetof(struct io_sq_ring, ring_mask);
 +	p->sq_off.ring_entries = offsetof(struct io_sq_ring, ring_entries);
 +	p->sq_off.flags = offsetof(struct io_sq_ring, flags);
 +	p->sq_off.dropped = offsetof(struct io_sq_ring, dropped);
 +	p->sq_off.array = offsetof(struct io_sq_ring, array);
  
  	memset(&p->cq_off, 0, sizeof(p->cq_off));
++<<<<<<< HEAD
 +	p->cq_off.head = offsetof(struct io_cq_ring, r.head);
 +	p->cq_off.tail = offsetof(struct io_cq_ring, r.tail);
 +	p->cq_off.ring_mask = offsetof(struct io_cq_ring, ring_mask);
 +	p->cq_off.ring_entries = offsetof(struct io_cq_ring, ring_entries);
 +	p->cq_off.overflow = offsetof(struct io_cq_ring, overflow);
 +	p->cq_off.cqes = offsetof(struct io_cq_ring, cqes);
++=======
+ 	p->cq_off.head = offsetof(struct io_rings, cq.head);
+ 	p->cq_off.tail = offsetof(struct io_rings, cq.tail);
+ 	p->cq_off.ring_mask = offsetof(struct io_rings, cq_ring_mask);
+ 	p->cq_off.ring_entries = offsetof(struct io_rings, cq_ring_entries);
+ 	p->cq_off.overflow = offsetof(struct io_rings, cq_overflow);
+ 	p->cq_off.cqes = offsetof(struct io_rings, cqes);
+ 
+ 	/*
+ 	 * Install ring fd as the very last thing, so we don't risk someone
+ 	 * having closed it before we finish setup
+ 	 */
+ 	ret = io_uring_get_fd(ctx);
+ 	if (ret < 0)
+ 		goto err;
+ 
+ 	p->features = IORING_FEAT_SINGLE_MMAP;
++>>>>>>> 044c1ab399af (io_uring: don't touch ctx in setup after ring fd install)
  	return ret;
  err:
  	io_ring_ctx_wait_and_kill(ctx);
* Unmerged path fs/io_uring.c
