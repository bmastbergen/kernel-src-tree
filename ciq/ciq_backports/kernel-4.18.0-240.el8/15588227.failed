ima: Collect modsig

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Thiago Jung Bauermann <bauerman@linux.ibm.com>
commit 15588227e086ec662d59df144e48af82e3e592f1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/15588227.failed

Obtain the modsig and calculate its corresponding hash in
ima_collect_measurement().

	Signed-off-by: Thiago Jung Bauermann <bauerman@linux.ibm.com>
	Signed-off-by: Mimi Zohar <zohar@linux.ibm.com>
(cherry picked from commit 15588227e086ec662d59df144e48af82e3e592f1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	security/integrity/ima/ima.h
#	security/integrity/ima/ima_modsig.c
diff --cc security/integrity/ima/ima.h
index 837eb0799374,0bc764c80327..000000000000
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@@ -306,11 -309,30 +306,36 @@@ static inline int ima_read_xattr(struc
  
  #ifdef CONFIG_IMA_APPRAISE_MODSIG
  bool ima_hook_supports_modsig(enum ima_hooks func);
++<<<<<<< HEAD
++=======
+ int ima_read_modsig(enum ima_hooks func, const void *buf, loff_t buf_len,
+ 		    struct modsig **modsig);
+ void ima_collect_modsig(struct modsig *modsig, const void *buf, loff_t size);
+ void ima_free_modsig(struct modsig *modsig);
++>>>>>>> 15588227e086 (ima: Collect modsig)
  #else
  static inline bool ima_hook_supports_modsig(enum ima_hooks func)
  {
  	return false;
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline int ima_read_modsig(enum ima_hooks func, const void *buf,
+ 				  loff_t buf_len, struct modsig **modsig)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline void ima_collect_modsig(struct modsig *modsig, const void *buf,
+ 				      loff_t size)
+ {
+ }
+ 
+ static inline void ima_free_modsig(struct modsig *modsig)
+ {
+ }
++>>>>>>> 15588227e086 (ima: Collect modsig)
  #endif /* CONFIG_IMA_APPRAISE_MODSIG */
  
  /* LSM based policy rules require audit */
diff --cc security/integrity/ima/ima_modsig.c
index 87503bfe8c8b,257387ce3b70..000000000000
--- a/security/integrity/ima/ima_modsig.c
+++ b/security/integrity/ima/ima_modsig.c
@@@ -8,8 -8,30 +8,28 @@@
   * Thiago Jung Bauermann <bauerman@linux.ibm.com>
   */
  
 -#include <linux/types.h>
 -#include <linux/module_signature.h>
 -#include <keys/asymmetric-type.h>
 -#include <crypto/pkcs7.h>
 -
  #include "ima.h"
  
++<<<<<<< HEAD
++=======
+ struct modsig {
+ 	struct pkcs7_message *pkcs7_msg;
+ 
+ 	enum hash_algo hash_algo;
+ 
+ 	/* This digest will go in the 'd-modsig' field of the IMA template. */
+ 	const u8 *digest;
+ 	u32 digest_size;
+ 
+ 	/*
+ 	 * This is what will go to the measurement list if the template requires
+ 	 * storing the signature.
+ 	 */
+ 	int raw_pkcs7_len;
+ 	u8 raw_pkcs7[];
+ };
+ 
++>>>>>>> 15588227e086 (ima: Collect modsig)
  /**
   * ima_hook_supports_modsig - can the policy allow modsig for this hook?
   *
@@@ -29,3 -51,98 +49,101 @@@ bool ima_hook_supports_modsig(enum ima_
  		return false;
  	}
  }
++<<<<<<< HEAD
++=======
+ 
+ /*
+  * ima_read_modsig - Read modsig from buf.
+  *
+  * Return: 0 on success, error code otherwise.
+  */
+ int ima_read_modsig(enum ima_hooks func, const void *buf, loff_t buf_len,
+ 		    struct modsig **modsig)
+ {
+ 	const size_t marker_len = strlen(MODULE_SIG_STRING);
+ 	const struct module_signature *sig;
+ 	struct modsig *hdr;
+ 	size_t sig_len;
+ 	const void *p;
+ 	int rc;
+ 
+ 	if (buf_len <= marker_len + sizeof(*sig))
+ 		return -ENOENT;
+ 
+ 	p = buf + buf_len - marker_len;
+ 	if (memcmp(p, MODULE_SIG_STRING, marker_len))
+ 		return -ENOENT;
+ 
+ 	buf_len -= marker_len;
+ 	sig = (const struct module_signature *)(p - sizeof(*sig));
+ 
+ 	rc = mod_check_sig(sig, buf_len, func_tokens[func]);
+ 	if (rc)
+ 		return rc;
+ 
+ 	sig_len = be32_to_cpu(sig->sig_len);
+ 	buf_len -= sig_len + sizeof(*sig);
+ 
+ 	/* Allocate sig_len additional bytes to hold the raw PKCS#7 data. */
+ 	hdr = kzalloc(sizeof(*hdr) + sig_len, GFP_KERNEL);
+ 	if (!hdr)
+ 		return -ENOMEM;
+ 
+ 	hdr->pkcs7_msg = pkcs7_parse_message(buf + buf_len, sig_len);
+ 	if (IS_ERR(hdr->pkcs7_msg)) {
+ 		kfree(hdr);
+ 		return PTR_ERR(hdr->pkcs7_msg);
+ 	}
+ 
+ 	memcpy(hdr->raw_pkcs7, buf + buf_len, sig_len);
+ 	hdr->raw_pkcs7_len = sig_len;
+ 
+ 	/* We don't know the hash algorithm yet. */
+ 	hdr->hash_algo = HASH_ALGO__LAST;
+ 
+ 	*modsig = hdr;
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * ima_collect_modsig - Calculate the file hash without the appended signature.
+  *
+  * Since the modsig is part of the file contents, the hash used in its signature
+  * isn't the same one ordinarily calculated by IMA. Therefore PKCS7 code
+  * calculates a separate one for signature verification.
+  */
+ void ima_collect_modsig(struct modsig *modsig, const void *buf, loff_t size)
+ {
+ 	int rc;
+ 
+ 	/*
+ 	 * Provide the file contents (minus the appended sig) so that the PKCS7
+ 	 * code can calculate the file hash.
+ 	 */
+ 	size -= modsig->raw_pkcs7_len + strlen(MODULE_SIG_STRING) +
+ 		sizeof(struct module_signature);
+ 	rc = pkcs7_supply_detached_data(modsig->pkcs7_msg, buf, size);
+ 	if (rc)
+ 		return;
+ 
+ 	/* Ask the PKCS7 code to calculate the file hash. */
+ 	rc = pkcs7_get_digest(modsig->pkcs7_msg, &modsig->digest,
+ 			      &modsig->digest_size, &modsig->hash_algo);
+ }
+ 
+ int ima_modsig_verify(struct key *keyring, const struct modsig *modsig)
+ {
+ 	return verify_pkcs7_message_sig(NULL, 0, modsig->pkcs7_msg, keyring,
+ 					VERIFYING_MODULE_SIGNATURE, NULL, NULL);
+ }
+ 
+ void ima_free_modsig(struct modsig *modsig)
+ {
+ 	if (!modsig)
+ 		return;
+ 
+ 	pkcs7_free_message(modsig->pkcs7_msg);
+ 	kfree(modsig);
+ }
++>>>>>>> 15588227e086 (ima: Collect modsig)
* Unmerged path security/integrity/ima/ima.h
diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index d426d4d1fe04..ac35bc3d6e35 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -209,7 +209,7 @@ int ima_get_action(struct inode *inode, const struct cred *cred, u32 secid,
  */
 int ima_collect_measurement(struct integrity_iint_cache *iint,
 			    struct file *file, void *buf, loff_t size,
-			    enum hash_algo algo)
+			    enum hash_algo algo, struct modsig *modsig)
 {
 	const char *audit_cause = "failed";
 	struct inode *inode = file_inode(file);
@@ -256,6 +256,9 @@ int ima_collect_measurement(struct integrity_iint_cache *iint,
 	memcpy(iint->ima_hash, &hash, length);
 	iint->version = i_version;
 
+	if (modsig)
+		ima_collect_modsig(modsig, buf, size);
+
 	/* Possibly temporary failure due to type of read (eg. O_DIRECT) */
 	if (!result)
 		iint->flags |= IMA_COLLECTED;
diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c
index b6b1cb008c36..5b79f83ce7e8 100644
--- a/security/integrity/ima/ima_appraise.c
+++ b/security/integrity/ima/ima_appraise.c
@@ -394,7 +394,7 @@ void ima_update_xattr(struct integrity_iint_cache *iint, struct file *file)
 	    !(iint->flags & IMA_HASH))
 		return;
 
-	rc = ima_collect_measurement(iint, file, NULL, 0, ima_hash_algo);
+	rc = ima_collect_measurement(iint, file, NULL, 0, ima_hash_algo, NULL);
 	if (rc < 0)
 		return;
 
diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index b7dd38fbfd04..b52250424dd4 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -283,7 +283,7 @@ static int process_measurement(struct file *file, const struct cred *cred,
 
 	hash_algo = ima_get_hash_algo(xattr_value, xattr_len);
 
-	rc = ima_collect_measurement(iint, file, buf, size, hash_algo);
+	rc = ima_collect_measurement(iint, file, buf, size, hash_algo, modsig);
 	if (rc != 0 && rc != -EBADF && rc != -EINVAL)
 		goto out_locked;
 
* Unmerged path security/integrity/ima/ima_modsig.c
