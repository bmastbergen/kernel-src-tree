KVM: VMX: check descriptor table exits on instruction emulation

jira LE-1907
cve CVE-2020-2732
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Oliver Upton <oupton@google.com>
commit 86f7e90ce840aa1db407d3ea6e9b3a52b2ce923c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/86f7e90c.failed

KVM emulates UMIP on hardware that doesn't support it by setting the
'descriptor table exiting' VM-execution control and performing
instruction emulation. When running nested, this emulation is broken as
KVM refuses to emulate L2 instructions by default.

Correct this regression by allowing the emulation of descriptor table
instructions if L1 hasn't requested 'descriptor table exiting'.

Fixes: 07721feee46b ("KVM: nVMX: Don't emulate instructions in guest mode")
	Reported-by: Jan Kiszka <jan.kiszka@web.de>
	Cc: stable@vger.kernel.org
	Cc: Paolo Bonzini <pbonzini@redhat.com>
	Cc: Jim Mattson <jmattson@google.com>
	Signed-off-by: Oliver Upton <oupton@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 86f7e90ce840aa1db407d3ea6e9b3a52b2ce923c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index 8ef29bfc0ecd,40b1e6138cd5..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -7180,6 -7147,40 +7180,43 @@@ static void vmx_request_immediate_exit(
  	to_vmx(vcpu)->req_immediate_exit = true;
  }
  
++<<<<<<< HEAD
++=======
+ static int vmx_check_intercept_io(struct kvm_vcpu *vcpu,
+ 				  struct x86_instruction_info *info)
+ {
+ 	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
+ 	unsigned short port;
+ 	bool intercept;
+ 	int size;
+ 
+ 	if (info->intercept == x86_intercept_in ||
+ 	    info->intercept == x86_intercept_ins) {
+ 		port = info->src_val;
+ 		size = info->dst_bytes;
+ 	} else {
+ 		port = info->dst_val;
+ 		size = info->src_bytes;
+ 	}
+ 
+ 	/*
+ 	 * If the 'use IO bitmaps' VM-execution control is 0, IO instruction
+ 	 * VM-exits depend on the 'unconditional IO exiting' VM-execution
+ 	 * control.
+ 	 *
+ 	 * Otherwise, IO instruction VM-exits are controlled by the IO bitmaps.
+ 	 */
+ 	if (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))
+ 		intercept = nested_cpu_has(vmcs12,
+ 					   CPU_BASED_UNCOND_IO_EXITING);
+ 	else
+ 		intercept = nested_vmx_check_io_bitmaps(vcpu, port, size);
+ 
+ 	/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */
+ 	return intercept ? X86EMUL_UNHANDLEABLE : X86EMUL_CONTINUE;
+ }
+ 
++>>>>>>> 86f7e90ce840 (KVM: VMX: check descriptor table exits on instruction emulation)
  static int vmx_check_intercept(struct kvm_vcpu *vcpu,
  			       struct x86_instruction_info *info,
  			       enum x86_intercept_stage stage)
@@@ -7191,14 -7193,39 +7228,48 @@@
  	 * RDPID causes #UD if disabled through secondary execution controls.
  	 * Because it is marked as EmulateOnUD, we need to intercept it here.
  	 */
++<<<<<<< HEAD
 +	if (info->intercept == x86_intercept_rdtscp &&
 +	    !nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDTSCP)) {
 +		ctxt->exception.vector = UD_VECTOR;
 +		ctxt->exception.error_code_valid = false;
 +		return X86EMUL_PROPAGATE_FAULT;
++=======
+ 	case x86_intercept_rdtscp:
+ 		if (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDTSCP)) {
+ 			ctxt->exception.vector = UD_VECTOR;
+ 			ctxt->exception.error_code_valid = false;
+ 			return X86EMUL_PROPAGATE_FAULT;
+ 		}
+ 		break;
+ 
+ 	case x86_intercept_in:
+ 	case x86_intercept_ins:
+ 	case x86_intercept_out:
+ 	case x86_intercept_outs:
+ 		return vmx_check_intercept_io(vcpu, info);
+ 
+ 	case x86_intercept_lgdt:
+ 	case x86_intercept_lidt:
+ 	case x86_intercept_lldt:
+ 	case x86_intercept_ltr:
+ 	case x86_intercept_sgdt:
+ 	case x86_intercept_sidt:
+ 	case x86_intercept_sldt:
+ 	case x86_intercept_str:
+ 		if (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_DESC))
+ 			return X86EMUL_CONTINUE;
+ 
+ 		/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */
+ 		break;
+ 
+ 	/* TODO: check more intercepts... */
+ 	default:
+ 		break;
++>>>>>>> 86f7e90ce840 (KVM: VMX: check descriptor table exits on instruction emulation)
  	}
  
 +	/* TODO: check more intercepts... */
  	return X86EMUL_UNHANDLEABLE;
  }
  
* Unmerged path arch/x86/kvm/vmx/vmx.c
