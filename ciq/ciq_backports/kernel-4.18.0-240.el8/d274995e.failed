KVM: s390: protvirt: handle secure guest prefix pages

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Janosch Frank <frankja@linux.ibm.com>
commit d274995ec273b82dbbccc5521ab2132217f64952
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d274995e.failed

The SPX instruction is handled by the ultravisor. We do get a
notification intercept, though. Let us update our internal view.

In addition to that, when the guest prefix page is not secure, an
intercept 112 (0x70) is indicated. Let us make the prefix pages
secure again.

	Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
	Reviewed-by: Cornelia Huck <cohuck@redhat.com>
[borntraeger@de.ibm.com: patch merging, splitting, fixing]
	Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
(cherry picked from commit d274995ec273b82dbbccc5521ab2132217f64952)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kvm/intercept.c
diff --cc arch/s390/kvm/intercept.c
index 59d88312ecd0,b6b7d4b0e26c..000000000000
--- a/arch/s390/kvm/intercept.c
+++ b/arch/s390/kvm/intercept.c
@@@ -451,8 -451,46 +451,51 @@@ static int handle_operexc(struct kvm_vc
  	return kvm_s390_inject_program_int(vcpu, PGM_OPERATION);
  }
  
++<<<<<<< HEAD
 +static int handle_pv_notification(struct kvm_vcpu *vcpu)
 +{
++=======
+ static int handle_pv_spx(struct kvm_vcpu *vcpu)
+ {
+ 	u32 pref = *(u32 *)vcpu->arch.sie_block->sidad;
+ 
+ 	kvm_s390_set_prefix(vcpu, pref);
+ 	trace_kvm_s390_handle_prefix(vcpu, 1, pref);
+ 	return 0;
+ }
+ 
+ static int handle_pv_sclp(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_s390_float_interrupt *fi = &vcpu->kvm->arch.float_int;
+ 
+ 	spin_lock(&fi->lock);
+ 	/*
+ 	 * 2 cases:
+ 	 * a: an sccb answering interrupt was already pending or in flight.
+ 	 *    As the sccb value is not known we can simply set some value to
+ 	 *    trigger delivery of a saved SCCB. UV will then use its saved
+ 	 *    copy of the SCCB value.
+ 	 * b: an error SCCB interrupt needs to be injected so we also inject
+ 	 *    a fake SCCB address. Firmware will use the proper one.
+ 	 * This makes sure, that both errors and real sccb returns will only
+ 	 * be delivered after a notification intercept (instruction has
+ 	 * finished) but not after others.
+ 	 */
+ 	fi->srv_signal.ext_params |= 0x43000;
+ 	set_bit(IRQ_PEND_EXT_SERVICE, &fi->pending_irqs);
+ 	clear_bit(IRQ_PEND_EXT_SERVICE, &fi->masked_irqs);
+ 	spin_unlock(&fi->lock);
+ 	return 0;
+ }
+ 
+ static int handle_pv_notification(struct kvm_vcpu *vcpu)
+ {
+ 	if (vcpu->arch.sie_block->ipa == 0xb210)
+ 		return handle_pv_spx(vcpu);
+ 	if (vcpu->arch.sie_block->ipa == 0xb220)
+ 		return handle_pv_sclp(vcpu);
+ 
++>>>>>>> d274995ec273 (KVM: s390: protvirt: handle secure guest prefix pages)
  	return handle_instruction(vcpu);
  }
  
diff --git a/arch/s390/include/asm/kvm_host.h b/arch/s390/include/asm/kvm_host.h
index c5f5ba8125e3..27eafd0c280b 100644
--- a/arch/s390/include/asm/kvm_host.h
+++ b/arch/s390/include/asm/kvm_host.h
@@ -213,6 +213,7 @@ struct kvm_s390_sie_block {
 #define ICPT_INT_ENABLE	0x64
 #define ICPT_PV_INSTR	0x68
 #define ICPT_PV_NOTIFY	0x6c
+#define ICPT_PV_PREF	0x70
 	__u8	icptcode;		/* 0x0050 */
 	__u8	icptstatus;		/* 0x0051 */
 	__u16	ihcpu;			/* 0x0052 */
* Unmerged path arch/s390/kvm/intercept.c
