KVM: s390: protvirt: Do only reset registers that are accessible

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Janosch Frank <frankja@linux.ibm.com>
commit 0f3035047140b3dc18fc5a028ed5f273f24b5539
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0f303504.failed

For protected VMs the hypervisor can not access guest breaking event
address, program parameter, bpbc and todpr. Do not reset those fields
as the control block does not provide access to these fields.

	Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
	Reviewed-by: Cornelia Huck <cohuck@redhat.com>
	Reviewed-by: David Hildenbrand <david@redhat.com>
[borntraeger@de.ibm.com: patch merging, splitting, fixing]
	Signed-off-by: Christian Borntraeger <borntraeger@de.ibm.com>
(cherry picked from commit 0f3035047140b3dc18fc5a028ed5f273f24b5539)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/kvm/kvm-s390.c
diff --cc arch/s390/kvm/kvm-s390.c
index 4c71e931da45,1c7bbc2497a2..000000000000
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@@ -3290,10 -3479,60 +3290,65 @@@ static int kvm_arch_vcpu_ioctl_set_one_
  	return r;
  }
  
 -static void kvm_arch_vcpu_ioctl_normal_reset(struct kvm_vcpu *vcpu)
 +static int kvm_arch_vcpu_ioctl_initial_reset(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	kvm_s390_vcpu_initial_reset(vcpu);
 +	return 0;
++=======
+ 	vcpu->arch.sie_block->gpsw.mask &= ~PSW_MASK_RI;
+ 	vcpu->arch.pfault_token = KVM_S390_PFAULT_TOKEN_INVALID;
+ 	memset(vcpu->run->s.regs.riccb, 0, sizeof(vcpu->run->s.regs.riccb));
+ 
+ 	kvm_clear_async_pf_completion_queue(vcpu);
+ 	if (!kvm_s390_user_cpu_state_ctrl(vcpu->kvm))
+ 		kvm_s390_vcpu_stop(vcpu);
+ 	kvm_s390_clear_local_irqs(vcpu);
+ }
+ 
+ static void kvm_arch_vcpu_ioctl_initial_reset(struct kvm_vcpu *vcpu)
+ {
+ 	/* Initial reset is a superset of the normal reset */
+ 	kvm_arch_vcpu_ioctl_normal_reset(vcpu);
+ 
+ 	/* this equals initial cpu reset in pop, but we don't switch to ESA */
+ 	vcpu->arch.sie_block->gpsw.mask = 0;
+ 	vcpu->arch.sie_block->gpsw.addr = 0;
+ 	kvm_s390_set_prefix(vcpu, 0);
+ 	kvm_s390_set_cpu_timer(vcpu, 0);
+ 	vcpu->arch.sie_block->ckc = 0;
+ 	memset(vcpu->arch.sie_block->gcr, 0, sizeof(vcpu->arch.sie_block->gcr));
+ 	vcpu->arch.sie_block->gcr[0] = CR0_INITIAL_MASK;
+ 	vcpu->arch.sie_block->gcr[14] = CR14_INITIAL_MASK;
+ 	vcpu->run->s.regs.fpc = 0;
+ 	/*
+ 	 * Do not reset these registers in the protected case, as some of
+ 	 * them are overlayed and they are not accessible in this case
+ 	 * anyway.
+ 	 */
+ 	if (!kvm_s390_pv_cpu_is_protected(vcpu)) {
+ 		vcpu->arch.sie_block->gbea = 1;
+ 		vcpu->arch.sie_block->pp = 0;
+ 		vcpu->arch.sie_block->fpf &= ~FPF_BPBC;
+ 		vcpu->arch.sie_block->todpr = 0;
+ 	}
+ }
+ 
+ static void kvm_arch_vcpu_ioctl_clear_reset(struct kvm_vcpu *vcpu)
+ {
+ 	struct kvm_sync_regs *regs = &vcpu->run->s.regs;
+ 
+ 	/* Clear reset is a superset of the initial reset */
+ 	kvm_arch_vcpu_ioctl_initial_reset(vcpu);
+ 
+ 	memset(&regs->gprs, 0, sizeof(regs->gprs));
+ 	memset(&regs->vrs, 0, sizeof(regs->vrs));
+ 	memset(&regs->acrs, 0, sizeof(regs->acrs));
+ 	memset(&regs->gscb, 0, sizeof(regs->gscb));
+ 
+ 	regs->etoken = 0;
+ 	regs->etoken_extension = 0;
++>>>>>>> 0f3035047140 (KVM: s390: protvirt: Do only reset registers that are accessible)
  }
  
  int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)
* Unmerged path arch/s390/kvm/kvm-s390.c
