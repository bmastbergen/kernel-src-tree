vxlan: add adjacent link to limit depth level

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Taehee Yoo <ap420073@gmail.com>
commit 0ce1822c2a08f6e05e22239bcb1778dcc916c7bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0ce1822c.failed

Current vxlan code doesn't limit the number of nested devices.
Nested devices would be handled recursively and this routine needs
huge stack memory. So, unlimited nested devices could make
stack overflow.

In order to fix this issue, this patch adds adjacent links.
The adjacent link APIs internally check the depth level.

Test commands:
    ip link add dummy0 type dummy
    ip link add vxlan0 type vxlan id 0 group 239.1.1.1 dev dummy0 \
	    dstport 4789
    for i in {1..100}
    do
	    let A=$i-1
	    ip link add vxlan$i type vxlan id $i group 239.1.1.1 \
		    dev vxlan$A dstport 4789
    done
    ip link del dummy0

The top upper link is vxlan100 and the lowest link is vxlan0.
When vxlan0 is deleting, the upper devices will be deleted recursively.
It needs huge stack memory so it makes stack overflow.

Splat looks like:
[  229.628477] =============================================================================
[  229.629785] BUG page->ptl (Not tainted): Padding overwritten. 0x0000000026abf214-0x0000000091f6abb2
[  229.629785] -----------------------------------------------------------------------------
[  229.629785]
[  229.655439] ==================================================================
[  229.629785] INFO: Slab 0x00000000ff7cfda8 objects=19 used=19 fp=0x00000000fe33776c flags=0x200000000010200
[  229.655688] BUG: KASAN: stack-out-of-bounds in unmap_single_vma+0x25a/0x2e0
[  229.655688] Read of size 8 at addr ffff888113076928 by task vlan-network-in/2334
[  229.655688]
[  229.629785] Padding 0000000026abf214: 00 80 14 0d 81 88 ff ff 68 91 81 14 81 88 ff ff  ........h.......
[  229.629785] Padding 0000000001e24790: 38 91 81 14 81 88 ff ff 68 91 81 14 81 88 ff ff  8.......h.......
[  229.629785] Padding 00000000b39397c8: 33 30 62 a7 ff ff ff ff ff eb 60 22 10 f1 ff 1f  30b.......`"....
[  229.629785] Padding 00000000bc98f53a: 80 60 07 13 81 88 ff ff 00 80 14 0d 81 88 ff ff  .`..............
[  229.629785] Padding 000000002aa8123d: 68 91 81 14 81 88 ff ff f7 21 17 a7 ff ff ff ff  h........!......
[  229.629785] Padding 000000001c8c2369: 08 81 14 0d 81 88 ff ff 03 02 00 00 00 00 00 00  ................
[  229.629785] Padding 000000004e290c5d: 21 90 a2 21 10 ed ff ff 00 00 00 00 00 fc ff df  !..!............
[  229.629785] Padding 000000000e25d731: 18 60 07 13 81 88 ff ff c0 8b 13 05 81 88 ff ff  .`..............
[  229.629785] Padding 000000007adc7ab3: b3 8a b5 41 00 00 00 00                          ...A....
[  229.629785] FIX page->ptl: Restoring 0x0000000026abf214-0x0000000091f6abb2=0x5a
[  ... ]

Fixes: acaf4e70997f ("net: vxlan: when lower dev unregisters remove vxlan dev as well")
	Signed-off-by: Taehee Yoo <ap420073@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0ce1822c2a08f6e05e22239bcb1778dcc916c7bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index b5e4c39e4c74,fcf028220bca..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -3798,13 -3950,13 +3816,18 @@@ static int vxlan_changelink(struct net_
  			    struct netlink_ext_ack *extack)
  {
  	struct vxlan_dev *vxlan = netdev_priv(dev);
- 	struct vxlan_rdst *dst = &vxlan->default_dst;
  	struct net_device *lowerdev;
  	struct vxlan_config conf;
+ 	struct vxlan_rdst *dst;
  	int err;
  
++<<<<<<< HEAD
 +	err = vxlan_nl2conf(tb, data,
 +			    dev, &conf, true);
++=======
+ 	dst = &vxlan->default_dst;
+ 	err = vxlan_nl2conf(tb, data, dev, &conf, true, extack);
++>>>>>>> 0ce1822c2a08 (vxlan: add adjacent link to limit depth level)
  	if (err)
  		return err;
  
@@@ -3813,9 -3965,16 +3836,14 @@@
  	if (err)
  		return err;
  
+ 	err = netdev_adjacent_change_prepare(dst->remote_dev, lowerdev, dev,
+ 					     extack);
+ 	if (err)
+ 		return err;
+ 
  	/* handle default dst entry */
  	if (!vxlan_addr_equal(&conf.remote_ip, &dst->remote_ip)) {
 -		u32 hash_index = fdb_head_index(vxlan, all_zeros_mac, conf.vni);
 -
 -		spin_lock_bh(&vxlan->hash_lock[hash_index]);
 +		spin_lock_bh(&vxlan->hash_lock);
  		if (!vxlan_addr_any(&conf.remote_ip)) {
  			err = vxlan_fdb_update(vxlan, all_zeros_mac,
  					       &conf.remote_ip,
@@@ -3826,7 -3985,9 +3854,13 @@@
  					       conf.remote_ifindex,
  					       NTF_SELF, true, extack);
  			if (err) {
++<<<<<<< HEAD
 +				spin_unlock_bh(&vxlan->hash_lock);
++=======
+ 				spin_unlock_bh(&vxlan->hash_lock[hash_index]);
+ 				netdev_adjacent_change_abort(dst->remote_dev,
+ 							     lowerdev, dev);
++>>>>>>> 0ce1822c2a08 (vxlan: add adjacent link to limit depth level)
  				return err;
  			}
  		}
* Unmerged path drivers/net/vxlan.c
diff --git a/include/net/vxlan.h b/include/net/vxlan.h
index 57d5e28f2b13..268450e50351 100644
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@ -197,6 +197,7 @@ struct vxlan_rdst {
 	u8			 offloaded:1;
 	__be32			 remote_vni;
 	u32			 remote_ifindex;
+	struct net_device	 *remote_dev;
 	struct list_head	 list;
 	struct rcu_head		 rcu;
 	struct dst_cache	 dst_cache;
