iommu: Move default domain allocation to iommu_probe_device()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Joerg Roedel <jroedel@suse.de>
commit 6e1aa2049154d7462968c968b20f985859308267
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6e1aa204.failed

Well, not really. The call to iommu_alloc_default_domain() in
iommu_group_get_for_dev() has to stay around as long as there are
IOMMU drivers using the add/remove_device() call-backs instead of
probe/release_device().

Those drivers expect that iommu_group_get_for_dev() returns the device
attached to a group and the group set up with a default domain (and
the device attached to the groups current domain).

But when all drivers are converted this compatability mess can be
removed.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
	Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
	Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
Link: https://lore.kernel.org/r/20200429133712.31431-9-joro@8bytes.org
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 6e1aa2049154d7462968c968b20f985859308267)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
diff --cc drivers/iommu/iommu.c
index 7997fcb701e0,7a385c18e1a5..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -165,13 -217,56 +175,46 @@@ void iommu_device_unregister(struct iom
  int iommu_probe_device(struct device *dev)
  {
  	const struct iommu_ops *ops = dev->bus->iommu_ops;
 -	int ret;
 +	int ret = -EINVAL;
  
  	WARN_ON(dev->iommu_group);
 -	if (!ops)
 -		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (ops)
++=======
+ 	if (!dev_iommu_get(dev))
+ 		return -ENOMEM;
+ 
+ 	if (!try_module_get(ops->owner)) {
+ 		ret = -EINVAL;
+ 		goto err_free_dev_param;
+ 	}
+ 
+ 	if (ops->probe_device) {
+ 		struct iommu_group *group;
+ 
+ 		ret = __iommu_probe_device(dev);
+ 
+ 		/*
+ 		 * Try to allocate a default domain - needs support from the
+ 		 * IOMMU driver. There are still some drivers which don't
+ 		 * support default domains, so the return value is not yet
+ 		 * checked.
+ 		 */
+ 		if (!ret)
+ 			iommu_alloc_default_domain(dev);
+ 
+ 		group = iommu_group_get(dev);
+ 		if (group && group->default_domain) {
+ 			ret = __iommu_attach_device(group->default_domain, dev);
+ 			iommu_group_put(group);
+ 		}
+ 
+ 	} else {
++>>>>>>> 6e1aa2049154 (iommu: Move default domain allocation to iommu_probe_device())
  		ret = ops->add_device(dev);
+ 	}
  
 -	if (ret)
 -		goto err_module_put;
 -
 -	if (ops->probe_finalize)
 -		ops->probe_finalize(dev);
 -
 -	return 0;
 -
 -err_module_put:
 -	module_put(ops->owner);
 -err_free_dev_param:
 -	dev_iommu_free(dev);
  	return ret;
  }
  
@@@ -179,19 -285,18 +222,10 @@@ void iommu_release_device(struct devic
  {
  	const struct iommu_ops *ops = dev->bus->iommu_ops;
  
 -	if (!dev->iommu)
 -		return;
 -
 -	if (ops->release_device)
 -		__iommu_release_device(dev);
 -	else if (dev->iommu_group)
 +	if (dev->iommu_group)
  		ops->remove_device(dev);
 -
 -	module_put(ops->owner);
 -	dev_iommu_free(dev);
  }
  
- static struct iommu_domain *__iommu_domain_alloc(struct bus_type *bus,
- 						 unsigned type);
- static int __iommu_attach_device(struct iommu_domain *domain,
- 				 struct device *dev);
- static int __iommu_attach_group(struct iommu_domain *domain,
- 				struct iommu_group *group);
- static void __iommu_detach_group(struct iommu_domain *domain,
- 				 struct iommu_group *group);
- 
  static int __init iommu_set_def_domain_type(char *str)
  {
  	bool pt;
@@@ -1119,23 -1417,44 +1153,33 @@@ struct iommu_group *pci_device_group(st
  	/* No shared group found, allocate new */
  	return iommu_group_alloc();
  }
 -EXPORT_SYMBOL_GPL(pci_device_group);
 -
 -/* Get the IOMMU group for device on fsl-mc bus */
 -struct iommu_group *fsl_mc_device_group(struct device *dev)
 -{
 -	struct device *cont_dev = fsl_mc_cont_dev(dev);
 -	struct iommu_group *group;
 -
 -	group = iommu_group_get(cont_dev);
 -	if (!group)
 -		group = iommu_group_alloc();
 -	return group;
 -}
 -EXPORT_SYMBOL_GPL(fsl_mc_device_group);
 -
 -static int iommu_get_def_domain_type(struct device *dev)
 -{
 -	const struct iommu_ops *ops = dev->bus->iommu_ops;
 -	unsigned int type = 0;
 -
 -	if (ops->def_domain_type)
 -		type = ops->def_domain_type(dev);
 -
 -	return (type == 0) ? iommu_def_domain_type : type;
 -}
  
- static int iommu_alloc_default_domain(struct device *dev,
- 				      struct iommu_group *group)
+ static int iommu_group_alloc_default_domain(struct bus_type *bus,
+ 					    struct iommu_group *group,
+ 					    unsigned int type)
  {
  	struct iommu_domain *dom;
  
++<<<<<<< HEAD
 +	if (group->default_domain)
 +		return 0;
 +
 +	dom = __iommu_domain_alloc(dev->bus, iommu_def_domain_type);
 +	if (!dom && iommu_def_domain_type != IOMMU_DOMAIN_DMA) {
 +		dom = __iommu_domain_alloc(dev->bus, IOMMU_DOMAIN_DMA);
 +		if (dom) {
 +			dev_warn(dev,
 +				 "failed to allocate default IOMMU domain of type %u; falling back to IOMMU_DOMAIN_DMA",
 +				 iommu_def_domain_type);
 +		}
++=======
+ 	dom = __iommu_domain_alloc(bus, type);
+ 	if (!dom && type != IOMMU_DOMAIN_DMA) {
+ 		dom = __iommu_domain_alloc(bus, IOMMU_DOMAIN_DMA);
+ 		if (dom)
+ 			pr_warn("Failed to allocate default IOMMU domain of type %u for group %s - Falling back to IOMMU_DOMAIN_DMA",
+ 				type, group->name);
++>>>>>>> 6e1aa2049154 (iommu: Move default domain allocation to iommu_probe_device())
  	}
  
  	if (!dom)
* Unmerged path drivers/iommu/iommu.c
