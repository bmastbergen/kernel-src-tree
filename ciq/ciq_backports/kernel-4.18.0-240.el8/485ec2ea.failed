bpf, devmap: Pass lockdep expression to RCU lists

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Amol Grover <frextrite@gmail.com>
commit 485ec2ea9cf556e9c120e07961b7b459d776a115
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/485ec2ea.failed

head is traversed using hlist_for_each_entry_rcu outside an RCU
read-side critical section but under the protection of dtab->index_lock.

Hence, add corresponding lockdep expression to silence false-positive
lockdep warnings, and harden RCU lists.

Fixes: 6f9d451ab1a3 ("xdp: Add devmap_hash map type for looking up devices by hashed index")
	Signed-off-by: Amol Grover <frextrite@gmail.com>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Jesper Dangaard Brouer <brouer@redhat.com>
	Acked-by: Toke Høiland-Jørgensen <toke@redhat.com>
Link: https://lore.kernel.org/bpf/20200123120437.26506-1-frextrite@gmail.com
(cherry picked from commit 485ec2ea9cf556e9c120e07961b7b459d776a115)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/devmap.c
diff --cc kernel/bpf/devmap.c
index cfc445b29247,f3a44f6ca86e..000000000000
--- a/kernel/bpf/devmap.c
+++ b/kernel/bpf/devmap.c
@@@ -226,11 -257,68 +226,74 @@@ static int dev_map_get_next_key(struct 
  	return 0;
  }
  
 -struct bpf_dtab_netdev *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key)
 +static int bq_xmit_all(struct xdp_bulk_queue *bq, u32 flags,
 +		       bool in_napi_ctx)
  {
++<<<<<<< HEAD
 +	struct bpf_dtab_netdev *obj = bq->obj;
 +	struct net_device *dev = obj->dev;
++=======
+ 	struct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);
+ 	struct hlist_head *head = dev_map_index_hash(dtab, key);
+ 	struct bpf_dtab_netdev *dev;
+ 
+ 	hlist_for_each_entry_rcu(dev, head, index_hlist,
+ 				 lockdep_is_held(&dtab->index_lock))
+ 		if (dev->idx == key)
+ 			return dev;
+ 
+ 	return NULL;
+ }
+ 
+ static int dev_map_hash_get_next_key(struct bpf_map *map, void *key,
+ 				    void *next_key)
+ {
+ 	struct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);
+ 	u32 idx, *next = next_key;
+ 	struct bpf_dtab_netdev *dev, *next_dev;
+ 	struct hlist_head *head;
+ 	int i = 0;
+ 
+ 	if (!key)
+ 		goto find_first;
+ 
+ 	idx = *(u32 *)key;
+ 
+ 	dev = __dev_map_hash_lookup_elem(map, idx);
+ 	if (!dev)
+ 		goto find_first;
+ 
+ 	next_dev = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu(&dev->index_hlist)),
+ 				    struct bpf_dtab_netdev, index_hlist);
+ 
+ 	if (next_dev) {
+ 		*next = next_dev->idx;
+ 		return 0;
+ 	}
+ 
+ 	i = idx & (dtab->n_buckets - 1);
+ 	i++;
+ 
+  find_first:
+ 	for (; i < dtab->n_buckets; i++) {
+ 		head = dev_map_index_hash(dtab, i);
+ 
+ 		next_dev = hlist_entry_safe(rcu_dereference_raw(hlist_first_rcu(head)),
+ 					    struct bpf_dtab_netdev,
+ 					    index_hlist);
+ 		if (next_dev) {
+ 			*next = next_dev->idx;
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	return -ENOENT;
+ }
+ 
+ static int bq_xmit_all(struct xdp_dev_bulk_queue *bq, u32 flags)
+ {
+ 	struct net_device *dev = bq->dev;
++>>>>>>> 485ec2ea9cf5 (bpf, devmap: Pass lockdep expression to RCU lists)
  	int sent = 0, drops = 0, err = 0;
  	int i;
  
* Unmerged path kernel/bpf/devmap.c
