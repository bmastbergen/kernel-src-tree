PCI/IOV: Move sysfs SR-IOV functions to iov.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Kelsey Skunberg <skunberg.kelsey@gmail.com>
commit aaee0c1ffd6399d291b030b49d622b81dd5071c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/aaee0c1f.failed

The sysfs SR-IOV functions are only needed when the kernel is built with
SR-IOV support.  Rather than put them in pci-sysfs.c under #ifdef
CONFIG_PCI_IOV, move them to iov.c, which is only compiled when
CONFIG_PCI_IOV=y.

Link: https://lore.kernel.org/r/20190813204513.4790-4-skunberg.kelsey@gmail.com
	Signed-off-by: Kelsey Skunberg <skunberg.kelsey@gmail.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Reviewed-by: Donald Dutile <ddutile@redhat.com>
	Reviewed-by: Kuppuswamy Sathyanarayanan <sathyanarayanan.kuppuswamy@linux.intel.com>
(cherry picked from commit aaee0c1ffd6399d291b030b49d622b81dd5071c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/pci-sysfs.c
diff --cc drivers/pci/pci-sysfs.c
index 3a8cc580cfdb,868e35109284..000000000000
--- a/drivers/pci/pci-sysfs.c
+++ b/drivers/pci/pci-sysfs.c
@@@ -548,154 -548,6 +548,157 @@@ static ssize_t devspec_show(struct devi
  static DEVICE_ATTR_RO(devspec);
  #endif
  
++<<<<<<< HEAD
 +#ifdef CONFIG_PCI_IOV
 +static ssize_t sriov_totalvfs_show(struct device *dev,
 +				   struct device_attribute *attr,
 +				   char *buf)
 +{
 +	struct pci_dev *pdev = to_pci_dev(dev);
 +
 +	return sprintf(buf, "%u\n", pci_sriov_get_totalvfs(pdev));
 +}
 +
 +
 +static ssize_t sriov_numvfs_show(struct device *dev,
 +				 struct device_attribute *attr,
 +				 char *buf)
 +{
 +	struct pci_dev *pdev = to_pci_dev(dev);
 +
 +	return sprintf(buf, "%u\n", pdev->sriov->num_VFs);
 +}
 +
 +/*
 + * num_vfs > 0; number of VFs to enable
 + * num_vfs = 0; disable all VFs
 + *
 + * Note: SRIOV spec doesn't allow partial VF
 + *       disable, so it's all or none.
 + */
 +static ssize_t sriov_numvfs_store(struct device *dev,
 +				  struct device_attribute *attr,
 +				  const char *buf, size_t count)
 +{
 +	struct pci_dev *pdev = to_pci_dev(dev);
 +	int ret;
 +	u16 num_vfs;
 +
 +	ret = kstrtou16(buf, 0, &num_vfs);
 +	if (ret < 0)
 +		return ret;
 +
 +	if (num_vfs > pci_sriov_get_totalvfs(pdev))
 +		return -ERANGE;
 +
 +	device_lock(&pdev->dev);
 +
 +	if (num_vfs == pdev->sriov->num_VFs)
 +		goto exit;
 +
 +	/* is PF driver loaded w/callback */
 +	if (!pdev->driver || !pdev->driver->sriov_configure) {
 +		pci_info(pdev, "Driver doesn't support SRIOV configuration via sysfs\n");
 +		ret = -ENOENT;
 +		goto exit;
 +	}
 +
 +	if (num_vfs == 0) {
 +		/* disable VFs */
 +		ret = pdev->driver->sriov_configure(pdev, 0);
 +		goto exit;
 +	}
 +
 +	/* enable VFs */
 +	if (pdev->sriov->num_VFs) {
 +		pci_warn(pdev, "%d VFs already enabled. Disable before enabling %d VFs\n",
 +			 pdev->sriov->num_VFs, num_vfs);
 +		ret = -EBUSY;
 +		goto exit;
 +	}
 +
 +	ret = pdev->driver->sriov_configure(pdev, num_vfs);
 +	if (ret < 0)
 +		goto exit;
 +
 +	if (ret != num_vfs)
 +		pci_warn(pdev, "%d VFs requested; only %d enabled\n",
 +			 num_vfs, ret);
 +
 +exit:
 +	device_unlock(&pdev->dev);
 +
 +	if (ret < 0)
 +		return ret;
 +
 +	return count;
 +}
 +
 +static ssize_t sriov_offset_show(struct device *dev,
 +				 struct device_attribute *attr,
 +				 char *buf)
 +{
 +	struct pci_dev *pdev = to_pci_dev(dev);
 +
 +	return sprintf(buf, "%u\n", pdev->sriov->offset);
 +}
 +
 +static ssize_t sriov_stride_show(struct device *dev,
 +				 struct device_attribute *attr,
 +				 char *buf)
 +{
 +	struct pci_dev *pdev = to_pci_dev(dev);
 +
 +	return sprintf(buf, "%u\n", pdev->sriov->stride);
 +}
 +
 +static ssize_t sriov_vf_device_show(struct device *dev,
 +				    struct device_attribute *attr,
 +				    char *buf)
 +{
 +	struct pci_dev *pdev = to_pci_dev(dev);
 +
 +	return sprintf(buf, "%x\n", pdev->sriov->vf_device);
 +}
 +
 +static ssize_t sriov_drivers_autoprobe_show(struct device *dev,
 +					    struct device_attribute *attr,
 +					    char *buf)
 +{
 +	struct pci_dev *pdev = to_pci_dev(dev);
 +
 +	return sprintf(buf, "%u\n", pdev->sriov->drivers_autoprobe);
 +}
 +
 +static ssize_t sriov_drivers_autoprobe_store(struct device *dev,
 +					     struct device_attribute *attr,
 +					     const char *buf, size_t count)
 +{
 +	struct pci_dev *pdev = to_pci_dev(dev);
 +	bool drivers_autoprobe;
 +
 +	if (kstrtobool(buf, &drivers_autoprobe) < 0)
 +		return -EINVAL;
 +
 +	pdev->sriov->drivers_autoprobe = drivers_autoprobe;
 +
 +	return count;
 +}
 +
 +static struct device_attribute sriov_totalvfs_attr = __ATTR_RO(sriov_totalvfs);
 +static struct device_attribute sriov_numvfs_attr =
 +		__ATTR(sriov_numvfs, (S_IRUGO|S_IWUSR|S_IWGRP),
 +		       sriov_numvfs_show, sriov_numvfs_store);
 +static struct device_attribute sriov_offset_attr = __ATTR_RO(sriov_offset);
 +static struct device_attribute sriov_stride_attr = __ATTR_RO(sriov_stride);
 +static struct device_attribute sriov_vf_device_attr = __ATTR_RO(sriov_vf_device);
 +static struct device_attribute sriov_drivers_autoprobe_attr =
 +		__ATTR(sriov_drivers_autoprobe, (S_IRUGO|S_IWUSR|S_IWGRP),
 +		       sriov_drivers_autoprobe_show, sriov_drivers_autoprobe_store);
 +#endif /* CONFIG_PCI_IOV */
 +
++=======
++>>>>>>> aaee0c1ffd63 (PCI/IOV: Move sysfs SR-IOV functions to iov.c)
  static ssize_t driver_override_store(struct device *dev,
  				     struct device_attribute *attr,
  				     const char *buf, size_t count)
@@@ -1703,34 -1546,6 +1706,37 @@@ static const struct attribute_group pci
  	.is_visible = pci_dev_hp_attrs_are_visible,
  };
  
++<<<<<<< HEAD
 +#ifdef CONFIG_PCI_IOV
 +static struct attribute *sriov_dev_attrs[] = {
 +	&sriov_totalvfs_attr.attr,
 +	&sriov_numvfs_attr.attr,
 +	&sriov_offset_attr.attr,
 +	&sriov_stride_attr.attr,
 +	&sriov_vf_device_attr.attr,
 +	&sriov_drivers_autoprobe_attr.attr,
 +	NULL,
 +};
 +
 +static umode_t sriov_attrs_are_visible(struct kobject *kobj,
 +				       struct attribute *a, int n)
 +{
 +	struct device *dev = kobj_to_dev(kobj);
 +
 +	if (!dev_is_pf(dev))
 +		return 0;
 +
 +	return a->mode;
 +}
 +
 +static const struct attribute_group sriov_dev_attr_group = {
 +	.attrs = sriov_dev_attrs,
 +	.is_visible = sriov_attrs_are_visible,
 +};
 +#endif /* CONFIG_PCI_IOV */
 +
++=======
++>>>>>>> aaee0c1ffd63 (PCI/IOV: Move sysfs SR-IOV functions to iov.c)
  static const struct attribute_group pci_dev_attr_group = {
  	.attrs = pci_dev_dev_attrs,
  	.is_visible = pci_dev_attrs_are_visible,
diff --git a/drivers/pci/iov.c b/drivers/pci/iov.c
index 525fd3f272b3..053054362247 100644
--- a/drivers/pci/iov.c
+++ b/drivers/pci/iov.c
@@ -240,6 +240,174 @@ void pci_iov_remove_virtfn(struct pci_dev *dev, int id)
 	pci_dev_put(dev);
 }
 
+static ssize_t sriov_totalvfs_show(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%u\n", pci_sriov_get_totalvfs(pdev));
+}
+
+static ssize_t sriov_numvfs_show(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%u\n", pdev->sriov->num_VFs);
+}
+
+/*
+ * num_vfs > 0; number of VFs to enable
+ * num_vfs = 0; disable all VFs
+ *
+ * Note: SRIOV spec does not allow partial VF
+ *	 disable, so it's all or none.
+ */
+static ssize_t sriov_numvfs_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	int ret;
+	u16 num_vfs;
+
+	ret = kstrtou16(buf, 0, &num_vfs);
+	if (ret < 0)
+		return ret;
+
+	if (num_vfs > pci_sriov_get_totalvfs(pdev))
+		return -ERANGE;
+
+	device_lock(&pdev->dev);
+
+	if (num_vfs == pdev->sriov->num_VFs)
+		goto exit;
+
+	/* is PF driver loaded w/callback */
+	if (!pdev->driver || !pdev->driver->sriov_configure) {
+		pci_info(pdev, "Driver does not support SRIOV configuration via sysfs\n");
+		ret = -ENOENT;
+		goto exit;
+	}
+
+	if (num_vfs == 0) {
+		/* disable VFs */
+		ret = pdev->driver->sriov_configure(pdev, 0);
+		goto exit;
+	}
+
+	/* enable VFs */
+	if (pdev->sriov->num_VFs) {
+		pci_warn(pdev, "%d VFs already enabled. Disable before enabling %d VFs\n",
+			 pdev->sriov->num_VFs, num_vfs);
+		ret = -EBUSY;
+		goto exit;
+	}
+
+	ret = pdev->driver->sriov_configure(pdev, num_vfs);
+	if (ret < 0)
+		goto exit;
+
+	if (ret != num_vfs)
+		pci_warn(pdev, "%d VFs requested; only %d enabled\n",
+			 num_vfs, ret);
+
+exit:
+	device_unlock(&pdev->dev);
+
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t sriov_offset_show(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%u\n", pdev->sriov->offset);
+}
+
+static ssize_t sriov_stride_show(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%u\n", pdev->sriov->stride);
+}
+
+static ssize_t sriov_vf_device_show(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%x\n", pdev->sriov->vf_device);
+}
+
+static ssize_t sriov_drivers_autoprobe_show(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+
+	return sprintf(buf, "%u\n", pdev->sriov->drivers_autoprobe);
+}
+
+static ssize_t sriov_drivers_autoprobe_store(struct device *dev,
+					     struct device_attribute *attr,
+					     const char *buf, size_t count)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	bool drivers_autoprobe;
+
+	if (kstrtobool(buf, &drivers_autoprobe) < 0)
+		return -EINVAL;
+
+	pdev->sriov->drivers_autoprobe = drivers_autoprobe;
+
+	return count;
+}
+
+static DEVICE_ATTR_RO(sriov_totalvfs);
+static DEVICE_ATTR(sriov_numvfs, 0664, sriov_numvfs_show, sriov_numvfs_store);
+static DEVICE_ATTR_RO(sriov_offset);
+static DEVICE_ATTR_RO(sriov_stride);
+static DEVICE_ATTR_RO(sriov_vf_device);
+static DEVICE_ATTR(sriov_drivers_autoprobe, 0664, sriov_drivers_autoprobe_show,
+		   sriov_drivers_autoprobe_store);
+
+static struct attribute *sriov_dev_attrs[] = {
+	&dev_attr_sriov_totalvfs.attr,
+	&dev_attr_sriov_numvfs.attr,
+	&dev_attr_sriov_offset.attr,
+	&dev_attr_sriov_stride.attr,
+	&dev_attr_sriov_vf_device.attr,
+	&dev_attr_sriov_drivers_autoprobe.attr,
+	NULL,
+};
+
+static umode_t sriov_attrs_are_visible(struct kobject *kobj,
+				       struct attribute *a, int n)
+{
+	struct device *dev = kobj_to_dev(kobj);
+
+	if (!dev_is_pf(dev))
+		return 0;
+
+	return a->mode;
+}
+
+const struct attribute_group sriov_dev_attr_group = {
+	.attrs = sriov_dev_attrs,
+	.is_visible = sriov_attrs_are_visible,
+};
+
 int __weak pcibios_sriov_enable(struct pci_dev *pdev, u16 num_vfs)
 {
 	return 0;
* Unmerged path drivers/pci/pci-sysfs.c
diff --git a/drivers/pci/pci.h b/drivers/pci/pci.h
index dd408ef0888b..ab2a317893b6 100644
--- a/drivers/pci/pci.h
+++ b/drivers/pci/pci.h
@@ -473,7 +473,7 @@ void pci_iov_update_resource(struct pci_dev *dev, int resno);
 resource_size_t pci_sriov_resource_alignment(struct pci_dev *dev, int resno);
 void pci_restore_iov_state(struct pci_dev *dev);
 int pci_iov_bus_range(struct pci_bus *bus);
-
+extern const struct attribute_group sriov_dev_attr_group;
 #else
 static inline int pci_iov_init(struct pci_dev *dev)
 {
