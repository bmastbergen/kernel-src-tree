iommu: Use C99 flexible array in fwspec

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Robin Murphy <robin.murphy@arm.com>
commit 098accf2da940189f4d62d3514d17f8bb05dc6e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/098accf2.failed

Although the 1-element array was a typical pre-C99 way to implement
variable-length structures, and indeed is a fundamental construct in the
APIs of certain other popular platforms, there's no good reason for it
here (and in particular the sizeof() trick is far too "clever" for its
own good). We can just as easily implement iommu_fwspec's preallocation
behaviour using a standard flexible array member, so let's make it look
the way most readers would expect.

	Signed-off-by: Robin Murphy <robin.murphy@arm.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 098accf2da940189f4d62d3514d17f8bb05dc6e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/iommu.h
diff --cc include/linux/iommu.h
index c1d843935775,4d1ba76c9a64..000000000000
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@@ -519,9 -589,10 +519,13 @@@ struct iommu_fwspec 
  	const struct iommu_ops	*ops;
  	struct fwnode_handle	*iommu_fwnode;
  	void			*iommu_priv;
 -	u32			flags;
 -	u32			num_pasid_bits;
  	unsigned int		num_ids;
++<<<<<<< HEAD
 +	u32			ids[1];
 +	RH_KABI_EXTEND(u32	flags)
++=======
+ 	u32			ids[];
++>>>>>>> 098accf2da94 (iommu: Use C99 flexible array in fwspec)
  };
  
  /* ATS is supported */
diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c
index b242a6d2dbb6..a9847051efee 100644
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@ -2077,7 +2077,8 @@ int iommu_fwspec_init(struct device *dev, struct fwnode_handle *iommu_fwnode,
 	if (fwspec)
 		return ops == fwspec->ops ? 0 : -EINVAL;
 
-	fwspec = kzalloc(sizeof(*fwspec), GFP_KERNEL);
+	/* Preallocate for the overwhelmingly common case of 1 ID */
+	fwspec = kzalloc(struct_size(fwspec, ids, 1), GFP_KERNEL);
 	if (!fwspec)
 		return -ENOMEM;
 
@@ -2104,15 +2105,15 @@ EXPORT_SYMBOL_GPL(iommu_fwspec_free);
 int iommu_fwspec_add_ids(struct device *dev, u32 *ids, int num_ids)
 {
 	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
-	size_t size;
-	int i;
+	int i, new_num;
 
 	if (!fwspec)
 		return -EINVAL;
 
-	size = offsetof(struct iommu_fwspec, ids[fwspec->num_ids + num_ids]);
-	if (size > sizeof(*fwspec)) {
-		fwspec = krealloc(fwspec, size, GFP_KERNEL);
+	new_num = fwspec->num_ids + num_ids;
+	if (new_num > 1) {
+		fwspec = krealloc(fwspec, struct_size(fwspec, ids, new_num),
+				  GFP_KERNEL);
 		if (!fwspec)
 			return -ENOMEM;
 
@@ -2122,7 +2123,7 @@ int iommu_fwspec_add_ids(struct device *dev, u32 *ids, int num_ids)
 	for (i = 0; i < num_ids; i++)
 		fwspec->ids[fwspec->num_ids + i] = ids[i];
 
-	fwspec->num_ids += num_ids;
+	fwspec->num_ids = new_num;
 	return 0;
 }
 EXPORT_SYMBOL_GPL(iommu_fwspec_add_ids);
* Unmerged path include/linux/iommu.h
