KVM: x86: Handle INVPCID CPUID adjustment in VMX code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 5ffec6f910dc8998c9da9320550ffddebe2e7afc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5ffec6f9.failed

Move the INVPCID CPUID adjustments into VMX to eliminate an instance of
the undesirable "unsigned f_* = *_supported ? F(*) : 0" pattern in the
common CPUID handling code.  Drop ->invpcid_supported(), CPUID
adjustment was the only user.

No functional change intended.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 5ffec6f910dc8998c9da9320550ffddebe2e7afc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.c
#	arch/x86/kvm/svm.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/cpuid.c
index d4472786ed92,99c4748e5a0d..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -368,8 -331,6 +368,11 @@@ static int __do_cpuid_func_emulated(str
  
  static inline void do_cpuid_7_mask(struct kvm_cpuid_entry2 *entry)
  {
++<<<<<<< HEAD
 +	unsigned f_invpcid = kvm_x86_ops->invpcid_supported() ? F(INVPCID) : 0;
 +	unsigned f_mpx = kvm_mpx_supported() ? F(MPX) : 0;
++=======
++>>>>>>> 5ffec6f910dc (KVM: x86: Handle INVPCID CPUID adjustment in VMX code)
  	unsigned f_umip = kvm_x86_ops->umip_emulated() ? F(UMIP) : 0;
  	unsigned f_intel_pt = kvm_x86_ops->pt_supported() ? F(INTEL_PT) : 0;
  	unsigned f_la57;
@@@ -378,7 -339,7 +381,11 @@@
  	/* cpuid 7.0.ebx */
  	const u32 kvm_cpuid_7_0_ebx_x86_features =
  		F(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |
++<<<<<<< HEAD
 +		F(BMI2) | F(ERMS) | f_invpcid | F(RTM) | f_mpx | F(RDSEED) |
++=======
+ 		F(BMI2) | F(ERMS) | 0 /*INVPCID*/ | F(RTM) | 0 /*MPX*/ | F(RDSEED) |
++>>>>>>> 5ffec6f910dc (KVM: x86: Handle INVPCID CPUID adjustment in VMX code)
  		F(ADX) | F(SMAP) | F(AVX512IFMA) | F(AVX512F) | F(AVX512PF) |
  		F(AVX512ER) | F(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(AVX512DQ) |
  		F(SHA_NI) | F(AVX512BW) | F(AVX512VL) | f_intel_pt;
diff --cc arch/x86/kvm/svm.c
index 2c7c88ef7253,9ef4ebf8475a..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -6091,16 -6073,6 +6091,19 @@@ static bool svm_rdtscp_supported(void
  	return boot_cpu_has(X86_FEATURE_RDTSCP);
  }
  
++<<<<<<< HEAD
 +static bool svm_invpcid_supported(void)
 +{
 +	return false;
 +}
 +
 +static bool svm_mpx_supported(void)
 +{
 +	return false;
 +}
 +
++=======
++>>>>>>> 5ffec6f910dc (KVM: x86: Handle INVPCID CPUID adjustment in VMX code)
  static bool svm_xsaves_supported(void)
  {
  	return boot_cpu_has(X86_FEATURE_XSAVES);
@@@ -7465,8 -7455,6 +7468,11 @@@ static struct kvm_x86_ops svm_x86_ops _
  	.cpuid_update = svm_cpuid_update,
  
  	.rdtscp_supported = svm_rdtscp_supported,
++<<<<<<< HEAD
 +	.invpcid_supported = svm_invpcid_supported,
 +	.mpx_supported = svm_mpx_supported,
++=======
++>>>>>>> 5ffec6f910dc (KVM: x86: Handle INVPCID CPUID adjustment in VMX code)
  	.xsaves_supported = svm_xsaves_supported,
  	.umip_emulated = svm_umip_emulated,
  	.pt_supported = svm_pt_supported,
diff --cc arch/x86/kvm/vmx/vmx.c
index b4f527d117f1,040c7e8f3345..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -7251,10 -7123,22 +7246,27 @@@ static void vmx_cpuid_update(struct kvm
  	}
  }
  
 -static void vmx_set_supported_cpuid(struct kvm_cpuid_entry2 *entry)
 +static void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)
  {
++<<<<<<< HEAD
 +	if (func == 1 && nested)
 +		entry->ecx |= feature_bit(VMX);
++=======
+ 	switch (entry->function) {
+ 	case 0x1:
+ 		if (nested)
+ 			cpuid_entry_set(entry, X86_FEATURE_VMX);
+ 		break;
+ 	case 0x7:
+ 		if (boot_cpu_has(X86_FEATURE_MPX) && kvm_mpx_supported())
+ 			cpuid_entry_set(entry, X86_FEATURE_MPX);
+ 		if (boot_cpu_has(X86_FEATURE_INVPCID) && cpu_has_vmx_invpcid())
+ 			cpuid_entry_set(entry, X86_FEATURE_INVPCID);
+ 		break;
+ 	default:
+ 		break;
+ 	}
++>>>>>>> 5ffec6f910dc (KVM: x86: Handle INVPCID CPUID adjustment in VMX code)
  }
  
  static void vmx_request_immediate_exit(struct kvm_vcpu *vcpu)
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 69418e1a3a68..2d30d5b69dd3 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -1149,7 +1149,6 @@ struct kvm_x86_ops {
 	u64 (*get_mt_mask)(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio);
 	int (*get_lpage_level)(void);
 	bool (*rdtscp_supported)(void);
-	bool (*invpcid_supported)(void);
 
 	void (*set_tdp_cr3)(struct kvm_vcpu *vcpu, unsigned long cr3);
 
* Unmerged path arch/x86/kvm/cpuid.c
* Unmerged path arch/x86/kvm/svm.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
