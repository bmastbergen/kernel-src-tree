nbd: verify socket is supported during setup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mike Christie <mchristi@redhat.com>
commit cf1b2326b734896734c6e167e41766f9cee7686a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/cf1b2326.failed

nbd requires socket families to support the shutdown method so the nbd
recv workqueue can be woken up from its sock_recvmsg call. If the socket
does not support the callout we will leave recv works running or get hangs
later when the device or module is removed.

This adds a check during socket connection/reconnection to make sure the
socket being passed in supports the needed callout.

	Reported-by: syzbot+24c12fa8d218ed26011a@syzkaller.appspotmail.com
Fixes: e9e006f5fcf2 ("nbd: fix max number of supported devs")
	Tested-by: Richard W.M. Jones <rjones@redhat.com>
	Signed-off-by: Mike Christie <mchristi@redhat.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit cf1b2326b734896734c6e167e41766f9cee7686a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nbd.c
diff --cc drivers/block/nbd.c
index 73bf952a0d16,a94ee45440b3..000000000000
--- a/drivers/block/nbd.c
+++ b/drivers/block/nbd.c
@@@ -968,23 -980,23 +968,43 @@@ static blk_status_t nbd_queue_rq(struc
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int nbd_check_sock_type(struct nbd_device *nbd, struct socket *sock)
 +{
 +	struct sockaddr_storage buf;
 +	struct sockaddr *addr = (struct sockaddr *)&buf;
 +	int err;
 +
 +	err = kernel_getsockname(sock, addr);
 +	if (err < 0)
 +		return err;
 +
 +	if (addr->sa_family != AF_UNIX) {
 +		dev_err(disk_to_dev(nbd->disk),
 +			"Only AF_UNIX sockets are supported.\n");
 +		return -EINVAL;
 +	}
 +
 +	return 0;
++=======
+ static struct socket *nbd_get_socket(struct nbd_device *nbd, unsigned long fd,
+ 				     int *err)
+ {
+ 	struct socket *sock;
+ 
+ 	*err = 0;
+ 	sock = sockfd_lookup(fd, err);
+ 	if (!sock)
+ 		return NULL;
+ 
+ 	if (sock->ops->shutdown == sock_no_shutdown) {
+ 		dev_err(disk_to_dev(nbd->disk), "Unsupported socket: shutdown callout must be supported.\n");
+ 		*err = -EINVAL;
+ 		return NULL;
+ 	}
+ 
+ 	return sock;
++>>>>>>> cf1b2326b734 (nbd: verify socket is supported during setup)
  }
  
  static int nbd_add_socket(struct nbd_device *nbd, unsigned long arg,
* Unmerged path drivers/block/nbd.c
