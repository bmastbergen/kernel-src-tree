perf evlist: Introduce perf_evlist__mmap_cb_get()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit bb1b1885e2f22afb8bc7981cd865fe4b0e3d975b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/bb1b1885.failed

Add the perf_evlist__mmap_cb_get() function to return 'struct perf_mmap'
object during perf_evlist__mmap_ops() call.

The array of 'struct mmap' is allocated via evlist__alloc_mmap(), in
this callback we simply returns pointer to the base object.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lore.kernel.org/lkml/20191007125344.14268-20-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit bb1b1885e2f22afb8bc7981cd865fe4b0e3d975b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/evlist.c
diff --cc tools/perf/util/evlist.c
index 29a998d183ce,f50ee5cb6554..000000000000
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@@ -833,7 -739,41 +833,45 @@@ static int perf_evlist__mmap_per_evsel(
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int perf_evlist__mmap_per_cpu(struct perf_evlist *evlist,
++=======
+ static void
+ perf_evlist__mmap_cb_idx(struct perf_evlist *_evlist,
+ 			 struct perf_mmap_param *_mp,
+ 			 int idx, bool per_cpu)
+ {
+ 	struct evlist *evlist = container_of(_evlist, struct evlist, core);
+ 	struct mmap_params *mp = container_of(_mp, struct mmap_params, core);
+ 
+ 	auxtrace_mmap_params__set_idx(&mp->auxtrace_mp, evlist, idx, per_cpu);
+ }
+ 
+ static struct perf_mmap*
+ perf_evlist__mmap_cb_get(struct perf_evlist *_evlist, bool overwrite, int idx)
+ {
+ 	struct evlist *evlist = container_of(_evlist, struct evlist, core);
+ 	struct mmap *maps = evlist->mmap;
+ 
+ 	if (overwrite) {
+ 		maps = evlist->overwrite_mmap;
+ 
+ 		if (!maps) {
+ 			maps = evlist__alloc_mmap(evlist, true);
+ 			if (!maps)
+ 				return NULL;
+ 
+ 			evlist->overwrite_mmap = maps;
+ 			if (evlist->bkw_mmap_state == BKW_MMAP_NOTREADY)
+ 				perf_evlist__toggle_bkw_mmap(evlist, BKW_MMAP_RUNNING);
+ 		}
+ 	}
+ 
+ 	return &maps[idx].core;
+ }
+ 
+ static int evlist__mmap_per_cpu(struct evlist *evlist,
++>>>>>>> bb1b1885e2f2 (perf evlist: Introduce perf_evlist__mmap_cb_get())
  				     struct mmap_params *mp)
  {
  	int cpu, thread;
@@@ -1023,11 -963,19 +1061,24 @@@ int perf_evlist__mmap_ex(struct perf_ev
  	 * Its value is decided by evsel's write_backward.
  	 * So &mp should not be passed through const pointer.
  	 */
++<<<<<<< HEAD
 +	struct mmap_params mp = { .nr_cblocks = nr_cblocks, .affinity = affinity, .flush = flush,
 +				  .comp_level = comp_level };
++=======
+ 	struct mmap_params mp = {
+ 		.nr_cblocks	= nr_cblocks,
+ 		.affinity	= affinity,
+ 		.flush		= flush,
+ 		.comp_level	= comp_level
+ 	};
+ 	struct perf_evlist_mmap_ops ops __maybe_unused = {
+ 		.idx = perf_evlist__mmap_cb_idx,
+ 		.get = perf_evlist__mmap_cb_get,
+ 	};
++>>>>>>> bb1b1885e2f2 (perf evlist: Introduce perf_evlist__mmap_cb_get())
  
  	if (!evlist->mmap)
 -		evlist->mmap = evlist__alloc_mmap(evlist, false);
 +		evlist->mmap = perf_evlist__alloc_mmap(evlist, false);
  	if (!evlist->mmap)
  		return -ENOMEM;
  
* Unmerged path tools/perf/util/evlist.c
