net: fib_notifier: propagate extack down to the notifier block callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] fib_notifier: propagate extack down to the notifier block callback (Petr Oros) [1805951]
Rebuild_FUZZ: 96.35%
commit-author Jiri Pirko <jiri@mellanox.com>
commit b7a595577ef3dc9add2b3e6d00869d017306bfbe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b7a59557.failed

Since errors are propagated all the way up to the caller, propagate
possible extack of the caller all the way down to the notifier block
callback.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b7a595577ef3dc9add2b3e6d00869d017306bfbe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
#	drivers/net/ethernet/rocker/rocker_main.c
#	drivers/net/netdevsim/fib.c
#	include/linux/mroute_base.h
#	include/net/fib_notifier.h
#	include/net/ip_fib.h
#	net/core/fib_notifier.c
#	net/core/fib_rules.c
#	net/ipv4/fib_notifier.c
#	net/ipv4/fib_trie.c
#	net/ipv4/ipmr_base.c
#	net/ipv6/ip6_fib.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
index a5addeadc732,13e2944b1274..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
@@@ -296,8 -308,8 +296,13 @@@ int mlx5_lag_mp_init(struct mlx5_lag *l
  		return 0;
  
  	mp->fib_nb.notifier_call = mlx5_lag_fib_event;
++<<<<<<< HEAD
 +	err = register_fib_notifier(&mp->fib_nb,
 +				    mlx5_lag_fib_event_flush);
++=======
+ 	err = register_fib_notifier(&init_net, &mp->fib_nb,
+ 				    mlx5_lag_fib_event_flush, NULL);
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  	if (err)
  		mp->fib_nb.notifier_call = NULL;
  
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 9e9609629563,445e2daa54ac..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -8132,8 -8134,8 +8132,13 @@@ int mlxsw_sp_router_init(struct mlxsw_s
  		goto err_dscp_init;
  
  	mlxsw_sp->router->fib_nb.notifier_call = mlxsw_sp_router_fib_event;
++<<<<<<< HEAD
 +	err = register_fib_notifier(&mlxsw_sp->router->fib_nb,
 +				    mlxsw_sp_router_fib_dump_flush);
++=======
+ 	err = register_fib_notifier(&init_net, &mlxsw_sp->router->fib_nb,
+ 				    mlxsw_sp_router_fib_dump_flush, NULL);
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  	if (err)
  		goto err_register_fib_notifier;
  
diff --cc drivers/net/ethernet/rocker/rocker_main.c
index c06a7a50400c,bc4f951315da..000000000000
--- a/drivers/net/ethernet/rocker/rocker_main.c
+++ b/drivers/net/ethernet/rocker/rocker_main.c
@@@ -2999,7 -2991,7 +2999,11 @@@ static int rocker_probe(struct pci_dev 
  	 * the device, so no need to pass a callback.
  	 */
  	rocker->fib_nb.notifier_call = rocker_router_fib_event;
++<<<<<<< HEAD
 +	err = register_fib_notifier(&rocker->fib_nb, NULL);
++=======
+ 	err = register_fib_notifier(&init_net, &rocker->fib_nb, NULL, NULL);
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  	if (err)
  		goto err_register_fib_notifier;
  
diff --cc drivers/net/netdevsim/fib.c
index 1a251f76d09b,d2aeac0f4c2c..000000000000
--- a/drivers/net/netdevsim/fib.c
+++ b/drivers/net/netdevsim/fib.c
@@@ -199,59 -202,63 +199,67 @@@ static int nsim_fib_event_nb(struct not
  /* inconsistent dump, trying again */
  static void nsim_fib_dump_inconsistent(struct notifier_block *nb)
  {
 -	struct nsim_fib_data *data = container_of(nb, struct nsim_fib_data,
 -						  fib_nb);
 +	struct nsim_fib_data *data;
 +	struct net *net;
  
 -	data->ipv4.fib.num = 0ULL;
 -	data->ipv4.rules.num = 0ULL;
 -	data->ipv6.fib.num = 0ULL;
 -	data->ipv6.rules.num = 0ULL;
 -}
 +	rcu_read_lock();
 +	for_each_net_rcu(net) {
 +		data = net_generic(net, nsim_fib_net_id);
  
 -static u64 nsim_fib_ipv4_resource_occ_get(void *priv)
 -{
 -	struct nsim_fib_data *data = priv;
 +		data->ipv4.fib.num = 0ULL;
 +		data->ipv4.rules.num = 0ULL;
  
 -	return nsim_fib_get_val(data, NSIM_RESOURCE_IPV4_FIB, false);
 +		data->ipv6.fib.num = 0ULL;
 +		data->ipv6.rules.num = 0ULL;
 +	}
 +	rcu_read_unlock();
  }
  
 -static u64 nsim_fib_ipv4_rules_res_occ_get(void *priv)
 +static struct notifier_block nsim_fib_nb = {
 +	.notifier_call = nsim_fib_event_nb,
 +};
 +
 +/* Initialize per network namespace state */
 +static int __net_init nsim_fib_netns_init(struct net *net)
  {
 -	struct nsim_fib_data *data = priv;
 +	struct nsim_fib_data *data = net_generic(net, nsim_fib_net_id);
  
 -	return nsim_fib_get_val(data, NSIM_RESOURCE_IPV4_FIB_RULES, false);
 -}
 +	data->ipv4.fib.max = (u64)-1;
 +	data->ipv4.rules.max = (u64)-1;
  
 -static u64 nsim_fib_ipv6_resource_occ_get(void *priv)
 -{
 -	struct nsim_fib_data *data = priv;
 +	data->ipv6.fib.max = (u64)-1;
 +	data->ipv6.rules.max = (u64)-1;
  
 -	return nsim_fib_get_val(data, NSIM_RESOURCE_IPV6_FIB, false);
++<<<<<<< HEAD
 +	return 0;
  }
  
 -static u64 nsim_fib_ipv6_rules_res_occ_get(void *priv)
 -{
 -	struct nsim_fib_data *data = priv;
 +static struct pernet_operations nsim_fib_net_ops = {
 +	.init = nsim_fib_netns_init,
 +	.id   = &nsim_fib_net_id,
 +	.size = sizeof(struct nsim_fib_data),
 +};
  
 -	return nsim_fib_get_val(data, NSIM_RESOURCE_IPV6_FIB_RULES, false);
 +void nsim_fib_exit(void)
 +{
 +	unregister_fib_notifier(&nsim_fib_nb);
 +	unregister_pernet_subsys(&nsim_fib_net_ops);
  }
  
 -struct nsim_fib_data *nsim_fib_create(struct devlink *devlink)
 +int nsim_fib_init(void)
  {
 -	struct nsim_fib_data *data;
  	int err;
  
 -	data = kzalloc(sizeof(*data), GFP_KERNEL);
 -	if (!data)
 -		return ERR_PTR(-ENOMEM);
 -
 -	data->ipv4.fib.max = (u64)-1;
 -	data->ipv4.rules.max = (u64)-1;
 -
 -	data->ipv6.fib.max = (u64)-1;
 -	data->ipv6.rules.max = (u64)-1;
 -
 +	err = register_pernet_subsys(&nsim_fib_net_ops);
 +	if (err < 0) {
 +		pr_err("Failed to register pernet subsystem\n");
++=======
+ 	data->fib_nb.notifier_call = nsim_fib_event_nb;
+ 	err = register_fib_notifier(&init_net, &data->fib_nb,
+ 				    nsim_fib_dump_inconsistent, NULL);
+ 	if (err) {
+ 		pr_err("Failed to register fib notifier\n");
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  		goto err_out;
  	}
  
diff --cc include/linux/mroute_base.h
index b9c6c04d2ed3,8071148f29a6..000000000000
--- a/include/linux/mroute_base.h
+++ b/include/linux/mroute_base.h
@@@ -56,7 -56,7 +57,11 @@@ static inline int mr_call_vif_notifier(
  	struct vif_entry_notifier_info info = {
  		.info = {
  			.family = family,
++<<<<<<< HEAD
 +			.net = net,
++=======
+ 			.extack = extack,
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  		},
  		.dev = vif->dev,
  		.vif_index = vif_index,
@@@ -173,15 -172,15 +178,20 @@@ struct mfc_entry_notifier_info 
  };
  
  static inline int mr_call_mfc_notifier(struct notifier_block *nb,
 +				       struct net *net,
  				       unsigned short family,
  				       enum fib_event_type event_type,
- 				       struct mr_mfc *mfc, u32 tb_id)
+ 				       struct mr_mfc *mfc, u32 tb_id,
+ 				       struct netlink_ext_ack *extack)
  {
  	struct mfc_entry_notifier_info info = {
  		.info = {
  			.family = family,
++<<<<<<< HEAD
 +			.net = net,
++=======
+ 			.extack = extack,
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  		},
  		.mfc = mfc,
  		.tb_id = tb_id
diff --cc include/net/fib_notifier.h
index c49d7bfb5c30,6d59221ff05a..000000000000
--- a/include/net/fib_notifier.h
+++ b/include/net/fib_notifier.h
@@@ -40,9 -40,10 +41,16 @@@ int call_fib_notifier(struct notifier_b
  		      struct fib_notifier_info *info);
  int call_fib_notifiers(struct net *net, enum fib_event_type event_type,
  		       struct fib_notifier_info *info);
++<<<<<<< HEAD
 +int register_fib_notifier(struct notifier_block *nb,
 +			  void (*cb)(struct notifier_block *nb));
 +int unregister_fib_notifier(struct notifier_block *nb);
++=======
+ int register_fib_notifier(struct net *net, struct notifier_block *nb,
+ 			  void (*cb)(struct notifier_block *nb),
+ 			  struct netlink_ext_ack *extack);
+ int unregister_fib_notifier(struct net *net, struct notifier_block *nb);
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  struct fib_notifier_ops *
  fib_notifier_ops_register(const struct fib_notifier_ops *tmpl, struct net *net);
  void fib_notifier_ops_unregister(struct fib_notifier_ops *ops);
diff --cc include/net/ip_fib.h
index cf0696685354,52b2406a5dfc..000000000000
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@@ -211,7 -228,9 +211,13 @@@ int call_fib4_notifiers(struct net *net
  int __net_init fib4_notifier_init(struct net *net);
  void __net_exit fib4_notifier_exit(struct net *net);
  
++<<<<<<< HEAD
 +void fib_notify(struct net *net, struct notifier_block *nb);
++=======
+ void fib_info_notify_update(struct net *net, struct nl_info *info);
+ int fib_notify(struct net *net, struct notifier_block *nb,
+ 	       struct netlink_ext_ack *extack);
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  
  struct fib_table {
  	struct hlist_node	tb_hlist;
diff --cc net/core/fib_notifier.c
index 470a606d5e8d,fc96259807b6..000000000000
--- a/net/core/fib_notifier.c
+++ b/net/core/fib_notifier.c
@@@ -69,22 -62,25 +70,22 @@@ static int fib_net_dump(struct net *net
  {
  	struct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);
  	struct fib_notifier_ops *ops;
 -	int err = 0;
  
 -	rcu_read_lock();
  	list_for_each_entry_rcu(ops, &fn_net->fib_notifier_ops, list) {
 +		int err;
 +
  		if (!try_module_get(ops->owner))
  			continue;
- 		err = ops->fib_dump(net, nb);
+ 		err = ops->fib_dump(net, nb, extack);
  		module_put(ops->owner);
  		if (err)
 -			goto unlock;
 +			return err;
  	}
  
 -unlock:
 -	rcu_read_unlock();
 -
 -	return err;
 +	return 0;
  }
  
 -static bool fib_dump_is_consistent(struct net *net, struct notifier_block *nb,
 +static bool fib_dump_is_consistent(struct notifier_block *nb,
  				   void (*cb)(struct notifier_block *nb),
  				   unsigned int fib_seq)
  {
@@@ -98,25 -96,21 +99,37 @@@
  }
  
  #define FIB_DUMP_MAX_RETRIES 5
++<<<<<<< HEAD
 +int register_fib_notifier(struct notifier_block *nb,
 +			  void (*cb)(struct notifier_block *nb))
++=======
+ int register_fib_notifier(struct net *net, struct notifier_block *nb,
+ 			  void (*cb)(struct notifier_block *nb),
+ 			  struct netlink_ext_ack *extack)
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  {
  	int retries = 0;
  	int err;
  
  	do {
 -		unsigned int fib_seq = fib_seq_sum(net);
 -
 +		unsigned int fib_seq = fib_seq_sum();
 +		struct net *net;
 +
++<<<<<<< HEAD
 +		rcu_read_lock();
 +		for_each_net_rcu(net) {
 +			err = fib_net_dump(net, nb);
 +			if (err)
 +				goto err_fib_net_dump;
 +		}
 +		rcu_read_unlock();
++=======
+ 		err = fib_net_dump(net, nb, extack);
+ 		if (err)
+ 			return err;
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  
 -		if (fib_dump_is_consistent(net, nb, cb, fib_seq))
 +		if (fib_dump_is_consistent(nb, cb, fib_seq))
  			return 0;
  	} while (++retries < FIB_DUMP_MAX_RETRIES);
  
diff --cc net/core/fib_rules.c
index 390d8b5d62ef,3e7e15278c46..000000000000
--- a/net/core/fib_rules.c
+++ b/net/core/fib_rules.c
@@@ -324,9 -321,10 +324,10 @@@ out
  }
  EXPORT_SYMBOL_GPL(fib_rules_lookup);
  
 -static int call_fib_rule_notifier(struct notifier_block *nb,
 +static int call_fib_rule_notifier(struct notifier_block *nb, struct net *net,
  				  enum fib_event_type event_type,
- 				  struct fib_rule *rule, int family)
+ 				  struct fib_rule *rule, int family,
+ 				  struct netlink_ext_ack *extack)
  {
  	struct fib_rule_notifier_info info = {
  		.info.family = family,
@@@ -361,12 -362,15 +364,21 @@@ int fib_rules_dump(struct net *net, str
  	ops = lookup_rules_ops(net, family);
  	if (!ops)
  		return -EAFNOSUPPORT;
++<<<<<<< HEAD
 +	list_for_each_entry_rcu(rule, &ops->rules_list, list)
 +		call_fib_rule_notifier(nb, net, FIB_EVENT_RULE_ADD, rule,
 +				       family);
++=======
+ 	list_for_each_entry_rcu(rule, &ops->rules_list, list) {
+ 		err = call_fib_rule_notifier(nb, FIB_EVENT_RULE_ADD,
+ 					     rule, family, extack);
+ 		if (err)
+ 			break;
+ 	}
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  	rules_ops_put(ops);
  
 -	return err;
 +	return 0;
  }
  EXPORT_SYMBOL_GPL(fib_rules_dump);
  
diff --cc net/ipv4/fib_notifier.c
index b804ccbdb241,0c28bd469a68..000000000000
--- a/net/ipv4/fib_notifier.c
+++ b/net/ipv4/fib_notifier.c
@@@ -42,9 -43,7 +43,13 @@@ static int fib4_dump(struct net *net, s
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	fib_notify(net, nb);
 +
 +	return 0;
++=======
+ 	return fib_notify(net, nb, extack);
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  }
  
  static const struct fib_notifier_ops fib4_notifier_ops_template = {
diff --cc net/ipv4/fib_trie.c
index cbaed1062674,b9df9c09b84e..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -86,11 -74,13 +86,13 @@@
  #include <trace/events/fib.h>
  #include "fib_lookup.h"
  
 -static int call_fib_entry_notifier(struct notifier_block *nb,
 +static int call_fib_entry_notifier(struct notifier_block *nb, struct net *net,
  				   enum fib_event_type event_type, u32 dst,
- 				   int dst_len, struct fib_alias *fa)
+ 				   int dst_len, struct fib_alias *fa,
+ 				   struct netlink_ext_ack *extack)
  {
  	struct fib_entry_notifier_info info = {
+ 		.info.extack = extack,
  		.dst = dst,
  		.dst_len = dst_len,
  		.fi = fa->fa_info,
@@@ -1942,10 -1946,83 +1944,87 @@@ int fib_table_flush(struct net *net, st
  	return found;
  }
  
++<<<<<<< HEAD
 +static void fib_leaf_notify(struct net *net, struct key_vector *l,
 +			    struct fib_table *tb, struct notifier_block *nb)
++=======
+ /* derived from fib_trie_free */
+ static void __fib_info_notify_update(struct net *net, struct fib_table *tb,
+ 				     struct nl_info *info)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *pn = t->kv;
+ 	unsigned long cindex = 1;
+ 	struct fib_alias *fa;
+ 
+ 	for (;;) {
+ 		struct key_vector *n;
+ 
+ 		if (!(cindex--)) {
+ 			t_key pkey = pn->key;
+ 
+ 			if (IS_TRIE(pn))
+ 				break;
+ 
+ 			pn = node_parent(pn);
+ 			cindex = get_index(pkey, pn);
+ 			continue;
+ 		}
+ 
+ 		/* grab the next available node */
+ 		n = get_child(pn, cindex);
+ 		if (!n)
+ 			continue;
+ 
+ 		if (IS_TNODE(n)) {
+ 			/* record pn and cindex for leaf walking */
+ 			pn = n;
+ 			cindex = 1ul << n->bits;
+ 
+ 			continue;
+ 		}
+ 
+ 		hlist_for_each_entry(fa, &n->leaf, fa_list) {
+ 			struct fib_info *fi = fa->fa_info;
+ 
+ 			if (!fi || !fi->nh_updated || fa->tb_id != tb->tb_id)
+ 				continue;
+ 
+ 			rtmsg_fib(RTM_NEWROUTE, htonl(n->key), fa,
+ 				  KEYLENGTH - fa->fa_slen, tb->tb_id,
+ 				  info, NLM_F_REPLACE);
+ 
+ 			/* call_fib_entry_notifiers will be removed when
+ 			 * in-kernel notifier is implemented and supported
+ 			 * for nexthop objects
+ 			 */
+ 			call_fib_entry_notifiers(net, FIB_EVENT_ENTRY_REPLACE,
+ 						 n->key,
+ 						 KEYLENGTH - fa->fa_slen, fa,
+ 						 NULL);
+ 		}
+ 	}
+ }
+ 
+ void fib_info_notify_update(struct net *net, struct nl_info *info)
+ {
+ 	unsigned int h;
+ 
+ 	for (h = 0; h < FIB_TABLE_HASHSZ; h++) {
+ 		struct hlist_head *head = &net->ipv4.fib_table_hash[h];
+ 		struct fib_table *tb;
+ 
+ 		hlist_for_each_entry_rcu(tb, head, tb_hlist)
+ 			__fib_info_notify_update(net, tb, info);
+ 	}
+ }
+ 
+ static int fib_leaf_notify(struct key_vector *l, struct fib_table *tb,
+ 			   struct notifier_block *nb,
+ 			   struct netlink_ext_ack *extack)
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  {
  	struct fib_alias *fa;
 -	int err;
  
  	hlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {
  		struct fib_info *fi = fa->fa_info;
@@@ -1959,39 -2036,53 +2038,71 @@@
  		if (tb->tb_id != fa->tb_id)
  			continue;
  
++<<<<<<< HEAD
 +		call_fib_entry_notifier(nb, net, FIB_EVENT_ENTRY_ADD, l->key,
 +					KEYLENGTH - fa->fa_slen, fa);
++=======
+ 		err = call_fib_entry_notifier(nb, FIB_EVENT_ENTRY_ADD, l->key,
+ 					      KEYLENGTH - fa->fa_slen,
+ 					      fa, extack);
+ 		if (err)
+ 			return err;
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  	}
 -	return 0;
  }
  
++<<<<<<< HEAD
 +static void fib_table_notify(struct net *net, struct fib_table *tb,
 +			     struct notifier_block *nb)
++=======
+ static int fib_table_notify(struct fib_table *tb, struct notifier_block *nb,
+ 			    struct netlink_ext_ack *extack)
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  {
  	struct trie *t = (struct trie *)tb->tb_data;
  	struct key_vector *l, *tp = t->kv;
  	t_key key = 0;
 -	int err;
  
  	while ((l = leaf_walk_rcu(&tp, key)) != NULL) {
++<<<<<<< HEAD
 +		fib_leaf_notify(net, l, tb, nb);
++=======
+ 		err = fib_leaf_notify(l, tb, nb, extack);
+ 		if (err)
+ 			return err;
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  
  		key = l->key + 1;
  		/* stop in case of wrap around */
  		if (key < l->key)
  			break;
  	}
 -	return 0;
  }
  
++<<<<<<< HEAD
 +void fib_notify(struct net *net, struct notifier_block *nb)
++=======
+ int fib_notify(struct net *net, struct notifier_block *nb,
+ 	       struct netlink_ext_ack *extack)
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  {
  	unsigned int h;
 -	int err;
  
  	for (h = 0; h < FIB_TABLE_HASHSZ; h++) {
  		struct hlist_head *head = &net->ipv4.fib_table_hash[h];
  		struct fib_table *tb;
  
++<<<<<<< HEAD
 +		hlist_for_each_entry_rcu(tb, head, tb_hlist)
 +			fib_table_notify(net, tb, nb);
++=======
+ 		hlist_for_each_entry_rcu(tb, head, tb_hlist) {
+ 			err = fib_table_notify(tb, nb, extack);
+ 			if (err)
+ 				return err;
+ 		}
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  	}
 -	return 0;
  }
  
  static void __trie_free_rcu(struct rcu_head *head)
diff --cc net/ipv4/ipmr_base.c
index ea48bd15a575,aa8738a91210..000000000000
--- a/net/ipv4/ipmr_base.c
+++ b/net/ipv4/ipmr_base.c
@@@ -409,17 -411,25 +411,35 @@@ int mr_dump(struct net *net, struct not
  			if (!v->dev)
  				continue;
  
++<<<<<<< HEAD
 +			mr_call_vif_notifier(nb, net, family,
 +					     FIB_EVENT_VIF_ADD,
 +					     v, vifi, mrt->id);
++=======
+ 			err = mr_call_vif_notifier(nb, family,
+ 						   FIB_EVENT_VIF_ADD,
+ 						   v, vifi, mrt->id, extack);
+ 			if (err)
+ 				break;
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  		}
  		read_unlock(mrt_lock);
  
 -		if (err)
 -			return err;
 -
  		/* Notify on table MFC entries */
++<<<<<<< HEAD
 +		list_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list)
 +			mr_call_mfc_notifier(nb, net, family,
 +					     FIB_EVENT_ENTRY_ADD,
 +					     mfc, mrt->id);
++=======
+ 		list_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list) {
+ 			err = mr_call_mfc_notifier(nb, family,
+ 						   FIB_EVENT_ENTRY_ADD,
+ 						   mfc, mrt->id, extack);
+ 			if (err)
+ 				return err;
+ 		}
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  	}
  
  	return 0;
diff --cc net/ipv6/ip6_fib.c
index 246c67f714a3,f66bc2af4e9d..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -390,11 -357,13 +390,13 @@@ unsigned int fib6_tables_seq_read(struc
  	return fib_seq;
  }
  
 -static int call_fib6_entry_notifier(struct notifier_block *nb,
 +static int call_fib6_entry_notifier(struct notifier_block *nb, struct net *net,
  				    enum fib_event_type event_type,
- 				    struct fib6_info *rt)
+ 				    struct fib6_info *rt,
+ 				    struct netlink_ext_ack *extack)
  {
  	struct fib6_entry_notifier_info info = {
+ 		.info.extack = extack,
  		.rt = rt,
  	};
  
@@@ -418,13 -387,31 +420,20 @@@ static int call_fib6_entry_notifiers(st
  struct fib6_dump_arg {
  	struct net *net;
  	struct notifier_block *nb;
+ 	struct netlink_ext_ack *extack;
  };
  
 -static int fib6_rt_dump(struct fib6_info *rt, struct fib6_dump_arg *arg)
 +static void fib6_rt_dump(struct fib6_info *rt, struct fib6_dump_arg *arg)
  {
  	if (rt == arg->net->ipv6.fib6_null_entry)
++<<<<<<< HEAD
 +		return;
 +	call_fib6_entry_notifier(arg->nb, arg->net, FIB_EVENT_ENTRY_ADD, rt);
++=======
+ 		return 0;
+ 	return call_fib6_entry_notifier(arg->nb, FIB_EVENT_ENTRY_ADD,
+ 					rt, arg->extack);
++>>>>>>> b7a595577ef3 (net: fib_notifier: propagate extack down to the notifier block callback)
  }
  
  static int fib6_node_dump(struct fib6_walker *w)
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
* Unmerged path drivers/net/ethernet/rocker/rocker_main.c
* Unmerged path drivers/net/netdevsim/fib.c
* Unmerged path include/linux/mroute_base.h
* Unmerged path include/net/fib_notifier.h
diff --git a/include/net/fib_rules.h b/include/net/fib_rules.h
index 9dcd04b874fa..fe995ef5bd57 100644
--- a/include/net/fib_rules.h
+++ b/include/net/fib_rules.h
@@ -205,7 +205,8 @@ int fib_rules_lookup(struct fib_rules_ops *, struct flowi *, int flags,
 int fib_default_rule_add(struct fib_rules_ops *, u32 pref, u32 table,
 			 u32 flags);
 bool fib_rule_matchall(const struct fib_rule *rule);
-int fib_rules_dump(struct net *net, struct notifier_block *nb, int family);
+int fib_rules_dump(struct net *net, struct notifier_block *nb, int family,
+		   struct netlink_ext_ack *extack);
 unsigned int fib_rules_seq_read(struct net *net, int family);
 
 int fib_nl_newrule(struct sk_buff *skb, struct nlmsghdr *nlh,
diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h
index 390067ba9e95..2df6b7ddb809 100644
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@ -462,7 +462,8 @@ int __net_init fib6_notifier_init(struct net *net);
 void __net_exit fib6_notifier_exit(struct net *net);
 
 unsigned int fib6_tables_seq_read(struct net *net);
-int fib6_tables_dump(struct net *net, struct notifier_block *nb);
+int fib6_tables_dump(struct net *net, struct notifier_block *nb,
+		     struct netlink_ext_ack *extack);
 
 void fib6_update_sernum(struct net *net, struct fib6_info *rt);
 void fib6_update_sernum_upto_root(struct net *net, struct fib6_info *rt);
@@ -477,7 +478,8 @@ static inline bool fib6_metric_locked(struct fib6_info *f6i, int metric)
 int fib6_rules_init(void);
 void fib6_rules_cleanup(void);
 bool fib6_rule_default(const struct fib_rule *rule);
-int fib6_rules_dump(struct net *net, struct notifier_block *nb);
+int fib6_rules_dump(struct net *net, struct notifier_block *nb,
+		    struct netlink_ext_ack *extack);
 unsigned int fib6_rules_seq_read(struct net *net);
 
 static inline bool fib6_rules_early_flow_dissect(struct net *net,
@@ -510,7 +512,8 @@ static inline bool fib6_rule_default(const struct fib_rule *rule)
 {
 	return true;
 }
-static inline int fib6_rules_dump(struct net *net, struct notifier_block *nb)
+static inline int fib6_rules_dump(struct net *net, struct notifier_block *nb,
+				  struct netlink_ext_ack *extack)
 {
 	return 0;
 }
* Unmerged path include/net/ip_fib.h
* Unmerged path net/core/fib_notifier.c
* Unmerged path net/core/fib_rules.c
* Unmerged path net/ipv4/fib_notifier.c
diff --git a/net/ipv4/fib_rules.c b/net/ipv4/fib_rules.c
index f8eb78d042a4..19ef5110ae13 100644
--- a/net/ipv4/fib_rules.c
+++ b/net/ipv4/fib_rules.c
@@ -68,9 +68,10 @@ bool fib4_rule_default(const struct fib_rule *rule)
 }
 EXPORT_SYMBOL_GPL(fib4_rule_default);
 
-int fib4_rules_dump(struct net *net, struct notifier_block *nb)
+int fib4_rules_dump(struct net *net, struct notifier_block *nb,
+		    struct netlink_ext_ack *extack)
 {
-	return fib_rules_dump(net, nb, AF_INET);
+	return fib_rules_dump(net, nb, AF_INET, extack);
 }
 
 unsigned int fib4_rules_seq_read(struct net *net)
* Unmerged path net/ipv4/fib_trie.c
diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c
index 51fae1b7c854..9080607b17ec 100644
--- a/net/ipv4/ipmr.c
+++ b/net/ipv4/ipmr.c
@@ -283,9 +283,10 @@ static void __net_exit ipmr_rules_exit(struct net *net)
 	rtnl_unlock();
 }
 
-static int ipmr_rules_dump(struct net *net, struct notifier_block *nb)
+static int ipmr_rules_dump(struct net *net, struct notifier_block *nb,
+			   struct netlink_ext_ack *extack)
 {
-	return fib_rules_dump(net, nb, RTNL_FAMILY_IPMR);
+	return fib_rules_dump(net, nb, RTNL_FAMILY_IPMR, extack);
 }
 
 static unsigned int ipmr_rules_seq_read(struct net *net)
@@ -341,7 +342,8 @@ static void __net_exit ipmr_rules_exit(struct net *net)
 	rtnl_unlock();
 }
 
-static int ipmr_rules_dump(struct net *net, struct notifier_block *nb)
+static int ipmr_rules_dump(struct net *net, struct notifier_block *nb,
+			   struct netlink_ext_ack *extack)
 {
 	return 0;
 }
@@ -3016,10 +3018,11 @@ static unsigned int ipmr_seq_read(struct net *net)
 	return net->ipv4.ipmr_seq + ipmr_rules_seq_read(net);
 }
 
-static int ipmr_dump(struct net *net, struct notifier_block *nb)
+static int ipmr_dump(struct net *net, struct notifier_block *nb,
+		     struct netlink_ext_ack *extack)
 {
 	return mr_dump(net, nb, RTNL_FAMILY_IPMR, ipmr_rules_dump,
-		       ipmr_mr_table_iter, &mrt_lock);
+		       ipmr_mr_table_iter, &mrt_lock, extack);
 }
 
 static const struct fib_notifier_ops ipmr_notifier_ops_template = {
* Unmerged path net/ipv4/ipmr_base.c
diff --git a/net/ipv6/fib6_notifier.c b/net/ipv6/fib6_notifier.c
index 05f82baaa99e..3af123d84628 100644
--- a/net/ipv6/fib6_notifier.c
+++ b/net/ipv6/fib6_notifier.c
@@ -27,15 +27,16 @@ static unsigned int fib6_seq_read(struct net *net)
 	return fib6_tables_seq_read(net) + fib6_rules_seq_read(net);
 }
 
-static int fib6_dump(struct net *net, struct notifier_block *nb)
+static int fib6_dump(struct net *net, struct notifier_block *nb,
+		     struct netlink_ext_ack *extack)
 {
 	int err;
 
-	err = fib6_rules_dump(net, nb);
+	err = fib6_rules_dump(net, nb, extack);
 	if (err)
 		return err;
 
-	return fib6_tables_dump(net, nb);
+	return fib6_tables_dump(net, nb, extack);
 }
 
 static const struct fib_notifier_ops fib6_notifier_ops_template = {
diff --git a/net/ipv6/fib6_rules.c b/net/ipv6/fib6_rules.c
index f590446595d8..faa910bf5224 100644
--- a/net/ipv6/fib6_rules.c
+++ b/net/ipv6/fib6_rules.c
@@ -50,9 +50,10 @@ bool fib6_rule_default(const struct fib_rule *rule)
 }
 EXPORT_SYMBOL_GPL(fib6_rule_default);
 
-int fib6_rules_dump(struct net *net, struct notifier_block *nb)
+int fib6_rules_dump(struct net *net, struct notifier_block *nb,
+		    struct netlink_ext_ack *extack)
 {
-	return fib_rules_dump(net, nb, AF_INET6);
+	return fib_rules_dump(net, nb, AF_INET6, extack);
 }
 
 unsigned int fib6_rules_seq_read(struct net *net)
* Unmerged path net/ipv6/ip6_fib.c
diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c
index cb4fbd92c830..e847e783a714 100644
--- a/net/ipv6/ip6mr.c
+++ b/net/ipv6/ip6mr.c
@@ -264,9 +264,10 @@ static void __net_exit ip6mr_rules_exit(struct net *net)
 	rtnl_unlock();
 }
 
-static int ip6mr_rules_dump(struct net *net, struct notifier_block *nb)
+static int ip6mr_rules_dump(struct net *net, struct notifier_block *nb,
+			    struct netlink_ext_ack *extack)
 {
-	return fib_rules_dump(net, nb, RTNL_FAMILY_IP6MR);
+	return fib_rules_dump(net, nb, RTNL_FAMILY_IP6MR, extack);
 }
 
 static unsigned int ip6mr_rules_seq_read(struct net *net)
@@ -323,7 +324,8 @@ static void __net_exit ip6mr_rules_exit(struct net *net)
 	rtnl_unlock();
 }
 
-static int ip6mr_rules_dump(struct net *net, struct notifier_block *nb)
+static int ip6mr_rules_dump(struct net *net, struct notifier_block *nb,
+			    struct netlink_ext_ack *extack)
 {
 	return 0;
 }
@@ -1251,10 +1253,11 @@ static unsigned int ip6mr_seq_read(struct net *net)
 	return net->ipv6.ipmr_seq + ip6mr_rules_seq_read(net);
 }
 
-static int ip6mr_dump(struct net *net, struct notifier_block *nb)
+static int ip6mr_dump(struct net *net, struct notifier_block *nb,
+		      struct netlink_ext_ack *extack)
 {
 	return mr_dump(net, nb, RTNL_FAMILY_IP6MR, ip6mr_rules_dump,
-		       ip6mr_mr_table_iter, &mrt_lock);
+		       ip6mr_mr_table_iter, &mrt_lock, extack);
 }
 
 static struct notifier_block ip6_mr_notifier = {
