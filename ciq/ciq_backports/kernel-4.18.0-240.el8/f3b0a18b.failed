net: remove unnecessary variables and callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] remove unnecessary variables and callback (Ivan Vecera) [1818074]
Rebuild_FUZZ: 94.25%
commit-author Taehee Yoo <ap420073@gmail.com>
commit f3b0a18bb6cb07a9abb75e21b1f08eeaefa78e81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f3b0a18b.failed

This patch removes variables and callback these are related to the nested
device structure.
devices that can be nested have their own nest_level variable that
represents the depth of nested devices.
In the previous patch, new {lower/upper}_level variables are added and
they replace old private nest_level variable.
So, this patch removes all 'nest_level' variables.

In order to avoid lockdep warning, ->ndo_get_lock_subclass() was added
to get lockdep subclass value, which is actually lower nested depth value.
But now, they use the dynamic lockdep key to avoid lockdep warning instead
of the subclass.
So, this patch removes ->ndo_get_lock_subclass() callback.

	Signed-off-by: Taehee Yoo <ap420073@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f3b0a18bb6cb07a9abb75e21b1f08eeaefa78e81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/bonding/bond_main.c
#	drivers/net/macsec.c
#	drivers/net/macvlan.c
#	net/8021q/vlan_dev.c
diff --cc drivers/net/bonding/bond_main.c
index 1aa92386a579,a48950b81434..000000000000
--- a/drivers/net/bonding/bond_main.c
+++ b/drivers/net/bonding/bond_main.c
@@@ -4762,9 -4756,6 +4749,12 @@@ static int bond_init(struct net_device 
  	if (!bond->wq)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	bond->nest_level = SINGLE_DEPTH_NESTING;
 +	netdev_lockdep_set_classes(bond_dev);
 +
++=======
++>>>>>>> f3b0a18bb6cb (net: remove unnecessary variables and callback)
  	spin_lock_init(&bond->mode_lock);
  	spin_lock_init(&bond->stats_lock);
  	lockdep_register_key(&bond->stats_lock_key);
diff --cc drivers/net/macsec.c
index a36eb122dee0,afd8b2a08245..000000000000
--- a/drivers/net/macsec.c
+++ b/drivers/net/macsec.c
@@@ -2960,13 -2956,6 +2959,16 @@@ static int macsec_get_iflink(const stru
  	return macsec_priv(dev)->real_dev->ifindex;
  }
  
++<<<<<<< HEAD
 +
 +static int macsec_get_nest_level(struct net_device *dev)
 +{
 +	return macsec_priv(dev)->nest_level;
 +}
 +
 +
++=======
++>>>>>>> f3b0a18bb6cb (net: remove unnecessary variables and callback)
  static const struct net_device_ops macsec_netdev_ops = {
  	.ndo_init		= macsec_dev_init,
  	.ndo_uninit		= macsec_dev_uninit,
@@@ -3263,12 -3251,6 +3264,15 @@@ static int macsec_newlink(struct net *n
  	if (err < 0)
  		return err;
  
++<<<<<<< HEAD
 +	macsec->nest_level = dev_get_nest_level(real_dev) + 1;
 +	netdev_lockdep_set_classes(dev);
 +	lockdep_set_class_and_subclass(&dev->addr_list_lock,
 +				       &macsec_netdev_addr_lock_key,
 +				       macsec_get_nest_level(dev));
 +
++=======
++>>>>>>> f3b0a18bb6cb (net: remove unnecessary variables and callback)
  	err = netdev_upper_dev_link(real_dev, dev, extack);
  	if (err < 0)
  		goto unregister;
diff --cc drivers/net/macvlan.c
index 8839b02c1ee5,34fc59bd1e20..000000000000
--- a/drivers/net/macvlan.c
+++ b/drivers/net/macvlan.c
@@@ -873,19 -867,6 +873,22 @@@ static struct lock_class_key macvlan_ne
  #define MACVLAN_STATE_MASK \
  	((1<<__LINK_STATE_NOCARRIER) | (1<<__LINK_STATE_DORMANT))
  
++<<<<<<< HEAD
 +static int macvlan_get_nest_level(struct net_device *dev)
 +{
 +	return ((struct macvlan_dev *)netdev_priv(dev))->nest_level;
 +}
 +
 +static void macvlan_set_lockdep_class(struct net_device *dev)
 +{
 +	netdev_lockdep_set_classes(dev);
 +	lockdep_set_class_and_subclass(&dev->addr_list_lock,
 +				       &macvlan_netdev_addr_lock_key,
 +				       macvlan_get_nest_level(dev));
 +}
 +
++=======
++>>>>>>> f3b0a18bb6cb (net: remove unnecessary variables and callback)
  static int macvlan_init(struct net_device *dev)
  {
  	struct macvlan_dev *vlan = netdev_priv(dev);
diff --cc net/8021q/vlan_dev.c
index 40c941826146,e5bff5cc6f97..000000000000
--- a/net/8021q/vlan_dev.c
+++ b/net/8021q/vlan_dev.c
@@@ -491,36 -489,6 +491,39 @@@ static void vlan_dev_set_rx_mode(struc
  	dev_uc_sync(vlan_dev_priv(vlan_dev)->real_dev, vlan_dev);
  }
  
++<<<<<<< HEAD
 +/*
 + * vlan network devices have devices nesting below it, and are a special
 + * "super class" of normal network devices; split their locks off into a
 + * separate class since they always nest.
 + */
 +static struct lock_class_key vlan_netdev_xmit_lock_key;
 +static struct lock_class_key vlan_netdev_addr_lock_key;
 +
 +static void vlan_dev_set_lockdep_one(struct net_device *dev,
 +				     struct netdev_queue *txq,
 +				     void *_subclass)
 +{
 +	lockdep_set_class_and_subclass(&txq->_xmit_lock,
 +				       &vlan_netdev_xmit_lock_key,
 +				       *(int *)_subclass);
 +}
 +
 +static void vlan_dev_set_lockdep_class(struct net_device *dev, int subclass)
 +{
 +	lockdep_set_class_and_subclass(&dev->addr_list_lock,
 +				       &vlan_netdev_addr_lock_key,
 +				       subclass);
 +	netdev_for_each_tx_queue(dev, vlan_dev_set_lockdep_one, &subclass);
 +}
 +
 +static int vlan_dev_get_lock_subclass(struct net_device *dev)
 +{
 +	return vlan_dev_priv(dev)->nest_level;
 +}
 +
++=======
++>>>>>>> f3b0a18bb6cb (net: remove unnecessary variables and callback)
  static const struct header_ops vlan_header_ops = {
  	.create	 = vlan_dev_hard_header,
  	.parse	 = eth_header_parse,
diff --git a/drivers/net/bonding/bond_alb.c b/drivers/net/bonding/bond_alb.c
index 8c79bad2a9a5..4f2e6910c623 100644
--- a/drivers/net/bonding/bond_alb.c
+++ b/drivers/net/bonding/bond_alb.c
@@ -952,7 +952,7 @@ static int alb_upper_dev_walk(struct net_device *upper, void *_data)
 	struct bond_vlan_tag *tags;
 
 	if (is_vlan_dev(upper) &&
-	    bond->nest_level == vlan_get_encap_level(upper) - 1) {
+	    bond->dev->lower_level == upper->lower_level - 1) {
 		if (upper->addr_assign_type == NET_ADDR_STOLEN) {
 			alb_send_lp_vid(slave, mac_addr,
 					vlan_dev_vlan_proto(upper),
* Unmerged path drivers/net/bonding/bond_main.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index db960e3ea3cd..e4fd062eec40 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@ -3180,7 +3180,7 @@ static int add_vlan_pop_action(struct mlx5e_priv *priv,
 			       struct mlx5_esw_flow_attr *attr,
 			       u32 *action)
 {
-	int nest_level = vlan_get_encap_level(attr->parse_attr->filter_dev);
+	int nest_level = attr->parse_attr->filter_dev->lower_level;
 	struct flow_action_entry vlan_act = {
 		.id = FLOW_ACTION_VLAN_POP,
 	};
* Unmerged path drivers/net/macsec.c
* Unmerged path drivers/net/macvlan.c
diff --git a/include/linux/if_macvlan.h b/include/linux/if_macvlan.h
index 2e55e4cdbd8a..a367ead4bf4b 100644
--- a/include/linux/if_macvlan.h
+++ b/include/linux/if_macvlan.h
@@ -29,7 +29,6 @@ struct macvlan_dev {
 	netdev_features_t	set_features;
 	enum macvlan_mode	mode;
 	u16			flags;
-	int			nest_level;
 	unsigned int		macaddr_count;
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	struct netpoll		*netpoll;
diff --git a/include/linux/if_vlan.h b/include/linux/if_vlan.h
index 03b08ffded07..3b484948239b 100644
--- a/include/linux/if_vlan.h
+++ b/include/linux/if_vlan.h
@@ -184,7 +184,6 @@ struct vlan_dev_priv {
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	struct netpoll				*netpoll;
 #endif
-	unsigned int				nest_level;
 };
 
 static inline struct vlan_dev_priv *vlan_dev_priv(const struct net_device *dev)
@@ -223,11 +222,6 @@ extern void vlan_vids_del_by_dev(struct net_device *dev,
 
 extern bool vlan_uses_dev(const struct net_device *dev);
 
-static inline int vlan_get_encap_level(struct net_device *dev)
-{
-	BUG_ON(!is_vlan_dev(dev));
-	return vlan_dev_priv(dev)->nest_level;
-}
 #else
 static inline struct net_device *
 __vlan_find_dev_deep_rcu(struct net_device *real_dev,
@@ -289,11 +283,6 @@ static inline bool vlan_uses_dev(const struct net_device *dev)
 {
 	return false;
 }
-static inline int vlan_get_encap_level(struct net_device *dev)
-{
-	BUG();
-	return 0;
-}
 #endif
 
 /**
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 0fb93b618ba7..f91ea5f7ad3a 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -1487,7 +1487,6 @@ struct net_device_ops {
 	void			(*ndo_dfwd_del_station)(struct net_device *pdev,
 							void *priv);
 
-	int			(*ndo_get_lock_subclass)(struct net_device *dev);
 	int			(*ndo_set_tx_maxrate)(struct net_device *dev,
 						      int queue_index,
 						      u32 maxrate);
@@ -4233,16 +4232,6 @@ static inline void netif_addr_lock(struct net_device *dev)
 	spin_lock(&dev->addr_list_lock);
 }
 
-static inline void netif_addr_lock_nested(struct net_device *dev)
-{
-	int subclass = SINGLE_DEPTH_NESTING;
-
-	if (dev->netdev_ops->ndo_get_lock_subclass)
-		subclass = dev->netdev_ops->ndo_get_lock_subclass(dev);
-
-	spin_lock_nested(&dev->addr_list_lock, subclass);
-}
-
 static inline void netif_addr_lock_bh(struct net_device *dev)
 {
 	spin_lock_bh(&dev->addr_list_lock);
@@ -4516,7 +4505,6 @@ void netdev_lower_state_changed(struct net_device *lower_dev,
 extern u8 netdev_rss_key[NETDEV_RSS_KEY_LEN] __read_mostly;
 void netdev_rss_key_fill(void *buffer, size_t len);
 
-int dev_get_nest_level(struct net_device *dev);
 int skb_checksum_help(struct sk_buff *skb);
 int skb_crc32c_csum_help(struct sk_buff *skb);
 int skb_csum_hwoffload_help(struct sk_buff *skb,
diff --git a/include/net/bonding.h b/include/net/bonding.h
index 334909feb2bb..1afc125014da 100644
--- a/include/net/bonding.h
+++ b/include/net/bonding.h
@@ -203,7 +203,6 @@ struct bonding {
 	struct   slave __rcu *primary_slave;
 	struct   bond_up_slave __rcu *slave_arr; /* Array of usable slaves */
 	bool     force_primary;
-	u32      nest_level;
 	s32      slave_cnt; /* never change this value outside the attach/detach wrappers */
 	int     (*recv_probe)(const struct sk_buff *, struct bonding *,
 			      struct slave *);
diff --git a/net/8021q/vlan.c b/net/8021q/vlan.c
index dc4411165e43..3351753440b5 100644
--- a/net/8021q/vlan.c
+++ b/net/8021q/vlan.c
@@ -168,7 +168,6 @@ int register_vlan_dev(struct net_device *dev, struct netlink_ext_ack *extack)
 	if (err < 0)
 		goto out_uninit_mvrp;
 
-	vlan->nest_level = dev_get_nest_level(real_dev) + 1;
 	err = register_netdevice(dev);
 	if (err < 0)
 		goto out_uninit_mvrp;
* Unmerged path net/8021q/vlan_dev.c
diff --git a/net/core/dev.c b/net/core/dev.c
index b1d9a896d680..a10f75aeb4e6 100644
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@ -7372,25 +7372,6 @@ void *netdev_lower_dev_get_private(struct net_device *dev,
 EXPORT_SYMBOL(netdev_lower_dev_get_private);
 
 
-int dev_get_nest_level(struct net_device *dev)
-{
-	struct net_device *lower = NULL;
-	struct list_head *iter;
-	int max_nest = -1;
-	int nest;
-
-	ASSERT_RTNL();
-
-	netdev_for_each_lower_dev(dev, lower, iter) {
-		nest = dev_get_nest_level(lower);
-		if (max_nest < nest)
-			max_nest = nest;
-	}
-
-	return max_nest + 1;
-}
-EXPORT_SYMBOL(dev_get_nest_level);
-
 /**
  * netdev_lower_change - Dispatch event about lower device state change
  * @lower_dev: device
diff --git a/net/core/dev_addr_lists.c b/net/core/dev_addr_lists.c
index 973c0913840a..84c3f0bc7bf9 100644
--- a/net/core/dev_addr_lists.c
+++ b/net/core/dev_addr_lists.c
@@ -544,7 +544,7 @@ int dev_uc_sync(struct net_device *to, struct net_device *from)
 	if (to->addr_len != from->addr_len)
 		return -EINVAL;
 
-	netif_addr_lock_nested(to);
+	netif_addr_lock(to);
 	err = __hw_addr_sync(&to->uc, &from->uc, to->addr_len);
 	if (!err)
 		__dev_set_rx_mode(to);
@@ -574,7 +574,7 @@ int dev_uc_sync_multiple(struct net_device *to, struct net_device *from)
 	if (to->addr_len != from->addr_len)
 		return -EINVAL;
 
-	netif_addr_lock_nested(to);
+	netif_addr_lock(to);
 	err = __hw_addr_sync_multiple(&to->uc, &from->uc, to->addr_len);
 	if (!err)
 		__dev_set_rx_mode(to);
@@ -598,7 +598,7 @@ void dev_uc_unsync(struct net_device *to, struct net_device *from)
 		return;
 
 	netif_addr_lock_bh(from);
-	netif_addr_lock_nested(to);
+	netif_addr_lock(to);
 	__hw_addr_unsync(&to->uc, &from->uc, to->addr_len);
 	__dev_set_rx_mode(to);
 	netif_addr_unlock(to);
@@ -765,7 +765,7 @@ int dev_mc_sync(struct net_device *to, struct net_device *from)
 	if (to->addr_len != from->addr_len)
 		return -EINVAL;
 
-	netif_addr_lock_nested(to);
+	netif_addr_lock(to);
 	err = __hw_addr_sync(&to->mc, &from->mc, to->addr_len);
 	if (!err)
 		__dev_set_rx_mode(to);
@@ -795,7 +795,7 @@ int dev_mc_sync_multiple(struct net_device *to, struct net_device *from)
 	if (to->addr_len != from->addr_len)
 		return -EINVAL;
 
-	netif_addr_lock_nested(to);
+	netif_addr_lock(to);
 	err = __hw_addr_sync_multiple(&to->mc, &from->mc, to->addr_len);
 	if (!err)
 		__dev_set_rx_mode(to);
@@ -819,7 +819,7 @@ void dev_mc_unsync(struct net_device *to, struct net_device *from)
 		return;
 
 	netif_addr_lock_bh(from);
-	netif_addr_lock_nested(to);
+	netif_addr_lock(to);
 	__hw_addr_unsync(&to->mc, &from->mc, to->addr_len);
 	__dev_set_rx_mode(to);
 	netif_addr_unlock(to);
diff --git a/net/smc/smc_core.c b/net/smc/smc_core.c
index e3bdd78ce3e5..59e11efcde38 100644
--- a/net/smc/smc_core.c
+++ b/net/smc/smc_core.c
@@ -557,7 +557,7 @@ int smc_vlan_by_tcpsk(struct socket *clcsock, struct smc_init_info *ini)
 	}
 
 	rtnl_lock();
-	nest_lvl = dev_get_nest_level(ndev);
+	nest_lvl = ndev->lower_level;
 	for (i = 0; i < nest_lvl; i++) {
 		struct list_head *lower = &ndev->adj_list.lower;
 
diff --git a/net/smc/smc_pnet.c b/net/smc/smc_pnet.c
index bab2da8cf17a..2920b006f65c 100644
--- a/net/smc/smc_pnet.c
+++ b/net/smc/smc_pnet.c
@@ -718,7 +718,7 @@ static struct net_device *pnet_find_base_ndev(struct net_device *ndev)
 	int i, nest_lvl;
 
 	rtnl_lock();
-	nest_lvl = dev_get_nest_level(ndev);
+	nest_lvl = ndev->lower_level;
 	for (i = 0; i < nest_lvl; i++) {
 		struct list_head *lower = &ndev->adj_list.lower;
 
