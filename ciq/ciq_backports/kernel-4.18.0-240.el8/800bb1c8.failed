mm: handle multiple owners of device private pages in migrate_vma

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [mm] handle multiple owners of device private pages in migrate_vma (Michael Roth) [1851259]
Rebuild_FUZZ: 96.83%
commit-author Christoph Hellwig <hch@lst.de>
commit 800bb1c8dc80bb4121446b56813067f3ea44edee
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/800bb1c8.failed

Add a new src_owner field to struct migrate_vma.  If the field is set,
only device private pages with page->pgmap->owner equal to that field are
migrated.  If the field is not set only "normal" pages are migrated.

Fixes: df6ad69838fc ("mm/device-public-memory: device memory cache coherent with CPU")
Link: https://lore.kernel.org/r/20200316193216.920734-3-hch@lst.de
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Ralph Campbell <rcampbell@nvidia.com>
	Tested-by: Bharata B Rao <bharata@linux.ibm.com>
	Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
(cherry picked from commit 800bb1c8dc80bb4121446b56813067f3ea44edee)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_hv_uvmem.c
#	drivers/gpu/drm/nouveau/nouveau_dmem.c
#	mm/migrate.c
diff --cc drivers/gpu/drm/nouveau/nouveau_dmem.c
index 98c1d07bfd14,0e36345d395c..000000000000
--- a/drivers/gpu/drm/nouveau/nouveau_dmem.c
+++ b/drivers/gpu/drm/nouveau/nouveau_dmem.c
@@@ -259,10 -174,10 +259,16 @@@ static vm_fault_t nouveau_dmem_migrate_
  		.vma		= vmf->vma,
  		.start		= vmf->address,
  		.end		= vmf->address + PAGE_SIZE,
++<<<<<<< HEAD
 +		.src		= src,
 +		.dst		= dst,
++=======
+ 		.src		= &src,
+ 		.dst		= &dst,
+ 		.src_owner	= drm->dev,
++>>>>>>> 800bb1c8dc80 (mm: handle multiple owners of device private pages in migrate_vma)
  	};
 +	struct nouveau_dmem_fault fault = { .drm = dmem->drm };
  
  	/*
  	 * FIXME what we really want is to find some heuristic to migrate more
diff --cc mm/migrate.c
index db350c642c35,7605d2c23433..000000000000
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@@ -2240,8 -2265,11 +2238,16 @@@ again
  				goto next;
  
  			page = device_private_entry_to_page(entry);
++<<<<<<< HEAD
 +			mpfn = migrate_pfn(page_to_pfn(page))|
 +				MIGRATE_PFN_DEVICE | MIGRATE_PFN_MIGRATE;
++=======
+ 			if (page->pgmap->owner != migrate->src_owner)
+ 				goto next;
+ 
+ 			mpfn = migrate_pfn(page_to_pfn(page)) |
+ 					MIGRATE_PFN_MIGRATE;
++>>>>>>> 800bb1c8dc80 (mm: handle multiple owners of device private pages in migrate_vma)
  			if (is_write_device_private_entry(entry))
  				mpfn |= MIGRATE_PFN_WRITE;
  		} else {
* Unmerged path arch/powerpc/kvm/book3s_hv_uvmem.c
* Unmerged path arch/powerpc/kvm/book3s_hv_uvmem.c
* Unmerged path drivers/gpu/drm/nouveau/nouveau_dmem.c
diff --git a/include/linux/migrate.h b/include/linux/migrate.h
index a0724547188c..724136a35f42 100644
--- a/include/linux/migrate.h
+++ b/include/linux/migrate.h
@@ -200,6 +200,14 @@ struct migrate_vma {
 	unsigned long		npages;
 	unsigned long		start;
 	unsigned long		end;
+
+	/*
+	 * Set to the owner value also stored in page->pgmap->owner for
+	 * migrating out of device private memory.  If set only device
+	 * private pages with this owner are migrated.  If not set
+	 * device private pages are not migrated at all.
+	 */
+	void			*src_owner;
 };
 
 int migrate_vma_setup(struct migrate_vma *args);
* Unmerged path mm/migrate.c
