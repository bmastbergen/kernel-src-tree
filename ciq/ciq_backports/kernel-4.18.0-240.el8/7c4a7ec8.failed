mlxsw: spectrum_router: Remove FIB entry list from FIB node

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ido Schimmel <idosch@mellanox.com>
commit 7c4a7ec8558dfc770c27931b43f01aede613faac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7c4a7ec8.failed

As explained in previous patches, the driver no longer needs to maintain
a list of identical FIB entries (i.e, same {tb_id, prefix, prefix
length}) and therefore each FIB node can only store one FIB entry.

Remove the FIB entry list and simplify the code.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7c4a7ec8558dfc770c27931b43f01aede613faac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 575ab41fc96b,da1c8342c8f5..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -4691,77 -4762,33 +4669,100 @@@ static void mlxsw_sp_fib_node_put(struc
  	mlxsw_sp_vr_put(mlxsw_sp, vr);
  }
  
 -static int mlxsw_sp_fib_node_entry_link(struct mlxsw_sp *mlxsw_sp,
++<<<<<<< HEAD
 +static int mlxsw_sp_fib_node_entry_add(struct mlxsw_sp *mlxsw_sp,
 +				       struct mlxsw_sp_fib_entry *fib_entry)
 +{
 +	struct mlxsw_sp_fib_node *fib_node = fib_entry->fib_node;
 +
 +	/* To prevent packet loss, overwrite the previously offloaded
 +	 * entry.
 +	 */
 +	if (!list_is_singular(&fib_node->entry_list)) {
 +		enum mlxsw_reg_ralue_op op = MLXSW_REG_RALUE_OP_WRITE_DELETE;
 +		struct mlxsw_sp_fib_entry *n = list_next_entry(fib_entry, list);
 +
 +		mlxsw_sp_fib_entry_offload_refresh(n, op, 0);
 +	}
 +
 +	return mlxsw_sp_fib_entry_update(mlxsw_sp, fib_entry);
 +}
 +
 +static void mlxsw_sp_fib_node_entry_del(struct mlxsw_sp *mlxsw_sp,
  					struct mlxsw_sp_fib_entry *fib_entry)
  {
  	struct mlxsw_sp_fib_node *fib_node = fib_entry->fib_node;
 +
 +	if (!mlxsw_sp_fib_node_entry_is_first(fib_node, fib_entry))
 +		return;
 +
 +	mlxsw_sp_fib_entry_del(mlxsw_sp, fib_entry);
 +}
 +
 +static int mlxsw_sp_fib4_node_entry_link(struct mlxsw_sp *mlxsw_sp,
 +					 struct mlxsw_sp_fib4_entry *fib4_entry)
++=======
++static int mlxsw_sp_fib_node_entry_link(struct mlxsw_sp *mlxsw_sp,
++					struct mlxsw_sp_fib_entry *fib_entry)
++>>>>>>> 7c4a7ec8558d (mlxsw: spectrum_router: Remove FIB entry list from FIB node)
 +{
 +	struct mlxsw_sp_fib_node *fib_node = fib4_entry->common.fib_node;
  	int err;
  
++<<<<<<< HEAD
 +	list_add(&fib4_entry->common.list, &fib_node->entry_list);
 +
 +	err = mlxsw_sp_fib_node_entry_add(mlxsw_sp, &fib4_entry->common);
++=======
+ 	fib_node->fib_entry = fib_entry;
+ 
+ 	err = mlxsw_sp_fib_entry_update(mlxsw_sp, fib_entry);
++>>>>>>> 7c4a7ec8558d (mlxsw: spectrum_router: Remove FIB entry list from FIB node)
  	if (err)
- 		goto err_fib_node_entry_add;
+ 		goto err_fib_entry_update;
  
  	return 0;
  
++<<<<<<< HEAD
 +err_fib_node_entry_add:
 +	list_del(&fib4_entry->common.list);
++=======
+ err_fib_entry_update:
+ 	fib_node->fib_entry = NULL;
++>>>>>>> 7c4a7ec8558d (mlxsw: spectrum_router: Remove FIB entry list from FIB node)
  	return err;
  }
  
  static void
 -mlxsw_sp_fib_node_entry_unlink(struct mlxsw_sp *mlxsw_sp,
 -			       struct mlxsw_sp_fib_entry *fib_entry)
 +mlxsw_sp_fib4_node_entry_unlink(struct mlxsw_sp *mlxsw_sp,
 +				struct mlxsw_sp_fib4_entry *fib4_entry)
 +{
++<<<<<<< HEAD
 +	mlxsw_sp_fib_node_entry_del(mlxsw_sp, &fib4_entry->common);
 +	list_del(&fib4_entry->common.list);
 +}
 +
 +static void mlxsw_sp_fib4_entry_replace(struct mlxsw_sp *mlxsw_sp,
 +					struct mlxsw_sp_fib4_entry *fib4_entry)
  {
 +	struct mlxsw_sp_fib_node *fib_node = fib4_entry->common.fib_node;
 +	struct mlxsw_sp_fib4_entry *replaced;
 +
 +	if (list_is_singular(&fib_node->entry_list))
 +		return;
 +
 +	/* We inserted the new entry before replaced one */
 +	replaced = list_next_entry(fib4_entry, common.list);
 +
 +	mlxsw_sp_fib4_node_entry_unlink(mlxsw_sp, replaced);
 +	mlxsw_sp_fib4_entry_destroy(mlxsw_sp, replaced);
 +	mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
++=======
+ 	struct mlxsw_sp_fib_node *fib_node = fib_entry->fib_node;
+ 
+ 	mlxsw_sp_fib_entry_del(mlxsw_sp, fib_entry);
+ 	fib_node->fib_entry = NULL;
++>>>>>>> 7c4a7ec8558d (mlxsw: spectrum_router: Remove FIB entry list from FIB node)
  }
  
  static int
@@@ -4791,17 -4819,26 +4793,34 @@@ mlxsw_sp_router_fib4_replace(struct mlx
  		goto err_fib4_entry_create;
  	}
  
++<<<<<<< HEAD
 +	err = mlxsw_sp_fib4_node_entry_link(mlxsw_sp, fib4_entry);
++=======
+ 	replaced = fib_node->fib_entry;
+ 	err = mlxsw_sp_fib_node_entry_link(mlxsw_sp, &fib4_entry->common);
++>>>>>>> 7c4a7ec8558d (mlxsw: spectrum_router: Remove FIB entry list from FIB node)
  	if (err) {
  		dev_warn(mlxsw_sp->bus_info->dev, "Failed to link FIB entry to node\n");
 -		goto err_fib_node_entry_link;
 +		goto err_fib4_node_entry_link;
  	}
  
- 	mlxsw_sp_fib4_entry_replace(mlxsw_sp, fib4_entry);
+ 	/* Nothing to replace */
+ 	if (!replaced)
+ 		return 0;
+ 
+ 	mlxsw_sp_fib_entry_offload_unset(replaced);
+ 	fib4_replaced = container_of(replaced, struct mlxsw_sp_fib4_entry,
+ 				     common);
+ 	mlxsw_sp_fib4_entry_destroy(mlxsw_sp, fib4_replaced);
  
  	return 0;
  
++<<<<<<< HEAD
 +err_fib4_node_entry_link:
++=======
+ err_fib_node_entry_link:
+ 	fib_node->fib_entry = replaced;
++>>>>>>> 7c4a7ec8558d (mlxsw: spectrum_router: Remove FIB entry list from FIB node)
  	mlxsw_sp_fib4_entry_destroy(mlxsw_sp, fib4_entry);
  err_fib4_entry_create:
  	mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
@@@ -5450,28 -5350,12 +5469,35 @@@ mlxsw_sp_fib6_entry_lookup(struct mlxsw
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static void mlxsw_sp_fib6_entry_replace(struct mlxsw_sp *mlxsw_sp,
 +					struct mlxsw_sp_fib6_entry *fib6_entry,
 +					bool replace)
 +{
 +	struct mlxsw_sp_fib_node *fib_node = fib6_entry->common.fib_node;
 +	struct mlxsw_sp_fib6_entry *replaced;
 +
 +	if (!replace)
 +		return;
 +
 +	replaced = list_next_entry(fib6_entry, common.list);
 +
 +	mlxsw_sp_fib6_node_entry_unlink(mlxsw_sp, replaced);
 +	mlxsw_sp_fib6_entry_destroy(mlxsw_sp, replaced);
 +	mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
 +}
 +
 +static int mlxsw_sp_router_fib6_add(struct mlxsw_sp *mlxsw_sp,
 +				    struct fib6_info **rt_arr,
 +				    unsigned int nrt6, bool replace)
- {
- 	struct mlxsw_sp_fib6_entry *fib6_entry;
++=======
+ static int mlxsw_sp_router_fib6_replace(struct mlxsw_sp *mlxsw_sp,
+ 					struct fib6_info **rt_arr,
+ 					unsigned int nrt6)
++>>>>>>> 7c4a7ec8558d (mlxsw: spectrum_router: Remove FIB entry list from FIB node)
+ {
+ 	struct mlxsw_sp_fib6_entry *fib6_entry, *fib6_replaced;
+ 	struct mlxsw_sp_fib_entry *replaced;
  	struct mlxsw_sp_fib_node *fib_node;
  	struct fib6_info *rt = rt_arr[0];
  	int err;
@@@ -5512,17 -5384,70 +5538,84 @@@
  		goto err_fib6_entry_create;
  	}
  
++<<<<<<< HEAD
 +	err = mlxsw_sp_fib6_node_entry_link(mlxsw_sp, fib6_entry, &replace);
++=======
+ 	replaced = fib_node->fib_entry;
+ 	err = mlxsw_sp_fib_node_entry_link(mlxsw_sp, &fib6_entry->common);
++>>>>>>> 7c4a7ec8558d (mlxsw: spectrum_router: Remove FIB entry list from FIB node)
  	if (err)
 -		goto err_fib_node_entry_link;
 +		goto err_fib6_node_entry_link;
 +
++<<<<<<< HEAD
 +	mlxsw_sp_fib6_entry_replace(mlxsw_sp, fib6_entry, replace);
  
 +	return 0;
 +
 +err_fib6_node_entry_link:
 +	mlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_entry);
 +err_fib6_entry_create:
++=======
+ 	/* Nothing to replace */
+ 	if (!replaced)
+ 		return 0;
+ 
+ 	mlxsw_sp_fib_entry_offload_unset(replaced);
+ 	fib6_replaced = container_of(replaced, struct mlxsw_sp_fib6_entry,
+ 				     common);
+ 	mlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_replaced);
+ 
+ 	return 0;
+ 
+ err_fib_node_entry_link:
+ 	fib_node->fib_entry = replaced;
+ 	mlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_entry);
+ err_fib6_entry_create:
+ 	mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
+ 	return err;
+ }
+ 
+ static int mlxsw_sp_router_fib6_append(struct mlxsw_sp *mlxsw_sp,
+ 				       struct fib6_info **rt_arr,
+ 				       unsigned int nrt6)
+ {
+ 	struct mlxsw_sp_fib6_entry *fib6_entry;
+ 	struct mlxsw_sp_fib_node *fib_node;
+ 	struct fib6_info *rt = rt_arr[0];
+ 	int err;
+ 
+ 	if (mlxsw_sp->router->aborted)
+ 		return 0;
+ 
+ 	if (rt->fib6_src.plen)
+ 		return -EINVAL;
+ 
+ 	if (mlxsw_sp_fib6_rt_should_ignore(rt))
+ 		return 0;
+ 
+ 	fib_node = mlxsw_sp_fib_node_get(mlxsw_sp, rt->fib6_table->tb6_id,
+ 					 &rt->fib6_dst.addr,
+ 					 sizeof(rt->fib6_dst.addr),
+ 					 rt->fib6_dst.plen,
+ 					 MLXSW_SP_L3_PROTO_IPV6);
+ 	if (IS_ERR(fib_node))
+ 		return PTR_ERR(fib_node);
+ 
+ 	if (WARN_ON_ONCE(!fib_node->fib_entry)) {
+ 		mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
+ 		return -EINVAL;
+ 	}
+ 
+ 	fib6_entry = container_of(fib_node->fib_entry,
+ 				  struct mlxsw_sp_fib6_entry, common);
+ 	err = mlxsw_sp_fib6_entry_nexthop_add(mlxsw_sp, fib6_entry, rt_arr,
+ 					      nrt6);
+ 	if (err)
+ 		goto err_fib6_entry_nexthop_add;
+ 
+ 	return 0;
+ 
++>>>>>>> 7c4a7ec8558d (mlxsw: spectrum_router: Remove FIB entry list from FIB node)
  err_fib6_entry_nexthop_add:
  	mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
  	return err;
@@@ -5716,39 -5641,25 +5809,55 @@@ static int mlxsw_sp_router_set_abort_tr
  static void mlxsw_sp_fib4_node_flush(struct mlxsw_sp *mlxsw_sp,
  				     struct mlxsw_sp_fib_node *fib_node)
  {
- 	struct mlxsw_sp_fib4_entry *fib4_entry, *tmp;
+ 	struct mlxsw_sp_fib4_entry *fib4_entry;
  
++<<<<<<< HEAD
 +	list_for_each_entry_safe(fib4_entry, tmp, &fib_node->entry_list,
 +				 common.list) {
 +		bool do_break = &tmp->common.list == &fib_node->entry_list;
 +
 +		mlxsw_sp_fib4_node_entry_unlink(mlxsw_sp, fib4_entry);
 +		mlxsw_sp_fib4_entry_destroy(mlxsw_sp, fib4_entry);
 +		mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
 +		/* Break when entry list is empty and node was freed.
 +		 * Otherwise, we'll access freed memory in the next
 +		 * iteration.
 +		 */
 +		if (do_break)
 +			break;
 +	}
++=======
+ 	fib4_entry = container_of(fib_node->fib_entry,
+ 				  struct mlxsw_sp_fib4_entry, common);
+ 	mlxsw_sp_fib_node_entry_unlink(mlxsw_sp, fib_node->fib_entry);
+ 	mlxsw_sp_fib4_entry_destroy(mlxsw_sp, fib4_entry);
+ 	mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
++>>>>>>> 7c4a7ec8558d (mlxsw: spectrum_router: Remove FIB entry list from FIB node)
  }
  
  static void mlxsw_sp_fib6_node_flush(struct mlxsw_sp *mlxsw_sp,
  				     struct mlxsw_sp_fib_node *fib_node)
  {
- 	struct mlxsw_sp_fib6_entry *fib6_entry, *tmp;
+ 	struct mlxsw_sp_fib6_entry *fib6_entry;
  
++<<<<<<< HEAD
 +	list_for_each_entry_safe(fib6_entry, tmp, &fib_node->entry_list,
 +				 common.list) {
 +		bool do_break = &tmp->common.list == &fib_node->entry_list;
 +
 +		mlxsw_sp_fib6_node_entry_unlink(mlxsw_sp, fib6_entry);
 +		mlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_entry);
 +		mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
 +		if (do_break)
 +			break;
 +	}
++=======
+ 	fib6_entry = container_of(fib_node->fib_entry,
+ 				  struct mlxsw_sp_fib6_entry, common);
+ 	mlxsw_sp_fib_node_entry_unlink(mlxsw_sp, fib_node->fib_entry);
+ 	mlxsw_sp_fib6_entry_destroy(mlxsw_sp, fib6_entry);
+ 	mlxsw_sp_fib_node_put(mlxsw_sp, fib_node);
++>>>>>>> 7c4a7ec8558d (mlxsw: spectrum_router: Remove FIB entry list from FIB node)
  }
  
  static void mlxsw_sp_fib_node_flush(struct mlxsw_sp *mlxsw_sp,
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
