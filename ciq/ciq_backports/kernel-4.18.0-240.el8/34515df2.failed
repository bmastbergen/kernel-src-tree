s390/zcrypt: use kvmalloc instead of kmalloc for 256k alloc

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit 34515df25d7e5ae19f66eadfb1351a3178344f36
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/34515df2.failed

Tests showed that it may happen that a 256k kmalloc may fail
due to a temporary shortage on 256k slab entries.

The find functions for cca and ep11 use a 256k array to fetch the
states of all possible crypto cards and their domains in one
piece. With the patch now kvmalloc is used to allocate this
temporary memory as there is no need to have this memory area
physical continuously.

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Reviewed-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit 34515df25d7e5ae19f66eadfb1351a3178344f36)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/crypto/zcrypt_ep11misc.c
diff --cc drivers/s390/crypto/zcrypt_ep11misc.c
index 3cd8e96d464e,7dd987afcd55..000000000000
--- a/drivers/s390/crypto/zcrypt_ep11misc.c
+++ b/drivers/s390/crypto/zcrypt_ep11misc.c
@@@ -374,6 -539,754 +374,757 @@@ out
  }
  EXPORT_SYMBOL(ep11_get_domain_info);
  
++<<<<<<< HEAD
++=======
+ /*
+  * Default EP11 AES key generate attributes, used when no keygenflags given:
+  * XCP_BLOB_ENCRYPT | XCP_BLOB_DECRYPT | XCP_BLOB_PROTKEY_EXTRACTABLE
+  */
+ #define KEY_ATTR_DEFAULTS 0x00200c00
+ 
+ int ep11_genaeskey(u16 card, u16 domain, u32 keybitsize, u32 keygenflags,
+ 		   u8 *keybuf, size_t *keybufsize)
+ {
+ 	struct keygen_req_pl {
+ 		struct pl_head head;
+ 		u8  var_tag;
+ 		u8  var_len;
+ 		u32 var;
+ 		u8  keybytes_tag;
+ 		u8  keybytes_len;
+ 		u32 keybytes;
+ 		u8  mech_tag;
+ 		u8  mech_len;
+ 		u32 mech;
+ 		u8  attr_tag;
+ 		u8  attr_len;
+ 		u32 attr_header;
+ 		u32 attr_bool_mask;
+ 		u32 attr_bool_bits;
+ 		u32 attr_val_len_type;
+ 		u32 attr_val_len_value;
+ 		u8  pin_tag;
+ 		u8  pin_len;
+ 	} __packed * req_pl;
+ 	struct keygen_rep_pl {
+ 		struct pl_head head;
+ 		u8  rc_tag;
+ 		u8  rc_len;
+ 		u32 rc;
+ 		u8  data_tag;
+ 		u8  data_lenfmt;
+ 		u16 data_len;
+ 		u8  data[512];
+ 	} __packed * rep_pl;
+ 	struct ep11_cprb *req = NULL, *rep = NULL;
+ 	struct ep11_target_dev target;
+ 	struct ep11_urb *urb = NULL;
+ 	struct ep11keyblob *kb;
+ 	int api, rc = -ENOMEM;
+ 
+ 	switch (keybitsize) {
+ 	case 128:
+ 	case 192:
+ 	case 256:
+ 		break;
+ 	default:
+ 		DEBUG_ERR(
+ 			"%s unknown/unsupported keybitsize %d\n",
+ 			__func__, keybitsize);
+ 		rc = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	/* request cprb and payload */
+ 	req = alloc_cprb(sizeof(struct keygen_req_pl));
+ 	if (!req)
+ 		goto out;
+ 	req_pl = (struct keygen_req_pl *) (((u8 *) req) + sizeof(*req));
+ 	api = (!keygenflags || keygenflags & 0x00200000) ? 4 : 1;
+ 	prep_head(&req_pl->head, sizeof(*req_pl), api, 21); /* GenerateKey */
+ 	req_pl->var_tag = 0x04;
+ 	req_pl->var_len = sizeof(u32);
+ 	req_pl->keybytes_tag = 0x04;
+ 	req_pl->keybytes_len = sizeof(u32);
+ 	req_pl->keybytes = keybitsize / 8;
+ 	req_pl->mech_tag = 0x04;
+ 	req_pl->mech_len = sizeof(u32);
+ 	req_pl->mech = 0x00001080; /* CKM_AES_KEY_GEN */
+ 	req_pl->attr_tag = 0x04;
+ 	req_pl->attr_len = 5 * sizeof(u32);
+ 	req_pl->attr_header = 0x10010000;
+ 	req_pl->attr_bool_mask = keygenflags ? keygenflags : KEY_ATTR_DEFAULTS;
+ 	req_pl->attr_bool_bits = keygenflags ? keygenflags : KEY_ATTR_DEFAULTS;
+ 	req_pl->attr_val_len_type = 0x00000161; /* CKA_VALUE_LEN */
+ 	req_pl->attr_val_len_value = keybitsize / 8;
+ 	req_pl->pin_tag = 0x04;
+ 
+ 	/* reply cprb and payload */
+ 	rep = alloc_cprb(sizeof(struct keygen_rep_pl));
+ 	if (!rep)
+ 		goto out;
+ 	rep_pl = (struct keygen_rep_pl *) (((u8 *) rep) + sizeof(*rep));
+ 
+ 	/* urb and target */
+ 	urb = kmalloc(sizeof(struct ep11_urb), GFP_KERNEL);
+ 	if (!urb)
+ 		goto out;
+ 	target.ap_id = card;
+ 	target.dom_id = domain;
+ 	prep_urb(urb, &target, 1,
+ 		 req, sizeof(*req) + sizeof(*req_pl),
+ 		 rep, sizeof(*rep) + sizeof(*rep_pl));
+ 
+ 	rc = _zcrypt_send_ep11_cprb(urb);
+ 	if (rc) {
+ 		DEBUG_ERR(
+ 			"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\n",
+ 			__func__, (int) card, (int) domain, rc);
+ 		goto out;
+ 	}
+ 
+ 	rc = check_reply_pl((u8 *)rep_pl, __func__);
+ 	if (rc)
+ 		goto out;
+ 	if (rep_pl->data_tag != 0x04 || rep_pl->data_lenfmt != 0x82) {
+ 		DEBUG_ERR("%s unknown reply data format\n", __func__);
+ 		rc = -EIO;
+ 		goto out;
+ 	}
+ 	if (rep_pl->data_len > *keybufsize) {
+ 		DEBUG_ERR("%s mismatch reply data len / key buffer len\n",
+ 			  __func__);
+ 		rc = -ENOSPC;
+ 		goto out;
+ 	}
+ 
+ 	/* copy key blob and set header values */
+ 	memcpy(keybuf, rep_pl->data, rep_pl->data_len);
+ 	*keybufsize = rep_pl->data_len;
+ 	kb = (struct ep11keyblob *) keybuf;
+ 	kb->head.type = TOKTYPE_NON_CCA;
+ 	kb->head.len = rep_pl->data_len;
+ 	kb->head.version = TOKVER_EP11_AES;
+ 	kb->head.keybitlen = keybitsize;
+ 
+ out:
+ 	kfree(req);
+ 	kfree(rep);
+ 	kfree(urb);
+ 	return rc;
+ }
+ EXPORT_SYMBOL(ep11_genaeskey);
+ 
+ static int ep11_cryptsingle(u16 card, u16 domain,
+ 			    u16 mode, u32 mech, const u8 *iv,
+ 			    const u8 *key, size_t keysize,
+ 			    const u8 *inbuf, size_t inbufsize,
+ 			    u8 *outbuf, size_t *outbufsize)
+ {
+ 	struct crypt_req_pl {
+ 		struct pl_head head;
+ 		u8  var_tag;
+ 		u8  var_len;
+ 		u32 var;
+ 		u8  mech_tag;
+ 		u8  mech_len;
+ 		u32 mech;
+ 		/*
+ 		 * maybe followed by iv data
+ 		 * followed by key tag + key blob
+ 		 * followed by plaintext tag + plaintext
+ 		 */
+ 	} __packed * req_pl;
+ 	struct crypt_rep_pl {
+ 		struct pl_head head;
+ 		u8  rc_tag;
+ 		u8  rc_len;
+ 		u32 rc;
+ 		u8  data_tag;
+ 		u8  data_lenfmt;
+ 		/* data follows */
+ 	} __packed * rep_pl;
+ 	struct ep11_cprb *req = NULL, *rep = NULL;
+ 	struct ep11_target_dev target;
+ 	struct ep11_urb *urb = NULL;
+ 	size_t req_pl_size, rep_pl_size;
+ 	int n, api = 1, rc = -ENOMEM;
+ 	u8 *p;
+ 
+ 	/* the simple asn1 coding used has length limits */
+ 	if (keysize > 0xFFFF || inbufsize > 0xFFFF)
+ 		return -EINVAL;
+ 
+ 	/* request cprb and payload */
+ 	req_pl_size = sizeof(struct crypt_req_pl) + (iv ? 16 : 0)
+ 		+ ASN1TAGLEN(keysize) + ASN1TAGLEN(inbufsize);
+ 	req = alloc_cprb(req_pl_size);
+ 	if (!req)
+ 		goto out;
+ 	req_pl = (struct crypt_req_pl *) (((u8 *) req) + sizeof(*req));
+ 	prep_head(&req_pl->head, req_pl_size, api, (mode ? 20 : 19));
+ 	req_pl->var_tag = 0x04;
+ 	req_pl->var_len = sizeof(u32);
+ 	/* mech is mech + mech params (iv here) */
+ 	req_pl->mech_tag = 0x04;
+ 	req_pl->mech_len = sizeof(u32) + (iv ? 16 : 0);
+ 	req_pl->mech = (mech ? mech : 0x00001085); /* CKM_AES_CBC_PAD */
+ 	p = ((u8 *) req_pl) + sizeof(*req_pl);
+ 	if (iv) {
+ 		memcpy(p, iv, 16);
+ 		p += 16;
+ 	}
+ 	/* key and input data */
+ 	p += asn1tag_write(p, 0x04, key, keysize);
+ 	p += asn1tag_write(p, 0x04, inbuf, inbufsize);
+ 
+ 	/* reply cprb and payload, assume out data size <= in data size + 32 */
+ 	rep_pl_size = sizeof(struct crypt_rep_pl) + ASN1TAGLEN(inbufsize + 32);
+ 	rep = alloc_cprb(rep_pl_size);
+ 	if (!rep)
+ 		goto out;
+ 	rep_pl = (struct crypt_rep_pl *) (((u8 *) rep) + sizeof(*rep));
+ 
+ 	/* urb and target */
+ 	urb = kmalloc(sizeof(struct ep11_urb), GFP_KERNEL);
+ 	if (!urb)
+ 		goto out;
+ 	target.ap_id = card;
+ 	target.dom_id = domain;
+ 	prep_urb(urb, &target, 1,
+ 		 req, sizeof(*req) + req_pl_size,
+ 		 rep, sizeof(*rep) + rep_pl_size);
+ 
+ 	rc = _zcrypt_send_ep11_cprb(urb);
+ 	if (rc) {
+ 		DEBUG_ERR(
+ 			"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\n",
+ 			__func__, (int) card, (int) domain, rc);
+ 		goto out;
+ 	}
+ 
+ 	rc = check_reply_pl((u8 *)rep_pl, __func__);
+ 	if (rc)
+ 		goto out;
+ 	if (rep_pl->data_tag != 0x04) {
+ 		DEBUG_ERR("%s unknown reply data format\n", __func__);
+ 		rc = -EIO;
+ 		goto out;
+ 	}
+ 	p = ((u8 *) rep_pl) + sizeof(*rep_pl);
+ 	if (rep_pl->data_lenfmt <= 127)
+ 		n = rep_pl->data_lenfmt;
+ 	else if (rep_pl->data_lenfmt == 0x81)
+ 		n = *p++;
+ 	else if (rep_pl->data_lenfmt == 0x82) {
+ 		n = *((u16 *) p);
+ 		p += 2;
+ 	} else {
+ 		DEBUG_ERR("%s unknown reply data length format 0x%02hhx\n",
+ 			  __func__, rep_pl->data_lenfmt);
+ 		rc = -EIO;
+ 		goto out;
+ 	}
+ 	if (n > *outbufsize) {
+ 		DEBUG_ERR("%s mismatch reply data len %d / output buffer %zu\n",
+ 			  __func__, n, *outbufsize);
+ 		rc = -ENOSPC;
+ 		goto out;
+ 	}
+ 
+ 	memcpy(outbuf, p, n);
+ 	*outbufsize = n;
+ 
+ out:
+ 	kfree(req);
+ 	kfree(rep);
+ 	kfree(urb);
+ 	return rc;
+ }
+ 
+ static int ep11_unwrapkey(u16 card, u16 domain,
+ 			  const u8 *kek, size_t keksize,
+ 			  const u8 *enckey, size_t enckeysize,
+ 			  u32 mech, const u8 *iv,
+ 			  u32 keybitsize, u32 keygenflags,
+ 			  u8 *keybuf, size_t *keybufsize)
+ {
+ 	struct uw_req_pl {
+ 		struct pl_head head;
+ 		u8  attr_tag;
+ 		u8  attr_len;
+ 		u32 attr_header;
+ 		u32 attr_bool_mask;
+ 		u32 attr_bool_bits;
+ 		u32 attr_key_type;
+ 		u32 attr_key_type_value;
+ 		u32 attr_val_len;
+ 		u32 attr_val_len_value;
+ 		u8  mech_tag;
+ 		u8  mech_len;
+ 		u32 mech;
+ 		/*
+ 		 * maybe followed by iv data
+ 		 * followed by kek tag + kek blob
+ 		 * followed by empty mac tag
+ 		 * followed by empty pin tag
+ 		 * followed by encryted key tag + bytes
+ 		 */
+ 	} __packed * req_pl;
+ 	struct uw_rep_pl {
+ 		struct pl_head head;
+ 		u8  rc_tag;
+ 		u8  rc_len;
+ 		u32 rc;
+ 		u8  data_tag;
+ 		u8  data_lenfmt;
+ 		u16 data_len;
+ 		u8  data[512];
+ 	} __packed * rep_pl;
+ 	struct ep11_cprb *req = NULL, *rep = NULL;
+ 	struct ep11_target_dev target;
+ 	struct ep11_urb *urb = NULL;
+ 	struct ep11keyblob *kb;
+ 	size_t req_pl_size;
+ 	int api, rc = -ENOMEM;
+ 	u8 *p;
+ 
+ 	/* request cprb and payload */
+ 	req_pl_size = sizeof(struct uw_req_pl) + (iv ? 16 : 0)
+ 		+ ASN1TAGLEN(keksize) + 4 + ASN1TAGLEN(enckeysize);
+ 	req = alloc_cprb(req_pl_size);
+ 	if (!req)
+ 		goto out;
+ 	req_pl = (struct uw_req_pl *) (((u8 *) req) + sizeof(*req));
+ 	api = (!keygenflags || keygenflags & 0x00200000) ? 4 : 1;
+ 	prep_head(&req_pl->head, req_pl_size, api, 34); /* UnwrapKey */
+ 	req_pl->attr_tag = 0x04;
+ 	req_pl->attr_len = 7 * sizeof(u32);
+ 	req_pl->attr_header = 0x10020000;
+ 	req_pl->attr_bool_mask = keygenflags ? keygenflags : KEY_ATTR_DEFAULTS;
+ 	req_pl->attr_bool_bits = keygenflags ? keygenflags : KEY_ATTR_DEFAULTS;
+ 	req_pl->attr_key_type = 0x00000100; /* CKA_KEY_TYPE */
+ 	req_pl->attr_key_type_value = 0x0000001f; /* CKK_AES */
+ 	req_pl->attr_val_len = 0x00000161; /* CKA_VALUE_LEN */
+ 	req_pl->attr_val_len_value = keybitsize / 8;
+ 	/* mech is mech + mech params (iv here) */
+ 	req_pl->mech_tag = 0x04;
+ 	req_pl->mech_len = sizeof(u32) + (iv ? 16 : 0);
+ 	req_pl->mech = (mech ? mech : 0x00001085); /* CKM_AES_CBC_PAD */
+ 	p = ((u8 *) req_pl) + sizeof(*req_pl);
+ 	if (iv) {
+ 		memcpy(p, iv, 16);
+ 		p += 16;
+ 	}
+ 	/* kek */
+ 	p += asn1tag_write(p, 0x04, kek, keksize);
+ 	/* empty mac key tag */
+ 	*p++ = 0x04;
+ 	*p++ = 0;
+ 	/* empty pin tag */
+ 	*p++ = 0x04;
+ 	*p++ = 0;
+ 	/* encrytped key value tag and bytes */
+ 	p += asn1tag_write(p, 0x04, enckey, enckeysize);
+ 
+ 	/* reply cprb and payload */
+ 	rep = alloc_cprb(sizeof(struct uw_rep_pl));
+ 	if (!rep)
+ 		goto out;
+ 	rep_pl = (struct uw_rep_pl *) (((u8 *) rep) + sizeof(*rep));
+ 
+ 	/* urb and target */
+ 	urb = kmalloc(sizeof(struct ep11_urb), GFP_KERNEL);
+ 	if (!urb)
+ 		goto out;
+ 	target.ap_id = card;
+ 	target.dom_id = domain;
+ 	prep_urb(urb, &target, 1,
+ 		 req, sizeof(*req) + req_pl_size,
+ 		 rep, sizeof(*rep) + sizeof(*rep_pl));
+ 
+ 	rc = _zcrypt_send_ep11_cprb(urb);
+ 	if (rc) {
+ 		DEBUG_ERR(
+ 			"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\n",
+ 			__func__, (int) card, (int) domain, rc);
+ 		goto out;
+ 	}
+ 
+ 	rc = check_reply_pl((u8 *)rep_pl, __func__);
+ 	if (rc)
+ 		goto out;
+ 	if (rep_pl->data_tag != 0x04 || rep_pl->data_lenfmt != 0x82) {
+ 		DEBUG_ERR("%s unknown reply data format\n", __func__);
+ 		rc = -EIO;
+ 		goto out;
+ 	}
+ 	if (rep_pl->data_len > *keybufsize) {
+ 		DEBUG_ERR("%s mismatch reply data len / key buffer len\n",
+ 			  __func__);
+ 		rc = -ENOSPC;
+ 		goto out;
+ 	}
+ 
+ 	/* copy key blob and set header values */
+ 	memcpy(keybuf, rep_pl->data, rep_pl->data_len);
+ 	*keybufsize = rep_pl->data_len;
+ 	kb = (struct ep11keyblob *) keybuf;
+ 	kb->head.type = TOKTYPE_NON_CCA;
+ 	kb->head.len = rep_pl->data_len;
+ 	kb->head.version = TOKVER_EP11_AES;
+ 	kb->head.keybitlen = keybitsize;
+ 
+ out:
+ 	kfree(req);
+ 	kfree(rep);
+ 	kfree(urb);
+ 	return rc;
+ }
+ 
+ static int ep11_wrapkey(u16 card, u16 domain,
+ 			const u8 *key, size_t keysize,
+ 			u32 mech, const u8 *iv,
+ 			u8 *databuf, size_t *datasize)
+ {
+ 	struct wk_req_pl {
+ 		struct pl_head head;
+ 		u8  var_tag;
+ 		u8  var_len;
+ 		u32 var;
+ 		u8  mech_tag;
+ 		u8  mech_len;
+ 		u32 mech;
+ 		/*
+ 		 * followed by iv data
+ 		 * followed by key tag + key blob
+ 		 * followed by dummy kek param
+ 		 * followed by dummy mac param
+ 		 */
+ 	} __packed * req_pl;
+ 	struct wk_rep_pl {
+ 		struct pl_head head;
+ 		u8  rc_tag;
+ 		u8  rc_len;
+ 		u32 rc;
+ 		u8  data_tag;
+ 		u8  data_lenfmt;
+ 		u16 data_len;
+ 		u8  data[512];
+ 	} __packed * rep_pl;
+ 	struct ep11_cprb *req = NULL, *rep = NULL;
+ 	struct ep11_target_dev target;
+ 	struct ep11_urb *urb = NULL;
+ 	struct ep11keyblob *kb;
+ 	size_t req_pl_size;
+ 	int api, rc = -ENOMEM;
+ 	u8 *p;
+ 
+ 	/* request cprb and payload */
+ 	req_pl_size = sizeof(struct wk_req_pl) + (iv ? 16 : 0)
+ 		+ ASN1TAGLEN(keysize) + 4;
+ 	req = alloc_cprb(req_pl_size);
+ 	if (!req)
+ 		goto out;
+ 	if (!mech || mech == 0x80060001)
+ 		req->flags |= 0x20; /* CPACF_WRAP needs special bit */
+ 	req_pl = (struct wk_req_pl *) (((u8 *) req) + sizeof(*req));
+ 	api = (!mech || mech == 0x80060001) ? 4 : 1; /* CKM_IBM_CPACF_WRAP */
+ 	prep_head(&req_pl->head, req_pl_size, api, 33); /* WrapKey */
+ 	req_pl->var_tag = 0x04;
+ 	req_pl->var_len = sizeof(u32);
+ 	/* mech is mech + mech params (iv here) */
+ 	req_pl->mech_tag = 0x04;
+ 	req_pl->mech_len = sizeof(u32) + (iv ? 16 : 0);
+ 	req_pl->mech = (mech ? mech : 0x80060001); /* CKM_IBM_CPACF_WRAP */
+ 	p = ((u8 *) req_pl) + sizeof(*req_pl);
+ 	if (iv) {
+ 		memcpy(p, iv, 16);
+ 		p += 16;
+ 	}
+ 	/* key blob */
+ 	p += asn1tag_write(p, 0x04, key, keysize);
+ 	/* maybe the key argument needs the head data cleaned out */
+ 	kb = (struct ep11keyblob *)(p - keysize);
+ 	if (kb->head.version == TOKVER_EP11_AES)
+ 		memset(&kb->head, 0, sizeof(kb->head));
+ 	/* empty kek tag */
+ 	*p++ = 0x04;
+ 	*p++ = 0;
+ 	/* empty mac tag */
+ 	*p++ = 0x04;
+ 	*p++ = 0;
+ 
+ 	/* reply cprb and payload */
+ 	rep = alloc_cprb(sizeof(struct wk_rep_pl));
+ 	if (!rep)
+ 		goto out;
+ 	rep_pl = (struct wk_rep_pl *) (((u8 *) rep) + sizeof(*rep));
+ 
+ 	/* urb and target */
+ 	urb = kmalloc(sizeof(struct ep11_urb), GFP_KERNEL);
+ 	if (!urb)
+ 		goto out;
+ 	target.ap_id = card;
+ 	target.dom_id = domain;
+ 	prep_urb(urb, &target, 1,
+ 		 req, sizeof(*req) + req_pl_size,
+ 		 rep, sizeof(*rep) + sizeof(*rep_pl));
+ 
+ 	rc = _zcrypt_send_ep11_cprb(urb);
+ 	if (rc) {
+ 		DEBUG_ERR(
+ 			"%s zcrypt_send_ep11_cprb(card=%d dom=%d) failed, rc=%d\n",
+ 			__func__, (int) card, (int) domain, rc);
+ 		goto out;
+ 	}
+ 
+ 	rc = check_reply_pl((u8 *)rep_pl, __func__);
+ 	if (rc)
+ 		goto out;
+ 	if (rep_pl->data_tag != 0x04 || rep_pl->data_lenfmt != 0x82) {
+ 		DEBUG_ERR("%s unknown reply data format\n", __func__);
+ 		rc = -EIO;
+ 		goto out;
+ 	}
+ 	if (rep_pl->data_len > *datasize) {
+ 		DEBUG_ERR("%s mismatch reply data len / data buffer len\n",
+ 			  __func__);
+ 		rc = -ENOSPC;
+ 		goto out;
+ 	}
+ 
+ 	/* copy the data from the cprb to the data buffer */
+ 	memcpy(databuf, rep_pl->data, rep_pl->data_len);
+ 	*datasize = rep_pl->data_len;
+ 
+ out:
+ 	kfree(req);
+ 	kfree(rep);
+ 	kfree(urb);
+ 	return rc;
+ }
+ 
+ int ep11_clr2keyblob(u16 card, u16 domain, u32 keybitsize, u32 keygenflags,
+ 		     const u8 *clrkey, u8 *keybuf, size_t *keybufsize)
+ {
+ 	int rc;
+ 	struct ep11keyblob *kb;
+ 	u8 encbuf[64], *kek = NULL;
+ 	size_t clrkeylen, keklen, encbuflen = sizeof(encbuf);
+ 
+ 	if (keybitsize == 128 || keybitsize == 192 || keybitsize == 256)
+ 		clrkeylen = keybitsize / 8;
+ 	else {
+ 		DEBUG_ERR(
+ 			"%s unknown/unsupported keybitsize %d\n",
+ 			__func__, keybitsize);
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* allocate memory for the temp kek */
+ 	keklen = MAXEP11AESKEYBLOBSIZE;
+ 	kek = kmalloc(keklen, GFP_ATOMIC);
+ 	if (!kek) {
+ 		rc = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	/* Step 1: generate AES 256 bit random kek key */
+ 	rc = ep11_genaeskey(card, domain, 256,
+ 			    0x00006c00, /* EN/DECRYTP, WRAP/UNWRAP */
+ 			    kek, &keklen);
+ 	if (rc) {
+ 		DEBUG_ERR(
+ 			"%s generate kek key failed, rc=%d\n",
+ 			__func__, rc);
+ 		goto out;
+ 	}
+ 	kb = (struct ep11keyblob *) kek;
+ 	memset(&kb->head, 0, sizeof(kb->head));
+ 
+ 	/* Step 2: encrypt clear key value with the kek key */
+ 	rc = ep11_cryptsingle(card, domain, 0, 0, def_iv, kek, keklen,
+ 			      clrkey, clrkeylen, encbuf, &encbuflen);
+ 	if (rc) {
+ 		DEBUG_ERR(
+ 			"%s encrypting key value with kek key failed, rc=%d\n",
+ 			__func__, rc);
+ 		goto out;
+ 	}
+ 
+ 	/* Step 3: import the encrypted key value as a new key */
+ 	rc = ep11_unwrapkey(card, domain, kek, keklen,
+ 			    encbuf, encbuflen, 0, def_iv,
+ 			    keybitsize, 0, keybuf, keybufsize);
+ 	if (rc) {
+ 		DEBUG_ERR(
+ 			"%s importing key value as new key failed,, rc=%d\n",
+ 			__func__, rc);
+ 		goto out;
+ 	}
+ 
+ out:
+ 	kfree(kek);
+ 	return rc;
+ }
+ EXPORT_SYMBOL(ep11_clr2keyblob);
+ 
+ int ep11_key2protkey(u16 card, u16 dom, const u8 *key, size_t keylen,
+ 		     u8 *protkey, u32 *protkeylen, u32 *protkeytype)
+ {
+ 	int rc = -EIO;
+ 	u8 *wkbuf = NULL;
+ 	size_t wkbuflen = 256;
+ 	struct wk_info {
+ 		u16 version;
+ 		u8  res1[16];
+ 		u32 pkeytype;
+ 		u32 pkeybitsize;
+ 		u64 pkeysize;
+ 		u8  res2[8];
+ 		u8  pkey[0];
+ 	} __packed * wki;
+ 
+ 	/* alloc temp working buffer */
+ 	wkbuf = kmalloc(wkbuflen, GFP_ATOMIC);
+ 	if (!wkbuf)
+ 		return -ENOMEM;
+ 
+ 	/* ep11 secure key -> protected key + info */
+ 	rc = ep11_wrapkey(card, dom, key, keylen,
+ 			  0, def_iv, wkbuf, &wkbuflen);
+ 	if (rc) {
+ 		DEBUG_ERR(
+ 			"%s rewrapping ep11 key to pkey failed, rc=%d\n",
+ 			__func__, rc);
+ 		goto out;
+ 	}
+ 	wki = (struct wk_info *) wkbuf;
+ 
+ 	/* check struct version and pkey type */
+ 	if (wki->version != 1 || wki->pkeytype != 1) {
+ 		DEBUG_ERR("%s wk info version %d or pkeytype %d mismatch.\n",
+ 			  __func__, (int) wki->version, (int) wki->pkeytype);
+ 		rc = -EIO;
+ 		goto out;
+ 	}
+ 
+ 	/* copy the tanslated protected key */
+ 	switch (wki->pkeysize) {
+ 	case 16+32:
+ 		/* AES 128 protected key */
+ 		if (protkeytype)
+ 			*protkeytype = PKEY_KEYTYPE_AES_128;
+ 		break;
+ 	case 24+32:
+ 		/* AES 192 protected key */
+ 		if (protkeytype)
+ 			*protkeytype = PKEY_KEYTYPE_AES_192;
+ 		break;
+ 	case 32+32:
+ 		/* AES 256 protected key */
+ 		if (protkeytype)
+ 			*protkeytype = PKEY_KEYTYPE_AES_256;
+ 		break;
+ 	default:
+ 		DEBUG_ERR("%s unknown/unsupported pkeysize %d\n",
+ 			  __func__, (int) wki->pkeysize);
+ 		rc = -EIO;
+ 		goto out;
+ 	}
+ 	memcpy(protkey, wki->pkey, wki->pkeysize);
+ 	if (protkeylen)
+ 		*protkeylen = (u32) wki->pkeysize;
+ 	rc = 0;
+ 
+ out:
+ 	kfree(wkbuf);
+ 	return rc;
+ }
+ EXPORT_SYMBOL(ep11_key2protkey);
+ 
+ int ep11_findcard2(u32 **apqns, u32 *nr_apqns, u16 cardnr, u16 domain,
+ 		   int minhwtype, int minapi, const u8 *wkvp)
+ {
+ 	struct zcrypt_device_status_ext *device_status;
+ 	u32 *_apqns = NULL, _nr_apqns = 0;
+ 	int i, card, dom, rc = -ENOMEM;
+ 	struct ep11_domain_info edi;
+ 	struct ep11_card_info eci;
+ 
+ 	/* fetch status of all crypto cards */
+ 	device_status = kvmalloc_array(MAX_ZDEV_ENTRIES_EXT,
+ 				       sizeof(struct zcrypt_device_status_ext),
+ 				       GFP_KERNEL);
+ 	if (!device_status)
+ 		return -ENOMEM;
+ 	zcrypt_device_status_mask_ext(device_status);
+ 
+ 	/* allocate 1k space for up to 256 apqns */
+ 	_apqns = kmalloc_array(256, sizeof(u32), GFP_KERNEL);
+ 	if (!_apqns) {
+ 		kvfree(device_status);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	/* walk through all the crypto apqnss */
+ 	for (i = 0; i < MAX_ZDEV_ENTRIES_EXT; i++) {
+ 		card = AP_QID_CARD(device_status[i].qid);
+ 		dom = AP_QID_QUEUE(device_status[i].qid);
+ 		/* check online state */
+ 		if (!device_status[i].online)
+ 			continue;
+ 		/* check for ep11 functions */
+ 		if (!(device_status[i].functions & 0x01))
+ 			continue;
+ 		/* check cardnr */
+ 		if (cardnr != 0xFFFF && card != cardnr)
+ 			continue;
+ 		/* check domain */
+ 		if (domain != 0xFFFF && dom != domain)
+ 			continue;
+ 		/* check min hardware type */
+ 		if (minhwtype && device_status[i].hwtype < minhwtype)
+ 			continue;
+ 		/* check min api version if given */
+ 		if (minapi > 0) {
+ 			if (ep11_get_card_info(card, &eci, 0))
+ 				continue;
+ 			if (minapi > eci.API_ord_nr)
+ 				continue;
+ 		}
+ 		/* check wkvp if given */
+ 		if (wkvp) {
+ 			if (ep11_get_domain_info(card, dom, &edi))
+ 				continue;
+ 			if (edi.cur_wk_state != '1')
+ 				continue;
+ 			if (memcmp(wkvp, edi.cur_wkvp, 16))
+ 				continue;
+ 		}
+ 		/* apqn passed all filtering criterons, add to the array */
+ 		if (_nr_apqns < 256)
+ 			_apqns[_nr_apqns++] = (((u16)card) << 16) | ((u16) dom);
+ 	}
+ 
+ 	/* nothing found ? */
+ 	if (!_nr_apqns) {
+ 		kfree(_apqns);
+ 		rc = -ENODEV;
+ 	} else {
+ 		/* no re-allocation, simple return the _apqns array */
+ 		*apqns = _apqns;
+ 		*nr_apqns = _nr_apqns;
+ 		rc = 0;
+ 	}
+ 
+ 	kvfree(device_status);
+ 	return rc;
+ }
+ EXPORT_SYMBOL(ep11_findcard2);
+ 
++>>>>>>> 34515df25d7e (s390/zcrypt: use kvmalloc instead of kmalloc for 256k alloc)
  void __exit zcrypt_ep11misc_exit(void)
  {
  	card_cache_free();
diff --git a/drivers/s390/crypto/zcrypt_ccamisc.c b/drivers/s390/crypto/zcrypt_ccamisc.c
index c1db64a2db21..0984fb14afaa 100644
--- a/drivers/s390/crypto/zcrypt_ccamisc.c
+++ b/drivers/s390/crypto/zcrypt_ccamisc.c
@@ -1568,9 +1568,9 @@ static int findcard(u64 mkvp, u16 *pcardnr, u16 *pdomain,
 		return -EINVAL;
 
 	/* fetch status of all crypto cards */
-	device_status = kmalloc_array(MAX_ZDEV_ENTRIES_EXT,
-				      sizeof(struct zcrypt_device_status_ext),
-				      GFP_KERNEL);
+	device_status = kvmalloc_array(MAX_ZDEV_ENTRIES_EXT,
+				       sizeof(struct zcrypt_device_status_ext),
+				       GFP_KERNEL);
 	if (!device_status)
 		return -ENOMEM;
 	zcrypt_device_status_mask_ext(device_status);
@@ -1640,7 +1640,7 @@ static int findcard(u64 mkvp, u16 *pcardnr, u16 *pdomain,
 	} else
 		rc = -ENODEV;
 
-	kfree(device_status);
+	kvfree(device_status);
 	return rc;
 }
 
* Unmerged path drivers/s390/crypto/zcrypt_ep11misc.c
