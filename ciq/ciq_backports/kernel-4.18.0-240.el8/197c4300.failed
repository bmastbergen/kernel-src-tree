netfilter: conntrack: remove invert_tuple callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 197c4300aec09b7cd2df124cea92f9f5a82efe42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/197c4300.failed

Only used by icmp(v6).  Prefer a direct call and remove this
function from the l4proto struct.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 197c4300aec09b7cd2df124cea92f9f5a82efe42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_conntrack_l4proto.h
#	net/ipv4/netfilter/nf_conntrack_proto_icmp.c
#	net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
diff --cc include/net/netfilter/nf_conntrack_l4proto.h
index 264f50873a3a,6cec8337e684..000000000000
--- a/include/net/netfilter/nf_conntrack_l4proto.h
+++ b/include/net/netfilter/nf_conntrack_l4proto.h
@@@ -30,28 -27,12 +30,31 @@@ struct nf_conntrack_l4proto 
  	/* protoinfo nlattr size, closes a hole */
  	u16 nlattr_size;
  
++<<<<<<< HEAD
 +	/* Try to fill in the third arg: dataoff is offset past network protocol
 +           hdr.  Return true if possible. */
 +	bool (*pkt_to_tuple)(const struct sk_buff *skb, unsigned int dataoff,
 +			     struct net *net, struct nf_conntrack_tuple *tuple);
 +
 +	/* Invert the per-proto part of the tuple: ie. turn xmit into reply.
 +	 * Only used by icmp, most protocols use a generic version.
 +	 */
 +	bool (*invert_tuple)(struct nf_conntrack_tuple *inverse,
 +			     const struct nf_conntrack_tuple *orig);
 +
++=======
++>>>>>>> 197c4300aec0 (netfilter: conntrack: remove invert_tuple callback)
  	/* Returns verdict for packet, or -1 for invalid. */
  	int (*packet)(struct nf_conn *ct,
 -		      struct sk_buff *skb,
 +		      const struct sk_buff *skb,
  		      unsigned int dataoff,
  		      enum ip_conntrack_info ctinfo,
 -		      const struct nf_hook_state *state);
 +		      unsigned int *timeouts);
 +
 +	/* Called when a new connection for this protocol found;
 +	 * returns TRUE if it's OK.  If so, packet() called next. */
 +	bool (*new)(struct nf_conn *ct, const struct sk_buff *skb,
 +		    unsigned int dataoff, unsigned int *timeouts);
  
  	/* Called when a conntrack entry is destroyed */
  	void (*destroy)(struct nf_conn *ct);
@@@ -105,6 -79,67 +108,70 @@@
  	struct module *me;
  };
  
++<<<<<<< HEAD
++=======
+ bool icmp_pkt_to_tuple(const struct sk_buff *skb,
+ 		       unsigned int dataoff,
+ 		       struct net *net,
+ 		       struct nf_conntrack_tuple *tuple);
+ 
+ bool icmpv6_pkt_to_tuple(const struct sk_buff *skb,
+ 			 unsigned int dataoff,
+ 			 struct net *net,
+ 			 struct nf_conntrack_tuple *tuple);
+ 
+ bool nf_conntrack_invert_icmp_tuple(struct nf_conntrack_tuple *tuple,
+ 				    const struct nf_conntrack_tuple *orig);
+ bool nf_conntrack_invert_icmpv6_tuple(struct nf_conntrack_tuple *tuple,
+ 				      const struct nf_conntrack_tuple *orig);
+ 
+ int nf_conntrack_icmpv4_error(struct nf_conn *tmpl,
+ 			      struct sk_buff *skb,
+ 			      unsigned int dataoff,
+ 			      const struct nf_hook_state *state);
+ 
+ int nf_conntrack_icmpv6_error(struct nf_conn *tmpl,
+ 			      struct sk_buff *skb,
+ 			      unsigned int dataoff,
+ 			      const struct nf_hook_state *state);
+ 
+ int nf_conntrack_icmp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state);
+ 
+ int nf_conntrack_icmpv6_packet(struct nf_conn *ct,
+ 			       struct sk_buff *skb,
+ 			       enum ip_conntrack_info ctinfo,
+ 			       const struct nf_hook_state *state);
+ 
+ int nf_conntrack_udp_packet(struct nf_conn *ct,
+ 			    struct sk_buff *skb,
+ 			    unsigned int dataoff,
+ 			    enum ip_conntrack_info ctinfo,
+ 			    const struct nf_hook_state *state);
+ int nf_conntrack_udplite_packet(struct nf_conn *ct,
+ 				struct sk_buff *skb,
+ 				unsigned int dataoff,
+ 				enum ip_conntrack_info ctinfo,
+ 				const struct nf_hook_state *state);
+ int nf_conntrack_tcp_packet(struct nf_conn *ct,
+ 			    struct sk_buff *skb,
+ 			    unsigned int dataoff,
+ 			    enum ip_conntrack_info ctinfo,
+ 			    const struct nf_hook_state *state);
+ int nf_conntrack_dccp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     unsigned int dataoff,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state);
+ int nf_conntrack_sctp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     unsigned int dataoff,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state);
+ 
++>>>>>>> 197c4300aec0 (netfilter: conntrack: remove invert_tuple callback)
  /* Existing built-in generic protocol */
  extern const struct nf_conntrack_l4proto nf_conntrack_l4proto_generic;
  
diff --cc net/ipv4/netfilter/nf_conntrack_proto_icmp.c
index da2ac2d71c9e,d28c1d7633b2..000000000000
--- a/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
+++ b/net/ipv4/netfilter/nf_conntrack_proto_icmp.c
@@@ -348,16 -346,7 +348,19 @@@ static struct nf_proto_net *icmp_get_ne
  
  const struct nf_conntrack_l4proto nf_conntrack_l4proto_icmp =
  {
 +	.l3proto		= PF_INET,
  	.l4proto		= IPPROTO_ICMP,
++<<<<<<< HEAD:net/ipv4/netfilter/nf_conntrack_proto_icmp.c
 +	.pkt_to_tuple		= icmp_pkt_to_tuple,
 +	.invert_tuple		= icmp_invert_tuple,
 +	.packet			= icmp_packet,
 +	.get_timeouts		= icmp_get_timeouts,
 +	.new			= icmp_new,
 +	.error			= icmp_error,
 +	.destroy		= NULL,
 +	.me			= NULL,
++=======
++>>>>>>> 197c4300aec0 (netfilter: conntrack: remove invert_tuple callback):net/netfilter/nf_conntrack_proto_icmp.c
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr	= icmp_tuple_to_nlattr,
  	.nlattr_tuple_size	= icmp_nlattr_tuple_size,
diff --cc net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
index 4b225a43a543,2910dcdea134..000000000000
--- a/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
+++ b/net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
@@@ -353,14 -357,7 +353,17 @@@ static struct nf_proto_net *icmpv6_get_
  
  const struct nf_conntrack_l4proto nf_conntrack_l4proto_icmpv6 =
  {
 +	.l3proto		= PF_INET6,
  	.l4proto		= IPPROTO_ICMPV6,
++<<<<<<< HEAD:net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
 +	.pkt_to_tuple		= icmpv6_pkt_to_tuple,
 +	.invert_tuple		= icmpv6_invert_tuple,
 +	.packet			= icmpv6_packet,
 +	.get_timeouts		= icmpv6_get_timeouts,
 +	.new			= icmpv6_new,
 +	.error			= icmpv6_error,
++=======
++>>>>>>> 197c4300aec0 (netfilter: conntrack: remove invert_tuple callback):net/netfilter/nf_conntrack_proto_icmpv6.c
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr	= icmpv6_tuple_to_nlattr,
  	.nlattr_tuple_size	= icmpv6_nlattr_tuple_size,
* Unmerged path include/net/netfilter/nf_conntrack_l4proto.h
* Unmerged path net/ipv4/netfilter/nf_conntrack_proto_icmp.c
* Unmerged path net/ipv6/netfilter/nf_conntrack_proto_icmpv6.c
diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c
index 680e0b0d92a5..6d8a21bcf32a 100644
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@ -343,8 +343,12 @@ nf_ct_invert_tuple(struct nf_conntrack_tuple *inverse,
 
 	inverse->dst.protonum = orig->dst.protonum;
 
-	if (unlikely(l4proto->invert_tuple))
-		return l4proto->invert_tuple(inverse, orig);
+	switch (orig->dst.protonum) {
+	case IPPROTO_ICMP:
+		return nf_conntrack_invert_icmp_tuple(inverse, orig);
+	case IPPROTO_ICMPV6:
+		return nf_conntrack_invert_icmpv6_tuple(inverse, orig);
+	}
 
 	inverse->src.u.all = orig->dst.u.all;
 	inverse->dst.u.all = orig->src.u.all;
