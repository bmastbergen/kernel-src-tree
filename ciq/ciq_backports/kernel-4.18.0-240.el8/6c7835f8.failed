mm: nobootmem: remove bootmem allocation APIs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mike Rapoport <rppt@linux.vnet.ibm.com>
commit 6c7835f8d0d1839ca93bd3cf6faa15706f03d604
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6c7835f8.failed

The bootmem compatibility APIs are not used and can be removed.

Link: http://lkml.kernel.org/r/1536927045-23536-23-git-send-email-rppt@linux.vnet.ibm.com
	Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Chris Zankel <chris@zankel.net>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Geert Uytterhoeven <geert@linux-m68k.org>
	Cc: Greentime Hu <green.hu@gmail.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Guan Xuetao <gxt@pku.edu.cn>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
	Cc: Jonas Bonn <jonas@southpole.se>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Ley Foon Tan <lftan@altera.com>
	Cc: Mark Salter <msalter@redhat.com>
	Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Cc: Matt Turner <mattst88@gmail.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Michal Simek <monstr@monstr.eu>
	Cc: Palmer Dabbelt <palmer@sifive.com>
	Cc: Paul Burton <paul.burton@mips.com>
	Cc: Richard Kuo <rkuo@codeaurora.org>
	Cc: Richard Weinberger <richard@nod.at>
	Cc: Rich Felker <dalias@libc.org>
	Cc: Russell King <linux@armlinux.org.uk>
	Cc: Serge Semin <fancer.lancer@gmail.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Vineet Gupta <vgupta@synopsys.com>
	Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 6c7835f8d0d1839ca93bd3cf6faa15706f03d604)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bootmem.h
#	mm/nobootmem.c
diff --cc include/linux/bootmem.h
index 42515195d7d8,73f1272fce20..000000000000
--- a/include/linux/bootmem.h
+++ b/include/linux/bootmem.h
@@@ -72,101 -36,13 +72,107 @@@ extern void free_bootmem_node(pg_data_
  extern void free_bootmem(unsigned long physaddr, unsigned long size);
  extern void free_bootmem_late(unsigned long physaddr, unsigned long size);
  
++<<<<<<< HEAD
 +/*
 + * Flags for reserve_bootmem (also if CONFIG_HAVE_ARCH_BOOTMEM_NODE,
 + * the architecture-specific code should honor this).
 + *
 + * If flags is BOOTMEM_DEFAULT, then the return value is always 0 (success).
 + * If flags contains BOOTMEM_EXCLUSIVE, then -EBUSY is returned if the memory
 + * already was reserved.
 + */
 +#define BOOTMEM_DEFAULT		0
 +#define BOOTMEM_EXCLUSIVE	(1<<0)
 +
 +extern int reserve_bootmem(unsigned long addr,
 +			   unsigned long size,
 +			   int flags);
 +extern int reserve_bootmem_node(pg_data_t *pgdat,
 +				unsigned long physaddr,
 +				unsigned long size,
 +				int flags);
 +
 +extern void *__alloc_bootmem(unsigned long size,
 +			     unsigned long align,
 +			     unsigned long goal);
 +extern void *__alloc_bootmem_nopanic(unsigned long size,
 +				     unsigned long align,
 +				     unsigned long goal) __malloc;
 +extern void *__alloc_bootmem_node(pg_data_t *pgdat,
 +				  unsigned long size,
 +				  unsigned long align,
 +				  unsigned long goal) __malloc;
 +void *__alloc_bootmem_node_high(pg_data_t *pgdat,
 +				  unsigned long size,
 +				  unsigned long align,
 +				  unsigned long goal) __malloc;
 +extern void *__alloc_bootmem_node_nopanic(pg_data_t *pgdat,
 +				  unsigned long size,
 +				  unsigned long align,
 +				  unsigned long goal) __malloc;
 +void *___alloc_bootmem_node_nopanic(pg_data_t *pgdat,
 +				  unsigned long size,
 +				  unsigned long align,
 +				  unsigned long goal,
 +				  unsigned long limit) __malloc;
 +extern void *__alloc_bootmem_low(unsigned long size,
 +				 unsigned long align,
 +				 unsigned long goal) __malloc;
 +void *__alloc_bootmem_low_nopanic(unsigned long size,
 +				 unsigned long align,
 +				 unsigned long goal) __malloc;
 +extern void *__alloc_bootmem_low_node(pg_data_t *pgdat,
 +				      unsigned long size,
 +				      unsigned long align,
 +				      unsigned long goal) __malloc;
 +
 +#ifdef CONFIG_NO_BOOTMEM
++=======
++>>>>>>> 6c7835f8d0d1 (mm: nobootmem: remove bootmem allocation APIs)
  /* We are using top down, so it is safe to use 0 here */
  #define BOOTMEM_LOW_LIMIT 0
 +#else
 +#define BOOTMEM_LOW_LIMIT __pa(MAX_DMA_ADDRESS)
 +#endif
  
  #ifndef ARCH_LOW_ADDRESS_LIMIT
  #define ARCH_LOW_ADDRESS_LIMIT  0xffffffffUL
  #endif
  
++<<<<<<< HEAD
 +#define alloc_bootmem(x) \
 +	__alloc_bootmem(x, SMP_CACHE_BYTES, BOOTMEM_LOW_LIMIT)
 +#define alloc_bootmem_align(x, align) \
 +	__alloc_bootmem(x, align, BOOTMEM_LOW_LIMIT)
 +#define alloc_bootmem_nopanic(x) \
 +	__alloc_bootmem_nopanic(x, SMP_CACHE_BYTES, BOOTMEM_LOW_LIMIT)
 +#define alloc_bootmem_pages(x) \
 +	__alloc_bootmem(x, PAGE_SIZE, BOOTMEM_LOW_LIMIT)
 +#define alloc_bootmem_pages_nopanic(x) \
 +	__alloc_bootmem_nopanic(x, PAGE_SIZE, BOOTMEM_LOW_LIMIT)
 +#define alloc_bootmem_node(pgdat, x) \
 +	__alloc_bootmem_node(pgdat, x, SMP_CACHE_BYTES, BOOTMEM_LOW_LIMIT)
 +#define alloc_bootmem_node_nopanic(pgdat, x) \
 +	__alloc_bootmem_node_nopanic(pgdat, x, SMP_CACHE_BYTES, BOOTMEM_LOW_LIMIT)
 +#define alloc_bootmem_pages_node(pgdat, x) \
 +	__alloc_bootmem_node(pgdat, x, PAGE_SIZE, BOOTMEM_LOW_LIMIT)
 +#define alloc_bootmem_pages_node_nopanic(pgdat, x) \
 +	__alloc_bootmem_node_nopanic(pgdat, x, PAGE_SIZE, BOOTMEM_LOW_LIMIT)
 +
 +#define alloc_bootmem_low(x) \
 +	__alloc_bootmem_low(x, SMP_CACHE_BYTES, 0)
 +#define alloc_bootmem_low_pages_nopanic(x) \
 +	__alloc_bootmem_low_nopanic(x, PAGE_SIZE, 0)
 +#define alloc_bootmem_low_pages(x) \
 +	__alloc_bootmem_low(x, PAGE_SIZE, 0)
 +#define alloc_bootmem_low_pages_node(pgdat, x) \
 +	__alloc_bootmem_low_node(pgdat, x, PAGE_SIZE, 0)
 +
 +
 +#if defined(CONFIG_HAVE_MEMBLOCK) && defined(CONFIG_NO_BOOTMEM)
 +
++=======
++>>>>>>> 6c7835f8d0d1 (mm: nobootmem: remove bootmem allocation APIs)
  /* FIXME: use MEMBLOCK_ALLOC_* variants here */
  #define BOOTMEM_ALLOC_ACCESSIBLE	0
  #define BOOTMEM_ALLOC_ANYWHERE		(~(phys_addr_t)0)
diff --cc mm/nobootmem.c
index 439af3b765a7,bc38e5673d31..000000000000
--- a/mm/nobootmem.c
+++ b/mm/nobootmem.c
@@@ -219,227 -180,3 +184,230 @@@ void __init free_bootmem(unsigned long 
  {
  	memblock_free(addr, size);
  }
++<<<<<<< HEAD
 +
 +static void * __init ___alloc_bootmem_nopanic(unsigned long size,
 +					unsigned long align,
 +					unsigned long goal,
 +					unsigned long limit)
 +{
 +	void *ptr;
 +
 +	if (WARN_ON_ONCE(slab_is_available()))
 +		return kzalloc(size, GFP_NOWAIT);
 +
 +restart:
 +
 +	ptr = __alloc_memory_core_early(NUMA_NO_NODE, size, align, goal, limit);
 +
 +	if (ptr)
 +		return ptr;
 +
 +	if (goal != 0) {
 +		goal = 0;
 +		goto restart;
 +	}
 +
 +	return NULL;
 +}
 +
 +/**
 + * __alloc_bootmem_nopanic - allocate boot memory without panicking
 + * @size: size of the request in bytes
 + * @align: alignment of the region
 + * @goal: preferred starting address of the region
 + *
 + * The goal is dropped if it can not be satisfied and the allocation will
 + * fall back to memory below @goal.
 + *
 + * Allocation may happen on any node in the system.
 + *
 + * Return: address of the allocated region or %NULL on failure.
 + */
 +void * __init __alloc_bootmem_nopanic(unsigned long size, unsigned long align,
 +					unsigned long goal)
 +{
 +	unsigned long limit = -1UL;
 +
 +	return ___alloc_bootmem_nopanic(size, align, goal, limit);
 +}
 +
 +static void * __init ___alloc_bootmem(unsigned long size, unsigned long align,
 +					unsigned long goal, unsigned long limit)
 +{
 +	void *mem = ___alloc_bootmem_nopanic(size, align, goal, limit);
 +
 +	if (mem)
 +		return mem;
 +	/*
 +	 * Whoops, we cannot satisfy the allocation request.
 +	 */
 +	pr_alert("bootmem alloc of %lu bytes failed!\n", size);
 +	panic("Out of memory");
 +	return NULL;
 +}
 +
 +/**
 + * __alloc_bootmem - allocate boot memory
 + * @size: size of the request in bytes
 + * @align: alignment of the region
 + * @goal: preferred starting address of the region
 + *
 + * The goal is dropped if it can not be satisfied and the allocation will
 + * fall back to memory below @goal.
 + *
 + * Allocation may happen on any node in the system.
 + *
 + * The function panics if the request can not be satisfied.
 + *
 + * Return: address of the allocated region.
 + */
 +void * __init __alloc_bootmem(unsigned long size, unsigned long align,
 +			      unsigned long goal)
 +{
 +	unsigned long limit = -1UL;
 +
 +	return ___alloc_bootmem(size, align, goal, limit);
 +}
 +
 +void * __init ___alloc_bootmem_node_nopanic(pg_data_t *pgdat,
 +						   unsigned long size,
 +						   unsigned long align,
 +						   unsigned long goal,
 +						   unsigned long limit)
 +{
 +	void *ptr;
 +
 +again:
 +	ptr = __alloc_memory_core_early(pgdat->node_id, size, align,
 +					goal, limit);
 +	if (ptr)
 +		return ptr;
 +
 +	ptr = __alloc_memory_core_early(NUMA_NO_NODE, size, align,
 +					goal, limit);
 +	if (ptr)
 +		return ptr;
 +
 +	if (goal) {
 +		goal = 0;
 +		goto again;
 +	}
 +
 +	return NULL;
 +}
 +
 +void * __init __alloc_bootmem_node_nopanic(pg_data_t *pgdat, unsigned long size,
 +				   unsigned long align, unsigned long goal)
 +{
 +	if (WARN_ON_ONCE(slab_is_available()))
 +		return kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);
 +
 +	return ___alloc_bootmem_node_nopanic(pgdat, size, align, goal, 0);
 +}
 +
 +static void * __init ___alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,
 +				    unsigned long align, unsigned long goal,
 +				    unsigned long limit)
 +{
 +	void *ptr;
 +
 +	ptr = ___alloc_bootmem_node_nopanic(pgdat, size, align, goal, limit);
 +	if (ptr)
 +		return ptr;
 +
 +	pr_alert("bootmem alloc of %lu bytes failed!\n", size);
 +	panic("Out of memory");
 +	return NULL;
 +}
 +
 +/**
 + * __alloc_bootmem_node - allocate boot memory from a specific node
 + * @pgdat: node to allocate from
 + * @size: size of the request in bytes
 + * @align: alignment of the region
 + * @goal: preferred starting address of the region
 + *
 + * The goal is dropped if it can not be satisfied and the allocation will
 + * fall back to memory below @goal.
 + *
 + * Allocation may fall back to any node in the system if the specified node
 + * can not hold the requested memory.
 + *
 + * The function panics if the request can not be satisfied.
 + *
 + * Return: address of the allocated region.
 + */
 +void * __init __alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,
 +				   unsigned long align, unsigned long goal)
 +{
 +	if (WARN_ON_ONCE(slab_is_available()))
 +		return kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);
 +
 +	return ___alloc_bootmem_node(pgdat, size, align, goal, 0);
 +}
 +
 +void * __init __alloc_bootmem_node_high(pg_data_t *pgdat, unsigned long size,
 +				   unsigned long align, unsigned long goal)
 +{
 +	return __alloc_bootmem_node(pgdat, size, align, goal);
 +}
 +
 +
 +/**
 + * __alloc_bootmem_low - allocate low boot memory
 + * @size: size of the request in bytes
 + * @align: alignment of the region
 + * @goal: preferred starting address of the region
 + *
 + * The goal is dropped if it can not be satisfied and the allocation will
 + * fall back to memory below @goal.
 + *
 + * Allocation may happen on any node in the system.
 + *
 + * The function panics if the request can not be satisfied.
 + *
 + * Return: address of the allocated region.
 + */
 +void * __init __alloc_bootmem_low(unsigned long size, unsigned long align,
 +				  unsigned long goal)
 +{
 +	return ___alloc_bootmem(size, align, goal, ARCH_LOW_ADDRESS_LIMIT);
 +}
 +
 +void * __init __alloc_bootmem_low_nopanic(unsigned long size,
 +					  unsigned long align,
 +					  unsigned long goal)
 +{
 +	return ___alloc_bootmem_nopanic(size, align, goal,
 +					ARCH_LOW_ADDRESS_LIMIT);
 +}
 +
 +/**
 + * __alloc_bootmem_low_node - allocate low boot memory from a specific node
 + * @pgdat: node to allocate from
 + * @size: size of the request in bytes
 + * @align: alignment of the region
 + * @goal: preferred starting address of the region
 + *
 + * The goal is dropped if it can not be satisfied and the allocation will
 + * fall back to memory below @goal.
 + *
 + * Allocation may fall back to any node in the system if the specified node
 + * can not hold the requested memory.
 + *
 + * The function panics if the request can not be satisfied.
 + *
 + * Return: address of the allocated region.
 + */
 +void * __init __alloc_bootmem_low_node(pg_data_t *pgdat, unsigned long size,
 +				       unsigned long align, unsigned long goal)
 +{
 +	if (WARN_ON_ONCE(slab_is_available()))
 +		return kzalloc_node(size, GFP_NOWAIT, pgdat->node_id);
 +
 +	return ___alloc_bootmem_node(pgdat, size, align, goal,
 +				     ARCH_LOW_ADDRESS_LIMIT);
 +}
++=======
++>>>>>>> 6c7835f8d0d1 (mm: nobootmem: remove bootmem allocation APIs)
* Unmerged path include/linux/bootmem.h
* Unmerged path mm/nobootmem.c
