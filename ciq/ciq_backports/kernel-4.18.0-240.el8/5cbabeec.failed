netfilter: nat: remove nf_nat_l4proto struct

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 5cbabeec1eb758233b35683123de446a57852932
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5cbabeec.failed

This removes the (now empty) nf_nat_l4proto struct, all its instances
and all the no longer needed runtime (un)register functionality.

nf_nat_need_gre() can be axed as well: the module that calls it (to
load the no-longer-existing nat_gre module) also calls other nat core
functions. GRE nat is now always available if kernel is built with it.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 5cbabeec1eb758233b35683123de446a57852932)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_nat_l4proto.h
#	net/ipv4/netfilter/Makefile
#	net/ipv4/netfilter/nf_nat_proto_gre.c
#	net/ipv4/netfilter/nf_nat_proto_icmp.c
#	net/ipv6/netfilter/Makefile
#	net/ipv6/netfilter/nf_nat_proto_icmpv6.c
#	net/netfilter/Makefile
#	net/netfilter/nf_nat_core.c
#	net/netfilter/nf_nat_proto.c
#	net/netfilter/nf_nat_proto_dccp.c
#	net/netfilter/nf_nat_proto_sctp.c
#	net/netfilter/nf_nat_proto_tcp.c
#	net/netfilter/nf_nat_proto_unknown.c
diff --cc include/net/netfilter/nf_nat_l4proto.h
index 7ecac2cd1020,95a4655bd1ad..000000000000
--- a/include/net/netfilter/nf_nat_l4proto.h
+++ b/include/net/netfilter/nf_nat_l4proto.h
@@@ -5,78 -5,12 +5,86 @@@
  #include <net/netfilter/nf_nat.h>
  #include <linux/netfilter/nfnetlink_conntrack.h>
  
- struct nf_nat_range;
  struct nf_nat_l3proto;
  
++<<<<<<< HEAD
 +struct nf_nat_l4proto {
 +	/* Protocol number. */
 +	u8 l4proto;
 +
 +	/* Translate a packet to the target according to manip type.
 +	 * Return true if succeeded.
 +	 */
 +	bool (*manip_pkt)(struct sk_buff *skb,
 +			  const struct nf_nat_l3proto *l3proto,
 +			  unsigned int iphdroff, unsigned int hdroff,
 +			  const struct nf_conntrack_tuple *tuple,
 +			  enum nf_nat_manip_type maniptype);
 +
 +	/* Is the manipable part of the tuple between min and max incl? */
 +	bool (*in_range)(const struct nf_conntrack_tuple *tuple,
 +			 enum nf_nat_manip_type maniptype,
 +			 const union nf_conntrack_man_proto *min,
 +			 const union nf_conntrack_man_proto *max);
 +
 +	/* Alter the per-proto part of the tuple (depending on
 +	 * maniptype), to give a unique tuple in the given range if
 +	 * possible.  Per-protocol part of tuple is initialized to the
 +	 * incoming packet.
 +	 */
 +	void (*unique_tuple)(const struct nf_nat_l3proto *l3proto,
 +			     struct nf_conntrack_tuple *tuple,
 +			     const struct nf_nat_range2 *range,
 +			     enum nf_nat_manip_type maniptype,
 +			     const struct nf_conn *ct);
 +
 +	int (*nlattr_to_range)(struct nlattr *tb[],
 +			       struct nf_nat_range2 *range);
 +};
 +
 +/* Protocol registration. */
 +int nf_nat_l4proto_register(u8 l3proto, const struct nf_nat_l4proto *l4proto);
 +void nf_nat_l4proto_unregister(u8 l3proto,
 +			       const struct nf_nat_l4proto *l4proto);
 +
 +const struct nf_nat_l4proto *__nf_nat_l4proto_find(u8 l3proto, u8 l4proto);
 +
 +/* Built-in protocols. */
 +extern const struct nf_nat_l4proto nf_nat_l4proto_tcp;
 +extern const struct nf_nat_l4proto nf_nat_l4proto_udp;
 +extern const struct nf_nat_l4proto nf_nat_l4proto_icmp;
 +extern const struct nf_nat_l4proto nf_nat_l4proto_icmpv6;
 +extern const struct nf_nat_l4proto nf_nat_l4proto_unknown;
 +#ifdef CONFIG_NF_NAT_PROTO_DCCP
 +extern const struct nf_nat_l4proto nf_nat_l4proto_dccp;
 +#endif
 +#ifdef CONFIG_NF_NAT_PROTO_SCTP
 +extern const struct nf_nat_l4proto nf_nat_l4proto_sctp;
 +#endif
 +#ifdef CONFIG_NF_NAT_PROTO_UDPLITE
 +extern const struct nf_nat_l4proto nf_nat_l4proto_udplite;
 +#endif
 +
 +bool nf_nat_l4proto_in_range(const struct nf_conntrack_tuple *tuple,
 +			     enum nf_nat_manip_type maniptype,
 +			     const union nf_conntrack_man_proto *min,
 +			     const union nf_conntrack_man_proto *max);
 +
 +void nf_nat_l4proto_unique_tuple(const struct nf_nat_l3proto *l3proto,
 +				 struct nf_conntrack_tuple *tuple,
 +				 const struct nf_nat_range2 *range,
 +				 enum nf_nat_manip_type maniptype,
 +				 const struct nf_conn *ct);
 +
 +int nf_nat_l4proto_nlattr_to_range(struct nlattr *tb[],
 +				   struct nf_nat_range2 *range);
 +
++=======
+ /* Translate a packet to the target according to manip type.  Return on success. */
+ bool nf_nat_l4proto_manip_pkt(struct sk_buff *skb,
+ 			      const struct nf_nat_l3proto *l3proto,
+ 			      unsigned int iphdroff, unsigned int hdroff,
+ 			      const struct nf_conntrack_tuple *tuple,
+ 			      enum nf_nat_manip_type maniptype);
++>>>>>>> 5cbabeec1eb7 (netfilter: nat: remove nf_nat_l4proto struct)
  #endif /*_NF_NAT_L4PROTO_H*/
diff --cc net/ipv4/netfilter/Makefile
index 8394c17c269f,fd7122e0e2c9..000000000000
--- a/net/ipv4/netfilter/Makefile
+++ b/net/ipv4/netfilter/Makefile
@@@ -3,13 -3,7 +3,17 @@@
  # Makefile for the netfilter modules on top of IPv4.
  #
  
++<<<<<<< HEAD
 +# objects for l3 independent conntrack
 +nf_conntrack_ipv4-y	:=  nf_conntrack_l3proto_ipv4.o nf_conntrack_proto_icmp.o
 +
 +# connection tracking
 +obj-$(CONFIG_NF_CONNTRACK_IPV4) += nf_conntrack_ipv4.o
 +
 +nf_nat_ipv4-y		:= nf_nat_l3proto_ipv4.o nf_nat_proto_icmp.o
++=======
+ nf_nat_ipv4-y		:= nf_nat_l3proto_ipv4.o
++>>>>>>> 5cbabeec1eb7 (netfilter: nat: remove nf_nat_l4proto struct)
  nf_nat_ipv4-$(CONFIG_NF_NAT_MASQUERADE_IPV4) += nf_nat_masquerade_ipv4.o
  obj-$(CONFIG_NF_NAT_IPV4) += nf_nat_ipv4.o
  
diff --cc net/ipv6/netfilter/Makefile
index 10a5a1c87320,9ea43d5256e0..000000000000
--- a/net/ipv6/netfilter/Makefile
+++ b/net/ipv6/netfilter/Makefile
@@@ -11,13 -11,7 +11,17 @@@ obj-$(CONFIG_IP6_NF_RAW) += ip6table_ra
  obj-$(CONFIG_IP6_NF_SECURITY) += ip6table_security.o
  obj-$(CONFIG_IP6_NF_NAT) += ip6table_nat.o
  
++<<<<<<< HEAD
 +# objects for l3 independent conntrack
 +nf_conntrack_ipv6-y  :=  nf_conntrack_l3proto_ipv6.o nf_conntrack_proto_icmpv6.o
 +
 +# l3 independent conntrack
 +obj-$(CONFIG_NF_CONNTRACK_IPV6) += nf_conntrack_ipv6.o
 +
 +nf_nat_ipv6-y		:= nf_nat_l3proto_ipv6.o nf_nat_proto_icmpv6.o
++=======
+ nf_nat_ipv6-y		:= nf_nat_l3proto_ipv6.o
++>>>>>>> 5cbabeec1eb7 (netfilter: nat: remove nf_nat_l4proto struct)
  nf_nat_ipv6-$(CONFIG_NF_NAT_MASQUERADE_IPV6) += nf_nat_masquerade_ipv6.o
  obj-$(CONFIG_NF_NAT_IPV6) += nf_nat_ipv6.o
  
diff --cc net/netfilter/Makefile
index c1b6a98afe92,1ae65a314d7a..000000000000
--- a/net/netfilter/Makefile
+++ b/net/netfilter/Makefile
@@@ -41,12 -47,7 +41,16 @@@ obj-$(CONFIG_NF_CONNTRACK_SANE) += nf_c
  obj-$(CONFIG_NF_CONNTRACK_SIP) += nf_conntrack_sip.o
  obj-$(CONFIG_NF_CONNTRACK_TFTP) += nf_conntrack_tftp.o
  
++<<<<<<< HEAD
 +nf_nat-y	:= nf_nat_core.o nf_nat_proto_unknown.o nf_nat_proto_common.o \
 +		   nf_nat_proto_udp.o nf_nat_proto_tcp.o nf_nat_helper.o
 +
 +# NAT protocols (nf_nat)
 +nf_nat-$(CONFIG_NF_NAT_PROTO_DCCP) += nf_nat_proto_dccp.o
 +nf_nat-$(CONFIG_NF_NAT_PROTO_SCTP) += nf_nat_proto_sctp.o
++=======
+ nf_nat-y	:= nf_nat_core.o nf_nat_proto.o nf_nat_helper.o
++>>>>>>> 5cbabeec1eb7 (netfilter: nat: remove nf_nat_l4proto struct)
  
  # generic transport layer logging
  obj-$(CONFIG_NF_LOG_COMMON) += nf_log_common.o
diff --cc net/netfilter/nf_nat_core.c
index 5e173f6800a4,9935b66427e6..000000000000
--- a/net/netfilter/nf_nat_core.c
+++ b/net/netfilter/nf_nat_core.c
@@@ -687,88 -807,8 +664,36 @@@ static void nf_nat_l3proto_clean(u8 l3p
  	nf_ct_iterate_destroy(nf_nat_proto_remove, &clean);
  }
  
- /* Protocol registration. */
- int nf_nat_l4proto_register(u8 l3proto, const struct nf_nat_l4proto *l4proto)
- {
- 	const struct nf_nat_l4proto **l4protos;
- 	unsigned int i;
- 	int ret = 0;
- 
- 	mutex_lock(&nf_nat_proto_mutex);
- 	if (nf_nat_l4protos[l3proto] == NULL) {
- 		l4protos = kmalloc_array(IPPROTO_MAX,
- 					 sizeof(struct nf_nat_l4proto *),
- 					 GFP_KERNEL);
- 		if (l4protos == NULL) {
- 			ret = -ENOMEM;
- 			goto out;
- 		}
- 
- 		for (i = 0; i < IPPROTO_MAX; i++)
- 			RCU_INIT_POINTER(l4protos[i], &nf_nat_l4proto_unknown);
- 
- 		/* Before making proto_array visible to lockless readers,
- 		 * we must make sure its content is committed to memory.
- 		 */
- 		smp_wmb();
- 
- 		nf_nat_l4protos[l3proto] = l4protos;
- 	}
- 
- 	if (rcu_dereference_protected(
- 			nf_nat_l4protos[l3proto][l4proto->l4proto],
- 			lockdep_is_held(&nf_nat_proto_mutex)
- 			) != &nf_nat_l4proto_unknown) {
- 		ret = -EBUSY;
- 		goto out;
- 	}
- 	RCU_INIT_POINTER(nf_nat_l4protos[l3proto][l4proto->l4proto], l4proto);
-  out:
- 	mutex_unlock(&nf_nat_proto_mutex);
- 	return ret;
- }
- EXPORT_SYMBOL_GPL(nf_nat_l4proto_register);
- 
- /* No one stores the protocol anywhere; simply delete it. */
- void nf_nat_l4proto_unregister(u8 l3proto, const struct nf_nat_l4proto *l4proto)
- {
- 	mutex_lock(&nf_nat_proto_mutex);
- 	RCU_INIT_POINTER(nf_nat_l4protos[l3proto][l4proto->l4proto],
- 			 &nf_nat_l4proto_unknown);
- 	mutex_unlock(&nf_nat_proto_mutex);
- 	synchronize_rcu();
- 
- 	nf_nat_l4proto_clean(l3proto, l4proto->l4proto);
- }
- EXPORT_SYMBOL_GPL(nf_nat_l4proto_unregister);
- 
  int nf_nat_l3proto_register(const struct nf_nat_l3proto *l3proto)
  {
++<<<<<<< HEAD
 +	int err;
 +
 +	err = nf_ct_l3proto_try_module_get(l3proto->l3proto);
 +	if (err < 0)
 +		return err;
 +
 +	mutex_lock(&nf_nat_proto_mutex);
 +	RCU_INIT_POINTER(nf_nat_l4protos[l3proto->l3proto][IPPROTO_TCP],
 +			 &nf_nat_l4proto_tcp);
 +	RCU_INIT_POINTER(nf_nat_l4protos[l3proto->l3proto][IPPROTO_UDP],
 +			 &nf_nat_l4proto_udp);
 +#ifdef CONFIG_NF_NAT_PROTO_DCCP
 +	RCU_INIT_POINTER(nf_nat_l4protos[l3proto->l3proto][IPPROTO_DCCP],
 +			 &nf_nat_l4proto_dccp);
 +#endif
 +#ifdef CONFIG_NF_NAT_PROTO_SCTP
 +	RCU_INIT_POINTER(nf_nat_l4protos[l3proto->l3proto][IPPROTO_SCTP],
 +			 &nf_nat_l4proto_sctp);
 +#endif
 +#ifdef CONFIG_NF_NAT_PROTO_UDPLITE
 +	RCU_INIT_POINTER(nf_nat_l4protos[l3proto->l3proto][IPPROTO_UDPLITE],
 +			 &nf_nat_l4proto_udplite);
 +#endif
 +	mutex_unlock(&nf_nat_proto_mutex);
 +
++=======
++>>>>>>> 5cbabeec1eb7 (netfilter: nat: remove nf_nat_l4proto struct)
  	RCU_INIT_POINTER(nf_nat_l3protos[l3proto->l3proto], l3proto);
  	return 0;
  }
@@@ -1099,12 -1146,8 +1023,8 @@@ static void __exit nf_nat_cleanup(void
  	nf_ct_helper_expectfn_unregister(&follow_master_nat);
  	RCU_INIT_POINTER(nf_nat_hook, NULL);
  
- 	synchronize_rcu();
- 
- 	for (i = 0; i < NFPROTO_NUMPROTO; i++)
- 		kfree(nf_nat_l4protos[i]);
  	synchronize_net();
 -	kvfree(nf_nat_bysource);
 +	nf_ct_free_hashtable(nf_nat_bysource, nf_nat_htable_size);
  	unregister_pernet_subsys(&nat_net_ops);
  }
  
* Unmerged path net/ipv4/netfilter/nf_nat_proto_gre.c
* Unmerged path net/ipv4/netfilter/nf_nat_proto_icmp.c
* Unmerged path net/ipv6/netfilter/nf_nat_proto_icmpv6.c
* Unmerged path net/netfilter/nf_nat_proto.c
* Unmerged path net/netfilter/nf_nat_proto_dccp.c
* Unmerged path net/netfilter/nf_nat_proto_sctp.c
* Unmerged path net/netfilter/nf_nat_proto_tcp.c
* Unmerged path net/netfilter/nf_nat_proto_unknown.c
diff --git a/include/linux/netfilter/nf_conntrack_proto_gre.h b/include/linux/netfilter/nf_conntrack_proto_gre.h
index b8d95564bd53..f76efa5f2996 100644
--- a/include/linux/netfilter/nf_conntrack_proto_gre.h
+++ b/include/linux/netfilter/nf_conntrack_proto_gre.h
@@ -28,7 +28,5 @@ int nf_ct_gre_keymap_add(struct nf_conn *ct, enum ip_conntrack_dir dir,
 /* delete keymap entries */
 void nf_ct_gre_keymap_destroy(struct nf_conn *ct);
 
-void nf_nat_need_gre(void);
-
 #endif /* __KERNEL__ */
 #endif /* _CONNTRACK_PROTO_GRE_H */
diff --git a/include/net/netfilter/nf_nat_l3proto.h b/include/net/netfilter/nf_nat_l3proto.h
index d300b8f03972..f68c24856481 100644
--- a/include/net/netfilter/nf_nat_l3proto.h
+++ b/include/net/netfilter/nf_nat_l3proto.h
@@ -2,7 +2,6 @@
 #ifndef _NF_NAT_L3PROTO_H
 #define _NF_NAT_L3PROTO_H
 
-struct nf_nat_l4proto;
 struct nf_nat_l3proto {
 	u8	l3proto;
 
@@ -13,7 +12,6 @@ struct nf_nat_l3proto {
 
 	bool	(*manip_pkt)(struct sk_buff *skb,
 			     unsigned int iphdroff,
-			     const struct nf_nat_l4proto *l4proto,
 			     const struct nf_conntrack_tuple *target,
 			     enum nf_nat_manip_type maniptype);
 
* Unmerged path include/net/netfilter/nf_nat_l4proto.h
* Unmerged path net/ipv4/netfilter/Makefile
diff --git a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
index 78a67f961d86..2c98efdb3b84 100644
--- a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
@@ -77,7 +77,6 @@ static u32 nf_nat_ipv4_secure_port(const struct nf_conntrack_tuple *t,
 
 static bool nf_nat_ipv4_manip_pkt(struct sk_buff *skb,
 				  unsigned int iphdroff,
-				  const struct nf_nat_l4proto *l4proto,
 				  const struct nf_conntrack_tuple *target,
 				  enum nf_nat_manip_type maniptype)
 {
@@ -186,7 +185,6 @@ int nf_nat_icmp_reply_translation(struct sk_buff *skb,
 	enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
 	enum nf_nat_manip_type manip = HOOK2MANIP(hooknum);
 	unsigned int hdrlen = ip_hdrlen(skb);
-	const struct nf_nat_l4proto *l4proto;
 	struct nf_conntrack_tuple target;
 	unsigned long statusbit;
 
@@ -217,9 +215,8 @@ int nf_nat_icmp_reply_translation(struct sk_buff *skb,
 	if (!(ct->status & statusbit))
 		return 1;
 
-	l4proto = __nf_nat_l4proto_find(NFPROTO_IPV4, inside->ip.protocol);
 	if (!nf_nat_ipv4_manip_pkt(skb, hdrlen + sizeof(inside->icmp),
-				   l4proto, &ct->tuplehash[!dir].tuple, !manip))
+				   &ct->tuplehash[!dir].tuple, !manip))
 		return 0;
 
 	if (skb->ip_summed != CHECKSUM_PARTIAL) {
@@ -233,8 +230,7 @@ int nf_nat_icmp_reply_translation(struct sk_buff *skb,
 
 	/* Change outer to look like the reply to an incoming packet */
 	nf_ct_invert_tuplepr(&target, &ct->tuplehash[!dir].tuple);
-	l4proto = __nf_nat_l4proto_find(NFPROTO_IPV4, 0);
-	if (!nf_nat_ipv4_manip_pkt(skb, 0, l4proto, &target, manip))
+	if (!nf_nat_ipv4_manip_pkt(skb, 0, &target, manip))
 		return 0;
 
 	return 1;
@@ -391,26 +387,12 @@ EXPORT_SYMBOL_GPL(nf_nat_l3proto_ipv4_unregister_fn);
 
 static int __init nf_nat_l3proto_ipv4_init(void)
 {
-	int err;
-
-	err = nf_nat_l4proto_register(NFPROTO_IPV4, &nf_nat_l4proto_icmp);
-	if (err < 0)
-		goto err1;
-	err = nf_nat_l3proto_register(&nf_nat_l3proto_ipv4);
-	if (err < 0)
-		goto err2;
-	return err;
-
-err2:
-	nf_nat_l4proto_unregister(NFPROTO_IPV4, &nf_nat_l4proto_icmp);
-err1:
-	return err;
+	return nf_nat_l3proto_register(&nf_nat_l3proto_ipv4);
 }
 
 static void __exit nf_nat_l3proto_ipv4_exit(void)
 {
 	nf_nat_l3proto_unregister(&nf_nat_l3proto_ipv4);
-	nf_nat_l4proto_unregister(NFPROTO_IPV4, &nf_nat_l4proto_icmp);
 }
 
 MODULE_LICENSE("GPL");
* Unmerged path net/ipv4/netfilter/nf_nat_proto_gre.c
* Unmerged path net/ipv4/netfilter/nf_nat_proto_icmp.c
* Unmerged path net/ipv6/netfilter/Makefile
diff --git a/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c b/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
index 9a3e0cf4290a..1f293bfbfcb2 100644
--- a/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
+++ b/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
@@ -77,7 +77,6 @@ static u32 nf_nat_ipv6_secure_port(const struct nf_conntrack_tuple *t,
 
 static bool nf_nat_ipv6_manip_pkt(struct sk_buff *skb,
 				  unsigned int iphdroff,
-				  const struct nf_nat_l4proto *l4proto,
 				  const struct nf_conntrack_tuple *target,
 				  enum nf_nat_manip_type maniptype)
 {
@@ -197,7 +196,6 @@ int nf_nat_icmpv6_reply_translation(struct sk_buff *skb,
 	} *inside;
 	enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
 	enum nf_nat_manip_type manip = HOOK2MANIP(hooknum);
-	const struct nf_nat_l4proto *l4proto;
 	struct nf_conntrack_tuple target;
 	unsigned long statusbit;
 
@@ -228,9 +226,8 @@ int nf_nat_icmpv6_reply_translation(struct sk_buff *skb,
 	if (!(ct->status & statusbit))
 		return 1;
 
-	l4proto = __nf_nat_l4proto_find(NFPROTO_IPV6, inside->ip6.nexthdr);
 	if (!nf_nat_ipv6_manip_pkt(skb, hdrlen + sizeof(inside->icmp6),
-				   l4proto, &ct->tuplehash[!dir].tuple, !manip))
+				   &ct->tuplehash[!dir].tuple, !manip))
 		return 0;
 
 	if (skb->ip_summed != CHECKSUM_PARTIAL) {
@@ -245,8 +242,7 @@ int nf_nat_icmpv6_reply_translation(struct sk_buff *skb,
 	}
 
 	nf_ct_invert_tuplepr(&target, &ct->tuplehash[!dir].tuple);
-	l4proto = __nf_nat_l4proto_find(NFPROTO_IPV6, IPPROTO_ICMPV6);
-	if (!nf_nat_ipv6_manip_pkt(skb, 0, l4proto, &target, manip))
+	if (!nf_nat_ipv6_manip_pkt(skb, 0, &target, manip))
 		return 0;
 
 	return 1;
@@ -430,26 +426,12 @@ EXPORT_SYMBOL_GPL(nf_nat_l3proto_ipv6_unregister_fn);
 
 static int __init nf_nat_l3proto_ipv6_init(void)
 {
-	int err;
-
-	err = nf_nat_l4proto_register(NFPROTO_IPV6, &nf_nat_l4proto_icmpv6);
-	if (err < 0)
-		goto err1;
-	err = nf_nat_l3proto_register(&nf_nat_l3proto_ipv6);
-	if (err < 0)
-		goto err2;
-	return err;
-
-err2:
-	nf_nat_l4proto_unregister(NFPROTO_IPV6, &nf_nat_l4proto_icmpv6);
-err1:
-	return err;
+	return nf_nat_l3proto_register(&nf_nat_l3proto_ipv6);
 }
 
 static void __exit nf_nat_l3proto_ipv6_exit(void)
 {
 	nf_nat_l3proto_unregister(&nf_nat_l3proto_ipv6);
-	nf_nat_l4proto_unregister(NFPROTO_IPV6, &nf_nat_l4proto_icmpv6);
 }
 
 MODULE_LICENSE("GPL");
* Unmerged path net/ipv6/netfilter/nf_nat_proto_icmpv6.c
* Unmerged path net/netfilter/Makefile
diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c
index 52706f27ce0a..e5ed3b7b2e4f 100644
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@ -49,7 +49,6 @@
 #include <net/netfilter/nf_conntrack_synproxy.h>
 #ifdef CONFIG_NF_NAT_NEEDED
 #include <net/netfilter/nf_nat_core.h>
-#include <net/netfilter/nf_nat_l4proto.h>
 #include <net/netfilter/nf_nat_helper.h>
 #endif
 
* Unmerged path net/netfilter/nf_nat_core.c
* Unmerged path net/netfilter/nf_nat_proto.c
* Unmerged path net/netfilter/nf_nat_proto_dccp.c
* Unmerged path net/netfilter/nf_nat_proto_sctp.c
* Unmerged path net/netfilter/nf_nat_proto_tcp.c
* Unmerged path net/netfilter/nf_nat_proto_unknown.c
