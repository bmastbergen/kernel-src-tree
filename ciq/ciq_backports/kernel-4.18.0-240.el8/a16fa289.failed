flow_offload: restrict driver to pass one allowed bit to flow_action_hw_stats_types_check()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Pirko <jiri@resnulli.us>
commit a16fa289843d5d4dd7c4d8eb3b2deb15a9d2180e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a16fa289.failed

The intention of this helper was to allow driver to specify one type
that it supports, so not only "any" value would pass. So make the API
more strict and allow driver to pass only 1 bit that is going
to be checked.

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a16fa289843d5d4dd7c4d8eb3b2deb15a9d2180e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
#	include/net/flow_offload.h
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
index 123069223147,f285713def77..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
@@@ -2865,6 -2878,10 +2865,13 @@@ static int parse_tc_nic_actions(struct 
  	if (!flow_action_has_entries(flow_action))
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	if (!flow_action_hw_stats_types_check(flow_action, extack,
+ 					      FLOW_ACTION_HW_STATS_TYPE_DELAYED_BIT))
+ 		return -EOPNOTSUPP;
+ 
++>>>>>>> a16fa289843d (flow_offload: restrict driver to pass one allowed bit to flow_action_hw_stats_types_check())
  	attr->flow_tag = MLX5_FS_DEFAULT_FLOW_TAG;
  
  	flow_action_for_each(i, act, flow_action) {
@@@ -3270,6 -3373,10 +3277,13 @@@ static int parse_tc_fdb_actions(struct 
  	if (!flow_action_has_entries(flow_action))
  		return -EINVAL;
  
++<<<<<<< HEAD
++=======
+ 	if (!flow_action_hw_stats_types_check(flow_action, extack,
+ 					      FLOW_ACTION_HW_STATS_TYPE_DELAYED_BIT))
+ 		return -EOPNOTSUPP;
+ 
++>>>>>>> a16fa289843d (flow_offload: restrict driver to pass one allowed bit to flow_action_hw_stats_types_check())
  	flow_action_for_each(i, act, flow_action) {
  		switch (act->id) {
  		case FLOW_ACTION_DROP:
diff --cc include/net/flow_offload.h
index 26b427dff50f,d1b1e4aa310a..000000000000
--- a/include/net/flow_offload.h
+++ b/include/net/flow_offload.h
@@@ -258,7 -267,78 +258,82 @@@ static inline bool flow_offload_has_one
  }
  
  #define flow_action_for_each(__i, __act, __actions)			\
++<<<<<<< HEAD
 +        for (__i = 0, __act = &(__actions)->entries[0]; __i < (__actions)->num_entries; __act = &(__actions)->entries[++__i])
++=======
+         for (__i = 0, __act = &(__actions)->entries[0];			\
+ 	     __i < (__actions)->num_entries;				\
+ 	     __act = &(__actions)->entries[++__i])
+ 
+ static inline bool
+ flow_action_mixed_hw_stats_types_check(const struct flow_action *action,
+ 				       struct netlink_ext_ack *extack)
+ {
+ 	const struct flow_action_entry *action_entry;
+ 	u8 uninitialized_var(last_hw_stats_type);
+ 	int i;
+ 
+ 	if (flow_offload_has_one_action(action))
+ 		return true;
+ 
+ 	flow_action_for_each(i, action_entry, action) {
+ 		if (i && action_entry->hw_stats_type != last_hw_stats_type) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Mixing HW stats types for actions is not supported");
+ 			return false;
+ 		}
+ 		last_hw_stats_type = action_entry->hw_stats_type;
+ 	}
+ 	return true;
+ }
+ 
+ static inline const struct flow_action_entry *
+ flow_action_first_entry_get(const struct flow_action *action)
+ {
+ 	WARN_ON(!flow_action_has_entries(action));
+ 	return &action->entries[0];
+ }
+ 
+ static inline bool
+ __flow_action_hw_stats_types_check(const struct flow_action *action,
+ 				   struct netlink_ext_ack *extack,
+ 				   bool check_allow_bit,
+ 				   enum flow_action_hw_stats_type_bit allow_bit)
+ {
+ 	const struct flow_action_entry *action_entry;
+ 
+ 	if (!flow_action_has_entries(action))
+ 		return true;
+ 	if (!flow_action_mixed_hw_stats_types_check(action, extack))
+ 		return false;
+ 	action_entry = flow_action_first_entry_get(action);
+ 	if (!check_allow_bit &&
+ 	    action_entry->hw_stats_type != FLOW_ACTION_HW_STATS_TYPE_ANY) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Driver supports only default HW stats type \"any\"");
+ 		return false;
+ 	} else if (check_allow_bit &&
+ 		   !(action_entry->hw_stats_type & BIT(allow_bit))) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Driver does not support selected HW stats type");
+ 		return false;
+ 	}
+ 	return true;
+ }
+ 
+ static inline bool
+ flow_action_hw_stats_types_check(const struct flow_action *action,
+ 				 struct netlink_ext_ack *extack,
+ 				 enum flow_action_hw_stats_type_bit allow_bit)
+ {
+ 	return __flow_action_hw_stats_types_check(action, extack,
+ 						  true, allow_bit);
+ }
+ 
+ static inline bool
+ flow_action_basic_hw_stats_types_check(const struct flow_action *action,
+ 				       struct netlink_ext_ack *extack)
+ {
+ 	return __flow_action_hw_stats_types_check(action, extack, false, 0);
+ }
++>>>>>>> a16fa289843d (flow_offload: restrict driver to pass one allowed bit to flow_action_hw_stats_types_check())
  
  struct flow_rule {
  	struct flow_match	match;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_tc.c
* Unmerged path include/net/flow_offload.h
