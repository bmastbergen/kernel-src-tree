bpf: Switch bpf_map_{area_alloc,area_mmapable_alloc}() to u64 size

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] bpf: Switch bpf_map_{area_alloc, area_mmapable_alloc}() to u64 size (Yauheni Kaliuta) [1813370]
Rebuild_FUZZ: 99.25%
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit 196e8ca74886c433dcfc64a809707074b936aaf5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/196e8ca7.failed

Given we recently extended the original bpf_map_area_alloc() helper in
commit fc9702273e2e ("bpf: Add mmap() support for BPF_MAP_TYPE_ARRAY"),
we need to apply the same logic as in ff1c08e1f74b ("bpf: Change size
to u64 for bpf_map_{area_alloc, charge_init}()"). To avoid conflicts,
extend it for bpf-next.

	Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
(cherry picked from commit 196e8ca74886c433dcfc64a809707074b936aaf5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bpf.h
#	kernel/bpf/syscall.c
diff --cc include/linux/bpf.h
index a5585413dfbe,e89e86122233..000000000000
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@@ -692,6 -799,7 +692,10 @@@ void bpf_map_charge_finish(struct bpf_m
  void bpf_map_charge_move(struct bpf_map_memory *dst,
  			 struct bpf_map_memory *src);
  void *bpf_map_area_alloc(u64 size, int numa_node);
++<<<<<<< HEAD
++=======
+ void *bpf_map_area_mmapable_alloc(u64 size, int numa_node);
++>>>>>>> 196e8ca74886 (bpf: Switch bpf_map_{area_alloc,area_mmapable_alloc}() to u64 size)
  void bpf_map_area_free(void *base);
  void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr);
  
diff --cc kernel/bpf/syscall.c
index dd68cbc967e7,b51ecb9644d0..000000000000
--- a/kernel/bpf/syscall.c
+++ b/kernel/bpf/syscall.c
@@@ -156,7 -128,7 +156,11 @@@ static struct bpf_map *find_and_alloc_m
  	return map;
  }
  
++<<<<<<< HEAD
 +void *bpf_map_area_alloc(u64 size, int numa_node)
++=======
+ static void *__bpf_map_area_alloc(u64 size, int numa_node, bool mmapable)
++>>>>>>> 196e8ca74886 (bpf: Switch bpf_map_{area_alloc,area_mmapable_alloc}() to u64 size)
  {
  	/* We really just want to fail instead of triggering OOM killer
  	 * under memory pressure, therefore we set __GFP_NORETRY to kmalloc,
@@@ -174,7 -146,8 +178,12 @@@
  	if (size >= SIZE_MAX)
  		return NULL;
  
++<<<<<<< HEAD
 +	if (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {
++=======
+ 	/* kmalloc()'ed memory can't be mmap()'ed */
+ 	if (!mmapable && size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {
++>>>>>>> 196e8ca74886 (bpf: Switch bpf_map_{area_alloc,area_mmapable_alloc}() to u64 size)
  		area = kmalloc_node(size, GFP_USER | __GFP_NORETRY | flags,
  				    numa_node);
  		if (area != NULL)
@@@ -186,6 -163,16 +195,19 @@@
  					   flags, __builtin_return_address(0));
  }
  
++<<<<<<< HEAD
++=======
+ void *bpf_map_area_alloc(u64 size, int numa_node)
+ {
+ 	return __bpf_map_area_alloc(size, numa_node, false);
+ }
+ 
+ void *bpf_map_area_mmapable_alloc(u64 size, int numa_node)
+ {
+ 	return __bpf_map_area_alloc(size, numa_node, true);
+ }
+ 
++>>>>>>> 196e8ca74886 (bpf: Switch bpf_map_{area_alloc,area_mmapable_alloc}() to u64 size)
  void bpf_map_area_free(void *area)
  {
  	kvfree(area);
* Unmerged path include/linux/bpf.h
* Unmerged path kernel/bpf/syscall.c
