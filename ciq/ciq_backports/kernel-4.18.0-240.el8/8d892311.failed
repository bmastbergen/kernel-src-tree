KVM: x86: Fix CPUID range checks for Hypervisor and Centaur classes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 8d8923115f1bc8f10b3309b9245cc3a7f39b5aa7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8d892311.failed

Rework the masking in the out-of-range CPUID logic to handle the
Hypervisor sub-classes, as well as the Centaur class if the guest
virtual CPU vendor is Centaur.

Masking against 0x80000000 only handles basic and extended leafs, which
results in Hypervisor range checks being performed against the basic
CPUID class, and Centuar range checks being performed against the
Extended class.  E.g. if CPUID.0x40000000.EAX returns 0x4000000A and
there is no entry for CPUID.0x40000006, then function 0x40000006 would
be incorrectly reported as out of bounds.

While there is no official definition of what constitutes a class, the
convention established for Hypervisor classes effectively uses bits 31:8
as the mask by virtue of checking for different bases in increments of
0x100, e.g. KVM advertises its CPUID functions starting at 0x40000100
when HyperV features are advertised at the default base of 0x40000000.

The bad range check doesn't cause functional problems for any known VMM
because out-of-range semantics only come into play if the exact entry
isn't found, and VMMs either support a very limited Hypervisor range,
e.g. the official KVM range is 0x40000000-0x40000001 (effectively no
room for undefined leafs) or explicitly defines gaps to be zero, e.g.
Qemu explicitly creates zeroed entries up to the Centaur and Hypervisor
limits (the latter comes into play when providing HyperV features).

The bad behavior can be visually confirmed by dumping CPUID output in
the guest when running Qemu with a stable TSC, as Qemu extends the limit
of range 0x40000000 to 0x40000010 to advertise VMware's cpuid_freq,
without defining zeroed entries for 0x40000002 - 0x4000000f.

Note, documentation of Centaur/VIA CPUs is hard to come by.  Designating
0xc0000000 - 0xcfffffff as the Centaur class is a best guess as to the
behavior of a real Centaur/VIA CPU.

Fixes: 43561123ab37 ("kvm: x86: Improve emulation of CPUID leaves 0BH and 1FH")
	Cc: Jim Mattson <jmattson@google.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 8d8923115f1bc8f10b3309b9245cc3a7f39b5aa7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/kvm_emulate.h
diff --cc arch/x86/kvm/kvm_emulate.h
index dcdb44a5fb11,3cb50eda606d..000000000000
--- a/arch/x86/kvm/kvm_emulate.h
+++ b/arch/x86/kvm/kvm_emulate.h
@@@ -388,6 -396,34 +388,37 @@@ struct x86_emulate_ctxt 
  #define X86EMUL_CPUID_VENDOR_GenuineIntel_ecx 0x6c65746e
  #define X86EMUL_CPUID_VENDOR_GenuineIntel_edx 0x49656e69
  
++<<<<<<< HEAD
++=======
+ #define X86EMUL_CPUID_VENDOR_CentaurHauls_ebx 0x746e6543
+ #define X86EMUL_CPUID_VENDOR_CentaurHauls_ecx 0x736c7561
+ #define X86EMUL_CPUID_VENDOR_CentaurHauls_edx 0x48727561
+ 
+ static inline bool is_guest_vendor_intel(u32 ebx, u32 ecx, u32 edx)
+ {
+ 	return ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx &&
+ 	       ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx &&
+ 	       edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx;
+ }
+ 
+ static inline bool is_guest_vendor_amd(u32 ebx, u32 ecx, u32 edx)
+ {
+ 	return (ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx &&
+ 		ecx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx &&
+ 		edx == X86EMUL_CPUID_VENDOR_AuthenticAMD_edx) ||
+ 	       (ebx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx &&
+ 		ecx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx &&
+ 		edx == X86EMUL_CPUID_VENDOR_AMDisbetterI_edx);
+ }
+ 
+ static inline bool is_guest_vendor_hygon(u32 ebx, u32 ecx, u32 edx)
+ {
+ 	return ebx == X86EMUL_CPUID_VENDOR_HygonGenuine_ebx &&
+ 	       ecx == X86EMUL_CPUID_VENDOR_HygonGenuine_ecx &&
+ 	       edx == X86EMUL_CPUID_VENDOR_HygonGenuine_edx;
+ }
+ 
++>>>>>>> 8d8923115f1b (KVM: x86: Fix CPUID range checks for Hypervisor and Centaur classes)
  enum x86_intercept_stage {
  	X86_ICTP_NONE = 0,   /* Allow zero-init to not match anything */
  	X86_ICPT_PRE_EXCEPT,
diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c
index 78d6db1ce0f2..40ba46772467 100644
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@ -995,16 +995,49 @@ struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,
 EXPORT_SYMBOL_GPL(kvm_find_cpuid_entry);
 
 /*
- * If the basic or extended CPUID leaf requested is higher than the
- * maximum supported basic or extended leaf, respectively, then it is
- * out of range.
+ * Intel CPUID semantics treats any query for an out-of-range leaf as if the
+ * highest basic leaf (i.e. CPUID.0H:EAX) were requested.  AMD CPUID semantics
+ * returns all zeroes for any undefined leaf, whether or not the leaf is in
+ * range.  Centaur/VIA follows Intel semantics.
+ *
+ * A leaf is considered out-of-range if its function is higher than the maximum
+ * supported leaf of its associated class or if its associated class does not
+ * exist.
+ *
+ * There are three primary classes to be considered, with their respective
+ * ranges described as "<base> - <top>[,<base2> - <top2>] inclusive.  A primary
+ * class exists if a guest CPUID entry for its <base> leaf exists.  For a given
+ * class, CPUID.<base>.EAX contains the max supported leaf for the class.
+ *
+ *  - Basic:      0x00000000 - 0x3fffffff, 0x50000000 - 0x7fffffff
+ *  - Hypervisor: 0x40000000 - 0x4fffffff
+ *  - Extended:   0x80000000 - 0xbfffffff
+ *  - Centaur:    0xc0000000 - 0xcfffffff
+ *
+ * The Hypervisor class is further subdivided into sub-classes that each act as
+ * their own indepdent class associated with a 0x100 byte range.  E.g. if Qemu
+ * is advertising support for both HyperV and KVM, the resulting Hypervisor
+ * CPUID sub-classes are:
+ *
+ *  - HyperV:     0x40000000 - 0x400000ff
+ *  - KVM:        0x40000100 - 0x400001ff
  */
 static bool cpuid_function_in_range(struct kvm_vcpu *vcpu, u32 function)
 {
-	struct kvm_cpuid_entry2 *max;
+	struct kvm_cpuid_entry2 *basic, *class;
+
+	basic = kvm_find_cpuid_entry(vcpu, 0, 0);
+	if (!basic)
+		return true;
+
+	if (function >= 0x40000000 && function <= 0x4fffffff)
+		class = kvm_find_cpuid_entry(vcpu, function & 0xffffff00, 0);
+	else if (function >= 0xc0000000)
+		class = kvm_find_cpuid_entry(vcpu, 0xc0000000, 0);
+	else
+		class = kvm_find_cpuid_entry(vcpu, function & 0x80000000, 0);
 
-	max = kvm_find_cpuid_entry(vcpu, function & 0x80000000, 0);
-	return max && function <= max->eax;
+	return class && function <= class->eax;
 }
 
 bool kvm_cpuid(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx,
* Unmerged path arch/x86/kvm/kvm_emulate.h
