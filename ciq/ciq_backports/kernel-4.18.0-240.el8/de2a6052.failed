netfilter: nf_tables_offload: check for register data length mismatches

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit de2a60522343a6cab998f61fd906eae445b19963
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/de2a6052.failed

Make sure register data length does not mismatch immediate data length,
otherwise hit EOPNOTSUPP.

Fixes: c9626a2cbdb2 ("netfilter: nf_tables: add hardware offload support")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit de2a60522343a6cab998f61fd906eae445b19963)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_cmp.c
diff --cc net/netfilter/nft_cmp.c
index 7007045c0849,0744b2bb46da..000000000000
--- a/net/netfilter/nft_cmp.c
+++ b/net/netfilter/nft_cmp.c
@@@ -116,6 -108,37 +116,40 @@@ nla_put_failure
  	return -1;
  }
  
++<<<<<<< HEAD
++=======
+ static int __nft_cmp_offload(struct nft_offload_ctx *ctx,
+ 			     struct nft_flow_rule *flow,
+ 			     const struct nft_cmp_expr *priv)
+ {
+ 	struct nft_offload_reg *reg = &ctx->regs[priv->sreg];
+ 	u8 *mask = (u8 *)&flow->match.mask;
+ 	u8 *key = (u8 *)&flow->match.key;
+ 
+ 	if (priv->op != NFT_CMP_EQ || reg->len != priv->len)
+ 		return -EOPNOTSUPP;
+ 
+ 	memcpy(key + reg->offset, &priv->data, priv->len);
+ 	memcpy(mask + reg->offset, &reg->mask, priv->len);
+ 
+ 	flow->match.dissector.used_keys |= BIT(reg->key);
+ 	flow->match.dissector.offset[reg->key] = reg->base_offset;
+ 
+ 	nft_offload_update_dependency(ctx, &priv->data, priv->len);
+ 
+ 	return 0;
+ }
+ 
+ static int nft_cmp_offload(struct nft_offload_ctx *ctx,
+ 			   struct nft_flow_rule *flow,
+ 			   const struct nft_expr *expr)
+ {
+ 	const struct nft_cmp_expr *priv = nft_expr_priv(expr);
+ 
+ 	return __nft_cmp_offload(ctx, flow, priv);
+ }
+ 
++>>>>>>> de2a60522343 (netfilter: nf_tables_offload: check for register data length mismatches)
  static const struct nft_expr_ops nft_cmp_ops = {
  	.type		= &nft_cmp_type,
  	.size		= NFT_EXPR_SIZE(sizeof(struct nft_cmp_expr)),
diff --git a/net/netfilter/nft_bitwise.c b/net/netfilter/nft_bitwise.c
index 777f5fb7e0d5..fdff6944a0fe 100644
--- a/net/netfilter/nft_bitwise.c
+++ b/net/netfilter/nft_bitwise.c
@@ -138,12 +138,13 @@ static int nft_bitwise_offload(struct nft_offload_ctx *ctx,
                                const struct nft_expr *expr)
 {
 	const struct nft_bitwise *priv = nft_expr_priv(expr);
+	struct nft_offload_reg *reg = &ctx->regs[priv->dreg];
 
 	if (memcmp(&priv->xor, &zero, sizeof(priv->xor)) ||
-	    priv->sreg != priv->dreg)
+	    priv->sreg != priv->dreg || priv->len != reg->len)
 		return -EOPNOTSUPP;
 
-	memcpy(&ctx->regs[priv->dreg].mask, &priv->mask, sizeof(priv->mask));
+	memcpy(&reg->mask, &priv->mask, sizeof(priv->mask));
 
 	return 0;
 }
* Unmerged path net/netfilter/nft_cmp.c
