KVM: VMX: Fix the spelling of CPU_BASED_USE_TSC_OFFSETTING

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Xiaoyao Li <xiaoyao.li@intel.com>
commit 5e3d394fdd9e6b49cd8b28d85adff100a5bddc66
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5e3d394f.failed

The mis-spelling is found by checkpatch.pl, so fix them.

	Signed-off-by: Xiaoyao Li <xiaoyao.li@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 5e3d394fdd9e6b49cd8b28d85adff100a5bddc66)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/vmx.h
#	arch/x86/kvm/vmx/nested.c
#	tools/testing/selftests/kvm/include/x86_64/vmx.h
diff --cc arch/x86/include/asm/vmx.h
index 1ae56d893b39,d716fe938fc0..000000000000
--- a/arch/x86/include/asm/vmx.h
+++ b/arch/x86/include/asm/vmx.h
@@@ -32,8 -19,8 +32,13 @@@
  /*
   * Definitions of Primary Processor-Based VM-Execution Controls.
   */
++<<<<<<< HEAD
 +#define CPU_BASED_VIRTUAL_INTR_PENDING          0x00000004
 +#define CPU_BASED_USE_TSC_OFFSETING             0x00000008
++=======
+ #define CPU_BASED_INTR_WINDOW_EXITING           0x00000004
+ #define CPU_BASED_USE_TSC_OFFSETTING            0x00000008
++>>>>>>> 5e3d394fdd9e (KVM: VMX: Fix the spelling of CPU_BASED_USE_TSC_OFFSETTING)
  #define CPU_BASED_HLT_EXITING                   0x00000080
  #define CPU_BASED_INVLPG_EXITING                0x00000200
  #define CPU_BASED_MWAIT_EXITING                 0x00000400
diff --cc arch/x86/kvm/vmx/nested.c
index 14c603e204e3,8c215da368b7..000000000000
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@@ -6018,8 -6015,8 +6018,13 @@@ void nested_vmx_setup_ctls_msrs(struct 
  	msrs->procbased_ctls_low =
  		CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR;
  	msrs->procbased_ctls_high &=
++<<<<<<< HEAD
 +		CPU_BASED_VIRTUAL_INTR_PENDING |
 +		CPU_BASED_VIRTUAL_NMI_PENDING | CPU_BASED_USE_TSC_OFFSETING |
++=======
+ 		CPU_BASED_INTR_WINDOW_EXITING |
+ 		CPU_BASED_NMI_WINDOW_EXITING | CPU_BASED_USE_TSC_OFFSETTING |
++>>>>>>> 5e3d394fdd9e (KVM: VMX: Fix the spelling of CPU_BASED_USE_TSC_OFFSETTING)
  		CPU_BASED_HLT_EXITING | CPU_BASED_INVLPG_EXITING |
  		CPU_BASED_MWAIT_EXITING | CPU_BASED_CR3_LOAD_EXITING |
  		CPU_BASED_CR3_STORE_EXITING |
diff --cc tools/testing/selftests/kvm/include/x86_64/vmx.h
index 433c43cce2ea,3d27069b9ed9..000000000000
--- a/tools/testing/selftests/kvm/include/x86_64/vmx.h
+++ b/tools/testing/selftests/kvm/include/x86_64/vmx.h
@@@ -20,8 -18,8 +20,13 @@@
  /*
   * Definitions of Primary Processor-Based VM-Execution Controls.
   */
++<<<<<<< HEAD
 +#define CPU_BASED_VIRTUAL_INTR_PENDING		0x00000004
 +#define CPU_BASED_USE_TSC_OFFSETING		0x00000008
++=======
+ #define CPU_BASED_INTR_WINDOW_EXITING		0x00000004
+ #define CPU_BASED_USE_TSC_OFFSETTING		0x00000008
++>>>>>>> 5e3d394fdd9e (KVM: VMX: Fix the spelling of CPU_BASED_USE_TSC_OFFSETTING)
  #define CPU_BASED_HLT_EXITING			0x00000080
  #define CPU_BASED_INVLPG_EXITING		0x00000200
  #define CPU_BASED_MWAIT_EXITING			0x00000400
* Unmerged path arch/x86/include/asm/vmx.h
* Unmerged path arch/x86/kvm/vmx/nested.c
diff --git a/arch/x86/kvm/vmx/vmx.c b/arch/x86/kvm/vmx/vmx.c
index d1c5b096e0f4..fc1712547b30 100644
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@ -1728,7 +1728,7 @@ static u64 vmx_read_l1_tsc_offset(struct kvm_vcpu *vcpu)
 	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
 
 	if (is_guest_mode(vcpu) &&
-	    (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETING))
+	    (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING))
 		return vcpu->arch.tsc_offset - vmcs12->tsc_offset;
 
 	return vcpu->arch.tsc_offset;
@@ -1746,7 +1746,7 @@ static u64 vmx_write_l1_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)
 	 * to the newly set TSC to get L2's TSC.
 	 */
 	if (is_guest_mode(vcpu) &&
-	    (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETING))
+	    (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING))
 		g_tsc_offset = vmcs12->tsc_offset;
 
 	trace_kvm_write_tsc_offset(vcpu->vcpu_id,
@@ -2394,7 +2394,7 @@ static __init int setup_vmcs_config(struct vmcs_config *vmcs_conf,
 	      CPU_BASED_CR3_STORE_EXITING |
 	      CPU_BASED_UNCOND_IO_EXITING |
 	      CPU_BASED_MOV_DR_EXITING |
-	      CPU_BASED_USE_TSC_OFFSETING |
+	      CPU_BASED_USE_TSC_OFFSETTING |
 	      CPU_BASED_MWAIT_EXITING |
 	      CPU_BASED_MONITOR_EXITING |
 	      CPU_BASED_INVLPG_EXITING |
* Unmerged path tools/testing/selftests/kvm/include/x86_64/vmx.h
diff --git a/tools/testing/selftests/kvm/x86_64/vmx_tsc_adjust_test.c b/tools/testing/selftests/kvm/x86_64/vmx_tsc_adjust_test.c
index b6afaef615a3..e057df7a9946 100644
--- a/tools/testing/selftests/kvm/x86_64/vmx_tsc_adjust_test.c
+++ b/tools/testing/selftests/kvm/x86_64/vmx_tsc_adjust_test.c
@@ -100,7 +100,7 @@ static void l1_guest_code(struct vmx_pages *vmx_pages)
 	prepare_vmcs(vmx_pages, l2_guest_code,
 		     &l2_guest_stack[L2_GUEST_STACK_SIZE]);
 	control = vmreadz(CPU_BASED_VM_EXEC_CONTROL);
-	control |= CPU_BASED_USE_MSR_BITMAPS | CPU_BASED_USE_TSC_OFFSETING;
+	control |= CPU_BASED_USE_MSR_BITMAPS | CPU_BASED_USE_TSC_OFFSETTING;
 	vmwrite(CPU_BASED_VM_EXEC_CONTROL, control);
 	vmwrite(TSC_OFFSET, TSC_OFFSET_VALUE);
 
