io_uring: account fixed file references correctly in batch

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jens Axboe <axboe@kernel.dk>
commit 10fef4bebf979bb705feed087611293d5864adfe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/10fef4be.failed

We can't assume that the whole batch has fixed files in it. If it's a
mix, or none at all, then we can end up doing a ref put that either
messes up accounting, or causes an oops if we have no fixed files at
all.

Also ensure we free requests properly between inflight accounted and
normal requests.

Fixes: 82c721577011 ("io_uring: extend batch freeing to cover more cases")
	Reported-by: Dmitrii Dolgov <9erthalion6@gmail.com>
	Reported-by: Pavel Begunkov <asml.silence@gmail.com>
	Tested-by: Dmitrii Dolgov <9erthalion6@gmail.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 10fef4bebf979bb705feed087611293d5864adfe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 28a601d08266,8a645a37b4c7..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -626,15 -1182,102 +626,89 @@@ static void io_free_req_many(struct io_
  
  static void __io_free_req(struct io_kiocb *req)
  {
 -	__io_req_aux_free(req);
 -
 -	if (req->flags & REQ_F_INFLIGHT) {
 -		struct io_ring_ctx *ctx = req->ctx;
 -		unsigned long flags;
 -
 -		spin_lock_irqsave(&ctx->inflight_lock, flags);
 -		list_del(&req->inflight_entry);
 -		if (waitqueue_active(&ctx->inflight_wait))
 -			wake_up(&ctx->inflight_wait);
 -		spin_unlock_irqrestore(&ctx->inflight_lock, flags);
 -	}
 -
 +	if (req->file && !(req->flags & REQ_F_FIXED_FILE))
 +		fput(req->file);
  	percpu_ref_put(&req->ctx->refs);
 -	__io_req_do_free(req);
 +	kmem_cache_free(req_cachep, req);
  }
  
 -struct req_batch {
 -	void *reqs[IO_IOPOLL_BATCH];
 -	int to_free;
 -	int need_iter;
 -};
 -
 -static void io_free_req_many(struct io_ring_ctx *ctx, struct req_batch *rb)
 +static void io_req_link_next(struct io_kiocb *req)
  {
++<<<<<<< HEAD
 +	struct io_kiocb *nxt;
++=======
+ 	int fixed_refs = rb->to_free;
+ 
+ 	if (!rb->to_free)
+ 		return;
+ 	if (rb->need_iter) {
+ 		int i, inflight = 0;
+ 		unsigned long flags;
+ 
+ 		fixed_refs = 0;
+ 		for (i = 0; i < rb->to_free; i++) {
+ 			struct io_kiocb *req = rb->reqs[i];
+ 
+ 			if (req->flags & REQ_F_FIXED_FILE) {
+ 				req->file = NULL;
+ 				fixed_refs++;
+ 			}
+ 			if (req->flags & REQ_F_INFLIGHT)
+ 				inflight++;
+ 			__io_req_aux_free(req);
+ 		}
+ 		if (!inflight)
+ 			goto do_free;
+ 
+ 		spin_lock_irqsave(&ctx->inflight_lock, flags);
+ 		for (i = 0; i < rb->to_free; i++) {
+ 			struct io_kiocb *req = rb->reqs[i];
+ 
+ 			if (req->flags & REQ_F_INFLIGHT) {
+ 				list_del(&req->inflight_entry);
+ 				if (!--inflight)
+ 					break;
+ 			}
+ 		}
+ 		spin_unlock_irqrestore(&ctx->inflight_lock, flags);
+ 
+ 		if (waitqueue_active(&ctx->inflight_wait))
+ 			wake_up(&ctx->inflight_wait);
+ 	}
+ do_free:
+ 	kmem_cache_free_bulk(req_cachep, rb->to_free, rb->reqs);
+ 	if (fixed_refs)
+ 		percpu_ref_put_many(&ctx->file_data->refs, fixed_refs);
+ 	percpu_ref_put_many(&ctx->refs, rb->to_free);
+ 	rb->to_free = rb->need_iter = 0;
+ }
+ 
+ static bool io_link_cancel_timeout(struct io_kiocb *req)
+ {
+ 	struct io_ring_ctx *ctx = req->ctx;
+ 	int ret;
+ 
+ 	ret = hrtimer_try_to_cancel(&req->io->timeout.timer);
+ 	if (ret != -1) {
+ 		io_cqring_fill_event(req, -ECANCELED);
+ 		io_commit_cqring(ctx);
+ 		req->flags &= ~REQ_F_LINK;
+ 		io_put_req(req);
+ 		return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ static void io_req_link_next(struct io_kiocb *req, struct io_kiocb **nxtptr)
+ {
+ 	struct io_ring_ctx *ctx = req->ctx;
+ 	bool wake_ev = false;
+ 
+ 	/* Already got next link */
+ 	if (req->flags & REQ_F_LINK_NEXT)
+ 		return;
++>>>>>>> 10fef4bebf97 (io_uring: account fixed file references correctly in batch)
  
  	/*
  	 * The list should never be empty when we are called here. But could
* Unmerged path fs/io_uring.c
