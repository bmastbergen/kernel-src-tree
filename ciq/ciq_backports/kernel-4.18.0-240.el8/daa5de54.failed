io_uring: compare cached_cq_tail with cq.head in_io_uring_poll

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author yangerkun <yangerkun@huawei.com>
commit daa5de5415849b9a53056ec1e1e88fe4c5c9aa2b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/daa5de54.failed

After 75b28af("io_uring: allocate the two rings together"), we compare
sq.head with cached_cq_tail to determine does there any cq invalid.
Actually, we should use cq.head.

Fixes: 75b28affdd6a ("io_uring: allocate the two rings together")
	Signed-off-by: yangerkun <yangerkun@huawei.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit daa5de5415849b9a53056ec1e1e88fe4c5c9aa2b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 3c3c73eab2a0,9b84232e5cc4..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -3318,10 -3452,10 +3318,14 @@@ static __poll_t io_uring_poll(struct fi
  	 * io_commit_cqring
  	 */
  	smp_rmb();
 -	if (READ_ONCE(ctx->rings->sq.tail) - ctx->cached_sq_head !=
 -	    ctx->rings->sq_ring_entries)
 +	if (READ_ONCE(ctx->sq_ring->r.tail) - ctx->cached_sq_head !=
 +	    ctx->sq_ring->ring_entries)
  		mask |= EPOLLOUT | EPOLLWRNORM;
++<<<<<<< HEAD
 +	if (READ_ONCE(ctx->cq_ring->r.head) != ctx->cached_cq_tail)
++=======
+ 	if (READ_ONCE(ctx->rings->cq.head) != ctx->cached_cq_tail)
++>>>>>>> daa5de541584 (io_uring: compare cached_cq_tail with cq.head in_io_uring_poll)
  		mask |= EPOLLIN | EPOLLRDNORM;
  
  	return mask;
* Unmerged path fs/io_uring.c
