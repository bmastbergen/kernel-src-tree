Bluetooth: hci_qca: Enable power off/on support during hci down/up for QCA Rome

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Rocky Liao <rjliao@codeaurora.org>
commit ae563183b647b3bdb47e8a78a5de879adf733735
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ae563183.failed

This patch registers hdev->shutdown() callback and also sets
HCI_QUIRK_NON_PERSISTENT_SETUP for QCA Rome. It will power-off the BT chip
during hci down and power-on/initialize the chip again during hci up. As
wcn399x already enabled this, this patch also removed the callback register
and QUIRK setting in qca_setup() for wcn399x and uniformly do this in the
probe() routine.

	Signed-off-by: Rocky Liao <rjliao@codeaurora.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit ae563183b647b3bdb47e8a78a5de879adf733735)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/hci_qca.c
diff --cc drivers/bluetooth/hci_qca.c
index c7723b08787d,d6e0c99ee5eb..000000000000
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@@ -914,48 -1542,68 +914,68 @@@ static int qca_setup(struct hci_uart *h
  	struct hci_dev *hdev = hu->hdev;
  	struct qca_data *qca = hu->priv;
  	unsigned int speed, qca_baudrate = QCA_BAUDRATE_115200;
 -	unsigned int retries = 0;
 -	enum qca_btsoc_type soc_type = qca_soc_type(hu);
 -	const char *firmware_name = qca_get_firmware_name(hu);
  	int ret;
 -	int soc_ver = 0;
  
 -	ret = qca_check_speeds(hu);
 -	if (ret)
 -		return ret;
 +	bt_dev_info(hdev, "ROME setup");
  
  	/* Patch downloading has to be done without IBS mode */
 -	clear_bit(QCA_IBS_ENABLED, &qca->flags);
 +	clear_bit(STATE_IN_BAND_SLEEP_ENABLED, &qca->flags);
  
 -	/* Enable controller to do both LE scan and BR/EDR inquiry
 -	 * simultaneously.
 -	 */
 -	set_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);
 +	/* Setup initial baudrate */
 +	speed = 0;
 +	if (hu->init_speed)
 +		speed = hu->init_speed;
 +	else if (hu->proto->init_speed)
 +		speed = hu->proto->init_speed;
  
++<<<<<<< HEAD
 +	if (speed)
 +		host_set_baudrate(hu, speed);
++=======
+ 	bt_dev_info(hdev, "setting up %s",
+ 		qca_is_wcn399x(soc_type) ? "wcn399x" : "ROME");
+ 
+ retry:
+ 	ret = qca_power_on(hdev);
+ 	if (ret)
+ 		return ret;
+ 
+ 	if (qca_is_wcn399x(soc_type)) {
+ 		set_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks);
+ 
+ 		ret = qca_read_soc_version(hdev, &soc_ver, soc_type);
+ 		if (ret)
+ 			return ret;
+ 	} else {
+ 		qca_set_speed(hu, QCA_INIT_SPEED);
+ 	}
++>>>>>>> ae563183b647 (Bluetooth: hci_qca: Enable power off/on support during hci down/up for QCA Rome)
  
  	/* Setup user speed if needed */
 -	speed = qca_get_speed(hu, QCA_OPER_SPEED);
 -	if (speed) {
 -		ret = qca_set_speed(hu, QCA_OPER_SPEED);
 -		if (ret)
 -			return ret;
 +	speed = 0;
 +	if (hu->oper_speed)
 +		speed = hu->oper_speed;
 +	else if (hu->proto->oper_speed)
 +		speed = hu->proto->oper_speed;
  
 +	if (speed) {
  		qca_baudrate = qca_get_baudrate_value(speed);
 -	}
  
 -	if (!qca_is_wcn399x(soc_type)) {
 -		/* Get QCA version information */
 -		ret = qca_read_soc_version(hdev, &soc_ver, soc_type);
 -		if (ret)
 +		bt_dev_info(hdev, "Set UART speed to %d", speed);
 +		ret = qca_set_baudrate(hdev, qca_baudrate);
 +		if (ret) {
 +			bt_dev_err(hdev, "Failed to change the baud rate (%d)",
 +				   ret);
  			return ret;
 +		}
 +		host_set_baudrate(hu, speed);
  	}
  
 -	bt_dev_info(hdev, "QCA controller version 0x%08x", soc_ver);
  	/* Setup patch / NVM configurations */
 -	ret = qca_uart_setup(hdev, qca_baudrate, soc_type, soc_ver,
 -			firmware_name);
 +	ret = qca_uart_setup_rome(hdev, qca_baudrate);
  	if (!ret) {
 -		set_bit(QCA_IBS_ENABLED, &qca->flags);
 +		set_bit(STATE_IN_BAND_SLEEP_ENABLED, &qca->flags);
  		qca_debugfs_init(hdev);
 -		hu->hdev->hw_error = qca_hw_error;
 -		hu->hdev->cmd_timeout = qca_cmd_timeout;
  	} else if (ret == -ENOENT) {
  		/* No patch/nvm-config found, run with original fw/config */
  		ret = 0;
@@@ -991,6 -1656,160 +1011,11 @@@ static const struct hci_uart_proto qca_
  static int qca_serdev_probe(struct serdev_device *serdev)
  {
  	struct qca_serdev *qcadev;
++<<<<<<< HEAD
++=======
+ 	struct hci_dev *hdev;
+ 	const struct qca_vreg_data *data;
++>>>>>>> ae563183b647 (Bluetooth: hci_qca: Enable power off/on support during hci down/up for QCA Rome)
  	int err;
  
  	qcadev = devm_kzalloc(&serdev->dev, sizeof(*qcadev), GFP_KERNEL);
@@@ -998,34 -1817,74 +1023,93 @@@
  		return -ENOMEM;
  
  	qcadev->serdev_hu.serdev = serdev;
 -	data = device_get_match_data(&serdev->dev);
  	serdev_device_set_drvdata(serdev, qcadev);
 -	device_property_read_string(&serdev->dev, "firmware-name",
 -					 &qcadev->firmware_name);
 -	if (data && qca_is_wcn399x(data->soc_type)) {
 -		qcadev->btsoc_type = data->soc_type;
 -		qcadev->bt_power = devm_kzalloc(&serdev->dev,
 -						sizeof(struct qca_power),
 -						GFP_KERNEL);
 -		if (!qcadev->bt_power)
 -			return -ENOMEM;
  
++<<<<<<< HEAD
 +	qcadev->bt_en = devm_gpiod_get(&serdev->dev, "enable",
 +				       GPIOD_OUT_LOW);
 +	if (IS_ERR(qcadev->bt_en)) {
 +		dev_err(&serdev->dev, "failed to acquire enable gpio\n");
 +		return PTR_ERR(qcadev->bt_en);
 +	}
 +
 +	qcadev->susclk = devm_clk_get(&serdev->dev, NULL);
 +	if (IS_ERR(qcadev->susclk)) {
 +		dev_err(&serdev->dev, "failed to acquire clk\n");
 +		return PTR_ERR(qcadev->susclk);
 +	}
 +
 +	err = clk_set_rate(qcadev->susclk, SUSCLK_RATE_32KHZ);
 +	if (err)
 +		return err;
 +
 +	err = clk_prepare_enable(qcadev->susclk);
 +	if (err)
 +		return err;
 +
 +	err = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);
 +	if (err)
 +		clk_disable_unprepare(qcadev->susclk);
 +
 +	return err;
++=======
+ 		qcadev->bt_power->dev = &serdev->dev;
+ 		err = qca_init_regulators(qcadev->bt_power, data->vregs,
+ 					  data->num_vregs);
+ 		if (err) {
+ 			BT_ERR("Failed to init regulators:%d", err);
+ 			return err;
+ 		}
+ 
+ 		qcadev->bt_power->vregs_on = false;
+ 
+ 		device_property_read_u32(&serdev->dev, "max-speed",
+ 					 &qcadev->oper_speed);
+ 		if (!qcadev->oper_speed)
+ 			BT_DBG("UART will pick default operating speed");
+ 
+ 		err = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);
+ 		if (err) {
+ 			BT_ERR("wcn3990 serdev registration failed");
+ 			return err;
+ 		}
+ 	} else {
+ 		qcadev->btsoc_type = QCA_ROME;
+ 		qcadev->bt_en = devm_gpiod_get(&serdev->dev, "enable",
+ 					       GPIOD_OUT_LOW);
+ 		if (IS_ERR(qcadev->bt_en)) {
+ 			dev_err(&serdev->dev, "failed to acquire enable gpio\n");
+ 			return PTR_ERR(qcadev->bt_en);
+ 		}
+ 
+ 		qcadev->susclk = devm_clk_get(&serdev->dev, NULL);
+ 		if (IS_ERR(qcadev->susclk)) {
+ 			dev_err(&serdev->dev, "failed to acquire clk\n");
+ 			return PTR_ERR(qcadev->susclk);
+ 		}
+ 
+ 		err = clk_set_rate(qcadev->susclk, SUSCLK_RATE_32KHZ);
+ 		if (err)
+ 			return err;
+ 
+ 		err = clk_prepare_enable(qcadev->susclk);
+ 		if (err)
+ 			return err;
+ 
+ 		err = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);
+ 		if (err) {
+ 			BT_ERR("Rome serdev registration failed");
+ 			clk_disable_unprepare(qcadev->susclk);
+ 			return err;
+ 		}
+ 	}
+ 
+ 	hdev = qcadev->serdev_hu.hdev;
+ 	set_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks);
+ 	hdev->shutdown = qca_power_off;
+ 
+ 	return 0;
++>>>>>>> ae563183b647 (Bluetooth: hci_qca: Enable power off/on support during hci down/up for QCA Rome)
  }
  
  static void qca_serdev_remove(struct serdev_device *serdev)
* Unmerged path drivers/bluetooth/hci_qca.c
