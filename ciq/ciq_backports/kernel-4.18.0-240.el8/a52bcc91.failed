net/smc: improve termination processing

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Karsten Graul <kgraul@linux.ibm.com>
commit a52bcc919b14c9d78f03b2b4ff604e5ca69c7e6d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a52bcc91.failed

Add helper smcr_lgr_link_deactivate_all() and eliminate duplicate code.
In smc_lgr_free(), clear the smc-r links before smc_lgr_free_bufs() is
called so buffers are already prepared for free. The usage of the soft
parameter in __smc_lgr_terminate() is no longer needed, smc_lgr_free()
can be called directly. smc_lgr_terminate_sched() and
smc_smcd_terminate() set lgr->freeing to indicate that the link group
will be freed soon to avoid unnecessary schedules of the free worker.

	Signed-off-by: Karsten Graul <kgraul@linux.ibm.com>
	Reviewed-by: Ursula Braun <ubraun@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a52bcc919b14c9d78f03b2b4ff604e5ca69c7e6d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/smc/smc_core.c
diff --cc net/smc/smc_core.c
index 399bc3ffb64e,fb391bc6781e..000000000000
--- a/net/smc/smc_core.c
+++ b/net/smc/smc_core.c
@@@ -226,18 -237,17 +226,32 @@@ void smc_lgr_cleanup_early(struct smc_c
  	smc_lgr_schedule_free_work_fast(lgr);
  }
  
++<<<<<<< HEAD
 +/* Send delete link, either as client to request the initiation
 + * of the DELETE LINK sequence from server; or as server to
 + * initiate the delete processing. See smc_llc_rx_delete_link().
 + */
 +static int smcr_link_send_delete(struct smc_link *lnk, bool orderly)
 +{
 +	if (lnk->state == SMC_LNK_ACTIVE &&
 +	    !smc_llc_send_delete_link(lnk, SMC_LLC_REQ, orderly)) {
 +		smc_llc_link_deleting(lnk);
 +		return 0;
 +	}
 +	return -ENOTCONN;
++=======
+ static void smcr_lgr_link_deactivate_all(struct smc_link_group *lgr)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {
+ 		struct smc_link *lnk = &lgr->lnk[i];
+ 
+ 		if (smc_link_usable(lnk))
+ 			lnk->state = SMC_LNK_INACTIVE;
+ 	}
+ 	wake_up_interruptible_all(&lgr->llc_waiter);
++>>>>>>> a52bcc919b14 (net/smc: improve termination processing)
  }
  
  static void smc_lgr_free(struct smc_link_group *lgr);
@@@ -288,16 -278,13 +301,21 @@@ static void smc_lgr_free_work(struct wo
  	spin_unlock_bh(lgr_lock);
  	cancel_delayed_work(&lgr->free_work);
  
 -	if (!lgr->is_smcd && !lgr->terminating)
 -		smc_llc_send_link_delete_all(lgr, true,
 -					     SMC_LLC_DEL_PROG_INIT_TERM);
  	if (lgr->is_smcd && !lgr->terminating)
  		smc_ism_signal_shutdown(lgr);
++<<<<<<< HEAD
 +	if (!lgr->is_smcd) {
 +		for (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {
 +			struct smc_link *lnk = &lgr->lnk[i];
 +
 +			if (lnk->state != SMC_LNK_INACTIVE)
 +				smc_llc_link_inactive(lnk);
 +		}
 +	}
++=======
+ 	if (!lgr->is_smcd)
+ 		smcr_lgr_link_deactivate_all(lgr);
++>>>>>>> a52bcc919b14 (net/smc: improve termination processing)
  	smc_lgr_free(lgr);
  }
  
@@@ -639,11 -826,6 +667,14 @@@ static void smc_lgr_free(struct smc_lin
  		if (!atomic_dec_return(&lgr->smcd->lgr_cnt))
  			wake_up(&lgr->smcd->lgrs_deleted);
  	} else {
++<<<<<<< HEAD
 +		for (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {
 +			if (lgr->lnk[i].state == SMC_LNK_INACTIVE)
 +				continue;
 +			smcr_link_clear(&lgr->lnk[i]);
 +		}
++=======
++>>>>>>> a52bcc919b14 (net/smc: improve termination processing)
  		if (!atomic_dec_return(&lgr_cnt))
  			wake_up(&lgrs_deleted);
  	}
@@@ -719,12 -886,12 +748,21 @@@ static void smc_lgr_cleanup(struct smc_
  		smc_ism_put_vlan(lgr->smcd, lgr->vlan_id);
  		put_device(&lgr->smcd->dev);
  	} else {
++<<<<<<< HEAD
 +		for (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {
 +			struct smc_link *lnk = &lgr->lnk[i];
 +
 +			if (lnk->state != SMC_LNK_INACTIVE)
 +				smc_llc_link_inactive(lnk);
 +		}
++=======
+ 		u32 rsn = lgr->llc_termination_rsn;
+ 
+ 		if (!rsn)
+ 			rsn = SMC_LLC_DEL_PROG_INIT_TERM;
+ 		smc_llc_send_link_delete_all(lgr, false, rsn);
+ 		smcr_lgr_link_deactivate_all(lgr);
++>>>>>>> a52bcc919b14 (net/smc: improve termination processing)
  	}
  }
  
@@@ -738,12 -907,9 +776,12 @@@ static void __smc_lgr_terminate(struct 
  
  	if (lgr->terminating)
  		return;	/* lgr already terminating */
- 	if (!soft)
- 		cancel_delayed_work_sync(&lgr->free_work);
+ 	/* cancel free_work sync, will terminate when lgr->freeing is set */
+ 	cancel_delayed_work_sync(&lgr->free_work);
  	lgr->terminating = 1;
 +	if (!lgr->is_smcd)
 +		for (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++)
 +			smc_llc_link_inactive(&lgr->lnk[i]);
  
  	/* kill remaining link group connections */
  	read_lock_bh(&lgr->conns_lock);
@@@ -762,17 -928,11 +800,14 @@@
  	}
  	read_unlock_bh(&lgr->conns_lock);
  	smc_lgr_cleanup(lgr);
- 	if (soft)
- 		smc_lgr_schedule_free_work_fast(lgr);
- 	else
- 		smc_lgr_free(lgr);
+ 	smc_lgr_free(lgr);
  }
  
 -/* unlink link group and schedule termination */
 -void smc_lgr_terminate_sched(struct smc_link_group *lgr)
 +/* unlink and terminate link group
 + * @soft: true if link group shutdown can take its time
 + *	  false if immediate link group shutdown is required
 + */
 +void smc_lgr_terminate(struct smc_link_group *lgr, bool soft)
  {
  	spinlock_t *lgr_lock;
  
@@@ -782,42 -942,10 +817,43 @@@
  		spin_unlock_bh(lgr_lock);
  		return;	/* lgr already terminating */
  	}
 +	if (!soft)
 +		lgr->freeing = 1;
  	list_del_init(&lgr->list);
+ 	lgr->freeing = 1;
  	spin_unlock_bh(lgr_lock);
 -	schedule_work(&lgr->terminate_work);
 +	__smc_lgr_terminate(lgr, soft);
 +}
 +
 +/* Called when IB port is terminated */
 +void smc_port_terminate(struct smc_ib_device *smcibdev, u8 ibport)
 +{
 +	struct smc_link_group *lgr, *l;
 +	LIST_HEAD(lgr_free_list);
 +	int i;
 +
 +	spin_lock_bh(&smc_lgr_list.lock);
 +	list_for_each_entry_safe(lgr, l, &smc_lgr_list.list, list) {
 +		if (lgr->is_smcd)
 +			continue;
 +		/* tbd - terminate only when no more links are active */
 +		for (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {
 +			if (lgr->lnk[i].state == SMC_LNK_INACTIVE ||
 +			    lgr->lnk[i].state == SMC_LNK_DELETING)
 +				continue;
 +			if (lgr->lnk[i].smcibdev == smcibdev &&
 +			    lgr->lnk[i].ibport == ibport) {
 +				list_move(&lgr->list, &lgr_free_list);
 +				lgr->freeing = 1;
 +			}
 +		}
 +	}
 +	spin_unlock_bh(&smc_lgr_list.lock);
 +
 +	list_for_each_entry_safe(lgr, l, &lgr_free_list, list) {
 +		list_del_init(&lgr->list);
 +		__smc_lgr_terminate(lgr, false);
 +	}
  }
  
  /* Called when peer lgr shutdown (regularly or abnormally) is received */
* Unmerged path net/smc/smc_core.c
