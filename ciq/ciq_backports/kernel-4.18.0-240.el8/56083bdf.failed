KVM: x86: check_nested_events is never NULL

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 56083bdf67c78030f11cdaed5b2b54959a329b02
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/56083bdf.failed

Both Intel and AMD now implement it, so there is no need to check if the
callback is implemented.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 56083bdf67c78030f11cdaed5b2b54959a329b02)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index bef07866f41a,0492baeb78ab..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -7622,8 -7699,8 +7622,13 @@@ static int inject_pending_event(struct 
  	 * from L2 to L1 due to pending L1 events which require exit
  	 * from L2 to L1.
  	 */
++<<<<<<< HEAD
 +	if (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {
 +		r = kvm_x86_ops->check_nested_events(vcpu);
++=======
+ 	if (is_guest_mode(vcpu)) {
+ 		r = kvm_x86_ops.check_nested_events(vcpu);
++>>>>>>> 56083bdf67c7 (KVM: x86: check_nested_events is never NULL)
  		if (r != 0)
  			return r;
  	}
@@@ -7684,8 -7761,8 +7689,13 @@@
  		 * proposal and current concerns.  Perhaps we should be setting
  		 * KVM_REQ_EVENT only on certain events and not unconditionally?
  		 */
++<<<<<<< HEAD
 +		if (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events) {
 +			r = kvm_x86_ops->check_nested_events(vcpu);
++=======
+ 		if (is_guest_mode(vcpu)) {
+ 			r = kvm_x86_ops.check_nested_events(vcpu);
++>>>>>>> 56083bdf67c7 (KVM: x86: check_nested_events is never NULL)
  			if (r != 0)
  				return r;
  		}
@@@ -8399,8 -8527,8 +8409,13 @@@ static inline int vcpu_block(struct kv
  
  static inline bool kvm_vcpu_running(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	if (is_guest_mode(vcpu) && kvm_x86_ops->check_nested_events)
 +		kvm_x86_ops->check_nested_events(vcpu);
++=======
+ 	if (is_guest_mode(vcpu))
+ 		kvm_x86_ops.check_nested_events(vcpu);
++>>>>>>> 56083bdf67c7 (KVM: x86: check_nested_events is never NULL)
  
  	return (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&
  		!vcpu->arch.apf.halted);
* Unmerged path arch/x86/kvm/x86.c
