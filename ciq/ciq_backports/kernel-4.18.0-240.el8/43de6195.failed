net: phylink: Add PHYLINK_DEV operation type

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ioana Ciornei <ioana.ciornei@nxp.com>
commit 43de61959b999279bafb031c0c9bdf0f6cd1c501
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/43de6195.failed

In the PHYLINK_DEV operation type, the PHYLINK infrastructure can work
without an attached net_device. For printing usecases, instead, a struct
device * should be passed to PHYLINK using the phylink_config structure.

Also, netif_carrier_* calls ar guarded by the presence of a valid
net_device. When using the PHYLINK_DEV operation type, we cannot check
link status using the netif_carrier_ok() API so instead, keep an
internal state of the MAC and call mac_link_{down,up} only when the link
changed.

	Signed-off-by: Ioana Ciornei <ioana.ciornei@nxp.com>
	Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 43de61959b999279bafb031c0c9bdf0f6cd1c501)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/phy/phylink.c
#	include/linux/phylink.h
diff --cc drivers/net/phy/phylink.c
index f51febdb1dc6,5f6120f3fa3f..000000000000
--- a/drivers/net/phy/phylink.c
+++ b/drivers/net/phy/phylink.c
@@@ -41,6 -41,9 +41,12 @@@ struct phylink 
  	/* private: */
  	struct net_device *netdev;
  	const struct phylink_mac_ops *ops;
++<<<<<<< HEAD
++=======
+ 	struct phylink_config *config;
+ 	struct device *dev;
+ 	unsigned int old_link_state:1;
++>>>>>>> 43de61959b99 (net: phylink: Add PHYLINK_DEV operation type)
  
  	unsigned long phylink_disable_state; /* bitmask of disables */
  	struct phy_device *phydev;
@@@ -400,6 -397,36 +406,39 @@@ static const char *phylink_pause_to_str
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void phylink_mac_link_up(struct phylink *pl,
+ 				struct phylink_link_state link_state)
+ {
+ 	struct net_device *ndev = pl->netdev;
+ 
+ 	pl->ops->mac_link_up(pl->config, pl->link_an_mode,
+ 			     pl->phy_state.interface,
+ 			     pl->phydev);
+ 
+ 	if (ndev)
+ 		netif_carrier_on(ndev);
+ 
+ 	netdev_info(ndev,
+ 		    "Link is Up - %s/%s - flow control %s\n",
+ 		    phy_speed_to_str(link_state.speed),
+ 		    phy_duplex_to_str(link_state.duplex),
+ 		    phylink_pause_to_str(link_state.pause));
+ }
+ 
+ static void phylink_mac_link_down(struct phylink *pl)
+ {
+ 	struct net_device *ndev = pl->netdev;
+ 
+ 	if (ndev)
+ 		netif_carrier_off(ndev);
+ 	pl->ops->mac_link_down(pl->config, pl->link_an_mode,
+ 			       pl->phy_state.interface);
+ 	netdev_info(ndev, "Link is Down\n");
+ }
+ 
++>>>>>>> 43de61959b99 (net: phylink: Add PHYLINK_DEV operation type)
  static void phylink_resolve(struct work_struct *w)
  {
  	struct phylink *pl = container_of(w, struct phylink, resolve);
@@@ -447,25 -475,17 +487,39 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	if (link_state.link != netif_carrier_ok(ndev)) {
 +		if (!link_state.link) {
 +			netif_carrier_off(ndev);
 +			pl->ops->mac_link_down(ndev, pl->link_an_mode,
 +					       pl->cur_interface);
 +			netdev_info(ndev, "Link is Down\n");
 +		} else {
 +			pl->cur_interface = link_state.interface;
 +			pl->ops->mac_link_up(ndev, pl->link_an_mode,
 +					     pl->cur_interface, pl->phydev);
 +
 +			netif_carrier_on(ndev);
 +
 +			netdev_info(ndev,
 +				    "Link is Up - %s/%s - flow control %s\n",
 +				    phy_speed_to_str(link_state.speed),
 +				    phy_duplex_to_str(link_state.duplex),
 +				    phylink_pause_to_str(link_state.pause));
 +		}
++=======
+ 	if (pl->netdev)
+ 		link_changed = (link_state.link != netif_carrier_ok(ndev));
+ 	else
+ 		link_changed = (link_state.link != pl->old_link_state);
+ 
+ 	if (link_changed) {
+ 		pl->old_link_state = link_state.link;
+ 		if (!link_state.link)
+ 			phylink_mac_link_down(pl);
+ 		else
+ 			phylink_mac_link_up(pl, link_state);
++>>>>>>> 43de61959b99 (net: phylink: Add PHYLINK_DEV operation type)
  	}
  	if (!link_state.link && pl->mac_link_dropped) {
  		pl->mac_link_dropped = false;
@@@ -557,7 -578,17 +611,21 @@@ struct phylink *phylink_create(struct n
  
  	mutex_init(&pl->state_mutex);
  	INIT_WORK(&pl->resolve, phylink_resolve);
++<<<<<<< HEAD
 +	pl->netdev = ndev;
++=======
+ 
+ 	pl->config = config;
+ 	if (config->type == PHYLINK_NETDEV) {
+ 		pl->netdev = to_net_dev(config->dev);
+ 	} else if (config->type == PHYLINK_DEV) {
+ 		pl->dev = config->dev;
+ 	} else {
+ 		kfree(pl);
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
++>>>>>>> 43de61959b99 (net: phylink: Add PHYLINK_DEV operation type)
  	pl->phy_state.interface = iface;
  	pl->link_interface = iface;
  	if (iface == PHY_INTERFACE_MODE_MOCA)
diff --cc include/linux/phylink.h
index 6411c624f63a,0f6f65bb9d44..000000000000
--- a/include/linux/phylink.h
+++ b/include/linux/phylink.h
@@@ -54,6 -54,21 +54,24 @@@ struct phylink_link_state 
  	unsigned int an_complete:1;
  };
  
++<<<<<<< HEAD
++=======
+ enum phylink_op_type {
+ 	PHYLINK_NETDEV = 0,
+ 	PHYLINK_DEV,
+ };
+ 
+ /**
+  * struct phylink_config - PHYLINK configuration structure
+  * @dev: a pointer to a struct device associated with the MAC
+  * @type: operation type of PHYLINK instance
+  */
+ struct phylink_config {
+ 	struct device *dev;
+ 	enum phylink_op_type type;
+ };
+ 
++>>>>>>> 43de61959b99 (net: phylink: Add PHYLINK_DEV operation type)
  /**
   * struct phylink_mac_ops - MAC operations structure.
   * @validate: Validate and update the link configuration.
* Unmerged path drivers/net/phy/phylink.c
* Unmerged path include/linux/phylink.h
