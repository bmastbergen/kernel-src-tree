pinctrl: baytrail: Keep pointer to struct device instead of its container

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 990ec243cb77c682e12bb84c98906880536132aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/990ec243.failed

There is no need to keep pointer to struct platform_device, which is container
of struct device, because the latter is what have been used everywhere outside
of ->probe() path. In any case we may derive pointer to the container when
needed.

	Acked-by: Hans de Goede <hdegoede@redhat.com>
	Acked-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
(cherry picked from commit 990ec243cb77c682e12bb84c98906880536132aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pinctrl/intel/pinctrl-baytrail.c
diff --cc drivers/pinctrl/intel/pinctrl-baytrail.c
index dbf8e5fd6a86,6e79138fc7f5..000000000000
--- a/drivers/pinctrl/intel/pinctrl-baytrail.c
+++ b/drivers/pinctrl/intel/pinctrl-baytrail.c
@@@ -114,8 -106,9 +114,13 @@@ struct byt_gpio_pin_context 
  	}
  
  struct byt_gpio {
+ 	struct device *dev;
  	struct gpio_chip chip;
++<<<<<<< HEAD
 +	struct platform_device *pdev;
++=======
+ 	struct irq_chip irqchip;
++>>>>>>> 990ec243cb77 (pinctrl: baytrail: Keep pointer to struct device instead of its container)
  	struct pinctrl_dev *pctl_dev;
  	struct pinctrl_desc pctl_desc;
  	const struct intel_pinctrl_soc_data *soc_data;
@@@ -1443,12 -1428,13 +1447,16 @@@ static void byt_gpio_irq_handler(struc
  	chip->irq_eoi(data);
  }
  
 -static void byt_init_irq_valid_mask(struct gpio_chip *chip,
 -				    unsigned long *valid_mask,
 -				    unsigned int ngpios)
 +static void byt_gpio_irq_init_hw(struct byt_gpio *vg)
  {
++<<<<<<< HEAD
 +	struct gpio_chip *gc = &vg->chip;
 +	struct device *dev = &vg->pdev->dev;
++=======
+ 	struct byt_gpio *vg = gpiochip_get_data(chip);
++>>>>>>> 990ec243cb77 (pinctrl: baytrail: Keep pointer to struct device instead of its container)
  	void __iomem *reg;
 -	u32 value;
 +	u32 base, value;
  	int i;
  
  	/*
@@@ -1469,13 -1455,20 +1477,18 @@@
  
  		value = readl(reg);
  		if (value & BYT_DIRECT_IRQ_EN) {
++<<<<<<< HEAD
 +			clear_bit(i, gc->irq.valid_mask);
 +			dev_dbg(dev, "excluding GPIO %d from IRQ domain\n", i);
++=======
+ 			clear_bit(i, valid_mask);
+ 			dev_dbg(vg->dev, "excluding GPIO %d from IRQ domain\n", i);
++>>>>>>> 990ec243cb77 (pinctrl: baytrail: Keep pointer to struct device instead of its container)
  		} else if ((value & BYT_PIN_MUX) == byt_get_gpio_mux(vg, i)) {
  			byt_gpio_clear_triggering(vg, i);
- 			dev_dbg(dev, "disabling GPIO %d\n", i);
+ 			dev_dbg(vg->dev, "disabling GPIO %d\n", i);
  		}
  	}
 -}
 -
 -static int byt_gpio_irq_init_hw(struct gpio_chip *chip)
 -{
 -	struct byt_gpio *vg = gpiochip_get_data(chip);
 -	void __iomem *reg;
 -	u32 base, value;
  
  	/* clear interrupt status trigger registers */
  	for (base = 0; base < vg->soc_data->npins; base += 32) {
@@@ -1525,19 -1521,46 +1539,51 @@@ static int byt_gpio_probe(struct byt_gp
  	gc->base	= -1;
  	gc->can_sleep	= false;
  	gc->add_pin_ranges = byt_gpio_add_pin_ranges;
- 	gc->parent	= &vg->pdev->dev;
+ 	gc->parent	= vg->dev;
  	gc->ngpio	= vg->soc_data->npins;
 +	gc->irq.need_valid_mask	= true;
  
  #ifdef CONFIG_PM_SLEEP
- 	vg->saved_context = devm_kcalloc(&vg->pdev->dev, gc->ngpio,
+ 	vg->saved_context = devm_kcalloc(vg->dev, gc->ngpio,
  				       sizeof(*vg->saved_context), GFP_KERNEL);
  	if (!vg->saved_context)
  		return -ENOMEM;
  #endif
++<<<<<<< HEAD
 +	ret = devm_gpiochip_add_data(&vg->pdev->dev, gc, vg);
++=======
+ 
+ 	/* set up interrupts  */
+ 	irq_rc = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+ 	if (irq_rc && irq_rc->start) {
+ 		struct gpio_irq_chip *girq;
+ 
+ 		vg->irqchip.name = "BYT-GPIO",
+ 		vg->irqchip.irq_ack = byt_irq_ack,
+ 		vg->irqchip.irq_mask = byt_irq_mask,
+ 		vg->irqchip.irq_unmask = byt_irq_unmask,
+ 		vg->irqchip.irq_set_type = byt_irq_type,
+ 		vg->irqchip.flags = IRQCHIP_SKIP_SET_WAKE,
+ 
+ 		girq = &gc->irq;
+ 		girq->chip = &vg->irqchip;
+ 		girq->init_hw = byt_gpio_irq_init_hw;
+ 		girq->init_valid_mask = byt_init_irq_valid_mask;
+ 		girq->parent_handler = byt_gpio_irq_handler;
+ 		girq->num_parents = 1;
+ 		girq->parents = devm_kcalloc(vg->dev, girq->num_parents,
+ 					     sizeof(*girq->parents), GFP_KERNEL);
+ 		if (!girq->parents)
+ 			return -ENOMEM;
+ 		girq->parents[0] = (unsigned int)irq_rc->start;
+ 		girq->default_type = IRQ_TYPE_NONE;
+ 		girq->handler = handle_bad_irq;
+ 	}
+ 
+ 	ret = devm_gpiochip_add_data(vg->dev, gc, vg);
++>>>>>>> 990ec243cb77 (pinctrl: baytrail: Keep pointer to struct device instead of its container)
  	if (ret) {
- 		dev_err(&vg->pdev->dev, "failed adding byt-gpio chip\n");
+ 		dev_err(vg->dev, "failed adding byt-gpio chip\n");
  		return ret;
  	}
  
* Unmerged path drivers/pinctrl/intel/pinctrl-baytrail.c
