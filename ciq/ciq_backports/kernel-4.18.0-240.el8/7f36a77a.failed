netdevsim: add all ports in nsim_dev_create() and del them in destroy()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Pirko <jiri@mellanox.com>
commit 7f36a77ade6eefc243c64c64b8f8252fa43ea55e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7f36a77a.failed

Currently the probe/remove function does this separately. Put the
addition an deletion of ports into nsim_dev_create() and
nsim_dev_destroy().

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Acked-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7f36a77ade6eefc243c64c64b8f8252fa43ea55e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/netdevsim/dev.c
diff --cc drivers/net/netdevsim/dev.c
index 863a10803cdb,3cc101aee991..000000000000
--- a/drivers/net/netdevsim/dev.c
+++ b/drivers/net/netdevsim/dev.c
@@@ -654,93 -603,6 +654,96 @@@ static const struct devlink_ops nsim_de
  #define NSIM_DEV_MAX_MACS_DEFAULT 32
  #define NSIM_DEV_TEST1_DEFAULT true
  
++<<<<<<< HEAD
 +static struct nsim_dev *
 +nsim_dev_create(struct nsim_bus_dev *nsim_bus_dev, unsigned int port_count)
 +{
 +	struct nsim_dev *nsim_dev;
 +	struct devlink *devlink;
 +	int err;
 +
 +	devlink = devlink_alloc(&nsim_dev_devlink_ops, sizeof(*nsim_dev));
 +	if (!devlink)
 +		return ERR_PTR(-ENOMEM);
 +	nsim_dev = devlink_priv(devlink);
 +	nsim_dev->nsim_bus_dev = nsim_bus_dev;
 +	nsim_dev->switch_id.id_len = sizeof(nsim_dev->switch_id.id);
 +	get_random_bytes(nsim_dev->switch_id.id, nsim_dev->switch_id.id_len);
 +	INIT_LIST_HEAD(&nsim_dev->port_list);
 +	mutex_init(&nsim_dev->port_list_lock);
 +	nsim_dev->fw_update_status = true;
 +	nsim_dev->max_macs = NSIM_DEV_MAX_MACS_DEFAULT;
 +	nsim_dev->test1 = NSIM_DEV_TEST1_DEFAULT;
 +
 +	err = nsim_dev_resources_register(devlink);
 +	if (err)
 +		goto err_devlink_free;
 +
 +	err = devlink_register(devlink, &nsim_bus_dev->dev);
 +	if (err)
 +		goto err_resources_unregister;
 +
 +	err = devlink_params_register(devlink, nsim_devlink_params,
 +				      ARRAY_SIZE(nsim_devlink_params));
 +	if (err)
 +		goto err_dl_unregister;
 +	nsim_devlink_set_params_init_values(nsim_dev, devlink);
 +
 +	err = nsim_dev_dummy_region_init(nsim_dev, devlink);
 +	if (err)
 +		goto err_params_unregister;
 +
 +	err = nsim_dev_traps_init(devlink);
 +	if (err)
 +		goto err_dummy_region_exit;
 +
 +	err = nsim_dev_debugfs_init(nsim_dev);
 +	if (err)
 +		goto err_traps_exit;
 +
 +	err = nsim_bpf_dev_init(nsim_dev);
 +	if (err)
 +		goto err_debugfs_exit;
 +
 +	devlink_params_publish(devlink);
 +	return nsim_dev;
 +
 +err_debugfs_exit:
 +	nsim_dev_debugfs_exit(nsim_dev);
 +err_traps_exit:
 +	nsim_dev_traps_exit(devlink);
 +err_dummy_region_exit:
 +	nsim_dev_dummy_region_exit(nsim_dev);
 +err_params_unregister:
 +	devlink_params_unregister(devlink, nsim_devlink_params,
 +				  ARRAY_SIZE(nsim_devlink_params));
 +err_dl_unregister:
 +	devlink_unregister(devlink);
 +err_resources_unregister:
 +	devlink_resources_unregister(devlink, NULL);
 +err_devlink_free:
 +	devlink_free(devlink);
 +	return ERR_PTR(err);
 +}
 +
 +static void nsim_dev_destroy(struct nsim_dev *nsim_dev)
 +{
 +	struct devlink *devlink = priv_to_devlink(nsim_dev);
 +
 +	nsim_bpf_dev_exit(nsim_dev);
 +	nsim_dev_debugfs_exit(nsim_dev);
 +	nsim_dev_traps_exit(devlink);
 +	nsim_dev_dummy_region_exit(nsim_dev);
 +	devlink_params_unregister(devlink, nsim_devlink_params,
 +				  ARRAY_SIZE(nsim_devlink_params));
 +	devlink_unregister(devlink);
 +	devlink_resources_unregister(devlink, NULL);
 +	mutex_destroy(&nsim_dev->port_list_lock);
 +	devlink_free(devlink);
 +}
 +
++=======
++>>>>>>> 7f36a77ade6e (netdevsim: add all ports in nsim_dev_create() and del them in destroy())
  static int __nsim_dev_port_add(struct nsim_dev *nsim_dev,
  			       unsigned int port_index)
  {
@@@ -807,22 -668,14 +810,25 @@@ static void nsim_dev_port_del_all(struc
  	list_for_each_entry_safe(nsim_dev_port, tmp,
  				 &nsim_dev->port_list, list)
  		__nsim_dev_port_del(nsim_dev_port);
 +	mutex_unlock(&nsim_dev->port_list_lock);
  }
  
- int nsim_dev_probe(struct nsim_bus_dev *nsim_bus_dev)
+ static int nsim_dev_port_add_all(struct nsim_dev *nsim_dev,
+ 				 unsigned int port_count)
  {
- 	struct nsim_dev *nsim_dev;
- 	int i;
- 	int err;
+ 	int i, err;
  
++<<<<<<< HEAD
 +	nsim_dev = nsim_dev_create(nsim_bus_dev, nsim_bus_dev->port_count);
 +	if (IS_ERR(nsim_dev))
 +		return PTR_ERR(nsim_dev);
 +	dev_set_drvdata(&nsim_bus_dev->dev, nsim_dev);
 +
 +	mutex_lock(&nsim_dev->port_list_lock);
 +	for (i = 0; i < nsim_bus_dev->port_count; i++) {
++=======
+ 	for (i = 0; i < port_count; i++) {
++>>>>>>> 7f36a77ade6e (netdevsim: add all ports in nsim_dev_create() and del them in destroy())
  		err = __nsim_dev_port_add(nsim_dev, i);
  		if (err)
  			goto err_port_del_all;
@@@ -831,9 -683,7 +837,8 @@@
  	return 0;
  
  err_port_del_all:
 +	mutex_unlock(&nsim_dev->port_list_lock);
  	nsim_dev_port_del_all(nsim_dev);
- 	nsim_dev_destroy(nsim_dev);
  	return err;
  }
  
* Unmerged path drivers/net/netdevsim/dev.c
