ixgbe: need_wakeup flag might not be set for Tx

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Magnus Karlsson <magnus.karlsson@intel.com>
commit 0843aa8f12edbd60e64e71f854eab2f452010eaa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0843aa8f.failed

The need_wakeup flag for Tx might not be set for AF_XDP sockets that
are only used to send packets. This happens if there is at least one
outstanding packet that has not been completed by the hardware and we
get that corresponding completion (which will not generate an
interrupt since interrupts are disabled in the napi poll loop) between
the time we stopped processing the Tx completions and interrupts are
enabled again. In this case, the need_wakeup flag will have been
cleared at the end of the Tx completion processing as we believe we
will get an interrupt from the outstanding completion at a later point
in time. But if this completion interrupt occurs before interrupts
are enable, we lose it and should at that point really have set the
need_wakeup flag since there are no more outstanding completions that
can generate an interrupt to continue the processing. When this
happens, user space will see a Tx queue need_wakeup of 0 and skip
issuing a syscall, which means will never get into the Tx processing
again and we have a deadlock.

This patch introduces a quick fix for this issue by just setting the
need_wakeup flag for Tx to 1 all the time. I am working on a proper
fix for this that will toggle the flag appropriately, but it is more
challenging than I anticipated and I am afraid that this patch will
not be completed before the merge window closes, therefore this easier
fix for now. This fix has a negative performance impact in the range
of 0% to 4%. Towards the higher end of the scale if you have driver
and application on the same core and issue a lot of packets, and
towards no negative impact if you use two cores, lower transmission
speeds and/or a workload that also receives packets.

	Signed-off-by: Magnus Karlsson <magnus.karlsson@intel.com>
	Tested-by: Andrew Bowers <andrewx.bowers@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 0843aa8f12edbd60e64e71f854eab2f452010eaa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c
index ca6f4a1b65b0,d6feaacfbf89..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c
@@@ -675,6 -689,9 +675,12 @@@ bool ixgbe_clean_xdp_tx_irq(struct ixgb
  	if (xsk_frames)
  		xsk_umem_complete_tx(umem, xsk_frames);
  
++<<<<<<< HEAD
++=======
+ 	if (xsk_umem_uses_need_wakeup(tx_ring->xsk_umem))
+ 		xsk_set_tx_need_wakeup(tx_ring->xsk_umem);
+ 
++>>>>>>> 0843aa8f12ed (ixgbe: need_wakeup flag might not be set for Tx)
  	return ixgbe_xmit_zc(tx_ring, q_vector->tx.work_limit);
  }
  
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c
