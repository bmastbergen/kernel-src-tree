EDAC/i10nm: Update driver to support different bus number config register offsets

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Qiuxu Zhuo <qiuxu.zhuo@intel.com>
commit ce20670828c1228ecd37befbdda87a1f87a803b9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ce206708.failed

The i10nm_edac driver failed to load on Ice Lake and Tremont/Jacobsville
servers if their CPU stepping >= 4 and failed on Ice Lake-D servers from
stepping 0. The root cause was that for Ice Lake and Tremont/Jacobsville
servers with CPU stepping >=4, the offset for bus number configuration
register was updated from 0xcc to 0xd0. For Ice Lake-D servers, all the
steppings use the updated 0xd0 offset.

Fix the issue by using the appropriate offset for bus number
configuration register according to the CPU model number and stepping.

	Reported-by: Jerry Chen <jerry.t.chen@intel.com>
Reported-and-tested-by: Jin Wen <wen.jin@intel.com>
	Signed-off-by: Qiuxu Zhuo <qiuxu.zhuo@intel.com>
	Signed-off-by: Tony Luck <tony.luck@intel.com>
	Reviewed-by: Borislav Petkov <bp@suse.de>
Link: https://lore.kernel.org/linux-edac/20200427084022.GC11036@zn.tnic
(cherry picked from commit ce20670828c1228ecd37befbdda87a1f87a803b9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/edac/i10nm_base.c
diff --cc drivers/edac/i10nm_base.c
index c370d5457e6b,a6bc54b02de4..000000000000
--- a/drivers/edac/i10nm_base.c
+++ b/drivers/edac/i10nm_base.c
@@@ -122,11 -122,23 +122,31 @@@ static int i10nm_get_all_munits(void
  	return 0;
  }
  
++<<<<<<< HEAD
 +static const struct x86_cpu_id i10nm_cpuids[] = {
 +	{ X86_VENDOR_INTEL, 6, INTEL_FAM6_ATOM_TREMONT_D, 0, 0 },
 +	{ X86_VENDOR_INTEL, 6, INTEL_FAM6_ICELAKE_X, 0, 0 },
 +	{ X86_VENDOR_INTEL, 6, INTEL_FAM6_ICELAKE_D, 0, 0 },
 +	{ }
++=======
+ static struct res_config i10nm_cfg0 = {
+ 	.type			= I10NM,
+ 	.decs_did		= 0x3452,
+ 	.busno_cfg_offset	= 0xcc,
+ };
+ 
+ static struct res_config i10nm_cfg1 = {
+ 	.type			= I10NM,
+ 	.decs_did		= 0x3452,
+ 	.busno_cfg_offset	= 0xd0,
+ };
+ 
+ static const struct x86_cpu_id i10nm_cpuids[] = {
+ 	X86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT_D,	&i10nm_cfg0),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_X,		&i10nm_cfg0),
+ 	X86_MATCH_INTEL_FAM6_MODEL(ICELAKE_D,		&i10nm_cfg1),
+ 	{}
++>>>>>>> ce20670828c1 (EDAC/i10nm: Update driver to support different bus number config register offsets)
  };
  MODULE_DEVICE_TABLE(x86cpu, i10nm_cpuids);
  
@@@ -250,6 -262,12 +270,15 @@@ static int __init i10nm_init(void
  	if (!id)
  		return -ENODEV;
  
++<<<<<<< HEAD
++=======
+ 	cfg = (struct res_config *)id->driver_data;
+ 
+ 	/* Newer steppings have different offset for ATOM_TREMONT_D/ICELAKE_X */
+ 	if (boot_cpu_data.x86_stepping >= 4)
+ 		cfg->busno_cfg_offset = 0xd0;
+ 
++>>>>>>> ce20670828c1 (EDAC/i10nm: Update driver to support different bus number config register offsets)
  	rc = skx_get_hi_lo(0x09a2, off, &tolm, &tohm);
  	if (rc)
  		return rc;
* Unmerged path drivers/edac/i10nm_base.c
