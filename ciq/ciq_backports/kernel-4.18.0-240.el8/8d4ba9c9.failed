KVM: PPC: Book3S HV: Don't push XIVE context when not using XIVE device

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paul Mackerras <paulus@ozlabs.org>
commit 8d4ba9c931bc384bcc6889a43915aaaf19d3e499
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8d4ba9c9.failed

At present, when running a guest on POWER9 using HV KVM but not using
an in-kernel interrupt controller (XICS or XIVE), for example if QEMU
is run with the kernel_irqchip=off option, the guest entry code goes
ahead and tries to load the guest context into the XIVE hardware, even
though no context has been set up.

To fix this, we check that the "CAM word" is non-zero before pushing
it to the hardware.  The CAM word is initialized to a non-zero value
in kvmppc_xive_connect_vcpu() and kvmppc_xive_native_connect_vcpu(),
and is now cleared in kvmppc_xive_{,native_}cleanup_vcpu.

Fixes: 5af50993850a ("KVM: PPC: Book3S HV: Native usage of the XIVE interrupt controller")
	Cc: stable@vger.kernel.org # v4.12+
	Reported-by: Cédric Le Goater <clg@kaod.org>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
	Reviewed-by: Cédric Le Goater <clg@kaod.org>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20190813100100.GC9567@blackberry
(cherry picked from commit 8d4ba9c931bc384bcc6889a43915aaaf19d3e499)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_xive.c
#	arch/powerpc/kvm/book3s_xive_native.c
diff --cc arch/powerpc/kvm/book3s_xive.c
index 42c4d9c2d39a,586867e46e51..000000000000
--- a/arch/powerpc/kvm/book3s_xive.c
+++ b/arch/powerpc/kvm/book3s_xive.c
@@@ -1150,7 -1147,18 +1156,22 @@@ void kvmppc_xive_cleanup_vcpu(struct kv
  			irq_dispose_mapping(xc->esc_virq[i]);
  			kfree(xc->esc_virq_names[i]);
  		}
++<<<<<<< HEAD
 +		/* Free the queue */
++=======
+ 	}
+ 
+ 	/* Disable the VP */
+ 	xive_native_disable_vp(xc->vp_id);
+ 
+ 	/* Clear the cam word so guest entry won't try to push context */
+ 	vcpu->arch.xive_cam_word = 0;
+ 
+ 	/* Free the queues */
+ 	for (i = 0; i < KVMPPC_XIVE_Q_COUNT; i++) {
+ 		struct xive_q *q = &xc->queues[i];
+ 
++>>>>>>> 8d4ba9c931bc (KVM: PPC: Book3S HV: Don't push XIVE context when not using XIVE device)
  		xive_native_disable_queue(xc->vp_id, q, i);
  		if (q->qpage) {
  			free_pages((unsigned long)q->qpage,
diff --cc arch/powerpc/kvm/book3s_xive_native.c
index e63cc40ef3c2,11b91b46fc39..000000000000
--- a/arch/powerpc/kvm/book3s_xive_native.c
+++ b/arch/powerpc/kvm/book3s_xive_native.c
@@@ -97,8 -76,16 +97,19 @@@ void kvmppc_xive_native_cleanup_vcpu(st
  			kfree(xc->esc_virq_names[i]);
  			xc->esc_virq[i] = 0;
  		}
 -	}
  
++<<<<<<< HEAD
 +		/* Free the queue */
++=======
+ 	/* Disable the VP */
+ 	xive_native_disable_vp(xc->vp_id);
+ 
+ 	/* Clear the cam word so guest entry won't try to push context */
+ 	vcpu->arch.xive_cam_word = 0;
+ 
+ 	/* Free the queues */
+ 	for (i = 0; i < KVMPPC_XIVE_Q_COUNT; i++) {
++>>>>>>> 8d4ba9c931bc (KVM: PPC: Book3S HV: Don't push XIVE context when not using XIVE device)
  		kvmppc_xive_native_cleanup_queue(vcpu, i);
  	}
  
diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S
index d3d0f4f1cdd1..838bca6710a9 100644
--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S
+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S
@@ -937,6 +937,8 @@ ALT_FTR_SECTION_END_IFCLR(CPU_FTR_ARCH_300)
 	ld	r11, VCPU_XIVE_SAVED_STATE(r4)
 	li	r9, TM_QW1_OS
 	lwz	r8, VCPU_XIVE_CAM_WORD(r4)
+	cmpwi	r8, 0
+	beq	no_xive
 	li	r7, TM_QW1_OS + TM_WORD2
 	mfmsr	r0
 	andi.	r0, r0, MSR_DR		/* in real mode? */
* Unmerged path arch/powerpc/kvm/book3s_xive.c
* Unmerged path arch/powerpc/kvm/book3s_xive_native.c
