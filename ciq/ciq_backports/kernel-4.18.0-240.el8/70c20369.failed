libperf: Add perf_evsel__alloc_id/perf_evsel__free_id functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit 70c20369ee95ef8b6887944194cfb74a5a8d1fe3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/70c20369.failed

Add perf_evsel__alloc_id()/perf_evsel__free_id() functions to libperf as
internal functions.

Move 'struct perf_sample_id' to internal/evsel.h header and change
'struct perf_sample_id::evsel' to 'struct perf_evsel' and the related
code that touches it.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lore.kernel.org/lkml/20190913132355.21634-28-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 70c20369ee95ef8b6887944194cfb74a5a8d1fe3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/lib/evsel.c
#	tools/perf/lib/include/internal/evsel.h
#	tools/perf/util/evlist.c
#	tools/perf/util/evsel.c
#	tools/perf/util/evsel.h
diff --cc tools/perf/util/evlist.c
index 29a998d183ce,559db38594a8..000000000000
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@@ -495,12 -469,12 +495,12 @@@ static void perf_evlist__id_hash(struc
  	struct perf_sample_id *sid = SID(evsel, cpu, thread);
  
  	sid->id = id;
- 	sid->evsel = evsel;
+ 	sid->evsel = &evsel->core;
  	hash = hash_64(sid->id, PERF_EVLIST__HLIST_BITS);
 -	hlist_add_head(&sid->node, &evlist->core.heads[hash]);
 +	hlist_add_head(&sid->node, &evlist->heads[hash]);
  }
  
 -void perf_evlist__id_add(struct evlist *evlist, struct evsel *evsel,
 +void perf_evlist__id_add(struct perf_evlist *evlist, struct perf_evsel *evsel,
  			 int cpu, int thread, u64 id)
  {
  	perf_evlist__id_hash(evlist, evsel, cpu, thread, id);
@@@ -1042,9 -1016,9 +1042,15 @@@ int perf_evlist__mmap_ex(struct perf_ev
  				   auxtrace_pages, auxtrace_overwrite);
  
  	evlist__for_each_entry(evlist, evsel) {
++<<<<<<< HEAD
 +		if ((evsel->attr.read_format & PERF_FORMAT_ID) &&
 +		    evsel->sample_id == NULL &&
 +		    perf_evsel__alloc_id(evsel, cpu_map__nr(cpus), threads->nr) < 0)
++=======
+ 		if ((evsel->core.attr.read_format & PERF_FORMAT_ID) &&
+ 		    evsel->core.sample_id == NULL &&
+ 		    perf_evsel__alloc_id(&evsel->core, perf_cpu_map__nr(cpus), threads->nr) < 0)
++>>>>>>> 70c20369ee95 (libperf: Add perf_evsel__alloc_id/perf_evsel__free_id functions)
  			return -ENOMEM;
  	}
  
diff --cc tools/perf/util/evsel.c
index 90bfc2303a40,a4a492f11849..000000000000
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@@ -1263,43 -1227,7 +1263,47 @@@ int perf_evsel__disable(struct perf_evs
  	return err;
  }
  
++<<<<<<< HEAD
 +int perf_evsel__alloc_id(struct perf_evsel *evsel, int ncpus, int nthreads)
 +{
 +	if (ncpus == 0 || nthreads == 0)
 +		return 0;
 +
 +	if (evsel->system_wide)
 +		nthreads = 1;
 +
 +	evsel->sample_id = xyarray__new(ncpus, nthreads, sizeof(struct perf_sample_id));
 +	if (evsel->sample_id == NULL)
 +		return -ENOMEM;
 +
 +	evsel->id = zalloc(ncpus * nthreads * sizeof(u64));
 +	if (evsel->id == NULL) {
 +		xyarray__delete(evsel->sample_id);
 +		evsel->sample_id = NULL;
 +		return -ENOMEM;
 +	}
 +
 +	return 0;
 +}
 +
 +static void perf_evsel__free_fd(struct perf_evsel *evsel)
 +{
 +	xyarray__delete(evsel->fd);
 +	evsel->fd = NULL;
 +}
 +
 +static void perf_evsel__free_id(struct perf_evsel *evsel)
 +{
 +	xyarray__delete(evsel->sample_id);
 +	evsel->sample_id = NULL;
 +	zfree(&evsel->id);
 +	evsel->ids = 0;
 +}
 +
 +static void perf_evsel__free_config_terms(struct perf_evsel *evsel)
++=======
+ static void perf_evsel__free_config_terms(struct evsel *evsel)
++>>>>>>> 70c20369ee95 (libperf: Add perf_evsel__alloc_id/perf_evsel__free_id functions)
  {
  	struct perf_evsel_config_term *term, *h;
  
@@@ -1309,29 -1237,18 +1313,34 @@@
  	}
  }
  
 -void perf_evsel__exit(struct evsel *evsel)
 +void perf_evsel__close_fd(struct perf_evsel *evsel)
 +{
 +	int cpu, thread;
 +
 +	for (cpu = 0; cpu < xyarray__max_x(evsel->fd); cpu++)
 +		for (thread = 0; thread < xyarray__max_y(evsel->fd); ++thread) {
 +			close(FD(evsel, cpu, thread));
 +			FD(evsel, cpu, thread) = -1;
 +		}
 +}
 +
 +void perf_evsel__exit(struct perf_evsel *evsel)
  {
 -	assert(list_empty(&evsel->core.node));
 +	assert(list_empty(&evsel->node));
  	assert(evsel->evlist == NULL);
  	perf_evsel__free_counts(evsel);
++<<<<<<< HEAD
 +	perf_evsel__free_fd(evsel);
 +	perf_evsel__free_id(evsel);
++=======
+ 	perf_evsel__free_fd(&evsel->core);
+ 	perf_evsel__free_id(&evsel->core);
++>>>>>>> 70c20369ee95 (libperf: Add perf_evsel__alloc_id/perf_evsel__free_id functions)
  	perf_evsel__free_config_terms(evsel);
  	cgroup__put(evsel->cgrp);
 -	perf_cpu_map__put(evsel->core.cpus);
 -	perf_cpu_map__put(evsel->core.own_cpus);
 -	perf_thread_map__put(evsel->core.threads);
 +	cpu_map__put(evsel->cpus);
 +	cpu_map__put(evsel->own_cpus);
 +	thread_map__put(evsel->threads);
  	zfree(&evsel->group_name);
  	zfree(&evsel->name);
  	perf_evsel__object.fini(evsel);
@@@ -2078,29 -1959,25 +2087,34 @@@ out_close
  	return err;
  }
  
 -void evsel__close(struct evsel *evsel)
 +void perf_evsel__close(struct perf_evsel *evsel)
  {
++<<<<<<< HEAD
 +	if (evsel->fd == NULL)
 +		return;
 +
 +	perf_evsel__close_fd(evsel);
 +	perf_evsel__free_fd(evsel);
 +	perf_evsel__free_id(evsel);
++=======
+ 	perf_evsel__close(&evsel->core);
+ 	perf_evsel__free_id(&evsel->core);
++>>>>>>> 70c20369ee95 (libperf: Add perf_evsel__alloc_id/perf_evsel__free_id functions)
  }
  
 -int perf_evsel__open_per_cpu(struct evsel *evsel,
 -			     struct perf_cpu_map *cpus)
 +int perf_evsel__open_per_cpu(struct perf_evsel *evsel,
 +			     struct cpu_map *cpus)
  {
 -	return evsel__open(evsel, cpus, NULL);
 +	return perf_evsel__open(evsel, cpus, NULL);
  }
  
 -int perf_evsel__open_per_thread(struct evsel *evsel,
 -				struct perf_thread_map *threads)
 +int perf_evsel__open_per_thread(struct perf_evsel *evsel,
 +				struct thread_map *threads)
  {
 -	return evsel__open(evsel, NULL, threads);
 +	return perf_evsel__open(evsel, NULL, threads);
  }
  
 -static int perf_evsel__parse_id_sample(const struct evsel *evsel,
 +static int perf_evsel__parse_id_sample(const struct perf_evsel *evsel,
  				       const union perf_event *event,
  				       struct perf_sample *sample)
  {
@@@ -3067,12 -2671,12 +3081,12 @@@ static int store_evsel_ids(struct perf_
  	return 0;
  }
  
 -int perf_evsel__store_ids(struct evsel *evsel, struct evlist *evlist)
 +int perf_evsel__store_ids(struct perf_evsel *evsel, struct perf_evlist *evlist)
  {
 -	struct perf_cpu_map *cpus = evsel->core.cpus;
 -	struct perf_thread_map *threads = evsel->core.threads;
 +	struct cpu_map *cpus = evsel->cpus;
 +	struct thread_map *threads = evsel->threads;
  
- 	if (perf_evsel__alloc_id(evsel, cpus->nr, threads->nr))
+ 	if (perf_evsel__alloc_id(&evsel->core, cpus->nr, threads->nr))
  		return -ENOMEM;
  
  	return store_evsel_ids(evsel, evlist);
diff --cc tools/perf/util/evsel.h
index fe84f1536094,a5b29ac10da0..000000000000
--- a/tools/perf/util/evsel.h
+++ b/tools/perf/util/evsel.h
@@@ -5,31 -5,18 +5,34 @@@
  #include <linux/list.h>
  #include <stdbool.h>
  #include <stdio.h>
 -#include <sys/types.h>
  #include <linux/perf_event.h>
  #include <linux/types.h>
 -#include <internal/evsel.h>
 -#include <perf/evsel.h>
 +#include "xyarray.h"
  #include "symbol_conf.h"
 -#include <internal/cpumap.h>
 +#include "cpumap.h"
 +#include "counts.h"
  
 -struct addr_location;
 -struct evsel;
 -union perf_event;
 +struct perf_evsel;
  
++<<<<<<< HEAD
 +/*
 + * Per fd, to map back from PERF_SAMPLE_ID to evsel, only used when there are
 + * more than one entry in the evlist.
 + */
 +struct perf_sample_id {
 +	struct hlist_node 	node;
 +	u64		 	id;
 +	struct perf_evsel	*evsel;
 +	int			idx;
 +	int			cpu;
 +	pid_t			tid;
 +
 +	/* Holds total ID period value for PERF_SAMPLE_READ processing. */
 +	u64			period;
 +};
 +
++=======
++>>>>>>> 70c20369ee95 (libperf: Add perf_evsel__alloc_id/perf_evsel__free_id functions)
  struct cgroup;
  
  /*
@@@ -266,17 -244,14 +269,21 @@@ extern const char *perf_evsel__hw_names
  extern const char *perf_evsel__sw_names[PERF_COUNT_SW_MAX];
  int __perf_evsel__hw_cache_type_op_res_name(u8 type, u8 op, u8 result,
  					    char *bf, size_t size);
 -const char *perf_evsel__name(struct evsel *evsel);
 +const char *perf_evsel__name(struct perf_evsel *evsel);
 +
 +const char *perf_evsel__group_name(struct perf_evsel *evsel);
 +int perf_evsel__group_desc(struct perf_evsel *evsel, char *buf, size_t size);
  
 -const char *perf_evsel__group_name(struct evsel *evsel);
 -int perf_evsel__group_desc(struct evsel *evsel, char *buf, size_t size);
++<<<<<<< HEAD
 +int perf_evsel__alloc_id(struct perf_evsel *evsel, int ncpus, int nthreads);
 +void perf_evsel__close_fd(struct perf_evsel *evsel);
  
 +void __perf_evsel__set_sample_bit(struct perf_evsel *evsel,
++=======
+ void __perf_evsel__set_sample_bit(struct evsel *evsel,
++>>>>>>> 70c20369ee95 (libperf: Add perf_evsel__alloc_id/perf_evsel__free_id functions)
  				  enum perf_event_sample_format bit);
 -void __perf_evsel__reset_sample_bit(struct evsel *evsel,
 +void __perf_evsel__reset_sample_bit(struct perf_evsel *evsel,
  				    enum perf_event_sample_format bit);
  
  #define perf_evsel__set_sample_bit(evsel, bit) \
* Unmerged path tools/perf/lib/evsel.c
* Unmerged path tools/perf/lib/include/internal/evsel.h
* Unmerged path tools/perf/lib/evsel.c
* Unmerged path tools/perf/lib/include/internal/evsel.h
diff --git a/tools/perf/tests/event_update.c b/tools/perf/tests/event_update.c
index 458ad9f8e8ad..5f399de14723 100644
--- a/tools/perf/tests/event_update.c
+++ b/tools/perf/tests/event_update.c
@@ -89,7 +89,7 @@ int test__event_update(struct test *test __maybe_unused, int subtest __maybe_unu
 	evsel = perf_evlist__first(evlist);
 
 	TEST_ASSERT_VAL("failed to allocate ids",
-			!perf_evsel__alloc_id(evsel, 1, 1));
+			!perf_evsel__alloc_id(&evsel->core, 1, 1));
 
 	perf_evlist__id_add(evlist, evsel, 0, 0, 123);
 
* Unmerged path tools/perf/util/evlist.c
* Unmerged path tools/perf/util/evsel.c
* Unmerged path tools/perf/util/evsel.h
diff --git a/tools/perf/util/header.c b/tools/perf/util/header.c
index 13489971ed57..36a18bf0f76e 100644
--- a/tools/perf/util/header.c
+++ b/tools/perf/util/header.c
@@ -3612,7 +3612,7 @@ int perf_session__read_header(struct perf_session *session)
 		 * for allocating the perf_sample_id table we fake 1 cpu and
 		 * hattr->ids threads.
 		 */
-		if (perf_evsel__alloc_id(evsel, 1, nr_ids))
+		if (perf_evsel__alloc_id(&evsel->core, 1, nr_ids))
 			goto out_delete_evlist;
 
 		lseek(fd, f_attr.ids.offset, SEEK_SET);
@@ -4046,7 +4046,7 @@ int perf_event__process_attr(struct perf_tool *tool __maybe_unused,
 	 * for allocating the perf_sample_id table we fake 1 cpu and
 	 * hattr->ids threads.
 	 */
-	if (perf_evsel__alloc_id(evsel, 1, n_ids))
+	if (perf_evsel__alloc_id(&evsel->core, 1, n_ids))
 		return -ENOMEM;
 
 	for (i = 0; i < n_ids; i++) {
diff --git a/tools/perf/util/session.c b/tools/perf/util/session.c
index 82adeb8dfbcf..c8f2ae268e26 100644
--- a/tools/perf/util/session.c
+++ b/tools/perf/util/session.c
@@ -1318,6 +1318,7 @@ static int deliver_sample_value(struct perf_evlist *evlist,
 				struct machine *machine)
 {
 	struct perf_sample_id *sid = perf_evlist__id2sid(evlist, v->id);
+	struct evsel *evsel;
 
 	if (sid) {
 		sample->id     = v->id;
@@ -1337,7 +1338,8 @@ static int deliver_sample_value(struct perf_evlist *evlist,
 	if (!sample->period)
 		return 0;
 
-	return tool->sample(tool, event, sample, sid->evsel, machine);
+	evsel = container_of(sid->evsel, struct evsel, core);
+	return tool->sample(tool, event, sample, evsel, machine);
 }
 
 static int deliver_sample_group(struct perf_evlist *evlist,
