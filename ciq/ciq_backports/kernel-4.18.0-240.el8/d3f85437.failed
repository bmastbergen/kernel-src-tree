perf evsel: Support PERF_SAMPLE_BRANCH_HW_INDEX

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Kan Liang <kan.liang@linux.intel.com>
commit d3f85437ad6a55113882d730beaa75759452da8f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d3f85437.failed

A new branch sample type PERF_SAMPLE_BRANCH_HW_INDEX has been introduced
in latest kernel.

Enable HW_INDEX by default in LBR call stack mode.

If kernel doesn't support the sample type, switching it off.

Add HW_INDEX in attr_fprintf as well. User can check whether the branch
sample type is set via debug information or header.

Committer testing:

First collect some samples with LBR callchains, system wide, for a few
seconds:

  # perf record --call-graph lbr -a sleep 5
  [ perf record: Woken up 1 times to write data ]
  [ perf record: Captured and wrote 0.625 MB perf.data (224 samples) ]
  #

Now lets use 'perf evlist -v' to look at the branch_sample_type:

  # perf evlist -v
  cycles: size: 120, { sample_period, sample_freq }: 4000, sample_type: IP|TID|TIME|CALLCHAIN|CPU|PERIOD|BRANCH_STACK, read_format: ID, disabled: 1, inherit: 1, mmap: 1, comm: 1, freq: 1, task: 1, precise_ip: 3, sample_id_all: 1, exclude_guest: 1, mmap2: 1, comm_exec: 1, ksymbol: 1, bpf_event: 1, branch_sample_type: USER|CALL_STACK|NO_FLAGS|NO_CYCLES|HW_INDEX
  #

So the machine has the kernel feature, and it was correctly added to
perf_event_attr.branch_sample_type, for the default 'cycles' event.

If we do it in another machine, where the kernel lacks the HW_INDEX
feature, we get:

  # perf record --call-graph lbr -a sleep 2s
  [ perf record: Woken up 1 times to write data ]
  [ perf record: Captured and wrote 1.690 MB perf.data (499 samples) ]
  # perf evlist -v
  cycles: size: 120, { sample_period, sample_freq }: 4000, sample_type: IP|TID|TIME|CALLCHAIN|CPU|PERIOD|BRANCH_STACK, read_format: ID, disabled: 1, inherit: 1, mmap: 1, comm: 1, freq: 1, task: 1, precise_ip: 3, sample_id_all: 1, exclude_guest: 1, mmap2: 1, comm_exec: 1, ksymbol: 1, bpf_event: 1, branch_sample_type: USER|CALL_STACK|NO_FLAGS|NO_CYCLES
  #

No HW_INDEX in attr.branch_sample_type.

	Signed-off-by: Kan Liang <kan.liang@linux.intel.com>
	Tested-by: Arnaldo Carvalho de Melo <acme@redhat.com>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Alexey Budankov <alexey.budankov@linux.intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Pavel Gerasimov <pavel.gerasimov@intel.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Ravi Bangoria <ravi.bangoria@linux.ibm.com>
	Cc: Stephane Eranian <eranian@google.com>
	Cc: Vitaly Slobodskoy <vitaly.slobodskoy@intel.com>
Link: http://lore.kernel.org/lkml/20200228163011.19358-3-kan.liang@linux.intel.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit d3f85437ad6a55113882d730beaa75759452da8f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/evsel.c
#	tools/perf/util/evsel.h
#	tools/perf/util/perf_event_attr_fprintf.c
diff --cc tools/perf/util/evsel.c
index c59d310d3797,816d930d774e..000000000000
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@@ -1889,25 -1663,27 +1891,33 @@@ fallback_missing_features
  	if (perf_missing_features.cloexec)
  		flags &= ~(unsigned long)PERF_FLAG_FD_CLOEXEC;
  	if (perf_missing_features.mmap2)
 -		evsel->core.attr.mmap2 = 0;
 +		evsel->attr.mmap2 = 0;
  	if (perf_missing_features.exclude_guest)
 -		evsel->core.attr.exclude_guest = evsel->core.attr.exclude_host = 0;
 +		evsel->attr.exclude_guest = evsel->attr.exclude_host = 0;
  	if (perf_missing_features.lbr_flags)
 -		evsel->core.attr.branch_sample_type &= ~(PERF_SAMPLE_BRANCH_NO_FLAGS |
 +		evsel->attr.branch_sample_type &= ~(PERF_SAMPLE_BRANCH_NO_FLAGS |
  				     PERF_SAMPLE_BRANCH_NO_CYCLES);
 -	if (perf_missing_features.group_read && evsel->core.attr.inherit)
 -		evsel->core.attr.read_format &= ~(PERF_FORMAT_GROUP|PERF_FORMAT_ID);
 +	if (perf_missing_features.group_read && evsel->attr.inherit)
 +		evsel->attr.read_format &= ~(PERF_FORMAT_GROUP|PERF_FORMAT_ID);
  	if (perf_missing_features.ksymbol)
++<<<<<<< HEAD
 +		evsel->attr.ksymbol = 0;
 +	if (perf_missing_features.bpf_event)
 +		evsel->attr.bpf_event = 0;
++=======
+ 		evsel->core.attr.ksymbol = 0;
+ 	if (perf_missing_features.bpf)
+ 		evsel->core.attr.bpf_event = 0;
+ 	if (perf_missing_features.branch_hw_idx)
+ 		evsel->core.attr.branch_sample_type &= ~PERF_SAMPLE_BRANCH_HW_INDEX;
++>>>>>>> d3f85437ad6a (perf evsel: Support PERF_SAMPLE_BRANCH_HW_INDEX)
  retry_sample_id:
  	if (perf_missing_features.sample_id_all)
 -		evsel->core.attr.sample_id_all = 0;
 +		evsel->attr.sample_id_all = 0;
  
 -	display_attr(&evsel->core.attr);
 +	display_attr(&evsel->attr);
  
 -	for (cpu = start_cpu; cpu < end_cpu; cpu++) {
 +	for (cpu = 0; cpu < cpus->nr; cpu++) {
  
  		for (thread = 0; thread < nthreads; thread++) {
  			int fd, group_fd;
@@@ -2012,25 -1788,34 +2022,40 @@@ try_fallback
  	 * Must probe features in the order they were added to the
  	 * perf_event_attr interface.
  	 */
++<<<<<<< HEAD
 +	if (!perf_missing_features.bpf_event && evsel->attr.bpf_event) {
 +		perf_missing_features.bpf_event = true;
 +		pr_debug2("switching off bpf_event\n");
++=======
+ 	if (!perf_missing_features.branch_hw_idx &&
+ 	    (evsel->core.attr.branch_sample_type & PERF_SAMPLE_BRANCH_HW_INDEX)) {
+ 		perf_missing_features.branch_hw_idx = true;
+ 		pr_debug2("switching off branch HW index support\n");
+ 		goto fallback_missing_features;
+ 	} else if (!perf_missing_features.aux_output && evsel->core.attr.aux_output) {
+ 		perf_missing_features.aux_output = true;
+ 		pr_debug2_peo("Kernel has no attr.aux_output support, bailing out\n");
+ 		goto out_close;
+ 	} else if (!perf_missing_features.bpf && evsel->core.attr.bpf_event) {
+ 		perf_missing_features.bpf = true;
+ 		pr_debug2_peo("switching off bpf_event\n");
++>>>>>>> d3f85437ad6a (perf evsel: Support PERF_SAMPLE_BRANCH_HW_INDEX)
  		goto fallback_missing_features;
 -	} else if (!perf_missing_features.ksymbol && evsel->core.attr.ksymbol) {
 +	} else if (!perf_missing_features.ksymbol && evsel->attr.ksymbol) {
  		perf_missing_features.ksymbol = true;
 -		pr_debug2_peo("switching off ksymbol\n");
 +		pr_debug2("switching off ksymbol\n");
  		goto fallback_missing_features;
 -	} else if (!perf_missing_features.write_backward && evsel->core.attr.write_backward) {
 +	} else if (!perf_missing_features.write_backward && evsel->attr.write_backward) {
  		perf_missing_features.write_backward = true;
 -		pr_debug2_peo("switching off write_backward\n");
 +		pr_debug2("switching off write_backward\n");
  		goto out_close;
 -	} else if (!perf_missing_features.clockid_wrong && evsel->core.attr.use_clockid) {
 +	} else if (!perf_missing_features.clockid_wrong && evsel->attr.use_clockid) {
  		perf_missing_features.clockid_wrong = true;
 -		pr_debug2_peo("switching off clockid\n");
 +		pr_debug2("switching off clockid\n");
  		goto fallback_missing_features;
 -	} else if (!perf_missing_features.clockid && evsel->core.attr.use_clockid) {
 +	} else if (!perf_missing_features.clockid && evsel->attr.use_clockid) {
  		perf_missing_features.clockid = true;
 -		pr_debug2_peo("switching off use_clockid\n");
 +		pr_debug2("switching off use_clockid\n");
  		goto fallback_missing_features;
  	} else if (!perf_missing_features.cloexec && (flags & PERF_FLAG_FD_CLOEXEC)) {
  		perf_missing_features.cloexec = true;
diff --cc tools/perf/util/evsel.h
index 2ab992b39a4c,33804740e2ca..000000000000
--- a/tools/perf/util/evsel.h
+++ b/tools/perf/util/evsel.h
@@@ -184,7 -117,9 +184,13 @@@ struct perf_missing_features 
  	bool write_backward;
  	bool group_read;
  	bool ksymbol;
++<<<<<<< HEAD
 +	bool bpf_event;
++=======
+ 	bool bpf;
+ 	bool aux_output;
+ 	bool branch_hw_idx;
++>>>>>>> d3f85437ad6a (perf evsel: Support PERF_SAMPLE_BRANCH_HW_INDEX)
  };
  
  extern struct perf_missing_features perf_missing_features;
* Unmerged path tools/perf/util/perf_event_attr_fprintf.c
* Unmerged path tools/perf/util/evsel.c
* Unmerged path tools/perf/util/evsel.h
* Unmerged path tools/perf/util/perf_event_attr_fprintf.c
