net/mlx5e: Change inline mode correctly when changing trust state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Maxim Mikityanskiy <maximmi@mellanox.com>
commit 6e0504c69811ae9df7e7e1284950befbe3e6f496
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/6e0504c6.failed

The current steps that are performed when the trust state changes, if
the channels are active:

1. The trust state is changed in hardware.

2. The new inline mode is calculated.

3. If the new inline mode is different, the channels are recreated using
the new inline mode.

This approach has some issues:

1. There is a time gap between changing trust state in hardware and
starting sending enough inline headers (the latter happens after
recreation of channels). It leads to failed transmissions and error
CQEs.

2. If the new channels fail to open, we'll be left with the old ones,
but the hardware will be configured for the new trust state, so the
interval when we can see TX errors never ends.

This patch fixes the issues above by moving the trust state change into
the preactivate hook that runs during the recreation of the channels
when no channels are active, so it eliminates the gap of partially
applied configuration. If the inline mode doesn't change with the change
of the trust state, the channels won't be recreated, just like before
this patch.

	Signed-off-by: Maxim Mikityanskiy <maximmi@mellanox.com>
	Reviewed-by: Tariq Toukan <tariqt@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 6e0504c69811ae9df7e7e1284950befbe3e6f496)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
index 01f2918063af,47874d34156b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
@@@ -1124,23 -1141,16 +1141,20 @@@ static int mlx5e_set_trust_state(struc
  	/* Skip if tx_min_inline is the same */
  	if (new_channels.params.tx_min_inline_mode ==
  	    priv->channels.params.tx_min_inline_mode)
- 		goto out;
+ 		reset_channels = false;
  
++<<<<<<< HEAD
 +	mlx5e_safe_switch_channels(priv, &new_channels, NULL);
++=======
+ 	if (reset_channels)
+ 		err = mlx5e_safe_switch_channels(priv, &new_channels,
+ 						 mlx5e_update_trust_state_hw,
+ 						 &trust_state);
+ 	else
+ 		err = mlx5e_update_trust_state_hw(priv, &trust_state);
++>>>>>>> 6e0504c69811 (net/mlx5e: Change inline mode correctly when changing trust state)
  
- out:
  	mutex_unlock(&priv->state_lock);
- }
- 
- static int mlx5e_set_trust_state(struct mlx5e_priv *priv, u8 trust_state)
- {
- 	int err;
- 
- 	err = mlx5_set_trust_state(priv->mdev, trust_state);
- 	if (err)
- 		return err;
- 	priv->dcbx_dp.trust_state = trust_state;
- 	mlx5e_trust_update_sq_inline_mode(priv);
  
  	return err;
  }
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/en_dcbnl.c
