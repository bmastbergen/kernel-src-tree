KVM: nVMX: Move reflection check into nested_vmx_reflect_vmexit()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 789afc5ccd4ef1374669f788c90a870d4e41074c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/789afc5c.failed

Move the call to nested_vmx_exit_reflected() from vmx_handle_exit() into
nested_vmx_reflect_vmexit() and change the semantics of the return value
for nested_vmx_reflect_vmexit() to indicate whether or not the exit was
reflected into L1.  nested_vmx_exit_reflected() and
nested_vmx_reflect_vmexit() are intrinsically tied together, calling one
without simultaneously calling the other makes little sense.

No functional change intended.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200415175519.14230-2-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 789afc5ccd4ef1374669f788c90a870d4e41074c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index dbadf7ce3b2f,d92ed73b22da..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -5970,8 -5891,23 +5970,28 @@@ static int vmx_handle_exit(struct kvm_v
  	if (vmx->emulation_required)
  		return handle_invalid_guest_state(vcpu);
  
++<<<<<<< HEAD
 +	if (is_guest_mode(vcpu) && nested_vmx_exit_reflected(vcpu, exit_reason))
 +		return nested_vmx_reflect_vmexit(vcpu, exit_reason);
++=======
+ 	if (is_guest_mode(vcpu)) {
+ 		/*
+ 		 * The host physical addresses of some pages of guest memory
+ 		 * are loaded into the vmcs02 (e.g. vmcs12's Virtual APIC
+ 		 * Page). The CPU may write to these pages via their host
+ 		 * physical address while L2 is running, bypassing any
+ 		 * address-translation-based dirty tracking (e.g. EPT write
+ 		 * protection).
+ 		 *
+ 		 * Mark them dirty on every exit from L2 to prevent them from
+ 		 * getting out of sync with dirty tracking.
+ 		 */
+ 		nested_mark_vmcs12_pages_dirty(vcpu);
+ 
+ 		if (nested_vmx_reflect_vmexit(vcpu, exit_reason))
+ 			return 1;
+ 	}
++>>>>>>> 789afc5ccd4e (KVM: nVMX: Move reflection check into nested_vmx_reflect_vmexit())
  
  	if (exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY) {
  		dump_vmcs();
diff --git a/arch/x86/kvm/vmx/nested.h b/arch/x86/kvm/vmx/nested.h
index 22c93a1e37fb..b62199dfc720 100644
--- a/arch/x86/kvm/vmx/nested.h
+++ b/arch/x86/kvm/vmx/nested.h
@@ -78,12 +78,16 @@ static inline bool nested_ept_ad_enabled(struct kvm_vcpu *vcpu)
 }
 
 /*
- * Reflect a VM Exit into L1.
+ * Conditionally reflect a VM-Exit into L1.  Returns %true if the VM-Exit was
+ * reflected into L1.
  */
-static inline int nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu,
-					    u32 exit_reason)
+static inline bool nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu,
+					     u32 exit_reason)
 {
-	u32 exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);
+	u32 exit_intr_info;
+
+	if (!nested_vmx_exit_reflected(vcpu, exit_reason))
+		return false;
 
 	/*
 	 * At this point, the exit interruption info in exit_intr_info
@@ -91,6 +95,8 @@ static inline int nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu,
 	 * we need to query the in-kernel LAPIC.
 	 */
 	WARN_ON(exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT);
+
+	exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);
 	if ((exit_intr_info &
 	     (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) ==
 	    (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) {
@@ -102,7 +108,7 @@ static inline int nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu,
 
 	nested_vmx_vmexit(vcpu, exit_reason, exit_intr_info,
 			  vmcs_readl(EXIT_QUALIFICATION));
-	return 1;
+	return true;
 }
 
 /*
* Unmerged path arch/x86/kvm/vmx/vmx.c
