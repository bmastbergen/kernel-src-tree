ASoC: SOF: Intel: byt: fixup topology filename for BYT-CR

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [sound] ALSA: ASoC: SOF: Intel: byt: fixup topology filename for BYT-CR (Jaroslav Kysela) [1797509]
Rebuild_FUZZ: 95.00%
commit-author Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
commit 2aae447a4c100d2a7b7cae26b1df8b329e730d8b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/2aae447a.failed

On Baytrail-CR, SSP0 needs to be used instead of SSP2.  The
substitution is assumed to be done in the topology file.

When Baytrail-CR is detected, add -ssp0 suffix to the topology file
name so that the topology code picks up the correct file.

Tested on Asus T100TAF

	Signed-off-by: Pierre-Louis Bossart <pierre-louis.bossart@linux.intel.com>
Link: https://lore.kernel.org/r/20191210004854.16845-8-pierre-louis.bossart@linux.intel.com
	Signed-off-by: Mark Brown <broonie@kernel.org>
(cherry picked from commit 2aae447a4c100d2a7b7cae26b1df8b329e730d8b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/soc/sof/intel/byt.c
diff --cc sound/soc/sof/intel/byt.c
index 92ef6a796fd5,ec6ca863243c..000000000000
--- a/sound/soc/sof/intel/byt.c
+++ b/sound/soc/sof/intel/byt.c
@@@ -17,6 -17,8 +17,11 @@@
  #include <sound/sof/xtensa.h>
  #include "../ops.h"
  #include "shim.h"
++<<<<<<< HEAD
++=======
+ #include "../sof-audio.h"
+ #include "../../intel/common/soc-intel-quirks.h"
++>>>>>>> 2aae447a4c10 (ASoC: SOF: Intel: byt: fixup topology filename for BYT-CR)
  
  /* DSP memories */
  #define IRAM_OFFSET		0x0C0000
@@@ -383,6 -384,76 +388,79 @@@ static int byt_reset(struct snd_sof_de
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static const char *fixup_tplg_name(struct snd_sof_dev *sdev,
+ 				   const char *sof_tplg_filename,
+ 				   const char *ssp_str)
+ {
+ 	const char *tplg_filename = NULL;
+ 	char *filename;
+ 	char *split_ext;
+ 
+ 	filename = devm_kstrdup(sdev->dev, sof_tplg_filename, GFP_KERNEL);
+ 	if (!filename)
+ 		return NULL;
+ 
+ 	/* this assumes a .tplg extension */
+ 	split_ext = strsep(&filename, ".");
+ 	if (split_ext) {
+ 		tplg_filename = devm_kasprintf(sdev->dev, GFP_KERNEL,
+ 					       "%s-%s.tplg",
+ 					       split_ext, ssp_str);
+ 		if (!tplg_filename)
+ 			return NULL;
+ 	}
+ 	return tplg_filename;
+ }
+ 
+ static void byt_machine_select(struct snd_sof_dev *sdev)
+ {
+ 	struct snd_sof_pdata *sof_pdata = sdev->pdata;
+ 	const struct sof_dev_desc *desc = sof_pdata->desc;
+ 	struct snd_soc_acpi_mach *mach;
+ 	struct platform_device *pdev;
+ 	const char *tplg_filename;
+ 
+ 	mach = snd_soc_acpi_find_machine(desc->machines);
+ 	if (!mach) {
+ 		dev_warn(sdev->dev, "warning: No matching ASoC machine driver found\n");
+ 		return;
+ 	}
+ 
+ 	pdev = to_platform_device(sdev->dev);
+ 	if (soc_intel_is_byt_cr(pdev)) {
+ 		dev_dbg(sdev->dev,
+ 			"BYT-CR detected, SSP0 used instead of SSP2\n");
+ 
+ 		tplg_filename = fixup_tplg_name(sdev,
+ 						mach->sof_tplg_filename,
+ 						"ssp0");
+ 	} else {
+ 		tplg_filename = mach->sof_tplg_filename;
+ 	}
+ 
+ 	if (!tplg_filename) {
+ 		dev_dbg(sdev->dev,
+ 			"error: no topology filename\n");
+ 		return;
+ 	}
+ 
+ 	sof_pdata->tplg_filename = tplg_filename;
+ 	mach->mach_params.acpi_ipc_irq_index = desc->irqindex_host_ipc;
+ 	sof_pdata->machine = mach;
+ }
+ 
+ static void byt_set_mach_params(const struct snd_soc_acpi_mach *mach,
+ 				struct device *dev)
+ {
+ 	struct snd_soc_acpi_mach_params *mach_params;
+ 
+ 	mach_params = (struct snd_soc_acpi_mach_params *)&mach->mach_params;
+ 	mach_params->platform = dev_name(dev);
+ }
+ 
++>>>>>>> 2aae447a4c10 (ASoC: SOF: Intel: byt: fixup topology filename for BYT-CR)
  /* Baytrail DAIs */
  static struct snd_soc_dai_driver byt_dai[] = {
  {
* Unmerged path sound/soc/sof/intel/byt.c
