Bluetooth: hci_qca: Update regulator_set_load() usage

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Bjorn Andersson <bjorn.andersson@linaro.org>
commit c29ff107e0bdf2911813dbae3e5808c5912cdff6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c29ff107.failed

Since the introduction of '5451781dadf8 ("regulator: core: Only count
load for enabled consumers")' in v5.0, the requested load of a regulator
consumer is only accounted for when said consumer is voted enabled.

So there's no need to vote for load ever time the regulator is
enabled or disabled.

	Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit c29ff107e0bdf2911813dbae3e5808c5912cdff6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/hci_qca.c
diff --cc drivers/bluetooth/hci_qca.c
index c7723b08787d,f7758def78b1..000000000000
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@@ -988,6 -1331,156 +988,159 @@@ static const struct hci_uart_proto qca_
  	.dequeue	= qca_dequeue,
  };
  
++<<<<<<< HEAD
++=======
+ static const struct qca_vreg_data qca_soc_data_wcn3990 = {
+ 	.soc_type = QCA_WCN3990,
+ 	.vregs = (struct qca_vreg []) {
+ 		{ "vddio",   1800000, 1900000,  15000  },
+ 		{ "vddxo",   1800000, 1900000,  80000  },
+ 		{ "vddrf",   1300000, 1350000,  300000 },
+ 		{ "vddch0",  3300000, 3400000,  450000 },
+ 	},
+ 	.num_vregs = 4,
+ };
+ 
+ static const struct qca_vreg_data qca_soc_data_wcn3998 = {
+ 	.soc_type = QCA_WCN3998,
+ 	.vregs = (struct qca_vreg []) {
+ 		{ "vddio",   1800000, 1900000,  10000  },
+ 		{ "vddxo",   1800000, 1900000,  80000  },
+ 		{ "vddrf",   1300000, 1352000,  300000 },
+ 		{ "vddch0",  3300000, 3300000,  450000 },
+ 	},
+ 	.num_vregs = 4,
+ };
+ 
+ static void qca_power_shutdown(struct hci_uart *hu)
+ {
+ 	struct qca_data *qca = hu->priv;
+ 	unsigned long flags;
+ 
+ 	/* From this point we go into power off state. But serial port is
+ 	 * still open, stop queueing the IBS data and flush all the buffered
+ 	 * data in skb's.
+ 	 */
+ 	spin_lock_irqsave(&qca->hci_ibs_lock, flags);
+ 	clear_bit(QCA_IBS_ENABLED, &qca->flags);
+ 	qca_flush(hu);
+ 	spin_unlock_irqrestore(&qca->hci_ibs_lock, flags);
+ 
+ 	host_set_baudrate(hu, 2400);
+ 	qca_send_power_pulse(hu, false);
+ 	qca_power_setup(hu, false);
+ }
+ 
+ static int qca_power_off(struct hci_dev *hdev)
+ {
+ 	struct hci_uart *hu = hci_get_drvdata(hdev);
+ 
+ 	/* Perform pre shutdown command */
+ 	qca_send_pre_shutdown_cmd(hdev);
+ 
+ 	usleep_range(8000, 10000);
+ 
+ 	qca_power_shutdown(hu);
+ 	return 0;
+ }
+ 
+ static int qca_enable_regulator(struct qca_vreg vregs,
+ 				struct regulator *regulator)
+ {
+ 	int ret;
+ 
+ 	ret = regulator_set_voltage(regulator, vregs.min_uV,
+ 				    vregs.max_uV);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return regulator_enable(regulator);
+ 
+ }
+ 
+ static void qca_disable_regulator(struct qca_vreg vregs,
+ 				  struct regulator *regulator)
+ {
+ 	regulator_disable(regulator);
+ 	regulator_set_voltage(regulator, 0, vregs.max_uV);
+ 
+ }
+ 
+ static int qca_power_setup(struct hci_uart *hu, bool on)
+ {
+ 	struct qca_vreg *vregs;
+ 	struct regulator_bulk_data *vreg_bulk;
+ 	struct qca_serdev *qcadev;
+ 	int i, num_vregs, ret = 0;
+ 
+ 	qcadev = serdev_device_get_drvdata(hu->serdev);
+ 	if (!qcadev || !qcadev->bt_power || !qcadev->bt_power->vreg_data ||
+ 	    !qcadev->bt_power->vreg_bulk)
+ 		return -EINVAL;
+ 
+ 	vregs = qcadev->bt_power->vreg_data->vregs;
+ 	vreg_bulk = qcadev->bt_power->vreg_bulk;
+ 	num_vregs = qcadev->bt_power->vreg_data->num_vregs;
+ 	BT_DBG("on: %d", on);
+ 	if (on && !qcadev->bt_power->vregs_on) {
+ 		for (i = 0; i < num_vregs; i++) {
+ 			ret = qca_enable_regulator(vregs[i],
+ 						   vreg_bulk[i].consumer);
+ 			if (ret)
+ 				break;
+ 		}
+ 
+ 		if (ret) {
+ 			BT_ERR("failed to enable regulator:%s", vregs[i].name);
+ 			/* turn off regulators which are enabled */
+ 			for (i = i - 1; i >= 0; i--)
+ 				qca_disable_regulator(vregs[i],
+ 						      vreg_bulk[i].consumer);
+ 		} else {
+ 			qcadev->bt_power->vregs_on = true;
+ 		}
+ 	} else if (!on && qcadev->bt_power->vregs_on) {
+ 		/* turn off regulator in reverse order */
+ 		i = qcadev->bt_power->vreg_data->num_vregs - 1;
+ 		for ( ; i >= 0; i--)
+ 			qca_disable_regulator(vregs[i], vreg_bulk[i].consumer);
+ 
+ 		qcadev->bt_power->vregs_on = false;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int qca_init_regulators(struct qca_power *qca,
+ 				const struct qca_vreg *vregs, size_t num_vregs)
+ {
+ 	struct regulator_bulk_data *bulk;
+ 	int ret;
+ 	int i;
+ 
+ 	bulk = devm_kcalloc(qca->dev, num_vregs, sizeof(*bulk), GFP_KERNEL);
+ 	if (!bulk)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < num_vregs; i++)
+ 		bulk[i].supply = vregs[i].name;
+ 
+ 	ret = devm_regulator_bulk_get(qca->dev, num_vregs, bulk);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	for (i = 0; i < num_vregs; i++) {
+ 		ret = regulator_set_load(bulk[i].consumer, vregs[i].load_uA);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	qca->vreg_bulk = bulk;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> c29ff107e0bd (Bluetooth: hci_qca: Update regulator_set_load() usage)
  static int qca_serdev_probe(struct serdev_device *serdev)
  {
  	struct qca_serdev *qcadev;
* Unmerged path drivers/bluetooth/hci_qca.c
