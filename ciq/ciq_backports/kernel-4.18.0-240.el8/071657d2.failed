netfilter: nft_masq: add inet support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 071657d2c38c54bf047cf2280fc96e4a3e8a91f2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/071657d2.failed

This allows use of a single masquerade rule in nat inet family
to handle both ipv4 and ipv6.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 071657d2c38c54bf047cf2280fc96e4a3e8a91f2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nft_masq.c
diff --cc net/netfilter/nft_masq.c
index 9d8655bc1bea,35a1794acf4c..000000000000
--- a/net/netfilter/nft_masq.c
+++ b/net/netfilter/nft_masq.c
@@@ -98,7 -102,219 +98,223 @@@ int nft_masq_dump(struct sk_buff *skb, 
  nla_put_failure:
  	return -1;
  }
++<<<<<<< HEAD
 +EXPORT_SYMBOL_GPL(nft_masq_dump);
++=======
+ 
+ static void nft_masq_ipv4_eval(const struct nft_expr *expr,
+ 			       struct nft_regs *regs,
+ 			       const struct nft_pktinfo *pkt)
+ {
+ 	struct nft_masq *priv = nft_expr_priv(expr);
+ 	struct nf_nat_range2 range;
+ 
+ 	memset(&range, 0, sizeof(range));
+ 	range.flags = priv->flags;
+ 	if (priv->sreg_proto_min) {
+ 		range.min_proto.all = (__force __be16)nft_reg_load16(
+ 			&regs->data[priv->sreg_proto_min]);
+ 		range.max_proto.all = (__force __be16)nft_reg_load16(
+ 			&regs->data[priv->sreg_proto_max]);
+ 	}
+ 	regs->verdict.code = nf_nat_masquerade_ipv4(pkt->skb, nft_hook(pkt),
+ 						    &range, nft_out(pkt));
+ }
+ 
+ static void
+ nft_masq_ipv4_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)
+ {
+ 	nf_ct_netns_put(ctx->net, NFPROTO_IPV4);
+ }
+ 
+ static struct nft_expr_type nft_masq_ipv4_type;
+ static const struct nft_expr_ops nft_masq_ipv4_ops = {
+ 	.type		= &nft_masq_ipv4_type,
+ 	.size		= NFT_EXPR_SIZE(sizeof(struct nft_masq)),
+ 	.eval		= nft_masq_ipv4_eval,
+ 	.init		= nft_masq_init,
+ 	.destroy	= nft_masq_ipv4_destroy,
+ 	.dump		= nft_masq_dump,
+ 	.validate	= nft_masq_validate,
+ };
+ 
+ static struct nft_expr_type nft_masq_ipv4_type __read_mostly = {
+ 	.family		= NFPROTO_IPV4,
+ 	.name		= "masq",
+ 	.ops		= &nft_masq_ipv4_ops,
+ 	.policy		= nft_masq_policy,
+ 	.maxattr	= NFTA_MASQ_MAX,
+ 	.owner		= THIS_MODULE,
+ };
+ 
+ #ifdef CONFIG_NF_TABLES_IPV6
+ static void nft_masq_ipv6_eval(const struct nft_expr *expr,
+ 			       struct nft_regs *regs,
+ 			       const struct nft_pktinfo *pkt)
+ {
+ 	struct nft_masq *priv = nft_expr_priv(expr);
+ 	struct nf_nat_range2 range;
+ 
+ 	memset(&range, 0, sizeof(range));
+ 	range.flags = priv->flags;
+ 	if (priv->sreg_proto_min) {
+ 		range.min_proto.all = (__force __be16)nft_reg_load16(
+ 			&regs->data[priv->sreg_proto_min]);
+ 		range.max_proto.all = (__force __be16)nft_reg_load16(
+ 			&regs->data[priv->sreg_proto_max]);
+ 	}
+ 	regs->verdict.code = nf_nat_masquerade_ipv6(pkt->skb, &range,
+ 						    nft_out(pkt));
+ }
+ 
+ static void
+ nft_masq_ipv6_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)
+ {
+ 	nf_ct_netns_put(ctx->net, NFPROTO_IPV6);
+ }
+ 
+ static struct nft_expr_type nft_masq_ipv6_type;
+ static const struct nft_expr_ops nft_masq_ipv6_ops = {
+ 	.type		= &nft_masq_ipv6_type,
+ 	.size		= NFT_EXPR_SIZE(sizeof(struct nft_masq)),
+ 	.eval		= nft_masq_ipv6_eval,
+ 	.init		= nft_masq_init,
+ 	.destroy	= nft_masq_ipv6_destroy,
+ 	.dump		= nft_masq_dump,
+ 	.validate	= nft_masq_validate,
+ };
+ 
+ static struct nft_expr_type nft_masq_ipv6_type __read_mostly = {
+ 	.family		= NFPROTO_IPV6,
+ 	.name		= "masq",
+ 	.ops		= &nft_masq_ipv6_ops,
+ 	.policy		= nft_masq_policy,
+ 	.maxattr	= NFTA_MASQ_MAX,
+ 	.owner		= THIS_MODULE,
+ };
+ 
+ static int __init nft_masq_module_init_ipv6(void)
+ {
+ 	int ret = nft_register_expr(&nft_masq_ipv6_type);
+ 
+ 	if (ret)
+ 		return ret;
+ 
+ 	ret = nf_nat_masquerade_ipv6_register_notifier();
+ 	if (ret < 0)
+ 		nft_unregister_expr(&nft_masq_ipv6_type);
+ 
+ 	return ret;
+ }
+ 
+ static void nft_masq_module_exit_ipv6(void)
+ {
+ 	nft_unregister_expr(&nft_masq_ipv6_type);
+ 	nf_nat_masquerade_ipv6_unregister_notifier();
+ }
+ #else
+ static inline int nft_masq_module_init_ipv6(void) { return 0; }
+ static inline void nft_masq_module_exit_ipv6(void) {}
+ #endif
+ 
+ #ifdef CONFIG_NF_TABLES_INET
+ static void nft_masq_inet_eval(const struct nft_expr *expr,
+ 			       struct nft_regs *regs,
+ 			       const struct nft_pktinfo *pkt)
+ {
+ 	switch (nft_pf(pkt)) {
+ 	case NFPROTO_IPV4:
+ 		return nft_masq_ipv4_eval(expr, regs, pkt);
+ 	case NFPROTO_IPV6:
+ 		return nft_masq_ipv6_eval(expr, regs, pkt);
+ 	}
+ 
+ 	WARN_ON_ONCE(1);
+ }
+ 
+ static void
+ nft_masq_inet_destroy(const struct nft_ctx *ctx, const struct nft_expr *expr)
+ {
+ 	nf_ct_netns_put(ctx->net, NFPROTO_INET);
+ }
+ 
+ static struct nft_expr_type nft_masq_inet_type;
+ static const struct nft_expr_ops nft_masq_inet_ops = {
+ 	.type		= &nft_masq_inet_type,
+ 	.size		= NFT_EXPR_SIZE(sizeof(struct nft_masq)),
+ 	.eval		= nft_masq_inet_eval,
+ 	.init		= nft_masq_init,
+ 	.destroy	= nft_masq_inet_destroy,
+ 	.dump		= nft_masq_dump,
+ 	.validate	= nft_masq_validate,
+ };
+ 
+ static struct nft_expr_type nft_masq_inet_type __read_mostly = {
+ 	.family		= NFPROTO_INET,
+ 	.name		= "masq",
+ 	.ops		= &nft_masq_inet_ops,
+ 	.policy		= nft_masq_policy,
+ 	.maxattr	= NFTA_MASQ_MAX,
+ 	.owner		= THIS_MODULE,
+ };
+ 
+ static int __init nft_masq_module_init_inet(void)
+ {
+ 	return nft_register_expr(&nft_masq_inet_type);
+ }
+ 
+ static void nft_masq_module_exit_inet(void)
+ {
+ 	nft_unregister_expr(&nft_masq_inet_type);
+ }
+ #else
+ static inline int nft_masq_module_init_inet(void) { return 0; }
+ static inline void nft_masq_module_exit_inet(void) {}
+ #endif
+ 
+ static int __init nft_masq_module_init(void)
+ {
+ 	int ret;
+ 
+ 	ret = nft_masq_module_init_ipv6();
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	ret = nft_masq_module_init_inet();
+ 	if (ret < 0) {
+ 		nft_masq_module_exit_ipv6();
+ 		return ret;
+ 	}
+ 
+ 	ret = nft_register_expr(&nft_masq_ipv4_type);
+ 	if (ret < 0) {
+ 		nft_masq_module_exit_inet();
+ 		nft_masq_module_exit_ipv6();
+ 		return ret;
+ 	}
+ 
+ 	ret = nf_nat_masquerade_ipv4_register_notifier();
+ 	if (ret < 0) {
+ 		nft_masq_module_exit_ipv6();
+ 		nft_masq_module_exit_inet();
+ 		nft_unregister_expr(&nft_masq_ipv4_type);
+ 		return ret;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static void __exit nft_masq_module_exit(void)
+ {
+ 	nft_masq_module_exit_ipv6();
+ 	nft_masq_module_exit_inet();
+ 	nft_unregister_expr(&nft_masq_ipv4_type);
+ 	nf_nat_masquerade_ipv4_unregister_notifier();
+ }
+ 
+ module_init(nft_masq_module_init);
+ module_exit(nft_masq_module_exit);
++>>>>>>> 071657d2c38c (netfilter: nft_masq: add inet support)
  
  MODULE_LICENSE("GPL");
  MODULE_AUTHOR("Arturo Borrero Gonzalez <arturo@debian.org>");
* Unmerged path net/netfilter/nft_masq.c
