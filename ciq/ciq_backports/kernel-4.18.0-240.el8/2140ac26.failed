net/smc: simplify link deactivation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Karsten Graul <kgraul@linux.ibm.com>
commit 2140ac26f8f501d3cc8f1575e6419f1a50779496
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/2140ac26.failed

Cancel the testlink worker during link clear processing and remove the
extra function smc_llc_link_inactive().

	Signed-off-by: Karsten Graul <kgraul@linux.ibm.com>
	Reviewed-by: Ursula Braun <ubraun@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2140ac26f8f501d3cc8f1575e6419f1a50779496)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/smc/smc_core.c
diff --cc net/smc/smc_core.c
index 9e33952db1df,78ccfbf6e4af..000000000000
--- a/net/smc/smc_core.c
+++ b/net/smc/smc_core.c
@@@ -258,8 -260,8 +258,13 @@@ static void smc_lgr_free_work(struct wo
  		for (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {
  			struct smc_link *lnk = &lgr->lnk[i];
  
++<<<<<<< HEAD
 +			if (lnk->state != SMC_LNK_INACTIVE)
 +				smc_llc_link_inactive(lnk);
++=======
+ 			if (smc_link_usable(lnk))
+ 				lnk->state = SMC_LNK_INACTIVE;
++>>>>>>> 2140ac26f8f5 (net/smc: simplify link deactivation)
  		}
  	}
  	smc_lgr_free(lgr);
@@@ -684,8 -691,8 +689,13 @@@ static void smc_lgr_cleanup(struct smc_
  		for (i = 0; i < SMC_LINKS_PER_LGR_MAX; i++) {
  			struct smc_link *lnk = &lgr->lnk[i];
  
++<<<<<<< HEAD
 +			if (lnk->state != SMC_LNK_INACTIVE)
 +				smc_llc_link_inactive(lnk);
++=======
+ 			if (smc_link_usable(lnk))
+ 				lnk->state = SMC_LNK_INACTIVE;
++>>>>>>> 2140ac26f8f5 (net/smc: simplify link deactivation)
  		}
  	}
  }
* Unmerged path net/smc/smc_core.c
diff --git a/net/smc/smc_llc.c b/net/smc/smc_llc.c
index 4119cdb6b6bf..4d425dc7f200 100644
--- a/net/smc/smc_llc.c
+++ b/net/smc/smc_llc.c
@@ -660,22 +660,15 @@ void smc_llc_link_deleting(struct smc_link *link)
 	smc_wr_wakeup_tx_wait(link);
 }
 
-/* called in tasklet context */
-void smc_llc_link_inactive(struct smc_link *link)
-{
-	if (link->state == SMC_LNK_INACTIVE)
-		return;
-	link->state = SMC_LNK_INACTIVE;
-	cancel_delayed_work_sync(&link->llc_testlink_wrk);
-	smc_wr_wakeup_reg_wait(link);
-	smc_wr_wakeup_tx_wait(link);
-}
-
 /* called in worker context */
 void smc_llc_link_clear(struct smc_link *link)
 {
 	flush_workqueue(link->llc_wq);
 	destroy_workqueue(link->llc_wq);
+	complete(&link->llc_testlink_resp);
+	cancel_delayed_work_sync(&link->llc_testlink_wrk);
+	smc_wr_wakeup_reg_wait(link);
+	smc_wr_wakeup_tx_wait(link);
 }
 
 /* register a new rtoken at the remote peer */
diff --git a/net/smc/smc_llc.h b/net/smc/smc_llc.h
index 461c0c3ef76e..4fa0a1fe3129 100644
--- a/net/smc/smc_llc.h
+++ b/net/smc/smc_llc.h
@@ -45,7 +45,6 @@ int smc_llc_send_delete_link(struct smc_link *link,
 int smc_llc_link_init(struct smc_link *link);
 void smc_llc_link_active(struct smc_link *link, int testlink_time);
 void smc_llc_link_deleting(struct smc_link *link);
-void smc_llc_link_inactive(struct smc_link *link);
 void smc_llc_link_clear(struct smc_link *link);
 int smc_llc_do_confirm_rkey(struct smc_link *link,
 			    struct smc_buf_desc *rmb_desc);
