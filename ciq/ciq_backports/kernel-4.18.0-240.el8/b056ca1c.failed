gpiolib: Introduce ->add_pin_ranges() callback

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit b056ca1c2f01b2d261c2dd6d167c17ac27977034
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b056ca1c.failed

When IRQ chip is being added by GPIO library, the ACPI based platform expects
GPIO <-> pin mapping ranges to be initialized in order to correctly initialize
ACPI event mechanism on affected platforms. Unfortunately this step is missed.

Introduce ->add_pin_ranges() callback to fill the above mentioned gap.

	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
	Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Reviewed-by: Hans de Goede <hdegoede@redhat.com>
	Tested-by: Hans de Goede <hdegoede@redhat.com>
(cherry picked from commit b056ca1c2f01b2d261c2dd6d167c17ac27977034)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/gpio/driver.h
diff --cc include/linux/gpio/driver.h
index 92cc189f3371,e2480ef94c55..000000000000
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@@ -173,6 -287,11 +173,14 @@@ static inline struct gpio_irq_chip *to_
   * @dbg_show: optional routine to show contents in debugfs; default code
   *	will be used when this is omitted, but custom code can show extra
   *	state (such as pullup/pulldown configuration).
++<<<<<<< HEAD
++=======
+  * @init_valid_mask: optional routine to initialize @valid_mask, to be used if
+  *	not all GPIOs are valid.
+  * @add_pin_ranges: optional routine to initialize pin ranges, to be used when
+  *	requires special mapping of the pins that provides GPIO functionality.
+  *	It is called after adding GPIO chip and before adding IRQ chip.
++>>>>>>> b056ca1c2f01 (gpiolib: Introduce ->add_pin_ranges() callback)
   * @base: identifies the first GPIO number handled by this chip;
   *	or, if negative during registration, requests dynamic ID allocation.
   *	DEPRECATION: providing anything non-negative and nailing the base
@@@ -254,6 -377,13 +262,16 @@@ struct gpio_chip 
  
  	void			(*dbg_show)(struct seq_file *s,
  						struct gpio_chip *chip);
++<<<<<<< HEAD
++=======
+ 
+ 	int			(*init_valid_mask)(struct gpio_chip *chip,
+ 						   unsigned long *valid_mask,
+ 						   unsigned int ngpios);
+ 
+ 	int			(*add_pin_ranges)(struct gpio_chip *chip);
+ 
++>>>>>>> b056ca1c2f01 (gpiolib: Introduce ->add_pin_ranges() callback)
  	int			base;
  	u16			ngpio;
  	const char		*const *names;
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index df0d87866af5..68bf8a0bf501 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -386,6 +386,14 @@ static void gpiochip_free_valid_mask(struct gpio_chip *gpiochip)
 	gpiochip->valid_mask = NULL;
 }
 
+static int gpiochip_add_pin_ranges(struct gpio_chip *gc)
+{
+	if (gc->add_pin_ranges)
+		return gc->add_pin_ranges(gc);
+
+	return 0;
+}
+
 bool gpiochip_line_is_valid(const struct gpio_chip *gpiochip,
 				unsigned int offset)
 {
@@ -1372,6 +1380,10 @@ int gpiochip_add_data_with_key(struct gpio_chip *chip, void *data,
 	if (status)
 		goto err_remove_chip;
 
+	ret = gpiochip_add_pin_ranges(chip);
+	if (ret)
+		goto err_remove_of_chip;
+
 	acpi_gpiochip_add(chip);
 
 	machine_gpiochip_add(chip);
* Unmerged path include/linux/gpio/driver.h
