netfilter: nat: move nlattr parse and xfrm session decode to core

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 096d09067a67702f9802e5b3a0fc2ea9c22f1cf6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/096d0906.failed

None of these functions calls any external functions, moving them allows
to avoid both the indirection and a need to export these symbols.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 096d09067a67702f9802e5b3a0fc2ea9c22f1cf6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
#	net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
diff --cc net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
index 78a67f961d86,36b4f9659ffa..000000000000
--- a/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
+++ b/net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
@@@ -28,56 -28,8 +28,59 @@@
  
  static const struct nf_nat_l3proto nf_nat_l3proto_ipv4;
  
++<<<<<<< HEAD
 +#ifdef CONFIG_XFRM
 +static void nf_nat_ipv4_decode_session(struct sk_buff *skb,
 +				       const struct nf_conn *ct,
 +				       enum ip_conntrack_dir dir,
 +				       unsigned long statusbit,
 +				       struct flowi *fl)
 +{
 +	const struct nf_conntrack_tuple *t = &ct->tuplehash[dir].tuple;
 +	struct flowi4 *fl4 = &fl->u.ip4;
 +
 +	if (ct->status & statusbit) {
 +		fl4->daddr = t->dst.u3.ip;
 +		if (t->dst.protonum == IPPROTO_TCP ||
 +		    t->dst.protonum == IPPROTO_UDP ||
 +		    t->dst.protonum == IPPROTO_UDPLITE ||
 +		    t->dst.protonum == IPPROTO_DCCP ||
 +		    t->dst.protonum == IPPROTO_SCTP)
 +			fl4->fl4_dport = t->dst.u.all;
 +	}
 +
 +	statusbit ^= IPS_NAT_MASK;
 +
 +	if (ct->status & statusbit) {
 +		fl4->saddr = t->src.u3.ip;
 +		if (t->dst.protonum == IPPROTO_TCP ||
 +		    t->dst.protonum == IPPROTO_UDP ||
 +		    t->dst.protonum == IPPROTO_UDPLITE ||
 +		    t->dst.protonum == IPPROTO_DCCP ||
 +		    t->dst.protonum == IPPROTO_SCTP)
 +			fl4->fl4_sport = t->src.u.all;
 +	}
 +}
 +#endif /* CONFIG_XFRM */
 +
 +static bool nf_nat_ipv4_in_range(const struct nf_conntrack_tuple *t,
 +				 const struct nf_nat_range2 *range)
 +{
 +	return ntohl(t->src.u3.ip) >= ntohl(range->min_addr.ip) &&
 +	       ntohl(t->src.u3.ip) <= ntohl(range->max_addr.ip);
 +}
 +
 +static u32 nf_nat_ipv4_secure_port(const struct nf_conntrack_tuple *t,
 +				   __be16 dport)
 +{
 +	return secure_ipv4_port_ephemeral(t->src.u3.ip, t->dst.u3.ip, dport);
 +}
 +
++=======
++>>>>>>> 096d09067a67 (netfilter: nat: move nlattr parse and xfrm session decode to core)
  static bool nf_nat_ipv4_manip_pkt(struct sk_buff *skb,
  				  unsigned int iphdroff,
 +				  const struct nf_nat_l4proto *l4proto,
  				  const struct nf_conntrack_tuple *target,
  				  enum nf_nat_manip_type maniptype)
  {
@@@ -141,28 -93,8 +144,10 @@@ static void nf_nat_ipv4_csum_recalc(str
  					 htons(oldlen), htons(datalen), true);
  }
  
- #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
- static int nf_nat_ipv4_nlattr_to_range(struct nlattr *tb[],
- 				       struct nf_nat_range2 *range)
- {
- 	if (tb[CTA_NAT_V4_MINIP]) {
- 		range->min_addr.ip = nla_get_be32(tb[CTA_NAT_V4_MINIP]);
- 		range->flags |= NF_NAT_RANGE_MAP_IPS;
- 	}
- 
- 	if (tb[CTA_NAT_V4_MAXIP])
- 		range->max_addr.ip = nla_get_be32(tb[CTA_NAT_V4_MAXIP]);
- 	else
- 		range->max_addr.ip = range->min_addr.ip;
- 
- 	return 0;
- }
- #endif
- 
  static const struct nf_nat_l3proto nf_nat_l3proto_ipv4 = {
  	.l3proto		= NFPROTO_IPV4,
 +	.in_range		= nf_nat_ipv4_in_range,
 +	.secure_port		= nf_nat_ipv4_secure_port,
  	.manip_pkt		= nf_nat_ipv4_manip_pkt,
  	.csum_update		= nf_nat_ipv4_csum_update,
  	.csum_recalc		= nf_nat_ipv4_csum_recalc,
diff --cc net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
index 9a3e0cf4290a,5d667cf9bab8..000000000000
--- a/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
+++ b/net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
@@@ -28,56 -28,8 +28,59 @@@
  
  static const struct nf_nat_l3proto nf_nat_l3proto_ipv6;
  
++<<<<<<< HEAD
 +#ifdef CONFIG_XFRM
 +static void nf_nat_ipv6_decode_session(struct sk_buff *skb,
 +				       const struct nf_conn *ct,
 +				       enum ip_conntrack_dir dir,
 +				       unsigned long statusbit,
 +				       struct flowi *fl)
 +{
 +	const struct nf_conntrack_tuple *t = &ct->tuplehash[dir].tuple;
 +	struct flowi6 *fl6 = &fl->u.ip6;
 +
 +	if (ct->status & statusbit) {
 +		fl6->daddr = t->dst.u3.in6;
 +		if (t->dst.protonum == IPPROTO_TCP ||
 +		    t->dst.protonum == IPPROTO_UDP ||
 +		    t->dst.protonum == IPPROTO_UDPLITE ||
 +		    t->dst.protonum == IPPROTO_DCCP ||
 +		    t->dst.protonum == IPPROTO_SCTP)
 +			fl6->fl6_dport = t->dst.u.all;
 +	}
 +
 +	statusbit ^= IPS_NAT_MASK;
 +
 +	if (ct->status & statusbit) {
 +		fl6->saddr = t->src.u3.in6;
 +		if (t->dst.protonum == IPPROTO_TCP ||
 +		    t->dst.protonum == IPPROTO_UDP ||
 +		    t->dst.protonum == IPPROTO_UDPLITE ||
 +		    t->dst.protonum == IPPROTO_DCCP ||
 +		    t->dst.protonum == IPPROTO_SCTP)
 +			fl6->fl6_sport = t->src.u.all;
 +	}
 +}
 +#endif
 +
 +static bool nf_nat_ipv6_in_range(const struct nf_conntrack_tuple *t,
 +				 const struct nf_nat_range2 *range)
 +{
 +	return ipv6_addr_cmp(&t->src.u3.in6, &range->min_addr.in6) >= 0 &&
 +	       ipv6_addr_cmp(&t->src.u3.in6, &range->max_addr.in6) <= 0;
 +}
 +
 +static u32 nf_nat_ipv6_secure_port(const struct nf_conntrack_tuple *t,
 +				   __be16 dport)
 +{
 +	return secure_ipv6_port_ephemeral(t->src.u3.ip6, t->dst.u3.ip6, dport);
 +}
 +
++=======
++>>>>>>> 096d09067a67 (netfilter: nat: move nlattr parse and xfrm session decode to core)
  static bool nf_nat_ipv6_manip_pkt(struct sk_buff *skb,
  				  unsigned int iphdroff,
 +				  const struct nf_nat_l4proto *l4proto,
  				  const struct nf_conntrack_tuple *target,
  				  enum nf_nat_manip_type maniptype)
  {
@@@ -150,30 -102,8 +153,10 @@@ static void nf_nat_ipv6_csum_recalc(str
  					 htons(oldlen), htons(datalen), true);
  }
  
- #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
- static int nf_nat_ipv6_nlattr_to_range(struct nlattr *tb[],
- 				       struct nf_nat_range2 *range)
- {
- 	if (tb[CTA_NAT_V6_MINIP]) {
- 		nla_memcpy(&range->min_addr.ip6, tb[CTA_NAT_V6_MINIP],
- 			   sizeof(struct in6_addr));
- 		range->flags |= NF_NAT_RANGE_MAP_IPS;
- 	}
- 
- 	if (tb[CTA_NAT_V6_MAXIP])
- 		nla_memcpy(&range->max_addr.ip6, tb[CTA_NAT_V6_MAXIP],
- 			   sizeof(struct in6_addr));
- 	else
- 		range->max_addr = range->min_addr;
- 
- 	return 0;
- }
- #endif
- 
  static const struct nf_nat_l3proto nf_nat_l3proto_ipv6 = {
  	.l3proto		= NFPROTO_IPV6,
 +	.secure_port		= nf_nat_ipv6_secure_port,
 +	.in_range		= nf_nat_ipv6_in_range,
  	.manip_pkt		= nf_nat_ipv6_manip_pkt,
  	.csum_update		= nf_nat_ipv6_csum_update,
  	.csum_recalc		= nf_nat_ipv6_csum_recalc,
diff --git a/include/net/netfilter/nf_nat_l3proto.h b/include/net/netfilter/nf_nat_l3proto.h
index d300b8f03972..0777bc052057 100644
--- a/include/net/netfilter/nf_nat_l3proto.h
+++ b/include/net/netfilter/nf_nat_l3proto.h
@@ -25,15 +25,6 @@ struct nf_nat_l3proto {
 	void	(*csum_recalc)(struct sk_buff *skb, u8 proto,
 			       void *data, __sum16 *check,
 			       int datalen, int oldlen);
-
-	void	(*decode_session)(struct sk_buff *skb,
-				  const struct nf_conn *ct,
-				  enum ip_conntrack_dir dir,
-				  unsigned long statusbit,
-				  struct flowi *fl);
-
-	int	(*nlattr_to_range)(struct nlattr *tb[],
-				   struct nf_nat_range2 *range);
 };
 
 int nf_nat_l3proto_register(const struct nf_nat_l3proto *);
* Unmerged path net/ipv4/netfilter/nf_nat_l3proto_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_nat_l3proto_ipv6.c
diff --git a/net/netfilter/nf_nat_core.c b/net/netfilter/nf_nat_core.c
index 275265d75be2..3135f3a524f1 100644
--- a/net/netfilter/nf_nat_core.c
+++ b/net/netfilter/nf_nat_core.c
@@ -76,9 +76,74 @@ __nf_nat_l4proto_find(u8 family, u8 protonum)
 EXPORT_SYMBOL_GPL(__nf_nat_l4proto_find);
 
 #ifdef CONFIG_XFRM
+static void nf_nat_ipv4_decode_session(struct sk_buff *skb,
+				       const struct nf_conn *ct,
+				       enum ip_conntrack_dir dir,
+				       unsigned long statusbit,
+				       struct flowi *fl)
+{
+	const struct nf_conntrack_tuple *t = &ct->tuplehash[dir].tuple;
+	struct flowi4 *fl4 = &fl->u.ip4;
+
+	if (ct->status & statusbit) {
+		fl4->daddr = t->dst.u3.ip;
+		if (t->dst.protonum == IPPROTO_TCP ||
+		    t->dst.protonum == IPPROTO_UDP ||
+		    t->dst.protonum == IPPROTO_UDPLITE ||
+		    t->dst.protonum == IPPROTO_DCCP ||
+		    t->dst.protonum == IPPROTO_SCTP)
+			fl4->fl4_dport = t->dst.u.all;
+	}
+
+	statusbit ^= IPS_NAT_MASK;
+
+	if (ct->status & statusbit) {
+		fl4->saddr = t->src.u3.ip;
+		if (t->dst.protonum == IPPROTO_TCP ||
+		    t->dst.protonum == IPPROTO_UDP ||
+		    t->dst.protonum == IPPROTO_UDPLITE ||
+		    t->dst.protonum == IPPROTO_DCCP ||
+		    t->dst.protonum == IPPROTO_SCTP)
+			fl4->fl4_sport = t->src.u.all;
+	}
+}
+
+static void nf_nat_ipv6_decode_session(struct sk_buff *skb,
+				       const struct nf_conn *ct,
+				       enum ip_conntrack_dir dir,
+				       unsigned long statusbit,
+				       struct flowi *fl)
+{
+#if IS_ENABLED(CONFIG_IPV6)
+	const struct nf_conntrack_tuple *t = &ct->tuplehash[dir].tuple;
+	struct flowi6 *fl6 = &fl->u.ip6;
+
+	if (ct->status & statusbit) {
+		fl6->daddr = t->dst.u3.in6;
+		if (t->dst.protonum == IPPROTO_TCP ||
+		    t->dst.protonum == IPPROTO_UDP ||
+		    t->dst.protonum == IPPROTO_UDPLITE ||
+		    t->dst.protonum == IPPROTO_DCCP ||
+		    t->dst.protonum == IPPROTO_SCTP)
+			fl6->fl6_dport = t->dst.u.all;
+	}
+
+	statusbit ^= IPS_NAT_MASK;
+
+	if (ct->status & statusbit) {
+		fl6->saddr = t->src.u3.in6;
+		if (t->dst.protonum == IPPROTO_TCP ||
+		    t->dst.protonum == IPPROTO_UDP ||
+		    t->dst.protonum == IPPROTO_UDPLITE ||
+		    t->dst.protonum == IPPROTO_DCCP ||
+		    t->dst.protonum == IPPROTO_SCTP)
+			fl6->fl6_sport = t->src.u.all;
+	}
+#endif
+}
+
 static void __nf_nat_decode_session(struct sk_buff *skb, struct flowi *fl)
 {
-	const struct nf_nat_l3proto *l3proto;
 	const struct nf_conn *ct;
 	enum ip_conntrack_info ctinfo;
 	enum ip_conntrack_dir dir;
@@ -90,17 +155,20 @@ static void __nf_nat_decode_session(struct sk_buff *skb, struct flowi *fl)
 		return;
 
 	family = nf_ct_l3num(ct);
-	l3proto = __nf_nat_l3proto_find(family);
-	if (l3proto == NULL)
-		return;
-
 	dir = CTINFO2DIR(ctinfo);
 	if (dir == IP_CT_DIR_ORIGINAL)
 		statusbit = IPS_DST_NAT;
 	else
 		statusbit = IPS_SRC_NAT;
 
-	l3proto->decode_session(skb, ct, dir, statusbit, fl);
+	switch (family) {
+	case NFPROTO_IPV4:
+		nf_nat_ipv4_decode_session(skb, ct, dir, statusbit, fl);
+		return;
+	case NFPROTO_IPV6:
+		nf_nat_ipv6_decode_session(skb, ct, dir, statusbit, fl);
+		return;
+	}
 }
 
 int nf_xfrm_me_harder(struct net *net, struct sk_buff *skb, unsigned int family)
@@ -837,10 +905,43 @@ static const struct nla_policy nat_nla_policy[CTA_NAT_MAX+1] = {
 	[CTA_NAT_PROTO]		= { .type = NLA_NESTED },
 };
 
+static int nf_nat_ipv4_nlattr_to_range(struct nlattr *tb[],
+				       struct nf_nat_range2 *range)
+{
+	if (tb[CTA_NAT_V4_MINIP]) {
+		range->min_addr.ip = nla_get_be32(tb[CTA_NAT_V4_MINIP]);
+		range->flags |= NF_NAT_RANGE_MAP_IPS;
+	}
+
+	if (tb[CTA_NAT_V4_MAXIP])
+		range->max_addr.ip = nla_get_be32(tb[CTA_NAT_V4_MAXIP]);
+	else
+		range->max_addr.ip = range->min_addr.ip;
+
+	return 0;
+}
+
+static int nf_nat_ipv6_nlattr_to_range(struct nlattr *tb[],
+				       struct nf_nat_range2 *range)
+{
+	if (tb[CTA_NAT_V6_MINIP]) {
+		nla_memcpy(&range->min_addr.ip6, tb[CTA_NAT_V6_MINIP],
+			   sizeof(struct in6_addr));
+		range->flags |= NF_NAT_RANGE_MAP_IPS;
+	}
+
+	if (tb[CTA_NAT_V6_MAXIP])
+		nla_memcpy(&range->max_addr.ip6, tb[CTA_NAT_V6_MAXIP],
+			   sizeof(struct in6_addr));
+	else
+		range->max_addr = range->min_addr;
+
+	return 0;
+}
+
 static int
 nfnetlink_parse_nat(const struct nlattr *nat,
-		    const struct nf_conn *ct, struct nf_nat_range2 *range,
-		    const struct nf_nat_l3proto *l3proto)
+		    const struct nf_conn *ct, struct nf_nat_range2 *range)
 {
 	struct nlattr *tb[CTA_NAT_MAX+1];
 	int err;
@@ -852,8 +953,19 @@ nfnetlink_parse_nat(const struct nlattr *nat,
 	if (err < 0)
 		return err;
 
-	err = l3proto->nlattr_to_range(tb, range);
-	if (err < 0)
+	switch (nf_ct_l3num(ct)) {
+	case NFPROTO_IPV4:
+		err = nf_nat_ipv4_nlattr_to_range(tb, range);
+		break;
+	case NFPROTO_IPV6:
+		err = nf_nat_ipv6_nlattr_to_range(tb, range);
+		break;
+	default:
+		err = -EPROTONOSUPPORT;
+		break;
+	}
+
+	if (err)
 		return err;
 
 	if (!tb[CTA_NAT_PROTO])
@@ -869,7 +981,6 @@ nfnetlink_parse_nat_setup(struct nf_conn *ct,
 			  const struct nlattr *attr)
 {
 	struct nf_nat_range2 range;
-	const struct nf_nat_l3proto *l3proto;
 	int err;
 
 	/* Should not happen, restricted to creating new conntracks
@@ -878,18 +989,11 @@ nfnetlink_parse_nat_setup(struct nf_conn *ct,
 	if (WARN_ON_ONCE(nf_nat_initialized(ct, manip)))
 		return -EEXIST;
 
-	/* Make sure that L3 NAT is there by when we call nf_nat_setup_info to
-	 * attach the null binding, otherwise this may oops.
-	 */
-	l3proto = __nf_nat_l3proto_find(nf_ct_l3num(ct));
-	if (l3proto == NULL)
-		return -EAGAIN;
-
 	/* No NAT information has been passed, allocate the null-binding */
 	if (attr == NULL)
 		return __nf_nat_alloc_null_binding(ct, manip) == NF_DROP ? -ENOMEM : 0;
 
-	err = nfnetlink_parse_nat(attr, ct, &range, l3proto);
+	err = nfnetlink_parse_nat(attr, ct, &range);
 	if (err < 0)
 		return err;
 
