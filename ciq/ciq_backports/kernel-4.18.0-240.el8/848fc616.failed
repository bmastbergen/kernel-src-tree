Bluetooth: hci_h5: btrtl: Add support for RTL8822C

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Max Chou <max.chou@realtek.com>
commit 848fc6164158d697b70b390a2db5019663713f47
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/848fc616.failed

Add new compatible and FW loading support for RTL8822C.

	Signed-off-by: Max Chou <max.chou@realtek.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 848fc6164158d697b70b390a2db5019663713f47)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/Kconfig
#	drivers/bluetooth/btrtl.c
#	drivers/bluetooth/hci_h5.c
diff --cc drivers/bluetooth/Kconfig
index f3c643a0473c,4e73a531b377..000000000000
--- a/drivers/bluetooth/Kconfig
+++ b/drivers/bluetooth/Kconfig
@@@ -194,6 -206,20 +194,23 @@@ config BT_HCIUART_BC
  
  	  Say Y here to compile support for Broadcom protocol.
  
++<<<<<<< HEAD
++=======
+ config BT_HCIUART_RTL
+ 	bool "Realtek protocol support"
+ 	depends on BT_HCIUART
+ 	depends on BT_HCIUART_SERDEV
+ 	depends on GPIOLIB
+ 	depends on (ACPI || SERIAL_DEV_CTRL_TTYPORT)
+ 	select BT_HCIUART_3WIRE
+ 	select BT_RTL
+ 	help
+ 	  The Realtek protocol support enables Bluetooth HCI over 3-Wire
+ 	  serial port interface for Realtek Bluetooth controllers.
+ 
+ 	  Say Y here to compile support for Realtek protocol.
+ 
++>>>>>>> 848fc6164158 (Bluetooth: hci_h5: btrtl: Add support for RTL8822C)
  config BT_HCIUART_QCA
  	bool "Qualcomm Atheros protocol support"
  	depends on BT_HCIUART
diff --cc drivers/bluetooth/btrtl.c
index 8307e5845311,67f4bc21e7c5..000000000000
--- a/drivers/bluetooth/btrtl.c
+++ b/drivers/bluetooth/btrtl.c
@@@ -79,8 -132,28 +79,31 @@@ static const struct id_table ic_id_tabl
  	/* 8761A */
  	{ IC_MATCH_FL_LMPSUBV, RTL_ROM_LMP_8761A, 0x0,
  	  .config_needed = false,
 -	  .has_rom_version = true,
  	  .fw_name  = "rtl_bt/rtl8761a_fw.bin",
++<<<<<<< HEAD
 +	  .cfg_name = "rtl_bt/rtl8761a_config.bin" },
++=======
+ 	  .cfg_name = "rtl_bt/rtl8761a_config" },
+ 
+ 	/* 8822C with UART interface */
+ 	{ .match_flags = IC_MATCH_FL_LMPSUBV | IC_MATCH_FL_HCIREV |
+ 			 IC_MATCH_FL_HCIBUS,
+ 	  .lmp_subver = RTL_ROM_LMP_8822B,
+ 	  .hci_rev = 0x000c,
+ 	  .hci_ver = 0x0a,
+ 	  .hci_bus = HCI_UART,
+ 	  .config_needed = true,
+ 	  .has_rom_version = true,
+ 	  .fw_name  = "rtl_bt/rtl8822cs_fw.bin",
+ 	  .cfg_name = "rtl_bt/rtl8822cs_config" },
+ 
+ 	/* 8822C with USB interface */
+ 	{ IC_INFO(RTL_ROM_LMP_8822B, 0xc),
+ 	  .config_needed = false,
+ 	  .has_rom_version = true,
+ 	  .fw_name  = "rtl_bt/rtl8822cu_fw.bin",
+ 	  .cfg_name = "rtl_bt/rtl8822cu_config" },
++>>>>>>> 848fc6164158 (Bluetooth: hci_h5: btrtl: Add support for RTL8822C)
  
  	/* 8822B */
  	{ IC_INFO(RTL_ROM_LMP_8822B, 0xb),
diff --cc drivers/bluetooth/hci_h5.c
index 94e06b357b4e,1d8173886852..000000000000
--- a/drivers/bluetooth/hci_h5.c
+++ b/drivers/bluetooth/hci_h5.c
@@@ -3,26 -4,15 +3,32 @@@
   *  Bluetooth HCI Three-wire UART driver
   *
   *  Copyright (C) 2012  Intel Corporation
 + *
 + *
 + *  This program is free software; you can redistribute it and/or modify
 + *  it under the terms of the GNU General Public License as published by
 + *  the Free Software Foundation; either version 2 of the License, or
 + *  (at your option) any later version.
 + *
 + *  This program is distributed in the hope that it will be useful,
 + *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 + *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 + *  GNU General Public License for more details.
 + *
 + *  You should have received a copy of the GNU General Public License
 + *  along with this program; if not, write to the Free Software
 + *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 + *
   */
  
 -#include <linux/acpi.h>
 -#include <linux/errno.h>
 -#include <linux/gpio/consumer.h>
  #include <linux/kernel.h>
++<<<<<<< HEAD
 +#include <linux/errno.h>
++=======
+ #include <linux/mod_devicetable.h>
+ #include <linux/of_device.h>
+ #include <linux/serdev.h>
++>>>>>>> 848fc6164158 (Bluetooth: hci_h5: btrtl: Add support for RTL8822C)
  #include <linux/skbuff.h>
  
  #include <net/bluetooth/bluetooth.h>
@@@ -753,8 -784,258 +759,260 @@@ static const struct hci_uart_proto h5p 
  	.flush		= h5_flush,
  };
  
++<<<<<<< HEAD
++=======
+ static int h5_serdev_probe(struct serdev_device *serdev)
+ {
+ 	const struct acpi_device_id *match;
+ 	struct device *dev = &serdev->dev;
+ 	struct h5 *h5;
+ 
+ 	h5 = devm_kzalloc(dev, sizeof(*h5), GFP_KERNEL);
+ 	if (!h5)
+ 		return -ENOMEM;
+ 
+ 	set_bit(HCI_UART_RESET_ON_INIT, &h5->serdev_hu.flags);
+ 
+ 	h5->hu = &h5->serdev_hu;
+ 	h5->serdev_hu.serdev = serdev;
+ 	serdev_device_set_drvdata(serdev, h5);
+ 
+ 	if (has_acpi_companion(dev)) {
+ 		match = acpi_match_device(dev->driver->acpi_match_table, dev);
+ 		if (!match)
+ 			return -ENODEV;
+ 
+ 		h5->vnd = (const struct h5_vnd *)match->driver_data;
+ 		h5->id  = (char *)match->id;
+ 
+ 		if (h5->vnd->acpi_gpio_map)
+ 			devm_acpi_dev_add_driver_gpios(dev,
+ 						       h5->vnd->acpi_gpio_map);
+ 	} else {
+ 		const void *data;
+ 
+ 		data = of_device_get_match_data(dev);
+ 		if (!data)
+ 			return -ENODEV;
+ 
+ 		h5->vnd = (const struct h5_vnd *)data;
+ 	}
+ 
+ 
+ 	h5->enable_gpio = devm_gpiod_get_optional(dev, "enable", GPIOD_OUT_LOW);
+ 	if (IS_ERR(h5->enable_gpio))
+ 		return PTR_ERR(h5->enable_gpio);
+ 
+ 	h5->device_wake_gpio = devm_gpiod_get_optional(dev, "device-wake",
+ 						       GPIOD_OUT_LOW);
+ 	if (IS_ERR(h5->device_wake_gpio))
+ 		return PTR_ERR(h5->device_wake_gpio);
+ 
+ 	return hci_uart_register_device(&h5->serdev_hu, &h5p);
+ }
+ 
+ static void h5_serdev_remove(struct serdev_device *serdev)
+ {
+ 	struct h5 *h5 = serdev_device_get_drvdata(serdev);
+ 
+ 	hci_uart_unregister_device(&h5->serdev_hu);
+ }
+ 
+ static int __maybe_unused h5_serdev_suspend(struct device *dev)
+ {
+ 	struct h5 *h5 = dev_get_drvdata(dev);
+ 	int ret = 0;
+ 
+ 	if (h5->vnd && h5->vnd->suspend)
+ 		ret = h5->vnd->suspend(h5);
+ 
+ 	return ret;
+ }
+ 
+ static int __maybe_unused h5_serdev_resume(struct device *dev)
+ {
+ 	struct h5 *h5 = dev_get_drvdata(dev);
+ 	int ret = 0;
+ 
+ 	if (h5->vnd && h5->vnd->resume)
+ 		ret = h5->vnd->resume(h5);
+ 
+ 	return ret;
+ }
+ 
+ #ifdef CONFIG_BT_HCIUART_RTL
+ static int h5_btrtl_setup(struct h5 *h5)
+ {
+ 	struct btrtl_device_info *btrtl_dev;
+ 	struct sk_buff *skb;
+ 	__le32 baudrate_data;
+ 	u32 device_baudrate;
+ 	unsigned int controller_baudrate;
+ 	bool flow_control;
+ 	int err;
+ 
+ 	btrtl_dev = btrtl_initialize(h5->hu->hdev, h5->id);
+ 	if (IS_ERR(btrtl_dev))
+ 		return PTR_ERR(btrtl_dev);
+ 
+ 	err = btrtl_get_uart_settings(h5->hu->hdev, btrtl_dev,
+ 				      &controller_baudrate, &device_baudrate,
+ 				      &flow_control);
+ 	if (err)
+ 		goto out_free;
+ 
+ 	baudrate_data = cpu_to_le32(device_baudrate);
+ 	skb = __hci_cmd_sync(h5->hu->hdev, 0xfc17, sizeof(baudrate_data),
+ 			     &baudrate_data, HCI_INIT_TIMEOUT);
+ 	if (IS_ERR(skb)) {
+ 		rtl_dev_err(h5->hu->hdev, "set baud rate command failed\n");
+ 		err = PTR_ERR(skb);
+ 		goto out_free;
+ 	} else {
+ 		kfree_skb(skb);
+ 	}
+ 	/* Give the device some time to set up the new baudrate. */
+ 	usleep_range(10000, 20000);
+ 
+ 	serdev_device_set_baudrate(h5->hu->serdev, controller_baudrate);
+ 	serdev_device_set_flow_control(h5->hu->serdev, flow_control);
+ 
+ 	err = btrtl_download_firmware(h5->hu->hdev, btrtl_dev);
+ 	/* Give the device some time before the hci-core sends it a reset */
+ 	usleep_range(10000, 20000);
+ 
+ out_free:
+ 	btrtl_free(btrtl_dev);
+ 
+ 	return err;
+ }
+ 
+ static void h5_btrtl_open(struct h5 *h5)
+ {
+ 	/* Devices always start with these fixed parameters */
+ 	serdev_device_set_flow_control(h5->hu->serdev, false);
+ 	serdev_device_set_parity(h5->hu->serdev, SERDEV_PARITY_EVEN);
+ 	serdev_device_set_baudrate(h5->hu->serdev, 115200);
+ 
+ 	/* The controller needs up to 500ms to wakeup */
+ 	gpiod_set_value_cansleep(h5->enable_gpio, 1);
+ 	gpiod_set_value_cansleep(h5->device_wake_gpio, 1);
+ 	msleep(500);
+ }
+ 
+ static void h5_btrtl_close(struct h5 *h5)
+ {
+ 	gpiod_set_value_cansleep(h5->device_wake_gpio, 0);
+ 	gpiod_set_value_cansleep(h5->enable_gpio, 0);
+ }
+ 
+ /* Suspend/resume support. On many devices the RTL BT device loses power during
+  * suspend/resume, causing it to lose its firmware and all state. So we simply
+  * turn it off on suspend and reprobe on resume.  This mirrors how RTL devices
+  * are handled in the USB driver, where the USB_QUIRK_RESET_RESUME is used which
+  * also causes a reprobe on resume.
+  */
+ static int h5_btrtl_suspend(struct h5 *h5)
+ {
+ 	serdev_device_set_flow_control(h5->hu->serdev, false);
+ 	gpiod_set_value_cansleep(h5->device_wake_gpio, 0);
+ 	gpiod_set_value_cansleep(h5->enable_gpio, 0);
+ 	return 0;
+ }
+ 
+ struct h5_btrtl_reprobe {
+ 	struct device *dev;
+ 	struct work_struct work;
+ };
+ 
+ static void h5_btrtl_reprobe_worker(struct work_struct *work)
+ {
+ 	struct h5_btrtl_reprobe *reprobe =
+ 		container_of(work, struct h5_btrtl_reprobe, work);
+ 	int ret;
+ 
+ 	ret = device_reprobe(reprobe->dev);
+ 	if (ret && ret != -EPROBE_DEFER)
+ 		dev_err(reprobe->dev, "Reprobe error %d\n", ret);
+ 
+ 	put_device(reprobe->dev);
+ 	kfree(reprobe);
+ 	module_put(THIS_MODULE);
+ }
+ 
+ static int h5_btrtl_resume(struct h5 *h5)
+ {
+ 	struct h5_btrtl_reprobe *reprobe;
+ 
+ 	reprobe = kzalloc(sizeof(*reprobe), GFP_KERNEL);
+ 	if (!reprobe)
+ 		return -ENOMEM;
+ 
+ 	__module_get(THIS_MODULE);
+ 
+ 	INIT_WORK(&reprobe->work, h5_btrtl_reprobe_worker);
+ 	reprobe->dev = get_device(&h5->hu->serdev->dev);
+ 	queue_work(system_long_wq, &reprobe->work);
+ 	return 0;
+ }
+ 
+ static const struct acpi_gpio_params btrtl_device_wake_gpios = { 0, 0, false };
+ static const struct acpi_gpio_params btrtl_enable_gpios = { 1, 0, false };
+ static const struct acpi_gpio_params btrtl_host_wake_gpios = { 2, 0, false };
+ static const struct acpi_gpio_mapping acpi_btrtl_gpios[] = {
+ 	{ "device-wake-gpios", &btrtl_device_wake_gpios, 1 },
+ 	{ "enable-gpios", &btrtl_enable_gpios, 1 },
+ 	{ "host-wake-gpios", &btrtl_host_wake_gpios, 1 },
+ 	{},
+ };
+ 
+ static struct h5_vnd rtl_vnd = {
+ 	.setup		= h5_btrtl_setup,
+ 	.open		= h5_btrtl_open,
+ 	.close		= h5_btrtl_close,
+ 	.suspend	= h5_btrtl_suspend,
+ 	.resume		= h5_btrtl_resume,
+ 	.acpi_gpio_map	= acpi_btrtl_gpios,
+ };
+ #endif
+ 
+ #ifdef CONFIG_ACPI
+ static const struct acpi_device_id h5_acpi_match[] = {
+ #ifdef CONFIG_BT_HCIUART_RTL
+ 	{ "OBDA8723", (kernel_ulong_t)&rtl_vnd },
+ #endif
+ 	{ },
+ };
+ MODULE_DEVICE_TABLE(acpi, h5_acpi_match);
+ #endif
+ 
+ static const struct dev_pm_ops h5_serdev_pm_ops = {
+ 	SET_SYSTEM_SLEEP_PM_OPS(h5_serdev_suspend, h5_serdev_resume)
+ };
+ 
+ static const struct of_device_id rtl_bluetooth_of_match[] = {
+ #ifdef CONFIG_BT_HCIUART_RTL
+ 	{ .compatible = "realtek,rtl8822cs-bt",
+ 	  .data = (const void *)&rtl_vnd },
+ #endif
+ 	{ },
+ };
+ MODULE_DEVICE_TABLE(of, rtl_bluetooth_of_match);
+ 
+ static struct serdev_device_driver h5_serdev_driver = {
+ 	.probe = h5_serdev_probe,
+ 	.remove = h5_serdev_remove,
+ 	.driver = {
+ 		.name = "hci_uart_h5",
+ 		.acpi_match_table = ACPI_PTR(h5_acpi_match),
+ 		.pm = &h5_serdev_pm_ops,
+ 		.of_match_table = rtl_bluetooth_of_match,
+ 	},
+ };
+ 
++>>>>>>> 848fc6164158 (Bluetooth: hci_h5: btrtl: Add support for RTL8822C)
  int __init h5_init(void)
  {
 -	serdev_device_driver_register(&h5_serdev_driver);
  	return hci_uart_register_proto(&h5p);
  }
  
* Unmerged path drivers/bluetooth/Kconfig
* Unmerged path drivers/bluetooth/btrtl.c
* Unmerged path drivers/bluetooth/hci_h5.c
