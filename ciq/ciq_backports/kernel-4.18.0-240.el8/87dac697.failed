net/mlx5e: Add devlink fdb_large_groups parameter

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jianbo Liu <jianbol@mellanox.com>
commit 87dac697a05a730d878f703a3c3dd78ac6c5bff4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/87dac697.failed

Add a devlink parameter to control the number of large groups in a
autogrouped flow table. The default value is 15, and the range is between 1
and 1024.

The size of each large group can be calculated according to the following
formula: size = 4M / (fdb_large_groups + 1).

Examples:
- Set the number of large groups to 20.
    $ devlink dev param set pci/0000:82:00.0 name fdb_large_groups \
      cmode driverinit value 20

  Then run devlink reload command to apply the new value.
    $ devlink dev reload pci/0000:82:00.0

- Read the number of large groups in flow table.
    $ devlink dev param show pci/0000:82:00.0 name fdb_large_groups
    pci/0000:82:00.0:
      name fdb_large_groups type driver-specific
        values:
          cmode driverinit value 20

	Signed-off-by: Jianbo Liu <jianbol@mellanox.com>
	Reviewed-by: Vlad Buslov <vladbu@mellanox.com>
	Reviewed-by: Roi Dayan <roid@mellanox.com>
	Acked-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 87dac697a05a730d878f703a3c3dd78ac6c5bff4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/networking/devlink/mlx5.rst
#	drivers/net/ethernet/mellanox/mlx5/core/devlink.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/devlink.c
index dd63e93851be,b7bb81b8c49b..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/devlink.c
@@@ -193,10 -190,37 +193,44 @@@ static int mlx5_devlink_fs_mode_get(str
  	return 0;
  }
  
++<<<<<<< HEAD
 +enum mlx5_devlink_param_id {
 +	MLX5_DEVLINK_PARAM_ID_BASE = DEVLINK_PARAM_GENERIC_ID_MAX,
 +	MLX5_DEVLINK_PARAM_ID_FLOW_STEERING_MODE,
 +};
++=======
+ static int mlx5_devlink_enable_roce_validate(struct devlink *devlink, u32 id,
+ 					     union devlink_param_value val,
+ 					     struct netlink_ext_ack *extack)
+ {
+ 	struct mlx5_core_dev *dev = devlink_priv(devlink);
+ 	bool new_state = val.vbool;
+ 
+ 	if (new_state && !MLX5_CAP_GEN(dev, roce)) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Device doesn't support RoCE");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ #ifdef CONFIG_MLX5_ESWITCH
+ static int mlx5_devlink_large_group_num_validate(struct devlink *devlink, u32 id,
+ 						 union devlink_param_value val,
+ 						 struct netlink_ext_ack *extack)
+ {
+ 	int group_num = val.vu32;
+ 
+ 	if (group_num < 1 || group_num > 1024) {
+ 		NL_SET_ERR_MSG_MOD(extack,
+ 				   "Unsupported group number, supported range is 1-1024");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ 	return 0;
+ }
+ #endif
++>>>>>>> 87dac697a05a (net/mlx5e: Add devlink fdb_large_groups parameter)
  
  static const struct devlink_param mlx5_devlink_params[] = {
  	DEVLINK_PARAM_DRIVER(MLX5_DEVLINK_PARAM_ID_FLOW_STEERING_MODE,
@@@ -204,6 -228,15 +238,18 @@@
  			     BIT(DEVLINK_PARAM_CMODE_RUNTIME),
  			     mlx5_devlink_fs_mode_get, mlx5_devlink_fs_mode_set,
  			     mlx5_devlink_fs_mode_validate),
++<<<<<<< HEAD
++=======
+ 	DEVLINK_PARAM_GENERIC(ENABLE_ROCE, BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),
+ 			      NULL, NULL, mlx5_devlink_enable_roce_validate),
+ #ifdef CONFIG_MLX5_ESWITCH
+ 	DEVLINK_PARAM_DRIVER(MLX5_DEVLINK_PARAM_ID_ESW_LARGE_GROUP_NUM,
+ 			     "fdb_large_groups", DEVLINK_PARAM_TYPE_U32,
+ 			     BIT(DEVLINK_PARAM_CMODE_DRIVERINIT),
+ 			     NULL, NULL,
+ 			     mlx5_devlink_large_group_num_validate),
+ #endif
++>>>>>>> 87dac697a05a (net/mlx5e: Add devlink fdb_large_groups parameter)
  };
  
  static void mlx5_devlink_set_params_init_values(struct devlink *devlink)
@@@ -218,6 -251,18 +264,21 @@@
  	devlink_param_driverinit_value_set(devlink,
  					   MLX5_DEVLINK_PARAM_ID_FLOW_STEERING_MODE,
  					   value);
++<<<<<<< HEAD
++=======
+ 
+ 	value.vbool = MLX5_CAP_GEN(dev, roce);
+ 	devlink_param_driverinit_value_set(devlink,
+ 					   DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE,
+ 					   value);
+ 
+ #ifdef CONFIG_MLX5_ESWITCH
+ 	value.vu32 = ESW_OFFLOADS_DEFAULT_NUM_GROUPS;
+ 	devlink_param_driverinit_value_set(devlink,
+ 					   MLX5_DEVLINK_PARAM_ID_ESW_LARGE_GROUP_NUM,
+ 					   value);
+ #endif
++>>>>>>> 87dac697a05a (net/mlx5e: Add devlink fdb_large_groups parameter)
  }
  
  int mlx5_devlink_register(struct devlink *devlink, struct device *dev)
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 9c629f913b96,d010657ce601..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -43,9 -43,15 +43,21 @@@
  #include <linux/mlx5/fs.h>
  #include "lib/mpfs.h"
  
++<<<<<<< HEAD
 +#define FDB_MAX_CHAIN 3
 +#define FDB_SLOW_PATH_CHAIN (FDB_MAX_CHAIN + 1)
 +#define FDB_MAX_PRIO 16
++=======
+ #define FDB_TC_MAX_CHAIN 3
+ #define FDB_FT_CHAIN (FDB_TC_MAX_CHAIN + 1)
+ #define FDB_TC_SLOW_PATH_CHAIN (FDB_FT_CHAIN + 1)
+ 
+ /* The index of the last real chain (FT) + 1 as chain zero is valid as well */
+ #define FDB_NUM_CHAINS (FDB_FT_CHAIN + 1)
+ 
+ #define FDB_TC_MAX_PRIO 16
+ #define FDB_TC_LEVELS_PER_PRIO 2
++>>>>>>> 87dac697a05a (net/mlx5e: Add devlink fdb_large_groups parameter)
  
  #ifdef CONFIG_MLX5_ESWITCH
  
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index a042a52084fa,4b5b6618dff4..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -47,12 -48,183 +47,190 @@@
   * one for multicast.
   */
  #define MLX5_ESW_MISS_FLOWS (2)
 +
 +#define fdb_prio_table(esw, chain, prio, level) \
 +	(esw)->fdb_table.offloads.fdb_prio[(chain)][(prio)][(level)]
 +
  #define UPLINK_REP_INDEX 0
  
++<<<<<<< HEAD
++=======
+ /* Per vport tables */
+ 
+ #define MLX5_ESW_VPORT_TABLE_SIZE 128
+ 
+ /* This struct is used as a key to the hash table and we need it to be packed
+  * so hash result is consistent
+  */
+ struct mlx5_vport_key {
+ 	u32 chain;
+ 	u16 prio;
+ 	u16 vport;
+ 	u16 vhca_id;
+ } __packed;
+ 
+ struct mlx5_vport_table {
+ 	struct hlist_node hlist;
+ 	struct mlx5_flow_table *fdb;
+ 	u32 num_rules;
+ 	struct mlx5_vport_key key;
+ };
+ 
+ #define MLX5_ESW_VPORT_TBL_NUM_GROUPS  4
+ 
+ static struct mlx5_flow_table *
+ esw_vport_tbl_create(struct mlx5_eswitch *esw, struct mlx5_flow_namespace *ns)
+ {
+ 	struct mlx5_flow_table_attr ft_attr = {};
+ 	struct mlx5_flow_table *fdb;
+ 
+ 	ft_attr.autogroup.max_num_groups = MLX5_ESW_VPORT_TBL_NUM_GROUPS;
+ 	ft_attr.max_fte = MLX5_ESW_VPORT_TABLE_SIZE;
+ 	ft_attr.prio = FDB_PER_VPORT;
+ 	fdb = mlx5_create_auto_grouped_flow_table(ns, &ft_attr);
+ 	if (IS_ERR(fdb)) {
+ 		esw_warn(esw->dev, "Failed to create per vport FDB Table err %ld\n",
+ 			 PTR_ERR(fdb));
+ 	}
+ 
+ 	return fdb;
+ }
+ 
+ static u32 flow_attr_to_vport_key(struct mlx5_eswitch *esw,
+ 				  struct mlx5_esw_flow_attr *attr,
+ 				  struct mlx5_vport_key *key)
+ {
+ 	key->vport = attr->in_rep->vport;
+ 	key->chain = attr->chain;
+ 	key->prio = attr->prio;
+ 	key->vhca_id = MLX5_CAP_GEN(esw->dev, vhca_id);
+ 	return jhash(key, sizeof(*key), 0);
+ }
+ 
+ /* caller must hold vports.lock */
+ static struct mlx5_vport_table *
+ esw_vport_tbl_lookup(struct mlx5_eswitch *esw, struct mlx5_vport_key *skey, u32 key)
+ {
+ 	struct mlx5_vport_table *e;
+ 
+ 	hash_for_each_possible(esw->fdb_table.offloads.vports.table, e, hlist, key)
+ 		if (!memcmp(&e->key, skey, sizeof(*skey)))
+ 			return e;
+ 
+ 	return NULL;
+ }
+ 
+ static void
+ esw_vport_tbl_put(struct mlx5_eswitch *esw, struct mlx5_esw_flow_attr *attr)
+ {
+ 	struct mlx5_vport_table *e;
+ 	struct mlx5_vport_key key;
+ 	u32 hkey;
+ 
+ 	mutex_lock(&esw->fdb_table.offloads.vports.lock);
+ 	hkey = flow_attr_to_vport_key(esw, attr, &key);
+ 	e = esw_vport_tbl_lookup(esw, &key, hkey);
+ 	if (!e || --e->num_rules)
+ 		goto out;
+ 
+ 	hash_del(&e->hlist);
+ 	mlx5_destroy_flow_table(e->fdb);
+ 	kfree(e);
+ out:
+ 	mutex_unlock(&esw->fdb_table.offloads.vports.lock);
+ }
+ 
+ static struct mlx5_flow_table *
+ esw_vport_tbl_get(struct mlx5_eswitch *esw, struct mlx5_esw_flow_attr *attr)
+ {
+ 	struct mlx5_core_dev *dev = esw->dev;
+ 	struct mlx5_flow_namespace *ns;
+ 	struct mlx5_flow_table *fdb;
+ 	struct mlx5_vport_table *e;
+ 	struct mlx5_vport_key skey;
+ 	u32 hkey;
+ 
+ 	mutex_lock(&esw->fdb_table.offloads.vports.lock);
+ 	hkey = flow_attr_to_vport_key(esw, attr, &skey);
+ 	e = esw_vport_tbl_lookup(esw, &skey, hkey);
+ 	if (e) {
+ 		e->num_rules++;
+ 		goto out;
+ 	}
+ 
+ 	e = kzalloc(sizeof(*e), GFP_KERNEL);
+ 	if (!e) {
+ 		fdb = ERR_PTR(-ENOMEM);
+ 		goto err_alloc;
+ 	}
+ 
+ 	ns = mlx5_get_flow_namespace(dev, MLX5_FLOW_NAMESPACE_FDB);
+ 	if (!ns) {
+ 		esw_warn(dev, "Failed to get FDB namespace\n");
+ 		fdb = ERR_PTR(-ENOENT);
+ 		goto err_ns;
+ 	}
+ 
+ 	fdb = esw_vport_tbl_create(esw, ns);
+ 	if (IS_ERR(fdb))
+ 		goto err_ns;
+ 
+ 	e->fdb = fdb;
+ 	e->num_rules = 1;
+ 	e->key = skey;
+ 	hash_add(esw->fdb_table.offloads.vports.table, &e->hlist, hkey);
+ out:
+ 	mutex_unlock(&esw->fdb_table.offloads.vports.lock);
+ 	return e->fdb;
+ 
+ err_ns:
+ 	kfree(e);
+ err_alloc:
+ 	mutex_unlock(&esw->fdb_table.offloads.vports.lock);
+ 	return fdb;
+ }
+ 
+ int mlx5_esw_vport_tbl_get(struct mlx5_eswitch *esw)
+ {
+ 	struct mlx5_esw_flow_attr attr = {};
+ 	struct mlx5_eswitch_rep rep = {};
+ 	struct mlx5_flow_table *fdb;
+ 	struct mlx5_vport *vport;
+ 	int i;
+ 
+ 	attr.prio = 1;
+ 	attr.in_rep = &rep;
+ 	mlx5_esw_for_all_vports(esw, i, vport) {
+ 		attr.in_rep->vport = vport->vport;
+ 		fdb = esw_vport_tbl_get(esw, &attr);
+ 		if (!fdb)
+ 			goto out;
+ 	}
+ 	return 0;
+ 
+ out:
+ 	mlx5_esw_vport_tbl_put(esw);
+ 	return PTR_ERR(fdb);
+ }
+ 
+ void mlx5_esw_vport_tbl_put(struct mlx5_eswitch *esw)
+ {
+ 	struct mlx5_esw_flow_attr attr = {};
+ 	struct mlx5_eswitch_rep rep = {};
+ 	struct mlx5_vport *vport;
+ 	int i;
+ 
+ 	attr.prio = 1;
+ 	attr.in_rep = &rep;
+ 	mlx5_esw_for_all_vports(esw, i, vport) {
+ 		attr.in_rep->vport = vport->vport;
+ 		esw_vport_tbl_put(esw, &attr);
+ 	}
+ }
+ 
+ /* End: Per vport tables */
+ 
++>>>>>>> 87dac697a05a (net/mlx5e: Add devlink fdb_large_groups parameter)
  static struct mlx5_eswitch_rep *mlx5_eswitch_get_rep(struct mlx5_eswitch *esw,
  						     u16 vport_num)
  {
* Unmerged path Documentation/networking/devlink/mlx5.rst
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c
* Unmerged path Documentation/networking/devlink/mlx5.rst
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/devlink.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/devlink.h b/drivers/net/ethernet/mellanox/mlx5/core/devlink.h
index d0ba03774ddf..f0de327a59be 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/devlink.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/devlink.h
@@ -6,6 +6,12 @@
 
 #include <net/devlink.h>
 
+enum mlx5_devlink_param_id {
+	MLX5_DEVLINK_PARAM_ID_BASE = DEVLINK_PARAM_GENERIC_ID_MAX,
+	MLX5_DEVLINK_PARAM_ID_FLOW_STEERING_MODE,
+	MLX5_DEVLINK_PARAM_ID_ESW_LARGE_GROUP_NUM,
+};
+
 struct devlink *mlx5_devlink_alloc(void);
 void mlx5_devlink_free(struct devlink *devlink);
 int mlx5_devlink_register(struct devlink *devlink, struct device *dev);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
index 1a31e7e828c2..9812ba2021de 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.c
@@ -39,6 +39,7 @@
 #include "lib/eq.h"
 #include "eswitch.h"
 #include "fs_core.h"
+#include "devlink.h"
 #include "ecpf.h"
 
 enum {
@@ -1896,6 +1897,25 @@ void mlx5_eswitch_disable_pf_vf_vports(struct mlx5_eswitch *esw)
 		esw_disable_vport(esw, vport);
 }
 
+static void mlx5_eswitch_get_devlink_param(struct mlx5_eswitch *esw)
+{
+	struct devlink *devlink = priv_to_devlink(esw->dev);
+	union devlink_param_value val;
+	int err;
+
+	err = devlink_param_driverinit_value_get(devlink,
+						 MLX5_DEVLINK_PARAM_ID_ESW_LARGE_GROUP_NUM,
+						 &val);
+	if (!err) {
+		esw->params.large_group_num = val.vu32;
+	} else {
+		esw_warn(esw->dev,
+			 "Devlink can't get param fdb_large_groups, uses default (%d).\n",
+			 ESW_OFFLOADS_DEFAULT_NUM_GROUPS);
+		esw->params.large_group_num = ESW_OFFLOADS_DEFAULT_NUM_GROUPS;
+	}
+}
+
 int mlx5_eswitch_enable(struct mlx5_eswitch *esw, int mode)
 {
 	int err;
@@ -1912,6 +1932,8 @@ int mlx5_eswitch_enable(struct mlx5_eswitch *esw, int mode)
 	if (!MLX5_CAP_ESW_EGRESS_ACL(esw->dev, ft_support))
 		esw_warn(esw->dev, "engress ACL is not supported by FW\n");
 
+	mlx5_eswitch_get_devlink_param(esw);
+
 	esw_create_tsar(esw);
 
 	esw->mode = mode;
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c
