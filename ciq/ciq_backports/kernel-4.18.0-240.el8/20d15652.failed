ipv4: Only Replay routes of interest to new listeners

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ido Schimmel <idosch@mellanox.com>
commit 20d1565203e68cd32d5db3e293e7323173ad7a0d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/20d15652.failed

When a new listener is registered to the FIB notification chain it
receives a dump of all the available routes in the system. Instead, make
sure to only replay the IPv4 routes that are actually used in the data
path and are of any interest to the new listener.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Reviewed-by: David Ahern <dsahern@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 20d1565203e68cd32d5db3e293e7323173ad7a0d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/fib_trie.c
diff --cc net/ipv4/fib_trie.c
index 852a585393c4,3f2ff97618ec..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -2000,10 -2004,84 +2000,15 @@@ int fib_table_flush(struct net *net, st
  	return found;
  }
  
 -/* derived from fib_trie_free */
 -static void __fib_info_notify_update(struct net *net, struct fib_table *tb,
 -				     struct nl_info *info)
 -{
 -	struct trie *t = (struct trie *)tb->tb_data;
 -	struct key_vector *pn = t->kv;
 -	unsigned long cindex = 1;
 -	struct fib_alias *fa;
 -
 -	for (;;) {
 -		struct key_vector *n;
 -
 -		if (!(cindex--)) {
 -			t_key pkey = pn->key;
 -
 -			if (IS_TRIE(pn))
 -				break;
 -
 -			pn = node_parent(pn);
 -			cindex = get_index(pkey, pn);
 -			continue;
 -		}
 -
 -		/* grab the next available node */
 -		n = get_child(pn, cindex);
 -		if (!n)
 -			continue;
 -
 -		if (IS_TNODE(n)) {
 -			/* record pn and cindex for leaf walking */
 -			pn = n;
 -			cindex = 1ul << n->bits;
 -
 -			continue;
 -		}
 -
 -		hlist_for_each_entry(fa, &n->leaf, fa_list) {
 -			struct fib_info *fi = fa->fa_info;
 -
 -			if (!fi || !fi->nh_updated || fa->tb_id != tb->tb_id)
 -				continue;
 -
 -			rtmsg_fib(RTM_NEWROUTE, htonl(n->key), fa,
 -				  KEYLENGTH - fa->fa_slen, tb->tb_id,
 -				  info, NLM_F_REPLACE);
 -
 -			/* call_fib_entry_notifiers will be removed when
 -			 * in-kernel notifier is implemented and supported
 -			 * for nexthop objects
 -			 */
 -			call_fib_entry_notifiers(net, FIB_EVENT_ENTRY_REPLACE,
 -						 n->key,
 -						 KEYLENGTH - fa->fa_slen, fa,
 -						 NULL);
 -		}
 -	}
 -}
 -
 -void fib_info_notify_update(struct net *net, struct nl_info *info)
 -{
 -	unsigned int h;
 -
 -	for (h = 0; h < FIB_TABLE_HASHSZ; h++) {
 -		struct hlist_head *head = &net->ipv4.fib_table_hash[h];
 -		struct fib_table *tb;
 -
 -		hlist_for_each_entry_rcu(tb, head, tb_hlist)
 -			__fib_info_notify_update(net, tb, info);
 -	}
 -}
 -
 -static int fib_leaf_notify(struct key_vector *l, struct fib_table *tb,
 -			   struct notifier_block *nb,
 -			   struct netlink_ext_ack *extack)
 +static void fib_leaf_notify(struct net *net, struct key_vector *l,
 +			    struct fib_table *tb, struct notifier_block *nb)
  {
  	struct fib_alias *fa;
++<<<<<<< HEAD
++=======
+ 	int last_slen = -1;
+ 	int err;
++>>>>>>> 20d1565203e6 (ipv4: Only Replay routes of interest to new listeners)
  
  	hlist_for_each_entry_rcu(fa, &l->leaf, fa_list) {
  		struct fib_info *fi = fa->fa_info;
@@@ -2017,13 -2095,27 +2022,31 @@@
  		if (tb->tb_id != fa->tb_id)
  			continue;
  
++<<<<<<< HEAD
 +		call_fib_entry_notifier(nb, net, FIB_EVENT_ENTRY_ADD, l->key,
 +					KEYLENGTH - fa->fa_slen, fa);
++=======
+ 		err = call_fib_entry_notifier(nb, FIB_EVENT_ENTRY_ADD, l->key,
+ 					      KEYLENGTH - fa->fa_slen,
+ 					      fa, extack);
+ 		if (err)
+ 			return err;
+ 
+ 		if (fa->fa_slen == last_slen)
+ 			continue;
+ 
+ 		last_slen = fa->fa_slen;
+ 		err = call_fib_entry_notifier(nb, FIB_EVENT_ENTRY_REPLACE_TMP,
+ 					      l->key, KEYLENGTH - fa->fa_slen,
+ 					      fa, extack);
+ 		if (err)
+ 			return err;
++>>>>>>> 20d1565203e6 (ipv4: Only Replay routes of interest to new listeners)
  	}
 -	return 0;
  }
  
 -static int fib_table_notify(struct fib_table *tb, struct notifier_block *nb,
 -			    struct netlink_ext_ack *extack)
 +static void fib_table_notify(struct net *net, struct fib_table *tb,
 +			     struct notifier_block *nb)
  {
  	struct trie *t = (struct trie *)tb->tb_data;
  	struct key_vector *l, *tp = t->kv;
* Unmerged path net/ipv4/fib_trie.c
