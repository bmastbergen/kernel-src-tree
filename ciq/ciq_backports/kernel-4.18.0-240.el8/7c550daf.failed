net: fib_notifier: make FIB notifier per-netns

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] fib_notifier: make FIB notifier per-netns (Petr Oros) [1805951]
Rebuild_FUZZ: 94.25%
commit-author Jiri Pirko <jiri@mellanox.com>
commit 7c550daffe22a97282effa75fe7c1f6b83563ecb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7c550daf.failed

Currently all users of FIB notifier only cares about events in init_net.
Later in this patchset, users get interested in other namespaces too.
However, for every registered block user is interested only about one
namespace. Make the FIB notifier registration per-netns and avoid
unnecessary calls of notifier block for other namespaces.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7c550daffe22a97282effa75fe7c1f6b83563ecb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/netdevsim/fib.c
#	net/ipv4/fib_trie.c
diff --cc drivers/net/netdevsim/fib.c
index 1a251f76d09b,01ee9cc54605..000000000000
--- a/drivers/net/netdevsim/fib.c
+++ b/drivers/net/netdevsim/fib.c
@@@ -199,69 -202,99 +199,96 @@@ static int nsim_fib_event_nb(struct not
  /* inconsistent dump, trying again */
  static void nsim_fib_dump_inconsistent(struct notifier_block *nb)
  {
 -	struct nsim_fib_data *data = container_of(nb, struct nsim_fib_data,
 -						  fib_nb);
 +	struct nsim_fib_data *data;
 +	struct net *net;
  
 -	data->ipv4.fib.num = 0ULL;
 -	data->ipv4.rules.num = 0ULL;
 -	data->ipv6.fib.num = 0ULL;
 -	data->ipv6.rules.num = 0ULL;
 -}
 +	rcu_read_lock();
 +	for_each_net_rcu(net) {
 +		data = net_generic(net, nsim_fib_net_id);
  
 -static u64 nsim_fib_ipv4_resource_occ_get(void *priv)
 -{
 -	struct nsim_fib_data *data = priv;
 +		data->ipv4.fib.num = 0ULL;
 +		data->ipv4.rules.num = 0ULL;
  
 -	return nsim_fib_get_val(data, NSIM_RESOURCE_IPV4_FIB, false);
 +		data->ipv6.fib.num = 0ULL;
 +		data->ipv6.rules.num = 0ULL;
 +	}
 +	rcu_read_unlock();
  }
  
 -static u64 nsim_fib_ipv4_rules_res_occ_get(void *priv)
 +static struct notifier_block nsim_fib_nb = {
 +	.notifier_call = nsim_fib_event_nb,
 +};
 +
 +/* Initialize per network namespace state */
 +static int __net_init nsim_fib_netns_init(struct net *net)
  {
 -	struct nsim_fib_data *data = priv;
 +	struct nsim_fib_data *data = net_generic(net, nsim_fib_net_id);
  
 -	return nsim_fib_get_val(data, NSIM_RESOURCE_IPV4_FIB_RULES, false);
 -}
 +	data->ipv4.fib.max = (u64)-1;
 +	data->ipv4.rules.max = (u64)-1;
  
 -static u64 nsim_fib_ipv6_resource_occ_get(void *priv)
 -{
 -	struct nsim_fib_data *data = priv;
 +	data->ipv6.fib.max = (u64)-1;
 +	data->ipv6.rules.max = (u64)-1;
  
 -	return nsim_fib_get_val(data, NSIM_RESOURCE_IPV6_FIB, false);
++<<<<<<< HEAD
 +	return 0;
  }
  
 -static u64 nsim_fib_ipv6_rules_res_occ_get(void *priv)
 -{
 -	struct nsim_fib_data *data = priv;
 +static struct pernet_operations nsim_fib_net_ops = {
 +	.init = nsim_fib_netns_init,
 +	.id   = &nsim_fib_net_id,
 +	.size = sizeof(struct nsim_fib_data),
 +};
  
 -	return nsim_fib_get_val(data, NSIM_RESOURCE_IPV6_FIB_RULES, false);
 +void nsim_fib_exit(void)
 +{
 +	unregister_fib_notifier(&nsim_fib_nb);
 +	unregister_pernet_subsys(&nsim_fib_net_ops);
  }
  
 -struct nsim_fib_data *nsim_fib_create(struct devlink *devlink)
 +int nsim_fib_init(void)
  {
 -	struct nsim_fib_data *data;
  	int err;
  
 -	data = kzalloc(sizeof(*data), GFP_KERNEL);
 -	if (!data)
 -		return ERR_PTR(-ENOMEM);
 -
 -	data->ipv4.fib.max = (u64)-1;
 -	data->ipv4.rules.max = (u64)-1;
 -
 -	data->ipv6.fib.max = (u64)-1;
 -	data->ipv6.rules.max = (u64)-1;
 -
 +	err = register_pernet_subsys(&nsim_fib_net_ops);
 +	if (err < 0) {
 +		pr_err("Failed to register pernet subsystem\n");
++=======
+ 	data->fib_nb.notifier_call = nsim_fib_event_nb;
+ 	err = register_fib_notifier(&init_net, &data->fib_nb,
+ 				    nsim_fib_dump_inconsistent);
+ 	if (err) {
+ 		pr_err("Failed to register fib notifier\n");
++>>>>>>> 7c550daffe22 (net: fib_notifier: make FIB notifier per-netns)
  		goto err_out;
  	}
  
 -	devlink_resource_occ_get_register(devlink,
 -					  NSIM_RESOURCE_IPV4_FIB,
 -					  nsim_fib_ipv4_resource_occ_get,
 -					  data);
 -	devlink_resource_occ_get_register(devlink,
 -					  NSIM_RESOURCE_IPV4_FIB_RULES,
 -					  nsim_fib_ipv4_rules_res_occ_get,
 -					  data);
 -	devlink_resource_occ_get_register(devlink,
 -					  NSIM_RESOURCE_IPV6_FIB,
 -					  nsim_fib_ipv6_resource_occ_get,
 -					  data);
 -	devlink_resource_occ_get_register(devlink,
 -					  NSIM_RESOURCE_IPV6_FIB_RULES,
 -					  nsim_fib_ipv6_rules_res_occ_get,
 -					  data);
 -	return data;
 +	err = register_fib_notifier(&nsim_fib_nb, nsim_fib_dump_inconsistent);
 +	if (err < 0) {
 +		pr_err("Failed to register fib notifier\n");
 +		unregister_pernet_subsys(&nsim_fib_net_ops);
 +		goto err_out;
 +	}
  
  err_out:
++<<<<<<< HEAD
 +	return err;
++=======
+ 	kfree(data);
+ 	return ERR_PTR(err);
+ }
+ 
+ void nsim_fib_destroy(struct devlink *devlink, struct nsim_fib_data *data)
+ {
+ 	devlink_resource_occ_get_unregister(devlink,
+ 					    NSIM_RESOURCE_IPV6_FIB_RULES);
+ 	devlink_resource_occ_get_unregister(devlink,
+ 					    NSIM_RESOURCE_IPV6_FIB);
+ 	devlink_resource_occ_get_unregister(devlink,
+ 					    NSIM_RESOURCE_IPV4_FIB_RULES);
+ 	devlink_resource_occ_get_unregister(devlink,
+ 					    NSIM_RESOURCE_IPV4_FIB);
+ 	unregister_fib_notifier(&init_net, &data->fib_nb);
+ 	kfree(data);
++>>>>>>> 7c550daffe22 (net: fib_notifier: make FIB notifier per-netns)
  }
diff --cc net/ipv4/fib_trie.c
index cbaed1062674,5b600b2a2aa3..000000000000
--- a/net/ipv4/fib_trie.c
+++ b/net/ipv4/fib_trie.c
@@@ -1942,8 -1944,79 +1942,84 @@@ int fib_table_flush(struct net *net, st
  	return found;
  }
  
++<<<<<<< HEAD
 +static void fib_leaf_notify(struct net *net, struct key_vector *l,
 +			    struct fib_table *tb, struct notifier_block *nb)
++=======
+ /* derived from fib_trie_free */
+ static void __fib_info_notify_update(struct net *net, struct fib_table *tb,
+ 				     struct nl_info *info)
+ {
+ 	struct trie *t = (struct trie *)tb->tb_data;
+ 	struct key_vector *pn = t->kv;
+ 	unsigned long cindex = 1;
+ 	struct fib_alias *fa;
+ 
+ 	for (;;) {
+ 		struct key_vector *n;
+ 
+ 		if (!(cindex--)) {
+ 			t_key pkey = pn->key;
+ 
+ 			if (IS_TRIE(pn))
+ 				break;
+ 
+ 			pn = node_parent(pn);
+ 			cindex = get_index(pkey, pn);
+ 			continue;
+ 		}
+ 
+ 		/* grab the next available node */
+ 		n = get_child(pn, cindex);
+ 		if (!n)
+ 			continue;
+ 
+ 		if (IS_TNODE(n)) {
+ 			/* record pn and cindex for leaf walking */
+ 			pn = n;
+ 			cindex = 1ul << n->bits;
+ 
+ 			continue;
+ 		}
+ 
+ 		hlist_for_each_entry(fa, &n->leaf, fa_list) {
+ 			struct fib_info *fi = fa->fa_info;
+ 
+ 			if (!fi || !fi->nh_updated || fa->tb_id != tb->tb_id)
+ 				continue;
+ 
+ 			rtmsg_fib(RTM_NEWROUTE, htonl(n->key), fa,
+ 				  KEYLENGTH - fa->fa_slen, tb->tb_id,
+ 				  info, NLM_F_REPLACE);
+ 
+ 			/* call_fib_entry_notifiers will be removed when
+ 			 * in-kernel notifier is implemented and supported
+ 			 * for nexthop objects
+ 			 */
+ 			call_fib_entry_notifiers(net, FIB_EVENT_ENTRY_REPLACE,
+ 						 n->key,
+ 						 KEYLENGTH - fa->fa_slen, fa,
+ 						 NULL);
+ 		}
+ 	}
+ }
+ 
+ void fib_info_notify_update(struct net *net, struct nl_info *info)
+ {
+ 	unsigned int h;
+ 
+ 	for (h = 0; h < FIB_TABLE_HASHSZ; h++) {
+ 		struct hlist_head *head = &net->ipv4.fib_table_hash[h];
+ 		struct fib_table *tb;
+ 
+ 		hlist_for_each_entry_rcu(tb, head, tb_hlist)
+ 			__fib_info_notify_update(net, tb, info);
+ 	}
+ }
+ 
+ static void fib_leaf_notify(struct key_vector *l, struct fib_table *tb,
+ 			    struct notifier_block *nb)
++>>>>>>> 7c550daffe22 (net: fib_notifier: make FIB notifier per-netns)
  {
  	struct fib_alias *fa;
  
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c b/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
index a5addeadc732..7ad7b906796e 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/lag_mp.c
@@ -296,7 +296,7 @@ int mlx5_lag_mp_init(struct mlx5_lag *ldev)
 		return 0;
 
 	mp->fib_nb.notifier_call = mlx5_lag_fib_event;
-	err = register_fib_notifier(&mp->fib_nb,
+	err = register_fib_notifier(&init_net, &mp->fib_nb,
 				    mlx5_lag_fib_event_flush);
 	if (err)
 		mp->fib_nb.notifier_call = NULL;
@@ -311,6 +311,6 @@ void mlx5_lag_mp_cleanup(struct mlx5_lag *ldev)
 	if (!mp->fib_nb.notifier_call)
 		return;
 
-	unregister_fib_notifier(&mp->fib_nb);
+	unregister_fib_notifier(&init_net, &mp->fib_nb);
 	mp->fib_nb.notifier_call = NULL;
 }
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 9e9609629563..58185ade0812 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@ -6212,7 +6212,7 @@ static int mlxsw_sp_router_fib_rule_event(unsigned long event,
 	rule = fr_info->rule;
 
 	/* Rule only affects locally generated traffic */
-	if (rule->iifindex == info->net->loopback_dev->ifindex)
+	if (rule->iifindex == init_net.loopback_dev->ifindex)
 		return 0;
 
 	switch (info->family) {
@@ -6249,8 +6249,7 @@ static int mlxsw_sp_router_fib_event(struct notifier_block *nb,
 	struct mlxsw_sp_router *router;
 	int err;
 
-	if (!net_eq(info->net, &init_net) ||
-	    (info->family != AF_INET && info->family != AF_INET6 &&
+	if ((info->family != AF_INET && info->family != AF_INET6 &&
 	     info->family != RTNL_FAMILY_IPMR &&
 	     info->family != RTNL_FAMILY_IP6MR))
 		return NOTIFY_DONE;
@@ -8132,7 +8131,7 @@ int mlxsw_sp_router_init(struct mlxsw_sp *mlxsw_sp)
 		goto err_dscp_init;
 
 	mlxsw_sp->router->fib_nb.notifier_call = mlxsw_sp_router_fib_event;
-	err = register_fib_notifier(&mlxsw_sp->router->fib_nb,
+	err = register_fib_notifier(&init_net, &mlxsw_sp->router->fib_nb,
 				    mlxsw_sp_router_fib_dump_flush);
 	if (err)
 		goto err_register_fib_notifier;
@@ -8172,7 +8171,7 @@ int mlxsw_sp_router_init(struct mlxsw_sp *mlxsw_sp)
 
 void mlxsw_sp_router_fini(struct mlxsw_sp *mlxsw_sp)
 {
-	unregister_fib_notifier(&mlxsw_sp->router->fib_nb);
+	unregister_fib_notifier(&init_net, &mlxsw_sp->router->fib_nb);
 	unregister_netevent_notifier(&mlxsw_sp->router->netevent_nb);
 	mlxsw_sp_neigh_fini(mlxsw_sp);
 	mlxsw_sp_vrs_fini(mlxsw_sp);
diff --git a/drivers/net/ethernet/rocker/rocker_main.c b/drivers/net/ethernet/rocker/rocker_main.c
index c06a7a50400c..9a504d78c71f 100644
--- a/drivers/net/ethernet/rocker/rocker_main.c
+++ b/drivers/net/ethernet/rocker/rocker_main.c
@@ -2999,7 +2999,7 @@ static int rocker_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	 * the device, so no need to pass a callback.
 	 */
 	rocker->fib_nb.notifier_call = rocker_router_fib_event;
-	err = register_fib_notifier(&rocker->fib_nb, NULL);
+	err = register_fib_notifier(&init_net, &rocker->fib_nb, NULL);
 	if (err)
 		goto err_register_fib_notifier;
 
@@ -3026,7 +3026,7 @@ static int rocker_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 err_register_switchdev_blocking_notifier:
 	unregister_switchdev_notifier(&rocker_switchdev_notifier);
 err_register_switchdev_notifier:
-	unregister_fib_notifier(&rocker->fib_nb);
+	unregister_fib_notifier(&init_net, &rocker->fib_nb);
 err_register_fib_notifier:
 	rocker_remove_ports(rocker);
 err_probe_ports:
@@ -3062,7 +3062,7 @@ static void rocker_remove(struct pci_dev *pdev)
 	unregister_switchdev_blocking_notifier(nb);
 
 	unregister_switchdev_notifier(&rocker_switchdev_notifier);
-	unregister_fib_notifier(&rocker->fib_nb);
+	unregister_fib_notifier(&init_net, &rocker->fib_nb);
 	rocker_remove_ports(rocker);
 	rocker_write32(rocker, CONTROL, ROCKER_CONTROL_RESET);
 	destroy_workqueue(rocker->rocker_owq);
* Unmerged path drivers/net/netdevsim/fib.c
diff --git a/include/linux/mroute_base.h b/include/linux/mroute_base.h
index b9c6c04d2ed3..1cb39127fcf7 100644
--- a/include/linux/mroute_base.h
+++ b/include/linux/mroute_base.h
@@ -47,7 +47,6 @@ struct vif_entry_notifier_info {
 };
 
 static inline int mr_call_vif_notifier(struct notifier_block *nb,
-				       struct net *net,
 				       unsigned short family,
 				       enum fib_event_type event_type,
 				       struct vif_device *vif,
@@ -56,7 +55,6 @@ static inline int mr_call_vif_notifier(struct notifier_block *nb,
 	struct vif_entry_notifier_info info = {
 		.info = {
 			.family = family,
-			.net = net,
 		},
 		.dev = vif->dev,
 		.vif_index = vif_index,
@@ -64,7 +62,7 @@ static inline int mr_call_vif_notifier(struct notifier_block *nb,
 		.tb_id = tb_id,
 	};
 
-	return call_fib_notifier(nb, net, event_type, &info.info);
+	return call_fib_notifier(nb, event_type, &info.info);
 }
 
 static inline int mr_call_vif_notifiers(struct net *net,
@@ -77,7 +75,6 @@ static inline int mr_call_vif_notifiers(struct net *net,
 	struct vif_entry_notifier_info info = {
 		.info = {
 			.family = family,
-			.net = net,
 		},
 		.dev = vif->dev,
 		.vif_index = vif_index,
@@ -173,7 +170,6 @@ struct mfc_entry_notifier_info {
 };
 
 static inline int mr_call_mfc_notifier(struct notifier_block *nb,
-				       struct net *net,
 				       unsigned short family,
 				       enum fib_event_type event_type,
 				       struct mr_mfc *mfc, u32 tb_id)
@@ -181,13 +177,12 @@ static inline int mr_call_mfc_notifier(struct notifier_block *nb,
 	struct mfc_entry_notifier_info info = {
 		.info = {
 			.family = family,
-			.net = net,
 		},
 		.mfc = mfc,
 		.tb_id = tb_id
 	};
 
-	return call_fib_notifier(nb, net, event_type, &info.info);
+	return call_fib_notifier(nb, event_type, &info.info);
 }
 
 static inline int mr_call_mfc_notifiers(struct net *net,
@@ -199,7 +194,6 @@ static inline int mr_call_mfc_notifiers(struct net *net,
 	struct mfc_entry_notifier_info info = {
 		.info = {
 			.family = family,
-			.net = net,
 		},
 		.mfc = mfc,
 		.tb_id = tb_id
diff --git a/include/net/fib_notifier.h b/include/net/fib_notifier.h
index c49d7bfb5c30..23353f67b2b0 100644
--- a/include/net/fib_notifier.h
+++ b/include/net/fib_notifier.h
@@ -8,7 +8,6 @@
 struct module;
 
 struct fib_notifier_info {
-	struct net *net;
 	int family;
 	struct netlink_ext_ack  *extack;
 };
@@ -35,14 +34,14 @@ struct fib_notifier_ops {
 	struct rcu_head rcu;
 };
 
-int call_fib_notifier(struct notifier_block *nb, struct net *net,
+int call_fib_notifier(struct notifier_block *nb,
 		      enum fib_event_type event_type,
 		      struct fib_notifier_info *info);
 int call_fib_notifiers(struct net *net, enum fib_event_type event_type,
 		       struct fib_notifier_info *info);
-int register_fib_notifier(struct notifier_block *nb,
+int register_fib_notifier(struct net *net, struct notifier_block *nb,
 			  void (*cb)(struct notifier_block *nb));
-int unregister_fib_notifier(struct notifier_block *nb);
+int unregister_fib_notifier(struct net *net, struct notifier_block *nb);
 struct fib_notifier_ops *
 fib_notifier_ops_register(const struct fib_notifier_ops *tmpl, struct net *net);
 void fib_notifier_ops_unregister(struct fib_notifier_ops *ops);
diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h
index 390067ba9e95..0a3c4cbf3811 100644
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@ -452,7 +452,7 @@ struct ipv6_route_iter {
 
 extern const struct seq_operations ipv6_route_seq_ops;
 
-int call_fib6_notifier(struct notifier_block *nb, struct net *net,
+int call_fib6_notifier(struct notifier_block *nb,
 		       enum fib_event_type event_type,
 		       struct fib_notifier_info *info);
 int call_fib6_notifiers(struct net *net, enum fib_event_type event_type,
diff --git a/include/net/ip_fib.h b/include/net/ip_fib.h
index cf0696685354..418149cff746 100644
--- a/include/net/ip_fib.h
+++ b/include/net/ip_fib.h
@@ -202,7 +202,7 @@ struct fib_nh_notifier_info {
 	struct fib_nh *fib_nh;
 };
 
-int call_fib4_notifier(struct notifier_block *nb, struct net *net,
+int call_fib4_notifier(struct notifier_block *nb,
 		       enum fib_event_type event_type,
 		       struct fib_notifier_info *info);
 int call_fib4_notifiers(struct net *net, enum fib_event_type event_type,
diff --git a/net/core/fib_notifier.c b/net/core/fib_notifier.c
index 470a606d5e8d..fbd029425638 100644
--- a/net/core/fib_notifier.c
+++ b/net/core/fib_notifier.c
@@ -12,17 +12,15 @@ static unsigned int fib_notifier_net_id;
 
 struct fib_notifier_net {
 	struct list_head fib_notifier_ops;
+	struct atomic_notifier_head fib_chain;
 };
 
-static ATOMIC_NOTIFIER_HEAD(fib_chain);
-
-int call_fib_notifier(struct notifier_block *nb, struct net *net,
+int call_fib_notifier(struct notifier_block *nb,
 		      enum fib_event_type event_type,
 		      struct fib_notifier_info *info)
 {
 	int err;
 
-	info->net = net;
 	err = nb->notifier_call(nb, event_type, info);
 	return notifier_to_errno(err);
 }
@@ -31,35 +29,29 @@ EXPORT_SYMBOL(call_fib_notifier);
 int call_fib_notifiers(struct net *net, enum fib_event_type event_type,
 		       struct fib_notifier_info *info)
 {
+	struct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);
 	int err;
 
-	info->net = net;
-	err = atomic_notifier_call_chain(&fib_chain, event_type, info);
+	err = atomic_notifier_call_chain(&fn_net->fib_chain, event_type, info);
 	return notifier_to_errno(err);
 }
 EXPORT_SYMBOL(call_fib_notifiers);
 
-static unsigned int fib_seq_sum(void)
+static unsigned int fib_seq_sum(struct net *net)
 {
-	struct fib_notifier_net *fn_net;
+	struct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);
 	struct fib_notifier_ops *ops;
 	unsigned int fib_seq = 0;
-	struct net *net;
 
 	rtnl_lock();
-	down_read(&net_rwsem);
-	for_each_net(net) {
-		fn_net = net_generic(net, fib_notifier_net_id);
-		rcu_read_lock();
-		list_for_each_entry_rcu(ops, &fn_net->fib_notifier_ops, list) {
-			if (!try_module_get(ops->owner))
-				continue;
-			fib_seq += ops->fib_seq_read(net);
-			module_put(ops->owner);
-		}
-		rcu_read_unlock();
+	rcu_read_lock();
+	list_for_each_entry_rcu(ops, &fn_net->fib_notifier_ops, list) {
+		if (!try_module_get(ops->owner))
+			continue;
+		fib_seq += ops->fib_seq_read(net);
+		module_put(ops->owner);
 	}
-	up_read(&net_rwsem);
+	rcu_read_unlock();
 	rtnl_unlock();
 
 	return fib_seq;
@@ -69,68 +61,66 @@ static int fib_net_dump(struct net *net, struct notifier_block *nb)
 {
 	struct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);
 	struct fib_notifier_ops *ops;
+	int err = 0;
 
+	rcu_read_lock();
 	list_for_each_entry_rcu(ops, &fn_net->fib_notifier_ops, list) {
-		int err;
-
 		if (!try_module_get(ops->owner))
 			continue;
 		err = ops->fib_dump(net, nb);
 		module_put(ops->owner);
 		if (err)
-			return err;
+			goto unlock;
 	}
 
-	return 0;
+unlock:
+	rcu_read_unlock();
+
+	return err;
 }
 
-static bool fib_dump_is_consistent(struct notifier_block *nb,
+static bool fib_dump_is_consistent(struct net *net, struct notifier_block *nb,
 				   void (*cb)(struct notifier_block *nb),
 				   unsigned int fib_seq)
 {
-	atomic_notifier_chain_register(&fib_chain, nb);
-	if (fib_seq == fib_seq_sum())
+	struct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);
+
+	atomic_notifier_chain_register(&fn_net->fib_chain, nb);
+	if (fib_seq == fib_seq_sum(net))
 		return true;
-	atomic_notifier_chain_unregister(&fib_chain, nb);
+	atomic_notifier_chain_unregister(&fn_net->fib_chain, nb);
 	if (cb)
 		cb(nb);
 	return false;
 }
 
 #define FIB_DUMP_MAX_RETRIES 5
-int register_fib_notifier(struct notifier_block *nb,
+int register_fib_notifier(struct net *net, struct notifier_block *nb,
 			  void (*cb)(struct notifier_block *nb))
 {
 	int retries = 0;
 	int err;
 
 	do {
-		unsigned int fib_seq = fib_seq_sum();
-		struct net *net;
-
-		rcu_read_lock();
-		for_each_net_rcu(net) {
-			err = fib_net_dump(net, nb);
-			if (err)
-				goto err_fib_net_dump;
-		}
-		rcu_read_unlock();
-
-		if (fib_dump_is_consistent(nb, cb, fib_seq))
+		unsigned int fib_seq = fib_seq_sum(net);
+
+		err = fib_net_dump(net, nb);
+		if (err)
+			return err;
+
+		if (fib_dump_is_consistent(net, nb, cb, fib_seq))
 			return 0;
 	} while (++retries < FIB_DUMP_MAX_RETRIES);
 
 	return -EBUSY;
-
-err_fib_net_dump:
-	rcu_read_unlock();
-	return err;
 }
 EXPORT_SYMBOL(register_fib_notifier);
 
-int unregister_fib_notifier(struct notifier_block *nb)
+int unregister_fib_notifier(struct net *net, struct notifier_block *nb)
 {
-	return atomic_notifier_chain_unregister(&fib_chain, nb);
+	struct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);
+
+	return atomic_notifier_chain_unregister(&fn_net->fib_chain, nb);
 }
 EXPORT_SYMBOL(unregister_fib_notifier);
 
@@ -181,6 +171,7 @@ static int __net_init fib_notifier_net_init(struct net *net)
 	struct fib_notifier_net *fn_net = net_generic(net, fib_notifier_net_id);
 
 	INIT_LIST_HEAD(&fn_net->fib_notifier_ops);
+	ATOMIC_INIT_NOTIFIER_HEAD(&fn_net->fib_chain);
 	return 0;
 }
 
diff --git a/net/core/fib_rules.c b/net/core/fib_rules.c
index 390d8b5d62ef..d217dbef22d6 100644
--- a/net/core/fib_rules.c
+++ b/net/core/fib_rules.c
@@ -324,7 +324,7 @@ int fib_rules_lookup(struct fib_rules_ops *ops, struct flowi *fl,
 }
 EXPORT_SYMBOL_GPL(fib_rules_lookup);
 
-static int call_fib_rule_notifier(struct notifier_block *nb, struct net *net,
+static int call_fib_rule_notifier(struct notifier_block *nb,
 				  enum fib_event_type event_type,
 				  struct fib_rule *rule, int family)
 {
@@ -333,7 +333,7 @@ static int call_fib_rule_notifier(struct notifier_block *nb, struct net *net,
 		.rule = rule,
 	};
 
-	return call_fib_notifier(nb, net, event_type, &info.info);
+	return call_fib_notifier(nb, event_type, &info.info);
 }
 
 static int call_fib_rule_notifiers(struct net *net,
@@ -362,8 +362,7 @@ int fib_rules_dump(struct net *net, struct notifier_block *nb, int family)
 	if (!ops)
 		return -EAFNOSUPPORT;
 	list_for_each_entry_rcu(rule, &ops->rules_list, list)
-		call_fib_rule_notifier(nb, net, FIB_EVENT_RULE_ADD, rule,
-				       family);
+		call_fib_rule_notifier(nb, FIB_EVENT_RULE_ADD, rule, family);
 	rules_ops_put(ops);
 
 	return 0;
diff --git a/net/ipv4/fib_notifier.c b/net/ipv4/fib_notifier.c
index b804ccbdb241..1a128c1346fb 100644
--- a/net/ipv4/fib_notifier.c
+++ b/net/ipv4/fib_notifier.c
@@ -9,12 +9,12 @@
 #include <net/netns/ipv4.h>
 #include <net/ip_fib.h>
 
-int call_fib4_notifier(struct notifier_block *nb, struct net *net,
+int call_fib4_notifier(struct notifier_block *nb,
 		       enum fib_event_type event_type,
 		       struct fib_notifier_info *info)
 {
 	info->family = AF_INET;
-	return call_fib_notifier(nb, net, event_type, info);
+	return call_fib_notifier(nb, event_type, info);
 }
 
 int call_fib4_notifiers(struct net *net, enum fib_event_type event_type,
* Unmerged path net/ipv4/fib_trie.c
diff --git a/net/ipv4/ipmr_base.c b/net/ipv4/ipmr_base.c
index ea48bd15a575..4dcc3214e3cc 100644
--- a/net/ipv4/ipmr_base.c
+++ b/net/ipv4/ipmr_base.c
@@ -409,7 +409,7 @@ int mr_dump(struct net *net, struct notifier_block *nb, unsigned short family,
 			if (!v->dev)
 				continue;
 
-			mr_call_vif_notifier(nb, net, family,
+			mr_call_vif_notifier(nb, family,
 					     FIB_EVENT_VIF_ADD,
 					     v, vifi, mrt->id);
 		}
@@ -417,7 +417,7 @@ int mr_dump(struct net *net, struct notifier_block *nb, unsigned short family,
 
 		/* Notify on table MFC entries */
 		list_for_each_entry_rcu(mfc, &mrt->mfc_cache_list, list)
-			mr_call_mfc_notifier(nb, net, family,
+			mr_call_mfc_notifier(nb, family,
 					     FIB_EVENT_ENTRY_ADD,
 					     mfc, mrt->id);
 	}
diff --git a/net/ipv6/fib6_notifier.c b/net/ipv6/fib6_notifier.c
index 05f82baaa99e..4fe79296999a 100644
--- a/net/ipv6/fib6_notifier.c
+++ b/net/ipv6/fib6_notifier.c
@@ -7,12 +7,12 @@
 #include <net/netns/ipv6.h>
 #include <net/ip6_fib.h>
 
-int call_fib6_notifier(struct notifier_block *nb, struct net *net,
+int call_fib6_notifier(struct notifier_block *nb,
 		       enum fib_event_type event_type,
 		       struct fib_notifier_info *info)
 {
 	info->family = AF_INET6;
-	return call_fib_notifier(nb, net, event_type, info);
+	return call_fib_notifier(nb, event_type, info);
 }
 
 int call_fib6_notifiers(struct net *net, enum fib_event_type event_type,
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index 246c67f714a3..505223caef57 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -390,7 +390,7 @@ unsigned int fib6_tables_seq_read(struct net *net)
 	return fib_seq;
 }
 
-static int call_fib6_entry_notifier(struct notifier_block *nb, struct net *net,
+static int call_fib6_entry_notifier(struct notifier_block *nb,
 				    enum fib_event_type event_type,
 				    struct fib6_info *rt)
 {
@@ -398,7 +398,7 @@ static int call_fib6_entry_notifier(struct notifier_block *nb, struct net *net,
 		.rt = rt,
 	};
 
-	return call_fib6_notifier(nb, net, event_type, &info.info);
+	return call_fib6_notifier(nb, event_type, &info.info);
 }
 
 static int call_fib6_entry_notifiers(struct net *net,
@@ -424,7 +424,7 @@ static void fib6_rt_dump(struct fib6_info *rt, struct fib6_dump_arg *arg)
 {
 	if (rt == arg->net->ipv6.fib6_null_entry)
 		return;
-	call_fib6_entry_notifier(arg->nb, arg->net, FIB_EVENT_ENTRY_ADD, rt);
+	call_fib6_entry_notifier(arg->nb, FIB_EVENT_ENTRY_ADD, rt);
 }
 
 static int fib6_node_dump(struct fib6_walker *w)
