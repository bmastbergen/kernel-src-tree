ipv6: Add "offload" and "trap" indications to routes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ido Schimmel <idosch@mellanox.com>
commit bb3c4ab93e44784c1e958bdbba7824bba40f23cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/bb3c4ab9.failed

In a similar fashion to previous patch, add "offload" and "trap"
indication to IPv6 routes.

This is done by using two unused bits in 'struct fib6_info' to hold
these indications. Capable drivers are expected to set these when
processing the various in-kernel route notifications.

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Reviewed-by: Jiri Pirko <jiri@mellanox.com>
	Reviewed-by: David Ahern <dsahern@gmail.com>
	Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bb3c4ab93e44784c1e958bdbba7824bba40f23cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip6_fib.h
diff --cc include/net/ip6_fib.h
index 390067ba9e95,fd60a8ac02ee..000000000000
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@@ -171,15 -191,14 +171,21 @@@ struct fib6_info 
  					dst_nocount:1,
  					dst_nopolicy:1,
  					dst_host:1,
 +#ifndef __GENKSYMS__
  					fib6_destroying:1,
++<<<<<<< HEAD
 +					unused:2;
 +#else
 +					unused:3;
 +#endif
++=======
+ 					offload:1,
+ 					trap:1,
+ 					unused:1;
++>>>>>>> bb3c4ab93e44 (ipv6: Add "offload" and "trap" indications to routes)
  
 +	struct fib6_nh			fib6_nh;
  	struct rcu_head			rcu;
 -	struct nexthop			*nh;
 -	struct fib6_nh			fib6_nh[0];
  };
  
  struct rt6_info {
* Unmerged path include/net/ip6_fib.h
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index f5ddf61a52e6..fff1eb1605f2 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -4945,6 +4945,13 @@ static int rt6_fill_node(struct net *net, struct sk_buff *skb,
 		expires -= jiffies;
 	}
 
+	if (!dst) {
+		if (rt->offload)
+			rtm->rtm_flags |= RTM_F_OFFLOAD;
+		if (rt->trap)
+			rtm->rtm_flags |= RTM_F_TRAP;
+	}
+
 	if (rtnl_put_cacheinfo(skb, dst, 0, expires, dst ? dst->error : 0) < 0)
 		goto nla_put_failure;
 
