bpftool, selftests/bpf: Embed object file inside skeleton

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 5dc7a8b2114479fd945956ece9875f747a996a8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/5dc7a8b2.failed

Embed contents of BPF object file used for BPF skeleton generation inside
skeleton itself. This allows to keep BPF object file and its skeleton in sync
at all times, and simpifies skeleton instantiation.

Also switch existing selftests to not require BPF_EMBED_OBJ anymore.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Yonghong Song <yhs@fb.com>
Link: https://lore.kernel.org/bpf/20191218052552.2915188-2-andriin@fb.com
(cherry picked from commit 5dc7a8b2114479fd945956ece9875f747a996a8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/prog_tests/attach_probe.c
#	tools/testing/selftests/bpf/prog_tests/fentry_fexit.c
#	tools/testing/selftests/bpf/prog_tests/fentry_test.c
#	tools/testing/selftests/bpf/prog_tests/mmap.c
#	tools/testing/selftests/bpf/prog_tests/stacktrace_build_id.c
#	tools/testing/selftests/bpf/prog_tests/stacktrace_build_id_nmi.c
diff --cc tools/testing/selftests/bpf/prog_tests/attach_probe.c
index fad615c22e4d,5ed90ede2f1d..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/attach_probe.c
+++ b/tools/testing/selftests/bpf/prog_tests/attach_probe.c
@@@ -49,35 -37,13 +49,40 @@@ void test_attach_probe(void
  		return;
  	uprobe_offset = (size_t)&get_base_addr - base_addr;
  
++<<<<<<< HEAD
 +	/* load programs */
 +	err = bpf_prog_load(file, BPF_PROG_TYPE_KPROBE, &obj, &prog_fd);
 +	if (CHECK(err, "obj_load", "err %d errno %d\n", err, errno))
++=======
+ 	skel = test_attach_probe__open_and_load();
+ 	if (CHECK(!skel, "skel_open", "failed to open skeleton\n"))
++>>>>>>> 5dc7a8b21144 (bpftool, selftests/bpf: Embed object file inside skeleton)
  		return;
 -	if (CHECK(!skel->bss, "check_bss", ".bss wasn't mmap()-ed\n"))
 +
 +	kprobe_prog = bpf_object__find_program_by_title(obj, kprobe_name);
 +	if (CHECK(!kprobe_prog, "find_probe",
 +		  "prog '%s' not found\n", kprobe_name))
 +		goto cleanup;
 +	kretprobe_prog = bpf_object__find_program_by_title(obj, kretprobe_name);
 +	if (CHECK(!kretprobe_prog, "find_probe",
 +		  "prog '%s' not found\n", kretprobe_name))
 +		goto cleanup;
 +	uprobe_prog = bpf_object__find_program_by_title(obj, uprobe_name);
 +	if (CHECK(!uprobe_prog, "find_probe",
 +		  "prog '%s' not found\n", uprobe_name))
 +		goto cleanup;
 +	uretprobe_prog = bpf_object__find_program_by_title(obj, uretprobe_name);
 +	if (CHECK(!uretprobe_prog, "find_probe",
 +		  "prog '%s' not found\n", uretprobe_name))
 +		goto cleanup;
 +
 +	/* load maps */
 +	results_map_fd = bpf_find_map(__func__, obj, "results_map");
 +	if (CHECK(results_map_fd < 0, "find_results_map",
 +		  "err %d\n", results_map_fd))
  		goto cleanup;
  
 -	kprobe_link = bpf_program__attach_kprobe(skel->progs.handle_kprobe,
 +	kprobe_link = bpf_program__attach_kprobe(kprobe_prog,
  						 false /* retprobe */,
  						 SYS_NANOSLEEP_KPROBE_NAME);
  	if (CHECK(IS_ERR(kprobe_link), "attach_kprobe",
diff --cc tools/testing/selftests/bpf/prog_tests/fentry_fexit.c
index 40bcff2cc274,235ac4f67f5b..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/fentry_fexit.c
+++ b/tools/testing/selftests/bpf/prog_tests/fentry_fexit.c
@@@ -1,64 -1,37 +1,81 @@@
  // SPDX-License-Identifier: GPL-2.0
  /* Copyright (c) 2019 Facebook */
  #include <test_progs.h>
++<<<<<<< HEAD
++=======
+ #include "test_pkt_access.skel.h"
+ #include "fentry_test.skel.h"
+ #include "fexit_test.skel.h"
++>>>>>>> 5dc7a8b21144 (bpftool, selftests/bpf: Embed object file inside skeleton)
  
  void test_fentry_fexit(void)
  {
 -	struct test_pkt_access *pkt_skel = NULL;
 -	struct fentry_test *fentry_skel = NULL;
 -	struct fexit_test *fexit_skel = NULL;
 -	__u64 *fentry_res, *fexit_res;
 -	__u32 duration = 0, retval;
 -	int err, pkt_fd, i;
 +	struct bpf_prog_load_attr attr_fentry = {
 +		.file = "./fentry_test.o",
 +	};
 +	struct bpf_prog_load_attr attr_fexit = {
 +		.file = "./fexit_test.o",
 +	};
  
++<<<<<<< HEAD
 +	struct bpf_object *obj_fentry = NULL, *obj_fexit = NULL, *pkt_obj;
 +	struct bpf_map *data_map_fentry, *data_map_fexit;
 +	char fentry_name[] = "fentry/bpf_fentry_testX";
 +	char fexit_name[] = "fexit/bpf_fentry_testX";
 +	int err, pkt_fd, kfree_skb_fd, i;
 +	struct bpf_link *link[12] = {};
 +	struct bpf_program *prog[12];
 +	__u32 duration, retval;
 +	const int zero = 0;
 +	u64 result[12];
 +
 +	err = bpf_prog_load("./test_pkt_access.o", BPF_PROG_TYPE_SCHED_CLS,
 +			    &pkt_obj, &pkt_fd);
 +	if (CHECK(err, "prog_load sched cls", "err %d errno %d\n", err, errno))
 +		return;
 +	err = bpf_prog_load_xattr(&attr_fentry, &obj_fentry, &kfree_skb_fd);
 +	if (CHECK(err, "prog_load fail", "err %d errno %d\n", err, errno))
 +		goto close_prog;
 +	err = bpf_prog_load_xattr(&attr_fexit, &obj_fexit, &kfree_skb_fd);
 +	if (CHECK(err, "prog_load fail", "err %d errno %d\n", err, errno))
++=======
+ 	pkt_skel = test_pkt_access__open_and_load();
+ 	if (CHECK(!pkt_skel, "pkt_skel_load", "pkt_access skeleton failed\n"))
+ 		return;
+ 	fentry_skel = fentry_test__open_and_load();
+ 	if (CHECK(!fentry_skel, "fentry_skel_load", "fentry skeleton failed\n"))
+ 		goto close_prog;
+ 	fexit_skel = fexit_test__open_and_load();
+ 	if (CHECK(!fexit_skel, "fexit_skel_load", "fexit skeleton failed\n"))
++>>>>>>> 5dc7a8b21144 (bpftool, selftests/bpf: Embed object file inside skeleton)
  		goto close_prog;
  
 -	err = fentry_test__attach(fentry_skel);
 -	if (CHECK(err, "fentry_attach", "fentry attach failed: %d\n", err))
 +	for (i = 0; i < 6; i++) {
 +		fentry_name[sizeof(fentry_name) - 2] = '1' + i;
 +		prog[i] = bpf_object__find_program_by_title(obj_fentry, fentry_name);
 +		if (CHECK(!prog[i], "find_prog", "prog %s not found\n", fentry_name))
 +			goto close_prog;
 +		link[i] = bpf_program__attach_trace(prog[i]);
 +		if (CHECK(IS_ERR(link[i]), "attach_trace", "failed to link\n"))
 +			goto close_prog;
 +	}
 +	data_map_fentry = bpf_object__find_map_by_name(obj_fentry, "fentry_t.bss");
 +	if (CHECK(!data_map_fentry, "find_data_map", "data map not found\n"))
  		goto close_prog;
 -	err = fexit_test__attach(fexit_skel);
 -	if (CHECK(err, "fexit_attach", "fexit attach failed: %d\n", err))
 +
 +	for (i = 6; i < 12; i++) {
 +		fexit_name[sizeof(fexit_name) - 2] = '1' + i - 6;
 +		prog[i] = bpf_object__find_program_by_title(obj_fexit, fexit_name);
 +		if (CHECK(!prog[i], "find_prog", "prog %s not found\n", fexit_name))
 +			goto close_prog;
 +		link[i] = bpf_program__attach_trace(prog[i]);
 +		if (CHECK(IS_ERR(link[i]), "attach_trace", "failed to link\n"))
 +			goto close_prog;
 +	}
 +	data_map_fexit = bpf_object__find_map_by_name(obj_fexit, "fexit_te.bss");
 +	if (CHECK(!data_map_fexit, "find_data_map", "data map not found\n"))
  		goto close_prog;
  
 -	pkt_fd = bpf_program__fd(pkt_skel->progs.test_pkt_access);
  	err = bpf_prog_test_run(pkt_fd, 1, &pkt_v6, sizeof(pkt_v6),
  				NULL, NULL, &retval, &duration);
  	CHECK(err || retval, "ipv6",
diff --cc tools/testing/selftests/bpf/prog_tests/fentry_test.c
index 9fb103193878,e1a379f5f7d2..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/fentry_test.c
+++ b/tools/testing/selftests/bpf/prog_tests/fentry_test.c
@@@ -1,44 -1,29 +1,58 @@@
  // SPDX-License-Identifier: GPL-2.0
  /* Copyright (c) 2019 Facebook */
  #include <test_progs.h>
++<<<<<<< HEAD
++=======
+ #include "test_pkt_access.skel.h"
+ #include "fentry_test.skel.h"
++>>>>>>> 5dc7a8b21144 (bpftool, selftests/bpf: Embed object file inside skeleton)
  
  void test_fentry_test(void)
  {
 -	struct test_pkt_access *pkt_skel = NULL;
 -	struct fentry_test *fentry_skel = NULL;
 -	int err, pkt_fd, i;
 +	struct bpf_prog_load_attr attr = {
 +		.file = "./fentry_test.o",
 +	};
 +
 +	char prog_name[] = "fentry/bpf_fentry_testX";
 +	struct bpf_object *obj = NULL, *pkt_obj;
 +	int err, pkt_fd, kfree_skb_fd, i;
 +	struct bpf_link *link[6] = {};
 +	struct bpf_program *prog[6];
  	__u32 duration, retval;
 -	__u64 *result;
 +	struct bpf_map *data_map;
 +	const int zero = 0;
 +	u64 result[6];
  
++<<<<<<< HEAD
 +	err = bpf_prog_load("./test_pkt_access.o", BPF_PROG_TYPE_SCHED_CLS,
 +			    &pkt_obj, &pkt_fd);
 +	if (CHECK(err, "prog_load sched cls", "err %d errno %d\n", err, errno))
 +		return;
 +	err = bpf_prog_load_xattr(&attr, &obj, &kfree_skb_fd);
 +	if (CHECK(err, "prog_load fail", "err %d errno %d\n", err, errno))
 +		goto close_prog;
++=======
+ 	pkt_skel = test_pkt_access__open_and_load();
+ 	if (CHECK(!pkt_skel, "pkt_skel_load", "pkt_access skeleton failed\n"))
+ 		return;
+ 	fentry_skel = fentry_test__open_and_load();
+ 	if (CHECK(!fentry_skel, "fentry_skel_load", "fentry skeleton failed\n"))
+ 		goto cleanup;
++>>>>>>> 5dc7a8b21144 (bpftool, selftests/bpf: Embed object file inside skeleton)
  
 -	err = fentry_test__attach(fentry_skel);
 -	if (CHECK(err, "fentry_attach", "fentry attach failed: %d\n", err))
 -		goto cleanup;
 +	for (i = 0; i < 6; i++) {
 +		prog_name[sizeof(prog_name) - 2] = '1' + i;
 +		prog[i] = bpf_object__find_program_by_title(obj, prog_name);
 +		if (CHECK(!prog[i], "find_prog", "prog %s not found\n", prog_name))
 +			goto close_prog;
 +		link[i] = bpf_program__attach_trace(prog[i]);
 +		if (CHECK(IS_ERR(link[i]), "attach_trace", "failed to link\n"))
 +			goto close_prog;
 +	}
 +	data_map = bpf_object__find_map_by_name(obj, "fentry_t.bss");
 +	if (CHECK(!data_map, "find_data_map", "data map not found\n"))
 +		goto close_prog;
  
 -	pkt_fd = bpf_program__fd(pkt_skel->progs.test_pkt_access);
  	err = bpf_prog_test_run(pkt_fd, 1, &pkt_v6, sizeof(pkt_v6),
  				NULL, NULL, &retval, &duration);
  	CHECK(err || retval, "ipv6",
diff --cc tools/testing/selftests/bpf/prog_tests/mmap.c
index 051a6d48762c,16a814eb4d64..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/mmap.c
+++ b/tools/testing/selftests/bpf/prog_tests/mmap.c
@@@ -27,33 -20,20 +27,39 @@@ void test_mmap(void
  	const int zero = 0, one = 1, two = 2, far = 1500;
  	const long page_size = sysconf(_SC_PAGE_SIZE);
  	int err, duration = 0, i, data_map_fd;
 +	struct bpf_program *prog;
 +	struct bpf_object *obj;
 +	struct bpf_link *link = NULL;
  	struct bpf_map *data_map, *bss_map;
  	void *bss_mmaped = NULL, *map_mmaped = NULL, *tmp1, *tmp2;
 -	struct test_mmap__bss *bss_data;
 -	struct map_data *map_data;
 -	struct test_mmap *skel;
 +	volatile struct bss_data *bss_data;
 +	volatile struct map_data *map_data;
  	__u64 val = 0;
  
++<<<<<<< HEAD
 +	obj = bpf_object__open_file("test_mmap.o", NULL);
 +	if (CHECK(IS_ERR(obj), "obj_open", "failed to open '%s': %ld\n",
 +		  file, PTR_ERR(obj)))
++=======
+ 
+ 	skel = test_mmap__open_and_load();
+ 	if (CHECK(!skel, "skel_open_and_load", "skeleton open/load failed\n"))
++>>>>>>> 5dc7a8b21144 (bpftool, selftests/bpf: Embed object file inside skeleton)
  		return;
 +	prog = bpf_object__find_program_by_title(obj, probe_name);
 +	if (CHECK(!prog, "find_probe", "prog '%s' not found\n", probe_name))
 +		goto cleanup;
 +	err = bpf_object__load(obj);
 +	if (CHECK(err, "obj_load", "failed to load prog '%s': %d\n",
 +		  probe_name, err))
 +		goto cleanup;
  
 -	bss_map = skel->maps.bss;
 -	data_map = skel->maps.data_map;
 +	bss_map = bpf_object__find_map_by_name(obj, "test_mma.bss");
 +	if (CHECK(!bss_map, "find_bss_map", ".bss map not found\n"))
 +		goto cleanup;
 +	data_map = bpf_object__find_map_by_name(obj, "data_map");
 +	if (CHECK(!data_map, "find_data_map", "data_map map not found\n"))
 +		goto cleanup;
  	data_map_fd = bpf_map__fd(data_map);
  
  	bss_mmaped = mmap(NULL, bss_sz, PROT_READ | PROT_WRITE, MAP_SHARED,
diff --cc tools/testing/selftests/bpf/prog_tests/stacktrace_build_id.c
index ac44fda84833,e8399ae50e77..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/stacktrace_build_id.c
+++ b/tools/testing/selftests/bpf/prog_tests/stacktrace_build_id.c
@@@ -1,5 -1,6 +1,9 @@@
  // SPDX-License-Identifier: GPL-2.0
  #include <test_progs.h>
++<<<<<<< HEAD
++=======
+ #include "test_stacktrace_build_id.skel.h"
++>>>>>>> 5dc7a8b21144 (bpftool, selftests/bpf: Embed object file inside skeleton)
  
  void test_stacktrace_build_id(void)
  {
@@@ -18,42 -16,24 +22,47 @@@
  	int retry = 1;
  
  retry:
++<<<<<<< HEAD
 +	err = bpf_prog_load(file, BPF_PROG_TYPE_TRACEPOINT, &obj, &prog_fd);
 +	if (CHECK(err, "prog_load", "err %d errno %d\n", err, errno))
++=======
+ 	skel = test_stacktrace_build_id__open_and_load();
+ 	if (CHECK(!skel, "skel_open_and_load", "skeleton open/load failed\n"))
++>>>>>>> 5dc7a8b21144 (bpftool, selftests/bpf: Embed object file inside skeleton)
  		return;
  
 -	err = test_stacktrace_build_id__attach(skel);
 -	if (CHECK(err, "attach_tp", "err %d\n", err))
 -		goto cleanup;
 +	prog = bpf_object__find_program_by_title(obj, prog_name);
 +	if (CHECK(!prog, "find_prog", "prog '%s' not found\n", prog_name))
 +		goto close_prog;
 +
 +	link = bpf_program__attach_tracepoint(prog, "random", "urandom_read");
 +	if (CHECK(IS_ERR(link), "attach_tp", "err %ld\n", PTR_ERR(link)))
 +		goto close_prog;
  
  	/* find map fds */
 -	control_map_fd = bpf_map__fd(skel->maps.control_map);
 -	stackid_hmap_fd = bpf_map__fd(skel->maps.stackid_hmap);
 -	stackmap_fd = bpf_map__fd(skel->maps.stackmap);
 -	stack_amap_fd = bpf_map__fd(skel->maps.stack_amap);
 -
 -	if (CHECK_FAIL(system("dd if=/dev/urandom of=/dev/zero count=4 2> /dev/null")))
 -		goto cleanup;
 -	if (CHECK_FAIL(system("./urandom_read")))
 -		goto cleanup;
 +	control_map_fd = bpf_find_map(__func__, obj, "control_map");
 +	if (CHECK(control_map_fd < 0, "bpf_find_map control_map",
 +		  "err %d errno %d\n", err, errno))
 +		goto disable_pmu;
 +
 +	stackid_hmap_fd = bpf_find_map(__func__, obj, "stackid_hmap");
 +	if (CHECK(stackid_hmap_fd < 0, "bpf_find_map stackid_hmap",
 +		  "err %d errno %d\n", err, errno))
 +		goto disable_pmu;
 +
 +	stackmap_fd = bpf_find_map(__func__, obj, "stackmap");
 +	if (CHECK(stackmap_fd < 0, "bpf_find_map stackmap", "err %d errno %d\n",
 +		  err, errno))
 +		goto disable_pmu;
 +
 +	stack_amap_fd = bpf_find_map(__func__, obj, "stack_amap");
 +	if (CHECK(stack_amap_fd < 0, "bpf_find_map stack_amap",
 +		  "err %d errno %d\n", err, errno))
 +		goto disable_pmu;
 +
 +	assert(system("dd if=/dev/urandom of=/dev/zero count=4 2> /dev/null")
 +	       == 0);
 +	assert(system("./urandom_read") == 0);
  	/* disable stack trace collection */
  	key = 0;
  	val = 1;
diff --cc tools/testing/selftests/bpf/prog_tests/stacktrace_build_id_nmi.c
index 9557b7dfb782,8974450a4bdb..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/stacktrace_build_id_nmi.c
+++ b/tools/testing/selftests/bpf/prog_tests/stacktrace_build_id_nmi.c
@@@ -38,13 -35,16 +38,18 @@@ void test_stacktrace_build_id_nmi(void
  	attr.sample_freq = read_perf_max_sample_freq();
  
  retry:
++<<<<<<< HEAD
 +	err = bpf_prog_load(file, BPF_PROG_TYPE_PERF_EVENT, &obj, &prog_fd);
 +	if (CHECK(err, "prog_load", "err %d errno %d\n", err, errno))
++=======
+ 	skel = test_stacktrace_build_id__open();
+ 	if (CHECK(!skel, "skel_open", "skeleton open failed\n"))
++>>>>>>> 5dc7a8b21144 (bpftool, selftests/bpf: Embed object file inside skeleton)
  		return;
  
 -	/* override program type */
 -	bpf_program__set_perf_event(skel->progs.oncpu);
 -
 -	err = test_stacktrace_build_id__load(skel);
 -	if (CHECK(err, "skel_load", "skeleton load failed: %d\n", err))
 -		goto cleanup;
 +	prog = bpf_object__find_program_by_title(obj, prog_name);
 +	if (CHECK(!prog, "find_prog", "prog '%s' not found\n", prog_name))
 +		goto close_prog;
  
  	pmu_fd = syscall(__NR_perf_event_open, &attr, -1 /* pid */,
  			 0 /* cpu 0 */, -1 /* group id */,
diff --git a/tools/bpf/bpftool/gen.c b/tools/bpf/bpftool/gen.c
index fbac89cefb31..c8a8af340425 100644
--- a/tools/bpf/bpftool/gen.c
+++ b/tools/bpf/bpftool/gen.c
@@ -16,6 +16,7 @@
 #include <libbpf.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <sys/mman.h>
 #include <unistd.h>
 
 #include "btf.h"
@@ -257,14 +258,16 @@ static int codegen(const char *template, ...)
 static int do_skeleton(int argc, char **argv)
 {
 	char header_guard[MAX_OBJ_NAME_LEN + sizeof("__SKEL_H__")];
-	size_t i, map_cnt = 0, prog_cnt = 0;
-	char obj_name[MAX_OBJ_NAME_LEN];
+	size_t i, map_cnt = 0, prog_cnt = 0, file_sz, mmap_sz;
+	DECLARE_LIBBPF_OPTS(bpf_object_open_opts, opts);
+	char obj_name[MAX_OBJ_NAME_LEN], *obj_data;
+	struct bpf_object *obj = NULL;
 	const char *file, *ident;
 	struct bpf_program *prog;
-	struct bpf_object *obj;
+	int fd, len, err = -1;
 	struct bpf_map *map;
 	struct btf *btf;
-	int err = -1;
+	struct stat st;
 
 	if (!REQ_ARGS(1)) {
 		usage();
@@ -277,14 +280,31 @@ static int do_skeleton(int argc, char **argv)
 		return -1;
 	}
 
-	obj = bpf_object__open_file(file, NULL);
-	if (IS_ERR(obj)) {
-		p_err("failed to open BPF object file: %ld", PTR_ERR(obj));
+	if (stat(file, &st)) {
+		p_err("failed to stat() %s: %s", file, strerror(errno));
 		return -1;
 	}
-
+	file_sz = st.st_size;
+	mmap_sz = roundup(file_sz, sysconf(_SC_PAGE_SIZE));
+	fd = open(file, O_RDONLY);
+	if (fd < 0) {
+		p_err("failed to open() %s: %s", file, strerror(errno));
+		return -1;
+	}
+	obj_data = mmap(NULL, mmap_sz, PROT_READ, MAP_PRIVATE, fd, 0);
+	if (obj_data == MAP_FAILED) {
+		obj_data = NULL;
+		p_err("failed to mmap() %s: %s", file, strerror(errno));
+		goto out;
+	}
 	get_obj_name(obj_name, file);
-	get_header_guard(header_guard, obj_name);
+	opts.object_name = obj_name;
+	obj = bpf_object__open_mem(obj_data, file_sz, &opts);
+	if (IS_ERR(obj)) {
+		obj = NULL;
+		p_err("failed to open BPF object file: %ld", PTR_ERR(obj));
+		goto out;
+	}
 
 	bpf_object__for_each_map(map, obj) {
 		ident = get_map_ident(map);
@@ -299,8 +319,11 @@ static int do_skeleton(int argc, char **argv)
 		prog_cnt++;
 	}
 
+	get_header_guard(header_guard, obj_name);
 	codegen("\
 		\n\
+		/* SPDX-License-Identifier: (LGPL-2.1 OR BSD-2-Clause) */   \n\
+									    \n\
 		/* THIS FILE IS AUTOGENERATED! */			    \n\
 		#ifndef %2$s						    \n\
 		#define %2$s						    \n\
@@ -352,19 +375,95 @@ static int do_skeleton(int argc, char **argv)
 		\n\
 		};							    \n\
 									    \n\
-		static inline struct bpf_object_skeleton *		    \n\
-		%1$s__create_skeleton(struct %1$s *obj, struct bpf_embed_data *embed)\n\
+		static void						    \n\
+		%1$s__destroy(struct %1$s *obj)				    \n\
+		{							    \n\
+			if (!obj)					    \n\
+				return;					    \n\
+			if (obj->skeleton)				    \n\
+				bpf_object__destroy_skeleton(obj->skeleton);\n\
+			free(obj);					    \n\
+		}							    \n\
+									    \n\
+		static inline int					    \n\
+		%1$s__create_skeleton(struct %1$s *obj);		    \n\
+									    \n\
+		static inline struct %1$s *				    \n\
+		%1$s__open_opts(const struct bpf_object_open_opts *opts)    \n\
+		{							    \n\
+			struct %1$s *obj;				    \n\
+									    \n\
+			obj = calloc(1, sizeof(*obj));			    \n\
+			if (!obj)					    \n\
+				return NULL;				    \n\
+			if (%1$s__create_skeleton(obj))			    \n\
+				goto err;				    \n\
+			if (bpf_object__open_skeleton(obj->skeleton, opts)) \n\
+				goto err;				    \n\
+									    \n\
+			return obj;					    \n\
+		err:							    \n\
+			%1$s__destroy(obj);				    \n\
+			return NULL;					    \n\
+		}							    \n\
+									    \n\
+		static inline struct %1$s *				    \n\
+		%1$s__open(void)					    \n\
+		{							    \n\
+			return %1$s__open_opts(NULL);			    \n\
+		}							    \n\
+									    \n\
+		static inline int					    \n\
+		%1$s__load(struct %1$s *obj)				    \n\
+		{							    \n\
+			return bpf_object__load_skeleton(obj->skeleton);    \n\
+		}							    \n\
+									    \n\
+		static inline struct %1$s *				    \n\
+		%1$s__open_and_load(void)				    \n\
+		{							    \n\
+			struct %1$s *obj;				    \n\
+									    \n\
+			obj = %1$s__open();				    \n\
+			if (!obj)					    \n\
+				return NULL;				    \n\
+			if (%1$s__load(obj)) {				    \n\
+				%1$s__destroy(obj);			    \n\
+				return NULL;				    \n\
+			}						    \n\
+			return obj;					    \n\
+		}							    \n\
+									    \n\
+		static inline int					    \n\
+		%1$s__attach(struct %1$s *obj)				    \n\
+		{							    \n\
+			return bpf_object__attach_skeleton(obj->skeleton);  \n\
+		}							    \n\
+									    \n\
+		static inline void					    \n\
+		%1$s__detach(struct %1$s *obj)				    \n\
+		{							    \n\
+			return bpf_object__detach_skeleton(obj->skeleton);  \n\
+		}							    \n\
+		",
+		obj_name
+	);
+
+	codegen("\
+		\n\
+									    \n\
+		static inline int					    \n\
+		%1$s__create_skeleton(struct %1$s *obj)			    \n\
 		{							    \n\
 			struct bpf_object_skeleton *s;			    \n\
 									    \n\
 			s = calloc(1, sizeof(*s));			    \n\
 			if (!s)						    \n\
-				return NULL;				    \n\
+				return -1;				    \n\
+			obj->skeleton = s;				    \n\
 									    \n\
 			s->sz = sizeof(*s);				    \n\
 			s->name = \"%1$s\";				    \n\
-			s->data = embed->data;				    \n\
-			s->data_sz = embed->size;			    \n\
 			s->obj = &obj->obj;				    \n\
 		",
 		obj_name
@@ -434,90 +533,45 @@ static int do_skeleton(int argc, char **argv)
 	codegen("\
 		\n\
 									    \n\
-			return s;					    \n\
-		err:							    \n\
-			bpf_object__destroy_skeleton(s);		    \n\
-			return NULL;					    \n\
-		}							    \n\
-									    \n\
-		static void						    \n\
-		%1$s__destroy(struct %1$s *obj)				    \n\
-		{							    \n\
-			if (!obj)					    \n\
-				return;					    \n\
-			if (obj->skeleton)				    \n\
-				bpf_object__destroy_skeleton(obj->skeleton);\n\
-			free(obj);					    \n\
-		}							    \n\
-									    \n\
-		static inline struct %1$s *				    \n\
-		%1$s__open_opts(struct bpf_embed_data *embed, const struct bpf_object_open_opts *opts)\n\
-		{							    \n\
-			struct %1$s *obj;				    \n\
-									    \n\
-			obj = calloc(1, sizeof(*obj));			    \n\
-			if (!obj)					    \n\
-				return NULL;				    \n\
-									    \n\
-			obj->skeleton = %1$s__create_skeleton(obj, embed);  \n\
-			if (!obj->skeleton)				    \n\
-				goto err;				    \n\
-									    \n\
-			if (bpf_object__open_skeleton(obj->skeleton, opts)) \n\
-				goto err;				    \n\
+			s->data_sz = %d;				    \n\
+			s->data = \"\\					    \n\
+		",
+		file_sz);
+
+	/* embed contents of BPF object file */
+	for (i = 0, len = 0; i < file_sz; i++) {
+		int w = obj_data[i] ? 4 : 2;
+
+		len += w;
+		if (len > 78) {
+			printf("\\\n");
+			len = w;
+		}
+		if (!obj_data[i])
+			printf("\\0");
+		else
+			printf("\\x%02x", (unsigned char)obj_data[i]);
+	}
+
+	codegen("\
+		\n\
+		\";							    \n\
 									    \n\
-			return obj;					    \n\
+			return 0;					    \n\
 		err:							    \n\
-			%1$s__destroy(obj);				    \n\
-			return NULL;					    \n\
-		}							    \n\
-									    \n\
-		static inline struct %1$s *				    \n\
-		%1$s__open(struct bpf_embed_data *embed)		    \n\
-		{							    \n\
-			return %1$s__open_opts(embed, NULL);		    \n\
-		}							    \n\
-									    \n\
-		static inline int					    \n\
-		%1$s__load(struct %1$s *obj)				    \n\
-		{							    \n\
-			return bpf_object__load_skeleton(obj->skeleton);    \n\
-		}							    \n\
-									    \n\
-		static inline struct %1$s *				    \n\
-		%1$s__open_and_load(struct bpf_embed_data *embed)	    \n\
-		{							    \n\
-			struct %1$s *obj;				    \n\
-									    \n\
-			obj = %1$s__open(embed);			    \n\
-			if (!obj)					    \n\
-				return NULL;				    \n\
-			if (%1$s__load(obj)) {				    \n\
-				%1$s__destroy(obj);			    \n\
-				return NULL;				    \n\
-			}						    \n\
-			return obj;					    \n\
-		}							    \n\
-									    \n\
-		static inline int					    \n\
-		%1$s__attach(struct %1$s *obj)				    \n\
-		{							    \n\
-			return bpf_object__attach_skeleton(obj->skeleton);  \n\
-		}							    \n\
-									    \n\
-		static inline void					    \n\
-		%1$s__detach(struct %1$s *obj)				    \n\
-		{							    \n\
-			return bpf_object__detach_skeleton(obj->skeleton);  \n\
+			bpf_object__destroy_skeleton(s);		    \n\
+			return -1;					    \n\
 		}							    \n\
 									    \n\
 		#endif /* %2$s */					    \n\
 		",
-		obj_name, header_guard
-	);
+		obj_name, header_guard);
 	err = 0;
 out:
 	bpf_object__close(obj);
+	if (obj_data)
+		munmap(obj_data, mmap_sz);
+	close(fd);
 	return err;
 }
 
* Unmerged path tools/testing/selftests/bpf/prog_tests/attach_probe.c
diff --git a/tools/testing/selftests/bpf/prog_tests/core_extern.c b/tools/testing/selftests/bpf/prog_tests/core_extern.c
index 30a7972e9012..5f03dc1de29e 100644
--- a/tools/testing/selftests/bpf/prog_tests/core_extern.c
+++ b/tools/testing/selftests/bpf/prog_tests/core_extern.c
@@ -124,8 +124,6 @@ static struct test_case {
 	{ .name = "u64 (max+1)", .fails = 1, .cfg = CFG"CONFIG_ULONG=0x10000000000000000" },
 };
 
-BPF_EMBED_OBJ(core_extern, "test_core_extern.o");
-
 void test_core_extern(void)
 {
 	const uint32_t kern_ver = get_kernel_version();
@@ -159,7 +157,7 @@ void test_core_extern(void)
 			opts.kconfig_path = tmp_cfg_path;
 		}
 
-		skel = test_core_extern__open_opts(&core_extern_embed, &opts);
+		skel = test_core_extern__open_opts(&opts);
 		if (CHECK(!skel, "skel_open", "skeleton open failed\n"))
 			goto cleanup;
 		err = test_core_extern__load(skel);
* Unmerged path tools/testing/selftests/bpf/prog_tests/fentry_fexit.c
* Unmerged path tools/testing/selftests/bpf/prog_tests/fentry_test.c
* Unmerged path tools/testing/selftests/bpf/prog_tests/mmap.c
diff --git a/tools/testing/selftests/bpf/prog_tests/skeleton.c b/tools/testing/selftests/bpf/prog_tests/skeleton.c
index 151cdad3ad0d..ec6f2aec3853 100644
--- a/tools/testing/selftests/bpf/prog_tests/skeleton.c
+++ b/tools/testing/selftests/bpf/prog_tests/skeleton.c
@@ -10,8 +10,6 @@ struct s {
 
 #include "test_skeleton.skel.h"
 
-BPF_EMBED_OBJ(skeleton, "test_skeleton.o");
-
 void test_skeleton(void)
 {
 	int duration = 0, err;
@@ -19,7 +17,7 @@ void test_skeleton(void)
 	struct test_skeleton__bss *bss;
 	struct test_skeleton__externs *exts;
 
-	skel = test_skeleton__open(&skeleton_embed);
+	skel = test_skeleton__open();
 	if (CHECK(!skel, "skel_open", "failed to open skeleton\n"))
 		return;
 
* Unmerged path tools/testing/selftests/bpf/prog_tests/stacktrace_build_id.c
* Unmerged path tools/testing/selftests/bpf/prog_tests/stacktrace_build_id_nmi.c
