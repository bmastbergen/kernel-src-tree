perf tools: Use perf_mmap way to detect aux mmap

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit 1d40ae4e1784bfa1646fd153ca022db21511284f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/1d40ae4e.failed

We will move this code to libperf shortly, so we need to free it of
'struct auxtrace_mmap' usage, because it won't be available in libperf
(for now).

The perf_event_mmap_page::aux_size is set when the aux mmap is mapped,
so the check is equivalent.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
Link: http://lore.kernel.org/lkml/20191007125344.14268-9-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 1d40ae4e1784bfa1646fd153ca022db21511284f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/mmap.c
diff --cc tools/perf/util/mmap.c
index 850493205040,f246dd403507..000000000000
--- a/tools/perf/util/mmap.c
+++ b/tools/perf/util/mmap.c
@@@ -101,28 -105,17 +101,34 @@@ union perf_event *perf_mmap__read_event
  	return event;
  }
  
 -static bool perf_mmap__empty(struct mmap *map)
 +static bool perf_mmap__empty(struct perf_mmap *map)
  {
++<<<<<<< HEAD
 +	return perf_mmap__read_head(map) == map->prev && !map->auxtrace_mmap.base;
++=======
+ 	struct perf_event_mmap_page *pc = map->core.base;
+ 
+ 	return perf_mmap__read_head(map) == map->core.prev && !pc->aux_size;
++>>>>>>> 1d40ae4e1784 (perf tools: Use perf_mmap way to detect aux mmap)
 +}
 +
 +void perf_mmap__get(struct perf_mmap *map)
 +{
 +	refcount_inc(&map->refcnt);
 +}
 +
 +void perf_mmap__put(struct perf_mmap *map)
 +{
 +	BUG_ON(map->base && refcount_read(&map->refcnt) == 0);
 +
 +	if (refcount_dec_and_test(&map->refcnt))
 +		perf_mmap__munmap(map);
  }
  
 -void perf_mmap__consume(struct mmap *map)
 +void perf_mmap__consume(struct perf_mmap *map)
  {
 -	if (!map->core.overwrite) {
 -		u64 old = map->core.prev;
 +	if (!map->overwrite) {
 +		u64 old = map->prev;
  
  		perf_mmap__write_tail(map, old);
  	}
* Unmerged path tools/perf/util/mmap.c
