drm/i915/gen12: Add aux table invalidate for all engines

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mika Kuoppala <mika.kuoppala@linux.intel.com>
commit 972282c4cf2454af7dca3fec16b8f2cc72d4238c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/972282c4.failed

All engines, exception being blitter as it does not
care about the form, can access compressed surfaces.

So we need to add forced aux table invalidates
for those engines.

v2: virtual instance masking (Chris)
v3: bug on if not found (Chris)

References: d248b371f747 ("drm/i915/gen12: Invalidate aux table entries forcibly")
References bspec#43904, hsdes#1809175790
	Cc: Chris Wilson <chris@chris-wilson.co.uk>
	Cc: Chuansheng Liu <chuansheng.liu@intel.com>
	Cc: Rafael Antognolli <rafael.antognolli@intel.com>
	Signed-off-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
	Acked-by: Chris Wilson <chris@chris-wilson.co.uk>
	Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Link: https://patchwork.freedesktop.org/patch/msgid/20200507142045.8668-1-mika.kuoppala@linux.intel.com
(cherry picked from commit 972282c4cf2454af7dca3fec16b8f2cc72d4238c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/gt/intel_lrc.c
#	drivers/gpu/drm/i915/i915_reg.h
diff --cc drivers/gpu/drm/i915/gt/intel_lrc.c
index f2865f3cc1d5,400b9b5a6882..000000000000
--- a/drivers/gpu/drm/i915/gt/intel_lrc.c
+++ b/drivers/gpu/drm/i915/gt/intel_lrc.c
@@@ -2508,6 -4483,220 +2508,223 @@@ static int gen8_emit_flush_render(struc
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int gen11_emit_flush_render(struct i915_request *request,
+ 				   u32 mode)
+ {
+ 	if (mode & EMIT_FLUSH) {
+ 		u32 *cs;
+ 		u32 flags = 0;
+ 
+ 		flags |= PIPE_CONTROL_CS_STALL;
+ 
+ 		flags |= PIPE_CONTROL_TILE_CACHE_FLUSH;
+ 		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
+ 		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
+ 		flags |= PIPE_CONTROL_DC_FLUSH_ENABLE;
+ 		flags |= PIPE_CONTROL_FLUSH_ENABLE;
+ 		flags |= PIPE_CONTROL_QW_WRITE;
+ 		flags |= PIPE_CONTROL_STORE_DATA_INDEX;
+ 
+ 		cs = intel_ring_begin(request, 6);
+ 		if (IS_ERR(cs))
+ 			return PTR_ERR(cs);
+ 
+ 		cs = gen8_emit_pipe_control(cs, flags, LRC_PPHWSP_SCRATCH_ADDR);
+ 		intel_ring_advance(request, cs);
+ 	}
+ 
+ 	if (mode & EMIT_INVALIDATE) {
+ 		u32 *cs;
+ 		u32 flags = 0;
+ 
+ 		flags |= PIPE_CONTROL_CS_STALL;
+ 
+ 		flags |= PIPE_CONTROL_COMMAND_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_TLB_INVALIDATE;
+ 		flags |= PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_QW_WRITE;
+ 		flags |= PIPE_CONTROL_STORE_DATA_INDEX;
+ 
+ 		cs = intel_ring_begin(request, 6);
+ 		if (IS_ERR(cs))
+ 			return PTR_ERR(cs);
+ 
+ 		cs = gen8_emit_pipe_control(cs, flags, LRC_PPHWSP_SCRATCH_ADDR);
+ 		intel_ring_advance(request, cs);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u32 preparser_disable(bool state)
+ {
+ 	return MI_ARB_CHECK | 1 << 8 | state;
+ }
+ 
+ static i915_reg_t aux_inv_reg(const struct intel_engine_cs *engine)
+ {
+ 	static const i915_reg_t vd[] = {
+ 		GEN12_VD0_AUX_NV,
+ 		GEN12_VD1_AUX_NV,
+ 		GEN12_VD2_AUX_NV,
+ 		GEN12_VD3_AUX_NV,
+ 	};
+ 
+ 	static const i915_reg_t ve[] = {
+ 		GEN12_VE0_AUX_NV,
+ 		GEN12_VE1_AUX_NV,
+ 	};
+ 
+ 	if (engine->class == VIDEO_DECODE_CLASS)
+ 		return vd[engine->instance];
+ 
+ 	if (engine->class == VIDEO_ENHANCEMENT_CLASS)
+ 		return ve[engine->instance];
+ 
+ 	GEM_BUG_ON("unknown aux_inv_reg\n");
+ 
+ 	return INVALID_MMIO_REG;
+ }
+ 
+ static u32 *
+ gen12_emit_aux_table_inv(const i915_reg_t inv_reg, u32 *cs)
+ {
+ 	*cs++ = MI_LOAD_REGISTER_IMM(1);
+ 	*cs++ = i915_mmio_reg_offset(inv_reg);
+ 	*cs++ = AUX_INV;
+ 	*cs++ = MI_NOOP;
+ 
+ 	return cs;
+ }
+ 
+ static int gen12_emit_flush_render(struct i915_request *request,
+ 				   u32 mode)
+ {
+ 	if (mode & EMIT_FLUSH) {
+ 		u32 flags = 0;
+ 		u32 *cs;
+ 
+ 		flags |= PIPE_CONTROL_TILE_CACHE_FLUSH;
+ 		flags |= PIPE_CONTROL_FLUSH_L3;
+ 		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
+ 		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
+ 		/* Wa_1409600907:tgl */
+ 		flags |= PIPE_CONTROL_DEPTH_STALL;
+ 		flags |= PIPE_CONTROL_DC_FLUSH_ENABLE;
+ 		flags |= PIPE_CONTROL_FLUSH_ENABLE;
+ 
+ 		flags |= PIPE_CONTROL_STORE_DATA_INDEX;
+ 		flags |= PIPE_CONTROL_QW_WRITE;
+ 
+ 		flags |= PIPE_CONTROL_CS_STALL;
+ 
+ 		cs = intel_ring_begin(request, 6);
+ 		if (IS_ERR(cs))
+ 			return PTR_ERR(cs);
+ 
+ 		cs = gen12_emit_pipe_control(cs,
+ 					     PIPE_CONTROL0_HDC_PIPELINE_FLUSH,
+ 					     flags, LRC_PPHWSP_SCRATCH_ADDR);
+ 		intel_ring_advance(request, cs);
+ 	}
+ 
+ 	if (mode & EMIT_INVALIDATE) {
+ 		u32 flags = 0;
+ 		u32 *cs;
+ 
+ 		flags |= PIPE_CONTROL_COMMAND_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_TLB_INVALIDATE;
+ 		flags |= PIPE_CONTROL_INSTRUCTION_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_TEXTURE_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_VF_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_CONST_CACHE_INVALIDATE;
+ 		flags |= PIPE_CONTROL_STATE_CACHE_INVALIDATE;
+ 
+ 		flags |= PIPE_CONTROL_STORE_DATA_INDEX;
+ 		flags |= PIPE_CONTROL_QW_WRITE;
+ 
+ 		flags |= PIPE_CONTROL_CS_STALL;
+ 
+ 		cs = intel_ring_begin(request, 8 + 4);
+ 		if (IS_ERR(cs))
+ 			return PTR_ERR(cs);
+ 
+ 		/*
+ 		 * Prevent the pre-parser from skipping past the TLB
+ 		 * invalidate and loading a stale page for the batch
+ 		 * buffer / request payload.
+ 		 */
+ 		*cs++ = preparser_disable(true);
+ 
+ 		cs = gen8_emit_pipe_control(cs, flags, LRC_PPHWSP_SCRATCH_ADDR);
+ 
+ 		/* hsdes: 1809175790 */
+ 		cs = gen12_emit_aux_table_inv(GEN12_GFX_CCS_AUX_NV, cs);
+ 
+ 		*cs++ = preparser_disable(false);
+ 		intel_ring_advance(request, cs);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int gen12_emit_flush(struct i915_request *request, u32 mode)
+ {
+ 	intel_engine_mask_t aux_inv = 0;
+ 	u32 cmd, *cs;
+ 
+ 	if (mode & EMIT_INVALIDATE)
+ 		aux_inv = request->engine->mask & ~BIT(BCS0);
+ 
+ 	cs = intel_ring_begin(request,
+ 			      4 + (aux_inv ? 2 * hweight8(aux_inv) + 2 : 0));
+ 	if (IS_ERR(cs))
+ 		return PTR_ERR(cs);
+ 
+ 	cmd = MI_FLUSH_DW + 1;
+ 
+ 	/* We always require a command barrier so that subsequent
+ 	 * commands, such as breadcrumb interrupts, are strictly ordered
+ 	 * wrt the contents of the write cache being flushed to memory
+ 	 * (and thus being coherent from the CPU).
+ 	 */
+ 	cmd |= MI_FLUSH_DW_STORE_INDEX | MI_FLUSH_DW_OP_STOREDW;
+ 
+ 	if (mode & EMIT_INVALIDATE) {
+ 		cmd |= MI_INVALIDATE_TLB;
+ 		if (request->engine->class == VIDEO_DECODE_CLASS)
+ 			cmd |= MI_INVALIDATE_BSD;
+ 	}
+ 
+ 	*cs++ = cmd;
+ 	*cs++ = LRC_PPHWSP_SCRATCH_ADDR;
+ 	*cs++ = 0; /* upper addr */
+ 	*cs++ = 0; /* value */
+ 
+ 	if (aux_inv) { /* hsdes: 1809175790 */
+ 		struct intel_engine_cs *engine;
+ 		unsigned int tmp;
+ 
+ 		*cs++ = MI_LOAD_REGISTER_IMM(hweight8(aux_inv));
+ 		for_each_engine_masked(engine, request->engine->gt,
+ 				       aux_inv, tmp) {
+ 			*cs++ = i915_mmio_reg_offset(aux_inv_reg(engine));
+ 			*cs++ = AUX_INV;
+ 		}
+ 		*cs++ = MI_NOOP;
+ 	}
+ 	intel_ring_advance(request, cs);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 972282c4cf24 (drm/i915/gen12: Add aux table invalidate for all engines)
  /*
   * Reserve space for 2 NOOPs at the end of each request to be
   * used as a workaround for not being allowed to do lite
@@@ -2633,7 -4930,10 +2850,14 @@@ logical_ring_default_vfuncs(struct inte
  	engine->emit_flush = gen8_emit_flush;
  	engine->emit_init_breadcrumb = gen8_emit_init_breadcrumb;
  	engine->emit_fini_breadcrumb = gen8_emit_fini_breadcrumb;
++<<<<<<< HEAD
 +
++=======
+ 	if (INTEL_GEN(engine->i915) >= 12) {
+ 		engine->emit_fini_breadcrumb = gen12_emit_fini_breadcrumb;
+ 		engine->emit_flush = gen12_emit_flush;
+ 	}
++>>>>>>> 972282c4cf24 (drm/i915/gen12: Add aux table invalidate for all engines)
  	engine->set_default_submission = intel_execlists_set_default_submission;
  
  	if (INTEL_GEN(engine->i915) < 11) {
diff --cc drivers/gpu/drm/i915/i915_reg.h
index 32940dd2ebc5,6c076a24eb82..000000000000
--- a/drivers/gpu/drm/i915/i915_reg.h
+++ b/drivers/gpu/drm/i915/i915_reg.h
@@@ -2492,7 -2554,17 +2492,18 @@@ enum i915_power_well_id 
  #define GEN8_PRIVATE_PAT_LO	_MMIO(0x40e0)
  #define GEN8_PRIVATE_PAT_HI	_MMIO(0x40e0 + 4)
  #define GEN10_PAT_INDEX(index)	_MMIO(0x40e0 + (index) * 4)
 -#define GEN12_PAT_INDEX(index)	_MMIO(0x4800 + (index) * 4)
  #define BSD_HWS_PGA_GEN7	_MMIO(0x04180)
++<<<<<<< HEAD
++=======
+ #define GEN12_GFX_CCS_AUX_NV	_MMIO(0x4208)
+ #define GEN12_VD0_AUX_NV	_MMIO(0x4218)
+ #define GEN12_VD1_AUX_NV	_MMIO(0x4228)
+ #define GEN12_VD2_AUX_NV	_MMIO(0x4298)
+ #define GEN12_VD3_AUX_NV	_MMIO(0x42A8)
+ #define GEN12_VE0_AUX_NV	_MMIO(0x4238)
+ #define GEN12_VE1_AUX_NV	_MMIO(0x42B8)
+ #define   AUX_INV		REG_BIT(0)
++>>>>>>> 972282c4cf24 (drm/i915/gen12: Add aux table invalidate for all engines)
  #define BLT_HWS_PGA_GEN7	_MMIO(0x04280)
  #define VEBOX_HWS_PGA_GEN7	_MMIO(0x04380)
  #define RING_ACTHD(base)	_MMIO((base) + 0x74)
* Unmerged path drivers/gpu/drm/i915/gt/intel_lrc.c
* Unmerged path drivers/gpu/drm/i915/i915_reg.h
