Bluetooth: hci_qca: Use regulator bulk enable/disable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Bjorn Andersson <bjorn.andersson@linaro.org>
commit 163d42fa83c6090071698533d33babd7bbf97147
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/163d42fa.failed

With the regulator_set_load() and regulator_set_voltage() out of the
enable/disable code paths the code can now use the standard
regulator bulk enable/disable API.

By cloning num_vregs into struct qca_power there's no need to lug around
a reference to the struct qca_vreg_data, which further simplifies
qca_power_setup().

	Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 163d42fa83c6090071698533d33babd7bbf97147)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/hci_qca.c
diff --cc drivers/bluetooth/hci_qca.c
index c7723b08787d,df3218072b04..000000000000
--- a/drivers/bluetooth/hci_qca.c
+++ b/drivers/bluetooth/hci_qca.c
@@@ -119,6 -119,36 +119,39 @@@ struct qca_data 
  	u64 votes_off;
  };
  
++<<<<<<< HEAD
++=======
+ enum qca_speed_type {
+ 	QCA_INIT_SPEED = 1,
+ 	QCA_OPER_SPEED
+ };
+ 
+ /*
+  * Voltage regulator information required for configuring the
+  * QCA Bluetooth chipset
+  */
+ struct qca_vreg {
+ 	const char *name;
+ 	unsigned int load_uA;
+ };
+ 
+ struct qca_vreg_data {
+ 	enum qca_btsoc_type soc_type;
+ 	struct qca_vreg *vregs;
+ 	size_t num_vregs;
+ };
+ 
+ /*
+  * Platform data for the QCA Bluetooth power driver.
+  */
+ struct qca_power {
+ 	struct device *dev;
+ 	struct regulator_bulk_data *vreg_bulk;
+ 	int num_vregs;
+ 	bool vregs_on;
+ };
+ 
++>>>>>>> 163d42fa83c6 (Bluetooth: hci_qca: Use regulator bulk enable/disable)
  struct qca_serdev {
  	struct hci_uart	 serdev_hu;
  	struct gpio_desc *bt_en;
@@@ -988,6 -1329,120 +1021,123 @@@ static const struct hci_uart_proto qca_
  	.dequeue	= qca_dequeue,
  };
  
++<<<<<<< HEAD
++=======
+ static const struct qca_vreg_data qca_soc_data_wcn3990 = {
+ 	.soc_type = QCA_WCN3990,
+ 	.vregs = (struct qca_vreg []) {
+ 		{ "vddio", 15000  },
+ 		{ "vddxo", 80000  },
+ 		{ "vddrf", 300000 },
+ 		{ "vddch0", 450000 },
+ 	},
+ 	.num_vregs = 4,
+ };
+ 
+ static const struct qca_vreg_data qca_soc_data_wcn3998 = {
+ 	.soc_type = QCA_WCN3998,
+ 	.vregs = (struct qca_vreg []) {
+ 		{ "vddio", 10000  },
+ 		{ "vddxo", 80000  },
+ 		{ "vddrf", 300000 },
+ 		{ "vddch0", 450000 },
+ 	},
+ 	.num_vregs = 4,
+ };
+ 
+ static void qca_power_shutdown(struct hci_uart *hu)
+ {
+ 	struct qca_data *qca = hu->priv;
+ 	unsigned long flags;
+ 
+ 	/* From this point we go into power off state. But serial port is
+ 	 * still open, stop queueing the IBS data and flush all the buffered
+ 	 * data in skb's.
+ 	 */
+ 	spin_lock_irqsave(&qca->hci_ibs_lock, flags);
+ 	clear_bit(QCA_IBS_ENABLED, &qca->flags);
+ 	qca_flush(hu);
+ 	spin_unlock_irqrestore(&qca->hci_ibs_lock, flags);
+ 
+ 	host_set_baudrate(hu, 2400);
+ 	qca_send_power_pulse(hu, false);
+ 	qca_power_setup(hu, false);
+ }
+ 
+ static int qca_power_off(struct hci_dev *hdev)
+ {
+ 	struct hci_uart *hu = hci_get_drvdata(hdev);
+ 
+ 	/* Perform pre shutdown command */
+ 	qca_send_pre_shutdown_cmd(hdev);
+ 
+ 	usleep_range(8000, 10000);
+ 
+ 	qca_power_shutdown(hu);
+ 	return 0;
+ }
+ 
+ static int qca_power_setup(struct hci_uart *hu, bool on)
+ {
+ 	struct regulator_bulk_data *vreg_bulk;
+ 	struct qca_serdev *qcadev;
+ 	int num_vregs;
+ 	int ret = 0;
+ 
+ 	qcadev = serdev_device_get_drvdata(hu->serdev);
+ 	if (!qcadev || !qcadev->bt_power || !qcadev->bt_power->vreg_bulk)
+ 		return -EINVAL;
+ 
+ 	vreg_bulk = qcadev->bt_power->vreg_bulk;
+ 	num_vregs = qcadev->bt_power->num_vregs;
+ 	BT_DBG("on: %d (%d regulators)", on, num_vregs);
+ 	if (on && !qcadev->bt_power->vregs_on) {
+ 		ret = regulator_bulk_enable(num_vregs, vreg_bulk);
+ 		if (ret)
+ 			return ret;
+ 
+ 		qcadev->bt_power->vregs_on = true;
+ 	} else if (!on && qcadev->bt_power->vregs_on) {
+ 		/* turn off regulator in reverse order */
+ 		regulator_bulk_disable(num_vregs, vreg_bulk);
+ 
+ 		qcadev->bt_power->vregs_on = false;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int qca_init_regulators(struct qca_power *qca,
+ 				const struct qca_vreg *vregs, size_t num_vregs)
+ {
+ 	struct regulator_bulk_data *bulk;
+ 	int ret;
+ 	int i;
+ 
+ 	bulk = devm_kcalloc(qca->dev, num_vregs, sizeof(*bulk), GFP_KERNEL);
+ 	if (!bulk)
+ 		return -ENOMEM;
+ 
+ 	for (i = 0; i < num_vregs; i++)
+ 		bulk[i].supply = vregs[i].name;
+ 
+ 	ret = devm_regulator_bulk_get(qca->dev, num_vregs, bulk);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	for (i = 0; i < num_vregs; i++) {
+ 		ret = regulator_set_load(bulk[i].consumer, vregs[i].load_uA);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	qca->vreg_bulk = bulk;
+ 	qca->num_vregs = num_vregs;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 163d42fa83c6 (Bluetooth: hci_qca: Use regulator bulk enable/disable)
  static int qca_serdev_probe(struct serdev_device *serdev)
  {
  	struct qca_serdev *qcadev;
@@@ -998,34 -1454,68 +1148,83 @@@
  		return -ENOMEM;
  
  	qcadev->serdev_hu.serdev = serdev;
 -	data = of_device_get_match_data(&serdev->dev);
  	serdev_device_set_drvdata(serdev, qcadev);
 -	device_property_read_string(&serdev->dev, "firmware-name",
 -					 &qcadev->firmware_name);
 -	if (data && qca_is_wcn399x(data->soc_type)) {
 -		qcadev->btsoc_type = data->soc_type;
 -		qcadev->bt_power = devm_kzalloc(&serdev->dev,
 -						sizeof(struct qca_power),
 -						GFP_KERNEL);
 -		if (!qcadev->bt_power)
 -			return -ENOMEM;
  
++<<<<<<< HEAD
 +	qcadev->bt_en = devm_gpiod_get(&serdev->dev, "enable",
 +				       GPIOD_OUT_LOW);
 +	if (IS_ERR(qcadev->bt_en)) {
 +		dev_err(&serdev->dev, "failed to acquire enable gpio\n");
 +		return PTR_ERR(qcadev->bt_en);
++=======
+ 		qcadev->bt_power->dev = &serdev->dev;
+ 		err = qca_init_regulators(qcadev->bt_power, data->vregs,
+ 					  data->num_vregs);
+ 		if (err) {
+ 			BT_ERR("Failed to init regulators:%d", err);
+ 			goto out;
+ 		}
+ 
+ 		qcadev->bt_power->vregs_on = false;
+ 
+ 		device_property_read_u32(&serdev->dev, "max-speed",
+ 					 &qcadev->oper_speed);
+ 		if (!qcadev->oper_speed)
+ 			BT_DBG("UART will pick default operating speed");
+ 
+ 		err = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);
+ 		if (err) {
+ 			BT_ERR("wcn3990 serdev registration failed");
+ 			goto out;
+ 		}
+ 	} else {
+ 		qcadev->btsoc_type = QCA_ROME;
+ 		qcadev->bt_en = devm_gpiod_get(&serdev->dev, "enable",
+ 					       GPIOD_OUT_LOW);
+ 		if (IS_ERR(qcadev->bt_en)) {
+ 			dev_err(&serdev->dev, "failed to acquire enable gpio\n");
+ 			return PTR_ERR(qcadev->bt_en);
+ 		}
+ 
+ 		qcadev->susclk = devm_clk_get(&serdev->dev, NULL);
+ 		if (IS_ERR(qcadev->susclk)) {
+ 			dev_err(&serdev->dev, "failed to acquire clk\n");
+ 			return PTR_ERR(qcadev->susclk);
+ 		}
+ 
+ 		err = clk_set_rate(qcadev->susclk, SUSCLK_RATE_32KHZ);
+ 		if (err)
+ 			return err;
+ 
+ 		err = clk_prepare_enable(qcadev->susclk);
+ 		if (err)
+ 			return err;
+ 
+ 		err = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);
+ 		if (err)
+ 			clk_disable_unprepare(qcadev->susclk);
++>>>>>>> 163d42fa83c6 (Bluetooth: hci_qca: Use regulator bulk enable/disable)
  	}
  
 -out:	return err;
 +	qcadev->susclk = devm_clk_get(&serdev->dev, NULL);
 +	if (IS_ERR(qcadev->susclk)) {
 +		dev_err(&serdev->dev, "failed to acquire clk\n");
 +		return PTR_ERR(qcadev->susclk);
 +	}
  
 +	err = clk_set_rate(qcadev->susclk, SUSCLK_RATE_32KHZ);
 +	if (err)
 +		return err;
 +
 +	err = clk_prepare_enable(qcadev->susclk);
 +	if (err)
 +		return err;
 +
 +	err = hci_uart_register_device(&qcadev->serdev_hu, &qca_proto);
 +	if (err)
 +		clk_disable_unprepare(qcadev->susclk);
 +
 +	return err;
  }
  
  static void qca_serdev_remove(struct serdev_device *serdev)
* Unmerged path drivers/bluetooth/hci_qca.c
