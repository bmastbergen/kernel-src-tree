drm/amdgpu: fix wrong vram lost counter increment V2

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Evan Quan <evan.quan@amd.com>
commit dadce777e0947b9b6839f06f360882e54ba2a154
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dadce777.failed

Vram lost counter is wrongly increased by two during baco reset.

V2: assumed vram lost for mode1 reset on all ASICs

	Signed-off-by: Evan Quan <evan.quan@amd.com>
	Acked-by: Alex Deucher <alexander.deucher@amd.com>
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit dadce777e0947b9b6839f06f360882e54ba2a154)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/amd/amdgpu/cik.c
#	drivers/gpu/drm/amd/amdgpu/nv.c
#	drivers/gpu/drm/amd/amdgpu/soc15.c
#	drivers/gpu/drm/amd/amdgpu/vi.c
diff --cc drivers/gpu/drm/amd/amdgpu/cik.c
index 1ffbc0d3d7a1,fe306d0f73f7..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@@ -1282,11 -1301,67 +1282,19 @@@ static int cik_asic_reset(struct amdgpu
  {
  	int r;
  
++<<<<<<< HEAD
  	amdgpu_atombios_scratch_regs_engine_hung(adev, true);
  
  	r = cik_gpu_pci_config_reset(adev);
  
  	amdgpu_atombios_scratch_regs_engine_hung(adev, false);
 -
 -	return r;
 -}
 -
 -static bool cik_asic_supports_baco(struct amdgpu_device *adev)
 -{
 -	switch (adev->asic_type) {
 -	case CHIP_BONAIRE:
 -	case CHIP_HAWAII:
 -		return amdgpu_dpm_is_baco_supported(adev);
 -	default:
 -		return false;
 -	}
 -}
 -
 -static enum amd_reset_method
 -cik_asic_reset_method(struct amdgpu_device *adev)
 -{
 -	bool baco_reset;
 -
 -	switch (adev->asic_type) {
 -	case CHIP_BONAIRE:
 -	case CHIP_HAWAII:
 -		/* disable baco reset until it works */
 -		/* smu7_asic_get_baco_capability(adev, &baco_reset); */
 -		baco_reset = false;
 -		break;
 -	default:
 -		baco_reset = false;
 -		break;
 -	}
 -
 -	if (baco_reset)
 -		return AMD_RESET_METHOD_BACO;
 -	else
 -		return AMD_RESET_METHOD_LEGACY;
 -}
 -
 -/**
 - * cik_asic_reset - soft reset GPU
 - *
 - * @adev: amdgpu_device pointer
 - *
 - * Look up which blocks are hung and attempt
 - * to reset them.
 - * Returns 0 for success.
 - */
 -static int cik_asic_reset(struct amdgpu_device *adev)
 -{
 -	int r;
 -
++=======
+ 	if (cik_asic_reset_method(adev) == AMD_RESET_METHOD_BACO) {
+ 		r = amdgpu_dpm_baco_reset(adev);
+ 	} else {
+ 		r = cik_asic_pci_config_reset(adev);
+ 	}
++>>>>>>> dadce777e094 (drm/amdgpu: fix wrong vram lost counter increment V2)
  
  	return r;
  }
diff --cc drivers/gpu/drm/amd/amdgpu/nv.c
index 9922bce3fd89,995bdec9fa7d..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/nv.c
+++ b/drivers/gpu/drm/amd/amdgpu/nv.c
@@@ -303,10 -350,16 +303,21 @@@ static int nv_asic_reset(struct amdgpu_
  	int ret = 0;
  	struct smu_context *smu = &adev->smu;
  
++<<<<<<< HEAD
 +	if (smu_baco_is_support(smu))
 +		ret = smu_baco_reset(smu);
 +	else
++=======
+ 	if (nv_asic_reset_method(adev) == AMD_RESET_METHOD_BACO) {
+ 		ret = smu_baco_enter(smu);
+ 		if (ret)
+ 			return ret;
+ 		ret = smu_baco_exit(smu);
+ 		if (ret)
+ 			return ret;
+ 	} else {
++>>>>>>> dadce777e094 (drm/amdgpu: fix wrong vram lost counter increment V2)
  		ret = nv_asic_mode1_reset(adev);
 -	}
  
  	return ret;
  }
diff --cc drivers/gpu/drm/amd/amdgpu/soc15.c
index 04fbf05d7176,58a440a15525..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/soc15.c
+++ b/drivers/gpu/drm/amd/amdgpu/soc15.c
@@@ -493,11 -556,41 +493,44 @@@ static int soc15_asic_reset(struct amdg
  	}
  
  	if (baco_reset)
 -		return AMD_RESET_METHOD_BACO;
 +		ret = soc15_asic_baco_reset(adev);
  	else
 -		return AMD_RESET_METHOD_MODE1;
 -}
 +		ret = soc15_asic_mode1_reset(adev);
  
++<<<<<<< HEAD
 +	return ret;
++=======
+ static int soc15_asic_reset(struct amdgpu_device *adev)
+ {
+ 	/* original raven doesn't have full asic reset */
+ 	if (adev->pdev->device == 0x15dd && adev->rev_id < 0x8)
+ 		return 0;
+ 
+ 	switch (soc15_asic_reset_method(adev)) {
+ 		case AMD_RESET_METHOD_BACO:
+ 			return soc15_asic_baco_reset(adev);
+ 		case AMD_RESET_METHOD_MODE2:
+ 			return amdgpu_dpm_mode2_reset(adev);
+ 		default:
+ 			return soc15_asic_mode1_reset(adev);
+ 	}
+ }
+ 
+ static bool soc15_supports_baco(struct amdgpu_device *adev)
+ {
+ 	switch (adev->asic_type) {
+ 	case CHIP_VEGA10:
+ 	case CHIP_VEGA12:
+ 	case CHIP_ARCTURUS:
+ 		return amdgpu_dpm_is_baco_supported(adev);
+ 	case CHIP_VEGA20:
+ 		if (adev->psp.sos_fw_version >= 0x80067)
+ 			return amdgpu_dpm_is_baco_supported(adev);
+ 		return false;
+ 	default:
+ 		return false;
+ 	}
++>>>>>>> dadce777e094 (drm/amdgpu: fix wrong vram lost counter increment V2)
  }
  
  /*static int soc15_set_uvd_clock(struct amdgpu_device *adev, u32 clock,
diff --cc drivers/gpu/drm/amd/amdgpu/vi.c
index 6575ddcfcf00,af8986a55354..000000000000
--- a/drivers/gpu/drm/amd/amdgpu/vi.c
+++ b/drivers/gpu/drm/amd/amdgpu/vi.c
@@@ -702,11 -681,73 +702,19 @@@ static int vi_asic_reset(struct amdgpu_
  {
  	int r;
  
++<<<<<<< HEAD
  	amdgpu_atombios_scratch_regs_engine_hung(adev, true);
  
  	r = vi_gpu_pci_config_reset(adev);
  
  	amdgpu_atombios_scratch_regs_engine_hung(adev, false);
 -
 -	return r;
 -}
 -
 -static bool vi_asic_supports_baco(struct amdgpu_device *adev)
 -{
 -	switch (adev->asic_type) {
 -	case CHIP_FIJI:
 -	case CHIP_TONGA:
 -	case CHIP_POLARIS10:
 -	case CHIP_POLARIS11:
 -	case CHIP_POLARIS12:
 -	case CHIP_TOPAZ:
 -		return amdgpu_dpm_is_baco_supported(adev);
 -	default:
 -		return false;
 -	}
 -}
 -
 -static enum amd_reset_method
 -vi_asic_reset_method(struct amdgpu_device *adev)
 -{
 -	bool baco_reset;
 -
 -	switch (adev->asic_type) {
 -	case CHIP_FIJI:
 -	case CHIP_TONGA:
 -	case CHIP_POLARIS10:
 -	case CHIP_POLARIS11:
 -	case CHIP_POLARIS12:
 -	case CHIP_TOPAZ:
 -		baco_reset = amdgpu_dpm_is_baco_supported(adev);
 -		break;
 -	default:
 -		baco_reset = false;
 -		break;
 -	}
 -
 -	if (baco_reset)
 -		return AMD_RESET_METHOD_BACO;
 -	else
 -		return AMD_RESET_METHOD_LEGACY;
 -}
 -
 -/**
 - * vi_asic_reset - soft reset GPU
 - *
 - * @adev: amdgpu_device pointer
 - *
 - * Look up which blocks are hung and attempt
 - * to reset them.
 - * Returns 0 for success.
 - */
 -static int vi_asic_reset(struct amdgpu_device *adev)
 -{
 -	int r;
 -
++=======
+ 	if (vi_asic_reset_method(adev) == AMD_RESET_METHOD_BACO) {
+ 		r = amdgpu_dpm_baco_reset(adev);
+ 	} else {
+ 		r = vi_asic_pci_config_reset(adev);
+ 	}
++>>>>>>> dadce777e094 (drm/amdgpu: fix wrong vram lost counter increment V2)
  
  	return r;
  }
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index 2877ce84aef2..437ea84f4a47 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
@@ -1817,8 +1817,24 @@ static void amdgpu_device_fill_reset_magic(struct amdgpu_device *adev)
  */
 static bool amdgpu_device_check_vram_lost(struct amdgpu_device *adev)
 {
-	return !!memcmp(adev->gart.ptr, adev->reset_magic,
-			AMDGPU_RESET_MAGIC_NUM);
+	if (memcmp(adev->gart.ptr, adev->reset_magic,
+			AMDGPU_RESET_MAGIC_NUM))
+		return true;
+
+	if (!adev->in_gpu_reset)
+		return false;
+
+	/*
+	 * For all ASICs with baco/mode1 reset, the VRAM is
+	 * always assumed to be lost.
+	 */
+	switch (amdgpu_asic_reset_method(adev)) {
+	case AMD_RESET_METHOD_BACO:
+	case AMD_RESET_METHOD_MODE1:
+		return true;
+	default:
+		return false;
+	}
 }
 
 /**
* Unmerged path drivers/gpu/drm/amd/amdgpu/cik.c
* Unmerged path drivers/gpu/drm/amd/amdgpu/nv.c
* Unmerged path drivers/gpu/drm/amd/amdgpu/soc15.c
* Unmerged path drivers/gpu/drm/amd/amdgpu/vi.c
