docs: fix broken references to text files

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
commit 72ef5e52b3f74c0be47b20f5c434b7ecc830cf40
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/72ef5e52.failed

Several references got broken due to txt to ReST conversion.

Several of them can be automatically fixed with:

	scripts/documentation-file-ref-check --fix

	Reviewed-by: Mathieu Poirier <mathieu.poirier@linaro.org> # hwtracing/coresight/Kconfig
	Reviewed-by: Paul E. McKenney <paulmck@kernel.org> # memory-barrier.txt
	Acked-by: Alex Shi <alex.shi@linux.alibaba.com> # translations/zh_CN
	Acked-by: Federico Vaga <federico.vaga@vaga.pv.it> # translations/it_IT
	Acked-by: Marc Zyngier <maz@kernel.org> # kvm/arm64
	Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Link: https://lore.kernel.org/r/6f919ddb83a33b5f2a63b6b5f0575737bb2b36aa.1586881715.git.mchehab+huawei@kernel.org
	Signed-off-by: Jonathan Corbet <corbet@lwn.net>
(cherry picked from commit 72ef5e52b3f74c0be47b20f5c434b7ecc830cf40)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	Documentation/process/submit-checklist.rst
#	Documentation/translations/it_IT/process/submit-checklist.rst
#	Documentation/translations/zh_CN/process/submit-checklist.rst
#	Documentation/virt/kvm/devices/vcpu.rst
#	drivers/hwtracing/coresight/Kconfig
#	include/linux/mm.h
#	include/uapi/linux/ethtool_netlink.h
#	include/uapi/rdma/rdma_user_ioctl_cmds.h
#	mm/gup.c
diff --cc Documentation/process/submit-checklist.rst
index c88867b173d9,3f8e9d5d95c2..000000000000
--- a/Documentation/process/submit-checklist.rst
+++ b/Documentation/process/submit-checklist.rst
@@@ -107,7 -107,7 +107,11 @@@ and elsewhere regarding submitting Linu
      and why.
  
  26) If any ioctl's are added by the patch, then also update
++<<<<<<< HEAD
 +    ``Documentation/ioctl/ioctl-number.txt``.
++=======
+     ``Documentation/userspace-api/ioctl/ioctl-number.rst``.
++>>>>>>> 72ef5e52b3f7 (docs: fix broken references to text files)
  
  27) If your modified source code depends on or uses any of the kernel
      APIs or features that are related to the following ``Kconfig`` symbols,
diff --cc drivers/hwtracing/coresight/Kconfig
index 094d5512a629,02dbb5ca3bcf..000000000000
--- a/drivers/hwtracing/coresight/Kconfig
+++ b/drivers/hwtracing/coresight/Kconfig
@@@ -101,7 -107,28 +101,11 @@@ config CORESIGHT_CPU_DEBU
  	  can quickly get to know program counter (PC), secure state,
  	  exception level, etc. Before use debugging functionality, platform
  	  needs to ensure the clock domain and power domain are enabled
++<<<<<<< HEAD
 +	  properly, please refer Documentation/trace/coresight-cpu-debug.txt
++=======
+ 	  properly, please refer Documentation/trace/coresight/coresight-cpu-debug.rst
++>>>>>>> 72ef5e52b3f7 (docs: fix broken references to text files)
  	  for detailed description and the example for usage.
  
 -config CORESIGHT_CTI
 -	bool "CoreSight Cross Trigger Interface (CTI) driver"
 -	depends on ARM || ARM64
 -	help
 -	  This driver provides support for CoreSight CTI and CTM components.
 -	  These provide hardware triggering events between CoreSight trace
 -	  source and sink components. These can be used to halt trace or
 -	  inject events into the trace stream. CTI also provides a software
 -	  control to trigger the same halt events. This can provide fast trace
 -	  halt compared to disabling sources and sinks normally in driver
 -	  software.
 -
 -config CORESIGHT_CTI_INTEGRATION_REGS
 -	bool "Access CTI CoreSight Integration Registers"
 -	depends on CORESIGHT_CTI
 -	help
 -	  This option adds support for the CoreSight integration registers on
 -	  this device. The integration registers allow the exploration of the
 -	  CTI trigger connections between this and other devices.These
 -	  registers are not used in normal operation and can leave devices in
 -	  an inconsistent state.
  endif
diff --cc include/linux/mm.h
index 5691398f32fe,1f2850465f59..000000000000
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@@ -973,30 -1161,87 +973,52 @@@ static inline void put_page(struct pag
  		__put_page(page);
  }
  
 -/*
 - * GUP_PIN_COUNTING_BIAS, and the associated functions that use it, overload
 - * the page's refcount so that two separate items are tracked: the original page
 - * reference count, and also a new count of how many pin_user_pages() calls were
 - * made against the page. ("gup-pinned" is another term for the latter).
 - *
 - * With this scheme, pin_user_pages() becomes special: such pages are marked as
 - * distinct from normal pages. As such, the unpin_user_page() call (and its
 - * variants) must be used in order to release gup-pinned pages.
 - *
 - * Choice of value:
 - *
 - * By making GUP_PIN_COUNTING_BIAS a power of two, debugging of page reference
 - * counts with respect to pin_user_pages() and unpin_user_page() becomes
 - * simpler, due to the fact that adding an even power of two to the page
 - * refcount has the effect of using only the upper N bits, for the code that
 - * counts up using the bias value. This means that the lower bits are left for
 - * the exclusive use of the original code that increments and decrements by one
 - * (or at least, by much smaller values than the bias value).
 - *
 - * Of course, once the lower bits overflow into the upper bits (and this is
 - * OK, because subtraction recovers the original values), then visual inspection
 - * no longer suffices to directly view the separate counts. However, for normal
 - * applications that don't have huge page reference counts, this won't be an
 - * issue.
 - *
 - * Locking: the lockless algorithm described in page_cache_get_speculative()
 - * and page_cache_gup_pin_speculative() provides safe operation for
 - * get_user_pages and page_mkclean and other calls that race to set up page
 - * table entries.
 - */
 -#define GUP_PIN_COUNTING_BIAS (1U << 10)
 -
 -void unpin_user_page(struct page *page);
 -void unpin_user_pages_dirty_lock(struct page **pages, unsigned long npages,
 -				 bool make_dirty);
 -void unpin_user_pages(struct page **pages, unsigned long npages);
 -
  /**
 - * page_maybe_dma_pinned() - report if a page is pinned for DMA.
 + * put_user_page() - release a gup-pinned page
 + * @page:            pointer to page to be released
   *
 - * This function checks if a page has been pinned via a call to
 - * pin_user_pages*().
 + * Pages that were pinned via get_user_pages*() must be released via
 + * either put_user_page(), or one of the put_user_pages*() routines
 + * below. This is so that eventually, pages that are pinned via
 + * get_user_pages*() can be separately tracked and uniquely handled. In
 + * particular, interactions with RDMA and filesystems need special
 + * handling.
   *
++<<<<<<< HEAD
 + * put_user_page() and put_page() are not interchangeable, despite this early
 + * implementation that makes them look the same. put_user_page() calls must
 + * be perfectly matched up with get_user_page() calls.
++=======
+  * For non-huge pages, the return value is partially fuzzy: false is not fuzzy,
+  * because it means "definitely not pinned for DMA", but true means "probably
+  * pinned for DMA, but possibly a false positive due to having at least
+  * GUP_PIN_COUNTING_BIAS worth of normal page references".
+  *
+  * False positives are OK, because: a) it's unlikely for a page to get that many
+  * refcounts, and b) all the callers of this routine are expected to be able to
+  * deal gracefully with a false positive.
+  *
+  * For huge pages, the result will be exactly correct. That's because we have
+  * more tracking data available: the 3rd struct page in the compound page is
+  * used to track the pincount (instead using of the GUP_PIN_COUNTING_BIAS
+  * scheme).
+  *
+  * For more information, please see Documentation/core-api/pin_user_pages.rst.
+  *
+  * @page:	pointer to page to be queried.
+  * @Return:	True, if it is likely that the page has been "dma-pinned".
+  *		False, if the page is definitely not dma-pinned.
++>>>>>>> 72ef5e52b3f7 (docs: fix broken references to text files)
   */
 -static inline bool page_maybe_dma_pinned(struct page *page)
 +static inline void put_user_page(struct page *page)
  {
 -	if (hpage_pincount_available(page))
 -		return compound_pincount(page) > 0;
 -
 -	/*
 -	 * page_ref_count() is signed. If that refcount overflows, then
 -	 * page_ref_count() returns a negative value, and callers will avoid
 -	 * further incrementing the refcount.
 -	 *
 -	 * Here, for that overflow case, use the signed bit to count a little
 -	 * bit higher via unsigned math, and thus still get an accurate result.
 -	 */
 -	return ((unsigned int)page_ref_count(compound_head(page))) >=
 -		GUP_PIN_COUNTING_BIAS;
 +	put_page(page);
  }
  
 +void put_user_pages_dirty(struct page **pages, unsigned long npages);
 +void put_user_pages_dirty_lock(struct page **pages, unsigned long npages);
 +void put_user_pages(struct page **pages, unsigned long npages);
 +
  #if defined(CONFIG_SPARSEMEM) && !defined(CONFIG_SPARSEMEM_VMEMMAP)
  #define SECTION_IN_PAGE_FLAGS
  #endif
@@@ -2572,11 -2802,39 +2594,42 @@@ struct page *follow_page(struct vm_area
   * Currently only get_user_pages() and get_user_pages_fast() support this flag
   * and calls to get_user_pages_[un]locked are specifically not allowed.  This
   * is due to an incompatibility with the FS DAX check and
 - * FAULT_FLAG_ALLOW_RETRY.
 + * FAULT_FLAG_ALLOW_RETRY
   *
 - * In the CMA case: long term pins in a CMA region would unnecessarily fragment
 - * that region.  And so, CMA attempts to migrate the page before pinning, when
 + * In the CMA case: longterm pins in a CMA region would unnecessarily fragment
 + * that region.  And so CMA attempts to migrate the page before pinning when
   * FOLL_LONGTERM is specified.
++<<<<<<< HEAD
++=======
+  *
+  * FOLL_PIN indicates that a special kind of tracking (not just page->_refcount,
+  * but an additional pin counting system) will be invoked. This is intended for
+  * anything that gets a page reference and then touches page data (for example,
+  * Direct IO). This lets the filesystem know that some non-file-system entity is
+  * potentially changing the pages' data. In contrast to FOLL_GET (whose pages
+  * are released via put_page()), FOLL_PIN pages must be released, ultimately, by
+  * a call to unpin_user_page().
+  *
+  * FOLL_PIN is similar to FOLL_GET: both of these pin pages. They use different
+  * and separate refcounting mechanisms, however, and that means that each has
+  * its own acquire and release mechanisms:
+  *
+  *     FOLL_GET: get_user_pages*() to acquire, and put_page() to release.
+  *
+  *     FOLL_PIN: pin_user_pages*() to acquire, and unpin_user_pages to release.
+  *
+  * FOLL_PIN and FOLL_GET are mutually exclusive for a given function call.
+  * (The underlying pages may experience both FOLL_GET-based and FOLL_PIN-based
+  * calls applied to them, and that's perfectly OK. This is a constraint on the
+  * callers, not on the pages.)
+  *
+  * FOLL_PIN should be set internally by the pin_user_pages*() APIs, never
+  * directly by the caller. That's in order to help avoid mismatches when
+  * releasing pages: get_user_pages*() pages must be released via put_page(),
+  * while pin_user_pages*() pages must be released via unpin_user_page().
+  *
+  * Please see Documentation/core-api/pin_user_pages.rst for more information.
++>>>>>>> 72ef5e52b3f7 (docs: fix broken references to text files)
   */
  
  static inline int vm_fault_to_errno(vm_fault_t vm_fault, int foll_flags)
diff --cc include/uapi/rdma/rdma_user_ioctl_cmds.h
index 64c14cb0022f,38ab7accb7be..000000000000
--- a/include/uapi/rdma/rdma_user_ioctl_cmds.h
+++ b/include/uapi/rdma/rdma_user_ioctl_cmds.h
@@@ -36,7 -36,7 +36,11 @@@
  #include <linux/types.h>
  #include <linux/ioctl.h>
  
++<<<<<<< HEAD
 +/* Documentation/ioctl/ioctl-number.txt */
++=======
+ /* Documentation/userspace-api/ioctl/ioctl-number.rst */
++>>>>>>> 72ef5e52b3f7 (docs: fix broken references to text files)
  #define RDMA_IOCTL_MAGIC	0x1b
  #define RDMA_VERBS_IOCTL \
  	_IOWR(RDMA_IOCTL_MAGIC, 1, struct ib_uverbs_ioctl_hdr)
diff --cc mm/gup.c
index ed9c3b00a481,81e4d0b377fd..000000000000
--- a/mm/gup.c
+++ b/mm/gup.c
@@@ -2273,4 -2792,148 +2273,152 @@@ int get_user_pages_fast(unsigned long s
  	return ret;
  }
  
++<<<<<<< HEAD
 +#endif /* CONFIG_HAVE_GENERIC_GUP */
++=======
+ /**
+  * get_user_pages_fast() - pin user pages in memory
+  * @start:      starting user address
+  * @nr_pages:   number of pages from start to pin
+  * @gup_flags:  flags modifying pin behaviour
+  * @pages:      array that receives pointers to the pages pinned.
+  *              Should be at least nr_pages long.
+  *
+  * Attempt to pin user pages in memory without taking mm->mmap_sem.
+  * If not successful, it will fall back to taking the lock and
+  * calling get_user_pages().
+  *
+  * Returns number of pages pinned. This may be fewer than the number requested.
+  * If nr_pages is 0 or negative, returns 0. If no pages were pinned, returns
+  * -errno.
+  */
+ int get_user_pages_fast(unsigned long start, int nr_pages,
+ 			unsigned int gup_flags, struct page **pages)
+ {
+ 	/*
+ 	 * FOLL_PIN must only be set internally by the pin_user_pages*() APIs,
+ 	 * never directly by the caller, so enforce that:
+ 	 */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_PIN))
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * The caller may or may not have explicitly set FOLL_GET; either way is
+ 	 * OK. However, internally (within mm/gup.c), gup fast variants must set
+ 	 * FOLL_GET, because gup fast is always a "pin with a +1 page refcount"
+ 	 * request.
+ 	 */
+ 	gup_flags |= FOLL_GET;
+ 	return internal_get_user_pages_fast(start, nr_pages, gup_flags, pages);
+ }
+ EXPORT_SYMBOL_GPL(get_user_pages_fast);
+ 
+ /**
+  * pin_user_pages_fast() - pin user pages in memory without taking locks
+  *
+  * @start:      starting user address
+  * @nr_pages:   number of pages from start to pin
+  * @gup_flags:  flags modifying pin behaviour
+  * @pages:      array that receives pointers to the pages pinned.
+  *              Should be at least nr_pages long.
+  *
+  * Nearly the same as get_user_pages_fast(), except that FOLL_PIN is set. See
+  * get_user_pages_fast() for documentation on the function arguments, because
+  * the arguments here are identical.
+  *
+  * FOLL_PIN means that the pages must be released via unpin_user_page(). Please
+  * see Documentation/core-api/pin_user_pages.rst for further details.
+  *
+  * This is intended for Case 1 (DIO) in Documentation/core-api/pin_user_pages.rst. It
+  * is NOT intended for Case 2 (RDMA: long-term pins).
+  */
+ int pin_user_pages_fast(unsigned long start, int nr_pages,
+ 			unsigned int gup_flags, struct page **pages)
+ {
+ 	/* FOLL_GET and FOLL_PIN are mutually exclusive. */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_GET))
+ 		return -EINVAL;
+ 
+ 	gup_flags |= FOLL_PIN;
+ 	return internal_get_user_pages_fast(start, nr_pages, gup_flags, pages);
+ }
+ EXPORT_SYMBOL_GPL(pin_user_pages_fast);
+ 
+ /**
+  * pin_user_pages_remote() - pin pages of a remote process (task != current)
+  *
+  * @tsk:	the task_struct to use for page fault accounting, or
+  *		NULL if faults are not to be recorded.
+  * @mm:		mm_struct of target mm
+  * @start:	starting user address
+  * @nr_pages:	number of pages from start to pin
+  * @gup_flags:	flags modifying lookup behaviour
+  * @pages:	array that receives pointers to the pages pinned.
+  *		Should be at least nr_pages long. Or NULL, if caller
+  *		only intends to ensure the pages are faulted in.
+  * @vmas:	array of pointers to vmas corresponding to each page.
+  *		Or NULL if the caller does not require them.
+  * @locked:	pointer to lock flag indicating whether lock is held and
+  *		subsequently whether VM_FAULT_RETRY functionality can be
+  *		utilised. Lock must initially be held.
+  *
+  * Nearly the same as get_user_pages_remote(), except that FOLL_PIN is set. See
+  * get_user_pages_remote() for documentation on the function arguments, because
+  * the arguments here are identical.
+  *
+  * FOLL_PIN means that the pages must be released via unpin_user_page(). Please
+  * see Documentation/core-api/pin_user_pages.rst for details.
+  *
+  * This is intended for Case 1 (DIO) in Documentation/core-api/pin_user_pages.rst. It
+  * is NOT intended for Case 2 (RDMA: long-term pins).
+  */
+ long pin_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
+ 			   unsigned long start, unsigned long nr_pages,
+ 			   unsigned int gup_flags, struct page **pages,
+ 			   struct vm_area_struct **vmas, int *locked)
+ {
+ 	/* FOLL_GET and FOLL_PIN are mutually exclusive. */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_GET))
+ 		return -EINVAL;
+ 
+ 	gup_flags |= FOLL_PIN;
+ 	return __get_user_pages_remote(tsk, mm, start, nr_pages, gup_flags,
+ 				       pages, vmas, locked);
+ }
+ EXPORT_SYMBOL(pin_user_pages_remote);
+ 
+ /**
+  * pin_user_pages() - pin user pages in memory for use by other devices
+  *
+  * @start:	starting user address
+  * @nr_pages:	number of pages from start to pin
+  * @gup_flags:	flags modifying lookup behaviour
+  * @pages:	array that receives pointers to the pages pinned.
+  *		Should be at least nr_pages long. Or NULL, if caller
+  *		only intends to ensure the pages are faulted in.
+  * @vmas:	array of pointers to vmas corresponding to each page.
+  *		Or NULL if the caller does not require them.
+  *
+  * Nearly the same as get_user_pages(), except that FOLL_TOUCH is not set, and
+  * FOLL_PIN is set.
+  *
+  * FOLL_PIN means that the pages must be released via unpin_user_page(). Please
+  * see Documentation/core-api/pin_user_pages.rst for details.
+  *
+  * This is intended for Case 1 (DIO) in Documentation/core-api/pin_user_pages.rst. It
+  * is NOT intended for Case 2 (RDMA: long-term pins).
+  */
+ long pin_user_pages(unsigned long start, unsigned long nr_pages,
+ 		    unsigned int gup_flags, struct page **pages,
+ 		    struct vm_area_struct **vmas)
+ {
+ 	/* FOLL_GET and FOLL_PIN are mutually exclusive. */
+ 	if (WARN_ON_ONCE(gup_flags & FOLL_GET))
+ 		return -EINVAL;
+ 
+ 	gup_flags |= FOLL_PIN;
+ 	return __gup_longterm_locked(current, current->mm, start, nr_pages,
+ 				     pages, vmas, gup_flags);
+ }
+ EXPORT_SYMBOL(pin_user_pages);
++>>>>>>> 72ef5e52b3f7 (docs: fix broken references to text files)
* Unmerged path Documentation/translations/it_IT/process/submit-checklist.rst
* Unmerged path Documentation/translations/zh_CN/process/submit-checklist.rst
* Unmerged path Documentation/virt/kvm/devices/vcpu.rst
* Unmerged path include/uapi/linux/ethtool_netlink.h
diff --git a/Documentation/memory-barriers.txt b/Documentation/memory-barriers.txt
index c314eea3f6f1..522b2596ff94 100644
--- a/Documentation/memory-barriers.txt
+++ b/Documentation/memory-barriers.txt
@@ -624,7 +624,7 @@ because the CPUs that the Linux kernel supports don't do writes
 until they are certain (1) that the write will actually happen, (2)
 of the location of the write, and (3) of the value to be written.
 But please carefully read the "CONTROL DEPENDENCIES" section and the
-Documentation/RCU/rcu_dereference.txt file:  The compiler can and does
+Documentation/RCU/rcu_dereference.rst file:  The compiler can and does
 break dependencies in a great many highly creative ways.
 
 	CPU 1		      CPU 2
* Unmerged path Documentation/process/submit-checklist.rst
* Unmerged path Documentation/translations/it_IT/process/submit-checklist.rst
diff --git a/Documentation/translations/ko_KR/memory-barriers.txt b/Documentation/translations/ko_KR/memory-barriers.txt
index 921739d00f69..a85fd72132ee 100644
--- a/Documentation/translations/ko_KR/memory-barriers.txt
+++ b/Documentation/translations/ko_KR/memory-barriers.txt
@@ -643,7 +643,7 @@ P 는 짝수 번호 캐시 라인에 저장되어 있고, 변수 B 는 홀수 
 리눅스 커널이 지원하는 CPU 들은 (1) 쓰기가 정말로 일어날지, (2) 쓰기가 어디에
 이루어질지, 그리고 (3) 쓰여질 값을 확실히 알기 전까지는 쓰기를 수행하지 않기
 때문입니다.  하지만 "컨트롤 의존성" 섹션과
-Documentation/RCU/rcu_dereference.txt 파일을 주의 깊게 읽어 주시기 바랍니다:
+Documentation/RCU/rcu_dereference.rst 파일을 주의 깊게 읽어 주시기 바랍니다:
 컴파일러는 매우 창의적인 많은 방법으로 종속성을 깰 수 있습니다.
 
 	CPU 1		      CPU 2
diff --git a/Documentation/translations/zh_CN/filesystems/sysfs.txt b/Documentation/translations/zh_CN/filesystems/sysfs.txt
index 452271dda141..58b9954d4e31 100644
--- a/Documentation/translations/zh_CN/filesystems/sysfs.txt
+++ b/Documentation/translations/zh_CN/filesystems/sysfs.txt
@@ -281,7 +281,7 @@ drivers/ 包含了每个已为特定总线上的设备而挂载的驱动程序
 假定驱动没有跨越多个总线类型)。
 
 fs/ 包含了一个为文件系统设立的目录。现在每个想要导出属性的文件系统必须
-在 fs/ 下创建自己的层次结构(参见Documentation/filesystems/fuse.txt)。
+在 fs/ 下创建自己的层次结构(参见Documentation/filesystems/fuse.rst)。
 
 dev/ 包含两个子目录： char/ 和 block/。在这两个子目录中，有以
 <major>:<minor> 格式命名的符号链接。这些符号链接指向 sysfs 目录
* Unmerged path Documentation/translations/zh_CN/process/submit-checklist.rst
diff --git a/Documentation/virt/kvm/arm/pvtime.rst b/Documentation/virt/kvm/arm/pvtime.rst
index 2357dd2d8655..687b60d76ca9 100644
--- a/Documentation/virt/kvm/arm/pvtime.rst
+++ b/Documentation/virt/kvm/arm/pvtime.rst
@@ -76,5 +76,5 @@ It is advisable that one or more 64k pages are set aside for the purpose of
 these structures and not used for other purposes, this enables the guest to map
 the region using 64k pages and avoids conflicting attributes with other memory.
 
-For the user space interface see Documentation/virt/kvm/devices/vcpu.txt
+For the user space interface see Documentation/virt/kvm/devices/vcpu.rst
 section "3. GROUP: KVM_ARM_VCPU_PVTIME_CTRL".
* Unmerged path Documentation/virt/kvm/devices/vcpu.rst
diff --git a/Documentation/virt/kvm/hypercalls.txt b/Documentation/virt/kvm/hypercalls.txt
index 5f6d291bd004..705c2115cfc7 100644
--- a/Documentation/virt/kvm/hypercalls.txt
+++ b/Documentation/virt/kvm/hypercalls.txt
@@ -18,7 +18,7 @@ S390:
   number in R1.
 
   For further information on the S390 diagnose call as supported by KVM,
-  refer to Documentation/virt/kvm/s390-diag.txt.
+  refer to Documentation/virt/kvm/s390-diag.rst.
 
  PowerPC:
   It uses R3-R10 and hypercall number in R11. R4-R11 are used as output registers.
@@ -26,7 +26,7 @@ S390:
 
   KVM hypercalls uses 4 byte opcode, that are patched with 'hypercall-instructions'
   property inside the device tree's /hypervisor node.
-  For more information refer to Documentation/virt/kvm/ppc-pv.txt
+  For more information refer to Documentation/virt/kvm/ppc-pv.rst
 
 MIPS:
   KVM hypercalls use the HYPCALL instruction with code 0 and the hypercall
diff --git a/arch/powerpc/include/uapi/asm/kvm_para.h b/arch/powerpc/include/uapi/asm/kvm_para.h
index be48c2215fa2..a809b1b44ddf 100644
--- a/arch/powerpc/include/uapi/asm/kvm_para.h
+++ b/arch/powerpc/include/uapi/asm/kvm_para.h
@@ -31,7 +31,7 @@
  * Struct fields are always 32 or 64 bit aligned, depending on them being 32
  * or 64 bit wide respectively.
  *
- * See Documentation/virt/kvm/ppc-pv.txt
+ * See Documentation/virt/kvm/ppc-pv.rst
  */
 struct kvm_vcpu_arch_shared {
 	__u64 scratch1;
diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index e531abf7e216..add1a4d546aa 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -141,7 +141,7 @@ config DRM_LOAD_EDID_FIRMWARE
 	  monitor are unable to provide appropriate EDID data. Since this
 	  feature is provided as a workaround for broken hardware, the
 	  default case is N. Details and instructions how to build your own
-	  EDID data are given in Documentation/driver-api/edid.rst.
+	  EDID data are given in Documentation/admin-guide/edid.rst.
 
 config DRM_DP_CEC
 	bool "Enable DisplayPort CEC-Tunneling-over-AUX HDMI support"
diff --git a/drivers/gpu/drm/drm_ioctl.c b/drivers/gpu/drm/drm_ioctl.c
index d9de5cf8c09f..7afd14d32fb6 100644
--- a/drivers/gpu/drm/drm_ioctl.c
+++ b/drivers/gpu/drm/drm_ioctl.c
@@ -741,7 +741,7 @@ static const struct drm_ioctl_desc drm_ioctls[] = {
  *     };
  *
  * Please make sure that you follow all the best practices from
- * ``Documentation/ioctl/botching-up-ioctls.rst``. Note that drm_ioctl()
+ * ``Documentation/process/botching-up-ioctls.rst``. Note that drm_ioctl()
  * automatically zero-extends structures, hence make sure you can add more stuff
  * at the end, i.e. don't put a variable sized array there.
  *
* Unmerged path drivers/hwtracing/coresight/Kconfig
diff --git a/fs/fat/Kconfig b/fs/fat/Kconfig
index 3ff1772f612e..ea5cdbf5c330 100644
--- a/fs/fat/Kconfig
+++ b/fs/fat/Kconfig
@@ -68,7 +68,7 @@ config VFAT_FS
 
 	  The VFAT support enlarges your kernel by about 10 KB and it only
 	  works if you said Y to the "DOS FAT fs support" above.  Please read
-	  the file <file:Documentation/filesystems/vfat.txt> for details.  If
+	  the file <file:Documentation/filesystems/vfat.rst> for details.  If
 	  unsure, say Y.
 
 	  To compile this as a module, choose M here: the module will be called
@@ -81,7 +81,7 @@ config FAT_DEFAULT_CODEPAGE
 	help
 	  This option should be set to the codepage of your FAT filesystems.
 	  It can be overridden with the "codepage" mount option.
-	  See <file:Documentation/filesystems/vfat.txt> for more information.
+	  See <file:Documentation/filesystems/vfat.rst> for more information.
 
 config FAT_DEFAULT_IOCHARSET
 	string "Default iocharset for FAT"
@@ -95,7 +95,7 @@ config FAT_DEFAULT_IOCHARSET
 	  Note that "utf8" is not recommended for FAT filesystems.
 	  If unsure, you shouldn't set "utf8" here - select the next option
 	  instead if you would like to use UTF-8 encoded file names by default.
-	  See <file:Documentation/filesystems/vfat.txt> for more information.
+	  See <file:Documentation/filesystems/vfat.rst> for more information.
 
 	  Enable any character sets you need in File Systems/Native Language
 	  Support.
@@ -113,4 +113,4 @@ config FAT_DEFAULT_UTF8
 
 	  Say Y if you use UTF-8 encoding for file names, N otherwise.
 
-	  See <file:Documentation/filesystems/vfat.txt> for more information.
+	  See <file:Documentation/filesystems/vfat.rst> for more information.
diff --git a/fs/fuse/Kconfig b/fs/fuse/Kconfig
index 46e9a8ff9f7a..0dfc8b1ec6cf 100644
--- a/fs/fuse/Kconfig
+++ b/fs/fuse/Kconfig
@@ -11,7 +11,7 @@ config FUSE_FS
 	  although chances are your distribution already has that library
 	  installed if you've installed the "fuse" package itself.
 
-	  See <file:Documentation/filesystems/fuse.txt> for more information.
+	  See <file:Documentation/filesystems/fuse.rst> for more information.
 	  See <file:Documentation/Changes> for needed library/utility version.
 
 	  If you want to develop a userspace FS, or if you want to use
diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c
index 4f2e4f38feb8..61fbf143a64b 100644
--- a/fs/fuse/dev.c
+++ b/fs/fuse/dev.c
@@ -2076,7 +2076,7 @@ static void end_polls(struct fuse_conn *fc)
  * The same effect is usually achievable through killing the filesystem daemon
  * and all users of the filesystem.  The exception is the combination of an
  * asynchronous request and the tricky deadlock (see
- * Documentation/filesystems/fuse.txt).
+ * Documentation/filesystems/fuse.rst).
  *
  * Aborting requests under I/O goes as follows: 1: Separate out unlocked
  * requests, they should be finished off immediately.  Locked requests will be
diff --git a/fs/overlayfs/Kconfig b/fs/overlayfs/Kconfig
index 2ef91be2a04e..a16ea29b98b1 100644
--- a/fs/overlayfs/Kconfig
+++ b/fs/overlayfs/Kconfig
@@ -8,7 +8,7 @@ config OVERLAY_FS
 	  'lower' filesystem is either hidden or, in the case of directories,
 	  merged with the 'upper' object.
 
-	  For more information see Documentation/filesystems/overlayfs.txt
+	  For more information see Documentation/filesystems/overlayfs.rst
 
 config OVERLAY_FS_REDIRECT_DIR
 	bool "Overlayfs: turn on redirect directory feature by default"
@@ -37,7 +37,7 @@ config OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW
 	  If backward compatibility is not an issue, then it is safe and
 	  recommended to say N here.
 
-	  For more information, see Documentation/filesystems/overlayfs.txt
+	  For more information, see Documentation/filesystems/overlayfs.rst
 
 	  If unsure, say Y.
 
@@ -101,7 +101,7 @@ config OVERLAY_FS_XINO_AUTO
 	  If compatibility with applications that expect 32bit inodes is not an
 	  issue, then it is safe and recommended to say Y here.
 
-	  For more information, see Documentation/filesystems/overlayfs.txt
+	  For more information, see Documentation/filesystems/overlayfs.rst
 
 	  If unsure, say N.
 
* Unmerged path include/linux/mm.h
* Unmerged path include/uapi/linux/ethtool_netlink.h
* Unmerged path include/uapi/rdma/rdma_user_ioctl_cmds.h
* Unmerged path mm/gup.c
diff --git a/virt/kvm/arm/vgic/vgic-mmio-v3.c b/virt/kvm/arm/vgic/vgic-mmio-v3.c
index f90e9535b708..56690dfa2a2b 100644
--- a/virt/kvm/arm/vgic/vgic-mmio-v3.c
+++ b/virt/kvm/arm/vgic/vgic-mmio-v3.c
@@ -307,7 +307,7 @@ static unsigned long vgic_v3_uaccess_read_pending(struct kvm_vcpu *vcpu,
 	 * pending state of interrupt is latched in pending_latch variable.
 	 * Userspace will save and restore pending state and line_level
 	 * separately.
-	 * Refer to Documentation/virt/kvm/devices/arm-vgic-v3.txt
+	 * Refer to Documentation/virt/kvm/devices/arm-vgic-v3.rst
 	 * for handling of ISPENDR and ICPENDR.
 	 */
 	for (i = 0; i < len * 8; i++) {
diff --git a/virt/kvm/arm/vgic/vgic.h b/virt/kvm/arm/vgic/vgic.h
index 4796a86aec06..50b0a9cd14ed 100644
--- a/virt/kvm/arm/vgic/vgic.h
+++ b/virt/kvm/arm/vgic/vgic.h
@@ -53,7 +53,7 @@
 			    VGIC_AFFINITY_LEVEL(val, 3))
 
 /*
- * As per Documentation/virt/kvm/devices/arm-vgic-v3.txt,
+ * As per Documentation/virt/kvm/devices/arm-vgic-v3.rst,
  * below macros are defined for CPUREG encoding.
  */
 #define KVM_REG_ARM_VGIC_SYSREG_OP0_MASK   0x000000000000c000
@@ -74,7 +74,7 @@
 				      KVM_REG_ARM_VGIC_SYSREG_OP2_MASK)
 
 /*
- * As per Documentation/virt/kvm/devices/arm-vgic-its.txt,
+ * As per Documentation/virt/kvm/devices/arm-vgic-its.rst,
  * below macros are defined for ITS table entry encoding.
  */
 #define KVM_ITS_CTE_VALID_SHIFT		63
