io_uring: add comment for drain_next

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pavel Begunkov <asml.silence@gmail.com>
commit 8cdf2193a3335b4cfb6e023b41ac293d0843d287
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8cdf2193.failed

Draining the middle of a link is tricky, so leave a comment there

	Signed-off-by: Pavel Begunkov <asml.silence@gmail.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 8cdf2193a3335b4cfb6e023b41ac293d0843d287)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index e4dddc0b25db,a700ee5fc89d..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -2324,10 -4627,20 +2324,25 @@@ err
  	 * conditions are true (normal request), then just queue it.
  	 */
  	if (*link) {
 -		struct io_kiocb *head = *link;
 +		struct io_kiocb *prev = *link;
  
++<<<<<<< HEAD
 +		sqe_copy = kmemdup(s->sqe, sizeof(*sqe_copy), GFP_KERNEL);
 +		if (!sqe_copy) {
++=======
+ 		/*
+ 		 * Taking sequential execution of a link, draining both sides
+ 		 * of the link also fullfils IOSQE_IO_DRAIN semantics for all
+ 		 * requests in the link. So, it drains the head and the
+ 		 * next after the link request. The last one is done via
+ 		 * drain_next flag to persist the effect across calls.
+ 		 */
+ 		if (sqe_flags & IOSQE_IO_DRAIN) {
+ 			head->flags |= REQ_F_IO_DRAIN;
+ 			ctx->drain_next = 1;
+ 		}
+ 		if (io_alloc_async_ctx(req)) {
++>>>>>>> 8cdf2193a333 (io_uring: add comment for drain_next)
  			ret = -EAGAIN;
  			goto err_req;
  		}
* Unmerged path fs/io_uring.c
