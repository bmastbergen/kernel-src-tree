KVM: VMX: Don't reload APIC access page if its control is disabled

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 4de1f9d469f4515464c2c4958a59479f641970ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/4de1f9d4.failed

Don't reload the APIC access page if its control is disabled, e.g. if
the guest is running with x2APIC (likely) or with the local APIC
disabled (unlikely), to avoid unnecessary TLB flushes and VMWRITEs.
Unconditionally reload the APIC access page and flush the TLB when
the guest's virtual APIC transitions to "xAPIC enabled", as any
changes to the APIC access page's mapping will not be recorded while
the guest's virtual APIC is disabled.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200320212833.3507-30-sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 4de1f9d469f4515464c2c4958a59479f641970ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index dbadf7ce3b2f,a87b8c1e8de6..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -6184,7 -6126,15 +6184,19 @@@ void vmx_set_virtual_apic_mode(struct k
  		if (flexpriority_enabled) {
  			sec_exec_control |=
  				SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
++<<<<<<< HEAD
 +			vmx_flush_tlb(vcpu, true);
++=======
+ 			kvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);
+ 
+ 			/*
+ 			 * Flush the TLB, reloading the APIC access page will
+ 			 * only do so if its physical address has changed, but
+ 			 * the guest may have inserted a non-APIC mapping into
+ 			 * the TLB while the APIC access page was disabled.
+ 			 */
+ 			kvm_make_request(KVM_REQ_TLB_FLUSH_CURRENT, vcpu);
++>>>>>>> 4de1f9d469f4 (KVM: VMX: Don't reload APIC access page if its control is disabled)
  		}
  		break;
  	case LAPIC_MODE_X2APIC:
@@@ -6198,12 -6148,32 +6210,32 @@@
  	vmx_update_msr_bitmap(vcpu);
  }
  
 -static void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu)
 +static void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu, hpa_t hpa)
  {
 -	struct page *page;
 -
 -	/* Defer reload until vmcs01 is the current VMCS. */
 -	if (is_guest_mode(vcpu)) {
 -		to_vmx(vcpu)->nested.reload_vmcs01_apic_access_page = true;
 -		return;
 +	if (!is_guest_mode(vcpu)) {
 +		vmcs_write64(APIC_ACCESS_ADDR, hpa);
 +		vmx_flush_tlb(vcpu, true);
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (!(secondary_exec_controls_get(to_vmx(vcpu)) &
+ 	    SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))
+ 		return;
+ 
+ 	page = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);
+ 	if (is_error_page(page))
+ 		return;
+ 
+ 	vmcs_write64(APIC_ACCESS_ADDR, page_to_phys(page));
+ 	vmx_flush_tlb_current(vcpu);
+ 
+ 	/*
+ 	 * Do not pin apic access page in memory, the MMU notifier
+ 	 * will call us again if it is migrated or swapped out.
+ 	 */
+ 	put_page(page);
++>>>>>>> 4de1f9d469f4 (KVM: VMX: Don't reload APIC access page if its control is disabled)
  }
  
  static void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)
* Unmerged path arch/x86/kvm/vmx/vmx.c
