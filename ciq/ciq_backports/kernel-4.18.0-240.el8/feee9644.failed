swiotlb: remove swiotlb_dma_supported

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Christoph Hellwig <hch@lst.de>
commit feee96440c9c5fdf47f8c8079c104fc8082924a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/feee9644.failed

The only user left is powerpc, but even there the generic dma-direct
version works just as well, given that we guarantee that the swiotlb
buffer must always be addressable.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Tested-by: Christian Zigotzky <chzigotzky@xenosoft.de>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit feee96440c9c5fdf47f8c8079c104fc8082924a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/dma/swiotlb.c
diff --cc kernel/dma/swiotlb.c
index 772e6f52f9c5,cbf3498a46f9..000000000000
--- a/kernel/dma/swiotlb.c
+++ b/kernel/dma/swiotlb.c
@@@ -678,45 -648,3 +678,48 @@@ bool swiotlb_map(struct device *dev, ph
  
  	return true;
  }
++<<<<<<< HEAD
 +
 +/*
 + * Return whether the given device DMA address mask can be supported
 + * properly.  For example, if your device can only drive the low 24-bits
 + * during bus mastering, then you would pass 0x00ffffff as the mask to
 + * this function.
 + */
 +int
 +swiotlb_dma_supported(struct device *hwdev, u64 mask)
 +{
 +	return __phys_to_dma(hwdev, io_tlb_end - 1) <= mask;
 +}
 +
 +size_t swiotlb_max_mapping_size(struct device *dev)
 +{
 +	return ((size_t)1 << IO_TLB_SHIFT) * IO_TLB_SEGSIZE;
 +}
 +
 +bool is_swiotlb_active(void)
 +{
 +	/*
 +	 * When SWIOTLB is initialized, even if io_tlb_start points to physical
 +	 * address zero, io_tlb_end surely doesn't.
 +	 */
 +	return io_tlb_end != 0;
 +}
 +
 +#ifdef CONFIG_DEBUG_FS
 +
 +static int __init swiotlb_create_debugfs(void)
 +{
 +	struct dentry *root;
 +
 +	root = debugfs_create_dir("swiotlb", NULL);
 +	debugfs_create_ulong("io_tlb_nslabs", 0400, root, &io_tlb_nslabs);
 +	debugfs_create_ulong("io_tlb_used", 0400, root, &io_tlb_used);
 +	return 0;
 +}
 +
 +late_initcall(swiotlb_create_debugfs);
 +
 +#endif
++=======
++>>>>>>> feee96440c9c (swiotlb: remove swiotlb_dma_supported)
diff --git a/arch/powerpc/kernel/dma-swiotlb.c b/arch/powerpc/kernel/dma-swiotlb.c
index d5950a0cb758..6d2677b2daa6 100644
--- a/arch/powerpc/kernel/dma-swiotlb.c
+++ b/arch/powerpc/kernel/dma-swiotlb.c
@@ -36,7 +36,7 @@ const struct dma_map_ops powerpc_swiotlb_dma_ops = {
 	.free = __dma_nommu_free_coherent,
 	.map_sg = dma_direct_map_sg,
 	.unmap_sg = dma_direct_unmap_sg,
-	.dma_supported = swiotlb_dma_supported,
+	.dma_supported = dma_direct_supported,
 	.map_page = dma_direct_map_page,
 	.unmap_page = dma_direct_unmap_page,
 	.sync_single_for_cpu = dma_direct_sync_single_for_cpu,
diff --git a/include/linux/swiotlb.h b/include/linux/swiotlb.h
index 29bc3a203283..361f62bb4a8e 100644
--- a/include/linux/swiotlb.h
+++ b/include/linux/swiotlb.h
@@ -60,9 +60,6 @@ extern void swiotlb_tbl_sync_single(struct device *hwdev,
 				    size_t size, enum dma_data_direction dir,
 				    enum dma_sync_target target);
 
-extern int
-swiotlb_dma_supported(struct device *hwdev, u64 mask);
-
 #ifdef CONFIG_SWIOTLB
 extern enum swiotlb_force swiotlb_force;
 extern phys_addr_t io_tlb_start, io_tlb_end;
* Unmerged path kernel/dma/swiotlb.c
