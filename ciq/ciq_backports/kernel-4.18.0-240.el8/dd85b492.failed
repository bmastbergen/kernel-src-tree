null_blk: return fixed zoned reads > write pointer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ajay Joshi <ajay.joshi@wdc.com>
commit dd85b4922de1b70f0729d2a7856db619e210a8ec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dd85b492.failed

A zoned block device maintains a write pointer within a zone, and reads
beyond the write pointer are undefined. Fill data buffer returned above
the write pointer with 0xFF.

	Signed-off-by: Ajay Joshi <ajay.joshi@wdc.com>
	Reviewed-by: Damien Le Moal <damien.lemoal@wdc.com>
	Reviewed-by: Matias Bj√∏rling <matias.bjorling@wdc.com>
	Signed-off-by: Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit dd85b4922de1b70f0729d2a7856db619e210a8ec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/null_blk.h
#	drivers/block/null_blk_zoned.c
diff --cc drivers/block/null_blk.h
index 0a5e75e1db62,93c2a3d403da..000000000000
--- a/drivers/block/null_blk.h
+++ b/drivers/block/null_blk.h
@@@ -92,11 -92,12 +92,20 @@@ struct nullb 
  int null_zone_init(struct nullb_device *dev);
  void null_zone_exit(struct nullb_device *dev);
  int null_zone_report(struct gendisk *disk, sector_t sector,
++<<<<<<< HEAD
 +		     struct blk_zone *zones, unsigned int *nr_zones,
 +		     gfp_t gfp_mask);
 +void null_zone_write(struct nullb_cmd *cmd, sector_t sector,
 +			unsigned int nr_sectors);
 +void null_zone_reset(struct nullb_cmd *cmd, sector_t sector);
++=======
+ 		     struct blk_zone *zones, unsigned int *nr_zones);
+ blk_status_t null_handle_zoned(struct nullb_cmd *cmd,
+ 				enum req_opf op, sector_t sector,
+ 				sector_t nr_sectors);
+ size_t null_zone_valid_read_len(struct nullb *nullb,
+ 				sector_t sector, unsigned int len);
++>>>>>>> dd85b4922de1 (null_blk: return fixed zoned reads > write pointer)
  #else
  static inline int null_zone_init(struct nullb_device *dev)
  {
@@@ -110,10 -111,17 +119,19 @@@ static inline int null_zone_report(stru
  {
  	return -EOPNOTSUPP;
  }
 -static inline blk_status_t null_handle_zoned(struct nullb_cmd *cmd,
 -					     enum req_opf op, sector_t sector,
 -					     sector_t nr_sectors)
 +static inline void null_zone_write(struct nullb_cmd *cmd, sector_t sector,
 +				   unsigned int nr_sectors)
  {
 -	return BLK_STS_NOTSUPP;
  }
++<<<<<<< HEAD
 +static inline void null_zone_reset(struct nullb_cmd *cmd, sector_t sector) {}
++=======
+ static inline size_t null_zone_valid_read_len(struct nullb *nullb,
+ 					      sector_t sector,
+ 					      unsigned int len)
+ {
+ 	return len;
+ }
++>>>>>>> dd85b4922de1 (null_blk: return fixed zoned reads > write pointer)
  #endif /* CONFIG_BLK_DEV_ZONED */
  #endif /* __NULL_BLK_H */
diff --cc drivers/block/null_blk_zoned.c
index 176ae5c83b71,e020f17dac9f..000000000000
--- a/drivers/block/null_blk_zoned.c
+++ b/drivers/block/null_blk_zoned.c
@@@ -85,7 -84,25 +85,29 @@@ int null_zone_report(struct gendisk *di
  	return 0;
  }
  
++<<<<<<< HEAD
 +void null_zone_write(struct nullb_cmd *cmd, sector_t sector,
++=======
+ size_t null_zone_valid_read_len(struct nullb *nullb,
+ 				sector_t sector, unsigned int len)
+ {
+ 	struct nullb_device *dev = nullb->dev;
+ 	struct blk_zone *zone = &dev->zones[null_zone_no(dev, sector)];
+ 	unsigned int nr_sectors = len >> SECTOR_SHIFT;
+ 
+ 	/* Read must be below the write pointer position */
+ 	if (zone->type == BLK_ZONE_TYPE_CONVENTIONAL ||
+ 	    sector + nr_sectors <= zone->wp)
+ 		return len;
+ 
+ 	if (sector > zone->wp)
+ 		return 0;
+ 
+ 	return (zone->wp - sector) << SECTOR_SHIFT;
+ }
+ 
+ static blk_status_t null_zone_write(struct nullb_cmd *cmd, sector_t sector,
++>>>>>>> dd85b4922de1 (null_blk: return fixed zoned reads > write pointer)
  		     unsigned int nr_sectors)
  {
  	struct nullb_device *dev = cmd->nq->dev;
@@@ -116,16 -131,15 +138,15 @@@
  		break;
  	default:
  		/* Invalid zone condition */
 -		return BLK_STS_IOERR;
 +		cmd->error = BLK_STS_IOERR;
 +		break;
  	}
 -	return BLK_STS_OK;
  }
  
 -static blk_status_t null_zone_reset(struct nullb_cmd *cmd, sector_t sector)
 +void null_zone_reset(struct nullb_cmd *cmd, sector_t sector)
  {
  	struct nullb_device *dev = cmd->nq->dev;
- 	unsigned int zno = null_zone_no(dev, sector);
- 	struct blk_zone *zone = &dev->zones[zno];
+ 	struct blk_zone *zone = &dev->zones[null_zone_no(dev, sector)];
  	size_t i;
  
  	switch (req_op(cmd->rq)) {
* Unmerged path drivers/block/null_blk.h
diff --git a/drivers/block/null_blk_main.c b/drivers/block/null_blk_main.c
index 5778d912ce37..13839ed29bad 100644
--- a/drivers/block/null_blk_main.c
+++ b/drivers/block/null_blk_main.c
@@ -1021,6 +1021,16 @@ static int copy_from_nullb(struct nullb *nullb, struct page *dest,
 	return 0;
 }
 
+static void nullb_fill_pattern(struct nullb *nullb, struct page *page,
+			       unsigned int len, unsigned int off)
+{
+	void *dst;
+
+	dst = kmap_atomic(page);
+	memset(dst + off, 0xFF, len);
+	kunmap_atomic(dst);
+}
+
 static void null_handle_discard(struct nullb *nullb, sector_t sector, size_t n)
 {
 	size_t temp;
@@ -1061,10 +1071,24 @@ static int null_transfer(struct nullb *nullb, struct page *page,
 	unsigned int len, unsigned int off, bool is_write, sector_t sector,
 	bool is_fua)
 {
+	struct nullb_device *dev = nullb->dev;
+	unsigned int valid_len = len;
 	int err = 0;
 
 	if (!is_write) {
-		err = copy_from_nullb(nullb, page, off, sector, len);
+		if (dev->zoned)
+			valid_len = null_zone_valid_read_len(nullb,
+				sector, len);
+
+		if (valid_len) {
+			err = copy_from_nullb(nullb, page, off,
+				sector, valid_len);
+			off += valid_len;
+			len -= valid_len;
+		}
+
+		if (len)
+			nullb_fill_pattern(nullb, page, len, off);
 		flush_dcache_page(page);
 	} else {
 		flush_dcache_page(page);
* Unmerged path drivers/block/null_blk_zoned.c
