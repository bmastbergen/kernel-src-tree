KVM: Move putting of vcpu->pid to kvm_vcpu_destroy()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 9941d224fb7c765bc20f3cb6c747786adc5cd002
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9941d224.failed

Move the putting of vcpu->pid to kvm_vcpu_destroy().  vcpu->pid is
guaranteed to be NULL when kvm_vcpu_uninit() is called in the error path
of kvm_vm_ioctl_create_vcpu(), e.g. it is explicitly nullified by
kvm_vcpu_init() and is only changed by KVM_RUN.

No functional change intended.

	Acked-by: Christoffer Dall <christoffer.dall@arm.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Reviewed-by: Cornelia Huck <cohuck@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9941d224fb7c765bc20f3cb6c747786adc5cd002)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	virt/kvm/kvm_main.c
diff --cc virt/kvm/kvm_main.c
index c6256c9afce6,483b6b8e70a1..000000000000
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@@ -351,31 -345,31 +351,52 @@@ int kvm_vcpu_init(struct kvm_vcpu *vcpu
  	kvm_vcpu_set_dy_eligible(vcpu, false);
  	vcpu->preempted = false;
  	vcpu->ready = false;
 -	preempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);
  
 +	r = kvm_arch_vcpu_init(vcpu);
 +	if (r < 0)
 +		goto fail_free_run;
  	return 0;
 +
 +fail_free_run:
 +	free_page((unsigned long)vcpu->run);
 +fail:
 +	return r;
  }
 +EXPORT_SYMBOL_GPL(kvm_vcpu_init);
  
 -static void kvm_vcpu_uninit(struct kvm_vcpu *vcpu)
 +void kvm_vcpu_uninit(struct kvm_vcpu *vcpu)
  {
++<<<<<<< HEAD
 +	/*
 +	 * no need for rcu_read_lock as VCPU_RUN is the only place that
 +	 * will change the vcpu->pid pointer and on uninit all file
 +	 * descriptors are already gone.
 +	 */
 +	put_pid(rcu_dereference_protected(vcpu->pid, 1));
 +	kvm_arch_vcpu_uninit(vcpu);
 +	free_page((unsigned long)vcpu->run);
 +}
 +EXPORT_SYMBOL_GPL(kvm_vcpu_uninit);
++=======
+ 	free_page((unsigned long)vcpu->run);
+ }
+ 
+ void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)
+ {
+ 	kvm_arch_vcpu_destroy(vcpu);
+ 
+ 	/*
+ 	 * No need for rcu_read_lock as VCPU_RUN is the only place that changes
+ 	 * the vcpu->pid pointer, and at destruction time all file descriptors
+ 	 * are already gone.
+ 	 */
+ 	put_pid(rcu_dereference_protected(vcpu->pid, 1));
+ 
+ 	kvm_vcpu_uninit(vcpu);
+ 	kmem_cache_free(kvm_vcpu_cache, vcpu);
+ }
+ EXPORT_SYMBOL_GPL(kvm_vcpu_destroy);
++>>>>>>> 9941d224fb7c (KVM: Move putting of vcpu->pid to kvm_vcpu_destroy())
  
  #if defined(CONFIG_MMU_NOTIFIER) && defined(KVM_ARCH_WANT_MMU_NOTIFIER)
  static inline struct kvm *mmu_notifier_to_kvm(struct mmu_notifier *mn)
* Unmerged path virt/kvm/kvm_main.c
