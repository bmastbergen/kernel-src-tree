kvm: x86: hyperv: Use APICv update request interface

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
commit f4fdc0a2edf48f16f7b10cceaf4781fc56ab7fd9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/f4fdc0a2.failed

Since disabling APICv has to be done for all vcpus on AMD-based
system, adopt the newly introduced kvm_request_apicv_update()
interface, and introduce a new APICV_INHIBIT_REASON_HYPERV.

Also, remove the kvm_vcpu_deactivate_apicv() since no longer used.

	Cc: Roman Kagan <rkagan@virtuozzo.com>
	Signed-off-by: Suravee Suthikulpanit <suravee.suthikulpanit@amd.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit f4fdc0a2edf48f16f7b10cceaf4781fc56ab7fd9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/svm.c
#	arch/x86/kvm/vmx/vmx.c
#	arch/x86/kvm/x86.c
diff --cc arch/x86/include/asm/kvm_host.h
index 5bd73b4f5d32,90bfe8becc56..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -876,6 -875,9 +876,12 @@@ enum kvm_irqchip_mode 
  	KVM_IRQCHIP_SPLIT,        /* created with KVM_CAP_SPLIT_IRQCHIP */
  };
  
++<<<<<<< HEAD
++=======
+ #define APICV_INHIBIT_REASON_DISABLE    0
+ #define APICV_INHIBIT_REASON_HYPERV     1
+ 
++>>>>>>> f4fdc0a2edf4 (kvm: x86: hyperv: Use APICv update request interface)
  struct kvm_arch {
  	unsigned long n_used_mmu_pages;
  	unsigned long n_requested_mmu_pages;
@@@ -1479,7 -1484,11 +1485,15 @@@ gpa_t kvm_mmu_gva_to_gpa_write(struct k
  gpa_t kvm_mmu_gva_to_gpa_system(struct kvm_vcpu *vcpu, gva_t gva,
  				struct x86_exception *exception);
  
++<<<<<<< HEAD
 +void kvm_vcpu_deactivate_apicv(struct kvm_vcpu *vcpu);
++=======
+ bool kvm_apicv_activated(struct kvm *kvm);
+ void kvm_apicv_init(struct kvm *kvm, bool enable);
+ void kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu);
+ void kvm_request_apicv_update(struct kvm *kvm, bool activate,
+ 			      unsigned long bit);
++>>>>>>> f4fdc0a2edf4 (kvm: x86: hyperv: Use APICv update request interface)
  
  int kvm_emulate_hypercall(struct kvm_vcpu *vcpu);
  
diff --cc arch/x86/kvm/svm.c
index 0b5d8983224a,3b87ccd320d1..000000000000
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@@ -7361,6 -7316,19 +7361,22 @@@ static bool svm_apic_init_signal_blocke
  		   (svm->vmcb->control.intercept & (1ULL << INTERCEPT_INIT));
  }
  
++<<<<<<< HEAD
++=======
+ static bool svm_check_apicv_inhibit_reasons(ulong bit)
+ {
+ 	ulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |
+ 			  BIT(APICV_INHIBIT_REASON_HYPERV);
+ 
+ 	return supported & BIT(bit);
+ }
+ 
+ static void svm_pre_update_apicv_exec_ctrl(struct kvm *kvm, bool activate)
+ {
+ 	avic_update_access_page(kvm, activate);
+ }
+ 
++>>>>>>> f4fdc0a2edf4 (kvm: x86: hyperv: Use APICv update request interface)
  static struct kvm_x86_ops svm_x86_ops __ro_after_init = {
  	.cpu_has_kvm_support = has_svm,
  	.disabled_by_bios = is_disabled,
diff --cc arch/x86/kvm/vmx/vmx.c
index 48e44d8933a0,678edbd6e278..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -7812,6 -7710,14 +7812,17 @@@ static __exit void hardware_unsetup(voi
  	free_kvm_area();
  }
  
++<<<<<<< HEAD
++=======
+ static bool vmx_check_apicv_inhibit_reasons(ulong bit)
+ {
+ 	ulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |
+ 			  BIT(APICV_INHIBIT_REASON_HYPERV);
+ 
+ 	return supported & BIT(bit);
+ }
+ 
++>>>>>>> f4fdc0a2edf4 (kvm: x86: hyperv: Use APICv update request interface)
  static struct kvm_x86_ops vmx_x86_ops __ro_after_init = {
  	.cpu_has_kvm_support = cpu_has_kvm_support,
  	.disabled_by_bios = vmx_disabled_by_bios,
diff --cc arch/x86/kvm/x86.c
index caae36aa2ba4,52edf0bb46e5..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -7437,18 -7457,22 +7437,37 @@@ static void kvm_pv_kick_cpu_op(struct k
  	kvm_irq_delivery_to_apic(kvm, NULL, &lapic_irq, NULL);
  }
  
++<<<<<<< HEAD
 +void kvm_vcpu_deactivate_apicv(struct kvm_vcpu *vcpu)
 +{
 +	if (!lapic_in_kernel(vcpu)) {
 +		WARN_ON_ONCE(vcpu->arch.apicv_active);
 +		return;
 +	}
 +	if (!vcpu->arch.apicv_active)
 +		return;
 +
 +	vcpu->arch.apicv_active = false;
 +	kvm_x86_ops->refresh_apicv_exec_ctrl(vcpu);
 +}
++=======
+ bool kvm_apicv_activated(struct kvm *kvm)
+ {
+ 	return (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);
+ }
+ EXPORT_SYMBOL_GPL(kvm_apicv_activated);
+ 
+ void kvm_apicv_init(struct kvm *kvm, bool enable)
+ {
+ 	if (enable)
+ 		clear_bit(APICV_INHIBIT_REASON_DISABLE,
+ 			  &kvm->arch.apicv_inhibit_reasons);
+ 	else
+ 		set_bit(APICV_INHIBIT_REASON_DISABLE,
+ 			&kvm->arch.apicv_inhibit_reasons);
+ }
+ EXPORT_SYMBOL_GPL(kvm_apicv_init);
++>>>>>>> f4fdc0a2edf4 (kvm: x86: hyperv: Use APICv update request interface)
  
  static void kvm_sched_yield(struct kvm *kvm, unsigned long dest_id)
  {
* Unmerged path arch/x86/include/asm/kvm_host.h
diff --git a/arch/x86/kvm/hyperv.c b/arch/x86/kvm/hyperv.c
index 1d09e7ed5d6f..86d5d6e31569 100644
--- a/arch/x86/kvm/hyperv.c
+++ b/arch/x86/kvm/hyperv.c
@@ -779,9 +779,10 @@ int kvm_hv_activate_synic(struct kvm_vcpu *vcpu, bool dont_zero_synic_pages)
 
 	/*
 	 * Hyper-V SynIC auto EOI SINT's are
-	 * not compatible with APICV, so deactivate APICV
+	 * not compatible with APICV, so request
+	 * to deactivate APICV permanently.
 	 */
-	kvm_vcpu_deactivate_apicv(vcpu);
+	kvm_request_apicv_update(vcpu->kvm, false, APICV_INHIBIT_REASON_HYPERV);
 	synic->active = true;
 	synic->dont_zero_synic_pages = dont_zero_synic_pages;
 	return 0;
* Unmerged path arch/x86/kvm/svm.c
* Unmerged path arch/x86/kvm/vmx/vmx.c
* Unmerged path arch/x86/kvm/x86.c
