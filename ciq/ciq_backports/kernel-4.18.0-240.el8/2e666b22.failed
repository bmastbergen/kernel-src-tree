netfilter: nat: remove l3 manip_pkt hook

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 2e666b229d97a9cdbc9fe571737eb297e7232098
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/2e666b22.failed

We can now use direct calls.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 2e666b229d97a9cdbc9fe571737eb297e7232098)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_nat_l3proto.h
#	net/netfilter/nf_nat_core.c
#	net/netfilter/nf_nat_proto.c
diff --cc include/net/netfilter/nf_nat_l3proto.h
index d300b8f03972,62ef15eb7594..000000000000
--- a/include/net/netfilter/nf_nat_l3proto.h
+++ b/include/net/netfilter/nf_nat_l3proto.h
@@@ -6,17 -5,6 +6,20 @@@ struct nf_nat_l4proto
  struct nf_nat_l3proto {
  	u8	l3proto;
  
++<<<<<<< HEAD
 +	bool	(*in_range)(const struct nf_conntrack_tuple *t,
 +			    const struct nf_nat_range2 *range);
 +
 +	u32 	(*secure_port)(const struct nf_conntrack_tuple *t, __be16);
 +
 +	bool	(*manip_pkt)(struct sk_buff *skb,
 +			     unsigned int iphdroff,
 +			     const struct nf_nat_l4proto *l4proto,
 +			     const struct nf_conntrack_tuple *target,
 +			     enum nf_nat_manip_type maniptype);
 +
++=======
++>>>>>>> 2e666b229d97 (netfilter: nat: remove l3 manip_pkt hook)
  	void	(*csum_update)(struct sk_buff *skb, unsigned int iphdroff,
  			       __sum16 *check,
  			       const struct nf_conntrack_tuple *t,
@@@ -25,17 -13,12 +28,21 @@@
  	void	(*csum_recalc)(struct sk_buff *skb, u8 proto,
  			       void *data, __sum16 *check,
  			       int datalen, int oldlen);
 +
 +	void	(*decode_session)(struct sk_buff *skb,
 +				  const struct nf_conn *ct,
 +				  enum ip_conntrack_dir dir,
 +				  unsigned long statusbit,
 +				  struct flowi *fl);
 +
 +	int	(*nlattr_to_range)(struct nlattr *tb[],
 +				   struct nf_nat_range2 *range);
  };
  
+ unsigned int nf_nat_manip_pkt(struct sk_buff *skb, struct nf_conn *ct,
+ 			      enum nf_nat_manip_type mtype,
+ 			      enum ip_conntrack_dir dir);
+ 
  int nf_nat_l3proto_register(const struct nf_nat_l3proto *);
  void nf_nat_l3proto_unregister(const struct nf_nat_l3proto *);
  const struct nf_nat_l3proto *__nf_nat_l3proto_find(u8 l3proto);
diff --cc net/netfilter/nf_nat_core.c
index 275265d75be2,8c5c29189383..000000000000
--- a/net/netfilter/nf_nat_core.c
+++ b/net/netfilter/nf_nat_core.c
@@@ -497,26 -699,6 +497,29 @@@ nf_nat_alloc_null_binding(struct nf_con
  }
  EXPORT_SYMBOL_GPL(nf_nat_alloc_null_binding);
  
++<<<<<<< HEAD
 +static unsigned int nf_nat_manip_pkt(struct sk_buff *skb, struct nf_conn *ct,
 +				     enum nf_nat_manip_type mtype,
 +				     enum ip_conntrack_dir dir)
 +{
 +	const struct nf_nat_l3proto *l3proto;
 +	const struct nf_nat_l4proto *l4proto;
 +	struct nf_conntrack_tuple target;
 +
 +	/* We are aiming to look like inverse of other direction. */
 +	nf_ct_invert_tuplepr(&target, &ct->tuplehash[!dir].tuple);
 +
 +	l3proto = __nf_nat_l3proto_find(target.src.l3num);
 +	l4proto = __nf_nat_l4proto_find(target.src.l3num,
 +					target.dst.protonum);
 +	if (!l3proto->manip_pkt(skb, 0, l4proto, &target, mtype))
 +		return NF_DROP;
 +
 +	return NF_ACCEPT;
 +}
 +
++=======
++>>>>>>> 2e666b229d97 (netfilter: nat: remove l3 manip_pkt hook)
  /* Do packet manipulations according to nf_nat_setup_info. */
  unsigned int nf_nat_packet(struct nf_conn *ct,
  			   enum ip_conntrack_info ctinfo,
* Unmerged path net/netfilter/nf_nat_proto.c
* Unmerged path include/net/netfilter/nf_nat_l3proto.h
* Unmerged path net/netfilter/nf_nat_core.c
* Unmerged path net/netfilter/nf_nat_proto.c
