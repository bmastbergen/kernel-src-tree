net/smc: unmapping of buffers to support multiple links

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Karsten Graul <kgraul@linux.ibm.com>
commit 4a3641c160873fe6b6bcff00a6ea15e7430d8d42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/4a3641c1.failed

With the support of multiple links that are created and cleared there
is a need to unmap one link from all current buffers. Add unmapping by
link and by rmb. And make smcr_link_clear() available to be called from
the LLC layer.

	Signed-off-by: Karsten Graul <kgraul@linux.ibm.com>
	Reviewed-by: Ursula Braun <ubraun@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4a3641c160873fe6b6bcff00a6ea15e7430d8d42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/smc/smc_core.c
#	net/smc/smc_core.h
diff --cc net/smc/smc_core.c
index 8d7f08e469be,d5ecea490b4e..000000000000
--- a/net/smc/smc_core.c
+++ b/net/smc/smc_core.c
@@@ -496,9 -498,64 +496,68 @@@ void smc_conn_free(struct smc_connectio
  		smc_lgr_schedule_free_work(lgr);
  }
  
- static void smcr_link_clear(struct smc_link *lnk)
+ /* unregister a link from a buf_desc */
+ static void smcr_buf_unmap_link(struct smc_buf_desc *buf_desc, bool is_rmb,
+ 				struct smc_link *lnk)
  {
+ 	if (is_rmb)
+ 		buf_desc->is_reg_mr[lnk->link_idx] = false;
+ 	if (!buf_desc->is_map_ib[lnk->link_idx])
+ 		return;
+ 	if (is_rmb) {
+ 		if (buf_desc->mr_rx[lnk->link_idx]) {
+ 			smc_ib_put_memory_region(
+ 					buf_desc->mr_rx[lnk->link_idx]);
+ 			buf_desc->mr_rx[lnk->link_idx] = NULL;
+ 		}
+ 		smc_ib_buf_unmap_sg(lnk, buf_desc, DMA_FROM_DEVICE);
+ 	} else {
+ 		smc_ib_buf_unmap_sg(lnk, buf_desc, DMA_TO_DEVICE);
+ 	}
+ 	sg_free_table(&buf_desc->sgt[lnk->link_idx]);
+ 	buf_desc->is_map_ib[lnk->link_idx] = false;
+ }
+ 
+ /* unmap all buffers of lgr for a deleted link */
+ static void smcr_buf_unmap_lgr(struct smc_link *lnk)
+ {
+ 	struct smc_link_group *lgr = lnk->lgr;
+ 	struct smc_buf_desc *buf_desc, *bf;
+ 	int i;
+ 
+ 	for (i = 0; i < SMC_RMBE_SIZES; i++) {
+ 		mutex_lock(&lgr->rmbs_lock);
+ 		list_for_each_entry_safe(buf_desc, bf, &lgr->rmbs[i], list)
+ 			smcr_buf_unmap_link(buf_desc, true, lnk);
+ 		mutex_unlock(&lgr->rmbs_lock);
+ 		mutex_lock(&lgr->sndbufs_lock);
+ 		list_for_each_entry_safe(buf_desc, bf, &lgr->sndbufs[i],
+ 					 list)
+ 			smcr_buf_unmap_link(buf_desc, false, lnk);
+ 		mutex_unlock(&lgr->sndbufs_lock);
+ 	}
+ }
+ 
+ static void smcr_rtoken_clear_link(struct smc_link *lnk)
+ {
+ 	struct smc_link_group *lgr = lnk->lgr;
+ 	int i;
+ 
+ 	for (i = 0; i < SMC_RMBS_PER_LGR_MAX; i++) {
+ 		lgr->rtokens[i][lnk->link_idx].rkey = 0;
+ 		lgr->rtokens[i][lnk->link_idx].dma_addr = 0;
+ 	}
+ }
+ 
+ void smcr_link_clear(struct smc_link *lnk)
+ {
++<<<<<<< HEAD
 +	if (lnk->peer_qpn == 0)
++=======
+ 	struct smc_ib_device *smcibdev;
+ 
+ 	if (!lnk->lgr || lnk->state == SMC_LNK_UNUSED)
++>>>>>>> 4a3641c16087 (net/smc: unmapping of buffers to support multiple links)
  		return;
  	lnk->peer_qpn = 0;
  	smc_llc_link_clear(lnk);
diff --cc net/smc/smc_core.h
index dbb7446cbf6a,fa532a423fd7..000000000000
--- a/net/smc/smc_core.h
+++ b/net/smc/smc_core.h
@@@ -335,6 -367,8 +335,11 @@@ void smc_lgr_schedule_free_work_fast(st
  int smc_core_init(void);
  void smc_core_exit(void);
  
++<<<<<<< HEAD
++=======
+ void smcr_link_clear(struct smc_link *lnk);
+ int smcr_link_reg_rmb(struct smc_link *link, struct smc_buf_desc *rmb_desc);
++>>>>>>> 4a3641c16087 (net/smc: unmapping of buffers to support multiple links)
  static inline struct smc_link_group *smc_get_lgr(struct smc_link *link)
  {
  	return link->lgr;
* Unmerged path net/smc/smc_core.c
* Unmerged path net/smc/smc_core.h
