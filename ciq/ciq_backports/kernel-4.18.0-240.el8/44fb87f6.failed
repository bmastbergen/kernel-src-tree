netfilter: conntrack: remove remaining l4proto indirect packet calls

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit 44fb87f6351d04fafae2b17df5f46f1ce22c6f93
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/44fb87f6.failed

Now that all l4trackers are builtin, no need to use a mix of direct and
indirect calls.
This removes the last two users: gre and the generic l4 protocol
tracker.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 44fb87f6351d04fafae2b17df5f46f1ce22c6f93)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_conntrack_l4proto.h
#	net/netfilter/nf_conntrack_core.c
#	net/netfilter/nf_conntrack_proto_generic.c
#	net/netfilter/nf_conntrack_proto_gre.c
diff --cc include/net/netfilter/nf_conntrack_l4proto.h
index 264f50873a3a,dda028996559..000000000000
--- a/include/net/netfilter/nf_conntrack_l4proto.h
+++ b/include/net/netfilter/nf_conntrack_l4proto.h
@@@ -30,29 -27,6 +30,32 @@@ struct nf_conntrack_l4proto 
  	/* protoinfo nlattr size, closes a hole */
  	u16 nlattr_size;
  
++<<<<<<< HEAD
 +	/* Try to fill in the third arg: dataoff is offset past network protocol
 +           hdr.  Return true if possible. */
 +	bool (*pkt_to_tuple)(const struct sk_buff *skb, unsigned int dataoff,
 +			     struct net *net, struct nf_conntrack_tuple *tuple);
 +
 +	/* Invert the per-proto part of the tuple: ie. turn xmit into reply.
 +	 * Only used by icmp, most protocols use a generic version.
 +	 */
 +	bool (*invert_tuple)(struct nf_conntrack_tuple *inverse,
 +			     const struct nf_conntrack_tuple *orig);
 +
 +	/* Returns verdict for packet, or -1 for invalid. */
 +	int (*packet)(struct nf_conn *ct,
 +		      const struct sk_buff *skb,
 +		      unsigned int dataoff,
 +		      enum ip_conntrack_info ctinfo,
 +		      unsigned int *timeouts);
 +
 +	/* Called when a new connection for this protocol found;
 +	 * returns TRUE if it's OK.  If so, packet() called next. */
 +	bool (*new)(struct nf_conn *ct, const struct sk_buff *skb,
 +		    unsigned int dataoff, unsigned int *timeouts);
 +
++=======
++>>>>>>> 44fb87f6351d (netfilter: conntrack: remove remaining l4proto indirect packet calls)
  	/* Called when a conntrack entry is destroyed */
  	void (*destroy)(struct nf_conn *ct);
  
@@@ -100,11 -67,74 +103,80 @@@
  
  	/* Return the per-net protocol part. */
  	struct nf_proto_net *(*get_net_proto)(struct net *net);
 +
 +	/* Module (if any) which this is connected to. */
 +	struct module *me;
  };
  
++<<<<<<< HEAD
++=======
+ bool icmp_pkt_to_tuple(const struct sk_buff *skb,
+ 		       unsigned int dataoff,
+ 		       struct net *net,
+ 		       struct nf_conntrack_tuple *tuple);
+ 
+ bool icmpv6_pkt_to_tuple(const struct sk_buff *skb,
+ 			 unsigned int dataoff,
+ 			 struct net *net,
+ 			 struct nf_conntrack_tuple *tuple);
+ 
+ bool nf_conntrack_invert_icmp_tuple(struct nf_conntrack_tuple *tuple,
+ 				    const struct nf_conntrack_tuple *orig);
+ bool nf_conntrack_invert_icmpv6_tuple(struct nf_conntrack_tuple *tuple,
+ 				      const struct nf_conntrack_tuple *orig);
+ 
+ int nf_conntrack_icmpv4_error(struct nf_conn *tmpl,
+ 			      struct sk_buff *skb,
+ 			      unsigned int dataoff,
+ 			      const struct nf_hook_state *state);
+ 
+ int nf_conntrack_icmpv6_error(struct nf_conn *tmpl,
+ 			      struct sk_buff *skb,
+ 			      unsigned int dataoff,
+ 			      const struct nf_hook_state *state);
+ 
+ int nf_conntrack_icmp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state);
+ 
+ int nf_conntrack_icmpv6_packet(struct nf_conn *ct,
+ 			       struct sk_buff *skb,
+ 			       enum ip_conntrack_info ctinfo,
+ 			       const struct nf_hook_state *state);
+ 
+ int nf_conntrack_udp_packet(struct nf_conn *ct,
+ 			    struct sk_buff *skb,
+ 			    unsigned int dataoff,
+ 			    enum ip_conntrack_info ctinfo,
+ 			    const struct nf_hook_state *state);
+ int nf_conntrack_udplite_packet(struct nf_conn *ct,
+ 				struct sk_buff *skb,
+ 				unsigned int dataoff,
+ 				enum ip_conntrack_info ctinfo,
+ 				const struct nf_hook_state *state);
+ int nf_conntrack_tcp_packet(struct nf_conn *ct,
+ 			    struct sk_buff *skb,
+ 			    unsigned int dataoff,
+ 			    enum ip_conntrack_info ctinfo,
+ 			    const struct nf_hook_state *state);
+ int nf_conntrack_dccp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     unsigned int dataoff,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state);
+ int nf_conntrack_sctp_packet(struct nf_conn *ct,
+ 			     struct sk_buff *skb,
+ 			     unsigned int dataoff,
+ 			     enum ip_conntrack_info ctinfo,
+ 			     const struct nf_hook_state *state);
+ int nf_conntrack_gre_packet(struct nf_conn *ct,
+ 			    struct sk_buff *skb,
+ 			    unsigned int dataoff,
+ 			    enum ip_conntrack_info ctinfo,
+ 			    const struct nf_hook_state *state);
+ 
++>>>>>>> 44fb87f6351d (netfilter: conntrack: remove remaining l4proto indirect packet calls)
  /* Existing built-in generic protocol */
  extern const struct nf_conntrack_l4proto nf_conntrack_l4proto_generic;
  
diff --cc net/netfilter/nf_conntrack_core.c
index 680e0b0d92a5,264074f04615..000000000000
--- a/net/netfilter/nf_conntrack_core.c
+++ b/net/netfilter/nf_conntrack_core.c
@@@ -1479,18 -1501,102 +1479,109 @@@ resolve_normal_ct(struct net *net, stru
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * icmp packets need special treatment to handle error messages that are
+  * related to a connection.
+  *
+  * Callers need to check if skb has a conntrack assigned when this
+  * helper returns; in such case skb belongs to an already known connection.
+  */
+ static unsigned int __cold
+ nf_conntrack_handle_icmp(struct nf_conn *tmpl,
+ 			 struct sk_buff *skb,
+ 			 unsigned int dataoff,
+ 			 u8 protonum,
+ 			 const struct nf_hook_state *state)
+ {
+ 	int ret;
+ 
+ 	if (state->pf == NFPROTO_IPV4 && protonum == IPPROTO_ICMP)
+ 		ret = nf_conntrack_icmpv4_error(tmpl, skb, dataoff, state);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	else if (state->pf == NFPROTO_IPV6 && protonum == IPPROTO_ICMPV6)
+ 		ret = nf_conntrack_icmpv6_error(tmpl, skb, dataoff, state);
+ #endif
+ 	else
+ 		return NF_ACCEPT;
+ 
+ 	if (ret <= 0) {
+ 		NF_CT_STAT_INC_ATOMIC(state->net, error);
+ 		NF_CT_STAT_INC_ATOMIC(state->net, invalid);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int generic_packet(struct nf_conn *ct, struct sk_buff *skb,
+ 			  enum ip_conntrack_info ctinfo)
+ {
+ 	const unsigned int *timeout = nf_ct_timeout_lookup(ct);
+ 
+ 	if (!timeout)
+ 		timeout = &nf_generic_pernet(nf_ct_net(ct))->timeout;
+ 
+ 	nf_ct_refresh_acct(ct, ctinfo, skb, *timeout);
+ 	return NF_ACCEPT;
+ }
+ 
+ /* Returns verdict for packet, or -1 for invalid. */
+ static int nf_conntrack_handle_packet(struct nf_conn *ct,
+ 				      struct sk_buff *skb,
+ 				      unsigned int dataoff,
+ 				      enum ip_conntrack_info ctinfo,
+ 				      const struct nf_hook_state *state)
+ {
+ 	switch (nf_ct_protonum(ct)) {
+ 	case IPPROTO_TCP:
+ 		return nf_conntrack_tcp_packet(ct, skb, dataoff,
+ 					       ctinfo, state);
+ 	case IPPROTO_UDP:
+ 		return nf_conntrack_udp_packet(ct, skb, dataoff,
+ 					       ctinfo, state);
+ 	case IPPROTO_ICMP:
+ 		return nf_conntrack_icmp_packet(ct, skb, ctinfo, state);
+ 	case IPPROTO_ICMPV6:
+ 		return nf_conntrack_icmpv6_packet(ct, skb, ctinfo, state);
+ #ifdef CONFIG_NF_CT_PROTO_UDPLITE
+ 	case IPPROTO_UDPLITE:
+ 		return nf_conntrack_udplite_packet(ct, skb, dataoff,
+ 						   ctinfo, state);
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ 	case IPPROTO_SCTP:
+ 		return nf_conntrack_sctp_packet(ct, skb, dataoff,
+ 						ctinfo, state);
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 	case IPPROTO_DCCP:
+ 		return nf_conntrack_dccp_packet(ct, skb, dataoff,
+ 						ctinfo, state);
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_GRE
+ 	case IPPROTO_GRE:
+ 		return nf_conntrack_gre_packet(ct, skb, dataoff,
+ 					       ctinfo, state);
+ #endif
+ 	}
+ 
+ 	return generic_packet(ct, skb, ctinfo);
+ }
+ 
++>>>>>>> 44fb87f6351d (netfilter: conntrack: remove remaining l4proto indirect packet calls)
  unsigned int
 -nf_conntrack_in(struct sk_buff *skb, const struct nf_hook_state *state)
 +nf_conntrack_in(struct net *net, u_int8_t pf, unsigned int hooknum,
 +		struct sk_buff *skb)
  {
 +	const struct nf_conntrack_l3proto *l3proto;
  	const struct nf_conntrack_l4proto *l4proto;
 -	enum ip_conntrack_info ctinfo;
  	struct nf_conn *ct, *tmpl;
 +	enum ip_conntrack_info ctinfo;
 +	unsigned int *timeouts;
 +	unsigned int dataoff;
  	u_int8_t protonum;
 -	int dataoff, ret;
 +	int ret;
  
  	tmpl = nf_ct_get(skb, &ctinfo);
  	if (tmpl || ctinfo == IP_CT_UNTRACKED) {
@@@ -1549,10 -1650,7 +1640,14 @@@ repeat
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	/* Decide what timeout policy we want to apply to this flow. */
 +	timeouts = nf_ct_timeout_lookup(net, ct, l4proto);
 +
 +	ret = l4proto->packet(ct, skb, dataoff, ctinfo, timeouts);
++=======
+ 	ret = nf_conntrack_handle_packet(ct, skb, dataoff, ctinfo, state);
++>>>>>>> 44fb87f6351d (netfilter: conntrack: remove remaining l4proto indirect packet calls)
  	if (ret <= 0) {
  		/* Invalid: inverse of the return code tells
  		 * the netfilter core what to do */
diff --cc net/netfilter/nf_conntrack_proto_generic.c
index 5ceb58c2c816,78358d192c60..000000000000
--- a/net/netfilter/nf_conntrack_proto_generic.c
+++ b/net/netfilter/nf_conntrack_proto_generic.c
@@@ -14,62 -14,7 +14,65 @@@
  
  static const unsigned int nf_ct_generic_timeout = 600*HZ;
  
++<<<<<<< HEAD
 +static bool nf_generic_should_process(u8 proto)
 +{
 +	switch (proto) {
 +#ifdef CONFIG_NF_CT_PROTO_GRE_MODULE
 +	case IPPROTO_GRE:
 +		return false;
 +#endif
 +	default:
 +		return true;
 +	}
 +}
 +
 +static inline struct nf_generic_net *generic_pernet(struct net *net)
 +{
 +	return &net->ct.nf_ct_proto.generic;
 +}
 +
 +static bool generic_pkt_to_tuple(const struct sk_buff *skb,
 +				 unsigned int dataoff,
 +				 struct net *net, struct nf_conntrack_tuple *tuple)
 +{
 +	tuple->src.u.all = 0;
 +	tuple->dst.u.all = 0;
 +
 +	return true;
 +}
 +
 +static unsigned int *generic_get_timeouts(struct net *net)
 +{
 +	return &(generic_pernet(net)->timeout);
 +}
 +
 +/* Returns verdict for packet, or -1 for invalid. */
 +static int generic_packet(struct nf_conn *ct,
 +			  const struct sk_buff *skb,
 +			  unsigned int dataoff,
 +			  enum ip_conntrack_info ctinfo,
 +			  unsigned int *timeout)
 +{
 +	nf_ct_refresh_acct(ct, ctinfo, skb, *timeout);
 +	return NF_ACCEPT;
 +}
 +
 +/* Called when a new connection for this protocol found. */
 +static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,
 +			unsigned int dataoff, unsigned int *timeouts)
 +{
 +	bool ret;
 +
 +	ret = nf_generic_should_process(nf_ct_protonum(ct));
 +	if (!ret)
 +		pr_warn_once("conntrack: generic helper won't handle protocol %d. Please consider loading the specific helper module.\n",
 +			     nf_ct_protonum(ct));
 +	return ret;
 +}
 +
++=======
++>>>>>>> 44fb87f6351d (netfilter: conntrack: remove remaining l4proto indirect packet calls)
  #ifdef CONFIG_NF_CONNTRACK_TIMEOUT
  
  #include <linux/netfilter/nfnetlink.h>
@@@ -156,12 -104,7 +159,15 @@@ static struct nf_proto_net *generic_get
  
  const struct nf_conntrack_l4proto nf_conntrack_l4proto_generic =
  {
 +	.l3proto		= PF_UNSPEC,
  	.l4proto		= 255,
++<<<<<<< HEAD
 +	.pkt_to_tuple		= generic_pkt_to_tuple,
 +	.packet			= generic_packet,
 +	.get_timeouts		= generic_get_timeouts,
 +	.new			= generic_new,
++=======
++>>>>>>> 44fb87f6351d (netfilter: conntrack: remove remaining l4proto indirect packet calls)
  #ifdef CONFIG_NF_CONNTRACK_TIMEOUT
  	.ctnl_timeout		= {
  		.nlattr_to_obj	= generic_timeout_nlattr_to_obj,
diff --cc net/netfilter/nf_conntrack_proto_gre.c
index c9e1b1061af6,f6391991bcf6..000000000000
--- a/net/netfilter/nf_conntrack_proto_gre.c
+++ b/net/netfilter/nf_conntrack_proto_gre.c
@@@ -231,12 -213,27 +231,20 @@@ static unsigned int *gre_get_timeouts(s
  }
  
  /* Returns verdict for packet, and may modify conntrack */
++<<<<<<< HEAD
 +static int gre_packet(struct nf_conn *ct,
 +		      const struct sk_buff *skb,
 +		      unsigned int dataoff,
 +		      enum ip_conntrack_info ctinfo,
 +		      unsigned int *timeouts)
++=======
+ int nf_conntrack_gre_packet(struct nf_conn *ct,
+ 			    struct sk_buff *skb,
+ 			    unsigned int dataoff,
+ 			    enum ip_conntrack_info ctinfo,
+ 			    const struct nf_hook_state *state)
++>>>>>>> 44fb87f6351d (netfilter: conntrack: remove remaining l4proto indirect packet calls)
  {
 -	if (state->pf != NFPROTO_IPV4)
 -		return -NF_ACCEPT;
 -
 -	if (!nf_ct_is_confirmed(ct)) {
 -		unsigned int *timeouts = nf_ct_timeout_lookup(ct);
 -
 -		if (!timeouts)
 -			timeouts = gre_get_timeouts(nf_ct_net(ct));
 -
 -		/* initialize to sane value.  Ideally a conntrack helper
 -		 * (e.g. in case of pptp) is increasing them */
 -		ct->proto.gre.stream_timeout = timeouts[GRE_CT_REPLIED];
 -		ct->proto.gre.timeout = timeouts[GRE_CT_UNREPLIED];
 -	}
 -
  	/* If we've seen traffic both ways, this is a GRE connection.
  	 * Extend timeout. */
  	if (ct->status & IPS_SEEN_REPLY) {
@@@ -350,11 -371,7 +358,14 @@@ static const struct nf_conntrack_l4prot
  #ifdef CONFIG_NF_CONNTRACK_PROCFS
  	.print_conntrack = gre_print_conntrack,
  #endif
++<<<<<<< HEAD
 +	.get_timeouts    = gre_get_timeouts,
 +	.packet		 = gre_packet,
 +	.new		 = gre_new,
++=======
++>>>>>>> 44fb87f6351d (netfilter: conntrack: remove remaining l4proto indirect packet calls)
  	.destroy	 = gre_destroy,
 +	.me 		 = THIS_MODULE,
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.tuple_to_nlattr = nf_ct_port_tuple_to_nlattr,
  	.nlattr_tuple_size = nf_ct_port_nlattr_tuple_size,
* Unmerged path include/net/netfilter/nf_conntrack_l4proto.h
* Unmerged path net/netfilter/nf_conntrack_core.c
* Unmerged path net/netfilter/nf_conntrack_proto_generic.c
* Unmerged path net/netfilter/nf_conntrack_proto_gre.c
