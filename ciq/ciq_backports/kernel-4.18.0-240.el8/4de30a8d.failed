net/tls: pass context to tls_device_decrypted()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
Rebuild_CHGLOG: - [net] tls: pass context to tls_device_decrypted() (Sabrina Dubroca) [1819627]
Rebuild_FUZZ: 95.56%
commit-author Jakub Kicinski <jakub.kicinski@netronome.com>
commit 4de30a8d58c90e18140342cdcb74903d2e4fbb62
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/4de30a8d.failed

Avoid unnecessary pointer chasing and calculations, callers already
have most of the state tls_device_decrypted() needs.

	Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>
	Reviewed-by: Dirk van der Merwe <dirk.vandermerwe@netronome.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4de30a8d58c90e18140342cdcb74903d2e4fbb62)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tls.h
diff --cc include/net/tls.h
index 355cc88fb8ed,b809f2362049..000000000000
--- a/include/net/tls.h
+++ b/include/net/tls.h
@@@ -672,7 -640,9 +672,13 @@@ void tls_device_free_resources_tx(struc
  int tls_set_device_offload_rx(struct sock *sk, struct tls_context *ctx);
  void tls_device_offload_cleanup_rx(struct sock *sk);
  void tls_device_rx_resync_new_rec(struct sock *sk, u32 rcd_len, u32 seq);
++<<<<<<< HEAD
 +int tls_device_decrypted(struct sock *sk, struct sk_buff *skb);
++=======
+ void tls_offload_tx_resync_request(struct sock *sk, u32 got_seq, u32 exp_seq);
+ int tls_device_decrypted(struct sock *sk, struct tls_context *tls_ctx,
+ 			 struct sk_buff *skb, struct strp_msg *rxm);
++>>>>>>> 4de30a8d58c9 (net/tls: pass context to tls_device_decrypted())
  #else
  static inline void tls_device_init(void) {}
  static inline void tls_device_cleanup(void) {}
* Unmerged path include/net/tls.h
diff --git a/net/tls/tls_device.c b/net/tls/tls_device.c
index b93c96318ef9..8fa37bcfec77 100644
--- a/net/tls/tls_device.c
+++ b/net/tls/tls_device.c
@@ -833,9 +833,9 @@ static int tls_device_reencrypt(struct sock *sk, struct sk_buff *skb)
 	return err;
 }
 
-int tls_device_decrypted(struct sock *sk, struct sk_buff *skb)
+int tls_device_decrypted(struct sock *sk, struct tls_context *tls_ctx,
+			 struct sk_buff *skb, struct strp_msg *rxm)
 {
-	struct tls_context *tls_ctx = tls_get_ctx(sk);
 	struct tls_offload_context_rx *ctx = tls_offload_ctx_rx(tls_ctx);
 	int is_decrypted = skb->decrypted;
 	int is_encrypted = !is_decrypted;
diff --git a/net/tls/tls_sw.c b/net/tls/tls_sw.c
index d77021334239..82270078f219 100644
--- a/net/tls/tls_sw.c
+++ b/net/tls/tls_sw.c
@@ -1524,7 +1524,7 @@ static int decrypt_skb_update(struct sock *sk, struct sk_buff *skb,
 
 	if (!ctx->decrypted) {
 		if (tls_ctx->rx_conf == TLS_HW) {
-			err = tls_device_decrypted(sk, skb);
+			err = tls_device_decrypted(sk, tls_ctx, skb, rxm);
 			if (err < 0)
 				return err;
 		}
