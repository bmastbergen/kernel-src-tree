selftests/harness: Refactor XFAIL into SKIP

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Kees Cook <keescook@chromium.org>
commit 9847d24af95c7fa146c9a0e82505a78e29161c10
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9847d24a.failed

Plumb the old XFAIL result into a TAP SKIP.

	Signed-off-by: Kees Cook <keescook@chromium.org>
	Signed-off-by: Shuah Khan <skhan@linuxfoundation.org>
(cherry picked from commit 9847d24af95c7fa146c9a0e82505a78e29161c10)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/seccomp/seccomp_bpf.c
diff --cc tools/testing/selftests/seccomp/seccomp_bpf.c
index 2e67f425d575,8c1cc8033c09..000000000000
--- a/tools/testing/selftests/seccomp/seccomp_bpf.c
+++ b/tools/testing/selftests/seccomp/seccomp_bpf.c
@@@ -2878,6 -3067,12 +2878,15 @@@ TEST(get_metadata
  	struct seccomp_metadata md;
  	long ret;
  
++<<<<<<< HEAD
++=======
+ 	/* Only real root can get metadata. */
+ 	if (geteuid()) {
+ 		SKIP(return, "get_metadata requires real root");
+ 		return;
+ 	}
+ 
++>>>>>>> 9847d24af95c (selftests/harness: Refactor XFAIL into SKIP)
  	ASSERT_EQ(0, pipe(pipefd));
  
  	pid = fork();
@@@ -2933,6 -3128,565 +2942,568 @@@ skip
  	ASSERT_EQ(0, kill(pid, SIGKILL));
  }
  
++<<<<<<< HEAD
++=======
+ static int user_trap_syscall(int nr, unsigned int flags)
+ {
+ 	struct sock_filter filter[] = {
+ 		BPF_STMT(BPF_LD+BPF_W+BPF_ABS,
+ 			offsetof(struct seccomp_data, nr)),
+ 		BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, nr, 0, 1),
+ 		BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_USER_NOTIF),
+ 		BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW),
+ 	};
+ 
+ 	struct sock_fprog prog = {
+ 		.len = (unsigned short)ARRAY_SIZE(filter),
+ 		.filter = filter,
+ 	};
+ 
+ 	return seccomp(SECCOMP_SET_MODE_FILTER, flags, &prog);
+ }
+ 
+ #define USER_NOTIF_MAGIC INT_MAX
+ TEST(user_notification_basic)
+ {
+ 	pid_t pid;
+ 	long ret;
+ 	int status, listener;
+ 	struct seccomp_notif req = {};
+ 	struct seccomp_notif_resp resp = {};
+ 	struct pollfd pollfd;
+ 
+ 	struct sock_filter filter[] = {
+ 		BPF_STMT(BPF_RET|BPF_K, SECCOMP_RET_ALLOW),
+ 	};
+ 	struct sock_fprog prog = {
+ 		.len = (unsigned short)ARRAY_SIZE(filter),
+ 		.filter = filter,
+ 	};
+ 
+ 	ret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
+ 	ASSERT_EQ(0, ret) {
+ 		TH_LOG("Kernel does not support PR_SET_NO_NEW_PRIVS!");
+ 	}
+ 
+ 	pid = fork();
+ 	ASSERT_GE(pid, 0);
+ 
+ 	/* Check that we get -ENOSYS with no listener attached */
+ 	if (pid == 0) {
+ 		if (user_trap_syscall(__NR_getppid, 0) < 0)
+ 			exit(1);
+ 		ret = syscall(__NR_getppid);
+ 		exit(ret >= 0 || errno != ENOSYS);
+ 	}
+ 
+ 	EXPECT_EQ(waitpid(pid, &status, 0), pid);
+ 	EXPECT_EQ(true, WIFEXITED(status));
+ 	EXPECT_EQ(0, WEXITSTATUS(status));
+ 
+ 	/* Add some no-op filters for grins. */
+ 	EXPECT_EQ(seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog), 0);
+ 	EXPECT_EQ(seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog), 0);
+ 	EXPECT_EQ(seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog), 0);
+ 	EXPECT_EQ(seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog), 0);
+ 
+ 	/* Check that the basic notification machinery works */
+ 	listener = user_trap_syscall(__NR_getppid,
+ 				     SECCOMP_FILTER_FLAG_NEW_LISTENER);
+ 	ASSERT_GE(listener, 0);
+ 
+ 	/* Installing a second listener in the chain should EBUSY */
+ 	EXPECT_EQ(user_trap_syscall(__NR_getppid,
+ 				    SECCOMP_FILTER_FLAG_NEW_LISTENER),
+ 		  -1);
+ 	EXPECT_EQ(errno, EBUSY);
+ 
+ 	pid = fork();
+ 	ASSERT_GE(pid, 0);
+ 
+ 	if (pid == 0) {
+ 		ret = syscall(__NR_getppid);
+ 		exit(ret != USER_NOTIF_MAGIC);
+ 	}
+ 
+ 	pollfd.fd = listener;
+ 	pollfd.events = POLLIN | POLLOUT;
+ 
+ 	EXPECT_GT(poll(&pollfd, 1, -1), 0);
+ 	EXPECT_EQ(pollfd.revents, POLLIN);
+ 
+ 	/* Test that we can't pass garbage to the kernel. */
+ 	memset(&req, 0, sizeof(req));
+ 	req.pid = -1;
+ 	errno = 0;
+ 	ret = ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req);
+ 	EXPECT_EQ(-1, ret);
+ 	EXPECT_EQ(EINVAL, errno);
+ 
+ 	if (ret) {
+ 		req.pid = 0;
+ 		EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);
+ 	}
+ 
+ 	pollfd.fd = listener;
+ 	pollfd.events = POLLIN | POLLOUT;
+ 
+ 	EXPECT_GT(poll(&pollfd, 1, -1), 0);
+ 	EXPECT_EQ(pollfd.revents, POLLOUT);
+ 
+ 	EXPECT_EQ(req.data.nr,  __NR_getppid);
+ 
+ 	resp.id = req.id;
+ 	resp.error = 0;
+ 	resp.val = USER_NOTIF_MAGIC;
+ 
+ 	/* check that we make sure flags == 0 */
+ 	resp.flags = 1;
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), -1);
+ 	EXPECT_EQ(errno, EINVAL);
+ 
+ 	resp.flags = 0;
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);
+ 
+ 	EXPECT_EQ(waitpid(pid, &status, 0), pid);
+ 	EXPECT_EQ(true, WIFEXITED(status));
+ 	EXPECT_EQ(0, WEXITSTATUS(status));
+ }
+ 
+ TEST(user_notification_with_tsync)
+ {
+ 	int ret;
+ 	unsigned int flags;
+ 
+ 	/* these were exclusive */
+ 	flags = SECCOMP_FILTER_FLAG_NEW_LISTENER |
+ 		SECCOMP_FILTER_FLAG_TSYNC;
+ 	ASSERT_EQ(-1, user_trap_syscall(__NR_getppid, flags));
+ 	ASSERT_EQ(EINVAL, errno);
+ 
+ 	/* but now they're not */
+ 	flags |= SECCOMP_FILTER_FLAG_TSYNC_ESRCH;
+ 	ret = user_trap_syscall(__NR_getppid, flags);
+ 	close(ret);
+ 	ASSERT_LE(0, ret);
+ }
+ 
+ TEST(user_notification_kill_in_middle)
+ {
+ 	pid_t pid;
+ 	long ret;
+ 	int listener;
+ 	struct seccomp_notif req = {};
+ 	struct seccomp_notif_resp resp = {};
+ 
+ 	ret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
+ 	ASSERT_EQ(0, ret) {
+ 		TH_LOG("Kernel does not support PR_SET_NO_NEW_PRIVS!");
+ 	}
+ 
+ 	listener = user_trap_syscall(__NR_getppid,
+ 				     SECCOMP_FILTER_FLAG_NEW_LISTENER);
+ 	ASSERT_GE(listener, 0);
+ 
+ 	/*
+ 	 * Check that nothing bad happens when we kill the task in the middle
+ 	 * of a syscall.
+ 	 */
+ 	pid = fork();
+ 	ASSERT_GE(pid, 0);
+ 
+ 	if (pid == 0) {
+ 		ret = syscall(__NR_getppid);
+ 		exit(ret != USER_NOTIF_MAGIC);
+ 	}
+ 
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_ID_VALID, &req.id), 0);
+ 
+ 	EXPECT_EQ(kill(pid, SIGKILL), 0);
+ 	EXPECT_EQ(waitpid(pid, NULL, 0), pid);
+ 
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_ID_VALID, &req.id), -1);
+ 
+ 	resp.id = req.id;
+ 	ret = ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp);
+ 	EXPECT_EQ(ret, -1);
+ 	EXPECT_EQ(errno, ENOENT);
+ }
+ 
+ static int handled = -1;
+ 
+ static void signal_handler(int signal)
+ {
+ 	if (write(handled, "c", 1) != 1)
+ 		perror("write from signal");
+ }
+ 
+ TEST(user_notification_signal)
+ {
+ 	pid_t pid;
+ 	long ret;
+ 	int status, listener, sk_pair[2];
+ 	struct seccomp_notif req = {};
+ 	struct seccomp_notif_resp resp = {};
+ 	char c;
+ 
+ 	ret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
+ 	ASSERT_EQ(0, ret) {
+ 		TH_LOG("Kernel does not support PR_SET_NO_NEW_PRIVS!");
+ 	}
+ 
+ 	ASSERT_EQ(socketpair(PF_LOCAL, SOCK_SEQPACKET, 0, sk_pair), 0);
+ 
+ 	listener = user_trap_syscall(__NR_gettid,
+ 				     SECCOMP_FILTER_FLAG_NEW_LISTENER);
+ 	ASSERT_GE(listener, 0);
+ 
+ 	pid = fork();
+ 	ASSERT_GE(pid, 0);
+ 
+ 	if (pid == 0) {
+ 		close(sk_pair[0]);
+ 		handled = sk_pair[1];
+ 		if (signal(SIGUSR1, signal_handler) == SIG_ERR) {
+ 			perror("signal");
+ 			exit(1);
+ 		}
+ 		/*
+ 		 * ERESTARTSYS behavior is a bit hard to test, because we need
+ 		 * to rely on a signal that has not yet been handled. Let's at
+ 		 * least check that the error code gets propagated through, and
+ 		 * hope that it doesn't break when there is actually a signal :)
+ 		 */
+ 		ret = syscall(__NR_gettid);
+ 		exit(!(ret == -1 && errno == 512));
+ 	}
+ 
+ 	close(sk_pair[1]);
+ 
+ 	memset(&req, 0, sizeof(req));
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);
+ 
+ 	EXPECT_EQ(kill(pid, SIGUSR1), 0);
+ 
+ 	/*
+ 	 * Make sure the signal really is delivered, which means we're not
+ 	 * stuck in the user notification code any more and the notification
+ 	 * should be dead.
+ 	 */
+ 	EXPECT_EQ(read(sk_pair[0], &c, 1), 1);
+ 
+ 	resp.id = req.id;
+ 	resp.error = -EPERM;
+ 	resp.val = 0;
+ 
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), -1);
+ 	EXPECT_EQ(errno, ENOENT);
+ 
+ 	memset(&req, 0, sizeof(req));
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);
+ 
+ 	resp.id = req.id;
+ 	resp.error = -512; /* -ERESTARTSYS */
+ 	resp.val = 0;
+ 
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);
+ 
+ 	EXPECT_EQ(waitpid(pid, &status, 0), pid);
+ 	EXPECT_EQ(true, WIFEXITED(status));
+ 	EXPECT_EQ(0, WEXITSTATUS(status));
+ }
+ 
+ TEST(user_notification_closed_listener)
+ {
+ 	pid_t pid;
+ 	long ret;
+ 	int status, listener;
+ 
+ 	ret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
+ 	ASSERT_EQ(0, ret) {
+ 		TH_LOG("Kernel does not support PR_SET_NO_NEW_PRIVS!");
+ 	}
+ 
+ 	listener = user_trap_syscall(__NR_getppid,
+ 				     SECCOMP_FILTER_FLAG_NEW_LISTENER);
+ 	ASSERT_GE(listener, 0);
+ 
+ 	/*
+ 	 * Check that we get an ENOSYS when the listener is closed.
+ 	 */
+ 	pid = fork();
+ 	ASSERT_GE(pid, 0);
+ 	if (pid == 0) {
+ 		close(listener);
+ 		ret = syscall(__NR_getppid);
+ 		exit(ret != -1 && errno != ENOSYS);
+ 	}
+ 
+ 	close(listener);
+ 
+ 	EXPECT_EQ(waitpid(pid, &status, 0), pid);
+ 	EXPECT_EQ(true, WIFEXITED(status));
+ 	EXPECT_EQ(0, WEXITSTATUS(status));
+ }
+ 
+ /*
+  * Check that a pid in a child namespace still shows up as valid in ours.
+  */
+ TEST(user_notification_child_pid_ns)
+ {
+ 	pid_t pid;
+ 	int status, listener;
+ 	struct seccomp_notif req = {};
+ 	struct seccomp_notif_resp resp = {};
+ 
+ 	ASSERT_EQ(unshare(CLONE_NEWUSER | CLONE_NEWPID), 0);
+ 
+ 	listener = user_trap_syscall(__NR_getppid,
+ 				     SECCOMP_FILTER_FLAG_NEW_LISTENER);
+ 	ASSERT_GE(listener, 0);
+ 
+ 	pid = fork();
+ 	ASSERT_GE(pid, 0);
+ 
+ 	if (pid == 0)
+ 		exit(syscall(__NR_getppid) != USER_NOTIF_MAGIC);
+ 
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);
+ 	EXPECT_EQ(req.pid, pid);
+ 
+ 	resp.id = req.id;
+ 	resp.error = 0;
+ 	resp.val = USER_NOTIF_MAGIC;
+ 
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);
+ 
+ 	EXPECT_EQ(waitpid(pid, &status, 0), pid);
+ 	EXPECT_EQ(true, WIFEXITED(status));
+ 	EXPECT_EQ(0, WEXITSTATUS(status));
+ 	close(listener);
+ }
+ 
+ /*
+  * Check that a pid in a sibling (i.e. unrelated) namespace shows up as 0, i.e.
+  * invalid.
+  */
+ TEST(user_notification_sibling_pid_ns)
+ {
+ 	pid_t pid, pid2;
+ 	int status, listener;
+ 	struct seccomp_notif req = {};
+ 	struct seccomp_notif_resp resp = {};
+ 
+ 	ASSERT_EQ(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0), 0) {
+ 		TH_LOG("Kernel does not support PR_SET_NO_NEW_PRIVS!");
+ 	}
+ 
+ 	listener = user_trap_syscall(__NR_getppid,
+ 				     SECCOMP_FILTER_FLAG_NEW_LISTENER);
+ 	ASSERT_GE(listener, 0);
+ 
+ 	pid = fork();
+ 	ASSERT_GE(pid, 0);
+ 
+ 	if (pid == 0) {
+ 		ASSERT_EQ(unshare(CLONE_NEWPID), 0);
+ 
+ 		pid2 = fork();
+ 		ASSERT_GE(pid2, 0);
+ 
+ 		if (pid2 == 0)
+ 			exit(syscall(__NR_getppid) != USER_NOTIF_MAGIC);
+ 
+ 		EXPECT_EQ(waitpid(pid2, &status, 0), pid2);
+ 		EXPECT_EQ(true, WIFEXITED(status));
+ 		EXPECT_EQ(0, WEXITSTATUS(status));
+ 		exit(WEXITSTATUS(status));
+ 	}
+ 
+ 	/* Create the sibling ns, and sibling in it. */
+ 	ASSERT_EQ(unshare(CLONE_NEWPID), 0);
+ 	ASSERT_EQ(errno, 0);
+ 
+ 	pid2 = fork();
+ 	ASSERT_GE(pid2, 0);
+ 
+ 	if (pid2 == 0) {
+ 		ASSERT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);
+ 		/*
+ 		 * The pid should be 0, i.e. the task is in some namespace that
+ 		 * we can't "see".
+ 		 */
+ 		EXPECT_EQ(req.pid, 0);
+ 
+ 		resp.id = req.id;
+ 		resp.error = 0;
+ 		resp.val = USER_NOTIF_MAGIC;
+ 
+ 		ASSERT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);
+ 		exit(0);
+ 	}
+ 
+ 	close(listener);
+ 
+ 	EXPECT_EQ(waitpid(pid, &status, 0), pid);
+ 	EXPECT_EQ(true, WIFEXITED(status));
+ 	EXPECT_EQ(0, WEXITSTATUS(status));
+ 
+ 	EXPECT_EQ(waitpid(pid2, &status, 0), pid2);
+ 	EXPECT_EQ(true, WIFEXITED(status));
+ 	EXPECT_EQ(0, WEXITSTATUS(status));
+ }
+ 
+ TEST(user_notification_fault_recv)
+ {
+ 	pid_t pid;
+ 	int status, listener;
+ 	struct seccomp_notif req = {};
+ 	struct seccomp_notif_resp resp = {};
+ 
+ 	ASSERT_EQ(unshare(CLONE_NEWUSER), 0);
+ 
+ 	listener = user_trap_syscall(__NR_getppid,
+ 				     SECCOMP_FILTER_FLAG_NEW_LISTENER);
+ 	ASSERT_GE(listener, 0);
+ 
+ 	pid = fork();
+ 	ASSERT_GE(pid, 0);
+ 
+ 	if (pid == 0)
+ 		exit(syscall(__NR_getppid) != USER_NOTIF_MAGIC);
+ 
+ 	/* Do a bad recv() */
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, NULL), -1);
+ 	EXPECT_EQ(errno, EFAULT);
+ 
+ 	/* We should still be able to receive this notification, though. */
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);
+ 	EXPECT_EQ(req.pid, pid);
+ 
+ 	resp.id = req.id;
+ 	resp.error = 0;
+ 	resp.val = USER_NOTIF_MAGIC;
+ 
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0);
+ 
+ 	EXPECT_EQ(waitpid(pid, &status, 0), pid);
+ 	EXPECT_EQ(true, WIFEXITED(status));
+ 	EXPECT_EQ(0, WEXITSTATUS(status));
+ }
+ 
+ TEST(seccomp_get_notif_sizes)
+ {
+ 	struct seccomp_notif_sizes sizes;
+ 
+ 	ASSERT_EQ(seccomp(SECCOMP_GET_NOTIF_SIZES, 0, &sizes), 0);
+ 	EXPECT_EQ(sizes.seccomp_notif, sizeof(struct seccomp_notif));
+ 	EXPECT_EQ(sizes.seccomp_notif_resp, sizeof(struct seccomp_notif_resp));
+ }
+ 
+ static int filecmp(pid_t pid1, pid_t pid2, int fd1, int fd2)
+ {
+ #ifdef __NR_kcmp
+ 	return syscall(__NR_kcmp, pid1, pid2, KCMP_FILE, fd1, fd2);
+ #else
+ 	errno = ENOSYS;
+ 	return -1;
+ #endif
+ }
+ 
+ TEST(user_notification_continue)
+ {
+ 	pid_t pid;
+ 	long ret;
+ 	int status, listener;
+ 	struct seccomp_notif req = {};
+ 	struct seccomp_notif_resp resp = {};
+ 	struct pollfd pollfd;
+ 
+ 	ret = prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);
+ 	ASSERT_EQ(0, ret) {
+ 		TH_LOG("Kernel does not support PR_SET_NO_NEW_PRIVS!");
+ 	}
+ 
+ 	listener = user_trap_syscall(__NR_dup, SECCOMP_FILTER_FLAG_NEW_LISTENER);
+ 	ASSERT_GE(listener, 0);
+ 
+ 	pid = fork();
+ 	ASSERT_GE(pid, 0);
+ 
+ 	if (pid == 0) {
+ 		int dup_fd, pipe_fds[2];
+ 		pid_t self;
+ 
+ 		ret = pipe(pipe_fds);
+ 		if (ret < 0)
+ 			exit(1);
+ 
+ 		dup_fd = dup(pipe_fds[0]);
+ 		if (dup_fd < 0)
+ 			exit(1);
+ 
+ 		self = getpid();
+ 
+ 		ret = filecmp(self, self, pipe_fds[0], dup_fd);
+ 		if (ret)
+ 			exit(2);
+ 
+ 		exit(0);
+ 	}
+ 
+ 	pollfd.fd = listener;
+ 	pollfd.events = POLLIN | POLLOUT;
+ 
+ 	EXPECT_GT(poll(&pollfd, 1, -1), 0);
+ 	EXPECT_EQ(pollfd.revents, POLLIN);
+ 
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_RECV, &req), 0);
+ 
+ 	pollfd.fd = listener;
+ 	pollfd.events = POLLIN | POLLOUT;
+ 
+ 	EXPECT_GT(poll(&pollfd, 1, -1), 0);
+ 	EXPECT_EQ(pollfd.revents, POLLOUT);
+ 
+ 	EXPECT_EQ(req.data.nr, __NR_dup);
+ 
+ 	resp.id = req.id;
+ 	resp.flags = SECCOMP_USER_NOTIF_FLAG_CONTINUE;
+ 
+ 	/*
+ 	 * Verify that setting SECCOMP_USER_NOTIF_FLAG_CONTINUE enforces other
+ 	 * args be set to 0.
+ 	 */
+ 	resp.error = 0;
+ 	resp.val = USER_NOTIF_MAGIC;
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), -1);
+ 	EXPECT_EQ(errno, EINVAL);
+ 
+ 	resp.error = USER_NOTIF_MAGIC;
+ 	resp.val = 0;
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), -1);
+ 	EXPECT_EQ(errno, EINVAL);
+ 
+ 	resp.error = 0;
+ 	resp.val = 0;
+ 	EXPECT_EQ(ioctl(listener, SECCOMP_IOCTL_NOTIF_SEND, &resp), 0) {
+ 		if (errno == EINVAL)
+ 			SKIP(goto skip, "Kernel does not support SECCOMP_USER_NOTIF_FLAG_CONTINUE");
+ 	}
+ 
+ skip:
+ 	EXPECT_EQ(waitpid(pid, &status, 0), pid);
+ 	EXPECT_EQ(true, WIFEXITED(status));
+ 	EXPECT_EQ(0, WEXITSTATUS(status)) {
+ 		if (WEXITSTATUS(status) == 2) {
+ 			SKIP(return, "Kernel does not support kcmp() syscall");
+ 			return;
+ 		}
+ 	}
+ }
+ 
++>>>>>>> 9847d24af95c (selftests/harness: Refactor XFAIL into SKIP)
  /*
   * TODO:
   * - add microbenchmarks
diff --git a/tools/testing/selftests/kselftest_harness.h b/tools/testing/selftests/kselftest_harness.h
index f8f7e47c739a..b519765904a6 100644
--- a/tools/testing/selftests/kselftest_harness.h
+++ b/tools/testing/selftests/kselftest_harness.h
@@ -112,22 +112,22 @@
 			__FILE__, __LINE__, _metadata->name, ##__VA_ARGS__)
 
 /**
- * XFAIL(statement, fmt, ...)
+ * SKIP(statement, fmt, ...)
  *
- * @statement: statement to run after reporting XFAIL
+ * @statement: statement to run after reporting SKIP
  * @fmt: format string
  * @...: optional arguments
  *
- * This forces a "pass" after reporting a failure with an XFAIL prefix,
+ * This forces a "pass" after reporting why something is being skipped
  * and runs "statement", which is usually "return" or "goto skip".
  */
-#define XFAIL(statement, fmt, ...) do { \
+#define SKIP(statement, fmt, ...) do { \
 	if (TH_LOG_ENABLED) { \
-		fprintf(TH_LOG_STREAM, "#      XFAIL     " fmt "\n", \
+		fprintf(TH_LOG_STREAM, "#      SKIP     " fmt "\n", \
 			##__VA_ARGS__); \
 	} \
-	/* TODO: find a way to pass xfail to test runner process. */ \
 	_metadata->passed = 1; \
+	_metadata->skip = 1; \
 	_metadata->trigger = 0; \
 	statement; \
 } while (0)
@@ -777,6 +777,7 @@ struct __test_metadata {
 	struct __fixture_metadata *fixture;
 	int termsig;
 	int passed;
+	int skip;	/* did SKIP get used? */
 	int trigger; /* extra handler after the evaluation */
 	int timeout;	/* seconds to wait for test timeout */
 	bool timed_out;	/* did this test timeout instead of exiting? */
@@ -866,17 +867,31 @@ void __wait_for_test(struct __test_metadata *t)
 		fprintf(TH_LOG_STREAM,
 			"# %s: Test terminated by timeout\n", t->name);
 	} else if (WIFEXITED(status)) {
-		t->passed = t->termsig == -1 ? !WEXITSTATUS(status) : 0;
 		if (t->termsig != -1) {
+			t->passed = 0;
 			fprintf(TH_LOG_STREAM,
 				"# %s: Test exited normally instead of by signal (code: %d)\n",
 				t->name,
 				WEXITSTATUS(status));
-		} else if (!t->passed) {
-			fprintf(TH_LOG_STREAM,
-				"# %s: Test failed at step #%d\n",
-				t->name,
-				WEXITSTATUS(status));
+		} else {
+			switch (WEXITSTATUS(status)) {
+			/* Success */
+			case 0:
+				t->passed = 1;
+				break;
+			/* SKIP */
+			case 255:
+				t->passed = 1;
+				t->skip = 1;
+				break;
+			/* Other failure, assume step report. */
+			default:
+				t->passed = 0;
+				fprintf(TH_LOG_STREAM,
+					"# %s: Test failed at step #%d\n",
+					t->name,
+					WEXITSTATUS(status));
+			}
 		}
 	} else if (WIFSIGNALED(status)) {
 		t->passed = 0;
@@ -906,6 +921,7 @@ void __run_test(struct __fixture_metadata *f,
 {
 	/* reset test struct */
 	t->passed = 1;
+	t->skip = 0;
 	t->trigger = 0;
 	t->step = 0;
 	t->no_print = 0;
@@ -918,15 +934,31 @@ void __run_test(struct __fixture_metadata *f,
 		t->passed = 0;
 	} else if (t->pid == 0) {
 		t->fn(t, variant);
-		/* return the step that failed or 0 */
-		_exit(t->passed ? 0 : t->step);
+		/* Make sure step doesn't get lost in reporting */
+		if (t->step >= 255) {
+			ksft_print_msg("Too many test steps (%u)!?\n", t->step);
+			t->step = 254;
+		}
+		/* Use 255 for SKIP */
+		if (t->skip)
+			_exit(255);
+		/* Pass is exit 0 */
+		if (t->passed)
+			_exit(0);
+		/* Something else happened, report the step. */
+		_exit(t->step);
 	} else {
 		__wait_for_test(t);
 	}
 	ksft_print_msg("         %4s  %s%s%s.%s\n", t->passed ? "OK" : "FAIL",
 	       f->name, variant->name[0] ? "." : "", variant->name, t->name);
-	ksft_test_result(t->passed, "%s%s%s.%s\n",
-	       f->name, variant->name[0] ? "." : "", variant->name, t->name);
+
+	if (t->skip)
+		ksft_test_result_skip("%s%s%s.%s\n",
+			f->name, variant->name[0] ? "." : "", variant->name, t->name);
+	else
+		ksft_test_result(t->passed, "%s%s%s.%s\n",
+			f->name, variant->name[0] ? "." : "", variant->name, t->name);
 }
 
 static int test_harness_run(int __attribute__((unused)) argc,
* Unmerged path tools/testing/selftests/seccomp/seccomp_bpf.c
