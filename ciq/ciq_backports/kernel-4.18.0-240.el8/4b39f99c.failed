futex: Remove {get,drop}_futex_key_refs()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Peter Zijlstra <peterz@infradead.org>
commit 4b39f99c222a2aff6a52fddfa6d8d4aef1771737
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/4b39f99c.failed

Now that {get,drop}_futex_key_refs() have become a glorified NOP,
remove them entirely.

The only thing get_futex_key_refs() is still doing is an smp_mb(), and
now that we don't need to (ab)use existing atomic ops to obtain them,
we can place it explicitly where we need it.

	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
(cherry picked from commit 4b39f99c222a2aff6a52fddfa6d8d4aef1771737)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/futex.c
diff --cc kernel/futex.c
index b1471854bcc6,b62cf942e4b7..000000000000
--- a/kernel/futex.c
+++ b/kernel/futex.c
@@@ -411,41 -399,38 +414,42 @@@ static inline int match_futex(union fut
  		&& key1->both.offset == key2->both.offset);
  }
  
 -enum futex_access {
 -	FUTEX_READ,
 -	FUTEX_WRITE
 -};
 -
 -/**
 - * futex_setup_timer - set up the sleeping hrtimer.
 - * @time:	ptr to the given timeout value
 - * @timeout:	the hrtimer_sleeper structure to be set up
 - * @flags:	futex flags
 - * @range_ns:	optional range in ns
 - *
 - * Return: Initialized hrtimer_sleeper structure or NULL if no timeout
 - *	   value given
++<<<<<<< HEAD
 +/*
 + * Take a reference to the resource addressed by a key.
 + * Can be called while holding spinlocks.
 + *
   */
 -static inline struct hrtimer_sleeper *
 -futex_setup_timer(ktime_t *time, struct hrtimer_sleeper *timeout,
 -		  int flags, u64 range_ns)
 +static void get_futex_key_refs(union futex_key *key)
  {
 -	if (!time)
 -		return NULL;
 +	if (!key->both.ptr)
 +		return;
  
 -	hrtimer_init_sleeper_on_stack(timeout, (flags & FLAGS_CLOCKRT) ?
 -				      CLOCK_REALTIME : CLOCK_MONOTONIC,
 -				      HRTIMER_MODE_ABS);
  	/*
 -	 * If range_ns is 0, calling hrtimer_set_expires_range_ns() is
 -	 * effectively the same as calling hrtimer_set_expires().
 +	 * On MMU less systems futexes are always "private" as there is no per
 +	 * process address space. We need the smp wmb nevertheless - yes,
 +	 * arch/blackfin has MMU less SMP ...
  	 */
 -	hrtimer_set_expires_range_ns(&timeout->timer, *time, range_ns);
 +	if (!IS_ENABLED(CONFIG_MMU)) {
 +		smp_mb(); /* explicit smp_mb(); (B) */
 +		return;
 +	}
  
 -	return timeout;
 +	switch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) {
 +	case FUT_OFF_INODE:
 +		ihold(key->shared.inode); /* implies smp_mb(); (B) */
 +		break;
 +	case FUT_OFF_MMSHARED:
 +		futex_get_mm(key); /* implies smp_mb(); (B) */
 +		break;
 +	default:
 +		/*
 +		 * Private futexes do not hold reference on an inode or
 +		 * mm, therefore the only purpose of calling get_futex_key_refs
 +		 * is because we need the barrier for the lockless waiter check.
 +		 */
 +		smp_mb(); /* explicit smp_mb(); (B) */
 +	}
  }
  
  /*
@@@ -475,11 -473,6 +479,13 @@@ static void drop_futex_key_refs(union f
  	}
  }
  
++=======
++>>>>>>> 4b39f99c222a (futex: Remove {get,drop}_futex_key_refs())
 +enum futex_access {
 +	FUTEX_READ,
 +	FUTEX_WRITE
 +};
 +
  /**
   * get_futex_key() - Get parameters which are the keys for a futex
   * @uaddr:	virtual address of the futex
* Unmerged path kernel/futex.c
