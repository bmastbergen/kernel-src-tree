io_uring: fix fs cleanup on cqe overflow

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pavel Begunkov <asml.silence@gmail.com>
commit c398ecb3d611925e4a5411afdf7489914a5c0460
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c398ecb3.failed

If completion queue overflow occurs, __io_cqring_fill_event() will
update req->cflags, which is in a union with req->work and happens to
be aliased to req->work.fs. Following io_free_req() ->
io_req_work_drop_env() may get a bunch of different problems (miscount
fs->users, segfault, etc) on cleaning @fs.

	Signed-off-by: Pavel Begunkov <asml.silence@gmail.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit c398ecb3d611925e4a5411afdf7489914a5c0460)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 2afa3b27779e,be65eda059ac..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -317,11 -589,28 +317,18 @@@ struct io_poll_iocb 
  struct io_kiocb {
  	union {
  		struct file		*file;
 -		struct io_rw		rw;
 +		struct kiocb		rw;
  		struct io_poll_iocb	poll;
 -		struct io_accept	accept;
 -		struct io_sync		sync;
 -		struct io_cancel	cancel;
 -		struct io_timeout	timeout;
 -		struct io_connect	connect;
 -		struct io_sr_msg	sr_msg;
 -		struct io_open		open;
 -		struct io_close		close;
 -		struct io_files_update	files_update;
 -		struct io_fadvise	fadvise;
 -		struct io_madvise	madvise;
 -		struct io_epoll		epoll;
 -		struct io_splice	splice;
 -		struct io_provide_buf	pbuf;
  	};
  
++<<<<<<< HEAD
 +	struct sqe_submit	submit;
++=======
+ 	struct io_async_ctx		*io;
+ 	int				cflags;
+ 	bool				needs_fixed_file;
+ 	u8				opcode;
++>>>>>>> c398ecb3d611 (io_uring: fix fs cleanup on cqe overflow)
  
  	struct io_ring_ctx	*ctx;
  	struct list_head	list;
@@@ -341,7 -622,26 +348,30 @@@
  	u32			result;
  	u32			sequence;
  
++<<<<<<< HEAD
 +	struct work_struct	work;
++=======
+ 	struct list_head	link_list;
+ 
+ 	struct list_head	inflight_entry;
+ 
+ 	struct percpu_ref	*fixed_file_refs;
+ 
+ 	union {
+ 		/*
+ 		 * Only commands that never go async can use the below fields,
+ 		 * obviously. Right now only IORING_OP_POLL_ADD uses them, and
+ 		 * async armed poll handlers for regular commands. The latter
+ 		 * restore the work, if needed.
+ 		 */
+ 		struct {
+ 			struct callback_head	task_work;
+ 			struct hlist_node	hash_node;
+ 			struct async_poll	*apoll;
+ 		};
+ 		struct io_wq_work	work;
+ 	};
++>>>>>>> c398ecb3d611 (io_uring: fix fs cleanup on cqe overflow)
  };
  
  #define IO_PLUG_THRESHOLD		2
* Unmerged path fs/io_uring.c
