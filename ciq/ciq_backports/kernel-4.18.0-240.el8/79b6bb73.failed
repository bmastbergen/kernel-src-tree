perf maps: Merge 'struct maps' with 'struct map_groups'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 79b6bb73f888933cbcd20b0ef3976cde67951b72
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/79b6bb73.failed

And pick the shortest name: 'struct maps'.

The split existed because we used to have two groups of maps, one for
functions and one for variables, but that only complicated things,
sometimes we needed to figure out what was at some address and then had
to first try it on the functions group and if that failed, fall back to
the variables one.

That split is long gone, so for quite a while we had only one struct
maps per struct map_groups, simplify things by combining those structs.

First patch is the minimum needed to merge both, follow up patches will
rename 'thread->mg' to 'thread->maps', etc.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
Link: https://lkml.kernel.org/n/tip-hom6639ro7020o708trhxh59@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 79b6bb73f888933cbcd20b0ef3976cde67951b72)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/arch/s390/annotate/instructions.c
#	tools/perf/arch/x86/util/event.c
#	tools/perf/util/annotate.c
#	tools/perf/util/machine.c
#	tools/perf/util/map.c
#	tools/perf/util/map.h
#	tools/perf/util/map_groups.h
#	tools/perf/util/map_symbol.h
#	tools/perf/util/symbol.c
#	tools/perf/util/synthetic-events.c
diff --cc tools/perf/arch/s390/annotate/instructions.c
index 20050fb54948,57be973aea74..000000000000
--- a/tools/perf/arch/s390/annotate/instructions.c
+++ b/tools/perf/arch/s390/annotate/instructions.c
@@@ -38,9 -38,9 +38,15 @@@ static int s390_call__parse(struct arc
  		return -1;
  	target.addr = map__objdump_2mem(map, ops->target.addr);
  
++<<<<<<< HEAD
 +	if (map_groups__find_ams(map->groups, &target) == 0 &&
 +	    map__rip_2objdump(target.map, map->map_ip(target.map, target.addr)) == ops->target.addr)
 +		ops->target.sym = target.sym;
++=======
+ 	if (maps__find_ams(ms->mg, &target) == 0 &&
+ 	    map__rip_2objdump(target.ms.map, map->map_ip(target.ms.map, target.addr)) == ops->target.addr)
+ 		ops->target.sym = target.ms.sym;
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  
  	return 0;
  }
diff --cc tools/perf/arch/x86/util/event.c
index a3a0b6884779,ac45015cc6ba..000000000000
--- a/tools/perf/arch/x86/util/event.c
+++ b/tools/perf/arch/x86/util/event.c
@@@ -27,7 -28,7 +26,11 @@@ int perf_event__synthesize_extra_kmaps(
  		return -1;
  	}
  
++<<<<<<< HEAD
 +	for (pos = maps__first(maps); pos; pos = map__next(pos)) {
++=======
+ 	maps__for_each_entry(kmaps, pos) {
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  		struct kmap *kmap;
  		size_t size;
  
diff --cc tools/perf/util/annotate.c
index e5850bb6616c,1b0980afdc3c..000000000000
--- a/tools/perf/util/annotate.c
+++ b/tools/perf/util/annotate.c
@@@ -269,9 -271,9 +269,15 @@@ static int call__parse(struct arch *arc
  find_target:
  	target.addr = map__objdump_2mem(map, ops->target.addr);
  
++<<<<<<< HEAD
 +	if (map_groups__find_ams(map->groups, &target) == 0 &&
 +	    map__rip_2objdump(target.map, map->map_ip(target.map, target.addr)) == ops->target.addr)
 +		ops->target.sym = target.sym;
++=======
+ 	if (maps__find_ams(ms->mg, &target) == 0 &&
+ 	    map__rip_2objdump(target.ms.map, map->map_ip(target.ms.map, target.addr)) == ops->target.addr)
+ 		ops->target.sym = target.ms.sym;
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  
  	return 0;
  
@@@ -389,9 -391,9 +395,15 @@@ static int jump__parse(struct arch *arc
  	 * Actual navigation will come next, with further understanding of how
  	 * the symbol searching and disassembly should be done.
  	 */
++<<<<<<< HEAD
 +	if (map_groups__find_ams(map->groups, &target) == 0 &&
 +	    map__rip_2objdump(target.map, map->map_ip(target.map, target.addr)) == ops->target.addr)
 +		ops->target.sym = target.sym;
++=======
+ 	if (maps__find_ams(ms->mg, &target) == 0 &&
+ 	    map__rip_2objdump(target.ms.map, map->map_ip(target.ms.map, target.addr)) == ops->target.addr)
+ 		ops->target.sym = target.ms.sym;
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  
  	if (!ops->target.outside) {
  		ops->target.offset = target.addr - start;
@@@ -1538,13 -1541,13 +1550,19 @@@ static int symbol__parse_objdump_line(s
  	/* kcore has no symbols, so add the call target symbol */
  	if (dl->ins.ops && ins__is_call(&dl->ins) && !dl->ops.target.sym) {
  		struct addr_map_symbol target = {
 +			.map = map,
  			.addr = dl->ops.target.addr,
 -			.ms = { .map = map, },
  		};
  
++<<<<<<< HEAD
 +		if (!map_groups__find_ams(map->groups, &target) &&
 +		    target.sym->start == target.al_addr)
 +			dl->ops.target.sym = target.sym;
++=======
+ 		if (!maps__find_ams(args->ms.mg, &target) &&
+ 		    target.ms.sym->start == target.al_addr)
+ 			dl->ops.target.sym = target.ms.sym;
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  	}
  
  	annotation_line__add(&dl->al, &notes->src->source);
diff --cc tools/perf/util/machine.c
index 97b56c40a5df,d646aea39333..000000000000
--- a/tools/perf/util/machine.c
+++ b/tools/perf/util/machine.c
@@@ -715,17 -723,16 +714,26 @@@ static int machine__process_ksymbol_reg
  					     struct perf_sample *sample __maybe_unused)
  {
  	struct symbol *sym;
- 	struct map *map;
+ 	struct map *map = maps__find(&machine->kmaps, event->ksymbol.addr);
  
++<<<<<<< HEAD
 +	map = map_groups__find(&machine->kmaps, event->ksymbol_event.addr);
++=======
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  	if (!map) {
 -		map = dso__new_map(event->ksymbol.name);
 +		map = dso__new_map(event->ksymbol_event.name);
  		if (!map)
  			return -ENOMEM;
  
++<<<<<<< HEAD
 +		map->start = event->ksymbol_event.addr;
 +		map->end = map->start + event->ksymbol_event.len;
 +		map_groups__insert(&machine->kmaps, map);
++=======
+ 		map->start = event->ksymbol.addr;
+ 		map->end = map->start + event->ksymbol.len;
+ 		maps__insert(&machine->kmaps, map);
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  	}
  
  	sym = symbol__new(map->map_ip(map, map->start),
@@@ -743,9 -750,9 +751,13 @@@ static int machine__process_ksymbol_unr
  {
  	struct map *map;
  
++<<<<<<< HEAD
 +	map = map_groups__find(&machine->kmaps, event->ksymbol_event.addr);
++=======
+ 	map = maps__find(&machine->kmaps, event->ksymbol.addr);
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  	if (map)
- 		map_groups__remove(&machine->kmaps, map);
+ 		maps__remove(&machine->kmaps, map);
  
  	return 0;
  }
@@@ -1024,7 -1030,7 +1035,11 @@@ int machine__map_x86_64_entry_trampolin
  	 * In the vmlinux case, pgoff is a virtual address which must now be
  	 * mapped to a vmlinux offset.
  	 */
++<<<<<<< HEAD
 +	for (map = maps__first(maps); map; map = map__next(map)) {
++=======
+ 	maps__for_each_entry(kmaps, map) {
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  		struct kmap *kmap = __map__kmap(map);
  		struct map *dest_map;
  
diff --cc tools/perf/util/map.c
index be8418d003b5,4c9fd064028f..000000000000
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@@ -516,23 -512,75 +516,89 @@@ u64 map__objdump_2mem(struct map *map, 
  	return ip + map->reloc;
  }
  
- static void maps__init(struct maps *maps)
+ void maps__init(struct maps *mg, struct machine *machine)
  {
++<<<<<<< HEAD
 +	maps->entries = RB_ROOT;
 +	maps->names = RB_ROOT;
 +	init_rwsem(&maps->lock);
 +}
 +
 +void map_groups__init(struct map_groups *mg, struct machine *machine)
 +{
 +	maps__init(&mg->maps);
++=======
+ 	mg->entries = RB_ROOT;
+ 	init_rwsem(&mg->lock);
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  	mg->machine = machine;
 -	mg->last_search_by_name = NULL;
 -	mg->nr_maps = 0;
 -	mg->maps_by_name = NULL;
  	refcount_set(&mg->refcnt, 1);
  }
  
++<<<<<<< HEAD
 +void map_groups__insert(struct map_groups *mg, struct map *map)
 +{
 +	maps__insert(&mg->maps, map);
++=======
+ static void __maps__free_maps_by_name(struct maps *mg)
+ {
+ 	/*
+ 	 * Free everything to try to do it from the rbtree in the next search
+ 	 */
+ 	zfree(&mg->maps_by_name);
+ 	mg->nr_maps_allocated = 0;
+ }
+ 
+ void maps__insert(struct maps *mg, struct map *map)
+ {
+ 	struct maps *maps = mg;
+ 
+ 	down_write(&maps->lock);
+ 	__maps__insert(maps, map);
+ 	++mg->nr_maps;
+ 
+ 	/*
+ 	 * If we already performed some search by name, then we need to add the just
+ 	 * inserted map and resort.
+ 	 */
+ 	if (mg->maps_by_name) {
+ 		if (mg->nr_maps > mg->nr_maps_allocated) {
+ 			int nr_allocate = mg->nr_maps * 2;
+ 			struct map **maps_by_name = realloc(mg->maps_by_name, nr_allocate * sizeof(map));
+ 
+ 			if (maps_by_name == NULL) {
+ 				__maps__free_maps_by_name(maps);
+ 				return;
+ 			}
+ 
+ 			mg->maps_by_name = maps_by_name;
+ 			mg->nr_maps_allocated = nr_allocate;
+ 		}
+ 		mg->maps_by_name[mg->nr_maps - 1] = map;
+ 		__maps__sort_by_name(maps);
+ 	}
+ 	up_write(&maps->lock);
+ }
+ 
+ static void __maps__remove(struct maps *maps, struct map *map)
+ {
+ 	rb_erase_init(&map->rb_node, &maps->entries);
+ 	map__put(map);
+ }
+ 
+ void maps__remove(struct maps *mg, struct map *map)
+ {
+ 	struct maps *maps = mg;
+ 	down_write(&maps->lock);
+ 	if (mg->last_search_by_name == map)
+ 		mg->last_search_by_name = NULL;
+ 
+ 	__maps__remove(maps, map);
+ 	--mg->nr_maps;
+ 	if (mg->maps_by_name)
+ 		__maps__free_maps_by_name(maps);
+ 	up_write(&maps->lock);
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  }
  
  static void __maps__purge(struct maps *maps)
@@@ -626,11 -649,10 +686,15 @@@ static bool map__contains_symbol(struc
  	return ip >= map->start && ip < map->end;
  }
  
++<<<<<<< HEAD
 +struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name,
 +					 struct map **mapp)
++=======
+ struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name, struct map **mapp)
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  {
  	struct symbol *sym;
 -	struct map *pos;
 +	struct rb_node *nd;
  
  	down_read(&maps->lock);
  
@@@ -656,33 -676,26 +720,31 @@@ out
  	return sym;
  }
  
- struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
- 					       const char *name,
- 					       struct map **mapp)
- {
- 	return maps__find_symbol_by_name(&mg->maps, name, mapp);
- }
- 
- int map_groups__find_ams(struct map_groups *mg, struct addr_map_symbol *ams)
+ int maps__find_ams(struct maps *mg, struct addr_map_symbol *ams)
  {
 -	if (ams->addr < ams->ms.map->start || ams->addr >= ams->ms.map->end) {
 +	if (ams->addr < ams->map->start || ams->addr >= ams->map->end) {
  		if (mg == NULL)
  			return -1;
++<<<<<<< HEAD
 +		ams->map = map_groups__find(mg, ams->addr);
 +		if (ams->map == NULL)
++=======
+ 		ams->ms.map = maps__find(mg, ams->addr);
+ 		if (ams->ms.map == NULL)
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  			return -1;
  	}
  
 -	ams->al_addr = ams->ms.map->map_ip(ams->ms.map, ams->addr);
 -	ams->ms.sym = map__find_symbol(ams->ms.map, ams->al_addr);
 +	ams->al_addr = ams->map->map_ip(ams->map, ams->addr);
 +	ams->sym = map__find_symbol(ams->map, ams->al_addr);
  
 -	return ams->ms.sym ? 0 : -1;
 +	return ams->sym ? 0 : -1;
  }
  
- static size_t maps__fprintf(struct maps *maps, FILE *fp)
+ size_t maps__fprintf(struct maps *maps, FILE *fp)
  {
  	size_t printed = 0;
 -	struct map *pos;
 +	struct rb_node *nd;
  
  	down_read(&maps->lock);
  
@@@ -701,20 -713,8 +763,23 @@@
  	return printed;
  }
  
- size_t map_groups__fprintf(struct map_groups *mg, FILE *fp)
+ int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp)
  {
++<<<<<<< HEAD
 +	return maps__fprintf(&mg->maps, fp);
 +}
 +
 +static void __map_groups__insert(struct map_groups *mg, struct map *map)
 +{
 +	__maps__insert(&mg->maps, map);
 +	__maps__insert_name(&mg->maps, map);
 +}
 +
 +int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map, FILE *fp)
 +{
 +	struct maps *maps = &mg->maps;
++=======
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  	struct rb_root *root;
  	struct rb_node *next, *first;
  	int err = 0;
@@@ -817,16 -817,15 +882,19 @@@ out
  /*
   * XXX This should not really _copy_ te maps, but refcount them.
   */
- int map_groups__clone(struct thread *thread, struct map_groups *parent)
+ int maps__clone(struct thread *thread, struct maps *parent)
  {
- 	struct map_groups *mg = thread->mg;
+ 	struct maps *mg = thread->mg;
  	int err = -ENOMEM;
  	struct map *map;
- 	struct maps *maps = &parent->maps;
  
- 	down_read(&maps->lock);
+ 	down_read(&parent->lock);
  
++<<<<<<< HEAD
 +	for (map = maps__first(maps); map; map = map__next(map)) {
++=======
+ 	maps__for_each_entry(parent, map) {
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  		struct map *new = map__clone(map);
  		if (new == NULL)
  			goto out_unlock;
diff --cc tools/perf/util/map.h
index f119eddbd620,067036e8970c..000000000000
--- a/tools/perf/util/map.h
+++ b/tools/perf/util/map.h
@@@ -12,21 -12,8 +12,25 @@@
  #include <linux/types.h>
  
  struct dso;
++<<<<<<< HEAD
 +struct ip_callchain;
 +struct ref_reloc_sym;
 +struct map_groups;
++=======
+ struct maps;
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  struct machine;
 +struct perf_evsel;
 +
 +/*
 + * Data about backing storage DSO, comes from PERF_RECORD_MMAP2 meta events
 + */
 +struct dso_id {
 +	u32	maj;
 +	u32	min;
 +	u64	ino;
 +	u64	ino_generation;
 +};
  
  struct map {
  	union {
diff --cc tools/perf/util/map_groups.h
index 1876388e8dd8,8a45994d6a97..000000000000
--- a/tools/perf/util/map_groups.h
+++ b/tools/perf/util/map_groups.h
@@@ -12,25 -12,28 +12,30 @@@
  struct ref_reloc_sym;
  struct machine;
  struct map;
+ struct maps;
  struct thread;
  
++<<<<<<< HEAD
 +struct maps {
 +	struct rb_root      entries;
 +	struct rb_root	    names;
 +	struct rw_semaphore lock;
 +};
 +
 +void maps__insert(struct maps *maps, struct map *map);
 +void maps__remove(struct maps *maps, struct map *map);
++=======
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  struct map *maps__find(struct maps *maps, u64 addr);
  struct map *maps__first(struct maps *maps);
  struct map *map__next(struct map *map);
 -
 -#define maps__for_each_entry(maps, map) \
 -	for (map = maps__first(maps); map; map = map__next(map))
 -
 -#define maps__for_each_entry_safe(maps, map, next) \
 -	for (map = maps__first(maps), next = map__next(map); map; map = next, next = map__next(map))
 +struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name, struct map **mapp);
  
- struct map_groups {
- 	struct maps	 maps;
+ struct maps {
+ 	struct rb_root      entries;
+ 	struct rw_semaphore lock;
  	struct machine	 *machine;
 -	struct map	 *last_search_by_name;
 -	struct map	 **maps_by_name;
  	refcount_t	 refcnt;
 -	unsigned int	 nr_maps;
 -	unsigned int	 nr_maps_allocated;
  #ifdef HAVE_LIBUNWIND_SUPPORT
  	void				*addr_space;
  	struct unwind_libunwind_ops	*unwind_libunwind_ops;
@@@ -56,41 -59,29 +61,39 @@@ static inline struct maps *maps__get(st
  	return mg;
  }
  
- void map_groups__put(struct map_groups *mg);
- void map_groups__init(struct map_groups *mg, struct machine *machine);
- void map_groups__exit(struct map_groups *mg);
- int map_groups__clone(struct thread *thread, struct map_groups *parent);
- size_t map_groups__fprintf(struct map_groups *mg, FILE *fp);
+ void maps__put(struct maps *mg);
+ void maps__init(struct maps *mg, struct machine *machine);
+ void maps__exit(struct maps *mg);
+ int maps__clone(struct thread *thread, struct maps *parent);
+ size_t maps__fprintf(struct maps *mg, FILE *fp);
  
- void map_groups__insert(struct map_groups *mg, struct map *map);
+ void maps__insert(struct maps *mg, struct map *map);
  
++<<<<<<< HEAD
 +static inline void map_groups__remove(struct map_groups *mg, struct map *map)
 +{
 +	maps__remove(&mg->maps, map);
 +}
++=======
+ void maps__remove(struct maps *mg, struct map *map);
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  
- static inline struct map *map_groups__find(struct map_groups *mg, u64 addr)
- {
- 	return maps__find(&mg->maps, addr);
- }
- 
- #define map_groups__for_each_entry(mg, map) \
- 	for (map = maps__first(&mg->maps); map; map = map__next(map))
- 
- #define map_groups__for_each_entry_safe(mg, map, next) \
- 	for (map = maps__first(&mg->maps), next = map__next(map); map; map = next, next = map__next(map))
- 
- struct symbol *map_groups__find_symbol(struct map_groups *mg, u64 addr, struct map **mapp);
- struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg, const char *name, struct map **mapp);
+ struct symbol *maps__find_symbol(struct maps *mg, u64 addr, struct map **mapp);
+ struct symbol *maps__find_symbol_by_name(struct maps *mg, const char *name, struct map **mapp);
  
  struct addr_map_symbol;
  
- int map_groups__find_ams(struct map_groups *mg, struct addr_map_symbol *ams);
+ int maps__find_ams(struct maps *mg, struct addr_map_symbol *ams);
+ 
+ int maps__fixup_overlappings(struct maps *mg, struct map *map, FILE *fp);
  
- int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map, FILE *fp);
+ struct map *maps__find_by_name(struct maps *mg, const char *name);
  
- struct map *map_groups__find_by_name(struct map_groups *mg, const char *name);
+ int maps__merge_in(struct maps *kmaps, struct map *new_map);
  
- int map_groups__merge_in(struct map_groups *kmaps, struct map *new_map);
++<<<<<<< HEAD
++=======
+ void __maps__sort_by_name(struct maps *mg);
  
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  #endif // __PERF_MAP_GROUPS_H
diff --cc tools/perf/util/map_symbol.h
index 5a1aed9f6bb4,bd985c1c6831..000000000000
--- a/tools/perf/util/map_symbol.h
+++ b/tools/perf/util/map_symbol.h
@@@ -4,10 -4,12 +4,18 @@@
  
  #include <linux/types.h>
  
++<<<<<<< HEAD
++=======
+ struct maps;
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  struct map;
  struct symbol;
  
  struct map_symbol {
++<<<<<<< HEAD
++=======
+ 	struct maps   *mg;
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  	struct map    *map;
  	struct symbol *sym;
  };
diff --cc tools/perf/util/symbol.c
index 7642451537f8,c70563622508..000000000000
--- a/tools/perf/util/symbol.c
+++ b/tools/perf/util/symbol.c
@@@ -236,10 -239,10 +236,15 @@@ void symbols__fixup_end(struct rb_root_
  		curr->end = roundup(curr->start, 4096) + 4096;
  }
  
- void map_groups__fixup_end(struct map_groups *mg)
+ void maps__fixup_end(struct maps *mg)
  {
++<<<<<<< HEAD
 +	struct maps *maps = &mg->maps;
 +	struct map *next, *curr;
++=======
+ 	struct maps *maps = mg;
+ 	struct map *prev = NULL, *curr;
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  
  	down_write(&maps->lock);
  
@@@ -1761,28 -1759,82 +1765,97 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
 +struct map *map_groups__find_by_name(struct map_groups *mg, const char *name)
++=======
+ static int map__strcmp(const void *a, const void *b)
  {
- 	struct maps *maps = &mg->maps;
+ 	const struct map *ma = *(const struct map **)a, *mb = *(const struct map **)b;
+ 	return strcmp(ma->dso->short_name, mb->dso->short_name);
+ }
+ 
+ static int map__strcmp_name(const void *name, const void *b)
+ {
+ 	const struct map *map = *(const struct map **)b;
+ 	return strcmp(name, map->dso->short_name);
+ }
+ 
+ void __maps__sort_by_name(struct maps *mg)
+ {
+ 	qsort(mg->maps_by_name, mg->nr_maps, sizeof(struct map *), map__strcmp);
+ }
+ 
+ static int map__groups__sort_by_name_from_rbtree(struct maps *mg)
+ {
+ 	struct map *map;
+ 	struct map **maps_by_name = realloc(mg->maps_by_name, mg->nr_maps * sizeof(map));
+ 	int i = 0;
+ 
+ 	if (maps_by_name == NULL)
+ 		return -1;
+ 
+ 	mg->maps_by_name = maps_by_name;
+ 	mg->nr_maps_allocated = mg->nr_maps;
+ 
+ 	maps__for_each_entry(mg, map)
+ 		maps_by_name[i++] = map;
+ 
+ 	__maps__sort_by_name(mg);
+ 	return 0;
+ }
+ 
+ static struct map *__maps__find_by_name(struct maps *mg, const char *name)
+ {
+ 	struct map **mapp;
+ 
+ 	if (mg->maps_by_name == NULL &&
+ 	    map__groups__sort_by_name_from_rbtree(mg))
+ 		return NULL;
+ 
+ 	mapp = bsearch(name, mg->maps_by_name, mg->nr_maps, sizeof(*mapp), map__strcmp_name);
+ 	if (mapp)
+ 		return *mapp;
+ 	return NULL;
+ }
+ 
+ struct map *maps__find_by_name(struct maps *mg, const char *name)
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
+ {
+ 	struct maps *maps = mg;
  	struct map *map;
 +	struct rb_node *node;
  
  	down_read(&maps->lock);
  
++<<<<<<< HEAD
 +	for (node = maps->names.rb_node; node; ) {
 +		int rc;
 +
 +		map = rb_entry(node, struct map, rb_node_name);
 +
 +		rc = strcmp(map->dso->short_name, name);
 +		if (rc < 0)
 +			node = node->rb_left;
 +		else if (rc > 0)
 +			node = node->rb_right;
 +		else
++=======
+ 	if (mg->last_search_by_name && strcmp(mg->last_search_by_name->dso->short_name, name) == 0) {
+ 		map = mg->last_search_by_name;
+ 		goto out_unlock;
+ 	}
+ 	/*
+ 	 * If we have mg->maps_by_name, then the name isn't in the rbtree,
+ 	 * as mg->maps_by_name mirrors the rbtree when lookups by name are
+ 	 * made.
+ 	 */
+ 	map = __maps__find_by_name(mg, name);
+ 	if (map || mg->maps_by_name != NULL)
+ 		goto out_unlock;
++>>>>>>> 79b6bb73f888 (perf maps: Merge 'struct maps' with 'struct map_groups')
  
 -	/* Fallback to traversing the rbtree... */
 -	maps__for_each_entry(maps, map)
 -		if (strcmp(map->dso->short_name, name) == 0) {
 -			mg->last_search_by_name = map;
  			goto out_unlock;
 -		}
 +	}
  
  	map = NULL;
  
* Unmerged path tools/perf/util/synthetic-events.c
diff --git a/tools/perf/arch/arm/tests/dwarf-unwind.c b/tools/perf/arch/arm/tests/dwarf-unwind.c
index 2c35e532bc9a..026737243766 100644
--- a/tools/perf/arch/arm/tests/dwarf-unwind.c
+++ b/tools/perf/arch/arm/tests/dwarf-unwind.c
@@ -26,7 +26,7 @@ static int sample_ustack(struct perf_sample *sample,
 
 	sp = (unsigned long) regs[PERF_REG_ARM_SP];
 
-	map = map_groups__find(thread->mg, (u64)sp);
+	map = maps__find(thread->mg, (u64)sp);
 	if (!map) {
 		pr_debug("failed to get stack map\n");
 		free(buf);
diff --git a/tools/perf/arch/arm64/tests/dwarf-unwind.c b/tools/perf/arch/arm64/tests/dwarf-unwind.c
index a6a407fa1b8b..886489632d17 100644
--- a/tools/perf/arch/arm64/tests/dwarf-unwind.c
+++ b/tools/perf/arch/arm64/tests/dwarf-unwind.c
@@ -26,7 +26,7 @@ static int sample_ustack(struct perf_sample *sample,
 
 	sp = (unsigned long) regs[PERF_REG_ARM64_SP];
 
-	map = map_groups__find(thread->mg, (u64)sp);
+	map = maps__find(thread->mg, (u64)sp);
 	if (!map) {
 		pr_debug("failed to get stack map\n");
 		free(buf);
diff --git a/tools/perf/arch/powerpc/tests/dwarf-unwind.c b/tools/perf/arch/powerpc/tests/dwarf-unwind.c
index 5c178e4a1995..b38117c50040 100644
--- a/tools/perf/arch/powerpc/tests/dwarf-unwind.c
+++ b/tools/perf/arch/powerpc/tests/dwarf-unwind.c
@@ -27,7 +27,7 @@ static int sample_ustack(struct perf_sample *sample,
 
 	sp = (unsigned long) regs[PERF_REG_POWERPC_R1];
 
-	map = map_groups__find(thread->mg, (u64)sp);
+	map = maps__find(thread->mg, (u64)sp);
 	if (!map) {
 		pr_debug("failed to get stack map\n");
 		free(buf);
* Unmerged path tools/perf/arch/s390/annotate/instructions.c
diff --git a/tools/perf/arch/x86/tests/dwarf-unwind.c b/tools/perf/arch/x86/tests/dwarf-unwind.c
index 6ad0a1cedb13..f52132ed7a8c 100644
--- a/tools/perf/arch/x86/tests/dwarf-unwind.c
+++ b/tools/perf/arch/x86/tests/dwarf-unwind.c
@@ -27,7 +27,7 @@ static int sample_ustack(struct perf_sample *sample,
 
 	sp = (unsigned long) regs[PERF_REG_X86_SP];
 
-	map = map_groups__find(thread->mg, (u64)sp);
+	map = maps__find(thread->mg, (u64)sp);
 	if (!map) {
 		pr_debug("failed to get stack map\n");
 		free(buf);
* Unmerged path tools/perf/arch/x86/util/event.c
diff --git a/tools/perf/builtin-report.c b/tools/perf/builtin-report.c
index 914e3c341a48..ee48c4f30259 100644
--- a/tools/perf/builtin-report.c
+++ b/tools/perf/builtin-report.c
@@ -737,11 +737,6 @@ static size_t maps__fprintf_task(struct maps *maps, int indent, FILE *fp)
 	return printed;
 }
 
-static int map_groups__fprintf_task(struct map_groups *mg, int indent, FILE *fp)
-{
-	return maps__fprintf_task(&mg->maps, indent, fp);
-}
-
 static void task__print_level(struct task *task, FILE *fp, int level)
 {
 	struct thread *thread = task->thread;
@@ -752,7 +747,7 @@ static void task__print_level(struct task *task, FILE *fp, int level)
 
 	fprintf(fp, "%s\n", thread__comm_str(thread));
 
-	map_groups__fprintf_task(thread->mg, comm_indent, fp);
+	maps__fprintf_task(thread->mg, comm_indent, fp);
 
 	if (!list_empty(&task->children)) {
 		list_for_each_entry(child, &task->children, list)
diff --git a/tools/perf/tests/map_groups.c b/tools/perf/tests/map_groups.c
index b52adad55f8d..27c6e3fb624c 100644
--- a/tools/perf/tests/map_groups.c
+++ b/tools/perf/tests/map_groups.c
@@ -13,12 +13,12 @@ struct map_def {
 	u64 end;
 };
 
-static int check_maps(struct map_def *merged, unsigned int size, struct map_groups *mg)
+static int check_maps(struct map_def *merged, unsigned int size, struct maps *maps)
 {
 	struct map *map;
 	unsigned int i = 0;
 
-	map_groups__for_each_entry(mg, map) {
+	maps__for_each_entry(maps, map) {
 		if (i > 0)
 			TEST_ASSERT_VAL("less maps expected", (map && i < size) || (!map && i == size));
 
@@ -35,7 +35,7 @@ static int check_maps(struct map_def *merged, unsigned int size, struct map_grou
 
 int test__map_groups__merge_in(struct test *t __maybe_unused, int subtest __maybe_unused)
 {
-	struct map_groups mg;
+	struct maps mg;
 	unsigned int i;
 	struct map_def bpf_progs[] = {
 		{ "bpf_prog_1", 200, 300 },
@@ -64,7 +64,7 @@ int test__map_groups__merge_in(struct test *t __maybe_unused, int subtest __mayb
 	struct map *map_kcore1, *map_kcore2, *map_kcore3;
 	int ret;
 
-	map_groups__init(&mg, NULL);
+	maps__init(&mg, NULL);
 
 	for (i = 0; i < ARRAY_SIZE(bpf_progs); i++) {
 		struct map *map;
@@ -74,7 +74,7 @@ int test__map_groups__merge_in(struct test *t __maybe_unused, int subtest __mayb
 
 		map->start = bpf_progs[i].start;
 		map->end   = bpf_progs[i].end;
-		map_groups__insert(&mg, map);
+		maps__insert(&mg, map);
 		map__put(map);
 	}
 
@@ -99,19 +99,19 @@ int test__map_groups__merge_in(struct test *t __maybe_unused, int subtest __mayb
 	map_kcore3->start = 880;
 	map_kcore3->end   = 1100;
 
-	ret = map_groups__merge_in(&mg, map_kcore1);
+	ret = maps__merge_in(&mg, map_kcore1);
 	TEST_ASSERT_VAL("failed to merge map", !ret);
 
 	ret = check_maps(merged12, ARRAY_SIZE(merged12), &mg);
 	TEST_ASSERT_VAL("merge check failed", !ret);
 
-	ret = map_groups__merge_in(&mg, map_kcore2);
+	ret = maps__merge_in(&mg, map_kcore2);
 	TEST_ASSERT_VAL("failed to merge map", !ret);
 
 	ret = check_maps(merged12, ARRAY_SIZE(merged12), &mg);
 	TEST_ASSERT_VAL("merge check failed", !ret);
 
-	ret = map_groups__merge_in(&mg, map_kcore3);
+	ret = maps__merge_in(&mg, map_kcore3);
 	TEST_ASSERT_VAL("failed to merge map", !ret);
 
 	ret = check_maps(merged3, ARRAY_SIZE(merged3), &mg);
diff --git a/tools/perf/tests/thread-mg-share.c b/tools/perf/tests/thread-mg-share.c
index cbac71716dec..7f15eedabbf6 100644
--- a/tools/perf/tests/thread-mg-share.c
+++ b/tools/perf/tests/thread-mg-share.c
@@ -12,16 +12,16 @@ int test__thread_mg_share(struct test *test __maybe_unused, int subtest __maybe_
 	/* thread group */
 	struct thread *leader;
 	struct thread *t1, *t2, *t3;
-	struct map_groups *mg;
+	struct maps *mg;
 
 	/* other process */
 	struct thread *other, *other_leader;
-	struct map_groups *other_mg;
+	struct maps *other_mg;
 
 	/*
 	 * This test create 2 processes abstractions (struct thread)
 	 * with several threads and checks they properly share and
-	 * maintain map groups info (struct map_groups).
+	 * maintain maps info (struct maps).
 	 *
 	 * thread group (pid: 0, tids: 0, 1, 2, 3)
 	 * other  group (pid: 4, tids: 4, 5)
diff --git a/tools/perf/tests/vmlinux-kallsyms.c b/tools/perf/tests/vmlinux-kallsyms.c
index 5e8834fc7dec..9d5c5f8e00d4 100644
--- a/tools/perf/tests/vmlinux-kallsyms.c
+++ b/tools/perf/tests/vmlinux-kallsyms.c
@@ -189,10 +189,9 @@ int test__vmlinux_matches_kallsyms(struct test *test __maybe_unused, int subtest
 		 * so use the short name, less descriptive but the same ("[kernel]" in
 		 * both cases.
 		 */
-		pair = map_groups__find_by_name(&kallsyms.kmaps,
-						(map->dso->kernel ?
-							map->dso->short_name :
-							map->dso->name));
+		pair = maps__find_by_name(&kallsyms.kmaps, (map->dso->kernel ?
+								map->dso->short_name :
+								map->dso->name));
 		if (pair) {
 			pair->priv = 1;
 		} else {
@@ -212,7 +211,7 @@ int test__vmlinux_matches_kallsyms(struct test *test __maybe_unused, int subtest
 		mem_start = vmlinux_map->unmap_ip(vmlinux_map, map->start);
 		mem_end = vmlinux_map->unmap_ip(vmlinux_map, map->end);
 
-		pair = map_groups__find(&kallsyms.kmaps, mem_start);
+		pair = maps__find(&kallsyms.kmaps, mem_start);
 		if (pair == NULL || pair->priv)
 			continue;
 
diff --git a/tools/perf/ui/stdio/hist.c b/tools/perf/ui/stdio/hist.c
index 51ed67548b83..1b1d7554e332 100644
--- a/tools/perf/ui/stdio/hist.c
+++ b/tools/perf/ui/stdio/hist.c
@@ -856,7 +856,7 @@ size_t hists__fprintf(struct hists *hists, bool show_header, int max_rows,
 		}
 
 		if (h->ms.map == NULL && verbose > 1) {
-			map_groups__fprintf(h->thread->mg, fp);
+			maps__fprintf(h->thread->mg, fp);
 			fprintf(fp, "%.10s end\n", graph_dotted_line);
 		}
 	}
* Unmerged path tools/perf/util/annotate.c
diff --git a/tools/perf/util/bpf-event.c b/tools/perf/util/bpf-event.c
index 2a4a0da35632..d29355db78a0 100644
--- a/tools/perf/util/bpf-event.c
+++ b/tools/perf/util/bpf-event.c
@@ -49,9 +49,7 @@ static int machine__process_bpf_event_load(struct machine *machine,
 	for (i = 0; i < info_linear->info.nr_jited_ksyms; i++) {
 		u64 *addrs = (u64 *)(uintptr_t)(info_linear->info.jited_ksyms);
 		u64 addr = addrs[i];
-		struct map *map;
-
-		map = map_groups__find(&machine->kmaps, addr);
+		struct map *map = maps__find(&machine->kmaps, addr);
 
 		if (map) {
 			map->dso->binary_type = DSO_BINARY_TYPE__BPF_PROG_INFO;
diff --git a/tools/perf/util/cs-etm.c b/tools/perf/util/cs-etm.c
index 9c2c45398f7b..ac9398c933c6 100644
--- a/tools/perf/util/cs-etm.c
+++ b/tools/perf/util/cs-etm.c
@@ -2566,7 +2566,7 @@ int cs_etm__process_auxtrace_info(union perf_event *event,
 	if (err)
 		goto err_delete_thread;
 
-	if (thread__init_map_groups(etm->unknown_thread, etm->machine)) {
+	if (thread__init_maps(etm->unknown_thread, etm->machine)) {
 		err = -ENOMEM;
 		goto err_delete_thread;
 	}
diff --git a/tools/perf/util/event.c b/tools/perf/util/event.c
index 8a8363d72082..a88f127608ae 100644
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@ -1557,7 +1557,7 @@ int perf_event__process(struct perf_tool *tool __maybe_unused,
 struct map *thread__find_map(struct thread *thread, u8 cpumode, u64 addr,
 			     struct addr_location *al)
 {
-	struct map_groups *mg = thread->mg;
+	struct maps *mg = thread->mg;
 	struct machine *machine = mg->machine;
 	bool load_map = false;
 
@@ -1600,7 +1600,7 @@ struct map *thread__find_map(struct thread *thread, u8 cpumode, u64 addr,
 		return NULL;
 	}
 
-	al->map = map_groups__find(mg, al->addr);
+	al->map = maps__find(mg, al->addr);
 	if (al->map != NULL) {
 		/*
 		 * Kernel maps might be changed when loading symbols so loading
diff --git a/tools/perf/util/intel-pt.c b/tools/perf/util/intel-pt.c
index e9ac11860229..a94dff7b640e 100644
--- a/tools/perf/util/intel-pt.c
+++ b/tools/perf/util/intel-pt.c
@@ -3189,7 +3189,7 @@ int intel_pt_process_auxtrace_info(union perf_event *event,
 	err = thread__set_comm(pt->unknown_thread, "unknown", 0);
 	if (err)
 		goto err_delete_thread;
-	if (thread__init_map_groups(pt->unknown_thread, pt->machine)) {
+	if (thread__init_maps(pt->unknown_thread, pt->machine)) {
 		err = -ENOMEM;
 		goto err_delete_thread;
 	}
* Unmerged path tools/perf/util/machine.c
diff --git a/tools/perf/util/machine.h b/tools/perf/util/machine.h
index 4dd10eefeebb..91843aaf3a22 100644
--- a/tools/perf/util/machine.h
+++ b/tools/perf/util/machine.h
@@ -49,7 +49,7 @@ struct machine {
 	struct vdso_info  *vdso_info;
 	struct perf_env   *env;
 	struct dsos	  dsos;
-	struct map_groups kmaps;
+	struct maps	  kmaps;
 	struct map	  *vmlinux_map;
 	u64		  kernel_start;
 	pid_t		  *current_tid;
@@ -81,7 +81,7 @@ struct map *machine__kernel_map(struct machine *machine)
 static inline
 struct maps *machine__kernel_maps(struct machine *machine)
 {
-	return &machine->kmaps.maps;
+	return &machine->kmaps;
 }
 
 int machine__get_kernel_start(struct machine *machine);
@@ -209,7 +209,7 @@ static inline
 struct symbol *machine__find_kernel_symbol(struct machine *machine, u64 addr,
 					   struct map **mapp)
 {
-	return map_groups__find_symbol(&machine->kmaps, addr, mapp);
+	return maps__find_symbol(&machine->kmaps, addr, mapp);
 }
 
 static inline
@@ -217,7 +217,7 @@ struct symbol *machine__find_kernel_symbol_by_name(struct machine *machine,
 						   const char *name,
 						   struct map **mapp)
 {
-	return map_groups__find_symbol_by_name(&machine->kmaps, name, mapp);
+	return maps__find_symbol_by_name(&machine->kmaps, name, mapp);
 }
 
 int arch__fix_module_text_start(u64 *start, u64 *size, const char *name);
* Unmerged path tools/perf/util/map.c
* Unmerged path tools/perf/util/map.h
* Unmerged path tools/perf/util/map_groups.h
* Unmerged path tools/perf/util/map_symbol.h
diff --git a/tools/perf/util/probe-event.c b/tools/perf/util/probe-event.c
index 2c6b090cf026..f370c0b34cac 100644
--- a/tools/perf/util/probe-event.c
+++ b/tools/perf/util/probe-event.c
@@ -333,7 +333,7 @@ static int kernel_get_module_dso(const char *module, struct dso **pdso)
 		char module_name[128];
 
 		snprintf(module_name, sizeof(module_name), "[%s]", module);
-		map = map_groups__find_by_name(&host_machine->kmaps, module_name);
+		map = maps__find_by_name(&host_machine->kmaps, module_name);
 		if (map) {
 			dso = map->dso;
 			goto found;
diff --git a/tools/perf/util/symbol-elf.c b/tools/perf/util/symbol-elf.c
index 8c01d30317b1..d2ae06313795 100644
--- a/tools/perf/util/symbol-elf.c
+++ b/tools/perf/util/symbol-elf.c
@@ -842,7 +842,7 @@ void __weak arch__sym_update(struct symbol *s __maybe_unused,
 
 static int dso__process_kernel_symbol(struct dso *dso, struct map *map,
 				      GElf_Sym *sym, GElf_Shdr *shdr,
-				      struct map_groups *kmaps, struct kmap *kmap,
+				      struct maps *kmaps, struct kmap *kmap,
 				      struct dso **curr_dsop, struct map **curr_mapp,
 				      const char *section_name,
 				      bool adjust_kernel_syms, bool kmodule, bool *remap_kernel)
@@ -874,8 +874,8 @@ static int dso__process_kernel_symbol(struct dso *dso, struct map *map,
 			/* Ensure maps are correctly ordered */
 			if (kmaps) {
 				map__get(map);
-				map_groups__remove(kmaps, map);
-				map_groups__insert(kmaps, map);
+				maps__remove(kmaps, map);
+				maps__insert(kmaps, map);
 				map__put(map);
 			}
 		}
@@ -900,7 +900,7 @@ static int dso__process_kernel_symbol(struct dso *dso, struct map *map,
 
 	snprintf(dso_name, sizeof(dso_name), "%s%s", dso->short_name, section_name);
 
-	curr_map = map_groups__find_by_name(kmaps, dso_name);
+	curr_map = maps__find_by_name(kmaps, dso_name);
 	if (curr_map == NULL) {
 		u64 start = sym->st_value;
 
@@ -926,7 +926,7 @@ static int dso__process_kernel_symbol(struct dso *dso, struct map *map,
 			curr_map->map_ip = curr_map->unmap_ip = identity__map_ip;
 		}
 		curr_dso->symtab_type = dso->symtab_type;
-		map_groups__insert(kmaps, curr_map);
+		maps__insert(kmaps, curr_map);
 		/*
 		 * Add it before we drop the referece to curr_map, i.e. while
 		 * we still are sure to have a reference to this DSO via
@@ -948,7 +948,7 @@ int dso__load_sym(struct dso *dso, struct map *map, struct symsrc *syms_ss,
 		  struct symsrc *runtime_ss, int kmodule)
 {
 	struct kmap *kmap = dso->kernel ? map__kmap(map) : NULL;
-	struct map_groups *kmaps = kmap ? map__kmaps(map) : NULL;
+	struct maps *kmaps = kmap ? map__kmaps(map) : NULL;
 	struct map *curr_map = map;
 	struct dso *curr_dso = dso;
 	Elf_Data *symstrs, *secstrs;
@@ -1160,7 +1160,7 @@ int dso__load_sym(struct dso *dso, struct map *map, struct symsrc *syms_ss,
 			 * We need to fixup this here too because we create new
 			 * maps here, for things like vsyscall sections.
 			 */
-			map_groups__fixup_end(kmaps);
+			maps__fixup_end(kmaps);
 		}
 	}
 	err = nr;
* Unmerged path tools/perf/util/symbol.c
diff --git a/tools/perf/util/symbol.h b/tools/perf/util/symbol.h
index 38ecd98dfede..e5f7d9191271 100644
--- a/tools/perf/util/symbol.h
+++ b/tools/perf/util/symbol.h
@@ -23,7 +23,7 @@
 
 struct dso;
 struct map;
-struct map_groups;
+struct maps;
 struct option;
 
 /*
@@ -137,7 +137,7 @@ struct block_info {
 
 struct addr_location {
 	struct thread *thread;
-	struct map_groups *mg;
+	struct maps   *mg;
 	struct map    *map;
 	struct symbol *sym;
 	const char    *srcline;
@@ -215,7 +215,7 @@ void __symbols__insert(struct rb_root_cached *symbols, struct symbol *sym,
 void symbols__insert(struct rb_root_cached *symbols, struct symbol *sym);
 void symbols__fixup_duplicate(struct rb_root_cached *symbols);
 void symbols__fixup_end(struct rb_root_cached *symbols);
-void map_groups__fixup_end(struct map_groups *mg);
+void maps__fixup_end(struct maps *mg);
 
 typedef int (*mapfn_t)(u64 start, u64 len, u64 pgoff, void *data);
 int file__read_maps(int fd, bool exe, mapfn_t mapfn, void *data,
* Unmerged path tools/perf/util/synthetic-events.c
diff --git a/tools/perf/util/thread.c b/tools/perf/util/thread.c
index d6742492492c..87473d28ad20 100644
--- a/tools/perf/util/thread.c
+++ b/tools/perf/util/thread.c
@@ -18,16 +18,16 @@
 
 #include <api/fs/fs.h>
 
-int thread__init_map_groups(struct thread *thread, struct machine *machine)
+int thread__init_maps(struct thread *thread, struct machine *machine)
 {
 	pid_t pid = thread->pid_;
 
 	if (pid == thread->tid || pid == -1) {
-		thread->mg = map_groups__new(machine);
+		thread->mg = maps__new(machine);
 	} else {
 		struct thread *leader = __machine__findnew_thread(machine, pid, pid);
 		if (leader) {
-			thread->mg = map_groups__get(leader->mg);
+			thread->mg = maps__get(leader->mg);
 			thread__put(leader);
 		}
 	}
@@ -86,7 +86,7 @@ void thread__delete(struct thread *thread)
 	thread_stack__free(thread);
 
 	if (thread->mg) {
-		map_groups__put(thread->mg);
+		maps__put(thread->mg);
 		thread->mg = NULL;
 	}
 	down_write(&thread->namespaces_lock);
@@ -323,7 +323,7 @@ int thread__comm_len(struct thread *thread)
 size_t thread__fprintf(struct thread *thread, FILE *fp)
 {
 	return fprintf(fp, "Thread %d %s\n", thread->tid, thread__comm_str(thread)) +
-	       map_groups__fprintf(thread->mg, fp);
+	       maps__fprintf(thread->mg, fp);
 }
 
 int thread__insert_map(struct thread *thread, struct map *map)
@@ -334,8 +334,8 @@ int thread__insert_map(struct thread *thread, struct map *map)
 	if (ret)
 		return ret;
 
-	map_groups__fixup_overlappings(thread->mg, map, stderr);
-	map_groups__insert(thread->mg, map);
+	maps__fixup_overlappings(thread->mg, map, stderr);
+	maps__insert(thread->mg, map);
 
 	return 0;
 }
@@ -344,7 +344,7 @@ static int __thread__prepare_access(struct thread *thread)
 {
 	bool initialized = false;
 	int err = 0;
-	struct maps *maps = &thread->mg->maps;
+	struct maps *maps = thread->mg;
 	struct map *map;
 
 	down_read(&maps->lock);
@@ -370,9 +370,7 @@ static int thread__prepare_access(struct thread *thread)
 	return err;
 }
 
-static int thread__clone_map_groups(struct thread *thread,
-				    struct thread *parent,
-				    bool do_maps_clone)
+static int thread__clone_maps(struct thread *thread, struct thread *parent, bool do_maps_clone)
 {
 	/* This is new thread, we share map groups for process. */
 	if (thread->pid_ == parent->pid_)
@@ -384,7 +382,7 @@ static int thread__clone_map_groups(struct thread *thread,
 		return 0;
 	}
 	/* But this one is new process, copy maps. */
-	return do_maps_clone ? map_groups__clone(thread, parent->mg) : 0;
+	return do_maps_clone ? maps__clone(thread, parent->mg) : 0;
 }
 
 int thread__fork(struct thread *thread, struct thread *parent, u64 timestamp, bool do_maps_clone)
@@ -400,7 +398,7 @@ int thread__fork(struct thread *thread, struct thread *parent, u64 timestamp, bo
 	}
 
 	thread->ppid = parent->tid;
-	return thread__clone_map_groups(thread, parent, do_maps_clone);
+	return thread__clone_maps(thread, parent, do_maps_clone);
 }
 
 void thread__find_cpumode_addr_location(struct thread *thread, u64 addr,
diff --git a/tools/perf/util/thread.h b/tools/perf/util/thread.h
index bf06113be4f3..6382a9a5b9d9 100644
--- a/tools/perf/util/thread.h
+++ b/tools/perf/util/thread.h
@@ -25,7 +25,7 @@ struct thread {
 		struct rb_node	 rb_node;
 		struct list_head node;
 	};
-	struct map_groups	*mg;
+	struct maps		*mg;
 	pid_t			pid_; /* Not all tools update this */
 	pid_t			tid;
 	pid_t			ppid;
@@ -53,7 +53,7 @@ struct namespaces;
 struct comm;
 
 struct thread *thread__new(pid_t pid, pid_t tid);
-int thread__init_map_groups(struct thread *thread, struct machine *machine);
+int thread__init_maps(struct thread *thread, struct machine *machine);
 void thread__delete(struct thread *thread);
 
 struct thread *thread__get(struct thread *thread);
diff --git a/tools/perf/util/unwind-libunwind-local.c b/tools/perf/util/unwind-libunwind-local.c
index aaf7a445c595..41a89bcb5e70 100644
--- a/tools/perf/util/unwind-libunwind-local.c
+++ b/tools/perf/util/unwind-libunwind-local.c
@@ -616,7 +616,7 @@ static unw_accessors_t accessors = {
 	.get_proc_name		= get_proc_name,
 };
 
-static int _unwind__prepare_access(struct map_groups *mg)
+static int _unwind__prepare_access(struct maps *mg)
 {
 	mg->addr_space = unw_create_addr_space(&accessors, 0);
 	if (!mg->addr_space) {
@@ -628,12 +628,12 @@ static int _unwind__prepare_access(struct map_groups *mg)
 	return 0;
 }
 
-static void _unwind__flush_access(struct map_groups *mg)
+static void _unwind__flush_access(struct maps *mg)
 {
 	unw_flush_cache(mg->addr_space, 0, 0);
 }
 
-static void _unwind__finish_access(struct map_groups *mg)
+static void _unwind__finish_access(struct maps *mg)
 {
 	unw_destroy_addr_space(mg->addr_space);
 }
diff --git a/tools/perf/util/unwind-libunwind.c b/tools/perf/util/unwind-libunwind.c
index 6499b22b158b..8c0c312f37cb 100644
--- a/tools/perf/util/unwind-libunwind.c
+++ b/tools/perf/util/unwind-libunwind.c
@@ -11,14 +11,12 @@ struct unwind_libunwind_ops __weak *local_unwind_libunwind_ops;
 struct unwind_libunwind_ops __weak *x86_32_unwind_libunwind_ops;
 struct unwind_libunwind_ops __weak *arm64_unwind_libunwind_ops;
 
-static void unwind__register_ops(struct map_groups *mg,
-			  struct unwind_libunwind_ops *ops)
+static void unwind__register_ops(struct maps *mg, struct unwind_libunwind_ops *ops)
 {
 	mg->unwind_libunwind_ops = ops;
 }
 
-int unwind__prepare_access(struct map_groups *mg, struct map *map,
-			   bool *initialized)
+int unwind__prepare_access(struct maps *mg, struct map *map, bool *initialized)
 {
 	const char *arch;
 	enum dso_type dso_type;
@@ -67,13 +65,13 @@ int unwind__prepare_access(struct map_groups *mg, struct map *map,
 	return err;
 }
 
-void unwind__flush_access(struct map_groups *mg)
+void unwind__flush_access(struct maps *mg)
 {
 	if (mg->unwind_libunwind_ops)
 		mg->unwind_libunwind_ops->flush_access(mg);
 }
 
-void unwind__finish_access(struct map_groups *mg)
+void unwind__finish_access(struct maps *mg)
 {
 	if (mg->unwind_libunwind_ops)
 		mg->unwind_libunwind_ops->finish_access(mg);
diff --git a/tools/perf/util/unwind.h b/tools/perf/util/unwind.h
index 50337c966979..ab8ad469c8de 100644
--- a/tools/perf/util/unwind.h
+++ b/tools/perf/util/unwind.h
@@ -6,7 +6,7 @@
 #include <linux/types.h>
 #include "util/map_symbol.h"
 
-struct map_groups;
+struct maps;
 struct perf_sample;
 struct thread;
 
@@ -18,9 +18,9 @@ struct unwind_entry {
 typedef int (*unwind_entry_cb_t)(struct unwind_entry *entry, void *arg);
 
 struct unwind_libunwind_ops {
-	int (*prepare_access)(struct map_groups *mg);
-	void (*flush_access)(struct map_groups *mg);
-	void (*finish_access)(struct map_groups *mg);
+	int (*prepare_access)(struct maps *maps);
+	void (*flush_access)(struct maps *maps);
+	void (*finish_access)(struct maps *maps);
 	int (*get_entries)(unwind_entry_cb_t cb, void *arg,
 			   struct thread *thread,
 			   struct perf_sample *data, int max_stack);
@@ -45,20 +45,19 @@ int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
 #endif
 
 int LIBUNWIND__ARCH_REG_ID(int regnum);
-int unwind__prepare_access(struct map_groups *mg, struct map *map,
-			   bool *initialized);
-void unwind__flush_access(struct map_groups *mg);
-void unwind__finish_access(struct map_groups *mg);
+int unwind__prepare_access(struct maps *maps, struct map *map, bool *initialized);
+void unwind__flush_access(struct maps *maps);
+void unwind__finish_access(struct maps *maps);
 #else
-static inline int unwind__prepare_access(struct map_groups *mg __maybe_unused,
+static inline int unwind__prepare_access(struct maps *maps __maybe_unused,
 					 struct map *map __maybe_unused,
 					 bool *initialized __maybe_unused)
 {
 	return 0;
 }
 
-static inline void unwind__flush_access(struct map_groups *mg __maybe_unused) {}
-static inline void unwind__finish_access(struct map_groups *mg __maybe_unused) {}
+static inline void unwind__flush_access(struct maps *maps __maybe_unused) {}
+static inline void unwind__finish_access(struct maps *maps __maybe_unused) {}
 #endif
 #else
 static inline int
@@ -71,14 +70,14 @@ unwind__get_entries(unwind_entry_cb_t cb __maybe_unused,
 	return 0;
 }
 
-static inline int unwind__prepare_access(struct map_groups *mg __maybe_unused,
+static inline int unwind__prepare_access(struct maps *maps __maybe_unused,
 					 struct map *map __maybe_unused,
 					 bool *initialized __maybe_unused)
 {
 	return 0;
 }
 
-static inline void unwind__flush_access(struct map_groups *mg __maybe_unused) {}
-static inline void unwind__finish_access(struct map_groups *mg __maybe_unused) {}
+static inline void unwind__flush_access(struct maps *maps __maybe_unused) {}
+static inline void unwind__finish_access(struct maps *maps __maybe_unused) {}
 #endif /* HAVE_DWARF_UNWIND_SUPPORT */
 #endif /* __UNWIND_H */
diff --git a/tools/perf/util/vdso.c b/tools/perf/util/vdso.c
index 0f8820b1784b..16f638b28647 100644
--- a/tools/perf/util/vdso.c
+++ b/tools/perf/util/vdso.c
@@ -143,7 +143,7 @@ static enum dso_type machine__thread_dso_type(struct machine *machine,
 	enum dso_type dso_type = DSO__TYPE_UNKNOWN;
 	struct map *map;
 
-	map_groups__for_each_entry(thread->mg, map) {
+	maps__for_each_entry(thread->mg, map) {
 		struct dso *dso = map->dso;
 		if (!dso || dso->long_name[0] != '/')
 			continue;
