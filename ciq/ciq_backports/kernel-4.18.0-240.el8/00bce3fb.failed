Bluetooth: Enable erroneous data reporting if WBS is supported

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Alain Michaud <alainm@chromium.org>
commit 00bce3fb0642b38fa2e5db3217526c3e0d5952ca
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/00bce3fb.failed

This change introduces a wide band speech setting which allows higher
level clients to query the local controller support for wide band speech
as well as set the setting state when the radio is powered off.
Internally, this setting controls if erroneous data reporting is enabled
on the controller.

	Signed-off-by: Alain Michaud <alainm@chromium.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 00bce3fb0642b38fa2e5db3217526c3e0d5952ca)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btusb.c
#	include/net/bluetooth/hci.h
#	include/net/bluetooth/mgmt.h
#	net/bluetooth/mgmt.c
diff --cc drivers/bluetooth/btusb.c
index f9f1be91d4c8,4b12c34f0b22..000000000000
--- a/drivers/bluetooth/btusb.c
+++ b/drivers/bluetooth/btusb.c
@@@ -3162,6 -3867,9 +3162,12 @@@ static int btusb_probe(struct usb_inter
  	if (id->driver_info & BTUSB_BROKEN_ISOC)
  		data->isoc = NULL;
  
++<<<<<<< HEAD
++=======
+ 	if (id->driver_info & BTUSB_WIDEBAND_SPEECH)
+ 		set_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED, &hdev->quirks);
+ 
++>>>>>>> 00bce3fb0642 (Bluetooth: Enable erroneous data reporting if WBS is supported)
  	if (id->driver_info & BTUSB_DIGIANSWER) {
  		data->cmdreq_type = USB_TYPE_VENDOR;
  		set_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);
diff --cc include/net/bluetooth/hci.h
index 1668211297a9,4e86f1bb7a87..000000000000
--- a/include/net/bluetooth/hci.h
+++ b/include/net/bluetooth/hci.h
@@@ -183,6 -196,24 +183,27 @@@ enum 
  	 * during the hdev->setup vendor callback.
  	 */
  	HCI_QUIRK_NON_PERSISTENT_DIAG,
++<<<<<<< HEAD
++=======
+ 
+ 	/* When this quirk is set, setup() would be run after every
+ 	 * open() and not just after the first open().
+ 	 *
+ 	 * This quirk can be set before hci_register_dev is called or
+ 	 * during the hdev->setup vendor callback.
+ 	 *
+ 	 */
+ 	HCI_QUIRK_NON_PERSISTENT_SETUP,
+ 
+ 	/* When this quirk is set, wide band speech is supported by
+ 	 * the driver since no reliable mechanism exist to report
+ 	 * this from the hardware, a driver flag is use to convey
+ 	 * this support
+ 	 *
+ 	 * This quirk must be set before hci_register_dev is called.
+ 	 */
+ 	HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED,
++>>>>>>> 00bce3fb0642 (Bluetooth: Enable erroneous data reporting if WBS is supported)
  };
  
  /* HCI device flags */
diff --cc include/net/bluetooth/mgmt.h
index e7303eee65cd,f41cd87550dc..000000000000
--- a/include/net/bluetooth/mgmt.h
+++ b/include/net/bluetooth/mgmt.h
@@@ -101,6 -101,8 +101,11 @@@ struct mgmt_rp_read_index_list 
  #define MGMT_SETTING_PRIVACY		0x00002000
  #define MGMT_SETTING_CONFIGURATION	0x00004000
  #define MGMT_SETTING_STATIC_ADDRESS	0x00008000
++<<<<<<< HEAD
++=======
+ #define MGMT_SETTING_PHY_CONFIGURATION	0x00010000
+ #define MGMT_SETTING_WIDEBAND_SPEECH	0x00020000
++>>>>>>> 00bce3fb0642 (Bluetooth: Enable erroneous data reporting if WBS is supported)
  
  #define MGMT_OP_READ_INFO		0x0004
  #define MGMT_READ_INFO_SIZE		0
@@@ -604,6 -612,68 +609,71 @@@ struct mgmt_cp_set_appearance 
  } __packed;
  #define MGMT_SET_APPEARANCE_SIZE	2
  
++<<<<<<< HEAD
++=======
+ #define MGMT_OP_GET_PHY_CONFIGURATION	0x0044
+ struct mgmt_rp_get_phy_confguration {
+ 	__le32	supported_phys;
+ 	__le32	configurable_phys;
+ 	__le32	selected_phys;
+ } __packed;
+ #define MGMT_GET_PHY_CONFIGURATION_SIZE	0
+ 
+ #define MGMT_PHY_BR_1M_1SLOT	0x00000001
+ #define MGMT_PHY_BR_1M_3SLOT	0x00000002
+ #define MGMT_PHY_BR_1M_5SLOT	0x00000004
+ #define MGMT_PHY_EDR_2M_1SLOT	0x00000008
+ #define MGMT_PHY_EDR_2M_3SLOT	0x00000010
+ #define MGMT_PHY_EDR_2M_5SLOT	0x00000020
+ #define MGMT_PHY_EDR_3M_1SLOT	0x00000040
+ #define MGMT_PHY_EDR_3M_3SLOT	0x00000080
+ #define MGMT_PHY_EDR_3M_5SLOT	0x00000100
+ #define MGMT_PHY_LE_1M_TX		0x00000200
+ #define MGMT_PHY_LE_1M_RX		0x00000400
+ #define MGMT_PHY_LE_2M_TX		0x00000800
+ #define MGMT_PHY_LE_2M_RX		0x00001000
+ #define MGMT_PHY_LE_CODED_TX	0x00002000
+ #define MGMT_PHY_LE_CODED_RX	0x00004000
+ 
+ #define MGMT_PHY_BREDR_MASK (MGMT_PHY_BR_1M_1SLOT | MGMT_PHY_BR_1M_3SLOT | \
+ 			     MGMT_PHY_BR_1M_5SLOT | MGMT_PHY_EDR_2M_1SLOT | \
+ 			     MGMT_PHY_EDR_2M_3SLOT | MGMT_PHY_EDR_2M_5SLOT | \
+ 			     MGMT_PHY_EDR_3M_1SLOT | MGMT_PHY_EDR_3M_3SLOT | \
+ 			     MGMT_PHY_EDR_3M_5SLOT)
+ #define MGMT_PHY_LE_MASK (MGMT_PHY_LE_1M_TX | MGMT_PHY_LE_1M_RX | \
+ 			  MGMT_PHY_LE_2M_TX | MGMT_PHY_LE_2M_RX | \
+ 			  MGMT_PHY_LE_CODED_TX | MGMT_PHY_LE_CODED_RX)
+ #define MGMT_PHY_LE_TX_MASK (MGMT_PHY_LE_1M_TX | MGMT_PHY_LE_2M_TX | \
+ 			     MGMT_PHY_LE_CODED_TX)
+ #define MGMT_PHY_LE_RX_MASK (MGMT_PHY_LE_1M_RX | MGMT_PHY_LE_2M_RX | \
+ 			     MGMT_PHY_LE_CODED_RX)
+ 
+ #define MGMT_OP_SET_PHY_CONFIGURATION	0x0045
+ struct mgmt_cp_set_phy_confguration {
+ 	__le32	selected_phys;
+ } __packed;
+ #define MGMT_SET_PHY_CONFIGURATION_SIZE	4
+ 
+ #define MGMT_OP_SET_BLOCKED_KEYS	0x0046
+ 
+ #define HCI_BLOCKED_KEY_TYPE_LINKKEY	0x00
+ #define HCI_BLOCKED_KEY_TYPE_LTK	0x01
+ #define HCI_BLOCKED_KEY_TYPE_IRK	0x02
+ 
+ struct mgmt_blocked_key_info {
+ 	__u8 type;
+ 	__u8 val[16];
+ } __packed;
+ 
+ struct mgmt_cp_set_blocked_keys {
+ 	__le16 key_count;
+ 	struct mgmt_blocked_key_info keys[0];
+ } __packed;
+ #define MGMT_OP_SET_BLOCKED_KEYS_SIZE 2
+ 
+ #define MGMT_OP_SET_WIDEBAND_SPEECH	0x0047
+ 
++>>>>>>> 00bce3fb0642 (Bluetooth: Enable erroneous data reporting if WBS is supported)
  #define MGMT_EV_CMD_COMPLETE		0x0001
  struct mgmt_ev_cmd_complete {
  	__le16	opcode;
diff --cc net/bluetooth/mgmt.c
index 8a80d48d89c4,4abb5daeeca8..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -106,6 -106,8 +106,11 @@@ static const u16 mgmt_commands[] = 
  	MGMT_OP_START_LIMITED_DISCOVERY,
  	MGMT_OP_READ_EXT_INFO,
  	MGMT_OP_SET_APPEARANCE,
++<<<<<<< HEAD
++=======
+ 	MGMT_OP_SET_BLOCKED_KEYS,
+ 	MGMT_OP_SET_WIDEBAND_SPEECH,
++>>>>>>> 00bce3fb0642 (Bluetooth: Enable erroneous data reporting if WBS is supported)
  };
  
  static const u16 mgmt_events[] = {
@@@ -640,6 -763,10 +645,13 @@@ static u32 get_supported_settings(struc
  
  		if (lmp_sc_capable(hdev))
  			settings |= MGMT_SETTING_SECURE_CONN;
++<<<<<<< HEAD
++=======
+ 
+ 		if (test_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED,
+ 			     &hdev->quirks))
+ 			settings |= MGMT_SETTING_WIDEBAND_SPEECH;
++>>>>>>> 00bce3fb0642 (Bluetooth: Enable erroneous data reporting if WBS is supported)
  	}
  
  	if (lmp_le_capable(hdev)) {
@@@ -3184,6 -3329,330 +3199,333 @@@ static int set_appearance(struct sock *
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int get_phy_configuration(struct sock *sk, struct hci_dev *hdev,
+ 				 void *data, u16 len)
+ {
+ 	struct mgmt_rp_get_phy_confguration rp;
+ 
+ 	BT_DBG("sock %p %s", sk, hdev->name);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	memset(&rp, 0, sizeof(rp));
+ 
+ 	rp.supported_phys = cpu_to_le32(get_supported_phys(hdev));
+ 	rp.selected_phys = cpu_to_le32(get_selected_phys(hdev));
+ 	rp.configurable_phys = cpu_to_le32(get_configurable_phys(hdev));
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_PHY_CONFIGURATION, 0,
+ 				 &rp, sizeof(rp));
+ }
+ 
+ int mgmt_phy_configuration_changed(struct hci_dev *hdev, struct sock *skip)
+ {
+ 	struct mgmt_ev_phy_configuration_changed ev;
+ 
+ 	memset(&ev, 0, sizeof(ev));
+ 
+ 	ev.selected_phys = cpu_to_le32(get_selected_phys(hdev));
+ 
+ 	return mgmt_event(MGMT_EV_PHY_CONFIGURATION_CHANGED, hdev, &ev,
+ 			  sizeof(ev), skip);
+ }
+ 
+ static void set_default_phy_complete(struct hci_dev *hdev, u8 status,
+ 				     u16 opcode, struct sk_buff *skb)
+ {
+ 	struct mgmt_pending_cmd *cmd;
+ 
+ 	BT_DBG("status 0x%02x", status);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	cmd = pending_find(MGMT_OP_SET_PHY_CONFIGURATION, hdev);
+ 	if (!cmd)
+ 		goto unlock;
+ 
+ 	if (status) {
+ 		mgmt_cmd_status(cmd->sk, hdev->id,
+ 				MGMT_OP_SET_PHY_CONFIGURATION,
+ 				mgmt_status(status));
+ 	} else {
+ 		mgmt_cmd_complete(cmd->sk, hdev->id,
+ 				  MGMT_OP_SET_PHY_CONFIGURATION, 0,
+ 				  NULL, 0);
+ 
+ 		mgmt_phy_configuration_changed(hdev, cmd->sk);
+ 	}
+ 
+ 	mgmt_pending_remove(cmd);
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ }
+ 
+ static int set_phy_configuration(struct sock *sk, struct hci_dev *hdev,
+ 				 void *data, u16 len)
+ {
+ 	struct mgmt_cp_set_phy_confguration *cp = data;
+ 	struct hci_cp_le_set_default_phy cp_phy;
+ 	struct mgmt_pending_cmd *cmd;
+ 	struct hci_request req;
+ 	u32 selected_phys, configurable_phys, supported_phys, unconfigure_phys;
+ 	u16 pkt_type = (HCI_DH1 | HCI_DM1);
+ 	bool changed = false;
+ 	int err;
+ 
+ 	BT_DBG("sock %p %s", sk, hdev->name);
+ 
+ 	configurable_phys = get_configurable_phys(hdev);
+ 	supported_phys = get_supported_phys(hdev);
+ 	selected_phys = __le32_to_cpu(cp->selected_phys);
+ 
+ 	if (selected_phys & ~supported_phys)
+ 		return mgmt_cmd_status(sk, hdev->id,
+ 				       MGMT_OP_SET_PHY_CONFIGURATION,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	unconfigure_phys = supported_phys & ~configurable_phys;
+ 
+ 	if ((selected_phys & unconfigure_phys) != unconfigure_phys)
+ 		return mgmt_cmd_status(sk, hdev->id,
+ 				       MGMT_OP_SET_PHY_CONFIGURATION,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	if (selected_phys == get_selected_phys(hdev))
+ 		return mgmt_cmd_complete(sk, hdev->id,
+ 					 MGMT_OP_SET_PHY_CONFIGURATION,
+ 					 0, NULL, 0);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (!hdev_is_powered(hdev)) {
+ 		err = mgmt_cmd_status(sk, hdev->id,
+ 				      MGMT_OP_SET_PHY_CONFIGURATION,
+ 				      MGMT_STATUS_REJECTED);
+ 		goto unlock;
+ 	}
+ 
+ 	if (pending_find(MGMT_OP_SET_PHY_CONFIGURATION, hdev)) {
+ 		err = mgmt_cmd_status(sk, hdev->id,
+ 				      MGMT_OP_SET_PHY_CONFIGURATION,
+ 				      MGMT_STATUS_BUSY);
+ 		goto unlock;
+ 	}
+ 
+ 	if (selected_phys & MGMT_PHY_BR_1M_3SLOT)
+ 		pkt_type |= (HCI_DH3 | HCI_DM3);
+ 	else
+ 		pkt_type &= ~(HCI_DH3 | HCI_DM3);
+ 
+ 	if (selected_phys & MGMT_PHY_BR_1M_5SLOT)
+ 		pkt_type |= (HCI_DH5 | HCI_DM5);
+ 	else
+ 		pkt_type &= ~(HCI_DH5 | HCI_DM5);
+ 
+ 	if (selected_phys & MGMT_PHY_EDR_2M_1SLOT)
+ 		pkt_type &= ~HCI_2DH1;
+ 	else
+ 		pkt_type |= HCI_2DH1;
+ 
+ 	if (selected_phys & MGMT_PHY_EDR_2M_3SLOT)
+ 		pkt_type &= ~HCI_2DH3;
+ 	else
+ 		pkt_type |= HCI_2DH3;
+ 
+ 	if (selected_phys & MGMT_PHY_EDR_2M_5SLOT)
+ 		pkt_type &= ~HCI_2DH5;
+ 	else
+ 		pkt_type |= HCI_2DH5;
+ 
+ 	if (selected_phys & MGMT_PHY_EDR_3M_1SLOT)
+ 		pkt_type &= ~HCI_3DH1;
+ 	else
+ 		pkt_type |= HCI_3DH1;
+ 
+ 	if (selected_phys & MGMT_PHY_EDR_3M_3SLOT)
+ 		pkt_type &= ~HCI_3DH3;
+ 	else
+ 		pkt_type |= HCI_3DH3;
+ 
+ 	if (selected_phys & MGMT_PHY_EDR_3M_5SLOT)
+ 		pkt_type &= ~HCI_3DH5;
+ 	else
+ 		pkt_type |= HCI_3DH5;
+ 
+ 	if (pkt_type != hdev->pkt_type) {
+ 		hdev->pkt_type = pkt_type;
+ 		changed = true;
+ 	}
+ 
+ 	if ((selected_phys & MGMT_PHY_LE_MASK) ==
+ 	    (get_selected_phys(hdev) & MGMT_PHY_LE_MASK)) {
+ 		if (changed)
+ 			mgmt_phy_configuration_changed(hdev, sk);
+ 
+ 		err = mgmt_cmd_complete(sk, hdev->id,
+ 					MGMT_OP_SET_PHY_CONFIGURATION,
+ 					0, NULL, 0);
+ 
+ 		goto unlock;
+ 	}
+ 
+ 	cmd = mgmt_pending_add(sk, MGMT_OP_SET_PHY_CONFIGURATION, hdev, data,
+ 			       len);
+ 	if (!cmd) {
+ 		err = -ENOMEM;
+ 		goto unlock;
+ 	}
+ 
+ 	hci_req_init(&req, hdev);
+ 
+ 	memset(&cp_phy, 0, sizeof(cp_phy));
+ 
+ 	if (!(selected_phys & MGMT_PHY_LE_TX_MASK))
+ 		cp_phy.all_phys |= 0x01;
+ 
+ 	if (!(selected_phys & MGMT_PHY_LE_RX_MASK))
+ 		cp_phy.all_phys |= 0x02;
+ 
+ 	if (selected_phys & MGMT_PHY_LE_1M_TX)
+ 		cp_phy.tx_phys |= HCI_LE_SET_PHY_1M;
+ 
+ 	if (selected_phys & MGMT_PHY_LE_2M_TX)
+ 		cp_phy.tx_phys |= HCI_LE_SET_PHY_2M;
+ 
+ 	if (selected_phys & MGMT_PHY_LE_CODED_TX)
+ 		cp_phy.tx_phys |= HCI_LE_SET_PHY_CODED;
+ 
+ 	if (selected_phys & MGMT_PHY_LE_1M_RX)
+ 		cp_phy.rx_phys |= HCI_LE_SET_PHY_1M;
+ 
+ 	if (selected_phys & MGMT_PHY_LE_2M_RX)
+ 		cp_phy.rx_phys |= HCI_LE_SET_PHY_2M;
+ 
+ 	if (selected_phys & MGMT_PHY_LE_CODED_RX)
+ 		cp_phy.rx_phys |= HCI_LE_SET_PHY_CODED;
+ 
+ 	hci_req_add(&req, HCI_OP_LE_SET_DEFAULT_PHY, sizeof(cp_phy), &cp_phy);
+ 
+ 	err = hci_req_run_skb(&req, set_default_phy_complete);
+ 	if (err < 0)
+ 		mgmt_pending_remove(cmd);
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 
+ 	return err;
+ }
+ 
+ static int set_blocked_keys(struct sock *sk, struct hci_dev *hdev, void *data,
+ 			    u16 len)
+ {
+ 	int err = MGMT_STATUS_SUCCESS;
+ 	struct mgmt_cp_set_blocked_keys *keys = data;
+ 	const u16 max_key_count = ((U16_MAX - sizeof(*keys)) /
+ 				   sizeof(struct mgmt_blocked_key_info));
+ 	u16 key_count, expected_len;
+ 	int i;
+ 
+ 	BT_DBG("request for %s", hdev->name);
+ 
+ 	key_count = __le16_to_cpu(keys->key_count);
+ 	if (key_count > max_key_count) {
+ 		bt_dev_err(hdev, "too big key_count value %u", key_count);
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 	}
+ 
+ 	expected_len = struct_size(keys, keys, key_count);
+ 	if (expected_len != len) {
+ 		bt_dev_err(hdev, "expected %u bytes, got %u bytes",
+ 			   expected_len, len);
+ 		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 	}
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	hci_blocked_keys_clear(hdev);
+ 
+ 	for (i = 0; i < keys->key_count; ++i) {
+ 		struct blocked_key *b = kzalloc(sizeof(*b), GFP_KERNEL);
+ 
+ 		if (!b) {
+ 			err = MGMT_STATUS_NO_RESOURCES;
+ 			break;
+ 		}
+ 
+ 		b->type = keys->keys[i].type;
+ 		memcpy(b->val, keys->keys[i].val, sizeof(b->val));
+ 		list_add_rcu(&b->list, &hdev->blocked_keys);
+ 	}
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
+ 				err, NULL, 0);
+ }
+ 
+ static int set_wideband_speech(struct sock *sk, struct hci_dev *hdev,
+ 			       void *data, u16 len)
+ {
+ 	struct mgmt_mode *cp = data;
+ 	int err;
+ 	bool changed = false;
+ 
+ 	BT_DBG("request for %s", hdev->name);
+ 
+ 	if (!test_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED, &hdev->quirks))
+ 		return mgmt_cmd_status(sk, hdev->id,
+ 				       MGMT_OP_SET_WIDEBAND_SPEECH,
+ 				       MGMT_STATUS_NOT_SUPPORTED);
+ 
+ 	if (cp->val != 0x00 && cp->val != 0x01)
+ 		return mgmt_cmd_status(sk, hdev->id,
+ 				       MGMT_OP_SET_WIDEBAND_SPEECH,
+ 				       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (pending_find(MGMT_OP_SET_WIDEBAND_SPEECH, hdev)) {
+ 		err = mgmt_cmd_status(sk, hdev->id,
+ 				      MGMT_OP_SET_WIDEBAND_SPEECH,
+ 				      MGMT_STATUS_BUSY);
+ 		goto unlock;
+ 	}
+ 
+ 	if (hdev_is_powered(hdev) &&
+ 	    !!cp->val != hci_dev_test_flag(hdev,
+ 					   HCI_WIDEBAND_SPEECH_ENABLED)) {
+ 		err = mgmt_cmd_status(sk, hdev->id,
+ 				      MGMT_OP_SET_WIDEBAND_SPEECH,
+ 				      MGMT_STATUS_REJECTED);
+ 		goto unlock;
+ 	}
+ 
+ 	if (cp->val)
+ 		changed = !hci_dev_test_and_set_flag(hdev,
+ 						   HCI_WIDEBAND_SPEECH_ENABLED);
+ 	else
+ 		changed = hci_dev_test_and_clear_flag(hdev,
+ 						   HCI_WIDEBAND_SPEECH_ENABLED);
+ 
+ 	err = send_settings_rsp(sk, MGMT_OP_SET_WIDEBAND_SPEECH, hdev);
+ 	if (err < 0)
+ 		goto unlock;
+ 
+ 	if (changed)
+ 		err = new_settings(hdev, sk);
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 	return err;
+ }
+ 
++>>>>>>> 00bce3fb0642 (Bluetooth: Enable erroneous data reporting if WBS is supported)
  static void read_local_oob_data_complete(struct hci_dev *hdev, u8 status,
  				         u16 opcode, struct sk_buff *skb)
  {
@@@ -6544,6 -7050,11 +6886,14 @@@ static const struct hci_mgmt_handler mg
  	{ read_ext_controller_info,MGMT_READ_EXT_INFO_SIZE,
  						HCI_MGMT_UNTRUSTED },
  	{ set_appearance,	   MGMT_SET_APPEARANCE_SIZE },
++<<<<<<< HEAD
++=======
+ 	{ get_phy_configuration,   MGMT_GET_PHY_CONFIGURATION_SIZE },
+ 	{ set_phy_configuration,   MGMT_SET_PHY_CONFIGURATION_SIZE },
+ 	{ set_blocked_keys,	   MGMT_OP_SET_BLOCKED_KEYS_SIZE,
+ 						HCI_MGMT_VAR_LEN },
+ 	{ set_wideband_speech,	   MGMT_SETTING_SIZE },
++>>>>>>> 00bce3fb0642 (Bluetooth: Enable erroneous data reporting if WBS is supported)
  };
  
  void mgmt_index_added(struct hci_dev *hdev)
* Unmerged path drivers/bluetooth/btusb.c
* Unmerged path include/net/bluetooth/hci.h
diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index d080a9db390b..58ae7754386d 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -237,6 +237,7 @@ struct hci_dev {
 	__u8		stored_num_keys;
 	__u8		io_capability;
 	__s8		inq_tx_power;
+	__u8		err_data_reporting;
 	__u16		page_scan_interval;
 	__u16		page_scan_window;
 	__u8		page_scan_type;
* Unmerged path include/net/bluetooth/mgmt.h
diff --git a/net/bluetooth/hci_core.c b/net/bluetooth/hci_core.c
index ee8ef1228263..89b3b529e2c4 100644
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@ -602,6 +602,9 @@ static int hci_init3_req(struct hci_request *req, unsigned long opt)
 	if (hdev->commands[8] & 0x01)
 		hci_req_add(req, HCI_OP_READ_PAGE_SCAN_ACTIVITY, 0, NULL);
 
+	if (hdev->commands[18] & 0x02)
+		hci_req_add(req, HCI_OP_READ_DEF_ERR_DATA_REPORTING, 0, NULL);
+
 	/* Some older Broadcom based Bluetooth 1.2 controllers do not
 	 * support the Read Page Scan Type command. Check support for
 	 * this command in the bit mask of supported commands.
@@ -789,6 +792,26 @@ static int hci_init4_req(struct hci_request *req, unsigned long opt)
 			    sizeof(support), &support);
 	}
 
+	/* Set erroneous data reporting if supported to the wideband speech
+	 * setting value
+	 */
+	if (hdev->commands[18] & 0x04) {
+		bool enabled = hci_dev_test_flag(hdev,
+						 HCI_WIDEBAND_SPEECH_ENABLED);
+
+		if (enabled !=
+		    (hdev->err_data_reporting == ERR_DATA_REPORTING_ENABLED)) {
+			struct hci_cp_write_def_err_data_reporting cp;
+
+			cp.err_data_reporting = enabled ?
+						ERR_DATA_REPORTING_ENABLED :
+						ERR_DATA_REPORTING_DISABLED;
+
+			hci_req_add(req, HCI_OP_WRITE_DEF_ERR_DATA_REPORTING,
+				    sizeof(cp), &cp);
+		}
+	}
+
 	/* Set Suggested Default Data Length to maximum if supported */
 	if (hdev->le_features[0] & HCI_LE_DATA_LEN_EXT) {
 		struct hci_cp_le_write_def_data_len cp;
diff --git a/net/bluetooth/hci_event.c b/net/bluetooth/hci_event.c
index 235b5aaab23d..716b8b3d2a04 100644
--- a/net/bluetooth/hci_event.c
+++ b/net/bluetooth/hci_event.c
@@ -855,6 +855,37 @@ static void hci_cc_read_inq_rsp_tx_power(struct hci_dev *hdev,
 	hdev->inq_tx_power = rp->tx_power;
 }
 
+static void hci_cc_read_def_err_data_reporting(struct hci_dev *hdev,
+					       struct sk_buff *skb)
+{
+	struct hci_rp_read_def_err_data_reporting *rp = (void *)skb->data;
+
+	BT_DBG("%s status 0x%2.2x", hdev->name, rp->status);
+
+	if (rp->status)
+		return;
+
+	hdev->err_data_reporting = rp->err_data_reporting;
+}
+
+static void hci_cc_write_def_err_data_reporting(struct hci_dev *hdev,
+						struct sk_buff *skb)
+{
+	__u8 status = *((__u8 *)skb->data);
+	struct hci_cp_write_def_err_data_reporting *cp;
+
+	BT_DBG("%s status 0x%2.2x", hdev->name, status);
+
+	if (status)
+		return;
+
+	cp = hci_sent_cmd_data(hdev, HCI_OP_WRITE_DEF_ERR_DATA_REPORTING);
+	if (!cp)
+		return;
+
+	hdev->err_data_reporting = cp->err_data_reporting;
+}
+
 static void hci_cc_pin_code_reply(struct hci_dev *hdev, struct sk_buff *skb)
 {
 	struct hci_rp_pin_code_reply *rp = (void *) skb->data;
@@ -2927,6 +2958,14 @@ static void hci_cmd_complete_evt(struct hci_dev *hdev, struct sk_buff *skb,
 		hci_cc_read_inq_rsp_tx_power(hdev, skb);
 		break;
 
+	case HCI_OP_READ_DEF_ERR_DATA_REPORTING:
+		hci_cc_read_def_err_data_reporting(hdev, skb);
+		break;
+
+	case HCI_OP_WRITE_DEF_ERR_DATA_REPORTING:
+		hci_cc_write_def_err_data_reporting(hdev, skb);
+		break;
+
 	case HCI_OP_PIN_CODE_REPLY:
 		hci_cc_pin_code_reply(hdev, skb);
 		break;
* Unmerged path net/bluetooth/mgmt.c
