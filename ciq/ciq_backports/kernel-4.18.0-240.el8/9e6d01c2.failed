KVM: x86: Refactor handling of XSAVES CPUID adjustment

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 9e6d01c2d9088efb8326997cafa8580295a49435
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9e6d01c2.failed

Invert the handling of XSAVES, i.e. set it based on boot_cpu_has() by
default, in preparation for adding KVM cpu caps, which will generate the
mask at load time before ->xsaves_supported() is ready.

No functional change intended.

	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 9e6d01c2d9088efb8326997cafa8580295a49435)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/cpuid.c
diff --cc arch/x86/kvm/cpuid.c
index d4472786ed92,3e4b03c8ec12..000000000000
--- a/arch/x86/kvm/cpuid.c
+++ b/arch/x86/kvm/cpuid.c
@@@ -462,8 -414,6 +462,11 @@@ static inline int __do_cpuid_func(struc
  	unsigned f_gbpages = 0;
  	unsigned f_lm = 0;
  #endif
++<<<<<<< HEAD
 +	unsigned f_rdtscp = kvm_x86_ops->rdtscp_supported() ? F(RDTSCP) : 0;
 +	unsigned f_xsaves = kvm_x86_ops->xsaves_supported() ? F(XSAVES) : 0;
++=======
++>>>>>>> 9e6d01c2d908 (KVM: x86: Refactor handling of XSAVES CPUID adjustment)
  	unsigned f_intel_pt = kvm_x86_ops->pt_supported() ? F(INTEL_PT) : 0;
  
  	/* cpuid 1.edx */
@@@ -652,9 -600,13 +655,17 @@@
  			goto out;
  
  		entry->eax &= kvm_cpuid_D_1_eax_x86_features;
++<<<<<<< HEAD
 +		cpuid_mask(&entry->eax, CPUID_D_1_EAX);
++=======
+ 		cpuid_entry_mask(entry, CPUID_D_1_EAX);
+ 
+ 		if (!kvm_x86_ops->xsaves_supported())
+ 			cpuid_entry_clear(entry, X86_FEATURE_XSAVES);
+ 
++>>>>>>> 9e6d01c2d908 (KVM: x86: Refactor handling of XSAVES CPUID adjustment)
  		if (entry->eax & (F(XSAVES)|F(XSAVEC)))
 -			entry->ebx = xstate_required_size(supported_xcr0, true);
 +			entry->ebx = xstate_required_size(supported, true);
  		else
  			entry->ebx = 0;
  		/* Saving XSS controlled state via XSAVES isn't supported. */
* Unmerged path arch/x86/kvm/cpuid.c
