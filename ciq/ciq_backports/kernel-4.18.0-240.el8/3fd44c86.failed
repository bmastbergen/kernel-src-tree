io_uring: use cond_resched() in io_ring_ctx_wait_and_kill()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Xiaoguang Wang <xiaoguang.wang@linux.alibaba.com>
commit 3fd44c86711f71156b586c22b0495c58f69358bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/3fd44c86.failed

While working on to make io_uring sqpoll mode support syscalls that need
struct files_struct, I got cpu soft lockup in io_ring_ctx_wait_and_kill(),

    while (ctx->sqo_thread && !wq_has_sleeper(&ctx->sqo_wait))
        cpu_relax();

above loop never has an chance to exit, it's because preempt isn't enabled
in the kernel, and the context calling io_ring_ctx_wait_and_kill() and
io_sq_thread() run in the same cpu, if io_sq_thread calls a cond_resched()
yield cpu and another context enters above loop, then io_sq_thread() will
always in runqueue and never exit.

Use cond_resched() can fix this issue.

 Reported-by: syzbot+66243bb7126c410cefe6@syzkaller.appspotmail.com
	Signed-off-by: Xiaoguang Wang <xiaoguang.wang@linux.alibaba.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 3fd44c86711f71156b586c22b0495c58f69358bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 2afa3b27779e,5ca2da6648d0..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -3571,10 -7335,29 +3571,24 @@@ static void io_ring_ctx_wait_and_kill(s
  	percpu_ref_kill(&ctx->refs);
  	mutex_unlock(&ctx->uring_lock);
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * Wait for sq thread to idle, if we have one. It won't spin on new
+ 	 * work after we've killed the ctx ref above. This is important to do
+ 	 * before we cancel existing commands, as the thread could otherwise
+ 	 * be queueing new work post that. If that's work we need to cancel,
+ 	 * it could cause shutdown to hang.
+ 	 */
+ 	while (ctx->sqo_thread && !wq_has_sleeper(&ctx->sqo_wait))
+ 		cond_resched();
+ 
+ 	io_kill_timeouts(ctx);
++>>>>>>> 3fd44c86711f (io_uring: use cond_resched() in io_ring_ctx_wait_and_kill())
  	io_poll_remove_all(ctx);
 -
 -	if (ctx->io_wq)
 -		io_wq_cancel_all(ctx->io_wq);
 -
  	io_iopoll_reap_events(ctx);
 -	/* if we failed setting up the ctx, we might not have any rings */
 -	if (ctx->rings)
 -		io_cqring_overflow_flush(ctx, true);
 -	idr_for_each(&ctx->personality_idr, io_remove_personalities, ctx);
 -	INIT_WORK(&ctx->exit_work, io_ring_exit_work);
 -	queue_work(system_wq, &ctx->exit_work);
 +	wait_for_completion(&ctx->ctx_done);
 +	io_ring_ctx_free(ctx);
  }
  
  static int io_uring_release(struct inode *inode, struct file *file)
* Unmerged path fs/io_uring.c
