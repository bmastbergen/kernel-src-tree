KVM: x86: Protect exit_reason from being used in Spectre-v1/L1TF attacks

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Marios Pomonis <pomonis@google.com>
commit c926f2f7230b1a29e31914b51db680f8cbf3103f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/c926f2f7.failed

This fixes a Spectre-v1/L1TF vulnerability in vmx_handle_exit().
While exit_reason is set by the hardware and therefore should not be
attacker-influenced, an unknown exit_reason could potentially be used to
perform such an attack.

Fixes: 55d2375e58a6 ("KVM: nVMX: Move nested code to dedicated files")

	Signed-off-by: Marios Pomonis <pomonis@google.com>
	Signed-off-by: Nick Finco <nifi@google.com>
	Suggested-by: Sean Christopherson <sean.j.christopherson@intel.com>
	Reviewed-by: Andrew Honig <ahonig@google.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit c926f2f7230b1a29e31914b51db680f8cbf3103f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index aace07a1fbd9,62fb639895c2..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -5984,34 -5913,41 +5984,71 @@@ static int vmx_handle_exit(struct kvm_v
  	if (exit_fastpath == EXIT_FASTPATH_SKIP_EMUL_INS) {
  		kvm_skip_emulated_instruction(vcpu);
  		return 1;
++<<<<<<< HEAD
 +	} else if (exit_reason < kvm_vmx_max_exit_handlers
 +	    && kvm_vmx_exit_handlers[exit_reason]) {
 +#ifdef CONFIG_RETPOLINE
 +		if (exit_reason == EXIT_REASON_MSR_WRITE)
 +			return kvm_emulate_wrmsr(vcpu);
 +		else if (exit_reason == EXIT_REASON_PREEMPTION_TIMER)
 +			return handle_preemption_timer(vcpu);
 +		else if (exit_reason == EXIT_REASON_PENDING_INTERRUPT)
 +			return handle_interrupt_window(vcpu);
 +		else if (exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT)
 +			return handle_external_interrupt(vcpu);
 +		else if (exit_reason == EXIT_REASON_HLT)
 +			return kvm_emulate_halt(vcpu);
 +		else if (exit_reason == EXIT_REASON_EPT_MISCONFIG)
 +			return handle_ept_misconfig(vcpu);
 +#endif
 +		return kvm_vmx_exit_handlers[exit_reason](vcpu);
 +	} else {
 +		vcpu_unimpl(vcpu, "vmx: unexpected exit reason 0x%x\n",
 +				exit_reason);
 +		dump_vmcs();
 +		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
 +		vcpu->run->internal.suberror =
 +			KVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;
 +		vcpu->run->internal.ndata = 1;
 +		vcpu->run->internal.data[0] = exit_reason;
 +		return 0;
++=======
++>>>>>>> c926f2f7230b (KVM: x86: Protect exit_reason from being used in Spectre-v1/L1TF attacks)
  	}
+ 
+ 	if (exit_reason >= kvm_vmx_max_exit_handlers)
+ 		goto unexpected_vmexit;
+ #ifdef CONFIG_RETPOLINE
+ 	if (exit_reason == EXIT_REASON_MSR_WRITE)
+ 		return kvm_emulate_wrmsr(vcpu);
+ 	else if (exit_reason == EXIT_REASON_PREEMPTION_TIMER)
+ 		return handle_preemption_timer(vcpu);
+ 	else if (exit_reason == EXIT_REASON_INTERRUPT_WINDOW)
+ 		return handle_interrupt_window(vcpu);
+ 	else if (exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT)
+ 		return handle_external_interrupt(vcpu);
+ 	else if (exit_reason == EXIT_REASON_HLT)
+ 		return kvm_emulate_halt(vcpu);
+ 	else if (exit_reason == EXIT_REASON_EPT_MISCONFIG)
+ 		return handle_ept_misconfig(vcpu);
+ #endif
+ 
+ 	exit_reason = array_index_nospec(exit_reason,
+ 					 kvm_vmx_max_exit_handlers);
+ 	if (!kvm_vmx_exit_handlers[exit_reason])
+ 		goto unexpected_vmexit;
+ 
+ 	return kvm_vmx_exit_handlers[exit_reason](vcpu);
+ 
+ unexpected_vmexit:
+ 	vcpu_unimpl(vcpu, "vmx: unexpected exit reason 0x%x\n", exit_reason);
+ 	dump_vmcs();
+ 	vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
+ 	vcpu->run->internal.suberror =
+ 			KVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;
+ 	vcpu->run->internal.ndata = 1;
+ 	vcpu->run->internal.data[0] = exit_reason;
+ 	return 0;
  }
  
  /*
* Unmerged path arch/x86/kvm/vmx/vmx.c
