memblock: replace free_bootmem_late with memblock_free_late

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Mike Rapoport <rppt@linux.vnet.ibm.com>
commit 53ab85ebfd27cdf16c8ddc72781c072a63bef3cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/53ab85eb.failed

The free_bootmem_late and memblock_free_late do exactly the same thing:
they iterate over a range and give pages to the page allocator.

Replace calls to free_bootmem_late with calls to memblock_free_late and
remove the bootmem variant.

Link: http://lkml.kernel.org/r/1536927045-23536-25-git-send-email-rppt@linux.vnet.ibm.com
	Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
	Acked-by: Michal Hocko <mhocko@suse.com>
	Cc: Catalin Marinas <catalin.marinas@arm.com>
	Cc: Chris Zankel <chris@zankel.net>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Geert Uytterhoeven <geert@linux-m68k.org>
	Cc: Greentime Hu <green.hu@gmail.com>
	Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
	Cc: Guan Xuetao <gxt@pku.edu.cn>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
	Cc: Jonas Bonn <jonas@southpole.se>
	Cc: Jonathan Corbet <corbet@lwn.net>
	Cc: Ley Foon Tan <lftan@altera.com>
	Cc: Mark Salter <msalter@redhat.com>
	Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
	Cc: Matt Turner <mattst88@gmail.com>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Michal Simek <monstr@monstr.eu>
	Cc: Palmer Dabbelt <palmer@sifive.com>
	Cc: Paul Burton <paul.burton@mips.com>
	Cc: Richard Kuo <rkuo@codeaurora.org>
	Cc: Richard Weinberger <richard@nod.at>
	Cc: Rich Felker <dalias@libc.org>
	Cc: Russell King <linux@armlinux.org.uk>
	Cc: Serge Semin <fancer.lancer@gmail.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Tony Luck <tony.luck@intel.com>
	Cc: Vineet Gupta <vgupta@synopsys.com>
	Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 53ab85ebfd27cdf16c8ddc72781c072a63bef3cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/bootmem.h
#	mm/nobootmem.c
diff --cc include/linux/bootmem.h
index 42515195d7d8,bcc7e2fcb6a6..000000000000
--- a/include/linux/bootmem.h
+++ b/include/linux/bootmem.h
@@@ -66,71 -30,8 +66,74 @@@ extern unsigned long free_all_bootmem(v
  extern void reset_node_managed_pages(pg_data_t *pgdat);
  extern void reset_all_zones_managed_pages(void);
  
++<<<<<<< HEAD
 +extern void free_bootmem_node(pg_data_t *pgdat,
 +			      unsigned long addr,
 +			      unsigned long size);
 +extern void free_bootmem(unsigned long physaddr, unsigned long size);
 +extern void free_bootmem_late(unsigned long physaddr, unsigned long size);
 +
 +/*
 + * Flags for reserve_bootmem (also if CONFIG_HAVE_ARCH_BOOTMEM_NODE,
 + * the architecture-specific code should honor this).
 + *
 + * If flags is BOOTMEM_DEFAULT, then the return value is always 0 (success).
 + * If flags contains BOOTMEM_EXCLUSIVE, then -EBUSY is returned if the memory
 + * already was reserved.
 + */
 +#define BOOTMEM_DEFAULT		0
 +#define BOOTMEM_EXCLUSIVE	(1<<0)
 +
 +extern int reserve_bootmem(unsigned long addr,
 +			   unsigned long size,
 +			   int flags);
 +extern int reserve_bootmem_node(pg_data_t *pgdat,
 +				unsigned long physaddr,
 +				unsigned long size,
 +				int flags);
 +
 +extern void *__alloc_bootmem(unsigned long size,
 +			     unsigned long align,
 +			     unsigned long goal);
 +extern void *__alloc_bootmem_nopanic(unsigned long size,
 +				     unsigned long align,
 +				     unsigned long goal) __malloc;
 +extern void *__alloc_bootmem_node(pg_data_t *pgdat,
 +				  unsigned long size,
 +				  unsigned long align,
 +				  unsigned long goal) __malloc;
 +void *__alloc_bootmem_node_high(pg_data_t *pgdat,
 +				  unsigned long size,
 +				  unsigned long align,
 +				  unsigned long goal) __malloc;
 +extern void *__alloc_bootmem_node_nopanic(pg_data_t *pgdat,
 +				  unsigned long size,
 +				  unsigned long align,
 +				  unsigned long goal) __malloc;
 +void *___alloc_bootmem_node_nopanic(pg_data_t *pgdat,
 +				  unsigned long size,
 +				  unsigned long align,
 +				  unsigned long goal,
 +				  unsigned long limit) __malloc;
 +extern void *__alloc_bootmem_low(unsigned long size,
 +				 unsigned long align,
 +				 unsigned long goal) __malloc;
 +void *__alloc_bootmem_low_nopanic(unsigned long size,
 +				 unsigned long align,
 +				 unsigned long goal) __malloc;
 +extern void *__alloc_bootmem_low_node(pg_data_t *pgdat,
 +				      unsigned long size,
 +				      unsigned long align,
 +				      unsigned long goal) __malloc;
 +
 +#ifdef CONFIG_NO_BOOTMEM
++=======
++>>>>>>> 53ab85ebfd27 (memblock: replace free_bootmem_late with memblock_free_late)
  /* We are using top down, so it is safe to use 0 here */
  #define BOOTMEM_LOW_LIMIT 0
 +#else
 +#define BOOTMEM_LOW_LIMIT __pa(MAX_DMA_ADDRESS)
 +#endif
  
  #ifndef ARCH_LOW_ADDRESS_LIMIT
  #define ARCH_LOW_ADDRESS_LIMIT  0xffffffffUL
diff --cc mm/nobootmem.c
index 439af3b765a7,ee0f7fc37fd1..000000000000
--- a/mm/nobootmem.c
+++ b/mm/nobootmem.c
@@@ -37,65 -33,6 +37,68 @@@ unsigned long min_low_pfn
  unsigned long max_pfn;
  unsigned long long max_possible_pfn;
  
++<<<<<<< HEAD
 +static void * __init __alloc_memory_core_early(int nid, u64 size, u64 align,
 +					u64 goal, u64 limit)
 +{
 +	void *ptr;
 +	u64 addr;
 +	enum memblock_flags flags = choose_memblock_flags();
 +
 +	if (limit > memblock.current_limit)
 +		limit = memblock.current_limit;
 +
 +again:
 +	addr = memblock_find_in_range_node(size, align, goal, limit, nid,
 +					   flags);
 +	if (!addr && (flags & MEMBLOCK_MIRROR)) {
 +		flags &= ~MEMBLOCK_MIRROR;
 +		pr_warn("Could not allocate %pap bytes of mirrored memory\n",
 +			&size);
 +		goto again;
 +	}
 +	if (!addr)
 +		return NULL;
 +
 +	if (memblock_reserve(addr, size))
 +		return NULL;
 +
 +	ptr = phys_to_virt(addr);
 +	memset(ptr, 0, size);
 +	/*
 +	 * The min_count is set to 0 so that bootmem allocated blocks
 +	 * are never reported as leaks.
 +	 */
 +	kmemleak_alloc(ptr, size, 0, 0);
 +	return ptr;
 +}
 +
 +/**
 + * free_bootmem_late - free bootmem pages directly to page allocator
 + * @addr: starting address of the range
 + * @size: size of the range in bytes
 + *
 + * This is only useful when the bootmem allocator has already been torn
 + * down, but we are still initializing the system.  Pages are given directly
 + * to the page allocator, no bootmem metadata is updated because it is gone.
 + */
 +void __init free_bootmem_late(unsigned long addr, unsigned long size)
 +{
 +	unsigned long cursor, end;
 +
 +	kmemleak_free_part_phys(addr, size);
 +
 +	cursor = PFN_UP(addr);
 +	end = PFN_DOWN(addr + size);
 +
 +	for (; cursor < end; cursor++) {
 +		__free_pages_bootmem(pfn_to_page(cursor), cursor, 0);
 +		totalram_pages++;
 +	}
 +}
 +
++=======
++>>>>>>> 53ab85ebfd27 (memblock: replace free_bootmem_late with memblock_free_late)
  static void __init __free_pages_memory(unsigned long start, unsigned long end)
  {
  	int order;
diff --git a/arch/sparc/kernel/mdesc.c b/arch/sparc/kernel/mdesc.c
index 59131e72ee78..a41526bd91e2 100644
--- a/arch/sparc/kernel/mdesc.c
+++ b/arch/sparc/kernel/mdesc.c
@@ -12,6 +12,7 @@
 #include <linux/mm.h>
 #include <linux/miscdevice.h>
 #include <linux/bootmem.h>
+#include <linux/memblock.h>
 #include <linux/export.h>
 #include <linux/refcount.h>
 
@@ -190,7 +191,7 @@ static void __init mdesc_memblock_free(struct mdesc_handle *hp)
 
 	alloc_size = PAGE_ALIGN(hp->handle_size);
 	start = __pa(hp);
-	free_bootmem_late(start, alloc_size);
+	memblock_free_late(start, alloc_size);
 }
 
 static struct mdesc_mem_ops memblock_mdesc_ops = {
diff --git a/arch/x86/platform/efi/quirks.c b/arch/x86/platform/efi/quirks.c
index 45bc961245e1..560c2d21d1a2 100644
--- a/arch/x86/platform/efi/quirks.c
+++ b/arch/x86/platform/efi/quirks.c
@@ -332,7 +332,7 @@ void __init efi_reserve_boot_services(void)
 
 		/*
 		 * Because the following memblock_reserve() is paired
-		 * with free_bootmem_late() for this region in
+		 * with memblock_free_late() for this region in
 		 * efi_free_boot_services(), we must be extremely
 		 * careful not to reserve, and subsequently free,
 		 * critical regions of memory (like the kernel image) or
@@ -363,7 +363,7 @@ void __init efi_reserve_boot_services(void)
 		 * doesn't make sense as far as the firmware is
 		 * concerned, but it does provide us with a way to tag
 		 * those regions that must not be paired with
-		 * free_bootmem_late().
+		 * memblock_free_late().
 		 */
 		md->attribute |= EFI_MEMORY_RUNTIME;
 	}
@@ -413,7 +413,7 @@ void __init efi_free_boot_services(void)
 			size -= rm_size;
 		}
 
-		free_bootmem_late(start, size);
+		memblock_free_late(start, size);
 	}
 
 	if (!num_entries)
diff --git a/drivers/firmware/efi/apple-properties.c b/drivers/firmware/efi/apple-properties.c
index 60a95719ecb8..2b675f788b61 100644
--- a/drivers/firmware/efi/apple-properties.c
+++ b/drivers/firmware/efi/apple-properties.c
@@ -235,7 +235,7 @@ static int __init map_properties(void)
 		 */
 		data->len = 0;
 		memunmap(data);
-		free_bootmem_late(pa_data + sizeof(*data), data_len);
+		memblock_free_late(pa_data + sizeof(*data), data_len);
 
 		return ret;
 	}
* Unmerged path include/linux/bootmem.h
* Unmerged path mm/nobootmem.c
