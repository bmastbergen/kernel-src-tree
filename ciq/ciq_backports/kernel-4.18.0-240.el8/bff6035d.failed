io_uring: fix missing 'return' in comment

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Chucheng Luo <luochucheng@vivo.com>
commit bff6035d0c40fa1dd195aa41f61814d622883420
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/bff6035d.failed

The missing 'return' work may make it hard for other developers to
understand it.

	Signed-off-by: Chucheng Luo <luochucheng@vivo.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit bff6035d0c40fa1dd195aa41f61814d622883420)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 7842c6de7135,487e2742a9e8..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -1435,20 -2666,34 +1435,34 @@@ static int io_write(struct io_kiocb *re
  		}
  		kiocb->ki_flags |= IOCB_WRITE;
  
 -		if (!force_nonblock)
 -			current->signal->rlim[RLIMIT_FSIZE].rlim_cur = req->fsize;
 -
 -		if (req->file->f_op->write_iter)
 -			ret2 = call_write_iter(req->file, kiocb, &iter);
 +		if (file->f_op->write_iter)
 +			ret2 = call_write_iter(file, kiocb, &iter);
  		else
++<<<<<<< HEAD
 +			ret2 = loop_rw_iter(WRITE, file, kiocb, &iter);
++=======
+ 			ret2 = loop_rw_iter(WRITE, req->file, kiocb, &iter);
+ 
+ 		if (!force_nonblock)
+ 			current->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
+ 
+ 		/*
+ 		 * Raw bdev writes will return -EOPNOTSUPP for IOCB_NOWAIT. Just
+ 		 * retry them without IOCB_NOWAIT.
+ 		 */
+ 		if (ret2 == -EOPNOTSUPP && (kiocb->ki_flags & IOCB_NOWAIT))
+ 			ret2 = -EAGAIN;
++>>>>>>> bff6035d0c40 (io_uring: fix missing 'return' in comment)
  		if (!force_nonblock || ret2 != -EAGAIN) {
 -			kiocb_done(kiocb, ret2);
 +			io_rw_done(kiocb, ret2);
  		} else {
 -copy_iov:
 -			ret = io_setup_async_rw(req, io_size, iovec,
 -						inline_vecs, &iter);
 -			if (ret)
 -				goto out_free;
 -			/* any defer here is final, must blocking retry */
 -			req->flags |= REQ_F_MUST_PUNT;
 -			return -EAGAIN;
 +			/*
 +			 * If ->needs_lock is true, we're already in async
 +			 * context.
 +			 */
 +			if (!s->needs_lock)
 +				io_async_list_note(WRITE, req, iov_count);
 +			ret = -EAGAIN;
  		}
  	}
  out_free:
* Unmerged path fs/io_uring.c
