xdp: Simplify devmap cleanup

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Björn Töpel <bjorn.topel@intel.com>
commit 0536b85239b8440735cdd910aae0eb076ebbb439
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/0536b852.failed

After the RCU flavor consolidation [1], call_rcu() and
synchronize_rcu() waits for preempt-disable regions (NAPI) in addition
to the read-side critical sections. As a result of this, the cleanup
code in devmap can be simplified

* There is no longer a need to flush in __dev_map_entry_free, since we
  know that this has been done when the call_rcu() callback is
  triggered.

* When freeing the map, there is no need to explicitly wait for a
  flush. It's guaranteed to be done after the synchronize_rcu() call
  in dev_map_free(). The rcu_barrier() is still needed, so that the
  map is not freed prior the elements.

[1] https://lwn.net/Articles/777036/

	Signed-off-by: Björn Töpel <bjorn.topel@intel.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Toke Høiland-Jørgensen <toke@redhat.com>
Link: https://lore.kernel.org/bpf/20191219061006.21980-2-bjorn.topel@gmail.com
(cherry picked from commit 0536b85239b8440735cdd910aae0eb076ebbb439)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/devmap.c
diff --cc kernel/bpf/devmap.c
index cfc445b29247,b7595de6a91a..000000000000
--- a/kernel/bpf/devmap.c
+++ b/kernel/bpf/devmap.c
@@@ -180,28 -221,37 +180,36 @@@ static void dev_map_free(struct bpf_ma
  	/* Make sure prior __dev_map_entry_free() have completed. */
  	rcu_barrier();
  
++<<<<<<< HEAD
 +	/* To ensure all pending flush operations have completed wait for flush
 +	 * list to empty on _all_ cpus.
 +	 * Because the above synchronize_rcu() ensures the map is disconnected
 +	 * from the program we can assume no new items will be added.
 +	 */
 +	for_each_online_cpu(cpu) {
 +		struct list_head *flush_list = per_cpu_ptr(dtab->flush_list, cpu);
 +
 +		while (!list_empty(flush_list))
 +			cond_resched();
 +	}
 +
 +	for (i = 0; i < dtab->map.max_entries; i++) {
 +		struct bpf_dtab_netdev *dev;
++=======
+ 	if (dtab->map.map_type == BPF_MAP_TYPE_DEVMAP_HASH) {
+ 		for (i = 0; i < dtab->n_buckets; i++) {
+ 			struct bpf_dtab_netdev *dev;
+ 			struct hlist_head *head;
+ 			struct hlist_node *next;
++>>>>>>> 0536b85239b8 (xdp: Simplify devmap cleanup)
  
 -			head = dev_map_index_hash(dtab, i);
 +		dev = dtab->netdev_map[i];
 +		if (!dev)
 +			continue;
  
 -			hlist_for_each_entry_safe(dev, next, head, index_hlist) {
 -				hlist_del_rcu(&dev->index_hlist);
 -				free_percpu(dev->bulkq);
 -				dev_put(dev->dev);
 -				kfree(dev);
 -			}
 -		}
 -
 -		kfree(dtab->dev_index_head);
 -	} else {
 -		for (i = 0; i < dtab->map.max_entries; i++) {
 -			struct bpf_dtab_netdev *dev;
 -
 -			dev = dtab->netdev_map[i];
 -			if (!dev)
 -				continue;
 -
 -			free_percpu(dev->bulkq);
 -			dev_put(dev->dev);
 -			kfree(dev);
 -		}
 -
 -		bpf_map_area_free(dtab->netdev_map);
 +		free_percpu(dev->bulkq);
 +		dev_put(dev->dev);
 +		kfree(dev);
  	}
  
  	free_percpu(dtab->flush_list);
@@@ -226,8 -275,65 +234,70 @@@ static int dev_map_get_next_key(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int bq_xmit_all(struct xdp_bulk_queue *bq, u32 flags,
 +		       bool in_napi_ctx)
++=======
+ struct bpf_dtab_netdev *__dev_map_hash_lookup_elem(struct bpf_map *map, u32 key)
+ {
+ 	struct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);
+ 	struct hlist_head *head = dev_map_index_hash(dtab, key);
+ 	struct bpf_dtab_netdev *dev;
+ 
+ 	hlist_for_each_entry_rcu(dev, head, index_hlist)
+ 		if (dev->idx == key)
+ 			return dev;
+ 
+ 	return NULL;
+ }
+ 
+ static int dev_map_hash_get_next_key(struct bpf_map *map, void *key,
+ 				    void *next_key)
+ {
+ 	struct bpf_dtab *dtab = container_of(map, struct bpf_dtab, map);
+ 	u32 idx, *next = next_key;
+ 	struct bpf_dtab_netdev *dev, *next_dev;
+ 	struct hlist_head *head;
+ 	int i = 0;
+ 
+ 	if (!key)
+ 		goto find_first;
+ 
+ 	idx = *(u32 *)key;
+ 
+ 	dev = __dev_map_hash_lookup_elem(map, idx);
+ 	if (!dev)
+ 		goto find_first;
+ 
+ 	next_dev = hlist_entry_safe(rcu_dereference_raw(hlist_next_rcu(&dev->index_hlist)),
+ 				    struct bpf_dtab_netdev, index_hlist);
+ 
+ 	if (next_dev) {
+ 		*next = next_dev->idx;
+ 		return 0;
+ 	}
+ 
+ 	i = idx & (dtab->n_buckets - 1);
+ 	i++;
+ 
+  find_first:
+ 	for (; i < dtab->n_buckets; i++) {
+ 		head = dev_map_index_hash(dtab, i);
+ 
+ 		next_dev = hlist_entry_safe(rcu_dereference_raw(hlist_first_rcu(head)),
+ 					    struct bpf_dtab_netdev,
+ 					    index_hlist);
+ 		if (next_dev) {
+ 			*next = next_dev->idx;
+ 			return 0;
+ 		}
+ 	}
+ 
+ 	return -ENOENT;
+ }
+ 
+ static int bq_xmit_all(struct xdp_bulk_queue *bq, u32 flags)
++>>>>>>> 0536b85239b8 (xdp: Simplify devmap cleanup)
  {
  	struct bpf_dtab_netdev *obj = bq->obj;
  	struct net_device *dev = obj->dev;
@@@ -381,19 -483,13 +447,29 @@@ static void *dev_map_lookup_elem(struc
  	return dev ? &dev->ifindex : NULL;
  }
  
++<<<<<<< HEAD
 +static void dev_map_flush_old(struct bpf_dtab_netdev *dev)
 +{
 +	if (dev->dev->netdev_ops->ndo_xdp_xmit) {
 +		struct xdp_bulk_queue *bq;
 +		int cpu;
 +
 +		rcu_read_lock();
 +		for_each_online_cpu(cpu) {
 +			bq = per_cpu_ptr(dev->bulkq, cpu);
 +			bq_xmit_all(bq, XDP_XMIT_FLUSH, false);
 +		}
 +		rcu_read_unlock();
 +	}
++=======
+ static void *dev_map_hash_lookup_elem(struct bpf_map *map, void *key)
+ {
+ 	struct bpf_dtab_netdev *obj = __dev_map_hash_lookup_elem(map,
+ 								*(u32 *)key);
+ 	struct net_device *dev = obj ? obj->dev : NULL;
+ 
+ 	return dev ? &dev->ifindex : NULL;
++>>>>>>> 0536b85239b8 (xdp: Simplify devmap cleanup)
  }
  
  static void __dev_map_entry_free(struct rcu_head *rcu)
* Unmerged path kernel/bpf/devmap.c
