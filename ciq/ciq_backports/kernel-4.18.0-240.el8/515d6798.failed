Bluetooth: btrtl: remove unneeded semicolon

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author YueHaibing <yuehaibing@huawei.com>
commit 515d6798fec9632fffb79261c511eb166f773273
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/515d6798.failed

Remove unneeded semicolon.
This is detected by coccinelle.

	Signed-off-by: YueHaibing <yuehaibing@huawei.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit 515d6798fec9632fffb79261c511eb166f773273)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/bluetooth/btrtl.c
diff --cc drivers/bluetooth/btrtl.c
index 8307e5845311,f838537f9f89..000000000000
--- a/drivers/bluetooth/btrtl.c
+++ b/drivers/bluetooth/btrtl.c
@@@ -526,8 -644,158 +526,139 @@@ int btrtl_setup_realtek(struct hci_dev 
  		return 0;
  	}
  }
 -EXPORT_SYMBOL_GPL(btrtl_download_firmware);
 -
 -int btrtl_setup_realtek(struct hci_dev *hdev)
 -{
 -	struct btrtl_device_info *btrtl_dev;
 -	int ret;
 -
 -	btrtl_dev = btrtl_initialize(hdev, NULL);
 -	if (IS_ERR(btrtl_dev))
 -		return PTR_ERR(btrtl_dev);
 -
 -	ret = btrtl_download_firmware(hdev, btrtl_dev);
 -
 -	btrtl_free(btrtl_dev);
 -
 -	/* Enable controller to do both LE scan and BR/EDR inquiry
 -	 * simultaneously.
 -	 */
 -	set_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);
 -
 -	return ret;
 -}
  EXPORT_SYMBOL_GPL(btrtl_setup_realtek);
  
++<<<<<<< HEAD
++=======
+ int btrtl_shutdown_realtek(struct hci_dev *hdev)
+ {
+ 	struct sk_buff *skb;
+ 	int ret;
+ 
+ 	/* According to the vendor driver, BT must be reset on close to avoid
+ 	 * firmware crash.
+ 	 */
+ 	skb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);
+ 	if (IS_ERR(skb)) {
+ 		ret = PTR_ERR(skb);
+ 		bt_dev_err(hdev, "HCI reset during shutdown failed");
+ 		return ret;
+ 	}
+ 	kfree_skb(skb);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(btrtl_shutdown_realtek);
+ 
+ static unsigned int btrtl_convert_baudrate(u32 device_baudrate)
+ {
+ 	switch (device_baudrate) {
+ 	case 0x0252a00a:
+ 		return 230400;
+ 
+ 	case 0x05f75004:
+ 		return 921600;
+ 
+ 	case 0x00005004:
+ 		return 1000000;
+ 
+ 	case 0x04928002:
+ 	case 0x01128002:
+ 		return 1500000;
+ 
+ 	case 0x00005002:
+ 		return 2000000;
+ 
+ 	case 0x0000b001:
+ 		return 2500000;
+ 
+ 	case 0x04928001:
+ 		return 3000000;
+ 
+ 	case 0x052a6001:
+ 		return 3500000;
+ 
+ 	case 0x00005001:
+ 		return 4000000;
+ 
+ 	case 0x0252c014:
+ 	default:
+ 		return 115200;
+ 	}
+ }
+ 
+ int btrtl_get_uart_settings(struct hci_dev *hdev,
+ 			    struct btrtl_device_info *btrtl_dev,
+ 			    unsigned int *controller_baudrate,
+ 			    u32 *device_baudrate, bool *flow_control)
+ {
+ 	struct rtl_vendor_config *config;
+ 	struct rtl_vendor_config_entry *entry;
+ 	int i, total_data_len;
+ 	bool found = false;
+ 
+ 	total_data_len = btrtl_dev->cfg_len - sizeof(*config);
+ 	if (total_data_len <= 0) {
+ 		rtl_dev_warn(hdev, "no config loaded");
+ 		return -EINVAL;
+ 	}
+ 
+ 	config = (struct rtl_vendor_config *)btrtl_dev->cfg_data;
+ 	if (le32_to_cpu(config->signature) != RTL_CONFIG_MAGIC) {
+ 		rtl_dev_err(hdev, "invalid config magic");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (total_data_len < le16_to_cpu(config->total_len)) {
+ 		rtl_dev_err(hdev, "config is too short");
+ 		return -EINVAL;
+ 	}
+ 
+ 	for (i = 0; i < total_data_len; ) {
+ 		entry = ((void *)config->entry) + i;
+ 
+ 		switch (le16_to_cpu(entry->offset)) {
+ 		case 0xc:
+ 			if (entry->len < sizeof(*device_baudrate)) {
+ 				rtl_dev_err(hdev, "invalid UART config entry");
+ 				return -EINVAL;
+ 			}
+ 
+ 			*device_baudrate = get_unaligned_le32(entry->data);
+ 			*controller_baudrate = btrtl_convert_baudrate(
+ 							*device_baudrate);
+ 
+ 			if (entry->len >= 13)
+ 				*flow_control = !!(entry->data[12] & BIT(2));
+ 			else
+ 				*flow_control = false;
+ 
+ 			found = true;
+ 			break;
+ 
+ 		default:
+ 			rtl_dev_dbg(hdev, "skipping config entry 0x%x (len %u)",
+ 				   le16_to_cpu(entry->offset), entry->len);
+ 			break;
+ 		}
+ 
+ 		i += sizeof(*entry) + entry->len;
+ 	}
+ 
+ 	if (!found) {
+ 		rtl_dev_err(hdev, "no UART config entry found");
+ 		return -ENOENT;
+ 	}
+ 
+ 	rtl_dev_dbg(hdev, "device baudrate = 0x%08x", *device_baudrate);
+ 	rtl_dev_dbg(hdev, "controller baudrate = %u", *controller_baudrate);
+ 	rtl_dev_dbg(hdev, "flow control %d", *flow_control);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(btrtl_get_uart_settings);
+ 
++>>>>>>> 515d6798fec9 (Bluetooth: btrtl: remove unneeded semicolon)
  MODULE_AUTHOR("Daniel Drake <drake@endlessm.com>");
  MODULE_DESCRIPTION("Bluetooth support for Realtek devices ver " VERSION);
  MODULE_VERSION(VERSION);
* Unmerged path drivers/bluetooth/btrtl.c
