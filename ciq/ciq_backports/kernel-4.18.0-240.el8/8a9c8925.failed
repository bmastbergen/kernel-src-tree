KVM: PPC: Book3S: Replace current->mm by kvm->mm

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Leonardo Bras <leonardo@linux.ibm.com>
commit 8a9c8925149f195d0bbd6b42aa3130ced0a075fb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8a9c8925.failed

Given that in kvm_create_vm() there is:
kvm->mm = current->mm;

And that on every kvm_*_ioctl we have:
if (kvm->mm != current->mm)
	return -EIO;

I see no reason to keep using current->mm instead of kvm->mm.

By doing so, we would reduce the use of 'global' variables on code, relying
more in the contents of kvm struct.

	Signed-off-by: Leonardo Bras <leonardo@linux.ibm.com>
	Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
(cherry picked from commit 8a9c8925149f195d0bbd6b42aa3130ced0a075fb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_64_mmu_hv.c
#	arch/powerpc/kvm/book3s_64_vio.c
diff --cc arch/powerpc/kvm/book3s_64_mmu_hv.c
index 8634b497fea3,6c372f5c61b6..000000000000
--- a/arch/powerpc/kvm/book3s_64_mmu_hv.c
+++ b/arch/powerpc/kvm/book3s_64_mmu_hv.c
@@@ -582,7 -570,11 +582,12 @@@ int kvmppc_book3s_hv_page_fault(struct 
  	smp_rmb();
  
  	ret = -EFAULT;
 -	is_ci = false;
 -	pfn = 0;
  	page = NULL;
++<<<<<<< HEAD
++=======
+ 	mm = kvm->mm;
+ 	pte_size = PAGE_SIZE;
++>>>>>>> 8a9c8925149f (KVM: PPC: Book3S: Replace current->mm by kvm->mm)
  	writing = (dsisr & DSISR_ISSTORE) != 0;
  	/* If writing != 0, then the HPTE must allow writing, if we get here */
  	write_ok = writing;
diff --cc arch/powerpc/kvm/book3s_64_vio.c
index 824f460b2f4f,ee6c103bb7d5..000000000000
--- a/arch/powerpc/kvm/book3s_64_vio.c
+++ b/arch/powerpc/kvm/book3s_64_vio.c
@@@ -301,10 -253,11 +301,16 @@@ static int kvm_spapr_tce_release(struc
  		}
  	}
  
+ 	account_locked_vm(kvm->mm,
+ 		kvmppc_stt_pages(kvmppc_tce_pages(stt->size)), false);
+ 
  	kvm_put_kvm(stt->kvm);
  
++<<<<<<< HEAD
 +	kvmppc_account_memlimit(
 +		kvmppc_stt_pages(kvmppc_tce_pages(stt->size)), false);
++=======
++>>>>>>> 8a9c8925149f (KVM: PPC: Book3S: Replace current->mm by kvm->mm)
  	call_rcu(&stt->rcu, release_spapr_tce_table);
  
  	return 0;
@@@ -328,7 -282,7 +335,11 @@@ long kvm_vm_ioctl_create_spapr_tce(stru
  		return -EINVAL;
  
  	npages = kvmppc_tce_pages(size);
++<<<<<<< HEAD
 +	ret = kvmppc_account_memlimit(kvmppc_stt_pages(npages), true);
++=======
+ 	ret = account_locked_vm(mm, kvmppc_stt_pages(npages), true);
++>>>>>>> 8a9c8925149f (KVM: PPC: Book3S: Replace current->mm by kvm->mm)
  	if (ret)
  		return ret;
  
@@@ -374,7 -328,7 +385,11 @@@
  
  	kfree(stt);
   fail_acct:
++<<<<<<< HEAD
 +	kvmppc_account_memlimit(kvmppc_stt_pages(npages), false);
++=======
+ 	account_locked_vm(mm, kvmppc_stt_pages(npages), false);
++>>>>>>> 8a9c8925149f (KVM: PPC: Book3S: Replace current->mm by kvm->mm)
  	return ret;
  }
  
* Unmerged path arch/powerpc/kvm/book3s_64_mmu_hv.c
* Unmerged path arch/powerpc/kvm/book3s_64_vio.c
diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c
index 46a62698fcb1..4bbbbeb0cac3 100644
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@ -4251,7 +4251,7 @@ static int kvmppc_vcpu_run_hv(struct kvm_run *run, struct kvm_vcpu *vcpu)
 	user_vrsave = mfspr(SPRN_VRSAVE);
 
 	vcpu->arch.wqp = &vcpu->arch.vcore->wq;
-	vcpu->arch.pgdir = current->mm->pgd;
+	vcpu->arch.pgdir = kvm->mm->pgd;
 	vcpu->arch.state = KVMPPC_VCPU_BUSY_IN_HOST;
 
 	do {
@@ -4580,14 +4580,14 @@ static int kvmppc_hv_setup_htab_rma(struct kvm_vcpu *vcpu)
 
 	/* Look up the VMA for the start of this memory slot */
 	hva = memslot->userspace_addr;
-	down_read(&current->mm->mmap_sem);
-	vma = find_vma(current->mm, hva);
+	down_read(&kvm->mm->mmap_sem);
+	vma = find_vma(kvm->mm, hva);
 	if (!vma || vma->vm_start > hva || (vma->vm_flags & VM_IO))
 		goto up_out;
 
 	psize = vma_kernel_pagesize(vma);
 
-	up_read(&current->mm->mmap_sem);
+	up_read(&kvm->mm->mmap_sem);
 
 	/* We can handle 4k, 64k or 16M pages in the VRMA */
 	if (psize >= 0x1000000)
@@ -4620,7 +4620,7 @@ static int kvmppc_hv_setup_htab_rma(struct kvm_vcpu *vcpu)
 	return err;
 
  up_out:
-	up_read(&current->mm->mmap_sem);
+	up_read(&kvm->mm->mmap_sem);
 	goto out_srcu;
 }
 
