s390/crypto: enable clear key values for paes ciphers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Harald Freudenberger <freude@linux.ibm.com>
commit 7f820d053948ca82bd8221b1df3d676b9c93a494
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7f820d05.failed

With this patch the paes ciphers do accept AES clear key values of
size 16, 24 or 32 byte. The key value is internal rearranged to form a
paes clear key token so that the pkey kernel module recognizes and
handles this key material as source for protected keys.

Using clear key material as a source for protected keys is a security
risc as the raw key material is kept in memory. However, so the AES
selftests provided with the testmanager can be run during registration
of the paes ciphers.

	Signed-off-by: Harald Freudenberger <freude@linux.ibm.com>
	Signed-off-by: Vasily Gorbik <gor@linux.ibm.com>
(cherry picked from commit 7f820d053948ca82bd8221b1df3d676b9c93a494)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/crypto/paes_s390.c
diff --cc arch/s390/crypto/paes_s390.c
index 6184dceed340,bb9aa86ad4bd..000000000000
--- a/arch/s390/crypto/paes_s390.c
+++ b/arch/s390/crypto/paes_s390.c
@@@ -143,10 -189,10 +170,10 @@@ static int ecb_paes_set_key(struct cryp
  			    unsigned int key_len)
  {
  	int rc;
 -	struct s390_paes_ctx *ctx = crypto_skcipher_ctx(tfm);
 +	struct s390_paes_ctx *ctx = crypto_tfm_ctx(tfm);
  
  	_free_kb_keybuf(&ctx->kb);
- 	rc = _copy_key_to_kb(&ctx->kb, in_key, key_len);
+ 	rc = _key_to_kb(&ctx->kb, in_key, key_len);
  	if (rc)
  		return rc;
  
@@@ -262,10 -302,10 +289,10 @@@ static int cbc_paes_set_key(struct cryp
  			    unsigned int key_len)
  {
  	int rc;
 -	struct s390_paes_ctx *ctx = crypto_skcipher_ctx(tfm);
 +	struct s390_paes_ctx *ctx = crypto_tfm_ctx(tfm);
  
  	_free_kb_keybuf(&ctx->kb);
- 	rc = _copy_key_to_kb(&ctx->kb, in_key, key_len);
+ 	rc = _key_to_kb(&ctx->kb, in_key, key_len);
  	if (rc)
  		return rc;
  
@@@ -559,10 -598,10 +586,10 @@@ static int ctr_paes_set_key(struct cryp
  			    unsigned int key_len)
  {
  	int rc;
 -	struct s390_paes_ctx *ctx = crypto_skcipher_ctx(tfm);
 +	struct s390_paes_ctx *ctx = crypto_tfm_ctx(tfm);
  
  	_free_kb_keybuf(&ctx->kb);
- 	rc = _copy_key_to_kb(&ctx->kb, in_key, key_len);
+ 	rc = _key_to_kb(&ctx->kb, in_key, key_len);
  	if (rc)
  		return rc;
  
@@@ -697,12 -722,12 +724,21 @@@ static inline void __crypto_unregister_
  
  static void paes_s390_fini(void)
  {
++<<<<<<< HEAD
 +	if (ctrblk)
 +		free_page((unsigned long) ctrblk);
 +	__crypto_unregister_alg(&ctr_paes_alg);
 +	__crypto_unregister_alg(&xts_paes_alg);
 +	__crypto_unregister_alg(&cbc_paes_alg);
 +	__crypto_unregister_alg(&ecb_paes_alg);
++=======
+ 	__crypto_unregister_skcipher(&ctr_paes_alg);
+ 	__crypto_unregister_skcipher(&xts_paes_alg);
+ 	__crypto_unregister_skcipher(&cbc_paes_alg);
+ 	__crypto_unregister_skcipher(&ecb_paes_alg);
+ 	if (ctrblk)
+ 		free_page((unsigned long) ctrblk);
++>>>>>>> 7f820d053948 (s390/crypto: enable clear key values for paes ciphers)
  }
  
  static int __init paes_s390_init(void)
@@@ -740,9 -765,6 +776,12 @@@
  	if (cpacf_test_func(&kmctr_functions, CPACF_KMCTR_PAES_128) ||
  	    cpacf_test_func(&kmctr_functions, CPACF_KMCTR_PAES_192) ||
  	    cpacf_test_func(&kmctr_functions, CPACF_KMCTR_PAES_256)) {
++<<<<<<< HEAD
 +		ret = crypto_register_alg(&ctr_paes_alg);
 +		if (ret)
 +			goto out_err;
++=======
++>>>>>>> 7f820d053948 (s390/crypto: enable clear key values for paes ciphers)
  		ctrblk = (u8 *) __get_free_page(GFP_KERNEL);
  		if (!ctrblk) {
  			ret = -ENOMEM;
* Unmerged path arch/s390/crypto/paes_s390.c
