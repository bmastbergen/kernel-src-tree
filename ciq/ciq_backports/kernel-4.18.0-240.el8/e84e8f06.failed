block: add req op to reset all zones and flag

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
commit e84e8f0663956f45c747df5629046794cff93893
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/e84e8f06.failed

This patch introduces a new request operation REQ_OP_ZONE_RESET_ALL.
This is useful for the applications like mkfs where it needs to reset
all the zones present on the underlying block device. As part for this
patch we also introduce new QUEUE_FLAG_ZONE_RESETALL which indicates the
queue zone reset all capability and corresponding helper macro.

	Reviewed-by: Damien Le Moal <damien.lemoal@wdc.com>
	Reviewed-by: Hannes Reinecke <hare@suse.com>
	Signed-off-by: Chaitanya Kulkarni <chaitanya.kulkarni@wdc.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit e84e8f0663956f45c747df5629046794cff93893)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/blkdev.h
diff --cc include/linux/blkdev.h
index bd38adaa12b3,167bf879f072..000000000000
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@@ -588,54 -584,34 +588,83 @@@ struct request_queue 
  
  #define BLK_MAX_WRITE_HINTS	5
  	u64			write_hints[BLK_MAX_WRITE_HINTS];
 +
 +	/*
 +	 * for reusing dead hctx instance in case of updating
 +	 * nr_hw_queues
 +	 */
 +	RH_KABI_EXTEND(struct list_head	unused_hctx_list)
 +	RH_KABI_EXTEND(spinlock_t	unused_hctx_lock)
 +	/*
 +	 * Protect concurrent access to q_usage_counter by
 +	 * percpu_ref_kill() and percpu_ref_reinit().
 +	 */
 +	RH_KABI_EXTEND(struct mutex		mq_freeze_lock)
 +
 +	RH_KABI_EXTEND(struct mutex		sysfs_dir_lock)
  };
  
++<<<<<<< HEAD
 +#define QUEUE_FLAG_STOPPED	1	/* queue is stopped */
 +#define QUEUE_FLAG_DYING	2	/* queue being torn down */
 +#define QUEUE_FLAG_BIDI		4	/* queue supports bidi requests */
 +#define QUEUE_FLAG_NOMERGES     5	/* disable merge attempts */
 +#define QUEUE_FLAG_SAME_COMP	6	/* complete on same CPU-group */
 +#define QUEUE_FLAG_FAIL_IO	7	/* fake timeout */
 +#define QUEUE_FLAG_UNPRIV_SGIO  8	/* SG_IO free for unprivileged users */
 +#define QUEUE_FLAG_NONROT	9	/* non-rotational device (SSD) */
 +#define QUEUE_FLAG_VIRT        QUEUE_FLAG_NONROT /* paravirt device */
 +#define QUEUE_FLAG_IO_STAT     10	/* do IO stats */
 +#define QUEUE_FLAG_DISCARD     11	/* supports DISCARD */
 +#define QUEUE_FLAG_NOXMERGES   12	/* No extended merges */
 +#define QUEUE_FLAG_ADD_RANDOM  13	/* Contributes to random pool */
 +#define QUEUE_FLAG_SECERASE    14	/* supports secure erase */
 +#define QUEUE_FLAG_SAME_FORCE  15	/* force complete on same CPU */
 +#define QUEUE_FLAG_DEAD        16	/* queue tear-down finished */
 +#define QUEUE_FLAG_INIT_DONE   17	/* queue is initialized */
 +#define QUEUE_FLAG_NO_SG_MERGE 18	/* don't attempt to merge SG segments (obsolete) */
 +#define QUEUE_FLAG_POLL	       19	/* IO polling enabled if set */
 +#define QUEUE_FLAG_WC	       20	/* Write back caching */
 +#define QUEUE_FLAG_FUA	       21	/* device supports FUA writes */
 +#define QUEUE_FLAG_DAX         23	/* device supports DAX */
 +#define QUEUE_FLAG_STATS       24	/* track rq completion times */
 +#define QUEUE_FLAG_POLL_STATS  25	/* collecting stats for hybrid polling */
 +#define QUEUE_FLAG_REGISTERED  26	/* queue has been registered to a disk */
 +#define QUEUE_FLAG_SCSI_PASSTHROUGH 27	/* queue supports SCSI commands */
 +#define QUEUE_FLAG_QUIESCED    28	/* queue has been quiesced */
 +#define QUEUE_FLAG_PCI_P2PDMA  29	/* device supports PCI p2p requests */
 +
 +#define QUEUE_FLAG_DEFAULT	((1 << QUEUE_FLAG_IO_STAT) |		\
 +				 (1 << QUEUE_FLAG_SAME_COMP)	|	\
 +				 (1 << QUEUE_FLAG_ADD_RANDOM))
++=======
+ #define QUEUE_FLAG_STOPPED	0	/* queue is stopped */
+ #define QUEUE_FLAG_DYING	1	/* queue being torn down */
+ #define QUEUE_FLAG_NOMERGES     3	/* disable merge attempts */
+ #define QUEUE_FLAG_SAME_COMP	4	/* complete on same CPU-group */
+ #define QUEUE_FLAG_FAIL_IO	5	/* fake timeout */
+ #define QUEUE_FLAG_NONROT	6	/* non-rotational device (SSD) */
+ #define QUEUE_FLAG_VIRT		QUEUE_FLAG_NONROT /* paravirt device */
+ #define QUEUE_FLAG_IO_STAT	7	/* do disk/partitions IO accounting */
+ #define QUEUE_FLAG_DISCARD	8	/* supports DISCARD */
+ #define QUEUE_FLAG_NOXMERGES	9	/* No extended merges */
+ #define QUEUE_FLAG_ADD_RANDOM	10	/* Contributes to random pool */
+ #define QUEUE_FLAG_SECERASE	11	/* supports secure erase */
+ #define QUEUE_FLAG_SAME_FORCE	12	/* force complete on same CPU */
+ #define QUEUE_FLAG_DEAD		13	/* queue tear-down finished */
+ #define QUEUE_FLAG_INIT_DONE	14	/* queue is initialized */
+ #define QUEUE_FLAG_POLL		16	/* IO polling enabled if set */
+ #define QUEUE_FLAG_WC		17	/* Write back caching */
+ #define QUEUE_FLAG_FUA		18	/* device supports FUA writes */
+ #define QUEUE_FLAG_DAX		19	/* device supports DAX */
+ #define QUEUE_FLAG_STATS	20	/* track IO start and completion times */
+ #define QUEUE_FLAG_POLL_STATS	21	/* collecting stats for hybrid polling */
+ #define QUEUE_FLAG_REGISTERED	22	/* queue has been registered to a disk */
+ #define QUEUE_FLAG_SCSI_PASSTHROUGH 23	/* queue supports SCSI commands */
+ #define QUEUE_FLAG_QUIESCED	24	/* queue has been quiesced */
+ #define QUEUE_FLAG_PCI_P2PDMA	25	/* device supports PCI p2p requests */
+ #define QUEUE_FLAG_ZONE_RESETALL 26	/* supports Zone Reset All */
++>>>>>>> e84e8f066395 (block: add req op to reset all zones and flag)
  
  #define QUEUE_FLAG_MQ_DEFAULT	((1 << QUEUE_FLAG_IO_STAT) |		\
  				 (1 << QUEUE_FLAG_SAME_COMP))
diff --git a/include/linux/blk_types.h b/include/linux/blk_types.h
index fc5ea6dee087..1fc1507fc99a 100644
--- a/include/linux/blk_types.h
+++ b/include/linux/blk_types.h
@@ -296,6 +296,8 @@ enum req_opf {
 	REQ_OP_ZONE_RESET	= 6,
 	/* write the same sector many times */
 	REQ_OP_WRITE_SAME	= 7,
+	/* reset all the zone present on the device */
+	REQ_OP_ZONE_RESET_ALL	= 8,
 	/* write the zero filled sector many times */
 	REQ_OP_WRITE_ZEROES	= 9,
 
* Unmerged path include/linux/blkdev.h
