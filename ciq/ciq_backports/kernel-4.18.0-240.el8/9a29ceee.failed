perf maps: Rename 'mg' variables to 'maps'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 9a29ceee6bb14aeb58ab2222c8e792576fe90fb8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/9a29ceee.failed

Continuing the merge of 'struct maps' with 'struct map_groups'.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Andi Kleen <ak@linux.intel.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
Link: https://lkml.kernel.org/n/tip-z8d14wrw393a0fbvmnk1bqd9@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 9a29ceee6bb14aeb58ab2222c8e792576fe90fb8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/tests/map_groups.c
#	tools/perf/tests/thread-mg-share.c
#	tools/perf/util/event.c
#	tools/perf/util/machine.c
#	tools/perf/util/map.c
#	tools/perf/util/map_groups.h
#	tools/perf/util/symbol.c
#	tools/perf/util/symbol.h
#	tools/perf/util/unwind-libunwind-local.c
#	tools/perf/util/unwind-libunwind.c
diff --cc tools/perf/tests/map_groups.c
index b52adad55f8d,9df1d14db40e..000000000000
--- a/tools/perf/tests/map_groups.c
+++ b/tools/perf/tests/map_groups.c
@@@ -35,7 -35,7 +35,11 @@@ static int check_maps(struct map_def *m
  
  int test__map_groups__merge_in(struct test *t __maybe_unused, int subtest __maybe_unused)
  {
++<<<<<<< HEAD
 +	struct map_groups mg;
++=======
+ 	struct maps maps;
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  	unsigned int i;
  	struct map_def bpf_progs[] = {
  		{ "bpf_prog_1", 200, 300 },
@@@ -64,7 -64,7 +68,11 @@@
  	struct map *map_kcore1, *map_kcore2, *map_kcore3;
  	int ret;
  
++<<<<<<< HEAD
 +	map_groups__init(&mg, NULL);
++=======
+ 	maps__init(&maps, NULL);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  
  	for (i = 0; i < ARRAY_SIZE(bpf_progs); i++) {
  		struct map *map;
@@@ -74,7 -74,7 +82,11 @@@
  
  		map->start = bpf_progs[i].start;
  		map->end   = bpf_progs[i].end;
++<<<<<<< HEAD
 +		map_groups__insert(&mg, map);
++=======
+ 		maps__insert(&maps, map);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  		map__put(map);
  	}
  
@@@ -99,22 -99,22 +111,34 @@@
  	map_kcore3->start = 880;
  	map_kcore3->end   = 1100;
  
++<<<<<<< HEAD
 +	ret = map_groups__merge_in(&mg, map_kcore1);
++=======
+ 	ret = maps__merge_in(&maps, map_kcore1);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  	TEST_ASSERT_VAL("failed to merge map", !ret);
  
- 	ret = check_maps(merged12, ARRAY_SIZE(merged12), &mg);
+ 	ret = check_maps(merged12, ARRAY_SIZE(merged12), &maps);
  	TEST_ASSERT_VAL("merge check failed", !ret);
  
++<<<<<<< HEAD
 +	ret = map_groups__merge_in(&mg, map_kcore2);
++=======
+ 	ret = maps__merge_in(&maps, map_kcore2);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  	TEST_ASSERT_VAL("failed to merge map", !ret);
  
- 	ret = check_maps(merged12, ARRAY_SIZE(merged12), &mg);
+ 	ret = check_maps(merged12, ARRAY_SIZE(merged12), &maps);
  	TEST_ASSERT_VAL("merge check failed", !ret);
  
++<<<<<<< HEAD
 +	ret = map_groups__merge_in(&mg, map_kcore3);
++=======
+ 	ret = maps__merge_in(&maps, map_kcore3);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  	TEST_ASSERT_VAL("failed to merge map", !ret);
  
- 	ret = check_maps(merged3, ARRAY_SIZE(merged3), &mg);
+ 	ret = check_maps(merged3, ARRAY_SIZE(merged3), &maps);
  	TEST_ASSERT_VAL("merge check failed", !ret);
  	return TEST_OK;
  }
diff --cc tools/perf/tests/thread-mg-share.c
index cbac71716dec,e3b0d692d565..000000000000
--- a/tools/perf/tests/thread-mg-share.c
+++ b/tools/perf/tests/thread-mg-share.c
@@@ -12,7 -12,7 +12,11 @@@ int test__thread_mg_share(struct test *
  	/* thread group */
  	struct thread *leader;
  	struct thread *t1, *t2, *t3;
++<<<<<<< HEAD
 +	struct map_groups *mg;
++=======
+ 	struct maps *maps;
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  
  	/* other process */
  	struct thread *other, *other_leader;
@@@ -42,13 -42,13 +46,23 @@@
  	TEST_ASSERT_VAL("failed to create threads",
  			leader && t1 && t2 && t3 && other);
  
++<<<<<<< HEAD
 +	mg = leader->mg;
 +	TEST_ASSERT_EQUAL("wrong refcnt", refcount_read(&mg->refcnt), 4);
 +
 +	/* test the map groups pointer is shared */
 +	TEST_ASSERT_VAL("map groups don't match", mg == t1->mg);
 +	TEST_ASSERT_VAL("map groups don't match", mg == t2->mg);
 +	TEST_ASSERT_VAL("map groups don't match", mg == t3->mg);
++=======
+ 	maps = leader->maps;
+ 	TEST_ASSERT_EQUAL("wrong refcnt", refcount_read(&maps->refcnt), 4);
+ 
+ 	/* test the map groups pointer is shared */
+ 	TEST_ASSERT_VAL("map groups don't match", maps == t1->maps);
+ 	TEST_ASSERT_VAL("map groups don't match", maps == t2->maps);
+ 	TEST_ASSERT_VAL("map groups don't match", maps == t3->maps);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  
  	/*
  	 * Verify the other leader was created by previous call.
diff --cc tools/perf/util/event.c
index 8a8363d72082,c5447ff516a2..000000000000
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@@ -1557,11 -457,11 +1557,19 @@@ int perf_event__process(struct perf_too
  struct map *thread__find_map(struct thread *thread, u8 cpumode, u64 addr,
  			     struct addr_location *al)
  {
++<<<<<<< HEAD
 +	struct map_groups *mg = thread->mg;
 +	struct machine *machine = mg->machine;
 +	bool load_map = false;
 +
 +	al->mg = mg;
++=======
+ 	struct maps *maps = thread->maps;
+ 	struct machine *machine = maps->machine;
+ 	bool load_map = false;
+ 
+ 	al->maps = maps;
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  	al->thread = thread;
  	al->addr = addr;
  	al->cpumode = cpumode;
@@@ -1574,13 -474,13 +1582,21 @@@
  
  	if (cpumode == PERF_RECORD_MISC_KERNEL && perf_host) {
  		al->level = 'k';
++<<<<<<< HEAD
 +		al->mg = mg = &machine->kmaps;
++=======
+ 		al->maps = maps = &machine->kmaps;
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  		load_map = true;
  	} else if (cpumode == PERF_RECORD_MISC_USER && perf_host) {
  		al->level = '.';
  	} else if (cpumode == PERF_RECORD_MISC_GUEST_KERNEL && perf_guest) {
  		al->level = 'g';
++<<<<<<< HEAD
 +		al->mg = mg = &machine->kmaps;
++=======
+ 		al->maps = maps = &machine->kmaps;
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  		load_map = true;
  	} else if (cpumode == PERF_RECORD_MISC_GUEST_USER && perf_guest) {
  		al->level = 'u';
@@@ -1600,7 -500,7 +1616,11 @@@
  		return NULL;
  	}
  
++<<<<<<< HEAD
 +	al->map = map_groups__find(mg, al->addr);
++=======
+ 	al->map = maps__find(maps, al->addr);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  	if (al->map != NULL) {
  		/*
  		 * Kernel maps might be changed when loading symbols so loading
diff --cc tools/perf/util/machine.c
index 97b56c40a5df,416d174d223c..000000000000
--- a/tools/perf/util/machine.c
+++ b/tools/perf/util/machine.c
@@@ -1253,11 -1259,10 +1253,18 @@@ static bool is_kmod_dso(struct dso *dso
  	       dso->symtab_type == DSO_BINARY_TYPE__GUEST_KMODULE;
  }
  
++<<<<<<< HEAD
 +static int map_groups__set_module_path(struct map_groups *mg, const char *path,
 +				       struct kmod_path *m)
 +{
 +	char *long_name;
 +	struct map *map = map_groups__find_by_name(mg, m->name);
++=======
+ static int maps__set_module_path(struct maps *maps, const char *path, struct kmod_path *m)
+ {
+ 	char *long_name;
+ 	struct map *map = maps__find_by_name(maps, m->name);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  
  	if (map == NULL)
  		return 0;
@@@ -1281,8 -1286,7 +1288,12 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int map_groups__set_modules_path_dir(struct map_groups *mg,
 +				const char *dir_name, int depth)
++=======
+ static int maps__set_modules_path_dir(struct maps *maps, const char *dir_name, int depth)
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  {
  	struct dirent *dent;
  	DIR *dir = opendir(dir_name);
@@@ -1314,8 -1318,7 +1325,12 @@@
  					continue;
  			}
  
++<<<<<<< HEAD
 +			ret = map_groups__set_modules_path_dir(mg, path,
 +							       depth + 1);
++=======
+ 			ret = maps__set_modules_path_dir(maps, path, depth + 1);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  			if (ret < 0)
  				goto out;
  		} else {
@@@ -1326,7 -1329,7 +1341,11 @@@
  				goto out;
  
  			if (m.kmod)
++<<<<<<< HEAD
 +				ret = map_groups__set_module_path(mg, path, &m);
++=======
+ 				ret = maps__set_module_path(maps, path, &m);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  
  			zfree(&m.name);
  
diff --cc tools/perf/util/map.c
index be8418d003b5,fdd5bddb3075..000000000000
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@@ -516,23 -512,72 +516,92 @@@ u64 map__objdump_2mem(struct map *map, 
  	return ip + map->reloc;
  }
  
++<<<<<<< HEAD
 +static void maps__init(struct maps *maps)
 +{
 +	maps->entries = RB_ROOT;
 +	maps->names = RB_ROOT;
 +	init_rwsem(&maps->lock);
 +}
 +
 +void map_groups__init(struct map_groups *mg, struct machine *machine)
 +{
 +	maps__init(&mg->maps);
 +	mg->machine = machine;
 +	refcount_set(&mg->refcnt, 1);
 +}
 +
 +void map_groups__insert(struct map_groups *mg, struct map *map)
 +{
 +	maps__insert(&mg->maps, map);
++=======
+ void maps__init(struct maps *maps, struct machine *machine)
+ {
+ 	maps->entries = RB_ROOT;
+ 	init_rwsem(&maps->lock);
+ 	maps->machine = machine;
+ 	maps->last_search_by_name = NULL;
+ 	maps->nr_maps = 0;
+ 	maps->maps_by_name = NULL;
+ 	refcount_set(&maps->refcnt, 1);
+ }
+ 
+ static void __maps__free_maps_by_name(struct maps *maps)
+ {
+ 	/*
+ 	 * Free everything to try to do it from the rbtree in the next search
+ 	 */
+ 	zfree(&maps->maps_by_name);
+ 	maps->nr_maps_allocated = 0;
+ }
+ 
+ void maps__insert(struct maps *maps, struct map *map)
+ {
+ 	down_write(&maps->lock);
+ 	__maps__insert(maps, map);
+ 	++maps->nr_maps;
+ 
+ 	/*
+ 	 * If we already performed some search by name, then we need to add the just
+ 	 * inserted map and resort.
+ 	 */
+ 	if (maps->maps_by_name) {
+ 		if (maps->nr_maps > maps->nr_maps_allocated) {
+ 			int nr_allocate = maps->nr_maps * 2;
+ 			struct map **maps_by_name = realloc(maps->maps_by_name, nr_allocate * sizeof(map));
+ 
+ 			if (maps_by_name == NULL) {
+ 				__maps__free_maps_by_name(maps);
+ 				return;
+ 			}
+ 
+ 			maps->maps_by_name = maps_by_name;
+ 			maps->nr_maps_allocated = nr_allocate;
+ 		}
+ 		maps->maps_by_name[maps->nr_maps - 1] = map;
+ 		__maps__sort_by_name(maps);
+ 	}
+ 	up_write(&maps->lock);
+ }
+ 
+ static void __maps__remove(struct maps *maps, struct map *map)
+ {
+ 	rb_erase_init(&map->rb_node, &maps->entries);
+ 	map__put(map);
+ }
+ 
+ void maps__remove(struct maps *maps, struct map *map)
+ {
+ 	down_write(&maps->lock);
+ 	if (maps->last_search_by_name == map)
+ 		maps->last_search_by_name = NULL;
+ 
+ 	__maps__remove(maps, map);
+ 	--maps->nr_maps;
+ 	if (maps->maps_by_name)
+ 		__maps__free_maps_by_name(maps);
+ 	up_write(&maps->lock);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  }
  
  static void __maps__purge(struct maps *maps)
@@@ -571,43 -597,37 +640,69 @@@ static void maps__exit(struct maps *map
  	up_write(&maps->lock);
  }
  
 -bool maps__empty(struct maps *maps)
 +void map_groups__exit(struct map_groups *mg)
 +{
 +	maps__exit(&mg->maps);
 +}
 +
 +bool map_groups__empty(struct map_groups *mg)
  {
 -	return !maps__first(maps);
++<<<<<<< HEAD
 +	return !maps__first(&mg->maps);
  }
  
 -struct maps *maps__new(struct machine *machine)
 +struct map_groups *map_groups__new(struct machine *machine)
  {
 +	struct map_groups *mg = zalloc(sizeof(*mg));
 +
 +	if (mg != NULL)
 +		map_groups__init(mg, machine);
++=======
+ 	struct maps *maps = zalloc(sizeof(*maps));
+ 
+ 	if (maps != NULL)
+ 		maps__init(maps, machine);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  
- 	return mg;
+ 	return maps;
  }
  
++<<<<<<< HEAD
 +void map_groups__delete(struct map_groups *mg)
 +{
 +	map_groups__exit(mg);
 +	unwind__finish_access(mg);
 +	free(mg);
 +}
 +
 +void map_groups__put(struct map_groups *mg)
 +{
 +	if (mg && refcount_dec_and_test(&mg->refcnt))
 +		map_groups__delete(mg);
 +}
 +
 +struct symbol *map_groups__find_symbol(struct map_groups *mg,
 +				       u64 addr, struct map **mapp)
 +{
 +	struct map *map = map_groups__find(mg, addr);
++=======
+ void maps__delete(struct maps *maps)
+ {
+ 	maps__exit(maps);
+ 	unwind__finish_access(maps);
+ 	free(maps);
+ }
+ 
+ void maps__put(struct maps *maps)
+ {
+ 	if (maps && refcount_dec_and_test(&maps->refcnt))
+ 		maps__delete(maps);
+ }
+ 
+ struct symbol *maps__find_symbol(struct maps *maps, u64 addr, struct map **mapp)
+ {
+ 	struct map *map = maps__find(maps, addr);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  
  	/* Ensure map is loaded before using map->map_ip */
  	if (map != NULL && map__load(map) >= 0) {
@@@ -656,20 -673,13 +751,30 @@@ out
  	return sym;
  }
  
++<<<<<<< HEAD
 +struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg,
 +					       const char *name,
 +					       struct map **mapp)
 +{
 +	return maps__find_symbol_by_name(&mg->maps, name, mapp);
 +}
 +
 +int map_groups__find_ams(struct map_groups *mg, struct addr_map_symbol *ams)
 +{
 +	if (ams->addr < ams->map->start || ams->addr >= ams->map->end) {
 +		if (mg == NULL)
 +			return -1;
 +		ams->map = map_groups__find(mg, ams->addr);
 +		if (ams->map == NULL)
++=======
+ int maps__find_ams(struct maps *maps, struct addr_map_symbol *ams)
+ {
+ 	if (ams->addr < ams->ms.map->start || ams->addr >= ams->ms.map->end) {
+ 		if (maps == NULL)
+ 			return -1;
+ 		ams->ms.map = maps__find(maps, ams->addr);
+ 		if (ams->ms.map == NULL)
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  			return -1;
  	}
  
@@@ -817,16 -814,15 +922,20 @@@ out
  /*
   * XXX This should not really _copy_ te maps, but refcount them.
   */
 -int maps__clone(struct thread *thread, struct maps *parent)
 +int map_groups__clone(struct thread *thread, struct map_groups *parent)
  {
++<<<<<<< HEAD
 +	struct map_groups *mg = thread->mg;
++=======
+ 	struct maps *maps = thread->maps;
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  	int err = -ENOMEM;
  	struct map *map;
 +	struct maps *maps = &parent->maps;
  
 -	down_read(&parent->lock);
 +	down_read(&maps->lock);
  
 -	maps__for_each_entry(parent, map) {
 +	for (map = maps__first(maps); map; map = map__next(map)) {
  		struct map *new = map__clone(map);
  		if (new == NULL)
  			goto out_unlock;
@@@ -835,7 -831,7 +944,11 @@@
  		if (err)
  			goto out_unlock;
  
++<<<<<<< HEAD
 +		map_groups__insert(mg, new);
++=======
+ 		maps__insert(maps, new);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  		map__put(new);
  	}
  
diff --cc tools/perf/util/map_groups.h
index 1876388e8dd8,ada2f401ebab..000000000000
--- a/tools/perf/util/map_groups.h
+++ b/tools/perf/util/map_groups.h
@@@ -45,52 -48,40 +45,87 @@@ struct kmap 
  	char		     name[KMAP_NAME_LEN];
  };
  
++<<<<<<< HEAD
 +struct map_groups *map_groups__new(struct machine *machine);
 +void map_groups__delete(struct map_groups *mg);
 +bool map_groups__empty(struct map_groups *mg);
 +
 +static inline struct map_groups *map_groups__get(struct map_groups *mg)
++=======
+ struct maps *maps__new(struct machine *machine);
+ void maps__delete(struct maps *maps);
+ bool maps__empty(struct maps *maps);
+ 
+ static inline struct maps *maps__get(struct maps *maps)
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  {
- 	if (mg)
- 		refcount_inc(&mg->refcnt);
- 	return mg;
+ 	if (maps)
+ 		refcount_inc(&maps->refcnt);
+ 	return maps;
  }
  
++<<<<<<< HEAD
 +void map_groups__put(struct map_groups *mg);
 +void map_groups__init(struct map_groups *mg, struct machine *machine);
 +void map_groups__exit(struct map_groups *mg);
 +int map_groups__clone(struct thread *thread, struct map_groups *parent);
 +size_t map_groups__fprintf(struct map_groups *mg, FILE *fp);
 +
 +void map_groups__insert(struct map_groups *mg, struct map *map);
 +
 +static inline void map_groups__remove(struct map_groups *mg, struct map *map)
 +{
 +	maps__remove(&mg->maps, map);
 +}
 +
 +static inline struct map *map_groups__find(struct map_groups *mg, u64 addr)
 +{
 +	return maps__find(&mg->maps, addr);
 +}
 +
 +#define map_groups__for_each_entry(mg, map) \
 +	for (map = maps__first(&mg->maps); map; map = map__next(map))
 +
 +#define map_groups__for_each_entry_safe(mg, map, next) \
 +	for (map = maps__first(&mg->maps), next = map__next(map); map; map = next, next = map__next(map))
 +
 +struct symbol *map_groups__find_symbol(struct map_groups *mg, u64 addr, struct map **mapp);
 +struct symbol *map_groups__find_symbol_by_name(struct map_groups *mg, const char *name, struct map **mapp);
 +
 +struct addr_map_symbol;
 +
 +int map_groups__find_ams(struct map_groups *mg, struct addr_map_symbol *ams);
 +
 +int map_groups__fixup_overlappings(struct map_groups *mg, struct map *map, FILE *fp);
 +
 +struct map *map_groups__find_by_name(struct map_groups *mg, const char *name);
 +
 +int map_groups__merge_in(struct map_groups *kmaps, struct map *new_map);
++=======
+ void maps__put(struct maps *maps);
+ void maps__init(struct maps *maps, struct machine *machine);
+ void maps__exit(struct maps *maps);
+ int maps__clone(struct thread *thread, struct maps *parent);
+ size_t maps__fprintf(struct maps *maps, FILE *fp);
+ 
+ void maps__insert(struct maps *maps, struct map *map);
+ 
+ void maps__remove(struct maps *maps, struct map *map);
+ 
+ struct symbol *maps__find_symbol(struct maps *maps, u64 addr, struct map **mapp);
+ struct symbol *maps__find_symbol_by_name(struct maps *maps, const char *name, struct map **mapp);
+ 
+ struct addr_map_symbol;
+ 
+ int maps__find_ams(struct maps *maps, struct addr_map_symbol *ams);
+ 
+ int maps__fixup_overlappings(struct maps *maps, struct map *map, FILE *fp);
+ 
+ struct map *maps__find_by_name(struct maps *maps, const char *name);
+ 
+ int maps__merge_in(struct maps *kmaps, struct map *new_map);
+ 
+ void __maps__sort_by_name(struct maps *maps);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  
  #endif // __PERF_MAP_GROUPS_H
diff --cc tools/perf/util/symbol.c
index 7642451537f8,3b379b1296f1..000000000000
--- a/tools/perf/util/symbol.c
+++ b/tools/perf/util/symbol.c
@@@ -236,10 -239,9 +236,16 @@@ void symbols__fixup_end(struct rb_root_
  		curr->end = roundup(curr->start, 4096) + 4096;
  }
  
++<<<<<<< HEAD
 +void map_groups__fixup_end(struct map_groups *mg)
 +{
 +	struct maps *maps = &mg->maps;
 +	struct map *next, *curr;
++=======
+ void maps__fixup_end(struct maps *maps)
+ {
+ 	struct map *prev = NULL, *curr;
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  
  	down_write(&maps->lock);
  
@@@ -1761,28 -1758,81 +1767,105 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
 +struct map *map_groups__find_by_name(struct map_groups *mg, const char *name)
++=======
+ static int map__strcmp(const void *a, const void *b)
+ {
+ 	const struct map *ma = *(const struct map **)a, *mb = *(const struct map **)b;
+ 	return strcmp(ma->dso->short_name, mb->dso->short_name);
+ }
+ 
+ static int map__strcmp_name(const void *name, const void *b)
+ {
+ 	const struct map *map = *(const struct map **)b;
+ 	return strcmp(name, map->dso->short_name);
+ }
+ 
+ void __maps__sort_by_name(struct maps *maps)
+ {
+ 	qsort(maps->maps_by_name, maps->nr_maps, sizeof(struct map *), map__strcmp);
+ }
+ 
+ static int map__groups__sort_by_name_from_rbtree(struct maps *maps)
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  {
 +	struct maps *maps = &mg->maps;
  	struct map *map;
++<<<<<<< HEAD
 +	struct rb_node *node;
 +
 +	down_read(&maps->lock);
 +
 +	for (node = maps->names.rb_node; node; ) {
 +		int rc;
 +
 +		map = rb_entry(node, struct map, rb_node_name);
 +
 +		rc = strcmp(map->dso->short_name, name);
 +		if (rc < 0)
 +			node = node->rb_left;
 +		else if (rc > 0)
 +			node = node->rb_right;
 +		else
 +
++=======
+ 	struct map **maps_by_name = realloc(maps->maps_by_name, maps->nr_maps * sizeof(map));
+ 	int i = 0;
+ 
+ 	if (maps_by_name == NULL)
+ 		return -1;
+ 
+ 	maps->maps_by_name = maps_by_name;
+ 	maps->nr_maps_allocated = maps->nr_maps;
+ 
+ 	maps__for_each_entry(maps, map)
+ 		maps_by_name[i++] = map;
+ 
+ 	__maps__sort_by_name(maps);
+ 	return 0;
+ }
+ 
+ static struct map *__maps__find_by_name(struct maps *maps, const char *name)
+ {
+ 	struct map **mapp;
+ 
+ 	if (maps->maps_by_name == NULL &&
+ 	    map__groups__sort_by_name_from_rbtree(maps))
+ 		return NULL;
+ 
+ 	mapp = bsearch(name, maps->maps_by_name, maps->nr_maps, sizeof(*mapp), map__strcmp_name);
+ 	if (mapp)
+ 		return *mapp;
+ 	return NULL;
+ }
+ 
+ struct map *maps__find_by_name(struct maps *maps, const char *name)
+ {
+ 	struct map *map;
+ 
+ 	down_read(&maps->lock);
+ 
+ 	if (maps->last_search_by_name && strcmp(maps->last_search_by_name->dso->short_name, name) == 0) {
+ 		map = maps->last_search_by_name;
+ 		goto out_unlock;
+ 	}
+ 	/*
+ 	 * If we have maps->maps_by_name, then the name isn't in the rbtree,
+ 	 * as maps->maps_by_name mirrors the rbtree when lookups by name are
+ 	 * made.
+ 	 */
+ 	map = __maps__find_by_name(maps, name);
+ 	if (map || maps->maps_by_name != NULL)
+ 		goto out_unlock;
+ 
+ 	/* Fallback to traversing the rbtree... */
+ 	maps__for_each_entry(maps, map)
+ 		if (strcmp(map->dso->short_name, name) == 0) {
+ 			maps->last_search_by_name = map;
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  			goto out_unlock;
 -		}
 +	}
  
  	map = NULL;
  
diff --cc tools/perf/util/symbol.h
index 38ecd98dfede,93fc43db1be3..000000000000
--- a/tools/perf/util/symbol.h
+++ b/tools/perf/util/symbol.h
@@@ -215,7 -186,7 +215,11 @@@ void __symbols__insert(struct rb_root_c
  void symbols__insert(struct rb_root_cached *symbols, struct symbol *sym);
  void symbols__fixup_duplicate(struct rb_root_cached *symbols);
  void symbols__fixup_end(struct rb_root_cached *symbols);
++<<<<<<< HEAD
 +void map_groups__fixup_end(struct map_groups *mg);
++=======
+ void maps__fixup_end(struct maps *maps);
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  
  typedef int (*mapfn_t)(u64 start, u64 len, u64 pgoff, void *data);
  int file__read_maps(int fd, bool exe, mapfn_t mapfn, void *data,
diff --cc tools/perf/util/unwind-libunwind-local.c
index aaf7a445c595,b4649f5a0c2f..000000000000
--- a/tools/perf/util/unwind-libunwind-local.c
+++ b/tools/perf/util/unwind-libunwind-local.c
@@@ -616,10 -616,10 +616,14 @@@ static unw_accessors_t accessors = 
  	.get_proc_name		= get_proc_name,
  };
  
++<<<<<<< HEAD
 +static int _unwind__prepare_access(struct map_groups *mg)
++=======
+ static int _unwind__prepare_access(struct maps *maps)
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  {
- 	mg->addr_space = unw_create_addr_space(&accessors, 0);
- 	if (!mg->addr_space) {
+ 	maps->addr_space = unw_create_addr_space(&accessors, 0);
+ 	if (!maps->addr_space) {
  		pr_err("unwind: Can't create unwind address space.\n");
  		return -ENOMEM;
  	}
@@@ -628,14 -628,14 +632,22 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void _unwind__flush_access(struct map_groups *mg)
++=======
+ static void _unwind__flush_access(struct maps *maps)
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  {
- 	unw_flush_cache(mg->addr_space, 0, 0);
+ 	unw_flush_cache(maps->addr_space, 0, 0);
  }
  
++<<<<<<< HEAD
 +static void _unwind__finish_access(struct map_groups *mg)
++=======
+ static void _unwind__finish_access(struct maps *maps)
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  {
- 	unw_destroy_addr_space(mg->addr_space);
+ 	unw_destroy_addr_space(maps->addr_space);
  }
  
  static int get_entries(struct unwind_info *ui, unwind_entry_cb_t cb,
diff --cc tools/perf/util/unwind-libunwind.c
index 6499b22b158b,e89a5479b361..000000000000
--- a/tools/perf/util/unwind-libunwind.c
+++ b/tools/perf/util/unwind-libunwind.c
@@@ -11,14 -12,12 +11,22 @@@ struct unwind_libunwind_ops __weak *loc
  struct unwind_libunwind_ops __weak *x86_32_unwind_libunwind_ops;
  struct unwind_libunwind_ops __weak *arm64_unwind_libunwind_ops;
  
++<<<<<<< HEAD
 +static void unwind__register_ops(struct map_groups *mg,
 +			  struct unwind_libunwind_ops *ops)
++=======
+ static void unwind__register_ops(struct maps *maps, struct unwind_libunwind_ops *ops)
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  {
- 	mg->unwind_libunwind_ops = ops;
+ 	maps->unwind_libunwind_ops = ops;
  }
  
++<<<<<<< HEAD
 +int unwind__prepare_access(struct map_groups *mg, struct map *map,
 +			   bool *initialized)
++=======
+ int unwind__prepare_access(struct maps *maps, struct map *map, bool *initialized)
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  {
  	const char *arch;
  	enum dso_type dso_type;
@@@ -67,16 -66,16 +75,24 @@@ out_register
  	return err;
  }
  
++<<<<<<< HEAD
 +void unwind__flush_access(struct map_groups *mg)
++=======
+ void unwind__flush_access(struct maps *maps)
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  {
- 	if (mg->unwind_libunwind_ops)
- 		mg->unwind_libunwind_ops->flush_access(mg);
+ 	if (maps->unwind_libunwind_ops)
+ 		maps->unwind_libunwind_ops->flush_access(maps);
  }
  
++<<<<<<< HEAD
 +void unwind__finish_access(struct map_groups *mg)
++=======
+ void unwind__finish_access(struct maps *maps)
++>>>>>>> 9a29ceee6bb1 (perf maps: Rename 'mg' variables to 'maps')
  {
- 	if (mg->unwind_libunwind_ops)
- 		mg->unwind_libunwind_ops->finish_access(mg);
+ 	if (maps->unwind_libunwind_ops)
+ 		maps->unwind_libunwind_ops->finish_access(maps);
  }
  
  int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
* Unmerged path tools/perf/tests/map_groups.c
* Unmerged path tools/perf/tests/thread-mg-share.c
* Unmerged path tools/perf/util/event.c
* Unmerged path tools/perf/util/machine.c
* Unmerged path tools/perf/util/map.c
* Unmerged path tools/perf/util/map_groups.h
* Unmerged path tools/perf/util/symbol.c
* Unmerged path tools/perf/util/symbol.h
* Unmerged path tools/perf/util/unwind-libunwind-local.c
* Unmerged path tools/perf/util/unwind-libunwind.c
