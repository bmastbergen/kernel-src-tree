KVM: VMX: Handle preemption timer fastpath

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Wanpeng Li <wanpengli@tencent.com>
commit 26efe2fd92e50822674acce1dbc4f2ac6fc1788f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/26efe2fd.failed

This patch implements a fastpath for the preemption timer vmexit.  The vmexit
can be handled quickly so it can be performed with interrupts off and going
back directly to the guest.

Testing on SKX Server.

cyclictest in guest(w/o mwait exposed, adaptive advance lapic timer is default -1):

5540.5ns -> 4602ns       17%

kvm-unit-test/vmexit.flat:

w/o avanced timer:
tscdeadline_immed: 3028.5  -> 2494.75  17.6%
tscdeadline:       5765.7  -> 5285      8.3%

w/ adaptive advance timer default -1:
tscdeadline_immed: 3123.75 -> 2583     17.3%
tscdeadline:       4663.75 -> 4537      2.7%

	Tested-by: Haiwei Li <lihaiwei@tencent.com>
	Cc: Haiwei Li <lihaiwei@tencent.com>
	Signed-off-by: Wanpeng Li <wanpengli@tencent.com>
Message-Id: <1588055009-12677-8-git-send-email-wanpengli@tencent.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 26efe2fd92e50822674acce1dbc4f2ac6fc1788f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index 539026efd9e1,5fa162f6e1dc..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -6630,10 -6634,23 +6638,25 @@@ void vmx_update_host_rsp(struct vcpu_vm
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static fastpath_t vmx_exit_handlers_fastpath(struct kvm_vcpu *vcpu)
+ {
+ 	switch (to_vmx(vcpu)->exit_reason) {
+ 	case EXIT_REASON_MSR_WRITE:
+ 		return handle_fastpath_set_msr_irqoff(vcpu);
+ 	case EXIT_REASON_PREEMPTION_TIMER:
+ 		return handle_fastpath_preemption_timer(vcpu);
+ 	default:
+ 		return EXIT_FASTPATH_NONE;
+ 	}
+ }
+ 
++>>>>>>> 26efe2fd92e5 (KVM: VMX: Handle preemption timer fastpath)
  bool __vmx_vcpu_run(struct vcpu_vmx *vmx, unsigned long *regs, bool launched);
  
 -static fastpath_t vmx_vcpu_run(struct kvm_vcpu *vcpu)
 +static void vmx_vcpu_run(struct kvm_vcpu *vcpu)
  {
 -	fastpath_t exit_fastpath;
  	struct vcpu_vmx *vmx = to_vmx(vcpu);
  	unsigned long cr3, cr4;
  
* Unmerged path arch/x86/kvm/vmx/vmx.c
