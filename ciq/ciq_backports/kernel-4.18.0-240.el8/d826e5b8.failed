NFSv4.x recover from pre-mature loss of openstateid

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Olga Kornievskaia <kolga@netapp.com>
commit d826e5b827641ae1bebb33d23a774f4e9bb8e94f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d826e5b8.failed

Ever since the commit 0e0cb35b417f, it's possible to lose an open stateid
while retrying a CLOSE due to ERR_OLD_STATEID. Once that happens,
operations that require openstateid fail with EAGAIN which is propagated
to the application then tests like generic/446 and generic/168 fail with
"Resource temporarily unavailable".

Instead of returning this error, initiate state recovery when possible to
recover the open stateid and then try calling nfs4_select_rw_stateid()
again.

Fixes: 0e0cb35b417f ("NFSv4: Handle NFS4ERR_OLD_STATEID in CLOSE/OPEN_DOWNGRADE")
	Signed-off-by: Olga Kornievskaia <kolga@netapp.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit d826e5b827641ae1bebb33d23a774f4e9bb8e94f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/nfs42proc.c
diff --cc fs/nfs/nfs42proc.c
index cc44135fbc5b,9637aad36bdc..000000000000
--- a/fs/nfs/nfs42proc.c
+++ b/fs/nfs/nfs42proc.c
@@@ -236,11 -284,18 +239,26 @@@ static ssize_t _nfs42_proc_copy(struct 
  	size_t count = args->count;
  	ssize_t status;
  
++<<<<<<< HEAD
 +	status = nfs4_set_rw_stateid(&args->src_stateid, src_lock->open_context,
 +				     src_lock, FMODE_READ);
 +	if (status)
 +		return status;
 +
++=======
+ 	if (nss) {
+ 		args->cp_src = nss;
+ 		nfs4_stateid_copy(&args->src_stateid, cnr_stateid);
+ 	} else {
+ 		status = nfs4_set_rw_stateid(&args->src_stateid,
+ 				src_lock->open_context, src_lock, FMODE_READ);
+ 		if (status) {
+ 			if (status == -EAGAIN)
+ 				status = -NFS4ERR_BAD_STATEID;
+ 			return status;
+ 		}
+ 	}
++>>>>>>> d826e5b82764 (NFSv4.x recover from pre-mature loss of openstateid)
  	status = nfs_filemap_write_and_wait_range(file_inode(src)->i_mapping,
  			pos_src, pos_src + (loff_t)count - 1);
  	if (status)
@@@ -459,6 -533,79 +480,82 @@@ static int nfs42_do_offload_cancel_asyn
  	return status;
  }
  
++<<<<<<< HEAD
++=======
+ static int _nfs42_proc_copy_notify(struct file *src, struct file *dst,
+ 				   struct nfs42_copy_notify_args *args,
+ 				   struct nfs42_copy_notify_res *res)
+ {
+ 	struct nfs_server *src_server = NFS_SERVER(file_inode(src));
+ 	struct rpc_message msg = {
+ 		.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_COPY_NOTIFY],
+ 		.rpc_argp = args,
+ 		.rpc_resp = res,
+ 	};
+ 	int status;
+ 	struct nfs_open_context *ctx;
+ 	struct nfs_lock_context *l_ctx;
+ 
+ 	ctx = get_nfs_open_context(nfs_file_open_context(src));
+ 	l_ctx = nfs_get_lock_context(ctx);
+ 	if (IS_ERR(l_ctx))
+ 		return PTR_ERR(l_ctx);
+ 
+ 	status = nfs4_set_rw_stateid(&args->cna_src_stateid, ctx, l_ctx,
+ 				     FMODE_READ);
+ 	nfs_put_lock_context(l_ctx);
+ 	if (status) {
+ 		if (status == -EAGAIN)
+ 			status = -NFS4ERR_BAD_STATEID;
+ 		return status;
+ 	}
+ 
+ 	status = nfs4_call_sync(src_server->client, src_server, &msg,
+ 				&args->cna_seq_args, &res->cnr_seq_res, 0);
+ 	if (status == -ENOTSUPP)
+ 		src_server->caps &= ~NFS_CAP_COPY_NOTIFY;
+ 
+ 	put_nfs_open_context(nfs_file_open_context(src));
+ 	return status;
+ }
+ 
+ int nfs42_proc_copy_notify(struct file *src, struct file *dst,
+ 				struct nfs42_copy_notify_res *res)
+ {
+ 	struct nfs_server *src_server = NFS_SERVER(file_inode(src));
+ 	struct nfs42_copy_notify_args *args;
+ 	struct nfs4_exception exception = {
+ 		.inode = file_inode(src),
+ 	};
+ 	int status;
+ 
+ 	if (!(src_server->caps & NFS_CAP_COPY_NOTIFY))
+ 		return -EOPNOTSUPP;
+ 
+ 	args = kzalloc(sizeof(struct nfs42_copy_notify_args), GFP_NOFS);
+ 	if (args == NULL)
+ 		return -ENOMEM;
+ 
+ 	args->cna_src_fh  = NFS_FH(file_inode(src)),
+ 	args->cna_dst.nl4_type = NL4_NETADDR;
+ 	nfs42_set_netaddr(dst, &args->cna_dst.u.nl4_addr);
+ 	exception.stateid = &args->cna_src_stateid;
+ 
+ 	do {
+ 		status = _nfs42_proc_copy_notify(src, dst, args, res);
+ 		if (status == -ENOTSUPP) {
+ 			status = -EOPNOTSUPP;
+ 			goto out;
+ 		}
+ 		status = nfs4_handle_exception(src_server, status, &exception);
+ 	} while (exception.retry);
+ 
+ out:
+ 	kfree(args);
+ 	return status;
+ }
+ 
++>>>>>>> d826e5b82764 (NFSv4.x recover from pre-mature loss of openstateid)
  static loff_t _nfs42_proc_llseek(struct file *filep,
  		struct nfs_lock_context *lock, loff_t offset, int whence)
  {
* Unmerged path fs/nfs/nfs42proc.c
diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c
index d2375150d70f..6395eba37e2c 100644
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@ -3258,6 +3258,8 @@ static int _nfs4_do_setattr(struct inode *inode,
 		nfs_put_lock_context(l_ctx);
 		if (status == -EIO)
 			return -EBADF;
+		else if (status == -EAGAIN)
+			goto zero_stateid;
 	} else {
 zero_stateid:
 		nfs4_stateid_copy(&arg->stateid, &zero_stateid);
diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c
index 39bbc335679e..542ea8dfd1bc 100644
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@ -1998,8 +1998,6 @@ pnfs_update_layout(struct inode *ino,
 			trace_pnfs_update_layout(ino, pos, count,
 					iomode, lo, lseg,
 					PNFS_UPDATE_LAYOUT_INVALID_OPEN);
-			if (status != -EAGAIN)
-				goto out_unlock;
 			spin_unlock(&ino->i_lock);
 			nfs4_schedule_stateid_recovery(server, ctx->state);
 			pnfs_clear_first_layoutget(lo);
