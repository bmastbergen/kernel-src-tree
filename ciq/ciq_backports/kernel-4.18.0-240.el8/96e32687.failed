net/mlx5e: Eswitch, Use per vport tables for mirroring

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Eli Cohen <eli@mellanox.com>
commit 96e326878fa5e2727d14e9a23644119374619010
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/96e32687.failed

When using port mirroring, we forward the traffic to another table and
use that table to forward to the mirrored vport. Since the hardware
loses the values of reg c, and in particular reg c0, we fail the match
on the input vport which previously existed in reg c0. To overcome this
situation, we use a set of per vport tables, positioned at the lowest
priority, and forward traffic to those tables. Since these tables are
per vport, we can avoid matching on reg c0.

Fixes: c01cfd0f1115 ("net/mlx5: E-Switch, Add match on vport metadata for rule in fast path")
	Signed-off-by: Eli Cohen <eli@mellanox.com>
	Reviewed-by: Mark Bloch <markb@mellanox.com>
	Reviewed-by: Paul Blakey <paulb@mellanox.com>
	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
(cherry picked from commit 96e326878fa5e2727d14e9a23644119374619010)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
#	drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
index 9c629f913b96,479d2458f872..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
@@@ -43,9 -43,16 +43,22 @@@
  #include <linux/mlx5/fs.h>
  #include "lib/mpfs.h"
  
++<<<<<<< HEAD
 +#define FDB_MAX_CHAIN 3
 +#define FDB_SLOW_PATH_CHAIN (FDB_MAX_CHAIN + 1)
 +#define FDB_MAX_PRIO 16
++=======
+ #define FDB_TC_MAX_CHAIN 3
+ #define FDB_FT_CHAIN (FDB_TC_MAX_CHAIN + 1)
+ #define FDB_TC_SLOW_PATH_CHAIN (FDB_FT_CHAIN + 1)
+ 
+ /* The index of the last real chain (FT) + 1 as chain zero is valid as well */
+ #define FDB_NUM_CHAINS (FDB_FT_CHAIN + 1)
+ #define ESW_OFFLOADS_NUM_GROUPS  4
+ 
+ #define FDB_TC_MAX_PRIO 16
+ #define FDB_TC_LEVELS_PER_PRIO 2
++>>>>>>> 96e326878fa5 (net/mlx5e: Eswitch, Use per vport tables for mirroring)
  
  #ifdef CONFIG_MLX5_ESWITCH
  
@@@ -165,14 -183,13 +178,24 @@@ struct mlx5_eswitch_fdb 
  			struct mlx5_flow_handle *miss_rule_multi;
  			int vlan_push_pop_refcount;
  
++<<<<<<< HEAD
 +			struct {
 +				struct mlx5_flow_table *fdb;
 +				u32 num_rules;
 +			} fdb_prio[FDB_MAX_CHAIN + 1][FDB_MAX_PRIO + 1][PRIO_LEVELS];
 +			/* Protects fdb_prio table */
 +			struct mutex fdb_prio_lock;
 +
 +			int fdb_left[ARRAY_SIZE(ESW_POOLS)];
++=======
+ 			struct mlx5_esw_chains_priv *esw_chains_priv;
+ 			struct {
+ 				DECLARE_HASHTABLE(table, 8);
+ 				/* Protects vports.table */
+ 				struct mutex lock;
+ 			} vports;
+ 
++>>>>>>> 96e326878fa5 (net/mlx5e: Eswitch, Use per vport tables for mirroring)
  		} offloads;
  	};
  	u32 flags;
@@@ -609,6 -623,16 +632,19 @@@ mlx5_eswitch_enable_pf_vf_vports(struc
  				 enum mlx5_eswitch_vport_event enabled_events);
  void mlx5_eswitch_disable_pf_vf_vports(struct mlx5_eswitch *esw);
  
++<<<<<<< HEAD
++=======
+ int
+ esw_vport_create_offloads_acl_tables(struct mlx5_eswitch *esw,
+ 				     struct mlx5_vport *vport);
+ void
+ esw_vport_destroy_offloads_acl_tables(struct mlx5_eswitch *esw,
+ 				      struct mlx5_vport *vport);
+ 
+ int mlx5_esw_vport_tbl_get(struct mlx5_eswitch *esw);
+ void mlx5_esw_vport_tbl_put(struct mlx5_eswitch *esw);
+ 
++>>>>>>> 96e326878fa5 (net/mlx5e: Eswitch, Use per vport tables for mirroring)
  #else  /* CONFIG_MLX5_ESWITCH */
  /* eswitch API stubs */
  static inline int  mlx5_eswitch_init(struct mlx5_core_dev *dev) { return 0; }
diff --cc drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
index a042a52084fa,9a72c719d8f5..000000000000
--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
@@@ -47,12 -48,181 +47,185 @@@
   * one for multicast.
   */
  #define MLX5_ESW_MISS_FLOWS (2)
 +
 +#define fdb_prio_table(esw, chain, prio, level) \
 +	(esw)->fdb_table.offloads.fdb_prio[(chain)][(prio)][(level)]
 +
  #define UPLINK_REP_INDEX 0
  
+ /* Per vport tables */
+ 
+ #define MLX5_ESW_VPORT_TABLE_SIZE 128
+ 
+ /* This struct is used as a key to the hash table and we need it to be packed
+  * so hash result is consistent
+  */
+ struct mlx5_vport_key {
+ 	u32 chain;
+ 	u16 prio;
+ 	u16 vport;
+ 	u16 vhca_id;
+ } __packed;
+ 
+ struct mlx5_vport_table {
+ 	struct hlist_node hlist;
+ 	struct mlx5_flow_table *fdb;
+ 	u32 num_rules;
+ 	struct mlx5_vport_key key;
+ };
+ 
+ static struct mlx5_flow_table *
+ esw_vport_tbl_create(struct mlx5_eswitch *esw, struct mlx5_flow_namespace *ns)
+ {
+ 	struct mlx5_flow_table_attr ft_attr = {};
+ 	struct mlx5_flow_table *fdb;
+ 
+ 	ft_attr.autogroup.max_num_groups = ESW_OFFLOADS_NUM_GROUPS;
+ 	ft_attr.max_fte = MLX5_ESW_VPORT_TABLE_SIZE;
+ 	ft_attr.prio = FDB_PER_VPORT;
+ 	fdb = mlx5_create_auto_grouped_flow_table(ns, &ft_attr);
+ 	if (IS_ERR(fdb)) {
+ 		esw_warn(esw->dev, "Failed to create per vport FDB Table err %ld\n",
+ 			 PTR_ERR(fdb));
+ 	}
+ 
+ 	return fdb;
+ }
+ 
+ static u32 flow_attr_to_vport_key(struct mlx5_eswitch *esw,
+ 				  struct mlx5_esw_flow_attr *attr,
+ 				  struct mlx5_vport_key *key)
+ {
+ 	key->vport = attr->in_rep->vport;
+ 	key->chain = attr->chain;
+ 	key->prio = attr->prio;
+ 	key->vhca_id = MLX5_CAP_GEN(esw->dev, vhca_id);
+ 	return jhash(key, sizeof(*key), 0);
+ }
+ 
+ /* caller must hold vports.lock */
+ static struct mlx5_vport_table *
+ esw_vport_tbl_lookup(struct mlx5_eswitch *esw, struct mlx5_vport_key *skey, u32 key)
+ {
+ 	struct mlx5_vport_table *e;
+ 
+ 	hash_for_each_possible(esw->fdb_table.offloads.vports.table, e, hlist, key)
+ 		if (!memcmp(&e->key, skey, sizeof(*skey)))
+ 			return e;
+ 
+ 	return NULL;
+ }
+ 
+ static void
+ esw_vport_tbl_put(struct mlx5_eswitch *esw, struct mlx5_esw_flow_attr *attr)
+ {
+ 	struct mlx5_vport_table *e;
+ 	struct mlx5_vport_key key;
+ 	u32 hkey;
+ 
+ 	mutex_lock(&esw->fdb_table.offloads.vports.lock);
+ 	hkey = flow_attr_to_vport_key(esw, attr, &key);
+ 	e = esw_vport_tbl_lookup(esw, &key, hkey);
+ 	if (!e || --e->num_rules)
+ 		goto out;
+ 
+ 	hash_del(&e->hlist);
+ 	mlx5_destroy_flow_table(e->fdb);
+ 	kfree(e);
+ out:
+ 	mutex_unlock(&esw->fdb_table.offloads.vports.lock);
+ }
+ 
+ static struct mlx5_flow_table *
+ esw_vport_tbl_get(struct mlx5_eswitch *esw, struct mlx5_esw_flow_attr *attr)
+ {
+ 	struct mlx5_core_dev *dev = esw->dev;
+ 	struct mlx5_flow_namespace *ns;
+ 	struct mlx5_flow_table *fdb;
+ 	struct mlx5_vport_table *e;
+ 	struct mlx5_vport_key skey;
+ 	u32 hkey;
+ 
+ 	mutex_lock(&esw->fdb_table.offloads.vports.lock);
+ 	hkey = flow_attr_to_vport_key(esw, attr, &skey);
+ 	e = esw_vport_tbl_lookup(esw, &skey, hkey);
+ 	if (e) {
+ 		e->num_rules++;
+ 		goto out;
+ 	}
+ 
+ 	e = kzalloc(sizeof(*e), GFP_KERNEL);
+ 	if (!e) {
+ 		fdb = ERR_PTR(-ENOMEM);
+ 		goto err_alloc;
+ 	}
+ 
+ 	ns = mlx5_get_flow_namespace(dev, MLX5_FLOW_NAMESPACE_FDB);
+ 	if (!ns) {
+ 		esw_warn(dev, "Failed to get FDB namespace\n");
+ 		fdb = ERR_PTR(-ENOENT);
+ 		goto err_ns;
+ 	}
+ 
+ 	fdb = esw_vport_tbl_create(esw, ns);
+ 	if (IS_ERR(fdb))
+ 		goto err_ns;
+ 
+ 	e->fdb = fdb;
+ 	e->num_rules = 1;
+ 	e->key = skey;
+ 	hash_add(esw->fdb_table.offloads.vports.table, &e->hlist, hkey);
+ out:
+ 	mutex_unlock(&esw->fdb_table.offloads.vports.lock);
+ 	return e->fdb;
+ 
+ err_ns:
+ 	kfree(e);
+ err_alloc:
+ 	mutex_unlock(&esw->fdb_table.offloads.vports.lock);
+ 	return fdb;
+ }
+ 
+ int mlx5_esw_vport_tbl_get(struct mlx5_eswitch *esw)
+ {
+ 	struct mlx5_esw_flow_attr attr = {};
+ 	struct mlx5_eswitch_rep rep = {};
+ 	struct mlx5_flow_table *fdb;
+ 	struct mlx5_vport *vport;
+ 	int i;
+ 
+ 	attr.prio = 1;
+ 	attr.in_rep = &rep;
+ 	mlx5_esw_for_all_vports(esw, i, vport) {
+ 		attr.in_rep->vport = vport->vport;
+ 		fdb = esw_vport_tbl_get(esw, &attr);
+ 		if (!fdb)
+ 			goto out;
+ 	}
+ 	return 0;
+ 
+ out:
+ 	mlx5_esw_vport_tbl_put(esw);
+ 	return PTR_ERR(fdb);
+ }
+ 
+ void mlx5_esw_vport_tbl_put(struct mlx5_eswitch *esw)
+ {
+ 	struct mlx5_esw_flow_attr attr = {};
+ 	struct mlx5_eswitch_rep rep = {};
+ 	struct mlx5_vport *vport;
+ 	int i;
+ 
+ 	attr.prio = 1;
+ 	attr.in_rep = &rep;
+ 	mlx5_esw_for_all_vports(esw, i, vport) {
+ 		attr.in_rep->vport = vport->vport;
+ 		esw_vport_tbl_put(esw, &attr);
+ 	}
+ }
+ 
+ /* End: Per vport tables */
+ 
  static struct mlx5_eswitch_rep *mlx5_eswitch_get_rep(struct mlx5_eswitch *esw,
  						     u16 vport_num)
  {
@@@ -220,7 -372,13 +391,17 @@@ mlx5_eswitch_add_offloaded_rule(struct 
  	if (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)
  		flow_act.modify_hdr = attr->modify_hdr;
  
++<<<<<<< HEAD
 +	fdb = esw_get_prio_table(esw, attr->chain, attr->prio, !!split);
++=======
+ 	if (split) {
+ 		fdb = esw_vport_tbl_get(esw, attr);
+ 	} else {
+ 		fdb = mlx5_esw_chains_get_table(esw, attr->chain, attr->prio,
+ 						0);
+ 		mlx5_eswitch_set_rule_source_port(esw, spec, attr);
+ 	}
++>>>>>>> 96e326878fa5 (net/mlx5e: Eswitch, Use per vport tables for mirroring)
  	if (IS_ERR(fdb)) {
  		rule = ERR_CAST(fdb);
  		goto err_esw_get;
@@@ -239,10 -397,13 +420,17 @@@
  	return rule;
  
  err_add_rule:
++<<<<<<< HEAD
 +	esw_put_prio_table(esw, attr->chain, attr->prio, !!split);
++=======
+ 	if (split)
+ 		esw_vport_tbl_put(esw, attr);
+ 	else
+ 		mlx5_esw_chains_put_table(esw, attr->chain, attr->prio, 0);
++>>>>>>> 96e326878fa5 (net/mlx5e: Eswitch, Use per vport tables for mirroring)
  err_esw_get:
 -	if (!(attr->flags & MLX5_ESW_ATTR_FLAG_SLOW_PATH) && attr->dest_chain)
 -		mlx5_esw_chains_put_table(esw, attr->dest_chain, 1, 0);
 +	if (attr->dest_chain)
 +		esw_put_prio_table(esw, attr->dest_chain, 1, 0);
  err_create_goto_table:
  	return rule;
  }
@@@ -265,7 -426,7 +453,11 @@@ mlx5_eswitch_add_fwd_rule(struct mlx5_e
  		goto err_get_fast;
  	}
  
++<<<<<<< HEAD
 +	fwd_fdb = esw_get_prio_table(esw, attr->chain, attr->prio, 1);
++=======
+ 	fwd_fdb = esw_vport_tbl_get(esw, attr);
++>>>>>>> 96e326878fa5 (net/mlx5e: Eswitch, Use per vport tables for mirroring)
  	if (IS_ERR(fwd_fdb)) {
  		rule = ERR_CAST(fwd_fdb);
  		goto err_get_fwd;
@@@ -302,9 -464,9 +494,13 @@@
  
  	return rule;
  add_err:
++<<<<<<< HEAD
 +	esw_put_prio_table(esw, attr->chain, attr->prio, 1);
++=======
+ 	esw_vport_tbl_put(esw, attr);
++>>>>>>> 96e326878fa5 (net/mlx5e: Eswitch, Use per vport tables for mirroring)
  err_get_fwd:
 -	mlx5_esw_chains_put_table(esw, attr->chain, attr->prio, 0);
 +	esw_put_prio_table(esw, attr->chain, attr->prio, 0);
  err_get_fast:
  	return rule;
  }
@@@ -329,12 -491,16 +525,23 @@@ __mlx5_eswitch_del_rule(struct mlx5_esw
  	atomic64_dec(&esw->offloads.num_flows);
  
  	if (fwd_rule)  {
++<<<<<<< HEAD
 +		esw_put_prio_table(esw, attr->chain, attr->prio, 1);
 +		esw_put_prio_table(esw, attr->chain, attr->prio, 0);
 +	} else {
 +		esw_put_prio_table(esw, attr->chain, attr->prio, !!split);
++=======
+ 		esw_vport_tbl_put(esw, attr);
+ 		mlx5_esw_chains_put_table(esw, attr->chain, attr->prio, 0);
+ 	} else {
+ 		if (split)
+ 			esw_vport_tbl_put(esw, attr);
+ 		else
+ 			mlx5_esw_chains_put_table(esw, attr->chain, attr->prio,
+ 						  0);
++>>>>>>> 96e326878fa5 (net/mlx5e: Eswitch, Use per vport tables for mirroring)
  		if (attr->dest_chain)
 -			mlx5_esw_chains_put_table(esw, attr->dest_chain, 1, 0);
 +			esw_put_prio_table(esw, attr->dest_chain, 1, 0);
  	}
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch.h
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c
* Unmerged path drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads_chains.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
index 19446018a6ee..132c16efbf5a 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c
@@ -2583,6 +2583,17 @@ static int init_fdb_root_ns(struct mlx5_flow_steering *steering)
 		goto out_err;
 	}
 
+	/* We put this priority last, knowing that nothing will get here
+	 * unless explicitly forwarded to. This is possible because the
+	 * slow path tables have catch all rules and nothing gets passed
+	 * those tables.
+	 */
+	maj_prio = fs_create_prio(&steering->fdb_root_ns->ns, FDB_PER_VPORT, 1);
+	if (IS_ERR(maj_prio)) {
+		err = PTR_ERR(maj_prio);
+		goto out_err;
+	}
+
 	set_prio_attrs(steering->fdb_root_ns);
 	return 0;
 
diff --git a/include/linux/mlx5/fs.h b/include/linux/mlx5/fs.h
index d4ccba587a81..d4c5a00291ff 100644
--- a/include/linux/mlx5/fs.h
+++ b/include/linux/mlx5/fs.h
@@ -81,6 +81,7 @@ enum {
 	FDB_BYPASS_PATH,
 	FDB_FAST_PATH,
 	FDB_SLOW_PATH,
+	FDB_PER_VPORT,
 };
 
 struct mlx5_pkt_reformat;
