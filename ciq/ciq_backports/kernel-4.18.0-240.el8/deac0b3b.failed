iommu: Split off default domain allocation from group assignment

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Joerg Roedel <jroedel@suse.de>
commit deac0b3bed26bb5d04486696b1071d8ec3851100
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/deac0b3b.failed

When a bus is initialized with iommu-ops, all devices on the bus are
scanned and iommu-groups are allocated for them, and each groups will
also get a default domain allocated.

Until now this happened as soon as the group was created and the first
device added to it. When other devices with different default domain
requirements were added to the group later on, the default domain was
re-allocated, if possible.

This resulted in some back and forth and unnecessary allocations, so
change the flow to defer default domain allocation until all devices
have been added to their respective IOMMU groups.

The default domains are allocated for newly allocated groups after
each device on the bus is handled and was probed by the IOMMU driver.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
	Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
	Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
Link: https://lore.kernel.org/r/20200429133712.31431-12-joro@8bytes.org
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit deac0b3bed26bb5d04486696b1071d8ec3851100)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
diff --cc drivers/iommu/iommu.c
index 7997fcb701e0,7de0e29db333..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -161,6 -161,104 +161,107 @@@ void iommu_device_unregister(struct iom
  	list_del(&iommu->list);
  	spin_unlock(&iommu_device_lock);
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL_GPL(iommu_device_unregister);
+ 
+ static struct dev_iommu *dev_iommu_get(struct device *dev)
+ {
+ 	struct dev_iommu *param = dev->iommu;
+ 
+ 	if (param)
+ 		return param;
+ 
+ 	param = kzalloc(sizeof(*param), GFP_KERNEL);
+ 	if (!param)
+ 		return NULL;
+ 
+ 	mutex_init(&param->lock);
+ 	dev->iommu = param;
+ 	return param;
+ }
+ 
+ static void dev_iommu_free(struct device *dev)
+ {
+ 	kfree(dev->iommu);
+ 	dev->iommu = NULL;
+ }
+ 
+ static int __iommu_probe_device(struct device *dev, struct list_head *group_list)
+ {
+ 	const struct iommu_ops *ops = dev->bus->iommu_ops;
+ 	struct iommu_device *iommu_dev;
+ 	struct iommu_group *group;
+ 	int ret;
+ 
+ 	iommu_dev = ops->probe_device(dev);
+ 	if (IS_ERR(iommu_dev))
+ 		return PTR_ERR(iommu_dev);
+ 
+ 	dev->iommu->iommu_dev = iommu_dev;
+ 
+ 	group = iommu_group_get_for_dev(dev);
+ 	if (IS_ERR(group)) {
+ 		ret = PTR_ERR(group);
+ 		goto out_release;
+ 	}
+ 	iommu_group_put(group);
+ 
+ 	if (group_list && !group->default_domain && list_empty(&group->entry))
+ 		list_add_tail(&group->entry, group_list);
+ 
+ 	iommu_device_link(iommu_dev, dev);
+ 
+ 	return 0;
+ 
+ out_release:
+ 	ops->release_device(dev);
+ 
+ 	return ret;
+ }
+ 
+ static int __iommu_probe_device_helper(struct device *dev)
+ {
+ 	const struct iommu_ops *ops = dev->bus->iommu_ops;
+ 	struct iommu_group *group;
+ 	int ret;
+ 
+ 	ret = __iommu_probe_device(dev, NULL);
+ 	if (ret)
+ 		goto err_out;
+ 
+ 	/*
+ 	 * Try to allocate a default domain - needs support from the
+ 	 * IOMMU driver. There are still some drivers which don't
+ 	 * support default domains, so the return value is not yet
+ 	 * checked.
+ 	 */
+ 	iommu_alloc_default_domain(dev);
+ 
+ 	group = iommu_group_get(dev);
+ 	if (!group)
+ 		goto err_release;
+ 
+ 	if (group->default_domain)
+ 		ret = __iommu_attach_device(group->default_domain, dev);
+ 
+ 	iommu_group_put(group);
+ 
+ 	if (ret)
+ 		goto err_release;
+ 
+ 	if (ops->probe_finalize)
+ 		ops->probe_finalize(dev);
+ 
+ 	return 0;
+ 
+ err_release:
+ 	iommu_release_device(dev);
+ err_out:
+ 	return ret;
+ 
+ }
++>>>>>>> deac0b3bed26 (iommu: Split off default domain allocation from group assignment)
  
  int iommu_probe_device(struct device *dev)
  {
* Unmerged path drivers/iommu/iommu.c
