bpf: Fix missing prog untrack in release_maps

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Daniel Borkmann <daniel@iogearbox.net>
commit a2ea07465c8d7984cc6b8b1f0b3324f9b138094a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a2ea0746.failed

Commit da765a2f5993 ("bpf: Add poke dependency tracking for prog array
maps") wrongly assumed that in case of prog load errors, we're cleaning
up all program tracking via bpf_free_used_maps().

However, it can happen that we're still at the point where we didn't copy
map pointers into the prog's aux section such that env->prog->aux->used_maps
is still zero, running into a UAF. In such case, the verifier has similar
release_maps() helper that drops references to used maps from its env.

Consolidate the release code into __bpf_free_used_maps() and call it from
all sides to fix it.

Fixes: da765a2f5993 ("bpf: Add poke dependency tracking for prog array maps")
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Yonghong Song <yhs@fb.com>
Link: https://lore.kernel.org/bpf/1c2909484ca524ae9f55109b06f22b6213e76376.1576514756.git.daniel@iogearbox.net
(cherry picked from commit a2ea07465c8d7984cc6b8b1f0b3324f9b138094a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/bpf/core.c
#	kernel/bpf/verifier.c
diff --cc kernel/bpf/core.c
index e8ab7b5844e9,6231858df723..000000000000
--- a/kernel/bpf/core.c
+++ b/kernel/bpf/core.c
@@@ -2008,6 -2036,39 +2008,42 @@@ int bpf_prog_array_copy_info(struct bpf
  								     : 0;
  }
  
++<<<<<<< HEAD
++=======
+ static void bpf_free_cgroup_storage(struct bpf_prog_aux *aux)
+ {
+ 	enum bpf_cgroup_storage_type stype;
+ 
+ 	for_each_cgroup_storage_type(stype) {
+ 		if (!aux->cgroup_storage[stype])
+ 			continue;
+ 		bpf_cgroup_storage_release(aux->prog,
+ 					   aux->cgroup_storage[stype]);
+ 	}
+ }
+ 
+ void __bpf_free_used_maps(struct bpf_prog_aux *aux,
+ 			  struct bpf_map **used_maps, u32 len)
+ {
+ 	struct bpf_map *map;
+ 	u32 i;
+ 
+ 	bpf_free_cgroup_storage(aux);
+ 	for (i = 0; i < len; i++) {
+ 		map = used_maps[i];
+ 		if (map->ops->map_poke_untrack)
+ 			map->ops->map_poke_untrack(map, aux);
+ 		bpf_map_put(map);
+ 	}
+ }
+ 
+ static void bpf_free_used_maps(struct bpf_prog_aux *aux)
+ {
+ 	__bpf_free_used_maps(aux, aux->used_maps, aux->used_map_cnt);
+ 	kfree(aux->used_maps);
+ }
+ 
++>>>>>>> a2ea07465c8d (bpf: Fix missing prog untrack in release_maps)
  static void bpf_prog_free_deferred(struct work_struct *work)
  {
  	struct bpf_prog_aux *aux;
diff --cc kernel/bpf/verifier.c
index 7e7ad8585479,a1acdce77070..000000000000
--- a/kernel/bpf/verifier.c
+++ b/kernel/bpf/verifier.c
@@@ -8297,18 -8298,8 +8297,23 @@@ next_insn
  /* drop refcnt of maps used by the rejected program */
  static void release_maps(struct bpf_verifier_env *env)
  {
++<<<<<<< HEAD
 +	enum bpf_cgroup_storage_type stype;
 +	int i;
 +
 +	for_each_cgroup_storage_type(stype) {
 +		if (!env->prog->aux->cgroup_storage[stype])
 +			continue;
 +		bpf_cgroup_storage_release(env->prog->aux,
 +			env->prog->aux->cgroup_storage[stype]);
 +	}
 +
 +	for (i = 0; i < env->used_map_cnt; i++)
 +		bpf_map_put(env->used_maps[i]);
++=======
+ 	__bpf_free_used_maps(env->prog->aux, env->used_maps,
+ 			     env->used_map_cnt);
++>>>>>>> a2ea07465c8d (bpf: Fix missing prog untrack in release_maps)
  }
  
  /* convert pseudo BPF_LD_IMM64 into generic BPF_LD_IMM64 */
diff --git a/include/linux/bpf.h b/include/linux/bpf.h
index 8c8f4e236fdc..661f5fb30341 100644
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@ -678,6 +678,8 @@ struct bpf_prog * __must_check bpf_prog_inc_not_zero(struct bpf_prog *prog);
 void bpf_prog_put(struct bpf_prog *prog);
 int __bpf_prog_charge(struct user_struct *user, u32 pages);
 void __bpf_prog_uncharge(struct user_struct *user, u32 pages);
+void __bpf_free_used_maps(struct bpf_prog_aux *aux,
+			  struct bpf_map **used_maps, u32 len);
 
 void bpf_prog_free_id(struct bpf_prog *prog, bool do_idr_lock);
 void bpf_map_free_id(struct bpf_map *map, bool do_idr_lock);
* Unmerged path kernel/bpf/core.c
* Unmerged path kernel/bpf/verifier.c
