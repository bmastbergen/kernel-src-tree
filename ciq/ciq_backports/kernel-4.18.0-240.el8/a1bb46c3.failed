ACPI: processor: Add QoS requests for all CPUs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit a1bb46c36ce389d4a24a42e5b6047b0626caa3ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/a1bb46c3.failed

The _PPC change notifications from the platform firmware are per-CPU,
so acpi_processor_ppc_init() needs to add a frequency QoS request
for each CPU covered by a cpufreq policy to take all of them into
account.

Even though ACPI thermal control of CPUs sets frequency limits
per processor package, it also needs a frequency QoS request for each
CPU in a cpufreq policy in case some of them are taken offline and
the frequency limit needs to be set through the remaining online
ones (this is slightly excessive, because all CPUs covered by one
cpufreq policy will set the same frequency limit through their QoS
requests, but it is not incorrect).

Modify the code in accordance with the above observations.

Fixes: d15ce412737a ("ACPI: cpufreq: Switch to QoS requests instead of cpufreq notifier")
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
(cherry picked from commit a1bb46c36ce389d4a24a42e5b6047b0626caa3ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/processor_perflib.c
#	drivers/acpi/processor_thermal.c
diff --cc drivers/acpi/processor_perflib.c
index 6c6e8672fe35,5909e8fa4013..000000000000
--- a/drivers/acpi/processor_perflib.c
+++ b/drivers/acpi/processor_perflib.c
@@@ -170,28 -157,36 +170,57 @@@ void acpi_processor_ignore_ppc_init(voi
  		ignore_ppc = 0;
  }
  
 -void acpi_processor_ppc_init(struct cpufreq_policy *policy)
 +void acpi_processor_ppc_init(int cpu)
  {
++<<<<<<< HEAD
 +	struct acpi_processor *pr = per_cpu(processors, cpu);
 +	int ret;
++=======
+ 	unsigned int cpu;
++>>>>>>> a1bb46c36ce3 (ACPI: processor: Add QoS requests for all CPUs)
  
- 	if (!pr)
- 		return;
+ 	for_each_cpu(cpu, policy->related_cpus) {
+ 		struct acpi_processor *pr = per_cpu(processors, cpu);
+ 		int ret;
  
++<<<<<<< HEAD
 +	ret = dev_pm_qos_add_request(get_cpu_device(cpu),
 +				     &pr->perflib_req, DEV_PM_QOS_MAX_FREQUENCY,
 +				     INT_MAX);
 +	if (ret < 0)
 +		pr_err("Failed to add freq constraint for CPU%d (%d)\n", cpu,
 +		       ret);
++=======
+ 		if (!pr)
+ 			continue;
+ 
+ 		ret = freq_qos_add_request(&policy->constraints,
+ 					   &pr->perflib_req,
+ 					   FREQ_QOS_MAX, INT_MAX);
+ 		if (ret < 0)
+ 			pr_err("Failed to add freq constraint for CPU%d (%d)\n",
+ 			       cpu, ret);
+ 	}
++>>>>>>> a1bb46c36ce3 (ACPI: processor: Add QoS requests for all CPUs)
  }
  
 -void acpi_processor_ppc_exit(struct cpufreq_policy *policy)
 +void acpi_processor_ppc_exit(int cpu)
  {
++<<<<<<< HEAD
 +	struct acpi_processor *pr = per_cpu(processors, cpu);
 +
 +	if (pr)
 +		dev_pm_qos_remove_request(&pr->perflib_req);
++=======
+ 	unsigned int cpu;
+ 
+ 	for_each_cpu(cpu, policy->related_cpus) {
+ 		struct acpi_processor *pr = per_cpu(processors, cpu);
+ 
+ 		if (pr)
+ 			freq_qos_remove_request(&pr->perflib_req);
+ 	}
++>>>>>>> a1bb46c36ce3 (ACPI: processor: Add QoS requests for all CPUs)
  }
  
  static int acpi_processor_get_performance_control(struct acpi_processor *pr)
diff --cc drivers/acpi/processor_thermal.c
index 5f607d22ea6b,41feb88ee92d..000000000000
--- a/drivers/acpi/processor_thermal.c
+++ b/drivers/acpi/processor_thermal.c
@@@ -138,28 -125,36 +138,57 @@@ static int cpufreq_set_cur_state(unsign
  	return 0;
  }
  
 -void acpi_thermal_cpufreq_init(struct cpufreq_policy *policy)
 +void acpi_thermal_cpufreq_init(int cpu)
  {
++<<<<<<< HEAD
 +	struct acpi_processor *pr = per_cpu(processors, cpu);
 +	int ret;
++=======
+ 	unsigned int cpu;
++>>>>>>> a1bb46c36ce3 (ACPI: processor: Add QoS requests for all CPUs)
  
- 	if (!pr)
- 		return;
+ 	for_each_cpu(cpu, policy->related_cpus) {
+ 		struct acpi_processor *pr = per_cpu(processors, cpu);
+ 		int ret;
  
++<<<<<<< HEAD
 +	ret = dev_pm_qos_add_request(get_cpu_device(cpu),
 +				     &pr->thermal_req, DEV_PM_QOS_MAX_FREQUENCY,
 +				     INT_MAX);
 +	if (ret < 0)
 +		pr_err("Failed to add freq constraint for CPU%d (%d)\n", cpu,
 +		       ret);
++=======
+ 		if (!pr)
+ 			continue;
+ 
+ 		ret = freq_qos_add_request(&policy->constraints,
+ 					   &pr->thermal_req,
+ 					   FREQ_QOS_MAX, INT_MAX);
+ 		if (ret < 0)
+ 			pr_err("Failed to add freq constraint for CPU%d (%d)\n",
+ 			       cpu, ret);
+ 	}
++>>>>>>> a1bb46c36ce3 (ACPI: processor: Add QoS requests for all CPUs)
  }
  
 -void acpi_thermal_cpufreq_exit(struct cpufreq_policy *policy)
 +void acpi_thermal_cpufreq_exit(int cpu)
  {
++<<<<<<< HEAD
 +	struct acpi_processor *pr = per_cpu(processors, cpu);
 +
 +	if (pr)
 +		dev_pm_qos_remove_request(&pr->thermal_req);
++=======
+ 	unsigned int cpu;
+ 
+ 	for_each_cpu(cpu, policy->related_cpus) {
+ 		struct acpi_processor *pr = per_cpu(processors, policy->cpu);
+ 
+ 		if (pr)
+ 			freq_qos_remove_request(&pr->thermal_req);
+ 	}
++>>>>>>> a1bb46c36ce3 (ACPI: processor: Add QoS requests for all CPUs)
  }
  #else				/* ! CONFIG_CPU_FREQ */
  static int cpufreq_get_max_state(unsigned int cpu)
* Unmerged path drivers/acpi/processor_perflib.c
* Unmerged path drivers/acpi/processor_thermal.c
