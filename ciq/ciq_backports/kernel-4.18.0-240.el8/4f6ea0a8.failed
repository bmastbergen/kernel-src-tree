KVM: VMX: Gracefully handle faults on VMXON

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 4f6ea0a87608e1b26ed26123ae7c42aaecdd2c6c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/4f6ea0a8.failed

Gracefully handle faults on VMXON, e.g. #GP due to VMX being disabled by
BIOS, instead of letting the fault crash the system.  Now that KVM uses
cpufeatures to query support instead of reading MSR_IA32_FEAT_CTL
directly, it's possible for a bug in a different subsystem to cause KVM
to incorrectly attempt VMXON[*].  Crashing the system is especially
annoying if the system is configured such that hardware_enable() will
be triggered during boot.

Oppurtunistically rename @addr to @vmxon_pointer and use a named param
to reference it in the inline assembly.

Print 0xdeadbeef in the ultra-"rare" case that reading MSR_IA32_FEAT_CTL
also faults.

[*] https://lkml.kernel.org/r/20200226231615.13664-1-sean.j.christopherson@intel.com
	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200321193751.24985-4-sean.j.christopherson@intel.com>
	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 4f6ea0a87608e1b26ed26123ae7c42aaecdd2c6c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/vmx.c
index 833b3f7d7961,3aba51d782e2..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -2281,33 -2214,14 +2281,35 @@@ static __init int cpu_has_kvm_support(v
  
  static __init int vmx_disabled_by_bios(void)
  {
 -	return !boot_cpu_has(X86_FEATURE_MSR_IA32_FEAT_CTL) ||
 -	       !boot_cpu_has(X86_FEATURE_VMX);
 +	u64 msr;
 +
 +	rdmsrl(MSR_IA32_FEATURE_CONTROL, msr);
 +	if (msr & FEATURE_CONTROL_LOCKED) {
 +		/* launched w/ TXT and VMX disabled */
 +		if (!(msr & FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX)
 +			&& tboot_enabled())
 +			return 1;
 +		/* launched w/o TXT and VMX only enabled w/ TXT */
 +		if (!(msr & FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX)
 +			&& (msr & FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX)
 +			&& !tboot_enabled()) {
 +			printk(KERN_WARNING "kvm: disable TXT in the BIOS or "
 +				"activate TXT before enabling KVM\n");
 +			return 1;
 +		}
 +		/* launched w/o TXT and VMX disabled */
 +		if (!(msr & FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX)
 +			&& !tboot_enabled())
 +			return 1;
 +	}
 +
 +	return 0;
  }
  
- static void kvm_cpu_vmxon(u64 addr)
+ static int kvm_cpu_vmxon(u64 vmxon_pointer)
  {
+ 	u64 msr;
+ 
  	cr4_set_bits(X86_CR4_VMXE);
  	intel_pt_handle_vmx(1);
  
@@@ -2318,7 -2244,7 +2332,11 @@@ static int hardware_enable(void
  {
  	int cpu = raw_smp_processor_id();
  	u64 phys_addr = __pa(per_cpu(vmxarea, cpu));
++<<<<<<< HEAD
 +	u64 old, test_bits;
++=======
+ 	int r;
++>>>>>>> 4f6ea0a87608 (KVM: VMX: Gracefully handle faults on VMXON)
  
  	if (cr4_read_shadow() & X86_CR4_VMXE)
  		return -EBUSY;
@@@ -2335,29 -2261,10 +2353,36 @@@
  	INIT_LIST_HEAD(&per_cpu(blocked_vcpu_on_cpu, cpu));
  	spin_lock_init(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));
  
++<<<<<<< HEAD
 +	/*
 +	 * Now we can enable the vmclear operation in kdump
 +	 * since the loaded_vmcss_on_cpu list on this cpu
 +	 * has been initialized.
 +	 *
 +	 * Though the cpu is not in VMX operation now, there
 +	 * is no problem to enable the vmclear operation
 +	 * for the loaded_vmcss_on_cpu list is empty!
 +	 */
 +	crash_enable_local_vmclear(cpu);
 +
 +	rdmsrl(MSR_IA32_FEATURE_CONTROL, old);
 +
 +	test_bits = FEATURE_CONTROL_LOCKED;
 +	test_bits |= FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;
 +	if (tboot_enabled())
 +		test_bits |= FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX;
 +
 +	if ((old & test_bits) != test_bits) {
 +		/* enable and lock */
 +		wrmsrl(MSR_IA32_FEATURE_CONTROL, old | test_bits);
 +	}
 +	kvm_cpu_vmxon(phys_addr);
++=======
+ 	r = kvm_cpu_vmxon(phys_addr);
+ 	if (r)
+ 		return r;
+ 
++>>>>>>> 4f6ea0a87608 (KVM: VMX: Gracefully handle faults on VMXON)
  	if (enable_ept)
  		ept_sync_global();
  
* Unmerged path arch/x86/kvm/vmx/vmx.c
