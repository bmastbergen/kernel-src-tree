iwlwifi: mvm: scan: enable adaptive dwell in p2p

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Shahar S Matityahu <shahar.s.matityahu@intel.com>
commit 559897363ca84cf1e445aa237b56b1e531047c1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/55989736.failed

Align to the requirement update and support adaptive dwell in p2p scan.

	Signed-off-by: Shahar S Matityahu <shahar.s.matityahu@intel.com>
	Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
	Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
(cherry picked from commit 559897363ca84cf1e445aa237b56b1e531047c1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/intel/iwlwifi/mvm/scan.c
diff --cc drivers/net/wireless/intel/iwlwifi/mvm/scan.c
index 3e5455cef0ee,60edba558c99..000000000000
--- a/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/scan.c
@@@ -1430,6 -1586,92 +1430,95 @@@ iwl_mvm_umac_scan_cfg_channels(struct i
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void
+ iwl_mvm_umac_scan_cfg_channels_v4(struct iwl_mvm *mvm,
+ 				  struct ieee80211_channel **channels,
+ 				  struct iwl_scan_channel_params_v4 *cp,
+ 				  int n_channels, u32 flags,
+ 				  enum nl80211_iftype vif_type)
+ {
+ 	u8 *bitmap = cp->adwell_ch_override_bitmap;
+ 	size_t bitmap_n_entries = ARRAY_SIZE(cp->adwell_ch_override_bitmap);
+ 	int i;
+ 
+ 	for (i = 0; i < n_channels; i++) {
+ 		enum nl80211_band band = channels[i]->band;
+ 		struct iwl_scan_channel_cfg_umac *cfg =
+ 			&cp->channel_config[i];
+ 
+ 		cfg->flags = cpu_to_le32(flags);
+ 		cfg->v2.channel_num = channels[i]->hw_value;
+ 		cfg->v2.band = iwl_mvm_phy_band_from_nl80211(band);
+ 		cfg->v2.iter_count = 1;
+ 		cfg->v2.iter_interval = 0;
+ 
+ 		iwl_mvm_scan_ch_add_n_aps_override(vif_type,
+ 						   cfg->v2.channel_num,
+ 						   cfg->v2.band, bitmap,
+ 						   bitmap_n_entries);
+ 	}
+ }
+ 
+ static u8 iwl_mvm_scan_umac_chan_flags_v2(struct iwl_mvm *mvm,
+ 					  struct iwl_mvm_scan_params *params,
+ 					  struct ieee80211_vif *vif)
+ {
+ 	u8 flags = 0;
+ 
+ 	flags |= IWL_SCAN_CHANNEL_FLAG_ENABLE_CHAN_ORDER;
+ 
+ 	if (iwl_mvm_scan_use_ebs(mvm, vif))
+ 		flags |= IWL_SCAN_CHANNEL_FLAG_EBS |
+ 			IWL_SCAN_CHANNEL_FLAG_EBS_ACCURATE |
+ 			IWL_SCAN_CHANNEL_FLAG_CACHE_ADD;
+ 
+ 	/* set fragmented ebs for fragmented scan on HB channels */
+ 	if (iwl_mvm_is_scan_fragmented(params->hb_type))
+ 		flags |= IWL_SCAN_CHANNEL_FLAG_EBS_FRAG;
+ 
+ 	return flags;
+ }
+ 
+ static u16 iwl_mvm_scan_umac_flags_v2(struct iwl_mvm *mvm,
+ 				      struct iwl_mvm_scan_params *params,
+ 				      struct ieee80211_vif *vif,
+ 				      int type)
+ {
+ 	u16 flags = 0;
+ 
+ 	if (params->n_ssids == 0)
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_FORCE_PASSIVE;
+ 
+ 	if (iwl_mvm_is_scan_fragmented(params->type))
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC1;
+ 
+ 	if (iwl_mvm_is_scan_fragmented(params->hb_type))
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_FRAGMENTED_LMAC2;
+ 
+ 	if (params->pass_all)
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_PASS_ALL;
+ 	else
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_MATCH;
+ 
+ 	if (!iwl_mvm_is_regular_scan(params))
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_PERIODIC;
+ 
+ 	if (params->measurement_dwell ||
+ 	    mvm->sched_scan_pass_all == SCHED_SCAN_PASS_ALL_ENABLED)
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_NTFY_ITER_COMPLETE;
+ 
+ 	if (IWL_MVM_ADWELL_ENABLE)
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_ADAPTIVE_DWELL;
+ 
+ 	if (type == IWL_MVM_SCAN_SCHED || type == IWL_MVM_SCAN_NETDETECT)
+ 		flags |= IWL_UMAC_SCAN_GEN_FLAGS_V2_PREEMPTIVE;
+ 
+ 	return flags;
+ }
+ 
++>>>>>>> 559897363ca8 (iwlwifi: mvm: scan: enable adaptive dwell in p2p)
  static u16 iwl_mvm_scan_umac_flags(struct iwl_mvm *mvm,
  				   struct iwl_mvm_scan_params *params,
  				   struct ieee80211_vif *vif)
* Unmerged path drivers/net/wireless/intel/iwlwifi/mvm/scan.c
