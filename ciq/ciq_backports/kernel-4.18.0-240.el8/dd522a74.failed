Bluetooth: Handle LE devices during suspend

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
commit dd522a7429b07e4441871ae75ebbfcf53635bdd4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/dd522a74.failed

To handle LE devices, we must first disable passive scanning and
disconnect all connected devices. Once that is complete, we update the
whitelist and re-enable scanning

	Signed-off-by: Abhishek Pandit-Subedi <abhishekpandit@chromium.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
(cherry picked from commit dd522a7429b07e4441871ae75ebbfcf53635bdd4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/hci_request.c
diff --cc net/bluetooth/hci_request.c
index ef1f5ba85455,11624645cfcf..000000000000
--- a/net/bluetooth/hci_request.c
+++ b/net/bluetooth/hci_request.c
@@@ -647,18 -655,70 +650,76 @@@ void __hci_req_update_eir(struct hci_re
  
  void hci_req_add_le_scan_disable(struct hci_request *req)
  {
 -	struct hci_dev *hdev = req->hdev;
 +	struct hci_cp_le_set_scan_enable cp;
  
++<<<<<<< HEAD
 +	memset(&cp, 0, sizeof(cp));
 +	cp.enable = LE_SCAN_DISABLE;
 +	hci_req_add(req, HCI_OP_LE_SET_SCAN_ENABLE, sizeof(cp), &cp);
++=======
+ 	if (hdev->scanning_paused) {
+ 		bt_dev_dbg(hdev, "Scanning is paused for suspend");
+ 		return;
+ 	}
+ 
+ 	if (use_ext_scan(hdev)) {
+ 		struct hci_cp_le_set_ext_scan_enable cp;
+ 
+ 		memset(&cp, 0, sizeof(cp));
+ 		cp.enable = LE_SCAN_DISABLE;
+ 		hci_req_add(req, HCI_OP_LE_SET_EXT_SCAN_ENABLE, sizeof(cp),
+ 			    &cp);
+ 	} else {
+ 		struct hci_cp_le_set_scan_enable cp;
+ 
+ 		memset(&cp, 0, sizeof(cp));
+ 		cp.enable = LE_SCAN_DISABLE;
+ 		hci_req_add(req, HCI_OP_LE_SET_SCAN_ENABLE, sizeof(cp), &cp);
+ 	}
++>>>>>>> dd522a7429b0 (Bluetooth: Handle LE devices during suspend)
  }
  
- static void add_to_white_list(struct hci_request *req,
- 			      struct hci_conn_params *params)
+ static void del_from_white_list(struct hci_request *req, bdaddr_t *bdaddr,
+ 				u8 bdaddr_type)
+ {
+ 	struct hci_cp_le_del_from_white_list cp;
+ 
+ 	cp.bdaddr_type = bdaddr_type;
+ 	bacpy(&cp.bdaddr, bdaddr);
+ 
+ 	bt_dev_dbg(req->hdev, "Remove %pMR (0x%x) from whitelist", &cp.bdaddr,
+ 		   cp.bdaddr_type);
+ 	hci_req_add(req, HCI_OP_LE_DEL_FROM_WHITE_LIST, sizeof(cp), &cp);
+ }
+ 
+ /* Adds connection to white list if needed. On error, returns -1. */
+ static int add_to_white_list(struct hci_request *req,
+ 			     struct hci_conn_params *params, u8 *num_entries,
+ 			     bool allow_rpa)
  {
  	struct hci_cp_le_add_to_white_list cp;
+ 	struct hci_dev *hdev = req->hdev;
  
+ 	/* Already in white list */
+ 	if (hci_bdaddr_list_lookup(&hdev->le_white_list, &params->addr,
+ 				   params->addr_type))
+ 		return 0;
+ 
+ 	/* Select filter policy to accept all advertising */
+ 	if (*num_entries >= hdev->le_white_list_size)
+ 		return -1;
+ 
+ 	/* White list can not be used with RPAs */
+ 	if (!allow_rpa &&
+ 	    hci_find_irk_by_addr(hdev, &params->addr, params->addr_type)) {
+ 		return -1;
+ 	}
+ 
+ 	/* During suspend, only wakeable devices can be in whitelist */
+ 	if (hdev->suspended && !params->wakeable)
+ 		return 0;
+ 
+ 	*num_entries += 1;
  	cp.bdaddr_type = params->addr_type;
  	bacpy(&cp.bdaddr, &params->addr);
  
@@@ -804,20 -926,172 +851,189 @@@ void hci_req_add_le_passive_scan(struc
  	    (hdev->le_features[0] & HCI_LE_EXT_SCAN_POLICY))
  		filter_policy |= 0x02;
  
++<<<<<<< HEAD
 +	memset(&param_cp, 0, sizeof(param_cp));
 +	param_cp.type = LE_SCAN_PASSIVE;
 +	param_cp.interval = cpu_to_le16(hdev->le_scan_interval);
 +	param_cp.window = cpu_to_le16(hdev->le_scan_window);
 +	param_cp.own_address_type = own_addr_type;
 +	param_cp.filter_policy = filter_policy;
 +	hci_req_add(req, HCI_OP_LE_SET_SCAN_PARAM, sizeof(param_cp),
 +		    &param_cp);
 +
 +	memset(&enable_cp, 0, sizeof(enable_cp));
 +	enable_cp.enable = LE_SCAN_ENABLE;
 +	enable_cp.filter_dup = LE_SCAN_FILTER_DUP_ENABLE;
 +	hci_req_add(req, HCI_OP_LE_SET_SCAN_ENABLE, sizeof(enable_cp),
 +		    &enable_cp);
++=======
+ 	if (hdev->suspended) {
+ 		window = LE_SUSPEND_SCAN_WINDOW;
+ 		interval = LE_SUSPEND_SCAN_INTERVAL;
+ 	} else {
+ 		window = hdev->le_scan_window;
+ 		interval = hdev->le_scan_interval;
+ 	}
+ 
+ 	bt_dev_dbg(hdev, "LE passive scan with whitelist = %d", filter_policy);
+ 	hci_req_start_scan(req, LE_SCAN_PASSIVE, interval, window,
+ 			   own_addr_type, filter_policy);
+ }
+ 
+ static u8 get_adv_instance_scan_rsp_len(struct hci_dev *hdev, u8 instance)
+ {
+ 	struct adv_info *adv_instance;
+ 
+ 	/* Instance 0x00 always set local name */
+ 	if (instance == 0x00)
+ 		return 1;
+ 
+ 	adv_instance = hci_find_adv_instance(hdev, instance);
+ 	if (!adv_instance)
+ 		return 0;
+ 
+ 	/* TODO: Take into account the "appearance" and "local-name" flags here.
+ 	 * These are currently being ignored as they are not supported.
+ 	 */
+ 	return adv_instance->scan_rsp_len;
+ }
+ 
+ static void hci_req_clear_event_filter(struct hci_request *req)
+ {
+ 	struct hci_cp_set_event_filter f;
+ 
+ 	memset(&f, 0, sizeof(f));
+ 	f.flt_type = HCI_FLT_CLEAR_ALL;
+ 	hci_req_add(req, HCI_OP_SET_EVENT_FLT, 1, &f);
+ 
+ 	/* Update page scan state (since we may have modified it when setting
+ 	 * the event filter).
+ 	 */
+ 	__hci_req_update_scan(req);
+ }
+ 
+ static void hci_req_set_event_filter(struct hci_request *req)
+ {
+ 	struct bdaddr_list *b;
+ 	struct hci_cp_set_event_filter f;
+ 	struct hci_dev *hdev = req->hdev;
+ 	u8 scan;
+ 
+ 	/* Always clear event filter when starting */
+ 	hci_req_clear_event_filter(req);
+ 
+ 	list_for_each_entry(b, &hdev->wakeable, list) {
+ 		memset(&f, 0, sizeof(f));
+ 		bacpy(&f.addr_conn_flt.bdaddr, &b->bdaddr);
+ 		f.flt_type = HCI_FLT_CONN_SETUP;
+ 		f.cond_type = HCI_CONN_SETUP_ALLOW_BDADDR;
+ 		f.addr_conn_flt.auto_accept = HCI_CONN_SETUP_AUTO_ON;
+ 
+ 		bt_dev_dbg(hdev, "Adding event filters for %pMR", &b->bdaddr);
+ 		hci_req_add(req, HCI_OP_SET_EVENT_FLT, sizeof(f), &f);
+ 	}
+ 
+ 	scan = !list_empty(&hdev->wakeable) ? SCAN_PAGE : SCAN_DISABLED;
+ 	hci_req_add(req, HCI_OP_WRITE_SCAN_ENABLE, 1, &scan);
+ }
+ 
+ static void hci_req_config_le_suspend_scan(struct hci_request *req)
+ {
+ 	/* Can't change params without disabling first */
+ 	hci_req_add_le_scan_disable(req);
+ 
+ 	/* Configure params and enable scanning */
+ 	hci_req_add_le_passive_scan(req);
+ 
+ 	/* Block suspend notifier on response */
+ 	set_bit(SUSPEND_SCAN_ENABLE, req->hdev->suspend_tasks);
+ }
+ 
+ static void suspend_req_complete(struct hci_dev *hdev, u8 status, u16 opcode)
+ {
+ 	bt_dev_dbg(hdev, "Request complete opcode=0x%x, status=0x%x", opcode,
+ 		   status);
+ 	if (test_and_clear_bit(SUSPEND_SCAN_ENABLE, hdev->suspend_tasks) ||
+ 	    test_and_clear_bit(SUSPEND_SCAN_DISABLE, hdev->suspend_tasks)) {
+ 		wake_up(&hdev->suspend_wait_q);
+ 	}
+ }
+ 
+ /* Call with hci_dev_lock */
+ void hci_req_prepare_suspend(struct hci_dev *hdev, enum suspended_state next)
+ {
+ 	struct hci_conn *conn;
+ 	struct hci_request req;
+ 	u8 page_scan;
+ 	int disconnect_counter;
+ 
+ 	if (next == hdev->suspend_state) {
+ 		bt_dev_dbg(hdev, "Same state before and after: %d", next);
+ 		goto done;
+ 	}
+ 
+ 	hdev->suspend_state = next;
+ 	hci_req_init(&req, hdev);
+ 
+ 	if (next == BT_SUSPEND_DISCONNECT) {
+ 		/* Mark device as suspended */
+ 		hdev->suspended = true;
+ 
+ 		/* Disable page scan */
+ 		page_scan = SCAN_DISABLED;
+ 		hci_req_add(&req, HCI_OP_WRITE_SCAN_ENABLE, 1, &page_scan);
+ 
+ 		/* Disable LE passive scan */
+ 		hci_req_add_le_scan_disable(&req);
+ 
+ 		/* Mark task needing completion */
+ 		set_bit(SUSPEND_SCAN_DISABLE, hdev->suspend_tasks);
+ 
+ 		/* Prevent disconnects from causing scanning to be re-enabled */
+ 		hdev->scanning_paused = true;
+ 
+ 		/* Run commands before disconnecting */
+ 		hci_req_run(&req, suspend_req_complete);
+ 
+ 		disconnect_counter = 0;
+ 		/* Soft disconnect everything (power off) */
+ 		list_for_each_entry(conn, &hdev->conn_hash.list, list) {
+ 			hci_disconnect(conn, HCI_ERROR_REMOTE_POWER_OFF);
+ 			disconnect_counter++;
+ 		}
+ 
+ 		if (disconnect_counter > 0) {
+ 			bt_dev_dbg(hdev,
+ 				   "Had %d disconnects. Will wait on them",
+ 				   disconnect_counter);
+ 			set_bit(SUSPEND_DISCONNECTING, hdev->suspend_tasks);
+ 		}
+ 	} else if (next == BT_SUSPEND_COMPLETE) {
+ 		/* Unpause to take care of updating scanning params */
+ 		hdev->scanning_paused = false;
+ 		/* Enable event filter for paired devices */
+ 		hci_req_set_event_filter(&req);
+ 		/* Enable passive scan at lower duty cycle */
+ 		hci_req_config_le_suspend_scan(&req);
+ 		/* Pause scan changes again. */
+ 		hdev->scanning_paused = true;
+ 		hci_req_run(&req, suspend_req_complete);
+ 	} else {
+ 		hdev->suspended = false;
+ 		hdev->scanning_paused = false;
+ 
+ 		hci_req_clear_event_filter(&req);
+ 		/* Reset passive/background scanning to normal */
+ 		hci_req_config_le_suspend_scan(&req);
+ 		hci_req_run(&req, suspend_req_complete);
+ 	}
+ 
+ 	hdev->suspend_state = next;
+ 
+ done:
+ 	clear_bit(SUSPEND_PREPARE_NOTIFIER, hdev->suspend_tasks);
+ 	wake_up(&hdev->suspend_wait_q);
++>>>>>>> dd522a7429b0 (Bluetooth: Handle LE devices during suspend)
  }
  
  static u8 get_cur_adv_instance_scan_rsp_len(struct hci_dev *hdev)
diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index b46e3ee436f3..bea6c78bebdf 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -539,6 +539,7 @@ struct hci_conn_params {
 
 	struct hci_conn *conn;
 	bool explicit_connect;
+	bool wakeable;
 };
 
 extern struct list_head hci_dev_list;
* Unmerged path net/bluetooth/hci_request.c
