libbpf: Expose BPF program's function name

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Andrii Nakryiko <andriin@fb.com>
commit 01af3bf06755dc5cda7050fe5d898998e5775e63
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/01af3bf0.failed

Add APIs to get BPF program function name, as opposed to bpf_program__title(),
which returns BPF program function's section name. Function name has a benefit
of being a valid C identifier and uniquely identifies a specific BPF program,
while section name can be duplicated across multiple independent BPF programs.

Add also bpf_object__find_program_by_name(), similar to
bpf_object__find_program_by_title(), to facilitate looking up BPF programs by
their C function names.

Convert one of selftests to new API for look up.

	Signed-off-by: Andrii Nakryiko <andriin@fb.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Martin KaFai Lau <kafai@fb.com>
Link: https://lore.kernel.org/bpf/20191214014341.3442258-9-andriin@fb.com
(cherry picked from commit 01af3bf06755dc5cda7050fe5d898998e5775e63)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
#	tools/lib/bpf/libbpf.map
diff --cc tools/lib/bpf/libbpf.c
index 729a06f61573,e7a6b57d849c..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -1392,10 -1383,11 +1392,15 @@@ static int bpf_object__init_user_btf_ma
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int bpf_object__init_maps(struct bpf_object *obj, bool relaxed_maps,
 +				 const char *pin_root_path)
++=======
+ static int bpf_object__init_maps(struct bpf_object *obj,
+ 				 const struct bpf_object_open_opts *opts)
++>>>>>>> 01af3bf06755 (libbpf: Expose BPF program's function name)
  {
 -	const char *pin_root_path = OPTS_GET(opts, pin_root_path, NULL);
 -	bool strict = !OPTS_GET(opts, relaxed_maps, false);
 +	bool strict = !relaxed_maps;
  	int err;
  
  	err = bpf_object__init_user_maps(obj, strict);
@@@ -3931,11 -3902,13 +3949,11 @@@ bpf_object__load_progs(struct bpf_objec
  	return 0;
  }
  
 -static int libbpf_find_attach_btf_id(const char *name,
 -				     enum bpf_attach_type attach_type,
 -				     __u32 attach_prog_fd);
  static struct bpf_object *
  __bpf_object__open(const char *path, const void *obj_buf, size_t obj_buf_sz,
- 		   struct bpf_object_open_opts *opts)
+ 		   const struct bpf_object_open_opts *opts)
  {
 +	const char *pin_root_path;
  	struct bpf_program *prog;
  	struct bpf_object *obj;
  	const char *obj_name;
diff --cc tools/lib/bpf/libbpf.map
index 3ca7228af37e,5a7630748eeb..000000000000
--- a/tools/lib/bpf/libbpf.map
+++ b/tools/lib/bpf/libbpf.map
@@@ -188,9 -197,23 +188,24 @@@ LIBBPF_0.0.4 
  		bpf_map__get_pin_path;
  		bpf_map__is_pinned;
  		bpf_map__set_pin_path;
 -		bpf_object__open_file;
 -		bpf_object__open_mem;
 -		bpf_program__attach_trace;
  		bpf_program__get_expected_attach_type;
  		bpf_program__get_type;
 -		bpf_program__is_tracing;
 -		bpf_program__set_tracing;
 +		bpf_get_link_xdp_info;
  		bpf_program__size;
++<<<<<<< HEAD
 +		bpf_btf_get_next_id;
 +} LIBBPF_0.0.3;
++=======
+ 		btf__find_by_name_kind;
+ 		libbpf_find_vmlinux_btf_id;
+ } LIBBPF_0.0.5;
+ 
+ LIBBPF_0.0.7 {
+ 	global:
+ 		btf_dump__emit_type_decl;
+ 		bpf_object__find_program_by_name;
+ 		bpf_program__attach;
+ 		bpf_program__name;
+ 		btf__align_of;
+ } LIBBPF_0.0.6;
++>>>>>>> 01af3bf06755 (libbpf: Expose BPF program's function name)
* Unmerged path tools/lib/bpf/libbpf.c
diff --git a/tools/lib/bpf/libbpf.h b/tools/lib/bpf/libbpf.h
index e454ceec9fa2..42a05f9af0f8 100644
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@ -89,10 +89,10 @@ struct bpf_object_open_opts {
 
 LIBBPF_API struct bpf_object *bpf_object__open(const char *path);
 LIBBPF_API struct bpf_object *
-bpf_object__open_file(const char *path, struct bpf_object_open_opts *opts);
+bpf_object__open_file(const char *path, const struct bpf_object_open_opts *opts);
 LIBBPF_API struct bpf_object *
 bpf_object__open_mem(const void *obj_buf, size_t obj_buf_sz,
-		     struct bpf_object_open_opts *opts);
+		     const struct bpf_object_open_opts *opts);
 
 /* deprecated bpf_object__open variants */
 LIBBPF_API struct bpf_object *
@@ -131,6 +131,7 @@ struct bpf_object_load_attr {
 LIBBPF_API int bpf_object__load(struct bpf_object *obj);
 LIBBPF_API int bpf_object__load_xattr(struct bpf_object_load_attr *attr);
 LIBBPF_API int bpf_object__unload(struct bpf_object *obj);
+
 LIBBPF_API const char *bpf_object__name(const struct bpf_object *obj);
 LIBBPF_API unsigned int bpf_object__kversion(const struct bpf_object *obj);
 
@@ -141,6 +142,9 @@ LIBBPF_API int bpf_object__btf_fd(const struct bpf_object *obj);
 LIBBPF_API struct bpf_program *
 bpf_object__find_program_by_title(const struct bpf_object *obj,
 				  const char *title);
+LIBBPF_API struct bpf_program *
+bpf_object__find_program_by_name(const struct bpf_object *obj,
+				 const char *name);
 
 LIBBPF_API struct bpf_object *bpf_object__next(struct bpf_object *prev);
 #define bpf_object__for_each_safe(pos, tmp)			\
@@ -182,6 +186,7 @@ LIBBPF_API void *bpf_program__priv(const struct bpf_program *prog);
 LIBBPF_API void bpf_program__set_ifindex(struct bpf_program *prog,
 					 __u32 ifindex);
 
+LIBBPF_API const char *bpf_program__name(const struct bpf_program *prog);
 LIBBPF_API const char *bpf_program__title(const struct bpf_program *prog,
 					  bool needs_copy);
 
* Unmerged path tools/lib/bpf/libbpf.map
diff --git a/tools/testing/selftests/bpf/prog_tests/rdonly_maps.c b/tools/testing/selftests/bpf/prog_tests/rdonly_maps.c
index 9bf9de0aaeea..e325496b29e3 100644
--- a/tools/testing/selftests/bpf/prog_tests/rdonly_maps.c
+++ b/tools/testing/selftests/bpf/prog_tests/rdonly_maps.c
@@ -16,14 +16,11 @@ struct rdonly_map_subtest {
 
 void test_rdonly_maps(void)
 {
-	const char *prog_name_skip_loop = "raw_tracepoint/sys_enter:skip_loop";
-	const char *prog_name_part_loop = "raw_tracepoint/sys_enter:part_loop";
-	const char *prog_name_full_loop = "raw_tracepoint/sys_enter:full_loop";
 	const char *file = "test_rdonly_maps.o";
 	struct rdonly_map_subtest subtests[] = {
-		{ "skip loop", prog_name_skip_loop, 0, 0 },
-		{ "part loop", prog_name_part_loop, 3, 2 + 3 + 4 },
-		{ "full loop", prog_name_full_loop, 4, 2 + 3 + 4 + 5 },
+		{ "skip loop", "skip_loop", 0, 0 },
+		{ "part loop", "part_loop", 3, 2 + 3 + 4 },
+		{ "full loop", "full_loop", 4, 2 + 3 + 4 + 5 },
 	};
 	int i, err, zero = 0, duration = 0;
 	struct bpf_link *link = NULL;
@@ -54,7 +51,7 @@ void test_rdonly_maps(void)
 		if (!test__start_subtest(t->subtest_name))
 			continue;
 
-		prog = bpf_object__find_program_by_title(obj, t->prog_name);
+		prog = bpf_object__find_program_by_name(obj, t->prog_name);
 		if (CHECK(!prog, "find_prog", "prog '%s' not found\n",
 			  t->prog_name))
 			goto cleanup;
