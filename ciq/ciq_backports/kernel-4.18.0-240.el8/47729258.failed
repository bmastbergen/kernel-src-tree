perf tools: Move 'struct events_stats' and prototypes to separate header

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 4772925885dac93aa5f00d1c1da93277778099cd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/47729258.failed

This will allow us to untangle the header dependency a bit more, as some
places will not need event.h anymore.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Jiri Olsa <jolsa@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
Link: https://lkml.kernel.org/n/tip-enqncj29ovzaat3cd9203rwl@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 4772925885dac93aa5f00d1c1da93277778099cd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/event.h
#	tools/perf/util/evlist.h
#	tools/perf/util/hist.h
diff --cc tools/perf/util/event.h
index ba0ec1b6aad3,47ad81d47b1a..000000000000
--- a/tools/perf/util/event.h
+++ b/tools/perf/util/event.h
@@@ -149,41 -151,6 +149,44 @@@ struct perf_sample 
  	 PERF_MEM_S(LOCK, NA) |\
  	 PERF_MEM_S(TLB, NA))
  
++<<<<<<< HEAD
 +struct build_id_event {
 +	struct perf_event_header header;
 +	pid_t			 pid;
 +	u8			 build_id[PERF_ALIGN(BUILD_ID_SIZE, sizeof(u64))];
 +	char			 filename[];
 +};
 +
 +enum perf_user_event_type { /* above any possible kernel type */
 +	PERF_RECORD_USER_TYPE_START		= 64,
 +	PERF_RECORD_HEADER_ATTR			= 64,
 +	PERF_RECORD_HEADER_EVENT_TYPE		= 65, /* deprecated */
 +	PERF_RECORD_HEADER_TRACING_DATA		= 66,
 +	PERF_RECORD_HEADER_BUILD_ID		= 67,
 +	PERF_RECORD_FINISHED_ROUND		= 68,
 +	PERF_RECORD_ID_INDEX			= 69,
 +	PERF_RECORD_AUXTRACE_INFO		= 70,
 +	PERF_RECORD_AUXTRACE			= 71,
 +	PERF_RECORD_AUXTRACE_ERROR		= 72,
 +	PERF_RECORD_THREAD_MAP			= 73,
 +	PERF_RECORD_CPU_MAP			= 74,
 +	PERF_RECORD_STAT_CONFIG			= 75,
 +	PERF_RECORD_STAT			= 76,
 +	PERF_RECORD_STAT_ROUND			= 77,
 +	PERF_RECORD_EVENT_UPDATE		= 78,
 +	PERF_RECORD_TIME_CONV			= 79,
 +	PERF_RECORD_HEADER_FEATURE		= 80,
 +	PERF_RECORD_COMPRESSED			= 81,
 +	PERF_RECORD_HEADER_MAX
 +};
 +
 +enum auxtrace_error_type {
 +	PERF_AUXTRACE_ERROR_ITRACE  = 1,
 +	PERF_AUXTRACE_ERROR_MAX
 +};
 +
++=======
++>>>>>>> 4772925885da (perf tools: Move 'struct events_stats' and prototypes to separate header)
  /* Attribute type for custom synthesized events */
  #define PERF_TYPE_SYNTH		(INT_MAX + 1U)
  
@@@ -305,225 -272,6 +308,228 @@@ static inline void *perf_synth__raw_dat
  
  #define perf_sample__bad_synth_size(s, d) ((s)->raw_size < sizeof(d) - 4)
  
++<<<<<<< HEAD
 +/*
 + * The kernel collects the number of events it couldn't send in a stretch and
 + * when possible sends this number in a PERF_RECORD_LOST event. The number of
 + * such "chunks" of lost events is stored in .nr_events[PERF_EVENT_LOST] while
 + * total_lost tells exactly how many events the kernel in fact lost, i.e. it is
 + * the sum of all struct lost_event.lost fields reported.
 + *
 + * The kernel discards mixed up samples and sends the number in a
 + * PERF_RECORD_LOST_SAMPLES event. The number of lost-samples events is stored
 + * in .nr_events[PERF_RECORD_LOST_SAMPLES] while total_lost_samples tells
 + * exactly how many samples the kernel in fact dropped, i.e. it is the sum of
 + * all struct lost_samples_event.lost fields reported.
 + *
 + * The total_period is needed because by default auto-freq is used, so
 + * multipling nr_events[PERF_EVENT_SAMPLE] by a frequency isn't possible to get
 + * the total number of low level events, it is necessary to to sum all struct
 + * sample_event.period and stash the result in total_period.
 + */
 +struct events_stats {
 +	u64 total_period;
 +	u64 total_non_filtered_period;
 +	u64 total_lost;
 +	u64 total_lost_samples;
 +	u64 total_aux_lost;
 +	u64 total_aux_partial;
 +	u64 total_invalid_chains;
 +	u32 nr_events[PERF_RECORD_HEADER_MAX];
 +	u32 nr_non_filtered_samples;
 +	u32 nr_lost_warned;
 +	u32 nr_unknown_events;
 +	u32 nr_invalid_chains;
 +	u32 nr_unknown_id;
 +	u32 nr_unprocessable_samples;
 +	u32 nr_auxtrace_errors[PERF_AUXTRACE_ERROR_MAX];
 +	u32 nr_proc_map_timeout;
 +};
 +
++=======
++>>>>>>> 4772925885da (perf tools: Move 'struct events_stats' and prototypes to separate header)
 +enum {
 +	PERF_CPU_MAP__CPUS = 0,
 +	PERF_CPU_MAP__MASK = 1,
 +};
 +
 +struct cpu_map_entries {
 +	u16	nr;
 +	u16	cpu[];
 +};
 +
 +struct cpu_map_mask {
 +	u16	nr;
 +	u16	long_size;
 +	unsigned long mask[];
 +};
 +
 +struct cpu_map_data {
 +	u16	type;
 +	char	data[];
 +};
 +
 +struct cpu_map_event {
 +	struct perf_event_header	header;
 +	struct cpu_map_data		data;
 +};
 +
 +struct attr_event {
 +	struct perf_event_header header;
 +	struct perf_event_attr attr;
 +	u64 id[];
 +};
 +
 +enum {
 +	PERF_EVENT_UPDATE__UNIT  = 0,
 +	PERF_EVENT_UPDATE__SCALE = 1,
 +	PERF_EVENT_UPDATE__NAME  = 2,
 +	PERF_EVENT_UPDATE__CPUS  = 3,
 +};
 +
 +struct event_update_event_cpus {
 +	struct cpu_map_data cpus;
 +};
 +
 +struct event_update_event_scale {
 +	double scale;
 +};
 +
 +struct event_update_event {
 +	struct perf_event_header header;
 +	u64 type;
 +	u64 id;
 +
 +	char data[];
 +};
 +
 +#define MAX_EVENT_NAME 64
 +
 +struct perf_trace_event_type {
 +	u64	event_id;
 +	char	name[MAX_EVENT_NAME];
 +};
 +
 +struct event_type_event {
 +	struct perf_event_header header;
 +	struct perf_trace_event_type event_type;
 +};
 +
 +struct tracing_data_event {
 +	struct perf_event_header header;
 +	u32 size;
 +};
 +
 +struct id_index_entry {
 +	u64 id;
 +	u64 idx;
 +	u64 cpu;
 +	u64 tid;
 +};
 +
 +struct id_index_event {
 +	struct perf_event_header header;
 +	u64 nr;
 +	struct id_index_entry entries[0];
 +};
 +
 +struct auxtrace_info_event {
 +	struct perf_event_header header;
 +	u32 type;
 +	u32 reserved__; /* For alignment */
 +	u64 priv[];
 +};
 +
 +struct auxtrace_event {
 +	struct perf_event_header header;
 +	u64 size;
 +	u64 offset;
 +	u64 reference;
 +	u32 idx;
 +	u32 tid;
 +	u32 cpu;
 +	u32 reserved__; /* For alignment */
 +};
 +
 +#define MAX_AUXTRACE_ERROR_MSG 64
 +
 +struct auxtrace_error_event {
 +	struct perf_event_header header;
 +	u32 type;
 +	u32 code;
 +	u32 cpu;
 +	u32 pid;
 +	u32 tid;
 +	u32 fmt;
 +	u64 ip;
 +	u64 time;
 +	char msg[MAX_AUXTRACE_ERROR_MSG];
 +};
 +
 +struct aux_event {
 +	struct perf_event_header header;
 +	u64	aux_offset;
 +	u64	aux_size;
 +	u64	flags;
 +};
 +
 +struct itrace_start_event {
 +	struct perf_event_header header;
 +	u32 pid, tid;
 +};
 +
 +struct context_switch_event {
 +	struct perf_event_header header;
 +	u32 next_prev_pid;
 +	u32 next_prev_tid;
 +};
 +
 +struct thread_map_event_entry {
 +	u64	pid;
 +	char	comm[16];
 +};
 +
 +struct thread_map_event {
 +	struct perf_event_header	header;
 +	u64				nr;
 +	struct thread_map_event_entry	entries[];
 +};
 +
 +enum {
 +	PERF_STAT_CONFIG_TERM__AGGR_MODE	= 0,
 +	PERF_STAT_CONFIG_TERM__INTERVAL		= 1,
 +	PERF_STAT_CONFIG_TERM__SCALE		= 2,
 +	PERF_STAT_CONFIG_TERM__MAX		= 3,
 +};
 +
 +struct stat_config_event_entry {
 +	u64	tag;
 +	u64	val;
 +};
 +
 +struct stat_config_event {
 +	struct perf_event_header	header;
 +	u64				nr;
 +	struct stat_config_event_entry	data[];
 +};
 +
 +struct stat_event {
 +	struct perf_event_header	header;
 +
 +	u64	id;
 +	u32	cpu;
 +	u32	thread;
 +
 +	union {
 +		struct {
 +			u64 val;
 +			u64 ena;
 +			u64 run;
 +		};
 +		u64 values[3];
 +	};
 +};
 +
  enum {
  	PERF_STAT_ROUND_TYPE__INTERVAL	= 0,
  	PERF_STAT_ROUND_TYPE__FINAL	= 1,
diff --cc tools/perf/util/evlist.h
index 49354fe24d5f,a55f0f2546e5..000000000000
--- a/tools/perf/util/evlist.h
+++ b/tools/perf/util/evlist.h
@@@ -8,11 -8,10 +8,16 @@@
  #include <linux/list.h>
  #include <api/fd/array.h>
  #include <stdio.h>
++<<<<<<< HEAD
 +#include "../perf.h"
 +#include "event.h"
++=======
+ #include <internal/evlist.h>
+ #include "events_stats.h"
++>>>>>>> 4772925885da (perf tools: Move 'struct events_stats' and prototypes to separate header)
  #include "evsel.h"
  #include "mmap.h"
 +#include "util.h"
  #include <signal.h>
  #include <unistd.h>
  
diff --cc tools/perf/util/hist.h
index 24635f36148d,34803e33dc80..000000000000
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@@ -6,9 -6,8 +6,12 @@@
  #include <linux/types.h>
  #include <pthread.h>
  #include "evsel.h"
- #include "header.h"
  #include "color.h"
++<<<<<<< HEAD
 +#include "ui/progress.h"
++=======
+ #include "events_stats.h"
++>>>>>>> 4772925885da (perf tools: Move 'struct events_stats' and prototypes to separate header)
  
  struct hist_entry;
  struct hist_entry_ops;
diff --git a/tools/perf/util/auxtrace.h b/tools/perf/util/auxtrace.h
index 48376e23c130..60497aa8810b 100644
--- a/tools/perf/util/auxtrace.h
+++ b/tools/perf/util/auxtrace.h
@@ -40,6 +40,11 @@ struct record_opts;
 struct auxtrace_info_event;
 struct events_stats;
 
+enum auxtrace_error_type {
+       PERF_AUXTRACE_ERROR_ITRACE  = 1,
+       PERF_AUXTRACE_ERROR_MAX
+};
+
 /* Auxtrace records must have the same alignment as perf event records */
 #define PERF_AUXTRACE_RECORD_ALIGNMENT 8
 
* Unmerged path tools/perf/util/event.h
diff --git a/tools/perf/util/events_stats.h b/tools/perf/util/events_stats.h
new file mode 100644
index 000000000000..859cb34fcff2
--- /dev/null
+++ b/tools/perf/util/events_stats.h
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __PERF_EVENTS_STATS_
+#define __PERF_EVENTS_STATS_
+
+#include <stdio.h>
+#include <perf/event.h>
+#include <linux/types.h>
+#include "auxtrace.h"
+
+/*
+ * The kernel collects the number of events it couldn't send in a stretch and
+ * when possible sends this number in a PERF_RECORD_LOST event. The number of
+ * such "chunks" of lost events is stored in .nr_events[PERF_EVENT_LOST] while
+ * total_lost tells exactly how many events the kernel in fact lost, i.e. it is
+ * the sum of all struct perf_record_lost.lost fields reported.
+ *
+ * The kernel discards mixed up samples and sends the number in a
+ * PERF_RECORD_LOST_SAMPLES event. The number of lost-samples events is stored
+ * in .nr_events[PERF_RECORD_LOST_SAMPLES] while total_lost_samples tells
+ * exactly how many samples the kernel in fact dropped, i.e. it is the sum of
+ * all struct perf_record_lost_samples.lost fields reported.
+ *
+ * The total_period is needed because by default auto-freq is used, so
+ * multipling nr_events[PERF_EVENT_SAMPLE] by a frequency isn't possible to get
+ * the total number of low level events, it is necessary to to sum all struct
+ * perf_record_sample.period and stash the result in total_period.
+ */
+struct events_stats {
+	u64 total_period;
+	u64 total_non_filtered_period;
+	u64 total_lost;
+	u64 total_lost_samples;
+	u64 total_aux_lost;
+	u64 total_aux_partial;
+	u64 total_invalid_chains;
+	u32 nr_events[PERF_RECORD_HEADER_MAX];
+	u32 nr_non_filtered_samples;
+	u32 nr_lost_warned;
+	u32 nr_unknown_events;
+	u32 nr_invalid_chains;
+	u32 nr_unknown_id;
+	u32 nr_unprocessable_samples;
+	u32 nr_auxtrace_errors[PERF_AUXTRACE_ERROR_MAX];
+	u32 nr_proc_map_timeout;
+};
+
+void events_stats__inc(struct events_stats *stats, u32 type);
+
+size_t events_stats__fprintf(struct events_stats *stats, FILE *fp);
+
+#endif /* __PERF_EVENTS_STATS_ */
* Unmerged path tools/perf/util/evlist.h
* Unmerged path tools/perf/util/hist.h
diff --git a/tools/perf/util/sort.h b/tools/perf/util/sort.h
index 5af9db62c314..81e0f3c877ee 100644
--- a/tools/perf/util/sort.h
+++ b/tools/perf/util/sort.h
@@ -9,7 +9,6 @@
 #include "symbol_conf.h"
 #include "callchain.h"
 #include "values.h"
-
 #include "hist.h"
 
 struct option;
