netdevsim: add ACL trap reporting cookie as a metadata

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Pirko <jiri@mellanox.com>
commit d3cbb907ae57fe5da314b51d949b617b538bdeae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/d3cbb907.failed

Add new trap ACL which reports flow action cookie in a metadata. Allow
used to setup the cookie using debugfs file.

	Signed-off-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Reviewed-by: Jakub Kicinski <kuba@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d3cbb907ae57fe5da314b51d949b617b538bdeae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/netdevsim/dev.c
#	drivers/net/netdevsim/netdevsim.h
diff --cc drivers/net/netdevsim/dev.c
index 8eedf9620b5e,f81c47377f32..000000000000
--- a/drivers/net/netdevsim/dev.c
+++ b/drivers/net/netdevsim/dev.c
@@@ -71,9 -72,101 +72,101 @@@ static const struct file_operations nsi
  	.llseek = generic_file_llseek,
  };
  
+ static ssize_t nsim_dev_trap_fa_cookie_read(struct file *file,
+ 					    char __user *data,
+ 					    size_t count, loff_t *ppos)
+ {
+ 	struct nsim_dev *nsim_dev = file->private_data;
+ 	struct flow_action_cookie *fa_cookie;
+ 	unsigned int buf_len;
+ 	ssize_t ret;
+ 	char *buf;
+ 
+ 	spin_lock(&nsim_dev->fa_cookie_lock);
+ 	fa_cookie = nsim_dev->fa_cookie;
+ 	if (!fa_cookie) {
+ 		ret = -EINVAL;
+ 		goto errout;
+ 	}
+ 	buf_len = fa_cookie->cookie_len * 2;
+ 	buf = kmalloc(buf_len, GFP_ATOMIC);
+ 	if (!buf) {
+ 		ret = -ENOMEM;
+ 		goto errout;
+ 	}
+ 	bin2hex(buf, fa_cookie->cookie, fa_cookie->cookie_len);
+ 	spin_unlock(&nsim_dev->fa_cookie_lock);
+ 
+ 	ret = simple_read_from_buffer(data, count, ppos, buf, buf_len);
+ 
+ 	kfree(buf);
+ 	return ret;
+ 
+ errout:
+ 	spin_unlock(&nsim_dev->fa_cookie_lock);
+ 	return ret;
+ }
+ 
+ static ssize_t nsim_dev_trap_fa_cookie_write(struct file *file,
+ 					     const char __user *data,
+ 					     size_t count, loff_t *ppos)
+ {
+ 	struct nsim_dev *nsim_dev = file->private_data;
+ 	struct flow_action_cookie *fa_cookie;
+ 	size_t cookie_len;
+ 	ssize_t ret;
+ 	char *buf;
+ 
+ 	if (*ppos != 0)
+ 		return -EINVAL;
+ 	cookie_len = (count - 1) / 2;
+ 	if ((count - 1) % 2)
+ 		return -EINVAL;
+ 	buf = kmalloc(count, GFP_KERNEL | __GFP_NOWARN);
+ 	if (!buf)
+ 		return -ENOMEM;
+ 
+ 	ret = simple_write_to_buffer(buf, count, ppos, data, count);
+ 	if (ret < 0)
+ 		goto free_buf;
+ 
+ 	fa_cookie = kmalloc(sizeof(*fa_cookie) + cookie_len,
+ 			    GFP_KERNEL | __GFP_NOWARN);
+ 	if (!fa_cookie) {
+ 		ret = -ENOMEM;
+ 		goto free_buf;
+ 	}
+ 
+ 	fa_cookie->cookie_len = cookie_len;
+ 	ret = hex2bin(fa_cookie->cookie, buf, cookie_len);
+ 	if (ret)
+ 		goto free_fa_cookie;
+ 	kfree(buf);
+ 
+ 	spin_lock(&nsim_dev->fa_cookie_lock);
+ 	kfree(nsim_dev->fa_cookie);
+ 	nsim_dev->fa_cookie = fa_cookie;
+ 	spin_unlock(&nsim_dev->fa_cookie_lock);
+ 
+ 	return count;
+ 
+ free_fa_cookie:
+ 	kfree(fa_cookie);
+ free_buf:
+ 	kfree(buf);
+ 	return ret;
+ }
+ 
+ static const struct file_operations nsim_dev_trap_fa_cookie_fops = {
+ 	.open = simple_open,
+ 	.read = nsim_dev_trap_fa_cookie_read,
+ 	.write = nsim_dev_trap_fa_cookie_write,
+ 	.llseek = generic_file_llseek,
+ };
+ 
  static int nsim_dev_debugfs_init(struct nsim_dev *nsim_dev)
  {
 -	char dev_ddir_name[sizeof(DRV_NAME) + 10];
 +	char dev_ddir_name[16];
  
  	sprintf(dev_ddir_name, DRV_NAME "%u", nsim_dev->nsim_bus_dev->dev.id);
  	nsim_dev->ddir = debugfs_create_dir(dev_ddir_name, nsim_dev_ddir);
@@@ -88,8 -181,17 +181,22 @@@
  			   &nsim_dev->max_macs);
  	debugfs_create_bool("test1", 0600, nsim_dev->ddir,
  			    &nsim_dev->test1);
++<<<<<<< HEAD
 +	debugfs_create_file("take_snapshot", 0200, nsim_dev->ddir, nsim_dev,
 +			    &nsim_dev_take_snapshot_fops);
++=======
+ 	nsim_dev->take_snapshot = debugfs_create_file("take_snapshot",
+ 						      0200,
+ 						      nsim_dev->ddir,
+ 						      nsim_dev,
+ 						&nsim_dev_take_snapshot_fops);
+ 	debugfs_create_bool("dont_allow_reload", 0600, nsim_dev->ddir,
+ 			    &nsim_dev->dont_allow_reload);
+ 	debugfs_create_bool("fail_reload", 0600, nsim_dev->ddir,
+ 			    &nsim_dev->fail_reload);
+ 	debugfs_create_file("trap_flow_action_cookie", 0600, nsim_dev->ddir,
+ 			    nsim_dev, &nsim_dev_trap_fa_cookie_fops);
++>>>>>>> d3cbb907ae57 (netdevsim: add ACL trap reporting cookie as a metadata)
  	return 0;
  }
  
@@@ -428,10 -491,12 +548,17 @@@ static void nsim_dev_trap_report(struc
  		 * softIRQs to prevent lockdep from complaining about
  		 * "incosistent lock state".
  		 */
- 		local_bh_disable();
+ 
+ 		spin_lock_bh(&nsim_dev->fa_cookie_lock);
+ 		fa_cookie = has_fa_cookie ? nsim_dev->fa_cookie : NULL;
  		devlink_trap_report(devlink, skb, nsim_trap_item->trap_ctx,
++<<<<<<< HEAD
 +				    &nsim_dev_port->devlink_port);
 +		local_bh_enable();
++=======
+ 				    &nsim_dev_port->devlink_port, fa_cookie);
+ 		spin_unlock_bh(&nsim_dev->fa_cookie_lock);
++>>>>>>> d3cbb907ae57 (netdevsim: add ACL trap reporting cookie as a metadata)
  		consume_skb(skb);
  	}
  	spin_unlock(&nsim_trap_data->trap_lock);
@@@ -845,6 -818,169 +972,172 @@@ err_port_del_all
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int nsim_dev_reload_create(struct nsim_dev *nsim_dev,
+ 				  struct netlink_ext_ack *extack)
+ {
+ 	struct nsim_bus_dev *nsim_bus_dev = nsim_dev->nsim_bus_dev;
+ 	struct devlink *devlink;
+ 	int err;
+ 
+ 	devlink = priv_to_devlink(nsim_dev);
+ 	nsim_dev = devlink_priv(devlink);
+ 	INIT_LIST_HEAD(&nsim_dev->port_list);
+ 	mutex_init(&nsim_dev->port_list_lock);
+ 	nsim_dev->fw_update_status = true;
+ 
+ 	nsim_dev->fib_data = nsim_fib_create(devlink, extack);
+ 	if (IS_ERR(nsim_dev->fib_data))
+ 		return PTR_ERR(nsim_dev->fib_data);
+ 
+ 	nsim_devlink_param_load_driverinit_values(devlink);
+ 
+ 	err = nsim_dev_dummy_region_init(nsim_dev, devlink);
+ 	if (err)
+ 		goto err_fib_destroy;
+ 
+ 	err = nsim_dev_traps_init(devlink);
+ 	if (err)
+ 		goto err_dummy_region_exit;
+ 
+ 	err = nsim_dev_health_init(nsim_dev, devlink);
+ 	if (err)
+ 		goto err_traps_exit;
+ 
+ 	err = nsim_dev_port_add_all(nsim_dev, nsim_bus_dev->port_count);
+ 	if (err)
+ 		goto err_health_exit;
+ 
+ 	nsim_dev->take_snapshot = debugfs_create_file("take_snapshot",
+ 						      0200,
+ 						      nsim_dev->ddir,
+ 						      nsim_dev,
+ 						&nsim_dev_take_snapshot_fops);
+ 	return 0;
+ 
+ err_health_exit:
+ 	nsim_dev_health_exit(nsim_dev);
+ err_traps_exit:
+ 	nsim_dev_traps_exit(devlink);
+ err_dummy_region_exit:
+ 	nsim_dev_dummy_region_exit(nsim_dev);
+ err_fib_destroy:
+ 	nsim_fib_destroy(devlink, nsim_dev->fib_data);
+ 	return err;
+ }
+ 
+ int nsim_dev_probe(struct nsim_bus_dev *nsim_bus_dev)
+ {
+ 	struct nsim_dev *nsim_dev;
+ 	struct devlink *devlink;
+ 	int err;
+ 
+ 	devlink = devlink_alloc(&nsim_dev_devlink_ops, sizeof(*nsim_dev));
+ 	if (!devlink)
+ 		return -ENOMEM;
+ 	devlink_net_set(devlink, nsim_bus_dev->initial_net);
+ 	nsim_dev = devlink_priv(devlink);
+ 	nsim_dev->nsim_bus_dev = nsim_bus_dev;
+ 	nsim_dev->switch_id.id_len = sizeof(nsim_dev->switch_id.id);
+ 	get_random_bytes(nsim_dev->switch_id.id, nsim_dev->switch_id.id_len);
+ 	INIT_LIST_HEAD(&nsim_dev->port_list);
+ 	mutex_init(&nsim_dev->port_list_lock);
+ 	nsim_dev->fw_update_status = true;
+ 	nsim_dev->max_macs = NSIM_DEV_MAX_MACS_DEFAULT;
+ 	nsim_dev->test1 = NSIM_DEV_TEST1_DEFAULT;
+ 	spin_lock_init(&nsim_dev->fa_cookie_lock);
+ 
+ 	dev_set_drvdata(&nsim_bus_dev->dev, nsim_dev);
+ 
+ 	err = nsim_dev_resources_register(devlink);
+ 	if (err)
+ 		goto err_devlink_free;
+ 
+ 	nsim_dev->fib_data = nsim_fib_create(devlink, NULL);
+ 	if (IS_ERR(nsim_dev->fib_data)) {
+ 		err = PTR_ERR(nsim_dev->fib_data);
+ 		goto err_resources_unregister;
+ 	}
+ 
+ 	err = devlink_register(devlink, &nsim_bus_dev->dev);
+ 	if (err)
+ 		goto err_fib_destroy;
+ 
+ 	err = devlink_params_register(devlink, nsim_devlink_params,
+ 				      ARRAY_SIZE(nsim_devlink_params));
+ 	if (err)
+ 		goto err_dl_unregister;
+ 	nsim_devlink_set_params_init_values(nsim_dev, devlink);
+ 
+ 	err = nsim_dev_dummy_region_init(nsim_dev, devlink);
+ 	if (err)
+ 		goto err_params_unregister;
+ 
+ 	err = nsim_dev_traps_init(devlink);
+ 	if (err)
+ 		goto err_dummy_region_exit;
+ 
+ 	err = nsim_dev_debugfs_init(nsim_dev);
+ 	if (err)
+ 		goto err_traps_exit;
+ 
+ 	err = nsim_dev_health_init(nsim_dev, devlink);
+ 	if (err)
+ 		goto err_debugfs_exit;
+ 
+ 	err = nsim_bpf_dev_init(nsim_dev);
+ 	if (err)
+ 		goto err_health_exit;
+ 
+ 	err = nsim_dev_port_add_all(nsim_dev, nsim_bus_dev->port_count);
+ 	if (err)
+ 		goto err_bpf_dev_exit;
+ 
+ 	devlink_params_publish(devlink);
+ 	devlink_reload_enable(devlink);
+ 	return 0;
+ 
+ err_bpf_dev_exit:
+ 	nsim_bpf_dev_exit(nsim_dev);
+ err_health_exit:
+ 	nsim_dev_health_exit(nsim_dev);
+ err_debugfs_exit:
+ 	nsim_dev_debugfs_exit(nsim_dev);
+ err_traps_exit:
+ 	nsim_dev_traps_exit(devlink);
+ err_dummy_region_exit:
+ 	nsim_dev_dummy_region_exit(nsim_dev);
+ err_params_unregister:
+ 	devlink_params_unregister(devlink, nsim_devlink_params,
+ 				  ARRAY_SIZE(nsim_devlink_params));
+ err_dl_unregister:
+ 	devlink_unregister(devlink);
+ err_fib_destroy:
+ 	nsim_fib_destroy(devlink, nsim_dev->fib_data);
+ err_resources_unregister:
+ 	devlink_resources_unregister(devlink, NULL);
+ err_devlink_free:
+ 	devlink_free(devlink);
+ 	return err;
+ }
+ 
+ static void nsim_dev_reload_destroy(struct nsim_dev *nsim_dev)
+ {
+ 	struct devlink *devlink = priv_to_devlink(nsim_dev);
+ 
+ 	if (devlink_is_reload_failed(devlink))
+ 		return;
+ 	debugfs_remove(nsim_dev->take_snapshot);
+ 	nsim_dev_port_del_all(nsim_dev);
+ 	nsim_dev_health_exit(nsim_dev);
+ 	nsim_dev_traps_exit(devlink);
+ 	nsim_dev_dummy_region_exit(nsim_dev);
+ 	mutex_destroy(&nsim_dev->port_list_lock);
+ 	nsim_fib_destroy(devlink, nsim_dev->fib_data);
+ }
+ 
++>>>>>>> d3cbb907ae57 (netdevsim: add ACL trap reporting cookie as a metadata)
  void nsim_dev_remove(struct nsim_bus_dev *nsim_bus_dev)
  {
  	struct nsim_dev *nsim_dev = dev_get_drvdata(&nsim_bus_dev->dev);
diff --cc drivers/net/netdevsim/netdevsim.h
index 4035af41eca9,e46fc565b981..000000000000
--- a/drivers/net/netdevsim/netdevsim.h
+++ b/drivers/net/netdevsim/netdevsim.h
@@@ -161,7 -174,12 +161,13 @@@ struct nsim_dev 
  	bool fw_update_status;
  	u32 max_macs;
  	bool test1;
 -	bool dont_allow_reload;
 -	bool fail_reload;
  	struct devlink_region *dummy_region;
++<<<<<<< HEAD
++=======
+ 	struct nsim_dev_health health;
+ 	struct flow_action_cookie *fa_cookie;
+ 	spinlock_t fa_cookie_lock; /* protects fa_cookie */
++>>>>>>> d3cbb907ae57 (netdevsim: add ACL trap reporting cookie as a metadata)
  };
  
  static inline struct net *nsim_dev_net(struct nsim_dev *nsim_dev)
* Unmerged path drivers/net/netdevsim/dev.c
* Unmerged path drivers/net/netdevsim/netdevsim.h
