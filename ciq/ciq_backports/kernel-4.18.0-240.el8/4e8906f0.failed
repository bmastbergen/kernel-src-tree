iommu: Move more initialization to __iommu_probe_device()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Joerg Roedel <jroedel@suse.de>
commit 4e8906f0d84d1a7d3cf82a30a701b0fb5d48977c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/4e8906f0.failed

Move the calls to dev_iommu_get() and try_module_get() into
__iommu_probe_device(), so that the callers don't have to do it on
their own.

	Signed-off-by: Joerg Roedel <jroedel@suse.de>
	Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
	Acked-by: Marek Szyprowski <m.szyprowski@samsung.com>
Link: https://lore.kernel.org/r/20200429133712.31431-34-joro@8bytes.org
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 4e8906f0d84d1a7d3cf82a30a701b0fb5d48977c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/iommu.c
diff --cc drivers/iommu/iommu.c
index 7997fcb701e0,48a95f7d7999..000000000000
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@@ -161,18 -163,122 +161,131 @@@ void iommu_device_unregister(struct iom
  	list_del(&iommu->list);
  	spin_unlock(&iommu_device_lock);
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL_GPL(iommu_device_unregister);
+ 
+ static struct dev_iommu *dev_iommu_get(struct device *dev)
+ {
+ 	struct dev_iommu *param = dev->iommu;
+ 
+ 	if (param)
+ 		return param;
+ 
+ 	param = kzalloc(sizeof(*param), GFP_KERNEL);
+ 	if (!param)
+ 		return NULL;
+ 
+ 	mutex_init(&param->lock);
+ 	dev->iommu = param;
+ 	return param;
+ }
+ 
+ static void dev_iommu_free(struct device *dev)
+ {
+ 	kfree(dev->iommu);
+ 	dev->iommu = NULL;
+ }
+ 
+ static int __iommu_probe_device(struct device *dev, struct list_head *group_list)
+ {
+ 	const struct iommu_ops *ops = dev->bus->iommu_ops;
+ 	struct iommu_device *iommu_dev;
+ 	struct iommu_group *group;
+ 	int ret;
+ 
+ 	if (!dev_iommu_get(dev))
+ 		return -ENOMEM;
+ 
+ 	if (!try_module_get(ops->owner)) {
+ 		ret = -EINVAL;
+ 		goto err_free;
+ 	}
+ 
+ 	iommu_dev = ops->probe_device(dev);
+ 	if (IS_ERR(iommu_dev)) {
+ 		ret = PTR_ERR(iommu_dev);
+ 		goto out_module_put;
+ 	}
+ 
+ 	dev->iommu->iommu_dev = iommu_dev;
+ 
+ 	group = iommu_group_get_for_dev(dev);
+ 	if (IS_ERR(group)) {
+ 		ret = PTR_ERR(group);
+ 		goto out_release;
+ 	}
+ 	iommu_group_put(group);
+ 
+ 	if (group_list && !group->default_domain && list_empty(&group->entry))
+ 		list_add_tail(&group->entry, group_list);
+ 
+ 	iommu_device_link(iommu_dev, dev);
+ 
+ 	return 0;
+ 
+ out_release:
+ 	ops->release_device(dev);
+ 
+ out_module_put:
+ 	module_put(ops->owner);
+ 
+ err_free:
+ 	dev_iommu_free(dev);
+ 
+ 	return ret;
+ }
++>>>>>>> 4e8906f0d84d (iommu: Move more initialization to __iommu_probe_device())
  
  int iommu_probe_device(struct device *dev)
  {
  	const struct iommu_ops *ops = dev->bus->iommu_ops;
 -	struct iommu_group *group;
 -	int ret;
 +	int ret = -EINVAL;
 +
++<<<<<<< HEAD
 +	WARN_ON(dev->iommu_group);
  
 +	if (ops)
 +		ret = ops->add_device(dev);
 +
++=======
+ 	ret = __iommu_probe_device(dev, NULL);
+ 	if (ret)
+ 		goto err_out;
+ 
+ 	/*
+ 	 * Try to allocate a default domain - needs support from the
+ 	 * IOMMU driver. There are still some drivers which don't
+ 	 * support default domains, so the return value is not yet
+ 	 * checked.
+ 	 */
+ 	iommu_alloc_default_domain(dev);
+ 
+ 	group = iommu_group_get(dev);
+ 	if (!group)
+ 		goto err_release;
+ 
+ 	if (group->default_domain)
+ 		ret = __iommu_attach_device(group->default_domain, dev);
+ 
+ 	iommu_create_device_direct_mappings(group, dev);
+ 
+ 	iommu_group_put(group);
+ 
+ 	if (ret)
+ 		goto err_release;
+ 
+ 	if (ops->probe_finalize)
+ 		ops->probe_finalize(dev);
+ 
+ 	return 0;
+ 
+ err_release:
+ 	iommu_release_device(dev);
+ 
+ err_out:
++>>>>>>> 4e8906f0d84d (iommu: Move more initialization to __iommu_probe_device())
  	return ret;
 -
  }
  
  void iommu_release_device(struct device *dev)
@@@ -1209,15 -1538,20 +1322,30 @@@ struct iommu_domain *iommu_group_defaul
  	return group->default_domain;
  }
  
 -static int probe_iommu_group(struct device *dev, void *data)
 +static int add_iommu_group(struct device *dev, void *data)
  {
++<<<<<<< HEAD
 +	int ret = iommu_probe_device(dev);
 +
 +	/*
 +	 * We ignore -ENODEV errors for now, as they just mean that the
 +	 * device is not translated by an IOMMU. We still care about
 +	 * other errors and fail to initialize when they happen.
 +	 */
++=======
+ 	struct list_head *group_list = data;
+ 	struct iommu_group *group;
+ 	int ret;
+ 
+ 	/* Device is probed already if in a group */
+ 	group = iommu_group_get(dev);
+ 	if (group) {
+ 		iommu_group_put(group);
+ 		return 0;
+ 	}
+ 
+ 	ret = __iommu_probe_device(dev, group_list);
++>>>>>>> 4e8906f0d84d (iommu: Move more initialization to __iommu_probe_device())
  	if (ret == -ENODEV)
  		ret = 0;
  
* Unmerged path drivers/iommu/iommu.c
