libperf: Move 'id' from 'struct evsel' to 'struct perf_evsel'

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Olsa <jolsa@kernel.org>
commit deaf321913a7b1d440c5cd5c7766d47381c9b21b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/deaf3219.failed

Move the 'id' array from 'struct evsel' to libperf's 'struct perf_evsel'.

Committer note:

Fix the tools/perf/util/cs-etm.c build, i.e. aarch64's CoreSight.

	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
	Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
	Cc: Michael Petlan <mpetlan@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lore.kernel.org/lkml/20190913132355.21634-25-jolsa@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit deaf321913a7b1d440c5cd5c7766d47381c9b21b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/lib/include/internal/evsel.h
#	tools/perf/util/evsel.c
#	tools/perf/util/evsel.h
#	tools/perf/util/intel-pt.c
#	tools/perf/util/synthetic-events.c
diff --cc tools/perf/util/evsel.c
index 90bfc2303a40,9c1b4f4a5fa3..000000000000
--- a/tools/perf/util/evsel.c
+++ b/tools/perf/util/evsel.c
@@@ -1268,34 -1232,28 +1268,47 @@@ int perf_evsel__alloc_id(struct perf_ev
  	if (ncpus == 0 || nthreads == 0)
  		return 0;
  
 -	if (evsel->core.system_wide)
 +	if (evsel->system_wide)
  		nthreads = 1;
  
 -	evsel->core.sample_id = xyarray__new(ncpus, nthreads, sizeof(struct perf_sample_id));
 -	if (evsel->core.sample_id == NULL)
 +	evsel->sample_id = xyarray__new(ncpus, nthreads, sizeof(struct perf_sample_id));
 +	if (evsel->sample_id == NULL)
  		return -ENOMEM;
  
++<<<<<<< HEAD
 +	evsel->id = zalloc(ncpus * nthreads * sizeof(u64));
 +	if (evsel->id == NULL) {
 +		xyarray__delete(evsel->sample_id);
 +		evsel->sample_id = NULL;
++=======
+ 	evsel->core.id = zalloc(ncpus * nthreads * sizeof(u64));
+ 	if (evsel->core.id == NULL) {
+ 		xyarray__delete(evsel->core.sample_id);
+ 		evsel->core.sample_id = NULL;
++>>>>>>> deaf321913a7 (libperf: Move 'id' from 'struct evsel' to 'struct perf_evsel')
  		return -ENOMEM;
  	}
  
  	return 0;
  }
  
 -static void perf_evsel__free_id(struct evsel *evsel)
 +static void perf_evsel__free_fd(struct perf_evsel *evsel)
  {
++<<<<<<< HEAD
 +	xyarray__delete(evsel->fd);
 +	evsel->fd = NULL;
 +}
 +
 +static void perf_evsel__free_id(struct perf_evsel *evsel)
 +{
 +	xyarray__delete(evsel->sample_id);
 +	evsel->sample_id = NULL;
 +	zfree(&evsel->id);
++=======
+ 	xyarray__delete(evsel->core.sample_id);
+ 	evsel->core.sample_id = NULL;
+ 	zfree(&evsel->core.id);
++>>>>>>> deaf321913a7 (libperf: Move 'id' from 'struct evsel' to 'struct perf_evsel')
  	evsel->ids = 0;
  }
  
diff --cc tools/perf/util/evsel.h
index fe84f1536094,0d2aa933ceb3..000000000000
--- a/tools/perf/util/evsel.h
+++ b/tools/perf/util/evsel.h
@@@ -102,14 -112,10 +102,17 @@@ struct bpf_object
   *          is used there is an id sample appended to non-sample events
   * @priv:   And what is in its containing unnamed union are tool specific
   */
 -struct evsel {
 -	struct perf_evsel	core;
 -	struct evlist	*evlist;
 +struct perf_evsel {
 +	struct list_head	node;
 +	struct perf_evlist	*evlist;
 +	struct perf_event_attr	attr;
  	char			*filter;
++<<<<<<< HEAD
 +	struct xyarray		*fd;
 +	struct xyarray		*sample_id;
 +	u64			*id;
++=======
++>>>>>>> deaf321913a7 (libperf: Move 'id' from 'struct evsel' to 'struct perf_evsel')
  	struct perf_counts	*counts;
  	struct perf_counts	*prev_raw_counts;
  	int			idx;
diff --cc tools/perf/util/intel-pt.c
index e9ac11860229,24ca5d5908ca..000000000000
--- a/tools/perf/util/intel-pt.c
+++ b/tools/perf/util/intel-pt.c
@@@ -1710,9 -1703,9 +1710,15 @@@ static int intel_pt_synth_pebs_sample(s
  	struct perf_sample sample = { .ip = 0, };
  	union perf_event *event = ptq->event_buf;
  	struct intel_pt *pt = ptq->pt;
++<<<<<<< HEAD
 +	struct perf_evsel *evsel = pt->pebs_evsel;
 +	u64 sample_type = evsel->attr.sample_type;
 +	u64 id = evsel->id[0];
++=======
+ 	struct evsel *evsel = pt->pebs_evsel;
+ 	u64 sample_type = evsel->core.attr.sample_type;
+ 	u64 id = evsel->core.id[0];
++>>>>>>> deaf321913a7 (libperf: Move 'id' from 'struct evsel' to 'struct perf_evsel')
  	u8 cpumode;
  
  	if (intel_pt_skip_event(pt))
@@@ -2721,13 -2714,13 +2727,13 @@@ static int intel_pt_synth_event(struct 
  	return err;
  }
  
 -static void intel_pt_set_event_name(struct evlist *evlist, u64 id,
 +static void intel_pt_set_event_name(struct perf_evlist *evlist, u64 id,
  				    const char *name)
  {
 -	struct evsel *evsel;
 +	struct perf_evsel *evsel;
  
  	evlist__for_each_entry(evlist, evsel) {
- 		if (evsel->id && evsel->id[0] == id) {
+ 		if (evsel->core.id && evsel->core.id[0] == id) {
  			if (evsel->name)
  				zfree(&evsel->name);
  			evsel->name = strdup(name);
@@@ -2775,15 -2768,15 +2781,15 @@@ static int intel_pt_synth_events(struc
  		attr.sample_type |= PERF_SAMPLE_TIME;
  	if (!pt->per_cpu_mmaps)
  		attr.sample_type &= ~(u64)PERF_SAMPLE_CPU;
 -	attr.exclude_user = evsel->core.attr.exclude_user;
 -	attr.exclude_kernel = evsel->core.attr.exclude_kernel;
 -	attr.exclude_hv = evsel->core.attr.exclude_hv;
 -	attr.exclude_host = evsel->core.attr.exclude_host;
 -	attr.exclude_guest = evsel->core.attr.exclude_guest;
 -	attr.sample_id_all = evsel->core.attr.sample_id_all;
 -	attr.read_format = evsel->core.attr.read_format;
 +	attr.exclude_user = evsel->attr.exclude_user;
 +	attr.exclude_kernel = evsel->attr.exclude_kernel;
 +	attr.exclude_hv = evsel->attr.exclude_hv;
 +	attr.exclude_host = evsel->attr.exclude_host;
 +	attr.exclude_guest = evsel->attr.exclude_guest;
 +	attr.sample_id_all = evsel->attr.sample_id_all;
 +	attr.read_format = evsel->attr.read_format;
  
- 	id = evsel->id[0] + 1000000000;
+ 	id = evsel->core.id[0] + 1000000000;
  	if (!id)
  		id = 1;
  
@@@ -2902,9 -2895,25 +2908,29 @@@
  	return 0;
  }
  
 -static void intel_pt_setup_pebs_events(struct intel_pt *pt)
 +static struct perf_evsel *intel_pt_find_sched_switch(struct perf_evlist *evlist)
  {
++<<<<<<< HEAD
 +	struct perf_evsel *evsel;
++=======
+ 	struct evsel *evsel;
+ 
+ 	if (!pt->synth_opts.other_events)
+ 		return;
+ 
+ 	evlist__for_each_entry(pt->session->evlist, evsel) {
+ 		if (evsel->core.attr.aux_output && evsel->core.id) {
+ 			pt->sample_pebs = true;
+ 			pt->pebs_evsel = evsel;
+ 			return;
+ 		}
+ 	}
+ }
+ 
+ static struct evsel *intel_pt_find_sched_switch(struct evlist *evlist)
+ {
+ 	struct evsel *evsel;
++>>>>>>> deaf321913a7 (libperf: Move 'id' from 'struct evsel' to 'struct perf_evsel')
  
  	evlist__for_each_entry_reverse(evlist, evsel) {
  		const char *name = perf_evsel__name(evsel);
* Unmerged path tools/perf/lib/include/internal/evsel.h
* Unmerged path tools/perf/util/synthetic-events.c
* Unmerged path tools/perf/lib/include/internal/evsel.h
diff --git a/tools/perf/util/cs-etm.c b/tools/perf/util/cs-etm.c
index d7ad43911473..737ad8b7598d 100644
--- a/tools/perf/util/cs-etm.c
+++ b/tools/perf/util/cs-etm.c
@@ -1295,7 +1295,7 @@ static int cs_etm__synth_events(struct cs_etm_auxtrace *etm,
 	attr.read_format = evsel->attr.read_format;
 
 	/* create new id val to be a fixed offset from evsel id */
-	id = evsel->id[0] + 1000000000;
+	id = evsel->core.id[0] + 1000000000;
 
 	if (!id)
 		id = 1;
diff --git a/tools/perf/util/evlist.c b/tools/perf/util/evlist.c
index 29a998d183ce..8ff0dbadfbc1 100644
--- a/tools/perf/util/evlist.c
+++ b/tools/perf/util/evlist.c
@@ -504,7 +504,7 @@ void perf_evlist__id_add(struct perf_evlist *evlist, struct perf_evsel *evsel,
 			 int cpu, int thread, u64 id)
 {
 	perf_evlist__id_hash(evlist, evsel, cpu, thread, id);
-	evsel->id[evsel->ids++] = id;
+	evsel->core.id[evsel->ids++] = id;
 }
 
 int perf_evlist__id_add_fd(struct perf_evlist *evlist,
* Unmerged path tools/perf/util/evsel.c
* Unmerged path tools/perf/util/evsel.h
diff --git a/tools/perf/util/header.c b/tools/perf/util/header.c
index 13489971ed57..130749138f6f 100644
--- a/tools/perf/util/header.c
+++ b/tools/perf/util/header.c
@@ -535,7 +535,7 @@ static int write_event_desc(struct feat_fd *ff,
 		/*
 		 * write unique ids for this event
 		 */
-		ret = do_write(ff, evsel->id, evsel->ids * sizeof(u64));
+		ret = do_write(ff, evsel->core.id, evsel->ids * sizeof(u64));
 		if (ret < 0)
 			return ret;
 	}
@@ -1586,7 +1586,7 @@ static void free_event_desc(struct perf_evsel *events)
 
 	for (evsel = events; evsel->attr.size; evsel++) {
 		zfree(&evsel->name);
-		zfree(&evsel->id);
+		zfree(&evsel->core.id);
 	}
 
 	free(events);
@@ -1653,7 +1653,7 @@ static struct perf_evsel *read_event_desc(struct feat_fd *ff)
 		if (!id)
 			goto error;
 		evsel->ids = nr;
-		evsel->id = id;
+		evsel->core.id = id;
 
 		for (j = 0 ; j < nr; j++) {
 			if (do_read_u64(ff, id))
@@ -1697,7 +1697,7 @@ static void print_event_desc(struct feat_fd *ff, FILE *fp)
 
 		if (evsel->ids) {
 			fprintf(fp, ", id = {");
-			for (j = 0, id = evsel->id; j < evsel->ids; j++, id++) {
+			for (j = 0, id = evsel->core.id; j < evsel->ids; j++, id++) {
 				if (j)
 					fputc(',', fp);
 				fprintf(fp, " %"PRIu64, *id);
@@ -3071,7 +3071,7 @@ int perf_session__write_header(struct perf_session *session,
 
 	evlist__for_each_entry(session->evlist, evsel) {
 		evsel->id_offset = lseek(fd, 0, SEEK_CUR);
-		err = do_write(&ff, evsel->id, evsel->ids * sizeof(u64));
+		err = do_write(&ff, evsel->core.id, evsel->ids * sizeof(u64));
 		if (err < 0) {
 			pr_debug("failed to write perf header\n");
 			return err;
diff --git a/tools/perf/util/intel-bts.c b/tools/perf/util/intel-bts.c
index 902b67a0538f..cb3c423b12a6 100644
--- a/tools/perf/util/intel-bts.c
+++ b/tools/perf/util/intel-bts.c
@@ -803,7 +803,7 @@ static int intel_bts_synth_events(struct intel_bts *bts,
 	attr.sample_id_all = evsel->attr.sample_id_all;
 	attr.read_format = evsel->attr.read_format;
 
-	id = evsel->id[0] + 1000000000;
+	id = evsel->core.id[0] + 1000000000;
 	if (!id)
 		id = 1;
 
* Unmerged path tools/perf/util/intel-pt.c
* Unmerged path tools/perf/util/synthetic-events.c
