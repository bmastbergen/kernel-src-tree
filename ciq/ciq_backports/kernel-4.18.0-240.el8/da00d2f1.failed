bpf: Add test ops for BPF_PROG_TYPE_TRACING

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author KP Singh <kpsingh@google.com>
commit da00d2f117a08fbca262db5ea422c80a568b112b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/da00d2f1.failed

The current fexit and fentry tests rely on a different program to
exercise the functions they attach to. Instead of doing this, implement
the test operations for tracing which will also be used for
BPF_MODIFY_RETURN in a subsequent patch.

Also, clean up the fexit test to use the generated skeleton.

	Signed-off-by: KP Singh <kpsingh@google.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
	Acked-by: Daniel Borkmann <daniel@iogearbox.net>
Link: https://lore.kernel.org/bpf/20200304191853.1529-7-kpsingh@chromium.org
(cherry picked from commit da00d2f117a08fbca262db5ea422c80a568b112b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/trace/bpf_trace.c
#	tools/testing/selftests/bpf/prog_tests/fentry_fexit.c
#	tools/testing/selftests/bpf/prog_tests/fentry_test.c
#	tools/testing/selftests/bpf/prog_tests/fexit_test.c
diff --cc kernel/trace/bpf_trace.c
index c37127369097,363e0a2c75cf..000000000000
--- a/kernel/trace/bpf_trace.c
+++ b/kernel/trace/bpf_trace.c
@@@ -1104,6 -1260,15 +1104,18 @@@ const struct bpf_verifier_ops raw_trace
  const struct bpf_prog_ops raw_tracepoint_prog_ops = {
  };
  
++<<<<<<< HEAD
++=======
+ const struct bpf_verifier_ops tracing_verifier_ops = {
+ 	.get_func_proto  = tracing_prog_func_proto,
+ 	.is_valid_access = tracing_prog_is_valid_access,
+ };
+ 
+ const struct bpf_prog_ops tracing_prog_ops = {
+ 	.test_run = bpf_prog_test_run_tracing,
+ };
+ 
++>>>>>>> da00d2f117a0 (bpf: Add test ops for BPF_PROG_TYPE_TRACING)
  static bool raw_tp_writable_prog_is_valid_access(int off, int size,
  						 enum bpf_access_type type,
  						 const struct bpf_prog *prog,
diff --cc tools/testing/selftests/bpf/prog_tests/fentry_fexit.c
index 40bcff2cc274,83493bd5745c..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/fentry_fexit.c
+++ b/tools/testing/selftests/bpf/prog_tests/fentry_fexit.c
@@@ -1,90 -1,49 +1,116 @@@
  // SPDX-License-Identifier: GPL-2.0
  /* Copyright (c) 2019 Facebook */
  #include <test_progs.h>
++<<<<<<< HEAD
 +
 +void test_fentry_fexit(void)
 +{
 +	struct bpf_prog_load_attr attr_fentry = {
 +		.file = "./fentry_test.o",
 +	};
 +	struct bpf_prog_load_attr attr_fexit = {
 +		.file = "./fexit_test.o",
 +	};
 +
 +	struct bpf_object *obj_fentry = NULL, *obj_fexit = NULL, *pkt_obj;
 +	struct bpf_map *data_map_fentry, *data_map_fexit;
 +	char fentry_name[] = "fentry/bpf_fentry_testX";
 +	char fexit_name[] = "fexit/bpf_fentry_testX";
 +	int err, pkt_fd, kfree_skb_fd, i;
 +	struct bpf_link *link[12] = {};
 +	struct bpf_program *prog[12];
 +	__u32 duration, retval;
 +	const int zero = 0;
 +	u64 result[12];
 +
 +	err = bpf_prog_load("./test_pkt_access.o", BPF_PROG_TYPE_SCHED_CLS,
 +			    &pkt_obj, &pkt_fd);
 +	if (CHECK(err, "prog_load sched cls", "err %d errno %d\n", err, errno))
 +		return;
 +	err = bpf_prog_load_xattr(&attr_fentry, &obj_fentry, &kfree_skb_fd);
 +	if (CHECK(err, "prog_load fail", "err %d errno %d\n", err, errno))
++=======
+ #include "fentry_test.skel.h"
+ #include "fexit_test.skel.h"
+ 
+ void test_fentry_fexit(void)
+ {
+ 	struct fentry_test *fentry_skel = NULL;
+ 	struct fexit_test *fexit_skel = NULL;
+ 	__u64 *fentry_res, *fexit_res;
+ 	__u32 duration = 0, retval;
+ 	int err, prog_fd, i;
+ 
+ 	fentry_skel = fentry_test__open_and_load();
+ 	if (CHECK(!fentry_skel, "fentry_skel_load", "fentry skeleton failed\n"))
++>>>>>>> da00d2f117a0 (bpf: Add test ops for BPF_PROG_TYPE_TRACING)
  		goto close_prog;
 -	fexit_skel = fexit_test__open_and_load();
 -	if (CHECK(!fexit_skel, "fexit_skel_load", "fexit skeleton failed\n"))
 +	err = bpf_prog_load_xattr(&attr_fexit, &obj_fexit, &kfree_skb_fd);
 +	if (CHECK(err, "prog_load fail", "err %d errno %d\n", err, errno))
  		goto close_prog;
  
 -	err = fentry_test__attach(fentry_skel);
 -	if (CHECK(err, "fentry_attach", "fentry attach failed: %d\n", err))
 +	for (i = 0; i < 6; i++) {
 +		fentry_name[sizeof(fentry_name) - 2] = '1' + i;
 +		prog[i] = bpf_object__find_program_by_title(obj_fentry, fentry_name);
 +		if (CHECK(!prog[i], "find_prog", "prog %s not found\n", fentry_name))
 +			goto close_prog;
 +		link[i] = bpf_program__attach_trace(prog[i]);
 +		if (CHECK(IS_ERR(link[i]), "attach_trace", "failed to link\n"))
 +			goto close_prog;
 +	}
 +	data_map_fentry = bpf_object__find_map_by_name(obj_fentry, "fentry_t.bss");
 +	if (CHECK(!data_map_fentry, "find_data_map", "data map not found\n"))
  		goto close_prog;
 -	err = fexit_test__attach(fexit_skel);
 -	if (CHECK(err, "fexit_attach", "fexit attach failed: %d\n", err))
 +
 +	for (i = 6; i < 12; i++) {
 +		fexit_name[sizeof(fexit_name) - 2] = '1' + i - 6;
 +		prog[i] = bpf_object__find_program_by_title(obj_fexit, fexit_name);
 +		if (CHECK(!prog[i], "find_prog", "prog %s not found\n", fexit_name))
 +			goto close_prog;
 +		link[i] = bpf_program__attach_trace(prog[i]);
 +		if (CHECK(IS_ERR(link[i]), "attach_trace", "failed to link\n"))
 +			goto close_prog;
 +	}
 +	data_map_fexit = bpf_object__find_map_by_name(obj_fexit, "fexit_te.bss");
 +	if (CHECK(!data_map_fexit, "find_data_map", "data map not found\n"))
  		goto close_prog;
  
++<<<<<<< HEAD
 +	err = bpf_prog_test_run(pkt_fd, 1, &pkt_v6, sizeof(pkt_v6),
++=======
+ 	prog_fd = bpf_program__fd(fexit_skel->progs.test1);
+ 	err = bpf_prog_test_run(prog_fd, 1, NULL, 0,
++>>>>>>> da00d2f117a0 (bpf: Add test ops for BPF_PROG_TYPE_TRACING)
  				NULL, NULL, &retval, &duration);
  	CHECK(err || retval, "ipv6",
  	      "err %d errno %d retval %d duration %d\n",
  	      err, errno, retval, duration);
  
 -	fentry_res = (__u64 *)fentry_skel->bss;
 -	fexit_res = (__u64 *)fexit_skel->bss;
 -	printf("%lld\n", fentry_skel->bss->test1_result);
 -	for (i = 0; i < 6; i++) {
 -		CHECK(fentry_res[i] != 1, "result",
 -		      "fentry_test%d failed err %lld\n", i + 1, fentry_res[i]);
 -		CHECK(fexit_res[i] != 1, "result",
 -		      "fexit_test%d failed err %lld\n", i + 1, fexit_res[i]);
 -	}
 +	err = bpf_map_lookup_elem(bpf_map__fd(data_map_fentry), &zero, &result);
 +	if (CHECK(err, "get_result",
 +		  "failed to get output data: %d\n", err))
 +		goto close_prog;
 +
 +	err = bpf_map_lookup_elem(bpf_map__fd(data_map_fexit), &zero, result + 6);
 +	if (CHECK(err, "get_result",
 +		  "failed to get output data: %d\n", err))
 +		goto close_prog;
 +
 +	for (i = 0; i < 12; i++)
 +		if (CHECK(result[i] != 1, "result", "bpf_fentry_test%d failed err %ld\n",
 +			  i % 6 + 1, result[i]))
 +			goto close_prog;
  
  close_prog:
++<<<<<<< HEAD
 +	for (i = 0; i < 12; i++)
 +		if (!IS_ERR_OR_NULL(link[i]))
 +			bpf_link__destroy(link[i]);
 +	bpf_object__close(obj_fentry);
 +	bpf_object__close(obj_fexit);
 +	bpf_object__close(pkt_obj);
++=======
+ 	fentry_test__destroy(fentry_skel);
+ 	fexit_test__destroy(fexit_skel);
++>>>>>>> da00d2f117a0 (bpf: Add test ops for BPF_PROG_TYPE_TRACING)
  }
diff --cc tools/testing/selftests/bpf/prog_tests/fentry_test.c
index 9fb103193878,04ebbf1cb390..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/fentry_test.c
+++ b/tools/testing/selftests/bpf/prog_tests/fentry_test.c
@@@ -1,64 -1,37 +1,89 @@@
  // SPDX-License-Identifier: GPL-2.0
  /* Copyright (c) 2019 Facebook */
  #include <test_progs.h>
++<<<<<<< HEAD
 +
 +void test_fentry_test(void)
 +{
 +	struct bpf_prog_load_attr attr = {
 +		.file = "./fentry_test.o",
 +	};
 +
 +	char prog_name[] = "fentry/bpf_fentry_testX";
 +	struct bpf_object *obj = NULL, *pkt_obj;
 +	int err, pkt_fd, kfree_skb_fd, i;
 +	struct bpf_link *link[6] = {};
 +	struct bpf_program *prog[6];
 +	__u32 duration, retval;
 +	struct bpf_map *data_map;
 +	const int zero = 0;
 +	u64 result[6];
 +
 +	err = bpf_prog_load("./test_pkt_access.o", BPF_PROG_TYPE_SCHED_CLS,
 +			    &pkt_obj, &pkt_fd);
 +	if (CHECK(err, "prog_load sched cls", "err %d errno %d\n", err, errno))
 +		return;
 +	err = bpf_prog_load_xattr(&attr, &obj, &kfree_skb_fd);
 +	if (CHECK(err, "prog_load fail", "err %d errno %d\n", err, errno))
 +		goto close_prog;
++=======
+ #include "fentry_test.skel.h"
+ 
+ void test_fentry_test(void)
+ {
+ 	struct fentry_test *fentry_skel = NULL;
+ 	int err, prog_fd, i;
+ 	__u32 duration = 0, retval;
+ 	__u64 *result;
+ 
+ 	fentry_skel = fentry_test__open_and_load();
+ 	if (CHECK(!fentry_skel, "fentry_skel_load", "fentry skeleton failed\n"))
+ 		goto cleanup;
++>>>>>>> da00d2f117a0 (bpf: Add test ops for BPF_PROG_TYPE_TRACING)
  
 -	err = fentry_test__attach(fentry_skel);
 -	if (CHECK(err, "fentry_attach", "fentry attach failed: %d\n", err))
 -		goto cleanup;
 +	for (i = 0; i < 6; i++) {
 +		prog_name[sizeof(prog_name) - 2] = '1' + i;
 +		prog[i] = bpf_object__find_program_by_title(obj, prog_name);
 +		if (CHECK(!prog[i], "find_prog", "prog %s not found\n", prog_name))
 +			goto close_prog;
 +		link[i] = bpf_program__attach_trace(prog[i]);
 +		if (CHECK(IS_ERR(link[i]), "attach_trace", "failed to link\n"))
 +			goto close_prog;
 +	}
 +	data_map = bpf_object__find_map_by_name(obj, "fentry_t.bss");
 +	if (CHECK(!data_map, "find_data_map", "data map not found\n"))
 +		goto close_prog;
  
++<<<<<<< HEAD
 +	err = bpf_prog_test_run(pkt_fd, 1, &pkt_v6, sizeof(pkt_v6),
++=======
+ 	prog_fd = bpf_program__fd(fentry_skel->progs.test1);
+ 	err = bpf_prog_test_run(prog_fd, 1, NULL, 0,
++>>>>>>> da00d2f117a0 (bpf: Add test ops for BPF_PROG_TYPE_TRACING)
  				NULL, NULL, &retval, &duration);
- 	CHECK(err || retval, "ipv6",
+ 	CHECK(err || retval, "test_run",
  	      "err %d errno %d retval %d duration %d\n",
  	      err, errno, retval, duration);
  
 -	result = (__u64 *)fentry_skel->bss;
 -	for (i = 0; i < 6; i++) {
 -		if (CHECK(result[i] != 1, "result",
 -			  "fentry_test%d failed err %lld\n", i + 1, result[i]))
 -			goto cleanup;
 -	}
 +	err = bpf_map_lookup_elem(bpf_map__fd(data_map), &zero, &result);
 +	if (CHECK(err, "get_result",
 +		  "failed to get output data: %d\n", err))
 +		goto close_prog;
 +
++<<<<<<< HEAD
 +	for (i = 0; i < 6; i++)
 +		if (CHECK(result[i] != 1, "result", "bpf_fentry_test%d failed err %ld\n",
 +			  i + 1, result[i]))
 +			goto close_prog;
  
 +close_prog:
 +	for (i = 0; i < 6; i++)
 +		if (!IS_ERR_OR_NULL(link[i]))
 +			bpf_link__destroy(link[i]);
 +	bpf_object__close(obj);
 +	bpf_object__close(pkt_obj);
++=======
+ cleanup:
+ 	fentry_test__destroy(fentry_skel);
++>>>>>>> da00d2f117a0 (bpf: Add test ops for BPF_PROG_TYPE_TRACING)
  }
diff --cc tools/testing/selftests/bpf/prog_tests/fexit_test.c
index f99013222c74,78d7a2765c27..000000000000
--- a/tools/testing/selftests/bpf/prog_tests/fexit_test.c
+++ b/tools/testing/selftests/bpf/prog_tests/fexit_test.c
@@@ -4,44 -5,23 +5,39 @@@
  
  void test_fexit_test(void)
  {
++<<<<<<< HEAD
 +	struct bpf_prog_load_attr attr = {
 +		.file = "./fexit_test.o",
 +	};
 +
 +	char prog_name[] = "fexit/bpf_fentry_testX";
 +	struct bpf_object *obj = NULL, *pkt_obj;
 +	int err, pkt_fd, kfree_skb_fd, i;
 +	struct bpf_link *link[6] = {};
 +	struct bpf_program *prog[6];
 +	__u32 duration, retval;
 +	struct bpf_map *data_map;
 +	const int zero = 0;
 +	u64 result[6];
- 
- 	err = bpf_prog_load("./test_pkt_access.o", BPF_PROG_TYPE_SCHED_CLS,
- 			    &pkt_obj, &pkt_fd);
- 	if (CHECK(err, "prog_load sched cls", "err %d errno %d\n", err, errno))
- 		return;
- 	err = bpf_prog_load_xattr(&attr, &obj, &kfree_skb_fd);
- 	if (CHECK(err, "prog_load fail", "err %d errno %d\n", err, errno))
- 		goto close_prog;
- 
- 	for (i = 0; i < 6; i++) {
- 		prog_name[sizeof(prog_name) - 2] = '1' + i;
- 		prog[i] = bpf_object__find_program_by_title(obj, prog_name);
- 		if (CHECK(!prog[i], "find_prog", "prog %s not found\n", prog_name))
- 			goto close_prog;
- 		link[i] = bpf_program__attach_trace(prog[i]);
- 		if (CHECK(IS_ERR(link[i]), "attach_trace", "failed to link\n"))
- 			goto close_prog;
- 	}
- 	data_map = bpf_object__find_map_by_name(obj, "fexit_te.bss");
- 	if (CHECK(!data_map, "find_data_map", "data map not found\n"))
- 		goto close_prog;
- 
- 	err = bpf_prog_test_run(pkt_fd, 1, &pkt_v6, sizeof(pkt_v6),
++=======
+ 	struct fexit_test *fexit_skel = NULL;
+ 	int err, prog_fd, i;
+ 	__u32 duration = 0, retval;
+ 	__u64 *result;
++>>>>>>> da00d2f117a0 (bpf: Add test ops for BPF_PROG_TYPE_TRACING)
+ 
+ 	fexit_skel = fexit_test__open_and_load();
+ 	if (CHECK(!fexit_skel, "fexit_skel_load", "fexit skeleton failed\n"))
+ 		goto cleanup;
+ 
+ 	err = fexit_test__attach(fexit_skel);
+ 	if (CHECK(err, "fexit_attach", "fexit attach failed: %d\n", err))
+ 		goto cleanup;
+ 
+ 	prog_fd = bpf_program__fd(fexit_skel->progs.test1);
+ 	err = bpf_prog_test_run(prog_fd, 1, NULL, 0,
  				NULL, NULL, &retval, &duration);
- 	CHECK(err || retval, "ipv6",
+ 	CHECK(err || retval, "test_run",
  	      "err %d errno %d retval %d duration %d\n",
  	      err, errno, retval, duration);
  
diff --git a/include/linux/bpf.h b/include/linux/bpf.h
index 609313a9dbb2..645167b3b419 100644
--- a/include/linux/bpf.h
+++ b/include/linux/bpf.h
@@ -808,6 +808,9 @@ int bpf_prog_test_run_xdp(struct bpf_prog *prog, const union bpf_attr *kattr,
 			  union bpf_attr __user *uattr);
 int bpf_prog_test_run_skb(struct bpf_prog *prog, const union bpf_attr *kattr,
 			  union bpf_attr __user *uattr);
+int bpf_prog_test_run_tracing(struct bpf_prog *prog,
+			      const union bpf_attr *kattr,
+			      union bpf_attr __user *uattr);
 int bpf_prog_test_run_flow_dissector(struct bpf_prog *prog,
 				     const union bpf_attr *kattr,
 				     union bpf_attr __user *uattr);
@@ -937,6 +940,13 @@ static inline int bpf_prog_test_run_skb(struct bpf_prog *prog,
 	return -ENOTSUPP;
 }
 
+static inline int bpf_prog_test_run_tracing(struct bpf_prog *prog,
+					    const union bpf_attr *kattr,
+					    union bpf_attr __user *uattr)
+{
+	return -ENOTSUPP;
+}
+
 static inline int bpf_prog_test_run_flow_dissector(struct bpf_prog *prog,
 						   const union bpf_attr *kattr,
 						   union bpf_attr __user *uattr)
* Unmerged path kernel/trace/bpf_trace.c
diff --git a/net/bpf/test_run.c b/net/bpf/test_run.c
index d17321193b1d..feb26030d325 100644
--- a/net/bpf/test_run.c
+++ b/net/bpf/test_run.c
@@ -163,18 +163,37 @@ static void *bpf_test_init(const union bpf_attr *kattr, u32 size,
 		kfree(data);
 		return ERR_PTR(-EFAULT);
 	}
-	if (bpf_fentry_test1(1) != 2 ||
-	    bpf_fentry_test2(2, 3) != 5 ||
-	    bpf_fentry_test3(4, 5, 6) != 15 ||
-	    bpf_fentry_test4((void *)7, 8, 9, 10) != 34 ||
-	    bpf_fentry_test5(11, (void *)12, 13, 14, 15) != 65 ||
-	    bpf_fentry_test6(16, (void *)17, 18, 19, (void *)20, 21) != 111) {
-		kfree(data);
-		return ERR_PTR(-EFAULT);
-	}
+
 	return data;
 }
 
+int bpf_prog_test_run_tracing(struct bpf_prog *prog,
+			      const union bpf_attr *kattr,
+			      union bpf_attr __user *uattr)
+{
+	int err = -EFAULT;
+
+	switch (prog->expected_attach_type) {
+	case BPF_TRACE_FENTRY:
+	case BPF_TRACE_FEXIT:
+		if (bpf_fentry_test1(1) != 2 ||
+		    bpf_fentry_test2(2, 3) != 5 ||
+		    bpf_fentry_test3(4, 5, 6) != 15 ||
+		    bpf_fentry_test4((void *)7, 8, 9, 10) != 34 ||
+		    bpf_fentry_test5(11, (void *)12, 13, 14, 15) != 65 ||
+		    bpf_fentry_test6(16, (void *)17, 18, 19, (void *)20, 21) != 111)
+			goto out;
+		break;
+	default:
+		goto out;
+	}
+
+	err = 0;
+out:
+	trace_bpf_test_finish(&err);
+	return err;
+}
+
 static void *bpf_ctx_init(const union bpf_attr *kattr, u32 max_size)
 {
 	void __user *data_in = u64_to_user_ptr(kattr->test.ctx_in);
* Unmerged path tools/testing/selftests/bpf/prog_tests/fentry_fexit.c
* Unmerged path tools/testing/selftests/bpf/prog_tests/fentry_test.c
* Unmerged path tools/testing/selftests/bpf/prog_tests/fexit_test.c
