libbpf: Add support for program extensions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Alexei Starovoitov <ast@kernel.org>
commit 2db6eab18b9778d55f48c804f8efebd7097e7958
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/2db6eab1.failed

Add minimal support for program extensions. bpf_object_open_opts() needs to be
called with attach_prog_fd = target_prog_fd and BPF program extension needs to
have in .c file section definition like SEC("freplace/func_to_be_replaced").
libbpf will search for "func_to_be_replaced" in the target_prog_fd's BTF and
will pass it in attach_btf_id to the kernel. This approach works for tests, but
more compex use case may need to request function name (and attach_btf_id that
kernel sees) to be more dynamic. Such API will be added in future patches.

	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: John Fastabend <john.fastabend@gmail.com>
	Acked-by: Andrii Nakryiko <andriin@fb.com>
	Acked-by: Toke Høiland-Jørgensen <toke@redhat.com>
Link: https://lore.kernel.org/bpf/20200121005348.2769920-3-ast@kernel.org
(cherry picked from commit 2db6eab18b9778d55f48c804f8efebd7097e7958)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/include/uapi/linux/bpf.h
#	tools/lib/bpf/bpf.c
#	tools/lib/bpf/libbpf.c
#	tools/lib/bpf/libbpf.h
#	tools/lib/bpf/libbpf.map
#	tools/lib/bpf/libbpf_probes.c
diff --cc tools/include/uapi/linux/bpf.h
index 4c50a38c7288,e81628eb059c..000000000000
--- a/tools/include/uapi/linux/bpf.h
+++ b/tools/include/uapi/linux/bpf.h
@@@ -173,6 -178,9 +173,12 @@@ enum bpf_prog_type 
  	BPF_PROG_TYPE_CGROUP_SYSCTL,
  	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE,
  	BPF_PROG_TYPE_CGROUP_SOCKOPT,
++<<<<<<< HEAD
++=======
+ 	BPF_PROG_TYPE_TRACING,
+ 	BPF_PROG_TYPE_STRUCT_OPS,
+ 	BPF_PROG_TYPE_EXT,
++>>>>>>> 2db6eab18b97 (libbpf: Add support for program extensions)
  };
  
  enum bpf_attach_type {
diff --cc tools/lib/bpf/bpf.c
index f9124e381f55,c6dafe563176..000000000000
--- a/tools/lib/bpf/bpf.c
+++ b/tools/lib/bpf/bpf.c
@@@ -228,9 -235,16 +228,22 @@@ int bpf_load_program_xattr(const struc
  	memset(&attr, 0, sizeof(attr));
  	attr.prog_type = load_attr->prog_type;
  	attr.expected_attach_type = load_attr->expected_attach_type;
++<<<<<<< HEAD
 +	if (attr.prog_type == BPF_PROG_TYPE_RAW_TRACEPOINT)
 +		/* expected_attach_type is ignored for tracing progs */
 +		attr.attach_btf_id = attr.expected_attach_type;
++=======
+ 	if (attr.prog_type == BPF_PROG_TYPE_STRUCT_OPS) {
+ 		attr.attach_btf_id = load_attr->attach_btf_id;
+ 	} else if (attr.prog_type == BPF_PROG_TYPE_TRACING ||
+ 		   attr.prog_type == BPF_PROG_TYPE_EXT) {
+ 		attr.attach_btf_id = load_attr->attach_btf_id;
+ 		attr.attach_prog_fd = load_attr->attach_prog_fd;
+ 	} else {
+ 		attr.prog_ifindex = load_attr->prog_ifindex;
+ 		attr.kern_version = load_attr->kern_version;
+ 	}
++>>>>>>> 2db6eab18b97 (libbpf: Add support for program extensions)
  	attr.insn_cnt = (__u32)load_attr->insns_cnt;
  	attr.insns = ptr_to_u64(load_attr->insns);
  	attr.license = ptr_to_u64(load_attr->license);
diff --cc tools/lib/bpf/libbpf.c
index 6ed9ef84b398,ae34b681ae82..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -3819,8 -4835,16 +3819,21 @@@ load_program(struct bpf_program *prog, 
  	load_attr.insns = insns;
  	load_attr.insns_cnt = insns_cnt;
  	load_attr.license = license;
++<<<<<<< HEAD
 +	load_attr.kern_version = kern_version;
 +	load_attr.prog_ifindex = prog->prog_ifindex;
++=======
+ 	if (prog->type == BPF_PROG_TYPE_STRUCT_OPS) {
+ 		load_attr.attach_btf_id = prog->attach_btf_id;
+ 	} else if (prog->type == BPF_PROG_TYPE_TRACING ||
+ 		   prog->type == BPF_PROG_TYPE_EXT) {
+ 		load_attr.attach_prog_fd = prog->attach_prog_fd;
+ 		load_attr.attach_btf_id = prog->attach_btf_id;
+ 	} else {
+ 		load_attr.kern_version = kern_version;
+ 		load_attr.prog_ifindex = prog->prog_ifindex;
+ 	}
++>>>>>>> 2db6eab18b97 (libbpf: Add support for program extensions)
  	/* if .BTF.ext was loaded, kernel supports associated BTF for prog */
  	if (prog->obj->btf_ext)
  		btf_fd = bpf_object__btf_fd(prog->obj);
@@@ -3889,11 -4913,19 +3902,23 @@@ out
  	return ret;
  }
  
 -static int libbpf_find_attach_btf_id(struct bpf_program *prog);
 -
 -int bpf_program__load(struct bpf_program *prog, char *license, __u32 kern_ver)
 +int
 +bpf_program__load(struct bpf_program *prog,
 +		  char *license, __u32 kern_version)
  {
++<<<<<<< HEAD
 +	int err = 0, fd, i;
++=======
+ 	int err = 0, fd, i, btf_id;
+ 
+ 	if (prog->type == BPF_PROG_TYPE_TRACING ||
+ 	    prog->type == BPF_PROG_TYPE_EXT) {
+ 		btf_id = libbpf_find_attach_btf_id(prog);
+ 		if (btf_id <= 0)
+ 			return btf_id;
+ 		prog->attach_btf_id = btf_id;
+ 	}
++>>>>>>> 2db6eab18b97 (libbpf: Add support for program extensions)
  
  	if (prog->instances.nr < 0 || !prog->instances.fds) {
  		if (prog->preprocessor) {
@@@ -4055,6 -5094,9 +4080,12 @@@ __bpf_object__open(const char *path, co
  
  		bpf_program__set_type(prog, prog_type);
  		bpf_program__set_expected_attach_type(prog, attach_type);
++<<<<<<< HEAD
++=======
+ 		if (prog_type == BPF_PROG_TYPE_TRACING ||
+ 		    prog_type == BPF_PROG_TYPE_EXT)
+ 			prog->attach_prog_fd = OPTS_GET(opts, attach_prog_fd, 0);
++>>>>>>> 2db6eab18b97 (libbpf: Add support for program extensions)
  	}
  
  	return obj;
@@@ -5008,6 -6167,9 +5039,12 @@@ BPF_PROG_TYPE_FNS(tracepoint, BPF_PROG_
  BPF_PROG_TYPE_FNS(raw_tracepoint, BPF_PROG_TYPE_RAW_TRACEPOINT);
  BPF_PROG_TYPE_FNS(xdp, BPF_PROG_TYPE_XDP);
  BPF_PROG_TYPE_FNS(perf_event, BPF_PROG_TYPE_PERF_EVENT);
++<<<<<<< HEAD
++=======
+ BPF_PROG_TYPE_FNS(tracing, BPF_PROG_TYPE_TRACING);
+ BPF_PROG_TYPE_FNS(struct_ops, BPF_PROG_TYPE_STRUCT_OPS);
+ BPF_PROG_TYPE_FNS(extension, BPF_PROG_TYPE_EXT);
++>>>>>>> 2db6eab18b97 (libbpf: Add support for program extensions)
  
  enum bpf_attach_type
  bpf_program__get_expected_attach_type(struct bpf_program *prog)
@@@ -5060,11 -6249,29 +5097,37 @@@ static const struct 
  	BPF_PROG_SEC("uretprobe/",		BPF_PROG_TYPE_KPROBE),
  	BPF_PROG_SEC("classifier",		BPF_PROG_TYPE_SCHED_CLS),
  	BPF_PROG_SEC("action",			BPF_PROG_TYPE_SCHED_ACT),
++<<<<<<< HEAD
 +	BPF_PROG_SEC("tracepoint/",		BPF_PROG_TYPE_TRACEPOINT),
 +	BPF_PROG_SEC("tp/",			BPF_PROG_TYPE_TRACEPOINT),
 +	BPF_PROG_SEC("raw_tracepoint/",		BPF_PROG_TYPE_RAW_TRACEPOINT),
 +	BPF_PROG_SEC("raw_tp/",			BPF_PROG_TYPE_RAW_TRACEPOINT),
 +	BPF_PROG_BTF("tp_btf/",			BPF_PROG_TYPE_RAW_TRACEPOINT),
++=======
+ 	SEC_DEF("tracepoint/", TRACEPOINT,
+ 		.attach_fn = attach_tp),
+ 	SEC_DEF("tp/", TRACEPOINT,
+ 		.attach_fn = attach_tp),
+ 	SEC_DEF("raw_tracepoint/", RAW_TRACEPOINT,
+ 		.attach_fn = attach_raw_tp),
+ 	SEC_DEF("raw_tp/", RAW_TRACEPOINT,
+ 		.attach_fn = attach_raw_tp),
+ 	SEC_DEF("tp_btf/", TRACING,
+ 		.expected_attach_type = BPF_TRACE_RAW_TP,
+ 		.is_attach_btf = true,
+ 		.attach_fn = attach_trace),
+ 	SEC_DEF("fentry/", TRACING,
+ 		.expected_attach_type = BPF_TRACE_FENTRY,
+ 		.is_attach_btf = true,
+ 		.attach_fn = attach_trace),
+ 	SEC_DEF("fexit/", TRACING,
+ 		.expected_attach_type = BPF_TRACE_FEXIT,
+ 		.is_attach_btf = true,
+ 		.attach_fn = attach_trace),
+ 	SEC_DEF("freplace/", EXT,
+ 		.is_attach_btf = true,
+ 		.attach_fn = attach_trace),
++>>>>>>> 2db6eab18b97 (libbpf: Add support for program extensions)
  	BPF_PROG_SEC("xdp",			BPF_PROG_TYPE_XDP),
  	BPF_PROG_SEC("perf_event",		BPF_PROG_TYPE_PERF_EVENT),
  	BPF_PROG_SEC("lwt_in",			BPF_PROG_TYPE_LWT_IN),
diff --cc tools/lib/bpf/libbpf.h
index e454ceec9fa2,2a5e3b087002..000000000000
--- a/tools/lib/bpf/libbpf.h
+++ b/tools/lib/bpf/libbpf.h
@@@ -297,6 -316,9 +297,12 @@@ LIBBPF_API int bpf_program__set_sched_c
  LIBBPF_API int bpf_program__set_sched_act(struct bpf_program *prog);
  LIBBPF_API int bpf_program__set_xdp(struct bpf_program *prog);
  LIBBPF_API int bpf_program__set_perf_event(struct bpf_program *prog);
++<<<<<<< HEAD
++=======
+ LIBBPF_API int bpf_program__set_tracing(struct bpf_program *prog);
+ LIBBPF_API int bpf_program__set_struct_ops(struct bpf_program *prog);
+ LIBBPF_API int bpf_program__set_extension(struct bpf_program *prog);
++>>>>>>> 2db6eab18b97 (libbpf: Add support for program extensions)
  
  LIBBPF_API enum bpf_prog_type bpf_program__get_type(struct bpf_program *prog);
  LIBBPF_API void bpf_program__set_type(struct bpf_program *prog,
@@@ -316,6 -338,9 +322,12 @@@ LIBBPF_API bool bpf_program__is_sched_c
  LIBBPF_API bool bpf_program__is_sched_act(const struct bpf_program *prog);
  LIBBPF_API bool bpf_program__is_xdp(const struct bpf_program *prog);
  LIBBPF_API bool bpf_program__is_perf_event(const struct bpf_program *prog);
++<<<<<<< HEAD
++=======
+ LIBBPF_API bool bpf_program__is_tracing(const struct bpf_program *prog);
+ LIBBPF_API bool bpf_program__is_struct_ops(const struct bpf_program *prog);
+ LIBBPF_API bool bpf_program__is_extension(const struct bpf_program *prog);
++>>>>>>> 2db6eab18b97 (libbpf: Add support for program extensions)
  
  /*
   * No need for __attribute__((packed)), all members of 'bpf_map_def'
diff --cc tools/lib/bpf/libbpf.map
index 3ca7228af37e,b035122142bb..000000000000
--- a/tools/lib/bpf/libbpf.map
+++ b/tools/lib/bpf/libbpf.map
@@@ -188,9 -197,41 +188,42 @@@ LIBBPF_0.0.4 
  		bpf_map__get_pin_path;
  		bpf_map__is_pinned;
  		bpf_map__set_pin_path;
 -		bpf_object__open_file;
 -		bpf_object__open_mem;
 -		bpf_program__attach_trace;
  		bpf_program__get_expected_attach_type;
  		bpf_program__get_type;
 -		bpf_program__is_tracing;
 -		bpf_program__set_tracing;
 +		bpf_get_link_xdp_info;
  		bpf_program__size;
++<<<<<<< HEAD
 +		bpf_btf_get_next_id;
 +} LIBBPF_0.0.3;
++=======
+ 		btf__find_by_name_kind;
+ 		libbpf_find_vmlinux_btf_id;
+ } LIBBPF_0.0.5;
+ 
+ LIBBPF_0.0.7 {
+ 	global:
+ 		btf_dump__emit_type_decl;
+ 		bpf_link__disconnect;
+ 		bpf_map__attach_struct_ops;
+ 		bpf_map_delete_batch;
+ 		bpf_map_lookup_and_delete_batch;
+ 		bpf_map_lookup_batch;
+ 		bpf_map_update_batch;
+ 		bpf_object__find_program_by_name;
+ 		bpf_object__attach_skeleton;
+ 		bpf_object__destroy_skeleton;
+ 		bpf_object__detach_skeleton;
+ 		bpf_object__load_skeleton;
+ 		bpf_object__open_skeleton;
+ 		bpf_probe_large_insn_limit;
+ 		bpf_prog_attach_xattr;
+ 		bpf_program__attach;
+ 		bpf_program__name;
+ 		bpf_program__is_extension;
+ 		bpf_program__is_struct_ops;
+ 		bpf_program__set_extension;
+ 		bpf_program__set_struct_ops;
+ 		btf__align_of;
+ 		libbpf_find_kernel_btf;
+ } LIBBPF_0.0.6;
++>>>>>>> 2db6eab18b97 (libbpf: Add support for program extensions)
diff --cc tools/lib/bpf/libbpf_probes.c
index 4b0b0364f5fc,b782ebef6ac9..000000000000
--- a/tools/lib/bpf/libbpf_probes.c
+++ b/tools/lib/bpf/libbpf_probes.c
@@@ -102,6 -105,9 +102,12 @@@ probe_load(enum bpf_prog_type prog_type
  	case BPF_PROG_TYPE_FLOW_DISSECTOR:
  	case BPF_PROG_TYPE_CGROUP_SYSCTL:
  	case BPF_PROG_TYPE_CGROUP_SOCKOPT:
++<<<<<<< HEAD
++=======
+ 	case BPF_PROG_TYPE_TRACING:
+ 	case BPF_PROG_TYPE_STRUCT_OPS:
+ 	case BPF_PROG_TYPE_EXT:
++>>>>>>> 2db6eab18b97 (libbpf: Add support for program extensions)
  	default:
  		break;
  	}
* Unmerged path tools/include/uapi/linux/bpf.h
* Unmerged path tools/lib/bpf/bpf.c
* Unmerged path tools/lib/bpf/libbpf.c
* Unmerged path tools/lib/bpf/libbpf.h
* Unmerged path tools/lib/bpf/libbpf.map
* Unmerged path tools/lib/bpf/libbpf_probes.c
