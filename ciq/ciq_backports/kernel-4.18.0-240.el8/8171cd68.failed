KVM: x86: use raw clock values consistently

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 8171cd68806bd2fc28ef688e32fb2a3b3deb04e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/8171cd68.failed

Commit 53fafdbb8b21f ("KVM: x86: switch KVMCLOCK base to monotonic raw
clock") changed kvmclock to use tkr_raw instead of tkr_mono.  However,
the default kvmclock_offset for the VM was still based on the monotonic
clock and, if the raw clock drifted enough from the monotonic clock,
this could cause a negative system_time to be written to the guest's
struct pvclock.  RHEL5 does not like it and (if it boots fast enough to
observe a negative time value) it hangs.

There is another thing to be careful about: getboottime64 returns the
host boot time with tkr_mono frequency, and subtracting the tkr_raw-based
kvmclock value will cause the wallclock to be off if tkr_raw drifts
from tkr_mono.  To avoid this, compute the wallclock delta from the
current time instead of being clever and using getboottime64.

Fixes: 53fafdbb8b21f ("KVM: x86: switch KVMCLOCK base to monotonic raw clock")
	Cc: stable@vger.kernel.org
	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 8171cd68806bd2fc28ef688e32fb2a3b3deb04e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index fb93b6c10029,6db92371ad21..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -1940,7 -1953,7 +1947,11 @@@ void kvm_write_tsc(struct kvm_vcpu *vcp
  
  	raw_spin_lock_irqsave(&kvm->arch.tsc_write_lock, flags);
  	offset = kvm_compute_tsc_offset(vcpu, data);
++<<<<<<< HEAD
 +	ns = ktime_get_boot_ns();
++=======
+ 	ns = get_kvmclock_base_ns();
++>>>>>>> 8171cd68806b (KVM: x86: use raw clock values consistently)
  	elapsed = ns - kvm->arch.last_tsc_nsec;
  
  	if (vcpu->arch.virtual_tsc_khz) {
@@@ -2278,7 -2291,7 +2289,11 @@@ u64 get_kvmclock_ns(struct kvm *kvm
  	spin_lock(&ka->pvclock_gtod_sync_lock);
  	if (!ka->use_master_clock) {
  		spin_unlock(&ka->pvclock_gtod_sync_lock);
++<<<<<<< HEAD
 +		return ktime_get_boot_ns() + ka->kvmclock_offset;
++=======
+ 		return get_kvmclock_base_ns() + ka->kvmclock_offset;
++>>>>>>> 8171cd68806b (KVM: x86: use raw clock values consistently)
  	}
  
  	hv_clock.tsc_timestamp = ka->master_cycle_now;
@@@ -2294,7 -2307,7 +2309,11 @@@
  				   &hv_clock.tsc_to_system_mul);
  		ret = __pvclock_read_cycles(&hv_clock, rdtsc());
  	} else
++<<<<<<< HEAD
 +		ret = ktime_get_boot_ns() + ka->kvmclock_offset;
++=======
+ 		ret = get_kvmclock_base_ns() + ka->kvmclock_offset;
++>>>>>>> 8171cd68806b (KVM: x86: use raw clock values consistently)
  
  	put_cpu();
  
@@@ -2393,7 -2406,7 +2412,11 @@@ static int kvm_guest_time_update(struc
  	}
  	if (!use_master_clock) {
  		host_tsc = rdtsc();
++<<<<<<< HEAD
 +		kernel_ns = ktime_get_boot_ns();
++=======
+ 		kernel_ns = get_kvmclock_base_ns();
++>>>>>>> 8171cd68806b (KVM: x86: use raw clock values consistently)
  	}
  
  	tsc_timestamp = kvm_read_l1_tsc(v, host_tsc);
@@@ -9606,7 -9685,7 +9630,11 @@@ int kvm_arch_init_vm(struct kvm *kvm, u
  	mutex_init(&kvm->arch.apic_map_lock);
  	spin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);
  
++<<<<<<< HEAD
 +	kvm->arch.kvmclock_offset = -ktime_get_boot_ns();
++=======
+ 	kvm->arch.kvmclock_offset = -get_kvmclock_base_ns();
++>>>>>>> 8171cd68806b (KVM: x86: use raw clock values consistently)
  	pvclock_update_vm_gtod_copy(kvm);
  
  	kvm->arch.guest_can_read_msr_platform_info = true;
* Unmerged path arch/x86/kvm/x86.c
