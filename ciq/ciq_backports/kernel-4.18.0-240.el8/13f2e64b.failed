mlxsw: spectrum_trap: Add devlink-trap policer support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ido Schimmel <idosch@mellanox.com>
commit 13f2e64b94eaf9131472a1102e1ee25b32e86fed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/13f2e64b.failed

Register supported packet trap policers with devlink and implement
callbacks to change their parameters and read their counters.

Prevent user space from passing invalid policer parameters down to the
device by checking their validity and communicating the failure via an
appropriate extack message.

v2:
* Remove the max/min validity checks from __mlxsw_sp_trap_policer_set()

	Signed-off-by: Ido Schimmel <idosch@mellanox.com>
	Reviewed-by: Jiri Pirko <jiri@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 13f2e64b94eaf9131472a1102e1ee25b32e86fed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.h
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
index 13424366f1bb,b2e41eb5ffdb..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
@@@ -1,7 -1,9 +1,8 @@@
  // SPDX-License-Identifier: BSD-3-Clause OR GPL-2.0
  /* Copyright (c) 2019 Mellanox Technologies. All rights reserved */
  
 -#include <linux/bitops.h>
  #include <linux/kernel.h>
+ #include <linux/netlink.h>
  #include <net/devlink.h>
  #include <uapi/linux/devlink.h>
  
@@@ -106,11 -168,23 +107,18 @@@ static void mlxsw_sp_rx_exception_liste
  	MLXSW_RXL(mlxsw_sp_rx_exception_listener, _id,			      \
  		   _action, false, SP_##_group_id, SET_FW_DEFAULT)
  
 -#define MLXSW_SP_TRAP_POLICER(_id, _rate, _burst)			      \
 -	DEVLINK_TRAP_POLICER(_id, _rate, _burst,			      \
 -			     MLXSW_REG_QPCR_HIGHEST_CIR,		      \
 -			     MLXSW_REG_QPCR_LOWEST_CIR,			      \
 -			     1 << MLXSW_REG_QPCR_HIGHEST_CBS,		      \
 -			     1 << MLXSW_REG_QPCR_LOWEST_CBS)
 -
 -/* Ordered by policer identifier */
 -static const struct devlink_trap_policer mlxsw_sp_trap_policers_arr[] = {
 -	MLXSW_SP_TRAP_POLICER(1, 10 * 1024, 128),
 -};
 -
  static const struct devlink_trap_group mlxsw_sp_trap_groups_arr[] = {
++<<<<<<< HEAD
 +	DEVLINK_TRAP_GROUP_GENERIC(L2_DROPS),
 +	DEVLINK_TRAP_GROUP_GENERIC(L3_DROPS),
 +	DEVLINK_TRAP_GROUP_GENERIC(TUNNEL_DROPS),
 +	DEVLINK_TRAP_GROUP_GENERIC(ACL_DROPS),
++=======
+ 	DEVLINK_TRAP_GROUP_GENERIC(L2_DROPS, 1),
+ 	DEVLINK_TRAP_GROUP_GENERIC(L3_DROPS, 1),
+ 	DEVLINK_TRAP_GROUP_GENERIC(TUNNEL_DROPS, 1),
+ 	DEVLINK_TRAP_GROUP_GENERIC(ACL_DROPS, 1),
++>>>>>>> 13f2e64b94ea (mlxsw: spectrum_trap: Add devlink-trap policer support)
  };
  
  static const struct devlink_trap mlxsw_sp_traps_arr[] = {
@@@ -202,8 -296,131 +210,125 @@@ static const u16 mlxsw_sp_listener_devl
  	DEVLINK_TRAP_GENERIC_ID_UNRESOLVED_NEIGH,
  	DEVLINK_TRAP_GENERIC_ID_IPV4_LPM_UNICAST_MISS,
  	DEVLINK_TRAP_GENERIC_ID_IPV6_LPM_UNICAST_MISS,
 -	DEVLINK_MLXSW_TRAP_ID_IRIF_DISABLED,
 -	DEVLINK_MLXSW_TRAP_ID_ERIF_DISABLED,
 -	DEVLINK_TRAP_GENERIC_ID_NON_ROUTABLE,
 -	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR,
 -	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR,
 -	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR,
 -	DEVLINK_TRAP_GENERIC_ID_OVERLAY_SMAC_MC,
 -	DEVLINK_TRAP_GENERIC_ID_INGRESS_FLOW_ACTION_DROP,
 -	DEVLINK_TRAP_GENERIC_ID_EGRESS_FLOW_ACTION_DROP,
  };
  
++<<<<<<< HEAD
++=======
+ #define MLXSW_SP_DISCARD_POLICER_ID	(MLXSW_REG_HTGT_TRAP_GROUP_MAX + 1)
+ #define MLXSW_SP_THIN_POLICER_ID	(MLXSW_SP_DISCARD_POLICER_ID + 1)
+ 
+ static struct mlxsw_sp_trap_policer_item *
+ mlxsw_sp_trap_policer_item_lookup(struct mlxsw_sp *mlxsw_sp, u32 id)
+ {
+ 	struct mlxsw_sp_trap_policer_item *policer_item;
+ 	struct mlxsw_sp_trap *trap = mlxsw_sp->trap;
+ 
+ 	list_for_each_entry(policer_item, &trap->policer_item_list, list) {
+ 		if (policer_item->id == id)
+ 			return policer_item;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static int mlxsw_sp_trap_cpu_policers_set(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	char qpcr_pl[MLXSW_REG_QPCR_LEN];
+ 	int err;
+ 
+ 	mlxsw_reg_qpcr_pack(qpcr_pl, MLXSW_SP_DISCARD_POLICER_ID,
+ 			    MLXSW_REG_QPCR_IR_UNITS_M, false, 10 * 1024, 7);
+ 	err = mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpcr), qpcr_pl);
+ 	if (err)
+ 		return err;
+ 
+ 	/* The purpose of "thin" policer is to drop as many packets
+ 	 * as possible. The dummy group is using it.
+ 	 */
+ 	__set_bit(MLXSW_SP_THIN_POLICER_ID, mlxsw_sp->trap->policers_usage);
+ 	mlxsw_reg_qpcr_pack(qpcr_pl, MLXSW_SP_THIN_POLICER_ID,
+ 			    MLXSW_REG_QPCR_IR_UNITS_M, false, 1, 4);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpcr), qpcr_pl);
+ }
+ 
+ static int mlxsw_sp_trap_dummy_group_init(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	char htgt_pl[MLXSW_REG_HTGT_LEN];
+ 
+ 	mlxsw_reg_htgt_pack(htgt_pl, MLXSW_REG_HTGT_TRAP_GROUP_SP_DUMMY,
+ 			    MLXSW_SP_THIN_POLICER_ID, 0, 1);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(htgt), htgt_pl);
+ }
+ 
+ static int mlxsw_sp_trap_policers_init(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	struct devlink *devlink = priv_to_devlink(mlxsw_sp->core);
+ 	struct mlxsw_sp_trap *trap = mlxsw_sp->trap;
+ 	u64 free_policers = 0;
+ 	u32 last_id = 0;
+ 	int err, i;
+ 
+ 	for_each_clear_bit(i, trap->policers_usage, trap->max_policers)
+ 		free_policers++;
+ 
+ 	if (ARRAY_SIZE(mlxsw_sp_trap_policers_arr) > free_policers) {
+ 		dev_err(mlxsw_sp->bus_info->dev, "Exceeded number of supported packet trap policers\n");
+ 		return -ENOBUFS;
+ 	}
+ 
+ 	trap->policers_arr = kcalloc(free_policers,
+ 				     sizeof(struct devlink_trap_policer),
+ 				     GFP_KERNEL);
+ 	if (!trap->policers_arr)
+ 		return -ENOMEM;
+ 
+ 	trap->policers_count = free_policers;
+ 
+ 	for (i = 0; i < free_policers; i++) {
+ 		const struct devlink_trap_policer *policer;
+ 
+ 		if (i < ARRAY_SIZE(mlxsw_sp_trap_policers_arr)) {
+ 			policer = &mlxsw_sp_trap_policers_arr[i];
+ 			trap->policers_arr[i] = *policer;
+ 			last_id = policer->id;
+ 		} else {
+ 			/* Use parameters set for first policer and override
+ 			 * relevant ones.
+ 			 */
+ 			policer = &mlxsw_sp_trap_policers_arr[0];
+ 			trap->policers_arr[i] = *policer;
+ 			trap->policers_arr[i].id = ++last_id;
+ 			trap->policers_arr[i].init_rate = 1;
+ 			trap->policers_arr[i].init_burst = 16;
+ 		}
+ 	}
+ 
+ 	INIT_LIST_HEAD(&trap->policer_item_list);
+ 
+ 	err = devlink_trap_policers_register(devlink, trap->policers_arr,
+ 					     trap->policers_count);
+ 	if (err)
+ 		goto err_trap_policers_register;
+ 
+ 	return 0;
+ 
+ err_trap_policers_register:
+ 	kfree(trap->policers_arr);
+ 	return err;
+ }
+ 
+ static void mlxsw_sp_trap_policers_fini(struct mlxsw_sp *mlxsw_sp)
+ {
+ 	struct devlink *devlink = priv_to_devlink(mlxsw_sp->core);
+ 	struct mlxsw_sp_trap *trap = mlxsw_sp->trap;
+ 
+ 	devlink_trap_policers_unregister(devlink, trap->policers_arr,
+ 					 trap->policers_count);
+ 	WARN_ON(!list_empty(&trap->policer_item_list));
+ 	kfree(trap->policers_arr);
+ }
+ 
++>>>>>>> 13f2e64b94ea (mlxsw: spectrum_trap: Add devlink-trap policer support)
  int mlxsw_sp_devlink_traps_init(struct mlxsw_sp *mlxsw_sp)
  {
  	size_t groups_count = ARRAY_SIZE(mlxsw_sp_trap_groups_arr);
@@@ -311,44 -544,13 +436,45 @@@ int mlxsw_sp_trap_action_set(struct mlx
  	return 0;
  }
  
 -int mlxsw_sp_trap_group_init(struct mlxsw_core *mlxsw_core,
 -			     const struct devlink_trap_group *group)
 +#define MLXSW_SP_DISCARD_POLICER_ID	(MLXSW_REG_HTGT_TRAP_GROUP_MAX + 1)
 +
 +static int
 +mlxsw_sp_trap_group_policer_init(struct mlxsw_sp *mlxsw_sp,
 +				 const struct devlink_trap_group *group)
 +{
 +	enum mlxsw_reg_qpcr_ir_units ir_units;
 +	char qpcr_pl[MLXSW_REG_QPCR_LEN];
 +	u16 policer_id;
 +	u8 burst_size;
 +	bool is_bytes;
 +	u32 rate;
 +
 +	switch (group->id) {
 +	case DEVLINK_TRAP_GROUP_GENERIC_ID_L2_DROPS: /* fall through */
 +	case DEVLINK_TRAP_GROUP_GENERIC_ID_L3_DROPS:
 +		policer_id = MLXSW_SP_DISCARD_POLICER_ID;
 +		ir_units = MLXSW_REG_QPCR_IR_UNITS_M;
 +		is_bytes = false;
 +		rate = 10 * 1024; /* 10Kpps */
 +		burst_size = 7;
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +
 +	mlxsw_reg_qpcr_pack(qpcr_pl, policer_id, ir_units, is_bytes, rate,
 +			    burst_size);
 +	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpcr), qpcr_pl);
 +}
 +
 +static int
 +__mlxsw_sp_trap_group_init(struct mlxsw_sp *mlxsw_sp,
 +			   const struct devlink_trap_group *group)
  {
+ 	struct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);
+ 	u16 hw_policer_id = MLXSW_REG_HTGT_INVALID_POLICER;
  	char htgt_pl[MLXSW_REG_HTGT_LEN];
  	u8 priority, tc, group_id;
- 	u16 policer_id;
  
  	switch (group->id) {
  	case DEVLINK_TRAP_GROUP_GENERIC_ID_L2_DROPS:
@@@ -362,28 -563,177 +487,202 @@@
  		priority = 0;
  		tc = 1;
  		break;
++<<<<<<< HEAD
++=======
+ 	case DEVLINK_TRAP_GROUP_GENERIC_ID_TUNNEL_DROPS:
+ 		group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_TUNNEL_DISCARDS;
+ 		priority = 0;
+ 		tc = 1;
+ 		break;
+ 	case DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_DROPS:
+ 		group_id = MLXSW_REG_HTGT_TRAP_GROUP_SP_ACL_DISCARDS;
+ 		priority = 0;
+ 		tc = 1;
+ 		break;
++>>>>>>> 13f2e64b94ea (mlxsw: spectrum_trap: Add devlink-trap policer support)
  	default:
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	mlxsw_reg_htgt_pack(htgt_pl, group_id, policer_id, priority, tc);
 +	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(htgt), htgt_pl);
 +}
 +
 +int mlxsw_sp_trap_group_init(struct mlxsw_core *mlxsw_core,
 +			     const struct devlink_trap_group *group)
 +{
 +	struct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);
 +	int err;
 +
 +	err = mlxsw_sp_trap_group_policer_init(mlxsw_sp, group);
 +	if (err)
 +		return err;
 +
 +	err = __mlxsw_sp_trap_group_init(mlxsw_sp, group);
 +	if (err)
 +		return err;
 +
++	return 0;
++=======
+ 	if (group->init_policer_id) {
+ 		struct mlxsw_sp_trap_policer_item *policer_item;
+ 		u32 id = group->init_policer_id;
+ 
+ 		policer_item = mlxsw_sp_trap_policer_item_lookup(mlxsw_sp, id);
+ 		if (WARN_ON(!policer_item))
+ 			return -EINVAL;
+ 		hw_policer_id = policer_item->hw_id;
+ 	}
+ 
+ 	mlxsw_reg_htgt_pack(htgt_pl, group_id, hw_policer_id, priority, tc);
+ 	return mlxsw_reg_write(mlxsw_core, MLXSW_REG(htgt), htgt_pl);
++>>>>>>> 13f2e64b94ea (mlxsw: spectrum_trap: Add devlink-trap policer support)
+ }
+ 
+ static struct mlxsw_sp_trap_policer_item *
+ mlxsw_sp_trap_policer_item_init(struct mlxsw_sp *mlxsw_sp, u32 id)
+ {
+ 	struct mlxsw_sp_trap_policer_item *policer_item;
+ 	struct mlxsw_sp_trap *trap = mlxsw_sp->trap;
+ 	u16 hw_id;
+ 
+ 	/* We should be able to allocate a policer because the number of
+ 	 * policers we registered with devlink is in according with the number
+ 	 * of available policers.
+ 	 */
+ 	hw_id = find_first_zero_bit(trap->policers_usage, trap->max_policers);
+ 	if (WARN_ON(hw_id == trap->max_policers))
+ 		return ERR_PTR(-ENOBUFS);
+ 
+ 	policer_item = kzalloc(sizeof(*policer_item), GFP_KERNEL);
+ 	if (!policer_item)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	__set_bit(hw_id, trap->policers_usage);
+ 	policer_item->hw_id = hw_id;
+ 	policer_item->id = id;
+ 	list_add_tail(&policer_item->list, &trap->policer_item_list);
+ 
+ 	return policer_item;
+ }
+ 
+ static void
+ mlxsw_sp_trap_policer_item_fini(struct mlxsw_sp *mlxsw_sp,
+ 				struct mlxsw_sp_trap_policer_item *policer_item)
+ {
+ 	list_del(&policer_item->list);
+ 	__clear_bit(policer_item->hw_id, mlxsw_sp->trap->policers_usage);
+ 	kfree(policer_item);
+ }
+ 
+ static int mlxsw_sp_trap_policer_bs(u64 burst, u8 *p_burst_size,
+ 				    struct netlink_ext_ack *extack)
+ {
+ 	int bs = fls64(burst) - 1;
+ 
+ 	if (burst != (1 << bs)) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Policer burst size is not power of two");
+ 		return -EINVAL;
+ 	}
+ 
+ 	*p_burst_size = bs;
+ 
+ 	return 0;
+ }
+ 
+ static int __mlxsw_sp_trap_policer_set(struct mlxsw_sp *mlxsw_sp, u16 hw_id,
+ 				       u64 rate, u64 burst, bool clear_counter,
+ 				       struct netlink_ext_ack *extack)
+ {
+ 	char qpcr_pl[MLXSW_REG_QPCR_LEN];
+ 	u8 burst_size;
+ 	int err;
+ 
+ 	err = mlxsw_sp_trap_policer_bs(burst, &burst_size, extack);
+ 	if (err)
+ 		return err;
+ 
+ 	mlxsw_reg_qpcr_pack(qpcr_pl, hw_id, MLXSW_REG_QPCR_IR_UNITS_M, false,
+ 			    rate, burst_size);
+ 	mlxsw_reg_qpcr_clear_counter_set(qpcr_pl, clear_counter);
+ 	return mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(qpcr), qpcr_pl);
+ }
+ 
+ int mlxsw_sp_trap_policer_init(struct mlxsw_core *mlxsw_core,
+ 			       const struct devlink_trap_policer *policer)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);
+ 	struct mlxsw_sp_trap_policer_item *policer_item;
+ 	int err;
+ 
+ 	policer_item = mlxsw_sp_trap_policer_item_init(mlxsw_sp, policer->id);
+ 	if (IS_ERR(policer_item))
+ 		return PTR_ERR(policer_item);
+ 
+ 	err = __mlxsw_sp_trap_policer_set(mlxsw_sp, policer_item->hw_id,
+ 					  policer->init_rate,
+ 					  policer->init_burst, true, NULL);
+ 	if (err)
+ 		goto err_trap_policer_set;
+ 
+ 	return 0;
+ 
+ err_trap_policer_set:
+ 	mlxsw_sp_trap_policer_item_fini(mlxsw_sp, policer_item);
+ 	return err;
+ }
+ 
+ void mlxsw_sp_trap_policer_fini(struct mlxsw_core *mlxsw_core,
+ 				const struct devlink_trap_policer *policer)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);
+ 	struct mlxsw_sp_trap_policer_item *policer_item;
+ 
+ 	policer_item = mlxsw_sp_trap_policer_item_lookup(mlxsw_sp, policer->id);
+ 	if (WARN_ON(!policer_item))
+ 		return;
+ 
+ 	mlxsw_sp_trap_policer_item_fini(mlxsw_sp, policer_item);
+ }
+ 
+ int mlxsw_sp_trap_policer_set(struct mlxsw_core *mlxsw_core,
+ 			      const struct devlink_trap_policer *policer,
+ 			      u64 rate, u64 burst,
+ 			      struct netlink_ext_ack *extack)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);
+ 	struct mlxsw_sp_trap_policer_item *policer_item;
+ 
+ 	policer_item = mlxsw_sp_trap_policer_item_lookup(mlxsw_sp, policer->id);
+ 	if (WARN_ON(!policer_item))
+ 		return -EINVAL;
+ 
+ 	return __mlxsw_sp_trap_policer_set(mlxsw_sp, policer_item->hw_id,
+ 					   rate, burst, false, extack);
+ }
+ 
+ int
+ mlxsw_sp_trap_policer_counter_get(struct mlxsw_core *mlxsw_core,
+ 				  const struct devlink_trap_policer *policer,
+ 				  u64 *p_drops)
+ {
+ 	struct mlxsw_sp *mlxsw_sp = mlxsw_core_driver_priv(mlxsw_core);
+ 	struct mlxsw_sp_trap_policer_item *policer_item;
+ 	char qpcr_pl[MLXSW_REG_QPCR_LEN];
+ 	int err;
+ 
+ 	policer_item = mlxsw_sp_trap_policer_item_lookup(mlxsw_sp, policer->id);
+ 	if (WARN_ON(!policer_item))
+ 		return -EINVAL;
+ 
+ 	mlxsw_reg_qpcr_pack(qpcr_pl, policer_item->hw_id,
+ 			    MLXSW_REG_QPCR_IR_UNITS_M, false, 0, 0);
+ 	err = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(qpcr), qpcr_pl);
+ 	if (err)
+ 		return err;
+ 
+ 	*p_drops = mlxsw_reg_qpcr_violate_count_get(qpcr_pl);
+ 
  	return 0;
  }
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.h
diff --git a/drivers/net/ethernet/mellanox/mlxsw/core.c b/drivers/net/ethernet/mellanox/mlxsw/core.c
index 885b75062085..a41d9eeab35f 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/core.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/core.c
@@ -1197,6 +1197,59 @@ mlxsw_devlink_trap_group_init(struct devlink *devlink,
 	return mlxsw_driver->trap_group_init(mlxsw_core, group);
 }
 
+static int
+mlxsw_devlink_trap_policer_init(struct devlink *devlink,
+				const struct devlink_trap_policer *policer)
+{
+	struct mlxsw_core *mlxsw_core = devlink_priv(devlink);
+	struct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;
+
+	if (!mlxsw_driver->trap_policer_init)
+		return -EOPNOTSUPP;
+	return mlxsw_driver->trap_policer_init(mlxsw_core, policer);
+}
+
+static void
+mlxsw_devlink_trap_policer_fini(struct devlink *devlink,
+				const struct devlink_trap_policer *policer)
+{
+	struct mlxsw_core *mlxsw_core = devlink_priv(devlink);
+	struct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;
+
+	if (!mlxsw_driver->trap_policer_fini)
+		return;
+	mlxsw_driver->trap_policer_fini(mlxsw_core, policer);
+}
+
+static int
+mlxsw_devlink_trap_policer_set(struct devlink *devlink,
+			       const struct devlink_trap_policer *policer,
+			       u64 rate, u64 burst,
+			       struct netlink_ext_ack *extack)
+{
+	struct mlxsw_core *mlxsw_core = devlink_priv(devlink);
+	struct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;
+
+	if (!mlxsw_driver->trap_policer_set)
+		return -EOPNOTSUPP;
+	return mlxsw_driver->trap_policer_set(mlxsw_core, policer, rate, burst,
+					      extack);
+}
+
+static int
+mlxsw_devlink_trap_policer_counter_get(struct devlink *devlink,
+				       const struct devlink_trap_policer *policer,
+				       u64 *p_drops)
+{
+	struct mlxsw_core *mlxsw_core = devlink_priv(devlink);
+	struct mlxsw_driver *mlxsw_driver = mlxsw_core->driver;
+
+	if (!mlxsw_driver->trap_policer_counter_get)
+		return -EOPNOTSUPP;
+	return mlxsw_driver->trap_policer_counter_get(mlxsw_core, policer,
+						      p_drops);
+}
+
 static const struct devlink_ops mlxsw_devlink_ops = {
 	.reload_down		= mlxsw_devlink_core_bus_device_reload_down,
 	.reload_up		= mlxsw_devlink_core_bus_device_reload_up,
@@ -1219,6 +1272,10 @@ static const struct devlink_ops mlxsw_devlink_ops = {
 	.trap_fini			= mlxsw_devlink_trap_fini,
 	.trap_action_set		= mlxsw_devlink_trap_action_set,
 	.trap_group_init		= mlxsw_devlink_trap_group_init,
+	.trap_policer_init		= mlxsw_devlink_trap_policer_init,
+	.trap_policer_fini		= mlxsw_devlink_trap_policer_fini,
+	.trap_policer_set		= mlxsw_devlink_trap_policer_set,
+	.trap_policer_counter_get	= mlxsw_devlink_trap_policer_counter_get,
 };
 
 static int
diff --git a/drivers/net/ethernet/mellanox/mlxsw/core.h b/drivers/net/ethernet/mellanox/mlxsw/core.h
index 4a005e104c33..37af5aad4503 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/core.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/core.h
@@ -324,6 +324,17 @@ struct mlxsw_driver {
 			       enum devlink_trap_action action);
 	int (*trap_group_init)(struct mlxsw_core *mlxsw_core,
 			       const struct devlink_trap_group *group);
+	int (*trap_policer_init)(struct mlxsw_core *mlxsw_core,
+				 const struct devlink_trap_policer *policer);
+	void (*trap_policer_fini)(struct mlxsw_core *mlxsw_core,
+				  const struct devlink_trap_policer *policer);
+	int (*trap_policer_set)(struct mlxsw_core *mlxsw_core,
+				const struct devlink_trap_policer *policer,
+				u64 rate, u64 burst,
+				struct netlink_ext_ack *extack);
+	int (*trap_policer_counter_get)(struct mlxsw_core *mlxsw_core,
+					const struct devlink_trap_policer *policer,
+					u64 *p_drops);
 	void (*txhdr_construct)(struct sk_buff *skb,
 				const struct mlxsw_tx_info *tx_info);
 	int (*resources_register)(struct mlxsw_core *mlxsw_core);
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
index df6805113dbf..f34115b08128 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.c
@@ -5657,6 +5657,10 @@ static struct mlxsw_driver mlxsw_sp1_driver = {
 	.trap_fini			= mlxsw_sp_trap_fini,
 	.trap_action_set		= mlxsw_sp_trap_action_set,
 	.trap_group_init		= mlxsw_sp_trap_group_init,
+	.trap_policer_init		= mlxsw_sp_trap_policer_init,
+	.trap_policer_fini		= mlxsw_sp_trap_policer_fini,
+	.trap_policer_set		= mlxsw_sp_trap_policer_set,
+	.trap_policer_counter_get	= mlxsw_sp_trap_policer_counter_get,
 	.txhdr_construct		= mlxsw_sp_txhdr_construct,
 	.resources_register		= mlxsw_sp1_resources_register,
 	.kvd_sizes_get			= mlxsw_sp_kvd_sizes_get,
@@ -5691,6 +5695,10 @@ static struct mlxsw_driver mlxsw_sp2_driver = {
 	.trap_fini			= mlxsw_sp_trap_fini,
 	.trap_action_set		= mlxsw_sp_trap_action_set,
 	.trap_group_init		= mlxsw_sp_trap_group_init,
+	.trap_policer_init		= mlxsw_sp_trap_policer_init,
+	.trap_policer_fini		= mlxsw_sp_trap_policer_fini,
+	.trap_policer_set		= mlxsw_sp_trap_policer_set,
+	.trap_policer_counter_get	= mlxsw_sp_trap_policer_counter_get,
 	.txhdr_construct		= mlxsw_sp_txhdr_construct,
 	.resources_register		= mlxsw_sp2_resources_register,
 	.params_register		= mlxsw_sp2_params_register,
@@ -5724,6 +5732,10 @@ static struct mlxsw_driver mlxsw_sp3_driver = {
 	.trap_fini			= mlxsw_sp_trap_fini,
 	.trap_action_set		= mlxsw_sp_trap_action_set,
 	.trap_group_init		= mlxsw_sp_trap_group_init,
+	.trap_policer_init		= mlxsw_sp_trap_policer_init,
+	.trap_policer_fini		= mlxsw_sp_trap_policer_fini,
+	.trap_policer_set		= mlxsw_sp_trap_policer_set,
+	.trap_policer_counter_get	= mlxsw_sp_trap_policer_counter_get,
 	.txhdr_construct		= mlxsw_sp_txhdr_construct,
 	.resources_register		= mlxsw_sp2_resources_register,
 	.params_register		= mlxsw_sp2_params_register,
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
index 2d08bfdfa522..4b32f85b7c38 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum.h
@@ -1015,5 +1015,18 @@ int mlxsw_sp_trap_action_set(struct mlxsw_core *mlxsw_core,
 			     enum devlink_trap_action action);
 int mlxsw_sp_trap_group_init(struct mlxsw_core *mlxsw_core,
 			     const struct devlink_trap_group *group);
+int
+mlxsw_sp_trap_policer_init(struct mlxsw_core *mlxsw_core,
+			   const struct devlink_trap_policer *policer);
+void mlxsw_sp_trap_policer_fini(struct mlxsw_core *mlxsw_core,
+				const struct devlink_trap_policer *policer);
+int
+mlxsw_sp_trap_policer_set(struct mlxsw_core *mlxsw_core,
+			  const struct devlink_trap_policer *policer,
+			  u64 rate, u64 burst, struct netlink_ext_ack *extack);
+int
+mlxsw_sp_trap_policer_counter_get(struct mlxsw_core *mlxsw_core,
+				  const struct devlink_trap_policer *policer,
+				  u64 *p_drops);
 
 #endif
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.c
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_trap.h
