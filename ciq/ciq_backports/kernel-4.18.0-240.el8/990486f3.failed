scsi: zfcp: Fence fc_host updates during link-down handling

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Benjamin Block <bblock@linux.ibm.com>
commit 990486f3a8508494dab2a7ff0fcc3eb977557d89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/990486f3.failed

When receiving a notification that a FCP device lost its local link we
usually update the fibre channel host object which represents that FCP
device to reflect that.

This notification/information can also surface when the FCP device is
running through adapter recovery (exchange config and exchange port data
return incomplete).

When moving the scsi host object allocation and registration - and thus
also the fibre channel host object allocation - to after the first exchange
config and exchange port data, and this happens during the very first
adapter recovery, these updates can not be done until after the scsi host
object is allocated.

Reorder the fc_host updates in zfcp_fsf_fc_host_link_down() so that they
only happen after a check of whether the scsi host object is already
allocated or not.

During the first adapter recovery this will cause the skip of these updates
if a link-down condition is detected, but we can repeat them after we
allocated the scsi host object, if necessary.

For any further link-down handling the only changes in the work flow are
the slightly reordered assignments in zfcp_fsf_fc_host_link_down().

Link: https://lore.kernel.org/r/f841f2cda61dcd7b8549910c44e1831927459edf.1588956679.git.bblock@linux.ibm.com
	Reviewed-by: Steffen Maier <maier@linux.ibm.com>
	Signed-off-by: Benjamin Block <bblock@linux.ibm.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 990486f3a8508494dab2a7ff0fcc3eb977557d89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/scsi/zfcp_fsf.c
diff --cc drivers/s390/scsi/zfcp_fsf.c
index 1ed6f3c18039,8c4b690e329e..000000000000
--- a/drivers/s390/scsi/zfcp_fsf.c
+++ b/drivers/s390/scsi/zfcp_fsf.c
@@@ -112,6 -120,27 +112,30 @@@ static void zfcp_fsf_status_read_port_c
  	read_unlock_irqrestore(&adapter->port_list_lock, flags);
  }
  
++<<<<<<< HEAD
++=======
+ static void zfcp_fsf_fc_host_link_down(struct zfcp_adapter *adapter)
+ {
+ 	struct Scsi_Host *shost = adapter->scsi_host;
+ 
+ 	adapter->hydra_version = 0;
+ 	adapter->peer_wwpn = 0;
+ 	adapter->peer_wwnn = 0;
+ 	adapter->peer_d_id = 0;
+ 
+ 	/* if there is no shost yet, we have nothing to zero-out */
+ 	if (shost == NULL)
+ 		return;
+ 
+ 	fc_host_port_id(shost) = 0;
+ 	fc_host_fabric_name(shost) = 0;
+ 	fc_host_speed(shost) = FC_PORTSPEED_UNKNOWN;
+ 	fc_host_port_type(shost) = FC_PORTTYPE_UNKNOWN;
+ 	snprintf(fc_host_model(shost), FC_SYMBOLIC_NAME_SIZE, "0x%04x", 0);
+ 	memset(fc_host_active_fc4s(shost), 0, FC_FC4_LIST_SIZE);
+ }
+ 
++>>>>>>> 990486f3a850 (scsi: zfcp: Fence fc_host updates during link-down handling)
  static void zfcp_fsf_link_down_info_eval(struct zfcp_fsf_req *req,
  					 struct fsf_link_down_info *link_down)
  {
* Unmerged path drivers/s390/scsi/zfcp_fsf.c
