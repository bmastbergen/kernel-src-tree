drm/i915/display: Move out code to return the digital_port of the aux ch

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author José Roberto de Souza <jose.souza@intel.com>
commit 34a3f0b273a7196b98668324556bce9f6dc091d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/34a3f0b2.failed

Moving the code to return the digital port of the aux channel also
removing the intel_phy_is_tc() to make it generic.
digital_port will be needed in icl_tc_phy_aux_power_well_enable()
so adding it as a parameter to icl_tc_port_assert_ref_held().

While at at removing the duplicated call to icl_tc_phy_aux_ch() in
icl_tc_port_assert_ref_held().

v2:
- fixed build when DRM_I915_DEBUG_RUNTIME_PM is not set
- moved to before hsw_wait_for_power_well_enable() as it will be
needed by hsw_wait_for_power_well_enable() in a future patch

v4:
- fixed action of if (!dig_port), continue instead of return

	Cc: You-Sheng Yang <vicamo@gmail.com>
	Reviewed-by: Imre Deak <imre.deak@intel.com>
	Tested-by: You-Sheng Yang <vicamo.yang@canonical.com>
	Signed-off-by: José Roberto de Souza <jose.souza@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20200414194956.164323-1-jose.souza@intel.com
(cherry picked from commit 34a3f0b273a7196b98668324556bce9f6dc091d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/display/intel_display_power.c
diff --cc drivers/gpu/drm/i915/display/intel_display_power.c
index dd1a43a366f2,0cf5ed0254cf..000000000000
--- a/drivers/gpu/drm/i915/display/intel_display_power.c
+++ b/drivers/gpu/drm/i915/display/intel_display_power.c
@@@ -441,24 -503,99 +468,116 @@@ icl_combo_phy_aux_power_well_disable(st
  #define ICL_TBT_AUX_PW_TO_CH(pw_idx)	\
  	((pw_idx) - ICL_PW_CTL_IDX_AUX_TBT1 + AUX_CH_C)
  
++<<<<<<< HEAD
++=======
+ static enum aux_ch icl_tc_phy_aux_ch(struct drm_i915_private *dev_priv,
+ 				     struct i915_power_well *power_well)
+ {
+ 	int pw_idx = power_well->desc->hsw.idx;
+ 
+ 	return power_well->desc->hsw.is_tc_tbt ? ICL_TBT_AUX_PW_TO_CH(pw_idx) :
+ 						 ICL_AUX_PW_TO_CH(pw_idx);
+ }
+ 
+ #if IS_ENABLED(CONFIG_DRM_I915_DEBUG_RUNTIME_PM)
+ 
+ static u64 async_put_domains_mask(struct i915_power_domains *power_domains);
+ 
+ static int power_well_async_ref_count(struct drm_i915_private *dev_priv,
+ 				      struct i915_power_well *power_well)
+ {
+ 	int refs = hweight64(power_well->desc->domains &
+ 			     async_put_domains_mask(&dev_priv->power_domains));
+ 
+ 	drm_WARN_ON(&dev_priv->drm, refs > power_well->count);
+ 
+ 	return refs;
+ }
+ 
+ static void icl_tc_port_assert_ref_held(struct drm_i915_private *dev_priv,
+ 					struct i915_power_well *power_well,
+ 					struct intel_digital_port *dig_port)
+ {
+ 	/* Bypass the check if all references are released asynchronously */
+ 	if (power_well_async_ref_count(dev_priv, power_well) ==
+ 	    power_well->count)
+ 		return;
+ 
+ 	if (drm_WARN_ON(&dev_priv->drm, !dig_port))
+ 		return;
+ 
+ 	drm_WARN_ON(&dev_priv->drm, !intel_tc_port_ref_held(dig_port));
+ }
+ 
+ #else
+ 
+ static void icl_tc_port_assert_ref_held(struct drm_i915_private *dev_priv,
+ 					struct i915_power_well *power_well,
+ 					struct intel_digital_port *dig_port)
+ {
+ }
+ 
+ #endif
+ 
+ #define TGL_AUX_PW_TO_TC_PORT(pw_idx)	((pw_idx) - TGL_PW_CTL_IDX_AUX_TC1)
+ 
++>>>>>>> 34a3f0b273a7 (drm/i915/display: Move out code to return the digital_port of the aux ch)
  static void
  icl_tc_phy_aux_power_well_enable(struct drm_i915_private *dev_priv,
  				 struct i915_power_well *power_well)
  {
++<<<<<<< HEAD
 +	int pw_idx = power_well->desc->hsw.idx;
 +	bool is_tbt = power_well->desc->hsw.is_tc_tbt;
 +	enum aux_ch aux_ch;
 +	u32 val;
 +
 +	aux_ch = is_tbt ? ICL_TBT_AUX_PW_TO_CH(pw_idx) :
 +			  ICL_AUX_PW_TO_CH(pw_idx);
 +	val = I915_READ(DP_AUX_CH_CTL(aux_ch));
++=======
+ 	enum aux_ch aux_ch = icl_tc_phy_aux_ch(dev_priv, power_well);
+ 	struct intel_digital_port *dig_port = aux_ch_to_digital_port(dev_priv, aux_ch);
+ 	u32 val;
+ 
+ 	icl_tc_port_assert_ref_held(dev_priv, power_well, dig_port);
+ 
+ 	val = intel_de_read(dev_priv, DP_AUX_CH_CTL(aux_ch));
++>>>>>>> 34a3f0b273a7 (drm/i915/display: Move out code to return the digital_port of the aux ch)
  	val &= ~DP_AUX_CH_CTL_TBT_IO;
 -	if (power_well->desc->hsw.is_tc_tbt)
 +	if (is_tbt)
  		val |= DP_AUX_CH_CTL_TBT_IO;
 -	intel_de_write(dev_priv, DP_AUX_CH_CTL(aux_ch), val);
 +	I915_WRITE(DP_AUX_CH_CTL(aux_ch), val);
  
  	hsw_power_well_enable(dev_priv, power_well);
++<<<<<<< HEAD
++=======
+ 
+ 	if (INTEL_GEN(dev_priv) >= 12 && !power_well->desc->hsw.is_tc_tbt) {
+ 		enum tc_port tc_port;
+ 
+ 		tc_port = TGL_AUX_PW_TO_TC_PORT(power_well->desc->hsw.idx);
+ 		intel_de_write(dev_priv, HIP_INDEX_REG(tc_port),
+ 			       HIP_INDEX_VAL(tc_port, 0x2));
+ 
+ 		if (intel_de_wait_for_set(dev_priv, DKL_CMN_UC_DW_27(tc_port),
+ 					  DKL_CMN_UC_DW27_UC_HEALTH, 1))
+ 			drm_warn(&dev_priv->drm,
+ 				 "Timeout waiting TC uC health\n");
+ 	}
+ }
+ 
+ static void
+ icl_tc_phy_aux_power_well_disable(struct drm_i915_private *dev_priv,
+ 				  struct i915_power_well *power_well)
+ {
+ 	enum aux_ch aux_ch = icl_tc_phy_aux_ch(dev_priv, power_well);
+ 	struct intel_digital_port *dig_port = aux_ch_to_digital_port(dev_priv, aux_ch);
+ 
+ 	icl_tc_port_assert_ref_held(dev_priv, power_well, dig_port);
+ 
+ 	hsw_power_well_disable(dev_priv, power_well);
++>>>>>>> 34a3f0b273a7 (drm/i915/display: Move out code to return the digital_port of the aux ch)
  }
  
  /*
* Unmerged path drivers/gpu/drm/i915/display/intel_display_power.c
