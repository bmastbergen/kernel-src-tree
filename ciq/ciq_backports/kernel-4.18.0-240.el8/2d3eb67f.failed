libbpf: Sanitize global functions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Alexei Starovoitov <ast@kernel.org>
commit 2d3eb67f64ec317bbfe340cfcc8325d40a6ff317
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/2d3eb67f.failed

In case the kernel doesn't support BTF_FUNC_GLOBAL sanitize BTF produced by the
compiler for global functions.

	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Signed-off-by: Daniel Borkmann <daniel@iogearbox.net>
	Acked-by: Song Liu <songliubraving@fb.com>
Link: https://lore.kernel.org/bpf/20200110064124.1760511-2-ast@kernel.org
(cherry picked from commit 2d3eb67f64ec317bbfe340cfcc8325d40a6ff317)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/lib/bpf/libbpf.c
diff --cc tools/lib/bpf/libbpf.c
index e39f1837896b,3afd780b0f06..000000000000
--- a/tools/lib/bpf/libbpf.c
+++ b/tools/lib/bpf/libbpf.c
@@@ -142,6 -171,24 +142,27 @@@ struct bpf_capabilities 
  	__u32 btf_func:1;
  	/* BTF_KIND_VAR and BTF_KIND_DATASEC support */
  	__u32 btf_datasec:1;
++<<<<<<< HEAD
++=======
+ 	/* BPF_F_MMAPABLE is supported for arrays */
+ 	__u32 array_mmap:1;
+ 	/* BTF_FUNC_GLOBAL is supported */
+ 	__u32 btf_func_global:1;
+ };
+ 
+ enum reloc_type {
+ 	RELO_LD64,
+ 	RELO_CALL,
+ 	RELO_DATA,
+ 	RELO_EXTERN,
+ };
+ 
+ struct reloc_desc {
+ 	enum reloc_type type;
+ 	int insn_idx;
+ 	int map_idx;
+ 	int sym_off;
++>>>>>>> 2d3eb67f64ec (libbpf: Sanitize global functions)
  };
  
  /*
@@@ -2143,9 -3211,35 +2168,35 @@@ static int bpf_object__probe_btf_func(s
  	return 0;
  }
  
+ static int bpf_object__probe_btf_func_global(struct bpf_object *obj)
+ {
+ 	static const char strs[] = "\0int\0x\0a";
+ 	/* static void x(int a) {} */
+ 	__u32 types[] = {
+ 		/* int */
+ 		BTF_TYPE_INT_ENC(1, BTF_INT_SIGNED, 0, 32, 4),  /* [1] */
+ 		/* FUNC_PROTO */                                /* [2] */
+ 		BTF_TYPE_ENC(0, BTF_INFO_ENC(BTF_KIND_FUNC_PROTO, 0, 1), 0),
+ 		BTF_PARAM_ENC(7, 1),
+ 		/* FUNC x BTF_FUNC_GLOBAL */                    /* [3] */
+ 		BTF_TYPE_ENC(5, BTF_INFO_ENC(BTF_KIND_FUNC, 0, BTF_FUNC_GLOBAL), 2),
+ 	};
+ 	int btf_fd;
+ 
+ 	btf_fd = libbpf__load_raw_btf((char *)types, sizeof(types),
+ 				      strs, sizeof(strs));
+ 	if (btf_fd >= 0) {
+ 		obj->caps.btf_func_global = 1;
+ 		close(btf_fd);
+ 		return 1;
+ 	}
+ 
+ 	return 0;
+ }
+ 
  static int bpf_object__probe_btf_datasec(struct bpf_object *obj)
  {
 -	static const char strs[] = "\0x\0.data";
 +	const char strs[] = "\0x\0.data";
  	/* static int a; */
  	__u32 types[] = {
  		/* int */
@@@ -2177,7 -3292,9 +2228,8 @@@ bpf_object__probe_caps(struct bpf_objec
  		bpf_object__probe_name,
  		bpf_object__probe_global_data,
  		bpf_object__probe_btf_func,
+ 		bpf_object__probe_btf_func_global,
  		bpf_object__probe_btf_datasec,
 -		bpf_object__probe_array_mmap,
  	};
  	int i, ret;
  
diff --git a/tools/include/uapi/linux/btf.h b/tools/include/uapi/linux/btf.h
index 63ae4a39e58b..1ec7c2b785f0 100644
--- a/tools/include/uapi/linux/btf.h
+++ b/tools/include/uapi/linux/btf.h
@@ -145,6 +145,12 @@ enum {
 	BTF_VAR_GLOBAL_ALLOCATED,
 };
 
+enum btf_func_linkage {
+	BTF_FUNC_STATIC = 0,
+	BTF_FUNC_GLOBAL = 1,
+	BTF_FUNC_EXTERN = 2,
+};
+
 /* BTF_KIND_VAR is followed by a single "struct btf_var" to describe
  * additional information related to the variable such as its linkage.
  */
* Unmerged path tools/lib/bpf/libbpf.c
