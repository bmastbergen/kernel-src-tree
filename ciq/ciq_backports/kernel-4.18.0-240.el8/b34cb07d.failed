sched/fair: Fix enqueue_task_fair() warning some more

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Phil Auld <pauld@redhat.com>
commit b34cb07dde7c2346dec73d053ce926aeaa087303
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b34cb07d.failed

sched/fair: Fix enqueue_task_fair warning some more

The recent patch, fe61468b2cb (sched/fair: Fix enqueue_task_fair warning)
did not fully resolve the issues with the rq->tmp_alone_branch !=
&rq->leaf_cfs_rq_list warning in enqueue_task_fair. There is a case where
the first for_each_sched_entity loop exits due to on_rq, having incompletely
updated the list.  In this case the second for_each_sched_entity loop can
further modify se. The later code to fix up the list management fails to do
what is needed because se does not point to the sched_entity which broke out
of the first loop. The list is not fixed up because the throttled parent was
already added back to the list by a task enqueue in a parallel child hierarchy.

Address this by calling list_add_leaf_cfs_rq if there are throttled parents
while doing the second for_each_sched_entity loop.

Fixes: fe61468b2cb ("sched/fair: Fix enqueue_task_fair warning")
	Suggested-by: Vincent Guittot <vincent.guittot@linaro.org>
	Signed-off-by: Phil Auld <pauld@redhat.com>
	Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Reviewed-by: Dietmar Eggemann <dietmar.eggemann@arm.com>
	Reviewed-by: Vincent Guittot <vincent.guittot@linaro.org>
Link: https://lkml.kernel.org/r/20200512135222.GC2201@lorien.usersys.redhat.com
(cherry picked from commit b34cb07dde7c2346dec73d053ce926aeaa087303)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/sched/fair.c
diff --cc kernel/sched/fair.c
index 487d0e3ead80,c6d57c334d51..000000000000
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@@ -5230,15 -5468,27 +5230,32 @@@ enqueue_task_fair(struct rq *rq, struc
  
  	for_each_sched_entity(se) {
  		cfs_rq = cfs_rq_of(se);
 +		cfs_rq->h_nr_running++;
 +
 +		if (cfs_rq_throttled(cfs_rq))
 +			break;
  
  		update_load_avg(cfs_rq, se, UPDATE_TG);
 -		se_update_runnable(se);
  		update_cfs_group(se);
++<<<<<<< HEAD
++=======
+ 
+ 		cfs_rq->h_nr_running++;
+ 		cfs_rq->idle_h_nr_running += idle_h_nr_running;
+ 
+ 		/* end evaluation on encountering a throttled cfs_rq */
+ 		if (cfs_rq_throttled(cfs_rq))
+ 			goto enqueue_throttle;
+ 
+                /*
+                 * One parent has been throttled and cfs_rq removed from the
+                 * list. Add it back to not break the leaf list.
+                 */
+                if (throttled_hierarchy(cfs_rq))
+                        list_add_leaf_cfs_rq(cfs_rq);
++>>>>>>> b34cb07dde7c (sched/fair: Fix enqueue_task_fair() warning some more)
  	}
  
 -enqueue_throttle:
  	if (!se) {
  		add_nr_running(rq, 1);
  		/*
* Unmerged path kernel/sched/fair.c
