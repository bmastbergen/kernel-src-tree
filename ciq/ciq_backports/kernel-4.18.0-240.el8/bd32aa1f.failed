veth: rely on veth_rq in veth_xdp_flush_bq signature

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Lorenzo Bianconi <lorenzo@kernel.org>
commit bd32aa1f5d2c0edab09c2d80af30cb829337ddef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/bd32aa1f.failed

Substitute net_device point with veth_rq one in veth_xdp_flush_bq,
veth_xdp_flush and veth_xdp_tx signature. This is a preliminary patch
to account xdp_xmit counter on 'receiving' veth_rq

	Acked-by: Toshiaki Makita <toshiaki.makita1@gmail.com>
	Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bd32aa1f5d2c0edab09c2d80af30cb829337ddef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/veth.c
diff --cc drivers/net/veth.c
index 013947869d96,2041152da716..000000000000
--- a/drivers/net/veth.c
+++ b/drivers/net/veth.c
@@@ -448,11 -462,17 +448,25 @@@ drop
  	return ret;
  }
  
++<<<<<<< HEAD
 +static void veth_xdp_flush_bq(struct net_device *dev, struct veth_xdp_tx_bq *bq)
 +{
 +	int sent, i, err = 0;
 +
 +	sent = veth_xdp_xmit(dev, bq->count, bq->q, 0);
++=======
+ static int veth_ndo_xdp_xmit(struct net_device *dev, int n,
+ 			     struct xdp_frame **frames, u32 flags)
+ {
+ 	return veth_xdp_xmit(dev, n, frames, flags, true);
+ }
+ 
+ static void veth_xdp_flush_bq(struct veth_rq *rq, struct veth_xdp_tx_bq *bq)
+ {
+ 	int sent, i, err = 0;
+ 
+ 	sent = veth_xdp_xmit(rq->dev, bq->count, bq->q, 0, false);
++>>>>>>> bd32aa1f5d2c (veth: rely on veth_rq in veth_xdp_flush_bq signature)
  	if (sent < 0) {
  		err = sent;
  		sent = 0;
@@@ -539,12 -559,13 +553,12 @@@ static struct sk_buff *veth_xdp_rcv_one
  			orig_frame = *frame;
  			xdp.data_hard_start = head;
  			xdp.rxq->mem = frame->mem;
- 			if (unlikely(veth_xdp_tx(rq->dev, &xdp, bq) < 0)) {
+ 			if (unlikely(veth_xdp_tx(rq, &xdp, bq) < 0)) {
  				trace_xdp_exception(rq->dev, xdp_prog, act);
  				frame = &orig_frame;
 -				stats->rx_drops++;
  				goto err_xdp;
  			}
 -			stats->xdp_tx++;
 +			*xdp_xmit |= VETH_XDP_TX;
  			rcu_read_unlock();
  			goto xdp_xmit;
  		case XDP_REDIRECT:
@@@ -667,11 -692,12 +681,11 @@@ static struct sk_buff *veth_xdp_rcv_skb
  		get_page(virt_to_page(xdp.data));
  		consume_skb(skb);
  		xdp.rxq->mem = rq->xdp_mem;
- 		if (unlikely(veth_xdp_tx(rq->dev, &xdp, bq) < 0)) {
+ 		if (unlikely(veth_xdp_tx(rq, &xdp, bq) < 0)) {
  			trace_xdp_exception(rq->dev, xdp_prog, act);
 -			stats->rx_drops++;
  			goto err_xdp;
  		}
 -		stats->xdp_tx++;
 +		*xdp_xmit |= VETH_XDP_TX;
  		rcu_read_unlock();
  		goto xdp_xmit;
  	case XDP_REDIRECT:
@@@ -786,10 -816,10 +800,17 @@@ static int veth_poll(struct napi_struc
  		}
  	}
  
++<<<<<<< HEAD
 +	if (xdp_xmit & VETH_XDP_TX)
 +		veth_xdp_flush(rq->dev, &bq);
 +	if (xdp_xmit & VETH_XDP_REDIR)
 +		xdp_do_flush_map();
++=======
+ 	if (stats.xdp_tx > 0)
+ 		veth_xdp_flush(rq, &bq);
+ 	if (stats.xdp_redirect > 0)
+ 		xdp_do_flush();
++>>>>>>> bd32aa1f5d2c (veth: rely on veth_rq in veth_xdp_flush_bq signature)
  	xdp_clear_return_frame_no_direct();
  
  	return done;
* Unmerged path drivers/net/veth.c
