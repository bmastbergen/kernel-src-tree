KVM: selftests: Don't probe KVM_CAP_HYPERV_ENLIGHTENED_VMCS when nested VMX is unsupported

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Vitaly Kuznetsov <vkuznets@redhat.com>
commit 7e464770a434f7e29bad4b2da7894d32775d6d6f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/7e464770.failed

KVM_CAP_HYPERV_ENLIGHTENED_VMCS will be reported as supported even when
nested VMX is not, fix evmcs_test/hyperv_cpuid tests to check for both.

	Signed-off-by: Vitaly Kuznetsov <vkuznets@redhat.com>
Message-Id: <20200610135847.754289-3-vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 7e464770a434f7e29bad4b2da7894d32775d6d6f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/kvm/x86_64/evmcs_test.c
#	tools/testing/selftests/kvm/x86_64/hyperv_cpuid.c
diff --cc tools/testing/selftests/kvm/x86_64/evmcs_test.c
index 5ec1e405a48c,757928199f19..000000000000
--- a/tools/testing/selftests/kvm/x86_64/evmcs_test.c
+++ b/tools/testing/selftests/kvm/x86_64/evmcs_test.c
@@@ -94,9 -94,10 +94,14 @@@ int main(int argc, char *argv[]
  
  	vcpu_set_cpuid(vm, VCPU_ID, kvm_get_supported_cpuid());
  
- 	if (!kvm_check_cap(KVM_CAP_NESTED_STATE) ||
+ 	if (!nested_vmx_supported() ||
+ 	    !kvm_check_cap(KVM_CAP_NESTED_STATE) ||
  	    !kvm_check_cap(KVM_CAP_HYPERV_ENLIGHTENED_VMCS)) {
++<<<<<<< HEAD
 +		printf("capabilities not available, skipping test\n");
++=======
+ 		print_skip("Enlightened VMCS is unsupported");
++>>>>>>> 7e464770a434 (KVM: selftests: Don't probe KVM_CAP_HYPERV_ENLIGHTENED_VMCS when nested VMX is unsupported)
  		exit(KSFT_SKIP);
  	}
  
diff --cc tools/testing/selftests/kvm/x86_64/hyperv_cpuid.c
index 443a2b54645b,745b708c2d3b..000000000000
--- a/tools/testing/selftests/kvm/x86_64/hyperv_cpuid.c
+++ b/tools/testing/selftests/kvm/x86_64/hyperv_cpuid.c
@@@ -146,37 -159,32 +146,57 @@@ int main(int argc, char *argv[]
  		exit(KSFT_SKIP);
  	}
  
 -	for (stage = 0; stage < 3; stage++) {
 -		evmcs_enabled = false;
 +	/* Create VM */
 +	vm = vm_create_default(VCPU_ID, 0, guest_code);
  
++<<<<<<< HEAD
 +	test_hv_cpuid_e2big(vm);
++=======
+ 		vm = vm_create_default(VCPU_ID, 0, guest_code);
+ 		switch (stage) {
+ 		case 0:
+ 			test_hv_cpuid_e2big(vm);
+ 			continue;
+ 		case 1:
+ 			break;
+ 		case 2:
+ 			if (!nested_vmx_supported() ||
+ 			    !kvm_check_cap(KVM_CAP_HYPERV_ENLIGHTENED_VMCS)) {
+ 				print_skip("Enlightened VMCS is unsupported");
+ 				continue;
+ 			}
+ 			vcpu_enable_evmcs(vm, VCPU_ID);
+ 			evmcs_enabled = true;
+ 			break;
+ 		}
++>>>>>>> 7e464770a434 (KVM: selftests: Don't probe KVM_CAP_HYPERV_ENLIGHTENED_VMCS when nested VMX is unsupported)
 +
 +	hv_cpuid_entries = kvm_get_supported_hv_cpuid(vm);
 +	if (!hv_cpuid_entries)
 +		return 1;
 +
 +	test_hv_cpuid(hv_cpuid_entries, 0);
  
 -		hv_cpuid_entries = kvm_get_supported_hv_cpuid(vm);
 -		test_hv_cpuid(hv_cpuid_entries, evmcs_enabled);
 -		free(hv_cpuid_entries);
 -		kvm_vm_free(vm);
 +	free(hv_cpuid_entries);
 +
 +	if (!kvm_check_cap(KVM_CAP_HYPERV_ENLIGHTENED_VMCS)) {
 +		fprintf(stderr,
 +			"Enlightened VMCS is unsupported, skip related test\n");
 +		goto vm_free;
  	}
  
 +	vcpu_enable_evmcs(vm, VCPU_ID);
 +
 +	hv_cpuid_entries = kvm_get_supported_hv_cpuid(vm);
 +	if (!hv_cpuid_entries)
 +		return 1;
 +
 +	test_hv_cpuid(hv_cpuid_entries, 1);
 +
 +	free(hv_cpuid_entries);
 +
 +vm_free:
 +	kvm_vm_free(vm);
 +
  	return 0;
  }
* Unmerged path tools/testing/selftests/kvm/x86_64/evmcs_test.c
* Unmerged path tools/testing/selftests/kvm/x86_64/hyperv_cpuid.c
