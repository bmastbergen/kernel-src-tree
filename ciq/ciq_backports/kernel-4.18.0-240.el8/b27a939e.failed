ceph: canonicalize server path in place

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Ilya Dryomov <idryomov@gmail.com>
commit b27a939e8376a3f1ed09b9c33ef44d20f18ec3d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/b27a939e.failed

syzbot reported that 4fbc0c711b24 ("ceph: remove the extra slashes in
the server path") had caused a regression where an allocation could be
done under a spinlock -- compare_mount_options() is called by sget_fc()
with sb_lock held.

We don't really need the supplied server path, so canonicalize it
in place and compare it directly.  To make this work, the leading
slash is kept around and the logic in ceph_real_mount() to skip it
is restored.  CEPH_MSG_CLIENT_SESSION now reports the same (i.e.
canonicalized) path, with the leading slash of course.

Fixes: 4fbc0c711b24 ("ceph: remove the extra slashes in the server path")
	Reported-by: syzbot+98704a51af8e3d9425a9@syzkaller.appspotmail.com
	Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
	Reviewed-by: Jeff Layton <jlayton@kernel.org>
(cherry picked from commit b27a939e8376a3f1ed09b9c33ef44d20f18ec3d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/super.c
diff --cc fs/ceph/super.c
index f47c913c51eb,64ea34ac330b..000000000000
--- a/fs/ceph/super.c
+++ b/fs/ceph/super.c
@@@ -141,98 -141,158 +141,227 @@@ enum 
  	/* int args above */
  	Opt_snapdirname,
  	Opt_mds_namespace,
 +	Opt_fscache_uniq,
  	Opt_recover_session,
 -	Opt_source,
 +	Opt_last_string,
  	/* string args above */
  	Opt_dirstat,
 +	Opt_nodirstat,
  	Opt_rbytes,
 +	Opt_norbytes,
  	Opt_asyncreaddir,
 +	Opt_noasyncreaddir,
  	Opt_dcache,
 +	Opt_nodcache,
  	Opt_ino32,
 +	Opt_noino32,
  	Opt_fscache,
 +	Opt_nofscache,
  	Opt_poolperm,
 +	Opt_nopoolperm,
  	Opt_require_active_mds,
 +	Opt_norequire_active_mds,
 +#ifdef CONFIG_CEPH_FS_POSIX_ACL
  	Opt_acl,
 +#endif
 +	Opt_noacl,
  	Opt_quotadf,
 -	Opt_copyfrom,
 +	Opt_noquotadf,
  };
  
 -enum ceph_recover_session_mode {
 -	ceph_recover_session_no,
 -	ceph_recover_session_clean
 +static match_table_t fsopt_tokens = {
 +	{Opt_wsize, "wsize=%d"},
 +	{Opt_rsize, "rsize=%d"},
 +	{Opt_rasize, "rasize=%d"},
 +	{Opt_caps_wanted_delay_min, "caps_wanted_delay_min=%d"},
 +	{Opt_caps_wanted_delay_max, "caps_wanted_delay_max=%d"},
 +	{Opt_caps_max, "caps_max=%d"},
 +	{Opt_readdir_max_entries, "readdir_max_entries=%d"},
 +	{Opt_readdir_max_bytes, "readdir_max_bytes=%d"},
 +	{Opt_congestion_kb, "write_congestion_kb=%d"},
 +	/* int args above */
 +	{Opt_snapdirname, "snapdirname=%s"},
 +	{Opt_mds_namespace, "mds_namespace=%s"},
 +	{Opt_recover_session, "recover_session=%s"},
 +	{Opt_fscache_uniq, "fsc=%s"},
 +	/* string args above */
 +	{Opt_dirstat, "dirstat"},
 +	{Opt_nodirstat, "nodirstat"},
 +	{Opt_rbytes, "rbytes"},
 +	{Opt_norbytes, "norbytes"},
 +	{Opt_asyncreaddir, "asyncreaddir"},
 +	{Opt_noasyncreaddir, "noasyncreaddir"},
 +	{Opt_dcache, "dcache"},
 +	{Opt_nodcache, "nodcache"},
 +	{Opt_ino32, "ino32"},
 +	{Opt_noino32, "noino32"},
 +	{Opt_fscache, "fsc"},
 +	{Opt_nofscache, "nofsc"},
 +	{Opt_poolperm, "poolperm"},
 +	{Opt_nopoolperm, "nopoolperm"},
 +	{Opt_require_active_mds, "require_active_mds"},
 +	{Opt_norequire_active_mds, "norequire_active_mds"},
 +#ifdef CONFIG_CEPH_FS_POSIX_ACL
 +	{Opt_acl, "acl"},
 +#endif
 +	{Opt_noacl, "noacl"},
 +	{Opt_quotadf, "quotadf"},
 +	{Opt_noquotadf, "noquotadf"},
 +	{-1, NULL}
  };
  
++<<<<<<< HEAD
 +static int parse_fsopt_token(char *c, void *private)
++=======
+ static const struct constant_table ceph_param_recover[] = {
+ 	{ "no",		ceph_recover_session_no },
+ 	{ "clean",	ceph_recover_session_clean },
+ 	{}
+ };
+ 
+ static const struct fs_parameter_spec ceph_mount_parameters[] = {
+ 	fsparam_flag_no ("acl",				Opt_acl),
+ 	fsparam_flag_no ("asyncreaddir",		Opt_asyncreaddir),
+ 	fsparam_s32	("caps_max",			Opt_caps_max),
+ 	fsparam_u32	("caps_wanted_delay_max",	Opt_caps_wanted_delay_max),
+ 	fsparam_u32	("caps_wanted_delay_min",	Opt_caps_wanted_delay_min),
+ 	fsparam_u32	("write_congestion_kb",		Opt_congestion_kb),
+ 	fsparam_flag_no ("copyfrom",			Opt_copyfrom),
+ 	fsparam_flag_no ("dcache",			Opt_dcache),
+ 	fsparam_flag_no ("dirstat",			Opt_dirstat),
+ 	fsparam_flag_no	("fsc",				Opt_fscache), // fsc|nofsc
+ 	fsparam_string	("fsc",				Opt_fscache), // fsc=...
+ 	fsparam_flag_no ("ino32",			Opt_ino32),
+ 	fsparam_string	("mds_namespace",		Opt_mds_namespace),
+ 	fsparam_flag_no ("poolperm",			Opt_poolperm),
+ 	fsparam_flag_no ("quotadf",			Opt_quotadf),
+ 	fsparam_u32	("rasize",			Opt_rasize),
+ 	fsparam_flag_no ("rbytes",			Opt_rbytes),
+ 	fsparam_u32	("readdir_max_bytes",		Opt_readdir_max_bytes),
+ 	fsparam_u32	("readdir_max_entries",		Opt_readdir_max_entries),
+ 	fsparam_enum	("recover_session",		Opt_recover_session, ceph_param_recover),
+ 	fsparam_flag_no ("require_active_mds",		Opt_require_active_mds),
+ 	fsparam_u32	("rsize",			Opt_rsize),
+ 	fsparam_string	("snapdirname",			Opt_snapdirname),
+ 	fsparam_string	("source",			Opt_source),
+ 	fsparam_u32	("wsize",			Opt_wsize),
+ 	{}
+ };
+ 
+ struct ceph_parse_opts_ctx {
+ 	struct ceph_options		*copts;
+ 	struct ceph_mount_options	*opts;
+ };
+ 
+ /*
+  * Remove adjacent slashes and then the trailing slash, unless it is
+  * the only remaining character.
+  *
+  * E.g. "//dir1////dir2///" --> "/dir1/dir2", "///" --> "/".
+  */
+ static void canonicalize_path(char *path)
+ {
+ 	int i, j = 0;
+ 
+ 	for (i = 0; path[i] != '\0'; i++) {
+ 		if (path[i] != '/' || j < 1 || path[j - 1] != '/')
+ 			path[j++] = path[i];
+ 	}
+ 
+ 	if (j > 1 && path[j - 1] == '/')
+ 		j--;
+ 	path[j] = '\0';
+ }
+ 
+ /*
+  * Parse the source parameter.  Distinguish the server list from the path.
+  *
+  * The source will look like:
+  *     <server_spec>[,<server_spec>...]:[<path>]
+  * where
+  *     <server_spec> is <ip>[:<port>]
+  *     <path> is optional, but if present must begin with '/'
+  */
+ static int ceph_parse_source(struct fs_parameter *param, struct fs_context *fc)
++>>>>>>> b27a939e8376 (ceph: canonicalize server path in place)
  {
 -	struct ceph_parse_opts_ctx *pctx = fc->fs_private;
 -	struct ceph_mount_options *fsopt = pctx->opts;
 -	char *dev_name = param->string, *dev_name_end;
 -	int ret;
 +	struct ceph_mount_options *fsopt = private;
 +	substring_t argstr[MAX_OPT_ARGS];
 +	int token, intval, ret;
  
++<<<<<<< HEAD
 +	token = match_token((char *)c, fsopt_tokens, argstr);
++=======
+ 	dout("%s '%s'\n", __func__, dev_name);
+ 	if (!dev_name || !*dev_name)
+ 		return invalfc(fc, "Empty source");
+ 
+ 	dev_name_end = strchr(dev_name, '/');
+ 	if (dev_name_end) {
+ 		/*
+ 		 * The server_path will include the whole chars from userland
+ 		 * including the leading '/'.
+ 		 */
+ 		kfree(fsopt->server_path);
+ 		fsopt->server_path = kstrdup(dev_name_end, GFP_KERNEL);
+ 		if (!fsopt->server_path)
+ 			return -ENOMEM;
+ 
+ 		canonicalize_path(fsopt->server_path);
+ 	} else {
+ 		dev_name_end = dev_name + strlen(dev_name);
+ 	}
+ 
+ 	dev_name_end--;		/* back up to ':' separator */
+ 	if (dev_name_end < dev_name || *dev_name_end != ':')
+ 		return invalfc(fc, "No path or : separator in source");
+ 
+ 	dout("device name '%.*s'\n", (int)(dev_name_end - dev_name), dev_name);
+ 	if (fsopt->server_path)
+ 		dout("server path '%s'\n", fsopt->server_path);
+ 
+ 	ret = ceph_parse_mon_ips(param->string, dev_name_end - dev_name,
+ 				 pctx->copts, fc->log.log);
+ 	if (ret)
+ 		return ret;
+ 
+ 	fc->source = param->string;
+ 	param->string = NULL;
+ 	return 0;
+ }
+ 
+ static int ceph_parse_mount_param(struct fs_context *fc,
+ 				  struct fs_parameter *param)
+ {
+ 	struct ceph_parse_opts_ctx *pctx = fc->fs_private;
+ 	struct ceph_mount_options *fsopt = pctx->opts;
+ 	struct fs_parse_result result;
+ 	unsigned int mode;
+ 	int token, ret;
+ 
+ 	ret = ceph_parse_param(param, pctx->copts, fc->log.log);
+ 	if (ret != -ENOPARAM)
+ 		return ret;
+ 
+ 	token = fs_parse(fc, ceph_mount_parameters, param, &result);
+ 	dout("%s fs_parse '%s' token %d\n", __func__, param->key, token);
++>>>>>>> b27a939e8376 (ceph: canonicalize server path in place)
  	if (token < 0)
 -		return token;
 +		return -EINVAL;
 +
 +	if (token < Opt_last_int) {
 +		ret = match_int(&argstr[0], &intval);
 +		if (ret < 0) {
 +			pr_err("bad option arg (not int) at '%s'\n", c);
 +			return ret;
 +		}
 +		dout("got int token %d val %d\n", token, intval);
 +	} else if (token > Opt_last_int && token < Opt_last_string) {
 +		dout("got string token %d val %s\n", token,
 +		     argstr[0].from);
 +	} else {
 +		dout("got token %d\n", token);
 +	}
  
  	switch (token) {
  	case Opt_snapdirname:
@@@ -438,6 -497,7 +568,10 @@@ static int compare_mount_options(struc
  	ret = strcmp_null(fsopt1->mds_namespace, fsopt2->mds_namespace);
  	if (ret)
  		return ret;
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> b27a939e8376 (ceph: canonicalize server path in place)
  	ret = strcmp_null(fsopt1->server_path, fsopt2->server_path);
  	if (ret)
  		return ret;
@@@ -931,7 -901,9 +1065,13 @@@ static struct dentry *ceph_real_mount(s
  	mutex_lock(&fsc->client->mount_mutex);
  
  	if (!fsc->sb->s_root) {
++<<<<<<< HEAD
 +		const char *path;
++=======
+ 		const char *path = fsc->mount_options->server_path ?
+ 				     fsc->mount_options->server_path + 1 : "";
+ 
++>>>>>>> b27a939e8376 (ceph: canonicalize server path in place)
  		err = __ceph_open_session(fsc->client, started);
  		if (err < 0)
  			goto out;
@@@ -943,13 -915,7 +1083,17 @@@
  				goto out;
  		}
  
++<<<<<<< HEAD
 +		if (!fsc->mount_options->server_path) {
 +			path = "";
 +			dout("mount opening path \\t\n");
 +		} else {
 +			path = fsc->mount_options->server_path + 1;
 +			dout("mount opening path %s\n", path);
 +		}
++=======
+ 		dout("mount opening path '%s'\n", path);
++>>>>>>> b27a939e8376 (ceph: canonicalize server path in place)
  
  		ceph_fs_debugfs_init(fsc);
  
* Unmerged path fs/ceph/super.c
diff --git a/fs/ceph/super.h b/fs/ceph/super.h
index 1ce9a01d17fe..c2f2f94d47eb 100644
--- a/fs/ceph/super.h
+++ b/fs/ceph/super.h
@@ -89,7 +89,7 @@ struct ceph_mount_options {
 
 	char *snapdir_name;   /* default ".snap" */
 	char *mds_namespace;  /* default NULL */
-	char *server_path;    /* default  "/" */
+	char *server_path;    /* default NULL (means "/") */
 	char *fscache_uniq;   /* default NULL */
 };
 
