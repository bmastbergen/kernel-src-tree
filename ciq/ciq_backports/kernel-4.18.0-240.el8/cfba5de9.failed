drivers: Introduce device lookup variants by of_node

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Suzuki K Poulose <suzuki.poulose@arm.com>
commit cfba5de9b99f8bbb8b4ea11b3049784e78b8759b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/cfba5de9.failed

Introduce wrappers for {bus/driver/class}_find_device() to
locate devices by its of_node.

	Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Cc: Maxime Ripard <maxime.ripard@bootlin.com>
	Cc: dri-devel@lists.freedesktop.org
	Cc: David Airlie <airlied@linux.ie>
	Cc: Daniel Vetter <daniel@ffwll.ch>
	Cc: devicetree@vger.kernel.org
	Cc: Florian Fainelli <f.fainelli@gmail.com>
	Cc: Frank Rowand <frowand.list@gmail.com>
	Cc: Heiko Stuebner <heiko@sntech.de>
	Cc: Liam Girdwood <lgirdwood@gmail.com>
	Cc: linux-i2c@vger.kernel.org
	Cc: linux-rockchip@lists.infradead.org
	Cc: linux-spi@vger.kernel.org
	Cc: Mathieu Poirier <mathieu.poirier@linaro.org>
	Cc: Rob Herring <robh+dt@kernel.org>
	Cc: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
	Cc: Takashi Iwai <tiwai@suse.com>
	Cc: Alan Tull <atull@kernel.org>
	Cc: linux-fpga@vger.kernel.org
	Cc: Peter Rosin <peda@axentia.se>
	Cc: Florian Fainelli <f.fainelli@gmail.com>
	Cc: Heiner Kallweit <hkallweit1@gmail.com>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Andrew Lunn <andrew@lunn.ch>
	Cc: Liam Girdwood <lgirdwood@gmail.com>
	Cc: "Rafael J. Wysocki" <rafael@kernel.org>
	Cc: Thor Thayer <thor.thayer@linux.intel.com>
	Cc: Jiri Slaby <jslaby@suse.com>
	Cc: Andrew Lunn <andrew@lunn.ch>
	Cc: Peter Rosin <peda@axentia.se>
	Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
	Acked-by: Lee Jones <lee.jones@linaro.org>
	Acked-by: Wolfram Sang <wsa@the-dreams.de> # I2C part
	Acked-by: Moritz Fischer <mdf@kernel.org> # For FPGA part
	Acked-by: Mark Brown <broonie@kernel.org>
Link: https://lore.kernel.org/r/20190723221838.12024-3-suzuki.poulose@arm.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit cfba5de9b99f8bbb8b4ea11b3049784e78b8759b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/amba/tegra-ahb.c
#	drivers/i2c/i2c-core-of.c
#	drivers/mfd/altera-sysmgr.c
#	include/linux/device.h
diff --cc drivers/amba/tegra-ahb.c
index b0b688c481e8,57d3b2e2d007..000000000000
--- a/drivers/amba/tegra-ahb.c
+++ b/drivers/amba/tegra-ahb.c
@@@ -143,14 -134,6 +143,17 @@@ static inline void gizmo_writel(struct 
  }
  
  #ifdef CONFIG_TEGRA_IOMMU_SMMU
++<<<<<<< HEAD
 +static int tegra_ahb_match_by_smmu(struct device *dev, void *data)
 +{
 +	struct tegra_ahb *ahb = dev_get_drvdata(dev);
 +	struct device_node *dn = data;
 +
 +	return (ahb->dev->of_node == dn) ? 1 : 0;
 +}
 +
++=======
++>>>>>>> cfba5de9b99f (drivers: Introduce device lookup variants by of_node)
  int tegra_ahb_enable_smmu(struct device_node *dn)
  {
  	struct device *dev;
diff --cc drivers/i2c/i2c-core-of.c
index 1b17d7ce6f74,6f632d543fcc..000000000000
--- a/drivers/i2c/i2c-core-of.c
+++ b/drivers/i2c/i2c-core-of.c
@@@ -117,12 -113,7 +117,16 @@@ void of_i2c_register_devices(struct i2c
  	of_node_put(bus);
  }
  
++<<<<<<< HEAD
 +static int of_dev_node_match(struct device *dev, const void *data)
 +{
 +	return dev->of_node == data;
 +}
 +
 +static int of_dev_or_parent_node_match(struct device *dev, void *data)
++=======
+ static int of_dev_or_parent_node_match(struct device *dev, const void *data)
++>>>>>>> cfba5de9b99f (drivers: Introduce device lookup variants by of_node)
  {
  	if (dev->of_node == data)
  		return 1;
diff --cc include/linux/device.h
index f1c93f0bca5a,29d8d7ad41e6..000000000000
--- a/include/linux/device.h
+++ b/include/linux/device.h
@@@ -174,9 -172,32 +174,38 @@@ int bus_for_each_dev(struct bus_type *b
  struct device *bus_find_device(struct bus_type *bus, struct device *start,
  			       const void *data,
  			       int (*match)(struct device *dev, const void *data));
++<<<<<<< HEAD
 +struct device *bus_find_device_by_name(struct bus_type *bus,
 +				       struct device *start,
 +				       const char *name);
++=======
+ /**
+  * bus_find_device_by_name - device iterator for locating a particular device
+  * of a specific name.
+  * @bus: bus type
+  * @start: Device to begin with
+  * @name: name of the device to match
+  */
+ static inline struct device *bus_find_device_by_name(struct bus_type *bus,
+ 						     struct device *start,
+ 						     const char *name)
+ {
+ 	return bus_find_device(bus, start, name, device_match_name);
+ }
+ 
+ /**
+  * bus_find_device_by_of_node : device iterator for locating a particular device
+  * matching the of_node.
+  * @bus: bus type
+  * @np: of_node of the device to match.
+  */
+ static inline struct device *
+ bus_find_device_by_of_node(struct bus_type *bus, const struct device_node *np)
+ {
+ 	return bus_find_device(bus, NULL, np, device_match_of_node);
+ }
+ 
++>>>>>>> cfba5de9b99f (drivers: Introduce device lookup variants by of_node)
  struct device *subsys_find_device_by_id(struct bus_type *bus, unsigned int id,
  					struct device *hint);
  int bus_for_each_drv(struct bus_type *bus, struct device_driver *start,
@@@ -353,9 -363,35 +382,38 @@@ extern int __must_check driver_for_each
  					       int (*fn)(struct device *dev,
  							 void *));
  struct device *driver_find_device(struct device_driver *drv,
 -				  struct device *start, const void *data,
 -				  int (*match)(struct device *dev, const void *data));
 +				  struct device *start, void *data,
 +				  int (*match)(struct device *dev, void *data));
  
++<<<<<<< HEAD
++=======
+ /**
+  * driver_find_device_by_name - device iterator for locating a particular device
+  * of a specific name.
+  * @driver: the driver we're iterating
+  * @name: name of the device to match
+  */
+ static inline struct device *driver_find_device_by_name(struct device_driver *drv,
+ 							const char *name)
+ {
+ 	return driver_find_device(drv, NULL, name, device_match_name);
+ }
+ 
+ /**
+  * driver_find_device_by_of_node- device iterator for locating a particular device
+  * by of_node pointer.
+  * @driver: the driver we're iterating
+  * @np: of_node pointer to match.
+  */
+ static inline struct device *
+ driver_find_device_by_of_node(struct device_driver *drv,
+ 			      const struct device_node *np)
+ {
+ 	return driver_find_device(drv, NULL, np, device_match_of_node);
+ }
+ 
+ void driver_deferred_probe_add(struct device *dev);
++>>>>>>> cfba5de9b99f (drivers: Introduce device lookup variants by of_node)
  int driver_deferred_probe_check_state(struct device *dev);
  int driver_deferred_probe_check_state_continue(struct device *dev);
  
@@@ -491,6 -520,30 +549,33 @@@ extern struct device *class_find_device
  					struct device *start, const void *data,
  					int (*match)(struct device *, const void *));
  
++<<<<<<< HEAD
++=======
+ /**
+  * class_find_device_by_name - device iterator for locating a particular device
+  * of a specific name.
+  * @class: class type
+  * @name: name of the device to match
+  */
+ static inline struct device *class_find_device_by_name(struct class *class,
+ 						       const char *name)
+ {
+ 	return class_find_device(class, NULL, name, device_match_name);
+ }
+ 
+ /**
+  * class_find_device_by_of_node : device iterator for locating a particular device
+  * matching the of_node.
+  * @class: class type
+  * @np: of_node of the device to match.
+  */
+ static inline struct device *
+ class_find_device_by_of_node(struct class *class, const struct device_node *np)
+ {
+ 	return class_find_device(class, NULL, np, device_match_of_node);
+ }
+ 
++>>>>>>> cfba5de9b99f (drivers: Introduce device lookup variants by of_node)
  struct class_attribute {
  	struct attribute attr;
  	ssize_t (*show)(struct class *class, struct class_attribute *attr,
* Unmerged path drivers/mfd/altera-sysmgr.c
* Unmerged path drivers/amba/tegra-ahb.c
diff --git a/drivers/fpga/fpga-bridge.c b/drivers/fpga/fpga-bridge.c
index 80bd8f1b2aa6..4bab9028940a 100644
--- a/drivers/fpga/fpga-bridge.c
+++ b/drivers/fpga/fpga-bridge.c
@@ -19,11 +19,6 @@ static struct class *fpga_bridge_class;
 /* Lock for adding/removing bridges to linked lists*/
 static spinlock_t bridge_list_lock;
 
-static int fpga_bridge_of_node_match(struct device *dev, const void *data)
-{
-	return dev->of_node == data;
-}
-
 /**
  * fpga_bridge_enable - Enable transactions on the bridge
  *
@@ -104,8 +99,7 @@ struct fpga_bridge *of_fpga_bridge_get(struct device_node *np,
 {
 	struct device *dev;
 
-	dev = class_find_device(fpga_bridge_class, NULL, np,
-				fpga_bridge_of_node_match);
+	dev = class_find_device_by_of_node(fpga_bridge_class, np);
 	if (!dev)
 		return ERR_PTR(-ENODEV);
 
diff --git a/drivers/fpga/fpga-mgr.c b/drivers/fpga/fpga-mgr.c
index c3866816456a..e05104f5e40c 100644
--- a/drivers/fpga/fpga-mgr.c
+++ b/drivers/fpga/fpga-mgr.c
@@ -482,11 +482,6 @@ struct fpga_manager *fpga_mgr_get(struct device *dev)
 }
 EXPORT_SYMBOL_GPL(fpga_mgr_get);
 
-static int fpga_mgr_of_node_match(struct device *dev, const void *data)
-{
-	return dev->of_node == data;
-}
-
 /**
  * of_fpga_mgr_get - Given a device node, get a reference to a fpga mgr.
  *
@@ -498,8 +493,7 @@ struct fpga_manager *of_fpga_mgr_get(struct device_node *node)
 {
 	struct device *dev;
 
-	dev = class_find_device(fpga_mgr_class, NULL, node,
-				fpga_mgr_of_node_match);
+	dev = class_find_device_by_of_node(fpga_mgr_class, node);
 	if (!dev)
 		return ERR_PTR(-ENODEV);
 
diff --git a/drivers/gpu/drm/drm_mipi_dsi.c b/drivers/gpu/drm/drm_mipi_dsi.c
index ad19df0686c9..bd2498bbd74a 100644
--- a/drivers/gpu/drm/drm_mipi_dsi.c
+++ b/drivers/gpu/drm/drm_mipi_dsi.c
@@ -93,11 +93,6 @@ static struct bus_type mipi_dsi_bus_type = {
 	.pm = &mipi_dsi_device_pm_ops,
 };
 
-static int of_device_match(struct device *dev, const void *data)
-{
-	return dev->of_node == data;
-}
-
 /**
  * of_find_mipi_dsi_device_by_node() - find the MIPI DSI device matching a
  *    device tree node
@@ -110,7 +105,7 @@ struct mipi_dsi_device *of_find_mipi_dsi_device_by_node(struct device_node *np)
 {
 	struct device *dev;
 
-	dev = bus_find_device(&mipi_dsi_bus_type, NULL, np, of_device_match);
+	dev = bus_find_device_by_of_node(&mipi_dsi_bus_type, np);
 
 	return dev ? to_mipi_dsi_device(dev) : NULL;
 }
* Unmerged path drivers/i2c/i2c-core-of.c
* Unmerged path drivers/mfd/altera-sysmgr.c
diff --git a/drivers/mux/core.c b/drivers/mux/core.c
index d1271c1ee23c..1fb22388e7e0 100644
--- a/drivers/mux/core.c
+++ b/drivers/mux/core.c
@@ -405,17 +405,12 @@ int mux_control_deselect(struct mux_control *mux)
 }
 EXPORT_SYMBOL_GPL(mux_control_deselect);
 
-static int of_dev_node_match(struct device *dev, const void *data)
-{
-	return dev->of_node == data;
-}
-
 /* Note this function returns a reference to the mux_chip dev. */
 static struct mux_chip *of_find_mux_chip_by_node(struct device_node *np)
 {
 	struct device *dev;
 
-	dev = class_find_device(&mux_class, NULL, np, of_dev_node_match);
+	dev = class_find_device_by_of_node(&mux_class, np);
 
 	return dev ? to_mux_chip(dev) : NULL;
 }
diff --git a/drivers/net/phy/mdio_bus.c b/drivers/net/phy/mdio_bus.c
index 482a608003cc..9bb9f37f21dc 100644
--- a/drivers/net/phy/mdio_bus.c
+++ b/drivers/net/phy/mdio_bus.c
@@ -463,11 +463,6 @@ static struct class mdio_bus_class = {
 };
 
 #if IS_ENABLED(CONFIG_OF_MDIO)
-/* Helper function for of_mdio_find_bus */
-static int of_mdio_bus_match(struct device *dev, const void *mdio_bus_np)
-{
-	return dev->of_node == mdio_bus_np;
-}
 /**
  * of_mdio_find_bus - Given an mii_bus node, find the mii_bus.
  * @mdio_bus_np: Pointer to the mii_bus.
@@ -488,9 +483,7 @@ struct mii_bus *of_mdio_find_bus(struct device_node *mdio_bus_np)
 	if (!mdio_bus_np)
 		return NULL;
 
-	d = class_find_device(&mdio_bus_class, NULL,  mdio_bus_np,
-			      of_mdio_bus_match);
-
+	d = class_find_device_by_of_node(&mdio_bus_class, mdio_bus_np);
 	return d ? to_mii_bus(d) : NULL;
 }
 EXPORT_SYMBOL(of_mdio_find_bus);
diff --git a/drivers/nvmem/core.c b/drivers/nvmem/core.c
index a327420056a1..8d612e617657 100644
--- a/drivers/nvmem/core.c
+++ b/drivers/nvmem/core.c
@@ -263,11 +263,6 @@ static struct bus_type nvmem_bus_type = {
 	.name		= "nvmem",
 };
 
-static int of_nvmem_match(struct device *dev, const void *nvmem_np)
-{
-	return dev->of_node == nvmem_np;
-}
-
 static struct nvmem_device *of_nvmem_find(struct device_node *nvmem_np)
 {
 	struct device *d;
@@ -275,7 +270,7 @@ static struct nvmem_device *of_nvmem_find(struct device_node *nvmem_np)
 	if (!nvmem_np)
 		return NULL;
 
-	d = bus_find_device(&nvmem_bus_type, NULL, nvmem_np, of_nvmem_match);
+	d = bus_find_device_by_of_node(&nvmem_bus_type, nvmem_np);
 
 	if (!d)
 		return NULL;
diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index 52b744a15dea..6ef5cbeced33 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -320,12 +320,6 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 }
 EXPORT_SYMBOL(of_mdiobus_register);
 
-/* Helper function for of_phy_find_device */
-static int of_phy_match(struct device *dev, const void *phy_np)
-{
-	return dev->of_node == phy_np;
-}
-
 /**
  * of_phy_find_device - Give a PHY node, find the phy_device
  * @phy_np: Pointer to the phy's device tree node
@@ -341,7 +335,7 @@ struct phy_device *of_phy_find_device(struct device_node *phy_np)
 	if (!phy_np)
 		return NULL;
 
-	d = bus_find_device(&mdio_bus_type, NULL, phy_np, of_phy_match);
+	d = bus_find_device_by_of_node(&mdio_bus_type, phy_np);
 	if (d) {
 		mdiodev = to_mdio_device(d);
 		if (mdiodev->flags & MDIO_DEVICE_FLAG_PHY)
diff --git a/drivers/of/platform.c b/drivers/of/platform.c
index 41d233adedf5..4b1cf2408f97 100644
--- a/drivers/of/platform.c
+++ b/drivers/of/platform.c
@@ -37,11 +37,6 @@ static const struct of_device_id of_skipped_node_table[] = {
 	{} /* Empty terminated list */
 };
 
-static int of_dev_node_match(struct device *dev, const void *data)
-{
-	return dev->of_node == data;
-}
-
 /**
  * of_find_device_by_node - Find the platform_device associated with a node
  * @np: Pointer to device tree node
@@ -55,7 +50,7 @@ struct platform_device *of_find_device_by_node(struct device_node *np)
 {
 	struct device *dev;
 
-	dev = bus_find_device(&platform_bus_type, NULL, np, of_dev_node_match);
+	dev = bus_find_device_by_of_node(&platform_bus_type, np);
 	return dev ? to_platform_device(dev) : NULL;
 }
 EXPORT_SYMBOL(of_find_device_by_node);
diff --git a/drivers/regulator/of_regulator.c b/drivers/regulator/of_regulator.c
index 638f17d4c848..2c2e8f274954 100644
--- a/drivers/regulator/of_regulator.c
+++ b/drivers/regulator/of_regulator.c
@@ -426,16 +426,11 @@ struct regulator_init_data *regulator_of_get_init_data(struct device *dev,
 	return init_data;
 }
 
-static int of_node_match(struct device *dev, const void *data)
-{
-	return dev->of_node == data;
-}
-
 struct regulator_dev *of_find_regulator_by_node(struct device_node *np)
 {
 	struct device *dev;
 
-	dev = class_find_device(&regulator_class, NULL, np, of_node_match);
+	dev = class_find_device_by_of_node(&regulator_class, np);
 
 	return dev ? dev_to_rdev(dev) : NULL;
 }
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 1051edf941c1..a0e0f827e2f9 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -3518,37 +3518,25 @@ EXPORT_SYMBOL_GPL(spi_write_then_read);
 /*-------------------------------------------------------------------------*/
 
 #if IS_ENABLED(CONFIG_OF)
-static int __spi_of_device_match(struct device *dev, const void *data)
-{
-	return dev->of_node == data;
-}
-
 /* must call put_device() when done with returned spi_device device */
 struct spi_device *of_find_spi_device_by_node(struct device_node *node)
 {
-	struct device *dev = bus_find_device(&spi_bus_type, NULL, node,
-						__spi_of_device_match);
+	struct device *dev = bus_find_device_by_of_node(&spi_bus_type, node);
+
 	return dev ? to_spi_device(dev) : NULL;
 }
 EXPORT_SYMBOL_GPL(of_find_spi_device_by_node);
 #endif /* IS_ENABLED(CONFIG_OF) */
 
 #if IS_ENABLED(CONFIG_OF_DYNAMIC)
-static int __spi_of_controller_match(struct device *dev, const void *data)
-{
-	return dev->of_node == data;
-}
-
 /* the spi controllers are not using spi_bus, so we find it with another way */
 static struct spi_controller *of_find_spi_controller_by_node(struct device_node *node)
 {
 	struct device *dev;
 
-	dev = class_find_device(&spi_master_class, NULL, node,
-				__spi_of_controller_match);
+	dev = class_find_device_by_of_node(&spi_master_class, node);
 	if (!dev && IS_ENABLED(CONFIG_SPI_SLAVE))
-		dev = class_find_device(&spi_slave_class, NULL, node,
-					__spi_of_controller_match);
+		dev = class_find_device_by_of_node(&spi_slave_class, node);
 	if (!dev)
 		return NULL;
 
* Unmerged path include/linux/device.h
diff --git a/sound/soc/rockchip/rk3399_gru_sound.c b/sound/soc/rockchip/rk3399_gru_sound.c
index b00c43c75e85..f45e5aaa4b30 100644
--- a/sound/soc/rockchip/rk3399_gru_sound.c
+++ b/sound/soc/rockchip/rk3399_gru_sound.c
@@ -422,11 +422,6 @@ static const struct dailink_match_data dailink_match[] = {
 	},
 };
 
-static int of_dev_node_match(struct device *dev, const void *data)
-{
-	return dev->of_node == data;
-}
-
 static int rockchip_sound_codec_node_match(struct device_node *np_codec)
 {
 	struct device *dev;
@@ -438,8 +433,8 @@ static int rockchip_sound_codec_node_match(struct device_node *np_codec)
 			continue;
 
 		if (dailink_match[i].bus_type) {
-			dev = bus_find_device(dailink_match[i].bus_type, NULL,
-					      np_codec, of_dev_node_match);
+			dev = bus_find_device_by_of_node(dailink_match[i].bus_type,
+							 np_codec);
 			if (!dev)
 				continue;
 			put_device(dev);
