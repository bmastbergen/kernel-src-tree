netfilter: nat: remove l4proto->in_range

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Florian Westphal <fw@strlen.de>
commit fe2d0020994cd9d4f451e3024109319af287413b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/fe2d0020.failed

With exception of icmp, all of the l4 nat protocols set this to
nf_nat_l4proto_in_range.

Get rid of this and just check the l4proto in the caller.

	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit fe2d0020994cd9d4f451e3024109319af287413b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_nat_l4proto.h
#	net/ipv4/netfilter/nf_nat_proto_gre.c
#	net/ipv4/netfilter/nf_nat_proto_icmp.c
#	net/ipv6/netfilter/nf_nat_proto_icmpv6.c
#	net/netfilter/nf_nat_core.c
#	net/netfilter/nf_nat_proto_common.c
#	net/netfilter/nf_nat_proto_dccp.c
#	net/netfilter/nf_nat_proto_sctp.c
#	net/netfilter/nf_nat_proto_tcp.c
#	net/netfilter/nf_nat_proto_udp.c
#	net/netfilter/nf_nat_proto_unknown.c
diff --cc include/net/netfilter/nf_nat_l4proto.h
index 7ecac2cd1020,ebf7cbf605cb..000000000000
--- a/include/net/netfilter/nf_nat_l4proto.h
+++ b/include/net/netfilter/nf_nat_l4proto.h
@@@ -21,23 -21,6 +21,26 @@@ struct nf_nat_l4proto 
  			  const struct nf_conntrack_tuple *tuple,
  			  enum nf_nat_manip_type maniptype);
  
++<<<<<<< HEAD
 +	/* Is the manipable part of the tuple between min and max incl? */
 +	bool (*in_range)(const struct nf_conntrack_tuple *tuple,
 +			 enum nf_nat_manip_type maniptype,
 +			 const union nf_conntrack_man_proto *min,
 +			 const union nf_conntrack_man_proto *max);
 +
 +	/* Alter the per-proto part of the tuple (depending on
 +	 * maniptype), to give a unique tuple in the given range if
 +	 * possible.  Per-protocol part of tuple is initialized to the
 +	 * incoming packet.
 +	 */
 +	void (*unique_tuple)(const struct nf_nat_l3proto *l3proto,
 +			     struct nf_conntrack_tuple *tuple,
 +			     const struct nf_nat_range2 *range,
 +			     enum nf_nat_manip_type maniptype,
 +			     const struct nf_conn *ct);
 +
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  	int (*nlattr_to_range)(struct nlattr *tb[],
  			       struct nf_nat_range2 *range);
  };
@@@ -65,17 -48,6 +68,20 @@@ extern const struct nf_nat_l4proto nf_n
  extern const struct nf_nat_l4proto nf_nat_l4proto_udplite;
  #endif
  
++<<<<<<< HEAD
 +bool nf_nat_l4proto_in_range(const struct nf_conntrack_tuple *tuple,
 +			     enum nf_nat_manip_type maniptype,
 +			     const union nf_conntrack_man_proto *min,
 +			     const union nf_conntrack_man_proto *max);
 +
 +void nf_nat_l4proto_unique_tuple(const struct nf_nat_l3proto *l3proto,
 +				 struct nf_conntrack_tuple *tuple,
 +				 const struct nf_nat_range2 *range,
 +				 enum nf_nat_manip_type maniptype,
 +				 const struct nf_conn *ct);
 +
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  int nf_nat_l4proto_nlattr_to_range(struct nlattr *tb[],
  				   struct nf_nat_range2 *range);
  
diff --cc net/ipv4/netfilter/nf_nat_proto_gre.c
index 00fda6331ce5,94b735dd570d..000000000000
--- a/net/ipv4/netfilter/nf_nat_proto_gre.c
+++ b/net/ipv4/netfilter/nf_nat_proto_gre.c
@@@ -123,8 -80,6 +123,11 @@@ gre_manip_pkt(struct sk_buff *skb
  static const struct nf_nat_l4proto gre = {
  	.l4proto		= IPPROTO_GRE,
  	.manip_pkt		= gre_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= nf_nat_l4proto_in_range,
 +	.unique_tuple		= gre_unique_tuple,
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
  #endif
diff --cc net/ipv4/netfilter/nf_nat_proto_icmp.c
index 6d7cf1d79baf,f532e2215970..000000000000
--- a/net/ipv4/netfilter/nf_nat_proto_icmp.c
+++ b/net/ipv4/netfilter/nf_nat_proto_icmp.c
@@@ -18,42 -18,6 +18,45 @@@
  #include <net/netfilter/nf_nat_l4proto.h>
  
  static bool
++<<<<<<< HEAD
 +icmp_in_range(const struct nf_conntrack_tuple *tuple,
 +	      enum nf_nat_manip_type maniptype,
 +	      const union nf_conntrack_man_proto *min,
 +	      const union nf_conntrack_man_proto *max)
 +{
 +	return ntohs(tuple->src.u.icmp.id) >= ntohs(min->icmp.id) &&
 +	       ntohs(tuple->src.u.icmp.id) <= ntohs(max->icmp.id);
 +}
 +
 +static void
 +icmp_unique_tuple(const struct nf_nat_l3proto *l3proto,
 +		  struct nf_conntrack_tuple *tuple,
 +		  const struct nf_nat_range2 *range,
 +		  enum nf_nat_manip_type maniptype,
 +		  const struct nf_conn *ct)
 +{
 +	static u_int16_t id;
 +	unsigned int range_size;
 +	unsigned int i;
 +
 +	range_size = ntohs(range->max_proto.icmp.id) -
 +		     ntohs(range->min_proto.icmp.id) + 1;
 +	/* If no range specified... */
 +	if (!(range->flags & NF_NAT_RANGE_PROTO_SPECIFIED))
 +		range_size = 0xFFFF;
 +
 +	for (i = 0; ; ++id) {
 +		tuple->src.u.icmp.id = htons(ntohs(range->min_proto.icmp.id) +
 +					     (id % range_size));
 +		if (++i == range_size || !nf_nat_used_tuple(tuple, ct))
 +			return;
 +	}
 +	return;
 +}
 +
 +static bool
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  icmp_manip_pkt(struct sk_buff *skb,
  	       const struct nf_nat_l3proto *l3proto,
  	       unsigned int iphdroff, unsigned int hdroff,
@@@ -75,8 -39,6 +78,11 @@@
  const struct nf_nat_l4proto nf_nat_l4proto_icmp = {
  	.l4proto		= IPPROTO_ICMP,
  	.manip_pkt		= icmp_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= icmp_in_range,
 +	.unique_tuple		= icmp_unique_tuple,
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
  #endif
diff --cc net/ipv6/netfilter/nf_nat_proto_icmpv6.c
index d9bf42ba44fa,ffae55c1fb8d..000000000000
--- a/net/ipv6/netfilter/nf_nat_proto_icmpv6.c
+++ b/net/ipv6/netfilter/nf_nat_proto_icmpv6.c
@@@ -20,41 -20,6 +20,44 @@@
  #include <net/netfilter/nf_nat_l4proto.h>
  
  static bool
++<<<<<<< HEAD
 +icmpv6_in_range(const struct nf_conntrack_tuple *tuple,
 +		enum nf_nat_manip_type maniptype,
 +		const union nf_conntrack_man_proto *min,
 +		const union nf_conntrack_man_proto *max)
 +{
 +	return ntohs(tuple->src.u.icmp.id) >= ntohs(min->icmp.id) &&
 +	       ntohs(tuple->src.u.icmp.id) <= ntohs(max->icmp.id);
 +}
 +
 +static void
 +icmpv6_unique_tuple(const struct nf_nat_l3proto *l3proto,
 +		    struct nf_conntrack_tuple *tuple,
 +		    const struct nf_nat_range2 *range,
 +		    enum nf_nat_manip_type maniptype,
 +		    const struct nf_conn *ct)
 +{
 +	static u16 id;
 +	unsigned int range_size;
 +	unsigned int i;
 +
 +	range_size = ntohs(range->max_proto.icmp.id) -
 +		     ntohs(range->min_proto.icmp.id) + 1;
 +
 +	if (!(range->flags & NF_NAT_RANGE_PROTO_SPECIFIED))
 +		range_size = 0xffff;
 +
 +	for (i = 0; ; ++id) {
 +		tuple->src.u.icmp.id = htons(ntohs(range->min_proto.icmp.id) +
 +					     (id % range_size));
 +		if (++i == range_size || !nf_nat_used_tuple(tuple, ct))
 +			return;
 +	}
 +}
 +
 +static bool
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  icmpv6_manip_pkt(struct sk_buff *skb,
  		 const struct nf_nat_l3proto *l3proto,
  		 unsigned int iphdroff, unsigned int hdroff,
@@@ -82,8 -47,6 +85,11 @@@
  const struct nf_nat_l4proto nf_nat_l4proto_icmpv6 = {
  	.l4proto		= IPPROTO_ICMPV6,
  	.manip_pkt		= icmpv6_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= icmpv6_in_range,
 +	.unique_tuple		= icmpv6_unique_tuple,
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
  #endif
diff --cc net/netfilter/nf_nat_core.c
index 5e173f6800a4,d0351e0f21ad..000000000000
--- a/net/netfilter/nf_nat_core.c
+++ b/net/netfilter/nf_nat_core.c
@@@ -174,27 -172,66 +174,75 @@@ nf_nat_used_tuple(const struct nf_connt
  }
  EXPORT_SYMBOL(nf_nat_used_tuple);
  
++<<<<<<< HEAD
 +/* If we source map this tuple so reply looks like reply_tuple, will
 + * that meet the constraints of range.
 + */
 +static int in_range(const struct nf_nat_l3proto *l3proto,
 +		    const struct nf_nat_l4proto *l4proto,
 +		    const struct nf_conntrack_tuple *tuple,
++=======
+ static bool nf_nat_inet_in_range(const struct nf_conntrack_tuple *t,
+ 				 const struct nf_nat_range2 *range)
+ {
+ 	if (t->src.l3num == NFPROTO_IPV4)
+ 		return ntohl(t->src.u3.ip) >= ntohl(range->min_addr.ip) &&
+ 		       ntohl(t->src.u3.ip) <= ntohl(range->max_addr.ip);
+ 
+ 	return ipv6_addr_cmp(&t->src.u3.in6, &range->min_addr.in6) >= 0 &&
+ 	       ipv6_addr_cmp(&t->src.u3.in6, &range->max_addr.in6) <= 0;
+ }
+ 
+ /* Is the manipable part of the tuple between min and max incl? */
+ static bool l4proto_in_range(const struct nf_conntrack_tuple *tuple,
+ 			     enum nf_nat_manip_type maniptype,
+ 			     const union nf_conntrack_man_proto *min,
+ 			     const union nf_conntrack_man_proto *max)
+ {
+ 	__be16 port;
+ 
+ 	switch (tuple->dst.protonum) {
+ 	case IPPROTO_ICMP: /* fallthrough */
+ 	case IPPROTO_ICMPV6:
+ 		return ntohs(tuple->src.u.icmp.id) >= ntohs(min->icmp.id) &&
+ 		       ntohs(tuple->src.u.icmp.id) <= ntohs(max->icmp.id);
+ 	case IPPROTO_GRE: /* all fall though */
+ 	case IPPROTO_TCP:
+ 	case IPPROTO_UDP:
+ 	case IPPROTO_UDPLITE:
+ 	case IPPROTO_DCCP:
+ 	case IPPROTO_SCTP:
+ 		if (maniptype == NF_NAT_MANIP_SRC)
+ 			port = tuple->src.u.all;
+ 		else
+ 			port = tuple->dst.u.all;
+ 
+ 		return ntohs(port) >= ntohs(min->all) &&
+ 		       ntohs(port) <= ntohs(max->all);
+ 	default:
+ 		return true;
+ 	}
+ }
+ 
+ /* If we source map this tuple so reply looks like reply_tuple, will
+  * that meet the constraints of range.
+  */
+ static int in_range(const struct nf_conntrack_tuple *tuple,
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  		    const struct nf_nat_range2 *range)
  {
  	/* If we are supposed to map IPs, then we must be in the
  	 * range specified, otherwise let this drag us onto a new src IP.
  	 */
  	if (range->flags & NF_NAT_RANGE_MAP_IPS &&
 -	    !nf_nat_inet_in_range(tuple, range))
 +	    !l3proto->in_range(tuple, range))
  		return 0;
  
- 	if (!(range->flags & NF_NAT_RANGE_PROTO_SPECIFIED) ||
- 	    l4proto->in_range(tuple, NF_NAT_MANIP_SRC,
- 			      &range->min_proto, &range->max_proto))
+ 	if (!(range->flags & NF_NAT_RANGE_PROTO_SPECIFIED))
  		return 1;
  
- 	return 0;
+ 	return l4proto_in_range(tuple, NF_NAT_MANIP_SRC,
+ 				&range->min_proto, &range->max_proto);
  }
  
  static inline int
@@@ -213,8 -250,6 +261,11 @@@ same_src(const struct nf_conn *ct
  static int
  find_appropriate_src(struct net *net,
  		     const struct nf_conntrack_zone *zone,
++<<<<<<< HEAD
 +		     const struct nf_nat_l3proto *l3proto,
 +		     const struct nf_nat_l4proto *l4proto,
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  		     const struct nf_conntrack_tuple *tuple,
  		     struct nf_conntrack_tuple *result,
  		     const struct nf_nat_range2 *range)
@@@ -231,7 -266,7 +282,11 @@@
  				       &ct->tuplehash[IP_CT_DIR_REPLY].tuple);
  			result->dst = tuple->dst;
  
++<<<<<<< HEAD
 +			if (in_range(l3proto, l4proto, result, range))
++=======
+ 			if (in_range(result, range))
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  				return 1;
  		}
  	}
@@@ -348,12 -493,12 +396,20 @@@ get_unique_tuple(struct nf_conntrack_tu
  	if (maniptype == NF_NAT_MANIP_SRC &&
  	    !(range->flags & NF_NAT_RANGE_PROTO_RANDOM_ALL)) {
  		/* try the original tuple first */
++<<<<<<< HEAD
 +		if (in_range(l3proto, l4proto, orig_tuple, range)) {
++=======
+ 		if (in_range(orig_tuple, range)) {
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  			if (!nf_nat_used_tuple(orig_tuple, ct)) {
  				*tuple = *orig_tuple;
- 				goto out;
+ 				return;
  			}
++<<<<<<< HEAD
 +		} else if (find_appropriate_src(net, zone, l3proto, l4proto,
++=======
+ 		} else if (find_appropriate_src(net, zone,
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  						orig_tuple, tuple, range)) {
  			pr_debug("get_unique_tuple: Found current src map\n");
  			if (!nf_nat_used_tuple(tuple, ct))
@@@ -385,9 -530,7 +441,13 @@@
  	}
  
  	/* Last chance: get protocol to try to obtain unique tuple. */
++<<<<<<< HEAD
 +	l4proto->unique_tuple(l3proto, tuple, range, maniptype, ct);
 +out:
 +	rcu_read_unlock();
++=======
+ 	nf_nat_l4proto_unique_tuple(tuple, range, maniptype, ct);
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  }
  
  struct nf_conn_nat *nf_ct_nat_ext_add(struct nf_conn *ct)
diff --cc net/netfilter/nf_nat_proto_common.c
index 234f535d350e,a155cfa1cc13..000000000000
--- a/net/netfilter/nf_nat_proto_common.c
+++ b/net/netfilter/nf_nat_proto_common.c
@@@ -17,103 -17,6 +17,106 @@@
  #include <net/netfilter/nf_nat_l3proto.h>
  #include <net/netfilter/nf_nat_l4proto.h>
  
++<<<<<<< HEAD
 +bool nf_nat_l4proto_in_range(const struct nf_conntrack_tuple *tuple,
 +			     enum nf_nat_manip_type maniptype,
 +			     const union nf_conntrack_man_proto *min,
 +			     const union nf_conntrack_man_proto *max)
 +{
 +	__be16 port;
 +
 +	if (maniptype == NF_NAT_MANIP_SRC)
 +		port = tuple->src.u.all;
 +	else
 +		port = tuple->dst.u.all;
 +
 +	return ntohs(port) >= ntohs(min->all) &&
 +	       ntohs(port) <= ntohs(max->all);
 +}
 +EXPORT_SYMBOL_GPL(nf_nat_l4proto_in_range);
 +
 +void nf_nat_l4proto_unique_tuple(const struct nf_nat_l3proto *l3proto,
 +				 struct nf_conntrack_tuple *tuple,
 +				 const struct nf_nat_range2 *range,
 +				 enum nf_nat_manip_type maniptype,
 +				 const struct nf_conn *ct)
 +{
 +	unsigned int range_size, min, max, i, attempts;
 +	__be16 *portptr;
 +	u16 off;
 +	static const unsigned int max_attempts = 128;
 +
 +	if (maniptype == NF_NAT_MANIP_SRC)
 +		portptr = &tuple->src.u.all;
 +	else
 +		portptr = &tuple->dst.u.all;
 +
 +	/* If no range specified... */
 +	if (!(range->flags & NF_NAT_RANGE_PROTO_SPECIFIED)) {
 +		/* If it's dst rewrite, can't change port */
 +		if (maniptype == NF_NAT_MANIP_DST)
 +			return;
 +
 +		if (ntohs(*portptr) < 1024) {
 +			/* Loose convention: >> 512 is credential passing */
 +			if (ntohs(*portptr) < 512) {
 +				min = 1;
 +				range_size = 511 - min + 1;
 +			} else {
 +				min = 600;
 +				range_size = 1023 - min + 1;
 +			}
 +		} else {
 +			min = 1024;
 +			range_size = 65535 - 1024 + 1;
 +		}
 +	} else {
 +		min = ntohs(range->min_proto.all);
 +		max = ntohs(range->max_proto.all);
 +		if (unlikely(max < min))
 +			swap(max, min);
 +		range_size = max - min + 1;
 +	}
 +
 +	if (range->flags & NF_NAT_RANGE_PROTO_RANDOM) {
 +		off = l3proto->secure_port(tuple, maniptype == NF_NAT_MANIP_SRC
 +						  ? tuple->dst.u.all
 +						  : tuple->src.u.all);
 +	} else if (range->flags & NF_NAT_RANGE_PROTO_RANDOM_FULLY) {
 +		off = prandom_u32();
 +	} else if (range->flags & NF_NAT_RANGE_PROTO_OFFSET) {
 +		off = (ntohs(*portptr) - ntohs(range->base_proto.all));
 +	} else {
 +		off = prandom_u32();
 +	}
 +
 +	attempts = range_size;
 +	if (attempts > max_attempts)
 +		attempts = max_attempts;
 +
 +	/* We are in softirq; doing a search of the entire range risks
 +	 * soft lockup when all tuples are already used.
 +	 *
 +	 * If we can't find any free port from first offset, pick a new
 +	 * one and try again, with ever smaller search window.
 +	 */
 +another_round:
 +	for (i = 0; i < attempts; i++, off++) {
 +		*portptr = htons(min + off % range_size);
 +		if (!nf_nat_used_tuple(tuple, ct))
 +			return;
 +	}
 +
 +	if (attempts >= range_size || attempts < 16)
 +		return;
 +	attempts /= 2;
 +	off = prandom_u32();
 +	goto another_round;
 +}
 +EXPORT_SYMBOL_GPL(nf_nat_l4proto_unique_tuple);
 +
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  int nf_nat_l4proto_nlattr_to_range(struct nlattr *tb[],
  				   struct nf_nat_range2 *range)
diff --cc net/netfilter/nf_nat_proto_dccp.c
index 7d4d2c124990,a5ed1e3e4f22..000000000000
--- a/net/netfilter/nf_nat_proto_dccp.c
+++ b/net/netfilter/nf_nat_proto_dccp.c
@@@ -71,8 -61,6 +71,11 @@@ dccp_manip_pkt(struct sk_buff *skb
  const struct nf_nat_l4proto nf_nat_l4proto_dccp = {
  	.l4proto		= IPPROTO_DCCP,
  	.manip_pkt		= dccp_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= nf_nat_l4proto_in_range,
 +	.unique_tuple		= dccp_unique_tuple,
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
  #endif
diff --cc net/netfilter/nf_nat_proto_sctp.c
index f05ad8fa7b20,ff5f5bbd2ff1..000000000000
--- a/net/netfilter/nf_nat_proto_sctp.c
+++ b/net/netfilter/nf_nat_proto_sctp.c
@@@ -66,8 -56,6 +66,11 @@@ sctp_manip_pkt(struct sk_buff *skb
  const struct nf_nat_l4proto nf_nat_l4proto_sctp = {
  	.l4proto		= IPPROTO_SCTP,
  	.manip_pkt		= sctp_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= nf_nat_l4proto_in_range,
 +	.unique_tuple		= sctp_unique_tuple,
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
  #endif
diff --cc net/netfilter/nf_nat_proto_tcp.c
index c312e6b3e2ea,c938ecf7e0b0..000000000000
--- a/net/netfilter/nf_nat_proto_tcp.c
+++ b/net/netfilter/nf_nat_proto_tcp.c
@@@ -74,8 -64,6 +74,11 @@@ tcp_manip_pkt(struct sk_buff *skb
  const struct nf_nat_l4proto nf_nat_l4proto_tcp = {
  	.l4proto		= IPPROTO_TCP,
  	.manip_pkt		= tcp_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= nf_nat_l4proto_in_range,
 +	.unique_tuple		= tcp_unique_tuple,
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
  #endif
diff --cc net/netfilter/nf_nat_proto_udp.c
index 208c14316359,6703eb005c67..000000000000
--- a/net/netfilter/nf_nat_proto_udp.c
+++ b/net/netfilter/nf_nat_proto_udp.c
@@@ -105,8 -85,6 +105,11 @@@ udplite_unique_tuple(const struct nf_na
  const struct nf_nat_l4proto nf_nat_l4proto_udplite = {
  	.l4proto		= IPPROTO_UDPLITE,
  	.manip_pkt		= udplite_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= nf_nat_l4proto_in_range,
 +	.unique_tuple		= udplite_unique_tuple,
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
  #endif
@@@ -116,8 -94,6 +119,11 @@@
  const struct nf_nat_l4proto nf_nat_l4proto_udp = {
  	.l4proto		= IPPROTO_UDP,
  	.manip_pkt		= udp_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= nf_nat_l4proto_in_range,
 +	.unique_tuple		= udp_unique_tuple,
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  #if IS_ENABLED(CONFIG_NF_CT_NETLINK)
  	.nlattr_to_range	= nf_nat_l4proto_nlattr_to_range,
  #endif
diff --cc net/netfilter/nf_nat_proto_unknown.c
index c5db3e251232,ba178b02fc1a..000000000000
--- a/net/netfilter/nf_nat_proto_unknown.c
+++ b/net/netfilter/nf_nat_proto_unknown.c
@@@ -17,26 -17,6 +17,29 @@@
  #include <net/netfilter/nf_nat.h>
  #include <net/netfilter/nf_nat_l4proto.h>
  
++<<<<<<< HEAD
 +static bool unknown_in_range(const struct nf_conntrack_tuple *tuple,
 +			     enum nf_nat_manip_type manip_type,
 +			     const union nf_conntrack_man_proto *min,
 +			     const union nf_conntrack_man_proto *max)
 +{
 +	return true;
 +}
 +
 +static void unknown_unique_tuple(const struct nf_nat_l3proto *l3proto,
 +				 struct nf_conntrack_tuple *tuple,
 +				 const struct nf_nat_range2 *range,
 +				 enum nf_nat_manip_type maniptype,
 +				 const struct nf_conn *ct)
 +{
 +	/* Sorry: we can't help you; if it's not unique, we can't frob
 +	 * anything.
 +	 */
 +	return;
 +}
 +
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  static bool
  unknown_manip_pkt(struct sk_buff *skb,
  		  const struct nf_nat_l3proto *l3proto,
@@@ -49,6 -29,4 +52,9 @@@
  
  const struct nf_nat_l4proto nf_nat_l4proto_unknown = {
  	.manip_pkt		= unknown_manip_pkt,
++<<<<<<< HEAD
 +	.in_range		= unknown_in_range,
 +	.unique_tuple		= unknown_unique_tuple,
++=======
++>>>>>>> fe2d0020994c (netfilter: nat: remove l4proto->in_range)
  };
* Unmerged path include/net/netfilter/nf_nat_l4proto.h
* Unmerged path net/ipv4/netfilter/nf_nat_proto_gre.c
* Unmerged path net/ipv4/netfilter/nf_nat_proto_icmp.c
* Unmerged path net/ipv6/netfilter/nf_nat_proto_icmpv6.c
* Unmerged path net/netfilter/nf_nat_core.c
* Unmerged path net/netfilter/nf_nat_proto_common.c
* Unmerged path net/netfilter/nf_nat_proto_dccp.c
* Unmerged path net/netfilter/nf_nat_proto_sctp.c
* Unmerged path net/netfilter/nf_nat_proto_tcp.c
* Unmerged path net/netfilter/nf_nat_proto_udp.c
* Unmerged path net/netfilter/nf_nat_proto_unknown.c
