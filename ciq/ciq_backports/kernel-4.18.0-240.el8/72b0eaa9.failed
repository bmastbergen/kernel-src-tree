KVM: VMX: Configure runtime hooks using vmx_x86_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Sean Christopherson <sean.j.christopherson@intel.com>
commit 72b0eaa946076cba3bc315c88199db7704b5538c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/72b0eaa9.failed

Configure VMX's runtime hooks by modifying vmx_x86_ops directly instead
of using the global kvm_x86_ops.  This sets the stage for waiting until
after ->hardware_setup() to set kvm_x86_ops with the vendor's
implementation.

	Signed-off-by: Sean Christopherson <sean.j.christopherson@intel.com>
Message-Id: <20200321202603.19355-5-sean.j.christopherson@intel.com>
	Reviewed-by: Vitaly Kuznetsov <vkuznets@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 72b0eaa946076cba3bc315c88199db7704b5538c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx/nested.c
#	arch/x86/kvm/vmx/vmx.c
diff --cc arch/x86/kvm/vmx/nested.c
index 2632df1c1f2b,87fea22c3799..000000000000
--- a/arch/x86/kvm/vmx/nested.c
+++ b/arch/x86/kvm/vmx/nested.c
@@@ -6278,28 -6265,25 +6279,37 @@@ __init int nested_vmx_hardware_setup(st
  		init_vmcs_shadow_fields();
  	}
  
 -	exit_handlers[EXIT_REASON_VMCLEAR]	= handle_vmclear;
 -	exit_handlers[EXIT_REASON_VMLAUNCH]	= handle_vmlaunch;
 -	exit_handlers[EXIT_REASON_VMPTRLD]	= handle_vmptrld;
 -	exit_handlers[EXIT_REASON_VMPTRST]	= handle_vmptrst;
 -	exit_handlers[EXIT_REASON_VMREAD]	= handle_vmread;
 -	exit_handlers[EXIT_REASON_VMRESUME]	= handle_vmresume;
 -	exit_handlers[EXIT_REASON_VMWRITE]	= handle_vmwrite;
 -	exit_handlers[EXIT_REASON_VMOFF]	= handle_vmoff;
 -	exit_handlers[EXIT_REASON_VMON]		= handle_vmon;
 -	exit_handlers[EXIT_REASON_INVEPT]	= handle_invept;
 -	exit_handlers[EXIT_REASON_INVVPID]	= handle_invvpid;
 -	exit_handlers[EXIT_REASON_VMFUNC]	= handle_vmfunc;
 -
 +	nested_vmx_setup_ctls_msrs(&vmcs_config.nested,
 +				   vmx_capability.ept, enable_apicv);
 +
 +	exit_handlers[EXIT_REASON_VMCLEAR]	= handle_vmclear,
 +	exit_handlers[EXIT_REASON_VMLAUNCH]	= handle_vmlaunch,
 +	exit_handlers[EXIT_REASON_VMPTRLD]	= handle_vmptrld,
 +	exit_handlers[EXIT_REASON_VMPTRST]	= handle_vmptrst,
 +	exit_handlers[EXIT_REASON_VMREAD]	= handle_vmread,
 +	exit_handlers[EXIT_REASON_VMRESUME]	= handle_vmresume,
 +	exit_handlers[EXIT_REASON_VMWRITE]	= handle_vmwrite,
 +	exit_handlers[EXIT_REASON_VMOFF]	= handle_vmoff,
 +	exit_handlers[EXIT_REASON_VMON]		= handle_vmon,
 +	exit_handlers[EXIT_REASON_INVEPT]	= handle_invept,
 +	exit_handlers[EXIT_REASON_INVVPID]	= handle_invvpid,
 +	exit_handlers[EXIT_REASON_VMFUNC]	= handle_vmfunc,
 +
++<<<<<<< HEAD
 +	kvm_x86_ops->check_nested_events = vmx_check_nested_events;
 +	kvm_x86_ops->get_nested_state = vmx_get_nested_state;
 +	kvm_x86_ops->set_nested_state = vmx_set_nested_state;
 +	kvm_x86_ops->get_vmcs12_pages = nested_get_vmcs12_pages,
 +	kvm_x86_ops->nested_enable_evmcs = nested_enable_evmcs;
 +	kvm_x86_ops->nested_get_evmcs_version = nested_get_evmcs_version;
++=======
+ 	ops->check_nested_events = vmx_check_nested_events;
+ 	ops->get_nested_state = vmx_get_nested_state;
+ 	ops->set_nested_state = vmx_set_nested_state;
+ 	ops->get_vmcs12_pages = nested_get_vmcs12_pages;
+ 	ops->nested_enable_evmcs = nested_enable_evmcs;
+ 	ops->nested_get_evmcs_version = nested_get_evmcs_version;
++>>>>>>> 72b0eaa94607 (KVM: VMX: Configure runtime hooks using vmx_x86_ops)
  
  	return 0;
  }
diff --cc arch/x86/kvm/vmx/vmx.c
index 833b3f7d7961,a64c386895e7..000000000000
--- a/arch/x86/kvm/vmx/vmx.c
+++ b/arch/x86/kvm/vmx/vmx.c
@@@ -7853,7 -7956,11 +7853,15 @@@ static __init int hardware_setup(void
  		pt_mode = PT_MODE_SYSTEM;
  
  	if (nested) {
++<<<<<<< HEAD
 +		r = nested_vmx_hardware_setup(kvm_vmx_exit_handlers);
++=======
+ 		nested_vmx_setup_ctls_msrs(&vmcs_config.nested,
+ 					   vmx_capability.ept);
+ 
+ 		r = nested_vmx_hardware_setup(&vmx_x86_ops,
+ 					      kvm_vmx_exit_handlers);
++>>>>>>> 72b0eaa94607 (KVM: VMX: Configure runtime hooks using vmx_x86_ops)
  		if (r)
  			return r;
  	}
* Unmerged path arch/x86/kvm/vmx/nested.c
diff --git a/arch/x86/kvm/vmx/nested.h b/arch/x86/kvm/vmx/nested.h
index 183399743537..aeee4d0b3100 100644
--- a/arch/x86/kvm/vmx/nested.h
+++ b/arch/x86/kvm/vmx/nested.h
@@ -20,7 +20,8 @@ void vmx_leave_nested(struct kvm_vcpu *vcpu);
 void nested_vmx_setup_ctls_msrs(struct nested_vmx_msrs *msrs, u32 ept_caps,
 				bool apicv);
 void nested_vmx_hardware_unsetup(void);
-__init int nested_vmx_hardware_setup(int (*exit_handlers[])(struct kvm_vcpu *));
+__init int nested_vmx_hardware_setup(struct kvm_x86_ops *ops,
+				     int (*exit_handlers[])(struct kvm_vcpu *));
 void nested_vmx_set_vmcs_shadowing_bitmap(void);
 void nested_vmx_free_vcpu(struct kvm_vcpu *vcpu);
 enum nvmx_vmentry_status nested_vmx_enter_non_root_mode(struct kvm_vcpu *vcpu,
* Unmerged path arch/x86/kvm/vmx/vmx.c
