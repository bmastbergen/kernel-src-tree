flow_offload: use flow_action_for_each in flow_action_mixed_hw_stats_types_check()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Jiri Pirko <jiri@resnulli.us>
commit 62751b6808ec6bdc7622849815943cbc7377262a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/62751b68.failed

Instead of manually iterating over entries, use flow_action_for_each
helper. Move the helper and wrap it to fit to 80 cols on the way.

	Signed-off-by: Jiri Pirko <jiri@resnulli.us>
	Acked-by: Pablo Neira Ayuso <pablo@netfilter.org>
	Acked-by: Edward Cree <ecree@solarflare.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 62751b6808ec6bdc7622849815943cbc7377262a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/flow_offload.h
diff --cc include/net/flow_offload.h
index 26b427dff50f,891e15055708..000000000000
--- a/include/net/flow_offload.h
+++ b/include/net/flow_offload.h
@@@ -258,7 -257,68 +258,72 @@@ static inline bool flow_offload_has_one
  }
  
  #define flow_action_for_each(__i, __act, __actions)			\
++<<<<<<< HEAD
 +        for (__i = 0, __act = &(__actions)->entries[0]; __i < (__actions)->num_entries; __act = &(__actions)->entries[++__i])
++=======
+         for (__i = 0, __act = &(__actions)->entries[0];			\
+ 	     __i < (__actions)->num_entries;				\
+ 	     __act = &(__actions)->entries[++__i])
+ 
+ static inline bool
+ flow_action_mixed_hw_stats_types_check(const struct flow_action *action,
+ 				       struct netlink_ext_ack *extack)
+ {
+ 	const struct flow_action_entry *action_entry;
+ 	u8 uninitialized_var(last_hw_stats_type);
+ 	int i;
+ 
+ 	if (flow_offload_has_one_action(action))
+ 		return true;
+ 
+ 	flow_action_for_each(i, action_entry, action) {
+ 		if (i && action_entry->hw_stats_type != last_hw_stats_type) {
+ 			NL_SET_ERR_MSG_MOD(extack, "Mixing HW stats types for actions is not supported");
+ 			return false;
+ 		}
+ 		last_hw_stats_type = action_entry->hw_stats_type;
+ 	}
+ 	return true;
+ }
+ 
+ static inline const struct flow_action_entry *
+ flow_action_first_entry_get(const struct flow_action *action)
+ {
+ 	WARN_ON(!flow_action_has_entries(action));
+ 	return &action->entries[0];
+ }
+ 
+ static inline bool
+ flow_action_hw_stats_types_check(const struct flow_action *action,
+ 				 struct netlink_ext_ack *extack,
+ 				 u8 allowed_hw_stats_type)
+ {
+ 	const struct flow_action_entry *action_entry;
+ 
+ 	if (!flow_action_has_entries(action))
+ 		return true;
+ 	if (!flow_action_mixed_hw_stats_types_check(action, extack))
+ 		return false;
+ 	action_entry = flow_action_first_entry_get(action);
+ 	if (allowed_hw_stats_type == 0 &&
+ 	    action_entry->hw_stats_type != FLOW_ACTION_HW_STATS_TYPE_ANY) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Driver supports only default HW stats type \"any\"");
+ 		return false;
+ 	} else if (allowed_hw_stats_type != 0 &&
+ 		   action_entry->hw_stats_type != allowed_hw_stats_type) {
+ 		NL_SET_ERR_MSG_MOD(extack, "Driver does not support selected HW stats type");
+ 		return false;
+ 	}
+ 	return true;
+ }
+ 
+ static inline bool
+ flow_action_basic_hw_stats_types_check(const struct flow_action *action,
+ 				       struct netlink_ext_ack *extack)
+ {
+ 	return flow_action_hw_stats_types_check(action, extack, 0);
+ }
++>>>>>>> 62751b6808ec (flow_offload: use flow_action_for_each in flow_action_mixed_hw_stats_types_check())
  
  struct flow_rule {
  	struct flow_match	match;
* Unmerged path include/net/flow_offload.h
