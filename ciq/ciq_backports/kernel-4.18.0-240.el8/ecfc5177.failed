io_uring: fix potential use after free on fallback request free

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-240.el8
commit-author Pavel Begunkov <asml.silence@gmail.com>
commit ecfc51777487da4da530710e0b13de4c8cb4a6d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-240.el8/ecfc5177.failed

After __io_free_req() puts a ctx ref, it should be assumed that the ctx
may already be gone. However, it can be accessed when putting the
fallback req. Free the req first and then put the ctx.

	Signed-off-by: Pavel Begunkov <asml.silence@gmail.com>
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit ecfc51777487da4da530710e0b13de4c8cb4a6d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/io_uring.c
diff --cc fs/io_uring.c
index 0b681a205810,b54e358e6b31..000000000000
--- a/fs/io_uring.c
+++ b/fs/io_uring.c
@@@ -624,13 -1526,61 +624,25 @@@ static void io_free_req_many(struct io_
  
  static void __io_free_req(struct io_kiocb *req)
  {
++<<<<<<< HEAD
 +	if (req->file && !(req->flags & REQ_F_FIXED_FILE))
 +		fput(req->file);
 +	percpu_ref_put(&req->ctx->refs);
 +	kmem_cache_free(req_cachep, req);
++=======
+ 	struct io_ring_ctx *ctx;
+ 
+ 	io_dismantle_req(req);
+ 	ctx = req->ctx;
+ 	if (likely(!io_is_fallback_req(req)))
+ 		kmem_cache_free(req_cachep, req);
+ 	else
+ 		clear_bit_unlock(0, (unsigned long *) &ctx->fallback_req);
+ 	percpu_ref_put(&ctx->refs);
++>>>>>>> ecfc51777487 (io_uring: fix potential use after free on fallback request free)
  }
  
 -static bool io_link_cancel_timeout(struct io_kiocb *req)
 -{
 -	struct io_ring_ctx *ctx = req->ctx;
 -	int ret;
 -
 -	ret = hrtimer_try_to_cancel(&req->io->timeout.timer);
 -	if (ret != -1) {
 -		io_cqring_fill_event(req, -ECANCELED);
 -		io_commit_cqring(ctx);
 -		req->flags &= ~REQ_F_LINK_HEAD;
 -		io_put_req(req);
 -		return true;
 -	}
 -
 -	return false;
 -}
 -
 -static void io_kill_linked_timeout(struct io_kiocb *req)
 -{
 -	struct io_ring_ctx *ctx = req->ctx;
 -	struct io_kiocb *link;
 -	bool wake_ev = false;
 -	unsigned long flags = 0; /* false positive warning */
 -
 -	if (!(req->flags & REQ_F_COMP_LOCKED))
 -		spin_lock_irqsave(&ctx->completion_lock, flags);
 -
 -	if (list_empty(&req->link_list))
 -		goto out;
 -	link = list_first_entry(&req->link_list, struct io_kiocb, link_list);
 -	if (link->opcode != IORING_OP_LINK_TIMEOUT)
 -		goto out;
 -
 -	list_del_init(&link->link_list);
 -	wake_ev = io_link_cancel_timeout(link);
 -	req->flags &= ~REQ_F_LINK_TIMEOUT;
 -out:
 -	if (!(req->flags & REQ_F_COMP_LOCKED))
 -		spin_unlock_irqrestore(&ctx->completion_lock, flags);
 -	if (wake_ev)
 -		io_cqring_ev_posted(ctx);
 -}
 -
 -static struct io_kiocb *io_req_link_next(struct io_kiocb *req)
 +static void io_req_link_next(struct io_kiocb *req)
  {
  	struct io_kiocb *nxt;
  
* Unmerged path fs/io_uring.c
