usb: sysfs link peer ports

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [usb] sysfs link peer ports (Don Zickus) [1110939]
Rebuild_FUZZ: 89.36%
commit-author Dan Williams <dan.j.williams@intel.com>
commit b7e38eac88265c4cb779edc72a5906116fc6c000
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/b7e38eac.failed

The usb topology after this change will have symlinks between usb3 ports
and their usb2 peers, for example:

usb2/2-1/2-1:1.0/2-1-port1/peer => ../../../../usb3/3-1/3-1:1.0/3-1-port1
usb2/2-1/2-1:1.0/2-1-port2/peer => ../../../../usb3/3-1/3-1:1.0/3-1-port2
usb2/2-1/2-1:1.0/2-1-port3/peer => ../../../../usb3/3-1/3-1:1.0/3-1-port3
usb2/2-1/2-1:1.0/2-1-port4/peer => ../../../../usb3/3-1/3-1:1.0/3-1-port4
usb2/2-0:1.0/usb2-port1/peer    => ../../../usb3/3-0:1.0/usb3-port1
usb2/2-0:1.0/usb2-port2/peer    => ../../../usb3/3-0:1.0/usb3-port2
usb2/2-0:1.0/usb2-port3/peer    => ../../../usb3/3-0:1.0/usb3-port3
usb2/2-0:1.0/usb2-port4/peer    => ../../../usb3/3-0:1.0/usb3-port4

usb3/3-1/3-1:1.0/usb3-1-port1/peer => ../../../../usb2/2-1/2-1:1.0/2-1-port1
usb3/3-1/3-1:1.0/usb3-1-port2/peer => ../../../../usb2/2-1/2-1:1.0/2-1-port2
usb3/3-1/3-1:1.0/usb3-1-port3/peer => ../../../../usb2/2-1/2-1:1.0/2-1-port3
usb3/3-1/3-1:1.0/usb3-1-port4/peer => ../../../../usb2/2-1/2-1:1.0/2-1-port4
usb3/3-0:1.0/usb3-port1/peer       => ../../../usb2/2-0:1.0/usb2-port1
usb3/3-0:1.0/usb3-port2/peer       => ../../../usb2/2-0:1.0/usb2-port2
usb3/3-0:1.0/usb3-port3/peer       => ../../../usb2/2-0:1.0/usb2-port3
usb3/3-0:1.0/usb3-port4/peer       => ../../../usb2/2-0:1.0/usb2-port4

Introduce link_peers_report() to notify on all link_peers() failure
cases.

	Acked-by: Alan Stern <stern@rowland.harvard.edu>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit b7e38eac88265c4cb779edc72a5906116fc6c000)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/core/port.c
diff --cc drivers/usb/core/port.c
index 168fa6ee3348,40c3ac173e9e..000000000000
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@@ -152,9 -152,164 +152,167 @@@ struct device_type usb_port_device_typ
  	.pm =		&usb_port_pm_ops,
  };
  
++<<<<<<< HEAD
++=======
+ static struct device_driver usb_port_driver = {
+ 	.name = "usb",
+ 	.owner = THIS_MODULE,
+ };
+ 
+ static int link_peers(struct usb_port *left, struct usb_port *right)
+ {
+ 	int rc;
+ 
+ 	if (left->peer == right && right->peer == left)
+ 		return 0;
+ 
+ 	if (left->peer || right->peer) {
+ 		struct usb_port *lpeer = left->peer;
+ 		struct usb_port *rpeer = right->peer;
+ 
+ 		WARN(1, "failed to peer %s and %s (%s -> %p) (%s -> %p)\n",
+ 			dev_name(&left->dev), dev_name(&right->dev),
+ 			dev_name(&left->dev), lpeer,
+ 			dev_name(&right->dev), rpeer);
+ 		return -EBUSY;
+ 	}
+ 
+ 	rc = sysfs_create_link(&left->dev.kobj, &right->dev.kobj, "peer");
+ 	if (rc)
+ 		return rc;
+ 	rc = sysfs_create_link(&right->dev.kobj, &left->dev.kobj, "peer");
+ 	if (rc) {
+ 		sysfs_remove_link(&left->dev.kobj, "peer");
+ 		return rc;
+ 	}
+ 
+ 	left->peer = right;
+ 	right->peer = left;
+ 
+ 	return 0;
+ }
+ 
+ static void link_peers_report(struct usb_port *left, struct usb_port *right)
+ {
+ 	int rc;
+ 
+ 	rc = link_peers(left, right);
+ 	if (rc == 0) {
+ 		dev_dbg(&left->dev, "peered to %s\n", dev_name(&right->dev));
+ 	} else {
+ 		dev_warn(&left->dev, "failed to peer to %s (%d)\n",
+ 				dev_name(&right->dev), rc);
+ 		pr_warn_once("usb: port power management may be unreliable\n");
+ 	}
+ }
+ 
+ static void unlink_peers(struct usb_port *left, struct usb_port *right)
+ {
+ 	WARN(right->peer != left || left->peer != right,
+ 			"%s and %s are not peers?\n",
+ 			dev_name(&left->dev), dev_name(&right->dev));
+ 
+ 	sysfs_remove_link(&left->dev.kobj, "peer");
+ 	right->peer = NULL;
+ 	sysfs_remove_link(&right->dev.kobj, "peer");
+ 	left->peer = NULL;
+ }
+ 
+ /*
+  * For each usb hub device in the system check to see if it is in the
+  * peer domain of the given port_dev, and if it is check to see if it
+  * has a port that matches the given port by location
+  */
+ static int match_location(struct usb_device *peer_hdev, void *p)
+ {
+ 	int port1;
+ 	struct usb_hcd *hcd, *peer_hcd;
+ 	struct usb_port *port_dev = p, *peer;
+ 	struct usb_hub *peer_hub = usb_hub_to_struct_hub(peer_hdev);
+ 	struct usb_device *hdev = to_usb_device(port_dev->dev.parent->parent);
+ 
+ 	if (!peer_hub)
+ 		return 0;
+ 
+ 	hcd = bus_to_hcd(hdev->bus);
+ 	peer_hcd = bus_to_hcd(peer_hdev->bus);
+ 	/* peer_hcd is provisional until we verify it against the known peer */
+ 	if (peer_hcd != hcd->shared_hcd)
+ 		return 0;
+ 
+ 	for (port1 = 1; port1 <= peer_hdev->maxchild; port1++) {
+ 		peer = peer_hub->ports[port1 - 1];
+ 		if (peer && peer->location == port_dev->location) {
+ 			link_peers_report(port_dev, peer);
+ 			return 1; /* done */
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Find the peer port either via explicit platform firmware "location"
+  * data, the peer hcd for root hubs, or the upstream peer relationship
+  * for all other hubs.
+  */
+ static void find_and_link_peer(struct usb_hub *hub, int port1)
+ {
+ 	struct usb_port *port_dev = hub->ports[port1 - 1], *peer;
+ 	struct usb_device *hdev = hub->hdev;
+ 	struct usb_device *peer_hdev;
+ 	struct usb_hub *peer_hub;
+ 
+ 	/*
+ 	 * If location data is available then we can only peer this port
+ 	 * by a location match, not the default peer (lest we create a
+ 	 * situation where we need to go back and undo a default peering
+ 	 * when the port is later peered by location data)
+ 	 */
+ 	if (port_dev->location) {
+ 		/* we link the peer in match_location() if found */
+ 		usb_for_each_dev(port_dev, match_location);
+ 		return;
+ 	} else if (!hdev->parent) {
+ 		struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
+ 		struct usb_hcd *peer_hcd = hcd->shared_hcd;
+ 
+ 		if (!peer_hcd)
+ 			return;
+ 
+ 		peer_hdev = peer_hcd->self.root_hub;
+ 	} else {
+ 		struct usb_port *upstream;
+ 		struct usb_device *parent = hdev->parent;
+ 		struct usb_hub *parent_hub = usb_hub_to_struct_hub(parent);
+ 
+ 		if (!parent_hub)
+ 			return;
+ 
+ 		upstream = parent_hub->ports[hdev->portnum - 1];
+ 		if (!upstream || !upstream->peer)
+ 			return;
+ 
+ 		peer_hdev = upstream->peer->child;
+ 	}
+ 
+ 	peer_hub = usb_hub_to_struct_hub(peer_hdev);
+ 	if (!peer_hub || port1 > peer_hdev->maxchild)
+ 		return;
+ 
+ 	/*
+ 	 * we found a valid default peer, last check is to make sure it
+ 	 * does not have location data
+ 	 */
+ 	peer = peer_hub->ports[port1 - 1];
+ 	if (peer && peer->location == 0)
+ 		link_peers_report(port_dev, peer);
+ }
+ 
++>>>>>>> b7e38eac8826 (usb: sysfs link peer ports)
  int usb_hub_create_port_device(struct usb_hub *hub, int port1)
  {
 -	struct usb_port *port_dev;
 +	struct usb_port *port_dev = NULL;
  	int retval;
  
  	port_dev = kzalloc(sizeof(*port_dev), GFP_KERNEL);
* Unmerged path drivers/usb/core/port.c
