wait: add wait_event_cmd()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Shaohua Li <shli@kernel.org>
commit 82e06c811163c4d853ed335d56c3378088bc89cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/82e06c81.failed

Add a new API wait_event_cmd(). It's a variant of wait_even() with two
commands executed. One is executed before sleep, another after sleep.

Modified to match use wait.h approach based on suggestion by
Peter Zijlstra <peterz@infradead.org> - neilb

	Signed-off-by: Shaohua Li <shli@fusionio.com>
	Signed-off-by: NeilBrown <neilb@suse.de>
(cherry picked from commit 82e06c811163c4d853ed335d56c3378088bc89cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/wait.h
diff --cc include/linux/wait.h
index c8e576022234,eaa00b10abaa..000000000000
--- a/include/linux/wait.h
+++ b/include/linux/wait.h
@@@ -247,23 -278,34 +247,54 @@@ do {									
  	__ret;								\
  })
  
++<<<<<<< HEAD
 +#define __wait_event_interruptible(wq, condition, ret)			\
 +do {									\
 +	DEFINE_WAIT(__wait);						\
 +									\
 +	for (;;) {							\
 +		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
 +		if (condition)						\
 +			break;						\
 +		if (!signal_pending(current)) {				\
 +			schedule();					\
 +			continue;					\
 +		}							\
 +		ret = -ERESTARTSYS;					\
 +		break;							\
 +	}								\
 +	finish_wait(&wq, &__wait);					\
 +} while (0)
++=======
+ #define __wait_event_cmd(wq, condition, cmd1, cmd2)			\
+ 	(void)___wait_event(wq, condition, TASK_UNINTERRUPTIBLE, 0, 0,	\
+ 			    cmd1; schedule(); cmd2)
+ 
+ /**
+  * wait_event_cmd - sleep until a condition gets true
+  * @wq: the waitqueue to wait on
+  * @condition: a C expression for the event to wait for
+  * cmd1: the command will be executed before sleep
+  * cmd2: the command will be executed after sleep
+  *
+  * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
+  * @condition evaluates to true. The @condition is checked each time
+  * the waitqueue @wq is woken up.
+  *
+  * wake_up() has to be called after changing any variable that could
+  * change the result of the wait condition.
+  */
+ #define wait_event_cmd(wq, condition, cmd1, cmd2)			\
+ do {									\
+ 	if (condition)							\
+ 		break;							\
+ 	__wait_event_cmd(wq, condition, cmd1, cmd2);			\
+ } while (0)
+ 
+ #define __wait_event_interruptible(wq, condition)			\
+ 	___wait_event(wq, condition, TASK_INTERRUPTIBLE, 0, 0,		\
+ 		      schedule())
++>>>>>>> 82e06c811163 (wait: add wait_event_cmd())
  
  /**
   * wait_event_interruptible - sleep until a condition gets true
* Unmerged path include/linux/wait.h
