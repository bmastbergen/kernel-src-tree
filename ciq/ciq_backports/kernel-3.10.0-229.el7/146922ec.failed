iommu/vt-d: Make get_domain_for_dev() take struct device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Make get_domain_for_dev() take struct device (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 94.34%
commit-author David Woodhouse <David.Woodhouse@intel.com>
commit 146922ec798de6484897a43fc6180e49c425f183
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/146922ec.failed

	Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
(cherry picked from commit 146922ec798de6484897a43fc6180e49c425f183)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 144c54a1b81e,1c5f656ff19d..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -2079,49 -2207,52 +2079,72 @@@ static int dmar_insert_dev_info(int seg
  }
  
  /* domain is initialized */
- static struct dmar_domain *get_domain_for_dev(struct pci_dev *pdev, int gaw)
+ static struct dmar_domain *get_domain_for_dev(struct device *dev, int gaw)
  {
  	struct dmar_domain *domain, *free = NULL;
++<<<<<<< HEAD
 +	struct intel_iommu *iommu;
 +	struct dmar_drhd_unit *drhd;
 +	struct pci_dev *dev_tmp;
++=======
+ 	struct intel_iommu *iommu = NULL;
+ 	struct device_domain_info *info;
+ 	struct pci_dev *dev_tmp = NULL;
++>>>>>>> 146922ec798d (iommu/vt-d: Make get_domain_for_dev() take struct device)
  	unsigned long flags;
- 	int bus = 0, devfn = 0;
- 	int segment;
+ 	u8 bus, devfn, bridge_bus, bridge_devfn;
  
- 	domain = find_domain(&pdev->dev);
+ 	domain = find_domain(dev);
  	if (domain)
  		return domain;
  
- 	segment = pci_domain_nr(pdev->bus);
+ 	if (dev_is_pci(dev)) {
+ 		struct pci_dev *pdev = to_pci_dev(dev);
+ 		u16 segment;
  
- 	dev_tmp = pci_find_upstream_pcie_bridge(pdev);
- 	if (dev_tmp) {
- 		if (pci_is_pcie(dev_tmp)) {
- 			bus = dev_tmp->subordinate->number;
- 			devfn = 0;
- 		} else {
- 			bus = dev_tmp->bus->number;
- 			devfn = dev_tmp->devfn;
+ 		segment = pci_domain_nr(pdev->bus);
+ 		dev_tmp = pci_find_upstream_pcie_bridge(pdev);
+ 		if (dev_tmp) {
+ 			if (pci_is_pcie(dev_tmp)) {
+ 				bridge_bus = dev_tmp->subordinate->number;
+ 				bridge_devfn = 0;
+ 			} else {
+ 				bridge_bus = dev_tmp->bus->number;
+ 				bridge_devfn = dev_tmp->devfn;
+ 			}
+ 			spin_lock_irqsave(&device_domain_lock, flags);
+ 			info = dmar_search_domain_by_dev_info(segment, bus, devfn);
+ 			if (info) {
+ 				iommu = info->iommu;
+ 				domain = info->domain;
+ 			}
+ 			spin_unlock_irqrestore(&device_domain_lock, flags);
+ 			/* pcie-pci bridge already has a domain, uses it */
+ 			if (info)
+ 				goto found_domain;
  		}
++<<<<<<< HEAD
 +		spin_lock_irqsave(&device_domain_lock, flags);
 +		domain = dmar_search_domain_by_dev_info(segment, bus, devfn);
 +		spin_unlock_irqrestore(&device_domain_lock, flags);
 +		/* pcie-pci bridge already has a domain, uses it */
 +		if (domain)
 +			goto found_domain;
++=======
++>>>>>>> 146922ec798d (iommu/vt-d: Make get_domain_for_dev() take struct device)
  	}
  
- 	drhd = dmar_find_matched_drhd_unit(pdev);
- 	if (!drhd) {
- 		printk(KERN_ERR "IOMMU: can't find DMAR for device %s\n",
- 			pci_name(pdev));
- 		return NULL;
- 	}
- 	iommu = drhd->iommu;
+ 	iommu = device_to_iommu(dev, &bus, &devfn);
+ 	if (!iommu)
+ 		goto error;
  
++<<<<<<< HEAD
 +	/* Allocate and intialize new domain for the device */
 +	domain = alloc_domain();
++=======
+ 	/* Allocate and initialize new domain for the device */
+ 	domain = alloc_domain(false);
++>>>>>>> 146922ec798d (iommu/vt-d: Make get_domain_for_dev() take struct device)
  	if (!domain)
  		goto error;
  	if (iommu_attach_domain(domain, iommu)) {
@@@ -2134,21 -2265,19 +2157,31 @@@
  
  	/* register pcie-to-pci device */
  	if (dev_tmp) {
++<<<<<<< HEAD
 +		if (dmar_insert_dev_info(segment, bus, devfn, NULL, &domain))
++=======
+ 		domain = dmar_insert_dev_info(iommu, bridge_bus, bridge_devfn,
+ 					      NULL, domain);
+ 		if (!domain)
++>>>>>>> 146922ec798d (iommu/vt-d: Make get_domain_for_dev() take struct device)
  			goto error;
 +		else
 +			free = NULL;
  	}
  
  found_domain:
++<<<<<<< HEAD
 +	if (dmar_insert_dev_info(segment, pdev->bus->number, pdev->devfn,
 +				 pdev, &domain) == 0)
 +		return domain;
++=======
+ 	domain = dmar_insert_dev_info(iommu, bus, devfn, dev, domain);
++>>>>>>> 146922ec798d (iommu/vt-d: Make get_domain_for_dev() take struct device)
  error:
 -	if (free != domain)
 +	if (free)
  		domain_exit(free);
 -
 -	return domain;
 +	/* recheck it here, maybe others set it */
 +	return find_domain(&pdev->dev);
  }
  
  static int iommu_identity_mapping;
* Unmerged path drivers/iommu/intel-iommu.c
