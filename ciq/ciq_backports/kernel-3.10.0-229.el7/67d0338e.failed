nfs: page group syncing in read path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Weston Andros Adamson <dros@primarydata.com>
commit 67d0338edd71db9a4f406d8778f7c525d31e9f7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/67d0338e.failed

Operations that modify state for a whole page must be syncronized across
all requests within a page group. In the read path, this is calling
unlock_page and SetPageUptodate. Both of these functions should not be
called until all requests in a page group have reached the point where
they would call them.

This patch should have no effect yet since all page groups currently
have one request, but will come into play when pg_test functions are
modified to split pages into sub-page regions.

	Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 67d0338edd71db9a4f406d8778f7c525d31e9f7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pagelist.c
#	include/linux/nfs_page.h
diff --cc fs/nfs/pagelist.c
index ac4fb6420265,18ee4e99347e..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -242,9 -389,14 +242,18 @@@ static void nfs_clear_request(struct nf
   *
   * Note: Should never be called with the spinlock held!
   */
 -static void nfs_free_request(struct nfs_page *req)
 +static void nfs_free_request(struct kref *kref)
  {
++<<<<<<< HEAD
 +	struct nfs_page *req = container_of(kref, struct nfs_page, wb_kref);
++=======
+ 	WARN_ON_ONCE(req->wb_this_page != req);
+ 
+ 	/* extra debug: make sure no sync bits are still set */
+ 	WARN_ON_ONCE(test_bit(PG_TEARDOWN, &req->wb_flags));
+ 	WARN_ON_ONCE(test_bit(PG_UNLOCKPAGE, &req->wb_flags));
+ 	WARN_ON_ONCE(test_bit(PG_UPTODATE, &req->wb_flags));
++>>>>>>> 67d0338edd71 (nfs: page group syncing in read path)
  
  	/* Release struct file and open context */
  	nfs_clear_request(req);
diff --cc include/linux/nfs_page.h
index 214e09851870,6385175a127b..000000000000
--- a/include/linux/nfs_page.h
+++ b/include/linux/nfs_page.h
@@@ -26,6 -26,11 +26,14 @@@ enum 
  	PG_MAPPED,		/* page private set for buffered io */
  	PG_CLEAN,		/* write succeeded */
  	PG_COMMIT_TO_DS,	/* used by pnfs layouts */
++<<<<<<< HEAD
++=======
+ 	PG_INODE_REF,		/* extra ref held by inode (head req only) */
+ 	PG_HEADLOCK,		/* page group lock of wb_head */
+ 	PG_TEARDOWN,		/* page group sync for destroy */
+ 	PG_UNLOCKPAGE,		/* page group sync bit in read path */
+ 	PG_UPTODATE,		/* page group sync bit in read path */
++>>>>>>> 67d0338edd71 (nfs: page group syncing in read path)
  };
  
  struct nfs_inode;
* Unmerged path fs/nfs/pagelist.c
diff --git a/fs/nfs/read.c b/fs/nfs/read.c
index d58a7ae6152b..7494cbda3ffd 100644
--- a/fs/nfs/read.c
+++ b/fs/nfs/read.c
@@ -166,10 +166,16 @@ static void nfs_readpage_release(struct nfs_page *req)
 {
 	struct inode *d_inode = req->wb_context->dentry->d_inode;
 
-	if (PageUptodate(req->wb_page))
-		nfs_readpage_to_fscache(d_inode, req->wb_page, 0);
+	dprintk("NFS: read done (%s/%llu %d@%lld)\n", d_inode->i_sb->s_id,
+		(unsigned long long)NFS_FILEID(d_inode), req->wb_bytes,
+		(long long)req_offset(req));
 
-	unlock_page(req->wb_page);
+	if (nfs_page_group_sync_on_bit(req, PG_UNLOCKPAGE)) {
+		if (PageUptodate(req->wb_page))
+			nfs_readpage_to_fscache(d_inode, req->wb_page, 0);
+
+		unlock_page(req->wb_page);
+	}
 
 	dprintk("NFS: read done (%s/%Lu %d@%Ld)\n",
 			req->wb_context->dentry->d_inode->i_sb->s_id,
@@ -179,6 +185,12 @@ static void nfs_readpage_release(struct nfs_page *req)
 	nfs_release_request(req);
 }
 
+static void nfs_page_group_set_uptodate(struct nfs_page *req)
+{
+	if (nfs_page_group_sync_on_bit(req, PG_UPTODATE))
+		SetPageUptodate(req->wb_page);
+}
+
 /* Note io was page aligned */
 static void nfs_read_completion(struct nfs_pgio_header *hdr)
 {
@@ -201,9 +213,9 @@ static void nfs_read_completion(struct nfs_pgio_header *hdr)
 		bytes += req->wb_bytes;
 		if (test_bit(NFS_IOHDR_ERROR, &hdr->flags)) {
 			if (bytes <= hdr->good_bytes)
-				SetPageUptodate(page);
+				nfs_page_group_set_uptodate(req);
 		} else
-			SetPageUptodate(page);
+			nfs_page_group_set_uptodate(req);
 		nfs_list_remove_request(req);
 		nfs_readpage_release(req);
 	}
* Unmerged path include/linux/nfs_page.h
