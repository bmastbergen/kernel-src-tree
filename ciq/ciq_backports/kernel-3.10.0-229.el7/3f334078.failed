net: make tcp_cleanup_rbuf private

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] tcp: make tcp_cleanup_rbuf private (Jiri Benc) [1173444]
Rebuild_FUZZ: 94.12%
commit-author Dan Williams <dan.j.williams@intel.com>
commit 3f334078567245429540e6461c81c749fce87f70
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3f334078.failed

net_dma was the only external user so this can become local to tcp.c
again.

	Cc: James Morris <jmorris@namei.org>
	Cc: Patrick McHardy <kaber@trash.net>
	Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
	Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Acked-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit 3f334078567245429540e6461c81c749fce87f70)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tcp.h
diff --cc include/net/tcp.h
index 66c0e9e62cd5,7ffbcbf90a64..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -354,38 -347,35 +354,61 @@@ extern struct proto tcp_prot
  #define TCP_ADD_STATS_USER(net, field, val) SNMP_ADD_STATS_USER((net)->mib.tcp_statistics, field, val)
  #define TCP_ADD_STATS(net, field, val)	SNMP_ADD_STATS((net)->mib.tcp_statistics, field, val)
  
 -void tcp_tasklet_init(void);
 -
 -void tcp_v4_err(struct sk_buff *skb, u32);
 -
 -void tcp_shutdown(struct sock *sk, int how);
 -
 -void tcp_v4_early_demux(struct sk_buff *skb);
 -int tcp_v4_rcv(struct sk_buff *skb);
 -
 +extern void tcp_init_mem(struct net *net);
 +
 +extern void tcp_tasklet_init(void);
 +
 +extern void tcp_v4_err(struct sk_buff *skb, u32);
 +
 +extern void tcp_shutdown (struct sock *sk, int how);
 +
++<<<<<<< HEAD
 +extern void tcp_v4_early_demux(struct sk_buff *skb);
 +extern int tcp_v4_rcv(struct sk_buff *skb);
 +
 +extern int tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);
 +extern int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 +		       size_t size);
 +extern int tcp_sendpage(struct sock *sk, struct page *page, int offset,
 +			size_t size, int flags);
 +extern void tcp_release_cb(struct sock *sk);
 +extern void tcp_wfree(struct sk_buff *skb);
 +extern void tcp_write_timer_handler(struct sock *sk);
 +extern void tcp_delack_timer_handler(struct sock *sk);
 +extern int tcp_ioctl(struct sock *sk, int cmd, unsigned long arg);
 +extern int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 +				 const struct tcphdr *th, unsigned int len);
 +extern int tcp_rcv_established(struct sock *sk, struct sk_buff *skb,
 +			       const struct tcphdr *th, unsigned int len);
 +extern void tcp_rcv_space_adjust(struct sock *sk);
 +extern void tcp_cleanup_rbuf(struct sock *sk, int copied);
 +extern int tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp);
 +extern void tcp_twsk_destructor(struct sock *sk);
 +extern ssize_t tcp_splice_read(struct socket *sk, loff_t *ppos,
 +			       struct pipe_inode_info *pipe, size_t len,
 +			       unsigned int flags);
++=======
+ int tcp_v4_tw_remember_stamp(struct inet_timewait_sock *tw);
+ int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+ 		size_t size);
+ int tcp_sendpage(struct sock *sk, struct page *page, int offset, size_t size,
+ 		 int flags);
+ void tcp_release_cb(struct sock *sk);
+ void tcp_wfree(struct sk_buff *skb);
+ void tcp_write_timer_handler(struct sock *sk);
+ void tcp_delack_timer_handler(struct sock *sk);
+ int tcp_ioctl(struct sock *sk, int cmd, unsigned long arg);
+ int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
+ 			  const struct tcphdr *th, unsigned int len);
+ void tcp_rcv_established(struct sock *sk, struct sk_buff *skb,
+ 			 const struct tcphdr *th, unsigned int len);
+ void tcp_rcv_space_adjust(struct sock *sk);
+ int tcp_twsk_unique(struct sock *sk, struct sock *sktw, void *twp);
+ void tcp_twsk_destructor(struct sock *sk);
+ ssize_t tcp_splice_read(struct socket *sk, loff_t *ppos,
+ 			struct pipe_inode_info *pipe, size_t len,
+ 			unsigned int flags);
++>>>>>>> 3f3340785672 (net: make tcp_cleanup_rbuf private)
  
  static inline void tcp_dec_quickack_mode(struct sock *sk,
  					 const unsigned int pkts)
* Unmerged path include/net/tcp.h
diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c
index 492ea4ab2ee2..99fa7e2c9c9c 100644
--- a/net/ipv4/tcp.c
+++ b/net/ipv4/tcp.c
@@ -1333,7 +1333,7 @@ static int tcp_peek_sndq(struct sock *sk, struct msghdr *msg, int len)
  * calculation of whether or not we must ACK for the sake of
  * a window update.
  */
-void tcp_cleanup_rbuf(struct sock *sk, int copied)
+static void tcp_cleanup_rbuf(struct sock *sk, int copied)
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 	bool time_to_ack = false;
