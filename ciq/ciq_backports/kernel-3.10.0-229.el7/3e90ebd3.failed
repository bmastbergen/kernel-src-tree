netfilter: ip_set: rename nfnl_dereference()/nfnl_set()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Patrick McHardy <kaber@trash.net>
commit 3e90ebd3c920e335e155e5d3a794197897630f99
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3e90ebd3.failed

The next patch will introduce a nfnl_dereference() macro that actually
checks that the appropriate mutex is held and therefore needs a
subsystem argument.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 3e90ebd3c920e335e155e5d3a794197897630f99)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/ipset/ip_set_core.c
diff --cc net/netfilter/ipset/ip_set_core.c
index f77139007983,728a2cf188f4..000000000000
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@@ -43,10 -54,10 +43,15 @@@ MODULE_DESCRIPTION("core IP set support
  MODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_IPSET);
  
  /* When the nfnl mutex is held: */
- #define nfnl_dereference(p)		\
+ #define ip_set_dereference(p)		\
  	rcu_dereference_protected(p, 1)
++<<<<<<< HEAD
 +#define nfnl_set(id)			\
 +	nfnl_dereference(ip_set_list)[id]
++=======
+ #define ip_set(inst, id)		\
+ 	ip_set_dereference((inst)->ip_set_list)[id]
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  
  /*
   * The set types are implemented in modules and registered set types
@@@ -581,7 -640,7 +586,11 @@@ ip_set_nfnl_get_byindex(ip_set_id_t ind
  		return IPSET_INVALID_ID;
  
  	nfnl_lock(NFNL_SUBSYS_IPSET);
++<<<<<<< HEAD
 +	set = nfnl_set(index);
++=======
+ 	set = ip_set(inst, index);
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  	if (set)
  		__ip_set_get(set);
  	else
@@@ -600,13 -659,17 +609,21 @@@ EXPORT_SYMBOL_GPL(ip_set_nfnl_get_byind
   * The nfnl mutex is used in the function.
   */
  void
 -ip_set_nfnl_put(struct net *net, ip_set_id_t index)
 +ip_set_nfnl_put(ip_set_id_t index)
  {
  	struct ip_set *set;
 -	struct ip_set_net *inst = ip_set_pernet(net);
 -
  	nfnl_lock(NFNL_SUBSYS_IPSET);
++<<<<<<< HEAD
 +	set = nfnl_set(index);
 +	if (set != NULL)
 +		__ip_set_put(set);
++=======
+ 	if (!inst->is_deleted) { /* already deleted from ip_set_net_exit() */
+ 		set = ip_set(inst, index);
+ 		if (set != NULL)
+ 			__ip_set_put(set);
+ 	}
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  	nfnl_unlock(NFNL_SUBSYS_IPSET);
  }
  EXPORT_SYMBOL_GPL(ip_set_nfnl_put);
@@@ -670,8 -733,8 +687,13 @@@ find_set_and_id(const char *name, ip_se
  	ip_set_id_t i;
  
  	*id = IPSET_INVALID_ID;
++<<<<<<< HEAD
 +	for (i = 0; i < ip_set_max; i++) {
 +		set = nfnl_set(i);
++=======
+ 	for (i = 0; i < inst->ip_set_max; i++) {
+ 		set = ip_set(inst, i);
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  		if (set != NULL && STREQ(set->name, name)) {
  			*id = i;
  			break;
@@@ -695,8 -759,8 +717,13 @@@ find_free_id(const char *name, ip_set_i
  	ip_set_id_t i;
  
  	*index = IPSET_INVALID_ID;
++<<<<<<< HEAD
 +	for (i = 0;  i < ip_set_max; i++) {
 +		s = nfnl_set(i);
++=======
+ 	for (i = 0;  i < inst->ip_set_max; i++) {
+ 		s = ip_set(inst, i);
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  		if (s == NULL) {
  			if (*index == IPSET_INVALID_ID)
  				*index = i;
@@@ -817,9 -883,9 +844,15 @@@ ip_set_create(struct sock *ctnl, struc
  		if (!list)
  			goto cleanup;
  		/* nfnl mutex is held, both lists are valid */
++<<<<<<< HEAD
 +		tmp = nfnl_dereference(ip_set_list);
 +		memcpy(list, tmp, sizeof(struct ip_set *) * ip_set_max);
 +		rcu_assign_pointer(ip_set_list, list);
++=======
+ 		tmp = ip_set_dereference(inst->ip_set_list);
+ 		memcpy(list, tmp, sizeof(struct ip_set *) * inst->ip_set_max);
+ 		rcu_assign_pointer(inst->ip_set_list, list);
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  		/* Make sure all current packets have passed through */
  		synchronize_net();
  		/* Use new list */
@@@ -834,7 -900,7 +867,11 @@@
  	 * Finally! Add our shiny new set to the list, and be done.
  	 */
  	pr_debug("create: '%s' created with index %u!\n", set->name, index);
++<<<<<<< HEAD
 +	nfnl_set(index) = set;
++=======
+ 	ip_set(inst, index) = set;
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  
  	return ret;
  
@@@ -857,12 -923,12 +894,19 @@@ ip_set_setname_policy[IPSET_ATTR_CMD_MA
  };
  
  static void
 -ip_set_destroy_set(struct ip_set_net *inst, ip_set_id_t index)
 +ip_set_destroy_set(ip_set_id_t index)
  {
++<<<<<<< HEAD
 +	struct ip_set *set = nfnl_set(index);
 +
 +	pr_debug("set: %s\n",  set->name);
 +	nfnl_set(index) = NULL;
++=======
+ 	struct ip_set *set = ip_set(inst, index);
+ 
+ 	pr_debug("set: %s\n",  set->name);
+ 	ip_set(inst, index) = NULL;
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  
  	/* Must call it without holding any lock */
  	set->variant->destroy(set);
@@@ -894,21 -961,22 +938,31 @@@ ip_set_destroy(struct sock *ctnl, struc
  	 */
  	read_lock_bh(&ip_set_ref_lock);
  	if (!attr[IPSET_ATTR_SETNAME]) {
++<<<<<<< HEAD
 +		for (i = 0; i < ip_set_max; i++) {
 +			s = nfnl_set(i);
++=======
+ 		for (i = 0; i < inst->ip_set_max; i++) {
+ 			s = ip_set(inst, i);
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  			if (s != NULL && s->ref) {
  				ret = -IPSET_ERR_BUSY;
  				goto out;
  			}
  		}
  		read_unlock_bh(&ip_set_ref_lock);
++<<<<<<< HEAD
 +		for (i = 0; i < ip_set_max; i++) {
 +			s = nfnl_set(i);
++=======
+ 		for (i = 0; i < inst->ip_set_max; i++) {
+ 			s = ip_set(inst, i);
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  			if (s != NULL)
 -				ip_set_destroy_set(inst, i);
 +				ip_set_destroy_set(i);
  		}
  	} else {
 -		s = find_set_and_id(inst, nla_data(attr[IPSET_ATTR_SETNAME]),
 -				    &i);
 +		s = find_set_and_id(nla_data(attr[IPSET_ATTR_SETNAME]), &i);
  		if (s == NULL) {
  			ret = -ENOENT;
  			goto out;
@@@ -950,8 -1019,8 +1004,13 @@@ ip_set_flush(struct sock *ctnl, struct 
  		return -IPSET_ERR_PROTOCOL;
  
  	if (!attr[IPSET_ATTR_SETNAME]) {
++<<<<<<< HEAD
 +		for (i = 0; i < ip_set_max; i++) {
 +			s = nfnl_set(i);
++=======
+ 		for (i = 0; i < inst->ip_set_max; i++) {
+ 			s = ip_set(inst, i);
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  			if (s != NULL)
  				ip_set_flush_set(s);
  		}
@@@ -1003,8 -1073,8 +1062,13 @@@ ip_set_rename(struct sock *ctnl, struc
  	}
  
  	name2 = nla_data(attr[IPSET_ATTR_SETNAME2]);
++<<<<<<< HEAD
 +	for (i = 0; i < ip_set_max; i++) {
 +		s = nfnl_set(i);
++=======
+ 	for (i = 0; i < inst->ip_set_max; i++) {
+ 		s = ip_set(inst, i);
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  		if (s != NULL && STREQ(s->name, name2)) {
  			ret = -IPSET_ERR_EXIST_SETNAME2;
  			goto out;
@@@ -1061,8 -1134,8 +1125,13 @@@ ip_set_swap(struct sock *ctnl, struct s
  
  	write_lock_bh(&ip_set_ref_lock);
  	swap(from->ref, to->ref);
++<<<<<<< HEAD
 +	nfnl_set(from_id) = to;
 +	nfnl_set(to_id) = from;
++=======
+ 	ip_set(inst, from_id) = to;
+ 	ip_set(inst, to_id) = from;
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  	write_unlock_bh(&ip_set_ref_lock);
  
  	return 0;
@@@ -1081,9 -1154,12 +1150,18 @@@
  static int
  ip_set_dump_done(struct netlink_callback *cb)
  {
++<<<<<<< HEAD
 +	if (cb->args[2]) {
 +		pr_debug("release set %s\n", nfnl_set(cb->args[1])->name);
 +		ip_set_put_byindex((ip_set_id_t) cb->args[1]);
++=======
+ 	struct ip_set_net *inst = (struct ip_set_net *)cb->args[IPSET_CB_NET];
+ 	if (cb->args[IPSET_CB_ARG0]) {
+ 		pr_debug("release set %s\n",
+ 			 ip_set(inst, cb->args[IPSET_CB_INDEX])->name);
+ 		__ip_set_put_byindex(inst,
+ 			(ip_set_id_t) cb->args[IPSET_CB_INDEX]);
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  	}
  	return 0;
  }
@@@ -1163,18 -1242,19 +1241,26 @@@ ip_set_dump_start(struct sk_buff *skb, 
  		}
  	}
  
 -	if (cb->args[IPSET_CB_INDEX] >= inst->ip_set_max)
 +	if (cb->args[1] >= ip_set_max)
  		goto out;
  
 -	dump_type = DUMP_TYPE(cb->args[IPSET_CB_DUMP]);
 -	dump_flags = DUMP_FLAGS(cb->args[IPSET_CB_DUMP]);
 -	max = dump_type == DUMP_ONE ? cb->args[IPSET_CB_INDEX] + 1
 -				    : inst->ip_set_max;
 +	dump_type = DUMP_TYPE(cb->args[0]);
 +	dump_flags = DUMP_FLAGS(cb->args[0]);
 +	max = dump_type == DUMP_ONE ? cb->args[1] + 1 : ip_set_max;
  dump_last:
++<<<<<<< HEAD
 +	pr_debug("args[0]: %u %u args[1]: %ld\n",
 +		 dump_type, dump_flags, cb->args[1]);
 +	for (; cb->args[1] < max; cb->args[1]++) {
 +		index = (ip_set_id_t) cb->args[1];
 +		set = nfnl_set(index);
++=======
+ 	pr_debug("dump type, flag: %u %u index: %ld\n",
+ 		 dump_type, dump_flags, cb->args[IPSET_CB_INDEX]);
+ 	for (; cb->args[IPSET_CB_INDEX] < max; cb->args[IPSET_CB_INDEX]++) {
+ 		index = (ip_set_id_t) cb->args[IPSET_CB_INDEX];
+ 		set = ip_set(inst, index);
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  		if (set == NULL) {
  			if (dump_type == DUMP_ONE) {
  				ret = -ENOENT;
@@@ -1246,15 -1326,15 +1332,22 @@@ nla_put_failure
  	ret = -EFAULT;
  next_set:
  	if (dump_type == DUMP_ONE)
 -		cb->args[IPSET_CB_INDEX] = IPSET_INVALID_ID;
 +		cb->args[1] = IPSET_INVALID_ID;
  	else
 -		cb->args[IPSET_CB_INDEX]++;
 +		cb->args[1]++;
  release_refcount:
  	/* If there was an error or set is done, release set */
++<<<<<<< HEAD
 +	if (ret || !cb->args[2]) {
 +		pr_debug("release set %s\n", nfnl_set(index)->name);
 +		ip_set_put_byindex(index);
 +		cb->args[2] = 0;
++=======
+ 	if (ret || !cb->args[IPSET_CB_ARG0]) {
+ 		pr_debug("release set %s\n", ip_set(inst, index)->name);
+ 		__ip_set_put_byindex(inst, index);
+ 		cb->args[IPSET_CB_ARG0] = 0;
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  	}
  out:
  	if (nlh) {
@@@ -1789,6 -1874,23 +1882,26 @@@ ip_set_sockfn_get(struct sock *sk, int 
  		nfnl_unlock(NFNL_SUBSYS_IPSET);
  		goto copy;
  	}
++<<<<<<< HEAD
++=======
+ 	case IP_SET_OP_GET_FNAME: {
+ 		struct ip_set_req_get_set_family *req_get = data;
+ 		ip_set_id_t id;
+ 
+ 		if (*len != sizeof(struct ip_set_req_get_set_family)) {
+ 			ret = -EINVAL;
+ 			goto done;
+ 		}
+ 		req_get->set.name[IPSET_MAXNAMELEN - 1] = '\0';
+ 		nfnl_lock(NFNL_SUBSYS_IPSET);
+ 		find_set_and_id(inst, req_get->set.name, &id);
+ 		req_get->set.index = id;
+ 		if (id != IPSET_INVALID_ID)
+ 			req_get->family = ip_set(inst, id)->family;
+ 		nfnl_unlock(NFNL_SUBSYS_IPSET);
+ 		goto copy;
+ 	}
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  	case IP_SET_OP_GET_BYINDEX: {
  		struct ip_set_req_get_set *req_get = data;
  		struct ip_set *set;
@@@ -1799,7 -1901,7 +1912,11 @@@
  			goto done;
  		}
  		nfnl_lock(NFNL_SUBSYS_IPSET);
++<<<<<<< HEAD
 +		set = nfnl_set(req_get->set.index);
++=======
+ 		set = ip_set(inst, req_get->set.index);
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  		strncpy(req_get->set.name, set ? set->name : "",
  			IPSET_MAXNAMELEN);
  		nfnl_unlock(NFNL_SUBSYS_IPSET);
@@@ -1828,6 -1930,51 +1945,54 @@@ static struct nf_sockopt_ops so_set __r
  	.owner		= THIS_MODULE,
  };
  
++<<<<<<< HEAD
++=======
+ static int __net_init
+ ip_set_net_init(struct net *net)
+ {
+ 	struct ip_set_net *inst = ip_set_pernet(net);
+ 	struct ip_set **list;
+ 
+ 	inst->ip_set_max = max_sets ? max_sets : CONFIG_IP_SET_MAX;
+ 	if (inst->ip_set_max >= IPSET_INVALID_ID)
+ 		inst->ip_set_max = IPSET_INVALID_ID - 1;
+ 
+ 	list = kzalloc(sizeof(struct ip_set *) * inst->ip_set_max, GFP_KERNEL);
+ 	if (!list)
+ 		return -ENOMEM;
+ 	inst->is_deleted = 0;
+ 	rcu_assign_pointer(inst->ip_set_list, list);
+ 	pr_notice("ip_set: protocol %u\n", IPSET_PROTOCOL);
+ 	return 0;
+ }
+ 
+ static void __net_exit
+ ip_set_net_exit(struct net *net)
+ {
+ 	struct ip_set_net *inst = ip_set_pernet(net);
+ 
+ 	struct ip_set *set = NULL;
+ 	ip_set_id_t i;
+ 
+ 	inst->is_deleted = 1; /* flag for ip_set_nfnl_put */
+ 
+ 	for (i = 0; i < inst->ip_set_max; i++) {
+ 		set = ip_set(inst, i);
+ 		if (set != NULL)
+ 			ip_set_destroy_set(inst, i);
+ 	}
+ 	kfree(rcu_dereference_protected(inst->ip_set_list, 1));
+ }
+ 
+ static struct pernet_operations ip_set_net_ops = {
+ 	.init	= ip_set_net_init,
+ 	.exit   = ip_set_net_exit,
+ 	.id	= &ip_set_net_id,
+ 	.size	= sizeof(struct ip_set_net)
+ };
+ 
+ 
++>>>>>>> 3e90ebd3c920 (netfilter: ip_set: rename nfnl_dereference()/nfnl_set())
  static int __init
  ip_set_init(void)
  {
* Unmerged path net/netfilter/ipset/ip_set_core.c
