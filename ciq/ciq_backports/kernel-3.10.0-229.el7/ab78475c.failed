KVM: PPC: Book3S: ifdef on CONFIG_KVM_BOOK3S_32_HANDLER for 32bit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/ppc: book3s - ifdef on CONFIG_KVM_book3s_32_HANDLER for 32bit (David Gibson) [1123145 1123133 1123367]
Rebuild_FUZZ: 95.38%
commit-author Alexander Graf <agraf@suse.de>
commit ab78475c76bd8c54375d8a778200c59314973d30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/ab78475c.failed

The book3s_32 target can get built as module which means we don't see the
config define for it in code. Instead, check on the bool define
CONFIG_KVM_BOOK3S_32_HANDLER whenever we want to know whether we're building
for a book3s_32 host.

This fixes running book3s_32 kvm as a module for me.

	Signed-off-by: Alexander Graf <agraf@suse.de>
	Reviewed-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
(cherry picked from commit ab78475c76bd8c54375d8a778200c59314973d30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s.c
diff --cc arch/powerpc/kvm/book3s.c
index be63f63c167b,7af190a266b3..000000000000
--- a/arch/powerpc/kvm/book3s.c
+++ b/arch/powerpc/kvm/book3s.c
@@@ -679,3 -765,147 +679,150 @@@ void kvmppc_decrementer_func(unsigned l
  	kvmppc_core_queue_dec(vcpu);
  	kvm_vcpu_kick(vcpu);
  }
++<<<<<<< HEAD
++=======
+ 
+ struct kvm_vcpu *kvmppc_core_vcpu_create(struct kvm *kvm, unsigned int id)
+ {
+ 	return kvm->arch.kvm_ops->vcpu_create(kvm, id);
+ }
+ 
+ void kvmppc_core_vcpu_free(struct kvm_vcpu *vcpu)
+ {
+ 	vcpu->kvm->arch.kvm_ops->vcpu_free(vcpu);
+ }
+ 
+ int kvmppc_core_check_requests(struct kvm_vcpu *vcpu)
+ {
+ 	return vcpu->kvm->arch.kvm_ops->check_requests(vcpu);
+ }
+ 
+ int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)
+ {
+ 	return kvm->arch.kvm_ops->get_dirty_log(kvm, log);
+ }
+ 
+ void kvmppc_core_free_memslot(struct kvm *kvm, struct kvm_memory_slot *free,
+ 			      struct kvm_memory_slot *dont)
+ {
+ 	kvm->arch.kvm_ops->free_memslot(free, dont);
+ }
+ 
+ int kvmppc_core_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,
+ 			       unsigned long npages)
+ {
+ 	return kvm->arch.kvm_ops->create_memslot(slot, npages);
+ }
+ 
+ void kvmppc_core_flush_memslot(struct kvm *kvm, struct kvm_memory_slot *memslot)
+ {
+ 	kvm->arch.kvm_ops->flush_memslot(kvm, memslot);
+ }
+ 
+ int kvmppc_core_prepare_memory_region(struct kvm *kvm,
+ 				struct kvm_memory_slot *memslot,
+ 				struct kvm_userspace_memory_region *mem)
+ {
+ 	return kvm->arch.kvm_ops->prepare_memory_region(kvm, memslot, mem);
+ }
+ 
+ void kvmppc_core_commit_memory_region(struct kvm *kvm,
+ 				struct kvm_userspace_memory_region *mem,
+ 				const struct kvm_memory_slot *old)
+ {
+ 	kvm->arch.kvm_ops->commit_memory_region(kvm, mem, old);
+ }
+ 
+ int kvm_unmap_hva(struct kvm *kvm, unsigned long hva)
+ {
+ 	return kvm->arch.kvm_ops->unmap_hva(kvm, hva);
+ }
+ EXPORT_SYMBOL_GPL(kvm_unmap_hva);
+ 
+ int kvm_unmap_hva_range(struct kvm *kvm, unsigned long start, unsigned long end)
+ {
+ 	return kvm->arch.kvm_ops->unmap_hva_range(kvm, start, end);
+ }
+ 
+ int kvm_age_hva(struct kvm *kvm, unsigned long hva)
+ {
+ 	return kvm->arch.kvm_ops->age_hva(kvm, hva);
+ }
+ 
+ int kvm_test_age_hva(struct kvm *kvm, unsigned long hva)
+ {
+ 	return kvm->arch.kvm_ops->test_age_hva(kvm, hva);
+ }
+ 
+ void kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte)
+ {
+ 	kvm->arch.kvm_ops->set_spte_hva(kvm, hva, pte);
+ }
+ 
+ void kvmppc_mmu_destroy(struct kvm_vcpu *vcpu)
+ {
+ 	vcpu->kvm->arch.kvm_ops->mmu_destroy(vcpu);
+ }
+ 
+ int kvmppc_core_init_vm(struct kvm *kvm)
+ {
+ 
+ #ifdef CONFIG_PPC64
+ 	INIT_LIST_HEAD(&kvm->arch.spapr_tce_tables);
+ 	INIT_LIST_HEAD(&kvm->arch.rtas_tokens);
+ #endif
+ 
+ 	return kvm->arch.kvm_ops->init_vm(kvm);
+ }
+ 
+ void kvmppc_core_destroy_vm(struct kvm *kvm)
+ {
+ 	kvm->arch.kvm_ops->destroy_vm(kvm);
+ 
+ #ifdef CONFIG_PPC64
+ 	kvmppc_rtas_tokens_free(kvm);
+ 	WARN_ON(!list_empty(&kvm->arch.spapr_tce_tables));
+ #endif
+ }
+ 
+ int kvmppc_core_check_processor_compat(void)
+ {
+ 	/*
+ 	 * We always return 0 for book3s. We check
+ 	 * for compatability while loading the HV
+ 	 * or PR module
+ 	 */
+ 	return 0;
+ }
+ 
+ static int kvmppc_book3s_init(void)
+ {
+ 	int r;
+ 
+ 	r = kvm_init(NULL, sizeof(struct kvm_vcpu), 0, THIS_MODULE);
+ 	if (r)
+ 		return r;
+ #ifdef CONFIG_KVM_BOOK3S_32_HANDLER
+ 	r = kvmppc_book3s_init_pr();
+ #endif
+ 	return r;
+ 
+ }
+ 
+ static void kvmppc_book3s_exit(void)
+ {
+ #ifdef CONFIG_KVM_BOOK3S_32_HANDLER
+ 	kvmppc_book3s_exit_pr();
+ #endif
+ 	kvm_exit();
+ }
+ 
+ module_init(kvmppc_book3s_init);
+ module_exit(kvmppc_book3s_exit);
+ 
+ /* On 32bit this is our one and only kernel module */
+ #ifdef CONFIG_KVM_BOOK3S_32_HANDLER
+ MODULE_ALIAS_MISCDEV(KVM_MINOR);
+ MODULE_ALIAS("devname:kvm");
+ #endif
++>>>>>>> ab78475c76bd (KVM: PPC: Book3S: ifdef on CONFIG_KVM_BOOK3S_32_HANDLER for 32bit)
* Unmerged path arch/powerpc/kvm/book3s.c
diff --git a/arch/powerpc/kvm/book3s_pr.c b/arch/powerpc/kvm/book3s_pr.c
index 4a72f612a23b..7c2fbd5638c0 100644
--- a/arch/powerpc/kvm/book3s_pr.c
+++ b/arch/powerpc/kvm/book3s_pr.c
@@ -1145,7 +1145,7 @@ struct kvm_vcpu *kvmppc_core_vcpu_create(struct kvm *kvm, unsigned int id)
 		goto free_vcpu;
 	vcpu->arch.book3s = vcpu_book3s;
 
-#ifdef CONFIG_KVM_BOOK3S_32
+#ifdef CONFIG_KVM_BOOK3S_32_HANDLER
 	vcpu->arch.shadow_vcpu =
 		kzalloc(sizeof(*vcpu->arch.shadow_vcpu), GFP_KERNEL);
 	if (!vcpu->arch.shadow_vcpu)
@@ -1190,7 +1190,7 @@ struct kvm_vcpu *kvmppc_core_vcpu_create(struct kvm *kvm, unsigned int id)
 uninit_vcpu:
 	kvm_vcpu_uninit(vcpu);
 free_shadow_vcpu:
-#ifdef CONFIG_KVM_BOOK3S_32
+#ifdef CONFIG_KVM_BOOK3S_32_HANDLER
 	kfree(vcpu->arch.shadow_vcpu);
 free_vcpu3s:
 #endif
@@ -1207,7 +1207,7 @@ void kvmppc_core_vcpu_free(struct kvm_vcpu *vcpu)
 
 	free_page((unsigned long)vcpu->arch.shared & PAGE_MASK);
 	kvm_vcpu_uninit(vcpu);
-#ifdef CONFIG_KVM_BOOK3S_32
+#ifdef CONFIG_KVM_BOOK3S_32_HANDLER
 	kfree(vcpu->arch.shadow_vcpu);
 #endif
 	vfree(vcpu_book3s);
