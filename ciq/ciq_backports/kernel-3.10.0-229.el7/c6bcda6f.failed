ceph: queue vmtruncate if necessary when handing cap grant/revoke

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Yan, Zheng <zheng.z.yan@intel.com>
commit c6bcda6f525129b1df169f77d96a4b0972e1ecb1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/c6bcda6f.failed

cap grant/revoke message from non-auth MDS can update inode's size
and truncate_seq/truncate_size. (the message arrives before auth
MDS's cap trunc message)

	Signed-off-by: Yan, Zheng <zheng.z.yan@intel.com>
(cherry picked from commit c6bcda6f525129b1df169f77d96a4b0972e1ecb1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/caps.c
diff --cc fs/ceph/caps.c
index 5db8817ba1a5,de39a03f5b71..000000000000
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@@ -2416,10 -2418,12 +2416,19 @@@ static void handle_cap_grant(struct ino
  	u64 max_size = le64_to_cpu(grant->max_size);
  	struct timespec mtime, atime, ctime;
  	int check_caps = 0;
++<<<<<<< HEAD
 +	int wake = 0;
 +	int writeback = 0;
 +	int queue_invalidate = 0;
 +	int deleted_inode = 0;
++=======
+ 	bool wake = 0;
+ 	bool writeback = 0;
+ 	bool queue_trunc = 0;
+ 	bool queue_invalidate = 0;
+ 	bool queue_revalidate = 0;
+ 	bool deleted_inode = 0;
++>>>>>>> c6bcda6f5251 (ceph: queue vmtruncate if necessary when handing cap grant/revoke)
  
  	dout("handle_cap_grant inode %p cap %p mds%d seq %d %s\n",
  	     inode, cap, mds, seq, ceph_cap_string(newcaps));
@@@ -2500,10 -2506,17 +2509,11 @@@
  		}
  	}
  
 -	/* Do we need to revalidate our fscache cookie. Don't bother on the
 -	 * first cache cap as we already validate at cookie creation time. */
 -	if ((issued & CEPH_CAP_FILE_CACHE) && ci->i_rdcache_gen > 1)
 -		queue_revalidate = 1;
 -
  	/* size/ctime/mtime/atime? */
- 	ceph_fill_file_size(inode, issued,
- 			    le32_to_cpu(grant->truncate_seq),
- 			    le64_to_cpu(grant->truncate_size), size);
+ 	queue_trunc = ceph_fill_file_size(inode, issued,
+ 					  le32_to_cpu(grant->truncate_seq),
+ 					  le64_to_cpu(grant->truncate_size),
+ 					  size);
  	ceph_decode_timespec(&mtime, &grant->mtime);
  	ceph_decode_timespec(&atime, &grant->atime);
  	ceph_decode_timespec(&ctime, &grant->ctime);
@@@ -2583,6 -2596,13 +2593,16 @@@
  	BUG_ON(cap->issued & ~cap->implemented);
  
  	spin_unlock(&ci->i_ceph_lock);
++<<<<<<< HEAD
++=======
+ 
+ 	if (queue_trunc) {
+ 		ceph_queue_vmtruncate(inode);
+ 		ceph_queue_revalidate(inode);
+ 	} else if (queue_revalidate)
+ 		ceph_queue_revalidate(inode);
+ 
++>>>>>>> c6bcda6f5251 (ceph: queue vmtruncate if necessary when handing cap grant/revoke)
  	if (writeback)
  		/*
  		 * queue inode for writeback: we can't actually call
* Unmerged path fs/ceph/caps.c
