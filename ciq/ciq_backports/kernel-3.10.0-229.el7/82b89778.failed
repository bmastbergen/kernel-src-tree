perf: Differentiate exec() and non-exec() comm events

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Adrian Hunter <adrian.hunter@intel.com>
commit 82b897782d10fcc4930c9d4a15b175348fdd2871
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/82b89778.failed

perf tools like 'perf report' can aggregate samples by comm strings,
which generally works.  However, there are other potential use-cases.
For example, to pair up 'calls' with 'returns' accurately (from branch
events like Intel BTS) it is necessary to identify whether the process
has exec'd.  Although a comm event is generated when an 'exec' happens
it is also generated whenever the comm string is changed on a whim
(e.g. by prctl PR_SET_NAME).  This patch adds a flag to the comm event
to differentiate one case from the other.

In order to determine whether the kernel supports the new flag, a
selection bit named 'exec' is added to struct perf_event_attr.  The
bit does nothing but will cause perf_event_open() to fail if the bit
is set on kernels that do not have it defined.

	Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/537D9EBE.7030806@intel.com
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Dave Jones <davej@redhat.com>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Alexander Viro <viro@zeniv.linux.org.uk>
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: linux-fsdevel@vger.kernel.org
	Cc: linux-kernel@vger.kernel.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 82b897782d10fcc4930c9d4a15b175348fdd2871)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/exec.c
#	include/linux/perf_event.h
#	include/linux/sched.h
diff --cc fs/exec.c
index 4ba6694d6649,a3d33fe592d6..000000000000
--- a/fs/exec.c
+++ b/fs/exec.c
@@@ -1035,30 -1046,15 +1035,34 @@@ EXPORT_SYMBOL_GPL(get_task_comm)
   * so that a new one can be started
   */
  
++<<<<<<< HEAD
 +void set_task_comm(struct task_struct *tsk, char *buf)
++=======
+ void __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)
++>>>>>>> 82b897782d10 (perf: Differentiate exec() and non-exec() comm events)
  {
  	task_lock(tsk);
  	trace_task_rename(tsk, buf);
  	strlcpy(tsk->comm, buf, sizeof(tsk->comm));
  	task_unlock(tsk);
- 	perf_event_comm(tsk);
+ 	perf_event_comm(tsk, exec);
  }
  
 +static void filename_to_taskname(char *tcomm, const char *fn, unsigned int len)
 +{
 +	int i, ch;
 +
 +	/* Copies the binary name from after last slash */
 +	for (i = 0; (ch = *(fn++)) != '\0';) {
 +		if (ch == '/')
 +			i = 0; /* overwrite what we wrote */
 +		else
 +			if (i < len - 1)
 +				tcomm[i++] = ch;
 +	}
 +	tcomm[i] = '\0';
 +}
 +
  int flush_old_exec(struct linux_binprm * bprm)
  {
  	int retval;
@@@ -1116,7 -1110,8 +1120,12 @@@ void setup_new_exec(struct linux_binpr
  	else
  		set_dumpable(current->mm, suid_dumpable);
  
++<<<<<<< HEAD
 +	set_task_comm(current, bprm->tcomm);
++=======
+ 	perf_event_exec();
+ 	__set_task_comm(current, kbasename(bprm->filename), true);
++>>>>>>> 82b897782d10 (perf: Differentiate exec() and non-exec() comm events)
  
  	/* Set the new mm task size. We have to do that late because it may
  	 * depend on TIF_32BIT which is only updated in flush_thread() on
diff --cc include/linux/perf_event.h
index 8838b22cb728,707617a8c0f6..000000000000
--- a/include/linux/perf_event.h
+++ b/include/linux/perf_event.h
@@@ -726,7 -706,8 +726,12 @@@ extern struct perf_guest_info_callback
  extern int perf_register_guest_info_callbacks(struct perf_guest_info_callbacks *callbacks);
  extern int perf_unregister_guest_info_callbacks(struct perf_guest_info_callbacks *callbacks);
  
++<<<<<<< HEAD
 +extern void perf_event_comm(struct task_struct *tsk);
++=======
+ extern void perf_event_exec(void);
+ extern void perf_event_comm(struct task_struct *tsk, bool exec);
++>>>>>>> 82b897782d10 (perf: Differentiate exec() and non-exec() comm events)
  extern void perf_event_fork(struct task_struct *tsk);
  
  /* Callchains */
@@@ -833,7 -814,8 +838,12 @@@ static inline int perf_unregister_guest
  (struct perf_guest_info_callbacks *callbacks)				{ return 0; }
  
  static inline void perf_event_mmap(struct vm_area_struct *vma)		{ }
++<<<<<<< HEAD
 +static inline void perf_event_comm(struct task_struct *tsk)		{ }
++=======
+ static inline void perf_event_exec(void)				{ }
+ static inline void perf_event_comm(struct task_struct *tsk, bool exec)	{ }
++>>>>>>> 82b897782d10 (perf: Differentiate exec() and non-exec() comm events)
  static inline void perf_event_fork(struct task_struct *tsk)		{ }
  static inline void perf_event_init(void)				{ }
  static inline int  perf_swevent_get_recursion_context(void)		{ return -1; }
diff --cc include/linux/sched.h
index f198ce0da322,ad86e1d7dbc2..000000000000
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@@ -2245,7 -2379,11 +2245,15 @@@ extern long do_fork(unsigned long, unsi
  struct task_struct *fork_idle(int);
  extern pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);
  
++<<<<<<< HEAD
 +extern void set_task_comm(struct task_struct *tsk, char *from);
++=======
+ extern void __set_task_comm(struct task_struct *tsk, const char *from, bool exec);
+ static inline void set_task_comm(struct task_struct *tsk, const char *from)
+ {
+ 	__set_task_comm(tsk, from, false);
+ }
++>>>>>>> 82b897782d10 (perf: Differentiate exec() and non-exec() comm events)
  extern char *get_task_comm(char *to, struct task_struct *tsk);
  
  #ifdef CONFIG_SMP
* Unmerged path fs/exec.c
* Unmerged path include/linux/perf_event.h
* Unmerged path include/linux/sched.h
diff --git a/include/uapi/linux/perf_event.h b/include/uapi/linux/perf_event.h
index 87f6492556df..2f0b52a48f69 100644
--- a/include/uapi/linux/perf_event.h
+++ b/include/uapi/linux/perf_event.h
@@ -302,8 +302,8 @@ struct perf_event_attr {
 				exclude_callchain_kernel : 1, /* exclude kernel callchains */
 				exclude_callchain_user   : 1, /* exclude user callchains */
 				mmap2          :  1, /* include mmap with inode data     */
-
-				__reserved_1   : 40;
+				comm_exec      :  1, /* flag comm events that are due to an exec */
+				__reserved_1   : 39;
 
 	union {
 		__u32		wakeup_events;	  /* wakeup every n events */
@@ -502,7 +502,12 @@ struct perf_event_mmap_page {
 #define PERF_RECORD_MISC_GUEST_KERNEL		(4 << 0)
 #define PERF_RECORD_MISC_GUEST_USER		(5 << 0)
 
+/*
+ * PERF_RECORD_MISC_MMAP_DATA and PERF_RECORD_MISC_COMM_EXEC are used on
+ * different events so can reuse the same bit position.
+ */
 #define PERF_RECORD_MISC_MMAP_DATA		(1 << 13)
+#define PERF_RECORD_MISC_COMM_EXEC		(1 << 13)
 /*
  * Indicates that the content of PERF_SAMPLE_IP points to
  * the actual instruction that triggered the event. See also
diff --git a/kernel/events/core.c b/kernel/events/core.c
index f41fb263220f..fe0faac51574 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -5079,7 +5079,7 @@ static void perf_event_comm_event(struct perf_comm_event *comm_event)
 		       NULL);
 }
 
-void perf_event_comm(struct task_struct *task)
+void perf_event_comm(struct task_struct *task, bool exec)
 {
 	struct perf_comm_event comm_event;
 	struct perf_event_context *ctx;
@@ -5105,7 +5105,7 @@ void perf_event_comm(struct task_struct *task)
 		.event_id  = {
 			.header = {
 				.type = PERF_RECORD_COMM,
-				.misc = 0,
+				.misc = exec ? PERF_RECORD_MISC_COMM_EXEC : 0,
 				/* .size */
 			},
 			/* .pid */
