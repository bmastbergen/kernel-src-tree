perf probe: Fix to do exit call for symbol maps

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf/probe: Fix to do exit call for symbol maps (Jiri Olsa) [1134356]
Rebuild_FUZZ: 97.87%
commit-author Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
commit ee45b6c2c52d4217aae82eb2e8136fa2f8b93303
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/ee45b6c2.failed

Some perf-probe commands do symbol_init() but doesn't do exit call.

This fixes that to call symbol_exit() and releases machine if needed.

This also merges init_vmlinux() and init_user_exec() because both of
them are doing similar things.  (init_user_exec() just skips init
vmlinux related symbol maps)

Changes from v2:
 - Not to set symbol_conf.try_vmlinux_path in init_symbol_maps()
   (Thanks to Namhyung Kim!)

	Signed-off-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: "David A. Long" <dave.long@linaro.org>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Oleg Nesterov <oleg@redhat.com>
	Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: yrl.pp-manager.tt@hitachi.com
Link: http://lkml.kernel.org/r/20140206053204.29635.28334.stgit@kbuild-fedora.yrl.intra.hitachi.co.jp
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit ee45b6c2c52d4217aae82eb2e8136fa2f8b93303)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/probe-event.c
diff --cc tools/perf/util/probe-event.c
index d71337318fcb,9aa77832099a..000000000000
--- a/tools/perf/util/probe-event.c
+++ b/tools/perf/util/probe-event.c
@@@ -72,10 -72,11 +72,15 @@@ static int e_snprintf(char *str, size_
  static char *synthesize_perf_probe_point(struct perf_probe_point *pp);
  static int convert_name_to_addr(struct perf_probe_event *pev,
  				const char *exec);
++<<<<<<< HEAD
 +static struct machine machine;
++=======
+ static void clear_probe_trace_event(struct probe_trace_event *tev);
+ static struct machine *host_machine;
++>>>>>>> ee45b6c2c52d (perf probe: Fix to do exit call for symbol maps)
  
  /* Initialize symbol maps and path of vmlinux/modules */
- static int init_vmlinux(void)
+ static int init_symbol_maps(bool user_only)
  {
  	int ret;
  
@@@ -172,17 -182,34 +186,48 @@@ const char *kernel_get_module_path(cons
  	return (dso) ? dso->long_name : NULL;
  }
  
++<<<<<<< HEAD
 +static int init_user_exec(void)
 +{
 +	int ret = 0;
 +
 +	symbol_conf.try_vmlinux_path = false;
 +	symbol_conf.sort_by_name = true;
 +	ret = symbol__init();
 +
 +	if (ret < 0)
 +		pr_debug("Failed to init symbol map.\n");
 +
++=======
+ static int convert_exec_to_group(const char *exec, char **result)
+ {
+ 	char *ptr1, *ptr2, *exec_copy;
+ 	char buf[64];
+ 	int ret;
+ 
+ 	exec_copy = strdup(exec);
+ 	if (!exec_copy)
+ 		return -ENOMEM;
+ 
+ 	ptr1 = basename(exec_copy);
+ 	if (!ptr1) {
+ 		ret = -EINVAL;
+ 		goto out;
+ 	}
+ 
+ 	ptr2 = strpbrk(ptr1, "-._");
+ 	if (ptr2)
+ 		*ptr2 = '\0';
+ 	ret = e_snprintf(buf, 64, "%s_%s", PERFPROBE_GROUP, ptr1);
+ 	if (ret < 0)
+ 		goto out;
+ 
+ 	*result = strdup(buf);
+ 	ret = *result ? 0 : -ENOMEM;
+ 
+ out:
+ 	free(exec_copy);
++>>>>>>> ee45b6c2c52d (perf probe: Fix to do exit call for symbol maps)
  	return ret;
  }
  
@@@ -2058,9 -2174,10 +2111,10 @@@ end
  	for (i = 0; i < npevs; i++) {
  		for (j = 0; j < pkgs[i].ntevs; j++)
  			clear_probe_trace_event(&pkgs[i].tevs[j]);
 -		zfree(&pkgs[i].tevs);
 +		free(pkgs[i].tevs);
  	}
  	free(pkgs);
+ 	exit_symbol_maps();
  
  	return ret;
  }
* Unmerged path tools/perf/util/probe-event.c
