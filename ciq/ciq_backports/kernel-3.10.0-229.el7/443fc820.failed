ACPI / hotplug: Rework generic code to handle suprise removals

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug: Rework generic code to handle suprise removals (Myron Stowe) [1128632]
Rebuild_FUZZ: 94.02%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 443fc8202272190c4693209b772edba46cd7fe61
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/443fc820.failed

The generic ACPI hotplug code used for several types of device
doesn't handle surprise removals, mostly because those devices
currently cannot be removed by surprise in the majority of systems.
However, surprise removals should be handled by that code as well
as surprise additions of devices, so make it do that.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 443fc8202272190c4693209b772edba46cd7fe61)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index 2bbdeee33be4,06db2c036085..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -285,129 -276,121 +285,224 @@@ static int acpi_scan_hot_remove(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +void acpi_bus_device_eject(struct acpi_device *device, u32 ost_src)
++=======
+ static int acpi_scan_device_not_present(struct acpi_device *adev)
+ {
+ 	if (!acpi_device_enumerated(adev)) {
+ 		dev_warn(&adev->dev, "Still not present\n");
+ 		return -EALREADY;
+ 	}
+ 	acpi_bus_trim(adev);
+ 	return 0;
+ }
+ 
+ static int acpi_scan_device_check(struct acpi_device *adev)
+ {
+ 	int error;
+ 
+ 	acpi_bus_get_status(adev);
+ 	if (adev->status.present || adev->status.functional) {
+ 		/*
+ 		 * This function is only called for device objects for which
+ 		 * matching scan handlers exist.  The only situation in which
+ 		 * the scan handler is not attached to this device object yet
+ 		 * is when the device has just appeared (either it wasn't
+ 		 * present at all before or it was removed and then added
+ 		 * again).
+ 		 */
+ 		if (adev->handler) {
+ 			dev_warn(&adev->dev, "Already enumerated\n");
+ 			return -EALREADY;
+ 		}
+ 		error = acpi_bus_scan(adev->handle);
+ 		if (error) {
+ 			dev_warn(&adev->dev, "Namespace scan failure\n");
+ 			return error;
+ 		}
+ 		if (!adev->handler) {
+ 			dev_warn(&adev->dev, "Enumeration failure\n");
+ 			error = -ENODEV;
+ 		}
+ 	} else {
+ 		error = acpi_scan_device_not_present(adev);
+ 	}
+ 	return error;
+ }
+ 
+ static int acpi_scan_bus_check(struct acpi_device *adev)
+ {
+ 	struct acpi_scan_handler *handler = adev->handler;
+ 	struct acpi_device *child;
+ 	int error;
+ 
+ 	acpi_bus_get_status(adev);
+ 	if (!(adev->status.present || adev->status.functional)) {
+ 		acpi_scan_device_not_present(adev);
+ 		return 0;
+ 	}
+ 	if (handler && handler->hotplug.scan_dependent)
+ 		return handler->hotplug.scan_dependent(adev);
+ 
+ 	error = acpi_bus_scan(adev->handle);
+ 	if (error) {
+ 		dev_warn(&adev->dev, "Namespace scan failure\n");
+ 		return error;
+ 	}
+ 	list_for_each_entry(child, &adev->children, node) {
+ 		error = acpi_scan_bus_check(child);
+ 		if (error)
+ 			return error;
+ 	}
+ 	return 0;
+ }
+ 
+ static void acpi_device_hotplug(void *data, u32 src)
++>>>>>>> 443fc8202272 (ACPI / hotplug: Rework generic code to handle suprise removals)
  {
 +	acpi_handle handle = device->handle;
  	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
++<<<<<<< HEAD
++=======
+ 	struct acpi_device *adev = data;
++>>>>>>> 443fc8202272 (ACPI / hotplug: Rework generic code to handle suprise removals)
  	int error;
  
  	lock_device_hotplug();
  	mutex_lock(&acpi_scan_lock);
  
 -	/*
 -	 * The device object's ACPI handle cannot become invalid as long as we
 -	 * are holding acpi_scan_lock, but it may have become invalid before
 -	 * that lock was acquired.
 -	 */
 -	if (adev->handle == INVALID_ACPI_HANDLE)
 -		goto out;
 +	if (ost_src == ACPI_NOTIFY_EJECT_REQUEST)
 +		acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
 +					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 +
++<<<<<<< HEAD
 +	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
 +		kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
  
 +	error = acpi_scan_hot_remove(device);
 +	if (error == -EPERM) {
 +		goto err_support;
 +	} else if (error) {
 +		goto err_out;
++=======
+ 	switch (src) {
+ 	case ACPI_NOTIFY_BUS_CHECK:
+ 		error = acpi_scan_bus_check(adev);
+ 		break;
+ 	case ACPI_NOTIFY_DEVICE_CHECK:
+ 		error = acpi_scan_device_check(adev);
+ 		break;
+ 	case ACPI_NOTIFY_EJECT_REQUEST:
+ 	case ACPI_OST_EC_OSPM_EJECT:
+ 		error = acpi_scan_hot_remove(adev);
+ 		break;
+ 	default:
+ 		error = -EINVAL;
+ 		break;
++>>>>>>> 443fc8202272 (ACPI / hotplug: Rework generic code to handle suprise removals)
  	}
 -	if (!error)
 -		ost_code = ACPI_OST_SC_SUCCESS;
  
   out:
 -	acpi_evaluate_hotplug_ost(adev->handle, src, ost_code, NULL);
 -	put_device(&adev->dev);
  	mutex_unlock(&acpi_scan_lock);
  	unlock_device_hotplug();
 +	return;
 +
 + err_support:
 +	ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
 + err_out:
 +	acpi_evaluate_hotplug_ost(handle, ost_src, ost_code, NULL);
 +	goto out;
  }
  
 -static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 +static void acpi_scan_bus_device_check(acpi_handle handle, u32 ost_source)
  {
 +	struct acpi_device *device = NULL;
  	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 +	int error;
 +
 +	lock_device_hotplug();
 +	mutex_lock(&acpi_scan_lock);
 +
 +	if (ost_source != ACPI_NOTIFY_BUS_CHECK) {
 +		acpi_bus_get_device(handle, &device);
 +		if (device) {
 +			dev_warn(&device->dev, "Attempt to re-insert\n");
 +			goto out;
 +		}
 +	}
 +	error = acpi_bus_scan(handle);
 +	if (error) {
 +		acpi_handle_warn(handle, "Namespace scan failure\n");
 +		goto out;
 +	}
 +	error = acpi_bus_get_device(handle, &device);
 +	if (error) {
 +		acpi_handle_warn(handle, "Missing device node object\n");
 +		goto out;
 +	}
 +	ost_code = ACPI_OST_SC_SUCCESS;
 +	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
 +		kobject_uevent(&device->dev.kobj, KOBJ_ONLINE);
 +
 + out:
 +	acpi_evaluate_hotplug_ost(handle, ost_source, ost_code, NULL);
 +	mutex_unlock(&acpi_scan_lock);
 +	unlock_device_hotplug();
 +}
 +
 +static void acpi_scan_bus_check(void *context)
 +{
 +	acpi_scan_bus_device_check((acpi_handle)context,
 +				   ACPI_NOTIFY_BUS_CHECK);
 +}
 +
 +static void acpi_scan_device_check(void *context)
 +{
 +	acpi_scan_bus_device_check((acpi_handle)context,
 +				   ACPI_NOTIFY_DEVICE_CHECK);
 +}
 +
 +static void acpi_hotplug_unsupported(acpi_handle handle, u32 type)
 +{
 +	u32 ost_status;
 +
 +	switch (type) {
 +	case ACPI_NOTIFY_BUS_CHECK:
 +		acpi_handle_debug(handle,
 +			"ACPI_NOTIFY_BUS_CHECK event: unsupported\n");
 +		ost_status = ACPI_OST_SC_INSERT_NOT_SUPPORTED;
 +		break;
 +	case ACPI_NOTIFY_DEVICE_CHECK:
 +		acpi_handle_debug(handle,
 +			"ACPI_NOTIFY_DEVICE_CHECK event: unsupported\n");
 +		ost_status = ACPI_OST_SC_INSERT_NOT_SUPPORTED;
 +		break;
 +	case ACPI_NOTIFY_EJECT_REQUEST:
 +		acpi_handle_debug(handle,
 +			"ACPI_NOTIFY_EJECT_REQUEST event: unsupported\n");
 +		ost_status = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
 +		break;
 +	default:
 +		/* non-hotplug event; possibly handled by other handler */
 +		return;
 +	}
 +
 +	acpi_evaluate_hotplug_ost(handle, type, ost_status, NULL);
 +}
 +
 +/**
 + * acpi_bus_hot_remove_device: Hot-remove a device and its children.
 + * @context: Address of the ACPI device object to hot-remove.
 + */
 +static void acpi_bus_hot_remove_device(void *context)
 +{
 +	acpi_bus_device_eject(context, ACPI_NOTIFY_EJECT_REQUEST);
 +}
 +
 +static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 +{
 +	acpi_osd_exec_callback callback;
  	struct acpi_scan_handler *handler = data;
  	struct acpi_device *adev;
  	acpi_status status;
* Unmerged path drivers/acpi/scan.c
