mlx5: Fix sparse warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [ethernet] mlx4: Fix sparse warning (Amir Vadai) [1107617 1107618 1107619 1107620]
Rebuild_FUZZ: 93.88%
commit-author Eli Cohen <eli@dev.mellanox.co.il>
commit 6a4f139aae77d601bd146a6b3c4e12e7e4e0226f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/6a4f139a.failed

1. Add required __acquire/__release statements to balance spinlock usage.
2. Change the index parameter of begin_wqe() to be unsigned to match supplied
argument type.

	Signed-off-by: Eli Cohen <eli@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 6a4f139aae77d601bd146a6b3c4e12e7e4e0226f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/mlx5/qp.c
diff --cc drivers/infiniband/hw/mlx5/qp.c
index 7dfe8a1c84cf,1cae1c7132b4..000000000000
--- a/drivers/infiniband/hw/mlx5/qp.c
+++ b/drivers/infiniband/hw/mlx5/qp.c
@@@ -2041,6 -2419,59 +2051,62 @@@ static u8 get_fence(u8 fence, struct ib
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int begin_wqe(struct mlx5_ib_qp *qp, void **seg,
+ 		     struct mlx5_wqe_ctrl_seg **ctrl,
+ 		     struct ib_send_wr *wr, unsigned *idx,
+ 		     int *size, int nreq)
+ {
+ 	int err = 0;
+ 
+ 	if (unlikely(mlx5_wq_overflow(&qp->sq, nreq, qp->ibqp.send_cq))) {
+ 		err = -ENOMEM;
+ 		return err;
+ 	}
+ 
+ 	*idx = qp->sq.cur_post & (qp->sq.wqe_cnt - 1);
+ 	*seg = mlx5_get_send_wqe(qp, *idx);
+ 	*ctrl = *seg;
+ 	*(uint32_t *)(*seg + 8) = 0;
+ 	(*ctrl)->imm = send_ieth(wr);
+ 	(*ctrl)->fm_ce_se = qp->sq_signal_bits |
+ 		(wr->send_flags & IB_SEND_SIGNALED ?
+ 		 MLX5_WQE_CTRL_CQ_UPDATE : 0) |
+ 		(wr->send_flags & IB_SEND_SOLICITED ?
+ 		 MLX5_WQE_CTRL_SOLICITED : 0);
+ 
+ 	*seg += sizeof(**ctrl);
+ 	*size = sizeof(**ctrl) / 16;
+ 
+ 	return err;
+ }
+ 
+ static void finish_wqe(struct mlx5_ib_qp *qp,
+ 		       struct mlx5_wqe_ctrl_seg *ctrl,
+ 		       u8 size, unsigned idx, u64 wr_id,
+ 		       int nreq, u8 fence, u8 next_fence,
+ 		       u32 mlx5_opcode)
+ {
+ 	u8 opmod = 0;
+ 
+ 	ctrl->opmod_idx_opcode = cpu_to_be32(((u32)(qp->sq.cur_post) << 8) |
+ 					     mlx5_opcode | ((u32)opmod << 24));
+ 	ctrl->qpn_ds = cpu_to_be32(size | (qp->mqp.qpn << 8));
+ 	ctrl->fm_ce_se |= fence;
+ 	qp->fm_cache = next_fence;
+ 	if (unlikely(qp->wq_sig))
+ 		ctrl->signature = wq_sig(ctrl);
+ 
+ 	qp->sq.wrid[idx] = wr_id;
+ 	qp->sq.w_list[idx].opcode = mlx5_opcode;
+ 	qp->sq.wqe_head[idx] = qp->sq.head + nreq;
+ 	qp->sq.cur_post += DIV_ROUND_UP(size * 16, MLX5_SEND_WQE_BB);
+ 	qp->sq.w_list[idx].next = qp->sq.cur_post;
+ }
+ 
+ 
++>>>>>>> 6a4f139aae77 (mlx5: Fix sparse warnings)
  int mlx5_ib_post_send(struct ib_qp *ibqp, struct ib_send_wr *wr,
  		      struct ib_send_wr **bad_wr)
  {
* Unmerged path drivers/infiniband/hw/mlx5/qp.c
