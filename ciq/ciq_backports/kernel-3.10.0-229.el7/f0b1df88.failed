ALSA: hda - Move azx_interrupt to hda_controller

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [alsa] hda: Move azx_interrupt to hda_controller (Jaroslav Kysela) [1112200]
Rebuild_FUZZ: 89.89%
commit-author Dylan Reid <dgreid@chromium.org>
commit f0b1df88713a3537e056658d860f6631653ec5c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/f0b1df88.failed

This code will be reused by an hda_platform driver as it has no PCI
dependencies.  This allows update_rirb to be static as all users are
now in hda_controller.c.

	Signed-off-by: Dylan Reid <dgreid@chromium.org>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit f0b1df88713a3537e056658d860f6631653ec5c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_controller.c
#	sound/pci/hda/hda_controller.h
#	sound/pci/hda/hda_intel.c
diff --cc sound/pci/hda/hda_intel.c
index f803cf3b4c64,96c22a3a2dc0..000000000000
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@@ -1023,269 -413,26 +1023,271 @@@ static void azx_init_pci(struct azx *ch
          }
  }
  
- 
  static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev);
  
 -/* called from IRQ */
 -static int azx_position_check(struct azx *chip, struct azx_dev *azx_dev)
 +/*
++<<<<<<< HEAD
 + * interrupt handler
 + */
 +static irqreturn_t azx_interrupt(int irq, void *dev_id)
 +{
 +	struct azx *chip = dev_id;
 +	struct azx_dev *azx_dev;
 +	u32 status;
 +	u8 sd_status;
 +	int i, ok;
 +
 +#ifdef CONFIG_PM_RUNTIME
 +	if (chip->driver_caps & AZX_DCAPS_PM_RUNTIME)
 +		if (chip->card->dev->power.runtime_status != RPM_ACTIVE)
 +			return IRQ_NONE;
 +#endif
 +
 +	spin_lock(&chip->reg_lock);
 +
 +	if (chip->disabled) {
 +		spin_unlock(&chip->reg_lock);
 +		return IRQ_NONE;
 +	}
 +
 +	status = azx_readl(chip, INTSTS);
 +	if (status == 0 || status == 0xffffffff) {
 +		spin_unlock(&chip->reg_lock);
 +		return IRQ_NONE;
 +	}
 +	
 +	for (i = 0; i < chip->num_streams; i++) {
 +		azx_dev = &chip->azx_dev[i];
 +		if (status & azx_dev->sd_int_sta_mask) {
 +			sd_status = azx_sd_readb(chip, azx_dev, SD_STS);
 +			azx_sd_writeb(chip, azx_dev, SD_STS, SD_INT_MASK);
 +			if (!azx_dev->substream || !azx_dev->running ||
 +			    !(sd_status & SD_INT_COMPLETE))
 +				continue;
 +			/* check whether this IRQ is really acceptable */
 +			ok = azx_position_ok(chip, azx_dev);
 +			if (ok == 1) {
 +				azx_dev->irq_pending = 0;
 +				spin_unlock(&chip->reg_lock);
 +				snd_pcm_period_elapsed(azx_dev->substream);
 +				spin_lock(&chip->reg_lock);
 +			} else if (ok == 0 && chip->bus && chip->bus->workq) {
 +				/* bogus IRQ, process it later */
 +				azx_dev->irq_pending = 1;
 +				queue_work(chip->bus->workq,
 +					   &chip->irq_pending_work);
 +			}
 +		}
 +	}
 +
 +	/* clear rirb int */
 +	status = azx_readb(chip, RIRBSTS);
 +	if (status & RIRB_INT_MASK) {
 +		if (status & RIRB_INT_RESPONSE) {
 +			if (chip->driver_caps & AZX_DCAPS_RIRB_PRE_DELAY)
 +				udelay(80);
 +			azx_update_rirb(chip);
 +		}
 +		azx_writeb(chip, RIRBSTS, RIRB_INT_MASK);
 +	}
 +
 +	spin_unlock(&chip->reg_lock);
 +	
 +	return IRQ_HANDLED;
 +}
 +
 +
 +/*
 + * set up a BDL entry
 + */
 +static int setup_bdle(struct azx *chip,
 +		      struct snd_dma_buffer *dmab,
 +		      struct azx_dev *azx_dev, u32 **bdlp,
 +		      int ofs, int size, int with_ioc)
 +{
 +	u32 *bdl = *bdlp;
 +
 +	while (size > 0) {
 +		dma_addr_t addr;
 +		int chunk;
 +
 +		if (azx_dev->frags >= AZX_MAX_BDL_ENTRIES)
 +			return -EINVAL;
 +
 +		addr = snd_sgbuf_get_addr(dmab, ofs);
 +		/* program the address field of the BDL entry */
 +		bdl[0] = cpu_to_le32((u32)addr);
 +		bdl[1] = cpu_to_le32(upper_32_bits(addr));
 +		/* program the size field of the BDL entry */
 +		chunk = snd_sgbuf_get_chunk_size(dmab, ofs, size);
 +		/* one BDLE cannot cross 4K boundary on CTHDA chips */
 +		if (chip->driver_caps & AZX_DCAPS_4K_BDLE_BOUNDARY) {
 +			u32 remain = 0x1000 - (ofs & 0xfff);
 +			if (chunk > remain)
 +				chunk = remain;
 +		}
 +		bdl[2] = cpu_to_le32(chunk);
 +		/* program the IOC to enable interrupt
 +		 * only when the whole fragment is processed
 +		 */
 +		size -= chunk;
 +		bdl[3] = (size || !with_ioc) ? 0 : cpu_to_le32(0x01);
 +		bdl += 4;
 +		azx_dev->frags++;
 +		ofs += chunk;
 +	}
 +	*bdlp = bdl;
 +	return ofs;
 +}
 +
 +/*
 + * set up BDL entries
 + */
 +static int azx_setup_periods(struct azx *chip,
 +			     struct snd_pcm_substream *substream,
 +			     struct azx_dev *azx_dev)
 +{
 +	u32 *bdl;
 +	int i, ofs, periods, period_bytes;
 +	int pos_adj;
 +
 +	/* reset BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +
 +	period_bytes = azx_dev->period_bytes;
 +	periods = azx_dev->bufsize / period_bytes;
 +
 +	/* program the initial BDL entries */
 +	bdl = (u32 *)azx_dev->bdl.area;
 +	ofs = 0;
 +	azx_dev->frags = 0;
 +	pos_adj = bdl_pos_adj[chip->dev_index];
 +	if (!azx_dev->no_period_wakeup && pos_adj > 0) {
 +		struct snd_pcm_runtime *runtime = substream->runtime;
 +		int pos_align = pos_adj;
 +		pos_adj = (pos_adj * runtime->rate + 47999) / 48000;
 +		if (!pos_adj)
 +			pos_adj = pos_align;
 +		else
 +			pos_adj = ((pos_adj + pos_align - 1) / pos_align) *
 +				pos_align;
 +		pos_adj = frames_to_bytes(runtime, pos_adj);
 +		if (pos_adj >= period_bytes) {
 +			snd_printk(KERN_WARNING SFX "%s: Too big adjustment %d\n",
 +				   pci_name(chip->pci), bdl_pos_adj[chip->dev_index]);
 +			pos_adj = 0;
 +		} else {
 +			ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
 +					 azx_dev,
 +					 &bdl, ofs, pos_adj, true);
 +			if (ofs < 0)
 +				goto error;
 +		}
 +	} else
 +		pos_adj = 0;
 +	for (i = 0; i < periods; i++) {
 +		if (i == periods - 1 && pos_adj)
 +			ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
 +					 azx_dev, &bdl, ofs,
 +					 period_bytes - pos_adj, 0);
 +		else
 +			ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
 +					 azx_dev, &bdl, ofs,
 +					 period_bytes,
 +					 !azx_dev->no_period_wakeup);
 +		if (ofs < 0)
 +			goto error;
 +	}
 +	return 0;
 +
 + error:
 +	snd_printk(KERN_ERR SFX "%s: Too many BDL entries: buffer=%d, period=%d\n",
 +		   pci_name(chip->pci), azx_dev->bufsize, period_bytes);
 +	return -EINVAL;
 +}
 +
 +/* reset stream */
 +static void azx_stream_reset(struct azx *chip, struct azx_dev *azx_dev)
  {
 -	int ok;
 +	unsigned char val;
 +	int timeout;
 +
 +	azx_stream_clear(chip, azx_dev);
 +
 +	azx_sd_writeb(chip, azx_dev, SD_CTL,
 +		      azx_sd_readb(chip, azx_dev, SD_CTL) |
 +		      SD_CTL_STREAM_RESET);
 +	udelay(3);
 +	timeout = 300;
 +	while (!((val = azx_sd_readb(chip, azx_dev, SD_CTL)) &
 +		 SD_CTL_STREAM_RESET) && --timeout)
 +		;
 +	val &= ~SD_CTL_STREAM_RESET;
 +	azx_sd_writeb(chip, azx_dev, SD_CTL, val);
 +	udelay(3);
 +
 +	timeout = 300;
 +	/* waiting for hardware to report that the stream is out of reset */
 +	while (((val = azx_sd_readb(chip, azx_dev, SD_CTL)) &
 +		SD_CTL_STREAM_RESET) && --timeout)
 +		;
 +
 +	/* reset first position - may not be synced with hw at this time */
 +	*azx_dev->posbuf = 0;
 +}
  
 -	ok = azx_position_ok(chip, azx_dev);
 -	if (ok == 1) {
 -		azx_dev->irq_pending = 0;
 -		return ok;
 -	} else if (ok == 0 && chip->bus && chip->bus->workq) {
 -		/* bogus IRQ, process it later */
 -		azx_dev->irq_pending = 1;
 -		queue_work(chip->bus->workq, &chip->irq_pending_work);
 +/*
 + * set up the SD for streaming
 + */
 +static int azx_setup_controller(struct azx *chip, struct azx_dev *azx_dev)
 +{
 +	unsigned int val;
 +	/* make sure the run bit is zero for SD */
 +	azx_stream_clear(chip, azx_dev);
 +	/* program the stream_tag */
 +	val = azx_sd_readl(chip, azx_dev, SD_CTL);
 +	val = (val & ~SD_CTL_STREAM_TAG_MASK) |
 +		(azx_dev->stream_tag << SD_CTL_STREAM_TAG_SHIFT);
 +	if (!azx_snoop(chip))
 +		val |= SD_CTL_TRAFFIC_PRIO;
 +	azx_sd_writel(chip, azx_dev, SD_CTL, val);
 +
 +	/* program the length of samples in cyclic buffer */
 +	azx_sd_writel(chip, azx_dev, SD_CBL, azx_dev->bufsize);
 +
 +	/* program the stream format */
 +	/* this value needs to be the same as the one programmed */
 +	azx_sd_writew(chip, azx_dev, SD_FORMAT, azx_dev->format_val);
 +
 +	/* program the stream LVI (last valid index) of the BDL */
 +	azx_sd_writew(chip, azx_dev, SD_LVI, azx_dev->frags - 1);
 +
 +	/* program the BDL address */
 +	/* lower BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, (u32)azx_dev->bdl.addr);
 +	/* upper BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU,
 +		      upper_32_bits(azx_dev->bdl.addr));
 +
 +	/* enable the position buffer */
 +	if (chip->position_fix[0] != POS_FIX_LPIB ||
 +	    chip->position_fix[1] != POS_FIX_LPIB) {
 +		if (!(azx_readl(chip, DPLBASE) & ICH6_DPLBASE_ENABLE))
 +			azx_writel(chip, DPLBASE,
 +				(u32)chip->posbuf.addr | ICH6_DPLBASE_ENABLE);
  	}
 +
 +	/* set the interrupt enable bits in the descriptor control register */
 +	azx_sd_writel(chip, azx_dev, SD_CTL,
 +		      azx_sd_readl(chip, azx_dev, SD_CTL) | SD_INT_MASK);
 +
  	return 0;
  }
  
  /*
++=======
++>>>>>>> f0b1df88713a (ALSA: hda - Move azx_interrupt to hda_controller)
   * Probe the given codec address
   */
  static int probe_codec(struct azx *chip, int addr)
* Unmerged path sound/pci/hda/hda_controller.c
* Unmerged path sound/pci/hda/hda_controller.h
* Unmerged path sound/pci/hda/hda_controller.c
* Unmerged path sound/pci/hda/hda_controller.h
* Unmerged path sound/pci/hda/hda_intel.c
