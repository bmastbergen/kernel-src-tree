ipv4: use ip_skb_dst_mtu to determine mtu in ip_fragment

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit 69647ce46a236a355a7a3096d793819a9bd7c1d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/69647ce4.failed

ip_skb_dst_mtu mostly falls back to ip_dst_mtu_maybe_forward if no socket
is attached to the skb (in case of forwarding) or determines the mtu like
we do in ip_finish_output, which actually checks if we should branch to
ip_fragment. Thus use the same function to determine the mtu here, too.

This is important for the introduction of IP_PMTUDISC_OMIT, where we
want the packets getting cut in pieces of the size of the outgoing
interface mtu. IPv6 already does this correctly.

	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 69647ce46a236a355a7a3096d793819a9bd7c1d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ip_output.c
diff --cc net/ipv4/ip_output.c
index 912402752f2f,22aa11971ed1..000000000000
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@@ -458,12 -458,13 +458,16 @@@ int ip_fragment(struct sk_buff *skb, in
  
  	iph = ip_hdr(skb);
  
++<<<<<<< HEAD
++=======
+ 	mtu = ip_skb_dst_mtu(skb);
++>>>>>>> 69647ce46a23 (ipv4: use ip_skb_dst_mtu to determine mtu in ip_fragment)
  	if (unlikely(((iph->frag_off & htons(IP_DF)) && !skb->local_df) ||
  		     (IPCB(skb)->frag_max_size &&
 -		      IPCB(skb)->frag_max_size > mtu))) {
 +		      IPCB(skb)->frag_max_size > dst_mtu(&rt->dst)))) {
  		IP_INC_STATS(dev_net(dev), IPSTATS_MIB_FRAGFAILS);
  		icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
 -			  htonl(mtu));
 +			  htonl(ip_skb_dst_mtu(skb)));
  		kfree_skb(skb);
  		return -EMSGSIZE;
  	}
* Unmerged path net/ipv4/ip_output.c
