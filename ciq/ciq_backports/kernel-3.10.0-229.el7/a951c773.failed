ACPI / scan: Clear match_driver flag in acpi_bus_trim()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] scan: Clear match_driver flag in acpi_bus_trim() (Myron Stowe) [1128632]
Rebuild_FUZZ: 93.20%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit a951c773bc39677ef3fa42814be7f5218a3100b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a951c773.failed

Drivers should not bind to struct acpi_device objects that
acpi_bus_trim() has been called for, so make that function
clear flags.match_driver for those objects.

If that is not done, an ACPI driver may theoretically try to operate
a device that is not physically present.

Fixes: 202317a573b2 (ACPI / scan: Add acpi_device objects for all device nodes in the namespace)
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Toshi Kani <toshi.kani@hp.com>
(cherry picked from commit a951c773bc39677ef3fa42814be7f5218a3100b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index 2bbdeee33be4,089dc403c43b..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -1986,22 -2036,30 +1986,40 @@@ static acpi_status acpi_bus_remove(acpi
   *
   * Must be called under acpi_scan_lock.
   */
 -void acpi_bus_trim(struct acpi_device *adev)
 +void acpi_bus_trim(struct acpi_device *start)
  {
++<<<<<<< HEAD
++=======
+ 	struct acpi_scan_handler *handler = adev->handler;
+ 	struct acpi_device *child;
+ 
+ 	list_for_each_entry_reverse(child, &adev->children, node)
+ 		acpi_bus_trim(child);
+ 
+ 	adev->flags.match_driver = false;
+ 	if (handler) {
+ 		if (handler->detach)
+ 			handler->detach(adev);
+ 
+ 		adev->handler = NULL;
+ 	} else {
+ 		device_release_driver(&adev->dev);
+ 	}
++>>>>>>> a951c773bc39 (ACPI / scan: Clear match_driver flag in acpi_bus_trim())
 +	/*
 +	 * Execute acpi_bus_device_detach() as a post-order callback to detach
 +	 * all ACPI drivers from the device nodes being removed.
 +	 */
 +	acpi_walk_namespace(ACPI_TYPE_ANY, start->handle, ACPI_UINT32_MAX, NULL,
 +			    acpi_bus_device_detach, NULL, NULL);
 +	acpi_bus_device_detach(start->handle, 0, NULL, NULL);
  	/*
 -	 * Most likely, the device is going away, so put it into D3cold before
 -	 * that.
 +	 * Execute acpi_bus_remove() as a post-order callback to remove device
 +	 * nodes in the given namespace scope.
  	 */
 -	acpi_device_set_power(adev, ACPI_STATE_D3_COLD);
 -	adev->flags.initialized = false;
 -	adev->flags.visited = false;
 +	acpi_walk_namespace(ACPI_TYPE_ANY, start->handle, ACPI_UINT32_MAX, NULL,
 +			    acpi_bus_remove, NULL, NULL);
 +	acpi_bus_remove(start->handle, 0, NULL, NULL);
  }
  EXPORT_SYMBOL_GPL(acpi_bus_trim);
  
* Unmerged path drivers/acpi/scan.c
