ACPI / dock: Add .uevent() callback to struct acpi_hotplug_context

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] dock: Add .uevent() callback to struct acpi_hotplug_context (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 94.40%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit be27b3dcb02335ec093b81053fc8c84b32d3106e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/be27b3dc.failed

In order to avoid the need to register special ACPI dock
operations for SATA devices add a .uevent() callback pointer to
struct acpi_hotplug_context and make dock_hotplug_event() use that
callback if available.  Also rename the existing .event() callback
in struct acpi_hotplug_context to .notify() to avoid possible
confusion in the future.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit be27b3dcb02335ec093b81053fc8c84b32d3106e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/dock.c
#	drivers/acpi/scan.c
#	drivers/pci/hotplug/acpiphp_glue.c
#	include/acpi/acpi_bus.h
diff --cc drivers/acpi/dock.c
index c3bab54256c4,a88fad9ff234..000000000000
--- a/drivers/acpi/dock.c
+++ b/drivers/acpi/dock.c
@@@ -184,6 -188,44 +184,46 @@@ static void dock_hotplug_event(struct d
  	acpi_notify_handler cb = NULL;
  	bool run = false;
  
++<<<<<<< HEAD
++=======
+ 	acpi_lock_hp_context();
+ 
+ 	if (!adev->hp)
+ 		goto no_context;
+ 
+ 	if (cb_type == DOCK_CALL_FIXUP) {
+ 		void (*fixup)(struct acpi_device *);
+ 
+ 		fixup = adev->hp->fixup;
+ 		if (fixup) {
+ 			acpi_unlock_hp_context();
+ 			fixup(adev);
+ 			return;
+ 		}
+ 	} else if (cb_type == DOCK_CALL_UEVENT) {
+ 		void (*uevent)(struct acpi_device *, u32);
+ 
+ 		uevent = adev->hp->uevent;
+ 		if (uevent) {
+ 			acpi_unlock_hp_context();
+ 			uevent(adev, event);
+ 			return;
+ 		}
+ 	} else {
+ 		int (*notify)(struct acpi_device *, u32);
+ 
+ 		notify = adev->hp->notify;
+ 		if (notify) {
+ 			acpi_unlock_hp_context();
+ 			notify(adev, event);
+ 			return;
+ 		}
+ 	}
+ 
+  no_context:
+ 	acpi_unlock_hp_context();
+ 
++>>>>>>> be27b3dcb023 (ACPI / dock: Add .uevent() callback to struct acpi_hotplug_context)
  	mutex_lock(&hotplug_lock);
  
  	if (dd->hp_context) {
diff --cc drivers/acpi/scan.c
index b30a50799f84,e7d951032f85..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -285,73 -380,144 +285,99 @@@ static int acpi_scan_hot_remove(struct 
  	return 0;
  }
  
 -static int acpi_scan_device_not_present(struct acpi_device *adev)
 -{
 -	if (!acpi_device_enumerated(adev)) {
 -		dev_warn(&adev->dev, "Still not present\n");
 -		return -EALREADY;
 -	}
 -	acpi_bus_trim(adev);
 -	return 0;
 -}
 -
 -static int acpi_scan_device_check(struct acpi_device *adev)
 -{
 -	int error;
 -
 -	acpi_bus_get_status(adev);
 -	if (adev->status.present || adev->status.functional) {
 -		/*
 -		 * This function is only called for device objects for which
 -		 * matching scan handlers exist.  The only situation in which
 -		 * the scan handler is not attached to this device object yet
 -		 * is when the device has just appeared (either it wasn't
 -		 * present at all before or it was removed and then added
 -		 * again).
 -		 */
 -		if (adev->handler) {
 -			dev_warn(&adev->dev, "Already enumerated\n");
 -			return -EALREADY;
 -		}
 -		error = acpi_bus_scan(adev->handle);
 -		if (error) {
 -			dev_warn(&adev->dev, "Namespace scan failure\n");
 -			return error;
 -		}
 -		if (!adev->handler) {
 -			dev_warn(&adev->dev, "Enumeration failure\n");
 -			error = -ENODEV;
 -		}
 -	} else {
 -		error = acpi_scan_device_not_present(adev);
 -	}
 -	return error;
 -}
 -
 -static int acpi_scan_bus_check(struct acpi_device *adev)
 +void acpi_bus_device_eject(struct acpi_device *device, u32 ost_src)
  {
 -	struct acpi_scan_handler *handler = adev->handler;
 -	struct acpi_device *child;
 +	acpi_handle handle = device->handle;
 +	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
  	int error;
  
 -	acpi_bus_get_status(adev);
 -	if (!(adev->status.present || adev->status.functional)) {
 -		acpi_scan_device_not_present(adev);
 -		return 0;
 -	}
 -	if (handler && handler->hotplug.scan_dependent)
 -		return handler->hotplug.scan_dependent(adev);
 -
 -	error = acpi_bus_scan(adev->handle);
 -	if (error) {
 -		dev_warn(&adev->dev, "Namespace scan failure\n");
 -		return error;
 -	}
 -	list_for_each_entry(child, &adev->children, node) {
 -		error = acpi_scan_bus_check(child);
 -		if (error)
 -			return error;
 -	}
 -	return 0;
 -}
 +	lock_device_hotplug();
 +	mutex_lock(&acpi_scan_lock);
  
 -static int acpi_generic_hotplug_event(struct acpi_device *adev, u32 type)
 -{
 -	switch (type) {
 -	case ACPI_NOTIFY_BUS_CHECK:
 -		return acpi_scan_bus_check(adev);
 -	case ACPI_NOTIFY_DEVICE_CHECK:
 -		return acpi_scan_device_check(adev);
 -	case ACPI_NOTIFY_EJECT_REQUEST:
 -	case ACPI_OST_EC_OSPM_EJECT:
 -		if (adev->handler && !adev->handler->hotplug.enabled) {
 -			dev_info(&adev->dev, "Eject disabled\n");
 -			return -EPERM;
 -		}
 -		acpi_evaluate_hotplug_ost(adev->handle, ACPI_NOTIFY_EJECT_REQUEST,
 +	if (ost_src == ACPI_NOTIFY_EJECT_REQUEST)
 +		acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
  					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 -		return acpi_scan_hot_remove(adev);
 -	}
 -	return -EINVAL;
 -}
  
 -void acpi_device_hotplug(void *data, u32 src)
 -{
 -	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 -	struct acpi_device *adev = data;
 -	int error = -ENODEV;
 -
 -	lock_device_hotplug();
 -	mutex_lock(&acpi_scan_lock);
 +	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
 +		kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
  
 -	/*
 -	 * The device object's ACPI handle cannot become invalid as long as we
 -	 * are holding acpi_scan_lock, but it might have become invalid before
 -	 * that lock was acquired.
 -	 */
 -	if (adev->handle == INVALID_ACPI_HANDLE)
 +	error = acpi_scan_hot_remove(device);
 +	if (error == -EPERM) {
 +		goto err_support;
 +	} else if (error) {
  		goto err_out;
++<<<<<<< HEAD
++=======
+ 
+ 	if (adev->flags.is_dock_station) {
+ 		error = dock_notify(adev, src);
+ 	} else if (adev->flags.hotplug_notify) {
+ 		error = acpi_generic_hotplug_event(adev, src);
+ 		if (error == -EPERM) {
+ 			ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
+ 			goto err_out;
+ 		}
+ 	} else {
+ 		int (*notify)(struct acpi_device *, u32);
+ 
+ 		acpi_lock_hp_context();
+ 		notify = adev->hp ? adev->hp->notify : NULL;
+ 		acpi_unlock_hp_context();
+ 		/*
+ 		 * There may be additional notify handlers for device objects
+ 		 * without the .event() callback, so ignore them here.
+ 		 */
+ 		if (notify)
+ 			error = notify(adev, src);
+ 		else
+ 			goto out;
++>>>>>>> be27b3dcb023 (ACPI / dock: Add .uevent() callback to struct acpi_hotplug_context)
  	}
 -	if (!error)
 -		ost_code = ACPI_OST_SC_SUCCESS;
  
 + out:
 +	mutex_unlock(&acpi_scan_lock);
 +	unlock_device_hotplug();
 +	return;
 +
 + err_support:
 +	ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
   err_out:
 -	acpi_evaluate_hotplug_ost(adev->handle, src, ost_code, NULL);
 +	acpi_evaluate_hotplug_ost(handle, ost_src, ost_code, NULL);
 +	goto out;
 +}
 +
 +static void acpi_scan_bus_device_check(acpi_handle handle, u32 ost_source)
 +{
 +	struct acpi_device *device = NULL;
 +	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 +	int error;
 +
 +	lock_device_hotplug();
 +	mutex_lock(&acpi_scan_lock);
 +
 +	if (ost_source != ACPI_NOTIFY_BUS_CHECK) {
 +		acpi_bus_get_device(handle, &device);
 +		if (device) {
 +			dev_warn(&device->dev, "Attempt to re-insert\n");
 +			goto out;
 +		}
 +	}
 +	error = acpi_bus_scan(handle);
 +	if (error) {
 +		acpi_handle_warn(handle, "Namespace scan failure\n");
 +		goto out;
 +	}
 +	error = acpi_bus_get_device(handle, &device);
 +	if (error) {
 +		acpi_handle_warn(handle, "Missing device node object\n");
 +		goto out;
 +	}
 +	ost_code = ACPI_OST_SC_SUCCESS;
 +	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
 +		kobject_uevent(&device->dev.kobj, KOBJ_ONLINE);
  
   out:
 -	acpi_bus_put_acpi_device(adev);
 +	acpi_evaluate_hotplug_ost(handle, ost_source, ost_code, NULL);
  	mutex_unlock(&acpi_scan_lock);
  	unlock_device_hotplug();
  }
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,a92b8b017901..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -58,25 -59,67 +58,77 @@@
  static LIST_HEAD(bridge_list);
  static DEFINE_MUTEX(bridge_mutex);
  
++<<<<<<< HEAD
 +static void handle_hotplug_event_bridge (acpi_handle, u32, void *);
++=======
+ static int acpiphp_hotplug_notify(struct acpi_device *adev, u32 type);
+ static void acpiphp_post_dock_fixup(struct acpi_device *adev);
++>>>>>>> be27b3dcb023 (ACPI / dock: Add .uevent() callback to struct acpi_hotplug_context)
  static void acpiphp_sanitize_bus(struct pci_bus *bus);
  static void acpiphp_set_hpp_values(struct pci_bus *bus);
 -static void hotplug_event(u32 type, struct acpiphp_context *context);
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context);
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type, void *context);
  static void free_bridge(struct kref *kref);
  
 -/**
 - * acpiphp_init_context - Create hotplug context and grab a reference to it.
 - * @adev: ACPI device object to create the context for.
 - *
 - * Call under acpi_hp_context_lock.
 - */
 -static struct acpiphp_context *acpiphp_init_context(struct acpi_device *adev)
 +/* callback routine to check for the existence of a pci dock device */
 +static acpi_status
 +is_pci_dock_device(acpi_handle handle, u32 lvl, void *context, void **rv)
  {
 -	struct acpiphp_context *context;
 +	int *count = (int *)context;
  
++<<<<<<< HEAD
 +	if (is_dock_device(handle)) {
 +		(*count)++;
 +		return AE_CTRL_TERMINATE;
 +	} else {
 +		return AE_OK;
 +	}
++=======
+ 	context = kzalloc(sizeof(*context), GFP_KERNEL);
+ 	if (!context)
+ 		return NULL;
+ 
+ 	context->refcount = 1;
+ 	acpi_set_hp_context(adev, &context->hp, acpiphp_hotplug_notify, NULL,
+ 			    acpiphp_post_dock_fixup);
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_get_context - Get hotplug context and grab a reference to it.
+  * @adev: ACPI device object to get the context for.
+  *
+  * Call under acpi_hp_context_lock.
+  */
+ static struct acpiphp_context *acpiphp_get_context(struct acpi_device *adev)
+ {
+ 	struct acpiphp_context *context;
+ 
+ 	if (!adev->hp)
+ 		return NULL;
+ 
+ 	context = to_acpiphp_context(adev->hp);
+ 	context->refcount++;
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_put_context - Drop a reference to ACPI hotplug context.
+  * @context: ACPI hotplug context to drop a reference to.
+  *
+  * The context object is removed if there are no more references to it.
+  *
+  * Call under acpi_hp_context_lock.
+  */
+ static void acpiphp_put_context(struct acpiphp_context *context)
+ {
+ 	if (--context->refcount)
+ 		return;
+ 
+ 	WARN_ON(context->bridge);
+ 	context->hp.self->hp = NULL;
+ 	kfree(context);
++>>>>>>> be27b3dcb023 (ACPI / dock: Add .uevent() callback to struct acpi_hotplug_context)
  }
  
  static inline void get_bridge(struct acpiphp_bridge *bridge)
@@@ -473,19 -397,16 +525,28 @@@ static void cleanup_bridge(struct acpip
  
  	list_for_each_entry(slot, &bridge->slots, node) {
  		list_for_each_entry(func, &slot->funcs, sibling) {
++<<<<<<< HEAD
 +			if (is_dock_device(func->handle)) {
 +				unregister_hotplug_dock_device(func->handle);
 +				unregister_dock_notifier(&func->nb);
 +			}
 +			if (!(func->flags & FUNC_HAS_DCK)) {
 +				status = acpi_remove_notify_handler(func->handle,
 +						ACPI_SYSTEM_NOTIFY,
 +						handle_hotplug_event_func);
 +				if (ACPI_FAILURE(status))
 +					pr_err("failed to remove notify handler\n");
 +			}
++=======
+ 			struct acpi_device *adev = func_to_acpi_device(func);
+ 
+ 			acpi_lock_hp_context();
+ 			adev->hp->notify = NULL;
+ 			adev->hp->fixup = NULL;
+ 			acpi_unlock_hp_context();
++>>>>>>> be27b3dcb023 (ACPI / dock: Add .uevent() callback to struct acpi_hotplug_context)
  		}
 -		slot->flags |= SLOT_IS_GOING_AWAY;
 -		if (slot->slot)
 -			acpiphp_unregister_hotplug_slot(slot);
 +		acpiphp_unregister_hotplug_slot(slot);
  	}
  
  	mutex_lock(&bridge_mutex);
@@@ -1054,115 -828,22 +1115,119 @@@ static void _handle_hotplug_event_bridg
  		break;
  	}
  
 -	pci_unlock_rescan_remove();
 -	if (bridge)
 -		put_bridge(bridge);
 +	acpi_scan_lock_release();
 +	kfree(hp_work); /* allocated in handle_hotplug_event_bridge */
 +	put_bridge(bridge);
  }
  
++<<<<<<< HEAD
 +/**
 + * handle_hotplug_event_bridge - handle ACPI event on bridges
 + * @handle: Notify()'ed acpi_handle
 + * @type: Notify code
 + * @context: pointer to acpiphp_bridge structure
 + *
 + * Handles ACPI event notification on {host,p2p} bridges.
 + */
 +static void handle_hotplug_event_bridge(acpi_handle handle, u32 type,
 +					void *context)
++=======
+ static int acpiphp_hotplug_notify(struct acpi_device *adev, u32 type)
++>>>>>>> be27b3dcb023 (ACPI / dock: Add .uevent() callback to struct acpi_hotplug_context)
  {
 -	struct acpiphp_context *context;
 +	struct acpiphp_bridge *bridge = context;
  
 -	context = acpiphp_grab_context(adev);
 -	if (!context)
 -		return -ENODATA;
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_bridge);
 +}
  
 -	hotplug_event(type, context);
 -	acpiphp_let_context_go(context);
 -	return 0;
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context)
 +{
 +	struct acpiphp_func *func = context;
 +	char objname[64];
 +	struct acpi_buffer buffer = { .length = sizeof(objname),
 +				      .pointer = objname };
 +
 +	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 +
 +	switch (type) {
 +	case ACPI_NOTIFY_BUS_CHECK:
 +		/* bus re-enumerate */
 +		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
 +		acpiphp_enable_slot(func->slot);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_CHECK:
 +		/* device check : re-enumerate from parent bus */
 +		pr_debug("%s: Device check notify on %s\n", __func__, objname);
 +		acpiphp_check_bridge(func->slot->bridge);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_WAKE:
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
 +		break;
 +
 +	case ACPI_NOTIFY_EJECT_REQUEST:
 +		/* request device eject */
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if (!(acpiphp_disable_slot(func->slot)))
 +			acpiphp_eject_slot(func->slot);
 +		break;
 +
 +	default:
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
 +		break;
 +	}
 +}
 +
 +static void _handle_hotplug_event_func(struct work_struct *work)
 +{
 +	struct acpi_hp_work *hp_work;
 +	struct acpiphp_func *func;
 +
 +	hp_work = container_of(work, struct acpi_hp_work, work);
 +	func = hp_work->context;
 +	acpi_scan_lock_acquire();
 +
 +	hotplug_event_func(hp_work->handle, hp_work->type, func);
 +
 +	acpi_scan_lock_release();
 +	kfree(hp_work); /* allocated in handle_hotplug_event_func */
 +	put_bridge(func->slot->bridge);
 +}
 +
 +/**
 + * handle_hotplug_event_func - handle ACPI event on functions (i.e. slots)
 + * @handle: Notify()'ed acpi_handle
 + * @type: Notify code
 + * @context: pointer to acpiphp_func structure
 + *
 + * Handles ACPI event notification on slots.
 + */
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type,
 +				      void *context)
 +{
 +	struct acpiphp_func *func = context;
 +
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(func->slot->bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_func);
  }
  
  /**
diff --cc include/acpi/acpi_bus.h
index 717f4adcfbd4,738278606677..000000000000
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@@ -124,6 -137,18 +124,21 @@@ struct acpi_scan_handler 
  };
  
  /*
++<<<<<<< HEAD
++=======
+  * ACPI Hotplug Context
+  * --------------------
+  */
+ 
+ struct acpi_hotplug_context {
+ 	struct acpi_device *self;
+ 	int (*notify)(struct acpi_device *, u32);
+ 	void (*uevent)(struct acpi_device *, u32);
+ 	void (*fixup)(struct acpi_device *);
+ };
+ 
+ /*
++>>>>>>> be27b3dcb023 (ACPI / dock: Add .uevent() callback to struct acpi_hotplug_context)
   * ACPI Driver
   * -----------
   */
@@@ -327,6 -361,24 +342,27 @@@ static inline void *acpi_driver_data(st
  #define to_acpi_device(d)	container_of(d, struct acpi_device, dev)
  #define to_acpi_driver(d)	container_of(d, struct acpi_driver, drv)
  
++<<<<<<< HEAD
++=======
+ static inline void acpi_set_device_status(struct acpi_device *adev, u32 sta)
+ {
+ 	*((u32 *)&adev->status) = sta;
+ }
+ 
+ static inline void acpi_set_hp_context(struct acpi_device *adev,
+ 				       struct acpi_hotplug_context *hp,
+ 				       int (*notify)(struct acpi_device *, u32),
+ 				       void (*uevent)(struct acpi_device *, u32),
+ 				       void (*fixup)(struct acpi_device *))
+ {
+ 	hp->self = adev;
+ 	hp->notify = notify;
+ 	hp->uevent = uevent;
+ 	hp->fixup = fixup;
+ 	adev->hp = hp;
+ }
+ 
++>>>>>>> be27b3dcb023 (ACPI / dock: Add .uevent() callback to struct acpi_hotplug_context)
  /* acpi_device.dev.bus == &acpi_bus_type */
  extern struct bus_type acpi_bus_type;
  
* Unmerged path drivers/acpi/dock.c
* Unmerged path drivers/acpi/scan.c
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
* Unmerged path include/acpi/acpi_bus.h
