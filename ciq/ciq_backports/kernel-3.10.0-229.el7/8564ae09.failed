qlcnic: Fix MSI-X initialization code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Alexander Gordeev <agordeev@redhat.com>
commit 8564ae09e08340a26c5408637cc4b32dba9f1640
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/8564ae09.failed

Function qlcnic_setup_tss_rss_intr() might enter endless
loop in case pci_enable_msix() contiguously returns a
positive number of MSI-Xs that could have been allocated.
Besides, the function contains 'err = -EIO;' assignment
that never could be reached. This update fixes the
aforementioned issues.

	Cc: Shahed Shaikh <shahed.shaikh@qlogic.com>
	Cc: Dept-HSGLinuxNICDev@qlogic.com
	Cc: netdev@vger.kernel.org
	Cc: linux-pci@vger.kernel.org

	Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
	Acked-by: Shahed Shaikh <shahed.shaikh@qlogic.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8564ae09e08340a26c5408637cc4b32dba9f1640)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index 3b17c83155ba,dbf75393f758..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@@ -567,6 -619,115 +567,118 @@@ static void qlcnic_get_multiq_capabilit
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int qlcnic_max_rings(struct qlcnic_adapter *adapter, u8 ring_cnt,
+ 			    int queue_type)
+ {
+ 	int num_rings, max_rings = QLCNIC_MAX_SDS_RINGS;
+ 
+ 	if (queue_type == QLCNIC_RX_QUEUE)
+ 		max_rings = adapter->max_sds_rings;
+ 	else if (queue_type == QLCNIC_TX_QUEUE)
+ 		max_rings = adapter->max_tx_rings;
+ 
+ 	num_rings = rounddown_pow_of_two(min_t(int, num_online_cpus(),
+ 					      max_rings));
+ 
+ 	if (ring_cnt > num_rings)
+ 		return num_rings;
+ 	else
+ 		return ring_cnt;
+ }
+ 
+ void qlcnic_set_tx_ring_count(struct qlcnic_adapter *adapter, u8 tx_cnt)
+ {
+ 	/* 83xx adapter does not have max_tx_rings intialized in probe */
+ 	if (adapter->max_tx_rings)
+ 		adapter->drv_tx_rings = qlcnic_max_rings(adapter, tx_cnt,
+ 							 QLCNIC_TX_QUEUE);
+ 	else
+ 		adapter->drv_tx_rings = tx_cnt;
+ }
+ 
+ void qlcnic_set_sds_ring_count(struct qlcnic_adapter *adapter, u8 rx_cnt)
+ {
+ 	/* 83xx adapter does not have max_sds_rings intialized in probe */
+ 	if (adapter->max_sds_rings)
+ 		adapter->drv_sds_rings = qlcnic_max_rings(adapter, rx_cnt,
+ 							  QLCNIC_RX_QUEUE);
+ 	else
+ 		adapter->drv_sds_rings = rx_cnt;
+ }
+ 
+ int qlcnic_setup_tss_rss_intr(struct qlcnic_adapter *adapter)
+ {
+ 	struct pci_dev *pdev = adapter->pdev;
+ 	int num_msix = 0, err = 0, vector;
+ 
+ 	adapter->flags &= ~QLCNIC_TSS_RSS;
+ 
+ 	if (adapter->drv_tss_rings > 0)
+ 		num_msix += adapter->drv_tss_rings;
+ 	else
+ 		num_msix += adapter->drv_tx_rings;
+ 
+ 	if (adapter->drv_rss_rings > 0)
+ 		num_msix += adapter->drv_rss_rings;
+ 	else
+ 		num_msix += adapter->drv_sds_rings;
+ 
+ 	if (qlcnic_83xx_check(adapter))
+ 		num_msix += 1;
+ 
+ 	if (!adapter->msix_entries) {
+ 		adapter->msix_entries = kcalloc(num_msix,
+ 						sizeof(struct msix_entry),
+ 						GFP_KERNEL);
+ 		if (!adapter->msix_entries)
+ 			return -ENOMEM;
+ 	}
+ 
+ 	for (vector = 0; vector < num_msix; vector++)
+ 		adapter->msix_entries[vector].entry = vector;
+ 
+ restore:
+ 	err = pci_enable_msix(pdev, adapter->msix_entries, num_msix);
+ 	if (err > 0) {
+ 		if (!adapter->drv_tss_rings && !adapter->drv_rss_rings)
+ 			return -ENOSPC;
+ 
+ 		netdev_info(adapter->netdev,
+ 			    "Unable to allocate %d MSI-X vectors, Available vectors %d\n",
+ 			    num_msix, err);
+ 
+ 		num_msix = adapter->drv_tx_rings + adapter->drv_sds_rings;
+ 
+ 		/* Set rings to 0 so we can restore original TSS/RSS count */
+ 		adapter->drv_tss_rings = 0;
+ 		adapter->drv_rss_rings = 0;
+ 
+ 		if (qlcnic_83xx_check(adapter))
+ 			num_msix += 1;
+ 
+ 		netdev_info(adapter->netdev,
+ 			    "Restoring %d Tx, %d SDS rings for total %d vectors.\n",
+ 			    adapter->drv_tx_rings, adapter->drv_sds_rings,
+ 			    num_msix);
+ 
+ 		goto restore;
+ 	} else if (err < 0) {
+ 		return err;
+ 	}
+ 
+ 	adapter->ahw->num_msix = num_msix;
+ 	if (adapter->drv_tss_rings > 0)
+ 		adapter->drv_tx_rings = adapter->drv_tss_rings;
+ 
+ 	if (adapter->drv_rss_rings > 0)
+ 		adapter->drv_sds_rings = adapter->drv_rss_rings;
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 8564ae09e083 (qlcnic: Fix MSI-X initialization code)
  int qlcnic_enable_msix(struct qlcnic_adapter *adapter, u32 num_msix)
  {
  	struct pci_dev *pdev = adapter->pdev;
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
