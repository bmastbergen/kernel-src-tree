tcp: syncookies: do not use getnstimeofday()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 632623153196bf183a69686ed9c07eee98ff1bf8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/63262315.failed

While it is true that getnstimeofday() uses about 40 cycles if TSC
is available, it can use 1600 cycles if hpet is the clocksource.

Switch to get_jiffies_64(), as this is more than enough, and
go back to 60 seconds periods.

Fixes: 8c27bd75f04f ("tcp: syncookies: reduce cookie lifetime to 128 seconds")
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Florian Westphal <fw@strlen.de>
	Acked-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 632623153196bf183a69686ed9c07eee98ff1bf8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/tcp.h
diff --cc include/net/tcp.h
index 66c0e9e62cd5,743accec6c76..000000000000
--- a/include/net/tcp.h
+++ b/include/net/tcp.h
@@@ -482,16 -473,33 +482,41 @@@ int tcp_send_rcvq(struct sock *sk, stru
  void inet_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb);
  
  /* From syncookies.c */
 -int __cookie_v4_check(const struct iphdr *iph, const struct tcphdr *th,
 -		      u32 cookie);
 -struct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb,
 -			     struct ip_options *opt);
 +extern __u32 syncookie_secret[2][16-4+SHA_DIGEST_WORDS];
 +extern int __cookie_v4_check(const struct iphdr *iph, const struct tcphdr *th,
 +			     u32 cookie);
 +extern struct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb, 
 +				    struct ip_options *opt);
  #ifdef CONFIG_SYN_COOKIES
++<<<<<<< HEAD
 +extern u32 __cookie_v4_init_sequence(const struct iphdr *iph,
 +				     const struct tcphdr *th, u16 *mssp);
 +extern __u32 cookie_v4_init_sequence(struct sock *sk, struct sk_buff *skb, 
 +				     __u16 *mss);
++=======
+ #include <linux/ktime.h>
+ 
+ /* Syncookies use a monotonic timer which increments every 60 seconds.
+  * This counter is used both as a hash input and partially encoded into
+  * the cookie value.  A cookie is only validated further if the delta
+  * between the current counter value and the encoded one is less than this,
+  * i.e. a sent cookie is valid only at most for 2*60 seconds (or less if
+  * the counter advances immediately after a cookie is generated).
+  */
+ #define MAX_SYNCOOKIE_AGE 2
+ 
+ static inline u32 tcp_cookie_time(void)
+ {
+ 	u64 val = get_jiffies_64();
+ 
+ 	do_div(val, 60 * HZ);
+ 	return val;
+ }
+ 
+ u32 __cookie_v4_init_sequence(const struct iphdr *iph, const struct tcphdr *th,
+ 			      u16 *mssp);
+ __u32 cookie_v4_init_sequence(struct sock *sk, struct sk_buff *skb, __u16 *mss);
++>>>>>>> 632623153196 (tcp: syncookies: do not use getnstimeofday())
  #else
  static inline __u32 cookie_v4_init_sequence(struct sock *sk,
  					    struct sk_buff *skb,
* Unmerged path include/net/tcp.h
