net: Call skb_checksum_init in IPv6

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] ipv6: Call skb_checksum_init in IPv6 (Florian Westphal) [1131999]
Rebuild_FUZZ: 90.14%
commit-author Tom Herbert <therbert@google.com>
commit e4f45b7f40bdaade5ef8f45e7c6daed4c909fdf5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e4f45b7f.failed

Call skb_checksum_init instead of private functions.

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e4f45b7f40bdaade5ef8f45e7c6daed4c909fdf5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/tcp_ipv6.c
diff --cc net/ipv6/tcp_ipv6.c
index d94101e787b7,7fa67439f4d6..000000000000
--- a/net/ipv6/tcp_ipv6.c
+++ b/net/ipv6/tcp_ipv6.c
@@@ -1277,26 -1294,6 +1277,29 @@@ out
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static __sum16 tcp_v6_checksum_init(struct sk_buff *skb)
 +{
 +	if (skb->ip_summed == CHECKSUM_COMPLETE) {
 +		if (!tcp_v6_check(skb->len, &ipv6_hdr(skb)->saddr,
 +				  &ipv6_hdr(skb)->daddr, skb->csum)) {
 +			skb->ip_summed = CHECKSUM_UNNECESSARY;
 +			return 0;
 +		}
 +	}
 +
 +	skb->csum = ~csum_unfold(tcp_v6_check(skb->len,
 +					      &ipv6_hdr(skb)->saddr,
 +					      &ipv6_hdr(skb)->daddr, 0));
 +
 +	if (skb->len <= 76) {
 +		return __skb_checksum_complete(skb);
 +	}
 +	return 0;
 +}
 +
++=======
++>>>>>>> e4f45b7f40bd (net: Call skb_checksum_init in IPv6)
  /* The socket must have it's spinlock held when we get
   * here.
   *
diff --git a/include/net/ip6_checksum.h b/include/net/ip6_checksum.h
index 9e3c540c1b11..8ac5c21f8456 100644
--- a/include/net/ip6_checksum.h
+++ b/include/net/ip6_checksum.h
@@ -41,6 +41,13 @@ __sum16 csum_ipv6_magic(const struct in6_addr *saddr,
 			__wsum csum);
 #endif
 
+static inline __wsum ip6_compute_pseudo(struct sk_buff *skb, int proto)
+{
+	return ~csum_unfold(csum_ipv6_magic(&ipv6_hdr(skb)->saddr,
+					    &ipv6_hdr(skb)->daddr,
+					    skb->len, proto, 0));
+}
+
 static __inline__ __sum16 tcp_v6_check(int len,
 				   const struct in6_addr *saddr,
 				   const struct in6_addr *daddr,
diff --git a/net/ipv6/ip6_checksum.c b/net/ipv6/ip6_checksum.c
index 72d198b8e4d2..53f28da93266 100644
--- a/net/ipv6/ip6_checksum.c
+++ b/net/ipv6/ip6_checksum.c
@@ -82,16 +82,7 @@ int udp6_csum_init(struct sk_buff *skb, struct udphdr *uh, int proto)
 		LIMIT_NETDEBUG(KERN_INFO "IPv6: udp checksum is 0\n");
 		return 1;
 	}
-	if (skb->ip_summed == CHECKSUM_COMPLETE &&
-	    !csum_ipv6_magic(&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr,
-			     skb->len, proto, skb->csum))
-		skb->ip_summed = CHECKSUM_UNNECESSARY;
 
-	if (!skb_csum_unnecessary(skb))
-		skb->csum = ~csum_unfold(csum_ipv6_magic(&ipv6_hdr(skb)->saddr,
-							 &ipv6_hdr(skb)->daddr,
-							 skb->len, proto, 0));
-
-	return 0;
+	return skb_checksum_init(skb, IPPROTO_UDP, ip6_compute_pseudo);
 }
 EXPORT_SYMBOL(udp6_csum_init);
* Unmerged path net/ipv6/tcp_ipv6.c
