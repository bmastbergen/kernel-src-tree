e1000e: Fix EEE in S5 w/ Runtime PM enabled

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author David Ertman <david.m.ertman@intel.com>
commit 2116bc25e8aefd76503dfa2fc328eb8da684bb38
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2116bc25.failed

The process of shutting down the system causes a call to the close PM
callback.  The reset in close causes a loss of link, and the resultant
LSC interrupt causes the Runtime PM idle callback to be called.  The
check for link (while link is down) in the idle callback is wiping the
information about the EEE ability of the link partner.  The information is
still gone when the PHY is powered back up in the shutdown flow.  This
causes EEE in S5 to fail when Runtime PM is active.

Save the link partner's EEE ability in the idle callback so that a Runtime
PM event will not cause a loss of this information.

	Signed-off-by: Dave Ertman <david.m.ertman@intel.com>
	Tested-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 2116bc25e8aefd76503dfa2fc328eb8da684bb38)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/e1000e/netdev.c
diff --cc drivers/net/ethernet/intel/e1000e/netdev.c
index 3dc2552664d3,1ce0d743029c..000000000000
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@@ -6314,32 -6357,36 +6314,41 @@@ static int e1000_runtime_suspend(struc
  	struct pci_dev *pdev = to_pci_dev(dev);
  	struct net_device *netdev = pci_get_drvdata(pdev);
  	struct e1000_adapter *adapter = netdev_priv(netdev);
+ 	u16 eee_lp;
  
 -	eee_lp = adapter->hw.dev_spec.ich8lan.eee_lp_ability;
 -
 -	if (!e1000e_has_link(adapter)) {
 -		adapter->hw.dev_spec.ich8lan.eee_lp_ability = eee_lp;
 -		pm_schedule_suspend(dev, 5 * MSEC_PER_SEC);
 -	}
++<<<<<<< HEAD
 +	if (!e1000e_pm_ready(adapter))
 +		return 0;
  
 -	return -EBUSY;
 +	return __e1000_shutdown(pdev, true);
  }
  
 -static int e1000e_pm_runtime_resume(struct device *dev)
 +static int e1000_idle(struct device *dev)
  {
  	struct pci_dev *pdev = to_pci_dev(dev);
  	struct net_device *netdev = pci_get_drvdata(pdev);
  	struct e1000_adapter *adapter = netdev_priv(netdev);
 -	int rc;
  
 -	rc = __e1000_resume(pdev);
 -	if (rc)
 -		return rc;
 +	if (!e1000e_pm_ready(adapter))
 +		return 0;
  
 -	if (netdev->flags & IFF_UP)
 -		rc = e1000e_up(adapter);
 +	if (adapter->idle_check) {
 +		adapter->idle_check = false;
 +		if (!e1000e_has_link(adapter))
 +			pm_schedule_suspend(dev, MSEC_PER_SEC);
++=======
++	eee_lp = adapter->hw.dev_spec.ich8lan.eee_lp_ability;
+ 
 -	return rc;
++	if (!e1000e_has_link(adapter)) {
++		adapter->hw.dev_spec.ich8lan.eee_lp_ability = eee_lp;
++		pm_schedule_suspend(dev, 5 * MSEC_PER_SEC);
++>>>>>>> 2116bc25e8ae (e1000e: Fix EEE in S5 w/ Runtime PM enabled)
 +	}
 +
 +	return -EBUSY;
  }
  
 -static int e1000e_pm_runtime_suspend(struct device *dev)
 +static int e1000_runtime_resume(struct device *dev)
  {
  	struct pci_dev *pdev = to_pci_dev(dev);
  	struct net_device *netdev = pci_get_drvdata(pdev);
* Unmerged path drivers/net/ethernet/intel/e1000e/netdev.c
