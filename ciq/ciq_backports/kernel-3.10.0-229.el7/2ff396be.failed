aio: add missing smp_rmb() in read_events_ring

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Jeff Moyer <jmoyer@redhat.com>
commit 2ff396be602f10b5eab8e73b24f20348fa2de159
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2ff396be.failed

We ran into a case on ppc64 running mariadb where io_getevents would
return zeroed out I/O events.  After adding instrumentation, it became
clear that there was some missing synchronization between reading the
tail pointer and the events themselves.  This small patch fixes the
problem in testing.

Thanks to Zach for helping to look into this, and suggesting the fix.

	Signed-off-by: Jeff Moyer <jmoyer@redhat.com>
	Signed-off-by: Benjamin LaHaise <bcrl@kvack.org>
	Cc: stable@vger.kernel.org
(cherry picked from commit 2ff396be602f10b5eab8e73b24f20348fa2de159)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/aio.c
diff --cc fs/aio.c
index e90f40ffd1ab,5f2e9c6c328e..000000000000
--- a/fs/aio.c
+++ b/fs/aio.c
@@@ -922,15 -1105,26 +922,25 @@@ static long aio_read_events_ring(struc
  
  	mutex_lock(&ctx->ring_lock);
  
 -	/* Access to ->ring_pages here is protected by ctx->ring_lock. */
  	ring = kmap_atomic(ctx->ring_pages[0]);
  	head = ring->head;
 -	tail = ring->tail;
  	kunmap_atomic(ring);
  
++<<<<<<< HEAD
 +	pr_debug("h%u t%u m%u\n", head, ctx->tail, ctx->nr_events);
++=======
+ 	/*
+ 	 * Ensure that once we've read the current tail pointer, that
+ 	 * we also see the events that were stored up to the tail.
+ 	 */
+ 	smp_rmb();
+ 
+ 	pr_debug("h%u t%u m%u\n", head, tail, ctx->nr_events);
++>>>>>>> 2ff396be602f (aio: add missing smp_rmb() in read_events_ring)
  
 -	if (head == tail)
 +	if (head == ctx->tail)
  		goto out;
  
 -	head %= ctx->nr_events;
 -	tail %= ctx->nr_events;
 -
  	while (ret < nr) {
  		long avail;
  		struct io_event *ev;
* Unmerged path fs/aio.c
