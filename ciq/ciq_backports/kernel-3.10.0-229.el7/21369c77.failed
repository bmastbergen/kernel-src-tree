ACPI / hotplug / PCI: Execute _EJ0 under the ACPI scan lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Execute _EJ0 under the ACPI scan lock (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 91.74%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 21369c77477a7f937174833c8094154f0f995710
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/21369c77.failed

Since acpi_device_hotplug() assumes that ACPI handles of device
objects passed to it will not become invalid while acpi_scan_lock
is being held, make acpiphp_disable_slot() acquire acpi_scan_lock,
because it generally causes _EJ0 to be executed for one of the
devices in the slot and that may cause its ACPI handle to become
invalid.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 21369c77477a7f937174833c8094154f0f995710)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,fa8fe7441952..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -1263,31 -977,48 +1263,44 @@@ int acpiphp_enable_slot(struct acpiphp_
  }
  
  /**
 - * acpiphp_disable_and_eject_slot - power off and eject slot
 + * acpiphp_disable_slot - power off slot
   * @slot: ACPI PHP slot
   */
 -static int acpiphp_disable_and_eject_slot(struct acpiphp_slot *slot)
 +int acpiphp_disable_slot(struct acpiphp_slot *slot)
  {
 -	struct acpiphp_func *func;
 +	int retval = 0;
  
 -	if (slot->flags & SLOT_IS_GOING_AWAY)
 -		return -ENODEV;
++<<<<<<< HEAD
 +	mutex_lock(&slot->crit_sect);
  
  	/* unconfigure all functions */
 -	disable_slot(slot);
 -
 -	list_for_each_entry(func, &slot->funcs, sibling)
 -		if (func->flags & FUNC_HAS_EJ0) {
 -			acpi_handle handle = func_to_handle(func);
 -
 -			if (ACPI_FAILURE(acpi_evaluate_ej0(handle)))
 -				acpi_handle_err(handle, "_EJ0 failed\n");
 -
 -			break;
 -		}
 -
 -	return 0;
 -}
 -
 -int acpiphp_disable_slot(struct acpiphp_slot *slot)
 -{
 -	int ret;
 -
 +	retval = disable_device(slot);
 +	if (retval)
 +		goto err_exit;
 +
 +	/* power off all functions */
 +	retval = power_off_slot(slot);
 +	if (retval)
 +		goto err_exit;
 +
 + err_exit:
 +	mutex_unlock(&slot->crit_sect);
 +	return retval;
++=======
+ 	/*
+ 	 * Acquire acpi_scan_lock to ensure that the execution of _EJ0 in
+ 	 * acpiphp_disable_and_eject_slot() will be synchronized properly.
+ 	 */
+ 	acpi_scan_lock_acquire();
+ 	pci_lock_rescan_remove();
+ 	ret = acpiphp_disable_and_eject_slot(slot);
+ 	pci_unlock_rescan_remove();
+ 	acpi_scan_lock_release();
+ 	return ret;
++>>>>>>> 21369c77477a (ACPI / hotplug / PCI: Execute _EJ0 under the ACPI scan lock)
  }
  
 +
  /*
   * slot enabled:  1
   * slot disabled: 0
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
