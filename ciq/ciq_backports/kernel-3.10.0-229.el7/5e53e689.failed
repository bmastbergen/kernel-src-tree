genetlink/pmcraid: use proper genetlink multicast API

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [scsi] pmcraid: use proper genetlink multicast API (Jiri Benc) [1140656]
Rebuild_FUZZ: 89.58%
commit-author Johannes Berg <johannes.berg@intel.com>
commit 5e53e689b737526308db2b5c9f56e9d0371a1676
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5e53e689.failed

The pmcraid driver is abusing the genetlink API and is using its
family ID as the multicast group ID, which is invalid and may
belong to somebody else (and likely will.)

Make it use the correct API, but since this may already be used
as-is by userspace, reserve a family ID for this code and also
reserve that group ID to not break userspace assumptions.

My previous patch broke event delivery in the driver as I missed
that it wasn't using the right API and forgot to update it later
in my series.

While changing this, I noticed that the genetlink code could use
the static group ID instead of a strcmp(), so also do that for
the VFS_DQUOT family.

	Cc: Anil Ravindranath <anil_ravindranath@pmc-sierra.com>
	Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5e53e689b737526308db2b5c9f56e9d0371a1676)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/pmcraid.c
#	net/netlink/genetlink.c
diff --cc drivers/scsi/pmcraid.c
index bfb72ec277c7,892ea6161376..000000000000
--- a/drivers/scsi/pmcraid.c
+++ b/drivers/scsi/pmcraid.c
@@@ -1511,8 -1522,8 +1522,13 @@@ static int pmcraid_notify_aen
  		return result;
  	}
  
++<<<<<<< HEAD
 +	result =
 +		genlmsg_multicast(skb, 0, pmcraid_event_family.id, GFP_ATOMIC);
++=======
+ 	result = genlmsg_multicast(&pmcraid_event_family, skb,
+ 				   0, 0, GFP_ATOMIC);
++>>>>>>> 5e53e689b737 (genetlink/pmcraid: use proper genetlink multicast API)
  
  	/* If there are no listeners, genlmsg_multicast may return non-zero
  	 * value.
diff --cc net/netlink/genetlink.c
index fa66966658bc,713671ae45af..000000000000
--- a/net/netlink/genetlink.c
+++ b/net/netlink/genetlink.c
@@@ -72,8 -72,14 +72,16 @@@ static struct list_head family_ht[GENL_
   * Bit 17 is marked as already used since the VFS quota code
   * also abused this API and relied on family == group ID, we
   * cater to that by giving it a static family and group ID.
+  * Bit 18 is marked as already used since the PMCRAID driver
+  * did the same thing as the VFS quota code (maybe copied?)
   */
++<<<<<<< HEAD
 +static unsigned long mc_group_start = 0x3 | BIT(GENL_ID_VFS_DQUOT);
++=======
+ static unsigned long mc_group_start = 0x3 | BIT(GENL_ID_CTRL) |
+ 				      BIT(GENL_ID_VFS_DQUOT) |
+ 				      BIT(GENL_ID_PMCRAID);
++>>>>>>> 5e53e689b737 (genetlink/pmcraid: use proper genetlink multicast API)
  static unsigned long *mc_groups = &mc_group_start;
  static unsigned long mc_groups_longs = 1;
  
@@@ -144,66 -152,113 +153,86 @@@ static u16 genl_generate_id(void
  	return 0;
  }
  
 -static int genl_allocate_reserve_groups(int n_groups, int *first_id)
 -{
 -	unsigned long *new_groups;
 -	int start = 0;
 -	int i;
 -	int id;
 -	bool fits;
 -
 -	do {
 -		if (start == 0)
 -			id = find_first_zero_bit(mc_groups,
 -						 mc_groups_longs *
 -						 BITS_PER_LONG);
 -		else
 -			id = find_next_zero_bit(mc_groups,
 -						mc_groups_longs * BITS_PER_LONG,
 -						start);
 -
 -		fits = true;
 -		for (i = id;
 -		     i < min_t(int, id + n_groups,
 -			       mc_groups_longs * BITS_PER_LONG);
 -		     i++) {
 -			if (test_bit(i, mc_groups)) {
 -				start = i;
 -				fits = false;
 -				break;
 -			}
 -		}
 -
 -		if (id >= mc_groups_longs * BITS_PER_LONG) {
 -			unsigned long new_longs = mc_groups_longs +
 -						  BITS_TO_LONGS(n_groups);
 -			size_t nlen = new_longs * sizeof(unsigned long);
 -
 -			if (mc_groups == &mc_group_start) {
 -				new_groups = kzalloc(nlen, GFP_KERNEL);
 -				if (!new_groups)
 -					return -ENOMEM;
 -				mc_groups = new_groups;
 -				*mc_groups = mc_group_start;
 -			} else {
 -				new_groups = krealloc(mc_groups, nlen,
 -						      GFP_KERNEL);
 -				if (!new_groups)
 -					return -ENOMEM;
 -				mc_groups = new_groups;
 -				for (i = 0; i < BITS_TO_LONGS(n_groups); i++)
 -					mc_groups[mc_groups_longs + i] = 0;
 -			}
 -			mc_groups_longs = new_longs;
 -		}
 -	} while (!fits);
 +static struct genl_multicast_group notify_grp;
  
 -	for (i = id; i < id + n_groups; i++)
 -		set_bit(i, mc_groups);
 -	*first_id = id;
 -	return 0;
 -}
 -
 -static struct genl_family genl_ctrl;
 -
 -static int genl_validate_assign_mc_groups(struct genl_family *family)
 +/**
 + * genl_register_mc_group - register a multicast group
 + *
 + * Registers the specified multicast group and notifies userspace
 + * about the new group.
 + *
 + * Returns 0 on success or a negative error code.
 + *
 + * @family: The generic netlink family the group shall be registered for.
 + * @grp: The group to register, must have a name.
 + */
 +int genl_register_mc_group(struct genl_family *family,
 +			   struct genl_multicast_group *grp)
  {
 -	int first_id;
 -	int n_groups = family->n_mcgrps;
 -	int err = 0, i;
 -	bool groups_allocated = false;
 -
 -	if (!n_groups)
 -		return 0;
 +	int id;
 +	unsigned long *new_groups;
 +	int err = 0;
  
 -	for (i = 0; i < n_groups; i++) {
 -		const struct genl_multicast_group *grp = &family->mcgrps[i];
 +	BUG_ON(grp->name[0] == '\0');
 +	BUG_ON(memchr(grp->name, '\0', GENL_NAMSIZ) == NULL);
  
 -		if (WARN_ON(grp->name[0] == '\0'))
 -			return -EINVAL;
 -		if (WARN_ON(memchr(grp->name, '\0', GENL_NAMSIZ) == NULL))
 -			return -EINVAL;
 -	}
 +	genl_lock_all();
  
  	/* special-case our own group and hacks */
++<<<<<<< HEAD
 +	if (grp == &notify_grp)
 +		id = GENL_ID_CTRL;
 +	else if (strcmp(family->name, "NET_DM") == 0)
 +		id = 1;
 +	else if (strcmp(family->name, "VFS_DQUOT") == 0)
 +		id = GENL_ID_VFS_DQUOT;
 +	else
 +		id = find_first_zero_bit(mc_groups,
 +					 mc_groups_longs * BITS_PER_LONG);
 +
 +
 +	if (id >= mc_groups_longs * BITS_PER_LONG) {
 +		size_t nlen = (mc_groups_longs + 1) * sizeof(unsigned long);
 +
 +		if (mc_groups == &mc_group_start) {
 +			new_groups = kzalloc(nlen, GFP_KERNEL);
 +			if (!new_groups) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			mc_groups = new_groups;
 +			*mc_groups = mc_group_start;
 +		} else {
 +			new_groups = krealloc(mc_groups, nlen, GFP_KERNEL);
 +			if (!new_groups) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			mc_groups = new_groups;
 +			mc_groups[mc_groups_longs] = 0;
 +		}
 +		mc_groups_longs++;
++=======
+ 	if (family == &genl_ctrl) {
+ 		first_id = GENL_ID_CTRL;
+ 		BUG_ON(n_groups != 1);
+ 	} else if (strcmp(family->name, "NET_DM") == 0) {
+ 		first_id = 1;
+ 		BUG_ON(n_groups != 1);
+ 	} else if (family->id == GENL_ID_VFS_DQUOT) {
+ 		first_id = GENL_ID_VFS_DQUOT;
+ 		BUG_ON(n_groups != 1);
+ 	} else if (family->id == GENL_ID_PMCRAID) {
+ 		first_id = GENL_ID_PMCRAID;
+ 		BUG_ON(n_groups != 1);
+ 	} else {
+ 		groups_allocated = true;
+ 		err = genl_allocate_reserve_groups(n_groups, &first_id);
+ 		if (err)
+ 			return err;
++>>>>>>> 5e53e689b737 (genetlink/pmcraid: use proper genetlink multicast API)
  	}
  
 -	family->mcgrp_offset = first_id;
 -
 -	/* if still initializing, can't and don't need to to realloc bitmaps */
 -	if (!init_net.genl_sock)
 -		return 0;
 -
  	if (family->netnsok) {
  		struct net *net;
  
* Unmerged path drivers/scsi/pmcraid.c
diff --git a/include/uapi/linux/genetlink.h b/include/uapi/linux/genetlink.h
index 1af72d8228e0..c3363ba1ae05 100644
--- a/include/uapi/linux/genetlink.h
+++ b/include/uapi/linux/genetlink.h
@@ -28,6 +28,7 @@ struct genlmsghdr {
 #define GENL_ID_GENERATE	0
 #define GENL_ID_CTRL		NLMSG_MIN_TYPE
 #define GENL_ID_VFS_DQUOT	(NLMSG_MIN_TYPE + 1)
+#define GENL_ID_PMCRAID		(NLMSG_MIN_TYPE + 2)
 
 /**************************************************************************
  * Controller
* Unmerged path net/netlink/genetlink.c
