nfs: merge nfs_pgio_data into _header

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Weston Andros Adamson <dros@primarydata.com>
commit d45f60c67848b9f19160692581d78e5b4757a000
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d45f60c6.failed

struct nfs_pgio_data only exists as a member of nfs_pgio_header, but is
passed around everywhere, because there used to be multiple _data structs
per _header. Many of these functions then use the _data to find a pointer
to the _header.  This patch cleans this up by merging the nfs_pgio_data
structure into nfs_pgio_header and passing nfs_pgio_header around instead.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit d45f60c67848b9f19160692581d78e5b4757a000)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/blocklayout/blocklayout.c
#	fs/nfs/direct.c
#	fs/nfs/filelayout/filelayout.c
#	fs/nfs/internal.h
#	fs/nfs/nfs3proc.c
#	fs/nfs/nfs4_fs.h
#	fs/nfs/nfs4proc.c
#	fs/nfs/nfs4trace.h
#	fs/nfs/objlayout/objio_osd.c
#	fs/nfs/objlayout/objlayout.c
#	fs/nfs/objlayout/objlayout.h
#	fs/nfs/pagelist.c
#	fs/nfs/pnfs.c
#	fs/nfs/pnfs.h
#	fs/nfs/proc.c
#	fs/nfs/read.c
#	fs/nfs/write.c
#	include/linux/nfs_page.h
#	include/linux/nfs_xdr.h
diff --cc fs/nfs/blocklayout/blocklayout.c
index 8fe72d727e75,c3ccfe440390..000000000000
--- a/fs/nfs/blocklayout/blocklayout.c
+++ b/fs/nfs/blocklayout/blocklayout.c
@@@ -201,20 -202,15 +201,25 @@@ static struct bio *bl_add_page_to_bio(s
  static void bl_end_io_read(struct bio *bio, int err)
  {
  	struct parallel_io *par = bio->bi_private;
 -	struct bio_vec *bvec;
 -	int i;
 +	const int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);
 +	struct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;
  
 -	if (!err)
 -		bio_for_each_segment_all(bvec, bio, i)
 -			SetPageUptodate(bvec->bv_page);
 +	do {
 +		struct page *page = bvec->bv_page;
  
++<<<<<<< HEAD
 +		if (--bvec >= bio->bi_io_vec)
 +			prefetchw(&bvec->bv_page->flags);
 +		if (uptodate)
 +			SetPageUptodate(page);
 +	} while (bvec >= bio->bi_io_vec);
 +	if (!uptodate) {
 +		struct nfs_read_data *rdata = par->data;
 +		struct nfs_pgio_header *header = rdata->header;
++=======
+ 	if (err) {
+ 		struct nfs_pgio_header *header = par->data;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
  		if (!header->pnfs_error)
  			header->pnfs_error = -EIO;
@@@ -227,27 -223,27 +232,43 @@@
  static void bl_read_cleanup(struct work_struct *work)
  {
  	struct rpc_task *task;
++<<<<<<< HEAD
 +	struct nfs_read_data *rdata;
 +	dprintk("%s enter\n", __func__);
 +	task = container_of(work, struct rpc_task, u.tk_work);
 +	rdata = container_of(task, struct nfs_read_data, task);
 +	pnfs_ld_read_done(rdata);
++=======
+ 	struct nfs_pgio_header *hdr;
+ 	dprintk("%s enter\n", __func__);
+ 	task = container_of(work, struct rpc_task, u.tk_work);
+ 	hdr = container_of(task, struct nfs_pgio_header, task);
+ 	pnfs_ld_read_done(hdr);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  }
  
  static void
  bl_end_par_io_read(void *data, int unused)
  {
++<<<<<<< HEAD
 +	struct nfs_read_data *rdata = data;
++=======
+ 	struct nfs_pgio_header *hdr = data;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
- 	rdata->task.tk_status = rdata->header->pnfs_error;
- 	INIT_WORK(&rdata->task.u.tk_work, bl_read_cleanup);
- 	schedule_work(&rdata->task.u.tk_work);
+ 	hdr->task.tk_status = hdr->pnfs_error;
+ 	INIT_WORK(&hdr->task.u.tk_work, bl_read_cleanup);
+ 	schedule_work(&hdr->task.u.tk_work);
  }
  
  static enum pnfs_try_status
++<<<<<<< HEAD
 +bl_read_pagelist(struct nfs_read_data *rdata)
++=======
+ bl_read_pagelist(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *header = rdata->header;
+ 	struct nfs_pgio_header *header = hdr;
  	int i, hole;
  	struct bio *bio = NULL;
  	struct pnfs_block_extent *be = NULL, *cow_read = NULL;
@@@ -261,9 -257,10 +282,14 @@@
  	const bool is_dio = (header->dreq != NULL);
  
  	dprintk("%s enter nr_pages %u offset %lld count %u\n", __func__,
++<<<<<<< HEAD
 +	       rdata->pages.npages, f_offset, (unsigned int)rdata->args.count);
++=======
+ 		hdr->page_array.npages, f_offset,
+ 		(unsigned int)hdr->args.count);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
- 	par = alloc_parallel(rdata);
+ 	par = alloc_parallel(hdr);
  	if (!par)
  		goto use_mds;
  	par->pnfs_callback = bl_end_par_io_read;
@@@ -271,7 -268,7 +297,11 @@@
  
  	isect = (sector_t) (f_offset >> SECTOR_SHIFT);
  	/* Code assumes extents are page-aligned */
++<<<<<<< HEAD
 +	for (i = pg_index; i < rdata->pages.npages; i++) {
++=======
+ 	for (i = pg_index; i < hdr->page_array.npages; i++) {
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  		if (!extent_length) {
  			/* We've used up the previous extent */
  			bl_put_extent(be);
@@@ -320,7 -317,8 +350,12 @@@
  			struct pnfs_block_extent *be_read;
  
  			be_read = (hole && cow_read) ? cow_read : be;
++<<<<<<< HEAD
 +			bio = do_add_page_to_bio(bio, rdata->pages.npages - i,
++=======
+ 			bio = do_add_page_to_bio(bio,
+ 						 hdr->page_array.npages - i,
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  						 READ,
  						 isect, pages[i], be_read,
  						 bl_end_io_read, par,
@@@ -383,22 -381,17 +418,27 @@@ static void mark_extents_written(struc
  static void bl_end_io_write_zero(struct bio *bio, int err)
  {
  	struct parallel_io *par = bio->bi_private;
 -	struct bio_vec *bvec;
 -	int i;
 +	const int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);
 +	struct bio_vec *bvec = bio->bi_io_vec + bio->bi_vcnt - 1;
 +
 +	do {
 +		struct page *page = bvec->bv_page;
  
 -	bio_for_each_segment_all(bvec, bio, i) {
 +		if (--bvec >= bio->bi_io_vec)
 +			prefetchw(&bvec->bv_page->flags);
  		/* This is the zeroing page we added */
 -		end_page_writeback(bvec->bv_page);
 -		page_cache_release(bvec->bv_page);
 -	}
 +		end_page_writeback(page);
 +		page_cache_release(page);
 +	} while (bvec >= bio->bi_io_vec);
  
++<<<<<<< HEAD
 +	if (unlikely(!uptodate)) {
 +		struct nfs_write_data *data = par->data;
 +		struct nfs_pgio_header *header = data->header;
++=======
+ 	if (unlikely(err)) {
+ 		struct nfs_pgio_header *header = par->data;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
  		if (!header->pnfs_error)
  			header->pnfs_error = -EIO;
@@@ -412,8 -405,7 +452,12 @@@ static void bl_end_io_write(struct bio 
  {
  	struct parallel_io *par = bio->bi_private;
  	const int uptodate = test_bit(BIO_UPTODATE, &bio->bi_flags);
++<<<<<<< HEAD
 +	struct nfs_write_data *data = par->data;
 +	struct nfs_pgio_header *header = data->header;
++=======
+ 	struct nfs_pgio_header *header = par->data;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
  	if (!uptodate) {
  		if (!header->pnfs_error)
@@@ -430,32 -422,32 +474,51 @@@
  static void bl_write_cleanup(struct work_struct *work)
  {
  	struct rpc_task *task;
++<<<<<<< HEAD
 +	struct nfs_write_data *wdata;
 +	dprintk("%s enter\n", __func__);
 +	task = container_of(work, struct rpc_task, u.tk_work);
 +	wdata = container_of(task, struct nfs_write_data, task);
 +	if (likely(!wdata->header->pnfs_error)) {
++=======
+ 	struct nfs_pgio_header *hdr;
+ 	dprintk("%s enter\n", __func__);
+ 	task = container_of(work, struct rpc_task, u.tk_work);
+ 	hdr = container_of(task, struct nfs_pgio_header, task);
+ 	if (likely(!hdr->pnfs_error)) {
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  		/* Marks for LAYOUTCOMMIT */
- 		mark_extents_written(BLK_LSEG2EXT(wdata->header->lseg),
- 				     wdata->args.offset, wdata->args.count);
+ 		mark_extents_written(BLK_LSEG2EXT(hdr->lseg),
+ 				     hdr->args.offset, hdr->args.count);
  	}
- 	pnfs_ld_write_done(wdata);
+ 	pnfs_ld_write_done(hdr);
  }
  
  /* Called when last of bios associated with a bl_write_pagelist call finishes */
  static void bl_end_par_io_write(void *data, int num_se)
  {
++<<<<<<< HEAD
 +	struct nfs_write_data *wdata = data;
++=======
+ 	struct nfs_pgio_header *hdr = data;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
- 	if (unlikely(wdata->header->pnfs_error)) {
- 		bl_free_short_extents(&BLK_LSEG2EXT(wdata->header->lseg)->bl_inval,
+ 	if (unlikely(hdr->pnfs_error)) {
+ 		bl_free_short_extents(&BLK_LSEG2EXT(hdr->lseg)->bl_inval,
  					num_se);
  	}
  
++<<<<<<< HEAD
 +	wdata->task.tk_status = wdata->header->pnfs_error;
 +	wdata->verf.committed = NFS_FILE_SYNC;
 +	INIT_WORK(&wdata->task.u.tk_work, bl_write_cleanup);
 +	schedule_work(&wdata->task.u.tk_work);
++=======
+ 	hdr->task.tk_status = hdr->pnfs_error;
+ 	hdr->writeverf.committed = NFS_FILE_SYNC;
+ 	INIT_WORK(&hdr->task.u.tk_work, bl_write_cleanup);
+ 	schedule_work(&hdr->task.u.tk_work);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  }
  
  /* FIXME STUB - mark intersection of layout and page as bad, so is not
@@@ -680,9 -672,8 +743,12 @@@ check_page
  }
  
  static enum pnfs_try_status
++<<<<<<< HEAD
 +bl_write_pagelist(struct nfs_write_data *wdata, int sync)
++=======
+ bl_write_pagelist(struct nfs_pgio_header *header, int sync)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *header = wdata->header;
  	int i, ret, npg_zero, pg_index, last = 0;
  	struct bio *bio = NULL;
  	struct pnfs_block_extent *be = NULL, *cow_read = NULL;
@@@ -706,7 -697,7 +772,11 @@@
  		dprintk("pnfsblock nonblock aligned DIO writes. Resend MDS\n");
  		goto out_mds;
  	}
++<<<<<<< HEAD
 +	/* At this point, wdata->pages is a (sequential) list of nfs_pages.
++=======
+ 	/* At this point, header->page_aray is a (sequential) list of nfs_pages.
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	 * We want to write each, and if there is an error set pnfs_error
  	 * to have it redone using nfs.
  	 */
@@@ -797,8 -788,8 +867,13 @@@ next_page
  	bio = bl_submit_bio(WRITE, bio);
  
  	/* Middle pages */
++<<<<<<< HEAD
 +	pg_index = wdata->args.pgbase >> PAGE_CACHE_SHIFT;
 +	for (i = pg_index; i < wdata->pages.npages; i++) {
++=======
+ 	pg_index = header->args.pgbase >> PAGE_CACHE_SHIFT;
+ 	for (i = pg_index; i < header->page_array.npages; i++) {
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  		if (!extent_length) {
  			/* We've used up the previous extent */
  			bl_put_extent(be);
@@@ -869,7 -860,8 +944,12 @@@
  		}
  
  
++<<<<<<< HEAD
 +		bio = do_add_page_to_bio(bio, wdata->pages.npages - i, WRITE,
++=======
+ 		bio = do_add_page_to_bio(bio, header->page_array.npages - i,
+ 					 WRITE,
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  					 isect, pages[i], be,
  					 bl_end_io_write, par,
  					 pg_offset, pg_len);
diff --cc fs/nfs/direct.c
index ddbc02a05958,6c4c867ee04c..000000000000
--- a/fs/nfs/direct.c
+++ b/fs/nfs/direct.c
@@@ -108,6 -108,97 +108,100 @@@ static inline int put_dreq(struct nfs_d
  	return atomic_dec_and_test(&dreq->io_count);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * nfs_direct_select_verf - select the right verifier
+  * @dreq - direct request possibly spanning multiple servers
+  * @ds_clp - nfs_client of data server or NULL if MDS / non-pnfs
+  * @ds_idx - index of data server in data server list, only valid if ds_clp set
+  *
+  * returns the correct verifier to use given the role of the server
+  */
+ static struct nfs_writeverf *
+ nfs_direct_select_verf(struct nfs_direct_req *dreq,
+ 		       struct nfs_client *ds_clp,
+ 		       int ds_idx)
+ {
+ 	struct nfs_writeverf *verfp = &dreq->verf;
+ 
+ #ifdef CONFIG_NFS_V4_1
+ 	if (ds_clp) {
+ 		/* pNFS is in use, use the DS verf */
+ 		if (ds_idx >= 0 && ds_idx < dreq->ds_cinfo.nbuckets)
+ 			verfp = &dreq->ds_cinfo.buckets[ds_idx].direct_verf;
+ 		else
+ 			WARN_ON_ONCE(1);
+ 	}
+ #endif
+ 	return verfp;
+ }
+ 
+ 
+ /*
+  * nfs_direct_set_hdr_verf - set the write/commit verifier
+  * @dreq - direct request possibly spanning multiple servers
+  * @hdr - pageio header to validate against previously seen verfs
+  *
+  * Set the server's (MDS or DS) "seen" verifier
+  */
+ static void nfs_direct_set_hdr_verf(struct nfs_direct_req *dreq,
+ 				    struct nfs_pgio_header *hdr)
+ {
+ 	struct nfs_writeverf *verfp;
+ 
+ 	verfp = nfs_direct_select_verf(dreq, hdr->ds_clp,
+ 				      hdr->ds_idx);
+ 	WARN_ON_ONCE(verfp->committed >= 0);
+ 	memcpy(verfp, &hdr->verf, sizeof(struct nfs_writeverf));
+ 	WARN_ON_ONCE(verfp->committed < 0);
+ }
+ 
+ /*
+  * nfs_direct_cmp_hdr_verf - compare verifier for pgio header
+  * @dreq - direct request possibly spanning multiple servers
+  * @hdr - pageio header to validate against previously seen verf
+  *
+  * set the server's "seen" verf if not initialized.
+  * returns result of comparison between @hdr->verf and the "seen"
+  * verf of the server used by @hdr (DS or MDS)
+  */
+ static int nfs_direct_set_or_cmp_hdr_verf(struct nfs_direct_req *dreq,
+ 					  struct nfs_pgio_header *hdr)
+ {
+ 	struct nfs_writeverf *verfp;
+ 
+ 	verfp = nfs_direct_select_verf(dreq, hdr->ds_clp,
+ 					 hdr->ds_idx);
+ 	if (verfp->committed < 0) {
+ 		nfs_direct_set_hdr_verf(dreq, hdr);
+ 		return 0;
+ 	}
+ 	return memcmp(verfp, &hdr->verf, sizeof(struct nfs_writeverf));
+ }
+ 
+ #if IS_ENABLED(CONFIG_NFS_V3) || IS_ENABLED(CONFIG_NFS_V4)
+ /*
+  * nfs_direct_cmp_commit_data_verf - compare verifier for commit data
+  * @dreq - direct request possibly spanning multiple servers
+  * @data - commit data to validate against previously seen verf
+  *
+  * returns result of comparison between @data->verf and the verf of
+  * the server used by @data (DS or MDS)
+  */
+ static int nfs_direct_cmp_commit_data_verf(struct nfs_direct_req *dreq,
+ 					   struct nfs_commit_data *data)
+ {
+ 	struct nfs_writeverf *verfp;
+ 
+ 	verfp = nfs_direct_select_verf(dreq, data->ds_clp,
+ 					 data->ds_commit_index);
+ 	WARN_ON_ONCE(verfp->committed < 0);
+ 	return memcmp(verfp, &data->verf, sizeof(struct nfs_writeverf));
+ }
+ #endif
+ 
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  /**
   * nfs_direct_IO - NFS address space operation for direct I/O
   * @rw: direction (read or write)
diff --cc fs/nfs/filelayout/filelayout.c
index b06557ac57c5,537e7f7a0b48..000000000000
--- a/fs/nfs/filelayout/filelayout.c
+++ b/fs/nfs/filelayout/filelayout.c
@@@ -84,10 -84,9 +84,13 @@@ filelayout_get_dserver_offset(struct pn
  	BUG();
  }
  
++<<<<<<< HEAD
 +static void filelayout_reset_write(struct nfs_write_data *data)
++=======
+ static void filelayout_reset_write(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = data->header;
- 	struct rpc_task *task = &data->task;
+ 	struct rpc_task *task = &hdr->task;
  
  	if (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {
  		dprintk("%s Reset task %5u for i/o through MDS "
@@@ -105,10 -104,9 +108,13 @@@
  	}
  }
  
++<<<<<<< HEAD
 +static void filelayout_reset_read(struct nfs_read_data *data)
++=======
+ static void filelayout_reset_read(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = data->header;
- 	struct rpc_task *task = &data->task;
+ 	struct rpc_task *task = &hdr->task;
  
  	if (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {
  		dprintk("%s Reset task %5u for i/o through MDS "
@@@ -243,14 -241,13 +249,17 @@@ wait_on_recovery
  /* NFS_PROTO call done callback routines */
  
  static int filelayout_read_done_cb(struct rpc_task *task,
++<<<<<<< HEAD
 +				struct nfs_read_data *data)
++=======
+ 				struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = data->header;
  	int err;
  
- 	trace_nfs4_pnfs_read(data, task->tk_status);
- 	err = filelayout_async_handle_error(task, data->args.context->state,
- 					    data->ds_clp, hdr->lseg);
+ 	trace_nfs4_pnfs_read(hdr, task->tk_status);
+ 	err = filelayout_async_handle_error(task, hdr->args.context->state,
+ 					    hdr->ds_clp, hdr->lseg);
  
  	switch (err) {
  	case -NFS4ERR_RESET_TO_MDS:
@@@ -270,15 -267,14 +279,18 @@@
   * rfc5661 is not clear about which credential should be used.
   */
  static void
++<<<<<<< HEAD
 +filelayout_set_layoutcommit(struct nfs_write_data *wdata)
++=======
+ filelayout_set_layoutcommit(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = wdata->header;
  
  	if (FILELAYOUT_LSEG(hdr->lseg)->commit_through_mds ||
- 	    wdata->res.verf->committed == NFS_FILE_SYNC)
+ 	    hdr->res.verf->committed == NFS_FILE_SYNC)
  		return;
  
- 	pnfs_set_layoutcommit(wdata);
+ 	pnfs_set_layoutcommit(hdr);
  	dprintk("%s inode %lu pls_end_pos %lu\n", __func__, hdr->inode->i_ino,
  		(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb);
  }
@@@ -305,9 -301,9 +317,13 @@@ filelayout_reset_to_mds(struct pnfs_lay
   */
  static void filelayout_read_prepare(struct rpc_task *task, void *data)
  {
++<<<<<<< HEAD
 +	struct nfs_read_data *rdata = data;
++=======
+ 	struct nfs_pgio_header *hdr = data;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
- 	if (unlikely(test_bit(NFS_CONTEXT_BAD, &rdata->args.context->flags))) {
+ 	if (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {
  		rpc_exit(task, -EIO);
  		return;
  	}
@@@ -317,21 -313,21 +333,29 @@@
  		rpc_exit(task, 0);
  		return;
  	}
++<<<<<<< HEAD
 +	rdata->read_done_cb = filelayout_read_done_cb;
++=======
+ 	hdr->pgio_done_cb = filelayout_read_done_cb;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
- 	if (nfs41_setup_sequence(rdata->ds_clp->cl_session,
- 			&rdata->args.seq_args,
- 			&rdata->res.seq_res,
+ 	if (nfs41_setup_sequence(hdr->ds_clp->cl_session,
+ 			&hdr->args.seq_args,
+ 			&hdr->res.seq_res,
  			task))
  		return;
- 	if (nfs4_set_rw_stateid(&rdata->args.stateid, rdata->args.context,
- 			rdata->args.lock_context, FMODE_READ) == -EIO)
+ 	if (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,
+ 			hdr->args.lock_context, FMODE_READ) == -EIO)
  		rpc_exit(task, -EIO); /* lost lock, terminate I/O */
  }
  
  static void filelayout_read_call_done(struct rpc_task *task, void *data)
  {
++<<<<<<< HEAD
 +	struct nfs_read_data *rdata = data;
++=======
+ 	struct nfs_pgio_header *hdr = data;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
  	dprintk("--> %s task->tk_status %d\n", __func__, task->tk_status);
  
@@@ -347,30 -343,29 +371,42 @@@
  
  static void filelayout_read_count_stats(struct rpc_task *task, void *data)
  {
++<<<<<<< HEAD
 +	struct nfs_read_data *rdata = data;
++=======
+ 	struct nfs_pgio_header *hdr = data;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
- 	rpc_count_iostats(task, NFS_SERVER(rdata->header->inode)->client->cl_metrics);
+ 	rpc_count_iostats(task, NFS_SERVER(hdr->inode)->client->cl_metrics);
  }
  
  static void filelayout_read_release(void *data)
  {
++<<<<<<< HEAD
 +	struct nfs_read_data *rdata = data;
 +	struct pnfs_layout_hdr *lo = rdata->header->lseg->pls_layout;
++=======
+ 	struct nfs_pgio_header *hdr = data;
+ 	struct pnfs_layout_hdr *lo = hdr->lseg->pls_layout;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
  	filelayout_fenceme(lo->plh_inode, lo);
- 	nfs_put_client(rdata->ds_clp);
- 	rdata->header->mds_ops->rpc_release(data);
+ 	nfs_put_client(hdr->ds_clp);
+ 	hdr->mds_ops->rpc_release(data);
  }
  
  static int filelayout_write_done_cb(struct rpc_task *task,
++<<<<<<< HEAD
 +				struct nfs_write_data *data)
++=======
+ 				struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = data->header;
  	int err;
  
- 	trace_nfs4_pnfs_write(data, task->tk_status);
- 	err = filelayout_async_handle_error(task, data->args.context->state,
- 					    data->ds_clp, hdr->lseg);
+ 	trace_nfs4_pnfs_write(hdr, task->tk_status);
+ 	err = filelayout_async_handle_error(task, hdr->args.context->state,
+ 					    hdr->ds_clp, hdr->lseg);
  
  	switch (err) {
  	case -NFS4ERR_RESET_TO_MDS:
@@@ -419,9 -414,9 +455,13 @@@ static int filelayout_commit_done_cb(st
  
  static void filelayout_write_prepare(struct rpc_task *task, void *data)
  {
++<<<<<<< HEAD
 +	struct nfs_write_data *wdata = data;
++=======
+ 	struct nfs_pgio_header *hdr = data;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
- 	if (unlikely(test_bit(NFS_CONTEXT_BAD, &wdata->args.context->flags))) {
+ 	if (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags))) {
  		rpc_exit(task, -EIO);
  		return;
  	}
@@@ -443,11 -438,11 +483,15 @@@
  
  static void filelayout_write_call_done(struct rpc_task *task, void *data)
  {
++<<<<<<< HEAD
 +	struct nfs_write_data *wdata = data;
++=======
+ 	struct nfs_pgio_header *hdr = data;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
- 	if (test_bit(NFS_IOHDR_REDO, &wdata->header->flags) &&
+ 	if (test_bit(NFS_IOHDR_REDO, &hdr->flags) &&
  	    task->tk_status == 0) {
- 		nfs41_sequence_done(task, &wdata->res.seq_res);
+ 		nfs41_sequence_done(task, &hdr->res.seq_res);
  		return;
  	}
  
@@@ -457,19 -452,19 +501,28 @@@
  
  static void filelayout_write_count_stats(struct rpc_task *task, void *data)
  {
++<<<<<<< HEAD
 +	struct nfs_write_data *wdata = data;
++=======
+ 	struct nfs_pgio_header *hdr = data;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
- 	rpc_count_iostats(task, NFS_SERVER(wdata->header->inode)->client->cl_metrics);
+ 	rpc_count_iostats(task, NFS_SERVER(hdr->inode)->client->cl_metrics);
  }
  
  static void filelayout_write_release(void *data)
  {
++<<<<<<< HEAD
 +	struct nfs_write_data *wdata = data;
 +	struct pnfs_layout_hdr *lo = wdata->header->lseg->pls_layout;
++=======
+ 	struct nfs_pgio_header *hdr = data;
+ 	struct pnfs_layout_hdr *lo = hdr->lseg->pls_layout;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
  	filelayout_fenceme(lo->plh_inode, lo);
- 	nfs_put_client(wdata->ds_clp);
- 	wdata->header->mds_ops->rpc_release(data);
+ 	nfs_put_client(hdr->ds_clp);
+ 	hdr->mds_ops->rpc_release(data);
  }
  
  static void filelayout_commit_prepare(struct rpc_task *task, void *data)
@@@ -529,9 -524,8 +582,12 @@@ static const struct rpc_call_ops filela
  };
  
  static enum pnfs_try_status
++<<<<<<< HEAD
 +filelayout_read_pagelist(struct nfs_read_data *data)
++=======
+ filelayout_read_pagelist(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = data->header;
  	struct pnfs_layout_segment *lseg = hdr->lseg;
  	struct nfs4_pnfs_ds *ds;
  	struct rpc_clnt *ds_clnt;
@@@ -559,25 -553,25 +615,38 @@@
  
  	/* No multipath support. Use first DS */
  	atomic_inc(&ds->ds_clp->cl_count);
++<<<<<<< HEAD
 +	data->ds_clp = ds->ds_clp;
++=======
+ 	hdr->ds_clp = ds->ds_clp;
+ 	hdr->ds_idx = idx;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	fh = nfs4_fl_select_ds_fh(lseg, j);
  	if (fh)
- 		data->args.fh = fh;
+ 		hdr->args.fh = fh;
  
- 	data->args.offset = filelayout_get_dserver_offset(lseg, offset);
- 	data->mds_offset = offset;
+ 	hdr->args.offset = filelayout_get_dserver_offset(lseg, offset);
+ 	hdr->mds_offset = offset;
  
  	/* Perform an asynchronous read to ds */
++<<<<<<< HEAD
 +	nfs_initiate_read(ds_clnt, data,
 +				  &filelayout_read_call_ops, RPC_TASK_SOFTCONN);
++=======
+ 	nfs_initiate_pgio(ds_clnt, hdr,
+ 			    &filelayout_read_call_ops, 0, RPC_TASK_SOFTCONN);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	return PNFS_ATTEMPTED;
  }
  
  /* Perform async writes. */
  static enum pnfs_try_status
++<<<<<<< HEAD
 +filelayout_write_pagelist(struct nfs_write_data *data, int sync)
++=======
+ filelayout_write_pagelist(struct nfs_pgio_header *hdr, int sync)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = data->header;
  	struct pnfs_layout_segment *lseg = hdr->lseg;
  	struct nfs4_pnfs_ds *ds;
  	struct rpc_clnt *ds_clnt;
@@@ -597,20 -591,20 +666,30 @@@
  		return PNFS_NOT_ATTEMPTED;
  
  	dprintk("%s ino %lu sync %d req %Zu@%llu DS: %s cl_count %d\n",
- 		__func__, hdr->inode->i_ino, sync, (size_t) data->args.count,
+ 		__func__, hdr->inode->i_ino, sync, (size_t) hdr->args.count,
  		offset, ds->ds_remotestr, atomic_read(&ds->ds_clp->cl_count));
  
++<<<<<<< HEAD
 +	data->write_done_cb = filelayout_write_done_cb;
 +	atomic_inc(&ds->ds_clp->cl_count);
 +	data->ds_clp = ds->ds_clp;
++=======
+ 	hdr->pgio_done_cb = filelayout_write_done_cb;
+ 	atomic_inc(&ds->ds_clp->cl_count);
+ 	hdr->ds_clp = ds->ds_clp;
+ 	hdr->ds_idx = idx;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	fh = nfs4_fl_select_ds_fh(lseg, j);
  	if (fh)
- 		data->args.fh = fh;
- 
- 	data->args.offset = filelayout_get_dserver_offset(lseg, offset);
+ 		hdr->args.fh = fh;
+ 	hdr->args.offset = filelayout_get_dserver_offset(lseg, offset);
  
  	/* Perform an asynchronous write */
++<<<<<<< HEAD
 +	nfs_initiate_write(ds_clnt, data,
++=======
+ 	nfs_initiate_pgio(ds_clnt, hdr,
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  				    &filelayout_write_call_ops, sync,
  				    RPC_TASK_SOFTCONN);
  	return PNFS_ATTEMPTED;
diff --cc fs/nfs/internal.h
index 96bd22580dbf,3f3aedd2e8c9..000000000000
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@@ -238,6 -237,14 +238,17 @@@ extern void nfs_pgheader_init(struct nf
  void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
  int nfs_iocounter_wait(struct nfs_io_counter *c);
  
++<<<<<<< HEAD
++=======
+ extern const struct nfs_pageio_ops nfs_pgio_rw_ops;
+ struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *);
+ void nfs_pgio_header_free(struct nfs_pgio_header *);
+ void nfs_pgio_data_destroy(struct nfs_pgio_header *);
+ int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
+ int nfs_initiate_pgio(struct rpc_clnt *, struct nfs_pgio_header *,
+ 		      const struct rpc_call_ops *, int, int);
+ 
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  static inline void nfs_iocounter_init(struct nfs_io_counter *c)
  {
  	c->flags = 0;
@@@ -489,7 -481,7 +500,11 @@@ static inline void nfs_inode_dio_wait(s
  extern ssize_t nfs_dreq_bytes_left(struct nfs_direct_req *dreq);
  
  /* nfs4proc.c */
++<<<<<<< HEAD
 +extern void __nfs4_read_done_cb(struct nfs_read_data *);
++=======
+ extern void __nfs4_read_done_cb(struct nfs_pgio_header *);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  extern struct nfs_client *nfs4_init_client(struct nfs_client *clp,
  			    const struct rpc_timeout *timeparms,
  			    const char *ip_addr);
diff --cc fs/nfs/nfs3proc.c
index 8ced9deec5a6,854959db0e5d..000000000000
--- a/fs/nfs/nfs3proc.c
+++ b/fs/nfs/nfs3proc.c
@@@ -774,9 -795,9 +774,13 @@@ nfs3_proc_pathconf(struct nfs_server *s
  	return status;
  }
  
++<<<<<<< HEAD
 +static int nfs3_read_done(struct rpc_task *task, struct nfs_read_data *data)
++=======
+ static int nfs3_read_done(struct rpc_task *task, struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct inode *inode = data->header->inode;
+ 	struct inode *inode = hdr->inode;
  
  	if (nfs3_async_handle_jukebox(task, inode))
  		return -EAGAIN;
@@@ -786,20 -807,22 +790,34 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void nfs3_proc_read_setup(struct nfs_read_data *data, struct rpc_message *msg)
++=======
+ static void nfs3_proc_read_setup(struct nfs_pgio_header *hdr,
+ 				 struct rpc_message *msg)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
  	msg->rpc_proc = &nfs3_procedures[NFS3PROC_READ];
  }
  
++<<<<<<< HEAD
 +static int nfs3_proc_read_rpc_prepare(struct rpc_task *task, struct nfs_read_data *data)
++=======
+ static int nfs3_proc_pgio_rpc_prepare(struct rpc_task *task,
+ 				      struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
  	rpc_call_start(task);
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int nfs3_write_done(struct rpc_task *task, struct nfs_write_data *data)
++=======
+ static int nfs3_write_done(struct rpc_task *task, struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct inode *inode = data->header->inode;
+ 	struct inode *inode = hdr->inode;
  
  	if (nfs3_async_handle_jukebox(task, inode))
  		return -EAGAIN;
@@@ -808,7 -831,8 +826,12 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void nfs3_proc_write_setup(struct nfs_write_data *data, struct rpc_message *msg)
++=======
+ static void nfs3_proc_write_setup(struct nfs_pgio_header *hdr,
+ 				  struct rpc_message *msg)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
  	msg->rpc_proc = &nfs3_procedures[NFS3PROC_WRITE];
  }
diff --cc fs/nfs/nfs4_fs.h
index e1d1badbe53c,b8ea4a26998c..000000000000
--- a/fs/nfs/nfs4_fs.h
+++ b/fs/nfs/nfs4_fs.h
@@@ -337,7 -337,7 +337,11 @@@ nfs4_state_protect(struct nfs_client *c
   */
  static inline void
  nfs4_state_protect_write(struct nfs_client *clp, struct rpc_clnt **clntp,
++<<<<<<< HEAD
 +			 struct rpc_message *msg, struct nfs_write_data *wdata)
++=======
+ 			 struct rpc_message *msg, struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
  	if (_nfs4_state_protect(clp, NFS_SP4_MACH_CRED_WRITE, clntp, msg) &&
  	    !test_bit(NFS_SP4_MACH_CRED_COMMIT, &clp->cl_sp4_flags))
@@@ -369,7 -369,7 +373,11 @@@ nfs4_state_protect(struct nfs_client *c
  
  static inline void
  nfs4_state_protect_write(struct nfs_client *clp, struct rpc_clnt **clntp,
++<<<<<<< HEAD
 +			 struct rpc_message *msg, struct nfs_write_data *wdata)
++=======
+ 			 struct rpc_message *msg, struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
  }
  #endif /* CONFIG_NFS_V4_1 */
diff --cc fs/nfs/nfs4proc.c
index 3d5be57bffcc,b0e5705599bf..000000000000
--- a/fs/nfs/nfs4proc.c
+++ b/fs/nfs/nfs4proc.c
@@@ -4033,17 -4033,18 +4033,26 @@@ static bool nfs4_error_stateid_expired(
  	return false;
  }
  
++<<<<<<< HEAD
 +void __nfs4_read_done_cb(struct nfs_read_data *data)
++=======
+ void __nfs4_read_done_cb(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	nfs_invalidate_atime(data->header->inode);
+ 	nfs_invalidate_atime(hdr->inode);
  }
  
++<<<<<<< HEAD
 +static int nfs4_read_done_cb(struct rpc_task *task, struct nfs_read_data *data)
++=======
+ static int nfs4_read_done_cb(struct rpc_task *task, struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_server *server = NFS_SERVER(data->header->inode);
+ 	struct nfs_server *server = NFS_SERVER(hdr->inode);
  
- 	trace_nfs4_read(data, task->tk_status);
- 	if (nfs4_async_handle_error(task, server, data->args.context->state) == -EAGAIN) {
+ 	trace_nfs4_read(hdr, task->tk_status);
+ 	if (nfs4_async_handle_error(task, server,
+ 				    hdr->args.context->state) == -EAGAIN) {
  		rpc_restart_call_prepare(task);
  		return -EAGAIN;
  	}
@@@ -4068,48 -4069,53 +4077,81 @@@ static bool nfs4_read_stateid_changed(s
  	return true;
  }
  
++<<<<<<< HEAD
 +static int nfs4_read_done(struct rpc_task *task, struct nfs_read_data *data)
++=======
+ static int nfs4_read_done(struct rpc_task *task, struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
  
  	dprintk("--> %s\n", __func__);
  
- 	if (!nfs4_sequence_done(task, &data->res.seq_res))
+ 	if (!nfs4_sequence_done(task, &hdr->res.seq_res))
  		return -EAGAIN;
- 	if (nfs4_read_stateid_changed(task, &data->args))
+ 	if (nfs4_read_stateid_changed(task, &hdr->args))
  		return -EAGAIN;
++<<<<<<< HEAD
 +	return data->read_done_cb ? data->read_done_cb(task, data) :
 +				    nfs4_read_done_cb(task, data);
 +}
 +
 +static void nfs4_proc_read_setup(struct nfs_read_data *data, struct rpc_message *msg)
 +{
 +	data->timestamp   = jiffies;
 +	data->read_done_cb = nfs4_read_done_cb;
++=======
+ 	return hdr->pgio_done_cb ? hdr->pgio_done_cb(task, hdr) :
+ 				    nfs4_read_done_cb(task, hdr);
+ }
+ 
+ static void nfs4_proc_read_setup(struct nfs_pgio_header *hdr,
+ 				 struct rpc_message *msg)
+ {
+ 	hdr->timestamp   = jiffies;
+ 	hdr->pgio_done_cb = nfs4_read_done_cb;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	msg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_READ];
- 	nfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 0);
+ 	nfs4_init_sequence(&hdr->args.seq_args, &hdr->res.seq_res, 0);
  }
  
++<<<<<<< HEAD
 +static int nfs4_proc_read_rpc_prepare(struct rpc_task *task, struct nfs_read_data *data)
- {
- 	if (nfs4_setup_sequence(NFS_SERVER(data->header->inode),
- 			&data->args.seq_args,
- 			&data->res.seq_res,
++=======
+ static int nfs4_proc_pgio_rpc_prepare(struct rpc_task *task,
+ 				      struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
+ {
+ 	if (nfs4_setup_sequence(NFS_SERVER(hdr->inode),
+ 			&hdr->args.seq_args,
+ 			&hdr->res.seq_res,
  			task))
  		return 0;
++<<<<<<< HEAD
 +	if (nfs4_set_rw_stateid(&data->args.stateid, data->args.context,
 +				data->args.lock_context, FMODE_READ) == -EIO)
++=======
+ 	if (nfs4_set_rw_stateid(&hdr->args.stateid, hdr->args.context,
+ 				hdr->args.lock_context,
+ 				hdr->rw_ops->rw_mode) == -EIO)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  		return -EIO;
- 	if (unlikely(test_bit(NFS_CONTEXT_BAD, &data->args.context->flags)))
+ 	if (unlikely(test_bit(NFS_CONTEXT_BAD, &hdr->args.context->flags)))
  		return -EIO;
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int nfs4_write_done_cb(struct rpc_task *task, struct nfs_write_data *data)
++=======
+ static int nfs4_write_done_cb(struct rpc_task *task,
+ 			      struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct inode *inode = data->header->inode;
+ 	struct inode *inode = hdr->inode;
  	
- 	trace_nfs4_write(data, task->tk_status);
- 	if (nfs4_async_handle_error(task, NFS_SERVER(inode), data->args.context->state) == -EAGAIN) {
+ 	trace_nfs4_write(hdr, task->tk_status);
+ 	if (nfs4_async_handle_error(task, NFS_SERVER(inode),
+ 				    hdr->args.context->state) == -EAGAIN) {
  		rpc_restart_call_prepare(task);
  		return -EAGAIN;
  	}
@@@ -4134,23 -4140,21 +4176,34 @@@ static bool nfs4_write_stateid_changed(
  	return true;
  }
  
++<<<<<<< HEAD
 +static int nfs4_write_done(struct rpc_task *task, struct nfs_write_data *data)
++=======
+ static int nfs4_write_done(struct rpc_task *task, struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	if (!nfs4_sequence_done(task, &data->res.seq_res))
+ 	if (!nfs4_sequence_done(task, &hdr->res.seq_res))
  		return -EAGAIN;
- 	if (nfs4_write_stateid_changed(task, &data->args))
+ 	if (nfs4_write_stateid_changed(task, &hdr->args))
  		return -EAGAIN;
++<<<<<<< HEAD
 +	return data->write_done_cb ? data->write_done_cb(task, data) :
 +		nfs4_write_done_cb(task, data);
 +}
 +
 +static
 +bool nfs4_write_need_cache_consistency_data(const struct nfs_write_data *data)
- {
- 	const struct nfs_pgio_header *hdr = data->header;
++=======
+ 	return hdr->pgio_done_cb ? hdr->pgio_done_cb(task, hdr) :
+ 		nfs4_write_done_cb(task, hdr);
+ }
  
+ static
+ bool nfs4_write_need_cache_consistency_data(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
+ {
  	/* Don't request attributes for pNFS or O_DIRECT writes */
- 	if (data->ds_clp != NULL || hdr->dreq != NULL)
+ 	if (hdr->ds_clp != NULL || hdr->dreq != NULL)
  		return false;
  	/* Otherwise, request attributes if and only if we don't hold
  	 * a delegation
@@@ -4158,40 -4162,26 +4211,52 @@@
  	return nfs4_have_delegation(hdr->inode, FMODE_READ) == 0;
  }
  
++<<<<<<< HEAD
 +static void nfs4_proc_write_setup(struct nfs_write_data *data, struct rpc_message *msg)
++=======
+ static void nfs4_proc_write_setup(struct nfs_pgio_header *hdr,
+ 				  struct rpc_message *msg)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_server *server = NFS_SERVER(data->header->inode);
+ 	struct nfs_server *server = NFS_SERVER(hdr->inode);
  
- 	if (!nfs4_write_need_cache_consistency_data(data)) {
- 		data->args.bitmask = NULL;
- 		data->res.fattr = NULL;
+ 	if (!nfs4_write_need_cache_consistency_data(hdr)) {
+ 		hdr->args.bitmask = NULL;
+ 		hdr->res.fattr = NULL;
  	} else
- 		data->args.bitmask = server->cache_consistency_bitmask;
+ 		hdr->args.bitmask = server->cache_consistency_bitmask;
  
++<<<<<<< HEAD
 +	if (!data->write_done_cb)
 +		data->write_done_cb = nfs4_write_done_cb;
 +	data->res.server = server;
 +	data->timestamp   = jiffies;
++=======
+ 	if (!hdr->pgio_done_cb)
+ 		hdr->pgio_done_cb = nfs4_write_done_cb;
+ 	hdr->res.server = server;
+ 	hdr->timestamp   = jiffies;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
  	msg->rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_WRITE];
- 	nfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 1);
+ 	nfs4_init_sequence(&hdr->args.seq_args, &hdr->res.seq_res, 1);
  }
  
 +static int nfs4_proc_write_rpc_prepare(struct rpc_task *task, struct nfs_write_data *data)
 +{
 +	if (nfs4_setup_sequence(NFS_SERVER(data->header->inode),
 +			&data->args.seq_args,
 +			&data->res.seq_res,
 +			task))
 +		return 0;
 +	if (nfs4_set_rw_stateid(&data->args.stateid, data->args.context,
 +				data->args.lock_context, FMODE_WRITE) == -EIO)
 +		return -EIO;
 +	if (unlikely(test_bit(NFS_CONTEXT_BAD, &data->args.context->flags)))
 +		return -EIO;
 +	return 0;
 +}
 +
  static void nfs4_proc_commit_rpc_prepare(struct rpc_task *task, struct nfs_commit_data *data)
  {
  	nfs4_setup_sequence(NFS_SERVER(data->inode),
diff --cc fs/nfs/nfs4trace.h
index 849cf146db30,1c32adbe728d..000000000000
--- a/fs/nfs/nfs4trace.h
+++ b/fs/nfs/nfs4trace.h
@@@ -932,7 -932,7 +932,11 @@@ DEFINE_NFS4_IDMAP_EVENT(nfs4_map_gid_to
  
  DECLARE_EVENT_CLASS(nfs4_read_event,
  		TP_PROTO(
++<<<<<<< HEAD
 +			const struct nfs_read_data *data,
++=======
+ 			const struct nfs_pgio_header *hdr,
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  			int error
  		),
  
@@@ -972,10 -972,10 +976,14 @@@
  #define DEFINE_NFS4_READ_EVENT(name) \
  	DEFINE_EVENT(nfs4_read_event, name, \
  			TP_PROTO( \
++<<<<<<< HEAD
 +				const struct nfs_read_data *data, \
++=======
+ 				const struct nfs_pgio_header *hdr, \
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  				int error \
  			), \
- 			TP_ARGS(data, error))
+ 			TP_ARGS(hdr, error))
  DEFINE_NFS4_READ_EVENT(nfs4_read);
  #ifdef CONFIG_NFS_V4_1
  DEFINE_NFS4_READ_EVENT(nfs4_pnfs_read);
@@@ -983,7 -983,7 +991,11 @@@
  
  DECLARE_EVENT_CLASS(nfs4_write_event,
  		TP_PROTO(
++<<<<<<< HEAD
 +			const struct nfs_write_data *data,
++=======
+ 			const struct nfs_pgio_header *hdr,
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  			int error
  		),
  
@@@ -1024,10 -1024,10 +1036,14 @@@
  #define DEFINE_NFS4_WRITE_EVENT(name) \
  	DEFINE_EVENT(nfs4_write_event, name, \
  			TP_PROTO( \
++<<<<<<< HEAD
 +				const struct nfs_write_data *data, \
++=======
+ 				const struct nfs_pgio_header *hdr, \
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  				int error \
  			), \
- 			TP_ARGS(data, error))
+ 			TP_ARGS(hdr, error))
  DEFINE_NFS4_WRITE_EVENT(nfs4_write);
  #ifdef CONFIG_NFS_V4_1
  DEFINE_NFS4_WRITE_EVENT(nfs4_pnfs_write);
diff --cc fs/nfs/objlayout/objio_osd.c
index dd0487223e63,ae05278b3761..000000000000
--- a/fs/nfs/objlayout/objio_osd.c
+++ b/fs/nfs/objlayout/objio_osd.c
@@@ -439,9 -439,8 +439,12 @@@ static void _read_done(struct ore_io_st
  	objlayout_read_done(&objios->oir, status, objios->sync);
  }
  
++<<<<<<< HEAD
 +int objio_read_pagelist(struct nfs_read_data *rdata)
++=======
+ int objio_read_pagelist(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = rdata->header;
  	struct objio_state *objios;
  	int ret;
  
@@@ -487,11 -486,11 +490,16 @@@ static void _write_done(struct ore_io_s
  static struct page *__r4w_get_page(void *priv, u64 offset, bool *uptodate)
  {
  	struct objio_state *objios = priv;
++<<<<<<< HEAD
 +	struct nfs_write_data *wdata = objios->oir.rpcdata;
 +	struct address_space *mapping = wdata->header->inode->i_mapping;
++=======
+ 	struct nfs_pgio_header *hdr = objios->oir.rpcdata;
+ 	struct address_space *mapping = hdr->inode->i_mapping;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	pgoff_t index = offset / PAGE_SIZE;
  	struct page *page;
- 	loff_t i_size = i_size_read(wdata->header->inode);
+ 	loff_t i_size = i_size_read(hdr->inode);
  
  	if (offset >= i_size) {
  		*uptodate = true;
@@@ -531,9 -530,8 +539,12 @@@ static const struct _ore_r4w_op _r4w_o
  	.put_page = &__r4w_put_page,
  };
  
++<<<<<<< HEAD
 +int objio_write_pagelist(struct nfs_write_data *wdata, int how)
++=======
+ int objio_write_pagelist(struct nfs_pgio_header *hdr, int how)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = wdata->header;
  	struct objio_state *objios;
  	int ret;
  
diff --cc fs/nfs/objlayout/objlayout.c
index dd7dcf3fd2ca,86312787cee6..000000000000
--- a/fs/nfs/objlayout/objlayout.c
+++ b/fs/nfs/objlayout/objlayout.c
@@@ -229,25 -229,25 +229,37 @@@ objlayout_io_set_result(struct objlayou
  static void _rpc_read_complete(struct work_struct *work)
  {
  	struct rpc_task *task;
++<<<<<<< HEAD
 +	struct nfs_read_data *rdata;
 +
 +	dprintk("%s enter\n", __func__);
 +	task = container_of(work, struct rpc_task, u.tk_work);
 +	rdata = container_of(task, struct nfs_read_data, task);
++=======
+ 	struct nfs_pgio_header *hdr;
  
- 	pnfs_ld_read_done(rdata);
+ 	dprintk("%s enter\n", __func__);
+ 	task = container_of(work, struct rpc_task, u.tk_work);
+ 	hdr = container_of(task, struct nfs_pgio_header, task);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
+ 
+ 	pnfs_ld_read_done(hdr);
  }
  
  void
  objlayout_read_done(struct objlayout_io_res *oir, ssize_t status, bool sync)
  {
++<<<<<<< HEAD
 +	struct nfs_read_data *rdata = oir->rpcdata;
++=======
+ 	struct nfs_pgio_header *hdr = oir->rpcdata;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
- 	oir->status = rdata->task.tk_status = status;
+ 	oir->status = hdr->task.tk_status = status;
  	if (status >= 0)
- 		rdata->res.count = status;
+ 		hdr->res.count = status;
  	else
- 		rdata->header->pnfs_error = status;
+ 		hdr->pnfs_error = status;
  	objlayout_iodone(oir);
  	/* must not use oir after this point */
  
@@@ -266,12 -266,11 +278,15 @@@
   * Perform sync or async reads.
   */
  enum pnfs_try_status
++<<<<<<< HEAD
 +objlayout_read_pagelist(struct nfs_read_data *rdata)
++=======
+ objlayout_read_pagelist(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = rdata->header;
  	struct inode *inode = hdr->inode;
- 	loff_t offset = rdata->args.offset;
- 	size_t count = rdata->args.count;
+ 	loff_t offset = hdr->args.offset;
+ 	size_t count = hdr->args.count;
  	int err;
  	loff_t eof;
  
@@@ -312,38 -311,38 +327,59 @@@
  static void _rpc_write_complete(struct work_struct *work)
  {
  	struct rpc_task *task;
++<<<<<<< HEAD
 +	struct nfs_write_data *wdata;
 +
 +	dprintk("%s enter\n", __func__);
 +	task = container_of(work, struct rpc_task, u.tk_work);
 +	wdata = container_of(task, struct nfs_write_data, task);
++=======
+ 	struct nfs_pgio_header *hdr;
+ 
+ 	dprintk("%s enter\n", __func__);
+ 	task = container_of(work, struct rpc_task, u.tk_work);
+ 	hdr = container_of(task, struct nfs_pgio_header, task);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
- 	pnfs_ld_write_done(wdata);
+ 	pnfs_ld_write_done(hdr);
  }
  
  void
  objlayout_write_done(struct objlayout_io_res *oir, ssize_t status, bool sync)
  {
++<<<<<<< HEAD
 +	struct nfs_write_data *wdata = oir->rpcdata;
++=======
+ 	struct nfs_pgio_header *hdr = oir->rpcdata;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
- 	oir->status = wdata->task.tk_status = status;
+ 	oir->status = hdr->task.tk_status = status;
  	if (status >= 0) {
++<<<<<<< HEAD
 +		wdata->res.count = status;
 +		wdata->verf.committed = oir->committed;
++=======
+ 		hdr->res.count = status;
+ 		hdr->writeverf.committed = oir->committed;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	} else {
- 		wdata->header->pnfs_error = status;
+ 		hdr->pnfs_error = status;
  	}
  	objlayout_iodone(oir);
  	/* must not use oir after this point */
  
  	dprintk("%s: Return status %zd committed %d sync=%d\n", __func__,
++<<<<<<< HEAD
 +		status, wdata->verf.committed, sync);
++=======
+ 		status, hdr->writeverf.committed, sync);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
  	if (sync)
- 		pnfs_ld_write_done(wdata);
+ 		pnfs_ld_write_done(hdr);
  	else {
- 		INIT_WORK(&wdata->task.u.tk_work, _rpc_write_complete);
- 		schedule_work(&wdata->task.u.tk_work);
+ 		INIT_WORK(&hdr->task.u.tk_work, _rpc_write_complete);
+ 		schedule_work(&hdr->task.u.tk_work);
  	}
  }
  
@@@ -351,17 -350,15 +387,20 @@@
   * Perform sync or async writes.
   */
  enum pnfs_try_status
++<<<<<<< HEAD
 +objlayout_write_pagelist(struct nfs_write_data *wdata,
 +			 int how)
++=======
+ objlayout_write_pagelist(struct nfs_pgio_header *hdr, int how)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = wdata->header;
  	int err;
  
- 	_fix_verify_io_params(hdr->lseg, &wdata->args.pages,
- 			      &wdata->args.pgbase,
- 			      wdata->args.offset, wdata->args.count);
+ 	_fix_verify_io_params(hdr->lseg, &hdr->args.pages,
+ 			      &hdr->args.pgbase,
+ 			      hdr->args.offset, hdr->args.count);
  
- 	err = objio_write_pagelist(wdata, how);
+ 	err = objio_write_pagelist(hdr, how);
  	if (unlikely(err)) {
  		hdr->pnfs_error = err;
  		dprintk("%s: Returned Error %d\n", __func__, err);
diff --cc fs/nfs/objlayout/objlayout.h
index 87aa1dec6120,fd13f1d2f136..000000000000
--- a/fs/nfs/objlayout/objlayout.h
+++ b/fs/nfs/objlayout/objlayout.h
@@@ -119,8 -119,8 +119,13 @@@ extern void objio_free_lseg(struct pnfs
   */
  extern void objio_free_result(struct objlayout_io_res *oir);
  
++<<<<<<< HEAD
 +extern int objio_read_pagelist(struct nfs_read_data *rdata);
 +extern int objio_write_pagelist(struct nfs_write_data *wdata, int how);
++=======
+ extern int objio_read_pagelist(struct nfs_pgio_header *rdata);
+ extern int objio_write_pagelist(struct nfs_pgio_header *wdata, int how);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
  /*
   * callback API
@@@ -168,10 -168,10 +173,17 @@@ extern struct pnfs_layout_segment *objl
  extern void objlayout_free_lseg(struct pnfs_layout_segment *);
  
  extern enum pnfs_try_status objlayout_read_pagelist(
++<<<<<<< HEAD
 +	struct nfs_read_data *);
 +
 +extern enum pnfs_try_status objlayout_write_pagelist(
 +	struct nfs_write_data *,
++=======
+ 	struct nfs_pgio_header *);
+ 
+ extern enum pnfs_try_status objlayout_write_pagelist(
+ 	struct nfs_pgio_header *,
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	int how);
  
  extern void objlayout_encode_layoutcommit(
diff --cc fs/nfs/pagelist.c
index 00f3d2d2a504,ecb3d4cdbc85..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -307,6 -452,190 +307,193 @@@ size_t nfs_generic_pg_test(struct nfs_p
  }
  EXPORT_SYMBOL_GPL(nfs_generic_pg_test);
  
++<<<<<<< HEAD
++=======
+ struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *ops)
+ {
+ 	struct nfs_pgio_header *hdr = ops->rw_alloc_header();
+ 
+ 	if (hdr) {
+ 		INIT_LIST_HEAD(&hdr->pages);
+ 		spin_lock_init(&hdr->lock);
+ 		atomic_set(&hdr->refcnt, 0);
+ 		hdr->rw_ops = ops;
+ 	}
+ 	return hdr;
+ }
+ EXPORT_SYMBOL_GPL(nfs_pgio_header_alloc);
+ 
+ /*
+  * nfs_pgio_header_free - Free a read or write header
+  * @hdr: The header to free
+  */
+ void nfs_pgio_header_free(struct nfs_pgio_header *hdr)
+ {
+ 	hdr->rw_ops->rw_free_header(hdr);
+ }
+ EXPORT_SYMBOL_GPL(nfs_pgio_header_free);
+ 
+ /**
+  * nfs_pgio_data_alloc - Allocate pageio data
+  * @hdr: The header making a request
+  * @pagecount: Number of pages to create
+  */
+ static bool nfs_pgio_data_init(struct nfs_pgio_header *hdr,
+ 			       unsigned int pagecount)
+ {
+ 	if (nfs_pgarray_set(&hdr->page_array, pagecount)) {
+ 		atomic_inc(&hdr->refcnt);
+ 		return true;
+ 	}
+ 	return false;
+ }
+ 
+ /**
+  * nfs_pgio_data_destroy - Properly release pageio data
+  * @hdr: The header with data to destroy
+  */
+ void nfs_pgio_data_destroy(struct nfs_pgio_header *hdr)
+ {
+ 	put_nfs_open_context(hdr->args.context);
+ 	if (hdr->page_array.pagevec != hdr->page_array.page_array)
+ 		kfree(hdr->page_array.pagevec);
+ 	if (atomic_dec_and_test(&hdr->refcnt))
+ 		hdr->completion_ops->completion(hdr);
+ }
+ EXPORT_SYMBOL_GPL(nfs_pgio_data_destroy);
+ 
+ /**
+  * nfs_pgio_rpcsetup - Set up arguments for a pageio call
+  * @hdr: The pageio hdr
+  * @count: Number of bytes to read
+  * @offset: Initial offset
+  * @how: How to commit data (writes only)
+  * @cinfo: Commit information for the call (writes only)
+  */
+ static void nfs_pgio_rpcsetup(struct nfs_pgio_header *hdr,
+ 			      unsigned int count, unsigned int offset,
+ 			      int how, struct nfs_commit_info *cinfo)
+ {
+ 	struct nfs_page *req = hdr->req;
+ 
+ 	/* Set up the RPC argument and reply structs
+ 	 * NB: take care not to mess about with hdr->commit et al. */
+ 
+ 	hdr->args.fh     = NFS_FH(hdr->inode);
+ 	hdr->args.offset = req_offset(req) + offset;
+ 	/* pnfs_set_layoutcommit needs this */
+ 	hdr->mds_offset = hdr->args.offset;
+ 	hdr->args.pgbase = req->wb_pgbase + offset;
+ 	hdr->args.pages  = hdr->page_array.pagevec;
+ 	hdr->args.count  = count;
+ 	hdr->args.context = get_nfs_open_context(req->wb_context);
+ 	hdr->args.lock_context = req->wb_lock_context;
+ 	hdr->args.stable  = NFS_UNSTABLE;
+ 	switch (how & (FLUSH_STABLE | FLUSH_COND_STABLE)) {
+ 	case 0:
+ 		break;
+ 	case FLUSH_COND_STABLE:
+ 		if (nfs_reqs_to_commit(cinfo))
+ 			break;
+ 	default:
+ 		hdr->args.stable = NFS_FILE_SYNC;
+ 	}
+ 
+ 	hdr->res.fattr   = &hdr->fattr;
+ 	hdr->res.count   = count;
+ 	hdr->res.eof     = 0;
+ 	hdr->res.verf    = &hdr->writeverf;
+ 	nfs_fattr_init(&hdr->fattr);
+ }
+ 
+ /**
+  * nfs_pgio_prepare - Prepare pageio hdr to go over the wire
+  * @task: The current task
+  * @calldata: pageio header to prepare
+  */
+ static void nfs_pgio_prepare(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs_pgio_header *hdr = calldata;
+ 	int err;
+ 	err = NFS_PROTO(hdr->inode)->pgio_rpc_prepare(task, hdr);
+ 	if (err)
+ 		rpc_exit(task, err);
+ }
+ 
+ int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,
+ 		      const struct rpc_call_ops *call_ops, int how, int flags)
+ {
+ 	struct inode *inode = hdr->inode;
+ 	struct rpc_task *task;
+ 	struct rpc_message msg = {
+ 		.rpc_argp = &hdr->args,
+ 		.rpc_resp = &hdr->res,
+ 		.rpc_cred = hdr->cred,
+ 	};
+ 	struct rpc_task_setup task_setup_data = {
+ 		.rpc_client = clnt,
+ 		.task = &hdr->task,
+ 		.rpc_message = &msg,
+ 		.callback_ops = call_ops,
+ 		.callback_data = hdr,
+ 		.workqueue = nfsiod_workqueue,
+ 		.flags = RPC_TASK_ASYNC | flags,
+ 	};
+ 	int ret = 0;
+ 
+ 	hdr->rw_ops->rw_initiate(hdr, &msg, &task_setup_data, how);
+ 
+ 	dprintk("NFS: %5u initiated pgio call "
+ 		"(req %s/%llu, %u bytes @ offset %llu)\n",
+ 		hdr->task.tk_pid,
+ 		inode->i_sb->s_id,
+ 		(unsigned long long)NFS_FILEID(inode),
+ 		hdr->args.count,
+ 		(unsigned long long)hdr->args.offset);
+ 
+ 	task = rpc_run_task(&task_setup_data);
+ 	if (IS_ERR(task)) {
+ 		ret = PTR_ERR(task);
+ 		goto out;
+ 	}
+ 	if (how & FLUSH_SYNC) {
+ 		ret = rpc_wait_for_completion_task(task);
+ 		if (ret == 0)
+ 			ret = task->tk_status;
+ 	}
+ 	rpc_put_task(task);
+ out:
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(nfs_initiate_pgio);
+ 
+ /**
+  * nfs_pgio_error - Clean up from a pageio error
+  * @desc: IO descriptor
+  * @hdr: pageio header
+  */
+ static int nfs_pgio_error(struct nfs_pageio_descriptor *desc,
+ 			  struct nfs_pgio_header *hdr)
+ {
+ 	set_bit(NFS_IOHDR_REDO, &hdr->flags);
+ 	nfs_pgio_data_destroy(hdr);
+ 	desc->pg_completion_ops->error_cleanup(&desc->pg_list);
+ 	return -ENOMEM;
+ }
+ 
+ /**
+  * nfs_pgio_release - Release pageio data
+  * @calldata: The pageio header to release
+  */
+ static void nfs_pgio_release(void *calldata)
+ {
+ 	struct nfs_pgio_header *hdr = calldata;
+ 	if (hdr->rw_ops->rw_release)
+ 		hdr->rw_ops->rw_release(hdr);
+ 	nfs_pgio_data_destroy(hdr);
+ }
+ 
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  /**
   * nfs_pageio_init - initialise a page io descriptor
   * @desc: pointer to descriptor
@@@ -340,6 -671,89 +527,92 @@@ void nfs_pageio_init(struct nfs_pageio_
  }
  EXPORT_SYMBOL_GPL(nfs_pageio_init);
  
++<<<<<<< HEAD
++=======
+ /**
+  * nfs_pgio_result - Basic pageio error handling
+  * @task: The task that ran
+  * @calldata: Pageio header to check
+  */
+ static void nfs_pgio_result(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs_pgio_header *hdr = calldata;
+ 	struct inode *inode = hdr->inode;
+ 
+ 	dprintk("NFS: %s: %5u, (status %d)\n", __func__,
+ 		task->tk_pid, task->tk_status);
+ 
+ 	if (hdr->rw_ops->rw_done(task, hdr, inode) != 0)
+ 		return;
+ 	if (task->tk_status < 0)
+ 		nfs_set_pgio_error(hdr, task->tk_status, hdr->args.offset);
+ 	else
+ 		hdr->rw_ops->rw_result(task, hdr);
+ }
+ 
+ /*
+  * Create an RPC task for the given read or write request and kick it.
+  * The page must have been locked by the caller.
+  *
+  * It may happen that the page we're passed is not marked dirty.
+  * This is the case if nfs_updatepage detects a conflicting request
+  * that has been written but not committed.
+  */
+ int nfs_generic_pgio(struct nfs_pageio_descriptor *desc,
+ 		     struct nfs_pgio_header *hdr)
+ {
+ 	struct nfs_page		*req;
+ 	struct page		**pages;
+ 	struct list_head *head = &desc->pg_list;
+ 	struct nfs_commit_info cinfo;
+ 
+ 	if (!nfs_pgio_data_init(hdr, nfs_page_array_len(desc->pg_base,
+ 			   desc->pg_count)))
+ 		return nfs_pgio_error(desc, hdr);
+ 
+ 	nfs_init_cinfo(&cinfo, desc->pg_inode, desc->pg_dreq);
+ 	pages = hdr->page_array.pagevec;
+ 	while (!list_empty(head)) {
+ 		req = nfs_list_entry(head->next);
+ 		nfs_list_remove_request(req);
+ 		nfs_list_add_request(req, &hdr->pages);
+ 		*pages++ = req->wb_page;
+ 	}
+ 
+ 	if ((desc->pg_ioflags & FLUSH_COND_STABLE) &&
+ 	    (desc->pg_moreio || nfs_reqs_to_commit(&cinfo)))
+ 		desc->pg_ioflags &= ~FLUSH_COND_STABLE;
+ 
+ 	/* Set up the argument struct */
+ 	nfs_pgio_rpcsetup(hdr, desc->pg_count, 0, desc->pg_ioflags, &cinfo);
+ 	desc->pg_rpc_callops = &nfs_pgio_common_ops;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(nfs_generic_pgio);
+ 
+ static int nfs_generic_pg_pgios(struct nfs_pageio_descriptor *desc)
+ {
+ 	struct nfs_pgio_header *hdr;
+ 	int ret;
+ 
+ 	hdr = nfs_pgio_header_alloc(desc->pg_rw_ops);
+ 	if (!hdr) {
+ 		desc->pg_completion_ops->error_cleanup(&desc->pg_list);
+ 		return -ENOMEM;
+ 	}
+ 	nfs_pgheader_init(desc, hdr, nfs_pgio_header_free);
+ 	atomic_inc(&hdr->refcnt);
+ 	ret = nfs_generic_pgio(desc, hdr);
+ 	if (ret == 0)
+ 		ret = nfs_initiate_pgio(NFS_CLIENT(hdr->inode),
+ 					hdr, desc->pg_rpc_callops,
+ 					desc->pg_ioflags, 0);
+ 	if (atomic_dec_and_test(&hdr->refcnt))
+ 		hdr->completion_ops->completion(hdr);
+ 	return ret;
+ }
+ 
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  static bool nfs_match_open_context(const struct nfs_open_context *ctx1,
  		const struct nfs_open_context *ctx2)
  {
diff --cc fs/nfs/pnfs.c
index eed474e3fcc7,ecc911347750..000000000000
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@@ -1502,9 -1502,8 +1502,12 @@@ int pnfs_write_done_resend_to_mds(struc
  }
  EXPORT_SYMBOL_GPL(pnfs_write_done_resend_to_mds);
  
++<<<<<<< HEAD
 +static void pnfs_ld_handle_write_error(struct nfs_write_data *data)
++=======
+ static void pnfs_ld_handle_write_error(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = data->header;
  
  	dprintk("pnfs write error = %d\n", hdr->pnfs_error);
  	if (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &
@@@ -1521,36 -1520,32 +1524,48 @@@
  /*
   * Called by non rpc-based layout drivers
   */
++<<<<<<< HEAD
 +void pnfs_ld_write_done(struct nfs_write_data *data)
++=======
+ void pnfs_ld_write_done(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = data->header;
- 
- 	trace_nfs4_pnfs_write(data, hdr->pnfs_error);
+ 	trace_nfs4_pnfs_write(hdr, hdr->pnfs_error);
  	if (!hdr->pnfs_error) {
- 		pnfs_set_layoutcommit(data);
- 		hdr->mds_ops->rpc_call_done(&data->task, data);
+ 		pnfs_set_layoutcommit(hdr);
+ 		hdr->mds_ops->rpc_call_done(&hdr->task, hdr);
  	} else
- 		pnfs_ld_handle_write_error(data);
- 	hdr->mds_ops->rpc_release(data);
+ 		pnfs_ld_handle_write_error(hdr);
+ 	hdr->mds_ops->rpc_release(hdr);
  }
  EXPORT_SYMBOL_GPL(pnfs_ld_write_done);
  
  static void
  pnfs_write_through_mds(struct nfs_pageio_descriptor *desc,
++<<<<<<< HEAD
 +		struct nfs_write_data *data)
++=======
+ 		struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = data->header;
- 
  	if (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {
  		list_splice_tail_init(&hdr->pages, &desc->pg_list);
  		nfs_pageio_reset_write_mds(desc);
  		desc->pg_recoalesce = 1;
  	}
++<<<<<<< HEAD
 +	nfs_writedata_release(data);
 +}
 +
 +static enum pnfs_try_status
 +pnfs_try_to_write_data(struct nfs_write_data *wdata,
++=======
+ 	nfs_pgio_data_destroy(hdr);
+ }
+ 
+ static enum pnfs_try_status
+ pnfs_try_to_write_data(struct nfs_pgio_header *hdr,
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  			const struct rpc_call_ops *call_ops,
  			struct pnfs_layout_segment *lseg,
  			int how)
@@@ -1572,23 -1566,17 +1586,32 @@@
  }
  
  static void
 -pnfs_do_write(struct nfs_pageio_descriptor *desc,
 -	      struct nfs_pgio_header *hdr, int how)
 +pnfs_do_multiple_writes(struct nfs_pageio_descriptor *desc, struct list_head *head, int how)
  {
++<<<<<<< HEAD
 +	struct nfs_write_data *data;
++=======
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	const struct rpc_call_ops *call_ops = desc->pg_rpc_callops;
  	struct pnfs_layout_segment *lseg = desc->pg_lseg;
 -	enum pnfs_try_status trypnfs;
  
  	desc->pg_lseg = NULL;
++<<<<<<< HEAD
 +	while (!list_empty(head)) {
 +		enum pnfs_try_status trypnfs;
 +
 +		data = list_first_entry(head, struct nfs_write_data, list);
 +		list_del_init(&data->list);
 +
 +		trypnfs = pnfs_try_to_write_data(data, call_ops, lseg, how);
 +		if (trypnfs == PNFS_NOT_ATTEMPTED)
 +			pnfs_write_through_mds(desc, data);
 +	}
++=======
+ 	trypnfs = pnfs_try_to_write_data(hdr, call_ops, lseg, how);
+ 	if (trypnfs == PNFS_NOT_ATTEMPTED)
+ 		pnfs_write_through_mds(desc, hdr);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	pnfs_put_lseg(lseg);
  }
  
@@@ -1657,10 -1643,8 +1680,12 @@@ int pnfs_read_done_resend_to_mds(struc
  }
  EXPORT_SYMBOL_GPL(pnfs_read_done_resend_to_mds);
  
++<<<<<<< HEAD
 +static void pnfs_ld_handle_read_error(struct nfs_read_data *data)
++=======
+ static void pnfs_ld_handle_read_error(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = data->header;
- 
  	dprintk("pnfs read error = %d\n", hdr->pnfs_error);
  	if (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &
  	    PNFS_LAYOUTRET_ON_ERROR) {
@@@ -1676,39 -1660,35 +1701,51 @@@
  /*
   * Called by non rpc-based layout drivers
   */
++<<<<<<< HEAD
 +void pnfs_ld_read_done(struct nfs_read_data *data)
++=======
+ void pnfs_ld_read_done(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = data->header;
- 
- 	trace_nfs4_pnfs_read(data, hdr->pnfs_error);
+ 	trace_nfs4_pnfs_read(hdr, hdr->pnfs_error);
  	if (likely(!hdr->pnfs_error)) {
- 		__nfs4_read_done_cb(data);
- 		hdr->mds_ops->rpc_call_done(&data->task, data);
+ 		__nfs4_read_done_cb(hdr);
+ 		hdr->mds_ops->rpc_call_done(&hdr->task, hdr);
  	} else
- 		pnfs_ld_handle_read_error(data);
- 	hdr->mds_ops->rpc_release(data);
+ 		pnfs_ld_handle_read_error(hdr);
+ 	hdr->mds_ops->rpc_release(hdr);
  }
  EXPORT_SYMBOL_GPL(pnfs_ld_read_done);
  
  static void
  pnfs_read_through_mds(struct nfs_pageio_descriptor *desc,
++<<<<<<< HEAD
 +		struct nfs_read_data *data)
++=======
+ 		struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = data->header;
- 
  	if (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {
  		list_splice_tail_init(&hdr->pages, &desc->pg_list);
  		nfs_pageio_reset_read_mds(desc);
  		desc->pg_recoalesce = 1;
  	}
++<<<<<<< HEAD
 +	nfs_readdata_release(data);
++=======
+ 	nfs_pgio_data_destroy(hdr);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  }
  
  /*
   * Call the appropriate parallel I/O subsystem read function.
   */
  static enum pnfs_try_status
++<<<<<<< HEAD
 +pnfs_try_to_read_data(struct nfs_read_data *rdata,
++=======
+ pnfs_try_to_read_data(struct nfs_pgio_header *hdr,
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  		       const struct rpc_call_ops *call_ops,
  		       struct pnfs_layout_segment *lseg)
  {
@@@ -1730,23 -1709,16 +1766,32 @@@
  }
  
  static void
 -pnfs_do_read(struct nfs_pageio_descriptor *desc, struct nfs_pgio_header *hdr)
 +pnfs_do_multiple_reads(struct nfs_pageio_descriptor *desc, struct list_head *head)
  {
++<<<<<<< HEAD
 +	struct nfs_read_data *data;
++=======
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	const struct rpc_call_ops *call_ops = desc->pg_rpc_callops;
  	struct pnfs_layout_segment *lseg = desc->pg_lseg;
 -	enum pnfs_try_status trypnfs;
  
  	desc->pg_lseg = NULL;
++<<<<<<< HEAD
 +	while (!list_empty(head)) {
 +		enum pnfs_try_status trypnfs;
 +
 +		data = list_first_entry(head, struct nfs_read_data, list);
 +		list_del_init(&data->list);
 +
 +		trypnfs = pnfs_try_to_read_data(data, call_ops, lseg);
 +		if (trypnfs == PNFS_NOT_ATTEMPTED)
 +			pnfs_read_through_mds(desc, data);
 +	}
++=======
+ 	trypnfs = pnfs_try_to_read_data(hdr, call_ops, lseg);
+ 	if (trypnfs == PNFS_NOT_ATTEMPTED)
+ 		pnfs_read_through_mds(desc, hdr);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	pnfs_put_lseg(lseg);
  }
  
@@@ -1831,12 -1801,11 +1876,15 @@@ void pnfs_set_lo_fail(struct pnfs_layou
  EXPORT_SYMBOL_GPL(pnfs_set_lo_fail);
  
  void
++<<<<<<< HEAD
 +pnfs_set_layoutcommit(struct nfs_write_data *wdata)
++=======
+ pnfs_set_layoutcommit(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_header *hdr = wdata->header;
  	struct inode *inode = hdr->inode;
  	struct nfs_inode *nfsi = NFS_I(inode);
- 	loff_t end_pos = wdata->mds_offset + wdata->res.count;
+ 	loff_t end_pos = hdr->mds_offset + hdr->res.count;
  	bool mark_as_dirty = false;
  
  	spin_lock(&inode->i_lock);
diff --cc fs/nfs/pnfs.h
index bb1f061f76db,a4a58be94064..000000000000
--- a/fs/nfs/pnfs.h
+++ b/fs/nfs/pnfs.h
@@@ -113,8 -113,8 +113,13 @@@ struct pnfs_layoutdriver_type 
  	 * Return PNFS_ATTEMPTED to indicate the layout code has attempted
  	 * I/O, else return PNFS_NOT_ATTEMPTED to fall back to normal NFS
  	 */
++<<<<<<< HEAD
 +	enum pnfs_try_status (*read_pagelist) (struct nfs_read_data *nfs_data);
 +	enum pnfs_try_status (*write_pagelist) (struct nfs_write_data *nfs_data, int how);
++=======
+ 	enum pnfs_try_status (*read_pagelist)(struct nfs_pgio_header *);
+ 	enum pnfs_try_status (*write_pagelist)(struct nfs_pgio_header *, int);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
  	void (*free_deviceid_node) (struct nfs4_deviceid_node *);
  
@@@ -213,13 -213,13 +218,22 @@@ bool pnfs_roc(struct inode *ino)
  void pnfs_roc_release(struct inode *ino);
  void pnfs_roc_set_barrier(struct inode *ino, u32 barrier);
  bool pnfs_roc_drain(struct inode *ino, u32 *barrier, struct rpc_task *task);
++<<<<<<< HEAD
 +void pnfs_set_layoutcommit(struct nfs_write_data *wdata);
++=======
+ void pnfs_set_layoutcommit(struct nfs_pgio_header *);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  void pnfs_cleanup_layoutcommit(struct nfs4_layoutcommit_data *data);
  int pnfs_layoutcommit_inode(struct inode *inode, bool sync);
  int _pnfs_return_layout(struct inode *);
  int pnfs_commit_and_return_layout(struct inode *);
++<<<<<<< HEAD
 +void pnfs_ld_write_done(struct nfs_write_data *);
 +void pnfs_ld_read_done(struct nfs_read_data *);
++=======
+ void pnfs_ld_write_done(struct nfs_pgio_header *);
+ void pnfs_ld_read_done(struct nfs_pgio_header *);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  struct pnfs_layout_segment *pnfs_update_layout(struct inode *ino,
  					       struct nfs_open_context *ctx,
  					       loff_t pos,
diff --cc fs/nfs/proc.c
index 8cc227fcd4d2,b09cc23d6f43..000000000000
--- a/fs/nfs/proc.c
+++ b/fs/nfs/proc.c
@@@ -578,9 -578,9 +578,13 @@@ nfs_proc_pathconf(struct nfs_server *se
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int nfs_read_done(struct rpc_task *task, struct nfs_read_data *data)
++=======
+ static int nfs_read_done(struct rpc_task *task, struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct inode *inode = data->header->inode;
+ 	struct inode *inode = hdr->inode;
  
  	nfs_invalidate_atime(inode);
  	if (task->tk_status >= 0) {
@@@ -594,30 -594,33 +598,49 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void nfs_proc_read_setup(struct nfs_read_data *data, struct rpc_message *msg)
++=======
+ static void nfs_proc_read_setup(struct nfs_pgio_header *hdr,
+ 				struct rpc_message *msg)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
  	msg->rpc_proc = &nfs_procedures[NFSPROC_READ];
  }
  
++<<<<<<< HEAD
 +static int nfs_proc_read_rpc_prepare(struct rpc_task *task, struct nfs_read_data *data)
++=======
+ static int nfs_proc_pgio_rpc_prepare(struct rpc_task *task,
+ 				     struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
  	rpc_call_start(task);
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int nfs_write_done(struct rpc_task *task, struct nfs_write_data *data)
++=======
+ static int nfs_write_done(struct rpc_task *task, struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct inode *inode = data->header->inode;
+ 	struct inode *inode = hdr->inode;
  
  	if (task->tk_status >= 0)
- 		nfs_post_op_update_inode_force_wcc(inode, data->res.fattr);
+ 		nfs_post_op_update_inode_force_wcc(inode, hdr->res.fattr);
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void nfs_proc_write_setup(struct nfs_write_data *data, struct rpc_message *msg)
++=======
+ static void nfs_proc_write_setup(struct nfs_pgio_header *hdr,
+ 				 struct rpc_message *msg)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
  	/* Note: NFSv2 ignores @stable and always uses NFS_FILE_SYNC */
- 	data->args.stable = NFS_FILE_SYNC;
+ 	hdr->args.stable = NFS_FILE_SYNC;
  	msg->rpc_proc = &nfs_procedures[NFSPROC_WRITE];
  }
  
diff --cc fs/nfs/read.c
index d58a7ae6152b,b1532b73fea3..000000000000
--- a/fs/nfs/read.c
+++ b/fs/nfs/read.c
@@@ -211,95 -172,15 +211,106 @@@ out
  	hdr->release(hdr);
  }
  
++<<<<<<< HEAD
 +int nfs_initiate_read(struct rpc_clnt *clnt,
 +		      struct nfs_read_data *data,
 +		      const struct rpc_call_ops *call_ops, int flags)
++=======
+ static void nfs_initiate_read(struct nfs_pgio_header *hdr,
+ 			      struct rpc_message *msg,
+ 			      struct rpc_task_setup *task_setup_data, int how)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct inode *inode = data->header->inode;
+ 	struct inode *inode = hdr->inode;
  	int swap_flags = IS_SWAPFILE(inode) ? NFS_RPC_SWAPFLAGS : 0;
 +	struct rpc_task *task;
 +	struct rpc_message msg = {
 +		.rpc_argp = &data->args,
 +		.rpc_resp = &data->res,
 +		.rpc_cred = data->header->cred,
 +	};
 +	struct rpc_task_setup task_setup_data = {
 +		.task = &data->task,
 +		.rpc_client = clnt,
 +		.rpc_message = &msg,
 +		.callback_ops = call_ops,
 +		.callback_data = data,
 +		.workqueue = nfsiod_workqueue,
 +		.flags = RPC_TASK_ASYNC | swap_flags | flags,
 +	};
  
++<<<<<<< HEAD
 +	/* Set up the initial task struct. */
 +	NFS_PROTO(inode)->read_setup(data, &msg);
 +
 +	dprintk("NFS: %5u initiated read call (req %s/%llu, %u bytes @ "
 +			"offset %llu)\n",
 +			data->task.tk_pid,
 +			inode->i_sb->s_id,
 +			(unsigned long long)NFS_FILEID(inode),
 +			data->args.count,
 +			(unsigned long long)data->args.offset);
 +
 +	task = rpc_run_task(&task_setup_data);
 +	if (IS_ERR(task))
 +		return PTR_ERR(task);
 +	rpc_put_task(task);
 +	return 0;
 +}
 +EXPORT_SYMBOL_GPL(nfs_initiate_read);
 +
 +/*
 + * Set up the NFS read request struct
 + */
 +static void nfs_read_rpcsetup(struct nfs_read_data *data,
 +		unsigned int count, unsigned int offset)
 +{
 +	struct nfs_page *req = data->header->req;
 +
 +	data->args.fh     = NFS_FH(data->header->inode);
 +	data->args.offset = req_offset(req) + offset;
 +	data->args.pgbase = req->wb_pgbase + offset;
 +	data->args.pages  = data->pages.pagevec;
 +	data->args.count  = count;
 +	data->args.context = get_nfs_open_context(req->wb_context);
 +	data->args.lock_context = req->wb_lock_context;
 +
 +	data->res.fattr   = &data->fattr;
 +	data->res.count   = count;
 +	data->res.eof     = 0;
 +	nfs_fattr_init(&data->fattr);
 +}
 +
 +static int nfs_do_read(struct nfs_read_data *data,
 +		const struct rpc_call_ops *call_ops)
 +{
 +	struct inode *inode = data->header->inode;
 +
 +	return nfs_initiate_read(NFS_CLIENT(inode), data, call_ops, 0);
 +}
 +
 +static int
 +nfs_do_multiple_reads(struct list_head *head,
 +		const struct rpc_call_ops *call_ops)
 +{
 +	struct nfs_read_data *data;
 +	int ret = 0;
 +
 +	while (!list_empty(head)) {
 +		int ret2;
 +
 +		data = list_first_entry(head, struct nfs_read_data, list);
 +		list_del_init(&data->list);
 +
 +		ret2 = nfs_do_read(data, call_ops);
 +		if (ret == 0)
 +			ret = ret2;
 +	}
 +	return ret;
++=======
+ 	task_setup_data->flags |= swap_flags;
+ 	NFS_PROTO(inode)->read_setup(hdr, msg);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  }
  
  static void
@@@ -447,15 -204,11 +458,23 @@@ static const struct nfs_pageio_ops nfs_
   * This is the callback from RPC telling us whether a reply was
   * received or some error occurred (timeout or socket shutdown).
   */
++<<<<<<< HEAD
 +int nfs_readpage_result(struct rpc_task *task, struct nfs_read_data *data)
 +{
 +	struct inode *inode = data->header->inode;
 +	int status;
 +
 +	dprintk("NFS: %s: %5u, (status %d)\n", __func__, task->tk_pid,
 +			task->tk_status);
 +
 +	status = NFS_PROTO(inode)->read_done(task, data);
++=======
+ static int nfs_readpage_done(struct rpc_task *task,
+ 			     struct nfs_pgio_header *hdr,
+ 			     struct inode *inode)
+ {
+ 	int status = NFS_PROTO(inode)->read_done(task, hdr);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	if (status != 0)
  		return status;
  
@@@ -468,40 -221,34 +487,52 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void nfs_readpage_retry(struct rpc_task *task, struct nfs_read_data *data)
++=======
+ static void nfs_readpage_retry(struct rpc_task *task,
+ 			       struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct nfs_pgio_args *argp = &data->args;
- 	struct nfs_pgio_res  *resp = &data->res;
+ 	struct nfs_pgio_args *argp = &hdr->args;
+ 	struct nfs_pgio_res  *resp = &hdr->res;
  
  	/* This is a short read! */
- 	nfs_inc_stats(data->header->inode, NFSIOS_SHORTREAD);
+ 	nfs_inc_stats(hdr->inode, NFSIOS_SHORTREAD);
  	/* Has the server at least made some progress? */
  	if (resp->count == 0) {
- 		nfs_set_pgio_error(data->header, -EIO, argp->offset);
+ 		nfs_set_pgio_error(hdr, -EIO, argp->offset);
  		return;
  	}
- 	/* Yes, so retry the read at the end of the data */
- 	data->mds_offset += resp->count;
+ 	/* Yes, so retry the read at the end of the hdr */
+ 	hdr->mds_offset += resp->count;
  	argp->offset += resp->count;
  	argp->pgbase += resp->count;
  	argp->count -= resp->count;
  	rpc_restart_call_prepare(task);
  }
  
++<<<<<<< HEAD
 +static void nfs_readpage_result_common(struct rpc_task *task, void *calldata)
 +{
 +	struct nfs_read_data *data = calldata;
 +	struct nfs_pgio_header *hdr = data->header;
 +
 +	/* Note the only returns of nfs_readpage_result are 0 and -EAGAIN */
 +	if (nfs_readpage_result(task, data) != 0)
 +		return;
 +	if (task->tk_status < 0)
 +		nfs_set_pgio_error(hdr, task->tk_status, data->args.offset);
 +	else if (data->res.eof) {
++=======
+ static void nfs_readpage_result(struct rpc_task *task,
+ 				struct nfs_pgio_header *hdr)
+ {
+ 	if (hdr->res.eof) {
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  		loff_t bound;
  
- 		bound = data->args.offset + data->res.count;
+ 		bound = hdr->args.offset + hdr->res.count;
  		spin_lock(&hdr->lock);
  		if (bound < hdr->io_start + hdr->good_bytes) {
  			set_bit(NFS_IOHDR_EOF, &hdr->flags);
@@@ -509,30 -256,10 +540,30 @@@
  			hdr->good_bytes = bound - hdr->io_start;
  		}
  		spin_unlock(&hdr->lock);
- 	} else if (data->res.count != data->args.count)
- 		nfs_readpage_retry(task, data);
+ 	} else if (hdr->res.count != hdr->args.count)
+ 		nfs_readpage_retry(task, hdr);
  }
  
 +static void nfs_readpage_release_common(void *calldata)
 +{
 +	nfs_readdata_release(calldata);
 +}
 +
 +void nfs_read_prepare(struct rpc_task *task, void *calldata)
 +{
 +	struct nfs_read_data *data = calldata;
 +	int err;
 +	err = NFS_PROTO(data->header->inode)->read_rpc_prepare(task, data);
 +	if (err)
 +		rpc_exit(task, err);
 +}
 +
 +static const struct rpc_call_ops nfs_read_common_ops = {
 +	.rpc_call_prepare = nfs_read_prepare,
 +	.rpc_call_done = nfs_readpage_result_common,
 +	.rpc_release = nfs_readpage_release_common,
 +};
 +
  /*
   * Read a page over NFS.
   * We read the page synchronously in the following case:
diff --cc fs/nfs/write.c
index 7571542ecbdc,6a2d0986a3a3..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -642,11 -596,11 +642,19 @@@ nfs_clear_request_commit(struct nfs_pag
  }
  
  static inline
++<<<<<<< HEAD
 +int nfs_write_need_commit(struct nfs_write_data *data)
 +{
 +	if (data->verf.committed == NFS_DATA_SYNC)
 +		return data->header->lseg == NULL;
 +	return data->verf.committed != NFS_FILE_SYNC;
++=======
+ int nfs_write_need_commit(struct nfs_pgio_header *hdr)
+ {
+ 	if (hdr->writeverf.committed == NFS_DATA_SYNC)
+ 		return hdr->lseg == NULL;
+ 	return hdr->writeverf.committed != NFS_FILE_SYNC;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  }
  
  #else
@@@ -673,7 -627,7 +681,11 @@@ nfs_clear_request_commit(struct nfs_pag
  }
  
  static inline
++<<<<<<< HEAD
 +int nfs_write_need_commit(struct nfs_write_data *data)
++=======
+ int nfs_write_need_commit(struct nfs_pgio_header *hdr)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
  	return 0;
  }
@@@ -1051,126 -1013,18 +1063,140 @@@ static int flush_task_priority(int how
  	return RPC_PRIORITY_NORMAL;
  }
  
++<<<<<<< HEAD
 +int nfs_initiate_write(struct rpc_clnt *clnt,
 +		       struct nfs_write_data *data,
 +		       const struct rpc_call_ops *call_ops,
 +		       int how, int flags)
++=======
+ static void nfs_initiate_write(struct nfs_pgio_header *hdr,
+ 			       struct rpc_message *msg,
+ 			       struct rpc_task_setup *task_setup_data, int how)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
- 	struct inode *inode = data->header->inode;
+ 	struct inode *inode = hdr->inode;
  	int priority = flush_task_priority(how);
 +	struct rpc_task *task;
 +	struct rpc_message msg = {
 +		.rpc_argp = &data->args,
 +		.rpc_resp = &data->res,
 +		.rpc_cred = data->header->cred,
 +	};
 +	struct rpc_task_setup task_setup_data = {
 +		.rpc_client = clnt,
 +		.task = &data->task,
 +		.rpc_message = &msg,
 +		.callback_ops = call_ops,
 +		.callback_data = data,
 +		.workqueue = nfsiod_workqueue,
 +		.flags = RPC_TASK_ASYNC | flags,
 +		.priority = priority,
 +	};
 +	int ret = 0;
 +
++<<<<<<< HEAD
 +	/* Set up the initial task struct.  */
 +	NFS_PROTO(inode)->write_setup(data, &msg);
 +
 +	dprintk("NFS: %5u initiated write call "
 +		"(req %s/%llu, %u bytes @ offset %llu)\n",
 +		data->task.tk_pid,
 +		inode->i_sb->s_id,
 +		(unsigned long long)NFS_FILEID(inode),
 +		data->args.count,
 +		(unsigned long long)data->args.offset);
 +
 +	nfs4_state_protect_write(NFS_SERVER(inode)->nfs_client,
 +				 &task_setup_data.rpc_client, &msg, data);
 +
 +	task = rpc_run_task(&task_setup_data);
 +	if (IS_ERR(task)) {
 +		ret = PTR_ERR(task);
 +		goto out;
 +	}
 +	if (how & FLUSH_SYNC) {
 +		ret = rpc_wait_for_completion_task(task);
 +		if (ret == 0)
 +			ret = task->tk_status;
 +	}
 +	rpc_put_task(task);
 +out:
 +	return ret;
 +}
 +EXPORT_SYMBOL_GPL(nfs_initiate_write);
 +
 +/*
 + * Set up the argument/result storage required for the RPC call.
 + */
 +static void nfs_write_rpcsetup(struct nfs_write_data *data,
 +		unsigned int count, unsigned int offset,
 +		int how, struct nfs_commit_info *cinfo)
 +{
 +	struct nfs_page *req = data->header->req;
 +
 +	/* Set up the RPC argument and reply structs
 +	 * NB: take care not to mess about with data->commit et al. */
 +
 +	data->args.fh     = NFS_FH(data->header->inode);
 +	data->args.offset = req_offset(req) + offset;
 +	/* pnfs_set_layoutcommit needs this */
 +	data->mds_offset = data->args.offset;
 +	data->args.pgbase = req->wb_pgbase + offset;
 +	data->args.pages  = data->pages.pagevec;
 +	data->args.count  = count;
 +	data->args.context = get_nfs_open_context(req->wb_context);
 +	data->args.lock_context = req->wb_lock_context;
 +	data->args.stable  = NFS_UNSTABLE;
 +	switch (how & (FLUSH_STABLE | FLUSH_COND_STABLE)) {
 +	case 0:
 +		break;
 +	case FLUSH_COND_STABLE:
 +		if (nfs_reqs_to_commit(cinfo))
 +			break;
 +	default:
 +		data->args.stable = NFS_FILE_SYNC;
 +	}
 +
 +	data->res.fattr   = &data->fattr;
 +	data->res.count   = count;
 +	data->res.verf    = &data->verf;
 +	nfs_fattr_init(&data->fattr);
 +}
  
 +static int nfs_do_write(struct nfs_write_data *data,
 +		const struct rpc_call_ops *call_ops,
 +		int how)
 +{
 +	struct inode *inode = data->header->inode;
 +
 +	return nfs_initiate_write(NFS_CLIENT(inode), data, call_ops, how, 0);
 +}
 +
 +static int nfs_do_multiple_writes(struct list_head *head,
 +		const struct rpc_call_ops *call_ops,
 +		int how)
 +{
 +	struct nfs_write_data *data;
 +	int ret = 0;
 +
 +	while (!list_empty(head)) {
 +		int ret2;
 +
 +		data = list_first_entry(head, struct nfs_write_data, list);
 +		list_del_init(&data->list);
 +		
 +		ret2 = nfs_do_write(data, call_ops, how);
 +		 if (ret == 0)
 +			 ret = ret2;
 +	}
 +	return ret;
++=======
+ 	task_setup_data->priority = priority;
+ 	NFS_PROTO(inode)->write_setup(hdr, msg);
+ 
+ 	nfs4_state_protect_write(NFS_SERVER(inode)->nfs_client,
+ 				 &task_setup_data->rpc_client, msg, hdr);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  }
  
  /* If a nfs_flush_* function fails, it should remove reqs from @head and
@@@ -1381,33 -1086,17 +1407,44 @@@ void nfs_commit_prepare(struct rpc_tas
  	NFS_PROTO(data->inode)->commit_rpc_prepare(task, data);
  }
  
++<<<<<<< HEAD
 +/*
 + * Handle a write reply that flushes a whole page.
 + *
 + * FIXME: There is an inherent race with invalidate_inode_pages and
 + *	  writebacks since the page->count is kept > 1 for as long
 + *	  as the page has a write request pending.
 + */
 +static void nfs_writeback_done_common(struct rpc_task *task, void *calldata)
 +{
 +	struct nfs_write_data	*data = calldata;
 +
 +	nfs_writeback_done(task, data);
 +}
 +
 +static void nfs_writeback_release_common(void *calldata)
 +{
 +	struct nfs_write_data	*data = calldata;
 +	struct nfs_pgio_header *hdr = data->header;
 +	int status = data->task.tk_status;
++=======
+ static void nfs_writeback_release_common(struct nfs_pgio_header *hdr)
+ {
+ 	int status = hdr->task.tk_status;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
- 	if ((status >= 0) && nfs_write_need_commit(data)) {
+ 	if ((status >= 0) && nfs_write_need_commit(hdr)) {
  		spin_lock(&hdr->lock);
  		if (test_bit(NFS_IOHDR_NEED_RESCHED, &hdr->flags))
  			; /* Do nothing */
  		else if (!test_and_set_bit(NFS_IOHDR_NEED_COMMIT, &hdr->flags))
++<<<<<<< HEAD
 +			memcpy(hdr->verf, &data->verf, sizeof(*hdr->verf));
 +		else if (memcmp(hdr->verf, &data->verf, sizeof(*hdr->verf)))
++=======
+ 			memcpy(&hdr->verf, &hdr->writeverf, sizeof(hdr->verf));
+ 		else if (memcmp(&hdr->verf, &hdr->writeverf, sizeof(hdr->verf)))
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  			set_bit(NFS_IOHDR_NEED_RESCHED, &hdr->flags);
  		spin_unlock(&hdr->lock);
  	}
@@@ -1448,16 -1130,12 +1485,22 @@@ static int nfs_should_remove_suid(cons
  /*
   * This function is called when the WRITE call is complete.
   */
++<<<<<<< HEAD
 +void nfs_writeback_done(struct rpc_task *task, struct nfs_write_data *data)
++=======
+ static int nfs_writeback_done(struct rpc_task *task,
+ 			      struct nfs_pgio_header *hdr,
+ 			      struct inode *inode)
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  {
 +	struct nfs_pgio_args	*argp = &data->args;
 +	struct nfs_pgio_res	*resp = &data->res;
 +	struct inode		*inode = data->header->inode;
  	int status;
  
 +	dprintk("NFS: %5u nfs_writeback_done (status %d)\n",
 +		task->tk_pid, task->tk_status);
 +
  	/*
  	 * ->write_done will attempt to use post-op attributes to detect
  	 * conflicting writes by other clients.  A strict interpretation
@@@ -1465,13 -1143,14 +1508,22 @@@
  	 * another writer had changed the file, but some applications
  	 * depend on tighter cache coherency when writing.
  	 */
- 	status = NFS_PROTO(inode)->write_done(task, data);
+ 	status = NFS_PROTO(inode)->write_done(task, hdr);
  	if (status != 0)
++<<<<<<< HEAD
 +		return;
 +	nfs_add_stats(inode, NFSIOS_SERVERWRITTENBYTES, resp->count);
 +
 +#if IS_ENABLED(CONFIG_NFS_V3) || IS_ENABLED(CONFIG_NFS_V4)
 +	if (resp->verf->committed < argp->stable && task->tk_status >= 0) {
++=======
+ 		return status;
+ 	nfs_add_stats(inode, NFSIOS_SERVERWRITTENBYTES, hdr->res.count);
+ 
+ #if IS_ENABLED(CONFIG_NFS_V3) || IS_ENABLED(CONFIG_NFS_V4)
+ 	if (hdr->res.verf->committed < hdr->args.stable &&
+ 	    task->tk_status >= 0) {
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  		/* We tried a write call, but the server did not
  		 * commit data to stable storage even though we
  		 * requested it.
@@@ -1487,7 -1166,7 +1539,11 @@@
  			dprintk("NFS:       faulty NFS server %s:"
  				" (committed = %d) != (stable = %d)\n",
  				NFS_SERVER(inode)->nfs_client->cl_hostname,
++<<<<<<< HEAD
 +				resp->verf->committed, argp->stable);
++=======
+ 				hdr->res.verf->committed, hdr->args.stable);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  			complain = jiffies + 300 * HZ;
  		}
  	}
@@@ -1500,12 -1175,23 +1556,30 @@@
  	/* Deal with the suid/sgid bit corner case */
  	if (nfs_should_remove_suid(inode))
  		nfs_mark_for_revalidate(inode);
++<<<<<<< HEAD
++=======
+ 	return 0;
+ }
+ 
+ /*
+  * This function is called when the WRITE call is complete.
+  */
+ static void nfs_writeback_result(struct rpc_task *task,
+ 				 struct nfs_pgio_header *hdr)
+ {
+ 	struct nfs_pgio_args	*argp = &hdr->args;
+ 	struct nfs_pgio_res	*resp = &hdr->res;
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
  	if (resp->count < argp->count) {
  		static unsigned long    complain;
  
  		/* This a short write! */
++<<<<<<< HEAD
 +		nfs_inc_stats(inode, NFSIOS_SHORTWRITE);
++=======
+ 		nfs_inc_stats(hdr->inode, NFSIOS_SHORTWRITE);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  
  		/* Has the server at least made some progress? */
  		if (resp->count == 0) {
diff --cc include/linux/nfs_page.h
index 214e09851870,d0fae7b78252..000000000000
--- a/include/linux/nfs_page.h
+++ b/include/linux/nfs_page.h
@@@ -51,6 -60,18 +51,21 @@@ struct nfs_pageio_ops 
  	int	(*pg_doio)(struct nfs_pageio_descriptor *);
  };
  
++<<<<<<< HEAD
++=======
+ struct nfs_rw_ops {
+ 	const fmode_t rw_mode;
+ 	struct nfs_pgio_header *(*rw_alloc_header)(void);
+ 	void (*rw_free_header)(struct nfs_pgio_header *);
+ 	void (*rw_release)(struct nfs_pgio_header *);
+ 	int  (*rw_done)(struct rpc_task *, struct nfs_pgio_header *,
+ 			struct inode *);
+ 	void (*rw_result)(struct rpc_task *, struct nfs_pgio_header *);
+ 	void (*rw_initiate)(struct nfs_pgio_header *, struct rpc_message *,
+ 			    struct rpc_task_setup *, int);
+ };
+ 
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  struct nfs_pageio_descriptor {
  	struct list_head	pg_list;
  	unsigned long		pg_bytes_written;
diff --cc include/linux/nfs_xdr.h
index 381f832b03c6,efeaf7690b51..000000000000
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@@ -1274,10 -1261,9 +1274,13 @@@ struct nfs_pgio_header 
  	struct inode		*inode;
  	struct rpc_cred		*cred;
  	struct list_head	pages;
++<<<<<<< HEAD
 +	struct list_head	rpc_list;
++=======
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	atomic_t		refcnt;
  	struct nfs_page		*req;
 -	struct nfs_writeverf	verf;		/* Used for writes */
 +	struct nfs_writeverf	*verf;
  	struct pnfs_layout_segment *lseg;
  	loff_t			io_start;
  	const struct rpc_call_ops *mds_ops;
@@@ -1291,34 -1278,23 +1294,49 @@@
  	int			error;		/* merge with pnfs_error */
  	unsigned long		good_bytes;	/* boundary of good data */
  	unsigned long		flags;
+ 
+ 	/*
+ 	 * rpc data
+ 	 */
+ 	struct rpc_task		task;
+ 	struct nfs_fattr	fattr;
+ 	struct nfs_writeverf	writeverf;	/* Used for writes */
+ 	struct nfs_pgio_args	args;		/* argument struct */
+ 	struct nfs_pgio_res	res;		/* result struct */
+ 	unsigned long		timestamp;	/* For lease renewal */
+ 	int (*pgio_done_cb)(struct rpc_task *, struct nfs_pgio_header *);
+ 	__u64			mds_offset;	/* Filelayout dense stripe */
+ 	struct nfs_page_array	page_array;
+ 	struct nfs_client	*ds_clp;	/* pNFS data server */
+ 	int			ds_idx;		/* ds index if ds_clp is set */
  };
  
 +struct nfs_read_header {
 +	struct nfs_pgio_header	header;
 +	struct nfs_read_data	rpc_data;
 +};
 +
 +struct nfs_write_data {
 +	struct nfs_pgio_header	*header;
 +	struct list_head	list;
 +	struct rpc_task		task;
 +	struct nfs_fattr	fattr;
 +	struct nfs_writeverf	verf;
 +	struct nfs_pgio_args	args;		/* argument struct */
 +	struct nfs_pgio_res	res;		/* result struct */
 +	unsigned long		timestamp;	/* For lease renewal */
 +	int (*write_done_cb) (struct rpc_task *task, struct nfs_write_data *data);
 +	__u64			mds_offset;	/* Filelayout dense stripe */
 +	struct nfs_page_array	pages;
 +	struct nfs_client	*ds_clp;	/* pNFS data server */
 +};
 +
 +struct nfs_write_header {
 +	struct nfs_pgio_header	header;
 +	struct nfs_write_data	rpc_data;
 +	struct nfs_writeverf	verf;
 +};
 +
  struct nfs_mds_commit_info {
  	atomic_t rpcs_out;
  	unsigned long		ncommit;
@@@ -1448,12 -1424,12 +1466,21 @@@ struct nfs_rpc_ops 
  			     struct nfs_pathconf *);
  	int	(*set_capabilities)(struct nfs_server *, struct nfs_fh *);
  	int	(*decode_dirent)(struct xdr_stream *, struct nfs_entry *, int);
++<<<<<<< HEAD
 +	void	(*read_setup)   (struct nfs_read_data *, struct rpc_message *);
 +	int	(*read_rpc_prepare)(struct rpc_task *, struct nfs_read_data *);
 +	int	(*read_done)  (struct rpc_task *, struct nfs_read_data *);
 +	void	(*write_setup)  (struct nfs_write_data *, struct rpc_message *);
 +	int	(*write_rpc_prepare)(struct rpc_task *, struct nfs_write_data *);
 +	int	(*write_done)  (struct rpc_task *, struct nfs_write_data *);
++=======
+ 	int	(*pgio_rpc_prepare)(struct rpc_task *,
+ 				    struct nfs_pgio_header *);
+ 	void	(*read_setup)(struct nfs_pgio_header *, struct rpc_message *);
+ 	int	(*read_done)(struct rpc_task *, struct nfs_pgio_header *);
+ 	void	(*write_setup)(struct nfs_pgio_header *, struct rpc_message *);
+ 	int	(*write_done)(struct rpc_task *, struct nfs_pgio_header *);
++>>>>>>> d45f60c67848 (nfs: merge nfs_pgio_data into _header)
  	void	(*commit_setup) (struct nfs_commit_data *, struct rpc_message *);
  	void	(*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
  	int	(*commit_done) (struct rpc_task *, struct nfs_commit_data *);
* Unmerged path fs/nfs/blocklayout/blocklayout.c
* Unmerged path fs/nfs/direct.c
* Unmerged path fs/nfs/filelayout/filelayout.c
* Unmerged path fs/nfs/internal.h
* Unmerged path fs/nfs/nfs3proc.c
* Unmerged path fs/nfs/nfs4_fs.h
* Unmerged path fs/nfs/nfs4proc.c
* Unmerged path fs/nfs/nfs4trace.h
* Unmerged path fs/nfs/objlayout/objio_osd.c
* Unmerged path fs/nfs/objlayout/objlayout.c
* Unmerged path fs/nfs/objlayout/objlayout.h
* Unmerged path fs/nfs/pagelist.c
* Unmerged path fs/nfs/pnfs.c
* Unmerged path fs/nfs/pnfs.h
* Unmerged path fs/nfs/proc.c
* Unmerged path fs/nfs/read.c
* Unmerged path fs/nfs/write.c
* Unmerged path include/linux/nfs_page.h
* Unmerged path include/linux/nfs_xdr.h
