xprtrdma: Don't invalidate FRMRs if registration fails

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 539431a437d2e5d6d94016184dfc0aab263c01e1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/539431a4.failed

If FRMR registration fails, it's likely to transition the QP to the
error state. Or, registration may have failed because the QP is
_already_ in ERROR.

Thus calling rpcrdma_deregister_external() in
rpcrdma_create_chunks() is useless in FRMR mode: the LOCAL_INVs just
get flushed.

It is safe to leave existing registrations: when FRMR registration
is tried again, rpcrdma_register_frmr_external() checks if each FRMR
is already/still VALID, and knocks it down first if it is.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Tested-by: Steve Wise <swise@opengridcomputing.com>
	Tested-by: Shirley Ma <shirley.ma@oracle.com>
	Tested-by: Devesh Sharma <devesh.sharma@emulex.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 539431a437d2e5d6d94016184dfc0aab263c01e1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/rpc_rdma.c
diff --cc net/sunrpc/xprtrdma/rpc_rdma.c
index d8cf393c8eb6,6166c985fe24..000000000000
--- a/net/sunrpc/xprtrdma/rpc_rdma.c
+++ b/net/sunrpc/xprtrdma/rpc_rdma.c
@@@ -275,10 -271,34 +275,41 @@@ rpcrdma_create_chunks(struct rpc_rqst *
  	return (unsigned char *)iptr - (unsigned char *)headerp;
  
  out:
++<<<<<<< HEAD
 +	for (pos = 0; nchunks--;)
 +		pos += rpcrdma_deregister_external(
 +				&req->rl_segments[pos], r_xprt);
 +	return 0;
++=======
+ 	if (r_xprt->rx_ia.ri_memreg_strategy != RPCRDMA_FRMR) {
+ 		for (pos = 0; nchunks--;)
+ 			pos += rpcrdma_deregister_external(
+ 					&req->rl_segments[pos], r_xprt);
+ 	}
+ 	return n;
+ }
+ 
+ /*
+  * Marshal chunks. This routine returns the header length
+  * consumed by marshaling.
+  *
+  * Returns positive RPC/RDMA header size, or negative errno.
+  */
+ 
+ ssize_t
+ rpcrdma_marshal_chunks(struct rpc_rqst *rqst, ssize_t result)
+ {
+ 	struct rpcrdma_req *req = rpcr_to_rdmar(rqst);
+ 	struct rpcrdma_msg *headerp = (struct rpcrdma_msg *)req->rl_base;
+ 
+ 	if (req->rl_rtype != rpcrdma_noch)
+ 		result = rpcrdma_create_chunks(rqst, &rqst->rq_snd_buf,
+ 					       headerp, req->rl_rtype);
+ 	else if (req->rl_wtype != rpcrdma_noch)
+ 		result = rpcrdma_create_chunks(rqst, &rqst->rq_rcv_buf,
+ 					       headerp, req->rl_wtype);
+ 	return result;
++>>>>>>> 539431a437d2 (xprtrdma: Don't invalidate FRMRs if registration fails)
  }
  
  /*
* Unmerged path net/sunrpc/xprtrdma/rpc_rdma.c
