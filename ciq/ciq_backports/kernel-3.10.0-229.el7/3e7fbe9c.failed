ceph: introduce ceph_fill_fragtree()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Yan, Zheng <zheng.z.yan@intel.com>
commit 3e7fbe9cebfdaac380419507908e10c499ddd25b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3e7fbe9c.failed

Move the code that update the i_fragtree into a separate function.
Also add simple probabilistic test to decide whether the i_fragtree
should be updated

	Signed-off-by: Yan, Zheng <zheng.z.yan@intel.com>
(cherry picked from commit 3e7fbe9cebfdaac380419507908e10c499ddd25b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/inode.c
diff --cc fs/ceph/inode.c
index f30bedb11ab8,850b26d2e601..000000000000
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@@ -9,6 -9,8 +9,11 @@@
  #include <linux/namei.h>
  #include <linux/writeback.h>
  #include <linux/vmalloc.h>
++<<<<<<< HEAD
++=======
+ #include <linux/posix_acl.h>
+ #include <linux/random.h>
++>>>>>>> 3e7fbe9cebfd (ceph: introduce ceph_fill_fragtree())
  
  #include "super.h"
  #include "mds_client.h"
@@@ -561,17 -658,17 +642,18 @@@ static int fill_inode(struct inode *ino
  		      unsigned long ttl_from, int cap_fmode,
  		      struct ceph_cap_reservation *caps_reservation)
  {
 -	struct ceph_mds_client *mdsc = ceph_inode_to_client(inode)->mdsc;
  	struct ceph_mds_reply_inode *info = iinfo->in;
  	struct ceph_inode_info *ci = ceph_inode(inode);
++<<<<<<< HEAD
 +	int i;
 +	int issued = 0, implemented;
++=======
+ 	int issued = 0, implemented, new_issued;
++>>>>>>> 3e7fbe9cebfd (ceph: introduce ceph_fill_fragtree())
  	struct timespec mtime, atime, ctime;
- 	u32 nsplits;
- 	struct ceph_inode_frag *frag;
- 	struct rb_node *rb_node;
  	struct ceph_buffer *xattr_blob = NULL;
 -	struct ceph_cap *new_cap = NULL;
  	int err = 0;
 -	bool wake = false;
 -	bool queue_trunc = false;
 -	bool new_version = false;
 +	int queue_trunc = 0;
  
  	dout("fill_inode %p ino %llx.%llx v %llu had %llu\n",
  	     inode, ceph_vinop(inode), le64_to_cpu(info->version),
@@@ -722,61 -840,8 +804,27 @@@
  	    !__ceph_dir_is_complete(ci)) {
  		dout(" marking %p complete (empty)\n", inode);
  		__ceph_dir_set_complete(ci, atomic_read(&ci->i_release_count));
 +		ci->i_max_offset = 2;
 +	}
 +no_change:
 +	/* only update max_size on auth cap */
 +	if ((info->cap.flags & CEPH_CAP_FLAG_AUTH) &&
 +	    ci->i_max_size != le64_to_cpu(info->max_size)) {
 +		dout("max_size %lld -> %llu\n", ci->i_max_size,
 +		     le64_to_cpu(info->max_size));
 +		ci->i_max_size = le64_to_cpu(info->max_size);
  	}
  
 +	spin_unlock(&ci->i_ceph_lock);
 +
 +	/* queue truncate if we saw i_size decrease */
 +	if (queue_trunc)
 +		ceph_queue_vmtruncate(inode);
 +
 +	/* populate frag tree */
- 	/* FIXME: move me up, if/when version reflects fragtree changes */
- 	nsplits = le32_to_cpu(info->fragtree.nsplits);
- 	mutex_lock(&ci->i_fragtree_mutex);
- 	rb_node = rb_first(&ci->i_fragtree);
- 	for (i = 0; i < nsplits; i++) {
- 		u32 id = le32_to_cpu(info->fragtree.splits[i].frag);
- 		frag = NULL;
- 		while (rb_node) {
- 			frag = rb_entry(rb_node, struct ceph_inode_frag, node);
- 			if (ceph_frag_compare(frag->frag, id) >= 0) {
- 				if (frag->frag != id)
- 					frag = NULL;
- 				else
- 					rb_node = rb_next(rb_node);
- 				break;
- 			}
- 			rb_node = rb_next(rb_node);
- 			rb_erase(&frag->node, &ci->i_fragtree);
- 			kfree(frag);
- 			frag = NULL;
- 		}
- 		if (!frag) {
- 			frag = __get_or_create_frag(ci, id);
- 			if (IS_ERR(frag))
- 				continue;
- 		}
- 		frag->split_by = le32_to_cpu(info->fragtree.splits[i].by);
- 		dout(" frag %x split by %d\n", frag->frag, frag->split_by);
- 	}
- 	while (rb_node) {
- 		frag = rb_entry(rb_node, struct ceph_inode_frag, node);
- 		rb_node = rb_next(rb_node);
- 		rb_erase(&frag->node, &ci->i_fragtree);
- 		kfree(frag);
- 	}
- 	mutex_unlock(&ci->i_fragtree_mutex);
++	if (S_ISDIR(inode->i_mode))
++		ceph_fill_fragtree(inode, &info->fragtree, dirinfo);
 +
  	/* were we issued a capability? */
  	if (info->cap.caps) {
  		if (ceph_snap(inode) == CEPH_NOSNAP) {
* Unmerged path fs/ceph/inode.c
