ACPI / hotplug / PCI: Rework namespace scanning and trimming routines

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Rework namespace scanning and trimming routines (Myron Stowe) [1114228]
Rebuild_FUZZ: 93.02%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 236e26245a6a437c4afbf33a5ad94cf61d1a7a7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/236e2624.failed

The acpiphp_bus_trim() and acpiphp_bus_add() functions need not
return error codes that are never checked, so redefine them and
simplify them a bit.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 236e26245a6a437c4afbf33a5ad94cf61d1a7a7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index b5069ad47c47,b136eee7a93b..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -585,52 -540,27 +585,63 @@@ static unsigned char acpiphp_max_busnr(
  	return max;
  }
  
- 
  /**
-  * acpiphp_bus_add - add a new bus to acpi subsystem
-  * @func: acpiphp_func of the bridge
+  * acpiphp_bus_trim - Trim device objects in an ACPI namespace subtree.
+  * @handle: ACPI device object handle to start from.
   */
- static int acpiphp_bus_add(struct acpiphp_func *func)
+ static void acpiphp_bus_trim(acpi_handle handle)
  {
++<<<<<<< HEAD
 +	struct acpi_device *device;
 +	int ret_val;
 +
 +	if (!acpi_bus_get_device(func->handle, &device)) {
 +		pr_debug("bus exists... trim\n");
 +		/* this shouldn't be in here, so remove
 +		 * the bus then re-add it...
 +		 */
 +		acpi_bus_trim(device);
 +	}
 +
 +	ret_val = acpi_bus_scan(func->handle);
 +	if (!ret_val)
 +		ret_val = acpi_bus_get_device(func->handle, &device);
 +
 +	if (ret_val)
 +		pr_debug("error adding bus, %x\n", -ret_val);
 +
 +	return ret_val;
- }
++=======
+ 	struct acpi_device *adev = NULL;
  
+ 	acpi_bus_get_device(handle, &adev);
+ 	if (adev)
+ 		acpi_bus_trim(adev);
++>>>>>>> 236e26245a6a (ACPI / hotplug / PCI: Rework namespace scanning and trimming routines)
+ }
  
  /**
-  * acpiphp_bus_trim - trim a bus from acpi subsystem
-  * @handle: handle to acpi namespace
+  * acpiphp_bus_add - Scan ACPI namespace subtree.
+  * @handle: ACPI object handle to start the scan from.
   */
- static int acpiphp_bus_trim(acpi_handle handle)
+ static void acpiphp_bus_add(acpi_handle handle)
  {
++<<<<<<< HEAD
 +	struct acpi_device *device;
 +	int retval;
 +
 +	retval = acpi_bus_get_device(handle, &device);
 +	if (retval) {
 +		pr_debug("acpi_device not found\n");
 +		return retval;
 +	}
 +
 +	acpi_bus_trim(device);
 +	return 0;
++=======
+ 	acpiphp_bus_trim(handle);
+ 	acpi_bus_scan(handle);
++>>>>>>> 236e26245a6a (ACPI / hotplug / PCI: Rework namespace scanning and trimming routines)
  }
  
  static void acpiphp_set_acpi_region(struct acpiphp_slot *slot)
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
