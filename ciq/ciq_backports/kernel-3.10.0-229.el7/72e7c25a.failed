crypto: drbg - Call CTR DRBG DF function only once

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [crypto] drbg: Call CTR DRBG DF function only once (Herbert Xu) [1011562]
Rebuild_FUZZ: 87.91%
commit-author Stephan Mueller <smueller@chronox.de>
commit 72e7c25aa6d73df2951229d2ce0a35065de66d3a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/72e7c25a.failed

The CTR DRBG requires the update function to be called twice when
generating a random number. In both cases, update function must process
the additional information string by using the DF function. As the DF
produces the same result in both cases, we can save one invocation of
the DF function when the first DF function result is reused.

The result of the DF function is stored in the scratchpad storage. The
patch ensures that the scratchpad is not cleared when we want to reuse
the DF result. For achieving this, the CTR DRBG update function must
know by whom and in which scenario it is called. This information is
provided with the reseed parameter to the update function.

	Signed-off-by: Stephan Mueller <smueller@chronox.de>
	Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
(cherry picked from commit 72e7c25aa6d73df2951229d2ce0a35065de66d3a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/drbg.c
diff --cc crypto/drbg.c
index 0c8afc251ae9,dba5ed2f83b6..000000000000
--- a/crypto/drbg.c
+++ b/crypto/drbg.c
@@@ -577,9 -562,23 +577,29 @@@ out
  	return ret;
  }
  
++<<<<<<< HEAD
 +/* update function of CTR DRBG as defined in 10.2.1.2 */
 +static int drbg_ctr_update(struct drbg_state *drbg,
 +			   struct drbg_string *addtl, int reseed)
++=======
+ /*
+  * update function of CTR DRBG as defined in 10.2.1.2
+  *
+  * The reseed variable has an enhanced meaning compared to the update
+  * functions of the other DRBGs as follows:
+  * 0 => initial seed from initialization
+  * 1 => reseed via drbg_seed
+  * 2 => first invocation from drbg_ctr_update when addtl is present. In
+  *      this case, the df_data scratchpad is not deleted so that it is
+  *      available for another calls to prevent calling the DF function
+  *      again.
+  * 3 => second invocation from drbg_ctr_update. When the update function
+  *      was called with addtl, the df_data memory already contains the
+  *      DFed addtl information and we do not need to call DF again.
+  */
+ static int drbg_ctr_update(struct drbg_state *drbg, struct list_head *seed,
+ 			   int reseed)
++>>>>>>> 72e7c25aa6d7 (crypto: drbg - Call CTR DRBG DF function only once)
  {
  	int ret = -EFAULT;
  	/* 10.2.1.2 step 1 */
@@@ -592,12 -591,12 +612,13 @@@
  	unsigned char prefix = DRBG_PREFIX1;
  
  	memset(temp, 0, drbg_statelen(drbg) + drbg_blocklen(drbg));
- 	memset(df_data, 0, drbg_statelen(drbg));
+ 	if (3 > reseed)
+ 		memset(df_data, 0, drbg_statelen(drbg));
  
  	/* 10.2.1.3.2 step 2 and 10.2.1.4.2 step 2 */
 -	if (seed) {
 -		ret = drbg_ctr_df(drbg, df_data, drbg_statelen(drbg), seed);
 +	if (addtl && 0 < addtl->len) {
 +		ret = drbg_ctr_df(drbg, df_data, drbg_statelen(drbg),
 +				  addtl);
  		if (ret)
  			goto out;
  	}
@@@ -657,8 -657,10 +679,15 @@@ static int drbg_ctr_generate(struct drb
  
  	/* 10.2.1.5.2 step 2 */
  	if (addtl && 0 < addtl->len) {
++<<<<<<< HEAD
 +		addtl->next = NULL;
 +		ret = drbg_ctr_update(drbg, addtl, 1);
++=======
+ 		LIST_HEAD(addtllist);
+ 
+ 		list_add_tail(&addtl->list, &addtllist);
+ 		ret = drbg_ctr_update(drbg, &addtllist, 2);
++>>>>>>> 72e7c25aa6d7 (crypto: drbg - Call CTR DRBG DF function only once)
  		if (ret)
  			return 0;
  	}
@@@ -690,15 -692,7 +719,19 @@@
  	}
  
  	/* 10.2.1.5.2 step 6 */
++<<<<<<< HEAD
 +	if (addtl)
 +		addtl->next = NULL;
 +	/*
 +	 * The following call invokes the DF function again which could be
 +	 * optimized. In step 2, the "additional_input" after step 2 is the
 +	 * output of the DF function. If this result would be saved, the DF
 +	 * function would not need to be invoked again at this point.
 +	 */
 +	ret = drbg_ctr_update(drbg, addtl, 1);
++=======
+ 	ret = drbg_ctr_update(drbg, NULL, 3);
++>>>>>>> 72e7c25aa6d7 (crypto: drbg - Call CTR DRBG DF function only once)
  	if (ret)
  		len = ret;
  
* Unmerged path crypto/drbg.c
