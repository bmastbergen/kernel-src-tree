smp: Move __smp_call_function_single() below its safe version

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Frederic Weisbecker <fweisbec@gmail.com>
commit d7877c03f1b62de06f9c00417952f39f56c1ab00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d7877c03.failed

Move this function closer to __smp_call_function_single(). These functions
have very similar behavior and should be displayed in the same block
for clarity.

	Reviewed-by: Jan Kara <jack@suse.cz>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Christoph Hellwig <hch@infradead.org>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Jan Kara <jack@suse.cz>
	Cc: Jens Axboe <axboe@fb.com>
	Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit d7877c03f1b62de06f9c00417952f39f56c1ab00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/smp.c
diff --cc kernel/smp.c
index 74100ac030d3,fa04ab938e52..000000000000
--- a/kernel/smp.c
+++ b/kernel/smp.c
@@@ -308,44 -313,6 +340,47 @@@ call
  EXPORT_SYMBOL_GPL(smp_call_function_any);
  
  /**
++<<<<<<< HEAD
 + * __smp_call_function_single(): Run a function on a specific CPU
 + * @cpu: The CPU to run on.
 + * @data: Pre-allocated and setup data structure
 + * @wait: If true, wait until function has completed on specified CPU.
 + *
 + * Like smp_call_function_single(), but allow caller to pass in a
 + * pre-allocated data structure. Useful for embedding @data inside
 + * other structures, for instance.
 + */
 +void __smp_call_function_single(int cpu, struct call_single_data *csd,
 +				int wait)
 +{
 +	unsigned int this_cpu;
 +	unsigned long flags;
 +
 +	this_cpu = get_cpu();
 +	/*
 +	 * Can deadlock when called with interrupts disabled.
 +	 * We allow cpu's that are not yet online though, as no one else can
 +	 * send smp call function interrupt to this cpu and as such deadlocks
 +	 * can't happen.
 +	 */
 +	WARN_ON_ONCE(cpu_online(smp_processor_id()) && wait && irqs_disabled()
 +		     && !oops_in_progress);
 +
 +	if (cpu == this_cpu) {
 +		local_irq_save(flags);
 +		csd->func(csd->info);
 +		local_irq_restore(flags);
 +	} else {
 +		csd_lock(csd);
 +		generic_exec_single(cpu, csd, wait);
 +	}
 +	put_cpu();
 +}
 +EXPORT_SYMBOL(__smp_call_function_single);
 +
 +/**
++=======
++>>>>>>> d7877c03f1b6 (smp: Move __smp_call_function_single() below its safe version)
   * smp_call_function_many(): Run a function on a set of other CPUs.
   * @mask: The set of cpus to run on (only runs on online subset).
   * @func: The function to run. This must be fast and non-blocking.
* Unmerged path kernel/smp.c
