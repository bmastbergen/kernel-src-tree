vfs: add whiteout support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit 787fb6bc9682ec7c05fb5d9561b57100fbc1cc41
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/787fb6bc.failed

Whiteout isn't actually a new file type, but is represented as a char
device (Linus's idea) with 0/0 device number.

This has several advantages compared to introducing a new whiteout file
type:

 - no userspace API changes (e.g. trivial to make backups of upper layer
   filesystem, without losing whiteouts)

 - no fs image format changes (you can boot an old kernel/fsck without
   whiteout support and things won't break)

 - implementation is trivial

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit 787fb6bc9682ec7c05fb5d9561b57100fbc1cc41)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namei.c
#	include/linux/fs.h
diff --cc fs/namei.c
index 805c1e534c10,d20191c0ebf5..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -4247,16 -4335,34 +4247,34 @@@ exit
  	return error;
  }
  
 -SYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,
 -		int, newdfd, const char __user *, newname)
 -{
 -	return sys_renameat2(olddfd, oldname, newdfd, newname, 0);
 -}
 -
  SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
  {
 -	return sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
 +	return sys_renameat(AT_FDCWD, oldname, AT_FDCWD, newname);
  }
  
++<<<<<<< HEAD
 +int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)
++=======
+ int vfs_whiteout(struct inode *dir, struct dentry *dentry)
+ {
+ 	int error = may_create(dir, dentry);
+ 	if (error)
+ 		return error;
+ 
+ 	if (!dir->i_op->mknod)
+ 		return -EPERM;
+ 
+ 	return dir->i_op->mknod(dir, dentry,
+ 				S_IFCHR | WHITEOUT_MODE, WHITEOUT_DEV);
+ }
+ EXPORT_SYMBOL(vfs_whiteout);
+ 
+ int readlink_copy(char __user *buffer, int buflen, const char *link)
++>>>>>>> 787fb6bc9682 (vfs: add whiteout support)
  {
 -	int len = PTR_ERR(link);
 +	int len;
 +
 +	len = PTR_ERR(link);
  	if (IS_ERR(link))
  		goto out;
  
diff --cc include/linux/fs.h
index e139dc65b562,69118b3cb917..000000000000
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@@ -1469,7 -1404,8 +1476,12 @@@ extern int vfs_symlink(struct inode *, 
  extern int vfs_link(struct dentry *, struct inode *, struct dentry *, struct inode **);
  extern int vfs_rmdir(struct inode *, struct dentry *);
  extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
++<<<<<<< HEAD
 +extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **);
++=======
+ extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **, unsigned int);
+ extern int vfs_whiteout(struct inode *, struct dentry *);
++>>>>>>> 787fb6bc9682 (vfs: add whiteout support)
  
  /*
   * VFS dentry helper functions.
* Unmerged path fs/namei.c
* Unmerged path include/linux/fs.h
