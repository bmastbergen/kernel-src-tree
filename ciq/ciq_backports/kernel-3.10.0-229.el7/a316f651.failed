i40e: Fix an issue when PF reset fails

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Anjali Singhai Jain <anjali.singhai@intel.com>
commit a316f651c73f782ff7c6df623a69b67f8f464856
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a316f651.failed

We shouldn't restart Admin queue subtask if PF reset fails since we do
not have the AQ setup at that point. This patch makes sure we disable AQ
clean subtask when PF reset fails.

This will resolve an occasional kernel panic when PF reset fails for
some reason.

Change-ID: I11a747773362a8c5c0ad7a10cd34be0bda8eb9e8
	Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
	Tested-by: Jim Young <jamesx.m.young@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit a316f651c73f782ff7c6df623a69b67f8f464856)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e.h
diff --cc drivers/net/ethernet/intel/i40e/i40e.h
index c32dbd6fa5db,f1e33f896439..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@@ -137,6 -144,8 +137,11 @@@ enum i40e_state_t 
  	__I40E_PTP_TX_IN_PROGRESS,
  	__I40E_BAD_EEPROM,
  	__I40E_DOWN_REQUESTED,
++<<<<<<< HEAD
++=======
+ 	__I40E_FD_FLUSH_REQUESTED,
+ 	__I40E_RESET_FAILED,
++>>>>>>> a316f651c73f (i40e: Fix an issue when PF reset fails)
  };
  
  enum i40e_interrupt_policy {
* Unmerged path drivers/net/ethernet/intel/i40e/i40e.h
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index 00a8c165a1a4..61296781fa7c 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -5256,6 +5256,10 @@ static void i40e_clean_adminq_subtask(struct i40e_pf *pf)
 	u32 oldval;
 	u32 val;
 
+	/* Do not run clean AQ when PF reset fails */
+	if (test_bit(__I40E_RESET_FAILED, &pf->state))
+		return;
+
 	/* check for error indications */
 	val = rd32(&pf->hw, pf->hw.aq.arq.len);
 	oldval = val;
@@ -5646,19 +5650,20 @@ static void i40e_reset_and_rebuild(struct i40e_pf *pf, bool reinit)
 	ret = i40e_pf_reset(hw);
 	if (ret) {
 		dev_info(&pf->pdev->dev, "PF reset failed, %d\n", ret);
-		goto end_core_reset;
+		set_bit(__I40E_RESET_FAILED, &pf->state);
+		goto clear_recovery;
 	}
 	pf->pfr_count++;
 
 	if (test_bit(__I40E_DOWN, &pf->state))
-		goto end_core_reset;
+		goto clear_recovery;
 	dev_dbg(&pf->pdev->dev, "Rebuilding internal switch\n");
 
 	/* rebuild the basics for the AdminQ, HMC, and initial HW switch */
 	ret = i40e_init_adminq(&pf->hw);
 	if (ret) {
 		dev_info(&pf->pdev->dev, "Rebuild AdminQ failed, %d\n", ret);
-		goto end_core_reset;
+		goto clear_recovery;
 	}
 
 	/* re-verify the eeprom if we just had an EMP reset */
@@ -5775,6 +5780,8 @@ static void i40e_reset_and_rebuild(struct i40e_pf *pf, bool reinit)
 	i40e_aq_send_driver_version(&pf->hw, &dv, NULL);
 
 end_core_reset:
+	clear_bit(__I40E_RESET_FAILED, &pf->state);
+clear_recovery:
 	clear_bit(__I40E_RESET_RECOVERY_PENDING, &pf->state);
 }
 
