ACPI / dock: Use callback pointers from devices' ACPI hotplug contexts

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] dock: Use callback pointers from devices' ACPI hotplug contexts (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 94.74%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit edf5bf34d40804fbef32f240a79b74ffc69a658b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/edf5bf34.failed

Instead of requiring a set of special dock operations to be registered
via register_hotplug_dock_device() for each ACPI dock device, it is
much more straightforward to use callback pointers from the devices'
hotplug contexts if available.

For this reason, modify dock_hotplug_event() to use callback pointers
from the hotplug contexts of ACPI devices and fall back to using the
special dock operarions only if those callbacks are missing.  Also
make the ACPI-based PCI hotplug (ACPIPHP) subsystem set the .fixup
callback pointer in the hotplug contexts of devices handled by it to
a new function, acpiphp_post_dock_fixup(), so that the dock station
driver can use the callbacks from those contexts instead of special
dock operations registered via register_hotplug_dock_device().

Along with the above changes drop the ACPIPHP's dock operations that
are not necessary any more.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit edf5bf34d40804fbef32f240a79b74ffc69a658b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,15865aeebbb5..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -58,25 -59,67 +58,77 @@@
  static LIST_HEAD(bridge_list);
  static DEFINE_MUTEX(bridge_mutex);
  
++<<<<<<< HEAD
 +static void handle_hotplug_event_bridge (acpi_handle, u32, void *);
++=======
+ static int acpiphp_hotplug_event(struct acpi_device *adev, u32 type);
+ static void acpiphp_post_dock_fixup(struct acpi_device *adev);
++>>>>>>> edf5bf34d408 (ACPI / dock: Use callback pointers from devices' ACPI hotplug contexts)
  static void acpiphp_sanitize_bus(struct pci_bus *bus);
  static void acpiphp_set_hpp_values(struct pci_bus *bus);
 -static void hotplug_event(u32 type, struct acpiphp_context *context);
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context);
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type, void *context);
  static void free_bridge(struct kref *kref);
  
 -/**
 - * acpiphp_init_context - Create hotplug context and grab a reference to it.
 - * @adev: ACPI device object to create the context for.
 - *
 - * Call under acpi_hp_context_lock.
 - */
 -static struct acpiphp_context *acpiphp_init_context(struct acpi_device *adev)
 +/* callback routine to check for the existence of a pci dock device */
 +static acpi_status
 +is_pci_dock_device(acpi_handle handle, u32 lvl, void *context, void **rv)
  {
 -	struct acpiphp_context *context;
 +	int *count = (int *)context;
  
++<<<<<<< HEAD
 +	if (is_dock_device(handle)) {
 +		(*count)++;
 +		return AE_CTRL_TERMINATE;
 +	} else {
 +		return AE_OK;
 +	}
++=======
+ 	context = kzalloc(sizeof(*context), GFP_KERNEL);
+ 	if (!context)
+ 		return NULL;
+ 
+ 	context->refcount = 1;
+ 	acpi_set_hp_context(adev, &context->hp, acpiphp_hotplug_event,
+ 			    acpiphp_post_dock_fixup);
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_get_context - Get hotplug context and grab a reference to it.
+  * @adev: ACPI device object to get the context for.
+  *
+  * Call under acpi_hp_context_lock.
+  */
+ static struct acpiphp_context *acpiphp_get_context(struct acpi_device *adev)
+ {
+ 	struct acpiphp_context *context;
+ 
+ 	if (!adev->hp)
+ 		return NULL;
+ 
+ 	context = to_acpiphp_context(adev->hp);
+ 	context->refcount++;
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_put_context - Drop a reference to ACPI hotplug context.
+  * @context: ACPI hotplug context to drop a reference to.
+  *
+  * The context object is removed if there are no more references to it.
+  *
+  * Call under acpi_hp_context_lock.
+  */
+ static void acpiphp_put_context(struct acpiphp_context *context)
+ {
+ 	if (--context->refcount)
+ 		return;
+ 
+ 	WARN_ON(context->bridge);
+ 	context->hp.self->hp = NULL;
+ 	kfree(context);
++>>>>>>> edf5bf34d408 (ACPI / dock: Use callback pointers from devices' ACPI hotplug contexts)
  }
  
  static inline void get_bridge(struct acpiphp_bridge *bridge)
@@@ -89,8 -132,30 +141,29 @@@ static inline void put_bridge(struct ac
  	kref_put(&bridge->ref, free_bridge);
  }
  
+ static struct acpiphp_context *acpiphp_grab_context(struct acpi_device *adev)
+ {
+ 	struct acpiphp_context *context;
+ 
+ 	acpi_lock_hp_context();
+ 	context = acpiphp_get_context(adev);
+ 	if (!context || context->func.parent->is_going_away) {
+ 		acpi_unlock_hp_context();
+ 		return NULL;
+ 	}
+ 	get_bridge(context->func.parent);
+ 	acpiphp_put_context(context);
+ 	acpi_unlock_hp_context();
+ 	return context;
+ }
+ 
+ static void acpiphp_let_context_go(struct acpiphp_context *context)
+ {
+ 	put_bridge(context->func.parent);
+ }
+ 
  static void free_bridge(struct kref *kref)
  {
 -	struct acpiphp_context *context;
  	struct acpiphp_bridge *bridge;
  	struct acpiphp_slot *slot, *next;
  	struct acpiphp_func *func, *tmp;
@@@ -110,24 -183,28 +183,38 @@@
  	put_device(&bridge->pci_bus->dev);
  	pci_dev_put(bridge->pci_dev);
  	kfree(bridge);
 -
 -	acpi_unlock_hp_context();
  }
  
- /*
-  * the _DCK method can do funny things... and sometimes not
-  * hah-hah funny.
+ /**
+  * acpiphp_post_dock_fixup - Post-dock fixups for PCI devices.
+  * @adev: ACPI device object corresponding to a PCI device.
   *
-  * TBD - figure out a way to only call fixups for
-  * systems that require them.
+  * TBD - figure out a way to only call fixups for systems that require them.
   */
++<<<<<<< HEAD
 +static int post_dock_fixups(struct notifier_block *nb, unsigned long val,
 +	void *v)
 +{
 +	struct acpiphp_func *func = container_of(nb, struct acpiphp_func, nb);
 +	struct pci_bus *bus = func->slot->bridge->pci_bus;
 +	u32 buses;
 +
 +	if (!bus->self)
 +		return  NOTIFY_OK;
++=======
+ static void acpiphp_post_dock_fixup(struct acpi_device *adev)
+ {
+ 	struct acpiphp_context *context = acpiphp_grab_context(adev);
+ 	struct pci_bus *bus;
+ 	u32 buses;
+ 
+ 	if (!context)
+ 		return;
++>>>>>>> edf5bf34d408 (ACPI / dock: Use callback pointers from devices' ACPI hotplug contexts)
+ 
+ 	bus = context->func.slot->bus;
+ 	if (!bus->self)
+ 		goto out;
  
  	/* fixup bad _DCK function that rewrites
  	 * secondary bridge on slot
@@@ -143,14 -218,11 +228,22 @@@
  			| ((unsigned int)(bus->busn_res.end) << 16);
  		pci_write_config_dword(bus->self, PCI_PRIMARY_BUS, buses);
  	}
++<<<<<<< HEAD
 +	return NOTIFY_OK;
 +}
 +
 +
 +static const struct acpi_dock_ops acpiphp_dock_ops = {
 +	.handler = hotplug_event_func,
 +};
 +
++=======
+ 
+  out:
+ 	acpiphp_let_context_go(context);
+ }
+ 
++>>>>>>> edf5bf34d408 (ACPI / dock: Use callback pointers from devices' ACPI hotplug contexts)
  /* Check whether the PCI device is managed by native PCIe hotplug driver */
  static bool device_is_managed_by_native_pciehp(struct pci_dev *pdev)
  {
@@@ -180,116 -252,108 +273,151 @@@
  	return true;
  }
  
++<<<<<<< HEAD
 +static void acpiphp_dock_init(void *data)
 +{
 +	struct acpiphp_func *func = data;
 +
 +	get_bridge(func->slot->bridge);
 +}
 +
 +static void acpiphp_dock_release(void *data)
 +{
 +	struct acpiphp_func *func = data;
 +
 +	put_bridge(func->slot->bridge);
 +}
 +
 +/* callback routine to register each ACPI PCI slot object */
 +static acpi_status
 +register_slot(acpi_handle handle, u32 lvl, void *context, void **rv)
++=======
+ /**
+  * acpiphp_add_context - Add ACPIPHP context to an ACPI device object.
+  * @handle: ACPI handle of the object to add a context to.
+  * @lvl: Not used.
+  * @data: The object's parent ACPIPHP bridge.
+  * @rv: Not used.
+  */
+ static acpi_status acpiphp_add_context(acpi_handle handle, u32 lvl, void *data,
+ 				       void **rv)
++>>>>>>> edf5bf34d408 (ACPI / dock: Use callback pointers from devices' ACPI hotplug contexts)
  {
 -	struct acpiphp_bridge *bridge = data;
 -	struct acpiphp_context *context;
 -	struct acpi_device *adev;
 +	struct acpiphp_bridge *bridge = (struct acpiphp_bridge *)context;
  	struct acpiphp_slot *slot;
  	struct acpiphp_func *newfunc;
 +	acpi_handle tmp;
  	acpi_status status = AE_OK;
 -	unsigned long long adr;
 -	int device, function;
 +	unsigned long long adr, sun;
 +	int device, function, retval, found = 0;
  	struct pci_bus *pbus = bridge->pci_bus;
 -	struct pci_dev *pdev = bridge->pci_dev;
 +	struct pci_dev *pdev;
  	u32 val;
  
 +	if (!acpi_pci_check_ejectable(pbus, handle) && !is_dock_device(handle))
 +		return AE_OK;
 +
  	status = acpi_evaluate_integer(handle, "_ADR", NULL, &adr);
  	if (ACPI_FAILURE(status)) {
 -		if (status != AE_NOT_FOUND)
 -			acpi_handle_warn(handle,
 -				"can't evaluate _ADR (%#x)\n", status);
 +		pr_warn("can't evaluate _ADR (%#x)\n", status);
  		return AE_OK;
  	}
 -	if (acpi_bus_get_device(handle, &adev))
 -		return AE_OK;
  
  	device = (adr >> 16) & 0xffff;
  	function = adr & 0xffff;
  
++<<<<<<< HEAD
 +	pdev = bridge->pci_dev;
 +	if (pdev && device_is_managed_by_native_pciehp(pdev))
 +		return AE_OK;
 +
 +	newfunc = kzalloc(sizeof(struct acpiphp_func), GFP_KERNEL);
 +	if (!newfunc)
 +		return AE_NO_MEMORY;
 +
 +	newfunc->handle = handle;
 +	newfunc->function = function;
 +
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
++=======
+ 	acpi_lock_hp_context();
+ 	context = acpiphp_init_context(adev);
+ 	if (!context) {
+ 		acpi_unlock_hp_context();
+ 		acpi_handle_err(handle, "No hotplug context\n");
+ 		return AE_NOT_EXIST;
+ 	}
+ 	newfunc = &context->func;
+ 	newfunc->function = function;
+ 	newfunc->parent = bridge;
+ 	acpi_unlock_hp_context();
+ 
+ 	/*
+ 	 * If this is a dock device, its _EJ0 should be executed by the dock
+ 	 * notify handler after calling _DCK.
+ 	 */
+ 	if (!is_dock_device(adev) && acpi_has_method(handle, "_EJ0"))
++>>>>>>> edf5bf34d408 (ACPI / dock: Use callback pointers from devices' ACPI hotplug contexts)
  		newfunc->flags = FUNC_HAS_EJ0;
  
 -	if (acpi_has_method(handle, "_STA"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_STA", &tmp)))
  		newfunc->flags |= FUNC_HAS_STA;
  
 -	/* search for objects that share the same slot */
 -	list_for_each_entry(slot, &bridge->slots, node)
 -		if (slot->device == device)
 -			goto slot_found;
++<<<<<<< HEAD
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS0", &tmp)))
 +		newfunc->flags |= FUNC_HAS_PS0;
  
 -	slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 -	if (!slot) {
 -		acpi_lock_hp_context();
 -		acpiphp_put_context(context);
 -		acpi_unlock_hp_context();
 -		return AE_NO_MEMORY;
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS3", &tmp)))
 +		newfunc->flags |= FUNC_HAS_PS3;
 +
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_DCK", &tmp)))
 +		newfunc->flags |= FUNC_HAS_DCK;
 +
 +	status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 +	if (ACPI_FAILURE(status)) {
 +		/*
 +		 * use the count of the number of slots we've found
 +		 * for the number of the slot
 +		 */
 +		sun = bridge->nr_slots+1;
  	}
  
 -	slot->bus = bridge->pci_bus;
 -	slot->device = device;
 -	INIT_LIST_HEAD(&slot->funcs);
++=======
++>>>>>>> edf5bf34d408 (ACPI / dock: Use callback pointers from devices' ACPI hotplug contexts)
 +	/* search for objects that share the same slot */
 +	list_for_each_entry(slot, &bridge->slots, node)
 +		if (slot->device == device) {
 +			if (slot->sun != sun)
 +				pr_warn("sibling found, but _SUN doesn't match!\n");
 +			found = 1;
 +			break;
 +		}
  
 -	list_add_tail(&slot->node, &bridge->slots);
 +	if (!found) {
 +		slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 +		if (!slot) {
 +			kfree(newfunc);
 +			return AE_NO_MEMORY;
 +		}
  
 -	/*
 -	 * Expose slots to user space for functions that have _EJ0 or _RMV or
 -	 * are located in dock stations.  Do not expose them for devices handled
 -	 * by the native PCIe hotplug (PCIeHP), becuase that code is supposed to
 -	 * expose slots to user space in those cases.
 -	 */
 -	if ((acpi_pci_check_ejectable(pbus, handle) || is_dock_device(adev))
 -	    && !(pdev && device_is_managed_by_native_pciehp(pdev))) {
 -		unsigned long long sun;
 -		int retval;
 +		slot->bridge = bridge;
 +		slot->device = device;
 +		slot->sun = sun;
 +		INIT_LIST_HEAD(&slot->funcs);
 +		mutex_init(&slot->crit_sect);
  
 +		mutex_lock(&bridge_mutex);
 +		list_add_tail(&slot->node, &bridge->slots);
 +		mutex_unlock(&bridge_mutex);
  		bridge->nr_slots++;
 -		status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 -		if (ACPI_FAILURE(status))
 -			sun = bridge->nr_slots;
  
  		pr_debug("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",
 -		    sun, pci_domain_nr(pbus), pbus->number, device);
 -
 -		retval = acpiphp_register_hotplug_slot(slot, sun);
 +		    slot->sun, pci_domain_nr(pbus), pbus->number, device);
 +		retval = acpiphp_register_hotplug_slot(slot);
  		if (retval) {
 -			slot->slot = NULL;
 -			bridge->nr_slots--;
  			if (retval == -EBUSY)
  				pr_warn("Slot %llu already registered by another "
 -					"hotplug driver\n", sun);
 +					"hotplug driver\n", slot->sun);
  			else
  				pr_warn("acpiphp_register_hotplug_slot failed "
  					"(err code = 0x%x)\n", retval);
@@@ -304,50 -367,8 +432,53 @@@
  
  	if (pci_bus_read_dev_vendor_id(pbus, PCI_DEVFN(device, function),
  				       &val, 60*1000))
 -		slot->flags |= SLOT_ENABLED;
 +		slot->flags |= (SLOT_ENABLED | SLOT_POWEREDON);
  
++<<<<<<< HEAD
 +	if (is_dock_device(handle)) {
 +		/* we don't want to call this device's _EJ0
 +		 * because we want the dock notify handler
 +		 * to call it after it calls _DCK
 +		 */
 +		newfunc->flags &= ~FUNC_HAS_EJ0;
 +		if (register_hotplug_dock_device(handle,
 +			&acpiphp_dock_ops, newfunc,
 +			acpiphp_dock_init, acpiphp_dock_release))
 +			pr_debug("failed to register dock device\n");
 +
 +		/* we need to be notified when dock events happen
 +		 * outside of the hotplug operation, since we may
 +		 * need to do fixups before we can hotplug.
 +		 */
 +		newfunc->nb.notifier_call = post_dock_fixups;
 +		if (register_dock_notifier(&newfunc->nb))
 +			pr_debug("failed to register a dock notifier");
 +	}
 +
 +	/* install notify handler */
 +	if (!(newfunc->flags & FUNC_HAS_DCK)) {
 +		status = acpi_install_notify_handler(handle,
 +					     ACPI_SYSTEM_NOTIFY,
 +					     handle_hotplug_event_func,
 +					     newfunc);
 +
 +		if (ACPI_FAILURE(status))
 +			pr_err("failed to register interrupt notify handler\n");
 +	} else
 +		status = AE_OK;
 +
 +	return status;
 +
 + err_exit:
 +	bridge->nr_slots--;
 +	mutex_lock(&bridge_mutex);
 +	list_del(&slot->node);
 +	mutex_unlock(&bridge_mutex);
 +	kfree(slot);
 +	kfree(newfunc);
 +
++=======
++>>>>>>> edf5bf34d408 (ACPI / dock: Use callback pointers from devices' ACPI hotplug contexts)
  	return AE_OK;
  }
  
@@@ -473,19 -397,16 +604,28 @@@ static void cleanup_bridge(struct acpip
  
  	list_for_each_entry(slot, &bridge->slots, node) {
  		list_for_each_entry(func, &slot->funcs, sibling) {
++<<<<<<< HEAD
 +			if (is_dock_device(func->handle)) {
 +				unregister_hotplug_dock_device(func->handle);
 +				unregister_dock_notifier(&func->nb);
 +			}
 +			if (!(func->flags & FUNC_HAS_DCK)) {
 +				status = acpi_remove_notify_handler(func->handle,
 +						ACPI_SYSTEM_NOTIFY,
 +						handle_hotplug_event_func);
 +				if (ACPI_FAILURE(status))
 +					pr_err("failed to remove notify handler\n");
 +			}
++=======
+ 			struct acpi_device *adev = func_to_acpi_device(func);
+ 
+ 			acpi_lock_hp_context();
+ 			adev->hp->event = NULL;
+ 			adev->hp->fixup = NULL;
+ 			acpi_unlock_hp_context();
++>>>>>>> edf5bf34d408 (ACPI / dock: Use callback pointers from devices' ACPI hotplug contexts)
  		}
 -		slot->flags |= SLOT_IS_GOING_AWAY;
 -		if (slot->slot)
 -			acpiphp_unregister_hotplug_slot(slot);
 +		acpiphp_unregister_hotplug_slot(slot);
  	}
  
  	mutex_lock(&bridge_mutex);
@@@ -1034,135 -821,29 +1174,145 @@@ static void _handle_hotplug_event_bridg
  		}
  		break;
  
 +	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
 +		printk(KERN_ERR "Device %s cannot be configured due"
 +				" to a frequency mismatch\n", objname);
 +		break;
 +
 +	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
 +		printk(KERN_ERR "Device %s cannot be configured due"
 +				" to a bus mode mismatch\n", objname);
 +		break;
 +
 +	case ACPI_NOTIFY_POWER_FAULT:
 +		printk(KERN_ERR "Device %s has suffered a power fault\n",
 +				objname);
 +		break;
 +
 +	default:
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
 +		break;
 +	}
 +
 +	acpi_scan_lock_release();
 +	kfree(hp_work); /* allocated in handle_hotplug_event_bridge */
 +	put_bridge(bridge);
 +}
 +
 +/**
 + * handle_hotplug_event_bridge - handle ACPI event on bridges
 + * @handle: Notify()'ed acpi_handle
 + * @type: Notify code
 + * @context: pointer to acpiphp_bridge structure
 + *
 + * Handles ACPI event notification on {host,p2p} bridges.
 + */
 +static void handle_hotplug_event_bridge(acpi_handle handle, u32 type,
 +					void *context)
 +{
 +	struct acpiphp_bridge *bridge = context;
 +
++<<<<<<< HEAD
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_bridge);
 +}
 +
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context)
 +{
 +	struct acpiphp_func *func = context;
 +	char objname[64];
 +	struct acpi_buffer buffer = { .length = sizeof(objname),
 +				      .pointer = objname };
 +
 +	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 +
 +	switch (type) {
 +	case ACPI_NOTIFY_BUS_CHECK:
 +		/* bus re-enumerate */
 +		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
 +		acpiphp_enable_slot(func->slot);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_CHECK:
 +		/* device check : re-enumerate from parent bus */
 +		pr_debug("%s: Device check notify on %s\n", __func__, objname);
 +		acpiphp_check_bridge(func->slot->bridge);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_WAKE:
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
 +		break;
 +
  	case ACPI_NOTIFY_EJECT_REQUEST:
  		/* request device eject */
 -		acpi_handle_debug(handle, "Eject request in %s()\n", __func__);
 -		acpiphp_disable_and_eject_slot(slot);
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if (!(acpiphp_disable_slot(func->slot)))
 +			acpiphp_eject_slot(func->slot);
 +		break;
 +
 +	default:
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
  		break;
  	}
 +}
  
 -	pci_unlock_rescan_remove();
 -	if (bridge)
 -		put_bridge(bridge);
 +static void _handle_hotplug_event_func(struct work_struct *work)
 +{
 +	struct acpi_hp_work *hp_work;
 +	struct acpiphp_func *func;
 +
 +	hp_work = container_of(work, struct acpi_hp_work, work);
 +	func = hp_work->context;
 +	acpi_scan_lock_acquire();
 +
 +	hotplug_event_func(hp_work->handle, hp_work->type, func);
 +
 +	acpi_scan_lock_release();
 +	kfree(hp_work); /* allocated in handle_hotplug_event_func */
 +	put_bridge(func->slot->bridge);
  }
  
 -static int acpiphp_hotplug_event(struct acpi_device *adev, u32 type)
 +/**
 + * handle_hotplug_event_func - handle ACPI event on functions (i.e. slots)
 + * @handle: Notify()'ed acpi_handle
 + * @type: Notify code
 + * @context: pointer to acpiphp_func structure
 + *
 + * Handles ACPI event notification on slots.
 + */
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type,
 +				      void *context)
  {
 -	struct acpiphp_context *context;
 +	struct acpiphp_func *func = context;
  
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(func->slot->bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_func);
++=======
+ 	context = acpiphp_grab_context(adev);
+ 	if (!context)
+ 		return -ENODATA;
+ 
+ 	hotplug_event(type, context);
+ 	acpiphp_let_context_go(context);
+ 	return 0;
++>>>>>>> edf5bf34d408 (ACPI / dock: Use callback pointers from devices' ACPI hotplug contexts)
  }
  
  /**
diff --git a/drivers/acpi/dock.c b/drivers/acpi/dock.c
index c3bab54256c4..8f117842a587 100644
--- a/drivers/acpi/dock.c
+++ b/drivers/acpi/dock.c
@@ -181,9 +181,38 @@ static void dock_release_hotplug(struct dock_dependent_device *dd)
 static void dock_hotplug_event(struct dock_dependent_device *dd, u32 event,
 			       bool uevent)
 {
+	struct acpi_device *adev = dd->adev;
 	acpi_notify_handler cb = NULL;
 	bool run = false;
 
+	acpi_lock_hp_context();
+
+	if (!adev->hp)
+		goto no_context;
+
+	if (cb_type == DOCK_CALL_FIXUP) {
+		void (*fixup)(struct acpi_device *);
+
+		fixup = adev->hp->fixup;
+		if (fixup) {
+			acpi_unlock_hp_context();
+			fixup(adev);
+			return;
+		}
+	} else {
+		int (*notify)(struct acpi_device *, u32);
+
+		notify = adev->hp->event;
+		if (notify) {
+			acpi_unlock_hp_context();
+			notify(adev, event);
+			return;
+		}
+	}
+
+ no_context:
+	acpi_unlock_hp_context();
+
 	mutex_lock(&hotplug_lock);
 
 	if (dd->hp_context) {
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
