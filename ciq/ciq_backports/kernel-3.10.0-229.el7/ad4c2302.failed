cpufreq: stats: Refactor common code into __cpufreq_stats_create_table()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] stats: Refactor common code into __cpufreq_stats_create_table() (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 93.33%
commit-author Saravana Kannan <skannan@codeaurora.org>
commit ad4c2302c20a6906eb2f10defdb0e982bab5eb0b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/ad4c2302.failed

cpufreq_frequency_get_table() is called from all callers of
__cpufreq_stats_create_table(). So, move it inside.

	Suggested-by: Viresh Kumar <viresh.kumar@linaro.org>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Saravana Kannan <skannan@codeaurora.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit ad4c2302c20a6906eb2f10defdb0e982bab5eb0b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq_stats.c
diff --cc drivers/cpufreq/cpufreq_stats.c
index 04c5a81b41f0,eb214d83ad6b..000000000000
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@@ -188,17 -180,21 +188,27 @@@ put_ref
  	cpufreq_cpu_put(policy);
  }
  
++<<<<<<< HEAD
 +static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 +		struct cpufreq_frequency_table *table)
++=======
+ static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
++>>>>>>> ad4c2302c20a (cpufreq: stats: Refactor common code into __cpufreq_stats_create_table())
  {
  	unsigned int i, j, count = 0, ret = 0;
  	struct cpufreq_stats *stat;
 +	struct cpufreq_policy *data;
  	unsigned int alloc_size;
  	unsigned int cpu = policy->cpu;
+ 	struct cpufreq_frequency_table *table;
+ 
+ 	table = cpufreq_frequency_get_table(cpu);
+ 	if (unlikely(!table))
+ 		return 0;
+ 
  	if (per_cpu(cpufreq_stats_table, cpu))
  		return -EBUSY;
 -	stat = kzalloc(sizeof(*stat), GFP_KERNEL);
 +	stat = kzalloc(sizeof(struct cpufreq_stats), GFP_KERNEL);
  	if ((stat) == NULL)
  		return -ENOMEM;
  
@@@ -263,6 -250,23 +273,26 @@@ error_get_fail
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void cpufreq_stats_create_table(unsigned int cpu)
+ {
+ 	struct cpufreq_policy *policy;
+ 
+ 	/*
+ 	 * "likely(!policy)" because normally cpufreq_stats will be registered
+ 	 * before cpufreq driver
+ 	 */
+ 	policy = cpufreq_cpu_get(cpu);
+ 	if (likely(!policy))
+ 		return;
+ 
+ 	__cpufreq_stats_create_table(policy);
+ 
+ 	cpufreq_cpu_put(policy);
+ }
+ 
++>>>>>>> ad4c2302c20a (cpufreq: stats: Refactor common code into __cpufreq_stats_create_table())
  static void cpufreq_stats_update_policy_cpu(struct cpufreq_policy *policy)
  {
  	struct cpufreq_stats *stat = per_cpu(cpufreq_stats_table,
@@@ -279,25 -283,20 +309,32 @@@
  static int cpufreq_stat_notifier_policy(struct notifier_block *nb,
  		unsigned long val, void *data)
  {
 -	int ret = 0;
 +	int ret;
  	struct cpufreq_policy *policy = data;
- 	struct cpufreq_frequency_table *table;
- 	unsigned int cpu = policy->cpu;
  
  	if (val == CPUFREQ_UPDATE_POLICY_CPU) {
  		cpufreq_stats_update_policy_cpu(policy);
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	if (val != CPUFREQ_NOTIFY)
 +		return 0;
 +	table = cpufreq_frequency_get_table(cpu);
 +	if (!table)
 +		return 0;
 +	ret = cpufreq_stats_create_table(policy, table);
 +	if (ret)
 +		return ret;
 +	return 0;
++=======
+ 	if (val == CPUFREQ_CREATE_POLICY)
+ 		ret = __cpufreq_stats_create_table(policy);
+ 	else if (val == CPUFREQ_REMOVE_POLICY)
+ 		__cpufreq_stats_free_table(policy);
+ 
+ 	return ret;
++>>>>>>> ad4c2302c20a (cpufreq: stats: Refactor common code into __cpufreq_stats_create_table())
  }
  
  static int cpufreq_stat_notifier_trans(struct notifier_block *nb,
* Unmerged path drivers/cpufreq/cpufreq_stats.c
