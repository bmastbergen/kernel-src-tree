ALSA: hda - Rename reg access ops in hda_controller_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [alsa] hda: Rename reg access ops in hda_controller_ops (Jaroslav Kysela) [1112200]
Rebuild_FUZZ: 91.26%
commit-author Dylan Reid <dgreid@chromium.org>
commit 778bde6f59e062a44df5e82646db71c9ef84c18a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/778bde6f.failed

Using readl, writel, etc. resulted in some architectures, such as
s390, expanding the member names into zpci_writel.  Obviously not the
intended result.

Fixes s390 build breakage introduced by "4083081 - ALSA: hda - Allow
different ops to read/write registers"

	Signed-off-by: Dylan Reid <dgreid@chromium.org>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 778bde6f59e062a44df5e82646db71c9ef84c18a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_intel.c
#	sound/pci/hda/hda_priv.h
diff --cc sound/pci/hda/hda_intel.c
index f803cf3b4c64,149c00b00320..000000000000
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@@ -3480,13 -1461,95 +3480,29 @@@ static u8 pci_azx_readb(u8 *addr
  	return readb(addr);
  }
  
 -static int disable_msi_reset_irq(struct azx *chip)
 -{
 -	int err;
 -
 -	free_irq(chip->irq, chip);
 -	chip->irq = -1;
 -	pci_disable_msi(chip->pci);
 -	chip->msi = 0;
 -	err = azx_acquire_irq(chip, 1);
 -	if (err < 0)
 -		return err;
 -
 -	return 0;
 -}
 -
 -/* DMA page allocation helpers.  */
 -static int dma_alloc_pages(struct azx *chip,
 -			   int type,
 -			   size_t size,
 -			   struct snd_dma_buffer *buf)
 -{
 -	int err;
 -
 -	err = snd_dma_alloc_pages(type,
 -				  chip->card->dev,
 -				  size, buf);
 -	if (err < 0)
 -		return err;
 -	mark_pages_wc(chip, buf, true);
 -	return 0;
 -}
 -
 -static void dma_free_pages(struct azx *chip, struct snd_dma_buffer *buf)
 -{
 -	mark_pages_wc(chip, buf, false);
 -	snd_dma_free_pages(buf);
 -}
 -
 -static int substream_alloc_pages(struct azx *chip,
 -				 struct snd_pcm_substream *substream,
 -				 size_t size)
 -{
 -	struct azx_dev *azx_dev = get_azx_dev(substream);
 -	int ret;
 -
 -	mark_runtime_wc(chip, azx_dev, substream, false);
 -	azx_dev->bufsize = 0;
 -	azx_dev->period_bytes = 0;
 -	azx_dev->format_val = 0;
 -	ret = snd_pcm_lib_malloc_pages(substream, size);
 -	if (ret < 0)
 -		return ret;
 -	mark_runtime_wc(chip, azx_dev, substream, true);
 -	return 0;
 -}
 -
 -static int substream_free_pages(struct azx *chip,
 -				struct snd_pcm_substream *substream)
 -{
 -	struct azx_dev *azx_dev = get_azx_dev(substream);
 -	mark_runtime_wc(chip, azx_dev, substream, false);
 -	return snd_pcm_lib_free_pages(substream);
 -}
 -
 -static void pcm_mmap_prepare(struct snd_pcm_substream *substream,
 -			     struct vm_area_struct *area)
 -{
 -#ifdef CONFIG_X86
 -	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 -	struct azx *chip = apcm->chip;
 -	if (!azx_snoop(chip))
 -		area->vm_page_prot = pgprot_writecombine(area->vm_page_prot);
 -#endif
 -}
 -
  static const struct hda_controller_ops pci_hda_ops = {
++<<<<<<< HEAD
 +	.writel = pci_azx_writel,
 +	.readl = pci_azx_readl,
 +	.writew = pci_azx_writew,
 +	.readw = pci_azx_readw,
 +	.writeb = pci_azx_writeb,
 +	.readb = pci_azx_readb,
++=======
+ 	.reg_writel = pci_azx_writel,
+ 	.reg_readl = pci_azx_readl,
+ 	.reg_writew = pci_azx_writew,
+ 	.reg_readw = pci_azx_readw,
+ 	.reg_writeb = pci_azx_writeb,
+ 	.reg_readb = pci_azx_readb,
+ 	.disable_msi_reset_irq = disable_msi_reset_irq,
+ 	.dma_alloc_pages = dma_alloc_pages,
+ 	.dma_free_pages = dma_free_pages,
+ 	.substream_alloc_pages = substream_alloc_pages,
+ 	.substream_free_pages = substream_free_pages,
+ 	.pcm_mmap_prepare = pcm_mmap_prepare,
+ 	.position_check = azx_position_check,
++>>>>>>> 778bde6f59e0 (ALSA: hda - Rename reg access ops in hda_controller_ops)
  };
  
  static int azx_probe(struct pci_dev *pci,
diff --cc sound/pci/hda/hda_priv.h
index c3b3f3090142,198fa825fa0e..000000000000
--- a/sound/pci/hda/hda_priv.h
+++ b/sound/pci/hda/hda_priv.h
@@@ -288,12 -288,31 +288,38 @@@ struct azx_rb 
  /* Functions to read/write to hda registers. */
  struct hda_controller_ops {
  	/* Register Access */
++<<<<<<< HEAD
 +	void (*writel)(u32 value, u32 *addr);
 +	u32 (*readl)(u32 *addr);
 +	void (*writew)(u16 value, u16 *addr);
 +	u16 (*readw)(u16 *addr);
 +	void (*writeb)(u8 value, u8 *addr);
 +	u8 (*readb)(u8 *addr);
++=======
+ 	void (*reg_writel)(u32 value, u32 *addr);
+ 	u32 (*reg_readl)(u32 *addr);
+ 	void (*reg_writew)(u16 value, u16 *addr);
+ 	u16 (*reg_readw)(u16 *addr);
+ 	void (*reg_writeb)(u8 value, u8 *addr);
+ 	u8 (*reg_readb)(u8 *addr);
+ 	/* Disable msi if supported, PCI only */
+ 	int (*disable_msi_reset_irq)(struct azx *);
+ 	/* Allocation ops */
+ 	int (*dma_alloc_pages)(struct azx *chip,
+ 			       int type,
+ 			       size_t size,
+ 			       struct snd_dma_buffer *buf);
+ 	void (*dma_free_pages)(struct azx *chip, struct snd_dma_buffer *buf);
+ 	int (*substream_alloc_pages)(struct azx *chip,
+ 				     struct snd_pcm_substream *substream,
+ 				     size_t size);
+ 	int (*substream_free_pages)(struct azx *chip,
+ 				    struct snd_pcm_substream *substream);
+ 	void (*pcm_mmap_prepare)(struct snd_pcm_substream *substream,
+ 				 struct vm_area_struct *area);
+ 	/* Check if current position is acceptable */
+ 	int (*position_check)(struct azx *chip, struct azx_dev *azx_dev);
++>>>>>>> 778bde6f59e0 (ALSA: hda - Rename reg access ops in hda_controller_ops)
  };
  
  struct azx_pcm {
* Unmerged path sound/pci/hda/hda_intel.c
* Unmerged path sound/pci/hda/hda_priv.h
