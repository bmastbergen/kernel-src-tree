ACPI / hotplug / PCI: Store acpi_device pointer in acpiphp_context

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Store acpi_device pointer in acpiphp_context (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 92.68%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit bbcbfc0eed6220591ccc5752edd079099bb1920c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/bbcbfc0e.failed

After recent modifications of the ACPI core making it create a struct
acpi_device object for every namespace node representing a device
regardless of the current status of that device the ACPIPHP code
can store a struct acpi_device pointer instead of an ACPI handle
in struct acpiphp_context.  This immediately makes it possible to
avoid making potentially costly calls to acpi_bus_get_device() in
two places and allows some more simplifications to be made going
forward.

The reason why that is correct is because ACPIPHP only installs
hotify handlers for namespace nodes that exist when
acpiphp_enumerate_slots() is called for their parent bridge.
That only happens if the parent bridge has an ACPI companion
associated with it, which means that the ACPI namespace scope
in question has been scanned already at that point.  That, in
turn, means that struct acpi_device objects have been created
for all namespace nodes in that scope and pointers to those
objects can be stored directly instead of their ACPI handles.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit bbcbfc0eed6220591ccc5752edd079099bb1920c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp.h
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp.h
index 9435d828e52f,098ff425f850..000000000000
--- a/drivers/pci/hotplug/acpiphp.h
+++ b/drivers/pci/hotplug/acpiphp.h
@@@ -119,6 -116,28 +119,31 @@@ struct acpiphp_func 
  	u32		flags;		/* see below */
  };
  
++<<<<<<< HEAD
++=======
+ struct acpiphp_context {
+ 	struct acpiphp_func func;
+ 	struct acpi_device *adev;
+ 	struct acpiphp_bridge *bridge;
+ 	unsigned int refcount;
+ };
+ 
+ static inline struct acpiphp_context *func_to_context(struct acpiphp_func *func)
+ {
+ 	return container_of(func, struct acpiphp_context, func);
+ }
+ 
+ static inline struct acpi_device *func_to_acpi_device(struct acpiphp_func *func)
+ {
+ 	return func_to_context(func)->adev;
+ }
+ 
+ static inline acpi_handle func_to_handle(struct acpiphp_func *func)
+ {
+ 	return func_to_acpi_device(func)->handle;
+ }
+ 
++>>>>>>> bbcbfc0eed62 (ACPI / hotplug / PCI: Store acpi_device pointer in acpiphp_context)
  /*
   * struct acpiphp_attention_info - device specific attention registration
   *
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,896a13bf2e02..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -57,26 -58,80 +57,90 @@@
  
  static LIST_HEAD(bridge_list);
  static DEFINE_MUTEX(bridge_mutex);
 -static DEFINE_MUTEX(acpiphp_context_lock);
  
 -static void handle_hotplug_event(acpi_handle handle, u32 type, void *data);
 +static void handle_hotplug_event_bridge (acpi_handle, u32, void *);
  static void acpiphp_sanitize_bus(struct pci_bus *bus);
  static void acpiphp_set_hpp_values(struct pci_bus *bus);
 -static void hotplug_event(acpi_handle handle, u32 type, void *data);
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context);
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type, void *context);
  static void free_bridge(struct kref *kref);
  
 -static void acpiphp_context_handler(acpi_handle handle, void *context)
 +/* callback routine to check for the existence of a pci dock device */
 +static acpi_status
 +is_pci_dock_device(acpi_handle handle, u32 lvl, void *context, void **rv)
  {
 -	/* Intentionally empty. */
 -}
 +	int *count = (int *)context;
  
++<<<<<<< HEAD
 +	if (is_dock_device(handle)) {
 +		(*count)++;
 +		return AE_CTRL_TERMINATE;
 +	} else {
 +		return AE_OK;
 +	}
++=======
+ /**
+  * acpiphp_init_context - Create hotplug context and grab a reference to it.
+  * @adev: ACPI device object to create the context for.
+  *
+  * Call under acpiphp_context_lock.
+  */
+ static struct acpiphp_context *acpiphp_init_context(struct acpi_device *adev)
+ {
+ 	struct acpiphp_context *context;
+ 	acpi_status status;
+ 
+ 	context = kzalloc(sizeof(*context), GFP_KERNEL);
+ 	if (!context)
+ 		return NULL;
+ 
+ 	context->adev = adev;
+ 	context->refcount = 1;
+ 	status = acpi_attach_data(adev->handle, acpiphp_context_handler, context);
+ 	if (ACPI_FAILURE(status)) {
+ 		kfree(context);
+ 		return NULL;
+ 	}
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_get_context - Get hotplug context and grab a reference to it.
+  * @handle: ACPI object handle to get the context for.
+  *
+  * Call under acpiphp_context_lock.
+  */
+ static struct acpiphp_context *acpiphp_get_context(acpi_handle handle)
+ {
+ 	struct acpiphp_context *context = NULL;
+ 	acpi_status status;
+ 	void *data;
+ 
+ 	status = acpi_get_data(handle, acpiphp_context_handler, &data);
+ 	if (ACPI_SUCCESS(status)) {
+ 		context = data;
+ 		context->refcount++;
+ 	}
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_put_context - Drop a reference to ACPI hotplug context.
+  * @context: ACPI hotplug context to drop a reference to.
+  *
+  * The context object is removed if there are no more references to it.
+  *
+  * Call under acpiphp_context_lock.
+  */
+ static void acpiphp_put_context(struct acpiphp_context *context)
+ {
+ 	if (--context->refcount)
+ 		return;
+ 
+ 	WARN_ON(context->bridge);
+ 	acpi_detach_data(context->adev->handle, acpiphp_context_handler);
+ 	kfree(context);
++>>>>>>> bbcbfc0eed62 (ACPI / hotplug / PCI: Store acpi_device pointer in acpiphp_context)
  }
  
  static inline void get_bridge(struct acpiphp_bridge *bridge)
@@@ -143,12 -208,31 +207,34 @@@ static int post_dock_fixups(struct noti
  			| ((unsigned int)(bus->busn_res.end) << 16);
  		pci_write_config_dword(bus->self, PCI_PRIMARY_BUS, buses);
  	}
 +	return NOTIFY_OK;
  }
  
++<<<<<<< HEAD
++=======
+ static void dock_event(acpi_handle handle, u32 type, void *data)
+ {
+ 	struct acpiphp_context *context;
+ 
+ 	mutex_lock(&acpiphp_context_lock);
+ 	context = acpiphp_get_context(handle);
+ 	if (!context || WARN_ON(context->adev->handle != handle)
+ 	    || context->func.parent->is_going_away) {
+ 		mutex_unlock(&acpiphp_context_lock);
+ 		return;
+ 	}
+ 	get_bridge(context->func.parent);
+ 	acpiphp_put_context(context);
+ 	mutex_unlock(&acpiphp_context_lock);
+ 
+ 	hotplug_event(handle, type, data);
+ 
+ 	put_bridge(context->func.parent);
+ }
++>>>>>>> bbcbfc0eed62 (ACPI / hotplug / PCI: Store acpi_device pointer in acpiphp_context)
  
  static const struct acpi_dock_ops acpiphp_dock_ops = {
 -	.fixup = post_dock_fixups,
 -	.handler = dock_event,
 +	.handler = hotplug_event_func,
  };
  
  /* Check whether the PCI device is managed by native PCIe hotplug driver */
@@@ -195,101 -279,98 +281,123 @@@ static void acpiphp_dock_release(void *
  }
  
  /* callback routine to register each ACPI PCI slot object */
 -static acpi_status register_slot(acpi_handle handle, u32 lvl, void *data,
 -				 void **rv)
 +static acpi_status
 +register_slot(acpi_handle handle, u32 lvl, void *context, void **rv)
  {
++<<<<<<< HEAD
 +	struct acpiphp_bridge *bridge = (struct acpiphp_bridge *)context;
++=======
+ 	struct acpiphp_bridge *bridge = data;
+ 	struct acpiphp_context *context;
+ 	struct acpi_device *adev;
++>>>>>>> bbcbfc0eed62 (ACPI / hotplug / PCI: Store acpi_device pointer in acpiphp_context)
  	struct acpiphp_slot *slot;
  	struct acpiphp_func *newfunc;
 +	acpi_handle tmp;
  	acpi_status status = AE_OK;
 -	unsigned long long adr;
 -	int device, function;
 +	unsigned long long adr, sun;
 +	int device, function, retval, found = 0;
  	struct pci_bus *pbus = bridge->pci_bus;
 -	struct pci_dev *pdev = bridge->pci_dev;
 +	struct pci_dev *pdev;
  	u32 val;
  
 -	if (pdev && device_is_managed_by_native_pciehp(pdev))
 +	if (!acpi_pci_check_ejectable(pbus, handle) && !is_dock_device(handle))
  		return AE_OK;
  
  	status = acpi_evaluate_integer(handle, "_ADR", NULL, &adr);
  	if (ACPI_FAILURE(status)) {
 -		if (status != AE_NOT_FOUND)
 -			acpi_handle_warn(handle,
 -				"can't evaluate _ADR (%#x)\n", status);
 +		pr_warn("can't evaluate _ADR (%#x)\n", status);
  		return AE_OK;
  	}
+ 	if (acpi_bus_get_device(handle, &adev))
+ 		return AE_OK;
  
  	device = (adr >> 16) & 0xffff;
  	function = adr & 0xffff;
  
++<<<<<<< HEAD
 +	pdev = bridge->pci_dev;
 +	if (pdev && device_is_managed_by_native_pciehp(pdev))
 +		return AE_OK;
++=======
+ 	mutex_lock(&acpiphp_context_lock);
+ 	context = acpiphp_init_context(adev);
+ 	if (!context) {
+ 		mutex_unlock(&acpiphp_context_lock);
+ 		acpi_handle_err(handle, "No hotplug context\n");
+ 		return AE_NOT_EXIST;
+ 	}
+ 	newfunc = &context->func;
+ 	newfunc->function = function;
+ 	newfunc->parent = bridge;
+ 	mutex_unlock(&acpiphp_context_lock);
++>>>>>>> bbcbfc0eed62 (ACPI / hotplug / PCI: Store acpi_device pointer in acpiphp_context)
 +
 +	newfunc = kzalloc(sizeof(struct acpiphp_func), GFP_KERNEL);
 +	if (!newfunc)
 +		return AE_NO_MEMORY;
 +
 +	newfunc->handle = handle;
 +	newfunc->function = function;
  
 -	if (acpi_has_method(handle, "_EJ0"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
  		newfunc->flags = FUNC_HAS_EJ0;
  
 -	if (acpi_has_method(handle, "_STA"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_STA", &tmp)))
  		newfunc->flags |= FUNC_HAS_STA;
  
 -	if (acpi_has_method(handle, "_DCK"))
 -		newfunc->flags |= FUNC_HAS_DCK;
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS0", &tmp)))
 +		newfunc->flags |= FUNC_HAS_PS0;
  
 -	/* search for objects that share the same slot */
 -	list_for_each_entry(slot, &bridge->slots, node)
 -		if (slot->device == device)
 -			goto slot_found;
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS3", &tmp)))
 +		newfunc->flags |= FUNC_HAS_PS3;
  
 -	slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 -	if (!slot) {
 -		mutex_lock(&acpiphp_context_lock);
 -		acpiphp_put_context(context);
 -		mutex_unlock(&acpiphp_context_lock);
 -		return AE_NO_MEMORY;
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_DCK", &tmp)))
 +		newfunc->flags |= FUNC_HAS_DCK;
 +
 +	status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 +	if (ACPI_FAILURE(status)) {
 +		/*
 +		 * use the count of the number of slots we've found
 +		 * for the number of the slot
 +		 */
 +		sun = bridge->nr_slots+1;
  	}
  
 -	slot->bus = bridge->pci_bus;
 -	slot->device = device;
 -	INIT_LIST_HEAD(&slot->funcs);
 -	mutex_init(&slot->crit_sect);
 +	/* search for objects that share the same slot */
 +	list_for_each_entry(slot, &bridge->slots, node)
 +		if (slot->device == device) {
 +			if (slot->sun != sun)
 +				pr_warn("sibling found, but _SUN doesn't match!\n");
 +			found = 1;
 +			break;
 +		}
  
 -	list_add_tail(&slot->node, &bridge->slots);
 +	if (!found) {
 +		slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 +		if (!slot) {
 +			kfree(newfunc);
 +			return AE_NO_MEMORY;
 +		}
  
 -	/* Register slots for ejectable functions only. */
 -	if (acpi_pci_check_ejectable(pbus, handle)  || is_dock_device(handle)) {
 -		unsigned long long sun;
 -		int retval;
 +		slot->bridge = bridge;
 +		slot->device = device;
 +		slot->sun = sun;
 +		INIT_LIST_HEAD(&slot->funcs);
 +		mutex_init(&slot->crit_sect);
  
 +		mutex_lock(&bridge_mutex);
 +		list_add_tail(&slot->node, &bridge->slots);
 +		mutex_unlock(&bridge_mutex);
  		bridge->nr_slots++;
 -		status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 -		if (ACPI_FAILURE(status))
 -			sun = bridge->nr_slots;
  
  		pr_debug("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",
 -		    sun, pci_domain_nr(pbus), pbus->number, device);
 -
 -		retval = acpiphp_register_hotplug_slot(slot, sun);
 +		    slot->sun, pci_domain_nr(pbus), pbus->number, device);
 +		retval = acpiphp_register_hotplug_slot(slot);
  		if (retval) {
 -			slot->slot = NULL;
 -			bridge->nr_slots--;
  			if (retval == -EBUSY)
  				pr_warn("Slot %llu already registered by another "
 -					"hotplug driver\n", sun);
 +					"hotplug driver\n", slot->sun);
  			else
  				pr_warn("acpiphp_register_hotplug_slot failed "
  					"(err code = 0x%x)\n", retval);
@@@ -778,20 -627,31 +886,43 @@@ static int disable_device(struct acpiph
  	 * methods (_EJ0, etc.) or not.  Therefore, we remove all functions
  	 * here.
  	 */
 -	list_for_each_entry_safe_reverse(dev, prev, &bus->devices, bus_list)
 -		if (PCI_SLOT(dev->devfn) == slot->device)
 -			pci_stop_and_remove_bus_device(dev);
 +	while ((pdev = dev_in_slot(slot))) {
 +		pci_stop_and_remove_bus_device(pdev);
 +		pci_dev_put(pdev);
 +	}
  
++<<<<<<< HEAD
 +	list_for_each_entry(func, &slot->funcs, sibling) {
 +		acpiphp_bus_trim(func->handle);
 +	}
++=======
+ 	list_for_each_entry(func, &slot->funcs, sibling)
+ 		acpi_bus_trim(func_to_acpi_device(func));
++>>>>>>> bbcbfc0eed62 (ACPI / hotplug / PCI: Store acpi_device pointer in acpiphp_context)
  
  	slot->flags &= (~SLOT_ENABLED);
 +
 +	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static bool acpiphp_no_hotplug(struct acpi_device *adev)
+ {
+ 	return adev && adev->flags.no_hotplug;
+ }
+ 
+ static bool slot_no_hotplug(struct acpiphp_slot *slot)
+ {
+ 	struct acpiphp_func *func;
+ 
+ 	list_for_each_entry(func, &slot->funcs, sibling)
+ 		if (acpiphp_no_hotplug(func_to_acpi_device(func)))
+ 			return true;
+ 
+ 	return false;
+ }
++>>>>>>> bbcbfc0eed62 (ACPI / hotplug / PCI: Store acpi_device pointer in acpiphp_context)
  
  /**
   * get_slot_status - get ACPI slot status
@@@ -1054,9 -896,23 +1185,26 @@@ static void _handle_hotplug_event_bridg
  		break;
  	}
  
++<<<<<<< HEAD
++=======
+ 	pci_unlock_rescan_remove();
+ 	if (bridge)
+ 		put_bridge(bridge);
+ }
+ 
+ static void hotplug_event_work(void *data, u32 type)
+ {
+ 	struct acpiphp_context *context = data;
+ 	acpi_handle handle = context->adev->handle;
+ 
+ 	acpi_scan_lock_acquire();
+ 
+ 	hotplug_event(handle, type, context);
+ 
++>>>>>>> bbcbfc0eed62 (ACPI / hotplug / PCI: Store acpi_device pointer in acpiphp_context)
  	acpi_scan_lock_release();
 -	acpi_evaluate_hotplug_ost(handle, type, ACPI_OST_SC_SUCCESS, NULL);
 -	put_bridge(context->func.parent);
 +	kfree(hp_work); /* allocated in handle_hotplug_event_bridge */
 +	put_bridge(bridge);
  }
  
  /**
@@@ -1107,62 -939,49 +1255,70 @@@ static void hotplug_event_func(acpi_han
  		break;
  
  	case ACPI_NOTIFY_DEVICE_WAKE:
 -		return;
 -
 -	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
 -		acpi_handle_err(handle, "Device cannot be configured due "
 -				"to a frequency mismatch\n");
 -		goto out;
 -
 -	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
 -		acpi_handle_err(handle, "Device cannot be configured due "
 -				"to a bus mode mismatch\n");
 -		goto out;
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
 +		break;
  
 -	case ACPI_NOTIFY_POWER_FAULT:
 -		acpi_handle_err(handle, "Device has suffered a power fault\n");
 -		goto out;
 +	case ACPI_NOTIFY_EJECT_REQUEST:
 +		/* request device eject */
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if (!(acpiphp_disable_slot(func->slot)))
 +			acpiphp_eject_slot(func->slot);
 +		break;
  
  	default:
 -		acpi_handle_warn(handle, "Unsupported event type 0x%x\n", type);
 -		ost_code = ACPI_OST_SC_UNRECOGNIZED_NOTIFY;
 -		goto out;
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
 +		break;
  	}
 +}
  
++<<<<<<< HEAD
 +static void _handle_hotplug_event_func(struct work_struct *work)
 +{
 +	struct acpi_hp_work *hp_work;
 +	struct acpiphp_func *func;
++=======
+ 	mutex_lock(&acpiphp_context_lock);
+ 	context = acpiphp_get_context(handle);
+ 	if (!context || WARN_ON(context->adev->handle != handle)
+ 	    || context->func.parent->is_going_away)
+ 		goto err_out;
++>>>>>>> bbcbfc0eed62 (ACPI / hotplug / PCI: Store acpi_device pointer in acpiphp_context)
  
 -	get_bridge(context->func.parent);
 -	acpiphp_put_context(context);
 -	status = acpi_hotplug_execute(hotplug_event_work, context, type);
 -	if (ACPI_SUCCESS(status)) {
 -		mutex_unlock(&acpiphp_context_lock);
 -		return;
 -	}
 -	put_bridge(context->func.parent);
 +	hp_work = container_of(work, struct acpi_hp_work, work);
 +	func = hp_work->context;
 +	acpi_scan_lock_acquire();
  
 - err_out:
 -	mutex_unlock(&acpiphp_context_lock);
 -	ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 +	hotplug_event_func(hp_work->handle, hp_work->type, func);
  
 - out:
 -	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
 +	acpi_scan_lock_release();
 +	kfree(hp_work); /* allocated in handle_hotplug_event_func */
 +	put_bridge(func->slot->bridge);
 +}
 +
 +/**
 + * handle_hotplug_event_func - handle ACPI event on functions (i.e. slots)
 + * @handle: Notify()'ed acpi_handle
 + * @type: Notify code
 + * @context: pointer to acpiphp_func structure
 + *
 + * Handles ACPI event notification on slots.
 + */
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type,
 +				      void *context)
 +{
 +	struct acpiphp_func *func = context;
 +
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(func->slot->bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_func);
  }
  
  /**
@@@ -1172,20 -991,24 +1328,32 @@@
   * A "slot" is an object associated with a PCI device number.  All functions
   * (PCI devices) with the same bus and device number belong to the same slot.
   */
 -void acpiphp_enumerate_slots(struct pci_bus *bus)
 +void acpiphp_enumerate_slots(struct pci_bus *bus, acpi_handle handle)
  {
 +	acpi_handle dummy_handle;
  	struct acpiphp_bridge *bridge;
++<<<<<<< HEAD
++=======
+ 	struct acpi_device *adev;
+ 	acpi_handle handle;
+ 	acpi_status status;
++>>>>>>> bbcbfc0eed62 (ACPI / hotplug / PCI: Store acpi_device pointer in acpiphp_context)
  
  	if (acpiphp_disabled)
  		return;
  
++<<<<<<< HEAD
 +	if (detect_ejectable_slots(handle) <= 0)
++=======
+ 	adev = ACPI_COMPANION(bus->bridge);
+ 	if (!adev)
++>>>>>>> bbcbfc0eed62 (ACPI / hotplug / PCI: Store acpi_device pointer in acpiphp_context)
  		return;
  
+ 	handle = adev->handle;
  	bridge = kzalloc(sizeof(struct acpiphp_bridge), GFP_KERNEL);
 -	if (!bridge) {
 -		acpi_handle_err(handle, "No memory for bridge object\n");
 +	if (bridge == NULL) {
 +		pr_err("out of memory\n");
  		return;
  	}
  
* Unmerged path drivers/pci/hotplug/acpiphp.h
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
