md/raid5: avoid livelock caused by non-aligned writes.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [md] raid5: avoid livelock caused by non-aligned writes (Jes Sorensen) [1085530]
Rebuild_FUZZ: 96.15%
commit-author NeilBrown <neilb@suse.de>
commit a40687ff73a5b14909d6aa522f7d778b158911c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a40687ff.failed

If a stripe in a raid6 array received a write to each data block while
the array is degraded, and if any of these writes to a missing device
are not page-aligned, then a live-lock happens.

In this case the P and Q blocks need to be read so that the part of
the missing block which is *not* being updated by the write can be
constructed.  Due to a logic error, these blocks are not loaded, so
the update cannot proceed and the stripe is 'handled' repeatedly in an
infinite loop.

This bug is unlikely as most writes are page aligned.  However as it
can lead to a livelock it is suitable for -stable.  It was introduced
in 3.16.

	Cc: stable@vger.kernel.org (v3.16)
Fixed: 67f455486d2ea20b2d94d6adf5b9b783d079e321
	Signed-off-by: NeilBrown <neilb@suse.de>
(cherry picked from commit a40687ff73a5b14909d6aa522f7d778b158911c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/raid5.c
diff --cc drivers/md/raid5.c
index 1b0917eb08e6,6b2d615d1094..000000000000
--- a/drivers/md/raid5.c
+++ b/drivers/md/raid5.c
@@@ -2904,8 -2919,11 +2904,14 @@@ static int fetch_block(struct stripe_he
  	     (s->failed >= 1 && fdev[0]->toread) ||
  	     (s->failed >= 2 && fdev[1]->toread) ||
  	     (sh->raid_conf->level <= 5 && s->failed && fdev[0]->towrite &&
 -	      (!test_bit(R5_Insync, &dev->flags) || test_bit(STRIPE_PREREAD_ACTIVE, &sh->state)) &&
  	      !test_bit(R5_OVERWRITE, &fdev[0]->flags)) ||
++<<<<<<< HEAD
 +	     (sh->raid_conf->level == 6 && s->failed && s->to_write))) {
++=======
+ 	     (sh->raid_conf->level == 6 && s->failed && s->to_write &&
+ 	      s->to_write - s->non_overwrite < sh->raid_conf->raid_disks - 2 &&
+ 	      (!test_bit(R5_Insync, &dev->flags) || test_bit(STRIPE_PREREAD_ACTIVE, &sh->state))))) {
++>>>>>>> a40687ff73a5 (md/raid5: avoid livelock caused by non-aligned writes.)
  		/* we would like to get this block, possibly by computing it,
  		 * otherwise read it if the backing disk is insync
  		 */
* Unmerged path drivers/md/raid5.c
