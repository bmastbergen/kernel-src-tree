kvm: Add arch specific mmu notifier for page invalidation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Tang Chen <tangchen@cn.fujitsu.com>
commit fe71557afbec641fee73711e40602bed37f6f33b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/fe71557a.failed

This will be used to let the guest run while the APIC access page is
not pinned.  Because subsequent patches will fill in the function
for x86, place the (still empty) x86 implementation in the x86.c file
instead of adding an inline function in kvm_host.h.

	Signed-off-by: Tang Chen <tangchen@cn.fujitsu.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit fe71557afbec641fee73711e40602bed37f6f33b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/include/asm/kvm_host.h
#	arch/powerpc/include/asm/kvm_host.h
#	arch/x86/kvm/x86.c
diff --cc arch/powerpc/include/asm/kvm_host.h
index db69ef15e5ee,2cf6c1587d43..000000000000
--- a/arch/powerpc/include/asm/kvm_host.h
+++ b/arch/powerpc/include/asm/kvm_host.h
@@@ -61,7 -60,10 +61,14 @@@ extern int kvm_age_hva(struct kvm *kvm
  extern int kvm_test_age_hva(struct kvm *kvm, unsigned long hva);
  extern void kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte);
  
++<<<<<<< HEAD
 +#endif
++=======
+ static inline void kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,
+ 							 unsigned long address)
+ {
+ }
++>>>>>>> fe71557afbec (kvm: Add arch specific mmu notifier for page invalidation)
  
  #define HPTEG_CACHE_NUM			(1 << 15)
  #define HPTEG_HASH_BITS_PTE		13
diff --cc arch/x86/kvm/x86.c
index fbab0434f978,142569e6f8f9..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -5916,6 -6020,17 +5916,20 @@@ static void vcpu_scan_ioapic(struct kvm
  	kvm_apic_update_tmr(vcpu, tmr);
  }
  
++<<<<<<< HEAD
++=======
+ static void kvm_vcpu_flush_tlb(struct kvm_vcpu *vcpu)
+ {
+ 	++vcpu->stat.tlb_flush;
+ 	kvm_x86_ops->tlb_flush(vcpu);
+ }
+ 
+ void kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,
+ 					   unsigned long address)
+ {
+ }
+ 
++>>>>>>> fe71557afbec (kvm: Add arch specific mmu notifier for page invalidation)
  /*
   * Returns 1 to let __vcpu_run() continue the guest execution loop without
   * exiting to the userspace.  Otherwise, the value will be returned to the
* Unmerged path arch/arm64/include/asm/kvm_host.h
diff --git a/arch/arm/include/asm/kvm_host.h b/arch/arm/include/asm/kvm_host.h
index 57cb786a6203..9ead7f53be2e 100644
--- a/arch/arm/include/asm/kvm_host.h
+++ b/arch/arm/include/asm/kvm_host.h
@@ -178,6 +178,11 @@ static inline int kvm_test_age_hva(struct kvm *kvm, unsigned long hva)
 	return 0;
 }
 
+static inline void kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,
+							 unsigned long address)
+{
+}
+
 struct kvm_vcpu *kvm_arm_get_running_vcpu(void);
 struct kvm_vcpu __percpu **kvm_get_running_vcpus(void);
 
* Unmerged path arch/arm64/include/asm/kvm_host.h
* Unmerged path arch/powerpc/include/asm/kvm_host.h
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index 31cd3909a583..645da3010692 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -1038,6 +1038,8 @@ int kvm_cpu_has_interrupt(struct kvm_vcpu *vcpu);
 int kvm_arch_interrupt_allowed(struct kvm_vcpu *vcpu);
 int kvm_cpu_get_interrupt(struct kvm_vcpu *v);
 void kvm_vcpu_reset(struct kvm_vcpu *vcpu);
+void kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,
+					   unsigned long address);
 
 void kvm_define_shared_msr(unsigned index, u32 msr);
 void kvm_set_shared_msr(unsigned index, u64 val, u64 mask);
* Unmerged path arch/x86/kvm/x86.c
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 0ad102410801..ed717d075c7a 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -293,6 +293,9 @@ static void kvm_mmu_notifier_invalidate_page(struct mmu_notifier *mn,
 		kvm_flush_remote_tlbs(kvm);
 
 	spin_unlock(&kvm->mmu_lock);
+
+	kvm_arch_mmu_notifier_invalidate_page(kvm, address);
+
 	srcu_read_unlock(&kvm->srcu, idx);
 }
 
