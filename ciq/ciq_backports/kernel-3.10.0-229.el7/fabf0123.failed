perf tests: Add map groups sharing with thread object test

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf/tests: Add map groups sharing with thread object test (Jiri Olsa) [1134356]
Rebuild_FUZZ: 98.28%
commit-author Jiri Olsa <jolsa@kernel.org>
commit fabf01238289e9ae009499594fc54642f5802a24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/fabf0123.failed

This test create 2 processes abstractions, with several threads
and checks they properly share and maintain map groups info.

	Acked-by: Namhyung Kim <namhyung@kernel.org>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Don Zickus <dzickus@redhat.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Mike Galbraith <efault@gmx.de>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Stephane Eranian <eranian@google.com>
Link: http://lkml.kernel.org/r/1397490723-1992-6-git-send-email-jolsa@redhat.com
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
(cherry picked from commit fabf01238289e9ae009499594fc54642f5802a24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Makefile.perf
#	tools/perf/tests/tests.h
diff --cc tools/perf/Makefile.perf
index 01fd40359345,46e0c32ad23b..000000000000
--- a/tools/perf/Makefile.perf
+++ b/tools/perf/Makefile.perf
@@@ -412,6 -411,13 +412,16 @@@ endi
  LIB_OBJS += $(OUTPUT)tests/code-reading.o
  LIB_OBJS += $(OUTPUT)tests/sample-parsing.o
  LIB_OBJS += $(OUTPUT)tests/parse-no-sample-id-all.o
++<<<<<<< HEAD
++=======
+ ifndef NO_DWARF_UNWIND
+ ifeq ($(ARCH),x86)
+ LIB_OBJS += $(OUTPUT)tests/dwarf-unwind.o
+ endif
+ endif
+ LIB_OBJS += $(OUTPUT)tests/mmap-thread-lookup.o
+ LIB_OBJS += $(OUTPUT)tests/thread-mg-share.o
++>>>>>>> fabf01238289 (perf tests: Add map groups sharing with thread object test)
  
  BUILTIN_OBJS += $(OUTPUT)builtin-annotate.o
  BUILTIN_OBJS += $(OUTPUT)builtin-bench.o
diff --cc tools/perf/tests/tests.h
index e0ac713857ba,a9d7cb019f9e..000000000000
--- a/tools/perf/tests/tests.h
+++ b/tools/perf/tests/tests.h
@@@ -40,5 -40,17 +40,12 @@@ int test__code_reading(void)
  int test__sample_parsing(void);
  int test__keep_tracking(void);
  int test__parse_no_sample_id_all(void);
++<<<<<<< HEAD
++=======
+ int test__dwarf_unwind(void);
+ int test__hists_filter(void);
+ int test__mmap_thread_lookup(void);
+ int test__thread_mg_share(void);
++>>>>>>> fabf01238289 (perf tests: Add map groups sharing with thread object test)
  
 -#if defined(__x86_64__) || defined(__i386__)
 -#ifdef HAVE_DWARF_UNWIND_SUPPORT
 -struct thread;
 -struct perf_sample;
 -int test__arch_unwind_sample(struct perf_sample *sample,
 -			     struct thread *thread);
 -#endif
 -#endif
  #endif /* TESTS_H */
* Unmerged path tools/perf/Makefile.perf
diff --git a/tools/perf/tests/builtin-test.c b/tools/perf/tests/builtin-test.c
index 1e67437fb4ca..ebc229e632fc 100644
--- a/tools/perf/tests/builtin-test.c
+++ b/tools/perf/tests/builtin-test.c
@@ -115,6 +115,10 @@ static struct test {
 		.desc = "Test parsing with no sample_id_all bit set",
 		.func = test__parse_no_sample_id_all,
 	},
+	{
+		.desc = "Test thread mg sharing",
+		.func = test__thread_mg_share,
+	},
 	{
 		.func = NULL,
 	},
* Unmerged path tools/perf/tests/tests.h
diff --git a/tools/perf/tests/thread-mg-share.c b/tools/perf/tests/thread-mg-share.c
new file mode 100644
index 000000000000..2b2e0dbe114f
--- /dev/null
+++ b/tools/perf/tests/thread-mg-share.c
@@ -0,0 +1,90 @@
+#include "tests.h"
+#include "machine.h"
+#include "thread.h"
+#include "map.h"
+
+int test__thread_mg_share(void)
+{
+	struct machines machines;
+	struct machine *machine;
+
+	/* thread group */
+	struct thread *leader;
+	struct thread *t1, *t2, *t3;
+	struct map_groups *mg;
+
+	/* other process */
+	struct thread *other, *other_leader;
+	struct map_groups *other_mg;
+
+	/*
+	 * This test create 2 processes abstractions (struct thread)
+	 * with several threads and checks they properly share and
+	 * maintain map groups info (struct map_groups).
+	 *
+	 * thread group (pid: 0, tids: 0, 1, 2, 3)
+	 * other  group (pid: 4, tids: 4, 5)
+	*/
+
+	machines__init(&machines);
+	machine = &machines.host;
+
+	/* create process with 4 threads */
+	leader = machine__findnew_thread(machine, 0, 0);
+	t1     = machine__findnew_thread(machine, 0, 1);
+	t2     = machine__findnew_thread(machine, 0, 2);
+	t3     = machine__findnew_thread(machine, 0, 3);
+
+	/* and create 1 separated process, without thread leader */
+	other  = machine__findnew_thread(machine, 4, 5);
+
+	TEST_ASSERT_VAL("failed to create threads",
+			leader && t1 && t2 && t3 && other);
+
+	mg = leader->mg;
+	TEST_ASSERT_VAL("wrong refcnt", mg->refcnt == 4);
+
+	/* test the map groups pointer is shared */
+	TEST_ASSERT_VAL("map groups don't match", mg == t1->mg);
+	TEST_ASSERT_VAL("map groups don't match", mg == t2->mg);
+	TEST_ASSERT_VAL("map groups don't match", mg == t3->mg);
+
+	/*
+	 * Verify the other leader was created by previous call.
+	 * It should have shared map groups with no change in
+	 * refcnt.
+	 */
+	other_leader = machine__find_thread(machine, 4, 4);
+	TEST_ASSERT_VAL("failed to find other leader", other_leader);
+
+	other_mg = other->mg;
+	TEST_ASSERT_VAL("wrong refcnt", other_mg->refcnt == 2);
+
+	TEST_ASSERT_VAL("map groups don't match", other_mg == other_leader->mg);
+
+	/* release thread group */
+	thread__delete(leader);
+	TEST_ASSERT_VAL("wrong refcnt", mg->refcnt == 3);
+
+	thread__delete(t1);
+	TEST_ASSERT_VAL("wrong refcnt", mg->refcnt == 2);
+
+	thread__delete(t2);
+	TEST_ASSERT_VAL("wrong refcnt", mg->refcnt == 1);
+
+	thread__delete(t3);
+
+	/* release other group  */
+	thread__delete(other_leader);
+	TEST_ASSERT_VAL("wrong refcnt", other_mg->refcnt == 1);
+
+	thread__delete(other);
+
+	/*
+	 * Cannot call machine__delete_threads(machine) now,
+	 * because we've already released all the threads.
+	 */
+
+	machines__exit(&machines);
+	return 0;
+}
