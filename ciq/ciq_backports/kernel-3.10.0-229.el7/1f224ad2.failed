i40e: Add ndo_get_phys_port_id() callback support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Neerav Parikh <neerav.parikh@intel.com>
commit 1f224ad2f760288dcc58b26546892a6b200b2af2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/1f224ad2.failed

This patch adds a new API to get the port mac address from firmware.
It also adds support to the ndo_get_phys_port_id() callback to provide
port specific unique id to the netdev layer.
If the adapter has a valid per-port mac address then that
would be used for this purpose and is expected to be unique
on a per-port basis.

The information can be viewed by reading the phys_port_id
attribute in sysfs for each netdev or via IF netlink
interface.

Change-ID: I341fa6fff9c112f1f6d987189309e730e0b50e8b
	Signed-off-by: Neerav Parikh <neerav.parikh@intel.com>
	Acked-by: Shannon Nelson <shannon.nelson@intel.com>
	Tested-by: Jim Young <jamesx.m.young@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 1f224ad2f760288dcc58b26546892a6b200b2af2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_common.c
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_common.c
index 1866f4096b38,51087b5c7d91..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_common.c
@@@ -287,6 -655,63 +287,66 @@@ i40e_status i40e_get_mac_addr(struct i4
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_get_port_mac_addr - get Port MAC address
+  * @hw: pointer to the HW structure
+  * @mac_addr: pointer to Port MAC address
+  *
+  * Reads the adapter's Port MAC address
+  **/
+ i40e_status i40e_get_port_mac_addr(struct i40e_hw *hw, u8 *mac_addr)
+ {
+ 	struct i40e_aqc_mac_address_read_data addrs;
+ 	i40e_status status;
+ 	u16 flags = 0;
+ 
+ 	status = i40e_aq_mac_address_read(hw, &flags, &addrs, NULL);
+ 	if (status)
+ 		return status;
+ 
+ 	if (flags & I40E_AQC_PORT_ADDR_VALID)
+ 		memcpy(mac_addr, &addrs.port_mac, sizeof(addrs.port_mac));
+ 	else
+ 		status = I40E_ERR_INVALID_MAC_ADDR;
+ 
+ 	return status;
+ }
+ 
+ /**
+  * i40e_pre_tx_queue_cfg - pre tx queue configure
+  * @hw: pointer to the HW structure
+  * @queue: target pf queue index
+  * @enable: state change request
+  *
+  * Handles hw requirement to indicate intention to enable
+  * or disable target queue.
+  **/
+ void i40e_pre_tx_queue_cfg(struct i40e_hw *hw, u32 queue, bool enable)
+ {
+ 	u32 abs_queue_idx = hw->func_caps.base_queue + queue;
+ 	u32 reg_block = 0;
+ 	u32 reg_val;
+ 
+ 	if (abs_queue_idx >= 128) {
+ 		reg_block = abs_queue_idx / 128;
+ 		abs_queue_idx %= 128;
+ 	}
+ 
+ 	reg_val = rd32(hw, I40E_GLLAN_TXPRE_QDIS(reg_block));
+ 	reg_val &= ~I40E_GLLAN_TXPRE_QDIS_QINDX_MASK;
+ 	reg_val |= (abs_queue_idx << I40E_GLLAN_TXPRE_QDIS_QINDX_SHIFT);
+ 
+ 	if (enable)
+ 		reg_val |= I40E_GLLAN_TXPRE_QDIS_CLEAR_QDIS_MASK;
+ 	else
+ 		reg_val |= I40E_GLLAN_TXPRE_QDIS_SET_QDIS_MASK;
+ 
+ 	wr32(hw, I40E_GLLAN_TXPRE_QDIS(reg_block), reg_val);
+ }
+ 
+ /**
++>>>>>>> 1f224ad2f760 (i40e: Add ndo_get_phys_port_id() callback support)
   * i40e_get_media_type - Gets media type
   * @hw: pointer to the hardware structure
   **/
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index b8421d2b483d,1f72eeca00ce..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -8583,7 -8702,10 +8600,14 @@@ static int i40e_probe(struct pci_dev *p
  		goto err_mac_addr;
  	}
  	dev_info(&pdev->dev, "MAC address: %pM\n", hw->mac.addr);
++<<<<<<< HEAD
 +	memcpy(hw->mac.perm_addr, hw->mac.addr, ETH_ALEN);
++=======
+ 	ether_addr_copy(hw->mac.perm_addr, hw->mac.addr);
+ 	i40e_get_port_mac_addr(hw, hw->mac.port_addr);
+ 	if (is_valid_ether_addr(hw->mac.port_addr))
+ 		pf->flags |= I40E_FLAG_PORT_ID_VALID;
++>>>>>>> 1f224ad2f760 (i40e: Add ndo_get_phys_port_id() callback support)
  
  	pci_set_drvdata(pdev, pf);
  	pci_save_state(pdev);
diff --git a/drivers/net/ethernet/intel/i40e/i40e.h b/drivers/net/ethernet/intel/i40e/i40e.h
index 9fd5cbf88c1b..380c7802ae9a 100644
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -267,6 +267,7 @@ struct i40e_pf {
 #ifdef CONFIG_I40E_VXLAN
 #define I40E_FLAG_VXLAN_FILTER_SYNC            (u64)(1 << 27)
 #endif
+#define I40E_FLAG_PORT_ID_VALID                (u64)(1 << 28)
 #define I40E_FLAG_DCB_CAPABLE                  (u64)(1 << 29)
 
 	/* tracks features that get auto disabled by errors */
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_common.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_prototype.h b/drivers/net/ethernet/intel/i40e/i40e_prototype.h
index 1a6e9030a1f0..aa5399347a99 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_prototype.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_prototype.h
@@ -220,8 +220,8 @@ i40e_status i40e_pf_reset(struct i40e_hw *hw);
 void i40e_clear_hw(struct i40e_hw *hw);
 void i40e_clear_pxe_mode(struct i40e_hw *hw);
 bool i40e_get_link_status(struct i40e_hw *hw);
-i40e_status i40e_get_mac_addr(struct i40e_hw *hw,
-						u8 *mac_addr);
+i40e_status i40e_get_mac_addr(struct i40e_hw *hw, u8 *mac_addr);
+i40e_status i40e_get_port_mac_addr(struct i40e_hw *hw, u8 *mac_addr);
 i40e_status i40e_validate_mac_addr(u8 *mac_addr);
 /* prototype for functions used for NVM access */
 i40e_status i40e_init_nvm(struct i40e_hw *hw);
diff --git a/drivers/net/ethernet/intel/i40e/i40e_type.h b/drivers/net/ethernet/intel/i40e/i40e_type.h
index 181a825d3160..5d6b05cd0128 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_type.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_type.h
@@ -232,6 +232,7 @@ struct i40e_mac_info {
 	u8 addr[ETH_ALEN];
 	u8 perm_addr[ETH_ALEN];
 	u8 san_addr[ETH_ALEN];
+	u8 port_addr[ETH_ALEN];
 	u16 max_fcoeq;
 };
 
