KVM: protect kvm_usage_count with its own spinlock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit 4a937f96f3a29c58b7edd349d2e4dfac371efdf2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/4a937f96.failed

The VM list need not be protected by a raw spinlock.  Separate the
two so that kvm_lock can be made non-raw.

	Cc: kvm@vger.kernel.org
	Cc: gleb@redhat.com
	Cc: jan.kiszka@siemens.com
	Reviewed-by: Gleb Natapov <gleb@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 4a937f96f3a29c58b7edd349d2e4dfac371efdf2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	virt/kvm/kvm_main.c
diff --cc virt/kvm/kvm_main.c
index 6d05f4aed965,eb94343c2ed2..000000000000
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@@ -2696,28 -2719,18 +2697,34 @@@ static void hardware_disable_all_nolock
  
  static void hardware_disable_all(void)
  {
++<<<<<<< HEAD
 +	int count;
 +	char count_string[20];
 +	char event_string[] = "EVENT=terminate";
 +	char *envp[] = { event_string, count_string, NULL };
 +
 +	raw_spin_lock(&kvm_lock);
 +	hardware_disable_all_nolock();
 +	count = kvm_usage_count;
 +	raw_spin_unlock(&kvm_lock);
 +
 +	sprintf(count_string, "COUNT=%d", count);
 +	kobject_uevent_env(&kvm_dev.this_device->kobj, KOBJ_CHANGE, envp);
++=======
+ 	raw_spin_lock(&kvm_count_lock);
+ 	hardware_disable_all_nolock();
+ 	raw_spin_unlock(&kvm_count_lock);
++>>>>>>> 4a937f96f3a2 (KVM: protect kvm_usage_count with its own spinlock)
  }
  
  static int hardware_enable_all(void)
  {
  	int r = 0;
 +	int count;
  
- 	raw_spin_lock(&kvm_lock);
+ 	raw_spin_lock(&kvm_count_lock);
  
 -	kvm_usage_count++;
 +	count = ++kvm_usage_count;
  	if (kvm_usage_count == 1) {
  		atomic_set(&hardware_enable_failed, 0);
  		on_each_cpu(hardware_enable_nolock, NULL, 1);
@@@ -2728,16 -2741,8 +2735,16 @@@
  		}
  	}
  
- 	raw_spin_unlock(&kvm_lock);
+ 	raw_spin_unlock(&kvm_count_lock);
  
 +	if (r == 0) {
 +		char count_string[20];
 +		char event_string[] = "EVENT=create";
 +		char *envp[] = { event_string, count_string, NULL };
 +
 +		sprintf(count_string, "COUNT=%d", count);
 +		kobject_uevent_env(&kvm_dev.this_device->kobj, KOBJ_CHANGE, envp);
 +	}
  	return r;
  }
  
diff --git a/Documentation/virtual/kvm/locking.txt b/Documentation/virtual/kvm/locking.txt
index caaf635f5c63..4879975ce3dd 100644
--- a/Documentation/virtual/kvm/locking.txt
+++ b/Documentation/virtual/kvm/locking.txt
@@ -135,7 +135,11 @@ Name:		kvm_lock
 Type:		raw_spinlock
 Arch:		any
 Protects:	- vm_list
-		- hardware virtualization enable/disable
+
+Name:		kvm_count_lock
+Type:		raw_spinlock_t
+Arch:		any
+Protects:	- hardware virtualization enable/disable
 Comment:	'raw' because hardware enabling/disabling must be atomic /wrt
 		migration.
 
* Unmerged path virt/kvm/kvm_main.c
