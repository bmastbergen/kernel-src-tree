qlcnic: Enhance logic to calculate msix vectors.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [ethernet] qlcnic: Enhance logic to calculate msix vectors (Chad Dupuis) [1089352]
Rebuild_FUZZ: 98.95%
commit-author Himanshu Madhani <himanshu.madhani@qlogic.com>
commit cb9327d567be71ae9248d1a9bbc9c274831f5b6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/cb9327d5.failed

o Refactored MSI-x vector calculation for All adapters.
  Decoupled logic in the code which was using same call to
  request MSI-x vectors in default driver load, as well as
  during set_channel() operation for TSS/RSS. This refactoring
  simplifies code for TSS/RSS code path as well as probe path
  of the driver load for all adapters.

	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit cb9327d567be71ae9248d1a9bbc9c274831f5b6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
index 3c9a8d64fa52,e55098f0eeb1..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
@@@ -98,8 -98,24 +98,29 @@@
  #define TX_STOP_THRESH		((MAX_SKB_FRAGS >> 2) + MAX_TSO_HEADER_DESC \
  							+ MGMT_CMD_DESC_RESV)
  #define QLCNIC_MAX_TX_TIMEOUTS	2
++<<<<<<< HEAD
 +#define QLCNIC_MAX_TX_RINGS	8
 +#define QLCNIC_MAX_SDS_RINGS	8
++=======
+ 
+ /* Driver will use 1 Tx ring in INT-x/MSI/SRIOV mode. */
+ #define QLCNIC_SINGLE_RING		1
+ #define QLCNIC_DEF_SDS_RINGS		4
+ #define QLCNIC_DEF_TX_RINGS		4
+ #define QLCNIC_MAX_VNIC_TX_RINGS	4
+ #define QLCNIC_MAX_VNIC_SDS_RINGS	4
+ #define QLCNIC_83XX_MINIMUM_VECTOR	3
+ #define QLCNIC_82XX_MINIMUM_VECTOR	2
+ 
+ enum qlcnic_queue_type {
+ 	QLCNIC_TX_QUEUE = 1,
+ 	QLCNIC_RX_QUEUE,
+ };
+ 
+ /* Operational mode for driver */
+ #define QLCNIC_VNIC_MODE	0xFF
+ #define QLCNIC_DEFAULT_MODE	0x0
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  
  /* Virtual NIC function count */
  #define QLC_DEFAULT_VNIC_COUNT	8
@@@ -1036,7 -1054,16 +1058,20 @@@ struct qlcnic_adapter 
  	u16 max_jumbo_rxd;
  
  	u8 max_rds_rings;
++<<<<<<< HEAD
 +	u8 max_sds_rings;
++=======
+ 
+ 	u8 max_sds_rings; /* max sds rings supported by adapter */
+ 	u8 max_tx_rings;  /* max tx rings supported by adapter */
+ 
+ 	u8 drv_tx_rings;  /* max tx rings supported by driver */
+ 	u8 drv_sds_rings; /* max sds rings supported by driver */
+ 
+ 	u8 drv_tss_rings; /* tss ring input */
+ 	u8 drv_rss_rings; /* rss ring input */
+ 
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  	u8 rx_csum;
  	u8 portnum;
  
@@@ -1559,14 -1575,14 +1594,24 @@@ int qlcnic_loopback_test(struct net_dev
  
  /* Functions from qlcnic_main.c */
  int qlcnic_reset_context(struct qlcnic_adapter *);
++<<<<<<< HEAD
 +void qlcnic_diag_free_res(struct net_device *netdev, int max_sds_rings);
 +int qlcnic_diag_alloc_res(struct net_device *netdev, int test);
 +netdev_tx_t qlcnic_xmit_frame(struct sk_buff *skb, struct net_device *netdev);
 +int qlcnic_set_max_rss(struct qlcnic_adapter *, u8, int);
 +int qlcnic_validate_max_rss(struct qlcnic_adapter *, __u32);
 +int qlcnic_validate_max_tx_rings(struct qlcnic_adapter *, u32 txq);
++=======
+ void qlcnic_diag_free_res(struct net_device *netdev, int);
+ int qlcnic_diag_alloc_res(struct net_device *netdev, int);
+ netdev_tx_t qlcnic_xmit_frame(struct sk_buff *, struct net_device *);
+ void qlcnic_set_tx_ring_count(struct qlcnic_adapter *, u8);
+ void qlcnic_set_sds_ring_count(struct qlcnic_adapter *, u8);
+ int qlcnic_setup_rings(struct qlcnic_adapter *);
+ int qlcnic_validate_rings(struct qlcnic_adapter *, __u32, int);
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  void qlcnic_alloc_lb_filters_mem(struct qlcnic_adapter *adapter);
 +void qlcnic_82xx_set_mac_filter_count(struct qlcnic_adapter *);
  int qlcnic_enable_msix(struct qlcnic_adapter *, u32);
  void qlcnic_set_drv_version(struct qlcnic_adapter *);
  
@@@ -1659,19 -1670,15 +1704,24 @@@ static inline u32 qlcnic_tx_avail(struc
  static inline int qlcnic_set_real_num_queues(struct qlcnic_adapter *adapter,
  					     struct net_device *netdev)
  {
 -	int err;
 +	int err, tx_q;
  
 -	netdev->num_tx_queues = adapter->drv_tx_rings;
 -	netdev->real_num_tx_queues = adapter->drv_tx_rings;
 +	tx_q = adapter->max_drv_tx_rings;
  
 -	err = netif_set_real_num_tx_queues(netdev, adapter->drv_tx_rings);
 +	netdev->num_tx_queues = tx_q;
 +	netdev->real_num_tx_queues = tx_q;
 +
 +	err = netif_set_real_num_tx_queues(netdev, tx_q);
  	if (err)
++<<<<<<< HEAD
 +		dev_err(&adapter->pdev->dev, "failed to set %d Tx queues\n",
 +			tx_q);
 +	else
 +		dev_info(&adapter->pdev->dev, "set %d Tx queues\n", tx_q);
++=======
+ 		netdev_err(netdev, "failed to set %d Tx queues\n",
+ 			   adapter->drv_tx_rings);
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  
  	return err;
  }
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
index f3a48cd31299,4146664d4d6a..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
@@@ -269,31 -290,60 +269,83 @@@ int qlcnic_83xx_wrt_reg_indirect(struc
  	}
  }
  
++<<<<<<< HEAD
 +int qlcnic_83xx_setup_intr(struct qlcnic_adapter *adapter, u8 num_intr, int txq)
++=======
+ static void qlcnic_83xx_enable_legacy(struct qlcnic_adapter *adapter)
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  {
- 	int err, i, num_msix;
  	struct qlcnic_hardware_context *ahw = adapter->ahw;
  
++<<<<<<< HEAD
 +	if (!num_intr)
 +		num_intr = QLCNIC_DEF_NUM_STS_DESC_RINGS;
 +	num_msix = rounddown_pow_of_two(min_t(int, num_online_cpus(),
 +					      num_intr));
++=======
+ 	/* MSI-X enablement failed, use legacy interrupt */
+ 	adapter->tgt_status_reg = ahw->pci_base0 + QLC_83XX_INTX_PTR;
+ 	adapter->tgt_mask_reg = ahw->pci_base0 + QLC_83XX_INTX_MASK;
+ 	adapter->isr_int_vec = ahw->pci_base0 + QLC_83XX_INTX_TRGR;
+ 	adapter->msix_entries[0].vector = adapter->pdev->irq;
+ 	dev_info(&adapter->pdev->dev, "using legacy interrupt\n");
+ }
+ 
+ static int qlcnic_83xx_calculate_msix_vector(struct qlcnic_adapter *adapter)
+ {
+ 	int num_msix;
+ 
+ 	num_msix = adapter->drv_sds_rings;
+ 
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  	/* account for AEN interrupt MSI-X based interrupts */
  	num_msix += 1;
  
  	if (!(adapter->flags & QLCNIC_TX_INTR_SHARED))
 -		num_msix += adapter->drv_tx_rings;
 +		num_msix += adapter->max_drv_tx_rings;
  
++<<<<<<< HEAD
 +	err = qlcnic_enable_msix(adapter, num_msix);
 +	if (err == -ENOMEM)
 +		return err;
 +	if (adapter->flags & QLCNIC_MSIX_ENABLED)
 +		num_msix = adapter->ahw->num_msix;
 +	else {
 +		if (qlcnic_sriov_vf_check(adapter))
 +			return -EINVAL;
 +		num_msix = 1;
++=======
+ 	return num_msix;
+ }
+ 
+ int qlcnic_83xx_setup_intr(struct qlcnic_adapter *adapter)
+ {
+ 	struct qlcnic_hardware_context *ahw = adapter->ahw;
+ 	int err, i, num_msix;
+ 
+ 	if (adapter->flags & QLCNIC_TSS_RSS) {
+ 		err = qlcnic_setup_tss_rss_intr(adapter);
+ 		if (err < 0)
+ 			return err;
+ 		num_msix = ahw->num_msix;
+ 	} else {
+ 		num_msix = qlcnic_83xx_calculate_msix_vector(adapter);
+ 
+ 		err = qlcnic_enable_msix(adapter, num_msix);
+ 		if (err == -ENOMEM)
+ 			return err;
+ 
+ 		if (adapter->flags & QLCNIC_MSIX_ENABLED) {
+ 			num_msix = ahw->num_msix;
+ 		} else {
+ 			if (qlcnic_sriov_vf_check(adapter))
+ 				return -EINVAL;
+ 			num_msix = 1;
+ 			adapter->drv_tx_rings = QLCNIC_SINGLE_RING;
+ 		}
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  	}
+ 
  	/* setup interrupt mapping table for fw */
  	ahw->intr_tbl = vzalloc(num_msix *
  				sizeof(struct qlcnic_intrpt_config));
@@@ -1288,11 -1321,12 +1336,12 @@@ int qlcnic_83xx_create_tx_ctx(struct ql
  	tx->ctx_id = mbx_out->ctx_id;
  	if ((adapter->flags & QLCNIC_MSIX_ENABLED) &&
  	    !(adapter->flags & QLCNIC_TX_INTR_SHARED)) {
 -		intr_mask = ahw->intr_tbl[adapter->drv_sds_rings + ring].src;
 +		intr_mask = ahw->intr_tbl[adapter->max_sds_rings + ring].src;
  		tx->crb_intr_mask = ahw->pci_base0 + intr_mask;
  	}
- 	dev_info(&adapter->pdev->dev, "Tx Context[0x%x] Created, state:0x%x\n",
- 		 tx->ctx_id, mbx_out->state);
+ 	netdev_info(adapter->netdev,
+ 		    "Tx Context[0x%x] Created, state:0x%x\n",
+ 		    tx->ctx_id, mbx_out->state);
  out:
  	qlcnic_free_mbx_args(&cmd);
  	return err;
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
index a39e2b629a03,acee1a5d80c6..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
@@@ -699,22 -723,39 +699,40 @@@ static int qlcnic_set_channels(struct n
  	if (channel->other_count || channel->combined_count)
  		return -EINVAL;
  
 -	err = qlcnic_validate_ring_count(adapter, channel->rx_count,
 -					 channel->tx_count);
 -	if (err)
 -		return err;
 -
  	if (channel->rx_count) {
 -		err = qlcnic_validate_rings(adapter, channel->rx_count,
 -					    QLCNIC_RX_QUEUE);
 -		if (err) {
 -			netdev_err(dev, "Unable to configure %u SDS rings\n",
 -				   channel->rx_count);
 +		err = qlcnic_validate_max_rss(adapter, channel->rx_count);
 +		if (err)
  			return err;
++<<<<<<< HEAD
++=======
+ 		}
+ 		adapter->drv_rss_rings = channel->rx_count;
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  	}
  
 -	if (channel->tx_count) {
 -		err = qlcnic_validate_rings(adapter, channel->tx_count,
 -					    QLCNIC_TX_QUEUE);
 -		if (err) {
 -			netdev_err(dev, "Unable to configure %u Tx rings\n",
 -				   channel->tx_count);
 +	if (qlcnic_82xx_check(adapter) && channel->tx_count) {
 +		err = qlcnic_validate_max_tx_rings(adapter, channel->tx_count);
 +		if (err)
  			return err;
++<<<<<<< HEAD
 +		txq = channel->tx_count;
 +	}
 +
 +	err = qlcnic_set_max_rss(adapter, channel->rx_count, txq);
 +	netdev_info(dev, "allocated 0x%x sds rings and  0x%x tx rings\n",
 +		    adapter->max_sds_rings, adapter->max_drv_tx_rings);
++=======
+ 		}
+ 		adapter->drv_tss_rings = channel->tx_count;
+ 	}
+ 
+ 	adapter->flags |= QLCNIC_TSS_RSS;
+ 
+ 	err = qlcnic_setup_rings(adapter);
+ 	netdev_info(dev, "Allocated %d SDS rings and %d Tx rings\n",
+ 		    adapter->drv_sds_rings, adapter->drv_tx_rings);
+ 
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  	return err;
  }
  
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index ecd8d1df8016,1f79d47c45fa..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@@ -567,19 -576,115 +567,131 @@@ static void qlcnic_get_multiq_capabilit
  	}
  }
  
++<<<<<<< HEAD
 +int qlcnic_enable_msix(struct qlcnic_adapter *adapter, u32 num_msix)
 +{
 +	struct pci_dev *pdev = adapter->pdev;
 +	int max_tx_rings, max_sds_rings, tx_vector;
 +	int err = -1, i;
 +
 +	if (adapter->flags & QLCNIC_TX_INTR_SHARED) {
 +		max_tx_rings = 0;
 +		tx_vector = 0;
 +	} else {
 +		max_tx_rings = adapter->max_drv_tx_rings;
 +		tx_vector = 1;
 +	}
++=======
+ static int qlcnic_max_rings(struct qlcnic_adapter *adapter, u8 ring_cnt,
+ 			    int queue_type)
+ {
+ 	int num_rings, max_rings = QLCNIC_MAX_SDS_RINGS;
+ 
+ 	if (queue_type == QLCNIC_RX_QUEUE)
+ 		max_rings = adapter->max_sds_rings;
+ 	else if (queue_type == QLCNIC_TX_QUEUE)
+ 		max_rings = adapter->max_tx_rings;
+ 
+ 	num_rings = rounddown_pow_of_two(min_t(int, num_online_cpus(),
+ 					      max_rings));
+ 
+ 	if (ring_cnt > num_rings)
+ 		return num_rings;
+ 	else
+ 		return ring_cnt;
+ }
+ 
+ void qlcnic_set_tx_ring_count(struct qlcnic_adapter *adapter, u8 tx_cnt)
+ {
+ 	/* 83xx adapter does not have max_tx_rings intialized in probe */
+ 	if (adapter->max_tx_rings)
+ 		adapter->drv_tx_rings = qlcnic_max_rings(adapter, tx_cnt,
+ 							 QLCNIC_TX_QUEUE);
+ 	else
+ 		adapter->drv_tx_rings = tx_cnt;
+ }
+ 
+ void qlcnic_set_sds_ring_count(struct qlcnic_adapter *adapter, u8 rx_cnt)
+ {
+ 	/* 83xx adapter does not have max_sds_rings intialized in probe */
+ 	if (adapter->max_sds_rings)
+ 		adapter->drv_sds_rings = qlcnic_max_rings(adapter, rx_cnt,
+ 							  QLCNIC_RX_QUEUE);
+ 	else
+ 		adapter->drv_sds_rings = rx_cnt;
+ }
+ 
+ int qlcnic_setup_tss_rss_intr(struct qlcnic_adapter *adapter)
+ {
+ 	struct pci_dev *pdev = adapter->pdev;
+ 	int num_msix = 0, err = 0, vector;
+ 
+ 	adapter->flags &= ~QLCNIC_TSS_RSS;
+ 
+ 	if (adapter->drv_tss_rings > 0)
+ 		num_msix += adapter->drv_tss_rings;
+ 	else
+ 		num_msix += adapter->drv_tx_rings;
+ 
+ 	if (adapter->drv_rss_rings  > 0)
+ 		num_msix += adapter->drv_rss_rings;
+ 	else
+ 		num_msix += adapter->drv_sds_rings;
+ 
+ 	if (qlcnic_83xx_check(adapter))
+ 		num_msix += 1;
+ 
+ 	if (!adapter->msix_entries) {
+ 		adapter->msix_entries = kcalloc(num_msix,
+ 						sizeof(struct msix_entry),
+ 						GFP_KERNEL);
+ 		if (!adapter->msix_entries)
+ 			return -ENOMEM;
+ 	}
+ 
+ restore:
+ 	for (vector = 0; vector < num_msix; vector++)
+ 		adapter->msix_entries[vector].entry = vector;
+ 
+ 	err = pci_enable_msix(pdev, adapter->msix_entries, num_msix);
+ 	if (err == 0) {
+ 		adapter->ahw->num_msix = num_msix;
+ 		if (adapter->drv_tss_rings > 0)
+ 			adapter->drv_tx_rings = adapter->drv_tss_rings;
+ 
+ 		if (adapter->drv_rss_rings > 0)
+ 			adapter->drv_sds_rings = adapter->drv_rss_rings;
+ 	} else {
+ 		netdev_info(adapter->netdev,
+ 			    "Unable to allocate %d MSI-X vectors, Available vectors %d\n",
+ 			    num_msix, err);
+ 
+ 		num_msix = adapter->drv_tx_rings + adapter->drv_sds_rings;
+ 
+ 		/* Set rings to 0 so we can restore original TSS/RSS count */
+ 		adapter->drv_tss_rings = 0;
+ 		adapter->drv_rss_rings = 0;
+ 
+ 		if (qlcnic_83xx_check(adapter))
+ 			num_msix += 1;
+ 
+ 		netdev_info(adapter->netdev,
+ 			    "Restoring %d Tx, %d SDS rings for total %d vectors.\n",
+ 			    adapter->drv_tx_rings, adapter->drv_sds_rings,
+ 			    num_msix);
+ 		goto restore;
+ 
+ 		err = -EIO;
+ 	}
+ 
+ 	return err;
+ }
+ 
+ int qlcnic_enable_msix(struct qlcnic_adapter *adapter, u32 num_msix)
+ {
+ 	struct pci_dev *pdev = adapter->pdev;
+ 	int err = -1, vector;
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  
  	if (!adapter->msix_entries) {
  		adapter->msix_entries = kcalloc(num_msix,
@@@ -589,7 -694,6 +701,10 @@@
  			return -ENOMEM;
  	}
  
++<<<<<<< HEAD
 +	adapter->max_sds_rings = 1;
++=======
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  	adapter->flags &= ~(QLCNIC_MSI_ENABLED | QLCNIC_MSIX_ENABLED);
  
  	if (adapter->ahw->msix_supported) {
@@@ -599,38 -704,33 +715,67 @@@ enable_msix
  		err = pci_enable_msix(pdev, adapter->msix_entries, num_msix);
  		if (err == 0) {
  			adapter->flags |= QLCNIC_MSIX_ENABLED;
++<<<<<<< HEAD
 +			if (qlcnic_83xx_check(adapter)) {
 +				adapter->ahw->num_msix = num_msix;
 +				/* subtract mail box and tx ring vectors */
 +				adapter->max_sds_rings = num_msix -
 +							 max_tx_rings - 1;
 +			} else {
 +				adapter->ahw->num_msix = num_msix;
 +				if (qlcnic_check_multi_tx(adapter) &&
 +				    !adapter->ahw->diag_test &&
 +				    (adapter->max_drv_tx_rings > 1))
 +					max_sds_rings = num_msix - max_tx_rings;
 +				else
 +					max_sds_rings = num_msix;
 +
 +				adapter->max_sds_rings = max_sds_rings;
 +			}
++=======
+ 			adapter->ahw->num_msix = num_msix;
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  			dev_info(&pdev->dev, "using msi-x interrupts\n");
  			return err;
  		} else if (err > 0) {
  			dev_info(&pdev->dev,
++<<<<<<< HEAD
 +				 "Unable to allocate %d MSI-X interrupt vectors\n",
 +				 num_msix);
 +			if (qlcnic_83xx_check(adapter)) {
 +				if (err < (QLC_83XX_MINIMUM_VECTOR - tx_vector))
 +					return err;
 +				err -= (max_tx_rings + 1);
 +				num_msix = rounddown_pow_of_two(err);
 +				num_msix += (max_tx_rings + 1);
 +			} else {
 +				num_msix = rounddown_pow_of_two(err);
 +				if (qlcnic_check_multi_tx(adapter))
 +					num_msix += max_tx_rings;
++=======
+ 				 "Unable to allocate %d MSI-X vectors, Available vectors %d\n",
+ 				 num_msix, err);
+ 
+ 			if (qlcnic_82xx_check(adapter)) {
+ 				num_msix = rounddown_pow_of_two(err);
+ 				if (err < QLCNIC_82XX_MINIMUM_VECTOR)
+ 					return -EIO;
+ 			} else {
+ 				num_msix = rounddown_pow_of_two(err - 1);
+ 				num_msix += 1;
+ 				if (err < QLCNIC_83XX_MINIMUM_VECTOR)
+ 					return -EIO;
+ 			}
+ 
+ 			if (qlcnic_82xx_check(adapter) &&
+ 			    !qlcnic_check_multi_tx(adapter)) {
+ 				adapter->drv_sds_rings = num_msix;
+ 				adapter->drv_tx_rings = QLCNIC_SINGLE_RING;
+ 			} else {
+ 				/* Distribute vectors equally */
+ 				adapter->drv_tx_rings = num_msix / 2;
+ 				adapter->drv_sds_rings = adapter->drv_tx_rings;
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  			}
  
  			if (num_msix) {
@@@ -683,36 -798,29 +843,57 @@@ static int qlcnic_enable_msi_legacy(str
  	return err;
  }
  
 -static int qlcnic_82xx_setup_intr(struct qlcnic_adapter *adapter)
 +int qlcnic_82xx_setup_intr(struct qlcnic_adapter *adapter, u8 num_intr, int txq)
  {
 +	struct qlcnic_hardware_context *ahw = adapter->ahw;
  	int num_msix, err = 0;
  
++<<<<<<< HEAD
 +	if (!num_intr)
 +		num_intr = QLCNIC_DEF_NUM_STS_DESC_RINGS;
 +
 +	if (ahw->msix_supported) {
 +		num_msix = rounddown_pow_of_two(min_t(int, num_online_cpus(),
 +						num_intr));
 +		if (qlcnic_check_multi_tx(adapter)) {
 +			if (txq)
 +				adapter->max_drv_tx_rings = txq;
 +			num_msix += adapter->max_drv_tx_rings;
 +		}
 +	} else {
 +		num_msix = 1;
 +	}
 +
 +	err = qlcnic_enable_msix(adapter, num_msix);
 +	if (err == -ENOMEM)
 +		return err;
 +
 +	if (!(adapter->flags & QLCNIC_MSIX_ENABLED)) {
 +		qlcnic_disable_multi_tx(adapter);
 +
 +		err = qlcnic_enable_msi_legacy(adapter);
 +		if (!err)
++=======
+ 	if (adapter->flags & QLCNIC_TSS_RSS) {
+ 		err = qlcnic_setup_tss_rss_intr(adapter);
+ 		if (err < 0)
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  			return err;
+ 		num_msix = adapter->ahw->num_msix;
+ 	} else {
+ 		num_msix = qlcnic_82xx_calculate_msix_vector(adapter);
+ 
+ 		err = qlcnic_enable_msix(adapter, num_msix);
+ 		if (err == -ENOMEM)
+ 			return err;
+ 
+ 		if (!(adapter->flags & QLCNIC_MSIX_ENABLED)) {
+ 			qlcnic_disable_multi_tx(adapter);
+ 
+ 			err = qlcnic_enable_msi_legacy(adapter);
+ 			if (!err)
+ 				return err;
+ 		}
  	}
  
  	return 0;
@@@ -3698,24 -3884,16 +3879,28 @@@ int qlcnic_validate_max_tx_rings(struc
  		return -EINVAL;
  	}
  
 -	if (qlcnic_82xx_check(adapter) && (queue_type == QLCNIC_TX_QUEUE) &&
 -	    !qlcnic_check_multi_tx(adapter)) {
 -			netdev_err(netdev, "No Multi Tx queue support\n");
 -			return -EINVAL;
 +	return 0;
 +}
 +
++<<<<<<< HEAD
 +int qlcnic_validate_max_rss(struct qlcnic_adapter *adapter,
 +				__u32 val)
++=======
++int qlcnic_setup_rings(struct qlcnic_adapter *adapter)
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
 +{
 +	struct net_device *netdev = adapter->netdev;
 +	u8 max_hw = adapter->ahw->max_rx_ques;
 +	u32 max_allowed;
 +
 +	if (!qlcnic_use_msi_x && !qlcnic_use_msi) {
 +		netdev_err(netdev, "No RSS support in INT-x mode\n");
 +		return -EINVAL;
  	}
  
 -	if (ring_cnt > num_online_cpus()) {
 -		netdev_err(netdev,
 -			   "%s value[%u] should not be higher than, number of online CPUs\n",
 -			   buf, num_online_cpus());
 +	if (val > QLCNIC_MAX_SDS_RINGS) {
 +		netdev_err(netdev, "RSS value should not be higher than %u\n",
 +			   QLCNIC_MAX_SDS_RINGS);
  		return -EINVAL;
  	}
  
@@@ -3782,11 -3919,9 +3967,15 @@@ int qlcnic_set_max_rss(struct qlcnic_ad
  		qlcnic_83xx_enable_mbx_poll(adapter);
  	}
  
 +	netif_set_real_num_tx_queues(netdev, adapter->max_drv_tx_rings);
 +
  	qlcnic_teardown_intr(adapter);
  
++<<<<<<< HEAD
 +	err = qlcnic_setup_intr(adapter, data, txq);
++=======
+ 	err = qlcnic_setup_intr(adapter);
++>>>>>>> cb9327d567be (qlcnic: Enhance logic to calculate msix vectors.)
  	if (err) {
  		kfree(adapter->msix_entries);
  		netdev_err(netdev, "failed to setup interrupt\n");
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
