netfilter: nf_tables: simplify set dump through netlink

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 5b96af7713546fca812682fed13cfad26d69fed7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5b96af77.failed

This patch uses the cb->data pointer that allows us to store the
context when dumping the set list. Thus, we don't need to parse the
original netlink message containing the dump request for each recvmsg()
call when dumping the set list. The different function flavours
depending on the dump criteria has been also merged into one single
generic function. This saves us ~100 lines of code.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 5b96af7713546fca812682fed13cfad26d69fed7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_tables_api.c
diff --cc net/netfilter/nf_tables_api.c
index cf269ea5d6aa,ecffb26e2f20..000000000000
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@@ -2241,74 -2247,7 +2241,78 @@@ err
  	return err;
  }
  
++<<<<<<< HEAD
 +static int nf_tables_dump_sets_table(struct nft_ctx *ctx, struct sk_buff *skb,
 +				     struct netlink_callback *cb)
 +{
 +	const struct nft_set *set;
 +	unsigned int idx = 0, s_idx = cb->args[0];
 +
 +	if (cb->args[1])
 +		return skb->len;
 +
 +	rcu_read_lock();
 +	list_for_each_entry_rcu(set, &ctx->table->sets, list) {
 +		if (idx < s_idx)
 +			goto cont;
 +		if (nf_tables_fill_set(skb, ctx, set, NFT_MSG_NEWSET,
 +				       NLM_F_MULTI) < 0) {
 +			cb->args[0] = idx;
 +			goto done;
 +		}
 +cont:
 +		idx++;
 +	}
 +	cb->args[1] = 1;
 +done:
 +	rcu_read_unlock();
 +	return skb->len;
 +}
 +
 +static int nf_tables_dump_sets_family(struct nft_ctx *ctx, struct sk_buff *skb,
 +				      struct netlink_callback *cb)
 +{
 +	const struct nft_set *set;
 +	unsigned int idx, s_idx = cb->args[0];
 +	struct nft_table *table, *cur_table = (struct nft_table *)cb->args[2];
 +
 +	if (cb->args[1])
 +		return skb->len;
 +
 +	rcu_read_lock();
 +	list_for_each_entry_rcu(table, &ctx->afi->tables, list) {
 +		if (cur_table) {
 +			if (cur_table != table)
 +				continue;
 +
 +			cur_table = NULL;
 +		}
 +		ctx->table = table;
 +		idx = 0;
 +		list_for_each_entry_rcu(set, &ctx->table->sets, list) {
 +			if (idx < s_idx)
 +				goto cont;
 +			if (nf_tables_fill_set(skb, ctx, set, NFT_MSG_NEWSET,
 +					       NLM_F_MULTI) < 0) {
 +				cb->args[0] = idx;
 +				cb->args[2] = (unsigned long) table;
 +				goto done;
 +			}
 +cont:
 +			idx++;
 +		}
 +	}
 +	cb->args[1] = 1;
 +done:
 +	rcu_read_unlock();
 +	return skb->len;
 +}
 +
 +static int nf_tables_dump_sets_all(struct nft_ctx *ctx, struct sk_buff *skb,
 +				   struct netlink_callback *cb)
++=======
+ static int nf_tables_dump_sets(struct sk_buff *skb, struct netlink_callback *cb)
++>>>>>>> 5b96af771354 (netfilter: nf_tables: simplify set dump through netlink)
  {
  	const struct nft_set *set;
  	unsigned int idx, s_idx = cb->args[0];
@@@ -2321,7 -2261,12 +2326,10 @@@
  		return skb->len;
  
  	rcu_read_lock();
 -	cb->seq = net->nft.base_seq;
 -
  	list_for_each_entry_rcu(afi, &net->nft.af_info, list) {
+ 		if (ctx->afi && ctx->afi != afi)
+ 			continue;
+ 
  		if (cur_family) {
  			if (afi->family != cur_family)
  				continue;
* Unmerged path net/netfilter/nf_tables_api.c
