ceph: skip invalid dentry during dcache readdir

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Yan, Zheng <zheng.z.yan@intel.com>
commit a30be7cb2ccb995ad5e67fd4b548f11fe37fc8b1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a30be7cb.failed

skip dentries that were added before MDS issued FILE_SHARED to
client.

	Signed-off-by: Yan, Zheng <zheng.z.yan@intel.com>
	Reviewed-by: Sage Weil <sage@inktank.com>
(cherry picked from commit a30be7cb2ccb995ad5e67fd4b548f11fe37fc8b1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/dir.c
diff --cc fs/ceph/dir.c
index 9c6549f6a540,766410a12c2c..000000000000
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@@ -111,11 -119,11 +111,16 @@@ static unsigned fpos_off(loff_t p
   * defined IFF we hold CEPH_CAP_FILE_SHARED (which will be revoked by
   * the MDS if/when the directory is modified).
   */
++<<<<<<< HEAD
 +static int __dcache_readdir(struct file *filp,
 +			    void *dirent, filldir_t filldir)
++=======
+ static int __dcache_readdir(struct file *file,  struct dir_context *ctx,
+ 			    u32 shared_gen)
++>>>>>>> a30be7cb2ccb (ceph: skip invalid dentry during dcache readdir)
  {
 -	struct ceph_file_info *fi = file->private_data;
 -	struct dentry *parent = file->f_dentry;
 +	struct ceph_file_info *fi = filp->private_data;
 +	struct dentry *parent = filp->f_dentry;
  	struct inode *dir = parent->d_inode;
  	struct list_head *p;
  	struct dentry *dentry, *last;
@@@ -126,8 -134,8 +131,13 @@@
  	last = fi->dentry;
  	fi->dentry = NULL;
  
++<<<<<<< HEAD
 +	dout("__dcache_readdir %p at %llu (last %p)\n", dir, filp->f_pos,
 +	     last);
++=======
+ 	dout("__dcache_readdir %p v%u at %llu (last %p)\n",
+ 	     dir, shared_gen, ctx->pos, last);
++>>>>>>> a30be7cb2ccb (ceph: skip invalid dentry during dcache readdir)
  
  	spin_lock(&parent->d_lock);
  
@@@ -154,10 -162,11 +164,11 @@@ more
  			goto out_unlock;
  		}
  		spin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED);
- 		if (!d_unhashed(dentry) && dentry->d_inode &&
+ 		if (di->lease_shared_gen == shared_gen &&
+ 		    !d_unhashed(dentry) && dentry->d_inode &&
  		    ceph_snap(dentry->d_inode) != CEPH_SNAPDIR &&
  		    ceph_ino(dentry->d_inode) != CEPH_INO_CEPH &&
 -		    fpos_cmp(ctx->pos, di->offset) <= 0)
 +		    filp->f_pos <= di->offset)
  			break;
  		dout(" skipping %p %.*s at %llu (%llu)%s%s\n", dentry,
  		     dentry->d_name.len, dentry->d_name.name, di->offset,
@@@ -284,8 -291,9 +295,13 @@@ static int ceph_readdir(struct file *fi
  	    ceph_snap(inode) != CEPH_SNAPDIR &&
  	    __ceph_dir_is_complete(ci) &&
  	    __ceph_caps_issued_mask(ci, CEPH_CAP_FILE_SHARED, 1)) {
+ 		u32 shared_gen = ci->i_shared_gen;
  		spin_unlock(&ci->i_ceph_lock);
++<<<<<<< HEAD
 +		err = __dcache_readdir(filp, dirent, filldir);
++=======
+ 		err = __dcache_readdir(file, ctx, shared_gen);
++>>>>>>> a30be7cb2ccb (ceph: skip invalid dentry during dcache readdir)
  		if (err != -EAGAIN)
  			return err;
  	} else {
* Unmerged path fs/ceph/dir.c
