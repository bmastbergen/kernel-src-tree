KVM: PPC: Book3S HV: Prepare for host using hypervisor doorbells

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/ppc: book3s hv - Prepare for host using hypervisor doorbells (Don Zickus) [1127366]
Rebuild_FUZZ: 95.31%
commit-author Paul Mackerras <paulus@samba.org>
commit 5d00f66b865e3782c5852cdafe1cea11a292a81e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5d00f66b.failed

POWER8 has support for hypervisor doorbell interrupts.  Though the
kernel doesn't use them for IPIs on the powernv platform yet, it
probably will in future, so this makes KVM cope gracefully if a
hypervisor doorbell interrupt arrives while in a guest.

	Signed-off-by: Paul Mackerras <paulus@samba.org>
	Signed-off-by: Alexander Graf <agraf@suse.de>
(cherry picked from commit 5d00f66b865e3782c5852cdafe1cea11a292a81e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_hv_rmhandlers.S
diff --cc arch/powerpc/kvm/book3s_hv_rmhandlers.S
index 4e71b0446184,eae4ab9b9135..000000000000
--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S
+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S
@@@ -1819,6 -1971,44 +1819,47 @@@ machine_check_realmode
  	b	fast_interrupt_c_return
  
  /*
++<<<<<<< HEAD
++=======
+  * Check the reason we woke from nap, and take appropriate action.
+  * Returns:
+  *	0 if nothing needs to be done
+  *	1 if something happened that needs to be handled by the host
+  *	-1 if there was a guest wakeup (IPI)
+  *
+  * Also sets r12 to the interrupt vector for any interrupt that needs
+  * to be handled now by the host (0x500 for external interrupt), or zero.
+  */
+ kvmppc_check_wake_reason:
+ 	mfspr	r6, SPRN_SRR1
+ BEGIN_FTR_SECTION
+ 	rlwinm	r6, r6, 45-31, 0xf	/* extract wake reason field (P8) */
+ FTR_SECTION_ELSE
+ 	rlwinm	r6, r6, 45-31, 0xe	/* P7 wake reason field is 3 bits */
+ ALT_FTR_SECTION_END_IFSET(CPU_FTR_ARCH_207S)
+ 	cmpwi	r6, 8			/* was it an external interrupt? */
+ 	li	r12, BOOK3S_INTERRUPT_EXTERNAL
+ 	beq	kvmppc_read_intr	/* if so, see what it was */
+ 	li	r3, 0
+ 	li	r12, 0
+ 	cmpwi	r6, 6			/* was it the decrementer? */
+ 	beq	0f
+ BEGIN_FTR_SECTION
+ 	cmpwi	r6, 5			/* privileged doorbell? */
+ 	beq	0f
+ 	cmpwi	r6, 3			/* hypervisor doorbell? */
+ 	beq	3f
+ END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
+ 	li	r3, 1			/* anything else, return 1 */
+ 0:	blr
+ 
+ 	/* hypervisor doorbell */
+ 3:	li	r12, BOOK3S_INTERRUPT_H_DOORBELL
+ 	li	r3, 1
+ 	blr
+ 
+ /*
++>>>>>>> 5d00f66b865e (KVM: PPC: Book3S HV: Prepare for host using hypervisor doorbells)
   * Determine what sort of external interrupt is pending (if any).
   * Returns:
   *	0 if no interrupt is pending
diff --git a/arch/powerpc/include/asm/kvm_asm.h b/arch/powerpc/include/asm/kvm_asm.h
index dba8fb244100..c3815b1e79e8 100644
--- a/arch/powerpc/include/asm/kvm_asm.h
+++ b/arch/powerpc/include/asm/kvm_asm.h
@@ -96,6 +96,7 @@
 #define BOOK3S_INTERRUPT_H_DATA_STORAGE	0xe00
 #define BOOK3S_INTERRUPT_H_INST_STORAGE	0xe20
 #define BOOK3S_INTERRUPT_H_EMUL_ASSIST	0xe40
+#define BOOK3S_INTERRUPT_H_DOORBELL	0xe80
 #define BOOK3S_INTERRUPT_PERFMON	0xf00
 #define BOOK3S_INTERRUPT_ALTIVEC	0xf20
 #define BOOK3S_INTERRUPT_VSX		0xf40
diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c
index bd4792543205..4bd74f49a656 100644
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@ -648,6 +648,7 @@ static int kvmppc_handle_exit(struct kvm_run *run, struct kvm_vcpu *vcpu,
 		r = RESUME_GUEST;
 		break;
 	case BOOK3S_INTERRUPT_EXTERNAL:
+	case BOOK3S_INTERRUPT_H_DOORBELL:
 		vcpu->stat.ext_intr_exits++;
 		r = RESUME_GUEST;
 		break;
* Unmerged path arch/powerpc/kvm/book3s_hv_rmhandlers.S
