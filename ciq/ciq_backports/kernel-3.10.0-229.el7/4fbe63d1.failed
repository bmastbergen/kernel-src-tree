netlabel: shorter names for the NetLabel catmap funcs/structs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Paul Moore <pmoore@redhat.com>
commit 4fbe63d1c773cceef3fe1f6ed0c9c268f4f24760
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/4fbe63d1.failed

Historically the NetLabel LSM secattr catmap functions and data
structures have had very long names which makes a mess of the NetLabel
code and anyone who uses NetLabel.  This patch renames the catmap
functions and structures from "*_secattr_catmap_*" to just "*_catmap_*"
which improves things greatly.

There are no substantial code or logic changes in this patch.

	Signed-off-by: Paul Moore <pmoore@redhat.com>
	Tested-by: Casey Schaufler <casey@schaufler-ca.com>
(cherry picked from commit 4fbe63d1c773cceef3fe1f6ed0c9c268f4f24760)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netlabel.h
#	net/netlabel/netlabel_kapi.c
#	security/selinux/ss/ebitmap.c
#	security/smack/smack_lsm.c
diff --cc include/net/netlabel.h
index 28400bdc6189,a4fc39bb3e4f..000000000000
--- a/include/net/netlabel.h
+++ b/include/net/netlabel.h
@@@ -281,12 -279,11 +280,11 @@@ static inline struct netlbl_lsm_catmap 
   * Free a LSM secattr catmap.
   *
   */
- static inline void netlbl_secattr_catmap_free(
- 	                              struct netlbl_lsm_secattr_catmap *catmap)
+ static inline void netlbl_catmap_free(struct netlbl_lsm_catmap *catmap)
  {
- 	struct netlbl_lsm_secattr_catmap *iter;
+ 	struct netlbl_lsm_catmap *iter;
  
 -	while (catmap) {
 +	do {
  		iter = catmap;
  		catmap = catmap->next;
  		kfree(iter);
@@@ -391,17 -388,22 +389,36 @@@ int netlbl_cfg_cipsov4_map_add(u32 doi
  /*
   * LSM security attribute operations
   */
++<<<<<<< HEAD
 +int netlbl_secattr_catmap_walk(struct netlbl_lsm_secattr_catmap *catmap,
 +			       u32 offset);
 +int netlbl_secattr_catmap_walk_rng(struct netlbl_lsm_secattr_catmap *catmap,
 +				   u32 offset);
 +int netlbl_secattr_catmap_setbit(struct netlbl_lsm_secattr_catmap **catmap,
 +				 u32 bit,
 +				 gfp_t flags);
 +int netlbl_secattr_catmap_setrng(struct netlbl_lsm_secattr_catmap **catmap,
 +				 u32 start,
 +				 u32 end,
 +				 gfp_t flags);
++=======
+ int netlbl_catmap_walk(struct netlbl_lsm_catmap *catmap, u32 offset);
+ int netlbl_catmap_walkrng(struct netlbl_lsm_catmap *catmap, u32 offset);
+ int netlbl_catmap_getlong(struct netlbl_lsm_catmap *catmap,
+ 			  u32 *offset,
+ 			  unsigned long *bitmap);
+ int netlbl_catmap_setbit(struct netlbl_lsm_catmap **catmap,
+ 			 u32 bit,
+ 			 gfp_t flags);
+ int netlbl_catmap_setrng(struct netlbl_lsm_catmap **catmap,
+ 			 u32 start,
+ 			 u32 end,
+ 			 gfp_t flags);
+ int netlbl_catmap_setlong(struct netlbl_lsm_catmap **catmap,
+ 			  u32 offset,
+ 			  unsigned long bitmap,
+ 			  gfp_t flags);
++>>>>>>> 4fbe63d1c773 (netlabel: shorter names for the NetLabel catmap funcs/structs)
  
  /*
   * LSM protocol operations (NetLabel LSM/kernel API)
@@@ -505,21 -505,32 +520,42 @@@ static inline int netlbl_catmap_walkrng
  {
  	return -ENOENT;
  }
++<<<<<<< HEAD
 +static inline int netlbl_secattr_catmap_setbit(
 +				      struct netlbl_lsm_secattr_catmap **catmap,
 +				      u32 bit,
 +				      gfp_t flags)
++=======
+ static inline int netlbl_catmap_getlong(struct netlbl_lsm_catmap *catmap,
+ 					u32 *offset,
+ 					unsigned long *bitmap)
  {
  	return 0;
  }
- static inline int netlbl_secattr_catmap_setrng(
- 				      struct netlbl_lsm_secattr_catmap **catmap,
- 				      u32 start,
- 				      u32 end,
- 				      gfp_t flags)
+ static inline int netlbl_catmap_setbit(struct netlbl_lsm_catmap **catmap,
+ 				       u32 bit,
+ 				       gfp_t flags)
++>>>>>>> 4fbe63d1c773 (netlabel: shorter names for the NetLabel catmap funcs/structs)
+ {
+ 	return 0;
+ }
+ static inline int netlbl_catmap_setrng(struct netlbl_lsm_catmap **catmap,
+ 				       u32 start,
+ 				       u32 end,
+ 				       gfp_t flags)
+ {
+ 	return 0;
+ }
++<<<<<<< HEAD
++=======
+ static int netlbl_catmap_setlong(struct netlbl_lsm_catmap **catmap,
+ 				 u32 offset,
+ 				 unsigned long bitmap,
+ 				 gfp_t flags)
  {
  	return 0;
  }
++>>>>>>> 4fbe63d1c773 (netlabel: shorter names for the NetLabel catmap funcs/structs)
  static inline int netlbl_enabled(void)
  {
  	return 0;
diff --cc net/netlabel/netlabel_kapi.c
index 82c7fca7f619,05ea4a4cc0ac..000000000000
--- a/net/netlabel/netlabel_kapi.c
+++ b/net/netlabel/netlabel_kapi.c
@@@ -406,8 -405,72 +406,75 @@@ out_entry
   * Security Attribute Functions
   */
  
++<<<<<<< HEAD
++=======
+ #define _CM_F_NONE	0x00000000
+ #define _CM_F_ALLOC	0x00000001
+ #define _CM_F_WALK	0x00000002
+ 
  /**
-  * netlbl_secattr_catmap_walk - Walk a LSM secattr catmap looking for a bit
+  * _netlbl_catmap_getnode - Get a individual node from a catmap
+  * @catmap: pointer to the category bitmap
+  * @offset: the requested offset
+  * @cm_flags: catmap flags, see _CM_F_*
+  * @gfp_flags: memory allocation flags
+  *
+  * Description:
+  * Iterate through the catmap looking for the node associated with @offset.
+  * If the _CM_F_ALLOC flag is set in @cm_flags and there is no associated node,
+  * one will be created and inserted into the catmap.  If the _CM_F_WALK flag is
+  * set in @cm_flags and there is no associated node, the next highest node will
+  * be returned.  Returns a pointer to the node on success, NULL on failure.
+  *
+  */
+ static struct netlbl_lsm_catmap *_netlbl_catmap_getnode(
+ 					     struct netlbl_lsm_catmap **catmap,
+ 					     u32 offset,
+ 					     unsigned int cm_flags,
+ 					     gfp_t gfp_flags)
+ {
+ 	struct netlbl_lsm_catmap *iter = *catmap;
+ 	struct netlbl_lsm_catmap *prev = NULL;
+ 
+ 	if (iter == NULL)
+ 		goto catmap_getnode_alloc;
+ 	if (offset < iter->startbit)
+ 		goto catmap_getnode_walk;
+ 	while (iter && offset >= (iter->startbit + NETLBL_CATMAP_SIZE)) {
+ 		prev = iter;
+ 		iter = iter->next;
+ 	}
+ 	if (iter == NULL || offset < iter->startbit)
+ 		goto catmap_getnode_walk;
+ 
+ 	return iter;
+ 
+ catmap_getnode_walk:
+ 	if (cm_flags & _CM_F_WALK)
+ 		return iter;
+ catmap_getnode_alloc:
+ 	if (!(cm_flags & _CM_F_ALLOC))
+ 		return NULL;
+ 
+ 	iter = netlbl_catmap_alloc(gfp_flags);
+ 	if (iter == NULL)
+ 		return NULL;
+ 	iter->startbit = offset & ~(NETLBL_CATMAP_SIZE - 1);
+ 
+ 	if (prev == NULL) {
+ 		iter->next = *catmap;
+ 		*catmap = iter;
+ 	} else {
+ 		iter->next = prev->next;
+ 		prev->next = iter;
+ 	}
+ 
+ 	return iter;
+ }
+ 
++>>>>>>> 4fbe63d1c773 (netlabel: shorter names for the NetLabel catmap funcs/structs)
+ /**
+  * netlbl_catmap_walk - Walk a LSM secattr catmap looking for a bit
   * @catmap: the category bitmap
   * @offset: the offset to start searching at, in bits
   *
@@@ -416,28 -479,25 +483,38 @@@
   * returns the spot of the first set bit or -ENOENT if no bits are set.
   *
   */
- int netlbl_secattr_catmap_walk(struct netlbl_lsm_secattr_catmap *catmap,
- 			       u32 offset)
+ int netlbl_catmap_walk(struct netlbl_lsm_catmap *catmap, u32 offset)
  {
++<<<<<<< HEAD
 +	struct netlbl_lsm_secattr_catmap *iter = catmap;
 +	u32 node_idx;
 +	u32 node_bit;
 +	NETLBL_CATMAP_MAPTYPE bitmap;
 +
++=======
+ 	struct netlbl_lsm_catmap *iter = catmap;
+ 	u32 idx;
+ 	u32 bit;
+ 	NETLBL_CATMAP_MAPTYPE bitmap;
+ 
+ 	iter = _netlbl_catmap_getnode(&catmap, offset, _CM_F_WALK, 0);
+ 	if (iter == NULL)
+ 		return -ENOENT;
++>>>>>>> 4fbe63d1c773 (netlabel: shorter names for the NetLabel catmap funcs/structs)
  	if (offset > iter->startbit) {
 -		offset -= iter->startbit;
 -		idx = offset / NETLBL_CATMAP_MAPSIZE;
 -		bit = offset % NETLBL_CATMAP_MAPSIZE;
 +		while (offset >= (iter->startbit + NETLBL_CATMAP_SIZE)) {
 +			iter = iter->next;
 +			if (iter == NULL)
 +				return -ENOENT;
 +		}
 +		node_idx = (offset - iter->startbit) / NETLBL_CATMAP_MAPSIZE;
 +		node_bit = offset - iter->startbit -
 +			   (NETLBL_CATMAP_MAPSIZE * node_idx);
  	} else {
 -		idx = 0;
 -		bit = 0;
 +		node_idx = 0;
 +		node_bit = 0;
  	}
 -	bitmap = iter->bitmap[idx] >> bit;
 +	bitmap = iter->bitmap[node_idx] >> node_bit;
  
  	for (;;) {
  		if (bitmap != 0) {
@@@ -473,56 -533,104 +550,120 @@@
   * the end of the bitmap.
   *
   */
- int netlbl_secattr_catmap_walk_rng(struct netlbl_lsm_secattr_catmap *catmap,
- 				   u32 offset)
+ int netlbl_catmap_walkrng(struct netlbl_lsm_catmap *catmap, u32 offset)
  {
++<<<<<<< HEAD
 +	struct netlbl_lsm_secattr_catmap *iter = catmap;
 +	u32 node_idx;
 +	u32 node_bit;
 +	NETLBL_CATMAP_MAPTYPE bitmask;
 +	NETLBL_CATMAP_MAPTYPE bitmap;
 +
++=======
+ 	struct netlbl_lsm_catmap *iter;
+ 	struct netlbl_lsm_catmap *prev = NULL;
+ 	u32 idx;
+ 	u32 bit;
+ 	NETLBL_CATMAP_MAPTYPE bitmask;
+ 	NETLBL_CATMAP_MAPTYPE bitmap;
+ 
+ 	iter = _netlbl_catmap_getnode(&catmap, offset, _CM_F_WALK, 0);
+ 	if (iter == NULL)
+ 		return -ENOENT;
++>>>>>>> 4fbe63d1c773 (netlabel: shorter names for the NetLabel catmap funcs/structs)
  	if (offset > iter->startbit) {
 -		offset -= iter->startbit;
 -		idx = offset / NETLBL_CATMAP_MAPSIZE;
 -		bit = offset % NETLBL_CATMAP_MAPSIZE;
 +		while (offset >= (iter->startbit + NETLBL_CATMAP_SIZE)) {
 +			iter = iter->next;
 +			if (iter == NULL)
 +				return -ENOENT;
 +		}
 +		node_idx = (offset - iter->startbit) / NETLBL_CATMAP_MAPSIZE;
 +		node_bit = offset - iter->startbit -
 +			   (NETLBL_CATMAP_MAPSIZE * node_idx);
  	} else {
 -		idx = 0;
 -		bit = 0;
 +		node_idx = 0;
 +		node_bit = 0;
  	}
 -	bitmask = NETLBL_CATMAP_BIT << bit;
 +	bitmask = NETLBL_CATMAP_BIT << node_bit;
  
  	for (;;) {
 -		bitmap = iter->bitmap[idx];
 +		bitmap = iter->bitmap[node_idx];
  		while (bitmask != 0 && (bitmap & bitmask) != 0) {
  			bitmask <<= 1;
 -			bit++;
 +			node_bit++;
  		}
  
 -		if (prev && idx == 0 && bit == 0)
 -			return prev->startbit + NETLBL_CATMAP_SIZE - 1;
 -		else if (bitmask != 0)
 +		if (bitmask != 0)
  			return iter->startbit +
 -				(NETLBL_CATMAP_MAPSIZE * idx) + bit - 1;
 -		else if (++idx >= NETLBL_CATMAP_MAPCNT) {
 +				(NETLBL_CATMAP_MAPSIZE * node_idx) +
 +				node_bit - 1;
 +		else if (++node_idx >= NETLBL_CATMAP_MAPCNT) {
  			if (iter->next == NULL)
 -				return iter->startbit + NETLBL_CATMAP_SIZE - 1;
 -			prev = iter;
 +				return iter->startbit +	NETLBL_CATMAP_SIZE - 1;
  			iter = iter->next;
 -			idx = 0;
 +			node_idx = 0;
  		}
  		bitmask = NETLBL_CATMAP_BIT;
 -		bit = 0;
 +		node_bit = 0;
  	}
  
  	return -ENOENT;
  }
  
  /**
++<<<<<<< HEAD
 + * netlbl_secattr_catmap_setbit - Set a bit in a LSM secattr catmap
++=======
+  * netlbl_catmap_getlong - Export an unsigned long bitmap
+  * @catmap: pointer to the category bitmap
+  * @offset: pointer to the requested offset
+  * @bitmap: the exported bitmap
+  *
+  * Description:
+  * Export a bitmap with an offset greater than or equal to @offset and return
+  * it in @bitmap.  The @offset must be aligned to an unsigned long and will be
+  * updated on return if different from what was requested; if the catmap is
+  * empty at the requested offset and beyond, the @offset is set to (u32)-1.
+  * Returns zero on sucess, negative values on failure.
+  *
+  */
+ int netlbl_catmap_getlong(struct netlbl_lsm_catmap *catmap,
+ 			  u32 *offset,
+ 			  unsigned long *bitmap)
+ {
+ 	struct netlbl_lsm_catmap *iter;
+ 	u32 off = *offset;
+ 	u32 idx;
+ 
+ 	/* only allow aligned offsets */
+ 	if ((off & (BITS_PER_LONG - 1)) != 0)
+ 		return -EINVAL;
+ 
+ 	if (off < catmap->startbit) {
+ 		off = catmap->startbit;
+ 		*offset = off;
+ 	}
+ 	iter = _netlbl_catmap_getnode(&catmap, off, _CM_F_NONE, 0);
+ 	if (iter == NULL) {
+ 		*offset = (u32)-1;
+ 		return 0;
+ 	}
+ 
+ 	if (off < iter->startbit) {
+ 		off = iter->startbit;
+ 		*offset = off;
+ 	} else
+ 		off -= iter->startbit;
+ 
+ 	idx = off / NETLBL_CATMAP_MAPSIZE;
+ 	*bitmap = iter->bitmap[idx] >> (off % NETLBL_CATMAP_SIZE);
+ 
+ 	return 0;
+ }
+ 
+ /**
+  * netlbl_catmap_setbit - Set a bit in a LSM secattr catmap
++>>>>>>> 4fbe63d1c773 (netlabel: shorter names for the NetLabel catmap funcs/structs)
   * @catmap: pointer to the category bitmap
   * @bit: the bit to set
   * @flags: memory allocation flags
@@@ -532,36 -640,20 +673,45 @@@
   * negative values on failure.
   *
   */
- int netlbl_secattr_catmap_setbit(struct netlbl_lsm_secattr_catmap **catmap,
- 				 u32 bit,
- 				 gfp_t flags)
+ int netlbl_catmap_setbit(struct netlbl_lsm_catmap **catmap,
+ 			 u32 bit,
+ 			 gfp_t flags)
  {
++<<<<<<< HEAD
 +	struct netlbl_lsm_secattr_catmap *iter = *catmap;
 +	u32 node_bit;
 +	u32 node_idx;
 +
 +	while (iter->next != NULL &&
 +	       bit >= (iter->startbit + NETLBL_CATMAP_SIZE))
 +		iter = iter->next;
 +	if (bit < iter->startbit) {
 +		iter = netlbl_secattr_catmap_alloc(flags);
 +		if (iter == NULL)
 +			return -ENOMEM;
 +		iter->next = *catmap;
 +		iter->startbit = bit & ~(NETLBL_CATMAP_SIZE - 1);
 +		*catmap = iter;
 +	} else if (bit >= (iter->startbit + NETLBL_CATMAP_SIZE)) {
 +		iter->next = netlbl_secattr_catmap_alloc(flags);
 +		if (iter->next == NULL)
 +			return -ENOMEM;
 +		iter = iter->next;
 +		iter->startbit = bit & ~(NETLBL_CATMAP_SIZE - 1);
 +	}
++=======
+ 	struct netlbl_lsm_catmap *iter;
+ 	u32 idx;
+ 
+ 	iter = _netlbl_catmap_getnode(catmap, bit, _CM_F_ALLOC, flags);
+ 	if (iter == NULL)
+ 		return -ENOMEM;
++>>>>>>> 4fbe63d1c773 (netlabel: shorter names for the NetLabel catmap funcs/structs)
  
 -	bit -= iter->startbit;
 -	idx = bit / NETLBL_CATMAP_MAPSIZE;
 -	iter->bitmap[idx] |= NETLBL_CATMAP_BIT << (bit % NETLBL_CATMAP_MAPSIZE);
 +	/* gcc always rounds to zero when doing integer division */
 +	node_idx = (bit - iter->startbit) / NETLBL_CATMAP_MAPSIZE;
 +	node_bit = bit - iter->startbit - (NETLBL_CATMAP_MAPSIZE * node_idx);
 +	iter->bitmap[node_idx] |= NETLBL_CATMAP_BIT << node_bit;
  
  	return 0;
  }
@@@ -578,39 -670,63 +728,91 @@@
   * on success, negative values on failure.
   *
   */
- int netlbl_secattr_catmap_setrng(struct netlbl_lsm_secattr_catmap **catmap,
- 				 u32 start,
- 				 u32 end,
- 				 gfp_t flags)
+ int netlbl_catmap_setrng(struct netlbl_lsm_catmap **catmap,
+ 			 u32 start,
+ 			 u32 end,
+ 			 gfp_t flags)
  {
 -	int rc = 0;
 -	u32 spot = start;
 +	int ret_val = 0;
 +	struct netlbl_lsm_secattr_catmap *iter = *catmap;
 +	u32 iter_max_spot;
 +	u32 spot;
 +	u32 orig_spot = iter->startbit;
 +
++<<<<<<< HEAD
 +	/* XXX - This could probably be made a bit faster by combining writes
 +	 * to the catmap instead of setting a single bit each time, but for
 +	 * right now skipping to the start of the range in the catmap should
 +	 * be a nice improvement over calling the individual setbit function
 +	 * repeatedly from a loop. */
 +
 +	while (iter->next != NULL &&
 +	       start >= (iter->startbit + NETLBL_CATMAP_SIZE))
 +		iter = iter->next;
 +	iter_max_spot = iter->startbit + NETLBL_CATMAP_SIZE;
  
 +	for (spot = start; spot <= end && ret_val == 0; spot++) {
 +		if (spot >= iter_max_spot && iter->next != NULL) {
 +			iter = iter->next;
 +			iter_max_spot = iter->startbit + NETLBL_CATMAP_SIZE;
 +		}
 +		ret_val = netlbl_secattr_catmap_setbit(&iter, spot, flags);
 +		if (iter->startbit < orig_spot)
 +			*catmap = iter;
 +	}
 +
 +	return ret_val;
++=======
+ 	while (rc == 0 && spot <= end) {
+ 		if (((spot & (BITS_PER_LONG - 1)) != 0) &&
+ 		    ((end - spot) > BITS_PER_LONG)) {
+ 			rc = netlbl_catmap_setlong(catmap,
+ 						   spot,
+ 						   (unsigned long)-1,
+ 						   flags);
+ 			spot += BITS_PER_LONG;
+ 		} else
+ 			rc = netlbl_catmap_setbit(catmap, spot++, flags);
+ 	}
+ 
+ 	return rc;
+ }
+ 
+ /**
+  * netlbl_catmap_setlong - Import an unsigned long bitmap
+  * @catmap: pointer to the category bitmap
+  * @offset: offset to the start of the imported bitmap
+  * @bitmap: the bitmap to import
+  * @flags: memory allocation flags
+  *
+  * Description:
+  * Import the bitmap specified in @bitmap into @catmap, using the offset
+  * in @offset.  The offset must be aligned to an unsigned long.  Returns zero
+  * on success, negative values on failure.
+  *
+  */
+ int netlbl_catmap_setlong(struct netlbl_lsm_catmap **catmap,
+ 			  u32 offset,
+ 			  unsigned long bitmap,
+ 			  gfp_t flags)
+ {
+ 	struct netlbl_lsm_catmap *iter;
+ 	u32 idx;
+ 
+ 	/* only allow aligned offsets */
+ 	if ((offset & (BITS_PER_LONG - 1)) != 0)
+ 		return -EINVAL;
+ 
+ 	iter = _netlbl_catmap_getnode(catmap, offset, _CM_F_ALLOC, flags);
+ 	if (iter == NULL)
+ 		return -ENOMEM;
+ 
+ 	offset -= iter->startbit;
+ 	idx = offset / NETLBL_CATMAP_MAPSIZE;
+ 	iter->bitmap[idx] |= bitmap << (offset % NETLBL_CATMAP_MAPSIZE);
+ 
+ 	return 0;
++>>>>>>> 4fbe63d1c773 (netlabel: shorter names for the NetLabel catmap funcs/structs)
  }
  
  /*
diff --cc security/selinux/ss/ebitmap.c
index 820313a04d49,afe6a269ec17..000000000000
--- a/security/selinux/ss/ebitmap.c
+++ b/security/selinux/ss/ebitmap.c
@@@ -86,51 -86,36 +86,68 @@@ int ebitmap_cpy(struct ebitmap *dst, st
   *
   */
  int ebitmap_netlbl_export(struct ebitmap *ebmap,
- 			  struct netlbl_lsm_secattr_catmap **catmap)
+ 			  struct netlbl_lsm_catmap **catmap)
  {
  	struct ebitmap_node *e_iter = ebmap->node;
 -	unsigned long e_map;
 -	u32 offset;
 -	unsigned int iter;
 -	int rc;
 +	struct netlbl_lsm_secattr_catmap *c_iter;
 +	u32 cmap_idx, cmap_sft;
 +	int i;
 +
 +	/* NetLabel's NETLBL_CATMAP_MAPTYPE is defined as an array of u64,
 +	 * however, it is not always compatible with an array of unsigned long
 +	 * in ebitmap_node.
 +	 * In addition, you should pay attention the following implementation
 +	 * assumes unsigned long has a width equal with or less than 64-bit.
 +	 */
  
  	if (e_iter == NULL) {
  		*catmap = NULL;
  		return 0;
  	}
  
++<<<<<<< HEAD
 +	c_iter = netlbl_secattr_catmap_alloc(GFP_ATOMIC);
 +	if (c_iter == NULL)
 +		return -ENOMEM;
 +	*catmap = c_iter;
 +	c_iter->startbit = e_iter->startbit & ~(NETLBL_CATMAP_SIZE - 1);
 +
 +	while (e_iter) {
 +		for (i = 0; i < EBITMAP_UNIT_NUMS; i++) {
 +			unsigned int delta, e_startbit, c_endbit;
 +
 +			e_startbit = e_iter->startbit + i * EBITMAP_UNIT_SIZE;
 +			c_endbit = c_iter->startbit + NETLBL_CATMAP_SIZE;
 +			if (e_startbit >= c_endbit) {
 +				c_iter->next
 +				  = netlbl_secattr_catmap_alloc(GFP_ATOMIC);
 +				if (c_iter->next == NULL)
++=======
+ 	if (*catmap != NULL)
+ 		netlbl_catmap_free(*catmap);
+ 	*catmap = NULL;
+ 
+ 	while (e_iter) {
+ 		offset = e_iter->startbit;
+ 		for (iter = 0; iter < EBITMAP_UNIT_NUMS; iter++) {
+ 			e_map = e_iter->maps[iter];
+ 			if (e_map != 0) {
+ 				rc = netlbl_catmap_setlong(catmap,
+ 							   offset,
+ 							   e_map,
+ 							   GFP_ATOMIC);
+ 				if (rc != 0)
++>>>>>>> 4fbe63d1c773 (netlabel: shorter names for the NetLabel catmap funcs/structs)
  					goto netlbl_export_failure;
 +				c_iter = c_iter->next;
 +				c_iter->startbit
 +				  = e_startbit & ~(NETLBL_CATMAP_SIZE - 1);
  			}
 -			offset += EBITMAP_UNIT_SIZE;
 +			delta = e_startbit - c_iter->startbit;
 +			cmap_idx = delta / NETLBL_CATMAP_MAPSIZE;
 +			cmap_sft = delta % NETLBL_CATMAP_MAPSIZE;
 +			c_iter->bitmap[cmap_idx]
 +				|= e_iter->maps[i] << cmap_sft;
  		}
  		e_iter = e_iter->next;
  	}
@@@ -153,58 -138,44 +170,67 @@@ netlbl_export_failure
   *
   */
  int ebitmap_netlbl_import(struct ebitmap *ebmap,
- 			  struct netlbl_lsm_secattr_catmap *catmap)
+ 			  struct netlbl_lsm_catmap *catmap)
  {
 -	int rc;
  	struct ebitmap_node *e_iter = NULL;
 -	struct ebitmap_node *e_prev = NULL;
 -	u32 offset = 0, idx;
 -	unsigned long bitmap;
 +	struct ebitmap_node *emap_prev = NULL;
 +	struct netlbl_lsm_secattr_catmap *c_iter = catmap;
 +	u32 c_idx, c_pos, e_idx, e_sft;
  
++<<<<<<< HEAD
 +	/* NetLabel's NETLBL_CATMAP_MAPTYPE is defined as an array of u64,
 +	 * however, it is not always compatible with an array of unsigned long
 +	 * in ebitmap_node.
 +	 * In addition, you should pay attention the following implementation
 +	 * assumes unsigned long has a width equal with or less than 64-bit.
 +	 */
++=======
+ 	for (;;) {
+ 		rc = netlbl_catmap_getlong(catmap, &offset, &bitmap);
+ 		if (rc < 0)
+ 			goto netlbl_import_failure;
+ 		if (offset == (u32)-1)
+ 			return 0;
++>>>>>>> 4fbe63d1c773 (netlabel: shorter names for the NetLabel catmap funcs/structs)
  
 -		if (e_iter == NULL ||
 -		    offset >= e_iter->startbit + EBITMAP_SIZE) {
 -			e_prev = e_iter;
 -			e_iter = kzalloc(sizeof(*e_iter), GFP_ATOMIC);
 -			if (e_iter == NULL)
 -				goto netlbl_import_failure;
 -			e_iter->startbit = offset & ~(EBITMAP_SIZE - 1);
 -			if (e_prev == NULL)
 -				ebmap->node = e_iter;
 -			else
 -				e_prev->next = e_iter;
 -			ebmap->highbit = e_iter->startbit + EBITMAP_SIZE;
 -		}
 +	do {
 +		for (c_idx = 0; c_idx < NETLBL_CATMAP_MAPCNT; c_idx++) {
 +			unsigned int delta;
 +			u64 map = c_iter->bitmap[c_idx];
  
 -		/* offset will always be aligned to an unsigned long */
 -		idx = EBITMAP_NODE_INDEX(e_iter, offset);
 -		e_iter->maps[idx] = bitmap;
 +			if (!map)
 +				continue;
  
 -		/* next */
 -		offset += EBITMAP_UNIT_SIZE;
 -	}
 +			c_pos = c_iter->startbit
 +				+ c_idx * NETLBL_CATMAP_MAPSIZE;
 +			if (!e_iter
 +			    || c_pos >= e_iter->startbit + EBITMAP_SIZE) {
 +				e_iter = kzalloc(sizeof(*e_iter), GFP_ATOMIC);
 +				if (!e_iter)
 +					goto netlbl_import_failure;
 +				e_iter->startbit
 +					= c_pos - (c_pos % EBITMAP_SIZE);
 +				if (emap_prev == NULL)
 +					ebmap->node = e_iter;
 +				else
 +					emap_prev->next = e_iter;
 +				emap_prev = e_iter;
 +			}
 +			delta = c_pos - e_iter->startbit;
 +			e_idx = delta / EBITMAP_UNIT_SIZE;
 +			e_sft = delta % EBITMAP_UNIT_SIZE;
 +			while (map) {
 +				e_iter->maps[e_idx++] |= map & (-1UL);
 +				map = EBITMAP_SHIFT_UNIT_SIZE(map);
 +			}
 +		}
 +		c_iter = c_iter->next;
 +	} while (c_iter);
 +	if (e_iter != NULL)
 +		ebmap->highbit = e_iter->startbit + EBITMAP_SIZE;
 +	else
 +		ebitmap_destroy(ebmap);
  
 -	/* NOTE: we should never reach this return */
  	return 0;
  
  netlbl_import_failure:
diff --cc security/smack/smack_lsm.c
index 3af62fbedea0,c32bba566df9..000000000000
--- a/security/smack/smack_lsm.c
+++ b/security/smack/smack_lsm.c
@@@ -2836,15 -3078,31 +2836,40 @@@ static char *smack_from_secattr(struct 
  		 * ambient value.
  		 */
  		rcu_read_lock();
 -		list_for_each_entry(skp, &smack_known_list, list) {
 -			if (sap->attr.mls.lvl != skp->smk_netlabel.attr.mls.lvl)
 +		list_for_each_entry(kp, &smack_known_list, list) {
 +			if (sap->attr.mls.lvl != kp->smk_netlabel.attr.mls.lvl)
  				continue;
++<<<<<<< HEAD
 +			if (memcmp(sap->attr.mls.cat,
 +				kp->smk_netlabel.attr.mls.cat,
 +				SMK_CIPSOLEN) != 0)
 +				continue;
 +			found = 1;
 +			break;
++=======
+ 			/*
+ 			 * Compare the catsets. Use the netlbl APIs.
+ 			 */
+ 			if ((sap->flags & NETLBL_SECATTR_MLS_CAT) == 0) {
+ 				if ((skp->smk_netlabel.flags &
+ 				     NETLBL_SECATTR_MLS_CAT) == 0)
+ 					found = 1;
+ 				break;
+ 			}
+ 			for (acat = -1, kcat = -1; acat == kcat; ) {
+ 				acat = netlbl_catmap_walk(sap->attr.mls.cat,
+ 							  acat + 1);
+ 				kcat = netlbl_catmap_walk(
+ 					skp->smk_netlabel.attr.mls.cat,
+ 					kcat + 1);
+ 				if (acat < 0 || kcat < 0)
+ 					break;
+ 			}
+ 			if (acat == kcat) {
+ 				found = 1;
+ 				break;
+ 			}
++>>>>>>> 4fbe63d1c773 (netlabel: shorter names for the NetLabel catmap funcs/structs)
  		}
  		rcu_read_unlock();
  
* Unmerged path include/net/netlabel.h
diff --git a/net/ipv4/cipso_ipv4.c b/net/ipv4/cipso_ipv4.c
index 78856ca12d32..3975d4e33975 100644
--- a/net/ipv4/cipso_ipv4.c
+++ b/net/ipv4/cipso_ipv4.c
@@ -891,8 +891,8 @@ static int cipso_v4_map_cat_rbm_hton(const struct cipso_v4_doi *doi_def,
 	}
 
 	for (;;) {
-		host_spot = netlbl_secattr_catmap_walk(secattr->attr.mls.cat,
-						       host_spot + 1);
+		host_spot = netlbl_catmap_walk(secattr->attr.mls.cat,
+					       host_spot + 1);
 		if (host_spot < 0)
 			break;
 
@@ -974,7 +974,7 @@ static int cipso_v4_map_cat_rbm_ntoh(const struct cipso_v4_doi *doi_def,
 				return -EPERM;
 			break;
 		}
-		ret_val = netlbl_secattr_catmap_setbit(&secattr->attr.mls.cat,
+		ret_val = netlbl_catmap_setbit(&secattr->attr.mls.cat,
 						       host_spot,
 						       GFP_ATOMIC);
 		if (ret_val != 0)
@@ -1040,8 +1040,7 @@ static int cipso_v4_map_cat_enum_hton(const struct cipso_v4_doi *doi_def,
 	u32 cat_iter = 0;
 
 	for (;;) {
-		cat = netlbl_secattr_catmap_walk(secattr->attr.mls.cat,
-						 cat + 1);
+		cat = netlbl_catmap_walk(secattr->attr.mls.cat, cat + 1);
 		if (cat < 0)
 			break;
 		if ((cat_iter + 2) > net_cat_len)
@@ -1076,9 +1075,9 @@ static int cipso_v4_map_cat_enum_ntoh(const struct cipso_v4_doi *doi_def,
 	u32 iter;
 
 	for (iter = 0; iter < net_cat_len; iter += 2) {
-		ret_val = netlbl_secattr_catmap_setbit(&secattr->attr.mls.cat,
-				get_unaligned_be16(&net_cat[iter]),
-				GFP_ATOMIC);
+		ret_val = netlbl_catmap_setbit(&secattr->attr.mls.cat,
+					     get_unaligned_be16(&net_cat[iter]),
+					     GFP_ATOMIC);
 		if (ret_val != 0)
 			return ret_val;
 	}
@@ -1156,8 +1155,7 @@ static int cipso_v4_map_cat_rng_hton(const struct cipso_v4_doi *doi_def,
 		return -ENOSPC;
 
 	for (;;) {
-		iter = netlbl_secattr_catmap_walk(secattr->attr.mls.cat,
-						  iter + 1);
+		iter = netlbl_catmap_walk(secattr->attr.mls.cat, iter + 1);
 		if (iter < 0)
 			break;
 		cat_size += (iter == 0 ? 0 : sizeof(u16));
@@ -1165,8 +1163,7 @@ static int cipso_v4_map_cat_rng_hton(const struct cipso_v4_doi *doi_def,
 			return -ENOSPC;
 		array[array_cnt++] = iter;
 
-		iter = netlbl_secattr_catmap_walk_rng(secattr->attr.mls.cat,
-						      iter);
+		iter = netlbl_catmap_walkrng(secattr->attr.mls.cat, iter);
 		if (iter < 0)
 			return -EFAULT;
 		cat_size += sizeof(u16);
@@ -1218,10 +1215,10 @@ static int cipso_v4_map_cat_rng_ntoh(const struct cipso_v4_doi *doi_def,
 		else
 			cat_low = 0;
 
-		ret_val = netlbl_secattr_catmap_setrng(&secattr->attr.mls.cat,
-						       cat_low,
-						       cat_high,
-						       GFP_ATOMIC);
+		ret_val = netlbl_catmap_setrng(&secattr->attr.mls.cat,
+					       cat_low,
+					       cat_high,
+					       GFP_ATOMIC);
 		if (ret_val != 0)
 			return ret_val;
 	}
@@ -1346,7 +1343,7 @@ static int cipso_v4_parsetag_rbm(const struct cipso_v4_doi *doi_def,
 						    tag_len - 4,
 						    secattr);
 		if (ret_val != 0) {
-			netlbl_secattr_catmap_free(secattr->attr.mls.cat);
+			netlbl_catmap_free(secattr->attr.mls.cat);
 			return ret_val;
 		}
 
@@ -1442,7 +1439,7 @@ static int cipso_v4_parsetag_enum(const struct cipso_v4_doi *doi_def,
 						     tag_len - 4,
 						     secattr);
 		if (ret_val != 0) {
-			netlbl_secattr_catmap_free(secattr->attr.mls.cat);
+			netlbl_catmap_free(secattr->attr.mls.cat);
 			return ret_val;
 		}
 
@@ -1537,7 +1534,7 @@ static int cipso_v4_parsetag_rng(const struct cipso_v4_doi *doi_def,
 						    tag_len - 4,
 						    secattr);
 		if (ret_val != 0) {
-			netlbl_secattr_catmap_free(secattr->attr.mls.cat);
+			netlbl_catmap_free(secattr->attr.mls.cat);
 			return ret_val;
 		}
 
* Unmerged path net/netlabel/netlabel_kapi.c
* Unmerged path security/selinux/ss/ebitmap.c
diff --git a/security/selinux/ss/ebitmap.h b/security/selinux/ss/ebitmap.h
index 712c8a7b8e8b..9637b8c71085 100644
--- a/security/selinux/ss/ebitmap.h
+++ b/security/selinux/ss/ebitmap.h
@@ -132,17 +132,17 @@ int ebitmap_write(struct ebitmap *e, void *fp);
 
 #ifdef CONFIG_NETLABEL
 int ebitmap_netlbl_export(struct ebitmap *ebmap,
-			  struct netlbl_lsm_secattr_catmap **catmap);
+			  struct netlbl_lsm_catmap **catmap);
 int ebitmap_netlbl_import(struct ebitmap *ebmap,
-			  struct netlbl_lsm_secattr_catmap *catmap);
+			  struct netlbl_lsm_catmap *catmap);
 #else
 static inline int ebitmap_netlbl_export(struct ebitmap *ebmap,
-				struct netlbl_lsm_secattr_catmap **catmap)
+					struct netlbl_lsm_catmap **catmap)
 {
 	return -ENOMEM;
 }
 static inline int ebitmap_netlbl_import(struct ebitmap *ebmap,
-				struct netlbl_lsm_secattr_catmap *catmap)
+					struct netlbl_lsm_catmap *catmap)
 {
 	return -ENOMEM;
 }
diff --git a/security/smack/smack_access.c b/security/smack/smack_access.c
index 442d40fbdeaf..44bd2998a0a3 100644
--- a/security/smack/smack_access.c
+++ b/security/smack/smack_access.c
@@ -408,10 +408,10 @@ int smk_netlbl_mls(int level, char *catset, struct netlbl_lsm_secattr *sap,
 		for (m = 0x80; m != 0; m >>= 1, cat++) {
 			if ((m & *cp) == 0)
 				continue;
-			rc = netlbl_secattr_catmap_setbit(&sap->attr.mls.cat,
-							  cat, GFP_ATOMIC);
+			rc = netlbl_catmap_setbit(&sap->attr.mls.cat,
+						  cat, GFP_ATOMIC);
 			if (rc < 0) {
-				netlbl_secattr_catmap_free(sap->attr.mls.cat);
+				netlbl_catmap_free(sap->attr.mls.cat);
 				return rc;
 			}
 		}
* Unmerged path security/smack/smack_lsm.c
diff --git a/security/smack/smackfs.c b/security/smack/smackfs.c
index 53a08b85bda4..a3a55a253608 100644
--- a/security/smack/smackfs.c
+++ b/security/smack/smackfs.c
@@ -770,7 +770,7 @@ static int cipso_seq_show(struct seq_file *s, void *v)
 	struct list_head  *list = v;
 	struct smack_known *skp =
 		 list_entry(list, struct smack_known, list);
-	struct netlbl_lsm_secattr_catmap *cmp = skp->smk_netlabel.attr.mls.cat;
+	struct netlbl_lsm_catmap *cmp = skp->smk_netlabel.attr.mls.cat;
 	char sep = '/';
 	int i;
 
@@ -787,8 +787,8 @@ static int cipso_seq_show(struct seq_file *s, void *v)
 
 	seq_printf(s, "%s %3d", skp->smk_known, skp->smk_netlabel.attr.mls.lvl);
 
-	for (i = netlbl_secattr_catmap_walk(cmp, 0); i >= 0;
-	     i = netlbl_secattr_catmap_walk(cmp, i + 1)) {
+	for (i = netlbl_catmap_walk(cmp, 0); i >= 0;
+	     i = netlbl_catmap_walk(cmp, i + 1)) {
 		seq_printf(s, "%c%d", sep, i);
 		sep = ',';
 	}
@@ -909,7 +909,7 @@ static ssize_t smk_set_cipso(struct file *file, const char __user *buf,
 
 	rc = smk_netlbl_mls(maplevel, mapcatset, &ncats, SMK_CIPSOLEN);
 	if (rc >= 0) {
-		netlbl_secattr_catmap_free(skp->smk_netlabel.attr.mls.cat);
+		netlbl_catmap_free(skp->smk_netlabel.attr.mls.cat);
 		skp->smk_netlabel.attr.mls.cat = ncats.attr.mls.cat;
 		skp->smk_netlabel.attr.mls.lvl = ncats.attr.mls.lvl;
 		rc = count;
@@ -959,14 +959,14 @@ static int cipso2_seq_show(struct seq_file *s, void *v)
 	struct list_head  *list = v;
 	struct smack_known *skp =
 		 list_entry(list, struct smack_known, list);
-	struct netlbl_lsm_secattr_catmap *cmp = skp->smk_netlabel.attr.mls.cat;
+	struct netlbl_lsm_catmap *cmp = skp->smk_netlabel.attr.mls.cat;
 	char sep = '/';
 	int i;
 
 	seq_printf(s, "%s %3d", skp->smk_known, skp->smk_netlabel.attr.mls.lvl);
 
-	for (i = netlbl_secattr_catmap_walk(cmp, 0); i >= 0;
-	     i = netlbl_secattr_catmap_walk(cmp, i + 1)) {
+	for (i = netlbl_catmap_walk(cmp, 0); i >= 0;
+	     i = netlbl_catmap_walk(cmp, i + 1)) {
 		seq_printf(s, "%c%d", sep, i);
 		sep = ',';
 	}
