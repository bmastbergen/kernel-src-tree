blk-mq: correct a few wrong/bad comments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Jens Axboe <axboe@fb.com>
commit a68aafa5b297d99c2d0c38689089a752126e9e79
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a68aafa5.failed

Just grammar or spelling errors, nothing major.

	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit a68aafa5b297d99c2d0c38689089a752126e9e79)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index e7914e35b358,a0565bb20fd5..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -1203,11 -1577,10 +1203,11 @@@ static int blk_mq_init_hw_queues(struc
  						blk_mq_hctx_notify, hctx);
  		blk_mq_register_cpu_notifier(&hctx->cpu_notifier);
  
 -		hctx->tags = set->tags[i];
 +		if (blk_mq_init_rq_map(hctx, reg->reserved_tags, node))
 +			break;
  
  		/*
- 		 * Allocate space for all possible cpus to avoid allocation in
+ 		 * Allocate space for all possible cpus to avoid allocation at
  		 * runtime
  		 */
  		hctx->ctxs = kmalloc_node(nr_cpu_ids * sizeof(void *),
@@@ -1307,30 -1665,84 +1307,56 @@@ static void blk_mq_map_swqueue(struct r
  		ctx->index_hw = hctx->nr_ctx;
  		hctx->ctxs[hctx->nr_ctx++] = ctx;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	queue_for_each_hw_ctx(q, hctx, i) {
+ 		/*
+ 		 * If no software queues are mapped to this hardware queue,
+ 		 * disable it and free the request entries.
+ 		 */
+ 		if (!hctx->nr_ctx) {
+ 			struct blk_mq_tag_set *set = q->tag_set;
+ 
+ 			if (set->tags[i]) {
+ 				blk_mq_free_rq_map(set, set->tags[i], i);
+ 				set->tags[i] = NULL;
+ 				hctx->tags = NULL;
+ 			}
+ 			continue;
+ 		}
+ 
+ 		/*
+ 		 * Initialize batch roundrobin counts
+ 		 */
+ 		hctx->next_cpu = cpumask_first(hctx->cpumask);
+ 		hctx->next_cpu_batch = BLK_MQ_CPU_WORK_BATCH;
+ 	}
++>>>>>>> a68aafa5b297 (blk-mq: correct a few wrong/bad comments)
  }
  
 -static void blk_mq_update_tag_set_depth(struct blk_mq_tag_set *set)
 +struct request_queue *blk_mq_init_queue(struct blk_mq_reg *reg,
 +					void *driver_data)
  {
 -	struct blk_mq_hw_ctx *hctx;
 +	struct blk_mq_hw_ctx **hctxs;
 +	struct blk_mq_ctx __percpu *ctx;
  	struct request_queue *q;
 -	bool shared;
  	int i;
  
 -	if (set->tag_list.next == set->tag_list.prev)
 -		shared = false;
 -	else
 -		shared = true;
 -
 -	list_for_each_entry(q, &set->tag_list, tag_set_list) {
 -		blk_mq_freeze_queue(q);
 +	if (!reg->nr_hw_queues ||
 +	    !reg->ops->queue_rq || !reg->ops->map_queue ||
 +	    !reg->ops->alloc_hctx || !reg->ops->free_hctx)
 +		return ERR_PTR(-EINVAL);
  
 -		queue_for_each_hw_ctx(q, hctx, i) {
 -			if (shared)
 -				hctx->flags |= BLK_MQ_F_TAG_SHARED;
 -			else
 -				hctx->flags &= ~BLK_MQ_F_TAG_SHARED;
 -		}
 -		blk_mq_unfreeze_queue(q);
 +	if (!reg->queue_depth)
 +		reg->queue_depth = BLK_MQ_MAX_DEPTH;
 +	else if (reg->queue_depth > BLK_MQ_MAX_DEPTH) {
 +		pr_err("blk-mq: queuedepth too large (%u)\n", reg->queue_depth);
 +		reg->queue_depth = BLK_MQ_MAX_DEPTH;
  	}
 -}
 -
 -static void blk_mq_del_queue_tag_set(struct request_queue *q)
 -{
 -	struct blk_mq_tag_set *set = q->tag_set;
 -
 -	mutex_lock(&set->tag_list_lock);
 -	list_del_init(&q->tag_set_list);
 -	blk_mq_update_tag_set_depth(set);
 -	mutex_unlock(&set->tag_list_lock);
 -}
 -
 -static void blk_mq_add_queue_tag_set(struct blk_mq_tag_set *set,
 -				     struct request_queue *q)
 -{
 -	q->tag_set = set;
  
 -	mutex_lock(&set->tag_list_lock);
 -	list_add_tail(&q->tag_set_list, &set->tag_list);
 -	blk_mq_update_tag_set_depth(set);
 -	mutex_unlock(&set->tag_list_lock);
 -}
 -
 -struct request_queue *blk_mq_init_queue(struct blk_mq_tag_set *set)
 -{
 -	struct blk_mq_hw_ctx **hctxs;
 -	struct blk_mq_ctx __percpu *ctx;
 -	struct request_queue *q;
 -	unsigned int *map;
 -	int i;
 +	if (reg->queue_depth < (reg->reserved_tags + BLK_MQ_TAG_MIN))
 +		return ERR_PTR(-EINVAL);
  
  	ctx = alloc_percpu(struct blk_mq_ctx);
  	if (!ctx)
* Unmerged path block/blk-mq.c
