blk-mq: fix schedule from atomic context

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Ming Lei <tom.leiming@gmail.com>
commit cb96a42cc1f50ba1c7b1e9b2343bec80b926107f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/cb96a42c.failed

blk_mq_put_ctx() has to be called before io_schedule() in
bt_get().

This patch fixes the problem by taking similar approach from
percpu_ida allocation for the situation.

	Signed-off-by: Ming Lei <tom.leiming@gmail.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit cb96a42cc1f50ba1c7b1e9b2343bec80b926107f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq-tag.c
#	block/blk-mq-tag.h
#	block/blk-mq.c
diff --cc block/blk-mq-tag.c
index d50cc52e39c1,1aab39f71d95..000000000000
--- a/block/blk-mq-tag.c
+++ b/block/blk-mq-tag.c
@@@ -40,44 -37,316 +40,339 @@@ void blk_mq_wait_for_tags(struct blk_mq
  
  bool blk_mq_has_free_tags(struct blk_mq_tags *tags)
  {
 -	if (!tags)
 -		return true;
 -
 -	return bt_has_free_tags(&tags->bitmap_tags);
 +	return !tags ||
 +		percpu_ida_free_tags(&tags->free_tags, nr_cpu_ids) != 0;
  }
  
++<<<<<<< HEAD
 +static unsigned int __blk_mq_get_tag(struct blk_mq_tags *tags, gfp_t gfp)
 +{
 +	int tag;
 +
 +	tag = percpu_ida_alloc(&tags->free_tags, (gfp & __GFP_WAIT) ?
 +			       TASK_UNINTERRUPTIBLE : TASK_RUNNING);
 +	if (tag < 0)
 +		return BLK_MQ_TAG_FAIL;
 +	return tag + tags->nr_reserved_tags;
++=======
+ static inline void bt_index_inc(unsigned int *index)
+ {
+ 	*index = (*index + 1) & (BT_WAIT_QUEUES - 1);
+ }
+ 
+ /*
+  * If a previously inactive queue goes active, bump the active user count.
+  */
+ bool __blk_mq_tag_busy(struct blk_mq_hw_ctx *hctx)
+ {
+ 	if (!test_bit(BLK_MQ_S_TAG_ACTIVE, &hctx->state) &&
+ 	    !test_and_set_bit(BLK_MQ_S_TAG_ACTIVE, &hctx->state))
+ 		atomic_inc(&hctx->tags->active_queues);
+ 
+ 	return true;
+ }
+ 
+ /*
+  * Wakeup all potentially sleeping on normal (non-reserved) tags
+  */
+ static void blk_mq_tag_wakeup_all(struct blk_mq_tags *tags)
+ {
+ 	struct blk_mq_bitmap_tags *bt;
+ 	int i, wake_index;
+ 
+ 	bt = &tags->bitmap_tags;
+ 	wake_index = bt->wake_index;
+ 	for (i = 0; i < BT_WAIT_QUEUES; i++) {
+ 		struct bt_wait_state *bs = &bt->bs[wake_index];
+ 
+ 		if (waitqueue_active(&bs->wait))
+ 			wake_up(&bs->wait);
+ 
+ 		bt_index_inc(&wake_index);
+ 	}
+ }
+ 
+ /*
+  * If a previously busy queue goes inactive, potential waiters could now
+  * be allowed to queue. Wake them up and check.
+  */
+ void __blk_mq_tag_idle(struct blk_mq_hw_ctx *hctx)
+ {
+ 	struct blk_mq_tags *tags = hctx->tags;
+ 
+ 	if (!test_and_clear_bit(BLK_MQ_S_TAG_ACTIVE, &hctx->state))
+ 		return;
+ 
+ 	atomic_dec(&tags->active_queues);
+ 
+ 	blk_mq_tag_wakeup_all(tags);
+ }
+ 
+ /*
+  * For shared tag users, we track the number of currently active users
+  * and attempt to provide a fair share of the tag depth for each of them.
+  */
+ static inline bool hctx_may_queue(struct blk_mq_hw_ctx *hctx,
+ 				  struct blk_mq_bitmap_tags *bt)
+ {
+ 	unsigned int depth, users;
+ 
+ 	if (!hctx || !(hctx->flags & BLK_MQ_F_TAG_SHARED))
+ 		return true;
+ 	if (!test_bit(BLK_MQ_S_TAG_ACTIVE, &hctx->state))
+ 		return true;
+ 
+ 	/*
+ 	 * Don't try dividing an ant
+ 	 */
+ 	if (bt->depth == 1)
+ 		return true;
+ 
+ 	users = atomic_read(&hctx->tags->active_queues);
+ 	if (!users)
+ 		return true;
+ 
+ 	/*
+ 	 * Allow at least some tags
+ 	 */
+ 	depth = max((bt->depth + users - 1) / users, 4U);
+ 	return atomic_read(&hctx->nr_active) < depth;
+ }
+ 
+ static int __bt_get_word(struct blk_align_bitmap *bm, unsigned int last_tag)
+ {
+ 	int tag, org_last_tag, end;
+ 
+ 	org_last_tag = last_tag;
+ 	end = bm->depth;
+ 	do {
+ restart:
+ 		tag = find_next_zero_bit(&bm->word, end, last_tag);
+ 		if (unlikely(tag >= end)) {
+ 			/*
+ 			 * We started with an offset, start from 0 to
+ 			 * exhaust the map.
+ 			 */
+ 			if (org_last_tag && last_tag) {
+ 				end = last_tag;
+ 				last_tag = 0;
+ 				goto restart;
+ 			}
+ 			return -1;
+ 		}
+ 		last_tag = tag + 1;
+ 	} while (test_and_set_bit_lock(tag, &bm->word));
+ 
+ 	return tag;
+ }
+ 
+ /*
+  * Straight forward bitmap tag implementation, where each bit is a tag
+  * (cleared == free, and set == busy). The small twist is using per-cpu
+  * last_tag caches, which blk-mq stores in the blk_mq_ctx software queue
+  * contexts. This enables us to drastically limit the space searched,
+  * without dirtying an extra shared cacheline like we would if we stored
+  * the cache value inside the shared blk_mq_bitmap_tags structure. On top
+  * of that, each word of tags is in a separate cacheline. This means that
+  * multiple users will tend to stick to different cachelines, at least
+  * until the map is exhausted.
+  */
+ static int __bt_get(struct blk_mq_hw_ctx *hctx, struct blk_mq_bitmap_tags *bt,
+ 		    unsigned int *tag_cache)
+ {
+ 	unsigned int last_tag, org_last_tag;
+ 	int index, i, tag;
+ 
+ 	if (!hctx_may_queue(hctx, bt))
+ 		return -1;
+ 
+ 	last_tag = org_last_tag = *tag_cache;
+ 	index = TAG_TO_INDEX(bt, last_tag);
+ 
+ 	for (i = 0; i < bt->map_nr; i++) {
+ 		tag = __bt_get_word(&bt->map[index], TAG_TO_BIT(bt, last_tag));
+ 		if (tag != -1) {
+ 			tag += (index << bt->bits_per_word);
+ 			goto done;
+ 		}
+ 
+ 		last_tag = 0;
+ 		if (++index >= bt->map_nr)
+ 			index = 0;
+ 	}
+ 
+ 	*tag_cache = 0;
+ 	return -1;
+ 
+ 	/*
+ 	 * Only update the cache from the allocation path, if we ended
+ 	 * up using the specific cached tag.
+ 	 */
+ done:
+ 	if (tag == org_last_tag) {
+ 		last_tag = tag + 1;
+ 		if (last_tag >= bt->depth - 1)
+ 			last_tag = 0;
+ 
+ 		*tag_cache = last_tag;
+ 	}
+ 
+ 	return tag;
  }
  
- static unsigned int __blk_mq_get_reserved_tag(struct blk_mq_tags *tags,
- 					      gfp_t gfp)
+ static struct bt_wait_state *bt_wait_ptr(struct blk_mq_bitmap_tags *bt,
+ 					 struct blk_mq_hw_ctx *hctx)
  {
+ 	struct bt_wait_state *bs;
+ 
+ 	if (!hctx)
+ 		return &bt->bs[0];
+ 
+ 	bs = &bt->bs[hctx->wait_index];
+ 	bt_index_inc(&hctx->wait_index);
+ 	return bs;
+ }
+ 
+ static int bt_get(struct blk_mq_alloc_data *data,
+ 		struct blk_mq_bitmap_tags *bt,
+ 		struct blk_mq_hw_ctx *hctx,
+ 		unsigned int *last_tag)
+ {
+ 	struct bt_wait_state *bs;
+ 	DEFINE_WAIT(wait);
  	int tag;
  
- 	if (unlikely(!tags->nr_reserved_tags)) {
+ 	tag = __bt_get(hctx, bt, last_tag);
+ 	if (tag != -1)
+ 		return tag;
+ 
+ 	if (!(data->gfp & __GFP_WAIT))
+ 		return -1;
+ 
+ 	bs = bt_wait_ptr(bt, hctx);
+ 	do {
+ 		bool was_empty;
+ 
+ 		was_empty = list_empty(&wait.task_list);
+ 		prepare_to_wait(&bs->wait, &wait, TASK_UNINTERRUPTIBLE);
+ 
+ 		tag = __bt_get(hctx, bt, last_tag);
+ 		if (tag != -1)
+ 			break;
+ 
+ 		if (was_empty)
+ 			atomic_set(&bs->wait_cnt, bt->wake_cnt);
+ 
+ 		blk_mq_put_ctx(data->ctx);
+ 
+ 		io_schedule();
+ 
+ 		data->ctx = blk_mq_get_ctx(data->q);
+ 		data->hctx = data->q->mq_ops->map_queue(data->q,
+ 				data->ctx->cpu);
+ 		if (data->reserved) {
+ 			bt = &data->hctx->tags->breserved_tags;
+ 		} else {
+ 			last_tag = &data->ctx->last_tag;
+ 			hctx = data->hctx;
+ 			bt = &hctx->tags->bitmap_tags;
+ 		}
+ 		finish_wait(&bs->wait, &wait);
+ 		bs = bt_wait_ptr(bt, hctx);
+ 	} while (1);
+ 
+ 	finish_wait(&bs->wait, &wait);
+ 	return tag;
+ }
+ 
+ static unsigned int __blk_mq_get_tag(struct blk_mq_alloc_data *data)
+ {
+ 	int tag;
+ 
+ 	tag = bt_get(data, &data->hctx->tags->bitmap_tags, data->hctx,
+ 			&data->ctx->last_tag);
+ 	if (tag >= 0)
+ 		return tag + data->hctx->tags->nr_reserved_tags;
+ 
+ 	return BLK_MQ_TAG_FAIL;
++>>>>>>> cb96a42cc1f5 (blk-mq: fix schedule from atomic context)
+ }
+ 
+ static unsigned int __blk_mq_get_reserved_tag(struct blk_mq_alloc_data *data)
+ {
 -	int tag, zero = 0;
++	int tag;
+ 
+ 	if (unlikely(!data->hctx->tags->nr_reserved_tags)) {
  		WARN_ON_ONCE(1);
  		return BLK_MQ_TAG_FAIL;
  	}
  
++<<<<<<< HEAD
 +	tag = percpu_ida_alloc(&tags->reserved_tags, (gfp & __GFP_WAIT) ?
 +			       TASK_UNINTERRUPTIBLE : TASK_RUNNING);
++=======
+ 	tag = bt_get(data, &data->hctx->tags->breserved_tags, NULL, &zero);
++>>>>>>> cb96a42cc1f5 (blk-mq: fix schedule from atomic context)
  	if (tag < 0)
  		return BLK_MQ_TAG_FAIL;
 -
  	return tag;
  }
  
++<<<<<<< HEAD
 +unsigned int blk_mq_get_tag(struct blk_mq_tags *tags, gfp_t gfp, bool reserved)
 +{
 +	if (!reserved)
 +		return __blk_mq_get_tag(tags, gfp);
 +
 +	return __blk_mq_get_reserved_tag(tags, gfp);
++=======
+ unsigned int blk_mq_get_tag(struct blk_mq_alloc_data *data)
+ {
+ 	if (!data->reserved)
+ 		return __blk_mq_get_tag(data);
+ 
+ 	return __blk_mq_get_reserved_tag(data);
+ }
+ 
+ static struct bt_wait_state *bt_wake_ptr(struct blk_mq_bitmap_tags *bt)
+ {
+ 	int i, wake_index;
+ 
+ 	wake_index = bt->wake_index;
+ 	for (i = 0; i < BT_WAIT_QUEUES; i++) {
+ 		struct bt_wait_state *bs = &bt->bs[wake_index];
+ 
+ 		if (waitqueue_active(&bs->wait)) {
+ 			if (wake_index != bt->wake_index)
+ 				bt->wake_index = wake_index;
+ 
+ 			return bs;
+ 		}
+ 
+ 		bt_index_inc(&wake_index);
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static void bt_clear_tag(struct blk_mq_bitmap_tags *bt, unsigned int tag)
+ {
+ 	const int index = TAG_TO_INDEX(bt, tag);
+ 	struct bt_wait_state *bs;
+ 
+ 	/*
+ 	 * The unlock memory barrier need to order access to req in free
+ 	 * path and clearing tag bit
+ 	 */
+ 	clear_bit_unlock(TAG_TO_BIT(bt, tag), &bt->map[index].word);
+ 
+ 	bs = bt_wake_ptr(bt);
+ 	if (bs && atomic_dec_and_test(&bs->wait_cnt)) {
+ 		atomic_set(&bs->wait_cnt, bt->wake_cnt);
+ 		bt_index_inc(&bt->wake_index);
+ 		wake_up(&bs->wait);
+ 	}
++>>>>>>> cb96a42cc1f5 (blk-mq: fix schedule from atomic context)
  }
  
  static void __blk_mq_put_tag(struct blk_mq_tags *tags, unsigned int tag)
diff --cc block/blk-mq-tag.h
index 947ba2c6148e,98696a65d4d4..000000000000
--- a/block/blk-mq-tag.h
+++ b/block/blk-mq-tag.h
@@@ -6,12 -48,12 +6,17 @@@ struct blk_mq_tags
  extern struct blk_mq_tags *blk_mq_init_tags(unsigned int nr_tags, unsigned int reserved_tags, int node);
  extern void blk_mq_free_tags(struct blk_mq_tags *tags);
  
++<<<<<<< HEAD
 +extern unsigned int blk_mq_get_tag(struct blk_mq_tags *tags, gfp_t gfp, bool reserved);
 +extern void blk_mq_wait_for_tags(struct blk_mq_tags *tags);
 +extern void blk_mq_put_tag(struct blk_mq_tags *tags, unsigned int tag);
 +extern void blk_mq_tag_busy_iter(struct blk_mq_tags *tags, void (*fn)(void *data, unsigned long *), void *data);
++=======
+ extern unsigned int blk_mq_get_tag(struct blk_mq_alloc_data *data);
+ extern void blk_mq_put_tag(struct blk_mq_hw_ctx *hctx, unsigned int tag, unsigned int *last_tag);
++>>>>>>> cb96a42cc1f5 (blk-mq: fix schedule from atomic context)
  extern bool blk_mq_has_free_tags(struct blk_mq_tags *tags);
  extern ssize_t blk_mq_tag_sysfs_show(struct blk_mq_tags *tags, char *page);
 -extern void blk_mq_tag_init_last_tag(struct blk_mq_tags *tags, unsigned int *last_tag);
 -extern int blk_mq_tag_update_depth(struct blk_mq_tags *tags, unsigned int depth);
  
  enum {
  	BLK_MQ_TAG_CACHE_MIN	= 1,
diff --cc block/blk-mq.c
index ed81194572d0,43eb3156e110..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -177,74 -189,82 +177,118 @@@ static void blk_mq_rq_ctx_init(struct r
  	ctx->rq_dispatched[rw_is_sync(rw_flags)]++;
  }
  
++<<<<<<< HEAD
 +static struct request *blk_mq_alloc_request_pinned(struct request_queue *q,
 +						   int rw, gfp_t gfp,
 +						   bool reserved)
++=======
+ static struct request *
+ __blk_mq_alloc_request(struct blk_mq_alloc_data *data, int rw)
++>>>>>>> cb96a42cc1f5 (blk-mq: fix schedule from atomic context)
  {
  	struct request *rq;
 -	unsigned int tag;
  
++<<<<<<< HEAD
 +	do {
 +		struct blk_mq_ctx *ctx = blk_mq_get_ctx(q);
 +		struct blk_mq_hw_ctx *hctx = q->mq_ops->map_queue(q, ctx->cpu);
 +
 +		rq = __blk_mq_alloc_request(hctx, gfp & ~__GFP_WAIT, reserved);
 +		if (rq) {
 +			blk_mq_rq_ctx_init(q, ctx, rq, rw);
 +			break;
 +		}
 +
 +		if (gfp & __GFP_WAIT) {
 +			__blk_mq_run_hw_queue(hctx);
 +			blk_mq_put_ctx(ctx);
 +		} else {
 +			blk_mq_put_ctx(ctx);
 +			break;
 +		}
++=======
+ 	tag = blk_mq_get_tag(data);
+ 	if (tag != BLK_MQ_TAG_FAIL) {
+ 		rq = data->hctx->tags->rqs[tag];
+ 
+ 		rq->cmd_flags = 0;
+ 		if (blk_mq_tag_busy(data->hctx)) {
+ 			rq->cmd_flags = REQ_MQ_INFLIGHT;
+ 			atomic_inc(&data->hctx->nr_active);
+ 		}
+ 
+ 		rq->tag = tag;
+ 		blk_mq_rq_ctx_init(data->q, data->ctx, rq, rw);
+ 		return rq;
+ 	}
++>>>>>>> cb96a42cc1f5 (blk-mq: fix schedule from atomic context)
  
 -	return NULL;
 +		blk_mq_wait_for_tags(hctx->tags);
 +	} while (1);
 +
 +	return rq;
  }
  
 -struct request *blk_mq_alloc_request(struct request_queue *q, int rw, gfp_t gfp,
 -		bool reserved)
 +struct request *blk_mq_alloc_request(struct request_queue *q, int rw, gfp_t gfp)
  {
 -	struct blk_mq_ctx *ctx;
 -	struct blk_mq_hw_ctx *hctx;
  	struct request *rq;
+ 	struct blk_mq_alloc_data alloc_data;
  
  	if (blk_mq_queue_enter(q))
  		return NULL;
  
++<<<<<<< HEAD
 +	rq = blk_mq_alloc_request_pinned(q, rw, gfp, false);
 +	if (rq)
 +		blk_mq_put_ctx(rq->mq_ctx);
++=======
+ 	ctx = blk_mq_get_ctx(q);
+ 	hctx = q->mq_ops->map_queue(q, ctx->cpu);
+ 	blk_mq_set_alloc_data(&alloc_data, q, gfp & ~__GFP_WAIT,
+ 			reserved, ctx, hctx);
+ 
+ 	rq = __blk_mq_alloc_request(&alloc_data, rw);
+ 	if (!rq && (gfp & __GFP_WAIT)) {
+ 		__blk_mq_run_hw_queue(hctx);
+ 		blk_mq_put_ctx(ctx);
+ 
+ 		ctx = blk_mq_get_ctx(q);
+ 		hctx = q->mq_ops->map_queue(q, ctx->cpu);
+ 		blk_mq_set_alloc_data(&alloc_data, q, gfp, reserved, ctx,
+ 				hctx);
+ 		rq =  __blk_mq_alloc_request(&alloc_data, rw);
+ 		ctx = alloc_data.ctx;
+ 	}
+ 	blk_mq_put_ctx(ctx);
++>>>>>>> cb96a42cc1f5 (blk-mq: fix schedule from atomic context)
 +	return rq;
 +}
 +
 +struct request *blk_mq_alloc_reserved_request(struct request_queue *q, int rw,
 +					      gfp_t gfp)
 +{
 +	struct request *rq;
 +
 +	if (blk_mq_queue_enter(q))
 +		return NULL;
 +
 +	rq = blk_mq_alloc_request_pinned(q, rw, gfp, true);
 +	if (rq)
 +		blk_mq_put_ctx(rq->mq_ctx);
  	return rq;
  }
 -EXPORT_SYMBOL(blk_mq_alloc_request);
 +EXPORT_SYMBOL(blk_mq_alloc_reserved_request);
 +
 +/*
 + * Re-init and set pdu, if we have it
 + */
 +void blk_mq_rq_init(struct blk_mq_hw_ctx *hctx, struct request *rq)
 +{
 +	blk_rq_init(hctx->queue, rq);
 +
 +	if (hctx->cmd_size)
 +		rq->special = blk_mq_rq_to_pdu(rq);
 +}
  
  static void __blk_mq_free_request(struct blk_mq_hw_ctx *hctx,
  				  struct blk_mq_ctx *ctx, struct request *rq)
@@@ -845,18 -1094,169 +889,102 @@@ void blk_mq_flush_plug_list(struct blk_
  static void blk_mq_bio_to_request(struct request *rq, struct bio *bio)
  {
  	init_request_from_bio(rq, bio);
 -
 -	if (blk_do_io_stat(rq)) {
 -		rq->start_time = jiffies;
 -		blk_account_io_start(rq, 1);
 -	}
 +	blk_account_io_start(rq, 1);
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool blk_mq_merge_queue_io(struct blk_mq_hw_ctx *hctx,
+ 					 struct blk_mq_ctx *ctx,
+ 					 struct request *rq, struct bio *bio)
+ {
+ 	struct request_queue *q = hctx->queue;
+ 
+ 	if (!(hctx->flags & BLK_MQ_F_SHOULD_MERGE)) {
+ 		blk_mq_bio_to_request(rq, bio);
+ 		spin_lock(&ctx->lock);
+ insert_rq:
+ 		__blk_mq_insert_request(hctx, rq, false);
+ 		spin_unlock(&ctx->lock);
+ 		return false;
+ 	} else {
+ 		spin_lock(&ctx->lock);
+ 		if (!blk_mq_attempt_merge(q, ctx, bio)) {
+ 			blk_mq_bio_to_request(rq, bio);
+ 			goto insert_rq;
+ 		}
+ 
+ 		spin_unlock(&ctx->lock);
+ 		__blk_mq_free_request(hctx, ctx, rq);
+ 		return true;
+ 	}
+ }
+ 
+ struct blk_map_ctx {
+ 	struct blk_mq_hw_ctx *hctx;
+ 	struct blk_mq_ctx *ctx;
+ };
+ 
+ static struct request *blk_mq_map_request(struct request_queue *q,
+ 					  struct bio *bio,
+ 					  struct blk_map_ctx *data)
+ {
+ 	struct blk_mq_hw_ctx *hctx;
+ 	struct blk_mq_ctx *ctx;
+ 	struct request *rq;
+ 	int rw = bio_data_dir(bio);
+ 	struct blk_mq_alloc_data alloc_data;
+ 
+ 	if (unlikely(blk_mq_queue_enter(q))) {
+ 		bio_endio(bio, -EIO);
+ 		return NULL;
+ 	}
+ 
+ 	ctx = blk_mq_get_ctx(q);
+ 	hctx = q->mq_ops->map_queue(q, ctx->cpu);
+ 
+ 	if (rw_is_sync(bio->bi_rw))
+ 		rw |= REQ_SYNC;
+ 
+ 	trace_block_getrq(q, bio, rw);
+ 	blk_mq_set_alloc_data(&alloc_data, q, GFP_ATOMIC, false, ctx,
+ 			hctx);
+ 	rq = __blk_mq_alloc_request(&alloc_data, rw);
+ 	if (unlikely(!rq)) {
+ 		__blk_mq_run_hw_queue(hctx);
+ 		blk_mq_put_ctx(ctx);
+ 		trace_block_sleeprq(q, bio, rw);
+ 
+ 		ctx = blk_mq_get_ctx(q);
+ 		hctx = q->mq_ops->map_queue(q, ctx->cpu);
+ 		blk_mq_set_alloc_data(&alloc_data, q,
+ 				__GFP_WAIT|GFP_ATOMIC, false, ctx, hctx);
+ 		rq = __blk_mq_alloc_request(&alloc_data, rw);
+ 		ctx = alloc_data.ctx;
+ 		hctx = alloc_data.hctx;
+ 	}
+ 
+ 	hctx->queued++;
+ 	data->hctx = hctx;
+ 	data->ctx = ctx;
+ 	return rq;
+ }
+ 
+ /*
+  * Multiple hardware queue variant. This will not use per-process plugs,
+  * but will attempt to bypass the hctx queueing if we can go straight to
+  * hardware for SYNC IO.
+  */
++>>>>>>> cb96a42cc1f5 (blk-mq: fix schedule from atomic context)
  static void blk_mq_make_request(struct request_queue *q, struct bio *bio)
  {
 +	struct blk_mq_hw_ctx *hctx;
 +	struct blk_mq_ctx *ctx;
  	const int is_sync = rw_is_sync(bio->bi_rw);
  	const int is_flush_fua = bio->bi_rw & (REQ_FLUSH | REQ_FUA);
 -	struct blk_map_ctx data;
 +	int rw = bio_data_dir(bio);
  	struct request *rq;
 -
 -	blk_queue_bounce(q, &bio);
 -
 -	if (bio_integrity_enabled(bio) && bio_integrity_prep(bio)) {
 -		bio_endio(bio, -EIO);
 -		return;
 -	}
 -
 -	rq = blk_mq_map_request(q, bio, &data);
 -	if (unlikely(!rq))
 -		return;
 -
 -	if (unlikely(is_flush_fua)) {
 -		blk_mq_bio_to_request(rq, bio);
 -		blk_insert_flush(rq);
 -		goto run_queue;
 -	}
 -
 -	if (is_sync) {
 -		int ret;
 -
 -		blk_mq_bio_to_request(rq, bio);
 -		blk_mq_start_request(rq, true);
 -		blk_add_timer(rq);
 -
 -		/*
 -		 * For OK queue, we are done. For error, kill it. Any other
 -		 * error (busy), just add it to our list as we previously
 -		 * would have done
 -		 */
 -		ret = q->mq_ops->queue_rq(data.hctx, rq);
 -		if (ret == BLK_MQ_RQ_QUEUE_OK)
 -			goto done;
 -		else {
 -			__blk_mq_requeue_request(rq);
 -
 -			if (ret == BLK_MQ_RQ_QUEUE_ERROR) {
 -				rq->errors = -EIO;
 -				blk_mq_end_io(rq, rq->errors);
 -				goto done;
 -			}
 -		}
 -	}
 -
 -	if (!blk_mq_merge_queue_io(data.hctx, data.ctx, rq, bio)) {
 -		/*
 -		 * For a SYNC request, send it to the hardware immediately. For
 -		 * an ASYNC request, just ensure that we run it later on. The
 -		 * latter allows for merging opportunities and more efficient
 -		 * dispatching.
 -		 */
 -run_queue:
 -		blk_mq_run_hw_queue(data.hctx, !is_sync || is_flush_fua);
 -	}
 -done:
 -	blk_mq_put_ctx(data.ctx);
 -}
 -
 -/*
 - * Single hardware queue variant. This will attempt to use any per-process
 - * plug for merging and IO deferral.
 - */
 -static void blk_sq_make_request(struct request_queue *q, struct bio *bio)
 -{
 -	const int is_sync = rw_is_sync(bio->bi_rw);
 -	const int is_flush_fua = bio->bi_rw & (REQ_FLUSH | REQ_FUA);
  	unsigned int use_plug, request_count = 0;
 -	struct blk_map_ctx data;
 -	struct request *rq;
  
  	/*
  	 * If we have multiple hardware queues, just go directly to
* Unmerged path block/blk-mq-tag.c
* Unmerged path block/blk-mq-tag.h
* Unmerged path block/blk-mq.c
diff --git a/block/blk-mq.h b/block/blk-mq.h
index 44904eae7f60..5ad2b7d5c709 100644
--- a/block/blk-mq.h
+++ b/block/blk-mq.h
@@ -72,4 +72,27 @@ static inline void blk_mq_put_ctx(struct blk_mq_ctx *ctx)
 	put_cpu();
 }
 
+struct blk_mq_alloc_data {
+	/* input parameter */
+	struct request_queue *q;
+	gfp_t gfp;
+	bool reserved;
+
+	/* input & output parameter */
+	struct blk_mq_ctx *ctx;
+	struct blk_mq_hw_ctx *hctx;
+};
+
+static inline void blk_mq_set_alloc_data(struct blk_mq_alloc_data *data,
+		struct request_queue *q, gfp_t gfp, bool reserved,
+		struct blk_mq_ctx *ctx,
+		struct blk_mq_hw_ctx *hctx)
+{
+	data->q = q;
+	data->gfp = gfp;
+	data->reserved = reserved;
+	data->ctx = ctx;
+	data->hctx = hctx;
+}
+
 #endif
