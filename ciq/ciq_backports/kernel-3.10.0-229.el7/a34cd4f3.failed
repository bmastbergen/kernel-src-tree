vti4: Use the on xfrm_lookup returned dst_entry directly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit a34cd4f31919119d8ab2d42330fb8364aa430551
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a34cd4f3.failed

We need to be protocol family indepenent to support
inter addresss family tunneling with vti. So use a
dst_entry instead of the ipv4 rtable in vti_tunnel_xmit.

	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit a34cd4f31919119d8ab2d42330fb8364aa430551)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ip_vti.c
diff --cc net/ipv4/ip_vti.c
index be11cdadfc8b,0dc341ddd1aa..000000000000
--- a/net/ipv4/ip_vti.c
+++ b/net/ipv4/ip_vti.c
@@@ -95,28 -128,26 +95,43 @@@ static int vti_rcv(struct sk_buff *skb
  static netdev_tx_t vti_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)
  {
  	struct ip_tunnel *tunnel = netdev_priv(dev);
++<<<<<<< HEAD
 +	struct iphdr  *tiph = &tunnel->parms.iph;
 +	u8     tos;
 +	struct rtable *rt;		/* Route to the other host */
++=======
+ 	struct dst_entry *dst = skb_dst(skb);
++>>>>>>> a34cd4f31919 (vti4: Use the on xfrm_lookup returned dst_entry directly)
  	struct net_device *tdev;	/* Device to other host */
 -	struct flowi fl;
 +	struct iphdr  *old_iph = ip_hdr(skb);
 +	__be32 dst = tiph->daddr;
 +	struct flowi4 fl4;
  	int err;
  
  	if (skb->protocol != htons(ETH_P_IP))
  		goto tx_error;
  
 -	memset(&fl, 0, sizeof(fl));
 -	skb->mark = be32_to_cpu(tunnel->parms.o_key);
 -	xfrm_decode_session(skb, &fl, AF_INET);
 -
 +	tos = old_iph->tos;
 +
++<<<<<<< HEAD
 +	memset(&fl4, 0, sizeof(fl4));
 +	flowi4_init_output(&fl4, tunnel->parms.link,
 +			   be32_to_cpu(tunnel->parms.o_key), RT_TOS(tos),
 +			   RT_SCOPE_UNIVERSE,
 +			   IPPROTO_IPIP, 0,
 +			   dst, tiph->saddr, 0, 0);
 +	rt = ip_route_output_key(dev_net(dev), &fl4);
 +	if (IS_ERR(rt)) {
++=======
+ 	if (!dst) {
+ 		dev->stats.tx_carrier_errors++;
+ 		goto tx_error_icmp;
+ 	}
+ 
+ 	dst_hold(dst);
+ 	dst = xfrm_lookup(tunnel->net, dst, &fl, NULL, 0);
+ 	if (IS_ERR(dst)) {
++>>>>>>> a34cd4f31919 (vti4: Use the on xfrm_lookup returned dst_entry directly)
  		dev->stats.tx_carrier_errors++;
  		goto tx_error_icmp;
  	}
@@@ -147,9 -179,8 +162,14 @@@
  	}
  
  	memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
++<<<<<<< HEAD
 +	skb_dst_drop(skb);
 +	skb_dst_set(skb, &rt->dst);
 +	nf_reset(skb);
++=======
+ 	skb_scrub_packet(skb, !net_eq(tunnel->net, dev_net(dev)));
+ 	skb_dst_set(skb, dst);
++>>>>>>> a34cd4f31919 (vti4: Use the on xfrm_lookup returned dst_entry directly)
  	skb->dev = skb_dst(skb)->dev;
  
  	err = dst_output(skb);
* Unmerged path net/ipv4/ip_vti.c
