drm/i915: add DP 1.2 MST support (v0.7)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] i915: add DP 1.2 MST support (v0.7) (Dave Airlie) [1140440]
Rebuild_FUZZ: 94.59%
commit-author Dave Airlie <airlied@redhat.com>
commit 0e32b39ceed665bfa4a77a4bc307b6652b991632
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0e32b39c.failed

This adds DP 1.2 MST support on Haswell systems.

Notes:
a) this reworks irq handling for DP MST ports, so that we can
avoid the mode config locking in the current hpd handlers, as
we need to process up/down msgs at a better time.

Changes since v0.1:
use PORT_PCH_HOTPLUG to detect short vs long pulses
add a workqueue to deal with digital events as they can get blocked on the
main workqueue beyong mode_config mutex
fix a bunch of modeset checker warnings
acks irqs in the driver
cleanup the MST encoders

Changes since v0.2:
check irq status again in work handler
move around bring up and tear down to fix DPMS on/off
use path properties.

Changes since v0.3:
updates for mst apis
more state checker fixes
irq handling improvements
fbcon handling support
improved reference counting of link - fixes redocking.

Changes since v0.4:
handle gpu reset hpd reinit without oopsing
check link status on HPD irqs
fix suspend/resume

Changes since v0.5:
use proper functions to get max link/lane counts
fix another checker backtrace - due to connectors disappearing.
set output type in more places fro, unknown->displayport
don't talk to devices if no HPD asserted
check mst on short irqs only
check link status properly
rebase onto prepping irq changes.
drop unsued force_act

Changes since v0.6:
cleanup unused struct entry.

[airlied: fix some sparse warnings].

	Reviewed-by: Todd Previte <tprevite@gmail.com>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 0e32b39ceed665bfa4a77a4bc307b6652b991632)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/Makefile
#	drivers/gpu/drm/i915/i915_dma.c
#	drivers/gpu/drm/i915/i915_drv.c
#	drivers/gpu/drm/i915/i915_irq.c
#	drivers/gpu/drm/i915/intel_ddi.c
#	drivers/gpu/drm/i915/intel_display.c
#	drivers/gpu/drm/i915/intel_dp.c
#	drivers/gpu/drm/i915/intel_drv.h
#	drivers/gpu/drm/i915/intel_fbdev.c
#	drivers/gpu/drm/i915/intel_opregion.c
diff --cc drivers/gpu/drm/i915/Makefile
index b8449a84a0dc,91bd167e1cb7..000000000000
--- a/drivers/gpu/drm/i915/Makefile
+++ b/drivers/gpu/drm/i915/Makefile
@@@ -13,43 -23,58 +13,52 @@@ i915-y := i915_drv.o i915_dma.o i915_ir
  	  i915_gem_evict.o \
  	  i915_gem_execbuffer.o \
  	  i915_gem_gtt.o \
 -	  i915_gem.o \
  	  i915_gem_stolen.o \
  	  i915_gem_tiling.o \
 -	  i915_gem_userptr.o \
 -	  i915_gpu_error.o \
 -	  i915_irq.o \
 +	  i915_sysfs.o \
  	  i915_trace_points.o \
 -	  intel_ringbuffer.o \
 -	  intel_uncore.o
 -
 -# autogenerated null render state
 -i915-y += intel_renderstate_gen6.o \
 -	  intel_renderstate_gen7.o \
 -	  intel_renderstate_gen8.o
 -
 -# modesetting core code
 -i915-y += intel_bios.o \
 +	  i915_ums.o \
  	  intel_display.o \
 -	  intel_modes.o \
 -	  intel_overlay.o \
 -	  intel_sideband.o \
 -	  intel_sprite.o
 -i915-$(CONFIG_ACPI)		+= intel_acpi.o intel_opregion.o
 -i915-$(CONFIG_DRM_I915_FBDEV)	+= intel_fbdev.o
 -
 -# modesetting output/encoder code
 -i915-y += dvo_ch7017.o \
 -	  dvo_ch7xxx.o \
 -	  dvo_ivch.o \
 -	  dvo_ns2501.o \
 -	  dvo_sil164.o \
 -	  dvo_tfp410.o \
  	  intel_crt.o \
 +	  intel_lvds.o \
 +	  intel_bios.o \
  	  intel_ddi.o \
  	  intel_dp.o \
++<<<<<<< HEAD
++=======
+ 	  intel_dp_mst.o \
+ 	  intel_dsi_cmd.o \
+ 	  intel_dsi.o \
+ 	  intel_dsi_pll.o \
+ 	  intel_dsi_panel_vbt.o \
+ 	  intel_dvo.o \
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  	  intel_hdmi.o \
 -	  intel_i2c.o \
 -	  intel_lvds.o \
 -	  intel_panel.o \
  	  intel_sdvo.o \
 -	  intel_tv.o
 +	  intel_modes.o \
 +	  intel_panel.o \
 +	  intel_pm.o \
 +	  intel_i2c.o \
 +	  intel_fb.o \
 +	  intel_tv.o \
 +	  intel_dvo.o \
 +	  intel_ringbuffer.o \
 +	  intel_overlay.o \
 +	  intel_sprite.o \
 +	  intel_opregion.o \
 +	  intel_sideband.o \
 +	  intel_uncore.o \
 +	  dvo_ch7xxx.o \
 +	  dvo_ch7017.o \
 +	  dvo_ivch.o \
 +	  dvo_tfp410.o \
 +	  dvo_sil164.o \
 +	  dvo_ns2501.o \
 +	  i915_gem_dmabuf.o
 +
 +i915-$(CONFIG_COMPAT)   += i915_ioc32.o
  
 -# legacy horrors
 -i915-y += i915_dma.o \
 -	  i915_ums.o
 +i915-$(CONFIG_ACPI)	+= intel_acpi.o
  
  obj-$(CONFIG_DRM_I915)  += i915.o
  
diff --cc drivers/gpu/drm/i915/i915_dma.c
index 661cf9b87340,d335c46ec6bc..000000000000
--- a/drivers/gpu/drm/i915/i915_dma.c
+++ b/drivers/gpu/drm/i915/i915_dma.c
@@@ -1606,13 -1717,15 +1606,22 @@@ int i915_driver_load(struct drm_device 
  		goto out_mtrrfree;
  	}
  
++<<<<<<< HEAD
 +	/* This must be called before any calls to HAS_PCH_* */
 +	intel_detect_pch(dev);
++=======
+ 	dev_priv->dp_wq = alloc_ordered_workqueue("i915-dp", 0);
+ 	if (dev_priv->dp_wq == NULL) {
+ 		DRM_ERROR("Failed to create our dp workqueue.\n");
+ 		ret = -ENOMEM;
+ 		goto out_freewq;
+ 	}
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  
  	intel_irq_init(dev);
 +	intel_pm_init(dev);
  	intel_uncore_sanitize(dev);
 +	intel_uncore_init(dev);
  
  	/* Try to make sure MCHBAR is enabled before poking at it */
  	intel_setup_mchbar(dev);
@@@ -1683,6 -1798,9 +1692,12 @@@ out_gem_unload
  
  	intel_teardown_gmbus(dev);
  	intel_teardown_mchbar(dev);
++<<<<<<< HEAD
++=======
+ 	pm_qos_remove_request(&dev_priv->pm_qos);
+ 	destroy_workqueue(dev_priv->dp_wq);
+ out_freewq:
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  	destroy_workqueue(dev_priv->wq);
  out_mtrrfree:
  	arch_phys_wc_del(dev_priv->gtt.mtrr);
diff --cc drivers/gpu/drm/i915/i915_drv.c
index 2ad27880cd04,a361bb9bc243..000000000000
--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@@ -491,17 -516,24 +491,27 @@@ static int i915_drm_freeze(struct drm_d
  			return error;
  		}
  
++<<<<<<< HEAD
 +		cancel_delayed_work_sync(&dev_priv->rps.delayed_resume_work);
++=======
+ 		flush_delayed_work(&dev_priv->rps.delayed_resume_work);
+ 
+ 
+ 		intel_suspend_gt_powersave(dev);
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  
 +		drm_irq_uninstall(dev);
 +		dev_priv->enable_hotplug_processing = false;
  		/*
  		 * Disable CRTCs directly since we want to preserve sw state
  		 * for _thaw.
  		 */
 -		drm_modeset_lock_all(dev);
 -		for_each_crtc(dev, crtc) {
 +		list_for_each_entry(crtc, &dev->mode_config.crtc_list, head)
  			dev_priv->display.crtc_disable(crtc);
 -		}
 -		drm_modeset_unlock_all(dev);
  
+ 		intel_dp_mst_suspend(dev);
+ 		intel_runtime_pm_disable_interrupts(dev);
+ 
  		intel_modeset_suspend_hw(dev);
  	}
  
diff --cc drivers/gpu/drm/i915/i915_irq.c
index 94d4a6c2b196,07e1a409e488..000000000000
--- a/drivers/gpu/drm/i915/i915_irq.c
+++ b/drivers/gpu/drm/i915/i915_irq.c
@@@ -1033,7 -1845,10 +1033,14 @@@ static inline void intel_hpd_irq_handle
  	 * queue for otherwise the flush_work in the pageflip code will
  	 * deadlock.
  	 */
++<<<<<<< HEAD
 +	schedule_work(&dev_priv->hotplug_work);
++=======
+ 	if (queue_dig)
+ 		queue_work(dev_priv->dp_wq, &dev_priv->dig_port_work);
+ 	if (queue_hp)
+ 		schedule_work(&dev_priv->hotplug_work);
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  }
  
  static void gmbus_irq_handler(struct drm_device *dev)
diff --cc drivers/gpu/drm/i915/intel_ddi.c
index a069b5e2a2d2,9b1542f1cf01..000000000000
--- a/drivers/gpu/drm/i915/intel_ddi.c
+++ b/drivers/gpu/drm/i915/intel_ddi.c
@@@ -539,6 -553,96 +542,99 @@@ static void wrpll_update_rnp(uint64_t f
  	/* Otherwise a < c && b >= d, do nothing */
  }
  
++<<<<<<< HEAD
++=======
+ static int intel_ddi_calc_wrpll_link(struct drm_i915_private *dev_priv,
+ 				     int reg)
+ {
+ 	int refclk = LC_FREQ;
+ 	int n, p, r;
+ 	u32 wrpll;
+ 
+ 	wrpll = I915_READ(reg);
+ 	switch (wrpll & WRPLL_PLL_REF_MASK) {
+ 	case WRPLL_PLL_SSC:
+ 	case WRPLL_PLL_NON_SSC:
+ 		/*
+ 		 * We could calculate spread here, but our checking
+ 		 * code only cares about 5% accuracy, and spread is a max of
+ 		 * 0.5% downspread.
+ 		 */
+ 		refclk = 135;
+ 		break;
+ 	case WRPLL_PLL_LCPLL:
+ 		refclk = LC_FREQ;
+ 		break;
+ 	default:
+ 		WARN(1, "bad wrpll refclk\n");
+ 		return 0;
+ 	}
+ 
+ 	r = wrpll & WRPLL_DIVIDER_REF_MASK;
+ 	p = (wrpll & WRPLL_DIVIDER_POST_MASK) >> WRPLL_DIVIDER_POST_SHIFT;
+ 	n = (wrpll & WRPLL_DIVIDER_FB_MASK) >> WRPLL_DIVIDER_FB_SHIFT;
+ 
+ 	/* Convert to KHz, p & r have a fixed point portion */
+ 	return (refclk * n * 100) / (p * r);
+ }
+ 
+ void intel_ddi_clock_get(struct intel_encoder *encoder,
+ 			 struct intel_crtc_config *pipe_config)
+ {
+ 	struct drm_i915_private *dev_priv = encoder->base.dev->dev_private;
+ 	int link_clock = 0;
+ 	u32 val, pll;
+ 
+ 	val = pipe_config->ddi_pll_sel;
+ 	switch (val & PORT_CLK_SEL_MASK) {
+ 	case PORT_CLK_SEL_LCPLL_810:
+ 		link_clock = 81000;
+ 		break;
+ 	case PORT_CLK_SEL_LCPLL_1350:
+ 		link_clock = 135000;
+ 		break;
+ 	case PORT_CLK_SEL_LCPLL_2700:
+ 		link_clock = 270000;
+ 		break;
+ 	case PORT_CLK_SEL_WRPLL1:
+ 		link_clock = intel_ddi_calc_wrpll_link(dev_priv, WRPLL_CTL1);
+ 		break;
+ 	case PORT_CLK_SEL_WRPLL2:
+ 		link_clock = intel_ddi_calc_wrpll_link(dev_priv, WRPLL_CTL2);
+ 		break;
+ 	case PORT_CLK_SEL_SPLL:
+ 		pll = I915_READ(SPLL_CTL) & SPLL_PLL_FREQ_MASK;
+ 		if (pll == SPLL_PLL_FREQ_810MHz)
+ 			link_clock = 81000;
+ 		else if (pll == SPLL_PLL_FREQ_1350MHz)
+ 			link_clock = 135000;
+ 		else if (pll == SPLL_PLL_FREQ_2700MHz)
+ 			link_clock = 270000;
+ 		else {
+ 			WARN(1, "bad spll freq\n");
+ 			return;
+ 		}
+ 		break;
+ 	default:
+ 		WARN(1, "bad port clock sel\n");
+ 		return;
+ 	}
+ 
+ 	pipe_config->port_clock = link_clock * 2;
+ 
+ 	if (pipe_config->has_pch_encoder)
+ 		pipe_config->adjusted_mode.crtc_clock =
+ 			intel_dotclock_calculate(pipe_config->port_clock,
+ 						 &pipe_config->fdi_m_n);
+ 	else if (pipe_config->has_dp_encoder)
+ 		pipe_config->adjusted_mode.crtc_clock =
+ 			intel_dotclock_calculate(pipe_config->port_clock,
+ 						 &pipe_config->dp_m_n);
+ 	else
+ 		pipe_config->adjusted_mode.crtc_clock = pipe_config->port_clock;
+ }
+ 
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  static void
  intel_ddi_calculate_wrpll(int clock /* in Hz */,
  			  unsigned *r2_out, unsigned *n2_out, unsigned *p_out)
@@@ -1200,10 -1307,15 +1328,20 @@@ void intel_ddi_prepare_link_retrain(str
  			intel_wait_ddi_buf_idle(dev_priv, port);
  	}
  
- 	val = DP_TP_CTL_ENABLE | DP_TP_CTL_MODE_SST |
+ 	val = DP_TP_CTL_ENABLE |
  	      DP_TP_CTL_LINK_TRAIN_PAT1 | DP_TP_CTL_SCRAMBLE_DISABLE;
++<<<<<<< HEAD
 +	if (intel_dp->link_configuration[1] & DP_LANE_COUNT_ENHANCED_FRAME_EN)
 +		val |= DP_TP_CTL_ENHANCED_FRAME_ENABLE;
++=======
+ 	if (intel_dp->is_mst)
+ 		val |= DP_TP_CTL_MODE_MST;
+ 	else {
+ 		val |= DP_TP_CTL_MODE_SST;
+ 		if (drm_dp_enhanced_frame_cap(intel_dp->dpcd))
+ 			val |= DP_TP_CTL_ENHANCED_FRAME_ENABLE;
+ 	}
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  	I915_WRITE(DP_TP_CTL(port), val);
  	POSTING_READ(DP_TP_CTL(port));
  
diff --cc drivers/gpu/drm/i915/intel_display.c
index aad6f7bfc589,7b542b477a4e..000000000000
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@@ -52,8 -87,28 +52,16 @@@ static void ironlake_crtc_clock_get(str
  
  static int intel_set_mode(struct drm_crtc *crtc, struct drm_display_mode *mode,
  			  int x, int y, struct drm_framebuffer *old_fb);
 -static int intel_framebuffer_init(struct drm_device *dev,
 -				  struct intel_framebuffer *ifb,
 -				  struct drm_mode_fb_cmd2 *mode_cmd,
 -				  struct drm_i915_gem_object *obj);
 -static void intel_dp_set_m_n(struct intel_crtc *crtc);
 -static void i9xx_set_pipeconf(struct intel_crtc *intel_crtc);
 -static void intel_set_pipe_timings(struct intel_crtc *intel_crtc);
 -static void intel_cpu_transcoder_set_m_n(struct intel_crtc *crtc,
 -					 struct intel_link_m_n *m_n);
 -static void ironlake_set_pipeconf(struct drm_crtc *crtc);
 -static void haswell_set_pipeconf(struct drm_crtc *crtc);
 -static void intel_set_pipe_csc(struct drm_crtc *crtc);
 -static void vlv_prepare_pll(struct intel_crtc *crtc);
 +
  
+ static struct intel_encoder *intel_find_encoder(struct intel_connector *connector, int pipe)
+ {
+ 	if (!connector->mst_port)
+ 		return connector->encoder;
+ 	else
+ 		return &connector->mst_port->mst_encoders[pipe]->base;
+ }
+ 
  typedef struct {
  	int	min, max;
  } intel_range_t;
@@@ -3462,22 -4138,18 +3470,32 @@@ static void haswell_crtc_enable(struct 
  	if (intel_crtc->config.has_pch_encoder)
  		lpt_pch_enable(crtc);
  
++<<<<<<< HEAD
 +	mutex_lock(&dev->struct_mutex);
 +	intel_update_fbc(dev);
 +	mutex_unlock(&dev->struct_mutex);
++=======
+ 	if (intel_crtc->config.dp_encoder_is_mst)
+ 		intel_ddi_set_vc_payload_alloc(crtc, true);
+ 
+ 	for_each_encoder_on_crtc(dev, crtc, encoder) {
+ 		encoder->enable(encoder);
+ 		intel_opregion_notify_encoder(encoder, true);
+ 	}
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
 +
 +	for_each_encoder_on_crtc(dev, crtc, encoder)
 +		encoder->enable(encoder);
  
 -	/* If we change the relative order between pipe/planes enabling, we need
 -	 * to change the workaround. */
 -	haswell_mode_set_planes_workaround(intel_crtc);
 -	intel_crtc_enable_planes(crtc);
 +	/*
 +	 * There seems to be a race in PCH platform hw (at least on some
 +	 * outputs) where an enabled pipe still completes any pageflip right
 +	 * away (as if the pipe is off) instead of waiting for vblank. As soon
 +	 * as the first vblank happend, everything works as expected. Hence just
 +	 * wait for one vblank before returning to avoid strange things
 +	 * happening.
 +	 */
 +	intel_wait_for_vblank(dev, intel_crtc->pipe);
  }
  
  static void ironlake_pfit_disable(struct intel_crtc *crtc)
@@@ -3702,6 -4314,294 +3723,297 @@@ static void i9xx_pfit_enable(struct int
  	I915_WRITE(BCLRPAT(crtc->pipe), 0);
  }
  
++<<<<<<< HEAD
++=======
+ static enum intel_display_power_domain port_to_power_domain(enum port port)
+ {
+ 	switch (port) {
+ 	case PORT_A:
+ 		return POWER_DOMAIN_PORT_DDI_A_4_LANES;
+ 	case PORT_B:
+ 		return POWER_DOMAIN_PORT_DDI_B_4_LANES;
+ 	case PORT_C:
+ 		return POWER_DOMAIN_PORT_DDI_C_4_LANES;
+ 	case PORT_D:
+ 		return POWER_DOMAIN_PORT_DDI_D_4_LANES;
+ 	default:
+ 		WARN_ON_ONCE(1);
+ 		return POWER_DOMAIN_PORT_OTHER;
+ 	}
+ }
+ 
+ #define for_each_power_domain(domain, mask)				\
+ 	for ((domain) = 0; (domain) < POWER_DOMAIN_NUM; (domain)++)	\
+ 		if ((1 << (domain)) & (mask))
+ 
+ enum intel_display_power_domain
+ intel_display_port_power_domain(struct intel_encoder *intel_encoder)
+ {
+ 	struct drm_device *dev = intel_encoder->base.dev;
+ 	struct intel_digital_port *intel_dig_port;
+ 
+ 	switch (intel_encoder->type) {
+ 	case INTEL_OUTPUT_UNKNOWN:
+ 		/* Only DDI platforms should ever use this output type */
+ 		WARN_ON_ONCE(!HAS_DDI(dev));
+ 	case INTEL_OUTPUT_DISPLAYPORT:
+ 	case INTEL_OUTPUT_HDMI:
+ 	case INTEL_OUTPUT_EDP:
+ 		intel_dig_port = enc_to_dig_port(&intel_encoder->base);
+ 		return port_to_power_domain(intel_dig_port->port);
+ 	case INTEL_OUTPUT_DP_MST:
+ 		intel_dig_port = enc_to_mst(&intel_encoder->base)->primary;
+ 		return port_to_power_domain(intel_dig_port->port);
+ 	case INTEL_OUTPUT_ANALOG:
+ 		return POWER_DOMAIN_PORT_CRT;
+ 	case INTEL_OUTPUT_DSI:
+ 		return POWER_DOMAIN_PORT_DSI;
+ 	default:
+ 		return POWER_DOMAIN_PORT_OTHER;
+ 	}
+ }
+ 
+ static unsigned long get_crtc_power_domains(struct drm_crtc *crtc)
+ {
+ 	struct drm_device *dev = crtc->dev;
+ 	struct intel_encoder *intel_encoder;
+ 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
+ 	enum pipe pipe = intel_crtc->pipe;
+ 	unsigned long mask;
+ 	enum transcoder transcoder;
+ 
+ 	transcoder = intel_pipe_to_cpu_transcoder(dev->dev_private, pipe);
+ 
+ 	mask = BIT(POWER_DOMAIN_PIPE(pipe));
+ 	mask |= BIT(POWER_DOMAIN_TRANSCODER(transcoder));
+ 	if (intel_crtc->config.pch_pfit.enabled ||
+ 	    intel_crtc->config.pch_pfit.force_thru)
+ 		mask |= BIT(POWER_DOMAIN_PIPE_PANEL_FITTER(pipe));
+ 
+ 	for_each_encoder_on_crtc(dev, crtc, intel_encoder)
+ 		mask |= BIT(intel_display_port_power_domain(intel_encoder));
+ 
+ 	return mask;
+ }
+ 
+ void intel_display_set_init_power(struct drm_i915_private *dev_priv,
+ 				  bool enable)
+ {
+ 	if (dev_priv->power_domains.init_power_on == enable)
+ 		return;
+ 
+ 	if (enable)
+ 		intel_display_power_get(dev_priv, POWER_DOMAIN_INIT);
+ 	else
+ 		intel_display_power_put(dev_priv, POWER_DOMAIN_INIT);
+ 
+ 	dev_priv->power_domains.init_power_on = enable;
+ }
+ 
+ static void modeset_update_crtc_power_domains(struct drm_device *dev)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	unsigned long pipe_domains[I915_MAX_PIPES] = { 0, };
+ 	struct intel_crtc *crtc;
+ 
+ 	/*
+ 	 * First get all needed power domains, then put all unneeded, to avoid
+ 	 * any unnecessary toggling of the power wells.
+ 	 */
+ 	for_each_intel_crtc(dev, crtc) {
+ 		enum intel_display_power_domain domain;
+ 
+ 		if (!crtc->base.enabled)
+ 			continue;
+ 
+ 		pipe_domains[crtc->pipe] = get_crtc_power_domains(&crtc->base);
+ 
+ 		for_each_power_domain(domain, pipe_domains[crtc->pipe])
+ 			intel_display_power_get(dev_priv, domain);
+ 	}
+ 
+ 	for_each_intel_crtc(dev, crtc) {
+ 		enum intel_display_power_domain domain;
+ 
+ 		for_each_power_domain(domain, crtc->enabled_power_domains)
+ 			intel_display_power_put(dev_priv, domain);
+ 
+ 		crtc->enabled_power_domains = pipe_domains[crtc->pipe];
+ 	}
+ 
+ 	intel_display_set_init_power(dev_priv, false);
+ }
+ 
+ /* returns HPLL frequency in kHz */
+ static int valleyview_get_vco(struct drm_i915_private *dev_priv)
+ {
+ 	int hpll_freq, vco_freq[] = { 800, 1600, 2000, 2400 };
+ 
+ 	/* Obtain SKU information */
+ 	mutex_lock(&dev_priv->dpio_lock);
+ 	hpll_freq = vlv_cck_read(dev_priv, CCK_FUSE_REG) &
+ 		CCK_FUSE_HPLL_FREQ_MASK;
+ 	mutex_unlock(&dev_priv->dpio_lock);
+ 
+ 	return vco_freq[hpll_freq] * 1000;
+ }
+ 
+ static void vlv_update_cdclk(struct drm_device *dev)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 
+ 	dev_priv->vlv_cdclk_freq = dev_priv->display.get_display_clock_speed(dev);
+ 	DRM_DEBUG_DRIVER("Current CD clock rate: %d kHz",
+ 			 dev_priv->vlv_cdclk_freq);
+ 
+ 	/*
+ 	 * Program the gmbus_freq based on the cdclk frequency.
+ 	 * BSpec erroneously claims we should aim for 4MHz, but
+ 	 * in fact 1MHz is the correct frequency.
+ 	 */
+ 	I915_WRITE(GMBUSFREQ_VLV, dev_priv->vlv_cdclk_freq);
+ }
+ 
+ /* Adjust CDclk dividers to allow high res or save power if possible */
+ static void valleyview_set_cdclk(struct drm_device *dev, int cdclk)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	u32 val, cmd;
+ 
+ 	WARN_ON(dev_priv->display.get_display_clock_speed(dev) != dev_priv->vlv_cdclk_freq);
+ 
+ 	if (cdclk >= 320000) /* jump to highest voltage for 400MHz too */
+ 		cmd = 2;
+ 	else if (cdclk == 266667)
+ 		cmd = 1;
+ 	else
+ 		cmd = 0;
+ 
+ 	mutex_lock(&dev_priv->rps.hw_lock);
+ 	val = vlv_punit_read(dev_priv, PUNIT_REG_DSPFREQ);
+ 	val &= ~DSPFREQGUAR_MASK;
+ 	val |= (cmd << DSPFREQGUAR_SHIFT);
+ 	vlv_punit_write(dev_priv, PUNIT_REG_DSPFREQ, val);
+ 	if (wait_for((vlv_punit_read(dev_priv, PUNIT_REG_DSPFREQ) &
+ 		      DSPFREQSTAT_MASK) == (cmd << DSPFREQSTAT_SHIFT),
+ 		     50)) {
+ 		DRM_ERROR("timed out waiting for CDclk change\n");
+ 	}
+ 	mutex_unlock(&dev_priv->rps.hw_lock);
+ 
+ 	if (cdclk == 400000) {
+ 		u32 divider, vco;
+ 
+ 		vco = valleyview_get_vco(dev_priv);
+ 		divider = DIV_ROUND_CLOSEST(vco << 1, cdclk) - 1;
+ 
+ 		mutex_lock(&dev_priv->dpio_lock);
+ 		/* adjust cdclk divider */
+ 		val = vlv_cck_read(dev_priv, CCK_DISPLAY_CLOCK_CONTROL);
+ 		val &= ~DISPLAY_FREQUENCY_VALUES;
+ 		val |= divider;
+ 		vlv_cck_write(dev_priv, CCK_DISPLAY_CLOCK_CONTROL, val);
+ 
+ 		if (wait_for((vlv_cck_read(dev_priv, CCK_DISPLAY_CLOCK_CONTROL) &
+ 			      DISPLAY_FREQUENCY_STATUS) == (divider << DISPLAY_FREQUENCY_STATUS_SHIFT),
+ 			     50))
+ 			DRM_ERROR("timed out waiting for CDclk change\n");
+ 		mutex_unlock(&dev_priv->dpio_lock);
+ 	}
+ 
+ 	mutex_lock(&dev_priv->dpio_lock);
+ 	/* adjust self-refresh exit latency value */
+ 	val = vlv_bunit_read(dev_priv, BUNIT_REG_BISOC);
+ 	val &= ~0x7f;
+ 
+ 	/*
+ 	 * For high bandwidth configs, we set a higher latency in the bunit
+ 	 * so that the core display fetch happens in time to avoid underruns.
+ 	 */
+ 	if (cdclk == 400000)
+ 		val |= 4500 / 250; /* 4.5 usec */
+ 	else
+ 		val |= 3000 / 250; /* 3.0 usec */
+ 	vlv_bunit_write(dev_priv, BUNIT_REG_BISOC, val);
+ 	mutex_unlock(&dev_priv->dpio_lock);
+ 
+ 	vlv_update_cdclk(dev);
+ }
+ 
+ static int valleyview_calc_cdclk(struct drm_i915_private *dev_priv,
+ 				 int max_pixclk)
+ {
+ 	int vco = valleyview_get_vco(dev_priv);
+ 	int freq_320 = (vco <<  1) % 320000 != 0 ? 333333 : 320000;
+ 
+ 	/*
+ 	 * Really only a few cases to deal with, as only 4 CDclks are supported:
+ 	 *   200MHz
+ 	 *   267MHz
+ 	 *   320/333MHz (depends on HPLL freq)
+ 	 *   400MHz
+ 	 * So we check to see whether we're above 90% of the lower bin and
+ 	 * adjust if needed.
+ 	 *
+ 	 * We seem to get an unstable or solid color picture at 200MHz.
+ 	 * Not sure what's wrong. For now use 200MHz only when all pipes
+ 	 * are off.
+ 	 */
+ 	if (max_pixclk > freq_320*9/10)
+ 		return 400000;
+ 	else if (max_pixclk > 266667*9/10)
+ 		return freq_320;
+ 	else if (max_pixclk > 0)
+ 		return 266667;
+ 	else
+ 		return 200000;
+ }
+ 
+ /* compute the max pixel clock for new configuration */
+ static int intel_mode_max_pixclk(struct drm_i915_private *dev_priv)
+ {
+ 	struct drm_device *dev = dev_priv->dev;
+ 	struct intel_crtc *intel_crtc;
+ 	int max_pixclk = 0;
+ 
+ 	for_each_intel_crtc(dev, intel_crtc) {
+ 		if (intel_crtc->new_enabled)
+ 			max_pixclk = max(max_pixclk,
+ 					 intel_crtc->new_config->adjusted_mode.crtc_clock);
+ 	}
+ 
+ 	return max_pixclk;
+ }
+ 
+ static void valleyview_modeset_global_pipes(struct drm_device *dev,
+ 					    unsigned *prepare_pipes)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct intel_crtc *intel_crtc;
+ 	int max_pixclk = intel_mode_max_pixclk(dev_priv);
+ 
+ 	if (valleyview_calc_cdclk(dev_priv, max_pixclk) ==
+ 	    dev_priv->vlv_cdclk_freq)
+ 		return;
+ 
+ 	/* disable/enable all currently active pipes while we change cdclk */
+ 	for_each_intel_crtc(dev, intel_crtc)
+ 		if (intel_crtc->base.enabled)
+ 			*prepare_pipes |= (1 << intel_crtc->pipe);
+ }
+ 
+ static void valleyview_modeset_global_resources(struct drm_device *dev)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	int max_pixclk = intel_mode_max_pixclk(dev_priv);
+ 	int req_cdclk = valleyview_calc_cdclk(dev_priv, max_pixclk);
+ 
+ 	if (req_cdclk != dev_priv->vlv_cdclk_freq)
+ 		valleyview_set_cdclk(dev, req_cdclk);
+ 	modeset_update_crtc_power_domains(dev);
+ }
+ 
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  static void valleyview_crtc_enable(struct drm_crtc *crtc)
  {
  	struct drm_device *dev = crtc->dev;
@@@ -3977,8 -5019,12 +4289,12 @@@ static void intel_connector_check_state
  
  		DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
  			      connector->base.base.id,
 -			      connector->base.name);
 +			      drm_get_connector_name(&connector->base));
  
+ 		/* there is no real hw state for MST connectors */
+ 		if (connector->mst_port)
+ 			return;
+ 
  		WARN(connector->base.dpms == DRM_MODE_DPMS_OFF,
  		     "wrong connector dpms state\n");
  		WARN(connector->base.encoder != &encoder->base,
@@@ -9235,11 -11140,11 +9559,11 @@@ intel_modeset_stage_output_state(struc
  		}
  
  		/* Make sure the new CRTC will work with the encoder */
 -		if (!drm_encoder_crtc_ok(&connector->new_encoder->base,
 -					 new_crtc)) {
 +		if (!intel_encoder_crtc_ok(&connector->new_encoder->base,
 +					   new_crtc)) {
  			return -EINVAL;
  		}
- 		connector->encoder->new_crtc = to_intel_crtc(new_crtc);
+ 		connector->new_encoder->new_crtc = to_intel_crtc(new_crtc);
  
  		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] to [CRTC:%d]\n",
  			connector->base.base.id,
@@@ -9269,6 -11178,35 +9593,38 @@@ next_encoder
  		}
  	}
  	/* Now we've also updated encoder->new_crtc for all encoders. */
++<<<<<<< HEAD
++=======
+ 	list_for_each_entry(connector, &dev->mode_config.connector_list,
+ 			    base.head) {
+ 		if (connector->new_encoder)
+ 			if (connector->new_encoder != connector->encoder)
+ 				connector->encoder = connector->new_encoder;
+ 	}
+ 	for_each_intel_crtc(dev, crtc) {
+ 		crtc->new_enabled = false;
+ 
+ 		list_for_each_entry(encoder,
+ 				    &dev->mode_config.encoder_list,
+ 				    base.head) {
+ 			if (encoder->new_crtc == crtc) {
+ 				crtc->new_enabled = true;
+ 				break;
+ 			}
+ 		}
+ 
+ 		if (crtc->new_enabled != crtc->base.enabled) {
+ 			DRM_DEBUG_KMS("crtc %sabled, full mode switch\n",
+ 				      crtc->new_enabled ? "en" : "dis");
+ 			config->mode_changed = true;
+ 		}
+ 
+ 		if (crtc->new_enabled)
+ 			crtc->new_config = &crtc->config;
+ 		else
+ 			crtc->new_config = NULL;
+ 	}
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  
  	return 0;
  }
diff --cc drivers/gpu/drm/i915/intel_dp.c
index 1a431377d83b,e7a7953da6d1..000000000000
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@@ -65,8 -109,10 +65,8 @@@ static struct intel_dp *intel_attached_
  }
  
  static void intel_dp_link_down(struct intel_dp *intel_dp);
 -static bool _edp_panel_vdd_on(struct intel_dp *intel_dp);
 -static void edp_panel_vdd_off(struct intel_dp *intel_dp, bool sync);
  
- static int
+ int
  intel_dp_max_link_bw(struct intel_dp *intel_dp)
  {
  	int max_link_bw = intel_dp->dpcd[DP_MAX_LINK_RATE];
@@@ -656,6 -680,89 +656,92 @@@ intel_dp_i2c_init(struct intel_dp *inte
  }
  
  static void
++<<<<<<< HEAD
++=======
+ intel_dp_aux_init(struct intel_dp *intel_dp, struct intel_connector *connector)
+ {
+ 	struct drm_device *dev = intel_dp_to_dev(intel_dp);
+ 	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
+ 	enum port port = intel_dig_port->port;
+ 	const char *name = NULL;
+ 	int ret;
+ 
+ 	switch (port) {
+ 	case PORT_A:
+ 		intel_dp->aux_ch_ctl_reg = DPA_AUX_CH_CTL;
+ 		name = "DPDDC-A";
+ 		break;
+ 	case PORT_B:
+ 		intel_dp->aux_ch_ctl_reg = PCH_DPB_AUX_CH_CTL;
+ 		name = "DPDDC-B";
+ 		break;
+ 	case PORT_C:
+ 		intel_dp->aux_ch_ctl_reg = PCH_DPC_AUX_CH_CTL;
+ 		name = "DPDDC-C";
+ 		break;
+ 	case PORT_D:
+ 		intel_dp->aux_ch_ctl_reg = PCH_DPD_AUX_CH_CTL;
+ 		name = "DPDDC-D";
+ 		break;
+ 	default:
+ 		BUG();
+ 	}
+ 
+ 	if (!HAS_DDI(dev))
+ 		intel_dp->aux_ch_ctl_reg = intel_dp->output_reg + 0x10;
+ 
+ 	intel_dp->aux.name = name;
+ 	intel_dp->aux.dev = dev->dev;
+ 	intel_dp->aux.transfer = intel_dp_aux_transfer;
+ 
+ 	DRM_DEBUG_KMS("registering %s bus for %s\n", name,
+ 		      connector->base.kdev->kobj.name);
+ 
+ 	ret = drm_dp_aux_register(&intel_dp->aux);
+ 	if (ret < 0) {
+ 		DRM_ERROR("drm_dp_aux_register() for %s failed (%d)\n",
+ 			  name, ret);
+ 		return;
+ 	}
+ 
+ 	ret = sysfs_create_link(&connector->base.kdev->kobj,
+ 				&intel_dp->aux.ddc.dev.kobj,
+ 				intel_dp->aux.ddc.dev.kobj.name);
+ 	if (ret < 0) {
+ 		DRM_ERROR("sysfs_create_link() for %s failed (%d)\n", name, ret);
+ 		drm_dp_aux_unregister(&intel_dp->aux);
+ 	}
+ }
+ 
+ static void
+ intel_dp_connector_unregister(struct intel_connector *intel_connector)
+ {
+ 	struct intel_dp *intel_dp = intel_attached_dp(&intel_connector->base);
+ 
+ 	if (!intel_connector->mst_port)
+ 		sysfs_remove_link(&intel_connector->base.kdev->kobj,
+ 				  intel_dp->aux.ddc.dev.kobj.name);
+ 	intel_connector_unregister(intel_connector);
+ }
+ 
+ static void
+ hsw_dp_set_ddi_pll_sel(struct intel_crtc_config *pipe_config, int link_bw)
+ {
+ 	switch (link_bw) {
+ 	case DP_LINK_BW_1_62:
+ 		pipe_config->ddi_pll_sel = PORT_CLK_SEL_LCPLL_810;
+ 		break;
+ 	case DP_LINK_BW_2_7:
+ 		pipe_config->ddi_pll_sel = PORT_CLK_SEL_LCPLL_1350;
+ 		break;
+ 	case DP_LINK_BW_5_4:
+ 		pipe_config->ddi_pll_sel = PORT_CLK_SEL_LCPLL_2700;
+ 		break;
+ 	}
+ }
+ 
+ static void
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  intel_dp_set_clock(struct intel_encoder *encoder,
  		   struct intel_crtc_config *pipe_config, int link_bw)
  {
@@@ -2642,30 -3307,151 +2728,161 @@@ intel_dp_probe_oui(struct intel_dp *int
  		DRM_DEBUG_KMS("Branch OUI: %02hx%02hx%02hx\n",
  			      buf[0], buf[1], buf[2]);
  
++<<<<<<< HEAD
 +	ironlake_edp_panel_vdd_off(intel_dp, false);
++=======
+ 	edp_panel_vdd_off(intel_dp, false);
+ }
+ 
+ static bool
+ intel_dp_probe_mst(struct intel_dp *intel_dp)
+ {
+ 	u8 buf[1];
+ 
+ 	if (!intel_dp->can_mst)
+ 		return false;
+ 
+ 	if (intel_dp->dpcd[DP_DPCD_REV] < 0x12)
+ 		return false;
+ 
+ 	_edp_panel_vdd_on(intel_dp);
+ 	if (intel_dp_dpcd_read_wake(&intel_dp->aux, DP_MSTM_CAP, buf, 1)) {
+ 		if (buf[0] & DP_MST_CAP) {
+ 			DRM_DEBUG_KMS("Sink is MST capable\n");
+ 			intel_dp->is_mst = true;
+ 		} else {
+ 			DRM_DEBUG_KMS("Sink is not MST capable\n");
+ 			intel_dp->is_mst = false;
+ 		}
+ 	}
+ 	edp_panel_vdd_off(intel_dp, false);
+ 
+ 	drm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr, intel_dp->is_mst);
+ 	return intel_dp->is_mst;
+ }
+ 
+ int intel_dp_sink_crc(struct intel_dp *intel_dp, u8 *crc)
+ {
+ 	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
+ 	struct drm_device *dev = intel_dig_port->base.base.dev;
+ 	struct intel_crtc *intel_crtc =
+ 		to_intel_crtc(intel_dig_port->base.base.crtc);
+ 	u8 buf[1];
+ 
+ 	if (drm_dp_dpcd_readb(&intel_dp->aux, DP_TEST_SINK_MISC, buf) < 0)
+ 		return -EAGAIN;
+ 
+ 	if (!(buf[0] & DP_TEST_CRC_SUPPORTED))
+ 		return -ENOTTY;
+ 
+ 	if (drm_dp_dpcd_writeb(&intel_dp->aux, DP_TEST_SINK,
+ 			       DP_TEST_SINK_START) < 0)
+ 		return -EAGAIN;
+ 
+ 	/* Wait 2 vblanks to be sure we will have the correct CRC value */
+ 	intel_wait_for_vblank(dev, intel_crtc->pipe);
+ 	intel_wait_for_vblank(dev, intel_crtc->pipe);
+ 
+ 	if (drm_dp_dpcd_read(&intel_dp->aux, DP_TEST_CRC_R_CR, crc, 6) < 0)
+ 		return -EAGAIN;
+ 
+ 	drm_dp_dpcd_writeb(&intel_dp->aux, DP_TEST_SINK, 0);
+ 	return 0;
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  }
  
  static bool
  intel_dp_get_sink_irq(struct intel_dp *intel_dp, u8 *sink_irq_vector)
  {
 -	return intel_dp_dpcd_read_wake(&intel_dp->aux,
 -				       DP_DEVICE_SERVICE_IRQ_VECTOR,
 -				       sink_irq_vector, 1) == 1;
 +	int ret;
 +
 +	ret = intel_dp_aux_native_read_retry(intel_dp,
 +					     DP_DEVICE_SERVICE_IRQ_VECTOR,
 +					     sink_irq_vector, 1);
 +	if (!ret)
 +		return false;
 +
 +	return true;
  }
  
+ static bool
+ intel_dp_get_sink_irq_esi(struct intel_dp *intel_dp, u8 *sink_irq_vector)
+ {
+ 	int ret;
+ 
+ 	ret = intel_dp_dpcd_read_wake(&intel_dp->aux,
+ 					     DP_SINK_COUNT_ESI,
+ 					     sink_irq_vector, 14);
+ 	if (ret != 14)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
  static void
  intel_dp_handle_test_request(struct intel_dp *intel_dp)
  {
  	/* NAK by default */
 -	drm_dp_dpcd_writeb(&intel_dp->aux, DP_TEST_RESPONSE, DP_TEST_NAK);
 +	intel_dp_aux_native_write_1(intel_dp, DP_TEST_RESPONSE, DP_TEST_NAK);
  }
  
+ static int
+ intel_dp_check_mst_status(struct intel_dp *intel_dp)
+ {
+ 	bool bret;
+ 
+ 	if (intel_dp->is_mst) {
+ 		u8 esi[16] = { 0 };
+ 		int ret = 0;
+ 		int retry;
+ 		bool handled;
+ 		bret = intel_dp_get_sink_irq_esi(intel_dp, esi);
+ go_again:
+ 		if (bret == true) {
+ 
+ 			/* check link status - esi[10] = 0x200c */
+ 			if (intel_dp->active_mst_links && !drm_dp_channel_eq_ok(&esi[10], intel_dp->lane_count)) {
+ 				DRM_DEBUG_KMS("channel EQ not ok, retraining\n");
+ 				intel_dp_start_link_train(intel_dp);
+ 				intel_dp_complete_link_train(intel_dp);
+ 				intel_dp_stop_link_train(intel_dp);
+ 			}
+ 
+ 			DRM_DEBUG_KMS("got esi %02x %02x %02x\n", esi[0], esi[1], esi[2]);
+ 			ret = drm_dp_mst_hpd_irq(&intel_dp->mst_mgr, esi, &handled);
+ 
+ 			if (handled) {
+ 				for (retry = 0; retry < 3; retry++) {
+ 					int wret;
+ 					wret = drm_dp_dpcd_write(&intel_dp->aux,
+ 								 DP_SINK_COUNT_ESI+1,
+ 								 &esi[1], 3);
+ 					if (wret == 3) {
+ 						break;
+ 					}
+ 				}
+ 
+ 				bret = intel_dp_get_sink_irq_esi(intel_dp, esi);
+ 				if (bret == true) {
+ 					DRM_DEBUG_KMS("got esi2 %02x %02x %02x\n", esi[0], esi[1], esi[2]);
+ 					goto go_again;
+ 				}
+ 			} else
+ 				ret = 0;
+ 
+ 			return ret;
+ 		} else {
+ 			struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
+ 			DRM_DEBUG_KMS("failed to get ESI - device may have failed\n");
+ 			intel_dp->is_mst = false;
+ 			drm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr, intel_dp->is_mst);
+ 			/* send a hotplug event */
+ 			drm_kms_helper_hotplug_event(intel_dig_port->base.base.dev);
+ 		}
+ 	}
+ 	return -EINVAL;
+ }
+ 
  /*
   * According to DP spec
   * 5.1.2:
@@@ -2873,12 -3675,28 +3089,21 @@@ intel_dp_detect(struct drm_connector *c
  	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
  	struct intel_encoder *intel_encoder = &intel_dig_port->base;
  	struct drm_device *dev = connector->dev;
 -	struct drm_i915_private *dev_priv = dev->dev_private;
  	enum drm_connector_status status;
 -	enum intel_display_power_domain power_domain;
  	struct edid *edid = NULL;
+ 	bool ret;
  
 -	intel_runtime_pm_get(dev_priv);
 -
 -	power_domain = intel_display_port_power_domain(intel_encoder);
 -	intel_display_power_get(dev_priv, power_domain);
 -
  	DRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n",
 -		      connector->base.id, connector->name);
 +		      connector->base.id, drm_get_connector_name(connector));
  
+ 	if (intel_dp->is_mst) {
+ 		/* MST devices are disconnected from a monitor POV */
+ 		if (intel_encoder->type != INTEL_OUTPUT_EDP)
+ 			intel_encoder->type = INTEL_OUTPUT_DISPLAYPORT;
+ 		status = connector_status_disconnected;
+ 		goto out;
+ 	}
+ 
  	intel_dp->has_audio = false;
  
  	if (HAS_PCH_SPLIT(dev))
@@@ -3061,7 -3913,8 +3296,12 @@@ void intel_dp_encoder_destroy(struct dr
  	struct intel_dp *intel_dp = &intel_dig_port->dp;
  	struct drm_device *dev = intel_dp_to_dev(intel_dp);
  
++<<<<<<< HEAD
 +	i2c_del_adapter(&intel_dp->adapter);
++=======
+ 	drm_dp_aux_unregister(&intel_dp->aux);
+ 	intel_dp_mst_encoder_cleanup(intel_dig_port);
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  	drm_encoder_cleanup(encoder);
  	if (is_edp(intel_dp)) {
  		cancel_delayed_work_sync(&intel_dp->panel_vdd_work);
@@@ -3090,14 -3943,64 +3330,67 @@@ static const struct drm_encoder_funcs i
  	.destroy = intel_dp_encoder_destroy,
  };
  
- static void
+ void
  intel_dp_hot_plug(struct intel_encoder *intel_encoder)
  {
- 	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);
+ 	return;
+ }
+ 
++<<<<<<< HEAD
++=======
+ bool
+ intel_dp_hpd_pulse(struct intel_digital_port *intel_dig_port, bool long_hpd)
+ {
+ 	struct intel_dp *intel_dp = &intel_dig_port->dp;
+ 	struct drm_device *dev = intel_dig_port->base.base.dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	int ret;
+ 	if (intel_dig_port->base.type != INTEL_OUTPUT_EDP)
+ 		intel_dig_port->base.type = INTEL_OUTPUT_DISPLAYPORT;
+ 
+ 	DRM_DEBUG_KMS("got hpd irq on port %d - %s\n", intel_dig_port->port,
+ 		      long_hpd ? "long" : "short");
+ 
+ 	if (long_hpd) {
+ 		if (!ibx_digital_port_connected(dev_priv, intel_dig_port))
+ 			goto mst_fail;
+ 
+ 		if (!intel_dp_get_dpcd(intel_dp)) {
+ 			goto mst_fail;
+ 		}
  
- 	intel_dp_check_link_status(intel_dp);
+ 		intel_dp_probe_oui(intel_dp);
+ 
+ 		if (!intel_dp_probe_mst(intel_dp))
+ 			goto mst_fail;
+ 
+ 	} else {
+ 		if (intel_dp->is_mst) {
+ 			ret = intel_dp_check_mst_status(intel_dp);
+ 			if (ret == -EINVAL)
+ 				goto mst_fail;
+ 		}
+ 
+ 		if (!intel_dp->is_mst) {
+ 			/*
+ 			 * we'll check the link status via the normal hot plug path later -
+ 			 * but for short hpds we should check it now
+ 			 */
+ 			intel_dp_check_link_status(intel_dp);
+ 		}
+ 	}
+ 	return false;
+ mst_fail:
+ 	/* if we were in MST mode, and device is not there get out of MST mode */
+ 	if (intel_dp->is_mst) {
+ 		DRM_DEBUG_KMS("MST device may have disappeared %d vs %d\n", intel_dp->is_mst, intel_dp->mst_mgr.mst_state);
+ 		intel_dp->is_mst = false;
+ 		drm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr, intel_dp->is_mst);
+ 	}
+ 	return true;
  }
  
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  /* Return which DP Port should be selected for Transcoder DP control */
  int
  intel_trans_dp_port_sel(struct drm_crtc *crtc)
@@@ -3495,21 -4536,29 +3788,33 @@@ intel_dp_init_connector(struct intel_di
  		BUG();
  	}
  
 -	if (is_edp(intel_dp)) {
 -		intel_dp_init_panel_power_timestamps(intel_dp);
 -		intel_dp_init_panel_power_sequencer(dev, intel_dp, &power_seq);
 -	}
 +	error = intel_dp_i2c_init(intel_dp, intel_connector, name);
 +	WARN(error, "intel_dp_i2c_init failed with error %d for port %c\n",
 +	     error, port_name(port));
  
 -	intel_dp_aux_init(intel_dp, intel_connector);
 +	intel_dp->psr_setup_done = false;
  
++<<<<<<< HEAD
 +	if (!intel_edp_init_connector(intel_dp, intel_connector)) {
 +		i2c_del_adapter(&intel_dp->adapter);
++=======
+ 	/* init MST on ports that can support it */
+ 	if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
+ 		if (port == PORT_B || port == PORT_C || port == PORT_D) {
+ 			intel_dp_mst_encoder_init(intel_dig_port, intel_connector->base.base.id);
+ 		}
+ 	}
+ 
+ 	if (!intel_edp_init_connector(intel_dp, intel_connector, &power_seq)) {
+ 		drm_dp_aux_unregister(&intel_dp->aux);
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  		if (is_edp(intel_dp)) {
  			cancel_delayed_work_sync(&intel_dp->panel_vdd_work);
 -			drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
 -			edp_panel_vdd_off_sync(intel_dp);
 -			drm_modeset_unlock(&dev->mode_config.connection_mutex);
 +			mutex_lock(&dev->mode_config.mutex);
 +			ironlake_panel_vdd_off_sync(intel_dp);
 +			mutex_unlock(&dev->mode_config.mutex);
  		}
 -		drm_connector_unregister(connector);
 +		drm_sysfs_connector_remove(connector);
  		drm_connector_cleanup(connector);
  		return false;
  	}
diff --cc drivers/gpu/drm/i915/intel_drv.h
index 7f2b384ac939,1dfd1e518551..000000000000
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@@ -93,7 -98,9 +93,13 @@@
  #define INTEL_OUTPUT_HDMI 6
  #define INTEL_OUTPUT_DISPLAYPORT 7
  #define INTEL_OUTPUT_EDP 8
++<<<<<<< HEAD
 +#define INTEL_OUTPUT_UNKNOWN 9
++=======
+ #define INTEL_OUTPUT_DSI 9
+ #define INTEL_OUTPUT_UNKNOWN 10
+ #define INTEL_OUTPUT_DP_MST 11
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  
  #define INTEL_DVO_CHIP_NONE 0
  #define INTEL_DVO_CHIP_LVDS 1
@@@ -288,6 -354,25 +298,28 @@@ struct intel_crtc_config 
  	struct intel_link_m_n fdi_m_n;
  
  	bool ips_enabled;
++<<<<<<< HEAD
++=======
+ 
+ 	bool double_wide;
+ 
+ 	bool dp_encoder_is_mst;
+ 	int pbn;
+ };
+ 
+ struct intel_pipe_wm {
+ 	struct intel_wm_level wm[5];
+ 	uint32_t linetime;
+ 	bool fbc_wm_enabled;
+ 	bool pipe_enabled;
+ 	bool sprites_enabled;
+ 	bool sprites_scaled;
+ };
+ 
+ struct intel_mmio_flip {
+ 	u32 seqno;
+ 	u32 ring_id;
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  };
  
  struct intel_crtc {
@@@ -416,8 -513,20 +448,9 @@@ struct intel_hdmi 
  			       struct drm_display_mode *adjusted_mode);
  };
  
+ struct intel_dp_mst_encoder;
  #define DP_MAX_DOWNSTREAM_PORTS		0x10
 -
 -/**
 - * HIGH_RR is the highest eDP panel refresh rate read from EDID
 - * LOW_RR is the lowest eDP panel refresh rate found from EDID
 - * parsing for same resolution.
 - */
 -enum edp_drrs_refresh_rate_type {
 -	DRRS_HIGH_RR,
 -	DRRS_LOW_RR,
 -	DRRS_MAX_RR, /* RR count */
 -};
 +#define DP_LINK_CONFIGURATION_SIZE	9
  
  struct intel_dp {
  	uint32_t output_reg;
@@@ -443,8 -550,35 +476,40 @@@
  	int backlight_off_delay;
  	struct delayed_work panel_vdd_work;
  	bool want_panel_vdd;
++<<<<<<< HEAD
 +	bool psr_setup_done;
 +	struct intel_connector *attached_connector;
++=======
+ 	unsigned long last_power_cycle;
+ 	unsigned long last_power_on;
+ 	unsigned long last_backlight_off;
+ 	bool use_tps3;
+ 	bool can_mst; /* this port supports mst */
+ 	bool is_mst;
+ 	int active_mst_links;
+ 	/* connector directly attached - won't be use for modeset in mst world */
+ 	struct intel_connector *attached_connector;
+ 
+ 	/* mst connector list */
+ 	struct intel_dp_mst_encoder *mst_encoders[I915_MAX_PIPES];
+ 	struct drm_dp_mst_topology_mgr mst_mgr;
+ 
+ 	uint32_t (*get_aux_clock_divider)(struct intel_dp *dp, int index);
+ 	/*
+ 	 * This function returns the value we have to program the AUX_CTL
+ 	 * register with to kick off an AUX transaction.
+ 	 */
+ 	uint32_t (*get_aux_send_ctl)(struct intel_dp *dp,
+ 				     bool has_aux_irq,
+ 				     int send_bytes,
+ 				     uint32_t aux_clock_divider);
+ 	struct {
+ 		enum drrs_support_type type;
+ 		enum edp_drrs_refresh_rate_type refresh_rate_type;
+ 		struct mutex mutex;
+ 	} drrs_state;
+ 
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  };
  
  struct intel_digital_port {
@@@ -453,8 -587,16 +518,15 @@@
  	u32 saved_port_bits;
  	struct intel_dp dp;
  	struct intel_hdmi hdmi;
 -	bool (*hpd_pulse)(struct intel_digital_port *, bool);
  };
  
+ struct intel_dp_mst_encoder {
+ 	struct intel_encoder base;
+ 	enum pipe pipe;
+ 	struct intel_digital_port *primary;
+ 	void *port; /* store this opaque as its illegal to dereference it */
+ };
+ 
  static inline int
  vlv_dport_to_channel(struct intel_digital_port *dport)
  {
@@@ -616,73 -704,132 +694,164 @@@ hdmi_to_dig_port(struct intel_hdmi *int
  	return container_of(intel_hdmi, struct intel_digital_port, hdmi);
  }
  
++<<<<<<< HEAD
++=======
+ 
+ /* i915_irq.c */
+ bool intel_set_cpu_fifo_underrun_reporting(struct drm_device *dev,
+ 					   enum pipe pipe, bool enable);
+ bool intel_set_pch_fifo_underrun_reporting(struct drm_device *dev,
+ 					   enum transcoder pch_transcoder,
+ 					   bool enable);
+ void ilk_enable_gt_irq(struct drm_i915_private *dev_priv, uint32_t mask);
+ void ilk_disable_gt_irq(struct drm_i915_private *dev_priv, uint32_t mask);
+ void snb_enable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask);
+ void snb_disable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask);
+ void bdw_enable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask);
+ void bdw_disable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask);
+ void intel_runtime_pm_disable_interrupts(struct drm_device *dev);
+ void intel_runtime_pm_restore_interrupts(struct drm_device *dev);
+ int intel_get_crtc_scanline(struct intel_crtc *crtc);
+ void i9xx_check_fifo_underruns(struct drm_device *dev);
+ 
+ 
+ /* intel_crt.c */
+ void intel_crt_init(struct drm_device *dev);
+ 
+ 
+ /* intel_ddi.c */
+ void intel_prepare_ddi(struct drm_device *dev);
+ void hsw_fdi_link_train(struct drm_crtc *crtc);
+ void intel_ddi_init(struct drm_device *dev, enum port port);
+ enum port intel_ddi_get_encoder_port(struct intel_encoder *intel_encoder);
+ bool intel_ddi_get_hw_state(struct intel_encoder *encoder, enum pipe *pipe);
+ int intel_ddi_get_cdclk_freq(struct drm_i915_private *dev_priv);
+ void intel_ddi_pll_init(struct drm_device *dev);
+ void intel_ddi_enable_transcoder_func(struct drm_crtc *crtc);
+ void intel_ddi_disable_transcoder_func(struct drm_i915_private *dev_priv,
+ 				       enum transcoder cpu_transcoder);
+ void intel_ddi_enable_pipe_clock(struct intel_crtc *intel_crtc);
+ void intel_ddi_disable_pipe_clock(struct intel_crtc *intel_crtc);
+ bool intel_ddi_pll_select(struct intel_crtc *crtc);
+ void intel_ddi_set_pipe_settings(struct drm_crtc *crtc);
+ void intel_ddi_prepare_link_retrain(struct drm_encoder *encoder);
+ bool intel_ddi_connector_get_hw_state(struct intel_connector *intel_connector);
+ void intel_ddi_fdi_disable(struct drm_crtc *crtc);
+ void intel_ddi_get_config(struct intel_encoder *encoder,
+ 			  struct intel_crtc_config *pipe_config);
+ 
+ void intel_ddi_init_dp_buf_reg(struct intel_encoder *encoder);
+ void intel_ddi_clock_get(struct intel_encoder *encoder,
+ 			 struct intel_crtc_config *pipe_config);
+ void intel_ddi_set_vc_payload_alloc(struct drm_crtc *crtc, bool state);
+ 
+ /* intel_display.c */
+ const char *intel_output_name(int output);
+ bool intel_has_pending_fb_unpin(struct drm_device *dev);
+ int intel_pch_rawclk(struct drm_device *dev);
+ void intel_mark_busy(struct drm_device *dev);
+ void intel_fb_obj_invalidate(struct drm_i915_gem_object *obj,
+ 			     struct intel_engine_cs *ring);
+ void intel_frontbuffer_flip_prepare(struct drm_device *dev,
+ 				    unsigned frontbuffer_bits);
+ void intel_frontbuffer_flip_complete(struct drm_device *dev,
+ 				     unsigned frontbuffer_bits);
+ void intel_frontbuffer_flush(struct drm_device *dev,
+ 			     unsigned frontbuffer_bits);
+ /**
+  * intel_frontbuffer_flip - prepare frontbuffer flip
+  * @dev: DRM device
+  * @frontbuffer_bits: frontbuffer plane tracking bits
+  *
+  * This function gets called after scheduling a flip on @obj. This is for
+  * synchronous plane updates which will happen on the next vblank and which will
+  * not get delayed by pending gpu rendering.
+  *
+  * Can be called without any locks held.
+  */
+ static inline
+ void intel_frontbuffer_flip(struct drm_device *dev,
+ 			    unsigned frontbuffer_bits)
+ {
+ 	intel_frontbuffer_flush(dev, frontbuffer_bits);
+ }
+ 
+ void intel_fb_obj_flush(struct drm_i915_gem_object *obj, bool retire);
+ void intel_mark_idle(struct drm_device *dev);
+ void intel_crtc_restore_mode(struct drm_crtc *crtc);
+ void intel_crtc_update_dpms(struct drm_crtc *crtc);
+ void intel_encoder_destroy(struct drm_encoder *encoder);
+ void intel_connector_dpms(struct drm_connector *, int mode);
+ bool intel_connector_get_hw_state(struct intel_connector *connector);
+ void intel_modeset_check_state(struct drm_device *dev);
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  bool ibx_digital_port_connected(struct drm_i915_private *dev_priv,
  				struct intel_digital_port *port);
 -void intel_connector_attach_encoder(struct intel_connector *connector,
 -				    struct intel_encoder *encoder);
 -struct drm_encoder *intel_best_encoder(struct drm_connector *connector);
 -struct drm_display_mode *intel_crtc_mode_get(struct drm_device *dev,
 -					     struct drm_crtc *crtc);
 -enum pipe intel_get_pipe_from_connector(struct intel_connector *connector);
 +
 +extern void intel_connector_attach_encoder(struct intel_connector *connector,
 +					   struct intel_encoder *encoder);
 +extern struct drm_encoder *intel_best_encoder(struct drm_connector *connector);
 +
 +extern struct drm_display_mode *intel_crtc_mode_get(struct drm_device *dev,
 +						    struct drm_crtc *crtc);
  int intel_get_pipe_from_crtc_id(struct drm_device *dev, void *data,
  				struct drm_file *file_priv);
 -enum transcoder intel_pipe_to_cpu_transcoder(struct drm_i915_private *dev_priv,
 -					     enum pipe pipe);
 -void intel_wait_for_vblank(struct drm_device *dev, int pipe);
 -void intel_wait_for_pipe_off(struct drm_device *dev, int pipe);
 -int ironlake_get_lanes_required(int target_clock, int link_bw, int bpp);
 -void vlv_wait_port_ready(struct drm_i915_private *dev_priv,
 -			 struct intel_digital_port *dport);
 -bool intel_get_load_detect_pipe(struct drm_connector *connector,
 -				struct drm_display_mode *mode,
 -				struct intel_load_detect_pipe *old,
 -				struct drm_modeset_acquire_ctx *ctx);
 -void intel_release_load_detect_pipe(struct drm_connector *connector,
 -				    struct intel_load_detect_pipe *old,
 -				    struct drm_modeset_acquire_ctx *ctx);
 -int intel_pin_and_fence_fb_obj(struct drm_device *dev,
 -			       struct drm_i915_gem_object *obj,
 -			       struct intel_engine_cs *pipelined);
 -void intel_unpin_fb_obj(struct drm_i915_gem_object *obj);
 -struct drm_framebuffer *
 -__intel_framebuffer_create(struct drm_device *dev,
 -			   struct drm_mode_fb_cmd2 *mode_cmd,
 -			   struct drm_i915_gem_object *obj);
 -void intel_prepare_page_flip(struct drm_device *dev, int plane);
 -void intel_finish_page_flip(struct drm_device *dev, int pipe);
 -void intel_finish_page_flip_plane(struct drm_device *dev, int plane);
 -
 -/* shared dpll functions */
 -struct intel_shared_dpll *intel_crtc_to_shared_dpll(struct intel_crtc *crtc);
 +extern enum transcoder
 +intel_pipe_to_cpu_transcoder(struct drm_i915_private *dev_priv,
 +			     enum pipe pipe);
 +extern void intel_wait_for_vblank(struct drm_device *dev, int pipe);
 +extern void intel_wait_for_pipe_off(struct drm_device *dev, int pipe);
 +extern int ironlake_get_lanes_required(int target_clock, int link_bw, int bpp);
 +extern void vlv_wait_port_ready(struct drm_i915_private *dev_priv, int port);
 +
 +struct intel_load_detect_pipe {
 +	struct drm_framebuffer *release_fb;
 +	bool load_detect_temp;
 +	int dpms_mode;
 +};
 +extern bool intel_get_load_detect_pipe(struct drm_connector *connector,
 +				       struct drm_display_mode *mode,
 +				       struct intel_load_detect_pipe *old);
 +extern void intel_release_load_detect_pipe(struct drm_connector *connector,
 +					   struct intel_load_detect_pipe *old);
 +
 +extern void intel_crtc_fb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,
 +				    u16 blue, int regno);
 +extern void intel_crtc_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,
 +				    u16 *blue, int regno);
 +
 +extern int intel_pin_and_fence_fb_obj(struct drm_device *dev,
 +				      struct drm_i915_gem_object *obj,
 +				      struct intel_ring_buffer *pipelined);
 +extern void intel_unpin_fb_obj(struct drm_i915_gem_object *obj);
 +
 +extern int intel_framebuffer_init(struct drm_device *dev,
 +				  struct intel_framebuffer *ifb,
 +				  struct drm_mode_fb_cmd2 *mode_cmd,
 +				  struct drm_i915_gem_object *obj);
 +extern void intel_framebuffer_fini(struct intel_framebuffer *fb);
 +extern int intel_fbdev_init(struct drm_device *dev);
 +extern void intel_fbdev_initial_config(struct drm_device *dev);
 +extern void intel_fbdev_fini(struct drm_device *dev);
 +extern void intel_fbdev_set_suspend(struct drm_device *dev, int state);
 +extern void intel_prepare_page_flip(struct drm_device *dev, int plane);
 +extern void intel_finish_page_flip(struct drm_device *dev, int pipe);
 +extern void intel_finish_page_flip_plane(struct drm_device *dev, int plane);
 +
 +extern void intel_setup_overlay(struct drm_device *dev);
 +extern void intel_cleanup_overlay(struct drm_device *dev);
 +extern int intel_overlay_switch_off(struct intel_overlay *overlay);
 +extern int intel_overlay_put_image(struct drm_device *dev, void *data,
 +				   struct drm_file *file_priv);
 +extern int intel_overlay_attrs(struct drm_device *dev, void *data,
 +			       struct drm_file *file_priv);
 +
 +extern void intel_fb_output_poll_changed(struct drm_device *dev);
 +extern void intel_fb_restore_mode(struct drm_device *dev);
 +
 +struct intel_shared_dpll *
 +intel_crtc_to_shared_dpll(struct intel_crtc *crtc);
 +
  void assert_shared_dpll(struct drm_i915_private *dev_priv,
  			struct intel_shared_dpll *pll,
  			bool state);
@@@ -696,104 -847,232 +865,118 @@@ void assert_fdi_rx_pll(struct drm_i915_
  		       enum pipe pipe, bool state);
  #define assert_fdi_rx_pll_enabled(d, p) assert_fdi_rx_pll(d, p, true)
  #define assert_fdi_rx_pll_disabled(d, p) assert_fdi_rx_pll(d, p, false)
 -void assert_pipe(struct drm_i915_private *dev_priv, enum pipe pipe, bool state);
 +extern void assert_pipe(struct drm_i915_private *dev_priv, enum pipe pipe,
 +			bool state);
  #define assert_pipe_enabled(d, p) assert_pipe(d, p, true)
  #define assert_pipe_disabled(d, p) assert_pipe(d, p, false)
 -void intel_write_eld(struct drm_encoder *encoder,
 -		     struct drm_display_mode *mode);
 -unsigned long intel_gen4_compute_page_offset(int *x, int *y,
 -					     unsigned int tiling_mode,
 -					     unsigned int bpp,
 -					     unsigned int pitch);
 -void intel_display_handle_reset(struct drm_device *dev);
 -void hsw_enable_pc8(struct drm_i915_private *dev_priv);
 -void hsw_disable_pc8(struct drm_i915_private *dev_priv);
 -void intel_dp_get_m_n(struct intel_crtc *crtc,
 -		      struct intel_crtc_config *pipe_config);
 -int intel_dotclock_calculate(int link_freq, const struct intel_link_m_n *m_n);
 -void
 -ironlake_check_encoder_dotclock(const struct intel_crtc_config *pipe_config,
 -				int dotclock);
 -bool intel_crtc_active(struct drm_crtc *crtc);
 -void hsw_enable_ips(struct intel_crtc *crtc);
 -void hsw_disable_ips(struct intel_crtc *crtc);
 -void intel_display_set_init_power(struct drm_i915_private *dev, bool enable);
 -enum intel_display_power_domain
 -intel_display_port_power_domain(struct intel_encoder *intel_encoder);
 -void intel_mode_from_pipe_config(struct drm_display_mode *mode,
 -				 struct intel_crtc_config *pipe_config);
 -int intel_format_to_fourcc(int format);
 -void intel_crtc_wait_for_pending_flips(struct drm_crtc *crtc);
 -
 -
 -/* intel_dp.c */
 -void intel_dp_init(struct drm_device *dev, int output_reg, enum port port);
 -bool intel_dp_init_connector(struct intel_digital_port *intel_dig_port,
 -			     struct intel_connector *intel_connector);
 -void intel_dp_start_link_train(struct intel_dp *intel_dp);
 -void intel_dp_complete_link_train(struct intel_dp *intel_dp);
 -void intel_dp_stop_link_train(struct intel_dp *intel_dp);
 -void intel_dp_sink_dpms(struct intel_dp *intel_dp, int mode);
 -void intel_dp_encoder_destroy(struct drm_encoder *encoder);
 -void intel_dp_check_link_status(struct intel_dp *intel_dp);
 -int intel_dp_sink_crc(struct intel_dp *intel_dp, u8 *crc);
 -bool intel_dp_compute_config(struct intel_encoder *encoder,
 -			     struct intel_crtc_config *pipe_config);
 -bool intel_dp_is_edp(struct drm_device *dev, enum port port);
 -bool intel_dp_hpd_pulse(struct intel_digital_port *intel_dig_port,
 -			bool long_hpd);
 -void intel_edp_backlight_on(struct intel_dp *intel_dp);
 -void intel_edp_backlight_off(struct intel_dp *intel_dp);
 -void intel_edp_panel_vdd_on(struct intel_dp *intel_dp);
 -void intel_edp_panel_on(struct intel_dp *intel_dp);
 -void intel_edp_panel_off(struct intel_dp *intel_dp);
 -void intel_edp_psr_enable(struct intel_dp *intel_dp);
 -void intel_edp_psr_disable(struct intel_dp *intel_dp);
 -void intel_dp_set_drrs_state(struct drm_device *dev, int refresh_rate);
 -void intel_edp_psr_exit(struct drm_device *dev);
 -void intel_edp_psr_init(struct drm_device *dev);
  
 +extern void intel_init_clock_gating(struct drm_device *dev);
 +extern void intel_suspend_hw(struct drm_device *dev);
 +extern void intel_write_eld(struct drm_encoder *encoder,
 +			    struct drm_display_mode *mode);
 +extern void intel_prepare_ddi(struct drm_device *dev);
 +extern void hsw_fdi_link_train(struct drm_crtc *crtc);
 +extern void intel_ddi_init(struct drm_device *dev, enum port port);
 +
 +/* For use by IVB LP watermark workaround in intel_sprite.c */
 +extern void intel_update_watermarks(struct drm_device *dev);
 +extern void intel_update_sprite_watermarks(struct drm_plane *plane,
 +					   struct drm_crtc *crtc,
 +					   uint32_t sprite_width, int pixel_size,
 +					   bool enabled, bool scaled);
 +
++<<<<<<< HEAD
 +extern unsigned long intel_gen4_compute_page_offset(int *x, int *y,
 +						    unsigned int tiling_mode,
 +						    unsigned int bpp,
 +						    unsigned int pitch);
++=======
+ int intel_dp_handle_hpd_irq(struct intel_digital_port *digport, bool long_hpd);
+ void intel_dp_add_properties(struct intel_dp *intel_dp, struct drm_connector *connector);
+ void intel_dp_mst_suspend(struct drm_device *dev);
+ void intel_dp_mst_resume(struct drm_device *dev);
+ int intel_dp_max_link_bw(struct intel_dp *intel_dp);
+ void intel_dp_hot_plug(struct intel_encoder *intel_encoder);
+ /* intel_dp_mst.c */
+ int intel_dp_mst_encoder_init(struct intel_digital_port *intel_dig_port, int conn_id);
+ void intel_dp_mst_encoder_cleanup(struct intel_digital_port *intel_dig_port);
+ /* intel_dsi.c */
+ void intel_dsi_init(struct drm_device *dev);
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
 +
 +extern int intel_sprite_set_colorkey(struct drm_device *dev, void *data,
 +				     struct drm_file *file_priv);
 +extern int intel_sprite_get_colorkey(struct drm_device *dev, void *data,
 +				     struct drm_file *file_priv);
 +
 +/* Power-related functions, located in intel_pm.c */
 +extern void intel_init_pm(struct drm_device *dev);
 +/* FBC */
 +extern bool intel_fbc_enabled(struct drm_device *dev);
 +extern void intel_update_fbc(struct drm_device *dev);
 +/* IPS */
 +extern void intel_gpu_ips_init(struct drm_i915_private *dev_priv);
 +extern void intel_gpu_ips_teardown(void);
 +
 +/* Power well */
 +extern int i915_init_power_well(struct drm_device *dev);
 +extern void i915_remove_power_well(struct drm_device *dev);
 +
 +extern bool intel_display_power_enabled(struct drm_device *dev,
 +					enum intel_display_power_domain domain);
 +extern void intel_init_power_well(struct drm_device *dev);
 +extern void intel_set_power_well(struct drm_device *dev, bool enable);
 +extern void intel_enable_gt_powersave(struct drm_device *dev);
 +extern void intel_disable_gt_powersave(struct drm_device *dev);
 +extern void ironlake_teardown_rc6(struct drm_device *dev);
 +void gen6_update_ring_freq(struct drm_device *dev);
  
 +extern bool intel_ddi_get_hw_state(struct intel_encoder *encoder,
 +				   enum pipe *pipe);
 +extern int intel_ddi_get_cdclk_freq(struct drm_i915_private *dev_priv);
 +extern void intel_ddi_pll_init(struct drm_device *dev);
 +extern void intel_ddi_enable_transcoder_func(struct drm_crtc *crtc);
 +extern void intel_ddi_disable_transcoder_func(struct drm_i915_private *dev_priv,
 +					      enum transcoder cpu_transcoder);
 +extern void intel_ddi_enable_pipe_clock(struct intel_crtc *intel_crtc);
 +extern void intel_ddi_disable_pipe_clock(struct intel_crtc *intel_crtc);
 +extern void intel_ddi_setup_hw_pll_state(struct drm_device *dev);
 +extern bool intel_ddi_pll_mode_set(struct drm_crtc *crtc);
 +extern void intel_ddi_put_crtc_pll(struct drm_crtc *crtc);
 +extern void intel_ddi_set_pipe_settings(struct drm_crtc *crtc);
 +extern void intel_ddi_prepare_link_retrain(struct drm_encoder *encoder);
 +extern bool
 +intel_ddi_connector_get_hw_state(struct intel_connector *intel_connector);
 +extern void intel_ddi_fdi_disable(struct drm_crtc *crtc);
 +extern void intel_ddi_get_config(struct intel_encoder *encoder,
 +				 struct intel_crtc_config *pipe_config);
  
 -/* intel_dvo.c */
 -void intel_dvo_init(struct drm_device *dev);
 -
 -
 -/* legacy fbdev emulation in intel_fbdev.c */
 -#ifdef CONFIG_DRM_I915_FBDEV
 -extern int intel_fbdev_init(struct drm_device *dev);
 -extern void intel_fbdev_initial_config(struct drm_device *dev);
 -extern void intel_fbdev_fini(struct drm_device *dev);
 -extern void intel_fbdev_set_suspend(struct drm_device *dev, int state);
 -extern void intel_fbdev_output_poll_changed(struct drm_device *dev);
 -extern void intel_fbdev_restore_mode(struct drm_device *dev);
 -#else
 -static inline int intel_fbdev_init(struct drm_device *dev)
 -{
 -	return 0;
 -}
 -
 -static inline void intel_fbdev_initial_config(struct drm_device *dev)
 -{
 -}
 -
 -static inline void intel_fbdev_fini(struct drm_device *dev)
 -{
 -}
 -
 -static inline void intel_fbdev_set_suspend(struct drm_device *dev, int state)
 -{
 -}
 -
 -static inline void intel_fbdev_restore_mode(struct drm_device *dev)
 -{
 -}
 -#endif
 -
 -/* intel_hdmi.c */
 -void intel_hdmi_init(struct drm_device *dev, int hdmi_reg, enum port port);
 -void intel_hdmi_init_connector(struct intel_digital_port *intel_dig_port,
 -			       struct intel_connector *intel_connector);
 -struct intel_hdmi *enc_to_intel_hdmi(struct drm_encoder *encoder);
 -bool intel_hdmi_compute_config(struct intel_encoder *encoder,
 -			       struct intel_crtc_config *pipe_config);
 -
 -
 -/* intel_lvds.c */
 -void intel_lvds_init(struct drm_device *dev);
 -bool intel_is_dual_link_lvds(struct drm_device *dev);
 -
 -
 -/* intel_modes.c */
 -int intel_connector_update_modes(struct drm_connector *connector,
 -				 struct edid *edid);
 -int intel_ddc_get_modes(struct drm_connector *c, struct i2c_adapter *adapter);
 -void intel_attach_force_audio_property(struct drm_connector *connector);
 -void intel_attach_broadcast_rgb_property(struct drm_connector *connector);
 -
 -
 -/* intel_overlay.c */
 -void intel_setup_overlay(struct drm_device *dev);
 -void intel_cleanup_overlay(struct drm_device *dev);
 -int intel_overlay_switch_off(struct intel_overlay *overlay);
 -int intel_overlay_put_image(struct drm_device *dev, void *data,
 -			    struct drm_file *file_priv);
 -int intel_overlay_attrs(struct drm_device *dev, void *data,
 -			struct drm_file *file_priv);
 -
 -
 -/* intel_panel.c */
 -int intel_panel_init(struct intel_panel *panel,
 -		     struct drm_display_mode *fixed_mode,
 -		     struct drm_display_mode *downclock_mode);
 -void intel_panel_fini(struct intel_panel *panel);
 -void intel_fixed_panel_mode(const struct drm_display_mode *fixed_mode,
 -			    struct drm_display_mode *adjusted_mode);
 -void intel_pch_panel_fitting(struct intel_crtc *crtc,
 -			     struct intel_crtc_config *pipe_config,
 -			     int fitting_mode);
 -void intel_gmch_panel_fitting(struct intel_crtc *crtc,
 -			      struct intel_crtc_config *pipe_config,
 -			      int fitting_mode);
 -void intel_panel_set_backlight(struct intel_connector *connector, u32 level,
 -			       u32 max);
 -int intel_panel_setup_backlight(struct drm_connector *connector);
 -void intel_panel_enable_backlight(struct intel_connector *connector);
 -void intel_panel_disable_backlight(struct intel_connector *connector);
 -void intel_panel_destroy_backlight(struct drm_connector *connector);
 -void intel_panel_init_backlight_funcs(struct drm_device *dev);
 -enum drm_connector_status intel_panel_detect(struct drm_device *dev);
 -extern struct drm_display_mode *intel_find_panel_downclock(
 -				struct drm_device *dev,
 -				struct drm_display_mode *fixed_mode,
 -				struct drm_connector *connector);
 -
 -/* intel_pm.c */
 -void intel_init_clock_gating(struct drm_device *dev);
 -void intel_suspend_hw(struct drm_device *dev);
 -int ilk_wm_max_level(const struct drm_device *dev);
 -void intel_update_watermarks(struct drm_crtc *crtc);
 -void intel_update_sprite_watermarks(struct drm_plane *plane,
 -				    struct drm_crtc *crtc,
 -				    uint32_t sprite_width, int pixel_size,
 -				    bool enabled, bool scaled);
 -void intel_init_pm(struct drm_device *dev);
 -void intel_pm_setup(struct drm_device *dev);
 -bool intel_fbc_enabled(struct drm_device *dev);
 -void intel_update_fbc(struct drm_device *dev);
 -void intel_gpu_ips_init(struct drm_i915_private *dev_priv);
 -void intel_gpu_ips_teardown(void);
 -int intel_power_domains_init(struct drm_i915_private *);
 -void intel_power_domains_remove(struct drm_i915_private *);
 -bool intel_display_power_enabled(struct drm_i915_private *dev_priv,
 -				 enum intel_display_power_domain domain);
 -bool intel_display_power_enabled_unlocked(struct drm_i915_private *dev_priv,
 -					  enum intel_display_power_domain domain);
 -void intel_display_power_get(struct drm_i915_private *dev_priv,
 -			     enum intel_display_power_domain domain);
 -void intel_display_power_put(struct drm_i915_private *dev_priv,
 -			     enum intel_display_power_domain domain);
 -void intel_power_domains_init_hw(struct drm_i915_private *dev_priv);
 -void intel_init_gt_powersave(struct drm_device *dev);
 -void intel_cleanup_gt_powersave(struct drm_device *dev);
 -void intel_enable_gt_powersave(struct drm_device *dev);
 -void intel_disable_gt_powersave(struct drm_device *dev);
 -void intel_suspend_gt_powersave(struct drm_device *dev);
 -void intel_reset_gt_powersave(struct drm_device *dev);
 -void ironlake_teardown_rc6(struct drm_device *dev);
 -void gen6_update_ring_freq(struct drm_device *dev);
 -void gen6_rps_idle(struct drm_i915_private *dev_priv);
 -void gen6_rps_boost(struct drm_i915_private *dev_priv);
 -void intel_aux_display_runtime_get(struct drm_i915_private *dev_priv);
 -void intel_aux_display_runtime_put(struct drm_i915_private *dev_priv);
 -void intel_runtime_pm_get(struct drm_i915_private *dev_priv);
 -void intel_runtime_pm_get_noresume(struct drm_i915_private *dev_priv);
 -void intel_runtime_pm_put(struct drm_i915_private *dev_priv);
 -void intel_init_runtime_pm(struct drm_i915_private *dev_priv);
 -void intel_fini_runtime_pm(struct drm_i915_private *dev_priv);
 -void ilk_wm_get_hw_state(struct drm_device *dev);
 -
 -
 -/* intel_sdvo.c */
 -bool intel_sdvo_init(struct drm_device *dev, uint32_t sdvo_reg, bool is_sdvob);
 -
 -
 -/* intel_sprite.c */
 -int intel_plane_init(struct drm_device *dev, enum pipe pipe, int plane);
 -void intel_flush_primary_plane(struct drm_i915_private *dev_priv,
 -			       enum plane plane);
 -void intel_plane_restore(struct drm_plane *plane);
 -void intel_plane_disable(struct drm_plane *plane);
 -int intel_sprite_set_colorkey(struct drm_device *dev, void *data,
 -			      struct drm_file *file_priv);
 -int intel_sprite_get_colorkey(struct drm_device *dev, void *data,
 -			      struct drm_file *file_priv);
 -
 -
 -/* intel_tv.c */
 -void intel_tv_init(struct drm_device *dev);
 +extern void intel_display_handle_reset(struct drm_device *dev);
 +extern bool intel_set_cpu_fifo_underrun_reporting(struct drm_device *dev,
 +						  enum pipe pipe,
 +						  bool enable);
 +extern bool intel_set_pch_fifo_underrun_reporting(struct drm_device *dev,
 +						 enum transcoder pch_transcoder,
 +						 bool enable);
 +
 +extern void intel_edp_psr_enable(struct intel_dp *intel_dp);
 +extern void intel_edp_psr_disable(struct intel_dp *intel_dp);
 +extern void intel_edp_psr_update(struct drm_device *dev);
 +extern void hsw_disable_lcpll(struct drm_i915_private *dev_priv,
 +			      bool switch_to_fclk, bool allow_power_down);
 +extern void hsw_restore_lcpll(struct drm_i915_private *dev_priv);
 +extern void ilk_enable_gt_irq(struct drm_i915_private *dev_priv, uint32_t mask);
 +extern void ilk_disable_gt_irq(struct drm_i915_private *dev_priv,
 +			       uint32_t mask);
 +extern void snb_enable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask);
 +extern void snb_disable_pm_irq(struct drm_i915_private *dev_priv,
 +			       uint32_t mask);
 +extern void hsw_enable_pc8_work(struct work_struct *__work);
 +extern void hsw_enable_package_c8(struct drm_i915_private *dev_priv);
 +extern void hsw_disable_package_c8(struct drm_i915_private *dev_priv);
 +extern void hsw_pc8_disable_interrupts(struct drm_device *dev);
 +extern void hsw_pc8_restore_interrupts(struct drm_device *dev);
 +extern void intel_aux_display_runtime_get(struct drm_i915_private *dev_priv);
 +extern void intel_aux_display_runtime_put(struct drm_i915_private *dev_priv);
  
  #endif /* __INTEL_DRV_H__ */
diff --cc drivers/gpu/drm/i915/intel_opregion.c
index 119771ff46ab,d37934b6338e..000000000000
--- a/drivers/gpu/drm/i915/intel_opregion.c
+++ b/drivers/gpu/drm/i915/intel_opregion.c
@@@ -157,7 -226,176 +157,177 @@@ struct opregion_asle 
  #define ACPI_DIGITAL_OUTPUT (3<<8)
  #define ACPI_LVDS_OUTPUT (4<<8)
  
 -#define MAX_DSLP	1500
 -
  #ifdef CONFIG_ACPI
++<<<<<<< HEAD
++=======
+ static int swsci(struct drm_device *dev, u32 function, u32 parm, u32 *parm_out)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct opregion_swsci __iomem *swsci = dev_priv->opregion.swsci;
+ 	u32 main_function, sub_function, scic;
+ 	u16 pci_swsci;
+ 	u32 dslp;
+ 
+ 	if (!swsci)
+ 		return -ENODEV;
+ 
+ 	main_function = (function & SWSCI_SCIC_MAIN_FUNCTION_MASK) >>
+ 		SWSCI_SCIC_MAIN_FUNCTION_SHIFT;
+ 	sub_function = (function & SWSCI_SCIC_SUB_FUNCTION_MASK) >>
+ 		SWSCI_SCIC_SUB_FUNCTION_SHIFT;
+ 
+ 	/* Check if we can call the function. See swsci_setup for details. */
+ 	if (main_function == SWSCI_SBCB) {
+ 		if ((dev_priv->opregion.swsci_sbcb_sub_functions &
+ 		     (1 << sub_function)) == 0)
+ 			return -EINVAL;
+ 	} else if (main_function == SWSCI_GBDA) {
+ 		if ((dev_priv->opregion.swsci_gbda_sub_functions &
+ 		     (1 << sub_function)) == 0)
+ 			return -EINVAL;
+ 	}
+ 
+ 	/* Driver sleep timeout in ms. */
+ 	dslp = ioread32(&swsci->dslp);
+ 	if (!dslp) {
+ 		/* The spec says 2ms should be the default, but it's too small
+ 		 * for some machines. */
+ 		dslp = 50;
+ 	} else if (dslp > MAX_DSLP) {
+ 		/* Hey bios, trust must be earned. */
+ 		DRM_INFO_ONCE("ACPI BIOS requests an excessive sleep of %u ms, "
+ 			      "using %u ms instead\n", dslp, MAX_DSLP);
+ 		dslp = MAX_DSLP;
+ 	}
+ 
+ 	/* The spec tells us to do this, but we are the only user... */
+ 	scic = ioread32(&swsci->scic);
+ 	if (scic & SWSCI_SCIC_INDICATOR) {
+ 		DRM_DEBUG_DRIVER("SWSCI request already in progress\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	scic = function | SWSCI_SCIC_INDICATOR;
+ 
+ 	iowrite32(parm, &swsci->parm);
+ 	iowrite32(scic, &swsci->scic);
+ 
+ 	/* Ensure SCI event is selected and event trigger is cleared. */
+ 	pci_read_config_word(dev->pdev, PCI_SWSCI, &pci_swsci);
+ 	if (!(pci_swsci & PCI_SWSCI_SCISEL) || (pci_swsci & PCI_SWSCI_GSSCIE)) {
+ 		pci_swsci |= PCI_SWSCI_SCISEL;
+ 		pci_swsci &= ~PCI_SWSCI_GSSCIE;
+ 		pci_write_config_word(dev->pdev, PCI_SWSCI, pci_swsci);
+ 	}
+ 
+ 	/* Use event trigger to tell bios to check the mail. */
+ 	pci_swsci |= PCI_SWSCI_GSSCIE;
+ 	pci_write_config_word(dev->pdev, PCI_SWSCI, pci_swsci);
+ 
+ 	/* Poll for the result. */
+ #define C (((scic = ioread32(&swsci->scic)) & SWSCI_SCIC_INDICATOR) == 0)
+ 	if (wait_for(C, dslp)) {
+ 		DRM_DEBUG_DRIVER("SWSCI request timed out\n");
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	scic = (scic & SWSCI_SCIC_EXIT_STATUS_MASK) >>
+ 		SWSCI_SCIC_EXIT_STATUS_SHIFT;
+ 
+ 	/* Note: scic == 0 is an error! */
+ 	if (scic != SWSCI_SCIC_EXIT_STATUS_SUCCESS) {
+ 		DRM_DEBUG_DRIVER("SWSCI request error %u\n", scic);
+ 		return -EIO;
+ 	}
+ 
+ 	if (parm_out)
+ 		*parm_out = ioread32(&swsci->parm);
+ 
+ 	return 0;
+ 
+ #undef C
+ }
+ 
+ #define DISPLAY_TYPE_CRT			0
+ #define DISPLAY_TYPE_TV				1
+ #define DISPLAY_TYPE_EXTERNAL_FLAT_PANEL	2
+ #define DISPLAY_TYPE_INTERNAL_FLAT_PANEL	3
+ 
+ int intel_opregion_notify_encoder(struct intel_encoder *intel_encoder,
+ 				  bool enable)
+ {
+ 	struct drm_device *dev = intel_encoder->base.dev;
+ 	u32 parm = 0;
+ 	u32 type = 0;
+ 	u32 port;
+ 
+ 	/* don't care about old stuff for now */
+ 	if (!HAS_DDI(dev))
+ 		return 0;
+ 
+ 	port = intel_ddi_get_encoder_port(intel_encoder);
+ 	if (port == PORT_E) {
+ 		port = 0;
+ 	} else {
+ 		parm |= 1 << port;
+ 		port++;
+ 	}
+ 
+ 	if (!enable)
+ 		parm |= 4 << 8;
+ 
+ 	switch (intel_encoder->type) {
+ 	case INTEL_OUTPUT_ANALOG:
+ 		type = DISPLAY_TYPE_CRT;
+ 		break;
+ 	case INTEL_OUTPUT_UNKNOWN:
+ 	case INTEL_OUTPUT_DISPLAYPORT:
+ 	case INTEL_OUTPUT_HDMI:
+ 	case INTEL_OUTPUT_DP_MST:
+ 		type = DISPLAY_TYPE_EXTERNAL_FLAT_PANEL;
+ 		break;
+ 	case INTEL_OUTPUT_EDP:
+ 		type = DISPLAY_TYPE_INTERNAL_FLAT_PANEL;
+ 		break;
+ 	default:
+ 		WARN_ONCE(1, "unsupported intel_encoder type %d\n",
+ 			  intel_encoder->type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	parm |= type << (16 + port * 3);
+ 
+ 	return swsci(dev, SWSCI_SBCB_DISPLAY_POWER_STATE, parm, NULL);
+ }
+ 
+ static const struct {
+ 	pci_power_t pci_power_state;
+ 	u32 parm;
+ } power_state_map[] = {
+ 	{ PCI_D0,	0x00 },
+ 	{ PCI_D1,	0x01 },
+ 	{ PCI_D2,	0x02 },
+ 	{ PCI_D3hot,	0x04 },
+ 	{ PCI_D3cold,	0x04 },
+ };
+ 
+ int intel_opregion_notify_adapter(struct drm_device *dev, pci_power_t state)
+ {
+ 	int i;
+ 
+ 	if (!HAS_DDI(dev))
+ 		return 0;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(power_state_map); i++) {
+ 		if (state == power_state_map[i].pci_power_state)
+ 			return swsci(dev, SWSCI_SBCB_ADAPTER_POWER_STATE,
+ 				     power_state_map[i].parm, NULL);
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> 0e32b39ceed6 (drm/i915: add DP 1.2 MST support (v0.7))
  static u32 asle_set_backlight(struct drm_device *dev, u32 bclp)
  {
  	struct drm_i915_private *dev_priv = dev->dev_private;
* Unmerged path drivers/gpu/drm/i915/intel_fbdev.c
* Unmerged path drivers/gpu/drm/i915/Makefile
* Unmerged path drivers/gpu/drm/i915/i915_dma.c
* Unmerged path drivers/gpu/drm/i915/i915_drv.c
diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h
index ab0f2c0a440c..eb3fbd7133d4 100644
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1341,6 +1341,15 @@ typedef struct drm_i915_private {
 
 	struct i915_package_c8 pc8;
 
+	/*
+	 * if we get a HPD irq from DP and a HPD irq from non-DP
+	 * the non-DP HPD could block the workqueue on a mode config
+	 * mutex getting, that userspace may have taken. However
+	 * userspace is waiting on the DP workqueue to run which is
+	 * blocked behind the non-DP one.
+	 */
+	struct workqueue_struct *dp_wq;
+
 	/* Old dri1 support infrastructure, beware the dragons ya fools entering
 	 * here! */
 	struct i915_dri1_state dri1;
* Unmerged path drivers/gpu/drm/i915/i915_irq.c
* Unmerged path drivers/gpu/drm/i915/intel_ddi.c
* Unmerged path drivers/gpu/drm/i915/intel_display.c
* Unmerged path drivers/gpu/drm/i915/intel_dp.c
diff --git a/drivers/gpu/drm/i915/intel_dp_mst.c b/drivers/gpu/drm/i915/intel_dp_mst.c
new file mode 100644
index 000000000000..ec48d562c7fc
--- /dev/null
+++ b/drivers/gpu/drm/i915/intel_dp_mst.c
@@ -0,0 +1,534 @@
+/*
+ * Copyright © 2008 Intel Corporation
+ *             2014 Red Hat Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#include <drm/drmP.h>
+#include "i915_drv.h"
+#include "intel_drv.h"
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_edid.h>
+
+static bool intel_dp_mst_compute_config(struct intel_encoder *encoder,
+					struct intel_crtc_config *pipe_config)
+{
+	struct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);
+	struct intel_digital_port *intel_dig_port = intel_mst->primary;
+	struct intel_dp *intel_dp = &intel_dig_port->dp;
+	struct drm_device *dev = encoder->base.dev;
+	int bpp;
+	int lane_count, slots;
+	struct drm_display_mode *adjusted_mode = &pipe_config->adjusted_mode;
+	struct intel_connector *found = NULL, *intel_connector;
+	int mst_pbn;
+
+	pipe_config->dp_encoder_is_mst = true;
+	pipe_config->has_pch_encoder = false;
+	pipe_config->has_dp_encoder = true;
+	bpp = 24;
+	/*
+	 * for MST we always configure max link bw - the spec doesn't
+	 * seem to suggest we should do otherwise.
+	 */
+	lane_count = drm_dp_max_lane_count(intel_dp->dpcd);
+	intel_dp->link_bw = intel_dp_max_link_bw(intel_dp);
+	intel_dp->lane_count = lane_count;
+
+	pipe_config->pipe_bpp = 24;
+	pipe_config->port_clock = drm_dp_bw_code_to_link_rate(intel_dp->link_bw);
+
+	list_for_each_entry(intel_connector, &dev->mode_config.connector_list, base.head) {
+		if (intel_connector->new_encoder == encoder) {
+			found = intel_connector;
+			break;
+		}
+	}
+
+	if (!found) {
+		DRM_ERROR("can't find connector\n");
+		return false;
+	}
+
+	mst_pbn = drm_dp_calc_pbn_mode(adjusted_mode->clock, bpp);
+
+	pipe_config->pbn = mst_pbn;
+	slots = drm_dp_find_vcpi_slots(&intel_dp->mst_mgr, mst_pbn);
+
+	intel_link_compute_m_n(bpp, lane_count,
+			       adjusted_mode->crtc_clock,
+			       pipe_config->port_clock,
+			       &pipe_config->dp_m_n);
+
+	pipe_config->dp_m_n.tu = slots;
+	return true;
+
+}
+
+static void intel_mst_disable_dp(struct intel_encoder *encoder)
+{
+	struct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);
+	struct intel_digital_port *intel_dig_port = intel_mst->primary;
+	struct intel_dp *intel_dp = &intel_dig_port->dp;
+	int ret;
+
+	DRM_DEBUG_KMS("%d\n", intel_dp->active_mst_links);
+
+	drm_dp_mst_reset_vcpi_slots(&intel_dp->mst_mgr, intel_mst->port);
+
+	ret = drm_dp_update_payload_part1(&intel_dp->mst_mgr);
+	if (ret) {
+		DRM_ERROR("failed to update payload %d\n", ret);
+	}
+}
+
+static void intel_mst_post_disable_dp(struct intel_encoder *encoder)
+{
+	struct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);
+	struct intel_digital_port *intel_dig_port = intel_mst->primary;
+	struct intel_dp *intel_dp = &intel_dig_port->dp;
+
+	DRM_DEBUG_KMS("%d\n", intel_dp->active_mst_links);
+
+	/* this can fail */
+	drm_dp_check_act_status(&intel_dp->mst_mgr);
+	/* and this can also fail */
+	drm_dp_update_payload_part2(&intel_dp->mst_mgr);
+
+	drm_dp_mst_deallocate_vcpi(&intel_dp->mst_mgr, intel_mst->port);
+
+	intel_dp->active_mst_links--;
+	intel_mst->port = NULL;
+	if (intel_dp->active_mst_links == 0) {
+		intel_dig_port->base.post_disable(&intel_dig_port->base);
+		intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_OFF);
+	}
+}
+
+static void intel_mst_pre_enable_dp(struct intel_encoder *encoder)
+{
+	struct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);
+	struct intel_digital_port *intel_dig_port = intel_mst->primary;
+	struct intel_dp *intel_dp = &intel_dig_port->dp;
+	struct drm_device *dev = encoder->base.dev;
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	enum port port = intel_dig_port->port;
+	int ret;
+	uint32_t temp;
+	struct intel_connector *found = NULL, *intel_connector;
+	int slots;
+	struct drm_crtc *crtc = encoder->base.crtc;
+	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
+
+	list_for_each_entry(intel_connector, &dev->mode_config.connector_list, base.head) {
+		if (intel_connector->new_encoder == encoder) {
+			found = intel_connector;
+			break;
+		}
+	}
+
+	if (!found) {
+		DRM_ERROR("can't find connector\n");
+		return;
+	}
+
+	DRM_DEBUG_KMS("%d\n", intel_dp->active_mst_links);
+	intel_mst->port = found->port;
+
+	if (intel_dp->active_mst_links == 0) {
+		enum port port = intel_ddi_get_encoder_port(encoder);
+
+		I915_WRITE(PORT_CLK_SEL(port), intel_crtc->config.ddi_pll_sel);
+
+		intel_ddi_init_dp_buf_reg(&intel_dig_port->base);
+
+		intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_ON);
+
+
+		intel_dp_start_link_train(intel_dp);
+		intel_dp_complete_link_train(intel_dp);
+		intel_dp_stop_link_train(intel_dp);
+	}
+
+	ret = drm_dp_mst_allocate_vcpi(&intel_dp->mst_mgr,
+				       intel_mst->port, intel_crtc->config.pbn, &slots);
+	if (ret == false) {
+		DRM_ERROR("failed to allocate vcpi\n");
+		return;
+	}
+
+
+	intel_dp->active_mst_links++;
+	temp = I915_READ(DP_TP_STATUS(port));
+	I915_WRITE(DP_TP_STATUS(port), temp);
+
+	ret = drm_dp_update_payload_part1(&intel_dp->mst_mgr);
+}
+
+static void intel_mst_enable_dp(struct intel_encoder *encoder)
+{
+	struct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);
+	struct intel_digital_port *intel_dig_port = intel_mst->primary;
+	struct intel_dp *intel_dp = &intel_dig_port->dp;
+	struct drm_device *dev = intel_dig_port->base.base.dev;
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	enum port port = intel_dig_port->port;
+	int ret;
+
+	DRM_DEBUG_KMS("%d\n", intel_dp->active_mst_links);
+
+	if (wait_for((I915_READ(DP_TP_STATUS(port)) & DP_TP_STATUS_ACT_SENT),
+		     1))
+		DRM_ERROR("Timed out waiting for ACT sent\n");
+
+	ret = drm_dp_check_act_status(&intel_dp->mst_mgr);
+
+	ret = drm_dp_update_payload_part2(&intel_dp->mst_mgr);
+}
+
+static bool intel_dp_mst_enc_get_hw_state(struct intel_encoder *encoder,
+				      enum pipe *pipe)
+{
+	struct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);
+	*pipe = intel_mst->pipe;
+	if (intel_mst->port)
+		return true;
+	return false;
+}
+
+static void intel_dp_mst_enc_get_config(struct intel_encoder *encoder,
+					struct intel_crtc_config *pipe_config)
+{
+	struct intel_dp_mst_encoder *intel_mst = enc_to_mst(&encoder->base);
+	struct intel_digital_port *intel_dig_port = intel_mst->primary;
+	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
+	struct drm_device *dev = encoder->base.dev;
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	enum transcoder cpu_transcoder = crtc->config.cpu_transcoder;
+	u32 temp, flags = 0;
+
+	pipe_config->has_dp_encoder = true;
+
+	temp = I915_READ(TRANS_DDI_FUNC_CTL(cpu_transcoder));
+	if (temp & TRANS_DDI_PHSYNC)
+		flags |= DRM_MODE_FLAG_PHSYNC;
+	else
+		flags |= DRM_MODE_FLAG_NHSYNC;
+	if (temp & TRANS_DDI_PVSYNC)
+		flags |= DRM_MODE_FLAG_PVSYNC;
+	else
+		flags |= DRM_MODE_FLAG_NVSYNC;
+
+	switch (temp & TRANS_DDI_BPC_MASK) {
+	case TRANS_DDI_BPC_6:
+		pipe_config->pipe_bpp = 18;
+		break;
+	case TRANS_DDI_BPC_8:
+		pipe_config->pipe_bpp = 24;
+		break;
+	case TRANS_DDI_BPC_10:
+		pipe_config->pipe_bpp = 30;
+		break;
+	case TRANS_DDI_BPC_12:
+		pipe_config->pipe_bpp = 36;
+		break;
+	default:
+		break;
+	}
+	pipe_config->adjusted_mode.flags |= flags;
+	intel_dp_get_m_n(crtc, pipe_config);
+
+	intel_ddi_clock_get(&intel_dig_port->base, pipe_config);
+}
+
+static int intel_dp_mst_get_ddc_modes(struct drm_connector *connector)
+{
+	struct intel_connector *intel_connector = to_intel_connector(connector);
+	struct intel_dp *intel_dp = intel_connector->mst_port;
+	struct edid *edid;
+	int ret;
+
+	edid = drm_dp_mst_get_edid(connector, &intel_dp->mst_mgr, intel_connector->port);
+	if (!edid)
+		return 0;
+
+	ret = intel_connector_update_modes(connector, edid);
+	kfree(edid);
+
+	return ret;
+}
+
+static enum drm_connector_status
+intel_mst_port_dp_detect(struct drm_connector *connector)
+{
+	struct intel_connector *intel_connector = to_intel_connector(connector);
+	struct intel_dp *intel_dp = intel_connector->mst_port;
+
+	return drm_dp_mst_detect_port(&intel_dp->mst_mgr, intel_connector->port);
+}
+
+static enum drm_connector_status
+intel_dp_mst_detect(struct drm_connector *connector, bool force)
+{
+	enum drm_connector_status status;
+	status = intel_mst_port_dp_detect(connector);
+	return status;
+}
+
+static int
+intel_dp_mst_set_property(struct drm_connector *connector,
+			  struct drm_property *property,
+			  uint64_t val)
+{
+	return 0;
+}
+
+static void
+intel_dp_mst_connector_destroy(struct drm_connector *connector)
+{
+	struct intel_connector *intel_connector = to_intel_connector(connector);
+
+	if (!IS_ERR_OR_NULL(intel_connector->edid))
+		kfree(intel_connector->edid);
+
+	drm_connector_cleanup(connector);
+	kfree(connector);
+}
+
+static const struct drm_connector_funcs intel_dp_mst_connector_funcs = {
+	.dpms = intel_connector_dpms,
+	.detect = intel_dp_mst_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.set_property = intel_dp_mst_set_property,
+	.destroy = intel_dp_mst_connector_destroy,
+};
+
+static int intel_dp_mst_get_modes(struct drm_connector *connector)
+{
+	return intel_dp_mst_get_ddc_modes(connector);
+}
+
+static enum drm_mode_status
+intel_dp_mst_mode_valid(struct drm_connector *connector,
+			struct drm_display_mode *mode)
+{
+	/* TODO - validate mode against available PBN for link */
+	if (mode->clock < 10000)
+		return MODE_CLOCK_LOW;
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		return MODE_H_ILLEGAL;
+
+	return MODE_OK;
+}
+
+static struct drm_encoder *intel_mst_best_encoder(struct drm_connector *connector)
+{
+	struct intel_connector *intel_connector = to_intel_connector(connector);
+	struct intel_dp *intel_dp = intel_connector->mst_port;
+	return &intel_dp->mst_encoders[0]->base.base;
+}
+
+static const struct drm_connector_helper_funcs intel_dp_mst_connector_helper_funcs = {
+	.get_modes = intel_dp_mst_get_modes,
+	.mode_valid = intel_dp_mst_mode_valid,
+	.best_encoder = intel_mst_best_encoder,
+};
+
+static void intel_dp_mst_encoder_destroy(struct drm_encoder *encoder)
+{
+	struct intel_dp_mst_encoder *intel_mst = enc_to_mst(encoder);
+
+	drm_encoder_cleanup(encoder);
+	kfree(intel_mst);
+}
+
+static const struct drm_encoder_funcs intel_dp_mst_enc_funcs = {
+	.destroy = intel_dp_mst_encoder_destroy,
+};
+
+static bool intel_dp_mst_get_hw_state(struct intel_connector *connector)
+{
+	if (connector->encoder) {
+		enum pipe pipe;
+		if (!connector->encoder->get_hw_state(connector->encoder, &pipe))
+			return false;
+		return true;
+	}
+	return false;
+}
+
+static struct drm_connector *intel_dp_add_mst_connector(struct drm_dp_mst_topology_mgr *mgr, struct drm_dp_mst_port *port, char *pathprop)
+{
+	struct intel_dp *intel_dp = container_of(mgr, struct intel_dp, mst_mgr);
+	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
+	struct drm_device *dev = intel_dig_port->base.base.dev;
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	struct intel_connector *intel_connector;
+	struct drm_connector *connector;
+	int i;
+
+	intel_connector = kzalloc(sizeof(*intel_connector), GFP_KERNEL);
+	if (!intel_connector)
+		return NULL;
+
+	connector = &intel_connector->base;
+	drm_connector_init(dev, connector, &intel_dp_mst_connector_funcs, DRM_MODE_CONNECTOR_DisplayPort);
+	drm_connector_helper_add(connector, &intel_dp_mst_connector_helper_funcs);
+
+	intel_connector->unregister = intel_connector_unregister;
+	intel_connector->get_hw_state = intel_dp_mst_get_hw_state;
+	intel_connector->mst_port = intel_dp;
+	intel_connector->port = port;
+
+	for (i = PIPE_A; i <= PIPE_C; i++) {
+		drm_mode_connector_attach_encoder(&intel_connector->base,
+						  &intel_dp->mst_encoders[i]->base.base);
+	}
+	intel_dp_add_properties(intel_dp, connector);
+
+	drm_object_attach_property(&connector->base, dev->mode_config.path_property, 0);
+	drm_mode_connector_set_path_property(connector, pathprop);
+	drm_reinit_primary_mode_group(dev);
+	mutex_lock(&dev->mode_config.mutex);
+	drm_fb_helper_add_one_connector(&dev_priv->fbdev->helper, connector);
+	mutex_unlock(&dev->mode_config.mutex);
+	drm_connector_register(&intel_connector->base);
+	return connector;
+}
+
+static void intel_dp_destroy_mst_connector(struct drm_dp_mst_topology_mgr *mgr,
+					   struct drm_connector *connector)
+{
+	struct intel_connector *intel_connector = to_intel_connector(connector);
+	struct drm_device *dev = connector->dev;
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	/* need to nuke the connector */
+	mutex_lock(&dev->mode_config.mutex);
+	intel_connector_dpms(connector, DRM_MODE_DPMS_OFF);
+	mutex_unlock(&dev->mode_config.mutex);
+
+	intel_connector->unregister(intel_connector);
+
+	mutex_lock(&dev->mode_config.mutex);
+	drm_fb_helper_remove_one_connector(&dev_priv->fbdev->helper, connector);
+	drm_connector_cleanup(connector);
+	mutex_unlock(&dev->mode_config.mutex);
+
+	drm_reinit_primary_mode_group(dev);
+
+	kfree(intel_connector);
+	DRM_DEBUG_KMS("\n");
+}
+
+static void intel_dp_mst_hotplug(struct drm_dp_mst_topology_mgr *mgr)
+{
+	struct intel_dp *intel_dp = container_of(mgr, struct intel_dp, mst_mgr);
+	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
+	struct drm_device *dev = intel_dig_port->base.base.dev;
+
+	drm_kms_helper_hotplug_event(dev);
+}
+
+static struct drm_dp_mst_topology_cbs mst_cbs = {
+	.add_connector = intel_dp_add_mst_connector,
+	.destroy_connector = intel_dp_destroy_mst_connector,
+	.hotplug = intel_dp_mst_hotplug,
+};
+
+static struct intel_dp_mst_encoder *
+intel_dp_create_fake_mst_encoder(struct intel_digital_port *intel_dig_port, enum pipe pipe)
+{
+	struct intel_dp_mst_encoder *intel_mst;
+	struct intel_encoder *intel_encoder;
+	struct drm_device *dev = intel_dig_port->base.base.dev;
+
+	intel_mst = kzalloc(sizeof(*intel_mst), GFP_KERNEL);
+
+	if (!intel_mst)
+		return NULL;
+
+	intel_mst->pipe = pipe;
+	intel_encoder = &intel_mst->base;
+	intel_mst->primary = intel_dig_port;
+
+	drm_encoder_init(dev, &intel_encoder->base, &intel_dp_mst_enc_funcs,
+			 DRM_MODE_ENCODER_DPMST);
+
+	intel_encoder->type = INTEL_OUTPUT_DP_MST;
+	intel_encoder->crtc_mask = 0x7;
+	intel_encoder->cloneable = 0;
+
+	intel_encoder->compute_config = intel_dp_mst_compute_config;
+	intel_encoder->disable = intel_mst_disable_dp;
+	intel_encoder->post_disable = intel_mst_post_disable_dp;
+	intel_encoder->pre_enable = intel_mst_pre_enable_dp;
+	intel_encoder->enable = intel_mst_enable_dp;
+	intel_encoder->get_hw_state = intel_dp_mst_enc_get_hw_state;
+	intel_encoder->get_config = intel_dp_mst_enc_get_config;
+
+	return intel_mst;
+
+}
+
+static bool
+intel_dp_create_fake_mst_encoders(struct intel_digital_port *intel_dig_port)
+{
+	int i;
+	struct intel_dp *intel_dp = &intel_dig_port->dp;
+
+	for (i = PIPE_A; i <= PIPE_C; i++)
+		intel_dp->mst_encoders[i] = intel_dp_create_fake_mst_encoder(intel_dig_port, i);
+	return true;
+}
+
+int
+intel_dp_mst_encoder_init(struct intel_digital_port *intel_dig_port, int conn_base_id)
+{
+	struct intel_dp *intel_dp = &intel_dig_port->dp;
+	struct drm_device *dev = intel_dig_port->base.base.dev;
+	int ret;
+
+	intel_dp->can_mst = true;
+	intel_dp->mst_mgr.cbs = &mst_cbs;
+
+	/* create encoders */
+	intel_dp_create_fake_mst_encoders(intel_dig_port);
+	ret = drm_dp_mst_topology_mgr_init(&intel_dp->mst_mgr, dev->dev, &intel_dp->aux, 16, 3, conn_base_id);
+	if (ret) {
+		intel_dp->can_mst = false;
+		return ret;
+	}
+	return 0;
+}
+
+void
+intel_dp_mst_encoder_cleanup(struct intel_digital_port *intel_dig_port)
+{
+	struct intel_dp *intel_dp = &intel_dig_port->dp;
+
+	if (!intel_dp->can_mst)
+		return;
+
+	drm_dp_mst_topology_mgr_destroy(&intel_dp->mst_mgr);
+	/* encoders will get killed by normal cleanup */
+}
* Unmerged path drivers/gpu/drm/i915/intel_drv.h
* Unmerged path drivers/gpu/drm/i915/intel_fbdev.c
* Unmerged path drivers/gpu/drm/i915/intel_opregion.c
