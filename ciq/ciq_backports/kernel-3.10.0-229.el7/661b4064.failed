ACPI / hotplug / PCI: Drop crit_sect locking

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Drop crit_sect locking (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 88.61%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 661b40644190eb5987907584920cb11a4a2c7a9e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/661b4064.failed

After recent PCI core changes related to the rescan/remove locking,
the code sections under crit_sect mutexes from ACPIPHP slot objects
are always executed under the general PCI rescan/remove lock.
For this reason, the crit_sect mutexes are simply redundant, so drop
them.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 661b40644190eb5987907584920cb11a4a2c7a9e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,0961911c706e..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -221,75 -310,66 +221,88 @@@ register_slot(acpi_handle handle, u32 l
  	device = (adr >> 16) & 0xffff;
  	function = adr & 0xffff;
  
 -	mutex_lock(&acpiphp_context_lock);
 -	context = acpiphp_init_context(adev);
 -	if (!context) {
 -		mutex_unlock(&acpiphp_context_lock);
 -		acpi_handle_err(handle, "No hotplug context\n");
 -		return AE_NOT_EXIST;
 -	}
 -	newfunc = &context->func;
 +	pdev = bridge->pci_dev;
 +	if (pdev && device_is_managed_by_native_pciehp(pdev))
 +		return AE_OK;
 +
 +	newfunc = kzalloc(sizeof(struct acpiphp_func), GFP_KERNEL);
 +	if (!newfunc)
 +		return AE_NO_MEMORY;
 +
 +	newfunc->handle = handle;
  	newfunc->function = function;
 -	newfunc->parent = bridge;
 -	mutex_unlock(&acpiphp_context_lock);
  
 -	if (acpi_has_method(handle, "_EJ0"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
  		newfunc->flags = FUNC_HAS_EJ0;
  
 -	if (acpi_has_method(handle, "_STA"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_STA", &tmp)))
  		newfunc->flags |= FUNC_HAS_STA;
  
 -	if (acpi_has_method(handle, "_DCK"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS0", &tmp)))
 +		newfunc->flags |= FUNC_HAS_PS0;
 +
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS3", &tmp)))
 +		newfunc->flags |= FUNC_HAS_PS3;
 +
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_DCK", &tmp)))
  		newfunc->flags |= FUNC_HAS_DCK;
  
 +	status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 +	if (ACPI_FAILURE(status)) {
 +		/*
 +		 * use the count of the number of slots we've found
 +		 * for the number of the slot
 +		 */
 +		sun = bridge->nr_slots+1;
 +	}
 +
  	/* search for objects that share the same slot */
  	list_for_each_entry(slot, &bridge->slots, node)
 -		if (slot->device == device)
 -			goto slot_found;
 +		if (slot->device == device) {
 +			if (slot->sun != sun)
 +				pr_warn("sibling found, but _SUN doesn't match!\n");
 +			found = 1;
 +			break;
 +		}
  
 -	slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 -	if (!slot) {
 -		mutex_lock(&acpiphp_context_lock);
 -		acpiphp_put_context(context);
 -		mutex_unlock(&acpiphp_context_lock);
 -		return AE_NO_MEMORY;
 -	}
 +	if (!found) {
 +		slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 +		if (!slot) {
 +			kfree(newfunc);
 +			return AE_NO_MEMORY;
 +		}
  
++<<<<<<< HEAD
 +		slot->bridge = bridge;
 +		slot->device = device;
 +		slot->sun = sun;
 +		INIT_LIST_HEAD(&slot->funcs);
 +		mutex_init(&slot->crit_sect);
++=======
+ 	slot->bus = bridge->pci_bus;
+ 	slot->device = device;
+ 	INIT_LIST_HEAD(&slot->funcs);
+ 
+ 	list_add_tail(&slot->node, &bridge->slots);
+ 
+ 	/* Register slots for ejectable functions only. */
+ 	if (acpi_pci_check_ejectable(pbus, handle)  || is_dock_device(handle)) {
+ 		unsigned long long sun;
+ 		int retval;
++>>>>>>> 661b40644190 (ACPI / hotplug / PCI: Drop crit_sect locking)
  
 +		mutex_lock(&bridge_mutex);
 +		list_add_tail(&slot->node, &bridge->slots);
 +		mutex_unlock(&bridge_mutex);
  		bridge->nr_slots++;
 -		status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 -		if (ACPI_FAILURE(status))
 -			sun = bridge->nr_slots;
  
  		pr_debug("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",
 -		    sun, pci_domain_nr(pbus), pbus->number, device);
 -
 -		retval = acpiphp_register_hotplug_slot(slot, sun);
 +		    slot->sun, pci_domain_nr(pbus), pbus->number, device);
 +		retval = acpiphp_register_hotplug_slot(slot);
  		if (retval) {
 -			slot->slot = NULL;
 -			bridge->nr_slots--;
  			if (retval == -EBUSY)
  				pr_warn("Slot %llu already registered by another "
 -					"hotplug driver\n", sun);
 +					"hotplug driver\n", slot->sun);
  			else
  				pr_warn("acpiphp_register_hotplug_slot failed "
  					"(err code = 0x%x)\n", retval);
@@@ -870,43 -731,33 +883,60 @@@ int acpiphp_eject_slot(struct acpiphp_s
   * Iterate over all slots under this bridge and make sure that if a
   * card is present they are enabled, and if not they are disabled.
   */
 -static void acpiphp_check_bridge(struct acpiphp_bridge *bridge)
 +static int acpiphp_check_bridge(struct acpiphp_bridge *bridge)
  {
  	struct acpiphp_slot *slot;
 +	int retval = 0;
 +	int enabled, disabled;
  
 -	/* Bail out if the bridge is going away. */
 -	if (bridge->is_going_away)
 -		return;
 +	enabled = disabled = 0;
  
  	list_for_each_entry(slot, &bridge->slots, node) {
++<<<<<<< HEAD
 +		unsigned int status = get_slot_status(slot);
 +		if (slot->flags & SLOT_ENABLED) {
 +			if (status == ACPI_STA_ALL)
 +				continue;
 +			retval = acpiphp_disable_slot(slot);
 +			if (retval) {
 +				pr_err("Error occurred in disabling\n");
 +				goto err_exit;
 +			} else {
 +				acpiphp_eject_slot(slot);
 +			}
 +			disabled++;
++=======
+ 		struct pci_bus *bus = slot->bus;
+ 		struct pci_dev *dev, *tmp;
+ 
+ 		if (slot_no_hotplug(slot)) {
+ 			; /* do nothing */
+ 		} else if (get_slot_status(slot) == ACPI_STA_ALL) {
+ 			/* remove stale devices if any */
+ 			list_for_each_entry_safe_reverse(dev, tmp,
+ 							 &bus->devices, bus_list)
+ 				if (PCI_SLOT(dev->devfn) == slot->device)
+ 					trim_stale_devices(dev);
+ 
+ 			/* configure all functions */
+ 			enable_slot(slot);
++>>>>>>> 661b40644190 (ACPI / hotplug / PCI: Drop crit_sect locking)
  		} else {
 -			disable_slot(slot);
 +			if (status != ACPI_STA_ALL)
 +				continue;
 +			retval = acpiphp_enable_slot(slot);
 +			if (retval) {
 +				pr_err("Error occurred in enabling\n");
 +				goto err_exit;
 +			}
 +			enabled++;
  		}
  	}
 +
 +	pr_debug("%s: %d enabled, %d disabled\n", __func__, enabled, disabled);
 +
 + err_exit:
 +	return retval;
  }
  
  static void acpiphp_set_hpp_values(struct pci_bus *bus)
@@@ -1007,20 -838,34 +1037,49 @@@ static void _handle_hotplug_event_bridg
  		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
  		pr_debug("%s: re-enumerating slots under %s\n",
  			 __func__, objname);
++<<<<<<< HEAD
 +		acpiphp_check_bridge(bridge);
 +		acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
 +			ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
++=======
+ 		if (bridge) {
+ 			acpiphp_check_bridge(bridge);
+ 		} else {
+ 			struct acpiphp_slot *slot = func->slot;
+ 
+ 			if (!(slot->flags & SLOT_IS_GOING_AWAY))
+ 				enable_slot(slot);
+ 		}
++>>>>>>> 661b40644190 (ACPI / hotplug / PCI: Drop crit_sect locking)
  		break;
  
  	case ACPI_NOTIFY_DEVICE_CHECK:
  		/* device check */
  		pr_debug("%s: Device check notify on %s\n", __func__, objname);
++<<<<<<< HEAD
 +		acpiphp_check_bridge(bridge);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_WAKE:
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
++=======
+ 		if (bridge) {
+ 			acpiphp_check_bridge(bridge);
+ 		} else {
+ 			struct acpiphp_slot *slot = func->slot;
+ 
+ 			if (slot->flags & SLOT_IS_GOING_AWAY)
+ 				break;
+ 
+ 			/*
+ 			 * Check if anything has changed in the slot and rescan
+ 			 * from the parent if that's the case.
+ 			 */
+ 			if (acpiphp_rescan_slot(slot))
+ 				acpiphp_check_bridge(func->parent);
+ 		}
++>>>>>>> 661b40644190 (ACPI / hotplug / PCI: Drop crit_sect locking)
  		break;
  
  	case ACPI_NOTIFY_EJECT_REQUEST:
@@@ -1238,55 -1072,55 +1297,66 @@@ void acpiphp_remove_slots(struct pci_bu
   */
  int acpiphp_enable_slot(struct acpiphp_slot *slot)
  {
 -	pci_lock_rescan_remove();
 -
 -	if (slot->flags & SLOT_IS_GOING_AWAY)
 -		return -ENODEV;
 +	int retval;
 +
++<<<<<<< HEAD
 +	mutex_lock(&slot->crit_sect);
 +
 +	/* wake up all functions */
 +	retval = power_on_slot(slot);
 +	if (retval)
 +		goto err_exit;
 +
 +	if (get_slot_status(slot) == ACPI_STA_ALL) {
 +		/* configure all functions */
 +		retval = enable_device(slot);
 +		if (retval)
 +			power_off_slot(slot);
 +	} else {
 +		pr_debug("%s: Slot status is not ACPI_STA_ALL\n", __func__);
 +		power_off_slot(slot);
 +	}
  
 + err_exit:
 +	mutex_unlock(&slot->crit_sect);
 +	return retval;
++=======
+ 	/* configure all functions */
+ 	if (!(slot->flags & SLOT_ENABLED))
+ 		enable_slot(slot);
+ 
+ 	pci_unlock_rescan_remove();
+ 	return 0;
++>>>>>>> 661b40644190 (ACPI / hotplug / PCI: Drop crit_sect locking)
  }
  
  /**
 - * acpiphp_disable_and_eject_slot - power off and eject slot
 + * acpiphp_disable_slot - power off slot
   * @slot: ACPI PHP slot
   */
 -static int acpiphp_disable_and_eject_slot(struct acpiphp_slot *slot)
 +int acpiphp_disable_slot(struct acpiphp_slot *slot)
  {
 -	struct acpiphp_func *func;
 -
 -	if (slot->flags & SLOT_IS_GOING_AWAY)
 -		return -ENODEV;
 +	int retval = 0;
  
- 	mutex_lock(&slot->crit_sect);
- 
  	/* unconfigure all functions */
 -	disable_slot(slot);
 -
 -	list_for_each_entry(func, &slot->funcs, sibling)
 -		if (func->flags & FUNC_HAS_EJ0) {
 -			acpi_handle handle = func_to_handle(func);
 -
 -			if (ACPI_FAILURE(acpi_evaluate_ej0(handle)))
 -				acpi_handle_err(handle, "_EJ0 failed\n");
 -
 -			break;
 -		}
 -
 +	retval = disable_device(slot);
 +	if (retval)
 +		goto err_exit;
 +
 +	/* power off all functions */
 +	retval = power_off_slot(slot);
 +	if (retval)
 +		goto err_exit;
 +
++<<<<<<< HEAD
 + err_exit:
 +	mutex_unlock(&slot->crit_sect);
 +	return retval;
++=======
+ 	return 0;
++>>>>>>> 661b40644190 (ACPI / hotplug / PCI: Drop crit_sect locking)
  }
  
 -int acpiphp_disable_slot(struct acpiphp_slot *slot)
 -{
 -	int ret;
 -
 -	pci_lock_rescan_remove();
 -	ret = acpiphp_disable_and_eject_slot(slot);
 -	pci_unlock_rescan_remove();
 -	return ret;
 -}
  
  /*
   * slot enabled:  1
diff --git a/drivers/pci/hotplug/acpiphp.h b/drivers/pci/hotplug/acpiphp.h
index 9435d828e52f..a243ed5ba72e 100644
--- a/drivers/pci/hotplug/acpiphp.h
+++ b/drivers/pci/hotplug/acpiphp.h
@@ -93,7 +93,6 @@ struct acpiphp_slot {
 	struct list_head funcs;		/* one slot may have different
 					   objects (i.e. for each function) */
 	struct slot *slot;
-	struct mutex crit_sect;
 
 	u8		device;		/* pci device# */
 
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
