drm/i915: mst topology dumper in debugfs (v0.2)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] i915: mst topology dumper in debugfs (v0.2) (Dave Airlie) [1140440]
Rebuild_FUZZ: 95.56%
commit-author Dave Airlie <airlied@redhat.com>
commit 11bed958b72e15fd12d78c30ce49047b94817840
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/11bed958.failed

use the mst helper code to dump the topology in debugfs.

v0.2: drop is_mst check - as we want to dump other info

	Reviewed-by: Todd Previte <tprevite@gmail.com>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 11bed958b72e15fd12d78c30ce49047b94817840)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/i915_debugfs.c
diff --cc drivers/gpu/drm/i915/i915_debugfs.c
index a6f4cb5af185,e6ff0ecf161c..000000000000
--- a/drivers/gpu/drm/i915/i915_debugfs.c
+++ b/drivers/gpu/drm/i915/i915_debugfs.c
@@@ -1825,6 -1994,1410 +1825,1413 @@@ static int i915_pc8_status(struct seq_f
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static const char *power_domain_str(enum intel_display_power_domain domain)
+ {
+ 	switch (domain) {
+ 	case POWER_DOMAIN_PIPE_A:
+ 		return "PIPE_A";
+ 	case POWER_DOMAIN_PIPE_B:
+ 		return "PIPE_B";
+ 	case POWER_DOMAIN_PIPE_C:
+ 		return "PIPE_C";
+ 	case POWER_DOMAIN_PIPE_A_PANEL_FITTER:
+ 		return "PIPE_A_PANEL_FITTER";
+ 	case POWER_DOMAIN_PIPE_B_PANEL_FITTER:
+ 		return "PIPE_B_PANEL_FITTER";
+ 	case POWER_DOMAIN_PIPE_C_PANEL_FITTER:
+ 		return "PIPE_C_PANEL_FITTER";
+ 	case POWER_DOMAIN_TRANSCODER_A:
+ 		return "TRANSCODER_A";
+ 	case POWER_DOMAIN_TRANSCODER_B:
+ 		return "TRANSCODER_B";
+ 	case POWER_DOMAIN_TRANSCODER_C:
+ 		return "TRANSCODER_C";
+ 	case POWER_DOMAIN_TRANSCODER_EDP:
+ 		return "TRANSCODER_EDP";
+ 	case POWER_DOMAIN_PORT_DDI_A_2_LANES:
+ 		return "PORT_DDI_A_2_LANES";
+ 	case POWER_DOMAIN_PORT_DDI_A_4_LANES:
+ 		return "PORT_DDI_A_4_LANES";
+ 	case POWER_DOMAIN_PORT_DDI_B_2_LANES:
+ 		return "PORT_DDI_B_2_LANES";
+ 	case POWER_DOMAIN_PORT_DDI_B_4_LANES:
+ 		return "PORT_DDI_B_4_LANES";
+ 	case POWER_DOMAIN_PORT_DDI_C_2_LANES:
+ 		return "PORT_DDI_C_2_LANES";
+ 	case POWER_DOMAIN_PORT_DDI_C_4_LANES:
+ 		return "PORT_DDI_C_4_LANES";
+ 	case POWER_DOMAIN_PORT_DDI_D_2_LANES:
+ 		return "PORT_DDI_D_2_LANES";
+ 	case POWER_DOMAIN_PORT_DDI_D_4_LANES:
+ 		return "PORT_DDI_D_4_LANES";
+ 	case POWER_DOMAIN_PORT_DSI:
+ 		return "PORT_DSI";
+ 	case POWER_DOMAIN_PORT_CRT:
+ 		return "PORT_CRT";
+ 	case POWER_DOMAIN_PORT_OTHER:
+ 		return "PORT_OTHER";
+ 	case POWER_DOMAIN_VGA:
+ 		return "VGA";
+ 	case POWER_DOMAIN_AUDIO:
+ 		return "AUDIO";
+ 	case POWER_DOMAIN_PLLS:
+ 		return "PLLS";
+ 	case POWER_DOMAIN_INIT:
+ 		return "INIT";
+ 	default:
+ 		WARN_ON(1);
+ 		return "?";
+ 	}
+ }
+ 
+ static int i915_power_domain_info(struct seq_file *m, void *unused)
+ {
+ 	struct drm_info_node *node = m->private;
+ 	struct drm_device *dev = node->minor->dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct i915_power_domains *power_domains = &dev_priv->power_domains;
+ 	int i;
+ 
+ 	mutex_lock(&power_domains->lock);
+ 
+ 	seq_printf(m, "%-25s %s\n", "Power well/domain", "Use count");
+ 	for (i = 0; i < power_domains->power_well_count; i++) {
+ 		struct i915_power_well *power_well;
+ 		enum intel_display_power_domain power_domain;
+ 
+ 		power_well = &power_domains->power_wells[i];
+ 		seq_printf(m, "%-25s %d\n", power_well->name,
+ 			   power_well->count);
+ 
+ 		for (power_domain = 0; power_domain < POWER_DOMAIN_NUM;
+ 		     power_domain++) {
+ 			if (!(BIT(power_domain) & power_well->domains))
+ 				continue;
+ 
+ 			seq_printf(m, "  %-23s %d\n",
+ 				 power_domain_str(power_domain),
+ 				 power_domains->domain_use_count[power_domain]);
+ 		}
+ 	}
+ 
+ 	mutex_unlock(&power_domains->lock);
+ 
+ 	return 0;
+ }
+ 
+ static void intel_seq_print_mode(struct seq_file *m, int tabs,
+ 				 struct drm_display_mode *mode)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < tabs; i++)
+ 		seq_putc(m, '\t');
+ 
+ 	seq_printf(m, "id %d:\"%s\" freq %d clock %d hdisp %d hss %d hse %d htot %d vdisp %d vss %d vse %d vtot %d type 0x%x flags 0x%x\n",
+ 		   mode->base.id, mode->name,
+ 		   mode->vrefresh, mode->clock,
+ 		   mode->hdisplay, mode->hsync_start,
+ 		   mode->hsync_end, mode->htotal,
+ 		   mode->vdisplay, mode->vsync_start,
+ 		   mode->vsync_end, mode->vtotal,
+ 		   mode->type, mode->flags);
+ }
+ 
+ static void intel_encoder_info(struct seq_file *m,
+ 			       struct intel_crtc *intel_crtc,
+ 			       struct intel_encoder *intel_encoder)
+ {
+ 	struct drm_info_node *node = m->private;
+ 	struct drm_device *dev = node->minor->dev;
+ 	struct drm_crtc *crtc = &intel_crtc->base;
+ 	struct intel_connector *intel_connector;
+ 	struct drm_encoder *encoder;
+ 
+ 	encoder = &intel_encoder->base;
+ 	seq_printf(m, "\tencoder %d: type: %s, connectors:\n",
+ 		   encoder->base.id, encoder->name);
+ 	for_each_connector_on_encoder(dev, encoder, intel_connector) {
+ 		struct drm_connector *connector = &intel_connector->base;
+ 		seq_printf(m, "\t\tconnector %d: type: %s, status: %s",
+ 			   connector->base.id,
+ 			   connector->name,
+ 			   drm_get_connector_status_name(connector->status));
+ 		if (connector->status == connector_status_connected) {
+ 			struct drm_display_mode *mode = &crtc->mode;
+ 			seq_printf(m, ", mode:\n");
+ 			intel_seq_print_mode(m, 2, mode);
+ 		} else {
+ 			seq_putc(m, '\n');
+ 		}
+ 	}
+ }
+ 
+ static void intel_crtc_info(struct seq_file *m, struct intel_crtc *intel_crtc)
+ {
+ 	struct drm_info_node *node = m->private;
+ 	struct drm_device *dev = node->minor->dev;
+ 	struct drm_crtc *crtc = &intel_crtc->base;
+ 	struct intel_encoder *intel_encoder;
+ 
+ 	if (crtc->primary->fb)
+ 		seq_printf(m, "\tfb: %d, pos: %dx%d, size: %dx%d\n",
+ 			   crtc->primary->fb->base.id, crtc->x, crtc->y,
+ 			   crtc->primary->fb->width, crtc->primary->fb->height);
+ 	else
+ 		seq_puts(m, "\tprimary plane disabled\n");
+ 	for_each_encoder_on_crtc(dev, crtc, intel_encoder)
+ 		intel_encoder_info(m, intel_crtc, intel_encoder);
+ }
+ 
+ static void intel_panel_info(struct seq_file *m, struct intel_panel *panel)
+ {
+ 	struct drm_display_mode *mode = panel->fixed_mode;
+ 
+ 	seq_printf(m, "\tfixed mode:\n");
+ 	intel_seq_print_mode(m, 2, mode);
+ }
+ 
+ static void intel_dp_info(struct seq_file *m,
+ 			  struct intel_connector *intel_connector)
+ {
+ 	struct intel_encoder *intel_encoder = intel_connector->encoder;
+ 	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);
+ 
+ 	seq_printf(m, "\tDPCD rev: %x\n", intel_dp->dpcd[DP_DPCD_REV]);
+ 	seq_printf(m, "\taudio support: %s\n", intel_dp->has_audio ? "yes" :
+ 		   "no");
+ 	if (intel_encoder->type == INTEL_OUTPUT_EDP)
+ 		intel_panel_info(m, &intel_connector->panel);
+ }
+ 
+ static void intel_hdmi_info(struct seq_file *m,
+ 			    struct intel_connector *intel_connector)
+ {
+ 	struct intel_encoder *intel_encoder = intel_connector->encoder;
+ 	struct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(&intel_encoder->base);
+ 
+ 	seq_printf(m, "\taudio support: %s\n", intel_hdmi->has_audio ? "yes" :
+ 		   "no");
+ }
+ 
+ static void intel_lvds_info(struct seq_file *m,
+ 			    struct intel_connector *intel_connector)
+ {
+ 	intel_panel_info(m, &intel_connector->panel);
+ }
+ 
+ static void intel_connector_info(struct seq_file *m,
+ 				 struct drm_connector *connector)
+ {
+ 	struct intel_connector *intel_connector = to_intel_connector(connector);
+ 	struct intel_encoder *intel_encoder = intel_connector->encoder;
+ 	struct drm_display_mode *mode;
+ 
+ 	seq_printf(m, "connector %d: type %s, status: %s\n",
+ 		   connector->base.id, connector->name,
+ 		   drm_get_connector_status_name(connector->status));
+ 	if (connector->status == connector_status_connected) {
+ 		seq_printf(m, "\tname: %s\n", connector->display_info.name);
+ 		seq_printf(m, "\tphysical dimensions: %dx%dmm\n",
+ 			   connector->display_info.width_mm,
+ 			   connector->display_info.height_mm);
+ 		seq_printf(m, "\tsubpixel order: %s\n",
+ 			   drm_get_subpixel_order_name(connector->display_info.subpixel_order));
+ 		seq_printf(m, "\tCEA rev: %d\n",
+ 			   connector->display_info.cea_rev);
+ 	}
+ 	if (intel_encoder) {
+ 		if (intel_encoder->type == INTEL_OUTPUT_DISPLAYPORT ||
+ 		    intel_encoder->type == INTEL_OUTPUT_EDP)
+ 			intel_dp_info(m, intel_connector);
+ 		else if (intel_encoder->type == INTEL_OUTPUT_HDMI)
+ 			intel_hdmi_info(m, intel_connector);
+ 		else if (intel_encoder->type == INTEL_OUTPUT_LVDS)
+ 			intel_lvds_info(m, intel_connector);
+ 	}
+ 
+ 	seq_printf(m, "\tmodes:\n");
+ 	list_for_each_entry(mode, &connector->modes, head)
+ 		intel_seq_print_mode(m, 2, mode);
+ }
+ 
+ static bool cursor_active(struct drm_device *dev, int pipe)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	u32 state;
+ 
+ 	if (IS_845G(dev) || IS_I865G(dev))
+ 		state = I915_READ(_CURACNTR) & CURSOR_ENABLE;
+ 	else
+ 		state = I915_READ(CURCNTR(pipe)) & CURSOR_MODE;
+ 
+ 	return state;
+ }
+ 
+ static bool cursor_position(struct drm_device *dev, int pipe, int *x, int *y)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	u32 pos;
+ 
+ 	pos = I915_READ(CURPOS(pipe));
+ 
+ 	*x = (pos >> CURSOR_X_SHIFT) & CURSOR_POS_MASK;
+ 	if (pos & (CURSOR_POS_SIGN << CURSOR_X_SHIFT))
+ 		*x = -*x;
+ 
+ 	*y = (pos >> CURSOR_Y_SHIFT) & CURSOR_POS_MASK;
+ 	if (pos & (CURSOR_POS_SIGN << CURSOR_Y_SHIFT))
+ 		*y = -*y;
+ 
+ 	return cursor_active(dev, pipe);
+ }
+ 
+ static int i915_display_info(struct seq_file *m, void *unused)
+ {
+ 	struct drm_info_node *node = m->private;
+ 	struct drm_device *dev = node->minor->dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct intel_crtc *crtc;
+ 	struct drm_connector *connector;
+ 
+ 	intel_runtime_pm_get(dev_priv);
+ 	drm_modeset_lock_all(dev);
+ 	seq_printf(m, "CRTC info\n");
+ 	seq_printf(m, "---------\n");
+ 	for_each_intel_crtc(dev, crtc) {
+ 		bool active;
+ 		int x, y;
+ 
+ 		seq_printf(m, "CRTC %d: pipe: %c, active=%s (size=%dx%d)\n",
+ 			   crtc->base.base.id, pipe_name(crtc->pipe),
+ 			   yesno(crtc->active), crtc->config.pipe_src_w, crtc->config.pipe_src_h);
+ 		if (crtc->active) {
+ 			intel_crtc_info(m, crtc);
+ 
+ 			active = cursor_position(dev, crtc->pipe, &x, &y);
+ 			seq_printf(m, "\tcursor visible? %s, position (%d, %d), size %dx%d, addr 0x%08x, active? %s\n",
+ 				   yesno(crtc->cursor_base),
+ 				   x, y, crtc->cursor_width, crtc->cursor_height,
+ 				   crtc->cursor_addr, yesno(active));
+ 		}
+ 
+ 		seq_printf(m, "\tunderrun reporting: cpu=%s pch=%s \n",
+ 			   yesno(!crtc->cpu_fifo_underrun_disabled),
+ 			   yesno(!crtc->pch_fifo_underrun_disabled));
+ 	}
+ 
+ 	seq_printf(m, "\n");
+ 	seq_printf(m, "Connector info\n");
+ 	seq_printf(m, "--------------\n");
+ 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+ 		intel_connector_info(m, connector);
+ 	}
+ 	drm_modeset_unlock_all(dev);
+ 	intel_runtime_pm_put(dev_priv);
+ 
+ 	return 0;
+ }
+ 
+ static int i915_semaphore_status(struct seq_file *m, void *unused)
+ {
+ 	struct drm_info_node *node = (struct drm_info_node *) m->private;
+ 	struct drm_device *dev = node->minor->dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct intel_engine_cs *ring;
+ 	int num_rings = hweight32(INTEL_INFO(dev)->ring_mask);
+ 	int i, j, ret;
+ 
+ 	if (!i915_semaphore_is_enabled(dev)) {
+ 		seq_puts(m, "Semaphores are disabled\n");
+ 		return 0;
+ 	}
+ 
+ 	ret = mutex_lock_interruptible(&dev->struct_mutex);
+ 	if (ret)
+ 		return ret;
+ 	intel_runtime_pm_get(dev_priv);
+ 
+ 	if (IS_BROADWELL(dev)) {
+ 		struct page *page;
+ 		uint64_t *seqno;
+ 
+ 		page = i915_gem_object_get_page(dev_priv->semaphore_obj, 0);
+ 
+ 		seqno = (uint64_t *)kmap_atomic(page);
+ 		for_each_ring(ring, dev_priv, i) {
+ 			uint64_t offset;
+ 
+ 			seq_printf(m, "%s\n", ring->name);
+ 
+ 			seq_puts(m, "  Last signal:");
+ 			for (j = 0; j < num_rings; j++) {
+ 				offset = i * I915_NUM_RINGS + j;
+ 				seq_printf(m, "0x%08llx (0x%02llx) ",
+ 					   seqno[offset], offset * 8);
+ 			}
+ 			seq_putc(m, '\n');
+ 
+ 			seq_puts(m, "  Last wait:  ");
+ 			for (j = 0; j < num_rings; j++) {
+ 				offset = i + (j * I915_NUM_RINGS);
+ 				seq_printf(m, "0x%08llx (0x%02llx) ",
+ 					   seqno[offset], offset * 8);
+ 			}
+ 			seq_putc(m, '\n');
+ 
+ 		}
+ 		kunmap_atomic(seqno);
+ 	} else {
+ 		seq_puts(m, "  Last signal:");
+ 		for_each_ring(ring, dev_priv, i)
+ 			for (j = 0; j < num_rings; j++)
+ 				seq_printf(m, "0x%08x\n",
+ 					   I915_READ(ring->semaphore.mbox.signal[j]));
+ 		seq_putc(m, '\n');
+ 	}
+ 
+ 	seq_puts(m, "\nSync seqno:\n");
+ 	for_each_ring(ring, dev_priv, i) {
+ 		for (j = 0; j < num_rings; j++) {
+ 			seq_printf(m, "  0x%08x ", ring->semaphore.sync_seqno[j]);
+ 		}
+ 		seq_putc(m, '\n');
+ 	}
+ 	seq_putc(m, '\n');
+ 
+ 	intel_runtime_pm_put(dev_priv);
+ 	mutex_unlock(&dev->struct_mutex);
+ 	return 0;
+ }
+ 
+ static int i915_shared_dplls_info(struct seq_file *m, void *unused)
+ {
+ 	struct drm_info_node *node = (struct drm_info_node *) m->private;
+ 	struct drm_device *dev = node->minor->dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	int i;
+ 
+ 	drm_modeset_lock_all(dev);
+ 	for (i = 0; i < dev_priv->num_shared_dpll; i++) {
+ 		struct intel_shared_dpll *pll = &dev_priv->shared_dplls[i];
+ 
+ 		seq_printf(m, "DPLL%i: %s, id: %i\n", i, pll->name, pll->id);
+ 		seq_printf(m, " refcount: %i, active: %i, on: %s\n", pll->refcount,
+ 			   pll->active, yesno(pll->on));
+ 		seq_printf(m, " tracked hardware state:\n");
+ 		seq_printf(m, " dpll:    0x%08x\n", pll->hw_state.dpll);
+ 		seq_printf(m, " dpll_md: 0x%08x\n", pll->hw_state.dpll_md);
+ 		seq_printf(m, " fp0:     0x%08x\n", pll->hw_state.fp0);
+ 		seq_printf(m, " fp1:     0x%08x\n", pll->hw_state.fp1);
+ 		seq_printf(m, " wrpll:   0x%08x\n", pll->hw_state.wrpll);
+ 	}
+ 	drm_modeset_unlock_all(dev);
+ 
+ 	return 0;
+ }
+ 
+ struct pipe_crc_info {
+ 	const char *name;
+ 	struct drm_device *dev;
+ 	enum pipe pipe;
+ };
+ 
+ static int i915_dp_mst_info(struct seq_file *m, void *unused)
+ {
+ 	struct drm_info_node *node = (struct drm_info_node *) m->private;
+ 	struct drm_device *dev = node->minor->dev;
+ 	struct drm_encoder *encoder;
+ 	struct intel_encoder *intel_encoder;
+ 	struct intel_digital_port *intel_dig_port;
+ 	drm_modeset_lock_all(dev);
+ 	list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
+ 		intel_encoder = to_intel_encoder(encoder);
+ 		if (intel_encoder->type != INTEL_OUTPUT_DISPLAYPORT)
+ 			continue;
+ 		intel_dig_port = enc_to_dig_port(encoder);
+ 		if (!intel_dig_port->dp.can_mst)
+ 			continue;
+ 
+ 		drm_dp_mst_dump_topology(m, &intel_dig_port->dp.mst_mgr);
+ 	}
+ 	drm_modeset_unlock_all(dev);
+ 	return 0;
+ }
+ 
+ static int i915_pipe_crc_open(struct inode *inode, struct file *filep)
+ {
+ 	struct pipe_crc_info *info = inode->i_private;
+ 	struct drm_i915_private *dev_priv = info->dev->dev_private;
+ 	struct intel_pipe_crc *pipe_crc = &dev_priv->pipe_crc[info->pipe];
+ 
+ 	if (info->pipe >= INTEL_INFO(info->dev)->num_pipes)
+ 		return -ENODEV;
+ 
+ 	spin_lock_irq(&pipe_crc->lock);
+ 
+ 	if (pipe_crc->opened) {
+ 		spin_unlock_irq(&pipe_crc->lock);
+ 		return -EBUSY; /* already open */
+ 	}
+ 
+ 	pipe_crc->opened = true;
+ 	filep->private_data = inode->i_private;
+ 
+ 	spin_unlock_irq(&pipe_crc->lock);
+ 
+ 	return 0;
+ }
+ 
+ static int i915_pipe_crc_release(struct inode *inode, struct file *filep)
+ {
+ 	struct pipe_crc_info *info = inode->i_private;
+ 	struct drm_i915_private *dev_priv = info->dev->dev_private;
+ 	struct intel_pipe_crc *pipe_crc = &dev_priv->pipe_crc[info->pipe];
+ 
+ 	spin_lock_irq(&pipe_crc->lock);
+ 	pipe_crc->opened = false;
+ 	spin_unlock_irq(&pipe_crc->lock);
+ 
+ 	return 0;
+ }
+ 
+ /* (6 fields, 8 chars each, space separated (5) + '\n') */
+ #define PIPE_CRC_LINE_LEN	(6 * 8 + 5 + 1)
+ /* account for \'0' */
+ #define PIPE_CRC_BUFFER_LEN	(PIPE_CRC_LINE_LEN + 1)
+ 
+ static int pipe_crc_data_count(struct intel_pipe_crc *pipe_crc)
+ {
+ 	assert_spin_locked(&pipe_crc->lock);
+ 	return CIRC_CNT(pipe_crc->head, pipe_crc->tail,
+ 			INTEL_PIPE_CRC_ENTRIES_NR);
+ }
+ 
+ static ssize_t
+ i915_pipe_crc_read(struct file *filep, char __user *user_buf, size_t count,
+ 		   loff_t *pos)
+ {
+ 	struct pipe_crc_info *info = filep->private_data;
+ 	struct drm_device *dev = info->dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct intel_pipe_crc *pipe_crc = &dev_priv->pipe_crc[info->pipe];
+ 	char buf[PIPE_CRC_BUFFER_LEN];
+ 	int head, tail, n_entries, n;
+ 	ssize_t bytes_read;
+ 
+ 	/*
+ 	 * Don't allow user space to provide buffers not big enough to hold
+ 	 * a line of data.
+ 	 */
+ 	if (count < PIPE_CRC_LINE_LEN)
+ 		return -EINVAL;
+ 
+ 	if (pipe_crc->source == INTEL_PIPE_CRC_SOURCE_NONE)
+ 		return 0;
+ 
+ 	/* nothing to read */
+ 	spin_lock_irq(&pipe_crc->lock);
+ 	while (pipe_crc_data_count(pipe_crc) == 0) {
+ 		int ret;
+ 
+ 		if (filep->f_flags & O_NONBLOCK) {
+ 			spin_unlock_irq(&pipe_crc->lock);
+ 			return -EAGAIN;
+ 		}
+ 
+ 		ret = wait_event_interruptible_lock_irq(pipe_crc->wq,
+ 				pipe_crc_data_count(pipe_crc), pipe_crc->lock);
+ 		if (ret) {
+ 			spin_unlock_irq(&pipe_crc->lock);
+ 			return ret;
+ 		}
+ 	}
+ 
+ 	/* We now have one or more entries to read */
+ 	head = pipe_crc->head;
+ 	tail = pipe_crc->tail;
+ 	n_entries = min((size_t)CIRC_CNT(head, tail, INTEL_PIPE_CRC_ENTRIES_NR),
+ 			count / PIPE_CRC_LINE_LEN);
+ 	spin_unlock_irq(&pipe_crc->lock);
+ 
+ 	bytes_read = 0;
+ 	n = 0;
+ 	do {
+ 		struct intel_pipe_crc_entry *entry = &pipe_crc->entries[tail];
+ 		int ret;
+ 
+ 		bytes_read += snprintf(buf, PIPE_CRC_BUFFER_LEN,
+ 				       "%8u %8x %8x %8x %8x %8x\n",
+ 				       entry->frame, entry->crc[0],
+ 				       entry->crc[1], entry->crc[2],
+ 				       entry->crc[3], entry->crc[4]);
+ 
+ 		ret = copy_to_user(user_buf + n * PIPE_CRC_LINE_LEN,
+ 				   buf, PIPE_CRC_LINE_LEN);
+ 		if (ret == PIPE_CRC_LINE_LEN)
+ 			return -EFAULT;
+ 
+ 		BUILD_BUG_ON_NOT_POWER_OF_2(INTEL_PIPE_CRC_ENTRIES_NR);
+ 		tail = (tail + 1) & (INTEL_PIPE_CRC_ENTRIES_NR - 1);
+ 		n++;
+ 	} while (--n_entries);
+ 
+ 	spin_lock_irq(&pipe_crc->lock);
+ 	pipe_crc->tail = tail;
+ 	spin_unlock_irq(&pipe_crc->lock);
+ 
+ 	return bytes_read;
+ }
+ 
+ static const struct file_operations i915_pipe_crc_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = i915_pipe_crc_open,
+ 	.read = i915_pipe_crc_read,
+ 	.release = i915_pipe_crc_release,
+ };
+ 
+ static struct pipe_crc_info i915_pipe_crc_data[I915_MAX_PIPES] = {
+ 	{
+ 		.name = "i915_pipe_A_crc",
+ 		.pipe = PIPE_A,
+ 	},
+ 	{
+ 		.name = "i915_pipe_B_crc",
+ 		.pipe = PIPE_B,
+ 	},
+ 	{
+ 		.name = "i915_pipe_C_crc",
+ 		.pipe = PIPE_C,
+ 	},
+ };
+ 
+ static int i915_pipe_crc_create(struct dentry *root, struct drm_minor *minor,
+ 				enum pipe pipe)
+ {
+ 	struct drm_device *dev = minor->dev;
+ 	struct dentry *ent;
+ 	struct pipe_crc_info *info = &i915_pipe_crc_data[pipe];
+ 
+ 	info->dev = dev;
+ 	ent = debugfs_create_file(info->name, S_IRUGO, root, info,
+ 				  &i915_pipe_crc_fops);
+ 	if (!ent)
+ 		return -ENOMEM;
+ 
+ 	return drm_add_fake_info_node(minor, ent, info);
+ }
+ 
+ static const char * const pipe_crc_sources[] = {
+ 	"none",
+ 	"plane1",
+ 	"plane2",
+ 	"pf",
+ 	"pipe",
+ 	"TV",
+ 	"DP-B",
+ 	"DP-C",
+ 	"DP-D",
+ 	"auto",
+ };
+ 
+ static const char *pipe_crc_source_name(enum intel_pipe_crc_source source)
+ {
+ 	BUILD_BUG_ON(ARRAY_SIZE(pipe_crc_sources) != INTEL_PIPE_CRC_SOURCE_MAX);
+ 	return pipe_crc_sources[source];
+ }
+ 
+ static int display_crc_ctl_show(struct seq_file *m, void *data)
+ {
+ 	struct drm_device *dev = m->private;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	int i;
+ 
+ 	for (i = 0; i < I915_MAX_PIPES; i++)
+ 		seq_printf(m, "%c %s\n", pipe_name(i),
+ 			   pipe_crc_source_name(dev_priv->pipe_crc[i].source));
+ 
+ 	return 0;
+ }
+ 
+ static int display_crc_ctl_open(struct inode *inode, struct file *file)
+ {
+ 	struct drm_device *dev = inode->i_private;
+ 
+ 	return single_open(file, display_crc_ctl_show, dev);
+ }
+ 
+ static int i8xx_pipe_crc_ctl_reg(enum intel_pipe_crc_source *source,
+ 				 uint32_t *val)
+ {
+ 	if (*source == INTEL_PIPE_CRC_SOURCE_AUTO)
+ 		*source = INTEL_PIPE_CRC_SOURCE_PIPE;
+ 
+ 	switch (*source) {
+ 	case INTEL_PIPE_CRC_SOURCE_PIPE:
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_INCLUDE_BORDER_I8XX;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_NONE:
+ 		*val = 0;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int i9xx_pipe_crc_auto_source(struct drm_device *dev, enum pipe pipe,
+ 				     enum intel_pipe_crc_source *source)
+ {
+ 	struct intel_encoder *encoder;
+ 	struct intel_crtc *crtc;
+ 	struct intel_digital_port *dig_port;
+ 	int ret = 0;
+ 
+ 	*source = INTEL_PIPE_CRC_SOURCE_PIPE;
+ 
+ 	drm_modeset_lock_all(dev);
+ 	list_for_each_entry(encoder, &dev->mode_config.encoder_list,
+ 			    base.head) {
+ 		if (!encoder->base.crtc)
+ 			continue;
+ 
+ 		crtc = to_intel_crtc(encoder->base.crtc);
+ 
+ 		if (crtc->pipe != pipe)
+ 			continue;
+ 
+ 		switch (encoder->type) {
+ 		case INTEL_OUTPUT_TVOUT:
+ 			*source = INTEL_PIPE_CRC_SOURCE_TV;
+ 			break;
+ 		case INTEL_OUTPUT_DISPLAYPORT:
+ 		case INTEL_OUTPUT_EDP:
+ 			dig_port = enc_to_dig_port(&encoder->base);
+ 			switch (dig_port->port) {
+ 			case PORT_B:
+ 				*source = INTEL_PIPE_CRC_SOURCE_DP_B;
+ 				break;
+ 			case PORT_C:
+ 				*source = INTEL_PIPE_CRC_SOURCE_DP_C;
+ 				break;
+ 			case PORT_D:
+ 				*source = INTEL_PIPE_CRC_SOURCE_DP_D;
+ 				break;
+ 			default:
+ 				WARN(1, "nonexisting DP port %c\n",
+ 				     port_name(dig_port->port));
+ 				break;
+ 			}
+ 			break;
+ 		}
+ 	}
+ 	drm_modeset_unlock_all(dev);
+ 
+ 	return ret;
+ }
+ 
+ static int vlv_pipe_crc_ctl_reg(struct drm_device *dev,
+ 				enum pipe pipe,
+ 				enum intel_pipe_crc_source *source,
+ 				uint32_t *val)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	bool need_stable_symbols = false;
+ 
+ 	if (*source == INTEL_PIPE_CRC_SOURCE_AUTO) {
+ 		int ret = i9xx_pipe_crc_auto_source(dev, pipe, source);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	switch (*source) {
+ 	case INTEL_PIPE_CRC_SOURCE_PIPE:
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_PIPE_VLV;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_DP_B:
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_DP_B_VLV;
+ 		need_stable_symbols = true;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_DP_C:
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_DP_C_VLV;
+ 		need_stable_symbols = true;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_NONE:
+ 		*val = 0;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	/*
+ 	 * When the pipe CRC tap point is after the transcoders we need
+ 	 * to tweak symbol-level features to produce a deterministic series of
+ 	 * symbols for a given frame. We need to reset those features only once
+ 	 * a frame (instead of every nth symbol):
+ 	 *   - DC-balance: used to ensure a better clock recovery from the data
+ 	 *     link (SDVO)
+ 	 *   - DisplayPort scrambling: used for EMI reduction
+ 	 */
+ 	if (need_stable_symbols) {
+ 		uint32_t tmp = I915_READ(PORT_DFT2_G4X);
+ 
+ 		tmp |= DC_BALANCE_RESET_VLV;
+ 		if (pipe == PIPE_A)
+ 			tmp |= PIPE_A_SCRAMBLE_RESET;
+ 		else
+ 			tmp |= PIPE_B_SCRAMBLE_RESET;
+ 
+ 		I915_WRITE(PORT_DFT2_G4X, tmp);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int i9xx_pipe_crc_ctl_reg(struct drm_device *dev,
+ 				 enum pipe pipe,
+ 				 enum intel_pipe_crc_source *source,
+ 				 uint32_t *val)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	bool need_stable_symbols = false;
+ 
+ 	if (*source == INTEL_PIPE_CRC_SOURCE_AUTO) {
+ 		int ret = i9xx_pipe_crc_auto_source(dev, pipe, source);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	switch (*source) {
+ 	case INTEL_PIPE_CRC_SOURCE_PIPE:
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_PIPE_I9XX;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_TV:
+ 		if (!SUPPORTS_TV(dev))
+ 			return -EINVAL;
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_TV_PRE;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_DP_B:
+ 		if (!IS_G4X(dev))
+ 			return -EINVAL;
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_DP_B_G4X;
+ 		need_stable_symbols = true;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_DP_C:
+ 		if (!IS_G4X(dev))
+ 			return -EINVAL;
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_DP_C_G4X;
+ 		need_stable_symbols = true;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_DP_D:
+ 		if (!IS_G4X(dev))
+ 			return -EINVAL;
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_DP_D_G4X;
+ 		need_stable_symbols = true;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_NONE:
+ 		*val = 0;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	/*
+ 	 * When the pipe CRC tap point is after the transcoders we need
+ 	 * to tweak symbol-level features to produce a deterministic series of
+ 	 * symbols for a given frame. We need to reset those features only once
+ 	 * a frame (instead of every nth symbol):
+ 	 *   - DC-balance: used to ensure a better clock recovery from the data
+ 	 *     link (SDVO)
+ 	 *   - DisplayPort scrambling: used for EMI reduction
+ 	 */
+ 	if (need_stable_symbols) {
+ 		uint32_t tmp = I915_READ(PORT_DFT2_G4X);
+ 
+ 		WARN_ON(!IS_G4X(dev));
+ 
+ 		I915_WRITE(PORT_DFT_I9XX,
+ 			   I915_READ(PORT_DFT_I9XX) | DC_BALANCE_RESET);
+ 
+ 		if (pipe == PIPE_A)
+ 			tmp |= PIPE_A_SCRAMBLE_RESET;
+ 		else
+ 			tmp |= PIPE_B_SCRAMBLE_RESET;
+ 
+ 		I915_WRITE(PORT_DFT2_G4X, tmp);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void vlv_undo_pipe_scramble_reset(struct drm_device *dev,
+ 					 enum pipe pipe)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	uint32_t tmp = I915_READ(PORT_DFT2_G4X);
+ 
+ 	if (pipe == PIPE_A)
+ 		tmp &= ~PIPE_A_SCRAMBLE_RESET;
+ 	else
+ 		tmp &= ~PIPE_B_SCRAMBLE_RESET;
+ 	if (!(tmp & PIPE_SCRAMBLE_RESET_MASK))
+ 		tmp &= ~DC_BALANCE_RESET_VLV;
+ 	I915_WRITE(PORT_DFT2_G4X, tmp);
+ 
+ }
+ 
+ static void g4x_undo_pipe_scramble_reset(struct drm_device *dev,
+ 					 enum pipe pipe)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	uint32_t tmp = I915_READ(PORT_DFT2_G4X);
+ 
+ 	if (pipe == PIPE_A)
+ 		tmp &= ~PIPE_A_SCRAMBLE_RESET;
+ 	else
+ 		tmp &= ~PIPE_B_SCRAMBLE_RESET;
+ 	I915_WRITE(PORT_DFT2_G4X, tmp);
+ 
+ 	if (!(tmp & PIPE_SCRAMBLE_RESET_MASK)) {
+ 		I915_WRITE(PORT_DFT_I9XX,
+ 			   I915_READ(PORT_DFT_I9XX) & ~DC_BALANCE_RESET);
+ 	}
+ }
+ 
+ static int ilk_pipe_crc_ctl_reg(enum intel_pipe_crc_source *source,
+ 				uint32_t *val)
+ {
+ 	if (*source == INTEL_PIPE_CRC_SOURCE_AUTO)
+ 		*source = INTEL_PIPE_CRC_SOURCE_PIPE;
+ 
+ 	switch (*source) {
+ 	case INTEL_PIPE_CRC_SOURCE_PLANE1:
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_PRIMARY_ILK;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_PLANE2:
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_SPRITE_ILK;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_PIPE:
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_PIPE_ILK;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_NONE:
+ 		*val = 0;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void hsw_trans_edp_pipe_A_crc_wa(struct drm_device *dev)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct intel_crtc *crtc =
+ 		to_intel_crtc(dev_priv->pipe_to_crtc_mapping[PIPE_A]);
+ 
+ 	drm_modeset_lock_all(dev);
+ 	/*
+ 	 * If we use the eDP transcoder we need to make sure that we don't
+ 	 * bypass the pfit, since otherwise the pipe CRC source won't work. Only
+ 	 * relevant on hsw with pipe A when using the always-on power well
+ 	 * routing.
+ 	 */
+ 	if (crtc->config.cpu_transcoder == TRANSCODER_EDP &&
+ 	    !crtc->config.pch_pfit.enabled) {
+ 		crtc->config.pch_pfit.force_thru = true;
+ 
+ 		intel_display_power_get(dev_priv,
+ 					POWER_DOMAIN_PIPE_PANEL_FITTER(PIPE_A));
+ 
+ 		dev_priv->display.crtc_disable(&crtc->base);
+ 		dev_priv->display.crtc_enable(&crtc->base);
+ 	}
+ 	drm_modeset_unlock_all(dev);
+ }
+ 
+ static void hsw_undo_trans_edp_pipe_A_crc_wa(struct drm_device *dev)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct intel_crtc *crtc =
+ 		to_intel_crtc(dev_priv->pipe_to_crtc_mapping[PIPE_A]);
+ 
+ 	drm_modeset_lock_all(dev);
+ 	/*
+ 	 * If we use the eDP transcoder we need to make sure that we don't
+ 	 * bypass the pfit, since otherwise the pipe CRC source won't work. Only
+ 	 * relevant on hsw with pipe A when using the always-on power well
+ 	 * routing.
+ 	 */
+ 	if (crtc->config.pch_pfit.force_thru) {
+ 		crtc->config.pch_pfit.force_thru = false;
+ 
+ 		dev_priv->display.crtc_disable(&crtc->base);
+ 		dev_priv->display.crtc_enable(&crtc->base);
+ 
+ 		intel_display_power_put(dev_priv,
+ 					POWER_DOMAIN_PIPE_PANEL_FITTER(PIPE_A));
+ 	}
+ 	drm_modeset_unlock_all(dev);
+ }
+ 
+ static int ivb_pipe_crc_ctl_reg(struct drm_device *dev,
+ 				enum pipe pipe,
+ 				enum intel_pipe_crc_source *source,
+ 				uint32_t *val)
+ {
+ 	if (*source == INTEL_PIPE_CRC_SOURCE_AUTO)
+ 		*source = INTEL_PIPE_CRC_SOURCE_PF;
+ 
+ 	switch (*source) {
+ 	case INTEL_PIPE_CRC_SOURCE_PLANE1:
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_PRIMARY_IVB;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_PLANE2:
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_SPRITE_IVB;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_PF:
+ 		if (IS_HASWELL(dev) && pipe == PIPE_A)
+ 			hsw_trans_edp_pipe_A_crc_wa(dev);
+ 
+ 		*val = PIPE_CRC_ENABLE | PIPE_CRC_SOURCE_PF_IVB;
+ 		break;
+ 	case INTEL_PIPE_CRC_SOURCE_NONE:
+ 		*val = 0;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int pipe_crc_set_source(struct drm_device *dev, enum pipe pipe,
+ 			       enum intel_pipe_crc_source source)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct intel_pipe_crc *pipe_crc = &dev_priv->pipe_crc[pipe];
+ 	u32 val = 0; /* shut up gcc */
+ 	int ret;
+ 
+ 	if (pipe_crc->source == source)
+ 		return 0;
+ 
+ 	/* forbid changing the source without going back to 'none' */
+ 	if (pipe_crc->source && source)
+ 		return -EINVAL;
+ 
+ 	if (IS_GEN2(dev))
+ 		ret = i8xx_pipe_crc_ctl_reg(&source, &val);
+ 	else if (INTEL_INFO(dev)->gen < 5)
+ 		ret = i9xx_pipe_crc_ctl_reg(dev, pipe, &source, &val);
+ 	else if (IS_VALLEYVIEW(dev))
+ 		ret = vlv_pipe_crc_ctl_reg(dev, pipe, &source, &val);
+ 	else if (IS_GEN5(dev) || IS_GEN6(dev))
+ 		ret = ilk_pipe_crc_ctl_reg(&source, &val);
+ 	else
+ 		ret = ivb_pipe_crc_ctl_reg(dev, pipe, &source, &val);
+ 
+ 	if (ret != 0)
+ 		return ret;
+ 
+ 	/* none -> real source transition */
+ 	if (source) {
+ 		DRM_DEBUG_DRIVER("collecting CRCs for pipe %c, %s\n",
+ 				 pipe_name(pipe), pipe_crc_source_name(source));
+ 
+ 		pipe_crc->entries = kzalloc(sizeof(*pipe_crc->entries) *
+ 					    INTEL_PIPE_CRC_ENTRIES_NR,
+ 					    GFP_KERNEL);
+ 		if (!pipe_crc->entries)
+ 			return -ENOMEM;
+ 
+ 		spin_lock_irq(&pipe_crc->lock);
+ 		pipe_crc->head = 0;
+ 		pipe_crc->tail = 0;
+ 		spin_unlock_irq(&pipe_crc->lock);
+ 	}
+ 
+ 	pipe_crc->source = source;
+ 
+ 	I915_WRITE(PIPE_CRC_CTL(pipe), val);
+ 	POSTING_READ(PIPE_CRC_CTL(pipe));
+ 
+ 	/* real source -> none transition */
+ 	if (source == INTEL_PIPE_CRC_SOURCE_NONE) {
+ 		struct intel_pipe_crc_entry *entries;
+ 		struct intel_crtc *crtc =
+ 			to_intel_crtc(dev_priv->pipe_to_crtc_mapping[pipe]);
+ 
+ 		DRM_DEBUG_DRIVER("stopping CRCs for pipe %c\n",
+ 				 pipe_name(pipe));
+ 
+ 		drm_modeset_lock(&crtc->base.mutex, NULL);
+ 		if (crtc->active)
+ 			intel_wait_for_vblank(dev, pipe);
+ 		drm_modeset_unlock(&crtc->base.mutex);
+ 
+ 		spin_lock_irq(&pipe_crc->lock);
+ 		entries = pipe_crc->entries;
+ 		pipe_crc->entries = NULL;
+ 		spin_unlock_irq(&pipe_crc->lock);
+ 
+ 		kfree(entries);
+ 
+ 		if (IS_G4X(dev))
+ 			g4x_undo_pipe_scramble_reset(dev, pipe);
+ 		else if (IS_VALLEYVIEW(dev))
+ 			vlv_undo_pipe_scramble_reset(dev, pipe);
+ 		else if (IS_HASWELL(dev) && pipe == PIPE_A)
+ 			hsw_undo_trans_edp_pipe_A_crc_wa(dev);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Parse pipe CRC command strings:
+  *   command: wsp* object wsp+ name wsp+ source wsp*
+  *   object: 'pipe'
+  *   name: (A | B | C)
+  *   source: (none | plane1 | plane2 | pf)
+  *   wsp: (#0x20 | #0x9 | #0xA)+
+  *
+  * eg.:
+  *  "pipe A plane1"  ->  Start CRC computations on plane1 of pipe A
+  *  "pipe A none"    ->  Stop CRC
+  */
+ static int display_crc_ctl_tokenize(char *buf, char *words[], int max_words)
+ {
+ 	int n_words = 0;
+ 
+ 	while (*buf) {
+ 		char *end;
+ 
+ 		/* skip leading white space */
+ 		buf = skip_spaces(buf);
+ 		if (!*buf)
+ 			break;	/* end of buffer */
+ 
+ 		/* find end of word */
+ 		for (end = buf; *end && !isspace(*end); end++)
+ 			;
+ 
+ 		if (n_words == max_words) {
+ 			DRM_DEBUG_DRIVER("too many words, allowed <= %d\n",
+ 					 max_words);
+ 			return -EINVAL;	/* ran out of words[] before bytes */
+ 		}
+ 
+ 		if (*end)
+ 			*end++ = '\0';
+ 		words[n_words++] = buf;
+ 		buf = end;
+ 	}
+ 
+ 	return n_words;
+ }
+ 
+ enum intel_pipe_crc_object {
+ 	PIPE_CRC_OBJECT_PIPE,
+ };
+ 
+ static const char * const pipe_crc_objects[] = {
+ 	"pipe",
+ };
+ 
+ static int
+ display_crc_ctl_parse_object(const char *buf, enum intel_pipe_crc_object *o)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(pipe_crc_objects); i++)
+ 		if (!strcmp(buf, pipe_crc_objects[i])) {
+ 			*o = i;
+ 			return 0;
+ 		    }
+ 
+ 	return -EINVAL;
+ }
+ 
+ static int display_crc_ctl_parse_pipe(const char *buf, enum pipe *pipe)
+ {
+ 	const char name = buf[0];
+ 
+ 	if (name < 'A' || name >= pipe_name(I915_MAX_PIPES))
+ 		return -EINVAL;
+ 
+ 	*pipe = name - 'A';
+ 
+ 	return 0;
+ }
+ 
+ static int
+ display_crc_ctl_parse_source(const char *buf, enum intel_pipe_crc_source *s)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(pipe_crc_sources); i++)
+ 		if (!strcmp(buf, pipe_crc_sources[i])) {
+ 			*s = i;
+ 			return 0;
+ 		    }
+ 
+ 	return -EINVAL;
+ }
+ 
+ static int display_crc_ctl_parse(struct drm_device *dev, char *buf, size_t len)
+ {
+ #define N_WORDS 3
+ 	int n_words;
+ 	char *words[N_WORDS];
+ 	enum pipe pipe;
+ 	enum intel_pipe_crc_object object;
+ 	enum intel_pipe_crc_source source;
+ 
+ 	n_words = display_crc_ctl_tokenize(buf, words, N_WORDS);
+ 	if (n_words != N_WORDS) {
+ 		DRM_DEBUG_DRIVER("tokenize failed, a command is %d words\n",
+ 				 N_WORDS);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (display_crc_ctl_parse_object(words[0], &object) < 0) {
+ 		DRM_DEBUG_DRIVER("unknown object %s\n", words[0]);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (display_crc_ctl_parse_pipe(words[1], &pipe) < 0) {
+ 		DRM_DEBUG_DRIVER("unknown pipe %s\n", words[1]);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (display_crc_ctl_parse_source(words[2], &source) < 0) {
+ 		DRM_DEBUG_DRIVER("unknown source %s\n", words[2]);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return pipe_crc_set_source(dev, pipe, source);
+ }
+ 
+ static ssize_t display_crc_ctl_write(struct file *file, const char __user *ubuf,
+ 				     size_t len, loff_t *offp)
+ {
+ 	struct seq_file *m = file->private_data;
+ 	struct drm_device *dev = m->private;
+ 	char *tmpbuf;
+ 	int ret;
+ 
+ 	if (len == 0)
+ 		return 0;
+ 
+ 	if (len > PAGE_SIZE - 1) {
+ 		DRM_DEBUG_DRIVER("expected <%lu bytes into pipe crc control\n",
+ 				 PAGE_SIZE);
+ 		return -E2BIG;
+ 	}
+ 
+ 	tmpbuf = kmalloc(len + 1, GFP_KERNEL);
+ 	if (!tmpbuf)
+ 		return -ENOMEM;
+ 
+ 	if (copy_from_user(tmpbuf, ubuf, len)) {
+ 		ret = -EFAULT;
+ 		goto out;
+ 	}
+ 	tmpbuf[len] = '\0';
+ 
+ 	ret = display_crc_ctl_parse(dev, tmpbuf, len);
+ 
+ out:
+ 	kfree(tmpbuf);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	*offp += len;
+ 	return len;
+ }
+ 
+ static const struct file_operations i915_display_crc_ctl_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = display_crc_ctl_open,
+ 	.read = seq_read,
+ 	.llseek = seq_lseek,
+ 	.release = single_release,
+ 	.write = display_crc_ctl_write
+ };
+ 
+ static void wm_latency_show(struct seq_file *m, const uint16_t wm[5])
+ {
+ 	struct drm_device *dev = m->private;
+ 	int num_levels = ilk_wm_max_level(dev) + 1;
+ 	int level;
+ 
+ 	drm_modeset_lock_all(dev);
+ 
+ 	for (level = 0; level < num_levels; level++) {
+ 		unsigned int latency = wm[level];
+ 
+ 		/* WM1+ latency values in 0.5us units */
+ 		if (level > 0)
+ 			latency *= 5;
+ 
+ 		seq_printf(m, "WM%d %u (%u.%u usec)\n",
+ 			   level, wm[level],
+ 			   latency / 10, latency % 10);
+ 	}
+ 
+ 	drm_modeset_unlock_all(dev);
+ }
+ 
+ static int pri_wm_latency_show(struct seq_file *m, void *data)
+ {
+ 	struct drm_device *dev = m->private;
+ 
+ 	wm_latency_show(m, to_i915(dev)->wm.pri_latency);
+ 
+ 	return 0;
+ }
+ 
+ static int spr_wm_latency_show(struct seq_file *m, void *data)
+ {
+ 	struct drm_device *dev = m->private;
+ 
+ 	wm_latency_show(m, to_i915(dev)->wm.spr_latency);
+ 
+ 	return 0;
+ }
+ 
+ static int cur_wm_latency_show(struct seq_file *m, void *data)
+ {
+ 	struct drm_device *dev = m->private;
+ 
+ 	wm_latency_show(m, to_i915(dev)->wm.cur_latency);
+ 
+ 	return 0;
+ }
+ 
+ static int pri_wm_latency_open(struct inode *inode, struct file *file)
+ {
+ 	struct drm_device *dev = inode->i_private;
+ 
+ 	if (!HAS_PCH_SPLIT(dev))
+ 		return -ENODEV;
+ 
+ 	return single_open(file, pri_wm_latency_show, dev);
+ }
+ 
+ static int spr_wm_latency_open(struct inode *inode, struct file *file)
+ {
+ 	struct drm_device *dev = inode->i_private;
+ 
+ 	if (!HAS_PCH_SPLIT(dev))
+ 		return -ENODEV;
+ 
+ 	return single_open(file, spr_wm_latency_show, dev);
+ }
+ 
+ static int cur_wm_latency_open(struct inode *inode, struct file *file)
+ {
+ 	struct drm_device *dev = inode->i_private;
+ 
+ 	if (!HAS_PCH_SPLIT(dev))
+ 		return -ENODEV;
+ 
+ 	return single_open(file, cur_wm_latency_show, dev);
+ }
+ 
+ static ssize_t wm_latency_write(struct file *file, const char __user *ubuf,
+ 				size_t len, loff_t *offp, uint16_t wm[5])
+ {
+ 	struct seq_file *m = file->private_data;
+ 	struct drm_device *dev = m->private;
+ 	uint16_t new[5] = { 0 };
+ 	int num_levels = ilk_wm_max_level(dev) + 1;
+ 	int level;
+ 	int ret;
+ 	char tmp[32];
+ 
+ 	if (len >= sizeof(tmp))
+ 		return -EINVAL;
+ 
+ 	if (copy_from_user(tmp, ubuf, len))
+ 		return -EFAULT;
+ 
+ 	tmp[len] = '\0';
+ 
+ 	ret = sscanf(tmp, "%hu %hu %hu %hu %hu", &new[0], &new[1], &new[2], &new[3], &new[4]);
+ 	if (ret != num_levels)
+ 		return -EINVAL;
+ 
+ 	drm_modeset_lock_all(dev);
+ 
+ 	for (level = 0; level < num_levels; level++)
+ 		wm[level] = new[level];
+ 
+ 	drm_modeset_unlock_all(dev);
+ 
+ 	return len;
+ }
+ 
+ 
+ static ssize_t pri_wm_latency_write(struct file *file, const char __user *ubuf,
+ 				    size_t len, loff_t *offp)
+ {
+ 	struct seq_file *m = file->private_data;
+ 	struct drm_device *dev = m->private;
+ 
+ 	return wm_latency_write(file, ubuf, len, offp, to_i915(dev)->wm.pri_latency);
+ }
+ 
+ static ssize_t spr_wm_latency_write(struct file *file, const char __user *ubuf,
+ 				    size_t len, loff_t *offp)
+ {
+ 	struct seq_file *m = file->private_data;
+ 	struct drm_device *dev = m->private;
+ 
+ 	return wm_latency_write(file, ubuf, len, offp, to_i915(dev)->wm.spr_latency);
+ }
+ 
+ static ssize_t cur_wm_latency_write(struct file *file, const char __user *ubuf,
+ 				    size_t len, loff_t *offp)
+ {
+ 	struct seq_file *m = file->private_data;
+ 	struct drm_device *dev = m->private;
+ 
+ 	return wm_latency_write(file, ubuf, len, offp, to_i915(dev)->wm.cur_latency);
+ }
+ 
+ static const struct file_operations i915_pri_wm_latency_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = pri_wm_latency_open,
+ 	.read = seq_read,
+ 	.llseek = seq_lseek,
+ 	.release = single_release,
+ 	.write = pri_wm_latency_write
+ };
+ 
+ static const struct file_operations i915_spr_wm_latency_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = spr_wm_latency_open,
+ 	.read = seq_read,
+ 	.llseek = seq_lseek,
+ 	.release = single_release,
+ 	.write = spr_wm_latency_write
+ };
+ 
+ static const struct file_operations i915_cur_wm_latency_fops = {
+ 	.owner = THIS_MODULE,
+ 	.open = cur_wm_latency_open,
+ 	.read = seq_read,
+ 	.llseek = seq_lseek,
+ 	.release = single_release,
+ 	.write = cur_wm_latency_write
+ };
+ 
++>>>>>>> 11bed958b72e (drm/i915: mst topology dumper in debugfs (v0.2))
  static int
  i915_wedged_get(void *data, u64 *val)
  {
@@@ -2261,11 -3919,16 +3668,19 @@@ static struct drm_info_list i915_debugf
  	{"i915_gen6_forcewake_count", i915_gen6_forcewake_count_info, 0},
  	{"i915_swizzle_info", i915_swizzle_info, 0},
  	{"i915_ppgtt_info", i915_ppgtt_info, 0},
 +	{"i915_dpio", i915_dpio_info, 0},
  	{"i915_llc", i915_llc, 0},
  	{"i915_edp_psr_status", i915_edp_psr_status, 0},
 -	{"i915_sink_crc_eDP1", i915_sink_crc, 0},
  	{"i915_energy_uJ", i915_energy_uJ, 0},
  	{"i915_pc8_status", i915_pc8_status, 0},
++<<<<<<< HEAD
++=======
+ 	{"i915_power_domain_info", i915_power_domain_info, 0},
+ 	{"i915_display_info", i915_display_info, 0},
+ 	{"i915_semaphore_status", i915_semaphore_status, 0},
+ 	{"i915_shared_dplls_info", i915_shared_dplls_info, 0},
+ 	{"i915_dp_mst_info", i915_dp_mst_info, 0},
++>>>>>>> 11bed958b72e (drm/i915: mst topology dumper in debugfs (v0.2))
  };
  #define I915_DEBUGFS_ENTRIES ARRAY_SIZE(i915_debugfs_list)
  
* Unmerged path drivers/gpu/drm/i915/i915_debugfs.c
