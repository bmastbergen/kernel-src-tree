ceph: fix bool assignments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Fabian Frederick <fabf@skynet.be>
commit ab6c2c3ebe1d4fddc1f9ae29810799419be950c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/ab6c2c3e.failed

Fix some coccinelle warnings:
fs/ceph/caps.c:2400:6-10: WARNING: Assignment of bool to 0/1
fs/ceph/caps.c:2401:6-15: WARNING: Assignment of bool to 0/1
fs/ceph/caps.c:2402:6-17: WARNING: Assignment of bool to 0/1
fs/ceph/caps.c:2403:6-22: WARNING: Assignment of bool to 0/1
fs/ceph/caps.c:2404:6-22: WARNING: Assignment of bool to 0/1
fs/ceph/caps.c:2405:6-19: WARNING: Assignment of bool to 0/1
fs/ceph/caps.c:2440:4-20: WARNING: Assignment of bool to 0/1
fs/ceph/caps.c:2469:3-16: WARNING: Assignment of bool to 0/1
fs/ceph/caps.c:2490:2-18: WARNING: Assignment of bool to 0/1
fs/ceph/caps.c:2519:3-7: WARNING: Assignment of bool to 0/1
fs/ceph/caps.c:2549:3-12: WARNING: Assignment of bool to 0/1
fs/ceph/caps.c:2575:2-6: WARNING: Assignment of bool to 0/1
fs/ceph/caps.c:2589:3-7: WARNING: Assignment of bool to 0/1

	Signed-off-by: Fabian Frederick <fabf@skynet.be>
	Signed-off-by: Ilya Dryomov <idryomov@redhat.com>
(cherry picked from commit ab6c2c3ebe1d4fddc1f9ae29810799419be950c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/caps.c
diff --cc fs/ceph/caps.c
index 51fb2a36af31,659f2ea9e6f7..000000000000
--- a/fs/ceph/caps.c
+++ b/fs/ceph/caps.c
@@@ -2416,10 -2397,12 +2416,19 @@@ static void handle_cap_grant(struct ino
  	u64 max_size = le64_to_cpu(grant->max_size);
  	struct timespec mtime, atime, ctime;
  	int check_caps = 0;
++<<<<<<< HEAD
 +	int wake = 0;
 +	int writeback = 0;
 +	int queue_invalidate = 0;
 +	int deleted_inode = 0;
++=======
+ 	bool wake = false;
+ 	bool writeback = false;
+ 	bool queue_trunc = false;
+ 	bool queue_invalidate = false;
+ 	bool queue_revalidate = false;
+ 	bool deleted_inode = false;
++>>>>>>> ab6c2c3ebe1d (ceph: fix bool assignments)
  
  	dout("handle_cap_grant inode %p cap %p mds%d seq %d %s\n",
  	     inode, cap, mds, seq, ceph_cap_string(newcaps));
@@@ -2500,30 -2483,41 +2509,58 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	/* size/ctime/mtime/atime? */
 +	ceph_fill_file_size(inode, issued,
 +			    le32_to_cpu(grant->truncate_seq),
 +			    le64_to_cpu(grant->truncate_size), size);
 +	ceph_decode_timespec(&mtime, &grant->mtime);
 +	ceph_decode_timespec(&atime, &grant->atime);
 +	ceph_decode_timespec(&ctime, &grant->ctime);
 +	ceph_fill_file_time(inode, issued,
 +			    le32_to_cpu(grant->time_warp_seq), &ctime, &mtime,
 +			    &atime);
++=======
+ 	/* Do we need to revalidate our fscache cookie. Don't bother on the
+ 	 * first cache cap as we already validate at cookie creation time. */
+ 	if ((issued & CEPH_CAP_FILE_CACHE) && ci->i_rdcache_gen > 1)
+ 		queue_revalidate = true;
++>>>>>>> ab6c2c3ebe1d (ceph: fix bool assignments)
  
 -	if (newcaps & CEPH_CAP_ANY_RD) {
 -		/* ctime/mtime/atime? */
 -		ceph_decode_timespec(&mtime, &grant->mtime);
 -		ceph_decode_timespec(&atime, &grant->atime);
 -		ceph_decode_timespec(&ctime, &grant->ctime);
 -		ceph_fill_file_time(inode, issued,
 -				    le32_to_cpu(grant->time_warp_seq),
 -				    &ctime, &mtime, &atime);
 -	}
  
++<<<<<<< HEAD
 +	/* file layout may have changed */
 +	ci->i_layout = grant->layout;
 +
 +	/* max size increase? */
 +	if (ci->i_auth_cap == cap && max_size != ci->i_max_size) {
 +		dout("max_size %lld -> %llu\n", ci->i_max_size, max_size);
 +		ci->i_max_size = max_size;
 +		if (max_size >= ci->i_wanted_max_size) {
 +			ci->i_wanted_max_size = 0;  /* reset */
 +			ci->i_requested_max_size = 0;
++=======
+ 	if (newcaps & (CEPH_CAP_ANY_FILE_RD | CEPH_CAP_ANY_FILE_WR)) {
+ 		/* file layout may have changed */
+ 		ci->i_layout = grant->layout;
+ 		/* size/truncate_seq? */
+ 		queue_trunc = ceph_fill_file_size(inode, issued,
+ 					le32_to_cpu(grant->truncate_seq),
+ 					le64_to_cpu(grant->truncate_size),
+ 					size);
+ 		/* max size increase? */
+ 		if (ci->i_auth_cap == cap && max_size != ci->i_max_size) {
+ 			dout("max_size %lld -> %llu\n",
+ 			     ci->i_max_size, max_size);
+ 			ci->i_max_size = max_size;
+ 			if (max_size >= ci->i_wanted_max_size) {
+ 				ci->i_wanted_max_size = 0;  /* reset */
+ 				ci->i_requested_max_size = 0;
+ 			}
+ 			wake = true;
++>>>>>>> ab6c2c3ebe1d (ceph: fix bool assignments)
  		}
 +		wake = 1;
  	}
  
  	/* check cap bits */
@@@ -2583,6 -2577,24 +2620,27 @@@
  	BUG_ON(cap->issued & ~cap->implemented);
  
  	spin_unlock(&ci->i_ceph_lock);
++<<<<<<< HEAD
++=======
+ 
+ 	if (le32_to_cpu(grant->op) == CEPH_CAP_OP_IMPORT) {
+ 		down_write(&mdsc->snap_rwsem);
+ 		ceph_update_snap_trace(mdsc, snaptrace,
+ 				       snaptrace + snaptrace_len, false);
+ 		downgrade_write(&mdsc->snap_rwsem);
+ 		kick_flushing_inode_caps(mdsc, session, inode);
+ 		up_read(&mdsc->snap_rwsem);
+ 		if (newcaps & ~issued)
+ 			wake = true;
+ 	}
+ 
+ 	if (queue_trunc) {
+ 		ceph_queue_vmtruncate(inode);
+ 		ceph_queue_revalidate(inode);
+ 	} else if (queue_revalidate)
+ 		ceph_queue_revalidate(inode);
+ 
++>>>>>>> ab6c2c3ebe1d (ceph: fix bool assignments)
  	if (writeback)
  		/*
  		 * queue inode for writeback: we can't actually call
* Unmerged path fs/ceph/caps.c
