cpufreq: define generic .attr, .exit() and .verify() routines

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] define generic .attr, .exit() and .verify() routines (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 92.04%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 184345129c53e76069c209f9912ed7c457eceb31
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/18434512.failed

Most of the CPUFreq drivers do similar things in .exit() and .verify() routines
and .attr. So its better if we have generic routines for them which can be used
by cpufreq drivers then.

This patch introduces generic .attr, .exit() and .verify() cpufreq drivers.

	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 184345129c53e76069c209f9912ed7c457eceb31)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/cpufreq.h
diff --cc include/linux/cpufreq.h
index 241e07069182,36ccd0bf1304..000000000000
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@@ -430,15 -417,17 +431,27 @@@ struct cpufreq_frequency_table *cpufreq
  
  /* the following are really really optional */
  extern struct freq_attr cpufreq_freq_attr_scaling_available_freqs;
++<<<<<<< HEAD
 +
++=======
+ extern struct freq_attr *cpufreq_generic_attr[];
++>>>>>>> 184345129c53 (cpufreq: define generic .attr, .exit() and .verify() routines)
  void cpufreq_frequency_table_get_attr(struct cpufreq_frequency_table *table,
  				      unsigned int cpu);
 +void cpufreq_frequency_table_update_policy_cpu(struct cpufreq_policy *policy);
 +
  void cpufreq_frequency_table_put_attr(unsigned int cpu);
  int cpufreq_table_validate_and_show(struct cpufreq_policy *policy,
  				      struct cpufreq_frequency_table *table);
  
++<<<<<<< HEAD
 +ssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf);
++=======
+ static inline int cpufreq_generic_exit(struct cpufreq_policy *policy)
+ {
+ 	cpufreq_frequency_table_put_attr(policy->cpu);
+ 	return 0;
+ }
++>>>>>>> 184345129c53 (cpufreq: define generic .attr, .exit() and .verify() routines)
  
  #endif /* _LINUX_CPUFREQ_H */
diff --git a/drivers/cpufreq/freq_table.c b/drivers/cpufreq/freq_table.c
index b9336edb9bd6..3458d27f63b4 100644
--- a/drivers/cpufreq/freq_table.c
+++ b/drivers/cpufreq/freq_table.c
@@ -86,6 +86,20 @@ int cpufreq_frequency_table_verify(struct cpufreq_policy *policy,
 }
 EXPORT_SYMBOL_GPL(cpufreq_frequency_table_verify);
 
+/*
+ * Generic routine to verify policy & frequency table, requires driver to call
+ * cpufreq_frequency_table_get_attr() prior to it.
+ */
+int cpufreq_generic_frequency_table_verify(struct cpufreq_policy *policy)
+{
+	struct cpufreq_frequency_table *table =
+		cpufreq_frequency_get_table(policy->cpu);
+	if (!table)
+		return -ENODEV;
+
+	return cpufreq_frequency_table_verify(policy, table);
+}
+EXPORT_SYMBOL_GPL(cpufreq_generic_frequency_table_verify);
 
 int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
 				   struct cpufreq_frequency_table *table,
@@ -199,6 +213,12 @@ struct freq_attr cpufreq_freq_attr_scaling_available_freqs = {
 };
 EXPORT_SYMBOL_GPL(cpufreq_freq_attr_scaling_available_freqs);
 
+struct freq_attr *cpufreq_generic_attr[] = {
+	&cpufreq_freq_attr_scaling_available_freqs,
+	NULL,
+};
+EXPORT_SYMBOL_GPL(cpufreq_generic_attr);
+
 /*
  * if you use these, you must assure that the frequency table is valid
  * all the time between get_attr and put_attr!
* Unmerged path include/linux/cpufreq.h
