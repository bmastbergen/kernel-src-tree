blk-mq: make the sysfs mq/ layout reflect current mappings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Jens Axboe <axboe@fb.com>
commit 67aec14ce87fe25bdfff7dbf468556333df11c4e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/67aec14c.failed

Currently blk-mq registers all the hardware queues in sysfs,
regardless of whether it uses them (e.g. they have CPU mappings)
or not. The unused hardware queues lack the cpux/ directories,
and the other sysfs entries (like active, pending, etc) are all
zeroes.

Change this so that sysfs correctly reflects the current mappings
of the hardware queues.

	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 67aec14ce87fe25bdfff7dbf468556333df11c4e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.h
#	include/linux/blk-mq.h
diff --cc block/blk-mq.h
index 98ea89df2873,de7b3bbd5bd6..000000000000
--- a/block/blk-mq.h
+++ b/block/blk-mq.h
@@@ -44,10 -50,23 +44,27 @@@ void blk_mq_disable_hotplug(void)
  /*
   * CPU -> queue mappings
   */
 -extern unsigned int *blk_mq_make_queue_map(struct blk_mq_tag_set *set);
 +struct blk_mq_reg;
 +extern unsigned int *blk_mq_make_queue_map(struct blk_mq_reg *reg);
  extern int blk_mq_update_queue_map(unsigned int *map, unsigned int nr_queues);
 -extern int blk_mq_hw_queue_to_node(unsigned int *map, unsigned int);
  
++<<<<<<< HEAD
 +void blk_mq_add_timer(struct request *rq);
++=======
+ /*
+  * sysfs helpers
+  */
+ extern int blk_mq_sysfs_register(struct request_queue *q);
+ extern void blk_mq_sysfs_unregister(struct request_queue *q);
+ 
+ /*
+  * Basic implementation of sparser bitmap, allowing the user to spread
+  * the bits over more cachelines.
+  */
+ struct blk_align_bitmap {
+ 	unsigned long word;
+ 	unsigned long depth;
+ } ____cacheline_aligned_in_smp;
++>>>>>>> 67aec14ce87f (blk-mq: make the sysfs mq/ layout reflect current mappings)
  
  #endif
diff --cc include/linux/blk-mq.h
index 0f2259d5e784,c15128833100..000000000000
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@@ -108,16 -128,24 +108,22 @@@ enum 
  
  	BLK_MQ_F_SHOULD_MERGE	= 1 << 0,
  	BLK_MQ_F_SHOULD_SORT	= 1 << 1,
++<<<<<<< HEAD
++=======
+ 	BLK_MQ_F_TAG_SHARED	= 1 << 2,
+ 	BLK_MQ_F_SG_MERGE	= 1 << 3,
+ 	BLK_MQ_F_SYSFS_UP	= 1 << 4,
++>>>>>>> 67aec14ce87f (blk-mq: make the sysfs mq/ layout reflect current mappings)
  
  	BLK_MQ_S_STOPPED	= 0,
 -	BLK_MQ_S_TAG_ACTIVE	= 1,
  
  	BLK_MQ_MAX_DEPTH	= 2048,
 -
 -	BLK_MQ_CPU_WORK_BATCH	= 8,
  };
  
 -struct request_queue *blk_mq_init_queue(struct blk_mq_tag_set *);
 +struct request_queue *blk_mq_init_queue(struct blk_mq_reg *, void *);
  int blk_mq_register_disk(struct gendisk *);
  void blk_mq_unregister_disk(struct gendisk *);
 -
 -int blk_mq_alloc_tag_set(struct blk_mq_tag_set *set);
 -void blk_mq_free_tag_set(struct blk_mq_tag_set *set);
 +void blk_mq_init_commands(struct request_queue *, void (*init)(void *data, struct blk_mq_hw_ctx *, struct request *, unsigned int), void *data);
  
  void blk_mq_flush_plug_list(struct blk_plug *plug, bool from_schedule);
  
diff --git a/block/blk-mq-sysfs.c b/block/blk-mq-sysfs.c
index 8145b5b25b4b..43c96c6335cf 100644
--- a/block/blk-mq-sysfs.c
+++ b/block/blk-mq-sysfs.c
@@ -317,6 +317,42 @@ static struct kobj_type blk_mq_hw_ktype = {
 	.release	= blk_mq_sysfs_release,
 };
 
+void blk_mq_unregister_hctx(struct blk_mq_hw_ctx *hctx)
+{
+	struct blk_mq_ctx *ctx;
+	int i;
+
+	if (!hctx->nr_ctx || !(hctx->flags & BLK_MQ_F_SYSFS_UP))
+		return;
+
+	hctx_for_each_ctx(hctx, ctx, i)
+		kobject_del(&ctx->kobj);
+
+	kobject_del(&hctx->kobj);
+}
+
+int blk_mq_register_hctx(struct blk_mq_hw_ctx *hctx)
+{
+	struct request_queue *q = hctx->queue;
+	struct blk_mq_ctx *ctx;
+	int i, ret;
+
+	if (!hctx->nr_ctx || !(hctx->flags & BLK_MQ_F_SYSFS_UP))
+		return 0;
+
+	ret = kobject_add(&hctx->kobj, &q->mq_kobj, "%u", hctx->queue_num);
+	if (ret)
+		return ret;
+
+	hctx_for_each_ctx(hctx, ctx, i) {
+		ret = kobject_add(&ctx->kobj, &hctx->kobj, "cpu%u", ctx->cpu);
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
+
 void blk_mq_unregister_disk(struct gendisk *disk)
 {
 	struct request_queue *q = disk->queue;
@@ -325,11 +361,11 @@ void blk_mq_unregister_disk(struct gendisk *disk)
 	int i, j;
 
 	queue_for_each_hw_ctx(q, hctx, i) {
-		hctx_for_each_ctx(hctx, ctx, j) {
-			kobject_del(&ctx->kobj);
+		blk_mq_unregister_hctx(hctx);
+
+		hctx_for_each_ctx(hctx, ctx, j)
 			kobject_put(&ctx->kobj);
-		}
-		kobject_del(&hctx->kobj);
+
 		kobject_put(&hctx->kobj);
 	}
 
@@ -340,15 +376,30 @@ void blk_mq_unregister_disk(struct gendisk *disk)
 	kobject_put(&disk_to_dev(disk)->kobj);
 }
 
+static void blk_mq_sysfs_init(struct request_queue *q)
+{
+	struct blk_mq_hw_ctx *hctx;
+	struct blk_mq_ctx *ctx;
+	int i, j;
+
+	kobject_init(&q->mq_kobj, &blk_mq_ktype);
+
+	queue_for_each_hw_ctx(q, hctx, i) {
+		kobject_init(&hctx->kobj, &blk_mq_hw_ktype);
+
+		hctx_for_each_ctx(hctx, ctx, j)
+			kobject_init(&ctx->kobj, &blk_mq_ctx_ktype);
+	}
+}
+
 int blk_mq_register_disk(struct gendisk *disk)
 {
 	struct device *dev = disk_to_dev(disk);
 	struct request_queue *q = disk->queue;
 	struct blk_mq_hw_ctx *hctx;
-	struct blk_mq_ctx *ctx;
-	int ret, i, j;
+	int ret, i;
 
-	kobject_init(&q->mq_kobj, &blk_mq_ktype);
+	blk_mq_sysfs_init(q);
 
 	ret = kobject_add(&q->mq_kobj, kobject_get(&dev->kobj), "%s", "mq");
 	if (ret < 0)
@@ -357,20 +408,10 @@ int blk_mq_register_disk(struct gendisk *disk)
 	kobject_uevent(&q->mq_kobj, KOBJ_ADD);
 
 	queue_for_each_hw_ctx(q, hctx, i) {
-		kobject_init(&hctx->kobj, &blk_mq_hw_ktype);
-		ret = kobject_add(&hctx->kobj, &q->mq_kobj, "%u", i);
+		hctx->flags |= BLK_MQ_F_SYSFS_UP;
+		ret = blk_mq_register_hctx(hctx);
 		if (ret)
 			break;
-
-		if (!hctx->nr_ctx)
-			continue;
-
-		hctx_for_each_ctx(hctx, ctx, j) {
-			kobject_init(&ctx->kobj, &blk_mq_ctx_ktype);
-			ret = kobject_add(&ctx->kobj, &hctx->kobj, "cpu%u", ctx->cpu);
-			if (ret)
-				break;
-		}
 	}
 
 	if (ret) {
@@ -380,3 +421,26 @@ int blk_mq_register_disk(struct gendisk *disk)
 
 	return 0;
 }
+
+void blk_mq_sysfs_unregister(struct request_queue *q)
+{
+	struct blk_mq_hw_ctx *hctx;
+	int i;
+
+	queue_for_each_hw_ctx(q, hctx, i)
+		blk_mq_unregister_hctx(hctx);
+}
+
+int blk_mq_sysfs_register(struct request_queue *q)
+{
+	struct blk_mq_hw_ctx *hctx;
+	int i, ret = 0;
+
+	queue_for_each_hw_ctx(q, hctx, i) {
+		ret = blk_mq_register_hctx(hctx);
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
diff --git a/block/blk-mq.c b/block/blk-mq.c
index 210626be5c6c..3ab0491b2568 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -1451,6 +1451,8 @@ static void __cpuinit blk_mq_queue_reinit(struct request_queue *q)
 {
 	blk_mq_freeze_queue(q);
 
+	blk_mq_sysfs_unregister(q);
+
 	blk_mq_update_queue_map(q->mq_map, q->nr_hw_queues);
 
 	/*
@@ -1461,6 +1463,8 @@ static void __cpuinit blk_mq_queue_reinit(struct request_queue *q)
 
 	blk_mq_map_swqueue(q);
 
+	blk_mq_sysfs_register(q);
+
 	blk_mq_unfreeze_queue(q);
 }
 
* Unmerged path block/blk-mq.h
* Unmerged path include/linux/blk-mq.h
