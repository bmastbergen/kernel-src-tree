ixgbe: fix ixgbe_setup_mac_link_82599 autoc variables

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Jacob Keller <jacob.e.keller@intel.com>
commit ee98b577e7711d5890ded2c7b05578a29512bd39
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/ee98b577.failed

This patch fixes flow control autonegotiation for KR/KX/K4 interfaces.
When setting up MAC link, the cached autoc value and current autoc value
were being incorrectly used to determine whether link reset is required.
This resulted in the driver ignoring and discarding flow control
negotiation changes that occur since the caching happened, as well as
when the mac was being setup.

This patch also splits the assignments for the 3 autoc variables into
their own block, and adds a comment explaining what each one means, in
order to help keep logic more straightforward while reading the code.

CC: Arun Sharma <asharma@fb.com>
	Reported-by: Sourav Chatterjee <sourav.chatterjee@intel.com>
	Signed-off-by: Jacob Keller <jacob.e.keller@intel.com>
	Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit ee98b577e7711d5890ded2c7b05578a29512bd39)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
index 40ae44cc44fc,e0fe8e88fbfa..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
@@@ -967,16 -1031,19 +967,31 @@@ static s32 ixgbe_setup_mac_link_82599(s
  				      ixgbe_link_speed speed,
  				      bool autoneg_wait_to_complete)
  {
++<<<<<<< HEAD
 +	s32 status = 0;
 +	u32 autoc, pma_pmd_1g, link_mode, start_autoc;
 +	u32 autoc2 = IXGBE_READ_REG(hw, IXGBE_AUTOC2);
 +	u32 orig_autoc = 0;
 +	u32 pma_pmd_10g_serial = autoc2 & IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK;
 +	u32 links_reg;
 +	u32 i;
 +	ixgbe_link_speed link_capabilities = IXGBE_LINK_SPEED_UNKNOWN;
 +	bool got_lock = false;
++=======
++>>>>>>> ee98b577e771 (ixgbe: fix ixgbe_setup_mac_link_82599 autoc variables)
  	bool autoneg = false;
+ 	s32 status = 0;
+ 	u32 pma_pmd_1g, link_mode, links_reg, i;
+ 	u32 autoc2 = IXGBE_READ_REG(hw, IXGBE_AUTOC2);
+ 	u32 pma_pmd_10g_serial = autoc2 & IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK;
+ 	ixgbe_link_speed link_capabilities = IXGBE_LINK_SPEED_UNKNOWN;
+ 
+ 	/* holds the value of AUTOC register at this current point in time */
+ 	u32 current_autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
+ 	/* holds the cached value of AUTOC register */
+ 	u32 orig_autoc = 0;
+ 	/* temporary variable used for comparison purposes */
+ 	u32 autoc = current_autoc;
  
  	/* Check to see if speed passed in is supported. */
  	status = hw->mac.ops.get_link_capabilities(hw, &link_capabilities,
@@@ -993,12 -1060,10 +1008,15 @@@
  
  	/* Use stored value (EEPROM defaults) of AUTOC to find KR/KX4 support*/
  	if (hw->mac.orig_link_settings_stored)
- 		autoc = hw->mac.orig_autoc;
+ 		orig_autoc = hw->mac.orig_autoc;
  	else
- 		autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
+ 		orig_autoc = autoc;
  
++<<<<<<< HEAD
 +	orig_autoc = autoc;
 +	start_autoc = hw->mac.cached_autoc;
++=======
++>>>>>>> ee98b577e771 (ixgbe: fix ixgbe_setup_mac_link_82599 autoc variables)
  	link_mode = autoc & IXGBE_AUTOC_LMS_MASK;
  	pma_pmd_1g = autoc & IXGBE_AUTOC_1G_PMA_PMD_MASK;
  
@@@ -1038,28 -1103,11 +1056,32 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	if (autoc != start_autoc) {
 +		/* Need SW/FW semaphore around AUTOC writes if LESM is on,
 +		 * likewise reset_pipeline requires us to hold this lock as
 +		 * it also writes to AUTOC.
 +		 */
 +		if (ixgbe_verify_lesm_fw_enabled_82599(hw)) {
 +			status = hw->mac.ops.acquire_swfw_sync(hw,
 +							IXGBE_GSSR_MAC_CSR_SM);
 +			if (status != 0)
 +				goto out;
 +
 +			got_lock = true;
 +		}
 +
++=======
+ 	if (autoc != current_autoc) {
++>>>>>>> ee98b577e771 (ixgbe: fix ixgbe_setup_mac_link_82599 autoc variables)
  		/* Restart link */
 -		status = hw->mac.ops.prot_autoc_write(hw, autoc, false);
 -		if (status)
 -			goto out;
 +		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc);
 +		hw->mac.cached_autoc = autoc;
 +		ixgbe_reset_pipeline_82599(hw);
 +
 +		if (got_lock)
 +			hw->mac.ops.release_swfw_sync(hw,
 +						      IXGBE_GSSR_MAC_CSR_SM);
  
  		/* Only poll for autoneg to complete if specified to do so */
  		if (autoneg_wait_to_complete) {
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
