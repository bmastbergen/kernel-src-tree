perf tools: Add file size check and factor dso__data_read_offset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf: Add file size check and factor dso__data_read_offset (Jiri Olsa) [1134356]
Rebuild_FUZZ: 95.08%
commit-author Jiri Olsa <jolsa@kernel.org>
commit c3fbd2a606c5f88de0079b027727a1fb0ae27b65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/c3fbd2a6.failed

Adding file size check, because the lseek will succeed for
any offset behind file size and thus succeed when it was
expected to fail.

Factoring the code to check the offset against file size
earlier in the flow.

	Acked-by: Namhyung Kim <namhyung@kernel.org>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Jean Pihet <jean.pihet@linaro.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1401892622-30848-8-git-send-email-jolsa@kernel.org
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
(cherry picked from commit c3fbd2a606c5f88de0079b027727a1fb0ae27b65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/dso.c
#	tools/perf/util/dso.h
diff --cc tools/perf/util/dso.c
index ffd3d5ede878,db634383156c..000000000000
--- a/tools/perf/util/dso.c
+++ b/tools/perf/util/dso.c
@@@ -159,6 -182,92 +159,95 @@@ static int open_dso(struct dso *dso, st
  	return fd;
  }
  
++<<<<<<< HEAD
++=======
+ static void check_data_close(void);
+ 
+ static int open_dso(struct dso *dso, struct machine *machine)
+ {
+ 	int fd = __open_dso(dso, machine);
+ 
+ 	if (fd > 0) {
+ 		dso__list_add(dso);
+ 		/*
+ 		 * Check if we crossed the allowed number
+ 		 * of opened DSOs and close one if needed.
+ 		 */
+ 		check_data_close();
+ 	}
+ 
+ 	return fd;
+ }
+ 
+ static void close_data_fd(struct dso *dso)
+ {
+ 	if (dso->data.fd >= 0) {
+ 		close(dso->data.fd);
+ 		dso->data.fd = -1;
+ 		dso->data.file_size = 0;
+ 		dso__list_del(dso);
+ 	}
+ }
+ 
+ static void close_dso(struct dso *dso)
+ {
+ 	close_data_fd(dso);
+ }
+ 
+ static void close_first_dso(void)
+ {
+ 	struct dso *dso;
+ 
+ 	dso = list_first_entry(&dso__data_open, struct dso, data.open_entry);
+ 	close_dso(dso);
+ }
+ 
+ static rlim_t get_fd_limit(void)
+ {
+ 	struct rlimit l;
+ 	rlim_t limit = 0;
+ 
+ 	/* Allow half of the current open fd limit. */
+ 	if (getrlimit(RLIMIT_NOFILE, &l) == 0) {
+ 		if (l.rlim_cur == RLIM_INFINITY)
+ 			limit = l.rlim_cur;
+ 		else
+ 			limit = l.rlim_cur / 2;
+ 	} else {
+ 		pr_err("failed to get fd limit\n");
+ 		limit = 1;
+ 	}
+ 
+ 	return limit;
+ }
+ 
+ static bool may_cache_fd(void)
+ {
+ 	static rlim_t limit;
+ 
+ 	if (!limit)
+ 		limit = get_fd_limit();
+ 
+ 	if (limit == RLIM_INFINITY)
+ 		return true;
+ 
+ 	return limit > (rlim_t) dso__data_open_cnt;
+ }
+ 
+ static void check_data_close(void)
+ {
+ 	bool cache_fd = may_cache_fd();
+ 
+ 	if (!cache_fd)
+ 		close_first_dso();
+ }
+ 
+ void dso__data_close(struct dso *dso)
+ {
+ 	close_dso(dso);
+ }
+ 
++>>>>>>> c3fbd2a606c5 (perf tools: Add file size check and factor dso__data_read_offset)
  int dso__data_fd(struct dso *dso, struct machine *machine)
  {
  	enum dso_binary_type binary_type_data[] = {
diff --cc tools/perf/util/dso.h
index 433c80284bd6,da47b13595f3..000000000000
--- a/tools/perf/util/dso.h
+++ b/tools/perf/util/dso.h
@@@ -102,6 -102,9 +102,12 @@@ struct dso 
  	/* dso data file */
  	struct {
  		struct rb_root	 cache;
++<<<<<<< HEAD
++=======
+ 		int		 fd;
+ 		size_t		 file_size;
+ 		struct list_head open_entry;
++>>>>>>> c3fbd2a606c5 (perf tools: Add file size check and factor dso__data_read_offset)
  	} data;
  
  	char		 name[0];
* Unmerged path tools/perf/util/dso.c
* Unmerged path tools/perf/util/dso.h
