s390/uaccess: normalize order of parameters of indirect uaccess function calls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [s390] uaccess: normalize order of parameters of indirect uaccess function calls (Hendrik Brueckner) [1099147]
Rebuild_FUZZ: 96.69%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit cfa785e623577cdad2aa721acb23bd3a95eced9a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/cfa785e6.failed

For some unknown reason the indirect uaccess functions on s390 implement a
different parameter order than what is usual.

e.g.:

unsigned long copy_to_user(void *to, const void *from, unsigned long n);
vs.
size_t (*copy_to_user)(size_t n, void __user * to, const void *from);

Let's get rid of this confusing parameter reordering.

	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit cfa785e623577cdad2aa721acb23bd3a95eced9a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/uaccess.h
#	arch/s390/lib/uaccess_mvcos.c
diff --cc arch/s390/include/asm/uaccess.h
index 9c33ed4e666f,73199636ba98..000000000000
--- a/arch/s390/include/asm/uaccess.h
+++ b/arch/s390/include/asm/uaccess.h
@@@ -93,14 -93,12 +93,23 @@@ static inline unsigned long extable_fix
  #define ARCH_HAS_SEARCH_EXTABLE
  
  struct uaccess_ops {
++<<<<<<< HEAD
 +	size_t (*copy_from_user)(size_t, const void __user *, void *);
 +	size_t (*copy_from_user_small)(size_t, const void __user *, void *);
 +	size_t (*copy_to_user)(size_t, void __user *, const void *);
 +	size_t (*copy_to_user_small)(size_t, void __user *, const void *);
 +	size_t (*copy_in_user)(size_t, void __user *, const void __user *);
 +	size_t (*clear_user)(size_t, void __user *);
 +	size_t (*strnlen_user)(size_t, const char __user *);
 +	size_t (*strncpy_from_user)(size_t, const char __user *, char *);
++=======
+ 	size_t (*copy_from_user)(void *, const void __user *, size_t);
+ 	size_t (*copy_to_user)(void __user *, const void *, size_t);
+ 	size_t (*copy_in_user)(void __user *, const void __user *, size_t);
+ 	size_t (*clear_user)(void __user *, size_t);
+ 	size_t (*strnlen_user)(const char __user *, size_t);
+ 	size_t (*strncpy_from_user)(char *, const char __user *, size_t);
++>>>>>>> cfa785e62357 (s390/uaccess: normalize order of parameters of indirect uaccess function calls)
  	int (*futex_atomic_op)(int op, u32 __user *, int oparg, int *old);
  	int (*futex_atomic_cmpxchg)(u32 *, u32 __user *, u32 old, u32 new);
  };
@@@ -113,15 -109,15 +122,23 @@@ extern struct uaccess_ops uaccess_pt
  
  extern int __handle_fault(unsigned long, unsigned long, int);
  
- static inline int __put_user_fn(size_t size, void __user *ptr, void *x)
+ static inline int __put_user_fn(void *x, void __user *ptr, size_t size)
  {
++<<<<<<< HEAD
 +	size = uaccess.copy_to_user_small(size, ptr, x);
++=======
+ 	size = uaccess.copy_to_user(ptr, x, size);
++>>>>>>> cfa785e62357 (s390/uaccess: normalize order of parameters of indirect uaccess function calls)
  	return size ? -EFAULT : size;
  }
  
- static inline int __get_user_fn(size_t size, const void __user *ptr, void *x)
+ static inline int __get_user_fn(void *x, const void __user *ptr, size_t size)
  {
++<<<<<<< HEAD
 +	size = uaccess.copy_from_user_small(size, ptr, x);
++=======
+ 	size = uaccess.copy_from_user(x, ptr, size);
++>>>>>>> cfa785e62357 (s390/uaccess: normalize order of parameters of indirect uaccess function calls)
  	return size ? -EFAULT : size;
  }
  
@@@ -226,10 -222,7 +243,14 @@@ extern int __get_user_bad(void) __attri
  static inline unsigned long __must_check
  __copy_to_user(void __user *to, const void *from, unsigned long n)
  {
++<<<<<<< HEAD
 +	if (__builtin_constant_p(n) && (n <= 256))
 +		return uaccess.copy_to_user_small(n, to, from);
 +	else
 +		return uaccess.copy_to_user(n, to, from);
++=======
+ 	return uaccess.copy_to_user(to, from, n);
++>>>>>>> cfa785e62357 (s390/uaccess: normalize order of parameters of indirect uaccess function calls)
  }
  
  #define __copy_to_user_inatomic __copy_to_user
@@@ -275,10 -268,7 +296,14 @@@ copy_to_user(void __user *to, const voi
  static inline unsigned long __must_check
  __copy_from_user(void *to, const void __user *from, unsigned long n)
  {
++<<<<<<< HEAD
 +	if (__builtin_constant_p(n) && (n <= 256))
 +		return uaccess.copy_from_user_small(n, from, to);
 +	else
 +		return uaccess.copy_from_user(n, from, to);
++=======
+ 	return uaccess.copy_from_user(to, from, n);
++>>>>>>> cfa785e62357 (s390/uaccess: normalize order of parameters of indirect uaccess function calls)
  }
  
  extern void copy_from_user_overflow(void)
diff --cc arch/s390/lib/uaccess_mvcos.c
index 1829742bf479,95123f57aaf8..000000000000
--- a/arch/s390/lib/uaccess_mvcos.c
+++ b/arch/s390/lib/uaccess_mvcos.c
@@@ -65,14 -65,7 +65,18 @@@ static size_t copy_from_user_mvcos(voi
  	return size;
  }
  
++<<<<<<< HEAD
 +static size_t copy_from_user_mvcos_check(size_t size, const void __user *ptr, void *x)
 +{
 +	if (size <= 256)
 +		return copy_from_user_std(size, ptr, x);
 +	return copy_from_user_mvcos(size, ptr, x);
 +}
 +
 +static size_t copy_to_user_mvcos(size_t size, void __user *ptr, const void *x)
++=======
+ static size_t copy_to_user_mvcos(void __user *ptr, const void *x, size_t size)
++>>>>>>> cfa785e62357 (s390/uaccess: normalize order of parameters of indirect uaccess function calls)
  {
  	register unsigned long reg0 asm("0") = 0x810000UL;
  	unsigned long tmp1, tmp2;
@@@ -101,16 -94,8 +105,21 @@@
  	return size;
  }
  
++<<<<<<< HEAD
 +static size_t copy_to_user_mvcos_check(size_t size, void __user *ptr,
 +				       const void *x)
 +{
 +	if (size <= 256)
 +		return copy_to_user_std(size, ptr, x);
 +	return copy_to_user_mvcos(size, ptr, x);
 +}
 +
 +static size_t copy_in_user_mvcos(size_t size, void __user *to,
 +				 const void __user *from)
++=======
+ static size_t copy_in_user_mvcos(void __user *to, const void __user *from,
+ 				 size_t size)
++>>>>>>> cfa785e62357 (s390/uaccess: normalize order of parameters of indirect uaccess function calls)
  {
  	register unsigned long reg0 asm("0") = 0x810081UL;
  	unsigned long tmp1, tmp2;
* Unmerged path arch/s390/include/asm/uaccess.h
* Unmerged path arch/s390/lib/uaccess_mvcos.c
diff --git a/arch/s390/lib/uaccess_pt.c b/arch/s390/lib/uaccess_pt.c
index f4df0e3aabe2..162a7f17c7e3 100644
--- a/arch/s390/lib/uaccess_pt.c
+++ b/arch/s390/lib/uaccess_pt.c
@@ -22,7 +22,7 @@
 #define SLR	"slgr"
 #endif
 
-static size_t strnlen_kernel(size_t count, const char __user *src)
+static size_t strnlen_kernel(const char __user *src, size_t count)
 {
 	register unsigned long reg0 asm("0") = 0UL;
 	unsigned long tmp1, tmp2;
@@ -42,8 +42,8 @@ static size_t strnlen_kernel(size_t count, const char __user *src)
 	return count;
 }
 
-static size_t copy_in_kernel(size_t count, void __user *to,
-			     const void __user *from)
+static size_t copy_in_kernel(void __user *to, const void __user *from,
+			     size_t count)
 {
 	unsigned long tmp1;
 
@@ -211,26 +211,26 @@ fault:
 	return 0;
 }
 
-static size_t copy_from_user_pt(size_t n, const void __user *from, void *to)
+static size_t copy_from_user_pt(void *to, const void __user *from, size_t n)
 {
 	size_t rc;
 
 	if (segment_eq(get_fs(), KERNEL_DS))
-		return copy_in_kernel(n, (void __user *) to, from);
+		return copy_in_kernel((void __user *) to, from, n);
 	rc = __user_copy_pt((unsigned long) from, to, n, 0);
 	if (unlikely(rc))
 		memset(to + n - rc, 0, rc);
 	return rc;
 }
 
-static size_t copy_to_user_pt(size_t n, void __user *to, const void *from)
+static size_t copy_to_user_pt(void __user *to, const void *from, size_t n)
 {
 	if (segment_eq(get_fs(), KERNEL_DS))
-		return copy_in_kernel(n, to, (void __user *) from);
+		return copy_in_kernel(to, (void __user *) from, n);
 	return __user_copy_pt((unsigned long) to, (void *) from, n, 1);
 }
 
-static size_t clear_user_pt(size_t n, void __user *to)
+static size_t clear_user_pt(void __user *to, size_t n)
 {
 	void *zpage = (void *) empty_zero_page;
 	long done, size, ret;
@@ -242,7 +242,7 @@ static size_t clear_user_pt(size_t n, void __user *to)
 		else
 			size = n - done;
 		if (segment_eq(get_fs(), KERNEL_DS))
-			ret = copy_in_kernel(n, to, (void __user *) zpage);
+			ret = copy_in_kernel(to, (void __user *) zpage, n);
 		else
 			ret = __user_copy_pt((unsigned long) to, zpage, size, 1);
 		done += size;
@@ -253,7 +253,7 @@ static size_t clear_user_pt(size_t n, void __user *to)
 	return 0;
 }
 
-static size_t strnlen_user_pt(size_t count, const char __user *src)
+static size_t strnlen_user_pt(const char __user *src, size_t count)
 {
 	unsigned long uaddr = (unsigned long) src;
 	struct mm_struct *mm = current->mm;
@@ -263,7 +263,7 @@ static size_t strnlen_user_pt(size_t count, const char __user *src)
 	if (unlikely(!count))
 		return 0;
 	if (segment_eq(get_fs(), KERNEL_DS))
-		return strnlen_kernel(count, src);
+		return strnlen_kernel(src, count);
 	if (!mm)
 		return 0;
 	done = 0;
@@ -289,8 +289,8 @@ fault:
 	goto retry;
 }
 
-static size_t strncpy_from_user_pt(size_t count, const char __user *src,
-				   char *dst)
+static size_t strncpy_from_user_pt(char *dst, const char __user *src,
+				   size_t count)
 {
 	size_t done, len, offset, len_str;
 
@@ -301,7 +301,7 @@ static size_t strncpy_from_user_pt(size_t count, const char __user *src,
 		offset = (size_t)src & ~PAGE_MASK;
 		len = min(count - done, PAGE_SIZE - offset);
 		if (segment_eq(get_fs(), KERNEL_DS)) {
-			if (copy_in_kernel(len, (void __user *) dst, src))
+			if (copy_in_kernel((void __user *) dst, src, len))
 				return -EFAULT;
 		} else {
 			if (__user_copy_pt((unsigned long) src, dst, len, 0))
@@ -315,8 +315,8 @@ static size_t strncpy_from_user_pt(size_t count, const char __user *src,
 	return done;
 }
 
-static size_t copy_in_user_pt(size_t n, void __user *to,
-			      const void __user *from)
+static size_t copy_in_user_pt(void __user *to, const void __user *from,
+			      size_t n)
 {
 	struct mm_struct *mm = current->mm;
 	unsigned long offset_max, uaddr, done, size, error_code;
@@ -326,7 +326,7 @@ static size_t copy_in_user_pt(size_t n, void __user *to,
 	int write_user;
 
 	if (segment_eq(get_fs(), KERNEL_DS))
-		return copy_in_kernel(n, to, from);
+		return copy_in_kernel(to, from, n);
 	if (!mm)
 		return n;
 	done = 0;
