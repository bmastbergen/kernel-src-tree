ACPI / scan: Use direct recurrence for device hierarchy walks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] scan: Use direct recurrence for device hierarchy walks (Myron Stowe) [1128632]
Rebuild_FUZZ: 93.91%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 2c22e6520ac87d8b12d4d9941e81d4119f2d903c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2c22e652.failed

Rework acpi_bus_trim() and acpi_bus_device_attach(), which is
renamed as acpi_bus_attach(), to walk the list of each device
object's children directly and call themselves recursively for
each child instead of using acpi_walk_namespace().  This
simplifies the code quite a bit and avoids the overhead of
callbacks and the ACPICA's internal processing which are not
really necessary for these two routines.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 2c22e6520ac87d8b12d4d9941e81d4119f2d903c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index 2bbdeee33be4,311904c720b1..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -1884,36 -1909,40 +1884,70 @@@ static int acpi_scan_attach_handler(str
  	return ret;
  }
  
- static acpi_status acpi_bus_device_attach(acpi_handle handle, u32 lvl_not_used,
- 					  void *not_used, void **ret_not_used)
+ static void acpi_bus_attach(struct acpi_device *device)
  {
++<<<<<<< HEAD
 +	struct acpi_device *device;
 +	unsigned long long sta_not_used;
 +	int ret;
 +
 +	/*
 +	 * Ignore errors ignored by acpi_bus_check_add() to avoid terminating
 +	 * namespace walks prematurely.
 +	 */
 +	if (acpi_bus_type_and_status(handle, &ret, &sta_not_used))
 +		return AE_OK;
 +
 +	if (acpi_bus_get_device(handle, &device))
 +		return AE_CTRL_DEPTH;
 +
++=======
+ 	struct acpi_device *child;
+ 	int ret;
+ 
+ 	acpi_bus_get_status(device);
+ 	/* Skip devices that are not present. */
+ 	if (!acpi_device_is_present(device)) {
+ 		device->flags.visited = false;
+ 		return;
+ 	}
++>>>>>>> 2c22e6520ac8 (ACPI / scan: Use direct recurrence for device hierarchy walks)
  	if (device->handler)
- 		return AE_OK;
+ 		goto ok;
  
++<<<<<<< HEAD
 +	ret = acpi_scan_attach_handler(device);
 +	if (ret < 0)
 +		return AE_CTRL_DEPTH;
 +
 +	device->flags.match_driver = true;
 +	if (ret > 0)
 +		return AE_OK;
 +
 +	ret = device_attach(&device->dev);
 +	return ret >= 0 ? AE_OK : AE_CTRL_DEPTH;
++=======
+ 	if (!device->flags.initialized) {
+ 		acpi_bus_update_power(device, NULL);
+ 		device->flags.initialized = true;
+ 	}
+ 	device->flags.visited = false;
+ 	ret = acpi_scan_attach_handler(device);
+ 	if (ret < 0)
+ 		return;
+ 
+ 	device->flags.match_driver = true;
+ 	if (!ret) {
+ 		ret = device_attach(&device->dev);
+ 		if (ret < 0)
+ 			return;
+ 	}
+ 	device->flags.visited = true;
+ 
+  ok:
+ 	list_for_each_entry(child, &device->children, node)
+ 		acpi_bus_attach(child);
++>>>>>>> 2c22e6520ac8 (ACPI / scan: Use direct recurrence for device hierarchy walks)
  }
  
  /**
@@@ -1949,59 -1975,35 +1980,82 @@@ int acpi_bus_scan(acpi_handle handle
  }
  EXPORT_SYMBOL(acpi_bus_scan);
  
++<<<<<<< HEAD
 +static acpi_status acpi_bus_device_detach(acpi_handle handle, u32 lvl_not_used,
 +					  void *not_used, void **ret_not_used)
 +{
 +	struct acpi_device *device = NULL;
 +
 +	if (!acpi_bus_get_device(handle, &device)) {
 +		struct acpi_scan_handler *dev_handler = device->handler;
 +
 +		if (dev_handler) {
 +			if (dev_handler->detach)
 +				dev_handler->detach(device);
 +
 +			device->handler = NULL;
 +		} else {
 +			device_release_driver(&device->dev);
 +		}
 +	}
 +	return AE_OK;
 +}
 +
 +static acpi_status acpi_bus_remove(acpi_handle handle, u32 lvl_not_used,
 +				   void *not_used, void **ret_not_used)
 +{
 +	struct acpi_device *device = NULL;
 +
 +	if (!acpi_bus_get_device(handle, &device))
 +		acpi_device_unregister(device);
 +
 +	return AE_OK;
 +}
 +
++=======
++>>>>>>> 2c22e6520ac8 (ACPI / scan: Use direct recurrence for device hierarchy walks)
  /**
-  * acpi_bus_trim - Remove ACPI device node and all of its descendants
-  * @start: Root of the ACPI device nodes subtree to remove.
+  * acpi_bus_trim - Detach scan handlers and drivers from ACPI device objects.
+  * @adev: Root of the ACPI namespace scope to walk.
   *
   * Must be called under acpi_scan_lock.
   */
- void acpi_bus_trim(struct acpi_device *start)
+ void acpi_bus_trim(struct acpi_device *adev)
  {
+ 	struct acpi_scan_handler *handler = adev->handler;
+ 	struct acpi_device *child;
+ 
+ 	list_for_each_entry_reverse(child, &adev->children, node)
+ 		acpi_bus_trim(child);
+ 
+ 	if (handler) {
+ 		if (handler->detach)
+ 			handler->detach(adev);
+ 
+ 		adev->handler = NULL;
+ 	} else {
+ 		device_release_driver(&adev->dev);
+ 	}
  	/*
- 	 * Execute acpi_bus_device_detach() as a post-order callback to detach
- 	 * all ACPI drivers from the device nodes being removed.
+ 	 * Most likely, the device is going away, so put it into D3cold before
+ 	 * that.
  	 */
++<<<<<<< HEAD
 +	acpi_walk_namespace(ACPI_TYPE_ANY, start->handle, ACPI_UINT32_MAX, NULL,
 +			    acpi_bus_device_detach, NULL, NULL);
 +	acpi_bus_device_detach(start->handle, 0, NULL, NULL);
 +	/*
 +	 * Execute acpi_bus_remove() as a post-order callback to remove device
 +	 * nodes in the given namespace scope.
 +	 */
 +	acpi_walk_namespace(ACPI_TYPE_ANY, start->handle, ACPI_UINT32_MAX, NULL,
 +			    acpi_bus_remove, NULL, NULL);
 +	acpi_bus_remove(start->handle, 0, NULL, NULL);
++=======
+ 	acpi_device_set_power(adev, ACPI_STATE_D3_COLD);
+ 	adev->flags.initialized = false;
+ 	adev->flags.visited = false;
++>>>>>>> 2c22e6520ac8 (ACPI / scan: Use direct recurrence for device hierarchy walks)
  }
  EXPORT_SYMBOL_GPL(acpi_bus_trim);
  
* Unmerged path drivers/acpi/scan.c
