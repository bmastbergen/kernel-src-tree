ACPI / hotplug / PCI: Simplify disable_slot()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Simplify disable_slot() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 88.89%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 1c0c5443de5f1f03ae2abce569fb673377f0fd0e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/1c0c5443.failed

After recent PCI core changes related to the rescan/remove locking,
the ACPIPHP's disable_slot() function is only called under the
general PCI rescan/remove lock, so it doesn't have to use
dev_in_slot() any more to avoid race conditions.  Make it simply
walk the devices on the bus and drop the ones in the slot being
disabled and drop dev_in_slot() which has no more users.

Moreover, to avoid problems described in the changelog of commit
29ed1f29b68a (PCI: pciehp: Fix null pointer deref when hot-removing
SR-IOV device), make disable_slot() carry out the list walk in
reverse order.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 1c0c5443de5f1f03ae2abce569fb673377f0fd0e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index d78516334707,f24c19c8f8c4..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -739,59 -623,52 +739,62 @@@ static int __ref enable_device(struct a
  			continue;
  		}
  	}
 +
 +
 + err_exit:
 +	return 0;
  }
  
++<<<<<<< HEAD
 +/* return first device in slot, acquiring a reference on it */
 +static struct pci_dev *dev_in_slot(struct acpiphp_slot *slot)
 +{
 +	struct pci_bus *bus = slot->bridge->pci_bus;
 +	struct pci_dev *dev;
 +	struct pci_dev *ret = NULL;
 +
 +	down_read(&pci_bus_sem);
 +	list_for_each_entry(dev, &bus->devices, bus_list)
 +		if (PCI_SLOT(dev->devfn) == slot->device) {
 +			ret = pci_dev_get(dev);
 +			break;
 +		}
 +	up_read(&pci_bus_sem);
 +
 +	return ret;
 +}
 +
++=======
++>>>>>>> 1c0c5443de5f (ACPI / hotplug / PCI: Simplify disable_slot())
  /**
 - * disable_slot - disable a slot
 + * disable_device - disable a slot
   * @slot: ACPI PHP slot
   */
 -static void disable_slot(struct acpiphp_slot *slot)
 +static int disable_device(struct acpiphp_slot *slot)
  {
+ 	struct pci_bus *bus = slot->bus;
+ 	struct pci_dev *dev, *prev;
  	struct acpiphp_func *func;
- 	struct pci_dev *pdev;
  
  	/*
 -	 * enable_slot() enumerates all functions in this device via
 +	 * enable_device() enumerates all functions in this device via
  	 * pci_scan_slot(), whether they have associated ACPI hotplug
  	 * methods (_EJ0, etc.) or not.  Therefore, we remove all functions
  	 * here.
  	 */
- 	while ((pdev = dev_in_slot(slot))) {
- 		pci_stop_and_remove_bus_device(pdev);
- 		pci_dev_put(pdev);
- 	}
+ 	list_for_each_entry_safe_reverse(dev, prev, &bus->devices, bus_list)
+ 		if (PCI_SLOT(dev->devfn) == slot->device)
+ 			pci_stop_and_remove_bus_device(dev);
  
 -	list_for_each_entry(func, &slot->funcs, sibling)
 -		acpiphp_bus_trim(func_to_handle(func));
 +	list_for_each_entry(func, &slot->funcs, sibling) {
 +		acpiphp_bus_trim(func->handle);
 +	}
  
  	slot->flags &= (~SLOT_ENABLED);
 -}
 -
 -static bool acpiphp_no_hotplug(acpi_handle handle)
 -{
 -	struct acpi_device *adev = NULL;
  
 -	acpi_bus_get_device(handle, &adev);
 -	return adev && adev->flags.no_hotplug;
 +	return 0;
  }
  
 -static bool slot_no_hotplug(struct acpiphp_slot *slot)
 -{
 -	struct acpiphp_func *func;
 -
 -	list_for_each_entry(func, &slot->funcs, sibling)
 -		if (acpiphp_no_hotplug(func_to_handle(func)))
 -			return true;
 -
 -	return false;
 -}
  
  /**
   * get_slot_status - get ACPI slot status
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
