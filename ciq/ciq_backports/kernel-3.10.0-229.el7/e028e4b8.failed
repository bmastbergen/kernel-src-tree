bridge: Keep track of ports capable of automatic discovery.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] bridge: Keep track of ports capable of automatic discovery (Vlad Yasevich) [896669]
Rebuild_FUZZ: 99.15%
commit-author Vlad Yasevich <vyasevic@redhat.com>
commit e028e4b8dc93be7bc3ff9e0b94cb68d7f104883b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e028e4b8.failed

By default, ports on the bridge are capable of automatic
discovery of nodes located behind the port.  This is accomplished
via flooding of unknown traffic (BR_FLOOD) and learning the
mac addresses from these packets (BR_LEARNING).
If the above functionality is disabled by turning off these
flags, the port requires static configuration in the form
of static FDB entries to function properly.

This patch adds functionality to keep track of all ports
capable of automatic discovery.  This will later be used
to control promiscuity settings.

	Acked-by: Michael S. Tsirkin <mst@redhat.com>
	Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e028e4b8dc93be7bc3ff9e0b94cb68d7f104883b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_if.c
#	net/bridge/br_private.h
diff --cc net/bridge/br_if.c
index 2f236b5d13fb,f7ef5f2b825b..000000000000
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@@ -383,8 -398,16 +397,10 @@@ int br_add_if(struct net_bridge *br, st
  
  	list_add_rcu(&p->list, &br->port_list);
  
+ 	nbp_update_port_count(br);
+ 
  	netdev_update_features(br->dev);
  
 -	if (br->dev->needed_headroom < dev->needed_headroom)
 -		br->dev->needed_headroom = dev->needed_headroom;
 -
 -	if (br_fdb_insert(br, p, dev->dev_addr, 0))
 -		netdev_err(dev, "failed insert local address bridge forwarding table\n");
 -
  	spin_lock_bh(&br->lock);
  	changed_addr = br_stp_recalculate_bridge_id(br);
  
@@@ -452,17 -472,10 +468,26 @@@ int br_del_if(struct net_bridge *br, st
  	return 0;
  }
  
++<<<<<<< HEAD
 +void __net_exit br_net_exit(struct net *net)
 +{
 +	struct net_device *dev;
 +	LIST_HEAD(list);
 +
 +	rtnl_lock();
 +	for_each_netdev(net, dev)
 +		if (dev->priv_flags & IFF_EBRIDGE)
 +			br_dev_delete(dev, &list);
 +
 +	unregister_netdevice_many(&list);
 +	rtnl_unlock();
 +
++=======
+ void br_port_flags_change(struct net_bridge_port *p, unsigned long mask)
+ {
+ 	struct net_bridge *br = p->br;
+ 
+ 	if (mask & BR_AUTO_MASK)
+ 		nbp_update_port_count(br);
++>>>>>>> e028e4b8dc93 (bridge: Keep track of ports capable of automatic discovery.)
  }
diff --cc net/bridge/br_private.h
index 10b5654d52ef,5ce3191438d8..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -385,71 -372,58 +389,83 @@@ static inline void br_netpoll_disable(s
  #endif
  
  /* br_fdb.c */
 -int br_fdb_init(void);
 -void br_fdb_fini(void);
 -void br_fdb_flush(struct net_bridge *br);
 -void br_fdb_find_delete_local(struct net_bridge *br,
 -			      const struct net_bridge_port *p,
 -			      const unsigned char *addr, u16 vid);
 -void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr);
 -void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
 -void br_fdb_cleanup(unsigned long arg);
 -void br_fdb_delete_by_port(struct net_bridge *br,
 -			   const struct net_bridge_port *p, int do_all);
 -struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
 -					  const unsigned char *addr, __u16 vid);
 -int br_fdb_test_addr(struct net_device *dev, unsigned char *addr);
 -int br_fdb_fillbuf(struct net_bridge *br, void *buf, unsigned long count,
 -		   unsigned long off);
 -int br_fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
 -		  const unsigned char *addr, u16 vid);
 -void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
 -		   const unsigned char *addr, u16 vid, bool added_by_user);
 -
 -int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 -		  struct net_device *dev, const unsigned char *addr);
 -int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[], struct net_device *dev,
 -	       const unsigned char *addr, u16 nlh_flags);
 -int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,
 -		struct net_device *dev, int idx);
 +extern int br_fdb_init(void);
 +extern void br_fdb_fini(void);
 +extern void br_fdb_flush(struct net_bridge *br);
 +extern void br_fdb_changeaddr(struct net_bridge_port *p,
 +			      const unsigned char *newaddr);
 +extern void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
 +extern void br_fdb_cleanup(unsigned long arg);
 +extern void br_fdb_delete_by_port(struct net_bridge *br,
 +				  const struct net_bridge_port *p, int do_all);
 +extern struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
 +						 const unsigned char *addr,
 +						 __u16 vid);
 +extern int br_fdb_test_addr(struct net_device *dev, unsigned char *addr);
 +extern int br_fdb_fillbuf(struct net_bridge *br, void *buf,
 +			  unsigned long count, unsigned long off);
 +extern int br_fdb_insert(struct net_bridge *br,
 +			 struct net_bridge_port *source,
 +			 const unsigned char *addr,
 +			 u16 vid);
 +extern void br_fdb_update(struct net_bridge *br,
 +			  struct net_bridge_port *source,
 +			  const unsigned char *addr,
 +			  u16 vid);
 +extern int fdb_delete_by_addr(struct net_bridge *br, const u8 *addr, u16 vid);
 +
 +extern int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 +			 struct net_device *dev,
 +			 const unsigned char *addr);
 +extern int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[],
 +		      struct net_device *dev,
 +		      const unsigned char *addr,
 +		      u16 nlh_flags);
 +extern int br_fdb_dump(struct sk_buff *skb,
 +		       struct netlink_callback *cb,
 +		       struct net_device *dev,
 +		       int idx);
  
  /* br_forward.c */
 -void br_deliver(const struct net_bridge_port *to, struct sk_buff *skb);
 -int br_dev_queue_push_xmit(struct sk_buff *skb);
 -void br_forward(const struct net_bridge_port *to,
 +extern void br_deliver(const struct net_bridge_port *to,
 +		struct sk_buff *skb);
 +extern int br_dev_queue_push_xmit(struct sk_buff *skb);
 +extern void br_forward(const struct net_bridge_port *to,
  		struct sk_buff *skb, struct sk_buff *skb0);
 -int br_forward_finish(struct sk_buff *skb);
 -void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb, bool unicast);
 -void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
 -		      struct sk_buff *skb2, bool unicast);
 +extern int br_forward_finish(struct sk_buff *skb);
 +extern void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb,
 +			     bool unicast);
 +extern void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
 +			     struct sk_buff *skb2, bool unicast);
  
  /* br_if.c */
++<<<<<<< HEAD
 +extern void br_port_carrier_check(struct net_bridge_port *p);
 +extern int br_add_bridge(struct net *net, const char *name);
 +extern int br_del_bridge(struct net *net, const char *name);
 +extern void br_net_exit(struct net *net);
 +extern int br_add_if(struct net_bridge *br,
 +	      struct net_device *dev);
 +extern int br_del_if(struct net_bridge *br,
 +	      struct net_device *dev);
 +extern int br_min_mtu(const struct net_bridge *br);
 +extern netdev_features_t br_features_recompute(struct net_bridge *br,
 +	netdev_features_t features);
++=======
+ void br_port_carrier_check(struct net_bridge_port *p);
+ int br_add_bridge(struct net *net, const char *name);
+ int br_del_bridge(struct net *net, const char *name);
+ int br_add_if(struct net_bridge *br, struct net_device *dev);
+ int br_del_if(struct net_bridge *br, struct net_device *dev);
+ int br_min_mtu(const struct net_bridge *br);
+ netdev_features_t br_features_recompute(struct net_bridge *br,
+ 					netdev_features_t features);
+ void br_port_flags_change(struct net_bridge_port *port, unsigned long mask);
++>>>>>>> e028e4b8dc93 (bridge: Keep track of ports capable of automatic discovery.)
  
  /* br_input.c */
 -int br_handle_frame_finish(struct sk_buff *skb);
 -rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
 +extern int br_handle_frame_finish(struct sk_buff *skb);
 +extern rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
  
  static inline bool br_rx_handler_check_rcu(const struct net_device *dev)
  {
* Unmerged path net/bridge/br_if.c
diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c
index f75d92e4f96b..12e6d5e60e99 100644
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@ -329,6 +329,7 @@ static void br_set_port_flag(struct net_bridge_port *p, struct nlattr *tb[],
 static int br_setport(struct net_bridge_port *p, struct nlattr *tb[])
 {
 	int err;
+	unsigned long old_flags = p->flags;
 
 	br_set_port_flag(p, tb, IFLA_BRPORT_MODE, BR_HAIRPIN_MODE);
 	br_set_port_flag(p, tb, IFLA_BRPORT_GUARD, BR_BPDU_GUARD);
@@ -354,6 +355,8 @@ static int br_setport(struct net_bridge_port *p, struct nlattr *tb[])
 		if (err)
 			return err;
 	}
+
+	br_port_flags_change(p, old_flags ^ p->flags);
 	return 0;
 }
 
* Unmerged path net/bridge/br_private.h
diff --git a/net/bridge/br_sysfs_if.c b/net/bridge/br_sysfs_if.c
index 265a878edcdd..2f4a01dbd24d 100644
--- a/net/bridge/br_sysfs_if.c
+++ b/net/bridge/br_sysfs_if.c
@@ -49,7 +49,9 @@ static BRPORT_ATTR(_name, S_IRUGO | S_IWUSR,			\
 static int store_flag(struct net_bridge_port *p, unsigned long v,
 		      unsigned long mask)
 {
-	unsigned long flags = p->flags;
+	unsigned long flags;
+
+	flags = p->flags;
 
 	if (v)
 		flags |= mask;
@@ -58,6 +60,7 @@ static int store_flag(struct net_bridge_port *p, unsigned long v,
 
 	if (flags != p->flags) {
 		p->flags = flags;
+		br_port_flags_change(p, mask);
 		br_ifinfo_notify(RTM_NEWLINK, p);
 	}
 	return 0;
