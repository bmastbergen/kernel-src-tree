ceph: check directory's completeness before emitting directory entry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Yan, Zheng <zheng.z.yan@intel.com>
commit 0081bd83c089ef3d0c9a4e4e869e2ab75f2cb379
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0081bd83.failed

	Signed-off-by: Yan, Zheng <zheng.z.yan@intel.com>
	Reviewed-by: Sage Weil <sage@inktank.com>
(cherry picked from commit 0081bd83c089ef3d0c9a4e4e869e2ab75f2cb379)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/dir.c
diff --cc fs/ceph/dir.c
index 9c6549f6a540,8c7f90b96913..000000000000
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@@ -173,37 -182,35 +173,62 @@@ more
  	spin_unlock(&dentry->d_lock);
  	spin_unlock(&parent->d_lock);
  
++<<<<<<< HEAD
 +	dout(" %llu (%llu) dentry %p %.*s %p\n", di->offset, filp->f_pos,
 +	     dentry, dentry->d_name.len, dentry->d_name.name, dentry->d_inode);
 +	filp->f_pos = di->offset;
 +	err = filldir(dirent, dentry->d_name.name,
 +		      dentry->d_name.len, di->offset,
++=======
+ 	/* make sure a dentry wasn't dropped while we didn't have parent lock */
+ 	if (!ceph_dir_is_complete(dir)) {
+ 		dout(" lost dir complete on %p; falling back to mds\n", dir);
+ 		dput(dentry);
+ 		err = -EAGAIN;
+ 		goto out;
+ 	}
+ 
+ 	dout(" %llu (%llu) dentry %p %.*s %p\n", di->offset, ctx->pos,
+ 	     dentry, dentry->d_name.len, dentry->d_name.name, dentry->d_inode);
+ 	if (!dir_emit(ctx, dentry->d_name.name,
+ 		      dentry->d_name.len,
++>>>>>>> 0081bd83c089 (ceph: check directory's completeness before emitting directory entry)
  		      ceph_translate_ino(dentry->d_sb, dentry->d_inode->i_ino),
 -		      dentry->d_inode->i_mode >> 12)) {
 -		if (last) {
 +		      dentry->d_inode->i_mode >> 12);
 +
 +	if (last) {
 +		if (err < 0) {
  			/* remember our position */
  			fi->dentry = last;
 -			fi->next_offset = fpos_off(di->offset);
 +			fi->next_offset = di->offset;
 +		} else {
 +			dput(last);
  		}
 -		dput(dentry);
 -		return 0;
  	}
++<<<<<<< HEAD
 +	last = dentry;
 +
 +	if (err < 0)
 +		goto out;
 +
 +	filp->f_pos++;
 +
 +	/* make sure a dentry wasn't dropped while we didn't have parent lock */
 +	if (!ceph_dir_is_complete(dir)) {
 +		dout(" lost dir complete on %p; falling back to mds\n", dir);
 +		err = -EAGAIN;
 +		goto out;
 +	}
 +
++=======
+ 
+ 	ctx->pos = di->offset + 1;
+ 
+ 	if (last)
+ 		dput(last);
+ 	last = dentry;
+ 
++>>>>>>> 0081bd83c089 (ceph: check directory's completeness before emitting directory entry)
  	spin_lock(&parent->d_lock);
  	p = p->prev;	/* advance to next dentry */
  	goto more;
@@@ -284,10 -291,13 +309,12 @@@ static int ceph_readdir(struct file *fi
  	    ceph_snap(inode) != CEPH_SNAPDIR &&
  	    __ceph_dir_is_complete(ci) &&
  	    __ceph_caps_issued_mask(ci, CEPH_CAP_FILE_SHARED, 1)) {
 -		u32 shared_gen = ci->i_shared_gen;
  		spin_unlock(&ci->i_ceph_lock);
 -		err = __dcache_readdir(file, ctx, shared_gen);
 +		err = __dcache_readdir(filp, dirent, filldir);
  		if (err != -EAGAIN)
  			return err;
+ 		frag = fpos_frag(ctx->pos);
+ 		off = fpos_off(ctx->pos);
  	} else {
  		spin_unlock(&ci->i_ceph_lock);
  	}
* Unmerged path fs/ceph/dir.c
