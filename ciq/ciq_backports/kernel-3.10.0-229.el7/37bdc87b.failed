openvswitch: Split ovs_flow_cmd_new_or_set().

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] openvswitch: Split ovs_flow_cmd_new_or_set() (Jiri Benc) [1110384]
Rebuild_FUZZ: 98.88%
commit-author Jarno Rajahalme <jrajahalme@nicira.com>
commit 37bdc87ba00dadd0156db77ba48224d042202435
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/37bdc87b.failed

Following patch will be easier to reason about with separate
ovs_flow_cmd_new() and ovs_flow_cmd_set() functions.

	Signed-off-by: Jarno Rajahalme <jrajahalme@nicira.com>
	Signed-off-by: Pravin B Shelar <pshelar@nicira.com>
(cherry picked from commit 37bdc87ba00dadd0156db77ba48224d042202435)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/datapath.c
diff --cc net/openvswitch/datapath.c
index d01b30b9528a,22665a6144fc..000000000000
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@@ -820,75 -952,43 +930,82 @@@ static int ovs_flow_cmd_set(struct sk_b
  	if (!dp)
  		goto err_unlock_ovs;
  
- 	/* Check if this is a duplicate flow */
+ 	/* Check that the flow exists. */
  	flow = ovs_flow_tbl_lookup(&dp->table, &key);
- 	if (!flow) {
- 		/* Bail out if we're not allowed to create a new flow. */
- 		error = -ENOENT;
- 		if (info->genlhdr->cmd == OVS_FLOW_CMD_SET)
- 			goto err_unlock_ovs;
+ 	error = -ENOENT;
+ 	if (!flow)
+ 		goto err_unlock_ovs;
  
- 		/* Allocate flow. */
- 		flow = ovs_flow_alloc();
- 		if (IS_ERR(flow)) {
- 			error = PTR_ERR(flow);
- 			goto err_unlock_ovs;
- 		}
+ 	/* The unmasked key has to be the same for flow updates. */
+ 	error = -EEXIST;
+ 	if (!ovs_flow_cmp_unmasked_key(flow, &match))
+ 		goto err_unlock_ovs;
  
- 		flow->key = masked_key;
- 		flow->unmasked_key = key;
+ 	/* Update actions, if present. */
+ 	if (acts) {
+ 		struct sw_flow_actions *old_acts;
+ 
+ 		old_acts = ovsl_dereference(flow->sf_acts);
  		rcu_assign_pointer(flow->sf_acts, acts);
++<<<<<<< HEAD
 +
 +		/* Put flow in bucket. */
 +		error = ovs_flow_tbl_insert(&dp->table, flow, &mask);
 +		if (error) {
 +			acts = NULL;
 +			goto err_flow_free;
 +		}
 +
 +		reply = ovs_flow_cmd_build_info(flow, dp, info, OVS_FLOW_CMD_NEW);
 +	} else {
 +		/* We found a matching flow. */
 +		/* Bail out if we're not allowed to modify an existing flow.
 +		 * We accept NLM_F_CREATE in place of the intended NLM_F_EXCL
 +		 * because Generic Netlink treats the latter as a dump
 +		 * request.  We also accept NLM_F_EXCL in case that bug ever
 +		 * gets fixed.
 +		 */
 +		error = -EEXIST;
 +		if (info->genlhdr->cmd == OVS_FLOW_CMD_NEW &&
 +		    info->nlhdr->nlmsg_flags & (NLM_F_CREATE | NLM_F_EXCL))
 +			goto err_unlock_ovs;
 +
 +		/* The unmasked key has to be the same for flow updates. */
 +		if (!ovs_flow_cmp_unmasked_key(flow, &match))
 +			goto err_unlock_ovs;
 +
 +		/* Update actions, if present. */
 +		if (acts) {
 +			struct sw_flow_actions *old_acts;
 +
 +			old_acts = ovsl_dereference(flow->sf_acts);
 +			rcu_assign_pointer(flow->sf_acts, acts);
 +			ovs_nla_free_flow_actions(old_acts);
 +		}
 +		reply = ovs_flow_cmd_build_info(flow, dp, info, OVS_FLOW_CMD_NEW);
 +
 +		/* Clear stats. */
 +		if (a[OVS_FLOW_ATTR_CLEAR])
 +			ovs_flow_stats_clear(flow);
++=======
+ 		ovs_nla_free_flow_actions(old_acts);
++>>>>>>> 37bdc87ba00d (openvswitch: Split ovs_flow_cmd_new_or_set().)
  	}
+ 
+ 	reply = ovs_flow_cmd_build_info(flow, ovs_header->dp_ifindex,
+ 					info, OVS_FLOW_CMD_NEW, false);
+ 	/* Clear stats. */
+ 	if (a[OVS_FLOW_ATTR_CLEAR])
+ 		ovs_flow_stats_clear(flow);
  	ovs_unlock();
  
 -	if (reply) {
 -		if (!IS_ERR(reply))
 -			ovs_notify(&dp_flow_genl_family, reply, info);
 -		else
 -			genl_set_err(&dp_flow_genl_family, sock_net(skb->sk), 0,
 -				     0, PTR_ERR(reply));
 -	}
 -
 +	if (!IS_ERR(reply))
 +		ovs_notify(reply, info, &ovs_dp_flow_multicast_group);
 +	else
 +		genl_set_err(sock_net(skb->sk), 0,
 +			     ovs_dp_flow_multicast_group.id, PTR_ERR(reply));
  	return 0;
  
- err_flow_free:
- 	ovs_flow_free(flow, false);
  err_unlock_ovs:
  	ovs_unlock();
  err_kfree:
* Unmerged path net/openvswitch/datapath.c
