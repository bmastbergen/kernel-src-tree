dm thin: direct dispatch when breaking sharing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [md] dm-thin: direct dispatch when breaking sharing (Mike Snitzer) [1156164]
Rebuild_FUZZ: 97.83%
commit-author Joe Thornber <ejt@redhat.com>
commit 23ca2bb6c6104db9d4cff4e33cbabee303c49d4d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/23ca2bb6.failed

This use of direct submission in process_shared_bio() reduces latency
for submitting bios in the shared cell by avoiding adding those bios to
the deferred list and waiting for the next iteration of the worker.

	Signed-off-by: Joe Thornber <ejt@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 23ca2bb6c6104db9d4cff4e33cbabee303c49d4d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-thin.c
diff --cc drivers/md/dm-thin.c
index 13e9a0386d73,3f3a66124d46..000000000000
--- a/drivers/md/dm-thin.c
+++ b/drivers/md/dm-thin.c
@@@ -1308,12 -1445,15 +1350,21 @@@ static void process_shared_bio(struct t
  	 * of being broken so we have nothing further to do here.
  	 */
  	build_data_key(tc->td, lookup_result->block, &key);
- 	if (bio_detain(pool, &key, bio, &cell))
+ 	if (bio_detain(pool, &key, bio, &data_cell)) {
+ 		cell_defer_no_holder(tc, virt_cell);
  		return;
+ 	}
  
++<<<<<<< HEAD
 +	if (bio_data_dir(bio) == WRITE && bio->bi_size)
 +		break_sharing(tc, bio, block, &key, lookup_result, cell);
 +	else {
++=======
+ 	if (bio_data_dir(bio) == WRITE && bio->bi_iter.bi_size) {
+ 		break_sharing(tc, bio, block, &key, lookup_result, data_cell);
+ 		cell_defer_no_holder(tc, virt_cell);
+ 	} else {
++>>>>>>> 23ca2bb6c610 (dm thin: direct dispatch when breaking sharing)
  		struct dm_thin_endio_hook *h = dm_per_bio_data(bio, sizeof(struct dm_thin_endio_hook));
  
  		h->shared_read_entry = dm_deferred_entry_inc(pool->shared_read_ds);
@@@ -1393,14 -1530,12 +1445,20 @@@ static void process_bio(struct thin_c *
  	r = dm_thin_find_block(tc->td, block, 1, &lookup_result);
  	switch (r) {
  	case 0:
++<<<<<<< HEAD
 +		if (lookup_result.shared) {
 +			process_shared_bio(tc, bio, block, &lookup_result);
 +			cell_defer_no_holder(tc, cell); /* FIXME: pass this cell into process_shared? */
 +		} else {
++=======
+ 		if (lookup_result.shared)
+ 			process_shared_bio(tc, bio, block, &lookup_result, cell);
+ 		else {
++>>>>>>> 23ca2bb6c610 (dm thin: direct dispatch when breaking sharing)
  			inc_all_io_entry(pool, bio);
 +			cell_defer_no_holder(tc, cell);
 +
  			remap_and_issue(tc, bio, lookup_result.block);
 -			inc_remap_and_issue_cell(tc, cell, lookup_result.block);
  		}
  		break;
  
* Unmerged path drivers/md/dm-thin.c
