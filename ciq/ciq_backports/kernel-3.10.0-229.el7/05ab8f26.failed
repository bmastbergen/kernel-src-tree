filter: prevent nla extensions to peek beyond the end of the message

jira LE-1907
cve CVE-2014-3145
cve CVE-2014-3144
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Mathias Krause <minipli@googlemail.com>
commit 05ab8f2647e4221cbdb3856dd7d32bd5407316b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/05ab8f26.failed

The BPF_S_ANC_NLATTR and BPF_S_ANC_NLATTR_NEST extensions fail to check
for a minimal message length before testing the supplied offset to be
within the bounds of the message. This allows the subtraction of the nla
header to underflow and therefore -- as the data type is unsigned --
allowing far to big offset and length values for the search of the
netlink attribute.

The remainder calculation for the BPF_S_ANC_NLATTR_NEST extension is
also wrong. It has the minuend and subtrahend mixed up, therefore
calculates a huge length value, allowing to overrun the end of the
message while looking for the netlink attribute.

The following three BPF snippets will trigger the bugs when attached to
a UNIX datagram socket and parsing a message with length 1, 2 or 3.

 ,-[ PoC for missing size check in BPF_S_ANC_NLATTR ]--
 | ld	#0x87654321
 | ldx	#42
 | ld	#nla
 | ret	a
 `---

 ,-[ PoC for the same bug in BPF_S_ANC_NLATTR_NEST ]--
 | ld	#0x87654321
 | ldx	#42
 | ld	#nlan
 | ret	a
 `---

 ,-[ PoC for wrong remainder calculation in BPF_S_ANC_NLATTR_NEST ]--
 | ; (needs a fake netlink header at offset 0)
 | ld	#0
 | ldx	#42
 | ld	#nlan
 | ret	a
 `---

Fix the first issue by ensuring the message length fulfills the minimal
size constrains of a nla header. Fix the second bug by getting the math
for the remainder calculation right.

Fixes: 4738c1db15 ("[SKFILTER]: Add SKF_ADF_NLATTR instruction")
Fixes: d214c7537b ("filter: add SKF_AD_NLATTR_NEST to look for nested..")
	Cc: Patrick McHardy <kaber@trash.net>
	Cc: Pablo Neira Ayuso <pablo@netfilter.org>
	Signed-off-by: Mathias Krause <minipli@googlemail.com>
	Acked-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 05ab8f2647e4221cbdb3856dd7d32bd5407316b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/filter.c
diff --cc net/core/filter.c
index 6438f29ff266,0e0856f5d708..000000000000
--- a/net/core/filter.c
+++ b/net/core/filter.c
@@@ -109,304 -113,1051 +109,1154 @@@ int sk_filter(struct sock *sk, struct s
  }
  EXPORT_SYMBOL(sk_filter);
  
 -/* Base function for offset calculation. Needs to go into .text section,
 - * therefore keeping it non-static as well; will also be used by JITs
 - * anyway later on, so do not let the compiler omit it.
 - */
 -noinline u64 __bpf_call_base(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)
 -{
 -	return 0;
 -}
 -
  /**
 - *	__sk_run_filter - run a filter on a given context
 - *	@ctx: buffer to run the filter on
 - *	@insn: filter to apply
 + *	sk_run_filter - run a filter on a socket
 + *	@skb: buffer to run the filter on
 + *	@fentry: filter to apply
   *
 - * Decode and apply filter instructions to the skb->data. Return length to
 - * keep, 0 for none. @ctx is the data we are operating on, @insn is the
 - * array of filter instructions.
 + * Decode and apply filter instructions to the skb->data.
 + * Return length to keep, 0 for none. @skb is the data we are
 + * filtering, @filter is the array of filter instructions.
 + * Because all jumps are guaranteed to be before last instruction,
 + * and last instruction guaranteed to be a RET, we dont need to check
 + * flen. (We used to pass to this function the length of filter)
   */
 -unsigned int __sk_run_filter(void *ctx, const struct sock_filter_int *insn)
 +unsigned int sk_run_filter(const struct sk_buff *skb,
 +			   const struct sock_filter *fentry)
  {
 -	u64 stack[MAX_BPF_STACK / sizeof(u64)];
 -	u64 regs[MAX_BPF_REG], tmp;
  	void *ptr;
++<<<<<<< HEAD
 +	u32 A = 0;			/* Accumulator */
 +	u32 X = 0;			/* Index Register */
 +	u32 mem[BPF_MEMWORDS];		/* Scratch Memory Store */
 +	u32 tmp;
 +	int k;
 +
 +	/*
 +	 * Process array of filter instructions.
 +	 */
 +	for (;; fentry++) {
 +#if defined(CONFIG_X86_32)
 +#define	K (fentry->k)
 +#else
 +		const u32 K = fentry->k;
 +#endif
 +
 +		switch (fentry->code) {
 +		case BPF_S_ALU_ADD_X:
 +			A += X;
 +			continue;
 +		case BPF_S_ALU_ADD_K:
 +			A += K;
 +			continue;
 +		case BPF_S_ALU_SUB_X:
 +			A -= X;
 +			continue;
 +		case BPF_S_ALU_SUB_K:
 +			A -= K;
 +			continue;
 +		case BPF_S_ALU_MUL_X:
 +			A *= X;
 +			continue;
 +		case BPF_S_ALU_MUL_K:
 +			A *= K;
 +			continue;
 +		case BPF_S_ALU_DIV_X:
 +			if (X == 0)
 +				return 0;
 +			A /= X;
 +			continue;
 +		case BPF_S_ALU_DIV_K:
 +			A = reciprocal_divide(A, K);
 +			continue;
 +		case BPF_S_ALU_MOD_X:
 +			if (X == 0)
 +				return 0;
 +			A %= X;
 +			continue;
 +		case BPF_S_ALU_MOD_K:
 +			A %= K;
 +			continue;
 +		case BPF_S_ALU_AND_X:
 +			A &= X;
 +			continue;
 +		case BPF_S_ALU_AND_K:
 +			A &= K;
 +			continue;
 +		case BPF_S_ALU_OR_X:
 +			A |= X;
 +			continue;
 +		case BPF_S_ALU_OR_K:
 +			A |= K;
 +			continue;
 +		case BPF_S_ANC_ALU_XOR_X:
 +		case BPF_S_ALU_XOR_X:
 +			A ^= X;
 +			continue;
 +		case BPF_S_ALU_XOR_K:
 +			A ^= K;
 +			continue;
 +		case BPF_S_ALU_LSH_X:
 +			A <<= X;
 +			continue;
 +		case BPF_S_ALU_LSH_K:
 +			A <<= K;
 +			continue;
 +		case BPF_S_ALU_RSH_X:
 +			A >>= X;
 +			continue;
 +		case BPF_S_ALU_RSH_K:
 +			A >>= K;
 +			continue;
 +		case BPF_S_ALU_NEG:
 +			A = -A;
 +			continue;
 +		case BPF_S_JMP_JA:
 +			fentry += K;
 +			continue;
 +		case BPF_S_JMP_JGT_K:
 +			fentry += (A > K) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JGE_K:
 +			fentry += (A >= K) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JEQ_K:
 +			fentry += (A == K) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JSET_K:
 +			fentry += (A & K) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JGT_X:
 +			fentry += (A > X) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JGE_X:
 +			fentry += (A >= X) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JEQ_X:
 +			fentry += (A == X) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_JMP_JSET_X:
 +			fentry += (A & X) ? fentry->jt : fentry->jf;
 +			continue;
 +		case BPF_S_LD_W_ABS:
 +			k = K;
 +load_w:
 +			ptr = load_pointer(skb, k, 4, &tmp);
 +			if (ptr != NULL) {
 +				A = get_unaligned_be32(ptr);
 +				continue;
++=======
+ 	int off;
+ 
+ #define K  insn->imm
+ #define A  regs[insn->a_reg]
+ #define X  regs[insn->x_reg]
+ #define R0 regs[0]
+ 
+ #define CONT	 ({insn++; goto select_insn; })
+ #define CONT_JMP ({insn++; goto select_insn; })
+ 
+ 	static const void *jumptable[256] = {
+ 		[0 ... 255] = &&default_label,
+ 		/* Now overwrite non-defaults ... */
+ #define DL(A, B, C)	[A|B|C] = &&A##_##B##_##C
+ 		DL(BPF_ALU, BPF_ADD, BPF_X),
+ 		DL(BPF_ALU, BPF_ADD, BPF_K),
+ 		DL(BPF_ALU, BPF_SUB, BPF_X),
+ 		DL(BPF_ALU, BPF_SUB, BPF_K),
+ 		DL(BPF_ALU, BPF_AND, BPF_X),
+ 		DL(BPF_ALU, BPF_AND, BPF_K),
+ 		DL(BPF_ALU, BPF_OR, BPF_X),
+ 		DL(BPF_ALU, BPF_OR, BPF_K),
+ 		DL(BPF_ALU, BPF_LSH, BPF_X),
+ 		DL(BPF_ALU, BPF_LSH, BPF_K),
+ 		DL(BPF_ALU, BPF_RSH, BPF_X),
+ 		DL(BPF_ALU, BPF_RSH, BPF_K),
+ 		DL(BPF_ALU, BPF_XOR, BPF_X),
+ 		DL(BPF_ALU, BPF_XOR, BPF_K),
+ 		DL(BPF_ALU, BPF_MUL, BPF_X),
+ 		DL(BPF_ALU, BPF_MUL, BPF_K),
+ 		DL(BPF_ALU, BPF_MOV, BPF_X),
+ 		DL(BPF_ALU, BPF_MOV, BPF_K),
+ 		DL(BPF_ALU, BPF_DIV, BPF_X),
+ 		DL(BPF_ALU, BPF_DIV, BPF_K),
+ 		DL(BPF_ALU, BPF_MOD, BPF_X),
+ 		DL(BPF_ALU, BPF_MOD, BPF_K),
+ 		DL(BPF_ALU, BPF_NEG, 0),
+ 		DL(BPF_ALU, BPF_END, BPF_TO_BE),
+ 		DL(BPF_ALU, BPF_END, BPF_TO_LE),
+ 		DL(BPF_ALU64, BPF_ADD, BPF_X),
+ 		DL(BPF_ALU64, BPF_ADD, BPF_K),
+ 		DL(BPF_ALU64, BPF_SUB, BPF_X),
+ 		DL(BPF_ALU64, BPF_SUB, BPF_K),
+ 		DL(BPF_ALU64, BPF_AND, BPF_X),
+ 		DL(BPF_ALU64, BPF_AND, BPF_K),
+ 		DL(BPF_ALU64, BPF_OR, BPF_X),
+ 		DL(BPF_ALU64, BPF_OR, BPF_K),
+ 		DL(BPF_ALU64, BPF_LSH, BPF_X),
+ 		DL(BPF_ALU64, BPF_LSH, BPF_K),
+ 		DL(BPF_ALU64, BPF_RSH, BPF_X),
+ 		DL(BPF_ALU64, BPF_RSH, BPF_K),
+ 		DL(BPF_ALU64, BPF_XOR, BPF_X),
+ 		DL(BPF_ALU64, BPF_XOR, BPF_K),
+ 		DL(BPF_ALU64, BPF_MUL, BPF_X),
+ 		DL(BPF_ALU64, BPF_MUL, BPF_K),
+ 		DL(BPF_ALU64, BPF_MOV, BPF_X),
+ 		DL(BPF_ALU64, BPF_MOV, BPF_K),
+ 		DL(BPF_ALU64, BPF_ARSH, BPF_X),
+ 		DL(BPF_ALU64, BPF_ARSH, BPF_K),
+ 		DL(BPF_ALU64, BPF_DIV, BPF_X),
+ 		DL(BPF_ALU64, BPF_DIV, BPF_K),
+ 		DL(BPF_ALU64, BPF_MOD, BPF_X),
+ 		DL(BPF_ALU64, BPF_MOD, BPF_K),
+ 		DL(BPF_ALU64, BPF_NEG, 0),
+ 		DL(BPF_JMP, BPF_CALL, 0),
+ 		DL(BPF_JMP, BPF_JA, 0),
+ 		DL(BPF_JMP, BPF_JEQ, BPF_X),
+ 		DL(BPF_JMP, BPF_JEQ, BPF_K),
+ 		DL(BPF_JMP, BPF_JNE, BPF_X),
+ 		DL(BPF_JMP, BPF_JNE, BPF_K),
+ 		DL(BPF_JMP, BPF_JGT, BPF_X),
+ 		DL(BPF_JMP, BPF_JGT, BPF_K),
+ 		DL(BPF_JMP, BPF_JGE, BPF_X),
+ 		DL(BPF_JMP, BPF_JGE, BPF_K),
+ 		DL(BPF_JMP, BPF_JSGT, BPF_X),
+ 		DL(BPF_JMP, BPF_JSGT, BPF_K),
+ 		DL(BPF_JMP, BPF_JSGE, BPF_X),
+ 		DL(BPF_JMP, BPF_JSGE, BPF_K),
+ 		DL(BPF_JMP, BPF_JSET, BPF_X),
+ 		DL(BPF_JMP, BPF_JSET, BPF_K),
+ 		DL(BPF_JMP, BPF_EXIT, 0),
+ 		DL(BPF_STX, BPF_MEM, BPF_B),
+ 		DL(BPF_STX, BPF_MEM, BPF_H),
+ 		DL(BPF_STX, BPF_MEM, BPF_W),
+ 		DL(BPF_STX, BPF_MEM, BPF_DW),
+ 		DL(BPF_STX, BPF_XADD, BPF_W),
+ 		DL(BPF_STX, BPF_XADD, BPF_DW),
+ 		DL(BPF_ST, BPF_MEM, BPF_B),
+ 		DL(BPF_ST, BPF_MEM, BPF_H),
+ 		DL(BPF_ST, BPF_MEM, BPF_W),
+ 		DL(BPF_ST, BPF_MEM, BPF_DW),
+ 		DL(BPF_LDX, BPF_MEM, BPF_B),
+ 		DL(BPF_LDX, BPF_MEM, BPF_H),
+ 		DL(BPF_LDX, BPF_MEM, BPF_W),
+ 		DL(BPF_LDX, BPF_MEM, BPF_DW),
+ 		DL(BPF_LD, BPF_ABS, BPF_W),
+ 		DL(BPF_LD, BPF_ABS, BPF_H),
+ 		DL(BPF_LD, BPF_ABS, BPF_B),
+ 		DL(BPF_LD, BPF_IND, BPF_W),
+ 		DL(BPF_LD, BPF_IND, BPF_H),
+ 		DL(BPF_LD, BPF_IND, BPF_B),
+ #undef DL
+ 	};
+ 
+ 	regs[FP_REG]  = (u64) (unsigned long) &stack[ARRAY_SIZE(stack)];
+ 	regs[ARG1_REG] = (u64) (unsigned long) ctx;
+ 
+ select_insn:
+ 	goto *jumptable[insn->code];
+ 
+ 	/* ALU */
+ #define ALU(OPCODE, OP)			\
+ 	BPF_ALU64_##OPCODE##_BPF_X:	\
+ 		A = A OP X;		\
+ 		CONT;			\
+ 	BPF_ALU_##OPCODE##_BPF_X:	\
+ 		A = (u32) A OP (u32) X;	\
+ 		CONT;			\
+ 	BPF_ALU64_##OPCODE##_BPF_K:	\
+ 		A = A OP K;		\
+ 		CONT;			\
+ 	BPF_ALU_##OPCODE##_BPF_K:	\
+ 		A = (u32) A OP (u32) K;	\
+ 		CONT;
+ 
+ 	ALU(BPF_ADD,  +)
+ 	ALU(BPF_SUB,  -)
+ 	ALU(BPF_AND,  &)
+ 	ALU(BPF_OR,   |)
+ 	ALU(BPF_LSH, <<)
+ 	ALU(BPF_RSH, >>)
+ 	ALU(BPF_XOR,  ^)
+ 	ALU(BPF_MUL,  *)
+ #undef ALU
+ 	BPF_ALU_BPF_NEG_0:
+ 		A = (u32) -A;
+ 		CONT;
+ 	BPF_ALU64_BPF_NEG_0:
+ 		A = -A;
+ 		CONT;
+ 	BPF_ALU_BPF_MOV_BPF_X:
+ 		A = (u32) X;
+ 		CONT;
+ 	BPF_ALU_BPF_MOV_BPF_K:
+ 		A = (u32) K;
+ 		CONT;
+ 	BPF_ALU64_BPF_MOV_BPF_X:
+ 		A = X;
+ 		CONT;
+ 	BPF_ALU64_BPF_MOV_BPF_K:
+ 		A = K;
+ 		CONT;
+ 	BPF_ALU64_BPF_ARSH_BPF_X:
+ 		(*(s64 *) &A) >>= X;
+ 		CONT;
+ 	BPF_ALU64_BPF_ARSH_BPF_K:
+ 		(*(s64 *) &A) >>= K;
+ 		CONT;
+ 	BPF_ALU64_BPF_MOD_BPF_X:
+ 		if (unlikely(X == 0))
+ 			return 0;
+ 		tmp = A;
+ 		A = do_div(tmp, X);
+ 		CONT;
+ 	BPF_ALU_BPF_MOD_BPF_X:
+ 		if (unlikely(X == 0))
+ 			return 0;
+ 		tmp = (u32) A;
+ 		A = do_div(tmp, (u32) X);
+ 		CONT;
+ 	BPF_ALU64_BPF_MOD_BPF_K:
+ 		tmp = A;
+ 		A = do_div(tmp, K);
+ 		CONT;
+ 	BPF_ALU_BPF_MOD_BPF_K:
+ 		tmp = (u32) A;
+ 		A = do_div(tmp, (u32) K);
+ 		CONT;
+ 	BPF_ALU64_BPF_DIV_BPF_X:
+ 		if (unlikely(X == 0))
+ 			return 0;
+ 		do_div(A, X);
+ 		CONT;
+ 	BPF_ALU_BPF_DIV_BPF_X:
+ 		if (unlikely(X == 0))
+ 			return 0;
+ 		tmp = (u32) A;
+ 		do_div(tmp, (u32) X);
+ 		A = (u32) tmp;
+ 		CONT;
+ 	BPF_ALU64_BPF_DIV_BPF_K:
+ 		do_div(A, K);
+ 		CONT;
+ 	BPF_ALU_BPF_DIV_BPF_K:
+ 		tmp = (u32) A;
+ 		do_div(tmp, (u32) K);
+ 		A = (u32) tmp;
+ 		CONT;
+ 	BPF_ALU_BPF_END_BPF_TO_BE:
+ 		switch (K) {
+ 		case 16:
+ 			A = (__force u16) cpu_to_be16(A);
+ 			break;
+ 		case 32:
+ 			A = (__force u32) cpu_to_be32(A);
+ 			break;
+ 		case 64:
+ 			A = (__force u64) cpu_to_be64(A);
+ 			break;
+ 		}
+ 		CONT;
+ 	BPF_ALU_BPF_END_BPF_TO_LE:
+ 		switch (K) {
+ 		case 16:
+ 			A = (__force u16) cpu_to_le16(A);
+ 			break;
+ 		case 32:
+ 			A = (__force u32) cpu_to_le32(A);
+ 			break;
+ 		case 64:
+ 			A = (__force u64) cpu_to_le64(A);
+ 			break;
+ 		}
+ 		CONT;
+ 
+ 	/* CALL */
+ 	BPF_JMP_BPF_CALL_0:
+ 		/* Function call scratches R1-R5 registers, preserves R6-R9,
+ 		 * and stores return value into R0.
+ 		 */
+ 		R0 = (__bpf_call_base + insn->imm)(regs[1], regs[2], regs[3],
+ 						   regs[4], regs[5]);
+ 		CONT;
+ 
+ 	/* JMP */
+ 	BPF_JMP_BPF_JA_0:
+ 		insn += insn->off;
+ 		CONT;
+ 	BPF_JMP_BPF_JEQ_BPF_X:
+ 		if (A == X) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_JEQ_BPF_K:
+ 		if (A == K) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_JNE_BPF_X:
+ 		if (A != X) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_JNE_BPF_K:
+ 		if (A != K) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_JGT_BPF_X:
+ 		if (A > X) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_JGT_BPF_K:
+ 		if (A > K) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_JGE_BPF_X:
+ 		if (A >= X) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_JGE_BPF_K:
+ 		if (A >= K) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_JSGT_BPF_X:
+ 		if (((s64)A) > ((s64)X)) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_JSGT_BPF_K:
+ 		if (((s64)A) > ((s64)K)) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_JSGE_BPF_X:
+ 		if (((s64)A) >= ((s64)X)) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_JSGE_BPF_K:
+ 		if (((s64)A) >= ((s64)K)) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_JSET_BPF_X:
+ 		if (A & X) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_JSET_BPF_K:
+ 		if (A & K) {
+ 			insn += insn->off;
+ 			CONT_JMP;
+ 		}
+ 		CONT;
+ 	BPF_JMP_BPF_EXIT_0:
+ 		return R0;
+ 
+ 	/* STX and ST and LDX*/
+ #define LDST(SIZEOP, SIZE)					\
+ 	BPF_STX_BPF_MEM_##SIZEOP:				\
+ 		*(SIZE *)(unsigned long) (A + insn->off) = X;	\
+ 		CONT;						\
+ 	BPF_ST_BPF_MEM_##SIZEOP:				\
+ 		*(SIZE *)(unsigned long) (A + insn->off) = K;	\
+ 		CONT;						\
+ 	BPF_LDX_BPF_MEM_##SIZEOP:				\
+ 		A = *(SIZE *)(unsigned long) (X + insn->off);	\
+ 		CONT;
+ 
+ 	LDST(BPF_B,   u8)
+ 	LDST(BPF_H,  u16)
+ 	LDST(BPF_W,  u32)
+ 	LDST(BPF_DW, u64)
+ #undef LDST
+ 	BPF_STX_BPF_XADD_BPF_W: /* lock xadd *(u32 *)(A + insn->off) += X */
+ 		atomic_add((u32) X, (atomic_t *)(unsigned long)
+ 			   (A + insn->off));
+ 		CONT;
+ 	BPF_STX_BPF_XADD_BPF_DW: /* lock xadd *(u64 *)(A + insn->off) += X */
+ 		atomic64_add((u64) X, (atomic64_t *)(unsigned long)
+ 			     (A + insn->off));
+ 		CONT;
+ 	BPF_LD_BPF_ABS_BPF_W: /* R0 = ntohl(*(u32 *) (skb->data + K)) */
+ 		off = K;
+ load_word:
+ 		/* BPF_LD + BPD_ABS and BPF_LD + BPF_IND insns are only
+ 		 * appearing in the programs where ctx == skb. All programs
+ 		 * keep 'ctx' in regs[CTX_REG] == R6, sk_convert_filter()
+ 		 * saves it in R6, internal BPF verifier will check that
+ 		 * R6 == ctx.
+ 		 *
+ 		 * BPF_ABS and BPF_IND are wrappers of function calls, so
+ 		 * they scratch R1-R5 registers, preserve R6-R9, and store
+ 		 * return value into R0.
+ 		 *
+ 		 * Implicit input:
+ 		 *   ctx
+ 		 *
+ 		 * Explicit input:
+ 		 *   X == any register
+ 		 *   K == 32-bit immediate
+ 		 *
+ 		 * Output:
+ 		 *   R0 - 8/16/32-bit skb data converted to cpu endianness
+ 		 */
+ 		ptr = load_pointer((struct sk_buff *) ctx, off, 4, &tmp);
+ 		if (likely(ptr != NULL)) {
+ 			R0 = get_unaligned_be32(ptr);
+ 			CONT;
+ 		}
+ 		return 0;
+ 	BPF_LD_BPF_ABS_BPF_H: /* R0 = ntohs(*(u16 *) (skb->data + K)) */
+ 		off = K;
+ load_half:
+ 		ptr = load_pointer((struct sk_buff *) ctx, off, 2, &tmp);
+ 		if (likely(ptr != NULL)) {
+ 			R0 = get_unaligned_be16(ptr);
+ 			CONT;
+ 		}
+ 		return 0;
+ 	BPF_LD_BPF_ABS_BPF_B: /* R0 = *(u8 *) (ctx + K) */
+ 		off = K;
+ load_byte:
+ 		ptr = load_pointer((struct sk_buff *) ctx, off, 1, &tmp);
+ 		if (likely(ptr != NULL)) {
+ 			R0 = *(u8 *)ptr;
+ 			CONT;
+ 		}
+ 		return 0;
+ 	BPF_LD_BPF_IND_BPF_W: /* R0 = ntohl(*(u32 *) (skb->data + X + K)) */
+ 		off = K + X;
+ 		goto load_word;
+ 	BPF_LD_BPF_IND_BPF_H: /* R0 = ntohs(*(u16 *) (skb->data + X + K)) */
+ 		off = K + X;
+ 		goto load_half;
+ 	BPF_LD_BPF_IND_BPF_B: /* R0 = *(u8 *) (skb->data + X + K) */
+ 		off = K + X;
+ 		goto load_byte;
+ 
+ 	default_label:
+ 		/* If we ever reach this, we have a bug somewhere. */
+ 		WARN_RATELIMIT(1, "unknown opcode %02x\n", insn->code);
+ 		return 0;
+ #undef CONT_JMP
+ #undef CONT
+ 
+ #undef R0
+ #undef X
+ #undef A
+ #undef K
+ }
+ 
+ u32 sk_run_filter_int_seccomp(const struct seccomp_data *ctx,
+ 			      const struct sock_filter_int *insni)
+     __attribute__ ((alias ("__sk_run_filter")));
+ 
+ u32 sk_run_filter_int_skb(const struct sk_buff *ctx,
+ 			  const struct sock_filter_int *insni)
+     __attribute__ ((alias ("__sk_run_filter")));
+ EXPORT_SYMBOL_GPL(sk_run_filter_int_skb);
+ 
+ /* Helper to find the offset of pkt_type in sk_buff structure. We want
+  * to make sure its still a 3bit field starting at a byte boundary;
+  * taken from arch/x86/net/bpf_jit_comp.c.
+  */
+ #define PKT_TYPE_MAX	7
+ static unsigned int pkt_type_offset(void)
+ {
+ 	struct sk_buff skb_probe = { .pkt_type = ~0, };
+ 	u8 *ct = (u8 *) &skb_probe;
+ 	unsigned int off;
+ 
+ 	for (off = 0; off < sizeof(struct sk_buff); off++) {
+ 		if (ct[off] == PKT_TYPE_MAX)
+ 			return off;
+ 	}
+ 
+ 	pr_err_once("Please fix %s, as pkt_type couldn't be found!\n", __func__);
+ 	return -1;
+ }
+ 
+ static u64 __skb_get_pay_offset(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)
+ {
+ 	struct sk_buff *skb = (struct sk_buff *)(long) ctx;
+ 
+ 	return __skb_get_poff(skb);
+ }
+ 
+ static u64 __skb_get_nlattr(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)
+ {
+ 	struct sk_buff *skb = (struct sk_buff *)(long) ctx;
+ 	struct nlattr *nla;
+ 
+ 	if (skb_is_nonlinear(skb))
+ 		return 0;
+ 
+ 	if (skb->len < sizeof(struct nlattr))
+ 		return 0;
+ 
+ 	if (A > skb->len - sizeof(struct nlattr))
+ 		return 0;
+ 
+ 	nla = nla_find((struct nlattr *) &skb->data[A], skb->len - A, X);
+ 	if (nla)
+ 		return (void *) nla - (void *) skb->data;
+ 
+ 	return 0;
+ }
+ 
+ static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)
+ {
+ 	struct sk_buff *skb = (struct sk_buff *)(long) ctx;
+ 	struct nlattr *nla;
+ 
+ 	if (skb_is_nonlinear(skb))
+ 		return 0;
+ 
+ 	if (skb->len < sizeof(struct nlattr))
+ 		return 0;
+ 
+ 	if (A > skb->len - sizeof(struct nlattr))
+ 		return 0;
+ 
+ 	nla = (struct nlattr *) &skb->data[A];
+ 	if (nla->nla_len > skb->len - A)
+ 		return 0;
+ 
+ 	nla = nla_find_nested(nla, X);
+ 	if (nla)
+ 		return (void *) nla - (void *) skb->data;
+ 
+ 	return 0;
+ }
+ 
+ static u64 __get_raw_cpu_id(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)
+ {
+ 	return raw_smp_processor_id();
+ }
+ 
+ /* Register mappings for user programs. */
+ #define A_REG		0
+ #define X_REG		7
+ #define TMP_REG		8
+ #define ARG2_REG	2
+ #define ARG3_REG	3
+ 
+ static bool convert_bpf_extensions(struct sock_filter *fp,
+ 				   struct sock_filter_int **insnp)
+ {
+ 	struct sock_filter_int *insn = *insnp;
+ 
+ 	switch (fp->k) {
+ 	case SKF_AD_OFF + SKF_AD_PROTOCOL:
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);
+ 
+ 		insn->code = BPF_LDX | BPF_MEM | BPF_H;
+ 		insn->a_reg = A_REG;
+ 		insn->x_reg = CTX_REG;
+ 		insn->off = offsetof(struct sk_buff, protocol);
+ 		insn++;
+ 
+ 		/* A = ntohs(A) [emitting a nop or swap16] */
+ 		insn->code = BPF_ALU | BPF_END | BPF_FROM_BE;
+ 		insn->a_reg = A_REG;
+ 		insn->imm = 16;
+ 		break;
+ 
+ 	case SKF_AD_OFF + SKF_AD_PKTTYPE:
+ 		insn->code = BPF_LDX | BPF_MEM | BPF_B;
+ 		insn->a_reg = A_REG;
+ 		insn->x_reg = CTX_REG;
+ 		insn->off = pkt_type_offset();
+ 		if (insn->off < 0)
+ 			return false;
+ 		insn++;
+ 
+ 		insn->code = BPF_ALU | BPF_AND | BPF_K;
+ 		insn->a_reg = A_REG;
+ 		insn->imm = PKT_TYPE_MAX;
+ 		break;
+ 
+ 	case SKF_AD_OFF + SKF_AD_IFINDEX:
+ 	case SKF_AD_OFF + SKF_AD_HATYPE:
+ 		if (FIELD_SIZEOF(struct sk_buff, dev) == 8)
+ 			insn->code = BPF_LDX | BPF_MEM | BPF_DW;
+ 		else
+ 			insn->code = BPF_LDX | BPF_MEM | BPF_W;
+ 		insn->a_reg = TMP_REG;
+ 		insn->x_reg = CTX_REG;
+ 		insn->off = offsetof(struct sk_buff, dev);
+ 		insn++;
+ 
+ 		insn->code = BPF_JMP | BPF_JNE | BPF_K;
+ 		insn->a_reg = TMP_REG;
+ 		insn->imm = 0;
+ 		insn->off = 1;
+ 		insn++;
+ 
+ 		insn->code = BPF_JMP | BPF_EXIT;
+ 		insn++;
+ 
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, type) != 2);
+ 
+ 		insn->a_reg = A_REG;
+ 		insn->x_reg = TMP_REG;
+ 
+ 		if (fp->k == SKF_AD_OFF + SKF_AD_IFINDEX) {
+ 			insn->code = BPF_LDX | BPF_MEM | BPF_W;
+ 			insn->off = offsetof(struct net_device, ifindex);
+ 		} else {
+ 			insn->code = BPF_LDX | BPF_MEM | BPF_H;
+ 			insn->off = offsetof(struct net_device, type);
+ 		}
+ 		break;
+ 
+ 	case SKF_AD_OFF + SKF_AD_MARK:
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);
+ 
+ 		insn->code = BPF_LDX | BPF_MEM | BPF_W;
+ 		insn->a_reg = A_REG;
+ 		insn->x_reg = CTX_REG;
+ 		insn->off = offsetof(struct sk_buff, mark);
+ 		break;
+ 
+ 	case SKF_AD_OFF + SKF_AD_RXHASH:
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, hash) != 4);
+ 
+ 		insn->code = BPF_LDX | BPF_MEM | BPF_W;
+ 		insn->a_reg = A_REG;
+ 		insn->x_reg = CTX_REG;
+ 		insn->off = offsetof(struct sk_buff, hash);
+ 		break;
+ 
+ 	case SKF_AD_OFF + SKF_AD_QUEUE:
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);
+ 
+ 		insn->code = BPF_LDX | BPF_MEM | BPF_H;
+ 		insn->a_reg = A_REG;
+ 		insn->x_reg = CTX_REG;
+ 		insn->off = offsetof(struct sk_buff, queue_mapping);
+ 		break;
+ 
+ 	case SKF_AD_OFF + SKF_AD_VLAN_TAG:
+ 	case SKF_AD_OFF + SKF_AD_VLAN_TAG_PRESENT:
+ 		BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, vlan_tci) != 2);
+ 
+ 		insn->code = BPF_LDX | BPF_MEM | BPF_H;
+ 		insn->a_reg = A_REG;
+ 		insn->x_reg = CTX_REG;
+ 		insn->off = offsetof(struct sk_buff, vlan_tci);
+ 		insn++;
+ 
+ 		BUILD_BUG_ON(VLAN_TAG_PRESENT != 0x1000);
+ 
+ 		if (fp->k == SKF_AD_OFF + SKF_AD_VLAN_TAG) {
+ 			insn->code = BPF_ALU | BPF_AND | BPF_K;
+ 			insn->a_reg = A_REG;
+ 			insn->imm = ~VLAN_TAG_PRESENT;
+ 		} else {
+ 			insn->code = BPF_ALU | BPF_RSH | BPF_K;
+ 			insn->a_reg = A_REG;
+ 			insn->imm = 12;
+ 			insn++;
+ 
+ 			insn->code = BPF_ALU | BPF_AND | BPF_K;
+ 			insn->a_reg = A_REG;
+ 			insn->imm = 1;
+ 		}
+ 		break;
+ 
+ 	case SKF_AD_OFF + SKF_AD_PAY_OFFSET:
+ 	case SKF_AD_OFF + SKF_AD_NLATTR:
+ 	case SKF_AD_OFF + SKF_AD_NLATTR_NEST:
+ 	case SKF_AD_OFF + SKF_AD_CPU:
+ 		/* arg1 = ctx */
+ 		insn->code = BPF_ALU64 | BPF_MOV | BPF_X;
+ 		insn->a_reg = ARG1_REG;
+ 		insn->x_reg = CTX_REG;
+ 		insn++;
+ 
+ 		/* arg2 = A */
+ 		insn->code = BPF_ALU64 | BPF_MOV | BPF_X;
+ 		insn->a_reg = ARG2_REG;
+ 		insn->x_reg = A_REG;
+ 		insn++;
+ 
+ 		/* arg3 = X */
+ 		insn->code = BPF_ALU64 | BPF_MOV | BPF_X;
+ 		insn->a_reg = ARG3_REG;
+ 		insn->x_reg = X_REG;
+ 		insn++;
+ 
+ 		/* Emit call(ctx, arg2=A, arg3=X) */
+ 		insn->code = BPF_JMP | BPF_CALL;
+ 		switch (fp->k) {
+ 		case SKF_AD_OFF + SKF_AD_PAY_OFFSET:
+ 			insn->imm = __skb_get_pay_offset - __bpf_call_base;
+ 			break;
+ 		case SKF_AD_OFF + SKF_AD_NLATTR:
+ 			insn->imm = __skb_get_nlattr - __bpf_call_base;
+ 			break;
+ 		case SKF_AD_OFF + SKF_AD_NLATTR_NEST:
+ 			insn->imm = __skb_get_nlattr_nest - __bpf_call_base;
+ 			break;
+ 		case SKF_AD_OFF + SKF_AD_CPU:
+ 			insn->imm = __get_raw_cpu_id - __bpf_call_base;
+ 			break;
+ 		}
+ 		break;
+ 
+ 	case SKF_AD_OFF + SKF_AD_ALU_XOR_X:
+ 		insn->code = BPF_ALU | BPF_XOR | BPF_X;
+ 		insn->a_reg = A_REG;
+ 		insn->x_reg = X_REG;
+ 		break;
+ 
+ 	default:
+ 		/* This is just a dummy call to avoid letting the compiler
+ 		 * evict __bpf_call_base() as an optimization. Placed here
+ 		 * where no-one bothers.
+ 		 */
+ 		BUG_ON(__bpf_call_base(0, 0, 0, 0, 0) != 0);
+ 		return false;
+ 	}
+ 
+ 	*insnp = insn;
+ 	return true;
+ }
+ 
+ /**
+  *	sk_convert_filter - convert filter program
+  *	@prog: the user passed filter program
+  *	@len: the length of the user passed filter program
+  *	@new_prog: buffer where converted program will be stored
+  *	@new_len: pointer to store length of converted program
+  *
+  * Remap 'sock_filter' style BPF instruction set to 'sock_filter_ext' style.
+  * Conversion workflow:
+  *
+  * 1) First pass for calculating the new program length:
+  *   sk_convert_filter(old_prog, old_len, NULL, &new_len)
+  *
+  * 2) 2nd pass to remap in two passes: 1st pass finds new
+  *    jump offsets, 2nd pass remapping:
+  *   new_prog = kmalloc(sizeof(struct sock_filter_int) * new_len);
+  *   sk_convert_filter(old_prog, old_len, new_prog, &new_len);
+  *
+  * User BPF's register A is mapped to our BPF register 6, user BPF
+  * register X is mapped to BPF register 7; frame pointer is always
+  * register 10; Context 'void *ctx' is stored in register 1, that is,
+  * for socket filters: ctx == 'struct sk_buff *', for seccomp:
+  * ctx == 'struct seccomp_data *'.
+  */
+ int sk_convert_filter(struct sock_filter *prog, int len,
+ 		      struct sock_filter_int *new_prog, int *new_len)
+ {
+ 	int new_flen = 0, pass = 0, target, i;
+ 	struct sock_filter_int *new_insn;
+ 	struct sock_filter *fp;
+ 	int *addrs = NULL;
+ 	u8 bpf_src;
+ 
+ 	BUILD_BUG_ON(BPF_MEMWORDS * sizeof(u32) > MAX_BPF_STACK);
+ 	BUILD_BUG_ON(FP_REG + 1 != MAX_BPF_REG);
+ 
+ 	if (len <= 0 || len >= BPF_MAXINSNS)
+ 		return -EINVAL;
+ 
+ 	if (new_prog) {
+ 		addrs = kzalloc(len * sizeof(*addrs), GFP_KERNEL);
+ 		if (!addrs)
+ 			return -ENOMEM;
+ 	}
+ 
+ do_pass:
+ 	new_insn = new_prog;
+ 	fp = prog;
+ 
+ 	if (new_insn) {
+ 		new_insn->code = BPF_ALU64 | BPF_MOV | BPF_X;
+ 		new_insn->a_reg = CTX_REG;
+ 		new_insn->x_reg = ARG1_REG;
+ 	}
+ 	new_insn++;
+ 
+ 	for (i = 0; i < len; fp++, i++) {
+ 		struct sock_filter_int tmp_insns[6] = { };
+ 		struct sock_filter_int *insn = tmp_insns;
+ 
+ 		if (addrs)
+ 			addrs[i] = new_insn - new_prog;
+ 
+ 		switch (fp->code) {
+ 		/* All arithmetic insns and skb loads map as-is. */
+ 		case BPF_ALU | BPF_ADD | BPF_X:
+ 		case BPF_ALU | BPF_ADD | BPF_K:
+ 		case BPF_ALU | BPF_SUB | BPF_X:
+ 		case BPF_ALU | BPF_SUB | BPF_K:
+ 		case BPF_ALU | BPF_AND | BPF_X:
+ 		case BPF_ALU | BPF_AND | BPF_K:
+ 		case BPF_ALU | BPF_OR | BPF_X:
+ 		case BPF_ALU | BPF_OR | BPF_K:
+ 		case BPF_ALU | BPF_LSH | BPF_X:
+ 		case BPF_ALU | BPF_LSH | BPF_K:
+ 		case BPF_ALU | BPF_RSH | BPF_X:
+ 		case BPF_ALU | BPF_RSH | BPF_K:
+ 		case BPF_ALU | BPF_XOR | BPF_X:
+ 		case BPF_ALU | BPF_XOR | BPF_K:
+ 		case BPF_ALU | BPF_MUL | BPF_X:
+ 		case BPF_ALU | BPF_MUL | BPF_K:
+ 		case BPF_ALU | BPF_DIV | BPF_X:
+ 		case BPF_ALU | BPF_DIV | BPF_K:
+ 		case BPF_ALU | BPF_MOD | BPF_X:
+ 		case BPF_ALU | BPF_MOD | BPF_K:
+ 		case BPF_ALU | BPF_NEG:
+ 		case BPF_LD | BPF_ABS | BPF_W:
+ 		case BPF_LD | BPF_ABS | BPF_H:
+ 		case BPF_LD | BPF_ABS | BPF_B:
+ 		case BPF_LD | BPF_IND | BPF_W:
+ 		case BPF_LD | BPF_IND | BPF_H:
+ 		case BPF_LD | BPF_IND | BPF_B:
+ 			/* Check for overloaded BPF extension and
+ 			 * directly convert it if found, otherwise
+ 			 * just move on with mapping.
+ 			 */
+ 			if (BPF_CLASS(fp->code) == BPF_LD &&
+ 			    BPF_MODE(fp->code) == BPF_ABS &&
+ 			    convert_bpf_extensions(fp, &insn))
+ 				break;
+ 
+ 			insn->code = fp->code;
+ 			insn->a_reg = A_REG;
+ 			insn->x_reg = X_REG;
+ 			insn->imm = fp->k;
+ 			break;
+ 
+ 		/* Jump opcodes map as-is, but offsets need adjustment. */
+ 		case BPF_JMP | BPF_JA:
+ 			target = i + fp->k + 1;
+ 			insn->code = fp->code;
+ #define EMIT_JMP							\
+ 	do {								\
+ 		if (target >= len || target < 0)			\
+ 			goto err;					\
+ 		insn->off = addrs ? addrs[target] - addrs[i] - 1 : 0;	\
+ 		/* Adjust pc relative offset for 2nd or 3rd insn. */	\
+ 		insn->off -= insn - tmp_insns;				\
+ 	} while (0)
+ 
+ 			EMIT_JMP;
+ 			break;
+ 
+ 		case BPF_JMP | BPF_JEQ | BPF_K:
+ 		case BPF_JMP | BPF_JEQ | BPF_X:
+ 		case BPF_JMP | BPF_JSET | BPF_K:
+ 		case BPF_JMP | BPF_JSET | BPF_X:
+ 		case BPF_JMP | BPF_JGT | BPF_K:
+ 		case BPF_JMP | BPF_JGT | BPF_X:
+ 		case BPF_JMP | BPF_JGE | BPF_K:
+ 		case BPF_JMP | BPF_JGE | BPF_X:
+ 			if (BPF_SRC(fp->code) == BPF_K && (int) fp->k < 0) {
+ 				/* BPF immediates are signed, zero extend
+ 				 * immediate into tmp register and use it
+ 				 * in compare insn.
+ 				 */
+ 				insn->code = BPF_ALU | BPF_MOV | BPF_K;
+ 				insn->a_reg = TMP_REG;
+ 				insn->imm = fp->k;
+ 				insn++;
+ 
+ 				insn->a_reg = A_REG;
+ 				insn->x_reg = TMP_REG;
+ 				bpf_src = BPF_X;
+ 			} else {
+ 				insn->a_reg = A_REG;
+ 				insn->x_reg = X_REG;
+ 				insn->imm = fp->k;
+ 				bpf_src = BPF_SRC(fp->code);
++>>>>>>> 05ab8f2647e4 (filter: prevent nla extensions to peek beyond the end of the message)
  			}
 -
 -			/* Common case where 'jump_false' is next insn. */
 -			if (fp->jf == 0) {
 -				insn->code = BPF_JMP | BPF_OP(fp->code) | bpf_src;
 -				target = i + fp->jt + 1;
 -				EMIT_JMP;
 -				break;
 +			return 0;
 +		case BPF_S_LD_H_ABS:
 +			k = K;
 +load_h:
 +			ptr = load_pointer(skb, k, 2, &tmp);
 +			if (ptr != NULL) {
 +				A = get_unaligned_be16(ptr);
 +				continue;
  			}
 -
 -			/* Convert JEQ into JNE when 'jump_true' is next insn. */
 -			if (fp->jt == 0 && BPF_OP(fp->code) == BPF_JEQ) {
 -				insn->code = BPF_JMP | BPF_JNE | bpf_src;
 -				target = i + fp->jf + 1;
 -				EMIT_JMP;
 -				break;
 +			return 0;
 +		case BPF_S_LD_B_ABS:
 +			k = K;
 +load_b:
 +			ptr = load_pointer(skb, k, 1, &tmp);
 +			if (ptr != NULL) {
 +				A = *(u8 *)ptr;
 +				continue;
  			}
 -
 -			/* Other jumps are mapped into two insns: Jxx and JA. */
 -			target = i + fp->jt + 1;
 -			insn->code = BPF_JMP | BPF_OP(fp->code) | bpf_src;
 -			EMIT_JMP;
 -			insn++;
 -
 -			insn->code = BPF_JMP | BPF_JA;
 -			target = i + fp->jf + 1;
 -			EMIT_JMP;
 -			break;
 -
 -		/* ldxb 4 * ([14] & 0xf) is remaped into 6 insns. */
 -		case BPF_LDX | BPF_MSH | BPF_B:
 -			insn->code = BPF_ALU64 | BPF_MOV | BPF_X;
 -			insn->a_reg = TMP_REG;
 -			insn->x_reg = A_REG;
 -			insn++;
 -
 -			insn->code = BPF_LD | BPF_ABS | BPF_B;
 -			insn->a_reg = A_REG;
 -			insn->imm = fp->k;
 -			insn++;
 -
 -			insn->code = BPF_ALU | BPF_AND | BPF_K;
 -			insn->a_reg = A_REG;
 -			insn->imm = 0xf;
 -			insn++;
 -
 -			insn->code = BPF_ALU | BPF_LSH | BPF_K;
 -			insn->a_reg = A_REG;
 -			insn->imm = 2;
 -			insn++;
 -
 -			insn->code = BPF_ALU64 | BPF_MOV | BPF_X;
 -			insn->a_reg = X_REG;
 -			insn->x_reg = A_REG;
 -			insn++;
 -
 -			insn->code = BPF_ALU64 | BPF_MOV | BPF_X;
 -			insn->a_reg = A_REG;
 -			insn->x_reg = TMP_REG;
 -			break;
 -
 -		/* RET_K, RET_A are remaped into 2 insns. */
 -		case BPF_RET | BPF_A:
 -		case BPF_RET | BPF_K:
 -			insn->code = BPF_ALU | BPF_MOV |
 -				     (BPF_RVAL(fp->code) == BPF_K ?
 -				      BPF_K : BPF_X);
 -			insn->a_reg = 0;
 -			insn->x_reg = A_REG;
 -			insn->imm = fp->k;
 -			insn++;
 -
 -			insn->code = BPF_JMP | BPF_EXIT;
 -			break;
 -
 -		/* Store to stack. */
 -		case BPF_ST:
 -		case BPF_STX:
 -			insn->code = BPF_STX | BPF_MEM | BPF_W;
 -			insn->a_reg = FP_REG;
 -			insn->x_reg = fp->code == BPF_ST ? A_REG : X_REG;
 -			insn->off = -(BPF_MEMWORDS - fp->k) * 4;
 -			break;
 -
 -		/* Load from stack. */
 -		case BPF_LD | BPF_MEM:
 -		case BPF_LDX | BPF_MEM:
 -			insn->code = BPF_LDX | BPF_MEM | BPF_W;
 -			insn->a_reg = BPF_CLASS(fp->code) == BPF_LD ?
 -				      A_REG : X_REG;
 -			insn->x_reg = FP_REG;
 -			insn->off = -(BPF_MEMWORDS - fp->k) * 4;
 -			break;
 -
 -		/* A = K or X = K */
 -		case BPF_LD | BPF_IMM:
 -		case BPF_LDX | BPF_IMM:
 -			insn->code = BPF_ALU | BPF_MOV | BPF_K;
 -			insn->a_reg = BPF_CLASS(fp->code) == BPF_LD ?
 -				      A_REG : X_REG;
 -			insn->imm = fp->k;
 -			break;
 -
 -		/* X = A */
 -		case BPF_MISC | BPF_TAX:
 -			insn->code = BPF_ALU64 | BPF_MOV | BPF_X;
 -			insn->a_reg = X_REG;
 -			insn->x_reg = A_REG;
 -			break;
 -
 -		/* A = X */
 -		case BPF_MISC | BPF_TXA:
 -			insn->code = BPF_ALU64 | BPF_MOV | BPF_X;
 -			insn->a_reg = A_REG;
 -			insn->x_reg = X_REG;
 -			break;
 -
 -		/* A = skb->len or X = skb->len */
 -		case BPF_LD | BPF_W | BPF_LEN:
 -		case BPF_LDX | BPF_W | BPF_LEN:
 -			insn->code = BPF_LDX | BPF_MEM | BPF_W;
 -			insn->a_reg = BPF_CLASS(fp->code) == BPF_LD ?
 -				      A_REG : X_REG;
 -			insn->x_reg = CTX_REG;
 -			insn->off = offsetof(struct sk_buff, len);
 -			break;
 -
 -		/* access seccomp_data fields */
 -		case BPF_LDX | BPF_ABS | BPF_W:
 -			insn->code = BPF_LDX | BPF_MEM | BPF_W;
 -			insn->a_reg = A_REG;
 -			insn->x_reg = CTX_REG;
 -			insn->off = fp->k;
 -			break;
 -
 +			return 0;
 +		case BPF_S_LD_W_LEN:
 +			A = skb->len;
 +			continue;
 +		case BPF_S_LDX_W_LEN:
 +			X = skb->len;
 +			continue;
 +		case BPF_S_LD_W_IND:
 +			k = X + K;
 +			goto load_w;
 +		case BPF_S_LD_H_IND:
 +			k = X + K;
 +			goto load_h;
 +		case BPF_S_LD_B_IND:
 +			k = X + K;
 +			goto load_b;
 +		case BPF_S_LDX_B_MSH:
 +			ptr = load_pointer(skb, K, 1, &tmp);
 +			if (ptr != NULL) {
 +				X = (*(u8 *)ptr & 0xf) << 2;
 +				continue;
 +			}
 +			return 0;
 +		case BPF_S_LD_IMM:
 +			A = K;
 +			continue;
 +		case BPF_S_LDX_IMM:
 +			X = K;
 +			continue;
 +		case BPF_S_LD_MEM:
 +			A = mem[K];
 +			continue;
 +		case BPF_S_LDX_MEM:
 +			X = mem[K];
 +			continue;
 +		case BPF_S_MISC_TAX:
 +			X = A;
 +			continue;
 +		case BPF_S_MISC_TXA:
 +			A = X;
 +			continue;
 +		case BPF_S_RET_K:
 +			return K;
 +		case BPF_S_RET_A:
 +			return A;
 +		case BPF_S_ST:
 +			mem[K] = A;
 +			continue;
 +		case BPF_S_STX:
 +			mem[K] = X;
 +			continue;
 +		case BPF_S_ANC_PROTOCOL:
 +			A = ntohs(skb->protocol);
 +			continue;
 +		case BPF_S_ANC_PKTTYPE:
 +			A = skb->pkt_type;
 +			continue;
 +		case BPF_S_ANC_IFINDEX:
 +			if (!skb->dev)
 +				return 0;
 +			A = skb->dev->ifindex;
 +			continue;
 +		case BPF_S_ANC_MARK:
 +			A = skb->mark;
 +			continue;
 +		case BPF_S_ANC_QUEUE:
 +			A = skb->queue_mapping;
 +			continue;
 +		case BPF_S_ANC_HATYPE:
 +			if (!skb->dev)
 +				return 0;
 +			A = skb->dev->type;
 +			continue;
 +		case BPF_S_ANC_RXHASH:
 +			A = skb->rxhash;
 +			continue;
 +		case BPF_S_ANC_CPU:
 +			A = raw_smp_processor_id();
 +			continue;
 +		case BPF_S_ANC_VLAN_TAG:
 +			A = vlan_tx_tag_get(skb);
 +			continue;
 +		case BPF_S_ANC_VLAN_TAG_PRESENT:
 +			A = !!vlan_tx_tag_present(skb);
 +			continue;
 +		case BPF_S_ANC_PAY_OFFSET:
 +			A = __skb_get_poff(skb);
 +			continue;
 +		case BPF_S_ANC_NLATTR: {
 +			struct nlattr *nla;
 +
 +			if (skb_is_nonlinear(skb))
 +				return 0;
 +			if (A > skb->len - sizeof(struct nlattr))
 +				return 0;
 +
 +			nla = nla_find((struct nlattr *)&skb->data[A],
 +				       skb->len - A, X);
 +			if (nla)
 +				A = (void *)nla - (void *)skb->data;
 +			else
 +				A = 0;
 +			continue;
 +		}
 +		case BPF_S_ANC_NLATTR_NEST: {
 +			struct nlattr *nla;
 +
 +			if (skb_is_nonlinear(skb))
 +				return 0;
 +			if (A > skb->len - sizeof(struct nlattr))
 +				return 0;
 +
 +			nla = (struct nlattr *)&skb->data[A];
 +			if (nla->nla_len > A - skb->len)
 +				return 0;
 +
 +			nla = nla_find_nested(nla, X);
 +			if (nla)
 +				A = (void *)nla - (void *)skb->data;
 +			else
 +				A = 0;
 +			continue;
 +		}
 +#ifdef CONFIG_SECCOMP_FILTER
 +		case BPF_S_ANC_SECCOMP_LD_W:
 +			A = seccomp_bpf_load(fentry->k);
 +			continue;
 +#endif
  		default:
 -			goto err;
 +			WARN_RATELIMIT(1, "Unknown code:%u jt:%u tf:%u k:%u\n",
 +				       fentry->code, fentry->jt,
 +				       fentry->jf, fentry->k);
 +			return 0;
  		}
 -
 -		insn++;
 -		if (new_prog)
 -			memcpy(new_insn, tmp_insns,
 -			       sizeof(*insn) * (insn - tmp_insns));
 -
 -		new_insn += insn - tmp_insns;
 -	}
 -
 -	if (!new_prog) {
 -		/* Only calculating new length. */
 -		*new_len = new_insn - new_prog;
 -		return 0;
 -	}
 -
 -	pass++;
 -	if (new_flen != new_insn - new_prog) {
 -		new_flen = new_insn - new_prog;
 -		if (pass > 2)
 -			goto err;
 -
 -		goto do_pass;
  	}
  
 -	kfree(addrs);
 -	BUG_ON(*new_len != new_flen);
  	return 0;
 -err:
 -	kfree(addrs);
 -	return -EINVAL;
  }
 +EXPORT_SYMBOL(sk_run_filter);
  
 -/* Security:
 - *
 +/*
 + * Security :
   * A BPF program is able to use 16 cells of memory to store intermediate
 - * values (check u32 mem[BPF_MEMWORDS] in sk_run_filter()).
 - *
 + * values (check u32 mem[BPF_MEMWORDS] in sk_run_filter())
   * As we dont want to clear mem[] array for each packet going through
   * sk_run_filter(), we check that filter loaded by user never try to read
   * a cell if not previously written, and we check all branches to be sure
* Unmerged path net/core/filter.c
