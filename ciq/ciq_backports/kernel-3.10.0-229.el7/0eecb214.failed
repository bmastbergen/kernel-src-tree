NFS: Create a common nfs_pgio_result_common function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Anna Schumaker <Anna.Schumaker@netapp.com>
commit 0eecb2145c1ce18e36617008424a93836ad0a3bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0eecb214.failed

Combining these functions will let me make a single nfs_rw_common_ops
struct (see the next patch).

	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 0eecb2145c1ce18e36617008424a93836ad0a3bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/internal.h
#	fs/nfs/read.c
#	fs/nfs/write.c
#	include/linux/nfs_fs.h
#	include/linux/nfs_page.h
diff --cc fs/nfs/internal.h
index 96bd22580dbf,7c0ae364bdad..000000000000
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@@ -238,6 -237,14 +238,17 @@@ extern void nfs_pgheader_init(struct nf
  void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
  int nfs_iocounter_wait(struct nfs_io_counter *c);
  
++<<<<<<< HEAD
++=======
+ struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *);
+ void nfs_rw_header_free(struct nfs_pgio_header *);
+ struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *, unsigned int);
+ void nfs_pgio_data_release(struct nfs_pgio_data *);
+ void nfs_pgio_prepare(struct rpc_task *, void *);
+ void nfs_pgio_release(void *);
+ void nfs_pgio_result(struct rpc_task *, void *);
+ 
++>>>>>>> 0eecb2145c1c (NFS: Create a common nfs_pgio_result_common function)
  static inline void nfs_iocounter_init(struct nfs_io_counter *c)
  {
  	c->flags = 0;
diff --cc fs/nfs/read.c
index 473bba35a2cb,bc78bd248eb8..000000000000
--- a/fs/nfs/read.c
+++ b/fs/nfs/read.c
@@@ -447,15 -388,10 +447,14 @@@ static const struct nfs_pageio_ops nfs_
   * This is the callback from RPC telling us whether a reply was
   * received or some error occurred (timeout or socket shutdown).
   */
++<<<<<<< HEAD
 +int nfs_readpage_result(struct rpc_task *task, struct nfs_read_data *data)
++=======
+ static int nfs_readpage_done(struct rpc_task *task, struct nfs_pgio_data *data,
+ 			     struct inode *inode)
++>>>>>>> 0eecb2145c1c (NFS: Create a common nfs_pgio_result_common function)
  {
- 	struct inode *inode = data->header->inode;
- 	int status;
- 
- 	dprintk("NFS: %s: %5u, (status %d)\n", __func__, task->tk_pid,
- 			task->tk_status);
- 
- 	status = NFS_PROTO(inode)->read_done(task, data);
+ 	int status = NFS_PROTO(inode)->read_done(task, data);
  	if (status != 0)
  		return status;
  
@@@ -488,17 -424,11 +487,15 @@@ static void nfs_readpage_retry(struct r
  	rpc_restart_call_prepare(task);
  }
  
- static void nfs_readpage_result_common(struct rpc_task *task, void *calldata)
+ static void nfs_readpage_result(struct rpc_task *task, struct nfs_pgio_data *data)
  {
++<<<<<<< HEAD
 +	struct nfs_read_data *data = calldata;
++=======
++>>>>>>> 0eecb2145c1c (NFS: Create a common nfs_pgio_result_common function)
  	struct nfs_pgio_header *hdr = data->header;
  
- 	/* Note the only returns of nfs_readpage_result are 0 and -EAGAIN */
- 	if (nfs_readpage_result(task, data) != 0)
- 		return;
- 	if (task->tk_status < 0)
- 		nfs_set_pgio_error(hdr, task->tk_status, data->args.offset);
- 	else if (data->res.eof) {
+ 	if (data->res.eof) {
  		loff_t bound;
  
  		bound = data->args.offset + data->res.count;
@@@ -513,24 -443,10 +510,30 @@@
  		nfs_readpage_retry(task, data);
  }
  
 +static void nfs_readpage_release_common(void *calldata)
 +{
 +	nfs_readdata_release(calldata);
 +}
 +
 +void nfs_read_prepare(struct rpc_task *task, void *calldata)
 +{
 +	struct nfs_read_data *data = calldata;
 +	int err;
 +	err = NFS_PROTO(data->header->inode)->read_rpc_prepare(task, data);
 +	if (err)
 +		rpc_exit(task, err);
 +}
 +
  static const struct rpc_call_ops nfs_read_common_ops = {
++<<<<<<< HEAD
 +	.rpc_call_prepare = nfs_read_prepare,
 +	.rpc_call_done = nfs_readpage_result_common,
 +	.rpc_release = nfs_readpage_release_common,
++=======
+ 	.rpc_call_prepare = nfs_pgio_prepare,
+ 	.rpc_call_done = nfs_pgio_result,
+ 	.rpc_release = nfs_pgio_release,
++>>>>>>> 0eecb2145c1c (NFS: Create a common nfs_pgio_result_common function)
  };
  
  /*
@@@ -693,3 -609,11 +696,14 @@@ void nfs_destroy_readpagecache(void
  {
  	kmem_cache_destroy(nfs_rdata_cachep);
  }
++<<<<<<< HEAD
++=======
+ 
+ static const struct nfs_rw_ops nfs_rw_read_ops = {
+ 	.rw_mode		= FMODE_READ,
+ 	.rw_alloc_header	= nfs_readhdr_alloc,
+ 	.rw_free_header		= nfs_readhdr_free,
+ 	.rw_done		= nfs_readpage_done,
+ 	.rw_result		= nfs_readpage_result,
+ };
++>>>>>>> 0eecb2145c1c (NFS: Create a common nfs_pgio_result_common function)
diff --cc fs/nfs/write.c
index f9fc82c305d1,1d3e1d75c8c5..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -1321,23 -1255,8 +1321,27 @@@ void nfs_commit_prepare(struct rpc_tas
  	NFS_PROTO(data->inode)->commit_rpc_prepare(task, data);
  }
  
++<<<<<<< HEAD
 +/*
 + * Handle a write reply that flushes a whole page.
 + *
 + * FIXME: There is an inherent race with invalidate_inode_pages and
 + *	  writebacks since the page->count is kept > 1 for as long
 + *	  as the page has a write request pending.
 + */
 +static void nfs_writeback_done_common(struct rpc_task *task, void *calldata)
 +{
 +	struct nfs_write_data	*data = calldata;
 +
 +	nfs_writeback_done(task, data);
 +}
 +
 +static void nfs_writeback_release_common(void *calldata)
++=======
+ static void nfs_writeback_release_common(struct nfs_pgio_data *data)
++>>>>>>> 0eecb2145c1c (NFS: Create a common nfs_pgio_result_common function)
  {
 +	struct nfs_write_data	*data = calldata;
  	struct nfs_pgio_header *hdr = data->header;
  	int status = data->task.tk_status;
  
@@@ -1355,9 -1273,9 +1359,15 @@@
  }
  
  static const struct rpc_call_ops nfs_write_common_ops = {
++<<<<<<< HEAD
 +	.rpc_call_prepare = nfs_write_prepare,
 +	.rpc_call_done = nfs_writeback_done_common,
 +	.rpc_release = nfs_writeback_release_common,
++=======
+ 	.rpc_call_prepare = nfs_pgio_prepare,
+ 	.rpc_call_done = nfs_pgio_result,
+ 	.rpc_release = nfs_pgio_release,
++>>>>>>> 0eecb2145c1c (NFS: Create a common nfs_pgio_result_common function)
  };
  
  /*
@@@ -1388,16 -1306,11 +1398,15 @@@ static int nfs_should_remove_suid(cons
  /*
   * This function is called when the WRITE call is complete.
   */
++<<<<<<< HEAD
 +void nfs_writeback_done(struct rpc_task *task, struct nfs_write_data *data)
++=======
+ static int nfs_writeback_done(struct rpc_task *task, struct nfs_pgio_data *data,
+ 			      struct inode *inode)
++>>>>>>> 0eecb2145c1c (NFS: Create a common nfs_pgio_result_common function)
  {
- 	struct nfs_pgio_args	*argp = &data->args;
- 	struct nfs_pgio_res	*resp = &data->res;
- 	struct inode		*inode = data->header->inode;
  	int status;
  
- 	dprintk("NFS: %5u nfs_writeback_done (status %d)\n",
- 		task->tk_pid, task->tk_status);
- 
  	/*
  	 * ->write_done will attempt to use post-op attributes to detect
  	 * conflicting writes by other clients.  A strict interpretation
@@@ -1974,3 -1893,11 +1989,14 @@@ void nfs_destroy_writepagecache(void
  	kmem_cache_destroy(nfs_wdata_cachep);
  }
  
++<<<<<<< HEAD
++=======
+ static const struct nfs_rw_ops nfs_rw_write_ops = {
+ 	.rw_mode		= FMODE_WRITE,
+ 	.rw_alloc_header	= nfs_writehdr_alloc,
+ 	.rw_free_header		= nfs_writehdr_free,
+ 	.rw_release		= nfs_writeback_release_common,
+ 	.rw_done		= nfs_writeback_done,
+ 	.rw_result		= nfs_writeback_result,
+ };
++>>>>>>> 0eecb2145c1c (NFS: Create a common nfs_pgio_result_common function)
diff --cc include/linux/nfs_fs.h
index e8e81176df65,919576b8e2cf..000000000000
--- a/include/linux/nfs_fs.h
+++ b/include/linux/nfs_fs.h
@@@ -519,7 -520,6 +519,10 @@@ extern int  nfs_writepage(struct page *
  extern int  nfs_writepages(struct address_space *, struct writeback_control *);
  extern int  nfs_flush_incompatible(struct file *file, struct page *page);
  extern int  nfs_updatepage(struct file *, struct page *, unsigned int, unsigned int);
++<<<<<<< HEAD
 +extern void nfs_writeback_done(struct rpc_task *, struct nfs_write_data *);
++=======
++>>>>>>> 0eecb2145c1c (NFS: Create a common nfs_pgio_result_common function)
  
  /*
   * Try to write back everything synchronously (but check the
@@@ -552,7 -552,6 +555,10 @@@ nfs_have_writebacks(struct inode *inode
  extern int  nfs_readpage(struct file *, struct page *);
  extern int  nfs_readpages(struct file *, struct address_space *,
  		struct list_head *, unsigned);
++<<<<<<< HEAD
 +extern int  nfs_readpage_result(struct rpc_task *, struct nfs_read_data *);
++=======
++>>>>>>> 0eecb2145c1c (NFS: Create a common nfs_pgio_result_common function)
  extern int  nfs_readpage_async(struct nfs_open_context *, struct inode *,
  			       struct page *);
  
diff --cc include/linux/nfs_page.h
index 92ce5783b707,01aa29c5ec42..000000000000
--- a/include/linux/nfs_page.h
+++ b/include/linux/nfs_page.h
@@@ -52,6 -52,15 +52,18 @@@ struct nfs_pageio_ops 
  	int	(*pg_doio)(struct nfs_pageio_descriptor *);
  };
  
++<<<<<<< HEAD
++=======
+ struct nfs_rw_ops {
+ 	const fmode_t rw_mode;
+ 	struct nfs_rw_header *(*rw_alloc_header)(void);
+ 	void (*rw_free_header)(struct nfs_rw_header *);
+ 	void (*rw_release)(struct nfs_pgio_data *);
+ 	int  (*rw_done)(struct rpc_task *, struct nfs_pgio_data *, struct inode *);
+ 	void (*rw_result)(struct rpc_task *, struct nfs_pgio_data *);
+ };
+ 
++>>>>>>> 0eecb2145c1c (NFS: Create a common nfs_pgio_result_common function)
  struct nfs_pageio_descriptor {
  	struct list_head	pg_list;
  	unsigned long		pg_bytes_written;
* Unmerged path fs/nfs/internal.h
diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c
index 2ffebf2081ce..83da8405f1f7 100644
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@ -24,6 +24,8 @@
 #include "internal.h"
 #include "pnfs.h"
 
+#define NFSDBG_FACILITY		NFSDBG_PAGECACHE
+
 static struct kmem_cache *nfs_page_cachep;
 
 bool nfs_pgarray_set(struct nfs_page_array *p, unsigned int pagecount)
@@ -328,6 +330,27 @@ void nfs_pageio_init(struct nfs_pageio_descriptor *desc,
 }
 EXPORT_SYMBOL_GPL(nfs_pageio_init);
 
+/**
+ * nfs_pgio_result - Basic pageio error handling
+ * @task: The task that ran
+ * @calldata: Pageio data to check
+ */
+void nfs_pgio_result(struct rpc_task *task, void *calldata)
+{
+	struct nfs_pgio_data *data = calldata;
+	struct inode *inode = data->header->inode;
+
+	dprintk("NFS: %s: %5u, (status %d)\n", __func__,
+		task->tk_pid, task->tk_status);
+
+	if (data->header->rw_ops->rw_done(task, data, inode) != 0)
+		return;
+	if (task->tk_status < 0)
+		nfs_set_pgio_error(data->header, task->tk_status, data->args.offset);
+	else
+		data->header->rw_ops->rw_result(task, data);
+}
+
 static bool nfs_match_open_context(const struct nfs_open_context *ctx1,
 		const struct nfs_open_context *ctx2)
 {
* Unmerged path fs/nfs/read.c
* Unmerged path fs/nfs/write.c
* Unmerged path include/linux/nfs_fs.h
* Unmerged path include/linux/nfs_page.h
