iw_cxgb4: fix for 64-bit integer division

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [infiniband] cxgb4: fix for 64-bit integer division (Sai Vemuri) [1124947]
Rebuild_FUZZ: 96.20%
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit da388973d4a15e71cada1219d625b5393c90e5ae
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/da388973.failed

Fixed error introduced in commit id 7730b4c (" cxgb4/iw_cxgb4: work request
logging feature") while compiling on 32 bit architecture reported by kbuild.

	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit da388973d4a15e71cada1219d625b5393c90e5ae)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/device.c
diff --cc drivers/infiniband/hw/cxgb4/device.c
index 2b0fdad02d90,03b6fa1291bf..000000000000
--- a/drivers/infiniband/hw/cxgb4/device.c
+++ b/drivers/infiniband/hw/cxgb4/device.c
@@@ -103,6 -113,117 +104,120 @@@ static ssize_t debugfs_read(struct fil
  	return simple_read_from_buffer(buf, count, ppos, d->buf, d->pos);
  }
  
++<<<<<<< HEAD
++=======
+ void c4iw_log_wr_stats(struct t4_wq *wq, struct t4_cqe *cqe)
+ {
+ 	struct wr_log_entry le;
+ 	int idx;
+ 
+ 	if (!wq->rdev->wr_log)
+ 		return;
+ 
+ 	idx = (atomic_inc_return(&wq->rdev->wr_log_idx) - 1) &
+ 		(wq->rdev->wr_log_size - 1);
+ 	le.poll_sge_ts = cxgb4_read_sge_timestamp(wq->rdev->lldi.ports[0]);
+ 	getnstimeofday(&le.poll_host_ts);
+ 	le.valid = 1;
+ 	le.cqe_sge_ts = CQE_TS(cqe);
+ 	if (SQ_TYPE(cqe)) {
+ 		le.qid = wq->sq.qid;
+ 		le.opcode = CQE_OPCODE(cqe);
+ 		le.post_host_ts = wq->sq.sw_sq[wq->sq.cidx].host_ts;
+ 		le.post_sge_ts = wq->sq.sw_sq[wq->sq.cidx].sge_ts;
+ 		le.wr_id = CQE_WRID_SQ_IDX(cqe);
+ 	} else {
+ 		le.qid = wq->rq.qid;
+ 		le.opcode = FW_RI_RECEIVE;
+ 		le.post_host_ts = wq->rq.sw_rq[wq->rq.cidx].host_ts;
+ 		le.post_sge_ts = wq->rq.sw_rq[wq->rq.cidx].sge_ts;
+ 		le.wr_id = CQE_WRID_MSN(cqe);
+ 	}
+ 	wq->rdev->wr_log[idx] = le;
+ }
+ 
+ static int wr_log_show(struct seq_file *seq, void *v)
+ {
+ 	struct c4iw_dev *dev = seq->private;
+ 	struct timespec prev_ts = {0, 0};
+ 	struct wr_log_entry *lep;
+ 	int prev_ts_set = 0;
+ 	int idx, end;
+ 
+ #define ts2ns(ts) div64_ul((ts) * dev->rdev.lldi.cclk_ps, 1000)
+ 
+ 	idx = atomic_read(&dev->rdev.wr_log_idx) &
+ 		(dev->rdev.wr_log_size - 1);
+ 	end = idx - 1;
+ 	if (end < 0)
+ 		end = dev->rdev.wr_log_size - 1;
+ 	lep = &dev->rdev.wr_log[idx];
+ 	while (idx != end) {
+ 		if (lep->valid) {
+ 			if (!prev_ts_set) {
+ 				prev_ts_set = 1;
+ 				prev_ts = lep->poll_host_ts;
+ 			}
+ 			seq_printf(seq, "%04u: sec %lu nsec %lu qid %u opcode "
+ 				   "%u %s 0x%x host_wr_delta sec %lu nsec %lu "
+ 				   "post_sge_ts 0x%llx cqe_sge_ts 0x%llx "
+ 				   "poll_sge_ts 0x%llx post_poll_delta_ns %llu "
+ 				   "cqe_poll_delta_ns %llu\n",
+ 				   idx,
+ 				   timespec_sub(lep->poll_host_ts,
+ 						prev_ts).tv_sec,
+ 				   timespec_sub(lep->poll_host_ts,
+ 						prev_ts).tv_nsec,
+ 				   lep->qid, lep->opcode,
+ 				   lep->opcode == FW_RI_RECEIVE ?
+ 							"msn" : "wrid",
+ 				   lep->wr_id,
+ 				   timespec_sub(lep->poll_host_ts,
+ 						lep->post_host_ts).tv_sec,
+ 				   timespec_sub(lep->poll_host_ts,
+ 						lep->post_host_ts).tv_nsec,
+ 				   lep->post_sge_ts, lep->cqe_sge_ts,
+ 				   lep->poll_sge_ts,
+ 				   ts2ns(lep->poll_sge_ts - lep->post_sge_ts),
+ 				   ts2ns(lep->poll_sge_ts - lep->cqe_sge_ts));
+ 			prev_ts = lep->poll_host_ts;
+ 		}
+ 		idx++;
+ 		if (idx > (dev->rdev.wr_log_size - 1))
+ 			idx = 0;
+ 		lep = &dev->rdev.wr_log[idx];
+ 	}
+ #undef ts2ns
+ 	return 0;
+ }
+ 
+ static int wr_log_open(struct inode *inode, struct file *file)
+ {
+ 	return single_open(file, wr_log_show, inode->i_private);
+ }
+ 
+ static ssize_t wr_log_clear(struct file *file, const char __user *buf,
+ 			    size_t count, loff_t *pos)
+ {
+ 	struct c4iw_dev *dev = ((struct seq_file *)file->private_data)->private;
+ 	int i;
+ 
+ 	if (dev->rdev.wr_log)
+ 		for (i = 0; i < dev->rdev.wr_log_size; i++)
+ 			dev->rdev.wr_log[i].valid = 0;
+ 	return count;
+ }
+ 
+ static const struct file_operations wr_log_debugfs_fops = {
+ 	.owner   = THIS_MODULE,
+ 	.open    = wr_log_open,
+ 	.release = single_release,
+ 	.read    = seq_read,
+ 	.llseek  = seq_lseek,
+ 	.write   = wr_log_clear,
+ };
+ 
++>>>>>>> da388973d4a1 (iw_cxgb4: fix for 64-bit integer division)
  static int dump_qp(int id, void *p, void *data)
  {
  	struct c4iw_qp *qp = p;
* Unmerged path drivers/infiniband/hw/cxgb4/device.c
