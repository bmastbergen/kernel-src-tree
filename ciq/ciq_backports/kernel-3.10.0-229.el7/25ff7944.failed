of: implement pci_address_to_pio as weak function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Rob Herring <rob.herring@calxeda.com>
commit 25ff79443cbfa924b8df1d4a8a0fbff83816938a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/25ff7944.failed

Implement pci_address_to_pio as weak function to remove the dependency on
asm/prom.h. This is in preparation to make prom.h optional.

	Signed-off-by: Rob Herring <rob.herring@calxeda.com>
	Acked-by: Grant Likely <grant.likely@linaro.org>
	Cc: Michal Simek <monstr@monstr.eu>
	Cc: Ralf Baechle <ralf@linux-mips.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: x86@kernel.org
	Cc: Grant Likely <grant.likely@linaro.org>
(cherry picked from commit 25ff79443cbfa924b8df1d4a8a0fbff83816938a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/microblaze/include/asm/prom.h
diff --cc arch/microblaze/include/asm/prom.h
index 20c5e8e5121b,0ebd924902df..000000000000
--- a/arch/microblaze/include/asm/prom.h
+++ b/arch/microblaze/include/asm/prom.h
@@@ -33,35 -26,4 +33,38 @@@ enum early_consoles 
  
  extern int of_early_console(void *version);
  
++<<<<<<< HEAD
 +/*
 + * OF address retreival & translation
 + */
 +
 +#ifdef CONFIG_PCI
 +extern unsigned long pci_address_to_pio(phys_addr_t address);
 +#define pci_address_to_pio pci_address_to_pio
 +#endif	/* CONFIG_PCI */
 +
 +/* Parse the ibm,dma-window property of an OF node into the busno, phys and
 + * size parameters.
 + */
 +void of_parse_dma_window(struct device_node *dn, const void *dma_window_prop,
 +		unsigned long *busno, unsigned long *phys, unsigned long *size);
 +
 +extern void kdump_move_device_tree(void);
 +
 +/* CPU OF node matching */
 +struct device_node *of_get_cpu_node(int cpu, unsigned int *thread);
 +
 +#endif /* __ASSEMBLY__ */
 +#endif /* __KERNEL__ */
 +
 +/* These includes are put at the bottom because they may contain things
 + * that are overridden by this file.  Ideally they shouldn't be included
 + * by this file, but there are a bunch of .c files that currently depend
 + * on it.  Eventually they will be cleaned up. */
 +#include <linux/of_fdt.h>
 +#include <linux/of_irq.h>
 +#include <linux/platform_device.h>
 +
++=======
++>>>>>>> 25ff79443cbf (of: implement pci_address_to_pio as weak function)
  #endif /* _ASM_MICROBLAZE_PROM_H */
* Unmerged path arch/microblaze/include/asm/prom.h
diff --git a/arch/mips/include/asm/prom.h b/arch/mips/include/asm/prom.h
index 1e7e0961064b..a7b28f507737 100644
--- a/arch/mips/include/asm/prom.h
+++ b/arch/mips/include/asm/prom.h
@@ -22,17 +22,6 @@ extern int early_init_dt_scan_memory_arch(unsigned long node,
 
 extern void device_tree_init(void);
 
-static inline unsigned long pci_address_to_pio(phys_addr_t address)
-{
-	/*
-	 * The ioport address can be directly used by inX() / outX()
-	 */
-	BUG_ON(address > IO_SPACE_LIMIT);
-
-	return (unsigned long) address;
-}
-#define pci_address_to_pio pci_address_to_pio
-
 struct boot_param_header;
 
 extern void __dt_setup_arch(struct boot_param_header *bph);
diff --git a/arch/powerpc/include/asm/prom.h b/arch/powerpc/include/asm/prom.h
index e6ec2cffba16..eb8be1a9b873 100644
--- a/arch/powerpc/include/asm/prom.h
+++ b/arch/powerpc/include/asm/prom.h
@@ -30,11 +30,6 @@
 extern u64 of_translate_dma_address(struct device_node *dev,
 				    const __be32 *in_addr);
 
-#ifdef CONFIG_PCI
-extern unsigned long pci_address_to_pio(phys_addr_t address);
-#define pci_address_to_pio pci_address_to_pio
-#endif	/* CONFIG_PCI */
-
 /* Parse the ibm,dma-window property of an OF node into the busno, phys and
  * size parameters.
  */
diff --git a/arch/x86/include/asm/prom.h b/arch/x86/include/asm/prom.h
index 60bef663609a..50cb83c43a5a 100644
--- a/arch/x86/include/asm/prom.h
+++ b/arch/x86/include/asm/prom.h
@@ -39,9 +39,6 @@ static inline void x86_dtb_init(void) { }
 
 extern char cmd_line[COMMAND_LINE_SIZE];
 
-#define pci_address_to_pio pci_address_to_pio
-unsigned long pci_address_to_pio(phys_addr_t addr);
-
 #define HAVE_ARCH_DEVTREE_FIXUPS
 
 #endif /* __ASSEMBLY__ */
diff --git a/arch/x86/kernel/devicetree.c b/arch/x86/kernel/devicetree.c
index b1581527a236..6212861d032d 100644
--- a/arch/x86/kernel/devicetree.c
+++ b/arch/x86/kernel/devicetree.c
@@ -26,16 +26,6 @@ char __initdata cmd_line[COMMAND_LINE_SIZE];
 
 int __initdata of_ioapic;
 
-unsigned long pci_address_to_pio(phys_addr_t address)
-{
-	/*
-	 * The ioport address can be directly used by inX / outX
-	 */
-	BUG_ON(address >= (1 << 16));
-	return (unsigned long)address;
-}
-EXPORT_SYMBOL_GPL(pci_address_to_pio);
-
 void __init early_init_dt_scan_chosen_arch(unsigned long node)
 {
 	BUG();
diff --git a/drivers/of/address.c b/drivers/of/address.c
index 7c8221d36329..0f3c83da2ff6 100644
--- a/drivers/of/address.c
+++ b/drivers/of/address.c
@@ -559,6 +559,14 @@ const __be32 *of_get_address(struct device_node *dev, int index, u64 *size,
 }
 EXPORT_SYMBOL(of_get_address);
 
+unsigned long __weak pci_address_to_pio(phys_addr_t address)
+{
+	if (address > IO_SPACE_LIMIT)
+		return (unsigned long)-1;
+
+	return (unsigned long) address;
+}
+
 static int __of_address_to_resource(struct device_node *dev,
 		const __be32 *addrp, u64 size, unsigned int flags,
 		const char *name, struct resource *r)
diff --git a/drivers/of/of_pci.c b/drivers/of/of_pci.c
index e5ca00893c0c..848199633798 100644
--- a/drivers/of/of_pci.c
+++ b/drivers/of/of_pci.c
@@ -2,7 +2,6 @@
 #include <linux/export.h>
 #include <linux/of.h>
 #include <linux/of_pci.h>
-#include <asm/prom.h>
 
 static inline int __of_pci_pci_compare(struct device_node *node,
 				       unsigned int data)
diff --git a/include/linux/of_address.h b/include/linux/of_address.h
index 0506eb53519b..f9db0258448f 100644
--- a/include/linux/of_address.h
+++ b/include/linux/of_address.h
@@ -22,10 +22,7 @@ extern void __iomem *of_iomap(struct device_node *device, int index);
 extern const __be32 *of_get_address(struct device_node *dev, int index,
 			   u64 *size, unsigned int *flags);
 
-#ifndef pci_address_to_pio
-static inline unsigned long pci_address_to_pio(phys_addr_t addr) { return -1; }
-#define pci_address_to_pio pci_address_to_pio
-#endif
+extern unsigned long pci_address_to_pio(phys_addr_t addr);
 
 #else /* CONFIG_OF_ADDRESS */
 #ifndef of_address_to_resource
