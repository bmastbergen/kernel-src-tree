vfs: rename: use common code for dir and non-dir

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [fs] namei: use common code for dir and non-dir (David Howells) [985875]
Rebuild_FUZZ: 91.11%
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit bc27027a73e8b80376b51a1583ad1c7445605e8a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/bc27027a.failed

There's actually very little difference between vfs_rename_dir() and
vfs_rename_other() so move both inline into vfs_rename() which still stays
reasonably readable.

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
	Reviewed-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit bc27027a73e8b80376b51a1583ad1c7445605e8a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namei.c
diff --cc fs/namei.c
index d87d2e09b208,12b8f56ba942..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -3981,133 -4021,19 +4001,142 @@@ SYSCALL_DEFINE2(link, const char __use
   *	   ->i_mutex on parents, which works but leads to some truly excessive
   *	   locking].
   */
++<<<<<<< HEAD
 +static int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
 +			  struct inode *new_dir, struct dentry *new_dentry)
 +{
 +	int error = 0;
 +	struct inode *target = new_dentry->d_inode;
 +	unsigned max_links = new_dir->i_sb->s_max_links;
 +
 +	/*
 +	 * If we are going to change the parent - check write permissions,
 +	 * we'll need to flip '..'.
 +	 */
 +	if (new_dir != old_dir) {
 +		error = inode_permission(old_dentry->d_inode, MAY_WRITE);
 +		if (error)
 +			return error;
 +	}
 +
 +	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
 +	if (error)
 +		return error;
 +
 +	dget(new_dentry);
 +	if (target)
 +		mutex_lock(&target->i_mutex);
 +
 +	error = -EBUSY;
 +	if (d_mountpoint(old_dentry) || d_mountpoint(new_dentry))
 +		goto out;
 +
 +	error = -EMLINK;
 +	if (max_links && !target && new_dir != old_dir &&
 +	    new_dir->i_nlink >= max_links)
 +		goto out;
 +
 +	if (target)
 +		shrink_dcache_parent(new_dentry);
 +	error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
 +	if (error)
 +		goto out;
 +
 +	if (target) {
 +		target->i_flags |= S_DEAD;
 +		dont_mount(new_dentry);
 +	}
 +out:
 +	if (target)
 +		mutex_unlock(&target->i_mutex);
 +	dput(new_dentry);
 +	if (!error)
 +		if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
 +			d_move(old_dentry,new_dentry);
 +	return error;
 +}
 +
 +static int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
 +			    struct inode *new_dir, struct dentry *new_dentry,
 +			    struct inode **delegated_inode)
 +{
 +	struct inode *target = new_dentry->d_inode;
 +	struct inode *source = old_dentry->d_inode;
 +	int error;
 +
 +	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
 +	if (error)
 +		return error;
 +
 +	dget(new_dentry);
 +	lock_two_nondirectories(source, target);
 +
 +	error = -EBUSY;
 +	if (d_mountpoint(old_dentry)||d_mountpoint(new_dentry))
 +		goto out;
 +
 +	error = try_break_deleg(source, delegated_inode);
 +	if (error)
 +		goto out;
 +	if (target) {
 +		error = try_break_deleg(target, delegated_inode);
 +		if (error)
 +			goto out;
 +	}
 +	error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
 +	if (error)
 +		goto out;
 +
 +	if (target)
 +		dont_mount(new_dentry);
 +	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
 +		d_move(old_dentry, new_dentry);
 +out:
 +	unlock_two_nondirectories(source, target);
 +	dput(new_dentry);
 +	return error;
 +}
 +
 +/**
 + * vfs_rename - rename a filesystem object
 + * @old_dir:	parent of source
 + * @old_dentry:	source
 + * @new_dir:	parent of destination
 + * @new_dentry:	destination
 + * @delegated_inode: returns an inode needing a delegation break
 + *
 + * The caller must hold multiple mutexes--see lock_rename()).
 + *
 + * If vfs_rename discovers a delegation in need of breaking at either
 + * the source or destination, it will return -EWOULDBLOCK and return a
 + * reference to the inode in delegated_inode.  The caller should then
 + * break the delegation and retry.  Because breaking a delegation may
 + * take a long time, the caller should drop all locks before doing
 + * so.
 + *
 + * Alternatively, a caller may pass NULL for delegated_inode.  This may
 + * be appropriate for callers that expect the underlying filesystem not
 + * to be NFS exported.
 + */
++=======
++>>>>>>> bc27027a73e8 (vfs: rename: use common code for dir and non-dir)
  int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
  	       struct inode *new_dir, struct dentry *new_dentry,
  	       struct inode **delegated_inode)
  {
  	int error;
++<<<<<<< HEAD
 +	int is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
++=======
+ 	bool is_dir = d_is_dir(old_dentry);
++>>>>>>> bc27027a73e8 (vfs: rename: use common code for dir and non-dir)
  	const unsigned char *old_name;
+ 	struct inode *source = old_dentry->d_inode;
+ 	struct inode *target = new_dentry->d_inode;
+ 
+ 	if (source == target)
+ 		return 0;
  
- 	if (old_dentry->d_inode == new_dentry->d_inode)
-  		return 0;
-  
  	error = may_delete(old_dir, old_dentry, is_dir);
  	if (error)
  		return error;
* Unmerged path fs/namei.c
