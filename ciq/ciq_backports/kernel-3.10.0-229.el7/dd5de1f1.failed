mei: revamp read and write length checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit dd5de1f165ade430357960459491a067c7e3d21c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/dd5de1f1.failed

1. Return zero on zero length read and writes
2. For a too large write return -EFBIG as defined in man write(2)
EFBIG  An attempt was made to write a file that
        exceeds the implementation-defined maximum
        file size or the process's file size limit,
        or to  write  at  a  position  past  the  maximum
        allowed offset.

	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit dd5de1f165ade430357960459491a067c7e3d21c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/main.c
diff --cc drivers/misc/mei/main.c
index dcdcbf5738d4,7404584e65e1..000000000000
--- a/drivers/misc/mei/main.c
+++ b/drivers/misc/mei/main.c
@@@ -210,18 -210,9 +211,24 @@@ static ssize_t mei_read(struct file *fi
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	if ((cl->sm_state & MEI_WD_STATE_INDEPENDENCE_MSG_SENT) == 0) {
 +		/* Do not allow to read watchdog client */
 +		i = mei_me_cl_by_uuid(dev, &mei_wd_guid);
 +		if (i >= 0) {
 +			struct mei_me_client *me_client = &dev->me_clients[i];
 +			if (cl->me_client_id == me_client->client_id) {
 +				rets = -EBADF;
 +				goto out;
 +			}
 +		}
 +	} else {
 +		cl->sm_state &= ~MEI_WD_STATE_INDEPENDENCE_MSG_SENT;
++=======
+ 	if (length == 0) {
+ 		rets = 0;
+ 		goto out;
++>>>>>>> dd5de1f165ad (mei: revamp read and write length checks)
  	}
  
  	if (cl == &dev->iamthif_cl) {
* Unmerged path drivers/misc/mei/main.c
