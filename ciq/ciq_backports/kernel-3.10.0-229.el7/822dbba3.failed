ext4: fix warning in ext4_evict_inode()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Jan Kara <jack@suse.cz>
commit 822dbba33458cd6ad0e715f3f4a57ebc99d54d1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/822dbba3.failed

The following race can lead to ext4_evict_inode() seeing i_ioend_count
> 0 and thus triggering a sanity check warning:

        CPU1                                    CPU2
ext4_end_bio()                          ext4_evict_inode()
  ext4_finish_bio()
    end_page_writeback();
                                          truncate_inode_pages()
                                            evict page
                                        WARN_ON(i_ioend_count > 0);
  ext4_put_io_end_defer()
    ext4_release_io_end()
      dec i_ioend_count

This is possible use-after-free bug since we decrement i_ioend_count in
possibly released inode.

Since i_ioend_count is used only for sanity checks one possible solution
would be to just remove it but for now I'd like to keep those sanity
checks to help debugging the new ext4 writeback code.

This patch changes ext4_end_bio() to call ext4_put_io_end_defer() before
ext4_finish_bio() in the shortcut case when unwritten extent conversion
isn't needed.  In that case we don't need the io_end so we are safe to
drop it early.

	Reported-by: Guenter Roeck <linux@roeck-us.net>
	Tested-by: Guenter Roeck <linux@roeck-us.net>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
(cherry picked from commit 822dbba33458cd6ad0e715f3f4a57ebc99d54d1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/page-io.c
diff --cc fs/ext4/page-io.c
index 44bfba203e32,d63cc5e9d3b5..000000000000
--- a/fs/ext4/page-io.c
+++ b/fs/ext4/page-io.c
@@@ -254,21 -308,7 +254,25 @@@ ext4_io_end_t *ext4_get_io_end(ext4_io_
  	return io_end;
  }
  
++<<<<<<< HEAD
 +/*
 + * Print an buffer I/O error compatible with the fs/buffer.c.  This
 + * provides compatibility with dmesg scrapers that look for a specific
 + * buffer I/O error message.  We really need a unified error reporting
 + * structure to userspace ala Digital Unix's uerf system, but it's
 + * probably not going to happen in my lifetime, due to LKML politics...
 + */
 +static void buffer_io_error(struct buffer_head *bh)
 +{
 +	char b[BDEVNAME_SIZE];
 +	printk_ratelimited(KERN_ERR "Buffer I/O error on device %s, logical block %llu\n",
 +			bdevname(bh->b_bdev, b),
 +			(unsigned long long)bh->b_blocknr);
 +}
 +
++=======
+ /* BIO completion function for page writeback */
++>>>>>>> 822dbba33458 (ext4: fix warning in ext4_evict_inode())
  static void ext4_end_bio(struct bio *bio, int error)
  {
  	ext4_io_end_t *io_end = bio->bi_private;
@@@ -284,49 -318,10 +288,52 @@@
  	bio->bi_end_io = NULL;
  	if (test_bit(BIO_UPTODATE, &bio->bi_flags))
  		error = 0;
 +	for (i = 0; i < bio->bi_vcnt; i++) {
 +		struct bio_vec *bvec = &bio->bi_io_vec[i];
 +		struct page *page = bvec->bv_page;
 +		struct buffer_head *bh, *head;
 +		unsigned bio_start = bvec->bv_offset;
 +		unsigned bio_end = bio_start + bvec->bv_len;
 +		unsigned under_io = 0;
 +		unsigned long flags;
  
 -	if (error) {
 -		struct inode *inode = io_end->inode;
++<<<<<<< HEAD
 +		if (!page)
 +			continue;
  
 +		if (error) {
 +			SetPageError(page);
 +			set_bit(AS_EIO, &page->mapping->flags);
 +		}
 +		bh = head = page_buffers(page);
 +		/*
 +		 * We check all buffers in the page under BH_Uptodate_Lock
 +		 * to avoid races with other end io clearing async_write flags
 +		 */
 +		local_irq_save(flags);
 +		bit_spin_lock(BH_Uptodate_Lock, &head->b_state);
 +		do {
 +			if (bh_offset(bh) < bio_start ||
 +			    bh_offset(bh) + blocksize > bio_end) {
 +				if (buffer_async_write(bh))
 +					under_io++;
 +				continue;
 +			}
 +			clear_buffer_async_write(bh);
 +			if (error)
 +				buffer_io_error(bh);
 +		} while ((bh = bh->b_this_page) != head);
 +		bit_spin_unlock(BH_Uptodate_Lock, &head->b_state);
 +		local_irq_restore(flags);
 +		if (!under_io)
 +			end_page_writeback(page);
 +	}
 +	bio_put(bio);
 +
++=======
++>>>>>>> 822dbba33458 (ext4: fix warning in ext4_evict_inode())
 +	if (error) {
 +		io_end->flag |= EXT4_IO_END_ERROR;
  		ext4_warning(inode->i_sb, "I/O error writing to inode %lu "
  			     "(offset %llu size %ld starting block %llu)",
  			     inode->i_ino,
@@@ -336,7 -331,23 +343,27 @@@
  			     bi_sector >> (inode->i_blkbits - 9));
  	}
  
++<<<<<<< HEAD
 +	ext4_put_io_end_defer(io_end);
++=======
+ 	if (io_end->flag & EXT4_IO_END_UNWRITTEN) {
+ 		/*
+ 		 * Link bio into list hanging from io_end. We have to do it
+ 		 * atomically as bio completions can be racing against each
+ 		 * other.
+ 		 */
+ 		bio->bi_private = xchg(&io_end->bio, bio);
+ 		ext4_put_io_end_defer(io_end);
+ 	} else {
+ 		/*
+ 		 * Drop io_end reference early. Inode can get freed once
+ 		 * we finish the bio.
+ 		 */
+ 		ext4_put_io_end_defer(io_end);
+ 		ext4_finish_bio(bio);
+ 		bio_put(bio);
+ 	}
++>>>>>>> 822dbba33458 (ext4: fix warning in ext4_evict_inode())
  }
  
  void ext4_io_submit(struct ext4_io_submit *io)
* Unmerged path fs/ext4/page-io.c
