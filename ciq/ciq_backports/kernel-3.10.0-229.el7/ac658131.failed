cpufreq: intel_pstate: Keep values in aperf/mperf in full precision

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] intel_pstate: Keep values in aperf/mperf in full precision (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 92.80%
commit-author Stratos Karafotis <stratosk@semaphore.gr>
commit ac658131d79e775efb0b819cc5a833e581d4de28
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/ac658131.failed

Currently we shift right aperf and mperf variables by FRAC_BITS
to prevent overflow when we convert them to fix point numbers
(shift left by FRAC_BITS).

But this is not necessary, because we actually use delta aperf and mperf
which are much less than APERF and MPERF values.

So, use the unmodified APERF and MPERF values in calculation.
This also adds 8 bits in precision, although the gain is insignificant.

	Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
	Signed-off-by: Dirk Brandewie <dirk.j.brandewie@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit ac658131d79e775efb0b819cc5a833e581d4de28)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index 2b1afcf7461b,129ffb2853dc..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -581,9 -584,8 +581,14 @@@ static inline void intel_pstate_sample(
  	rdmsrl(MSR_IA32_MPERF, mperf);
  	local_irq_restore(flags);
  
++<<<<<<< HEAD
 +	aperf = aperf >> FRAC_BITS;
 +	mperf = mperf >> FRAC_BITS;
 +
++=======
+ 	cpu->last_sample_time = cpu->sample.time;
+ 	cpu->sample.time = ktime_get();
++>>>>>>> ac658131d79e (cpufreq: intel_pstate: Keep values in aperf/mperf in full precision)
  	cpu->sample.aperf = aperf;
  	cpu->sample.mperf = mperf;
  	cpu->sample.aperf -= cpu->prev_aperf;
* Unmerged path drivers/cpufreq/intel_pstate.c
