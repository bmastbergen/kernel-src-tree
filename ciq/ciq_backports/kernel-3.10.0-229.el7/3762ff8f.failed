enic: Add ethtool support to show classifier filters added by the driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Govindarajulu Varadarajan <_govind@gmx.com>
commit 3762ff8f0e95f50f78d94e3f62e839103d1303aa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3762ff8f.failed

This patch impliments ethtool_ops->get_rxnfc() to display the classifier
filter added by the driver.

	Signed-off-by: Govindarajulu Varadarajan <_govind@gmx.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3762ff8f0e95f50f78d94e3f62e839103d1303aa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/cisco/enic/enic_clsf.c
#	drivers/net/ethernet/cisco/enic/enic_clsf.h
diff --cc drivers/net/ethernet/cisco/enic/enic_clsf.c
index 4dbdcfb81638,69dfd3c9e529..000000000000
--- a/drivers/net/ethernet/cisco/enic/enic_clsf.c
+++ b/drivers/net/ethernet/cisco/enic/enic_clsf.c
@@@ -65,6 -65,62 +65,65 @@@ int enic_delfltr(struct enic *enic, u1
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /* enic_rfs_flw_tbl_init - initialize enic->rfs_h members
+  *	@enic: enic data
+  */
+ void enic_rfs_flw_tbl_init(struct enic *enic)
+ {
+ 	int i;
+ 
+ 	spin_lock_init(&enic->rfs_h.lock);
+ 	for (i = 0; i <= ENIC_RFS_FLW_MASK; i++)
+ 		INIT_HLIST_HEAD(&enic->rfs_h.ht_head[i]);
+ 	enic->rfs_h.max = enic->config.num_arfs;
+ 	enic->rfs_h.free = enic->rfs_h.max;
+ 	enic->rfs_h.toclean = 0;
+ 	enic_rfs_timer_start(enic);
+ }
+ 
+ void enic_rfs_flw_tbl_free(struct enic *enic)
+ {
+ 	int i;
+ 
+ 	enic_rfs_timer_stop(enic);
+ 	spin_lock(&enic->rfs_h.lock);
+ 	enic->rfs_h.free = 0;
+ 	for (i = 0; i < (1 << ENIC_RFS_FLW_BITSHIFT); i++) {
+ 		struct hlist_head *hhead;
+ 		struct hlist_node *tmp;
+ 		struct enic_rfs_fltr_node *n;
+ 
+ 		hhead = &enic->rfs_h.ht_head[i];
+ 		hlist_for_each_entry_safe(n, tmp, hhead, node) {
+ 			enic_delfltr(enic, n->fltr_id);
+ 			hlist_del(&n->node);
+ 			kfree(n);
+ 		}
+ 	}
+ 	spin_unlock(&enic->rfs_h.lock);
+ }
+ 
+ struct enic_rfs_fltr_node *htbl_fltr_search(struct enic *enic, u16 fltr_id)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < (1 << ENIC_RFS_FLW_BITSHIFT); i++) {
+ 		struct hlist_head *hhead;
+ 		struct hlist_node *tmp;
+ 		struct enic_rfs_fltr_node *n;
+ 
+ 		hhead = &enic->rfs_h.ht_head[i];
+ 		hlist_for_each_entry_safe(n, tmp, hhead, node)
+ 			if (n->fltr_id == fltr_id)
+ 				return n;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
++>>>>>>> 3762ff8f0e95 (enic: Add ethtool support to show classifier filters added by the driver)
  #ifdef CONFIG_RFS_ACCEL
  void enic_flow_may_expire(unsigned long data)
  {
diff --cc drivers/net/ethernet/cisco/enic/enic_clsf.h
index d572704cd117,6aa9f89d073b..000000000000
--- a/drivers/net/ethernet/cisco/enic/enic_clsf.h
+++ b/drivers/net/ethernet/cisco/enic/enic_clsf.h
@@@ -8,15 -8,30 +8,21 @@@
  
  int enic_addfltr_5t(struct enic *enic, struct flow_keys *keys, u16 rq);
  int enic_delfltr(struct enic *enic, u16 filter_id);
++<<<<<<< HEAD
++=======
+ void enic_rfs_flw_tbl_init(struct enic *enic);
+ void enic_rfs_flw_tbl_free(struct enic *enic);
+ struct enic_rfs_fltr_node *htbl_fltr_search(struct enic *enic, u16 fltr_id);
++>>>>>>> 3762ff8f0e95 (enic: Add ethtool support to show classifier filters added by the driver)
  
  #ifdef CONFIG_RFS_ACCEL
 +void enic_rfs_flw_tbl_init(struct enic *enic);
 +void enic_rfs_flw_tbl_free(struct enic *enic);
  int enic_rx_flow_steer(struct net_device *dev, const struct sk_buff *skb,
  		       u16 rxq_index, u32 flow_id);
 -void enic_flow_may_expire(unsigned long data);
 -
 -static inline void enic_rfs_timer_start(struct enic *enic)
 -{
 -	init_timer(&enic->rfs_h.rfs_may_expire);
 -	enic->rfs_h.rfs_may_expire.function = enic_flow_may_expire;
 -	enic->rfs_h.rfs_may_expire.data = (unsigned long)enic;
 -	mod_timer(&enic->rfs_h.rfs_may_expire, jiffies + HZ/4);
 -}
 -
 -static inline void enic_rfs_timer_stop(struct enic *enic)
 -{
 -	del_timer_sync(&enic->rfs_h.rfs_may_expire);
 -}
  #else
 -static inline void enic_rfs_timer_start(struct enic *enic) {}
 -static inline void enic_rfs_timer_stop(struct enic *enic) {}
 +static inline void enic_rfs_flw_tbl_init(struct enic *enic) {}
 +static inline void enic_rfs_flw_tbl_free(struct enic *enic) {}
  #endif /* CONFIG_RFS_ACCEL */
  
  #endif /* _ENIC_CLSF_H_ */
* Unmerged path drivers/net/ethernet/cisco/enic/enic_clsf.c
* Unmerged path drivers/net/ethernet/cisco/enic/enic_clsf.h
diff --git a/drivers/net/ethernet/cisco/enic/enic_ethtool.c b/drivers/net/ethernet/cisco/enic/enic_ethtool.c
index 6a5d7b51a23a..9ac699d61743 100644
--- a/drivers/net/ethernet/cisco/enic/enic_ethtool.c
+++ b/drivers/net/ethernet/cisco/enic/enic_ethtool.c
@@ -22,6 +22,7 @@
 #include "enic_res.h"
 #include "enic.h"
 #include "enic_dev.h"
+#include "enic_clsf.h"
 
 struct enic_stat {
 	char name[ETH_GSTRING_LEN];
@@ -282,6 +283,102 @@ static int enic_set_coalesce(struct net_device *netdev,
 	return 0;
 }
 
+static int enic_grxclsrlall(struct enic *enic, struct ethtool_rxnfc *cmd,
+			    u32 *rule_locs)
+{
+	int j, ret = 0, cnt = 0;
+
+	cmd->data = enic->rfs_h.max - enic->rfs_h.free;
+	for (j = 0; j < (1 << ENIC_RFS_FLW_BITSHIFT); j++) {
+		struct hlist_head *hhead;
+		struct hlist_node *tmp;
+		struct enic_rfs_fltr_node *n;
+
+		hhead = &enic->rfs_h.ht_head[j];
+		hlist_for_each_entry_safe(n, tmp, hhead, node) {
+			if (cnt == cmd->rule_cnt)
+				return -EMSGSIZE;
+			rule_locs[cnt] = n->fltr_id;
+			cnt++;
+		}
+	}
+	cmd->rule_cnt = cnt;
+
+	return ret;
+}
+
+static int enic_grxclsrule(struct enic *enic, struct ethtool_rxnfc *cmd)
+{
+	struct ethtool_rx_flow_spec *fsp =
+				(struct ethtool_rx_flow_spec *)&cmd->fs;
+	struct enic_rfs_fltr_node *n;
+
+	n = htbl_fltr_search(enic, (u16)fsp->location);
+	if (!n)
+		return -EINVAL;
+	switch (n->keys.ip_proto) {
+	case IPPROTO_TCP:
+		fsp->flow_type = TCP_V4_FLOW;
+		break;
+	case IPPROTO_UDP:
+		fsp->flow_type = UDP_V4_FLOW;
+		break;
+	default:
+		return -EINVAL;
+		break;
+	}
+
+	fsp->h_u.tcp_ip4_spec.ip4src = n->keys.src;
+	fsp->m_u.tcp_ip4_spec.ip4src = (__u32)~0;
+
+	fsp->h_u.tcp_ip4_spec.ip4dst = n->keys.dst;
+	fsp->m_u.tcp_ip4_spec.ip4dst = (__u32)~0;
+
+	fsp->h_u.tcp_ip4_spec.psrc = n->keys.port16[0];
+	fsp->m_u.tcp_ip4_spec.psrc = (__u16)~0;
+
+	fsp->h_u.tcp_ip4_spec.pdst = n->keys.port16[1];
+	fsp->m_u.tcp_ip4_spec.pdst = (__u16)~0;
+
+	fsp->ring_cookie = n->rq_id;
+
+	return 0;
+}
+
+static int enic_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
+			  u32 *rule_locs)
+{
+	struct enic *enic = netdev_priv(dev);
+	int ret = 0;
+
+	switch (cmd->cmd) {
+	case ETHTOOL_GRXRINGS:
+		cmd->data = enic->rq_count;
+		break;
+	case ETHTOOL_GRXCLSRLCNT:
+		spin_lock_bh(&enic->rfs_h.lock);
+		cmd->rule_cnt = enic->rfs_h.max - enic->rfs_h.free;
+		cmd->data = enic->rfs_h.max;
+		spin_unlock_bh(&enic->rfs_h.lock);
+		break;
+	case ETHTOOL_GRXCLSRLALL:
+		spin_lock_bh(&enic->rfs_h.lock);
+		ret = enic_grxclsrlall(enic, cmd, rule_locs);
+		spin_unlock_bh(&enic->rfs_h.lock);
+		break;
+	case ETHTOOL_GRXCLSRULE:
+		spin_lock_bh(&enic->rfs_h.lock);
+		ret = enic_grxclsrule(enic, cmd);
+		spin_unlock_bh(&enic->rfs_h.lock);
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	return ret;
+}
+
 static const struct ethtool_ops enic_ethtool_ops = {
 	.get_settings = enic_get_settings,
 	.get_drvinfo = enic_get_drvinfo,
@@ -293,6 +390,7 @@ static const struct ethtool_ops enic_ethtool_ops = {
 	.get_ethtool_stats = enic_get_ethtool_stats,
 	.get_coalesce = enic_get_coalesce,
 	.set_coalesce = enic_set_coalesce,
+	.get_rxnfc = enic_get_rxnfc,
 };
 
 void enic_set_ethtool_ops(struct net_device *netdev)
