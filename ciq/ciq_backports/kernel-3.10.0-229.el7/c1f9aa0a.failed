perf tools: Add dso__data_* interface descriptons

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf: Add dso__data_* interface descriptons (Jiri Olsa) [1134356]
Rebuild_FUZZ: 93.48%
commit-author Jiri Olsa <jolsa@kernel.org>
commit c1f9aa0a61bde512a68060883d1c3c1955a546ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/c1f9aa0a.failed

Adding descriptions/explanations for dso__data_* interface
functions.

	Acked-by: Namhyung Kim <namhyung@kernel.org>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Jean Pihet <jean.pihet@linaro.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1401892622-30848-10-git-send-email-jolsa@kernel.org
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
(cherry picked from commit c1f9aa0a61bde512a68060883d1c3c1955a546ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/dso.c
diff --cc tools/perf/util/dso.c
index ffd3d5ede878,819f10414f08..000000000000
--- a/tools/perf/util/dso.c
+++ b/tools/perf/util/dso.c
@@@ -159,6 -203,125 +159,128 @@@ static int open_dso(struct dso *dso, st
  	return fd;
  }
  
++<<<<<<< HEAD
++=======
+ static void check_data_close(void);
+ 
+ /**
+  * dso_close - Open DSO data file
+  * @dso: dso object
+  *
+  * Open @dso's data file descriptor and updates
+  * list/count of open DSO objects.
+  */
+ static int open_dso(struct dso *dso, struct machine *machine)
+ {
+ 	int fd = __open_dso(dso, machine);
+ 
+ 	if (fd > 0) {
+ 		dso__list_add(dso);
+ 		/*
+ 		 * Check if we crossed the allowed number
+ 		 * of opened DSOs and close one if needed.
+ 		 */
+ 		check_data_close();
+ 	}
+ 
+ 	return fd;
+ }
+ 
+ static void close_data_fd(struct dso *dso)
+ {
+ 	if (dso->data.fd >= 0) {
+ 		close(dso->data.fd);
+ 		dso->data.fd = -1;
+ 		dso->data.file_size = 0;
+ 		dso__list_del(dso);
+ 	}
+ }
+ 
+ /**
+  * dso_close - Close DSO data file
+  * @dso: dso object
+  *
+  * Close @dso's data file descriptor and updates
+  * list/count of open DSO objects.
+  */
+ static void close_dso(struct dso *dso)
+ {
+ 	close_data_fd(dso);
+ }
+ 
+ static void close_first_dso(void)
+ {
+ 	struct dso *dso;
+ 
+ 	dso = list_first_entry(&dso__data_open, struct dso, data.open_entry);
+ 	close_dso(dso);
+ }
+ 
+ static rlim_t get_fd_limit(void)
+ {
+ 	struct rlimit l;
+ 	rlim_t limit = 0;
+ 
+ 	/* Allow half of the current open fd limit. */
+ 	if (getrlimit(RLIMIT_NOFILE, &l) == 0) {
+ 		if (l.rlim_cur == RLIM_INFINITY)
+ 			limit = l.rlim_cur;
+ 		else
+ 			limit = l.rlim_cur / 2;
+ 	} else {
+ 		pr_err("failed to get fd limit\n");
+ 		limit = 1;
+ 	}
+ 
+ 	return limit;
+ }
+ 
+ static bool may_cache_fd(void)
+ {
+ 	static rlim_t limit;
+ 
+ 	if (!limit)
+ 		limit = get_fd_limit();
+ 
+ 	if (limit == RLIM_INFINITY)
+ 		return true;
+ 
+ 	return limit > (rlim_t) dso__data_open_cnt;
+ }
+ 
+ /*
+  * Check and close LRU dso if we crossed allowed limit
+  * for opened dso file descriptors. The limit is half
+  * of the RLIMIT_NOFILE files opened.
+ */
+ static void check_data_close(void)
+ {
+ 	bool cache_fd = may_cache_fd();
+ 
+ 	if (!cache_fd)
+ 		close_first_dso();
+ }
+ 
+ /**
+  * dso__data_close - Close DSO data file
+  * @dso: dso object
+  *
+  * External interface to close @dso's data file descriptor.
+  */
+ void dso__data_close(struct dso *dso)
+ {
+ 	close_dso(dso);
+ }
+ 
+ /**
+  * dso__data_fd - Get dso's data file descriptor
+  * @dso: dso object
+  * @machine: machine object
+  *
+  * External interface to find dso's file, open it and
+  * returns file descriptor.
+  */
++>>>>>>> c1f9aa0a61bd (perf tools: Add dso__data_* interface descriptons)
  int dso__data_fd(struct dso *dso, struct machine *machine)
  {
  	enum dso_binary_type binary_type_data[] = {
@@@ -315,11 -475,15 +437,20 @@@ static ssize_t dso_cache_read(struct ds
  	if (cache)
  		return dso_cache__memcpy(cache, offset, data, size);
  	else
 -		return dso_cache__read(dso, offset, data, size);
 +		return dso_cache__read(dso, machine, offset, data, size);
  }
  
++<<<<<<< HEAD
 +ssize_t dso__data_read_offset(struct dso *dso, struct machine *machine,
 +			      u64 offset, u8 *data, ssize_t size)
++=======
+ /*
+  * Reads and caches dso data DSO__DATA_CACHE_SIZE size chunks
+  * in the rb_tree. Any read to already cached data is served
+  * by cached data.
+  */
+ static ssize_t cached_read(struct dso *dso, u64 offset, u8 *data, ssize_t size)
++>>>>>>> c1f9aa0a61bd (perf tools: Add dso__data_* interface descriptons)
  {
  	ssize_t r = 0;
  	u8 *p = data;
@@@ -347,6 -511,67 +478,70 @@@
  	return r;
  }
  
++<<<<<<< HEAD
++=======
+ static int data_file_size(struct dso *dso)
+ {
+ 	struct stat st;
+ 
+ 	if (!dso->data.file_size) {
+ 		if (fstat(dso->data.fd, &st)) {
+ 			pr_err("dso mmap failed, fstat: %s\n", strerror(errno));
+ 			return -1;
+ 		}
+ 		dso->data.file_size = st.st_size;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static ssize_t data_read_offset(struct dso *dso, u64 offset,
+ 				u8 *data, ssize_t size)
+ {
+ 	if (data_file_size(dso))
+ 		return -1;
+ 
+ 	/* Check the offset sanity. */
+ 	if (offset > dso->data.file_size)
+ 		return -1;
+ 
+ 	if (offset + size < offset)
+ 		return -1;
+ 
+ 	return cached_read(dso, offset, data, size);
+ }
+ 
+ /**
+  * dso__data_read_offset - Read data from dso file offset
+  * @dso: dso object
+  * @machine: machine object
+  * @offset: file offset
+  * @data: buffer to store data
+  * @size: size of the @data buffer
+  *
+  * External interface to read data from dso file offset. Open
+  * dso data file and use cached_read to get the data.
+  */
+ ssize_t dso__data_read_offset(struct dso *dso, struct machine *machine,
+ 			      u64 offset, u8 *data, ssize_t size)
+ {
+ 	if (dso__data_fd(dso, machine) < 0)
+ 		return -1;
+ 
+ 	return data_read_offset(dso, offset, data, size);
+ }
+ 
+ /**
+  * dso__data_read_addr - Read data from dso address
+  * @dso: dso object
+  * @machine: machine object
+  * @add: virtual memory address
+  * @data: buffer to store data
+  * @size: size of the @data buffer
+  *
+  * External interface to read data from dso address.
+  */
++>>>>>>> c1f9aa0a61bd (perf tools: Add dso__data_* interface descriptons)
  ssize_t dso__data_read_addr(struct dso *dso, struct map *map,
  			    struct machine *machine, u64 addr,
  			    u8 *data, ssize_t size)
* Unmerged path tools/perf/util/dso.c
diff --git a/tools/perf/util/dso.h b/tools/perf/util/dso.h
index 433c80284bd6..0e19c0cd2474 100644
--- a/tools/perf/util/dso.h
+++ b/tools/perf/util/dso.h
@@ -136,6 +136,44 @@ char dso__symtab_origin(const struct dso *dso);
 int dso__binary_type_file(struct dso *dso, enum dso_binary_type type,
 			  char *root_dir, char *file, size_t size);
 
+/*
+ * The dso__data_* external interface provides following functions:
+ *   dso__data_fd
+ *   dso__data_close
+ *   dso__data_read_offset
+ *   dso__data_read_addr
+ *
+ * Please refer to the dso.c object code for each function and
+ * arguments documentation. Following text tries to explain the
+ * dso file descriptor caching.
+ *
+ * The dso__data* interface allows caching of opened file descriptors
+ * to speed up the dso data accesses. The idea is to leave the file
+ * descriptor opened ideally for the whole life of the dso object.
+ *
+ * The current usage of the dso__data_* interface is as follows:
+ *
+ * Get DSO's fd:
+ *   int fd = dso__data_fd(dso, machine);
+ *   USE 'fd' SOMEHOW
+ *
+ * Read DSO's data:
+ *   n = dso__data_read_offset(dso_0, &machine, 0, buf, BUFSIZE);
+ *   n = dso__data_read_addr(dso_0, &machine, 0, buf, BUFSIZE);
+ *
+ * Eventually close DSO's fd:
+ *   dso__data_close(dso);
+ *
+ * It is not necessary to close the DSO object data file. Each time new
+ * DSO data file is opened, the limit (RLIMIT_NOFILE/2) is checked. Once
+ * it is crossed, the oldest opened DSO object is closed.
+ *
+ * The dso__delete function calls close_dso function to ensure the
+ * data file descriptor gets closed/unmapped before the dso object
+ * is freed.
+ *
+ * TODO
+*/
 int dso__data_fd(struct dso *dso, struct machine *machine);
 ssize_t dso__data_read_offset(struct dso *dso, struct machine *machine,
 			      u64 offset, u8 *data, ssize_t size);
