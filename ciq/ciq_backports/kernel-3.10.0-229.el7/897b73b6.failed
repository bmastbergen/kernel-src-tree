xfs: zeroing space needs to punch delalloc blocks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 897b73b6a2ee5d3c06648b601beb1724f7fbd678
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/897b73b6.failed

When we are zeroing space andit is covered by a delalloc range, we
need to punch the delalloc range out before we truncate the page
cache. Failing to do so leaves and inconsistency between the page
cache and the extent tree, which we later trip over when doing
direct IO over the same range.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Tested-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 897b73b6a2ee5d3c06648b601beb1724f7fbd678)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_trace.h
diff --cc fs/xfs/xfs_trace.h
index 6d0671f355d3,65d8c793a25c..000000000000
--- a/fs/xfs/xfs_trace.h
+++ b/fs/xfs/xfs_trace.h
@@@ -603,6 -603,8 +603,11 @@@ DEFINE_INODE_EVENT(xfs_readlink)
  DEFINE_INODE_EVENT(xfs_inactive_symlink);
  DEFINE_INODE_EVENT(xfs_alloc_file_space);
  DEFINE_INODE_EVENT(xfs_free_file_space);
++<<<<<<< HEAD
++=======
+ DEFINE_INODE_EVENT(xfs_zero_file_space);
+ DEFINE_INODE_EVENT(xfs_collapse_file_space);
++>>>>>>> 897b73b6a2ee (xfs: zeroing space needs to punch delalloc blocks)
  DEFINE_INODE_EVENT(xfs_readdir);
  #ifdef CONFIG_XFS_POSIX_ACL
  DEFINE_INODE_EVENT(xfs_get_acl);
diff --git a/fs/xfs/xfs_bmap_util.c b/fs/xfs/xfs_bmap_util.c
index f264616080ca..cfaaf22340a4 100644
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@ -1419,6 +1419,8 @@ xfs_zero_file_space(
 	xfs_off_t		end_boundary;
 	int			error;
 
+	trace_xfs_zero_file_space(ip);
+
 	granularity = max_t(uint, 1 << mp->m_sb.sb_blocklog, PAGE_CACHE_SIZE);
 
 	/*
@@ -1433,9 +1435,18 @@ xfs_zero_file_space(
 	ASSERT(end_boundary <= offset + len);
 
 	if (start_boundary < end_boundary - 1) {
-		/* punch out the page cache over the conversion range */
+		/*
+		 * punch out delayed allocation blocks and the page cache over
+		 * the conversion range
+		 */
+		xfs_ilock(ip, XFS_ILOCK_EXCL);
+		error = xfs_bmap_punch_delalloc_range(ip,
+				XFS_B_TO_FSBT(mp, start_boundary),
+				XFS_B_TO_FSB(mp, end_boundary - start_boundary));
+		xfs_iunlock(ip, XFS_ILOCK_EXCL);
 		truncate_pagecache_range(VFS_I(ip), start_boundary,
 					 end_boundary - 1);
+
 		/* convert the blocks */
 		error = xfs_alloc_file_space(ip, start_boundary,
 					end_boundary - start_boundary - 1,
* Unmerged path fs/xfs/xfs_trace.h
