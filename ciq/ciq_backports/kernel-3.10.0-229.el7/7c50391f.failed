perf top: Convert to hist_entry_iter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf/top: Convert to hist_entry_iter (Jiri Olsa) [1134356]
Rebuild_FUZZ: 97.22%
commit-author Namhyung Kim <namhyung@kernel.org>
commit 7c50391f536ea6ed1e75b0f4d90922a2606da3de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/7c50391f.failed

Reuse hist_entry_iter__add() function to share the similar code with
perf report.  Note that it needs to be called with hists.lock so tweak
some internal functions not to deadlock or hold the lock too long.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Tested-by: Arun Sharma <asharma@fb.com>
	Tested-by: Rodrigo Campos <rodrigo@sdfg.com.ar>
Link: http://lkml.kernel.org/r/1401335910-16832-20-git-send-email-namhyung@kernel.org
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
(cherry picked from commit 7c50391f536ea6ed1e75b0f4d90922a2606da3de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-top.c
diff --cc tools/perf/builtin-top.c
index 610f8ed9ce3e,b1cb5f589ade..000000000000
--- a/tools/perf/builtin-top.c
+++ b/tools/perf/builtin-top.c
@@@ -236,27 -246,6 +244,30 @@@ out_unlock
  	pthread_mutex_unlock(&notes->lock);
  }
  
++<<<<<<< HEAD
 +static struct hist_entry *perf_evsel__add_hist_entry(struct perf_evsel *evsel,
 +						     struct addr_location *al,
 +						     struct perf_sample *sample)
 +{
 +	struct hist_entry *he;
 +
 +	pthread_mutex_lock(&evsel->hists.lock);
 +	he = __hists__add_entry(&evsel->hists, al, NULL, NULL, NULL,
 +				sample->period, sample->weight,
 +				sample->transaction);
 +	pthread_mutex_unlock(&evsel->hists.lock);
 +	if (he == NULL)
 +		return NULL;
 +
 +	hists__inc_nr_events(&evsel->hists, PERF_RECORD_SAMPLE);
 +	if (!he->filtered)
 +		evsel->hists.stats.nr_non_filtered_samples++;
 +
 +	return he;
 +}
 +
++=======
++>>>>>>> 7c50391f536e (perf top: Convert to hist_entry_iter)
  static void perf_top__print_sym_table(struct perf_top *top)
  {
  	char bf[160];
@@@ -744,33 -750,23 +773,47 @@@ static void perf_event__process_sample(
  	}
  
  	if (al.sym == NULL || !al.sym->ignore) {
- 		struct hist_entry *he;
+ 		struct hist_entry_iter iter = {
+ 			.add_entry_cb = hist_iter__top_callback,
+ 		};
  
++<<<<<<< HEAD
 +		if ((sort__has_parent || symbol_conf.use_callchain) &&
 +		    sample->callchain) {
 +			err = machine__resolve_callchain(machine, evsel,
 +							 al.thread, sample,
 +							 &parent, &al,
 +							 PERF_MAX_STACK_DEPTH);
 +			if (err)
 +				return;
 +		}
- 
- 		he = perf_evsel__add_hist_entry(evsel, &al, sample);
- 		if (he == NULL) {
++=======
+ 		if (symbol_conf.cumulate_callchain)
+ 			iter.ops = &hist_iter_cumulative;
+ 		else
+ 			iter.ops = &hist_iter_normal;
++>>>>>>> 7c50391f536e (perf top: Convert to hist_entry_iter)
+ 
+ 		pthread_mutex_lock(&evsel->hists.lock);
+ 
+ 		err = hist_entry_iter__add(&iter, &al, evsel, sample,
+ 					   top->max_stack, top);
+ 		if (err < 0)
  			pr_err("Problem incrementing symbol period, skipping event\n");
- 			return;
- 		}
  
++<<<<<<< HEAD
 +		if (symbol_conf.use_callchain) {
 +			err = callchain_append(he->callchain, &callchain_cursor,
 +					       sample->period);
 +			if (err)
 +				return;
 +		}
 +
 +		if (sort__has_sym)
 +			perf_top__record_precise_ip(top, he, evsel->idx, ip);
++=======
+ 		pthread_mutex_unlock(&evsel->hists.lock);
++>>>>>>> 7c50391f536e (perf top: Convert to hist_entry_iter)
  	}
  
  	return;
* Unmerged path tools/perf/builtin-top.c
