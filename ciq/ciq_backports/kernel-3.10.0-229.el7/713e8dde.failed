ext4: fix ZERO_RANGE bug hidden by flag aliasing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit 713e8dde3e71e92db2d8cc8459d236ce1fb576ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/713e8dde.failed

We accidently aliased EXT4_EX_NOCACHE and EXT4_GET_CONVERT_UNWRITTEN
falgs, which apparently was hiding a bug that was unmasked when this
flag aliasing issue was addressed (see the subsequent commit).  The
reproduction case was:

   fsx -N 10000 -l 500000 -r 4096 -t 4096 -w 4096 -Z -R -W /vdb/junk

... which would cause fsx to report corruption in the data file.

The fix we have is a bit of an overkill, but I'd much rather be
conservative for now, and we can optimize ZERO_RANGE_FL handling
later.  The fact that we need to zap the extent_status cache for the
inode is unfortunate, but correctness is far more important than
performance.

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: Namjae Jeon <namjae.jeon@samsung.com>
(cherry picked from commit 713e8dde3e71e92db2d8cc8459d236ce1fb576ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/extents.c
diff --cc fs/ext4/extents.c
index 05f65d8f9208,bf205f72be35..000000000000
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@@ -4658,20 -4738,148 +4658,146 @@@ retry
  		goto retry;
  	}
  
 -	return ret > 0 ? ret2 : ret;
 -}
 +	handle = ext4_journal_start(inode, EXT4_HT_INODE, 2);
 +	if (IS_ERR(handle))
 +		goto out;
  
 -static long ext4_zero_range(struct file *file, loff_t offset,
 -			    loff_t len, int mode)
 -{
 -	struct inode *inode = file_inode(file);
 -	handle_t *handle = NULL;
 -	unsigned int max_blocks;
 -	loff_t new_size = 0;
 -	int ret = 0;
 -	int flags;
 -	int credits;
 -	int partial_begin, partial_end;
 -	loff_t start, end;
 -	ext4_lblk_t lblk;
 -	struct address_space *mapping = inode->i_mapping;
 -	unsigned int blkbits = inode->i_blkbits;
 +	tv = inode->i_ctime = ext4_current_time(inode);
  
++<<<<<<< HEAD
 +	if (ret > 0 && new_size) {
 +		if (new_size > i_size_read(inode)) {
 +			i_size_write(inode, new_size);
 +			inode->i_mtime = tv;
 +		}
 +		if (new_size > EXT4_I(inode)->i_disksize)
 +			ext4_update_i_disksize(inode, new_size);
 +	} else if (ret > 0 && !new_size) {
++=======
+ 	trace_ext4_zero_range(inode, offset, len, mode);
+ 
+ 	if (!S_ISREG(inode->i_mode))
+ 		return -EINVAL;
+ 
+ 	/* Call ext4_force_commit to flush all data in case of data=journal. */
+ 	if (ext4_should_journal_data(inode)) {
+ 		ret = ext4_force_commit(inode->i_sb);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	/*
+ 	 * Write out all dirty pages to avoid race conditions
+ 	 * Then release them.
+ 	 */
+ 	if (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {
+ 		ret = filemap_write_and_wait_range(mapping, offset,
+ 						   offset + len - 1);
+ 		if (ret)
+ 			return ret;
+ 	}
+ 
+ 	/*
+ 	 * Round up offset. This is not fallocate, we neet to zero out
+ 	 * blocks, so convert interior block aligned part of the range to
+ 	 * unwritten and possibly manually zero out unaligned parts of the
+ 	 * range.
+ 	 */
+ 	start = round_up(offset, 1 << blkbits);
+ 	end = round_down((offset + len), 1 << blkbits);
+ 
+ 	if (start < offset || end > offset + len)
+ 		return -EINVAL;
+ 	partial_begin = offset & ((1 << blkbits) - 1);
+ 	partial_end = (offset + len) & ((1 << blkbits) - 1);
+ 
+ 	lblk = start >> blkbits;
+ 	max_blocks = (end >> blkbits);
+ 	if (max_blocks < lblk)
+ 		max_blocks = 0;
+ 	else
+ 		max_blocks -= lblk;
+ 
+ 	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |
+ 		EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |
+ 		EXT4_EX_NOCACHE;
+ 	if (mode & FALLOC_FL_KEEP_SIZE)
+ 		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;
+ 
+ 	mutex_lock(&inode->i_mutex);
+ 
+ 	/*
+ 	 * Indirect files do not support unwritten extnets
+ 	 */
+ 	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {
+ 		ret = -EOPNOTSUPP;
+ 		goto out_mutex;
+ 	}
+ 
+ 	if (!(mode & FALLOC_FL_KEEP_SIZE) &&
+ 	     offset + len > i_size_read(inode)) {
+ 		new_size = offset + len;
+ 		ret = inode_newsize_ok(inode, new_size);
+ 		if (ret)
+ 			goto out_mutex;
+ 		/*
+ 		 * If we have a partial block after EOF we have to allocate
+ 		 * the entire block.
+ 		 */
+ 		if (partial_end)
+ 			max_blocks += 1;
+ 	}
+ 
+ 	if (max_blocks > 0) {
+ 
+ 		/* Now release the pages and zero block aligned part of pages*/
+ 		truncate_pagecache_range(inode, start, end - 1);
+ 		inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
+ 
+ 		/* Wait all existing dio workers, newcomers will block on i_mutex */
+ 		ext4_inode_block_unlocked_dio(inode);
+ 		inode_dio_wait(inode);
+ 
+ 		ret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,
+ 					     flags, mode);
+ 		if (ret)
+ 			goto out_dio;
+ 		/*
+ 		 * Remove entire range from the extent status tree.
+ 		 *
+ 		 * ext4_es_remove_extent(inode, lblk, max_blocks) is
+ 		 * NOT sufficient.  I'm not sure why this is the case,
+ 		 * but let's be conservative and remove the extent
+ 		 * status tree for the entire inode.  There should be
+ 		 * no outstanding delalloc extents thanks to the
+ 		 * filemap_write_and_wait_range() call above.
+ 		 */
+ 		ret = ext4_es_remove_extent(inode, 0, EXT_MAX_BLOCKS);
+ 		if (ret)
+ 			goto out_dio;
+ 	}
+ 	if (!partial_begin && !partial_end)
+ 		goto out_dio;
+ 
+ 	/*
+ 	 * In worst case we have to writeout two nonadjacent unwritten
+ 	 * blocks and update the inode
+ 	 */
+ 	credits = (2 * ext4_ext_index_trans_blocks(inode, 2)) + 1;
+ 	if (ext4_should_journal_data(inode))
+ 		credits += 2;
+ 	handle = ext4_journal_start(inode, EXT4_HT_MISC, credits);
+ 	if (IS_ERR(handle)) {
+ 		ret = PTR_ERR(handle);
+ 		ext4_std_error(inode->i_sb, ret);
+ 		goto out_dio;
+ 	}
+ 
+ 	inode->i_mtime = inode->i_ctime = ext4_current_time(inode);
+ 	if (new_size) {
+ 		ext4_update_inode_size(inode, new_size);
+ 	} else {
++>>>>>>> 713e8dde3e71 (ext4: fix ZERO_RANGE bug hidden by flag aliasing)
  		/*
  		* Mark that we allocate beyond EOF so the subsequent truncate
  		* can proceed even if the new size is the same as i_size.
* Unmerged path fs/ext4/extents.c
