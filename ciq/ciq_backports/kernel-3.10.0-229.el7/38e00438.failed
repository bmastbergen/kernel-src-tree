i40e: Adds FCoE related code to i40e core driver

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Vasu Dev <vasu.dev@intel.com>
commit 38e004388692f049908636a7944f6cd57d28bd77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/38e00438.failed

Adds FCoE specific code to existing i40e core driver to:-

1. have separate FCoE VSI with additional FCoE queues pairs.
2. have FCoE related hash defines.
3. have additional FCoE related stats code.
4. export and then re-use existing functions required by FCoE build.

	Signed-off-by: Vasu Dev <vasu.dev@intel.com>
	Tested-by: Jack Morgan<jack.morgan@intel.com>
	Signed-off-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 38e004388692f049908636a7944f6cd57d28bd77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_common.c
#	drivers/net/ethernet/intel/i40e/i40e_main.c
#	drivers/net/ethernet/intel/i40e/i40e_prototype.h
diff --cc drivers/net/ethernet/intel/i40e/i40e_common.c
index 1866f4096b38,a010584d8962..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_common.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_common.c
@@@ -287,6 -654,90 +287,93 @@@ i40e_status i40e_get_mac_addr(struct i4
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_get_port_mac_addr - get Port MAC address
+  * @hw: pointer to the HW structure
+  * @mac_addr: pointer to Port MAC address
+  *
+  * Reads the adapter's Port MAC address
+  **/
+ i40e_status i40e_get_port_mac_addr(struct i40e_hw *hw, u8 *mac_addr)
+ {
+ 	struct i40e_aqc_mac_address_read_data addrs;
+ 	i40e_status status;
+ 	u16 flags = 0;
+ 
+ 	status = i40e_aq_mac_address_read(hw, &flags, &addrs, NULL);
+ 	if (status)
+ 		return status;
+ 
+ 	if (flags & I40E_AQC_PORT_ADDR_VALID)
+ 		memcpy(mac_addr, &addrs.port_mac, sizeof(addrs.port_mac));
+ 	else
+ 		status = I40E_ERR_INVALID_MAC_ADDR;
+ 
+ 	return status;
+ }
+ 
+ /**
+  * i40e_pre_tx_queue_cfg - pre tx queue configure
+  * @hw: pointer to the HW structure
+  * @queue: target pf queue index
+  * @enable: state change request
+  *
+  * Handles hw requirement to indicate intention to enable
+  * or disable target queue.
+  **/
+ void i40e_pre_tx_queue_cfg(struct i40e_hw *hw, u32 queue, bool enable)
+ {
+ 	u32 abs_queue_idx = hw->func_caps.base_queue + queue;
+ 	u32 reg_block = 0;
+ 	u32 reg_val;
+ 
+ 	if (abs_queue_idx >= 128) {
+ 		reg_block = abs_queue_idx / 128;
+ 		abs_queue_idx %= 128;
+ 	}
+ 
+ 	reg_val = rd32(hw, I40E_GLLAN_TXPRE_QDIS(reg_block));
+ 	reg_val &= ~I40E_GLLAN_TXPRE_QDIS_QINDX_MASK;
+ 	reg_val |= (abs_queue_idx << I40E_GLLAN_TXPRE_QDIS_QINDX_SHIFT);
+ 
+ 	if (enable)
+ 		reg_val |= I40E_GLLAN_TXPRE_QDIS_CLEAR_QDIS_MASK;
+ 	else
+ 		reg_val |= I40E_GLLAN_TXPRE_QDIS_SET_QDIS_MASK;
+ 
+ 	wr32(hw, I40E_GLLAN_TXPRE_QDIS(reg_block), reg_val);
+ }
+ #ifdef I40E_FCOE
+ 
+ /**
+  * i40e_get_san_mac_addr - get SAN MAC address
+  * @hw: pointer to the HW structure
+  * @mac_addr: pointer to SAN MAC address
+  *
+  * Reads the adapter's SAN MAC address from NVM
+  **/
+ i40e_status i40e_get_san_mac_addr(struct i40e_hw *hw, u8 *mac_addr)
+ {
+ 	struct i40e_aqc_mac_address_read_data addrs;
+ 	i40e_status status;
+ 	u16 flags = 0;
+ 
+ 	status = i40e_aq_mac_address_read(hw, &flags, &addrs, NULL);
+ 	if (status)
+ 		return status;
+ 
+ 	if (flags & I40E_AQC_SAN_ADDR_VALID)
+ 		memcpy(mac_addr, &addrs.pf_san_mac, sizeof(addrs.pf_san_mac));
+ 	else
+ 		status = I40E_ERR_INVALID_MAC_ADDR;
+ 
+ 	return status;
+ }
+ #endif
+ 
+ /**
++>>>>>>> 38e004388692 (i40e: Adds FCoE related code to i40e core driver)
   * i40e_get_media_type - Gets media type
   * @hw: pointer to the hardware structure
   **/
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 56d76a198095,6ac8487f9a51..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -354,8 -361,10 +363,9 @@@ struct rtnl_link_stats64 *i40e_get_netd
  static struct rtnl_link_stats64 *i40e_get_netdev_stats_struct(
  					     struct net_device *netdev,
  					     struct rtnl_link_stats64 *stats)
+ #endif
  {
  	struct i40e_netdev_priv *np = netdev_priv(netdev);
 -	struct i40e_ring *tx_ring, *rx_ring;
  	struct i40e_vsi *vsi = np->vsi;
  	struct rtnl_link_stats64 *vsi_stats = i40e_get_vsi_stats_struct(vsi);
  	int i;
@@@ -999,6 -1110,25 +1058,28 @@@ void i40e_update_stats(struct i40e_vsi 
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * i40e_update_stats - Update the various statistics counters.
+  * @vsi: the VSI to be updated
+  *
+  * Update the various stats for this VSI and its related entities.
+  **/
+ void i40e_update_stats(struct i40e_vsi *vsi)
+ {
+ 	struct i40e_pf *pf = vsi->back;
+ 
+ 	if (vsi == pf->vsi[pf->lan_vsi])
+ 		i40e_update_pf_stats(pf);
+ 
+ 	i40e_update_vsi_stats(vsi);
+ #ifdef I40E_FCOE
+ 	i40e_update_fcoe_stats(vsi);
+ #endif
+ }
+ 
+ /**
++>>>>>>> 38e004388692 (i40e: Adds FCoE related code to i40e core driver)
   * i40e_find_filter - Search VSI filter list for specific mac/vlan filter
   * @vsi: the VSI to be searched
   * @macaddr: the MAC address
@@@ -2228,7 -2394,15 +2345,10 @@@ static int i40e_configure_tx_ring(struc
  	tx_ctx.qlen = ring->count;
  	tx_ctx.fd_ena = !!(vsi->back->flags & (I40E_FLAG_FD_SB_ENABLED |
  					       I40E_FLAG_FD_ATR_ENABLED));
+ #ifdef I40E_FCOE
+ 	tx_ctx.fc_ena = (vsi->type == I40E_VSI_FCOE);
+ #endif
  	tx_ctx.timesync_ena = !!(vsi->back->flags & I40E_FLAG_PTP);
 -	/* FDIR VSI tx ring can still use RS bit and writebacks */
 -	if (vsi->type != I40E_VSI_FDIR)
 -		tx_ctx.head_wb_ena = 1;
 -	tx_ctx.head_wb_addr = ring->dma +
 -			      (ring->count * sizeof(struct i40e_tx_desc));
  
  	/* As part of VSI creation/update, FW allocates certain
  	 * Tx arbitration queue sets for each TC enabled for
@@@ -2335,6 -2509,11 +2455,14 @@@ static int i40e_configure_rx_ring(struc
  	rx_ctx.crcstrip = 1;
  	rx_ctx.l2tsel = 1;
  	rx_ctx.showiv = 1;
++<<<<<<< HEAD
++=======
+ #ifdef I40E_FCOE
+ 	rx_ctx.fc_ena = (vsi->type == I40E_VSI_FCOE);
+ #endif
+ 	/* set the prefena field to 1 because the manual says to */
+ 	rx_ctx.prefena = 1;
++>>>>>>> 38e004388692 (i40e: Adds FCoE related code to i40e core driver)
  
  	/* clear the context in the HMC */
  	err = i40e_clear_lan_rx_queue_context(hw, pf_q);
@@@ -6316,6 -6607,20 +6506,23 @@@ static int i40e_init_msix(struct i40e_p
  	for (i = 0; i < v_budget; i++)
  		pf->msix_entries[i].entry = i;
  	vec = i40e_reserve_msix_vectors(pf, v_budget);
++<<<<<<< HEAD
++=======
+ 
+ 	if (vec != v_budget) {
+ 		/* If we have limited resources, we will start with no vectors
+ 		 * for the special features and then allocate vectors to some
+ 		 * of these features based on the policy and at the end disable
+ 		 * the features that did not get any vectors.
+ 		 */
+ #ifdef I40E_FCOE
+ 		pf->num_fcoe_qps = 0;
+ 		pf->num_fcoe_msix = 0;
+ #endif
+ 		pf->num_vmdq_msix = 0;
+ 	}
+ 
++>>>>>>> 38e004388692 (i40e: Adds FCoE related code to i40e core driver)
  	if (vec < I40E_MIN_MSIX) {
  		pf->flags &= ~I40E_FLAG_MSIX_ENABLED;
  		kfree(pf->msix_entries);
@@@ -6344,10 -6648,24 +6551,28 @@@
  			pf->num_lan_msix = 1;
  			break;
  		case 3:
++<<<<<<< HEAD
 +			pf->num_vmdq_vsis = 1;
++=======
+ #ifdef I40E_FCOE
+ 			/* give one vector to FCoE */
+ 			if (pf->flags & I40E_FLAG_FCOE_ENABLED) {
+ 				pf->num_lan_msix = 1;
+ 				pf->num_fcoe_msix = 1;
+ 			}
+ #else
++>>>>>>> 38e004388692 (i40e: Adds FCoE related code to i40e core driver)
  			pf->num_lan_msix = 2;
+ #endif
  			break;
  		default:
+ #ifdef I40E_FCOE
+ 			/* give one vector to FCoE */
+ 			if (pf->flags & I40E_FLAG_FCOE_ENABLED) {
+ 				pf->num_fcoe_msix = 1;
+ 				vec--;
+ 			}
+ #endif
  			pf->num_lan_msix = min_t(int, (vec / 2),
  						 pf->num_lan_qps);
  			pf->num_vmdq_vsis = min_t(int, (vec - pf->num_lan_msix),
@@@ -6356,6 -6674,18 +6581,21 @@@
  		}
  	}
  
++<<<<<<< HEAD
++=======
+ 	if ((pf->flags & I40E_FLAG_VMDQ_ENABLED) &&
+ 	    (pf->num_vmdq_msix == 0)) {
+ 		dev_info(&pf->pdev->dev, "VMDq disabled, not enough MSI-X vectors\n");
+ 		pf->flags &= ~I40E_FLAG_VMDQ_ENABLED;
+ 	}
+ #ifdef I40E_FCOE
+ 
+ 	if ((pf->flags & I40E_FLAG_FCOE_ENABLED) && (pf->num_fcoe_msix == 0)) {
+ 		dev_info(&pf->pdev->dev, "FCOE disabled, not enough MSI-X vectors\n");
+ 		pf->flags &= ~I40E_FLAG_FCOE_ENABLED;
+ 	}
+ #endif
++>>>>>>> 38e004388692 (i40e: Adds FCoE related code to i40e core driver)
  	return err;
  }
  
@@@ -8323,7 -8690,9 +8615,13 @@@ static void i40e_determine_queue_usage(
  	}
  
  	pf->queues_left = queues_left;
++<<<<<<< HEAD
 +	return;
++=======
+ #ifdef I40E_FCOE
+ 	dev_info(&pf->pdev->dev, "fcoe queues = %d\n", pf->num_fcoe_qps);
+ #endif
++>>>>>>> 38e004388692 (i40e: Adds FCoE related code to i40e core driver)
  }
  
  /**
@@@ -8577,7 -8946,22 +8879,26 @@@ static int i40e_probe(struct pci_dev *p
  		goto err_mac_addr;
  	}
  	dev_info(&pdev->dev, "MAC address: %pM\n", hw->mac.addr);
++<<<<<<< HEAD
 +	memcpy(hw->mac.perm_addr, hw->mac.addr, ETH_ALEN);
++=======
+ 	ether_addr_copy(hw->mac.perm_addr, hw->mac.addr);
+ 	i40e_get_port_mac_addr(hw, hw->mac.port_addr);
+ 	if (is_valid_ether_addr(hw->mac.port_addr))
+ 		pf->flags |= I40E_FLAG_PORT_ID_VALID;
+ #ifdef I40E_FCOE
+ 	err = i40e_get_san_mac_addr(hw, hw->mac.san_addr);
+ 	if (err)
+ 		dev_info(&pdev->dev,
+ 			 "(non-fatal) SAN MAC retrieval failed: %d\n", err);
+ 	if (!is_valid_ether_addr(hw->mac.san_addr)) {
+ 		dev_warn(&pdev->dev, "invalid SAN MAC address %pM, falling back to LAN MAC\n",
+ 			 hw->mac.san_addr);
+ 		ether_addr_copy(hw->mac.san_addr, hw->mac.addr);
+ 	}
+ 	dev_info(&pf->pdev->dev, "SAN MAC: %pM\n", hw->mac.san_addr);
+ #endif /* I40E_FCOE */
++>>>>>>> 38e004388692 (i40e: Adds FCoE related code to i40e core driver)
  
  	pci_set_drvdata(pdev, pf);
  	pci_save_state(pdev);
diff --cc drivers/net/ethernet/intel/i40e/i40e_prototype.h
index 1a6e9030a1f0,8cd4390a2842..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_prototype.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_prototype.h
@@@ -220,9 -233,13 +220,16 @@@ i40e_status i40e_pf_reset(struct i40e_h
  void i40e_clear_hw(struct i40e_hw *hw);
  void i40e_clear_pxe_mode(struct i40e_hw *hw);
  bool i40e_get_link_status(struct i40e_hw *hw);
 -i40e_status i40e_get_mac_addr(struct i40e_hw *hw, u8 *mac_addr);
 -i40e_status i40e_get_port_mac_addr(struct i40e_hw *hw, u8 *mac_addr);
 +i40e_status i40e_get_mac_addr(struct i40e_hw *hw,
 +						u8 *mac_addr);
  i40e_status i40e_validate_mac_addr(u8 *mac_addr);
++<<<<<<< HEAD
++=======
+ void i40e_pre_tx_queue_cfg(struct i40e_hw *hw, u32 queue, bool enable);
+ #ifdef I40E_FCOE
+ i40e_status i40e_get_san_mac_addr(struct i40e_hw *hw, u8 *mac_addr);
+ #endif
++>>>>>>> 38e004388692 (i40e: Adds FCoE related code to i40e core driver)
  /* prototype for functions used for NVM access */
  i40e_status i40e_init_nvm(struct i40e_hw *hw);
  i40e_status i40e_acquire_nvm(struct i40e_hw *hw,
diff --git a/drivers/net/ethernet/intel/i40e/i40e.h b/drivers/net/ethernet/intel/i40e/i40e.h
index 11439c769886..0a26718cab89 100644
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -54,6 +54,9 @@
 #include <linux/ptp_clock_kernel.h>
 #include "i40e_type.h"
 #include "i40e_prototype.h"
+#ifdef I40E_FCOE
+#include "i40e_fcoe.h"
+#endif
 #include "i40e_virtchnl.h"
 #include "i40e_virtchnl_pf.h"
 #include "i40e_txrx.h"
@@ -79,6 +82,10 @@
 #define I40E_MAX_QUEUES_PER_TC        64 /* should be a power of 2 */
 #define I40E_FDIR_RING                0
 #define I40E_FDIR_RING_COUNT          32
+#ifdef I40E_FCOE
+#define I40E_DEFAULT_FCOE             8 /* default number of QPs for FCoE */
+#define I40E_MINIMUM_FCOE             1 /* minimum number of QPs for FCoE */
+#endif /* I40E_FCOE */
 #define I40E_MAX_AQ_BUF_SIZE          4096
 #define I40E_AQ_LEN                   32
 #define I40E_AQ_WORK_LIMIT            16
@@ -215,6 +222,10 @@ struct i40e_pf {
 	u16 num_vmdq_msix;         /* num queue vectors per vmdq pool */
 	u16 num_req_vfs;           /* num vfs requested for this vf */
 	u16 num_vf_qps;            /* num queue pairs per vf */
+#ifdef I40E_FCOE
+	u16 num_fcoe_qps;          /* num fcoe queues this pf has set up */
+	u16 num_fcoe_msix;         /* num queue vectors per fcoe pool */
+#endif /* I40E_FCOE */
 	u16 num_lan_qps;           /* num lan queues this pf has set up */
 	u16 num_lan_msix;          /* num queue vectors for the base pf vsi */
 	int queues_left;           /* queues left unclaimed */
@@ -253,6 +264,9 @@ struct i40e_pf {
 #define I40E_FLAG_VMDQ_ENABLED                 (u64)(1 << 7)
 #define I40E_FLAG_FDIR_REQUIRES_REINIT         (u64)(1 << 8)
 #define I40E_FLAG_NEED_LINK_UPDATE             (u64)(1 << 9)
+#ifdef I40E_FCOE
+#define I40E_FLAG_FCOE_ENABLED                 (u64)(1 << 11)
+#endif /* I40E_FCOE */
 #define I40E_FLAG_IN_NETPOLL                   (u64)(1 << 12)
 #define I40E_FLAG_16BYTE_RX_DESC_ENABLED       (u64)(1 << 13)
 #define I40E_FLAG_CLEAN_ADMINQ                 (u64)(1 << 14)
@@ -273,6 +287,10 @@ struct i40e_pf {
 	/* tracks features that get auto disabled by errors */
 	u64 auto_disable_flags;
 
+#ifdef I40E_FCOE
+	struct i40e_fcoe fcoe;
+
+#endif /* I40E_FCOE */
 	bool stat_offsets_loaded;
 	struct i40e_hw_port_stats stats;
 	struct i40e_hw_port_stats stats_offsets;
@@ -395,6 +413,11 @@ struct i40e_vsi {
 	struct rtnl_link_stats64 net_stats_offsets;
 	struct i40e_eth_stats eth_stats;
 	struct i40e_eth_stats eth_stats_offsets;
+#ifdef I40E_FCOE
+	struct i40e_fcoe_stats fcoe_stats;
+	struct i40e_fcoe_stats fcoe_stats_offsets;
+	bool fcoe_stat_offsets_loaded;
+#endif
 	u32 tx_restart;
 	u32 tx_busy;
 	u32 rx_buf_failed;
@@ -585,6 +608,11 @@ struct i40e_vsi *i40e_vsi_setup(struct i40e_pf *pf, u8 type,
 int i40e_vsi_release(struct i40e_vsi *vsi);
 struct i40e_vsi *i40e_vsi_lookup(struct i40e_pf *pf, enum i40e_vsi_type type,
 				 struct i40e_vsi *start_vsi);
+#ifdef I40E_FCOE
+void i40e_vsi_setup_queue_map(struct i40e_vsi *vsi,
+			      struct i40e_vsi_context *ctxt,
+			      u8 enabled_tc, bool is_add);
+#endif
 int i40e_vsi_control_rings(struct i40e_vsi *vsi, bool enable);
 int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count);
 struct i40e_veb *i40e_veb_setup(struct i40e_pf *pf, u16 flags, u16 uplink_seid,
@@ -610,7 +638,21 @@ static inline void i40e_dbg_exit(void) {}
 void i40e_irq_dynamic_enable(struct i40e_vsi *vsi, int vector);
 void i40e_irq_dynamic_disable_icr0(struct i40e_pf *pf);
 void i40e_irq_dynamic_enable_icr0(struct i40e_pf *pf);
+#ifdef I40E_FCOE
+struct rtnl_link_stats64 *i40e_get_netdev_stats_struct(
+					     struct net_device *netdev,
+					     struct rtnl_link_stats64 *storage);
+int i40e_set_mac(struct net_device *netdev, void *p);
+void i40e_set_rx_mode(struct net_device *netdev);
+#endif
 int i40e_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
+#ifdef I40E_FCOE
+void i40e_tx_timeout(struct net_device *netdev);
+int i40e_vlan_rx_add_vid(struct net_device *netdev,
+			 __always_unused __be16 proto, u16 vid);
+int i40e_vlan_rx_kill_vid(struct net_device *netdev,
+			  __always_unused __be16 proto, u16 vid);
+#endif
 int i40e_vsi_open(struct i40e_vsi *vsi);
 void i40e_vlan_stripping_disable(struct i40e_vsi *vsi);
 int i40e_vsi_add_vlan(struct i40e_vsi *vsi, s16 vid);
@@ -620,6 +662,26 @@ struct i40e_mac_filter *i40e_put_mac_in_vlan(struct i40e_vsi *vsi, u8 *macaddr,
 bool i40e_is_vsi_in_vlan(struct i40e_vsi *vsi);
 struct i40e_mac_filter *i40e_find_mac(struct i40e_vsi *vsi, u8 *macaddr,
 				      bool is_vf, bool is_netdev);
+#ifdef I40E_FCOE
+int i40e_open(struct net_device *netdev);
+int i40e_close(struct net_device *netdev);
+int i40e_setup_tc(struct net_device *netdev, u8 tc);
+void i40e_netpoll(struct net_device *netdev);
+int i40e_fcoe_enable(struct net_device *netdev);
+int i40e_fcoe_disable(struct net_device *netdev);
+int i40e_fcoe_vsi_init(struct i40e_vsi *vsi, struct i40e_vsi_context *ctxt);
+u8 i40e_get_fcoe_tc_map(struct i40e_pf *pf);
+void i40e_fcoe_config_netdev(struct net_device *netdev, struct i40e_vsi *vsi);
+void i40e_fcoe_vsi_setup(struct i40e_pf *pf);
+int i40e_init_pf_fcoe(struct i40e_pf *pf);
+int i40e_fcoe_setup_ddp_resources(struct i40e_vsi *vsi);
+void i40e_fcoe_free_ddp_resources(struct i40e_vsi *vsi);
+int i40e_fcoe_handle_offload(struct i40e_ring *rx_ring,
+			     union i40e_rx_desc *rx_desc,
+			     struct sk_buff *skb);
+void i40e_fcoe_handle_status(struct i40e_ring *rx_ring,
+			     union i40e_rx_desc *rx_desc, u8 prog_id);
+#endif /* I40E_FCOE */
 void i40e_vlan_stripping_enable(struct i40e_vsi *vsi);
 #ifdef CONFIG_I40E_DCB
 void i40e_dcbnl_flush_apps(struct i40e_pf *pf,
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_common.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_debugfs.c b/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
index e322db988782..5bc68a241f28 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_debugfs.c
@@ -697,6 +697,25 @@ static void i40e_dbg_dump_vsi_seid(struct i40e_pf *pf, int seid)
 			 vsi->bw_ets_limit_credits[i],
 			 vsi->bw_ets_max_quanta[i]);
 	}
+#ifdef I40E_FCOE
+	if (vsi->type == I40E_VSI_FCOE) {
+		dev_info(&pf->pdev->dev,
+			 "    fcoe_stats: rx_packets = %llu, rx_dwords = %llu, rx_dropped = %llu\n",
+			 vsi->fcoe_stats.rx_fcoe_packets,
+			 vsi->fcoe_stats.rx_fcoe_dwords,
+			 vsi->fcoe_stats.rx_fcoe_dropped);
+		dev_info(&pf->pdev->dev,
+			 "    fcoe_stats: tx_packets = %llu, tx_dwords = %llu\n",
+			 vsi->fcoe_stats.tx_fcoe_packets,
+			 vsi->fcoe_stats.tx_fcoe_dwords);
+		dev_info(&pf->pdev->dev,
+			 "    fcoe_stats: bad_crc = %llu, last_error = %llu\n",
+			 vsi->fcoe_stats.fcoe_bad_fccrc,
+			 vsi->fcoe_stats.fcoe_last_error);
+		dev_info(&pf->pdev->dev, "    fcoe_stats: ddp_count = %llu\n",
+			 vsi->fcoe_stats.fcoe_ddp_count);
+	}
+#endif
 }
 
 /**
diff --git a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 481e300435f7..19b71f90e86a 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@ -141,6 +141,19 @@ static struct i40e_stats i40e_gstrings_stats[] = {
 	I40E_PF_STAT("rx_hwtstamp_cleared", rx_hwtstamp_cleared),
 };
 
+#ifdef I40E_FCOE
+static const struct i40e_stats i40e_gstrings_fcoe_stats[] = {
+	I40E_VSI_STAT("fcoe_bad_fccrc", fcoe_stats.fcoe_bad_fccrc),
+	I40E_VSI_STAT("rx_fcoe_dropped", fcoe_stats.rx_fcoe_dropped),
+	I40E_VSI_STAT("rx_fcoe_packets", fcoe_stats.rx_fcoe_packets),
+	I40E_VSI_STAT("rx_fcoe_dwords", fcoe_stats.rx_fcoe_dwords),
+	I40E_VSI_STAT("fcoe_ddp_count", fcoe_stats.fcoe_ddp_count),
+	I40E_VSI_STAT("fcoe_last_error", fcoe_stats.fcoe_last_error),
+	I40E_VSI_STAT("tx_fcoe_packets", fcoe_stats.tx_fcoe_packets),
+	I40E_VSI_STAT("tx_fcoe_dwords", fcoe_stats.tx_fcoe_dwords),
+};
+
+#endif /* I40E_FCOE */
 #define I40E_QUEUE_STATS_LEN(n) \
 	(((struct i40e_netdev_priv *)netdev_priv((n)))->vsi->num_queue_pairs \
 	    * 2 /* Tx and Rx together */                                     \
@@ -148,9 +161,17 @@ static struct i40e_stats i40e_gstrings_stats[] = {
 #define I40E_GLOBAL_STATS_LEN	ARRAY_SIZE(i40e_gstrings_stats)
 #define I40E_NETDEV_STATS_LEN   ARRAY_SIZE(i40e_gstrings_net_stats)
 #define I40E_MISC_STATS_LEN	ARRAY_SIZE(i40e_gstrings_misc_stats)
+#ifdef I40E_FCOE
+#define I40E_FCOE_STATS_LEN	ARRAY_SIZE(i40e_gstrings_fcoe_stats)
+#define I40E_VSI_STATS_LEN(n)	(I40E_NETDEV_STATS_LEN + \
+				 I40E_FCOE_STATS_LEN + \
+				 I40E_MISC_STATS_LEN + \
+				 I40E_QUEUE_STATS_LEN((n)))
+#else
 #define I40E_VSI_STATS_LEN(n)   (I40E_NETDEV_STATS_LEN + \
 				 I40E_MISC_STATS_LEN + \
 				 I40E_QUEUE_STATS_LEN((n)))
+#endif /* I40E_FCOE */
 #define I40E_PFC_STATS_LEN ( \
 		(FIELD_SIZEOF(struct i40e_pf, stats.priority_xoff_rx) + \
 		 FIELD_SIZEOF(struct i40e_pf, stats.priority_xon_rx) + \
@@ -1041,6 +1062,13 @@ static void i40e_get_ethtool_stats(struct net_device *netdev,
 		data[i++] = (i40e_gstrings_misc_stats[j].sizeof_stat ==
 			    sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
 	}
+#ifdef I40E_FCOE
+	for (j = 0; j < I40E_FCOE_STATS_LEN; j++) {
+		p = (char *)vsi + i40e_gstrings_fcoe_stats[j].stat_offset;
+		data[i++] = (i40e_gstrings_fcoe_stats[j].sizeof_stat ==
+			sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
+	}
+#endif
 	rcu_read_lock();
 	for (j = 0; j < vsi->num_queue_pairs; j++, i += 4) {
 		struct i40e_ring *tx_ring = ACCESS_ONCE(vsi->tx_rings[j]);
@@ -1121,6 +1149,13 @@ static void i40e_get_strings(struct net_device *netdev, u32 stringset,
 				 i40e_gstrings_misc_stats[i].stat_string);
 			p += ETH_GSTRING_LEN;
 		}
+#ifdef I40E_FCOE
+		for (i = 0; i < I40E_FCOE_STATS_LEN; i++) {
+			snprintf(p, ETH_GSTRING_LEN, "%s",
+				 i40e_gstrings_fcoe_stats[i].stat_string);
+			p += ETH_GSTRING_LEN;
+		}
+#endif
 		for (i = 0; i < vsi->num_queue_pairs; i++) {
 			snprintf(p, ETH_GSTRING_LEN, "tx-%u.tx_packets", i);
 			p += ETH_GSTRING_LEN;
diff --git a/drivers/net/ethernet/intel/i40e/i40e_fcoe.c b/drivers/net/ethernet/intel/i40e/i40e_fcoe.c
index 8574eeefefc7..6938fc1ad877 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_fcoe.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_fcoe.c
@@ -1363,8 +1363,6 @@ static netdev_tx_t i40e_fcoe_xmit_frame(struct sk_buff *skb,
 	struct i40e_vsi *vsi = np->vsi;
 	struct i40e_ring *tx_ring = vsi->tx_rings[skb->queue_mapping];
 	struct i40e_tx_buffer *first;
-	__be16 protocol = skb->protocol;
-
 	u32 tx_flags = 0;
 	u8 hdr_len = 0;
 	u8 sof = 0;
@@ -1384,13 +1382,8 @@ static netdev_tx_t i40e_fcoe_xmit_frame(struct sk_buff *skb,
 	/* record the location of the first descriptor for this packet */
 	first = &tx_ring->tx_bi[tx_ring->next_to_use];
 
-	if (protocol == htons(ETH_P_8021Q)) {
-		struct vlan_ethhdr *veth = (struct vlan_ethhdr *)eth_hdr(skb);
-
-		protocol = veth->h_vlan_encapsulated_proto;
-	}
 	/* FIP is a regular L2 traffic w/o offload */
-	if (protocol == htons(ETH_P_FIP))
+	if (skb->protocol == htons(ETH_P_FIP))
 		goto out_send;
 
 	/* check sof and eof, only supports FC Class 2 or 3 */
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_osdep.h b/drivers/net/ethernet/intel/i40e/i40e_osdep.h
index ecd0f0b663c9..045b5c4b98b3 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_osdep.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_osdep.h
@@ -78,4 +78,7 @@ do {                                                            \
 } while (0)
 
 typedef enum i40e_status_code i40e_status;
+#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)
+#define I40E_FCOE
+#endif /* CONFIG_FCOE or CONFIG_FCOE_MODULE */
 #endif /* _I40E_OSDEP_H_ */
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_prototype.h
diff --git a/drivers/net/ethernet/intel/i40e/i40e_txrx.c b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
index 9c6fc77462e7..219c24e503a6 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@ -870,6 +870,11 @@ static void i40e_clean_programming_status(struct i40e_ring *rx_ring,
 
 	if (id == I40E_RX_PROG_STATUS_DESC_FD_FILTER_STATUS)
 		i40e_fd_handle_status(rx_ring, rx_desc, id);
+#ifdef I40E_FCOE
+	else if ((id == I40E_RX_PROG_STATUS_DESC_FCOE_CTXT_PROG_STATUS) ||
+		 (id == I40E_RX_PROG_STATUS_DESC_FCOE_CTXT_INVL_STATUS))
+		i40e_fcoe_handle_status(rx_ring, rx_desc, id);
+#endif
 }
 
 /**
@@ -1401,6 +1406,12 @@ static int i40e_clean_rx_irq(struct i40e_ring *rx_ring, int budget)
 		vlan_tag = rx_status & (1 << I40E_RX_DESC_STATUS_L2TAG1P_SHIFT)
 			 ? le16_to_cpu(rx_desc->wb.qword0.lo_dword.l2tag1)
 			 : 0;
+#ifdef I40E_FCOE
+		if (!i40e_fcoe_handle_offload(rx_ring, rx_desc, skb)) {
+			dev_kfree_skb_any(skb);
+			goto next_desc;
+		}
+#endif
 		i40e_receive_skb(rx_ring, skb, vlan_tag);
 
 		rx_ring->netdev->last_rx = jiffies;
@@ -1626,9 +1637,15 @@ static void i40e_atr(struct i40e_ring *tx_ring, struct sk_buff *skb,
  * Returns error code indicate the frame should be dropped upon error and the
  * otherwise  returns 0 to indicate the flags has been set properly.
  **/
+#ifdef I40E_FCOE
+int i40e_tx_prepare_vlan_flags(struct sk_buff *skb,
+			       struct i40e_ring *tx_ring,
+			       u32 *flags)
+#else
 static int i40e_tx_prepare_vlan_flags(struct sk_buff *skb,
 				      struct i40e_ring *tx_ring,
 				      u32 *flags)
+#endif
 {
 	__be16 protocol = skb->protocol;
 	u32  tx_flags = 0;
@@ -1650,9 +1667,8 @@ static int i40e_tx_prepare_vlan_flags(struct sk_buff *skb,
 	}
 
 	/* Insert 802.1p priority into VLAN header */
-	if ((tx_ring->vsi->back->flags & I40E_FLAG_DCB_ENABLED) &&
-	    ((tx_flags & (I40E_TX_FLAGS_HW_VLAN | I40E_TX_FLAGS_SW_VLAN)) ||
-	     (skb->priority != TC_PRIO_CONTROL))) {
+	if ((tx_flags & (I40E_TX_FLAGS_HW_VLAN | I40E_TX_FLAGS_SW_VLAN)) ||
+	    (skb->priority != TC_PRIO_CONTROL)) {
 		tx_flags &= ~I40E_TX_FLAGS_VLAN_PRIO_MASK;
 		tx_flags |= (skb->priority & 0x7) <<
 				I40E_TX_FLAGS_VLAN_PRIO_SHIFT;
@@ -1926,9 +1942,15 @@ static void i40e_create_tx_ctx(struct i40e_ring *tx_ring,
  * @td_cmd:   the command field in the descriptor
  * @td_offset: offset for checksum or crc
  **/
+#ifdef I40E_FCOE
+void i40e_tx_map(struct i40e_ring *tx_ring, struct sk_buff *skb,
+		 struct i40e_tx_buffer *first, u32 tx_flags,
+		 const u8 hdr_len, u32 td_cmd, u32 td_offset)
+#else
 static void i40e_tx_map(struct i40e_ring *tx_ring, struct sk_buff *skb,
 			struct i40e_tx_buffer *first, u32 tx_flags,
 			const u8 hdr_len, u32 td_cmd, u32 td_offset)
+#endif
 {
 	unsigned int data_len = skb->data_len;
 	unsigned int size = skb_headlen(skb);
@@ -2091,7 +2113,11 @@ static inline int __i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)
  *
  * Returns 0 if stop is not needed
  **/
+#ifdef I40E_FCOE
+int i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)
+#else
 static int i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)
+#endif
 {
 	if (likely(I40E_DESC_UNUSED(tx_ring) >= size))
 		return 0;
@@ -2107,8 +2133,13 @@ static int i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size)
  * there is not enough descriptors available in this ring since we need at least
  * one descriptor.
  **/
+#ifdef I40E_FCOE
+int i40e_xmit_descriptor_count(struct sk_buff *skb,
+			       struct i40e_ring *tx_ring)
+#else
 static int i40e_xmit_descriptor_count(struct sk_buff *skb,
 				      struct i40e_ring *tx_ring)
+#endif
 {
 #if PAGE_SIZE > I40E_MAX_DATA_PER_TXD
 	unsigned int f;
diff --git a/drivers/net/ethernet/intel/i40e/i40e_txrx.h b/drivers/net/ethernet/intel/i40e/i40e_txrx.h
index d5349698e513..bbb9561329f8 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.h
@@ -299,4 +299,13 @@ int i40e_setup_rx_descriptors(struct i40e_ring *rx_ring);
 void i40e_free_tx_resources(struct i40e_ring *tx_ring);
 void i40e_free_rx_resources(struct i40e_ring *rx_ring);
 int i40e_napi_poll(struct napi_struct *napi, int budget);
+#ifdef I40E_FCOE
+void i40e_tx_map(struct i40e_ring *tx_ring, struct sk_buff *skb,
+		 struct i40e_tx_buffer *first, u32 tx_flags,
+		 const u8 hdr_len, u32 td_cmd, u32 td_offset);
+int i40e_maybe_stop_tx(struct i40e_ring *tx_ring, int size);
+int i40e_xmit_descriptor_count(struct sk_buff *skb, struct i40e_ring *tx_ring);
+int i40e_tx_prepare_vlan_flags(struct sk_buff *skb,
+			       struct i40e_ring *tx_ring, u32 *flags);
+#endif
 #endif /* _I40E_TXRX_H_ */
diff --git a/drivers/net/ethernet/intel/i40e/i40e_type.h b/drivers/net/ethernet/intel/i40e/i40e_type.h
index 181a825d3160..1b36ba3174ac 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_type.h
+++ b/drivers/net/ethernet/intel/i40e/i40e_type.h
@@ -968,6 +968,25 @@ struct i40e_eth_stats {
 	u64 tx_errors;			/* tepc */
 };
 
+#ifdef I40E_FCOE
+/* Statistics collected per function for FCoE */
+struct i40e_fcoe_stats {
+	u64 rx_fcoe_packets;		/* fcoeprc */
+	u64 rx_fcoe_dwords;		/* focedwrc */
+	u64 rx_fcoe_dropped;		/* fcoerpdc */
+	u64 tx_fcoe_packets;		/* fcoeptc */
+	u64 tx_fcoe_dwords;		/* focedwtc */
+	u64 fcoe_bad_fccrc;		/* fcoecrc */
+	u64 fcoe_last_error;		/* fcoelast */
+	u64 fcoe_ddp_count;		/* fcoeddpc */
+};
+
+/* offset to per function FCoE statistics block */
+#define I40E_FCOE_VF_STAT_OFFSET	0
+#define I40E_FCOE_PF_STAT_OFFSET	128
+#define I40E_FCOE_STAT_MAX		(I40E_FCOE_PF_STAT_OFFSET + I40E_MAX_PF)
+
+#endif
 /* Statistics collected by the MAC */
 struct i40e_hw_port_stats {
 	/* eth stats collected by the port */
@@ -1040,6 +1059,125 @@ struct i40e_hw_port_stats {
 
 #define I40E_SRRD_SRCTL_ATTEMPTS	100000
 
+#ifdef I40E_FCOE
+/* FCoE Tx context descriptor - Use the i40e_tx_context_desc struct */
+
+enum i40E_fcoe_tx_ctx_desc_cmd_bits {
+	I40E_FCOE_TX_CTX_DESC_OPCODE_SINGLE_SEND	= 0x00, /* 4 BITS */
+	I40E_FCOE_TX_CTX_DESC_OPCODE_TSO_FC_CLASS2	= 0x01, /* 4 BITS */
+	I40E_FCOE_TX_CTX_DESC_OPCODE_TSO_FC_CLASS3	= 0x05, /* 4 BITS */
+	I40E_FCOE_TX_CTX_DESC_OPCODE_ETSO_FC_CLASS2	= 0x02, /* 4 BITS */
+	I40E_FCOE_TX_CTX_DESC_OPCODE_ETSO_FC_CLASS3	= 0x06, /* 4 BITS */
+	I40E_FCOE_TX_CTX_DESC_OPCODE_DWO_FC_CLASS2	= 0x03, /* 4 BITS */
+	I40E_FCOE_TX_CTX_DESC_OPCODE_DWO_FC_CLASS3	= 0x07, /* 4 BITS */
+	I40E_FCOE_TX_CTX_DESC_OPCODE_DDP_CTX_INVL	= 0x08, /* 4 BITS */
+	I40E_FCOE_TX_CTX_DESC_OPCODE_DWO_CTX_INVL	= 0x09, /* 4 BITS */
+	I40E_FCOE_TX_CTX_DESC_RELOFF			= 0x10,
+	I40E_FCOE_TX_CTX_DESC_CLRSEQ			= 0x20,
+	I40E_FCOE_TX_CTX_DESC_DIFENA			= 0x40,
+	I40E_FCOE_TX_CTX_DESC_IL2TAG2			= 0x80
+};
+
+/* FCoE DDP Context descriptor */
+struct i40e_fcoe_ddp_context_desc {
+	__le64 rsvd;
+	__le64 type_cmd_foff_lsize;
+};
+
+#define I40E_FCOE_DDP_CTX_QW1_DTYPE_SHIFT	0
+#define I40E_FCOE_DDP_CTX_QW1_DTYPE_MASK	(0xFULL << \
+					I40E_FCOE_DDP_CTX_QW1_DTYPE_SHIFT)
+
+#define I40E_FCOE_DDP_CTX_QW1_CMD_SHIFT	4
+#define I40E_FCOE_DDP_CTX_QW1_CMD_MASK	(0xFULL << \
+					 I40E_FCOE_DDP_CTX_QW1_CMD_SHIFT)
+
+enum i40e_fcoe_ddp_ctx_desc_cmd_bits {
+	I40E_FCOE_DDP_CTX_DESC_BSIZE_512B	= 0x00, /* 2 BITS */
+	I40E_FCOE_DDP_CTX_DESC_BSIZE_4K		= 0x01, /* 2 BITS */
+	I40E_FCOE_DDP_CTX_DESC_BSIZE_8K		= 0x02, /* 2 BITS */
+	I40E_FCOE_DDP_CTX_DESC_BSIZE_16K	= 0x03, /* 2 BITS */
+	I40E_FCOE_DDP_CTX_DESC_DIFENA		= 0x04, /* 1 BIT  */
+	I40E_FCOE_DDP_CTX_DESC_LASTSEQH		= 0x08, /* 1 BIT  */
+};
+
+#define I40E_FCOE_DDP_CTX_QW1_FOFF_SHIFT	16
+#define I40E_FCOE_DDP_CTX_QW1_FOFF_MASK	(0x3FFFULL << \
+					 I40E_FCOE_DDP_CTX_QW1_FOFF_SHIFT)
+
+#define I40E_FCOE_DDP_CTX_QW1_LSIZE_SHIFT	32
+#define I40E_FCOE_DDP_CTX_QW1_LSIZE_MASK	(0x3FFFULL << \
+					I40E_FCOE_DDP_CTX_QW1_LSIZE_SHIFT)
+
+/* FCoE DDP/DWO Queue Context descriptor */
+struct i40e_fcoe_queue_context_desc {
+	__le64 dmaindx_fbase;           /* 0:11 DMAINDX, 12:63 FBASE */
+	__le64 flen_tph;                /* 0:12 FLEN, 13:15 TPH */
+};
+
+#define I40E_FCOE_QUEUE_CTX_QW0_DMAINDX_SHIFT	0
+#define I40E_FCOE_QUEUE_CTX_QW0_DMAINDX_MASK	(0xFFFULL << \
+					I40E_FCOE_QUEUE_CTX_QW0_DMAINDX_SHIFT)
+
+#define I40E_FCOE_QUEUE_CTX_QW0_FBASE_SHIFT	12
+#define I40E_FCOE_QUEUE_CTX_QW0_FBASE_MASK	(0xFFFFFFFFFFFFFULL << \
+					I40E_FCOE_QUEUE_CTX_QW0_FBASE_SHIFT)
+
+#define I40E_FCOE_QUEUE_CTX_QW1_FLEN_SHIFT	0
+#define I40E_FCOE_QUEUE_CTX_QW1_FLEN_MASK	(0x1FFFULL << \
+					I40E_FCOE_QUEUE_CTX_QW1_FLEN_SHIFT)
+
+#define I40E_FCOE_QUEUE_CTX_QW1_TPH_SHIFT	13
+#define I40E_FCOE_QUEUE_CTX_QW1_TPH_MASK	(0x7ULL << \
+					I40E_FCOE_QUEUE_CTX_QW1_FLEN_SHIFT)
+
+enum i40e_fcoe_queue_ctx_desc_tph_bits {
+	I40E_FCOE_QUEUE_CTX_DESC_TPHRDESC	= 0x1,
+	I40E_FCOE_QUEUE_CTX_DESC_TPHDATA	= 0x2
+};
+
+#define I40E_FCOE_QUEUE_CTX_QW1_RECIPE_SHIFT	30
+#define I40E_FCOE_QUEUE_CTX_QW1_RECIPE_MASK	(0x3ULL << \
+					I40E_FCOE_QUEUE_CTX_QW1_RECIPE_SHIFT)
+
+/* FCoE DDP/DWO Filter Context descriptor */
+struct i40e_fcoe_filter_context_desc {
+	__le32 param;
+	__le16 seqn;
+
+	/* 48:51(0:3) RSVD, 52:63(4:15) DMAINDX */
+	__le16 rsvd_dmaindx;
+
+	/* 0:7 FLAGS, 8:52 RSVD, 53:63 LANQ */
+	__le64 flags_rsvd_lanq;
+};
+
+#define I40E_FCOE_FILTER_CTX_QW0_DMAINDX_SHIFT	4
+#define I40E_FCOE_FILTER_CTX_QW0_DMAINDX_MASK	(0xFFF << \
+					I40E_FCOE_FILTER_CTX_QW0_DMAINDX_SHIFT)
+
+enum i40e_fcoe_filter_ctx_desc_flags_bits {
+	I40E_FCOE_FILTER_CTX_DESC_CTYP_DDP	= 0x00,
+	I40E_FCOE_FILTER_CTX_DESC_CTYP_DWO	= 0x01,
+	I40E_FCOE_FILTER_CTX_DESC_ENODE_INIT	= 0x00,
+	I40E_FCOE_FILTER_CTX_DESC_ENODE_RSP	= 0x02,
+	I40E_FCOE_FILTER_CTX_DESC_FC_CLASS2	= 0x00,
+	I40E_FCOE_FILTER_CTX_DESC_FC_CLASS3	= 0x04
+};
+
+#define I40E_FCOE_FILTER_CTX_QW1_FLAGS_SHIFT	0
+#define I40E_FCOE_FILTER_CTX_QW1_FLAGS_MASK	(0xFFULL << \
+					I40E_FCOE_FILTER_CTX_QW1_FLAGS_SHIFT)
+
+#define I40E_FCOE_FILTER_CTX_QW1_PCTYPE_SHIFT     8
+#define I40E_FCOE_FILTER_CTX_QW1_PCTYPE_MASK      (0x3FULL << \
+			I40E_FCOE_FILTER_CTX_QW1_PCTYPE_SHIFT)
+
+#define I40E_FCOE_FILTER_CTX_QW1_LANQINDX_SHIFT     53
+#define I40E_FCOE_FILTER_CTX_QW1_LANQINDX_MASK      (0x7FFULL << \
+			I40E_FCOE_FILTER_CTX_QW1_LANQINDX_SHIFT)
+
+#endif /* I40E_FCOE */
 enum i40e_switch_element_types {
 	I40E_SWITCH_ELEMENT_TYPE_MAC	= 1,
 	I40E_SWITCH_ELEMENT_TYPE_PF	= 2,
