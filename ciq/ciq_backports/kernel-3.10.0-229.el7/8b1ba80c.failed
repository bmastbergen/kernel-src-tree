usb: assign usb3 external hub port peers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [usb] assign usb3 external hub port peers (Don Zickus) [1110939]
Rebuild_FUZZ: 93.33%
commit-author Dan Williams <dan.j.williams@intel.com>
commit 8b1ba80c59fb3e77f9e1761480617d5ea9ee159c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/8b1ba80c.failed

Given that root hub port peers are already established, external hub peer
ports can be determined by traversing the device topology:

1/ ascend to the parent hub and find the upstream port_dev

2/ walk ->peer to find the peer port

3/ descend to the peer hub via ->child

4/ find the port with the matching port id

Note that this assumes the port labeling scheme required by the
specification [1].

[1]: usb3 3.1 section 10.3.3

	Acked-by: Alan Stern <stern@rowland.harvard.edu>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 8b1ba80c59fb3e77f9e1761480617d5ea9ee159c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/core/port.c
diff --cc drivers/usb/core/port.c
index 168fa6ee3348,9b7496b52f2a..000000000000
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@@ -152,9 -152,87 +152,90 @@@ struct device_type usb_port_device_typ
  	.pm =		&usb_port_pm_ops,
  };
  
++<<<<<<< HEAD
++=======
+ static struct device_driver usb_port_driver = {
+ 	.name = "usb",
+ 	.owner = THIS_MODULE,
+ };
+ 
+ static void link_peers(struct usb_port *left, struct usb_port *right)
+ {
+ 	if (left->peer == right && right->peer == left)
+ 		return;
+ 
+ 	if (left->peer || right->peer) {
+ 		struct usb_port *lpeer = left->peer;
+ 		struct usb_port *rpeer = right->peer;
+ 
+ 		WARN(1, "failed to peer %s and %s (%s -> %p) (%s -> %p)\n",
+ 			dev_name(&left->dev), dev_name(&right->dev),
+ 			dev_name(&left->dev), lpeer,
+ 			dev_name(&right->dev), rpeer);
+ 		return;
+ 	}
+ 
+ 	left->peer = right;
+ 	right->peer = left;
+ }
+ 
+ static void unlink_peers(struct usb_port *left, struct usb_port *right)
+ {
+ 	WARN(right->peer != left || left->peer != right,
+ 			"%s and %s are not peers?\n",
+ 			dev_name(&left->dev), dev_name(&right->dev));
+ 
+ 	right->peer = NULL;
+ 	left->peer = NULL;
+ }
+ 
+ /*
+  * Set the default peer port for root hubs, or via the upstream peer
+  * relationship for all other hubs
+  */
+ static void find_and_link_peer(struct usb_hub *hub, int port1)
+ {
+ 	struct usb_port *port_dev = hub->ports[port1 - 1], *peer;
+ 	struct usb_device *hdev = hub->hdev;
+ 	struct usb_device *peer_hdev;
+ 	struct usb_hub *peer_hub;
+ 
+ 	if (!hdev->parent) {
+ 		struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
+ 		struct usb_hcd *peer_hcd = hcd->shared_hcd;
+ 
+ 		if (!peer_hcd)
+ 			return;
+ 
+ 		peer_hdev = peer_hcd->self.root_hub;
+ 	} else {
+ 		struct usb_port *upstream;
+ 		struct usb_device *parent = hdev->parent;
+ 		struct usb_hub *parent_hub = usb_hub_to_struct_hub(parent);
+ 
+ 		if (!parent_hub)
+ 			return;
+ 
+ 		upstream = parent_hub->ports[hdev->portnum - 1];
+ 		if (!upstream || !upstream->peer)
+ 			return;
+ 
+ 		peer_hdev = upstream->peer->child;
+ 	}
+ 
+ 	peer_hub = usb_hub_to_struct_hub(peer_hdev);
+ 	if (!peer_hub || port1 > peer_hdev->maxchild)
+ 		return;
+ 
+ 	peer = peer_hub->ports[port1 - 1];
+ 	if (peer)
+ 		link_peers(port_dev, peer);
+ }
+ 
++>>>>>>> 8b1ba80c59fb (usb: assign usb3 external hub port peers)
  int usb_hub_create_port_device(struct usb_hub *hub, int port1)
  {
 -	struct usb_port *port_dev;
 +	struct usb_port *port_dev = NULL;
  	int retval;
  
  	port_dev = kzalloc(sizeof(*port_dev), GFP_KERNEL);
* Unmerged path drivers/usb/core/port.c
