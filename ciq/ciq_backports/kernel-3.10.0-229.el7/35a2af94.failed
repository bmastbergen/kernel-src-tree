sched/wait: Make the __wait_event*() interface more friendly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [kernel] wait: Make the __wait_event*() interface more friendly (Jes Sorensen) [1085530]
Rebuild_FUZZ: 94.74%
commit-author Peter Zijlstra <peterz@infradead.org>
commit 35a2af94c7ce7130ca292c68b1d27fcfdb648f6b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/35a2af94.failed

Change all __wait_event*() implementations to match the corresponding
wait_event*() signature for convenience.

In particular this does away with the weird 'ret' logic. Since there
are __wait_event*() users this requires we update them too.

	Reviewed-by: Oleg Nesterov <oleg@redhat.com>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20131002092529.042563462@infradead.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 35a2af94c7ce7130ca292c68b1d27fcfdb648f6b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/tty.h
#	include/linux/wait.h
diff --cc include/linux/tty.h
index 4e59c4288148,633cac77f9f9..000000000000
--- a/include/linux/tty.h
+++ b/include/linux/tty.h
@@@ -670,25 -678,11 +670,31 @@@ static inline void tty_wait_until_sent_
  	__ret;								\
  })
  
++<<<<<<< HEAD
 +#define __wait_event_interruptible_tty(tty, wq, condition, ret)		\
 +do {									\
 +	DEFINE_WAIT(__wait);						\
 +									\
 +	for (;;) {							\
 +		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
 +		if (condition)						\
 +			break;						\
 +		if (!signal_pending(current)) {				\
 +			tty_unlock(tty);					\
++=======
+ #define __wait_event_interruptible_tty(tty, wq, condition)		\
+ 	___wait_event(wq, condition, TASK_INTERRUPTIBLE, 0, 0,		\
+ 			tty_unlock(tty);				\
++>>>>>>> 35a2af94c7ce (sched/wait: Make the __wait_event*() interface more friendly)
  			schedule();					\
 -			tty_lock(tty))
 +			tty_lock(tty);					\
 +			continue;					\
 +		}							\
 +		ret = -ERESTARTSYS;					\
 +		break;							\
 +	}								\
 +	finish_wait(&wq, &__wait);					\
 +} while (0)
  
  #ifdef CONFIG_PROC_FS
  extern void proc_tty_register_driver(struct tty_driver *);
diff --cc include/linux/wait.h
index c8e576022234,bd4bd7b479b6..000000000000
--- a/include/linux/wait.h
+++ b/include/linux/wait.h
@@@ -173,19 -179,53 +173,62 @@@ wait_queue_head_t *bit_waitqueue(void *
  #define wake_up_interruptible_sync_poll(x, m)				\
  	__wake_up_sync_key((x), TASK_INTERRUPTIBLE, 1, (void *) (m))
  
++<<<<<<< HEAD
 +#define __wait_event(wq, condition) 					\
 +do {									\
++=======
+ #define ___wait_cond_timeout(condition)					\
+ ({									\
+  	bool __cond = (condition);					\
+  	if (__cond && !__ret)						\
+  		__ret = 1;						\
+  	__cond || !__ret;						\
+ })
+ 
+ #define ___wait_signal_pending(state)					\
+ 	((state == TASK_INTERRUPTIBLE && signal_pending(current)) ||	\
+ 	 (state == TASK_KILLABLE && fatal_signal_pending(current)))
+ 
+ #define ___wait_event(wq, condition, state, exclusive, ret, cmd)	\
+ ({									\
+ 	__label__ __out;						\
++>>>>>>> 35a2af94c7ce (sched/wait: Make the __wait_event*() interface more friendly)
  	DEFINE_WAIT(__wait);						\
+ 	long __ret = ret;						\
  									\
  	for (;;) {							\
 -		if (exclusive)						\
 -			prepare_to_wait_exclusive(&wq, &__wait, state); \
 -		else							\
 -			prepare_to_wait(&wq, &__wait, state);		\
 -									\
 +		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);	\
  		if (condition)						\
  			break;						\
++<<<<<<< HEAD
 +		schedule();						\
 +	}								\
 +	finish_wait(&wq, &__wait);					\
 +} while (0)
 +
++=======
+ 									\
+ 		if (___wait_signal_pending(state)) {			\
+ 			__ret = -ERESTARTSYS;				\
+ 			if (exclusive) {				\
+ 				abort_exclusive_wait(&wq, &__wait, 	\
+ 						     state, NULL); 	\
+ 				goto __out;				\
+ 			}						\
+ 			break;						\
+ 		}							\
+ 									\
+ 		cmd;							\
+ 	}								\
+ 	finish_wait(&wq, &__wait);					\
+ __out:	__ret;								\
+ })
+ 
+ #define __wait_event(wq, condition) 					\
+ 	(void)___wait_event(wq, condition, TASK_UNINTERRUPTIBLE, 0, 0,	\
+ 			    schedule())
+ 
++>>>>>>> 35a2af94c7ce (sched/wait: Make the __wait_event*() interface more friendly)
  /**
   * wait_event - sleep until a condition gets true
   * @wq: the waitqueue to wait on
@@@ -205,22 -245,10 +248,29 @@@ do {									
  	__wait_event(wq, condition);					\
  } while (0)
  
++<<<<<<< HEAD
 +#define __wait_event_timeout(wq, condition, ret)			\
 +do {									\
 +	DEFINE_WAIT(__wait);						\
 +									\
 +	for (;;) {							\
 +		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);	\
 +		if (condition)						\
 +			break;						\
 +		ret = schedule_timeout(ret);				\
 +		if (!ret)						\
 +			break;						\
 +	}								\
 +	if (!ret && (condition))					\
 +		ret = 1;						\
 +	finish_wait(&wq, &__wait);					\
 +} while (0)
++=======
+ #define __wait_event_timeout(wq, condition, timeout)			\
+ 	___wait_event(wq, ___wait_cond_timeout(condition),		\
+ 		      TASK_UNINTERRUPTIBLE, 0, timeout,			\
+ 		      __ret = schedule_timeout(__ret))
++>>>>>>> 35a2af94c7ce (sched/wait: Make the __wait_event*() interface more friendly)
  
  /**
   * wait_event_timeout - sleep until a condition gets true or a timeout elapses
@@@ -247,23 -275,9 +297,29 @@@
  	__ret;								\
  })
  
++<<<<<<< HEAD
 +#define __wait_event_interruptible(wq, condition, ret)			\
 +do {									\
 +	DEFINE_WAIT(__wait);						\
 +									\
 +	for (;;) {							\
 +		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
 +		if (condition)						\
 +			break;						\
 +		if (!signal_pending(current)) {				\
 +			schedule();					\
 +			continue;					\
 +		}							\
 +		ret = -ERESTARTSYS;					\
 +		break;							\
 +	}								\
 +	finish_wait(&wq, &__wait);					\
 +} while (0)
++=======
+ #define __wait_event_interruptible(wq, condition)			\
+ 	___wait_event(wq, condition, TASK_INTERRUPTIBLE, 0, 0,		\
+ 		      schedule())
++>>>>>>> 35a2af94c7ce (sched/wait: Make the __wait_event*() interface more friendly)
  
  /**
   * wait_event_interruptible - sleep until a condition gets true
@@@ -288,27 -302,10 +344,34 @@@
  	__ret;								\
  })
  
++<<<<<<< HEAD
 +#define __wait_event_interruptible_timeout(wq, condition, ret)		\
 +do {									\
 +	DEFINE_WAIT(__wait);						\
 +									\
 +	for (;;) {							\
 +		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
 +		if (condition)						\
 +			break;						\
 +		if (!signal_pending(current)) {				\
 +			ret = schedule_timeout(ret);			\
 +			if (!ret)					\
 +				break;					\
 +			continue;					\
 +		}							\
 +		ret = -ERESTARTSYS;					\
 +		break;							\
 +	}								\
 +	if (!ret && (condition))					\
 +		ret = 1;						\
 +	finish_wait(&wq, &__wait);					\
 +} while (0)
++=======
+ #define __wait_event_interruptible_timeout(wq, condition, timeout)	\
+ 	___wait_event(wq, ___wait_cond_timeout(condition),		\
+ 		      TASK_INTERRUPTIBLE, 0, timeout,			\
+ 		      __ret = schedule_timeout(__ret))
++>>>>>>> 35a2af94c7ce (sched/wait: Make the __wait_event*() interface more friendly)
  
  /**
   * wait_event_interruptible_timeout - sleep until a condition gets true or a timeout elapses
@@@ -350,15 -347,7 +414,19 @@@
  				       current->timer_slack_ns,		\
  				       HRTIMER_MODE_REL);		\
  									\
++<<<<<<< HEAD
 +	for (;;) {							\
 +		prepare_to_wait(&wq, &__wait, state);			\
 +		if (condition)						\
 +			break;						\
 +		if (state == TASK_INTERRUPTIBLE &&			\
 +		    signal_pending(current)) {				\
 +			__ret = -ERESTARTSYS;				\
 +			break;						\
 +		}							\
++=======
+ 	__ret = ___wait_event(wq, condition, state, 0, 0,		\
++>>>>>>> 35a2af94c7ce (sched/wait: Make the __wait_event*() interface more friendly)
  		if (!__t.task) {					\
  			__ret = -ETIME;					\
  			break;						\
@@@ -422,27 -409,9 +490,33 @@@
  	__ret;								\
  })
  
++<<<<<<< HEAD
 +#define __wait_event_interruptible_exclusive(wq, condition, ret)	\
 +do {									\
 +	DEFINE_WAIT(__wait);						\
 +									\
 +	for (;;) {							\
 +		prepare_to_wait_exclusive(&wq, &__wait,			\
 +					TASK_INTERRUPTIBLE);		\
 +		if (condition) {					\
 +			finish_wait(&wq, &__wait);			\
 +			break;						\
 +		}							\
 +		if (!signal_pending(current)) {				\
 +			schedule();					\
 +			continue;					\
 +		}							\
 +		ret = -ERESTARTSYS;					\
 +		abort_exclusive_wait(&wq, &__wait, 			\
 +				TASK_INTERRUPTIBLE, NULL);		\
 +		break;							\
 +	}								\
 +} while (0)
++=======
+ #define __wait_event_interruptible_exclusive(wq, condition)		\
+ 	___wait_event(wq, condition, TASK_INTERRUPTIBLE, 1, 0,		\
+ 		      schedule())
++>>>>>>> 35a2af94c7ce (sched/wait: Make the __wait_event*() interface more friendly)
  
  #define wait_event_interruptible_exclusive(wq, condition)		\
  ({									\
@@@ -601,23 -570,8 +675,28 @@@
  
  
  
++<<<<<<< HEAD
 +#define __wait_event_killable(wq, condition, ret)			\
 +do {									\
 +	DEFINE_WAIT(__wait);						\
 +									\
 +	for (;;) {							\
 +		prepare_to_wait(&wq, &__wait, TASK_KILLABLE);		\
 +		if (condition)						\
 +			break;						\
 +		if (!fatal_signal_pending(current)) {			\
 +			schedule();					\
 +			continue;					\
 +		}							\
 +		ret = -ERESTARTSYS;					\
 +		break;							\
 +	}								\
 +	finish_wait(&wq, &__wait);					\
 +} while (0)
++=======
+ #define __wait_event_killable(wq, condition)				\
+ 	___wait_event(wq, condition, TASK_KILLABLE, 0, 0, schedule())
++>>>>>>> 35a2af94c7ce (sched/wait: Make the __wait_event*() interface more friendly)
  
  /**
   * wait_event_killable - sleep until a condition gets true
@@@ -644,20 -598,11 +723,28 @@@
  
  
  #define __wait_event_lock_irq(wq, condition, lock, cmd)			\
++<<<<<<< HEAD
 +do {									\
 +	DEFINE_WAIT(__wait);						\
 +									\
 +	for (;;) {							\
 +		prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);	\
 +		if (condition)						\
 +			break;						\
 +		spin_unlock_irq(&lock);					\
 +		cmd;							\
 +		schedule();						\
 +		spin_lock_irq(&lock);					\
 +	}								\
 +	finish_wait(&wq, &__wait);					\
 +} while (0)
++=======
+ 	(void)___wait_event(wq, condition, TASK_UNINTERRUPTIBLE, 0, 0,	\
+ 			    spin_unlock_irq(&lock);			\
+ 			    cmd;					\
+ 			    schedule();					\
+ 			    spin_lock_irq(&lock))
++>>>>>>> 35a2af94c7ce (sched/wait: Make the __wait_event*() interface more friendly)
  
  /**
   * wait_event_lock_irq_cmd - sleep until a condition gets true. The
@@@ -717,26 -662,12 +804,35 @@@ do {									
  } while (0)
  
  
++<<<<<<< HEAD
 +#define __wait_event_interruptible_lock_irq(wq, condition,		\
 +					    lock, ret, cmd)		\
 +do {									\
 +	DEFINE_WAIT(__wait);						\
 +									\
 +	for (;;) {							\
 +		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
 +		if (condition)						\
 +			break;						\
 +		if (signal_pending(current)) {				\
 +			ret = -ERESTARTSYS;				\
 +			break;						\
 +		}							\
 +		spin_unlock_irq(&lock);					\
 +		cmd;							\
 +		schedule();						\
 +		spin_lock_irq(&lock);					\
 +	}								\
 +	finish_wait(&wq, &__wait);					\
 +} while (0)
++=======
+ #define __wait_event_interruptible_lock_irq(wq, condition, lock, cmd)	\
+ 	___wait_event(wq, condition, TASK_INTERRUPTIBLE, 0, 0,	   	\
+ 		      spin_unlock_irq(&lock);				\
+ 		      cmd;						\
+ 		      schedule();					\
+ 		      spin_lock_irq(&lock))
++>>>>>>> 35a2af94c7ce (sched/wait: Make the __wait_event*() interface more friendly)
  
  /**
   * wait_event_interruptible_lock_irq_cmd - sleep until a condition gets true.
@@@ -805,27 -734,13 +899,37 @@@
  	__ret;								\
  })
  
++<<<<<<< HEAD
 +#define __wait_event_interruptible_lock_irq_timeout(wq, condition,	\
 +						    lock, ret)		\
 +do {									\
 +	DEFINE_WAIT(__wait);						\
 +									\
 +	for (;;) {							\
 +		prepare_to_wait(&wq, &__wait, TASK_INTERRUPTIBLE);	\
 +		if (condition)						\
 +			break;						\
 +		if (signal_pending(current)) {				\
 +			ret = -ERESTARTSYS;				\
 +			break;						\
 +		}							\
 +		spin_unlock_irq(&lock);					\
 +		ret = schedule_timeout(ret);				\
 +		spin_lock_irq(&lock);					\
 +		if (!ret)						\
 +			break;						\
 +	}								\
 +	finish_wait(&wq, &__wait);					\
 +} while (0)
++=======
+ #define __wait_event_interruptible_lock_irq_timeout(wq, condition, 	\
+ 						    lock, timeout) 	\
+ 	___wait_event(wq, ___wait_cond_timeout(condition),		\
+ 		      TASK_INTERRUPTIBLE, 0, ret,	      		\
+ 		      spin_unlock_irq(&lock);				\
+ 		      __ret = schedule_timeout(__ret);			\
+ 		      spin_lock_irq(&lock));
++>>>>>>> 35a2af94c7ce (sched/wait: Make the __wait_event*() interface more friendly)
  
  /**
   * wait_event_interruptible_lock_irq_timeout - sleep until a condition gets true or a timeout elapses.
diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 6fa198db8999..a4f61558cd7d 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -172,8 +172,9 @@ int rtlx_open(int index, int can_sleep)
 	if (rtlx == NULL) {
 		if( (p = vpe_get_shared(tclimit)) == NULL) {
 		    if (can_sleep) {
-			__wait_event_interruptible(channel_wqs[index].lx_queue,
-				(p = vpe_get_shared(tclimit)), ret);
+			ret = __wait_event_interruptible(
+					channel_wqs[index].lx_queue,
+					(p = vpe_get_shared(tclimit)));
 			if (ret)
 				goto out_fail;
 		    } else {
@@ -263,11 +264,10 @@ unsigned int rtlx_read_poll(int index, int can_sleep)
 	/* data available to read? */
 	if (chan->lx_read == chan->lx_write) {
 		if (can_sleep) {
-			int ret = 0;
-
-			__wait_event_interruptible(channel_wqs[index].lx_queue,
+			int ret = __wait_event_interruptible(
+				channel_wqs[index].lx_queue,
 				(chan->lx_read != chan->lx_write) ||
-				sp_stopping, ret);
+				sp_stopping);
 			if (ret)
 				return ret;
 
@@ -441,14 +441,13 @@ static ssize_t file_write(struct file *file, const char __user * buffer,
 
 	/* any space left... */
 	if (!rtlx_write_poll(minor)) {
-		int ret = 0;
+		int ret;
 
 		if (file->f_flags & O_NONBLOCK)
 			return -EAGAIN;
 
-		__wait_event_interruptible(channel_wqs[minor].rt_queue,
-					   rtlx_write_poll(minor),
-					   ret);
+		ret = __wait_event_interruptible(channel_wqs[minor].rt_queue,
+					   rtlx_write_poll(minor));
 		if (ret)
 			return ret;
 	}
* Unmerged path include/linux/tty.h
* Unmerged path include/linux/wait.h
diff --git a/net/irda/af_irda.c b/net/irda/af_irda.c
index a5e62ef57155..de7db23049f1 100644
--- a/net/irda/af_irda.c
+++ b/net/irda/af_irda.c
@@ -2559,9 +2559,8 @@ bed:
 				  jiffies + msecs_to_jiffies(val));
 
 			/* Wait for IR-LMP to call us back */
-			__wait_event_interruptible(self->query_wait,
-			      (self->cachedaddr != 0 || self->errno == -ETIME),
-						   err);
+			err = __wait_event_interruptible(self->query_wait,
+			      (self->cachedaddr != 0 || self->errno == -ETIME));
 
 			/* If watchdog is still activated, kill it! */
 			del_timer(&(self->watchdog));
diff --git a/net/netfilter/ipvs/ip_vs_sync.c b/net/netfilter/ipvs/ip_vs_sync.c
index f6046d9af8d3..0942e60a7851 100644
--- a/net/netfilter/ipvs/ip_vs_sync.c
+++ b/net/netfilter/ipvs/ip_vs_sync.c
@@ -1624,12 +1624,9 @@ static int sync_thread_master(void *data)
 			continue;
 		}
 		while (ip_vs_send_sync_msg(tinfo->sock, sb->mesg) < 0) {
-			int ret = 0;
-
-			__wait_event_interruptible(*sk_sleep(sk),
+			int ret = __wait_event_interruptible(*sk_sleep(sk),
 						   sock_writeable(sk) ||
-						   kthread_should_stop(),
-						   ret);
+						   kthread_should_stop());
 			if (unlikely(kthread_should_stop()))
 				goto done;
 		}
