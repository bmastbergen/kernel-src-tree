hyperv: Fix error return code in netvsc_init_buf()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Wei Yongjun <yongjun_wei@trendmicro.com.cn>
commit dd1d3f8f9920926aa426589e542eed6bf58b7354
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/dd1d3f8f.failed

Fix to return -ENOMEM from the kalloc error handling
case instead of 0.

	Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
	Reviewed-by: Haiyang Zhang <haiyangz@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit dd1d3f8f9920926aa426589e542eed6bf58b7354)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc.c
diff --cc drivers/net/hyperv/netvsc.c
index 9cc0753cff9d,d97d5f39a04e..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -249,6 -301,88 +249,91 @@@ static int netvsc_init_recv_buf(struct 
  		goto cleanup;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* Now setup the send buffer.
+ 	 */
+ 	net_device->send_buf =
+ 		(void *)__get_free_pages(GFP_KERNEL|__GFP_ZERO,
+ 					 get_order(net_device->send_buf_size));
+ 	if (!net_device->send_buf) {
+ 		netdev_err(ndev, "unable to allocate send "
+ 			   "buffer of size %d\n", net_device->send_buf_size);
+ 		ret = -ENOMEM;
+ 		goto cleanup;
+ 	}
+ 
+ 	/* Establish the gpadl handle for this buffer on this
+ 	 * channel.  Note: This call uses the vmbus connection rather
+ 	 * than the channel to establish the gpadl handle.
+ 	 */
+ 	ret = vmbus_establish_gpadl(device->channel, net_device->send_buf,
+ 				    net_device->send_buf_size,
+ 				    &net_device->send_buf_gpadl_handle);
+ 	if (ret != 0) {
+ 		netdev_err(ndev,
+ 			   "unable to establish send buffer's gpadl\n");
+ 		goto cleanup;
+ 	}
+ 
+ 	/* Notify the NetVsp of the gpadl handle */
+ 	init_packet = &net_device->channel_init_pkt;
+ 	memset(init_packet, 0, sizeof(struct nvsp_message));
+ 	init_packet->hdr.msg_type = NVSP_MSG1_TYPE_SEND_SEND_BUF;
+ 	init_packet->msg.v1_msg.send_recv_buf.gpadl_handle =
+ 		net_device->send_buf_gpadl_handle;
+ 	init_packet->msg.v1_msg.send_recv_buf.id = 0;
+ 
+ 	/* Send the gpadl notification request */
+ 	ret = vmbus_sendpacket(device->channel, init_packet,
+ 			       sizeof(struct nvsp_message),
+ 			       (unsigned long)init_packet,
+ 			       VM_PKT_DATA_INBAND,
+ 			       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);
+ 	if (ret != 0) {
+ 		netdev_err(ndev,
+ 			   "unable to send send buffer's gpadl to netvsp\n");
+ 		goto cleanup;
+ 	}
+ 
+ 	t = wait_for_completion_timeout(&net_device->channel_init_wait, 5*HZ);
+ 	BUG_ON(t == 0);
+ 
+ 	/* Check the response */
+ 	if (init_packet->msg.v1_msg.
+ 	    send_send_buf_complete.status != NVSP_STAT_SUCCESS) {
+ 		netdev_err(ndev, "Unable to complete send buffer "
+ 			   "initialization with NetVsp - status %d\n",
+ 			   init_packet->msg.v1_msg.
+ 			   send_recv_buf_complete.status);
+ 		ret = -EINVAL;
+ 		goto cleanup;
+ 	}
+ 
+ 	/* Parse the response */
+ 	net_device->send_section_size = init_packet->msg.
+ 				v1_msg.send_send_buf_complete.section_size;
+ 
+ 	/* Section count is simply the size divided by the section size.
+ 	 */
+ 	net_device->send_section_cnt =
+ 		net_device->send_buf_size/net_device->send_section_size;
+ 
+ 	dev_info(&device->device, "Send section size: %d, Section count:%d\n",
+ 		 net_device->send_section_size, net_device->send_section_cnt);
+ 
+ 	/* Setup state for managing the send buffer. */
+ 	net_device->map_words = DIV_ROUND_UP(net_device->send_section_cnt,
+ 					     BITS_PER_LONG);
+ 
+ 	net_device->send_section_map =
+ 		kzalloc(net_device->map_words * sizeof(ulong), GFP_KERNEL);
+ 	if (net_device->send_section_map == NULL) {
+ 		ret = -ENOMEM;
+ 		goto cleanup;
+ 	}
+ 
++>>>>>>> dd1d3f8f9920 (hyperv: Fix error return code in netvsc_init_buf())
  	goto exit;
  
  cleanup:
* Unmerged path drivers/net/hyperv/netvsc.c
