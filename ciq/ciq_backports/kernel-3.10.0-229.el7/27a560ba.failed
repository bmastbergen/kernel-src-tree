Input: alps - v7: document the v7 touchpad packet protocol

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [input] alps: v7 - document the v7 touchpad packet protocol (Benjamin Tissoires) [1107819]
Rebuild_FUZZ: 88.07%
commit-author Hans de Goede <hdegoede@redhat.com>
commit 27a560ba1d4f0a07a36e1de2cae839abe776e8f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/27a560ba.failed

Add a table documenting where all the bits are in the v7 touchpad packets.

	Signed-off-by: Hans de Goede <hdegoede@redhat.com>
	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
(cherry picked from commit 27a560ba1d4f0a07a36e1de2cae839abe776e8f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/input/mouse/alps.c
diff --cc drivers/input/mouse/alps.c
index 566ef5285082,0faea6df228b..000000000000
--- a/drivers/input/mouse/alps.c
+++ b/drivers/input/mouse/alps.c
@@@ -842,6 -846,249 +842,252 @@@ static void alps_process_packet_v4(stru
  	alps_report_semi_mt_data(psmouse, f->fingers);
  }
  
++<<<<<<< HEAD
++=======
+ static bool alps_is_valid_package_v7(struct psmouse *psmouse)
+ {
+ 	switch (psmouse->pktcnt) {
+ 	case 3:
+ 		return (psmouse->packet[2] & 0x40) == 0x40;
+ 	case 4:
+ 		return (psmouse->packet[3] & 0x48) == 0x48;
+ 	case 6:
+ 		return (psmouse->packet[5] & 0x40) == 0x00;
+ 	}
+ 	return true;
+ }
+ 
+ static unsigned char alps_get_packet_id_v7(char *byte)
+ {
+ 	unsigned char packet_id;
+ 
+ 	if (byte[4] & 0x40)
+ 		packet_id = V7_PACKET_ID_TWO;
+ 	else if (byte[4] & 0x01)
+ 		packet_id = V7_PACKET_ID_MULTI;
+ 	else if ((byte[0] & 0x10) && !(byte[4] & 0x43))
+ 		packet_id = V7_PACKET_ID_NEW;
+ 	else if (byte[1] == 0x00 && byte[4] == 0x00)
+ 		packet_id = V7_PACKET_ID_IDLE;
+ 	else
+ 		packet_id = V7_PACKET_ID_UNKNOWN;
+ 
+ 	return packet_id;
+ }
+ 
+ static void alps_get_finger_coordinate_v7(struct input_mt_pos *mt,
+ 					  unsigned char *pkt,
+ 					  unsigned char pkt_id)
+ {
+ 	/*
+ 	 *       packet-fmt    b7   b6    b5   b4   b3   b2   b1   b0
+ 	 * Byte0 TWO & MULTI    L    1     R    M    1 Y0-2 Y0-1 Y0-0
+ 	 * Byte0 NEW            L    1  X1-5    1    1 Y0-2 Y0-1 Y0-0
+ 	 * Byte1            Y0-10 Y0-9  Y0-8 Y0-7 Y0-6 Y0-5 Y0-4 Y0-3
+ 	 * Byte2            X0-11    1 X0-10 X0-9 X0-8 X0-7 X0-6 X0-5
+ 	 * Byte3            X1-11    1  X0-4 X0-3    1 X0-2 X0-1 X0-0
+ 	 * Byte4 TWO        X1-10  TWO  X1-9 X1-8 X1-7 X1-6 X1-5 X1-4
+ 	 * Byte4 MULTI      X1-10  TWO  X1-9 X1-8 X1-7 X1-6 Y1-5    1
+ 	 * Byte4 NEW        X1-10  TWO  X1-9 X1-8 X1-7 X1-6    0    0
+ 	 * Byte5 TWO & NEW  Y1-10    0  Y1-9 Y1-8 Y1-7 Y1-6 Y1-5 Y1-4
+ 	 * Byte5 MULTI      Y1-10    0  Y1-9 Y1-8 Y1-7 Y1-6  F-1  F-0
+ 	 * L:         Left button
+ 	 * R / M:     Non-clickpads: Right / Middle button
+ 	 *            Clickpads: When > 2 fingers are down, and some fingers
+ 	 *            are in the button area, then the 2 coordinates reported
+ 	 *            are for fingers outside the button area and these report
+ 	 *            extra fingers being present in the right / left button
+ 	 *            area. Note these fingers are not added to the F field!
+ 	 *            so if a TWO packet is received and R = 1 then there are
+ 	 *            3 fingers down, etc.
+ 	 * TWO:       1: Two touches present, byte 0/4/5 are in TWO fmt
+ 	 *            0: If byte 4 bit 0 is 1, then byte 0/4/5 are in MULTI fmt
+ 	 *               otherwise byte 0 bit 4 must be set and byte 0/4/5 are
+ 	 *               in NEW fmt
+ 	 * F:         Number of fingers - 3, 0 means 3 fingers, 1 means 4 ...
+ 	 */
+ 
+ 	mt[0].x = ((pkt[2] & 0x80) << 4);
+ 	mt[0].x |= ((pkt[2] & 0x3F) << 5);
+ 	mt[0].x |= ((pkt[3] & 0x30) >> 1);
+ 	mt[0].x |= (pkt[3] & 0x07);
+ 	mt[0].y = (pkt[1] << 3) | (pkt[0] & 0x07);
+ 
+ 	mt[1].x = ((pkt[3] & 0x80) << 4);
+ 	mt[1].x |= ((pkt[4] & 0x80) << 3);
+ 	mt[1].x |= ((pkt[4] & 0x3F) << 4);
+ 	mt[1].y = ((pkt[5] & 0x80) << 3);
+ 	mt[1].y |= ((pkt[5] & 0x3F) << 4);
+ 
+ 	switch (pkt_id) {
+ 	case V7_PACKET_ID_TWO:
+ 		mt[1].x &= ~0x000F;
+ 		mt[1].y |= 0x000F;
+ 		break;
+ 
+ 	case V7_PACKET_ID_MULTI:
+ 		mt[1].x &= ~0x003F;
+ 		mt[1].y &= ~0x0020;
+ 		mt[1].y |= ((pkt[4] & 0x02) << 4);
+ 		mt[1].y |= 0x001F;
+ 		break;
+ 
+ 	case V7_PACKET_ID_NEW:
+ 		mt[1].x &= ~0x003F;
+ 		mt[1].x |= (pkt[0] & 0x20);
+ 		mt[1].y |= 0x000F;
+ 		break;
+ 	}
+ 
+ 	mt[0].y = 0x7FF - mt[0].y;
+ 	mt[1].y = 0x7FF - mt[1].y;
+ }
+ 
+ static int alps_get_mt_count(struct input_mt_pos *mt)
+ {
+ 	int i, fingers = 0;
+ 
+ 	for (i = 0; i < MAX_TOUCHES; i++) {
+ 		if (mt[i].x != 0 || mt[i].y != 0)
+ 			fingers++;
+ 	}
+ 
+ 	return fingers;
+ }
+ 
+ static int alps_decode_packet_v7(struct alps_fields *f,
+ 				  unsigned char *p,
+ 				  struct psmouse *psmouse)
+ {
+ 	struct alps_data *priv = psmouse->private;
+ 	unsigned char pkt_id;
+ 
+ 	pkt_id = alps_get_packet_id_v7(p);
+ 	if (pkt_id == V7_PACKET_ID_IDLE)
+ 		return 0;
+ 	if (pkt_id == V7_PACKET_ID_UNKNOWN)
+ 		return -1;
+ 	/*
+ 	 * NEW packets are send to indicate a discontinuity in the finger
+ 	 * coordinate reporting. Specifically a finger may have moved from
+ 	 * slot 0 to 1 or vice versa. INPUT_MT_TRACK takes care of this for
+ 	 * us.
+ 	 *
+ 	 * NEW packets have 3 problems:
+ 	 * 1) They do not contain middle / right button info (on non clickpads)
+ 	 *    this can be worked around by preserving the old button state
+ 	 * 2) They do not contain an accurate fingercount, and they are
+ 	 *    typically send when the number of fingers changes. We cannot use
+ 	 *    the old finger count as that may mismatch with the amount of
+ 	 *    touch coordinates we've available in the NEW packet
+ 	 * 3) Their x data for the second touch is inaccurate leading to
+ 	 *    a possible jump of the x coordinate by 16 units when the first
+ 	 *    non NEW packet comes in
+ 	 * Since problems 2 & 3 cannot be worked around, just ignore them.
+ 	 */
+ 	if (pkt_id == V7_PACKET_ID_NEW)
+ 		return 1;
+ 
+ 	alps_get_finger_coordinate_v7(f->mt, p, pkt_id);
+ 
+ 	if (pkt_id == V7_PACKET_ID_TWO)
+ 		f->fingers = alps_get_mt_count(f->mt);
+ 	else /* pkt_id == V7_PACKET_ID_MULTI */
+ 		f->fingers = 3 + (p[5] & 0x03);
+ 
+ 	f->left = (p[0] & 0x80) >> 7;
+ 	if (priv->flags & ALPS_BUTTONPAD) {
+ 		if (p[0] & 0x20)
+ 			f->fingers++;
+ 		if (p[0] & 0x10)
+ 			f->fingers++;
+ 	} else {
+ 		f->right = (p[0] & 0x20) >> 5;
+ 		f->middle = (p[0] & 0x10) >> 4;
+ 	}
+ 
+ 	/* Sometimes a single touch is reported in mt[1] rather then mt[0] */
+ 	if (f->fingers == 1 && f->mt[0].x == 0 && f->mt[0].y == 0) {
+ 		f->mt[0].x = f->mt[1].x;
+ 		f->mt[0].y = f->mt[1].y;
+ 		f->mt[1].x = 0;
+ 		f->mt[1].y = 0;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void alps_process_trackstick_packet_v7(struct psmouse *psmouse)
+ {
+ 	struct alps_data *priv = psmouse->private;
+ 	unsigned char *packet = psmouse->packet;
+ 	struct input_dev *dev2 = priv->dev2;
+ 	int x, y, z, left, right, middle;
+ 
+ 	/*
+ 	 *        b7 b6 b5 b4 b3 b2 b1 b0
+ 	 * Byte0   0  1  0  0  1  0  0  0
+ 	 * Byte1   1  1  *  *  1  M  R  L
+ 	 * Byte2  X7  1 X5 X4 X3 X2 X1 X0
+ 	 * Byte3  Z6  1 Y6 X6  1 Y2 Y1 Y0
+ 	 * Byte4  Y7  0 Y5 Y4 Y3  1  1  0
+ 	 * Byte5 T&P  0 Z5 Z4 Z3 Z2 Z1 Z0
+ 	 * M / R / L: Middle / Right / Left button
+ 	 */
+ 
+ 	x = ((packet[2] & 0xbf)) | ((packet[3] & 0x10) << 2);
+ 	y = (packet[3] & 0x07) | (packet[4] & 0xb8) |
+ 	    ((packet[3] & 0x20) << 1);
+ 	z = (packet[5] & 0x3f) | ((packet[3] & 0x80) >> 1);
+ 
+ 	left = (packet[1] & 0x01);
+ 	right = (packet[1] & 0x02) >> 1;
+ 	middle = (packet[1] & 0x04) >> 2;
+ 
+ 	/* Divide 2 since trackpoint's speed is too fast */
+ 	input_report_rel(dev2, REL_X, (char)x / 2);
+ 	input_report_rel(dev2, REL_Y, -((char)y / 2));
+ 
+ 	input_report_key(dev2, BTN_LEFT, left);
+ 	input_report_key(dev2, BTN_RIGHT, right);
+ 	input_report_key(dev2, BTN_MIDDLE, middle);
+ 
+ 	input_sync(dev2);
+ }
+ 
+ static void alps_process_touchpad_packet_v7(struct psmouse *psmouse)
+ {
+ 	struct alps_data *priv = psmouse->private;
+ 	struct input_dev *dev = psmouse->dev;
+ 	struct alps_fields *f = &priv->f;
+ 
+ 	memset(f, 0, sizeof(*f));
+ 
+ 	if (priv->decode_fields(f, psmouse->packet, psmouse))
+ 		return;
+ 
+ 	alps_report_mt_data(psmouse, alps_get_mt_count(f->mt));
+ 
+ 	input_mt_report_finger_count(dev, f->fingers);
+ 
+ 	input_report_key(dev, BTN_LEFT, f->left);
+ 	input_report_key(dev, BTN_RIGHT, f->right);
+ 	input_report_key(dev, BTN_MIDDLE, f->middle);
+ 
+ 	input_sync(dev);
+ }
+ 
+ static void alps_process_packet_v7(struct psmouse *psmouse)
+ {
+ 	unsigned char *packet = psmouse->packet;
+ 
+ 	if (packet[0] == 0x48 && (packet[4] & 0x47) == 0x06)
+ 		alps_process_trackstick_packet_v7(psmouse);
+ 	else
+ 		alps_process_touchpad_packet_v7(psmouse);
+ }
+ 
++>>>>>>> 27a560ba1d4f (Input: alps - v7: document the v7 touchpad packet protocol)
  static void alps_report_bare_ps2_packet(struct psmouse *psmouse,
  					unsigned char packet[],
  					bool report_buttons)
* Unmerged path drivers/input/mouse/alps.c
