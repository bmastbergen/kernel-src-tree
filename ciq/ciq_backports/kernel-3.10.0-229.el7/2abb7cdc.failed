udp: Add support for doing checksum unnecessary conversion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Tom Herbert <therbert@google.com>
commit 2abb7cdc0dc84e99b76ef983a1ae1978922aa9b3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2abb7cdc.failed

Add support for doing CHECKSUM_UNNECESSARY to CHECKSUM_COMPLETE
conversion in UDP tunneling path.

In the normal UDP path, we call skb_checksum_try_convert after locating
the UDP socket. The check is that checksum conversion is enabled for
the socket (new flag in UDP socket) and that checksum field is
non-zero.

In the UDP GRO path, we call skb_gro_checksum_try_convert after
checksum is validated and checksum field is non-zero. Since this is
already in GRO we assume that checksum conversion is always wanted.

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2abb7cdc0dc84e99b76ef983a1ae1978922aa9b3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/udp.h
#	net/ipv4/udp.c
#	net/ipv6/udp.c
diff --cc include/linux/udp.h
index 42278bbf7a88,ee3277593222..000000000000
--- a/include/linux/udp.h
+++ b/include/linux/udp.h
@@@ -47,7 -47,13 +47,17 @@@ struct udp_sock 
  #define udp_portaddr_node	inet.sk.__sk_common.skc_portaddr_node
  	int		 pending;	/* Any pending frames ? */
  	unsigned int	 corkflag;	/* Cork is required */
++<<<<<<< HEAD
 +  	__u16		 encap_type;	/* Is this an Encapsulation socket? */
++=======
+ 	__u8		 encap_type;	/* Is this an Encapsulation socket? */
+ 	unsigned char	 no_check6_tx:1,/* Send zero UDP6 checksums on TX? */
+ 			 no_check6_rx:1,/* Allow zero UDP6 checksums on RX? */
+ 			 convert_csum:1;/* On receive, convert checksum
+ 					 * unnecessary to checksum complete
+ 					 * if possible.
+ 					 */
++>>>>>>> 2abb7cdc0dc8 (udp: Add support for doing checksum unnecessary conversion)
  	/*
  	 * Following member retains the information to create a UDP header
  	 * when the socket is uncorked.
@@@ -76,6 -82,36 +86,39 @@@ static inline struct udp_sock *udp_sk(c
  	return (struct udp_sock *)sk;
  }
  
++<<<<<<< HEAD
++=======
+ static inline void udp_set_no_check6_tx(struct sock *sk, bool val)
+ {
+ 	udp_sk(sk)->no_check6_tx = val;
+ }
+ 
+ static inline void udp_set_no_check6_rx(struct sock *sk, bool val)
+ {
+ 	udp_sk(sk)->no_check6_rx = val;
+ }
+ 
+ static inline bool udp_get_no_check6_tx(struct sock *sk)
+ {
+ 	return udp_sk(sk)->no_check6_tx;
+ }
+ 
+ static inline bool udp_get_no_check6_rx(struct sock *sk)
+ {
+ 	return udp_sk(sk)->no_check6_rx;
+ }
+ 
+ static inline void udp_set_convert_csum(struct sock *sk, bool val)
+ {
+ 	udp_sk(sk)->convert_csum = val;
+ }
+ 
+ static inline bool udp_get_convert_csum(struct sock *sk)
+ {
+ 	return udp_sk(sk)->convert_csum;
+ }
+ 
++>>>>>>> 2abb7cdc0dc8 (udp: Add support for doing checksum unnecessary conversion)
  #define udp_portaddr_for_each_entry(__sk, node, list) \
  	hlist_nulls_for_each_entry(__sk, node, list, __sk_common.skc_portaddr_node)
  
diff --cc net/ipv4/udp.c
index 457eeb17c6b5,0da3849fd35b..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -1740,7 -1788,10 +1740,14 @@@ int __udp4_lib_rcv(struct sk_buff *skb
  	if (sk != NULL) {
  		int ret;
  
++<<<<<<< HEAD
 +		sk_mark_napi_id(sk, skb);
++=======
+ 		if (udp_sk(sk)->convert_csum && uh->check && !IS_UDPLITE(sk))
+ 			skb_checksum_try_convert(skb, IPPROTO_UDP, uh->check,
+ 						 inet_compute_pseudo);
+ 
++>>>>>>> 2abb7cdc0dc8 (udp: Add support for doing checksum unnecessary conversion)
  		ret = udp_queue_rcv_skb(sk, skb);
  		sock_put(sk);
  
diff --cc net/ipv6/udp.c
index d21783b5711c,f6ba535b6feb..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -839,7 -885,16 +839,20 @@@ int __udp6_lib_rcv(struct sk_buff *skb
  	if (sk != NULL) {
  		int ret;
  
++<<<<<<< HEAD
 +		sk_mark_napi_id(sk, skb);
++=======
+ 		if (!uh->check && !udp_sk(sk)->no_check6_rx) {
+ 			sock_put(sk);
+ 			udp6_csum_zero_error(skb);
+ 			goto csum_error;
+ 		}
+ 
+ 		if (udp_sk(sk)->convert_csum && uh->check && !IS_UDPLITE(sk))
+ 			skb_checksum_try_convert(skb, IPPROTO_UDP, uh->check,
+ 						 ip6_compute_pseudo);
+ 
++>>>>>>> 2abb7cdc0dc8 (udp: Add support for doing checksum unnecessary conversion)
  		ret = udpv6_queue_rcv_skb(sk, skb);
  		sock_put(sk);
  
* Unmerged path include/linux/udp.h
* Unmerged path net/ipv4/udp.c
diff --git a/net/ipv4/udp_offload.c b/net/ipv4/udp_offload.c
index 1d2f12fcbc52..8ea29fa9d2c2 100644
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@ -213,16 +213,25 @@ static struct sk_buff **udp4_gro_receive(struct sk_buff **head,
 {
 	struct udphdr *uh = udp_gro_udphdr(skb);
 
-	/* Don't bother verifying checksum if we're going to flush anyway. */
-	if (unlikely(!uh) ||
-	    (!NAPI_GRO_CB(skb)->flush &&
-	     skb_gro_checksum_validate_zero_check(skb, IPPROTO_UDP, uh->check,
-						  inet_gro_compute_pseudo))) {
-		NAPI_GRO_CB(skb)->flush = 1;
-		return NULL;
-	}
+	if (unlikely(!uh))
+		goto flush;
 
+	/* Don't bother verifying checksum if we're going to flush anyway. */
+	if (!NAPI_GRO_CB(skb)->flush)
+		goto skip;
+
+	if (skb_gro_checksum_validate_zero_check(skb, IPPROTO_UDP, uh->check,
+						 inet_gro_compute_pseudo))
+		goto flush;
+	else if (uh->check)
+		skb_gro_checksum_try_convert(skb, IPPROTO_UDP, uh->check,
+					     inet_gro_compute_pseudo);
+skip:
 	return udp_gro_receive(head, skb, uh);
+
+flush:
+	NAPI_GRO_CB(skb)->flush = 1;
+	return NULL;
 }
 
 int udp_gro_complete(struct sk_buff *skb, int nhoff)
* Unmerged path net/ipv6/udp.c
diff --git a/net/ipv6/udp_offload.c b/net/ipv6/udp_offload.c
index 0d60f40e0d74..ba6e0d47fa94 100644
--- a/net/ipv6/udp_offload.c
+++ b/net/ipv6/udp_offload.c
@@ -134,16 +134,26 @@ static struct sk_buff **udp6_gro_receive(struct sk_buff **head,
 {
 	struct udphdr *uh = udp_gro_udphdr(skb);
 
+	if (unlikely(!uh))
+		goto flush;
+
 	/* Don't bother verifying checksum if we're going to flush anyway. */
-	if (unlikely(!uh) ||
-	    (!NAPI_GRO_CB(skb)->flush &&
-	     skb_gro_checksum_validate_zero_check(skb, IPPROTO_UDP, uh->check,
-						  ip6_gro_compute_pseudo))) {
-		NAPI_GRO_CB(skb)->flush = 1;
-		return NULL;
-	}
+	if (!NAPI_GRO_CB(skb)->flush)
+		goto skip;
 
+	if (skb_gro_checksum_validate_zero_check(skb, IPPROTO_UDP, uh->check,
+						 ip6_gro_compute_pseudo))
+		goto flush;
+	else if (uh->check)
+		skb_gro_checksum_try_convert(skb, IPPROTO_UDP, uh->check,
+					     ip6_gro_compute_pseudo);
+
+skip:
 	return udp_gro_receive(head, skb, uh);
+
+flush:
+	NAPI_GRO_CB(skb)->flush = 1;
+	return NULL;
 }
 
 int udp6_gro_complete(struct sk_buff *skb, int nhoff)
