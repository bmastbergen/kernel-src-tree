ext4: always check ext4_ext_find_extent result

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Dmitry Monakhov <dmonakhov@openvz.org>
commit a18ed359bdddcded4f97ff5e2f07793ff9336913
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a18ed359.failed

Where are some places where logic guaranties us that extent we are
searching exits, but this may not be true due to on-disk data
corruption. If such corruption happens we must prevent possible
null pointer dereferences.

	Signed-off-by: Dmitry Monakhov <dmonakhov@openvz.org>
	Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
(cherry picked from commit a18ed359bdddcded4f97ff5e2f07793ff9336913)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/extents.c
diff --cc fs/ext4/extents.c
index 97c5dbfbebda,64b400356cad..000000000000
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@@ -3654,6 -3666,66 +3659,69 @@@ static int ext4_split_unwritten_extents
  	return ext4_split_extent(handle, inode, path, map, split_flag, flags);
  }
  
++<<<<<<< HEAD
++=======
+ static int ext4_convert_initialized_extents(handle_t *handle,
+ 					    struct inode *inode,
+ 					    struct ext4_map_blocks *map,
+ 					    struct ext4_ext_path *path)
+ {
+ 	struct ext4_extent *ex;
+ 	ext4_lblk_t ee_block;
+ 	unsigned int ee_len;
+ 	int depth;
+ 	int err = 0;
+ 
+ 	depth = ext_depth(inode);
+ 	ex = path[depth].p_ext;
+ 	ee_block = le32_to_cpu(ex->ee_block);
+ 	ee_len = ext4_ext_get_actual_len(ex);
+ 
+ 	ext_debug("%s: inode %lu, logical"
+ 		"block %llu, max_blocks %u\n", __func__, inode->i_ino,
+ 		  (unsigned long long)ee_block, ee_len);
+ 
+ 	if (ee_block != map->m_lblk || ee_len > map->m_len) {
+ 		err = ext4_split_convert_extents(handle, inode, map, path,
+ 				EXT4_GET_BLOCKS_CONVERT_UNWRITTEN);
+ 		if (err < 0)
+ 			goto out;
+ 		ext4_ext_drop_refs(path);
+ 		path = ext4_ext_find_extent(inode, map->m_lblk, path, 0);
+ 		if (IS_ERR(path)) {
+ 			err = PTR_ERR(path);
+ 			goto out;
+ 		}
+ 		depth = ext_depth(inode);
+ 		ex = path[depth].p_ext;
+ 		if (!ex) {
+ 			EXT4_ERROR_INODE(inode, "unexpected hole at %lu",
+ 					 (unsigned long) map->m_lblk);
+ 			err = -EIO;
+ 			goto out;
+ 		}
+ 	}
+ 
+ 	err = ext4_ext_get_access(handle, inode, path + depth);
+ 	if (err)
+ 		goto out;
+ 	/* first mark the extent as uninitialized */
+ 	ext4_ext_mark_uninitialized(ex);
+ 
+ 	/* note: ext4_ext_correct_indexes() isn't needed here because
+ 	 * borders are not changed
+ 	 */
+ 	ext4_ext_try_to_merge(handle, inode, path, ex);
+ 
+ 	/* Mark modified extent as dirty */
+ 	err = ext4_ext_dirty(handle, inode, path + path->p_depth);
+ out:
+ 	ext4_ext_show_leaf(inode, path);
+ 	return err;
+ }
+ 
+ 
++>>>>>>> a18ed359bddd (ext4: always check ext4_ext_find_extent result)
  static int ext4_convert_unwritten_extents_endio(handle_t *handle,
  						struct inode *inode,
  						struct ext4_map_blocks *map,
* Unmerged path fs/ext4/extents.c
