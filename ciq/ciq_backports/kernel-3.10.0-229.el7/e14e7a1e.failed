KVM: PPC: Book3S PR: Expose TAR facility to guest

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/ppc: book3s/pr - Expose TAR facility to guest (David Gibson) [1123145 1123133 1123367]
Rebuild_FUZZ: 91.84%
commit-author Alexander Graf <agraf@suse.de>
commit e14e7a1e537d6e18f9c511f25c25c5efb7799fb5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e14e7a1e.failed

POWER8 implements a new register called TAR. This register has to be
enabled in FSCR and then from KVM's point of view is mere storage.

This patch enables the guest to use TAR.

	Signed-off-by: Alexander Graf <agraf@suse.de>
(cherry picked from commit e14e7a1e537d6e18f9c511f25c25c5efb7799fb5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/kvm_host.h
#	arch/powerpc/kernel/asm-offsets.c
#	arch/powerpc/kvm/book3s.c
#	arch/powerpc/kvm/book3s_hv.c
#	arch/powerpc/kvm/book3s_pr.c
diff --cc arch/powerpc/include/asm/kvm_host.h
index db69ef15e5ee,29fbb554af5c..000000000000
--- a/arch/powerpc/include/asm/kvm_host.h
+++ b/arch/powerpc/include/asm/kvm_host.h
@@@ -456,6 -449,9 +456,12 @@@ struct kvm_vcpu_arch 
  	ulong pc;
  	ulong ctr;
  	ulong lr;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PPC_BOOK3S
+ 	ulong tar;
+ #endif
++>>>>>>> e14e7a1e537d (KVM: PPC: Book3S PR: Expose TAR facility to guest)
  
  	ulong xer;
  	u32 cr;
diff --cc arch/powerpc/kernel/asm-offsets.c
index 79fa5c26d629,93e1465c8496..000000000000
--- a/arch/powerpc/kernel/asm-offsets.c
+++ b/arch/powerpc/kernel/asm-offsets.c
@@@ -437,6 -446,9 +437,12 @@@ int main(void
  	DEFINE(VCPU_XER, offsetof(struct kvm_vcpu, arch.xer));
  	DEFINE(VCPU_CTR, offsetof(struct kvm_vcpu, arch.ctr));
  	DEFINE(VCPU_LR, offsetof(struct kvm_vcpu, arch.lr));
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_PPC_BOOK3S
+ 	DEFINE(VCPU_TAR, offsetof(struct kvm_vcpu, arch.tar));
+ #endif
++>>>>>>> e14e7a1e537d (KVM: PPC: Book3S PR: Expose TAR facility to guest)
  	DEFINE(VCPU_CR, offsetof(struct kvm_vcpu, arch.cr));
  	DEFINE(VCPU_PC, offsetof(struct kvm_vcpu, arch.pc));
  #ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
diff --cc arch/powerpc/kvm/book3s.c
index be63f63c167b,4046a1a91a75..000000000000
--- a/arch/powerpc/kvm/book3s.c
+++ b/arch/powerpc/kvm/book3s.c
@@@ -561,6 -631,12 +561,15 @@@ int kvm_vcpu_ioctl_get_one_reg(struct k
  			val = get_reg_val(reg->id, kvmppc_xics_get_icp(vcpu));
  			break;
  #endif /* CONFIG_KVM_XICS */
++<<<<<<< HEAD
++=======
+ 		case KVM_REG_PPC_FSCR:
+ 			val = get_reg_val(reg->id, vcpu->arch.fscr);
+ 			break;
+ 		case KVM_REG_PPC_TAR:
+ 			val = get_reg_val(reg->id, vcpu->arch.tar);
+ 			break;
++>>>>>>> e14e7a1e537d (KVM: PPC: Book3S PR: Expose TAR facility to guest)
  		default:
  			r = -EINVAL;
  			break;
@@@ -651,6 -726,12 +660,15 @@@ int kvm_vcpu_ioctl_set_one_reg(struct k
  						set_reg_val(reg->id, val));
  			break;
  #endif /* CONFIG_KVM_XICS */
++<<<<<<< HEAD
++=======
+ 		case KVM_REG_PPC_FSCR:
+ 			vcpu->arch.fscr = set_reg_val(reg->id, val);
+ 			break;
+ 		case KVM_REG_PPC_TAR:
+ 			vcpu->arch.tar = set_reg_val(reg->id, val);
+ 			break;
++>>>>>>> e14e7a1e537d (KVM: PPC: Book3S PR: Expose TAR facility to guest)
  		default:
  			r = -EINVAL;
  			break;
diff --cc arch/powerpc/kvm/book3s_hv.c
index 14588bcd5db5,ee1d8ee5f1a7..000000000000
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@@ -836,6 -873,60 +836,63 @@@ int kvmppc_get_one_reg(struct kvm_vcpu 
  	case KVM_REG_PPC_SDAR:
  		*val = get_reg_val(id, vcpu->arch.sdar);
  		break;
++<<<<<<< HEAD
++=======
+ 	case KVM_REG_PPC_SIER:
+ 		*val = get_reg_val(id, vcpu->arch.sier);
+ 		break;
+ 	case KVM_REG_PPC_IAMR:
+ 		*val = get_reg_val(id, vcpu->arch.iamr);
+ 		break;
+ 	case KVM_REG_PPC_PSPB:
+ 		*val = get_reg_val(id, vcpu->arch.pspb);
+ 		break;
+ 	case KVM_REG_PPC_EBBHR:
+ 		*val = get_reg_val(id, vcpu->arch.ebbhr);
+ 		break;
+ 	case KVM_REG_PPC_EBBRR:
+ 		*val = get_reg_val(id, vcpu->arch.ebbrr);
+ 		break;
+ 	case KVM_REG_PPC_BESCR:
+ 		*val = get_reg_val(id, vcpu->arch.bescr);
+ 		break;
+ 	case KVM_REG_PPC_DPDES:
+ 		*val = get_reg_val(id, vcpu->arch.vcore->dpdes);
+ 		break;
+ 	case KVM_REG_PPC_DAWR:
+ 		*val = get_reg_val(id, vcpu->arch.dawr);
+ 		break;
+ 	case KVM_REG_PPC_DAWRX:
+ 		*val = get_reg_val(id, vcpu->arch.dawrx);
+ 		break;
+ 	case KVM_REG_PPC_CIABR:
+ 		*val = get_reg_val(id, vcpu->arch.ciabr);
+ 		break;
+ 	case KVM_REG_PPC_IC:
+ 		*val = get_reg_val(id, vcpu->arch.ic);
+ 		break;
+ 	case KVM_REG_PPC_VTB:
+ 		*val = get_reg_val(id, vcpu->arch.vtb);
+ 		break;
+ 	case KVM_REG_PPC_CSIGR:
+ 		*val = get_reg_val(id, vcpu->arch.csigr);
+ 		break;
+ 	case KVM_REG_PPC_TACR:
+ 		*val = get_reg_val(id, vcpu->arch.tacr);
+ 		break;
+ 	case KVM_REG_PPC_TCSCR:
+ 		*val = get_reg_val(id, vcpu->arch.tcscr);
+ 		break;
+ 	case KVM_REG_PPC_PID:
+ 		*val = get_reg_val(id, vcpu->arch.pid);
+ 		break;
+ 	case KVM_REG_PPC_ACOP:
+ 		*val = get_reg_val(id, vcpu->arch.acop);
+ 		break;
+ 	case KVM_REG_PPC_WORT:
+ 		*val = get_reg_val(id, vcpu->arch.wort);
+ 		break;
++>>>>>>> e14e7a1e537d (KVM: PPC: Book3S PR: Expose TAR facility to guest)
  	case KVM_REG_PPC_VPA_ADDR:
  		spin_lock(&vcpu->arch.vpa_update_lock);
  		*val = get_reg_val(id, vcpu->arch.vpa.next_gpa);
@@@ -917,6 -1079,63 +974,66 @@@ int kvmppc_set_one_reg(struct kvm_vcpu 
  	case KVM_REG_PPC_SDAR:
  		vcpu->arch.sdar = set_reg_val(id, *val);
  		break;
++<<<<<<< HEAD
++=======
+ 	case KVM_REG_PPC_SIER:
+ 		vcpu->arch.sier = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_IAMR:
+ 		vcpu->arch.iamr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_PSPB:
+ 		vcpu->arch.pspb = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_EBBHR:
+ 		vcpu->arch.ebbhr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_EBBRR:
+ 		vcpu->arch.ebbrr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_BESCR:
+ 		vcpu->arch.bescr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_DPDES:
+ 		vcpu->arch.vcore->dpdes = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_DAWR:
+ 		vcpu->arch.dawr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_DAWRX:
+ 		vcpu->arch.dawrx = set_reg_val(id, *val) & ~DAWRX_HYP;
+ 		break;
+ 	case KVM_REG_PPC_CIABR:
+ 		vcpu->arch.ciabr = set_reg_val(id, *val);
+ 		/* Don't allow setting breakpoints in hypervisor code */
+ 		if ((vcpu->arch.ciabr & CIABR_PRIV) == CIABR_PRIV_HYPER)
+ 			vcpu->arch.ciabr &= ~CIABR_PRIV;	/* disable */
+ 		break;
+ 	case KVM_REG_PPC_IC:
+ 		vcpu->arch.ic = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_VTB:
+ 		vcpu->arch.vtb = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_CSIGR:
+ 		vcpu->arch.csigr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_TACR:
+ 		vcpu->arch.tacr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_TCSCR:
+ 		vcpu->arch.tcscr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_PID:
+ 		vcpu->arch.pid = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_ACOP:
+ 		vcpu->arch.acop = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_WORT:
+ 		vcpu->arch.wort = set_reg_val(id, *val);
+ 		break;
++>>>>>>> e14e7a1e537d (KVM: PPC: Book3S PR: Expose TAR facility to guest)
  	case KVM_REG_PPC_VPA_ADDR:
  		addr = set_reg_val(id, *val);
  		r = -EINVAL;
diff --cc arch/powerpc/kvm/book3s_pr.c
index 4a72f612a23b,7d27a9518f07..000000000000
--- a/arch/powerpc/kvm/book3s_pr.c
+++ b/arch/powerpc/kvm/book3s_pr.c
@@@ -600,6 -618,25 +601,28 @@@ void kvmppc_giveup_ext(struct kvm_vcpu 
  	kvmppc_recalc_shadow_msr(vcpu);
  }
  
++<<<<<<< HEAD
++=======
+ /* Give up facility (TAR / EBB / DSCR) */
+ static void kvmppc_giveup_fac(struct kvm_vcpu *vcpu, ulong fac)
+ {
+ #ifdef CONFIG_PPC_BOOK3S_64
+ 	if (!(vcpu->arch.shadow_fscr & (1ULL << fac))) {
+ 		/* Facility not available to the guest, ignore giveup request*/
+ 		return;
+ 	}
+ 
+ 	switch (fac) {
+ 	case FSCR_TAR_LG:
+ 		vcpu->arch.tar = mfspr(SPRN_TAR);
+ 		mtspr(SPRN_TAR, current->thread.tar);
+ 		vcpu->arch.shadow_fscr &= ~FSCR_TAR;
+ 		break;
+ 	}
+ #endif
+ }
+ 
++>>>>>>> e14e7a1e537d (KVM: PPC: Book3S PR: Expose TAR facility to guest)
  static int kvmppc_read_inst(struct kvm_vcpu *vcpu)
  {
  	ulong srr0 = kvmppc_get_pc(vcpu);
@@@ -718,8 -768,58 +741,63 @@@ static void kvmppc_handle_lost_ext(stru
  	current->thread.regs->msr |= lost_ext;
  }
  
++<<<<<<< HEAD
 +int kvmppc_handle_exit(struct kvm_run *run, struct kvm_vcpu *vcpu,
 +                       unsigned int exit_nr)
++=======
+ #ifdef CONFIG_PPC_BOOK3S_64
+ 
+ static void kvmppc_trigger_fac_interrupt(struct kvm_vcpu *vcpu, ulong fac)
+ {
+ 	/* Inject the Interrupt Cause field and trigger a guest interrupt */
+ 	vcpu->arch.fscr &= ~(0xffULL << 56);
+ 	vcpu->arch.fscr |= (fac << 56);
+ 	kvmppc_book3s_queue_irqprio(vcpu, BOOK3S_INTERRUPT_FAC_UNAVAIL);
+ }
+ 
+ static void kvmppc_emulate_fac(struct kvm_vcpu *vcpu, ulong fac)
+ {
+ 	enum emulation_result er = EMULATE_FAIL;
+ 
+ 	if (!(kvmppc_get_msr(vcpu) & MSR_PR))
+ 		er = kvmppc_emulate_instruction(vcpu->run, vcpu);
+ 
+ 	if ((er != EMULATE_DONE) && (er != EMULATE_AGAIN)) {
+ 		/* Couldn't emulate, trigger interrupt in guest */
+ 		kvmppc_trigger_fac_interrupt(vcpu, fac);
+ 	}
+ }
+ 
+ /* Enable facilities (TAR, EBB, DSCR) for the guest */
+ static int kvmppc_handle_fac(struct kvm_vcpu *vcpu, ulong fac)
+ {
+ 	BUG_ON(!cpu_has_feature(CPU_FTR_ARCH_207S));
+ 
+ 	if (!(vcpu->arch.fscr & (1ULL << fac))) {
+ 		/* Facility not enabled by the guest */
+ 		kvmppc_trigger_fac_interrupt(vcpu, fac);
+ 		return RESUME_GUEST;
+ 	}
+ 
+ 	switch (fac) {
+ 	case FSCR_TAR_LG:
+ 		/* TAR switching isn't lazy in Linux yet */
+ 		current->thread.tar = mfspr(SPRN_TAR);
+ 		mtspr(SPRN_TAR, vcpu->arch.tar);
+ 		vcpu->arch.shadow_fscr |= FSCR_TAR;
+ 		break;
+ 	default:
+ 		kvmppc_emulate_fac(vcpu, fac);
+ 		break;
+ 	}
+ 
+ 	return RESUME_GUEST;
+ }
+ #endif
+ 
+ int kvmppc_handle_exit_pr(struct kvm_run *run, struct kvm_vcpu *vcpu,
+ 			  unsigned int exit_nr)
++>>>>>>> e14e7a1e537d (KVM: PPC: Book3S PR: Expose TAR facility to guest)
  {
  	int r = RESUME_HOST;
  	int s;
@@@ -1288,24 -1408,8 +1366,29 @@@ int kvmppc_vcpu_run(struct kvm_run *kvm
  	/* Make sure we save the guest FPU/Altivec/VSX state */
  	kvmppc_giveup_ext(vcpu, MSR_FP | MSR_VEC | MSR_VSX);
  
++<<<<<<< HEAD
 +	current->thread.regs->msr = ext_msr;
 +
 +	/* Restore FPU/VSX state from stack */
 +	current->thread.fp_state = fp;
 +	current->thread.fpexc_mode = fpexc_mode;
 +
 +#ifdef CONFIG_ALTIVEC
 +	/* Restore Altivec state from stack */
 +	if (used_vr && current->thread.used_vr) {
 +		current->thread.vr_state = vr;
 +		current->thread.vrsave = vrsave;
 +	}
 +	current->thread.used_vr = used_vr;
 +#endif
 +
 +#ifdef CONFIG_VSX
 +	current->thread.used_vsr = used_vsr;
 +#endif
++=======
+ 	/* Make sure we save the guest TAR/EBB/DSCR state */
+ 	kvmppc_giveup_fac(vcpu, FSCR_TAR_LG);
++>>>>>>> e14e7a1e537d (KVM: PPC: Book3S PR: Expose TAR facility to guest)
  
  out:
  	vcpu->mode = OUTSIDE_GUEST_MODE;
* Unmerged path arch/powerpc/include/asm/kvm_host.h
* Unmerged path arch/powerpc/kernel/asm-offsets.c
* Unmerged path arch/powerpc/kvm/book3s.c
* Unmerged path arch/powerpc/kvm/book3s_hv.c
* Unmerged path arch/powerpc/kvm/book3s_pr.c
