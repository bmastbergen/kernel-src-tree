cpufreq: Fix white space in __cpufreq_remove_dev()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Fix white space in __cpufreq_remove_dev() (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 90.11%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit edab2fbc21b9eb37007ad8bffe1159d536bbb451
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/edab2fbc.failed

Align closing brace '}' of an if block.

[rjw: Subject and changelog]
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit edab2fbc21b9eb37007ad8bffe1159d536bbb451)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index a0ff523b9cd4,fedc8420214e..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -1162,33 -1245,51 +1162,45 @@@ static int __cpufreq_remove_dev(struct 
  
  	/* If cpu is last user of policy, free policy */
  	if (cpus == 1) {
++<<<<<<< HEAD
 +		if (cpufreq_driver->target)
 +			__cpufreq_governor(data, CPUFREQ_GOV_POLICY_EXIT);
++=======
+ 		if (cpufreq_driver->target) {
+ 			ret = __cpufreq_governor(policy,
+ 					CPUFREQ_GOV_POLICY_EXIT);
+ 			if (ret) {
+ 				pr_err("%s: Failed to exit governor\n",
+ 						__func__);
+ 				return ret;
+ 			}
+ 		}
++>>>>>>> edab2fbc21b9 (cpufreq: Fix white space in __cpufreq_remove_dev())
  
 -		if (!frozen) {
 -			lock_policy_rwsem_read(cpu);
 -			kobj = &policy->kobj;
 -			cmp = &policy->kobj_unregister;
 -			unlock_policy_rwsem_read(cpu);
 -			kobject_put(kobj);
 -
 -			/*
 -			 * We need to make sure that the underlying kobj is
 -			 * actually not referenced anymore by anybody before we
 -			 * proceed with unloading.
 -			 */
 -			pr_debug("waiting for dropping of refcount\n");
 -			wait_for_completion(cmp);
 -			pr_debug("wait complete\n");
 -		}
 +		lock_policy_rwsem_read(cpu);
 +		kobj = &data->kobj;
 +		cmp = &data->kobj_unregister;
 +		unlock_policy_rwsem_read(cpu);
 +		kobject_put(kobj);
  
 -		/*
 -		 * Perform the ->exit() even during light-weight tear-down,
 -		 * since this is a core component, and is essential for the
 -		 * subsequent light-weight ->init() to succeed.
 +		/* we need to make sure that the underlying kobj is actually
 +		 * not referenced anymore by anybody before we proceed with
 +		 * unloading.
  		 */
 +		pr_debug("waiting for dropping of refcount\n");
 +		wait_for_completion(cmp);
 +		pr_debug("wait complete\n");
 +
  		if (cpufreq_driver->exit)
 -			cpufreq_driver->exit(policy);
 +			cpufreq_driver->exit(data);
  
 -		if (!frozen)
 -			cpufreq_policy_free(policy);
 +		free_cpumask_var(data->related_cpus);
 +		free_cpumask_var(data->cpus);
 +		kfree(data);
  	} else {
  		if (cpufreq_driver->target) {
 -			if ((ret = __cpufreq_governor(policy, CPUFREQ_GOV_START)) ||
 -					(ret = __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS))) {
 -				pr_err("%s: Failed to start governor\n",
 -						__func__);
 -				return ret;
 -			}
 +			__cpufreq_governor(data, CPUFREQ_GOV_START);
 +			__cpufreq_governor(data, CPUFREQ_GOV_LIMITS);
  		}
  	}
  
* Unmerged path drivers/cpufreq/cpufreq.c
