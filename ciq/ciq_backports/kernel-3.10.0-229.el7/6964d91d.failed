cpufreq: remove sysfs link when a cpu != policy->cpu, is removed

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] remove sysfs link when a cpu != policy->cpu, is removed (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 92.44%
commit-author viresh kumar <viresh.kumar@linaro.org>
commit 6964d91db2becfe80658f50584d264708ca7f49e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/6964d91d.failed

Commit 42f921a (cpufreq: remove sysfs files for CPUs which failed to
come back after resume) tried to do this but missed this piece of code
to fix.

Currently we are getting this on suspend/resume:

------------[ cut here ]------------
WARNING: CPU: 0 PID: 877 at fs/sysfs/dir.c:52 sysfs_warn_dup+0x68/0x84()
sysfs: cannot create duplicate filename '/devices/system/cpu/cpu1/cpufreq'
Modules linked in: brcmfmac brcmutil
CPU: 0 PID: 877 Comm: test-rtc-resume Not tainted 3.14.0-rc2-00259-g9398a10cd964 #12
[<c0015bac>] (unwind_backtrace) from [<c0011850>] (show_stack+0x10/0x14)
[<c0011850>] (show_stack) from [<c056e018>] (dump_stack+0x80/0xcc)
[<c056e018>] (dump_stack) from [<c0025e44>] (warn_slowpath_common+0x64/0x88)
[<c0025e44>] (warn_slowpath_common) from [<c0025efc>] (warn_slowpath_fmt+0x30/0x40)
[<c0025efc>] (warn_slowpath_fmt) from [<c012776c>] (sysfs_warn_dup+0x68/0x84)
[<c012776c>] (sysfs_warn_dup) from [<c0127a54>] (sysfs_do_create_link_sd+0xb0/0xb8)
[<c0127a54>] (sysfs_do_create_link_sd) from [<c038ef64>] (__cpufreq_add_dev.isra.27+0x2a8/0x814)
[<c038ef64>] (__cpufreq_add_dev.isra.27) from [<c038f548>] (cpufreq_cpu_callback+0x70/0x8c)
[<c038f548>] (cpufreq_cpu_callback) from [<c0043864>] (notifier_call_chain+0x44/0x84)
[<c0043864>] (notifier_call_chain) from [<c0025f60>] (__cpu_notify+0x28/0x44)
[<c0025f60>] (__cpu_notify) from [<c00261e8>] (_cpu_up+0xf0/0x140)
[<c00261e8>] (_cpu_up) from [<c0569eb8>] (enable_nonboot_cpus+0x68/0xb0)
[<c0569eb8>] (enable_nonboot_cpus) from [<c006339c>] (suspend_devices_and_enter+0x198/0x2dc)
[<c006339c>] (suspend_devices_and_enter) from [<c0063654>] (pm_suspend+0x174/0x1e8)
[<c0063654>] (pm_suspend) from [<c00624e0>] (state_store+0x6c/0xbc)
[<c00624e0>] (state_store) from [<c01fc200>] (kobj_attr_store+0x14/0x20)
[<c01fc200>] (kobj_attr_store) from [<c0126e50>] (sysfs_kf_write+0x44/0x48)
[<c0126e50>] (sysfs_kf_write) from [<c012a274>] (kernfs_fop_write+0xb4/0x14c)
[<c012a274>] (kernfs_fop_write) from [<c00d4818>] (vfs_write+0xa8/0x180)
[<c00d4818>] (vfs_write) from [<c00d4bb8>] (SyS_write+0x3c/0x70)
[<c00d4bb8>] (SyS_write) from [<c000e620>] (ret_fast_syscall+0x0/0x30)
---[ end trace 76969904b614c18f ]---

Fix this by removing sysfs link for cpufreq directory when cpu removed
isn't policy->cpu.

Revamps: 42f921a (cpufreq: remove sysfs files for CPUs which failed to come back after resume)
Reported-and-tested-by: Stephen Warren <swarren@nvidia.com>
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 6964d91db2becfe80658f50584d264708ca7f49e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index c8bc717e8458,cb003a6b72c8..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -1192,59 -1315,93 +1192,103 @@@ static int __cpufreq_remove_dev(struct 
  #ifdef CONFIG_HOTPLUG_CPU
  	if (!cpufreq_driver->setpolicy)
  		strncpy(per_cpu(cpufreq_cpu_governor, cpu),
 -			policy->governor->name, CPUFREQ_NAME_LEN);
 +			data->governor->name, CPUFREQ_NAME_LEN);
  #endif
  
++<<<<<<< HEAD
 +	WARN_ON(lock_policy_rwsem_write(cpu));
 +	cpus = cpumask_weight(data->cpus);
++=======
+ 	down_read(&policy->rwsem);
+ 	cpus = cpumask_weight(policy->cpus);
+ 	up_read(&policy->rwsem);
+ 
+ 	if (cpu != policy->cpu) {
+ 		sysfs_remove_link(&dev->kobj, "cpufreq");
+ 	} else if (cpus > 1) {
+ 		new_cpu = cpufreq_nominate_new_policy_cpu(policy, cpu);
+ 		if (new_cpu >= 0) {
+ 			update_policy_cpu(policy, new_cpu);
+ 
+ 			if (!frozen) {
+ 				pr_debug("%s: policy Kobject moved to cpu: %d from: %d\n",
+ 						__func__, new_cpu, cpu);
+ 			}
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int __cpufreq_remove_dev_finish(struct device *dev,
+ 				       struct subsys_interface *sif,
+ 				       bool frozen)
+ {
+ 	unsigned int cpu = dev->id, cpus;
+ 	int ret;
+ 	unsigned long flags;
+ 	struct cpufreq_policy *policy;
+ 
+ 	read_lock_irqsave(&cpufreq_driver_lock, flags);
+ 	policy = per_cpu(cpufreq_cpu_data, cpu);
+ 	read_unlock_irqrestore(&cpufreq_driver_lock, flags);
+ 
+ 	if (!policy) {
+ 		pr_debug("%s: No cpu_data found\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 
+ 	down_write(&policy->rwsem);
+ 	cpus = cpumask_weight(policy->cpus);
++>>>>>>> 6964d91db2be (cpufreq: remove sysfs link when a cpu != policy->cpu, is removed)
  
  	if (cpus > 1)
 -		cpumask_clear_cpu(cpu, policy->cpus);
 -	up_write(&policy->rwsem);
 +		cpumask_clear_cpu(cpu, data->cpus);
 +	unlock_policy_rwsem_write(cpu);
  
 -	/* If cpu is last user of policy, free policy */
 -	if (cpus == 1) {
 -		if (has_target()) {
 -			ret = __cpufreq_governor(policy,
 -					CPUFREQ_GOV_POLICY_EXIT);
 -			if (ret) {
 -				pr_err("%s: Failed to exit governor\n",
 -						__func__);
 -				return ret;
 -			}
 -		}
 +	if (cpu != data->cpu) {
 +		sysfs_remove_link(&dev->kobj, "cpufreq");
 +	} else if (cpus > 1) {
  
 -		if (!frozen)
 -			cpufreq_policy_put_kobj(policy);
 +		new_cpu = cpufreq_nominate_new_policy_cpu(data, cpu);
 +		if (new_cpu >= 0) {
 +			WARN_ON(lock_policy_rwsem_write(cpu));
 +			update_policy_cpu(data, new_cpu);
 +			unlock_policy_rwsem_write(cpu);
 +			pr_debug("%s: policy Kobject moved to cpu: %d "
 +				 "from: %d\n",__func__, new_cpu, cpu);
 +		}
 +	}
  
 -		/*
 -		 * Perform the ->exit() even during light-weight tear-down,
 -		 * since this is a core component, and is essential for the
 -		 * subsequent light-weight ->init() to succeed.
 +	/* If cpu is last user of policy, free policy */
 +	if (cpus == 1) {
 +		if (cpufreq_driver->target)
 +			__cpufreq_governor(data, CPUFREQ_GOV_POLICY_EXIT);
 +
 +		lock_policy_rwsem_read(cpu);
 +		kobj = &data->kobj;
 +		cmp = &data->kobj_unregister;
 +		unlock_policy_rwsem_read(cpu);
 +		kobject_put(kobj);
 +
 +		/* we need to make sure that the underlying kobj is actually
 +		 * not referenced anymore by anybody before we proceed with
 +		 * unloading.
  		 */
 -		if (cpufreq_driver->exit)
 -			cpufreq_driver->exit(policy);
 +		pr_debug("waiting for dropping of refcount\n");
 +		wait_for_completion(cmp);
 +		pr_debug("wait complete\n");
  
 -		/* Remove policy from list of active policies */
 -		write_lock_irqsave(&cpufreq_driver_lock, flags);
 -		list_del(&policy->policy_list);
 -		write_unlock_irqrestore(&cpufreq_driver_lock, flags);
 +		if (cpufreq_driver->exit)
 +			cpufreq_driver->exit(data);
  
 -		if (!frozen)
 -			cpufreq_policy_free(policy);
 +		free_cpumask_var(data->related_cpus);
 +		free_cpumask_var(data->cpus);
 +		kfree(data);
  	} else {
 -		if (has_target()) {
 -			if ((ret = __cpufreq_governor(policy, CPUFREQ_GOV_START)) ||
 -					(ret = __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS))) {
 -				pr_err("%s: Failed to start governor\n",
 -						__func__);
 -				return ret;
 -			}
 +		if (cpufreq_driver->target) {
 +			__cpufreq_governor(data, CPUFREQ_GOV_START);
 +			__cpufreq_governor(data, CPUFREQ_GOV_LIMITS);
  		}
  	}
  
* Unmerged path drivers/cpufreq/cpufreq.c
