genetlink: Fix uninitialized variable in genl_validate_assign_mc_groups()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Geert Uytterhoeven <geert@linux-m68k.org>
commit 0f0e2159c0c101426b705d70f43b9f423d51c869
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0f0e2159.failed

net/netlink/genetlink.c: In function ‘genl_validate_assign_mc_groups’:
net/netlink/genetlink.c:217: warning: ‘err’ may be used uninitialized in this
function

Commit 2a94fe48f32ccf7321450a2cc07f2b724a444e5b ("genetlink: make multicast
groups const, prevent abuse") split genl_register_mc_group() in multiple
functions, but dropped the initialization of err.

Initialize err to zero to fix this.

	Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0f0e2159c0c101426b705d70f43b9f423d51c869)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netlink/genetlink.c
diff --cc net/netlink/genetlink.c
index fa66966658bc,803206e82450..000000000000
--- a/net/netlink/genetlink.c
+++ b/net/netlink/genetlink.c
@@@ -144,66 -148,110 +144,131 @@@ static u16 genl_generate_id(void
  	return 0;
  }
  
 -static int genl_allocate_reserve_groups(int n_groups, int *first_id)
 +static struct genl_multicast_group notify_grp;
 +
 +/**
 + * genl_register_mc_group - register a multicast group
 + *
 + * Registers the specified multicast group and notifies userspace
 + * about the new group.
 + *
 + * Returns 0 on success or a negative error code.
 + *
 + * @family: The generic netlink family the group shall be registered for.
 + * @grp: The group to register, must have a name.
 + */
 +int genl_register_mc_group(struct genl_family *family,
 +			   struct genl_multicast_group *grp)
  {
 -	unsigned long *new_groups;
 -	int start = 0;
 -	int i;
  	int id;
 -	bool fits;
 -
 -	do {
 -		if (start == 0)
 -			id = find_first_zero_bit(mc_groups,
 -						 mc_groups_longs *
 -						 BITS_PER_LONG);
 -		else
 -			id = find_next_zero_bit(mc_groups,
 -						mc_groups_longs * BITS_PER_LONG,
 -						start);
 +	unsigned long *new_groups;
 +	int err = 0;
  
 +	BUG_ON(grp->name[0] == '\0');
 +	BUG_ON(memchr(grp->name, '\0', GENL_NAMSIZ) == NULL);
 +
++<<<<<<< HEAD
 +	genl_lock_all();
++=======
+ 		fits = true;
+ 		for (i = id;
+ 		     i < min_t(int, id + n_groups,
+ 			       mc_groups_longs * BITS_PER_LONG);
+ 		     i++) {
+ 			if (test_bit(i, mc_groups)) {
+ 				start = i;
+ 				fits = false;
+ 				break;
+ 			}
+ 		}
+ 
+ 		if (id >= mc_groups_longs * BITS_PER_LONG) {
+ 			unsigned long new_longs = mc_groups_longs +
+ 						  BITS_TO_LONGS(n_groups);
+ 			size_t nlen = new_longs * sizeof(unsigned long);
+ 
+ 			if (mc_groups == &mc_group_start) {
+ 				new_groups = kzalloc(nlen, GFP_KERNEL);
+ 				if (!new_groups)
+ 					return -ENOMEM;
+ 				mc_groups = new_groups;
+ 				*mc_groups = mc_group_start;
+ 			} else {
+ 				new_groups = krealloc(mc_groups, nlen,
+ 						      GFP_KERNEL);
+ 				if (!new_groups)
+ 					return -ENOMEM;
+ 				mc_groups = new_groups;
+ 				for (i = 0; i < BITS_TO_LONGS(n_groups); i++)
+ 					mc_groups[mc_groups_longs + i] = 0;
+ 			}
+ 			mc_groups_longs = new_longs;
+ 		}
+ 	} while (!fits);
+ 
+ 	for (i = id; i < id + n_groups; i++)
+ 		set_bit(i, mc_groups);
+ 	*first_id = id;
+ 	return 0;
+ }
+ 
+ static struct genl_family genl_ctrl;
+ 
+ static int genl_validate_assign_mc_groups(struct genl_family *family)
+ {
+ 	int first_id;
+ 	int n_groups = family->n_mcgrps;
+ 	int err = 0, i;
+ 	bool groups_allocated = false;
+ 
+ 	if (!n_groups)
+ 		return 0;
+ 
+ 	for (i = 0; i < n_groups; i++) {
+ 		const struct genl_multicast_group *grp = &family->mcgrps[i];
+ 
+ 		if (WARN_ON(grp->name[0] == '\0'))
+ 			return -EINVAL;
+ 		if (WARN_ON(memchr(grp->name, '\0', GENL_NAMSIZ) == NULL))
+ 			return -EINVAL;
+ 	}
++>>>>>>> 0f0e2159c0c1 (genetlink: Fix uninitialized variable in genl_validate_assign_mc_groups())
  
  	/* special-case our own group and hacks */
 -	if (family == &genl_ctrl) {
 -		first_id = GENL_ID_CTRL;
 -		BUG_ON(n_groups != 1);
 -	} else if (strcmp(family->name, "NET_DM") == 0) {
 -		first_id = 1;
 -		BUG_ON(n_groups != 1);
 -	} else if (strcmp(family->name, "VFS_DQUOT") == 0) {
 -		first_id = GENL_ID_VFS_DQUOT;
 -		BUG_ON(n_groups != 1);
 -	} else {
 -		groups_allocated = true;
 -		err = genl_allocate_reserve_groups(n_groups, &first_id);
 -		if (err)
 -			return err;
 +	if (grp == &notify_grp)
 +		id = GENL_ID_CTRL;
 +	else if (strcmp(family->name, "NET_DM") == 0)
 +		id = 1;
 +	else if (strcmp(family->name, "VFS_DQUOT") == 0)
 +		id = GENL_ID_VFS_DQUOT;
 +	else
 +		id = find_first_zero_bit(mc_groups,
 +					 mc_groups_longs * BITS_PER_LONG);
 +
 +
 +	if (id >= mc_groups_longs * BITS_PER_LONG) {
 +		size_t nlen = (mc_groups_longs + 1) * sizeof(unsigned long);
 +
 +		if (mc_groups == &mc_group_start) {
 +			new_groups = kzalloc(nlen, GFP_KERNEL);
 +			if (!new_groups) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			mc_groups = new_groups;
 +			*mc_groups = mc_group_start;
 +		} else {
 +			new_groups = krealloc(mc_groups, nlen, GFP_KERNEL);
 +			if (!new_groups) {
 +				err = -ENOMEM;
 +				goto out;
 +			}
 +			mc_groups = new_groups;
 +			mc_groups[mc_groups_longs] = 0;
 +		}
 +		mc_groups_longs++;
  	}
  
 -	family->mcgrp_offset = first_id;
 -
 -	/* if still initializing, can't and don't need to to realloc bitmaps */
 -	if (!init_net.genl_sock)
 -		return 0;
 -
  	if (family->netnsok) {
  		struct net *net;
  
* Unmerged path net/netlink/genetlink.c
