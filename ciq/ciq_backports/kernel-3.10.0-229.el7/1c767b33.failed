drm/i915: take display port power domain in DP HPD handler

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] i915: take display port power domain in DP HPD handler (Dave Airlie) [1140440]
Rebuild_FUZZ: 96.43%
commit-author Imre Deak <imre.deak@intel.com>
commit 1c767b339b3938b19076ffdc9d70aa1e4235a45b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/1c767b33.failed

Ville noticed that we can call ibx_digital_port_connected() which accesses
the HW without holding any power well/runtime pm reference. Fix this by
holding a display port power domain reference around the whole hpd_pulse
handler.

	Signed-off-by: Imre Deak <imre.deak@intel.com>
	Reviewed-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
	Reviewed-by: Dave Airlie <airlied@redhat.com>
	Cc: stable@vger.kernel.org (3.16+)
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
(cherry picked from commit 1c767b339b3938b19076ffdc9d70aa1e4235a45b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_dp.c
diff --cc drivers/gpu/drm/i915/intel_dp.c
index 1a431377d83b,a520188e6d97..000000000000
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@@ -3090,12 -4026,74 +3090,76 @@@ static const struct drm_encoder_funcs i
  	.destroy = intel_dp_encoder_destroy,
  };
  
 -void
 +static void
  intel_dp_hot_plug(struct intel_encoder *intel_encoder)
  {
 -	return;
 -}
 +	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);
  
++<<<<<<< HEAD
 +	intel_dp_check_link_status(intel_dp);
++=======
+ bool
+ intel_dp_hpd_pulse(struct intel_digital_port *intel_dig_port, bool long_hpd)
+ {
+ 	struct intel_dp *intel_dp = &intel_dig_port->dp;
+ 	struct intel_encoder *intel_encoder = &intel_dig_port->base;
+ 	struct drm_device *dev = intel_dig_port->base.base.dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	enum intel_display_power_domain power_domain;
+ 	bool ret = true;
+ 
+ 	if (intel_dig_port->base.type != INTEL_OUTPUT_EDP)
+ 		intel_dig_port->base.type = INTEL_OUTPUT_DISPLAYPORT;
+ 
+ 	DRM_DEBUG_KMS("got hpd irq on port %d - %s\n", intel_dig_port->port,
+ 		      long_hpd ? "long" : "short");
+ 
+ 	power_domain = intel_display_port_power_domain(intel_encoder);
+ 	intel_display_power_get(dev_priv, power_domain);
+ 
+ 	if (long_hpd) {
+ 		if (!ibx_digital_port_connected(dev_priv, intel_dig_port))
+ 			goto mst_fail;
+ 
+ 		if (!intel_dp_get_dpcd(intel_dp)) {
+ 			goto mst_fail;
+ 		}
+ 
+ 		intel_dp_probe_oui(intel_dp);
+ 
+ 		if (!intel_dp_probe_mst(intel_dp))
+ 			goto mst_fail;
+ 
+ 	} else {
+ 		if (intel_dp->is_mst) {
+ 			if (intel_dp_check_mst_status(intel_dp) == -EINVAL)
+ 				goto mst_fail;
+ 		}
+ 
+ 		if (!intel_dp->is_mst) {
+ 			/*
+ 			 * we'll check the link status via the normal hot plug path later -
+ 			 * but for short hpds we should check it now
+ 			 */
+ 			drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
+ 			intel_dp_check_link_status(intel_dp);
+ 			drm_modeset_unlock(&dev->mode_config.connection_mutex);
+ 		}
+ 	}
+ 	ret = false;
+ 	goto put_power;
+ mst_fail:
+ 	/* if we were in MST mode, and device is not there get out of MST mode */
+ 	if (intel_dp->is_mst) {
+ 		DRM_DEBUG_KMS("MST device may have disappeared %d vs %d\n", intel_dp->is_mst, intel_dp->mst_mgr.mst_state);
+ 		intel_dp->is_mst = false;
+ 		drm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr, intel_dp->is_mst);
+ 	}
+ put_power:
+ 	intel_display_power_put(dev_priv, power_domain);
+ 
+ 	return ret;
++>>>>>>> 1c767b339b39 (drm/i915: take display port power domain in DP HPD handler)
  }
  
  /* Return which DP Port should be selected for Transcoder DP control */
* Unmerged path drivers/gpu/drm/i915/intel_dp.c
