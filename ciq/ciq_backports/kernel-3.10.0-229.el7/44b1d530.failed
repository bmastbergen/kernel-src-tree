vfs: add d_is_dir()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit 44b1d53043c482225196e8a9cd9f35163a1b3336
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/44b1d530.failed

Add d_is_dir(dentry) helper which is analogous to S_ISDIR().

To avoid confusion, rename d_is_directory() to d_can_lookup().

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
	Reviewed-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 44b1d53043c482225196e8a9cd9f35163a1b3336)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namei.c
#	include/linux/dcache.h
diff --cc fs/namei.c
index d87d2e09b208,e987ea7c305f..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -1842,7 -1796,7 +1842,11 @@@ static int link_path_walk(const char *n
  			if (err)
  				return err;
  		}
++<<<<<<< HEAD
 +		if (!can_lookup(nd->inode)) {
++=======
+ 		if (!d_can_lookup(nd->path.dentry)) {
++>>>>>>> 44b1d53043c4 (vfs: add d_is_dir())
  			err = -ENOTDIR; 
  			break;
  		}
@@@ -1860,9 -1814,10 +1864,13 @@@ static int path_init(int dfd, const cha
  	nd->flags = flags | LOOKUP_JUMPED;
  	nd->depth = 0;
  	if (flags & LOOKUP_ROOT) {
 -		struct dentry *root = nd->root.dentry;
 -		struct inode *inode = root->d_inode;
 +		struct inode *inode = nd->root.dentry->d_inode;
  		if (*name) {
++<<<<<<< HEAD
 +			if (!can_lookup(inode))
++=======
+ 			if (!d_can_lookup(root))
++>>>>>>> 44b1d53043c4 (vfs: add d_is_dir())
  				return -ENOTDIR;
  			retval = inode_permission(inode, MAY_EXEC);
  			if (retval)
@@@ -1916,7 -1873,7 +1924,11 @@@
  		dentry = f.file->f_path.dentry;
  
  		if (*name) {
++<<<<<<< HEAD
 +			if (!can_lookup(dentry->d_inode)) {
++=======
+ 			if (!d_can_lookup(dentry)) {
++>>>>>>> 44b1d53043c4 (vfs: add d_is_dir())
  				fdput(f);
  				return -ENOTDIR;
  			}
@@@ -1998,7 -1955,7 +2010,11 @@@ static int path_lookupat(int dfd, cons
  		err = complete_walk(nd);
  
  	if (!err && nd->flags & LOOKUP_DIRECTORY) {
++<<<<<<< HEAD
 +		if (!can_lookup(nd->inode)) {
++=======
+ 		if (!d_can_lookup(nd->path.dentry)) {
++>>>>>>> 44b1d53043c4 (vfs: add d_is_dir())
  			path_put(&nd->path);
  			err = -ENOTDIR;
  		}
@@@ -2449,15 -2409,16 +2465,23 @@@ static int may_delete(struct inode *dir
  		return error;
  	if (IS_APPEND(dir))
  		return -EPERM;
 -
 -	if (check_sticky(dir, inode) || IS_APPEND(inode) ||
 -	    IS_IMMUTABLE(inode) || IS_SWAPFILE(inode))
 +	if (check_sticky(dir, victim->d_inode)||IS_APPEND(victim->d_inode)||
 +	    IS_IMMUTABLE(victim->d_inode) || IS_SWAPFILE(victim->d_inode))
  		return -EPERM;
  	if (isdir) {
++<<<<<<< HEAD
 +		if (!S_ISDIR(victim->d_inode->i_mode))
 +			return -ENOTDIR;
 +		if (IS_ROOT(victim))
 +			return -EBUSY;
 +	} else if (S_ISDIR(victim->d_inode->i_mode))
++=======
+ 		if (!d_is_dir(victim))
+ 			return -ENOTDIR;
+ 		if (IS_ROOT(victim))
+ 			return -EBUSY;
+ 	} else if (d_is_dir(victim))
++>>>>>>> 44b1d53043c4 (vfs: add d_is_dir())
  		return -EISDIR;
  	if (IS_DEADDIR(dir))
  		return -ENOENT;
@@@ -3070,14 -3014,13 +3094,21 @@@ finish_lookup
  		path_put(&save_parent);
  		return error;
  	}
 -	audit_inode(name, nd->path.dentry, 0);
  	error = -EISDIR;
++<<<<<<< HEAD
 +	if ((open_flag & O_CREAT) && S_ISDIR(nd->inode->i_mode))
 +		goto out;
 +	error = -ENOTDIR;
 +	if ((nd->flags & LOOKUP_DIRECTORY) && !can_lookup(nd->inode))
++=======
+ 	if ((open_flag & O_CREAT) && d_is_dir(nd->path.dentry))
+ 		goto out;
+ 	error = -ENOTDIR;
+ 	if ((nd->flags & LOOKUP_DIRECTORY) && !d_can_lookup(nd->path.dentry))
++>>>>>>> 44b1d53043c4 (vfs: add d_is_dir())
  		goto out;
 +	audit_inode(name, nd->path.dentry, 0);
 +finish_open:
  	if (!S_ISREG(nd->inode->i_mode))
  		will_truncate = false;
  
@@@ -3731,8 -3741,12 +3762,17 @@@ exit1
  	return error;
  
  slashes:
++<<<<<<< HEAD
 +	error = !dentry->d_inode ? -ENOENT :
 +		S_ISDIR(dentry->d_inode->i_mode) ? -EISDIR : -ENOTDIR;
++=======
+ 	if (d_is_negative(dentry))
+ 		error = -ENOENT;
+ 	else if (d_is_dir(dentry))
+ 		error = -EISDIR;
+ 	else
+ 		error = -ENOTDIR;
++>>>>>>> 44b1d53043c4 (vfs: add d_is_dir())
  	goto exit2;
  }
  
@@@ -4102,7 -4122,7 +4142,11 @@@ int vfs_rename(struct inode *old_dir, s
  	       struct inode **delegated_inode)
  {
  	int error;
++<<<<<<< HEAD
 +	int is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
++=======
+ 	int is_dir = d_is_dir(old_dentry);
++>>>>>>> 44b1d53043c4 (vfs: add d_is_dir())
  	const unsigned char *old_name;
  
  	if (old_dentry->d_inode == new_dentry->d_inode)
@@@ -4192,10 -4212,10 +4236,14 @@@ retry_deleg
  		goto exit3;
  	/* source must exist */
  	error = -ENOENT;
 -	if (d_is_negative(old_dentry))
 +	if (!old_dentry->d_inode)
  		goto exit4;
  	/* unless the source is a directory trailing slashes give -ENOTDIR */
++<<<<<<< HEAD
 +	if (!S_ISDIR(old_dentry->d_inode->i_mode)) {
++=======
+ 	if (!d_is_dir(old_dentry)) {
++>>>>>>> 44b1d53043c4 (vfs: add d_is_dir())
  		error = -ENOTDIR;
  		if (oldnd.last.name[oldnd.last.len])
  			goto exit4;
diff --cc include/linux/dcache.h
index 472a2e1eab0f,3b50cac7ccb3..000000000000
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@@ -391,6 -404,70 +391,69 @@@ static inline bool d_mountpoint(struct 
  	return dentry->d_flags & DCACHE_MOUNTED;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Directory cache entry type accessor functions.
+  */
+ static inline void __d_set_type(struct dentry *dentry, unsigned type)
+ {
+ 	dentry->d_flags = (dentry->d_flags & ~DCACHE_ENTRY_TYPE) | type;
+ }
+ 
+ static inline void __d_clear_type(struct dentry *dentry)
+ {
+ 	__d_set_type(dentry, DCACHE_MISS_TYPE);
+ }
+ 
+ static inline void d_set_type(struct dentry *dentry, unsigned type)
+ {
+ 	spin_lock(&dentry->d_lock);
+ 	__d_set_type(dentry, type);
+ 	spin_unlock(&dentry->d_lock);
+ }
+ 
+ static inline unsigned __d_entry_type(const struct dentry *dentry)
+ {
+ 	return dentry->d_flags & DCACHE_ENTRY_TYPE;
+ }
+ 
+ static inline bool d_can_lookup(const struct dentry *dentry)
+ {
+ 	return __d_entry_type(dentry) == DCACHE_DIRECTORY_TYPE;
+ }
+ 
+ static inline bool d_is_autodir(const struct dentry *dentry)
+ {
+ 	return __d_entry_type(dentry) == DCACHE_AUTODIR_TYPE;
+ }
+ 
+ static inline bool d_is_dir(const struct dentry *dentry)
+ {
+ 	return d_can_lookup(dentry) || d_is_autodir(dentry);
+ }
+ 
+ static inline bool d_is_symlink(const struct dentry *dentry)
+ {
+ 	return __d_entry_type(dentry) == DCACHE_SYMLINK_TYPE;
+ }
+ 
+ static inline bool d_is_file(const struct dentry *dentry)
+ {
+ 	return __d_entry_type(dentry) == DCACHE_FILE_TYPE;
+ }
+ 
+ static inline bool d_is_negative(const struct dentry *dentry)
+ {
+ 	return __d_entry_type(dentry) == DCACHE_MISS_TYPE;
+ }
+ 
+ static inline bool d_is_positive(const struct dentry *dentry)
+ {
+ 	return !d_is_negative(dentry);
+ }
+ 
++>>>>>>> 44b1d53043c4 (vfs: add d_is_dir())
  extern int sysctl_vfs_cache_pressure;
  
 -static inline unsigned long vfs_pressure_ratio(unsigned long val)
 -{
 -	return mult_frac(val, sysctl_vfs_cache_pressure, 100);
 -}
  #endif	/* __LINUX_DCACHE_H */
* Unmerged path fs/namei.c
* Unmerged path include/linux/dcache.h
