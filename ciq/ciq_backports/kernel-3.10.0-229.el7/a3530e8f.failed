x86/efi: Do not export efi runtime map in case old map

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [x86] efi: Do not export efi runtime map in case old map (Dave Young) [1080109]
Rebuild_FUZZ: 96.15%
commit-author Dave Young <dyoung@redhat.com>
commit a3530e8fe980f756b823d451fe9243f26db95fa5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a3530e8f.failed

For ioremapped efi memory aka old_map the virt addresses are not persistant
across kexec reboot. kexec-tools will read the runtime maps from sysfs then
pass them to 2nd kernel and assuming kexec efi boot is ok. This will cause
kexec boot failure.

To address this issue do not export runtime maps in case efi old_map so
userspace can use no efi boot instead.

	Signed-off-by: Dave Young <dyoung@redhat.com>
	Acked-by: Borislav Petkov <bp@suse.de>
	Acked-by: Vivek Goyal <vgoyal@redhat.com>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit a3530e8fe980f756b823d451fe9243f26db95fa5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/platform/efi/efi.c
diff --cc arch/x86/platform/efi/efi.c
index 4ba4bd5dfe10,4d36932ca4f2..000000000000
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@@ -804,6 -896,87 +804,90 @@@ void __init efi_enter_virtual_mode(void
  		}
  		prev_md = md;
  	}
++<<<<<<< HEAD
++=======
+ }
+ 
+ static void __init get_systab_virt_addr(efi_memory_desc_t *md)
+ {
+ 	unsigned long size;
+ 	u64 end, systab;
+ 
+ 	size = md->num_pages << EFI_PAGE_SHIFT;
+ 	end = md->phys_addr + size;
+ 	systab = (u64)(unsigned long)efi_phys.systab;
+ 	if (md->phys_addr <= systab && systab < end) {
+ 		systab += md->virt_addr - md->phys_addr;
+ 		efi.systab = (efi_system_table_t *)(unsigned long)systab;
+ 	}
+ }
+ 
+ static void __init save_runtime_map(void)
+ {
+ #ifdef CONFIG_KEXEC
+ 	efi_memory_desc_t *md;
+ 	void *tmp, *p, *q = NULL;
+ 	int count = 0;
+ 
+ 	if (efi_enabled(EFI_OLD_MEMMAP))
+ 		return;
+ 
+ 	for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
+ 		md = p;
+ 
+ 		if (!(md->attribute & EFI_MEMORY_RUNTIME) ||
+ 		    (md->type == EFI_BOOT_SERVICES_CODE) ||
+ 		    (md->type == EFI_BOOT_SERVICES_DATA))
+ 			continue;
+ 		tmp = krealloc(q, (count + 1) * memmap.desc_size, GFP_KERNEL);
+ 		if (!tmp)
+ 			goto out;
+ 		q = tmp;
+ 
+ 		memcpy(q + count * memmap.desc_size, md, memmap.desc_size);
+ 		count++;
+ 	}
+ 
+ 	efi_runtime_map_setup(q, count, memmap.desc_size);
+ 	return;
+ 
+ out:
+ 	kfree(q);
+ 	pr_err("Error saving runtime map, efi runtime on kexec non-functional!!\n");
+ #endif
+ }
+ 
+ static void *realloc_pages(void *old_memmap, int old_shift)
+ {
+ 	void *ret;
+ 
+ 	ret = (void *)__get_free_pages(GFP_KERNEL, old_shift + 1);
+ 	if (!ret)
+ 		goto out;
+ 
+ 	/*
+ 	 * A first-time allocation doesn't have anything to copy.
+ 	 */
+ 	if (!old_memmap)
+ 		return ret;
+ 
+ 	memcpy(ret, old_memmap, PAGE_SIZE << old_shift);
+ 
+ out:
+ 	free_pages((unsigned long)old_memmap, old_shift);
+ 	return ret;
+ }
+ 
+ /*
+  * Map the efi memory ranges of the runtime services and update new_mmap with
+  * virtual addresses.
+  */
+ static void * __init efi_map_regions(int *count, int *pg_shift)
+ {
+ 	void *p, *new_memmap = NULL;
+ 	unsigned long left = 0;
+ 	efi_memory_desc_t *md;
++>>>>>>> a3530e8fe980 (x86/efi: Do not export efi runtime map in case old map)
  
  	for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
  		md = p;
* Unmerged path arch/x86/platform/efi/efi.c
