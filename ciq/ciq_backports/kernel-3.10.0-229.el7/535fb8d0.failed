vxlan: Call udp_flow_src_port

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Tom Herbert <therbert@google.com>
commit 535fb8d006bc6a96d59558181a9a6f267be382c5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/535fb8d0.failed

In vxlan and OVS vport-vxlan call common function to get source port
for a UDP tunnel. Removed vxlan_src_port since the functionality is
now in udp_flow_src_port.

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 535fb8d006bc6a96d59558181a9a6f267be382c5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	net/openvswitch/vport-vxlan.c
diff --cc drivers/net/vxlan.c
index d158096bf15a,c2d360150804..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1556,25 -1570,6 +1556,28 @@@ static bool route_shortcircuit(struct n
  	return false;
  }
  
++<<<<<<< HEAD
 +/* Compute source port for outgoing packet
 + *   first choice to use L4 flow hash since it will spread
 + *     better and maybe available from hardware
 + *   secondary choice is to use jhash on the Ethernet header
 + */
 +__be16 vxlan_src_port(__u16 port_min, __u16 port_max, struct sk_buff *skb)
 +{
 +	unsigned int range = (port_max - port_min) + 1;
 +	u32 hash;
 +
 +	hash = skb_get_rxhash(skb);
 +	if (!hash)
 +		hash = jhash(skb->data, 2 * ETH_ALEN,
 +			     (__force u32) skb->protocol);
 +
 +	return htons((((u64) hash * range) >> 32) + port_min);
 +}
 +EXPORT_SYMBOL_GPL(vxlan_src_port);
 +
++=======
++>>>>>>> 535fb8d006bc (vxlan: Call udp_flow_src_port)
  static inline struct sk_buff *vxlan_handle_offloads(struct sk_buff *skb,
  						    bool udp_csum)
  {
@@@ -2254,9 -2253,6 +2257,12 @@@ static void vxlan_setup(struct net_devi
  	vxlan->age_timer.function = vxlan_cleanup;
  	vxlan->age_timer.data = (unsigned long) vxlan;
  
++<<<<<<< HEAD
 +	inet_get_local_port_range(&low, &high);
 +	vxlan->port_min = low;
 +	vxlan->port_max = high;
++=======
++>>>>>>> 535fb8d006bc (vxlan: Call udp_flow_src_port)
  	vxlan->dst_port = htons(vxlan_port);
  
  	vxlan->dev = dev;
diff --cc net/openvswitch/vport-vxlan.c
index 05c0853994c1,d8b7e247bebf..000000000000
--- a/net/openvswitch/vport-vxlan.c
+++ b/net/openvswitch/vport-vxlan.c
@@@ -170,12 -168,11 +168,16 @@@ static int vxlan_tnl_send(struct vport 
  	df = OVS_CB(skb)->tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ?
  		htons(IP_DF) : 0;
  
 -	skb->ignore_df = 1;
 +	skb->local_df = 1;
  
++<<<<<<< HEAD
 +	inet_get_local_port_range(&port_min, &port_max);
 +	src_port = vxlan_src_port(port_min, port_max, skb);
++=======
+ 	src_port = udp_flow_src_port(net, skb, 0, 0, true);
++>>>>>>> 535fb8d006bc (vxlan: Call udp_flow_src_port)
  
 -	err = vxlan_xmit_skb(vxlan_port->vs, rt, skb,
 +	err = vxlan_xmit_skb(net, vxlan_port->vs, rt, skb,
  			     fl.saddr, OVS_CB(skb)->tun_key->ipv4_dst,
  			     OVS_CB(skb)->tun_key->ipv4_tos,
  			     OVS_CB(skb)->tun_key->ipv4_ttl, df,
* Unmerged path drivers/net/vxlan.c
diff --git a/include/net/vxlan.h b/include/net/vxlan.h
index 4a48f0737b86..1ddc74769f81 100644
--- a/include/net/vxlan.h
+++ b/include/net/vxlan.h
@@ -45,8 +45,6 @@ int vxlan_xmit_skb(struct net *net, struct vxlan_sock *vs,
 		   __be32 src, __be32 dst, __u8 tos, __u8 ttl, __be16 df,
 		   __be16 src_port, __be16 dst_port, __be32 vni);
 
-__be16 vxlan_src_port(__u16 port_min, __u16 port_max, struct sk_buff *skb);
-
 /* IP header + UDP + VXLAN + Ethernet header */
 #define VXLAN_HEADROOM (20 + 8 + 8 + 14)
 /* IPv6 header + UDP + VXLAN + Ethernet header */
* Unmerged path net/openvswitch/vport-vxlan.c
