ACPI / hotplug / PCI: Simplify acpi_install_hotplug_notify_handler()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Simplify acpi_install_hotplug_notify_handler() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 92.91%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 5e6f236c263117cef5f0d68e3fec241ba2adc4fc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5e6f236c.failed

Since acpi_hotplug_notify_cb() does not use its data argument any
more, the second argument of acpi_install_hotplug_notify_handler()
can be dropped, so do that and update its callers accordingly.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 5e6f236c263117cef5f0d68e3fec241ba2adc4fc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
#	drivers/pci/hotplug/acpiphp_glue.c
#	include/acpi/acpi_bus.h
diff --cc drivers/acpi/scan.c
index b30a50799f84,59f9e272562e..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -445,9 -571,22 +445,28 @@@ static void acpi_hotplug_notify_cb(acpi
  	if (ACPI_SUCCESS(status))
  		return;
  
++<<<<<<< HEAD
 + err_out:
 +	acpi_evaluate_hotplug_ost(handle, type,
 +				  ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);
++=======
+ 	acpi_bus_put_acpi_device(adev);
+ 
+  out:
+ 	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
+ }
+ 
+ void acpi_install_hotplug_notify_handler(acpi_handle handle)
+ {
+ 	acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
+ 				    acpi_hotplug_notify_cb, NULL);
+ }
+ 
+ void acpi_remove_hotplug_notify_handler(acpi_handle handle)
+ {
+ 	acpi_remove_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
+ 				   acpi_hotplug_notify_cb);
++>>>>>>> 5e6f236c2631 (ACPI / hotplug / PCI: Simplify acpi_install_hotplug_notify_handler())
  }
  
  static ssize_t real_power_state_show(struct device *dev,
@@@ -1809,33 -2029,21 +1828,42 @@@ void acpi_scan_hotplug_enabled(struct a
  	mutex_unlock(&acpi_scan_lock);
  }
  
 -static void acpi_scan_init_hotplug(struct acpi_device *adev)
 +static void acpi_scan_init_hotplug(acpi_handle handle, int type)
  {
 +	struct acpi_device_pnp pnp = {};
  	struct acpi_hardware_id *hwid;
 +	struct acpi_scan_handler *handler;
  
 -	list_for_each_entry(hwid, &adev->pnp.ids, list) {
 -		struct acpi_scan_handler *handler;
 +	INIT_LIST_HEAD(&pnp.ids);
 +	acpi_set_pnp_ids(handle, &pnp, type);
  
 +	if (!pnp.type.hardware_id)
 +		goto out;
 +
 +	/*
 +	 * This relies on the fact that acpi_install_notify_handler() will not
 +	 * install the same notify handler routine twice for the same handle.
 +	 */
 +	list_for_each_entry(hwid, &pnp.ids, list) {
  		handler = acpi_scan_match_handler(hwid->id, NULL);
++<<<<<<< HEAD
 +		if (handler && !handler->hotplug.ignore) {
 +			acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
 +					acpi_hotplug_notify_cb, handler);
 +			break;
 +		}
++=======
+ 		if (!handler)
+ 			continue;
+ 
+ 		acpi_install_hotplug_notify_handler(adev->handle);
+ 		adev->flags.hotplug_notify = true;
+ 		break;
++>>>>>>> 5e6f236c2631 (ACPI / hotplug / PCI: Simplify acpi_install_hotplug_notify_handler())
  	}
 +
 +out:
 +	acpi_free_pnp_ids(&pnp);
  }
  
  static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,f3c49c442d93..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -327,26 -375,8 +327,31 @@@ register_slot(acpi_handle handle, u32 l
  	}
  
  	/* install notify handler */
++<<<<<<< HEAD
 +	if (!(newfunc->flags & FUNC_HAS_DCK)) {
 +		status = acpi_install_notify_handler(handle,
 +					     ACPI_SYSTEM_NOTIFY,
 +					     handle_hotplug_event_func,
 +					     newfunc);
 +
 +		if (ACPI_FAILURE(status))
 +			pr_err("failed to register interrupt notify handler\n");
 +	} else
 +		status = AE_OK;
 +
 +	return status;
 +
 + err_exit:
 +	bridge->nr_slots--;
 +	mutex_lock(&bridge_mutex);
 +	list_del(&slot->node);
 +	mutex_unlock(&bridge_mutex);
 +	kfree(slot);
 +	kfree(newfunc);
++=======
+ 	if (!(newfunc->flags & FUNC_HAS_DCK))
+ 		acpi_install_hotplug_notify_handler(handle);
++>>>>>>> 5e6f236c2631 (ACPI / hotplug / PCI: Simplify acpi_install_hotplug_notify_handler())
  
  	return AE_OK;
  }
diff --cc include/acpi/acpi_bus.h
index f5d6e1e4030e,907d5078f78a..000000000000
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@@ -398,6 -438,16 +398,19 @@@ int acpi_match_device_ids(struct acpi_d
  int acpi_create_dir(struct acpi_device *);
  void acpi_remove_dir(struct acpi_device *);
  
++<<<<<<< HEAD
++=======
+ static inline bool acpi_device_enumerated(struct acpi_device *adev)
+ {
+ 	return adev && adev->flags.initialized && adev->flags.visited;
+ }
+ 
+ typedef void (*acpi_hp_callback)(void *data, u32 src);
+ 
+ acpi_status acpi_hotplug_execute(acpi_hp_callback func, void *data, u32 src);
+ void acpi_install_hotplug_notify_handler(acpi_handle handle);
+ void acpi_remove_hotplug_notify_handler(acpi_handle handle);
++>>>>>>> 5e6f236c2631 (ACPI / hotplug / PCI: Simplify acpi_install_hotplug_notify_handler())
  
  /**
   * module_acpi_driver(acpi_driver) - Helper macro for registering an ACPI driver
* Unmerged path drivers/acpi/scan.c
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
* Unmerged path include/acpi/acpi_bus.h
