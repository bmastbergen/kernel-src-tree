iommu/vt-d: Remove device_to_iommu() call from domain_remove_dev_info()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Remove device_to_iommu() call from domain_remove_dev_info() (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 95.59%
commit-author David Woodhouse <David.Woodhouse@intel.com>
commit 7c7faa11ecf3eec17699ae73fc6e336cbf993081
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/7c7faa11.failed

This was problematic because it works by domain/bus/devfn and we want
to make device_to_iommu() use only a struct device * (for handling non-PCI
devices). Now that the iommu pointer is reliably stored in the
device_domain_info, we don't need to look it up.

	Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
(cherry picked from commit 7c7faa11ecf3eec17699ae73fc6e336cbf993081)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 78f8d07de7e0,aa8548c8a915..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -1988,8 -2083,7 +1988,12 @@@ static inline void unlink_domain_info(s
  static void domain_remove_dev_info(struct dmar_domain *domain)
  {
  	struct device_domain_info *info;
++<<<<<<< HEAD
 +	unsigned long flags;
 +	struct intel_iommu *iommu;
++=======
+ 	unsigned long flags, flags2;
++>>>>>>> 7c7faa11ecf3 (iommu/vt-d: Remove device_to_iommu() call from domain_remove_dev_info())
  
  	spin_lock_irqsave(&device_domain_lock, flags);
  	while (!list_empty(&domain->devices)) {
@@@ -1999,10 -2093,23 +2003,29 @@@
  		spin_unlock_irqrestore(&device_domain_lock, flags);
  
  		iommu_disable_dev_iotlb(info);
++<<<<<<< HEAD
 +		iommu = device_to_iommu(info->segment, info->bus, info->devfn);
 +		iommu_detach_dev(iommu, info->bus, info->devfn);
++=======
+ 		iommu_detach_dev(info->iommu, info->bus, info->devfn);
+ 
+ 		if (domain->flags & DOMAIN_FLAG_VIRTUAL_MACHINE) {
+ 			iommu_detach_dependent_devices(info->iommu, info->dev);
+ 			/* clear this iommu in iommu_bmp, update iommu count
+ 			 * and capabilities
+ 			 */
+ 			spin_lock_irqsave(&domain->iommu_lock, flags2);
+ 			if (test_and_clear_bit(info->iommu->seq_id,
+ 					       domain->iommu_bmp)) {
+ 				domain->iommu_count--;
+ 				domain_update_iommu_cap(domain);
+ 			}
+ 			spin_unlock_irqrestore(&domain->iommu_lock, flags2);
+ 		}
+ 
++>>>>>>> 7c7faa11ecf3 (iommu/vt-d: Remove device_to_iommu() call from domain_remove_dev_info())
  		free_devinfo_mem(info);
 +
  		spin_lock_irqsave(&device_domain_lock, flags);
  	}
  	spin_unlock_irqrestore(&device_domain_lock, flags);
* Unmerged path drivers/iommu/intel-iommu.c
