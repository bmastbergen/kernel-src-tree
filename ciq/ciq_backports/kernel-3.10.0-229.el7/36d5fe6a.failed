core, nfqueue, openvswitch: Orphan frags in skb_zerocopy and handle errors

jira LE-1907
cve CVE-2014-2568
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Zoltan Kiss <zoltan.kiss@citrix.com>
commit 36d5fe6a000790f56039afe26834265db0a3ad4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/36d5fe6a.failed

skb_zerocopy can copy elements of the frags array between skbs, but it doesn't
orphan them. Also, it doesn't handle errors, so this patch takes care of that
as well, and modify the callers accordingly. skb_tx_error() is also added to
the callers so they will signal the failed delivery towards the creator of the
skb.

	Signed-off-by: Zoltan Kiss <zoltan.kiss@citrix.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 36d5fe6a000790f56039afe26834265db0a3ad4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
diff --cc include/linux/skbuff.h
index 5832e933a0f2,15ede6a823a6..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -2399,61 -2421,54 +2399,69 @@@ static inline void skb_frag_add_head(st
  #define skb_walk_frags(skb, iter)	\
  	for (iter = skb_shinfo(skb)->frag_list; iter; iter = iter->next)
  
 -struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
 -				    int *peeked, int *off, int *err);
 -struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags, int noblock,
 -				  int *err);
 -unsigned int datagram_poll(struct file *file, struct socket *sock,
 -			   struct poll_table_struct *wait);
 -int skb_copy_datagram_iovec(const struct sk_buff *from, int offset,
 -			    struct iovec *to, int size);
 -int skb_copy_and_csum_datagram_iovec(struct sk_buff *skb, int hlen,
 -				     struct iovec *iov);
 -int skb_copy_datagram_from_iovec(struct sk_buff *skb, int offset,
 -				 const struct iovec *from, int from_offset,
 -				 int len);
 -int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *frm,
 -			   int offset, size_t count);
 -int skb_copy_datagram_const_iovec(const struct sk_buff *from, int offset,
 -				  const struct iovec *to, int to_offset,
 -				  int size);
 -void skb_free_datagram(struct sock *sk, struct sk_buff *skb);
 -void skb_free_datagram_locked(struct sock *sk, struct sk_buff *skb);
 -int skb_kill_datagram(struct sock *sk, struct sk_buff *skb, unsigned int flags);
 -int skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len);
 -int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len);
 -__wsum skb_copy_and_csum_bits(const struct sk_buff *skb, int offset, u8 *to,
 -			      int len, __wsum csum);
 -int skb_splice_bits(struct sk_buff *skb, unsigned int offset,
 -		    struct pipe_inode_info *pipe, unsigned int len,
 -		    unsigned int flags);
 -void skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to);
 +extern struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
 +					   int *peeked, int *off, int *err);
 +extern struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags,
 +					 int noblock, int *err);
 +extern unsigned int    datagram_poll(struct file *file, struct socket *sock,
 +				     struct poll_table_struct *wait);
 +extern int	       skb_copy_datagram_iovec(const struct sk_buff *from,
 +					       int offset, struct iovec *to,
 +					       int size);
 +extern int	       skb_copy_and_csum_datagram_iovec(struct sk_buff *skb,
 +							int hlen,
 +							struct iovec *iov);
 +extern int	       skb_copy_datagram_from_iovec(struct sk_buff *skb,
 +						    int offset,
 +						    const struct iovec *from,
 +						    int from_offset,
 +						    int len);
 +extern int	       skb_copy_datagram_const_iovec(const struct sk_buff *from,
 +						     int offset,
 +						     const struct iovec *to,
 +						     int to_offset,
 +						     int size);
 +extern void	       skb_free_datagram(struct sock *sk, struct sk_buff *skb);
 +extern void	       skb_free_datagram_locked(struct sock *sk,
 +						struct sk_buff *skb);
 +extern int	       skb_kill_datagram(struct sock *sk, struct sk_buff *skb,
 +					 unsigned int flags);
 +extern __wsum	       skb_checksum(const struct sk_buff *skb, int offset,
 +				    int len, __wsum csum);
 +extern int	       skb_copy_bits(const struct sk_buff *skb, int offset,
 +				     void *to, int len);
 +extern int	       skb_store_bits(struct sk_buff *skb, int offset,
 +				      const void *from, int len);
 +extern __wsum	       skb_copy_and_csum_bits(const struct sk_buff *skb,
 +					      int offset, u8 *to, int len,
 +					      __wsum csum);
 +extern int             skb_splice_bits(struct sk_buff *skb,
 +						unsigned int offset,
 +						struct pipe_inode_info *pipe,
 +						unsigned int len,
 +						unsigned int flags);
 +extern void	       skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to);
  unsigned int skb_zerocopy_headlen(const struct sk_buff *from);
++<<<<<<< HEAD
 +void skb_zerocopy(struct sk_buff *to, const struct sk_buff *from,
 +                 int len, int hlen);
 +
 +extern void	       skb_split(struct sk_buff *skb,
 +				 struct sk_buff *skb1, const u32 len);
 +extern int	       skb_shift(struct sk_buff *tgt, struct sk_buff *skb,
 +				 int shiftlen);
 +extern void	       skb_scrub_packet(struct sk_buff *skb);
++=======
+ int skb_zerocopy(struct sk_buff *to, struct sk_buff *from,
+ 		 int len, int hlen);
+ void skb_split(struct sk_buff *skb, struct sk_buff *skb1, const u32 len);
+ int skb_shift(struct sk_buff *tgt, struct sk_buff *skb, int shiftlen);
+ void skb_scrub_packet(struct sk_buff *skb, bool xnet);
++>>>>>>> 36d5fe6a0007 (core, nfqueue, openvswitch: Orphan frags in skb_zerocopy and handle errors)
  unsigned int skb_gso_transport_seglen(const struct sk_buff *skb);
 -struct sk_buff *skb_segment(struct sk_buff *skb, netdev_features_t features);
 -
 -struct skb_checksum_ops {
 -	__wsum (*update)(const void *mem, int len, __wsum wsum);
 -	__wsum (*combine)(__wsum csum, __wsum csum2, int offset, int len);
 -};
 -
 -__wsum __skb_checksum(const struct sk_buff *skb, int offset, int len,
 -		      __wsum csum, const struct skb_checksum_ops *ops);
 -__wsum skb_checksum(const struct sk_buff *skb, int offset, int len,
 -		    __wsum csum);
  
 +extern struct sk_buff *skb_segment(struct sk_buff *skb,
 +				   netdev_features_t features);
  static inline void *skb_header_pointer(const struct sk_buff *skb, int offset,
  				       int len, void *buffer)
  {
* Unmerged path include/linux/skbuff.h
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index dd3aefbfd232..38978709e869 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -2113,25 +2113,31 @@ EXPORT_SYMBOL_GPL(skb_zerocopy_headlen);
  *
  *	The `hlen` as calculated by skb_zerocopy_headlen() specifies the
  *	headroom in the `to` buffer.
+ *
+ *	Return value:
+ *	0: everything is OK
+ *	-ENOMEM: couldn't orphan frags of @from due to lack of memory
+ *	-EFAULT: skb_copy_bits() found some problem with skb geometry
  */
-void
-skb_zerocopy(struct sk_buff *to, const struct sk_buff *from, int len, int hlen)
+int
+skb_zerocopy(struct sk_buff *to, struct sk_buff *from, int len, int hlen)
 {
 	int i, j = 0;
 	int plen = 0; /* length of skb->head fragment */
+	int ret;
 	struct page *page;
 	unsigned int offset;
 
 	BUG_ON(!from->head_frag && !hlen);
 
 	/* dont bother with small payloads */
-	if (len <= skb_tailroom(to)) {
-		skb_copy_bits(from, 0, skb_put(to, len), len);
-		return;
-	}
+	if (len <= skb_tailroom(to))
+		return skb_copy_bits(from, 0, skb_put(to, len), len);
 
 	if (hlen) {
-		skb_copy_bits(from, 0, skb_put(to, hlen), hlen);
+		ret = skb_copy_bits(from, 0, skb_put(to, hlen), hlen);
+		if (unlikely(ret))
+			return ret;
 		len -= hlen;
 	} else {
 		plen = min_t(int, skb_headlen(from), len);
@@ -2149,6 +2155,11 @@ skb_zerocopy(struct sk_buff *to, const struct sk_buff *from, int len, int hlen)
 	to->len += len + plen;
 	to->data_len += len + plen;
 
+	if (unlikely(skb_orphan_frags(from, GFP_ATOMIC))) {
+		skb_tx_error(from);
+		return -ENOMEM;
+	}
+
 	for (i = 0; i < skb_shinfo(from)->nr_frags; i++) {
 		if (!len)
 			break;
@@ -2159,6 +2170,8 @@ skb_zerocopy(struct sk_buff *to, const struct sk_buff *from, int len, int hlen)
 		j++;
 	}
 	skb_shinfo(to)->nr_frags = j;
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(skb_zerocopy);
 
diff --git a/net/netfilter/nfnetlink_queue_core.c b/net/netfilter/nfnetlink_queue_core.c
index c227d2679708..8f24e23976a1 100644
--- a/net/netfilter/nfnetlink_queue_core.c
+++ b/net/netfilter/nfnetlink_queue_core.c
@@ -315,13 +315,16 @@ nfqnl_build_packet_message(struct nfqnl_instance *queue,
 
 	skb = nfnetlink_alloc_skb(&init_net, size, queue->peer_portid,
 				  GFP_ATOMIC);
-	if (!skb)
+	if (!skb) {
+		skb_tx_error(entskb);
 		return NULL;
+	}
 
 	nlh = nlmsg_put(skb, 0, 0,
 			NFNL_SUBSYS_QUEUE << 8 | NFQNL_MSG_PACKET,
 			sizeof(struct nfgenmsg), 0);
 	if (!nlh) {
+		skb_tx_error(entskb);
 		kfree_skb(skb);
 		return NULL;
 	}
@@ -444,13 +447,15 @@ nfqnl_build_packet_message(struct nfqnl_instance *queue,
 		nla->nla_type = NFQA_PAYLOAD;
 		nla->nla_len = nla_attr_size(data_len);
 
-		skb_zerocopy(skb, entskb, data_len, hlen);
+		if (skb_zerocopy(skb, entskb, data_len, hlen))
+			goto nla_put_failure;
 	}
 
 	nlh->nlmsg_len = skb->len;
 	return skb;
 
 nla_put_failure:
+	skb_tx_error(entskb);
 	kfree_skb(skb);
 	net_err_ratelimited("nf_queue: error creating packet message\n");
 	return NULL;
diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c
index 68fd03cc34f5..2b3c0af05364 100644
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@ -464,7 +464,9 @@ static int queue_userspace_packet(struct datapath *dp, struct sk_buff *skb,
 	}
 	nla->nla_len = nla_attr_size(skb->len);
 
-	skb_zerocopy(user_skb, skb, skb->len, hlen);
+	err = skb_zerocopy(user_skb, skb, skb->len, hlen);
+	if (err)
+		goto out;
 
 	/* Pad OVS_PACKET_ATTR_PACKET if linear copy was performed */
 	if (!(dp->user_features & OVS_DP_F_UNALIGNED)) {
@@ -478,6 +480,8 @@ static int queue_userspace_packet(struct datapath *dp, struct sk_buff *skb,
 
 	err = genlmsg_unicast(ovs_dp_get_net(dp), user_skb, upcall_info->portid);
 out:
+	if (err)
+		skb_tx_error(skb);
 	kfree_skb(nskb);
 	return err;
 }
