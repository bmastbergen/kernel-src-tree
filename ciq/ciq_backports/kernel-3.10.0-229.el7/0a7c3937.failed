vfs: add RENAME_NOREPLACE flag

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit 0a7c3937a1f23f8cb5fc77ae01661e9968a51d0c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0a7c3937.failed

If this flag is specified and the target of the rename exists then the
rename syscall fails with EEXIST.

The VFS does the existence checking, so it is trivial to enable for most
local filesystems.  This patch only enables it in ext4.

For network filesystems the VFS check is not enough as there may be a race
between a remote create and the rename, so these filesystems need to handle
this flag in their ->rename() implementations to ensure atomicity.

Andy writes about why this is useful:

"The trivial answer: to eliminate the race condition from 'mv -i'.

Another answer: there's a common pattern to atomically create a file
with contents: open a temporary file, write to it, optionally fsync
it, close it, then link(2) it to the final name, then unlink the
temporary file.

The reason to use link(2) is because it won't silently clobber the destination.

This is annoying:
 - It requires an extra system call that shouldn't be necessary.
 - It doesn't work on (IMO sensible) filesystems that don't support
hard links (e.g. vfat).
 - It's not atomic -- there's an intermediate state where both files exist.
 - It's ugly.

The new rename flag will make this totally sensible.

To be fair, on new enough kernels, you can also use O_TMPFILE and
linkat to achieve the same thing even more cleanly."

	Suggested-by: Andy Lutomirski <luto@amacapital.net> 
	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
	Reviewed-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 0a7c3937a1f23f8cb5fc77ae01661e9968a51d0c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/namei.c
diff --cc fs/namei.c
index d87d2e09b208,0e9d186b7f77..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -4149,6 -4141,10 +4149,13 @@@ SYSCALL_DEFINE4(renameat, int, olddfd, 
  	unsigned int lookup_flags = 0;
  	bool should_retry = false;
  	int error;
++<<<<<<< HEAD
++=======
+ 
+ 	if (flags & ~RENAME_NOREPLACE)
+ 		return -EINVAL;
+ 
++>>>>>>> 0a7c3937a1f2 (vfs: add RENAME_NOREPLACE flag)
  retry:
  	from = user_path_parent(olddfd, oldname, &oldnd, lookup_flags);
  	if (IS_ERR(from)) {
@@@ -4192,20 -4190,8 +4201,23 @@@ retry_deleg
  		goto exit3;
  	/* source must exist */
  	error = -ENOENT;
 -	if (d_is_negative(old_dentry))
 +	if (!old_dentry->d_inode)
  		goto exit4;
++<<<<<<< HEAD
 +	/* unless the source is a directory trailing slashes give -ENOTDIR */
 +	if (!S_ISDIR(old_dentry->d_inode->i_mode)) {
 +		error = -ENOTDIR;
 +		if (oldnd.last.name[oldnd.last.len])
 +			goto exit4;
 +		if (newnd.last.name[newnd.last.len])
 +			goto exit4;
 +	}
 +	/* source should not be ancestor of target */
 +	error = -EINVAL;
 +	if (old_dentry == trap)
 +		goto exit4;
++=======
++>>>>>>> 0a7c3937a1f2 (vfs: add RENAME_NOREPLACE flag)
  	new_dentry = lookup_hash(&newnd);
  	error = PTR_ERR(new_dentry);
  	if (IS_ERR(new_dentry))
diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c
index 02ee66b9dd7b..e6cdb9bfd958 100644
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@ -3248,6 +3248,16 @@ end_rename:
 	return retval;
 }
 
+static int ext4_rename2(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry,
+			unsigned int flags)
+{
+	if (flags & ~RENAME_NOREPLACE)
+		return -EINVAL;
+
+	return ext4_rename(old_dir, old_dentry, new_dir, new_dentry);
+}
+
 /*
  * directories can handle most operations...
  */
@@ -3261,6 +3271,7 @@ const struct inode_operations ext4_dir_inode_operations = {
 	.rmdir		= ext4_rmdir,
 	.mknod		= ext4_mknod,
 	.rename		= ext4_rename,
+	.rename2	= ext4_rename2,
 	.setattr	= ext4_setattr,
 	.setxattr	= generic_setxattr,
 	.getxattr	= generic_getxattr,
* Unmerged path fs/namei.c
diff --git a/include/uapi/linux/fs.h b/include/uapi/linux/fs.h
index a4ed56cf0eac..644ab863d6a9 100644
--- a/include/uapi/linux/fs.h
+++ b/include/uapi/linux/fs.h
@@ -35,6 +35,8 @@
 #define SEEK_HOLE	4	/* seek to the next hole */
 #define SEEK_MAX	SEEK_HOLE
 
+#define RENAME_NOREPLACE	(1 << 0)	/* Don't overwrite target */
+
 struct fstrim_range {
 	__u64 start;
 	__u64 len;
