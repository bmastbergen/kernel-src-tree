xprtrdma: Remove REGISTER memory registration mode

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] sunrpc/xprtrdma: Remove REGISTER memory registration mode (Steve Dickson) [1113248]
Rebuild_FUZZ: 93.46%
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 0ac531c1832318efa3dc3d723e356a7e09330e80
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0ac531c1.failed

All kernel RDMA providers except amso1100 support either MTHCAFMR
or FRMR, both of which are faster than REGISTER.  amso1100 can
continue to use ALLPHYSICAL.

The only other ULP consumer in the kernel that uses the reg_phys_mr
verb is Lustre.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 0ac531c1832318efa3dc3d723e356a7e09330e80)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/verbs.c
diff --cc net/sunrpc/xprtrdma/verbs.c
index 0ce6cc091efd,6bb9a07f7d49..000000000000
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@@ -494,19 -492,8 +494,18 @@@ rpcrdma_ia_open(struct rpcrdma_xprt *xp
  	}
  
  	switch (memreg) {
 +	case RPCRDMA_MEMWINDOWS:
 +	case RPCRDMA_MEMWINDOWS_ASYNC:
 +		if (!(devattr.device_cap_flags & IB_DEVICE_MEM_WINDOW)) {
 +			dprintk("RPC:       %s: MEMWINDOWS registration "
 +				"specified but not supported by adapter, "
 +				"using slower RPCRDMA_REGISTER\n",
 +				__func__);
 +			memreg = RPCRDMA_REGISTER;
 +		}
 +		break;
  	case RPCRDMA_MTHCAFMR:
  		if (!ia->ri_id->device->alloc_fmr) {
- #if RPCRDMA_PERSISTENT_REGISTRATION
  			dprintk("RPC:       %s: MTHCAFMR registration "
  				"specified but not supported by adapter, "
  				"using riskier RPCRDMA_ALLPHYSICAL\n",
@@@ -1684,135 -1593,6 +1666,138 @@@ rpcrdma_deregister_fmr_external(struct 
  	return rc;
  }
  
++<<<<<<< HEAD
 +static int
 +rpcrdma_register_memwin_external(struct rpcrdma_mr_seg *seg,
 +			int *nsegs, int writing, struct rpcrdma_ia *ia,
 +			struct rpcrdma_xprt *r_xprt)
 +{
 +	int mem_priv = (writing ? IB_ACCESS_REMOTE_WRITE :
 +				  IB_ACCESS_REMOTE_READ);
 +	struct ib_mw_bind param;
 +	int rc;
 +
 +	*nsegs = 1;
 +	rpcrdma_map_one(ia, seg, writing);
 +	param.bind_info.mr = ia->ri_bind_mem;
 +	param.wr_id = 0ULL;	/* no send cookie */
 +	param.bind_info.addr = seg->mr_dma;
 +	param.bind_info.length = seg->mr_len;
 +	param.send_flags = 0;
 +	param.bind_info.mw_access_flags = mem_priv;
 +
 +	DECR_CQCOUNT(&r_xprt->rx_ep);
 +	rc = ib_bind_mw(ia->ri_id->qp, seg->mr_chunk.rl_mw->r.mw, &param);
 +	if (rc) {
 +		dprintk("RPC:       %s: failed ib_bind_mw "
 +			"%u@0x%llx status %i\n",
 +			__func__, seg->mr_len,
 +			(unsigned long long)seg->mr_dma, rc);
 +		rpcrdma_unmap_one(ia, seg);
 +	} else {
 +		seg->mr_rkey = seg->mr_chunk.rl_mw->r.mw->rkey;
 +		seg->mr_base = param.bind_info.addr;
 +		seg->mr_nsegs = 1;
 +	}
 +	return rc;
 +}
 +
 +static int
 +rpcrdma_deregister_memwin_external(struct rpcrdma_mr_seg *seg,
 +			struct rpcrdma_ia *ia,
 +			struct rpcrdma_xprt *r_xprt, void **r)
 +{
 +	struct ib_mw_bind param;
 +	LIST_HEAD(l);
 +	int rc;
 +
 +	BUG_ON(seg->mr_nsegs != 1);
 +	param.bind_info.mr = ia->ri_bind_mem;
 +	param.bind_info.addr = 0ULL;	/* unbind */
 +	param.bind_info.length = 0;
 +	param.bind_info.mw_access_flags = 0;
 +	if (*r) {
 +		param.wr_id = (u64) (unsigned long) *r;
 +		param.send_flags = IB_SEND_SIGNALED;
 +		INIT_CQCOUNT(&r_xprt->rx_ep);
 +	} else {
 +		param.wr_id = 0ULL;
 +		param.send_flags = 0;
 +		DECR_CQCOUNT(&r_xprt->rx_ep);
 +	}
 +	rc = ib_bind_mw(ia->ri_id->qp, seg->mr_chunk.rl_mw->r.mw, &param);
 +	rpcrdma_unmap_one(ia, seg);
 +	if (rc)
 +		dprintk("RPC:       %s: failed ib_(un)bind_mw,"
 +			" status %i\n", __func__, rc);
 +	else
 +		*r = NULL;	/* will upcall on completion */
 +	return rc;
 +}
 +
 +static int
 +rpcrdma_register_default_external(struct rpcrdma_mr_seg *seg,
 +			int *nsegs, int writing, struct rpcrdma_ia *ia)
 +{
 +	int mem_priv = (writing ? IB_ACCESS_REMOTE_WRITE :
 +				  IB_ACCESS_REMOTE_READ);
 +	struct rpcrdma_mr_seg *seg1 = seg;
 +	struct ib_phys_buf ipb[RPCRDMA_MAX_DATA_SEGS];
 +	int len, i, rc = 0;
 +
 +	if (*nsegs > RPCRDMA_MAX_DATA_SEGS)
 +		*nsegs = RPCRDMA_MAX_DATA_SEGS;
 +	for (len = 0, i = 0; i < *nsegs;) {
 +		rpcrdma_map_one(ia, seg, writing);
 +		ipb[i].addr = seg->mr_dma;
 +		ipb[i].size = seg->mr_len;
 +		len += seg->mr_len;
 +		++seg;
 +		++i;
 +		/* Check for holes */
 +		if ((i < *nsegs && offset_in_page(seg->mr_offset)) ||
 +		    offset_in_page((seg-1)->mr_offset+(seg-1)->mr_len))
 +			break;
 +	}
 +	seg1->mr_base = seg1->mr_dma;
 +	seg1->mr_chunk.rl_mr = ib_reg_phys_mr(ia->ri_pd,
 +				ipb, i, mem_priv, &seg1->mr_base);
 +	if (IS_ERR(seg1->mr_chunk.rl_mr)) {
 +		rc = PTR_ERR(seg1->mr_chunk.rl_mr);
 +		dprintk("RPC:       %s: failed ib_reg_phys_mr "
 +			"%u@0x%llx (%d)... status %i\n",
 +			__func__, len,
 +			(unsigned long long)seg1->mr_dma, i, rc);
 +		while (i--)
 +			rpcrdma_unmap_one(ia, --seg);
 +	} else {
 +		seg1->mr_rkey = seg1->mr_chunk.rl_mr->rkey;
 +		seg1->mr_nsegs = i;
 +		seg1->mr_len = len;
 +	}
 +	*nsegs = i;
 +	return rc;
 +}
 +
 +static int
 +rpcrdma_deregister_default_external(struct rpcrdma_mr_seg *seg,
 +			struct rpcrdma_ia *ia)
 +{
 +	struct rpcrdma_mr_seg *seg1 = seg;
 +	int rc;
 +
 +	rc = ib_dereg_mr(seg1->mr_chunk.rl_mr);
 +	seg1->mr_chunk.rl_mr = NULL;
 +	while (seg1->mr_nsegs--)
 +		rpcrdma_unmap_one(ia, seg++);
 +	if (rc)
 +		dprintk("RPC:       %s: failed ib_dereg_mr,"
 +			" status %i\n", __func__, rc);
 +	return rc;
 +}
 +
++=======
++>>>>>>> 0ac531c18323 (xprtrdma: Remove REGISTER memory registration mode)
  int
  rpcrdma_register_external(struct rpcrdma_mr_seg *seg,
  			int nsegs, int writing, struct rpcrdma_xprt *r_xprt)
@@@ -1842,16 -1622,8 +1827,18 @@@
  		rc = rpcrdma_register_fmr_external(seg, &nsegs, writing, ia);
  		break;
  
++<<<<<<< HEAD
 +	/* Registration using memory windows */
 +	case RPCRDMA_MEMWINDOWS_ASYNC:
 +	case RPCRDMA_MEMWINDOWS:
 +		rc = rpcrdma_register_memwin_external(seg, &nsegs, writing, ia, r_xprt);
 +		break;
 +
 +	/* Default registration each time */
++=======
++>>>>>>> 0ac531c18323 (xprtrdma: Remove REGISTER memory registration mode)
  	default:
- 		rc = rpcrdma_register_default_external(seg, &nsegs, writing, ia);
- 		break;
+ 		return -1;
  	}
  	if (rc)
  		return -1;
@@@ -1884,13 -1656,7 +1871,12 @@@ rpcrdma_deregister_external(struct rpcr
  		rc = rpcrdma_deregister_fmr_external(seg, ia);
  		break;
  
 +	case RPCRDMA_MEMWINDOWS_ASYNC:
 +	case RPCRDMA_MEMWINDOWS:
 +		rc = rpcrdma_deregister_memwin_external(seg, ia, r_xprt, &r);
 +		break;
 +
  	default:
- 		rc = rpcrdma_deregister_default_external(seg, ia);
  		break;
  	}
  	if (r) {
diff --git a/net/sunrpc/xprtrdma/rpc_rdma.c b/net/sunrpc/xprtrdma/rpc_rdma.c
index 02b29419e372..74973a53c077 100644
--- a/net/sunrpc/xprtrdma/rpc_rdma.c
+++ b/net/sunrpc/xprtrdma/rpc_rdma.c
@@ -477,8 +477,7 @@ rpcrdma_marshal_req(struct rpc_rqst *rqst)
 			 * on receive. Therefore, we request a reply chunk
 			 * for non-writes wherever feasible and efficient.
 			 */
-			if (wtype == rpcrdma_noch &&
-			    r_xprt->rx_ia.ri_memreg_strategy > RPCRDMA_REGISTER)
+			if (wtype == rpcrdma_noch)
 				wtype = rpcrdma_replych;
 		}
 	}
* Unmerged path net/sunrpc/xprtrdma/verbs.c
