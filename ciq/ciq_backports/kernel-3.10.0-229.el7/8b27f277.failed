skb: allow skb_scrub_packet() to be used by tunnels

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Nicolas Dichtel <nicolas.dichtel@6wind.com>
commit 8b27f27797cac5ed9b2f3e63dac89a7ae70e70a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/8b27f277.failed

This function was only used when a packet was sent to another netns. Now, it can
also be used after tunnel encapsulation or decapsulation.

Only skb_orphan() should not be done when a packet is not crossing netns.

	Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8b27f27797cac5ed9b2f3e63dac89a7ae70e70a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/core/dev.c
#	net/ipv4/ip_tunnel.c
#	net/ipv6/sit.c
diff --cc include/linux/skbuff.h
index a03fd0ae9875,2ddb48d9312c..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -2454,8 -2392,7 +2454,12 @@@ extern void	       skb_split(struct sk_
  				 struct sk_buff *skb1, const u32 len);
  extern int	       skb_shift(struct sk_buff *tgt, struct sk_buff *skb,
  				 int shiftlen);
++<<<<<<< HEAD
 +extern void	       skb_scrub_packet(struct sk_buff *skb);
 +unsigned int skb_gso_transport_seglen(const struct sk_buff *skb);
++=======
+ extern void	       skb_scrub_packet(struct sk_buff *skb, bool xnet);
++>>>>>>> 8b27f27797ca (skb: allow skb_scrub_packet() to be used by tunnels)
  
  extern struct sk_buff *skb_segment(struct sk_buff *skb,
  				   netdev_features_t features);
diff --cc net/core/dev.c
index 8e05b1bc1044,07684e880a5d..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -1667,8 -1691,14 +1667,19 @@@ int dev_forward_skb(struct net_device *
  		kfree_skb(skb);
  		return NET_RX_DROP;
  	}
++<<<<<<< HEAD
 +	skb_scrub_packet(skb);
 +	skb->protocol = eth_type_trans(skb, dev);
++=======
+ 	skb->protocol = eth_type_trans(skb, dev);
+ 
+ 	/* eth_type_trans() can set pkt_type.
+ 	 * call skb_scrub_packet() after it to clear pkt_type _after_ calling
+ 	 * eth_type_trans().
+ 	 */
+ 	skb_scrub_packet(skb, true);
+ 
++>>>>>>> 8b27f27797ca (skb: allow skb_scrub_packet() to be used by tunnels)
  	return netif_rx(skb);
  }
  EXPORT_SYMBOL_GPL(dev_forward_skb);
diff --cc net/ipv4/ip_tunnel.c
index 26bb30d12002,b0e74e17088f..000000000000
--- a/net/ipv4/ip_tunnel.c
+++ b/net/ipv4/ip_tunnel.c
@@@ -465,6 -460,10 +465,13 @@@ int ip_tunnel_rcv(struct ip_tunnel *tun
  	} else {
  		skb->dev = tunnel->dev;
  	}
++<<<<<<< HEAD
++=======
+ 
+ 	if (!net_eq(tunnel->net, dev_net(tunnel->dev)))
+ 		skb_scrub_packet(skb, true);
+ 
++>>>>>>> 8b27f27797ca (skb: allow skb_scrub_packet() to be used by tunnels)
  	gro_cells_receive(&tunnel->gro_cells, skb);
  	return 0;
  
@@@ -615,8 -614,8 +622,13 @@@ void ip_tunnel_xmit(struct sk_buff *skb
  		goto tx_error;
  	}
  
++<<<<<<< HEAD
 +	if (tunnel->net != dev_net(dev))
 +		skb_scrub_packet(skb);
++=======
+ 	if (!net_eq(tunnel->net, dev_net(dev)))
+ 		skb_scrub_packet(skb, true);
++>>>>>>> 8b27f27797ca (skb: allow skb_scrub_packet() to be used by tunnels)
  
  	if (tunnel->err_count > 0) {
  		if (time_before(jiffies,
diff --cc net/ipv6/sit.c
index aff21b3145f9,b2e44f478e14..000000000000
--- a/net/ipv6/sit.c
+++ b/net/ipv6/sit.c
@@@ -621,8 -621,8 +621,13 @@@ static int ipip6_rcv(struct sk_buff *sk
  		tstats->rx_packets++;
  		tstats->rx_bytes += skb->len;
  
++<<<<<<< HEAD
 +		if (tunnel->net != dev_net(tunnel->dev))
 +			skb_scrub_packet(skb);
++=======
+ 		if (!net_eq(tunnel->net, dev_net(tunnel->dev)))
+ 			skb_scrub_packet(skb, true);
++>>>>>>> 8b27f27797ca (skb: allow skb_scrub_packet() to be used by tunnels)
  		netif_rx(skb);
  
  		return 0;
@@@ -858,8 -860,8 +863,13 @@@ static netdev_tx_t ipip6_tunnel_xmit(st
  			tunnel->err_count = 0;
  	}
  
++<<<<<<< HEAD
 +	if (tunnel->net != dev_net(dev))
 +		skb_scrub_packet(skb);
++=======
+ 	if (!net_eq(tunnel->net, dev_net(dev)))
+ 		skb_scrub_packet(skb, true);
++>>>>>>> 8b27f27797ca (skb: allow skb_scrub_packet() to be used by tunnels)
  
  	/*
  	 * Okay, now see if we can stuff it in the buffer as-is.
* Unmerged path include/linux/skbuff.h
* Unmerged path net/core/dev.c
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index 25fb6ef7b10e..1d2e8efafda8 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -3605,17 +3605,22 @@ bool skb_try_coalesce(struct sk_buff *to, struct sk_buff *from,
 EXPORT_SYMBOL(skb_try_coalesce);
 
 /**
- * skb_scrub_packet - scrub an skb before sending it to another netns
+ * skb_scrub_packet - scrub an skb
  *
  * @skb: buffer to clean
- *
- * skb_scrub_packet can be used to clean an skb before injecting it in
- * another namespace. We have to clear all information in the skb that
- * could impact namespace isolation.
+ * @xnet: packet is crossing netns
+ *
+ * skb_scrub_packet can be used after encapsulating or decapsulting a packet
+ * into/from a tunnel. Some information have to be cleared during these
+ * operations.
+ * skb_scrub_packet can also be used to clean a skb before injecting it in
+ * another namespace (@xnet == true). We have to clear all information in the
+ * skb that could impact namespace isolation.
  */
-void skb_scrub_packet(struct sk_buff *skb)
+void skb_scrub_packet(struct sk_buff *skb, bool xnet)
 {
-	skb_orphan(skb);
+	if (xnet)
+		skb_orphan(skb);
 	skb->tstamp.tv64 = 0;
 	skb->pkt_type = PACKET_HOST;
 	skb->skb_iif = 0;
* Unmerged path net/ipv4/ip_tunnel.c
diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c
index 2f844ea3e0a1..4f42a0d50c16 100644
--- a/net/ipv6/ip6_tunnel.c
+++ b/net/ipv6/ip6_tunnel.c
@@ -829,7 +829,7 @@ static int ip6_tnl_rcv(struct sk_buff *skb, __u16 protocol,
 		tstats->rx_bytes += skb->len;
 
 		if (!net_eq(t->net, dev_net(t->dev)))
-			skb_scrub_packet(skb);
+			skb_scrub_packet(skb, true);
 
 		netif_rx(skb);
 
@@ -1001,7 +1001,7 @@ static int ip6_tnl_xmit2(struct sk_buff *skb,
 	}
 
 	if (!net_eq(t->net, dev_net(dev)))
-		skb_scrub_packet(skb);
+		skb_scrub_packet(skb, true);
 
 	/*
 	 * Okay, now see if we can stuff it in the buffer as-is.
* Unmerged path net/ipv6/sit.c
