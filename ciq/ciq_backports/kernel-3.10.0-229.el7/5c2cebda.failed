i40e: Fix ethtool coalesce settings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Carolyn Wyborny <carolyn.wyborny@intel.com>
commit 5c2cebda438b888147f6dfd6d1423432d837c0ea
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5c2cebda.failed

This patch fixes the i40e_set_coalesce function to allow 0 as a disable
value.  Also, added message to user about invalid value and provides valid
range.

Change-ID: I6c9ff11a9861f2045bd543745a3d132999ffbbd8
	Signed-off-by: Carolyn Wyborny <carolyn.wyborny@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 5c2cebda438b888147f6dfd6d1423432d837c0ea)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_ethtool.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index daf54e6aabf0,7da37581bc02..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@@ -1090,39 -1105,47 +1090,81 @@@ static int i40e_set_coalesce(struct net
  	if (ec->tx_max_coalesced_frames_irq || ec->rx_max_coalesced_frames_irq)
  		vsi->work_limit = ec->tx_max_coalesced_frames_irq;
  
++<<<<<<< HEAD
 +	switch (ec->rx_coalesce_usecs) {
 +	case 0:
 +		vsi->rx_itr_setting = 0;
 +		break;
 +	case 1:
 +		vsi->rx_itr_setting = (I40E_ITR_DYNAMIC |
 +				       ITR_REG_TO_USEC(I40E_ITR_RX_DEF));
 +		break;
 +	default:
 +		if ((ec->rx_coalesce_usecs < (I40E_MIN_ITR << 1)) ||
 +		    (ec->rx_coalesce_usecs > (I40E_MAX_ITR << 1)))
 +			return -EINVAL;
 +		vsi->rx_itr_setting = ec->rx_coalesce_usecs;
 +		break;
 +	}
 +
 +	switch (ec->tx_coalesce_usecs) {
 +	case 0:
 +		vsi->tx_itr_setting = 0;
 +		break;
 +	case 1:
 +		vsi->tx_itr_setting = (I40E_ITR_DYNAMIC |
 +				       ITR_REG_TO_USEC(I40E_ITR_TX_DEF));
 +		break;
 +	default:
 +		if ((ec->tx_coalesce_usecs < (I40E_MIN_ITR << 1)) ||
 +		    (ec->tx_coalesce_usecs > (I40E_MAX_ITR << 1)))
 +			return -EINVAL;
 +		vsi->tx_itr_setting = ec->tx_coalesce_usecs;
 +		break;
 +	}
- 
++=======
  	vector = vsi->base_vector;
+ 	if ((ec->rx_coalesce_usecs >= (I40E_MIN_ITR << 1)) &&
+ 	    (ec->rx_coalesce_usecs <= (I40E_MAX_ITR << 1))) {
+ 		vsi->rx_itr_setting = ec->rx_coalesce_usecs;
+ 	} else if (ec->rx_coalesce_usecs == 0) {
+ 		vsi->rx_itr_setting = ec->rx_coalesce_usecs;
+ 		i40e_irq_dynamic_disable(vsi, vector);
+ 		if (ec->use_adaptive_rx_coalesce)
+ 			netif_info(pf, drv, netdev,
+ 				   "Rx-secs=0, need to disable adaptive-Rx for a complete disable\n");
+ 	} else {
+ 		netif_info(pf, drv, netdev,
+ 			   "Invalid value, Rx-usecs range is 0, 8-8160\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if ((ec->tx_coalesce_usecs >= (I40E_MIN_ITR << 1)) &&
+ 	    (ec->tx_coalesce_usecs <= (I40E_MAX_ITR << 1))) {
+ 		vsi->tx_itr_setting = ec->tx_coalesce_usecs;
+ 	} else if (ec->tx_coalesce_usecs == 0) {
+ 		vsi->tx_itr_setting = ec->tx_coalesce_usecs;
+ 		i40e_irq_dynamic_disable(vsi, vector);
+ 		if (ec->use_adaptive_tx_coalesce)
+ 			netif_info(pf, drv, netdev,
+ 				   "Tx-secs=0, need to disable adaptive-Tx for a complete disable\n");
+ 	} else {
+ 		netif_info(pf, drv, netdev,
+ 			   "Invalid value, Tx-usecs range is 0, 8-8160\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (ec->use_adaptive_rx_coalesce)
+ 		vsi->rx_itr_setting |= I40E_ITR_DYNAMIC;
+ 	else
+ 		vsi->rx_itr_setting &= ~I40E_ITR_DYNAMIC;
+ 
+ 	if (ec->use_adaptive_tx_coalesce)
+ 		vsi->tx_itr_setting |= I40E_ITR_DYNAMIC;
+ 	else
+ 		vsi->tx_itr_setting &= ~I40E_ITR_DYNAMIC;
++>>>>>>> 5c2cebda438b (i40e: Fix ethtool coalesce settings)
+ 
  	for (i = 0; i < vsi->num_q_vectors; i++, vector++) {
  		q_vector = vsi->q_vectors[i];
  		q_vector->rx.itr = ITR_TO_REG(vsi->rx_itr_setting);
diff --git a/drivers/net/ethernet/intel/i40e/i40e.h b/drivers/net/ethernet/intel/i40e/i40e.h
index db1ac025983c..f5a82e908d56 100644
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -606,6 +606,7 @@ static inline void i40e_dbg_init(void) {}
 static inline void i40e_dbg_exit(void) {}
 #endif /* CONFIG_DEBUG_FS*/
 void i40e_irq_dynamic_enable(struct i40e_vsi *vsi, int vector);
+void i40e_irq_dynamic_disable(struct i40e_vsi *vsi, int vector);
 void i40e_irq_dynamic_disable_icr0(struct i40e_pf *pf);
 void i40e_irq_dynamic_enable_icr0(struct i40e_pf *pf);
 int i40e_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_ethtool.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index 858dc4634185..51d49e66f823 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -2694,6 +2694,22 @@ void i40e_irq_dynamic_enable(struct i40e_vsi *vsi, int vector)
 	/* skip the flush */
 }
 
+/**
+ * i40e_irq_dynamic_disable - Disable default interrupt generation settings
+ * @vsi: pointer to a vsi
+ * @vector: enable a particular Hw Interrupt vector
+ **/
+void i40e_irq_dynamic_disable(struct i40e_vsi *vsi, int vector)
+{
+	struct i40e_pf *pf = vsi->back;
+	struct i40e_hw *hw = &pf->hw;
+	u32 val;
+
+	val = I40E_ITR_NONE << I40E_PFINT_DYN_CTLN_ITR_INDX_SHIFT;
+	wr32(hw, I40E_PFINT_DYN_CTLN(vector - 1), val);
+	i40e_flush(hw);
+}
+
 /**
  * i40e_msix_clean_rings - MSIX mode Interrupt Handler
  * @irq: interrupt number
