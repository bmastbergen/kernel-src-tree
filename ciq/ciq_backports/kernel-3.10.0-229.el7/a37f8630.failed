driver core: Release device_hotplug_lock when store_mem_state returns EINVAL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [base] Release device_hotplug_lock when store_mem_state returns EINVAL (Myron Stowe) [1114228]
Rebuild_FUZZ: 90.65%
commit-author Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
commit a37f86305c80f441b8b99dae7c19d3f9d2effc15
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a37f8630.failed

When inserting a wrong value to /sys/devices/system/memory/memoryX/state file,
following messages are shown. And device_hotplug_lock is never released.

================================================
[ BUG: lock held when returning to user space! ]
3.12.0-rc4-debug+ #3 Tainted: G        W
------------------------------------------------
bash/6442 is leaving the kernel with locks still held!
1 lock held by bash/6442:
 #0:  (device_hotplug_lock){+.+.+.}, at: [<ffffffff8146cbb5>] lock_device_hotplug_sysfs+0x15/0x50

This issue was introdued by commit fa2be40 (drivers: base: use standard
device online/offline for state change).

This patch releases device_hotplug_lcok when store_mem_state returns EINVAL.

	Signed-off-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
	Reviewed-by: Toshi Kani <toshi.kani@hp.com>
CC: Seth Jennings <sjenning@linux.vnet.ibm.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit a37f86305c80f441b8b99dae7c19d3f9d2effc15)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/memory.c
diff --cc drivers/base/memory.c
index 80ca71e0ae64,bece691cb5d9..000000000000
--- a/drivers/base/memory.c
+++ b/drivers/base/memory.c
@@@ -374,26 -325,41 +374,62 @@@ store_mem_state(struct device *dev
  	if (ret)
  		return ret;
  
++<<<<<<< HEAD
 +	if (!strncmp(buf, "online_kernel", min_t(int, count, 13))) {
 +		offline = false;
 +		ret = memory_block_change_state(mem, MEM_ONLINE,
 +						MEM_OFFLINE, ONLINE_KERNEL);
 +	} else if (!strncmp(buf, "online_movable", min_t(int, count, 14))) {
 +		offline = false;
 +		ret = memory_block_change_state(mem, MEM_ONLINE,
 +						MEM_OFFLINE, ONLINE_MOVABLE);
 +	} else if (!strncmp(buf, "online", min_t(int, count, 6))) {
 +		offline = false;
 +		ret = memory_block_change_state(mem, MEM_ONLINE,
 +						MEM_OFFLINE, ONLINE_KEEP);
 +	} else if(!strncmp(buf, "offline", min_t(int, count, 7))) {
 +		offline = true;
 +		ret = memory_block_change_state(mem, MEM_OFFLINE,
 +						MEM_ONLINE, -1);
++=======
+ 	if (!strncmp(buf, "online_kernel", min_t(int, count, 13)))
+ 		online_type = ONLINE_KERNEL;
+ 	else if (!strncmp(buf, "online_movable", min_t(int, count, 14)))
+ 		online_type = ONLINE_MOVABLE;
+ 	else if (!strncmp(buf, "online", min_t(int, count, 6)))
+ 		online_type = ONLINE_KEEP;
+ 	else if (!strncmp(buf, "offline", min_t(int, count, 7)))
+ 		online_type = -1;
+ 	else {
+ 		ret = -EINVAL;
+ 		goto err;
+ 	}
+ 
+ 	switch (online_type) {
+ 	case ONLINE_KERNEL:
+ 	case ONLINE_MOVABLE:
+ 	case ONLINE_KEEP:
+ 		/*
+ 		 * mem->online_type is not protected so there can be a
+ 		 * race here.  However, when racing online, the first
+ 		 * will succeed and the second will just return as the
+ 		 * block will already be online.  The online type
+ 		 * could be either one, but that is expected.
+ 		 */
+ 		mem->online_type = online_type;
+ 		ret = device_online(&mem->dev);
+ 		break;
+ 	case -1:
+ 		ret = device_offline(&mem->dev);
+ 		break;
+ 	default:
+ 		ret = -EINVAL; /* should never happen */
++>>>>>>> a37f86305c80 (driver core: Release device_hotplug_lock when store_mem_state returns EINVAL)
  	}
 +	if (!ret)
 +		dev->offline = offline;
  
+ err:
  	unlock_device_hotplug();
  
  	if (ret)
* Unmerged path drivers/base/memory.c
