mei: wd: fix stop completion failure

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Tomas Winkler <tomas.winkler@intel.com>
commit 5877255dc57403f49b4961070b206b832c931201
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5877255d.failed

While running Documentation/watchdog/src/watchdog-simple.c
and quiting by Ctrl-C, fallowing error is displayed:
mei_me 0000:00:16.0: wd: stop failed to complete ret=-512.

The whatchdog core framework is not able to propagate
-ESYSRESTART or -EINTR. Also There is no much sense in
restarting the close system call so instead of using
wait_event_interruptible_timeout we can use wait_event_timeout
with reasonable 10 msecs timeout.

	Reported-by: Prarit Bhargava <prarit@redhat.com>
	Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 5877255dc57403f49b4961070b206b832c931201)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/misc/mei/wd.c
diff --cc drivers/misc/mei/wd.c
index 1f382682b829,e084adf27259..000000000000
--- a/drivers/misc/mei/wd.c
+++ b/drivers/misc/mei/wd.c
@@@ -162,19 -175,12 +164,25 @@@ int mei_wd_stop(struct mei_device *dev
  
  	ret = mei_cl_flow_ctrl_creds(&dev->wd_cl);
  	if (ret < 0)
- 		goto out;
+ 		goto err;
  
  	if (ret && mei_hbuf_acquire(dev)) {
++<<<<<<< HEAD
 +		ret = 0;
 +
 +		if (!mei_wd_send(dev)) {
 +			ret = mei_cl_flow_ctrl_reduce(&dev->wd_cl);
 +			if (ret)
 +				goto out;
 +		} else {
 +			dev_err(&dev->pdev->dev, "wd: send stop failed\n");
 +		}
 +
++=======
+ 		ret = mei_wd_send(dev);
+ 		if (ret)
+ 			goto err;
++>>>>>>> 5877255dc574 (mei: wd: fix stop completion failure)
  		dev->wd_pending = false;
  	} else {
  		dev->wd_pending = true;
@@@ -182,21 -188,21 +190,30 @@@
  
  	mutex_unlock(&dev->device_lock);
  
- 	ret = wait_event_interruptible_timeout(dev->wait_stop_wd,
- 					dev->wd_state == MEI_WD_IDLE,
- 					msecs_to_jiffies(MEI_WD_STOP_TIMEOUT));
+ 	ret = wait_event_timeout(dev->wait_stop_wd,
+ 				dev->wd_state == MEI_WD_IDLE,
+ 				msecs_to_jiffies(MEI_WD_STOP_TIMEOUT));
  	mutex_lock(&dev->device_lock);
++<<<<<<< HEAD
 +	if (dev->wd_state == MEI_WD_IDLE) {
 +		dev_dbg(&dev->pdev->dev, "wd: stop completed ret=%d.\n", ret);
 +		ret = 0;
 +	} else {
 +		if (!ret)
 +			ret = -ETIMEDOUT;
++=======
+ 	if (dev->wd_state != MEI_WD_IDLE) {
+ 		/* timeout */
+ 		ret = -ETIME;
++>>>>>>> 5877255dc574 (mei: wd: fix stop completion failure)
  		dev_warn(&dev->pdev->dev,
  			"wd: stop failed to complete ret=%d.\n", ret);
+ 		goto err;
  	}
- 
- out:
+ 	dev_dbg(&dev->pdev->dev, "wd: stop completed after %u msec\n",
+ 			MEI_WD_STOP_TIMEOUT - jiffies_to_msecs(ret));
+ 	return 0;
+ err:
  	return ret;
  }
  
diff --git a/drivers/misc/mei/interrupt.c b/drivers/misc/mei/interrupt.c
index e6151e2dac48..e13477950fd5 100644
--- a/drivers/misc/mei/interrupt.c
+++ b/drivers/misc/mei/interrupt.c
@@ -474,7 +474,7 @@ int mei_irq_write_handler(struct mei_device *dev, struct mei_cl_cb *cmpl_list)
 
 	if (dev->wd_state == MEI_WD_STOPPING) {
 		dev->wd_state = MEI_WD_IDLE;
-		wake_up_interruptible(&dev->wait_stop_wd);
+		wake_up(&dev->wait_stop_wd);
 	}
 
 	if (mei_cl_is_connected(&dev->wd_cl)) {
* Unmerged path drivers/misc/mei/wd.c
