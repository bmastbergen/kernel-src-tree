qlcnic: Enhance Tx timeout debug data collection.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [ethernet] qlcnic: Enhance Tx timeout debug data collection (Chad Dupuis) [1089352]
Rebuild_FUZZ: 98.97%
commit-author Harish Patil <harish.patil@qlogic.com>
commit 665d1eca03cb9c7a1fb7d74186459b75b4a6ba7c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/665d1eca.failed

- Collect a firmware dump on first Tx timeout if netif_msg_tx_err() is set
- Log Receive and Status ring info on Tx timeout, in addition to Tx ring info
- Log additional Tx ring info if netif_msg_tx_err() is set

	Signed-off-by: Harish Patil <harish.patil@qlogic.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 665d1eca03cb9c7a1fb7d74186459b75b4a6ba7c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index ccf682b59be0,f8de2ae01a5a..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@@ -2719,6 -2966,85 +2719,88 @@@ int qlcnic_check_temp(struct qlcnic_ada
  	return rv;
  }
  
++<<<<<<< HEAD
++=======
+ static inline void dump_tx_ring_desc(struct qlcnic_host_tx_ring *tx_ring)
+ {
+ 	int i;
+ 	struct cmd_desc_type0 *tx_desc_info;
+ 
+ 	for (i = 0; i < tx_ring->num_desc; i++) {
+ 		tx_desc_info = &tx_ring->desc_head[i];
+ 		pr_info("TX Desc: %d\n", i);
+ 		print_hex_dump(KERN_INFO, "TX: ", DUMP_PREFIX_OFFSET, 16, 1,
+ 			       &tx_ring->desc_head[i],
+ 			       sizeof(struct cmd_desc_type0), true);
+ 	}
+ }
+ 
+ static void qlcnic_dump_rings(struct qlcnic_adapter *adapter)
+ {
+ 	struct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;
+ 	struct net_device *netdev = adapter->netdev;
+ 	struct qlcnic_host_rds_ring *rds_ring;
+ 	struct qlcnic_host_sds_ring *sds_ring;
+ 	struct qlcnic_host_tx_ring *tx_ring;
+ 	int ring;
+ 
+ 	if (!netdev || !netif_running(netdev))
+ 		return;
+ 
+ 	for (ring = 0; ring < adapter->max_rds_rings; ring++) {
+ 		rds_ring = &recv_ctx->rds_rings[ring];
+ 		if (!rds_ring)
+ 			continue;
+ 		netdev_info(netdev,
+ 			    "rds_ring=%d crb_rcv_producer=%d producer=%u num_desc=%u\n",
+ 			     ring, readl(rds_ring->crb_rcv_producer),
+ 			     rds_ring->producer, rds_ring->num_desc);
+ 	}
+ 
+ 	for (ring = 0; ring < adapter->drv_sds_rings; ring++) {
+ 		sds_ring = &(recv_ctx->sds_rings[ring]);
+ 		if (!sds_ring)
+ 			continue;
+ 		netdev_info(netdev,
+ 			    "sds_ring=%d crb_sts_consumer=%d consumer=%u crb_intr_mask=%d num_desc=%u\n",
+ 			    ring, readl(sds_ring->crb_sts_consumer),
+ 			    sds_ring->consumer, readl(sds_ring->crb_intr_mask),
+ 			    sds_ring->num_desc);
+ 	}
+ 
+ 	for (ring = 0; ring < adapter->drv_tx_rings; ring++) {
+ 		tx_ring = &adapter->tx_ring[ring];
+ 		if (!tx_ring)
+ 			continue;
+ 		netdev_info(netdev, "Tx ring=%d Context Id=0x%x\n",
+ 			    ring, tx_ring->ctx_id);
+ 		netdev_info(netdev,
+ 			    "xmit_finished=%llu, xmit_called=%llu, xmit_on=%llu, xmit_off=%llu\n",
+ 			    tx_ring->tx_stats.xmit_finished,
+ 			    tx_ring->tx_stats.xmit_called,
+ 			    tx_ring->tx_stats.xmit_on,
+ 			    tx_ring->tx_stats.xmit_off);
+ 
+ 		if (tx_ring->crb_intr_mask)
+ 			netdev_info(netdev, "crb_intr_mask=%d\n",
+ 				    readl(tx_ring->crb_intr_mask));
+ 
+ 		netdev_info(netdev,
+ 			    "hw_producer=%d, sw_producer=%d sw_consumer=%d, hw_consumer=%d\n",
+ 			    readl(tx_ring->crb_cmd_producer),
+ 			    tx_ring->producer, tx_ring->sw_consumer,
+ 			    le32_to_cpu(*(tx_ring->hw_consumer)));
+ 
+ 		netdev_info(netdev, "Total desc=%d, Available desc=%d\n",
+ 			    tx_ring->num_desc, qlcnic_tx_avail(tx_ring));
+ 
+ 		if (netif_msg_tx_err(adapter->ahw))
+ 			dump_tx_ring_desc(tx_ring);
+ 	}
+ 
+ }
+ 
++>>>>>>> 665d1eca03cb (qlcnic: Enhance Tx timeout debug data collection.)
  static void qlcnic_tx_timeout(struct net_device *netdev)
  {
  	struct qlcnic_adapter *adapter = netdev_priv(netdev);
@@@ -2736,23 -3063,7 +2821,27 @@@
  			qlcnic_83xx_idc_request_reset(adapter,
  						      QLCNIC_FORCE_FW_DUMP_KEY);
  	} else {
++<<<<<<< HEAD
 +		netdev_info(netdev, "Tx timeout, reset adapter context.\n");
 +		for (ring = 0; ring < adapter->max_drv_tx_rings; ring++) {
 +			tx_ring = &adapter->tx_ring[ring];
 +			netdev_info(netdev, "Tx ring=%d\n", ring);
 +			netdev_info(netdev,
 +				    "crb_intr_mask=%d, producer=%d, sw_consumer=%d, hw_consumer=%d\n",
 +				    readl(tx_ring->crb_intr_mask),
 +				    readl(tx_ring->crb_cmd_producer),
 +				    tx_ring->sw_consumer,
 +				    le32_to_cpu(*(tx_ring->hw_consumer)));
 +			netdev_info(netdev,
 +				    "xmit_finished=%llu, xmit_called=%llu, xmit_on=%llu, xmit_off=%llu\n",
 +				    tx_ring->tx_stats.xmit_finished,
 +				    tx_ring->tx_stats.xmit_called,
 +				    tx_ring->tx_stats.xmit_on,
 +				    tx_ring->tx_stats.xmit_off);
 +		}
++=======
+ 		netdev_err(netdev, "Tx timeout, reset adapter context.\n");
++>>>>>>> 665d1eca03cb (qlcnic: Enhance Tx timeout debug data collection.)
  		adapter->ahw->reset_context = 1;
  	}
  }
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
