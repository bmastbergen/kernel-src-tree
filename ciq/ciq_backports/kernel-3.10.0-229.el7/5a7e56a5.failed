cpufreq: Initialize policy before making it available for others to use

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Initialize policy before making it available for others to use (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 93.23%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 5a7e56a5d29071bcccd947dee6e3b9f8e4eb3309
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5a7e56a5.failed

Policy must be fully initialized before it is being made available
for use by others. Otherwise cpufreq_cpu_get() would be able to grab
a half initialized policy structure that might not have affected_cpus
(for example) populated. Then, anybody accessing those fields will get
a wrong value and that will lead to unpredictable results.

In order to fix this, do all the necessary initialization before we
make the policy structure available via cpufreq_cpu_get(). That will
guarantee that any code accessing fields of the policy will get
correct data from them.

	Reported-by: Saravana Kannan <skannan@codeaurora.org>
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
[rjw: Changelog]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 5a7e56a5d29071bcccd947dee6e3b9f8e4eb3309)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index c8bc717e8458,d6622689d000..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -993,6 -1109,25 +993,28 @@@ static int cpufreq_add_dev(struct devic
  		goto err_set_policy_cpu;
  	}
  
++<<<<<<< HEAD
++=======
+ 	/* related cpus should atleast have policy->cpus */
+ 	cpumask_or(policy->related_cpus, policy->related_cpus, policy->cpus);
+ 
+ 	/*
+ 	 * affected cpus must always be the one, which are online. We aren't
+ 	 * managing offline cpus here.
+ 	 */
+ 	cpumask_and(policy->cpus, policy->cpus, cpu_online_mask);
+ 
+ 	if (!frozen) {
+ 		policy->user_policy.min = policy->min;
+ 		policy->user_policy.max = policy->max;
+ 	}
+ 
+ 	write_lock_irqsave(&cpufreq_driver_lock, flags);
+ 	for_each_cpu(j, policy->cpus)
+ 		per_cpu(cpufreq_cpu_data, j) = policy;
+ 	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
+ 
++>>>>>>> 5a7e56a5d290 (cpufreq: Initialize policy before making it available for others to use)
  	if (cpufreq_driver->get) {
  		policy->cur = cpufreq_driver->get(policy->cpu);
  		if (!policy->cur) {
@@@ -1041,18 -1176,6 +1063,21 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	/* related cpus should atleast have policy->cpus */
 +	cpumask_or(policy->related_cpus, policy->related_cpus, policy->cpus);
 +
 +	/*
 +	 * affected cpus must always be the one, which are online. We aren't
 +	 * managing offline cpus here.
 +	 */
 +	cpumask_and(policy->cpus, policy->cpus, cpu_online_mask);
 +
 +	policy->user_policy.min = policy->min;
 +	policy->user_policy.max = policy->max;
 +
++=======
++>>>>>>> 5a7e56a5d290 (cpufreq: Initialize policy before making it available for others to use)
  	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
  				     CPUFREQ_START, policy);
  
* Unmerged path drivers/cpufreq/cpufreq.c
