panic: Make panic_timeout configurable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Jason Baron <jbaron@akamai.com>
commit 5800dc3cff87c3a1548382298bb16e1fb4ec7e32
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5800dc3c.failed

The panic_timeout value can be set via the command line option
'panic=x', or via /proc/sys/kernel/panic, however that is not
sufficient when the panic occurs before we are able to set up
these values. Thus, add a CONFIG_PANIC_TIMEOUT so that we can
set the desired value from the .config.

The default panic_timeout value continues to be 0 - wait
forever. Also adds set_arch_panic_timeout(new_timeout,
arch_default_timeout), which is intended to be used by arches in
arch_setup(). The idea being that the new_timeout is only set if
the user hasn't changed from the arch_default_timeout.

	Signed-off-by: Jason Baron <jbaron@akamai.com>
	Cc: benh@kernel.crashing.org
	Cc: paulus@samba.org
	Cc: ralf@linux-mips.org
	Cc: mpe@ellerman.id.au
	Cc: felipe.contreras@gmail.com
	Cc: Linus Torvalds <torvalds@linux-foundation.org>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/1a1674daec27c534df409697025ac568ebcee91e.1385418410.git.jbaron@akamai.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 5800dc3cff87c3a1548382298bb16e1fb4ec7e32)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	lib/Kconfig.debug
diff --cc lib/Kconfig.debug
index 13b8c1c73e61,6982094a7e74..000000000000
--- a/lib/Kconfig.debug
+++ b/lib/Kconfig.debug
@@@ -502,6 -483,328 +502,331 @@@ config DEBUG_KMEMLEAK_DEFAULT_OF
  	  Say Y here to disable kmemleak by default. It can then be enabled
  	  on the command line via kmemleak=on.
  
++<<<<<<< HEAD
++=======
+ config DEBUG_STACK_USAGE
+ 	bool "Stack utilization instrumentation"
+ 	depends on DEBUG_KERNEL && !IA64 && !PARISC && !METAG
+ 	help
+ 	  Enables the display of the minimum amount of free stack which each
+ 	  task has ever had available in the sysrq-T and sysrq-P debug output.
+ 
+ 	  This option will slow down process creation somewhat.
+ 
+ config DEBUG_VM
+ 	bool "Debug VM"
+ 	depends on DEBUG_KERNEL
+ 	help
+ 	  Enable this to turn on extended checks in the virtual-memory system
+           that may impact performance.
+ 
+ 	  If unsure, say N.
+ 
+ config DEBUG_VM_RB
+ 	bool "Debug VM red-black trees"
+ 	depends on DEBUG_VM
+ 	help
+ 	  Enable this to turn on more extended checks in the virtual-memory
+ 	  system that may impact performance.
+ 
+ 	  If unsure, say N.
+ 
+ config DEBUG_VIRTUAL
+ 	bool "Debug VM translations"
+ 	depends on DEBUG_KERNEL && X86
+ 	help
+ 	  Enable some costly sanity checks in virtual to page code. This can
+ 	  catch mistakes with virt_to_page() and friends.
+ 
+ 	  If unsure, say N.
+ 
+ config DEBUG_NOMMU_REGIONS
+ 	bool "Debug the global anon/private NOMMU mapping region tree"
+ 	depends on DEBUG_KERNEL && !MMU
+ 	help
+ 	  This option causes the global tree of anonymous and private mapping
+ 	  regions to be regularly checked for invalid topology.
+ 
+ config DEBUG_MEMORY_INIT
+ 	bool "Debug memory initialisation" if EXPERT
+ 	default !EXPERT
+ 	help
+ 	  Enable this for additional checks during memory initialisation.
+ 	  The sanity checks verify aspects of the VM such as the memory model
+ 	  and other information provided by the architecture. Verbose
+ 	  information will be printed at KERN_DEBUG loglevel depending
+ 	  on the mminit_loglevel= command-line option.
+ 
+ 	  If unsure, say Y
+ 
+ config MEMORY_NOTIFIER_ERROR_INJECT
+ 	tristate "Memory hotplug notifier error injection module"
+ 	depends on MEMORY_HOTPLUG_SPARSE && NOTIFIER_ERROR_INJECTION
+ 	help
+ 	  This option provides the ability to inject artificial errors to
+ 	  memory hotplug notifier chain callbacks.  It is controlled through
+ 	  debugfs interface under /sys/kernel/debug/notifier-error-inject/memory
+ 
+ 	  If the notifier call chain should be failed with some events
+ 	  notified, write the error code to "actions/<notifier event>/error".
+ 
+ 	  Example: Inject memory hotplug offline error (-12 == -ENOMEM)
+ 
+ 	  # cd /sys/kernel/debug/notifier-error-inject/memory
+ 	  # echo -12 > actions/MEM_GOING_OFFLINE/error
+ 	  # echo offline > /sys/devices/system/memory/memoryXXX/state
+ 	  bash: echo: write error: Cannot allocate memory
+ 
+ 	  To compile this code as a module, choose M here: the module will
+ 	  be called memory-notifier-error-inject.
+ 
+ 	  If unsure, say N.
+ 
+ config DEBUG_PER_CPU_MAPS
+ 	bool "Debug access to per_cpu maps"
+ 	depends on DEBUG_KERNEL
+ 	depends on SMP
+ 	help
+ 	  Say Y to verify that the per_cpu map being accessed has
+ 	  been set up. This adds a fair amount of code to kernel memory
+ 	  and decreases performance.
+ 
+ 	  Say N if unsure.
+ 
+ config DEBUG_HIGHMEM
+ 	bool "Highmem debugging"
+ 	depends on DEBUG_KERNEL && HIGHMEM
+ 	help
+ 	  This options enables addition error checking for high memory systems.
+ 	  Disable for production systems.
+ 
+ config HAVE_DEBUG_STACKOVERFLOW
+ 	bool
+ 
+ config DEBUG_STACKOVERFLOW
+ 	bool "Check for stack overflows"
+ 	depends on DEBUG_KERNEL && HAVE_DEBUG_STACKOVERFLOW
+ 	---help---
+ 	  Say Y here if you want to check for overflows of kernel, IRQ
+ 	  and exception stacks (if your archicture uses them). This
+ 	  option will show detailed messages if free stack space drops
+ 	  below a certain limit.
+ 
+ 	  These kinds of bugs usually occur when call-chains in the
+ 	  kernel get too deep, especially when interrupts are
+ 	  involved.
+ 
+ 	  Use this in cases where you see apparently random memory
+ 	  corruption, especially if it appears in 'struct thread_info'
+ 
+ 	  If in doubt, say "N".
+ 
+ source "lib/Kconfig.kmemcheck"
+ 
+ endmenu # "Memory Debugging"
+ 
+ config DEBUG_SHIRQ
+ 	bool "Debug shared IRQ handlers"
+ 	depends on DEBUG_KERNEL
+ 	help
+ 	  Enable this to generate a spurious interrupt as soon as a shared
+ 	  interrupt handler is registered, and just before one is deregistered.
+ 	  Drivers ought to be able to handle interrupts coming in at those
+ 	  points; some don't and need to be caught.
+ 
+ menu "Debug Lockups and Hangs"
+ 
+ config LOCKUP_DETECTOR
+ 	bool "Detect Hard and Soft Lockups"
+ 	depends on DEBUG_KERNEL && !S390
+ 	help
+ 	  Say Y here to enable the kernel to act as a watchdog to detect
+ 	  hard and soft lockups.
+ 
+ 	  Softlockups are bugs that cause the kernel to loop in kernel
+ 	  mode for more than 20 seconds, without giving other tasks a
+ 	  chance to run.  The current stack trace is displayed upon
+ 	  detection and the system will stay locked up.
+ 
+ 	  Hardlockups are bugs that cause the CPU to loop in kernel mode
+ 	  for more than 10 seconds, without letting other interrupts have a
+ 	  chance to run.  The current stack trace is displayed upon detection
+ 	  and the system will stay locked up.
+ 
+ 	  The overhead should be minimal.  A periodic hrtimer runs to
+ 	  generate interrupts and kick the watchdog task every 4 seconds.
+ 	  An NMI is generated every 10 seconds or so to check for hardlockups.
+ 
+ 	  The frequency of hrtimer and NMI events and the soft and hard lockup
+ 	  thresholds can be controlled through the sysctl watchdog_thresh.
+ 
+ config HARDLOCKUP_DETECTOR
+ 	def_bool y
+ 	depends on LOCKUP_DETECTOR && !HAVE_NMI_WATCHDOG
+ 	depends on PERF_EVENTS && HAVE_PERF_EVENTS_NMI
+ 
+ config BOOTPARAM_HARDLOCKUP_PANIC
+ 	bool "Panic (Reboot) On Hard Lockups"
+ 	depends on HARDLOCKUP_DETECTOR
+ 	help
+ 	  Say Y here to enable the kernel to panic on "hard lockups",
+ 	  which are bugs that cause the kernel to loop in kernel
+ 	  mode with interrupts disabled for more than 10 seconds (configurable
+ 	  using the watchdog_thresh sysctl).
+ 
+ 	  Say N if unsure.
+ 
+ config BOOTPARAM_HARDLOCKUP_PANIC_VALUE
+ 	int
+ 	depends on HARDLOCKUP_DETECTOR
+ 	range 0 1
+ 	default 0 if !BOOTPARAM_HARDLOCKUP_PANIC
+ 	default 1 if BOOTPARAM_HARDLOCKUP_PANIC
+ 
+ config BOOTPARAM_SOFTLOCKUP_PANIC
+ 	bool "Panic (Reboot) On Soft Lockups"
+ 	depends on LOCKUP_DETECTOR
+ 	help
+ 	  Say Y here to enable the kernel to panic on "soft lockups",
+ 	  which are bugs that cause the kernel to loop in kernel
+ 	  mode for more than 20 seconds (configurable using the watchdog_thresh
+ 	  sysctl), without giving other tasks a chance to run.
+ 
+ 	  The panic can be used in combination with panic_timeout,
+ 	  to cause the system to reboot automatically after a
+ 	  lockup has been detected. This feature is useful for
+ 	  high-availability systems that have uptime guarantees and
+ 	  where a lockup must be resolved ASAP.
+ 
+ 	  Say N if unsure.
+ 
+ config BOOTPARAM_SOFTLOCKUP_PANIC_VALUE
+ 	int
+ 	depends on LOCKUP_DETECTOR
+ 	range 0 1
+ 	default 0 if !BOOTPARAM_SOFTLOCKUP_PANIC
+ 	default 1 if BOOTPARAM_SOFTLOCKUP_PANIC
+ 
+ config DETECT_HUNG_TASK
+ 	bool "Detect Hung Tasks"
+ 	depends on DEBUG_KERNEL
+ 	default LOCKUP_DETECTOR
+ 	help
+ 	  Say Y here to enable the kernel to detect "hung tasks",
+ 	  which are bugs that cause the task to be stuck in
+ 	  uninterruptible "D" state indefinitiley.
+ 
+ 	  When a hung task is detected, the kernel will print the
+ 	  current stack trace (which you should report), but the
+ 	  task will stay in uninterruptible state. If lockdep is
+ 	  enabled then all held locks will also be reported. This
+ 	  feature has negligible overhead.
+ 
+ config DEFAULT_HUNG_TASK_TIMEOUT
+ 	int "Default timeout for hung task detection (in seconds)"
+ 	depends on DETECT_HUNG_TASK
+ 	default 120
+ 	help
+ 	  This option controls the default timeout (in seconds) used
+ 	  to determine when a task has become non-responsive and should
+ 	  be considered hung.
+ 
+ 	  It can be adjusted at runtime via the kernel.hung_task_timeout_secs
+ 	  sysctl or by writing a value to
+ 	  /proc/sys/kernel/hung_task_timeout_secs.
+ 
+ 	  A timeout of 0 disables the check.  The default is two minutes.
+ 	  Keeping the default should be fine in most cases.
+ 
+ config BOOTPARAM_HUNG_TASK_PANIC
+ 	bool "Panic (Reboot) On Hung Tasks"
+ 	depends on DETECT_HUNG_TASK
+ 	help
+ 	  Say Y here to enable the kernel to panic on "hung tasks",
+ 	  which are bugs that cause the kernel to leave a task stuck
+ 	  in uninterruptible "D" state.
+ 
+ 	  The panic can be used in combination with panic_timeout,
+ 	  to cause the system to reboot automatically after a
+ 	  hung task has been detected. This feature is useful for
+ 	  high-availability systems that have uptime guarantees and
+ 	  where a hung tasks must be resolved ASAP.
+ 
+ 	  Say N if unsure.
+ 
+ config BOOTPARAM_HUNG_TASK_PANIC_VALUE
+ 	int
+ 	depends on DETECT_HUNG_TASK
+ 	range 0 1
+ 	default 0 if !BOOTPARAM_HUNG_TASK_PANIC
+ 	default 1 if BOOTPARAM_HUNG_TASK_PANIC
+ 
+ endmenu # "Debug lockups and hangs"
+ 
+ config PANIC_ON_OOPS
+ 	bool "Panic on Oops"
+ 	help
+ 	  Say Y here to enable the kernel to panic when it oopses. This
+ 	  has the same effect as setting oops=panic on the kernel command
+ 	  line.
+ 
+ 	  This feature is useful to ensure that the kernel does not do
+ 	  anything erroneous after an oops which could result in data
+ 	  corruption or other issues.
+ 
+ 	  Say N if unsure.
+ 
+ config PANIC_ON_OOPS_VALUE
+ 	int
+ 	range 0 1
+ 	default 0 if !PANIC_ON_OOPS
+ 	default 1 if PANIC_ON_OOPS
+ 
+ config PANIC_TIMEOUT
+ 	int "panic timeout"
+ 	default 0
+ 	help
+ 	  Set the timeout value (in seconds) until a reboot occurs when the
+ 	  the kernel panics. If n = 0, then we wait forever. A timeout
+ 	  value n > 0 will wait n seconds before rebooting, while a timeout
+ 	  value n < 0 will reboot immediately.
+ 
+ config SCHED_DEBUG
+ 	bool "Collect scheduler debugging info"
+ 	depends on DEBUG_KERNEL && PROC_FS
+ 	default y
+ 	help
+ 	  If you say Y here, the /proc/sched_debug file will be provided
+ 	  that can help debug the scheduler. The runtime overhead of this
+ 	  option is minimal.
+ 
+ config SCHEDSTATS
+ 	bool "Collect scheduler statistics"
+ 	depends on DEBUG_KERNEL && PROC_FS
+ 	help
+ 	  If you say Y here, additional code will be inserted into the
+ 	  scheduler and related routines to collect statistics about
+ 	  scheduler behavior and provide them in /proc/schedstat.  These
+ 	  stats may be useful for both tuning and debugging the scheduler
+ 	  If you aren't debugging the scheduler or trying to tune a specific
+ 	  application, you can say N to avoid the very slight overhead
+ 	  this adds.
+ 
+ config TIMER_STATS
+ 	bool "Collect kernel timers statistics"
+ 	depends on DEBUG_KERNEL && PROC_FS
+ 	help
+ 	  If you say Y here, additional code will be inserted into the
+ 	  timer routines to collect statistics about kernel timers being
+ 	  reprogrammed. The statistics can be read from /proc/timer_stats.
+ 	  The statistics collection is started by writing 1 to /proc/timer_stats,
+ 	  writing 0 stops it. This feature is useful to collect information
+ 	  about timer usage patterns in kernel and userspace. This feature
+ 	  is lightweight if enabled in the kernel config but not activated
+ 	  (it defaults to deactivated on bootup and will only be activated
+ 	  if some application like powertop activates it explicitly).
+ 
++>>>>>>> 5800dc3cff87 (panic: Make panic_timeout configurable)
  config DEBUG_PREEMPT
  	bool "Debug preemptible kernel"
  	depends on DEBUG_KERNEL && PREEMPT && TRACE_IRQFLAGS_SUPPORT
diff --git a/include/linux/kernel.h b/include/linux/kernel.h
index 8f8582c55584..7cc33aeb351c 100644
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@ -393,6 +393,15 @@ extern int panic_on_oops;
 extern int panic_on_unrecovered_nmi;
 extern int panic_on_io_nmi;
 extern int sysctl_panic_on_stackoverflow;
+/*
+ * Only to be used by arch init code. If the user over-wrote the default
+ * CONFIG_PANIC_TIMEOUT, honor it.
+ */
+static inline void set_arch_panic_timeout(int timeout, int arch_default_timeout)
+{
+	if (panic_timeout == arch_default_timeout)
+		panic_timeout = timeout;
+}
 extern const char *print_tainted(void);
 enum lockdep_ok {
 	LOCKDEP_STILL_OK,
diff --git a/kernel/panic.c b/kernel/panic.c
index 58520a541891..f4058fc38642 100644
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -32,7 +32,7 @@ static int pause_on_oops;
 static int pause_on_oops_flag;
 static DEFINE_SPINLOCK(pause_on_oops_lock);
 
-int panic_timeout;
+int panic_timeout = CONFIG_PANIC_TIMEOUT;
 EXPORT_SYMBOL_GPL(panic_timeout);
 
 ATOMIC_NOTIFIER_HEAD(panic_notifier_list);
* Unmerged path lib/Kconfig.debug
