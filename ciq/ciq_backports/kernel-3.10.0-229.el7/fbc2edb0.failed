vmstat: use this_cpu() to avoid irqon/off sequence in refresh_cpu_vm_stats

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [mm] Revert: vmstat: use this_cpu() to avoid irqon/off sequence in refresh_cpu_vm_stats (Larry Woodman) [1179654]
Rebuild_FUZZ: 94.87%
commit-author Christoph Lameter <cl@linux.com>
commit fbc2edb05354480a88aa39db8a6acb5782fa1a1b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/fbc2edb0.failed

Disabling interrupts repeatedly can be avoided in the inner loop if we use
a this_cpu operation.

	Signed-off-by: Christoph Lameter <cl@linux.com>
	Cc: KOSAKI Motohiro <kosaki.motohiro@jp.fujitsu.com>
CC: Tejun Heo <tj@kernel.org>
	Cc: Joonsoo Kim <js1304@gmail.com>
	Cc: Alexey Dobriyan <adobriyan@gmail.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit fbc2edb05354480a88aa39db8a6acb5782fa1a1b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/vmstat.c
diff --cc mm/vmstat.c
index 79736a1e5a9a,d57a09143bf9..000000000000
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@@ -432,7 -437,7 +432,11 @@@ EXPORT_SYMBOL(dec_zone_page_state)
   * with the global counters. These could cause remote node cache line
   * bouncing and will have to be only done when necessary.
   */
++<<<<<<< HEAD
 +void refresh_cpu_vm_stats(int cpu)
++=======
+ static void refresh_cpu_vm_stats(void)
++>>>>>>> fbc2edb05354 (vmstat: use this_cpu() to avoid irqon/off sequence in refresh_cpu_vm_stats)
  {
  	struct zone *zone;
  	int i;
@@@ -479,18 -481,45 +480,18 @@@
  			continue;
  		}
  
- 		p->expire--;
- 		if (p->expire)
+ 
+ 		if (__this_cpu_dec_return(p->expire))
  			continue;
  
- 		if (p->pcp.count)
- 			drain_zone_pages(zone, &p->pcp);
+ 		if (__this_cpu_read(p->pcp.count))
+ 			drain_zone_pages(zone, __this_cpu_ptr(&p->pcp));
  #endif
  	}
 -	fold_diff(global_diff);
 -}
  
 -/*
 - * Fold the data for an offline cpu into the global array.
 - * There cannot be any access by the offline cpu and therefore
 - * synchronization is simplified.
 - */
 -void cpu_vm_stats_fold(int cpu)
 -{
 -	struct zone *zone;
 -	int i;
 -	int global_diff[NR_VM_ZONE_STAT_ITEMS] = { 0, };
 -
 -	for_each_populated_zone(zone) {
 -		struct per_cpu_pageset *p;
 -
 -		p = per_cpu_ptr(zone->pageset, cpu);
 -
 -		for (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)
 -			if (p->vm_stat_diff[i]) {
 -				int v;
 -
 -				v = p->vm_stat_diff[i];
 -				p->vm_stat_diff[i] = 0;
 -				atomic_long_add(v, &zone->vm_stat[i]);
 -				global_diff[i] += v;
 -			}
 -	}
 -
 -	fold_diff(global_diff);
 +	for (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)
 +		if (global_diff[i])
 +			atomic_long_add(global_diff[i], &vm_stat[i]);
  }
  
  /*
* Unmerged path mm/vmstat.c
