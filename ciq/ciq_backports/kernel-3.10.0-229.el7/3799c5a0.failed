ACPI / hotplug / PCI: Rename register_slot() to acpiphp_add_context()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Rename register_slot() to acpiphp_add_context() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 93.02%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 3799c5a032aefb258e2a19dfdb1e3780b78ee3ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3799c5a0.failed

The name of register_slot() doesn't really reflect what the function
is does, so rename it to acpiphp_add_context() and add a proper
kerneldoc comment to it.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 3799c5a032aefb258e2a19dfdb1e3780b78ee3ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,903af4d4a383..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -189,27 -250,34 +189,39 @@@ static void acpiphp_dock_init(void *dat
  
  static void acpiphp_dock_release(void *data)
  {
 -	struct acpiphp_context *context = data;
 +	struct acpiphp_func *func = data;
  
 -	put_bridge(context->func.parent);
 +	put_bridge(func->slot->bridge);
  }
  
++<<<<<<< HEAD
 +/* callback routine to register each ACPI PCI slot object */
 +static acpi_status
 +register_slot(acpi_handle handle, u32 lvl, void *context, void **rv)
++=======
+ /**
+  * acpiphp_add_context - Add ACPIPHP context to an ACPI device object.
+  * @handle: ACPI handle of the object to add a context to.
+  * @lvl: Not used.
+  * @data: The object's parent ACPIPHP bridge.
+  * @rv: Not used.
+  */
+ static acpi_status acpiphp_add_context(acpi_handle handle, u32 lvl, void *data,
+ 				       void **rv)
++>>>>>>> 3799c5a032ae (ACPI / hotplug / PCI: Rename register_slot() to acpiphp_add_context())
  {
 -	struct acpiphp_bridge *bridge = data;
 -	struct acpiphp_context *context;
 -	struct acpi_device *adev;
 +	struct acpiphp_bridge *bridge = (struct acpiphp_bridge *)context;
  	struct acpiphp_slot *slot;
  	struct acpiphp_func *newfunc;
 +	acpi_handle tmp;
  	acpi_status status = AE_OK;
 -	unsigned long long adr;
 -	int device, function;
 +	unsigned long long adr, sun;
 +	int device, function, retval, found = 0;
  	struct pci_bus *pbus = bridge->pci_bus;
 -	struct pci_dev *pdev = bridge->pci_dev;
 +	struct pci_dev *pdev;
  	u32 val;
  
 -	if (pdev && device_is_managed_by_native_pciehp(pdev))
 +	if (!acpi_pci_check_ejectable(pbus, handle) && !is_dock_device(handle))
  		return AE_OK;
  
  	status = acpi_evaluate_integer(handle, "_ADR", NULL, &adr);
@@@ -1202,15 -911,44 +1214,31 @@@ void acpiphp_enumerate_slots(struct pci
  	 */
  	get_device(&bus->dev);
  
 -	if (!pci_is_root_bus(bridge->pci_bus)) {
 -		struct acpiphp_context *context;
 -
 -		/*
 -		 * This bridge should have been registered as a hotplug function
 -		 * under its parent, so the context should be there, unless the
 -		 * parent is going to be handled by pciehp, in which case this
 -		 * bridge is not interesting to us either.
 -		 */
 -		acpi_lock_hp_context();
 -		context = acpiphp_get_context(adev);
 -		if (!context) {
 -			acpi_unlock_hp_context();
 -			put_device(&bus->dev);
 -			pci_dev_put(bridge->pci_dev);
 -			kfree(bridge);
 -			return;
 -		}
 -		bridge->context = context;
 -		context->bridge = bridge;
 -		/* Get a reference to the parent bridge. */
 -		get_bridge(context->func.parent);
 -		acpi_unlock_hp_context();
 +	if (!pci_is_root_bus(bridge->pci_bus) &&
 +	    ACPI_SUCCESS(acpi_get_handle(bridge->handle,
 +					"_EJ0", &dummy_handle))) {
 +		pr_debug("found ejectable p2p bridge\n");
 +		bridge->flags |= BRIDGE_HAS_EJ0;
 +		bridge->func = acpiphp_bridge_handle_to_function(handle);
  	}
  
++<<<<<<< HEAD
 +	init_bridge_misc(bridge);
++=======
+ 	/* Must be added to the list prior to calling acpiphp_add_context(). */
+ 	mutex_lock(&bridge_mutex);
+ 	list_add(&bridge->list, &bridge_list);
+ 	mutex_unlock(&bridge_mutex);
+ 
+ 	/* register all slot objects under this bridge */
+ 	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
+ 				     acpiphp_add_context, NULL, bridge, NULL);
+ 	if (ACPI_FAILURE(status)) {
+ 		acpi_handle_err(handle, "failed to register slots\n");
+ 		cleanup_bridge(bridge);
+ 		put_bridge(bridge);
+ 	}
++>>>>>>> 3799c5a032ae (ACPI / hotplug / PCI: Rename register_slot() to acpiphp_add_context())
  }
  
  /**
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
