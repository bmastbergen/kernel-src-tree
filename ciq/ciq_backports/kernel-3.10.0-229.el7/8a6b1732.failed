uprobes: Kill UPROBE_SKIP_SSTEP and can_skip_sstep()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Oleg Nesterov <oleg@redhat.com>
commit 8a6b173287bb94b3ef8360119020e856afb1c934
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/8a6b1732.failed

UPROBE_COPY_INSN, UPROBE_SKIP_SSTEP, and uprobe->flags must die. This
patch kills UPROBE_SKIP_SSTEP. I never understood why it was added;
not only it doesn't help, it harms.

It can only help to avoid arch_uprobe_skip_sstep() if it was already
called before and failed. But this is ugly, if we want to know whether
we can emulate this instruction or not we should do this analysis in
arch_uprobe_analyze_insn(), not when we hit this probe for the first
time.

And in fact this logic is simply wrong. arch_uprobe_skip_sstep() can
fail or not depending on the task/register state, if this insn can be
emulated but, say, put_user() fails we need to xol it this time, but
this doesn't mean we shouldn't try to emulate it when this or another
thread hits this bp next time.

And this is the actual reason for this change. We need to emulate the
"call" insn, but push(return-address) can obviously fail.

Per-arch notes:

	x86: __skip_sstep() can only emulate "rep;nop". With this
	     change it will be called every time and most probably
	     for no reason.

	     This will be fixed by the next changes. We need to
	     change this suboptimal code anyway.

	arm: Should not be affected. It has its own "bool simulate"
	     flag checked in arch_uprobe_skip_sstep().

	ppc: Looks like, it can emulate almost everything. Does it
	     actually need to record the fact that emulate_step()
	     failed? Hopefully not. But if yes, it can add the ppc-
	     specific flag into arch_uprobe.

TODO: rename arch_uprobe_skip_sstep() to arch_uprobe_emulate_insn(),

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Reviewed-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Reviewed-by: David A. Long <dave.long@linaro.org>
	Reviewed-by: Jim Keniston <jkenisto@us.ibm.com>
	Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
(cherry picked from commit 8a6b173287bb94b3ef8360119020e856afb1c934)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/events/uprobes.c
diff --cc kernel/events/uprobes.c
index b77e5413ed2c,ea2a7c0728bb..000000000000
--- a/kernel/events/uprobes.c
+++ b/kernel/events/uprobes.c
@@@ -1827,8 -1840,16 +1808,13 @@@ static void handle_swbp(struct pt_regs 
  	if (unlikely(!test_bit(UPROBE_COPY_INSN, &uprobe->flags)))
  		goto out;
  
 -	/* Tracing handlers use ->utask to communicate with fetch methods */
 -	if (!get_utask())
 -		goto out;
 -
 -	if (arch_uprobe_ignore(&uprobe->arch, regs))
 -		goto out;
 -
  	handler_chain(uprobe, regs);
++<<<<<<< HEAD
 +	if (can_skip_sstep(uprobe, regs))
++=======
+ 
+ 	if (arch_uprobe_skip_sstep(&uprobe->arch, regs))
++>>>>>>> 8a6b173287bb (uprobes: Kill UPROBE_SKIP_SSTEP and can_skip_sstep())
  		goto out;
  
  	if (!pre_ssout(uprobe, regs, bp_vaddr))
* Unmerged path kernel/events/uprobes.c
