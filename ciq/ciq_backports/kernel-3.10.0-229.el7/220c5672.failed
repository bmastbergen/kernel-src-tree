KVM: nVMX: Do not inject NMI vmexits when L2 has a pending interrupt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/nvmx: Do not inject NMI vmexits when L2 has a pending interrupt (Paolo Bonzini) [1116936]
Rebuild_FUZZ: 97.78%
commit-author Jan Kiszka <jan.kiszka@siemens.com>
commit 220c56729766444f3dd823f740a147ca6d82c4c6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/220c5672.failed

According to SDM 27.2.3, IDT vectoring information will not be valid on
vmexits caused by external NMIs. So we have to avoid creating such
scenarios by delaying EXIT_REASON_EXCEPTION_NMI injection as long as we
have a pending interrupt because that one would be migrated to L1's IDT
vectoring info on nested exit.

	Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 220c56729766444f3dd823f740a147ca6d82c4c6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index 827c1e271e94,2c9d21e2d033..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -8045,6 -8163,58 +8045,61 @@@ static void vmcs12_save_pending_event(s
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static int vmx_check_nested_events(struct kvm_vcpu *vcpu, bool external_intr)
+ {
+ 	struct vcpu_vmx *vmx = to_vmx(vcpu);
+ 
+ 	if (nested_cpu_has_preemption_timer(get_vmcs12(vcpu)) &&
+ 	    vmx->nested.preemption_timer_expired) {
+ 		if (vmx->nested.nested_run_pending)
+ 			return -EBUSY;
+ 		nested_vmx_vmexit(vcpu, EXIT_REASON_PREEMPTION_TIMER, 0, 0);
+ 		return 0;
+ 	}
+ 
+ 	if (vcpu->arch.nmi_pending && nested_exit_on_nmi(vcpu)) {
+ 		if (vmx->nested.nested_run_pending ||
+ 		    vcpu->arch.interrupt.pending)
+ 			return -EBUSY;
+ 		nested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,
+ 				  NMI_VECTOR | INTR_TYPE_NMI_INTR |
+ 				  INTR_INFO_VALID_MASK, 0);
+ 		/*
+ 		 * The NMI-triggered VM exit counts as injection:
+ 		 * clear this one and block further NMIs.
+ 		 */
+ 		vcpu->arch.nmi_pending = 0;
+ 		vmx_set_nmi_mask(vcpu, true);
+ 		return 0;
+ 	}
+ 
+ 	if ((kvm_cpu_has_interrupt(vcpu) || external_intr) &&
+ 	    nested_exit_on_intr(vcpu)) {
+ 		if (vmx->nested.nested_run_pending)
+ 			return -EBUSY;
+ 		nested_vmx_vmexit(vcpu, EXIT_REASON_EXTERNAL_INTERRUPT, 0, 0);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static u32 vmx_get_preemption_timer_value(struct kvm_vcpu *vcpu)
+ {
+ 	ktime_t remaining =
+ 		hrtimer_get_remaining(&to_vmx(vcpu)->nested.preemption_timer);
+ 	u64 value;
+ 
+ 	if (ktime_to_ns(remaining) <= 0)
+ 		return 0;
+ 
+ 	value = ktime_to_ns(remaining) * vcpu->arch.virtual_tsc_khz;
+ 	do_div(value, 1000000);
+ 	return value >> VMX_MISC_EMULATED_PREEMPTION_TIMER_RATE;
+ }
+ 
++>>>>>>> 220c56729766 (KVM: nVMX: Do not inject NMI vmexits when L2 has a pending interrupt)
  /*
   * prepare_vmcs12 is part of what we need to do when the nested L2 guest exits
   * and we want to prepare to run its L1 parent. L1 keeps a vmcs for L2 (vmcs12),
* Unmerged path arch/x86/kvm/vmx.c
