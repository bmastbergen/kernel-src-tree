ALSA: hda - Remove obsoleted snd_hda_check_board_config() & co

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [alsa] hda: Remove obsoleted snd_hda_check_board_config() & co (Jaroslav Kysela) [1112200]
Rebuild_FUZZ: 92.31%
commit-author Takashi Iwai <tiwai@suse.de>
commit e9bd0224c130617d7d6037d3a405571c33b1e097
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e9bd0224.failed

The helper functions snd_hda_check_board_config() and
snd_hda_check_board_codec_sid_config() are no longer used since the
transition to the generic parser and all quirks have been replaced
with fixups.  Let's kill these dead codes.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit e9bd0224c130617d7d6037d3a405571c33b1e097)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_codec.c
diff --cc sound/pci/hda/hda_codec.c
index d0422f97ef10,0aa2e1ed1dbc..000000000000
--- a/sound/pci/hda/hda_codec.c
+++ b/sound/pci/hda/hda_codec.c
@@@ -4794,126 -4814,9 +4794,129 @@@ int snd_hda_build_pcms(struct hda_bus *
  	}
  	return 0;
  }
 -EXPORT_SYMBOL_GPL(snd_hda_build_pcms);
 +EXPORT_SYMBOL_HDA(snd_hda_build_pcms);
 +
 +/**
++<<<<<<< HEAD
 + * snd_hda_check_board_config - compare the current codec with the config table
 + * @codec: the HDA codec
 + * @num_configs: number of config enums
 + * @models: array of model name strings
 + * @tbl: configuration table, terminated by null entries
 + *
 + * Compares the modelname or PCI subsystem id of the current codec with the
 + * given configuration table.  If a matching entry is found, returns its
 + * config value (supposed to be 0 or positive).
 + *
 + * If no entries are matching, the function returns a negative value.
 + */
 +int snd_hda_check_board_config(struct hda_codec *codec,
 +			       int num_configs, const char * const *models,
 +			       const struct snd_pci_quirk *tbl)
 +{
 +	if (codec->modelname && models) {
 +		int i;
 +		for (i = 0; i < num_configs; i++) {
 +			if (models[i] &&
 +			    !strcmp(codec->modelname, models[i])) {
 +				snd_printd(KERN_INFO "hda_codec: model '%s' is "
 +					   "selected\n", models[i]);
 +				return i;
 +			}
 +		}
 +	}
 +
 +	if (!codec->bus->pci || !tbl)
 +		return -1;
 +
 +	tbl = snd_pci_quirk_lookup(codec->bus->pci, tbl);
 +	if (!tbl)
 +		return -1;
 +	if (tbl->value >= 0 && tbl->value < num_configs) {
 +#ifdef CONFIG_SND_DEBUG_VERBOSE
 +		char tmp[10];
 +		const char *model = NULL;
 +		if (models)
 +			model = models[tbl->value];
 +		if (!model) {
 +			sprintf(tmp, "#%d", tbl->value);
 +			model = tmp;
 +		}
 +		snd_printdd(KERN_INFO "hda_codec: model '%s' is selected "
 +			    "for config %x:%x (%s)\n",
 +			    model, tbl->subvendor, tbl->subdevice,
 +			    (tbl->name ? tbl->name : "Unknown device"));
 +#endif
 +		return tbl->value;
 +	}
 +	return -1;
 +}
 +EXPORT_SYMBOL_HDA(snd_hda_check_board_config);
 +
 +/**
 + * snd_hda_check_board_codec_sid_config - compare the current codec
 +					subsystem ID with the
 +					config table
 +
 +	   This is important for Gateway notebooks with SB450 HDA Audio
 +	   where the vendor ID of the PCI device is:
 +		ATI Technologies Inc SB450 HDA Audio [1002:437b]
 +	   and the vendor/subvendor are found only at the codec.
 +
 + * @codec: the HDA codec
 + * @num_configs: number of config enums
 + * @models: array of model name strings
 + * @tbl: configuration table, terminated by null entries
 + *
 + * Compares the modelname or PCI subsystem id of the current codec with the
 + * given configuration table.  If a matching entry is found, returns its
 + * config value (supposed to be 0 or positive).
 + *
 + * If no entries are matching, the function returns a negative value.
 + */
 +int snd_hda_check_board_codec_sid_config(struct hda_codec *codec,
 +			       int num_configs, const char * const *models,
 +			       const struct snd_pci_quirk *tbl)
 +{
 +	const struct snd_pci_quirk *q;
 +
 +	/* Search for codec ID */
 +	for (q = tbl; q->subvendor; q++) {
 +		unsigned int mask = 0xffff0000 | q->subdevice_mask;
 +		unsigned int id = (q->subdevice | (q->subvendor << 16)) & mask;
 +		if ((codec->subsystem_id & mask) == id)
 +			break;
 +	}
 +
 +	if (!q->subvendor)
 +		return -1;
 +
 +	tbl = q;
 +
 +	if (tbl->value >= 0 && tbl->value < num_configs) {
 +#ifdef CONFIG_SND_DEBUG_VERBOSE
 +		char tmp[10];
 +		const char *model = NULL;
 +		if (models)
 +			model = models[tbl->value];
 +		if (!model) {
 +			sprintf(tmp, "#%d", tbl->value);
 +			model = tmp;
 +		}
 +		snd_printdd(KERN_INFO "hda_codec: model '%s' is selected "
 +			    "for config %x:%x (%s)\n",
 +			    model, tbl->subvendor, tbl->subdevice,
 +			    (tbl->name ? tbl->name : "Unknown device"));
 +#endif
 +		return tbl->value;
 +	}
 +	return -1;
 +}
 +EXPORT_SYMBOL_HDA(snd_hda_check_board_codec_sid_config);
  
  /**
++=======
++>>>>>>> e9bd0224c130 (ALSA: hda - Remove obsoleted snd_hda_check_board_config() & co)
   * snd_hda_add_new_ctls - create controls from the array
   * @codec: the HDA codec
   * @knew: the array of struct snd_kcontrol_new
* Unmerged path sound/pci/hda/hda_codec.c
diff --git a/sound/pci/hda/hda_local.h b/sound/pci/hda/hda_local.h
index d5900d4376f2..bcabb8bfe5fb 100644
--- a/sound/pci/hda/hda_local.h
+++ b/sound/pci/hda/hda_local.h
@@ -370,12 +370,6 @@ void snd_print_pcm_bits(int pcm, char *buf, int buflen);
 /*
  * Misc
  */
-int snd_hda_check_board_config(struct hda_codec *codec, int num_configs,
-			       const char * const *modelnames,
-			       const struct snd_pci_quirk *pci_list);
-int snd_hda_check_board_codec_sid_config(struct hda_codec *codec,
-                               int num_configs, const char * const *models,
-                               const struct snd_pci_quirk *tbl);
 int snd_hda_add_new_ctls(struct hda_codec *codec,
 			 const struct snd_kcontrol_new *knew);
 
