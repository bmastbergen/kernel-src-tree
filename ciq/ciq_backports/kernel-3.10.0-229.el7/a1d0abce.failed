ACPI / hotplug / PCI: Redefine enable_device() and disable_device()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Redefine enable_device() and disable_device() (Myron Stowe) [1114228]
Rebuild_FUZZ: 92.80%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit a1d0abcea845730c4ff2f47897e28c2f11c79d4f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a1d0abce.failed

Notice that functions enable_device() and disable_device() cannot
fail and their return values are ignored in the majority of places,
so redefine them as void and use the opportunity to change their
names to enable_slot() and disable_slot(), respectively, which much
better reflects what they do.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit a1d0abcea845730c4ff2f47897e28c2f11c79d4f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index d210006fa4ad,18c9e54990ee..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -676,26 -538,18 +676,26 @@@ static void check_hotplug_bridge(struc
   * This function should be called per *physical slot*,
   * not per each slot object in ACPI namespace.
   */
- static int __ref enable_device(struct acpiphp_slot *slot)
+ static void __ref enable_slot(struct acpiphp_slot *slot)
  {
  	struct pci_dev *dev;
 -	struct pci_bus *bus = slot->bus;
 +	struct pci_bus *bus = slot->bridge->pci_bus;
  	struct acpiphp_func *func;
 -	int max, pass;
 +	int num, max, pass;
  	LIST_HEAD(add_list);
  
 +	if (slot->flags & SLOT_ENABLED)
 +		goto err_exit;
 +
  	list_for_each_entry(func, &slot->funcs, sibling)
 -		acpiphp_bus_add(func_to_handle(func));
 +		acpiphp_bus_add(func);
  
 -	pci_scan_slot(bus, PCI_DEVFN(slot->device, 0));
 +	num = pci_scan_slot(bus, PCI_DEVFN(slot->device, 0));
 +	if (num == 0) {
 +		/* Maybe only part of funcs are added. */
 +		pr_debug("No new device found\n");
 +		goto err_exit;
 +	}
  
  	max = acpiphp_max_busnr(bus);
  	for (pass = 0; pass < 2; pass++) {
@@@ -739,10 -595,6 +740,13 @@@
  			continue;
  		}
  	}
++<<<<<<< HEAD
 +
 +
 + err_exit:
 +	return 0;
++=======
++>>>>>>> a1d0abcea845 (ACPI / hotplug / PCI: Redefine enable_device() and disable_device())
  }
  
  /* return first device in slot, acquiring a reference on it */
@@@ -783,13 -635,10 +787,11 @@@ static void disable_slot(struct acpiphp
  		pci_dev_put(pdev);
  	}
  
 -	list_for_each_entry(func, &slot->funcs, sibling)
 -		acpiphp_bus_trim(func_to_handle(func));
 +	list_for_each_entry(func, &slot->funcs, sibling) {
 +		acpiphp_bus_trim(func->handle);
 +	}
  
  	slot->flags &= (~SLOT_ENABLED);
- 
- 	return 0;
  }
  
  
@@@ -870,43 -730,30 +872,62 @@@ int acpiphp_eject_slot(struct acpiphp_s
   * Iterate over all slots under this bridge and make sure that if a
   * card is present they are enabled, and if not they are disabled.
   */
 -static void acpiphp_check_bridge(struct acpiphp_bridge *bridge)
 +static int acpiphp_check_bridge(struct acpiphp_bridge *bridge)
  {
  	struct acpiphp_slot *slot;
 +	int retval = 0;
 +	int enabled, disabled;
 +
 +	enabled = disabled = 0;
  
  	list_for_each_entry(slot, &bridge->slots, node) {
++<<<<<<< HEAD
 +		unsigned int status = get_slot_status(slot);
 +		if (slot->flags & SLOT_ENABLED) {
 +			if (status == ACPI_STA_ALL)
 +				continue;
 +			retval = acpiphp_disable_slot(slot);
 +			if (retval) {
 +				pr_err("Error occurred in disabling\n");
 +				goto err_exit;
 +			} else {
 +				acpiphp_eject_slot(slot);
 +			}
 +			disabled++;
 +		} else {
 +			if (status != ACPI_STA_ALL)
 +				continue;
 +			retval = acpiphp_enable_slot(slot);
 +			if (retval) {
 +				pr_err("Error occurred in enabling\n");
 +				goto err_exit;
 +			}
 +			enabled++;
++=======
+ 		struct pci_bus *bus = slot->bus;
+ 		struct pci_dev *dev, *tmp;
+ 
+ 		mutex_lock(&slot->crit_sect);
+ 		/* wake up all functions */
+ 		if (get_slot_status(slot) == ACPI_STA_ALL) {
+ 			/* remove stale devices if any */
+ 			list_for_each_entry_safe(dev, tmp, &bus->devices,
+ 						 bus_list)
+ 				if (PCI_SLOT(dev->devfn) == slot->device)
+ 					trim_stale_devices(dev);
+ 
+ 			/* configure all functions */
+ 			enable_slot(slot);
+ 		} else {
+ 			disable_slot(slot);
++>>>>>>> a1d0abcea845 (ACPI / hotplug / PCI: Redefine enable_device() and disable_device())
  		}
 -		mutex_unlock(&slot->crit_sect);
  	}
 +
 +	pr_debug("%s: %d enabled, %d disabled\n", __func__, enabled, disabled);
 +
 + err_exit:
 +	return retval;
  }
  
  static void acpiphp_set_hpp_values(struct pci_bus *bus)
@@@ -1000,12 -846,20 +1021,29 @@@ static void _handle_hotplug_event_bridg
  	switch (type) {
  	case ACPI_NOTIFY_BUS_CHECK:
  		/* bus re-enumerate */
++<<<<<<< HEAD
 +		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
 +		pr_debug("%s: re-enumerating slots under %s\n",
 +			 __func__, objname);
 +		acpiphp_check_bridge(bridge);
 +		acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
 +			ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
++=======
+ 		dbg("%s: Bus check notify on %s\n", __func__, objname);
+ 		dbg("%s: re-enumerating slots under %s\n", __func__, objname);
+ 		if (bridge) {
+ 			acpiphp_check_bridge(bridge);
+ 			acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
+ 					    ACPI_UINT32_MAX, check_sub_bridges,
+ 					    NULL, NULL, NULL);
+ 		} else {
+ 			struct acpiphp_slot *slot = func->slot;
+ 
+ 			mutex_lock(&slot->crit_sect);
+ 			enable_slot(slot);
+ 			mutex_unlock(&slot->crit_sect);
+ 		}
++>>>>>>> a1d0abcea845 (ACPI / hotplug / PCI: Redefine enable_device() and disable_device())
  		break;
  
  	case ACPI_NOTIFY_DEVICE_CHECK:
@@@ -1228,28 -1044,13 +1266,35 @@@ void acpiphp_remove_slots(struct pci_bu
   */
  int acpiphp_enable_slot(struct acpiphp_slot *slot)
  {
++<<<<<<< HEAD
 +	int retval;
 +
 +	mutex_lock(&slot->crit_sect);
 +
 +	/* wake up all functions */
 +	retval = power_on_slot(slot);
 +	if (retval)
 +		goto err_exit;
++=======
+ 	mutex_lock(&slot->crit_sect);
+ 	/* configure all functions */
+ 	if (!(slot->flags & SLOT_ENABLED))
+ 		enable_slot(slot);
++>>>>>>> a1d0abcea845 (ACPI / hotplug / PCI: Redefine enable_device() and disable_device())
 +
 +	if (get_slot_status(slot) == ACPI_STA_ALL) {
 +		/* configure all functions */
 +		retval = enable_device(slot);
 +		if (retval)
 +			power_off_slot(slot);
 +	} else {
 +		pr_debug("%s: Slot status is not ACPI_STA_ALL\n", __func__);
 +		power_off_slot(slot);
 +	}
  
 + err_exit:
  	mutex_unlock(&slot->crit_sect);
- 	return retval;
+ 	return 0;
  }
  
  /**
@@@ -1263,16 -1065,18 +1308,13 @@@ int acpiphp_disable_slot(struct acpiphp
  	mutex_lock(&slot->crit_sect);
  
  	/* unconfigure all functions */
- 	retval = disable_device(slot);
- 	if (retval)
- 		goto err_exit;
+ 	disable_slot(slot);
  
 -	list_for_each_entry(func, &slot->funcs, sibling)
 -		if (func->flags & FUNC_HAS_EJ0) {
 -			acpi_handle handle = func_to_handle(func);
 -
 -			if (ACPI_FAILURE(acpi_evaluate_ej0(handle)))
 -				acpi_handle_err(handle, "_EJ0 failed\n");
 -
 -			break;
 -		}
 +	/* power off all functions */
 +	retval = power_off_slot(slot);
 +	if (retval)
 +		goto err_exit;
  
-  err_exit:
  	mutex_unlock(&slot->crit_sect);
  	return retval;
  }
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
