NFS: Fix a bogus warning in nfs_generic_pgio

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit b8fb9c30f25e45dab5d2cd310ab6913b6861d00f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/b8fb9c30.failed

It is OK for pageused == pagecount in the loop, as long as we don't add
another entry to the *pages array. Move the test so that it only triggers
in that case.

	Reported-by: Steve Dickson <SteveD@redhat.com>
Fixes: bba5c1887a92 (nfs: disallow duplicate pages in pgio page vectors)
	Cc: Weston Andros Adamson <dros@primarydata.com>
	Cc: stable@vger.kernel.org # 3.16.x
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit b8fb9c30f25e45dab5d2cd310ab6913b6861d00f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pagelist.c
diff --cc fs/nfs/pagelist.c
index 5f18707a0319,ed0db61f8543..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -340,6 -700,98 +340,101 @@@ void nfs_pageio_init(struct nfs_pageio_
  }
  EXPORT_SYMBOL_GPL(nfs_pageio_init);
  
++<<<<<<< HEAD
++=======
+ /**
+  * nfs_pgio_result - Basic pageio error handling
+  * @task: The task that ran
+  * @calldata: Pageio header to check
+  */
+ static void nfs_pgio_result(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs_pgio_header *hdr = calldata;
+ 	struct inode *inode = hdr->inode;
+ 
+ 	dprintk("NFS: %s: %5u, (status %d)\n", __func__,
+ 		task->tk_pid, task->tk_status);
+ 
+ 	if (hdr->rw_ops->rw_done(task, hdr, inode) != 0)
+ 		return;
+ 	if (task->tk_status < 0)
+ 		nfs_set_pgio_error(hdr, task->tk_status, hdr->args.offset);
+ 	else
+ 		hdr->rw_ops->rw_result(task, hdr);
+ }
+ 
+ /*
+  * Create an RPC task for the given read or write request and kick it.
+  * The page must have been locked by the caller.
+  *
+  * It may happen that the page we're passed is not marked dirty.
+  * This is the case if nfs_updatepage detects a conflicting request
+  * that has been written but not committed.
+  */
+ int nfs_generic_pgio(struct nfs_pageio_descriptor *desc,
+ 		     struct nfs_pgio_header *hdr)
+ {
+ 	struct nfs_page		*req;
+ 	struct page		**pages,
+ 				*last_page;
+ 	struct list_head *head = &desc->pg_list;
+ 	struct nfs_commit_info cinfo;
+ 	unsigned int pagecount, pageused;
+ 
+ 	pagecount = nfs_page_array_len(desc->pg_base, desc->pg_count);
+ 	if (!nfs_pgarray_set(&hdr->page_array, pagecount))
+ 		return nfs_pgio_error(desc, hdr);
+ 
+ 	nfs_init_cinfo(&cinfo, desc->pg_inode, desc->pg_dreq);
+ 	pages = hdr->page_array.pagevec;
+ 	last_page = NULL;
+ 	pageused = 0;
+ 	while (!list_empty(head)) {
+ 		req = nfs_list_entry(head->next);
+ 		nfs_list_remove_request(req);
+ 		nfs_list_add_request(req, &hdr->pages);
+ 
+ 		if (!last_page || last_page != req->wb_page) {
+ 			pageused++;
+ 			if (pageused > pagecount)
+ 				break;
+ 			*pages++ = last_page = req->wb_page;
+ 		}
+ 	}
+ 	if (WARN_ON_ONCE(pageused != pagecount))
+ 		return nfs_pgio_error(desc, hdr);
+ 
+ 	if ((desc->pg_ioflags & FLUSH_COND_STABLE) &&
+ 	    (desc->pg_moreio || nfs_reqs_to_commit(&cinfo)))
+ 		desc->pg_ioflags &= ~FLUSH_COND_STABLE;
+ 
+ 	/* Set up the argument struct */
+ 	nfs_pgio_rpcsetup(hdr, desc->pg_count, 0, desc->pg_ioflags, &cinfo);
+ 	desc->pg_rpc_callops = &nfs_pgio_common_ops;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(nfs_generic_pgio);
+ 
+ static int nfs_generic_pg_pgios(struct nfs_pageio_descriptor *desc)
+ {
+ 	struct nfs_pgio_header *hdr;
+ 	int ret;
+ 
+ 	hdr = nfs_pgio_header_alloc(desc->pg_rw_ops);
+ 	if (!hdr) {
+ 		desc->pg_completion_ops->error_cleanup(&desc->pg_list);
+ 		return -ENOMEM;
+ 	}
+ 	nfs_pgheader_init(desc, hdr, nfs_pgio_header_free);
+ 	ret = nfs_generic_pgio(desc, hdr);
+ 	if (ret == 0)
+ 		ret = nfs_initiate_pgio(NFS_CLIENT(hdr->inode),
+ 					hdr, desc->pg_rpc_callops,
+ 					desc->pg_ioflags, 0);
+ 	return ret;
+ }
+ 
++>>>>>>> b8fb9c30f25e (NFS: Fix a bogus warning in nfs_generic_pgio)
  static bool nfs_match_open_context(const struct nfs_open_context *ctx1,
  		const struct nfs_open_context *ctx2)
  {
* Unmerged path fs/nfs/pagelist.c
