udp: Fix inverted NAPI_GRO_CB(skb)->flush test

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Scott Wood <scottwood@freescale.com>
commit 2d8f7e2c8a63131828e8d4e2d98835399f27319e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2d8f7e2c.failed

Commit 2abb7cdc0d ("udp: Add support for doing checksum unnecessary
conversion") caused napi_gro_cb structs with the "flush" field zero to
take the "udp_gro_receive" path rather than the "set flush to 1" path
that they would previously take.  As a result I saw booting from an NFS
root hang shortly after starting userspace, with "server not
responding" messages.

This change to the handling of "flush == 0" packets appears to be
incidental to the goal of adding new code in the case where
skb_gro_checksum_validate_zero_check() returns zero.  Based on that and
the fact that it breaks things, I'm assuming that it is unintentional.

Fixes: 2abb7cdc0d ("udp: Add support for doing checksum unnecessary conversion")
	Cc: Tom Herbert <therbert@google.com>
	Signed-off-by: Scott Wood <scottwood@freescale.com>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2d8f7e2c8a63131828e8d4e2d98835399f27319e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp_offload.c
#	net/ipv6/udp_offload.c
diff --cc net/ipv4/udp_offload.c
index 1d2f12fcbc52,adab393b2fe5..000000000000
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@@ -213,16 -290,25 +213,21 @@@ static struct sk_buff **udp4_gro_receiv
  {
  	struct udphdr *uh = udp_gro_udphdr(skb);
  
 -	if (unlikely(!uh))
 -		goto flush;
 -
  	/* Don't bother verifying checksum if we're going to flush anyway. */
++<<<<<<< HEAD
 +	if (unlikely(!uh) ||
 +	    (!NAPI_GRO_CB(skb)->flush &&
 +	     skb_gro_checksum_validate_zero_check(skb, IPPROTO_UDP, uh->check,
 +						  inet_gro_compute_pseudo))) {
 +		NAPI_GRO_CB(skb)->flush = 1;
 +		return NULL;
 +	}
++=======
+ 	if (NAPI_GRO_CB(skb)->flush)
+ 		goto skip;
++>>>>>>> 2d8f7e2c8a63 (udp: Fix inverted NAPI_GRO_CB(skb)->flush test)
  
 -	if (skb_gro_checksum_validate_zero_check(skb, IPPROTO_UDP, uh->check,
 -						 inet_gro_compute_pseudo))
 -		goto flush;
 -	else if (uh->check)
 -		skb_gro_checksum_try_convert(skb, IPPROTO_UDP, uh->check,
 -					     inet_gro_compute_pseudo);
 -skip:
  	return udp_gro_receive(head, skb, uh);
 -
 -flush:
 -	NAPI_GRO_CB(skb)->flush = 1;
 -	return NULL;
  }
  
  int udp_gro_complete(struct sk_buff *skb, int nhoff)
diff --cc net/ipv6/udp_offload.c
index 0d60f40e0d74,de85f809bf29..000000000000
--- a/net/ipv6/udp_offload.c
+++ b/net/ipv6/udp_offload.c
@@@ -134,19 -134,29 +134,24 @@@ static struct sk_buff **udp6_gro_receiv
  {
  	struct udphdr *uh = udp_gro_udphdr(skb);
  
 -	if (unlikely(!uh))
 -		goto flush;
 -
  	/* Don't bother verifying checksum if we're going to flush anyway. */
++<<<<<<< HEAD
 +	if (unlikely(!uh) ||
 +	    (!NAPI_GRO_CB(skb)->flush &&
 +	     skb_gro_checksum_validate_zero_check(skb, IPPROTO_UDP, uh->check,
 +						  ip6_gro_compute_pseudo))) {
 +		NAPI_GRO_CB(skb)->flush = 1;
 +		return NULL;
 +	}
++=======
+ 	if (NAPI_GRO_CB(skb)->flush)
+ 		goto skip;
++>>>>>>> 2d8f7e2c8a63 (udp: Fix inverted NAPI_GRO_CB(skb)->flush test)
  
 -	if (skb_gro_checksum_validate_zero_check(skb, IPPROTO_UDP, uh->check,
 -						 ip6_gro_compute_pseudo))
 -		goto flush;
 -	else if (uh->check)
 -		skb_gro_checksum_try_convert(skb, IPPROTO_UDP, uh->check,
 -					     ip6_gro_compute_pseudo);
 -
 -skip:
  	return udp_gro_receive(head, skb, uh);
 -
 -flush:
 -	NAPI_GRO_CB(skb)->flush = 1;
 -	return NULL;
  }
  
 -static int udp6_gro_complete(struct sk_buff *skb, int nhoff)
 +int udp6_gro_complete(struct sk_buff *skb, int nhoff)
  {
  	const struct ipv6hdr *ipv6h = ipv6_hdr(skb);
  	struct udphdr *uh = (struct udphdr *)(skb->data + nhoff);
* Unmerged path net/ipv4/udp_offload.c
* Unmerged path net/ipv6/udp_offload.c
