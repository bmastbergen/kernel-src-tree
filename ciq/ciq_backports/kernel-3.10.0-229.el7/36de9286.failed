ext4: propagate errors up to ext4_find_entry()'s callers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit 36de928641ee48b2078d3fe9514242aaa2f92013
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/36de9286.failed

If we run into some kind of error, such as ENOMEM, while calling
ext4_getblk() or ext4_dx_find_entry(), we need to make sure this error
gets propagated up to ext4_find_entry() and then to its callers.  This
way, transient errors such as ENOMEM can get propagated to the VFS.
This is important so that the system calls return the appropriate
error, and also so that in the case of ext4_lookup(), we return an
error instead of a NULL inode, since that will result in a negative
dentry cache entry that will stick around long past the OOM condition
which caused a transient ENOMEM error.

Google-Bug-Id: #17142205

	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@vger.kernel.org
(cherry picked from commit 36de928641ee48b2078d3fe9514242aaa2f92013)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/namei.c
diff --cc fs/ext4/namei.c
index 360c09c5abae,ae7088b446d1..000000000000
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@@ -3231,6 -3333,146 +3256,149 @@@ end_rename
  	return retval;
  }
  
++<<<<<<< HEAD
++=======
+ static int ext4_cross_rename(struct inode *old_dir, struct dentry *old_dentry,
+ 			     struct inode *new_dir, struct dentry *new_dentry)
+ {
+ 	handle_t *handle = NULL;
+ 	struct ext4_renament old = {
+ 		.dir = old_dir,
+ 		.dentry = old_dentry,
+ 		.inode = old_dentry->d_inode,
+ 	};
+ 	struct ext4_renament new = {
+ 		.dir = new_dir,
+ 		.dentry = new_dentry,
+ 		.inode = new_dentry->d_inode,
+ 	};
+ 	u8 new_file_type;
+ 	int retval;
+ 
+ 	dquot_initialize(old.dir);
+ 	dquot_initialize(new.dir);
+ 
+ 	old.bh = ext4_find_entry(old.dir, &old.dentry->d_name,
+ 				 &old.de, &old.inlined);
+ 	if (IS_ERR(old.bh))
+ 		return PTR_ERR(old.bh);
+ 	/*
+ 	 *  Check for inode number is _not_ due to possible IO errors.
+ 	 *  We might rmdir the source, keep it as pwd of some process
+ 	 *  and merrily kill the link to whatever was created under the
+ 	 *  same name. Goodbye sticky bit ;-<
+ 	 */
+ 	retval = -ENOENT;
+ 	if (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)
+ 		goto end_rename;
+ 
+ 	new.bh = ext4_find_entry(new.dir, &new.dentry->d_name,
+ 				 &new.de, &new.inlined);
+ 	if (IS_ERR(new.bh)) {
+ 		retval = PTR_ERR(new.bh);
+ 		goto end_rename;
+ 	}
+ 
+ 	/* RENAME_EXCHANGE case: old *and* new must both exist */
+ 	if (!new.bh || le32_to_cpu(new.de->inode) != new.inode->i_ino)
+ 		goto end_rename;
+ 
+ 	handle = ext4_journal_start(old.dir, EXT4_HT_DIR,
+ 		(2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +
+ 		 2 * EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2));
+ 	if (IS_ERR(handle))
+ 		return PTR_ERR(handle);
+ 
+ 	if (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))
+ 		ext4_handle_sync(handle);
+ 
+ 	if (S_ISDIR(old.inode->i_mode)) {
+ 		old.is_dir = true;
+ 		retval = ext4_rename_dir_prepare(handle, &old);
+ 		if (retval)
+ 			goto end_rename;
+ 	}
+ 	if (S_ISDIR(new.inode->i_mode)) {
+ 		new.is_dir = true;
+ 		retval = ext4_rename_dir_prepare(handle, &new);
+ 		if (retval)
+ 			goto end_rename;
+ 	}
+ 
+ 	/*
+ 	 * Other than the special case of overwriting a directory, parents'
+ 	 * nlink only needs to be modified if this is a cross directory rename.
+ 	 */
+ 	if (old.dir != new.dir && old.is_dir != new.is_dir) {
+ 		old.dir_nlink_delta = old.is_dir ? -1 : 1;
+ 		new.dir_nlink_delta = -old.dir_nlink_delta;
+ 		retval = -EMLINK;
+ 		if ((old.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(old.dir)) ||
+ 		    (new.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(new.dir)))
+ 			goto end_rename;
+ 	}
+ 
+ 	new_file_type = new.de->file_type;
+ 	retval = ext4_setent(handle, &new, old.inode->i_ino, old.de->file_type);
+ 	if (retval)
+ 		goto end_rename;
+ 
+ 	retval = ext4_setent(handle, &old, new.inode->i_ino, new_file_type);
+ 	if (retval)
+ 		goto end_rename;
+ 
+ 	/*
+ 	 * Like most other Unix systems, set the ctime for inodes on a
+ 	 * rename.
+ 	 */
+ 	old.inode->i_ctime = ext4_current_time(old.inode);
+ 	new.inode->i_ctime = ext4_current_time(new.inode);
+ 	ext4_mark_inode_dirty(handle, old.inode);
+ 	ext4_mark_inode_dirty(handle, new.inode);
+ 
+ 	if (old.dir_bh) {
+ 		retval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);
+ 		if (retval)
+ 			goto end_rename;
+ 	}
+ 	if (new.dir_bh) {
+ 		retval = ext4_rename_dir_finish(handle, &new, old.dir->i_ino);
+ 		if (retval)
+ 			goto end_rename;
+ 	}
+ 	ext4_update_dir_count(handle, &old);
+ 	ext4_update_dir_count(handle, &new);
+ 	retval = 0;
+ 
+ end_rename:
+ 	brelse(old.dir_bh);
+ 	brelse(new.dir_bh);
+ 	brelse(old.bh);
+ 	brelse(new.bh);
+ 	if (handle)
+ 		ext4_journal_stop(handle);
+ 	return retval;
+ }
+ 
+ static int ext4_rename2(struct inode *old_dir, struct dentry *old_dentry,
+ 			struct inode *new_dir, struct dentry *new_dentry,
+ 			unsigned int flags)
+ {
+ 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))
+ 		return -EINVAL;
+ 
+ 	if (flags & RENAME_EXCHANGE) {
+ 		return ext4_cross_rename(old_dir, old_dentry,
+ 					 new_dir, new_dentry);
+ 	}
+ 	/*
+ 	 * Existence checking was done by the VFS, otherwise "RENAME_NOREPLACE"
+ 	 * is equivalent to regular rename.
+ 	 */
+ 	return ext4_rename(old_dir, old_dentry, new_dir, new_dentry);
+ }
+ 
++>>>>>>> 36de928641ee (ext4: propagate errors up to ext4_find_entry()'s callers)
  /*
   * directories can handle most operations...
   */
diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h
index 5d697ecd0ca6..1250a4e7be5e 100644
--- a/fs/ext4/ext4.h
+++ b/fs/ext4/ext4.h
@@ -1838,7 +1838,7 @@ ext4_group_first_block_no(struct super_block *sb, ext4_group_t group_no)
 /*
  * Special error return code only used by dx_probe() and its callers.
  */
-#define ERR_BAD_DX_DIR	-75000
+#define ERR_BAD_DX_DIR	(-(MAX_ERRNO - 1))
 
 /*
  * Timeout and state flag for lazy initialization inode thread.
* Unmerged path fs/ext4/namei.c
