uprobes/x86: Don't use arch_uprobe_abort_xol() in arch_uprobe_post_xol()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [kernel] uprobes: Don't use arch_uprobe_abort_xol() in arch_uprobe_post_xol() (Oleg Nesterov) [1073627]
Rebuild_FUZZ: 97.14%
commit-author Oleg Nesterov <oleg@redhat.com>
commit 6ded5f3848bfd3227ee208aa38f8bf8d7209d4e3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/6ded5f38.failed

014940bad8e4 "uprobes/x86: Send SIGILL if arch_uprobe_post_xol() fails"
changed arch_uprobe_post_xol() to use arch_uprobe_abort_xol() if ->post_xol
fails. This was correct and helped to avoid the additional complications,
we need to clear X86_EFLAGS_TF in this case.

However, now that we have uprobe_xol_ops->abort() hook it would be better
to avoid arch_uprobe_abort_xol() here. ->post_xol() should likely do what
->abort() does anyway, we should not do the same work twice. Currently only
handle_riprel_post_xol() can be called twice, this is unnecessary but safe.
Still this is not clean and can lead to the problems in future.

Change arch_uprobe_post_xol() to clear X86_EFLAGS_TF and restore ->ip by
hand and avoid arch_uprobe_abort_xol(). This temporary uglifies the usage
of autask.saved_tf, we will cleanup this later.

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Reviewed-by: Jim Keniston <jkenisto@us.ibm.com>
(cherry picked from commit 6ded5f3848bfd3227ee208aa38f8bf8d7209d4e3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/uprobes.c
diff --cc arch/x86/kernel/uprobes.c
index 99569dc5b83d,2efb93f96030..000000000000
--- a/arch/x86/kernel/uprobes.c
+++ b/arch/x86/kernel/uprobes.c
@@@ -545,12 -757,26 +545,32 @@@ bool arch_uprobe_xol_was_trapped(struc
  int arch_uprobe_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
  {
  	struct uprobe_task *utask = current->utask;
 +	long correction;
 +	int result = 0;
  
  	WARN_ON_ONCE(current->thread.trap_nr != UPROBE_TRAP_NR);
+ 	current->thread.trap_nr = utask->autask.saved_trap_nr;
  
++<<<<<<< HEAD
 +	current->thread.trap_nr = utask->autask.saved_trap_nr;
++=======
+ 	if (auprobe->ops->post_xol) {
+ 		int err = auprobe->ops->post_xol(auprobe, regs);
+ 		if (err) {
+ 			if (!utask->autask.saved_tf)
+ 				regs->flags &= ~X86_EFLAGS_TF;
+ 			/*
+ 			 * Restore ->ip for restart or post mortem analysis.
+ 			 * ->post_xol() must not return -ERESTART unless this
+ 			 * is really possible.
+ 			 */
+ 			regs->ip = utask->vaddr;
+ 			if (err == -ERESTART)
+ 				return 0;
+ 			return err;
+ 		}
+ 	}
++>>>>>>> 6ded5f3848bf (uprobes/x86: Don't use arch_uprobe_abort_xol() in arch_uprobe_post_xol())
  	/*
  	 * arch_uprobe_pre_xol() doesn't save the state of TIF_BLOCKSTEP
  	 * so we can get an extra SIGTRAP if we do not clear TF. We need
@@@ -603,8 -821,8 +623,13 @@@ int arch_uprobe_exception_notify(struc
  
  /*
   * This function gets called when XOL instruction either gets trapped or
++<<<<<<< HEAD
 + * the thread has a fatal signal, so reset the instruction pointer to its
 + * probed address.
++=======
+  * the thread has a fatal signal. Reset the instruction pointer to its
+  * probed address for the potential restart or for post mortem analysis.
++>>>>>>> 6ded5f3848bf (uprobes/x86: Don't use arch_uprobe_abort_xol() in arch_uprobe_post_xol())
   */
  void arch_uprobe_abort_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
  {
* Unmerged path arch/x86/kernel/uprobes.c
