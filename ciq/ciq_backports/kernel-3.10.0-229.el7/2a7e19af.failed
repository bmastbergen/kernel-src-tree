e1000e: Fix Runtime PM blocks EEE link negotiation in S5

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author David Ertman <david.m.ertman@intel.com>
commit 2a7e19af94104b270d675c52bba2ca1bc20efa70
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2a7e19af.failed

Adding a function, and associated calls, to flush writes to (read) the LPIC
MAC register before entering the shutdown flow.  This fixes the problem
of the PHY never negotiating a 100M link (if both sides of the link support
EEE and 100M link) when Runtime PM is enabled.

	Signed-off-by: Dave Ertman <david.m.ertman@intel.com>
	Tested-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 2a7e19af94104b270d675c52bba2ca1bc20efa70)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/e1000e/netdev.c
diff --cc drivers/net/ethernet/intel/e1000e/netdev.c
index 3dc2552664d3,65c3aef2bd36..000000000000
--- a/drivers/net/ethernet/intel/e1000e/netdev.c
+++ b/drivers/net/ethernet/intel/e1000e/netdev.c
@@@ -6010,15 -6033,32 +6010,41 @@@ release
  	return retval;
  }
  
++<<<<<<< HEAD
 +static int __e1000_shutdown(struct pci_dev *pdev, bool runtime)
++=======
+ static void e1000e_flush_lpic(struct pci_dev *pdev)
+ {
+ 	struct net_device *netdev = pci_get_drvdata(pdev);
+ 	struct e1000_adapter *adapter = netdev_priv(netdev);
+ 	struct e1000_hw *hw = &adapter->hw;
+ 	u32 ret_val;
+ 
+ 	pm_runtime_get_sync(netdev->dev.parent);
+ 
+ 	ret_val = hw->phy.ops.acquire(hw);
+ 	if (ret_val)
+ 		goto fl_out;
+ 
+ 	pr_info("EEE TX LPI TIMER: %08X\n",
+ 		er32(LPIC) >> E1000_LPIC_LPIET_SHIFT);
+ 
+ 	hw->phy.ops.release(hw);
+ 
+ fl_out:
+ 	pm_runtime_put_sync(netdev->dev.parent);
+ }
+ 
+ static int e1000e_pm_freeze(struct device *dev)
++>>>>>>> 2a7e19af9410 (e1000e: Fix Runtime PM blocks EEE link negotiation in S5)
  {
 -	struct net_device *netdev = pci_get_drvdata(to_pci_dev(dev));
 +	struct net_device *netdev = pci_get_drvdata(pdev);
  	struct e1000_adapter *adapter = netdev_priv(netdev);
 +	struct e1000_hw *hw = &adapter->hw;
 +	u32 ctrl, ctrl_ext, rctl, status;
 +	/* Runtime suspend should only enable wakeup for link changes */
 +	u32 wufc = runtime ? E1000_WUFC_LNKC : adapter->wol;
 +	int retval = 0;
  
  	netif_device_detach(netdev);
  
@@@ -6292,6 -6355,10 +6318,13 @@@ static int e1000_suspend(struct device 
  {
  	struct pci_dev *pdev = to_pci_dev(dev);
  
++<<<<<<< HEAD
++=======
+ 	e1000e_flush_lpic(pdev);
+ 
+ 	e1000e_pm_freeze(dev);
+ 
++>>>>>>> 2a7e19af9410 (e1000e: Fix Runtime PM blocks EEE link negotiation in S5)
  	return __e1000_shutdown(pdev, false);
  }
  
@@@ -6356,6 -6440,10 +6389,13 @@@ static int e1000_runtime_resume(struct 
  
  static void e1000_shutdown(struct pci_dev *pdev)
  {
++<<<<<<< HEAD
++=======
+ 	e1000e_flush_lpic(pdev);
+ 
+ 	e1000e_pm_freeze(&pdev->dev);
+ 
++>>>>>>> 2a7e19af9410 (e1000e: Fix Runtime PM blocks EEE link negotiation in S5)
  	__e1000_shutdown(pdev, false);
  }
  
* Unmerged path drivers/net/ethernet/intel/e1000e/netdev.c
