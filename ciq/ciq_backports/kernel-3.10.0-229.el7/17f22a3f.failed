perf report: Use al->cpumode where applicable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf/report: Use al->cpumode where applicable (Jiri Olsa) [1134356]
Rebuild_FUZZ: 97.78%
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 17f22a3fbc9d81c1d8f9f853dd23d0e5e8f4c994
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/17f22a3f.failed

We don't need to recalculate cpumode from the perf_event->header field,
as this is already available in the struct addr_location->cpumode field.

Remove the function signature of functions that receive both perf_event
and addr_location parameters but use perf_event just to extract the
cpumode.

	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Mike Galbraith <efault@gmx.de>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Stephane Eranian <eranian@google.com>
Link: http://lkml.kernel.org/n/tip-tmct07y7mka54allj82trlnx@git.kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 17f22a3fbc9d81c1d8f9f853dd23d0e5e8f4c994)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-report.c
diff --cc tools/perf/builtin-report.c
index e3b253d3e27e,8f9d6edb4674..000000000000
--- a/tools/perf/builtin-report.c
+++ b/tools/perf/builtin-report.c
@@@ -74,27 -75,8 +74,31 @@@ static int report__config(const char *v
  	return perf_default_config(var, value, cb);
  }
  
 +static int report__resolve_callchain(struct report *rep, struct symbol **parent,
 +				     struct perf_evsel *evsel, struct addr_location *al,
 +				     struct perf_sample *sample, struct machine *machine)
 +{
 +	if ((sort__has_parent || symbol_conf.use_callchain) && sample->callchain) {
 +		return machine__resolve_callchain(machine, evsel, al->thread, sample,
 +						  parent, al, rep->max_stack);
 +	}
 +	return 0;
 +}
 +
 +static int hist_entry__append_callchain(struct hist_entry *he, struct perf_sample *sample)
 +{
 +	if (!symbol_conf.use_callchain)
 +		return 0;
 +	return callchain_append(he->callchain, &callchain_cursor, sample->period);
 +}
 +
  static int report__add_mem_hist_entry(struct perf_tool *tool, struct addr_location *al,
++<<<<<<< HEAD
 +				      struct perf_sample *sample, struct perf_evsel *evsel,
 +				      struct machine *machine, union perf_event *event)
++=======
+ 				      struct perf_sample *sample, struct perf_evsel *evsel)
++>>>>>>> 17f22a3fbc9d (perf report: Use al->cpumode where applicable)
  {
  	struct report *rep = container_of(tool, struct report, tool);
  	struct symbol *parent = NULL;
@@@ -107,7 -88,7 +110,11 @@@
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	mi = machine__resolve_mem(machine, al->thread, sample, cpumode);
++=======
+ 	mi = machine__resolve_mem(al->machine, al->thread, sample, al->cpumode);
++>>>>>>> 17f22a3fbc9d (perf report: Use al->cpumode where applicable)
  	if (!mi)
  		return -ENOMEM;
  
@@@ -259,7 -238,7 +266,11 @@@ static int process_sample_event(struct 
  		if (ret < 0)
  			pr_debug("problem adding lbr entry, skipping event\n");
  	} else if (rep->mem_mode == 1) {
++<<<<<<< HEAD
 +		ret = report__add_mem_hist_entry(tool, &al, sample, evsel, machine, event);
++=======
+ 		ret = report__add_mem_hist_entry(tool, &al, sample, evsel);
++>>>>>>> 17f22a3fbc9d (perf report: Use al->cpumode where applicable)
  		if (ret < 0)
  			pr_debug("problem adding mem entry, skipping event\n");
  	} else {
* Unmerged path tools/perf/builtin-report.c
