cpufreq: use cpufreq_driver->flags to mark CPUFREQ_HAVE_GOVERNOR_PER_POLICY

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] use cpufreq_driver->flags to mark CPUFREQ_HAVE_GOVERNOR_PER_POLICY (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 93.62%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 0b981e70748861a3e10ea2e2a689bdcee3e15085
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0b981e70.failed

Use cpufreq_driver->flags to mark CPUFREQ_HAVE_GOVERNOR_PER_POLICY instead
of a separate field within cpufreq_driver. This will save some bytes of
memory.

	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 0b981e70748861a3e10ea2e2a689bdcee3e15085)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/cpufreq.h
diff --cc include/linux/cpufreq.h
index 241e07069182,24b84f7e7f8d..000000000000
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@@ -331,26 -176,102 +331,77 @@@ __ATTR(_name, 0444, show_##_name, NULL
  static struct global_attr _name =		\
  __ATTR(_name, 0644, show_##_name, store_##_name)
  
++<<<<<<< HEAD
 +struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
 +void cpufreq_cpu_put(struct cpufreq_policy *data);
++=======
+ 
+ struct cpufreq_driver {
+ 	char			name[CPUFREQ_NAME_LEN];
+ 	u8			flags;
+ 
+ 	/* needed by all drivers */
+ 	int	(*init)		(struct cpufreq_policy *policy);
+ 	int	(*verify)	(struct cpufreq_policy *policy);
+ 
+ 	/* define one out of two */
+ 	int	(*setpolicy)	(struct cpufreq_policy *policy);
+ 	int	(*target)	(struct cpufreq_policy *policy,
+ 				 unsigned int target_freq,
+ 				 unsigned int relation);
+ 
+ 	/* should be defined, if possible */
+ 	unsigned int	(*get)	(unsigned int cpu);
+ 
+ 	/* optional */
+ 	int	(*bios_limit)	(int cpu, unsigned int *limit);
+ 
+ 	int	(*exit)		(struct cpufreq_policy *policy);
+ 	int	(*suspend)	(struct cpufreq_policy *policy);
+ 	int	(*resume)	(struct cpufreq_policy *policy);
+ 	struct freq_attr	**attr;
+ };
+ 
+ /* flags */
+ #define CPUFREQ_STICKY		(1 << 0)	/* driver isn't removed even if
+ 						   all ->init() calls failed */
+ #define CPUFREQ_CONST_LOOPS	(1 << 1)	/* loops_per_jiffy or other
+ 						   kernel "constants" aren't
+ 						   affected by frequency
+ 						   transitions */
+ #define CPUFREQ_PM_NO_WARN	(1 << 2)	/* don't warn on suspend/resume
+ 						   speed mismatches */
+ 
+ /*
+  * This should be set by platforms having multiple clock-domains, i.e.
+  * supporting multiple policies. With this sysfs directories of governor would
+  * be created in cpu/cpu<num>/cpufreq/ directory and so they can use the same
+  * governor with different tunables for different clusters.
+  */
+ #define CPUFREQ_HAVE_GOVERNOR_PER_POLICY (1 << 3)
+ 
+ int cpufreq_register_driver(struct cpufreq_driver *driver_data);
+ int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
+ 
++>>>>>>> 0b981e707488 (cpufreq: use cpufreq_driver->flags to mark CPUFREQ_HAVE_GOVERNOR_PER_POLICY)
  const char *cpufreq_get_current_driver(void);
  
 -static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
 -		unsigned int min, unsigned int max)
 -{
 -	if (policy->min < min)
 -		policy->min = min;
 -	if (policy->max < min)
 -		policy->max = min;
 -	if (policy->min > max)
 -		policy->min = max;
 -	if (policy->max > max)
 -		policy->max = max;
 -	if (policy->min > policy->max)
 -		policy->min = policy->max;
 -	return;
 -}
 -
  /*********************************************************************
 - *                     CPUFREQ NOTIFIER INTERFACE                    *
 + *                        CPUFREQ 2.6. INTERFACE                     *
   *********************************************************************/
 -
 -#define CPUFREQ_TRANSITION_NOTIFIER	(0)
 -#define CPUFREQ_POLICY_NOTIFIER		(1)
 -
 -/* Transition notifiers */
 -#define CPUFREQ_PRECHANGE		(0)
 -#define CPUFREQ_POSTCHANGE		(1)
 -#define CPUFREQ_RESUMECHANGE		(8)
 -#define CPUFREQ_SUSPENDCHANGE		(9)
 -
 -/* Policy Notifiers  */
 -#define CPUFREQ_ADJUST			(0)
 -#define CPUFREQ_INCOMPATIBLE		(1)
 -#define CPUFREQ_NOTIFY			(2)
 -#define CPUFREQ_START			(3)
 -#define CPUFREQ_UPDATE_POLICY_CPU	(4)
 +u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
 +int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 +int cpufreq_update_policy(unsigned int cpu);
 +bool have_governor_per_policy(void);
 +struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
  
  #ifdef CONFIG_CPU_FREQ
 -int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
 -int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
 -
 -void cpufreq_notify_transition(struct cpufreq_policy *policy,
 -		struct cpufreq_freqs *freqs, unsigned int state);
 -
 -#else /* CONFIG_CPU_FREQ */
 -static inline int cpufreq_register_notifier(struct notifier_block *nb,
 -						unsigned int list)
 +/*
 + * query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it
 + */
 +unsigned int cpufreq_get(unsigned int cpu);
 +#else
 +static inline unsigned int cpufreq_get(unsigned int cpu)
  {
  	return 0;
  }
diff --git a/drivers/cpufreq/arm_big_little.c b/drivers/cpufreq/arm_big_little.c
index 5d7f53fcd6f5..652163067203 100644
--- a/drivers/cpufreq/arm_big_little.c
+++ b/drivers/cpufreq/arm_big_little.c
@@ -216,13 +216,13 @@ static struct freq_attr *bL_cpufreq_attr[] = {
 
 static struct cpufreq_driver bL_cpufreq_driver = {
 	.name			= "arm-big-little",
-	.flags			= CPUFREQ_STICKY,
+	.flags			= CPUFREQ_STICKY |
+					CPUFREQ_HAVE_GOVERNOR_PER_POLICY,
 	.verify			= bL_cpufreq_verify_policy,
 	.target			= bL_cpufreq_set_target,
 	.get			= bL_cpufreq_get,
 	.init			= bL_cpufreq_init,
 	.exit			= bL_cpufreq_exit,
-	.have_governor_per_policy = true,
 	.attr			= bL_cpufreq_attr,
 };
 
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 006b599e5bea..33901df96cfd 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -134,7 +134,7 @@ static DEFINE_MUTEX(cpufreq_governor_mutex);
 
 bool have_governor_per_policy(void)
 {
-	return cpufreq_driver->have_governor_per_policy;
+	return !!(cpufreq_driver->flags & CPUFREQ_HAVE_GOVERNOR_PER_POLICY);
 }
 EXPORT_SYMBOL_GPL(have_governor_per_policy);
 
diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 7db437370f38..f67ff57d966e 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -191,7 +191,10 @@ struct common_dbs_data {
 	struct attribute_group *attr_group_gov_sys; /* one governor - system */
 	struct attribute_group *attr_group_gov_pol; /* one governor - policy */
 
-	/* Common data for platforms that don't set have_governor_per_policy */
+	/*
+	 * Common data for platforms that don't set
+	 * CPUFREQ_HAVE_GOVERNOR_PER_POLICY
+	 */
 	struct dbs_data *gdbs_data;
 
 	struct cpu_dbs_common_info *(*get_cpu_cdbs)(int cpu);
* Unmerged path include/linux/cpufreq.h
