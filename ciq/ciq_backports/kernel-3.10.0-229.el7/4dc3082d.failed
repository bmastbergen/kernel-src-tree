ACPI / hotplug / PCI: Drop acpiphp_bus_trim()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Drop acpiphp_bus_trim() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 88.89%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 4dc3082dc1dd1415177d71f15d4b19bebb1365c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/4dc3082d.failed

If trim_stale_devices() calls acpi_bus_trim() directly, we can
save a potentially costly acpi_bus_get_device() invocation.  After
making that change acpiphp_bus_trim() would only be called from one
place, so move the code from it to that place and drop it.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 4dc3082dc1dd1415177d71f15d4b19bebb1365c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,caeef648287a..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -585,52 -488,18 +585,62 @@@ static unsigned char acpiphp_max_busnr(
  	return max;
  }
  
++<<<<<<< HEAD
 +
 +/**
 + * acpiphp_bus_add - add a new bus to acpi subsystem
 + * @func: acpiphp_func of the bridge
 + */
 +static int acpiphp_bus_add(struct acpiphp_func *func)
 +{
 +	struct acpi_device *device;
 +	int ret_val;
 +
 +	if (!acpi_bus_get_device(func->handle, &device)) {
 +		pr_debug("bus exists... trim\n");
 +		/* this shouldn't be in here, so remove
 +		 * the bus then re-add it...
 +		 */
 +		acpi_bus_trim(device);
 +	}
 +
 +	ret_val = acpi_bus_scan(func->handle);
 +	if (!ret_val)
 +		ret_val = acpi_bus_get_device(func->handle, &device);
 +
 +	if (ret_val)
 +		pr_debug("error adding bus, %x\n", -ret_val);
 +
 +	return ret_val;
 +}
 +
++=======
+ /**
+  * acpiphp_bus_add - Scan ACPI namespace subtree.
+  * @handle: ACPI object handle to start the scan from.
+  */
+ static void acpiphp_bus_add(acpi_handle handle)
+ {
+ 	struct acpi_device *adev = NULL;
++>>>>>>> 4dc3082dc1dd (ACPI / hotplug / PCI: Drop acpiphp_bus_trim())
  
 -	acpi_bus_scan(handle);
 -	acpi_bus_get_device(handle, &adev);
 -	if (acpi_device_enumerated(adev))
 -		acpi_device_set_power(adev, ACPI_STATE_D0);
 +/**
 + * acpiphp_bus_trim - trim a bus from acpi subsystem
 + * @handle: handle to acpi namespace
 + */
 +static int acpiphp_bus_trim(acpi_handle handle)
 +{
 +	struct acpi_device *device;
 +	int retval;
 +
 +	retval = acpi_bus_get_device(handle, &device);
 +	if (retval) {
 +		pr_debug("acpi_device not found\n");
 +		return retval;
 +	}
 +
 +	acpi_bus_trim(device);
 +	return 0;
  }
  
  static void acpiphp_set_acpi_region(struct acpiphp_slot *slot)
@@@ -778,13 -624,15 +788,20 @@@ static int disable_device(struct acpiph
  	 * methods (_EJ0, etc.) or not.  Therefore, we remove all functions
  	 * here.
  	 */
 -	list_for_each_entry_safe_reverse(dev, prev, &bus->devices, bus_list)
 -		if (PCI_SLOT(dev->devfn) == slot->device)
 -			pci_stop_and_remove_bus_device(dev);
 +	while ((pdev = dev_in_slot(slot))) {
 +		pci_stop_and_remove_bus_device(pdev);
 +		pci_dev_put(pdev);
 +	}
  
  	list_for_each_entry(func, &slot->funcs, sibling) {
++<<<<<<< HEAD
 +		acpiphp_bus_trim(func->handle);
++=======
+ 		struct acpi_device *adev;
+ 
+ 		if (!acpi_bus_get_device(func_to_handle(func), &adev))
+ 			acpi_bus_trim(adev);
++>>>>>>> 4dc3082dc1dd (ACPI / hotplug / PCI: Drop acpiphp_bus_trim())
  	}
  
  	slot->flags &= (~SLOT_ENABLED);
@@@ -833,34 -700,44 +850,69 @@@ static unsigned int get_slot_status(str
  }
  
  /**
 - * trim_stale_devices - remove PCI devices that are not responding.
 - * @dev: PCI device to start walking the hierarchy from.
 + * acpiphp_eject_slot - physically eject the slot
 + * @slot: ACPI PHP slot
   */
 -static void trim_stale_devices(struct pci_dev *dev)
 +int acpiphp_eject_slot(struct acpiphp_slot *slot)
  {
++<<<<<<< HEAD
 +	acpi_status status;
 +	struct acpiphp_func *func;
 +	struct acpi_object_list arg_list;
 +	union acpi_object arg;
 +
 +	list_for_each_entry(func, &slot->funcs, sibling) {
 +		/* We don't want to call _EJ0 on non-existing functions. */
 +		if ((func->flags & FUNC_HAS_EJ0)) {
 +			/* _EJ0 method take one argument */
 +			arg_list.count = 1;
 +			arg_list.pointer = &arg;
 +			arg.type = ACPI_TYPE_INTEGER;
 +			arg.integer.value = 1;
 +
 +			status = acpi_evaluate_object(func->handle, "_EJ0", &arg_list, NULL);
 +			if (ACPI_FAILURE(status)) {
 +				pr_warn("%s: _EJ0 failed\n", __func__);
 +				return -1;
 +			} else
 +				break;
 +		}
++=======
+ 	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
+ 	struct pci_bus *bus = dev->subordinate;
+ 	bool alive = false;
+ 
+ 	if (adev) {
+ 		acpi_handle handle = adev->handle;
+ 		acpi_status status;
+ 		unsigned long long sta;
+ 
+ 		status = acpi_evaluate_integer(handle, "_STA", NULL, &sta);
+ 		alive = (ACPI_SUCCESS(status) && sta == ACPI_STA_ALL)
+ 			|| acpiphp_no_hotplug(handle);
+ 	}
+ 	if (!alive) {
+ 		u32 v;
+ 
+ 		/* Check if the device responds. */
+ 		alive = pci_bus_read_dev_vendor_id(dev->bus, dev->devfn, &v, 0);
+ 	}
+ 	if (!alive) {
+ 		pci_stop_and_remove_bus_device(dev);
+ 		if (adev)
+ 			acpi_bus_trim(adev);
+ 	} else if (bus) {
+ 		struct pci_dev *child, *tmp;
+ 
+ 		/* The device is a bridge. so check the bus below it. */
+ 		pm_runtime_get_sync(&dev->dev);
+ 		list_for_each_entry_safe_reverse(child, tmp, &bus->devices, bus_list)
+ 			trim_stale_devices(child);
+ 
+ 		pm_runtime_put(&dev->dev);
++>>>>>>> 4dc3082dc1dd (ACPI / hotplug / PCI: Drop acpiphp_bus_trim())
  	}
 +	return 0;
  }
  
  /**
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
