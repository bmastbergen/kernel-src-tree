perf tools: Move elide bool into perf_hpp_fmt struct

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf: Move elide bool into perf_hpp_fmt struct (Jiri Olsa) [1134356]
Rebuild_FUZZ: 93.88%
commit-author Jiri Olsa <jolsa@kernel.org>
commit f29984226978313039d7dfe9b45eaa55a3aad03d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/f2998422.failed

After output/sort fields refactoring, it's expensive
to check the elide bool in its current location inside
the 'struct sort_entry'.

The perf_hpp__should_skip function gets highly noticable in
workloads with high number of output/sort fields, like for:

  $ perf report -i perf-test.data -F overhead,sample,period,comm,pid,dso,symbol,cpu --stdio

Performance report:
   9.70%  perf  [.] perf_hpp__should_skip

Moving the elide bool into the 'struct perf_hpp_fmt', which
makes the perf_hpp__should_skip just single struct read.

Got speedup of around 22% for my test perf.data workload.
The change should not harm any other workload types.

Performance counter stats for (10 runs):
  before:
   358,319,732,626      cycles                    ( +-  0.55% )
   467,129,581,515      instructions              #    1.30  insns per cycle          ( +-  0.00% )

     150.943975206 seconds time elapsed           ( +-  0.62% )

  now:
   278,785,972,990      cycles                    ( +-  0.12% )
   370,146,797,640      instructions              #    1.33  insns per cycle          ( +-  0.00% )

     116.416670507 seconds time elapsed           ( +-  0.31% )

	Acked-by: Namhyung Kim <namhyung@kernel.org>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Stephane Eranian <eranian@google.com>
Link: http://lkml.kernel.org/r/20140601142622.GA9131@krava.brq.redhat.com
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
(cherry picked from commit f29984226978313039d7dfe9b45eaa55a3aad03d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/hist.h
#	tools/perf/util/sort.c
diff --cc tools/perf/util/hist.h
index 8cd00e1c742e,d2bf03575d5f..000000000000
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@@ -196,6 -248,18 +197,21 @@@ void perf_hpp__cancel_cumulate(void)
  
  void perf_hpp__register_sort_field(struct perf_hpp_fmt *format);
  void perf_hpp__setup_output_field(void);
++<<<<<<< HEAD
++=======
+ void perf_hpp__reset_output_field(void);
+ void perf_hpp__append_sort_keys(void);
+ 
+ bool perf_hpp__is_sort_entry(struct perf_hpp_fmt *format);
+ bool perf_hpp__same_sort_entry(struct perf_hpp_fmt *a, struct perf_hpp_fmt *b);
+ 
+ static inline bool perf_hpp__should_skip(struct perf_hpp_fmt *format)
+ {
+ 	return format->elide;
+ }
+ 
+ void perf_hpp__reset_width(struct perf_hpp_fmt *fmt, struct hists *hists);
++>>>>>>> f29984226978 (perf tools: Move elide bool into perf_hpp_fmt struct)
  
  typedef u64 (*hpp_field_fn)(struct hist_entry *he);
  typedef int (*hpp_callback_fn)(struct perf_hpp *hpp, bool front);
diff --cc tools/perf/util/sort.c
index 7eb398ecf91e,45512baaab67..000000000000
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@@ -1110,7 -1157,23 +1110,8 @@@ static int __sort_dimension__add_hpp(st
  
  	INIT_LIST_HEAD(&hse->hpp.list);
  	INIT_LIST_HEAD(&hse->hpp.sort_list);
+ 	hse->hpp.elide = false;
  
 -	return hse;
 -}
 -
 -bool perf_hpp__is_sort_entry(struct perf_hpp_fmt *format)
 -{
 -	return format->header == __sort__hpp_header;
 -}
 -
 -static int __sort_dimension__add_hpp_sort(struct sort_dimension *sd)
 -{
 -	struct hpp_sort_entry *hse = __sort_dimension__alloc_hpp(sd);
 -
 -	if (hse == NULL)
 -		return -1;
 -
  	perf_hpp__register_sort_field(&hse->hpp);
  	return 0;
  }
@@@ -1244,9 -1365,24 +1245,30 @@@ int setup_sorting(void
  	return ret;
  }
  
++<<<<<<< HEAD
 +static void sort_entry__setup_elide(struct sort_entry *se,
 +				    struct strlist *list,
 +				    const char *list_name, FILE *fp)
++=======
+ void perf_hpp__set_elide(int idx, bool elide)
+ {
+ 	struct perf_hpp_fmt *fmt;
+ 	struct hpp_sort_entry *hse;
+ 
+ 	perf_hpp__for_each_format(fmt) {
+ 		if (!perf_hpp__is_sort_entry(fmt))
+ 			continue;
+ 
+ 		hse = container_of(fmt, struct hpp_sort_entry, hpp);
+ 		if (hse->se->se_width_idx == idx) {
+ 			fmt->elide = elide;
+ 			break;
+ 		}
+ 	}
+ }
+ 
+ static bool __get_elide(struct strlist *list, const char *list_name, FILE *fp)
++>>>>>>> f29984226978 (perf tools: Move elide bool into perf_hpp_fmt struct)
  {
  	if (list && strlist__nr_entries(list) == 1) {
  		if (fp != NULL)
@@@ -1258,39 -1427,173 +1313,182 @@@ static bool get_elide(int idx, FILE *ou
  
  void sort__setup_elide(FILE *output)
  {
 -	struct perf_hpp_fmt *fmt;
 -	struct hpp_sort_entry *hse;
 +	struct sort_entry *se;
  
- 	sort_entry__setup_elide(&sort_dso, symbol_conf.dso_list,
- 				"dso", output);
- 	sort_entry__setup_elide(&sort_comm, symbol_conf.comm_list,
- 				"comm", output);
- 	sort_entry__setup_elide(&sort_sym, symbol_conf.sym_list,
- 				"symbol", output);
- 
- 	if (sort__mode == SORT_MODE__BRANCH) {
- 		sort_entry__setup_elide(&sort_dso_from,
- 					symbol_conf.dso_from_list,
- 					"dso_from", output);
- 		sort_entry__setup_elide(&sort_dso_to,
- 					symbol_conf.dso_to_list,
- 					"dso_to", output);
- 		sort_entry__setup_elide(&sort_sym_from,
- 					symbol_conf.sym_from_list,
- 					"sym_from", output);
- 		sort_entry__setup_elide(&sort_sym_to,
- 					symbol_conf.sym_to_list,
- 					"sym_to", output);
+ 	perf_hpp__for_each_format(fmt) {
+ 		if (!perf_hpp__is_sort_entry(fmt))
+ 			continue;
+ 
+ 		hse = container_of(fmt, struct hpp_sort_entry, hpp);
+ 		fmt->elide = get_elide(hse->se->se_width_idx, output);
  	}
  
  	/*
  	 * It makes no sense to elide all of sort entries.
  	 * Just revert them to show up again.
  	 */
++<<<<<<< HEAD
 +	list_for_each_entry(se, &hist_entry__sort_list, list) {
 +		if (!se->elide)
 +			return;
 +	}
 +
 +	list_for_each_entry(se, &hist_entry__sort_list, list)
 +		se->elide = false;
++=======
+ 	perf_hpp__for_each_format(fmt) {
+ 		if (!perf_hpp__is_sort_entry(fmt))
+ 			continue;
+ 
+ 		if (!fmt->elide)
+ 			return;
+ 	}
+ 
+ 	perf_hpp__for_each_format(fmt) {
+ 		if (!perf_hpp__is_sort_entry(fmt))
+ 			continue;
+ 
+ 		fmt->elide = false;
+ 	}
+ }
+ 
+ static int output_field_add(char *tok)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(common_sort_dimensions); i++) {
+ 		struct sort_dimension *sd = &common_sort_dimensions[i];
+ 
+ 		if (strncasecmp(tok, sd->name, strlen(tok)))
+ 			continue;
+ 
+ 		return __sort_dimension__add_output(sd);
+ 	}
+ 
+ 	for (i = 0; i < ARRAY_SIZE(hpp_sort_dimensions); i++) {
+ 		struct hpp_dimension *hd = &hpp_sort_dimensions[i];
+ 
+ 		if (strncasecmp(tok, hd->name, strlen(tok)))
+ 			continue;
+ 
+ 		return __hpp_dimension__add_output(hd);
+ 	}
+ 
+ 	for (i = 0; i < ARRAY_SIZE(bstack_sort_dimensions); i++) {
+ 		struct sort_dimension *sd = &bstack_sort_dimensions[i];
+ 
+ 		if (strncasecmp(tok, sd->name, strlen(tok)))
+ 			continue;
+ 
+ 		return __sort_dimension__add_output(sd);
+ 	}
+ 
+ 	for (i = 0; i < ARRAY_SIZE(memory_sort_dimensions); i++) {
+ 		struct sort_dimension *sd = &memory_sort_dimensions[i];
+ 
+ 		if (strncasecmp(tok, sd->name, strlen(tok)))
+ 			continue;
+ 
+ 		return __sort_dimension__add_output(sd);
+ 	}
+ 
+ 	return -ESRCH;
+ }
+ 
+ static void reset_dimensions(void)
+ {
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(common_sort_dimensions); i++)
+ 		common_sort_dimensions[i].taken = 0;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(hpp_sort_dimensions); i++)
+ 		hpp_sort_dimensions[i].taken = 0;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(bstack_sort_dimensions); i++)
+ 		bstack_sort_dimensions[i].taken = 0;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(memory_sort_dimensions); i++)
+ 		memory_sort_dimensions[i].taken = 0;
+ }
+ 
+ static int __setup_output_field(void)
+ {
+ 	char *tmp, *tok, *str;
+ 	int ret = 0;
+ 
+ 	if (field_order == NULL)
+ 		return 0;
+ 
+ 	reset_dimensions();
+ 
+ 	str = strdup(field_order);
+ 	if (str == NULL) {
+ 		error("Not enough memory to setup output fields");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	for (tok = strtok_r(str, ", ", &tmp);
+ 			tok; tok = strtok_r(NULL, ", ", &tmp)) {
+ 		ret = output_field_add(tok);
+ 		if (ret == -EINVAL) {
+ 			error("Invalid --fields key: `%s'", tok);
+ 			break;
+ 		} else if (ret == -ESRCH) {
+ 			error("Unknown --fields key: `%s'", tok);
+ 			break;
+ 		}
+ 	}
+ 
+ 	free(str);
+ 	return ret;
+ }
+ 
+ int setup_sorting(void)
+ {
+ 	int err;
+ 
+ 	err = __setup_sorting();
+ 	if (err < 0)
+ 		return err;
+ 
+ 	if (parent_pattern != default_parent_pattern) {
+ 		err = sort_dimension__add("parent");
+ 		if (err < 0)
+ 			return err;
+ 	}
+ 
+ 	reset_dimensions();
+ 
+ 	/*
+ 	 * perf diff doesn't use default hpp output fields.
+ 	 */
+ 	if (sort__mode != SORT_MODE__DIFF)
+ 		perf_hpp__init();
+ 
+ 	err = __setup_output_field();
+ 	if (err < 0)
+ 		return err;
+ 
+ 	/* copy sort keys to output fields */
+ 	perf_hpp__setup_output_field();
+ 	/* and then copy output fields to sort keys */
+ 	perf_hpp__append_sort_keys();
+ 
+ 	return 0;
+ }
+ 
+ void reset_output_field(void)
+ {
+ 	sort__need_collapse = 0;
+ 	sort__has_parent = 0;
+ 	sort__has_sym = 0;
+ 	sort__has_dso = 0;
+ 
+ 	field_order = NULL;
+ 	sort_order = NULL;
+ 
+ 	reset_dimensions();
+ 	perf_hpp__reset_output_field();
++>>>>>>> f29984226978 (perf tools: Move elide bool into perf_hpp_fmt struct)
  }
diff --git a/tools/perf/ui/browsers/hists.c b/tools/perf/ui/browsers/hists.c
index 9c27e35401c5..3ae9575cf73e 100644
--- a/tools/perf/ui/browsers/hists.c
+++ b/tools/perf/ui/browsers/hists.c
@@ -1685,14 +1685,14 @@ zoom_dso:
 zoom_out_dso:
 				ui_helpline__pop();
 				browser->hists->dso_filter = NULL;
-				sort_dso.elide = false;
+				perf_hpp__set_elide(HISTC_DSO, false);
 			} else {
 				if (dso == NULL)
 					continue;
 				ui_helpline__fpush("To zoom out press <- or -> + \"Zoom out of %s DSO\"",
 						   dso->kernel ? "the Kernel" : dso->short_name);
 				browser->hists->dso_filter = dso;
-				sort_dso.elide = true;
+				perf_hpp__set_elide(HISTC_DSO, true);
 				pstack__push(fstack, &browser->hists->dso_filter);
 			}
 			hists__filter_by_dso(hists);
@@ -1704,13 +1704,13 @@ zoom_thread:
 zoom_out_thread:
 				ui_helpline__pop();
 				browser->hists->thread_filter = NULL;
-				sort_thread.elide = false;
+				perf_hpp__set_elide(HISTC_THREAD, false);
 			} else {
 				ui_helpline__fpush("To zoom out press <- or -> + \"Zoom out of %s(%d) thread\"",
 						   thread->comm_set ? thread__comm_str(thread) : "",
 						   thread->tid);
 				browser->hists->thread_filter = thread;
-				sort_thread.elide = true;
+				perf_hpp__set_elide(HISTC_THREAD, false);
 				pstack__push(fstack, &browser->hists->thread_filter);
 			}
 			hists__filter_by_thread(hists);
* Unmerged path tools/perf/util/hist.h
* Unmerged path tools/perf/util/sort.c
diff --git a/tools/perf/util/sort.h b/tools/perf/util/sort.h
index d43ebef70364..60fcbf1bc154 100644
--- a/tools/perf/util/sort.h
+++ b/tools/perf/util/sort.h
@@ -182,7 +182,6 @@ struct sort_entry {
 	int	(*se_snprintf)(struct hist_entry *self, char *bf, size_t size,
 			       unsigned int width);
 	u8	se_width_idx;
-	bool	elide;
 };
 
 extern struct sort_entry sort_thread;
@@ -191,6 +190,7 @@ extern struct list_head hist_entry__sort_list;
 int setup_sorting(void);
 extern int sort_dimension__add(const char *);
 void sort__setup_elide(FILE *fp);
+void perf_hpp__set_elide(int idx, bool elide);
 
 int report_parse_ignore_callees_opt(const struct option *opt, const char *arg, int unset);
 
