bridge: Fix the way to find old local fdb entries in br_fdb_changeaddr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
commit a5642ab4744bc8c5a8c7ce7c6e30c01bd6bbc691
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a5642ab4.failed

br_fdb_changeaddr() assumes that there is at most one local entry per port
per vlan. It used to be true, but since commit 36fd2b63e3b4 ("bridge: allow
creating/deleting fdb entries via netlink"), it has not been so.
Therefore, the function might fail to search a correct previous address
to be deleted and delete an arbitrary local entry if user has added local
entries manually.

Example of problematic case:
  ip link set eth0 address ee:ff:12:34:56:78
  brctl addif br0 eth0
  bridge fdb add 12:34:56:78:90:ab dev eth0 master
  ip link set eth0 address aa:bb:cc:dd:ee:ff
Then, the address 12:34:56:78:90:ab might be deleted instead of
ee:ff:12:34:56:78, the original mac address of eth0.

Address this issue by introducing a new flag, added_by_user, to struct
net_bridge_fdb_entry.

Note that br_fdb_delete_by_port() has to set added_by_user to 0 in cases
like:
  ip link set eth0 address 12:34:56:78:90:ab
  ip link set eth1 address aa:bb:cc:dd:ee:ff
  brctl addif br0 eth0
  bridge fdb add aa:bb:cc:dd:ee:ff dev eth0 master
  brctl addif br0 eth1
  brctl delif br0 eth0
In this case, kernel should delete the user-added entry aa:bb:cc:dd:ee:ff,
but it also should have been added by "brctl addif br0 eth1" originally,
so we don't delete it and treat it a new kernel-created entry.

	Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit a5642ab4744bc8c5a8c7ce7c6e30c01bd6bbc691)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_private.h
diff --cc net/bridge/br_private.h
index 10b5654d52ef,939a59e15036..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -385,71 -368,55 +386,92 @@@ static inline void br_netpoll_disable(s
  #endif
  
  /* br_fdb.c */
++<<<<<<< HEAD
 +extern int br_fdb_init(void);
 +extern void br_fdb_fini(void);
 +extern void br_fdb_flush(struct net_bridge *br);
 +extern void br_fdb_changeaddr(struct net_bridge_port *p,
 +			      const unsigned char *newaddr);
 +extern void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
 +extern void br_fdb_cleanup(unsigned long arg);
 +extern void br_fdb_delete_by_port(struct net_bridge *br,
 +				  const struct net_bridge_port *p, int do_all);
 +extern struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
 +						 const unsigned char *addr,
 +						 __u16 vid);
 +extern int br_fdb_test_addr(struct net_device *dev, unsigned char *addr);
 +extern int br_fdb_fillbuf(struct net_bridge *br, void *buf,
 +			  unsigned long count, unsigned long off);
 +extern int br_fdb_insert(struct net_bridge *br,
 +			 struct net_bridge_port *source,
 +			 const unsigned char *addr,
 +			 u16 vid);
 +extern void br_fdb_update(struct net_bridge *br,
 +			  struct net_bridge_port *source,
 +			  const unsigned char *addr,
 +			  u16 vid);
 +extern int fdb_delete_by_addr(struct net_bridge *br, const u8 *addr, u16 vid);
++=======
+ int br_fdb_init(void);
+ void br_fdb_fini(void);
+ void br_fdb_flush(struct net_bridge *br);
+ void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr);
+ void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
+ void br_fdb_cleanup(unsigned long arg);
+ void br_fdb_delete_by_port(struct net_bridge *br,
+ 			   const struct net_bridge_port *p, int do_all);
+ struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
+ 					  const unsigned char *addr, __u16 vid);
+ int br_fdb_test_addr(struct net_device *dev, unsigned char *addr);
+ int br_fdb_fillbuf(struct net_bridge *br, void *buf, unsigned long count,
+ 		   unsigned long off);
+ int br_fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
+ 		  const unsigned char *addr, u16 vid);
+ void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
+ 		   const unsigned char *addr, u16 vid, bool added_by_user);
+ int fdb_delete_by_addr(struct net_bridge *br, const u8 *addr, u16 vid);
 -
 -int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 -		  struct net_device *dev, const unsigned char *addr);
 -int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[], struct net_device *dev,
 -	       const unsigned char *addr, u16 nlh_flags);
 -int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,
 -		struct net_device *dev, int idx);
++>>>>>>> a5642ab4744b (bridge: Fix the way to find old local fdb entries in br_fdb_changeaddr)
 +
 +extern int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 +			 struct net_device *dev,
 +			 const unsigned char *addr);
 +extern int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[],
 +		      struct net_device *dev,
 +		      const unsigned char *addr,
 +		      u16 nlh_flags);
 +extern int br_fdb_dump(struct sk_buff *skb,
 +		       struct netlink_callback *cb,
 +		       struct net_device *dev,
 +		       int idx);
  
  /* br_forward.c */
 -void br_deliver(const struct net_bridge_port *to, struct sk_buff *skb);
 -int br_dev_queue_push_xmit(struct sk_buff *skb);
 -void br_forward(const struct net_bridge_port *to,
 +extern void br_deliver(const struct net_bridge_port *to,
 +		struct sk_buff *skb);
 +extern int br_dev_queue_push_xmit(struct sk_buff *skb);
 +extern void br_forward(const struct net_bridge_port *to,
  		struct sk_buff *skb, struct sk_buff *skb0);
 -int br_forward_finish(struct sk_buff *skb);
 -void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb, bool unicast);
 -void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
 -		      struct sk_buff *skb2, bool unicast);
 +extern int br_forward_finish(struct sk_buff *skb);
 +extern void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb,
 +			     bool unicast);
 +extern void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
 +			     struct sk_buff *skb2, bool unicast);
  
  /* br_if.c */
 -void br_port_carrier_check(struct net_bridge_port *p);
 -int br_add_bridge(struct net *net, const char *name);
 -int br_del_bridge(struct net *net, const char *name);
 -int br_add_if(struct net_bridge *br, struct net_device *dev);
 -int br_del_if(struct net_bridge *br, struct net_device *dev);
 -int br_min_mtu(const struct net_bridge *br);
 -netdev_features_t br_features_recompute(struct net_bridge *br,
 -					netdev_features_t features);
 +extern void br_port_carrier_check(struct net_bridge_port *p);
 +extern int br_add_bridge(struct net *net, const char *name);
 +extern int br_del_bridge(struct net *net, const char *name);
 +extern void br_net_exit(struct net *net);
 +extern int br_add_if(struct net_bridge *br,
 +	      struct net_device *dev);
 +extern int br_del_if(struct net_bridge *br,
 +	      struct net_device *dev);
 +extern int br_min_mtu(const struct net_bridge *br);
 +extern netdev_features_t br_features_recompute(struct net_bridge *br,
 +	netdev_features_t features);
  
  /* br_input.c */
 -int br_handle_frame_finish(struct sk_buff *skb);
 -rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
 +extern int br_handle_frame_finish(struct sk_buff *skb);
 +extern rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
  
  static inline bool br_rx_handler_check_rcu(const struct net_device *dev)
  {
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
index 8e14532d83db..2fd8d4909f6e 100644
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -152,7 +152,7 @@ void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr)
 			struct net_bridge_fdb_entry *f;
 
 			f = hlist_entry(h, struct net_bridge_fdb_entry, hlist);
-			if (f->dst == p && f->is_local) {
+			if (f->dst == p && f->is_local && !f->added_by_user) {
 				/* maybe another port has same hw addr? */
 				struct net_bridge_port *op;
 				u16 vid = f->vlan_id;
@@ -295,6 +295,7 @@ void br_fdb_delete_by_port(struct net_bridge *br,
 					    ether_addr_equal(op->dev->dev_addr,
 							     f->addr.addr)) {
 						f->dst = op;
+						f->added_by_user = 0;
 						goto skip_delete;
 					}
 				}
@@ -445,6 +446,7 @@ static struct net_bridge_fdb_entry *fdb_create(struct hlist_head *head,
 		fdb->vlan_id = vid;
 		fdb->is_local = 0;
 		fdb->is_static = 0;
+		fdb->added_by_user = 0;
 		fdb->updated = fdb->used = jiffies;
 		hlist_add_head_rcu(&fdb->hlist, head);
 	}
@@ -496,7 +498,7 @@ int br_fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
 }
 
 void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
-		   const unsigned char *addr, u16 vid)
+		   const unsigned char *addr, u16 vid, bool added_by_user)
 {
 	struct hlist_head *head = &br->hash[br_mac_hash(addr, vid)];
 	struct net_bridge_fdb_entry *fdb;
@@ -522,13 +524,18 @@ void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
 			/* fastpath: update of existing entry */
 			fdb->dst = source;
 			fdb->updated = jiffies;
+			if (unlikely(added_by_user))
+				fdb->added_by_user = 1;
 		}
 	} else {
 		spin_lock(&br->hash_lock);
 		if (likely(!fdb_find(head, addr, vid))) {
 			fdb = fdb_create(head, source, addr, vid);
-			if (fdb)
+			if (fdb) {
+				if (unlikely(added_by_user))
+					fdb->added_by_user = 1;
 				fdb_notify(br, fdb, RTM_NEWNEIGH);
+			}
 		}
 		/* else  we lose race and someone else inserts
 		 * it first, don't bother updating
@@ -709,6 +716,7 @@ static int fdb_add_entry(struct net_bridge_port *source, const __u8 *addr,
 
 		modified = true;
 	}
+	fdb->added_by_user = 1;
 
 	fdb->used = jiffies;
 	if (modified) {
@@ -726,7 +734,7 @@ static int __br_fdb_add(struct ndmsg *ndm, struct net_bridge_port *p,
 
 	if (ndm->ndm_flags & NTF_USE) {
 		rcu_read_lock();
-		br_fdb_update(p->br, p, addr, vid);
+		br_fdb_update(p->br, p, addr, vid, true);
 		rcu_read_unlock();
 	} else {
 		spin_lock_bh(&p->br->hash_lock);
diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
index fa29179a5382..ab0ee7d7610f 100644
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@ -77,7 +77,7 @@ int br_handle_frame_finish(struct sk_buff *skb)
 	/* insert into forwarding database after filtering to avoid spoofing */
 	br = p->br;
 	if (p->flags & BR_LEARNING)
-		br_fdb_update(br, p, eth_hdr(skb)->h_source, vid);
+		br_fdb_update(br, p, eth_hdr(skb)->h_source, vid, false);
 
 	if (!is_broadcast_ether_addr(dest) && is_multicast_ether_addr(dest) &&
 	    br_multicast_rcv(br, p, skb, vid))
@@ -148,7 +148,7 @@ static int br_handle_local_finish(struct sk_buff *skb)
 
 	br_vlan_get_tag(skb, &vid);
 	if (p->flags & BR_LEARNING)
-		br_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid);
+		br_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid, false);
 	return 0;	 /* process further */
 }
 
* Unmerged path net/bridge/br_private.h
