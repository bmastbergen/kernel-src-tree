cpufreq: don't call cpufreq_update_policy() on CPU addition

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] don't call cpufreq_update_policy() on CPU addition (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 91.74%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 1c0ca90207d61e4868043b5bbbbd7cc0bb1ac974
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/1c0ca902.failed

cpufreq_update_policy() is called from two places currently. From a
workqueue handled queued from cpufreq_bp_resume() for boot CPU and
from cpufreq_cpu_callback() whenever a CPU is added.

The first one makes sure that boot CPU is running on the frequency
present in policy->cpu. But we don't really need a call from
cpufreq_cpu_callback(), because we always call cpufreq_driver->init()
(which will set policy->cur correctly) whenever first CPU of any
policy is added back. And so every policy structure is guaranteed to
have the right frequency in policy->cur.

	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 1c0ca90207d61e4868043b5bbbbd7cc0bb1ac974)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index c8bc717e8458,c755b5fe317c..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -1967,19 -2167,26 +1967,23 @@@ static int cpufreq_cpu_callback(struct 
  
  	dev = get_cpu_device(cpu);
  	if (dev) {
 -
 -		if (action & CPU_TASKS_FROZEN)
 -			frozen = true;
 -
 -		switch (action & ~CPU_TASKS_FROZEN) {
 +		switch (action) {
  		case CPU_ONLINE:
++<<<<<<< HEAD
 +		case CPU_ONLINE_FROZEN:
 +			cpufreq_add_dev(dev, NULL);
 +			cpufreq_update_policy(cpu);
++=======
+ 			__cpufreq_add_dev(dev, NULL, frozen);
++>>>>>>> 1c0ca90207d6 (cpufreq: don't call cpufreq_update_policy() on CPU addition)
  			break;
 -
  		case CPU_DOWN_PREPARE:
 -			__cpufreq_remove_dev_prepare(dev, NULL, frozen);
 +		case CPU_DOWN_PREPARE_FROZEN:
 +			__cpufreq_remove_dev(dev, NULL);
  			break;
 -
 -		case CPU_POST_DEAD:
 -			__cpufreq_remove_dev_finish(dev, NULL, frozen);
 -			break;
 -
  		case CPU_DOWN_FAILED:
 -			__cpufreq_add_dev(dev, NULL, frozen);
 +		case CPU_DOWN_FAILED_FROZEN:
 +			cpufreq_add_dev(dev, NULL);
  			break;
  		}
  	}
* Unmerged path drivers/cpufreq/cpufreq.c
