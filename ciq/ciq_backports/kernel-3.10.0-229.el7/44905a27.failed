i915: split some DP modesetting code into a separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Dave Airlie <airlied@redhat.com>
commit 44905a27dd01f2bddd96664d0ab7da43a07f4d5a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/44905a27.failed

this is just prep work for mst support.

	Reviewed-by: Todd Previte <tprevite@gmail.com>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 44905a27dd01f2bddd96664d0ab7da43a07f4d5a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_ddi.c
#	drivers/gpu/drm/i915/intel_drv.h
diff --cc drivers/gpu/drm/i915/intel_ddi.c
index a069b5e2a2d2,1aec4257e296..000000000000
--- a/drivers/gpu/drm/i915/intel_ddi.c
+++ b/drivers/gpu/drm/i915/intel_ddi.c
@@@ -267,56 -365,16 +267,69 @@@ void hsw_fdi_link_train(struct drm_crt
  	DRM_ERROR("FDI link training failed!\n");
  }
  
++<<<<<<< HEAD
 +static void intel_ddi_mode_set(struct intel_encoder *encoder)
 +{
 +	struct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);
 +	int port = intel_ddi_get_encoder_port(encoder);
 +	int pipe = crtc->pipe;
 +	int type = encoder->type;
 +	struct drm_display_mode *adjusted_mode = &crtc->config.adjusted_mode;
 +
 +	DRM_DEBUG_KMS("Preparing DDI mode on port %c, pipe %c\n",
 +		      port_name(port), pipe_name(pipe));
 +
 +	crtc->eld_vld = false;
 +	if (type == INTEL_OUTPUT_DISPLAYPORT || type == INTEL_OUTPUT_EDP) {
 +		struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
 +		struct intel_digital_port *intel_dig_port =
 +			enc_to_dig_port(&encoder->base);
 +
 +		intel_dp->DP = intel_dig_port->saved_port_bits |
 +			       DDI_BUF_CTL_ENABLE | DDI_BUF_EMP_400MV_0DB_HSW;
 +		intel_dp->DP |= DDI_PORT_WIDTH(intel_dp->lane_count);
 +
 +		if (intel_dp->has_audio) {
 +			DRM_DEBUG_DRIVER("DP audio on pipe %c on DDI\n",
 +					 pipe_name(crtc->pipe));
 +
 +			/* write eld */
 +			DRM_DEBUG_DRIVER("DP audio: write eld information\n");
 +			intel_write_eld(&encoder->base, adjusted_mode);
 +		}
 +
 +		intel_dp_init_link_config(intel_dp);
 +
 +	} else if (type == INTEL_OUTPUT_HDMI) {
 +		struct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(&encoder->base);
 +
 +		if (intel_hdmi->has_audio) {
 +			/* Proper support for digital audio needs a new logic
 +			 * and a new set of registers, so we leave it for future
 +			 * patch bombing.
 +			 */
 +			DRM_DEBUG_DRIVER("HDMI audio on pipe %c on DDI\n",
 +					 pipe_name(crtc->pipe));
 +
 +			/* write eld */
 +			DRM_DEBUG_DRIVER("HDMI audio: write eld information\n");
 +			intel_write_eld(&encoder->base, adjusted_mode);
 +		}
 +
 +		intel_hdmi->set_infoframes(&encoder->base, adjusted_mode);
 +	}
++=======
+ void intel_ddi_init_dp_buf_reg(struct intel_encoder *encoder)
+ {
+ 	struct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);
+ 	struct intel_digital_port *intel_dig_port =
+ 		enc_to_dig_port(&encoder->base);
+ 
+ 	intel_dp->DP = intel_dig_port->saved_port_bits |
+ 		DDI_BUF_CTL_ENABLE | DDI_BUF_EMP_400MV_0DB_HSW;
+ 	intel_dp->DP |= DDI_PORT_WIDTH(intel_dp->lane_count);
+ 
++>>>>>>> 44905a27dd01 (i915: split some DP modesetting code into a separate function)
  }
  
  static struct intel_encoder *
@@@ -1029,6 -1027,8 +1042,11 @@@ static void intel_ddi_pre_enable(struc
  
  	if (type == INTEL_OUTPUT_DISPLAYPORT || type == INTEL_OUTPUT_EDP) {
  		struct intel_dp *intel_dp = enc_to_intel_dp(encoder);
++<<<<<<< HEAD
++=======
+ 
+ 		intel_ddi_init_dp_buf_reg(intel_encoder);
++>>>>>>> 44905a27dd01 (i915: split some DP modesetting code into a separate function)
  
  		intel_dp_sink_dpms(intel_dp, DRM_MODE_DPMS_ON);
  		intel_dp_start_link_train(intel_dp);
diff --cc drivers/gpu/drm/i915/intel_drv.h
index 7f2b384ac939,40086e1a4ee3..000000000000
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@@ -616,73 -674,129 +616,161 @@@ hdmi_to_dig_port(struct intel_hdmi *int
  	return container_of(intel_hdmi, struct intel_digital_port, hdmi);
  }
  
++<<<<<<< HEAD
++=======
+ 
+ /* i915_irq.c */
+ bool intel_set_cpu_fifo_underrun_reporting(struct drm_device *dev,
+ 					   enum pipe pipe, bool enable);
+ bool intel_set_pch_fifo_underrun_reporting(struct drm_device *dev,
+ 					   enum transcoder pch_transcoder,
+ 					   bool enable);
+ void ilk_enable_gt_irq(struct drm_i915_private *dev_priv, uint32_t mask);
+ void ilk_disable_gt_irq(struct drm_i915_private *dev_priv, uint32_t mask);
+ void snb_enable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask);
+ void snb_disable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask);
+ void bdw_enable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask);
+ void bdw_disable_pm_irq(struct drm_i915_private *dev_priv, uint32_t mask);
+ void intel_runtime_pm_disable_interrupts(struct drm_device *dev);
+ void intel_runtime_pm_restore_interrupts(struct drm_device *dev);
+ int intel_get_crtc_scanline(struct intel_crtc *crtc);
+ void i9xx_check_fifo_underruns(struct drm_device *dev);
+ 
+ 
+ /* intel_crt.c */
+ void intel_crt_init(struct drm_device *dev);
+ 
+ 
+ /* intel_ddi.c */
+ void intel_prepare_ddi(struct drm_device *dev);
+ void hsw_fdi_link_train(struct drm_crtc *crtc);
+ void intel_ddi_init(struct drm_device *dev, enum port port);
+ enum port intel_ddi_get_encoder_port(struct intel_encoder *intel_encoder);
+ bool intel_ddi_get_hw_state(struct intel_encoder *encoder, enum pipe *pipe);
+ int intel_ddi_get_cdclk_freq(struct drm_i915_private *dev_priv);
+ void intel_ddi_pll_init(struct drm_device *dev);
+ void intel_ddi_enable_transcoder_func(struct drm_crtc *crtc);
+ void intel_ddi_disable_transcoder_func(struct drm_i915_private *dev_priv,
+ 				       enum transcoder cpu_transcoder);
+ void intel_ddi_enable_pipe_clock(struct intel_crtc *intel_crtc);
+ void intel_ddi_disable_pipe_clock(struct intel_crtc *intel_crtc);
+ bool intel_ddi_pll_select(struct intel_crtc *crtc);
+ void intel_ddi_set_pipe_settings(struct drm_crtc *crtc);
+ void intel_ddi_prepare_link_retrain(struct drm_encoder *encoder);
+ bool intel_ddi_connector_get_hw_state(struct intel_connector *intel_connector);
+ void intel_ddi_fdi_disable(struct drm_crtc *crtc);
+ void intel_ddi_get_config(struct intel_encoder *encoder,
+ 			  struct intel_crtc_config *pipe_config);
+ 
+ void intel_ddi_init_dp_buf_reg(struct intel_encoder *encoder);
+ 
+ /* intel_display.c */
+ const char *intel_output_name(int output);
+ bool intel_has_pending_fb_unpin(struct drm_device *dev);
+ int intel_pch_rawclk(struct drm_device *dev);
+ void intel_mark_busy(struct drm_device *dev);
+ void intel_fb_obj_invalidate(struct drm_i915_gem_object *obj,
+ 			     struct intel_engine_cs *ring);
+ void intel_frontbuffer_flip_prepare(struct drm_device *dev,
+ 				    unsigned frontbuffer_bits);
+ void intel_frontbuffer_flip_complete(struct drm_device *dev,
+ 				     unsigned frontbuffer_bits);
+ void intel_frontbuffer_flush(struct drm_device *dev,
+ 			     unsigned frontbuffer_bits);
+ /**
+  * intel_frontbuffer_flip - prepare frontbuffer flip
+  * @dev: DRM device
+  * @frontbuffer_bits: frontbuffer plane tracking bits
+  *
+  * This function gets called after scheduling a flip on @obj. This is for
+  * synchronous plane updates which will happen on the next vblank and which will
+  * not get delayed by pending gpu rendering.
+  *
+  * Can be called without any locks held.
+  */
+ static inline
+ void intel_frontbuffer_flip(struct drm_device *dev,
+ 			    unsigned frontbuffer_bits)
+ {
+ 	intel_frontbuffer_flush(dev, frontbuffer_bits);
+ }
+ 
+ void intel_fb_obj_flush(struct drm_i915_gem_object *obj, bool retire);
+ void intel_mark_idle(struct drm_device *dev);
+ void intel_crtc_restore_mode(struct drm_crtc *crtc);
+ void intel_crtc_update_dpms(struct drm_crtc *crtc);
+ void intel_encoder_destroy(struct drm_encoder *encoder);
+ void intel_connector_dpms(struct drm_connector *, int mode);
+ bool intel_connector_get_hw_state(struct intel_connector *connector);
+ void intel_modeset_check_state(struct drm_device *dev);
++>>>>>>> 44905a27dd01 (i915: split some DP modesetting code into a separate function)
  bool ibx_digital_port_connected(struct drm_i915_private *dev_priv,
  				struct intel_digital_port *port);
 -void intel_connector_attach_encoder(struct intel_connector *connector,
 -				    struct intel_encoder *encoder);
 -struct drm_encoder *intel_best_encoder(struct drm_connector *connector);
 -struct drm_display_mode *intel_crtc_mode_get(struct drm_device *dev,
 -					     struct drm_crtc *crtc);
 -enum pipe intel_get_pipe_from_connector(struct intel_connector *connector);
 +
 +extern void intel_connector_attach_encoder(struct intel_connector *connector,
 +					   struct intel_encoder *encoder);
 +extern struct drm_encoder *intel_best_encoder(struct drm_connector *connector);
 +
 +extern struct drm_display_mode *intel_crtc_mode_get(struct drm_device *dev,
 +						    struct drm_crtc *crtc);
  int intel_get_pipe_from_crtc_id(struct drm_device *dev, void *data,
  				struct drm_file *file_priv);
 -enum transcoder intel_pipe_to_cpu_transcoder(struct drm_i915_private *dev_priv,
 -					     enum pipe pipe);
 -void intel_wait_for_vblank(struct drm_device *dev, int pipe);
 -void intel_wait_for_pipe_off(struct drm_device *dev, int pipe);
 -int ironlake_get_lanes_required(int target_clock, int link_bw, int bpp);
 -void vlv_wait_port_ready(struct drm_i915_private *dev_priv,
 -			 struct intel_digital_port *dport);
 -bool intel_get_load_detect_pipe(struct drm_connector *connector,
 -				struct drm_display_mode *mode,
 -				struct intel_load_detect_pipe *old,
 -				struct drm_modeset_acquire_ctx *ctx);
 -void intel_release_load_detect_pipe(struct drm_connector *connector,
 -				    struct intel_load_detect_pipe *old,
 -				    struct drm_modeset_acquire_ctx *ctx);
 -int intel_pin_and_fence_fb_obj(struct drm_device *dev,
 -			       struct drm_i915_gem_object *obj,
 -			       struct intel_engine_cs *pipelined);
 -void intel_unpin_fb_obj(struct drm_i915_gem_object *obj);
 -struct drm_framebuffer *
 -__intel_framebuffer_create(struct drm_device *dev,
 -			   struct drm_mode_fb_cmd2 *mode_cmd,
 -			   struct drm_i915_gem_object *obj);
 -void intel_prepare_page_flip(struct drm_device *dev, int plane);
 -void intel_finish_page_flip(struct drm_device *dev, int pipe);
 -void intel_finish_page_flip_plane(struct drm_device *dev, int plane);
 -
 -/* shared dpll functions */
 -struct intel_shared_dpll *intel_crtc_to_shared_dpll(struct intel_crtc *crtc);
 +extern enum transcoder
 +intel_pipe_to_cpu_transcoder(struct drm_i915_private *dev_priv,
 +			     enum pipe pipe);
 +extern void intel_wait_for_vblank(struct drm_device *dev, int pipe);
 +extern void intel_wait_for_pipe_off(struct drm_device *dev, int pipe);
 +extern int ironlake_get_lanes_required(int target_clock, int link_bw, int bpp);
 +extern void vlv_wait_port_ready(struct drm_i915_private *dev_priv, int port);
 +
 +struct intel_load_detect_pipe {
 +	struct drm_framebuffer *release_fb;
 +	bool load_detect_temp;
 +	int dpms_mode;
 +};
 +extern bool intel_get_load_detect_pipe(struct drm_connector *connector,
 +				       struct drm_display_mode *mode,
 +				       struct intel_load_detect_pipe *old);
 +extern void intel_release_load_detect_pipe(struct drm_connector *connector,
 +					   struct intel_load_detect_pipe *old);
 +
 +extern void intel_crtc_fb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,
 +				    u16 blue, int regno);
 +extern void intel_crtc_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,
 +				    u16 *blue, int regno);
 +
 +extern int intel_pin_and_fence_fb_obj(struct drm_device *dev,
 +				      struct drm_i915_gem_object *obj,
 +				      struct intel_ring_buffer *pipelined);
 +extern void intel_unpin_fb_obj(struct drm_i915_gem_object *obj);
 +
 +extern int intel_framebuffer_init(struct drm_device *dev,
 +				  struct intel_framebuffer *ifb,
 +				  struct drm_mode_fb_cmd2 *mode_cmd,
 +				  struct drm_i915_gem_object *obj);
 +extern void intel_framebuffer_fini(struct intel_framebuffer *fb);
 +extern int intel_fbdev_init(struct drm_device *dev);
 +extern void intel_fbdev_initial_config(struct drm_device *dev);
 +extern void intel_fbdev_fini(struct drm_device *dev);
 +extern void intel_fbdev_set_suspend(struct drm_device *dev, int state);
 +extern void intel_prepare_page_flip(struct drm_device *dev, int plane);
 +extern void intel_finish_page_flip(struct drm_device *dev, int pipe);
 +extern void intel_finish_page_flip_plane(struct drm_device *dev, int plane);
 +
 +extern void intel_setup_overlay(struct drm_device *dev);
 +extern void intel_cleanup_overlay(struct drm_device *dev);
 +extern int intel_overlay_switch_off(struct intel_overlay *overlay);
 +extern int intel_overlay_put_image(struct drm_device *dev, void *data,
 +				   struct drm_file *file_priv);
 +extern int intel_overlay_attrs(struct drm_device *dev, void *data,
 +			       struct drm_file *file_priv);
 +
 +extern void intel_fb_output_poll_changed(struct drm_device *dev);
 +extern void intel_fb_restore_mode(struct drm_device *dev);
 +
 +struct intel_shared_dpll *
 +intel_crtc_to_shared_dpll(struct intel_crtc *crtc);
 +
  void assert_shared_dpll(struct drm_i915_private *dev_priv,
  			struct intel_shared_dpll *pll,
  			bool state);
* Unmerged path drivers/gpu/drm/i915/intel_ddi.c
* Unmerged path drivers/gpu/drm/i915/intel_drv.h
