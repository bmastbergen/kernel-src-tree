ipv6: remove prune parameter for fib6_clean_all

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Li RongQing <roy.qing.li@gmail.com>
commit 0c3584d58913a72a6b28a976f7c0bfd2afb65237
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0c3584d5.failed

since the prune parameter for fib6_clean_all always is 0, remove it.

	Signed-off-by: Li RongQing <roy.qing.li@gmail.com>
	Acked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 0c3584d58913a72a6b28a976f7c0bfd2afb65237)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/ip6_fib.h
#	net/ipv6/ip6_fib.c
diff --cc include/net/ip6_fib.h
index 665e0cee59bd,aca0c2709fd6..000000000000
--- a/include/net/ip6_fib.h
+++ b/include/net/ip6_fib.h
@@@ -268,48 -268,39 +268,53 @@@ typedef struct rt6_info *(*pol_lookup_t
   *	exported functions
   */
  
 -struct fib6_table *fib6_get_table(struct net *net, u32 id);
 -struct fib6_table *fib6_new_table(struct net *net, u32 id);
 -struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,
 -				   int flags, pol_lookup_t lookup);
 -
 -struct fib6_node *fib6_lookup(struct fib6_node *root,
 -			      const struct in6_addr *daddr,
 -			      const struct in6_addr *saddr);
 -
 -struct fib6_node *fib6_locate(struct fib6_node *root,
 -			      const struct in6_addr *daddr, int dst_len,
 -			      const struct in6_addr *saddr, int src_len);
 -
 +extern struct fib6_table        *fib6_get_table(struct net *net, u32 id);
 +extern struct fib6_table        *fib6_new_table(struct net *net, u32 id);
 +extern struct dst_entry         *fib6_rule_lookup(struct net *net,
 +						  struct flowi6 *fl6, int flags,
 +						  pol_lookup_t lookup);
 +
 +extern struct fib6_node		*fib6_lookup(struct fib6_node *root,
 +					     const struct in6_addr *daddr,
 +					     const struct in6_addr *saddr);
 +
 +struct fib6_node		*fib6_locate(struct fib6_node *root,
 +					     const struct in6_addr *daddr, int dst_len,
 +					     const struct in6_addr *saddr, int src_len);
 +
++<<<<<<< HEAD
 +extern void			fib6_clean_all_ro(struct net *net,
 +					       int (*func)(struct rt6_info *, void *arg),
 +					       int prune, void *arg);
++=======
+ void fib6_clean_all(struct net *net, int (*func)(struct rt6_info *, void *arg),
+ 		    void *arg);
++>>>>>>> 0c3584d58913 (ipv6: remove prune parameter for fib6_clean_all)
  
 -int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info);
 +extern void			fib6_clean_all(struct net *net,
 +					       int (*func)(struct rt6_info *, void *arg),
 +					       int prune, void *arg);
  
 -int fib6_del(struct rt6_info *rt, struct nl_info *info);
 +extern int			fib6_add(struct fib6_node *root,
 +					 struct rt6_info *rt,
 +					 struct nl_info *info);
  
 -void inet6_rt_notify(int event, struct rt6_info *rt, struct nl_info *info);
 +extern int			fib6_del(struct rt6_info *rt,
 +					 struct nl_info *info);
  
 -void fib6_run_gc(unsigned long expires, struct net *net, bool force);
 +extern void			inet6_rt_notify(int event, struct rt6_info *rt,
 +						struct nl_info *info);
  
 -void fib6_gc_cleanup(void);
 +extern void			fib6_run_gc(unsigned long expires,
 +					    struct net *net);
  
 -int fib6_init(void);
 +extern void			fib6_gc_cleanup(void);
  
 -int ipv6_route_open(struct inode *inode, struct file *file);
 +extern int			fib6_init(void);
  
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
 -int fib6_rules_init(void);
 -void fib6_rules_cleanup(void);
 +extern int			fib6_rules_init(void);
 +extern void			fib6_rules_cleanup(void);
  #else
  static inline int               fib6_rules_init(void)
  {
diff --cc net/ipv6/ip6_fib.c
index 9c06ecb6556e,075602fc6b6a..000000000000
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@@ -1529,27 -1529,8 +1529,27 @@@ static void fib6_clean_tree(struct net 
  	fib6_walk(&c.w);
  }
  
 +void fib6_clean_all_ro(struct net *net, int (*func)(struct rt6_info *, void *arg),
 +		    int prune, void *arg)
 +{
 +	struct fib6_table *table;
 +	struct hlist_head *head;
 +	unsigned int h;
 +
 +	rcu_read_lock();
 +	for (h = 0; h < FIB6_TABLE_HASHSZ; h++) {
 +		head = &net->ipv6.fib_table_hash[h];
 +		hlist_for_each_entry_rcu(table, head, tb6_hlist) {
 +			read_lock_bh(&table->tb6_lock);
 +			fib6_clean_tree(net, &table->tb6_root,
 +					func, prune, arg);
 +			read_unlock_bh(&table->tb6_lock);
 +		}
 +	}
 +	rcu_read_unlock();
 +}
  void fib6_clean_all(struct net *net, int (*func)(struct rt6_info *, void *arg),
- 		    int prune, void *arg)
+ 		    void *arg)
  {
  	struct fib6_table *table;
  	struct hlist_head *head;
@@@ -1656,7 -1634,11 +1656,13 @@@ void fib6_run_gc(unsigned long expires
  
  	gc_args.more = icmp6_dst_gc();
  
++<<<<<<< HEAD
 +	fib6_clean_all(net, fib6_age, 0, NULL);
++=======
+ 	fib6_clean_all(net, fib6_age, NULL);
+ 	now = jiffies;
+ 	net->ipv6.ip6_rt_last_gc = now;
++>>>>>>> 0c3584d58913 (ipv6: remove prune parameter for fib6_clean_all)
  
  	if (gc_args.more)
  		mod_timer(&net->ipv6.ip6_fib_timer,
* Unmerged path include/net/ip6_fib.h
* Unmerged path net/ipv6/ip6_fib.c
diff --git a/net/ipv6/route.c b/net/ipv6/route.c
index ef949e4ec57f..814aa6878577 100644
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@ -2248,7 +2248,7 @@ void rt6_remove_prefsrc(struct inet6_ifaddr *ifp)
 		.net = net,
 		.addr = &ifp->addr,
 	};
-	fib6_clean_all(net, fib6_remove_prefsrc, 0, &adni);
+	fib6_clean_all(net, fib6_remove_prefsrc, &adni);
 }
 
 struct arg_dev_net {
@@ -2275,7 +2275,7 @@ void rt6_ifdown(struct net *net, struct net_device *dev)
 		.net = net,
 	};
 
-	fib6_clean_all(net, fib6_ifdown, 0, &adn);
+	fib6_clean_all(net, fib6_ifdown, &adn);
 	icmp6_clean_all(fib6_ifdown, &adn);
 }
 
@@ -2330,7 +2330,7 @@ void rt6_mtu_change(struct net_device *dev, unsigned int mtu)
 		.mtu = mtu,
 	};
 
-	fib6_clean_all(dev_net(dev), rt6_mtu_change_route, 0, &arg);
+	fib6_clean_all(dev_net(dev), rt6_mtu_change_route, &arg);
 }
 
 static const struct nla_policy rtm_ipv6_policy[RTA_MAX+1] = {
