ACPI / hotplug / PCI: Simplify hotplug_event()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Simplify hotplug_event() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 89.16%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit b75cece1a79a6259185442004e040511ed3a7341
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/b75cece1.failed

A few lines of code can be cut from hotplug_event() by defining
and initializing the slot variable at the top of the function,
so do that.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit b75cece1a79a6259185442004e040511ed3a7341)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,d00da68752ea..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -977,13 -809,15 +977,19 @@@ void acpiphp_check_host_bridge(acpi_han
  		pci_unlock_rescan_remove();
  		put_bridge(bridge);
  	}
 -}
  
 -static int acpiphp_disable_and_eject_slot(struct acpiphp_slot *slot);
 +	acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
 +		ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
 +}
  
 -static void hotplug_event(acpi_handle handle, u32 type, void *data)
 +static void _handle_hotplug_event_bridge(struct work_struct *work)
  {
++<<<<<<< HEAD
++=======
+ 	struct acpiphp_context *context = data;
+ 	struct acpiphp_func *func = &context->func;
+ 	struct acpiphp_slot *slot = func->slot;
++>>>>>>> b75cece1a79a (ACPI / hotplug / PCI: Simplify hotplug_event())
  	struct acpiphp_bridge *bridge;
  	char objname[64];
  	struct acpi_buffer buffer = { .length = sizeof(objname),
@@@ -1007,56 -839,52 +1013,81 @@@
  		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
  		pr_debug("%s: re-enumerating slots under %s\n",
  			 __func__, objname);
++<<<<<<< HEAD
 +		acpiphp_check_bridge(bridge);
 +		acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
 +			ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
++=======
+ 		if (bridge)
+ 			acpiphp_check_bridge(bridge);
+ 		else if (!(slot->flags & SLOT_IS_GOING_AWAY))
+ 			enable_slot(slot);
+ 
++>>>>>>> b75cece1a79a (ACPI / hotplug / PCI: Simplify hotplug_event())
  		break;
  
  	case ACPI_NOTIFY_DEVICE_CHECK:
  		/* device check */
  		pr_debug("%s: Device check notify on %s\n", __func__, objname);
++<<<<<<< HEAD
 +		acpiphp_check_bridge(bridge);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_WAKE:
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
++=======
+ 		if (bridge) {
+ 			acpiphp_check_bridge(bridge);
+ 		} else if (!(slot->flags & SLOT_IS_GOING_AWAY)) {
+ 			/*
+ 			 * Check if anything has changed in the slot and rescan
+ 			 * from the parent if that's the case.
+ 			 */
+ 			if (acpiphp_rescan_slot(slot))
+ 				acpiphp_check_bridge(func->parent);
+ 		}
++>>>>>>> b75cece1a79a (ACPI / hotplug / PCI: Simplify hotplug_event())
  		break;
  
  	case ACPI_NOTIFY_EJECT_REQUEST:
  		/* request device eject */
  		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 -		acpiphp_disable_and_eject_slot(slot);
++<<<<<<< HEAD
 +		if ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {
 +			struct acpiphp_slot *slot;
 +			slot = bridge->func->slot;
 +			if (!acpiphp_disable_slot(slot))
 +				acpiphp_eject_slot(slot);
 +		}
  		break;
 -	}
  
 -	pci_unlock_rescan_remove();
 -	if (bridge)
 -		put_bridge(bridge);
 -}
 +	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
 +		printk(KERN_ERR "Device %s cannot be configured due"
 +				" to a frequency mismatch\n", objname);
 +		break;
  
 -static void hotplug_event_work(void *data, u32 type)
 -{
 -	struct acpiphp_context *context = data;
 -	acpi_handle handle = context->adev->handle;
 +	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
 +		printk(KERN_ERR "Device %s cannot be configured due"
 +				" to a bus mode mismatch\n", objname);
 +		break;
  
 -	acpi_scan_lock_acquire();
 +	case ACPI_NOTIFY_POWER_FAULT:
 +		printk(KERN_ERR "Device %s has suffered a power fault\n",
 +				objname);
 +		break;
  
 -	hotplug_event(handle, type, context);
 +	default:
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
++=======
++		acpiphp_disable_and_eject_slot(slot);
++>>>>>>> b75cece1a79a (ACPI / hotplug / PCI: Simplify hotplug_event())
 +		break;
 +	}
  
  	acpi_scan_lock_release();
 -	acpi_evaluate_hotplug_ost(handle, type, ACPI_OST_SC_SUCCESS, NULL);
 -	put_bridge(context->func.parent);
 +	kfree(hp_work); /* allocated in handle_hotplug_event_bridge */
 +	put_bridge(bridge);
  }
  
  /**
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
