iommu/vt-d: Reduce duplicated code to handle virtual machine domains

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Reduce duplicated code to handle virtual machine domains (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 95.38%
commit-author Jiang Liu <jiang.liu@linux.intel.com>
commit 92d03cc8d0c9bedfa1ab0ac6ee713a1b1f41a901
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/92d03cc8.failed

Reduce duplicated code to handle virtual machine domains, there's no
functionality changes. It also improves code readability.

	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Signed-off-by: Joerg Roedel <joro@8bytes.org>
(cherry picked from commit 92d03cc8d0c9bedfa1ab0ac6ee713a1b1f41a901)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index f51765a48ab1,672477241791..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -1314,11 -1289,7 +1317,15 @@@ static int iommu_init_domains(struct in
  	return 0;
  }
  
++<<<<<<< HEAD
 +
 +static void domain_exit(struct dmar_domain *domain);
 +static void vm_domain_exit(struct dmar_domain *domain);
 +
 +void free_dmar_iommu(struct intel_iommu *iommu)
++=======
+ static void free_dmar_iommu(struct intel_iommu *iommu)
++>>>>>>> 92d03cc8d0c9 (iommu/vt-d: Reduce duplicated code to handle virtual machine domains)
  {
  	struct dmar_domain *domain;
  	int i, count;
@@@ -3942,52 -3850,6 +3905,55 @@@ static int md_domain_init(struct dmar_d
  	return 0;
  }
  
++<<<<<<< HEAD
 +static void iommu_free_vm_domain(struct dmar_domain *domain)
 +{
 +	unsigned long flags;
 +	struct dmar_drhd_unit *drhd;
 +	struct intel_iommu *iommu;
 +	unsigned long i;
 +	unsigned long ndomains;
 +
 +	for_each_drhd_unit(drhd) {
 +		if (drhd->ignored)
 +			continue;
 +		iommu = drhd->iommu;
 +
 +		ndomains = cap_ndoms(iommu->cap);
 +		for_each_set_bit(i, iommu->domain_ids, ndomains) {
 +			if (iommu->domains[i] == domain) {
 +				spin_lock_irqsave(&iommu->lock, flags);
 +				clear_bit(i, iommu->domain_ids);
 +				iommu->domains[i] = NULL;
 +				spin_unlock_irqrestore(&iommu->lock, flags);
 +				break;
 +			}
 +		}
 +	}
 +}
 +
 +static void vm_domain_exit(struct dmar_domain *domain)
 +{
 +	/* Domain 0 is reserved, so dont process it */
 +	if (!domain)
 +		return;
 +
 +	vm_domain_remove_all_dev_info(domain);
 +	/* destroy iovas */
 +	put_iova_domain(&domain->iovad);
 +
 +	/* clear ptes */
 +	dma_pte_clear_range(domain, 0, DOMAIN_MAX_PFN(domain->gaw));
 +
 +	/* free page tables */
 +	dma_pte_free_pagetable(domain, 0, DOMAIN_MAX_PFN(domain->gaw));
 +
 +	iommu_free_vm_domain(domain);
 +	free_domain_mem(domain);
 +}
 +
++=======
++>>>>>>> 92d03cc8d0c9 (iommu/vt-d: Reduce duplicated code to handle virtual machine domains)
  static int intel_iommu_domain_init(struct iommu_domain *domain)
  {
  	struct dmar_domain *dmar_domain;
* Unmerged path drivers/iommu/intel-iommu.c
