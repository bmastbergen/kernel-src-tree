drm/ttm: Use mutex_trylock() to avoid deadlock inside shrinker functions.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] ttm: Use mutex_trylock() to avoid deadlock inside shrinker functions (Rob Clark) [1173317]
Rebuild_FUZZ: 96.45%
commit-author Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
commit 22e71691fd54c637800d10816bbeba9cf132d218
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/22e71691.failed

I can observe that RHEL7 environment stalls with 100% CPU usage when a
certain type of memory pressure is given. While the shrinker functions
are called by shrink_slab() before the OOM killer is triggered, the stall
lasts for many minutes.

One of reasons of this stall is that
ttm_dma_pool_shrink_count()/ttm_dma_pool_shrink_scan() are called and
are blocked at mutex_lock(&_manager->lock). GFP_KERNEL allocation with
_manager->lock held causes someone (including kswapd) to deadlock when
these functions are called due to memory pressure. This patch changes
"mutex_lock();" to "if (!mutex_trylock()) return ...;" in order to
avoid deadlock.

	Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Cc: stable <stable@kernel.org> [3.3+]
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 22e71691fd54c637800d10816bbeba9cf132d218)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/ttm/ttm_page_alloc_dma.c
diff --cc drivers/gpu/drm/ttm/ttm_page_alloc_dma.c
index de1a753b1d56,524cc1a2c1fa..000000000000
--- a/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c
+++ b/drivers/gpu/drm/ttm/ttm_page_alloc_dma.c
@@@ -1011,11 -1009,13 +1011,12 @@@ static int ttm_dma_pool_mm_shrink(struc
  	unsigned pool_offset;
  	unsigned shrink_pages = sc->nr_to_scan;
  	struct device_pools *p;
 -	unsigned long freed = 0;
  
  	if (list_empty(&_manager->pools))
 -		return SHRINK_STOP;
 +		return 0;
  
- 	mutex_lock(&_manager->lock);
+ 	if (!mutex_trylock(&_manager->lock))
+ 		return SHRINK_STOP;
  	if (!_manager->npools)
  		goto out;
  	pool_offset = ++start_pool % _manager->npools;
@@@ -1037,8 -1039,21 +1038,26 @@@
  	}
  out:
  	mutex_unlock(&_manager->lock);
++<<<<<<< HEAD
 +	/* return estimated number of unused pages in pool */
 +	return ttm_dma_pool_get_num_unused_pages();
++=======
+ 	return freed;
+ }
+ 
+ static unsigned long
+ ttm_dma_pool_shrink_count(struct shrinker *shrink, struct shrink_control *sc)
+ {
+ 	struct device_pools *p;
+ 	unsigned long count = 0;
+ 
+ 	if (!mutex_trylock(&_manager->lock))
+ 		return 0;
+ 	list_for_each_entry(p, &_manager->pools, pools)
+ 		count += p->pool->npages_free;
+ 	mutex_unlock(&_manager->lock);
+ 	return count;
++>>>>>>> 22e71691fd54 (drm/ttm: Use mutex_trylock() to avoid deadlock inside shrinker functions.)
  }
  
  static void ttm_dma_pool_mm_shrink_init(struct ttm_pool_manager *manager)
* Unmerged path drivers/gpu/drm/ttm/ttm_page_alloc_dma.c
