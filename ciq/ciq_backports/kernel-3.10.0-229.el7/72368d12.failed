cpufreq: Clean up after a failing light-weight initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Clean up after a failing light-weight initialization (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 92.04%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 72368d122c7479aa6e14fbbd334717b8a0c157a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/72368d12.failed

If cpufreq_policy_restore() returns NULL during system resume,
__cpufreq_add_dev() should just fall back to the full initialization
instead of returning an error, because that may actually make things
work.  Moreover, it should not leave stale fallback data behind after
it has failed to restore a previously existing policy.

This change is based on Viresh Kumar's work.

Fixes: 5302c3fb2e62 ("cpufreq: Perform light-weight init/teardown during suspend/resume")
	Reported-by: Bj√∏rn Mork <bjorn@mork.no>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Cc: 3.12+ <stable@vger.kernel.org> # 3.12+
(cherry picked from commit 72368d122c7479aa6e14fbbd334717b8a0c157a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index 7e78bc2de297,f13a663d1da5..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -964,17 -1016,29 +964,31 @@@ static int cpufreq_add_dev(struct devic
  	read_unlock_irqrestore(&cpufreq_driver_lock, flags);
  #endif
  
++<<<<<<< HEAD
 +	policy = kzalloc(sizeof(struct cpufreq_policy), GFP_KERNEL);
 +	if (!policy)
 +		goto nomem_out;
 +
 +	if (!alloc_cpumask_var(&policy->cpus, GFP_KERNEL))
 +		goto err_free_policy;
++=======
+ 	/*
+ 	 * Restore the saved policy when doing light-weight init and fall back
+ 	 * to the full init if that fails.
+ 	 */
+ 	policy = frozen ? cpufreq_policy_restore(cpu) : NULL;
+ 	if (!policy) {
+ 		frozen = false;
+ 		policy = cpufreq_policy_alloc();
+ 		if (!policy)
+ 			goto nomem_out;
+ 	}
++>>>>>>> 72368d122c74 (cpufreq: Clean up after a failing light-weight initialization)
  
 -	/*
 -	 * In the resume path, since we restore a saved policy, the assignment
 -	 * to policy->cpu is like an update of the existing policy, rather than
 -	 * the creation of a brand new one. So we need to perform this update
 -	 * by invoking update_policy_cpu().
 -	 */
 -	if (frozen && cpu != policy->cpu)
 -		update_policy_cpu(policy, cpu);
 -	else
 -		policy->cpu = cpu;
 +	if (!zalloc_cpumask_var(&policy->related_cpus, GFP_KERNEL))
 +		goto err_free_cpumask;
  
 +	policy->cpu = cpu;
  	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
  	cpumask_copy(policy->cpus, cpumask_of(cpu));
  
@@@ -1057,14 -1120,16 +1071,24 @@@ err_get_freq
  	if (cpufreq_driver->exit)
  		cpufreq_driver->exit(policy);
  err_set_policy_cpu:
++<<<<<<< HEAD
 +	per_cpu(cpufreq_policy_cpu, cpu) = -1;
 +	free_cpumask_var(policy->related_cpus);
 +err_free_cpumask:
 +	free_cpumask_var(policy->cpus);
 +err_free_policy:
 +	kfree(policy);
++=======
+ 	if (frozen) {
+ 		/* Do not leave stale fallback data behind. */
+ 		per_cpu(cpufreq_cpu_data_fallback, cpu) = NULL;
+ 		cpufreq_policy_put_kobj(policy);
+ 	}
+ 	cpufreq_policy_free(policy);
+ 
++>>>>>>> 72368d122c74 (cpufreq: Clean up after a failing light-weight initialization)
  nomem_out:
  	up_read(&cpufreq_rwsem);
 -
  	return ret;
  }
  
* Unmerged path drivers/cpufreq/cpufreq.c
