rbd: add support for single-major device number allocation scheme

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Ilya Dryomov <ilya.dryomov@inktank.com>
commit 9b60e70b3b6a8e4bc2d1b6d9f858a30e1cec496b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/9b60e70b.failed

Currently each rbd device is allocated its own major number, which
leads to a hard limit of 230-250 images mapped at once.  This commit
adds support for a new single-major device number allocation scheme,
which is hidden behind a new single_major boolean module parameter and
is disabled by default for backwards compatibility reasons.  (Old
userspace cannot correctly unmap images mapped under single-major
scheme and would essentially just unmap a random image, if that.)

$ rbd showmapped
id pool image snap device
0  rbd  b100  -    /dev/rbd0
1  rbd  b101  -    /dev/rbd1
2  rbd  b102  -    /dev/rbd2
3  rbd  b103  -    /dev/rbd3

Old scheme (modprobe rbd):

$ ls -l /dev/rbd*
brw-rw---- 1 root disk 253, 0 Dec 10 12:24 /dev/rbd0
brw-rw---- 1 root disk 252, 0 Dec 10 12:28 /dev/rbd1
brw-rw---- 1 root disk 252, 1 Dec 10 12:28 /dev/rbd1p1
brw-rw---- 1 root disk 252, 2 Dec 10 12:28 /dev/rbd1p2
brw-rw---- 1 root disk 252, 3 Dec 10 12:28 /dev/rbd1p3
brw-rw---- 1 root disk 251, 0 Dec 10 12:28 /dev/rbd2
brw-rw---- 1 root disk 251, 1 Dec 10 12:28 /dev/rbd2p1
brw-rw---- 1 root disk 250, 0 Dec 10 12:24 /dev/rbd3

New scheme (modprobe rbd single_major=Y):

$ ls -l /dev/rbd*
brw-rw---- 1 root disk 253,   0 Dec 10 12:30 /dev/rbd0
brw-rw---- 1 root disk 253, 256 Dec 10 12:30 /dev/rbd1
brw-rw---- 1 root disk 253, 257 Dec 10 12:30 /dev/rbd1p1
brw-rw---- 1 root disk 253, 258 Dec 10 12:30 /dev/rbd1p2
brw-rw---- 1 root disk 253, 259 Dec 10 12:30 /dev/rbd1p3
brw-rw---- 1 root disk 253, 512 Dec 10 12:30 /dev/rbd2
brw-rw---- 1 root disk 253, 513 Dec 10 12:30 /dev/rbd2p1
brw-rw---- 1 root disk 253, 768 Dec 10 12:30 /dev/rbd3

(major 253 was assigned dynamically at module load time)

The new limit is 4096 images mapped at once, and it comes from the fact
that, as before, 256 minor numbers are reserved for each mapping.
(A follow-up commit changes the number of minors reserved and the way
we deal with partitions over that number.)

If single_major is set to true, two new sysfs interfaces show up:
/sys/bus/rbd/{add,remove}_single_major.  These are to be used instead
of /sys/bus/rbd/{add,remove}, which are disabled for backwards
compatibility reasons outlined above.

	Signed-off-by: Ilya Dryomov <ilya.dryomov@inktank.com>
	Reviewed-by: Alex Elder <elder@linaro.org>
	Reviewed-by: Josh Durgin <josh.durgin@inktank.com>
(cherry picked from commit 9b60e70b3b6a8e4bc2d1b6d9f858a30e1cec496b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/rbd.c
diff --cc drivers/block/rbd.c
index d5c35879051c,e5ddcb58e9a2..000000000000
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@@ -400,15 -413,49 +413,58 @@@ static ssize_t rbd_remove_single_major(
  static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping);
  static void rbd_spec_put(struct rbd_spec *spec);
  
++<<<<<<< HEAD
 +static struct bus_attribute rbd_bus_attrs[] = {
 +	__ATTR(add, S_IWUSR, NULL, rbd_add),
 +	__ATTR(remove, S_IWUSR, NULL, rbd_remove),
 +	__ATTR_NULL
 +};
 +
++=======
+ static int rbd_dev_id_to_minor(int dev_id)
+ {
+ 	return dev_id << RBD_PART_SHIFT;
+ }
+ 
+ static int minor_to_rbd_dev_id(int minor)
+ {
+ 	return minor >> RBD_PART_SHIFT;
+ }
+ 
+ static BUS_ATTR(add, S_IWUSR, NULL, rbd_add);
+ static BUS_ATTR(remove, S_IWUSR, NULL, rbd_remove);
+ static BUS_ATTR(add_single_major, S_IWUSR, NULL, rbd_add_single_major);
+ static BUS_ATTR(remove_single_major, S_IWUSR, NULL, rbd_remove_single_major);
+ 
+ static struct attribute *rbd_bus_attrs[] = {
+ 	&bus_attr_add.attr,
+ 	&bus_attr_remove.attr,
+ 	&bus_attr_add_single_major.attr,
+ 	&bus_attr_remove_single_major.attr,
+ 	NULL,
+ };
+ 
+ static umode_t rbd_bus_is_visible(struct kobject *kobj,
+ 				  struct attribute *attr, int index)
+ {
+ 	if (!single_major &&
+ 	    (attr == &bus_attr_add_single_major.attr ||
+ 	     attr == &bus_attr_remove_single_major.attr))
+ 		return 0;
+ 
+ 	return attr->mode;
+ }
+ 
+ static const struct attribute_group rbd_bus_group = {
+ 	.attrs = rbd_bus_attrs,
+ 	.is_visible = rbd_bus_is_visible,
+ };
+ __ATTRIBUTE_GROUPS(rbd_bus);
+ 
++>>>>>>> 9b60e70b3b6a (rbd: add support for single-major device number allocation scheme)
  static struct bus_type rbd_bus_type = {
  	.name		= "rbd",
 -	.bus_groups	= rbd_bus_groups,
 +	.bus_attrs	= rbd_bus_attrs,
  };
  
  static void rbd_root_dev_release(struct device *dev)
diff --git a/Documentation/ABI/testing/sysfs-bus-rbd b/Documentation/ABI/testing/sysfs-bus-rbd
index 17b119c692da..501adc2a9ec7 100644
--- a/Documentation/ABI/testing/sysfs-bus-rbd
+++ b/Documentation/ABI/testing/sysfs-bus-rbd
@@ -18,6 +18,28 @@ Removal of a device:
 
   $ echo <dev-id> > /sys/bus/rbd/remove
 
+What:		/sys/bus/rbd/add_single_major
+Date:		December 2013
+KernelVersion:	3.14
+Contact:	Sage Weil <sage@inktank.com>
+Description:	Available only if rbd module is inserted with single_major
+		parameter set to true.
+		Usage is the same as for /sys/bus/rbd/add.  If present,
+		should be used instead of the latter: any attempts to use
+		/sys/bus/rbd/add if /sys/bus/rbd/add_single_major is
+		available will fail for backwards compatibility reasons.
+
+What:		/sys/bus/rbd/remove_single_major
+Date:		December 2013
+KernelVersion:	3.14
+Contact:	Sage Weil <sage@inktank.com>
+Description:	Available only if rbd module is inserted with single_major
+		parameter set to true.
+		Usage is the same as for /sys/bus/rbd/remove.  If present,
+		should be used instead of the latter: any attempts to use
+		/sys/bus/rbd/remove if /sys/bus/rbd/remove_single_major is
+		available will fail for backwards compatibility reasons.
+
 Entries under /sys/bus/rbd/devices/<dev-id>/
 --------------------------------------------
 
* Unmerged path drivers/block/rbd.c
