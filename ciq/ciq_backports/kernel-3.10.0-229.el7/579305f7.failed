iommu/vt-d: Update to use PCI DMA aliases

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Update to use PCI DMA aliases (Myron Stowe) [1136537]
Rebuild_FUZZ: 92.11%
commit-author Alex Williamson <alex.williamson@redhat.com>
commit 579305f75d34429d11e7eeeee9d9e45000a988d3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/579305f7.failed

VT-d code currently makes use of pci_find_upstream_pcie_bridge() in
order to find the topology based alias of a device.  This function has
a few problems.  First, it doesn't check the entire alias path of the
device to the root bus, therefore if a PCIe device is masked upstream,
the wrong result is produced.  Also, it's known to get confused and
give up when it crosses a bridge from a conventional PCI bus to a PCIe
bus that lacks a PCIe capability.  The PCI-core provided DMA alias
support solves both of these problems and additionally adds support
for DMA function quirks allowing VT-d to work with devices like
Marvell and Ricoh with known broken requester IDs.

	Signed-off-by: Alex Williamson <alex.williamson@redhat.com>
	Cc: David Woodhouse <dwmw2@infradead.org>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 579305f75d34429d11e7eeeee9d9e45000a988d3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 45626ce6c39f,f38ec7ab7673..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -1732,80 -1841,68 +1732,135 @@@ static int domain_context_mapping_one(s
  	return 0;
  }
  
+ struct domain_context_mapping_data {
+ 	struct dmar_domain *domain;
+ 	struct intel_iommu *iommu;
+ 	int translation;
+ };
+ 
+ static int domain_context_mapping_cb(struct pci_dev *pdev,
+ 				     u16 alias, void *opaque)
+ {
+ 	struct domain_context_mapping_data *data = opaque;
+ 
+ 	return domain_context_mapping_one(data->domain, data->iommu,
+ 					  PCI_BUS_NUM(alias), alias & 0xff,
+ 					  data->translation);
+ }
+ 
  static int
 -domain_context_mapping(struct dmar_domain *domain, struct device *dev,
 -		       int translation)
 +domain_context_mapping(struct dmar_domain *domain, struct pci_dev *pdev,
 +			int translation)
  {
++<<<<<<< HEAD
 +	int ret;
 +	struct pci_dev *tmp, *parent;
 +
 +	ret = domain_context_mapping_one(domain, pci_domain_nr(pdev->bus),
 +					 pdev->bus->number, pdev->devfn,
 +					 translation);
 +	if (ret)
 +		return ret;
 +
 +	/* dependent device mapping */
 +	tmp = pci_find_upstream_pcie_bridge(pdev);
 +	if (!tmp)
 +		return 0;
 +	/* Secondary interface's bus number and devfn 0 */
 +	parent = pdev->bus->self;
 +	while (parent != tmp) {
 +		ret = domain_context_mapping_one(domain,
 +						 pci_domain_nr(parent->bus),
 +						 parent->bus->number,
 +						 parent->devfn, translation);
 +		if (ret)
 +			return ret;
 +		parent = parent->bus->self;
 +	}
 +	if (pci_is_pcie(tmp)) /* this is a PCIe-to-PCI bridge */
 +		return domain_context_mapping_one(domain,
 +					pci_domain_nr(tmp->subordinate),
 +					tmp->subordinate->number, 0,
 +					translation);
 +	else /* this is a legacy PCI bridge */
 +		return domain_context_mapping_one(domain,
 +						  pci_domain_nr(tmp->bus),
 +						  tmp->bus->number,
 +						  tmp->devfn,
++=======
+ 	struct intel_iommu *iommu;
+ 	u8 bus, devfn;
+ 	struct domain_context_mapping_data data;
+ 
+ 	iommu = device_to_iommu(dev, &bus, &devfn);
+ 	if (!iommu)
+ 		return -ENODEV;
+ 
+ 	if (!dev_is_pci(dev))
+ 		return domain_context_mapping_one(domain, iommu, bus, devfn,
++>>>>>>> 579305f75d34 (iommu/vt-d: Update to use PCI DMA aliases)
  						  translation);
+ 
+ 	data.domain = domain;
+ 	data.iommu = iommu;
+ 	data.translation = translation;
+ 
+ 	return pci_for_each_dma_alias(to_pci_dev(dev),
+ 				      &domain_context_mapping_cb, &data);
+ }
+ 
+ static int domain_context_mapped_cb(struct pci_dev *pdev,
+ 				    u16 alias, void *opaque)
+ {
+ 	struct intel_iommu *iommu = opaque;
+ 
+ 	return !device_context_mapped(iommu, PCI_BUS_NUM(alias), alias & 0xff);
  }
  
 -static int domain_context_mapped(struct device *dev)
 +static int domain_context_mapped(struct pci_dev *pdev)
  {
++<<<<<<< HEAD
 +	int ret;
 +	struct pci_dev *tmp, *parent;
++=======
++>>>>>>> 579305f75d34 (iommu/vt-d: Update to use PCI DMA aliases)
  	struct intel_iommu *iommu;
 -	u8 bus, devfn;
  
 -	iommu = device_to_iommu(dev, &bus, &devfn);
 +	iommu = device_to_iommu(pci_domain_nr(pdev->bus), pdev->bus->number,
 +				pdev->devfn);
  	if (!iommu)
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	ret = device_context_mapped(iommu, pdev->bus->number, pdev->devfn);
 +	if (!ret)
 +		return ret;
 +	/* dependent device mapping */
 +	tmp = pci_find_upstream_pcie_bridge(pdev);
 +	if (!tmp)
 +		return ret;
 +	/* Secondary interface's bus number and devfn 0 */
 +	parent = pdev->bus->self;
 +	while (parent != tmp) {
 +		ret = device_context_mapped(iommu, parent->bus->number,
 +					    parent->devfn);
 +		if (!ret)
 +			return ret;
 +		parent = parent->bus->self;
 +	}
 +	if (pci_is_pcie(tmp))
 +		return device_context_mapped(iommu, tmp->subordinate->number,
 +					     0);
 +	else
 +		return device_context_mapped(iommu, tmp->bus->number,
 +					     tmp->devfn);
++=======
+ 	if (!dev_is_pci(dev))
+ 		return device_context_mapped(iommu, bus, devfn);
+ 
+ 	return !pci_for_each_dma_alias(to_pci_dev(dev),
+ 				       domain_context_mapped_cb, iommu);
++>>>>>>> 579305f75d34 (iommu/vt-d: Update to use PCI DMA aliases)
  }
  
  /* Returns a number of VTD pages, but aligned to MM page size */
@@@ -2063,93 -2178,101 +2118,162 @@@ static int dmar_insert_dev_info(int seg
  	if (found) {
  		spin_unlock_irqrestore(&device_domain_lock, flags);
  		free_devinfo_mem(info);
 -		/* Caller must free the original domain */
 -		return found;
 +		if (found != domain) {
 +			domain_exit(domain);
 +			*domp = found;
 +		}
 +	} else {
 +		list_add(&info->link, &domain->devices);
 +		list_add(&info->global, &device_domain_list);
 +		if (dev)
 +			dev->dev.archdata.iommu = info;
 +		spin_unlock_irqrestore(&device_domain_lock, flags);
  	}
  
 -	list_add(&info->link, &domain->devices);
 -	list_add(&info->global, &device_domain_list);
 -	if (dev)
 -		dev->archdata.iommu = info;
 -	spin_unlock_irqrestore(&device_domain_lock, flags);
 -
 -	return domain;
 +	return 0;
  }
  
+ static int get_last_alias(struct pci_dev *pdev, u16 alias, void *opaque)
+ {
+ 	*(u16 *)opaque = alias;
+ 	return 0;
+ }
+ 
  /* domain is initialized */
 -static struct dmar_domain *get_domain_for_dev(struct device *dev, int gaw)
 +static struct dmar_domain *get_domain_for_dev(struct pci_dev *pdev, int gaw)
  {
++<<<<<<< HEAD
 +	struct dmar_domain *domain, *free = NULL;
 +	struct intel_iommu *iommu;
 +	struct dmar_drhd_unit *drhd;
 +	struct pci_dev *dev_tmp;
 +	unsigned long flags;
 +	int bus = 0, devfn = 0;
 +	int segment;
++=======
+ 	struct dmar_domain *domain, *tmp;
+ 	struct intel_iommu *iommu;
+ 	struct device_domain_info *info;
+ 	u16 dma_alias;
+ 	unsigned long flags;
+ 	u8 bus, devfn;
++>>>>>>> 579305f75d34 (iommu/vt-d: Update to use PCI DMA aliases)
  
 -	domain = find_domain(dev);
 +	domain = find_domain(&pdev->dev);
  	if (domain)
  		return domain;
  
++<<<<<<< HEAD
 +	segment = pci_domain_nr(pdev->bus);
 +
 +	dev_tmp = pci_find_upstream_pcie_bridge(pdev);
 +	if (dev_tmp) {
 +		if (pci_is_pcie(dev_tmp)) {
 +			bus = dev_tmp->subordinate->number;
 +			devfn = 0;
 +		} else {
 +			bus = dev_tmp->bus->number;
 +			devfn = dev_tmp->devfn;
 +		}
 +		spin_lock_irqsave(&device_domain_lock, flags);
 +		domain = dmar_search_domain_by_dev_info(segment, bus, devfn);
 +		spin_unlock_irqrestore(&device_domain_lock, flags);
 +		/* pcie-pci bridge already has a domain, uses it */
 +		if (domain)
 +			goto found_domain;
 +	}
 +
 +	drhd = dmar_find_matched_drhd_unit(pdev);
 +	if (!drhd) {
 +		printk(KERN_ERR "IOMMU: can't find DMAR for device %s\n",
 +			pci_name(pdev));
 +		return NULL;
 +	}
 +	iommu = drhd->iommu;
++=======
+ 	iommu = device_to_iommu(dev, &bus, &devfn);
+ 	if (!iommu)
+ 		return NULL;
+ 
+ 	if (dev_is_pci(dev)) {
+ 		struct pci_dev *pdev = to_pci_dev(dev);
+ 
+ 		pci_for_each_dma_alias(pdev, get_last_alias, &dma_alias);
+ 
+ 		spin_lock_irqsave(&device_domain_lock, flags);
+ 		info = dmar_search_domain_by_dev_info(pci_domain_nr(pdev->bus),
+ 						      PCI_BUS_NUM(dma_alias),
+ 						      dma_alias & 0xff);
+ 		if (info) {
+ 			iommu = info->iommu;
+ 			domain = info->domain;
+ 		}
+ 		spin_unlock_irqrestore(&device_domain_lock, flags);
+ 
+ 		/* DMA alias already has a domain, uses it */
+ 		if (info)
+ 			goto found_domain;
+ 	}
++>>>>>>> 579305f75d34 (iommu/vt-d: Update to use PCI DMA aliases)
  
 -	/* Allocate and initialize new domain for the device */
 -	domain = alloc_domain(false);
 +	/* Allocate and intialize new domain for the device */
 +	domain = alloc_domain();
  	if (!domain)
- 		goto error;
+ 		return NULL;
+ 
  	if (iommu_attach_domain(domain, iommu)) {
  		free_domain_mem(domain);
- 		domain = NULL;
- 		goto error;
+ 		return NULL;
  	}
- 	free = domain;
- 	if (domain_init(domain, gaw))
- 		goto error;
  
++<<<<<<< HEAD
 +	/* register pcie-to-pci device */
 +	if (dev_tmp) {
 +		if (dmar_insert_dev_info(segment, bus, devfn, NULL, &domain))
 +			goto error;
 +		else
 +			free = NULL;
 +	}
 +
 +found_domain:
 +	if (dmar_insert_dev_info(segment, pdev->bus->number, pdev->devfn,
 +				 pdev, &domain) == 0)
 +		return domain;
 +error:
 +	if (free)
 +		domain_exit(free);
 +	/* recheck it here, maybe others set it */
 +	return find_domain(&pdev->dev);
++=======
+ 	if (domain_init(domain, gaw)) {
+ 		domain_exit(domain);
+ 		return NULL;
+ 	}
+ 
+ 	/* register PCI DMA alias device */
+ 	if (dev_is_pci(dev)) {
+ 		tmp = dmar_insert_dev_info(iommu, PCI_BUS_NUM(dma_alias),
+ 					   dma_alias & 0xff, NULL, domain);
+ 
+ 		if (!tmp || tmp != domain) {
+ 			domain_exit(domain);
+ 			domain = tmp;
+ 		}
+ 
+ 		if (!domain)
+ 			return NULL;
+ 	}
+ 
+ found_domain:
+ 	tmp = dmar_insert_dev_info(iommu, bus, devfn, dev, domain);
+ 
+ 	if (!tmp || tmp != domain) {
+ 		domain_exit(domain);
+ 		domain = tmp;
+ 	}
+ 
+ 	return domain;
++>>>>>>> 579305f75d34 (iommu/vt-d: Update to use PCI DMA aliases)
  }
  
  static int iommu_identity_mapping;
@@@ -3849,33 -4023,37 +3973,54 @@@ int __init intel_iommu_init(void
  	intel_iommu_enabled = 1;
  
  	return 0;
 -
 -out_free_reserved_range:
 -	put_iova_domain(&reserved_iova_list);
 -out_free_dmar:
 -	intel_iommu_free_dmars();
 -	up_write(&dmar_global_lock);
 -	iommu_exit_mempool();
 -	return ret;
  }
  
+ static int iommu_detach_dev_cb(struct pci_dev *pdev, u16 alias, void *opaque)
+ {
+ 	struct intel_iommu *iommu = opaque;
+ 
+ 	iommu_detach_dev(iommu, PCI_BUS_NUM(alias), alias & 0xff);
+ 	return 0;
+ }
+ 
+ /*
+  * NB - intel-iommu lacks any sort of reference counting for the users of
+  * dependent devices.  If multiple endpoints have intersecting dependent
+  * devices, unbinding the driver from any one of them will possibly leave
+  * the others unable to operate.
+  */
  static void iommu_detach_dependent_devices(struct intel_iommu *iommu,
 -					   struct device *dev)
 +					   struct pci_dev *pdev)
  {
++<<<<<<< HEAD
 +	struct pci_dev *tmp, *parent;
 +
 +	if (!iommu || !pdev)
 +		return;
 +
 +	/* dependent device detach */
 +	tmp = pci_find_upstream_pcie_bridge(pdev);
 +	/* Secondary interface's bus number and devfn 0 */
 +	if (tmp) {
 +		parent = pdev->bus->self;
 +		while (parent != tmp) {
 +			iommu_detach_dev(iommu, parent->bus->number,
 +					 parent->devfn);
 +			parent = parent->bus->self;
 +		}
 +		if (pci_is_pcie(tmp)) /* this is a PCIe-to-PCI bridge */
 +			iommu_detach_dev(iommu,
 +				tmp->subordinate->number, 0);
 +		else /* this is a legacy PCI bridge */
 +			iommu_detach_dev(iommu, tmp->bus->number,
 +					 tmp->devfn);
 +	}
++=======
+ 	if (!iommu || !dev || !dev_is_pci(dev))
+ 		return;
+ 
+ 	pci_for_each_dma_alias(to_pci_dev(dev), &iommu_detach_dev_cb, iommu);
++>>>>>>> 579305f75d34 (iommu/vt-d: Update to use PCI DMA aliases)
  }
  
  static void domain_remove_one_dev_info(struct dmar_domain *domain,
* Unmerged path drivers/iommu/intel-iommu.c
diff --git a/drivers/iommu/intel_irq_remapping.c b/drivers/iommu/intel_irq_remapping.c
index f3de8df9c220..e43a6b793bd7 100644
--- a/drivers/iommu/intel_irq_remapping.c
+++ b/drivers/iommu/intel_irq_remapping.c
@@ -354,29 +354,52 @@ static int set_hpet_sid(struct irte *irte, u8 id)
 	return 0;
 }
 
+struct set_msi_sid_data {
+	struct pci_dev *pdev;
+	u16 alias;
+};
+
+static int set_msi_sid_cb(struct pci_dev *pdev, u16 alias, void *opaque)
+{
+	struct set_msi_sid_data *data = opaque;
+
+	data->pdev = pdev;
+	data->alias = alias;
+
+	return 0;
+}
+
 static int set_msi_sid(struct irte *irte, struct pci_dev *dev)
 {
-	struct pci_dev *bridge;
+	struct set_msi_sid_data data;
 
 	if (!irte || !dev)
 		return -1;
 
-	/* PCIe device or Root Complex integrated PCI device */
-	if (pci_is_pcie(dev) || !dev->bus->parent) {
-		set_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16,
-			     (dev->bus->number << 8) | dev->devfn);
-		return 0;
-	}
+	pci_for_each_dma_alias(dev, set_msi_sid_cb, &data);
 
-	bridge = pci_find_upstream_pcie_bridge(dev);
-	if (bridge) {
-		if (pci_is_pcie(bridge))/* this is a PCIe-to-PCI/PCIX bridge */
-			set_irte_sid(irte, SVT_VERIFY_BUS, SQ_ALL_16,
-				(bridge->bus->number << 8) | dev->bus->number);
-		else /* this is a legacy PCI bridge */
-			set_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16,
-				(bridge->bus->number << 8) | bridge->devfn);
-	}
+	/*
+	 * DMA alias provides us with a PCI device and alias.  The only case
+	 * where the it will return an alias on a different bus than the
+	 * device is the case of a PCIe-to-PCI bridge, where the alias is for
+	 * the subordinate bus.  In this case we can only verify the bus.
+	 *
+	 * If the alias device is on a different bus than our source device
+	 * then we have a topology based alias, use it.
+	 *
+	 * Otherwise, the alias is for a device DMA quirk and we cannot
+	 * assume that MSI uses the same requester ID.  Therefore use the
+	 * original device.
+	 */
+	if (PCI_BUS_NUM(data.alias) != data.pdev->bus->number)
+		set_irte_sid(irte, SVT_VERIFY_BUS, SQ_ALL_16,
+			     PCI_DEVID(PCI_BUS_NUM(data.alias),
+				       dev->bus->number));
+	else if (data.pdev->bus->number != dev->bus->number)
+		set_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16, data.alias);
+	else
+		set_irte_sid(irte, SVT_VERIFY_SID_SQ, SQ_ALL_16,
+			     PCI_DEVID(dev->bus->number, dev->devfn));
 
 	return 0;
 }
