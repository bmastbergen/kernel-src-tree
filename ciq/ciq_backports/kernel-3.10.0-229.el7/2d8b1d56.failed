ACPI / hotplug / PCI: Get rid of check_sub_bridges()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Get rid of check_sub_bridges() (Myron Stowe) [1114228]
Rebuild_FUZZ: 90.53%
commit-author Mika Westerberg <mika.westerberg@linux.intel.com>
commit 2d8b1d566a5f4874f4d92361f5cdbb50baa396f8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2d8b1d56.failed

Now that acpiphp_check_bridge() always enumerates devices behind the
bridge, there is no need to do that for each sub-bridge anymore like
it is done in the current ACPI-based PCI hotplug (ACPIPHP) code.

Given this we don't need check_sub_bridges() anymore, so drop that
function completely.

This also simplifies the ACPIPHP code a bit.

	Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 2d8b1d566a5f4874f4d92361f5cdbb50baa396f8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index d210006fa4ad,05e463db11de..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -945,25 -788,6 +945,28 @@@ static void acpiphp_sanitize_bus(struc
   * ACPI event handlers
   */
  
++<<<<<<< HEAD
 +static acpi_status
 +check_sub_bridges(acpi_handle handle, u32 lvl, void *context, void **rv)
 +{
 +	struct acpiphp_bridge *bridge;
 +	char objname[64];
 +	struct acpi_buffer buffer = { .length = sizeof(objname),
 +				      .pointer = objname };
 +
 +	bridge = acpiphp_handle_to_bridge(handle);
 +	if (bridge) {
 +		acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 +		pr_debug("%s: re-enumerating slots under %s\n",
 +			__func__, objname);
 +		acpiphp_check_bridge(bridge);
 +		put_bridge(bridge);
 +	}
 +	return AE_OK ;
 +}
 +
++=======
++>>>>>>> 2d8b1d566a5f (ACPI / hotplug / PCI: Get rid of check_sub_bridges())
  void acpiphp_check_host_bridge(acpi_handle handle)
  {
  	struct acpiphp_bridge *bridge;
@@@ -973,13 -797,12 +976,10 @@@
  		acpiphp_check_bridge(bridge);
  		put_bridge(bridge);
  	}
- 
- 	acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
- 		ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
  }
  
 -static void hotplug_event(acpi_handle handle, u32 type, void *data)
 +static void _handle_hotplug_event_bridge(struct work_struct *work)
  {
 -	struct acpiphp_context *context = data;
 -	struct acpiphp_func *func = &context->func;
  	struct acpiphp_bridge *bridge;
  	char objname[64];
  	struct acpi_buffer buffer = { .length = sizeof(objname),
@@@ -1000,12 -820,17 +1000,26 @@@
  	switch (type) {
  	case ACPI_NOTIFY_BUS_CHECK:
  		/* bus re-enumerate */
++<<<<<<< HEAD
 +		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
 +		pr_debug("%s: re-enumerating slots under %s\n",
 +			 __func__, objname);
 +		acpiphp_check_bridge(bridge);
 +		acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
 +			ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
++=======
+ 		dbg("%s: Bus check notify on %s\n", __func__, objname);
+ 		dbg("%s: re-enumerating slots under %s\n", __func__, objname);
+ 		if (bridge) {
+ 			acpiphp_check_bridge(bridge);
+ 		} else {
+ 			struct acpiphp_slot *slot = func->slot;
+ 
+ 			mutex_lock(&slot->crit_sect);
+ 			enable_slot(slot);
+ 			mutex_unlock(&slot->crit_sect);
+ 		}
++>>>>>>> 2d8b1d566a5f (ACPI / hotplug / PCI: Get rid of check_sub_bridges())
  		break;
  
  	case ACPI_NOTIFY_DEVICE_CHECK:
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
