xfrm: revert ipv4 mtu determination to dst_mtu

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Hannes Frederic Sowa <hannes@stressinduktion.org>
commit 5a25cf1e310888eb333f9e034be84a8117111d30
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5a25cf1e.failed

In commit 0ea9d5e3e0e03a63b11392f5613378977dae7eca ("xfrm: introduce
helper for safe determination of mtu") I switched the determination of
ipv4 mtus from dst_mtu to ip_skb_dst_mtu. This was an error because in
case of IP_PMTUDISC_PROBE we fall back to the interface mtu, which is
never correct for ipv4 ipsec.

This patch partly reverts 0ea9d5e3e0e03a63b11392f5613378977dae7eca
("xfrm: introduce helper for safe determination of mtu").

	Cc: Steffen Klassert <steffen.klassert@secunet.com>
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 5a25cf1e310888eb333f9e034be84a8117111d30)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/xfrm.h
diff --cc include/net/xfrm.h
index 92f6eb59b8b5,e823786e7c66..000000000000
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@@ -1724,15 -1723,4 +1723,18 @@@ static inline int xfrm_mark_put(struct 
  	return ret;
  }
  
++<<<<<<< HEAD
 +static inline int xfrm_skb_dst_mtu(struct sk_buff *skb)
 +{
 +	struct sock *sk = skb->sk;
 +
 +	if (sk && sk->sk_family == AF_INET6)
 +		return ip6_skb_dst_mtu(skb);
 +	else if (sk && sk->sk_family == AF_INET)
 +		return ip_skb_dst_mtu(skb);
 +	return dst_mtu(skb_dst(skb));
 +}
 +
++=======
++>>>>>>> 5a25cf1e3108 (xfrm: revert ipv4 mtu determination to dst_mtu)
  #endif	/* _NET_XFRM_H */
* Unmerged path include/net/xfrm.h
diff --git a/net/ipv4/xfrm4_output.c b/net/ipv4/xfrm4_output.c
index cfc614b3088f..5b429bc2fa4f 100644
--- a/net/ipv4/xfrm4_output.c
+++ b/net/ipv4/xfrm4_output.c
@@ -28,7 +28,7 @@ static int xfrm4_tunnel_check_size(struct sk_buff *skb)
 	if (!(ip_hdr(skb)->frag_off & htons(IP_DF)) || skb->local_df)
 		goto out;
 
-	mtu = xfrm_skb_dst_mtu(skb);
+	mtu = dst_mtu(skb_dst(skb));
 	if (skb->len > mtu) {
 		if (skb->sk)
 			ip_local_error(skb->sk, EMSGSIZE, ip_hdr(skb)->daddr,
diff --git a/net/ipv6/xfrm6_output.c b/net/ipv6/xfrm6_output.c
index 2f7ac7476954..6e2aad7cec23 100644
--- a/net/ipv6/xfrm6_output.c
+++ b/net/ipv6/xfrm6_output.c
@@ -136,10 +136,12 @@ static int __xfrm6_output(struct sk_buff *skb)
 {
 	struct dst_entry *dst = skb_dst(skb);
 	struct xfrm_state *x = dst->xfrm;
-	int mtu = xfrm_skb_dst_mtu(skb);
+	int mtu;
 
-	if (mtu < IPV6_MIN_MTU)
-		mtu = IPV6_MIN_MTU;
+	if (skb->protocol == htons(ETH_P_IPV6))
+		mtu = ip6_skb_dst_mtu(skb);
+	else
+		mtu = dst_mtu(skb_dst(skb));
 
 	if (skb->len > mtu && xfrm6_local_dontfrag(skb)) {
 		xfrm6_local_rxpmtu(skb, mtu);
