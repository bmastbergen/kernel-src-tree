iommu/vt-d: Handle RMRRs for non-PCI devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Handle RMRRs for non-PCI devices (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 92.68%
commit-author David Woodhouse <David.Woodhouse@intel.com>
commit 0b9d9753155b9ed72e864592f9bf482a688c3c11
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0b9d9753.failed

Should hopefully never happen (RMRRs are an abomination) but while we're
busy eliminating all the PCI assumptions, we might as well do it.

	Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
(cherry picked from commit 0b9d9753155b9ed72e864592f9bf482a688c3c11)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 144c54a1b81e,7b2b9f321c74..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -2189,7 -2318,7 +2189,11 @@@ static int iommu_prepare_identity_map(s
  	struct dmar_domain *domain;
  	int ret;
  
++<<<<<<< HEAD
 +	domain = get_domain_for_dev(pdev, DEFAULT_DOMAIN_ADDRESS_WIDTH);
++=======
+ 	domain = get_domain_for_dev(dev, DEFAULT_DOMAIN_ADDRESS_WIDTH);
++>>>>>>> 0b9d9753155b (iommu/vt-d: Handle RMRRs for non-PCI devices)
  	if (!domain)
  		return -ENOMEM;
  
@@@ -2233,7 -2362,7 +2237,11 @@@
  		goto error;
  
  	/* context entry init */
++<<<<<<< HEAD
 +	ret = domain_context_mapping(domain, pdev, CONTEXT_TT_MULTI_LEVEL);
++=======
+ 	ret = domain_context_mapping(domain, dev, CONTEXT_TT_MULTI_LEVEL);
++>>>>>>> 0b9d9753155b (iommu/vt-d: Handle RMRRs for non-PCI devices)
  	if (ret)
  		goto error;
  
@@@ -2375,21 -2495,26 +2383,32 @@@ static int domain_add_dev_info(struct d
  	return 0;
  }
  
- static bool device_has_rmrr(struct pci_dev *dev)
+ static bool device_has_rmrr(struct device *dev)
  {
  	struct dmar_rmrr_unit *rmrr;
 -	struct device *tmp;
  	int i;
  
 -	rcu_read_lock();
  	for_each_rmrr_units(rmrr) {
++<<<<<<< HEAD
 +		for (i = 0; i < rmrr->devices_cnt; i++) {
 +			/*
 +			 * Return TRUE if this RMRR contains the device that
 +			 * is passed in.
 +			 */
 +			if (rmrr->devices[i] == dev)
++=======
+ 		/*
+ 		 * Return TRUE if this RMRR contains the device that
+ 		 * is passed in.
+ 		 */
+ 		for_each_active_dev_scope(rmrr->devices,
+ 					  rmrr->devices_cnt, i, tmp)
+ 			if (tmp == dev) {
+ 				rcu_read_unlock();
++>>>>>>> 0b9d9753155b (iommu/vt-d: Handle RMRRs for non-PCI devices)
  				return true;
 -			}
 +		}
  	}
 -	rcu_read_unlock();
  	return false;
  }
  
@@@ -2652,15 -2763,10 +2671,22 @@@ static int __init init_dmars(void
  	 */
  	printk(KERN_INFO "IOMMU: Setting RMRR:\n");
  	for_each_rmrr_units(rmrr) {
++<<<<<<< HEAD
 +		for (i = 0; i < rmrr->devices_cnt; i++) {
 +			pdev = rmrr->devices[i];
 +			/*
 +			 * some BIOS lists non-exist devices in DMAR
 +			 * table.
 +			 */
 +			if (!pdev)
 +				continue;
 +			ret = iommu_prepare_rmrr_dev(rmrr, pdev);
++=======
+ 		/* some BIOS lists non-exist devices in DMAR table. */
+ 		for_each_active_dev_scope(rmrr->devices, rmrr->devices_cnt,
+ 					  i, dev) {
+ 			ret = iommu_prepare_rmrr_dev(rmrr, dev);
++>>>>>>> 0b9d9753155b (iommu/vt-d: Handle RMRRs for non-PCI devices)
  			if (ret)
  				printk(KERN_ERR
  				       "IOMMU: mapping reserved region failed\n");
* Unmerged path drivers/iommu/intel-iommu.c
