X.509: x509_request_asymmetric_keys() doesn't need string length arguments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [crypto] x509: x509_request_asymmetric_keys() doesn't need string length arguments (Vivek Goyal) [1129779]
Rebuild_FUZZ: 99.32%
commit-author David Howells <dhowells@redhat.com>
commit 185de09c6aa9d38ec04e34b2d9a996561963f895
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/185de09c.failed

x509_request_asymmetric_keys() doesn't need the lengths of the NUL-terminated
strings passing in as it can work that out for itself.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
(cherry picked from commit 185de09c6aa9d38ec04e34b2d9a996561963f895)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/asymmetric_keys/x509_public_key.c
diff --cc crypto/asymmetric_keys/x509_public_key.c
index 2fcf47e69b21,4ae982234d78..000000000000
--- a/crypto/asymmetric_keys/x509_public_key.c
+++ b/crypto/asymmetric_keys/x509_public_key.c
@@@ -23,6 -24,73 +23,76 @@@
  #include "public_key.h"
  #include "x509_parser.h"
  
++<<<<<<< HEAD
++=======
+ static bool use_builtin_keys;
+ static char *ca_keyid;
+ 
+ #ifndef MODULE
+ static int __init ca_keys_setup(char *str)
+ {
+ 	if (!str)		/* default system keyring */
+ 		return 1;
+ 
+ 	if (strncmp(str, "id:", 3) == 0)
+ 		ca_keyid = str;	/* owner key 'id:xxxxxx' */
+ 	else if (strcmp(str, "builtin") == 0)
+ 		use_builtin_keys = true;
+ 
+ 	return 1;
+ }
+ __setup("ca_keys=", ca_keys_setup);
+ #endif
+ 
+ /*
+  * Find a key in the given keyring by issuer and authority.
+  */
+ static struct key *x509_request_asymmetric_key(struct key *keyring,
+ 					       const char *signer,
+ 					       const char *authority)
+ {
+ 	key_ref_t key;
+ 	size_t signer_len = strlen(signer), auth_len = strlen(authority);
+ 	char *id;
+ 
+ 	/* Construct an identifier. */
+ 	id = kmalloc(signer_len + 2 + auth_len + 1, GFP_KERNEL);
+ 	if (!id)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	memcpy(id, signer, signer_len);
+ 	id[signer_len + 0] = ':';
+ 	id[signer_len + 1] = ' ';
+ 	memcpy(id + signer_len + 2, authority, auth_len);
+ 	id[signer_len + 2 + auth_len] = 0;
+ 
+ 	pr_debug("Look up: \"%s\"\n", id);
+ 
+ 	key = keyring_search(make_key_ref(keyring, 1),
+ 			     &key_type_asymmetric, id);
+ 	if (IS_ERR(key))
+ 		pr_debug("Request for module key '%s' err %ld\n",
+ 			 id, PTR_ERR(key));
+ 	kfree(id);
+ 
+ 	if (IS_ERR(key)) {
+ 		switch (PTR_ERR(key)) {
+ 			/* Hide some search errors */
+ 		case -EACCES:
+ 		case -ENOTDIR:
+ 		case -EAGAIN:
+ 			return ERR_PTR(-ENOKEY);
+ 		default:
+ 			return ERR_CAST(key);
+ 		}
+ 	}
+ 
+ 	pr_devel("<==%s() = 0 [%x]\n", __func__,
+ 		 key_serial(key_ref_to_ptr(key)));
+ 	return key_ref_to_ptr(key);
+ }
+ 
++>>>>>>> 185de09c6aa9 (X.509: x509_request_asymmetric_keys() doesn't need string length arguments)
  /*
   * Set up the signature parameters in an X.509 certificate.  This involves
   * digesting the signed data and extracting the signature.
@@@ -103,6 -171,38 +173,41 @@@ int x509_check_signature(const struct p
  EXPORT_SYMBOL_GPL(x509_check_signature);
  
  /*
++<<<<<<< HEAD
++=======
+  * Check the new certificate against the ones in the trust keyring.  If one of
+  * those is the signing key and validates the new certificate, then mark the
+  * new certificate as being trusted.
+  *
+  * Return 0 if the new certificate was successfully validated, 1 if we couldn't
+  * find a matching parent certificate in the trusted list and an error if there
+  * is a matching certificate but the signature check fails.
+  */
+ static int x509_validate_trust(struct x509_certificate *cert,
+ 			       struct key *trust_keyring)
+ {
+ 	struct key *key;
+ 	int ret = 1;
+ 
+ 	if (!trust_keyring)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (ca_keyid && !asymmetric_keyid_match(cert->authority, ca_keyid))
+ 		return -EPERM;
+ 
+ 	key = x509_request_asymmetric_key(trust_keyring,
+ 					  cert->issuer, cert->authority);
+ 	if (!IS_ERR(key))  {
+ 		if (!use_builtin_keys
+ 		    || test_bit(KEY_FLAG_BUILTIN, &key->flags))
+ 			ret = x509_check_signature(key->payload.data, cert);
+ 		key_put(key);
+ 	}
+ 	return ret;
+ }
+ 
+ /*
++>>>>>>> 185de09c6aa9 (X.509: x509_request_asymmetric_keys() doesn't need string length arguments)
   * Attempt to parse a data blob for a key as an X509 certificate.
   */
  static int x509_key_preparse(struct key_preparsed_payload *prep)
* Unmerged path crypto/asymmetric_keys/x509_public_key.c
