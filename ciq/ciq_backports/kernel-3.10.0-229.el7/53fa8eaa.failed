perf tools: Add data_fd into dso object

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf: Add data_fd into dso object (Jiri Olsa) [1134356]
Rebuild_FUZZ: 91.67%
commit-author Jiri Olsa <jolsa@kernel.org>
commit 53fa8eaa093ad87eb59379de059e76d735a5de45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/53fa8eaa.failed

Adding data_fd into dso object so we could handle caching
of opened dso file data descriptors coming int next patches.

Adding dso__data_close interface to keep the data_fd updated
when the descriptor is closed.

	Acked-by: Namhyung Kim <namhyung@kernel.org>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Jean Pihet <jean.pihet@linaro.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1401892622-30848-4-git-send-email-jolsa@kernel.org
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
(cherry picked from commit 53fa8eaa093ad87eb59379de059e76d735a5de45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/dso.c
diff --cc tools/perf/util/dso.c
index ffd3d5ede878,5acb4b8b35d7..000000000000
--- a/tools/perf/util/dso.c
+++ b/tools/perf/util/dso.c
@@@ -168,8 -176,13 +176,18 @@@ int dso__data_fd(struct dso *dso, struc
  	};
  	int i = 0;
  
++<<<<<<< HEAD
 +	if (dso->data_type != DSO_BINARY_TYPE__NOT_FOUND)
 +		return open_dso(dso, machine);
++=======
+ 	if (dso->data.fd >= 0)
+ 		return dso->data.fd;
+ 
+ 	if (dso->binary_type != DSO_BINARY_TYPE__NOT_FOUND) {
+ 		dso->data.fd = open_dso(dso, machine);
+ 		return dso->data.fd;
+ 	}
++>>>>>>> 53fa8eaa093a (perf tools: Add data_fd into dso object)
  
  	do {
  		int fd;
@@@ -178,9 -191,9 +196,9 @@@
  
  		fd = open_dso(dso, machine);
  		if (fd >= 0)
- 			return fd;
+ 			return dso->data.fd = fd;
  
 -	} while (dso->binary_type != DSO_BINARY_TYPE__NOT_FOUND);
 +	} while (dso->data_type != DSO_BINARY_TYPE__NOT_FOUND);
  
  	return -EINVAL;
  }
@@@ -475,8 -487,9 +493,9 @@@ struct dso *dso__new(const char *name
  		for (i = 0; i < MAP__NR_TYPES; ++i)
  			dso->symbols[i] = dso->symbol_names[i] = RB_ROOT;
  		dso->data.cache = RB_ROOT;
+ 		dso->data.fd = -1;
  		dso->symtab_type = DSO_BINARY_TYPE__NOT_FOUND;
 -		dso->binary_type = DSO_BINARY_TYPE__NOT_FOUND;
 +		dso->data_type   = DSO_BINARY_TYPE__NOT_FOUND;
  		dso->loaded = 0;
  		dso->rel = 0;
  		dso->sorted_by_name = 0;
@@@ -509,10 -520,10 +528,11 @@@ void dso__delete(struct dso *dso
  		dso->long_name_allocated = false;
  	}
  
+ 	dso__data_close(dso);
  	dso_cache__free(&dso->data.cache);
  	dso__free_a2l(dso);
 -	zfree(&dso->symsrc_filename);
 +	free(dso->symsrc_filename);
 +	dso->symsrc_filename = NULL;
  	free(dso);
  }
  
* Unmerged path tools/perf/util/dso.c
diff --git a/tools/perf/util/dso.h b/tools/perf/util/dso.h
index 433c80284bd6..58ae8951a40a 100644
--- a/tools/perf/util/dso.h
+++ b/tools/perf/util/dso.h
@@ -102,6 +102,7 @@ struct dso {
 	/* dso data file */
 	struct {
 		struct rb_root	 cache;
+		int		 fd;
 	} data;
 
 	char		 name[0];
@@ -137,6 +138,8 @@ int dso__binary_type_file(struct dso *dso, enum dso_binary_type type,
 			  char *root_dir, char *file, size_t size);
 
 int dso__data_fd(struct dso *dso, struct machine *machine);
+void dso__data_close(struct dso *dso);
+
 ssize_t dso__data_read_offset(struct dso *dso, struct machine *machine,
 			      u64 offset, u8 *data, ssize_t size);
 ssize_t dso__data_read_addr(struct dso *dso, struct map *map,
diff --git a/tools/perf/util/unwind.c b/tools/perf/util/unwind.c
index 6c308f43c0ca..7f8814457216 100644
--- a/tools/perf/util/unwind.c
+++ b/tools/perf/util/unwind.c
@@ -267,7 +267,7 @@ static int read_unwind_spec_eh_frame(struct dso *dso, struct machine *machine,
 
 	/* Check the .eh_frame section for unwinding info */
 	offset = elf_section_offset(fd, ".eh_frame_hdr");
-	close(fd);
+	dso__data_close(dso);
 
 	if (offset)
 		ret = unwind_spec_ehframe(dso, machine, offset,
@@ -288,7 +288,7 @@ static int read_unwind_spec_debug_frame(struct dso *dso,
 
 	/* Check the .debug_frame section for unwinding info */
 	*offset = elf_section_offset(fd, ".debug_frame");
-	close(fd);
+	dso__data_close(dso);
 
 	if (*offset)
 		return 0;
