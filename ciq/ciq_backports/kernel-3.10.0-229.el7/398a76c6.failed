KVM: PPC: Add devname:kvm aliases for modules

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/ppc: Add devname:kvm aliases for modules (David Gibson) [1123145 1123133 1123367]
Rebuild_FUZZ: 96.63%
commit-author Alexander Graf <agraf@suse.de>
commit 398a76c677a2612c1b03a8d20fbf116e3778ebec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/398a76c6.failed

Systems that support automatic loading of kernel modules through
device aliases should try and automatically load kvm when /dev/kvm
gets opened.

Add code to support that magic for all PPC kvm targets, even the
ones that don't support modules yet.

	Signed-off-by: Alexander Graf <agraf@suse.de>
(cherry picked from commit 398a76c677a2612c1b03a8d20fbf116e3778ebec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s.c
#	arch/powerpc/kvm/book3s_hv.c
#	arch/powerpc/kvm/book3s_pr.c
diff --cc arch/powerpc/kvm/book3s.c
index be63f63c167b,48cf91bc862f..000000000000
--- a/arch/powerpc/kvm/book3s.c
+++ b/arch/powerpc/kvm/book3s.c
@@@ -679,3 -743,147 +681,150 @@@ void kvmppc_decrementer_func(unsigned l
  	kvmppc_core_queue_dec(vcpu);
  	kvm_vcpu_kick(vcpu);
  }
++<<<<<<< HEAD
++=======
+ 
+ struct kvm_vcpu *kvmppc_core_vcpu_create(struct kvm *kvm, unsigned int id)
+ {
+ 	return kvm->arch.kvm_ops->vcpu_create(kvm, id);
+ }
+ 
+ void kvmppc_core_vcpu_free(struct kvm_vcpu *vcpu)
+ {
+ 	vcpu->kvm->arch.kvm_ops->vcpu_free(vcpu);
+ }
+ 
+ int kvmppc_core_check_requests(struct kvm_vcpu *vcpu)
+ {
+ 	return vcpu->kvm->arch.kvm_ops->check_requests(vcpu);
+ }
+ 
+ int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)
+ {
+ 	return kvm->arch.kvm_ops->get_dirty_log(kvm, log);
+ }
+ 
+ void kvmppc_core_free_memslot(struct kvm *kvm, struct kvm_memory_slot *free,
+ 			      struct kvm_memory_slot *dont)
+ {
+ 	kvm->arch.kvm_ops->free_memslot(free, dont);
+ }
+ 
+ int kvmppc_core_create_memslot(struct kvm *kvm, struct kvm_memory_slot *slot,
+ 			       unsigned long npages)
+ {
+ 	return kvm->arch.kvm_ops->create_memslot(slot, npages);
+ }
+ 
+ void kvmppc_core_flush_memslot(struct kvm *kvm, struct kvm_memory_slot *memslot)
+ {
+ 	kvm->arch.kvm_ops->flush_memslot(kvm, memslot);
+ }
+ 
+ int kvmppc_core_prepare_memory_region(struct kvm *kvm,
+ 				struct kvm_memory_slot *memslot,
+ 				struct kvm_userspace_memory_region *mem)
+ {
+ 	return kvm->arch.kvm_ops->prepare_memory_region(kvm, memslot, mem);
+ }
+ 
+ void kvmppc_core_commit_memory_region(struct kvm *kvm,
+ 				struct kvm_userspace_memory_region *mem,
+ 				const struct kvm_memory_slot *old)
+ {
+ 	kvm->arch.kvm_ops->commit_memory_region(kvm, mem, old);
+ }
+ 
+ int kvm_unmap_hva(struct kvm *kvm, unsigned long hva)
+ {
+ 	return kvm->arch.kvm_ops->unmap_hva(kvm, hva);
+ }
+ EXPORT_SYMBOL_GPL(kvm_unmap_hva);
+ 
+ int kvm_unmap_hva_range(struct kvm *kvm, unsigned long start, unsigned long end)
+ {
+ 	return kvm->arch.kvm_ops->unmap_hva_range(kvm, start, end);
+ }
+ 
+ int kvm_age_hva(struct kvm *kvm, unsigned long hva)
+ {
+ 	return kvm->arch.kvm_ops->age_hva(kvm, hva);
+ }
+ 
+ int kvm_test_age_hva(struct kvm *kvm, unsigned long hva)
+ {
+ 	return kvm->arch.kvm_ops->test_age_hva(kvm, hva);
+ }
+ 
+ void kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte)
+ {
+ 	kvm->arch.kvm_ops->set_spte_hva(kvm, hva, pte);
+ }
+ 
+ void kvmppc_mmu_destroy(struct kvm_vcpu *vcpu)
+ {
+ 	vcpu->kvm->arch.kvm_ops->mmu_destroy(vcpu);
+ }
+ 
+ int kvmppc_core_init_vm(struct kvm *kvm)
+ {
+ 
+ #ifdef CONFIG_PPC64
+ 	INIT_LIST_HEAD(&kvm->arch.spapr_tce_tables);
+ 	INIT_LIST_HEAD(&kvm->arch.rtas_tokens);
+ #endif
+ 
+ 	return kvm->arch.kvm_ops->init_vm(kvm);
+ }
+ 
+ void kvmppc_core_destroy_vm(struct kvm *kvm)
+ {
+ 	kvm->arch.kvm_ops->destroy_vm(kvm);
+ 
+ #ifdef CONFIG_PPC64
+ 	kvmppc_rtas_tokens_free(kvm);
+ 	WARN_ON(!list_empty(&kvm->arch.spapr_tce_tables));
+ #endif
+ }
+ 
+ int kvmppc_core_check_processor_compat(void)
+ {
+ 	/*
+ 	 * We always return 0 for book3s. We check
+ 	 * for compatability while loading the HV
+ 	 * or PR module
+ 	 */
+ 	return 0;
+ }
+ 
+ static int kvmppc_book3s_init(void)
+ {
+ 	int r;
+ 
+ 	r = kvm_init(NULL, sizeof(struct kvm_vcpu), 0, THIS_MODULE);
+ 	if (r)
+ 		return r;
+ #ifdef CONFIG_KVM_BOOK3S_32
+ 	r = kvmppc_book3s_init_pr();
+ #endif
+ 	return r;
+ 
+ }
+ 
+ static void kvmppc_book3s_exit(void)
+ {
+ #ifdef CONFIG_KVM_BOOK3S_32
+ 	kvmppc_book3s_exit_pr();
+ #endif
+ 	kvm_exit();
+ }
+ 
+ module_init(kvmppc_book3s_init);
+ module_exit(kvmppc_book3s_exit);
+ 
+ /* On 32bit this is our one and only kernel module */
+ #ifdef CONFIG_KVM_BOOK3S_32
+ MODULE_ALIAS_MISCDEV(KVM_MINOR);
+ MODULE_ALIAS("devname:kvm");
+ #endif
++>>>>>>> 398a76c677a2 (KVM: PPC: Add devname:kvm aliases for modules)
diff --cc arch/powerpc/kvm/book3s_hv.c
index 732f35bcae5d,088a6e54c998..000000000000
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@@ -2091,10 -2209,13 +2092,18 @@@ static int kvmppc_book3s_hv_init(void
  	return r;
  }
  
 -static void kvmppc_book3s_exit_hv(void)
 +static void kvmppc_book3s_hv_exit(void)
  {
 -	kvmppc_hv_ops = NULL;
 +	kvm_exit();
  }
  
++<<<<<<< HEAD
 +module_init(kvmppc_book3s_hv_init);
 +module_exit(kvmppc_book3s_hv_exit);
++=======
+ module_init(kvmppc_book3s_init_hv);
+ module_exit(kvmppc_book3s_exit_hv);
+ MODULE_LICENSE("GPL");
+ MODULE_ALIAS_MISCDEV(KVM_MINOR);
+ MODULE_ALIAS("devname:kvm");
++>>>>>>> 398a76c677a2 (KVM: PPC: Add devname:kvm aliases for modules)
diff --cc arch/powerpc/kvm/book3s_pr.c
index 8956df8d25a8,21bf7c5c9545..000000000000
--- a/arch/powerpc/kvm/book3s_pr.c
+++ b/arch/powerpc/kvm/book3s_pr.c
@@@ -40,8 -40,13 +40,13 @@@
  #include <linux/sched.h>
  #include <linux/vmalloc.h>
  #include <linux/highmem.h>
++<<<<<<< HEAD
++=======
+ #include <linux/module.h>
+ #include <linux/miscdevice.h>
++>>>>>>> 398a76c677a2 (KVM: PPC: Add devname:kvm aliases for modules)
  
 -#include "book3s.h"
 -
 -#define CREATE_TRACE_POINTS
 -#include "trace_pr.h"
 +#include "trace.h"
  
  /* #define EXIT_DEBUG */
  /* #define DEBUG_EXT */
@@@ -1455,11 -1570,21 +1460,26 @@@ static int kvmppc_book3s_init(void
  	return r;
  }
  
 -void kvmppc_book3s_exit_pr(void)
 +static void kvmppc_book3s_exit(void)
  {
 -	kvmppc_pr_ops = NULL;
  	kvmppc_mmu_hpte_sysexit();
 +	kvm_exit();
  }
  
++<<<<<<< HEAD
 +module_init(kvmppc_book3s_init);
 +module_exit(kvmppc_book3s_exit);
++=======
+ /*
+  * We only support separate modules for book3s 64
+  */
+ #ifdef CONFIG_PPC_BOOK3S_64
+ 
+ module_init(kvmppc_book3s_init_pr);
+ module_exit(kvmppc_book3s_exit_pr);
+ 
+ MODULE_LICENSE("GPL");
+ MODULE_ALIAS_MISCDEV(KVM_MINOR);
+ MODULE_ALIAS("devname:kvm");
+ #endif
++>>>>>>> 398a76c677a2 (KVM: PPC: Add devname:kvm aliases for modules)
diff --git a/arch/powerpc/kvm/44x.c b/arch/powerpc/kvm/44x.c
index 2f5c6b6d6877..3cf48cf0c7f4 100644
--- a/arch/powerpc/kvm/44x.c
+++ b/arch/powerpc/kvm/44x.c
@@ -21,6 +21,8 @@
 #include <linux/slab.h>
 #include <linux/err.h>
 #include <linux/export.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
 
 #include <asm/reg.h>
 #include <asm/cputable.h>
@@ -203,3 +205,5 @@ static void __exit kvmppc_44x_exit(void)
 
 module_init(kvmppc_44x_init);
 module_exit(kvmppc_44x_exit);
+MODULE_ALIAS_MISCDEV(KVM_MINOR);
+MODULE_ALIAS("devname:kvm");
* Unmerged path arch/powerpc/kvm/book3s.c
* Unmerged path arch/powerpc/kvm/book3s_hv.c
* Unmerged path arch/powerpc/kvm/book3s_pr.c
diff --git a/arch/powerpc/kvm/e500.c b/arch/powerpc/kvm/e500.c
index ce6b73c29612..feafb8427f30 100644
--- a/arch/powerpc/kvm/e500.c
+++ b/arch/powerpc/kvm/e500.c
@@ -16,6 +16,8 @@
 #include <linux/slab.h>
 #include <linux/err.h>
 #include <linux/export.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
 
 #include <asm/reg.h>
 #include <asm/cputable.h>
@@ -544,3 +546,5 @@ static void __exit kvmppc_e500_exit(void)
 
 module_init(kvmppc_e500_init);
 module_exit(kvmppc_e500_exit);
+MODULE_ALIAS_MISCDEV(KVM_MINOR);
+MODULE_ALIAS("devname:kvm");
diff --git a/arch/powerpc/kvm/e500mc.c b/arch/powerpc/kvm/e500mc.c
index 19c8379575f7..5254d233a3df 100644
--- a/arch/powerpc/kvm/e500mc.c
+++ b/arch/powerpc/kvm/e500mc.c
@@ -16,6 +16,8 @@
 #include <linux/slab.h>
 #include <linux/err.h>
 #include <linux/export.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
 
 #include <asm/reg.h>
 #include <asm/cputable.h>
@@ -363,3 +365,5 @@ static void __exit kvmppc_e500mc_exit(void)
 
 module_init(kvmppc_e500mc_init);
 module_exit(kvmppc_e500mc_exit);
+MODULE_ALIAS_MISCDEV(KVM_MINOR);
+MODULE_ALIAS("devname:kvm");
