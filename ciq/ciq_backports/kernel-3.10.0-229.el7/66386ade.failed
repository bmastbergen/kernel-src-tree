KVM: Rename variable smep to cr4_smep

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Feng Wu <feng.wu@intel.com>
commit 66386ade2aa7f5fcf0dda4171df7b4d4c274d2d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/66386ade.failed

Rename variable smep to cr4_smep, which can better reflect the
meaning of the variable.

	Signed-off-by: Feng Wu <feng.wu@intel.com>
	Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
(cherry picked from commit 66386ade2aa7f5fcf0dda4171df7b4d4c274d2d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/mmu.c
diff --cc arch/x86/kvm/mmu.c
index 9fd6b6d2b555,813d31038b93..000000000000
--- a/arch/x86/kvm/mmu.c
+++ b/arch/x86/kvm/mmu.c
@@@ -3590,9 -3606,10 +3590,16 @@@ static void update_permission_bitmask(s
  {
  	unsigned bit, byte, pfec;
  	u8 map;
++<<<<<<< HEAD
 +	bool fault, x, w, u, wf, uf, ff, smep;
 +
 +	smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);
++=======
+ 	bool fault, x, w, u, wf, uf, ff, smapf, cr4_smap, cr4_smep, smap = 0;
+ 
+ 	cr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);
+ 	cr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);
++>>>>>>> 66386ade2aa7 (KVM: Rename variable smep to cr4_smep)
  	for (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {
  		pfec = byte << 1;
  		map = 0;
@@@ -3604,14 -3627,39 +3611,24 @@@
  			w = bit & ACC_WRITE_MASK;
  			u = bit & ACC_USER_MASK;
  
++<<<<<<< HEAD
 +			/* Not really needed: !nx will cause pte.nx to fault */
 +			x |= !mmu->nx;
 +			/* Allow supervisor writes if !cr0.wp */
 +			w |= !is_write_protection(vcpu) && !uf;
 +			/* Disallow supervisor fetches of user code if cr4.smep */
 +			x &= !(smep && u && !uf);
++=======
+ 			if (!ept) {
+ 				/* Not really needed: !nx will cause pte.nx to fault */
+ 				x |= !mmu->nx;
+ 				/* Allow supervisor writes if !cr0.wp */
+ 				w |= !is_write_protection(vcpu) && !uf;
+ 				/* Disallow supervisor fetches of user code if cr4.smep */
+ 				x &= !(cr4_smep && u && !uf);
++>>>>>>> 66386ade2aa7 (KVM: Rename variable smep to cr4_smep)
  
 -				/*
 -				 * SMAP:kernel-mode data accesses from user-mode
 -				 * mappings should fault. A fault is considered
 -				 * as a SMAP violation if all of the following
 -				 * conditions are ture:
 -				 *   - X86_CR4_SMAP is set in CR4
 -				 *   - An user page is accessed
 -				 *   - Page fault in kernel mode
 -				 *   - if CPL = 3 or X86_EFLAGS_AC is clear
 -				 *
 -				 *   Here, we cover the first three conditions.
 -				 *   The fourth is computed dynamically in
 -				 *   permission_fault() and is in smapf.
 -				 *
 -				 *   Also, SMAP does not affect instruction
 -				 *   fetches, add the !ff check here to make it
 -				 *   clearer.
 -				 */
 -				smap = cr4_smap && u && !uf && !ff;
 -			} else
 -				/* Not really needed: no U/S accesses on ept  */
 -				u = 1;
 -
 -			fault = (ff && !x) || (uf && !u) || (wf && !w) ||
 -				(smapf && smap);
 +			fault = (ff && !x) || (uf && !u) || (wf && !w);
  			map |= fault << bit;
  		}
  		mmu->permissions[byte] = map;
* Unmerged path arch/x86/kvm/mmu.c
