xfs: mark all internal workqueues as freezable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Brian Foster <bfoster@redhat.com>
commit 8018ec083c72443cc74fd2d08eb7c5dddc13af53
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/8018ec08.failed

Workqueues must be explicitly set as freezable to ensure they are frozen
in the assocated part of the hibernation/suspend sequence. Freezing of
workqueues and kernel threads is important to ensure that modifications
are not made on-disk after the hibernation image has been created.
Otherwise, the in-memory state can become inconsistent with what is on
disk and eventually lead to filesystem corruption. We have reports of
free space btree corruptions that occur immediately after restore from
hibernate that suggest the xfs-eofblocks workqueue could be causing
such problems if it races with hibernation.

Mark all of the internal XFS workqueues as freezable to ensure nothing
changes on-disk once the freezer infrastructure freezes kernel threads
and creates the hibernation image.

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reported-by: Carlos E. R. <carlos.e.r@opensuse.org>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 8018ec083c72443cc74fd2d08eb7c5dddc13af53)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_mru_cache.c
#	fs/xfs/xfs_super.c
diff --cc fs/xfs/xfs_mru_cache.c
index 4aff56395732,30ecca3037e3..000000000000
--- a/fs/xfs/xfs_mru_cache.c
+++ b/fs/xfs/xfs_mru_cache.c
@@@ -304,21 -304,11 +304,26 @@@ _xfs_mru_cache_reap
  int
  xfs_mru_cache_init(void)
  {
++<<<<<<< HEAD
 +	xfs_mru_elem_zone = kmem_zone_init(sizeof(xfs_mru_cache_elem_t),
 +	                                 "xfs_mru_cache_elem");
 +	if (!xfs_mru_elem_zone)
 +		goto out;
 +
 +	xfs_mru_reap_wq = alloc_workqueue("xfs_mru_cache", WQ_MEM_RECLAIM, 1);
++=======
+ 	xfs_mru_reap_wq = alloc_workqueue("xfs_mru_cache",
+ 				WQ_MEM_RECLAIM|WQ_FREEZABLE, 1);
++>>>>>>> 8018ec083c72 (xfs: mark all internal workqueues as freezable)
  	if (!xfs_mru_reap_wq)
 -		return -ENOMEM;
 +		goto out_destroy_mru_elem_zone;
 +
  	return 0;
 +
 + out_destroy_mru_elem_zone:
 +	kmem_zone_destroy(xfs_mru_elem_zone);
 + out:
 +	return -ENOMEM;
  }
  
  void
diff --cc fs/xfs/xfs_super.c
index 4fa2281561ea,bc9ec44cae45..000000000000
--- a/fs/xfs/xfs_super.c
+++ b/fs/xfs/xfs_super.c
@@@ -863,17 -853,17 +863,29 @@@ xfs_init_mount_workqueues
  		goto out_destroy_unwritten;
  
  	mp->m_reclaim_workqueue = alloc_workqueue("xfs-reclaim/%s",
++<<<<<<< HEAD
 +			WQ_NON_REENTRANT, 0, mp->m_fsname);
++=======
+ 			WQ_FREEZABLE, 0, mp->m_fsname);
++>>>>>>> 8018ec083c72 (xfs: mark all internal workqueues as freezable)
  	if (!mp->m_reclaim_workqueue)
  		goto out_destroy_cil;
  
  	mp->m_log_workqueue = alloc_workqueue("xfs-log/%s",
++<<<<<<< HEAD
 +			WQ_NON_REENTRANT, 0, mp->m_fsname);
++=======
+ 			WQ_FREEZABLE, 0, mp->m_fsname);
++>>>>>>> 8018ec083c72 (xfs: mark all internal workqueues as freezable)
  	if (!mp->m_log_workqueue)
  		goto out_destroy_reclaim;
  
  	mp->m_eofblocks_workqueue = alloc_workqueue("xfs-eofblocks/%s",
++<<<<<<< HEAD
 +			WQ_NON_REENTRANT, 0, mp->m_fsname);
++=======
+ 			WQ_FREEZABLE, 0, mp->m_fsname);
++>>>>>>> 8018ec083c72 (xfs: mark all internal workqueues as freezable)
  	if (!mp->m_eofblocks_workqueue)
  		goto out_destroy_log;
  
diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c
index f1adf6d0b7ae..efbbdab5381c 100644
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@ -1851,7 +1851,7 @@ xfs_buf_init(void)
 		goto out;
 
 	xfslogd_workqueue = alloc_workqueue("xfslogd",
-					WQ_MEM_RECLAIM | WQ_HIGHPRI, 1);
+				WQ_MEM_RECLAIM | WQ_HIGHPRI | WQ_FREEZABLE, 1);
 	if (!xfslogd_workqueue)
 		goto out_free_buf_zone;
 
* Unmerged path fs/xfs/xfs_mru_cache.c
* Unmerged path fs/xfs/xfs_super.c
