of/fdt: use libfdt accessors for header data

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [powerpc] use libfdt accessors for header data (Don Zickus) [1127366]
Rebuild_FUZZ: 90.00%
commit-author Rob Herring <robh@kernel.org>
commit c972de14971f1482ab482f0a7abc85679a23326a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/c972de14.failed

With libfdt support, we can take advantage of helper accessors in libfdt
for accessing the FDT header data. This makes the code more readable and
makes the FDT blob structure more opaque to the kernel. This also
prepares for removing struct boot_param_header completely.

	Signed-off-by: Rob Herring <robh@kernel.org>
	Cc: Max Filippov <jcmvbkbc@gmail.com>
	Tested-by: Michal Simek <michal.simek@xilinx.com>
	Tested-by: Grant Likely <grant.likely@linaro.org>
	Tested-by: Stephen Chivers <schivers@csc.com>
(cherry picked from commit c972de14971f1482ab482f0a7abc85679a23326a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/of/fdt.c
#	include/linux/of_fdt.h
diff --cc drivers/of/fdt.c
index 9f3bba3e7bdc,0b38a6aa8603..000000000000
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@@ -146,9 -98,9 +146,15 @@@ static void *unflatten_dt_alloc(unsigne
   * @allnextpp: pointer to ->allnext from last allocated device_node
   * @fpsize: Size of the node path up at the current depth.
   */
++<<<<<<< HEAD
 +static unsigned long unflatten_dt_node(struct boot_param_header *blob,
 +				unsigned long mem,
 +				unsigned long *p,
++=======
+ static void * unflatten_dt_node(void *blob,
+ 				void *mem,
+ 				int *poffset,
++>>>>>>> c972de14971f (of/fdt: use libfdt accessors for header data)
  				struct device_node *dad,
  				struct device_node ***allnextpp,
  				unsigned long fpsize)
@@@ -699,6 -793,80 +703,83 @@@ int __init early_init_dt_scan_chosen(un
  	return 1;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_HAVE_MEMBLOCK
+ void __init __weak early_init_dt_add_memory_arch(u64 base, u64 size)
+ {
+ 	const u64 phys_offset = __pa(PAGE_OFFSET);
+ 	base &= PAGE_MASK;
+ 	size &= PAGE_MASK;
+ 	if (base + size < phys_offset) {
+ 		pr_warning("Ignoring memory block 0x%llx - 0x%llx\n",
+ 			   base, base + size);
+ 		return;
+ 	}
+ 	if (base < phys_offset) {
+ 		pr_warning("Ignoring memory range 0x%llx - 0x%llx\n",
+ 			   base, phys_offset);
+ 		size -= phys_offset - base;
+ 		base = phys_offset;
+ 	}
+ 	memblock_add(base, size);
+ }
+ 
+ int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
+ 					phys_addr_t size, bool nomap)
+ {
+ 	if (memblock_is_region_reserved(base, size))
+ 		return -EBUSY;
+ 	if (nomap)
+ 		return memblock_remove(base, size);
+ 	return memblock_reserve(base, size);
+ }
+ 
+ /*
+  * called from unflatten_device_tree() to bootstrap devicetree itself
+  * Architectures can override this definition if memblock isn't used
+  */
+ void * __init __weak early_init_dt_alloc_memory_arch(u64 size, u64 align)
+ {
+ 	return __va(memblock_alloc(size, align));
+ }
+ #else
+ int __init __weak early_init_dt_reserve_memory_arch(phys_addr_t base,
+ 					phys_addr_t size, bool nomap)
+ {
+ 	pr_err("Reserved memory not supported, ignoring range 0x%llx - 0x%llx%s\n",
+ 		  base, size, nomap ? " (nomap)" : "");
+ 	return -ENOSYS;
+ }
+ #endif
+ 
+ bool __init early_init_dt_scan(void *params)
+ {
+ 	if (!params)
+ 		return false;
+ 
+ 	/* Setup flat device-tree pointer */
+ 	initial_boot_params = params;
+ 
+ 	/* check device tree validity */
+ 	if (fdt_check_header(params)) {
+ 		initial_boot_params = NULL;
+ 		return false;
+ 	}
+ 
+ 	/* Retrieve various information from the /chosen node */
+ 	of_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);
+ 
+ 	/* Initialize {size,address}-cells info */
+ 	of_scan_flat_dt(early_init_dt_scan_root, NULL);
+ 
+ 	/* Setup memory, calling early_init_dt_add_memory_arch */
+ 	of_scan_flat_dt(early_init_dt_scan_memory, NULL);
+ 
+ 	return true;
+ }
+ 
++>>>>>>> c972de14971f (of/fdt: use libfdt accessors for header data)
  /**
   * unflatten_device_tree - create tree of device_nodes from flat blob
   *
@@@ -716,4 -884,36 +797,39 @@@ void __init unflatten_device_tree(void
  	of_alias_scan(early_init_dt_alloc_memory_arch);
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  * unflatten_and_copy_device_tree - copy and create tree of device_nodes from flat blob
+  *
+  * Copies and unflattens the device-tree passed by the firmware, creating the
+  * tree of struct device_node. It also fills the "name" and "type"
+  * pointers of the nodes so the normal device-tree walking functions
+  * can be used. This should only be used when the FDT memory has not been
+  * reserved such is the case when the FDT is built-in to the kernel init
+  * section. If the FDT memory is reserved already then unflatten_device_tree
+  * should be used instead.
+  */
+ void __init unflatten_and_copy_device_tree(void)
+ {
+ 	int size;
+ 	void *dt;
+ 
+ 	if (!initial_boot_params) {
+ 		pr_warn("No valid device tree found, continuing without\n");
+ 		return;
+ 	}
+ 
+ 	size = fdt_totalsize(initial_boot_params);
+ 	dt = early_init_dt_alloc_memory_arch(size,
+ 					     roundup_pow_of_two(FDT_V17_SIZE));
+ 
+ 	if (dt) {
+ 		memcpy(dt, initial_boot_params, size);
+ 		initial_boot_params = dt;
+ 	}
+ 	unflatten_device_tree();
+ }
+ 
++>>>>>>> c972de14971f (of/fdt: use libfdt accessors for header data)
  #endif /* CONFIG_OF_EARLY_FLATTREE */
diff --cc include/linux/of_fdt.h
index ed136ad698ce,348dae2c8a3c..000000000000
--- a/include/linux/of_fdt.h
+++ b/include/linux/of_fdt.h
@@@ -62,15 -62,15 +62,20 @@@ struct boot_param_header 
  struct device_node;
  
  /* For scanning an arbitrary device-tree at any time */
- extern char *of_fdt_get_string(struct boot_param_header *blob, u32 offset);
- extern void *of_fdt_get_property(struct boot_param_header *blob,
+ extern char *of_fdt_get_string(const void *blob, u32 offset);
+ extern void *of_fdt_get_property(const void *blob,
  				 unsigned long node,
  				 const char *name,
++<<<<<<< HEAD
 +				 unsigned long *size);
 +extern int of_fdt_is_compatible(struct boot_param_header *blob,
++=======
+ 				 int *size);
+ extern int of_fdt_is_compatible(const void *blob,
++>>>>>>> c972de14971f (of/fdt: use libfdt accessors for header data)
  				unsigned long node,
  				const char *compat);
- extern int of_fdt_match(struct boot_param_header *blob, unsigned long node,
+ extern int of_fdt_match(const void *blob, unsigned long node,
  			const char *const *compat);
  extern void of_fdt_unflatten_tree(unsigned long *blob,
  			       struct device_node **mynodes);
* Unmerged path drivers/of/fdt.c
* Unmerged path include/linux/of_fdt.h
