perf callchain: Separate perf_reg_value function in perf_regs object

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf/callchain: Separate perf_reg_value function in perf_regs object (Jiri Olsa) [1134356]
Rebuild_FUZZ: 98.53%
commit-author Jiri Olsa <jolsa@redhat.com>
commit c9b951c4d12f0b2e9a07dd459c554bc05628d092
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/c9b951c4.failed

Making perf_reg_value function global (formely reg_value), because it's
going to be used globaly across all code providing the dwarf post unwind
feature.

Changing its prototype to be generic:

  -int reg_value(unw_word_t *valp, struct regs_dump *regs, int id)
  +int perf_reg_value(u64 *valp, struct regs_dump *regs, int id);

Changing the valp type from libunwind specific 'unw_word_t' to u64.

	Signed-off-by: Jiri Olsa <jolsa@redhat.com>
	Acked-by: Jean Pihet <jean.pihet@linaro.org>
	Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Jean Pihet <jean.pihet@linaro.org>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1389098853-14466-13-git-send-email-jolsa@redhat.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit c9b951c4d12f0b2e9a07dd459c554bc05628d092)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/perf_regs.h
#	tools/perf/util/unwind.c
diff --cc tools/perf/util/perf_regs.h
index 5a4f2b6f3738,d6e8b6a8d7f3..000000000000
--- a/tools/perf/util/perf_regs.h
+++ b/tools/perf/util/perf_regs.h
@@@ -1,8 -1,14 +1,18 @@@
  #ifndef __PERF_REGS_H
  #define __PERF_REGS_H
  
++<<<<<<< HEAD
 +#ifdef HAVE_PERF_REGS
++=======
+ #include "types.h"
+ #include "event.h"
+ 
+ #ifdef HAVE_PERF_REGS_SUPPORT
++>>>>>>> c9b951c4d12f (perf callchain: Separate perf_reg_value function in perf_regs object)
  #include <perf_regs.h>
+ 
+ int perf_reg_value(u64 *valp, struct regs_dump *regs, int id);
+ 
  #else
  #define PERF_REGS_MASK	0
  
@@@ -10,5 -16,12 +20,16 @@@ static inline const char *perf_reg_name
  {
  	return NULL;
  }
++<<<<<<< HEAD
 +#endif /* HAVE_PERF_REGS */
++=======
+ 
+ static inline int perf_reg_value(u64 *valp __maybe_unused,
+ 				 struct regs_dump *regs __maybe_unused,
+ 				 int id __maybe_unused)
+ {
+ 	return 0;
+ }
+ #endif /* HAVE_PERF_REGS_SUPPORT */
++>>>>>>> c9b951c4d12f (perf callchain: Separate perf_reg_value function in perf_regs object)
  #endif /* __PERF_REGS_H */
diff --cc tools/perf/util/unwind.c
index 6c308f43c0ca,bd5768d74f01..000000000000
--- a/tools/perf/util/unwind.c
+++ b/tools/perf/util/unwind.c
@@@ -407,23 -390,6 +407,26 @@@ static int access_dso_mem(struct unwind
  	return !(size == sizeof(*data));
  }
  
++<<<<<<< HEAD:tools/perf/util/unwind.c
 +static int reg_value(unw_word_t *valp, struct regs_dump *regs, int id,
 +		     u64 sample_regs)
 +{
 +	int i, idx = 0;
 +
 +	if (!(sample_regs & (1 << id)))
 +		return -EINVAL;
 +
 +	for (i = 0; i < id; i++) {
 +		if (sample_regs & (1 << i))
 +			idx++;
 +	}
 +
 +	*valp = regs->regs[idx];
 +	return 0;
 +}
 +
++=======
++>>>>>>> c9b951c4d12f (perf callchain: Separate perf_reg_value function in perf_regs object):tools/perf/util/unwind-libunwind.c
  static int access_mem(unw_addr_space_t __maybe_unused as,
  		      unw_word_t addr, unw_word_t *valp,
  		      int __write, void *arg)
@@@ -440,8 -406,7 +443,12 @@@
  		return 0;
  	}
  
++<<<<<<< HEAD:tools/perf/util/unwind.c
 +	ret = reg_value(&start, &ui->sample->user_regs, PERF_REG_SP,
 +			ui->sample_uregs);
++=======
+ 	ret = perf_reg_value(&start, &ui->sample->user_regs, PERF_REG_SP);
++>>>>>>> c9b951c4d12f (perf callchain: Separate perf_reg_value function in perf_regs object):tools/perf/util/unwind-libunwind.c
  	if (ret)
  		return ret;
  
@@@ -491,7 -458,7 +500,11 @@@ static int access_reg(unw_addr_space_t 
  	if (id < 0)
  		return -EINVAL;
  
++<<<<<<< HEAD:tools/perf/util/unwind.c
 +	ret = reg_value(valp, &ui->sample->user_regs, id, ui->sample_uregs);
++=======
+ 	ret = perf_reg_value(&val, &ui->sample->user_regs, id);
++>>>>>>> c9b951c4d12f (perf callchain: Separate perf_reg_value function in perf_regs object):tools/perf/util/unwind-libunwind.c
  	if (ret) {
  		pr_err("unwind: can't read reg %d\n", regnum);
  		return ret;
@@@ -588,13 -556,11 +602,13 @@@ static int get_entries(struct unwind_in
  
  int unwind__get_entries(unwind_entry_cb_t cb, void *arg,
  			struct machine *machine, struct thread *thread,
 -			struct perf_sample *data, int max_stack)
 +			u64 sample_uregs, struct perf_sample *data,
 +			int max_stack)
  {
- 	unw_word_t ip;
+ 	u64 ip;
  	struct unwind_info ui = {
  		.sample       = data,
 +		.sample_uregs = sample_uregs,
  		.thread       = thread,
  		.machine      = machine,
  	};
@@@ -603,7 -569,7 +617,11 @@@
  	if (!data->user_regs.regs)
  		return -EINVAL;
  
++<<<<<<< HEAD:tools/perf/util/unwind.c
 +	ret = reg_value(&ip, &data->user_regs, PERF_REG_IP, sample_uregs);
++=======
+ 	ret = perf_reg_value(&ip, &data->user_regs, PERF_REG_IP);
++>>>>>>> c9b951c4d12f (perf callchain: Separate perf_reg_value function in perf_regs object):tools/perf/util/unwind-libunwind.c
  	if (ret)
  		return ret;
  
diff --git a/tools/perf/Makefile.perf b/tools/perf/Makefile.perf
index 469a631cb69a..bdc60eb8e800 100644
--- a/tools/perf/Makefile.perf
+++ b/tools/perf/Makefile.perf
@@ -524,6 +524,7 @@ ifeq ($(NO_PERF_REGS),0)
   ifeq ($(ARCH),x86)
     LIB_H += arch/x86/include/perf_regs.h
   endif
+  LIB_OBJS += $(OUTPUT)util/perf_regs.o
 endif
 
 ifndef NO_LIBNUMA
diff --git a/tools/perf/util/perf_regs.c b/tools/perf/util/perf_regs.c
new file mode 100644
index 000000000000..a3539ef30b15
--- /dev/null
+++ b/tools/perf/util/perf_regs.c
@@ -0,0 +1,19 @@
+#include <errno.h>
+#include "perf_regs.h"
+
+int perf_reg_value(u64 *valp, struct regs_dump *regs, int id)
+{
+	int i, idx = 0;
+	u64 mask = regs->mask;
+
+	if (!(mask & (1 << id)))
+		return -EINVAL;
+
+	for (i = 0; i < id; i++) {
+		if (mask & (1 << i))
+			idx++;
+	}
+
+	*valp = regs->regs[idx];
+	return 0;
+}
* Unmerged path tools/perf/util/perf_regs.h
* Unmerged path tools/perf/util/unwind.c
