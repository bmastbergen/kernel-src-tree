pseries: Fix endian issues in cpu hot-removal

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
commit e36d1227776a2daa2c9aa7f997ac7083d6783f2c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e36d1227.failed

When removing a cpu, this patch makes sure that values
gotten from or passed to firmware are in the correct
endian format.

	Signed-off-by: Thomas Falcon <tlfalcon@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
(cherry picked from commit e36d1227776a2daa2c9aa7f997ac7083d6783f2c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/pseries/dlpar.c
diff --cc arch/powerpc/platforms/pseries/dlpar.c
index 0d050ce52c91,fdf01b660d59..000000000000
--- a/arch/powerpc/platforms/pseries/dlpar.c
+++ b/arch/powerpc/platforms/pseries/dlpar.c
@@@ -521,20 -515,19 +523,25 @@@ static ssize_t dlpar_cpu_release(const 
  	rc = dlpar_offline_cpu(dn);
  	if (rc) {
  		of_node_put(dn);
 -		return -EINVAL;
 +		rc = -EINVAL;
 +		goto out;
  	}
  
- 	rc = dlpar_release_drc(*drc_index);
+ 	rc = dlpar_release_drc(drc_index);
  	if (rc) {
  		of_node_put(dn);
 -		return rc;
 +		goto out;
  	}
  
  	rc = dlpar_detach_node(dn);
  	if (rc) {
++<<<<<<< HEAD
 +		dlpar_acquire_drc(*drc_index);
 +		goto out;
++=======
+ 		dlpar_acquire_drc(drc_index);
+ 		return rc;
++>>>>>>> e36d1227776a (pseries: Fix endian issues in cpu hot-removal)
  	}
  
  	of_node_put(dn);
* Unmerged path arch/powerpc/platforms/pseries/dlpar.c
diff --git a/arch/powerpc/platforms/pseries/hotplug-cpu.c b/arch/powerpc/platforms/pseries/hotplug-cpu.c
index 9b8e05078a63..faaa19c5ee8b 100644
--- a/arch/powerpc/platforms/pseries/hotplug-cpu.c
+++ b/arch/powerpc/platforms/pseries/hotplug-cpu.c
@@ -91,7 +91,7 @@ static void rtas_stop_self(void)
 	struct rtas_args args = {
 		.token = cpu_to_be32(rtas_stop_self_token),
 		.nargs = 0,
-		.nret = 1,
+		.nret = cpu_to_be32(1),
 		.rets = &args.args[0],
 	};
 
@@ -311,7 +311,8 @@ static void pseries_remove_processor(struct device_node *np)
 {
 	unsigned int cpu;
 	int len, nthreads, i;
-	const u32 *intserv;
+	const __be32 *intserv;
+	u32 thread;
 
 	intserv = of_get_property(np, "ibm,ppc-interrupt-server#s", &len);
 	if (!intserv)
@@ -321,8 +322,9 @@ static void pseries_remove_processor(struct device_node *np)
 
 	cpu_maps_update_begin();
 	for (i = 0; i < nthreads; i++) {
+		thread = be32_to_cpu(intserv[i]);
 		for_each_present_cpu(cpu) {
-			if (get_hard_smp_processor_id(cpu) != intserv[i])
+			if (get_hard_smp_processor_id(cpu) != thread)
 				continue;
 			BUG_ON(cpu_online(cpu));
 			set_cpu_present(cpu, false);
@@ -331,7 +333,7 @@ static void pseries_remove_processor(struct device_node *np)
 		}
 		if (cpu >= nr_cpu_ids)
 			printk(KERN_WARNING "Could not find cpu to remove "
-			       "with physical id 0x%x\n", intserv[i]);
+			       "with physical id 0x%x\n", thread);
 	}
 	cpu_maps_update_done();
 }
