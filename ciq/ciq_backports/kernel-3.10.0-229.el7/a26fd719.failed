x86/uv: Update the UV3 TLB shootdown logic

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [x86] uv: Update the UV3 TLB shootdown logic (Frank Ramsay) [1170253]
Rebuild_FUZZ: 95.00%
commit-author Cliff Wickman <cpw@sgi.com>
commit a26fd71953711acb4884df84e393d52de57e4f17
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a26fd719.failed

Update of TLB shootdown code for UV3.

Kernel function native_flush_tlb_others() calls
uv_flush_tlb_others() on UV to invalidate tlb page definitions
on remote cpus. The UV systems have a hardware 'broadcast assist
unit' which can be used to broadcast shootdown messages to all
cpu's of selected nodes.

The behavior of the BAU has changed only slightly with UV3:

  - UV3 is recognized with is_uv3_hub().
  - UV2 functions and structures (uv2_xxx) are in most cases
    simply renamed to uv2_3_xxx.
  - Some UV2 error workarounds are not needed for UV3.
    (see uv_bau_message_interrupt and enable_timeouts)

	Signed-off-by: Cliff Wickman <cpw@sgi.com>
Link: http://lkml.kernel.org/r/E1WkgWh-0001yJ-3K@eag09.americas.sgi.com
[ Removed a few linebreak uglies. ]
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit a26fd71953711acb4884df84e393d52de57e4f17)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/platform/uv/tlb_uv.c
diff --cc arch/x86/platform/uv/tlb_uv.c
index a6b5affb024a,ed161c6e278b..000000000000
--- a/arch/x86/platform/uv/tlb_uv.c
+++ b/arch/x86/platform/uv/tlb_uv.c
@@@ -433,15 -433,49 +433,48 @@@ static void reset_with_ipi(struct pnmas
  	return;
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Not to be confused with cycles_2_ns() from tsc.c; this gives a relative
+  * number, not an absolute. It converts a duration in cycles to a duration in
+  * ns.
+  */
+ static inline unsigned long long cycles_2_ns(unsigned long long cyc)
+ {
+ 	struct cyc2ns_data *data = cyc2ns_read_begin();
+ 	unsigned long long ns;
+ 
+ 	ns = mul_u64_u32_shr(cyc, data->cyc2ns_mul, data->cyc2ns_shift);
+ 
+ 	cyc2ns_read_end(data);
+ 	return ns;
+ }
+ 
+ /*
+  * The reverse of the above; converts a duration in ns to a duration in cycles.
+  */
+ static inline unsigned long long ns_2_cycles(unsigned long long ns)
+ {
+ 	struct cyc2ns_data *data = cyc2ns_read_begin();
+ 	unsigned long long cyc;
+ 
+ 	cyc = (ns << data->cyc2ns_shift) / data->cyc2ns_mul;
+ 
+ 	cyc2ns_read_end(data);
+ 	return cyc;
+ }
+ 
++>>>>>>> a26fd7195371 (x86/uv: Update the UV3 TLB shootdown logic)
  static inline unsigned long cycles_2_us(unsigned long long cyc)
  {
 -	return cycles_2_ns(cyc) / NSEC_PER_USEC;
 -}
 -
 -static inline cycles_t sec_2_cycles(unsigned long sec)
 -{
 -	return ns_2_cycles(sec * NSEC_PER_SEC);
 -}
 +	unsigned long long ns;
 +	unsigned long us;
 +	int cpu = smp_processor_id();
  
 -static inline unsigned long long usec_2_cycles(unsigned long usec)
 -{
 -	return ns_2_cycles(usec * NSEC_PER_USEC);
 +	ns =  (cyc * per_cpu(cyc2ns, cpu)) >> CYC2NS_SCALE_FACTOR;
 +	us = ns / 1000;
 +	return us;
  }
  
  /*
@@@ -661,23 -692,11 +691,21 @@@ static int wait_completion(struct bau_d
  	}
  
  	if (bcp->uvhub_version == 1)
- 		return uv1_wait_completion(bau_desc, mmr_offset, right_shift,
- 								bcp, try);
+ 		return uv1_wait_completion(bau_desc, mmr_offset, right_shift, bcp, try);
  	else
- 		return uv2_wait_completion(bau_desc, mmr_offset, right_shift,
- 								bcp, try);
+ 		return uv2_3_wait_completion(bau_desc, mmr_offset, right_shift, bcp, try);
  }
  
 +static inline cycles_t sec_2_cycles(unsigned long sec)
 +{
 +	unsigned long ns;
 +	cycles_t cyc;
 +
 +	ns = sec * 1000000000;
 +	cyc = (ns << CYC2NS_SCALE_FACTOR)/(per_cpu(cyc2ns, smp_processor_id()));
 +	return cyc;
 +}
 +
  /*
   * Our retries are blocked by all destination sw ack resources being
   * in use, and a timeout is pending. In that case hardware immediately
diff --git a/arch/x86/include/asm/uv/uv_bau.h b/arch/x86/include/asm/uv/uv_bau.h
index ea3d3c171a36..fc808b83fccb 100644
--- a/arch/x86/include/asm/uv/uv_bau.h
+++ b/arch/x86/include/asm/uv/uv_bau.h
@@ -73,6 +73,7 @@
 #define UV_INTD_SOFT_ACK_TIMEOUT_PERIOD	(is_uv1_hub() ?			\
 		UV1_INTD_SOFT_ACK_TIMEOUT_PERIOD :			\
 		UV2_INTD_SOFT_ACK_TIMEOUT_PERIOD)
+/* assuming UV3 is the same */
 
 #define BAU_MISC_CONTROL_MULT_MASK	3
 
@@ -93,6 +94,8 @@
 #define SOFTACK_MSHIFT UVH_LB_BAU_MISC_CONTROL_ENABLE_INTD_SOFT_ACK_MODE_SHFT
 #define SOFTACK_PSHIFT UVH_LB_BAU_MISC_CONTROL_INTD_SOFT_ACK_TIMEOUT_PERIOD_SHFT
 #define SOFTACK_TIMEOUT_PERIOD UV_INTD_SOFT_ACK_TIMEOUT_PERIOD
+#define PREFETCH_HINT_SHFT UV3H_LB_BAU_MISC_CONTROL_ENABLE_INTD_PREFETCH_HINT_SHFT
+#define SB_STATUS_SHFT UV3H_LB_BAU_MISC_CONTROL_ENABLE_EXTENDED_SB_STATUS_SHFT
 #define write_gmmr	uv_write_global_mmr64
 #define write_lmmr	uv_write_local_mmr
 #define read_lmmr	uv_read_local_mmr
@@ -322,8 +325,9 @@ struct uv1_bau_msg_header {
 /*
  * UV2 Message header:  16 bytes (128 bits) (bytes 0x30-0x3f of descriptor)
  * see figure 9-2 of harp_sys.pdf
+ * assuming UV3 is the same
  */
-struct uv2_bau_msg_header {
+struct uv2_3_bau_msg_header {
 	unsigned int	base_dest_nasid:15;	/* nasid of the first bit */
 	/* bits 14:0 */				/* in uvhub map */
 	unsigned int	dest_subnodeid:5;	/* must be 0x10, for the LB */
@@ -395,7 +399,7 @@ struct bau_desc {
 	 */
 	union bau_msg_header {
 		struct uv1_bau_msg_header	uv1_hdr;
-		struct uv2_bau_msg_header	uv2_hdr;
+		struct uv2_3_bau_msg_header	uv2_3_hdr;
 	} header;
 
 	struct bau_msg_payload			payload;
@@ -631,11 +635,6 @@ struct bau_control {
 	struct hub_and_pnode	*thp;
 };
 
-static inline unsigned long read_mmr_uv2_status(void)
-{
-	return read_lmmr(UV2H_LB_BAU_SB_ACTIVATION_STATUS_2);
-}
-
 static inline void write_mmr_data_broadcast(int pnode, unsigned long mmr_image)
 {
 	write_gmmr(pnode, UVH_BAU_DATA_BROADCAST, mmr_image);
@@ -760,7 +759,11 @@ static inline int atomic_read_short(const struct atomic_short *v)
  */
 static inline int atom_asr(short i, struct atomic_short *v)
 {
-	return i + xadd(&v->counter, i);
+	short __i = i;
+	asm volatile(LOCK_PREFIX "xaddw %0, %1"
+			: "+r" (i), "+m" (v->counter)
+			: : "memory");
+	return i + __i;
 }
 
 /*
* Unmerged path arch/x86/platform/uv/tlb_uv.c
