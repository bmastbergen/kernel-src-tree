ceph: remove redundant code for max file size verification

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Chao Yu <chao2.yu@samsung.com>
commit a4483e8a424d76bc1dfacdd94e739fba29d7f83f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a4483e8a.failed

Both ceph_update_writeable_page and ceph_setattr will verify file size
with max size ceph supported.
There are two caller for ceph_update_writeable_page, ceph_write_begin and
ceph_page_mkwrite. For ceph_write_begin, we have already verified the size in
generic_write_checks of ceph_write_iter; for ceph_page_mkwrite, we have no
chance to change file size when mmap. Likewise we have already verified the size
in inode_change_ok when we call ceph_setattr.
So let's remove the redundant code for max file size verification.

	Signed-off-by: Chao Yu <chao2.yu@samsung.com>
	Reviewed-by: Yan, Zheng <zyan@redhat.com>
(cherry picked from commit a4483e8a424d76bc1dfacdd94e739fba29d7f83f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/inode.c
diff --cc fs/ceph/inode.c
index 943722fa6b76,7b6139004401..000000000000
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@@ -1851,8 -1892,7 +1847,12 @@@ int ceph_setattr(struct dentry *dentry
  	if (mask & CEPH_SETATTR_SIZE)
  		__ceph_do_pending_vmtruncate(inode);
  	return err;
++<<<<<<< HEAD
 +out:
 +	spin_unlock(&ci->i_ceph_lock);
++=======
+ out_put:
++>>>>>>> a4483e8a424d (ceph: remove redundant code for max file size verification)
  	ceph_mdsc_put_request(req);
  	return err;
  }
diff --git a/fs/ceph/addr.c b/fs/ceph/addr.c
index c869a056c6e6..9913a451b198 100644
--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@ -1045,12 +1045,6 @@ retry_locked:
 	/* past end of file? */
 	i_size = inode->i_size;   /* caller holds i_mutex */
 
-	if (i_size + len > inode->i_sb->s_maxbytes) {
-		/* file is too big */
-		r = -EINVAL;
-		goto fail;
-	}
-
 	if (page_off >= i_size ||
 	    (pos_in_page == 0 && (pos+len) >= i_size &&
 	     end_in_page - pos_in_page != PAGE_CACHE_SIZE)) {
@@ -1068,9 +1062,6 @@ retry_locked:
 	if (r < 0)
 		goto fail_nosnap;
 	goto retry_locked;
-
-fail:
-	up_read(&mdsc->snap_rwsem);
 fail_nosnap:
 	unlock_page(page);
 	return r;
* Unmerged path fs/ceph/inode.c
