perf bench: Add futex-wake microbenchmark

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf/bench: Add futex-wake microbenchmark (Jiri Olsa) [1134356]
Rebuild_FUZZ: 97.56%
commit-author Davidlohr Bueso <davidlohr@hp.com>
commit 27db78307481dbba68c5f3563c6cb694b25521d9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/27db7830.failed

Block a bunch of threads on a futex and wake them up, N at a time.

This program is particularly useful to measure the latency of nthread
wakeups in non-error situations:  all waiters are queued and all wake
calls wakeup one or more tasks.

An example run:

  $ perf bench futex wake -t 512 -r 100
  Run summary [PID 27823]: blocking on 512 threads (at futex 0x7e10d4), waking up 1 at a time.

  [Run 1]: Wokeup 512 of 512 threads in 6.0080 ms
  [Run 2]: Wokeup 512 of 512 threads in 5.2280 ms
  [Run 3]: Wokeup 512 of 512 threads in 4.8300 ms
  ...
  [Run 100]: Wokeup 512 of 512 threads in 5.0100 ms
  Wokeup 512 of 512 threads in 5.0109 ms (+-2.25%)

	Signed-off-by: Davidlohr Bueso <davidlohr@hp.com>
	Acked-by: Darren Hart <dvhart@linux.intel.com>
	Cc: Aswin Chandramouleeswaran <aswin@hp.com>
	Cc: Darren Hart <dvhart@linux.intel.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Jason Low <jason.low2@hp.com>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Scott J Norton <scott.norton@hp.com>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Waiman Long <Waiman.Long@hp.com>
Link: http://lkml.kernel.org/r/1387081917-9102-3-git-send-email-davidlohr@hp.com
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 27db78307481dbba68c5f3563c6cb694b25521d9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Makefile.perf
#	tools/perf/bench/bench.h
#	tools/perf/bench/futex.h
#	tools/perf/builtin-bench.c
diff --cc tools/perf/Makefile.perf
index d61a8858cf15,6fa5d8b74635..000000000000
--- a/tools/perf/Makefile.perf
+++ b/tools/perf/Makefile.perf
@@@ -423,6 -426,8 +423,11 @@@ BUILTIN_OBJS += $(OUTPUT)bench/mem-mems
  endif
  BUILTIN_OBJS += $(OUTPUT)bench/mem-memcpy.o
  BUILTIN_OBJS += $(OUTPUT)bench/mem-memset.o
++<<<<<<< HEAD
++=======
+ BUILTIN_OBJS += $(OUTPUT)bench/futex-hash.o
+ BUILTIN_OBJS += $(OUTPUT)bench/futex-wake.o
++>>>>>>> 27db78307481 (perf bench: Add futex-wake microbenchmark)
  
  BUILTIN_OBJS += $(OUTPUT)builtin-diff.o
  BUILTIN_OBJS += $(OUTPUT)builtin-evlist.o
diff --cc tools/perf/bench/bench.h
index 0fdc85269c4d,6ac3f1d083cc..000000000000
--- a/tools/perf/bench/bench.h
+++ b/tools/perf/bench/bench.h
@@@ -31,6 -31,8 +31,11 @@@ extern int bench_sched_pipe(int argc, c
  extern int bench_mem_memcpy(int argc, const char **argv,
  			    const char *prefix __maybe_unused);
  extern int bench_mem_memset(int argc, const char **argv, const char *prefix);
++<<<<<<< HEAD
++=======
+ extern int bench_futex_hash(int argc, const char **argv, const char *prefix);
+ extern int bench_futex_wake(int argc, const char **argv, const char *prefix);
++>>>>>>> 27db78307481 (perf bench: Add futex-wake microbenchmark)
  
  #define BENCH_FORMAT_DEFAULT_STR	"default"
  #define BENCH_FORMAT_DEFAULT		0
diff --cc tools/perf/builtin-bench.c
index 77298bf892b8,743a30a8baa0..000000000000
--- a/tools/perf/builtin-bench.c
+++ b/tools/perf/builtin-bench.c
@@@ -47,72 -41,62 +47,80 @@@ static struct bench_suite numa_suites[
  };
  #endif
  
 -static struct bench sched_benchmarks[] = {
 -	{ "messaging",	"Benchmark for scheduling and IPC",		bench_sched_messaging	},
 -	{ "pipe",	"Benchmark for pipe() between two processes",	bench_sched_pipe	},
 -	{ "all",	"Test all scheduler benchmarks",		NULL			},
 -	{ NULL,		NULL,						NULL			}
 +static struct bench_suite sched_suites[] = {
 +	{ "messaging",
 +	  "Benchmark for scheduler and IPC mechanisms",
 +	  bench_sched_messaging },
 +	{ "pipe",
 +	  "Flood of communication over pipe() between two processes",
 +	  bench_sched_pipe      },
 +	suite_all,
 +	{ NULL,
 +	  NULL,
 +	  NULL                  }
  };
  
 -static struct bench mem_benchmarks[] = {
 -	{ "memcpy",	"Benchmark for memcpy()",			bench_mem_memcpy	},
 -	{ "memset",	"Benchmark for memset() tests",			bench_mem_memset	},
 -	{ "all",	"Test all memory benchmarks",			NULL			},
 -	{ NULL,		NULL,						NULL			}
 +static struct bench_suite mem_suites[] = {
 +	{ "memcpy",
 +	  "Simple memory copy in various ways",
 +	  bench_mem_memcpy },
 +	{ "memset",
 +	  "Simple memory set in various ways",
 +	  bench_mem_memset },
 +	suite_all,
 +	{ NULL,
 +	  NULL,
 +	  NULL             }
  };
  
++<<<<<<< HEAD
 +struct bench_subsys {
 +	const char *name;
 +	const char *summary;
 +	struct bench_suite *suites;
++=======
+ static struct bench futex_benchmarks[] = {
+ 	{ "hash",	"Benchmark for futex hash table",               bench_futex_hash	},
+ 	{ "wake",	"Benchmark for futex wake calls",               bench_futex_wake	},
+ 	{ "all",	"Test all futex benchmarks",			NULL			},
+ 	{ NULL,		NULL,						NULL			}
++>>>>>>> 27db78307481 (perf bench: Add futex-wake microbenchmark)
  };
  
 -struct collection {
 -	const char	*name;
 -	const char	*summary;
 -	struct bench	*benchmarks;
 -};
 -
 -static struct collection collections[] = {
 -	{ "sched",	"Scheduler and IPC benchmarks",			sched_benchmarks	},
 -	{ "mem",	"Memory access benchmarks",			mem_benchmarks		},
 -#ifdef HAVE_LIBNUMA_SUPPORT
 -	{ "numa",	"NUMA scheduling and MM benchmarks",		numa_benchmarks		},
 +static struct bench_subsys subsystems[] = {
 +#ifdef LIBNUMA_SUPPORT
 +	{ "numa",
 +	  "NUMA scheduling and MM behavior",
 +	  numa_suites },
  #endif
 -	{"futex",       "Futex stressing benchmarks",                   futex_benchmarks        },
 -	{ "all",	"All benchmarks",				NULL			},
 -	{ NULL,		NULL,						NULL			}
 +	{ "sched",
 +	  "scheduler and IPC mechanism",
 +	  sched_suites },
 +	{ "mem",
 +	  "memory access performance",
 +	  mem_suites },
 +	{ "all",		/* sentinel: easy for help */
 +	  "all benchmark subsystem",
 +	  NULL },
 +	{ NULL,
 +	  NULL,
 +	  NULL       }
  };
  
 -/* Iterate over all benchmark collections: */
 -#define for_each_collection(coll) \
 -	for (coll = collections; coll->name; coll++)
 -
 -/* Iterate over all benchmarks within a collection: */
 -#define for_each_bench(coll, bench) \
 -	for (bench = coll->benchmarks; bench->name; bench++)
 -
 -static void dump_benchmarks(struct collection *coll)
 +static void dump_suites(int subsys_index)
  {
 -	struct bench *bench;
 +	int i;
  
 -	printf("\n        # List of available benchmarks for collection '%s':\n\n", coll->name);
 +	printf("# List of available suites for %s...\n\n",
 +	       subsystems[subsys_index].name);
  
 -	for_each_bench(coll, bench)
 -		printf("%14s: %s\n", bench->name, bench->summary);
 +	for (i = 0; subsystems[subsys_index].suites[i].name; i++)
 +		printf("%14s: %s\n",
 +		       subsystems[subsys_index].suites[i].name,
 +		       subsystems[subsys_index].suites[i].summary);
  
  	printf("\n");
 +	return;
  }
  
  static const char *bench_format_str;
* Unmerged path tools/perf/bench/futex.h
* Unmerged path tools/perf/Makefile.perf
* Unmerged path tools/perf/bench/bench.h
diff --git a/tools/perf/bench/futex-wake.c b/tools/perf/bench/futex-wake.c
new file mode 100644
index 000000000000..d096169b161e
--- /dev/null
+++ b/tools/perf/bench/futex-wake.c
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2013  Davidlohr Bueso <davidlohr@hp.com>
+ *
+ * futex-wake: Block a bunch of threads on a futex and wake'em up, N at a time.
+ *
+ * This program is particularly useful to measure the latency of nthread wakeups
+ * in non-error situations:  all waiters are queued and all wake calls wakeup
+ * one or more tasks, and thus the waitqueue is never empty.
+ */
+
+#include "../perf.h"
+#include "../util/util.h"
+#include "../util/stat.h"
+#include "../util/parse-options.h"
+#include "../util/header.h"
+#include "bench.h"
+#include "futex.h"
+
+#include <err.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <pthread.h>
+
+/* all threads will block on the same futex */
+static u_int32_t futex1 = 0;
+
+/*
+ * How many wakeups to do at a time.
+ * Default to 1 in order to make the kernel work more.
+ */
+static unsigned int nwakes = 1;
+
+/*
+ * There can be significant variance from run to run,
+ * the more repeats, the more exact the overall avg and
+ * the better idea of the futex latency.
+ */
+static unsigned int repeat = 10;
+
+pthread_t *worker;
+static bool done = 0, silent = 0;
+static pthread_mutex_t thread_lock;
+static pthread_cond_t thread_parent, thread_worker;
+static struct stats waketime_stats, wakeup_stats;
+static unsigned int ncpus, threads_starting, nthreads = 0;
+
+static const struct option options[] = {
+	OPT_UINTEGER('t', "threads", &nthreads, "Specify amount of threads"),
+	OPT_UINTEGER('w', "nwakes",  &nwakes,   "Specify amount of threads to wake at once"),
+	OPT_UINTEGER('r', "repeat",  &repeat,   "Specify amount of times to repeat the run"),
+	OPT_BOOLEAN( 's', "silent",  &silent,   "Silent mode: do not display data/details"),
+	OPT_END()
+};
+
+static const char * const bench_futex_wake_usage[] = {
+	"perf bench futex wake <options>",
+	NULL
+};
+
+static void *workerfn(void *arg __maybe_unused)
+{
+	pthread_mutex_lock(&thread_lock);
+	threads_starting--;
+	if (!threads_starting)
+		pthread_cond_signal(&thread_parent);
+	pthread_cond_wait(&thread_worker, &thread_lock);
+	pthread_mutex_unlock(&thread_lock);
+
+	futex_wait(&futex1, 0, NULL, FUTEX_PRIVATE_FLAG);
+	return NULL;
+}
+
+static void print_summary(void)
+{
+	double waketime_avg = avg_stats(&waketime_stats);
+	double waketime_stddev = stddev_stats(&waketime_stats);
+	unsigned int wakeup_avg = avg_stats(&wakeup_stats);
+
+	printf("Wokeup %d of %d threads in %.4f ms (+-%.2f%%)\n",
+	       wakeup_avg,
+	       nthreads,
+	       waketime_avg/1e3,
+	       rel_stddev_stats(waketime_stddev, waketime_avg));
+}
+
+static void block_threads(pthread_t *w,
+			  pthread_attr_t thread_attr)
+{
+	cpu_set_t cpu;
+	unsigned int i;
+
+	threads_starting = nthreads;
+
+	/* create and block all threads */
+	for (i = 0; i < nthreads; i++) {
+		CPU_ZERO(&cpu);
+		CPU_SET(i % ncpus, &cpu);
+
+		if (pthread_attr_setaffinity_np(&thread_attr, sizeof(cpu_set_t), &cpu))
+			err(EXIT_FAILURE, "pthread_attr_setaffinity_np");
+
+		if (pthread_create(&w[i], &thread_attr, workerfn, NULL))
+			err(EXIT_FAILURE, "pthread_create");
+	}
+}
+
+static void toggle_done(int sig __maybe_unused,
+			siginfo_t *info __maybe_unused,
+			void *uc __maybe_unused)
+{
+	done = true;
+}
+
+int bench_futex_wake(int argc, const char **argv,
+		     const char *prefix __maybe_unused)
+{
+	int ret = 0;
+	unsigned int i, j;
+	struct sigaction act;
+	pthread_attr_t thread_attr;
+
+	argc = parse_options(argc, argv, options, bench_futex_wake_usage, 0);
+	if (argc) {
+		usage_with_options(bench_futex_wake_usage, options);
+		exit(EXIT_FAILURE);
+	}
+
+	ncpus = sysconf(_SC_NPROCESSORS_ONLN);
+
+	sigfillset(&act.sa_mask);
+	act.sa_sigaction = toggle_done;
+	sigaction(SIGINT, &act, NULL);
+
+	if (!nthreads)
+		nthreads = ncpus;
+
+	worker = calloc(nthreads, sizeof(*worker));
+	if (!worker)
+		err(EXIT_FAILURE, "calloc");
+
+	printf("Run summary [PID %d]: blocking on %d threads (at futex %p), "
+	       "waking up %d at a time.\n\n",
+	       getpid(), nthreads, &futex1, nwakes);
+
+	init_stats(&wakeup_stats);
+	init_stats(&waketime_stats);
+	pthread_attr_init(&thread_attr);
+	pthread_mutex_init(&thread_lock, NULL);
+	pthread_cond_init(&thread_parent, NULL);
+	pthread_cond_init(&thread_worker, NULL);
+
+	for (j = 0; j < repeat && !done; j++) {
+		unsigned int nwoken = 0;
+		struct timeval start, end, runtime;
+
+		/* create, launch & block all threads */
+		block_threads(worker, thread_attr);
+
+		/* make sure all threads are already blocked */
+		pthread_mutex_lock(&thread_lock);
+		while (threads_starting)
+			pthread_cond_wait(&thread_parent, &thread_lock);
+		pthread_cond_broadcast(&thread_worker);
+		pthread_mutex_unlock(&thread_lock);
+
+		usleep(100000);
+
+		/* Ok, all threads are patiently blocked, start waking folks up */
+		gettimeofday(&start, NULL);
+		while (nwoken != nthreads)
+			nwoken += futex_wake(&futex1, nwakes, FUTEX_PRIVATE_FLAG);
+		gettimeofday(&end, NULL);
+		timersub(&end, &start, &runtime);
+
+		update_stats(&wakeup_stats, nwoken);
+		update_stats(&waketime_stats, runtime.tv_usec);
+
+		if (!silent) {
+			printf("[Run %d]: Wokeup %d of %d threads in %.4f ms\n",
+			       j + 1, nwoken, nthreads, runtime.tv_usec/1e3);
+		}
+
+		for (i = 0; i < nthreads; i++) {
+			ret = pthread_join(worker[i], NULL);
+			if (ret)
+				err(EXIT_FAILURE, "pthread_join");
+		}
+
+	}
+
+	/* cleanup & report results */
+	pthread_cond_destroy(&thread_parent);
+	pthread_cond_destroy(&thread_worker);
+	pthread_mutex_destroy(&thread_lock);
+	pthread_attr_destroy(&thread_attr);
+
+	print_summary();
+
+	free(worker);
+	return ret;
+}
* Unmerged path tools/perf/bench/futex.h
* Unmerged path tools/perf/builtin-bench.c
