perf tools: Get rid of obsolete hist_entry__sort_list

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf: Get rid of obsolete hist_entry__sort_list (Jiri Olsa) [1134356]
Rebuild_FUZZ: 94.00%
commit-author Namhyung Kim <namhyung@kernel.org>
commit cfaa154b2335d4c8efdfcb65d9b12e944d1b74a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/cfaa154b.failed

Now we moved to the perf_hpp_[_sort]_list so no need to keep the old
hist_entry__sort_list and sort__first_dimension.  Also the
hist_entry__sort_snprintf() can be gone as hist_entry__snprintf()
provides the functionality.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
Link: http://lkml.kernel.org/r/1400480762-22852-18-git-send-email-namhyung@kernel.org
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
(cherry picked from commit cfaa154b2335d4c8efdfcb65d9b12e944d1b74a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/sort.c
diff --cc tools/perf/util/sort.c
index 916652af8304,d9132069d3b1..000000000000
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@@ -1115,7 -1176,18 +1112,22 @@@ static int __sort_dimension__add_hpp(st
  	return 0;
  }
  
++<<<<<<< HEAD
 +static int __sort_dimension__add(struct sort_dimension *sd, enum sort_type idx)
++=======
+ static int __sort_dimension__add_hpp_output(struct sort_dimension *sd)
+ {
+ 	struct hpp_sort_entry *hse = __sort_dimension__alloc_hpp(sd);
+ 
+ 	if (hse == NULL)
+ 		return -1;
+ 
+ 	perf_hpp__column_register(&hse->hpp);
+ 	return 0;
+ }
+ 
+ static int __sort_dimension__add(struct sort_dimension *sd)
++>>>>>>> cfaa154b2335 (perf tools: Get rid of obsolete hist_entry__sort_list)
  {
  	if (sd->taken)
  		return 0;
@@@ -1304,6 -1439,137 +1317,11 @@@ void sort__setup_elide(FILE *output
  			return;
  	}
  
- 	list_for_each_entry(se, &hist_entry__sort_list, list)
- 		se->elide = false;
+ 	perf_hpp__for_each_format(fmt) {
+ 		if (!perf_hpp__is_sort_entry(fmt))
+ 			continue;
+ 
+ 		hse = container_of(fmt, struct hpp_sort_entry, hpp);
+ 		hse->se->elide = false;
+ 	}
  }
 -
 -static int output_field_add(char *tok)
 -{
 -	unsigned int i;
 -
 -	for (i = 0; i < ARRAY_SIZE(common_sort_dimensions); i++) {
 -		struct sort_dimension *sd = &common_sort_dimensions[i];
 -
 -		if (strncasecmp(tok, sd->name, strlen(tok)))
 -			continue;
 -
 -		return __sort_dimension__add_output(sd);
 -	}
 -
 -	for (i = 0; i < ARRAY_SIZE(hpp_sort_dimensions); i++) {
 -		struct hpp_dimension *hd = &hpp_sort_dimensions[i];
 -
 -		if (strncasecmp(tok, hd->name, strlen(tok)))
 -			continue;
 -
 -		return __hpp_dimension__add_output(hd);
 -	}
 -
 -	for (i = 0; i < ARRAY_SIZE(bstack_sort_dimensions); i++) {
 -		struct sort_dimension *sd = &bstack_sort_dimensions[i];
 -
 -		if (strncasecmp(tok, sd->name, strlen(tok)))
 -			continue;
 -
 -		return __sort_dimension__add_output(sd);
 -	}
 -
 -	for (i = 0; i < ARRAY_SIZE(memory_sort_dimensions); i++) {
 -		struct sort_dimension *sd = &memory_sort_dimensions[i];
 -
 -		if (strncasecmp(tok, sd->name, strlen(tok)))
 -			continue;
 -
 -		return __sort_dimension__add_output(sd);
 -	}
 -
 -	return -ESRCH;
 -}
 -
 -static void reset_dimensions(void)
 -{
 -	unsigned int i;
 -
 -	for (i = 0; i < ARRAY_SIZE(common_sort_dimensions); i++)
 -		common_sort_dimensions[i].taken = 0;
 -
 -	for (i = 0; i < ARRAY_SIZE(hpp_sort_dimensions); i++)
 -		hpp_sort_dimensions[i].taken = 0;
 -
 -	for (i = 0; i < ARRAY_SIZE(bstack_sort_dimensions); i++)
 -		bstack_sort_dimensions[i].taken = 0;
 -
 -	for (i = 0; i < ARRAY_SIZE(memory_sort_dimensions); i++)
 -		memory_sort_dimensions[i].taken = 0;
 -}
 -
 -static int __setup_output_field(void)
 -{
 -	char *tmp, *tok, *str;
 -	int ret = 0;
 -
 -	if (field_order == NULL)
 -		return 0;
 -
 -	reset_dimensions();
 -
 -	str = strdup(field_order);
 -	if (str == NULL) {
 -		error("Not enough memory to setup output fields");
 -		return -ENOMEM;
 -	}
 -
 -	for (tok = strtok_r(str, ", ", &tmp);
 -			tok; tok = strtok_r(NULL, ", ", &tmp)) {
 -		ret = output_field_add(tok);
 -		if (ret == -EINVAL) {
 -			error("Invalid --fields key: `%s'", tok);
 -			break;
 -		} else if (ret == -ESRCH) {
 -			error("Unknown --fields key: `%s'", tok);
 -			break;
 -		}
 -	}
 -
 -	free(str);
 -	return ret;
 -}
 -
 -int setup_sorting(void)
 -{
 -	int err;
 -
 -	err = __setup_sorting();
 -	if (err < 0)
 -		return err;
 -
 -	if (parent_pattern != default_parent_pattern) {
 -		err = sort_dimension__add("parent");
 -		if (err < 0)
 -			return err;
 -	}
 -
 -	reset_dimensions();
 -
 -	/*
 -	 * perf diff doesn't use default hpp output fields.
 -	 */
 -	if (sort__mode != SORT_MODE__DIFF)
 -		perf_hpp__init();
 -
 -	err = __setup_output_field();
 -	if (err < 0)
 -		return err;
 -
 -	/* copy sort keys to output fields */
 -	perf_hpp__setup_output_field();
 -	/* and then copy output fields to sort keys */
 -	perf_hpp__append_sort_keys();
 -
 -	return 0;
 -}
diff --git a/tools/perf/ui/hist.c b/tools/perf/ui/hist.c
index 24116a48298f..538471f25312 100644
--- a/tools/perf/ui/hist.c
+++ b/tools/perf/ui/hist.c
@@ -408,47 +408,29 @@ void perf_hpp__setup_output_field(void)
 	}
 }
 
-int hist_entry__sort_snprintf(struct hist_entry *he, char *s, size_t size,
-			      struct hists *hists)
-{
-	const char *sep = symbol_conf.field_sep;
-	struct sort_entry *se;
-	int ret = 0;
-
-	list_for_each_entry(se, &hist_entry__sort_list, list) {
-		if (se->elide)
-			continue;
-
-		ret += scnprintf(s + ret, size - ret, "%s", sep ?: "  ");
-		ret += se->se_snprintf(he, s + ret, size - ret,
-				       hists__col_len(hists, se->se_width_idx));
-	}
-
-	return ret;
-}
-
 /*
  * See hists__fprintf to match the column widths
  */
 unsigned int hists__sort_list_width(struct hists *hists)
 {
 	struct perf_hpp_fmt *fmt;
-	struct sort_entry *se;
-	int i = 0, ret = 0;
+	int ret = 0;
+	bool first = true;
 	struct perf_hpp dummy_hpp;
 
 	perf_hpp__for_each_format(fmt) {
-		if (i)
+		if (perf_hpp__should_skip(fmt))
+			continue;
+
+		if (first)
+			first = false;
+		else
 			ret += 2;
 
 		ret += fmt->width(fmt, &dummy_hpp, hists_to_evsel(hists));
 	}
 
-	list_for_each_entry(se, &hist_entry__sort_list, list)
-		if (!se->elide)
-			ret += 2 + hists__col_len(hists, se->se_width_idx);
-
-	if (verbose) /* Addr + origin */
+	if (verbose && sort__has_sym) /* Addr + origin */
 		ret += 3 + BITS_PER_LONG / 4;
 
 	return ret;
diff --git a/tools/perf/ui/stdio/hist.c b/tools/perf/ui/stdio/hist.c
index f3a923a35b97..c6a0bff69236 100644
--- a/tools/perf/ui/stdio/hist.c
+++ b/tools/perf/ui/stdio/hist.c
@@ -183,7 +183,8 @@ static size_t callchain__fprintf_graph(FILE *fp, struct rb_root *root,
 			 * the symbol. No need to print it otherwise it appears as
 			 * displayed twice.
 			 */
-			if (!i++ && sort__first_dimension == SORT_SYM)
+			if (!i++ && field_order == NULL &&
+			    sort_order && !prefixcmp(sort_order, "sym"))
 				continue;
 			if (!printed) {
 				ret += callchain__fprintf_left_margin(fp, left_margin);
@@ -298,13 +299,20 @@ static size_t hist_entry__callchain_fprintf(struct hist_entry *he,
 	int left_margin = 0;
 	u64 total_period = hists->stats.total_period;
 
-	if (sort__first_dimension == SORT_COMM) {
-		struct sort_entry *se = list_first_entry(&hist_entry__sort_list,
-							 typeof(*se), list);
-		left_margin = hists__col_len(hists, se->se_width_idx);
-		left_margin -= thread__comm_len(he->thread);
-	}
+	if (field_order == NULL && (sort_order == NULL ||
+				    !prefixcmp(sort_order, "comm"))) {
+		struct perf_hpp_fmt *fmt;
+
+		perf_hpp__for_each_format(fmt) {
+			if (!perf_hpp__is_sort_entry(fmt))
+				continue;
 
+			/* must be 'comm' sort entry */
+			left_margin = fmt->width(fmt, NULL, hists_to_evsel(hists));
+			left_margin -= thread__comm_len(he->thread);
+			break;
+		}
+	}
 	return hist_entry_callchain__fprintf(he, total_period, left_margin, fp);
 }
 
* Unmerged path tools/perf/util/sort.c
