kvm: powerpc: book3s: Support building HV and PR KVM as module

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/ppc: book3s - Support building HV and PR KVM as module (Don Zickus) [1127366]
Rebuild_FUZZ: 91.67%
commit-author Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
commit 2ba9f0d8875073a2ed802fca0c25c9bfc4338439
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2ba9f0d8.failed

	Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
[agraf: squash in compile fix]
	Signed-off-by: Alexander Graf <agraf@suse.de>
(cherry picked from commit 2ba9f0d8875073a2ed802fca0c25c9bfc4338439)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s.c
#	arch/powerpc/kvm/book3s_hv.c
#	arch/powerpc/kvm/book3s_pr.c
#	arch/powerpc/kvm/powerpc.c
diff --cc arch/powerpc/kvm/book3s.c
index 807103ad2628,39d2994f9d27..000000000000
--- a/arch/powerpc/kvm/book3s.c
+++ b/arch/powerpc/kvm/book3s.c
@@@ -638,6 -700,27 +646,30 @@@ int kvm_vcpu_ioctl_set_one_reg(struct k
  	return r;
  }
  
++<<<<<<< HEAD
++=======
+ void kvmppc_core_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
+ {
+ 	kvmppc_ops->vcpu_load(vcpu, cpu);
+ }
+ 
+ void kvmppc_core_vcpu_put(struct kvm_vcpu *vcpu)
+ {
+ 	kvmppc_ops->vcpu_put(vcpu);
+ }
+ 
+ void kvmppc_set_msr(struct kvm_vcpu *vcpu, u64 msr)
+ {
+ 	kvmppc_ops->set_msr(vcpu, msr);
+ }
+ EXPORT_SYMBOL_GPL(kvmppc_set_msr);
+ 
+ int kvmppc_vcpu_run(struct kvm_run *kvm_run, struct kvm_vcpu *vcpu)
+ {
+ 	return kvmppc_ops->vcpu_run(kvm_run, vcpu);
+ }
+ 
++>>>>>>> 2ba9f0d88750 (kvm: powerpc: book3s: Support building HV and PR KVM as module)
  int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,
                                    struct kvm_translation *tr)
  {
@@@ -657,3 -740,111 +689,114 @@@ void kvmppc_decrementer_func(unsigned l
  	kvmppc_core_queue_dec(vcpu);
  	kvm_vcpu_kick(vcpu);
  }
++<<<<<<< HEAD
++=======
+ 
+ struct kvm_vcpu *kvmppc_core_vcpu_create(struct kvm *kvm, unsigned int id)
+ {
+ 	return kvmppc_ops->vcpu_create(kvm, id);
+ }
+ 
+ void kvmppc_core_vcpu_free(struct kvm_vcpu *vcpu)
+ {
+ 	kvmppc_ops->vcpu_free(vcpu);
+ }
+ 
+ int kvmppc_core_check_requests(struct kvm_vcpu *vcpu)
+ {
+ 	return kvmppc_ops->check_requests(vcpu);
+ }
+ 
+ int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)
+ {
+ 	return kvmppc_ops->get_dirty_log(kvm, log);
+ }
+ 
+ void kvmppc_core_free_memslot(struct kvm_memory_slot *free,
+ 			      struct kvm_memory_slot *dont)
+ {
+ 	kvmppc_ops->free_memslot(free, dont);
+ }
+ 
+ int kvmppc_core_create_memslot(struct kvm_memory_slot *slot,
+ 			       unsigned long npages)
+ {
+ 	return kvmppc_ops->create_memslot(slot, npages);
+ }
+ 
+ void kvmppc_core_flush_memslot(struct kvm *kvm, struct kvm_memory_slot *memslot)
+ {
+ 	kvmppc_ops->flush_memslot(kvm, memslot);
+ }
+ 
+ int kvmppc_core_prepare_memory_region(struct kvm *kvm,
+ 				struct kvm_memory_slot *memslot,
+ 				struct kvm_userspace_memory_region *mem)
+ {
+ 	return kvmppc_ops->prepare_memory_region(kvm, memslot, mem);
+ }
+ 
+ void kvmppc_core_commit_memory_region(struct kvm *kvm,
+ 				struct kvm_userspace_memory_region *mem,
+ 				const struct kvm_memory_slot *old)
+ {
+ 	kvmppc_ops->commit_memory_region(kvm, mem, old);
+ }
+ 
+ int kvm_unmap_hva(struct kvm *kvm, unsigned long hva)
+ {
+ 	return kvmppc_ops->unmap_hva(kvm, hva);
+ }
+ EXPORT_SYMBOL_GPL(kvm_unmap_hva);
+ 
+ int kvm_unmap_hva_range(struct kvm *kvm, unsigned long start, unsigned long end)
+ {
+ 	return kvmppc_ops->unmap_hva_range(kvm, start, end);
+ }
+ 
+ int kvm_age_hva(struct kvm *kvm, unsigned long hva)
+ {
+ 	return kvmppc_ops->age_hva(kvm, hva);
+ }
+ 
+ int kvm_test_age_hva(struct kvm *kvm, unsigned long hva)
+ {
+ 	return kvmppc_ops->test_age_hva(kvm, hva);
+ }
+ 
+ void kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte)
+ {
+ 	kvmppc_ops->set_spte_hva(kvm, hva, pte);
+ }
+ 
+ void kvmppc_mmu_destroy(struct kvm_vcpu *vcpu)
+ {
+ 	kvmppc_ops->mmu_destroy(vcpu);
+ }
+ 
+ int kvmppc_core_init_vm(struct kvm *kvm)
+ {
+ 
+ #ifdef CONFIG_PPC64
+ 	INIT_LIST_HEAD(&kvm->arch.spapr_tce_tables);
+ 	INIT_LIST_HEAD(&kvm->arch.rtas_tokens);
+ #endif
+ 
+ 	return kvmppc_ops->init_vm(kvm);
+ }
+ 
+ void kvmppc_core_destroy_vm(struct kvm *kvm)
+ {
+ 	kvmppc_ops->destroy_vm(kvm);
+ 
+ #ifdef CONFIG_PPC64
+ 	kvmppc_rtas_tokens_free(kvm);
+ 	WARN_ON(!list_empty(&kvm->arch.spapr_tce_tables));
+ #endif
+ }
+ 
+ int kvmppc_core_check_processor_compat(void)
+ {
+ 	return kvmppc_ops->check_processor_compat();
+ }
++>>>>>>> 2ba9f0d88750 (kvm: powerpc: book3s: Support building HV and PR KVM as module)
diff --cc arch/powerpc/kvm/book3s_hv.c
index b327916c88e9,9e954a81c078..000000000000
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@@ -52,7 -52,10 +52,8 @@@
  #include <linux/vmalloc.h>
  #include <linux/highmem.h>
  #include <linux/hugetlb.h>
+ #include <linux/module.h>
  
 -#include "book3s.h"
 -
  /* #define EXIT_DEBUG */
  /* #define EXIT_DEBUG_SIMPLE */
  /* #define EXIT_DEBUG_INT */
@@@ -2106,5 -2214,6 +2107,11 @@@ static void kvmppc_book3s_hv_exit(void
  	kvm_exit();
  }
  
++<<<<<<< HEAD
 +module_init(kvmppc_book3s_hv_init);
 +module_exit(kvmppc_book3s_hv_exit);
++=======
+ module_init(kvmppc_book3s_init_hv);
+ module_exit(kvmppc_book3s_exit_hv);
+ MODULE_LICENSE("GPL");
++>>>>>>> 2ba9f0d88750 (kvm: powerpc: book3s: Support building HV and PR KVM as module)
diff --cc arch/powerpc/kvm/book3s_pr.c
index d10e1186f935,7f583a482161..000000000000
--- a/arch/powerpc/kvm/book3s_pr.c
+++ b/arch/powerpc/kvm/book3s_pr.c
@@@ -40,8 -40,12 +40,9 @@@
  #include <linux/sched.h>
  #include <linux/vmalloc.h>
  #include <linux/highmem.h>
+ #include <linux/module.h>
  
 -#include "book3s.h"
 -
 -#define CREATE_TRACE_POINTS
 -#include "trace_pr.h"
 +#include "trace.h"
  
  /* #define EXIT_DEBUG */
  /* #define DEBUG_EXT */
@@@ -1513,5 -1581,7 +1514,12 @@@ static void kvmppc_book3s_exit(void
  	kvm_exit();
  }
  
++<<<<<<< HEAD
 +module_init(kvmppc_book3s_init);
 +module_exit(kvmppc_book3s_exit);
++=======
+ module_init(kvmppc_book3s_init_pr);
+ module_exit(kvmppc_book3s_exit_pr);
+ 
+ MODULE_LICENSE("GPL");
++>>>>>>> 2ba9f0d88750 (kvm: powerpc: book3s: Support building HV and PR KVM as module)
diff --cc arch/powerpc/kvm/powerpc.c
index f55e14cd1762,9aaa07efa4b6..000000000000
--- a/arch/powerpc/kvm/powerpc.c
+++ b/arch/powerpc/kvm/powerpc.c
@@@ -125,7 -126,7 +125,11 @@@ int kvmppc_prepare_to_enter(struct kvm_
  
  	return r;
  }
++<<<<<<< HEAD
 +#endif /* CONFIG_KVM_BOOK3S_64_HV */
++=======
+ EXPORT_SYMBOL_GPL(kvmppc_prepare_to_enter);
++>>>>>>> 2ba9f0d88750 (kvm: powerpc: book3s: Support building HV and PR KVM as module)
  
  int kvmppc_kvm_pv(struct kvm_vcpu *vcpu)
  {
diff --git a/arch/powerpc/kvm/Kconfig b/arch/powerpc/kvm/Kconfig
index 7a4d1879aa7d..141b2027189a 100644
--- a/arch/powerpc/kvm/Kconfig
+++ b/arch/powerpc/kvm/Kconfig
@@ -74,7 +74,7 @@ config KVM_BOOK3S_64
 	  If unsure, say N.
 
 config KVM_BOOK3S_64_HV
-	bool "KVM support for POWER7 and PPC970 using hypervisor mode in host"
+	tristate "KVM support for POWER7 and PPC970 using hypervisor mode in host"
 	depends on KVM_BOOK3S_64
 	select KVM_BOOK3S_HV_POSSIBLE
 	select MMU_NOTIFIER
@@ -95,8 +95,8 @@ config KVM_BOOK3S_64_HV
 	  If unsure, say N.
 
 config KVM_BOOK3S_64_PR
-	bool "KVM support without using hypervisor mode in host"
-	depends on KVM_BOOK3S_64 && !KVM_BOOK3S_64_HV
+	tristate "KVM support without using hypervisor mode in host"
+	depends on KVM_BOOK3S_64
 	select KVM_BOOK3S_PR_POSSIBLE
 	---help---
 	  Support running guest kernels in virtual machines on processors
diff --git a/arch/powerpc/kvm/Makefile b/arch/powerpc/kvm/Makefile
index fa17b337bb96..ce569b6bf4d8 100644
--- a/arch/powerpc/kvm/Makefile
+++ b/arch/powerpc/kvm/Makefile
@@ -56,7 +56,7 @@ kvm-objs-$(CONFIG_KVM_E500MC) := $(kvm-e500mc-objs)
 kvm-book3s_64-builtin-objs-$(CONFIG_KVM_BOOK3S_64_HANDLER) := \
 	book3s_64_vio_hv.o
 
-kvm-book3s_64-objs-$(CONFIG_KVM_BOOK3S_64_PR) := \
+kvm-pr-y := \
 	fpu.o \
 	book3s_paired_singles.o \
 	book3s_pr.o \
@@ -76,7 +76,7 @@ kvm-book3s_64-builtin-objs-$(CONFIG_KVM_BOOK3S_64_HANDLER) += \
 	book3s_rmhandlers.o
 endif
 
-kvm-book3s_64-objs-$(CONFIG_KVM_BOOK3S_64_HV)  += \
+kvm-hv-y += \
 	book3s_hv.o \
 	book3s_hv_interrupts.o \
 	book3s_64_mmu_hv.o
@@ -84,13 +84,15 @@ kvm-book3s_64-objs-$(CONFIG_KVM_BOOK3S_64_HV)  += \
 kvm-book3s_64-builtin-xics-objs-$(CONFIG_KVM_XICS) := \
 	book3s_hv_rm_xics.o
 
-kvm-book3s_64-builtin-objs-$(CONFIG_KVM_BOOK3S_64_HV) += \
+ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE
+kvm-book3s_64-builtin-objs-$(CONFIG_KVM_BOOK3S_64_HANDLER) += \
 	book3s_hv_rmhandlers.o \
 	book3s_hv_rm_mmu.o \
 	book3s_hv_ras.o \
 	book3s_hv_builtin.o \
 	book3s_hv_cma.o \
 	$(kvm-book3s_64-builtin-xics-objs-y)
+endif
 
 kvm-book3s_64-objs-$(CONFIG_KVM_XICS) += \
 	book3s_xics.o
@@ -131,4 +133,7 @@ obj-$(CONFIG_KVM_E500MC) += kvm.o
 obj-$(CONFIG_KVM_BOOK3S_64) += kvm.o
 obj-$(CONFIG_KVM_BOOK3S_32) += kvm.o
 
+obj-$(CONFIG_KVM_BOOK3S_64_PR) += kvm-pr.o
+obj-$(CONFIG_KVM_BOOK3S_64_HV) += kvm-hv.o
+
 obj-y += $(kvm-book3s_64-builtin-objs-y)
* Unmerged path arch/powerpc/kvm/book3s.c
diff --git a/arch/powerpc/kvm/book3s_emulate.c b/arch/powerpc/kvm/book3s_emulate.c
index 2a7210cb2844..9f0dc1b0c09c 100644
--- a/arch/powerpc/kvm/book3s_emulate.c
+++ b/arch/powerpc/kvm/book3s_emulate.c
@@ -172,7 +172,7 @@ int kvmppc_core_emulate_op(struct kvm_run *run, struct kvm_vcpu *vcpu,
 			vcpu->arch.mmu.tlbie(vcpu, addr, large);
 			break;
 		}
-#ifdef CONFIG_KVM_BOOK3S_64_PR
+#ifdef CONFIG_PPC_BOOK3S_64
 		case OP_31_XOP_FAKE_SC1:
 		{
 			/* SC 1 papr hypercalls */
* Unmerged path arch/powerpc/kvm/book3s_hv.c
* Unmerged path arch/powerpc/kvm/book3s_pr.c
diff --git a/arch/powerpc/kvm/book3s_rtas.c b/arch/powerpc/kvm/book3s_rtas.c
index 3219ba895246..cf95cdef73c9 100644
--- a/arch/powerpc/kvm/book3s_rtas.c
+++ b/arch/powerpc/kvm/book3s_rtas.c
@@ -260,6 +260,7 @@ fail:
 	 */
 	return rc;
 }
+EXPORT_SYMBOL_GPL(kvmppc_rtas_hcall);
 
 void kvmppc_rtas_tokens_free(struct kvm *kvm)
 {
diff --git a/arch/powerpc/kvm/book3s_xics.c b/arch/powerpc/kvm/book3s_xics.c
index a3a5cb8ee7ea..5b1a09c5fb1e 100644
--- a/arch/powerpc/kvm/book3s_xics.c
+++ b/arch/powerpc/kvm/book3s_xics.c
@@ -840,6 +840,7 @@ int kvmppc_xics_hcall(struct kvm_vcpu *vcpu, u32 req)
 
 	return rc;
 }
+EXPORT_SYMBOL_GPL(kvmppc_xics_hcall);
 
 
 /* -- Initialisation code etc. -- */
diff --git a/arch/powerpc/kvm/emulate.c b/arch/powerpc/kvm/emulate.c
index 6d20566d074e..d26e09a419fe 100644
--- a/arch/powerpc/kvm/emulate.c
+++ b/arch/powerpc/kvm/emulate.c
@@ -480,3 +480,4 @@ int kvmppc_emulate_instruction(struct kvm_run *run, struct kvm_vcpu *vcpu)
 
 	return emulated;
 }
+EXPORT_SYMBOL_GPL(kvmppc_emulate_instruction);
* Unmerged path arch/powerpc/kvm/powerpc.c
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 352075a32048..3534c4aeb62d 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -192,6 +192,7 @@ void kvm_flush_remote_tlbs(struct kvm *kvm)
 		++kvm->stat.remote_tlb_flush;
 	cmpxchg(&kvm->tlbs_dirty, dirty_count, 0);
 }
+EXPORT_SYMBOL_GPL(kvm_flush_remote_tlbs);
 
 void kvm_reload_remote_mmus(struct kvm *kvm)
 {
@@ -975,6 +976,7 @@ int kvm_get_dirty_log(struct kvm *kvm,
 out:
 	return r;
 }
+EXPORT_SYMBOL_GPL(kvm_get_dirty_log);
 
 bool kvm_largepages_enabled(void)
 {
@@ -1660,6 +1662,7 @@ void mark_page_dirty(struct kvm *kvm, gfn_t gfn)
 	memslot = gfn_to_memslot(kvm, gfn);
 	mark_page_dirty_in_slot(kvm, memslot, gfn);
 }
+EXPORT_SYMBOL_GPL(mark_page_dirty);
 
 /*
  * The vCPU has executed a HLT instruction with in-kernel mode enabled.
@@ -1685,6 +1688,7 @@ void kvm_vcpu_block(struct kvm_vcpu *vcpu)
 
 	finish_wait(&vcpu->wq, &wait);
 }
+EXPORT_SYMBOL_GPL(kvm_vcpu_block);
 
 #ifndef CONFIG_S390
 /*
