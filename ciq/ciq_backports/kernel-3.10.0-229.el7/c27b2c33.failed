ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug: Introduce common hotplug function acpi_device_hotplug() (Myron Stowe) [1128632]
Rebuild_FUZZ: 94.81%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit c27b2c33b6215eeb3d5c290ac889ab6d543f6207
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/c27b2c33.failed

Modify the common ACPI device hotplug code to always queue up the
same function, acpi_device_hotplug(), using acpi_hotplug_execute()
and make the PCI host bridge hotplug code use that function too for
device hot removal.

This allows some code duplication to be reduced and a race condition
where the relevant ACPI handle may become invalid between the
notification handler and the function queued up by it via
acpi_hotplug_execute() to be avoided.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit c27b2c33b6215eeb3d5c290ac889ab6d543f6207)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/internal.h
#	drivers/acpi/scan.c
diff --cc drivers/acpi/internal.h
index f9b49d659abb,a0d42cf5b0c5..000000000000
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@@ -86,7 -89,8 +86,12 @@@ void acpi_device_add_finalize(struct ac
  void acpi_free_pnp_ids(struct acpi_device_pnp *pnp);
  int acpi_bind_one(struct device *dev, acpi_handle handle);
  int acpi_unbind_one(struct device *dev);
++<<<<<<< HEAD
 +void acpi_bus_device_eject(struct acpi_device *device, u32 ost_src);
++=======
+ void acpi_device_hotplug(void *data, u32 ost_src);
+ bool acpi_device_is_present(struct acpi_device *adev);
++>>>>>>> c27b2c33b621 (ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug())
  
  /* --------------------------------------------------------------------------
                                    Power Resource
diff --cc drivers/acpi/scan.c
index 2bbdeee33be4,dd0ff9de9277..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -255,10 -253,6 +249,13 @@@ static int acpi_scan_hot_remove(struct 
  
  	acpi_bus_trim(device);
  
++<<<<<<< HEAD
 +	/* Device node has been unregistered. */
 +	put_device(&device->dev);
 +	device = NULL;
 +
++=======
++>>>>>>> c27b2c33b621 (ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug())
  	acpi_evaluate_lck(handle, 0);
  	/*
  	 * TBD: _EJD support.
@@@ -285,73 -279,74 +282,111 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +void acpi_bus_device_eject(struct acpi_device *device, u32 ost_src)
 +{
 +	acpi_handle handle = device->handle;
 +	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
++=======
+ static int acpi_scan_device_check(struct acpi_device *adev)
+ {
++>>>>>>> c27b2c33b621 (ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug())
  	int error;
  
- 	lock_device_hotplug();
- 	mutex_lock(&acpi_scan_lock);
- 
- 	if (ost_src == ACPI_NOTIFY_EJECT_REQUEST)
- 		acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
- 					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
- 
- 	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
- 		kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
- 
- 	error = acpi_scan_hot_remove(device);
- 	if (error == -EPERM) {
- 		goto err_support;
- 	} else if (error) {
- 		goto err_out;
+ 	/*
+ 	 * This function is only called for device objects for which matching
+ 	 * scan handlers exist.  The only situation in which the scan handler is
+ 	 * not attached to this device object yet is when the device has just
+ 	 * appeared (either it wasn't present at all before or it was removed
+ 	 * and then added again).
+ 	 */
+ 	if (adev->handler) {
+ 		dev_warn(&adev->dev, "Already enumerated\n");
+ 		return -EBUSY;
  	}
- 
-  out:
- 	mutex_unlock(&acpi_scan_lock);
- 	unlock_device_hotplug();
- 	return;
- 
-  err_support:
- 	ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
-  err_out:
- 	acpi_evaluate_hotplug_ost(handle, ost_src, ost_code, NULL);
- 	goto out;
+ 	error = acpi_bus_scan(adev->handle);
+ 	if (error) {
+ 		dev_warn(&adev->dev, "Namespace scan failure\n");
+ 		return error;
+ 	}
+ 	if (adev->handler) {
+ 		if (adev->handler->hotplug.mode == AHM_CONTAINER)
+ 			kobject_uevent(&adev->dev.kobj, KOBJ_ONLINE);
+ 	} else {
+ 		dev_warn(&adev->dev, "Enumeration failure\n");
+ 		return -ENODEV;
+ 	}
+ 	return 0;
  }
  
++<<<<<<< HEAD
 +static void acpi_scan_bus_device_check(acpi_handle handle, u32 ost_source)
 +{
 +	struct acpi_device *device = NULL;
++=======
+ void acpi_device_hotplug(void *data, u32 src)
+ {
++>>>>>>> c27b2c33b621 (ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug())
  	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
+ 	struct acpi_device *adev = data;
  	int error;
  
  	lock_device_hotplug();
  	mutex_lock(&acpi_scan_lock);
  
++<<<<<<< HEAD
 +	if (ost_source != ACPI_NOTIFY_BUS_CHECK) {
 +		acpi_bus_get_device(handle, &device);
 +		if (device) {
 +			dev_warn(&device->dev, "Attempt to re-insert\n");
 +			goto out;
 +		}
 +	}
 +	error = acpi_bus_scan(handle);
 +	if (error) {
 +		acpi_handle_warn(handle, "Namespace scan failure\n");
++=======
+ 	/*
+ 	 * The device object's ACPI handle cannot become invalid as long as we
+ 	 * are holding acpi_scan_lock, but it may have become invalid before
+ 	 * that lock was acquired.
+ 	 */
+ 	if (adev->handle == INVALID_ACPI_HANDLE)
++>>>>>>> c27b2c33b621 (ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug())
  		goto out;
+ 
+ 	switch (src) {
+ 	case ACPI_NOTIFY_BUS_CHECK:
+ 		error = acpi_bus_scan(adev->handle);
+ 		break;
+ 	case ACPI_NOTIFY_DEVICE_CHECK:
+ 		error = acpi_scan_device_check(adev);
+ 		break;
+ 	case ACPI_NOTIFY_EJECT_REQUEST:
+ 	case ACPI_OST_EC_OSPM_EJECT:
+ 		error = acpi_scan_hot_remove(adev);
+ 		break;
+ 	default:
+ 		error = -EINVAL;
+ 		break;
  	}
++<<<<<<< HEAD
 +	error = acpi_bus_get_device(handle, &device);
 +	if (error) {
 +		acpi_handle_warn(handle, "Missing device node object\n");
 +		goto out;
 +	}
 +	ost_code = ACPI_OST_SC_SUCCESS;
 +	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
 +		kobject_uevent(&device->dev.kobj, KOBJ_ONLINE);
++=======
+ 	if (!error)
+ 		ost_code = ACPI_OST_SC_SUCCESS;
++>>>>>>> c27b2c33b621 (ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug())
  
   out:
- 	acpi_evaluate_hotplug_ost(handle, ost_source, ost_code, NULL);
+ 	acpi_evaluate_hotplug_ost(adev->handle, src, ost_code, NULL);
+ 	put_device(&adev->dev);
  	mutex_unlock(&acpi_scan_lock);
  	unlock_device_hotplug();
  }
@@@ -412,8 -358,8 +447,13 @@@ static void acpi_hotplug_notify_cb(acpi
  	struct acpi_device *adev;
  	acpi_status status;
  
++<<<<<<< HEAD
 +	if (!handler->hotplug.enabled)
 +		return acpi_hotplug_unsupported(handle, type);
++=======
+ 	if (acpi_bus_get_device(handle, &adev))
+ 		goto err_out;
++>>>>>>> c27b2c33b621 (ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug())
  
  	switch (type) {
  	case ACPI_NOTIFY_BUS_CHECK:
@@@ -426,28 -370,27 +466,46 @@@
  		break;
  	case ACPI_NOTIFY_EJECT_REQUEST:
  		acpi_handle_debug(handle, "ACPI_NOTIFY_EJECT_REQUEST event\n");
++<<<<<<< HEAD
 +		if (acpi_bus_get_device(handle, &adev))
 +			goto err_out;
 +
 +		get_device(&adev->dev);
 +		callback = acpi_bus_hot_remove_device;
 +		status = acpi_os_hotplug_execute(callback, adev);
 +		if (ACPI_SUCCESS(status))
 +			return;
 +
 +		put_device(&adev->dev);
 +		goto err_out;
++=======
+ 		if (!handler->hotplug.enabled) {
+ 			acpi_handle_err(handle, "Eject disabled\n");
+ 			ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
+ 			goto err_out;
+ 		}
+ 		acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
+ 					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
+ 		break;
++>>>>>>> c27b2c33b621 (ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug())
  	default:
  		/* non-hotplug event; possibly handled by other handler */
  		return;
  	}
++<<<<<<< HEAD
 +	status = acpi_os_hotplug_execute(callback, handle);
++=======
+ 	get_device(&adev->dev);
+ 	status = acpi_hotplug_execute(acpi_device_hotplug, adev, type);
++>>>>>>> c27b2c33b621 (ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug())
  	if (ACPI_SUCCESS(status))
  		return;
  
+ 	put_device(&adev->dev);
+ 
   err_out:
 -	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
 +	acpi_evaluate_hotplug_ost(handle, type,
 +				  ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);
  }
  
  static ssize_t real_power_state_show(struct device *dev,
@@@ -503,7 -441,8 +561,12 @@@ acpi_eject_store(struct device *d, stru
  	acpi_evaluate_hotplug_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,
  				  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
  	get_device(&acpi_device->dev);
++<<<<<<< HEAD
 +	status = acpi_os_hotplug_execute(acpi_eject_store_work, acpi_device);
++=======
+ 	status = acpi_hotplug_execute(acpi_device_hotplug, acpi_device,
+ 				      ACPI_OST_EC_OSPM_EJECT);
++>>>>>>> c27b2c33b621 (ACPI / hotplug: Introduce common hotplug function acpi_device_hotplug())
  	if (ACPI_SUCCESS(status))
  		return count;
  
* Unmerged path drivers/acpi/internal.h
diff --git a/drivers/acpi/pci_root.c b/drivers/acpi/pci_root.c
index 652517550b2a..2557b873f8dd 100644
--- a/drivers/acpi/pci_root.c
+++ b/drivers/acpi/pci_root.c
@@ -695,11 +695,13 @@ static void _handle_hotplug_event_root(struct work_struct *work)
 		if (!root)
 			break;
 
+		acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
+					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 		get_device(&root->device->dev);
 
 		acpi_scan_lock_release();
 
-		acpi_bus_device_eject(root->device, ACPI_NOTIFY_EJECT_REQUEST);
+		acpi_device_hotplug(root->device, ACPI_NOTIFY_EJECT_REQUEST);
 		return;
 	default:
 		acpi_handle_warn(handle,
* Unmerged path drivers/acpi/scan.c
