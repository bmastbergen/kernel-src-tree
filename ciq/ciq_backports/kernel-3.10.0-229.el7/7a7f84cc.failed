drm/i915: Ignore long hpds on eDP ports

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] i915: Ignore long hpds on eDP ports (Rob Clark) [1173317]
Rebuild_FUZZ: 94.59%
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit 7a7f84ccb82e542c845c43f604665ccea1247866
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/7a7f84cc.failed

Turning vdd on/off can generate a long hpd pulse on eDP ports. In order
to handle hpd we would need to turn on vdd to perform aux transfers.
This would lead to an endless cycle of
"vdd off -> long hpd -> vdd on -> detect -> vdd off -> ..."

So ignore long hpd pulses on eDP ports. eDP panels should be physically
tied to the machine anyway so they should not actually disappear and
thus don't need long hpd handling. Short hpds are still needed for link
re-train and whatnot so we can't just turn off the hpd interrupt
entirely for eDP ports. Perhaps we could turn it off whenever the panel
is disabled, but just ignoring the long hpd seems sufficient.

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Cc: stable@vger.kernel.org
	Reviewed-by: Dave Airlie <airlied@redhat.com>
	Reviewed-by: Todd Previte <tprevite@gmail.com>
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
(cherry picked from commit 7a7f84ccb82e542c845c43f604665ccea1247866)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_dp.c
diff --cc drivers/gpu/drm/i915/intel_dp.c
index a4f2fedc61d6,464d8ad9bb71..000000000000
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@@ -3093,12 -4478,93 +3093,95 @@@ static const struct drm_encoder_funcs i
  	.destroy = intel_dp_encoder_destroy,
  };
  
 -void
 +static void
  intel_dp_hot_plug(struct intel_encoder *intel_encoder)
  {
 -	return;
 -}
 +	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);
  
++<<<<<<< HEAD
 +	intel_dp_check_link_status(intel_dp);
++=======
+ bool
+ intel_dp_hpd_pulse(struct intel_digital_port *intel_dig_port, bool long_hpd)
+ {
+ 	struct intel_dp *intel_dp = &intel_dig_port->dp;
+ 	struct intel_encoder *intel_encoder = &intel_dig_port->base;
+ 	struct drm_device *dev = intel_dig_port->base.base.dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	enum intel_display_power_domain power_domain;
+ 	bool ret = true;
+ 
+ 	if (intel_dig_port->base.type != INTEL_OUTPUT_EDP)
+ 		intel_dig_port->base.type = INTEL_OUTPUT_DISPLAYPORT;
+ 
+ 	if (long_hpd && intel_dig_port->base.type == INTEL_OUTPUT_EDP) {
+ 		/*
+ 		 * vdd off can generate a long pulse on eDP which
+ 		 * would require vdd on to handle it, and thus we
+ 		 * would end up in an endless cycle of
+ 		 * "vdd off -> long hpd -> vdd on -> detect -> vdd off -> ..."
+ 		 */
+ 		DRM_DEBUG_KMS("ignoring long hpd on eDP port %c\n",
+ 			      port_name(intel_dig_port->port));
+ 		return false;
+ 	}
+ 
+ 	DRM_DEBUG_KMS("got hpd irq on port %c - %s\n",
+ 		      port_name(intel_dig_port->port),
+ 		      long_hpd ? "long" : "short");
+ 
+ 	power_domain = intel_display_port_power_domain(intel_encoder);
+ 	intel_display_power_get(dev_priv, power_domain);
+ 
+ 	if (long_hpd) {
+ 
+ 		if (HAS_PCH_SPLIT(dev)) {
+ 			if (!ibx_digital_port_connected(dev_priv, intel_dig_port))
+ 				goto mst_fail;
+ 		} else {
+ 			if (g4x_digital_port_connected(dev, intel_dig_port) != 1)
+ 				goto mst_fail;
+ 		}
+ 
+ 		if (!intel_dp_get_dpcd(intel_dp)) {
+ 			goto mst_fail;
+ 		}
+ 
+ 		intel_dp_probe_oui(intel_dp);
+ 
+ 		if (!intel_dp_probe_mst(intel_dp))
+ 			goto mst_fail;
+ 
+ 	} else {
+ 		if (intel_dp->is_mst) {
+ 			if (intel_dp_check_mst_status(intel_dp) == -EINVAL)
+ 				goto mst_fail;
+ 		}
+ 
+ 		if (!intel_dp->is_mst) {
+ 			/*
+ 			 * we'll check the link status via the normal hot plug path later -
+ 			 * but for short hpds we should check it now
+ 			 */
+ 			drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
+ 			intel_dp_check_link_status(intel_dp);
+ 			drm_modeset_unlock(&dev->mode_config.connection_mutex);
+ 		}
+ 	}
+ 	ret = false;
+ 	goto put_power;
+ mst_fail:
+ 	/* if we were in MST mode, and device is not there get out of MST mode */
+ 	if (intel_dp->is_mst) {
+ 		DRM_DEBUG_KMS("MST device may have disappeared %d vs %d\n", intel_dp->is_mst, intel_dp->mst_mgr.mst_state);
+ 		intel_dp->is_mst = false;
+ 		drm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr, intel_dp->is_mst);
+ 	}
+ put_power:
+ 	intel_display_power_put(dev_priv, power_domain);
+ 
+ 	return ret;
++>>>>>>> 7a7f84ccb82e (drm/i915: Ignore long hpds on eDP ports)
  }
  
  /* Return which DP Port should be selected for Transcoder DP control */
* Unmerged path drivers/gpu/drm/i915/intel_dp.c
