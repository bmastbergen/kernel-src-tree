PCI: Remove unnecessary braces

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Remove unnecessary braces (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 90.91%
commit-author Nicholas Johnson <nicholas.johnson-opensource@outlook.com.au>
commit 3d67a2dbdbe9400523164d8557a7a5fb7ef83c7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3d67a2db.failed

Remove unnecessary braces in pci_bus_distribute_available_resources().  No
functional changes.

Link: https://lore.kernel.org/r/PSXP216MB0438061CB4442460BB92A75F803C0@PSXP216MB0438.KORP216.PROD.OUTLOOK.COM
	Signed-off-by: Nicholas Johnson <nicholas.johnson-opensource@outlook.com.au>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
	Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 3d67a2dbdbe9400523164d8557a7a5fb7ef83c7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/setup-bus.c
diff --cc drivers/pci/setup-bus.c
index 2e344a5581ae,16300ad5e277..000000000000
--- a/drivers/pci/setup-bus.c
+++ b/drivers/pci/setup-bus.c
@@@ -1556,8 -1829,186 +1556,189 @@@ void __init pci_assign_unassigned_resou
  {
  	struct pci_bus *root_bus;
  
 -	list_for_each_entry(root_bus, &pci_root_buses, node) {
 +	list_for_each_entry(root_bus, &pci_root_buses, node)
  		pci_assign_unassigned_root_bus_resources(root_bus);
++<<<<<<< HEAD
++=======
+ 
+ 		/* Make sure the root bridge has a companion ACPI device */
+ 		if (ACPI_HANDLE(root_bus->bridge))
+ 			acpi_ioapic_add(ACPI_HANDLE(root_bus->bridge));
+ 	}
+ }
+ 
+ static void extend_bridge_window(struct pci_dev *bridge, struct resource *res,
+ 				 struct list_head *add_list,
+ 				 resource_size_t available)
+ {
+ 	struct pci_dev_resource *dev_res;
+ 
+ 	if (res->parent)
+ 		return;
+ 
+ 	if (resource_size(res) >= available)
+ 		return;
+ 
+ 	dev_res = res_to_dev_res(add_list, res);
+ 	if (!dev_res)
+ 		return;
+ 
+ 	/* Is there room to extend the window? */
+ 	if (available - resource_size(res) <= dev_res->add_size)
+ 		return;
+ 
+ 	dev_res->add_size = available - resource_size(res);
+ 	pci_dbg(bridge, "bridge window %pR extended by %pa\n", res,
+ 		&dev_res->add_size);
+ }
+ 
+ static void pci_bus_distribute_available_resources(struct pci_bus *bus,
+ 					    struct list_head *add_list,
+ 					    resource_size_t available_io,
+ 					    resource_size_t available_mmio,
+ 					    resource_size_t available_mmio_pref)
+ {
+ 	resource_size_t remaining_io, remaining_mmio, remaining_mmio_pref;
+ 	unsigned int normal_bridges = 0, hotplug_bridges = 0;
+ 	struct resource *io_res, *mmio_res, *mmio_pref_res;
+ 	struct pci_dev *dev, *bridge = bus->self;
+ 
+ 	io_res = &bridge->resource[PCI_BRIDGE_RESOURCES + 0];
+ 	mmio_res = &bridge->resource[PCI_BRIDGE_RESOURCES + 1];
+ 	mmio_pref_res = &bridge->resource[PCI_BRIDGE_RESOURCES + 2];
+ 
+ 	/*
+ 	 * Update additional resource list (add_list) to fill all the
+ 	 * extra resource space available for this port except the space
+ 	 * calculated in __pci_bus_size_bridges() which covers all the
+ 	 * devices currently connected to the port and below.
+ 	 */
+ 	extend_bridge_window(bridge, io_res, add_list, available_io);
+ 	extend_bridge_window(bridge, mmio_res, add_list, available_mmio);
+ 	extend_bridge_window(bridge, mmio_pref_res, add_list,
+ 			     available_mmio_pref);
+ 
+ 	/*
+ 	 * Calculate how many hotplug bridges and normal bridges there
+ 	 * are on this bus.  We will distribute the additional available
+ 	 * resources between hotplug bridges.
+ 	 */
+ 	for_each_pci_bridge(dev, bus) {
+ 		if (dev->is_hotplug_bridge)
+ 			hotplug_bridges++;
+ 		else
+ 			normal_bridges++;
+ 	}
+ 
+ 	/*
+ 	 * There is only one bridge on the bus so it gets all available
+ 	 * resources which it can then distribute to the possible hotplug
+ 	 * bridges below.
+ 	 */
+ 	if (hotplug_bridges + normal_bridges == 1) {
+ 		dev = list_first_entry(&bus->devices, struct pci_dev, bus_list);
+ 		if (dev->subordinate)
+ 			pci_bus_distribute_available_resources(dev->subordinate,
+ 				add_list, available_io, available_mmio,
+ 				available_mmio_pref);
+ 		return;
+ 	}
+ 
+ 	if (hotplug_bridges == 0)
+ 		return;
+ 
+ 	/*
+ 	 * Calculate the total amount of extra resource space we can
+ 	 * pass to bridges below this one.  This is basically the
+ 	 * extra space reduced by the minimal required space for the
+ 	 * non-hotplug bridges.
+ 	 */
+ 	remaining_io = available_io;
+ 	remaining_mmio = available_mmio;
+ 	remaining_mmio_pref = available_mmio_pref;
+ 
+ 	for_each_pci_bridge(dev, bus) {
+ 		const struct resource *res;
+ 
+ 		if (dev->is_hotplug_bridge)
+ 			continue;
+ 
+ 		/*
+ 		 * Reduce the available resource space by what the
+ 		 * bridge and devices below it occupy.
+ 		 */
+ 		res = &dev->resource[PCI_BRIDGE_RESOURCES + 0];
+ 		if (!res->parent && available_io > resource_size(res))
+ 			remaining_io -= resource_size(res);
+ 
+ 		res = &dev->resource[PCI_BRIDGE_RESOURCES + 1];
+ 		if (!res->parent && available_mmio > resource_size(res))
+ 			remaining_mmio -= resource_size(res);
+ 
+ 		res = &dev->resource[PCI_BRIDGE_RESOURCES + 2];
+ 		if (!res->parent && available_mmio_pref > resource_size(res))
+ 			remaining_mmio_pref -= resource_size(res);
+ 	}
+ 
+ 	/*
+ 	 * Go over devices on this bus and distribute the remaining
+ 	 * resource space between hotplug bridges.
+ 	 */
+ 	for_each_pci_bridge(dev, bus) {
+ 		resource_size_t align, io, mmio, mmio_pref;
+ 		struct pci_bus *b;
+ 
+ 		b = dev->subordinate;
+ 		if (!b || !dev->is_hotplug_bridge)
+ 			continue;
+ 
+ 		/*
+ 		 * Distribute available extra resources equally between
+ 		 * hotplug-capable downstream ports taking alignment into
+ 		 * account.
+ 		 */
+ 		align = pci_resource_alignment(bridge, io_res);
+ 		io = div64_ul(available_io, hotplug_bridges);
+ 		io = min(ALIGN(io, align), remaining_io);
+ 		remaining_io -= io;
+ 
+ 		align = pci_resource_alignment(bridge, mmio_res);
+ 		mmio = div64_ul(available_mmio, hotplug_bridges);
+ 		mmio = min(ALIGN(mmio, align), remaining_mmio);
+ 		remaining_mmio -= mmio;
+ 
+ 		align = pci_resource_alignment(bridge, mmio_pref_res);
+ 		mmio_pref = div64_ul(available_mmio_pref, hotplug_bridges);
+ 		mmio_pref = min(ALIGN(mmio_pref, align), remaining_mmio_pref);
+ 		remaining_mmio_pref -= mmio_pref;
+ 
+ 		pci_bus_distribute_available_resources(b, add_list, io, mmio,
+ 						       mmio_pref);
+ 	}
+ }
+ 
+ static void pci_bridge_distribute_available_resources(struct pci_dev *bridge,
+ 						     struct list_head *add_list)
+ {
+ 	resource_size_t available_io, available_mmio, available_mmio_pref;
+ 	const struct resource *res;
+ 
+ 	if (!bridge->is_hotplug_bridge)
+ 		return;
+ 
+ 	/* Take the initial extra resources from the hotplug port */
+ 	res = &bridge->resource[PCI_BRIDGE_RESOURCES + 0];
+ 	available_io = resource_size(res);
+ 	res = &bridge->resource[PCI_BRIDGE_RESOURCES + 1];
+ 	available_mmio = resource_size(res);
+ 	res = &bridge->resource[PCI_BRIDGE_RESOURCES + 2];
+ 	available_mmio_pref = resource_size(res);
+ 
+ 	pci_bus_distribute_available_resources(bridge->subordinate,
+ 					       add_list, available_io,
+ 					       available_mmio,
+ 					       available_mmio_pref);
++>>>>>>> 3d67a2dbdbe9 (PCI: Remove unnecessary braces)
  }
  
  void pci_assign_unassigned_bridge_resources(struct pci_dev *bridge)
* Unmerged path drivers/pci/setup-bus.c
