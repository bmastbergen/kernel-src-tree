net_dma: revert 'copied_early'

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Dan Williams <dan.j.williams@intel.com>
commit d27f9bc104375a0a835cf68bb88fc9cec69125da
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d27f9bc1.failed

Now that tcp_dma_try_early_copy() is gone nothing ever sets
copied_early.

Also reverts "53240c208776 tcp: Fix possible double-ack w/ user dma"
since it is no longer necessary.

	Cc: Ali Saidi <saidi@engin.umich.edu>
	Cc: James Morris <jmorris@namei.org>
	Cc: Patrick McHardy <kaber@trash.net>
	Cc: Eric Dumazet <edumazet@google.com>
	Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
	Cc: Hideaki YOSHIFUJI <yoshfuji@linux-ipv6.org>
	Cc: Neal Cardwell <ncardwell@google.com>
	Reported-by: Dave Jones <davej@redhat.com>
	Acked-by: David S. Miller <davem@davemloft.net>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
(cherry picked from commit d27f9bc104375a0a835cf68bb88fc9cec69125da)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
diff --cc net/ipv4/tcp_input.c
index 35158b5fc07c,1da0ade98236..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -5194,27 -5148,15 +5194,31 @@@ int tcp_rcv_established(struct sock *sk
  			}
  		} else {
  			int eaten = 0;
- 			int copied_early = 0;
  			bool fragstolen = false;
  
++<<<<<<< HEAD
 +			if (tp->copied_seq == tp->rcv_nxt &&
 +			    len - tcp_header_len <= tp->ucopy.len) {
 +#ifdef CONFIG_NET_DMA
 +				if (tp->ucopy.task == current &&
 +				    sock_owned_by_user(sk) &&
 +				    tcp_dma_try_early_copy(sk, skb, tcp_header_len)) {
 +					copied_early = 1;
 +					eaten = 1;
 +				}
 +#endif
 +				if (tp->ucopy.task == current &&
 +				    sock_owned_by_user(sk) && !copied_early) {
 +					__set_current_state(TASK_RUNNING);
- 
- 					if (!tcp_copy_to_iovec(sk, skb, tcp_header_len))
- 						eaten = 1;
- 				}
- 				if (eaten) {
++=======
+ 			if (tp->ucopy.task == current &&
+ 			    tp->copied_seq == tp->rcv_nxt &&
+ 			    len - tcp_header_len <= tp->ucopy.len &&
+ 			    sock_owned_by_user(sk)) {
+ 				__set_current_state(TASK_RUNNING);
++>>>>>>> d27f9bc10437 (net_dma: revert 'copied_early')
+ 
+ 				if (!tcp_copy_to_iovec(sk, skb, tcp_header_len)) {
  					/* Predicted packet is in window by definition.
  					 * seq == rcv_nxt and rcv_wup <= rcv_nxt.
  					 * Hence, check seq<=rcv_wup reduces to:
@@@ -5269,14 -5210,8 +5272,13 @@@
  					goto no_ack;
  			}
  
- 			if (!copied_early || tp->rcv_nxt != tp->rcv_wup)
- 				__tcp_ack_snd_check(sk, 0);
+ 			__tcp_ack_snd_check(sk, 0);
  no_ack:
 +#ifdef CONFIG_NET_DMA
 +			if (copied_early)
 +				__skb_queue_tail(&sk->sk_async_wait_queue, skb);
 +			else
 +#endif
  			if (eaten)
  				kfree_skb_partial(skb, fragstolen);
  			sk->sk_data_ready(sk, 0);
* Unmerged path net/ipv4/tcp_input.c
