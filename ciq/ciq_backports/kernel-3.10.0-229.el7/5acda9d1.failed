bdi: avoid oops on device removal

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Jan Kara <jack@suse.cz>
commit 5acda9d12dcf1ad0d9a5a2a7c646de3472fa7555
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5acda9d1.failed

After commit 839a8e8660b6 ("writeback: replace custom worker pool
implementation with unbound workqueue") when device is removed while we
are writing to it we crash in bdi_writeback_workfn() ->
set_worker_desc() because bdi->dev is NULL.

This can happen because even though bdi_unregister() cancels all pending
flushing work, nothing really prevents new ones from being queued from
balance_dirty_pages() or other places.

Fix the problem by clearing BDI_registered bit in bdi_unregister() and
checking it before scheduling of any flushing work.

Fixes: 839a8e8660b6777e7fe4e80af1a048aebe2b5977

	Reviewed-by: Tejun Heo <tj@kernel.org>
	Signed-off-by: Jan Kara <jack@suse.cz>
	Cc: Derek Basehore <dbasehore@chromium.org>
	Cc: Jens Axboe <axboe@kernel.dk>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 5acda9d12dcf1ad0d9a5a2a7c646de3472fa7555)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/fs-writeback.c
diff --cc fs/fs-writeback.c
index 1e61665a6e57,a16315957ef3..000000000000
--- a/fs/fs-writeback.c
+++ b/fs/fs-writeback.c
@@@ -88,7 -89,13 +88,17 @@@ static inline struct inode *wb_inode(st
  #define CREATE_TRACE_POINTS
  #include <trace/events/writeback.h>
  
++<<<<<<< HEAD
 +EXPORT_TRACEPOINT_SYMBOL_GPL(wbc_writepage);
++=======
+ static void bdi_wakeup_thread(struct backing_dev_info *bdi)
+ {
+ 	spin_lock_bh(&bdi->wb_lock);
+ 	if (test_bit(BDI_registered, &bdi->state))
+ 		mod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);
+ 	spin_unlock_bh(&bdi->wb_lock);
+ }
++>>>>>>> 5acda9d12dcf (bdi: avoid oops on device removal)
  
  static void bdi_queue_work(struct backing_dev_info *bdi,
  			   struct wb_writeback_work *work)
* Unmerged path fs/fs-writeback.c
diff --git a/include/linux/backing-dev.h b/include/linux/backing-dev.h
index 5f66d519a726..a4cf599ecfc8 100644
--- a/include/linux/backing-dev.h
+++ b/include/linux/backing-dev.h
@@ -95,7 +95,7 @@ struct backing_dev_info {
 	unsigned int max_ratio, max_prop_frac;
 
 	struct bdi_writeback wb;  /* default writeback info for this bdi */
-	spinlock_t wb_lock;	  /* protects work_list */
+	spinlock_t wb_lock;	  /* protects work_list & wb.dwork scheduling */
 
 	struct list_head work_list;
 
diff --git a/mm/backing-dev.c b/mm/backing-dev.c
index 4f81435eeef9..0f9feb4a2726 100644
--- a/mm/backing-dev.c
+++ b/mm/backing-dev.c
@@ -294,7 +294,10 @@ void bdi_wakeup_thread_delayed(struct backing_dev_info *bdi)
 	unsigned long timeout;
 
 	timeout = msecs_to_jiffies(dirty_writeback_interval * 10);
-	queue_delayed_work(bdi_wq, &bdi->wb.dwork, timeout);
+	spin_lock_bh(&bdi->wb_lock);
+	if (test_bit(BDI_registered, &bdi->state))
+		queue_delayed_work(bdi_wq, &bdi->wb.dwork, timeout);
+	spin_unlock_bh(&bdi->wb_lock);
 }
 
 /*
@@ -307,9 +310,6 @@ static void bdi_remove_from_list(struct backing_dev_info *bdi)
 	spin_unlock_bh(&bdi_lock);
 
 	synchronize_rcu_expedited();
-
-	/* bdi_list is now unused, clear it to mark @bdi dying */
-	INIT_LIST_HEAD(&bdi->bdi_list);
 }
 
 int bdi_register(struct backing_dev_info *bdi, struct device *parent,
@@ -360,6 +360,11 @@ static void bdi_wb_shutdown(struct backing_dev_info *bdi)
 	 */
 	bdi_remove_from_list(bdi);
 
+	/* Make sure nobody queues further work */
+	spin_lock_bh(&bdi->wb_lock);
+	clear_bit(BDI_registered, &bdi->state);
+	spin_unlock_bh(&bdi->wb_lock);
+
 	/*
 	 * Drain work list and shutdown the delayed_work.  At this point,
 	 * @bdi->bdi_list is empty telling bdi_Writeback_workfn() that @bdi
