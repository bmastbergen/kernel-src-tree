ACPI / hotplug / PCI: Fix bridge removal race in handle_hotplug_event()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Fix bridge removal race in handle_hotplug_event() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 93.23%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 1b360f44d009059e446532f29c1a889951e72667
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/1b360f44.failed

If a PCI bridge with an ACPIPHP context attached is removed via
sysfs, the code path executed as a result is the following:

pci_stop_and_remove_bus_device_locked
 pci_remove_bus
  pcibios_remove_bus
   acpi_pci_remove_bus
    acpiphp_remove_slots
     cleanup_bridge
     put_bridge
      free_bridge
       acpiphp_put_context (for each child, under context lock)
        kfree (child context)

Now, if a hotplug notify is dispatched for one of the bridge's
children and the timing is such that handle_hotplug_event() for
that notify is executed while free_bridge() above is running,
the get_bridge(context->func.parent) in handle_hotplug_event()
will not really help, because it is too late to prevent the bridge
from going away and the child's context may be freed before
hotplug_event_work() scheduled from handle_hotplug_event()
dereferences the pointer to it passed via the data argument.
That will cause a kernel crash to happpen in hotplug_event_work().

To prevent that from happening, make handle_hotplug_event()
check the is_going_away flag of the function's parent bridge
(under acpiphp_context_lock) and bail out if it's set.  Also,
make cleanup_bridge() set the bridge's is_going_away flag under
acpiphp_context_lock so that it cannot be changed between the
check and the subsequent get_bridge(context->func.parent) in
handle_hotplug_event().

Then, in the above scenario, handle_hotplug_event() will notice
that context->func.parent->is_going_away is already set and it
will exit immediately preventing the crash from happening.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 1b360f44d009059e446532f29c1a889951e72667)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index d78516334707,91eceaf3131b..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -491,73 -440,12 +491,80 @@@ static void cleanup_bridge(struct acpip
  	mutex_lock(&bridge_mutex);
  	list_del(&bridge->list);
  	mutex_unlock(&bridge_mutex);
++<<<<<<< HEAD
++=======
+ 
+ 	mutex_lock(&acpiphp_context_lock);
+ 	bridge->is_going_away = true;
+ 	mutex_unlock(&acpiphp_context_lock);
++>>>>>>> 1b360f44d009 (ACPI / hotplug / PCI: Fix bridge removal race in handle_hotplug_event())
  }
  
 +static int power_on_slot(struct acpiphp_slot *slot)
 +{
 +	acpi_status status;
 +	struct acpiphp_func *func;
 +	int retval = 0;
 +
 +	/* if already enabled, just skip */
 +	if (slot->flags & SLOT_POWEREDON)
 +		goto err_exit;
 +
 +	list_for_each_entry(func, &slot->funcs, sibling) {
 +		if (func->flags & FUNC_HAS_PS0) {
 +			pr_debug("%s: executing _PS0\n", __func__);
 +			status = acpi_evaluate_object(func->handle, "_PS0", NULL, NULL);
 +			if (ACPI_FAILURE(status)) {
 +				pr_warn("%s: _PS0 failed\n", __func__);
 +				retval = -1;
 +				goto err_exit;
 +			} else
 +				break;
 +		}
 +	}
 +
 +	/* TBD: evaluate _STA to check if the slot is enabled */
 +
 +	slot->flags |= SLOT_POWEREDON;
 +
 + err_exit:
 +	return retval;
 +}
 +
 +
 +static int power_off_slot(struct acpiphp_slot *slot)
 +{
 +	acpi_status status;
 +	struct acpiphp_func *func;
 +
 +	int retval = 0;
 +
 +	/* if already disabled, just skip */
 +	if ((slot->flags & SLOT_POWEREDON) == 0)
 +		goto err_exit;
 +
 +	list_for_each_entry(func, &slot->funcs, sibling) {
 +		if (func->flags & FUNC_HAS_PS3) {
 +			status = acpi_evaluate_object(func->handle, "_PS3", NULL, NULL);
 +			if (ACPI_FAILURE(status)) {
 +				pr_warn("%s: _PS3 failed\n", __func__);
 +				retval = -1;
 +				goto err_exit;
 +			} else
 +				break;
 +		}
 +	}
 +
 +	/* TBD: evaluate _STA to check if the slot is disabled */
 +
 +	slot->flags &= (~SLOT_POWEREDON);
 +
 + err_exit:
 +	return retval;
 +}
 +
 +
 +
  /**
   * acpiphp_max_busnr - return the highest reserved bus number under the given bus.
   * @bus: bus to start search with
@@@ -1060,38 -932,18 +1067,44 @@@ static void _handle_hotplug_event_bridg
  }
  
  /**
 - * handle_hotplug_event - handle ACPI hotplug event
 + * handle_hotplug_event_bridge - handle ACPI event on bridges
   * @handle: Notify()'ed acpi_handle
   * @type: Notify code
 - * @data: pointer to acpiphp_context structure
 + * @context: pointer to acpiphp_bridge structure
   *
 - * Handles ACPI event notification on slots.
 + * Handles ACPI event notification on {host,p2p} bridges.
   */
 -static void handle_hotplug_event(acpi_handle handle, u32 type, void *data)
 +static void handle_hotplug_event_bridge(acpi_handle handle, u32 type,
 +					void *context)
  {
++<<<<<<< HEAD
 +	struct acpiphp_bridge *bridge = context;
 +
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_bridge);
 +}
 +
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context)
 +{
 +	struct acpiphp_func *func = context;
 +	char objname[64];
 +	struct acpi_buffer buffer = { .length = sizeof(objname),
 +				      .pointer = objname };
 +
 +	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
++=======
+ 	struct acpiphp_context *context;
+ 	u32 ost_code = ACPI_OST_SC_SUCCESS;
+ 	acpi_status status;
++>>>>>>> 1b360f44d009 (ACPI / hotplug / PCI: Fix bridge removal race in handle_hotplug_event())
  
  	switch (type) {
  	case ACPI_NOTIFY_BUS_CHECK:
@@@ -1107,62 -955,49 +1120,83 @@@
  		break;
  
  	case ACPI_NOTIFY_DEVICE_WAKE:
 -		return;
 -
 -	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
 -		acpi_handle_err(handle, "Device cannot be configured due "
 -				"to a frequency mismatch\n");
 -		goto out;
 -
 -	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
 -		acpi_handle_err(handle, "Device cannot be configured due "
 -				"to a bus mode mismatch\n");
 -		goto out;
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
 +		break;
  
 -	case ACPI_NOTIFY_POWER_FAULT:
 -		acpi_handle_err(handle, "Device has suffered a power fault\n");
 -		goto out;
 +	case ACPI_NOTIFY_EJECT_REQUEST:
 +		/* request device eject */
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if (!(acpiphp_disable_slot(func->slot)))
 +			acpiphp_eject_slot(func->slot);
 +		break;
  
  	default:
 -		acpi_handle_warn(handle, "Unsupported event type 0x%x\n", type);
 -		ost_code = ACPI_OST_SC_UNRECOGNIZED_NOTIFY;
 -		goto out;
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
 +		break;
  	}
 +}
  
++<<<<<<< HEAD
 +static void _handle_hotplug_event_func(struct work_struct *work)
 +{
 +	struct acpi_hp_work *hp_work;
 +	struct acpiphp_func *func;
++=======
+ 	mutex_lock(&acpiphp_context_lock);
+ 	context = acpiphp_get_context(handle);
+ 	if (!context || WARN_ON(context->handle != handle)
+ 	    || context->func.parent->is_going_away)
+ 		goto err_out;
+ 
+ 	get_bridge(context->func.parent);
+ 	acpiphp_put_context(context);
+ 	status = acpi_hotplug_execute(hotplug_event_work, context, type);
+ 	if (ACPI_SUCCESS(status)) {
+ 		mutex_unlock(&acpiphp_context_lock);
+ 		return;
+ 	}
+ 	put_bridge(context->func.parent);
+ 
+  err_out:
+ 	mutex_unlock(&acpiphp_context_lock);
+ 	ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
++>>>>>>> 1b360f44d009 (ACPI / hotplug / PCI: Fix bridge removal race in handle_hotplug_event())
  
 - out:
 -	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
 +	hp_work = container_of(work, struct acpi_hp_work, work);
 +	func = hp_work->context;
 +	acpi_scan_lock_acquire();
 +
 +	hotplug_event_func(hp_work->handle, hp_work->type, func);
 +
 +	acpi_scan_lock_release();
 +	kfree(hp_work); /* allocated in handle_hotplug_event_func */
 +	put_bridge(func->slot->bridge);
 +}
 +
 +/**
 + * handle_hotplug_event_func - handle ACPI event on functions (i.e. slots)
 + * @handle: Notify()'ed acpi_handle
 + * @type: Notify code
 + * @context: pointer to acpiphp_func structure
 + *
 + * Handles ACPI event notification on slots.
 + */
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type,
 +				      void *context)
 +{
 +	struct acpiphp_func *func = context;
 +
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(func->slot->bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_func);
  }
  
  /*
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
