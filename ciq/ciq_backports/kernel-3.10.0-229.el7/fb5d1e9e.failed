openvswitch: Build flow cmd netlink reply only if needed.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] openvswitch: Build flow cmd netlink reply only if needed (Jiri Benc) [1110384]
Rebuild_FUZZ: 99.12%
commit-author Jarno Rajahalme <jrajahalme@nicira.com>
commit fb5d1e9e127ad1542e5db20cd8620a1509baef69
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/fb5d1e9e.failed

Use netlink_has_listeners() and NLM_F_ECHO flag to determine if a
reply is needed or not for OVS_FLOW_CMD_NEW, OVS_FLOW_CMD_SET, or
OVS_FLOW_CMD_DEL.  Currently, OVS userspace does not request a reply
for OVS_FLOW_CMD_NEW, but usually does for OVS_FLOW_CMD_DEL, as stats
may have changed.

	Signed-off-by: Jarno Rajahalme <jrajahalme@nicira.com>
	Signed-off-by: Pravin B Shelar <pshelar@nicira.com>
(cherry picked from commit fb5d1e9e127ad1542e5db20cd8620a1509baef69)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/datapath.c
diff --cc net/openvswitch/datapath.c
index d01b30b9528a,cb5d64a5c759..000000000000
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@@ -62,11 -62,20 +62,25 @@@
  
  int ovs_net_id __read_mostly;
  
++<<<<<<< HEAD
 +static void ovs_notify(struct sk_buff *skb, struct genl_info *info,
 +		       struct genl_multicast_group *grp)
++=======
+ /* Check if need to build a reply message.
+  * OVS userspace sets the NLM_F_ECHO flag if it needs the reply. */
+ static bool ovs_must_notify(struct genl_info *info,
+ 			    const struct genl_multicast_group *grp)
+ {
+ 	return info->nlhdr->nlmsg_flags & NLM_F_ECHO ||
+ 		netlink_has_listeners(genl_info_net(info)->genl_sock, 0);
+ }
+ 
+ static void ovs_notify(struct genl_family *family,
+ 		       struct sk_buff *skb, struct genl_info *info)
++>>>>>>> fb5d1e9e127a (openvswitch: Build flow cmd netlink reply only if needed.)
  {
 -	genl_notify(family, skb, genl_info_net(info), info->snd_portid,
 -		    0, info->nlhdr, GFP_KERNEL);
 +	genl_notify(skb, genl_info_net(info), info->snd_portid,
 +		    grp->id, info->nlhdr, GFP_KERNEL);
  }
  
  /**
@@@ -880,11 -904,14 +905,22 @@@ static int ovs_flow_cmd_new_or_set(stru
  	}
  	ovs_unlock();
  
++<<<<<<< HEAD
 +	if (!IS_ERR(reply))
 +		ovs_notify(reply, info, &ovs_dp_flow_multicast_group);
 +	else
 +		genl_set_err(sock_net(skb->sk), 0,
 +			     ovs_dp_flow_multicast_group.id, PTR_ERR(reply));
++=======
+ 	if (reply) {
+ 		if (!IS_ERR(reply))
+ 			ovs_notify(&dp_flow_genl_family, reply, info);
+ 		else
+ 			genl_set_err(&dp_flow_genl_family, sock_net(skb->sk), 0,
+ 				     0, PTR_ERR(reply));
+ 	}
+ 
++>>>>>>> fb5d1e9e127a (openvswitch: Build flow cmd netlink reply only if needed.)
  	return 0;
  
  err_flow_free:
@@@ -993,7 -1022,8 +1031,12 @@@ static int ovs_flow_cmd_del(struct sk_b
  	ovs_flow_free(flow, true);
  	ovs_unlock();
  
++<<<<<<< HEAD
 +	ovs_notify(reply, info, &ovs_dp_flow_multicast_group);
++=======
+ 	if (reply)
+ 		ovs_notify(&dp_flow_genl_family, reply, info);
++>>>>>>> fb5d1e9e127a (openvswitch: Build flow cmd netlink reply only if needed.)
  	return 0;
  unlock:
  	ovs_unlock();
* Unmerged path net/openvswitch/datapath.c
