arch/x86/mm/numa.c: fix array index overflow when synchronizing nid to memblock.reserved.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [x86] mm/numa: fix array index overflow when synchronizing nid to memblock.reserved (Motohiro Kosaki) [810042]
Rebuild_FUZZ: 92.77%
commit-author Tang Chen <tangchen@cn.fujitsu.com>
commit 7bc35fdde6724549a0239b71e08b9f33d8bf2bfb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/7bc35fdd.failed

The following path will cause array out of bound.

memblock_add_region() will always set nid in memblock.reserved to
MAX_NUMNODES.  In numa_register_memblks(), after we set all nid to
correct valus in memblock.reserved, we called setup_node_data(), and
used memblock_alloc_nid() to allocate memory, with nid set to
MAX_NUMNODES.

The nodemask_t type can be seen as a bit array.  And the index is 0 ~
MAX_NUMNODES-1.

After that, when we call node_set() in numa_clear_kernel_node_hotplug(),
the nodemask_t got an index of value MAX_NUMNODES, which is out of [0 ~
MAX_NUMNODES-1].

See below:

numa_init()
 |---> numa_register_memblks()
 |      |---> memblock_set_node(memory)		set correct nid in memblock.memory
 |      |---> memblock_set_node(reserved)	set correct nid in memblock.reserved
 |      |......
 |      |---> setup_node_data()
 |             |---> memblock_alloc_nid()	here, nid is set to MAX_NUMNODES (1024)
 |......
 |---> numa_clear_kernel_node_hotplug()
        |---> node_set()			here, we have an index 1024, and overflowed

This patch moves nid setting to numa_clear_kernel_node_hotplug() to fix
this problem.

	Reported-by: Dave Jones <davej@redhat.com>
	Signed-off-by: Tang Chen <tangchen@cn.fujitsu.com>
	Tested-by: Gu Zheng <guz.fnst@cn.fujitsu.com>
	Reported-by: Dave Jones <davej@redhat.com>
	Cc: David Rientjes <rientjes@google.com>
	Tested-by: Dave Jones <davej@redhat.com>
	Cc: Ingo Molnar <mingo@elte.hu>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 7bc35fdde6724549a0239b71e08b9f33d8bf2bfb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/numa.c
diff --cc arch/x86/mm/numa.c
index ad1a142a317e,27aa0455fab3..000000000000
--- a/arch/x86/mm/numa.c
+++ b/arch/x86/mm/numa.c
@@@ -550,6 -554,41 +550,44 @@@ static void __init numa_init_array(void
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void __init numa_clear_kernel_node_hotplug(void)
+ {
+ 	int i, nid;
+ 	nodemask_t numa_kernel_nodes = NODE_MASK_NONE;
+ 	unsigned long start, end;
+ 	struct memblock_type *type = &memblock.reserved;
+ 
+ 	/*
+ 	 * At this time, all memory regions reserved by memblock are
+ 	 * used by the kernel. Set the nid in memblock.reserved will
+ 	 * mark out all the nodes the kernel resides in.
+ 	 */
+ 	for (i = 0; i < numa_meminfo.nr_blks; i++) {
+ 		struct numa_memblk *mb = &numa_meminfo.blk[i];
+ 		memblock_set_node(mb->start, mb->end - mb->start,
+ 				  &memblock.reserved, mb->nid);
+ 	}
+ 
+ 	/* Mark all kernel nodes. */
+ 	for (i = 0; i < type->cnt; i++)
+ 		node_set(type->regions[i].nid, numa_kernel_nodes);
+ 
+ 	/* Clear MEMBLOCK_HOTPLUG flag for memory in kernel nodes. */
+ 	for (i = 0; i < numa_meminfo.nr_blks; i++) {
+ 		nid = numa_meminfo.blk[i].nid;
+ 		if (!node_isset(nid, numa_kernel_nodes))
+ 			continue;
+ 
+ 		start = numa_meminfo.blk[i].start;
+ 		end = numa_meminfo.blk[i].end;
+ 
+ 		memblock_clear_hotplug(start, end - start);
+ 	}
+ }
+ 
++>>>>>>> 7bc35fdde672 (arch/x86/mm/numa.c: fix array index overflow when synchronizing nid to memblock.reserved.)
  static int __init numa_init(int (*init_func)(void))
  {
  	int i;
* Unmerged path arch/x86/mm/numa.c
