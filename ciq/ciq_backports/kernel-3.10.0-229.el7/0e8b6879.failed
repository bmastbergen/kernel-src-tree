ext4: refactor ext4_fallocate code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Lukas Czerner <lczerner@redhat.com>
commit 0e8b6879f3c234036181526683be2b0231892ae4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0e8b6879.failed

Move block allocation out of the ext4_fallocate into separate function
called ext4_alloc_file_blocks(). This will allow us to use the same
allocation code for other allocation operations such as zero range which
is commit in the next patch.

	Signed-off-by: Lukas Czerner <lczerner@redhat.com>
	Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
(cherry picked from commit 0e8b6879f3c234036181526683be2b0231892ae4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/extents.c
diff --cc fs/ext4/extents.c
index b0f11d183059,2db2d77769a2..000000000000
--- a/fs/ext4/extents.c
+++ b/fs/ext4/extents.c
@@@ -4565,60 -4554,10 +4559,60 @@@ static int ext4_alloc_file_blocks(struc
  	int ret = 0;
  	int ret2 = 0;
  	int retries = 0;
- 	int flags;
  	struct ext4_map_blocks map;
- 	struct timespec tv;
- 	unsigned int credits, blkbits = inode->i_blkbits;
+ 	unsigned int credits;
  
++<<<<<<< HEAD
 +	/*
 +	 * currently supporting (pre)allocate mode for extent-based
 +	 * files _only_
 +	 */
 +	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))
 +		return -EOPNOTSUPP;
 +
 +	/* Return error if mode is not supported */
 +	if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |
 +		     FALLOC_FL_COLLAPSE_RANGE))
 +		return -EOPNOTSUPP;
 +
 +	if (mode & FALLOC_FL_PUNCH_HOLE)
 +		return ext4_punch_hole(inode, offset, len);
 +
 +	if (mode & FALLOC_FL_COLLAPSE_RANGE)
 +		return ext4_collapse_range(inode, offset, len);
 +
 +	ret = ext4_convert_inline_data(inode);
 +	if (ret)
 +		return ret;
 +
 +	trace_ext4_fallocate_enter(inode, offset, len, mode);
 +	map.m_lblk = offset >> blkbits;
 +	/*
 +	 * We can't just convert len to max_blocks because
 +	 * If blocksize = 4096 offset = 3072 and len = 2048
 +	 */
 +	max_blocks = (EXT4_BLOCK_ALIGN(len + offset, blkbits) >> blkbits)
 +		- map.m_lblk;
 +	/*
 +	 * credits to insert 1 extent into extent tree
 +	 */
 +	credits = ext4_chunk_trans_blocks(inode, max_blocks);
 +	mutex_lock(&inode->i_mutex);
 +
 +	if (!(mode & FALLOC_FL_KEEP_SIZE) &&
 +	     offset + len > i_size_read(inode)) {
 +		new_size = offset + len;
 +		ret = inode_newsize_ok(inode, new_size);
 +		if (ret)
 +			goto out;
 +	}
 +
 +	flags = EXT4_GET_BLOCKS_CREATE_UNINIT_EXT;
 +	if (mode & FALLOC_FL_KEEP_SIZE)
 +		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;
++=======
+ 	map.m_lblk = offset;
++>>>>>>> 0e8b6879f3c2 (ext4: refactor ext4_fallocate code)
  	/*
  	 * Don't normalize the request if it can fit in one extent so
  	 * that it doesn't get unnecessarily split into multiple
* Unmerged path fs/ext4/extents.c
