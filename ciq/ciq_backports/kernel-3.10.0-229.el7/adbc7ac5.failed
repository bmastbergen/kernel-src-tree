net/mlx4_core: Introduce ACCESS_REG CMD and eth_prot_ctrl dev cap

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [ethernet] mlx4: Introduce ACCESS_REG CMD and eth_prot_ctrl dev cap (Amir Vadai) [1060221]
Rebuild_FUZZ: 92.56%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit adbc7ac5c15eb5e9d70393428345e72a1a897d6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/adbc7ac5.failed

Adding ACCESS REG mlx4 command and use it to implement Query method for
PTYS (Port Type and Speed Register).
Query and store eth_prot_ctrl dev cap.

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Amir Vadai <amirv@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit adbc7ac5c15eb5e9d70393428345e72a1a897d6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/fw.c
#	include/linux/mlx4/device.h
diff --cc drivers/net/ethernet/mellanox/mlx4/fw.c
index 352765311b33,6fd9b8581e95..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/fw.c
+++ b/drivers/net/ethernet/mellanox/mlx4/fw.c
@@@ -136,7 -136,11 +136,15 @@@ static void dump_dev_cap_flags2(struct 
  		[7] = "FSM (MAC anti-spoofing) support",
  		[8] = "Dynamic QP updates support",
  		[9] = "Device managed flow steering IPoIB support",
++<<<<<<< HEAD
 +		[10] = "TCP/IP offloads/flow-steering for VXLAN support"
++=======
+ 		[10] = "TCP/IP offloads/flow-steering for VXLAN support",
+ 		[11] = "MAD DEMUX (Secure-Host) support",
+ 		[12] = "Large cache line (>64B) CQE stride support",
+ 		[13] = "Large cache line (>64B) EQE stride support",
+ 		[14] = "Ethernet protocol control support"
++>>>>>>> adbc7ac5c15e (net/mlx4_core: Introduce ACCESS_REG CMD and eth_prot_ctrl dev cap)
  	};
  	int i;
  
@@@ -540,6 -560,8 +548,11 @@@ int mlx4_QUERY_DEV_CAP(struct mlx4_dev 
  #define QUERY_DEV_CAP_FLOW_STEERING_IPOIB_OFFSET	0x74
  #define QUERY_DEV_CAP_FLOW_STEERING_RANGE_EN_OFFSET	0x76
  #define QUERY_DEV_CAP_FLOW_STEERING_MAX_QP_OFFSET	0x77
++<<<<<<< HEAD
++=======
+ #define QUERY_DEV_CAP_CQ_EQ_CACHE_LINE_STRIDE	0x7a
+ #define QUERY_DEV_CAP_ETH_PROT_CTRL_OFFSET	0x7a
++>>>>>>> adbc7ac5c15e (net/mlx4_core: Introduce ACCESS_REG CMD and eth_prot_ctrl dev cap)
  #define QUERY_DEV_CAP_RDMARC_ENTRY_SZ_OFFSET	0x80
  #define QUERY_DEV_CAP_QPC_ENTRY_SZ_OFFSET	0x82
  #define QUERY_DEV_CAP_AUX_ENTRY_SZ_OFFSET	0x84
@@@ -715,7 -738,13 +728,17 @@@
  	dev_cap->max_rq_sg = field;
  	MLX4_GET(size, outbox, QUERY_DEV_CAP_MAX_DESC_SZ_RQ_OFFSET);
  	dev_cap->max_rq_desc_sz = size;
- 
++<<<<<<< HEAD
++
++=======
+ 	MLX4_GET(field, outbox, QUERY_DEV_CAP_CQ_EQ_CACHE_LINE_STRIDE);
+ 	if (field & (1 << 5))
+ 		dev_cap->flags2 |= MLX4_DEV_CAP_FLAG2_ETH_PROT_CTRL;
+ 	if (field & (1 << 6))
+ 		dev_cap->flags2 |= MLX4_DEV_CAP_FLAG2_CQE_STRIDE;
+ 	if (field & (1 << 7))
+ 		dev_cap->flags2 |= MLX4_DEV_CAP_FLAG2_EQE_STRIDE;
++>>>>>>> adbc7ac5c15e (net/mlx4_core: Introduce ACCESS_REG CMD and eth_prot_ctrl dev cap)
  	MLX4_GET(dev_cap->bmme_flags, outbox,
  		 QUERY_DEV_CAP_BMME_FLAGS_OFFSET);
  	MLX4_GET(dev_cap->reserved_lkey, outbox,
@@@ -1999,3 -2065,196 +2022,199 @@@ void mlx4_opreq_action(struct work_stru
  out:
  	mlx4_free_cmd_mailbox(dev, mailbox);
  }
++<<<<<<< HEAD
++=======
+ 
+ static int mlx4_check_smp_firewall_active(struct mlx4_dev *dev,
+ 					  struct mlx4_cmd_mailbox *mailbox)
+ {
+ #define MLX4_CMD_MAD_DEMUX_SET_ATTR_OFFSET		0x10
+ #define MLX4_CMD_MAD_DEMUX_GETRESP_ATTR_OFFSET		0x20
+ #define MLX4_CMD_MAD_DEMUX_TRAP_ATTR_OFFSET		0x40
+ #define MLX4_CMD_MAD_DEMUX_TRAP_REPRESS_ATTR_OFFSET	0x70
+ 
+ 	u32 set_attr_mask, getresp_attr_mask;
+ 	u32 trap_attr_mask, traprepress_attr_mask;
+ 
+ 	MLX4_GET(set_attr_mask, mailbox->buf,
+ 		 MLX4_CMD_MAD_DEMUX_SET_ATTR_OFFSET);
+ 	mlx4_dbg(dev, "SMP firewall set_attribute_mask = 0x%x\n",
+ 		 set_attr_mask);
+ 
+ 	MLX4_GET(getresp_attr_mask, mailbox->buf,
+ 		 MLX4_CMD_MAD_DEMUX_GETRESP_ATTR_OFFSET);
+ 	mlx4_dbg(dev, "SMP firewall getresp_attribute_mask = 0x%x\n",
+ 		 getresp_attr_mask);
+ 
+ 	MLX4_GET(trap_attr_mask, mailbox->buf,
+ 		 MLX4_CMD_MAD_DEMUX_TRAP_ATTR_OFFSET);
+ 	mlx4_dbg(dev, "SMP firewall trap_attribute_mask = 0x%x\n",
+ 		 trap_attr_mask);
+ 
+ 	MLX4_GET(traprepress_attr_mask, mailbox->buf,
+ 		 MLX4_CMD_MAD_DEMUX_TRAP_REPRESS_ATTR_OFFSET);
+ 	mlx4_dbg(dev, "SMP firewall traprepress_attribute_mask = 0x%x\n",
+ 		 traprepress_attr_mask);
+ 
+ 	if (set_attr_mask && getresp_attr_mask && trap_attr_mask &&
+ 	    traprepress_attr_mask)
+ 		return 1;
+ 
+ 	return 0;
+ }
+ 
+ int mlx4_config_mad_demux(struct mlx4_dev *dev)
+ {
+ 	struct mlx4_cmd_mailbox *mailbox;
+ 	int secure_host_active;
+ 	int err;
+ 
+ 	/* Check if mad_demux is supported */
+ 	if (!(dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_MAD_DEMUX))
+ 		return 0;
+ 
+ 	mailbox = mlx4_alloc_cmd_mailbox(dev);
+ 	if (IS_ERR(mailbox)) {
+ 		mlx4_warn(dev, "Failed to allocate mailbox for cmd MAD_DEMUX");
+ 		return -ENOMEM;
+ 	}
+ 
+ 	/* Query mad_demux to find out which MADs are handled by internal sma */
+ 	err = mlx4_cmd_box(dev, 0, mailbox->dma, 0x01 /* subn mgmt class */,
+ 			   MLX4_CMD_MAD_DEMUX_QUERY_RESTR, MLX4_CMD_MAD_DEMUX,
+ 			   MLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);
+ 	if (err) {
+ 		mlx4_warn(dev, "MLX4_CMD_MAD_DEMUX: query restrictions failed (%d)\n",
+ 			  err);
+ 		goto out;
+ 	}
+ 
+ 	secure_host_active = mlx4_check_smp_firewall_active(dev, mailbox);
+ 
+ 	/* Config mad_demux to handle all MADs returned by the query above */
+ 	err = mlx4_cmd(dev, mailbox->dma, 0x01 /* subn mgmt class */,
+ 		       MLX4_CMD_MAD_DEMUX_CONFIG, MLX4_CMD_MAD_DEMUX,
+ 		       MLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);
+ 	if (err) {
+ 		mlx4_warn(dev, "MLX4_CMD_MAD_DEMUX: configure failed (%d)\n", err);
+ 		goto out;
+ 	}
+ 
+ 	if (secure_host_active)
+ 		mlx4_warn(dev, "HCA operating in secure-host mode. SMP firewall activated.\n");
+ out:
+ 	mlx4_free_cmd_mailbox(dev, mailbox);
+ 	return err;
+ }
+ 
+ /* Access Reg commands */
+ enum mlx4_access_reg_masks {
+ 	MLX4_ACCESS_REG_STATUS_MASK = 0x7f,
+ 	MLX4_ACCESS_REG_METHOD_MASK = 0x7f,
+ 	MLX4_ACCESS_REG_LEN_MASK = 0x7ff
+ };
+ 
+ struct mlx4_access_reg {
+ 	__be16 constant1;
+ 	u8 status;
+ 	u8 resrvd1;
+ 	__be16 reg_id;
+ 	u8 method;
+ 	u8 constant2;
+ 	__be32 resrvd2[2];
+ 	__be16 len_const;
+ 	__be16 resrvd3;
+ #define MLX4_ACCESS_REG_HEADER_SIZE (20)
+ 	u8 reg_data[MLX4_MAILBOX_SIZE-MLX4_ACCESS_REG_HEADER_SIZE];
+ } __attribute__((__packed__));
+ 
+ /**
+  * mlx4_ACCESS_REG - Generic access reg command.
+  * @dev: mlx4_dev.
+  * @reg_id: register ID to access.
+  * @method: Access method Read/Write.
+  * @reg_len: register length to Read/Write in bytes.
+  * @reg_data: reg_data pointer to Read/Write From/To.
+  *
+  * Access ConnectX registers FW command.
+  * Returns 0 on success and copies outbox mlx4_access_reg data
+  * field into reg_data or a negative error code.
+  */
+ static int mlx4_ACCESS_REG(struct mlx4_dev *dev, u16 reg_id,
+ 			   enum mlx4_access_reg_method method,
+ 			   u16 reg_len, void *reg_data)
+ {
+ 	struct mlx4_cmd_mailbox *inbox, *outbox;
+ 	struct mlx4_access_reg *inbuf, *outbuf;
+ 	int err;
+ 
+ 	inbox = mlx4_alloc_cmd_mailbox(dev);
+ 	if (IS_ERR(inbox))
+ 		return PTR_ERR(inbox);
+ 
+ 	outbox = mlx4_alloc_cmd_mailbox(dev);
+ 	if (IS_ERR(outbox)) {
+ 		mlx4_free_cmd_mailbox(dev, inbox);
+ 		return PTR_ERR(outbox);
+ 	}
+ 
+ 	inbuf = inbox->buf;
+ 	outbuf = outbox->buf;
+ 
+ 	inbuf->constant1 = cpu_to_be16(0x1<<11 | 0x4);
+ 	inbuf->constant2 = 0x1;
+ 	inbuf->reg_id = cpu_to_be16(reg_id);
+ 	inbuf->method = method & MLX4_ACCESS_REG_METHOD_MASK;
+ 
+ 	reg_len = min(reg_len, (u16)(sizeof(inbuf->reg_data)));
+ 	inbuf->len_const =
+ 		cpu_to_be16(((reg_len/4 + 1) & MLX4_ACCESS_REG_LEN_MASK) |
+ 			    ((0x3) << 12));
+ 
+ 	memcpy(inbuf->reg_data, reg_data, reg_len);
+ 	err = mlx4_cmd_box(dev, inbox->dma, outbox->dma, 0, 0,
+ 			   MLX4_CMD_ACCESS_REG, MLX4_CMD_TIME_CLASS_C,
+ 			   MLX4_CMD_NATIVE);
+ 	if (err)
+ 		goto out;
+ 
+ 	if (outbuf->status & MLX4_ACCESS_REG_STATUS_MASK) {
+ 		err = outbuf->status & MLX4_ACCESS_REG_STATUS_MASK;
+ 		mlx4_err(dev,
+ 			 "MLX4_CMD_ACCESS_REG(%x) returned REG status (%x)\n",
+ 			 reg_id, err);
+ 		goto out;
+ 	}
+ 
+ 	memcpy(reg_data, outbuf->reg_data, reg_len);
+ out:
+ 	mlx4_free_cmd_mailbox(dev, inbox);
+ 	mlx4_free_cmd_mailbox(dev, outbox);
+ 	return err;
+ }
+ 
+ /* ConnectX registers IDs */
+ enum mlx4_reg_id {
+ 	MLX4_REG_ID_PTYS = 0x5004,
+ };
+ 
+ /**
+  * mlx4_ACCESS_PTYS_REG - Access PTYs (Port Type and Speed)
+  * register
+  * @dev: mlx4_dev.
+  * @method: Access method Read/Write.
+  * @ptys_reg: PTYS register data pointer.
+  *
+  * Access ConnectX PTYS register, to Read/Write Port Type/Speed
+  * configuration
+  * Returns 0 on success or a negative error code.
+  */
+ int mlx4_ACCESS_PTYS_REG(struct mlx4_dev *dev,
+ 			 enum mlx4_access_reg_method method,
+ 			 struct mlx4_ptys_reg *ptys_reg)
+ {
+ 	return mlx4_ACCESS_REG(dev, MLX4_REG_ID_PTYS,
+ 			       method, sizeof(*ptys_reg), ptys_reg);
+ }
+ EXPORT_SYMBOL_GPL(mlx4_ACCESS_PTYS_REG);
++>>>>>>> adbc7ac5c15e (net/mlx4_core: Introduce ACCESS_REG CMD and eth_prot_ctrl dev cap)
diff --cc include/linux/mlx4/device.h
index e8e5c83cafc9,181cd9fc90f2..000000000000
--- a/include/linux/mlx4/device.h
+++ b/include/linux/mlx4/device.h
@@@ -180,8 -182,12 +180,17 @@@ enum 
  	MLX4_DEV_CAP_FLAG2_VLAN_CONTROL		= 1LL <<  6,
  	MLX4_DEV_CAP_FLAG2_FSM			= 1LL <<  7,
  	MLX4_DEV_CAP_FLAG2_UPDATE_QP		= 1LL <<  8,
++<<<<<<< HEAD
 +	MLX4_DEV_CAP_FLAG2_VXLAN_OFFLOADS	= 1LL <<  9,
 +	MLX4_DEV_CAP_FLAG2_DMFS_IPOIB		= 1LL << 10
++=======
+ 	MLX4_DEV_CAP_FLAG2_DMFS_IPOIB		= 1LL <<  9,
+ 	MLX4_DEV_CAP_FLAG2_VXLAN_OFFLOADS	= 1LL <<  10,
+ 	MLX4_DEV_CAP_FLAG2_MAD_DEMUX		= 1LL <<  11,
+ 	MLX4_DEV_CAP_FLAG2_CQE_STRIDE		= 1LL <<  12,
+ 	MLX4_DEV_CAP_FLAG2_EQE_STRIDE		= 1LL <<  13,
+ 	MLX4_DEV_CAP_FLAG2_ETH_PROT_CTRL        = 1LL <<  14
++>>>>>>> adbc7ac5c15e (net/mlx4_core: Introduce ACCESS_REG CMD and eth_prot_ctrl dev cap)
  };
  
  enum {
@@@ -1252,4 -1291,70 +1261,73 @@@ int mlx4_phys_to_slave_port(struct mlx4
  int mlx4_get_base_gid_ix(struct mlx4_dev *dev, int slave, int port);
  
  int mlx4_config_vxlan_port(struct mlx4_dev *dev, __be16 udp_port);
++<<<<<<< HEAD
++=======
+ int mlx4_vf_smi_enabled(struct mlx4_dev *dev, int slave, int port);
+ int mlx4_vf_get_enable_smi_admin(struct mlx4_dev *dev, int slave, int port);
+ int mlx4_vf_set_enable_smi_admin(struct mlx4_dev *dev, int slave, int port,
+ 				 int enable);
+ int mlx4_mr_hw_get_mpt(struct mlx4_dev *dev, struct mlx4_mr *mmr,
+ 		       struct mlx4_mpt_entry ***mpt_entry);
+ int mlx4_mr_hw_write_mpt(struct mlx4_dev *dev, struct mlx4_mr *mmr,
+ 			 struct mlx4_mpt_entry **mpt_entry);
+ int mlx4_mr_hw_change_pd(struct mlx4_dev *dev, struct mlx4_mpt_entry *mpt_entry,
+ 			 u32 pdn);
+ int mlx4_mr_hw_change_access(struct mlx4_dev *dev,
+ 			     struct mlx4_mpt_entry *mpt_entry,
+ 			     u32 access);
+ void mlx4_mr_hw_put_mpt(struct mlx4_dev *dev,
+ 			struct mlx4_mpt_entry **mpt_entry);
+ void mlx4_mr_rereg_mem_cleanup(struct mlx4_dev *dev, struct mlx4_mr *mr);
+ int mlx4_mr_rereg_mem_write(struct mlx4_dev *dev, struct mlx4_mr *mr,
+ 			    u64 iova, u64 size, int npages,
+ 			    int page_shift, struct mlx4_mpt_entry *mpt_entry);
+ 
+ int mlx4_get_module_info(struct mlx4_dev *dev, u8 port,
+ 			 u16 offset, u16 size, u8 *data);
+ 
+ /* Returns true if running in low memory profile (kdump kernel) */
+ static inline bool mlx4_low_memory_profile(void)
+ {
+ 	return is_kdump_kernel();
+ }
+ 
+ /* ACCESS REG commands */
+ enum mlx4_access_reg_method {
+ 	MLX4_ACCESS_REG_QUERY = 0x1,
+ 	MLX4_ACCESS_REG_WRITE = 0x2,
+ };
+ 
+ /* ACCESS PTYS Reg command */
+ enum mlx4_ptys_proto {
+ 	MLX4_PTYS_IB = 1<<0,
+ 	MLX4_PTYS_EN = 1<<2,
+ };
+ 
+ struct mlx4_ptys_reg {
+ 	u8 resrvd1;
+ 	u8 local_port;
+ 	u8 resrvd2;
+ 	u8 proto_mask;
+ 	__be32 resrvd3[2];
+ 	__be32 eth_proto_cap;
+ 	__be16 ib_width_cap;
+ 	__be16 ib_speed_cap;
+ 	__be32 resrvd4;
+ 	__be32 eth_proto_admin;
+ 	__be16 ib_width_admin;
+ 	__be16 ib_speed_admin;
+ 	__be32 resrvd5;
+ 	__be32 eth_proto_oper;
+ 	__be16 ib_width_oper;
+ 	__be16 ib_speed_oper;
+ 	__be32 resrvd6;
+ 	__be32 eth_proto_lp_adv;
+ } __packed;
+ 
+ int mlx4_ACCESS_PTYS_REG(struct mlx4_dev *dev,
+ 			 enum mlx4_access_reg_method method,
+ 			 struct mlx4_ptys_reg *ptys_reg);
+ 
++>>>>>>> adbc7ac5c15e (net/mlx4_core: Introduce ACCESS_REG CMD and eth_prot_ctrl dev cap)
  #endif /* MLX4_DEVICE_H */
diff --git a/drivers/net/ethernet/mellanox/mlx4/cmd.c b/drivers/net/ethernet/mellanox/mlx4/cmd.c
index 84d8585a28b8..5c9d211c0197 100644
--- a/drivers/net/ethernet/mellanox/mlx4/cmd.c
+++ b/drivers/net/ethernet/mellanox/mlx4/cmd.c
@@ -1305,6 +1305,15 @@ static struct mlx4_cmd_info cmd_info[] = {
 		.verify = NULL,
 		.wrapper = mlx4_QUERY_IF_STAT_wrapper
 	},
+	{
+		.opcode = MLX4_CMD_ACCESS_REG,
+		.has_inbox = true,
+		.has_outbox = true,
+		.out_is_imm = false,
+		.encode_slave_id = false,
+		.verify = NULL,
+		.wrapper = NULL,
+	},
 	/* Native multicast commands are not available for guests */
 	{
 		.opcode = MLX4_CMD_QP_ATTACH,
* Unmerged path drivers/net/ethernet/mellanox/mlx4/fw.c
diff --git a/include/linux/mlx4/cmd.h b/include/linux/mlx4/cmd.h
index c8450366c130..0a46d4138c33 100644
--- a/include/linux/mlx4/cmd.h
+++ b/include/linux/mlx4/cmd.h
@@ -67,6 +67,8 @@ enum {
 	MLX4_CMD_MAP_ICM_AUX	 = 0xffc,
 	MLX4_CMD_UNMAP_ICM_AUX	 = 0xffb,
 	MLX4_CMD_SET_ICM_SIZE	 = 0xffd,
+	MLX4_CMD_ACCESS_REG	 = 0x3b,
+
 	/*master notify fw on finish for slave's flr*/
 	MLX4_CMD_INFORM_FLR_DONE = 0x5b,
 	MLX4_CMD_GET_OP_REQ      = 0x59,
* Unmerged path include/linux/mlx4/device.h
