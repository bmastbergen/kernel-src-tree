x86, pageattr: Export page unmapping interface

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [x86] mm/pageattr: Export page unmapping interface (Dave Young) [1080109]
Rebuild_FUZZ: 91.11%
commit-author Borislav Petkov <bp@suse.de>
commit 42a5477251f0e0f33ad5f6a95c48d685ec03191e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/42a54772.failed

We will use it in efi so expose it.

	Signed-off-by: Borislav Petkov <bp@suse.de>
	Tested-by: Toshi Kani <toshi.kani@hp.com>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit 42a5477251f0e0f33ad5f6a95c48d685ec03191e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/pgtable_types.h
#	arch/x86/mm/pageattr.c
diff --cc arch/x86/include/asm/pgtable_types.h
index dc5fac4c8ca2,94e40f1efdfd..000000000000
--- a/arch/x86/include/asm/pgtable_types.h
+++ b/arch/x86/include/asm/pgtable_types.h
@@@ -355,7 -383,10 +355,14 @@@ static inline void update_page_count(in
   */
  extern pte_t *lookup_address(unsigned long address, unsigned int *level);
  extern phys_addr_t slow_virt_to_phys(void *__address);
- 
++<<<<<<< HEAD
++
++=======
+ extern int kernel_map_pages_in_pgd(pgd_t *pgd, u64 pfn, unsigned long address,
+ 				   unsigned numpages, unsigned long page_flags);
+ void kernel_unmap_pages_in_pgd(pgd_t *root, unsigned long address,
+ 			       unsigned numpages);
++>>>>>>> 42a5477251f0 (x86, pageattr: Export page unmapping interface)
  #endif	/* !__ASSEMBLY__ */
  
  #endif /* _ASM_X86_PGTABLE_DEFS_H */
diff --cc arch/x86/mm/pageattr.c
index db8ace29514f,a3488689e301..000000000000
--- a/arch/x86/mm/pageattr.c
+++ b/arch/x86/mm/pageattr.c
@@@ -1822,6 -1843,42 +1834,45 @@@ bool kernel_page_present(struct page *p
  
  #endif /* CONFIG_DEBUG_PAGEALLOC */
  
++<<<<<<< HEAD
++=======
+ int kernel_map_pages_in_pgd(pgd_t *pgd, u64 pfn, unsigned long address,
+ 			    unsigned numpages, unsigned long page_flags)
+ {
+ 	int retval = -EINVAL;
+ 
+ 	struct cpa_data cpa = {
+ 		.vaddr = &address,
+ 		.pfn = pfn,
+ 		.pgd = pgd,
+ 		.numpages = numpages,
+ 		.mask_set = __pgprot(0),
+ 		.mask_clr = __pgprot(0),
+ 		.flags = 0,
+ 	};
+ 
+ 	if (!(__supported_pte_mask & _PAGE_NX))
+ 		goto out;
+ 
+ 	if (!(page_flags & _PAGE_NX))
+ 		cpa.mask_clr = __pgprot(_PAGE_NX);
+ 
+ 	cpa.mask_set = __pgprot(_PAGE_PRESENT | page_flags);
+ 
+ 	retval = __change_page_attr_set_clr(&cpa, 0);
+ 	__flush_tlb_all();
+ 
+ out:
+ 	return retval;
+ }
+ 
+ void kernel_unmap_pages_in_pgd(pgd_t *root, unsigned long address,
+ 			       unsigned numpages)
+ {
+ 	unmap_pgd_range(root, address, address + (numpages << PAGE_SHIFT));
+ }
+ 
++>>>>>>> 42a5477251f0 (x86, pageattr: Export page unmapping interface)
  /*
   * The testcases use internal knowledge of the implementation that shouldn't
   * be exposed to the rest of the kernel. Include these directly here.
* Unmerged path arch/x86/include/asm/pgtable_types.h
* Unmerged path arch/x86/mm/pageattr.c
