blk-merge: fix blk_recount_segments

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Ming Lei <ming.lei@canonical.com>
commit 0738854939e6ec9b9111a8cfc0ca1dfa3cff6b2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/07388549.failed

QUEUE_FLAG_NO_SG_MERGE is set at default for blk-mq devices,
so bio->bi_phys_segment computed may be bigger than
queue_max_segments(q) for blk-mq devices, then drivers will
fail to handle the case, for example, BUG_ON() in
virtio_queue_rq() can be triggerd for virtio-blk:

	https://bugs.launchpad.net/ubuntu/+source/linux/+bug/1359146

This patch fixes the issue by ignoring the QUEUE_FLAG_NO_SG_MERGE
flag if the computed bio->bi_phys_segment is bigger than
queue_max_segments(q), and the regression is caused by commit
05f1dd53152173(block: add queue flag for disabling SG merging).

	Reported-by: Kick In <pierre-andre.morey@canonical.com>
	Tested-by: Chris J Arges <chris.j.arges@canonical.com>
	Signed-off-by: Ming Lei <ming.lei@canonical.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 0738854939e6ec9b9111a8cfc0ca1dfa3cff6b2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-merge.c
diff --cc block/blk-merge.c
index 1ffc58977835,77881798f793..000000000000
--- a/block/blk-merge.c
+++ b/block/blk-merge.c
@@@ -10,12 -10,14 +10,18 @@@
  #include "blk.h"
  
  static unsigned int __blk_recalc_rq_segments(struct request_queue *q,
- 					     struct bio *bio)
+ 					     struct bio *bio,
+ 					     bool no_sg_merge)
  {
++<<<<<<< HEAD
 +	struct bio_vec *bv, *bvprv = NULL;
 +	int cluster, i, high, highprv = 1;
++=======
+ 	struct bio_vec bv, bvprv = { NULL };
+ 	int cluster, high, highprv = 1;
++>>>>>>> 0738854939e6 (blk-merge: fix blk_recount_segments)
  	unsigned int seg_size, nr_phys_segs;
  	struct bio *fbio, *bbio;
 -	struct bvec_iter iter;
  
  	if (!bio)
  		return 0;
@@@ -24,26 -36,32 +30,30 @@@
  	cluster = blk_queue_cluster(q);
  	seg_size = 0;
  	nr_phys_segs = 0;
++<<<<<<< HEAD
++=======
+ 	high = 0;
++>>>>>>> 0738854939e6 (blk-merge: fix blk_recount_segments)
  	for_each_bio(bio) {
 -		bio_for_each_segment(bv, bio, iter) {
 -			/*
 -			 * If SG merging is disabled, each bio vector is
 -			 * a segment
 -			 */
 -			if (no_sg_merge)
 -				goto new_segment;
 -
 +		bio_for_each_segment(bv, bio, i) {
  			/*
  			 * the trick here is making sure that a high page is
 -			 * never considered part of another segment, since
 -			 * that might change with the bounce page.
 +			 * never considered part of another segment, since that
 +			 * might change with the bounce page.
  			 */
 -			high = page_to_pfn(bv.bv_page) > queue_bounce_pfn(q);
 -			if (!high && !highprv && cluster) {
 -				if (seg_size + bv.bv_len
 +			high = page_to_pfn(bv->bv_page) > queue_bounce_pfn(q);
 +			if (high || highprv)
 +				goto new_segment;
 +			if (cluster) {
 +				if (seg_size + bv->bv_len
  				    > queue_max_segment_size(q))
  					goto new_segment;
 -				if (!BIOVEC_PHYS_MERGEABLE(&bvprv, &bv))
 +				if (!BIOVEC_PHYS_MERGEABLE(bvprv, bv))
  					goto new_segment;
 -				if (!BIOVEC_SEG_BOUNDARY(q, &bvprv, &bv))
 +				if (!BIOVEC_SEG_BOUNDARY(q, bvprv, bv))
  					goto new_segment;
  
 -				seg_size += bv.bv_len;
 +				seg_size += bv->bv_len;
  				bvprv = bv;
  				continue;
  			}
@@@ -75,11 -97,17 +89,24 @@@ void blk_recalc_rq_segments(struct requ
  
  void blk_recount_segments(struct request_queue *q, struct bio *bio)
  {
++<<<<<<< HEAD
 +	struct bio *nxt = bio->bi_next;
++=======
+ 	if (test_bit(QUEUE_FLAG_NO_SG_MERGE, &q->queue_flags) &&
+ 			bio->bi_vcnt < queue_max_segments(q))
+ 		bio->bi_phys_segments = bio->bi_vcnt;
+ 	else {
+ 		struct bio *nxt = bio->bi_next;
+ 
+ 		bio->bi_next = NULL;
+ 		bio->bi_phys_segments = __blk_recalc_rq_segments(q, bio, false);
+ 		bio->bi_next = nxt;
+ 	}
++>>>>>>> 0738854939e6 (blk-merge: fix blk_recount_segments)
  
 +	bio->bi_next = NULL;
 +	bio->bi_phys_segments = __blk_recalc_rq_segments(q, bio);
 +	bio->bi_next = nxt;
  	bio->bi_flags |= (1 << BIO_SEG_VALID);
  }
  EXPORT_SYMBOL(blk_recount_segments);
* Unmerged path block/blk-merge.c
