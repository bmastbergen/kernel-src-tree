ACPI / hotplug / PCI: Move PCI rescan-remove locking to hotplug_event()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Move PCI rescan-remove locking to hotplug_event() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 93.23%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit f41b32613138ae05329a0f0e7170223b775d6b24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/f41b3261.failed

Commit 9217a984671e (ACPI / hotplug / PCI: Use global PCI rescan-remove
locking) modified ACPIPHP to protect its PCI device removal and addition
code paths from races against sysfs-driven rescan and remove operations
with the help of PCI rescan-remove locking.  However, it overlooked the
fact that hotplug_event_work() is not the only caller of hotplug_event()
which may also be called by dock_hotplug_event() and that code path
is missing the PCI rescan-remove locking.  This means that, although
the PCI rescan-remove lock is held as appropriate during the handling
of events originating from handle_hotplug_event(), the ACPIPHP's
operations resulting from dock events may still suffer the race
conditions that commit 9217a984671e was supposed to eliminate.

To address that problem, move the PCI rescan-remove locking from
hotplug_event_work() to hotplug_event() so that it is used regardless
of the way that function is invoked.

Revamps: 9217a984671e (ACPI / hotplug / PCI: Use global PCI rescan-remove locking)
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit f41b32613138ae05329a0f0e7170223b775d6b24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 212725764a09,6e5bd79af810..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -984,17 -844,15 +984,18 @@@ static void _handle_hotplug_event_bridg
  	char objname[64];
  	struct acpi_buffer buffer = { .length = sizeof(objname),
  				      .pointer = objname };
 +	struct acpi_hp_work *hp_work;
 +	acpi_handle handle;
 +	u32 type;
  
 -	mutex_lock(&acpiphp_context_lock);
 -	bridge = context->bridge;
 -	if (bridge)
 -		get_bridge(bridge);
 +	hp_work = container_of(work, struct acpi_hp_work, work);
 +	handle = hp_work->handle;
 +	type = hp_work->type;
 +	bridge = (struct acpiphp_bridge *)hp_work->context;
  
 -	mutex_unlock(&acpiphp_context_lock);
 +	acpi_scan_lock_acquire();
  
+ 	pci_lock_rescan_remove();
  	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
  
  	switch (type) {
@@@ -1050,9 -906,23 +1051,26 @@@
  		break;
  	}
  
++<<<<<<< HEAD
++=======
+ 	pci_unlock_rescan_remove();
+ 	if (bridge)
+ 		put_bridge(bridge);
+ }
+ 
+ static void hotplug_event_work(void *data, u32 type)
+ {
+ 	struct acpiphp_context *context = data;
+ 	acpi_handle handle = context->handle;
+ 
+ 	acpi_scan_lock_acquire();
+ 
+ 	hotplug_event(handle, type, context);
+ 
++>>>>>>> f41b32613138 (ACPI / hotplug / PCI: Move PCI rescan-remove locking to hotplug_event())
  	acpi_scan_lock_release();
 -	acpi_evaluate_hotplug_ost(handle, type, ACPI_OST_SC_SUCCESS, NULL);
 -	put_bridge(context->func.parent);
 +	kfree(hp_work); /* allocated in handle_hotplug_event_bridge */
 +	put_bridge(bridge);
  }
  
  /**
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
