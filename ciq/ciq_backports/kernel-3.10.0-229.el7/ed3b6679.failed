drm/i915: Fix crash when failing to parse MIPI VBT

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] i915: Fix crash when failing to parse MIPI VBT (Rob Clark) [1153301]
Rebuild_FUZZ: 95.83%
commit-author Rafael Barbalho <rafael.barbalho@intel.com>
commit ed3b6679936801fa2dab47e7a6ef74e383400ed9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/ed3b6679.failed

This particular nasty presented itself while trying to register the
intelfb device (intel_fbdev.c). During the process of registering the device
the driver will disable the crtc via i9xx_crtc_disable. These will
also disable the panel using the generic mipi panel functions in
dsi_mod_vbt_generic.c. The stale MIPI generic data sequence pointers would
cause a crash within those functions. However, all of this is happening
while console_lock is held from do_register_framebuffer inside fbcon.c. Which
means that you got kernel log and just the device appearing to reboot/hang for
no apparent reason.

The fault started from the FB_EVENT_FB_REGISTERED event using the
fb_notifier_call_chain call in fbcon.c.

This regression has been introduced in

commit d3b542fcfc72d7724585e3fd2c5e75351bc3df47
Author: Shobhit Kumar <shobhit.kumar@intel.com>
Date:   Mon Apr 14 11:00:34 2014 +0530

    drm/i915: Add parsing support for new MIPI blocks in VBT

	Cc: Shobhit Kumar <shobhit.kumar@intel.com>
	Signed-off-by: Rafael Barbalho <rafael.barbalho@intel.com>
	Reviewed-by: Shobhit Kumar <shobhit.kumar@intel.com>
[danvet: Add regression citation.]
	Cc: stable@vger.kernel.org
	Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
(cherry picked from commit ed3b6679936801fa2dab47e7a6ef74e383400ed9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_bios.c
diff --cc drivers/gpu/drm/i915/intel_bios.c
index 53f2bed8bc5f,a66955037e4e..000000000000
--- a/drivers/gpu/drm/i915/intel_bios.c
+++ b/drivers/gpu/drm/i915/intel_bios.c
@@@ -568,6 -660,350 +568,349 @@@ parse_edp(struct drm_i915_private *dev_
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static u8 *goto_next_sequence(u8 *data, int *size)
+ {
+ 	u16 len;
+ 	int tmp = *size;
+ 
+ 	if (--tmp < 0)
+ 		return NULL;
+ 
+ 	/* goto first element */
+ 	data++;
+ 	while (1) {
+ 		switch (*data) {
+ 		case MIPI_SEQ_ELEM_SEND_PKT:
+ 			/*
+ 			 * skip by this element payload size
+ 			 * skip elem id, command flag and data type
+ 			 */
+ 			tmp -= 5;
+ 			if (tmp < 0)
+ 				return NULL;
+ 
+ 			data += 3;
+ 			len = *((u16 *)data);
+ 
+ 			tmp -= len;
+ 			if (tmp < 0)
+ 				return NULL;
+ 
+ 			/* skip by len */
+ 			data = data + 2 + len;
+ 			break;
+ 		case MIPI_SEQ_ELEM_DELAY:
+ 			/* skip by elem id, and delay is 4 bytes */
+ 			tmp -= 5;
+ 			if (tmp < 0)
+ 				return NULL;
+ 
+ 			data += 5;
+ 			break;
+ 		case MIPI_SEQ_ELEM_GPIO:
+ 			tmp -= 3;
+ 			if (tmp < 0)
+ 				return NULL;
+ 
+ 			data += 3;
+ 			break;
+ 		default:
+ 			DRM_ERROR("Unknown element\n");
+ 			return NULL;
+ 		}
+ 
+ 		/* end of sequence ? */
+ 		if (*data == 0)
+ 			break;
+ 	}
+ 
+ 	/* goto next sequence or end of block byte */
+ 	if (--tmp < 0)
+ 		return NULL;
+ 
+ 	data++;
+ 
+ 	/* update amount of data left for the sequence block to be parsed */
+ 	*size = tmp;
+ 	return data;
+ }
+ 
+ static void
+ parse_mipi(struct drm_i915_private *dev_priv, struct bdb_header *bdb)
+ {
+ 	struct bdb_mipi_config *start;
+ 	struct bdb_mipi_sequence *sequence;
+ 	struct mipi_config *config;
+ 	struct mipi_pps_data *pps;
+ 	u8 *data, *seq_data;
+ 	int i, panel_id, seq_size;
+ 	u16 block_size;
+ 
+ 	/* parse MIPI blocks only if LFP type is MIPI */
+ 	if (!dev_priv->vbt.has_mipi)
+ 		return;
+ 
+ 	/* Initialize this to undefined indicating no generic MIPI support */
+ 	dev_priv->vbt.dsi.panel_id = MIPI_DSI_UNDEFINED_PANEL_ID;
+ 
+ 	/* Block #40 is already parsed and panel_fixed_mode is
+ 	 * stored in dev_priv->lfp_lvds_vbt_mode
+ 	 * resuse this when needed
+ 	 */
+ 
+ 	/* Parse #52 for panel index used from panel_type already
+ 	 * parsed
+ 	 */
+ 	start = find_section(bdb, BDB_MIPI_CONFIG);
+ 	if (!start) {
+ 		DRM_DEBUG_KMS("No MIPI config BDB found");
+ 		return;
+ 	}
+ 
+ 	DRM_DEBUG_DRIVER("Found MIPI Config block, panel index = %d\n",
+ 								panel_type);
+ 
+ 	/*
+ 	 * get hold of the correct configuration block and pps data as per
+ 	 * the panel_type as index
+ 	 */
+ 	config = &start->config[panel_type];
+ 	pps = &start->pps[panel_type];
+ 
+ 	/* store as of now full data. Trim when we realise all is not needed */
+ 	dev_priv->vbt.dsi.config = kmemdup(config, sizeof(struct mipi_config), GFP_KERNEL);
+ 	if (!dev_priv->vbt.dsi.config)
+ 		return;
+ 
+ 	dev_priv->vbt.dsi.pps = kmemdup(pps, sizeof(struct mipi_pps_data), GFP_KERNEL);
+ 	if (!dev_priv->vbt.dsi.pps) {
+ 		kfree(dev_priv->vbt.dsi.config);
+ 		return;
+ 	}
+ 
+ 	/* We have mandatory mipi config blocks. Initialize as generic panel */
+ 	dev_priv->vbt.dsi.panel_id = MIPI_DSI_GENERIC_PANEL_ID;
+ 
+ 	/* Check if we have sequence block as well */
+ 	sequence = find_section(bdb, BDB_MIPI_SEQUENCE);
+ 	if (!sequence) {
+ 		DRM_DEBUG_KMS("No MIPI Sequence found, parsing complete\n");
+ 		return;
+ 	}
+ 
+ 	DRM_DEBUG_DRIVER("Found MIPI sequence block\n");
+ 
+ 	block_size = get_blocksize(sequence);
+ 
+ 	/*
+ 	 * parse the sequence block for individual sequences
+ 	 */
+ 	dev_priv->vbt.dsi.seq_version = sequence->version;
+ 
+ 	seq_data = &sequence->data[0];
+ 
+ 	/*
+ 	 * sequence block is variable length and hence we need to parse and
+ 	 * get the sequence data for specific panel id
+ 	 */
+ 	for (i = 0; i < MAX_MIPI_CONFIGURATIONS; i++) {
+ 		panel_id = *seq_data;
+ 		seq_size = *((u16 *) (seq_data + 1));
+ 		if (panel_id == panel_type)
+ 			break;
+ 
+ 		/* skip the sequence including seq header of 3 bytes */
+ 		seq_data = seq_data + 3 + seq_size;
+ 		if ((seq_data - &sequence->data[0]) > block_size) {
+ 			DRM_ERROR("Sequence start is beyond sequence block size, corrupted sequence block\n");
+ 			return;
+ 		}
+ 	}
+ 
+ 	if (i == MAX_MIPI_CONFIGURATIONS) {
+ 		DRM_ERROR("Sequence block detected but no valid configuration\n");
+ 		return;
+ 	}
+ 
+ 	/* check if found sequence is completely within the sequence block
+ 	 * just being paranoid */
+ 	if (seq_size > block_size) {
+ 		DRM_ERROR("Corrupted sequence/size, bailing out\n");
+ 		return;
+ 	}
+ 
+ 	/* skip the panel id(1 byte) and seq size(2 bytes) */
+ 	dev_priv->vbt.dsi.data = kmemdup(seq_data + 3, seq_size, GFP_KERNEL);
+ 	if (!dev_priv->vbt.dsi.data)
+ 		return;
+ 
+ 	/*
+ 	 * loop into the sequence data and split into multiple sequneces
+ 	 * There are only 5 types of sequences as of now
+ 	 */
+ 	data = dev_priv->vbt.dsi.data;
+ 	dev_priv->vbt.dsi.size = seq_size;
+ 
+ 	/* two consecutive 0x00 indicate end of all sequences */
+ 	while (1) {
+ 		int seq_id = *data;
+ 		if (MIPI_SEQ_MAX > seq_id && seq_id > MIPI_SEQ_UNDEFINED) {
+ 			dev_priv->vbt.dsi.sequence[seq_id] = data;
+ 			DRM_DEBUG_DRIVER("Found mipi sequence - %d\n", seq_id);
+ 		} else {
+ 			DRM_ERROR("undefined sequence\n");
+ 			goto err;
+ 		}
+ 
+ 		/* partial parsing to skip elements */
+ 		data = goto_next_sequence(data, &seq_size);
+ 
+ 		if (data == NULL) {
+ 			DRM_ERROR("Sequence elements going beyond block itself. Sequence block parsing failed\n");
+ 			goto err;
+ 		}
+ 
+ 		if (*data == 0)
+ 			break; /* end of sequence reached */
+ 	}
+ 
+ 	DRM_DEBUG_DRIVER("MIPI related vbt parsing complete\n");
+ 	return;
+ err:
+ 	kfree(dev_priv->vbt.dsi.data);
+ 	dev_priv->vbt.dsi.data = NULL;
+ 
+ 	/* error during parsing so set all pointers to null
+ 	 * because of partial parsing */
+ 	memset(dev_priv->vbt.dsi.sequence, 0, sizeof(dev_priv->vbt.dsi.sequence));
+ }
+ 
+ static void parse_ddi_port(struct drm_i915_private *dev_priv, enum port port,
+ 			   struct bdb_header *bdb)
+ {
+ 	union child_device_config *it, *child = NULL;
+ 	struct ddi_vbt_port_info *info = &dev_priv->vbt.ddi_port_info[port];
+ 	uint8_t hdmi_level_shift;
+ 	int i, j;
+ 	bool is_dvi, is_hdmi, is_dp, is_edp, is_crt;
+ 	uint8_t aux_channel;
+ 	/* Each DDI port can have more than one value on the "DVO Port" field,
+ 	 * so look for all the possible values for each port and abort if more
+ 	 * than one is found. */
+ 	int dvo_ports[][2] = {
+ 		{DVO_PORT_HDMIA, DVO_PORT_DPA},
+ 		{DVO_PORT_HDMIB, DVO_PORT_DPB},
+ 		{DVO_PORT_HDMIC, DVO_PORT_DPC},
+ 		{DVO_PORT_HDMID, DVO_PORT_DPD},
+ 		{DVO_PORT_CRT, -1 /* Port E can only be DVO_PORT_CRT */ },
+ 	};
+ 
+ 	/* Find the child device to use, abort if more than one found. */
+ 	for (i = 0; i < dev_priv->vbt.child_dev_num; i++) {
+ 		it = dev_priv->vbt.child_dev + i;
+ 
+ 		for (j = 0; j < 2; j++) {
+ 			if (dvo_ports[port][j] == -1)
+ 				break;
+ 
+ 			if (it->common.dvo_port == dvo_ports[port][j]) {
+ 				if (child) {
+ 					DRM_DEBUG_KMS("More than one child device for port %c in VBT.\n",
+ 						      port_name(port));
+ 					return;
+ 				}
+ 				child = it;
+ 			}
+ 		}
+ 	}
+ 	if (!child)
+ 		return;
+ 
+ 	aux_channel = child->raw[25];
+ 
+ 	is_dvi = child->common.device_type & DEVICE_TYPE_TMDS_DVI_SIGNALING;
+ 	is_dp = child->common.device_type & DEVICE_TYPE_DISPLAYPORT_OUTPUT;
+ 	is_crt = child->common.device_type & DEVICE_TYPE_ANALOG_OUTPUT;
+ 	is_hdmi = is_dvi && (child->common.device_type & DEVICE_TYPE_NOT_HDMI_OUTPUT) == 0;
+ 	is_edp = is_dp && (child->common.device_type & DEVICE_TYPE_INTERNAL_CONNECTOR);
+ 
+ 	info->supports_dvi = is_dvi;
+ 	info->supports_hdmi = is_hdmi;
+ 	info->supports_dp = is_dp;
+ 
+ 	DRM_DEBUG_KMS("Port %c VBT info: DP:%d HDMI:%d DVI:%d EDP:%d CRT:%d\n",
+ 		      port_name(port), is_dp, is_hdmi, is_dvi, is_edp, is_crt);
+ 
+ 	if (is_edp && is_dvi)
+ 		DRM_DEBUG_KMS("Internal DP port %c is TMDS compatible\n",
+ 			      port_name(port));
+ 	if (is_crt && port != PORT_E)
+ 		DRM_DEBUG_KMS("Port %c is analog\n", port_name(port));
+ 	if (is_crt && (is_dvi || is_dp))
+ 		DRM_DEBUG_KMS("Analog port %c is also DP or TMDS compatible\n",
+ 			      port_name(port));
+ 	if (is_dvi && (port == PORT_A || port == PORT_E))
+ 		DRM_DEBUG_KMS("Port %c is TMDS compabile\n", port_name(port));
+ 	if (!is_dvi && !is_dp && !is_crt)
+ 		DRM_DEBUG_KMS("Port %c is not DP/TMDS/CRT compatible\n",
+ 			      port_name(port));
+ 	if (is_edp && (port == PORT_B || port == PORT_C || port == PORT_E))
+ 		DRM_DEBUG_KMS("Port %c is internal DP\n", port_name(port));
+ 
+ 	if (is_dvi) {
+ 		if (child->common.ddc_pin == 0x05 && port != PORT_B)
+ 			DRM_DEBUG_KMS("Unexpected DDC pin for port B\n");
+ 		if (child->common.ddc_pin == 0x04 && port != PORT_C)
+ 			DRM_DEBUG_KMS("Unexpected DDC pin for port C\n");
+ 		if (child->common.ddc_pin == 0x06 && port != PORT_D)
+ 			DRM_DEBUG_KMS("Unexpected DDC pin for port D\n");
+ 	}
+ 
+ 	if (is_dp) {
+ 		if (aux_channel == 0x40 && port != PORT_A)
+ 			DRM_DEBUG_KMS("Unexpected AUX channel for port A\n");
+ 		if (aux_channel == 0x10 && port != PORT_B)
+ 			DRM_DEBUG_KMS("Unexpected AUX channel for port B\n");
+ 		if (aux_channel == 0x20 && port != PORT_C)
+ 			DRM_DEBUG_KMS("Unexpected AUX channel for port C\n");
+ 		if (aux_channel == 0x30 && port != PORT_D)
+ 			DRM_DEBUG_KMS("Unexpected AUX channel for port D\n");
+ 	}
+ 
+ 	if (bdb->version >= 158) {
+ 		/* The VBT HDMI level shift values match the table we have. */
+ 		hdmi_level_shift = child->raw[7] & 0xF;
+ 		if (hdmi_level_shift < 0xC) {
+ 			DRM_DEBUG_KMS("VBT HDMI level shift for port %c: %d\n",
+ 				      port_name(port),
+ 				      hdmi_level_shift);
+ 			info->hdmi_level_shift = hdmi_level_shift;
+ 		}
+ 	}
+ }
+ 
+ static void parse_ddi_ports(struct drm_i915_private *dev_priv,
+ 			    struct bdb_header *bdb)
+ {
+ 	struct drm_device *dev = dev_priv->dev;
+ 	enum port port;
+ 
+ 	if (!HAS_DDI(dev))
+ 		return;
+ 
+ 	if (!dev_priv->vbt.child_dev_num)
+ 		return;
+ 
+ 	if (bdb->version < 155)
+ 		return;
+ 
+ 	for (port = PORT_A; port < I915_MAX_PORTS; port++)
+ 		parse_ddi_port(dev_priv, port, bdb);
+ }
+ 
++>>>>>>> ed3b66799368 (drm/i915: Fix crash when failing to parse MIPI VBT)
  static void
  parse_device_mapping(struct drm_i915_private *dev_priv,
  		       struct bdb_header *bdb)
* Unmerged path drivers/gpu/drm/i915/intel_bios.c
