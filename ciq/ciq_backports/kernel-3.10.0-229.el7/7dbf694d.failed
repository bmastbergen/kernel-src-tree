cpufreq: distinguish drivers that do asynchronous notifications

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] distinguish drivers that do asynchronous notifications (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 92.31%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 7dbf694db6ac7c759599316d50d7050efcbd512a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/7dbf694d.failed

There are few special cases like exynos5440 which doesn't send POSTCHANGE
notification from their ->target() routine and call some kind of bottom halves
for doing this work, work/tasklet/etc.. From which they finally send POSTCHANGE
notification.

Its better if we distinguish them from other cpufreq drivers in some way so that
core can handle them specially. So this patch introduces another flag:
CPUFREQ_ASYNC_NOTIFICATION, which will be set by such drivers.

This also changes exynos5440-cpufreq.c and powernow-k8 in order to set this
flag.

	Acked-by: Amit Daniel Kachhap <amit.daniel@samsung.com>
	Acked-by: Kukjin Kim <kgene.kim@samsung.com>
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 7dbf694db6ac7c759599316d50d7050efcbd512a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/exynos5440-cpufreq.c
#	drivers/cpufreq/powernow-k8.c
#	include/linux/cpufreq.h
diff --cc drivers/cpufreq/exynos5440-cpufreq.c
index 0c74018eda47,76bef8b078cb..000000000000
--- a/drivers/cpufreq/exynos5440-cpufreq.c
+++ b/drivers/cpufreq/exynos5440-cpufreq.c
@@@ -339,12 -312,14 +339,18 @@@ static int exynos_cpufreq_cpu_init(stru
  }
  
  static struct cpufreq_driver exynos_driver = {
++<<<<<<< HEAD
 +	.flags		= CPUFREQ_STICKY,
 +	.verify		= exynos_verify_speed,
 +	.target		= exynos_target,
++=======
+ 	.flags		= CPUFREQ_STICKY | CPUFREQ_ASYNC_NOTIFICATION,
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= exynos_target,
++>>>>>>> 7dbf694db6ac (cpufreq: distinguish drivers that do asynchronous notifications)
  	.get		= exynos_getspeed,
  	.init		= exynos_cpufreq_cpu_init,
 -	.exit		= cpufreq_generic_exit,
  	.name		= CPUFREQ_NAME,
 -	.attr		= cpufreq_generic_attr,
  };
  
  static const struct of_device_id exynos_cpufreq_match[] = {
diff --cc drivers/cpufreq/powernow-k8.c
index eefb04acff89,0023c7d40a51..000000000000
--- a/drivers/cpufreq/powernow-k8.c
+++ b/drivers/cpufreq/powernow-k8.c
@@@ -1222,14 -1203,10 +1222,20 @@@ out
  	return khz;
  }
  
 +static struct freq_attr *powernow_k8_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver cpufreq_amd64_driver = {
++<<<<<<< HEAD
 +	.verify		= powernowk8_verify,
 +	.target		= powernowk8_target,
++=======
+ 	.flags		= CPUFREQ_ASYNC_NOTIFICATION,
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= powernowk8_target,
++>>>>>>> 7dbf694db6ac (cpufreq: distinguish drivers that do asynchronous notifications)
  	.bios_limit	= acpi_processor_get_bios_limit,
  	.init		= powernowk8_cpu_init,
  	.exit		= powernowk8_cpu_exit,
diff --cc include/linux/cpufreq.h
index 241e07069182,5bd6ab9b0c27..000000000000
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@@ -331,26 -190,118 +331,86 @@@ __ATTR(_name, 0444, show_##_name, NULL
  static struct global_attr _name =		\
  __ATTR(_name, 0644, show_##_name, store_##_name)
  
++<<<<<<< HEAD
 +struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
 +void cpufreq_cpu_put(struct cpufreq_policy *data);
++=======
+ 
+ struct cpufreq_driver {
+ 	char			name[CPUFREQ_NAME_LEN];
+ 	u8			flags;
+ 
+ 	/* needed by all drivers */
+ 	int	(*init)		(struct cpufreq_policy *policy);
+ 	int	(*verify)	(struct cpufreq_policy *policy);
+ 
+ 	/* define one out of two */
+ 	int	(*setpolicy)	(struct cpufreq_policy *policy);
+ 	int	(*target)	(struct cpufreq_policy *policy,	/* Deprecated */
+ 				 unsigned int target_freq,
+ 				 unsigned int relation);
+ 	int	(*target_index)	(struct cpufreq_policy *policy,
+ 				 unsigned int index);
+ 
+ 	/* should be defined, if possible */
+ 	unsigned int	(*get)	(unsigned int cpu);
+ 
+ 	/* optional */
+ 	int	(*bios_limit)	(int cpu, unsigned int *limit);
+ 
+ 	int	(*exit)		(struct cpufreq_policy *policy);
+ 	int	(*suspend)	(struct cpufreq_policy *policy);
+ 	int	(*resume)	(struct cpufreq_policy *policy);
+ 	struct freq_attr	**attr;
+ };
+ 
+ /* flags */
+ #define CPUFREQ_STICKY		(1 << 0)	/* driver isn't removed even if
+ 						   all ->init() calls failed */
+ #define CPUFREQ_CONST_LOOPS	(1 << 1)	/* loops_per_jiffy or other
+ 						   kernel "constants" aren't
+ 						   affected by frequency
+ 						   transitions */
+ #define CPUFREQ_PM_NO_WARN	(1 << 2)	/* don't warn on suspend/resume
+ 						   speed mismatches */
+ 
+ /*
+  * This should be set by platforms having multiple clock-domains, i.e.
+  * supporting multiple policies. With this sysfs directories of governor would
+  * be created in cpu/cpu<num>/cpufreq/ directory and so they can use the same
+  * governor with different tunables for different clusters.
+  */
+ #define CPUFREQ_HAVE_GOVERNOR_PER_POLICY (1 << 3)
+ 
+ /*
+  * Driver will do POSTCHANGE notifications from outside of their ->target()
+  * routine and so must set cpufreq_driver->flags with this flag, so that core
+  * can handle them specially.
+  */
+ #define CPUFREQ_ASYNC_NOTIFICATION  (1 << 4)
+ 
+ int cpufreq_register_driver(struct cpufreq_driver *driver_data);
+ int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
+ 
++>>>>>>> 7dbf694db6ac (cpufreq: distinguish drivers that do asynchronous notifications)
  const char *cpufreq_get_current_driver(void);
  
 -static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
 -		unsigned int min, unsigned int max)
 -{
 -	if (policy->min < min)
 -		policy->min = min;
 -	if (policy->max < min)
 -		policy->max = min;
 -	if (policy->min > max)
 -		policy->min = max;
 -	if (policy->max > max)
 -		policy->max = max;
 -	if (policy->min > policy->max)
 -		policy->min = policy->max;
 -	return;
 -}
 -
 -static inline void
 -cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
 -{
 -	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
 -			policy->cpuinfo.max_freq);
 -}
 -
  /*********************************************************************
 - *                     CPUFREQ NOTIFIER INTERFACE                    *
 + *                        CPUFREQ 2.6. INTERFACE                     *
   *********************************************************************/
 -
 -#define CPUFREQ_TRANSITION_NOTIFIER	(0)
 -#define CPUFREQ_POLICY_NOTIFIER		(1)
 -
 -/* Transition notifiers */
 -#define CPUFREQ_PRECHANGE		(0)
 -#define CPUFREQ_POSTCHANGE		(1)
 -#define CPUFREQ_RESUMECHANGE		(8)
 -#define CPUFREQ_SUSPENDCHANGE		(9)
 -
 -/* Policy Notifiers  */
 -#define CPUFREQ_ADJUST			(0)
 -#define CPUFREQ_INCOMPATIBLE		(1)
 -#define CPUFREQ_NOTIFY			(2)
 -#define CPUFREQ_START			(3)
 -#define CPUFREQ_UPDATE_POLICY_CPU	(4)
 +u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
 +int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 +int cpufreq_update_policy(unsigned int cpu);
 +bool have_governor_per_policy(void);
 +struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
  
  #ifdef CONFIG_CPU_FREQ
 -int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
 -int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
 -
 -void cpufreq_notify_transition(struct cpufreq_policy *policy,
 -		struct cpufreq_freqs *freqs, unsigned int state);
 -
 -#else /* CONFIG_CPU_FREQ */
 -static inline int cpufreq_register_notifier(struct notifier_block *nb,
 -						unsigned int list)
 +/*
 + * query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it
 + */
 +unsigned int cpufreq_get(unsigned int cpu);
 +#else
 +static inline unsigned int cpufreq_get(unsigned int cpu)
  {
  	return 0;
  }
* Unmerged path drivers/cpufreq/exynos5440-cpufreq.c
* Unmerged path drivers/cpufreq/powernow-k8.c
* Unmerged path include/linux/cpufreq.h
