bnx2x: Fix sparse warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Yuval Mintz <Yuval.Mintz@qlogic.com>
commit 56daf66d3ca9558a71683779eec4f03c878f4de2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/56daf66d.failed

This fixes a sprase warning introduced recently by commit
eeed018cbfa30 ("bnx2x: Add timestamping and PTP hardware clock support"),
as well as another unrelated sparse endian issue.

	Signed-off-by: Yuval Mintz <Yuval.Mintz@qlogic.com>
	Signed-off-by: Ariel Elior <Ariel.Elior@qlogic.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 56daf66d3ca9558a71683779eec4f03c878f4de2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
diff --cc drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
index c5a32b5752c4,06d6d3c9316b..000000000000
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
@@@ -1067,6 -1064,11 +1067,14 @@@ reuse_rx
  
  		skb_record_rx_queue(skb, fp->rx_queue);
  
++<<<<<<< HEAD
++=======
+ 		/* Check if this packet was timestamped */
+ 		if (unlikely(cqe->fast_path_cqe.type_error_flags &
+ 			     (1 << ETH_FAST_PATH_RX_CQE_PTP_PKT_SHIFT)))
+ 			bnx2x_set_rx_ts(bp, skb);
+ 
++>>>>>>> 56daf66d3ca9 (bnx2x: Fix sparse warnings)
  		if (le16_to_cpu(cqe_fp->pars_flags.flags) &
  		    PARSING_FLAGS_VLAN)
  			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
* Unmerged path drivers/net/ethernet/broadcom/bnx2x/bnx2x_cmn.c
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
index 490e4ee7426c..218ddef3a465 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sp.c
@@ -4063,6 +4063,13 @@ static int bnx2x_setup_rss(struct bnx2x *bp,
 	if (test_bit(BNX2X_RSS_GRE_INNER_HDRS, &p->rss_flags))
 		caps |= ETH_RSS_UPDATE_RAMROD_DATA_GRE_INNER_HDRS_CAPABILITY;
 
+	/* RSS keys */
+	if (test_bit(BNX2X_RSS_SET_SRCH, &p->rss_flags)) {
+		memcpy(&data->rss_key[0], &p->rss_key[0],
+		       sizeof(data->rss_key));
+		caps |= ETH_RSS_UPDATE_RAMROD_DATA_UPDATE_RSS_KEY;
+	}
+
 	data->capabilities = cpu_to_le16(caps);
 
 	/* Hashing mask */
@@ -4084,13 +4091,6 @@ static int bnx2x_setup_rss(struct bnx2x *bp,
 	if (netif_msg_ifup(bp))
 		bnx2x_debug_print_ind_table(bp, p);
 
-	/* RSS keys */
-	if (test_bit(BNX2X_RSS_SET_SRCH, &p->rss_flags)) {
-		memcpy(&data->rss_key[0], &p->rss_key[0],
-		       sizeof(data->rss_key));
-		data->capabilities |= ETH_RSS_UPDATE_RAMROD_DATA_UPDATE_RSS_KEY;
-	}
-
 	/* No need for an explicit memory barrier here as long as we
 	 * ensure the ordering of writing to the SPQ element
 	 * and updating of the SPQ producer which involves a memory
