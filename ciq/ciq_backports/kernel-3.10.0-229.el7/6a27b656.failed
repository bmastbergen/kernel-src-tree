block: virtio-blk: support multi virt queues per virtio-blk device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] virtio_blk: support multi virt queues per virtio-blk device (Jeff Moyer) [1105698]
Rebuild_FUZZ: 92.80%
commit-author Ming Lei <ming.lei@canonical.com>
commit 6a27b656fc0210e976db362e1368c56db05c8f08
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/6a27b656.failed

Firstly this patch supports more than one virtual queues for virtio-blk
device.

Secondly this patch maps the virtual queue to blk-mq's hardware queue.

With this approach, both scalability and performance can be improved.

	Signed-off-by: Ming Lei <ming.lei@canonical.com>
	Acked-by: Michael S. Tsirkin <mst@redhat.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 6a27b656fc0210e976db362e1368c56db05c8f08)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/virtio_blk.c
diff --cc drivers/block/virtio_blk.c
index 94062c5cfd56,0a581400de0f..000000000000
--- a/drivers/block/virtio_blk.c
+++ b/drivers/block/virtio_blk.c
@@@ -154,9 -167,10 +164,10 @@@ static void virtblk_done(struct virtque
  static int virtio_queue_rq(struct blk_mq_hw_ctx *hctx, struct request *req)
  {
  	struct virtio_blk *vblk = hctx->queue->queuedata;
 -	struct virtblk_req *vbr = blk_mq_rq_to_pdu(req);
 +	struct virtblk_req *vbr = req->special;
  	unsigned long flags;
  	unsigned int num;
+ 	int qid = hctx->queue_num;
  	const bool last = (req->cmd_flags & REQ_END) != 0;
  	int err;
  	bool notify = false;
@@@ -564,24 -623,34 +626,43 @@@ static int virtblk_probe(struct virtio_
  	}
  
  	/* Default queue sizing is to fill the ring. */
++<<<<<<< HEAD
 +	if (!virtio_mq_reg.queue_depth) {
 +		virtio_mq_reg.queue_depth = vblk->vq->num_free;
++=======
+ 	if (!virtblk_queue_depth) {
+ 		virtblk_queue_depth = vblk->vqs[0].vq->num_free;
++>>>>>>> 6a27b656fc02 (block: virtio-blk: support multi virt queues per virtio-blk device)
  		/* ... but without indirect descs, we use 2 descs per req */
  		if (!virtio_has_feature(vdev, VIRTIO_RING_F_INDIRECT_DESC))
 -			virtblk_queue_depth /= 2;
 +			virtio_mq_reg.queue_depth /= 2;
  	}
++<<<<<<< HEAD
 +	virtio_mq_reg.cmd_size =
 +		sizeof(struct virtblk_req) +
 +		sizeof(struct scatterlist) * sg_elems;
++=======
+ 
+ 	memset(&vblk->tag_set, 0, sizeof(vblk->tag_set));
+ 	vblk->tag_set.ops = &virtio_mq_ops;
+ 	vblk->tag_set.queue_depth = virtblk_queue_depth;
+ 	vblk->tag_set.numa_node = NUMA_NO_NODE;
+ 	vblk->tag_set.flags = BLK_MQ_F_SHOULD_MERGE;
+ 	vblk->tag_set.cmd_size =
+ 		sizeof(struct virtblk_req) +
+ 		sizeof(struct scatterlist) * sg_elems;
+ 	vblk->tag_set.driver_data = vblk;
+ 	vblk->tag_set.nr_hw_queues = vblk->num_vqs;
++>>>>>>> 6a27b656fc02 (block: virtio-blk: support multi virt queues per virtio-blk device)
  
 -	err = blk_mq_alloc_tag_set(&vblk->tag_set);
 -	if (err)
 -		goto out_put_disk;
 -
 -	q = vblk->disk->queue = blk_mq_init_queue(&vblk->tag_set);
 +	q = vblk->disk->queue = blk_mq_init_queue(&virtio_mq_reg, vblk);
  	if (!q) {
  		err = -ENOMEM;
 -		goto out_free_tags;
 +		goto out_put_disk;
  	}
  
 +	blk_mq_init_commands(q, virtblk_init_vbr, vblk);
 +
  	q->queuedata = vblk;
  
  	virtblk_name_format("vd", index, vblk->disk->disk_name, DISK_NAME_LEN);
* Unmerged path drivers/block/virtio_blk.c
