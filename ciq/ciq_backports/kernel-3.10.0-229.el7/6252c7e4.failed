i40e: reapply LAA after reset

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Shannon Nelson <shannon.nelson@intel.com>
commit 6252c7e4ee48f016dd075168df9fabc7197f38e5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/6252c7e4.failed

The LAA is lost on a reset, so be sure to replay it when rebuilding
the switch after any reset.

Change-ID: I6e643f9a59dfd899b6cbdf84d93b4bc9c37bb949
	Signed-off-by: Shannon Nelson <shannon.nelson@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 6252c7e4ee48f016dd075168df9fabc7197f38e5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index a960b5c3292a,9276ca3f43f2..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -1277,22 -1342,27 +1277,44 @@@ static int i40e_set_mac(struct net_devi
  				    ret);
  			return -EADDRNOTAVAIL;
  		}
 +
 +		memcpy(vsi->back->hw.mac.addr, addr->sa_data, netdev->addr_len);
  	}
  
++<<<<<<< HEAD
 +	/* In order to be sure to not drop any packets, add the new address
 +	 * then delete the old one.
 +	 */
 +	f = i40e_add_filter(vsi, addr->sa_data, I40E_VLAN_ANY, false, false);
 +	if (!f)
 +		return -ENOMEM;
 +
 +	i40e_sync_vsi_filters(vsi);
 +	i40e_del_filter(vsi, netdev->dev_addr, I40E_VLAN_ANY, false, false);
 +	i40e_sync_vsi_filters(vsi);
 +
 +	memcpy(netdev->dev_addr, addr->sa_data, netdev->addr_len);
++=======
+ 	f = i40e_find_mac(vsi, addr->sa_data, false, true);
+ 	if (!f) {
+ 		/* In order to be sure to not drop any packets, add the
+ 		 * new address first then delete the old one.
+ 		 */
+ 		f = i40e_add_filter(vsi, addr->sa_data, I40E_VLAN_ANY,
+ 				    false, false);
+ 		if (!f)
+ 			return -ENOMEM;
+ 
+ 		i40e_sync_vsi_filters(vsi);
+ 		i40e_del_filter(vsi, netdev->dev_addr, I40E_VLAN_ANY,
+ 				false, false);
+ 		i40e_sync_vsi_filters(vsi);
+ 	}
+ 
+ 	f->is_laa = true;
+ 	if (!ether_addr_equal(netdev->dev_addr, addr->sa_data))
+ 		ether_addr_copy(netdev->dev_addr, addr->sa_data);
++>>>>>>> 6252c7e4ee48 (i40e: reapply LAA after reset)
  
  	return 0;
  }
diff --git a/drivers/net/ethernet/intel/i40e/i40e.h b/drivers/net/ethernet/intel/i40e/i40e.h
index db1ac025983c..e6392d19281d 100644
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -351,6 +351,7 @@ struct i40e_mac_filter {
 	bool is_vf;		/* filter belongs to a VF */
 	bool is_netdev;		/* filter belongs to a netdev */
 	bool changed;		/* filter needs to be sync'd to the HW */
+	bool is_laa;		/* filter is a Locally Administered Address */
 };
 
 struct i40e_veb {
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
