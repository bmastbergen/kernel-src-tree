qlcnic: Fix panic while dumping TX queues on TX timeout

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Manish Chopra <manish.chopra@qlogic.com>
commit d5d2bf3eabb34cc8eaf54db37fdc43f04267985a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d5d2bf3e.failed

o In case of non-multi TX queue mode driver does not initialize "crb_intr_mask" pointer
  and driver was accessing that un-initialized pointer while dumping TX queue.
  So dump "crb_intr_mask" only when it is initilaized.

	Signed-off-by: Manish Chopra <manish.chopra@qlogic.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit d5d2bf3eabb34cc8eaf54db37fdc43f04267985a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index 9918316d26ed,be789513774c..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@@ -2722,6 -2910,58 +2722,61 @@@ int qlcnic_check_temp(struct qlcnic_ada
  	return rv;
  }
  
++<<<<<<< HEAD
++=======
+ static inline void dump_tx_ring_desc(struct qlcnic_host_tx_ring *tx_ring)
+ {
+ 	int i;
+ 	struct cmd_desc_type0 *tx_desc_info;
+ 
+ 	for (i = 0; i < tx_ring->num_desc; i++) {
+ 		tx_desc_info = &tx_ring->desc_head[i];
+ 		pr_info("TX Desc: %d\n", i);
+ 		print_hex_dump(KERN_INFO, "TX: ", DUMP_PREFIX_OFFSET, 16, 1,
+ 			       &tx_ring->desc_head[i],
+ 			       sizeof(struct cmd_desc_type0), true);
+ 	}
+ }
+ 
+ static void qlcnic_dump_tx_rings(struct qlcnic_adapter *adapter)
+ {
+ 	struct net_device *netdev = adapter->netdev;
+ 	struct qlcnic_host_tx_ring *tx_ring;
+ 	int ring;
+ 
+ 	if (!netdev || !netif_running(netdev))
+ 		return;
+ 
+ 	for (ring = 0; ring < adapter->drv_tx_rings; ring++) {
+ 		tx_ring = &adapter->tx_ring[ring];
+ 		netdev_info(netdev, "Tx ring=%d Context Id=0x%x\n",
+ 			    ring, tx_ring->ctx_id);
+ 		netdev_info(netdev,
+ 			    "xmit_finished=%llu, xmit_called=%llu, xmit_on=%llu, xmit_off=%llu\n",
+ 			    tx_ring->tx_stats.xmit_finished,
+ 			    tx_ring->tx_stats.xmit_called,
+ 			    tx_ring->tx_stats.xmit_on,
+ 			    tx_ring->tx_stats.xmit_off);
+ 
+ 		if (tx_ring->crb_intr_mask)
+ 			netdev_info(netdev, "crb_intr_mask=%d\n",
+ 				    readl(tx_ring->crb_intr_mask));
+ 
+ 		netdev_info(netdev,
+ 			    "hw_producer=%d, sw_producer=%d sw_consumer=%d, hw_consumer=%d\n",
+ 			    readl(tx_ring->crb_cmd_producer),
+ 			    tx_ring->producer, tx_ring->sw_consumer,
+ 			    le32_to_cpu(*(tx_ring->hw_consumer)));
+ 
+ 		netdev_info(netdev, "Total desc=%d, Available desc=%d\n",
+ 			    tx_ring->num_desc, qlcnic_tx_avail(tx_ring));
+ 
+ 		if (netif_msg_tx_done(adapter->ahw))
+ 			dump_tx_ring_desc(tx_ring);
+ 	}
+ }
+ 
++>>>>>>> d5d2bf3eabb3 (qlcnic: Fix panic while dumping TX queues on TX timeout)
  static void qlcnic_tx_timeout(struct net_device *netdev)
  {
  	struct qlcnic_adapter *adapter = netdev_priv(netdev);
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
