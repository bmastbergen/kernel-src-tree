i40e: Tx/Rx rings declaration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
commit e7046ee1f820f7cbe870c1a62cd27b8fc420155d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e7046ee1.failed

This patch changes the declaration of Tx/Rx rings inside several loops. It
eliminates declaring the same rings every time for the duration of the loop,
instead declaring them once before the loop.

Change-ID: I59dea54276f18c47dca522f520c18f65fe42a15d
	Signed-off-by: Akeem G Abodunrin <akeem.g.abodunrin@intel.com>
	Tested-by: Kavindya Deegala <kavindya.s.deegala@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit e7046ee1f820f7cbe870c1a62cd27b8fc420155d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e_ethtool.c
diff --cc drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 7c5448156f3e,a7bf14953c95..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@@ -644,9 -650,8 +645,14 @@@ static void i40e_get_ethtool_stats(stru
  			sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
  	}
  	rcu_read_lock();
++<<<<<<< HEAD
 +	for (j = 0; j < vsi->num_queue_pairs; j++, i += 4) {
 +		struct i40e_ring *tx_ring = ACCESS_ONCE(vsi->tx_rings[j]);
 +		struct i40e_ring *rx_ring;
++=======
+ 	for (j = 0; j < vsi->num_queue_pairs; j++) {
+ 		tx_ring = ACCESS_ONCE(vsi->tx_rings[j]);
++>>>>>>> e7046ee1f820 (i40e: Tx/Rx rings declaration)
  
  		if (!tx_ring)
  			continue;
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_ethtool.c
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index 9ae4a80de9e8..f76a4d2ab629 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -356,6 +356,7 @@ static struct rtnl_link_stats64 *i40e_get_netdev_stats_struct(
 					     struct rtnl_link_stats64 *stats)
 {
 	struct i40e_netdev_priv *np = netdev_priv(netdev);
+	struct i40e_ring *tx_ring, *rx_ring;
 	struct i40e_vsi *vsi = np->vsi;
 	struct rtnl_link_stats64 *vsi_stats = i40e_get_vsi_stats_struct(vsi);
 	int i;
@@ -368,7 +369,6 @@ static struct rtnl_link_stats64 *i40e_get_netdev_stats_struct(
 
 	rcu_read_lock();
 	for (i = 0; i < vsi->num_queue_pairs; i++) {
-		struct i40e_ring *tx_ring, *rx_ring;
 		u64 bytes, packets;
 		unsigned int start;
 
@@ -2393,6 +2393,7 @@ static int i40e_vsi_configure_rx(struct i40e_vsi *vsi)
  **/
 static void i40e_vsi_config_dcb_rings(struct i40e_vsi *vsi)
 {
+	struct i40e_ring *tx_ring, *rx_ring;
 	u16 qoffset, qcount;
 	int i, n;
 
@@ -2406,8 +2407,8 @@ static void i40e_vsi_config_dcb_rings(struct i40e_vsi *vsi)
 		qoffset = vsi->tc_config.tc_info[n].qoffset;
 		qcount = vsi->tc_config.tc_info[n].qcount;
 		for (i = qoffset; i < (qoffset + qcount); i++) {
-			struct i40e_ring *rx_ring = vsi->rx_rings[i];
-			struct i40e_ring *tx_ring = vsi->tx_rings[i];
+			rx_ring = vsi->rx_rings[i];
+			tx_ring = vsi->tx_rings[i];
 			rx_ring->dcb_tc = n;
 			tx_ring->dcb_tc = n;
 		}
@@ -5926,14 +5927,12 @@ static void i40e_vsi_clear_rings(struct i40e_vsi *vsi)
  **/
 static int i40e_alloc_rings(struct i40e_vsi *vsi)
 {
+	struct i40e_ring *tx_ring, *rx_ring;
 	struct i40e_pf *pf = vsi->back;
 	int i;
 
 	/* Set basic values in the rings to be used later during open() */
 	for (i = 0; i < vsi->alloc_queue_pairs; i++) {
-		struct i40e_ring *tx_ring;
-		struct i40e_ring *rx_ring;
-
 		/* allocate space for both Tx and Rx in one shot */
 		tx_ring = kzalloc(sizeof(struct i40e_ring) * 2, GFP_KERNEL);
 		if (!tx_ring)
