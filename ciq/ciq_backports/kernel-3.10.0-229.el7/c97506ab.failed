ixgbe: Add check for FW veto bit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Don Skidmore <donald.c.skidmore@intel.com>
commit c97506ab0e224613aa4fe9898f72d5e3eaf81772
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/c97506ab.failed

The driver will now honor the MNG FW veto bit in blocking link resets.
This patch will affect x520 and x540 systems.

	Signed-off-by: Don Skidmore <donald.c.skidmore@intel.com>
	Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
	Signed-off-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c97506ab0e224613aa4fe9898f72d5e3eaf81772)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
index 29fd5786e174,b96cefd5a2eb..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
@@@ -207,6 -188,79 +207,82 @@@ setup_sfp_err
  	return IXGBE_ERR_SFP_SETUP_NOT_COMPLETE;
  }
  
++<<<<<<< HEAD
++=======
+ /**
+  *  prot_autoc_read_82599 - Hides MAC differences needed for AUTOC read
+  *  @hw: pointer to hardware structure
+  *  @locked: Return the if we locked for this read.
+  *  @reg_val: Value we read from AUTOC
+  *
+  *  For this part (82599) we need to wrap read-modify-writes with a possible
+  *  FW/SW lock.  It is assumed this lock will be freed with the next
+  *  prot_autoc_write_82599().  Note, that locked can only be true in cases
+  *  where this function doesn't return an error.
+  **/
+ static s32 prot_autoc_read_82599(struct ixgbe_hw *hw, bool *locked,
+ 				 u32 *reg_val)
+ {
+ 	s32 ret_val;
+ 
+ 	*locked = false;
+ 	/* If LESM is on then we need to hold the SW/FW semaphore. */
+ 	if (ixgbe_verify_lesm_fw_enabled_82599(hw)) {
+ 		ret_val = hw->mac.ops.acquire_swfw_sync(hw,
+ 					IXGBE_GSSR_MAC_CSR_SM);
+ 		if (!ret_val)
+ 			return IXGBE_ERR_SWFW_SYNC;
+ 
+ 		*locked = true;
+ 	}
+ 
+ 	*reg_val = IXGBE_READ_REG(hw, IXGBE_AUTOC);
+ 	return 0;
+ }
+ 
+ /**
+  * prot_autoc_write_82599 - Hides MAC differences needed for AUTOC write
+  * @hw: pointer to hardware structure
+  * @reg_val: value to write to AUTOC
+  * @locked: bool to indicate whether the SW/FW lock was already taken by
+  *	     previous proc_autoc_read_82599.
+  *
+  * This part (82599) may need to hold a the SW/FW lock around all writes to
+  * AUTOC. Likewise after a write we need to do a pipeline reset.
+  **/
+ static s32 prot_autoc_write_82599(struct ixgbe_hw *hw, u32 autoc, bool locked)
+ {
+ 	s32 ret_val = 0;
+ 
+ 	/* Blocked by MNG FW so bail */
+ 	if (ixgbe_check_reset_blocked(hw))
+ 		goto out;
+ 
+ 	/* We only need to get the lock if:
+ 	 *  - We didn't do it already (in the read part of a read-modify-write)
+ 	 *  - LESM is enabled.
+ 	 */
+ 	if (!locked && ixgbe_verify_lesm_fw_enabled_82599(hw)) {
+ 		ret_val = hw->mac.ops.acquire_swfw_sync(hw,
+ 					IXGBE_GSSR_MAC_CSR_SM);
+ 		if (!ret_val)
+ 			return IXGBE_ERR_SWFW_SYNC;
+ 	}
+ 
+ 	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc);
+ 	ret_val = ixgbe_reset_pipeline_82599(hw);
+ 
+ out:
+ 	/* Free the SW/FW semaphore as we either grabbed it here or
+ 	 * already had it when this function was called.
+ 	 */
+ 	if (locked)
+ 		hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);
+ 
+ 	return ret_val;
+ }
+ 
++>>>>>>> c97506ab0e22 (ixgbe: Add check for FW veto bit)
  static s32 ixgbe_get_invariants_82599(struct ixgbe_hw *hw)
  {
  	struct ixgbe_mac_info *mac = &hw->mac;
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
index e4c676006be9..562f0f62d780 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
@@ -1,7 +1,7 @@
 /*******************************************************************************
 
   Intel 10 Gigabit PCI Express Linux driver
-  Copyright(c) 1999 - 2013 Intel Corporation.
+  Copyright(c) 1999 - 2014 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify it
   under the terms and conditions of the GNU General Public License,
@@ -96,6 +96,32 @@ s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw)
 	return status;
 }
 
+/**
+ * ixgbe_check_reset_blocked - check status of MNG FW veto bit
+ * @hw: pointer to the hardware structure
+ *
+ * This function checks the MMNGC.MNG_VETO bit to see if there are
+ * any constraints on link from manageability.  For MAC's that don't
+ * have this bit just return false since the link can not be blocked
+ * via this method.
+ **/
+s32 ixgbe_check_reset_blocked(struct ixgbe_hw *hw)
+{
+	u32 mmngc;
+
+	/* If we don't have this bit, it can't be blocking */
+	if (hw->mac.type == ixgbe_mac_82598EB)
+		return false;
+
+	mmngc = IXGBE_READ_REG(hw, IXGBE_MMNGC);
+	if (mmngc & IXGBE_MMNGC_MNG_VETO) {
+		hw_dbg(hw, "MNG_VETO bit detected.\n");
+		return true;
+	}
+
+	return false;
+}
+
 /**
  *  ixgbe_get_phy_id - Get the phy type
  *  @hw: pointer to hardware structure
@@ -171,6 +197,10 @@ s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw)
 	    (IXGBE_ERR_OVERTEMP == hw->phy.ops.check_overtemp(hw)))
 		goto out;
 
+	/* Blocked by MNG FW so bail */
+	if (ixgbe_check_reset_blocked(hw))
+		goto out;
+
 	/*
 	 * Perform soft PHY reset to the PHY_XS.
 	 * This will cause a soft reset to the PHY
@@ -475,6 +505,10 @@ s32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw)
 				      autoneg_reg);
 	}
 
+	/* Blocked by MNG FW so don't reset PHY */
+	if (ixgbe_check_reset_blocked(hw))
+		return status;
+
 	/* Restart PHY autonegotiation and wait for completion */
 	hw->phy.ops.read_reg(hw, MDIO_CTRL1,
 			     MDIO_MMD_AN, &autoneg_reg);
@@ -681,6 +715,10 @@ s32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw)
 				      autoneg_reg);
 	}
 
+	/* Blocked by MNG FW so don't reset PHY */
+	if (ixgbe_check_reset_blocked(hw))
+		return status;
+
 	/* Restart PHY autonegotiation and wait for completion */
 	hw->phy.ops.read_reg(hw, MDIO_CTRL1,
 			     MDIO_MMD_AN, &autoneg_reg);
@@ -758,6 +796,10 @@ s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw)
 	s32 ret_val = 0;
 	u32 i;
 
+	/* Blocked by MNG FW so bail */
+	if (ixgbe_check_reset_blocked(hw))
+		goto out;
+
 	hw->phy.ops.read_reg(hw, MDIO_CTRL1, MDIO_MMD_PHYXS, &phy_data);
 
 	/* reset the PHY and poll for completion */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h
index aae900a256da..5cc4388d8365 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 
   Intel 10 Gigabit PCI Express Linux driver
-  Copyright(c) 1999 - 2013 Intel Corporation.
+  Copyright(c) 1999 - 2014 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify it
   under the terms and conditions of the GNU General Public License,
@@ -131,6 +131,7 @@ s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw,
 s32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw,
                                                ixgbe_link_speed *speed,
                                                bool *autoneg);
+s32 ixgbe_check_reset_blocked(struct ixgbe_hw *hw);
 
 /* PHY specific */
 s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw,
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
index e9ef4fedd445..7a1af011eb9c 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
@@ -1,7 +1,7 @@
 /*******************************************************************************
 
   Intel 10 Gigabit PCI Express Linux driver
-  Copyright(c) 1999 - 2013 Intel Corporation.
+  Copyright(c) 1999 - 2014 Intel Corporation.
 
   This program is free software; you can redistribute it and/or modify it
   under the terms and conditions of the GNU General Public License,
@@ -1605,6 +1605,9 @@ enum {
 #define IXGBE_MACC_FS        0x00040000
 #define IXGBE_MAC_RX2TX_LPBK 0x00000002
 
+/* Veto Bit definiton */
+#define IXGBE_MMNGC_MNG_VETO  0x00000001
+
 /* LINKS Bit Masks */
 #define IXGBE_LINKS_KX_AN_COMP  0x80000000
 #define IXGBE_LINKS_UP          0x40000000
