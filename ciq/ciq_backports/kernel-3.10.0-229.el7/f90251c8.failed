hyperv: Increase the buffer length for netvsc_channel_cb()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Haiyang Zhang <haiyangz@microsoft.com>
commit f90251c8a6d06ed8b072a2a0f13c4b8a6d0cb222
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/f90251c8.failed

When the buffer is too small for a packet from VMBus, a bigger buffer will be
allocated in netvsc_channel_cb() and retry reading the packet from VMBus.
Increasing this buffer size will reduce the retry overhead.

	Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
	Reviewed-by: Dexuan Cui <decui@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f90251c8a6d06ed8b072a2a0f13c4b8a6d0cb222)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc.c
diff --cc drivers/net/hyperv/hyperv_net.h
index a2561fea6d21,2f48f790c9b4..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -521,10 -588,12 +521,14 @@@ struct nvsp_message 
  
  #define NETVSC_RECEIVE_BUFFER_ID		0xcafe
  
++<<<<<<< HEAD
 +/* Preallocated receive packets */
 +#define NETVSC_RECEIVE_PACKETLIST_COUNT		256
++=======
+ #define NETVSC_PACKET_SIZE                      4096
++>>>>>>> f90251c8a6d0 (hyperv: Increase the buffer length for netvsc_channel_cb())
  
 -#define VRSS_SEND_TAB_SIZE 16
 +#define NETVSC_PACKET_SIZE                      2048
  
  /* Per netvsc channel-specific */
  struct netvsc_device {
@@@ -559,8 -631,20 +563,18 @@@
  
  	struct net_device *ndev;
  
 -	struct vmbus_channel *chn_table[NR_CPUS];
 -	u32 send_table[VRSS_SEND_TAB_SIZE];
 -	u32 num_chn;
 -	atomic_t queue_sends[NR_CPUS];
 -
  	/* Holds rndis device info */
  	void *extension;
++<<<<<<< HEAD
++=======
+ 
+ 	int ring_size;
+ 
+ 	/* The primary channel callback buffer */
+ 	unsigned char *cb_buffer;
+ 	/* The sub channel callback buffer */
+ 	unsigned char *sub_cb_buf;
++>>>>>>> f90251c8a6d0 (hyperv: Increase the buffer length for netvsc_channel_cb())
  };
  
  /* NdisInitialize message */
diff --cc drivers/net/hyperv/netvsc.c
index 9cc0753cff9d,5b5644a2233c..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -417,13 -560,10 +429,13 @@@ int netvsc_device_remove(struct hv_devi
  	vmbus_close(device->channel);
  
  	/* Release all resources */
 -	if (net_device->sub_cb_buf)
 -		vfree(net_device->sub_cb_buf);
 +	list_for_each_entry_safe(netvsc_packet, pos,
 +				 &net_device->recv_pkt_list, list_ent) {
 +		list_del(&netvsc_packet->list_ent);
 +		kfree(netvsc_packet);
 +	}
  
- 	kfree(net_device);
+ 	free_netvsc_device(net_device);
  	return 0;
  }
  
@@@ -962,17 -1105,7 +974,21 @@@ close
  	vmbus_close(device->channel);
  
  cleanup:
++<<<<<<< HEAD
 +
 +	if (net_device) {
 +		list_for_each_entry_safe(packet, pos,
 +					 &net_device->recv_pkt_list,
 +					 list_ent) {
 +			list_del(&packet->list_ent);
 +			kfree(packet);
 +		}
 +
 +		kfree(net_device);
 +	}
++=======
+ 	free_netvsc_device(net_device);
++>>>>>>> f90251c8a6d0 (hyperv: Increase the buffer length for netvsc_channel_cb())
  
  	return ret;
  }
* Unmerged path drivers/net/hyperv/hyperv_net.h
* Unmerged path drivers/net/hyperv/netvsc.c
