kexec: export free_huge_page to VMCOREINFO

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Atsushi Kumagai <kumagai-atsushi@mxc.nes.nec.co.jp>
commit 8f1d26d0e59b9676587c54578f976709b625d6e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/8f1d26d0.failed

PG_head_mask was added into VMCOREINFO to filter huge pages in b3acc56bfe1
("kexec: save PG_head_mask in VMCOREINFO"), but makedumpfile still need
another symbol to filter *hugetlbfs* pages.

If a user hope to filter user pages, makedumpfile tries to exclude them by
checking the condition whether the page is anonymous, but hugetlbfs pages
aren't anonymous while they also be user pages.

We know it's possible to detect them in the same way as PageHuge(),
so we need the start address of free_huge_page():

    int PageHuge(struct page *page)
    {
            if (!PageCompound(page))
                    return 0;

            page = compound_head(page);
            return get_compound_page_dtor(page) == free_huge_page;
    }

For that reason, this patch changes free_huge_page() into public
to export it to VMCOREINFO.

	Signed-off-by: Atsushi Kumagai <kumagai-atsushi@mxc.nes.nec.co.jp>
	Acked-by: Baoquan He <bhe@redhat.com>
	Cc: Vivek Goyal <vgoyal@redhat.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 8f1d26d0e59b9676587c54578f976709b625d6e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/hugetlb.h
#	kernel/kexec.c
diff --cc include/linux/hugetlb.h
index 3386cad757e9,a23c096b3080..000000000000
--- a/include/linux/hugetlb.h
+++ b/include/linux/hugetlb.h
@@@ -67,6 -77,14 +67,17 @@@ int hugetlb_reserve_pages(struct inode 
  						vm_flags_t vm_flags);
  void hugetlb_unreserve_pages(struct inode *inode, long offset, long freed);
  int dequeue_hwpoisoned_huge_page(struct page *page);
++<<<<<<< HEAD
++=======
+ bool isolate_huge_page(struct page *page, struct list_head *list);
+ void putback_active_hugepage(struct page *page);
+ bool is_hugepage_active(struct page *page);
+ void free_huge_page(struct page *page);
+ 
+ #ifdef CONFIG_ARCH_WANT_HUGE_PMD_SHARE
+ pte_t *huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud);
+ #endif
++>>>>>>> 8f1d26d0e59b (kexec: export free_huge_page to VMCOREINFO)
  
  extern unsigned long hugepages_treat_as_movable;
  extern const unsigned long hugetlb_zero, hugetlb_infinity;
diff --cc kernel/kexec.c
index 650eef6c770a,23a088fec3c0..000000000000
--- a/kernel/kexec.c
+++ b/kernel/kexec.c
@@@ -32,7 -32,8 +32,12 @@@
  #include <linux/vmalloc.h>
  #include <linux/swap.h>
  #include <linux/syscore_ops.h>
++<<<<<<< HEAD
 +#include <linux/security.h>
++=======
+ #include <linux/compiler.h>
+ #include <linux/hugetlb.h>
++>>>>>>> 8f1d26d0e59b (kexec: export free_huge_page to VMCOREINFO)
  
  #include <asm/page.h>
  #include <asm/uaccess.h>
* Unmerged path include/linux/hugetlb.h
* Unmerged path kernel/kexec.c
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index e9ed3cb4a5b2..f3888f57995d 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -659,7 +659,7 @@ struct hstate *size_to_hstate(unsigned long size)
 	return NULL;
 }
 
-static void free_huge_page(struct page *page)
+void free_huge_page(struct page *page)
 {
 	/*
 	 * Can't pass hstate in here because it is called from the
