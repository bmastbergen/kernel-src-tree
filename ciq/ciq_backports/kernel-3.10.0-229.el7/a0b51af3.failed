perf hists: Check if accumulated when adding a hist entry

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf/hists: Check if accumulated when adding a hist entry (Jiri Olsa) [1134356]
Rebuild_FUZZ: 98.25%
commit-author Namhyung Kim <namhyung@kernel.org>
commit a0b51af367a6831330564c96dc4cc1ac63413701
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a0b51af3.failed

To support callchain accumulation, @entry should be recognized if it's
accumulated or not when add_hist_entry() called.  The period of an
accumulated entry should be added to ->stat_acc but not ->stat. Add
@sample_self arg for that.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Tested-by: Arun Sharma <asharma@fb.com>
	Tested-by: Rodrigo Campos <rodrigo@sdfg.com.ar>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
Link: http://lkml.kernel.org/r/1401335910-16832-5-git-send-email-namhyung@kernel.org
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
(cherry picked from commit a0b51af367a6831330564c96dc4cc1ac63413701)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/hist.c
#	tools/perf/util/hist.h
diff --cc tools/perf/util/hist.c
index 9820956c30b9,b9facf33b224..000000000000
--- a/tools/perf/util/hist.c
+++ b/tools/perf/util/hist.c
@@@ -277,14 -279,31 +277,29 @@@ void hists__decay_entries(struct hists 
   * histogram, sorted on item, collects periods
   */
  
- static struct hist_entry *hist_entry__new(struct hist_entry *template)
+ static struct hist_entry *hist_entry__new(struct hist_entry *template,
+ 					  bool sample_self)
  {
 -	size_t callchain_size = 0;
 -	struct hist_entry *he;
 -
 -	if (symbol_conf.use_callchain || symbol_conf.cumulate_callchain)
 -		callchain_size = sizeof(struct callchain_root);
 -
 -	he = zalloc(sizeof(*he) + callchain_size);
 +	size_t callchain_size = symbol_conf.use_callchain ? sizeof(struct callchain_root) : 0;
 +	struct hist_entry *he = zalloc(sizeof(*he) + callchain_size);
  
  	if (he != NULL) {
  		*he = *template;
  
++<<<<<<< HEAD
++=======
+ 		if (symbol_conf.cumulate_callchain) {
+ 			he->stat_acc = malloc(sizeof(he->stat));
+ 			if (he->stat_acc == NULL) {
+ 				free(he);
+ 				return NULL;
+ 			}
+ 			memcpy(he->stat_acc, &he->stat, sizeof(he->stat));
+ 			if (!sample_self)
+ 				memset(&he->stat, 0, sizeof(he->stat));
+ 		}
+ 
++>>>>>>> a0b51af367a6 (perf hists: Check if accumulated when adding a hist entry)
  		if (he->ms.map)
  			he->ms.map->referenced = true;
  
@@@ -369,13 -379,16 +385,20 @@@ static struct hist_entry *add_hist_entr
  		cmp = hist_entry__cmp(he, entry);
  
  		if (!cmp) {
++<<<<<<< HEAD
 +			he_stat__add_period(&he->stat, period, weight);
++=======
+ 			if (sample_self)
+ 				he_stat__add_period(&he->stat, period, weight);
+ 			if (symbol_conf.cumulate_callchain)
+ 				he_stat__add_period(he->stat_acc, period, weight);
++>>>>>>> a0b51af367a6 (perf hists: Check if accumulated when adding a hist entry)
  
  			/*
 -			 * This mem info was allocated from sample__resolve_mem
 +			 * This mem info was allocated from machine__resolve_mem
  			 * and will not be used anymore.
  			 */
 -			zfree(&entry->mem_info);
 +			free(entry->mem_info);
  
  			/* If the map of an existing hist_entry has
  			 * become out-of-date due to an exec() or
@@@ -404,7 -417,10 +427,14 @@@
  	rb_link_node(&he->rb_node_in, parent, p);
  	rb_insert_color(&he->rb_node_in, hists->entries_in);
  out:
++<<<<<<< HEAD
 +	he_stat__add_cpumode_period(&he->stat, al->cpumode, period);
++=======
+ 	if (sample_self)
+ 		he_stat__add_cpumode_period(&he->stat, al->cpumode, period);
+ 	if (symbol_conf.cumulate_callchain)
+ 		he_stat__add_cpumode_period(he->stat_acc, al->cpumode, period);
++>>>>>>> a0b51af367a6 (perf hists: Check if accumulated when adding a hist entry)
  	return he;
  }
  
@@@ -438,9 -455,307 +469,310 @@@ struct hist_entry *__hists__add_entry(s
  		.transaction = transaction,
  	};
  
- 	return add_hist_entry(hists, &entry, al);
+ 	return add_hist_entry(hists, &entry, al, sample_self);
+ }
+ 
++<<<<<<< HEAD
++=======
+ static int
+ iter_next_nop_entry(struct hist_entry_iter *iter __maybe_unused,
+ 		    struct addr_location *al __maybe_unused)
+ {
+ 	return 0;
+ }
+ 
+ static int
+ iter_add_next_nop_entry(struct hist_entry_iter *iter __maybe_unused,
+ 			struct addr_location *al __maybe_unused)
+ {
+ 	return 0;
+ }
+ 
+ static int
+ iter_prepare_mem_entry(struct hist_entry_iter *iter, struct addr_location *al)
+ {
+ 	struct perf_sample *sample = iter->sample;
+ 	struct mem_info *mi;
+ 
+ 	mi = sample__resolve_mem(sample, al);
+ 	if (mi == NULL)
+ 		return -ENOMEM;
+ 
+ 	iter->priv = mi;
+ 	return 0;
+ }
+ 
+ static int
+ iter_add_single_mem_entry(struct hist_entry_iter *iter, struct addr_location *al)
+ {
+ 	u64 cost;
+ 	struct mem_info *mi = iter->priv;
+ 	struct hist_entry *he;
+ 
+ 	if (mi == NULL)
+ 		return -EINVAL;
+ 
+ 	cost = iter->sample->weight;
+ 	if (!cost)
+ 		cost = 1;
+ 
+ 	/*
+ 	 * must pass period=weight in order to get the correct
+ 	 * sorting from hists__collapse_resort() which is solely
+ 	 * based on periods. We want sorting be done on nr_events * weight
+ 	 * and this is indirectly achieved by passing period=weight here
+ 	 * and the he_stat__add_period() function.
+ 	 */
+ 	he = __hists__add_entry(&iter->evsel->hists, al, iter->parent, NULL, mi,
+ 				cost, cost, 0, true);
+ 	if (!he)
+ 		return -ENOMEM;
+ 
+ 	iter->he = he;
+ 	return 0;
+ }
+ 
+ static int
+ iter_finish_mem_entry(struct hist_entry_iter *iter, struct addr_location *al)
+ {
+ 	struct perf_evsel *evsel = iter->evsel;
+ 	struct hist_entry *he = iter->he;
+ 	struct mem_info *mx;
+ 	int err = -EINVAL;
+ 
+ 	if (he == NULL)
+ 		goto out;
+ 
+ 	if (ui__has_annotation()) {
+ 		err = hist_entry__inc_addr_samples(he, evsel->idx, al->addr);
+ 		if (err)
+ 			goto out;
+ 
+ 		mx = he->mem_info;
+ 		err = addr_map_symbol__inc_samples(&mx->daddr, evsel->idx);
+ 		if (err)
+ 			goto out;
+ 	}
+ 
+ 	hists__inc_nr_samples(&evsel->hists, he->filtered);
+ 
+ 	err = hist_entry__append_callchain(he, iter->sample);
+ 
+ out:
+ 	/*
+ 	 * We don't need to free iter->priv (mem_info) here since
+ 	 * the mem info was either already freed in add_hist_entry() or
+ 	 * passed to a new hist entry by hist_entry__new().
+ 	 */
+ 	iter->priv = NULL;
+ 
+ 	iter->he = NULL;
+ 	return err;
+ }
+ 
+ static int
+ iter_prepare_branch_entry(struct hist_entry_iter *iter, struct addr_location *al)
+ {
+ 	struct branch_info *bi;
+ 	struct perf_sample *sample = iter->sample;
+ 
+ 	bi = sample__resolve_bstack(sample, al);
+ 	if (!bi)
+ 		return -ENOMEM;
+ 
+ 	iter->curr = 0;
+ 	iter->total = sample->branch_stack->nr;
+ 
+ 	iter->priv = bi;
+ 	return 0;
+ }
+ 
+ static int
+ iter_add_single_branch_entry(struct hist_entry_iter *iter __maybe_unused,
+ 			     struct addr_location *al __maybe_unused)
+ {
+ 	return 0;
+ }
+ 
+ static int
+ iter_next_branch_entry(struct hist_entry_iter *iter, struct addr_location *al)
+ {
+ 	struct branch_info *bi = iter->priv;
+ 	int i = iter->curr;
+ 
+ 	if (bi == NULL)
+ 		return 0;
+ 
+ 	if (iter->curr >= iter->total)
+ 		return 0;
+ 
+ 	al->map = bi[i].to.map;
+ 	al->sym = bi[i].to.sym;
+ 	al->addr = bi[i].to.addr;
+ 	return 1;
+ }
+ 
+ static int
+ iter_add_next_branch_entry(struct hist_entry_iter *iter, struct addr_location *al)
+ {
+ 	struct branch_info *bi, *bx;
+ 	struct perf_evsel *evsel = iter->evsel;
+ 	struct hist_entry *he = NULL;
+ 	int i = iter->curr;
+ 	int err = 0;
+ 
+ 	bi = iter->priv;
+ 
+ 	if (iter->hide_unresolved && !(bi[i].from.sym && bi[i].to.sym))
+ 		goto out;
+ 
+ 	/*
+ 	 * The report shows the percentage of total branches captured
+ 	 * and not events sampled. Thus we use a pseudo period of 1.
+ 	 */
+ 	he = __hists__add_entry(&evsel->hists, al, iter->parent, &bi[i], NULL,
+ 				1, 1, 0, true);
+ 	if (he == NULL)
+ 		return -ENOMEM;
+ 
+ 	if (ui__has_annotation()) {
+ 		bx = he->branch_info;
+ 		err = addr_map_symbol__inc_samples(&bx->from, evsel->idx);
+ 		if (err)
+ 			goto out;
+ 
+ 		err = addr_map_symbol__inc_samples(&bx->to, evsel->idx);
+ 		if (err)
+ 			goto out;
+ 	}
+ 
+ 	hists__inc_nr_samples(&evsel->hists, he->filtered);
+ 
+ out:
+ 	iter->he = he;
+ 	iter->curr++;
+ 	return err;
+ }
+ 
+ static int
+ iter_finish_branch_entry(struct hist_entry_iter *iter,
+ 			 struct addr_location *al __maybe_unused)
+ {
+ 	zfree(&iter->priv);
+ 	iter->he = NULL;
+ 
+ 	return iter->curr >= iter->total ? 0 : -1;
+ }
+ 
+ static int
+ iter_prepare_normal_entry(struct hist_entry_iter *iter __maybe_unused,
+ 			  struct addr_location *al __maybe_unused)
+ {
+ 	return 0;
+ }
+ 
+ static int
+ iter_add_single_normal_entry(struct hist_entry_iter *iter, struct addr_location *al)
+ {
+ 	struct perf_evsel *evsel = iter->evsel;
+ 	struct perf_sample *sample = iter->sample;
+ 	struct hist_entry *he;
+ 
+ 	he = __hists__add_entry(&evsel->hists, al, iter->parent, NULL, NULL,
+ 				sample->period, sample->weight,
+ 				sample->transaction, true);
+ 	if (he == NULL)
+ 		return -ENOMEM;
+ 
+ 	iter->he = he;
+ 	return 0;
+ }
+ 
+ static int
+ iter_finish_normal_entry(struct hist_entry_iter *iter, struct addr_location *al)
+ {
+ 	int err;
+ 	struct hist_entry *he = iter->he;
+ 	struct perf_evsel *evsel = iter->evsel;
+ 	struct perf_sample *sample = iter->sample;
+ 
+ 	if (he == NULL)
+ 		return 0;
+ 
+ 	iter->he = NULL;
+ 
+ 	if (ui__has_annotation()) {
+ 		err = hist_entry__inc_addr_samples(he, evsel->idx, al->addr);
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	hists__inc_nr_samples(&evsel->hists, he->filtered);
+ 
+ 	return hist_entry__append_callchain(he, sample);
+ }
+ 
+ const struct hist_iter_ops hist_iter_mem = {
+ 	.prepare_entry 		= iter_prepare_mem_entry,
+ 	.add_single_entry 	= iter_add_single_mem_entry,
+ 	.next_entry 		= iter_next_nop_entry,
+ 	.add_next_entry 	= iter_add_next_nop_entry,
+ 	.finish_entry 		= iter_finish_mem_entry,
+ };
+ 
+ const struct hist_iter_ops hist_iter_branch = {
+ 	.prepare_entry 		= iter_prepare_branch_entry,
+ 	.add_single_entry 	= iter_add_single_branch_entry,
+ 	.next_entry 		= iter_next_branch_entry,
+ 	.add_next_entry 	= iter_add_next_branch_entry,
+ 	.finish_entry 		= iter_finish_branch_entry,
+ };
+ 
+ const struct hist_iter_ops hist_iter_normal = {
+ 	.prepare_entry 		= iter_prepare_normal_entry,
+ 	.add_single_entry 	= iter_add_single_normal_entry,
+ 	.next_entry 		= iter_next_nop_entry,
+ 	.add_next_entry 	= iter_add_next_nop_entry,
+ 	.finish_entry 		= iter_finish_normal_entry,
+ };
+ 
+ int hist_entry_iter__add(struct hist_entry_iter *iter, struct addr_location *al,
+ 			 struct perf_evsel *evsel, struct perf_sample *sample,
+ 			 int max_stack_depth)
+ {
+ 	int err, err2;
+ 
+ 	err = sample__resolve_callchain(sample, &iter->parent, evsel, al,
+ 					max_stack_depth);
+ 	if (err)
+ 		return err;
+ 
+ 	iter->evsel = evsel;
+ 	iter->sample = sample;
+ 
+ 	err = iter->ops->prepare_entry(iter, al);
+ 	if (err)
+ 		goto out;
+ 
+ 	err = iter->ops->add_single_entry(iter, al);
+ 	if (err)
+ 		goto out;
+ 
+ 	while (iter->ops->next_entry(iter, al)) {
+ 		err = iter->ops->add_next_entry(iter, al);
+ 		if (err)
+ 			break;
+ 	}
+ 
+ out:
+ 	err2 = iter->ops->finish_entry(iter, al);
+ 	if (!err)
+ 		err = err2;
+ 
+ 	return err;
  }
  
++>>>>>>> a0b51af367a6 (perf hists: Check if accumulated when adding a hist entry)
  int64_t
  hist_entry__cmp(struct hist_entry *left, struct hist_entry *right)
  {
diff --cc tools/perf/util/hist.h
index 4b860e6a25f0,bedb24d3643c..000000000000
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@@ -100,7 -130,12 +100,16 @@@ struct hist_entry *__hists__add_entry(s
  				      struct symbol *parent,
  				      struct branch_info *bi,
  				      struct mem_info *mi, u64 period,
++<<<<<<< HEAD
 +				      u64 weight, u64 transaction);
++=======
+ 				      u64 weight, u64 transaction,
+ 				      bool sample_self);
+ int hist_entry_iter__add(struct hist_entry_iter *iter, struct addr_location *al,
+ 			 struct perf_evsel *evsel, struct perf_sample *sample,
+ 			 int max_stack_depth);
+ 
++>>>>>>> a0b51af367a6 (perf hists: Check if accumulated when adding a hist entry)
  int64_t hist_entry__cmp(struct hist_entry *left, struct hist_entry *right);
  int64_t hist_entry__collapse(struct hist_entry *left, struct hist_entry *right);
  int hist_entry__transaction_len(void);
diff --git a/tools/perf/builtin-annotate.c b/tools/perf/builtin-annotate.c
index 36e3a284497c..c95c97498451 100644
--- a/tools/perf/builtin-annotate.c
+++ b/tools/perf/builtin-annotate.c
@@ -64,7 +64,8 @@ static int perf_evsel__add_sample(struct perf_evsel *evsel,
 		return 0;
 	}
 
-	he = __hists__add_entry(&evsel->hists, al, NULL, NULL, NULL, 1, 1, 0);
+	he = __hists__add_entry(&evsel->hists, al, NULL, NULL, NULL, 1, 1, 0,
+				true);
 	if (he == NULL)
 		return -ENOMEM;
 
diff --git a/tools/perf/builtin-diff.c b/tools/perf/builtin-diff.c
index 7f46af05f9cd..8091a8499524 100644
--- a/tools/perf/builtin-diff.c
+++ b/tools/perf/builtin-diff.c
@@ -316,7 +316,7 @@ static int hists__add_entry(struct hists *hists,
 			    u64 weight, u64 transaction)
 {
 	if (__hists__add_entry(hists, al, NULL, NULL, NULL, period, weight,
-			       transaction) != NULL)
+			       transaction, true) != NULL)
 		return 0;
 	return -ENOMEM;
 }
diff --git a/tools/perf/builtin-top.c b/tools/perf/builtin-top.c
index 610f8ed9ce3e..ba43f07e01cc 100644
--- a/tools/perf/builtin-top.c
+++ b/tools/perf/builtin-top.c
@@ -245,7 +245,7 @@ static struct hist_entry *perf_evsel__add_hist_entry(struct perf_evsel *evsel,
 	pthread_mutex_lock(&evsel->hists.lock);
 	he = __hists__add_entry(&evsel->hists, al, NULL, NULL, NULL,
 				sample->period, sample->weight,
-				sample->transaction);
+				sample->transaction, true);
 	pthread_mutex_unlock(&evsel->hists.lock);
 	if (he == NULL)
 		return NULL;
diff --git a/tools/perf/tests/hists_link.c b/tools/perf/tests/hists_link.c
index 06ecbc5a1da9..0dc175b62a72 100644
--- a/tools/perf/tests/hists_link.c
+++ b/tools/perf/tests/hists_link.c
@@ -87,7 +87,7 @@ static int add_hist_entries(struct perf_evlist *evlist, struct machine *machine)
 				goto out;
 
 			he = __hists__add_entry(&evsel->hists, &al, NULL,
-						NULL, NULL, 1, 1, 0);
+						NULL, NULL, 1, 1, 0, true);
 			if (he == NULL)
 				goto out;
 
@@ -110,7 +110,7 @@ static int add_hist_entries(struct perf_evlist *evlist, struct machine *machine)
 				goto out;
 
 			he = __hists__add_entry(&evsel->hists, &al, NULL,
-						NULL, NULL, 1, 1, 0);
+						NULL, NULL, 1, 1, 0, true);
 			if (he == NULL)
 				goto out;
 
* Unmerged path tools/perf/util/hist.c
* Unmerged path tools/perf/util/hist.h
