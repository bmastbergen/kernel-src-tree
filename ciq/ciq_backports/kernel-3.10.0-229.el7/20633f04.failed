nfs: page group syncing in write path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Weston Andros Adamson <dros@primarydata.com>
commit 20633f042fd0907300069714b98aaf607a8b5bf8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/20633f04.failed

Operations that modify state for a whole page must be syncronized across
all requests within a page group. In the write path, this is calling
end_page_writeback and removing the head request from an inode.
Both of these operations should not be called until all requests
in a page group have reached the point where they would call them.

This patch should have no effect yet since all page groups currently
have one request, but will come into play when pg_test functions are
modified to split pages into sub-page regions.

	Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 20633f042fd0907300069714b98aaf607a8b5bf8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pagelist.c
#	fs/nfs/write.c
#	include/linux/nfs_page.h
diff --cc fs/nfs/pagelist.c
index ac4fb6420265,ceb4424614aa..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -242,9 -389,16 +242,20 @@@ static void nfs_clear_request(struct nf
   *
   * Note: Should never be called with the spinlock held!
   */
 -static void nfs_free_request(struct nfs_page *req)
 +static void nfs_free_request(struct kref *kref)
  {
++<<<<<<< HEAD
 +	struct nfs_page *req = container_of(kref, struct nfs_page, wb_kref);
++=======
+ 	WARN_ON_ONCE(req->wb_this_page != req);
+ 
+ 	/* extra debug: make sure no sync bits are still set */
+ 	WARN_ON_ONCE(test_bit(PG_TEARDOWN, &req->wb_flags));
+ 	WARN_ON_ONCE(test_bit(PG_UNLOCKPAGE, &req->wb_flags));
+ 	WARN_ON_ONCE(test_bit(PG_UPTODATE, &req->wb_flags));
+ 	WARN_ON_ONCE(test_bit(PG_WB_END, &req->wb_flags));
+ 	WARN_ON_ONCE(test_bit(PG_REMOVE, &req->wb_flags));
++>>>>>>> 20633f042fd0 (nfs: page group syncing in write path)
  
  	/* Release struct file and open context */
  	nfs_clear_request(req);
diff --cc fs/nfs/write.c
index d0c08ef947b8,5d752766139d..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -652,7 -607,8 +660,12 @@@ remove_req
  		nfs_inode_remove_request(req);
  next:
  		nfs_unlock_request(req);
++<<<<<<< HEAD
 +		nfs_end_page_writeback(req->wb_page);
++=======
+ 		nfs_end_page_writeback(req);
+ 		do_destroy = !test_bit(NFS_IOHDR_NEED_COMMIT, &hdr->flags);
++>>>>>>> 20633f042fd0 (nfs: page group syncing in write path)
  		nfs_release_request(req);
  	}
  out:
diff --cc include/linux/nfs_page.h
index 214e09851870,7d9096d95d4a..000000000000
--- a/include/linux/nfs_page.h
+++ b/include/linux/nfs_page.h
@@@ -26,6 -26,13 +26,16 @@@ enum 
  	PG_MAPPED,		/* page private set for buffered io */
  	PG_CLEAN,		/* write succeeded */
  	PG_COMMIT_TO_DS,	/* used by pnfs layouts */
++<<<<<<< HEAD
++=======
+ 	PG_INODE_REF,		/* extra ref held by inode (head req only) */
+ 	PG_HEADLOCK,		/* page group lock of wb_head */
+ 	PG_TEARDOWN,		/* page group sync for destroy */
+ 	PG_UNLOCKPAGE,		/* page group sync bit in read path */
+ 	PG_UPTODATE,		/* page group sync bit in read path */
+ 	PG_WB_END,		/* page group sync bit in write path */
+ 	PG_REMOVE,		/* page group sync bit in write path */
++>>>>>>> 20633f042fd0 (nfs: page group syncing in write path)
  };
  
  struct nfs_inode;
* Unmerged path fs/nfs/pagelist.c
* Unmerged path fs/nfs/write.c
* Unmerged path include/linux/nfs_page.h
