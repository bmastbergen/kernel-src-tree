qlcnic: Cleanup qlcnic_enable_msix() return values

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Alexander Gordeev <agordeev@redhat.com>
commit 74a1fa45eba3958cbc6a6f726525e38263ea4cbf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/74a1fa45.failed

	Signed-off-by: Alexander Gordeev <agordeev@redhat.com>
	Cc: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Cc: Rajesh Borundia <rajesh.borundia@qlogic.com>
	Cc: Shahed Shaikh <shahed.shaikh@qlogic.com>
	Cc: linux-driver@qlogic.com
	Cc: netdev@vger.kernel.org
	Cc: linux-pci@vger.kernel.org
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 74a1fa45eba3958cbc6a6f726525e38263ea4cbf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index ecd8d1df8016,0c077cfc388b..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@@ -567,19 -576,115 +567,23 @@@ static void qlcnic_get_multiq_capabilit
  	}
  }
  
 -static int qlcnic_max_rings(struct qlcnic_adapter *adapter, u8 ring_cnt,
 -			    int queue_type)
 -{
 -	int num_rings, max_rings = QLCNIC_MAX_SDS_RINGS;
 -
 -	if (queue_type == QLCNIC_RX_QUEUE)
 -		max_rings = adapter->max_sds_rings;
 -	else if (queue_type == QLCNIC_TX_QUEUE)
 -		max_rings = adapter->max_tx_rings;
 -
 -	num_rings = rounddown_pow_of_two(min_t(int, num_online_cpus(),
 -					      max_rings));
 -
 -	if (ring_cnt > num_rings)
 -		return num_rings;
 -	else
 -		return ring_cnt;
 -}
 -
 -void qlcnic_set_tx_ring_count(struct qlcnic_adapter *adapter, u8 tx_cnt)
 -{
 -	/* 83xx adapter does not have max_tx_rings intialized in probe */
 -	if (adapter->max_tx_rings)
 -		adapter->drv_tx_rings = qlcnic_max_rings(adapter, tx_cnt,
 -							 QLCNIC_TX_QUEUE);
 -	else
 -		adapter->drv_tx_rings = tx_cnt;
 -}
 -
 -void qlcnic_set_sds_ring_count(struct qlcnic_adapter *adapter, u8 rx_cnt)
 -{
 -	/* 83xx adapter does not have max_sds_rings intialized in probe */
 -	if (adapter->max_sds_rings)
 -		adapter->drv_sds_rings = qlcnic_max_rings(adapter, rx_cnt,
 -							  QLCNIC_RX_QUEUE);
 -	else
 -		adapter->drv_sds_rings = rx_cnt;
 -}
 -
 -int qlcnic_setup_tss_rss_intr(struct qlcnic_adapter *adapter)
 +int qlcnic_enable_msix(struct qlcnic_adapter *adapter, u32 num_msix)
  {
  	struct pci_dev *pdev = adapter->pdev;
 -	int num_msix = 0, err = 0, vector;
 -
 -	adapter->flags &= ~QLCNIC_TSS_RSS;
 -
 -	if (adapter->drv_tss_rings > 0)
 -		num_msix += adapter->drv_tss_rings;
 -	else
 -		num_msix += adapter->drv_tx_rings;
 -
 -	if (adapter->drv_rss_rings  > 0)
 -		num_msix += adapter->drv_rss_rings;
 -	else
 -		num_msix += adapter->drv_sds_rings;
++<<<<<<< HEAD
 +	int max_tx_rings, max_sds_rings, tx_vector;
 +	int err = -1, i;
  
 -	if (qlcnic_83xx_check(adapter))
 -		num_msix += 1;
 -
 -	if (!adapter->msix_entries) {
 -		adapter->msix_entries = kcalloc(num_msix,
 -						sizeof(struct msix_entry),
 -						GFP_KERNEL);
 -		if (!adapter->msix_entries)
 -			return -ENOMEM;
 -	}
 -
 -restore:
 -	for (vector = 0; vector < num_msix; vector++)
 -		adapter->msix_entries[vector].entry = vector;
 -
 -	err = pci_enable_msix(pdev, adapter->msix_entries, num_msix);
 -	if (err == 0) {
 -		adapter->ahw->num_msix = num_msix;
 -		if (adapter->drv_tss_rings > 0)
 -			adapter->drv_tx_rings = adapter->drv_tss_rings;
 -
 -		if (adapter->drv_rss_rings > 0)
 -			adapter->drv_sds_rings = adapter->drv_rss_rings;
 +	if (adapter->flags & QLCNIC_TX_INTR_SHARED) {
 +		max_tx_rings = 0;
 +		tx_vector = 0;
  	} else {
 -		netdev_info(adapter->netdev,
 -			    "Unable to allocate %d MSI-X vectors, Available vectors %d\n",
 -			    num_msix, err);
 -
 -		num_msix = adapter->drv_tx_rings + adapter->drv_sds_rings;
 -
 -		/* Set rings to 0 so we can restore original TSS/RSS count */
 -		adapter->drv_tss_rings = 0;
 -		adapter->drv_rss_rings = 0;
 -
 -		if (qlcnic_83xx_check(adapter))
 -			num_msix += 1;
 -
 -		netdev_info(adapter->netdev,
 -			    "Restoring %d Tx, %d SDS rings for total %d vectors.\n",
 -			    adapter->drv_tx_rings, adapter->drv_sds_rings,
 -			    num_msix);
 -		goto restore;
 -
 -		err = -EIO;
 +		max_tx_rings = adapter->max_drv_tx_rings;
 +		tx_vector = 1;
  	}
 -
 -	return err;
 -}
 -
 -int qlcnic_enable_msix(struct qlcnic_adapter *adapter, u32 num_msix)
 -{
 -	struct pci_dev *pdev = adapter->pdev;
++=======
+ 	int err, vector;
++>>>>>>> 74a1fa45eba3 (qlcnic: Cleanup qlcnic_enable_msix() return values)
  
  	if (!adapter->msix_entries) {
  		adapter->msix_entries = kcalloc(num_msix,
@@@ -599,38 -704,33 +603,58 @@@
  		err = pci_enable_msix(pdev, adapter->msix_entries, num_msix);
  		if (err == 0) {
  			adapter->flags |= QLCNIC_MSIX_ENABLED;
 -			adapter->ahw->num_msix = num_msix;
 +			if (qlcnic_83xx_check(adapter)) {
 +				adapter->ahw->num_msix = num_msix;
 +				/* subtract mail box and tx ring vectors */
 +				adapter->max_sds_rings = num_msix -
 +							 max_tx_rings - 1;
 +			} else {
 +				adapter->ahw->num_msix = num_msix;
 +				if (qlcnic_check_multi_tx(adapter) &&
 +				    !adapter->ahw->diag_test &&
 +				    (adapter->max_drv_tx_rings > 1))
 +					max_sds_rings = num_msix - max_tx_rings;
 +				else
 +					max_sds_rings = num_msix;
 +
 +				adapter->max_sds_rings = max_sds_rings;
 +			}
  			dev_info(&pdev->dev, "using msi-x interrupts\n");
- 			return err;
+ 			return 0;
  		} else if (err > 0) {
  			dev_info(&pdev->dev,
 -				 "Unable to allocate %d MSI-X vectors, Available vectors %d\n",
 -				 num_msix, err);
 -
 -			if (qlcnic_82xx_check(adapter)) {
 +				 "Unable to allocate %d MSI-X interrupt vectors\n",
 +				 num_msix);
 +			if (qlcnic_83xx_check(adapter)) {
 +				if (err < (QLC_83XX_MINIMUM_VECTOR - tx_vector))
 +					return err;
 +				err -= (max_tx_rings + 1);
 +				num_msix = rounddown_pow_of_two(err);
++<<<<<<< HEAD
 +				num_msix += (max_tx_rings + 1);
 +			} else {
  				num_msix = rounddown_pow_of_two(err);
 +				if (qlcnic_check_multi_tx(adapter))
 +					num_msix += max_tx_rings;
++=======
+ 				if (err < QLCNIC_82XX_MINIMUM_VECTOR)
+ 					return -ENOSPC;
+ 			} else {
+ 				num_msix = rounddown_pow_of_two(err - 1);
+ 				num_msix += 1;
+ 				if (err < QLCNIC_83XX_MINIMUM_VECTOR)
+ 					return -ENOSPC;
+ 			}
+ 
+ 			if (qlcnic_82xx_check(adapter) &&
+ 			    !qlcnic_check_multi_tx(adapter)) {
+ 				adapter->drv_sds_rings = num_msix;
+ 				adapter->drv_tx_rings = QLCNIC_SINGLE_RING;
+ 			} else {
+ 				/* Distribute vectors equally */
+ 				adapter->drv_tx_rings = num_msix / 2;
+ 				adapter->drv_sds_rings = adapter->drv_tx_rings;
++>>>>>>> 74a1fa45eba3 (qlcnic: Cleanup qlcnic_enable_msix() return values)
  			}
  
  			if (num_msix) {
@@@ -646,9 -747,23 +670,9 @@@
  		}
  	}
  
- 	return err;
+ 	return -EIO;
  }
  
 -static int qlcnic_82xx_calculate_msix_vector(struct qlcnic_adapter *adapter)
 -{
 -	int num_msix;
 -
 -	num_msix = adapter->drv_sds_rings;
 -
 -	if (qlcnic_check_multi_tx(adapter))
 -		num_msix += adapter->drv_tx_rings;
 -	else
 -		num_msix += QLCNIC_SINGLE_RING;
 -
 -	return num_msix;
 -}
 -
  static int qlcnic_enable_msi_legacy(struct qlcnic_adapter *adapter)
  {
  	int err = 0;
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
