ACPI / hotplug: Simplify acpi_set_hp_context()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug: Simplify acpi_set_hp_context() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 91.76%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit ba574dc8563c7c1d1d1c5bf3c1c99ec88513402e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/ba574dc8.failed

Since all of the acpi_set_hp_context() callers pass at least one NULL
function pointer and one caller passes NULL function pointers only
to it, drop function pointer arguments from acpi_set_hp_context()
and make the callers initialize the function pointers in struct
acpi_hotplug_context by themselves before passing it to
acpi_set_hp_context().

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit ba574dc8563c7c1d1d1c5bf3c1c99ec88513402e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
#	drivers/pci/hotplug/acpiphp_glue.c
#	include/acpi/acpi_bus.h
diff --cc drivers/acpi/scan.c
index b30a50799f84,3ffc9306538b..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -59,9 -61,32 +59,35 @@@ void acpi_scan_lock_release(void
  }
  EXPORT_SYMBOL_GPL(acpi_scan_lock_release);
  
++<<<<<<< HEAD
++=======
+ void acpi_lock_hp_context(void)
+ {
+ 	mutex_lock(&acpi_hp_context_lock);
+ }
+ 
+ void acpi_unlock_hp_context(void)
+ {
+ 	mutex_unlock(&acpi_hp_context_lock);
+ }
+ 
+ void acpi_initialize_hp_context(struct acpi_device *adev,
+ 				struct acpi_hotplug_context *hp,
+ 				int (*notify)(struct acpi_device *, u32),
+ 				void (*uevent)(struct acpi_device *, u32))
+ {
+ 	acpi_lock_hp_context();
+ 	hp->notify = notify;
+ 	hp->uevent = uevent;
+ 	acpi_set_hp_context(adev, hp);
+ 	acpi_unlock_hp_context();
+ }
+ EXPORT_SYMBOL_GPL(acpi_initialize_hp_context);
+ 
++>>>>>>> ba574dc8563c (ACPI / hotplug: Simplify acpi_set_hp_context())
  int acpi_scan_add_handler(struct acpi_scan_handler *handler)
  {
 -	if (!handler)
 +	if (!handler || !handler->attach)
  		return -EINVAL;
  
  	list_add_tail(&handler->list_node, &acpi_scan_handlers_list);
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,24a43d4e9933..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -58,25 -58,68 +58,73 @@@
  static LIST_HEAD(bridge_list);
  static DEFINE_MUTEX(bridge_mutex);
  
 -static int acpiphp_hotplug_notify(struct acpi_device *adev, u32 type);
 -static void acpiphp_post_dock_fixup(struct acpi_device *adev);
 +static void handle_hotplug_event_bridge (acpi_handle, u32, void *);
  static void acpiphp_sanitize_bus(struct pci_bus *bus);
  static void acpiphp_set_hpp_values(struct pci_bus *bus);
 -static void hotplug_event(u32 type, struct acpiphp_context *context);
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context);
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type, void *context);
  static void free_bridge(struct kref *kref);
  
 -/**
 - * acpiphp_init_context - Create hotplug context and grab a reference to it.
 - * @adev: ACPI device object to create the context for.
 - *
 - * Call under acpi_hp_context_lock.
 - */
 -static struct acpiphp_context *acpiphp_init_context(struct acpi_device *adev)
 +/* callback routine to check for the existence of a pci dock device */
 +static acpi_status
 +is_pci_dock_device(acpi_handle handle, u32 lvl, void *context, void **rv)
  {
 -	struct acpiphp_context *context;
 +	int *count = (int *)context;
  
++<<<<<<< HEAD
 +	if (is_dock_device(handle)) {
 +		(*count)++;
 +		return AE_CTRL_TERMINATE;
 +	} else {
 +		return AE_OK;
 +	}
++=======
+ 	context = kzalloc(sizeof(*context), GFP_KERNEL);
+ 	if (!context)
+ 		return NULL;
+ 
+ 	context->refcount = 1;
+ 	context->hp.notify = acpiphp_hotplug_notify;
+ 	context->hp.fixup = acpiphp_post_dock_fixup;
+ 	acpi_set_hp_context(adev, &context->hp);
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_get_context - Get hotplug context and grab a reference to it.
+  * @adev: ACPI device object to get the context for.
+  *
+  * Call under acpi_hp_context_lock.
+  */
+ static struct acpiphp_context *acpiphp_get_context(struct acpi_device *adev)
+ {
+ 	struct acpiphp_context *context;
+ 
+ 	if (!adev->hp)
+ 		return NULL;
+ 
+ 	context = to_acpiphp_context(adev->hp);
+ 	context->refcount++;
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_put_context - Drop a reference to ACPI hotplug context.
+  * @context: ACPI hotplug context to drop a reference to.
+  *
+  * The context object is removed if there are no more references to it.
+  *
+  * Call under acpi_hp_context_lock.
+  */
+ static void acpiphp_put_context(struct acpiphp_context *context)
+ {
+ 	if (--context->refcount)
+ 		return;
+ 
+ 	WARN_ON(context->bridge);
+ 	context->hp.self->hp = NULL;
+ 	kfree(context);
++>>>>>>> ba574dc8563c (ACPI / hotplug: Simplify acpi_set_hp_context())
  }
  
  static inline void get_bridge(struct acpiphp_bridge *bridge)
@@@ -1202,15 -868,73 +1250,45 @@@ void acpiphp_enumerate_slots(struct pci
  	 */
  	get_device(&bus->dev);
  
++<<<<<<< HEAD
 +	if (!pci_is_root_bus(bridge->pci_bus) &&
 +	    ACPI_SUCCESS(acpi_get_handle(bridge->handle,
 +					"_EJ0", &dummy_handle))) {
 +		pr_debug("found ejectable p2p bridge\n");
 +		bridge->flags |= BRIDGE_HAS_EJ0;
 +		bridge->func = acpiphp_bridge_handle_to_function(handle);
++=======
+ 	acpi_lock_hp_context();
+ 	if (pci_is_root_bus(bridge->pci_bus)) {
+ 		struct acpiphp_root_context *root_context;
+ 
+ 		root_context = kzalloc(sizeof(*root_context), GFP_KERNEL);
+ 		if (!root_context)
+ 			goto err;
+ 
+ 		root_context->root_bridge = bridge;
+ 		acpi_set_hp_context(adev, &root_context->hp);
+ 	} else {
+ 		struct acpiphp_context *context;
+ 
+ 		/*
+ 		 * This bridge should have been registered as a hotplug function
+ 		 * under its parent, so the context should be there, unless the
+ 		 * parent is going to be handled by pciehp, in which case this
+ 		 * bridge is not interesting to us either.
+ 		 */
+ 		context = acpiphp_get_context(adev);
+ 		if (!context)
+ 			goto err;
+ 
+ 		bridge->context = context;
+ 		context->bridge = bridge;
+ 		/* Get a reference to the parent bridge. */
+ 		get_bridge(context->func.parent);
++>>>>>>> ba574dc8563c (ACPI / hotplug: Simplify acpi_set_hp_context())
  	}
 -	acpi_unlock_hp_context();
 -
 -	/* Must be added to the list prior to calling acpiphp_add_context(). */
 -	mutex_lock(&bridge_mutex);
 -	list_add(&bridge->list, &bridge_list);
 -	mutex_unlock(&bridge_mutex);
 -
 -	/* register all slot objects under this bridge */
 -	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
 -				     acpiphp_add_context, NULL, bridge, NULL);
 -	if (ACPI_FAILURE(status)) {
 -		acpi_handle_err(handle, "failed to register slots\n");
 -		cleanup_bridge(bridge);
 -		put_bridge(bridge);
 -	}
 -	return;
 -
 - err:
 -	acpi_unlock_hp_context();
 -	put_device(&bus->dev);
 -	pci_dev_put(bridge->pci_dev);
 -	kfree(bridge);
 -}
  
 -void acpiphp_drop_bridge(struct acpiphp_bridge *bridge)
 -{
 -	if (pci_is_root_bus(bridge->pci_bus)) {
 -		struct acpiphp_root_context *root_context;
 -		struct acpi_device *adev;
 -
 -		acpi_lock_hp_context();
 -		adev = ACPI_COMPANION(bridge->pci_bus->bridge);
 -		root_context = to_acpiphp_root_context(adev->hp);
 -		adev->hp = NULL;
 -		acpi_unlock_hp_context();
 -		kfree(root_context);
 -	}
 -	cleanup_bridge(bridge);
 -	put_bridge(bridge);
 +	init_bridge_misc(bridge);
  }
  
  /**
diff --cc include/acpi/acpi_bus.h
index 717f4adcfbd4,e0720a569b2c..000000000000
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@@ -327,6 -366,23 +327,26 @@@ static inline void *acpi_driver_data(st
  #define to_acpi_device(d)	container_of(d, struct acpi_device, dev)
  #define to_acpi_driver(d)	container_of(d, struct acpi_driver, drv)
  
++<<<<<<< HEAD
++=======
+ static inline void acpi_set_device_status(struct acpi_device *adev, u32 sta)
+ {
+ 	*((u32 *)&adev->status) = sta;
+ }
+ 
+ static inline void acpi_set_hp_context(struct acpi_device *adev,
+ 				       struct acpi_hotplug_context *hp)
+ {
+ 	hp->self = adev;
+ 	adev->hp = hp;
+ }
+ 
+ void acpi_initialize_hp_context(struct acpi_device *adev,
+ 				struct acpi_hotplug_context *hp,
+ 				int (*notify)(struct acpi_device *, u32),
+ 				void (*uevent)(struct acpi_device *, u32));
+ 
++>>>>>>> ba574dc8563c (ACPI / hotplug: Simplify acpi_set_hp_context())
  /* acpi_device.dev.bus == &acpi_bus_type */
  extern struct bus_type acpi_bus_type;
  
* Unmerged path drivers/acpi/scan.c
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
* Unmerged path include/acpi/acpi_bus.h
