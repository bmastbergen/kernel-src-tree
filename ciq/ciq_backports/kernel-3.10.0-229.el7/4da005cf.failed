qlcnic: Pre-allocate DMA buffer used for minidump collection

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Shahed Shaikh <shahed.shaikh@qlogic.com>
commit 4da005cf1e30897520106114a8ce11a5aa558497
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/4da005cf.failed

Pre-allocate the physically contiguous DMA buffer used for
minidump collection at driver load time, rather than at
run time, to minimize allocation failures. Driver will allocate
the buffer at load time if PEX DMA support capability is indicated
by the adapter.

	Signed-off-by: Shahed Shaikh <shahed.shaikh@qlogic.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4da005cf1e30897520106114a8ce11a5aa558497)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
index d72671739763,d85f7e1e117f..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
@@@ -406,6 -423,26 +406,29 @@@ struct qlcnic_dump_template_hdr 
  	u32	rsvd[0];
  };
  
++<<<<<<< HEAD
++=======
+ struct qlcnic_82xx_dump_template_hdr {
+ 	u32	type;
+ 	u32	offset;
+ 	u32	size;
+ 	u32	cap_mask;
+ 	u32	num_entries;
+ 	u32	version;
+ 	u32	timestamp;
+ 	u32	checksum;
+ 	u32	drv_cap_mask;
+ 	u32	sys_info[3];
+ 	u32	saved_state[16];
+ 	u32	cap_sizes[8];
+ 	u32	rsvd[7];
+ 	u32	capabilities;
+ 	u32	rsvd1[0];
+ };
+ 
+ #define QLC_PEX_DMA_READ_SIZE	(PAGE_SIZE * 16)
+ 
++>>>>>>> 4da005cf1e30 (qlcnic: Pre-allocate DMA buffer used for minidump collection)
  struct qlcnic_fw_dump {
  	u8	clr;	/* flag to indicate if dump is cleared */
  	bool	enable; /* enable/disable dump */
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c
index 7763962e2ec4,e46fc39d425d..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c
@@@ -1029,15 -1148,16 +1027,24 @@@ free_mem
  
  int qlcnic_fw_cmd_get_minidump_temp(struct qlcnic_adapter *adapter)
  {
++<<<<<<< HEAD
++=======
+ 	struct qlcnic_hardware_context *ahw;
+ 	struct qlcnic_fw_dump *fw_dump;
+ 	u32 version, csum, *tmp_buf;
+ 	u8 use_flash_temp = 0;
+ 	u32 temp_size = 0;
+ 	void *temp_buffer;
++>>>>>>> 4da005cf1e30 (qlcnic: Pre-allocate DMA buffer used for minidump collection)
  	int err;
 +	u32 temp_size = 0;
 +	u32 version, csum, *tmp_buf;
 +	struct qlcnic_hardware_context *ahw;
 +	struct qlcnic_dump_template_hdr *tmpl_hdr;
 +	u8 use_flash_temp = 0;
  
  	ahw = adapter->ahw;
 -	fw_dump = &ahw->fw_dump;
 +
  	err = qlcnic_fw_get_minidump_temp_size(adapter, &version, &temp_size,
  					       &use_flash_temp);
  	if (err) {
@@@ -1081,16 -1201,24 +1088,34 @@@ flash_temp
  		return -EIO;
  	}
  
++<<<<<<< HEAD
 +	tmpl_hdr = ahw->fw_dump.tmpl_hdr;
 +	tmpl_hdr->drv_cap_mask = tmpl_hdr->cap_mask;
++=======
+ 	qlcnic_cache_tmpl_hdr_values(adapter, fw_dump);
+ 
+ 	if (fw_dump->use_pex_dma) {
+ 		fw_dump->dma_buffer = NULL;
+ 		temp_buffer = dma_alloc_coherent(&adapter->pdev->dev,
+ 						 QLC_PEX_DMA_READ_SIZE,
+ 						 &fw_dump->phys_addr,
+ 						 GFP_KERNEL);
+ 		if (!temp_buffer)
+ 			fw_dump->use_pex_dma = false;
+ 		else
+ 			fw_dump->dma_buffer = temp_buffer;
+ 	}
+ 
+ 
++>>>>>>> 4da005cf1e30 (qlcnic: Pre-allocate DMA buffer used for minidump collection)
  	dev_info(&adapter->pdev->dev,
  		 "Default minidump capture mask 0x%x\n",
 -		 fw_dump->cap_mask);
 +		 tmpl_hdr->cap_mask);
 +
 +	if ((tmpl_hdr->version & 0xfffff) >= 0x20001)
 +		ahw->fw_dump.use_pex_dma = true;
 +	else
 +		ahw->fw_dump.use_pex_dma = false;
  
  	qlcnic_enable_fw_dump_state(adapter);
  
@@@ -1099,21 -1227,22 +1124,34 @@@
  
  int qlcnic_dump_fw(struct qlcnic_adapter *adapter)
  {
++<<<<<<< HEAD
++=======
+ 	struct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;
+ 	static const struct qlcnic_dump_operations *fw_dump_ops;
+ 	struct qlcnic_83xx_dump_template_hdr *hdr_83xx;
+ 	u32 entry_offset, dump, no_entries, buf_offset = 0;
+ 	int i, k, ops_cnt, ops_index, dump_size = 0;
+ 	struct device *dev = &adapter->pdev->dev;
+ 	struct qlcnic_hardware_context *ahw;
+ 	struct qlcnic_dump_entry *entry;
+ 	void *tmpl_hdr;
+ 	u32 ocm_window;
++>>>>>>> 4da005cf1e30 (qlcnic: Pre-allocate DMA buffer used for minidump collection)
  	__le32 *buffer;
 +	u32 ocm_window;
  	char mesg[64];
  	char *msg[] = {mesg, NULL};
 +	int i, k, ops_cnt, ops_index, dump_size = 0;
 +	u32 entry_offset, dump, no_entries, buf_offset = 0;
 +	struct qlcnic_dump_entry *entry;
 +	struct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;
 +	struct qlcnic_dump_template_hdr *tmpl_hdr = fw_dump->tmpl_hdr;
 +	static const struct qlcnic_dump_operations *fw_dump_ops;
 +	struct device *dev = &adapter->pdev->dev;
 +	struct qlcnic_hardware_context *ahw;
 +	void *temp_buffer;
  
  	ahw = adapter->ahw;
 -	tmpl_hdr = fw_dump->tmpl_hdr;
  
  	/* Return if we don't have firmware dump template header */
  	if (!tmpl_hdr)
@@@ -1144,21 -1274,11 +1182,11 @@@
  
  	buffer = fw_dump->data;
  	fw_dump->size = dump_size;
 -	no_entries = fw_dump->num_entries;
 -	entry_offset = fw_dump->offset;
 -	qlcnic_set_sys_info(adapter, tmpl_hdr, 0, QLCNIC_DRIVER_VERSION);
 -	qlcnic_set_sys_info(adapter, tmpl_hdr, 1, adapter->fw_version);
 +	no_entries = tmpl_hdr->num_entries;
 +	entry_offset = tmpl_hdr->offset;
 +	tmpl_hdr->sys_info[0] = QLCNIC_DRIVER_VERSION;
 +	tmpl_hdr->sys_info[1] = adapter->fw_version;
  
- 	if (fw_dump->use_pex_dma) {
- 		temp_buffer = dma_alloc_coherent(dev, QLC_PEX_DMA_READ_SIZE,
- 						 &fw_dump->phys_addr,
- 						 GFP_KERNEL);
- 		if (!temp_buffer)
- 			fw_dump->use_pex_dma = false;
- 		else
- 			fw_dump->dma_buffer = temp_buffer;
- 	}
- 
  	if (qlcnic_82xx_check(adapter)) {
  		ops_cnt = ARRAY_SIZE(qlcnic_fw_dump_ops);
  		fw_dump_ops = qlcnic_fw_dump_ops;
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index ccf682b59be0..a64680ec658a 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@ -1881,12 +1881,20 @@ err_out:
 
 static void qlcnic_free_adapter_resources(struct qlcnic_adapter *adapter)
 {
+	struct qlcnic_fw_dump *fw_dump = &adapter->ahw->fw_dump;
+
 	kfree(adapter->recv_ctx);
 	adapter->recv_ctx = NULL;
 
-	if (adapter->ahw->fw_dump.tmpl_hdr) {
-		vfree(adapter->ahw->fw_dump.tmpl_hdr);
-		adapter->ahw->fw_dump.tmpl_hdr = NULL;
+	if (fw_dump->tmpl_hdr) {
+		vfree(fw_dump->tmpl_hdr);
+		fw_dump->tmpl_hdr = NULL;
+	}
+
+	if (fw_dump->dma_buffer) {
+		dma_free_coherent(&adapter->pdev->dev, QLC_PEX_DMA_READ_SIZE,
+				  fw_dump->dma_buffer, fw_dump->phys_addr);
+		fw_dump->dma_buffer = NULL;
 	}
 
 	kfree(adapter->ahw->reset.buff);
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_minidump.c
