enic: remove #ifdef CONFIG_RFS_ACCEL around filter structures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Govindarajulu Varadarajan <_govind@gmx.com>
commit e3e5af33e6d64a36bce1dfd9f599649f539801de
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e3e5af33.failed

This patch removes the #ifdef CONFIG_RFS_ACCEL around the classifier filter
structures. This makes the filter structures available when CONFIG_RFS_ACCEL = n.

Introduce enic_rfs_timer_start() & enic_rfs_timer_stop() to start/stop the
timer. These two functions are nop when CONFIG_RFS_ACCEL = n.

	Signed-off-by: Govindarajulu Varadarajan <_govind@gmx.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e3e5af33e6d64a36bce1dfd9f599649f539801de)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/cisco/enic/enic_clsf.c
diff --cc drivers/net/ethernet/cisco/enic/enic_clsf.c
index 4dbdcfb81638,ee6acbf02ef0..000000000000
--- a/drivers/net/ethernet/cisco/enic/enic_clsf.c
+++ b/drivers/net/ethernet/cisco/enic/enic_clsf.c
@@@ -96,47 -134,6 +134,50 @@@ void enic_flow_may_expire(unsigned lon
  	mod_timer(&enic->rfs_h.rfs_may_expire, jiffies + HZ/4);
  }
  
++<<<<<<< HEAD
 +/* enic_rfs_flw_tbl_init - initialize enic->rfs_h members
 + *	@enic: enic data
 + */
 +void enic_rfs_flw_tbl_init(struct enic *enic)
 +{
 +	int i;
 +
 +	spin_lock_init(&enic->rfs_h.lock);
 +	for (i = 0; i <= ENIC_RFS_FLW_MASK; i++)
 +		INIT_HLIST_HEAD(&enic->rfs_h.ht_head[i]);
 +	enic->rfs_h.max = enic->config.num_arfs;
 +	enic->rfs_h.free = enic->rfs_h.max;
 +	enic->rfs_h.toclean = 0;
 +	init_timer(&enic->rfs_h.rfs_may_expire);
 +	enic->rfs_h.rfs_may_expire.function = enic_flow_may_expire;
 +	enic->rfs_h.rfs_may_expire.data = (unsigned long)enic;
 +	mod_timer(&enic->rfs_h.rfs_may_expire, jiffies + HZ/4);
 +}
 +
 +void enic_rfs_flw_tbl_free(struct enic *enic)
 +{
 +	int i, res;
 +
 +	del_timer_sync(&enic->rfs_h.rfs_may_expire);
 +	spin_lock(&enic->rfs_h.lock);
 +	enic->rfs_h.free = 0;
 +	for (i = 0; i < (1 << ENIC_RFS_FLW_BITSHIFT); i++) {
 +		struct hlist_head *hhead;
 +		struct hlist_node *tmp;
 +		struct enic_rfs_fltr_node *n;
 +
 +		hhead = &enic->rfs_h.ht_head[i];
 +		hlist_for_each_entry_safe(n, tmp, hhead, node) {
 +			enic_delfltr(enic, n->fltr_id);
 +			hlist_del(&n->node);
 +			kfree(n);
 +		}
 +	}
 +	spin_unlock(&enic->rfs_h.lock);
 +}
 +
++=======
++>>>>>>> e3e5af33e6d6 (enic: remove #ifdef CONFIG_RFS_ACCEL around filter structures)
  static struct enic_rfs_fltr_node *htbl_key_search(struct hlist_head *h,
  						  struct flow_keys *k)
  {
diff --git a/drivers/net/ethernet/cisco/enic/enic.h b/drivers/net/ethernet/cisco/enic/enic.h
index d723d818fdc7..02decdc41b6a 100644
--- a/drivers/net/ethernet/cisco/enic/enic.h
+++ b/drivers/net/ethernet/cisco/enic/enic.h
@@ -99,7 +99,6 @@ struct enic_port_profile {
 	u8 mac_addr[ETH_ALEN];
 };
 
-#ifdef CONFIG_RFS_ACCEL
 /* enic_rfs_fltr_node - rfs filter node in hash table
  *	@@keys: IPv4 5 tuple
  *	@flow_id: flow_id of clsf filter provided by kernel
@@ -135,8 +134,6 @@ struct enic_rfs_flw_tbl {
 	struct timer_list rfs_may_expire;
 };
 
-#endif /* CONFIG_RFS_ACCEL */
-
 /* Per-instance private data structure */
 struct enic {
 	struct net_device *netdev;
@@ -190,9 +187,7 @@ struct enic {
 	/* completion queue cache line section */
 	____cacheline_aligned struct vnic_cq cq[ENIC_CQ_MAX];
 	unsigned int cq_count;
-#ifdef CONFIG_RFS_ACCEL
 	struct enic_rfs_flw_tbl rfs_h;
-#endif
 };
 
 static inline struct device *enic_get_dev(struct enic *enic)
* Unmerged path drivers/net/ethernet/cisco/enic/enic_clsf.c
diff --git a/drivers/net/ethernet/cisco/enic/enic_clsf.h b/drivers/net/ethernet/cisco/enic/enic_clsf.h
index d572704cd117..221f364cd811 100644
--- a/drivers/net/ethernet/cisco/enic/enic_clsf.h
+++ b/drivers/net/ethernet/cisco/enic/enic_clsf.h
@@ -8,15 +8,29 @@
 
 int enic_addfltr_5t(struct enic *enic, struct flow_keys *keys, u16 rq);
 int enic_delfltr(struct enic *enic, u16 filter_id);
-
-#ifdef CONFIG_RFS_ACCEL
 void enic_rfs_flw_tbl_init(struct enic *enic);
 void enic_rfs_flw_tbl_free(struct enic *enic);
+
+#ifdef CONFIG_RFS_ACCEL
 int enic_rx_flow_steer(struct net_device *dev, const struct sk_buff *skb,
 		       u16 rxq_index, u32 flow_id);
+void enic_flow_may_expire(unsigned long data);
+
+static inline void enic_rfs_timer_start(struct enic *enic)
+{
+	init_timer(&enic->rfs_h.rfs_may_expire);
+	enic->rfs_h.rfs_may_expire.function = enic_flow_may_expire;
+	enic->rfs_h.rfs_may_expire.data = (unsigned long)enic;
+	mod_timer(&enic->rfs_h.rfs_may_expire, jiffies + HZ/4);
+}
+
+static inline void enic_rfs_timer_stop(struct enic *enic)
+{
+	del_timer_sync(&enic->rfs_h.rfs_may_expire);
+}
 #else
-static inline void enic_rfs_flw_tbl_init(struct enic *enic) {}
-static inline void enic_rfs_flw_tbl_free(struct enic *enic) {}
+static inline void enic_rfs_timer_start(struct enic *enic) {}
+static inline void enic_rfs_timer_stop(struct enic *enic) {}
 #endif /* CONFIG_RFS_ACCEL */
 
 #endif /* _ENIC_CLSF_H_ */
