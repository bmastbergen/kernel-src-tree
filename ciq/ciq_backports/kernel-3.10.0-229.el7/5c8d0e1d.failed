ACPI / hotplug / PCI: Do not queue up event handling work items in vain

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Do not queue up event handling work items in vain (Myron Stowe) [1114228]
Rebuild_FUZZ: 93.23%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 5c8d0e1dc475f0f35b5a774c92c68c3f7dbd3f5f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5c8d0e1d.failed

Modify handle_hotplug_event() to avoid queing up the execution of
handle_hotplug_event_work_fn() as a work item on kacpi_hotplug_wq
for non-hotplug events, such as ACPI_NOTIFY_DEVICE_WAKE.  Move
the code printing diagnostic messages for those events into
handle_hotplug_event().

In addition to that, remove the bogus comment about how the core
should distinguish between hotplug and non-hotplug events and
queue them up on different workqueues.  The core clearly cannot
know in advance what events will be interesting to the given
caller of acpi_install_notify_handler().

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 5c8d0e1dc475f0f35b5a774c92c68c3f7dbd3f5f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index d210006fa4ad,44191db1f050..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -1010,130 -912,39 +1010,137 @@@ static void _handle_hotplug_event_bridg
  
  	case ACPI_NOTIFY_DEVICE_CHECK:
  		/* device check */
 -		dbg("%s: Device check notify on %s\n", __func__, objname);
 -		if (bridge)
 -			acpiphp_check_bridge(bridge);
 -		else
 -			acpiphp_check_bridge(func->parent);
 +		pr_debug("%s: Device check notify on %s\n", __func__, objname);
 +		acpiphp_check_bridge(bridge);
 +		break;
  
++<<<<<<< HEAD
 +	case ACPI_NOTIFY_DEVICE_WAKE:
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
  		break;
  
++=======
++>>>>>>> 5c8d0e1dc475 (ACPI / hotplug / PCI: Do not queue up event handling work items in vain)
  	case ACPI_NOTIFY_EJECT_REQUEST:
  		/* request device eject */
 -		dbg("%s: Device eject notify on %s\n", __func__, objname);
 -		acpiphp_disable_and_eject_slot(func->slot);
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {
 +			struct acpiphp_slot *slot;
 +			slot = bridge->func->slot;
 +			if (!acpiphp_disable_slot(slot))
 +				acpiphp_eject_slot(slot);
 +		}
 +		break;
++<<<<<<< HEAD
 +
 +	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
 +		printk(KERN_ERR "Device %s cannot be configured due"
 +				" to a frequency mismatch\n", objname);
  		break;
 +
 +	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
 +		printk(KERN_ERR "Device %s cannot be configured due"
 +				" to a bus mode mismatch\n", objname);
 +		break;
 +
 +	case ACPI_NOTIFY_POWER_FAULT:
 +		printk(KERN_ERR "Device %s has suffered a power fault\n",
 +				objname);
 +		break;
 +
 +	default:
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
 +		break;
++=======
++>>>>>>> 5c8d0e1dc475 (ACPI / hotplug / PCI: Do not queue up event handling work items in vain)
  	}
  
 -	if (bridge)
 -		put_bridge(bridge);
 +	acpi_scan_lock_release();
 +	kfree(hp_work); /* allocated in handle_hotplug_event_bridge */
 +	put_bridge(bridge);
  }
  
 -static void hotplug_event_work(struct work_struct *work)
 +/**
 + * handle_hotplug_event_bridge - handle ACPI event on bridges
 + * @handle: Notify()'ed acpi_handle
 + * @type: Notify code
 + * @context: pointer to acpiphp_bridge structure
 + *
 + * Handles ACPI event notification on {host,p2p} bridges.
 + */
 +static void handle_hotplug_event_bridge(acpi_handle handle, u32 type,
 +					void *context)
 +{
 +	struct acpiphp_bridge *bridge = context;
 +
++<<<<<<< HEAD
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_bridge);
 +}
 +
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context)
 +{
 +	struct acpiphp_func *func = context;
 +	char objname[64];
 +	struct acpi_buffer buffer = { .length = sizeof(objname),
 +				      .pointer = objname };
 +
 +	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 +
 +	switch (type) {
 +	case ACPI_NOTIFY_BUS_CHECK:
 +		/* bus re-enumerate */
 +		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
 +		acpiphp_enable_slot(func->slot);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_CHECK:
 +		/* device check : re-enumerate from parent bus */
 +		pr_debug("%s: Device check notify on %s\n", __func__, objname);
 +		acpiphp_check_bridge(func->slot->bridge);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_WAKE:
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
 +		break;
 +
 +	case ACPI_NOTIFY_EJECT_REQUEST:
 +		/* request device eject */
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if (!(acpiphp_disable_slot(func->slot)))
 +			acpiphp_eject_slot(func->slot);
 +		break;
 +
 +	default:
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
 +		break;
 +	}
 +}
 +
 +static void _handle_hotplug_event_func(struct work_struct *work)
  {
 -	struct acpiphp_context *context;
  	struct acpi_hp_work *hp_work;
 +	struct acpiphp_func *func;
  
  	hp_work = container_of(work, struct acpi_hp_work, work);
 -	context = hp_work->context;
 +	func = hp_work->context;
  	acpi_scan_lock_acquire();
  
 -	hotplug_event(hp_work->handle, hp_work->type, context);
 +	hotplug_event_func(hp_work->handle, hp_work->type, func);
  
  	acpi_scan_lock_release();
 -	kfree(hp_work); /* allocated in handle_hotplug_event() */
 -	put_bridge(context->func.parent);
 +	kfree(hp_work); /* allocated in handle_hotplug_event_func */
 +	put_bridge(func->slot->bridge);
  }
  
  /**
@@@ -1144,21 -955,46 +1151,59 @@@
   *
   * Handles ACPI event notification on slots.
   */
 -static void handle_hotplug_event(acpi_handle handle, u32 type, void *data)
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type,
 +				      void *context)
  {
 -	struct acpiphp_context *context;
 +	struct acpiphp_func *func = context;
  
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(func->slot->bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_func);
++=======
+ 	switch (type) {
+ 	case ACPI_NOTIFY_BUS_CHECK:
+ 	case ACPI_NOTIFY_DEVICE_CHECK:
+ 	case ACPI_NOTIFY_EJECT_REQUEST:
+ 		break;
+ 
+ 	case ACPI_NOTIFY_DEVICE_WAKE:
+ 		return;
+ 
+ 	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
+ 		acpi_handle_err(handle, "Device cannot be configured due "
+ 				"to a frequency mismatch\n");
+ 		return;
+ 
+ 	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
+ 		acpi_handle_err(handle, "Device cannot be configured due "
+ 				"to a bus mode mismatch\n");
+ 		return;
+ 
+ 	case ACPI_NOTIFY_POWER_FAULT:
+ 		acpi_handle_err(handle, "Device has suffered a power fault\n");
+ 		return;
+ 
+ 	default:
+ 		acpi_handle_warn(handle, "Unsupported event type 0x%x\n", type);
+ 		return;
+ 	}
+ 
+ 	mutex_lock(&acpiphp_context_lock);
+ 	context = acpiphp_get_context(handle);
+ 	if (context) {
+ 		get_bridge(context->func.parent);
+ 		acpiphp_put_context(context);
+ 		alloc_acpi_hp_work(handle, type, context, hotplug_event_work);
+ 	}
+ 	mutex_unlock(&acpiphp_context_lock);
++>>>>>>> 5c8d0e1dc475 (ACPI / hotplug / PCI: Do not queue up event handling work items in vain)
  }
  
  /*
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
