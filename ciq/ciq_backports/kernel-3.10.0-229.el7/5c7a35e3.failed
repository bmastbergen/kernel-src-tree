powerpc/powernv: Fix killed EEH event

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [powerpc] powernv: Fix killed EEH event (Don Zickus) [1127366]
Rebuild_FUZZ: 87.88%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit 5c7a35e3e25232aef8d7aee484436f8cbe3b9b94
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5c7a35e3.failed

On PowerNV platform, EEH errors are reported by IO accessors or poller
driven by interrupt. After the PE is isolated, we won't produce EEH
event for the PE. The current implementation has possibility of EEH
event lost in this way:

The interrupt handler queues one "special" event, which drives the poller.
EEH thread doesn't pick the special event yet. IO accessors kicks in, the
frozen PE is marked as "isolated" and EEH event is queued to the list.
EEH thread runs because of special event and purge all existing EEH events.
However, we never produce an other EEH event for the frozen PE. Eventually,
the PE is marked as "isolated" and we don't have EEH event to recover it.

The patch fixes the issue to keep EEH events for PEs that have been
marked as "isolated" with the help of additional "force" help to
eeh_remove_event().

	Reported-by: Rolf Brudeseth <rolfb@us.ibm.com>
	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 5c7a35e3e25232aef8d7aee484436f8cbe3b9b94)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/eeh_driver.c
diff --cc arch/powerpc/kernel/eeh_driver.c
index cd221e920667,420da61d4ce0..000000000000
--- a/arch/powerpc/kernel/eeh_driver.c
+++ b/arch/powerpc/kernel/eeh_driver.c
@@@ -664,86 -756,92 +664,131 @@@ static void eeh_handle_special_event(vo
  {
  	struct eeh_pe *pe, *phb_pe;
  	struct pci_bus *bus;
 -	struct pci_controller *hose;
 +	struct pci_controller *hose, *tmp;
  	unsigned long flags;
 -	int rc;
 -
 +	int rc = 0;
  
 -	do {
 -		rc = eeh_ops->next_error(&pe);
 +	/*
 +	 * The return value from next_error() has been classified as follows.
 +	 * It might be good to enumerate them. However, next_error() is only
 +	 * supported by PowerNV platform for now. So it would be fine to use
 +	 * integer directly:
 +	 *
 +	 * 4 - Dead IOC           3 - Dead PHB
 +	 * 2 - Fenced PHB         1 - Frozen PE
 +	 * 0 - No error found
 +	 *
 +	 */
 +	rc = eeh_ops->next_error(&pe);
 +	if (rc <= 0)
 +		return;
  
 +	switch (rc) {
 +	case 4:
 +		/* Mark all PHBs in dead state */
 +		eeh_serialize_lock(&flags);
 +		list_for_each_entry_safe(hose, tmp,
 +				&hose_list, list_node) {
 +			phb_pe = eeh_phb_pe_get(hose);
 +			if (!phb_pe) continue;
 +
++<<<<<<< HEAD
 +			eeh_pe_state_mark(phb_pe,
 +				EEH_PE_ISOLATED | EEH_PE_PHB_DEAD);
++=======
+ 		switch (rc) {
+ 		case EEH_NEXT_ERR_DEAD_IOC:
+ 			/* Mark all PHBs in dead state */
+ 			eeh_serialize_lock(&flags);
+ 
+ 			/* Purge all events */
+ 			eeh_remove_event(NULL, true);
+ 
+ 			list_for_each_entry(hose, &hose_list, list_node) {
+ 				phb_pe = eeh_phb_pe_get(hose);
+ 				if (!phb_pe) continue;
+ 
+ 				eeh_pe_state_mark(phb_pe, EEH_PE_ISOLATED);
+ 			}
+ 
+ 			eeh_serialize_unlock(flags);
+ 
+ 			break;
+ 		case EEH_NEXT_ERR_FROZEN_PE:
+ 		case EEH_NEXT_ERR_FENCED_PHB:
+ 		case EEH_NEXT_ERR_DEAD_PHB:
+ 			/* Mark the PE in fenced state */
+ 			eeh_serialize_lock(&flags);
+ 
+ 			/* Purge all events of the PHB */
+ 			eeh_remove_event(pe, true);
+ 
+ 			if (rc == EEH_NEXT_ERR_DEAD_PHB)
+ 				eeh_pe_state_mark(pe, EEH_PE_ISOLATED);
+ 			else
+ 				eeh_pe_state_mark(pe,
+ 					EEH_PE_ISOLATED | EEH_PE_RECOVERING);
+ 
+ 			eeh_serialize_unlock(flags);
+ 
+ 			break;
+ 		case EEH_NEXT_ERR_NONE:
+ 			return;
+ 		default:
+ 			pr_warn("%s: Invalid value %d from next_error()\n",
+ 				__func__, rc);
+ 			return;
++>>>>>>> 5c7a35e3e252 (powerpc/powernv: Fix killed EEH event)
  		}
 +		eeh_serialize_unlock(flags);
 +
 +		/* Purge all events */
 +		eeh_remove_event(NULL);
 +		break;
 +	case 3:
 +	case 2:
 +	case 1:
 +		/* Mark the PE in fenced state */
 +		eeh_serialize_lock(&flags);
 +		if (rc == 3)
 +			eeh_pe_state_mark(pe,
 +				EEH_PE_ISOLATED | EEH_PE_PHB_DEAD);
 +		else
 +			eeh_pe_state_mark(pe,
 +				EEH_PE_ISOLATED | EEH_PE_RECOVERING);
 +		eeh_serialize_unlock(flags);
 +
 +		/* Purge all events of the PHB */
 +		eeh_remove_event(pe);
 +		break;
 +	default:
 +		pr_err("%s: Invalid value %d from next_error()\n",
 +		       __func__, rc);
 +		return;
 +	}
  
 -		/*
 -		 * For fenced PHB and frozen PE, it's handled as normal
 -		 * event. We have to remove the affected PHBs for dead
 -		 * PHB and IOC
 -		 */
 -		if (rc == EEH_NEXT_ERR_FROZEN_PE ||
 -		    rc == EEH_NEXT_ERR_FENCED_PHB) {
 -			eeh_handle_normal_event(pe);
 -			eeh_pe_state_clear(pe, EEH_PE_RECOVERING);
 -		} else {
 -			pci_lock_rescan_remove();
 -			list_for_each_entry(hose, &hose_list, list_node) {
 -				phb_pe = eeh_phb_pe_get(hose);
 -				if (!phb_pe ||
 -				    !(phb_pe->state & EEH_PE_ISOLATED) ||
 -				    (phb_pe->state & EEH_PE_RECOVERING))
 -					continue;
 -
 -				/* Notify all devices to be down */
 -				bus = eeh_pe_bus_get(phb_pe);
 -				eeh_pe_dev_traverse(pe,
 -					eeh_report_failure, NULL);
 -				pcibios_remove_pci_devices(bus);
 -			}
 -			pci_unlock_rescan_remove();
 +	/*
 +	 * For fenced PHB and frozen PE, it's handled as normal
 +	 * event. We have to remove the affected PHBs for dead
 +	 * PHB and IOC
 +	 */
 +	if (rc == 2 || rc == 1)
 +		eeh_handle_normal_event(pe);
 +	else {
 +		pci_lock_rescan_remove();
 +		list_for_each_entry_safe(hose, tmp,
 +			&hose_list, list_node) {
 +			phb_pe = eeh_phb_pe_get(hose);
 +			if (!phb_pe || !(phb_pe->state & EEH_PE_PHB_DEAD))
 +				continue;
 +
 +			bus = eeh_pe_bus_get(phb_pe);
 +			/* Notify all devices that they're about to go down. */
 +			eeh_pe_dev_traverse(pe, eeh_report_failure, NULL);
 +			pcibios_remove_pci_devices(bus);
  		}
 -
 -		/*
 -		 * If we have detected dead IOC, we needn't proceed
 -		 * any more since all PHBs would have been removed
 -		 */
 -		if (rc == EEH_NEXT_ERR_DEAD_IOC)
 -			break;
 -	} while (rc != EEH_NEXT_ERR_NONE);
 +		pci_unlock_rescan_remove();
 +	}
  }
  
  /**
diff --git a/arch/powerpc/include/asm/eeh_event.h b/arch/powerpc/include/asm/eeh_event.h
index 89d5670b2eeb..1e551a2d6f82 100644
--- a/arch/powerpc/include/asm/eeh_event.h
+++ b/arch/powerpc/include/asm/eeh_event.h
@@ -33,7 +33,7 @@ struct eeh_event {
 
 int eeh_event_init(void);
 int eeh_send_failure_event(struct eeh_pe *pe);
-void eeh_remove_event(struct eeh_pe *pe);
+void eeh_remove_event(struct eeh_pe *pe, bool force);
 void eeh_handle_event(struct eeh_pe *pe);
 
 #endif /* __KERNEL__ */
* Unmerged path arch/powerpc/kernel/eeh_driver.c
diff --git a/arch/powerpc/kernel/eeh_event.c b/arch/powerpc/kernel/eeh_event.c
index d27c5afc90ae..85777318cd34 100644
--- a/arch/powerpc/kernel/eeh_event.c
+++ b/arch/powerpc/kernel/eeh_event.c
@@ -147,24 +147,33 @@ int eeh_send_failure_event(struct eeh_pe *pe)
 /**
  * eeh_remove_event - Remove EEH event from the queue
  * @pe: Event binding to the PE
+ * @force: Event will be removed unconditionally
  *
  * On PowerNV platform, we might have subsequent coming events
  * is part of the former one. For that case, those subsequent
  * coming events are totally duplicated and unnecessary, thus
  * they should be removed.
  */
-void eeh_remove_event(struct eeh_pe *pe)
+void eeh_remove_event(struct eeh_pe *pe, bool force)
 {
 	unsigned long flags;
 	struct eeh_event *event, *tmp;
 
+	/*
+	 * If we have NULL PE passed in, we have dead IOC
+	 * or we're sure we can report all existing errors
+	 * by the caller.
+	 *
+	 * With "force", the event with associated PE that
+	 * have been isolated, the event won't be removed
+	 * to avoid event lost.
+	 */
 	spin_lock_irqsave(&eeh_eventlist_lock, flags);
 	list_for_each_entry_safe(event, tmp, &eeh_eventlist, list) {
-		/*
-		 * If we don't have valid PE passed in, that means
-		 * we already have event corresponding to dead IOC
-		 * and all events should be purged.
-		 */
+		if (!force && event->pe &&
+		    (event->pe->state & EEH_PE_ISOLATED))
+			continue;
+
 		if (!pe) {
 			list_del(&event->list);
 			kfree(event);
diff --git a/arch/powerpc/platforms/powernv/eeh-ioda.c b/arch/powerpc/platforms/powernv/eeh-ioda.c
index be33a16408be..ee2b3f7c8f0c 100644
--- a/arch/powerpc/platforms/powernv/eeh-ioda.c
+++ b/arch/powerpc/platforms/powernv/eeh-ioda.c
@@ -762,7 +762,7 @@ static int ioda_eeh_next_error(struct eeh_pe **pe)
 	 * And we should keep the cached OPAL notifier event sychronized
 	 * between the kernel and firmware.
 	 */
-	eeh_remove_event(NULL);
+	eeh_remove_event(NULL, false);
 	opal_notifier_update_evt(OPAL_EVENT_PCI_ERROR, 0x0ul);
 
 	list_for_each_entry_safe(hose, tmp, &hose_list, list_node) {
