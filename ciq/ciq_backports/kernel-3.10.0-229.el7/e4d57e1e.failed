KVM: Move irq notifier implementation into eventfd.c

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Paul Mackerras <paulus@samba.org>
commit e4d57e1ee1ab59f0cef0272800ac6c52e0ec814a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e4d57e1e.failed

This moves the functions kvm_irq_has_notifier(), kvm_notify_acked_irq(),
kvm_register_irq_ack_notifier() and kvm_unregister_irq_ack_notifier()
from irqchip.c to eventfd.c.  The reason for doing this is that those
functions are used in connection with IRQFDs, which are implemented in
eventfd.c.  In future we will want to use IRQFDs on platforms that
don't implement the GSI routing implemented in irqchip.c, so we won't
be compiling in irqchip.c, but we still need the irq notifiers.  The
implementation is unchanged.

	Signed-off-by: Paul Mackerras <paulus@samba.org>
	Tested-by: Eric Auger <eric.auger@linaro.org>
	Tested-by: Cornelia Huck <cornelia.huck@de.ibm.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit e4d57e1ee1ab59f0cef0272800ac6c52e0ec814a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	virt/kvm/irqchip.c
diff --cc virt/kvm/irqchip.c
index b43c275775cd,7f256f31df10..000000000000
--- a/virt/kvm/irqchip.c
+++ b/virt/kvm/irqchip.c
@@@ -31,65 -31,42 +31,104 @@@
  #include <trace/events/kvm.h>
  #include "irq.h"
  
++<<<<<<< HEAD
 +bool kvm_irq_has_notifier(struct kvm *kvm, unsigned irqchip, unsigned pin)
 +{
 +	struct kvm_irq_ack_notifier *kian;
 +	int gsi, idx;
 +
 +	idx = srcu_read_lock(&kvm->irq_srcu);
 +	gsi = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu)->chip[irqchip][pin];
 +	if (gsi != -1)
 +		hlist_for_each_entry_rcu(kian, &kvm->irq_ack_notifier_list,
 +					 link)
 +			if (kian->gsi == gsi) {
 +				srcu_read_unlock(&kvm->irq_srcu, idx);
 +				return true;
 +			}
 +
 +	srcu_read_unlock(&kvm->irq_srcu, idx);
 +
 +	return false;
 +}
 +EXPORT_SYMBOL_GPL(kvm_irq_has_notifier);
 +
 +void kvm_notify_acked_irq(struct kvm *kvm, unsigned irqchip, unsigned pin)
 +{
 +	struct kvm_irq_ack_notifier *kian;
 +	int gsi, idx;
 +
 +	trace_kvm_ack_irq(irqchip, pin);
 +
 +	idx = srcu_read_lock(&kvm->irq_srcu);
 +	gsi = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu)->chip[irqchip][pin];
 +	if (gsi != -1)
 +		hlist_for_each_entry_rcu(kian, &kvm->irq_ack_notifier_list,
 +					 link)
 +			if (kian->gsi == gsi)
 +				kian->irq_acked(kian);
 +	srcu_read_unlock(&kvm->irq_srcu, idx);
 +}
 +
 +void kvm_register_irq_ack_notifier(struct kvm *kvm,
 +				   struct kvm_irq_ack_notifier *kian)
 +{
 +	mutex_lock(&kvm->irq_lock);
 +	hlist_add_head_rcu(&kian->link, &kvm->irq_ack_notifier_list);
 +	mutex_unlock(&kvm->irq_lock);
 +#ifdef __KVM_HAVE_IOAPIC
 +	kvm_vcpu_request_scan_ioapic(kvm);
 +#endif
 +}
 +
 +void kvm_unregister_irq_ack_notifier(struct kvm *kvm,
 +				    struct kvm_irq_ack_notifier *kian)
 +{
 +	mutex_lock(&kvm->irq_lock);
 +	hlist_del_init_rcu(&kian->link);
 +	mutex_unlock(&kvm->irq_lock);
 +	synchronize_srcu(&kvm->irq_srcu);
 +#ifdef __KVM_HAVE_IOAPIC
 +	kvm_vcpu_request_scan_ioapic(kvm);
 +#endif
++=======
+ struct kvm_irq_routing_table {
+ 	int chip[KVM_NR_IRQCHIPS][KVM_IRQCHIP_NUM_PINS];
+ 	struct kvm_kernel_irq_routing_entry *rt_entries;
+ 	u32 nr_rt_entries;
+ 	/*
+ 	 * Array indexed by gsi. Each entry contains list of irq chips
+ 	 * the gsi is connected to.
+ 	 */
+ 	struct hlist_head map[0];
+ };
+ 
+ int kvm_irq_map_gsi(struct kvm *kvm,
+ 		    struct kvm_kernel_irq_routing_entry *entries, int gsi)
+ {
+ 	struct kvm_irq_routing_table *irq_rt;
+ 	struct kvm_kernel_irq_routing_entry *e;
+ 	int n = 0;
+ 
+ 	irq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,
+ 					lockdep_is_held(&kvm->irq_lock));
+ 	if (gsi < irq_rt->nr_rt_entries) {
+ 		hlist_for_each_entry(e, &irq_rt->map[gsi], link) {
+ 			entries[n] = *e;
+ 			++n;
+ 		}
+ 	}
+ 
+ 	return n;
+ }
+ 
+ int kvm_irq_map_chip_pin(struct kvm *kvm, unsigned irqchip, unsigned pin)
+ {
+ 	struct kvm_irq_routing_table *irq_rt;
+ 
+ 	irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);
+ 	return irq_rt->chip[irqchip][pin];
++>>>>>>> e4d57e1ee1ab (KVM: Move irq notifier implementation into eventfd.c)
  }
  
  int kvm_send_userspace_msi(struct kvm *kvm, struct kvm_msi *msi)
diff --git a/virt/kvm/eventfd.c b/virt/kvm/eventfd.c
index 69e2c5d400cf..2439aa01d1cc 100644
--- a/virt/kvm/eventfd.c
+++ b/virt/kvm/eventfd.c
@@ -34,7 +34,9 @@
 #include <linux/srcu.h>
 #include <linux/slab.h>
 #include <linux/seqlock.h>
+#include <trace/events/kvm.h>
 
+#include "irq.h"
 #include "iodev.h"
 
 #ifdef CONFIG_HAVE_KVM_IRQ_ROUTING
@@ -850,3 +852,64 @@ kvm_ioeventfd(struct kvm *kvm, struct kvm_ioeventfd *args)
 
 	return kvm_assign_ioeventfd(kvm, args);
 }
+
+bool kvm_irq_has_notifier(struct kvm *kvm, unsigned irqchip, unsigned pin)
+{
+	struct kvm_irq_ack_notifier *kian;
+	int gsi, idx;
+
+	idx = srcu_read_lock(&kvm->irq_srcu);
+	gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	if (gsi != -1)
+		hlist_for_each_entry_rcu(kian, &kvm->irq_ack_notifier_list,
+					 link)
+			if (kian->gsi == gsi) {
+				srcu_read_unlock(&kvm->irq_srcu, idx);
+				return true;
+			}
+
+	srcu_read_unlock(&kvm->irq_srcu, idx);
+
+	return false;
+}
+EXPORT_SYMBOL_GPL(kvm_irq_has_notifier);
+
+void kvm_notify_acked_irq(struct kvm *kvm, unsigned irqchip, unsigned pin)
+{
+	struct kvm_irq_ack_notifier *kian;
+	int gsi, idx;
+
+	trace_kvm_ack_irq(irqchip, pin);
+
+	idx = srcu_read_lock(&kvm->irq_srcu);
+	gsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);
+	if (gsi != -1)
+		hlist_for_each_entry_rcu(kian, &kvm->irq_ack_notifier_list,
+					 link)
+			if (kian->gsi == gsi)
+				kian->irq_acked(kian);
+	srcu_read_unlock(&kvm->irq_srcu, idx);
+}
+
+void kvm_register_irq_ack_notifier(struct kvm *kvm,
+				   struct kvm_irq_ack_notifier *kian)
+{
+	mutex_lock(&kvm->irq_lock);
+	hlist_add_head_rcu(&kian->link, &kvm->irq_ack_notifier_list);
+	mutex_unlock(&kvm->irq_lock);
+#ifdef __KVM_HAVE_IOAPIC
+	kvm_vcpu_request_scan_ioapic(kvm);
+#endif
+}
+
+void kvm_unregister_irq_ack_notifier(struct kvm *kvm,
+				    struct kvm_irq_ack_notifier *kian)
+{
+	mutex_lock(&kvm->irq_lock);
+	hlist_del_init_rcu(&kian->link);
+	mutex_unlock(&kvm->irq_lock);
+	synchronize_srcu(&kvm->irq_srcu);
+#ifdef __KVM_HAVE_IOAPIC
+	kvm_vcpu_request_scan_ioapic(kvm);
+#endif
+}
* Unmerged path virt/kvm/irqchip.c
