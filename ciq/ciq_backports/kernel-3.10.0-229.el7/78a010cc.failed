vti4: Support inter address family tunneling.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] vti4: Support inter address family tunneling (Jiri Pirko) [1091561]
Rebuild_FUZZ: 98.88%
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit 78a010cca000aafc6a8503eb2be590a533589a27
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/78a010cc.failed

With this patch we can tunnel ipv6 traffic via a vti4
interface. A vti4 interface can now have an ipv6 address
and ipv6 traffic can be routed via a vti4 interface.
The resulting traffic is xfrm transformed and tunneled
throuhg ipv4 if matching IPsec policies and states are
present.

	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 78a010cca000aafc6a8503eb2be590a533589a27)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ip_vti.c
diff --cc net/ipv4/ip_vti.c
index be11cdadfc8b,9369b7c03f1c..000000000000
--- a/net/ipv4/ip_vti.c
+++ b/net/ipv4/ip_vti.c
@@@ -60,66 -61,88 +61,88 @@@ static int vti_rcv(struct sk_buff *skb
  	tunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,
  				  iph->saddr, iph->daddr, 0);
  	if (tunnel != NULL) {
 -		if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
 -			goto drop;
 -
 -		XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = tunnel;
 -		skb->mark = be32_to_cpu(tunnel->parms.i_key);
 -
 -		return xfrm_input(skb, nexthdr, spi, encap_type);
 -	}
 -
 -	return -EINVAL;
 -drop:
 -	kfree_skb(skb);
 -	return 0;
 -}
 -
 -static int vti_rcv(struct sk_buff *skb)
 -{
 -	XFRM_SPI_SKB_CB(skb)->family = AF_INET;
 -	XFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);
 -
 -	return vti_input(skb, ip_hdr(skb)->protocol, 0, 0);
 -}
 -
 -static int vti_rcv_cb(struct sk_buff *skb, int err)
 -{
 -	unsigned short family;
 -	struct net_device *dev;
 -	struct pcpu_sw_netstats *tstats;
 -	struct xfrm_state *x;
 -	struct ip_tunnel *tunnel = XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4;
 -
 -	if (!tunnel)
 +		struct pcpu_tstats *tstats;
 +		u32 oldmark = skb->mark;
 +		int ret;
 +
 +
 +		/* temporarily mark the skb with the tunnel o_key, to
 +		 * only match policies with this mark.
 +		 */
 +		skb->mark = be32_to_cpu(tunnel->parms.o_key);
 +		ret = xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb);
 +		skb->mark = oldmark;
 +		if (!ret)
 +			return -1;
 +
 +		tstats = this_cpu_ptr(tunnel->dev->tstats);
 +		u64_stats_update_begin(&tstats->syncp);
 +		tstats->rx_packets++;
 +		tstats->rx_bytes += skb->len;
 +		u64_stats_update_end(&tstats->syncp);
 +
 +		secpath_reset(skb);
 +		skb->dev = tunnel->dev;
  		return 1;
 -
 -	dev = tunnel->dev;
 -
 -	if (err) {
 -		dev->stats.rx_errors++;
 -		dev->stats.rx_dropped++;
 -
 -		return 0;
  	}
  
 -	x = xfrm_input_state(skb);
 -	family = x->inner_mode->afinfo->family;
 -
 -	if (!xfrm_policy_check(NULL, XFRM_POLICY_IN, skb, family))
 -		return -EPERM;
 -
 -	skb_scrub_packet(skb, !net_eq(tunnel->net, dev_net(skb->dev)));
 -	skb->dev = dev;
 -
 -	tstats = this_cpu_ptr(dev->tstats);
 -
 -	u64_stats_update_begin(&tstats->syncp);
 -	tstats->rx_packets++;
 -	tstats->rx_bytes += skb->len;
 -	u64_stats_update_end(&tstats->syncp);
 -
 -	return 0;
 +	return -1;
  }
  
++<<<<<<< HEAD
 +/* This function assumes it is being called from dev_queue_xmit()
 + * and that skb is filled properly by that function.
 + */
 +
 +static netdev_tx_t vti_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)
++=======
+ static netdev_tx_t vti_xmit(struct sk_buff *skb, struct net_device *dev,
+ 			    struct flowi *fl)
++>>>>>>> 78a010cca000 (vti4: Support inter address family tunneling.)
  {
  	struct ip_tunnel *tunnel = netdev_priv(dev);
 -	struct dst_entry *dst = skb_dst(skb);
 +	struct iphdr  *tiph = &tunnel->parms.iph;
 +	u8     tos;
 +	struct rtable *rt;		/* Route to the other host */
  	struct net_device *tdev;	/* Device to other host */
++<<<<<<< HEAD
 +	struct iphdr  *old_iph = ip_hdr(skb);
 +	__be32 dst = tiph->daddr;
 +	struct flowi4 fl4;
 +	int err;
 +
 +	if (skb->protocol != htons(ETH_P_IP))
 +		goto tx_error;
 +
 +	tos = old_iph->tos;
 +
 +	memset(&fl4, 0, sizeof(fl4));
 +	flowi4_init_output(&fl4, tunnel->parms.link,
 +			   be32_to_cpu(tunnel->parms.o_key), RT_TOS(tos),
 +			   RT_SCOPE_UNIVERSE,
 +			   IPPROTO_IPIP, 0,
 +			   dst, tiph->saddr, 0, 0);
 +	rt = ip_route_output_key(dev_net(dev), &fl4);
 +	if (IS_ERR(rt)) {
 +		dev->stats.tx_carrier_errors++;
 +		goto tx_error_icmp;
 +	}
++=======
+ 	int err;
+ 
+ 	if (!dst) {
+ 		dev->stats.tx_carrier_errors++;
+ 		goto tx_error_icmp;
+ 	}
+ 
+ 	dst_hold(dst);
+ 	dst = xfrm_lookup(tunnel->net, dst, fl, NULL, 0);
+ 	if (IS_ERR(dst)) {
+ 		dev->stats.tx_carrier_errors++;
+ 		goto tx_error_icmp;
+ 	}
+ 
++>>>>>>> 78a010cca000 (vti4: Support inter address family tunneling.)
  	/* if there is no transform then this tunnel is not functional.
  	 * Or if the xfrm is not mode tunnel.
  	 */
@@@ -146,10 -169,8 +169,15 @@@
  			tunnel->err_count = 0;
  	}
  
++<<<<<<< HEAD
 +	memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
 +	skb_dst_drop(skb);
 +	skb_dst_set(skb, &rt->dst);
 +	nf_reset(skb);
++=======
+ 	skb_scrub_packet(skb, !net_eq(tunnel->net, dev_net(dev)));
+ 	skb_dst_set(skb, dst);
++>>>>>>> 78a010cca000 (vti4: Support inter address family tunneling.)
  	skb->dev = skb_dst(skb)->dev;
  
  	err = dst_output(skb);
@@@ -166,6 -187,95 +194,98 @@@ tx_error
  	return NETDEV_TX_OK;
  }
  
++<<<<<<< HEAD
++=======
+ /* This function assumes it is being called from dev_queue_xmit()
+  * and that skb is filled properly by that function.
+  */
+ static netdev_tx_t vti_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct ip_tunnel *tunnel = netdev_priv(dev);
+ 	struct flowi fl;
+ 
+ 	memset(&fl, 0, sizeof(fl));
+ 
+ 	skb->mark = be32_to_cpu(tunnel->parms.o_key);
+ 
+ 	switch (skb->protocol) {
+ 	case htons(ETH_P_IP):
+ 		xfrm_decode_session(skb, &fl, AF_INET);
+ 		memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
+ 		break;
+ 	case htons(ETH_P_IPV6):
+ 		xfrm_decode_session(skb, &fl, AF_INET6);
+ 		memset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));
+ 		break;
+ 	default:
+ 		dev->stats.tx_errors++;
+ 		dev_kfree_skb(skb);
+ 		return NETDEV_TX_OK;
+ 	}
+ 
+ 	return vti_xmit(skb, dev, &fl);
+ }
+ 
+ static int vti4_err(struct sk_buff *skb, u32 info)
+ {
+ 	__be32 spi;
+ 	struct xfrm_state *x;
+ 	struct ip_tunnel *tunnel;
+ 	struct ip_esp_hdr *esph;
+ 	struct ip_auth_hdr *ah ;
+ 	struct ip_comp_hdr *ipch;
+ 	struct net *net = dev_net(skb->dev);
+ 	const struct iphdr *iph = (const struct iphdr *)skb->data;
+ 	int protocol = iph->protocol;
+ 	struct ip_tunnel_net *itn = net_generic(net, vti_net_id);
+ 
+ 	tunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,
+ 				  iph->daddr, iph->saddr, 0);
+ 	if (!tunnel)
+ 		return -1;
+ 
+ 	switch (protocol) {
+ 	case IPPROTO_ESP:
+ 		esph = (struct ip_esp_hdr *)(skb->data+(iph->ihl<<2));
+ 		spi = esph->spi;
+ 		break;
+ 	case IPPROTO_AH:
+ 		ah = (struct ip_auth_hdr *)(skb->data+(iph->ihl<<2));
+ 		spi = ah->spi;
+ 		break;
+ 	case IPPROTO_COMP:
+ 		ipch = (struct ip_comp_hdr *)(skb->data+(iph->ihl<<2));
+ 		spi = htonl(ntohs(ipch->cpi));
+ 		break;
+ 	default:
+ 		return 0;
+ 	}
+ 
+ 	switch (icmp_hdr(skb)->type) {
+ 	case ICMP_DEST_UNREACH:
+ 		if (icmp_hdr(skb)->code != ICMP_FRAG_NEEDED)
+ 			return 0;
+ 	case ICMP_REDIRECT:
+ 		break;
+ 	default:
+ 		return 0;
+ 	}
+ 
+ 	x = xfrm_state_lookup(net, skb->mark, (const xfrm_address_t *)&iph->daddr,
+ 			      spi, protocol, AF_INET);
+ 	if (!x)
+ 		return 0;
+ 
+ 	if (icmp_hdr(skb)->type == ICMP_DEST_UNREACH)
+ 		ipv4_update_pmtu(skb, net, info, 0, 0, protocol, 0);
+ 	else
+ 		ipv4_redirect(skb, net, 0, 0, protocol, 0);
+ 	xfrm_state_put(x);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 78a010cca000 (vti4: Support inter address family tunneling.)
  static int
  vti_tunnel_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
  {
* Unmerged path net/ipv4/ip_vti.c
