nfs: rename members of nfs_pgio_data

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Weston Andros Adamson <dros@primarydata.com>
commit 823b0c9d9800e712374cda89ac3565bd29f6701b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/823b0c9d.failed

Rename "verf" to "writeverf" and "pages" to "page_array" to prepare for
merge of nfs_pgio_data and nfs_pgio_header.

	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 823b0c9d9800e712374cda89ac3565bd29f6701b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pagelist.c
#	fs/nfs/write.c
#	include/linux/nfs_xdr.h
diff --cc fs/nfs/pagelist.c
index 00f3d2d2a504,5e70918f6c95..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -307,6 -452,192 +307,195 @@@ size_t nfs_generic_pg_test(struct nfs_p
  }
  EXPORT_SYMBOL_GPL(nfs_generic_pg_test);
  
++<<<<<<< HEAD
++=======
+ struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *ops)
+ {
+ 	struct nfs_pgio_header *hdr = ops->rw_alloc_header();
+ 
+ 	if (hdr) {
+ 		INIT_LIST_HEAD(&hdr->pages);
+ 		spin_lock_init(&hdr->lock);
+ 		atomic_set(&hdr->refcnt, 0);
+ 		hdr->rw_ops = ops;
+ 	}
+ 	return hdr;
+ }
+ EXPORT_SYMBOL_GPL(nfs_pgio_header_alloc);
+ 
+ /*
+  * nfs_pgio_header_free - Free a read or write header
+  * @hdr: The header to free
+  */
+ void nfs_pgio_header_free(struct nfs_pgio_header *hdr)
+ {
+ 	hdr->rw_ops->rw_free_header(hdr);
+ }
+ EXPORT_SYMBOL_GPL(nfs_pgio_header_free);
+ 
+ /**
+  * nfs_pgio_data_alloc - Allocate pageio data
+  * @hdr: The header making a request
+  * @pagecount: Number of pages to create
+  */
+ static bool nfs_pgio_data_init(struct nfs_pgio_header *hdr,
+ 			       unsigned int pagecount)
+ {
+ 	if (nfs_pgarray_set(&hdr->data.page_array, pagecount)) {
+ 		hdr->data.header = hdr;
+ 		atomic_inc(&hdr->refcnt);
+ 		return true;
+ 	}
+ 	return false;
+ }
+ 
+ /**
+  * nfs_pgio_data_destroy - Properly free pageio data
+  * @data: The data to destroy
+  */
+ void nfs_pgio_data_destroy(struct nfs_pgio_data *data)
+ {
+ 	struct nfs_pgio_header *hdr = data->header;
+ 
+ 	put_nfs_open_context(data->args.context);
+ 	if (data->page_array.pagevec != data->page_array.page_array)
+ 		kfree(data->page_array.pagevec);
+ 	if (atomic_dec_and_test(&hdr->refcnt))
+ 		hdr->completion_ops->completion(hdr);
+ }
+ EXPORT_SYMBOL_GPL(nfs_pgio_data_destroy);
+ 
+ /**
+  * nfs_pgio_rpcsetup - Set up arguments for a pageio call
+  * @data: The pageio data
+  * @count: Number of bytes to read
+  * @offset: Initial offset
+  * @how: How to commit data (writes only)
+  * @cinfo: Commit information for the call (writes only)
+  */
+ static void nfs_pgio_rpcsetup(struct nfs_pgio_data *data,
+ 			      unsigned int count, unsigned int offset,
+ 			      int how, struct nfs_commit_info *cinfo)
+ {
+ 	struct nfs_page *req = data->header->req;
+ 
+ 	/* Set up the RPC argument and reply structs
+ 	 * NB: take care not to mess about with data->commit et al. */
+ 
+ 	data->args.fh     = NFS_FH(data->header->inode);
+ 	data->args.offset = req_offset(req) + offset;
+ 	/* pnfs_set_layoutcommit needs this */
+ 	data->mds_offset = data->args.offset;
+ 	data->args.pgbase = req->wb_pgbase + offset;
+ 	data->args.pages  = data->page_array.pagevec;
+ 	data->args.count  = count;
+ 	data->args.context = get_nfs_open_context(req->wb_context);
+ 	data->args.lock_context = req->wb_lock_context;
+ 	data->args.stable  = NFS_UNSTABLE;
+ 	switch (how & (FLUSH_STABLE | FLUSH_COND_STABLE)) {
+ 	case 0:
+ 		break;
+ 	case FLUSH_COND_STABLE:
+ 		if (nfs_reqs_to_commit(cinfo))
+ 			break;
+ 	default:
+ 		data->args.stable = NFS_FILE_SYNC;
+ 	}
+ 
+ 	data->res.fattr   = &data->fattr;
+ 	data->res.count   = count;
+ 	data->res.eof     = 0;
+ 	data->res.verf    = &data->writeverf;
+ 	nfs_fattr_init(&data->fattr);
+ }
+ 
+ /**
+  * nfs_pgio_prepare - Prepare pageio data to go over the wire
+  * @task: The current task
+  * @calldata: pageio data to prepare
+  */
+ static void nfs_pgio_prepare(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs_pgio_data *data = calldata;
+ 	int err;
+ 	err = NFS_PROTO(data->header->inode)->pgio_rpc_prepare(task, data);
+ 	if (err)
+ 		rpc_exit(task, err);
+ }
+ 
+ int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_data *data,
+ 		      const struct rpc_call_ops *call_ops, int how, int flags)
+ {
+ 	struct rpc_task *task;
+ 	struct rpc_message msg = {
+ 		.rpc_argp = &data->args,
+ 		.rpc_resp = &data->res,
+ 		.rpc_cred = data->header->cred,
+ 	};
+ 	struct rpc_task_setup task_setup_data = {
+ 		.rpc_client = clnt,
+ 		.task = &data->task,
+ 		.rpc_message = &msg,
+ 		.callback_ops = call_ops,
+ 		.callback_data = data,
+ 		.workqueue = nfsiod_workqueue,
+ 		.flags = RPC_TASK_ASYNC | flags,
+ 	};
+ 	int ret = 0;
+ 
+ 	data->header->rw_ops->rw_initiate(data, &msg, &task_setup_data, how);
+ 
+ 	dprintk("NFS: %5u initiated pgio call "
+ 		"(req %s/%llu, %u bytes @ offset %llu)\n",
+ 		data->task.tk_pid,
+ 		data->header->inode->i_sb->s_id,
+ 		(unsigned long long)NFS_FILEID(data->header->inode),
+ 		data->args.count,
+ 		(unsigned long long)data->args.offset);
+ 
+ 	task = rpc_run_task(&task_setup_data);
+ 	if (IS_ERR(task)) {
+ 		ret = PTR_ERR(task);
+ 		goto out;
+ 	}
+ 	if (how & FLUSH_SYNC) {
+ 		ret = rpc_wait_for_completion_task(task);
+ 		if (ret == 0)
+ 			ret = task->tk_status;
+ 	}
+ 	rpc_put_task(task);
+ out:
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(nfs_initiate_pgio);
+ 
+ /**
+  * nfs_pgio_error - Clean up from a pageio error
+  * @desc: IO descriptor
+  * @hdr: pageio header
+  */
+ static int nfs_pgio_error(struct nfs_pageio_descriptor *desc,
+ 			  struct nfs_pgio_header *hdr)
+ {
+ 	set_bit(NFS_IOHDR_REDO, &hdr->flags);
+ 	nfs_pgio_data_destroy(&hdr->data);
+ 	desc->pg_completion_ops->error_cleanup(&desc->pg_list);
+ 	return -ENOMEM;
+ }
+ 
+ /**
+  * nfs_pgio_release - Release pageio data
+  * @calldata: The pageio data to release
+  */
+ static void nfs_pgio_release(void *calldata)
+ {
+ 	struct nfs_pgio_data *data = calldata;
+ 	if (data->header->rw_ops->rw_release)
+ 		data->header->rw_ops->rw_release(data);
+ 	nfs_pgio_data_destroy(data);
+ }
+ 
++>>>>>>> 823b0c9d9800 (nfs: rename members of nfs_pgio_data)
  /**
   * nfs_pageio_init - initialise a page io descriptor
   * @desc: pointer to descriptor
@@@ -340,6 -673,91 +529,94 @@@ void nfs_pageio_init(struct nfs_pageio_
  }
  EXPORT_SYMBOL_GPL(nfs_pageio_init);
  
++<<<<<<< HEAD
++=======
+ /**
+  * nfs_pgio_result - Basic pageio error handling
+  * @task: The task that ran
+  * @calldata: Pageio data to check
+  */
+ static void nfs_pgio_result(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs_pgio_data *data = calldata;
+ 	struct inode *inode = data->header->inode;
+ 
+ 	dprintk("NFS: %s: %5u, (status %d)\n", __func__,
+ 		task->tk_pid, task->tk_status);
+ 
+ 	if (data->header->rw_ops->rw_done(task, data, inode) != 0)
+ 		return;
+ 	if (task->tk_status < 0)
+ 		nfs_set_pgio_error(data->header, task->tk_status, data->args.offset);
+ 	else
+ 		data->header->rw_ops->rw_result(task, data);
+ }
+ 
+ /*
+  * Create an RPC task for the given read or write request and kick it.
+  * The page must have been locked by the caller.
+  *
+  * It may happen that the page we're passed is not marked dirty.
+  * This is the case if nfs_updatepage detects a conflicting request
+  * that has been written but not committed.
+  */
+ int nfs_generic_pgio(struct nfs_pageio_descriptor *desc,
+ 		     struct nfs_pgio_header *hdr)
+ {
+ 	struct nfs_page		*req;
+ 	struct page		**pages;
+ 	struct nfs_pgio_data	*data;
+ 	struct list_head *head = &desc->pg_list;
+ 	struct nfs_commit_info cinfo;
+ 
+ 	if (!nfs_pgio_data_init(hdr, nfs_page_array_len(desc->pg_base,
+ 			   desc->pg_count)))
+ 		return nfs_pgio_error(desc, hdr);
+ 
+ 	data = &hdr->data;
+ 	nfs_init_cinfo(&cinfo, desc->pg_inode, desc->pg_dreq);
+ 	pages = data->page_array.pagevec;
+ 	while (!list_empty(head)) {
+ 		req = nfs_list_entry(head->next);
+ 		nfs_list_remove_request(req);
+ 		nfs_list_add_request(req, &hdr->pages);
+ 		*pages++ = req->wb_page;
+ 	}
+ 
+ 	if ((desc->pg_ioflags & FLUSH_COND_STABLE) &&
+ 	    (desc->pg_moreio || nfs_reqs_to_commit(&cinfo)))
+ 		desc->pg_ioflags &= ~FLUSH_COND_STABLE;
+ 
+ 	/* Set up the argument struct */
+ 	nfs_pgio_rpcsetup(data, desc->pg_count, 0, desc->pg_ioflags, &cinfo);
+ 	desc->pg_rpc_callops = &nfs_pgio_common_ops;
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(nfs_generic_pgio);
+ 
+ static int nfs_generic_pg_pgios(struct nfs_pageio_descriptor *desc)
+ {
+ 	struct nfs_pgio_header *hdr;
+ 	int ret;
+ 
+ 	hdr = nfs_pgio_header_alloc(desc->pg_rw_ops);
+ 	if (!hdr) {
+ 		desc->pg_completion_ops->error_cleanup(&desc->pg_list);
+ 		return -ENOMEM;
+ 	}
+ 	nfs_pgheader_init(desc, hdr, nfs_pgio_header_free);
+ 	atomic_inc(&hdr->refcnt);
+ 	ret = nfs_generic_pgio(desc, hdr);
+ 	if (ret == 0)
+ 		ret = nfs_initiate_pgio(NFS_CLIENT(hdr->inode),
+ 					&hdr->data, desc->pg_rpc_callops,
+ 					desc->pg_ioflags, 0);
+ 	if (atomic_dec_and_test(&hdr->refcnt))
+ 		hdr->completion_ops->completion(hdr);
+ 	return ret;
+ }
+ 
++>>>>>>> 823b0c9d9800 (nfs: rename members of nfs_pgio_data)
  static bool nfs_match_open_context(const struct nfs_open_context *ctx1,
  		const struct nfs_open_context *ctx2)
  {
diff --cc fs/nfs/write.c
index 7571542ecbdc,6afe0f679420..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -642,11 -596,11 +642,11 @@@ nfs_clear_request_commit(struct nfs_pag
  }
  
  static inline
 -int nfs_write_need_commit(struct nfs_pgio_data *data)
 +int nfs_write_need_commit(struct nfs_write_data *data)
  {
- 	if (data->verf.committed == NFS_DATA_SYNC)
+ 	if (data->writeverf.committed == NFS_DATA_SYNC)
  		return data->header->lseg == NULL;
- 	return data->verf.committed != NFS_FILE_SYNC;
+ 	return data->writeverf.committed != NFS_FILE_SYNC;
  }
  
  #else
@@@ -1406,8 -1095,9 +1406,14 @@@ static void nfs_writeback_release_commo
  		if (test_bit(NFS_IOHDR_NEED_RESCHED, &hdr->flags))
  			; /* Do nothing */
  		else if (!test_and_set_bit(NFS_IOHDR_NEED_COMMIT, &hdr->flags))
++<<<<<<< HEAD
 +			memcpy(hdr->verf, &data->verf, sizeof(*hdr->verf));
 +		else if (memcmp(hdr->verf, &data->verf, sizeof(*hdr->verf)))
++=======
+ 			memcpy(&hdr->verf, &data->writeverf, sizeof(hdr->verf));
+ 		else if (memcmp(&hdr->verf, &data->writeverf,
+ 			 sizeof(hdr->verf)))
++>>>>>>> 823b0c9d9800 (nfs: rename members of nfs_pgio_data)
  			set_bit(NFS_IOHDR_NEED_RESCHED, &hdr->flags);
  		spin_unlock(&hdr->lock);
  	}
diff --cc include/linux/nfs_xdr.h
index 381f832b03c6,bb18dba1aefe..000000000000
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@@ -1270,6 -1257,22 +1270,25 @@@ enum 
  	NFS_IOHDR_NEED_RESCHED,
  };
  
++<<<<<<< HEAD
++=======
+ struct nfs_pgio_data {
+ 	struct nfs_pgio_header	*header;
+ 	struct list_head	list;
+ 	struct rpc_task		task;
+ 	struct nfs_fattr	fattr;
+ 	struct nfs_writeverf	writeverf;	/* Used for writes */
+ 	struct nfs_pgio_args	args;		/* argument struct */
+ 	struct nfs_pgio_res	res;		/* result struct */
+ 	unsigned long		timestamp;	/* For lease renewal */
+ 	int (*pgio_done_cb)(struct rpc_task *task, struct nfs_pgio_data *data);
+ 	__u64			mds_offset;	/* Filelayout dense stripe */
+ 	struct nfs_page_array	page_array;
+ 	struct nfs_client	*ds_clp;	/* pNFS data server */
+ 	int			ds_idx;		/* ds index if ds_clp is set */
+ };
+ 
++>>>>>>> 823b0c9d9800 (nfs: rename members of nfs_pgio_data)
  struct nfs_pgio_header {
  	struct inode		*inode;
  	struct rpc_cred		*cred;
diff --git a/fs/nfs/blocklayout/blocklayout.c b/fs/nfs/blocklayout/blocklayout.c
index 8fe72d727e75..51414b1acb27 100644
--- a/fs/nfs/blocklayout/blocklayout.c
+++ b/fs/nfs/blocklayout/blocklayout.c
@@ -261,7 +261,8 @@ bl_read_pagelist(struct nfs_read_data *rdata)
 	const bool is_dio = (header->dreq != NULL);
 
 	dprintk("%s enter nr_pages %u offset %lld count %u\n", __func__,
-	       rdata->pages.npages, f_offset, (unsigned int)rdata->args.count);
+		rdata->page_array.npages, f_offset,
+		(unsigned int)rdata->args.count);
 
 	par = alloc_parallel(rdata);
 	if (!par)
@@ -271,7 +272,7 @@ bl_read_pagelist(struct nfs_read_data *rdata)
 
 	isect = (sector_t) (f_offset >> SECTOR_SHIFT);
 	/* Code assumes extents are page-aligned */
-	for (i = pg_index; i < rdata->pages.npages; i++) {
+	for (i = pg_index; i < rdata->page_array.npages; i++) {
 		if (!extent_length) {
 			/* We've used up the previous extent */
 			bl_put_extent(be);
@@ -320,7 +321,8 @@ bl_read_pagelist(struct nfs_read_data *rdata)
 			struct pnfs_block_extent *be_read;
 
 			be_read = (hole && cow_read) ? cow_read : be;
-			bio = do_add_page_to_bio(bio, rdata->pages.npages - i,
+			bio = do_add_page_to_bio(bio,
+						 rdata->page_array.npages - i,
 						 READ,
 						 isect, pages[i], be_read,
 						 bl_end_io_read, par,
@@ -453,7 +455,7 @@ static void bl_end_par_io_write(void *data, int num_se)
 	}
 
 	wdata->task.tk_status = wdata->header->pnfs_error;
-	wdata->verf.committed = NFS_FILE_SYNC;
+	wdata->writeverf.committed = NFS_FILE_SYNC;
 	INIT_WORK(&wdata->task.u.tk_work, bl_write_cleanup);
 	schedule_work(&wdata->task.u.tk_work);
 }
@@ -706,7 +708,7 @@ bl_write_pagelist(struct nfs_write_data *wdata, int sync)
 		dprintk("pnfsblock nonblock aligned DIO writes. Resend MDS\n");
 		goto out_mds;
 	}
-	/* At this point, wdata->pages is a (sequential) list of nfs_pages.
+	/* At this point, wdata->page_aray is a (sequential) list of nfs_pages.
 	 * We want to write each, and if there is an error set pnfs_error
 	 * to have it redone using nfs.
 	 */
@@ -798,7 +800,7 @@ next_page:
 
 	/* Middle pages */
 	pg_index = wdata->args.pgbase >> PAGE_CACHE_SHIFT;
-	for (i = pg_index; i < wdata->pages.npages; i++) {
+	for (i = pg_index; i < wdata->page_array.npages; i++) {
 		if (!extent_length) {
 			/* We've used up the previous extent */
 			bl_put_extent(be);
@@ -869,7 +871,8 @@ next_page:
 		}
 
 
-		bio = do_add_page_to_bio(bio, wdata->pages.npages - i, WRITE,
+		bio = do_add_page_to_bio(bio, wdata->page_array.npages - i,
+					 WRITE,
 					 isect, pages[i], be,
 					 bl_end_io_write, par,
 					 pg_offset, pg_len);
diff --git a/fs/nfs/objlayout/objlayout.c b/fs/nfs/objlayout/objlayout.c
index dd7dcf3fd2ca..7eb641a16899 100644
--- a/fs/nfs/objlayout/objlayout.c
+++ b/fs/nfs/objlayout/objlayout.c
@@ -329,7 +329,7 @@ objlayout_write_done(struct objlayout_io_res *oir, ssize_t status, bool sync)
 	oir->status = wdata->task.tk_status = status;
 	if (status >= 0) {
 		wdata->res.count = status;
-		wdata->verf.committed = oir->committed;
+		wdata->writeverf.committed = oir->committed;
 	} else {
 		wdata->header->pnfs_error = status;
 	}
@@ -337,7 +337,7 @@ objlayout_write_done(struct objlayout_io_res *oir, ssize_t status, bool sync)
 	/* must not use oir after this point */
 
 	dprintk("%s: Return status %zd committed %d sync=%d\n", __func__,
-		status, wdata->verf.committed, sync);
+		status, wdata->writeverf.committed, sync);
 
 	if (sync)
 		pnfs_ld_write_done(wdata);
* Unmerged path fs/nfs/pagelist.c
* Unmerged path fs/nfs/write.c
* Unmerged path include/linux/nfs_xdr.h
