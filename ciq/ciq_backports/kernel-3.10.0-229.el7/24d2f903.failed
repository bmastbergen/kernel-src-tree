blk-mq: split out tag initialization, support shared tags

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Christoph Hellwig <hch@lst.de>
commit 24d2f90309b23f2cfe016b2aebc5f0d6e01c57fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/24d2f903.failed

Add a new blk_mq_tag_set structure that gets set up before we initialize
the queue.  A single blk_mq_tag_set structure can be shared by multiple
queues.

	Signed-off-by: Christoph Hellwig <hch@lst.de>

Modular export of blk_mq_{alloc,free}_tagset added by me.

	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 24d2f90309b23f2cfe016b2aebc5f0d6e01c57fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
#	drivers/block/virtio_blk.c
#	include/linux/blk-mq.h
diff --cc block/blk-mq.c
index f4a318f9cbbe,9180052d42cc..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -65,7 -81,8 +65,12 @@@ static struct request *__blk_mq_alloc_r
  
  	tag = blk_mq_get_tag(hctx->tags, gfp, reserved);
  	if (tag != BLK_MQ_TAG_FAIL) {
++<<<<<<< HEAD
 +		rq = hctx->rqs[tag];
++=======
+ 		rq = hctx->tags->rqs[tag];
+ 		blk_rq_init(hctx->queue, rq);
++>>>>>>> 24d2f90309b2 (blk-mq: split out tag initialization, support shared tags)
  		rq->tag = tag;
  
  		return rq;
@@@ -1021,80 -1035,26 +1033,101 @@@ static int blk_mq_hctx_notify(void *dat
  
  	blk_mq_run_hw_queue(hctx, true);
  	blk_mq_put_ctx(ctx);
 +	return NOTIFY_OK;
 +}
 +
++<<<<<<< HEAD
 +static int blk_mq_init_hw_commands(struct blk_mq_hw_ctx *hctx,
 +				   int (*init)(void *, struct blk_mq_hw_ctx *,
 +					struct request *, unsigned int),
 +				   void *data)
 +{
 +	unsigned int i;
 +	int ret = 0;
 +
 +	for (i = 0; i < hctx->queue_depth; i++) {
 +		struct request *rq = hctx->rqs[i];
 +
 +		ret = init(data, hctx, rq, i);
 +		if (ret)
 +			break;
 +	}
 +
 +	return ret;
 +}
 +
 +int blk_mq_init_commands(struct request_queue *q,
 +			 int (*init)(void *, struct blk_mq_hw_ctx *,
 +					struct request *, unsigned int),
 +			 void *data)
 +{
 +	struct blk_mq_hw_ctx *hctx;
 +	unsigned int i;
 +	int ret = 0;
 +
 +	queue_for_each_hw_ctx(q, hctx, i) {
 +		ret = blk_mq_init_hw_commands(hctx, init, data);
 +		if (ret)
 +			break;
 +	}
 +
 +	return ret;
 +}
 +EXPORT_SYMBOL(blk_mq_init_commands);
 +
 +static void blk_mq_free_hw_commands(struct blk_mq_hw_ctx *hctx,
 +				    void (*free)(void *, struct blk_mq_hw_ctx *,
 +					struct request *, unsigned int),
 +				    void *data)
 +{
 +	unsigned int i;
 +
 +	for (i = 0; i < hctx->queue_depth; i++) {
 +		struct request *rq = hctx->rqs[i];
 +
 +		free(data, hctx, rq, i);
 +	}
 +}
 +
 +void blk_mq_free_commands(struct request_queue *q,
 +			  void (*free)(void *, struct blk_mq_hw_ctx *,
 +					struct request *, unsigned int),
 +			  void *data)
 +{
 +	struct blk_mq_hw_ctx *hctx;
 +	unsigned int i;
 +
 +	queue_for_each_hw_ctx(q, hctx, i)
 +		blk_mq_free_hw_commands(hctx, free, data);
  }
 +EXPORT_SYMBOL(blk_mq_free_commands);
  
 +static void blk_mq_free_rq_map(struct blk_mq_hw_ctx *hctx)
 +{
 +	struct page *page;
 +
 +	while (!list_empty(&hctx->page_list)) {
 +		page = list_first_entry(&hctx->page_list, struct page, lru);
++=======
+ static void blk_mq_free_rq_map(struct blk_mq_tag_set *set,
+ 		struct blk_mq_tags *tags, unsigned int hctx_idx)
+ {
+ 	struct page *page;
+ 
+ 	if (tags->rqs && set->ops->exit_request) {
+ 		int i;
+ 
+ 		for (i = 0; i < tags->nr_tags; i++) {
+ 			if (!tags->rqs[i])
+ 				continue;
+ 			set->ops->exit_request(set->driver_data, tags->rqs[i],
+ 						hctx_idx, i);
+ 		}
+ 	}
+ 
+ 	while (!list_empty(&tags->page_list)) {
+ 		page = list_first_entry(&tags->page_list, struct page, lru);
++>>>>>>> 24d2f90309b2 (blk-mq: split out tag initialization, support shared tags)
  		list_del_init(&page->lru);
  		__free_pages(page, page->private);
  	}
@@@ -1107,12 -1066,18 +1139,19 @@@
  
  static size_t order_to_size(unsigned int order)
  {
 -	size_t ret = PAGE_SIZE;
 -
 -	while (order--)
 -		ret *= 2;
 -
 -	return ret;
 +	return (size_t)PAGE_SIZE << order;
  }
  
++<<<<<<< HEAD
 +static int blk_mq_init_rq_map(struct blk_mq_hw_ctx *hctx,
 +			      unsigned int reserved_tags, int node)
 +{
++=======
+ static struct blk_mq_tags *blk_mq_init_rq_map(struct blk_mq_tag_set *set,
+ 		unsigned int hctx_idx)
+ {
+ 	struct blk_mq_tags *tags;
++>>>>>>> 24d2f90309b2 (blk-mq: split out tag initialization, support shared tags)
  	unsigned int i, j, entries_per_page, max_order = 4;
  	size_t rq_size, left;
  
@@@ -1158,32 -1131,28 +1205,52 @@@
  
  		p = page_address(page);
  		entries_per_page = order_to_size(this_order) / rq_size;
- 		to_do = min(entries_per_page, hctx->queue_depth - i);
+ 		to_do = min(entries_per_page, set->queue_depth - i);
  		left -= to_do * rq_size;
  		for (j = 0; j < to_do; j++) {
++<<<<<<< HEAD
 +			hctx->rqs[i] = p;
 +			blk_mq_rq_init(hctx, hctx->rqs[i]);
++=======
+ 			tags->rqs[i] = p;
+ 			if (set->ops->init_request) {
+ 				if (set->ops->init_request(set->driver_data,
+ 						tags->rqs[i], hctx_idx, i,
+ 						set->numa_node))
+ 					goto fail;
+ 			}
+ 
++>>>>>>> 24d2f90309b2 (blk-mq: split out tag initialization, support shared tags)
  			p += rq_size;
  			i++;
  		}
  	}
  
++<<<<<<< HEAD
 +	if (i < (reserved_tags + BLK_MQ_TAG_MIN))
 +		goto err_rq_map;
 +	else if (i != hctx->queue_depth) {
 +		hctx->queue_depth = i;
 +		pr_warn("%s: queue depth set to %u because of low memory\n",
 +					__func__, i);
 +	}
 +
 +	hctx->tags = blk_mq_init_tags(hctx->queue_depth, reserved_tags, node);
 +	if (!hctx->tags) {
 +err_rq_map:
 +		blk_mq_free_rq_map(hctx);
 +		return -ENOMEM;
 +	}
 +
 +	return 0;
++=======
+ 	return tags;
+ 
+ fail:
+ 	pr_warn("%s: failed to allocate requests\n", __func__);
+ 	blk_mq_free_rq_map(set, tags, hctx_idx);
+ 	return NULL;
++>>>>>>> 24d2f90309b2 (blk-mq: split out tag initialization, support shared tags)
  }
  
  static int blk_mq_init_hw_queues(struct request_queue *q,
@@@ -1216,8 -1184,7 +1282,12 @@@
  						blk_mq_hctx_notify, hctx);
  		blk_mq_register_cpu_notifier(&hctx->cpu_notifier);
  
++<<<<<<< HEAD
 +		if (blk_mq_init_rq_map(hctx, reg->reserved_tags, node))
 +			break;
++=======
+ 		hctx->tags = set->tags[i];
++>>>>>>> 24d2f90309b2 (blk-mq: split out tag initialization, support shared tags)
  
  		/*
  		 * Allocate space for all possible cpus to avoid allocation in
@@@ -1252,13 -1219,11 +1322,16 @@@
  		if (i == j)
  			break;
  
- 		if (reg->ops->exit_hctx)
- 			reg->ops->exit_hctx(hctx, j);
+ 		if (set->ops->exit_hctx)
+ 			set->ops->exit_hctx(hctx, j);
  
  		blk_mq_unregister_cpu_notifier(&hctx->cpu_notifier);
++<<<<<<< HEAD
 +		blk_mq_free_rq_map(hctx);
++=======
++>>>>>>> 24d2f90309b2 (blk-mq: split out tag initialization, support shared tags)
  		kfree(hctx->ctxs);
 +		kfree(hctx->ctx_map);
  	}
  
  	return 1;
@@@ -1322,11 -1287,10 +1395,10 @@@ static void blk_mq_map_swqueue(struct r
  	}
  }
  
- struct request_queue *blk_mq_init_queue(struct blk_mq_reg *reg,
- 					void *driver_data)
+ struct request_queue *blk_mq_init_queue(struct blk_mq_tag_set *set)
  {
  	struct blk_mq_hw_ctx **hctxs;
 -	struct blk_mq_ctx *ctx;
 +	struct blk_mq_ctx __percpu *ctx;
  	struct request_queue *q;
  	int i;
  
@@@ -1444,7 -1394,6 +1502,10 @@@ void blk_mq_free_queue(struct request_q
  	queue_for_each_hw_ctx(q, hctx, i) {
  		kfree(hctx->ctx_map);
  		kfree(hctx->ctxs);
++<<<<<<< HEAD
 +		blk_mq_free_rq_map(hctx);
++=======
++>>>>>>> 24d2f90309b2 (blk-mq: split out tag initialization, support shared tags)
  		blk_mq_unregister_cpu_notifier(&hctx->cpu_notifier);
  		if (q->mq_ops->exit_hctx)
  			q->mq_ops->exit_hctx(hctx, i);
diff --cc drivers/block/virtio_blk.c
index 6d8a87f252de,f909a8821e65..000000000000
--- a/drivers/block/virtio_blk.c
+++ b/drivers/block/virtio_blk.c
@@@ -480,33 -483,29 +483,42 @@@ static const struct device_attribute de
  	__ATTR(cache_type, S_IRUGO|S_IWUSR,
  	       virtblk_cache_type_show, virtblk_cache_type_store);
  
++<<<<<<< HEAD
++=======
+ static int virtblk_init_request(void *data, struct request *rq,
+ 		unsigned int hctx_idx, unsigned int request_idx,
+ 		unsigned int numa_node)
+ {
+ 	struct virtio_blk *vblk = data;
+ 	struct virtblk_req *vbr = blk_mq_rq_to_pdu(rq);
+ 
+ 	sg_init_table(vbr->sg, vblk->sg_elems);
+ 	return 0;
+ }
+ 
++>>>>>>> 24d2f90309b2 (blk-mq: split out tag initialization, support shared tags)
  static struct blk_mq_ops virtio_mq_ops = {
  	.queue_rq	= virtio_queue_rq,
  	.map_queue	= blk_mq_map_queue,
  	.alloc_hctx	= blk_mq_alloc_single_hw_queue,
  	.free_hctx	= blk_mq_free_single_hw_queue,
  	.complete	= virtblk_request_done,
+ 	.init_request	= virtblk_init_request,
  };
  
- static struct blk_mq_reg virtio_mq_reg = {
- 	.ops		= &virtio_mq_ops,
- 	.nr_hw_queues	= 1,
- 	.queue_depth	= 0, /* Set in virtblk_probe */
- 	.numa_node	= NUMA_NO_NODE,
- 	.flags		= BLK_MQ_F_SHOULD_MERGE,
- };
- module_param_named(queue_depth, virtio_mq_reg.queue_depth, uint, 0444);
+ static unsigned int virtblk_queue_depth;
+ module_param_named(queue_depth, virtblk_queue_depth, uint, 0444);
  
 +static int virtblk_init_vbr(void *data, struct blk_mq_hw_ctx *hctx,
 +			     struct request *rq, unsigned int nr)
 +{
 +	struct virtio_blk *vblk = data;
 +	struct virtblk_req *vbr = rq->special;
 +
 +	sg_init_table(vbr->sg, vblk->sg_elems);
 +	return 0;
 +}
 +
  static int virtblk_probe(struct virtio_device *vdev)
  {
  	struct virtio_blk *vblk;
@@@ -561,24 -560,34 +573,36 @@@
  	}
  
  	/* Default queue sizing is to fill the ring. */
- 	if (!virtio_mq_reg.queue_depth) {
- 		virtio_mq_reg.queue_depth = vblk->vq->num_free;
+ 	if (!virtblk_queue_depth) {
+ 		virtblk_queue_depth = vblk->vq->num_free;
  		/* ... but without indirect descs, we use 2 descs per req */
  		if (!virtio_has_feature(vdev, VIRTIO_RING_F_INDIRECT_DESC))
- 			virtio_mq_reg.queue_depth /= 2;
+ 			virtblk_queue_depth /= 2;
  	}
- 	virtio_mq_reg.cmd_size =
+ 
+ 	memset(&vblk->tag_set, 0, sizeof(vblk->tag_set));
+ 	vblk->tag_set.ops = &virtio_mq_ops;
+ 	vblk->tag_set.nr_hw_queues = 1;
+ 	vblk->tag_set.queue_depth = virtblk_queue_depth;
+ 	vblk->tag_set.numa_node = NUMA_NO_NODE;
+ 	vblk->tag_set.flags = BLK_MQ_F_SHOULD_MERGE;
+ 	vblk->tag_set.cmd_size =
  		sizeof(struct virtblk_req) +
  		sizeof(struct scatterlist) * sg_elems;
+ 	vblk->tag_set.driver_data = vblk;
  
- 	q = vblk->disk->queue = blk_mq_init_queue(&virtio_mq_reg, vblk);
+ 	err = blk_mq_alloc_tag_set(&vblk->tag_set);
+ 	if (err)
+ 		goto out_put_disk;
+ 
+ 	q = vblk->disk->queue = blk_mq_init_queue(&vblk->tag_set);
  	if (!q) {
  		err = -ENOMEM;
- 		goto out_put_disk;
+ 		goto out_free_tags;
  	}
  
 +	blk_mq_init_commands(q, virtblk_init_vbr, vblk);
 +
  	q->queuedata = vblk;
  
  	virtblk_name_format("vd", index, vblk->disk->disk_name, DISK_NAME_LEN);
diff --cc include/linux/blk-mq.h
index f63ea3c3d292,a4ea0ce83b07..000000000000
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@@ -67,6 -68,10 +68,13 @@@ typedef struct blk_mq_hw_ctx *(alloc_hc
  typedef void (free_hctx_fn)(struct blk_mq_hw_ctx *, unsigned int);
  typedef int (init_hctx_fn)(struct blk_mq_hw_ctx *, void *, unsigned int);
  typedef void (exit_hctx_fn)(struct blk_mq_hw_ctx *, unsigned int);
++<<<<<<< HEAD
++=======
+ typedef int (init_request_fn)(void *, struct request *, unsigned int,
+ 		unsigned int, unsigned int);
+ typedef void (exit_request_fn)(void *, struct request *, unsigned int,
+ 		unsigned int);
++>>>>>>> 24d2f90309b2 (blk-mq: split out tag initialization, support shared tags)
  
  struct blk_mq_ops {
  	/*
@@@ -114,12 -128,13 +122,15 @@@ enum 
  	BLK_MQ_MAX_DEPTH	= 2048,
  };
  
- struct request_queue *blk_mq_init_queue(struct blk_mq_reg *, void *);
+ struct request_queue *blk_mq_init_queue(struct blk_mq_tag_set *);
  int blk_mq_register_disk(struct gendisk *);
  void blk_mq_unregister_disk(struct gendisk *);
 +int blk_mq_init_commands(struct request_queue *, int (*init)(void *data, struct blk_mq_hw_ctx *, struct request *, unsigned int), void *data);
 +void blk_mq_free_commands(struct request_queue *, void (*free)(void *data, struct blk_mq_hw_ctx *, struct request *, unsigned int), void *data);
  
+ int blk_mq_alloc_tag_set(struct blk_mq_tag_set *set);
+ void blk_mq_free_tag_set(struct blk_mq_tag_set *set);
+ 
  void blk_mq_flush_plug_list(struct blk_plug *plug, bool from_schedule);
  
  void blk_mq_insert_request(struct request *, bool, bool, bool);
diff --git a/block/blk-mq-cpumap.c b/block/blk-mq-cpumap.c
index a937d47eb9d9..472efb59dd80 100644
--- a/block/blk-mq-cpumap.c
+++ b/block/blk-mq-cpumap.c
@@ -85,17 +85,17 @@ int blk_mq_update_queue_map(unsigned int *map, unsigned int nr_queues)
 	return 0;
 }
 
-unsigned int *blk_mq_make_queue_map(struct blk_mq_reg *reg)
+unsigned int *blk_mq_make_queue_map(struct blk_mq_tag_set *set)
 {
 	unsigned int *map;
 
 	/* If cpus are offline, map them to first hctx */
 	map = kzalloc_node(sizeof(*map) * num_possible_cpus(), GFP_KERNEL,
-				reg->numa_node);
+				set->numa_node);
 	if (!map)
 		return NULL;
 
-	if (!blk_mq_update_queue_map(map, reg->nr_hw_queues))
+	if (!blk_mq_update_queue_map(map, set->nr_hw_queues))
 		return map;
 
 	kfree(map);
diff --git a/block/blk-mq-tag.c b/block/blk-mq-tag.c
index d50cc52e39c1..145cd8eadebb 100644
--- a/block/blk-mq-tag.c
+++ b/block/blk-mq-tag.c
@@ -12,26 +12,12 @@
  */
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/percpu_ida.h>
 
 #include <linux/blk-mq.h>
 #include "blk.h"
 #include "blk-mq.h"
 #include "blk-mq-tag.h"
 
-/*
- * Per tagged queue (tag address space) map
- */
-struct blk_mq_tags {
-	unsigned int nr_tags;
-	unsigned int nr_reserved_tags;
-	unsigned int nr_batch_move;
-	unsigned int nr_max_cache;
-
-	struct percpu_ida free_tags;
-	struct percpu_ida reserved_tags;
-};
-
 void blk_mq_wait_for_tags(struct blk_mq_tags *tags)
 {
 	int tag = blk_mq_get_tag(tags, __GFP_WAIT, false);
diff --git a/block/blk-mq-tag.h b/block/blk-mq-tag.h
index 947ba2c6148e..b602e3fa66ea 100644
--- a/block/blk-mq-tag.h
+++ b/block/blk-mq-tag.h
@@ -1,7 +1,24 @@
 #ifndef INT_BLK_MQ_TAG_H
 #define INT_BLK_MQ_TAG_H
 
-struct blk_mq_tags;
+#include <linux/percpu_ida.h>
+
+/*
+ * Tag address space map.
+ */
+struct blk_mq_tags {
+	unsigned int nr_tags;
+	unsigned int nr_reserved_tags;
+	unsigned int nr_batch_move;
+	unsigned int nr_max_cache;
+
+	struct percpu_ida free_tags;
+	struct percpu_ida reserved_tags;
+
+	struct request **rqs;
+	struct list_head page_list;
+};
+
 
 extern struct blk_mq_tags *blk_mq_init_tags(unsigned int nr_tags, unsigned int reserved_tags, int node);
 extern void blk_mq_free_tags(struct blk_mq_tags *tags);
* Unmerged path block/blk-mq.c
diff --git a/block/blk-mq.h b/block/blk-mq.h
index 44904eae7f60..1c7f5c16e56d 100644
--- a/block/blk-mq.h
+++ b/block/blk-mq.h
@@ -1,6 +1,8 @@
 #ifndef INT_BLK_MQ_H
 #define INT_BLK_MQ_H
 
+struct blk_mq_tag_set;
+
 struct blk_mq_ctx {
 	struct {
 		spinlock_t		lock;
@@ -44,8 +46,7 @@ void blk_mq_disable_hotplug(void);
 /*
  * CPU -> queue mappings
  */
-struct blk_mq_reg;
-extern unsigned int *blk_mq_make_queue_map(struct blk_mq_reg *reg);
+extern unsigned int *blk_mq_make_queue_map(struct blk_mq_tag_set *set);
 extern int blk_mq_update_queue_map(unsigned int *map, unsigned int nr_queues);
 
 void blk_mq_add_timer(struct request *rq);
diff --git a/drivers/block/null_blk.c b/drivers/block/null_blk.c
index 3ae5f19b54ef..d4e27f7b6cee 100644
--- a/drivers/block/null_blk.c
+++ b/drivers/block/null_blk.c
@@ -32,6 +32,7 @@ struct nullb {
 	unsigned int index;
 	struct request_queue *q;
 	struct gendisk *disk;
+	struct blk_mq_tag_set tag_set;
 	struct hrtimer timer;
 	unsigned int queue_depth;
 	spinlock_t lock;
@@ -320,10 +321,11 @@ static int null_queue_rq(struct blk_mq_hw_ctx *hctx, struct request *rq)
 	return BLK_MQ_RQ_QUEUE_OK;
 }
 
-static struct blk_mq_hw_ctx *null_alloc_hctx(struct blk_mq_reg *reg, unsigned int hctx_index)
+static struct blk_mq_hw_ctx *null_alloc_hctx(struct blk_mq_tag_set *set,
+		unsigned int hctx_index)
 {
-	int b_size = DIV_ROUND_UP(reg->nr_hw_queues, nr_online_nodes);
-	int tip = (reg->nr_hw_queues % nr_online_nodes);
+	int b_size = DIV_ROUND_UP(set->nr_hw_queues, nr_online_nodes);
+	int tip = (set->nr_hw_queues % nr_online_nodes);
 	int node = 0, i, n;
 
 	/*
@@ -338,7 +340,7 @@ static struct blk_mq_hw_ctx *null_alloc_hctx(struct blk_mq_reg *reg, unsigned in
 
 			tip--;
 			if (!tip)
-				b_size = reg->nr_hw_queues / nr_online_nodes;
+				b_size = set->nr_hw_queues / nr_online_nodes;
 		}
 	}
 
@@ -387,13 +389,17 @@ static struct blk_mq_ops null_mq_ops = {
 	.map_queue      = blk_mq_map_queue,
 	.init_hctx	= null_init_hctx,
 	.complete	= null_softirq_done_fn,
+	.alloc_hctx	= blk_mq_alloc_single_hw_queue,
+	.free_hctx	= blk_mq_free_single_hw_queue,
 };
 
-static struct blk_mq_reg null_mq_reg = {
-	.ops		= &null_mq_ops,
-	.queue_depth	= 64,
-	.cmd_size	= sizeof(struct nullb_cmd),
-	.flags		= BLK_MQ_F_SHOULD_MERGE,
+static struct blk_mq_ops null_mq_ops_pernode = {
+	.queue_rq       = null_queue_rq,
+	.map_queue      = blk_mq_map_queue,
+	.init_hctx	= null_init_hctx,
+	.complete	= null_softirq_done_fn,
+	.alloc_hctx	= null_alloc_hctx,
+	.free_hctx	= null_free_hctx,
 };
 
 static void null_del_dev(struct nullb *nullb)
@@ -402,6 +408,8 @@ static void null_del_dev(struct nullb *nullb)
 
 	del_gendisk(nullb->disk);
 	blk_cleanup_queue(nullb->q);
+	if (queue_mode == NULL_Q_MQ)
+		blk_mq_free_tag_set(&nullb->tag_set);
 	put_disk(nullb->disk);
 	kfree(nullb);
 }
@@ -506,54 +514,52 @@ static int null_add_dev(void)
 
 	nullb = kzalloc_node(sizeof(*nullb), GFP_KERNEL, home_node);
 	if (!nullb)
-		return -ENOMEM;
+		goto out;
 
 	spin_lock_init(&nullb->lock);
 
 	if (setup_queues(nullb))
-		goto err;
+		goto out_free_nullb;
 
 	if (queue_mode == NULL_Q_MQ) {
-		null_mq_reg.numa_node = home_node;
-		null_mq_reg.queue_depth = hw_queue_depth;
-		null_mq_reg.nr_hw_queues = submit_queues;
-
-		if (use_per_node_hctx) {
-			null_mq_reg.ops->alloc_hctx = null_alloc_hctx;
-			null_mq_reg.ops->free_hctx = null_free_hctx;
-		} else {
-			null_mq_reg.ops->alloc_hctx = blk_mq_alloc_single_hw_queue;
-			null_mq_reg.ops->free_hctx = blk_mq_free_single_hw_queue;
-		}
-
-		nullb->q = blk_mq_init_queue(&null_mq_reg, nullb);
+		if (use_per_node_hctx)
+			nullb->tag_set.ops = &null_mq_ops_pernode;
+		else
+			nullb->tag_set.ops = &null_mq_ops;
+		nullb->tag_set.nr_hw_queues = submit_queues;
+		nullb->tag_set.queue_depth = hw_queue_depth;
+		nullb->tag_set.numa_node = home_node;
+		nullb->tag_set.cmd_size	= sizeof(struct nullb_cmd);
+		nullb->tag_set.flags = BLK_MQ_F_SHOULD_MERGE;
+		nullb->tag_set.driver_data = nullb;
+
+		if (blk_mq_alloc_tag_set(&nullb->tag_set))
+			goto out_cleanup_queues;
+
+		nullb->q = blk_mq_init_queue(&nullb->tag_set);
+		if (!nullb->q)
+			goto out_cleanup_tags;
 	} else if (queue_mode == NULL_Q_BIO) {
 		nullb->q = blk_alloc_queue_node(GFP_KERNEL, home_node);
+		if (!nullb->q)
+			goto out_cleanup_queues;
 		blk_queue_make_request(nullb->q, null_queue_bio);
 		init_driver_queues(nullb);
 	} else {
 		nullb->q = blk_init_queue_node(null_request_fn, &nullb->lock, home_node);
+		if (!nullb->q)
+			goto out_cleanup_queues;
 		blk_queue_prep_rq(nullb->q, null_rq_prep_fn);
-		if (nullb->q)
-			blk_queue_softirq_done(nullb->q, null_softirq_done_fn);
+		blk_queue_softirq_done(nullb->q, null_softirq_done_fn);
 		init_driver_queues(nullb);
 	}
 
-	if (!nullb->q)
-		goto queue_fail;
-
 	nullb->q->queuedata = nullb;
 	queue_flag_set_unlocked(QUEUE_FLAG_NONROT, nullb->q);
 
 	disk = nullb->disk = alloc_disk_node(1, home_node);
-	if (!disk) {
-queue_fail:
-		blk_cleanup_queue(nullb->q);
-		cleanup_queues(nullb);
-err:
-		kfree(nullb);
-		return -ENOMEM;
-	}
+	if (!disk)
+		goto out_cleanup_blk_queue;
 
 	mutex_lock(&lock);
 	list_add_tail(&nullb->list, &nullb_list);
@@ -576,6 +582,18 @@ err:
 	sprintf(disk->disk_name, "nullb%d", nullb->index);
 	add_disk(disk);
 	return 0;
+
+out_cleanup_blk_queue:
+	blk_cleanup_queue(nullb->q);
+out_cleanup_tags:
+	if (queue_mode == NULL_Q_MQ)
+		blk_mq_free_tag_set(&nullb->tag_set);
+out_cleanup_queues:
+	cleanup_queues(nullb);
+out_free_nullb:
+	kfree(nullb);
+out:
+	return -ENOMEM;
 }
 
 static int __init null_init(void)
* Unmerged path drivers/block/virtio_blk.c
* Unmerged path include/linux/blk-mq.h
