clocksource: Make delta calculation a function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [kernel] time/clocksource: Make delta calculation a function (Prarit Bhargava) [1148398]
Rebuild_FUZZ: 94.85%
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 3a97837784acbf9fed699fc04d1799b0eb742fdf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3a978377.failed

We want to move the TSC sanity check into core code to make NMI safe
accessors to clock monotonic[_raw] possible. For this we need to
sanity check the delta calculation. Create a helper function and
convert all sites to use it.

[ Build fix from jstultz ]

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Signed-off-by: John Stultz <john.stultz@linaro.org>
(cherry picked from commit 3a97837784acbf9fed699fc04d1799b0eb742fdf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/time/clocksource.c
#	kernel/time/timekeeping.c
#	kernel/time/timekeeping_internal.h
diff --cc kernel/time/clocksource.c
index c9583382141a,2e949cc9c9f1..000000000000
--- a/kernel/time/clocksource.c
+++ b/kernel/time/clocksource.c
@@@ -31,6 -31,9 +31,12 @@@
  #include <linux/tick.h>
  #include <linux/kthread.h>
  
++<<<<<<< HEAD
++=======
+ #include "tick-internal.h"
+ #include "timekeeping_internal.h"
+ 
++>>>>>>> 3a97837784ac (clocksource: Make delta calculation a function)
  void timecounter_init(struct timecounter *tc,
  		      const struct cyclecounter *cc,
  		      u64 start_tstamp)
diff --cc kernel/time/timekeeping.c
index 1c5b0fcd83b2,531805013786..000000000000
--- a/kernel/time/timekeeping.c
+++ b/kernel/time/timekeeping.c
@@@ -189,14 -202,48 +189,14 @@@ static inline s64 timekeeping_get_ns_ra
  	cycle_now = clock->read(clock);
  
  	/* calculate the delta since the last update_wall_time: */
- 	cycle_delta = (cycle_now - clock->cycle_last) & clock->mask;
+ 	delta = clocksource_delta(cycle_now, clock->cycle_last, clock->mask);
  
  	/* convert delta to nanoseconds. */
- 	nsec = clocksource_cyc2ns(cycle_delta, clock->mult, clock->shift);
+ 	nsec = clocksource_cyc2ns(delta, clock->mult, clock->shift);
  
  	/* If arch requires, add in get_arch_timeoffset() */
 -	return nsec + arch_gettimeoffset();
 -}
 -
 -#ifdef CONFIG_GENERIC_TIME_VSYSCALL_OLD
 -
 -static inline void update_vsyscall(struct timekeeper *tk)
 -{
 -	struct timespec xt;
 -
 -	xt = tk_xtime(tk);
 -	update_vsyscall_old(&xt, &tk->wall_to_monotonic, tk->clock, tk->mult);
 -}
 -
 -static inline void old_vsyscall_fixup(struct timekeeper *tk)
 -{
 -	s64 remainder;
 -
 -	/*
 -	* Store only full nanoseconds into xtime_nsec after rounding
 -	* it up and add the remainder to the error difference.
 -	* XXX - This is necessary to avoid small 1ns inconsistnecies caused
 -	* by truncating the remainder in vsyscalls. However, it causes
 -	* additional work to be done in timekeeping_adjust(). Once
 -	* the vsyscall implementations are converted to use xtime_nsec
 -	* (shifted nanoseconds), and CONFIG_GENERIC_TIME_VSYSCALL_OLD
 -	* users are removed, this can be killed.
 -	*/
 -	remainder = tk->xtime_nsec & ((1ULL << tk->shift) - 1);
 -	tk->xtime_nsec -= remainder;
 -	tk->xtime_nsec += 1ULL << tk->shift;
 -	tk->ntp_error += remainder << tk->ntp_error_shift;
 -	tk->ntp_error -= (1ULL << tk->shift) << tk->ntp_error_shift;
 +	return nsec + get_arch_timeoffset();
  }
 -#else
 -#define old_vsyscall_fixup(tk)
 -#endif
  
  static RAW_NOTIFIER_HEAD(pvclock_gtod_chain);
  
@@@ -269,18 -342,18 +269,23 @@@ static void timekeeping_forward_now(str
  
  	clock = tk->clock;
  	cycle_now = clock->read(clock);
- 	cycle_delta = (cycle_now - clock->cycle_last) & clock->mask;
+ 	delta = clocksource_delta(cycle_now, clock->cycle_last, clock->mask);
  	tk->cycle_last = clock->cycle_last = cycle_now;
  
- 	tk->xtime_nsec += cycle_delta * tk->mult;
+ 	tk->xtime_nsec += delta * tk->mult;
  
  	/* If arch requires, add in get_arch_timeoffset() */
 -	tk->xtime_nsec += (u64)arch_gettimeoffset() << tk->shift;
 +	tk->xtime_nsec += (u64)get_arch_timeoffset() << tk->shift;
  
  	tk_normalize_xtime(tk);
  
++<<<<<<< HEAD
 +	nsec = clocksource_cyc2ns(cycle_delta, clock->mult, clock->shift);
 +	timespec_add_ns(&tk->raw_time, nsec);
++=======
+ 	nsec = clocksource_cyc2ns(delta, clock->mult, clock->shift);
+ 	timespec64_add_ns(&tk->raw_time, nsec);
++>>>>>>> 3a97837784ac (clocksource: Make delta calculation a function)
  }
  
  /**
* Unmerged path kernel/time/timekeeping_internal.h
* Unmerged path kernel/time/clocksource.c
* Unmerged path kernel/time/timekeeping.c
* Unmerged path kernel/time/timekeeping_internal.h
