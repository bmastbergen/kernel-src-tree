mac80211: use secondary channel offset IE also beacons during CSA

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Luciano Coelho <luciano.coelho@intel.com>
commit 84469a45a1bedec9918e94ab2f78c5dc0739e4a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/84469a45.failed

If we are switching from an HT40+ to an HT40- channel (or vice-versa),
we need the secondary channel offset IE to specify what is the
post-CSA offset to be used.  This applies both to beacons and to probe
responses.

In ieee80211_parse_ch_switch_ie() we were ignoring this IE from
beacons and using the *current* HT information IE instead.  This was
causing us to use the same offset as before the switch.

Fix that by using the secondary channel offset IE also for beacons and
don't ever use the pre-switch offset.  Additionally, remove the
"beacon" argument from ieee80211_parse_ch_switch_ie(), since it's not
needed anymore.

	Cc: stable@vger.kernel.org
	Reported-by: Jouni Malinen <j@w1.fi>
	Signed-off-by: Luciano Coelho <luciano.coelho@intel.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 84469a45a1bedec9918e94ab2f78c5dc0739e4a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/ibss.c
#	net/mac80211/ieee80211_i.h
#	net/mac80211/mesh.c
#	net/mac80211/mlme.c
#	net/mac80211/spectmgmt.c
diff --cc net/mac80211/ibss.c
index 3052672e37f7,509bc157ce55..000000000000
--- a/net/mac80211/ibss.c
+++ b/net/mac80211/ibss.c
@@@ -380,10 -644,295 +380,298 @@@ ieee80211_ibss_add_sta(struct ieee80211
  	sta->last_rx = jiffies;
  
  	/* make sure mandatory rates are always added */
 -	sband = local->hw.wiphy->bands[band];
  	sta->sta.supp_rates[band] = supp_rates |
 -			ieee80211_mandatory_rates(sband, scan_width);
 +			ieee80211_mandatory_rates(local, band);
  
++<<<<<<< HEAD
 +	return ieee80211_ibss_finish_sta(sta, auth);
++=======
+ 	return ieee80211_ibss_finish_sta(sta);
+ }
+ 
+ static int ieee80211_sta_active_ibss(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+ 	int active = 0;
+ 	struct sta_info *sta;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	rcu_read_lock();
+ 
+ 	list_for_each_entry_rcu(sta, &local->sta_list, list) {
+ 		if (sta->sdata == sdata &&
+ 		    time_after(sta->last_rx + IEEE80211_IBSS_MERGE_INTERVAL,
+ 			       jiffies)) {
+ 			active++;
+ 			break;
+ 		}
+ 	}
+ 
+ 	rcu_read_unlock();
+ 
+ 	return active;
+ }
+ 
+ static void ieee80211_ibss_disconnect(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct cfg80211_bss *cbss;
+ 	struct beacon_data *presp;
+ 	struct sta_info *sta;
+ 	u16 capability;
+ 
+ 	if (!is_zero_ether_addr(ifibss->bssid)) {
+ 		capability = WLAN_CAPABILITY_IBSS;
+ 
+ 		if (ifibss->privacy)
+ 			capability |= WLAN_CAPABILITY_PRIVACY;
+ 
+ 		cbss = cfg80211_get_bss(local->hw.wiphy, ifibss->chandef.chan,
+ 					ifibss->bssid, ifibss->ssid,
+ 					ifibss->ssid_len, WLAN_CAPABILITY_IBSS |
+ 					WLAN_CAPABILITY_PRIVACY,
+ 					capability);
+ 
+ 		if (cbss) {
+ 			cfg80211_unlink_bss(local->hw.wiphy, cbss);
+ 			cfg80211_put_bss(sdata->local->hw.wiphy, cbss);
+ 		}
+ 	}
+ 
+ 	ifibss->state = IEEE80211_IBSS_MLME_SEARCH;
+ 
+ 	sta_info_flush(sdata);
+ 
+ 	spin_lock_bh(&ifibss->incomplete_lock);
+ 	while (!list_empty(&ifibss->incomplete_stations)) {
+ 		sta = list_first_entry(&ifibss->incomplete_stations,
+ 				       struct sta_info, list);
+ 		list_del(&sta->list);
+ 		spin_unlock_bh(&ifibss->incomplete_lock);
+ 
+ 		sta_info_free(local, sta);
+ 		spin_lock_bh(&ifibss->incomplete_lock);
+ 	}
+ 	spin_unlock_bh(&ifibss->incomplete_lock);
+ 
+ 	netif_carrier_off(sdata->dev);
+ 
+ 	sdata->vif.bss_conf.ibss_joined = false;
+ 	sdata->vif.bss_conf.ibss_creator = false;
+ 	sdata->vif.bss_conf.enable_beacon = false;
+ 	sdata->vif.bss_conf.ssid_len = 0;
+ 
+ 	/* remove beacon */
+ 	presp = rcu_dereference_protected(ifibss->presp,
+ 					  lockdep_is_held(&sdata->wdev.mtx));
+ 	RCU_INIT_POINTER(sdata->u.ibss.presp, NULL);
+ 	if (presp)
+ 		kfree_rcu(presp, rcu_head);
+ 
+ 	clear_bit(SDATA_STATE_OFFCHANNEL_BEACON_STOPPED, &sdata->state);
+ 	ieee80211_bss_info_change_notify(sdata, BSS_CHANGED_BEACON_ENABLED |
+ 						BSS_CHANGED_IBSS);
+ 	drv_leave_ibss(local, sdata);
+ 	mutex_lock(&local->mtx);
+ 	ieee80211_vif_release_channel(sdata);
+ 	mutex_unlock(&local->mtx);
+ }
+ 
+ static void ieee80211_csa_connection_drop_work(struct work_struct *work)
+ {
+ 	struct ieee80211_sub_if_data *sdata =
+ 		container_of(work, struct ieee80211_sub_if_data,
+ 			     u.ibss.csa_connection_drop_work);
+ 
+ 	sdata_lock(sdata);
+ 
+ 	ieee80211_ibss_disconnect(sdata);
+ 	synchronize_rcu();
+ 	skb_queue_purge(&sdata->skb_queue);
+ 
+ 	/* trigger a scan to find another IBSS network to join */
+ 	ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+ 
+ 	sdata_unlock(sdata);
+ }
+ 
+ static void ieee80211_ibss_csa_mark_radar(struct ieee80211_sub_if_data *sdata)
+ {
+ 	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+ 	int err;
+ 
+ 	/* if the current channel is a DFS channel, mark the channel as
+ 	 * unavailable.
+ 	 */
+ 	err = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,
+ 					    &ifibss->chandef,
+ 					    NL80211_IFTYPE_ADHOC);
+ 	if (err > 0)
+ 		cfg80211_radar_event(sdata->local->hw.wiphy, &ifibss->chandef,
+ 				     GFP_ATOMIC);
+ }
+ 
+ static bool
+ ieee80211_ibss_process_chanswitch(struct ieee80211_sub_if_data *sdata,
+ 				  struct ieee802_11_elems *elems,
+ 				  bool beacon)
+ {
+ 	struct cfg80211_csa_settings params;
+ 	struct ieee80211_csa_ie csa_ie;
+ 	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+ 	enum nl80211_channel_type ch_type;
+ 	int err;
+ 	u32 sta_flags;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	sta_flags = IEEE80211_STA_DISABLE_VHT;
+ 	switch (ifibss->chandef.width) {
+ 	case NL80211_CHAN_WIDTH_5:
+ 	case NL80211_CHAN_WIDTH_10:
+ 	case NL80211_CHAN_WIDTH_20_NOHT:
+ 		sta_flags |= IEEE80211_STA_DISABLE_HT;
+ 		/* fall through */
+ 	case NL80211_CHAN_WIDTH_20:
+ 		sta_flags |= IEEE80211_STA_DISABLE_40MHZ;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	memset(&params, 0, sizeof(params));
+ 	memset(&csa_ie, 0, sizeof(csa_ie));
+ 	err = ieee80211_parse_ch_switch_ie(sdata, elems,
+ 					   ifibss->chandef.chan->band,
+ 					   sta_flags, ifibss->bssid, &csa_ie);
+ 	/* can't switch to destination channel, fail */
+ 	if (err < 0)
+ 		goto disconnect;
+ 
+ 	/* did not contain a CSA */
+ 	if (err)
+ 		return false;
+ 
+ 	/* channel switch is not supported, disconnect */
+ 	if (!(sdata->local->hw.wiphy->flags & WIPHY_FLAG_HAS_CHANNEL_SWITCH))
+ 		goto disconnect;
+ 
+ 	params.count = csa_ie.count;
+ 	params.chandef = csa_ie.chandef;
+ 
+ 	switch (ifibss->chandef.width) {
+ 	case NL80211_CHAN_WIDTH_20_NOHT:
+ 	case NL80211_CHAN_WIDTH_20:
+ 	case NL80211_CHAN_WIDTH_40:
+ 		/* keep our current HT mode (HT20/HT40+/HT40-), even if
+ 		 * another mode  has been announced. The mode is not adopted
+ 		 * within the beacon while doing CSA and we should therefore
+ 		 * keep the mode which we announce.
+ 		 */
+ 		ch_type = cfg80211_get_chandef_type(&ifibss->chandef);
+ 		cfg80211_chandef_create(&params.chandef, params.chandef.chan,
+ 					ch_type);
+ 		break;
+ 	case NL80211_CHAN_WIDTH_5:
+ 	case NL80211_CHAN_WIDTH_10:
+ 		if (params.chandef.width != ifibss->chandef.width) {
+ 			sdata_info(sdata,
+ 				   "IBSS %pM received channel switch from incompatible channel width (%d MHz, width:%d, CF1/2: %d/%d MHz), disconnecting\n",
+ 				   ifibss->bssid,
+ 				   params.chandef.chan->center_freq,
+ 				   params.chandef.width,
+ 				   params.chandef.center_freq1,
+ 				   params.chandef.center_freq2);
+ 			goto disconnect;
+ 		}
+ 		break;
+ 	default:
+ 		/* should not happen, sta_flags should prevent VHT modes. */
+ 		WARN_ON(1);
+ 		goto disconnect;
+ 	}
+ 
+ 	if (!cfg80211_reg_can_beacon(sdata->local->hw.wiphy, &params.chandef,
+ 				     NL80211_IFTYPE_ADHOC)) {
+ 		sdata_info(sdata,
+ 			   "IBSS %pM switches to unsupported channel (%d MHz, width:%d, CF1/2: %d/%d MHz), disconnecting\n",
+ 			   ifibss->bssid,
+ 			   params.chandef.chan->center_freq,
+ 			   params.chandef.width,
+ 			   params.chandef.center_freq1,
+ 			   params.chandef.center_freq2);
+ 		goto disconnect;
+ 	}
+ 
+ 	err = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,
+ 					    &params.chandef,
+ 					    NL80211_IFTYPE_ADHOC);
+ 	if (err < 0)
+ 		goto disconnect;
+ 	if (err > 0 && !ifibss->userspace_handles_dfs) {
+ 		/* IBSS-DFS only allowed with a control program */
+ 		goto disconnect;
+ 	}
+ 
+ 	params.radar_required = err;
+ 
+ 	if (cfg80211_chandef_identical(&params.chandef,
+ 				       &sdata->vif.bss_conf.chandef)) {
+ 		ibss_dbg(sdata,
+ 			 "received csa with an identical chandef, ignoring\n");
+ 		return true;
+ 	}
+ 
+ 	/* all checks done, now perform the channel switch. */
+ 	ibss_dbg(sdata,
+ 		 "received channel switch announcement to go to channel %d MHz\n",
+ 		 params.chandef.chan->center_freq);
+ 
+ 	params.block_tx = !!csa_ie.mode;
+ 
+ 	if (ieee80211_channel_switch(sdata->local->hw.wiphy, sdata->dev,
+ 				     &params))
+ 		goto disconnect;
+ 
+ 	ieee80211_ibss_csa_mark_radar(sdata);
+ 
+ 	return true;
+ disconnect:
+ 	ibss_dbg(sdata, "Can't handle channel switch, disconnect\n");
+ 	ieee80211_queue_work(&sdata->local->hw,
+ 			     &ifibss->csa_connection_drop_work);
+ 
+ 	ieee80211_ibss_csa_mark_radar(sdata);
+ 
+ 	return true;
+ }
+ 
+ static void
+ ieee80211_rx_mgmt_spectrum_mgmt(struct ieee80211_sub_if_data *sdata,
+ 				struct ieee80211_mgmt *mgmt, size_t len,
+ 				struct ieee80211_rx_status *rx_status,
+ 				struct ieee802_11_elems *elems)
+ {
+ 	int required_len;
+ 
+ 	if (len < IEEE80211_MIN_ACTION_SIZE + 1)
+ 		return;
+ 
+ 	/* CSA is the only action we handle for now */
+ 	if (mgmt->u.action.u.measurement.action_code !=
+ 	    WLAN_ACTION_SPCT_CHL_SWITCH)
+ 		return;
+ 
+ 	required_len = IEEE80211_MIN_ACTION_SIZE +
+ 		       sizeof(mgmt->u.action.u.chan_switch);
+ 	if (len < required_len)
+ 		return;
+ 
+ 	if (!sdata->vif.csa_active)
+ 		ieee80211_ibss_process_chanswitch(sdata, elems, false);
++>>>>>>> 84469a45a1be (mac80211: use secondary channel offset IE also beacons during CSA)
  }
  
  static void ieee80211_rx_mgmt_deauth_ibss(struct ieee80211_sub_if_data *sdata,
diff --cc net/mac80211/ieee80211_i.h
index 92ef04c72c51,8c68da30595d..000000000000
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@@ -1428,6 -1638,27 +1428,30 @@@ void ieee80211_apply_vhtcap_overrides(s
  void ieee80211_process_measurement_req(struct ieee80211_sub_if_data *sdata,
  				       struct ieee80211_mgmt *mgmt,
  				       size_t len);
++<<<<<<< HEAD
++=======
+ /**
+  * ieee80211_parse_ch_switch_ie - parses channel switch IEs
+  * @sdata: the sdata of the interface which has received the frame
+  * @elems: parsed 802.11 elements received with the frame
+  * @current_band: indicates the current band
+  * @sta_flags: contains information about own capabilities and restrictions
+  *	to decide which channel switch announcements can be accepted. Only the
+  *	following subset of &enum ieee80211_sta_flags are evaluated:
+  *	%IEEE80211_STA_DISABLE_HT, %IEEE80211_STA_DISABLE_VHT,
+  *	%IEEE80211_STA_DISABLE_40MHZ, %IEEE80211_STA_DISABLE_80P80MHZ,
+  *	%IEEE80211_STA_DISABLE_160MHZ.
+  * @bssid: the currently connected bssid (for reporting)
+  * @csa_ie: parsed 802.11 csa elements on count, mode, chandef and mesh ttl.
+ 	All of them will be filled with if success only.
+  * Return: 0 on success, <0 on error and >0 if there is nothing to parse.
+  */
+ int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,
+ 				 struct ieee802_11_elems *elems,
+ 				 enum ieee80211_band current_band,
+ 				 u32 sta_flags, u8 *bssid,
+ 				 struct ieee80211_csa_ie *csa_ie);
++>>>>>>> 84469a45a1be (mac80211: use secondary channel offset IE also beacons during CSA)
  
  /* Suspend/resume and hw reconfiguration */
  int ieee80211_reconfig(struct ieee80211_local *local);
diff --cc net/mac80211/mesh.c
index 6952760881c8,0c8b2a77d312..000000000000
--- a/net/mac80211/mesh.c
+++ b/net/mac80211/mesh.c
@@@ -820,6 -848,97 +820,100 @@@ void ieee80211_stop_mesh(struct ieee802
  	ieee80211_configure_filter(local);
  }
  
++<<<<<<< HEAD
++=======
+ static bool
+ ieee80211_mesh_process_chnswitch(struct ieee80211_sub_if_data *sdata,
+ 				 struct ieee802_11_elems *elems, bool beacon)
+ {
+ 	struct cfg80211_csa_settings params;
+ 	struct ieee80211_csa_ie csa_ie;
+ 	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+ 	enum ieee80211_band band = ieee80211_get_sdata_band(sdata);
+ 	int err;
+ 	u32 sta_flags;
+ 
+ 	sdata_assert_lock(sdata);
+ 
+ 	sta_flags = IEEE80211_STA_DISABLE_VHT;
+ 	switch (sdata->vif.bss_conf.chandef.width) {
+ 	case NL80211_CHAN_WIDTH_20_NOHT:
+ 		sta_flags |= IEEE80211_STA_DISABLE_HT;
+ 	case NL80211_CHAN_WIDTH_20:
+ 		sta_flags |= IEEE80211_STA_DISABLE_40MHZ;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	memset(&params, 0, sizeof(params));
+ 	memset(&csa_ie, 0, sizeof(csa_ie));
+ 	err = ieee80211_parse_ch_switch_ie(sdata, elems, band,
+ 					   sta_flags, sdata->vif.addr,
+ 					   &csa_ie);
+ 	if (err < 0)
+ 		return false;
+ 	if (err)
+ 		return false;
+ 
+ 	params.chandef = csa_ie.chandef;
+ 	params.count = csa_ie.count;
+ 
+ 	if (!cfg80211_chandef_usable(sdata->local->hw.wiphy, &params.chandef,
+ 				     IEEE80211_CHAN_DISABLED)) {
+ 		sdata_info(sdata,
+ 			   "mesh STA %pM switches to unsupported channel (%d MHz, width:%d, CF1/2: %d/%d MHz), aborting\n",
+ 			   sdata->vif.addr,
+ 			   params.chandef.chan->center_freq,
+ 			   params.chandef.width,
+ 			   params.chandef.center_freq1,
+ 			   params.chandef.center_freq2);
+ 		return false;
+ 	}
+ 
+ 	err = cfg80211_chandef_dfs_required(sdata->local->hw.wiphy,
+ 					    &params.chandef,
+ 					    NL80211_IFTYPE_MESH_POINT);
+ 	if (err < 0)
+ 		return false;
+ 	if (err > 0)
+ 		/* TODO: DFS not (yet) supported */
+ 		return false;
+ 
+ 	params.radar_required = err;
+ 
+ 	if (cfg80211_chandef_identical(&params.chandef,
+ 				       &sdata->vif.bss_conf.chandef)) {
+ 		mcsa_dbg(sdata,
+ 			 "received csa with an identical chandef, ignoring\n");
+ 		return true;
+ 	}
+ 
+ 	mcsa_dbg(sdata,
+ 		 "received channel switch announcement to go to channel %d MHz\n",
+ 		 params.chandef.chan->center_freq);
+ 
+ 	params.block_tx = csa_ie.mode & WLAN_EID_CHAN_SWITCH_PARAM_TX_RESTRICT;
+ 	if (beacon) {
+ 		ifmsh->chsw_ttl = csa_ie.ttl - 1;
+ 		if (ifmsh->pre_value >= csa_ie.pre_value)
+ 			return false;
+ 		ifmsh->pre_value = csa_ie.pre_value;
+ 	}
+ 
+ 	if (ifmsh->chsw_ttl >= ifmsh->mshcfg.dot11MeshTTL)
+ 		return false;
+ 
+ 	ifmsh->csa_role = IEEE80211_MESH_CSA_ROLE_REPEATER;
+ 
+ 	if (ieee80211_channel_switch(sdata->local->hw.wiphy, sdata->dev,
+ 				     &params) < 0)
+ 		return false;
+ 
+ 	return true;
+ }
+ 
++>>>>>>> 84469a45a1be (mac80211: use secondary channel offset IE also beacons during CSA)
  static void
  ieee80211_mesh_rx_probe_req(struct ieee80211_sub_if_data *sdata,
  			    struct ieee80211_mgmt *mgmt, size_t len)
diff --cc net/mac80211/mlme.c
index b7830baa1cd5,08f51c6d0953..000000000000
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@@ -1056,152 -1067,21 +1056,161 @@@ ieee80211_sta_process_chanswitch(struc
  		return;
  
  	/* disregard subsequent announcements if we are already processing */
 -	if (sdata->vif.csa_active)
 +	if (ifmgd->flags & IEEE80211_STA_CSA_RECEIVED)
 +		return;
 +
++<<<<<<< HEAD
 +	sec_chan_offs = elems->sec_chan_offs;
 +	wide_bw_chansw_ie = elems->wide_bw_chansw_ie;
 +	ht_oper = elems->ht_operation;
 +
 +	if (ifmgd->flags & (IEEE80211_STA_DISABLE_HT |
 +			    IEEE80211_STA_DISABLE_40MHZ)) {
 +		sec_chan_offs = NULL;
 +		wide_bw_chansw_ie = NULL;
 +		/* only used for bandwidth here */
 +		ht_oper = NULL;
 +	}
 +
 +	if (ifmgd->flags & IEEE80211_STA_DISABLE_VHT)
 +		wide_bw_chansw_ie = NULL;
 +
 +	if (elems->ext_chansw_ie) {
 +		if (!ieee80211_operating_class_to_band(
 +				elems->ext_chansw_ie->new_operating_class,
 +				&new_band)) {
 +			sdata_info(sdata,
 +				   "cannot understand ECSA IE operating class %d, disconnecting\n",
 +				   elems->ext_chansw_ie->new_operating_class);
 +			ieee80211_queue_work(&local->hw,
 +					     &ifmgd->csa_connection_drop_work);
 +		}
 +		new_chan_no = elems->ext_chansw_ie->new_ch_num;
 +		count = elems->ext_chansw_ie->count;
 +		mode = elems->ext_chansw_ie->mode;
 +	} else if (elems->ch_switch_ie) {
 +		new_band = cbss->channel->band;
 +		new_chan_no = elems->ch_switch_ie->new_ch_num;
 +		count = elems->ch_switch_ie->count;
 +		mode = elems->ch_switch_ie->mode;
 +	} else {
 +		/* nothing here we understand */
  		return;
 +	}
 +
 +	bss = (void *)cbss->priv;
  
 +	new_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);
 +	new_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);
 +	if (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {
 +		sdata_info(sdata,
 +			   "AP %pM switches to unsupported channel (%d MHz), disconnecting\n",
 +			   ifmgd->associated->bssid, new_freq);
++=======
+ 	current_band = cbss->channel->band;
+ 	memset(&csa_ie, 0, sizeof(csa_ie));
+ 	res = ieee80211_parse_ch_switch_ie(sdata, elems, current_band,
+ 					   ifmgd->flags,
+ 					   ifmgd->associated->bssid, &csa_ie);
+ 	if (res	< 0)
++>>>>>>> 84469a45a1be (mac80211: use secondary channel offset IE also beacons during CSA)
  		ieee80211_queue_work(&local->hw,
  				     &ifmgd->csa_connection_drop_work);
 -	if (res)
  		return;
 +	}
 +
 +	if (!beacon && sec_chan_offs) {
 +		secondary_channel_offset = sec_chan_offs->sec_chan_offs;
 +	} else if (beacon && ht_oper) {
 +		secondary_channel_offset =
 +			ht_oper->ht_param & IEEE80211_HT_PARAM_CHA_SEC_OFFSET;
 +	} else if (!(ifmgd->flags & IEEE80211_STA_DISABLE_HT)) {
 +		/*
 +		 * If it's not a beacon, HT is enabled and the IE not present,
 +		 * it's 20 MHz, 802.11-2012 8.5.2.6:
 +		 *	This element [the Secondary Channel Offset Element] is
 +		 *	present when switching to a 40 MHz channel. It may be
 +		 *	present when switching to a 20 MHz channel (in which
 +		 *	case the secondary channel offset is set to SCN).
 +		 */
 +		secondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;
 +	}
 +
 +	switch (secondary_channel_offset) {
 +	default:
 +		/* secondary_channel_offset was present but is invalid */
 +	case IEEE80211_HT_PARAM_CHA_SEC_NONE:
 +		cfg80211_chandef_create(&new_chandef, new_chan,
 +					NL80211_CHAN_HT20);
 +		break;
 +	case IEEE80211_HT_PARAM_CHA_SEC_ABOVE:
 +		cfg80211_chandef_create(&new_chandef, new_chan,
 +					NL80211_CHAN_HT40PLUS);
 +		break;
 +	case IEEE80211_HT_PARAM_CHA_SEC_BELOW:
 +		cfg80211_chandef_create(&new_chandef, new_chan,
 +					NL80211_CHAN_HT40MINUS);
 +		break;
 +	case -1:
 +		cfg80211_chandef_create(&new_chandef, new_chan,
 +					NL80211_CHAN_NO_HT);
 +		break;
 +	}
 +
 +	if (wide_bw_chansw_ie) {
 +		new_vht_chandef.chan = new_chan;
 +		new_vht_chandef.center_freq1 =
 +			ieee80211_channel_to_frequency(
 +				wide_bw_chansw_ie->new_center_freq_seg0,
 +				new_band);
 +
 +		switch (wide_bw_chansw_ie->new_channel_width) {
 +		default:
 +			/* hmmm, ignore VHT and use HT if present */
 +		case IEEE80211_VHT_CHANWIDTH_USE_HT:
 +			new_vht_chandef.chan = NULL;
 +			break;
 +		case IEEE80211_VHT_CHANWIDTH_80MHZ:
 +			new_vht_chandef.width = NL80211_CHAN_WIDTH_80;
 +			break;
 +		case IEEE80211_VHT_CHANWIDTH_160MHZ:
 +			new_vht_chandef.width = NL80211_CHAN_WIDTH_160;
 +			break;
 +		case IEEE80211_VHT_CHANWIDTH_80P80MHZ:
 +			/* field is otherwise reserved */
 +			new_vht_chandef.center_freq2 =
 +				ieee80211_channel_to_frequency(
 +					wide_bw_chansw_ie->new_center_freq_seg1,
 +					new_band);
 +			new_vht_chandef.width = NL80211_CHAN_WIDTH_80P80;
 +			break;
 +		}
 +		if (ifmgd->flags & IEEE80211_STA_DISABLE_80P80MHZ &&
 +		    new_vht_chandef.width == NL80211_CHAN_WIDTH_80P80)
 +			chandef_downgrade(&new_vht_chandef);
 +		if (ifmgd->flags & IEEE80211_STA_DISABLE_160MHZ &&
 +		    new_vht_chandef.width == NL80211_CHAN_WIDTH_160)
 +			chandef_downgrade(&new_vht_chandef);
 +		if (ifmgd->flags & IEEE80211_STA_DISABLE_40MHZ &&
 +		    new_vht_chandef.width > NL80211_CHAN_WIDTH_20)
 +			chandef_downgrade(&new_vht_chandef);
 +	}
 +
 +	/* if VHT data is there validate & use it */
 +	if (new_vht_chandef.chan) {
 +		if (!cfg80211_chandef_compatible(&new_vht_chandef,
 +						 &new_chandef)) {
 +			sdata_info(sdata,
 +				   "AP %pM CSA has inconsistent channel data, disconnecting\n",
 +				   ifmgd->associated->bssid);
 +			ieee80211_queue_work(&local->hw,
 +					     &ifmgd->csa_connection_drop_work);
 +			return;
 +		}
 +		new_chandef = new_vht_chandef;
 +	}
  
 -	if (!cfg80211_chandef_usable(local->hw.wiphy, &csa_ie.chandef,
 +	if (!cfg80211_chandef_usable(local->hw.wiphy, &new_chandef,
  				     IEEE80211_CHAN_DISABLED)) {
  		sdata_info(sdata,
  			   "AP %pM switches to unsupported channel (%d MHz, width:%d, CF1/2: %d/%d MHz), disconnecting\n",
diff --cc net/mac80211/spectmgmt.c
index 578eea3fc04d,efeba56c913b..000000000000
--- a/net/mac80211/spectmgmt.c
+++ b/net/mac80211/spectmgmt.c
@@@ -21,6 -21,171 +21,174 @@@
  #include "sta_info.h"
  #include "wme.h"
  
++<<<<<<< HEAD
++=======
+ int ieee80211_parse_ch_switch_ie(struct ieee80211_sub_if_data *sdata,
+ 				 struct ieee802_11_elems *elems,
+ 				 enum ieee80211_band current_band,
+ 				 u32 sta_flags, u8 *bssid,
+ 				 struct ieee80211_csa_ie *csa_ie)
+ {
+ 	enum ieee80211_band new_band;
+ 	int new_freq;
+ 	u8 new_chan_no;
+ 	struct ieee80211_channel *new_chan;
+ 	struct cfg80211_chan_def new_vht_chandef = {};
+ 	const struct ieee80211_sec_chan_offs_ie *sec_chan_offs;
+ 	const struct ieee80211_wide_bw_chansw_ie *wide_bw_chansw_ie;
+ 	const struct ieee80211_ht_operation *ht_oper;
+ 	int secondary_channel_offset = -1;
+ 
+ 	sec_chan_offs = elems->sec_chan_offs;
+ 	wide_bw_chansw_ie = elems->wide_bw_chansw_ie;
+ 	ht_oper = elems->ht_operation;
+ 
+ 	if (sta_flags & (IEEE80211_STA_DISABLE_HT |
+ 			 IEEE80211_STA_DISABLE_40MHZ)) {
+ 		sec_chan_offs = NULL;
+ 		wide_bw_chansw_ie = NULL;
+ 		/* only used for bandwidth here */
+ 		ht_oper = NULL;
+ 	}
+ 
+ 	if (sta_flags & IEEE80211_STA_DISABLE_VHT)
+ 		wide_bw_chansw_ie = NULL;
+ 
+ 	if (elems->ext_chansw_ie) {
+ 		if (!ieee80211_operating_class_to_band(
+ 				elems->ext_chansw_ie->new_operating_class,
+ 				&new_band)) {
+ 			sdata_info(sdata,
+ 				   "cannot understand ECSA IE operating class %d, disconnecting\n",
+ 				   elems->ext_chansw_ie->new_operating_class);
+ 			return -EINVAL;
+ 		}
+ 		new_chan_no = elems->ext_chansw_ie->new_ch_num;
+ 		csa_ie->count = elems->ext_chansw_ie->count;
+ 		csa_ie->mode = elems->ext_chansw_ie->mode;
+ 	} else if (elems->ch_switch_ie) {
+ 		new_band = current_band;
+ 		new_chan_no = elems->ch_switch_ie->new_ch_num;
+ 		csa_ie->count = elems->ch_switch_ie->count;
+ 		csa_ie->mode = elems->ch_switch_ie->mode;
+ 	} else {
+ 		/* nothing here we understand */
+ 		return 1;
+ 	}
+ 
+ 	/* Mesh Channel Switch Parameters Element */
+ 	if (elems->mesh_chansw_params_ie) {
+ 		csa_ie->ttl = elems->mesh_chansw_params_ie->mesh_ttl;
+ 		csa_ie->mode = elems->mesh_chansw_params_ie->mesh_flags;
+ 		csa_ie->pre_value = le16_to_cpu(
+ 				elems->mesh_chansw_params_ie->mesh_pre_value);
+ 	}
+ 
+ 	new_freq = ieee80211_channel_to_frequency(new_chan_no, new_band);
+ 	new_chan = ieee80211_get_channel(sdata->local->hw.wiphy, new_freq);
+ 	if (!new_chan || new_chan->flags & IEEE80211_CHAN_DISABLED) {
+ 		sdata_info(sdata,
+ 			   "BSS %pM switches to unsupported channel (%d MHz), disconnecting\n",
+ 			   bssid, new_freq);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (sec_chan_offs) {
+ 		secondary_channel_offset = sec_chan_offs->sec_chan_offs;
+ 	} else if (!(sta_flags & IEEE80211_STA_DISABLE_HT)) {
+ 		/* If the secondary channel offset IE is not present,
+ 		 * we can't know what's the post-CSA offset, so the
+ 		 * best we can do is use 20MHz.
+ 		*/
+ 		secondary_channel_offset = IEEE80211_HT_PARAM_CHA_SEC_NONE;
+ 	}
+ 
+ 	switch (secondary_channel_offset) {
+ 	default:
+ 		/* secondary_channel_offset was present but is invalid */
+ 	case IEEE80211_HT_PARAM_CHA_SEC_NONE:
+ 		cfg80211_chandef_create(&csa_ie->chandef, new_chan,
+ 					NL80211_CHAN_HT20);
+ 		break;
+ 	case IEEE80211_HT_PARAM_CHA_SEC_ABOVE:
+ 		cfg80211_chandef_create(&csa_ie->chandef, new_chan,
+ 					NL80211_CHAN_HT40PLUS);
+ 		break;
+ 	case IEEE80211_HT_PARAM_CHA_SEC_BELOW:
+ 		cfg80211_chandef_create(&csa_ie->chandef, new_chan,
+ 					NL80211_CHAN_HT40MINUS);
+ 		break;
+ 	case -1:
+ 		cfg80211_chandef_create(&csa_ie->chandef, new_chan,
+ 					NL80211_CHAN_NO_HT);
+ 		/* keep width for 5/10 MHz channels */
+ 		switch (sdata->vif.bss_conf.chandef.width) {
+ 		case NL80211_CHAN_WIDTH_5:
+ 		case NL80211_CHAN_WIDTH_10:
+ 			csa_ie->chandef.width =
+ 				sdata->vif.bss_conf.chandef.width;
+ 			break;
+ 		default:
+ 			break;
+ 		}
+ 		break;
+ 	}
+ 
+ 	if (wide_bw_chansw_ie) {
+ 		new_vht_chandef.chan = new_chan;
+ 		new_vht_chandef.center_freq1 =
+ 			ieee80211_channel_to_frequency(
+ 				wide_bw_chansw_ie->new_center_freq_seg0,
+ 				new_band);
+ 
+ 		switch (wide_bw_chansw_ie->new_channel_width) {
+ 		default:
+ 			/* hmmm, ignore VHT and use HT if present */
+ 		case IEEE80211_VHT_CHANWIDTH_USE_HT:
+ 			new_vht_chandef.chan = NULL;
+ 			break;
+ 		case IEEE80211_VHT_CHANWIDTH_80MHZ:
+ 			new_vht_chandef.width = NL80211_CHAN_WIDTH_80;
+ 			break;
+ 		case IEEE80211_VHT_CHANWIDTH_160MHZ:
+ 			new_vht_chandef.width = NL80211_CHAN_WIDTH_160;
+ 			break;
+ 		case IEEE80211_VHT_CHANWIDTH_80P80MHZ:
+ 			/* field is otherwise reserved */
+ 			new_vht_chandef.center_freq2 =
+ 				ieee80211_channel_to_frequency(
+ 					wide_bw_chansw_ie->new_center_freq_seg1,
+ 					new_band);
+ 			new_vht_chandef.width = NL80211_CHAN_WIDTH_80P80;
+ 			break;
+ 		}
+ 		if (sta_flags & IEEE80211_STA_DISABLE_80P80MHZ &&
+ 		    new_vht_chandef.width == NL80211_CHAN_WIDTH_80P80)
+ 			ieee80211_chandef_downgrade(&new_vht_chandef);
+ 		if (sta_flags & IEEE80211_STA_DISABLE_160MHZ &&
+ 		    new_vht_chandef.width == NL80211_CHAN_WIDTH_160)
+ 			ieee80211_chandef_downgrade(&new_vht_chandef);
+ 		if (sta_flags & IEEE80211_STA_DISABLE_40MHZ &&
+ 		    new_vht_chandef.width > NL80211_CHAN_WIDTH_20)
+ 			ieee80211_chandef_downgrade(&new_vht_chandef);
+ 	}
+ 
+ 	/* if VHT data is there validate & use it */
+ 	if (new_vht_chandef.chan) {
+ 		if (!cfg80211_chandef_compatible(&new_vht_chandef,
+ 						 &csa_ie->chandef)) {
+ 			sdata_info(sdata,
+ 				   "BSS %pM: CSA has inconsistent channel data, disconnecting\n",
+ 				   bssid);
+ 			return -EINVAL;
+ 		}
+ 		csa_ie->chandef = new_vht_chandef;
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 84469a45a1be (mac80211: use secondary channel offset IE also beacons during CSA)
  static void ieee80211_send_refuse_measurement_request(struct ieee80211_sub_if_data *sdata,
  					struct ieee80211_msrment_ie *request_ie,
  					const u8 *da, const u8 *bssid,
* Unmerged path net/mac80211/ibss.c
* Unmerged path net/mac80211/ieee80211_i.h
* Unmerged path net/mac80211/mesh.c
* Unmerged path net/mac80211/mlme.c
* Unmerged path net/mac80211/spectmgmt.c
