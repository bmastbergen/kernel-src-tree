iommu/vt-d: Include ACPI devices in iommu=pt

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Include ACPI devices in iommu=pt (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 92.68%
commit-author David Woodhouse <David.Woodhouse@intel.com>
commit cf04eee8bf0e842dd73a64d02cdcdcbb31b0102c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/cf04eee8.failed

	Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
(cherry picked from commit cf04eee8bf0e842dd73a64d02cdcdcbb31b0102c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index d725f75f445b,6fbce01b7875..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -2474,21 -2630,31 +2499,47 @@@ static int __init iommu_prepare_static_
  		return -EFAULT;
  
  	for_each_pci_dev(pdev) {
++<<<<<<< HEAD
 +		if (iommu_should_identity_map(pdev, 1)) {
 +			ret = domain_add_dev_info(si_domain, pdev,
 +					     hw ? CONTEXT_TT_PASS_THROUGH :
 +						  CONTEXT_TT_MULTI_LEVEL);
 +			if (ret) {
 +				/* device not associated with an iommu */
 +				if (ret == -ENODEV)
 +					continue;
 +				return ret;
 +			}
 +			pr_info("IOMMU: %s identity mapping for device %s\n",
 +				hw ? "hardware" : "software", pci_name(pdev));
 +		}
++=======
+ 		ret = dev_prepare_static_identity_mapping(&pdev->dev, hw);
+ 		if (ret)
+ 			return ret;
++>>>>>>> cf04eee8bf0e (iommu/vt-d: Include ACPI devices in iommu=pt)
  	}
  
+ 	for_each_active_iommu(iommu, drhd)
+ 		for_each_active_dev_scope(drhd->devices, drhd->devices_cnt, i, dev) {
+ 			struct acpi_device_physical_node *pn;
+ 			struct acpi_device *adev;
+ 
+ 			if (dev->bus != &acpi_bus_type)
+ 				continue;
+ 				
+ 			adev= to_acpi_device(dev);
+ 			mutex_lock(&adev->physical_node_lock);
+ 			list_for_each_entry(pn, &adev->physical_node_list, node) {
+ 				ret = dev_prepare_static_identity_mapping(pn->dev, hw);
+ 				if (ret)
+ 					break;
+ 			}
+ 			mutex_unlock(&adev->physical_node_lock);
+ 			if (ret)
+ 				return ret;
+ 		}
+ 
  	return 0;
  }
  
* Unmerged path drivers/iommu/intel-iommu.c
