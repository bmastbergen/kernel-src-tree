mac80211: Fix regression that triggers a kernel BUG with CCMP

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Ronald Wahl <ronald.wahl@raritan.com>
commit 4f031fa9f188b2b0641ac20087d9e16bcfb4e49d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/4f031fa9.failed

Commit 7ec7c4a9a686c608315739ab6a2b0527a240883c (mac80211: port CCMP to
cryptoapi's CCM driver) introduced a regression when decrypting empty
packets (data_len == 0). This will lead to backtraces like:

(scatterwalk_start) from [<c01312f4>] (scatterwalk_map_and_copy+0x2c/0xa8)
(scatterwalk_map_and_copy) from [<c013a5a0>] (crypto_ccm_decrypt+0x7c/0x25c)
(crypto_ccm_decrypt) from [<c032886c>] (ieee80211_aes_ccm_decrypt+0x160/0x170)
(ieee80211_aes_ccm_decrypt) from [<c031c628>] (ieee80211_crypto_ccmp_decrypt+0x1ac/0x238)
(ieee80211_crypto_ccmp_decrypt) from [<c032ef28>] (ieee80211_rx_handlers+0x870/0x1d24)
(ieee80211_rx_handlers) from [<c0330c7c>] (ieee80211_prepare_and_rx_handle+0x8a0/0x91c)
(ieee80211_prepare_and_rx_handle) from [<c0331260>] (ieee80211_rx+0x568/0x730)
(ieee80211_rx) from [<c01d3054>] (__carl9170_rx+0x94c/0xa20)
(__carl9170_rx) from [<c01d3324>] (carl9170_rx_stream+0x1fc/0x320)
(carl9170_rx_stream) from [<c01cbccc>] (carl9170_usb_tasklet+0x80/0xc8)
(carl9170_usb_tasklet) from [<c00199dc>] (tasklet_hi_action+0x88/0xcc)
(tasklet_hi_action) from [<c00193c8>] (__do_softirq+0xcc/0x200)
(__do_softirq) from [<c0019734>] (irq_exit+0x80/0xe0)
(irq_exit) from [<c0009c10>] (handle_IRQ+0x64/0x80)
(handle_IRQ) from [<c000c3a0>] (__irq_svc+0x40/0x4c)
(__irq_svc) from [<c0009d44>] (arch_cpu_idle+0x2c/0x34)

Such packets can appear for example when using the carl9170 wireless driver
because hardware sometimes generates garbage when the internal FIFO overruns.

This patch adds an additional length check.

	Cc: stable@vger.kernel.org
Fixes: 7ec7c4a9a686 ("mac80211: port CCMP to cryptoapi's CCM driver")
	Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
	Signed-off-by: Ronald Wahl <ronald.wahl@raritan.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit 4f031fa9f188b2b0641ac20087d9e16bcfb4e49d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mac80211/aes_ccm.c
diff --cc net/mac80211/aes_ccm.c
index 0785e95c9924,09d9caaec591..000000000000
--- a/net/mac80211/aes_ccm.c
+++ b/net/mac80211/aes_ccm.c
@@@ -17,134 -19,79 +17,141 @@@
  #include "key.h"
  #include "aes_ccm.h"
  
 -void ieee80211_aes_ccm_encrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
 -			       u8 *data, size_t data_len, u8 *mic)
 +static void aes_ccm_prepare(struct crypto_cipher *tfm, u8 *scratch, u8 *a)
  {
 -	struct scatterlist assoc, pt, ct[2];
 +	int i;
 +	u8 *b_0, *aad, *b, *s_0;
  
 -	char aead_req_data[sizeof(struct aead_request) +
 -			   crypto_aead_reqsize(tfm)]
 -		__aligned(__alignof__(struct aead_request));
 -	struct aead_request *aead_req = (void *) aead_req_data;
 +	b_0 = scratch + 3 * AES_BLOCK_SIZE;
 +	aad = scratch + 4 * AES_BLOCK_SIZE;
 +	b = scratch;
 +	s_0 = scratch + AES_BLOCK_SIZE;
  
 -	memset(aead_req, 0, sizeof(aead_req_data));
 +	crypto_cipher_encrypt_one(tfm, b, b_0);
 +
 +	/* Extra Authenticate-only data (always two AES blocks) */
 +	for (i = 0; i < AES_BLOCK_SIZE; i++)
 +		aad[i] ^= b[i];
 +	crypto_cipher_encrypt_one(tfm, b, aad);
  
 -	sg_init_one(&pt, data, data_len);
 -	sg_init_one(&assoc, &aad[2], be16_to_cpup((__be16 *)aad));
 -	sg_init_table(ct, 2);
 -	sg_set_buf(&ct[0], data, data_len);
 -	sg_set_buf(&ct[1], mic, IEEE80211_CCMP_MIC_LEN);
 +	aad += AES_BLOCK_SIZE;
  
 -	aead_request_set_tfm(aead_req, tfm);
 -	aead_request_set_assoc(aead_req, &assoc, assoc.length);
 -	aead_request_set_crypt(aead_req, &pt, ct, data_len, b_0);
 +	for (i = 0; i < AES_BLOCK_SIZE; i++)
 +		aad[i] ^= b[i];
 +	crypto_cipher_encrypt_one(tfm, a, aad);
  
 -	crypto_aead_encrypt(aead_req);
 +	/* Mask out bits from auth-only-b_0 */
 +	b_0[0] &= 0x07;
 +
 +	/* S_0 is used to encrypt T (= MIC) */
 +	b_0[14] = 0;
 +	b_0[15] = 0;
 +	crypto_cipher_encrypt_one(tfm, s_0, b_0);
  }
  
 -int ieee80211_aes_ccm_decrypt(struct crypto_aead *tfm, u8 *b_0, u8 *aad,
 -			      u8 *data, size_t data_len, u8 *mic)
 -{
 -	struct scatterlist assoc, pt, ct[2];
 -	char aead_req_data[sizeof(struct aead_request) +
 -			   crypto_aead_reqsize(tfm)]
 -		__aligned(__alignof__(struct aead_request));
 -	struct aead_request *aead_req = (void *) aead_req_data;
  
 +void ieee80211_aes_ccm_encrypt(struct crypto_cipher *tfm, u8 *scratch,
 +			       u8 *data, size_t data_len,
 +			       u8 *cdata, u8 *mic)
 +{
 +	int i, j, last_len, num_blocks;
 +	u8 *pos, *cpos, *b, *s_0, *e, *b_0;
 +
++<<<<<<< HEAD
 +	b = scratch;
 +	s_0 = scratch + AES_BLOCK_SIZE;
 +	e = scratch + 2 * AES_BLOCK_SIZE;
 +	b_0 = scratch + 3 * AES_BLOCK_SIZE;
++=======
+ 	if (data_len == 0)
+ 		return -EINVAL;
+ 
+ 	memset(aead_req, 0, sizeof(aead_req_data));
++>>>>>>> 4f031fa9f188 (mac80211: Fix regression that triggers a kernel BUG with CCMP)
 +
 +	num_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);
 +	last_len = data_len % AES_BLOCK_SIZE;
 +	aes_ccm_prepare(tfm, scratch, b);
 +
 +	/* Process payload blocks */
 +	pos = data;
 +	cpos = cdata;
 +	for (j = 1; j <= num_blocks; j++) {
 +		int blen = (j == num_blocks && last_len) ?
 +			last_len : AES_BLOCK_SIZE;
 +
 +		/* Authentication followed by encryption */
 +		for (i = 0; i < blen; i++)
 +			b[i] ^= pos[i];
 +		crypto_cipher_encrypt_one(tfm, b, b);
 +
 +		b_0[14] = (j >> 8) & 0xff;
 +		b_0[15] = j & 0xff;
 +		crypto_cipher_encrypt_one(tfm, e, b_0);
 +		for (i = 0; i < blen; i++)
 +			*cpos++ = *pos++ ^ e[i];
 +	}
 +
 +	for (i = 0; i < CCMP_MIC_LEN; i++)
 +		mic[i] = b[i] ^ s_0[i];
 +}
  
 -	sg_init_one(&pt, data, data_len);
 -	sg_init_one(&assoc, &aad[2], be16_to_cpup((__be16 *)aad));
 -	sg_init_table(ct, 2);
 -	sg_set_buf(&ct[0], data, data_len);
 -	sg_set_buf(&ct[1], mic, IEEE80211_CCMP_MIC_LEN);
 -
 -	aead_request_set_tfm(aead_req, tfm);
 -	aead_request_set_assoc(aead_req, &assoc, assoc.length);
 -	aead_request_set_crypt(aead_req, ct, &pt,
 -			       data_len + IEEE80211_CCMP_MIC_LEN, b_0);
  
 -	return crypto_aead_decrypt(aead_req);
 +int ieee80211_aes_ccm_decrypt(struct crypto_cipher *tfm, u8 *scratch,
 +			      u8 *cdata, size_t data_len, u8 *mic, u8 *data)
 +{
 +	int i, j, last_len, num_blocks;
 +	u8 *pos, *cpos, *b, *s_0, *a, *b_0;
 +
 +	b = scratch;
 +	s_0 = scratch + AES_BLOCK_SIZE;
 +	a = scratch + 2 * AES_BLOCK_SIZE;
 +	b_0 = scratch + 3 * AES_BLOCK_SIZE;
 +
 +	num_blocks = DIV_ROUND_UP(data_len, AES_BLOCK_SIZE);
 +	last_len = data_len % AES_BLOCK_SIZE;
 +	aes_ccm_prepare(tfm, scratch, a);
 +
 +	/* Process payload blocks */
 +	cpos = cdata;
 +	pos = data;
 +	for (j = 1; j <= num_blocks; j++) {
 +		int blen = (j == num_blocks && last_len) ?
 +			last_len : AES_BLOCK_SIZE;
 +
 +		/* Decryption followed by authentication */
 +		b_0[14] = (j >> 8) & 0xff;
 +		b_0[15] = j & 0xff;
 +		crypto_cipher_encrypt_one(tfm, b, b_0);
 +		for (i = 0; i < blen; i++) {
 +			*pos = *cpos++ ^ b[i];
 +			a[i] ^= *pos++;
 +		}
 +		crypto_cipher_encrypt_one(tfm, a, a);
 +	}
 +
 +	for (i = 0; i < CCMP_MIC_LEN; i++) {
 +		if ((mic[i] ^ s_0[i]) != a[i])
 +			return -1;
 +	}
 +
 +	return 0;
  }
  
 -struct crypto_aead *ieee80211_aes_key_setup_encrypt(const u8 key[])
 -{
 -	struct crypto_aead *tfm;
 -	int err;
  
 -	tfm = crypto_alloc_aead("ccm(aes)", 0, CRYPTO_ALG_ASYNC);
 -	if (IS_ERR(tfm))
 -		return tfm;
 +struct crypto_cipher *ieee80211_aes_key_setup_encrypt(const u8 key[])
 +{
 +	struct crypto_cipher *tfm;
  
 -	err = crypto_aead_setkey(tfm, key, WLAN_KEY_LEN_CCMP);
 -	if (!err)
 -		err = crypto_aead_setauthsize(tfm, IEEE80211_CCMP_MIC_LEN);
 -	if (!err)
 -		return tfm;
 +	tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);
 +	if (!IS_ERR(tfm))
 +		crypto_cipher_setkey(tfm, key, ALG_CCMP_KEY_LEN);
  
 -	crypto_free_aead(tfm);
 -	return ERR_PTR(err);
 +	return tfm;
  }
  
 -void ieee80211_aes_key_free(struct crypto_aead *tfm)
 +
 +void ieee80211_aes_key_free(struct crypto_cipher *tfm)
  {
 -	crypto_free_aead(tfm);
 +	crypto_free_cipher(tfm);
  }
* Unmerged path net/mac80211/aes_ccm.c
