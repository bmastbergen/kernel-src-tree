i40e: Add a FD flush counter to ethtool

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Anjali Singhai Jain <anjali.singhai@intel.com>
commit 60793f4ab541f9c279f823e42dc8053341cc7547
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/60793f4a.failed

This helps know how many times the interface had to flush and replay FD
filter table, which gives an indication on how often we are getting FD
table full situation.

Also check on certain pf states before proceeding to add or delete
filters since we can't add or delete filters if we are in those states.

Change-ID: I97f5bbbea7146833ea61af0e08ea794fccba1780
	Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
	Tested-by: Jim Young <jamesx.m.young@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 60793f4ab541f9c279f823e42dc8053341cc7547)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/i40e/i40e.h
#	drivers/net/ethernet/intel/i40e/i40e_ethtool.c
#	drivers/net/ethernet/intel/i40e/i40e_main.c
diff --cc drivers/net/ethernet/intel/i40e/i40e.h
index 11439c769886,85269509f420..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@@ -227,6 -249,13 +227,16 @@@ struct i40e_pf 
  
  	struct hlist_head fdir_filter_list;
  	u16 fdir_pf_active_filters;
++<<<<<<< HEAD
++=======
+ 	u16 fd_sb_cnt_idx;
+ 	u16 fd_atr_cnt_idx;
+ 	unsigned long fd_flush_timestamp;
+ 	u32 fd_flush_cnt;
+ 	u32 fd_add_err;
+ 	u32 fd_atr_cnt;
+ 	u32 fd_tcp_rule;
++>>>>>>> 60793f4ab541 (i40e: Add a FD flush counter to ethtool)
  
  #ifdef CONFIG_I40E_VXLAN
  	__be16  vxlan_ports[I40E_MAX_PF_UDP_OFFLOAD_PORTS];
diff --cc drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index 481e300435f7,571d527e7920..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@@ -139,8 -145,30 +139,20 @@@ static struct i40e_stats i40e_gstrings_
  	I40E_PF_STAT("rx_jabber", stats.rx_jabber),
  	I40E_PF_STAT("VF_admin_queue_requests", vf_aq_requests),
  	I40E_PF_STAT("rx_hwtstamp_cleared", rx_hwtstamp_cleared),
++<<<<<<< HEAD
++=======
+ 	I40E_PF_STAT("fdir_flush_cnt", fd_flush_cnt),
+ 	I40E_PF_STAT("fdir_atr_match", stats.fd_atr_match),
+ 	I40E_PF_STAT("fdir_sb_match", stats.fd_sb_match),
+ 
+ 	/* LPI stats */
+ 	I40E_PF_STAT("tx_lpi_status", stats.tx_lpi_status),
+ 	I40E_PF_STAT("rx_lpi_status", stats.rx_lpi_status),
+ 	I40E_PF_STAT("tx_lpi_count", stats.tx_lpi_count),
+ 	I40E_PF_STAT("rx_lpi_count", stats.rx_lpi_count),
++>>>>>>> 60793f4ab541 (i40e: Add a FD flush counter to ethtool)
  };
  
 -#ifdef I40E_FCOE
 -static const struct i40e_stats i40e_gstrings_fcoe_stats[] = {
 -	I40E_VSI_STAT("fcoe_bad_fccrc", fcoe_stats.fcoe_bad_fccrc),
 -	I40E_VSI_STAT("rx_fcoe_dropped", fcoe_stats.rx_fcoe_dropped),
 -	I40E_VSI_STAT("rx_fcoe_packets", fcoe_stats.rx_fcoe_packets),
 -	I40E_VSI_STAT("rx_fcoe_dwords", fcoe_stats.rx_fcoe_dwords),
 -	I40E_VSI_STAT("fcoe_ddp_count", fcoe_stats.fcoe_ddp_count),
 -	I40E_VSI_STAT("fcoe_last_error", fcoe_stats.fcoe_last_error),
 -	I40E_VSI_STAT("tx_fcoe_packets", fcoe_stats.tx_fcoe_packets),
 -	I40E_VSI_STAT("tx_fcoe_dwords", fcoe_stats.tx_fcoe_dwords),
 -};
 -
 -#endif /* I40E_FCOE */
  #define I40E_QUEUE_STATS_LEN(n) \
  	(((struct i40e_netdev_priv *)netdev_priv((n)))->vsi->num_queue_pairs \
  	    * 2 /* Tx and Rx together */                                     \
@@@ -1871,6 -1978,13 +1883,16 @@@ static int i40e_del_fdir_entry(struct i
  	struct i40e_pf *pf = vsi->back;
  	int ret = 0;
  
++<<<<<<< HEAD
++=======
+ 	if (test_bit(__I40E_RESET_RECOVERY_PENDING, &pf->state) ||
+ 	    test_bit(__I40E_RESET_INTR_RECEIVED, &pf->state))
+ 		return -EBUSY;
+ 
+ 	if (test_bit(__I40E_FD_FLUSH_REQUESTED, &pf->state))
+ 		return -EBUSY;
+ 
++>>>>>>> 60793f4ab541 (i40e: Add a FD flush counter to ethtool)
  	ret = i40e_update_ethtool_fdir_entry(vsi, NULL, fsp->location, cmd);
  
  	i40e_fdir_check_and_reenable(pf);
@@@ -1904,6 -2018,13 +1926,16 @@@ static int i40e_add_fdir_ethtool(struc
  	if (pf->auto_disable_flags & I40E_FLAG_FD_SB_ENABLED)
  		return -ENOSPC;
  
++<<<<<<< HEAD
++=======
+ 	if (test_bit(__I40E_RESET_RECOVERY_PENDING, &pf->state) ||
+ 	    test_bit(__I40E_RESET_INTR_RECEIVED, &pf->state))
+ 		return -EBUSY;
+ 
+ 	if (test_bit(__I40E_FD_FLUSH_REQUESTED, &pf->state))
+ 		return -EBUSY;
+ 
++>>>>>>> 60793f4ab541 (i40e: Add a FD flush counter to ethtool)
  	fsp = (struct ethtool_rx_flow_spec *)&cmd->fs;
  
  	if (fsp->location >= (pf->hw.func_caps.fd_filters_best_effort +
diff --cc drivers/net/ethernet/intel/i40e/i40e_main.c
index 101ffca9c781,712a23b926b3..000000000000
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@@ -4901,6 -5169,66 +4901,69 @@@ void i40e_fdir_check_and_reenable(struc
  	}
  }
  
++<<<<<<< HEAD
++=======
+ #define I40E_MIN_FD_FLUSH_INTERVAL 10
+ /**
+  * i40e_fdir_flush_and_replay - Function to flush all FD filters and replay SB
+  * @pf: board private structure
+  **/
+ static void i40e_fdir_flush_and_replay(struct i40e_pf *pf)
+ {
+ 	int flush_wait_retry = 50;
+ 	int reg;
+ 
+ 	if (time_after(jiffies, pf->fd_flush_timestamp +
+ 				(I40E_MIN_FD_FLUSH_INTERVAL * HZ))) {
+ 		set_bit(__I40E_FD_FLUSH_REQUESTED, &pf->state);
+ 		pf->fd_flush_timestamp = jiffies;
+ 		pf->auto_disable_flags |= I40E_FLAG_FD_SB_ENABLED;
+ 		pf->flags &= ~I40E_FLAG_FD_ATR_ENABLED;
+ 		/* flush all filters */
+ 		wr32(&pf->hw, I40E_PFQF_CTL_1,
+ 		     I40E_PFQF_CTL_1_CLEARFDTABLE_MASK);
+ 		i40e_flush(&pf->hw);
+ 		pf->fd_flush_cnt++;
+ 		pf->fd_add_err = 0;
+ 		do {
+ 			/* Check FD flush status every 5-6msec */
+ 			usleep_range(5000, 6000);
+ 			reg = rd32(&pf->hw, I40E_PFQF_CTL_1);
+ 			if (!(reg & I40E_PFQF_CTL_1_CLEARFDTABLE_MASK))
+ 				break;
+ 		} while (flush_wait_retry--);
+ 		if (reg & I40E_PFQF_CTL_1_CLEARFDTABLE_MASK) {
+ 			dev_warn(&pf->pdev->dev, "FD table did not flush, needs more time\n");
+ 		} else {
+ 			/* replay sideband filters */
+ 			i40e_fdir_filter_restore(pf->vsi[pf->lan_vsi]);
+ 
+ 			pf->flags |= I40E_FLAG_FD_ATR_ENABLED;
+ 			pf->auto_disable_flags &= ~I40E_FLAG_FD_ATR_ENABLED;
+ 			pf->auto_disable_flags &= ~I40E_FLAG_FD_SB_ENABLED;
+ 			clear_bit(__I40E_FD_FLUSH_REQUESTED, &pf->state);
+ 			dev_info(&pf->pdev->dev, "FD Filter table flushed and FD-SB replayed.\n");
+ 		}
+ 	}
+ }
+ 
+ /**
+  * i40e_get_current_atr_count - Get the count of total FD ATR filters programmed
+  * @pf: board private structure
+  **/
+ int i40e_get_current_atr_cnt(struct i40e_pf *pf)
+ {
+ 	return i40e_get_current_fd_count(pf) - pf->fdir_pf_active_filters;
+ }
+ 
+ /* We can see up to 256 filter programming desc in transit if the filters are
+  * being applied really fast; before we see the first
+  * filter miss error on Rx queue 0. Accumulating enough error messages before
+  * reacting will make sure we don't cause flush too often.
+  */
+ #define I40E_MAX_FD_PROGRAM_ERROR 256
+ 
++>>>>>>> 60793f4ab541 (i40e: Add a FD flush counter to ethtool)
  /**
   * i40e_fdir_reinit_subtask - Worker thread to reinit FDIR filter table
   * @pf: board private structure
* Unmerged path drivers/net/ethernet/intel/i40e/i40e.h
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_ethtool.c
* Unmerged path drivers/net/ethernet/intel/i40e/i40e_main.c
