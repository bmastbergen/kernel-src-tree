iscsi/isert-target: Refactor ISCSI_OP_NOOP RX handling

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iscsi] isert-target: Refactor ISCSI_OP_NOOP RX handling (Andy Grover) [1058736]
Rebuild_FUZZ: 94.12%
commit-author Nicholas Bellinger <nab@linux-iscsi.org>
commit 778de368964c5b7e8100cde9f549992d521e9c89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/778de368.failed

This patch refactors ISCSI_OP_NOOP handling within iscsi-target in
order to handle iscsi_nopout payloads in a transport specific manner.

This includes splitting existing iscsit_handle_nop_out() into
iscsit_setup_nop_out() and iscsit_process_nop_out() calls, and
makes iscsit_handle_nop_out() be only used internally by traditional
iscsi socket calls.

Next update iser-target code to use new callers and add FIXME for
the handling iscsi_nopout payloads.  Also fix reject response handling
in iscsit_setup_nop_out() to use proper iscsit_add_reject_from_cmd().

v2: Fix uninitialized iscsit_handle_nop_out() payload_length usage (Fengguang)
v3: Remove left-over dead code in iscsit_setup_nop_out() (DanC)

	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit 778de368964c5b7e8100cde9f549992d521e9c89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/target/iscsi/iscsi_target.c
diff --cc drivers/target/iscsi/iscsi_target.c
index fe777581f025,f684627244bf..000000000000
--- a/drivers/target/iscsi/iscsi_target.c
+++ b/drivers/target/iscsi/iscsi_target.c
@@@ -1542,12 -1543,8 +1534,17 @@@ int iscsit_setup_nop_out(struct iscsi_c
  	if (hdr->itt == RESERVED_ITT && !(hdr->opcode & ISCSI_OP_IMMEDIATE)) {
  		pr_err("NOPOUT ITT is reserved, but Immediate Bit is"
  			" not set, protocol error.\n");
++<<<<<<< HEAD
 +		if (!cmd)
 +			return iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,
 +						 (unsigned char *)hdr);
 +
 +		return iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,
 +					 (unsigned char *)hdr);
++=======
+ 		return iscsit_add_reject_from_cmd(ISCSI_REASON_PROTOCOL_ERROR,
+ 					1, 0, (unsigned char *)hdr, cmd);
++>>>>>>> 778de368964c (iscsi/isert-target: Refactor ISCSI_OP_NOOP RX handling)
  	}
  
  	if (payload_length > conn->conn_ops->MaxXmitDataSegmentLength) {
@@@ -1555,12 -1552,8 +1552,17 @@@
  			" greater than MaxXmitDataSegmentLength: %u, protocol"
  			" error.\n", payload_length,
  			conn->conn_ops->MaxXmitDataSegmentLength);
++<<<<<<< HEAD
 +		if (!cmd)
 +			return iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,
 +						 (unsigned char *)hdr);
 +
 +		return iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,
 +					 (unsigned char *)hdr);
++=======
+ 		return iscsit_add_reject_from_cmd(ISCSI_REASON_PROTOCOL_ERROR,
+ 					1, 0, (unsigned char *)hdr, cmd);
++>>>>>>> 778de368964c (iscsi/isert-target: Refactor ISCSI_OP_NOOP RX handling)
  	}
  
  	pr_debug("Got NOPOUT Ping %s ITT: 0x%08x, TTT: 0x%08x,"
@@@ -1576,11 -1569,6 +1578,14 @@@
  	 * can contain ping data.
  	 */
  	if (hdr->ttt == cpu_to_be32(0xFFFFFFFF)) {
++<<<<<<< HEAD
 +		if (!cmd)
 +			return iscsit_reject_cmd(cmd,
 +					ISCSI_REASON_BOOKMARK_NO_RESOURCES,
 +					(unsigned char *)hdr);
 +
++=======
++>>>>>>> 778de368964c (iscsi/isert-target: Refactor ISCSI_OP_NOOP RX handling)
  		cmd->iscsi_opcode	= ISCSI_OP_NOOP_OUT;
  		cmd->i_state		= ISTATE_SEND_NOPIN;
  		cmd->immediate_cmd	= ((hdr->opcode & ISCSI_OP_IMMEDIATE) ?
@@@ -1672,67 -1739,7 +1756,71 @@@ static int iscsit_handle_nop_out(struc
  		pr_debug("Ping Data: \"%s\"\n", ping_data);
  	}
  
++<<<<<<< HEAD
 +	if (hdr->itt != RESERVED_ITT) {
 +		if (!cmd) {
 +			pr_err("Checking CmdSN for NOPOUT,"
 +				" but cmd is NULL!\n");
 +			return -1;
 +		}
 +		/*
 +		 * Initiator is expecting a NopIN ping reply,
 +		 */
 +		spin_lock_bh(&conn->cmd_lock);
 +		list_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);
 +		spin_unlock_bh(&conn->cmd_lock);
 +
 +		iscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));
 +
 +		if (hdr->opcode & ISCSI_OP_IMMEDIATE) {
 +			iscsit_add_cmd_to_response_queue(cmd, conn,
 +					cmd->i_state);
 +			return 0;
 +		}
 +
 +		cmdsn_ret = iscsit_sequence_cmd(conn, cmd,
 +				(unsigned char *)hdr, hdr->cmdsn);
 +		if (cmdsn_ret == CMDSN_LOWER_THAN_EXP) {
 +			ret = 0;
 +			goto ping_out;
 +		}
 +		if (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)
 +			return -1;
 +
 +		return 0;
 +	}
 +
 +	if (hdr->ttt != cpu_to_be32(0xFFFFFFFF)) {
 +		/*
 +		 * This was a response to a unsolicited NOPIN ping.
 +		 */
 +		cmd_p = iscsit_find_cmd_from_ttt(conn, be32_to_cpu(hdr->ttt));
 +		if (!cmd_p)
 +			return -1;
 +
 +		iscsit_stop_nopin_response_timer(conn);
 +
 +		cmd_p->i_state = ISTATE_REMOVE;
 +		iscsit_add_cmd_to_immediate_queue(cmd_p, conn, cmd_p->i_state);
 +		iscsit_start_nopin_timer(conn);
 +	} else {
 +		/*
 +		 * Initiator is not expecting a NOPIN is response.
 +		 * Just ignore for now.
 +		 *
 +		 * iSCSI v19-91 10.18
 +		 * "A NOP-OUT may also be used to confirm a changed
 +		 *  ExpStatSN if another PDU will not be available
 +		 *  for a long time."
 +		 */
 +		ret = 0;
 +		goto out;
 +	}
 +
 +	return 0;
++=======
+ 	return iscsit_process_nop_out(conn, cmd, hdr);
++>>>>>>> 778de368964c (iscsi/isert-target: Refactor ISCSI_OP_NOOP RX handling)
  out:
  	if (cmd)
  		iscsit_free_cmd(cmd, false);
diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c
index ec71464a2b6f..d6fafa7e4b63 100644
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@ -1028,6 +1028,25 @@ isert_handle_iscsi_dataout(struct isert_conn *isert_conn,
 	return 0;
 }
 
+static int
+isert_handle_nop_out(struct isert_conn *isert_conn, struct isert_cmd *isert_cmd,
+		     struct iser_rx_desc *rx_desc, unsigned char *buf)
+{
+	struct iscsi_cmd *cmd = &isert_cmd->iscsi_cmd;
+	struct iscsi_conn *conn = isert_conn->conn;
+	struct iscsi_nopout *hdr = (struct iscsi_nopout *)buf;
+	int rc;
+
+	rc = iscsit_setup_nop_out(conn, cmd, hdr);
+	if (rc < 0)
+		return rc;
+	/*
+	 * FIXME: Add support for NOPOUT payload using unsolicited RDMA payload
+	 */
+
+	return iscsit_process_nop_out(conn, cmd, hdr);
+}
+
 static int
 isert_rx_opcode(struct isert_conn *isert_conn, struct iser_rx_desc *rx_desc,
 		uint32_t read_stag, uint64_t read_va,
@@ -1060,7 +1079,9 @@ isert_rx_opcode(struct isert_conn *isert_conn, struct iser_rx_desc *rx_desc,
 		if (!cmd)
 			break;
 
-		ret = iscsit_handle_nop_out(conn, cmd, (unsigned char *)hdr);
+		isert_cmd = container_of(cmd, struct isert_cmd, iscsi_cmd);
+		ret = isert_handle_nop_out(isert_conn, isert_cmd,
+					   rx_desc, (unsigned char *)hdr);
 		break;
 	case ISCSI_OP_SCSI_DATA_OUT:
 		ret = isert_handle_iscsi_dataout(isert_conn, rx_desc,
* Unmerged path drivers/target/iscsi/iscsi_target.c
diff --git a/include/target/iscsi/iscsi_transport.h b/include/target/iscsi/iscsi_transport.h
index c5aade523863..c136d735aea3 100644
--- a/include/target/iscsi/iscsi_transport.h
+++ b/include/target/iscsi/iscsi_transport.h
@@ -43,8 +43,10 @@ extern int iscsit_check_dataout_hdr(struct iscsi_conn *, unsigned char *,
 				struct iscsi_cmd **);
 extern int iscsit_check_dataout_payload(struct iscsi_cmd *, struct iscsi_data *,
 				bool);
-extern int iscsit_handle_nop_out(struct iscsi_conn *, struct iscsi_cmd *,
-				unsigned char *);
+extern int iscsit_setup_nop_out(struct iscsi_conn *, struct iscsi_cmd *,
+				struct iscsi_nopout *);
+extern int iscsit_process_nop_out(struct iscsi_conn *, struct iscsi_cmd *,
+				struct iscsi_nopout *);
 extern int iscsit_handle_logout_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 				unsigned char *);
 extern int iscsit_handle_task_mgt_cmd(struct iscsi_conn *, struct iscsi_cmd *,
