powerpc/powernv: Make it possible to skip the IRQHAPPENED check in power7_nap()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [powerpc] powernv: Make it possible to skip the IRQHAPPENED check in power7_nap() (Don Zickus) [1127366]
Rebuild_FUZZ: 94.67%
commit-author Michael Ellerman <mpe@ellerman.id.au>
commit 8d6f7c5aa3db6f3e5e43d09f8a0166c7d96f33f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/8d6f7c5a.failed

To support split core we need to be able to force all secondaries into
nap, so the core can detect they are idle and do an unsplit.

Currently power7_nap() will return without napping if there is an irq
pending. We want to ignore the pending irq and nap anyway, we will deal
with the interrupt later.

	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
	Signed-off-by: Michael Neuling <mikey@neuling.org>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 8d6f7c5aa3db6f3e5e43d09f8a0166c7d96f33f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/processor.h
#	arch/powerpc/kernel/idle_power7.S
diff --cc arch/powerpc/include/asm/processor.h
index d1c7667742b1,6d59072e13a7..000000000000
--- a/arch/powerpc/include/asm/processor.h
+++ b/arch/powerpc/include/asm/processor.h
@@@ -442,14 -449,8 +442,19 @@@ extern unsigned long cpuidle_disable
  enum idle_boot_override {IDLE_NO_OVERRIDE = 0, IDLE_POWERSAVE_OFF};
  
  extern int powersave_nap;	/* set if nap mode can be used in idle loop */
++<<<<<<< HEAD
 +extern void power7_nap(void);
 +
 +#ifdef CONFIG_PSERIES_IDLE
 +extern void update_smt_snooze_delay(int cpu, int residency);
 +#else
 +static inline void update_smt_snooze_delay(int cpu, int residency) {}
 +#endif
 +
++=======
+ extern void power7_nap(int check_irq);
+ extern void power7_sleep(void);
++>>>>>>> 8d6f7c5aa3db (powerpc/powernv: Make it possible to skip the IRQHAPPENED check in power7_nap())
  extern void flush_instruction_cache(void);
  extern void hard_reset_now(void);
  extern void poweroff_now(void);
diff --cc arch/powerpc/kernel/idle_power7.S
index 3fdef0f0c67f,2480256272d4..000000000000
--- a/arch/powerpc/kernel/idle_power7.S
+++ b/arch/powerpc/kernel/idle_power7.S
@@@ -20,17 -20,32 +20,31 @@@
  
  #undef DEBUG
  
 -/* Idle state entry routines */
 -
 -#define	IDLE_STATE_ENTER_SEQ(IDLE_INST)				\
 -	/* Magic NAP/SLEEP/WINKLE mode enter sequence */	\
 -	std	r0,0(r1);					\
 -	ptesync;						\
 -	ld	r0,0(r1);					\
 -1:	cmp	cr0,r0,r0;					\
 -	bne	1b;						\
 -	IDLE_INST;						\
 -	b	.
 -
  	.text
  
++<<<<<<< HEAD
 +_GLOBAL(power7_idle)
 +	/* Now check if user or arch enabled NAP mode */
 +	LOAD_REG_ADDRBASE(r3,powersave_nap)
 +	lwz	r4,ADDROFF(powersave_nap)(r3)
 +	cmpwi	0,r4,0
 +	beqlr
 +	/* fall through */
 +
 +_GLOBAL(power7_nap)
++=======
+ /*
+  * Pass requested state in r3:
+  * 	0 - nap
+  * 	1 - sleep
+  *
+  * To check IRQ_HAPPENED in r4
+  * 	0 - don't check
+  * 	1 - check
+  */
+ _GLOBAL(power7_powersave_common)
+ 	/* Use r3 to pass state nap/sleep/winkle */
++>>>>>>> 8d6f7c5aa3db (powerpc/powernv: Make it possible to skip the IRQHAPPENED check in power7_nap())
  	/* NAP is a state loss, we create a regs frame on the
  	 * stack, fill it up with the state we care about and
  	 * stick a pointer to it in PACAR1. We really only
@@@ -90,15 -107,59 +106,64 @@@ _GLOBAL(power7_enter_nap_mode
  	li	r4,KVM_HWTHREAD_IN_NAP
  	stb	r4,HSTATE_HWTHREAD_STATE(r13)
  #endif
 -	cmpwi	cr0,r3,1
 -	beq	2f
 -	IDLE_STATE_ENTER_SEQ(PPC_NAP)
 -	/* No return */
 -2:	IDLE_STATE_ENTER_SEQ(PPC_SLEEP)
 -	/* No return */
  
++<<<<<<< HEAD
 +	/* Magic NAP mode enter sequence */
 +	std	r0,0(r1)
 +	ptesync
 +	ld	r0,0(r1)
 +1:	cmp	cr0,r0,r0
 +	bne	1b
 +	PPC_NAP
 +	b	.
++=======
+ _GLOBAL(power7_idle)
+ 	/* Now check if user or arch enabled NAP mode */
+ 	LOAD_REG_ADDRBASE(r3,powersave_nap)
+ 	lwz	r4,ADDROFF(powersave_nap)(r3)
+ 	cmpwi	0,r4,0
+ 	beqlr
+ 	li	r3, 1
+ 	/* fall through */
+ 
+ _GLOBAL(power7_nap)
+ 	mr	r4,r3
+ 	li	r3,0
+ 	b	power7_powersave_common
+ 	/* No return */
+ 
+ _GLOBAL(power7_sleep)
+ 	li	r3,1
+ 	li	r4,0
+ 	b	power7_powersave_common
+ 	/* No return */
+ 
+ _GLOBAL(power7_wakeup_tb_loss)
+ 	ld	r2,PACATOC(r13);
+ 	ld	r1,PACAR1(r13)
+ 
+ 	/* Time base re-sync */
+ 	li	r0,OPAL_RESYNC_TIMEBASE
+ 	LOAD_REG_ADDR(r11,opal);
+ 	ld	r12,8(r11);
+ 	ld	r2,0(r11);
+ 	mtctr	r12
+ 	bctrl
+ 
+ 	/* TODO: Check r3 for failure */
+ 
+ 	REST_NVGPRS(r1)
+ 	REST_GPR(2, r1)
+ 	ld	r3,_CCR(r1)
+ 	ld	r4,_MSR(r1)
+ 	ld	r5,_NIP(r1)
+ 	addi	r1,r1,INT_FRAME_SIZE
+ 	mtcr	r3
+ 	mfspr	r3,SPRN_SRR1		/* Return SRR1 */
+ 	mtspr	SPRN_SRR1,r4
+ 	mtspr	SPRN_SRR0,r5
+ 	rfid
++>>>>>>> 8d6f7c5aa3db (powerpc/powernv: Make it possible to skip the IRQHAPPENED check in power7_nap())
  
  _GLOBAL(power7_wakeup_loss)
  	ld	r1,PACAR1(r13)
* Unmerged path arch/powerpc/include/asm/processor.h
* Unmerged path arch/powerpc/kernel/idle_power7.S
diff --git a/arch/powerpc/platforms/powernv/smp.c b/arch/powerpc/platforms/powernv/smp.c
index e91f28f2ca7b..3b7f63a0a491 100644
--- a/arch/powerpc/platforms/powernv/smp.c
+++ b/arch/powerpc/platforms/powernv/smp.c
@@ -158,7 +158,7 @@ static void pnv_smp_cpu_kill_self(void)
 	mtspr(SPRN_LPCR, mfspr(SPRN_LPCR) & ~(u64)LPCR_PECE1);
 	while (!generic_check_cpu_restart(cpu)) {
 		ppc64_runlatch_off();
-		power7_nap();
+		power7_nap(1);
 		ppc64_runlatch_on();
 		if (!generic_check_cpu_restart(cpu)) {
 			DBG("CPU%d Unexpected exit while offline !\n", cpu);
