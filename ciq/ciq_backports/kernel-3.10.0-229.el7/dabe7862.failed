kexec: move segment verification code in a separate function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Vivek Goyal <vgoyal@redhat.com>
commit dabe78628dd886c4b71971d1d78f1cecc674b760
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/dabe7862.failed

Previously do_kimage_alloc() will allocate a kimage structure, copy
segment list from user space and then do the segment list sanity
verification.

Break down this function in 3 parts.  do_kimage_alloc_init() to do actual
allocation and basic initialization of kimage structure.
copy_user_segment_list() to copy segment list from user space and
sanity_check_segment_list() to verify the sanity of segment list as passed
by user space.

In later patches, I need to only allocate kimage and not copy segment list
from user space.  So breaking down in smaller functions enables re-use of
code at other places.

	Signed-off-by: Vivek Goyal <vgoyal@redhat.com>
	Cc: Borislav Petkov <bp@suse.de>
	Cc: Michael Kerrisk <mtk.manpages@gmail.com>
	Cc: Yinghai Lu <yinghai@kernel.org>
	Cc: Eric Biederman <ebiederm@xmission.com>
	Cc: H. Peter Anvin <hpa@zytor.com>
	Cc: Matthew Garrett <mjg59@srcf.ucam.org>
	Cc: Greg Kroah-Hartman <greg@kroah.com>
	Cc: Dave Young <dyoung@redhat.com>
	Cc: WANG Chao <chaowang@redhat.com>
	Cc: Baoquan He <bhe@redhat.com>
	Cc: Andy Lutomirski <luto@amacapital.net>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit dabe78628dd886c4b71971d1d78f1cecc674b760)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/kexec.c
diff --cc kernel/kexec.c
index 4b1d9ca3907c,062e5567750e..000000000000
--- a/kernel/kexec.c
+++ b/kernel/kexec.c
@@@ -125,36 -125,12 +125,18 @@@ static struct page *kimage_alloc_page(s
  				       gfp_t gfp_mask,
  				       unsigned long dest);
  
++<<<<<<< HEAD
 +static int do_kimage_alloc(struct kimage **rimage, unsigned long entry,
 +	                    unsigned long nr_segments,
 +                            struct kexec_segment __user *segments)
++=======
+ static int copy_user_segment_list(struct kimage *image,
+ 				  unsigned long nr_segments,
+ 				  struct kexec_segment __user *segments)
++>>>>>>> dabe78628dd8 (kexec: move segment verification code in a separate function)
  {
+ 	int ret;
  	size_t segment_bytes;
- 	struct kimage *image;
- 	unsigned long i;
- 	int result;
- 
- 	/* Allocate a controlling structure */
- 	result = -ENOMEM;
- 	image = kzalloc(sizeof(*image), GFP_KERNEL);
- 	if (!image)
- 		goto out;
- 
- 	image->head = 0;
- 	image->entry = &image->head;
- 	image->last_entry = &image->head;
- 	image->control_page = ~0; /* By default this does not apply */
- 	image->start = entry;
- 	image->type = KEXEC_TYPE_DEFAULT;
- 
- 	/* Initialize the list of control pages */
- 	INIT_LIST_HEAD(&image->control_pages);
- 
- 	/* Initialize the list of destination pages */
- 	INIT_LIST_HEAD(&image->dest_pages);
- 
- 	/* Initialize the list of unusable pages */
- 	INIT_LIST_HEAD(&image->unusable_pages);
  
  	/* Read in the segments */
  	image->nr_segments = nr_segments;
@@@ -258,14 -292,14 +298,24 @@@ static int kimage_normal_alloc(struct k
  	image->control_code_page = kimage_alloc_control_pages(image,
  					   get_order(KEXEC_CONTROL_PAGE_SIZE));
  	if (!image->control_code_page) {
++<<<<<<< HEAD
 +		printk(KERN_ERR "Could not allocate control_code_buffer\n");
 +		goto out_free;
++=======
+ 		pr_err("Could not allocate control_code_buffer\n");
+ 		goto out_free_image;
++>>>>>>> dabe78628dd8 (kexec: move segment verification code in a separate function)
  	}
  
  	image->swap_page = kimage_alloc_control_pages(image, 0);
  	if (!image->swap_page) {
++<<<<<<< HEAD
 +		printk(KERN_ERR "Could not allocate swap buffer\n");
 +		goto out_free;
++=======
+ 		pr_err("Could not allocate swap buffer\n");
+ 		goto out_free_control_pages;
++>>>>>>> dabe78628dd8 (kexec: move segment verification code in a separate function)
  	}
  
  	*rimage = image;
@@@ -333,8 -352,8 +368,13 @@@ static int kimage_crash_alloc(struct ki
  	image->control_code_page = kimage_alloc_control_pages(image,
  					   get_order(KEXEC_CONTROL_PAGE_SIZE));
  	if (!image->control_code_page) {
++<<<<<<< HEAD
 +		printk(KERN_ERR "Could not allocate control_code_buffer\n");
 +		goto out_free;
++=======
+ 		pr_err("Could not allocate control_code_buffer\n");
+ 		goto out_free_image;
++>>>>>>> dabe78628dd8 (kexec: move segment verification code in a separate function)
  	}
  
  	*rimage = image;
* Unmerged path kernel/kexec.c
