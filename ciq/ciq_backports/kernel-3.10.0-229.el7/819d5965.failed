powerpc: refactor of_get_cpu_node to support other architectures

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [powerpc] refactor of_get_cpu_node to support other architectures (Don Zickus) [1127366]
Rebuild_FUZZ: 92.44%
commit-author Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>
commit 819d596568d82ffb85b0b5989a1567810fe66098
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/819d5965.failed

Currently different drivers requiring to access cpu device node are
parsing the device tree themselves. Since the ordering in the DT need
not match the logical cpu ordering, the parsing logic needs to consider
that. However, this has resulted in lots of code duplication and in some
cases even incorrect logic.

It's better to consolidate them by adding support for getting cpu
device node for a given logical cpu index in DT core library. However
logical to physical index mapping can be architecture specific.

PowerPC has it's own implementation to get the cpu node for a given
logical index.

This patch refactors the current implementation of of_get_cpu_node.
This in preparation to move the implementation to DT core library.
It separates out the logical to physical mapping so that a default
matching of the physical id to the logical cpu index can be added
when moved to common code. Architecture specific code can override it.

	Cc: Rob Herring <rob.herring@calxeda.com>
	Cc: Grant Likely <grant.likely@linaro.org>
	Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Signed-off-by: Sudeep KarkadaNagesha <sudeep.karkadanagesha@arm.com>
(cherry picked from commit 819d596568d82ffb85b0b5989a1567810fe66098)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/prom.c
diff --cc arch/powerpc/kernel/prom.c
index 49a77c25b33e,f7b8c0be982e..000000000000
--- a/arch/powerpc/kernel/prom.c
+++ b/arch/powerpc/kernel/prom.c
@@@ -899,39 -900,28 +928,58 @@@ static bool __of_find_n_match_cpu_prope
   */
  struct device_node *of_get_cpu_node(int cpu, unsigned int *thread)
  {
- 	int hardid;
- 	struct device_node *np;
+ 	struct device_node *cpun, *cpus;
  
- 	hardid = get_hard_smp_processor_id(cpu);
+ 	cpus = of_find_node_by_path("/cpus");
+ 	if (!cpus) {
+ 		pr_warn("Missing cpus node, bailing out\n");
+ 		return NULL;
+ 	}
  
++<<<<<<< HEAD
 +	for_each_node_by_type(np, "cpu") {
 +		const __be32 *intserv;
 +		unsigned int plen, t;
++=======
+ 	for_each_child_of_node(cpus, cpun) {
+ 		if (of_node_cmp(cpun->type, "cpu"))
+ 			continue;
++>>>>>>> 819d596568d8 (powerpc: refactor of_get_cpu_node to support other architectures)
  
- 		/* Check for ibm,ppc-interrupt-server#s. If it doesn't exist
- 		 * fallback to "reg" property and assume no threads
+ 		/* Check for non-standard "ibm,ppc-interrupt-server#s" property
+ 		 * for thread ids on PowerPC. If it doesn't exist fallback to
+ 		 * standard "reg" property.
  		 */
++<<<<<<< HEAD
 +		intserv = of_get_property(np, "ibm,ppc-interrupt-server#s",
 +				&plen);
 +		if (intserv == NULL) {
 +			const __be32 *reg = of_get_property(np, "reg", NULL);
 +			if (reg == NULL)
 +				continue;
 +			if (be32_to_cpup(reg) == hardid) {
 +				if (thread)
 +					*thread = 0;
 +				return np;
 +			}
 +		} else {
 +			plen /= sizeof(u32);
 +			for (t = 0; t < plen; t++) {
 +				if (hardid == be32_to_cpu(intserv[t])) {
 +					if (thread)
 +						*thread = t;
 +					return np;
 +				}
 +			}
 +		}
++=======
+ 		if (__of_find_n_match_cpu_property(cpun,
+ 				"ibm,ppc-interrupt-server#s", cpu, thread))
+ 			return cpun;
+ 
+ 		if (__of_find_n_match_cpu_property(cpun, "reg", cpu, thread))
+ 			return cpun;
++>>>>>>> 819d596568d8 (powerpc: refactor of_get_cpu_node to support other architectures)
  	}
  	return NULL;
  }
* Unmerged path arch/powerpc/kernel/prom.c
