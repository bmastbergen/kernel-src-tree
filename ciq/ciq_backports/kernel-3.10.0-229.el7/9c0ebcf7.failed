cpufreq: Implement light weight ->target_index() routine

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Implement light weight ->target_index() routine (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 91.26%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 9c0ebcf78fde0ffa348a95a544c6d3f2dac5af65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/9c0ebcf7.failed

Currently, the prototype of cpufreq_drivers target routines is:

int target(struct cpufreq_policy *policy, unsigned int target_freq,
		unsigned int relation);

And most of the drivers call cpufreq_frequency_table_target() to get a valid
index of their frequency table which is closest to the target_freq. And they
don't use target_freq and relation after that.

So, it makes sense to just do this work in cpufreq core before calling
cpufreq_frequency_table_target() and simply pass index instead. But this can be
done only with drivers which expose their frequency table with cpufreq core. For
others we need to stick with the old prototype of target() until those drivers
are converted to expose frequency tables.

This patch implements the new light weight prototype for target_index() routine.
It looks like this:

int target_index(struct cpufreq_policy *policy, unsigned int index);

CPUFreq core will call cpufreq_frequency_table_target() before calling this
routine and pass index to it. Because CPUFreq core now requires to call routines
present in freq_table.c CONFIG_CPU_FREQ_TABLE must be enabled all the time.

This also marks target() interface as deprecated. So, that new drivers avoid
using it. And Documentation is updated accordingly.

It also converts existing .target() to newly defined light weight
.target_index() routine for many driver.

	Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
	Acked-by: Jesper Nilsson <jesper.nilsson@axis.com>
	Acked-by: Linus Walleij <linus.walleij@linaro.org>
	Acked-by: Russell King <linux@arm.linux.org.uk>
	Acked-by: David S. Miller <davem@davemloft.net>
	Tested-by: Andrew Lunn <andrew@lunn.ch>
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rjw@rjwysocki.net>
(cherry picked from commit 9c0ebcf78fde0ffa348a95a544c6d3f2dac5af65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/mach-sa1100/generic.c
#	arch/arm/mach-sa1100/generic.h
#	drivers/cpufreq/arm_big_little.c
#	drivers/cpufreq/at32ap-cpufreq.c
#	drivers/cpufreq/blackfin-cpufreq.c
#	drivers/cpufreq/cpufreq-cpu0.c
#	drivers/cpufreq/cpufreq.c
#	drivers/cpufreq/cris-artpec3-cpufreq.c
#	drivers/cpufreq/cris-etraxfs-cpufreq.c
#	drivers/cpufreq/dbx500-cpufreq.c
#	drivers/cpufreq/e_powersaver.c
#	drivers/cpufreq/elanfreq.c
#	drivers/cpufreq/exynos-cpufreq.c
#	drivers/cpufreq/exynos5440-cpufreq.c
#	drivers/cpufreq/ia64-acpi-cpufreq.c
#	drivers/cpufreq/imx6q-cpufreq.c
#	drivers/cpufreq/kirkwood-cpufreq.c
#	drivers/cpufreq/longhaul.c
#	drivers/cpufreq/loongson2_cpufreq.c
#	drivers/cpufreq/maple-cpufreq.c
#	drivers/cpufreq/omap-cpufreq.c
#	drivers/cpufreq/pasemi-cpufreq.c
#	drivers/cpufreq/pmac32-cpufreq.c
#	drivers/cpufreq/pmac64-cpufreq.c
#	drivers/cpufreq/powernow-k6.c
#	drivers/cpufreq/powernow-k7.c
#	drivers/cpufreq/powernow-k8.c
#	drivers/cpufreq/ppc-corenet-cpufreq.c
#	drivers/cpufreq/ppc_cbe_cpufreq.c
#	drivers/cpufreq/pxa2xx-cpufreq.c
#	drivers/cpufreq/pxa3xx-cpufreq.c
#	drivers/cpufreq/s3c2416-cpufreq.c
#	drivers/cpufreq/s3c64xx-cpufreq.c
#	drivers/cpufreq/s5pv210-cpufreq.c
#	drivers/cpufreq/sa1100-cpufreq.c
#	drivers/cpufreq/sa1110-cpufreq.c
#	drivers/cpufreq/sc520_freq.c
#	drivers/cpufreq/sparc-us2e-cpufreq.c
#	drivers/cpufreq/sparc-us3-cpufreq.c
#	drivers/cpufreq/spear-cpufreq.c
#	drivers/cpufreq/speedstep-centrino.c
#	drivers/cpufreq/speedstep-ich.c
#	drivers/cpufreq/speedstep-smi.c
#	drivers/cpufreq/tegra-cpufreq.c
#	include/linux/cpufreq.h
diff --cc arch/arm/mach-sa1100/generic.c
index 9db3e98e8b85,d4ea142c4edd..000000000000
--- a/arch/arm/mach-sa1100/generic.c
+++ b/arch/arm/mach-sa1100/generic.c
@@@ -41,69 -42,26 +41,72 @@@ EXPORT_SYMBOL(reset_status)
  /*
   * This table is setup for a 3.6864MHz Crystal.
   */
 -struct cpufreq_frequency_table sa11x0_freq_table[NR_FREQS+1] = {
 -	{ .frequency = 59000,	/*  59.0 MHz */},
 -	{ .frequency = 73700,	/*  73.7 MHz */},
 -	{ .frequency = 88500,	/*  88.5 MHz */},
 -	{ .frequency = 103200,	/* 103.2 MHz */},
 -	{ .frequency = 118000,	/* 118.0 MHz */},
 -	{ .frequency = 132700,	/* 132.7 MHz */},
 -	{ .frequency = 147500,	/* 147.5 MHz */},
 -	{ .frequency = 162200,	/* 162.2 MHz */},
 -	{ .frequency = 176900,	/* 176.9 MHz */},
 -	{ .frequency = 191700,	/* 191.7 MHz */},
 -	{ .frequency = 206400,	/* 206.4 MHz */},
 -	{ .frequency = 221200,	/* 221.2 MHz */},
 -	{ .frequency = 235900,	/* 235.9 MHz */},
 -	{ .frequency = 250700,	/* 250.7 MHz */},
 -	{ .frequency = 265400,	/* 265.4 MHz */},
 -	{ .frequency = 280200,	/* 280.2 MHz */},
 -	{ .frequency = CPUFREQ_TABLE_END, },
 +static const unsigned short cclk_frequency_100khz[NR_FREQS] = {
 +	 590,	/*  59.0 MHz */
 +	 737,	/*  73.7 MHz */
 +	 885,	/*  88.5 MHz */
 +	1032,	/* 103.2 MHz */
 +	1180,	/* 118.0 MHz */
 +	1327,	/* 132.7 MHz */
 +	1475,	/* 147.5 MHz */
 +	1622,	/* 162.2 MHz */
 +	1769,	/* 176.9 MHz */
 +	1917,	/* 191.7 MHz */
 +	2064,	/* 206.4 MHz */
 +	2212,	/* 221.2 MHz */
 +	2359,	/* 235.9 MHz */
 +	2507,	/* 250.7 MHz */
 +	2654,	/* 265.4 MHz */
 +	2802	/* 280.2 MHz */
  };
  
++<<<<<<< HEAD
 +/* rounds up(!)  */
 +unsigned int sa11x0_freq_to_ppcr(unsigned int khz)
 +{
 +	int i;
 +
 +	khz /= 100;
 +
 +	for (i = 0; i < NR_FREQS; i++)
 +		if (cclk_frequency_100khz[i] >= khz)
 +			break;
 +
 +	return i;
 +}
 +
 +unsigned int sa11x0_ppcr_to_freq(unsigned int idx)
 +{
 +	unsigned int freq = 0;
 +	if (idx < NR_FREQS)
 +		freq = cclk_frequency_100khz[idx] * 100;
 +	return freq;
 +}
 +
 +
 +/* make sure that only the "userspace" governor is run -- anything else wouldn't make sense on
 + * this platform, anyway.
 + */
 +int sa11x0_verify_speed(struct cpufreq_policy *policy)
 +{
 +	unsigned int tmp;
 +	if (policy->cpu)
 +		return -EINVAL;
 +
 +	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq, policy->cpuinfo.max_freq);
 +
 +	/* make sure that at least one frequency is within the policy */
 +	tmp = cclk_frequency_100khz[sa11x0_freq_to_ppcr(policy->min)] * 100;
 +	if (tmp > policy->max)
 +		policy->max = tmp;
 +
 +	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq, policy->cpuinfo.max_freq);
 +
 +	return 0;
 +}
 +
++=======
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  unsigned int sa11x0_getspeed(unsigned int cpu)
  {
  	if (cpu)
diff --cc arch/arm/mach-sa1100/generic.h
index 2abc6a1f6e86,0d92e119b36b..000000000000
--- a/arch/arm/mach-sa1100/generic.h
+++ b/arch/arm/mach-sa1100/generic.h
@@@ -18,12 -20,8 +18,15 @@@ extern void sa11x0_init_late(void)
  extern void sa1110_mb_enable(void);
  extern void sa1110_mb_disable(void);
  
++<<<<<<< HEAD
 +struct cpufreq_policy;
 +
 +extern unsigned int sa11x0_freq_to_ppcr(unsigned int khz);
 +extern int sa11x0_verify_speed(struct cpufreq_policy *policy);
++=======
+ extern struct cpufreq_frequency_table sa11x0_freq_table[];
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  extern unsigned int sa11x0_getspeed(unsigned int cpu);
- extern unsigned int sa11x0_ppcr_to_freq(unsigned int idx);
  
  struct flash_platform_data;
  struct resource;
diff --cc drivers/cpufreq/arm_big_little.c
index 5d7f53fcd6f5,163e3378fe17..000000000000
--- a/drivers/cpufreq/arm_big_little.c
+++ b/drivers/cpufreq/arm_big_little.c
@@@ -47,20 -47,12 +47,20 @@@ static unsigned int bL_cpufreq_get(unsi
  	return clk_get_rate(clk[cur_cluster]) / 1000;
  }
  
 +/* Validate policy frequency range */
 +static int bL_cpufreq_verify_policy(struct cpufreq_policy *policy)
 +{
 +	u32 cur_cluster = cpu_to_cluster(policy->cpu);
 +
 +	return cpufreq_frequency_table_verify(policy, freq_table[cur_cluster]);
 +}
 +
  /* Set clock frequency */
  static int bL_cpufreq_set_target(struct cpufreq_policy *policy,
- 		unsigned int target_freq, unsigned int relation)
+ 		unsigned int index)
  {
  	struct cpufreq_freqs freqs;
- 	u32 cpu = policy->cpu, freq_tab_idx, cur_cluster;
+ 	u32 cpu = policy->cpu, cur_cluster;
  	int ret = 0;
  
  	cur_cluster = cpu_to_cluster(policy->cpu);
@@@ -208,17 -188,12 +201,24 @@@ static int bL_cpufreq_exit(struct cpufr
  	return 0;
  }
  
 +/* Export freq_table to sysfs */
 +static struct freq_attr *bL_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver bL_cpufreq_driver = {
  	.name			= "arm-big-little",
++<<<<<<< HEAD
 +	.flags			= CPUFREQ_STICKY,
 +	.verify			= bL_cpufreq_verify_policy,
 +	.target			= bL_cpufreq_set_target,
++=======
+ 	.flags			= CPUFREQ_STICKY |
+ 					CPUFREQ_HAVE_GOVERNOR_PER_POLICY,
+ 	.verify			= cpufreq_generic_frequency_table_verify,
+ 	.target_index		= bL_cpufreq_set_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get			= bL_cpufreq_get,
  	.init			= bL_cpufreq_init,
  	.exit			= bL_cpufreq_exit,
diff --cc drivers/cpufreq/at32ap-cpufreq.c
index 654488723cb5,81d07527bde6..000000000000
--- a/drivers/cpufreq/at32ap-cpufreq.c
+++ b/drivers/cpufreq/at32ap-cpufreq.c
@@@ -108,10 -124,9 +95,15 @@@ static int __init at32_cpufreq_driver_i
  
  static struct cpufreq_driver at32_driver = {
  	.name		= "at32ap",
 +	.owner		= THIS_MODULE,
  	.init		= at32_cpufreq_driver_init,
++<<<<<<< HEAD
 +	.verify		= at32_verify_speed,
 +	.target		= at32_set_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= at32_set_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= at32_get_speed,
  	.flags		= CPUFREQ_STICKY,
  };
diff --cc drivers/cpufreq/blackfin-cpufreq.c
index 995511e80bef,12528b28d45d..000000000000
--- a/drivers/cpufreq/blackfin-cpufreq.c
+++ b/drivers/cpufreq/blackfin-cpufreq.c
@@@ -209,24 -195,17 +200,29 @@@ static int __bfin_cpu_init(struct cpufr
  
  	policy->cpuinfo.transition_latency = 50000; /* 50us assumed */
  
 -	return cpufreq_table_validate_and_show(policy, bfin_freq_table);
 +	policy->cur = cclk;
 +	cpufreq_frequency_table_get_attr(bfin_freq_table, policy->cpu);
 +	return cpufreq_frequency_table_cpuinfo(policy, bfin_freq_table);
  }
  
 +static struct freq_attr *bfin_freq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver bfin_driver = {
++<<<<<<< HEAD
 +	.verify = bfin_verify_speed,
 +	.target = bfin_target,
++=======
+ 	.verify = cpufreq_generic_frequency_table_verify,
+ 	.target_index = bfin_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get = bfin_getfreq_khz,
  	.init = __bfin_cpu_init,
 -	.exit = cpufreq_generic_exit,
  	.name = "bfin cpufreq",
 -	.attr = cpufreq_generic_attr,
 +	.owner = THIS_MODULE,
 +	.attr = bfin_freq_attr,
  };
  
  static int __init bfin_cpu_init(void)
diff --cc drivers/cpufreq/cpufreq-cpu0.c
index ad1fde277661,4dbe7efd86e5..000000000000
--- a/drivers/cpufreq/cpufreq-cpu0.c
+++ b/drivers/cpufreq/cpufreq-cpu0.c
@@@ -39,24 -35,14 +39,14 @@@ static unsigned int cpu0_get_speed(unsi
  	return clk_get_rate(cpu_clk) / 1000;
  }
  
- static int cpu0_set_target(struct cpufreq_policy *policy,
- 			   unsigned int target_freq, unsigned int relation)
+ static int cpu0_set_target(struct cpufreq_policy *policy, unsigned int index)
  {
  	struct cpufreq_freqs freqs;
 -	struct dev_pm_opp *opp;
 +	struct opp *opp;
  	unsigned long volt = 0, volt_old = 0, tol = 0;
  	long freq_Hz, freq_exact;
- 	unsigned int index;
  	int ret;
  
- 	ret = cpufreq_frequency_table_target(policy, freq_table, target_freq,
- 					     relation, &index);
- 	if (ret) {
- 		pr_err("failed to match target freqency %d: %d\n",
- 		       target_freq, ret);
- 		return ret;
- 	}
- 
  	freq_Hz = clk_round_rate(cpu_clk, freq_table[index].frequency * 1000);
  	if (freq_Hz < 0)
  		freq_Hz = freq_table[index].frequency * 1000;
@@@ -64,14 -50,11 +54,11 @@@
  	freqs.new = freq_Hz / 1000;
  	freqs.old = clk_get_rate(cpu_clk) / 1000;
  
- 	if (freqs.old == freqs.new)
- 		return 0;
- 
  	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
  
 -	if (!IS_ERR(cpu_reg)) {
 +	if (cpu_reg) {
  		rcu_read_lock();
 -		opp = dev_pm_opp_find_freq_ceil(cpu_dev, &freq_Hz);
 +		opp = opp_find_freq_ceil(cpu_dev, &freq_Hz);
  		if (IS_ERR(opp)) {
  			rcu_read_unlock();
  			pr_err("failed to find OPP for %ld\n", freq_Hz);
@@@ -126,50 -109,18 +113,55 @@@ post_notify
  
  static int cpu0_cpufreq_init(struct cpufreq_policy *policy)
  {
 -	return cpufreq_generic_init(policy, freq_table, transition_latency);
 +	int ret;
 +
 +	ret = cpufreq_frequency_table_cpuinfo(policy, freq_table);
 +	if (ret) {
 +		pr_err("invalid frequency table: %d\n", ret);
 +		return ret;
 +	}
 +
 +	policy->cpuinfo.transition_latency = transition_latency;
 +	policy->cur = clk_get_rate(cpu_clk) / 1000;
 +
 +	/*
 +	 * The driver only supports the SMP configuartion where all processors
 +	 * share the clock and voltage and clock.  Use cpufreq affected_cpus
 +	 * interface to have all CPUs scaled together.
 +	 */
 +	cpumask_setall(policy->cpus);
 +
 +	cpufreq_frequency_table_get_attr(freq_table, policy->cpu);
 +
 +	return 0;
 +}
 +
 +static int cpu0_cpufreq_exit(struct cpufreq_policy *policy)
 +{
 +	cpufreq_frequency_table_put_attr(policy->cpu);
 +
 +	return 0;
  }
  
 +static struct freq_attr *cpu0_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver cpu0_cpufreq_driver = {
  	.flags = CPUFREQ_STICKY,
++<<<<<<< HEAD
 +	.verify = cpu0_verify_speed,
 +	.target = cpu0_set_target,
++=======
+ 	.verify = cpufreq_generic_frequency_table_verify,
+ 	.target_index = cpu0_set_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get = cpu0_get_speed,
  	.init = cpu0_cpufreq_init,
 -	.exit = cpufreq_generic_exit,
 +	.exit = cpu0_cpufreq_exit,
  	.name = "generic_cpu0",
 -	.attr = cpufreq_generic_attr,
 +	.attr = cpu0_cpufreq_attr,
  };
  
  static int cpu0_cpufreq_probe(struct platform_device *pdev)
diff --cc drivers/cpufreq/cpufreq.c
index 7e78bc2de297,87ed83a6c894..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -874,21 -885,22 +879,34 @@@ static void cpufreq_init_policy(struct 
  }
  
  #ifdef CONFIG_HOTPLUG_CPU
 -static int cpufreq_add_policy_cpu(struct cpufreq_policy *policy,
 -				  unsigned int cpu, struct device *dev,
 -				  bool frozen)
 +static int cpufreq_add_policy_cpu(unsigned int cpu, unsigned int sibling,
 +				  struct device *dev)
  {
++<<<<<<< HEAD
 +	struct cpufreq_policy *policy;
 +	int ret = 0, has_target = !!cpufreq_driver->target;
 +	unsigned long flags;
 +
 +	policy = cpufreq_cpu_get(sibling);
 +	if (WARN_ON_ONCE(!policy))
 +		return -ENODATA;
++=======
+ 	int ret = 0;
+ 	unsigned long flags;
+ 
+ 	if (has_target()) {
+ 		ret = __cpufreq_governor(policy, CPUFREQ_GOV_STOP);
+ 		if (ret) {
+ 			pr_err("%s: Failed to stop governor\n", __func__);
+ 			return ret;
+ 		}
+ 	}
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
 +
 +	if (has_target)
 +		__cpufreq_governor(policy, CPUFREQ_GOV_STOP);
  
 -	lock_policy_rwsem_write(policy->cpu);
 +	lock_policy_rwsem_write(sibling);
  
  	write_lock_irqsave(&cpufreq_driver_lock, flags);
  
@@@ -897,16 -908,20 +915,25 @@@
  	per_cpu(cpufreq_cpu_data, cpu) = policy;
  	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
  
 -	unlock_policy_rwsem_write(policy->cpu);
 +	unlock_policy_rwsem_write(sibling);
  
++<<<<<<< HEAD
 +	if (has_target) {
 +		__cpufreq_governor(policy, CPUFREQ_GOV_START);
 +		__cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
++=======
+ 	if (has_target()) {
+ 		if ((ret = __cpufreq_governor(policy, CPUFREQ_GOV_START)) ||
+ 			(ret = __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS))) {
+ 			pr_err("%s: Failed to start governor\n", __func__);
+ 			return ret;
+ 		}
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	}
  
 -	/* Don't touch sysfs links during light-weight init */
 -	if (!frozen)
 -		ret = sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");
 +	ret = sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");
  
 +	cpufreq_cpu_put(policy);
  	return ret;
  }
  #endif
@@@ -1146,8 -1220,13 +1173,18 @@@ static int __cpufreq_remove_dev(struct 
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	if (cpufreq_driver->target)
 +		__cpufreq_governor(data, CPUFREQ_GOV_STOP);
++=======
+ 	if (has_target()) {
+ 		ret = __cpufreq_governor(policy, CPUFREQ_GOV_STOP);
+ 		if (ret) {
+ 			pr_err("%s: Failed to stop governor\n", __func__);
+ 			return ret;
+ 		}
+ 	}
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  
  #ifdef CONFIG_HOTPLUG_CPU
  	if (!cpufreq_driver->setpolicy)
@@@ -1176,35 -1253,88 +1213,57 @@@
  		}
  	}
  
 -	return 0;
 -}
 -
 -static int __cpufreq_remove_dev_finish(struct device *dev,
 -				       struct subsys_interface *sif,
 -				       bool frozen)
 -{
 -	unsigned int cpu = dev->id, cpus;
 -	int ret;
 -	unsigned long flags;
 -	struct cpufreq_policy *policy;
 -	struct kobject *kobj;
 -	struct completion *cmp;
 -
 -	read_lock_irqsave(&cpufreq_driver_lock, flags);
 -	policy = per_cpu(cpufreq_cpu_data, cpu);
 -	read_unlock_irqrestore(&cpufreq_driver_lock, flags);
 -
 -	if (!policy) {
 -		pr_debug("%s: No cpu_data found\n", __func__);
 -		return -EINVAL;
 -	}
 -
 -	lock_policy_rwsem_write(cpu);
 -	cpus = cpumask_weight(policy->cpus);
 -
 -	if (cpus > 1)
 -		cpumask_clear_cpu(cpu, policy->cpus);
 -	unlock_policy_rwsem_write(cpu);
 -
  	/* If cpu is last user of policy, free policy */
  	if (cpus == 1) {
++<<<<<<< HEAD
 +		if (cpufreq_driver->target)
 +			__cpufreq_governor(data, CPUFREQ_GOV_POLICY_EXIT);
++=======
+ 		if (has_target()) {
+ 			ret = __cpufreq_governor(policy,
+ 					CPUFREQ_GOV_POLICY_EXIT);
+ 			if (ret) {
+ 				pr_err("%s: Failed to exit governor\n",
+ 						__func__);
+ 				return ret;
+ 			}
+ 		}
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  
 -		if (!frozen) {
 -			lock_policy_rwsem_read(cpu);
 -			kobj = &policy->kobj;
 -			cmp = &policy->kobj_unregister;
 -			unlock_policy_rwsem_read(cpu);
 -			kobject_put(kobj);
 -
 -			/*
 -			 * We need to make sure that the underlying kobj is
 -			 * actually not referenced anymore by anybody before we
 -			 * proceed with unloading.
 -			 */
 -			pr_debug("waiting for dropping of refcount\n");
 -			wait_for_completion(cmp);
 -			pr_debug("wait complete\n");
 -		}
 +		lock_policy_rwsem_read(cpu);
 +		kobj = &data->kobj;
 +		cmp = &data->kobj_unregister;
 +		unlock_policy_rwsem_read(cpu);
 +		kobject_put(kobj);
  
 -		/*
 -		 * Perform the ->exit() even during light-weight tear-down,
 -		 * since this is a core component, and is essential for the
 -		 * subsequent light-weight ->init() to succeed.
 +		/* we need to make sure that the underlying kobj is actually
 +		 * not referenced anymore by anybody before we proceed with
 +		 * unloading.
  		 */
 -		if (cpufreq_driver->exit)
 -			cpufreq_driver->exit(policy);
 +		pr_debug("waiting for dropping of refcount\n");
 +		wait_for_completion(cmp);
 +		pr_debug("wait complete\n");
  
 -		/* Remove policy from list of active policies */
 -		write_lock_irqsave(&cpufreq_driver_lock, flags);
 -		list_del(&policy->policy_list);
 -		write_unlock_irqrestore(&cpufreq_driver_lock, flags);
 +		if (cpufreq_driver->exit)
 +			cpufreq_driver->exit(data);
  
 -		if (!frozen)
 -			cpufreq_policy_free(policy);
 +		free_cpumask_var(data->related_cpus);
 +		free_cpumask_var(data->cpus);
 +		kfree(data);
  	} else {
++<<<<<<< HEAD
 +		if (cpufreq_driver->target) {
 +			__cpufreq_governor(data, CPUFREQ_GOV_START);
 +			__cpufreq_governor(data, CPUFREQ_GOV_LIMITS);
++=======
+ 		if (has_target()) {
+ 			if ((ret = __cpufreq_governor(policy, CPUFREQ_GOV_START)) ||
+ 					(ret = __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS))) {
+ 				pr_err("%s: Failed to start governor\n",
+ 						__func__);
+ 				return ret;
+ 			}
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  		}
  	}
  
@@@ -1897,14 -2054,14 +1985,20 @@@ int cpufreq_update_policy(unsigned int 
  	 * -> ask driver for current freq and notify governors about a change
  	 */
  	if (cpufreq_driver->get) {
 -		new_policy.cur = cpufreq_driver->get(cpu);
 -		if (!policy->cur) {
 +		policy.cur = cpufreq_driver->get(cpu);
 +		if (!data->cur) {
  			pr_debug("Driver did not initialize current freq");
 -			policy->cur = new_policy.cur;
 +			data->cur = policy.cur;
  		} else {
++<<<<<<< HEAD
 +			if (data->cur != policy.cur && cpufreq_driver->target)
 +				cpufreq_out_of_sync(cpu, data->cur,
 +								policy.cur);
++=======
+ 			if (policy->cur != new_policy.cur && has_target())
+ 				cpufreq_out_of_sync(cpu, policy->cur,
+ 								new_policy.cur);
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  		}
  	}
  
diff --cc drivers/cpufreq/cris-artpec3-cpufreq.c
index ee142c490575,841857cf1562..000000000000
--- a/drivers/cpufreq/cris-artpec3-cpufreq.c
+++ b/drivers/cpufreq/cris-artpec3-cpufreq.c
@@@ -52,67 -51,23 +51,75 @@@ static int cris_freq_target(struct cpuf
  	local_irq_enable();
  
  	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
++<<<<<<< HEAD
 +};
 +
 +static int cris_freq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, &cris_freq_table[0]);
 +}
 +
 +static int cris_freq_target(struct cpufreq_policy *policy,
 +			    unsigned int target_freq,
 +			    unsigned int relation)
 +{
 +	unsigned int newstate = 0;
 +
 +	if (cpufreq_frequency_table_target(policy, cris_freq_table,
 +			target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	cris_freq_set_cpu_state(policy, newstate);
++=======
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  
  	return 0;
  }
  
  static int cris_freq_cpu_init(struct cpufreq_policy *policy)
  {
 -	return cpufreq_generic_init(policy, cris_freq_table, 1000000);
 +	int result;
 +
 +	/* cpuinfo and default policy values */
 +	policy->cpuinfo.transition_latency = 1000000; /* 1ms */
 +	policy->cur = cris_freq_get_cpu_frequency(0);
 +
 +	result = cpufreq_frequency_table_cpuinfo(policy, cris_freq_table);
 +	if (result)
 +		return (result);
 +
 +	cpufreq_frequency_table_get_attr(cris_freq_table, policy->cpu);
 +
 +	return 0;
 +}
 +
 +
 +static int cris_freq_cpu_exit(struct cpufreq_policy *policy)
 +{
 +	cpufreq_frequency_table_put_attr(policy->cpu);
 +	return 0;
  }
  
 +
 +static struct freq_attr *cris_freq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver cris_freq_driver = {
  	.get	= cris_freq_get_cpu_frequency,
++<<<<<<< HEAD
 +	.verify	= cris_freq_verify,
 +	.target	= cris_freq_target,
++=======
+ 	.verify	= cpufreq_generic_frequency_table_verify,
+ 	.target_index = cris_freq_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.init	= cris_freq_cpu_init,
 -	.exit	= cpufreq_generic_exit,
 +	.exit	= cris_freq_cpu_exit,
  	.name	= "cris_freq",
 -	.attr	= cpufreq_generic_attr,
 +	.owner	= THIS_MODULE,
 +	.attr	= cris_freq_attr,
  };
  
  static int __init cris_freq_init(void)
diff --cc drivers/cpufreq/cris-etraxfs-cpufreq.c
index 12952235d5db,c58811abd961..000000000000
--- a/drivers/cpufreq/cris-etraxfs-cpufreq.c
+++ b/drivers/cpufreq/cris-etraxfs-cpufreq.c
@@@ -52,64 -51,23 +51,72 @@@ static int cris_freq_target(struct cpuf
  	local_irq_enable();
  
  	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
++<<<<<<< HEAD
 +};
 +
 +static int cris_freq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, &cris_freq_table[0]);
 +}
 +
 +static int cris_freq_target(struct cpufreq_policy *policy,
 +			    unsigned int target_freq, unsigned int relation)
 +{
 +	unsigned int newstate = 0;
 +
 +	if (cpufreq_frequency_table_target
 +	    (policy, cris_freq_table, target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	cris_freq_set_cpu_state(policy, newstate);
++=======
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  
  	return 0;
  }
  
  static int cris_freq_cpu_init(struct cpufreq_policy *policy)
  {
 -	return cpufreq_generic_init(policy, cris_freq_table, 1000000);
 +	int result;
 +
 +	/* cpuinfo and default policy values */
 +	policy->cpuinfo.transition_latency = 1000000;	/* 1ms */
 +	policy->cur = cris_freq_get_cpu_frequency(0);
 +
 +	result = cpufreq_frequency_table_cpuinfo(policy, cris_freq_table);
 +	if (result)
 +		return (result);
 +
 +	cpufreq_frequency_table_get_attr(cris_freq_table, policy->cpu);
 +
 +	return 0;
  }
  
 +static int cris_freq_cpu_exit(struct cpufreq_policy *policy)
 +{
 +	cpufreq_frequency_table_put_attr(policy->cpu);
 +	return 0;
 +}
 +
 +static struct freq_attr *cris_freq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver cris_freq_driver = {
  	.get = cris_freq_get_cpu_frequency,
++<<<<<<< HEAD
 +	.verify = cris_freq_verify,
 +	.target = cris_freq_target,
++=======
+ 	.verify = cpufreq_generic_frequency_table_verify,
+ 	.target_index = cris_freq_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.init = cris_freq_cpu_init,
 -	.exit = cpufreq_generic_exit,
 +	.exit = cris_freq_cpu_exit,
  	.name = "cris_freq",
 -	.attr = cpufreq_generic_attr,
 +	.owner = THIS_MODULE,
 +	.attr = cris_freq_attr,
  };
  
  static int __init cris_freq_init(void)
diff --cc drivers/cpufreq/dbx500-cpufreq.c
index 8c005ac8b701,238b16976be1..000000000000
--- a/drivers/cpufreq/dbx500-cpufreq.c
+++ b/drivers/cpufreq/dbx500-cpufreq.c
@@@ -19,34 -19,14 +19,24 @@@
  static struct cpufreq_frequency_table *freq_table;
  static struct clk *armss_clk;
  
 +static struct freq_attr *dbx500_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
 +static int dbx500_cpufreq_verify_speed(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, freq_table);
 +}
 +
  static int dbx500_cpufreq_target(struct cpufreq_policy *policy,
- 				unsigned int target_freq,
- 				unsigned int relation)
+ 				unsigned int index)
  {
  	struct cpufreq_freqs freqs;
- 	unsigned int idx;
  	int ret;
  
- 	/* Lookup the next frequency */
- 	if (cpufreq_frequency_table_target(policy, freq_table, target_freq,
- 					relation, &idx))
- 		return -EINVAL;
- 
  	freqs.old = policy->cur;
- 	freqs.new = freq_table[idx].frequency;
- 
- 	if (freqs.old == freqs.new)
- 		return 0;
+ 	freqs.new = freq_table[index].frequency;
  
  	/* pre-change notification */
  	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
@@@ -115,8 -69,8 +105,13 @@@ static int dbx500_cpufreq_init(struct c
  
  static struct cpufreq_driver dbx500_cpufreq_driver = {
  	.flags  = CPUFREQ_STICKY | CPUFREQ_CONST_LOOPS,
++<<<<<<< HEAD
 +	.verify = dbx500_cpufreq_verify_speed,
 +	.target = dbx500_cpufreq_target,
++=======
+ 	.verify = cpufreq_generic_frequency_table_verify,
+ 	.target_index = dbx500_cpufreq_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get    = dbx500_cpufreq_getspeed,
  	.init   = dbx500_cpufreq_init,
  	.name   = "DBX500",
diff --cc drivers/cpufreq/e_powersaver.c
index 37380fb92621,b39c4ef60a7a..000000000000
--- a/drivers/cpufreq/e_powersaver.c
+++ b/drivers/cpufreq/e_powersaver.c
@@@ -179,16 -179,8 +176,12 @@@ static int eps_target(struct cpufreq_po
  		return -ENODEV;
  	centaur = eps_cpu[cpu];
  
- 	if (unlikely(cpufreq_frequency_table_target(policy,
- 			&eps_cpu[cpu]->freq_table[0],
- 			target_freq,
- 			relation,
- 			&newstate))) {
- 		return -EINVAL;
- 	}
- 
  	/* Make frequency transition */
++<<<<<<< HEAD
 +	dest_state = centaur->freq_table[newstate].index & 0xffff;
++=======
+ 	dest_state = centaur->freq_table[index].driver_data & 0xffff;
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	ret = eps_set_state(centaur, policy, dest_state);
  	if (ret)
  		printk(KERN_ERR "eps: Timeout!\n");
@@@ -421,14 -405,9 +414,19 @@@ static int eps_cpu_exit(struct cpufreq_
  	return 0;
  }
  
 +static struct freq_attr *eps_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver eps_driver = {
++<<<<<<< HEAD
 +	.verify		= eps_verify,
 +	.target		= eps_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= eps_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.init		= eps_cpu_init,
  	.exit		= eps_cpu_exit,
  	.get		= eps_get,
diff --cc drivers/cpufreq/elanfreq.c
index 658d860344b0,4ab41539514f..000000000000
--- a/drivers/cpufreq/elanfreq.c
+++ b/drivers/cpufreq/elanfreq.c
@@@ -162,33 -150,6 +150,36 @@@ static int elanfreq_target(struct cpufr
  	local_irq_enable();
  
  	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
++<<<<<<< HEAD
 +};
 +
 +
 +/**
 + *	elanfreq_validatespeed: test if frequency range is valid
 + *	@policy: the policy to validate
 + *
 + *	This function checks if a given frequency range in kHz is valid
 + *	for the hardware supported by the driver.
 + */
 +
 +static int elanfreq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, &elanfreq_table[0]);
 +}
 +
 +static int elanfreq_target(struct cpufreq_policy *policy,
 +			    unsigned int target_freq,
 +			    unsigned int relation)
 +{
 +	unsigned int newstate = 0;
 +
 +	if (cpufreq_frequency_table_target(policy, &elanfreq_table[0],
 +				target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	elanfreq_set_cpu_state(policy, newstate);
++=======
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  
  	return 0;
  }
@@@ -261,21 -206,14 +250,26 @@@ __setup("elanfreq=", elanfreq_setup)
  #endif
  
  
 +static struct freq_attr *elanfreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
 +
  static struct cpufreq_driver elanfreq_driver = {
  	.get		= elanfreq_get_cpu_frequency,
++<<<<<<< HEAD
 +	.verify		= elanfreq_verify,
 +	.target		= elanfreq_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= elanfreq_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.init		= elanfreq_cpu_init,
 -	.exit		= cpufreq_generic_exit,
 +	.exit		= elanfreq_cpu_exit,
  	.name		= "elanfreq",
 -	.attr		= cpufreq_generic_attr,
 +	.owner		= THIS_MODULE,
 +	.attr		= elanfreq_attr,
  };
  
  static const struct x86_cpu_id elan_id[] = {
diff --cc drivers/cpufreq/exynos-cpufreq.c
index 475b4f607f0d,9982fcb82257..000000000000
--- a/drivers/cpufreq/exynos-cpufreq.c
+++ b/drivers/cpufreq/exynos-cpufreq.c
@@@ -241,38 -226,18 +226,43 @@@ static struct notifier_block exynos_cpu
  
  static int exynos_cpufreq_cpu_init(struct cpufreq_policy *policy)
  {
 -	return cpufreq_generic_init(policy, exynos_info->freq_table, 100000);
 +	policy->cur = policy->min = policy->max = exynos_getspeed(policy->cpu);
 +
 +	cpufreq_frequency_table_get_attr(exynos_info->freq_table, policy->cpu);
 +
 +	/* set the transition latency value */
 +	policy->cpuinfo.transition_latency = 100000;
 +
 +	cpumask_setall(policy->cpus);
 +
 +	return cpufreq_frequency_table_cpuinfo(policy, exynos_info->freq_table);
 +}
 +
 +static int exynos_cpufreq_cpu_exit(struct cpufreq_policy *policy)
 +{
 +	cpufreq_frequency_table_put_attr(policy->cpu);
 +	return 0;
  }
  
 +static struct freq_attr *exynos_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver exynos_driver = {
  	.flags		= CPUFREQ_STICKY,
++<<<<<<< HEAD
 +	.verify		= exynos_verify_speed,
 +	.target		= exynos_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= exynos_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= exynos_getspeed,
  	.init		= exynos_cpufreq_cpu_init,
 -	.exit		= cpufreq_generic_exit,
 +	.exit		= exynos_cpufreq_cpu_exit,
  	.name		= "exynos_cpufreq",
 -	.attr		= cpufreq_generic_attr,
 +	.attr		= exynos_cpufreq_attr,
  #ifdef CONFIG_PM
  	.suspend	= exynos_cpufreq_suspend,
  	.resume		= exynos_cpufreq_resume,
diff --cc drivers/cpufreq/exynos5440-cpufreq.c
index 0c74018eda47,1bf9b060d522..000000000000
--- a/drivers/cpufreq/exynos5440-cpufreq.c
+++ b/drivers/cpufreq/exynos5440-cpufreq.c
@@@ -340,11 -313,13 +332,16 @@@ static int exynos_cpufreq_cpu_init(stru
  
  static struct cpufreq_driver exynos_driver = {
  	.flags		= CPUFREQ_STICKY,
++<<<<<<< HEAD
 +	.verify		= exynos_verify_speed,
 +	.target		= exynos_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= exynos_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= exynos_getspeed,
  	.init		= exynos_cpufreq_cpu_init,
 -	.exit		= cpufreq_generic_exit,
  	.name		= CPUFREQ_NAME,
 -	.attr		= cpufreq_generic_attr,
  };
  
  static const struct of_device_id exynos_cpufreq_match[] = {
diff --cc drivers/cpufreq/ia64-acpi-cpufreq.c
index c0075dbaa633,4695fa22406a..000000000000
--- a/drivers/cpufreq/ia64-acpi-cpufreq.c
+++ b/drivers/cpufreq/ia64-acpi-cpufreq.c
@@@ -227,42 -227,11 +227,27 @@@ acpi_cpufreq_get 
  static int
  acpi_cpufreq_target (
  	struct cpufreq_policy   *policy,
- 	unsigned int target_freq,
- 	unsigned int relation)
+ 	unsigned int index)
  {
- 	struct cpufreq_acpi_io *data = acpi_io_data[policy->cpu];
- 	unsigned int next_state = 0;
- 	unsigned int result = 0;
- 
- 	pr_debug("acpi_cpufreq_setpolicy\n");
- 
- 	result = cpufreq_frequency_table_target(policy,
- 			data->freq_table, target_freq, relation, &next_state);
- 	if (result)
- 		return (result);
- 
- 	result = processor_set_freq(data, policy, next_state);
- 
- 	return (result);
+ 	return processor_set_freq(acpi_io_data[policy->cpu], policy, index);
  }
  
- 
 +static int
 +acpi_cpufreq_verify (
 +	struct cpufreq_policy   *policy)
 +{
 +	unsigned int result = 0;
 +	struct cpufreq_acpi_io *data = acpi_io_data[policy->cpu];
 +
 +	pr_debug("acpi_cpufreq_verify\n");
 +
 +	result = cpufreq_frequency_table_verify(policy,
 +			data->freq_table);
 +
 +	return (result);
 +}
 +
 +
  static int
  acpi_cpufreq_cpu_init (
  	struct cpufreq_policy   *policy)
@@@ -396,15 -362,9 +381,20 @@@ acpi_cpufreq_cpu_exit 
  }
  
  
 +static struct freq_attr* acpi_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
 +
  static struct cpufreq_driver acpi_cpufreq_driver = {
++<<<<<<< HEAD
 +	.verify 	= acpi_cpufreq_verify,
 +	.target 	= acpi_cpufreq_target,
++=======
+ 	.verify 	= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= acpi_cpufreq_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get 		= acpi_cpufreq_get,
  	.init		= acpi_cpufreq_cpu_init,
  	.exit		= acpi_cpufreq_cpu_exit,
diff --cc drivers/cpufreq/imx6q-cpufreq.c
index b78bc35973ba,07af3b0de069..000000000000
--- a/drivers/cpufreq/imx6q-cpufreq.c
+++ b/drivers/cpufreq/imx6q-cpufreq.c
@@@ -44,34 -40,19 +44,27 @@@ static unsigned int imx6q_get_speed(uns
  	return clk_get_rate(arm_clk) / 1000;
  }
  
- static int imx6q_set_target(struct cpufreq_policy *policy,
- 			    unsigned int target_freq, unsigned int relation)
+ static int imx6q_set_target(struct cpufreq_policy *policy, unsigned int index)
  {
  	struct cpufreq_freqs freqs;
 -	struct dev_pm_opp *opp;
 +	struct opp *opp;
  	unsigned long freq_hz, volt, volt_old;
- 	unsigned int index;
  	int ret;
  
- 	ret = cpufreq_frequency_table_target(policy, freq_table, target_freq,
- 					     relation, &index);
- 	if (ret) {
- 		dev_err(cpu_dev, "failed to match target frequency %d: %d\n",
- 			target_freq, ret);
- 		return ret;
- 	}
- 
  	freqs.new = freq_table[index].frequency;
  	freq_hz = freqs.new * 1000;
  	freqs.old = clk_get_rate(arm_clk) / 1000;
  
++<<<<<<< HEAD
 +	if (freqs.old == freqs.new)
 +		return 0;
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +
++=======
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	rcu_read_lock();
 -	opp = dev_pm_opp_find_freq_ceil(cpu_dev, &freq_hz);
 +	opp = opp_find_freq_ceil(cpu_dev, &freq_hz);
  	if (IS_ERR(opp)) {
  		rcu_read_unlock();
  		dev_err(cpu_dev, "failed to find OPP for %ld\n", freq_hz);
@@@ -170,41 -141,17 +163,46 @@@
  
  static int imx6q_cpufreq_init(struct cpufreq_policy *policy)
  {
 -	return cpufreq_generic_init(policy, freq_table, transition_latency);
 +	int ret;
 +
 +	ret = cpufreq_frequency_table_cpuinfo(policy, freq_table);
 +	if (ret) {
 +		dev_err(cpu_dev, "invalid frequency table: %d\n", ret);
 +		return ret;
 +	}
 +
 +	policy->cpuinfo.transition_latency = transition_latency;
 +	policy->cur = clk_get_rate(arm_clk) / 1000;
 +	cpumask_setall(policy->cpus);
 +	cpufreq_frequency_table_get_attr(freq_table, policy->cpu);
 +
 +	return 0;
 +}
 +
 +static int imx6q_cpufreq_exit(struct cpufreq_policy *policy)
 +{
 +	cpufreq_frequency_table_put_attr(policy->cpu);
 +	return 0;
  }
  
 +static struct freq_attr *imx6q_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver imx6q_cpufreq_driver = {
++<<<<<<< HEAD
 +	.verify = imx6q_verify_speed,
 +	.target = imx6q_set_target,
++=======
+ 	.verify = cpufreq_generic_frequency_table_verify,
+ 	.target_index = imx6q_set_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get = imx6q_get_speed,
  	.init = imx6q_cpufreq_init,
 -	.exit = cpufreq_generic_exit,
 +	.exit = imx6q_cpufreq_exit,
  	.name = "imx6q-cpufreq",
 -	.attr = cpufreq_generic_attr,
 +	.attr = imx6q_cpufreq_attr,
  };
  
  static int imx6q_cpufreq_probe(struct platform_device *pdev)
diff --cc drivers/cpufreq/kirkwood-cpufreq.c
index b2644af985ec,0ae4dd7e1f2d..000000000000
--- a/drivers/cpufreq/kirkwood-cpufreq.c
+++ b/drivers/cpufreq/kirkwood-cpufreq.c
@@@ -55,11 -55,11 +55,11 @@@ static unsigned int kirkwood_cpufreq_ge
  	return kirkwood_freq_table[0].frequency;
  }
  
- static void kirkwood_cpufreq_set_cpu_state(struct cpufreq_policy *policy,
- 		unsigned int index)
+ static int kirkwood_cpufreq_target(struct cpufreq_policy *policy,
+ 			    unsigned int index)
  {
  	struct cpufreq_freqs freqs;
 -	unsigned int state = kirkwood_freq_table[index].driver_data;
 +	unsigned int state = kirkwood_freq_table[index].index;
  	unsigned long reg;
  
  	freqs.old = kirkwood_cpufreq_get_cpu_frequency(0);
@@@ -100,24 -100,6 +100,27 @@@
  		local_irq_enable();
  	}
  	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
++<<<<<<< HEAD
 +};
 +
 +static int kirkwood_cpufreq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, kirkwood_freq_table);
 +}
 +
 +static int kirkwood_cpufreq_target(struct cpufreq_policy *policy,
 +			    unsigned int target_freq,
 +			    unsigned int relation)
 +{
 +	unsigned int index = 0;
 +
 +	if (cpufreq_frequency_table_target(policy, kirkwood_freq_table,
 +				target_freq, relation, &index))
 +		return -EINVAL;
 +
 +	kirkwood_cpufreq_set_cpu_state(policy, index);
++=======
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  
  	return 0;
  }
@@@ -125,41 -107,17 +128,46 @@@
  /* Module init and exit code */
  static int kirkwood_cpufreq_cpu_init(struct cpufreq_policy *policy)
  {
 -	return cpufreq_generic_init(policy, kirkwood_freq_table, 5000);
 +	int result;
 +
 +	/* cpuinfo and default policy values */
 +	policy->cpuinfo.transition_latency = 5000; /* 5uS */
 +	policy->cur = kirkwood_cpufreq_get_cpu_frequency(0);
 +
 +	result = cpufreq_frequency_table_cpuinfo(policy, kirkwood_freq_table);
 +	if (result)
 +		return result;
 +
 +	cpufreq_frequency_table_get_attr(kirkwood_freq_table, policy->cpu);
 +
 +	return 0;
 +}
 +
 +static int kirkwood_cpufreq_cpu_exit(struct cpufreq_policy *policy)
 +{
 +	cpufreq_frequency_table_put_attr(policy->cpu);
 +	return 0;
  }
  
 +static struct freq_attr *kirkwood_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver kirkwood_cpufreq_driver = {
  	.get	= kirkwood_cpufreq_get_cpu_frequency,
++<<<<<<< HEAD
 +	.verify	= kirkwood_cpufreq_verify,
 +	.target	= kirkwood_cpufreq_target,
++=======
+ 	.verify	= cpufreq_generic_frequency_table_verify,
+ 	.target_index = kirkwood_cpufreq_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.init	= kirkwood_cpufreq_cpu_init,
 -	.exit	= cpufreq_generic_exit,
 +	.exit	= kirkwood_cpufreq_cpu_exit,
  	.name	= "kirkwood-cpufreq",
 -	.attr	= cpufreq_generic_attr,
 +	.owner	= THIS_MODULE,
 +	.attr	= kirkwood_cpufreq_attr,
  };
  
  static int kirkwood_cpufreq_probe(struct platform_device *pdev)
diff --cc drivers/cpufreq/longhaul.c
index 51a0420c0c78,45bafddfd8ea..000000000000
--- a/drivers/cpufreq/longhaul.c
+++ b/drivers/cpufreq/longhaul.c
@@@ -625,16 -625,9 +625,15 @@@ static void longhaul_setup_voltagescali
  }
  
  
 +static int longhaul_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, longhaul_table);
 +}
 +
 +
  static int longhaul_target(struct cpufreq_policy *policy,
- 			    unsigned int target_freq, unsigned int relation)
+ 			    unsigned int table_index)
  {
- 	unsigned int table_index = 0;
  	unsigned int i;
  	unsigned int dir = 0;
  	u8 vid, current_vid;
@@@ -919,37 -904,18 +910,42 @@@ static int longhaul_cpu_init(struct cpu
  		longhaul_setup_voltagescaling();
  
  	policy->cpuinfo.transition_latency = 200000;	/* nsec */
 +	policy->cur = calc_speed(longhaul_get_cpu_mult());
 +
 +	ret = cpufreq_frequency_table_cpuinfo(policy, longhaul_table);
 +	if (ret)
 +		return ret;
 +
 +	cpufreq_frequency_table_get_attr(longhaul_table, policy->cpu);
  
 -	return cpufreq_table_validate_and_show(policy, longhaul_table);
 +	return 0;
  }
  
 +static int longhaul_cpu_exit(struct cpufreq_policy *policy)
 +{
 +	cpufreq_frequency_table_put_attr(policy->cpu);
 +	return 0;
 +}
 +
 +static struct freq_attr *longhaul_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver longhaul_driver = {
++<<<<<<< HEAD
 +	.verify	= longhaul_verify,
 +	.target	= longhaul_target,
++=======
+ 	.verify	= cpufreq_generic_frequency_table_verify,
+ 	.target_index = longhaul_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get	= longhaul_get,
  	.init	= longhaul_cpu_init,
 -	.exit	= cpufreq_generic_exit,
 +	.exit	= longhaul_cpu_exit,
  	.name	= "longhaul",
 -	.attr	= cpufreq_generic_attr,
 +	.owner	= THIS_MODULE,
 +	.attr	= longhaul_attr,
  };
  
  static const struct x86_cpu_id longhaul_id[] = {
diff --cc drivers/cpufreq/loongson2_cpufreq.c
index f92b02ae20be,41a8e2cdf940..000000000000
--- a/drivers/cpufreq/loongson2_cpufreq.c
+++ b/drivers/cpufreq/loongson2_cpufreq.c
@@@ -65,18 -63,12 +63,18 @@@ static int loongson2_cpufreq_target(str
  	cpus_allowed = current->cpus_allowed;
  	set_cpus_allowed_ptr(current, cpumask_of(cpu));
  
- 	if (cpufreq_frequency_table_target
- 	    (policy, &loongson2_clockmod_table[0], target_freq, relation,
- 	     &newstate))
- 		return -EINVAL;
- 
  	freq =
  	    ((cpu_clock_freq / 1000) *
++<<<<<<< HEAD
 +	     loongson2_clockmod_table[newstate].index) / 8;
 +	if (freq < policy->min || freq > policy->max)
 +		return -EINVAL;
++=======
+ 	     loongson2_clockmod_table[index].driver_data) / 8;
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  
- 	pr_debug("cpufreq: requested frequency %u Hz\n", target_freq * 1000);
+ 	pr_debug("cpufreq: requested frequency %u Hz\n",
+ 			loongson2_clockmod_table[index].frequency * 1000);
  
  	freqs.old = loongson2_cpufreq_get(cpu);
  	freqs.new = freq;
@@@ -152,20 -130,14 +147,25 @@@ static int loongson2_cpufreq_exit(struc
  	return 0;
  }
  
 +static struct freq_attr *loongson2_table_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver loongson2_cpufreq_driver = {
 +	.owner = THIS_MODULE,
  	.name = "loongson2",
  	.init = loongson2_cpufreq_cpu_init,
++<<<<<<< HEAD
 +	.verify = loongson2_cpufreq_verify,
 +	.target = loongson2_cpufreq_target,
++=======
+ 	.verify = cpufreq_generic_frequency_table_verify,
+ 	.target_index = loongson2_cpufreq_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get = loongson2_cpufreq_get,
  	.exit = loongson2_cpufreq_exit,
 -	.attr = cpufreq_generic_attr,
 +	.attr = loongson2_table_attr,
  };
  
  static struct platform_device_id platform_device_ids[] = {
diff --cc drivers/cpufreq/maple-cpufreq.c
index cdd62915efaf,4e2da0874bfb..000000000000
--- a/drivers/cpufreq/maple-cpufreq.c
+++ b/drivers/cpufreq/maple-cpufreq.c
@@@ -135,15 -130,9 +135,14 @@@ static int maple_scom_query_freq(void
   * Common interface to the cpufreq core
   */
  
 +static int maple_cpufreq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, maple_cpu_freqs);
 +}
 +
  static int maple_cpufreq_target(struct cpufreq_policy *policy,
- 	unsigned int target_freq, unsigned int relation)
+ 	unsigned int index)
  {
- 	unsigned int newstate = 0;
  	struct cpufreq_freqs freqs;
  	int rc;
  
@@@ -175,28 -157,17 +167,33 @@@ static unsigned int maple_cpufreq_get_s
  
  static int maple_cpufreq_cpu_init(struct cpufreq_policy *policy)
  {
 -	return cpufreq_generic_init(policy, maple_cpu_freqs, 12000);
 +	policy->cpuinfo.transition_latency = 12000;
 +	policy->cur = maple_cpu_freqs[maple_scom_query_freq()].frequency;
 +	/* secondary CPUs are tied to the primary one by the
 +	 * cpufreq core if in the secondary policy we tell it that
 +	 * it actually must be one policy together with all others. */
 +	cpumask_setall(policy->cpus);
 +	cpufreq_frequency_table_get_attr(maple_cpu_freqs, policy->cpu);
 +
 +	return cpufreq_frequency_table_cpuinfo(policy,
 +		maple_cpu_freqs);
  }
  
 +
  static struct cpufreq_driver maple_cpufreq_driver = {
  	.name		= "maple",
 +	.owner		= THIS_MODULE,
  	.flags		= CPUFREQ_CONST_LOOPS,
  	.init		= maple_cpufreq_cpu_init,
++<<<<<<< HEAD
 +	.verify		= maple_cpufreq_verify,
 +	.target		= maple_cpufreq_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= maple_cpufreq_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= maple_cpufreq_get_speed,
 -	.attr		= cpufreq_generic_attr,
 +	.attr		= maple_cpu_freqs_attr,
  };
  
  static int __init maple_cpufreq_init(void)
diff --cc drivers/cpufreq/omap-cpufreq.c
index 4b81d3e9f0ab,b5512712298f..000000000000
--- a/drivers/cpufreq/omap-cpufreq.c
+++ b/drivers/cpufreq/omap-cpufreq.c
@@@ -58,44 -51,16 +58,19 @@@ static unsigned int omap_getspeed(unsig
  	return rate;
  }
  
- static int omap_target(struct cpufreq_policy *policy,
- 		       unsigned int target_freq,
- 		       unsigned int relation)
+ static int omap_target(struct cpufreq_policy *policy, unsigned int index)
  {
- 	unsigned int i;
  	int r, ret = 0;
  	struct cpufreq_freqs freqs;
 -	struct dev_pm_opp *opp;
 +	struct opp *opp;
  	unsigned long freq, volt = 0, volt_old = 0, tol = 0;
  
- 	if (!freq_table) {
- 		dev_err(mpu_dev, "%s: cpu%d: no freq table!\n", __func__,
- 				policy->cpu);
- 		return -EINVAL;
- 	}
- 
- 	ret = cpufreq_frequency_table_target(policy, freq_table, target_freq,
- 			relation, &i);
- 	if (ret) {
- 		dev_dbg(mpu_dev, "%s: cpu%d: no freq match for %d(ret=%d)\n",
- 			__func__, policy->cpu, target_freq, ret);
- 		return ret;
- 	}
- 	freqs.new = freq_table[i].frequency;
- 	if (!freqs.new) {
- 		dev_err(mpu_dev, "%s: cpu%d: no match for freq %d\n", __func__,
- 			policy->cpu, target_freq);
- 		return -EINVAL;
- 	}
- 
  	freqs.old = omap_getspeed(policy->cpu);
- 
- 	if (freqs.old == freqs.new && policy->cur == freqs.new)
- 		return ret;
+ 	freqs.new = freq_table[index].frequency;
  
 +	/* notifiers */
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +
  	freq = freqs.new * 1000;
  	ret = clk_round_rate(mpu_clk, freq);
  	if (IS_ERR_VALUE(ret)) {
@@@ -228,15 -172,10 +203,20 @@@ static int omap_cpu_exit(struct cpufreq
  	return 0;
  }
  
 +static struct freq_attr *omap_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver omap_driver = {
  	.flags		= CPUFREQ_STICKY,
++<<<<<<< HEAD
 +	.verify		= omap_verify_speed,
 +	.target		= omap_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= omap_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= omap_getspeed,
  	.init		= omap_cpu_init,
  	.exit		= omap_cpu_exit,
diff --cc drivers/cpufreq/pasemi-cpufreq.c
index b704da404067,17424ddc7f67..000000000000
--- a/drivers/cpufreq/pasemi-cpufreq.c
+++ b/drivers/cpufreq/pasemi-cpufreq.c
@@@ -253,25 -239,12 +253,17 @@@ static int pas_cpufreq_cpu_exit(struct 
  	return 0;
  }
  
 +static int pas_cpufreq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, pas_freqs);
 +}
 +
  static int pas_cpufreq_target(struct cpufreq_policy *policy,
- 			      unsigned int target_freq,
- 			      unsigned int relation)
+ 			      unsigned int pas_astate_new)
  {
  	struct cpufreq_freqs freqs;
- 	int pas_astate_new;
  	int i;
  
- 	cpufreq_frequency_table_target(policy,
- 				       pas_freqs,
- 				       target_freq,
- 				       relation,
- 				       &pas_astate_new);
- 
  	freqs.old = policy->cur;
  	freqs.new = pas_freqs[pas_astate_new].frequency;
  
@@@ -301,9 -273,9 +293,15 @@@ static struct cpufreq_driver pas_cpufre
  	.flags		= CPUFREQ_CONST_LOOPS,
  	.init		= pas_cpufreq_cpu_init,
  	.exit		= pas_cpufreq_cpu_exit,
++<<<<<<< HEAD
 +	.verify		= pas_cpufreq_verify,
 +	.target		= pas_cpufreq_target,
 +	.attr		= pas_cpu_freqs_attr,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= pas_cpufreq_target,
+ 	.attr		= cpufreq_generic_attr,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  };
  
  /*
diff --cc drivers/cpufreq/pmac32-cpufreq.c
index 3104fad82480,05f705e1b7a2..000000000000
--- a/drivers/cpufreq/pmac32-cpufreq.c
+++ b/drivers/cpufreq/pmac32-cpufreq.c
@@@ -377,23 -373,12 +377,17 @@@ static unsigned int pmac_cpufreq_get_sp
  	return cur_freq;
  }
  
 +static int pmac_cpufreq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, pmac_cpu_freqs);
 +}
 +
  static int pmac_cpufreq_target(	struct cpufreq_policy *policy,
- 					unsigned int target_freq,
- 					unsigned int relation)
+ 					unsigned int index)
  {
- 	unsigned int    newstate = 0;
  	int		rc;
  
- 	if (cpufreq_frequency_table_target(policy, pmac_cpu_freqs,
- 			target_freq, relation, &newstate))
- 		return -EINVAL;
- 
- 	rc = do_set_cpu_speed(policy, newstate, 1);
+ 	rc = do_set_cpu_speed(policy, index, 1);
  
  	ppc_proc_freq = cur_freq * 1000ul;
  	return rc;
@@@ -468,8 -446,8 +462,13 @@@ static int pmac_cpufreq_resume(struct c
  }
  
  static struct cpufreq_driver pmac_cpufreq_driver = {
++<<<<<<< HEAD
 +	.verify 	= pmac_cpufreq_verify,
 +	.target 	= pmac_cpufreq_target,
++=======
+ 	.verify 	= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= pmac_cpufreq_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= pmac_cpufreq_get_speed,
  	.init		= pmac_cpufreq_cpu_init,
  	.suspend	= pmac_cpufreq_suspend,
diff --cc drivers/cpufreq/pmac64-cpufreq.c
index 7ba423431cfe,234b598ce416..000000000000
--- a/drivers/cpufreq/pmac64-cpufreq.c
+++ b/drivers/cpufreq/pmac64-cpufreq.c
@@@ -316,15 -312,8 +316,18 @@@ static int g5_pfunc_query_freq(void
   * Common interface to the cpufreq core
   */
  
++<<<<<<< HEAD
 +static int g5_cpufreq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, g5_cpu_freqs);
 +}
 +
 +static int g5_cpufreq_target(struct cpufreq_policy *policy,
 +	unsigned int target_freq, unsigned int relation)
++=======
+ static int g5_cpufreq_target(struct cpufreq_policy *policy, unsigned int index)
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  {
- 	unsigned int newstate = 0;
  	struct cpufreq_freqs freqs;
  	int rc;
  
@@@ -356,28 -338,17 +352,33 @@@ static unsigned int g5_cpufreq_get_spee
  
  static int g5_cpufreq_cpu_init(struct cpufreq_policy *policy)
  {
 -	return cpufreq_generic_init(policy, g5_cpu_freqs, transition_latency);
 +	policy->cpuinfo.transition_latency = transition_latency;
 +	policy->cur = g5_cpu_freqs[g5_query_freq()].frequency;
 +	/* secondary CPUs are tied to the primary one by the
 +	 * cpufreq core if in the secondary policy we tell it that
 +	 * it actually must be one policy together with all others. */
 +	cpumask_copy(policy->cpus, cpu_online_mask);
 +	cpufreq_frequency_table_get_attr(g5_cpu_freqs, policy->cpu);
 +
 +	return cpufreq_frequency_table_cpuinfo(policy,
 +		g5_cpu_freqs);
  }
  
 +
  static struct cpufreq_driver g5_cpufreq_driver = {
  	.name		= "powermac",
 +	.owner		= THIS_MODULE,
  	.flags		= CPUFREQ_CONST_LOOPS,
  	.init		= g5_cpufreq_cpu_init,
++<<<<<<< HEAD
 +	.verify		= g5_cpufreq_verify,
 +	.target		= g5_cpufreq_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= g5_cpufreq_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= g5_cpufreq_get_speed,
 -	.attr 		= cpufreq_generic_attr,
 +	.attr 		= g5_cpu_freqs_attr,
  };
  
  
diff --cc drivers/cpufreq/powernow-k6.c
index a5b23da513dc,643e7952cad3..000000000000
--- a/drivers/cpufreq/powernow-k6.c
+++ b/drivers/cpufreq/powernow-k6.c
@@@ -100,44 -100,6 +100,47 @@@ static int powernow_k6_target(struct cp
  
  	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
  
++<<<<<<< HEAD
 +	return;
 +}
 +
 +
 +/**
 + * powernow_k6_verify - verifies a new CPUfreq policy
 + * @policy: new policy
 + *
 + * Policy must be within lowest and highest possible CPU Frequency,
 + * and at least one possible state must be within min and max.
 + */
 +static int powernow_k6_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, &clock_ratio[0]);
 +}
 +
 +
 +/**
 + * powernow_k6_setpolicy - sets a new CPUFreq policy
 + * @policy: new policy
 + * @target_freq: the target frequency
 + * @relation: how that frequency relates to achieved frequency
 + *  (CPUFREQ_RELATION_L or CPUFREQ_RELATION_H)
 + *
 + * sets a new CPUFreq policy
 + */
 +static int powernow_k6_target(struct cpufreq_policy *policy,
 +			       unsigned int target_freq,
 +			       unsigned int relation)
 +{
 +	unsigned int newstate = 0;
 +
 +	if (cpufreq_frequency_table_target(policy, &clock_ratio[0],
 +				target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	powernow_k6_set_state(policy, newstate);
 +
++=======
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	return 0;
  }
  
@@@ -187,14 -149,9 +190,19 @@@ static unsigned int powernow_k6_get(uns
  	return ret;
  }
  
 +static struct freq_attr *powernow_k6_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver powernow_k6_driver = {
++<<<<<<< HEAD
 +	.verify		= powernow_k6_verify,
 +	.target		= powernow_k6_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= powernow_k6_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.init		= powernow_k6_cpu_init,
  	.exit		= powernow_k6_cpu_exit,
  	.get		= powernow_k6_get,
diff --cc drivers/cpufreq/powernow-k7.c
index e369f59f7aa1,946708a1d745..000000000000
--- a/drivers/cpufreq/powernow-k7.c
+++ b/drivers/cpufreq/powernow-k7.c
@@@ -534,27 -535,6 +536,30 @@@ static int powernow_decode_bios(int max
  }
  
  
++<<<<<<< HEAD
 +static int powernow_target(struct cpufreq_policy *policy,
 +			    unsigned int target_freq,
 +			    unsigned int relation)
 +{
 +	unsigned int newstate;
 +
 +	if (cpufreq_frequency_table_target(policy, powernow_table, target_freq,
 +				relation, &newstate))
 +		return -EINVAL;
 +
 +	change_speed(policy, newstate);
 +
 +	return 0;
 +}
 +
 +
 +static int powernow_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, powernow_table);
 +}
 +
++=======
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  /*
   * We use the fact that the bus frequency is somehow
   * a multiple of 100000/3 khz, then we compute sgtc according
@@@ -698,14 -678,9 +703,19 @@@ static int powernow_cpu_exit(struct cpu
  	return 0;
  }
  
 +static struct freq_attr *powernow_table_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver powernow_driver = {
++<<<<<<< HEAD
 +	.verify		= powernow_verify,
 +	.target		= powernow_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= powernow_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= powernow_get,
  #ifdef CONFIG_X86_POWERNOW_K7_ACPI
  	.bios_limit	= acpi_processor_get_bios_limit,
diff --cc drivers/cpufreq/powernow-k8.c
index eefb04acff89,62a1ce47d3df..000000000000
--- a/drivers/cpufreq/powernow-k8.c
+++ b/drivers/cpufreq/powernow-k8.c
@@@ -1222,14 -1203,9 +1214,19 @@@ out
  	return khz;
  }
  
 +static struct freq_attr *powernow_k8_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver cpufreq_amd64_driver = {
++<<<<<<< HEAD
 +	.verify		= powernowk8_verify,
 +	.target		= powernowk8_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= powernowk8_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.bios_limit	= acpi_processor_get_bios_limit,
  	.init		= powernowk8_cpu_init,
  	.exit		= powernowk8_cpu_exit,
diff --cc drivers/cpufreq/ppc_cbe_cpufreq.c
index 5936f8d6f2cc,52f707d5f458..000000000000
--- a/drivers/cpufreq/ppc_cbe_cpufreq.c
+++ b/drivers/cpufreq/ppc_cbe_cpufreq.c
@@@ -176,12 -155,11 +168,17 @@@ static int cbe_cpufreq_target(struct cp
  }
  
  static struct cpufreq_driver cbe_cpufreq_driver = {
++<<<<<<< HEAD
 +	.verify		= cbe_cpufreq_verify,
 +	.target		= cbe_cpufreq_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= cbe_cpufreq_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.init		= cbe_cpufreq_cpu_init,
 -	.exit		= cpufreq_generic_exit,
 +	.exit		= cbe_cpufreq_cpu_exit,
  	.name		= "cbe-cpufreq",
 +	.owner		= THIS_MODULE,
  	.flags		= CPUFREQ_CONST_LOOPS,
  };
  
diff --cc drivers/cpufreq/pxa2xx-cpufreq.c
index 9e5bc8e388a0,183bc13f13e5..000000000000
--- a/drivers/cpufreq/pxa2xx-cpufreq.c
+++ b/drivers/cpufreq/pxa2xx-cpufreq.c
@@@ -464,9 -438,10 +455,14 @@@ static int pxa_cpufreq_init(struct cpuf
  }
  
  static struct cpufreq_driver pxa_cpufreq_driver = {
++<<<<<<< HEAD
 +	.verify	= pxa_verify_policy,
 +	.target	= pxa_set_target,
++=======
+ 	.verify	= cpufreq_generic_frequency_table_verify,
+ 	.target_index = pxa_set_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.init	= pxa_cpufreq_init,
 -	.exit	= cpufreq_generic_exit,
  	.get	= pxa_cpufreq_get,
  	.name	= "PXA2xx",
  };
diff --cc drivers/cpufreq/pxa3xx-cpufreq.c
index 15d60f857ad5,132e37d578c2..000000000000
--- a/drivers/cpufreq/pxa3xx-cpufreq.c
+++ b/drivers/cpufreq/pxa3xx-cpufreq.c
@@@ -228,9 -213,10 +217,14 @@@ static int pxa3xx_cpufreq_init(struct c
  }
  
  static struct cpufreq_driver pxa3xx_cpufreq_driver = {
++<<<<<<< HEAD
 +	.verify		= pxa3xx_cpufreq_verify,
 +	.target		= pxa3xx_cpufreq_set,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= pxa3xx_cpufreq_set,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.init		= pxa3xx_cpufreq_init,
 -	.exit		= cpufreq_generic_exit,
  	.get		= pxa3xx_cpufreq_get,
  	.name		= "pxa3xx-cpufreq",
  };
diff --cc drivers/cpufreq/s3c2416-cpufreq.c
index 4f1881eee3f1,4188accd34ab..000000000000
--- a/drivers/cpufreq/s3c2416-cpufreq.c
+++ b/drivers/cpufreq/s3c2416-cpufreq.c
@@@ -236,15 -225,7 +235,18 @@@ static int s3c2416_cpufreq_set_target(s
  
  	mutex_lock(&cpufreq_lock);
  
++<<<<<<< HEAD
 +	pr_debug("cpufreq: to %dKHz, relation %d\n", target_freq, relation);
 +
 +	ret = cpufreq_frequency_table_target(policy, s3c_freq->freq_table,
 +					     target_freq, relation, &i);
 +	if (ret != 0)
 +		goto out;
 +
 +	idx = s3c_freq->freq_table[i].index;
++=======
+ 	idx = s3c_freq->freq_table[index].driver_data;
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  
  	if (idx == SOURCE_HCLK)
  		to_dvs = 1;
@@@ -518,16 -493,10 +520,21 @@@ err_hclk
  	return ret;
  }
  
 +static struct freq_attr *s3c2416_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver s3c2416_cpufreq_driver = {
 +	.owner		= THIS_MODULE,
  	.flags          = 0,
++<<<<<<< HEAD
 +	.verify		= s3c2416_cpufreq_verify_speed,
 +	.target		= s3c2416_cpufreq_set_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= s3c2416_cpufreq_set_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= s3c2416_cpufreq_get_speed,
  	.init		= s3c2416_cpufreq_driver_init,
  	.name		= "s3c2416",
diff --cc drivers/cpufreq/s3c64xx-cpufreq.c
index 27cacb524796,8bdcf32a4418..000000000000
--- a/drivers/cpufreq/s3c64xx-cpufreq.c
+++ b/drivers/cpufreq/s3c64xx-cpufreq.c
@@@ -78,19 -69,10 +77,17 @@@ static int s3c64xx_cpufreq_set_target(s
  	struct cpufreq_freqs freqs;
  	struct s3c64xx_dvfs *dvfs;
  
- 	ret = cpufreq_frequency_table_target(policy, s3c64xx_freq_table,
- 					     target_freq, relation, &i);
- 	if (ret != 0)
- 		return ret;
- 
  	freqs.old = clk_get_rate(armclk) / 1000;
- 	freqs.new = s3c64xx_freq_table[i].frequency;
+ 	freqs.new = s3c64xx_freq_table[index].frequency;
  	freqs.flags = 0;
++<<<<<<< HEAD
 +	dvfs = &s3c64xx_dvfs_table[s3c64xx_freq_table[i].index];
 +
 +	if (freqs.old == freqs.new)
 +		return 0;
++=======
+ 	dvfs = &s3c64xx_dvfs_table[s3c64xx_freq_table[index].driver_data];
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  
  	pr_debug("Transition %d-%dkHz\n", freqs.old, freqs.new);
  
@@@ -259,10 -242,9 +256,15 @@@ static int s3c64xx_cpufreq_driver_init(
  }
  
  static struct cpufreq_driver s3c64xx_cpufreq_driver = {
 +	.owner		= THIS_MODULE,
  	.flags          = 0,
++<<<<<<< HEAD
 +	.verify		= s3c64xx_cpufreq_verify_speed,
 +	.target		= s3c64xx_cpufreq_set_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= s3c64xx_cpufreq_set_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= s3c64xx_cpufreq_get_speed,
  	.init		= s3c64xx_cpufreq_driver_init,
  	.name		= "s3c",
diff --cc drivers/cpufreq/s5pv210-cpufreq.c
index 5c7757073793,5978b94e0340..000000000000
--- a/drivers/cpufreq/s5pv210-cpufreq.c
+++ b/drivers/cpufreq/s5pv210-cpufreq.c
@@@ -605,8 -565,8 +579,13 @@@ static int s5pv210_cpufreq_reboot_notif
  
  static struct cpufreq_driver s5pv210_driver = {
  	.flags		= CPUFREQ_STICKY,
++<<<<<<< HEAD
 +	.verify		= s5pv210_verify_speed,
 +	.target		= s5pv210_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= s5pv210_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= s5pv210_getspeed,
  	.init		= s5pv210_cpu_init,
  	.name		= "s5pv210",
diff --cc drivers/cpufreq/sa1100-cpufreq.c
index cff18e87ca58,b0da1fe40b1d..000000000000
--- a/drivers/cpufreq/sa1100-cpufreq.c
+++ b/drivers/cpufreq/sa1100-cpufreq.c
@@@ -229,8 -207,8 +213,13 @@@ static int __init sa1100_cpu_init(struc
  
  static struct cpufreq_driver sa1100_driver __refdata = {
  	.flags		= CPUFREQ_STICKY,
++<<<<<<< HEAD
 +	.verify		= sa11x0_verify_speed,
 +	.target		= sa1100_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= sa1100_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= sa11x0_getspeed,
  	.init		= sa1100_cpu_init,
  	.name		= "sa1100",
diff --cc drivers/cpufreq/sa1110-cpufreq.c
index 39c90b6f4286,55b1818c3e49..000000000000
--- a/drivers/cpufreq/sa1110-cpufreq.c
+++ b/drivers/cpufreq/sa1110-cpufreq.c
@@@ -345,8 -321,8 +327,13 @@@ static int __init sa1110_cpu_init(struc
   * it with cpufreq_register_driver() */
  static struct cpufreq_driver sa1110_driver __refdata = {
  	.flags		= CPUFREQ_STICKY,
++<<<<<<< HEAD
 +	.verify		= sa11x0_verify_speed,
 +	.target		= sa1110_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= sa1110_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= sa11x0_getspeed,
  	.init		= sa1110_cpu_init,
  	.name		= "sa1110",
diff --cc drivers/cpufreq/sc520_freq.c
index 77a210975fc4,6c86452e1737..000000000000
--- a/drivers/cpufreq/sc520_freq.c
+++ b/drivers/cpufreq/sc520_freq.c
@@@ -76,24 -75,6 +75,27 @@@ static int sc520_freq_target(struct cpu
  	local_irq_enable();
  
  	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
++<<<<<<< HEAD
 +};
 +
 +static int sc520_freq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, &sc520_freq_table[0]);
 +}
 +
 +static int sc520_freq_target(struct cpufreq_policy *policy,
 +			    unsigned int target_freq,
 +			    unsigned int relation)
 +{
 +	unsigned int newstate = 0;
 +
 +	if (cpufreq_frequency_table_target(policy, sc520_freq_table,
 +				target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	sc520_freq_set_cpu_state(policy, newstate);
++=======
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  
  	return 0;
  }
@@@ -127,28 -99,14 +128,33 @@@ static int sc520_freq_cpu_init(struct c
  }
  
  
 +static int sc520_freq_cpu_exit(struct cpufreq_policy *policy)
 +{
 +	cpufreq_frequency_table_put_attr(policy->cpu);
 +	return 0;
 +}
 +
 +
 +static struct freq_attr *sc520_freq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
 +
  static struct cpufreq_driver sc520_freq_driver = {
  	.get	= sc520_freq_get_cpu_frequency,
++<<<<<<< HEAD
 +	.verify	= sc520_freq_verify,
 +	.target	= sc520_freq_target,
++=======
+ 	.verify	= cpufreq_generic_frequency_table_verify,
+ 	.target_index = sc520_freq_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.init	= sc520_freq_cpu_init,
 -	.exit	= cpufreq_generic_exit,
 +	.exit	= sc520_freq_cpu_exit,
  	.name	= "sc520_freq",
 -	.attr	= cpufreq_generic_attr,
 +	.owner	= THIS_MODULE,
 +	.attr	= sc520_freq_attr,
  };
  
  static const struct x86_cpu_id sc520_ids[] = {
diff --cc drivers/cpufreq/sparc-us2e-cpufreq.c
index 306ae462bba6,3bf5b8f03661..000000000000
--- a/drivers/cpufreq/sparc-us2e-cpufreq.c
+++ b/drivers/cpufreq/sparc-us2e-cpufreq.c
@@@ -329,8 -308,10 +314,15 @@@ static int __init us2e_freq_cpu_init(st
  
  static int us2e_freq_cpu_exit(struct cpufreq_policy *policy)
  {
++<<<<<<< HEAD
 +	if (cpufreq_us2e_driver)
 +		us2e_set_cpu_divider_index(policy, 0);
++=======
+ 	if (cpufreq_us2e_driver) {
+ 		cpufreq_frequency_table_put_attr(policy->cpu);
+ 		us2e_freq_target(policy, 0);
+ 	}
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  
  	return 0;
  }
@@@ -362,11 -342,10 +354,16 @@@ static int __init us2e_freq_init(void
  			goto err_out;
  
  		driver->init = us2e_freq_cpu_init;
++<<<<<<< HEAD
 +		driver->verify = us2e_freq_verify;
 +		driver->target = us2e_freq_target;
++=======
+ 		driver->verify = cpufreq_generic_frequency_table_verify;
+ 		driver->target_index = us2e_freq_target;
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  		driver->get = us2e_freq_get;
  		driver->exit = us2e_freq_cpu_exit;
 +		driver->owner = THIS_MODULE,
  		strcpy(driver->name, "UltraSPARC-IIe");
  
  		cpufreq_us2e_driver = driver;
diff --cc drivers/cpufreq/sparc-us3-cpufreq.c
index c71ee142347a,2e54d55915df..000000000000
--- a/drivers/cpufreq/sparc-us3-cpufreq.c
+++ b/drivers/cpufreq/sparc-us3-cpufreq.c
@@@ -186,8 -163,10 +169,15 @@@ static int __init us3_freq_cpu_init(str
  
  static int us3_freq_cpu_exit(struct cpufreq_policy *policy)
  {
++<<<<<<< HEAD
 +	if (cpufreq_us3_driver)
 +		us3_set_cpu_divider_index(policy, 0);
++=======
+ 	if (cpufreq_us3_driver) {
+ 		cpufreq_frequency_table_put_attr(policy->cpu);
+ 		us3_freq_target(policy, 0);
+ 	}
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  
  	return 0;
  }
@@@ -223,11 -201,10 +213,16 @@@ static int __init us3_freq_init(void
  			goto err_out;
  
  		driver->init = us3_freq_cpu_init;
++<<<<<<< HEAD
 +		driver->verify = us3_freq_verify;
 +		driver->target = us3_freq_target;
++=======
+ 		driver->verify = cpufreq_generic_frequency_table_verify;
+ 		driver->target_index = us3_freq_target;
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  		driver->get = us3_freq_get;
  		driver->exit = us3_freq_cpu_exit;
 +		driver->owner = THIS_MODULE,
  		strcpy(driver->name, "UltraSPARC-III");
  
  		cpufreq_us3_driver = driver;
diff --cc drivers/cpufreq/spear-cpufreq.c
index 156829f4576d,11a65be3fd76..000000000000
--- a/drivers/cpufreq/spear-cpufreq.c
+++ b/drivers/cpufreq/spear-cpufreq.c
@@@ -110,20 -105,16 +110,16 @@@ static int spear1340_set_cpu_rate(struc
  }
  
  static int spear_cpufreq_target(struct cpufreq_policy *policy,
- 		unsigned int target_freq, unsigned int relation)
+ 		unsigned int index)
  {
  	struct cpufreq_freqs freqs;
 -	long newfreq;
 +	unsigned long newfreq;
  	struct clk *srcclk;
- 	int index, ret, mult = 1;
- 
- 	if (cpufreq_frequency_table_target(policy, spear_cpufreq.freq_tbl,
- 				target_freq, relation, &index))
- 		return -EINVAL;
+ 	int ret, mult = 1;
  
  	freqs.old = spear_cpufreq_get(0);
- 
  	newfreq = spear_cpufreq.freq_tbl[index].frequency * 1000;
+ 
  	if (of_machine_is_compatible("st,spear1340")) {
  		/*
  		 * SPEAr1340 is special in the sense that due to the possibility
@@@ -207,12 -174,12 +203,17 @@@ static struct freq_attr *spear_cpufreq_
  static struct cpufreq_driver spear_cpufreq_driver = {
  	.name		= "cpufreq-spear",
  	.flags		= CPUFREQ_STICKY,
++<<<<<<< HEAD
 +	.verify		= spear_cpufreq_verify,
 +	.target		= spear_cpufreq_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= spear_cpufreq_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= spear_cpufreq_get,
  	.init		= spear_cpufreq_init,
 -	.exit		= cpufreq_generic_exit,
 -	.attr		= cpufreq_generic_attr,
 +	.exit		= spear_cpufreq_exit,
 +	.attr		= spear_cpufreq_attr,
  };
  
  static int spear_cpufreq_driver_init(void)
diff --cc drivers/cpufreq/speedstep-centrino.c
index f897d5105842,c51ec8c0e3a8..000000000000
--- a/drivers/cpufreq/speedstep-centrino.c
+++ b/drivers/cpufreq/speedstep-centrino.c
@@@ -571,10 -528,10 +560,15 @@@ static struct cpufreq_driver centrino_d
  					 but there's a 16 char limit */
  	.init		= centrino_cpu_init,
  	.exit		= centrino_cpu_exit,
++<<<<<<< HEAD
 +	.verify		= centrino_verify,
 +	.target		= centrino_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= centrino_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= get_cur_freq,
 -	.attr		= cpufreq_generic_attr,
 +	.attr           = centrino_attr,
  };
  
  /*
diff --cc drivers/cpufreq/speedstep-ich.c
index 5355abb69afc,707721ebb853..000000000000
--- a/drivers/cpufreq/speedstep-ich.c
+++ b/drivers/cpufreq/speedstep-ich.c
@@@ -373,12 -317,12 +361,17 @@@ static struct freq_attr *speedstep_attr
  
  static struct cpufreq_driver speedstep_driver = {
  	.name	= "speedstep-ich",
++<<<<<<< HEAD
 +	.verify	= speedstep_verify,
 +	.target	= speedstep_target,
++=======
+ 	.verify	= cpufreq_generic_frequency_table_verify,
+ 	.target_index = speedstep_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.init	= speedstep_cpu_init,
 -	.exit	= cpufreq_generic_exit,
 +	.exit	= speedstep_cpu_exit,
  	.get	= speedstep_get,
 -	.attr	= cpufreq_generic_attr,
 +	.attr	= speedstep_attr,
  };
  
  static const struct x86_cpu_id ss_smi_ids[] = {
diff --cc drivers/cpufreq/speedstep-smi.c
index abfba4f731eb,19446e479ccc..000000000000
--- a/drivers/cpufreq/speedstep-smi.c
+++ b/drivers/cpufreq/speedstep-smi.c
@@@ -362,20 -314,15 +352,25 @@@ static int speedstep_resume(struct cpuf
  	return result;
  }
  
 +static struct freq_attr *speedstep_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver speedstep_driver = {
  	.name		= "speedstep-smi",
++<<<<<<< HEAD
 +	.verify		= speedstep_verify,
 +	.target		= speedstep_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= speedstep_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.init		= speedstep_cpu_init,
 -	.exit		= cpufreq_generic_exit,
 +	.exit		= speedstep_cpu_exit,
  	.get		= speedstep_get,
  	.resume		= speedstep_resume,
 -	.attr		= cpufreq_generic_attr,
 +	.attr		= speedstep_attr,
  };
  
  static const struct x86_cpu_id ss_smi_ids[] = {
diff --cc drivers/cpufreq/tegra-cpufreq.c
index c74c0e130ef4,bd7d89c013a5..000000000000
--- a/drivers/cpufreq/tegra-cpufreq.c
+++ b/drivers/cpufreq/tegra-cpufreq.c
@@@ -239,14 -230,9 +233,19 @@@ static int tegra_cpu_exit(struct cpufre
  	return 0;
  }
  
 +static struct freq_attr *tegra_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver tegra_cpufreq_driver = {
++<<<<<<< HEAD
 +	.verify		= tegra_verify_speed,
 +	.target		= tegra_target,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= tegra_target,
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  	.get		= tegra_getspeed,
  	.init		= tegra_cpu_init,
  	.exit		= tegra_cpu_exit,
diff --cc include/linux/cpufreq.h
index 241e07069182,e8c77d330479..000000000000
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@@ -331,26 -176,111 +331,79 @@@ __ATTR(_name, 0444, show_##_name, NULL
  static struct global_attr _name =		\
  __ATTR(_name, 0644, show_##_name, store_##_name)
  
++<<<<<<< HEAD
 +struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
 +void cpufreq_cpu_put(struct cpufreq_policy *data);
++=======
+ 
+ struct cpufreq_driver {
+ 	char			name[CPUFREQ_NAME_LEN];
+ 	u8			flags;
+ 
+ 	/* needed by all drivers */
+ 	int	(*init)		(struct cpufreq_policy *policy);
+ 	int	(*verify)	(struct cpufreq_policy *policy);
+ 
+ 	/* define one out of two */
+ 	int	(*setpolicy)	(struct cpufreq_policy *policy);
+ 	int	(*target)	(struct cpufreq_policy *policy,	/* Deprecated */
+ 				 unsigned int target_freq,
+ 				 unsigned int relation);
+ 	int	(*target_index)	(struct cpufreq_policy *policy,
+ 				 unsigned int index);
+ 
+ 	/* should be defined, if possible */
+ 	unsigned int	(*get)	(unsigned int cpu);
+ 
+ 	/* optional */
+ 	int	(*bios_limit)	(int cpu, unsigned int *limit);
+ 
+ 	int	(*exit)		(struct cpufreq_policy *policy);
+ 	int	(*suspend)	(struct cpufreq_policy *policy);
+ 	int	(*resume)	(struct cpufreq_policy *policy);
+ 	struct freq_attr	**attr;
+ };
+ 
+ /* flags */
+ #define CPUFREQ_STICKY		(1 << 0)	/* driver isn't removed even if
+ 						   all ->init() calls failed */
+ #define CPUFREQ_CONST_LOOPS	(1 << 1)	/* loops_per_jiffy or other
+ 						   kernel "constants" aren't
+ 						   affected by frequency
+ 						   transitions */
+ #define CPUFREQ_PM_NO_WARN	(1 << 2)	/* don't warn on suspend/resume
+ 						   speed mismatches */
+ 
+ /*
+  * This should be set by platforms having multiple clock-domains, i.e.
+  * supporting multiple policies. With this sysfs directories of governor would
+  * be created in cpu/cpu<num>/cpufreq/ directory and so they can use the same
+  * governor with different tunables for different clusters.
+  */
+ #define CPUFREQ_HAVE_GOVERNOR_PER_POLICY (1 << 3)
+ 
+ int cpufreq_register_driver(struct cpufreq_driver *driver_data);
+ int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
+ 
++>>>>>>> 9c0ebcf78fde (cpufreq: Implement light weight ->target_index() routine)
  const char *cpufreq_get_current_driver(void);
  
 -static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
 -		unsigned int min, unsigned int max)
 -{
 -	if (policy->min < min)
 -		policy->min = min;
 -	if (policy->max < min)
 -		policy->max = min;
 -	if (policy->min > max)
 -		policy->min = max;
 -	if (policy->max > max)
 -		policy->max = max;
 -	if (policy->min > policy->max)
 -		policy->min = policy->max;
 -	return;
 -}
 -
 -static inline void
 -cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
 -{
 -	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
 -			policy->cpuinfo.max_freq);
 -}
 -
  /*********************************************************************
 - *                     CPUFREQ NOTIFIER INTERFACE                    *
 + *                        CPUFREQ 2.6. INTERFACE                     *
   *********************************************************************/
 -
 -#define CPUFREQ_TRANSITION_NOTIFIER	(0)
 -#define CPUFREQ_POLICY_NOTIFIER		(1)
 -
 -/* Transition notifiers */
 -#define CPUFREQ_PRECHANGE		(0)
 -#define CPUFREQ_POSTCHANGE		(1)
 -#define CPUFREQ_RESUMECHANGE		(8)
 -#define CPUFREQ_SUSPENDCHANGE		(9)
 -
 -/* Policy Notifiers  */
 -#define CPUFREQ_ADJUST			(0)
 -#define CPUFREQ_INCOMPATIBLE		(1)
 -#define CPUFREQ_NOTIFY			(2)
 -#define CPUFREQ_START			(3)
 -#define CPUFREQ_UPDATE_POLICY_CPU	(4)
 +u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
 +int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 +int cpufreq_update_policy(unsigned int cpu);
 +bool have_governor_per_policy(void);
 +struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
  
  #ifdef CONFIG_CPU_FREQ
 -int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
 -int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
 -
 -void cpufreq_notify_transition(struct cpufreq_policy *policy,
 -		struct cpufreq_freqs *freqs, unsigned int state);
 -
 -#else /* CONFIG_CPU_FREQ */
 -static inline int cpufreq_register_notifier(struct notifier_block *nb,
 -						unsigned int list)
 +/*
 + * query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it
 + */
 +unsigned int cpufreq_get(unsigned int cpu);
 +#else
 +static inline unsigned int cpufreq_get(unsigned int cpu)
  {
  	return 0;
  }
* Unmerged path drivers/cpufreq/ppc-corenet-cpufreq.c
diff --git a/Documentation/cpu-freq/cpu-drivers.txt b/Documentation/cpu-freq/cpu-drivers.txt
index 19fa98e07bf7..e54219838f2d 100644
--- a/Documentation/cpu-freq/cpu-drivers.txt
+++ b/Documentation/cpu-freq/cpu-drivers.txt
@@ -23,8 +23,8 @@ Contents:
 1.1  Initialization
 1.2  Per-CPU Initialization
 1.3  verify
-1.4  target or setpolicy?
-1.5  target
+1.4  target/target_index or setpolicy?
+1.5  target/target_index
 1.6  setpolicy
 2.   Frequency Table Helpers
 
@@ -58,7 +58,8 @@ cpufreq_driver.init -		A pointer to the per-CPU initialization
 cpufreq_driver.verify -		A pointer to a "verification" function.
 
 cpufreq_driver.setpolicy _or_ 
-cpufreq_driver.target -		See below on the differences.
+cpufreq_driver.target/
+target_index		-	See below on the differences.
 
 And optionally
 
@@ -68,7 +69,7 @@ cpufreq_driver.resume -		A pointer to a per-CPU resume function
 				which is called with interrupts disabled
 				and _before_ the pre-suspend frequency
 				and/or policy is restored by a call to
-				->target or ->setpolicy.
+				->target/target_index or ->setpolicy.
 
 cpufreq_driver.attr -		A pointer to a NULL-terminated list of
 				"struct freq_attr" which allow to
@@ -105,8 +106,8 @@ policy->governor		must contain the "default policy" for
 				this CPU. A few moments later,
 				cpufreq_driver.verify and either
 				cpufreq_driver.setpolicy or
-				cpufreq_driver.target is called with
-				these values.
+				cpufreq_driver.target/target_index is called
+				with these values.
 
 For setting some of these values (cpuinfo.min[max]_freq, policy->min[max]), the
 frequency table helpers might be helpful. See the section 2 for more information
@@ -135,20 +136,28 @@ range) is within policy->min and policy->max. If necessary, increase
 policy->max first, and only if this is no solution, decrease policy->min.
 
 
-1.4 target or setpolicy?
+1.4 target/target_index or setpolicy?
 ----------------------------
 
 Most cpufreq drivers or even most cpu frequency scaling algorithms 
 only allow the CPU to be set to one frequency. For these, you use the
-->target call.
+->target/target_index call.
 
 Some cpufreq-capable processors switch the frequency between certain
 limits on their own. These shall use the ->setpolicy call
 
 
-1.4. target
+1.4. target/target_index
 -------------
 
+The target_index call has two arguments: struct cpufreq_policy *policy,
+and unsigned int index (into the exposed frequency table).
+
+The CPUfreq driver must set the new frequency when called here. The
+actual frequency must be determined by freq_table[index].frequency.
+
+Deprecated:
+----------
 The target call has three arguments: struct cpufreq_policy *policy,
 unsigned int target_frequency, unsigned int relation.
 
diff --git a/Documentation/cpu-freq/governors.txt b/Documentation/cpu-freq/governors.txt
index 219970ba54b7..77ec21574fb1 100644
--- a/Documentation/cpu-freq/governors.txt
+++ b/Documentation/cpu-freq/governors.txt
@@ -40,7 +40,7 @@ Most cpufreq drivers (in fact, all except one, longrun) or even most
 cpu frequency scaling algorithms only offer the CPU to be set to one
 frequency. In order to offer dynamic frequency scaling, the cpufreq
 core must be able to tell these drivers of a "target frequency". So
-these specific drivers will be transformed to offer a "->target"
+these specific drivers will be transformed to offer a "->target/target_index"
 call instead of the existing "->setpolicy" call. For "longrun", all
 stays the same, though.
 
@@ -71,7 +71,7 @@ CPU can be set to switch independently	 |	   CPU can only be set
 		    /			       the limits of policy->{min,max}
 		   /			            \
 		  /				     \
-	Using the ->setpolicy call,		 Using the ->target call,
+	Using the ->setpolicy call,		 Using the ->target/target_index call,
 	    the limits and the			  the frequency closest
 	     "policy" is set.			  to target_freq is set.
 						  It is assured that it
* Unmerged path arch/arm/mach-sa1100/generic.c
* Unmerged path arch/arm/mach-sa1100/generic.h
diff --git a/drivers/cpufreq/acpi-cpufreq.c b/drivers/cpufreq/acpi-cpufreq.c
index dbe16c760bb8..87d6cef62605 100644
--- a/drivers/cpufreq/acpi-cpufreq.c
+++ b/drivers/cpufreq/acpi-cpufreq.c
@@ -425,17 +425,17 @@ static unsigned int check_freqs(const struct cpumask *mask, unsigned int freq,
 }
 
 static int acpi_cpufreq_target(struct cpufreq_policy *policy,
-			       unsigned int target_freq, unsigned int relation)
+			       unsigned int index)
 {
 	struct acpi_cpufreq_data *data = per_cpu(acfreq_data, policy->cpu);
 	struct acpi_processor_performance *perf;
 	struct cpufreq_freqs freqs;
 	struct drv_cmd cmd;
-	unsigned int next_state = 0; /* Index into freq_table */
 	unsigned int next_perf_state = 0; /* Index into perf table */
 	int result = 0;
 
-	pr_debug("acpi_cpufreq_target %d (%d)\n", target_freq, policy->cpu);
+	pr_debug("acpi_cpufreq_target %d (%d)\n",
+			data->freq_table[index].frequency, policy->cpu);
 
 	if (unlikely(data == NULL ||
 	     data->acpi_data == NULL || data->freq_table == NULL)) {
@@ -443,16 +443,7 @@ static int acpi_cpufreq_target(struct cpufreq_policy *policy,
 	}
 
 	perf = data->acpi_data;
-	result = cpufreq_frequency_table_target(policy,
-						data->freq_table,
-						target_freq,
-						relation, &next_state);
-	if (unlikely(result)) {
-		result = -ENODEV;
-		goto out;
-	}
-
-	next_perf_state = data->freq_table[next_state].driver_data;
+	next_perf_state = data->freq_table[index].driver_data;
 	if (perf->state == next_perf_state) {
 		if (unlikely(data->resume)) {
 			pr_debug("Called after resume, resetting to P%d\n",
@@ -494,7 +485,7 @@ static int acpi_cpufreq_target(struct cpufreq_policy *policy,
 		cmd.mask = cpumask_of(policy->cpu);
 
 	freqs.old = perf->states[perf->state].core_frequency * 1000;
-	freqs.new = data->freq_table[next_state].frequency;
+	freqs.new = data->freq_table[index].frequency;
 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 
 	drv_write(&cmd);
@@ -928,7 +919,7 @@ static struct freq_attr *acpi_cpufreq_attr[] = {
 
 static struct cpufreq_driver acpi_cpufreq_driver = {
 	.verify		= cpufreq_generic_frequency_table_verify,
-	.target		= acpi_cpufreq_target,
+	.target_index	= acpi_cpufreq_target,
 	.bios_limit	= acpi_processor_get_bios_limit,
 	.init		= acpi_cpufreq_cpu_init,
 	.exit		= acpi_cpufreq_cpu_exit,
* Unmerged path drivers/cpufreq/arm_big_little.c
* Unmerged path drivers/cpufreq/at32ap-cpufreq.c
* Unmerged path drivers/cpufreq/blackfin-cpufreq.c
* Unmerged path drivers/cpufreq/cpufreq-cpu0.c
* Unmerged path drivers/cpufreq/cpufreq.c
* Unmerged path drivers/cpufreq/cris-artpec3-cpufreq.c
* Unmerged path drivers/cpufreq/cris-etraxfs-cpufreq.c
diff --git a/drivers/cpufreq/davinci-cpufreq.c b/drivers/cpufreq/davinci-cpufreq.c
index 7c60c8b54e11..9b4c58bda31d 100644
--- a/drivers/cpufreq/davinci-cpufreq.c
+++ b/drivers/cpufreq/davinci-cpufreq.c
@@ -66,28 +66,18 @@ static unsigned int davinci_getspeed(unsigned int cpu)
 	return clk_get_rate(cpufreq.armclk) / 1000;
 }
 
-static int davinci_target(struct cpufreq_policy *policy,
-				unsigned int target_freq, unsigned int relation)
+static int davinci_target(struct cpufreq_policy *policy, unsigned int idx)
 {
 	int ret = 0;
-	unsigned int idx;
 	struct cpufreq_freqs freqs;
 	struct davinci_cpufreq_config *pdata = cpufreq.dev->platform_data;
 	struct clk *armclk = cpufreq.armclk;
 
 	freqs.old = davinci_getspeed(0);
-	freqs.new = clk_round_rate(armclk, target_freq * 1000) / 1000;
-
-	if (freqs.old == freqs.new)
-		return ret;
+	freqs.new = pdata->freq_table[idx].frequency;
 
 	dev_dbg(cpufreq.dev, "transition: %u --> %u\n", freqs.old, freqs.new);
 
-	ret = cpufreq_frequency_table_target(policy, pdata->freq_table,
-						freqs.new, relation, &idx);
-	if (ret)
-		return -EINVAL;
-
 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 
 	/* if moving to higher frequency, up the voltage beforehand */
@@ -168,7 +158,7 @@ static struct freq_attr *davinci_cpufreq_attr[] = {
 static struct cpufreq_driver davinci_driver = {
 	.flags		= CPUFREQ_STICKY,
 	.verify		= davinci_verify_speed,
-	.target		= davinci_target,
+	.target_index	= davinci_target,
 	.get		= davinci_getspeed,
 	.init		= davinci_cpu_init,
 	.exit		= davinci_cpu_exit,
* Unmerged path drivers/cpufreq/dbx500-cpufreq.c
* Unmerged path drivers/cpufreq/e_powersaver.c
* Unmerged path drivers/cpufreq/elanfreq.c
* Unmerged path drivers/cpufreq/exynos-cpufreq.c
* Unmerged path drivers/cpufreq/exynos5440-cpufreq.c
* Unmerged path drivers/cpufreq/ia64-acpi-cpufreq.c
* Unmerged path drivers/cpufreq/imx6q-cpufreq.c
* Unmerged path drivers/cpufreq/kirkwood-cpufreq.c
* Unmerged path drivers/cpufreq/longhaul.c
* Unmerged path drivers/cpufreq/loongson2_cpufreq.c
* Unmerged path drivers/cpufreq/maple-cpufreq.c
* Unmerged path drivers/cpufreq/omap-cpufreq.c
diff --git a/drivers/cpufreq/p4-clockmod.c b/drivers/cpufreq/p4-clockmod.c
index 6164c1cca504..3c23053afdfd 100644
--- a/drivers/cpufreq/p4-clockmod.c
+++ b/drivers/cpufreq/p4-clockmod.c
@@ -105,23 +105,13 @@ static struct cpufreq_frequency_table p4clockmod_table[] = {
 };
 
 
-static int cpufreq_p4_target(struct cpufreq_policy *policy,
-			     unsigned int target_freq,
-			     unsigned int relation)
+static int cpufreq_p4_target(struct cpufreq_policy *policy, unsigned int index)
 {
-	unsigned int    newstate = DC_RESV;
 	struct cpufreq_freqs freqs;
 	int i;
 
-	if (cpufreq_frequency_table_target(policy, &p4clockmod_table[0],
-				target_freq, relation, &newstate))
-		return -EINVAL;
-
 	freqs.old = cpufreq_p4_get(policy->cpu);
-	freqs.new = stock_freq * p4clockmod_table[newstate].driver_data / 8;
-
-	if (freqs.new == freqs.old)
-		return 0;
+	freqs.new = stock_freq * p4clockmod_table[index].driver_data / 8;
 
 	/* notifiers */
 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
@@ -131,7 +121,7 @@ static int cpufreq_p4_target(struct cpufreq_policy *policy,
 	 * Developer's Manual, Volume 3
 	 */
 	for_each_cpu(i, policy->cpus)
-		cpufreq_p4_setdc(i, p4clockmod_table[newstate].driver_data);
+		cpufreq_p4_setdc(i, p4clockmod_table[index].driver_data);
 
 	/* notifiers */
 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
@@ -255,7 +245,7 @@ static unsigned int cpufreq_p4_get(unsigned int cpu)
 
 static struct cpufreq_driver p4clockmod_driver = {
 	.verify		= cpufreq_generic_frequency_table_verify,
-	.target		= cpufreq_p4_target,
+	.target_index	= cpufreq_p4_target,
 	.init		= cpufreq_p4_cpu_init,
 	.exit		= cpufreq_generic_exit,
 	.get		= cpufreq_p4_get,
* Unmerged path drivers/cpufreq/pasemi-cpufreq.c
* Unmerged path drivers/cpufreq/pmac32-cpufreq.c
* Unmerged path drivers/cpufreq/pmac64-cpufreq.c
* Unmerged path drivers/cpufreq/powernow-k6.c
* Unmerged path drivers/cpufreq/powernow-k7.c
* Unmerged path drivers/cpufreq/powernow-k8.c
* Unmerged path drivers/cpufreq/ppc-corenet-cpufreq.c
* Unmerged path drivers/cpufreq/ppc_cbe_cpufreq.c
* Unmerged path drivers/cpufreq/pxa2xx-cpufreq.c
* Unmerged path drivers/cpufreq/pxa3xx-cpufreq.c
* Unmerged path drivers/cpufreq/s3c2416-cpufreq.c
* Unmerged path drivers/cpufreq/s3c64xx-cpufreq.c
* Unmerged path drivers/cpufreq/s5pv210-cpufreq.c
* Unmerged path drivers/cpufreq/sa1100-cpufreq.c
* Unmerged path drivers/cpufreq/sa1110-cpufreq.c
* Unmerged path drivers/cpufreq/sc520_freq.c
* Unmerged path drivers/cpufreq/sparc-us2e-cpufreq.c
* Unmerged path drivers/cpufreq/sparc-us3-cpufreq.c
* Unmerged path drivers/cpufreq/spear-cpufreq.c
* Unmerged path drivers/cpufreq/speedstep-centrino.c
* Unmerged path drivers/cpufreq/speedstep-ich.c
* Unmerged path drivers/cpufreq/speedstep-smi.c
* Unmerged path drivers/cpufreq/tegra-cpufreq.c
* Unmerged path include/linux/cpufreq.h
