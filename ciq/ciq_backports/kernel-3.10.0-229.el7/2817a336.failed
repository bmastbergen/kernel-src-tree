net: skb_checksum: allow custom update/combine for walking skb

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] skb_checksum: allow custom update/combine for walking skb (Daniel Borkmann) [1054215]
Rebuild_FUZZ: 95.80%
commit-author Daniel Borkmann <dborkman@redhat.com>
commit 2817a336d4d533fb8b68719723cd60ea7dd7c09e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2817a336.failed

Currently, skb_checksum walks over 1) linearized, 2) frags[], and
3) frag_list data and calculats the one's complement, a 32 bit
result suitable for feeding into itself or csum_tcpudp_magic(),
but unsuitable for SCTP as we're calculating CRC32c there.

Hence, in order to not re-implement the very same function in
SCTP (and maybe other protocols) over and over again, use an
update() + combine() callback internally to allow for walking
over the skb with different algorithms.

	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2817a336d4d533fb8b68719723cd60ea7dd7c09e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
diff --cc include/linux/skbuff.h
index 5832e933a0f2,44727b5d4981..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -2399,61 -2339,50 +2399,108 @@@ static inline void skb_frag_add_head(st
  #define skb_walk_frags(skb, iter)	\
  	for (iter = skb_shinfo(skb)->frag_list; iter; iter = iter->next)
  
++<<<<<<< HEAD
 +extern struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
 +					   int *peeked, int *off, int *err);
 +extern struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags,
 +					 int noblock, int *err);
 +extern unsigned int    datagram_poll(struct file *file, struct socket *sock,
 +				     struct poll_table_struct *wait);
 +extern int	       skb_copy_datagram_iovec(const struct sk_buff *from,
 +					       int offset, struct iovec *to,
 +					       int size);
 +extern int	       skb_copy_and_csum_datagram_iovec(struct sk_buff *skb,
 +							int hlen,
 +							struct iovec *iov);
 +extern int	       skb_copy_datagram_from_iovec(struct sk_buff *skb,
 +						    int offset,
 +						    const struct iovec *from,
 +						    int from_offset,
 +						    int len);
 +extern int	       skb_copy_datagram_const_iovec(const struct sk_buff *from,
 +						     int offset,
 +						     const struct iovec *to,
 +						     int to_offset,
 +						     int size);
 +extern void	       skb_free_datagram(struct sock *sk, struct sk_buff *skb);
 +extern void	       skb_free_datagram_locked(struct sock *sk,
 +						struct sk_buff *skb);
 +extern int	       skb_kill_datagram(struct sock *sk, struct sk_buff *skb,
 +					 unsigned int flags);
 +extern __wsum	       skb_checksum(const struct sk_buff *skb, int offset,
 +				    int len, __wsum csum);
 +extern int	       skb_copy_bits(const struct sk_buff *skb, int offset,
 +				     void *to, int len);
 +extern int	       skb_store_bits(struct sk_buff *skb, int offset,
 +				      const void *from, int len);
 +extern __wsum	       skb_copy_and_csum_bits(const struct sk_buff *skb,
 +					      int offset, u8 *to, int len,
 +					      __wsum csum);
 +extern int             skb_splice_bits(struct sk_buff *skb,
 +						unsigned int offset,
 +						struct pipe_inode_info *pipe,
 +						unsigned int len,
 +						unsigned int flags);
 +extern void	       skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to);
 +unsigned int skb_zerocopy_headlen(const struct sk_buff *from);
 +void skb_zerocopy(struct sk_buff *to, const struct sk_buff *from,
 +                 int len, int hlen);
 +
 +extern void	       skb_split(struct sk_buff *skb,
 +				 struct sk_buff *skb1, const u32 len);
 +extern int	       skb_shift(struct sk_buff *tgt, struct sk_buff *skb,
 +				 int shiftlen);
 +extern void	       skb_scrub_packet(struct sk_buff *skb);
 +unsigned int skb_gso_transport_seglen(const struct sk_buff *skb);
 +
 +extern struct sk_buff *skb_segment(struct sk_buff *skb,
 +				   netdev_features_t features);
++=======
+ struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
+ 				    int *peeked, int *off, int *err);
+ struct sk_buff *skb_recv_datagram(struct sock *sk, unsigned flags, int noblock,
+ 				  int *err);
+ unsigned int datagram_poll(struct file *file, struct socket *sock,
+ 			   struct poll_table_struct *wait);
+ int skb_copy_datagram_iovec(const struct sk_buff *from, int offset,
+ 			    struct iovec *to, int size);
+ int skb_copy_and_csum_datagram_iovec(struct sk_buff *skb, int hlen,
+ 				     struct iovec *iov);
+ int skb_copy_datagram_from_iovec(struct sk_buff *skb, int offset,
+ 				 const struct iovec *from, int from_offset,
+ 				 int len);
+ int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *frm,
+ 			   int offset, size_t count);
+ int skb_copy_datagram_const_iovec(const struct sk_buff *from, int offset,
+ 				  const struct iovec *to, int to_offset,
+ 				  int size);
+ void skb_free_datagram(struct sock *sk, struct sk_buff *skb);
+ void skb_free_datagram_locked(struct sock *sk, struct sk_buff *skb);
+ int skb_kill_datagram(struct sock *sk, struct sk_buff *skb, unsigned int flags);
+ int skb_copy_bits(const struct sk_buff *skb, int offset, void *to, int len);
+ int skb_store_bits(struct sk_buff *skb, int offset, const void *from, int len);
+ __wsum skb_copy_and_csum_bits(const struct sk_buff *skb, int offset, u8 *to,
+ 			      int len, __wsum csum);
+ int skb_splice_bits(struct sk_buff *skb, unsigned int offset,
+ 		    struct pipe_inode_info *pipe, unsigned int len,
+ 		    unsigned int flags);
+ void skb_copy_and_csum_dev(const struct sk_buff *skb, u8 *to);
+ void skb_split(struct sk_buff *skb, struct sk_buff *skb1, const u32 len);
+ int skb_shift(struct sk_buff *tgt, struct sk_buff *skb, int shiftlen);
+ void skb_scrub_packet(struct sk_buff *skb, bool xnet);
+ struct sk_buff *skb_segment(struct sk_buff *skb, netdev_features_t features);
+ 
+ struct skb_checksum_ops {
+ 	__wsum (*update)(const void *mem, int len, __wsum wsum);
+ 	__wsum (*combine)(__wsum csum, __wsum csum2, int offset, int len);
+ };
+ 
+ __wsum __skb_checksum(const struct sk_buff *skb, int offset, int len,
+ 		      __wsum csum, const struct skb_checksum_ops *ops);
+ __wsum skb_checksum(const struct sk_buff *skb, int offset, int len,
+ 		    __wsum csum);
+ 
++>>>>>>> 2817a336d4d5 (net: skb_checksum: allow custom update/combine for walking skb)
  static inline void *skb_header_pointer(const struct sk_buff *skb, int offset,
  				       int len, void *buffer)
  {
* Unmerged path include/linux/skbuff.h
diff --git a/include/net/checksum.h b/include/net/checksum.h
index 600d1d705bb8..5ad45571267e 100644
--- a/include/net/checksum.h
+++ b/include/net/checksum.h
@@ -78,6 +78,12 @@ csum_block_add(__wsum csum, __wsum csum2, int offset)
 	return csum_add(csum, (__force __wsum)sum);
 }
 
+static inline __wsum
+csum_block_add_ext(__wsum csum, __wsum csum2, int offset, int len)
+{
+	return csum_block_add(csum, csum2, offset);
+}
+
 static inline __wsum
 csum_block_sub(__wsum csum, __wsum csum2, int offset)
 {
diff --git a/net/core/skbuff.c b/net/core/skbuff.c
index dd3aefbfd232..1524ece788f0 100644
--- a/net/core/skbuff.c
+++ b/net/core/skbuff.c
@@ -1926,9 +1926,8 @@ fault:
 EXPORT_SYMBOL(skb_store_bits);
 
 /* Checksum skb data. */
-
-__wsum skb_checksum(const struct sk_buff *skb, int offset,
-			  int len, __wsum csum)
+__wsum __skb_checksum(const struct sk_buff *skb, int offset, int len,
+		      __wsum csum, const struct skb_checksum_ops *ops)
 {
 	int start = skb_headlen(skb);
 	int i, copy = start - offset;
@@ -1939,7 +1938,7 @@ __wsum skb_checksum(const struct sk_buff *skb, int offset,
 	if (copy > 0) {
 		if (copy > len)
 			copy = len;
-		csum = csum_partial(skb->data + offset, copy, csum);
+		csum = ops->update(skb->data + offset, copy, csum);
 		if ((len -= copy) == 0)
 			return csum;
 		offset += copy;
@@ -1960,10 +1959,10 @@ __wsum skb_checksum(const struct sk_buff *skb, int offset,
 			if (copy > len)
 				copy = len;
 			vaddr = kmap_atomic(skb_frag_page(frag));
-			csum2 = csum_partial(vaddr + frag->page_offset +
-					     offset - start, copy, 0);
+			csum2 = ops->update(vaddr + frag->page_offset +
+					    offset - start, copy, 0);
 			kunmap_atomic(vaddr);
-			csum = csum_block_add(csum, csum2, pos);
+			csum = ops->combine(csum, csum2, pos, copy);
 			if (!(len -= copy))
 				return csum;
 			offset += copy;
@@ -1982,9 +1981,9 @@ __wsum skb_checksum(const struct sk_buff *skb, int offset,
 			__wsum csum2;
 			if (copy > len)
 				copy = len;
-			csum2 = skb_checksum(frag_iter, offset - start,
-					     copy, 0);
-			csum = csum_block_add(csum, csum2, pos);
+			csum2 = __skb_checksum(frag_iter, offset - start,
+					       copy, 0, ops);
+			csum = ops->combine(csum, csum2, pos, copy);
 			if ((len -= copy) == 0)
 				return csum;
 			offset += copy;
@@ -1996,6 +1995,18 @@ __wsum skb_checksum(const struct sk_buff *skb, int offset,
 
 	return csum;
 }
+EXPORT_SYMBOL(__skb_checksum);
+
+__wsum skb_checksum(const struct sk_buff *skb, int offset,
+		    int len, __wsum csum)
+{
+	const struct skb_checksum_ops ops = {
+		.update  = csum_partial,
+		.combine = csum_block_add_ext,
+	};
+
+	return __skb_checksum(skb, offset, len, csum, &ops);
+}
 EXPORT_SYMBOL(skb_checksum);
 
 /* Both of above in one bottle. */
