iommu/vt-d: Make iommu_should_identity_map() take struct device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Make iommu_should_identity_map() take struct device (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 95.00%
commit-author David Woodhouse <David.Woodhouse@intel.com>
commit 3bdb259116059a6b805cfe9be66f4054f92598a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3bdb2591.failed

	Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
(cherry picked from commit 3bdb259116059a6b805cfe9be66f4054f92598a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 144c54a1b81e,ccfce8832954..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -2393,58 -2517,66 +2393,79 @@@ static bool device_has_rmrr(struct pci_
  	return false;
  }
  
- static int iommu_should_identity_map(struct pci_dev *pdev, int startup)
+ static int iommu_should_identity_map(struct device *dev, int startup)
  {
  
++<<<<<<< HEAD
 +	/*
 +	 * We want to prevent any device associated with an RMRR from
 +	 * getting placed into the SI Domain. This is done because
 +	 * problems exist when devices are moved in and out of domains
 +	 * and their respective RMRR info is lost. We exempt USB devices
 +	 * from this process due to their usage of RMRRs that are known
 +	 * to not be needed after BIOS hand-off to OS.
 +	 */
 +	if (device_has_rmrr(pdev) &&
 +	    (pdev->class >> 8) != PCI_CLASS_SERIAL_USB)
 +		return 0;
++=======
+ 	if (dev_is_pci(dev)) {
+ 		struct pci_dev *pdev = to_pci_dev(dev);
++>>>>>>> 3bdb25911605 (iommu/vt-d: Make iommu_should_identity_map() take struct device)
  
- 	if ((iommu_identity_mapping & IDENTMAP_AZALIA) && IS_AZALIA(pdev))
- 		return 1;
+ 		/*
+ 		 * We want to prevent any device associated with an RMRR from
+ 		 * getting placed into the SI Domain. This is done because
+ 		 * problems exist when devices are moved in and out of domains
+ 		 * and their respective RMRR info is lost. We exempt USB devices
+ 		 * from this process due to their usage of RMRRs that are known
+ 		 * to not be needed after BIOS hand-off to OS.
+ 		 */
+ 		if (device_has_rmrr(dev) &&
+ 		    (pdev->class >> 8) != PCI_CLASS_SERIAL_USB)
+ 			return 0;
  
- 	if ((iommu_identity_mapping & IDENTMAP_GFX) && IS_GFX_DEVICE(pdev))
- 		return 1;
+ 		if ((iommu_identity_mapping & IDENTMAP_AZALIA) && IS_AZALIA(pdev))
+ 			return 1;
  
- 	if (!(iommu_identity_mapping & IDENTMAP_ALL))
- 		return 0;
+ 		if ((iommu_identity_mapping & IDENTMAP_GFX) && IS_GFX_DEVICE(pdev))
+ 			return 1;
  
- 	/*
- 	 * We want to start off with all devices in the 1:1 domain, and
- 	 * take them out later if we find they can't access all of memory.
- 	 *
- 	 * However, we can't do this for PCI devices behind bridges,
- 	 * because all PCI devices behind the same bridge will end up
- 	 * with the same source-id on their transactions.
- 	 *
- 	 * Practically speaking, we can't change things around for these
- 	 * devices at run-time, because we can't be sure there'll be no
- 	 * DMA transactions in flight for any of their siblings.
- 	 * 
- 	 * So PCI devices (unless they're on the root bus) as well as
- 	 * their parent PCI-PCI or PCIe-PCI bridges must be left _out_ of
- 	 * the 1:1 domain, just in _case_ one of their siblings turns out
- 	 * not to be able to map all of memory.
- 	 */
- 	if (!pci_is_pcie(pdev)) {
- 		if (!pci_is_root_bus(pdev->bus))
+ 		if (!(iommu_identity_mapping & IDENTMAP_ALL))
  			return 0;
- 		if (pdev->class >> 8 == PCI_CLASS_BRIDGE_PCI)
+ 
+ 		/*
+ 		 * We want to start off with all devices in the 1:1 domain, and
+ 		 * take them out later if we find they can't access all of memory.
+ 		 *
+ 		 * However, we can't do this for PCI devices behind bridges,
+ 		 * because all PCI devices behind the same bridge will end up
+ 		 * with the same source-id on their transactions.
+ 		 *
+ 		 * Practically speaking, we can't change things around for these
+ 		 * devices at run-time, because we can't be sure there'll be no
+ 		 * DMA transactions in flight for any of their siblings.
+ 		 *
+ 		 * So PCI devices (unless they're on the root bus) as well as
+ 		 * their parent PCI-PCI or PCIe-PCI bridges must be left _out_ of
+ 		 * the 1:1 domain, just in _case_ one of their siblings turns out
+ 		 * not to be able to map all of memory.
+ 		 */
+ 		if (!pci_is_pcie(pdev)) {
+ 			if (!pci_is_root_bus(pdev->bus))
+ 				return 0;
+ 			if (pdev->class >> 8 == PCI_CLASS_BRIDGE_PCI)
+ 				return 0;
+ 		} else if (pci_pcie_type(pdev) == PCI_EXP_TYPE_PCI_BRIDGE)
  			return 0;
- 	} else if (pci_pcie_type(pdev) == PCI_EXP_TYPE_PCI_BRIDGE)
- 		return 0;
+ 	} else {
+ 		if (device_has_rmrr(dev))
+ 			return 0;
+ 	}
  
- 	/* 
+ 	/*
  	 * At boot time, we don't yet know if devices will be 64-bit capable.
- 	 * Assume that they will -- if they turn out not to be, then we can 
+ 	 * Assume that they will â€” if they turn out not to be, then we can
  	 * take them out of the 1:1 domain later.
  	 */
  	if (!startup) {
* Unmerged path drivers/iommu/intel-iommu.c
