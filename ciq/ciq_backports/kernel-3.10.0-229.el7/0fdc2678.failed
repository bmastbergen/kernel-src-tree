sunrpc: get rid of use_gssp_lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Jeff Layton <jlayton@redhat.com>
commit 0fdc26785d0a5bb33d9adb572307fd2d7a406734
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0fdc2678.failed

We can achieve the same result with a cmpxchg(). This also fixes a
potential race in use_gss_proxy(). The value of sn->use_gss_proxy could
go from -1 to 1 just after we check it in use_gss_proxy() but before we
acquire the spinlock. The procfile write would end up returning success
but the value would flip to 0 soon afterward. With this method we not
only avoid locking but the first "setter" always wins.

	Signed-off-by: Jeff Layton <jlayton@redhat.com>
	Signed-off-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 0fdc26785d0a5bb33d9adb572307fd2d7a406734)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/auth_gss/svcauth_gss.c
diff --cc net/sunrpc/auth_gss/svcauth_gss.c
index 49bb4cbc928a,2a935404047f..000000000000
--- a/net/sunrpc/auth_gss/svcauth_gss.c
+++ b/net/sunrpc/auth_gss/svcauth_gss.c
@@@ -1283,46 -1292,6 +1292,49 @@@ static bool use_gss_proxy(struct net *n
  
  #ifdef CONFIG_PROC_FS
  
++<<<<<<< HEAD
 +static int set_gss_proxy(struct net *net, int type)
 +{
 +	struct sunrpc_net *sn = net_generic(net, sunrpc_net_id);
 +	int ret = 0;
 +
 +	WARN_ON_ONCE(type != 0 && type != 1);
 +	spin_lock(&use_gssp_lock);
 +	if (sn->use_gss_proxy == -1 || sn->use_gss_proxy == type)
 +		sn->use_gss_proxy = type;
 +	else
 +		ret = -EBUSY;
 +	spin_unlock(&use_gssp_lock);
 +	wake_up(&sn->gssp_wq);
 +	return ret;
 +}
 +
 +static inline bool gssp_ready(struct sunrpc_net *sn)
 +{
 +	switch (sn->use_gss_proxy) {
 +		case -1:
 +			return false;
 +		case 0:
 +			return true;
 +		case 1:
 +			return sn->gssp_clnt;
 +	}
 +	WARN_ON_ONCE(1);
 +	return false;
 +}
 +
 +static int wait_for_gss_proxy(struct net *net, struct file *file)
 +{
 +	struct sunrpc_net *sn = net_generic(net, sunrpc_net_id);
 +
 +	if (file->f_flags & O_NONBLOCK && !gssp_ready(sn))
 +		return -EAGAIN;
 +	return wait_event_interruptible(sn->gssp_wq, gssp_ready(sn));
 +}
 +
 +
++=======
++>>>>>>> 0fdc26785d0a (sunrpc: get rid of use_gssp_lock)
  static ssize_t write_gssp(struct file *file, const char __user *buf,
  			 size_t count, loff_t *ppos)
  {
* Unmerged path net/sunrpc/auth_gss/svcauth_gss.c
