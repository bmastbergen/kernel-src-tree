NFS: Don't reset pg_moreio in __nfs_pageio_add_request

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit f563b89b182594f827b4100bd34f916339785a77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/f563b89b.failed

Once we've started sending unstable NFS writes, we do not want to
clear pg_moreio, or we may end up sending the very last request as
a stable write if the commit lists are still empty.

Do, however, reset pg_moreio in the case where we end up having to
recoalesce the write if an attempt to use pNFS failed.

	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit f563b89b182594f827b4100bd34f916339785a77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pagelist.c
diff --cc fs/nfs/pagelist.c
index 5f18707a0319,17fab89f6358..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -449,16 -912,63 +449,71 @@@ static void nfs_pageio_doio(struct nfs_
  static int __nfs_pageio_add_request(struct nfs_pageio_descriptor *desc,
  			   struct nfs_page *req)
  {
++<<<<<<< HEAD
 +	while (!nfs_pageio_do_add_request(desc, req)) {
 +		desc->pg_moreio = 1;
 +		nfs_pageio_doio(desc);
 +		if (desc->pg_error < 0)
 +			return 0;
 +		desc->pg_moreio = 0;
 +		if (desc->pg_recoalesce)
 +			return 0;
 +	}
++=======
+ 	struct nfs_page *subreq;
+ 	unsigned int bytes_left = 0;
+ 	unsigned int offset, pgbase;
+ 
+ 	nfs_page_group_lock(req);
+ 
+ 	subreq = req;
+ 	bytes_left = subreq->wb_bytes;
+ 	offset = subreq->wb_offset;
+ 	pgbase = subreq->wb_pgbase;
+ 
+ 	do {
+ 		if (!nfs_pageio_do_add_request(desc, subreq)) {
+ 			/* make sure pg_test call(s) did nothing */
+ 			WARN_ON_ONCE(subreq->wb_bytes != bytes_left);
+ 			WARN_ON_ONCE(subreq->wb_offset != offset);
+ 			WARN_ON_ONCE(subreq->wb_pgbase != pgbase);
+ 
+ 			nfs_page_group_unlock(req);
+ 			desc->pg_moreio = 1;
+ 			nfs_pageio_doio(desc);
+ 			if (desc->pg_error < 0)
+ 				return 0;
+ 			if (desc->pg_recoalesce)
+ 				return 0;
+ 			/* retry add_request for this subreq */
+ 			nfs_page_group_lock(req);
+ 			continue;
+ 		}
+ 
+ 		/* check for buggy pg_test call(s) */
+ 		WARN_ON_ONCE(subreq->wb_bytes + subreq->wb_pgbase > PAGE_SIZE);
+ 		WARN_ON_ONCE(subreq->wb_bytes > bytes_left);
+ 		WARN_ON_ONCE(subreq->wb_bytes == 0);
+ 
+ 		bytes_left -= subreq->wb_bytes;
+ 		offset += subreq->wb_bytes;
+ 		pgbase += subreq->wb_bytes;
+ 
+ 		if (bytes_left) {
+ 			subreq = nfs_create_request(req->wb_context,
+ 					req->wb_page,
+ 					subreq, pgbase, bytes_left);
+ 			if (IS_ERR(subreq))
+ 				goto err_ptr;
+ 			nfs_lock_request(subreq);
+ 			subreq->wb_offset  = offset;
+ 			subreq->wb_index = req->wb_index;
+ 		}
+ 	} while (bytes_left > 0);
+ 
+ 	nfs_page_group_unlock(req);
++>>>>>>> f563b89b1825 (NFS: Don't reset pg_moreio in __nfs_pageio_add_request)
  	return 1;
 -err_ptr:
 -	desc->pg_error = PTR_ERR(subreq);
 -	nfs_page_group_unlock(req);
 -	return 0;
  }
  
  static int nfs_do_recoalesce(struct nfs_pageio_descriptor *desc)
* Unmerged path fs/nfs/pagelist.c
