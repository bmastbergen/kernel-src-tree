ACPI / hotplug / PCI: Define hotplug context lock in the core

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Define hotplug context lock in the core (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 92.04%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit e525506fcb67a9bbd94f01eac84af802139004eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e525506f.failed

Subsequent changes will require the ACPI core to acquire the lock
protecting the ACPIPHP hotplug contexts, so move the definition of
the lock to the core and change its name to be more generic.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit e525506fcb67a9bbd94f01eac84af802139004eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,8139a4b0d389..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -58,25 -59,78 +58,89 @@@
  static LIST_HEAD(bridge_list);
  static DEFINE_MUTEX(bridge_mutex);
  
 -static void handle_hotplug_event(acpi_handle handle, u32 type, void *data);
 +static void handle_hotplug_event_bridge (acpi_handle, u32, void *);
  static void acpiphp_sanitize_bus(struct pci_bus *bus);
  static void acpiphp_set_hpp_values(struct pci_bus *bus);
 -static void hotplug_event(u32 type, struct acpiphp_context *context);
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context);
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type, void *context);
  static void free_bridge(struct kref *kref);
  
 -static void acpiphp_context_handler(acpi_handle handle, void *context)
 +/* callback routine to check for the existence of a pci dock device */
 +static acpi_status
 +is_pci_dock_device(acpi_handle handle, u32 lvl, void *context, void **rv)
  {
 -	/* Intentionally empty. */
 -}
 +	int *count = (int *)context;
  
++<<<<<<< HEAD
 +	if (is_dock_device(handle)) {
 +		(*count)++;
 +		return AE_CTRL_TERMINATE;
 +	} else {
 +		return AE_OK;
 +	}
++=======
+ /**
+  * acpiphp_init_context - Create hotplug context and grab a reference to it.
+  * @adev: ACPI device object to create the context for.
+  *
+  * Call under acpi_hp_context_lock.
+  */
+ static struct acpiphp_context *acpiphp_init_context(struct acpi_device *adev)
+ {
+ 	struct acpiphp_context *context;
+ 	acpi_status status;
+ 
+ 	context = kzalloc(sizeof(*context), GFP_KERNEL);
+ 	if (!context)
+ 		return NULL;
+ 
+ 	context->adev = adev;
+ 	context->refcount = 1;
+ 	status = acpi_attach_data(adev->handle, acpiphp_context_handler, context);
+ 	if (ACPI_FAILURE(status)) {
+ 		kfree(context);
+ 		return NULL;
+ 	}
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_get_context - Get hotplug context and grab a reference to it.
+  * @handle: ACPI object handle to get the context for.
+  *
+  * Call under acpi_hp_context_lock.
+  */
+ static struct acpiphp_context *acpiphp_get_context(acpi_handle handle)
+ {
+ 	struct acpiphp_context *context = NULL;
+ 	acpi_status status;
+ 	void *data;
+ 
+ 	status = acpi_get_data(handle, acpiphp_context_handler, &data);
+ 	if (ACPI_SUCCESS(status)) {
+ 		context = data;
+ 		context->refcount++;
+ 	}
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_put_context - Drop a reference to ACPI hotplug context.
+  * @context: ACPI hotplug context to drop a reference to.
+  *
+  * The context object is removed if there are no more references to it.
+  *
+  * Call under acpi_hp_context_lock.
+  */
+ static void acpiphp_put_context(struct acpiphp_context *context)
+ {
+ 	if (--context->refcount)
+ 		return;
+ 
+ 	WARN_ON(context->bridge);
+ 	acpi_detach_data(context->adev->handle, acpiphp_context_handler);
+ 	kfree(context);
++>>>>>>> e525506fcb67 (ACPI / hotplug / PCI: Define hotplug context lock in the core)
  }
  
  static inline void get_bridge(struct acpiphp_bridge *bridge)
@@@ -95,6 -150,8 +159,11 @@@ static void free_bridge(struct kref *kr
  	struct acpiphp_slot *slot, *next;
  	struct acpiphp_func *func, *tmp;
  
++<<<<<<< HEAD
++=======
+ 	acpi_lock_hp_context();
+ 
++>>>>>>> e525506fcb67 (ACPI / hotplug / PCI: Define hotplug context lock in the core)
  	bridge = container_of(kref, struct acpiphp_bridge, ref);
  
  	list_for_each_entry_safe(slot, next, &bridge->slots, node) {
@@@ -110,6 -173,8 +179,11 @@@
  	put_device(&bridge->pci_bus->dev);
  	pci_dev_put(bridge->pci_dev);
  	kfree(bridge);
++<<<<<<< HEAD
++=======
+ 
+ 	acpi_unlock_hp_context();
++>>>>>>> e525506fcb67 (ACPI / hotplug / PCI: Define hotplug context lock in the core)
  }
  
  /*
@@@ -143,12 -207,31 +217,34 @@@ static int post_dock_fixups(struct noti
  			| ((unsigned int)(bus->busn_res.end) << 16);
  		pci_write_config_dword(bus->self, PCI_PRIMARY_BUS, buses);
  	}
 +	return NOTIFY_OK;
  }
  
++<<<<<<< HEAD
++=======
+ static void dock_event(acpi_handle handle, u32 type, void *data)
+ {
+ 	struct acpiphp_context *context;
+ 
+ 	acpi_lock_hp_context();
+ 	context = acpiphp_get_context(handle);
+ 	if (!context || WARN_ON(context->adev->handle != handle)
+ 	    || context->func.parent->is_going_away) {
+ 		acpi_unlock_hp_context();
+ 		return;
+ 	}
+ 	get_bridge(context->func.parent);
+ 	acpiphp_put_context(context);
+ 	acpi_unlock_hp_context();
+ 
+ 	hotplug_event(type, context);
+ 
+ 	put_bridge(context->func.parent);
+ }
++>>>>>>> e525506fcb67 (ACPI / hotplug / PCI: Define hotplug context lock in the core)
  
  static const struct acpi_dock_ops acpiphp_dock_ops = {
 -	.fixup = post_dock_fixups,
 -	.handler = dock_event,
 +	.handler = hotplug_event_func,
  };
  
  /* Check whether the PCI device is managed by native PCIe hotplug driver */
@@@ -221,75 -309,66 +317,99 @@@ register_slot(acpi_handle handle, u32 l
  	device = (adr >> 16) & 0xffff;
  	function = adr & 0xffff;
  
++<<<<<<< HEAD
 +	pdev = bridge->pci_dev;
 +	if (pdev && device_is_managed_by_native_pciehp(pdev))
 +		return AE_OK;
++=======
+ 	acpi_lock_hp_context();
+ 	context = acpiphp_init_context(adev);
+ 	if (!context) {
+ 		acpi_unlock_hp_context();
+ 		acpi_handle_err(handle, "No hotplug context\n");
+ 		return AE_NOT_EXIST;
+ 	}
+ 	newfunc = &context->func;
+ 	newfunc->function = function;
+ 	newfunc->parent = bridge;
+ 	acpi_unlock_hp_context();
++>>>>>>> e525506fcb67 (ACPI / hotplug / PCI: Define hotplug context lock in the core)
 +
 +	newfunc = kzalloc(sizeof(struct acpiphp_func), GFP_KERNEL);
 +	if (!newfunc)
 +		return AE_NO_MEMORY;
  
 -	if (acpi_has_method(handle, "_EJ0"))
 +	newfunc->handle = handle;
 +	newfunc->function = function;
 +
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
  		newfunc->flags = FUNC_HAS_EJ0;
  
 -	if (acpi_has_method(handle, "_STA"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_STA", &tmp)))
  		newfunc->flags |= FUNC_HAS_STA;
  
 -	if (acpi_has_method(handle, "_DCK"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS0", &tmp)))
 +		newfunc->flags |= FUNC_HAS_PS0;
 +
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS3", &tmp)))
 +		newfunc->flags |= FUNC_HAS_PS3;
 +
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_DCK", &tmp)))
  		newfunc->flags |= FUNC_HAS_DCK;
  
 +	status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 +	if (ACPI_FAILURE(status)) {
 +		/*
 +		 * use the count of the number of slots we've found
 +		 * for the number of the slot
 +		 */
 +		sun = bridge->nr_slots+1;
 +	}
 +
  	/* search for objects that share the same slot */
  	list_for_each_entry(slot, &bridge->slots, node)
 -		if (slot->device == device)
 -			goto slot_found;
 +		if (slot->device == device) {
 +			if (slot->sun != sun)
 +				pr_warn("sibling found, but _SUN doesn't match!\n");
 +			found = 1;
 +			break;
 +		}
  
++<<<<<<< HEAD
 +	if (!found) {
 +		slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 +		if (!slot) {
 +			kfree(newfunc);
 +			return AE_NO_MEMORY;
 +		}
++=======
+ 	slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
+ 	if (!slot) {
+ 		acpi_lock_hp_context();
+ 		acpiphp_put_context(context);
+ 		acpi_unlock_hp_context();
+ 		return AE_NO_MEMORY;
+ 	}
++>>>>>>> e525506fcb67 (ACPI / hotplug / PCI: Define hotplug context lock in the core)
  
 -	slot->bus = bridge->pci_bus;
 -	slot->device = device;
 -	INIT_LIST_HEAD(&slot->funcs);
 -
 -	list_add_tail(&slot->node, &bridge->slots);
 -
 -	/* Register slots for ejectable functions only. */
 -	if (acpi_pci_check_ejectable(pbus, handle)  || is_dock_device(handle)) {
 -		unsigned long long sun;
 -		int retval;
 +		slot->bridge = bridge;
 +		slot->device = device;
 +		slot->sun = sun;
 +		INIT_LIST_HEAD(&slot->funcs);
 +		mutex_init(&slot->crit_sect);
  
 +		mutex_lock(&bridge_mutex);
 +		list_add_tail(&slot->node, &bridge->slots);
 +		mutex_unlock(&bridge_mutex);
  		bridge->nr_slots++;
 -		status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 -		if (ACPI_FAILURE(status))
 -			sun = bridge->nr_slots;
  
  		pr_debug("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",
 -		    sun, pci_domain_nr(pbus), pbus->number, device);
 -
 -		retval = acpiphp_register_hotplug_slot(slot, sun);
 +		    slot->sun, pci_domain_nr(pbus), pbus->number, device);
 +		retval = acpiphp_register_hotplug_slot(slot);
  		if (retval) {
 -			slot->slot = NULL;
 -			bridge->nr_slots--;
  			if (retval == -EBUSY)
  				pr_warn("Slot %llu already registered by another "
 -					"hotplug driver\n", sun);
 +					"hotplug driver\n", slot->sun);
  			else
  				pr_warn("acpiphp_register_hotplug_slot failed "
  					"(err code = 0x%x)\n", retval);
@@@ -491,73 -456,12 +611,80 @@@ static void cleanup_bridge(struct acpip
  	mutex_lock(&bridge_mutex);
  	list_del(&bridge->list);
  	mutex_unlock(&bridge_mutex);
++<<<<<<< HEAD
++=======
+ 
+ 	acpi_lock_hp_context();
+ 	bridge->is_going_away = true;
+ 	acpi_unlock_hp_context();
++>>>>>>> e525506fcb67 (ACPI / hotplug / PCI: Define hotplug context lock in the core)
  }
  
 +static int power_on_slot(struct acpiphp_slot *slot)
 +{
 +	acpi_status status;
 +	struct acpiphp_func *func;
 +	int retval = 0;
 +
 +	/* if already enabled, just skip */
 +	if (slot->flags & SLOT_POWEREDON)
 +		goto err_exit;
 +
 +	list_for_each_entry(func, &slot->funcs, sibling) {
 +		if (func->flags & FUNC_HAS_PS0) {
 +			pr_debug("%s: executing _PS0\n", __func__);
 +			status = acpi_evaluate_object(func->handle, "_PS0", NULL, NULL);
 +			if (ACPI_FAILURE(status)) {
 +				pr_warn("%s: _PS0 failed\n", __func__);
 +				retval = -1;
 +				goto err_exit;
 +			} else
 +				break;
 +		}
 +	}
 +
 +	/* TBD: evaluate _STA to check if the slot is enabled */
 +
 +	slot->flags |= SLOT_POWEREDON;
 +
 + err_exit:
 +	return retval;
 +}
 +
 +
 +static int power_off_slot(struct acpiphp_slot *slot)
 +{
 +	acpi_status status;
 +	struct acpiphp_func *func;
 +
 +	int retval = 0;
 +
 +	/* if already disabled, just skip */
 +	if ((slot->flags & SLOT_POWEREDON) == 0)
 +		goto err_exit;
 +
 +	list_for_each_entry(func, &slot->funcs, sibling) {
 +		if (func->flags & FUNC_HAS_PS3) {
 +			status = acpi_evaluate_object(func->handle, "_PS3", NULL, NULL);
 +			if (ACPI_FAILURE(status)) {
 +				pr_warn("%s: _PS3 failed\n", __func__);
 +				retval = -1;
 +				goto err_exit;
 +			} else
 +				break;
 +		}
 +	}
 +
 +	/* TBD: evaluate _STA to check if the slot is disabled */
 +
 +	slot->flags &= (~SLOT_POWEREDON);
 +
 + err_exit:
 +	return retval;
 +}
 +
 +
 +
  /**
   * acpiphp_max_busnr - return the highest reserved bus number under the given bus.
   * @bus: bus to start search with
@@@ -977,29 -808,25 +1104,38 @@@ void acpiphp_check_host_bridge(acpi_han
  		pci_unlock_rescan_remove();
  		put_bridge(bridge);
  	}
 -}
  
 -static int acpiphp_disable_and_eject_slot(struct acpiphp_slot *slot);
 +	acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
 +		ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
 +}
  
 -static void hotplug_event(u32 type, struct acpiphp_context *context)
 +static void _handle_hotplug_event_bridge(struct work_struct *work)
  {
 -	acpi_handle handle = context->adev->handle;
 -	struct acpiphp_func *func = &context->func;
 -	struct acpiphp_slot *slot = func->slot;
  	struct acpiphp_bridge *bridge;
 +	char objname[64];
 +	struct acpi_buffer buffer = { .length = sizeof(objname),
 +				      .pointer = objname };
 +	struct acpi_hp_work *hp_work;
 +	acpi_handle handle;
 +	u32 type;
 +
++<<<<<<< HEAD
 +	hp_work = container_of(work, struct acpi_hp_work, work);
 +	handle = hp_work->handle;
 +	type = hp_work->type;
 +	bridge = (struct acpiphp_bridge *)hp_work->context;
  
 +	acpi_scan_lock_acquire();
++=======
+ 	acpi_lock_hp_context();
+ 	bridge = context->bridge;
+ 	if (bridge)
+ 		get_bridge(bridge);
+ 
+ 	acpi_unlock_hp_context();
++>>>>>>> e525506fcb67 (ACPI / hotplug / PCI: Define hotplug context lock in the core)
  
 -	pci_lock_rescan_remove();
 +	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
  
  	switch (type) {
  	case ACPI_NOTIFY_BUS_CHECK:
@@@ -1107,62 -904,49 +1243,83 @@@ static void hotplug_event_func(acpi_han
  		break;
  
  	case ACPI_NOTIFY_DEVICE_WAKE:
 -		return;
 -
 -	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
 -		acpi_handle_err(handle, "Device cannot be configured due "
 -				"to a frequency mismatch\n");
 -		goto out;
 -
 -	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
 -		acpi_handle_err(handle, "Device cannot be configured due "
 -				"to a bus mode mismatch\n");
 -		goto out;
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
 +		break;
  
 -	case ACPI_NOTIFY_POWER_FAULT:
 -		acpi_handle_err(handle, "Device has suffered a power fault\n");
 -		goto out;
 +	case ACPI_NOTIFY_EJECT_REQUEST:
 +		/* request device eject */
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if (!(acpiphp_disable_slot(func->slot)))
 +			acpiphp_eject_slot(func->slot);
 +		break;
  
  	default:
 -		acpi_handle_warn(handle, "Unsupported event type 0x%x\n", type);
 -		ost_code = ACPI_OST_SC_UNRECOGNIZED_NOTIFY;
 -		goto out;
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
 +		break;
  	}
 +}
 +
++<<<<<<< HEAD
 +static void _handle_hotplug_event_func(struct work_struct *work)
 +{
 +	struct acpi_hp_work *hp_work;
 +	struct acpiphp_func *func;
  
 +	hp_work = container_of(work, struct acpi_hp_work, work);
 +	func = hp_work->context;
 +	acpi_scan_lock_acquire();
 +
 +	hotplug_event_func(hp_work->handle, hp_work->type, func);
++=======
+ 	acpi_lock_hp_context();
+ 	context = acpiphp_get_context(handle);
+ 	if (!context || WARN_ON(context->adev->handle != handle)
+ 	    || context->func.parent->is_going_away)
+ 		goto err_out;
+ 
+ 	get_bridge(context->func.parent);
+ 	acpiphp_put_context(context);
+ 	status = acpi_hotplug_execute(hotplug_event_work, context, type);
+ 	if (ACPI_SUCCESS(status)) {
+ 		acpi_unlock_hp_context();
+ 		return;
+ 	}
+ 	put_bridge(context->func.parent);
+ 
+  err_out:
+ 	acpi_unlock_hp_context();
+ 	ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
++>>>>>>> e525506fcb67 (ACPI / hotplug / PCI: Define hotplug context lock in the core)
 +
 +	acpi_scan_lock_release();
 +	kfree(hp_work); /* allocated in handle_hotplug_event_func */
 +	put_bridge(func->slot->bridge);
 +}
  
 - out:
 -	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
 +/**
 + * handle_hotplug_event_func - handle ACPI event on functions (i.e. slots)
 + * @handle: Notify()'ed acpi_handle
 + * @type: Notify code
 + * @context: pointer to acpiphp_func structure
 + *
 + * Handles ACPI event notification on slots.
 + */
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type,
 +				      void *context)
 +{
 +	struct acpiphp_func *func = context;
 +
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(func->slot->bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_func);
  }
  
  /**
@@@ -1202,15 -989,44 +1359,41 @@@ void acpiphp_enumerate_slots(struct pci
  	 */
  	get_device(&bus->dev);
  
++<<<<<<< HEAD
 +	if (!pci_is_root_bus(bridge->pci_bus) &&
 +	    ACPI_SUCCESS(acpi_get_handle(bridge->handle,
 +					"_EJ0", &dummy_handle))) {
 +		pr_debug("found ejectable p2p bridge\n");
 +		bridge->flags |= BRIDGE_HAS_EJ0;
 +		bridge->func = acpiphp_bridge_handle_to_function(handle);
++=======
+ 	if (!pci_is_root_bus(bridge->pci_bus)) {
+ 		struct acpiphp_context *context;
+ 
+ 		/*
+ 		 * This bridge should have been registered as a hotplug function
+ 		 * under its parent, so the context should be there, unless the
+ 		 * parent is going to be handled by pciehp, in which case this
+ 		 * bridge is not interesting to us either.
+ 		 */
+ 		acpi_lock_hp_context();
+ 		context = acpiphp_get_context(handle);
+ 		if (!context) {
+ 			acpi_unlock_hp_context();
+ 			put_device(&bus->dev);
+ 			pci_dev_put(bridge->pci_dev);
+ 			kfree(bridge);
+ 			return;
+ 		}
+ 		bridge->context = context;
+ 		context->bridge = bridge;
+ 		/* Get a reference to the parent bridge. */
+ 		get_bridge(context->func.parent);
+ 		acpi_unlock_hp_context();
++>>>>>>> e525506fcb67 (ACPI / hotplug / PCI: Define hotplug context lock in the core)
  	}
  
 -	/* must be added to the list prior to calling register_slot */
 -	mutex_lock(&bridge_mutex);
 -	list_add(&bridge->list, &bridge_list);
 -	mutex_unlock(&bridge_mutex);
 -
 -	/* register all slot objects under this bridge */
 -	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
 -				     register_slot, NULL, bridge, NULL);
 -	if (ACPI_FAILURE(status)) {
 -		acpi_handle_err(handle, "failed to register slots\n");
 -		cleanup_bridge(bridge);
 -		put_bridge(bridge);
 -	}
 +	init_bridge_misc(bridge);
  }
  
  /**
diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c
index b30a50799f84..8d1493508dd7 100644
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@ -40,6 +40,7 @@ static DEFINE_MUTEX(acpi_scan_lock);
 static LIST_HEAD(acpi_scan_handlers_list);
 DEFINE_MUTEX(acpi_device_lock);
 LIST_HEAD(acpi_wakeup_device_list);
+static DEFINE_MUTEX(acpi_hp_context_lock);
 
 struct acpi_device_bus_id{
 	char bus_id[15];
@@ -59,6 +60,16 @@ void acpi_scan_lock_release(void)
 }
 EXPORT_SYMBOL_GPL(acpi_scan_lock_release);
 
+void acpi_lock_hp_context(void)
+{
+	mutex_lock(&acpi_hp_context_lock);
+}
+
+void acpi_unlock_hp_context(void)
+{
+	mutex_unlock(&acpi_hp_context_lock);
+}
+
 int acpi_scan_add_handler(struct acpi_scan_handler *handler)
 {
 	if (!handler || !handler->attach)
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
index f5d6e1e4030e..4641955651bc 100644
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -387,6 +387,8 @@ static inline int acpi_bus_generate_proc_event(struct acpi_device *device, u8 ty
 
 void acpi_scan_lock_acquire(void);
 void acpi_scan_lock_release(void);
+void acpi_lock_hp_context(void);
+void acpi_unlock_hp_context(void);
 int acpi_scan_add_handler(struct acpi_scan_handler *handler);
 int acpi_bus_register_driver(struct acpi_driver *driver);
 void acpi_bus_unregister_driver(struct acpi_driver *driver);
