GFS2: Fix return value in slot_get()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Abhi Das <adas@redhat.com>
commit e9fb7c73a43e0551e689b7024f1581af5fa36a03
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e9fb7c73.failed

ENOSPC was being returned in slot_get inspite of successful
execution of the function. This patch fixes this return
code.

	Signed-off-by: Abhi Das <adas@redhat.com>
	Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

(cherry picked from commit e9fb7c73a43e0551e689b7024f1581af5fa36a03)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/quota.c
diff --cc fs/gfs2/quota.c
index 679b366e073c,c4effff7cf55..000000000000
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@@ -241,45 -319,26 +241,56 @@@ static void qd_put(struct gfs2_quota_da
  
  static int slot_get(struct gfs2_quota_data *qd)
  {
 -	struct gfs2_sbd *sdp = qd->qd_sbd;
 -	unsigned int bit;
 -	int error = 0;
 +	struct gfs2_sbd *sdp = qd->qd_gl->gl_sbd;
 +	unsigned int c, o = 0, b;
 +	unsigned char byte = 0;
  
 -	spin_lock(&sdp->sd_bitmap_lock);
 -	if (qd->qd_slot_count != 0)
 -		goto out;
 +	spin_lock(&qd_lru_lock);
  
++<<<<<<< HEAD
 +	if (qd->qd_slot_count++) {
 +		spin_unlock(&qd_lru_lock);
 +		return 0;
++=======
+ 	error = -ENOSPC;
+ 	bit = find_first_zero_bit(sdp->sd_quota_bitmap, sdp->sd_quota_slots);
+ 	if (bit < sdp->sd_quota_slots) {
+ 		set_bit(bit, sdp->sd_quota_bitmap);
+ 		qd->qd_slot = bit;
+ 		error = 0;
+ out:
+ 		qd->qd_slot_count++;
++>>>>>>> e9fb7c73a43e (GFS2: Fix return value in slot_get())
  	}
 -	spin_unlock(&sdp->sd_bitmap_lock);
  
 -	return error;
 +	for (c = 0; c < sdp->sd_quota_chunks; c++)
 +		for (o = 0; o < PAGE_SIZE; o++) {
 +			byte = sdp->sd_quota_bitmap[c][o];
 +			if (byte != 0xFF)
 +				goto found;
 +		}
 +
 +	goto fail;
 +
 +found:
 +	for (b = 0; b < 8; b++)
 +		if (!(byte & (1 << b)))
 +			break;
 +	qd->qd_slot = c * (8 * PAGE_SIZE) + o * 8 + b;
 +
 +	if (qd->qd_slot >= sdp->sd_quota_slots)
 +		goto fail;
 +
 +	sdp->sd_quota_bitmap[c][o] |= 1 << b;
 +
 +	spin_unlock(&qd_lru_lock);
 +
 +	return 0;
 +
 +fail:
 +	qd->qd_slot_count--;
 +	spin_unlock(&qd_lru_lock);
 +	return -ENOSPC;
  }
  
  static void slot_hold(struct gfs2_quota_data *qd)
* Unmerged path fs/gfs2/quota.c
