xprtrdma: On disconnect, don't ignore pending CQEs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit a7bc211ac926172ad20463afcf00ae7b9ebcd950
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a7bc211a.failed

xprtrdma is currently throwing away queued completions during
a reconnect. RPC replies posted just before connection loss, or
successful completions that change the state of an FRMR, can be
missed.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Tested-by: Steve Wise <swise@opengridcomputing.com>
	Tested-by: Shirley Ma <shirley.ma@oracle.com>
	Tested-by: Devesh Sharma <devesh.sharma@emulex.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit a7bc211ac926172ad20463afcf00ae7b9ebcd950)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/verbs.c
diff --cc net/sunrpc/xprtrdma/verbs.c
index 24eb49bbb4c7,e49cdc930dfd..000000000000
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@@ -261,9 -307,16 +261,16 @@@ rpcrdma_cq_event_upcall(struct ib_cq *c
  		return;
  	}
  
 -	rpcrdma_recvcq_poll(cq, ep);
 +	rpcrdma_cq_poll(cq);
  }
  
+ static void
+ rpcrdma_flush_cqs(struct rpcrdma_ep *ep)
+ {
+ 	rpcrdma_recvcq_upcall(ep->rep_attr.recv_cq, ep);
+ 	rpcrdma_sendcq_upcall(ep->rep_attr.send_cq, ep);
+ }
+ 
  #ifdef RPC_DEBUG
  static const char * const conn[] = {
  	"address resolved",
@@@ -855,7 -879,7 +862,11 @@@ retry
  		if (rc && rc != -ENOTCONN)
  			dprintk("RPC:       %s: rpcrdma_ep_disconnect"
  				" status %i\n", __func__, rc);
++<<<<<<< HEAD
 +		rpcrdma_clean_cq(ep->rep_cq);
++=======
+ 		rpcrdma_flush_cqs(ep);
++>>>>>>> a7bc211ac926 (xprtrdma: On disconnect, don't ignore pending CQEs)
  
  		xprt = container_of(ia, struct rpcrdma_xprt, rx_ia);
  		id = rpcrdma_create_id(xprt, ia,
@@@ -966,7 -990,7 +977,11 @@@ rpcrdma_ep_disconnect(struct rpcrdma_e
  {
  	int rc;
  
++<<<<<<< HEAD
 +	rpcrdma_clean_cq(ep->rep_cq);
++=======
+ 	rpcrdma_flush_cqs(ep);
++>>>>>>> a7bc211ac926 (xprtrdma: On disconnect, don't ignore pending CQEs)
  	rc = rdma_disconnect(ia->ri_id);
  	if (!rc) {
  		/* returns without wait if not connected */
* Unmerged path net/sunrpc/xprtrdma/verbs.c
