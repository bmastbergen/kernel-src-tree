qlcnic: Add hwmon interface to export board temperature.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [ethernet] qlcnic: Add hwmon interface to export board temperature (Chad Dupuis) [1089352]
Rebuild_FUZZ: 99.10%
commit-author Harish Patil <harish.patil@qlogic.com>
commit 1f0f467b670eec101419a2a1235e315e4324ea07
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/1f0f467b.failed

	Signed-off-by: Harish Patil <harish.patil@qlogic.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1f0f467b670eec101419a2a1235e315e4324ea07)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/Kconfig
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
diff --cc drivers/net/ethernet/qlogic/Kconfig
index f59e6be4a66e,b8184323faae..000000000000
--- a/drivers/net/ethernet/qlogic/Kconfig
+++ b/drivers/net/ethernet/qlogic/Kconfig
@@@ -56,6 -56,27 +56,30 @@@ config QLCNIC_DC
  	  mode of DCB is supported. PG and PFC values are related only
  	  to Tx.
  
++<<<<<<< HEAD
++=======
+ config QLCNIC_VXLAN
+ 	bool "Virtual eXtensible Local Area Network (VXLAN) offload support"
+ 	default n
+ 	depends on QLCNIC && VXLAN && !(QLCNIC=y && VXLAN=m)
+ 	---help---
+ 	  This enables hardware offload support for VXLAN protocol over QLogic's
+ 	  84XX series adapters.
+ 	  Say Y here if you want to enable hardware offload support for
+ 	  Virtual eXtensible Local Area Network (VXLAN) in the driver.
+ 
+ config QLCNIC_HWMON
+ 	bool "QLOGIC QLCNIC 82XX and 83XX family HWMON support"
+ 	depends on QLCNIC && HWMON
+ 	default y
+ 	---help---
+ 	  This configuration parameter can be used to read the
+ 	  board temperature in Converged Ethernet devices
+ 	  supported by qlcnic.
+ 
+ 	  This data is available via the hwmon sysfs interface.
+ 
++>>>>>>> 1f0f467b670e (qlcnic: Add hwmon interface to export board temperature.)
  config QLGE
  	tristate "QLogic QLGE 10Gb Ethernet Driver Support"
  	depends on PCI
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
index d72671739763,381da04f1b71..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
@@@ -492,6 -536,8 +492,11 @@@ struct qlcnic_hardware_context 
  	u8 extend_lb_time;
  	u8 phys_port_id[ETH_ALEN];
  	u8 lb_mode;
++<<<<<<< HEAD
++=======
+ 	u16 vxlan_port;
+ 	struct device *hwmon_dev;
++>>>>>>> 1f0f467b670e (qlcnic: Add hwmon interface to export board temperature.)
  };
  
  struct qlcnic_adapter_stats {
* Unmerged path drivers/net/ethernet/qlogic/Kconfig
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic.h
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index d1c2562bf5f0..e4f72ff5373c 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@ -2413,7 +2413,7 @@ qlcnic_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		qlcnic_alloc_lb_filters_mem(adapter);
 
 	qlcnic_add_sysfs(adapter);
-
+	qlcnic_register_hwmon_dev(adapter);
 	return 0;
 
 err_out_disable_mbx_intr:
@@ -2520,6 +2520,8 @@ static void qlcnic_remove(struct pci_dev *pdev)
 
 	qlcnic_remove_sysfs(adapter);
 
+	qlcnic_unregister_hwmon_dev(adapter);
+
 	qlcnic_cleanup_pci_map(adapter->ahw);
 
 	qlcnic_release_firmware(adapter);
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c
index 0065a13c4c20..423ee35bf471 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_sysfs.c
@@ -19,6 +19,10 @@
 #include <linux/sysfs.h>
 #include <linux/aer.h>
 #include <linux/log2.h>
+#ifdef CONFIG_QLCNIC_HWMON
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#endif
 
 #define QLC_STATUS_UNSUPPORTED_CMD	-2
 
@@ -1252,6 +1256,68 @@ static struct bin_attribute bin_attr_flash = {
 	.write = qlcnic_83xx_sysfs_flash_write_handler,
 };
 
+#ifdef CONFIG_QLCNIC_HWMON
+
+static ssize_t qlcnic_hwmon_show_temp(struct device *dev,
+				      struct device_attribute *dev_attr,
+				      char *buf)
+{
+	struct qlcnic_adapter *adapter = dev_get_drvdata(dev);
+	unsigned int temperature = 0, value = 0;
+
+	if (qlcnic_83xx_check(adapter))
+		value = QLCRDX(adapter->ahw, QLC_83XX_ASIC_TEMP);
+	else if (qlcnic_82xx_check(adapter))
+		value = QLC_SHARED_REG_RD32(adapter, QLCNIC_ASIC_TEMP);
+
+	temperature = qlcnic_get_temp_val(value);
+	/* display millidegree celcius */
+	temperature *= 1000;
+	return sprintf(buf, "%u\n", temperature);
+}
+
+/* hwmon-sysfs attributes */
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO,
+			  qlcnic_hwmon_show_temp, NULL, 1);
+
+static struct attribute *qlcnic_hwmon_attrs[] = {
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	NULL
+};
+
+ATTRIBUTE_GROUPS(qlcnic_hwmon);
+
+void qlcnic_register_hwmon_dev(struct qlcnic_adapter *adapter)
+{
+	struct device *dev = &adapter->pdev->dev;
+	struct device *hwmon_dev;
+
+	/* Skip hwmon registration for a VF device */
+	if (qlcnic_sriov_vf_check(adapter)) {
+		adapter->ahw->hwmon_dev = NULL;
+		return;
+	}
+	hwmon_dev = hwmon_device_register_with_groups(dev, qlcnic_driver_name,
+						      adapter,
+						      qlcnic_hwmon_groups);
+	if (IS_ERR(hwmon_dev)) {
+		dev_err(dev, "Cannot register with hwmon, err=%ld\n",
+			PTR_ERR(hwmon_dev));
+		hwmon_dev = NULL;
+	}
+	adapter->ahw->hwmon_dev = hwmon_dev;
+}
+
+void qlcnic_unregister_hwmon_dev(struct qlcnic_adapter *adapter)
+{
+	struct device *hwmon_dev = adapter->ahw->hwmon_dev;
+	if (hwmon_dev) {
+		hwmon_device_unregister(hwmon_dev);
+		adapter->ahw->hwmon_dev = NULL;
+	}
+}
+#endif
+
 void qlcnic_create_sysfs_entries(struct qlcnic_adapter *adapter)
 {
 	struct device *dev = &adapter->pdev->dev;
