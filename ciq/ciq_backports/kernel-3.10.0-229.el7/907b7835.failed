igb: Add ethtool support to configure number of channels

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Laura Mihaela Vasilescu <laura.vasilescu@rosedu.org>
commit 907b7835799f741bf80e18b635555dc332ca9863
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/907b7835.failed

This patch adds the ethtool callbacks necessary to configure the
number of RSS queues.

The maximum number of queues is in accordance with the datasheets.

	Signed-off-by: Laura Mihaela Vasilescu <laura.vasilescu@rosedu.org>
	Tested-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 907b7835799f741bf80e18b635555dc332ca9863)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/igb/igb.h
diff --cc drivers/net/ethernet/intel/igb/igb.h
index 6807b098edae,5e9ed89403aa..000000000000
--- a/drivers/net/ethernet/intel/igb/igb.h
+++ b/drivers/net/ethernet/intel/igb/igb.h
@@@ -483,40 -483,38 +483,75 @@@ enum igb_boards 
  extern char igb_driver_name[];
  extern char igb_driver_version[];
  
++<<<<<<< HEAD
 +extern int igb_up(struct igb_adapter *);
 +extern void igb_down(struct igb_adapter *);
 +extern void igb_reinit_locked(struct igb_adapter *);
 +extern void igb_reset(struct igb_adapter *);
 +extern void igb_write_rss_indir_tbl(struct igb_adapter *);
 +extern int igb_set_spd_dplx(struct igb_adapter *, u32, u8);
 +extern int igb_setup_tx_resources(struct igb_ring *);
 +extern int igb_setup_rx_resources(struct igb_ring *);
 +extern void igb_free_tx_resources(struct igb_ring *);
 +extern void igb_free_rx_resources(struct igb_ring *);
 +extern void igb_configure_tx_ring(struct igb_adapter *, struct igb_ring *);
 +extern void igb_configure_rx_ring(struct igb_adapter *, struct igb_ring *);
 +extern void igb_setup_tctl(struct igb_adapter *);
 +extern void igb_setup_rctl(struct igb_adapter *);
 +extern netdev_tx_t igb_xmit_frame_ring(struct sk_buff *, struct igb_ring *);
 +extern void igb_unmap_and_free_tx_resource(struct igb_ring *,
 +					   struct igb_tx_buffer *);
 +extern void igb_alloc_rx_buffers(struct igb_ring *, u16);
 +extern void igb_update_stats(struct igb_adapter *, struct rtnl_link_stats64 *);
 +extern bool igb_has_link(struct igb_adapter *adapter);
 +extern void igb_set_ethtool_ops(struct net_device *);
 +extern void igb_power_up_link(struct igb_adapter *);
 +extern void igb_set_fw_version(struct igb_adapter *);
 +extern void igb_ptp_init(struct igb_adapter *adapter);
 +extern void igb_ptp_stop(struct igb_adapter *adapter);
 +extern void igb_ptp_reset(struct igb_adapter *adapter);
 +extern void igb_ptp_tx_work(struct work_struct *work);
 +extern void igb_ptp_rx_hang(struct igb_adapter *adapter);
 +extern void igb_ptp_tx_hwtstamp(struct igb_adapter *adapter);
 +extern void igb_ptp_rx_rgtstamp(struct igb_q_vector *q_vector,
 +				struct sk_buff *skb);
 +extern void igb_ptp_rx_pktstamp(struct igb_q_vector *q_vector,
 +				unsigned char *va,
 +				struct sk_buff *skb);
++=======
+ int igb_up(struct igb_adapter *);
+ void igb_down(struct igb_adapter *);
+ void igb_reinit_locked(struct igb_adapter *);
+ void igb_reset(struct igb_adapter *);
+ int igb_reinit_queues(struct igb_adapter *);
+ void igb_write_rss_indir_tbl(struct igb_adapter *);
+ int igb_set_spd_dplx(struct igb_adapter *, u32, u8);
+ int igb_setup_tx_resources(struct igb_ring *);
+ int igb_setup_rx_resources(struct igb_ring *);
+ void igb_free_tx_resources(struct igb_ring *);
+ void igb_free_rx_resources(struct igb_ring *);
+ void igb_configure_tx_ring(struct igb_adapter *, struct igb_ring *);
+ void igb_configure_rx_ring(struct igb_adapter *, struct igb_ring *);
+ void igb_setup_tctl(struct igb_adapter *);
+ void igb_setup_rctl(struct igb_adapter *);
+ netdev_tx_t igb_xmit_frame_ring(struct sk_buff *, struct igb_ring *);
+ void igb_unmap_and_free_tx_resource(struct igb_ring *, struct igb_tx_buffer *);
+ void igb_alloc_rx_buffers(struct igb_ring *, u16);
+ void igb_update_stats(struct igb_adapter *, struct rtnl_link_stats64 *);
+ bool igb_has_link(struct igb_adapter *adapter);
+ void igb_set_ethtool_ops(struct net_device *);
+ void igb_power_up_link(struct igb_adapter *);
+ void igb_set_fw_version(struct igb_adapter *);
+ void igb_ptp_init(struct igb_adapter *adapter);
+ void igb_ptp_stop(struct igb_adapter *adapter);
+ void igb_ptp_reset(struct igb_adapter *adapter);
+ void igb_ptp_tx_work(struct work_struct *work);
+ void igb_ptp_rx_hang(struct igb_adapter *adapter);
+ void igb_ptp_tx_hwtstamp(struct igb_adapter *adapter);
+ void igb_ptp_rx_rgtstamp(struct igb_q_vector *q_vector, struct sk_buff *skb);
+ void igb_ptp_rx_pktstamp(struct igb_q_vector *q_vector, unsigned char *va,
+ 			 struct sk_buff *skb);
++>>>>>>> 907b7835799f (igb: Add ethtool support to configure number of channels)
  static inline void igb_ptp_rx_hwtstamp(struct igb_ring *rx_ring,
  				       union e1000_adv_rx_desc *rx_desc,
  				       struct sk_buff *skb)
* Unmerged path drivers/net/ethernet/intel/igb/igb.h
diff --git a/drivers/net/ethernet/intel/igb/igb_ethtool.c b/drivers/net/ethernet/intel/igb/igb_ethtool.c
index caa78d587fe0..ebdac0273501 100644
--- a/drivers/net/ethernet/intel/igb/igb_ethtool.c
+++ b/drivers/net/ethernet/intel/igb/igb_ethtool.c
@@ -2877,6 +2877,88 @@ static int igb_set_rxfh_indir(struct net_device *netdev, const u32 *indir)
 	return 0;
 }
 
+static unsigned int igb_max_channels(struct igb_adapter *adapter)
+{
+	struct e1000_hw *hw = &adapter->hw;
+	unsigned int max_combined = 0;
+
+	switch (hw->mac.type) {
+	case e1000_i211:
+		max_combined = IGB_MAX_RX_QUEUES_I211;
+		break;
+	case e1000_82575:
+	case e1000_i210:
+		max_combined = IGB_MAX_RX_QUEUES_82575;
+		break;
+	case e1000_i350:
+		if (!!adapter->vfs_allocated_count) {
+			max_combined = 1;
+			break;
+		}
+		/* fall through */
+	case e1000_82576:
+		if (!!adapter->vfs_allocated_count) {
+			max_combined = 2;
+			break;
+		}
+		/* fall through */
+	case e1000_82580:
+	case e1000_i354:
+	default:
+		max_combined = IGB_MAX_RX_QUEUES;
+		break;
+	}
+
+	return max_combined;
+}
+
+static void igb_get_channels(struct net_device *netdev,
+			     struct ethtool_channels *ch)
+{
+	struct igb_adapter *adapter = netdev_priv(netdev);
+
+	/* Report maximum channels */
+	ch->max_combined = igb_max_channels(adapter);
+
+	/* Report info for other vector */
+	if (adapter->msix_entries) {
+		ch->max_other = NON_Q_VECTORS;
+		ch->other_count = NON_Q_VECTORS;
+	}
+
+	ch->combined_count = adapter->rss_queues;
+}
+
+static int igb_set_channels(struct net_device *netdev,
+			    struct ethtool_channels *ch)
+{
+	struct igb_adapter *adapter = netdev_priv(netdev);
+	unsigned int count = ch->combined_count;
+
+	/* Verify they are not requesting separate vectors */
+	if (!count || ch->rx_count || ch->tx_count)
+		return -EINVAL;
+
+	/* Verify other_count is valid and has not been changed */
+	if (ch->other_count != NON_Q_VECTORS)
+		return -EINVAL;
+
+	/* Verify the number of channels doesn't exceed hw limits */
+	if (count > igb_max_channels(adapter))
+		return -EINVAL;
+
+	if (count != adapter->rss_queues) {
+		adapter->rss_queues = count;
+
+		/* Hardware has to reinitialize queues and interrupts to
+		 * match the new configuration.
+		 */
+		return igb_reinit_queues(adapter);
+	}
+
+	return 0;
+}
+
 static const struct ethtool_ops igb_ethtool_ops = {
 	.get_settings		= igb_get_settings,
 	.set_settings		= igb_set_settings,
@@ -2913,6 +2995,8 @@ static const struct ethtool_ops igb_ethtool_ops = {
 	.get_rxfh_indir_size	= igb_get_rxfh_indir_size,
 	.get_rxfh_indir		= igb_get_rxfh_indir,
 	.set_rxfh_indir		= igb_set_rxfh_indir,
+	.get_channels		= igb_get_channels,
+	.set_channels		= igb_set_channels,
 	.begin			= igb_ethtool_begin,
 	.complete		= igb_ethtool_complete,
 };
diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index 421f3f1e7a72..95b4473de195 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -7833,4 +7833,26 @@ s32 igb_write_i2c_byte(struct e1000_hw *hw, u8 byte_offset,
 		return E1000_SUCCESS;
 
 }
+
+int igb_reinit_queues(struct igb_adapter *adapter)
+{
+	struct net_device *netdev = adapter->netdev;
+	struct pci_dev *pdev = adapter->pdev;
+	int err = 0;
+
+	if (netif_running(netdev))
+		igb_close(netdev);
+
+	igb_clear_interrupt_scheme(adapter);
+
+	if (igb_init_interrupt_scheme(adapter, true)) {
+		dev_err(&pdev->dev, "Unable to allocate memory for queues\n");
+		return -ENOMEM;
+	}
+
+	if (netif_running(netdev))
+		err = igb_open(netdev);
+
+	return err;
+}
 /* igb_main.c */
