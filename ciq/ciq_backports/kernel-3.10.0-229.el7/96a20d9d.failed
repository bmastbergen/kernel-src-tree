bridge: Add a default_pvid sysfs attribute

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Vlad Yasevich <vyasevich@gmail.com>
commit 96a20d9d7fff7068a2233b00379f0778a150bf86
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/96a20d9d.failed

This patch allows the user to set and retrieve default_pvid
value.  A new value can only be stored when vlan filtering
is disabled.

	Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 96a20d9d7fff7068a2233b00379f0778a150bf86)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_private.h
#	net/bridge/br_sysfs_br.c
#	net/bridge/br_vlan.c
diff --cc net/bridge/br_private.h
index 10b5654d52ef,5a347eb1d139..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -296,8 -295,11 +296,13 @@@ struct net_bridg
  	struct timer_list		topology_change_timer;
  	struct timer_list		gc_timer;
  	struct kobject			*ifobj;
 -	u32				auto_cnt;
  #ifdef CONFIG_BRIDGE_VLAN_FILTERING
  	u8				vlan_enabled;
++<<<<<<< HEAD
++=======
+ 	__be16				vlan_proto;
+ 	u16				default_pvid;
++>>>>>>> 96a20d9d7fff (bridge: Add a default_pvid sysfs attribute)
  	struct net_port_vlans __rcu	*vlan_info;
  #endif
  };
@@@ -611,22 -590,27 +616,46 @@@ static inline void br_mdb_uninit(void
  
  /* br_vlan.c */
  #ifdef CONFIG_BRIDGE_VLAN_FILTERING
++<<<<<<< HEAD
 +extern bool br_allowed_ingress(struct net_bridge *br, struct net_port_vlans *v,
 +			       struct sk_buff *skb, u16 *vid);
 +extern bool br_allowed_egress(struct net_bridge *br,
 +			      const struct net_port_vlans *v,
 +			      const struct sk_buff *skb);
 +extern struct sk_buff *br_handle_vlan(struct net_bridge *br,
 +				      const struct net_port_vlans *v,
 +				      struct sk_buff *skb);
 +extern int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
 +extern int br_vlan_delete(struct net_bridge *br, u16 vid);
 +extern void br_vlan_flush(struct net_bridge *br);
 +extern int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 +extern int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
 +extern int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 +extern void nbp_vlan_flush(struct net_bridge_port *port);
 +extern bool nbp_vlan_find(struct net_bridge_port *port, u16 vid);
++=======
+ bool br_allowed_ingress(struct net_bridge *br, struct net_port_vlans *v,
+ 			struct sk_buff *skb, u16 *vid);
+ bool br_allowed_egress(struct net_bridge *br, const struct net_port_vlans *v,
+ 		       const struct sk_buff *skb);
+ bool br_should_learn(struct net_bridge_port *p, struct sk_buff *skb, u16 *vid);
+ struct sk_buff *br_handle_vlan(struct net_bridge *br,
+ 			       const struct net_port_vlans *v,
+ 			       struct sk_buff *skb);
+ int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
+ int br_vlan_delete(struct net_bridge *br, u16 vid);
+ void br_vlan_flush(struct net_bridge *br);
+ bool br_vlan_find(struct net_bridge *br, u16 vid);
+ void br_recalculate_fwd_mask(struct net_bridge *br);
+ int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
+ int br_vlan_set_proto(struct net_bridge *br, unsigned long val);
+ void br_vlan_init(struct net_bridge *br);
+ int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val);
+ int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
+ int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
+ void nbp_vlan_flush(struct net_bridge_port *port);
+ bool nbp_vlan_find(struct net_bridge_port *port, u16 vid);
++>>>>>>> 96a20d9d7fff (bridge: Add a default_pvid sysfs attribute)
  
  static inline struct net_port_vlans *br_get_vlan_info(
  						const struct net_bridge *br)
diff --cc net/bridge/br_sysfs_br.c
index 8baa9c08e1a4,4c97fc50fb70..000000000000
--- a/net/bridge/br_sysfs_br.c
+++ b/net/bridge/br_sysfs_br.c
@@@ -706,8 -708,39 +706,44 @@@ static ssize_t store_vlan_filtering(str
  {
  	return store_bridge_parm(d, buf, len, br_vlan_filter_toggle);
  }
++<<<<<<< HEAD
 +static DEVICE_ATTR(vlan_filtering, S_IRUGO | S_IWUSR,
 +		   show_vlan_filtering, store_vlan_filtering);
++=======
+ static DEVICE_ATTR_RW(vlan_filtering);
+ 
+ static ssize_t vlan_protocol_show(struct device *d,
+ 				  struct device_attribute *attr,
+ 				  char *buf)
+ {
+ 	struct net_bridge *br = to_bridge(d);
+ 	return sprintf(buf, "%#06x\n", ntohs(br->vlan_proto));
+ }
+ 
+ static ssize_t vlan_protocol_store(struct device *d,
+ 				   struct device_attribute *attr,
+ 				   const char *buf, size_t len)
+ {
+ 	return store_bridge_parm(d, buf, len, br_vlan_set_proto);
+ }
+ static DEVICE_ATTR_RW(vlan_protocol);
+ 
+ static ssize_t default_pvid_show(struct device *d,
+ 				 struct device_attribute *attr,
+ 				 char *buf)
+ {
+ 	struct net_bridge *br = to_bridge(d);
+ 	return sprintf(buf, "%d\n", br->default_pvid);
+ }
+ 
+ static ssize_t default_pvid_store(struct device *d,
+ 				  struct device_attribute *attr,
+ 				  const char *buf, size_t len)
+ {
+ 	return store_bridge_parm(d, buf, len, br_vlan_set_default_pvid);
+ }
+ static DEVICE_ATTR_RW(default_pvid);
++>>>>>>> 96a20d9d7fff (bridge: Add a default_pvid sysfs attribute)
  #endif
  
  static struct attribute *bridge_attrs[] = {
@@@ -752,6 -786,8 +788,11 @@@
  #endif
  #ifdef CONFIG_BRIDGE_VLAN_FILTERING
  	&dev_attr_vlan_filtering.attr,
++<<<<<<< HEAD
++=======
+ 	&dev_attr_vlan_protocol.attr,
+ 	&dev_attr_default_pvid.attr,
++>>>>>>> 96a20d9d7fff (bridge: Add a default_pvid sysfs attribute)
  #endif
  	NULL
  };
diff --cc net/bridge/br_vlan.c
index c5c15c7d9539,dfa7c9a7e193..000000000000
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@@ -307,6 -431,108 +307,111 @@@ unlock
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ int br_vlan_set_proto(struct net_bridge *br, unsigned long val)
+ {
+ 	int err = 0;
+ 	struct net_bridge_port *p;
+ 	struct net_port_vlans *pv;
+ 	__be16 proto, oldproto;
+ 	u16 vid, errvid;
+ 
+ 	if (val != ETH_P_8021Q && val != ETH_P_8021AD)
+ 		return -EPROTONOSUPPORT;
+ 
+ 	if (!rtnl_trylock())
+ 		return restart_syscall();
+ 
+ 	proto = htons(val);
+ 	if (br->vlan_proto == proto)
+ 		goto unlock;
+ 
+ 	/* Add VLANs for the new proto to the device filter. */
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		pv = rtnl_dereference(p->vlan_info);
+ 		if (!pv)
+ 			continue;
+ 
+ 		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {
+ 			err = vlan_vid_add(p->dev, proto, vid);
+ 			if (err)
+ 				goto err_filt;
+ 		}
+ 	}
+ 
+ 	oldproto = br->vlan_proto;
+ 	br->vlan_proto = proto;
+ 
+ 	recalculate_group_addr(br);
+ 	br_recalculate_fwd_mask(br);
+ 
+ 	/* Delete VLANs for the old proto from the device filter. */
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		pv = rtnl_dereference(p->vlan_info);
+ 		if (!pv)
+ 			continue;
+ 
+ 		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID)
+ 			vlan_vid_del(p->dev, oldproto, vid);
+ 	}
+ 
+ unlock:
+ 	rtnl_unlock();
+ 	return err;
+ 
+ err_filt:
+ 	errvid = vid;
+ 	for_each_set_bit(vid, pv->vlan_bitmap, errvid)
+ 		vlan_vid_del(p->dev, proto, vid);
+ 
+ 	list_for_each_entry_continue_reverse(p, &br->port_list, list) {
+ 		pv = rtnl_dereference(p->vlan_info);
+ 		if (!pv)
+ 			continue;
+ 
+ 		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID)
+ 			vlan_vid_del(p->dev, proto, vid);
+ 	}
+ 
+ 	goto unlock;
+ }
+ 
+ int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val)
+ {
+ 	u16 pvid = val;
+ 	int err = 0;
+ 
+ 	if (!val || val >= VLAN_VID_MASK)
+ 		return -EINVAL;
+ 
+ 	if (!rtnl_trylock())
+ 		return restart_syscall();
+ 
+ 	if (pvid == br->default_pvid)
+ 		goto unlock;
+ 
+ 	/* Only allow default pvid change when filtering is disabled */
+ 	if (br->vlan_enabled) {
+ 		pr_info_once("Please disable vlan filtering to change default_pvid\n");
+ 		err = -EPERM;
+ 		goto unlock;
+ 	}
+ 
+ 	br->default_pvid = pvid;
+ 
+ unlock:
+ 	rtnl_unlock();
+ 	return err;
+ }
+ 
+ void br_vlan_init(struct net_bridge *br)
+ {
+ 	br->vlan_proto = htons(ETH_P_8021Q);
+ 	br->default_pvid = 1;
+ }
+ 
++>>>>>>> 96a20d9d7fff (bridge: Add a default_pvid sysfs attribute)
  /* Must be protected by RTNL.
   * Must be called with vid in range from 1 to 4094 inclusive.
   */
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_sysfs_br.c
* Unmerged path net/bridge/br_vlan.c
