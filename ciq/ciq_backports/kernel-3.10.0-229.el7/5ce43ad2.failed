PKCS#7: Use x509_request_asymmetric_key()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [crypto] pkcs7: Use x509_request_asymmetric_key() (Vivek Goyal) [1129779]
Rebuild_FUZZ: 98.77%
commit-author David Howells <dhowells@redhat.com>
commit 5ce43ad28262115a1eab866392f8cfb985094160
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5ce43ad2.failed

pkcs7_request_asymmetric_key() and x509_request_asymmetric_key() do the same
thing, the latter being a copy of the former created by the IMA folks, so drop
the PKCS#7 version as the X.509 location is more general.

Whilst we're at it, rename the arguments of x509_request_asymmetric_key() to
better reflect what the values being passed in are intended to match on an
X.509 cert.

	Signed-off-by: David Howells <dhowells@redhat.com>
	Acked-by: Mimi Zohar <zohar@linux.vnet.ibm.com>
(cherry picked from commit 5ce43ad28262115a1eab866392f8cfb985094160)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/asymmetric_keys/pkcs7_trust.c
#	crypto/asymmetric_keys/x509_public_key.c
diff --cc crypto/asymmetric_keys/x509_public_key.c
index 2fcf47e69b21,da1e5fc85346..000000000000
--- a/crypto/asymmetric_keys/x509_public_key.c
+++ b/crypto/asymmetric_keys/x509_public_key.c
@@@ -23,6 -24,79 +23,82 @@@
  #include "public_key.h"
  #include "x509_parser.h"
  
++<<<<<<< HEAD
++=======
+ static bool use_builtin_keys;
+ static char *ca_keyid;
+ 
+ #ifndef MODULE
+ static int __init ca_keys_setup(char *str)
+ {
+ 	if (!str)		/* default system keyring */
+ 		return 1;
+ 
+ 	if (strncmp(str, "id:", 3) == 0)
+ 		ca_keyid = str;	/* owner key 'id:xxxxxx' */
+ 	else if (strcmp(str, "builtin") == 0)
+ 		use_builtin_keys = true;
+ 
+ 	return 1;
+ }
+ __setup("ca_keys=", ca_keys_setup);
+ #endif
+ 
+ /**
+  * x509_request_asymmetric_key - Request a key by X.509 certificate params.
+  * @keyring: The keys to search.
+  * @subject: The name of the subject to whom the key belongs.
+  * @key_id: The subject key ID as a hex string.
+  *
+  * Find a key in the given keyring by subject name and key ID.  These might,
+  * for instance, be the issuer name and the authority key ID of an X.509
+  * certificate that needs to be verified.
+  */
+ struct key *x509_request_asymmetric_key(struct key *keyring,
+ 					const char *subject,
+ 					const char *key_id)
+ {
+ 	key_ref_t key;
+ 	size_t subject_len = strlen(subject), key_id_len = strlen(key_id);
+ 	char *id;
+ 
+ 	/* Construct an identifier "<subjname>:<keyid>". */
+ 	id = kmalloc(subject_len + 2 + key_id_len + 1, GFP_KERNEL);
+ 	if (!id)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	memcpy(id, subject, subject_len);
+ 	id[subject_len + 0] = ':';
+ 	id[subject_len + 1] = ' ';
+ 	memcpy(id + subject_len + 2, key_id, key_id_len);
+ 	id[subject_len + 2 + key_id_len] = 0;
+ 
+ 	pr_debug("Look up: \"%s\"\n", id);
+ 
+ 	key = keyring_search(make_key_ref(keyring, 1),
+ 			     &key_type_asymmetric, id);
+ 	if (IS_ERR(key))
+ 		pr_debug("Request for key '%s' err %ld\n", id, PTR_ERR(key));
+ 	kfree(id);
+ 
+ 	if (IS_ERR(key)) {
+ 		switch (PTR_ERR(key)) {
+ 			/* Hide some search errors */
+ 		case -EACCES:
+ 		case -ENOTDIR:
+ 		case -EAGAIN:
+ 			return ERR_PTR(-ENOKEY);
+ 		default:
+ 			return ERR_CAST(key);
+ 		}
+ 	}
+ 
+ 	pr_devel("<==%s() = 0 [%x]\n", __func__,
+ 		 key_serial(key_ref_to_ptr(key)));
+ 	return key_ref_to_ptr(key);
+ }
+ 
++>>>>>>> 5ce43ad28262 (PKCS#7: Use x509_request_asymmetric_key())
  /*
   * Set up the signature parameters in an X.509 certificate.  This involves
   * digesting the signed data and extracting the signature.
* Unmerged path crypto/asymmetric_keys/pkcs7_trust.c
* Unmerged path crypto/asymmetric_keys/pkcs7_trust.c
* Unmerged path crypto/asymmetric_keys/x509_public_key.c
diff --git a/include/crypto/public_key.h b/include/crypto/public_key.h
index fc09732613ad..0d164c6af539 100644
--- a/include/crypto/public_key.h
+++ b/include/crypto/public_key.h
@@ -98,4 +98,8 @@ struct key;
 extern int verify_signature(const struct key *key,
 			    const struct public_key_signature *sig);
 
+extern struct key *x509_request_asymmetric_key(struct key *keyring,
+					       const char *issuer,
+					       const char *key_id);
+
 #endif /* _LINUX_PUBLIC_KEY_H */
