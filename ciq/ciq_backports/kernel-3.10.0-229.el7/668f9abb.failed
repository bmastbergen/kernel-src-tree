mm: close PageTail race

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [mm] close PageTail race (Andrea Arcangeli) [1135506]
Rebuild_FUZZ: 90.48%
commit-author David Rientjes <rientjes@google.com>
commit 668f9abbd4334e6c29fa8acd71635c4f9101caa7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/668f9abb.failed

Commit bf6bddf1924e ("mm: introduce compaction and migration for
ballooned pages") introduces page_count(page) into memory compaction
which dereferences page->first_page if PageTail(page).

This results in a very rare NULL pointer dereference on the
aforementioned page_count(page).  Indeed, anything that does
compound_head(), including page_count() is susceptible to racing with
prep_compound_page() and seeing a NULL or dangling page->first_page
pointer.

This patch uses Andrea's implementation of compound_trans_head() that
deals with such a race and makes it the default compound_head()
implementation.  This includes a read memory barrier that ensures that
if PageTail(head) is true that we return a head page that is neither
NULL nor dangling.  The patch then adds a store memory barrier to
prep_compound_page() to ensure page->first_page is set.

This is the safest way to ensure we see the head page that we are
expecting, PageTail(page) is already in the unlikely() path and the
memory barriers are unfortunately required.

Hugetlbfs is the exception, we don't enforce a store memory barrier
during init since no race is possible.

	Signed-off-by: David Rientjes <rientjes@google.com>
	Cc: Holger Kiehl <Holger.Kiehl@dwd.de>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: Rafael Aquini <aquini@redhat.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Michal Hocko <mhocko@suse.cz>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Andrea Arcangeli <aarcange@redhat.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: "Kirill A. Shutemov" <kirill.shutemov@linux.intel.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 668f9abbd4334e6c29fa8acd71635c4f9101caa7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/aoe/aoecmd.c
#	include/linux/huge_mm.h
diff --cc drivers/block/aoe/aoecmd.c
index 77d8fdf34ca2,422b7d84f686..000000000000
--- a/drivers/block/aoe/aoecmd.c
+++ b/drivers/block/aoe/aoecmd.c
@@@ -896,7 -874,7 +896,11 @@@ bio_pageinc(struct bio *bio
  		/* Non-zero page count for non-head members of
  		 * compound pages is no longer allowed by the kernel.
  		 */
++<<<<<<< HEAD
 +		page = compound_trans_head(bv->bv_page);
++=======
+ 		page = compound_head(bv.bv_page);
++>>>>>>> 668f9abbd433 (mm: close PageTail race)
  		atomic_inc(&page->_count);
  	}
  }
@@@ -904,12 -882,12 +908,17 @@@
  static void
  bio_pagedec(struct bio *bio)
  {
 +	struct bio_vec *bv;
  	struct page *page;
 -	struct bio_vec bv;
 -	struct bvec_iter iter;
 +	int i;
  
++<<<<<<< HEAD
 +	bio_for_each_segment(bv, bio, i) {
 +		page = compound_trans_head(bv->bv_page);
++=======
+ 	bio_for_each_segment(bv, bio, iter) {
+ 		page = compound_head(bv.bv_page);
++>>>>>>> 668f9abbd433 (mm: close PageTail race)
  		atomic_dec(&page->_count);
  	}
  }
diff --cc include/linux/huge_mm.h
index d57875ed9c82,b826239bdce0..000000000000
--- a/include/linux/huge_mm.h
+++ b/include/linux/huge_mm.h
@@@ -157,23 -157,6 +157,26 @@@ static inline int hpage_nr_pages(struc
  		return HPAGE_PMD_NR;
  	return 1;
  }
++<<<<<<< HEAD
 +static inline struct page *compound_trans_head(struct page *page)
 +{
 +	if (PageTail(page)) {
 +		struct page *head;
 +		head = page->first_page;
 +		smp_rmb();
 +		/*
 +		 * head may be a dangling pointer.
 +		 * __split_huge_page_refcount clears PageTail before
 +		 * overwriting first_page, so if PageTail is still
 +		 * there it means the head pointer isn't dangling.
 +		 */
 +		if (PageTail(page))
 +			return head;
 +	}
 +	return page;
 +}
++=======
++>>>>>>> 668f9abbd433 (mm: close PageTail race)
  
  extern int do_huge_pmd_numa_page(struct mm_struct *mm, struct vm_area_struct *vma,
  				unsigned long addr, pmd_t pmd, pmd_t *pmdp);
* Unmerged path drivers/block/aoe/aoecmd.c
diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c
index 4fb7a8f83c8a..54af4e933695 100644
--- a/drivers/vfio/vfio_iommu_type1.c
+++ b/drivers/vfio/vfio_iommu_type1.c
@@ -186,12 +186,12 @@ static bool is_invalid_reserved_pfn(unsigned long pfn)
 	if (pfn_valid(pfn)) {
 		bool reserved;
 		struct page *tail = pfn_to_page(pfn);
-		struct page *head = compound_trans_head(tail);
+		struct page *head = compound_head(tail);
 		reserved = !!(PageReserved(head));
 		if (head != tail) {
 			/*
 			 * "head" is not a dangling pointer
-			 * (compound_trans_head takes care of that)
+			 * (compound_head takes care of that)
 			 * but the hugepage may have been split
 			 * from under us (and we may not hold a
 			 * reference count on the head page so it can
diff --git a/fs/proc/page.c b/fs/proc/page.c
index cab84b6272ed..54e111e436a5 100644
--- a/fs/proc/page.c
+++ b/fs/proc/page.c
@@ -121,9 +121,8 @@ u64 stable_page_flags(struct page *page)
 	 * just checks PG_head/PG_tail, so we need to check PageLRU/PageAnon
 	 * to make sure a given page is a thp, not a non-huge compound page.
 	 */
-	else if (PageTransCompound(page) &&
-		 (PageLRU(compound_trans_head(page)) ||
-		  PageAnon(compound_trans_head(page))))
+	else if (PageTransCompound(page) && (PageLRU(compound_head(page)) ||
+					     PageAnon(compound_head(page))))
 		u |= 1 << KPF_THP;
 
 	/*
* Unmerged path include/linux/huge_mm.h
diff --git a/include/linux/mm.h b/include/linux/mm.h
index b3f1a12ea128..3428672ec760 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -373,8 +373,18 @@ static inline void compound_unlock_irqrestore(struct page *page,
 
 static inline struct page *compound_head(struct page *page)
 {
-	if (unlikely(PageTail(page)))
-		return page->first_page;
+	if (unlikely(PageTail(page))) {
+		struct page *head = page->first_page;
+
+		/*
+		 * page->first_page may be a dangling pointer to an old
+		 * compound page, so recheck that it is still a tail
+		 * page before returning.
+		 */
+		smp_rmb();
+		if (likely(PageTail(page)))
+			return head;
+	}
 	return page;
 }
 
diff --git a/mm/ksm.c b/mm/ksm.c
index b6afe0c440d8..784d1e4bc385 100644
--- a/mm/ksm.c
+++ b/mm/ksm.c
@@ -444,7 +444,7 @@ static void break_cow(struct rmap_item *rmap_item)
 static struct page *page_trans_compound_anon(struct page *page)
 {
 	if (PageTransCompound(page)) {
-		struct page *head = compound_trans_head(page);
+		struct page *head = compound_head(page);
 		/*
 		 * head may actually be splitted and freed from under
 		 * us but it's ok here.
diff --git a/mm/memory-failure.c b/mm/memory-failure.c
index 9af7010e56d8..b25b1bd055f7 100644
--- a/mm/memory-failure.c
+++ b/mm/memory-failure.c
@@ -1580,7 +1580,7 @@ int soft_offline_page(struct page *page, int flags)
 {
 	int ret;
 	unsigned long pfn = page_to_pfn(page);
-	struct page *hpage = compound_trans_head(page);
+	struct page *hpage = compound_head(page);
 
 	if (PageHWPoison(page)) {
 		pr_info("soft offline: %#lx page already poisoned\n", pfn);
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index c2c1427d74ec..f77d2fe00070 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -361,9 +361,11 @@ void prep_compound_page(struct page *page, unsigned long order)
 	__SetPageHead(page);
 	for (i = 1; i < nr_pages; i++) {
 		struct page *p = page + i;
-		__SetPageTail(p);
 		set_page_count(p, 0);
 		p->first_page = page;
+		/* Make sure p->first_page is always valid for PageTail() */
+		smp_wmb();
+		__SetPageTail(p);
 	}
 }
 
diff --git a/mm/swap.c b/mm/swap.c
index e08e15146ebc..384a4e40e161 100644
--- a/mm/swap.c
+++ b/mm/swap.c
@@ -98,7 +98,7 @@ static void put_compound_page(struct page *page)
 	}
 
 	/* __split_huge_page_refcount can run under us */
-	page_head = compound_trans_head(page);
+	page_head = compound_head(page);
 
 	/*
 	 * THP can not break up slab pages so avoid taking
@@ -253,7 +253,7 @@ bool __get_page_tail(struct page *page)
 	 */
 	unsigned long flags;
 	bool got;
-	struct page *page_head = compound_trans_head(page);
+	struct page *page_head = compound_head(page);
 
 	/* Ref to put_compound_page() comment. */
 	if (!__compound_tail_refcounted(page_head)) {
