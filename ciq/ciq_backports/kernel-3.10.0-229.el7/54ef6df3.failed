rcu: Provide counterpart to rcu_dereference() for non-RCU situations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Paul E. McKenney <paulmck@linux.vnet.ibm.com>
commit 54ef6df3f3f1353d99c80c437259d317b2cd1cbd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/54ef6df3.failed

Although rcu_dereference() and friends can be used in situations where
object lifetimes are being managed by something other than RCU, the
resulting sparse and lockdep-RCU noise can be annoying.  This commit
therefore supplies a lockless_dereference(), which provides the
protection for dereferences without the RCU-related debugging noise.

	Reported-by: Al Viro <viro@ZenIV.linux.org.uk>
	Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 54ef6df3f3f1353d99c80c437259d317b2cd1cbd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/rcupdate.h
diff --cc include/linux/rcupdate.h
index ddcc7826d907,53ff1a752d7e..000000000000
--- a/include/linux/rcupdate.h
+++ b/include/linux/rcupdate.h
@@@ -516,49 -575,94 +516,105 @@@ static inline void rcu_preempt_sleep_ch
  #endif /* #else #ifdef __CHECKER__ */
  
  #define __rcu_access_pointer(p, space) \
 -({ \
 -	typeof(*p) *_________p1 = (typeof(*p) *__force)ACCESS_ONCE(p); \
 -	rcu_dereference_sparse(p, space); \
 -	((typeof(*p) __force __kernel *)(_________p1)); \
 -})
 +	({ \
 +		typeof(*p) *_________p1 = (typeof(*p)*__force )ACCESS_ONCE(p); \
 +		rcu_dereference_sparse(p, space); \
 +		((typeof(*p) __force __kernel *)(_________p1)); \
 +	})
  #define __rcu_dereference_check(p, c, space) \
 -({ \
 -	typeof(*p) *_________p1 = (typeof(*p) *__force)ACCESS_ONCE(p); \
 -	rcu_lockdep_assert(c, "suspicious rcu_dereference_check() usage"); \
 -	rcu_dereference_sparse(p, space); \
 -	smp_read_barrier_depends(); /* Dependency order vs. p above. */ \
 -	((typeof(*p) __force __kernel *)(_________p1)); \
 -})
 +	({ \
 +		typeof(*p) *_________p1 = (typeof(*p)*__force )ACCESS_ONCE(p); \
 +		rcu_lockdep_assert(c, "suspicious rcu_dereference_check()" \
 +				      " usage"); \
 +		rcu_dereference_sparse(p, space); \
 +		smp_read_barrier_depends(); \
 +		((typeof(*p) __force __kernel *)(_________p1)); \
 +	})
  #define __rcu_dereference_protected(p, c, space) \
 -({ \
 -	rcu_lockdep_assert(c, "suspicious rcu_dereference_protected() usage"); \
 -	rcu_dereference_sparse(p, space); \
 -	((typeof(*p) __force __kernel *)(p)); \
 -})
 +	({ \
 +		rcu_lockdep_assert(c, "suspicious rcu_dereference_protected()" \
 +				      " usage"); \
 +		rcu_dereference_sparse(p, space); \
 +		((typeof(*p) __force __kernel *)(p)); \
 +	})
  
  #define __rcu_access_index(p, space) \
 -({ \
 -	typeof(p) _________p1 = ACCESS_ONCE(p); \
 -	rcu_dereference_sparse(p, space); \
 -	(_________p1); \
 -})
 +	({ \
 +		typeof(p) _________p1 = ACCESS_ONCE(p); \
 +		rcu_dereference_sparse(p, space); \
 +		(_________p1); \
 +	})
  #define __rcu_dereference_index_check(p, c) \
 -({ \
 -	typeof(p) _________p1 = ACCESS_ONCE(p); \
 -	rcu_lockdep_assert(c, \
 -			   "suspicious rcu_dereference_index_check() usage"); \
 -	smp_read_barrier_depends(); /* Dependency order vs. p above. */ \
 -	(_________p1); \
 -})
 +	({ \
 +		typeof(p) _________p1 = ACCESS_ONCE(p); \
 +		rcu_lockdep_assert(c, \
 +				   "suspicious rcu_dereference_index_check()" \
 +				   " usage"); \
 +		smp_read_barrier_depends(); \
 +		(_________p1); \
 +	})
 +#define __rcu_assign_pointer(p, v, space) \
 +	do { \
 +		smp_wmb(); \
 +		(p) = (typeof(*v) __force space *)(v); \
 +	} while (0)
  
++<<<<<<< HEAD
++=======
+ /**
+  * RCU_INITIALIZER() - statically initialize an RCU-protected global variable
+  * @v: The value to statically initialize with.
+  */
+ #define RCU_INITIALIZER(v) (typeof(*(v)) __force __rcu *)(v)
+ 
+ /**
+  * lockless_dereference() - safely load a pointer for later dereference
+  * @p: The pointer to load
+  *
+  * Similar to rcu_dereference(), but for situations where the pointed-to
+  * object's lifetime is managed by something other than RCU.  That
+  * "something other" might be reference counting or simple immortality.
+  */
+ #define lockless_dereference(p) \
+ ({ \
+ 	typeof(p) _________p1 = ACCESS_ONCE(p); \
+ 	smp_read_barrier_depends(); /* Dependency order vs. p above. */ \
+ 	(_________p1); \
+ })
+ 
+ /**
+  * rcu_assign_pointer() - assign to RCU-protected pointer
+  * @p: pointer to assign to
+  * @v: value to assign (publish)
+  *
+  * Assigns the specified value to the specified RCU-protected
+  * pointer, ensuring that any concurrent RCU readers will see
+  * any prior initialization.
+  *
+  * Inserts memory barriers on architectures that require them
+  * (which is most of them), and also prevents the compiler from
+  * reordering the code that initializes the structure after the pointer
+  * assignment.  More importantly, this call documents which pointers
+  * will be dereferenced by RCU read-side code.
+  *
+  * In some special cases, you may use RCU_INIT_POINTER() instead
+  * of rcu_assign_pointer().  RCU_INIT_POINTER() is a bit faster due
+  * to the fact that it does not constrain either the CPU or the compiler.
+  * That said, using RCU_INIT_POINTER() when you should have used
+  * rcu_assign_pointer() is a very bad thing that results in
+  * impossible-to-diagnose memory corruption.  So please be careful.
+  * See the RCU_INIT_POINTER() comment header for details.
+  *
+  * Note that rcu_assign_pointer() evaluates each of its arguments only
+  * once, appearances notwithstanding.  One of the "extra" evaluations
+  * is in typeof() and the other visible only to sparse (__CHECKER__),
+  * neither of which actually execute the argument.  As with most cpp
+  * macros, this execute-arguments-only-once property is important, so
+  * please be careful when making changes to rcu_assign_pointer() and the
+  * other macros that it invokes.
+  */
+ #define rcu_assign_pointer(p, v) smp_store_release(&p, RCU_INITIALIZER(v))
++>>>>>>> 54ef6df3f3f1 (rcu: Provide counterpart to rcu_dereference() for non-RCU situations)
  
  /**
   * rcu_access_pointer() - fetch RCU pointer with no dereferencing
* Unmerged path include/linux/rcupdate.h
