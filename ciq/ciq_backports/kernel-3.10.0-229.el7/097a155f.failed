usb: synchronize port poweroff and khubd

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [usb] synchronize port poweroff and khubd (Don Zickus) [1110939]
Rebuild_FUZZ: 93.33%
commit-author Dan Williams <dan.j.williams@intel.com>
commit 097a155f05e88dc71184ceb93ad1aab1a13d1e41
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/097a155f.failed

If a port is powered-off, or in the process of being powered-off, prevent
khubd from operating on it.  Otherwise, the following sequence of events
leading to an unintended disconnect may occur:

Events:
(0) <set pm_qos_no_poweroff to '0' for port1>
(1) hub 2-2:1.0: hub_resume
(2) hub 2-2:1.0: port 1: status 0301 change 0000
(3) hub 2-2:1.0: state 7 ports 4 chg 0002 evt 0000
(4) hub 2-2:1.0: port 1, power off status 0000, change 0000, 12 Mb/s
(5) usb 2-2.1: USB disconnect, device number 5

Description:
(1) hub is resumed before sending a ClearPortFeature request
(2) hub_activate() notices the port is connected and sets
    hub->change_bits for the port
(3) hub_events() starts, but at the same time the port suspends
(4) hub_connect_change() sees the disabled port and triggers disconnect

	Acked-by: Alan Stern <stern@rowland.harvard.edu>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 097a155f05e88dc71184ceb93ad1aab1a13d1e41)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/core/hub.c
diff --cc drivers/usb/core/hub.c
index 2f5db8b4a93a,988f227e796f..000000000000
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@@ -4711,6 -4712,125 +4711,128 @@@ static int hub_handle_remote_wakeup(str
  	return connect_change;
  }
  
++<<<<<<< HEAD
++=======
+ static void port_event(struct usb_hub *hub, int port1)
+ {
+ 	int connect_change, reset_device = 0;
+ 	struct usb_port *port_dev = hub->ports[port1 - 1];
+ 	struct usb_device *udev = port_dev->child;
+ 	struct usb_device *hdev = hub->hdev;
+ 	u16 portstatus, portchange;
+ 
+ 	connect_change = test_bit(port1, hub->change_bits);
+ 	clear_bit(port1, hub->event_bits);
+ 	clear_bit(port1, hub->wakeup_bits);
+ 
+ 	if (hub_port_status(hub, port1, &portstatus, &portchange) < 0)
+ 		return;
+ 
+ 	if (portchange & USB_PORT_STAT_C_CONNECTION) {
+ 		usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);
+ 		connect_change = 1;
+ 	}
+ 
+ 	if (portchange & USB_PORT_STAT_C_ENABLE) {
+ 		if (!connect_change)
+ 			dev_dbg(&port_dev->dev, "enable change, status %08x\n",
+ 					portstatus);
+ 		usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);
+ 
+ 		/*
+ 		 * EM interference sometimes causes badly shielded USB devices
+ 		 * to be shutdown by the hub, this hack enables them again.
+ 		 * Works at least with mouse driver.
+ 		 */
+ 		if (!(portstatus & USB_PORT_STAT_ENABLE)
+ 		    && !connect_change && udev) {
+ 			dev_err(&port_dev->dev, "disabled by hub (EMI?), re-enabling...\n");
+ 			connect_change = 1;
+ 		}
+ 	}
+ 
+ 	if (portchange & USB_PORT_STAT_C_OVERCURRENT) {
+ 		u16 status = 0, unused;
+ 
+ 		dev_dbg(&port_dev->dev, "over-current change\n");
+ 		usb_clear_port_feature(hdev, port1,
+ 				USB_PORT_FEAT_C_OVER_CURRENT);
+ 		msleep(100);	/* Cool down */
+ 		hub_power_on(hub, true);
+ 		hub_port_status(hub, port1, &status, &unused);
+ 		if (status & USB_PORT_STAT_OVERCURRENT)
+ 			dev_err(&port_dev->dev, "over-current condition\n");
+ 	}
+ 
+ 	if (portchange & USB_PORT_STAT_C_RESET) {
+ 		dev_dbg(&port_dev->dev, "reset change\n");
+ 		usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_RESET);
+ 	}
+ 	if ((portchange & USB_PORT_STAT_C_BH_RESET)
+ 	    && hub_is_superspeed(hdev)) {
+ 		dev_dbg(&port_dev->dev, "warm reset change\n");
+ 		usb_clear_port_feature(hdev, port1,
+ 				USB_PORT_FEAT_C_BH_PORT_RESET);
+ 	}
+ 	if (portchange & USB_PORT_STAT_C_LINK_STATE) {
+ 		dev_dbg(&port_dev->dev, "link state change\n");
+ 		usb_clear_port_feature(hdev, port1,
+ 				USB_PORT_FEAT_C_PORT_LINK_STATE);
+ 	}
+ 	if (portchange & USB_PORT_STAT_C_CONFIG_ERROR) {
+ 		dev_warn(&port_dev->dev, "config error\n");
+ 		usb_clear_port_feature(hdev, port1,
+ 				USB_PORT_FEAT_C_PORT_CONFIG_ERROR);
+ 	}
+ 
+ 	/* skip port actions that require the port to be powered on */
+ 	if (!pm_runtime_active(&port_dev->dev))
+ 		return;
+ 
+ 	if (hub_handle_remote_wakeup(hub, port1, portstatus, portchange))
+ 		connect_change = 1;
+ 
+ 	/*
+ 	 * Warm reset a USB3 protocol port if it's in
+ 	 * SS.Inactive state.
+ 	 */
+ 	if (hub_port_warm_reset_required(hub, portstatus)) {
+ 		dev_dbg(&port_dev->dev, "do warm reset\n");
+ 		if (!udev || !(portstatus & USB_PORT_STAT_CONNECTION)
+ 				|| udev->state == USB_STATE_NOTATTACHED) {
+ 			if (hub_port_reset(hub, port1, NULL,
+ 					HUB_BH_RESET_TIME, true) < 0)
+ 				hub_port_disable(hub, port1, 1);
+ 		} else
+ 			reset_device = 1;
+ 	}
+ 
+ 	/*
+ 	 * On disconnect USB3 protocol ports transit from U0 to
+ 	 * SS.Inactive to Rx.Detect. If this happens a warm-
+ 	 * reset is not needed, but a (re)connect may happen
+ 	 * before khubd runs and sees the disconnect, and the
+ 	 * device may be an unknown state.
+ 	 *
+ 	 * If the port went through SS.Inactive without khubd
+ 	 * seeing it the C_LINK_STATE change flag will be set,
+ 	 * and we reset the dev to put it in a known state.
+ 	 */
+ 	if (reset_device || (udev && hub_is_superspeed(hub->hdev)
+ 				&& (portchange & USB_PORT_STAT_C_LINK_STATE)
+ 				&& (portstatus & USB_PORT_STAT_CONNECTION))) {
+ 		usb_lock_device(udev);
+ 		usb_reset_device(udev);
+ 		usb_unlock_device(udev);
+ 		connect_change = 0;
+ 	}
+ 
+ 	if (connect_change)
+ 		hub_port_connect_change(hub, port1, portstatus, portchange);
+ }
+ 
+ 
++>>>>>>> 097a155f05e8 (usb: synchronize port poweroff and khubd)
  static void hub_events(void)
  {
  	struct list_head *tmp;
@@@ -4797,146 -4914,27 +4919,170 @@@
  
  		/* deal with port status changes */
  		for (i = 1; i <= hdev->maxchild; i++) {
++<<<<<<< HEAD
 +			struct usb_device *udev = hub->ports[i - 1]->child;
 +
 +			if (test_bit(i, hub->busy_bits))
 +				continue;
 +			connect_change = test_bit(i, hub->change_bits);
 +			wakeup_change = test_and_clear_bit(i, hub->wakeup_bits);
 +			if (!test_and_clear_bit(i, hub->event_bits) &&
 +					!connect_change && !wakeup_change)
 +				continue;
 +
 +			ret = hub_port_status(hub, i,
 +					&portstatus, &portchange);
 +			if (ret < 0)
 +				continue;
 +
 +			if (portchange & USB_PORT_STAT_C_CONNECTION) {
 +				usb_clear_port_feature(hdev, i,
 +					USB_PORT_FEAT_C_CONNECTION);
 +				connect_change = 1;
 +			}
 +
 +			if (portchange & USB_PORT_STAT_C_ENABLE) {
 +				if (!connect_change)
 +					dev_dbg (hub_dev,
 +						"port %d enable change, "
 +						"status %08x\n",
 +						i, portstatus);
 +				usb_clear_port_feature(hdev, i,
 +					USB_PORT_FEAT_C_ENABLE);
 +
 +				/*
 +				 * EM interference sometimes causes badly
 +				 * shielded USB devices to be shutdown by
 +				 * the hub, this hack enables them again.
 +				 * Works at least with mouse driver. 
 +				 */
 +				if (!(portstatus & USB_PORT_STAT_ENABLE)
 +				    && !connect_change
 +				    && hub->ports[i - 1]->child) {
 +					dev_err (hub_dev,
 +					    "port %i "
 +					    "disabled by hub (EMI?), "
 +					    "re-enabling...\n",
 +						i);
 +					connect_change = 1;
 +				}
 +			}
 +
 +			if (hub_handle_remote_wakeup(hub, i,
 +						portstatus, portchange))
 +				connect_change = 1;
 +
 +			if (portchange & USB_PORT_STAT_C_OVERCURRENT) {
 +				u16 status = 0;
 +				u16 unused;
 +
 +				dev_dbg(hub_dev, "over-current change on port "
 +					"%d\n", i);
 +				usb_clear_port_feature(hdev, i,
 +					USB_PORT_FEAT_C_OVER_CURRENT);
 +				msleep(100);	/* Cool down */
 +				hub_power_on(hub, true);
 +				hub_port_status(hub, i, &status, &unused);
 +				if (status & USB_PORT_STAT_OVERCURRENT)
 +					dev_err(hub_dev, "over-current "
 +						"condition on port %d\n", i);
 +			}
 +
 +			if (portchange & USB_PORT_STAT_C_RESET) {
 +				dev_dbg (hub_dev,
 +					"reset change on port %d\n",
 +					i);
 +				usb_clear_port_feature(hdev, i,
 +					USB_PORT_FEAT_C_RESET);
 +			}
 +			if ((portchange & USB_PORT_STAT_C_BH_RESET) &&
 +					hub_is_superspeed(hub->hdev)) {
 +				dev_dbg(hub_dev,
 +					"warm reset change on port %d\n",
 +					i);
 +				usb_clear_port_feature(hdev, i,
 +					USB_PORT_FEAT_C_BH_PORT_RESET);
 +			}
 +			if (portchange & USB_PORT_STAT_C_LINK_STATE) {
 +				usb_clear_port_feature(hub->hdev, i,
 +						USB_PORT_FEAT_C_PORT_LINK_STATE);
 +			}
 +			if (portchange & USB_PORT_STAT_C_CONFIG_ERROR) {
 +				dev_warn(hub_dev,
 +					"config error on port %d\n",
 +					i);
 +				usb_clear_port_feature(hub->hdev, i,
 +						USB_PORT_FEAT_C_PORT_CONFIG_ERROR);
 +			}
 +
 +			/* Warm reset a USB3 protocol port if it's in
 +			 * SS.Inactive state.
 +			 */
 +			if (hub_port_warm_reset_required(hub, portstatus)) {
 +				int status;
 +
 +				dev_dbg(hub_dev, "warm reset port %d\n", i);
 +				if (!udev ||
 +				    !(portstatus & USB_PORT_STAT_CONNECTION) ||
 +				    udev->state == USB_STATE_NOTATTACHED) {
 +					status = hub_port_reset(hub, i,
 +							NULL, HUB_BH_RESET_TIME,
 +							true);
 +					if (status < 0)
 +						hub_port_disable(hub, i, 1);
 +				} else {
 +					usb_lock_device(udev);
 +					status = usb_reset_device(udev);
 +					usb_unlock_device(udev);
 +					connect_change = 0;
 +				}
 +			/*
 +			 * On disconnect USB3 protocol ports transit from U0 to
 +			 * SS.Inactive to Rx.Detect. If this happens a warm-
 +			 * reset is not needed, but a (re)connect may happen
 +			 * before khubd runs and sees the disconnect, and the
 +			 * device may be an unknown state.
 +			 *
 +			 * If the port went through SS.Inactive without khubd
 +			 * seeing it the C_LINK_STATE change flag will be set,
 +			 * and we reset the dev to put it in a known state.
 +			 */
 +			} else if (udev && hub_is_superspeed(hub->hdev) &&
 +				   (portchange & USB_PORT_STAT_C_LINK_STATE) &&
 +				   (portstatus & USB_PORT_STAT_CONNECTION)) {
 +				usb_lock_device(udev);
 +				usb_reset_device(udev);
 +				usb_unlock_device(udev);
 +				connect_change = 0;
 +			}
 +
 +			if (connect_change)
 +				hub_port_connect_change(hub, i,
 +						portstatus, portchange);
 +		} /* end for i */
++=======
+ 			struct usb_port *port_dev = hub->ports[i - 1];
+ 
+ 			if (!test_bit(i, hub->busy_bits)
+ 					&& (test_bit(i, hub->event_bits)
+ 						|| test_bit(i, hub->change_bits)
+ 						|| test_bit(i, hub->wakeup_bits))) {
+ 				/*
+ 				 * The get_noresume and barrier ensure that if
+ 				 * the port was in the process of resuming, we
+ 				 * flush that work and keep the port active for
+ 				 * the duration of the port_event().  However,
+ 				 * if the port is runtime pm suspended
+ 				 * (powered-off), we leave it in that state, run
+ 				 * an abbreviated port_event(), and move on.
+ 				 */
+ 				pm_runtime_get_noresume(&port_dev->dev);
+ 				pm_runtime_barrier(&port_dev->dev);
+ 				port_event(hub, i);
+ 				pm_runtime_put_sync(&port_dev->dev);
+ 			}
+ 		}
++>>>>>>> 097a155f05e8 (usb: synchronize port poweroff and khubd)
  
  		/* deal with hub status changes */
  		if (test_and_clear_bit(0, hub->event_bits) == 0)
* Unmerged path drivers/usb/core/hub.c
