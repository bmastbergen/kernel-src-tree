ACPI / hotplug / PCI: Rework acpiphp_no_hotplug()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Rework acpiphp_no_hotplug() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 89.89%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit b2118d6a4073e394312072b6666cb576e18653b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/b2118d6a.failed

If a struct acpi_device pointer is passed to acpiphp_no_hotplug()
instead of an ACPI handle, the function won't need to call
acpi_bus_get_device(), which may be costly, any more.  Then,
trim_stale_devices() can call acpiphp_no_hotplug() passing
the struct acpi_device object it already has directly to that
function.

Make those changes and update slot_no_hotplug() accordingly.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit b2118d6a4073e394312072b6666cb576e18653b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,a0d6c83ac27b..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -788,10 -636,26 +788,31 @@@ static int disable_device(struct acpiph
  	}
  
  	slot->flags &= (~SLOT_ENABLED);
 +
 +	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static bool acpiphp_no_hotplug(struct acpi_device *adev)
+ {
+ 	return adev && adev->flags.no_hotplug;
+ }
+ 
+ static bool slot_no_hotplug(struct acpiphp_slot *slot)
+ {
+ 	struct acpiphp_func *func;
+ 
+ 	list_for_each_entry(func, &slot->funcs, sibling) {
+ 		struct acpi_device *adev = NULL;
+ 
+ 		acpi_bus_get_device(func_to_handle(func), &adev);
+ 		if (acpiphp_no_hotplug(adev))
+ 			return true;
+ 	}
+ 	return false;
+ }
++>>>>>>> b2118d6a4073 (ACPI / hotplug / PCI: Rework acpiphp_no_hotplug())
  
  /**
   * get_slot_status - get ACPI slot status
@@@ -833,34 -700,43 +854,64 @@@ static unsigned int get_slot_status(str
  }
  
  /**
 - * trim_stale_devices - remove PCI devices that are not responding.
 - * @dev: PCI device to start walking the hierarchy from.
 + * acpiphp_eject_slot - physically eject the slot
 + * @slot: ACPI PHP slot
   */
 -static void trim_stale_devices(struct pci_dev *dev)
 +int acpiphp_eject_slot(struct acpiphp_slot *slot)
  {
 -	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
 -	struct pci_bus *bus = dev->subordinate;
 -	bool alive = false;
 +	acpi_status status;
 +	struct acpiphp_func *func;
 +	struct acpi_object_list arg_list;
 +	union acpi_object arg;
  
++<<<<<<< HEAD
 +	list_for_each_entry(func, &slot->funcs, sibling) {
 +		/* We don't want to call _EJ0 on non-existing functions. */
 +		if ((func->flags & FUNC_HAS_EJ0)) {
 +			/* _EJ0 method take one argument */
 +			arg_list.count = 1;
 +			arg_list.pointer = &arg;
 +			arg.type = ACPI_TYPE_INTEGER;
 +			arg.integer.value = 1;
 +
 +			status = acpi_evaluate_object(func->handle, "_EJ0", &arg_list, NULL);
 +			if (ACPI_FAILURE(status)) {
 +				pr_warn("%s: _EJ0 failed\n", __func__);
 +				return -1;
 +			} else
 +				break;
 +		}
++=======
+ 	if (adev) {
+ 		acpi_status status;
+ 		unsigned long long sta;
+ 
+ 		status = acpi_evaluate_integer(adev->handle, "_STA", NULL, &sta);
+ 		alive = (ACPI_SUCCESS(status) && sta == ACPI_STA_ALL)
+ 			|| acpiphp_no_hotplug(adev);
+ 	}
+ 	if (!alive) {
+ 		u32 v;
+ 
+ 		/* Check if the device responds. */
+ 		alive = pci_bus_read_dev_vendor_id(dev->bus, dev->devfn, &v, 0);
+ 	}
+ 	if (!alive) {
+ 		pci_stop_and_remove_bus_device(dev);
+ 		if (adev)
+ 			acpi_bus_trim(adev);
+ 	} else if (bus) {
+ 		struct pci_dev *child, *tmp;
+ 
+ 		/* The device is a bridge. so check the bus below it. */
+ 		pm_runtime_get_sync(&dev->dev);
+ 		list_for_each_entry_safe_reverse(child, tmp, &bus->devices, bus_list)
+ 			trim_stale_devices(child);
+ 
+ 		pm_runtime_put(&dev->dev);
++>>>>>>> b2118d6a4073 (ACPI / hotplug / PCI: Rework acpiphp_no_hotplug())
  	}
 +	return 0;
  }
  
  /**
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
