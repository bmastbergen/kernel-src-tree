ACPI / hotplug / PCI: Do not pass ACPI handle to hotplug_event()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Do not pass ACPI handle to hotplug_event() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 92.44%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit d3a1ebb063cc45d5f4a5655534b87c3547fd9bbf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d3a1ebb0.failed

Since hotplug_event() can get the ACPI handle needed for debug
printouts from its context argument, there's no need to pass the
handle to it.  Moreover, the second argument's type may be changed
to (struct acpiphp_context *), because that's what is always passed
to hotplug_event() as the second argument anyway.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit d3a1ebb063cc45d5f4a5655534b87c3547fd9bbf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,5da32eff3bc3..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -57,26 -58,80 +57,30 @@@
  
  static LIST_HEAD(bridge_list);
  static DEFINE_MUTEX(bridge_mutex);
 -static DEFINE_MUTEX(acpiphp_context_lock);
  
 -static void handle_hotplug_event(acpi_handle handle, u32 type, void *data);
 +static void handle_hotplug_event_bridge (acpi_handle, u32, void *);
  static void acpiphp_sanitize_bus(struct pci_bus *bus);
  static void acpiphp_set_hpp_values(struct pci_bus *bus);
++<<<<<<< HEAD
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context);
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type, void *context);
++=======
+ static void hotplug_event(u32 type, struct acpiphp_context *context);
++>>>>>>> d3a1ebb063cc (ACPI / hotplug / PCI: Do not pass ACPI handle to hotplug_event())
  static void free_bridge(struct kref *kref);
  
 -static void acpiphp_context_handler(acpi_handle handle, void *context)
 +/* callback routine to check for the existence of a pci dock device */
 +static acpi_status
 +is_pci_dock_device(acpi_handle handle, u32 lvl, void *context, void **rv)
  {
 -	/* Intentionally empty. */
 -}
 -
 -/**
 - * acpiphp_init_context - Create hotplug context and grab a reference to it.
 - * @adev: ACPI device object to create the context for.
 - *
 - * Call under acpiphp_context_lock.
 - */
 -static struct acpiphp_context *acpiphp_init_context(struct acpi_device *adev)
 -{
 -	struct acpiphp_context *context;
 -	acpi_status status;
 -
 -	context = kzalloc(sizeof(*context), GFP_KERNEL);
 -	if (!context)
 -		return NULL;
 -
 -	context->adev = adev;
 -	context->refcount = 1;
 -	status = acpi_attach_data(adev->handle, acpiphp_context_handler, context);
 -	if (ACPI_FAILURE(status)) {
 -		kfree(context);
 -		return NULL;
 -	}
 -	return context;
 -}
 +	int *count = (int *)context;
  
 -/**
 - * acpiphp_get_context - Get hotplug context and grab a reference to it.
 - * @handle: ACPI object handle to get the context for.
 - *
 - * Call under acpiphp_context_lock.
 - */
 -static struct acpiphp_context *acpiphp_get_context(acpi_handle handle)
 -{
 -	struct acpiphp_context *context = NULL;
 -	acpi_status status;
 -	void *data;
 -
 -	status = acpi_get_data(handle, acpiphp_context_handler, &data);
 -	if (ACPI_SUCCESS(status)) {
 -		context = data;
 -		context->refcount++;
 +	if (is_dock_device(handle)) {
 +		(*count)++;
 +		return AE_CTRL_TERMINATE;
 +	} else {
 +		return AE_OK;
  	}
 -	return context;
 -}
 -
 -/**
 - * acpiphp_put_context - Drop a reference to ACPI hotplug context.
 - * @context: ACPI hotplug context to drop a reference to.
 - *
 - * The context object is removed if there are no more references to it.
 - *
 - * Call under acpiphp_context_lock.
 - */
 -static void acpiphp_put_context(struct acpiphp_context *context)
 -{
 -	if (--context->refcount)
 -		return;
 -
 -	WARN_ON(context->bridge);
 -	acpi_detach_data(context->adev->handle, acpiphp_context_handler);
 -	kfree(context);
  }
  
  static inline void get_bridge(struct acpiphp_bridge *bridge)
@@@ -143,12 -208,31 +147,34 @@@ static int post_dock_fixups(struct noti
  			| ((unsigned int)(bus->busn_res.end) << 16);
  		pci_write_config_dword(bus->self, PCI_PRIMARY_BUS, buses);
  	}
 +	return NOTIFY_OK;
  }
  
++<<<<<<< HEAD
++=======
+ static void dock_event(acpi_handle handle, u32 type, void *data)
+ {
+ 	struct acpiphp_context *context;
+ 
+ 	mutex_lock(&acpiphp_context_lock);
+ 	context = acpiphp_get_context(handle);
+ 	if (!context || WARN_ON(context->adev->handle != handle)
+ 	    || context->func.parent->is_going_away) {
+ 		mutex_unlock(&acpiphp_context_lock);
+ 		return;
+ 	}
+ 	get_bridge(context->func.parent);
+ 	acpiphp_put_context(context);
+ 	mutex_unlock(&acpiphp_context_lock);
+ 
+ 	hotplug_event(type, context);
+ 
+ 	put_bridge(context->func.parent);
+ }
++>>>>>>> d3a1ebb063cc (ACPI / hotplug / PCI: Do not pass ACPI handle to hotplug_event())
  
  static const struct acpi_dock_ops acpiphp_dock_ops = {
 -	.fixup = post_dock_fixups,
 -	.handler = dock_event,
 +	.handler = hotplug_event_func,
  };
  
  /* Check whether the PCI device is managed by native PCIe hotplug driver */
@@@ -977,29 -809,25 +1003,39 @@@ void acpiphp_check_host_bridge(acpi_han
  		pci_unlock_rescan_remove();
  		put_bridge(bridge);
  	}
 +
 +	acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
 +		ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
  }
  
++<<<<<<< HEAD
 +static void _handle_hotplug_event_bridge(struct work_struct *work)
 +{
++=======
+ static int acpiphp_disable_and_eject_slot(struct acpiphp_slot *slot);
+ 
+ static void hotplug_event(u32 type, struct acpiphp_context *context)
+ {
+ 	acpi_handle handle = context->adev->handle;
+ 	struct acpiphp_func *func = &context->func;
+ 	struct acpiphp_slot *slot = func->slot;
++>>>>>>> d3a1ebb063cc (ACPI / hotplug / PCI: Do not pass ACPI handle to hotplug_event())
  	struct acpiphp_bridge *bridge;
 +	char objname[64];
 +	struct acpi_buffer buffer = { .length = sizeof(objname),
 +				      .pointer = objname };
 +	struct acpi_hp_work *hp_work;
 +	acpi_handle handle;
 +	u32 type;
  
 -	mutex_lock(&acpiphp_context_lock);
 -	bridge = context->bridge;
 -	if (bridge)
 -		get_bridge(bridge);
 +	hp_work = container_of(work, struct acpi_hp_work, work);
 +	handle = hp_work->handle;
 +	type = hp_work->type;
 +	bridge = (struct acpiphp_bridge *)hp_work->context;
  
 -	mutex_unlock(&acpiphp_context_lock);
 +	acpi_scan_lock_acquire();
  
 -	pci_lock_rescan_remove();
 +	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
  
  	switch (type) {
  	case ACPI_NOTIFY_BUS_CHECK:
@@@ -1054,9 -862,23 +1090,29 @@@
  		break;
  	}
  
++<<<<<<< HEAD
 +	acpi_scan_lock_release();
 +	kfree(hp_work); /* allocated in handle_hotplug_event_bridge */
 +	put_bridge(bridge);
++=======
+ 	pci_unlock_rescan_remove();
+ 	if (bridge)
+ 		put_bridge(bridge);
+ }
+ 
+ static void hotplug_event_work(void *data, u32 type)
+ {
+ 	struct acpiphp_context *context = data;
+ 
+ 	acpi_scan_lock_acquire();
+ 
+ 	hotplug_event(type, context);
+ 
+ 	acpi_scan_lock_release();
+ 	acpi_evaluate_hotplug_ost(context->adev->handle, type,
+ 				  ACPI_OST_SC_SUCCESS, NULL);
+ 	put_bridge(context->func.parent);
++>>>>>>> d3a1ebb063cc (ACPI / hotplug / PCI: Do not pass ACPI handle to hotplug_event())
  }
  
  /**
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
