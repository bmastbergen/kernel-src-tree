vfs: add renameat2 syscall

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit 520c8b16505236fc82daa352e6c5e73cd9870cff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/520c8b16.failed

Add new renameat2 syscall, which is the same as renameat with an added
flags argument.

Pass flags to vfs_rename() and to i_op->rename() as well.

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
	Reviewed-by: J. Bruce Fields <bfields@redhat.com>
(cherry picked from commit 520c8b16505236fc82daa352e6c5e73cd9870cff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/syscalls/syscall_64.tbl
#	drivers/staging/lustre/lustre/include/linux/lustre_compat25.h
#	drivers/staging/lustre/lustre/lvfs/lvfs_linux.c
#	fs/namei.c
diff --cc arch/x86/syscalls/syscall_64.tbl
index 38ae65dfd14f,04376ac3d9ef..000000000000
--- a/arch/x86/syscalls/syscall_64.tbl
+++ b/arch/x86/syscalls/syscall_64.tbl
@@@ -320,6 -320,9 +320,12 @@@
  311	64	process_vm_writev	sys_process_vm_writev
  312	common	kcmp			sys_kcmp
  313	common	finit_module		sys_finit_module
++<<<<<<< HEAD
++=======
+ 314	common	sched_setattr		sys_sched_setattr
+ 315	common	sched_getattr		sys_sched_getattr
+ 316	common	renameat2		sys_renameat2
++>>>>>>> 520c8b165052 (vfs: add renameat2 syscall)
  
  #
  # x32-specific system call numbers start at 512 to avoid cache impact
diff --cc fs/namei.c
index d87d2e09b208,ab4e48c4a80a..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -3953,7 -3973,28 +3953,32 @@@ SYSCALL_DEFINE2(link, const char __use
  	return sys_linkat(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
  }
  
++<<<<<<< HEAD
 +/*
++=======
+ /**
+  * vfs_rename - rename a filesystem object
+  * @old_dir:	parent of source
+  * @old_dentry:	source
+  * @new_dir:	parent of destination
+  * @new_dentry:	destination
+  * @delegated_inode: returns an inode needing a delegation break
+  * @flags:	rename flags
+  *
+  * The caller must hold multiple mutexes--see lock_rename()).
+  *
+  * If vfs_rename discovers a delegation in need of breaking at either
+  * the source or destination, it will return -EWOULDBLOCK and return a
+  * reference to the inode in delegated_inode.  The caller should then
+  * break the delegation and retry.  Because breaking a delegation may
+  * take a long time, the caller should drop all locks before doing
+  * so.
+  *
+  * Alternatively, a caller may pass NULL for delegated_inode.  This may
+  * be appropriate for callers that expect the underlying filesystem not
+  * to be NFS exported.
+  *
++>>>>>>> 520c8b165052 (vfs: add renameat2 syscall)
   * The worst of all namespace operations - renaming directory. "Perverted"
   * doesn't even start to describe it. Somebody in UCB had a heck of a trip...
   * Problems:
@@@ -3981,133 -4022,19 +4006,133 @@@
   *	   ->i_mutex on parents, which works but leads to some truly excessive
   *	   locking].
   */
 +static int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
 +			  struct inode *new_dir, struct dentry *new_dentry)
 +{
 +	int error = 0;
 +	struct inode *target = new_dentry->d_inode;
 +	unsigned max_links = new_dir->i_sb->s_max_links;
 +
 +	/*
 +	 * If we are going to change the parent - check write permissions,
 +	 * we'll need to flip '..'.
 +	 */
 +	if (new_dir != old_dir) {
 +		error = inode_permission(old_dentry->d_inode, MAY_WRITE);
 +		if (error)
 +			return error;
 +	}
 +
 +	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
 +	if (error)
 +		return error;
 +
 +	dget(new_dentry);
 +	if (target)
 +		mutex_lock(&target->i_mutex);
 +
 +	error = -EBUSY;
 +	if (d_mountpoint(old_dentry) || d_mountpoint(new_dentry))
 +		goto out;
 +
 +	error = -EMLINK;
 +	if (max_links && !target && new_dir != old_dir &&
 +	    new_dir->i_nlink >= max_links)
 +		goto out;
 +
 +	if (target)
 +		shrink_dcache_parent(new_dentry);
 +	error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
 +	if (error)
 +		goto out;
 +
 +	if (target) {
 +		target->i_flags |= S_DEAD;
 +		dont_mount(new_dentry);
 +	}
 +out:
 +	if (target)
 +		mutex_unlock(&target->i_mutex);
 +	dput(new_dentry);
 +	if (!error)
 +		if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
 +			d_move(old_dentry,new_dentry);
 +	return error;
 +}
 +
 +static int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,
 +			    struct inode *new_dir, struct dentry *new_dentry,
 +			    struct inode **delegated_inode)
 +{
 +	struct inode *target = new_dentry->d_inode;
 +	struct inode *source = old_dentry->d_inode;
 +	int error;
 +
 +	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
 +	if (error)
 +		return error;
 +
 +	dget(new_dentry);
 +	lock_two_nondirectories(source, target);
 +
 +	error = -EBUSY;
 +	if (d_mountpoint(old_dentry)||d_mountpoint(new_dentry))
 +		goto out;
 +
 +	error = try_break_deleg(source, delegated_inode);
 +	if (error)
 +		goto out;
 +	if (target) {
 +		error = try_break_deleg(target, delegated_inode);
 +		if (error)
 +			goto out;
 +	}
 +	error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
 +	if (error)
 +		goto out;
 +
 +	if (target)
 +		dont_mount(new_dentry);
 +	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
 +		d_move(old_dentry, new_dentry);
 +out:
 +	unlock_two_nondirectories(source, target);
 +	dput(new_dentry);
 +	return error;
 +}
 +
 +/**
 + * vfs_rename - rename a filesystem object
 + * @old_dir:	parent of source
 + * @old_dentry:	source
 + * @new_dir:	parent of destination
 + * @new_dentry:	destination
 + * @delegated_inode: returns an inode needing a delegation break
 + *
 + * The caller must hold multiple mutexes--see lock_rename()).
 + *
 + * If vfs_rename discovers a delegation in need of breaking at either
 + * the source or destination, it will return -EWOULDBLOCK and return a
 + * reference to the inode in delegated_inode.  The caller should then
 + * break the delegation and retry.  Because breaking a delegation may
 + * take a long time, the caller should drop all locks before doing
 + * so.
 + *
 + * Alternatively, a caller may pass NULL for delegated_inode.  This may
 + * be appropriate for callers that expect the underlying filesystem not
 + * to be NFS exported.
 + */
  int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
  	       struct inode *new_dir, struct dentry *new_dentry,
- 	       struct inode **delegated_inode)
+ 	       struct inode **delegated_inode, unsigned int flags)
  {
  	int error;
 -	bool is_dir = d_is_dir(old_dentry);
 +	int is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
  	const unsigned char *old_name;
 -	struct inode *source = old_dentry->d_inode;
 -	struct inode *target = new_dentry->d_inode;
 -
 -	if (source == target)
 -		return 0;
  
 +	if (old_dentry->d_inode == new_dentry->d_inode)
 + 		return 0;
 + 
  	error = may_delete(old_dir, old_dentry, is_dir);
  	if (error)
  		return error;
@@@ -4122,15 -4049,80 +4147,85 @@@
  	if (!old_dir->i_op->rename)
  		return -EPERM;
  
++<<<<<<< HEAD
++=======
+ 	if (flags && !old_dir->i_op->rename2)
+ 		return -EINVAL;
+ 
+ 	/*
+ 	 * If we are going to change the parent - check write permissions,
+ 	 * we'll need to flip '..'.
+ 	 */
+ 	if (is_dir && new_dir != old_dir) {
+ 		error = inode_permission(source, MAY_WRITE);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);
+ 	if (error)
+ 		return error;
+ 
++>>>>>>> 520c8b165052 (vfs: add renameat2 syscall)
  	old_name = fsnotify_oldname_init(old_dentry->d_name.name);
 -	dget(new_dentry);
 -	if (!is_dir)
 -		lock_two_nondirectories(source, target);
 -	else if (target)
 -		mutex_lock(&target->i_mutex);
  
++<<<<<<< HEAD
 +	if (is_dir)
 +		error = vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);
 +	else
 +		error = vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry,delegated_inode);
++=======
+ 	error = -EBUSY;
+ 	if (d_mountpoint(old_dentry) || d_mountpoint(new_dentry))
+ 		goto out;
+ 
+ 	if (is_dir) {
+ 		unsigned max_links = new_dir->i_sb->s_max_links;
+ 
+ 		error = -EMLINK;
+ 		if (max_links && !target && new_dir != old_dir &&
+ 		    new_dir->i_nlink >= max_links)
+ 			goto out;
+ 
+ 		if (target)
+ 			shrink_dcache_parent(new_dentry);
+ 	} else {
+ 		error = try_break_deleg(source, delegated_inode);
+ 		if (error)
+ 			goto out;
+ 		if (target) {
+ 			error = try_break_deleg(target, delegated_inode);
+ 			if (error)
+ 				goto out;
+ 		}
+ 	}
+ 	if (!flags) {
+ 		error = old_dir->i_op->rename(old_dir, old_dentry,
+ 					      new_dir, new_dentry);
+ 	} else {
+ 		error = old_dir->i_op->rename2(old_dir, old_dentry,
+ 					       new_dir, new_dentry, flags);
+ 	}
+ 	if (error)
+ 		goto out;
+ 
+ 	if (target) {
+ 		if (is_dir)
+ 			target->i_flags |= S_DEAD;
+ 		dont_mount(new_dentry);
+ 	}
+ 	if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))
+ 		d_move(old_dentry, new_dentry);
+ out:
+ 	if (!is_dir)
+ 		unlock_two_nondirectories(source, target);
+ 	else if (target)
+ 		mutex_unlock(&target->i_mutex);
+ 	dput(new_dentry);
++>>>>>>> 520c8b165052 (vfs: add renameat2 syscall)
  	if (!error)
  		fsnotify_move(old_dir, new_dir, old_name, is_dir,
 -			      target, old_dentry);
 +			      new_dentry->d_inode, old_dentry);
  	fsnotify_oldname_free(old_name);
  
  	return error;
* Unmerged path drivers/staging/lustre/lustre/include/linux/lustre_compat25.h
* Unmerged path drivers/staging/lustre/lustre/lvfs/lvfs_linux.c
diff --git a/Documentation/filesystems/Locking b/Documentation/filesystems/Locking
index ad6a5a7a678c..959cdfe65331 100644
--- a/Documentation/filesystems/Locking
+++ b/Documentation/filesystems/Locking
@@ -47,6 +47,8 @@ prototypes:
 	int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
+	int (*rename2) (struct inode *, struct dentry *,
+			struct inode *, struct dentry *, unsigned int);
 	int (*readlink) (struct dentry *, char __user *,int);
 	void * (*follow_link) (struct dentry *, struct nameidata *);
 	void (*put_link) (struct dentry *, struct nameidata *, void *);
@@ -77,6 +79,7 @@ mkdir:		yes
 unlink:		yes (both)
 rmdir:		yes (both)	(see below)
 rename:		yes (all)	(see below)
+rename2:	yes (all)	(see below)
 readlink:	no
 follow_link:	no
 put_link:	no
@@ -94,7 +97,8 @@ atomic_open:	yes
 
 	Additionally, ->rmdir(), ->unlink() and ->rename() have ->i_mutex on
 victim.
-	cross-directory ->rename() has (per-superblock) ->s_vfs_rename_sem.
+	cross-directory ->rename() and rename2() has (per-superblock)
+->s_vfs_rename_sem.
 
 See Documentation/filesystems/directory-locking for more detailed discussion
 of the locking scheme for directory operations.
diff --git a/Documentation/filesystems/vfs.txt b/Documentation/filesystems/vfs.txt
index 17a310f1b313..4dbb42cec61f 100644
--- a/Documentation/filesystems/vfs.txt
+++ b/Documentation/filesystems/vfs.txt
@@ -347,6 +347,8 @@ struct inode_operations {
 	int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
+	int (*rename2) (struct inode *, struct dentry *,
+			struct inode *, struct dentry *, unsigned int);
 	int (*readlink) (struct dentry *, char __user *,int);
         void * (*follow_link) (struct dentry *, struct nameidata *);
         void (*put_link) (struct dentry *, struct nameidata *, void *);
@@ -413,6 +415,20 @@ otherwise noted.
   rename: called by the rename(2) system call to rename the object to
 	have the parent and name given by the second inode and dentry.
 
+  rename2: this has an additional flags argument compared to rename.
+	If no flags are supported by the filesystem then this method
+	need not be implemented.  If some flags are supported then the
+	filesystem must return -EINVAL for any unsupported or unknown
+	flags.  Currently the following flags are implemented:
+	(1) RENAME_NOREPLACE: this flag indicates that if the target
+	of the rename exists the rename should fail with -EEXIST
+	instead of replacing the target.  The VFS already checks for
+	existence, so for local filesystems the RENAME_NOREPLACE
+	implementation is equivalent to plain rename.
+	(2) RENAME_EXCHANGE: exchange source and target.  Both must
+	exist; this is checked by the VFS.  Unlike plain rename,
+	source and target may be of different type.
+
   readlink: called by the readlink(2) system call. Only required if
 	you want to support reading symbolic links
 
* Unmerged path arch/x86/syscalls/syscall_64.tbl
* Unmerged path drivers/staging/lustre/lustre/include/linux/lustre_compat25.h
* Unmerged path drivers/staging/lustre/lustre/lvfs/lvfs_linux.c
diff --git a/fs/cachefiles/namei.c b/fs/cachefiles/namei.c
index 678a8af594e1..92103c74836c 100644
--- a/fs/cachefiles/namei.c
+++ b/fs/cachefiles/namei.c
@@ -396,7 +396,7 @@ try_again:
 		cachefiles_io_error(cache, "Rename security error %d", ret);
 	} else {
 		ret = vfs_rename(dir->d_inode, rep,
-				 cache->graveyard->d_inode, grave, NULL);
+				 cache->graveyard->d_inode, grave, NULL, 0);
 		if (ret != 0 && ret != -ENOMEM)
 			cachefiles_io_error(cache,
 					    "Rename failed with error %d", ret);
diff --git a/fs/ecryptfs/inode.c b/fs/ecryptfs/inode.c
index 4cbbf63f4eb5..60d104849dcb 100644
--- a/fs/ecryptfs/inode.c
+++ b/fs/ecryptfs/inode.c
@@ -641,7 +641,7 @@ ecryptfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 	}
 	rc = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,
 			lower_new_dir_dentry->d_inode, lower_new_dentry,
-			NULL);
+			NULL, 0);
 	if (rc)
 		goto out_lock;
 	if (target_inode)
* Unmerged path fs/namei.c
diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c
index 7b60f637b0a6..4f3bb0f843c2 100644
--- a/fs/nfsd/vfs.c
+++ b/fs/nfsd/vfs.c
@@ -1848,7 +1848,7 @@ nfsd_rename(struct svc_rqst *rqstp, struct svc_fh *ffhp, char *fname, int flen,
 	if (ffhp->fh_export->ex_path.dentry != tfhp->fh_export->ex_path.dentry)
 		goto out_dput_new;
 
-	host_err = vfs_rename(fdir, odentry, tdir, ndentry, NULL);
+	host_err = vfs_rename(fdir, odentry, tdir, ndentry, NULL, 0);
 	if (!host_err) {
 		host_err = commit_metadata(tfhp);
 		if (!host_err)
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 8171b14c718b..ab30dd4272b9 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1469,7 +1469,7 @@ extern int vfs_symlink(struct inode *, struct dentry *, const char *);
 extern int vfs_link(struct dentry *, struct inode *, struct dentry *, struct inode **);
 extern int vfs_rmdir(struct inode *, struct dentry *);
 extern int vfs_unlink(struct inode *, struct dentry *, struct inode **);
-extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **);
+extern int vfs_rename(struct inode *, struct dentry *, struct inode *, struct dentry *, struct inode **, unsigned int);
 
 /*
  * VFS dentry helper functions.
@@ -1575,6 +1575,8 @@ struct inode_operations {
 	int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
 	int (*rename) (struct inode *, struct dentry *,
 			struct inode *, struct dentry *);
+	int (*rename2) (struct inode *, struct dentry *,
+			struct inode *, struct dentry *, unsigned int);
 	int (*setattr) (struct dentry *, struct iattr *);
 	int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);
 	int (*setxattr) (struct dentry *, const char *,const void *,size_t,int);
