powerpc/pseries/cpuidle: smt-snooze-delay cleanup.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [powerpc] pseries/cpuidle: smt-snooze-delay cleanup (Don Zickus) [1127366]
Rebuild_FUZZ: 90.11%
commit-author Deepthi Dharwar <deepthi@linux.vnet.ibm.com>
commit 3fa8cad82b94d0bed002571bd246f2299ffc876b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3fa8cad8.failed

smt-snooze-delay was designed to disable NAP state or delay the entry
to the NAP state prior to adoption of cpuidle framework. This
is per-cpu variable. With the coming of CPUIDLE framework,
states can be disabled on per-cpu basis using the cpuidle/enable
sysfs entry.

Also, with the coming of cpuidle driver each state's target residency
is per-driver unlike earlier which was per-device. Therefore,
the per-cpu sysfs smt-snooze-delay which decides the target residency
of the idle state on a particular cpu causes more confusion to the user
as we cannot have different smt-snooze-delay (target residency)
values for each cpu.

In the current code, smt-snooze-delay functionality is completely broken.
It makes sense to remove smt-snooze-delay from idle driver with the
coming of cpuidle framework.
However, sysfs files are retained as ppc64_util currently
utilises it. Once we fix ppc64_util, propose to clean
up the kernel code.

	Signed-off-by: Deepthi Dharwar <deepthi@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 3fa8cad82b94d0bed002571bd246f2299ffc876b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/processor.h
diff --cc arch/powerpc/include/asm/processor.h
index d1c7667742b1,b62de43ae5f3..000000000000
--- a/arch/powerpc/include/asm/processor.h
+++ b/arch/powerpc/include/asm/processor.h
@@@ -443,13 -450,6 +443,16 @@@ enum idle_boot_override {IDLE_NO_OVERRI
  
  extern int powersave_nap;	/* set if nap mode can be used in idle loop */
  extern void power7_nap(void);
++<<<<<<< HEAD
 +
 +#ifdef CONFIG_PSERIES_IDLE
 +extern void update_smt_snooze_delay(int cpu, int residency);
 +#else
 +static inline void update_smt_snooze_delay(int cpu, int residency) {}
 +#endif
 +
++=======
++>>>>>>> 3fa8cad82b94 (powerpc/pseries/cpuidle: smt-snooze-delay cleanup.)
  extern void flush_instruction_cache(void);
  extern void hard_reset_now(void);
  extern void poweroff_now(void);
* Unmerged path arch/powerpc/include/asm/processor.h
diff --git a/arch/powerpc/kernel/sysfs.c b/arch/powerpc/kernel/sysfs.c
index cd369bc5499d..2ab1bef01455 100644
--- a/arch/powerpc/kernel/sysfs.c
+++ b/arch/powerpc/kernel/sysfs.c
@@ -51,8 +51,6 @@ static ssize_t store_smt_snooze_delay(struct device *dev,
 		return -EINVAL;
 
 	per_cpu(smt_snooze_delay, cpu->dev.id) = snooze;
-	update_smt_snooze_delay(cpu->dev.id, snooze);
-
 	return count;
 }
 
diff --git a/arch/powerpc/platforms/pseries/processor_idle.c b/arch/powerpc/platforms/pseries/processor_idle.c
index a166e38bd683..a5eb1ad1e8dc 100644
--- a/arch/powerpc/platforms/pseries/processor_idle.c
+++ b/arch/powerpc/platforms/pseries/processor_idle.c
@@ -169,23 +169,6 @@ static struct cpuidle_state shared_states[MAX_IDLE_STATE_COUNT] = {
 		.enter = &shared_cede_loop },
 };
 
-void update_smt_snooze_delay(int cpu, int residency)
-{
-	struct cpuidle_driver *drv = cpuidle_get_driver();
-	struct cpuidle_device *dev = per_cpu(cpuidle_devices, cpu);
-
-	if (cpuidle_state_table != dedicated_states)
-		return;
-
-	if (residency < 0) {
-		/* Disable the Nap state on that cpu */
-		if (dev)
-			dev->states_usage[1].disable = 1;
-	} else
-		if (drv)
-			drv->states[1].target_residency = residency;
-}
-
 static int pseries_cpuidle_add_cpu_notifier(struct notifier_block *n,
 			unsigned long action, void *hcpu)
 {
