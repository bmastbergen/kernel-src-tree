cpufreq: preserve user_policy across suspend/resume

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] preserve user_policy across suspend/resume (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 90.32%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 08fd8c1cf0a99abf34e09a8b99b74872e0d73a23
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/08fd8c1c.failed

Prevent __cpufreq_add_dev() from overwriting the existing values of
user_policy.{min|max|policy|governor} with defaults during resume
from system suspend.

Fixes: 5302c3fb2e62 ("cpufreq: Perform light-weight init/teardown during suspend/resume")
	Reported-by: Bj√∏rn Mork <bjorn@mork.no>
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Cc: 3.12+ <stable@vger.kernel.org> # 3.12+
[rjw: Changelog]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 08fd8c1cf0a99abf34e09a8b99b74872e0d73a23)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index 7e78bc2de297,8d19f7c06010..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -862,10 -838,7 +862,14 @@@ static void cpufreq_init_policy(struct 
  	policy->governor = NULL;
  
  	/* set default policy */
++<<<<<<< HEAD
 +	ret = __cpufreq_set_policy(policy, &new_policy);
 +	policy->user_policy.policy = policy->policy;
 +	policy->user_policy.governor = policy->governor;
 +
++=======
+ 	ret = cpufreq_set_policy(policy, &new_policy);
++>>>>>>> 08fd8c1cf0a9 (cpufreq: preserve user_policy across suspend/resume)
  	if (ret) {
  		pr_debug("setting policy failed\n");
  		if (cpufreq_driver->exit)
@@@ -1026,20 -1086,30 +1032,25 @@@ static int cpufreq_add_dev(struct devic
  #endif
  
  	write_lock_irqsave(&cpufreq_driver_lock, flags);
 -	for_each_cpu(j, policy->cpus)
 +	for_each_cpu(j, policy->cpus) {
  		per_cpu(cpufreq_cpu_data, j) = policy;
 -	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
 -
 -	if (!frozen) {
 -		ret = cpufreq_add_dev_interface(policy, dev);
 -		if (ret)
 -			goto err_out_unregister;
 +		per_cpu(cpufreq_policy_cpu, j) = policy->cpu;
  	}
 -
 -	write_lock_irqsave(&cpufreq_driver_lock, flags);
 -	list_add(&policy->policy_list, &cpufreq_policy_list);
  	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
  
 +	ret = cpufreq_add_dev_interface(cpu, policy, dev);
 +	if (ret)
 +		goto err_out_unregister;
 +
  	cpufreq_init_policy(policy);
  
+ 	if (!frozen) {
+ 		policy->user_policy.policy = policy->policy;
+ 		policy->user_policy.governor = policy->governor;
+ 	}
+ 
  	kobject_uevent(&policy->kobj, KOBJ_ADD);
  	up_read(&cpufreq_rwsem);
 -
  	pr_debug("initialization complete\n");
  
  	return 0;
* Unmerged path drivers/cpufreq/cpufreq.c
