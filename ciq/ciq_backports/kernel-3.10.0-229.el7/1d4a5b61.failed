ACPI / hotplug / PCI: Use acpi_handle_debug() in hotplug_event()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Use acpi_handle_debug() in hotplug_event() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 92.44%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 1d4a5b610e500fe860570db4ceb64e45255221ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/1d4a5b61.failed

Make hotplug_event() use acpi_handle_debug() instead of an open-coded
debug message printing and clean up the messages printed by it.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 1d4a5b610e500fe860570db4ceb64e45255221ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,64ad6eed983f..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -977,86 -809,76 +977,121 @@@ void acpiphp_check_host_bridge(acpi_han
  		pci_unlock_rescan_remove();
  		put_bridge(bridge);
  	}
 -}
  
 -static int acpiphp_disable_and_eject_slot(struct acpiphp_slot *slot);
 +	acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
 +		ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
 +}
  
 -static void hotplug_event(acpi_handle handle, u32 type, void *data)
 +static void _handle_hotplug_event_bridge(struct work_struct *work)
  {
 -	struct acpiphp_context *context = data;
 -	struct acpiphp_func *func = &context->func;
 -	struct acpiphp_slot *slot = func->slot;
  	struct acpiphp_bridge *bridge;
++<<<<<<< HEAD
 +	char objname[64];
 +	struct acpi_buffer buffer = { .length = sizeof(objname),
 +				      .pointer = objname };
 +	struct acpi_hp_work *hp_work;
 +	acpi_handle handle;
 +	u32 type;
++=======
++>>>>>>> 1d4a5b610e50 (ACPI / hotplug / PCI: Use acpi_handle_debug() in hotplug_event())
  
 -	mutex_lock(&acpiphp_context_lock);
 -	bridge = context->bridge;
 -	if (bridge)
 -		get_bridge(bridge);
 +	hp_work = container_of(work, struct acpi_hp_work, work);
 +	handle = hp_work->handle;
 +	type = hp_work->type;
 +	bridge = (struct acpiphp_bridge *)hp_work->context;
  
 -	mutex_unlock(&acpiphp_context_lock);
 +	acpi_scan_lock_acquire();
  
++<<<<<<< HEAD
 +	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
++=======
+ 	pci_lock_rescan_remove();
++>>>>>>> 1d4a5b610e50 (ACPI / hotplug / PCI: Use acpi_handle_debug() in hotplug_event())
  
  	switch (type) {
  	case ACPI_NOTIFY_BUS_CHECK:
  		/* bus re-enumerate */
++<<<<<<< HEAD
 +		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
 +		pr_debug("%s: re-enumerating slots under %s\n",
 +			 __func__, objname);
 +		acpiphp_check_bridge(bridge);
 +		acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
 +			ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
++=======
+ 		acpi_handle_debug(handle, "Bus check in %s()\n", __func__);
+ 		if (bridge)
+ 			acpiphp_check_bridge(bridge);
+ 		else if (!(slot->flags & SLOT_IS_GOING_AWAY))
+ 			enable_slot(slot);
+ 
++>>>>>>> 1d4a5b610e50 (ACPI / hotplug / PCI: Use acpi_handle_debug() in hotplug_event())
  		break;
  
  	case ACPI_NOTIFY_DEVICE_CHECK:
  		/* device check */
++<<<<<<< HEAD
 +		pr_debug("%s: Device check notify on %s\n", __func__, objname);
 +		acpiphp_check_bridge(bridge);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_WAKE:
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
++=======
+ 		acpi_handle_debug(handle, "Device check in %s()\n", __func__);
+ 		if (bridge) {
+ 			acpiphp_check_bridge(bridge);
+ 		} else if (!(slot->flags & SLOT_IS_GOING_AWAY)) {
+ 			/*
+ 			 * Check if anything has changed in the slot and rescan
+ 			 * from the parent if that's the case.
+ 			 */
+ 			if (acpiphp_rescan_slot(slot))
+ 				acpiphp_check_bridge(func->parent);
+ 		}
++>>>>>>> 1d4a5b610e50 (ACPI / hotplug / PCI: Use acpi_handle_debug() in hotplug_event())
  		break;
  
  	case ACPI_NOTIFY_EJECT_REQUEST:
  		/* request device eject */
 -		acpi_handle_debug(handle, "Eject request in %s()\n", __func__);
 -		acpiphp_disable_and_eject_slot(slot);
++<<<<<<< HEAD
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {
 +			struct acpiphp_slot *slot;
 +			slot = bridge->func->slot;
 +			if (!acpiphp_disable_slot(slot))
 +				acpiphp_eject_slot(slot);
 +		}
  		break;
 -	}
  
 -	pci_unlock_rescan_remove();
 -	if (bridge)
 -		put_bridge(bridge);
 -}
 +	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
 +		printk(KERN_ERR "Device %s cannot be configured due"
 +				" to a frequency mismatch\n", objname);
 +		break;
  
 -static void hotplug_event_work(void *data, u32 type)
 -{
 -	struct acpiphp_context *context = data;
 -	acpi_handle handle = context->adev->handle;
 +	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
 +		printk(KERN_ERR "Device %s cannot be configured due"
 +				" to a bus mode mismatch\n", objname);
 +		break;
  
 -	acpi_scan_lock_acquire();
 +	case ACPI_NOTIFY_POWER_FAULT:
 +		printk(KERN_ERR "Device %s has suffered a power fault\n",
 +				objname);
 +		break;
  
 -	hotplug_event(handle, type, context);
 +	default:
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
++=======
++		acpi_handle_debug(handle, "Eject request in %s()\n", __func__);
++		acpiphp_disable_and_eject_slot(slot);
++>>>>>>> 1d4a5b610e50 (ACPI / hotplug / PCI: Use acpi_handle_debug() in hotplug_event())
 +		break;
 +	}
  
  	acpi_scan_lock_release();
 -	acpi_evaluate_hotplug_ost(handle, type, ACPI_OST_SC_SUCCESS, NULL);
 -	put_bridge(context->func.parent);
 +	kfree(hp_work); /* allocated in handle_hotplug_event_bridge */
 +	put_bridge(bridge);
  }
  
  /**
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
