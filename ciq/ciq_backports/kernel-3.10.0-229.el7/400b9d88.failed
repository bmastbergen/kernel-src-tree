xfs: catch buffers written without verifiers attached

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 400b9d88757c0bfbdfa97014e090ec40a31c1282
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/400b9d88.failed

We recently had a bug where buffers were slipping through log
recovery without any verifier attached to them. This was resulting
in on-disk CRC mismatches for valid data. Add some warning code to
catch this occurrence so that we catch such bugs during development
rather than not being aware they exist.

Note that we cannot do this verification unconditionally as non-CRC
filesystems don't always attach verifiers to the buffers being
written. e.g. during log recovery we cannot identify all the
different types of buffers correctly on non-CRC filesystems, so we
can't attach the correct verifiers in all cases and so we don't
attach any. Hence we don't want on non-CRC filesystems to avoid
spamming the logs with false indications.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 400b9d88757c0bfbdfa97014e090ec40a31c1282)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_log.c
diff --cc fs/xfs/xfs_log.c
index a5f8bd9899d3,d015ed7d4a26..000000000000
--- a/fs/xfs/xfs_log.c
+++ b/fs/xfs/xfs_log.c
@@@ -1369,8 -1369,14 +1369,19 @@@ xlog_alloc_log
  
  	xlog_get_iclog_buffer_size(mp, log);
  
++<<<<<<< HEAD
 +	error = ENOMEM;
 +	bp = xfs_buf_alloc(mp->m_logdev_targp, 0, BTOBB(log->l_iclog_size), 0);
++=======
+ 	/*
+ 	 * Use a NULL block for the extra log buffer used during splits so that
+ 	 * it will trigger errors if we ever try to do IO on it without first
+ 	 * having set it up properly.
+ 	 */
+ 	error = -ENOMEM;
+ 	bp = xfs_buf_alloc(mp->m_logdev_targp, XFS_BUF_DADDR_NULL,
+ 			   BTOBB(log->l_iclog_size), 0);
++>>>>>>> 400b9d88757c (xfs: catch buffers written without verifiers attached)
  	if (!bp)
  		goto out_free_log;
  
diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c
index dbb69f06a7f7..9edc0e5a4b54 100644
--- a/fs/xfs/xfs_buf.c
+++ b/fs/xfs/xfs_buf.c
@@ -1352,6 +1352,20 @@ _xfs_buf_ioapply(
 						   SHUTDOWN_CORRUPT_INCORE);
 				return;
 			}
+		} else if (bp->b_bn != XFS_BUF_DADDR_NULL) {
+			struct xfs_mount *mp = bp->b_target->bt_mount;
+
+			/*
+			 * non-crc filesystems don't attach verifiers during
+			 * log recovery, so don't warn for such filesystems.
+			 */
+			if (xfs_sb_version_hascrc(&mp->m_sb)) {
+				xfs_warn(mp,
+					"%s: no ops on block 0x%llx/0x%x",
+					__func__, bp->b_bn, bp->b_length);
+				xfs_hex_dump(bp->b_addr, 64);
+				dump_stack();
+			}
 		}
 	} else if (bp->b_flags & XBF_READ_AHEAD) {
 		rw = READA;
* Unmerged path fs/xfs/xfs_log.c
