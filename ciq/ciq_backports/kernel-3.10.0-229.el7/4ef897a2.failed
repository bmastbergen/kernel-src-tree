xfs: flush both inodes in xfs_swap_extents

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit 4ef897a27543b513351262881660147366c042a1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/4ef897a2.failed

We need to treat both inodes identically from a page cache point of
view when prepareing them for extent swapping. We don't do this
right now - we assume that one of the inodes empty, because that's
what xfs_fsr currently does. Remove this assumption from the code.

While factoring out the flushing and related checks, move the
transactions reservation to immeidately after the flushes so that we
don't need to pick up and then drop the ilock to do the transaction
reservation. There are no issues with aborting the transaction it if
the checks fail before we join the inodes to the transaction and
dirty them, so this is a safe change to make.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit 4ef897a27543b513351262881660147366c042a1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
diff --cc fs/xfs/xfs_bmap_util.c
index 94eb31033c80,8f7da5877fa3..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -1558,26 -1739,28 +1582,46 @@@ xfs_swap_extents
  		goto out_unlock;
  	}
  
++<<<<<<< HEAD
 +	error = -filemap_write_and_wait(VFS_I(tip)->i_mapping);
++=======
+ 	error = xfs_swap_extent_flush(ip);
+ 	if (error)
+ 		goto out_unlock;
+ 	error = xfs_swap_extent_flush(tip);
++>>>>>>> 4ef897a27543 (xfs: flush both inodes in xfs_swap_extents)
  	if (error)
  		goto out_unlock;
- 	truncate_pagecache_range(VFS_I(tip), 0, -1);
  
++<<<<<<< HEAD
 +	xfs_lock_two_inodes(ip, tip, XFS_ILOCK_EXCL);
 +	lock_flags |= XFS_ILOCK_EXCL;
 +
 +	/* Verify O_DIRECT for ftmp */
 +	if (VN_CACHED(VFS_I(tip)) != 0) {
 +		error = XFS_ERROR(EINVAL);
++=======
+ 	tp = xfs_trans_alloc(mp, XFS_TRANS_SWAPEXT);
+ 	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);
+ 	if (error) {
+ 		xfs_trans_cancel(tp, 0);
++>>>>>>> 4ef897a27543 (xfs: flush both inodes in xfs_swap_extents)
  		goto out_unlock;
  	}
+ 	xfs_lock_two_inodes(ip, tip, XFS_ILOCK_EXCL);
+ 	lock_flags |= XFS_ILOCK_EXCL;
  
  	/* Verify all data are being swapped */
  	if (sxp->sx_offset != 0 ||
  	    sxp->sx_length != ip->i_d.di_size ||
  	    sxp->sx_length != tip->i_d.di_size) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EFAULT);
 +		goto out_unlock;
++=======
+ 		error = -EFAULT;
+ 		goto out_trans_cancel;
++>>>>>>> 4ef897a27543 (xfs: flush both inodes in xfs_swap_extents)
  	}
  
  	trace_xfs_swap_extent_before(ip, 0);
@@@ -1603,42 -1786,9 +1647,43 @@@
  	    (sbp->bs_ctime.tv_nsec != VFS_I(ip)->i_ctime.tv_nsec) ||
  	    (sbp->bs_mtime.tv_sec != VFS_I(ip)->i_mtime.tv_sec) ||
  	    (sbp->bs_mtime.tv_nsec != VFS_I(ip)->i_mtime.tv_nsec)) {
++<<<<<<< HEAD
 +		error = XFS_ERROR(EBUSY);
 +		goto out_unlock;
 +	}
 +
 +	/* We need to fail if the file is memory mapped.  Once we have tossed
 +	 * all existing pages, the page fault will have no option
 +	 * but to go to the filesystem for pages. By making the page fault call
 +	 * vop_read (or write in the case of autogrow) they block on the iolock
 +	 * until we have switched the extents.
 +	 */
 +	if (VN_MAPPED(VFS_I(ip))) {
 +		error = XFS_ERROR(EBUSY);
 +		goto out_unlock;
 +	}
 +
 +	xfs_iunlock(ip, XFS_ILOCK_EXCL);
 +	xfs_iunlock(tip, XFS_ILOCK_EXCL);
 +	lock_flags &= ~XFS_ILOCK_EXCL;
 +
 +	/*
 +	 * There is a race condition here since we gave up the
 +	 * ilock.  However, the data fork will not change since
 +	 * we have the iolock (locked for truncation too) so we
 +	 * are safe.  We don't really care if non-io related
 +	 * fields change.
 +	 */
 +	truncate_pagecache_range(VFS_I(ip), 0, -1);
 +
 +	tp = xfs_trans_alloc(mp, XFS_TRANS_SWAPEXT);
 +	error = xfs_trans_reserve(tp, &M_RES(mp)->tr_ichange, 0, 0);
 +	if (error)
++=======
+ 		error = -EBUSY;
++>>>>>>> 4ef897a27543 (xfs: flush both inodes in xfs_swap_extents)
  		goto out_trans_cancel;
- 
- 	xfs_lock_two_inodes(ip, tip, XFS_ILOCK_EXCL);
- 	lock_flags |= XFS_ILOCK_EXCL;
- 
+ 	}
  	/*
  	 * Count the number of extended attribute blocks
  	 */
* Unmerged path fs/xfs/xfs_bmap_util.c
