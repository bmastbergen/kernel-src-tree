iwlwifi: mvm: fix endianity issues with Smart Fifo commands

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [wireless] iwlwifi/mvm: fix endianity issues with Smart Fifo commands (Stanislaw Gruszka) [1155538]
Rebuild_FUZZ: 97.44%
commit-author Emmanuel Grumbach <emmanuel.grumbach@intel.com>
commit 86974bff066dd8b98be46d7c7d3aba89034f0833
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/86974bff.failed

This code was broken on big endian systems. Sparse didn't
catch the bug since the firmware command was not tagged as
little endian.
Fix the bug for big endian systems and tag the field in the
firmware command to prevent such issues in the future.

	Cc: stable@vger.kernel.org [3.14+]
Fixes: 1f3b0ff8ec ("iwlwifi: mvm: Add Smart FIFO support")
	Reviewed-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
(cherry picked from commit 86974bff066dd8b98be46d7c7d3aba89034f0833)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/iwlwifi/mvm/fw-api.h
#	drivers/net/wireless/iwlwifi/mvm/sf.c
diff --cc drivers/net/wireless/iwlwifi/mvm/fw-api.h
index c6384555aab4,9a922f3bd16b..000000000000
--- a/drivers/net/wireless/iwlwifi/mvm/fw-api.h
+++ b/drivers/net/wireless/iwlwifi/mvm/fw-api.h
@@@ -975,4 -1223,357 +975,360 @@@ struct iwl_mcast_filter_cmd 
  	u8 addr_list[0];
  } __packed; /* MCAST_FILTERING_CMD_API_S_VER_1 */
  
++<<<<<<< HEAD
++=======
+ #define MAX_BCAST_FILTERS 8
+ #define MAX_BCAST_FILTER_ATTRS 2
+ 
+ /**
+  * enum iwl_mvm_bcast_filter_attr_offset - written by fw for each Rx packet
+  * @BCAST_FILTER_OFFSET_PAYLOAD_START: offset is from payload start.
+  * @BCAST_FILTER_OFFSET_IP_END: offset is from ip header end (i.e.
+  *	start of ip payload).
+  */
+ enum iwl_mvm_bcast_filter_attr_offset {
+ 	BCAST_FILTER_OFFSET_PAYLOAD_START = 0,
+ 	BCAST_FILTER_OFFSET_IP_END = 1,
+ };
+ 
+ /**
+  * struct iwl_fw_bcast_filter_attr - broadcast filter attribute
+  * @offset_type:	&enum iwl_mvm_bcast_filter_attr_offset.
+  * @offset:	starting offset of this pattern.
+  * @val:		value to match - big endian (MSB is the first
+  *		byte to match from offset pos).
+  * @mask:	mask to match (big endian).
+  */
+ struct iwl_fw_bcast_filter_attr {
+ 	u8 offset_type;
+ 	u8 offset;
+ 	__le16 reserved1;
+ 	__be32 val;
+ 	__be32 mask;
+ } __packed; /* BCAST_FILTER_ATT_S_VER_1 */
+ 
+ /**
+  * enum iwl_mvm_bcast_filter_frame_type - filter frame type
+  * @BCAST_FILTER_FRAME_TYPE_ALL: consider all frames.
+  * @BCAST_FILTER_FRAME_TYPE_IPV4: consider only ipv4 frames
+  */
+ enum iwl_mvm_bcast_filter_frame_type {
+ 	BCAST_FILTER_FRAME_TYPE_ALL = 0,
+ 	BCAST_FILTER_FRAME_TYPE_IPV4 = 1,
+ };
+ 
+ /**
+  * struct iwl_fw_bcast_filter - broadcast filter
+  * @discard: discard frame (1) or let it pass (0).
+  * @frame_type: &enum iwl_mvm_bcast_filter_frame_type.
+  * @num_attrs: number of valid attributes in this filter.
+  * @attrs: attributes of this filter. a filter is considered matched
+  *	only when all its attributes are matched (i.e. AND relationship)
+  */
+ struct iwl_fw_bcast_filter {
+ 	u8 discard;
+ 	u8 frame_type;
+ 	u8 num_attrs;
+ 	u8 reserved1;
+ 	struct iwl_fw_bcast_filter_attr attrs[MAX_BCAST_FILTER_ATTRS];
+ } __packed; /* BCAST_FILTER_S_VER_1 */
+ 
+ /**
+  * struct iwl_fw_bcast_mac - per-mac broadcast filtering configuration.
+  * @default_discard: default action for this mac (discard (1) / pass (0)).
+  * @attached_filters: bitmap of relevant filters for this mac.
+  */
+ struct iwl_fw_bcast_mac {
+ 	u8 default_discard;
+ 	u8 reserved1;
+ 	__le16 attached_filters;
+ } __packed; /* BCAST_MAC_CONTEXT_S_VER_1 */
+ 
+ /**
+  * struct iwl_bcast_filter_cmd - broadcast filtering configuration
+  * @disable: enable (0) / disable (1)
+  * @max_bcast_filters: max number of filters (MAX_BCAST_FILTERS)
+  * @max_macs: max number of macs (NUM_MAC_INDEX_DRIVER)
+  * @filters: broadcast filters
+  * @macs: broadcast filtering configuration per-mac
+  */
+ struct iwl_bcast_filter_cmd {
+ 	u8 disable;
+ 	u8 max_bcast_filters;
+ 	u8 max_macs;
+ 	u8 reserved1;
+ 	struct iwl_fw_bcast_filter filters[MAX_BCAST_FILTERS];
+ 	struct iwl_fw_bcast_mac macs[NUM_MAC_INDEX_DRIVER];
+ } __packed; /* BCAST_FILTERING_HCMD_API_S_VER_1 */
+ 
+ struct mvm_statistics_dbg {
+ 	__le32 burst_check;
+ 	__le32 burst_count;
+ 	__le32 wait_for_silence_timeout_cnt;
+ 	__le32 reserved[3];
+ } __packed; /* STATISTICS_DEBUG_API_S_VER_2 */
+ 
+ struct mvm_statistics_div {
+ 	__le32 tx_on_a;
+ 	__le32 tx_on_b;
+ 	__le32 exec_time;
+ 	__le32 probe_time;
+ 	__le32 rssi_ant;
+ 	__le32 reserved2;
+ } __packed; /* STATISTICS_SLOW_DIV_API_S_VER_2 */
+ 
+ struct mvm_statistics_general_common {
+ 	__le32 temperature;   /* radio temperature */
+ 	__le32 temperature_m; /* radio voltage */
+ 	struct mvm_statistics_dbg dbg;
+ 	__le32 sleep_time;
+ 	__le32 slots_out;
+ 	__le32 slots_idle;
+ 	__le32 ttl_timestamp;
+ 	struct mvm_statistics_div div;
+ 	__le32 rx_enable_counter;
+ 	/*
+ 	 * num_of_sos_states:
+ 	 *  count the number of times we have to re-tune
+ 	 *  in order to get out of bad PHY status
+ 	 */
+ 	__le32 num_of_sos_states;
+ } __packed; /* STATISTICS_GENERAL_API_S_VER_5 */
+ 
+ struct mvm_statistics_rx_non_phy {
+ 	__le32 bogus_cts;	/* CTS received when not expecting CTS */
+ 	__le32 bogus_ack;	/* ACK received when not expecting ACK */
+ 	__le32 non_bssid_frames;	/* number of frames with BSSID that
+ 					 * doesn't belong to the STA BSSID */
+ 	__le32 filtered_frames;	/* count frames that were dumped in the
+ 				 * filtering process */
+ 	__le32 non_channel_beacons;	/* beacons with our bss id but not on
+ 					 * our serving channel */
+ 	__le32 channel_beacons;	/* beacons with our bss id and in our
+ 				 * serving channel */
+ 	__le32 num_missed_bcon;	/* number of missed beacons */
+ 	__le32 adc_rx_saturation_time;	/* count in 0.8us units the time the
+ 					 * ADC was in saturation */
+ 	__le32 ina_detection_search_time;/* total time (in 0.8us) searched
+ 					  * for INA */
+ 	__le32 beacon_silence_rssi_a;	/* RSSI silence after beacon frame */
+ 	__le32 beacon_silence_rssi_b;	/* RSSI silence after beacon frame */
+ 	__le32 beacon_silence_rssi_c;	/* RSSI silence after beacon frame */
+ 	__le32 interference_data_flag;	/* flag for interference data
+ 					 * availability. 1 when data is
+ 					 * available. */
+ 	__le32 channel_load;		/* counts RX Enable time in uSec */
+ 	__le32 dsp_false_alarms;	/* DSP false alarm (both OFDM
+ 					 * and CCK) counter */
+ 	__le32 beacon_rssi_a;
+ 	__le32 beacon_rssi_b;
+ 	__le32 beacon_rssi_c;
+ 	__le32 beacon_energy_a;
+ 	__le32 beacon_energy_b;
+ 	__le32 beacon_energy_c;
+ 	__le32 num_bt_kills;
+ 	__le32 mac_id;
+ 	__le32 directed_data_mpdu;
+ } __packed; /* STATISTICS_RX_NON_PHY_API_S_VER_3 */
+ 
+ struct mvm_statistics_rx_phy {
+ 	__le32 ina_cnt;
+ 	__le32 fina_cnt;
+ 	__le32 plcp_err;
+ 	__le32 crc32_err;
+ 	__le32 overrun_err;
+ 	__le32 early_overrun_err;
+ 	__le32 crc32_good;
+ 	__le32 false_alarm_cnt;
+ 	__le32 fina_sync_err_cnt;
+ 	__le32 sfd_timeout;
+ 	__le32 fina_timeout;
+ 	__le32 unresponded_rts;
+ 	__le32 rxe_frame_limit_overrun;
+ 	__le32 sent_ack_cnt;
+ 	__le32 sent_cts_cnt;
+ 	__le32 sent_ba_rsp_cnt;
+ 	__le32 dsp_self_kill;
+ 	__le32 mh_format_err;
+ 	__le32 re_acq_main_rssi_sum;
+ 	__le32 reserved;
+ } __packed; /* STATISTICS_RX_PHY_API_S_VER_2 */
+ 
+ struct mvm_statistics_rx_ht_phy {
+ 	__le32 plcp_err;
+ 	__le32 overrun_err;
+ 	__le32 early_overrun_err;
+ 	__le32 crc32_good;
+ 	__le32 crc32_err;
+ 	__le32 mh_format_err;
+ 	__le32 agg_crc32_good;
+ 	__le32 agg_mpdu_cnt;
+ 	__le32 agg_cnt;
+ 	__le32 unsupport_mcs;
+ } __packed;  /* STATISTICS_HT_RX_PHY_API_S_VER_1 */
+ 
+ #define MAX_CHAINS 3
+ 
+ struct mvm_statistics_tx_non_phy_agg {
+ 	__le32 ba_timeout;
+ 	__le32 ba_reschedule_frames;
+ 	__le32 scd_query_agg_frame_cnt;
+ 	__le32 scd_query_no_agg;
+ 	__le32 scd_query_agg;
+ 	__le32 scd_query_mismatch;
+ 	__le32 frame_not_ready;
+ 	__le32 underrun;
+ 	__le32 bt_prio_kill;
+ 	__le32 rx_ba_rsp_cnt;
+ 	__s8 txpower[MAX_CHAINS];
+ 	__s8 reserved;
+ 	__le32 reserved2;
+ } __packed; /* STATISTICS_TX_NON_PHY_AGG_API_S_VER_1 */
+ 
+ struct mvm_statistics_tx_channel_width {
+ 	__le32 ext_cca_narrow_ch20[1];
+ 	__le32 ext_cca_narrow_ch40[2];
+ 	__le32 ext_cca_narrow_ch80[3];
+ 	__le32 ext_cca_narrow_ch160[4];
+ 	__le32 last_tx_ch_width_indx;
+ 	__le32 rx_detected_per_ch_width[4];
+ 	__le32 success_per_ch_width[4];
+ 	__le32 fail_per_ch_width[4];
+ }; /* STATISTICS_TX_CHANNEL_WIDTH_API_S_VER_1 */
+ 
+ struct mvm_statistics_tx {
+ 	__le32 preamble_cnt;
+ 	__le32 rx_detected_cnt;
+ 	__le32 bt_prio_defer_cnt;
+ 	__le32 bt_prio_kill_cnt;
+ 	__le32 few_bytes_cnt;
+ 	__le32 cts_timeout;
+ 	__le32 ack_timeout;
+ 	__le32 expected_ack_cnt;
+ 	__le32 actual_ack_cnt;
+ 	__le32 dump_msdu_cnt;
+ 	__le32 burst_abort_next_frame_mismatch_cnt;
+ 	__le32 burst_abort_missing_next_frame_cnt;
+ 	__le32 cts_timeout_collision;
+ 	__le32 ack_or_ba_timeout_collision;
+ 	struct mvm_statistics_tx_non_phy_agg agg;
+ 	struct mvm_statistics_tx_channel_width channel_width;
+ } __packed; /* STATISTICS_TX_API_S_VER_4 */
+ 
+ 
+ struct mvm_statistics_bt_activity {
+ 	__le32 hi_priority_tx_req_cnt;
+ 	__le32 hi_priority_tx_denied_cnt;
+ 	__le32 lo_priority_tx_req_cnt;
+ 	__le32 lo_priority_tx_denied_cnt;
+ 	__le32 hi_priority_rx_req_cnt;
+ 	__le32 hi_priority_rx_denied_cnt;
+ 	__le32 lo_priority_rx_req_cnt;
+ 	__le32 lo_priority_rx_denied_cnt;
+ } __packed;  /* STATISTICS_BT_ACTIVITY_API_S_VER_1 */
+ 
+ struct mvm_statistics_general {
+ 	struct mvm_statistics_general_common common;
+ 	__le32 beacon_filtered;
+ 	__le32 missed_beacons;
+ 	__s8 beacon_filter_average_energy;
+ 	__s8 beacon_filter_reason;
+ 	__s8 beacon_filter_current_energy;
+ 	__s8 beacon_filter_reserved;
+ 	__le32 beacon_filter_delta_time;
+ 	struct mvm_statistics_bt_activity bt_activity;
+ } __packed; /* STATISTICS_GENERAL_API_S_VER_5 */
+ 
+ struct mvm_statistics_rx {
+ 	struct mvm_statistics_rx_phy ofdm;
+ 	struct mvm_statistics_rx_phy cck;
+ 	struct mvm_statistics_rx_non_phy general;
+ 	struct mvm_statistics_rx_ht_phy ofdm_ht;
+ } __packed; /* STATISTICS_RX_API_S_VER_3 */
+ 
+ /*
+  * STATISTICS_NOTIFICATION = 0x9d (notification only, not a command)
+  *
+  * By default, uCode issues this notification after receiving a beacon
+  * while associated.  To disable this behavior, set DISABLE_NOTIF flag in the
+  * REPLY_STATISTICS_CMD 0x9c, above.
+  *
+  * Statistics counters continue to increment beacon after beacon, but are
+  * cleared when changing channels or when driver issues REPLY_STATISTICS_CMD
+  * 0x9c with CLEAR_STATS bit set (see above).
+  *
+  * uCode also issues this notification during scans.  uCode clears statistics
+  * appropriately so that each notification contains statistics for only the
+  * one channel that has just been scanned.
+  */
+ 
+ struct iwl_notif_statistics { /* STATISTICS_NTFY_API_S_VER_8 */
+ 	__le32 flag;
+ 	struct mvm_statistics_rx rx;
+ 	struct mvm_statistics_tx tx;
+ 	struct mvm_statistics_general general;
+ } __packed;
+ 
+ /***********************************
+  * Smart Fifo API
+  ***********************************/
+ /* Smart Fifo state */
+ enum iwl_sf_state {
+ 	SF_LONG_DELAY_ON = 0, /* should never be called by driver */
+ 	SF_FULL_ON,
+ 	SF_UNINIT,
+ 	SF_INIT_OFF,
+ 	SF_HW_NUM_STATES
+ };
+ 
+ /* Smart Fifo possible scenario */
+ enum iwl_sf_scenario {
+ 	SF_SCENARIO_SINGLE_UNICAST,
+ 	SF_SCENARIO_AGG_UNICAST,
+ 	SF_SCENARIO_MULTICAST,
+ 	SF_SCENARIO_BA_RESP,
+ 	SF_SCENARIO_TX_RESP,
+ 	SF_NUM_SCENARIO
+ };
+ 
+ #define SF_TRANSIENT_STATES_NUMBER 2	/* SF_LONG_DELAY_ON and SF_FULL_ON */
+ #define SF_NUM_TIMEOUT_TYPES 2		/* Aging timer and Idle timer */
+ 
+ /* smart FIFO default values */
+ #define SF_W_MARK_SISO 4096
+ #define SF_W_MARK_MIMO2 8192
+ #define SF_W_MARK_MIMO3 6144
+ #define SF_W_MARK_LEGACY 4096
+ #define SF_W_MARK_SCAN 4096
+ 
+ /* SF Scenarios timers for FULL_ON state (aligned to 32 uSec) */
+ #define SF_SINGLE_UNICAST_IDLE_TIMER 320	/* 300 uSec  */
+ #define SF_SINGLE_UNICAST_AGING_TIMER 2016	/* 2 mSec */
+ #define SF_AGG_UNICAST_IDLE_TIMER 320		/* 300 uSec */
+ #define SF_AGG_UNICAST_AGING_TIMER 2016		/* 2 mSec */
+ #define SF_MCAST_IDLE_TIMER 2016		/* 2 mSec */
+ #define SF_MCAST_AGING_TIMER 10016		/* 10 mSec */
+ #define SF_BA_IDLE_TIMER 320			/* 300 uSec */
+ #define SF_BA_AGING_TIMER 2016			/* 2 mSec */
+ #define SF_TX_RE_IDLE_TIMER 320			/* 300 uSec */
+ #define SF_TX_RE_AGING_TIMER 2016		/* 2 mSec */
+ 
+ #define SF_LONG_DELAY_AGING_TIMER 1000000	/* 1 Sec */
+ 
+ /**
+  * Smart Fifo configuration command.
+  * @state: smart fifo state, types listed in enum %iwl_sf_sate.
+  * @watermark: Minimum allowed availabe free space in RXF for transient state.
+  * @long_delay_timeouts: aging and idle timer values for each scenario
+  * in long delay state.
+  * @full_on_timeouts: timer values for each scenario in full on state.
+  */
+ struct iwl_sf_cfg_cmd {
+ 	__le32 state;
+ 	__le32 watermark[SF_TRANSIENT_STATES_NUMBER];
+ 	__le32 long_delay_timeouts[SF_NUM_SCENARIO][SF_NUM_TIMEOUT_TYPES];
+ 	__le32 full_on_timeouts[SF_NUM_SCENARIO][SF_NUM_TIMEOUT_TYPES];
+ } __packed; /* SF_CFG_API_S_VER_2 */
+ 
++>>>>>>> 86974bff066d (iwlwifi: mvm: fix endianity issues with Smart Fifo commands)
  #endif /* __fw_api_h__ */
* Unmerged path drivers/net/wireless/iwlwifi/mvm/sf.c
* Unmerged path drivers/net/wireless/iwlwifi/mvm/fw-api.h
* Unmerged path drivers/net/wireless/iwlwifi/mvm/sf.c
