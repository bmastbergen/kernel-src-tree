iommu/vt-d: Stop dmar_insert_dev_info() freeing domains on losing race

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Stop dmar_insert_dev_info() freeing domains on losing race (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 95.52%
commit-author David Woodhouse <David.Woodhouse@intel.com>
commit b718cd3d8412edaf02665d29b0cf5ef828675a45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/b718cd3d.failed

By moving this into get_domain_for_dev() we can make dmar_insert_dev_info()
suitable for use with "special" domains such as the si_domain, which
currently use domain_add_dev_info().

	Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
(cherry picked from commit b718cd3d8412edaf02665d29b0cf5ef828675a45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 2d7348365b6d,c1c564233768..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -2036,10 -2147,11 +2036,16 @@@ dmar_search_domain_by_dev_info(int segm
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static int dmar_insert_dev_info(int segment, int bus, int devfn,
 +				struct pci_dev *dev, struct dmar_domain **domp)
++=======
+ static struct dmar_domain *dmar_insert_dev_info(int segment, int bus, int devfn,
+ 						struct device *dev,
+ 						struct dmar_domain *domain)
++>>>>>>> b718cd3d8412 (iommu/vt-d: Stop dmar_insert_dev_info() freeing domains on losing race)
  {
- 	struct dmar_domain *found, *domain = *domp;
+ 	struct dmar_domain *found;
  	struct device_domain_info *info;
  	unsigned long flags;
  
@@@ -2063,19 -2175,17 +2069,30 @@@
  	if (found) {
  		spin_unlock_irqrestore(&device_domain_lock, flags);
  		free_devinfo_mem(info);
++<<<<<<< HEAD
 +		if (found != domain) {
 +			domain_exit(domain);
 +			*domp = found;
 +		}
 +	} else {
 +		list_add(&info->link, &domain->devices);
 +		list_add(&info->global, &device_domain_list);
 +		if (dev)
 +			dev->dev.archdata.iommu = info;
 +		spin_unlock_irqrestore(&device_domain_lock, flags);
++=======
+ 		/* Caller must free the original domain */
+ 		return found;
++>>>>>>> b718cd3d8412 (iommu/vt-d: Stop dmar_insert_dev_info() freeing domains on losing race)
  	}
  
- 	return 0;
+ 	list_add(&info->link, &domain->devices);
+ 	list_add(&info->global, &device_domain_list);
+ 	if (dev)
+ 		dev->archdata.iommu = info;
+ 	spin_unlock_irqrestore(&device_domain_lock, flags);
+ 
+ 	return domain;
  }
  
  /* domain is initialized */
@@@ -2139,16 -2250,13 +2157,19 @@@ static struct dmar_domain *get_domain_f
  	}
  
  found_domain:
++<<<<<<< HEAD
 +	if (dmar_insert_dev_info(segment, pdev->bus->number, pdev->devfn,
 +				 pdev, &domain) == 0)
 +		return domain;
++=======
+ 	domain = dmar_insert_dev_info(segment, pdev->bus->number, pdev->devfn,
+ 				      &pdev->dev, domain);
++>>>>>>> b718cd3d8412 (iommu/vt-d: Stop dmar_insert_dev_info() freeing domains on losing race)
  error:
- 	if (free)
+ 	if (free != domain)
  		domain_exit(free);
- 	/* recheck it here, maybe others set it */
- 	return find_domain(&pdev->dev);
+ 
+ 	return domain;
  }
  
  static int iommu_identity_mapping;
* Unmerged path drivers/iommu/intel-iommu.c
