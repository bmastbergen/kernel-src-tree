ACPI / hotplug: Fix potential race in acpi_bus_notify()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug: Fix potential race in acpi_bus_notify() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 93.20%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 78ea4639a7647f2fcc957c3a532bde49df9895c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/78ea4639.failed

There is a slight possibility for the ACPI device object pointed to
by adev in acpi_hotplug_notify_cb() to become invalid between the
acpi_bus_get_device() that it comes from and the subsequent dereference
of that pointer under get_device().  Namely, if acpi_scan_drop_device()
runs in parallel with acpi_hotplug_notify_cb(), acpi_device_del_work_fn()
queued up by it may delete the device object in question right after
a successful execution of acpi_bus_get_device() in acpi_bus_notify().

An analogous problem is present in acpi_bus_notify() where the device
pointer coming from acpi_bus_get_device() may become invalid before
it subsequent dereference in the "if" block.

To prevent that from happening, introduce a new function,
acpi_bus_get_acpi_device(), working analogously to acpi_bus_get_device()
except that it will grab a reference to the ACPI device object returned
by it and it will do that under the ACPICA's namespace mutex.  Then,
make both acpi_hotplug_notify_cb() and acpi_bus_notify() use
acpi_bus_get_acpi_device() instead of acpi_bus_get_device() so as to
ensure that the pointers used by them will not become stale at one
point.

In addition to that, introduce acpi_bus_put_acpi_device() as a wrapper
around put_device() to be used along with acpi_bus_get_acpi_device()
and make the (new) users of the latter use acpi_bus_put_acpi_device()
too.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 78ea4639a7647f2fcc957c3a532bde49df9895c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index b30a50799f84,59eba29a6066..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -285,124 -369,116 +285,133 @@@ static int acpi_scan_hot_remove(struct 
  	return 0;
  }
  
 -static int acpi_scan_device_not_present(struct acpi_device *adev)
 -{
 -	if (!acpi_device_enumerated(adev)) {
 -		dev_warn(&adev->dev, "Still not present\n");
 -		return -EALREADY;
 -	}
 -	acpi_bus_trim(adev);
 -	return 0;
 -}
 -
 -static int acpi_scan_device_check(struct acpi_device *adev)
 +void acpi_bus_device_eject(struct acpi_device *device, u32 ost_src)
  {
 +	acpi_handle handle = device->handle;
 +	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
  	int error;
  
 -	acpi_bus_get_status(adev);
 -	if (adev->status.present || adev->status.functional) {
 -		/*
 -		 * This function is only called for device objects for which
 -		 * matching scan handlers exist.  The only situation in which
 -		 * the scan handler is not attached to this device object yet
 -		 * is when the device has just appeared (either it wasn't
 -		 * present at all before or it was removed and then added
 -		 * again).
 -		 */
 -		if (adev->handler) {
 -			dev_warn(&adev->dev, "Already enumerated\n");
 -			return -EALREADY;
 -		}
 -		error = acpi_bus_scan(adev->handle);
 -		if (error) {
 -			dev_warn(&adev->dev, "Namespace scan failure\n");
 -			return error;
 -		}
 -		if (!adev->handler) {
 -			dev_warn(&adev->dev, "Enumeration failure\n");
 -			error = -ENODEV;
 -		}
 -	} else {
 -		error = acpi_scan_device_not_present(adev);
 +	lock_device_hotplug();
 +	mutex_lock(&acpi_scan_lock);
 +
 +	if (ost_src == ACPI_NOTIFY_EJECT_REQUEST)
 +		acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
 +					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
 +
 +	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
 +		kobject_uevent(&device->dev.kobj, KOBJ_OFFLINE);
 +
 +	error = acpi_scan_hot_remove(device);
 +	if (error == -EPERM) {
 +		goto err_support;
 +	} else if (error) {
 +		goto err_out;
  	}
 -	return error;
 +
 + out:
++<<<<<<< HEAD
 +	mutex_unlock(&acpi_scan_lock);
 +	unlock_device_hotplug();
 +	return;
 +
 + err_support:
 +	ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
 + err_out:
 +	acpi_evaluate_hotplug_ost(handle, ost_src, ost_code, NULL);
 +	goto out;
  }
  
 -static int acpi_scan_bus_check(struct acpi_device *adev)
 +static void acpi_scan_bus_device_check(acpi_handle handle, u32 ost_source)
  {
 -	struct acpi_scan_handler *handler = adev->handler;
 -	struct acpi_device *child;
 +	struct acpi_device *device = NULL;
 +	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
  	int error;
  
 -	acpi_bus_get_status(adev);
 -	if (!(adev->status.present || adev->status.functional)) {
 -		acpi_scan_device_not_present(adev);
 -		return 0;
 -	}
 -	if (handler && handler->hotplug.scan_dependent)
 -		return handler->hotplug.scan_dependent(adev);
 +	lock_device_hotplug();
 +	mutex_lock(&acpi_scan_lock);
  
 -	error = acpi_bus_scan(adev->handle);
 +	if (ost_source != ACPI_NOTIFY_BUS_CHECK) {
 +		acpi_bus_get_device(handle, &device);
 +		if (device) {
 +			dev_warn(&device->dev, "Attempt to re-insert\n");
 +			goto out;
 +		}
 +	}
 +	error = acpi_bus_scan(handle);
  	if (error) {
 -		dev_warn(&adev->dev, "Namespace scan failure\n");
 -		return error;
 +		acpi_handle_warn(handle, "Namespace scan failure\n");
 +		goto out;
  	}
 -	list_for_each_entry(child, &adev->children, node) {
 -		error = acpi_scan_bus_check(child);
 -		if (error)
 -			return error;
 +	error = acpi_bus_get_device(handle, &device);
 +	if (error) {
 +		acpi_handle_warn(handle, "Missing device node object\n");
 +		goto out;
  	}
 -	return 0;
 +	ost_code = ACPI_OST_SC_SUCCESS;
 +	if (device->handler && device->handler->hotplug.mode == AHM_CONTAINER)
 +		kobject_uevent(&device->dev.kobj, KOBJ_ONLINE);
 +
 + out:
 +	acpi_evaluate_hotplug_ost(handle, ost_source, ost_code, NULL);
++=======
++	acpi_evaluate_hotplug_ost(adev->handle, src, ost_code, NULL);
++	acpi_bus_put_acpi_device(adev);
++>>>>>>> 78ea4639a764 (ACPI / hotplug: Fix potential race in acpi_bus_notify())
 +	mutex_unlock(&acpi_scan_lock);
 +	unlock_device_hotplug();
  }
  
 -static void acpi_device_hotplug(void *data, u32 src)
 +static void acpi_scan_bus_check(void *context)
  {
 -	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
 -	struct acpi_device *adev = data;
 -	int error;
 +	acpi_scan_bus_device_check((acpi_handle)context,
 +				   ACPI_NOTIFY_BUS_CHECK);
 +}
  
 -	lock_device_hotplug();
 -	mutex_lock(&acpi_scan_lock);
++<<<<<<< HEAD
 +static void acpi_scan_device_check(void *context)
 +{
 +	acpi_scan_bus_device_check((acpi_handle)context,
 +				   ACPI_NOTIFY_DEVICE_CHECK);
 +}
  
 -	/*
 -	 * The device object's ACPI handle cannot become invalid as long as we
 -	 * are holding acpi_scan_lock, but it may have become invalid before
 -	 * that lock was acquired.
 -	 */
 -	if (adev->handle == INVALID_ACPI_HANDLE)
 -		goto out;
 +static void acpi_hotplug_unsupported(acpi_handle handle, u32 type)
 +{
 +	u32 ost_status;
  
 -	switch (src) {
++=======
++>>>>>>> 78ea4639a764 (ACPI / hotplug: Fix potential race in acpi_bus_notify())
 +	switch (type) {
  	case ACPI_NOTIFY_BUS_CHECK:
 -		error = acpi_scan_bus_check(adev);
 +		acpi_handle_debug(handle,
 +			"ACPI_NOTIFY_BUS_CHECK event: unsupported\n");
 +		ost_status = ACPI_OST_SC_INSERT_NOT_SUPPORTED;
  		break;
  	case ACPI_NOTIFY_DEVICE_CHECK:
 -		error = acpi_scan_device_check(adev);
 +		acpi_handle_debug(handle,
 +			"ACPI_NOTIFY_DEVICE_CHECK event: unsupported\n");
 +		ost_status = ACPI_OST_SC_INSERT_NOT_SUPPORTED;
  		break;
  	case ACPI_NOTIFY_EJECT_REQUEST:
 -	case ACPI_OST_EC_OSPM_EJECT:
 -		error = acpi_scan_hot_remove(adev);
 +		acpi_handle_debug(handle,
 +			"ACPI_NOTIFY_EJECT_REQUEST event: unsupported\n");
 +		ost_status = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
  		break;
  	default:
 -		error = -EINVAL;
 -		break;
 +		/* non-hotplug event; possibly handled by other handler */
 +		return;
  	}
 -	if (!error)
 -		ost_code = ACPI_OST_SC_SUCCESS;
++<<<<<<< HEAD
  
 - out:
 -	acpi_evaluate_hotplug_ost(adev->handle, src, ost_code, NULL);
 -	acpi_bus_put_acpi_device(adev);
 -	mutex_unlock(&acpi_scan_lock);
 -	unlock_device_hotplug();
 +	acpi_evaluate_hotplug_ost(handle, type, ost_status, NULL);
 +}
 +
 +/**
 + * acpi_bus_hot_remove_device: Hot-remove a device and its children.
 + * @context: Address of the ACPI device object to hot-remove.
 + */
 +static void acpi_bus_hot_remove_device(void *context)
 +{
 +	acpi_bus_device_eject(context, ACPI_NOTIFY_EJECT_REQUEST);
  }
  
  static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
@@@ -441,13 -509,18 +450,25 @@@
  		/* non-hotplug event; possibly handled by other handler */
  		return;
  	}
 +	status = acpi_os_hotplug_execute(callback, handle);
 +	if (ACPI_SUCCESS(status))
 +		return;
 +
++=======
+ 	adev = acpi_bus_get_acpi_device(handle);
+ 	if (!adev)
+ 		goto err_out;
+ 
+ 	status = acpi_hotplug_execute(acpi_device_hotplug, adev, type);
+ 	if (ACPI_SUCCESS(status))
+ 		return;
+ 
+ 	acpi_bus_put_acpi_device(adev);
+ 
++>>>>>>> 78ea4639a764 (ACPI / hotplug: Fix potential race in acpi_bus_notify())
   err_out:
 -	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
 +	acpi_evaluate_hotplug_ost(handle, type,
 +				  ACPI_OST_SC_NON_SPECIFIC_FAILURE, NULL);
  }
  
  static ssize_t real_power_state_show(struct device *dev,
@@@ -957,19 -1025,103 +978,25 @@@ struct bus_type acpi_bus_type = 
  	.uevent		= acpi_device_uevent,
  };
  
 -static void acpi_device_del(struct acpi_device *device)
 -{
 -	mutex_lock(&acpi_device_lock);
 -	if (device->parent)
 -		list_del(&device->node);
 -
 -	list_del(&device->wakeup_list);
 -	mutex_unlock(&acpi_device_lock);
 -
 -	acpi_power_add_remove_device(device, false);
 -	acpi_device_remove_files(device);
 -	if (device->remove)
 -		device->remove(device);
 -
 -	device_del(&device->dev);
 -}
 -
 -static LIST_HEAD(acpi_device_del_list);
 -static DEFINE_MUTEX(acpi_device_del_lock);
 -
 -static void acpi_device_del_work_fn(struct work_struct *work_not_used)
 -{
 -	for (;;) {
 -		struct acpi_device *adev;
 -
 -		mutex_lock(&acpi_device_del_lock);
 -
 -		if (list_empty(&acpi_device_del_list)) {
 -			mutex_unlock(&acpi_device_del_lock);
 -			break;
 -		}
 -		adev = list_first_entry(&acpi_device_del_list,
 -					struct acpi_device, del_list);
 -		list_del(&adev->del_list);
 -
 -		mutex_unlock(&acpi_device_del_lock);
 -
 -		acpi_device_del(adev);
 -		/*
 -		 * Drop references to all power resources that might have been
 -		 * used by the device.
 -		 */
 -		acpi_power_transition(adev, ACPI_STATE_D3_COLD);
 -		put_device(&adev->dev);
 -	}
 -}
 -
 -/**
 - * acpi_scan_drop_device - Drop an ACPI device object.
 - * @handle: Handle of an ACPI namespace node, not used.
 - * @context: Address of the ACPI device object to drop.
 - *
 - * This is invoked by acpi_ns_delete_node() during the removal of the ACPI
 - * namespace node the device object pointed to by @context is attached to.
 - *
 - * The unregistration is carried out asynchronously to avoid running
 - * acpi_device_del() under the ACPICA's namespace mutex and the list is used to
 - * ensure the correct ordering (the device objects must be unregistered in the
 - * same order in which the corresponding namespace nodes are deleted).
 - */
 -static void acpi_scan_drop_device(acpi_handle handle, void *context)
 +static void acpi_bus_data_handler(acpi_handle handle, void *context)
  {
 -	static DECLARE_WORK(work, acpi_device_del_work_fn);
 -	struct acpi_device *adev = context;
 -
 -	mutex_lock(&acpi_device_del_lock);
 -
 -	/*
 -	 * Use the ACPI hotplug workqueue which is ordered, so this work item
 -	 * won't run after any hotplug work items submitted subsequently.  That
 -	 * prevents attempts to register device objects identical to those being
 -	 * deleted from happening concurrently (such attempts result from
 -	 * hotplug events handled via the ACPI hotplug workqueue).  It also will
 -	 * run after all of the work items submitted previosuly, which helps
 -	 * those work items to ensure that they are not accessing stale device
 -	 * objects.
 -	 */
 -	if (list_empty(&acpi_device_del_list))
 -		acpi_queue_hotplug_work(&work);
 -
 -	list_add_tail(&adev->del_list, &acpi_device_del_list);
 -	/* Make acpi_ns_validate_handle() return NULL for this handle. */
 -	adev->handle = INVALID_ACPI_HANDLE;
 -
 -	mutex_unlock(&acpi_device_del_lock);
 +	/* Intentionally empty. */
  }
  
- int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device)
+ static int acpi_get_device_data(acpi_handle handle, struct acpi_device **device,
+ 				void (*callback)(void *))
  {
  	acpi_status status;
  
  	if (!device)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	status = acpi_get_data(handle, acpi_bus_data_handler, (void **)device);
++=======
+ 	status = acpi_get_data_full(handle, acpi_scan_drop_device,
+ 				    (void **)device, callback);
++>>>>>>> 78ea4639a764 (ACPI / hotplug: Fix potential race in acpi_bus_notify())
  	if (ACPI_FAILURE(status) || !*device) {
  		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No context for object [%p]\n",
  				  handle));
diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index f7cd8718b651..da0df04bc0e5 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -433,7 +433,7 @@ int acpi_bus_receive_event(struct acpi_bus_event *event)
  */
 static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 {
-	struct acpi_device *device = NULL;
+	struct acpi_device *device;
 	struct acpi_driver *driver;
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Notification %#02x to handle %p\n",
@@ -480,12 +480,14 @@ static void acpi_bus_notify(acpi_handle handle, u32 type, void *data)
 		break;
 	}
 
-	acpi_bus_get_device(handle, &device);
+	device = acpi_bus_get_acpi_device(handle);
 	if (device) {
 		driver = device->driver;
 		if (driver && driver->ops.notify &&
 		    (driver->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS))
 			driver->ops.notify(device, type);
+
+		acpi_bus_put_acpi_device(device);
 	}
 }
 
* Unmerged path drivers/acpi/scan.c
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
index f5d6e1e4030e..059a03622cfb 100644
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -357,6 +357,8 @@ extern int unregister_acpi_notifier(struct notifier_block *);
  */
 
 int acpi_bus_get_device(acpi_handle handle, struct acpi_device **device);
+struct acpi_device *acpi_bus_get_acpi_device(acpi_handle handle);
+void acpi_bus_put_acpi_device(struct acpi_device *adev);
 acpi_status acpi_bus_get_status_handle(acpi_handle handle,
 				       unsigned long long *sta);
 int acpi_bus_get_status(struct acpi_device *device);
