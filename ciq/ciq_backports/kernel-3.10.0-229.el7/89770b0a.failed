net: introduce reciprocal_scale helper and convert users

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] introduce reciprocal_scale helper and convert users (Jiri Benc) [1140665]
Rebuild_FUZZ: 95.33%
commit-author Daniel Borkmann <dborkman@redhat.com>
commit 89770b0a69ee0e0e5e99c722192d535115f73778
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/89770b0a.failed

As David Laight suggests, we shouldn't necessarily call this
reciprocal_divide() when users didn't requested a reciprocal_value();
lets keep the basic idea and call it reciprocal_scale(). More
background information on this topic can be found in [1].

Joint work with Hannes Frederic Sowa.

  [1] http://homepage.cs.uiowa.edu/~jones/bcd/divide.html

	Suggested-by: David Laight <david.laight@aculab.com>
	Cc: Jakub Zawadzki <darkjames-ws@darkjames.pl>
	Cc: Eric Dumazet <eric.dumazet@gmail.com>
	Cc: linux-kernel@vger.kernel.org
	Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 89770b0a69ee0e0e5e99c722192d535115f73778)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/kernel.h
diff --cc include/linux/kernel.h
index 8f8582c55584,03d8a6b0e2e8..000000000000
--- a/include/linux/kernel.h
+++ b/include/linux/kernel.h
@@@ -193,7 -193,27 +193,31 @@@ extern int _cond_resched(void)
  		(__x < 0) ? -__x : __x;		\
  	})
  
++<<<<<<< HEAD
 +#if defined(CONFIG_PROVE_LOCKING) || defined(CONFIG_DEBUG_ATOMIC_SLEEP)
++=======
+ /**
+  * reciprocal_scale - "scale" a value into range [0, ep_ro)
+  * @val: value
+  * @ep_ro: right open interval endpoint
+  *
+  * Perform a "reciprocal multiplication" in order to "scale" a value into
+  * range [0, ep_ro), where the upper interval endpoint is right-open.
+  * This is useful, e.g. for accessing a index of an array containing
+  * ep_ro elements, for example. Think of it as sort of modulus, only that
+  * the result isn't that of modulo. ;) Note that if initial input is a
+  * small value, then result will return 0.
+  *
+  * Return: a result based on val in interval [0, ep_ro).
+  */
+ static inline u32 reciprocal_scale(u32 val, u32 ep_ro)
+ {
+ 	return (u32)(((u64) val * ep_ro) >> 32);
+ }
+ 
+ #if defined(CONFIG_MMU) && \
+ 	(defined(CONFIG_PROVE_LOCKING) || defined(CONFIG_DEBUG_ATOMIC_SLEEP))
++>>>>>>> 89770b0a69ee (net: introduce reciprocal_scale helper and convert users)
  void might_fault(void);
  #else
  static inline void might_fault(void) { }
* Unmerged path include/linux/kernel.h
diff --git a/include/net/codel.h b/include/net/codel.h
index 389cf621161d..33002fc669f8 100644
--- a/include/net/codel.h
+++ b/include/net/codel.h
@@ -46,7 +46,6 @@
 #include <linux/skbuff.h>
 #include <net/pkt_sched.h>
 #include <net/inet_ecn.h>
-#include <linux/reciprocal_div.h>
 
 /* Controlling Queue Delay (CoDel) algorithm
  * =========================================
@@ -200,10 +199,9 @@ static codel_time_t codel_control_law(codel_time_t t,
 				      codel_time_t interval,
 				      u32 rec_inv_sqrt)
 {
-	return t + reciprocal_divide(interval, rec_inv_sqrt << REC_INV_SQRT_SHIFT);
+	return t + reciprocal_scale(interval, rec_inv_sqrt << REC_INV_SQRT_SHIFT);
 }
 
-
 static bool codel_should_drop(const struct sk_buff *skb,
 			      struct Qdisc *sch,
 			      struct codel_vars *vars,
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 2b60ee12324a..77c5d165af83 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -88,7 +88,6 @@
 #include <linux/virtio_net.h>
 #include <linux/errqueue.h>
 #include <linux/net_tstamp.h>
-#include <linux/reciprocal_div.h>
 #include <linux/percpu.h>
 #ifdef CONFIG_INET
 #include <net/inet_common.h>
@@ -1205,7 +1204,7 @@ static unsigned int fanout_demux_hash(struct packet_fanout *f,
 				      struct sk_buff *skb,
 				      unsigned int num)
 {
-	return reciprocal_divide(skb->rxhash, num);
+	return reciprocal_scale(skb->rxhash, num);
 }
 
 static unsigned int fanout_demux_lb(struct packet_fanout *f,
