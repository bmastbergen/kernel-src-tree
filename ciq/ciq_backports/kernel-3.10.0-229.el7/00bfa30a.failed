NFS: Create a common pgio_alloc and pgio_release function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Anna Schumaker <Anna.Schumaker@netapp.com>
commit 00bfa30abe86982ce1929e9cabd703e5546106bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/00bfa30a.failed

These functions are identical for the read and write paths so they can
be combined.

	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 00bfa30abe86982ce1929e9cabd703e5546106bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/internal.h
#	fs/nfs/read.c
#	fs/nfs/write.c
diff --cc fs/nfs/internal.h
index 96bd22580dbf,5ddc142c5062..000000000000
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@@ -404,7 -409,6 +406,10 @@@ extern void nfs_read_prepare(struct rpc
  extern int nfs_generic_pagein(struct nfs_pageio_descriptor *desc,
  			      struct nfs_pgio_header *hdr);
  extern void nfs_pageio_reset_read_mds(struct nfs_pageio_descriptor *pgio);
++<<<<<<< HEAD
 +extern void nfs_readdata_release(struct nfs_read_data *rdata);
++=======
++>>>>>>> 00bfa30abe86 (NFS: Create a common pgio_alloc and pgio_release function)
  
  /* super.c */
  void nfs_clone_super(struct super_block *, struct nfs_mount_info *);
@@@ -426,10 -430,9 +431,13 @@@ extern void nfs_writehdr_free(struct nf
  extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
  			     struct nfs_pgio_header *hdr);
  extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);
++<<<<<<< HEAD
 +extern void nfs_writedata_release(struct nfs_write_data *wdata);
++=======
++>>>>>>> 00bfa30abe86 (NFS: Create a common pgio_alloc and pgio_release function)
  extern void nfs_commit_free(struct nfs_commit_data *p);
  extern int nfs_initiate_write(struct rpc_clnt *clnt,
 -			      struct nfs_pgio_data *data,
 +			      struct nfs_write_data *data,
  			      const struct rpc_call_ops *call_ops,
  			      int how, int flags);
  extern void nfs_write_prepare(struct rpc_task *task, void *calldata);
diff --cc fs/nfs/read.c
index 473bba35a2cb,ab4c1a5b5fbd..000000000000
--- a/fs/nfs/read.c
+++ b/fs/nfs/read.c
@@@ -51,60 -51,14 +51,66 @@@ struct nfs_read_header *nfs_readhdr_all
  }
  EXPORT_SYMBOL_GPL(nfs_readhdr_alloc);
  
++<<<<<<< HEAD
 +static struct nfs_read_data *nfs_readdata_alloc(struct nfs_pgio_header *hdr,
 +						unsigned int pagecount)
 +{
 +	struct nfs_read_data *data, *prealloc;
 +
 +	prealloc = &container_of(hdr, struct nfs_read_header, header)->rpc_data;
 +	if (prealloc->header == NULL)
 +		data = prealloc;
 +	else
 +		data = kzalloc(sizeof(*data), GFP_KERNEL);
 +	if (!data)
 +		goto out;
 +
 +	if (nfs_pgarray_set(&data->pages, pagecount)) {
 +		data->header = hdr;
 +		atomic_inc(&hdr->refcnt);
 +	} else {
 +		if (data != prealloc)
 +			kfree(data);
 +		data = NULL;
 +	}
 +out:
 +	return data;
 +}
 +
++=======
++>>>>>>> 00bfa30abe86 (NFS: Create a common pgio_alloc and pgio_release function)
  void nfs_readhdr_free(struct nfs_pgio_header *hdr)
  {
 -	struct nfs_rw_header *rhdr = container_of(hdr, struct nfs_rw_header, header);
 +	struct nfs_read_header *rhdr = container_of(hdr, struct nfs_read_header, header);
  
  	kmem_cache_free(nfs_rdata_cachep, rhdr);
  }
  EXPORT_SYMBOL_GPL(nfs_readhdr_free);
  
++<<<<<<< HEAD
 +void nfs_readdata_release(struct nfs_read_data *rdata)
 +{
 +	struct nfs_pgio_header *hdr = rdata->header;
 +	struct nfs_read_header *read_header = container_of(hdr, struct nfs_read_header, header);
 +
 +	put_nfs_open_context(rdata->args.context);
 +	if (rdata->pages.pagevec != rdata->pages.page_array)
 +		kfree(rdata->pages.pagevec);
 +	if (rdata == &read_header->rpc_data) {
 +		rdata->header = NULL;
 +		rdata = NULL;
 +	}
 +	if (atomic_dec_and_test(&hdr->refcnt))
 +		hdr->completion_ops->completion(hdr);
 +	/* Note: we only free the rpc_task after callbacks are done.
 +	 * See the comment in rpc_free_task() for why
 +	 */
 +	kfree(rdata);
 +}
 +EXPORT_SYMBOL_GPL(nfs_readdata_release);
 +
++=======
++>>>>>>> 00bfa30abe86 (NFS: Create a common pgio_alloc and pgio_release function)
  static
  int nfs_return_empty_page(struct page *page)
  {
@@@ -324,10 -278,10 +330,10 @@@ static void nfs_pagein_error(struct nfs
  {
  	set_bit(NFS_IOHDR_REDO, &hdr->flags);
  	while (!list_empty(&hdr->rpc_list)) {
 -		struct nfs_pgio_data *data = list_first_entry(&hdr->rpc_list,
 -				struct nfs_pgio_data, list);
 +		struct nfs_read_data *data = list_first_entry(&hdr->rpc_list,
 +				struct nfs_read_data, list);
  		list_del(&data->list);
- 		nfs_readdata_release(data);
+ 		nfs_pgio_data_release(data);
  	}
  	desc->pg_completion_ops->error_cleanup(&desc->pg_list);
  }
@@@ -382,10 -336,10 +388,10 @@@ static int nfs_pagein_one(struct nfs_pa
  {
  	struct nfs_page		*req;
  	struct page		**pages;
 -	struct nfs_pgio_data	*data;
 +	struct nfs_read_data    *data;
  	struct list_head *head = &desc->pg_list;
  
- 	data = nfs_readdata_alloc(hdr, nfs_page_array_len(desc->pg_base,
+ 	data = nfs_pgio_data_alloc(hdr, nfs_page_array_len(desc->pg_base,
  							  desc->pg_count));
  	if (!data) {
  		nfs_pagein_error(desc, hdr);
diff --cc fs/nfs/write.c
index f9fc82c305d1,0dc4d6a28bd0..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -88,59 -87,13 +88,65 @@@ struct nfs_write_header *nfs_writehdr_a
  }
  EXPORT_SYMBOL_GPL(nfs_writehdr_alloc);
  
++<<<<<<< HEAD
 +static struct nfs_write_data *nfs_writedata_alloc(struct nfs_pgio_header *hdr,
 +						  unsigned int pagecount)
 +{
 +	struct nfs_write_data *data, *prealloc;
 +
 +	prealloc = &container_of(hdr, struct nfs_write_header, header)->rpc_data;
 +	if (prealloc->header == NULL)
 +		data = prealloc;
 +	else
 +		data = kzalloc(sizeof(*data), GFP_KERNEL);
 +	if (!data)
 +		goto out;
 +
 +	if (nfs_pgarray_set(&data->pages, pagecount)) {
 +		data->header = hdr;
 +		atomic_inc(&hdr->refcnt);
 +	} else {
 +		if (data != prealloc)
 +			kfree(data);
 +		data = NULL;
 +	}
 +out:
 +	return data;
 +}
 +
++=======
++>>>>>>> 00bfa30abe86 (NFS: Create a common pgio_alloc and pgio_release function)
  void nfs_writehdr_free(struct nfs_pgio_header *hdr)
  {
 -	struct nfs_rw_header *whdr = container_of(hdr, struct nfs_rw_header, header);
 +	struct nfs_write_header *whdr = container_of(hdr, struct nfs_write_header, header);
  	mempool_free(whdr, nfs_wdata_mempool);
  }
  EXPORT_SYMBOL_GPL(nfs_writehdr_free);
  
++<<<<<<< HEAD
 +void nfs_writedata_release(struct nfs_write_data *wdata)
 +{
 +	struct nfs_pgio_header *hdr = wdata->header;
 +	struct nfs_write_header *write_header = container_of(hdr, struct nfs_write_header, header);
 +
 +	put_nfs_open_context(wdata->args.context);
 +	if (wdata->pages.pagevec != wdata->pages.page_array)
 +		kfree(wdata->pages.pagevec);
 +	if (wdata == &write_header->rpc_data) {
 +		wdata->header = NULL;
 +		wdata = NULL;
 +	}
 +	if (atomic_dec_and_test(&hdr->refcnt))
 +		hdr->completion_ops->completion(hdr);
 +	/* Note: we only free the rpc_task after callbacks are done.
 +	 * See the comment in rpc_free_task() for why
 +	 */
 +	kfree(wdata);
 +}
 +EXPORT_SYMBOL_GPL(nfs_writedata_release);
 +
++=======
++>>>>>>> 00bfa30abe86 (NFS: Create a common pgio_alloc and pgio_release function)
  static void nfs_context_set_write_error(struct nfs_open_context *ctx, int error)
  {
  	ctx->error = error;
@@@ -1146,10 -1097,10 +1152,10 @@@ static void nfs_flush_error(struct nfs_
  {
  	set_bit(NFS_IOHDR_REDO, &hdr->flags);
  	while (!list_empty(&hdr->rpc_list)) {
 -		struct nfs_pgio_data *data = list_first_entry(&hdr->rpc_list,
 -				struct nfs_pgio_data, list);
 +		struct nfs_write_data *data = list_first_entry(&hdr->rpc_list,
 +				struct nfs_write_data, list);
  		list_del(&data->list);
- 		nfs_writedata_release(data);
+ 		nfs_pgio_data_release(data);
  	}
  	desc->pg_completion_ops->error_cleanup(&desc->pg_list);
  }
* Unmerged path fs/nfs/internal.h
diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c
index 2ffebf2081ce..a98ccf722d7b 100644
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@ -26,7 +26,7 @@
 
 static struct kmem_cache *nfs_page_cachep;
 
-bool nfs_pgarray_set(struct nfs_page_array *p, unsigned int pagecount)
+static bool nfs_pgarray_set(struct nfs_page_array *p, unsigned int pagecount)
 {
 	p->npages = pagecount;
 	if (pagecount <= ARRAY_SIZE(p->page_array))
@@ -295,6 +295,66 @@ bool nfs_generic_pg_test(struct nfs_pageio_descriptor *desc, struct nfs_page *pr
 }
 EXPORT_SYMBOL_GPL(nfs_generic_pg_test);
 
+static inline struct nfs_rw_header *NFS_RW_HEADER(struct nfs_pgio_header *hdr)
+{
+	return container_of(hdr, struct nfs_rw_header, header);
+}
+
+/**
+ * nfs_pgio_data_alloc - Allocate pageio data
+ * @hdr: The header making a request
+ * @pagecount: Number of pages to create
+ */
+struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *hdr,
+					  unsigned int pagecount)
+{
+	struct nfs_pgio_data *data, *prealloc;
+
+	prealloc = &NFS_RW_HEADER(hdr)->rpc_data;
+	if (prealloc->header == NULL)
+		data = prealloc;
+	else
+		data = kzalloc(sizeof(*data), GFP_KERNEL);
+	if (!data)
+		goto out;
+
+	if (nfs_pgarray_set(&data->pages, pagecount)) {
+		data->header = hdr;
+		atomic_inc(&hdr->refcnt);
+	} else {
+		if (data != prealloc)
+			kfree(data);
+		data = NULL;
+	}
+out:
+	return data;
+}
+
+/**
+ * nfs_pgio_data_release - Properly free pageio data
+ * @data: The data to release
+ */
+void nfs_pgio_data_release(struct nfs_pgio_data *data)
+{
+	struct nfs_pgio_header *hdr = data->header;
+	struct nfs_rw_header *pageio_header = NFS_RW_HEADER(hdr);
+
+	put_nfs_open_context(data->args.context);
+	if (data->pages.pagevec != data->pages.page_array)
+		kfree(data->pages.pagevec);
+	if (data == &pageio_header->rpc_data) {
+		data->header = NULL;
+		data = NULL;
+	}
+	if (atomic_dec_and_test(&hdr->refcnt))
+		hdr->completion_ops->completion(hdr);
+	/* Note: we only free the rpc_task after callbacks are done.
+	 * See the comment in rpc_free_task() for why
+	 */
+	kfree(data);
+}
+EXPORT_SYMBOL_GPL(nfs_pgio_data_release);
+
 /**
  * nfs_pageio_init - initialise a page io descriptor
  * @desc: pointer to descriptor
diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c
index 3d5bc2baafd1..87270e1236e7 100644
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@ -1536,7 +1536,7 @@ pnfs_write_through_mds(struct nfs_pageio_descriptor *desc,
 		nfs_pageio_reset_write_mds(desc);
 		desc->pg_recoalesce = 1;
 	}
-	nfs_writedata_release(data);
+	nfs_pgio_data_release(data);
 }
 
 static enum pnfs_try_status
@@ -1691,7 +1691,7 @@ pnfs_read_through_mds(struct nfs_pageio_descriptor *desc,
 		nfs_pageio_reset_read_mds(desc);
 		desc->pg_recoalesce = 1;
 	}
-	nfs_readdata_release(data);
+	nfs_pgio_data_release(data);
 }
 
 /*
* Unmerged path fs/nfs/read.c
* Unmerged path fs/nfs/write.c
