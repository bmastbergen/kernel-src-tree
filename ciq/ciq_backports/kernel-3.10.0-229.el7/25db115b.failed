ACPI: Introduce acpi_set_device_status()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] Introduce acpi_set_device_status() (Myron Stowe) [1128632]
Rebuild_FUZZ: 91.89%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 25db115b0bf72acfdf8a339fa8e37d8b895214d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/25db115b.failed

Introduce a static inline function for setting the status field
of struct acpi_device on the basis of a supplied u32 number,
acpi_set_device_status(), and use it instead of the horrible
horrible STRUCT_TO_INT() macro wherever applicable.  Having done
that, drop STRUCT_TO_INT() (and pretend that it has never existed).

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 25db115b0bf72acfdf8a339fa8e37d8b895214d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index 2bbdeee33be4,cf773c918102..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -1901,6 -1926,11 +1900,14 @@@ static acpi_status acpi_bus_device_atta
  	if (acpi_bus_get_device(handle, &device))
  		return AE_CTRL_DEPTH;
  
++<<<<<<< HEAD
++=======
+ 	acpi_set_device_status(device, sta);
+ 	/* Skip devices that are not present. */
+ 	if (!acpi_device_is_present(device))
+ 		goto err;
+ 
++>>>>>>> 25db115b0bf7 (ACPI: Introduce acpi_set_device_status())
  	if (device->handler)
  		return AE_OK;
  
diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c
index 8509c721cb57..5e1c127e3bf0 100644
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@ -52,9 +52,6 @@ struct acpi_device *acpi_root;
 struct proc_dir_entry *acpi_root_dir;
 EXPORT_SYMBOL(acpi_root_dir);
 
-#define STRUCT_TO_INT(s)	(*((int*)&s))
-
-
 #ifdef CONFIG_X86
 static int set_copy_dsdt(const struct dmi_system_id *id)
 {
@@ -115,18 +112,16 @@ int acpi_bus_get_status(struct acpi_device *device)
 	if (ACPI_FAILURE(status))
 		return -ENODEV;
 
-	STRUCT_TO_INT(device->status) = (int) sta;
+	acpi_set_device_status(device, sta);
 
 	if (device->status.functional && !device->status.present) {
 		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]: "
 		       "functional but not present;\n",
-			device->pnp.bus_id,
-			(u32) STRUCT_TO_INT(device->status)));
+			device->pnp.bus_id, (u32)sta));
 	}
 
 	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] status [%08x]\n",
-			  device->pnp.bus_id,
-			  (u32) STRUCT_TO_INT(device->status)));
+			  device->pnp.bus_id, (u32)sta));
 	return 0;
 }
 EXPORT_SYMBOL(acpi_bus_get_status);
* Unmerged path drivers/acpi/scan.c
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
index be0290eb08d8..24524158571c 100644
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -320,6 +320,11 @@ static inline void *acpi_driver_data(struct acpi_device *d)
 #define to_acpi_device(d)	container_of(d, struct acpi_device, dev)
 #define to_acpi_driver(d)	container_of(d, struct acpi_driver, drv)
 
+static inline void acpi_set_device_status(struct acpi_device *adev, u32 sta)
+{
+	*((u32 *)&adev->status) = sta;
+}
+
 /* acpi_device.dev.bus == &acpi_bus_type */
 extern struct bus_type acpi_bus_type;
 
