cpufreq: move freq change notifications to cpufreq core

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] move freq change notifications to cpufreq core (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 91.09%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit d4019f0a92ab802f385cc9c8ad3ab7b5449712cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d4019f0a.failed

Most of the drivers do following in their ->target_index() routines:

	struct cpufreq_freqs freqs;
	freqs.old = old freq...
	freqs.new = new freq...

	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);

	/* Change rate here */

	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);

This is replicated over all cpufreq drivers today and there doesn't exists a
good enough reason why this shouldn't be moved to cpufreq core instead.

There are few special cases though, like exynos5440, which doesn't do everything
on the call to ->target_index() routine and call some kind of bottom halves for
doing this work, work/tasklet/etc..

They may continue doing notification from their own code as flag:
CPUFREQ_ASYNC_NOTIFICATION is already set for them.

All drivers are also modified in this patch to avoid breaking 'git bisect', as
double notification would happen otherwise.

	Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
	Acked-by: Jesper Nilsson <jesper.nilsson@axis.com>
	Acked-by: Linus Walleij <linus.walleij@linaro.org>
	Acked-by: Russell King <linux@arm.linux.org.uk>
	Acked-by: Stephen Warren <swarren@nvidia.com>
	Tested-by: Andrew Lunn <andrew@lunn.ch>
	Tested-by: Nicolas Pitre <nicolas.pitre@linaro.org>
	Reviewed-by: Lan Tianyu <tianyu.lan@intel.com>
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit d4019f0a92ab802f385cc9c8ad3ab7b5449712cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/acpi-cpufreq.c
#	drivers/cpufreq/arm_big_little.c
#	drivers/cpufreq/at32ap-cpufreq.c
#	drivers/cpufreq/blackfin-cpufreq.c
#	drivers/cpufreq/cpufreq-cpu0.c
#	drivers/cpufreq/cpufreq.c
#	drivers/cpufreq/cris-artpec3-cpufreq.c
#	drivers/cpufreq/cris-etraxfs-cpufreq.c
#	drivers/cpufreq/davinci-cpufreq.c
#	drivers/cpufreq/dbx500-cpufreq.c
#	drivers/cpufreq/e_powersaver.c
#	drivers/cpufreq/elanfreq.c
#	drivers/cpufreq/exynos-cpufreq.c
#	drivers/cpufreq/imx6q-cpufreq.c
#	drivers/cpufreq/kirkwood-cpufreq.c
#	drivers/cpufreq/loongson2_cpufreq.c
#	drivers/cpufreq/maple-cpufreq.c
#	drivers/cpufreq/omap-cpufreq.c
#	drivers/cpufreq/p4-clockmod.c
#	drivers/cpufreq/pasemi-cpufreq.c
#	drivers/cpufreq/pmac32-cpufreq.c
#	drivers/cpufreq/pmac64-cpufreq.c
#	drivers/cpufreq/ppc-corenet-cpufreq.c
#	drivers/cpufreq/ppc_cbe_cpufreq.c
#	drivers/cpufreq/pxa2xx-cpufreq.c
#	drivers/cpufreq/pxa3xx-cpufreq.c
#	drivers/cpufreq/s3c64xx-cpufreq.c
#	drivers/cpufreq/s5pv210-cpufreq.c
#	drivers/cpufreq/sa1100-cpufreq.c
#	drivers/cpufreq/sa1110-cpufreq.c
#	drivers/cpufreq/sc520_freq.c
#	drivers/cpufreq/spear-cpufreq.c
#	drivers/cpufreq/speedstep-centrino.c
#	drivers/cpufreq/speedstep-ich.c
#	drivers/cpufreq/speedstep-smi.c
#	drivers/cpufreq/tegra-cpufreq.c
diff --cc drivers/cpufreq/acpi-cpufreq.c
index dbe16c760bb8,3c060dd50637..000000000000
--- a/drivers/cpufreq/acpi-cpufreq.c
+++ b/drivers/cpufreq/acpi-cpufreq.c
@@@ -429,14 -428,10 +429,16 @@@ static int acpi_cpufreq_target(struct c
  {
  	struct acpi_cpufreq_data *data = per_cpu(acfreq_data, policy->cpu);
  	struct acpi_processor_performance *perf;
- 	struct cpufreq_freqs freqs;
  	struct drv_cmd cmd;
 +	unsigned int next_state = 0; /* Index into freq_table */
  	unsigned int next_perf_state = 0; /* Index into perf table */
  	int result = 0;
  
++<<<<<<< HEAD
 +	pr_debug("acpi_cpufreq_target %d (%d)\n", target_freq, policy->cpu);
 +
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	if (unlikely(data == NULL ||
  	     data->acpi_data == NULL || data->freq_table == NULL)) {
  		return -ENODEV;
@@@ -493,10 -479,6 +495,13 @@@
  	else
  		cmd.mask = cpumask_of(policy->cpu);
  
++<<<<<<< HEAD
 +	freqs.old = perf->states[perf->state].core_frequency * 1000;
 +	freqs.new = data->freq_table[next_state].frequency;
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	drv_write(&cmd);
  
  	if (acpi_pstate_strict) {
diff --cc drivers/cpufreq/arm_big_little.c
index 5d7f53fcd6f5,5519933813ea..000000000000
--- a/drivers/cpufreq/arm_big_little.c
+++ b/drivers/cpufreq/arm_big_little.c
@@@ -33,65 -35,260 +33,86 @@@
  #include "arm_big_little.h"
  
  /* Currently we support only two clusters */
 -#define A15_CLUSTER	0
 -#define A7_CLUSTER	1
  #define MAX_CLUSTERS	2
  
 -#ifdef CONFIG_BL_SWITCHER
 -static bool bL_switching_enabled;
 -#define is_bL_switching_enabled()	bL_switching_enabled
 -#define set_switching_enabled(x)	(bL_switching_enabled = (x))
 -#else
 -#define is_bL_switching_enabled()	false
 -#define set_switching_enabled(x)	do { } while (0)
 -#endif
 -
 -#define ACTUAL_FREQ(cluster, freq)  ((cluster == A7_CLUSTER) ? freq << 1 : freq)
 -#define VIRT_FREQ(cluster, freq)    ((cluster == A7_CLUSTER) ? freq >> 1 : freq)
 -
  static struct cpufreq_arm_bL_ops *arm_bL_ops;
  static struct clk *clk[MAX_CLUSTERS];
 -static struct cpufreq_frequency_table *freq_table[MAX_CLUSTERS + 1];
 -static atomic_t cluster_usage[MAX_CLUSTERS + 1];
 -
 -static unsigned int clk_big_min;	/* (Big) clock frequencies */
 -static unsigned int clk_little_max;	/* Maximum clock frequency (Little) */
 -
 -static DEFINE_PER_CPU(unsigned int, physical_cluster);
 -static DEFINE_PER_CPU(unsigned int, cpu_last_req_freq);
 -
 -static struct mutex cluster_lock[MAX_CLUSTERS];
 -
 -static inline int raw_cpu_to_cluster(int cpu)
 -{
 -	return topology_physical_package_id(cpu);
 -}
 -
 -static inline int cpu_to_cluster(int cpu)
 -{
 -	return is_bL_switching_enabled() ?
 -		MAX_CLUSTERS : raw_cpu_to_cluster(cpu);
 -}
 -
 -static unsigned int find_cluster_maxfreq(int cluster)
 -{
 -	int j;
 -	u32 max_freq = 0, cpu_freq;
 -
 -	for_each_online_cpu(j) {
 -		cpu_freq = per_cpu(cpu_last_req_freq, j);
 -
 -		if ((cluster == per_cpu(physical_cluster, j)) &&
 -				(max_freq < cpu_freq))
 -			max_freq = cpu_freq;
 -	}
 -
 -	pr_debug("%s: cluster: %d, max freq: %d\n", __func__, cluster,
 -			max_freq);
 +static struct cpufreq_frequency_table *freq_table[MAX_CLUSTERS];
 +static atomic_t cluster_usage[MAX_CLUSTERS] = {ATOMIC_INIT(0), ATOMIC_INIT(0)};
  
 -	return max_freq;
 -}
 -
 -static unsigned int clk_get_cpu_rate(unsigned int cpu)
 +static unsigned int bL_cpufreq_get(unsigned int cpu)
  {
 -	u32 cur_cluster = per_cpu(physical_cluster, cpu);
 -	u32 rate = clk_get_rate(clk[cur_cluster]) / 1000;
 -
 -	/* For switcher we use virtual A7 clock rates */
 -	if (is_bL_switching_enabled())
 -		rate = VIRT_FREQ(cur_cluster, rate);
 +	u32 cur_cluster = cpu_to_cluster(cpu);
  
 -	pr_debug("%s: cpu: %d, cluster: %d, freq: %u\n", __func__, cpu,
 -			cur_cluster, rate);
 -
 -	return rate;
 +	return clk_get_rate(clk[cur_cluster]) / 1000;
  }
  
 -static unsigned int bL_cpufreq_get_rate(unsigned int cpu)
 +/* Validate policy frequency range */
 +static int bL_cpufreq_verify_policy(struct cpufreq_policy *policy)
  {
 -	if (is_bL_switching_enabled()) {
 -		pr_debug("%s: freq: %d\n", __func__, per_cpu(cpu_last_req_freq,
 -					cpu));
 +	u32 cur_cluster = cpu_to_cluster(policy->cpu);
  
 -		return per_cpu(cpu_last_req_freq, cpu);
 -	} else {
 -		return clk_get_cpu_rate(cpu);
 -	}
 +	return cpufreq_frequency_table_verify(policy, freq_table[cur_cluster]);
  }
  
 -static unsigned int
 -bL_cpufreq_set_rate(u32 cpu, u32 old_cluster, u32 new_cluster, u32 rate)
 +/* Set clock frequency */
 +static int bL_cpufreq_set_target(struct cpufreq_policy *policy,
 +		unsigned int target_freq, unsigned int relation)
  {
 -	u32 new_rate, prev_rate;
 -	int ret;
 -	bool bLs = is_bL_switching_enabled();
++<<<<<<< HEAD
 +	struct cpufreq_freqs freqs;
 +	u32 cpu = policy->cpu, freq_tab_idx, cur_cluster;
 +	int ret = 0;
++=======
++	u32 cpu = policy->cpu, cur_cluster, new_cluster, actual_cluster;
++	unsigned int freqs_new;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
 -	mutex_lock(&cluster_lock[new_cluster]);
 +	cur_cluster = cpu_to_cluster(policy->cpu);
  
 -	if (bLs) {
 -		prev_rate = per_cpu(cpu_last_req_freq, cpu);
 -		per_cpu(cpu_last_req_freq, cpu) = rate;
 -		per_cpu(physical_cluster, cpu) = new_cluster;
++<<<<<<< HEAD
 +	freqs.old = bL_cpufreq_get(policy->cpu);
  
 -		new_rate = find_cluster_maxfreq(new_cluster);
 -		new_rate = ACTUAL_FREQ(new_cluster, new_rate);
 -	} else {
 -		new_rate = rate;
 -	}
 +	/* Determine valid target frequency using freq_table */
 +	cpufreq_frequency_table_target(policy, freq_table[cur_cluster],
 +			target_freq, relation, &freq_tab_idx);
 +	freqs.new = freq_table[cur_cluster][freq_tab_idx].frequency;
  
 -	pr_debug("%s: cpu: %d, old cluster: %d, new cluster: %d, freq: %d\n",
 -			__func__, cpu, old_cluster, new_cluster, new_rate);
 +	pr_debug("%s: cpu: %d, cluster: %d, oldfreq: %d, target freq: %d, new freq: %d\n",
 +			__func__, cpu, cur_cluster, freqs.old, target_freq,
 +			freqs.new);
  
 -	ret = clk_set_rate(clk[new_cluster], new_rate * 1000);
 -	if (WARN_ON(ret)) {
 -		pr_err("clk_set_rate failed: %d, new cluster: %d\n", ret,
 -				new_cluster);
 -		if (bLs) {
 -			per_cpu(cpu_last_req_freq, cpu) = prev_rate;
 -			per_cpu(physical_cluster, cpu) = old_cluster;
 -		}
 +	if (freqs.old == freqs.new)
 +		return 0;
  
 -		mutex_unlock(&cluster_lock[new_cluster]);
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
  
 +	ret = clk_set_rate(clk[cur_cluster], freqs.new * 1000);
 +	if (ret) {
 +		pr_err("clk_set_rate failed: %d\n", ret);
  		return ret;
  	}
  
 -	mutex_unlock(&cluster_lock[new_cluster]);
 -
 -	/* Recalc freq for old cluster when switching clusters */
 -	if (old_cluster != new_cluster) {
 -		pr_debug("%s: cpu: %d, old cluster: %d, new cluster: %d\n",
 -				__func__, cpu, old_cluster, new_cluster);
 -
 -		/* Switch cluster */
 -		bL_switch_request(cpu, new_cluster);
 -
 -		mutex_lock(&cluster_lock[old_cluster]);
 -
 -		/* Set freq of old cluster if there are cpus left on it */
 -		new_rate = find_cluster_maxfreq(old_cluster);
 -		new_rate = ACTUAL_FREQ(old_cluster, new_rate);
 -
 -		if (new_rate) {
 -			pr_debug("%s: Updating rate of old cluster: %d, to freq: %d\n",
 -					__func__, old_cluster, new_rate);
 -
 -			if (clk_set_rate(clk[old_cluster], new_rate * 1000))
 -				pr_err("%s: clk_set_rate failed: %d, old cluster: %d\n",
 -						__func__, ret, old_cluster);
 -		}
 -		mutex_unlock(&cluster_lock[old_cluster]);
 -	}
 -
 -	return 0;
 -}
 -
 -/* Set clock frequency */
 -static int bL_cpufreq_set_target(struct cpufreq_policy *policy,
 -		unsigned int index)
 -{
 -	u32 cpu = policy->cpu, cur_cluster, new_cluster, actual_cluster;
 -	unsigned int freqs_new;
 +	policy->cur = freqs.new;
  
 -	cur_cluster = cpu_to_cluster(cpu);
 -	new_cluster = actual_cluster = per_cpu(physical_cluster, cpu);
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
  
 +	return ret;
++=======
+ 	freqs_new = freq_table[cur_cluster][index].frequency;
+ 
+ 	if (is_bL_switching_enabled()) {
+ 		if ((actual_cluster == A15_CLUSTER) &&
+ 				(freqs_new < clk_big_min)) {
+ 			new_cluster = A7_CLUSTER;
+ 		} else if ((actual_cluster == A7_CLUSTER) &&
+ 				(freqs_new > clk_little_max)) {
+ 			new_cluster = A15_CLUSTER;
+ 		}
+ 	}
+ 
+ 	return bL_cpufreq_set_rate(cpu, actual_cluster, new_cluster, freqs_new);
 -}
 -
 -static inline u32 get_table_count(struct cpufreq_frequency_table *table)
 -{
 -	int count;
 -
 -	for (count = 0; table[count].frequency != CPUFREQ_TABLE_END; count++)
 -		;
 -
 -	return count;
 -}
 -
 -/* get the minimum frequency in the cpufreq_frequency_table */
 -static inline u32 get_table_min(struct cpufreq_frequency_table *table)
 -{
 -	int i;
 -	uint32_t min_freq = ~0;
 -	for (i = 0; (table[i].frequency != CPUFREQ_TABLE_END); i++)
 -		if (table[i].frequency < min_freq)
 -			min_freq = table[i].frequency;
 -	return min_freq;
 -}
 -
 -/* get the maximum frequency in the cpufreq_frequency_table */
 -static inline u32 get_table_max(struct cpufreq_frequency_table *table)
 -{
 -	int i;
 -	uint32_t max_freq = 0;
 -	for (i = 0; (table[i].frequency != CPUFREQ_TABLE_END); i++)
 -		if (table[i].frequency > max_freq)
 -			max_freq = table[i].frequency;
 -	return max_freq;
 -}
 -
 -static int merge_cluster_tables(void)
 -{
 -	int i, j, k = 0, count = 1;
 -	struct cpufreq_frequency_table *table;
 -
 -	for (i = 0; i < MAX_CLUSTERS; i++)
 -		count += get_table_count(freq_table[i]);
 -
 -	table = kzalloc(sizeof(*table) * count, GFP_KERNEL);
 -	if (!table)
 -		return -ENOMEM;
 -
 -	freq_table[MAX_CLUSTERS] = table;
 -
 -	/* Add in reverse order to get freqs in increasing order */
 -	for (i = MAX_CLUSTERS - 1; i >= 0; i--) {
 -		for (j = 0; freq_table[i][j].frequency != CPUFREQ_TABLE_END;
 -				j++) {
 -			table[k].frequency = VIRT_FREQ(i,
 -					freq_table[i][j].frequency);
 -			pr_debug("%s: index: %d, freq: %d\n", __func__, k,
 -					table[k].frequency);
 -			k++;
 -		}
 -	}
 -
 -	table[k].driver_data = k;
 -	table[k].frequency = CPUFREQ_TABLE_END;
 -
 -	pr_debug("%s: End, table: %p, count: %d\n", __func__, table, k);
 -
 -	return 0;
 -}
 -
 -static void _put_cluster_clk_and_freq_table(struct device *cpu_dev)
 -{
 -	u32 cluster = raw_cpu_to_cluster(cpu_dev->id);
 -
 -	if (!freq_table[cluster])
 -		return;
 -
 -	clk_put(clk[cluster]);
 -	dev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table[cluster]);
 -	dev_dbg(cpu_dev, "%s: cluster: %d\n", __func__, cluster);
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  }
  
  static void put_cluster_clk_and_freq_table(struct device *cpu_dev)
diff --cc drivers/cpufreq/at32ap-cpufreq.c
index 654488723cb5,856ad80418ae..000000000000
--- a/drivers/cpufreq/at32ap-cpufreq.c
+++ b/drivers/cpufreq/at32ap-cpufreq.c
@@@ -43,42 -35,25 +43,56 @@@ static unsigned int at32_get_speed(unsi
  static unsigned int	ref_freq;
  static unsigned long	loops_per_jiffy_ref;
  
 -static int at32_set_target(struct cpufreq_policy *policy, unsigned int index)
 +static int at32_set_target(struct cpufreq_policy *policy,
 +			  unsigned int target_freq,
 +			  unsigned int relation)
  {
++<<<<<<< HEAD
 +	struct cpufreq_freqs freqs;
 +	long freq;
 +
 +	/* Convert target_freq from kHz to Hz */
 +	freq = clk_round_rate(cpuclk, target_freq * 1000);
 +
 +	/* Check if policy->min <= new_freq <= policy->max */
 +	if(freq < (policy->min * 1000) || freq > (policy->max * 1000))
 +		return -EINVAL;
 +
 +	pr_debug("cpufreq: requested frequency %u Hz\n", target_freq * 1000);
 +
 +	freqs.old = at32_get_speed(0);
 +	freqs.new = (freq + 500) / 1000;
 +	freqs.flags = 0;
++=======
+ 	unsigned int old_freq, new_freq;
+ 
+ 	old_freq = at32_get_speed(0);
+ 	new_freq = freq_table[index].frequency;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
  	if (!ref_freq) {
- 		ref_freq = freqs.old;
+ 		ref_freq = old_freq;
  		loops_per_jiffy_ref = boot_cpu_data.loops_per_jiffy;
  	}
  
- 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
- 	if (freqs.old < freqs.new)
+ 	if (old_freq < new_freq)
  		boot_cpu_data.loops_per_jiffy = cpufreq_scale(
++<<<<<<< HEAD
 +				loops_per_jiffy_ref, ref_freq, freqs.new);
 +	clk_set_rate(cpuclk, freq);
 +	if (freqs.new < freqs.old)
 +		boot_cpu_data.loops_per_jiffy = cpufreq_scale(
 +				loops_per_jiffy_ref, ref_freq, freqs.new);
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
 +	pr_debug("cpufreq: set frequency %lu Hz\n", freq);
++=======
+ 				loops_per_jiffy_ref, ref_freq, new_freq);
+ 	clk_set_rate(cpuclk, new_freq * 1000);
+ 	if (new_freq < old_freq)
+ 		boot_cpu_data.loops_per_jiffy = cpufreq_scale(
+ 				loops_per_jiffy_ref, ref_freq, new_freq);
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
  	return 0;
  }
diff --cc drivers/cpufreq/blackfin-cpufreq.c
index 995511e80bef,e9e63fc9c2c9..000000000000
--- a/drivers/cpufreq/blackfin-cpufreq.c
+++ b/drivers/cpufreq/blackfin-cpufreq.c
@@@ -133,30 -132,18 +133,40 @@@ static int bfin_target(struct cpufreq_p
  #ifndef CONFIG_BF60x
  	unsigned int plldiv;
  #endif
++<<<<<<< HEAD
 +	unsigned int index;
 +	unsigned long cclk_hz;
 +	struct cpufreq_freqs freqs;
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	static unsigned long lpj_ref;
  	static unsigned int  lpj_ref_freq;
+ 	unsigned int old_freq, new_freq;
  	int ret = 0;
  
  #if defined(CONFIG_CYCLES_CLOCKSOURCE)
  	cycles_t cycles;
  #endif
  
++<<<<<<< HEAD
 +	if (cpufreq_frequency_table_target(policy, bfin_freq_table, target_freq,
 +				relation, &index))
 +		return -EINVAL;
 +
 +	cclk_hz = bfin_freq_table[index].frequency;
 +
 +	freqs.old = bfin_getfreq_khz(0);
 +	freqs.new = cclk_hz;
 +
 +	pr_debug("cpufreq: changing cclk to %lu; target = %u, oldfreq = %u\n",
 +			cclk_hz, target_freq, freqs.old);
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
++=======
+ 	old_freq = bfin_getfreq_khz(0);
+ 	new_freq = bfin_freq_table[index].frequency;
+ 
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  #ifndef CONFIG_BF60x
  	plldiv = (bfin_read_PLL_DIV() & SSEL) | dpm_state_table[index].csel;
  	bfin_write_PLL_DIV(plldiv);
diff --cc drivers/cpufreq/cpufreq-cpu0.c
index ad1fde277661,d4585ce2346c..000000000000
--- a/drivers/cpufreq/cpufreq-cpu0.c
+++ b/drivers/cpufreq/cpufreq-cpu0.c
@@@ -39,58 -35,42 +39,68 @@@ static unsigned int cpu0_get_speed(unsi
  	return clk_get_rate(cpu_clk) / 1000;
  }
  
 -static int cpu0_set_target(struct cpufreq_policy *policy, unsigned int index)
 +static int cpu0_set_target(struct cpufreq_policy *policy,
 +			   unsigned int target_freq, unsigned int relation)
  {
++<<<<<<< HEAD
 +	struct cpufreq_freqs freqs;
 +	struct opp *opp;
++=======
+ 	struct dev_pm_opp *opp;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	unsigned long volt = 0, volt_old = 0, tol = 0;
+ 	unsigned int old_freq, new_freq;
  	long freq_Hz, freq_exact;
 +	unsigned int index;
  	int ret;
  
 +	ret = cpufreq_frequency_table_target(policy, freq_table, target_freq,
 +					     relation, &index);
 +	if (ret) {
 +		pr_err("failed to match target freqency %d: %d\n",
 +		       target_freq, ret);
 +		return ret;
 +	}
 +
  	freq_Hz = clk_round_rate(cpu_clk, freq_table[index].frequency * 1000);
  	if (freq_Hz < 0)
  		freq_Hz = freq_table[index].frequency * 1000;
- 	freq_exact = freq_Hz;
- 	freqs.new = freq_Hz / 1000;
- 	freqs.old = clk_get_rate(cpu_clk) / 1000;
  
++<<<<<<< HEAD
 +	if (freqs.old == freqs.new)
 +		return 0;
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
++=======
+ 	freq_exact = freq_Hz;
+ 	new_freq = freq_Hz / 1000;
+ 	old_freq = clk_get_rate(cpu_clk) / 1000;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
 -	if (!IS_ERR(cpu_reg)) {
 +	if (cpu_reg) {
  		rcu_read_lock();
 -		opp = dev_pm_opp_find_freq_ceil(cpu_dev, &freq_Hz);
 +		opp = opp_find_freq_ceil(cpu_dev, &freq_Hz);
  		if (IS_ERR(opp)) {
  			rcu_read_unlock();
  			pr_err("failed to find OPP for %ld\n", freq_Hz);
- 			freqs.new = freqs.old;
- 			ret = PTR_ERR(opp);
- 			goto post_notify;
+ 			return PTR_ERR(opp);
  		}
 -		volt = dev_pm_opp_get_voltage(opp);
 +		volt = opp_get_voltage(opp);
  		rcu_read_unlock();
  		tol = volt * voltage_tolerance / 100;
  		volt_old = regulator_get_voltage(cpu_reg);
  	}
  
  	pr_debug("%u MHz, %ld mV --> %u MHz, %ld mV\n",
- 		 freqs.old / 1000, volt_old ? volt_old / 1000 : -1,
- 		 freqs.new / 1000, volt ? volt / 1000 : -1);
+ 		 old_freq / 1000, volt_old ? volt_old / 1000 : -1,
+ 		 new_freq / 1000, volt ? volt / 1000 : -1);
  
  	/* scaling up?  scale voltage before frequency */
++<<<<<<< HEAD
 +	if (cpu_reg && freqs.new > freqs.old) {
++=======
+ 	if (!IS_ERR(cpu_reg) && new_freq > old_freq) {
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  		ret = regulator_set_voltage_tol(cpu_reg, volt, tol);
  		if (ret) {
  			pr_err("failed to scale voltage up: %d\n", ret);
@@@ -102,14 -81,13 +111,17 @@@
  	ret = clk_set_rate(cpu_clk, freq_exact);
  	if (ret) {
  		pr_err("failed to set clock rate: %d\n", ret);
 -		if (!IS_ERR(cpu_reg))
 +		if (cpu_reg)
  			regulator_set_voltage_tol(cpu_reg, volt_old, tol);
- 		freqs.new = freqs.old;
- 		goto post_notify;
+ 		return ret;
  	}
  
  	/* scaling down?  scale voltage after frequency */
++<<<<<<< HEAD
 +	if (cpu_reg && freqs.new < freqs.old) {
++=======
+ 	if (!IS_ERR(cpu_reg) && new_freq < old_freq) {
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  		ret = regulator_set_voltage_tol(cpu_reg, volt, tol);
  		if (ret) {
  			pr_err("failed to scale voltage down: %d\n", ret);
diff --cc drivers/cpufreq/cpufreq.c
index 7e78bc2de297,02d534da22dd..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -1570,7 -1667,64 +1570,68 @@@ int __cpufreq_driver_target(struct cpuf
  
  	if (cpufreq_driver->target)
  		retval = cpufreq_driver->target(policy, target_freq, relation);
++<<<<<<< HEAD
++
++=======
+ 	else if (cpufreq_driver->target_index) {
+ 		struct cpufreq_frequency_table *freq_table;
+ 		struct cpufreq_freqs freqs;
+ 		bool notify;
+ 		int index;
+ 
+ 		freq_table = cpufreq_frequency_get_table(policy->cpu);
+ 		if (unlikely(!freq_table)) {
+ 			pr_err("%s: Unable to find freq_table\n", __func__);
+ 			goto out;
+ 		}
+ 
+ 		retval = cpufreq_frequency_table_target(policy, freq_table,
+ 				target_freq, relation, &index);
+ 		if (unlikely(retval)) {
+ 			pr_err("%s: Unable to find matching freq\n", __func__);
+ 			goto out;
+ 		}
+ 
+ 		if (freq_table[index].frequency == policy->cur) {
+ 			retval = 0;
+ 			goto out;
+ 		}
+ 
+ 		notify = !(cpufreq_driver->flags & CPUFREQ_ASYNC_NOTIFICATION);
  
+ 		if (notify) {
+ 			freqs.old = policy->cur;
+ 			freqs.new = freq_table[index].frequency;
+ 			freqs.flags = 0;
+ 
+ 			pr_debug("%s: cpu: %d, oldfreq: %u, new freq: %u\n",
+ 					__func__, policy->cpu, freqs.old,
+ 					freqs.new);
+ 
+ 			cpufreq_notify_transition(policy, &freqs,
+ 					CPUFREQ_PRECHANGE);
+ 		}
+ 
+ 		retval = cpufreq_driver->target_index(policy, index);
+ 		if (retval)
+ 			pr_err("%s: Failed to change cpu frequency: %d\n",
+ 					__func__, retval);
+ 
+ 		if (notify) {
+ 			/*
+ 			 * Notify with old freq in case we failed to change
+ 			 * frequency
+ 			 */
+ 			if (retval)
+ 				freqs.new = freqs.old;
+ 
+ 			cpufreq_notify_transition(policy, &freqs,
+ 					CPUFREQ_POSTCHANGE);
+ 		}
+ 	}
+ 
+ out:
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	return retval;
  }
  EXPORT_SYMBOL_GPL(__cpufreq_driver_target);
diff --cc drivers/cpufreq/cris-artpec3-cpufreq.c
index ee142c490575,86559040c54c..000000000000
--- a/drivers/cpufreq/cris-artpec3-cpufreq.c
+++ b/drivers/cpufreq/cris-artpec3-cpufreq.c
@@@ -27,10 -27,8 +27,9 @@@ static unsigned int cris_freq_get_cpu_f
  	return clk_ctrl.pll ? 200000 : 6000;
  }
  
 -static int cris_freq_target(struct cpufreq_policy *policy, unsigned int state)
 +static void cris_freq_set_cpu_state(struct cpufreq_policy *policy,
 +		unsigned int state)
  {
- 	struct cpufreq_freqs freqs;
  	reg_clkgen_rw_clk_ctrl clk_ctrl;
  	clk_ctrl = REG_RD(clkgen, regi_clkgen, rw_clk_ctrl);
  
@@@ -51,26 -44,6 +45,29 @@@
  
  	local_irq_enable();
  
++<<<<<<< HEAD
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +};
 +
 +static int cris_freq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, &cris_freq_table[0]);
 +}
 +
 +static int cris_freq_target(struct cpufreq_policy *policy,
 +			    unsigned int target_freq,
 +			    unsigned int relation)
 +{
 +	unsigned int newstate = 0;
 +
 +	if (cpufreq_frequency_table_target(policy, cris_freq_table,
 +			target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	cris_freq_set_cpu_state(policy, newstate);
 +
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	return 0;
  }
  
diff --cc drivers/cpufreq/cris-etraxfs-cpufreq.c
index 12952235d5db,26d940d40b1d..000000000000
--- a/drivers/cpufreq/cris-etraxfs-cpufreq.c
+++ b/drivers/cpufreq/cris-etraxfs-cpufreq.c
@@@ -27,10 -27,8 +27,9 @@@ static unsigned int cris_freq_get_cpu_f
  	return clk_ctrl.pll ? 200000 : 6000;
  }
  
 -static int cris_freq_target(struct cpufreq_policy *policy, unsigned int state)
 +static void cris_freq_set_cpu_state(struct cpufreq_policy *policy,
 +		unsigned int state)
  {
- 	struct cpufreq_freqs freqs;
  	reg_config_rw_clk_ctrl clk_ctrl;
  	clk_ctrl = REG_RD(config, regi_config, rw_clk_ctrl);
  
@@@ -51,25 -44,6 +45,28 @@@
  
  	local_irq_enable();
  
++<<<<<<< HEAD
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +};
 +
 +static int cris_freq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, &cris_freq_table[0]);
 +}
 +
 +static int cris_freq_target(struct cpufreq_policy *policy,
 +			    unsigned int target_freq, unsigned int relation)
 +{
 +	unsigned int newstate = 0;
 +
 +	if (cpufreq_frequency_table_target
 +	    (policy, cris_freq_table, target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	cris_freq_set_cpu_state(policy, newstate);
 +
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	return 0;
  }
  
diff --cc drivers/cpufreq/davinci-cpufreq.c
index 7c60c8b54e11,5e8a854381b7..000000000000
--- a/drivers/cpufreq/davinci-cpufreq.c
+++ b/drivers/cpufreq/davinci-cpufreq.c
@@@ -66,35 -66,21 +66,45 @@@ static unsigned int davinci_getspeed(un
  	return clk_get_rate(cpufreq.armclk) / 1000;
  }
  
 -static int davinci_target(struct cpufreq_policy *policy, unsigned int idx)
 +static int davinci_target(struct cpufreq_policy *policy,
 +				unsigned int target_freq, unsigned int relation)
  {
++<<<<<<< HEAD
 +	int ret = 0;
 +	unsigned int idx;
 +	struct cpufreq_freqs freqs;
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	struct davinci_cpufreq_config *pdata = cpufreq.dev->platform_data;
  	struct clk *armclk = cpufreq.armclk;
+ 	unsigned int old_freq, new_freq;
+ 	int ret = 0;
  
++<<<<<<< HEAD
 +	freqs.old = davinci_getspeed(0);
 +	freqs.new = clk_round_rate(armclk, target_freq * 1000) / 1000;
 +
 +	if (freqs.old == freqs.new)
 +		return ret;
 +
 +	dev_dbg(cpufreq.dev, "transition: %u --> %u\n", freqs.old, freqs.new);
 +
 +	ret = cpufreq_frequency_table_target(policy, pdata->freq_table,
 +						freqs.new, relation, &idx);
 +	if (ret)
 +		return -EINVAL;
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
++=======
+ 	old_freq = davinci_getspeed(0);
+ 	new_freq = pdata->freq_table[idx].frequency;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
  	/* if moving to higher frequency, up the voltage beforehand */
- 	if (pdata->set_voltage && freqs.new > freqs.old) {
+ 	if (pdata->set_voltage && new_freq > old_freq) {
  		ret = pdata->set_voltage(idx);
  		if (ret)
- 			goto out;
+ 			return ret;
  	}
  
  	ret = clk_set_rate(armclk, idx);
@@@ -108,13 -94,10 +118,17 @@@
  	}
  
  	/* if moving to lower freq, lower the voltage after lowering freq */
- 	if (pdata->set_voltage && freqs.new < freqs.old)
+ 	if (pdata->set_voltage && new_freq < old_freq)
  		pdata->set_voltage(idx);
  
++<<<<<<< HEAD
 +out:
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
 +	return ret;
++=======
+ 	return 0;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  }
  
  static int davinci_cpu_init(struct cpufreq_policy *policy)
diff --cc drivers/cpufreq/dbx500-cpufreq.c
index 8c005ac8b701,0e67ab96321a..000000000000
--- a/drivers/cpufreq/dbx500-cpufreq.c
+++ b/drivers/cpufreq/dbx500-cpufreq.c
@@@ -19,51 -19,11 +19,56 @@@
  static struct cpufreq_frequency_table *freq_table;
  static struct clk *armss_clk;
  
 +static struct freq_attr *dbx500_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
 +static int dbx500_cpufreq_verify_speed(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, freq_table);
 +}
 +
  static int dbx500_cpufreq_target(struct cpufreq_policy *policy,
 -				unsigned int index)
 +				unsigned int target_freq,
 +				unsigned int relation)
  {
++<<<<<<< HEAD
 +	struct cpufreq_freqs freqs;
 +	unsigned int idx;
 +	int ret;
 +
 +	/* Lookup the next frequency */
 +	if (cpufreq_frequency_table_target(policy, freq_table, target_freq,
 +					relation, &idx))
 +		return -EINVAL;
 +
 +	freqs.old = policy->cur;
 +	freqs.new = freq_table[idx].frequency;
 +
 +	if (freqs.old == freqs.new)
 +		return 0;
 +
 +	/* pre-change notification */
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +
 +	/* update armss clk frequency */
 +	ret = clk_set_rate(armss_clk, freqs.new * 1000);
 +
 +	if (ret) {
 +		pr_err("dbx500-cpufreq: Failed to set armss_clk to %d Hz: error %d\n",
 +		       freqs.new * 1000, ret);
 +		return ret;
 +	}
 +
 +	/* post change notification */
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
 +	return 0;
++=======
+ 	/* update armss clk frequency */
+ 	return clk_set_rate(armss_clk, freq_table[index].frequency * 1000);
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  }
  
  static unsigned int dbx500_cpufreq_getspeed(unsigned int cpu)
diff --cc drivers/cpufreq/e_powersaver.c
index 37380fb92621,9012b8bb6b64..000000000000
--- a/drivers/cpufreq/e_powersaver.c
+++ b/drivers/cpufreq/e_powersaver.c
@@@ -161,16 -148,12 +148,20 @@@ static int eps_set_state(struct eps_cpu
  		current_multiplier);
  	}
  #endif
++<<<<<<< HEAD
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +	return err;
++=======
+ 	return 0;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  }
  
 -static int eps_target(struct cpufreq_policy *policy, unsigned int index)
 +static int eps_target(struct cpufreq_policy *policy,
 +			       unsigned int target_freq,
 +			       unsigned int relation)
  {
  	struct eps_cpu_data *centaur;
 +	unsigned int newstate = 0;
  	unsigned int cpu = policy->cpu;
  	unsigned int dest_state;
  	int ret;
diff --cc drivers/cpufreq/elanfreq.c
index 658d860344b0,de08acff5101..000000000000
--- a/drivers/cpufreq/elanfreq.c
+++ b/drivers/cpufreq/elanfreq.c
@@@ -105,32 -105,9 +105,21 @@@ static unsigned int elanfreq_get_cpu_fr
  }
  
  
 -static int elanfreq_target(struct cpufreq_policy *policy,
 -			    unsigned int state)
 +/**
 + *	elanfreq_set_cpu_frequency: Change the CPU core frequency
 + *	@cpu: cpu number
 + *	@freq: frequency in kHz
 + *
 + *	This function takes a frequency value and changes the CPU frequency
 + *	according to this. Note that the frequency has to be checked by
 + *	elanfreq_validatespeed() for correctness!
 + *
 + *	There is no return value.
 + */
 +
 +static void elanfreq_set_cpu_state(struct cpufreq_policy *policy,
 +		unsigned int state)
  {
- 	struct cpufreq_freqs    freqs;
- 
- 	freqs.old = elanfreq_get_cpu_frequency(0);
- 	freqs.new = elan_multiplier[state].clock;
- 
- 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
- 
- 	printk(KERN_INFO "elanfreq: attempting to set frequency to %i kHz\n",
- 			elan_multiplier[state].clock);
- 
- 
  	/*
  	 * Access to the Elan's internal registers is indexed via
  	 * 0x22: Chip Setup & Control Register Index Register (CSCI)
@@@ -161,39 -138,8 +150,42 @@@
  	udelay(10000);
  	local_irq_enable();
  
++<<<<<<< HEAD
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +};
 +
 +
 +/**
 + *	elanfreq_validatespeed: test if frequency range is valid
 + *	@policy: the policy to validate
 + *
 + *	This function checks if a given frequency range in kHz is valid
 + *	for the hardware supported by the driver.
 + */
 +
 +static int elanfreq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, &elanfreq_table[0]);
 +}
 +
 +static int elanfreq_target(struct cpufreq_policy *policy,
 +			    unsigned int target_freq,
 +			    unsigned int relation)
 +{
 +	unsigned int newstate = 0;
 +
 +	if (cpufreq_frequency_table_target(policy, &elanfreq_table[0],
 +				target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	elanfreq_set_cpu_state(policy, newstate);
 +
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	return 0;
  }
 +
 +
  /*
   *	Module init and exit code
   */
diff --cc drivers/cpufreq/exynos-cpufreq.c
index 475b4f607f0d,7b6dc06b1bd4..000000000000
--- a/drivers/cpufreq/exynos-cpufreq.c
+++ b/drivers/cpufreq/exynos-cpufreq.c
@@@ -68,12 -62,8 +68,11 @@@ static int exynos_cpufreq_scale(unsigne
  	int index, old_index;
  	int ret = 0;
  
- 	freqs.old = policy->cur;
- 	freqs.new = target_freq;
+ 	old_freq = policy->cur;
  
 +	if (freqs.new == freqs.old)
 +		goto out;
 +
  	/*
  	 * The policy max have been changed so that we cannot get proper
  	 * old_index with cpufreq_frequency_table_target(). Thus, ignore
@@@ -113,7 -101,7 +110,11 @@@
  		if (ret) {
  			pr_err("%s: failed to set cpu voltage to %d\n",
  				__func__, arm_volt);
++<<<<<<< HEAD
 +			goto out;
++=======
+ 			return ret;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  		}
  	}
  
@@@ -123,19 -111,17 +124,26 @@@
  		if (ret) {
  			pr_err("%s: failed to set cpu voltage to %d\n",
  				__func__, safe_arm_volt);
++<<<<<<< HEAD
 +			goto out;
++=======
+ 			return ret;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  		}
  	}
  
  	exynos_info->set_freq(old_index, index);
  
++<<<<<<< HEAD
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	/* When the new frequency is lower than current frequency */
- 	if ((freqs.new < freqs.old) ||
- 	   ((freqs.new > freqs.old) && safe_arm_volt)) {
+ 	if ((target_freq < old_freq) ||
+ 	   ((target_freq > old_freq) && safe_arm_volt)) {
  		/* down the voltage after frequency change */
 -		ret = regulator_set_voltage(arm_regulator, arm_volt,
 +		regulator_set_voltage(arm_regulator, arm_volt,
  				arm_volt);
  		if (ret) {
  			pr_err("%s: failed to set cpu voltage to %d\n",
diff --cc drivers/cpufreq/imx6q-cpufreq.c
index b78bc35973ba,4b3f18e5f36b..000000000000
--- a/drivers/cpufreq/imx6q-cpufreq.c
+++ b/drivers/cpufreq/imx6q-cpufreq.c
@@@ -44,34 -40,19 +44,45 @@@ static unsigned int imx6q_get_speed(uns
  	return clk_get_rate(arm_clk) / 1000;
  }
  
 -static int imx6q_set_target(struct cpufreq_policy *policy, unsigned int index)
 +static int imx6q_set_target(struct cpufreq_policy *policy,
 +			    unsigned int target_freq, unsigned int relation)
  {
++<<<<<<< HEAD
 +	struct cpufreq_freqs freqs;
 +	struct opp *opp;
 +	unsigned long freq_hz, volt, volt_old;
 +	unsigned int index;
 +	int ret;
 +
 +	ret = cpufreq_frequency_table_target(policy, freq_table, target_freq,
 +					     relation, &index);
 +	if (ret) {
 +		dev_err(cpu_dev, "failed to match target frequency %d: %d\n",
 +			target_freq, ret);
 +		return ret;
 +	}
 +
 +	freqs.new = freq_table[index].frequency;
 +	freq_hz = freqs.new * 1000;
 +	freqs.old = clk_get_rate(arm_clk) / 1000;
++=======
+ 	struct dev_pm_opp *opp;
+ 	unsigned long freq_hz, volt, volt_old;
+ 	unsigned int old_freq, new_freq;
+ 	int ret;
+ 
+ 	new_freq = freq_table[index].frequency;
+ 	freq_hz = new_freq * 1000;
+ 	old_freq = clk_get_rate(arm_clk) / 1000;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
 +
 +	if (freqs.old == freqs.new)
 +		return 0;
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
  
  	rcu_read_lock();
 -	opp = dev_pm_opp_find_freq_ceil(cpu_dev, &freq_hz);
 +	opp = opp_find_freq_ceil(cpu_dev, &freq_hz);
  	if (IS_ERR(opp)) {
  		rcu_read_unlock();
  		dev_err(cpu_dev, "failed to find OPP for %ld\n", freq_hz);
@@@ -83,11 -64,11 +94,16 @@@
  	volt_old = regulator_get_voltage(arm_reg);
  
  	dev_dbg(cpu_dev, "%u MHz, %ld mV --> %u MHz, %ld mV\n",
++<<<<<<< HEAD
 +		freqs.old / 1000, volt_old / 1000,
 +		freqs.new / 1000, volt / 1000);
++=======
+ 		old_freq / 1000, volt_old / 1000,
+ 		new_freq / 1000, volt / 1000);
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
  	/* scaling up?  scale voltage before frequency */
- 	if (freqs.new > freqs.old) {
+ 	if (new_freq > old_freq) {
  		ret = regulator_set_voltage_tol(arm_reg, volt, 0);
  		if (ret) {
  			dev_err(cpu_dev,
@@@ -120,24 -100,8 +136,28 @@@
  	clk_set_parent(step_clk, pll2_pfd2_396m_clk);
  	clk_set_parent(pll1_sw_clk, step_clk);
  	if (freq_hz > clk_get_rate(pll2_pfd2_396m_clk)) {
++<<<<<<< HEAD
 +		clk_set_rate(pll1_sys_clk, freqs.new * 1000);
 +		/*
 +		 * If we are leaving 396 MHz set-point, we need to enable
 +		 * pll1_sys_clk and disable pll2_pfd2_396m_clk to keep
 +		 * their use count correct.
 +		 */
 +		if (freqs.old * 1000 <= clk_get_rate(pll2_pfd2_396m_clk)) {
 +			clk_prepare_enable(pll1_sys_clk);
 +			clk_disable_unprepare(pll2_pfd2_396m_clk);
 +		}
++=======
+ 		clk_set_rate(pll1_sys_clk, new_freq * 1000);
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  		clk_set_parent(pll1_sw_clk, pll1_sys_clk);
 +		clk_disable_unprepare(pll2_pfd2_396m_clk);
 +	} else {
 +		/*
 +		 * Disable pll1_sys_clk if pll2_pfd2_396m_clk is sufficient
 +		 * to provide the frequency.
 +		 */
 +		clk_disable_unprepare(pll1_sys_clk);
  	}
  
  	/* Ensure the arm clock divider is what we expect */
@@@ -149,13 -113,15 +169,13 @@@
  	}
  
  	/* scaling down?  scale voltage after frequency */
- 	if (freqs.new < freqs.old) {
+ 	if (new_freq < old_freq) {
  		ret = regulator_set_voltage_tol(arm_reg, volt, 0);
 -		if (ret) {
 +		if (ret)
  			dev_warn(cpu_dev,
  				 "failed to scale vddarm down: %d\n", ret);
 -			ret = 0;
 -		}
  
- 		if (freqs.old == FREQ_1P2_GHZ / 1000) {
+ 		if (old_freq == FREQ_1P2_GHZ / 1000) {
  			regulator_set_voltage_tol(pu_reg,
  					PU_SOC_VOLTAGE_NORMAL, 0);
  			regulator_set_voltage_tol(soc_reg,
@@@ -163,8 -129,6 +183,11 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	return 0;
  }
  
diff --cc drivers/cpufreq/kirkwood-cpufreq.c
index b2644af985ec,0767a4e29dfe..000000000000
--- a/drivers/cpufreq/kirkwood-cpufreq.c
+++ b/drivers/cpufreq/kirkwood-cpufreq.c
@@@ -55,69 -55,37 +55,64 @@@ static unsigned int kirkwood_cpufreq_ge
  	return kirkwood_freq_table[0].frequency;
  }
  
 -static int kirkwood_cpufreq_target(struct cpufreq_policy *policy,
 -			    unsigned int index)
 +static void kirkwood_cpufreq_set_cpu_state(struct cpufreq_policy *policy,
 +		unsigned int index)
  {
++<<<<<<< HEAD
 +	struct cpufreq_freqs freqs;
 +	unsigned int state = kirkwood_freq_table[index].index;
++=======
+ 	unsigned int state = kirkwood_freq_table[index].driver_data;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	unsigned long reg;
  
- 	freqs.old = kirkwood_cpufreq_get_cpu_frequency(0);
- 	freqs.new = kirkwood_freq_table[index].frequency;
+ 	local_irq_disable();
  
- 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
+ 	/* Disable interrupts to the CPU */
+ 	reg = readl_relaxed(priv.base);
+ 	reg |= CPU_SW_INT_BLK;
+ 	writel_relaxed(reg, priv.base);
  
- 	dev_dbg(priv.dev, "Attempting to set frequency to %i KHz\n",
- 		kirkwood_freq_table[index].frequency);
- 	dev_dbg(priv.dev, "old frequency was %i KHz\n",
- 		kirkwood_cpufreq_get_cpu_frequency(0));
- 
- 	if (freqs.old != freqs.new) {
- 		local_irq_disable();
- 
- 		/* Disable interrupts to the CPU */
- 		reg = readl_relaxed(priv.base);
- 		reg |= CPU_SW_INT_BLK;
- 		writel_relaxed(reg, priv.base);
- 
- 		switch (state) {
- 		case STATE_CPU_FREQ:
- 			clk_disable(priv.powersave_clk);
- 			break;
- 		case STATE_DDR_FREQ:
- 			clk_enable(priv.powersave_clk);
- 			break;
- 		}
- 
- 		/* Wait-for-Interrupt, while the hardware changes frequency */
- 		cpu_do_idle();
- 
- 		/* Enable interrupts to the CPU */
- 		reg = readl_relaxed(priv.base);
- 		reg &= ~CPU_SW_INT_BLK;
- 		writel_relaxed(reg, priv.base);
- 
- 		local_irq_enable();
+ 	switch (state) {
+ 	case STATE_CPU_FREQ:
+ 		clk_disable(priv.powersave_clk);
+ 		break;
+ 	case STATE_DDR_FREQ:
+ 		clk_enable(priv.powersave_clk);
+ 		break;
  	}
++<<<<<<< HEAD
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +};
 +
 +static int kirkwood_cpufreq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, kirkwood_freq_table);
 +}
 +
 +static int kirkwood_cpufreq_target(struct cpufreq_policy *policy,
 +			    unsigned int target_freq,
 +			    unsigned int relation)
 +{
 +	unsigned int index = 0;
 +
 +	if (cpufreq_frequency_table_target(policy, kirkwood_freq_table,
 +				target_freq, relation, &index))
 +		return -EINVAL;
 +
 +	kirkwood_cpufreq_set_cpu_state(policy, index);
++=======
+ 
+ 	/* Wait-for-Interrupt, while the hardware changes frequency */
+ 	cpu_do_idle();
+ 
+ 	/* Enable interrupts to the CPU */
+ 	reg = readl_relaxed(priv.base);
+ 	reg &= ~CPU_SW_INT_BLK;
+ 	writel_relaxed(reg, priv.base);
+ 
+ 	local_irq_enable();
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
  	return 0;
  }
diff --cc drivers/cpufreq/loongson2_cpufreq.c
index f92b02ae20be,a43609218105..000000000000
--- a/drivers/cpufreq/loongson2_cpufreq.c
+++ b/drivers/cpufreq/loongson2_cpufreq.c
@@@ -53,41 -53,19 +53,43 @@@ static unsigned int loongson2_cpufreq_g
   * Here we notify other drivers of the proposed change and the final change.
   */
  static int loongson2_cpufreq_target(struct cpufreq_policy *policy,
 -				     unsigned int index)
 +				     unsigned int target_freq,
 +				     unsigned int relation)
  {
  	unsigned int cpu = policy->cpu;
 +	unsigned int newstate = 0;
  	cpumask_t cpus_allowed;
- 	struct cpufreq_freqs freqs;
  	unsigned int freq;
  
  	cpus_allowed = current->cpus_allowed;
  	set_cpus_allowed_ptr(current, cpumask_of(cpu));
  
 +	if (cpufreq_frequency_table_target
 +	    (policy, &loongson2_clockmod_table[0], target_freq, relation,
 +	     &newstate))
 +		return -EINVAL;
 +
  	freq =
  	    ((cpu_clock_freq / 1000) *
 -	     loongson2_clockmod_table[index].driver_data) / 8;
 +	     loongson2_clockmod_table[newstate].index) / 8;
 +	if (freq < policy->min || freq > policy->max)
 +		return -EINVAL;
 +
++<<<<<<< HEAD
 +	pr_debug("cpufreq: requested frequency %u Hz\n", target_freq * 1000);
 +
 +	freqs.old = loongson2_cpufreq_get(cpu);
 +	freqs.new = freq;
 +	freqs.flags = 0;
 +
 +	if (freqs.new == freqs.old)
 +		return 0;
 +
 +	/* notifiers */
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
  
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	set_cpus_allowed_ptr(current, &cpus_allowed);
  
  	/* setting the cpu frequency */
diff --cc drivers/cpufreq/maple-cpufreq.c
index cdd62915efaf,c4dfa42a75ac..000000000000
--- a/drivers/cpufreq/maple-cpufreq.c
+++ b/drivers/cpufreq/maple-cpufreq.c
@@@ -135,37 -128,10 +133,41 @@@ static int maple_scom_query_freq(void
   * Common interface to the cpufreq core
   */
  
 +static int maple_cpufreq_verify(struct cpufreq_policy *policy)
 +{
++<<<<<<< HEAD
 +	return cpufreq_frequency_table_verify(policy, maple_cpu_freqs);
 +}
 +
  static int maple_cpufreq_target(struct cpufreq_policy *policy,
 -	unsigned int index)
 +	unsigned int target_freq, unsigned int relation)
  {
 +	unsigned int newstate = 0;
 +	struct cpufreq_freqs freqs;
 +	int rc;
 +
 +	if (cpufreq_frequency_table_target(policy, maple_cpu_freqs,
 +			target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	if (maple_pmode_cur == newstate)
 +		return 0;
 +
 +	mutex_lock(&maple_switch_mutex);
 +
 +	freqs.old = maple_cpu_freqs[maple_pmode_cur].frequency;
 +	freqs.new = maple_cpu_freqs[newstate].frequency;
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +	rc = maple_scom_switch_freq(newstate);
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
 +	mutex_unlock(&maple_switch_mutex);
 +
 +	return rc;
++=======
+ 	return maple_scom_switch_freq(index);
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  }
  
  static unsigned int maple_cpufreq_get_speed(unsigned int cpu)
diff --cc drivers/cpufreq/omap-cpufreq.c
index 4b81d3e9f0ab,be6d14307aa8..000000000000
--- a/drivers/cpufreq/omap-cpufreq.c
+++ b/drivers/cpufreq/omap-cpufreq.c
@@@ -58,45 -51,16 +58,55 @@@ static unsigned int omap_getspeed(unsig
  	return rate;
  }
  
 -static int omap_target(struct cpufreq_policy *policy, unsigned int index)
 +static int omap_target(struct cpufreq_policy *policy,
 +		       unsigned int target_freq,
 +		       unsigned int relation)
  {
++<<<<<<< HEAD
 +	unsigned int i;
 +	int r, ret = 0;
 +	struct cpufreq_freqs freqs;
 +	struct opp *opp;
++=======
+ 	struct dev_pm_opp *opp;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	unsigned long freq, volt = 0, volt_old = 0, tol = 0;
+ 	unsigned int old_freq, new_freq;
  
++<<<<<<< HEAD
 +	if (!freq_table) {
 +		dev_err(mpu_dev, "%s: cpu%d: no freq table!\n", __func__,
 +				policy->cpu);
 +		return -EINVAL;
 +	}
 +
 +	ret = cpufreq_frequency_table_target(policy, freq_table, target_freq,
 +			relation, &i);
 +	if (ret) {
 +		dev_dbg(mpu_dev, "%s: cpu%d: no freq match for %d(ret=%d)\n",
 +			__func__, policy->cpu, target_freq, ret);
 +		return ret;
 +	}
 +	freqs.new = freq_table[i].frequency;
 +	if (!freqs.new) {
 +		dev_err(mpu_dev, "%s: cpu%d: no match for freq %d\n", __func__,
 +			policy->cpu, target_freq);
 +		return -EINVAL;
 +	}
 +
 +	freqs.old = omap_getspeed(policy->cpu);
 +
 +	if (freqs.old == freqs.new && policy->cur == freqs.new)
 +		return ret;
 +
 +	/* notifiers */
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
++=======
+ 	old_freq = omap_getspeed(policy->cpu);
+ 	new_freq = freq_table[index].frequency;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
- 	freq = freqs.new * 1000;
+ 	freq = new_freq * 1000;
  	ret = clk_round_rate(mpu_clk, freq);
  	if (IS_ERR_VALUE(ret)) {
  		dev_warn(mpu_dev,
@@@ -112,21 -76,21 +122,26 @@@
  		if (IS_ERR(opp)) {
  			rcu_read_unlock();
  			dev_err(mpu_dev, "%s: unable to find MPU OPP for %d\n",
- 				__func__, freqs.new);
+ 				__func__, new_freq);
  			return -EINVAL;
  		}
 -		volt = dev_pm_opp_get_voltage(opp);
 +		volt = opp_get_voltage(opp);
  		rcu_read_unlock();
  		tol = volt * OPP_TOLERANCE / 100;
  		volt_old = regulator_get_voltage(mpu_reg);
  	}
  
  	dev_dbg(mpu_dev, "cpufreq-omap: %u MHz, %ld mV --> %u MHz, %ld mV\n", 
++<<<<<<< HEAD
 +		freqs.old / 1000, volt_old ? volt_old / 1000 : -1,
 +		freqs.new / 1000, volt ? volt / 1000 : -1);
++=======
+ 		old_freq / 1000, volt_old ? volt_old / 1000 : -1,
+ 		new_freq / 1000, volt ? volt / 1000 : -1);
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
  	/* scaling up?  scale voltage before frequency */
- 	if (mpu_reg && (freqs.new > freqs.old)) {
+ 	if (mpu_reg && (new_freq > old_freq)) {
  		r = regulator_set_voltage(mpu_reg, volt - tol, volt + tol);
  		if (r < 0) {
  			dev_warn(mpu_dev, "%s: unable to scale voltage up.\n",
diff --cc drivers/cpufreq/p4-clockmod.c
index 6164c1cca504,3d1cba9fd5f9..000000000000
--- a/drivers/cpufreq/p4-clockmod.c
+++ b/drivers/cpufreq/p4-clockmod.c
@@@ -105,37 -105,17 +105,39 @@@ static struct cpufreq_frequency_table p
  };
  
  
 -static int cpufreq_p4_target(struct cpufreq_policy *policy, unsigned int index)
 +static int cpufreq_p4_target(struct cpufreq_policy *policy,
 +			     unsigned int target_freq,
 +			     unsigned int relation)
  {
++<<<<<<< HEAD
 +	unsigned int    newstate = DC_RESV;
 +	struct cpufreq_freqs freqs;
  	int i;
  
 +	if (cpufreq_frequency_table_target(policy, &p4clockmod_table[0],
 +				target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	freqs.old = cpufreq_p4_get(policy->cpu);
 +	freqs.new = stock_freq * p4clockmod_table[newstate].driver_data / 8;
 +
 +	if (freqs.new == freqs.old)
 +		return 0;
 +
 +	/* notifiers */
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +
++=======
++	int i;
++
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	/* run on each logical CPU,
  	 * see section 13.15.3 of IA32 Intel Architecture Software
  	 * Developer's Manual, Volume 3
  	 */
  	for_each_cpu(i, policy->cpus)
 -		cpufreq_p4_setdc(i, p4clockmod_table[index].driver_data);
 +		cpufreq_p4_setdc(i, p4clockmod_table[newstate].driver_data);
  
- 	/* notifiers */
- 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
- 
  	return 0;
  }
  
diff --cc drivers/cpufreq/pasemi-cpufreq.c
index b704da404067,1c331369b15b..000000000000
--- a/drivers/cpufreq/pasemi-cpufreq.c
+++ b/drivers/cpufreq/pasemi-cpufreq.c
@@@ -253,31 -237,11 +251,36 @@@ static int pas_cpufreq_cpu_exit(struct 
  	return 0;
  }
  
 +static int pas_cpufreq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, pas_freqs);
 +}
 +
  static int pas_cpufreq_target(struct cpufreq_policy *policy,
 -			      unsigned int pas_astate_new)
 +			      unsigned int target_freq,
 +			      unsigned int relation)
  {
++<<<<<<< HEAD
 +	struct cpufreq_freqs freqs;
 +	int pas_astate_new;
 +	int i;
 +
 +	cpufreq_frequency_table_target(policy,
 +				       pas_freqs,
 +				       target_freq,
 +				       relation,
 +				       &pas_astate_new);
 +
 +	freqs.old = policy->cur;
 +	freqs.new = pas_freqs[pas_astate_new].frequency;
 +
 +	mutex_lock(&pas_switch_mutex);
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +
++=======
+ 	int i;
+ 
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	pr_debug("setting frequency for cpu %d to %d kHz, 1/%d of max frequency\n",
  		 policy->cpu,
  		 pas_freqs[pas_astate_new].frequency,
diff --cc drivers/cpufreq/pmac32-cpufreq.c
index 3104fad82480,cf55d202f332..000000000000
--- a/drivers/cpufreq/pmac32-cpufreq.c
+++ b/drivers/cpufreq/pmac32-cpufreq.c
@@@ -377,23 -361,12 +365,27 @@@ static unsigned int pmac_cpufreq_get_sp
  	return cur_freq;
  }
  
 +static int pmac_cpufreq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, pmac_cpu_freqs);
 +}
 +
  static int pmac_cpufreq_target(	struct cpufreq_policy *policy,
 -					unsigned int index)
 +					unsigned int target_freq,
 +					unsigned int relation)
  {
 +	unsigned int    newstate = 0;
  	int		rc;
  
++<<<<<<< HEAD
 +	if (cpufreq_frequency_table_target(policy, pmac_cpu_freqs,
 +			target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	rc = do_set_cpu_speed(policy, newstate, 1);
++=======
+ 	rc = do_set_cpu_speed(policy, index);
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
  	ppc_proc_freq = cur_freq * 1000ul;
  	return rc;
diff --cc drivers/cpufreq/pmac64-cpufreq.c
index 7ba423431cfe,6a338f8c3860..000000000000
--- a/drivers/cpufreq/pmac64-cpufreq.c
+++ b/drivers/cpufreq/pmac64-cpufreq.c
@@@ -316,37 -310,9 +314,41 @@@ static int g5_pfunc_query_freq(void
   * Common interface to the cpufreq core
   */
  
 -static int g5_cpufreq_target(struct cpufreq_policy *policy, unsigned int index)
 +static int g5_cpufreq_verify(struct cpufreq_policy *policy)
 +{
++<<<<<<< HEAD
 +	return cpufreq_frequency_table_verify(policy, g5_cpu_freqs);
 +}
 +
 +static int g5_cpufreq_target(struct cpufreq_policy *policy,
 +	unsigned int target_freq, unsigned int relation)
  {
 +	unsigned int newstate = 0;
 +	struct cpufreq_freqs freqs;
 +	int rc;
 +
 +	if (cpufreq_frequency_table_target(policy, g5_cpu_freqs,
 +			target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	if (g5_pmode_cur == newstate)
 +		return 0;
 +
 +	mutex_lock(&g5_switch_mutex);
 +
 +	freqs.old = g5_cpu_freqs[g5_pmode_cur].frequency;
 +	freqs.new = g5_cpu_freqs[newstate].frequency;
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +	rc = g5_switch_freq(newstate);
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
 +	mutex_unlock(&g5_switch_mutex);
 +
 +	return rc;
++=======
+ 	return g5_switch_freq(index);
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  }
  
  static unsigned int g5_cpufreq_get_speed(unsigned int cpu)
diff --cc drivers/cpufreq/ppc_cbe_cpufreq.c
index 5936f8d6f2cc,e42ca9c31cea..000000000000
--- a/drivers/cpufreq/ppc_cbe_cpufreq.c
+++ b/drivers/cpufreq/ppc_cbe_cpufreq.c
@@@ -142,25 -126,8 +139,28 @@@ static int cbe_cpufreq_verify(struct cp
  }
  
  static int cbe_cpufreq_target(struct cpufreq_policy *policy,
 -			      unsigned int cbe_pmode_new)
 +			      unsigned int target_freq,
 +			      unsigned int relation)
  {
++<<<<<<< HEAD
 +	int rc;
 +	struct cpufreq_freqs freqs;
 +	unsigned int cbe_pmode_new;
 +
 +	cpufreq_frequency_table_target(policy,
 +				       cbe_freqs,
 +				       target_freq,
 +				       relation,
 +				       &cbe_pmode_new);
 +
 +	freqs.old = policy->cur;
 +	freqs.new = cbe_freqs[cbe_pmode_new].frequency;
 +
 +	mutex_lock(&cbe_switch_mutex);
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	pr_debug("setting frequency for cpu %d to %d kHz, " \
  		 "1/%d of max frequency\n",
  		 policy->cpu,
diff --cc drivers/cpufreq/pxa2xx-cpufreq.c
index 9e5bc8e388a0,0a0f4369636a..000000000000
--- a/drivers/cpufreq/pxa2xx-cpufreq.c
+++ b/drivers/cpufreq/pxa2xx-cpufreq.c
@@@ -290,8 -271,6 +290,11 @@@ static int pxa_set_target(struct cpufre
  {
  	struct cpufreq_frequency_table *pxa_freqs_table;
  	pxa_freqs_t *pxa_freq_settings;
++<<<<<<< HEAD
 +	struct cpufreq_freqs freqs;
 +	unsigned int idx;
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	unsigned long flags;
  	unsigned int new_freq_cpu, new_freq_mem;
  	unsigned int unused, preset_mdrefr, postset_mdrefr, cclkcfg;
@@@ -300,16 -279,8 +303,14 @@@
  	/* Get the current policy */
  	find_freq_tables(&pxa_freqs_table, &pxa_freq_settings);
  
 +	/* Lookup the next frequency */
 +	if (cpufreq_frequency_table_target(policy, pxa_freqs_table,
 +					   target_freq, relation, &idx)) {
 +		return -EINVAL;
 +	}
 +
  	new_freq_cpu = pxa_freq_settings[idx].khz;
  	new_freq_mem = pxa_freq_settings[idx].membus;
- 	freqs.old = policy->cur;
- 	freqs.new = new_freq_cpu;
  
  	if (freq_debug)
  		pr_debug("Changing CPU frequency to %d Mhz, (SDRAM %d Mhz)\n",
diff --cc drivers/cpufreq/pxa3xx-cpufreq.c
index 15d60f857ad5,93840048dd11..000000000000
--- a/drivers/cpufreq/pxa3xx-cpufreq.c
+++ b/drivers/cpufreq/pxa3xx-cpufreq.c
@@@ -160,37 -155,16 +160,39 @@@ static unsigned int pxa3xx_cpufreq_get(
  	return pxa3xx_get_clk_frequency_khz(0);
  }
  
 -static int pxa3xx_cpufreq_set(struct cpufreq_policy *policy, unsigned int index)
 +static int pxa3xx_cpufreq_set(struct cpufreq_policy *policy,
 +			      unsigned int target_freq,
 +			      unsigned int relation)
  {
  	struct pxa3xx_freq_info *next;
- 	struct cpufreq_freqs freqs;
  	unsigned long flags;
 +	int idx;
  
  	if (policy->cpu != 0)
  		return -EINVAL;
  
 -	next = &pxa3xx_freqs[index];
 +	/* Lookup the next frequency */
 +	if (cpufreq_frequency_table_target(policy, pxa3xx_freqs_table,
 +				target_freq, relation, &idx))
 +		return -EINVAL;
 +
 +	next = &pxa3xx_freqs[idx];
 +
++<<<<<<< HEAD
 +	freqs.old = policy->cur;
 +	freqs.new = next->cpufreq_mhz * 1000;
 +
 +	pr_debug("CPU frequency from %d MHz to %d MHz%s\n",
 +			freqs.old / 1000, freqs.new / 1000,
 +			(freqs.old == freqs.new) ? " (skipped)" : "");
 +
 +	if (freqs.old == target_freq)
 +		return 0;
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
  
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	local_irq_save(flags);
  	__update_core_freq(next);
  	__update_bus_freq(next);
diff --cc drivers/cpufreq/s3c64xx-cpufreq.c
index 27cacb524796,67e302eeefec..000000000000
--- a/drivers/cpufreq/s3c64xx-cpufreq.c
+++ b/drivers/cpufreq/s3c64xx-cpufreq.c
@@@ -71,55 -63,38 +71,74 @@@ static unsigned int s3c64xx_cpufreq_get
  }
  
  static int s3c64xx_cpufreq_set_target(struct cpufreq_policy *policy,
 -				      unsigned int index)
 +				      unsigned int target_freq,
 +				      unsigned int relation)
  {
++<<<<<<< HEAD
 +	int ret;
 +	unsigned int i;
 +	struct cpufreq_freqs freqs;
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	struct s3c64xx_dvfs *dvfs;
+ 	unsigned int old_freq, new_freq;
+ 	int ret;
  
++<<<<<<< HEAD
 +	ret = cpufreq_frequency_table_target(policy, s3c64xx_freq_table,
 +					     target_freq, relation, &i);
 +	if (ret != 0)
 +		return ret;
 +
 +	freqs.old = clk_get_rate(armclk) / 1000;
 +	freqs.new = s3c64xx_freq_table[i].frequency;
 +	freqs.flags = 0;
 +	dvfs = &s3c64xx_dvfs_table[s3c64xx_freq_table[i].index];
 +
 +	if (freqs.old == freqs.new)
 +		return 0;
- 
- 	pr_debug("Transition %d-%dkHz\n", freqs.old, freqs.new);
- 
- 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
++=======
+ 	old_freq = clk_get_rate(armclk) / 1000;
+ 	new_freq = s3c64xx_freq_table[index].frequency;
+ 	dvfs = &s3c64xx_dvfs_table[s3c64xx_freq_table[index].driver_data];
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
  #ifdef CONFIG_REGULATOR
- 	if (vddarm && freqs.new > freqs.old) {
+ 	if (vddarm && new_freq > old_freq) {
  		ret = regulator_set_voltage(vddarm,
  					    dvfs->vddarm_min,
  					    dvfs->vddarm_max);
  		if (ret != 0) {
  			pr_err("Failed to set VDDARM for %dkHz: %d\n",
++<<<<<<< HEAD
 +			       freqs.new, ret);
 +			goto err;
++=======
+ 			       new_freq, ret);
+ 			return ret;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  		}
  	}
  #endif
  
- 	ret = clk_set_rate(armclk, freqs.new * 1000);
+ 	ret = clk_set_rate(armclk, new_freq * 1000);
  	if (ret < 0) {
  		pr_err("Failed to set rate %dkHz: %d\n",
++<<<<<<< HEAD
 +		       freqs.new, ret);
 +		goto err;
 +	}
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
++=======
+ 		       new_freq, ret);
+ 		return ret;
+ 	}
+ 
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  #ifdef CONFIG_REGULATOR
- 	if (vddarm && freqs.new < freqs.old) {
+ 	if (vddarm && new_freq < old_freq) {
  		ret = regulator_set_voltage(vddarm,
  					    dvfs->vddarm_min,
  					    dvfs->vddarm_max);
diff --cc drivers/cpufreq/s5pv210-cpufreq.c
index 5c7757073793,e3973dae28a7..000000000000
--- a/drivers/cpufreq/s5pv210-cpufreq.c
+++ b/drivers/cpufreq/s5pv210-cpufreq.c
@@@ -190,14 -172,13 +189,15 @@@ static unsigned int s5pv210_getspeed(un
  	return clk_get_rate(cpu_clk) / 1000;
  }
  
 -static int s5pv210_target(struct cpufreq_policy *policy, unsigned int index)
 +static int s5pv210_target(struct cpufreq_policy *policy,
 +			  unsigned int target_freq,
 +			  unsigned int relation)
  {
  	unsigned long reg;
 -	unsigned int priv_index;
 +	unsigned int index, priv_index;
  	unsigned int pll_changing = 0;
  	unsigned int bus_speed_changing = 0;
+ 	unsigned int old_freq, new_freq;
  	int arm_volt, int_volt;
  	int ret = 0;
  
@@@ -215,27 -193,13 +215,37 @@@
  		goto exit;
  	}
  
++<<<<<<< HEAD
 +	if (relation & DISABLE_FURTHER_CPUFREQ)
 +		no_cpufreq_access = true;
 +
 +	relation &= ~(ENABLE_FURTHER_CPUFREQ | DISABLE_FURTHER_CPUFREQ);
 +
 +	freqs.old = s5pv210_getspeed(0);
 +
 +	if (cpufreq_frequency_table_target(policy, s5pv210_freq_table,
 +					   target_freq, relation, &index)) {
 +		ret = -EINVAL;
 +		goto exit;
 +	}
 +
 +	freqs.new = s5pv210_freq_table[index].frequency;
++=======
+ 	old_freq = s5pv210_getspeed(0);
+ 	new_freq = s5pv210_freq_table[index].frequency;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
 +
 +	if (freqs.new == freqs.old)
 +		goto exit;
  
  	/* Finding current running level index */
  	if (cpufreq_frequency_table_target(policy, s5pv210_freq_table,
++<<<<<<< HEAD
 +					   freqs.old, relation, &priv_index)) {
++=======
+ 					   old_freq, CPUFREQ_RELATION_H,
+ 					   &priv_index)) {
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  		ret = -EINVAL;
  		goto exit;
  	}
diff --cc drivers/cpufreq/sa1100-cpufreq.c
index cff18e87ca58,623da742f8e7..000000000000
--- a/drivers/cpufreq/sa1100-cpufreq.c
+++ b/drivers/cpufreq/sa1100-cpufreq.c
@@@ -177,41 -177,20 +177,43 @@@ static void sa1100_update_dram_timings(
  	}
  }
  
 -static int sa1100_target(struct cpufreq_policy *policy, unsigned int ppcr)
 +static int sa1100_target(struct cpufreq_policy *policy,
 +			 unsigned int target_freq,
 +			 unsigned int relation)
  {
  	unsigned int cur = sa11x0_getspeed(0);
++<<<<<<< HEAD
 +	unsigned int new_ppcr;
 +	struct cpufreq_freqs freqs;
 +
 +	new_ppcr = sa11x0_freq_to_ppcr(target_freq);
 +	switch (relation) {
 +	case CPUFREQ_RELATION_L:
 +		if (sa11x0_ppcr_to_freq(new_ppcr) > policy->max)
 +			new_ppcr--;
 +		break;
 +	case CPUFREQ_RELATION_H:
 +		if ((sa11x0_ppcr_to_freq(new_ppcr) > target_freq) &&
 +		    (sa11x0_ppcr_to_freq(new_ppcr - 1) >= policy->min))
 +			new_ppcr--;
 +		break;
 +	}
 +
 +	freqs.old = cur;
 +	freqs.new = sa11x0_ppcr_to_freq(new_ppcr);
++=======
+ 	unsigned int new_freq;
  
- 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
+ 	new_freq = sa11x0_freq_table[ppcr].frequency;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
- 	if (freqs.new > cur)
- 		sa1100_update_dram_timings(cur, freqs.new);
+ 	if (new_freq > cur)
+ 		sa1100_update_dram_timings(cur, new_freq);
  
 -	PPCR = ppcr;
 +	PPCR = new_ppcr;
  
- 	if (freqs.new < cur)
- 		sa1100_update_dram_timings(cur, freqs.new);
- 
- 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
+ 	if (new_freq < cur)
+ 		sa1100_update_dram_timings(cur, new_freq);
  
  	return 0;
  }
diff --cc drivers/cpufreq/sa1110-cpufreq.c
index 39c90b6f4286,2c2b2e601d13..000000000000
--- a/drivers/cpufreq/sa1110-cpufreq.c
+++ b/drivers/cpufreq/sa1110-cpufreq.c
@@@ -229,36 -229,14 +229,39 @@@ sdram_update_refresh(u_int cpu_khz, str
  /*
   * Ok, set the CPU frequency.
   */
 -static int sa1110_target(struct cpufreq_policy *policy, unsigned int ppcr)
 +static int sa1110_target(struct cpufreq_policy *policy,
 +			 unsigned int target_freq,
 +			 unsigned int relation)
  {
  	struct sdram_params *sdram = &sdram_params;
- 	struct cpufreq_freqs freqs;
  	struct sdram_info sd;
  	unsigned long flags;
 -	unsigned int unused;
 +	unsigned int ppcr, unused;
 +
 +	switch (relation) {
 +	case CPUFREQ_RELATION_L:
 +		ppcr = sa11x0_freq_to_ppcr(target_freq);
 +		if (sa11x0_ppcr_to_freq(ppcr) > policy->max)
 +			ppcr--;
 +		break;
 +	case CPUFREQ_RELATION_H:
 +		ppcr = sa11x0_freq_to_ppcr(target_freq);
 +		if (ppcr && (sa11x0_ppcr_to_freq(ppcr) > target_freq) &&
 +		    (sa11x0_ppcr_to_freq(ppcr-1) >= policy->min))
 +			ppcr--;
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +
++<<<<<<< HEAD
 +	freqs.old = sa11x0_getspeed(0);
 +	freqs.new = sa11x0_ppcr_to_freq(ppcr);
  
 +	sdram_calculate_timing(&sd, freqs.new, sdram);
++=======
+ 	sdram_calculate_timing(&sd, sa11x0_freq_table[ppcr].frequency, sdram);
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
  #if 0
  	/*
diff --cc drivers/cpufreq/sc520_freq.c
index 77a210975fc4,6adb354e359c..000000000000
--- a/drivers/cpufreq/sc520_freq.c
+++ b/drivers/cpufreq/sc520_freq.c
@@@ -53,21 -53,11 +53,12 @@@ static unsigned int sc520_freq_get_cpu_
  	}
  }
  
 -static int sc520_freq_target(struct cpufreq_policy *policy, unsigned int state)
 +static void sc520_freq_set_cpu_state(struct cpufreq_policy *policy,
 +		unsigned int state)
  {
  
- 	struct cpufreq_freqs	freqs;
  	u8 clockspeed_reg;
  
- 	freqs.old = sc520_freq_get_cpu_frequency(0);
- 	freqs.new = sc520_freq_table[state].frequency;
- 
- 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
- 
- 	pr_debug("attempting to set frequency to %i kHz\n",
- 			sc520_freq_table[state].frequency);
- 
  	local_irq_disable();
  
  	clockspeed_reg = *cpuctl & ~0x03;
@@@ -75,26 -65,6 +66,29 @@@
  
  	local_irq_enable();
  
++<<<<<<< HEAD
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +};
 +
 +static int sc520_freq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, &sc520_freq_table[0]);
 +}
 +
 +static int sc520_freq_target(struct cpufreq_policy *policy,
 +			    unsigned int target_freq,
 +			    unsigned int relation)
 +{
 +	unsigned int newstate = 0;
 +
 +	if (cpufreq_frequency_table_target(policy, sc520_freq_table,
 +				target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	sc520_freq_set_cpu_state(policy, newstate);
 +
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	return 0;
  }
  
diff --cc drivers/cpufreq/spear-cpufreq.c
index 156829f4576d,d02ccd19c9c4..000000000000
--- a/drivers/cpufreq/spear-cpufreq.c
+++ b/drivers/cpufreq/spear-cpufreq.c
@@@ -110,20 -105,14 +110,28 @@@ static int spear1340_set_cpu_rate(struc
  }
  
  static int spear_cpufreq_target(struct cpufreq_policy *policy,
 -		unsigned int index)
 +		unsigned int target_freq, unsigned int relation)
  {
++<<<<<<< HEAD
 +	struct cpufreq_freqs freqs;
 +	unsigned long newfreq;
++=======
+ 	long newfreq;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	struct clk *srcclk;
 -	int ret, mult = 1;
 +	int index, ret, mult = 1;
  
 +	if (cpufreq_frequency_table_target(policy, spear_cpufreq.freq_tbl,
 +				target_freq, relation, &index))
 +		return -EINVAL;
 +
++<<<<<<< HEAD
 +	freqs.old = spear_cpufreq_get(0);
++=======
+ 	newfreq = spear_cpufreq.freq_tbl[index].frequency * 1000;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
 +	newfreq = spear_cpufreq.freq_tbl[index].frequency * 1000;
  	if (of_machine_is_compatible("st,spear1340")) {
  		/*
  		 * SPEAr1340 is special in the sense that due to the possibility
diff --cc drivers/cpufreq/speedstep-centrino.c
index f897d5105842,4e1daca5ce3b..000000000000
--- a/drivers/cpufreq/speedstep-centrino.c
+++ b/drivers/cpufreq/speedstep-centrino.c
@@@ -449,15 -420,12 +449,19 @@@ static int centrino_verify (struct cpuf
   *
   * Sets a new CPUFreq policy.
   */
 -static int centrino_target(struct cpufreq_policy *policy, unsigned int index)
 +static int centrino_target (struct cpufreq_policy *policy,
 +			    unsigned int target_freq,
 +			    unsigned int relation)
  {
 +	unsigned int    newstate = 0;
  	unsigned int	msr, oldmsr = 0, h = 0, cpu = policy->cpu;
- 	struct cpufreq_freqs	freqs;
  	int			retval = 0;
++<<<<<<< HEAD
 +	unsigned int		j, first_cpu, tmp;
++=======
+ 	unsigned int		j, first_cpu;
+ 	struct cpufreq_frequency_table *op_points;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  	cpumask_var_t covered_cpus;
  
  	if (unlikely(!zalloc_cpumask_var(&covered_cpus, GFP_KERNEL)))
@@@ -512,15 -472,6 +516,18 @@@
  				goto out;
  			}
  
++<<<<<<< HEAD
 +			freqs.old = extract_clock(oldmsr, cpu, 0);
 +			freqs.new = extract_clock(msr, cpu, 0);
 +
 +			pr_debug("target=%dkHz old=%d new=%d msr=%04x\n",
 +				target_freq, freqs.old, freqs.new, msr);
 +
 +			cpufreq_notify_transition(policy, &freqs,
 +					CPUFREQ_PRECHANGE);
 +
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  			first_cpu = 0;
  			/* all but 16 LSB are reserved, treat them with care */
  			oldmsr &= ~0xffff;
diff --cc drivers/cpufreq/speedstep-ich.c
index 5355abb69afc,7639b2be2a90..000000000000
--- a/drivers/cpufreq/speedstep-ich.c
+++ b/drivers/cpufreq/speedstep-ich.c
@@@ -257,34 -255,15 +257,39 @@@ static unsigned int speedstep_get(unsig
   *
   * Sets a new CPUFreq policy.
   */
 -static int speedstep_target(struct cpufreq_policy *policy, unsigned int index)
 +static int speedstep_target(struct cpufreq_policy *policy,
 +			     unsigned int target_freq,
 +			     unsigned int relation)
  {
++<<<<<<< HEAD
 +	unsigned int newstate = 0, policy_cpu;
 +	struct cpufreq_freqs freqs;
++=======
+ 	unsigned int policy_cpu;
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
 +
 +	if (cpufreq_frequency_table_target(policy, &speedstep_freqs[0],
 +				target_freq, relation, &newstate))
 +		return -EINVAL;
  
  	policy_cpu = cpumask_any_and(policy->cpus, cpu_online_mask);
++<<<<<<< HEAD
 +	freqs.old = speedstep_get(policy_cpu);
 +	freqs.new = speedstep_freqs[newstate].frequency;
 +
 +	pr_debug("transiting from %u to %u kHz\n", freqs.old, freqs.new);
 +
 +	/* no transition necessary */
 +	if (freqs.old == freqs.new)
 +		return 0;
  
 -	smp_call_function_single(policy_cpu, _speedstep_set_state, &index,
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
++=======
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
 +
 +	smp_call_function_single(policy_cpu, _speedstep_set_state, &newstate,
  				 true);
  
- 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
- 
  	return 0;
  }
  
diff --cc drivers/cpufreq/speedstep-smi.c
index abfba4f731eb,0f5326d6f79f..000000000000
--- a/drivers/cpufreq/speedstep-smi.c
+++ b/drivers/cpufreq/speedstep-smi.c
@@@ -240,25 -239,9 +240,29 @@@ static void speedstep_set_state(unsigne
   *
   * Sets a new CPUFreq policy/freq.
   */
 -static int speedstep_target(struct cpufreq_policy *policy, unsigned int index)
 +static int speedstep_target(struct cpufreq_policy *policy,
 +			unsigned int target_freq, unsigned int relation)
  {
++<<<<<<< HEAD
 +	unsigned int newstate = 0;
 +	struct cpufreq_freqs freqs;
 +
 +	if (cpufreq_frequency_table_target(policy, &speedstep_freqs[0],
 +				target_freq, relation, &newstate))
 +		return -EINVAL;
 +
 +	freqs.old = speedstep_freqs[speedstep_get_state()].frequency;
 +	freqs.new = speedstep_freqs[newstate].frequency;
 +
 +	if (freqs.old == freqs.new)
 +		return 0;
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +	speedstep_set_state(newstate);
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
++=======
+ 	speedstep_set_state(index);
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
  	return 0;
  }
diff --cc drivers/cpufreq/tegra-cpufreq.c
index c74c0e130ef4,f42df7ec03c5..000000000000
--- a/drivers/cpufreq/tegra-cpufreq.c
+++ b/drivers/cpufreq/tegra-cpufreq.c
@@@ -127,23 -117,12 +123,30 @@@ static int tegra_update_cpu_speed(struc
  	else
  		clk_set_rate(emc_clk, 100000000);  /* emc 50Mhz */
  
++<<<<<<< HEAD
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +
 +#ifdef CONFIG_CPU_FREQ_DEBUG
 +	printk(KERN_DEBUG "cpufreq-tegra: transition: %u --> %u\n",
 +	       freqs.old, freqs.new);
 +#endif
 +
 +	ret = tegra_cpu_clk_set_rate(freqs.new * 1000);
 +	if (ret) {
 +		pr_err("cpu-tegra: Failed to set cpu frequency to %d kHz\n",
 +			freqs.new);
 +		return ret;
 +	}
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
++=======
+ 	ret = tegra_cpu_clk_set_rate(rate * 1000);
+ 	if (ret)
+ 		pr_err("cpu-tegra: Failed to set cpu frequency to %lu kHz\n",
+ 			rate);
++>>>>>>> d4019f0a92ab (cpufreq: move freq change notifications to cpufreq core)
  
 -	return ret;
 +	return 0;
  }
  
  static unsigned long tegra_cpu_highest_speed(void)
* Unmerged path drivers/cpufreq/ppc-corenet-cpufreq.c
* Unmerged path drivers/cpufreq/acpi-cpufreq.c
* Unmerged path drivers/cpufreq/arm_big_little.c
* Unmerged path drivers/cpufreq/at32ap-cpufreq.c
* Unmerged path drivers/cpufreq/blackfin-cpufreq.c
* Unmerged path drivers/cpufreq/cpufreq-cpu0.c
* Unmerged path drivers/cpufreq/cpufreq.c
* Unmerged path drivers/cpufreq/cris-artpec3-cpufreq.c
* Unmerged path drivers/cpufreq/cris-etraxfs-cpufreq.c
* Unmerged path drivers/cpufreq/davinci-cpufreq.c
* Unmerged path drivers/cpufreq/dbx500-cpufreq.c
* Unmerged path drivers/cpufreq/e_powersaver.c
* Unmerged path drivers/cpufreq/elanfreq.c
* Unmerged path drivers/cpufreq/exynos-cpufreq.c
diff --git a/drivers/cpufreq/ia64-acpi-cpufreq.c b/drivers/cpufreq/ia64-acpi-cpufreq.c
index c0075dbaa633..11f5d2ecc6df 100644
--- a/drivers/cpufreq/ia64-acpi-cpufreq.c
+++ b/drivers/cpufreq/ia64-acpi-cpufreq.c
@@ -141,7 +141,6 @@ processor_set_freq (
 {
 	int			ret = 0;
 	u32			value = 0;
-	struct cpufreq_freqs    cpufreq_freqs;
 	cpumask_t		saved_mask;
 	int			retval;
 
@@ -168,13 +167,6 @@ processor_set_freq (
 	pr_debug("Transitioning from P%d to P%d\n",
 		data->acpi_data.state, state);
 
-	/* cpufreq frequency struct */
-	cpufreq_freqs.old = data->freq_table[data->acpi_data.state].frequency;
-	cpufreq_freqs.new = data->freq_table[state].frequency;
-
-	/* notify cpufreq */
-	cpufreq_notify_transition(policy, &cpufreq_freqs, CPUFREQ_PRECHANGE);
-
 	/*
 	 * First we write the target state's 'control' value to the
 	 * control_register.
@@ -186,22 +178,11 @@ processor_set_freq (
 
 	ret = processor_set_pstate(value);
 	if (ret) {
-		unsigned int tmp = cpufreq_freqs.new;
-		cpufreq_notify_transition(policy, &cpufreq_freqs,
-				CPUFREQ_POSTCHANGE);
-		cpufreq_freqs.new = cpufreq_freqs.old;
-		cpufreq_freqs.old = tmp;
-		cpufreq_notify_transition(policy, &cpufreq_freqs,
-				CPUFREQ_PRECHANGE);
-		cpufreq_notify_transition(policy, &cpufreq_freqs,
-				CPUFREQ_POSTCHANGE);
 		printk(KERN_WARNING "Transition failed with error %d\n", ret);
 		retval = -ENODEV;
 		goto migrate_end;
 	}
 
-	cpufreq_notify_transition(policy, &cpufreq_freqs, CPUFREQ_POSTCHANGE);
-
 	data->acpi_data.state = state;
 
 	retval = 0;
* Unmerged path drivers/cpufreq/imx6q-cpufreq.c
* Unmerged path drivers/cpufreq/kirkwood-cpufreq.c
* Unmerged path drivers/cpufreq/loongson2_cpufreq.c
* Unmerged path drivers/cpufreq/maple-cpufreq.c
* Unmerged path drivers/cpufreq/omap-cpufreq.c
* Unmerged path drivers/cpufreq/p4-clockmod.c
* Unmerged path drivers/cpufreq/pasemi-cpufreq.c
* Unmerged path drivers/cpufreq/pmac32-cpufreq.c
* Unmerged path drivers/cpufreq/pmac64-cpufreq.c
* Unmerged path drivers/cpufreq/ppc-corenet-cpufreq.c
* Unmerged path drivers/cpufreq/ppc_cbe_cpufreq.c
* Unmerged path drivers/cpufreq/pxa2xx-cpufreq.c
* Unmerged path drivers/cpufreq/pxa3xx-cpufreq.c
diff --git a/drivers/cpufreq/s3c2416-cpufreq.c b/drivers/cpufreq/s3c2416-cpufreq.c
index 4f1881eee3f1..7dbca1772464 100644
--- a/drivers/cpufreq/s3c2416-cpufreq.c
+++ b/drivers/cpufreq/s3c2416-cpufreq.c
@@ -231,7 +231,7 @@ static int s3c2416_cpufreq_set_target(struct cpufreq_policy *policy,
 				      unsigned int relation)
 {
 	struct s3c2416_data *s3c_freq = &s3c2416_cpufreq;
-	struct cpufreq_freqs freqs;
+	unsigned int new_freq;
 	int idx, ret, to_dvs = 0;
 	unsigned int i;
 
@@ -256,25 +256,14 @@ static int s3c2416_cpufreq_set_target(struct cpufreq_policy *policy,
 		goto out;
 	}
 
-	freqs.flags = 0;
-	freqs.old = s3c_freq->is_dvs ? FREQ_DVS
-				     : clk_get_rate(s3c_freq->armclk) / 1000;
-
 	/* When leavin dvs mode, always switch the armdiv to the hclk rate
 	 * The S3C2416 has stability issues when switching directly to
 	 * higher frequencies.
 	 */
-	freqs.new = (s3c_freq->is_dvs && !to_dvs)
+	new_freq = (s3c_freq->is_dvs && !to_dvs)
 				? clk_get_rate(s3c_freq->hclk) / 1000
 				: s3c_freq->freq_table[i].frequency;
 
-	pr_debug("cpufreq: Transition %d-%dkHz\n", freqs.old, freqs.new);
-
-	if (!to_dvs && freqs.old == freqs.new)
-		goto out;
-
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
-
 	if (to_dvs) {
 		pr_debug("cpufreq: enter dvs\n");
 		ret = s3c2416_cpufreq_enter_dvs(s3c_freq, idx);
@@ -282,12 +271,10 @@ static int s3c2416_cpufreq_set_target(struct cpufreq_policy *policy,
 		pr_debug("cpufreq: leave dvs\n");
 		ret = s3c2416_cpufreq_leave_dvs(s3c_freq, idx);
 	} else {
-		pr_debug("cpufreq: change armdiv to %dkHz\n", freqs.new);
-		ret = s3c2416_cpufreq_set_armdiv(s3c_freq, freqs.new);
+		pr_debug("cpufreq: change armdiv to %dkHz\n", new_freq);
+		ret = s3c2416_cpufreq_set_armdiv(s3c_freq, new_freq);
 	}
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
-
 out:
 	mutex_unlock(&cpufreq_lock);
 
* Unmerged path drivers/cpufreq/s3c64xx-cpufreq.c
* Unmerged path drivers/cpufreq/s5pv210-cpufreq.c
* Unmerged path drivers/cpufreq/sa1100-cpufreq.c
* Unmerged path drivers/cpufreq/sa1110-cpufreq.c
* Unmerged path drivers/cpufreq/sc520_freq.c
diff --git a/drivers/cpufreq/sparc-us2e-cpufreq.c b/drivers/cpufreq/sparc-us2e-cpufreq.c
index 306ae462bba6..5de825e40488 100644
--- a/drivers/cpufreq/sparc-us2e-cpufreq.c
+++ b/drivers/cpufreq/sparc-us2e-cpufreq.c
@@ -252,7 +252,6 @@ static void us2e_set_cpu_divider_index(struct cpufreq_policy *policy,
 	unsigned long new_bits, new_freq;
 	unsigned long clock_tick, divisor, old_divisor, estar;
 	cpumask_t cpus_allowed;
-	struct cpufreq_freqs freqs;
 
 	cpumask_copy(&cpus_allowed, tsk_cpus_allowed(current));
 	set_cpus_allowed_ptr(current, cpumask_of(cpu));
@@ -266,16 +265,10 @@ static void us2e_set_cpu_divider_index(struct cpufreq_policy *policy,
 
 	old_divisor = estar_to_divisor(estar);
 
-	freqs.old = clock_tick / old_divisor;
-	freqs.new = new_freq;
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
-
 	if (old_divisor != divisor)
 		us2e_transition(estar, new_bits, clock_tick * 1000,
 				old_divisor, divisor);
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
-
 	set_cpus_allowed_ptr(current, &cpus_allowed);
 }
 
diff --git a/drivers/cpufreq/sparc-us3-cpufreq.c b/drivers/cpufreq/sparc-us3-cpufreq.c
index c71ee142347a..acdc8a8d46a0 100644
--- a/drivers/cpufreq/sparc-us3-cpufreq.c
+++ b/drivers/cpufreq/sparc-us3-cpufreq.c
@@ -99,7 +99,6 @@ static void us3_set_cpu_divider_index(struct cpufreq_policy *policy,
 	unsigned int cpu = policy->cpu;
 	unsigned long new_bits, new_freq, reg;
 	cpumask_t cpus_allowed;
-	struct cpufreq_freqs freqs;
 
 	cpumask_copy(&cpus_allowed, tsk_cpus_allowed(current));
 	set_cpus_allowed_ptr(current, cpumask_of(cpu));
@@ -125,16 +124,10 @@ static void us3_set_cpu_divider_index(struct cpufreq_policy *policy,
 
 	reg = read_safari_cfg();
 
-	freqs.old = get_current_freq(cpu, reg);
-	freqs.new = new_freq;
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
-
 	reg &= ~SAFARI_CFG_DIV_MASK;
 	reg |= new_bits;
 	write_safari_cfg(reg);
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
-
 	set_cpus_allowed_ptr(current, &cpus_allowed);
 }
 
* Unmerged path drivers/cpufreq/spear-cpufreq.c
* Unmerged path drivers/cpufreq/speedstep-centrino.c
* Unmerged path drivers/cpufreq/speedstep-ich.c
* Unmerged path drivers/cpufreq/speedstep-smi.c
* Unmerged path drivers/cpufreq/tegra-cpufreq.c
