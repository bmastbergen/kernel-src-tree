perf tools: Allocate thread map_groups's dynamically

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf: Allocate thread map_groups's dynamically (Jiri Olsa) [1134356]
Rebuild_FUZZ: 93.88%
commit-author Arnaldo Carvalho de Melo <acme@redhat.com>
commit 93d5731dcb5b8cb7fa56ee11a5891f10c96c2a45
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/93d5731d.failed

Moving towards sharing map groups within a process threads.

Because of this we need the map groups to be dynamically allocated. No
other functional change is intended in here.

Based on a patch by Jiri Olsa, but this time _just_ making the
conversion from statically allocating thread->mg to turning it into a
pointer and instead of initializing it at thread's constructor,
introduce a constructor/destructor for the map_groups class and
call at thread creation time.

Later we will introduce the get/put methods when we move to sharing
those map_groups, when the get/put refcounting semantics will be needed.

	Signed-off-by: Arnaldo Carvalho de Melo <acme@kernel.org>
	Acked-by: Namhyung Kim <namhyung@kernel.org>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Don Zickus <dzickus@redhat.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Mike Galbraith <efault@gmx.de>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Stephane Eranian <eranian@google.com>
Link: http://lkml.kernel.org/r/1397490723-1992-3-git-send-email-jolsa@redhat.com
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
(cherry picked from commit 93d5731dcb5b8cb7fa56ee11a5891f10c96c2a45)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/arch/x86/tests/dwarf-unwind.c
#	tools/perf/util/event.c
diff --cc tools/perf/util/event.c
index 12958f641271,dbcaea1a8180..000000000000
--- a/tools/perf/util/event.c
+++ b/tools/perf/util/event.c
@@@ -699,10 -699,11 +699,14 @@@ void thread__find_addr_map(struct threa
  			   enum map_type type, u64 addr,
  			   struct addr_location *al)
  {
++<<<<<<< HEAD
 +	struct map_groups *mg = &self->mg;
++=======
+ 	struct map_groups *mg = thread->mg;
++>>>>>>> 93d5731dcb5b (perf tools: Allocate thread map_groups's dynamically)
  	bool load_map = false;
  
 -	al->machine = machine;
 -	al->thread = thread;
 +	al->thread = self;
  	al->addr = addr;
  	al->cpumode = cpumode;
  	al->filtered = 0;
* Unmerged path tools/perf/arch/x86/tests/dwarf-unwind.c
* Unmerged path tools/perf/arch/x86/tests/dwarf-unwind.c
diff --git a/tools/perf/ui/stdio/hist.c b/tools/perf/ui/stdio/hist.c
index 38ab1b4aee31..0706ee626884 100644
--- a/tools/perf/ui/stdio/hist.c
+++ b/tools/perf/ui/stdio/hist.c
@@ -497,7 +497,7 @@ print_entries:
 			break;
 
 		if (h->ms.map == NULL && verbose > 1) {
-			__map_groups__fprintf_maps(&h->thread->mg,
+			__map_groups__fprintf_maps(h->thread->mg,
 						   MAP__FUNCTION, verbose, fp);
 			fprintf(fp, "%.10s end\n", graph_dotted_line);
 		}
* Unmerged path tools/perf/util/event.c
diff --git a/tools/perf/util/map.c b/tools/perf/util/map.c
index 3305ccfeb0d7..313ec9824ee2 100644
--- a/tools/perf/util/map.c
+++ b/tools/perf/util/map.c
@@ -358,6 +358,22 @@ void map_groups__exit(struct map_groups *mg)
 	}
 }
 
+struct map_groups *map_groups__new(void)
+{
+	struct map_groups *mg = malloc(sizeof(*mg));
+
+	if (mg != NULL)
+		map_groups__init(mg);
+
+	return mg;
+}
+
+void map_groups__delete(struct map_groups *mg)
+{
+	map_groups__exit(mg);
+	free(mg);
+}
+
 void map_groups__flush(struct map_groups *mg)
 {
 	int type;
diff --git a/tools/perf/util/map.h b/tools/perf/util/map.h
index 257e513205ce..372dcb7f5ee2 100644
--- a/tools/perf/util/map.h
+++ b/tools/perf/util/map.h
@@ -61,6 +61,9 @@ struct map_groups {
 	struct machine	 *machine;
 };
 
+struct map_groups *map_groups__new(void);
+void map_groups__delete(struct map_groups *mg);
+
 static inline struct kmap *map__kmap(struct map *map)
 {
 	return (struct kmap *)(map + 1);
diff --git a/tools/perf/util/thread.c b/tools/perf/util/thread.c
index 3ce0498bdae6..dc51d1632e92 100644
--- a/tools/perf/util/thread.c
+++ b/tools/perf/util/thread.c
@@ -15,7 +15,10 @@ struct thread *thread__new(pid_t pid, pid_t tid)
 	struct thread *thread = zalloc(sizeof(*thread));
 
 	if (thread != NULL) {
-		map_groups__init(&thread->mg);
+		thread->mg = map_groups__new();
+		if (thread->mg == NULL)
+			goto out_free;
+
 		thread->pid_ = pid;
 		thread->tid = tid;
 		thread->ppid = -1;
@@ -37,6 +40,8 @@ struct thread *thread__new(pid_t pid, pid_t tid)
 	return thread;
 
 err_thread:
+	map_groups__delete(thread->mg);
+out_free:
 	free(thread);
 	return NULL;
 }
@@ -45,7 +50,8 @@ void thread__delete(struct thread *thread)
 {
 	struct comm *comm, *tmp;
 
-	map_groups__exit(&thread->mg);
+	map_groups__delete(thread->mg);
+	thread->mg = NULL;
 	list_for_each_entry_safe(comm, tmp, &thread->comm_list, list) {
 		list_del(&comm->list);
 		comm__free(comm);
@@ -111,13 +117,13 @@ int thread__comm_len(struct thread *thread)
 size_t thread__fprintf(struct thread *thread, FILE *fp)
 {
 	return fprintf(fp, "Thread %d %s\n", thread->tid, thread__comm_str(thread)) +
-	       map_groups__fprintf(&thread->mg, verbose, fp);
+	       map_groups__fprintf(thread->mg, verbose, fp);
 }
 
 void thread__insert_map(struct thread *thread, struct map *map)
 {
-	map_groups__fixup_overlappings(&thread->mg, map, verbose, stderr);
-	map_groups__insert(&thread->mg, map);
+	map_groups__fixup_overlappings(thread->mg, map, verbose, stderr);
+	map_groups__insert(thread->mg, map);
 }
 
 int thread__fork(struct thread *thread, struct thread *parent, u64 timestamp)
@@ -135,7 +141,7 @@ int thread__fork(struct thread *thread, struct thread *parent, u64 timestamp)
 	}
 
 	for (i = 0; i < MAP__NR_TYPES; ++i)
-		if (map_groups__clone(&thread->mg, &parent->mg, i) < 0)
+		if (map_groups__clone(thread->mg, parent->mg, i) < 0)
 			return -ENOMEM;
 
 	thread->ppid = parent->tid;
diff --git a/tools/perf/util/thread.h b/tools/perf/util/thread.h
index 8d4dfb992c91..f7dc0b1dddfb 100644
--- a/tools/perf/util/thread.h
+++ b/tools/perf/util/thread.h
@@ -13,7 +13,7 @@ struct thread {
 		struct rb_node	 rb_node;
 		struct list_head node;
 	};
-	struct map_groups	mg;
+	struct map_groups	*mg;
 	pid_t			pid_; /* Not all tools update this */
 	pid_t			tid;
 	pid_t			ppid;
