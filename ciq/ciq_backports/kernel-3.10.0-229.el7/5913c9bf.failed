iommu/vt-d: Make domain_add_dev_info() take struct device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Make domain_add_dev_info() take struct device (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 94.44%
commit-author David Woodhouse <David.Woodhouse@intel.com>
commit 5913c9bf0efecfa869375af8b4619529d3464038
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5913c9bf.failed

	Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
(cherry picked from commit 5913c9bf0efecfa869375af8b4619529d3464038)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index bd20ea6166e6,2333f36f4866..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -2340,35 -2470,24 +2340,48 @@@ static int identity_mapping(struct devi
  }
  
  static int domain_add_dev_info(struct dmar_domain *domain,
- 			       struct pci_dev *pdev,
- 			       int translation)
+ 			       struct device *dev, int translation)
  {
 -	struct dmar_domain *ndomain;
 -	struct intel_iommu *iommu;
 -	u8 bus, devfn;
 +	struct device_domain_info *info;
 +	unsigned long flags;
  	int ret;
  
++<<<<<<< HEAD
 +	info = alloc_devinfo_mem();
 +	if (!info)
 +		return -ENOMEM;
 +
 +	info->segment = pci_domain_nr(pdev->bus);
 +	info->bus = pdev->bus->number;
 +	info->devfn = pdev->devfn;
 +	info->dev = pdev;
 +	info->domain = domain;
 +
 +	spin_lock_irqsave(&device_domain_lock, flags);
 +	list_add(&info->link, &domain->devices);
 +	list_add(&info->global, &device_domain_list);
 +	pdev->dev.archdata.iommu = info;
 +	spin_unlock_irqrestore(&device_domain_lock, flags);
 +
 +	ret = domain_context_mapping(domain, pdev, translation);
 +	if (ret) {
 +		spin_lock_irqsave(&device_domain_lock, flags);
 +		unlink_domain_info(info);
 +		spin_unlock_irqrestore(&device_domain_lock, flags);
 +		free_devinfo_mem(info);
++=======
+ 	iommu = device_to_iommu(dev, &bus, &devfn);
+ 	if (!iommu)
+ 		return -ENODEV;
+ 
+ 	ndomain = dmar_insert_dev_info(iommu, bus, devfn, dev, domain);
+ 	if (ndomain != domain)
+ 		return -EBUSY;
+ 
+ 	ret = domain_context_mapping(domain, dev, translation);
+ 	if (ret) {
+ 		domain_remove_one_dev_info(domain, dev);
++>>>>>>> 5913c9bf0efe (iommu/vt-d: Make domain_add_dev_info() take struct device)
  		return ret;
  	}
  
@@@ -2474,8 -2605,8 +2487,13 @@@ static int __init iommu_prepare_static_
  		return -EFAULT;
  
  	for_each_pci_dev(pdev) {
++<<<<<<< HEAD
 +		if (iommu_should_identity_map(pdev, 1)) {
 +			ret = domain_add_dev_info(si_domain, pdev,
++=======
+ 		if (iommu_should_identity_map(&pdev->dev, 1)) {
+ 			ret = domain_add_dev_info(si_domain, &pdev->dev,
++>>>>>>> 5913c9bf0efe (iommu/vt-d: Make domain_add_dev_info() take struct device)
  					     hw ? CONTEXT_TT_PASS_THROUGH :
  						  CONTEXT_TT_MULTI_LEVEL);
  			if (ret) {
@@@ -2829,9 -2937,9 +2847,9 @@@ static int iommu_no_mapping(struct devi
  		 * In case of a detached 64 bit DMA device from vm, the device
  		 * is put into si_domain for identity mapping.
  		 */
 -		if (iommu_should_identity_map(&pdev->dev, 0)) {
 +		if (iommu_should_identity_map(pdev, 0)) {
  			int ret;
- 			ret = domain_add_dev_info(si_domain, pdev,
+ 			ret = domain_add_dev_info(si_domain, dev,
  						  hw_pass_through ?
  						  CONTEXT_TT_PASS_THROUGH :
  						  CONTEXT_TT_MULTI_LEVEL);
* Unmerged path drivers/iommu/intel-iommu.c
