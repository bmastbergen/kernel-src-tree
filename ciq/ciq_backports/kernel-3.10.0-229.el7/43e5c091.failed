ACPI / hotplug / PCI: Merge hotplug event handling functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Merge hotplug event handling functions (Myron Stowe) [1114228]
Rebuild_FUZZ: 91.89%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 43e5c091c797616170b11f4a1b32ea8c81ad0100
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/43e5c091.failed

There are separate handling event functions for hotplug bridges and
for hotplug functions, but they may be combined into one common
hotplug event handling function which simplifies the code slightly.

That also allows a theoretical bug to be dealt with which in
principle may occur if a hotplug bridge is on a dock station, because
in that case the bridge-specific notification should be used instead
of the function-specific one, but the dock station always uses the
latter.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 43e5c091c797616170b11f4a1b32ea8c81ad0100)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index b5069ad47c47,e2f9ea03aece..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -57,12 -55,14 +57,16 @@@
  
  static LIST_HEAD(bridge_list);
  static DEFINE_MUTEX(bridge_mutex);
 -static DEFINE_MUTEX(acpiphp_context_lock);
 -
 -#define MY_NAME "acpiphp_glue"
  
 -static void handle_hotplug_event(acpi_handle handle, u32 type, void *data);
 +static void handle_hotplug_event_bridge (acpi_handle, u32, void *);
  static void acpiphp_sanitize_bus(struct pci_bus *bus);
  static void acpiphp_set_hpp_values(struct pci_bus *bus);
++<<<<<<< HEAD
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context);
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type, void *context);
++=======
+ static void hotplug_event(acpi_handle handle, u32 type, void *data);
++>>>>>>> 43e5c091c797 (ACPI / hotplug / PCI: Merge hotplug event handling functions)
  static void free_bridge(struct kref *kref);
  
  /* callback routine to check for the existence of a pci dock device */
@@@ -119,11 -199,10 +123,16 @@@ static void free_bridge(struct kref *kr
   * TBD - figure out a way to only call fixups for
   * systems that require them.
   */
 -static void post_dock_fixups(acpi_handle not_used, u32 event, void *data)
 +static int post_dock_fixups(struct notifier_block *nb, unsigned long val,
 +	void *v)
  {
++<<<<<<< HEAD
 +	struct acpiphp_func *func = container_of(nb, struct acpiphp_func, nb);
 +	struct pci_bus *bus = func->slot->bridge->pci_bus;
++=======
+ 	struct acpiphp_context *context = data;
+ 	struct pci_bus *bus = context->func->slot->bridge->pci_bus;
++>>>>>>> 43e5c091c797 (ACPI / hotplug / PCI: Merge hotplug event handling functions)
  	u32 buses;
  
  	if (!bus->self)
@@@ -148,7 -226,8 +157,12 @@@
  
  
  static const struct acpi_dock_ops acpiphp_dock_ops = {
++<<<<<<< HEAD
 +	.handler = hotplug_event_func,
++=======
+ 	.fixup = post_dock_fixups,
+ 	.handler = hotplug_event,
++>>>>>>> 43e5c091c797 (ACPI / hotplug / PCI: Merge hotplug event handling functions)
  };
  
  /* Check whether the PCI device is managed by native PCIe hotplug driver */
@@@ -313,17 -406,9 +327,17 @@@ register_slot(acpi_handle handle, u32 l
  		 */
  		newfunc->flags &= ~FUNC_HAS_EJ0;
  		if (register_hotplug_dock_device(handle,
- 			&acpiphp_dock_ops, newfunc,
+ 			&acpiphp_dock_ops, context,
  			acpiphp_dock_init, acpiphp_dock_release))
 -			dbg("failed to register dock device\n");
 +			pr_debug("failed to register dock device\n");
 +
 +		/* we need to be notified when dock events happen
 +		 * outside of the hotplug operation, since we may
 +		 * need to do fixups before we can hotplug.
 +		 */
 +		newfunc->nb.notifier_call = post_dock_fixups;
 +		if (register_dock_notifier(&newfunc->nb))
 +			pr_debug("failed to register a dock notifier");
  	}
  
  	/* install notify handler */
@@@ -984,40 -987,52 +998,76 @@@ void acpiphp_check_host_bridge(acpi_han
  		ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
  }
  
- static void _handle_hotplug_event_bridge(struct work_struct *work)
+ static void hotplug_event(acpi_handle handle, u32 type, void *data)
  {
++<<<<<<< HEAD
++=======
+ 	struct acpiphp_context *context = data;
++>>>>>>> 43e5c091c797 (ACPI / hotplug / PCI: Merge hotplug event handling functions)
  	struct acpiphp_bridge *bridge;
+ 	struct acpiphp_func *func;
  	char objname[64];
  	struct acpi_buffer buffer = { .length = sizeof(objname),
  				      .pointer = objname };
- 	struct acpi_hp_work *hp_work;
- 	acpi_handle handle;
- 	u32 type;
  
++<<<<<<< HEAD
 +	hp_work = container_of(work, struct acpi_hp_work, work);
 +	handle = hp_work->handle;
 +	type = hp_work->type;
 +	bridge = (struct acpiphp_bridge *)hp_work->context;
++=======
+ 	mutex_lock(&acpiphp_context_lock);
+ 	bridge = context->bridge;
+ 	if (bridge)
+ 		get_bridge(bridge);
++>>>>>>> 43e5c091c797 (ACPI / hotplug / PCI: Merge hotplug event handling functions)
  
- 	acpi_scan_lock_acquire();
+ 	/*
+ 	 * If context->func is not NULL, we are holding a reference to its
+ 	 * parent bridge, so it won't go away until we drop that reference.
+ 	 */
+ 	func = context->func;
+ 	mutex_unlock(&acpiphp_context_lock);
  
  	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
  
  	switch (type) {
  	case ACPI_NOTIFY_BUS_CHECK:
  		/* bus re-enumerate */
++<<<<<<< HEAD
 +		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
 +		pr_debug("%s: re-enumerating slots under %s\n",
 +			 __func__, objname);
 +		acpiphp_check_bridge(bridge);
 +		acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
 +			ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
++=======
+ 		dbg("%s: Bus check notify on %s\n", __func__, objname);
+ 		dbg("%s: re-enumerating slots under %s\n", __func__, objname);
+ 		if (bridge) {
+ 			acpiphp_check_bridge(bridge);
+ 			acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
+ 					    ACPI_UINT32_MAX, check_sub_bridges,
+ 					    NULL, NULL, NULL);
+ 		} else {
+ 			acpiphp_enable_slot(func->slot);
+ 		}
++>>>>>>> 43e5c091c797 (ACPI / hotplug / PCI: Merge hotplug event handling functions)
  		break;
  
  	case ACPI_NOTIFY_DEVICE_CHECK:
  		/* device check */
++<<<<<<< HEAD
 +		pr_debug("%s: Device check notify on %s\n", __func__, objname);
 +		acpiphp_check_bridge(bridge);
++=======
+ 		dbg("%s: Device check notify on %s\n", __func__, objname);
+ 		if (bridge)
+ 			acpiphp_check_bridge(bridge);
+ 		else
+ 			acpiphp_check_bridge(func->slot->bridge);
+ 
++>>>>>>> 43e5c091c797 (ACPI / hotplug / PCI: Merge hotplug event handling functions)
  		break;
  
  	case ACPI_NOTIFY_DEVICE_WAKE:
@@@ -1027,13 -1042,16 +1077,26 @@@
  
  	case ACPI_NOTIFY_EJECT_REQUEST:
  		/* request device eject */
++<<<<<<< HEAD
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {
 +			struct acpiphp_slot *slot;
 +			slot = bridge->func->slot;
 +			if (!acpiphp_disable_slot(slot))
 +				acpiphp_eject_slot(slot);
 +		}
++=======
+ 		dbg("%s: Device eject notify on %s\n", __func__, objname);
+ 		if (!func)
+ 			break;
+ 
+ 		if (bridge && !(bridge->flags & BRIDGE_HAS_EJ0))
+ 			break;
+ 
+ 		if (!(acpiphp_disable_slot(func->slot)))
+ 			acpiphp_eject_slot(func->slot);
+ 
++>>>>>>> 43e5c091c797 (ACPI / hotplug / PCI: Merge hotplug event handling functions)
  		break;
  
  	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
@@@ -1052,94 -1070,36 +1115,117 @@@
  		break;
  
  	default:
++<<<<<<< HEAD
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
++=======
+ 		warn("notify_handler: unknown event type 0x%x for %s\n", type,
+ 		     objname);
++>>>>>>> 43e5c091c797 (ACPI / hotplug / PCI: Merge hotplug event handling functions)
  		break;
  	}
  
- 	acpi_scan_lock_release();
- 	kfree(hp_work); /* allocated in handle_hotplug_event_bridge */
- 	put_bridge(bridge);
+ 	if (bridge)
+ 		put_bridge(bridge);
  }
  
++<<<<<<< HEAD
 +/**
 + * handle_hotplug_event_bridge - handle ACPI event on bridges
 + * @handle: Notify()'ed acpi_handle
 + * @type: Notify code
 + * @context: pointer to acpiphp_bridge structure
 + *
 + * Handles ACPI event notification on {host,p2p} bridges.
 + */
 +static void handle_hotplug_event_bridge(acpi_handle handle, u32 type,
 +					void *context)
 +{
 +	struct acpiphp_bridge *bridge = context;
 +
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_bridge);
 +}
 +
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context)
 +{
 +	struct acpiphp_func *func = context;
 +	char objname[64];
 +	struct acpi_buffer buffer = { .length = sizeof(objname),
 +				      .pointer = objname };
 +
 +	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 +
 +	switch (type) {
 +	case ACPI_NOTIFY_BUS_CHECK:
 +		/* bus re-enumerate */
 +		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
 +		acpiphp_enable_slot(func->slot);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_CHECK:
 +		/* device check : re-enumerate from parent bus */
 +		pr_debug("%s: Device check notify on %s\n", __func__, objname);
 +		acpiphp_check_bridge(func->slot->bridge);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_WAKE:
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
 +		break;
 +
 +	case ACPI_NOTIFY_EJECT_REQUEST:
 +		/* request device eject */
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if (!(acpiphp_disable_slot(func->slot)))
 +			acpiphp_eject_slot(func->slot);
 +		break;
 +
 +	default:
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
 +		break;
 +	}
 +}
 +
 +static void _handle_hotplug_event_func(struct work_struct *work)
++=======
+ static void hotplug_event_work(struct work_struct *work)
++>>>>>>> 43e5c091c797 (ACPI / hotplug / PCI: Merge hotplug event handling functions)
  {
 -	struct acpiphp_context *context;
  	struct acpi_hp_work *hp_work;
 +	struct acpiphp_func *func;
  
  	hp_work = container_of(work, struct acpi_hp_work, work);
 -	context = hp_work->context;
 +	func = hp_work->context;
  	acpi_scan_lock_acquire();
  
++<<<<<<< HEAD
 +	hotplug_event_func(hp_work->handle, hp_work->type, func);
 +
 +	acpi_scan_lock_release();
 +	kfree(hp_work); /* allocated in handle_hotplug_event_func */
 +	put_bridge(func->slot->bridge);
++=======
+ 	hotplug_event(hp_work->handle, hp_work->type, context);
+ 
+ 	acpi_scan_lock_release();
+ 	kfree(hp_work); /* allocated in handle_hotplug_event() */
+ 
+ 	mutex_lock(&acpiphp_context_lock);
+ 	if (context->func)
+ 		put_bridge(context->func->slot->bridge);
+ 	else
+ 		acpiphp_put_context(context);
+ 
+ 	mutex_unlock(&acpiphp_context_lock);
++>>>>>>> 43e5c091c797 (ACPI / hotplug / PCI: Merge hotplug event handling functions)
  }
  
  /**
@@@ -1150,11 -1110,22 +1236,28 @@@
   *
   * Handles ACPI event notification on slots.
   */
 -static void handle_hotplug_event(acpi_handle handle, u32 type, void *data)
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type,
 +				      void *context)
  {
++<<<<<<< HEAD
 +	struct acpiphp_func *func = context;
 +
++=======
+ 	struct acpiphp_context *context;
+ 
+ 	mutex_lock(&acpiphp_context_lock);
+ 	context = acpiphp_get_context(handle);
+ 	if (context) {
+ 		if (context->func) {
+ 			get_bridge(context->func->slot->bridge);
+ 			acpiphp_put_context(context);
+ 		} else if (!context->bridge) {
+ 			acpiphp_put_context(context);
+ 			context = NULL;
+ 		}
+ 	}
+ 	mutex_unlock(&acpiphp_context_lock);
++>>>>>>> 43e5c091c797 (ACPI / hotplug / PCI: Merge hotplug event handling functions)
  	/*
  	 * Currently the code adds all hotplug events to the kacpid_wq
  	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
@@@ -1163,8 -1134,8 +1266,13 @@@
  	 * For now just re-add this work to the kacpi_hotplug_wq so we
  	 * don't deadlock on hotplug actions.
  	 */
++<<<<<<< HEAD
 +	get_bridge(func->slot->bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_func);
++=======
+ 	if (context)
+ 		alloc_acpi_hp_work(handle, type, context, hotplug_event_work);
++>>>>>>> 43e5c091c797 (ACPI / hotplug / PCI: Merge hotplug event handling functions)
  }
  
  /*
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
