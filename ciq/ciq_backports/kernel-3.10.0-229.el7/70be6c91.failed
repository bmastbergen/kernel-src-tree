xfrm: Add xfrm_tunnel_skb_cb to the skb common buffer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit 70be6c91c86596ad2b60c73587880b47df170a41
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/70be6c91.failed

IPsec vti_rcv needs to remind the tunnel pointer to
check it later at the vti_rcv_cb callback. So add
this pointer to the IPsec common buffer, initialize
it and check it to avoid transport state matching of
a tunneled packet.

	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 70be6c91c86596ad2b60c73587880b47df170a41)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/xfrm.h
#	net/ipv4/xfrm4_protocol.c
diff --cc include/net/xfrm.h
index 94ce082b29dc,33112599fa47..000000000000
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@@ -590,11 -593,26 +590,25 @@@ struct xfrm_mgr 
  					   const struct xfrm_migrate *m,
  					   int num_bundles,
  					   const struct xfrm_kmaddress *k);
 -	bool			(*is_alive)(const struct km_event *c);
  };
  
 -int xfrm_register_km(struct xfrm_mgr *km);
 -int xfrm_unregister_km(struct xfrm_mgr *km);
 +extern int xfrm_register_km(struct xfrm_mgr *km);
 +extern int xfrm_unregister_km(struct xfrm_mgr *km);
  
+ struct xfrm_tunnel_skb_cb {
+ 	union {
+ 		struct inet_skb_parm h4;
+ 		struct inet6_skb_parm h6;
+ 	} header;
+ 
+ 	union {
+ 		struct ip_tunnel *ip4;
+ 		struct ip6_tnl *ip6;
+ 	} tunnel;
+ };
+ 
+ #define XFRM_TUNNEL_SKB_CB(__skb) ((struct xfrm_tunnel_skb_cb *)&((__skb)->cb[0]))
+ 
  /*
   * This structure is used for the duration where packets are being
   * transformed by IPsec.  As soon as the packet leaves IPsec the
@@@ -1486,38 -1515,49 +1491,45 @@@ extern int xfrm4_rcv(struct sk_buff *sk
  
  static inline int xfrm4_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi)
  {
++<<<<<<< HEAD
 +	return xfrm4_rcv_encap(skb, nexthdr, spi, 0);
++=======
+ 	XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;
+ 	XFRM_SPI_SKB_CB(skb)->family = AF_INET;
+ 	XFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);
+ 	return xfrm_input(skb, nexthdr, spi, 0);
 -}
 -
 -int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 -int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 -int xfrm4_output(struct sk_buff *skb);
 -int xfrm4_output_finish(struct sk_buff *skb);
 -int xfrm4_rcv_cb(struct sk_buff *skb, u8 protocol, int err);
 -int xfrm4_protocol_register(struct xfrm4_protocol *handler, unsigned char protocol);
 -int xfrm4_protocol_deregister(struct xfrm4_protocol *handler, unsigned char protocol);
 -int xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family);
 -int xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family);
 -void xfrm4_local_error(struct sk_buff *skb, u32 mtu);
 -int xfrm4_mode_tunnel_input_register(struct xfrm_tunnel_notifier *handler);
 -int xfrm4_mode_tunnel_input_deregister(struct xfrm_tunnel_notifier *handler);
 -int xfrm6_mode_tunnel_input_register(struct xfrm_tunnel_notifier *handler);
 -int xfrm6_mode_tunnel_input_deregister(struct xfrm_tunnel_notifier *handler);
 -int xfrm6_extract_header(struct sk_buff *skb);
 -int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb);
 -int xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi);
 -int xfrm6_transport_finish(struct sk_buff *skb, int async);
 -int xfrm6_rcv(struct sk_buff *skb);
 -int xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,
 -		     xfrm_address_t *saddr, u8 proto);
 -void xfrm6_local_error(struct sk_buff *skb, u32 mtu);
 -int xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family);
 -int xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler, unsigned short family);
 -__be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr);
 -__be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr);
 -int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 -int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 -int xfrm6_output(struct sk_buff *skb);
 -int xfrm6_output_finish(struct sk_buff *skb);
 -int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
 -			  u8 **prevhdr);
++>>>>>>> 70be6c91c865 (xfrm: Add xfrm_tunnel_skb_cb to the skb common buffer)
 +}
 +
 +extern int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_output(struct sk_buff *skb);
 +extern int xfrm4_output_finish(struct sk_buff *skb);
 +extern int xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family);
 +extern int xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family);
 +extern int xfrm4_mode_tunnel_input_register(struct xfrm_tunnel *handler);
 +extern int xfrm4_mode_tunnel_input_deregister(struct xfrm_tunnel *handler);
 +extern int xfrm6_extract_header(struct sk_buff *skb);
 +extern int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi);
 +extern int xfrm6_transport_finish(struct sk_buff *skb, int async);
 +extern int xfrm6_rcv(struct sk_buff *skb);
 +extern int xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,
 +			    xfrm_address_t *saddr, u8 proto);
 +extern int xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family);
 +extern int xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler, unsigned short family);
 +extern __be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr);
 +extern __be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr);
 +extern int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_output(struct sk_buff *skb);
 +extern int xfrm6_output_finish(struct sk_buff *skb);
 +extern int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
 +				 u8 **prevhdr);
  
  #ifdef CONFIG_XFRM
 -int xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);
 -int xfrm_user_policy(struct sock *sk, int optname,
 -		     u8 __user *optval, int optlen);
 +extern int xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);
 +extern int xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen);
  #else
  static inline int xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen)
  {
@@@ -1717,4 -1775,36 +1729,39 @@@ static inline int xfrm_mark_put(struct 
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static inline int xfrm_rcv_cb(struct sk_buff *skb, unsigned int family,
+ 			      u8 protocol, int err)
+ {
+ 	switch(family) {
+ #ifdef CONFIG_INET
+ 	case AF_INET:
+ 		return xfrm4_rcv_cb(skb, protocol, err);
+ #endif
+ 	}
+ 	return 0;
+ }
+ 
+ static inline int xfrm_tunnel_check(struct sk_buff *skb, struct xfrm_state *x,
+ 				    unsigned int family)
+ {
+ 	bool tunnel = false;
+ 
+ 	switch(family) {
+ 	case AF_INET:
+ 		if (XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4)
+ 			tunnel = true;
+ 		break;
+ 	case AF_INET6:
+ 		if (XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip6)
+ 			tunnel = true;
+ 		break;
+ 	}
+ 	if (tunnel && !(x->outer_mode->flags & XFRM_MODE_FLAG_TUNNEL))
+ 		return -EINVAL;
+ 
+ 	return 0;
+ }
++>>>>>>> 70be6c91c865 (xfrm: Add xfrm_tunnel_skb_cb to the skb common buffer)
  #endif	/* _NET_XFRM_H */
* Unmerged path net/ipv4/xfrm4_protocol.c
* Unmerged path include/net/xfrm.h
* Unmerged path net/ipv4/xfrm4_protocol.c
diff --git a/net/xfrm/xfrm_input.c b/net/xfrm/xfrm_input.c
index ab2bb42fe094..f7acf1901278 100644
--- a/net/xfrm/xfrm_input.c
+++ b/net/xfrm/xfrm_input.c
@@ -162,6 +162,11 @@ int xfrm_input(struct sk_buff *skb, int nexthdr, __be32 spi, int encap_type)
 
 		skb->sp->xvec[skb->sp->len++] = x;
 
+		if (xfrm_tunnel_check(skb, x, family)) {
+			XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEMODEERROR);
+			goto drop;
+		}
+
 		spin_lock(&x->lock);
 		if (unlikely(x->km.state != XFRM_STATE_VALID)) {
 			XFRM_INC_STATS(net, LINUX_MIB_XFRMINSTATEINVALID);
