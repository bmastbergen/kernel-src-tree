dm crypt: fix access beyond the end of allocated space

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [md] dm-crypt: fix access beyond the end of allocated space (Mike Snitzer) [1135066]
Rebuild_FUZZ: 98.15%
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit d49ec52ff6ddcda178fc2476a109cf1bd1fa19ed
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d49ec52f.failed

The DM crypt target accesses memory beyond allocated space resulting in
a crash on 32 bit x86 systems.

This bug is very old (it dates back to 2.6.25 commit 3a7f6c990ad04 "dm
crypt: use async crypto").  However, this bug was masked by the fact
that kmalloc rounds the size up to the next power of two.  This bug
wasn't exposed until 3.17-rc1 commit 298a9fa08a ("dm crypt: use per-bio
data").  By switching to using per-bio data there was no longer any
padding beyond the end of a dm-crypt allocated memory block.

To minimize allocation overhead dm-crypt puts several structures into one
block allocated with kmalloc.  The block holds struct ablkcipher_request,
cipher-specific scratch pad (crypto_ablkcipher_reqsize(any_tfm(cc))),
struct dm_crypt_request and an initialization vector.

The variable dmreq_start is set to offset of struct dm_crypt_request
within this memory block.  dm-crypt allocates the block with this size:
cc->dmreq_start + sizeof(struct dm_crypt_request) + cc->iv_size.

When accessing the initialization vector, dm-crypt uses the function
iv_of_dmreq, which performs this calculation: ALIGN((unsigned long)(dmreq
+ 1), crypto_ablkcipher_alignmask(any_tfm(cc)) + 1).

dm-crypt allocated "cc->iv_size" bytes beyond the end of dm_crypt_request
structure.  However, when dm-crypt accesses the initialization vector, it
takes a pointer to the end of dm_crypt_request, aligns it, and then uses
it as the initialization vector.  If the end of dm_crypt_request is not
aligned on a crypto_ablkcipher_alignmask(any_tfm(cc)) boundary the
alignment causes the initialization vector to point beyond the allocated
space.

Fix this bug by calculating the variable iv_size_padding and adding it
to the allocated size.

Also correct the alignment of dm_crypt_request.  struct dm_crypt_request
is specific to dm-crypt (it isn't used by the crypto subsystem at all),
so it is aligned on __alignof__(struct dm_crypt_request).

Also align per_bio_data_size on ARCH_KMALLOC_MINALIGN, so that it is
aligned as if the block was allocated with kmalloc.

	Reported-by: Krzysztof Kolasa <kkolasa@winsoft.pl>
	Tested-by: Milan Broz <gmazyland@gmail.com>
	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit d49ec52ff6ddcda178fc2476a109cf1bd1fa19ed)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-crypt.c
diff --cc drivers/md/dm-crypt.c
index ed4032c3eadc,cd15e0801228..000000000000
--- a/drivers/md/dm-crypt.c
+++ b/drivers/md/dm-crypt.c
@@@ -1741,6 -1747,11 +1753,14 @@@ static int crypt_ctr(struct dm_target *
  		goto bad;
  	}
  
++<<<<<<< HEAD
++=======
+ 	cc->per_bio_data_size = ti->per_bio_data_size =
+ 		ALIGN(sizeof(struct dm_crypt_io) + cc->dmreq_start +
+ 		      sizeof(struct dm_crypt_request) + iv_size_padding + cc->iv_size,
+ 		      ARCH_KMALLOC_MINALIGN);
+ 
++>>>>>>> d49ec52ff6dd (dm crypt: fix access beyond the end of allocated space)
  	cc->page_pool = mempool_create_page_pool(MIN_POOL_PAGES, 0);
  	if (!cc->page_pool) {
  		ti->error = "Cannot allocate page mempool";
* Unmerged path drivers/md/dm-crypt.c
