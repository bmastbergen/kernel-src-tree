KVM: nVMX: Unconditionally uninit the MMU on nested vmexit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/nvmx: Unconditionally uninit the MMU on nested vmexit (Paolo Bonzini) [1116936]
Rebuild_FUZZ: 97.39%
commit-author Jan Kiszka <jan.kiszka@web.de>
commit 29bf08f12b2fd72b882da0d85b7385e4a438a297
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/29bf08f1.failed

Three reasons for doing this: 1. arch.walk_mmu points to arch.mmu anyway
in case nested EPT wasn't in use. 2. this aligns VMX with SVM. But 3. is
most important: nested_cpu_has_ept(vmcs12) queries the VMCS page, and if
one guest VCPU manipulates the page of another VCPU in L2, we may be
fooled to skip over the nested_ept_uninit_mmu_context, leaving mmu in
nested state. That can crash the host later on if nested_ept_get_cr3 is
invoked while L1 already left vmxon and nested.current_vmcs12 became
NULL therefore.

	Cc: stable@kernel.org
	Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
	Signed-off-by: Marcelo Tosatti <mtosatti@redhat.com>
(cherry picked from commit 29bf08f12b2fd72b882da0d85b7385e4a438a297)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index b835df27f9ec,da7837e1349d..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -8226,7 -8283,8 +8226,12 @@@ static void load_vmcs12_host_state(stru
  	vcpu->arch.cr4_guest_owned_bits = ~vmcs_readl(CR4_GUEST_HOST_MASK);
  	kvm_set_cr4(vcpu, vmcs12->host_cr4);
  
++<<<<<<< HEAD
 +	/* shadow page tables on either EPT or shadow page tables */
++=======
+ 	nested_ept_uninit_mmu_context(vcpu);
+ 
++>>>>>>> 29bf08f12b2f (KVM: nVMX: Unconditionally uninit the MMU on nested vmexit)
  	kvm_set_cr3(vcpu, vmcs12->host_cr3);
  	kvm_mmu_reset_context(vcpu);
  
* Unmerged path arch/x86/kvm/vmx.c
