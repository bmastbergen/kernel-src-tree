net: ip: push gso skb forwarding handling down the stack

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] ip: push gso skb forwarding handling down the stack (Florian Westphal) [1109214]
Rebuild_FUZZ: 95.33%
commit-author Florian Westphal <fw@strlen.de>
commit c7ba65d7b64984ff371cb5630b36af23506c50d5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/c7ba65d7.failed

Doing the segmentation in the forward path has one major drawback:

When using virtio, we may process gso udp packets coming
from host network stack.  In that case, netfilter POSTROUTING
will see one packet with udp header followed by multiple ip
fragments.

Delay the segmentation and do it after POSTROUTING invocation
to avoid this.

Fixes: fe6cc55f3a9 ("net: ip, ipv6: handle gso skbs in forwarding path")
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit c7ba65d7b64984ff371cb5630b36af23506c50d5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ip_forward.c
#	net/ipv4/ip_output.c
diff --cc net/ipv4/ip_forward.c
index bd1c5baf69be,6f111e48e11c..000000000000
--- a/net/ipv4/ip_forward.c
+++ b/net/ipv4/ip_forward.c
@@@ -56,53 -56,6 +56,56 @@@ static bool ip_exceeds_mtu(const struc
  	return true;
  }
  
++<<<<<<< HEAD
 +static bool ip_gso_exceeds_dst_mtu(const struct sk_buff *skb)
 +{
 +	unsigned int mtu;
 +
 +	if (skb->local_df || !skb_is_gso(skb))
 +		return false;
 +
 +	mtu = dst_mtu(skb_dst(skb));
 +
 +	/* if seglen > mtu, do software segmentation for IP fragmentation on
 +	 * output.  DF bit cannot be set since ip_forward would have sent
 +	 * icmp error.
 +	 */
 +	return skb_gso_network_seglen(skb) > mtu;
 +}
 +
 +/* called if GSO skb needs to be fragmented on forward */
 +static int ip_forward_finish_gso(struct sk_buff *skb)
 +{
 +	struct dst_entry *dst = skb_dst(skb);
 +	netdev_features_t features;
 +	struct sk_buff *segs;
 +	int ret = 0;
 +
 +	features = netif_skb_dev_features(skb, dst->dev);
 +	segs = skb_gso_segment(skb, features & ~NETIF_F_GSO_MASK);
 +	if (IS_ERR(segs)) {
 +		kfree_skb(skb);
 +		return -ENOMEM;
 +	}
 +
 +	consume_skb(skb);
 +
 +	do {
 +		struct sk_buff *nskb = segs->next;
 +		int err;
 +
 +		segs->next = NULL;
 +		err = dst_output(segs);
 +
 +		if (err && ret == 0)
 +			ret = err;
 +		segs = nskb;
 +	} while (segs);
 +
 +	return ret;
 +}
++=======
++>>>>>>> c7ba65d7b649 (net: ip: push gso skb forwarding handling down the stack)
  
  static int ip_forward_finish(struct sk_buff *skb)
  {
diff --cc net/ipv4/ip_output.c
index 7c3233e7befc,a52f50187b54..000000000000
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@@ -211,12 -211,46 +211,55 @@@ static inline int ip_finish_output2(str
  	return -EINVAL;
  }
  
++<<<<<<< HEAD
 +static inline int ip_skb_dst_mtu(struct sk_buff *skb)
 +{
 +	struct inet_sock *inet = skb->sk ? inet_sk(skb->sk) : NULL;
 +
 +	return (inet && inet->pmtudisc == IP_PMTUDISC_PROBE) ?
 +	       skb_dst(skb)->dev->mtu : dst_mtu(skb_dst(skb));
++=======
+ static int ip_finish_output_gso(struct sk_buff *skb)
+ {
+ 	netdev_features_t features;
+ 	struct sk_buff *segs;
+ 	int ret = 0;
+ 
+ 	/* common case: locally created skb or seglen is <= mtu */
+ 	if (((IPCB(skb)->flags & IPSKB_FORWARDED) == 0) ||
+ 	      skb_gso_network_seglen(skb) <= ip_skb_dst_mtu(skb))
+ 		return ip_finish_output2(skb);
+ 
+ 	/* Slowpath -  GSO segment length is exceeding the dst MTU.
+ 	 *
+ 	 * This can happen in two cases:
+ 	 * 1) TCP GRO packet, DF bit not set
+ 	 * 2) skb arrived via virtio-net, we thus get TSO/GSO skbs directly
+ 	 * from host network stack.
+ 	 */
+ 	features = netif_skb_features(skb);
+ 	segs = skb_gso_segment(skb, features & ~NETIF_F_GSO_MASK);
+ 	if (IS_ERR(segs)) {
+ 		kfree_skb(skb);
+ 		return -ENOMEM;
+ 	}
+ 
+ 	consume_skb(skb);
+ 
+ 	do {
+ 		struct sk_buff *nskb = segs->next;
+ 		int err;
+ 
+ 		segs->next = NULL;
+ 		err = ip_fragment(segs, ip_finish_output2);
+ 
+ 		if (err && ret == 0)
+ 			ret = err;
+ 		segs = nskb;
+ 	} while (segs);
+ 
+ 	return ret;
++>>>>>>> c7ba65d7b649 (net: ip: push gso skb forwarding handling down the stack)
  }
  
  static int ip_finish_output(struct sk_buff *skb)
@@@ -228,15 -262,17 +271,18 @@@
  		return dst_output(skb);
  	}
  #endif
- 	if (skb->len > ip_skb_dst_mtu(skb) && !skb_is_gso(skb))
+ 	if (skb_is_gso(skb))
+ 		return ip_finish_output_gso(skb);
+ 
+ 	if (skb->len > ip_skb_dst_mtu(skb))
  		return ip_fragment(skb, ip_finish_output2);
- 	else
- 		return ip_finish_output2(skb);
+ 
+ 	return ip_finish_output2(skb);
  }
  
 -int ip_mc_output(struct sock *sk, struct sk_buff *skb)
 +int ip_mc_output(struct sk_buff *skb)
  {
 +	struct sock *sk = skb->sk;
  	struct rtable *rt = skb_rtable(skb);
  	struct net_device *dev = rt->dst.dev;
  
* Unmerged path net/ipv4/ip_forward.c
* Unmerged path net/ipv4/ip_output.c
