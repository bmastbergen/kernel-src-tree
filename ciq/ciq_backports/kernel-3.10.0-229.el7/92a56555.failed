nfs: Don't busy-wait on SIGKILL in __nfs_iocounter_wait

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author David Jeffery <djeffery@redhat.com>
commit 92a56555bd576c61b27a5cab9f38a33a1e9a1df5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/92a56555.failed

If a SIGKILL is sent to a task waiting in __nfs_iocounter_wait,
it will busy-wait or soft lockup in its while loop.
nfs_wait_bit_killable won't sleep, and the loop won't exit on
the error return.

Stop the busy-wait by breaking out of the loop when
nfs_wait_bit_killable returns an error.

	Signed-off-by: David Jeffery <djeffery@redhat.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 92a56555bd576c61b27a5cab9f38a33a1e9a1df5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pagelist.c
diff --cc fs/nfs/pagelist.c
index 5f18707a0319,be7cbce6e4c7..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -112,8 -115,8 +112,13 @@@ __nfs_iocounter_wait(struct nfs_io_coun
  		set_bit(NFS_IO_INPROGRESS, &c->flags);
  		if (atomic_read(&c->io_count) == 0)
  			break;
++<<<<<<< HEAD
 +		ret = nfs_wait_bit_killable(&c->flags);
 +	} while (atomic_read(&c->io_count) != 0);
++=======
+ 		ret = nfs_wait_bit_killable(&q.key);
+ 	} while (atomic_read(&c->io_count) != 0 && !ret);
++>>>>>>> 92a56555bd57 (nfs: Don't busy-wait on SIGKILL in __nfs_iocounter_wait)
  	finish_wait(wq, &q.wait);
  	return ret;
  }
* Unmerged path fs/nfs/pagelist.c
