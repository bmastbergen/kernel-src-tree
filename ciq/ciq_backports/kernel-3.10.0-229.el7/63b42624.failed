iommu/vt-d: Only call dmar_acpi_dev_scope_init() if DRHD units present

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Only call dmar_acpi_dev_scope_init() if DRHD units present (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 95.52%
commit-author David Woodhouse <David.Woodhouse@intel.com>
commit 63b4262478ee6384c7efb5279be54236e5d6361b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/63b42624.failed

As pointed out by Jörg and fixed in commit 11f1a7768 ("iommu/vt-d: Check
for NULL pointer in dmar_acpi_dev_scope_init(), this code path can
bizarrely get exercised even on AMD IOMMU systems with IRQ remapping
enabled.

In addition to the defensive check for NULL which Jörg added, let's also
just avoid calling the function at all if there aren't an Intel IOMMU
units in the system.

	Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
(cherry picked from commit 63b4262478ee6384c7efb5279be54236e5d6361b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/dmar.c
diff --cc drivers/iommu/dmar.c
index e2ae85c4b46e,142650e82979..000000000000
--- a/drivers/iommu/dmar.c
+++ b/drivers/iommu/dmar.c
@@@ -465,32 -692,37 +465,57 @@@ dmar_find_matched_drhd_unit(struct pci_
  
  int __init dmar_dev_scope_init(void)
  {
 -	struct pci_dev *dev = NULL;
 -	struct dmar_pci_notify_info *info;
 +	static int dmar_dev_scope_initialized;
 +	struct dmar_drhd_unit *drhd, *drhd_n;
 +	int ret = -ENODEV;
  
 -	if (dmar_dev_scope_status != 1)
 -		return dmar_dev_scope_status;
 +	if (dmar_dev_scope_initialized)
 +		return dmar_dev_scope_initialized;
  
++<<<<<<< HEAD
 +	if (list_empty(&dmar_drhd_units))
 +		goto fail;
 +
 +	list_for_each_entry_safe(drhd, drhd_n, &dmar_drhd_units, list) {
 +		ret = dmar_parse_dev(drhd);
 +		if (ret)
 +			goto fail;
++=======
+ 	if (list_empty(&dmar_drhd_units)) {
+ 		dmar_dev_scope_status = -ENODEV;
+ 	} else {
+ 		dmar_dev_scope_status = 0;
+ 
+ 		dmar_acpi_dev_scope_init();
+ 
+ 		for_each_pci_dev(dev) {
+ 			if (dev->is_virtfn)
+ 				continue;
+ 
+ 			info = dmar_alloc_pci_notify_info(dev,
+ 					BUS_NOTIFY_ADD_DEVICE);
+ 			if (!info) {
+ 				return dmar_dev_scope_status;
+ 			} else {
+ 				dmar_pci_bus_add_dev(info);
+ 				dmar_free_pci_notify_info(info);
+ 			}
+ 		}
+ 
+ 		bus_register_notifier(&pci_bus_type, &dmar_pci_bus_nb);
++>>>>>>> 63b4262478ee (iommu/vt-d: Only call dmar_acpi_dev_scope_init() if DRHD units present)
  	}
  
 -	return dmar_dev_scope_status;
 +	ret = dmar_parse_rmrr_atsr_dev();
 +	if (ret)
 +		goto fail;
 +
 +	dmar_dev_scope_initialized = 1;
 +	return 0;
 +
 +fail:
 +	dmar_dev_scope_initialized = ret;
 +	return ret;
  }
  
  
* Unmerged path drivers/iommu/dmar.c
