ext4: support RENAME_WHITEOUT

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit cd808deced431b66b5fa4e5c193cb7ec0059eaff
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/cd808dec.failed

Add whiteout support to ext4_rename().  A whiteout inode (chrdev/0,0) is
created before the rename takes place.  The whiteout inode is added to the
old entry instead of deleting it.

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
(cherry picked from commit cd808deced431b66b5fa4e5c193cb7ec0059eaff)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/namei.c
diff --cc fs/ext4/namei.c
index 02ee66b9dd7b,aba86e8ef1ef..000000000000
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@@ -3096,6 -3179,50 +3096,53 @@@ static void ext4_rename_delete(handle_
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static void ext4_update_dir_count(handle_t *handle, struct ext4_renament *ent)
+ {
+ 	if (ent->dir_nlink_delta) {
+ 		if (ent->dir_nlink_delta == -1)
+ 			ext4_dec_count(handle, ent->dir);
+ 		else
+ 			ext4_inc_count(handle, ent->dir);
+ 		ext4_mark_inode_dirty(handle, ent->dir);
+ 	}
+ }
+ 
+ static struct inode *ext4_whiteout_for_rename(struct ext4_renament *ent,
+ 					      int credits, handle_t **h)
+ {
+ 	struct inode *wh;
+ 	handle_t *handle;
+ 	int retries = 0;
+ 
+ 	/*
+ 	 * for inode block, sb block, group summaries,
+ 	 * and inode bitmap
+ 	 */
+ 	credits += (EXT4_MAXQUOTAS_TRANS_BLOCKS(ent->dir->i_sb) +
+ 		    EXT4_XATTR_TRANS_BLOCKS + 4);
+ retry:
+ 	wh = ext4_new_inode_start_handle(ent->dir, S_IFCHR | WHITEOUT_MODE,
+ 					 &ent->dentry->d_name, 0, NULL,
+ 					 EXT4_HT_DIR, credits);
+ 
+ 	handle = ext4_journal_current_handle();
+ 	if (IS_ERR(wh)) {
+ 		if (handle)
+ 			ext4_journal_stop(handle);
+ 		if (PTR_ERR(wh) == -ENOSPC &&
+ 		    ext4_should_retry_alloc(ent->dir->i_sb, &retries))
+ 			goto retry;
+ 	} else {
+ 		*h = handle;
+ 		init_special_inode(wh, wh->i_mode, WHITEOUT_DEV);
+ 		wh->i_op = &ext4_special_inode_operations;
+ 	}
+ 	return wh;
+ }
+ 
++>>>>>>> cd808deced43 (ext4: support RENAME_WHITEOUT)
  /*
   * Anybody can rename anything with this: the permission checks are left to the
   * higher-level routines.
@@@ -3243,11 -3402,155 +3315,158 @@@ end_rename
  	brelse(old.dir_bh);
  	brelse(old.bh);
  	brelse(new.bh);
+ 	if (whiteout) {
+ 		if (retval)
+ 			drop_nlink(whiteout);
+ 		unlock_new_inode(whiteout);
+ 		iput(whiteout);
+ 	}
+ 	if (handle)
+ 		ext4_journal_stop(handle);
+ 	return retval;
+ }
+ 
++<<<<<<< HEAD
++=======
+ static int ext4_cross_rename(struct inode *old_dir, struct dentry *old_dentry,
+ 			     struct inode *new_dir, struct dentry *new_dentry)
+ {
+ 	handle_t *handle = NULL;
+ 	struct ext4_renament old = {
+ 		.dir = old_dir,
+ 		.dentry = old_dentry,
+ 		.inode = old_dentry->d_inode,
+ 	};
+ 	struct ext4_renament new = {
+ 		.dir = new_dir,
+ 		.dentry = new_dentry,
+ 		.inode = new_dentry->d_inode,
+ 	};
+ 	u8 new_file_type;
+ 	int retval;
+ 
+ 	dquot_initialize(old.dir);
+ 	dquot_initialize(new.dir);
+ 
+ 	old.bh = ext4_find_entry(old.dir, &old.dentry->d_name,
+ 				 &old.de, &old.inlined);
+ 	if (IS_ERR(old.bh))
+ 		return PTR_ERR(old.bh);
+ 	/*
+ 	 *  Check for inode number is _not_ due to possible IO errors.
+ 	 *  We might rmdir the source, keep it as pwd of some process
+ 	 *  and merrily kill the link to whatever was created under the
+ 	 *  same name. Goodbye sticky bit ;-<
+ 	 */
+ 	retval = -ENOENT;
+ 	if (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)
+ 		goto end_rename;
+ 
+ 	new.bh = ext4_find_entry(new.dir, &new.dentry->d_name,
+ 				 &new.de, &new.inlined);
+ 	if (IS_ERR(new.bh)) {
+ 		retval = PTR_ERR(new.bh);
+ 		new.bh = NULL;
+ 		goto end_rename;
+ 	}
+ 
+ 	/* RENAME_EXCHANGE case: old *and* new must both exist */
+ 	if (!new.bh || le32_to_cpu(new.de->inode) != new.inode->i_ino)
+ 		goto end_rename;
+ 
+ 	handle = ext4_journal_start(old.dir, EXT4_HT_DIR,
+ 		(2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +
+ 		 2 * EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2));
+ 	if (IS_ERR(handle))
+ 		return PTR_ERR(handle);
+ 
+ 	if (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))
+ 		ext4_handle_sync(handle);
+ 
+ 	if (S_ISDIR(old.inode->i_mode)) {
+ 		old.is_dir = true;
+ 		retval = ext4_rename_dir_prepare(handle, &old);
+ 		if (retval)
+ 			goto end_rename;
+ 	}
+ 	if (S_ISDIR(new.inode->i_mode)) {
+ 		new.is_dir = true;
+ 		retval = ext4_rename_dir_prepare(handle, &new);
+ 		if (retval)
+ 			goto end_rename;
+ 	}
+ 
+ 	/*
+ 	 * Other than the special case of overwriting a directory, parents'
+ 	 * nlink only needs to be modified if this is a cross directory rename.
+ 	 */
+ 	if (old.dir != new.dir && old.is_dir != new.is_dir) {
+ 		old.dir_nlink_delta = old.is_dir ? -1 : 1;
+ 		new.dir_nlink_delta = -old.dir_nlink_delta;
+ 		retval = -EMLINK;
+ 		if ((old.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(old.dir)) ||
+ 		    (new.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(new.dir)))
+ 			goto end_rename;
+ 	}
+ 
+ 	new_file_type = new.de->file_type;
+ 	retval = ext4_setent(handle, &new, old.inode->i_ino, old.de->file_type);
+ 	if (retval)
+ 		goto end_rename;
+ 
+ 	retval = ext4_setent(handle, &old, new.inode->i_ino, new_file_type);
+ 	if (retval)
+ 		goto end_rename;
+ 
+ 	/*
+ 	 * Like most other Unix systems, set the ctime for inodes on a
+ 	 * rename.
+ 	 */
+ 	old.inode->i_ctime = ext4_current_time(old.inode);
+ 	new.inode->i_ctime = ext4_current_time(new.inode);
+ 	ext4_mark_inode_dirty(handle, old.inode);
+ 	ext4_mark_inode_dirty(handle, new.inode);
+ 
+ 	if (old.dir_bh) {
+ 		retval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);
+ 		if (retval)
+ 			goto end_rename;
+ 	}
+ 	if (new.dir_bh) {
+ 		retval = ext4_rename_dir_finish(handle, &new, old.dir->i_ino);
+ 		if (retval)
+ 			goto end_rename;
+ 	}
+ 	ext4_update_dir_count(handle, &old);
+ 	ext4_update_dir_count(handle, &new);
+ 	retval = 0;
+ 
+ end_rename:
+ 	brelse(old.dir_bh);
+ 	brelse(new.dir_bh);
+ 	brelse(old.bh);
+ 	brelse(new.bh);
  	if (handle)
  		ext4_journal_stop(handle);
  	return retval;
  }
  
+ static int ext4_rename2(struct inode *old_dir, struct dentry *old_dentry,
+ 			struct inode *new_dir, struct dentry *new_dentry,
+ 			unsigned int flags)
+ {
+ 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
+ 		return -EINVAL;
+ 
+ 	if (flags & RENAME_EXCHANGE) {
+ 		return ext4_cross_rename(old_dir, old_dentry,
+ 					 new_dir, new_dentry);
+ 	}
+ 
+ 	return ext4_rename(old_dir, old_dentry, new_dir, new_dentry, flags);
+ }
+ 
++>>>>>>> cd808deced43 (ext4: support RENAME_WHITEOUT)
  /*
   * directories can handle most operations...
   */
* Unmerged path fs/ext4/namei.c
