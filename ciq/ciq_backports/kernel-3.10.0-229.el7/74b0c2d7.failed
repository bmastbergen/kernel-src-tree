drm/i915, HD-audio: Don't continue probing when nomodeset is given

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [alsa] hd-audio: Don't continue probing i915 when nomodeset is given (Jaroslav Kysela) [1112200]
Rebuild_FUZZ: 88.19%
commit-author Takashi Iwai <tiwai@suse.de>
commit 74b0c2d75fb4cc89173944e6d8f9eb47aca0c343
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/74b0c2d7.failed

When a machine is booted with nomodeset option, i915 driver skips the
whole initialization.  Meanwhile, HD-audio tries to bind wth i915 just
by request_symbol() without knowing that the initialization was
skipped, and eventually it hits WARN_ON() in i915_request_power_well()
and i915_release_power_well() wrongly but still continues probing,
even though it doesn't work at all.

In this patch, both functions are changed to return an error in case
of uninitialized state instead of WARN_ON(), so that HD-audio driver
can give up HDMI controller initialization at the right time.

	Acked-by: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: <stable@vger.kernel.org> [3.15]
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 74b0c2d75fb4cc89173944e6d8f9eb47aca0c343)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_pm.c
diff --cc drivers/gpu/drm/i915/intel_pm.c
index 26c2ea3e985c,6463f0201cf2..000000000000
--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@@ -5316,52 -5733,323 +5316,76 @@@ static void __intel_set_power_well(stru
  			I915_WRITE(HSW_PWR_WELL_DRIVER, 0);
  			POSTING_READ(HSW_PWR_WELL_DRIVER);
  			DRM_DEBUG_KMS("Requesting to disable the power well\n");
 -		}
 -	}
 -}
 -
 -static void hsw_power_well_sync_hw(struct drm_i915_private *dev_priv,
 -				   struct i915_power_well *power_well)
 -{
 -	hsw_set_power_well(dev_priv, power_well, power_well->count > 0);
 -
 -	/*
 -	 * We're taking over the BIOS, so clear any requests made by it since
 -	 * the driver is in charge now.
 -	 */
 -	if (I915_READ(HSW_PWR_WELL_BIOS) & HSW_PWR_WELL_ENABLE_REQUEST)
 -		I915_WRITE(HSW_PWR_WELL_BIOS, 0);
 -}
 -
 -static void hsw_power_well_enable(struct drm_i915_private *dev_priv,
 -				  struct i915_power_well *power_well)
 -{
 -	hsw_set_power_well(dev_priv, power_well, true);
 -}
 -
 -static void hsw_power_well_disable(struct drm_i915_private *dev_priv,
 -				   struct i915_power_well *power_well)
 -{
 -	hsw_set_power_well(dev_priv, power_well, false);
 -}
 -
 -static void i9xx_always_on_power_well_noop(struct drm_i915_private *dev_priv,
 -					   struct i915_power_well *power_well)
 -{
 -}
 -
 -static bool i9xx_always_on_power_well_enabled(struct drm_i915_private *dev_priv,
 -					     struct i915_power_well *power_well)
 -{
 -	return true;
 -}
  
 -void __vlv_set_power_well(struct drm_i915_private *dev_priv,
 -			  enum punit_power_well power_well_id, bool enable)
 -{
 -	struct drm_device *dev = dev_priv->dev;
 -	u32 mask;
 -	u32 state;
 -	u32 ctrl;
 -	enum pipe pipe;
 -
 -	if (power_well_id == PUNIT_POWER_WELL_DPIO_CMN_BC) {
 -		if (enable) {
  			/*
 -			 * Enable the CRI clock source so we can get at the
 -			 * display and the reference clock for VGA
 -			 * hotplug / manual detection.
 +			 * After this, the registers on the pipes that are part
 +			 * of the power well will become zero, so we have to
 +			 * adjust our counters according to that.
 +			 *
 +			 * FIXME: Should we do this in general in
 +			 * drm_vblank_post_modeset?
  			 */
 -			I915_WRITE(DPLL(PIPE_B), I915_READ(DPLL(PIPE_B)) |
 -				   DPLL_REFA_CLK_ENABLE_VLV |
 -				   DPLL_INTEGRATED_CRI_CLK_VLV);
 -			udelay(1); /* >10ns for cmnreset, >0ns for sidereset */
 -		} else {
 -			for_each_pipe(pipe)
 -				assert_pll_disabled(dev_priv, pipe);
 -			/* Assert common reset */
 -			I915_WRITE(DPIO_CTL, I915_READ(DPIO_CTL) &
 -				   ~DPIO_CMNRST);
 +			spin_lock_irqsave(&dev->vbl_lock, irqflags);
 +			for_each_pipe(p)
 +				if (p != PIPE_A)
 +					dev->last_vblank[p] = 0;
 +			spin_unlock_irqrestore(&dev->vbl_lock, irqflags);
  		}
  	}
 -
 -	mask = PUNIT_PWRGT_MASK(power_well_id);
 -	state = enable ? PUNIT_PWRGT_PWR_ON(power_well_id) :
 -			 PUNIT_PWRGT_PWR_GATE(power_well_id);
 -
 -	mutex_lock(&dev_priv->rps.hw_lock);
 -
 -#define COND \
 -	((vlv_punit_read(dev_priv, PUNIT_REG_PWRGT_STATUS) & mask) == state)
 -
 -	if (COND)
 -		goto out;
 -
 -	ctrl = vlv_punit_read(dev_priv, PUNIT_REG_PWRGT_CTRL);
 -	ctrl &= ~mask;
 -	ctrl |= state;
 -	vlv_punit_write(dev_priv, PUNIT_REG_PWRGT_CTRL, ctrl);
 -
 -	if (wait_for(COND, 100))
 -		DRM_ERROR("timout setting power well state %08x (%08x)\n",
 -			  state,
 -			  vlv_punit_read(dev_priv, PUNIT_REG_PWRGT_CTRL));
 -
 -#undef COND
 -
 -out:
 -	mutex_unlock(&dev_priv->rps.hw_lock);
 -
 -	/*
 -	 * From VLV2A0_DP_eDP_DPIO_driver_vbios_notes_10.docx -
 -	 *  6.	De-assert cmn_reset/side_reset. Same as VLV X0.
 -	 *   a.	GUnit 0x2110 bit[0] set to 1 (def 0)
 -	 *   b.	The other bits such as sfr settings / modesel may all
 -	 *	be set to 0.
 -	 *
 -	 * This should only be done on init and resume from S3 with
 -	 * both PLLs disabled, or we risk losing DPIO and PLL
 -	 * synchronization.
 -	 */
 -	if (power_well_id == PUNIT_POWER_WELL_DPIO_CMN_BC && enable)
 -		I915_WRITE(DPIO_CTL, I915_READ(DPIO_CTL) | DPIO_CMNRST);
 -}
 -
 -static void vlv_set_power_well(struct drm_i915_private *dev_priv,
 -			       struct i915_power_well *power_well, bool enable)
 -{
 -	enum punit_power_well power_well_id = power_well->data;
 -
 -	__vlv_set_power_well(dev_priv, power_well_id, enable);
 -}
 -
 -static void vlv_power_well_sync_hw(struct drm_i915_private *dev_priv,
 -				   struct i915_power_well *power_well)
 -{
 -	vlv_set_power_well(dev_priv, power_well, power_well->count > 0);
 -}
 -
 -static void vlv_power_well_enable(struct drm_i915_private *dev_priv,
 -				  struct i915_power_well *power_well)
 -{
 -	vlv_set_power_well(dev_priv, power_well, true);
 -}
 -
 -static void vlv_power_well_disable(struct drm_i915_private *dev_priv,
 -				   struct i915_power_well *power_well)
 -{
 -	vlv_set_power_well(dev_priv, power_well, false);
 -}
 -
 -static bool vlv_power_well_enabled(struct drm_i915_private *dev_priv,
 -				   struct i915_power_well *power_well)
 -{
 -	int power_well_id = power_well->data;
 -	bool enabled = false;
 -	u32 mask;
 -	u32 state;
 -	u32 ctrl;
 -
 -	mask = PUNIT_PWRGT_MASK(power_well_id);
 -	ctrl = PUNIT_PWRGT_PWR_ON(power_well_id);
 -
 -	mutex_lock(&dev_priv->rps.hw_lock);
 -
 -	state = vlv_punit_read(dev_priv, PUNIT_REG_PWRGT_STATUS) & mask;
 -	/*
 -	 * We only ever set the power-on and power-gate states, anything
 -	 * else is unexpected.
 -	 */
 -	WARN_ON(state != PUNIT_PWRGT_PWR_ON(power_well_id) &&
 -		state != PUNIT_PWRGT_PWR_GATE(power_well_id));
 -	if (state == ctrl)
 -		enabled = true;
 -
 -	/*
 -	 * A transient state at this point would mean some unexpected party
 -	 * is poking at the power controls too.
 -	 */
 -	ctrl = vlv_punit_read(dev_priv, PUNIT_REG_PWRGT_CTRL) & mask;
 -	WARN_ON(ctrl != state);
 -
 -	mutex_unlock(&dev_priv->rps.hw_lock);
 -
 -	return enabled;
 -}
 -
 -static void vlv_display_power_well_enable(struct drm_i915_private *dev_priv,
 -					  struct i915_power_well *power_well)
 -{
 -	WARN_ON_ONCE(power_well->data != PUNIT_POWER_WELL_DISP2D);
 -
 -	vlv_set_power_well(dev_priv, power_well, true);
 -
 -	spin_lock_irq(&dev_priv->irq_lock);
 -	valleyview_enable_display_irqs(dev_priv);
 -	spin_unlock_irq(&dev_priv->irq_lock);
 -
 -	/*
 -	 * During driver initialization/resume we can avoid restoring the
 -	 * part of the HW/SW state that will be inited anyway explicitly.
 -	 */
 -	if (dev_priv->power_domains.initializing)
 -		return;
 -
 -	intel_hpd_init(dev_priv->dev);
 -
 -	i915_redisable_vga_power_on(dev_priv->dev);
 -}
 -
 -static void vlv_display_power_well_disable(struct drm_i915_private *dev_priv,
 -					   struct i915_power_well *power_well)
 -{
 -	WARN_ON_ONCE(power_well->data != PUNIT_POWER_WELL_DISP2D);
 -
 -	spin_lock_irq(&dev_priv->irq_lock);
 -	valleyview_disable_display_irqs(dev_priv);
 -	spin_unlock_irq(&dev_priv->irq_lock);
 -
 -	vlv_set_power_well(dev_priv, power_well, false);
  }
  
 -static void check_power_well_state(struct drm_i915_private *dev_priv,
 -				   struct i915_power_well *power_well)
 -{
 -	bool enabled = power_well->ops->is_enabled(dev_priv, power_well);
 -
 -	if (power_well->always_on || !i915.disable_power_well) {
 -		if (!enabled)
 -			goto mismatch;
 -
 -		return;
 -	}
 -
 -	if (enabled != (power_well->count > 0))
 -		goto mismatch;
 -
 -	return;
 -
 -mismatch:
 -	WARN(1, "state mismatch for '%s' (always_on %d hw state %d use-count %d disable_power_well %d\n",
 -		  power_well->name, power_well->always_on, enabled,
 -		  power_well->count, i915.disable_power_well);
 -}
 -
 -void intel_display_power_get(struct drm_i915_private *dev_priv,
 -			     enum intel_display_power_domain domain)
 -{
 -	struct i915_power_domains *power_domains;
 -	struct i915_power_well *power_well;
 -	int i;
 -
 -	intel_runtime_pm_get(dev_priv);
 -
 -	power_domains = &dev_priv->power_domains;
 -
 -	mutex_lock(&power_domains->lock);
 -
 -	for_each_power_well(i, power_well, BIT(domain), power_domains) {
 -		if (!power_well->count++) {
 -			DRM_DEBUG_KMS("enabling %s\n", power_well->name);
 -			power_well->ops->enable(dev_priv, power_well);
 -		}
 -
 -		check_power_well_state(dev_priv, power_well);
 -	}
 -
 -	power_domains->domain_use_count[domain]++;
 -
 -	mutex_unlock(&power_domains->lock);
 -}
 -
 -void intel_display_power_put(struct drm_i915_private *dev_priv,
 -			     enum intel_display_power_domain domain)
 -{
 -	struct i915_power_domains *power_domains;
 -	struct i915_power_well *power_well;
 -	int i;
 -
 -	power_domains = &dev_priv->power_domains;
 -
 -	mutex_lock(&power_domains->lock);
 -
 -	WARN_ON(!power_domains->domain_use_count[domain]);
 -	power_domains->domain_use_count[domain]--;
 -
 -	for_each_power_well_rev(i, power_well, BIT(domain), power_domains) {
 -		WARN_ON(!power_well->count);
 -
 -		if (!--power_well->count && i915.disable_power_well) {
 -			DRM_DEBUG_KMS("disabling %s\n", power_well->name);
 -			power_well->ops->disable(dev_priv, power_well);
 -		}
 -
 -		check_power_well_state(dev_priv, power_well);
 -	}
 -
 -	mutex_unlock(&power_domains->lock);
 -
 -	intel_runtime_pm_put(dev_priv);
 -}
 -
 -static struct i915_power_domains *hsw_pwr;
 +static struct i915_power_well *hsw_pwr;
  
  /* Display audio driver power well request */
- void i915_request_power_well(void)
+ int i915_request_power_well(void)
  {
++<<<<<<< HEAD
 +	if (WARN_ON(!hsw_pwr))
 +		return;
 +
 +	spin_lock_irq(&hsw_pwr->lock);
 +	if (!hsw_pwr->count++ &&
 +			!hsw_pwr->i915_request)
 +		__intel_set_power_well(hsw_pwr->device, true);
 +	spin_unlock_irq(&hsw_pwr->lock);
++=======
+ 	struct drm_i915_private *dev_priv;
+ 
+ 	if (!hsw_pwr)
+ 		return -ENODEV;
+ 
+ 	dev_priv = container_of(hsw_pwr, struct drm_i915_private,
+ 				power_domains);
+ 	intel_display_power_get(dev_priv, POWER_DOMAIN_AUDIO);
+ 	return 0;
++>>>>>>> 74b0c2d75fb4 (drm/i915, HD-audio: Don't continue probing when nomodeset is given)
  }
  EXPORT_SYMBOL_GPL(i915_request_power_well);
  
  /* Display audio driver power well release */
- void i915_release_power_well(void)
+ int i915_release_power_well(void)
  {
++<<<<<<< HEAD
 +	if (WARN_ON(!hsw_pwr))
 +		return;
 +
 +	spin_lock_irq(&hsw_pwr->lock);
 +	WARN_ON(!hsw_pwr->count);
 +	if (!--hsw_pwr->count &&
 +		       !hsw_pwr->i915_request)
 +		__intel_set_power_well(hsw_pwr->device, false);
 +	spin_unlock_irq(&hsw_pwr->lock);
++=======
+ 	struct drm_i915_private *dev_priv;
+ 
+ 	if (!hsw_pwr)
+ 		return -ENODEV;
+ 
+ 	dev_priv = container_of(hsw_pwr, struct drm_i915_private,
+ 				power_domains);
+ 	intel_display_power_put(dev_priv, POWER_DOMAIN_AUDIO);
+ 	return 0;
++>>>>>>> 74b0c2d75fb4 (drm/i915, HD-audio: Don't continue probing when nomodeset is given)
  }
  EXPORT_SYMBOL_GPL(i915_release_power_well);
  
* Unmerged path drivers/gpu/drm/i915/intel_pm.c
diff --git a/include/drm/i915_powerwell.h b/include/drm/i915_powerwell.h
index cfdc884405b7..2baba9996094 100644
--- a/include/drm/i915_powerwell.h
+++ b/include/drm/i915_powerwell.h
@@ -30,7 +30,7 @@
 #define _I915_POWERWELL_H_
 
 /* For use by hda_i915 driver */
-extern void i915_request_power_well(void);
-extern void i915_release_power_well(void);
+extern int i915_request_power_well(void);
+extern int i915_release_power_well(void);
 
 #endif				/* _I915_POWERWELL_H_ */
diff --git a/sound/pci/hda/hda_i915.c b/sound/pci/hda/hda_i915.c
index 76c13d5b3ca0..3ea8b980460e 100644
--- a/sound/pci/hda/hda_i915.c
+++ b/sound/pci/hda/hda_i915.c
@@ -22,20 +22,20 @@
 #include <drm/i915_powerwell.h>
 #include "hda_i915.h"
 
-static void (*get_power)(void);
-static void (*put_power)(void);
+static int (*get_power)(void);
+static int (*put_power)(void);
 
-void hda_display_power(bool enable)
+int hda_display_power(bool enable)
 {
 	if (!get_power || !put_power)
-		return;
+		return -ENODEV;
 
 	snd_printdd("HDA display power %s \n",
 			enable ? "Enable" : "Disable");
 	if (enable)
-		get_power();
+		return get_power();
 	else
-		put_power();
+		return put_power();
 }
 
 int hda_i915_init(void)
diff --git a/sound/pci/hda/hda_i915.h b/sound/pci/hda/hda_i915.h
index 5a63da2c53e5..bfd835f8f1aa 100644
--- a/sound/pci/hda/hda_i915.h
+++ b/sound/pci/hda/hda_i915.h
@@ -17,11 +17,11 @@
 #define __SOUND_HDA_I915_H
 
 #ifdef CONFIG_SND_HDA_I915
-void hda_display_power(bool enable);
+int hda_display_power(bool enable);
 int hda_i915_init(void);
 int hda_i915_exit(void);
 #else
-static inline void hda_display_power(bool enable) {}
+static inline int hda_display_power(bool enable) { return 0; }
 static inline int hda_i915_init(void)
 {
 	return -ENODEV;
diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c
index c74374a10f3c..25bbb9754528 100644
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@ -3593,8 +3593,13 @@ static int azx_probe_continue(struct azx *chip)
 			snd_printk(KERN_ERR SFX "Error request power-well from i915\n");
 			goto out_free;
 		}
+		err = hda_display_power(true);
+		if (err < 0) {
+			dev_err(chip->card->dev,
+				"Cannot turn on display power on i915\n");
+			goto out_free;
+		}
 #endif
-		hda_display_power(true);
 	}
 
 	err = azx_first_init(chip);
