hyperv: Add support for virtual Receive Side Scaling (vRSS)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Haiyang Zhang <haiyangz@microsoft.com>
commit 5b54dac856cb5bd6f33f4159012773e4a33704f7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5b54dac8.failed

This feature allows multiple channels to be used by each virtual NIC.
It is available on Hyper-V host 2012 R2.

	Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
	Reviewed-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5b54dac856cb5bd6f33f4159012773e4a33704f7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc.c
#	drivers/net/hyperv/netvsc_drv.c
#	drivers/net/hyperv/rndis_filter.c
diff --cc drivers/net/hyperv/hyperv_net.h
index a2561fea6d21,57eb3f906d64..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -29,8 -28,99 +29,98 @@@
  #include <linux/hyperv.h>
  #include <linux/rndis.h>
  
+ /* RSS related */
+ #define OID_GEN_RECEIVE_SCALE_CAPABILITIES 0x00010203  /* query only */
+ #define OID_GEN_RECEIVE_SCALE_PARAMETERS 0x00010204  /* query and set */
+ 
+ #define NDIS_OBJECT_TYPE_RSS_CAPABILITIES 0x88
+ #define NDIS_OBJECT_TYPE_RSS_PARAMETERS 0x89
+ 
+ #define NDIS_RECEIVE_SCALE_CAPABILITIES_REVISION_2 2
+ #define NDIS_RECEIVE_SCALE_PARAMETERS_REVISION_2 2
+ 
+ struct ndis_obj_header {
+ 	u8 type;
+ 	u8 rev;
+ 	u16 size;
+ } __packed;
+ 
+ /* ndis_recv_scale_cap/cap_flag */
+ #define NDIS_RSS_CAPS_MESSAGE_SIGNALED_INTERRUPTS 0x01000000
+ #define NDIS_RSS_CAPS_CLASSIFICATION_AT_ISR       0x02000000
+ #define NDIS_RSS_CAPS_CLASSIFICATION_AT_DPC       0x04000000
+ #define NDIS_RSS_CAPS_USING_MSI_X                 0x08000000
+ #define NDIS_RSS_CAPS_RSS_AVAILABLE_ON_PORTS      0x10000000
+ #define NDIS_RSS_CAPS_SUPPORTS_MSI_X              0x20000000
+ #define NDIS_RSS_CAPS_HASH_TYPE_TCP_IPV4          0x00000100
+ #define NDIS_RSS_CAPS_HASH_TYPE_TCP_IPV6          0x00000200
+ #define NDIS_RSS_CAPS_HASH_TYPE_TCP_IPV6_EX       0x00000400
+ 
+ struct ndis_recv_scale_cap { /* NDIS_RECEIVE_SCALE_CAPABILITIES */
+ 	struct ndis_obj_header hdr;
+ 	u32 cap_flag;
+ 	u32 num_int_msg;
+ 	u32 num_recv_que;
+ 	u16 num_indirect_tabent;
+ } __packed;
+ 
+ 
+ /* ndis_recv_scale_param flags */
+ #define NDIS_RSS_PARAM_FLAG_BASE_CPU_UNCHANGED     0x0001
+ #define NDIS_RSS_PARAM_FLAG_HASH_INFO_UNCHANGED    0x0002
+ #define NDIS_RSS_PARAM_FLAG_ITABLE_UNCHANGED       0x0004
+ #define NDIS_RSS_PARAM_FLAG_HASH_KEY_UNCHANGED     0x0008
+ #define NDIS_RSS_PARAM_FLAG_DISABLE_RSS            0x0010
+ 
+ /* Hash info bits */
+ #define NDIS_HASH_FUNC_TOEPLITZ 0x00000001
+ #define NDIS_HASH_IPV4          0x00000100
+ #define NDIS_HASH_TCP_IPV4      0x00000200
+ #define NDIS_HASH_IPV6          0x00000400
+ #define NDIS_HASH_IPV6_EX       0x00000800
+ #define NDIS_HASH_TCP_IPV6      0x00001000
+ #define NDIS_HASH_TCP_IPV6_EX   0x00002000
+ 
+ #define NDIS_RSS_INDIRECTION_TABLE_MAX_SIZE_REVISION_2 (128 * 4)
+ #define NDIS_RSS_HASH_SECRET_KEY_MAX_SIZE_REVISION_2   40
+ 
+ #define ITAB_NUM 128
+ #define HASH_KEYLEN NDIS_RSS_HASH_SECRET_KEY_MAX_SIZE_REVISION_2
+ extern u8 netvsc_hash_key[];
+ 
+ struct ndis_recv_scale_param { /* NDIS_RECEIVE_SCALE_PARAMETERS */
+ 	struct ndis_obj_header hdr;
+ 
+ 	/* Qualifies the rest of the information */
+ 	u16 flag;
+ 
+ 	/* The base CPU number to do receive processing. not used */
+ 	u16 base_cpu_number;
+ 
+ 	/* This describes the hash function and type being enabled */
+ 	u32 hashinfo;
+ 
+ 	/* The size of indirection table array */
+ 	u16 indirect_tabsize;
+ 
+ 	/* The offset of the indirection table from the beginning of this
+ 	 * structure
+ 	 */
+ 	u32 indirect_taboffset;
+ 
+ 	/* The size of the hash secret key */
+ 	u16 hashkey_size;
+ 
+ 	/* The offset of the secret key from the beginning of this structure */
+ 	u32 kashkey_offset;
+ 
+ 	u32 processor_masks_offset;
+ 	u32 num_processor_masks;
+ 	u32 processor_masks_entry_size;
+ };
+ 
  /* Fwd declaration */
  struct hv_netvsc_packet;
 -struct ndis_tcp_ip_checksum_info;
  
  /* Represent the xfer page packet which contains 1 or more netvsc packet */
  struct xferpage_packet {
@@@ -118,7 -213,9 +213,13 @@@ int netvsc_send(struct hv_device *devic
  void netvsc_linkstatus_callback(struct hv_device *device_obj,
  				unsigned int status);
  int netvsc_recv_callback(struct hv_device *device_obj,
++<<<<<<< HEAD
 +			struct hv_netvsc_packet *packet);
++=======
+ 			struct hv_netvsc_packet *packet,
+ 			struct ndis_tcp_ip_checksum_info *csum_info);
+ void netvsc_channel_cb(void *context);
++>>>>>>> 5b54dac856cb (hyperv: Add support for virtual Receive Side Scaling (vRSS))
  int rndis_filter_open(struct hv_device *dev);
  int rndis_filter_close(struct hv_device *dev);
  int rndis_filter_device_add(struct hv_device *dev,
@@@ -559,8 -653,20 +662,23 @@@ struct netvsc_device 
  
  	struct net_device *ndev;
  
+ 	struct vmbus_channel *chn_table[NR_CPUS];
+ 	u32 send_table[VRSS_SEND_TAB_SIZE];
+ 	u32 num_chn;
+ 	atomic_t queue_sends[NR_CPUS];
+ 
  	/* Holds rndis device info */
  	void *extension;
++<<<<<<< HEAD
++=======
+ 
+ 	int ring_size;
+ 
+ 	/* The primary channel callback buffer */
+ 	unsigned char cb_buffer[NETVSC_PACKET_SIZE];
+ 	/* The sub channel callback buffer */
+ 	unsigned char *sub_cb_buf;
++>>>>>>> 5b54dac856cb (hyperv: Add support for virtual Receive Side Scaling (vRSS))
  };
  
  /* NdisInitialize message */
diff --cc drivers/net/hyperv/netvsc.c
index 9cc0753cff9d,e7e77f12bc38..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -574,6 -597,8 +601,11 @@@ int netvsc_send(struct hv_device *devic
  }
  
  static void netvsc_send_recv_completion(struct hv_device *device,
++<<<<<<< HEAD
++=======
+ 					struct vmbus_channel *channel,
+ 					struct netvsc_device *net_device,
++>>>>>>> 5b54dac856cb (hyperv: Add support for virtual Receive Side Scaling (vRSS))
  					u64 transaction_id, u32 status)
  {
  	struct nvsp_message recvcompMessage;
@@@ -666,14 -692,16 +700,26 @@@ static void netvsc_receive_completion(v
  
  	/* Send a receive completion for the xfer page packet */
  	if (fsend_receive_comp)
++<<<<<<< HEAD
 +		netvsc_send_recv_completion(device, transaction_id, status);
 +
 +}
 +
 +static void netvsc_receive(struct hv_device *device,
 +			    struct vmpacket_descriptor *packet)
++=======
+ 		netvsc_send_recv_completion(device, channel, net_device,
+ 					    transaction_id, status);
+ 
+ }
+ 
+ static void netvsc_receive(struct netvsc_device *net_device,
+ 			struct vmbus_channel *channel,
+ 			struct hv_device *device,
+ 			struct vmpacket_descriptor *packet)
++>>>>>>> 5b54dac856cb (hyperv: Add support for virtual Receive Side Scaling (vRSS))
  {
 +	struct netvsc_device *net_device;
  	struct vmtransfer_page_packet_header *vmxferpage_packet;
  	struct nvsp_message *nvsp_packet;
  	struct hv_netvsc_packet *netvsc_packet = NULL;
@@@ -754,7 -779,7 +800,11 @@@
  		spin_unlock_irqrestore(&net_device->recv_pkt_list_lock,
  				       flags);
  
++<<<<<<< HEAD
 +		netvsc_send_recv_completion(device,
++=======
+ 		netvsc_send_recv_completion(device, channel, net_device,
++>>>>>>> 5b54dac856cb (hyperv: Add support for virtual Receive Side Scaling (vRSS))
  					    vmxferpage_packet->d.trans_id,
  					    NVSP_STAT_FAIL);
  
@@@ -819,19 -879,19 +905,30 @@@ void netvsc_channel_cb(void *context
  	int bufferlen = NETVSC_PACKET_SIZE;
  	struct net_device *ndev;
  
++<<<<<<< HEAD
 +	packet = kzalloc(NETVSC_PACKET_SIZE * sizeof(unsigned char),
 +			 GFP_ATOMIC);
 +	if (!packet)
 +		return;
 +	buffer = packet;
++=======
+ 	if (channel->primary_channel != NULL)
+ 		device = channel->primary_channel->device_obj;
+ 	else
+ 		device = channel->device_obj;
++>>>>>>> 5b54dac856cb (hyperv: Add support for virtual Receive Side Scaling (vRSS))
  
  	net_device = get_inbound_net_device(device);
  	if (!net_device)
 -		return;
 +		goto out;
  	ndev = net_device->ndev;
++<<<<<<< HEAD
++=======
+ 	buffer = get_per_channel_state(channel);
++>>>>>>> 5b54dac856cb (hyperv: Add support for virtual Receive Side Scaling (vRSS))
  
  	do {
- 		ret = vmbus_recvpacket_raw(device->channel, buffer, bufferlen,
+ 		ret = vmbus_recvpacket_raw(channel, buffer, bufferlen,
  					   &bytes_recvd, &request_id);
  		if (ret == 0) {
  			if (bytes_recvd > 0) {
@@@ -842,7 -903,12 +939,16 @@@
  					break;
  
  				case VM_PKT_DATA_USING_XFER_PAGES:
++<<<<<<< HEAD
 +					netvsc_receive(device, desc);
++=======
+ 					netvsc_receive(net_device, channel,
+ 						       device, desc);
+ 					break;
+ 
+ 				case VM_PKT_DATA_INBAND:
+ 					netvsc_send_table(device, desc);
++>>>>>>> 5b54dac856cb (hyperv: Add support for virtual Receive Side Scaling (vRSS))
  					break;
  
  				default:
diff --cc drivers/net/hyperv/netvsc_drv.c
index 854b31f1a85a,093cf3fc46b8..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -129,6 -128,109 +129,112 @@@ static int netvsc_close(struct net_devi
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static void *init_ppi_data(struct rndis_message *msg, u32 ppi_size,
+ 				int pkt_type)
+ {
+ 	struct rndis_packet *rndis_pkt;
+ 	struct rndis_per_packet_info *ppi;
+ 
+ 	rndis_pkt = &msg->msg.pkt;
+ 	rndis_pkt->data_offset += ppi_size;
+ 
+ 	ppi = (struct rndis_per_packet_info *)((void *)rndis_pkt +
+ 		rndis_pkt->per_pkt_info_offset + rndis_pkt->per_pkt_info_len);
+ 
+ 	ppi->size = ppi_size;
+ 	ppi->type = pkt_type;
+ 	ppi->ppi_offset = sizeof(struct rndis_per_packet_info);
+ 
+ 	rndis_pkt->per_pkt_info_len += ppi_size;
+ 
+ 	return ppi;
+ }
+ 
+ union sub_key {
+ 	u64 k;
+ 	struct {
+ 		u8 pad[3];
+ 		u8 kb;
+ 		u32 ka;
+ 	};
+ };
+ 
+ /* Toeplitz hash function
+  * data: network byte order
+  * return: host byte order
+  */
+ static u32 comp_hash(u8 *key, int klen, u8 *data, int dlen)
+ {
+ 	union sub_key subk;
+ 	int k_next = 4;
+ 	u8 dt;
+ 	int i, j;
+ 	u32 ret = 0;
+ 
+ 	subk.k = 0;
+ 	subk.ka = ntohl(*(u32 *)key);
+ 
+ 	for (i = 0; i < dlen; i++) {
+ 		subk.kb = key[k_next];
+ 		k_next = (k_next + 1) % klen;
+ 		dt = data[i];
+ 		for (j = 0; j < 8; j++) {
+ 			if (dt & 0x80)
+ 				ret ^= subk.ka;
+ 			dt <<= 1;
+ 			subk.k <<= 1;
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static bool netvsc_set_hash(u32 *hash, struct sk_buff *skb)
+ {
+ 	struct iphdr *iphdr;
+ 	int data_len;
+ 	bool ret = false;
+ 
+ 	if (eth_hdr(skb)->h_proto != htons(ETH_P_IP))
+ 		return false;
+ 
+ 	iphdr = ip_hdr(skb);
+ 
+ 	if (iphdr->version == 4) {
+ 		if (iphdr->protocol == IPPROTO_TCP)
+ 			data_len = 12;
+ 		else
+ 			data_len = 8;
+ 		*hash = comp_hash(netvsc_hash_key, HASH_KEYLEN,
+ 				  (u8 *)&iphdr->saddr, data_len);
+ 		ret = true;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static u16 netvsc_select_queue(struct net_device *ndev, struct sk_buff *skb,
+ 			void *accel_priv, select_queue_fallback_t fallback)
+ {
+ 	struct net_device_context *net_device_ctx = netdev_priv(ndev);
+ 	struct hv_device *hdev =  net_device_ctx->device_ctx;
+ 	struct netvsc_device *nvsc_dev = hv_get_drvdata(hdev);
+ 	u32 hash;
+ 	u16 q_idx = 0;
+ 
+ 	if (nvsc_dev == NULL || ndev->real_num_tx_queues <= 1)
+ 		return 0;
+ 
+ 	if (netvsc_set_hash(&hash, skb))
+ 		q_idx = nvsc_dev->send_table[hash % VRSS_SEND_TAB_SIZE] %
+ 			ndev->real_num_tx_queues;
+ 
+ 	return q_idx;
+ }
+ 
++>>>>>>> 5b54dac856cb (hyperv: Add support for virtual Receive Side Scaling (vRSS))
  static void netvsc_xmit_completion(void *context)
  {
  	struct hv_netvsc_packet *packet = (struct hv_netvsc_packet *)context;
@@@ -169,45 -415,14 +275,51 @@@ static int netvsc_start_xmit(struct sk_
  
  	packet->vlan_tci = skb->vlan_tci;
  
++<<<<<<< HEAD
 +	packet->extension = (void *)(unsigned long)packet +
 +				sizeof(struct hv_netvsc_packet) +
 +				    (num_pages * sizeof(struct hv_page_buffer));
 +
 +	/* If the rndis msg goes beyond 1 page, we will add 1 later */
 +	packet->page_buf_cnt = num_pages - 1;
 +
 +	/* Initialize it from the skb */
++=======
+ 	packet->q_idx = skb_get_queue_mapping(skb);
+ 
+ 	packet->is_data_pkt = true;
++>>>>>>> 5b54dac856cb (hyperv: Add support for virtual Receive Side Scaling (vRSS))
  	packet->total_data_buflen = skb->len;
  
 -	packet->rndis_msg = (struct rndis_message *)((unsigned long)packet +
 -				sizeof(struct hv_netvsc_packet) +
 -				(num_data_pgs * sizeof(struct hv_page_buffer)));
 +	/* Start filling in the page buffers starting after RNDIS buffer. */
 +	packet->page_buf[1].pfn = virt_to_phys(skb->data) >> PAGE_SHIFT;
 +	packet->page_buf[1].offset
 +		= (unsigned long)skb->data & (PAGE_SIZE - 1);
 +	if (npg_data == 1)
 +		packet->page_buf[1].len = skb_headlen(skb);
 +	else
 +		packet->page_buf[1].len = PAGE_SIZE
 +			- packet->page_buf[1].offset;
 +
 +	for (i = 2; i <= npg_data; i++) {
 +		packet->page_buf[i].pfn = virt_to_phys(skb->data
 +			+ PAGE_SIZE * (i-1)) >> PAGE_SHIFT;
 +		packet->page_buf[i].offset = 0;
 +		packet->page_buf[i].len = PAGE_SIZE;
 +	}
 +	if (npg_data > 1)
 +		packet->page_buf[npg_data].len = (((unsigned long)skb->data
 +			+ skb_headlen(skb) - 1) & (PAGE_SIZE - 1)) + 1;
 +
 +	/* Additional fragments are after SKB data */
 +	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 +		const skb_frag_t *f = &skb_shinfo(skb)->frags[i];
 +
 +		packet->page_buf[i+npg_data+1].pfn =
 +			page_to_pfn(skb_frag_page(f));
 +		packet->page_buf[i+npg_data+1].offset = f->page_offset;
 +		packet->page_buf[i+npg_data+1].len = skb_frag_size(f);
 +	}
  
  	/* Set the completion routine */
  	packet->completion.send.send_completion = netvsc_xmit_completion;
diff --cc drivers/net/hyperv/rndis_filter.c
index 4b3b201565af,d92cfbe43410..000000000000
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@@ -631,7 -644,155 +646,90 @@@ cleanup
  	return ret;
  }
  
 -int rndis_filter_set_offload_params(struct hv_device *hdev,
 -				struct ndis_offload_params *req_offloads)
 -{
 -	struct netvsc_device *nvdev = hv_get_drvdata(hdev);
 -	struct rndis_device *rdev = nvdev->extension;
 -	struct net_device *ndev = nvdev->ndev;
 -	struct rndis_request *request;
 -	struct rndis_set_request *set;
 -	struct ndis_offload_params *offload_params;
 -	struct rndis_set_complete *set_complete;
 -	u32 extlen = sizeof(struct ndis_offload_params);
 -	int ret, t;
 -	u32 vsp_version = nvdev->nvsp_version;
 -
 -	if (vsp_version <= NVSP_PROTOCOL_VERSION_4) {
 -		extlen = VERSION_4_OFFLOAD_SIZE;
 -		/* On NVSP_PROTOCOL_VERSION_4 and below, we do not support
 -		 * UDP checksum offload.
 -		 */
 -		req_offloads->udp_ip_v4_csum = 0;
 -		req_offloads->udp_ip_v6_csum = 0;
 -	}
 -
 -	request = get_rndis_request(rdev, RNDIS_MSG_SET,
 -		RNDIS_MESSAGE_SIZE(struct rndis_set_request) + extlen);
 -	if (!request)
 -		return -ENOMEM;
 -
 -	set = &request->request_msg.msg.set_req;
 -	set->oid = OID_TCP_OFFLOAD_PARAMETERS;
 -	set->info_buflen = extlen;
 -	set->info_buf_offset = sizeof(struct rndis_set_request);
 -	set->dev_vc_handle = 0;
 -
 -	offload_params = (struct ndis_offload_params *)((ulong)set +
 -				set->info_buf_offset);
 -	*offload_params = *req_offloads;
 -	offload_params->header.type = NDIS_OBJECT_TYPE_DEFAULT;
 -	offload_params->header.revision = NDIS_OFFLOAD_PARAMETERS_REVISION_3;
 -	offload_params->header.size = extlen;
 -
 -	ret = rndis_filter_send_request(rdev, request);
 -	if (ret != 0)
 -		goto cleanup;
 -
 -	t = wait_for_completion_timeout(&request->wait_event, 5*HZ);
 -	if (t == 0) {
 -		netdev_err(ndev, "timeout before we got aOFFLOAD set response...\n");
 -		/* can't put_rndis_request, since we may still receive a
 -		 * send-completion.
 -		 */
 -		return -EBUSY;
 -	} else {
 -		set_complete = &request->response_msg.msg.set_complete;
 -		if (set_complete->status != RNDIS_STATUS_SUCCESS) {
 -			netdev_err(ndev, "Fail to set offload on host side:0x%x\n",
 -				   set_complete->status);
 -			ret = -EINVAL;
 -		}
 -	}
 -
 -cleanup:
 -	put_rndis_request(rdev, request);
 -	return ret;
 -}
  
+ u8 netvsc_hash_key[HASH_KEYLEN] = {
+ 	0x6d, 0x5a, 0x56, 0xda, 0x25, 0x5b, 0x0e, 0xc2,
+ 	0x41, 0x67, 0x25, 0x3d, 0x43, 0xa3, 0x8f, 0xb0,
+ 	0xd0, 0xca, 0x2b, 0xcb, 0xae, 0x7b, 0x30, 0xb4,
+ 	0x77, 0xcb, 0x2d, 0xa3, 0x80, 0x30, 0xf2, 0x0c,
+ 	0x6a, 0x42, 0xb7, 0x3b, 0xbe, 0xac, 0x01, 0xfa
+ };
+ 
+ int rndis_filter_set_rss_param(struct rndis_device *rdev, int num_queue)
+ {
+ 	struct net_device *ndev = rdev->net_dev->ndev;
+ 	struct rndis_request *request;
+ 	struct rndis_set_request *set;
+ 	struct rndis_set_complete *set_complete;
+ 	u32 extlen = sizeof(struct ndis_recv_scale_param) +
+ 		     4*ITAB_NUM + HASH_KEYLEN;
+ 	struct ndis_recv_scale_param *rssp;
+ 	u32 *itab;
+ 	u8 *keyp;
+ 	int i, t, ret;
+ 
+ 	request = get_rndis_request(
+ 			rdev, RNDIS_MSG_SET,
+ 			RNDIS_MESSAGE_SIZE(struct rndis_set_request) + extlen);
+ 	if (!request)
+ 		return -ENOMEM;
+ 
+ 	set = &request->request_msg.msg.set_req;
+ 	set->oid = OID_GEN_RECEIVE_SCALE_PARAMETERS;
+ 	set->info_buflen = extlen;
+ 	set->info_buf_offset = sizeof(struct rndis_set_request);
+ 	set->dev_vc_handle = 0;
+ 
+ 	rssp = (struct ndis_recv_scale_param *)(set + 1);
+ 	rssp->hdr.type = NDIS_OBJECT_TYPE_RSS_PARAMETERS;
+ 	rssp->hdr.rev = NDIS_RECEIVE_SCALE_PARAMETERS_REVISION_2;
+ 	rssp->hdr.size = sizeof(struct ndis_recv_scale_param);
+ 	rssp->flag = 0;
+ 	rssp->hashinfo = NDIS_HASH_FUNC_TOEPLITZ | NDIS_HASH_IPV4 |
+ 			 NDIS_HASH_TCP_IPV4;
+ 	rssp->indirect_tabsize = 4*ITAB_NUM;
+ 	rssp->indirect_taboffset = sizeof(struct ndis_recv_scale_param);
+ 	rssp->hashkey_size = HASH_KEYLEN;
+ 	rssp->kashkey_offset = rssp->indirect_taboffset +
+ 			       rssp->indirect_tabsize;
+ 
+ 	/* Set indirection table entries */
+ 	itab = (u32 *)(rssp + 1);
+ 	for (i = 0; i < ITAB_NUM; i++)
+ 		itab[i] = i % num_queue;
+ 
+ 	/* Set hask key values */
+ 	keyp = (u8 *)((unsigned long)rssp + rssp->kashkey_offset);
+ 	for (i = 0; i < HASH_KEYLEN; i++)
+ 		keyp[i] = netvsc_hash_key[i];
+ 
+ 
+ 	ret = rndis_filter_send_request(rdev, request);
+ 	if (ret != 0)
+ 		goto cleanup;
+ 
+ 	t = wait_for_completion_timeout(&request->wait_event, 5*HZ);
+ 	if (t == 0) {
+ 		netdev_err(ndev, "timeout before we got a set response...\n");
+ 		/* can't put_rndis_request, since we may still receive a
+ 		 * send-completion.
+ 		 */
+ 		return -ETIMEDOUT;
+ 	} else {
+ 		set_complete = &request->response_msg.msg.set_complete;
+ 		if (set_complete->status != RNDIS_STATUS_SUCCESS) {
+ 			netdev_err(ndev, "Fail to set RSS parameters:0x%x\n",
+ 				   set_complete->status);
+ 			ret = -EINVAL;
+ 		}
+ 	}
+ 
+ cleanup:
+ 	put_rndis_request(rdev, request);
+ 	return ret;
+ }
+ 
+ 
  static int rndis_filter_query_device_link_status(struct rndis_device *dev)
  {
  	u32 size = sizeof(u32);
@@@ -830,6 -1013,11 +950,14 @@@ int rndis_filter_device_add(struct hv_d
  	struct netvsc_device *net_device;
  	struct rndis_device *rndis_device;
  	struct netvsc_device_info *device_info = additional_info;
++<<<<<<< HEAD
++=======
+ 	struct ndis_offload_params offloads;
+ 	struct nvsp_message *init_packet;
+ 	int t;
+ 	struct ndis_recv_scale_cap rsscap;
+ 	u32 rsscap_size = sizeof(struct ndis_recv_scale_cap);
++>>>>>>> 5b54dac856cb (hyperv: Add support for virtual Receive Side Scaling (vRSS))
  
  	rndis_device = get_rndis_device();
  	if (!rndis_device)
@@@ -869,6 -1058,25 +998,28 @@@
  
  	memcpy(device_info->mac_adr, rndis_device->hw_mac_adr, ETH_ALEN);
  
++<<<<<<< HEAD
++=======
+ 	/* Turn on the offloads; the host supports all of the relevant
+ 	 * offloads.
+ 	 */
+ 	memset(&offloads, 0, sizeof(struct ndis_offload_params));
+ 	/* A value of zero means "no change"; now turn on what we
+ 	 * want.
+ 	 */
+ 	offloads.ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
+ 	offloads.tcp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
+ 	offloads.udp_ip_v4_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
+ 	offloads.tcp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
+ 	offloads.udp_ip_v6_csum = NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED;
+ 	offloads.lso_v2_ipv4 = NDIS_OFFLOAD_PARAMETERS_LSOV2_ENABLED;
+ 
+ 
+ 	ret = rndis_filter_set_offload_params(dev, &offloads);
+ 	if (ret)
+ 		goto err_dev_remv;
+ 
++>>>>>>> 5b54dac856cb (hyperv: Add support for virtual Receive Side Scaling (vRSS))
  	rndis_filter_query_device_link_status(rndis_device);
  
  	device_info->link_state = rndis_device->link_state;
@@@ -877,6 -1085,69 +1028,72 @@@
  		 rndis_device->hw_mac_adr,
  		 device_info->link_state ? "down" : "up");
  
++<<<<<<< HEAD
++=======
+ 	if (net_device->nvsp_version < NVSP_PROTOCOL_VERSION_5)
+ 		return 0;
+ 
+ 	/* vRSS setup */
+ 	memset(&rsscap, 0, rsscap_size);
+ 	ret = rndis_filter_query_device(rndis_device,
+ 					OID_GEN_RECEIVE_SCALE_CAPABILITIES,
+ 					&rsscap, &rsscap_size);
+ 	if (ret || rsscap.num_recv_que < 2)
+ 		goto out;
+ 
+ 	net_device->num_chn = (num_online_cpus() < rsscap.num_recv_que) ?
+ 			       num_online_cpus() : rsscap.num_recv_que;
+ 	if (net_device->num_chn == 1)
+ 		goto out;
+ 
+ 	net_device->sub_cb_buf = vzalloc((net_device->num_chn - 1) *
+ 					 NETVSC_PACKET_SIZE);
+ 	if (!net_device->sub_cb_buf) {
+ 		net_device->num_chn = 1;
+ 		dev_info(&dev->device, "No memory for subchannels.\n");
+ 		goto out;
+ 	}
+ 
+ 	vmbus_set_sc_create_callback(dev->channel, netvsc_sc_open);
+ 
+ 	init_packet = &net_device->channel_init_pkt;
+ 	memset(init_packet, 0, sizeof(struct nvsp_message));
+ 	init_packet->hdr.msg_type = NVSP_MSG5_TYPE_SUBCHANNEL;
+ 	init_packet->msg.v5_msg.subchn_req.op = NVSP_SUBCHANNEL_ALLOCATE;
+ 	init_packet->msg.v5_msg.subchn_req.num_subchannels =
+ 						net_device->num_chn - 1;
+ 	ret = vmbus_sendpacket(dev->channel, init_packet,
+ 			       sizeof(struct nvsp_message),
+ 			       (unsigned long)init_packet,
+ 			       VM_PKT_DATA_INBAND,
+ 			       VMBUS_DATA_PACKET_FLAG_COMPLETION_REQUESTED);
+ 	if (ret)
+ 		goto out;
+ 	t = wait_for_completion_timeout(&net_device->channel_init_wait, 5*HZ);
+ 	if (t == 0) {
+ 		ret = -ETIMEDOUT;
+ 		goto out;
+ 	}
+ 	if (init_packet->msg.v5_msg.subchn_comp.status !=
+ 	    NVSP_STAT_SUCCESS) {
+ 		ret = -ENODEV;
+ 		goto out;
+ 	}
+ 	net_device->num_chn = 1 +
+ 		init_packet->msg.v5_msg.subchn_comp.num_subchannels;
+ 
+ 	vmbus_are_subchannels_present(dev->channel);
+ 
+ 	ret = rndis_filter_set_rss_param(rndis_device, net_device->num_chn);
+ 
+ out:
+ 	if (ret)
+ 		net_device->num_chn = 1;
+ 	return 0; /* return 0 because primary channel can be used alone */
+ 
+ err_dev_remv:
+ 	rndis_filter_device_remove(dev);
++>>>>>>> 5b54dac856cb (hyperv: Add support for virtual Receive Side Scaling (vRSS))
  	return ret;
  }
  
* Unmerged path drivers/net/hyperv/hyperv_net.h
* Unmerged path drivers/net/hyperv/netvsc.c
* Unmerged path drivers/net/hyperv/netvsc_drv.c
* Unmerged path drivers/net/hyperv/rndis_filter.c
