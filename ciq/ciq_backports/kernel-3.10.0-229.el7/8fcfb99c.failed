ACPI / hotplug: Fix panic on eject to ejected device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug: Fix panic on eject to ejected device (Myron Stowe) [1128632]
Rebuild_FUZZ: 92.78%
commit-author Toshi Kani <toshi.kani@hp.com>
commit 8fcfb99c8e29c73dd8945b6105ef54ca4eeb171e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/8fcfb99c.failed

When an eject request is sent to an ejected ACPI device, the following
panic occurs:

 ACPI: \_SB_.SCK3.CPU3: ACPI_NOTIFY_EJECT_REQUEST event
 BUG: unable to handle kernel NULL pointer dereference at 0000000000000070
 IP: [<ffffffff813a7cfe>] acpi_device_hotplug+0x10b/0x33b
	:
 Call Trace:
 [<ffffffff813a24da>] acpi_hotplug_work_fn+0x1c/0x27
 [<ffffffff8109cbe5>] process_one_work+0x175/0x430
 [<ffffffff8109d7db>] worker_thread+0x11b/0x3a0

This is becase device->handler is NULL in acpi_device_hotplug().
This case was used to fail in acpi_hotplug_notify_cb() as the target
had no acpi_deivce.  However, acpi_device now exists after ejection.

Added a check to verify if acpi_device->handler is valid for an
eject request in acpi_hotplug_notify_cb().  Note that handler passed
from an argument is still valid while acpi_device->handler is NULL.

Fixes: 202317a573b2 (ACPI / scan: Add acpi_device objects for all device nodes in the namespace)
	Signed-off-by: Toshi Kani <toshi.kani@hp.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 8fcfb99c8e29c73dd8945b6105ef54ca4eeb171e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index 2bbdeee33be4,57b053f424d1..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -356,37 -481,34 +356,57 @@@ static void acpi_scan_bus_device_check(
  	unlock_device_hotplug();
  }
  
 -static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 +static void acpi_scan_bus_check(void *context)
  {
++<<<<<<< HEAD
 +	acpi_scan_bus_device_check((acpi_handle)context,
 +				   ACPI_NOTIFY_BUS_CHECK);
 +}
++=======
+ 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
+ 	struct acpi_device *adev;
+ 	acpi_status status;
++>>>>>>> 8fcfb99c8e29 (ACPI / hotplug: Fix panic on eject to ejected device)
  
 -	if (acpi_bus_get_device(handle, &adev))
 -		goto err_out;
 +static void acpi_scan_device_check(void *context)
 +{
 +	acpi_scan_bus_device_check((acpi_handle)context,
 +				   ACPI_NOTIFY_DEVICE_CHECK);
 +}
 +
 +static void acpi_hotplug_unsupported(acpi_handle handle, u32 type)
 +{
 +	u32 ost_status;
  
  	switch (type) {
  	case ACPI_NOTIFY_BUS_CHECK:
 -		acpi_handle_debug(handle, "ACPI_NOTIFY_BUS_CHECK event\n");
 +		acpi_handle_debug(handle,
 +			"ACPI_NOTIFY_BUS_CHECK event: unsupported\n");
 +		ost_status = ACPI_OST_SC_INSERT_NOT_SUPPORTED;
  		break;
  	case ACPI_NOTIFY_DEVICE_CHECK:
 -		acpi_handle_debug(handle, "ACPI_NOTIFY_DEVICE_CHECK event\n");
 +		acpi_handle_debug(handle,
 +			"ACPI_NOTIFY_DEVICE_CHECK event: unsupported\n");
 +		ost_status = ACPI_OST_SC_INSERT_NOT_SUPPORTED;
  		break;
  	case ACPI_NOTIFY_EJECT_REQUEST:
++<<<<<<< HEAD
 +		acpi_handle_debug(handle,
 +			"ACPI_NOTIFY_EJECT_REQUEST event: unsupported\n");
 +		ost_status = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
++=======
+ 		acpi_handle_debug(handle, "ACPI_NOTIFY_EJECT_REQUEST event\n");
+ 		if (!adev->handler)
+ 			goto err_out;
+ 
+ 		if (!adev->handler->hotplug.enabled) {
+ 			acpi_handle_err(handle, "Eject disabled\n");
+ 			ost_code = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
+ 			goto err_out;
+ 		}
+ 		acpi_evaluate_hotplug_ost(handle, ACPI_NOTIFY_EJECT_REQUEST,
+ 					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
++>>>>>>> 8fcfb99c8e29 (ACPI / hotplug: Fix panic on eject to ejected device)
  		break;
  	default:
  		/* non-hotplug event; possibly handled by other handler */
* Unmerged path drivers/acpi/scan.c
