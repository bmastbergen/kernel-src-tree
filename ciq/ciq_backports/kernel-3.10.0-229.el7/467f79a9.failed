powerpc/powernv: Remove PNV_EEH_STATE_REMOVED

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [powerpc] powernv: Remove PNV_EEH_STATE_REMOVED (Don Zickus) [1127366]
Rebuild_FUZZ: 90.24%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit 467f79a9564b8fafa83adb53471aebe8cf75fb8e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/467f79a9.failed

The PHB state PNV_EEH_STATE_REMOVED maintained in pnv_phb isn't
so useful any more and it's duplicated to EEH_PE_ISOLATED. The
patch replaces PNV_EEH_STATE_REMOVED with EEH_PE_ISOLATED.

	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit 467f79a9564b8fafa83adb53471aebe8cf75fb8e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/eeh-ioda.c
diff --cc arch/powerpc/platforms/powernv/eeh-ioda.c
index be33a16408be,5432598447d9..000000000000
--- a/arch/powerpc/platforms/powernv/eeh-ioda.c
+++ b/arch/powerpc/platforms/powernv/eeh-ioda.c
@@@ -681,38 -639,6 +681,41 @@@ static void ioda_eeh_hub_diag(struct pc
  	}
  }
  
++<<<<<<< HEAD
 +static void ioda_eeh_phb_diag(struct pci_controller *hose)
 +{
 +	struct pnv_phb *phb = hose->private_data;
 +	long rc;
 +
 +	rc = opal_pci_get_phb_diag_data2(phb->opal_id, phb->diag.blob,
 +					 PNV_PCI_DIAG_BUF_SIZE);
 +	if (rc != OPAL_SUCCESS) {
 +		pr_warning("%s: Failed to get diag-data for PHB#%x (%ld)\n",
 +			    __func__, hose->global_number, rc);
 +		return;
 +	}
 +
 +	pnv_pci_dump_phb_diag_data(hose, phb->diag.blob);
 +}
 +
 +static int ioda_eeh_get_phb_pe(struct pci_controller *hose,
 +			       struct eeh_pe **pe)
 +{
 +	struct eeh_pe *phb_pe;
 +
 +	phb_pe = eeh_phb_pe_get(hose);
 +	if (!phb_pe) {
 +		pr_warning("%s Can't find PE for PHB#%d\n",
 +			   __func__, hose->global_number);
 +		return -EEXIST;
 +	}
 +
 +	*pe = phb_pe;
 +	return 0;
 +}
 +
++=======
++>>>>>>> 467f79a9564b (powerpc/powernv: Remove PNV_EEH_STATE_REMOVED)
  static int ioda_eeh_get_pe(struct pci_controller *hose,
  			   u16 pe_no, struct eeh_pe **pe)
  {
@@@ -750,8 -673,9 +754,9 @@@
   */
  static int ioda_eeh_next_error(struct eeh_pe **pe)
  {
 -	struct pci_controller *hose;
 +	struct pci_controller *hose, *tmp;
  	struct pnv_phb *phb;
+ 	struct eeh_pe *phb_pe;
  	u64 frozen_pe_no;
  	u16 err_type, severity;
  	long rc;
@@@ -765,13 -689,15 +770,15 @@@
  	eeh_remove_event(NULL);
  	opal_notifier_update_evt(OPAL_EVENT_PCI_ERROR, 0x0ul);
  
 -	list_for_each_entry(hose, &hose_list, list_node) {
 +	list_for_each_entry_safe(hose, tmp, &hose_list, list_node) {
  		/*
  		 * If the subordinate PCI buses of the PHB has been
- 		 * removed, we needn't take care of it any more.
+ 		 * removed or is exactly under error recovery, we
+ 		 * needn't take care of it any more.
  		 */
  		phb = hose->private_data;
- 		if (phb->eeh_state & PNV_EEH_STATE_REMOVED)
+ 		phb_pe = eeh_phb_pe_get(hose);
+ 		if (!phb_pe || (phb_pe->state & EEH_PE_ISOLATED))
  			continue;
  
  		rc = opal_pci_next_error(phb->opal_id,
@@@ -804,15 -730,8 +811,18 @@@
  		switch (err_type) {
  		case OPAL_EEH_IOC_ERROR:
  			if (severity == OPAL_EEH_SEV_IOC_DEAD) {
++<<<<<<< HEAD
 +				list_for_each_entry_safe(hose, tmp,
 +						&hose_list, list_node) {
 +					phb = hose->private_data;
 +					phb->eeh_state |= PNV_EEH_STATE_REMOVED;
 +				}
 +
++=======
++>>>>>>> 467f79a9564b (powerpc/powernv: Remove PNV_EEH_STATE_REMOVED)
  				pr_err("EEH: dead IOC detected\n");
 -				ret = EEH_NEXT_ERR_DEAD_IOC;
 +				ret = 4;
 +				goto out;
  			} else if (severity == OPAL_EEH_SEV_INF) {
  				pr_info("EEH: IOC informative error "
  					"detected\n");
@@@ -822,22 -742,15 +832,22 @@@
  			break;
  		case OPAL_EEH_PHB_ERROR:
  			if (severity == OPAL_EEH_SEV_PHB_DEAD) {
- 				if (ioda_eeh_get_phb_pe(hose, pe))
- 					break;
- 
+ 				*pe = phb_pe;
  				pr_err("EEH: dead PHB#%x detected\n",
  					hose->global_number);
++<<<<<<< HEAD
 +				phb->eeh_state |= PNV_EEH_STATE_REMOVED;
 +				ret = 3;
 +				goto out;
++=======
+ 				ret = EEH_NEXT_ERR_DEAD_PHB;
++>>>>>>> 467f79a9564b (powerpc/powernv: Remove PNV_EEH_STATE_REMOVED)
  			} else if (severity == OPAL_EEH_SEV_PHB_FENCED) {
- 				if (ioda_eeh_get_phb_pe(hose, pe))
- 					break;
- 
+ 				*pe = phb_pe;
  				pr_err("EEH: fenced PHB#%x detected\n",
  					hose->global_number);
 -				ret = EEH_NEXT_ERR_FENCED_PHB;
 +				ret = 2;
 +				goto out;
  			} else if (severity == OPAL_EEH_SEV_INF) {
  				pr_info("EEH: PHB#%x informative error "
  					"detected\n",
@@@ -847,18 -761,54 +857,38 @@@
  
  			break;
  		case OPAL_EEH_PE_ERROR:
++<<<<<<< HEAD
 +			if (ioda_eeh_get_pe(hose, frozen_pe_no, pe))
 +				break;
++=======
+ 			/*
+ 			 * If we can't find the corresponding PE, the
+ 			 * PEEV / PEST would be messy. So we force an
+ 			 * fenced PHB so that it can be recovered.
+ 			 */
+ 			if (ioda_eeh_get_pe(hose, frozen_pe_no, pe)) {
+ 				*pe = phb_pe;
+ 				pr_err("EEH: Escalated fenced PHB#%x "
+ 				       "detected for PE#%llx\n",
+ 					hose->global_number,
+ 					frozen_pe_no);
+ 				ret = EEH_NEXT_ERR_FENCED_PHB;
+ 			} else {
+ 				pr_err("EEH: Frozen PE#%x on PHB#%x detected\n",
+ 					(*pe)->addr, (*pe)->phb->global_number);
+ 				ret = EEH_NEXT_ERR_FROZEN_PE;
+ 			}
++>>>>>>> 467f79a9564b (powerpc/powernv: Remove PNV_EEH_STATE_REMOVED)
  
 -			break;
 -		default:
 -			pr_warn("%s: Unexpected error type %d\n",
 -				__func__, err_type);
 -		}
 -
 -		/*
 -		 * EEH core will try recover from fenced PHB or
 -		 * frozen PE. In the time for frozen PE, EEH core
 -		 * enable IO path for that before collecting logs,
 -		 * but it ruins the site. So we have to dump the
 -		 * log in advance here.
 -		 */
 -		if ((ret == EEH_NEXT_ERR_FROZEN_PE  ||
 -		    ret == EEH_NEXT_ERR_FENCED_PHB) &&
 -		    !((*pe)->state & EEH_PE_ISOLATED)) {
 -			eeh_pe_state_mark(*pe, EEH_PE_ISOLATED);
 -			ioda_eeh_phb_diag(hose);
 +			pr_err("EEH: Frozen PE#%x on PHB#%x detected\n",
 +				(*pe)->addr, (*pe)->phb->global_number);
 +			ret = 1;
 +			goto out;
  		}
 -
 -		/*
 -		 * If we have no errors on the specific PHB or only
 -		 * informative error there, we continue poking it.
 -		 * Otherwise, we need actions to be taken by upper
 -		 * layer.
 -		 */
 -		if (ret > EEH_NEXT_ERR_INF)
 -			break;
  	}
  
 +	ret = 0;
 +out:
  	return ret;
  }
  
* Unmerged path arch/powerpc/platforms/powernv/eeh-ioda.c
diff --git a/arch/powerpc/platforms/powernv/pci.h b/arch/powerpc/platforms/powernv/pci.h
index 48749fa60351..c7b8a777182d 100644
--- a/arch/powerpc/platforms/powernv/pci.h
+++ b/arch/powerpc/platforms/powernv/pci.h
@@ -80,7 +80,6 @@ struct pnv_eeh_ops {
 };
 
 #define PNV_EEH_STATE_ENABLED	(1 << 0)	/* EEH enabled	*/
-#define PNV_EEH_STATE_REMOVED	(1 << 1)	/* PHB removed	*/
 
 #endif /* CONFIG_EEH */
 
