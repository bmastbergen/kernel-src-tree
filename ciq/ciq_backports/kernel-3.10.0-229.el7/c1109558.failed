NFS: Fix error handling in __nfs_pageio_add_request

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit c1109558ae0f07a3434357cd26203bfc7adfea75
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/c1109558.failed

Handle the case where nfs_create_request() returns an error.

	Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit c1109558ae0f07a3434357cd26203bfc7adfea75)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pagelist.c
diff --cc fs/nfs/pagelist.c
index 00f3d2d2a504,0b8446f1008d..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -441,16 -903,64 +441,76 @@@ static void nfs_pageio_doio(struct nfs_
  static int __nfs_pageio_add_request(struct nfs_pageio_descriptor *desc,
  			   struct nfs_page *req)
  {
++<<<<<<< HEAD
 +	while (!nfs_pageio_do_add_request(desc, req)) {
 +		desc->pg_moreio = 1;
 +		nfs_pageio_doio(desc);
 +		if (desc->pg_error < 0)
 +			return 0;
 +		desc->pg_moreio = 0;
 +		if (desc->pg_recoalesce)
 +			return 0;
 +	}
++=======
+ 	struct nfs_page *subreq;
+ 	unsigned int bytes_left = 0;
+ 	unsigned int offset, pgbase;
+ 
+ 	nfs_page_group_lock(req);
+ 
+ 	subreq = req;
+ 	bytes_left = subreq->wb_bytes;
+ 	offset = subreq->wb_offset;
+ 	pgbase = subreq->wb_pgbase;
+ 
+ 	do {
+ 		if (!nfs_pageio_do_add_request(desc, subreq)) {
+ 			/* make sure pg_test call(s) did nothing */
+ 			WARN_ON_ONCE(subreq->wb_bytes != bytes_left);
+ 			WARN_ON_ONCE(subreq->wb_offset != offset);
+ 			WARN_ON_ONCE(subreq->wb_pgbase != pgbase);
+ 
+ 			nfs_page_group_unlock(req);
+ 			desc->pg_moreio = 1;
+ 			nfs_pageio_doio(desc);
+ 			if (desc->pg_error < 0)
+ 				return 0;
+ 			desc->pg_moreio = 0;
+ 			if (desc->pg_recoalesce)
+ 				return 0;
+ 			/* retry add_request for this subreq */
+ 			nfs_page_group_lock(req);
+ 			continue;
+ 		}
+ 
+ 		/* check for buggy pg_test call(s) */
+ 		WARN_ON_ONCE(subreq->wb_bytes + subreq->wb_pgbase > PAGE_SIZE);
+ 		WARN_ON_ONCE(subreq->wb_bytes > bytes_left);
+ 		WARN_ON_ONCE(subreq->wb_bytes == 0);
+ 
+ 		bytes_left -= subreq->wb_bytes;
+ 		offset += subreq->wb_bytes;
+ 		pgbase += subreq->wb_bytes;
+ 
+ 		if (bytes_left) {
+ 			subreq = nfs_create_request(req->wb_context,
+ 					req->wb_page,
+ 					subreq, pgbase, bytes_left);
+ 			if (IS_ERR(subreq))
+ 				goto err_ptr;
+ 			nfs_lock_request(subreq);
+ 			subreq->wb_offset  = offset;
+ 			subreq->wb_index = req->wb_index;
+ 		}
+ 	} while (bytes_left > 0);
+ 
+ 	nfs_page_group_unlock(req);
++>>>>>>> c1109558ae0f (NFS: Fix error handling in __nfs_pageio_add_request)
  	return 1;
+ err_ptr:
+ 	desc->pg_error = PTR_ERR(subreq);
+ 	nfs_page_group_unlock(req);
+ 	return 0;
  }
  
  static int nfs_do_recoalesce(struct nfs_pageio_descriptor *desc)
* Unmerged path fs/nfs/pagelist.c
