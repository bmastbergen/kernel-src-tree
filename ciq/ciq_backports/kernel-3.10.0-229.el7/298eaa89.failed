dm snapshot: do not split read bios sent to snapshot-origin target

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [md] dm-snapshot: do not split read bios sent to snapshot-origin target (Mike Snitzer) [1117872]
Rebuild_FUZZ: 98.48%
commit-author Mikulas Patocka <mpatocka@redhat.com>
commit 298eaa89b02e88dc9081f8761a957f7cd5e8b201
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/298eaa89.failed

Change the snapshot-origin target so that only write bios are split on
chunk boundary.  Read bios are passed unchanged to the underlying
device, so they don't have to be split.

Later, we could change the target so that it accepts a larger write bio
if it spans an area that is completely covered by snapshot exceptions.

	Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
	Signed-off-by: Mike Snitzer <snitzer@redhat.com>
(cherry picked from commit 298eaa89b02e88dc9081f8761a957f7cd5e8b201)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/md/dm-snap.c
diff --cc drivers/md/dm-snap.c
index 717718558bd9,e5a84c890e8f..000000000000
--- a/drivers/md/dm-snap.c
+++ b/drivers/md/dm-snap.c
@@@ -2140,6 -2141,11 +2140,14 @@@ static int origin_write_extent(struct d
   * Origin: maps a linear range of a device, with hooks for snapshotting.
   */
  
++<<<<<<< HEAD
++=======
+ struct dm_origin {
+ 	struct dm_dev *dev;
+ 	unsigned split_boundary;
+ };
+ 
++>>>>>>> 298eaa89b02e (dm snapshot: do not split read bios sent to snapshot-origin target)
  /*
   * Construct an origin mapping: <dev_path>
   * The context for an origin is merely a 'struct dm_dev *'
@@@ -2175,14 -2194,25 +2183,34 @@@ static void origin_dtr(struct dm_targe
  
  static int origin_map(struct dm_target *ti, struct bio *bio)
  {
++<<<<<<< HEAD
 +	struct dm_dev *dev = ti->private;
 +	bio->bi_bdev = dev->bdev;
++=======
+ 	struct dm_origin *o = ti->private;
+ 	unsigned available_sectors;
+ 
+ 	bio->bi_bdev = o->dev->bdev;
++>>>>>>> 298eaa89b02e (dm snapshot: do not split read bios sent to snapshot-origin target)
  
- 	if (bio->bi_rw & REQ_FLUSH)
+ 	if (unlikely(bio->bi_rw & REQ_FLUSH))
  		return DM_MAPIO_REMAPPED;
  
+ 	if (bio_rw(bio) != WRITE)
+ 		return DM_MAPIO_REMAPPED;
+ 
+ 	available_sectors = o->split_boundary -
+ 		((unsigned)bio->bi_iter.bi_sector & (o->split_boundary - 1));
+ 
+ 	if (bio_sectors(bio) > available_sectors)
+ 		dm_accept_partial_bio(bio, available_sectors);
+ 
  	/* Only tell snapshots if this is a write */
++<<<<<<< HEAD
 +	return (bio_rw(bio) == WRITE) ? do_origin(dev, bio) : DM_MAPIO_REMAPPED;
++=======
+ 	return do_origin(o->dev, bio);
++>>>>>>> 298eaa89b02e (dm snapshot: do not split read bios sent to snapshot-origin target)
  }
  
  /*
@@@ -2191,9 -2221,9 +2219,13 @@@
   */
  static void origin_resume(struct dm_target *ti)
  {
 -	struct dm_origin *o = ti->private;
 +	struct dm_dev *dev = ti->private;
  
++<<<<<<< HEAD
 +	ti->max_io_len = get_origin_minimum_chunksize(dev->bdev);
++=======
+ 	o->split_boundary = get_origin_minimum_chunksize(o->dev->bdev);
++>>>>>>> 298eaa89b02e (dm snapshot: do not split read bios sent to snapshot-origin target)
  }
  
  static void origin_status(struct dm_target *ti, status_type_t type,
* Unmerged path drivers/md/dm-snap.c
