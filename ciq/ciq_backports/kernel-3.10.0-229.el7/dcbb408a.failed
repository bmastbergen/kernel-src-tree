PCI: Fix spelling errors

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Kconfig: Fix spelling errors (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 88.46%
commit-author Colin Ian King <colin.king@canonical.com>
commit dcbb408ac5a2803ba44ca2fae8bf53eb5d4082f3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/dcbb408a.failed

Fix spelling of "initalization".

[bhelgaas: also fix pci/pci.c]
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit dcbb408ac5a2803ba44ca2fae8bf53eb5d4082f3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/host/pcie-xilinx-nwl.c
#	drivers/pci/pci.c
diff --cc drivers/pci/pci.c
index 84ea416bd62d,e3d6b33fd596..000000000000
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@@ -2088,6 -2226,198 +2088,201 @@@ void pci_pm_init(struct pci_dev *dev
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static unsigned long pci_ea_flags(struct pci_dev *dev, u8 prop)
+ {
+ 	unsigned long flags = IORESOURCE_PCI_FIXED;
+ 
+ 	switch (prop) {
+ 	case PCI_EA_P_MEM:
+ 	case PCI_EA_P_VF_MEM:
+ 		flags |= IORESOURCE_MEM;
+ 		break;
+ 	case PCI_EA_P_MEM_PREFETCH:
+ 	case PCI_EA_P_VF_MEM_PREFETCH:
+ 		flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH;
+ 		break;
+ 	case PCI_EA_P_IO:
+ 		flags |= IORESOURCE_IO;
+ 		break;
+ 	default:
+ 		return 0;
+ 	}
+ 
+ 	return flags;
+ }
+ 
+ static struct resource *pci_ea_get_resource(struct pci_dev *dev, u8 bei,
+ 					    u8 prop)
+ {
+ 	if (bei <= PCI_EA_BEI_BAR5 && prop <= PCI_EA_P_IO)
+ 		return &dev->resource[bei];
+ #ifdef CONFIG_PCI_IOV
+ 	else if (bei >= PCI_EA_BEI_VF_BAR0 && bei <= PCI_EA_BEI_VF_BAR5 &&
+ 		 (prop == PCI_EA_P_VF_MEM || prop == PCI_EA_P_VF_MEM_PREFETCH))
+ 		return &dev->resource[PCI_IOV_RESOURCES +
+ 				      bei - PCI_EA_BEI_VF_BAR0];
+ #endif
+ 	else if (bei == PCI_EA_BEI_ROM)
+ 		return &dev->resource[PCI_ROM_RESOURCE];
+ 	else
+ 		return NULL;
+ }
+ 
+ /* Read an Enhanced Allocation (EA) entry */
+ static int pci_ea_read(struct pci_dev *dev, int offset)
+ {
+ 	struct resource *res;
+ 	int ent_size, ent_offset = offset;
+ 	resource_size_t start, end;
+ 	unsigned long flags;
+ 	u32 dw0, bei, base, max_offset;
+ 	u8 prop;
+ 	bool support_64 = (sizeof(resource_size_t) >= 8);
+ 
+ 	pci_read_config_dword(dev, ent_offset, &dw0);
+ 	ent_offset += 4;
+ 
+ 	/* Entry size field indicates DWORDs after 1st */
+ 	ent_size = ((dw0 & PCI_EA_ES) + 1) << 2;
+ 
+ 	if (!(dw0 & PCI_EA_ENABLE)) /* Entry not enabled */
+ 		goto out;
+ 
+ 	bei = (dw0 & PCI_EA_BEI) >> 4;
+ 	prop = (dw0 & PCI_EA_PP) >> 8;
+ 
+ 	/*
+ 	 * If the Property is in the reserved range, try the Secondary
+ 	 * Property instead.
+ 	 */
+ 	if (prop > PCI_EA_P_BRIDGE_IO && prop < PCI_EA_P_MEM_RESERVED)
+ 		prop = (dw0 & PCI_EA_SP) >> 16;
+ 	if (prop > PCI_EA_P_BRIDGE_IO)
+ 		goto out;
+ 
+ 	res = pci_ea_get_resource(dev, bei, prop);
+ 	if (!res) {
+ 		dev_err(&dev->dev, "Unsupported EA entry BEI: %u\n", bei);
+ 		goto out;
+ 	}
+ 
+ 	flags = pci_ea_flags(dev, prop);
+ 	if (!flags) {
+ 		dev_err(&dev->dev, "Unsupported EA properties: %#x\n", prop);
+ 		goto out;
+ 	}
+ 
+ 	/* Read Base */
+ 	pci_read_config_dword(dev, ent_offset, &base);
+ 	start = (base & PCI_EA_FIELD_MASK);
+ 	ent_offset += 4;
+ 
+ 	/* Read MaxOffset */
+ 	pci_read_config_dword(dev, ent_offset, &max_offset);
+ 	ent_offset += 4;
+ 
+ 	/* Read Base MSBs (if 64-bit entry) */
+ 	if (base & PCI_EA_IS_64) {
+ 		u32 base_upper;
+ 
+ 		pci_read_config_dword(dev, ent_offset, &base_upper);
+ 		ent_offset += 4;
+ 
+ 		flags |= IORESOURCE_MEM_64;
+ 
+ 		/* entry starts above 32-bit boundary, can't use */
+ 		if (!support_64 && base_upper)
+ 			goto out;
+ 
+ 		if (support_64)
+ 			start |= ((u64)base_upper << 32);
+ 	}
+ 
+ 	end = start + (max_offset | 0x03);
+ 
+ 	/* Read MaxOffset MSBs (if 64-bit entry) */
+ 	if (max_offset & PCI_EA_IS_64) {
+ 		u32 max_offset_upper;
+ 
+ 		pci_read_config_dword(dev, ent_offset, &max_offset_upper);
+ 		ent_offset += 4;
+ 
+ 		flags |= IORESOURCE_MEM_64;
+ 
+ 		/* entry too big, can't use */
+ 		if (!support_64 && max_offset_upper)
+ 			goto out;
+ 
+ 		if (support_64)
+ 			end += ((u64)max_offset_upper << 32);
+ 	}
+ 
+ 	if (end < start) {
+ 		dev_err(&dev->dev, "EA Entry crosses address boundary\n");
+ 		goto out;
+ 	}
+ 
+ 	if (ent_size != ent_offset - offset) {
+ 		dev_err(&dev->dev,
+ 			"EA Entry Size (%d) does not match length read (%d)\n",
+ 			ent_size, ent_offset - offset);
+ 		goto out;
+ 	}
+ 
+ 	res->name = pci_name(dev);
+ 	res->start = start;
+ 	res->end = end;
+ 	res->flags = flags;
+ 
+ 	if (bei <= PCI_EA_BEI_BAR5)
+ 		dev_printk(KERN_DEBUG, &dev->dev, "BAR %d: %pR (from Enhanced Allocation, properties %#02x)\n",
+ 			   bei, res, prop);
+ 	else if (bei == PCI_EA_BEI_ROM)
+ 		dev_printk(KERN_DEBUG, &dev->dev, "ROM: %pR (from Enhanced Allocation, properties %#02x)\n",
+ 			   res, prop);
+ 	else if (bei >= PCI_EA_BEI_VF_BAR0 && bei <= PCI_EA_BEI_VF_BAR5)
+ 		dev_printk(KERN_DEBUG, &dev->dev, "VF BAR %d: %pR (from Enhanced Allocation, properties %#02x)\n",
+ 			   bei - PCI_EA_BEI_VF_BAR0, res, prop);
+ 	else
+ 		dev_printk(KERN_DEBUG, &dev->dev, "BEI %d res: %pR (from Enhanced Allocation, properties %#02x)\n",
+ 			   bei, res, prop);
+ 
+ out:
+ 	return offset + ent_size;
+ }
+ 
+ /* Enhanced Allocation Initialization */
+ void pci_ea_init(struct pci_dev *dev)
+ {
+ 	int ea;
+ 	u8 num_ent;
+ 	int offset;
+ 	int i;
+ 
+ 	/* find PCI EA capability in list */
+ 	ea = pci_find_capability(dev, PCI_CAP_ID_EA);
+ 	if (!ea)
+ 		return;
+ 
+ 	/* determine the number of entries */
+ 	pci_bus_read_config_byte(dev->bus, dev->devfn, ea + PCI_EA_NUM_ENT,
+ 					&num_ent);
+ 	num_ent &= PCI_EA_NUM_ENT_MASK;
+ 
+ 	offset = ea + PCI_EA_FIRST_ENT;
+ 
+ 	/* Skip DWORD 2 for type 1 functions */
+ 	if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE)
+ 		offset += 4;
+ 
+ 	/* parse each EA entry */
+ 	for (i = 0; i < num_ent; ++i)
+ 		offset = pci_ea_read(dev, offset);
+ }
+ 
++>>>>>>> dcbb408ac5a2 (PCI: Fix spelling errors)
  static void pci_add_saved_cap(struct pci_dev *pci_dev,
  	struct pci_cap_saved_state *new_cap)
  {
* Unmerged path drivers/pci/host/pcie-xilinx-nwl.c
* Unmerged path drivers/pci/host/pcie-xilinx-nwl.c
* Unmerged path drivers/pci/pci.c
