ext4: avoid trying to kfree an ERR_PTR pointer

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Theodore Ts'o <tytso@mit.edu>
commit a9cfcd63e8d206ce4235c355d857c4fbdf0f4587
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a9cfcd63.failed

Thanks to Dan Carpenter for extending smatch to find bugs like this.
(This was found using a development version of smatch.)

Fixes: 36de928641ee48b2078d3fe9514242aaa2f92013
	Reported-by: Dan Carpenter <dan.carpenter@oracle.com
	Signed-off-by: Theodore Ts'o <tytso@mit.edu>
	Cc: stable@vger.kernel.org
(cherry picked from commit a9cfcd63e8d206ce4235c355d857c4fbdf0f4587)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/namei.c
diff --cc fs/ext4/namei.c
index b8d6dc96dd7e,603e4ebbd0ac..000000000000
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@@ -3140,6 -3238,11 +3140,14 @@@ static int ext4_rename(struct inode *ol
  
  	new.bh = ext4_find_entry(new.dir, &new.dentry->d_name,
  				 &new.de, &new.inlined);
++<<<<<<< HEAD
++=======
+ 	if (IS_ERR(new.bh)) {
+ 		retval = PTR_ERR(new.bh);
+ 		new.bh = NULL;
+ 		goto end_rename;
+ 	}
++>>>>>>> a9cfcd63e8d2 (ext4: avoid trying to kfree an ERR_PTR pointer)
  	if (new.bh) {
  		if (!new.inode) {
  			brelse(new.bh);
@@@ -3246,6 -3349,147 +3254,150 @@@ end_rename
  	return retval;
  }
  
++<<<<<<< HEAD
++=======
+ static int ext4_cross_rename(struct inode *old_dir, struct dentry *old_dentry,
+ 			     struct inode *new_dir, struct dentry *new_dentry)
+ {
+ 	handle_t *handle = NULL;
+ 	struct ext4_renament old = {
+ 		.dir = old_dir,
+ 		.dentry = old_dentry,
+ 		.inode = old_dentry->d_inode,
+ 	};
+ 	struct ext4_renament new = {
+ 		.dir = new_dir,
+ 		.dentry = new_dentry,
+ 		.inode = new_dentry->d_inode,
+ 	};
+ 	u8 new_file_type;
+ 	int retval;
+ 
+ 	dquot_initialize(old.dir);
+ 	dquot_initialize(new.dir);
+ 
+ 	old.bh = ext4_find_entry(old.dir, &old.dentry->d_name,
+ 				 &old.de, &old.inlined);
+ 	if (IS_ERR(old.bh))
+ 		return PTR_ERR(old.bh);
+ 	/*
+ 	 *  Check for inode number is _not_ due to possible IO errors.
+ 	 *  We might rmdir the source, keep it as pwd of some process
+ 	 *  and merrily kill the link to whatever was created under the
+ 	 *  same name. Goodbye sticky bit ;-<
+ 	 */
+ 	retval = -ENOENT;
+ 	if (!old.bh || le32_to_cpu(old.de->inode) != old.inode->i_ino)
+ 		goto end_rename;
+ 
+ 	new.bh = ext4_find_entry(new.dir, &new.dentry->d_name,
+ 				 &new.de, &new.inlined);
+ 	if (IS_ERR(new.bh)) {
+ 		retval = PTR_ERR(new.bh);
+ 		new.bh = NULL;
+ 		goto end_rename;
+ 	}
+ 
+ 	/* RENAME_EXCHANGE case: old *and* new must both exist */
+ 	if (!new.bh || le32_to_cpu(new.de->inode) != new.inode->i_ino)
+ 		goto end_rename;
+ 
+ 	handle = ext4_journal_start(old.dir, EXT4_HT_DIR,
+ 		(2 * EXT4_DATA_TRANS_BLOCKS(old.dir->i_sb) +
+ 		 2 * EXT4_INDEX_EXTRA_TRANS_BLOCKS + 2));
+ 	if (IS_ERR(handle))
+ 		return PTR_ERR(handle);
+ 
+ 	if (IS_DIRSYNC(old.dir) || IS_DIRSYNC(new.dir))
+ 		ext4_handle_sync(handle);
+ 
+ 	if (S_ISDIR(old.inode->i_mode)) {
+ 		old.is_dir = true;
+ 		retval = ext4_rename_dir_prepare(handle, &old);
+ 		if (retval)
+ 			goto end_rename;
+ 	}
+ 	if (S_ISDIR(new.inode->i_mode)) {
+ 		new.is_dir = true;
+ 		retval = ext4_rename_dir_prepare(handle, &new);
+ 		if (retval)
+ 			goto end_rename;
+ 	}
+ 
+ 	/*
+ 	 * Other than the special case of overwriting a directory, parents'
+ 	 * nlink only needs to be modified if this is a cross directory rename.
+ 	 */
+ 	if (old.dir != new.dir && old.is_dir != new.is_dir) {
+ 		old.dir_nlink_delta = old.is_dir ? -1 : 1;
+ 		new.dir_nlink_delta = -old.dir_nlink_delta;
+ 		retval = -EMLINK;
+ 		if ((old.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(old.dir)) ||
+ 		    (new.dir_nlink_delta > 0 && EXT4_DIR_LINK_MAX(new.dir)))
+ 			goto end_rename;
+ 	}
+ 
+ 	new_file_type = new.de->file_type;
+ 	retval = ext4_setent(handle, &new, old.inode->i_ino, old.de->file_type);
+ 	if (retval)
+ 		goto end_rename;
+ 
+ 	retval = ext4_setent(handle, &old, new.inode->i_ino, new_file_type);
+ 	if (retval)
+ 		goto end_rename;
+ 
+ 	/*
+ 	 * Like most other Unix systems, set the ctime for inodes on a
+ 	 * rename.
+ 	 */
+ 	old.inode->i_ctime = ext4_current_time(old.inode);
+ 	new.inode->i_ctime = ext4_current_time(new.inode);
+ 	ext4_mark_inode_dirty(handle, old.inode);
+ 	ext4_mark_inode_dirty(handle, new.inode);
+ 
+ 	if (old.dir_bh) {
+ 		retval = ext4_rename_dir_finish(handle, &old, new.dir->i_ino);
+ 		if (retval)
+ 			goto end_rename;
+ 	}
+ 	if (new.dir_bh) {
+ 		retval = ext4_rename_dir_finish(handle, &new, old.dir->i_ino);
+ 		if (retval)
+ 			goto end_rename;
+ 	}
+ 	ext4_update_dir_count(handle, &old);
+ 	ext4_update_dir_count(handle, &new);
+ 	retval = 0;
+ 
+ end_rename:
+ 	brelse(old.dir_bh);
+ 	brelse(new.dir_bh);
+ 	brelse(old.bh);
+ 	brelse(new.bh);
+ 	if (handle)
+ 		ext4_journal_stop(handle);
+ 	return retval;
+ }
+ 
+ static int ext4_rename2(struct inode *old_dir, struct dentry *old_dentry,
+ 			struct inode *new_dir, struct dentry *new_dentry,
+ 			unsigned int flags)
+ {
+ 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))
+ 		return -EINVAL;
+ 
+ 	if (flags & RENAME_EXCHANGE) {
+ 		return ext4_cross_rename(old_dir, old_dentry,
+ 					 new_dir, new_dentry);
+ 	}
+ 	/*
+ 	 * Existence checking was done by the VFS, otherwise "RENAME_NOREPLACE"
+ 	 * is equivalent to regular rename.
+ 	 */
+ 	return ext4_rename(old_dir, old_dentry, new_dir, new_dentry);
+ }
+ 
++>>>>>>> a9cfcd63e8d2 (ext4: avoid trying to kfree an ERR_PTR pointer)
  /*
   * directories can handle most operations...
   */
* Unmerged path fs/ext4/namei.c
diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c
index f3b84cd9de56..3702801e3ea7 100644
--- a/fs/ext4/resize.c
+++ b/fs/ext4/resize.c
@@ -572,6 +572,7 @@ handle_bb:
 		bh = bclean(handle, sb, block);
 		if (IS_ERR(bh)) {
 			err = PTR_ERR(bh);
+			bh = NULL;
 			goto out;
 		}
 		overhead = ext4_group_overhead_blocks(sb, group);
@@ -600,6 +601,7 @@ handle_ib:
 		bh = bclean(handle, sb, block);
 		if (IS_ERR(bh)) {
 			err = PTR_ERR(bh);
+			bh = NULL;
 			goto out;
 		}
 
