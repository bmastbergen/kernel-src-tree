iwlwifi: configure the LTR

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Emmanuel Grumbach <emmanuel.grumbach@intel.com>
commit 9180ac50716a097a407c6d7e7e4589754a922260
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/9180ac50.failed

The LTR is the handshake between the device and the root
complex about the latency allowed when the bus exits power
save. This configuration was missing and this led to high
latency in the link power up. The end user could experience
high latency in the network because of this.

	Cc: <stable@vger.kernel.org> [3.10+]
	Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
(cherry picked from commit 9180ac50716a097a407c6d7e7e4589754a922260)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/wireless/iwlwifi/mvm/fw-api-power.h
#	drivers/net/wireless/iwlwifi/mvm/fw-api.h
#	drivers/net/wireless/iwlwifi/mvm/fw.c
#	drivers/net/wireless/iwlwifi/mvm/ops.c
diff --cc drivers/net/wireless/iwlwifi/mvm/fw-api-power.h
index 81fe45f46be7,2fd8ad4633e0..000000000000
--- a/drivers/net/wireless/iwlwifi/mvm/fw-api-power.h
+++ b/drivers/net/wireless/iwlwifi/mvm/fw-api-power.h
@@@ -66,8 -68,46 +66,49 @@@
  
  /* Power Management Commands, Responses, Notifications */
  
++<<<<<<< HEAD
++=======
  /**
-  * enum iwl_scan_flags - masks for power table command flags
+  * enum iwl_ltr_config_flags - masks for LTR config command flags
+  * @LTR_CFG_FLAG_FEATURE_ENABLE: Feature operational status
+  * @LTR_CFG_FLAG_HW_DIS_ON_SHADOW_REG_ACCESS: allow LTR change on shadow
+  *	memory access
+  * @LTR_CFG_FLAG_HW_EN_SHRT_WR_THROUGH: allow LTR msg send on ANY LTR
+  *	reg change
+  * @LTR_CFG_FLAG_HW_DIS_ON_D0_2_D3: allow LTR msg send on transition from
+  *	D0 to D3
+  * @LTR_CFG_FLAG_SW_SET_SHORT: fixed static short LTR register
+  * @LTR_CFG_FLAG_SW_SET_LONG: fixed static short LONG register
+  * @LTR_CFG_FLAG_DENIE_C10_ON_PD: allow going into C10 on PD
+  */
+ enum iwl_ltr_config_flags {
+ 	LTR_CFG_FLAG_FEATURE_ENABLE = BIT(0),
+ 	LTR_CFG_FLAG_HW_DIS_ON_SHADOW_REG_ACCESS = BIT(1),
+ 	LTR_CFG_FLAG_HW_EN_SHRT_WR_THROUGH = BIT(2),
+ 	LTR_CFG_FLAG_HW_DIS_ON_D0_2_D3 = BIT(3),
+ 	LTR_CFG_FLAG_SW_SET_SHORT = BIT(4),
+ 	LTR_CFG_FLAG_SW_SET_LONG = BIT(5),
+ 	LTR_CFG_FLAG_DENIE_C10_ON_PD = BIT(6),
+ };
+ 
+ /**
+  * struct iwl_ltr_config_cmd - configures the LTR
+  * @flags: See %enum iwl_ltr_config_flags
+  */
+ struct iwl_ltr_config_cmd {
+ 	__le32 flags;
+ 	__le32 static_long;
+ 	__le32 static_short;
+ } __packed;
+ 
+ /* Radio LP RX Energy Threshold measured in dBm */
+ #define POWER_LPRX_RSSI_THRESHOLD	75
+ #define POWER_LPRX_RSSI_THRESHOLD_MAX	94
+ #define POWER_LPRX_RSSI_THRESHOLD_MIN	30
+ 
++>>>>>>> 9180ac50716a (iwlwifi: configure the LTR)
+ /**
+  * enum iwl_power_flags - masks for power table command flags
   * @POWER_FLAGS_POWER_SAVE_ENA_MSK: '1' Allow to save power by turning off
   *		receiver and transmitter. '0' - does not allow.
   * @POWER_FLAGS_POWER_MANAGEMENT_ENA_MSK: '0' Driver disables power management,
diff --cc drivers/net/wireless/iwlwifi/mvm/fw-api.h
index c6384555aab4,c62575d86bcd..000000000000
--- a/drivers/net/wireless/iwlwifi/mvm/fw-api.h
+++ b/drivers/net/wireless/iwlwifi/mvm/fw-api.h
@@@ -136,8 -154,13 +136,16 @@@ enum 
  	CALIB_RES_NOTIF_PHY_DB = 0x6b,
  	/* PHY_DB_CMD = 0x6c, */
  
 -	/* Power - legacy power table command */
 +	/* Power */
  	POWER_TABLE_CMD = 0x77,
++<<<<<<< HEAD
++=======
+ 	PSM_UAPSD_AP_MISBEHAVING_NOTIFICATION = 0x78,
+ 	LTR_CONFIG = 0xee,
+ 
+ 	/* Thermal Throttling*/
+ 	REPLY_THERMAL_MNG_BACKOFF = 0x7e,
++>>>>>>> 9180ac50716a (iwlwifi: configure the LTR)
  
  	/* Scanning */
  	SCAN_REQUEST_CMD = 0x80,
diff --cc drivers/net/wireless/iwlwifi/mvm/fw.c
index e18c92dd60ec,e0d9f19650b0..000000000000
--- a/drivers/net/wireless/iwlwifi/mvm/fw.c
+++ b/drivers/net/wireless/iwlwifi/mvm/fw.c
@@@ -443,8 -462,42 +443,46 @@@ int iwl_mvm_up(struct iwl_mvm *mvm
  	if (ret)
  		goto error;
  
++<<<<<<< HEAD
++=======
+ 	/* Add all the PHY contexts */
+ 	chan = &mvm->hw->wiphy->bands[IEEE80211_BAND_2GHZ]->channels[0];
+ 	cfg80211_chandef_create(&chandef, chan, NL80211_CHAN_NO_HT);
+ 	for (i = 0; i < NUM_PHY_CTX; i++) {
+ 		/*
+ 		 * The channel used here isn't relevant as it's
+ 		 * going to be overwritten in the other flows.
+ 		 * For now use the first channel we have.
+ 		 */
+ 		ret = iwl_mvm_phy_ctxt_add(mvm, &mvm->phy_ctxts[i],
+ 					   &chandef, 1, 1);
+ 		if (ret)
+ 			goto error;
+ 	}
+ 
+ 	/* Initialize tx backoffs to the minimal possible */
+ 	iwl_mvm_tt_tx_backoff(mvm, 0);
+ 
+ 	if (mvm->trans->ltr_enabled) {
+ 		struct iwl_ltr_config_cmd cmd = {
+ 			.flags = cpu_to_le32(LTR_CFG_FLAG_FEATURE_ENABLE),
+ 		};
+ 
+ 		WARN_ON(iwl_mvm_send_cmd_pdu(mvm, LTR_CONFIG, 0,
+ 					     sizeof(cmd), &cmd));
+ 	}
+ 
+ 	ret = iwl_mvm_power_update_device(mvm);
+ 	if (ret)
+ 		goto error;
+ 
+ 	/* allow FW/transport low power modes if not during restart */
+ 	if (!test_bit(IWL_MVM_STATUS_IN_HW_RESTART, &mvm->status))
+ 		iwl_mvm_unref(mvm, IWL_MVM_REF_UCODE_DOWN);
+ 
++>>>>>>> 9180ac50716a (iwlwifi: configure the LTR)
  	IWL_DEBUG_INFO(mvm, "RT uCode started.\n");
 +
  	return 0;
   error:
  	iwl_trans_stop_device(mvm->trans);
diff --cc drivers/net/wireless/iwlwifi/mvm/ops.c
index b29c31a41594,48cb25a93591..000000000000
--- a/drivers/net/wireless/iwlwifi/mvm/ops.c
+++ b/drivers/net/wireless/iwlwifi/mvm/ops.c
@@@ -293,6 -329,21 +293,24 @@@ static const char *iwl_mvm_cmd_strings[
  	CMD(BT_PROFILE_NOTIFICATION),
  	CMD(BT_CONFIG),
  	CMD(MCAST_FILTER_CMD),
++<<<<<<< HEAD
++=======
+ 	CMD(BCAST_FILTER_CMD),
+ 	CMD(REPLY_SF_CFG_CMD),
+ 	CMD(REPLY_BEACON_FILTERING_CMD),
+ 	CMD(CMD_DTS_MEASUREMENT_TRIGGER),
+ 	CMD(DTS_MEASUREMENT_NOTIFICATION),
+ 	CMD(REPLY_THERMAL_MNG_BACKOFF),
+ 	CMD(MAC_PM_POWER_TABLE),
+ 	CMD(LTR_CONFIG),
+ 	CMD(BT_COEX_CI),
+ 	CMD(BT_COEX_UPDATE_SW_BOOST),
+ 	CMD(BT_COEX_UPDATE_CORUN_LUT),
+ 	CMD(BT_COEX_UPDATE_REDUCED_TXP),
+ 	CMD(PSM_UAPSD_AP_MISBEHAVING_NOTIFICATION),
+ 	CMD(ANTENNA_COUPLING_NOTIFICATION),
+ 	CMD(SCD_QUEUE_CFG),
++>>>>>>> 9180ac50716a (iwlwifi: configure the LTR)
  };
  #undef CMD
  
diff --git a/drivers/net/wireless/iwlwifi/iwl-trans.h b/drivers/net/wireless/iwlwifi/iwl-trans.h
index 72d2ecce0b8d..d8df1d9b0de3 100644
--- a/drivers/net/wireless/iwlwifi/iwl-trans.h
+++ b/drivers/net/wireless/iwlwifi/iwl-trans.h
@@ -489,6 +489,7 @@ enum iwl_trans_state {
  *	Set during transport allocation.
  * @hw_id_str: a string with info about HW ID. Set during transport allocation.
  * @pm_support: set to true in start_hw if link pm is supported
+ * @ltr_enabled: set to true if the LTR is enabled
  * @dev_cmd_pool: pool for Tx cmd allocation - for internal use only.
  *	The user should use iwl_trans_{alloc,free}_tx_cmd.
  * @dev_cmd_headroom: room needed for the transport's private use before the
@@ -513,6 +514,7 @@ struct iwl_trans {
 	u8 rx_mpdu_cmd, rx_mpdu_cmd_hdr_size;
 
 	bool pm_support;
+	bool ltr_enabled;
 
 	/* The following fields are internal only */
 	struct kmem_cache *dev_cmd_pool;
* Unmerged path drivers/net/wireless/iwlwifi/mvm/fw-api-power.h
* Unmerged path drivers/net/wireless/iwlwifi/mvm/fw-api.h
* Unmerged path drivers/net/wireless/iwlwifi/mvm/fw.c
* Unmerged path drivers/net/wireless/iwlwifi/mvm/ops.c
diff --git a/drivers/net/wireless/iwlwifi/pcie/trans.c b/drivers/net/wireless/iwlwifi/pcie/trans.c
index aeb70e13137a..06bd02b774c7 100644
--- a/drivers/net/wireless/iwlwifi/pcie/trans.c
+++ b/drivers/net/wireless/iwlwifi/pcie/trans.c
@@ -121,6 +121,7 @@ static void iwl_pcie_apm_config(struct iwl_trans *trans)
 {
 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
 	u16 lctl;
+	u16 cap;
 
 	/*
 	 * HW bug W/A for instability in PCIe bus L0S->L1 transition.
@@ -131,16 +132,17 @@ static void iwl_pcie_apm_config(struct iwl_trans *trans)
 	 *    power savings, even without L1.
 	 */
 	pcie_capability_read_word(trans_pcie->pci_dev, PCI_EXP_LNKCTL, &lctl);
-	if (lctl & PCI_EXP_LNKCTL_ASPM_L1) {
-		/* L1-ASPM enabled; disable(!) L0S */
+	if (lctl & PCI_EXP_LNKCTL_ASPM_L1)
 		iwl_set_bit(trans, CSR_GIO_REG, CSR_GIO_REG_VAL_L0S_ENABLED);
-		dev_info(trans->dev, "L1 Enabled; Disabling L0S\n");
-	} else {
-		/* L1-ASPM disabled; enable(!) L0S */
+	else
 		iwl_clear_bit(trans, CSR_GIO_REG, CSR_GIO_REG_VAL_L0S_ENABLED);
-		dev_info(trans->dev, "L1 Disabled; Enabling L0S\n");
-	}
 	trans->pm_support = !(lctl & PCI_EXP_LNKCTL_ASPM_L0S);
+
+	pcie_capability_read_word(trans_pcie->pci_dev, PCI_EXP_DEVCTL2, &cap);
+	trans->ltr_enabled = cap & PCI_EXP_DEVCTL2_LTR_EN;
+	dev_info(trans->dev, "L1 %sabled - LTR %sabled\n",
+		 (lctl & PCI_EXP_LNKCTL_ASPM_L1) ? "En" : "Dis",
+		 trans->ltr_enabled ? "En" : "Dis");
 }
 
 /*
