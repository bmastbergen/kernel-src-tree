KVM: PPC: Book3S HV: Fix machine check delivery to guest

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/ppc: book3s/hv - Fix machine check delivery to guest (David Gibson) [1123145 1123133 1123367]
Rebuild_FUZZ: 92.86%
commit-author Paul Mackerras <paulus@samba.org>
commit 000a25ddb7106cdcb34e7f6c7547e5b2354b6645
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/000a25dd.failed

The code that delivered a machine check to the guest after handling
it in real mode failed to load up r11 before calling kvmppc_msr_interrupt,
which needs the old MSR value in r11 so it can see the transactional
state there.  This adds the missing load.

	Signed-off-by: Paul Mackerras <paulus@samba.org>
	Signed-off-by: Alexander Graf <agraf@suse.de>
(cherry picked from commit 000a25ddb7106cdcb34e7f6c7547e5b2354b6645)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_hv_rmhandlers.S
diff --cc arch/powerpc/kvm/book3s_hv_rmhandlers.S
index 0ae4c28ae4b6,220aefbcb7ca..000000000000
--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S
+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S
@@@ -1814,10 -2144,48 +1814,15 @@@ machine_check_realmode
  	beq	mc_cont
  	/* If not, deliver a machine check.  SRR0/1 are already set */
  	li	r10, BOOK3S_INTERRUPT_MACHINE_CHECK
++<<<<<<< HEAD
 +	li	r11, (MSR_ME << 1) | 1	/* synthesize MSR_SF | MSR_ME */
 +	rotldi	r11, r11, 63
++=======
+ 	ld	r11, VCPU_MSR(r9)
+ 	bl	kvmppc_msr_interrupt
++>>>>>>> 000a25ddb710 (KVM: PPC: Book3S HV: Fix machine check delivery to guest)
  	b	fast_interrupt_c_return
  
 -/*
 - * Check the reason we woke from nap, and take appropriate action.
 - * Returns:
 - *	0 if nothing needs to be done
 - *	1 if something happened that needs to be handled by the host
 - *	-1 if there was a guest wakeup (IPI)
 - *
 - * Also sets r12 to the interrupt vector for any interrupt that needs
 - * to be handled now by the host (0x500 for external interrupt), or zero.
 - */
 -kvmppc_check_wake_reason:
 -	mfspr	r6, SPRN_SRR1
 -BEGIN_FTR_SECTION
 -	rlwinm	r6, r6, 45-31, 0xf	/* extract wake reason field (P8) */
 -FTR_SECTION_ELSE
 -	rlwinm	r6, r6, 45-31, 0xe	/* P7 wake reason field is 3 bits */
 -ALT_FTR_SECTION_END_IFSET(CPU_FTR_ARCH_207S)
 -	cmpwi	r6, 8			/* was it an external interrupt? */
 -	li	r12, BOOK3S_INTERRUPT_EXTERNAL
 -	beq	kvmppc_read_intr	/* if so, see what it was */
 -	li	r3, 0
 -	li	r12, 0
 -	cmpwi	r6, 6			/* was it the decrementer? */
 -	beq	0f
 -BEGIN_FTR_SECTION
 -	cmpwi	r6, 5			/* privileged doorbell? */
 -	beq	0f
 -	cmpwi	r6, 3			/* hypervisor doorbell? */
 -	beq	3f
 -END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
 -	li	r3, 1			/* anything else, return 1 */
 -0:	blr
 -
 -	/* hypervisor doorbell */
 -3:	li	r12, BOOK3S_INTERRUPT_H_DOORBELL
 -	li	r3, 1
 -	blr
 -
  /*
   * Determine what sort of external interrupt is pending (if any).
   * Returns:
* Unmerged path arch/powerpc/kvm/book3s_hv_rmhandlers.S
