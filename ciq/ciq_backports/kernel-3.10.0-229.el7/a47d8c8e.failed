ACPI / hotplug / PCI: Avoid parent bus rescans on spurious device checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Avoid parent bus rescans on spurious device checks (Myron Stowe) [1114228]
Rebuild_FUZZ: 93.33%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit a47d8c8e72a5fa2e69117674c4b0b6cc79c5bc53
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a47d8c8e.failed

In the current ACPIPHP notify handler we always go directly for a
rescan of the parent bus if we get a device check notification for
a device that is not a bridge.  However, this obviously is
overzealous if nothing really changes, because this way we may rescan
the whole PCI hierarchy pretty much in vain.

That happens on Alex Williamson's machine whose ACPI tables contain
device objects that are supposed to coresspond to PCIe root ports,
but those ports aren't physically present (or at least they aren't
visible in the PCI config space to us).  The BIOS generates multiple
device check notifies for those objects during boot and for each of
them we go straight for the parent bus rescan, but the parent bus is
the root bus in this particular case.  In consequence, we rescan the
whole PCI bus from the top several times in a row, which is
completely unnecessary, increases boot time by 50% (after previous
fixes) and generates excess dmesg output from the PCI subsystem.

Fix the problem by checking if we can find anything new in the
slot corresponding to the device we've got a device check notify
for and doing nothig if that's not the case.

The spec (ACPI 5.0, Section 5.6.6) appears to mandate this behavior,
as it says:

  Device Check. Used to notify OSPM that the device either appeared
  or disappeared. If the device has appeared, OSPM will re-enumerate
  from the parent. If the device has disappeared, OSPM will
  invalidate the state of the device. OSPM may optimize out
  re-enumeration.

Therefore, according to the spec, we are free to do nothing if
nothing changes.

References: https://bugzilla.kernel.org/show_bug.cgi?id=60865
Reported-and-tested-by: Alex Williamson <alex.williamson@redhat.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit a47d8c8e72a5fa2e69117674c4b0b6cc79c5bc53)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index d210006fa4ad,9d6e535e74a1..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -669,34 -528,33 +669,48 @@@ static void check_hotplug_bridge(struc
  	}
  }
  
+ static int acpiphp_rescan_slot(struct acpiphp_slot *slot)
+ {
+ 	struct acpiphp_func *func;
+ 
+ 	list_for_each_entry(func, &slot->funcs, sibling)
+ 		acpiphp_bus_add(func_to_handle(func));
+ 
+ 	return pci_scan_slot(slot->bus, PCI_DEVFN(slot->device, 0));
+ }
+ 
  /**
 - * enable_slot - enable, configure a slot
 + * enable_device - enable, configure a slot
   * @slot: slot to be enabled
   *
   * This function should be called per *physical slot*,
   * not per each slot object in ACPI namespace.
   */
 -static void __ref enable_slot(struct acpiphp_slot *slot)
 +static int __ref enable_device(struct acpiphp_slot *slot)
  {
  	struct pci_dev *dev;
 -	struct pci_bus *bus = slot->bus;
 +	struct pci_bus *bus = slot->bridge->pci_bus;
  	struct acpiphp_func *func;
 -	int max, pass;
 +	int num, max, pass;
  	LIST_HEAD(add_list);
 -	int nr_found;
  
 +	if (slot->flags & SLOT_ENABLED)
 +		goto err_exit;
 +
++<<<<<<< HEAD
 +	list_for_each_entry(func, &slot->funcs, sibling)
 +		acpiphp_bus_add(func);
 +
 +	num = pci_scan_slot(bus, PCI_DEVFN(slot->device, 0));
 +	if (num == 0) {
 +		/* Maybe only part of funcs are added. */
 +		pr_debug("No new device found\n");
 +		goto err_exit;
 +	}
 +
++=======
+ 	nr_found = acpiphp_rescan_slot(slot);
++>>>>>>> a47d8c8e72a5 (ACPI / hotplug / PCI: Avoid parent bus rescans on spurious device checks)
  	max = acpiphp_max_busnr(bus);
  	for (pass = 0; pass < 2; pass++) {
  		list_for_each_entry(dev, &bus->devices, bus_list) {
@@@ -1010,13 -846,23 +1024,33 @@@ static void _handle_hotplug_event_bridg
  
  	case ACPI_NOTIFY_DEVICE_CHECK:
  		/* device check */
++<<<<<<< HEAD
 +		pr_debug("%s: Device check notify on %s\n", __func__, objname);
 +		acpiphp_check_bridge(bridge);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_WAKE:
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
++=======
+ 		dbg("%s: Device check notify on %s\n", __func__, objname);
+ 		if (bridge) {
+ 			acpiphp_check_bridge(bridge);
+ 		} else {
+ 			struct acpiphp_slot *slot = func->slot;
+ 			int ret;
+ 
+ 			/*
+ 			 * Check if anything has changed in the slot and rescan
+ 			 * from the parent if that's the case.
+ 			 */
+ 			mutex_lock(&slot->crit_sect);
+ 			ret = acpiphp_rescan_slot(slot);
+ 			mutex_unlock(&slot->crit_sect);
+ 			if (ret)
+ 				acpiphp_check_bridge(func->parent);
+ 		}
++>>>>>>> a47d8c8e72a5 (ACPI / hotplug / PCI: Avoid parent bus rescans on spurious device checks)
  		break;
  
  	case ACPI_NOTIFY_EJECT_REQUEST:
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
