rbd: use helpers to handle discard for layered images correctly

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Josh Durgin <josh.durgin@inktank.com>
commit d3246fb0da5d70838469c01d5b6b11163b49cd86
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d3246fb0.failed

Only allocate two osd ops for discard requests, since the
preallocation hint is only added for regular writes.  Use
rbd_img_obj_request_fill() to recreate the original write or discard
osd operations, isolating that logic to one place, and change the
assert in rbd_osd_req_create_copyup() to accept discard requests as
well.

	Signed-off-by: Josh Durgin <josh.durgin@inktank.com>
(cherry picked from commit d3246fb0da5d70838469c01d5b6b11163b49cd86)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/rbd.c
diff --cc drivers/block/rbd.c
index 0c349c7388a9,e1dcd36ae072..000000000000
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@@ -2270,6 -2326,67 +2277,70 @@@ out
  }
  
  /*
++<<<<<<< HEAD
++=======
+  * Add individual osd ops to the given ceph_osd_request and prepare
+  * them for submission. num_ops is the current number of
+  * osd operations already to the object request.
+  */
+ static void rbd_img_obj_request_fill(struct rbd_obj_request *obj_request,
+ 				struct ceph_osd_request *osd_request,
+ 				enum obj_operation_type op_type,
+ 				unsigned int num_ops)
+ {
+ 	struct rbd_img_request *img_request = obj_request->img_request;
+ 	struct rbd_device *rbd_dev = img_request->rbd_dev;
+ 	u64 object_size = rbd_obj_bytes(&rbd_dev->header);
+ 	u64 offset = obj_request->offset;
+ 	u64 length = obj_request->length;
+ 	u64 img_end;
+ 	u16 opcode;
+ 
+ 	if (op_type == OBJ_OP_DISCARD) {
+ 		if (!offset && length == object_size &&
+ 		    (!img_request_layered_test(img_request) ||
+ 		     !obj_request_overlaps_parent(obj_request))) {
+ 			opcode = CEPH_OSD_OP_DELETE;
+ 		} else if ((offset + length == object_size)) {
+ 			opcode = CEPH_OSD_OP_TRUNCATE;
+ 		} else {
+ 			down_read(&rbd_dev->header_rwsem);
+ 			img_end = rbd_dev->header.image_size;
+ 			up_read(&rbd_dev->header_rwsem);
+ 
+ 			if (obj_request->img_offset + length == img_end)
+ 				opcode = CEPH_OSD_OP_TRUNCATE;
+ 			else
+ 				opcode = CEPH_OSD_OP_ZERO;
+ 		}
+ 	} else if (op_type == OBJ_OP_WRITE) {
+ 		opcode = CEPH_OSD_OP_WRITE;
+ 		osd_req_op_alloc_hint_init(osd_request, num_ops,
+ 					object_size, object_size);
+ 		num_ops++;
+ 	} else {
+ 		opcode = CEPH_OSD_OP_READ;
+ 	}
+ 
+ 	osd_req_op_extent_init(osd_request, num_ops, opcode, offset, length,
+ 				0, 0);
+ 	if (obj_request->type == OBJ_REQUEST_BIO)
+ 		osd_req_op_extent_osd_data_bio(osd_request, num_ops,
+ 					obj_request->bio_list, length);
+ 	else if (obj_request->type == OBJ_REQUEST_PAGES)
+ 		osd_req_op_extent_osd_data_pages(osd_request, num_ops,
+ 					obj_request->pages, length,
+ 					offset & ~PAGE_MASK, false, false);
+ 
+ 	/* Discards are also writes */
+ 	if (op_type == OBJ_OP_WRITE || op_type == OBJ_OP_DISCARD)
+ 		rbd_osd_req_format_write(obj_request);
+ 	else
+ 		rbd_osd_req_format_read(obj_request);
+ }
+ 
+ /*
++>>>>>>> d3246fb0da5d (rbd: use helpers to handle discard for layered images correctly)
   * Split up an image request into one or more object requests, each
   * to a different object.  The "type" parameter indicates whether
   * "data_desc" is the pointer to the head of a list of bio
* Unmerged path drivers/block/rbd.c
