ACPI / hotplug: Do not fail bus and device checks for disabled hotplug

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug: Do not fail bus and device checks for disabled hotplug (Myron Stowe) [1128632]
Rebuild_FUZZ: 94.74%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 1ceaba05b4afb4bd7b4b4801f2718c13f59321eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/1ceaba05.failed

If the scan handler for the given device has hotplug.enabled
unset, it doesn't really make sense to fail bus check and device
check notifications.

First, bus check may not have anything to do with the device it is
signaled for, but it may concern another device on the bus below
this one.  For this reason, bus check notifications should not be
failed if hotplug is disabled for the target device.

Second, device check notifications are signaled only after a device
has already appeared (or disappeared), so failing it can only prevent
scan handlers and drivers from attaching to that (already existing)
device, which is not very useful.

Consequently, if device hotplug is disabled through the device's
scan handler, fail eject request notifications only.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 1ceaba05b4afb4bd7b4b4801f2718c13f59321eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/scan.c
diff --cc drivers/acpi/scan.c
index 2bbdeee33be4,4fa416f94f52..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -356,58 -363,9 +356,64 @@@ static void acpi_scan_bus_device_check(
  	unlock_device_hotplug();
  }
  
++<<<<<<< HEAD
 +static void acpi_scan_bus_check(void *context)
 +{
 +	acpi_scan_bus_device_check((acpi_handle)context,
 +				   ACPI_NOTIFY_BUS_CHECK);
 +}
 +
 +static void acpi_scan_device_check(void *context)
 +{
 +	acpi_scan_bus_device_check((acpi_handle)context,
 +				   ACPI_NOTIFY_DEVICE_CHECK);
 +}
 +
 +static void acpi_hotplug_unsupported(acpi_handle handle, u32 type)
 +{
 +	u32 ost_status;
 +
 +	switch (type) {
 +	case ACPI_NOTIFY_BUS_CHECK:
 +		acpi_handle_debug(handle,
 +			"ACPI_NOTIFY_BUS_CHECK event: unsupported\n");
 +		ost_status = ACPI_OST_SC_INSERT_NOT_SUPPORTED;
 +		break;
 +	case ACPI_NOTIFY_DEVICE_CHECK:
 +		acpi_handle_debug(handle,
 +			"ACPI_NOTIFY_DEVICE_CHECK event: unsupported\n");
 +		ost_status = ACPI_OST_SC_INSERT_NOT_SUPPORTED;
 +		break;
 +	case ACPI_NOTIFY_EJECT_REQUEST:
 +		acpi_handle_debug(handle,
 +			"ACPI_NOTIFY_EJECT_REQUEST event: unsupported\n");
 +		ost_status = ACPI_OST_SC_EJECT_NOT_SUPPORTED;
 +		break;
 +	default:
 +		/* non-hotplug event; possibly handled by other handler */
 +		return;
 +	}
 +
 +	acpi_evaluate_hotplug_ost(handle, type, ost_status, NULL);
 +}
 +
 +/**
 + * acpi_bus_hot_remove_device: Hot-remove a device and its children.
 + * @context: Address of the ACPI device object to hot-remove.
 + */
 +static void acpi_bus_hot_remove_device(void *context)
 +{
 +	acpi_bus_device_eject(context, ACPI_NOTIFY_EJECT_REQUEST);
 +}
 +
 +static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
 +{
 +	acpi_osd_exec_callback callback;
++=======
+ static void acpi_hotplug_notify_cb(acpi_handle handle, u32 type, void *data)
+ {
+ 	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
++>>>>>>> 1ceaba05b4af (ACPI / hotplug: Do not fail bus and device checks for disabled hotplug)
  	struct acpi_scan_handler *handler = data;
  	struct acpi_device *adev;
  	acpi_status status;
* Unmerged path drivers/acpi/scan.c
