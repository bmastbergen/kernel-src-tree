iommu/vt-d: Make domain_remove_one_dev_info() take struct device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Make domain_remove_one_dev_info() take struct device (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 95.08%
commit-author David Woodhouse <David.Woodhouse@intel.com>
commit bf9c9eda718bd56dde772270d117a8ef51bcea7e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/bf9c9eda.failed

	Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
(cherry picked from commit bf9c9eda718bd56dde772270d117a8ef51bcea7e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index bd20ea6166e6,66c2921f6404..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -450,9 -422,12 +450,15 @@@ static LIST_HEAD(unmaps_to_do)
  static int timer_on;
  static long list_size;
  
 -static void domain_exit(struct dmar_domain *domain);
  static void domain_remove_dev_info(struct dmar_domain *domain);
  static void domain_remove_one_dev_info(struct dmar_domain *domain,
++<<<<<<< HEAD
 +				       struct pci_dev *pdev);
++=======
+ 				       struct device *dev);
+ static void iommu_detach_dependent_devices(struct intel_iommu *iommu,
+ 					   struct device *dev);
++>>>>>>> bf9c9eda718b (iommu/vt-d: Make domain_remove_one_dev_info() take struct device)
  
  #ifdef CONFIG_INTEL_IOMMU_DEFAULT_ON
  int dmar_disabled = 0;
@@@ -2343,32 -2473,22 +2349,36 @@@ static int domain_add_dev_info(struct d
  			       struct pci_dev *pdev,
  			       int translation)
  {
 -	struct dmar_domain *ndomain;
 -	struct intel_iommu *iommu;
 -	u8 bus, devfn;
 +	struct device_domain_info *info;
 +	unsigned long flags;
  	int ret;
  
 -	iommu = device_to_iommu(&pdev->dev, &bus, &devfn);
 -	if (!iommu)
 -		return -ENODEV;
 +	info = alloc_devinfo_mem();
 +	if (!info)
 +		return -ENOMEM;
 +
 +	info->segment = pci_domain_nr(pdev->bus);
 +	info->bus = pdev->bus->number;
 +	info->devfn = pdev->devfn;
 +	info->dev = pdev;
 +	info->domain = domain;
  
 -	ndomain = dmar_insert_dev_info(iommu, bus, devfn, &pdev->dev, domain);
 -	if (ndomain != domain)
 -		return -EBUSY;
 +	spin_lock_irqsave(&device_domain_lock, flags);
 +	list_add(&info->link, &domain->devices);
 +	list_add(&info->global, &device_domain_list);
 +	pdev->dev.archdata.iommu = info;
 +	spin_unlock_irqrestore(&device_domain_lock, flags);
  
 -	ret = domain_context_mapping(domain, &pdev->dev, translation);
 +	ret = domain_context_mapping(domain, pdev, translation);
  	if (ret) {
++<<<<<<< HEAD
 +		spin_lock_irqsave(&device_domain_lock, flags);
 +		unlink_domain_info(info);
 +		spin_unlock_irqrestore(&device_domain_lock, flags);
 +		free_devinfo_mem(info);
++=======
+ 		domain_remove_one_dev_info(domain, &pdev->dev);
++>>>>>>> bf9c9eda718b (iommu/vt-d: Make domain_remove_one_dev_info() take struct device)
  		return ret;
  	}
  
@@@ -3685,7 -3823,8 +3694,12 @@@ static int device_notifier(struct notif
  	if (!domain)
  		return 0;
  
++<<<<<<< HEAD
 +	domain_remove_one_dev_info(domain, pdev);
++=======
+ 	down_read(&dmar_global_lock);
+ 	domain_remove_one_dev_info(domain, dev);
++>>>>>>> bf9c9eda718b (iommu/vt-d: Make domain_remove_one_dev_info() take struct device)
  	if (!(domain->flags & DOMAIN_FLAG_VIRTUAL_MACHINE) &&
  	    !(domain->flags & DOMAIN_FLAG_STATIC_IDENTITY) &&
  	    list_empty(&domain->devices))
@@@ -3886,23 -4032,22 +3900,36 @@@ static void domain_remove_one_dev_info(
  	struct intel_iommu *iommu;
  	unsigned long flags;
  	int found = 0;
 -	u8 bus, devfn;
  
++<<<<<<< HEAD
 +	iommu = device_to_iommu(pci_domain_nr(pdev->bus), pdev->bus->number,
 +				pdev->devfn);
++=======
+ 	iommu = device_to_iommu(dev, &bus, &devfn);
++>>>>>>> bf9c9eda718b (iommu/vt-d: Make domain_remove_one_dev_info() take struct device)
  	if (!iommu)
  		return;
  
  	spin_lock_irqsave(&device_domain_lock, flags);
  	list_for_each_entry_safe(info, tmp, &domain->devices, link) {
++<<<<<<< HEAD
 +		if (info->segment == pci_domain_nr(pdev->bus) &&
 +		    info->bus == pdev->bus->number &&
 +		    info->devfn == pdev->devfn) {
++=======
+ 		if (info->iommu == iommu && info->bus == bus &&
+ 		    info->devfn == devfn) {
++>>>>>>> bf9c9eda718b (iommu/vt-d: Make domain_remove_one_dev_info() take struct device)
  			unlink_domain_info(info);
  			spin_unlock_irqrestore(&device_domain_lock, flags);
  
  			iommu_disable_dev_iotlb(info);
  			iommu_detach_dev(iommu, info->bus, info->devfn);
++<<<<<<< HEAD
 +			iommu_detach_dependent_devices(iommu, pdev);
++=======
+ 			iommu_detach_dependent_devices(iommu, dev);
++>>>>>>> bf9c9eda718b (iommu/vt-d: Make domain_remove_one_dev_info() take struct device)
  			free_devinfo_mem(info);
  
  			spin_lock_irqsave(&device_domain_lock, flags);
* Unmerged path drivers/iommu/intel-iommu.c
