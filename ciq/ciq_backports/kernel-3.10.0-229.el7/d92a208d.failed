powerpc/pci: Mask linkDown on resetting PCI bus

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [powerpc] pci: Mask linkDown on resetting PCI bus (Don Zickus) [1127366]
Rebuild_FUZZ: 90.70%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit d92a208d086063ecc785b4588f74ab42268cbc4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d92a208d.failed

The problem was initially reported by Wendy who tried pass through
IPR adapter, which was connected to PHB root port directly, to KVM
based guest. When doing that, pci_reset_bridge_secondary_bus() was
called by VFIO driver and linkDown was detected by the root port.
That caused all PEs to be frozen.

The patch fixes the issue by routing the reset for the secondary bus
of root port to underly firmware. For that, one more weak function
pci_reset_secondary_bus() is introduced so that the individual platforms
can override that and do specific reset for bridge's secondary bus.

	Reported-by: Wendy Xiong <wenxiong@linux.vnet.ibm.com>
	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit d92a208d086063ecc785b4588f74ab42268cbc4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/eeh-ioda.c
#	arch/powerpc/platforms/powernv/pci.h
diff --cc arch/powerpc/platforms/powernv/eeh-ioda.c
index be33a16408be,58ef80987eed..000000000000
--- a/arch/powerpc/platforms/powernv/eeh-ioda.c
+++ b/arch/powerpc/platforms/powernv/eeh-ioda.c
@@@ -459,26 -470,51 +459,65 @@@ out
  	return 0;
  }
  
 -static int ioda_eeh_bridge_reset(struct pci_dev *dev, int option)
 -
 +static int ioda_eeh_bridge_reset(struct pci_controller *hose,
 +		struct pci_dev *dev, int option)
  {
++<<<<<<< HEAD
 +	u16 ctrl;
++=======
+ 	struct device_node *dn = pci_device_to_OF_node(dev);
+ 	struct eeh_dev *edev = of_node_to_eeh_dev(dn);
+ 	int aer = edev ? edev->aer_cap : 0;
+ 	u32 ctrl;
++>>>>>>> d92a208d0860 (powerpc/pci: Mask linkDown on resetting PCI bus)
  
 -	pr_debug("%s: Reset PCI bus %04x:%02x with option %d\n",
 -		 __func__, pci_domain_nr(dev->bus),
 -		 dev->bus->number, option);
 +	pr_debug("%s: Reset device %04x:%02x:%02x.%01x with option %d\n",
 +		 __func__, hose->global_number, dev->bus->number,
 +		 PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn), option);
  
  	switch (option) {
  	case EEH_RESET_FUNDAMENTAL:
  	case EEH_RESET_HOT:
++<<<<<<< HEAD
 +		pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &ctrl);
 +		ctrl |= PCI_BRIDGE_CTL_BUS_RESET;
 +		pci_write_config_word(dev, PCI_BRIDGE_CONTROL, ctrl);
++=======
+ 		/* Don't report linkDown event */
+ 		if (aer) {
+ 			eeh_ops->read_config(dn, aer + PCI_ERR_UNCOR_MASK,
+ 					     4, &ctrl);
+ 			ctrl |= PCI_ERR_UNC_SURPDN;
+                         eeh_ops->write_config(dn, aer + PCI_ERR_UNCOR_MASK,
+ 					      4, ctrl);
+                 }
+ 
+ 		eeh_ops->read_config(dn, PCI_BRIDGE_CONTROL, 2, &ctrl);
+ 		ctrl |= PCI_BRIDGE_CTL_BUS_RESET;
+ 		eeh_ops->write_config(dn, PCI_BRIDGE_CONTROL, 2, ctrl);
+ 		msleep(EEH_PE_RST_HOLD_TIME);
+ 
++>>>>>>> d92a208d0860 (powerpc/pci: Mask linkDown on resetting PCI bus)
  		break;
  	case EEH_RESET_DEACTIVATE:
 -		eeh_ops->read_config(dn, PCI_BRIDGE_CONTROL, 2, &ctrl);
 +		pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &ctrl);
  		ctrl &= ~PCI_BRIDGE_CTL_BUS_RESET;
++<<<<<<< HEAD
 +		pci_write_config_word(dev, PCI_BRIDGE_CONTROL, ctrl);
++=======
+ 		eeh_ops->write_config(dn, PCI_BRIDGE_CONTROL, 2, ctrl);
+ 		msleep(EEH_PE_RST_SETTLE_TIME);
+ 
+ 		/* Continue reporting linkDown event */
+ 		if (aer) {
+ 			eeh_ops->read_config(dn, aer + PCI_ERR_UNCOR_MASK,
+ 					     4, &ctrl);
+ 			ctrl &= ~PCI_ERR_UNC_SURPDN;
+ 			eeh_ops->write_config(dn, aer + PCI_ERR_UNCOR_MASK,
+ 					      4, ctrl);
+ 		}
+ 
++>>>>>>> d92a208d0860 (powerpc/pci: Mask linkDown on resetting PCI bus)
  		break;
  	}
  
diff --cc arch/powerpc/platforms/powernv/pci.h
index 48749fa60351,34a09740aad3..000000000000
--- a/arch/powerpc/platforms/powernv/pci.h
+++ b/arch/powerpc/platforms/powernv/pci.h
@@@ -197,6 -203,7 +197,11 @@@ extern void pnv_pci_init_p5ioc2_hub(str
  extern void pnv_pci_init_ioda_hub(struct device_node *np);
  extern void pnv_pci_init_ioda2_phb(struct device_node *np);
  extern void pnv_pci_ioda_tce_invalidate(struct iommu_table *tbl,
++<<<<<<< HEAD
 +					__be64 *startp, __be64 *endp);
++=======
+ 					__be64 *startp, __be64 *endp, bool rm);
+ extern void pnv_pci_reset_secondary_bus(struct pci_dev *dev);
++>>>>>>> d92a208d0860 (powerpc/pci: Mask linkDown on resetting PCI bus)
  
  #endif /* __POWERNV_PCI_H */
diff --git a/arch/powerpc/include/asm/machdep.h b/arch/powerpc/include/asm/machdep.h
index 24042603ed03..d851417ff2c1 100644
--- a/arch/powerpc/include/asm/machdep.h
+++ b/arch/powerpc/include/asm/machdep.h
@@ -229,6 +229,9 @@ struct machdep_calls {
 	/* Called during PCI resource reassignment */
 	resource_size_t (*pcibios_window_alignment)(struct pci_bus *, unsigned long type);
 
+	/* Reset the secondary bus of bridge */
+	void  (*pcibios_reset_secondary_bus)(struct pci_dev *dev);
+
 	/* Called to shutdown machine specific hardware not already controlled
 	 * by other drivers.
 	 */
diff --git a/arch/powerpc/kernel/pci-common.c b/arch/powerpc/kernel/pci-common.c
index 905a24bb7acc..08905dc8457a 100644
--- a/arch/powerpc/kernel/pci-common.c
+++ b/arch/powerpc/kernel/pci-common.c
@@ -21,6 +21,7 @@
 #include <linux/string.h>
 #include <linux/init.h>
 #include <linux/bootmem.h>
+#include <linux/delay.h>
 #include <linux/export.h>
 #include <linux/of_address.h>
 #include <linux/of_pci.h>
@@ -120,6 +121,25 @@ resource_size_t pcibios_window_alignment(struct pci_bus *bus,
 	return 1;
 }
 
+void pcibios_reset_secondary_bus(struct pci_dev *dev)
+{
+	u16 ctrl;
+
+	if (ppc_md.pcibios_reset_secondary_bus) {
+		ppc_md.pcibios_reset_secondary_bus(dev);
+		return;
+	}
+
+	pci_read_config_word(dev, PCI_BRIDGE_CONTROL, &ctrl);
+	ctrl |= PCI_BRIDGE_CTL_BUS_RESET;
+	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, ctrl);
+	msleep(2);
+
+	ctrl &= ~PCI_BRIDGE_CTL_BUS_RESET;
+	pci_write_config_word(dev, PCI_BRIDGE_CONTROL, ctrl);
+	ssleep(1);
+}
+
 static resource_size_t pcibios_io_size(const struct pci_controller *hose)
 {
 #ifdef CONFIG_PPC64
* Unmerged path arch/powerpc/platforms/powernv/eeh-ioda.c
diff --git a/arch/powerpc/platforms/powernv/pci-ioda.c b/arch/powerpc/platforms/powernv/pci-ioda.c
index db28bbfcd20e..d8d5583bf30c 100644
--- a/arch/powerpc/platforms/powernv/pci-ioda.c
+++ b/arch/powerpc/platforms/powernv/pci-ioda.c
@@ -1276,6 +1276,7 @@ void __init pnv_pci_init_ioda_phb(struct device_node *np,
 	ppc_md.pcibios_fixup = pnv_pci_ioda_fixup;
 	ppc_md.pcibios_enable_device_hook = pnv_pci_enable_device_hook;
 	ppc_md.pcibios_window_alignment = pnv_pci_window_alignment;
+	ppc_md.pcibios_reset_secondary_bus = pnv_pci_reset_secondary_bus;
 	pci_add_flags(PCI_REASSIGN_ALL_RSRC);
 
 	/* Reset IODA tables to a clean state */
* Unmerged path arch/powerpc/platforms/powernv/pci.h
diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c
index 84ea416bd62d..5157723caf1e 100644
--- a/drivers/pci/pci.c
+++ b/drivers/pci/pci.c
@@ -3184,14 +3184,7 @@ static int pci_pm_reset(struct pci_dev *dev, int probe)
 	return 0;
 }
 
-/**
- * pci_reset_bridge_secondary_bus - Reset the secondary bus on a PCI bridge.
- * @dev: Bridge device
- *
- * Use the bridge control register to assert reset on the secondary bus.
- * Devices on the secondary bus are left in power-on state.
- */
-void pci_reset_bridge_secondary_bus(struct pci_dev *dev)
+void __weak pcibios_reset_secondary_bus(struct pci_dev *dev)
 {
 	u16 ctrl;
 
@@ -3216,6 +3209,18 @@ void pci_reset_bridge_secondary_bus(struct pci_dev *dev)
 	 */
 	ssleep(1);
 }
+
+/**
+ * pci_reset_bridge_secondary_bus - Reset the secondary bus on a PCI bridge.
+ * @dev: Bridge device
+ *
+ * Use the bridge control register to assert reset on the secondary bus.
+ * Devices on the secondary bus are left in power-on state.
+ */
+void pci_reset_bridge_secondary_bus(struct pci_dev *dev)
+{
+	pcibios_reset_secondary_bus(dev);
+}
 EXPORT_SYMBOL_GPL(pci_reset_bridge_secondary_bus);
 
 static int pci_parent_bus_reset(struct pci_dev *dev, int probe)
