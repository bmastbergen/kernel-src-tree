cpufreq: unlock when failing cpufreq_update_policy()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] unlock when failing cpufreq_update_policy() (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 90.53%
commit-author Aaron Plattner <aplattner@nvidia.com>
commit fefa8ff810c5ab4c4206aed9d159c4d6fe8d4f1c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/fefa8ff8.failed

Commit bd0fa9bb455d introduced a failure path to cpufreq_update_policy() if
cpufreq_driver->get(cpu) returns NULL.  However, it jumps to the 'no_policy'
label, which exits without unlocking any of the locks the function acquired
earlier.  This causes later calls into cpufreq to hang.

Fix this by creating a new 'unlock' label and jumping to that instead.

Fixes: bd0fa9bb455d ("cpufreq: Return error if ->get() failed in cpufreq_update_policy()")
Link: https://devtalk.nvidia.com/default/topic/751903/kernel-3-15-and-nv-drivers-337-340-failed-to-initialize-the-nvidia-kernel-module-gtx-550-ti-/
	Signed-off-by: Aaron Plattner <aplattner@nvidia.com>
	Cc: 3.15+ <stable@vger.kernel.org> # 3.15+
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit fefa8ff810c5ab4c4206aed9d159c4d6fe8d4f1c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index a029f5bcbc1e,62259d27f03e..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -1922,50 -2238,49 +1922,75 @@@ error_out
   */
  int cpufreq_update_policy(unsigned int cpu)
  {
 -	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
 -	struct cpufreq_policy new_policy;
 +	struct cpufreq_policy *data = cpufreq_cpu_get(cpu);
 +	struct cpufreq_policy policy;
  	int ret;
  
++<<<<<<< HEAD
 +	if (!data) {
 +		ret = -ENODEV;
 +		goto no_policy;
 +	}
++=======
+ 	if (!policy)
+ 		return -ENODEV;
++>>>>>>> fefa8ff810c5 (cpufreq: unlock when failing cpufreq_update_policy())
  
 -	down_write(&policy->rwsem);
 +	if (unlikely(lock_policy_rwsem_write(cpu))) {
 +		ret = -EINVAL;
 +		goto fail;
 +	}
  
  	pr_debug("updating policy for CPU %u\n", cpu);
 -	memcpy(&new_policy, policy, sizeof(*policy));
 -	new_policy.min = policy->user_policy.min;
 -	new_policy.max = policy->user_policy.max;
 -	new_policy.policy = policy->user_policy.policy;
 -	new_policy.governor = policy->user_policy.governor;
 +	memcpy(&policy, data, sizeof(struct cpufreq_policy));
 +	policy.min = data->user_policy.min;
 +	policy.max = data->user_policy.max;
 +	policy.policy = data->user_policy.policy;
 +	policy.governor = data->user_policy.governor;
  
  	/*
  	 * BIOS might change freq behind our back
  	 * -> ask driver for current freq and notify governors about a change
  	 */
++<<<<<<< HEAD
 +	if (cpufreq_driver->get) {
 +		policy.cur = cpufreq_driver->get(cpu);
 +		if (!data->cur) {
 +			pr_debug("Driver did not initialize current freq");
 +			data->cur = policy.cur;
++=======
+ 	if (cpufreq_driver->get && !cpufreq_driver->setpolicy) {
+ 		new_policy.cur = cpufreq_driver->get(cpu);
+ 		if (WARN_ON(!new_policy.cur)) {
+ 			ret = -EIO;
+ 			goto unlock;
+ 		}
+ 
+ 		if (!policy->cur) {
+ 			pr_debug("Driver did not initialize current freq\n");
+ 			policy->cur = new_policy.cur;
++>>>>>>> fefa8ff810c5 (cpufreq: unlock when failing cpufreq_update_policy())
  		} else {
 -			if (policy->cur != new_policy.cur && has_target())
 -				cpufreq_out_of_sync(cpu, policy->cur,
 -								new_policy.cur);
 +			if (data->cur != policy.cur && cpufreq_driver->target)
 +				cpufreq_out_of_sync(cpu, data->cur,
 +								policy.cur);
  		}
  	}
  
 -	ret = cpufreq_set_policy(policy, &new_policy);
 +	ret = __cpufreq_set_policy(data, &policy);
  
++<<<<<<< HEAD
 +	unlock_policy_rwsem_write(cpu);
 +
 +fail:
 +	cpufreq_cpu_put(data);
 +no_policy:
++=======
+ unlock:
+ 	up_write(&policy->rwsem);
+ 
+ 	cpufreq_cpu_put(policy);
++>>>>>>> fefa8ff810c5 (cpufreq: unlock when failing cpufreq_update_policy())
  	return ret;
  }
  EXPORT_SYMBOL(cpufreq_update_policy);
* Unmerged path drivers/cpufreq/cpufreq.c
