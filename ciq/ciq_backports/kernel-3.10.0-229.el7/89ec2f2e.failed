ACPI / hotplug / PCI: Don't trim devices before scanning the namespace

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Don't trim devices before scanning the namespace (Myron Stowe) [1114228]
Rebuild_FUZZ: 93.13%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 89ec2f2ee104970329139e6526a075113c92f650
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/89ec2f2e.failed

In acpiphp_bus_add() we first remove device objects corresponding to
the given handle and the ACPI namespace branch below it, which are
then re-created by acpi_bus_scan().  This used to be done to clean
up after surprise removals, but now we do the cleanup through
trim_stale_devices() which checks if the devices in question are
actually gone before removing them, so the device hierarchy trimming
in acpiphp_bus_add() is not necessary any more and, moreover, it may
lead to problems if it removes device objects corresponding to
devices that are actually present.

For this reason, remove the leftover acpiphp_bus_trim() from
acpiphp_bus_add().

	Reported-by: Alex Williamson <alex.williamson@redhat.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 89ec2f2ee104970329139e6526a075113c92f650)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index d210006fa4ad,3f78212f4eee..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -585,52 -466,31 +585,59 @@@ static unsigned char acpiphp_max_busnr(
  	return max;
  }
  
 +
  /**
 - * acpiphp_bus_trim - Trim device objects in an ACPI namespace subtree.
 - * @handle: ACPI device object handle to start from.
 + * acpiphp_bus_add - add a new bus to acpi subsystem
 + * @func: acpiphp_func of the bridge
   */
 -static void acpiphp_bus_trim(acpi_handle handle)
 +static int acpiphp_bus_add(struct acpiphp_func *func)
  {
 -	struct acpi_device *adev = NULL;
 +	struct acpi_device *device;
 +	int ret_val;
  
 -	acpi_bus_get_device(handle, &adev);
 -	if (adev)
 -		acpi_bus_trim(adev);
 +	if (!acpi_bus_get_device(func->handle, &device)) {
 +		pr_debug("bus exists... trim\n");
 +		/* this shouldn't be in here, so remove
 +		 * the bus then re-add it...
 +		 */
 +		acpi_bus_trim(device);
 +	}
 +
 +	ret_val = acpi_bus_scan(func->handle);
 +	if (!ret_val)
 +		ret_val = acpi_bus_get_device(func->handle, &device);
 +
 +	if (ret_val)
 +		pr_debug("error adding bus, %x\n", -ret_val);
 +
 +	return ret_val;
  }
  
 +
++<<<<<<< HEAD
  /**
 - * acpiphp_bus_add - Scan ACPI namespace subtree.
 - * @handle: ACPI object handle to start the scan from.
 + * acpiphp_bus_trim - trim a bus from acpi subsystem
 + * @handle: handle to acpi namespace
   */
 -static void acpiphp_bus_add(acpi_handle handle)
 +static int acpiphp_bus_trim(acpi_handle handle)
  {
 -	struct acpi_device *adev = NULL;
 +	struct acpi_device *device;
 +	int retval;
 +
 +	retval = acpi_bus_get_device(handle, &device);
 +	if (retval) {
 +		pr_debug("acpi_device not found\n");
 +		return retval;
 +	}
  
 +	acpi_bus_trim(device);
 +	return 0;
++=======
+ 	acpi_bus_scan(handle);
+ 	acpi_bus_get_device(handle, &adev);
+ 	if (adev)
+ 		acpi_device_set_power(adev, ACPI_STATE_D0);
++>>>>>>> 89ec2f2ee104 (ACPI / hotplug / PCI: Don't trim devices before scanning the namespace)
  }
  
  static void acpiphp_set_acpi_region(struct acpiphp_slot *slot)
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
