hugetlb: ensure hugepage access is denied if hugepages are not supported

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Nishanth Aravamudan <nacc@linux.vnet.ibm.com>
commit 457c1b27ed56ec472d202731b12417bff023594a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/457c1b27.failed

Currently, I am seeing the following when I `mount -t hugetlbfs /none
/dev/hugetlbfs`, and then simply do a `ls /dev/hugetlbfs`.  I think it's
related to the fact that hugetlbfs is properly not correctly setting
itself up in this state?:

  Unable to handle kernel paging request for data at address 0x00000031
  Faulting instruction address: 0xc000000000245710
  Oops: Kernel access of bad area, sig: 11 [#1]
  SMP NR_CPUS=2048 NUMA pSeries
  ....

In KVM guests on Power, in a guest not backed by hugepages, we see the
following:

  AnonHugePages:         0 kB
  HugePages_Total:       0
  HugePages_Free:        0
  HugePages_Rsvd:        0
  HugePages_Surp:        0
  Hugepagesize:         64 kB

HPAGE_SHIFT == 0 in this configuration, which indicates that hugepages
are not supported at boot-time, but this is only checked in
hugetlb_init().  Extract the check to a helper function, and use it in a
few relevant places.

This does make hugetlbfs not supported (not registered at all) in this
environment.  I believe this is fine, as there are no valid hugepages
and that won't change at runtime.

[akpm@linux-foundation.org: use pr_info(), per Mel]
[akpm@linux-foundation.org: fix build when HPAGE_SHIFT is undefined]
	Signed-off-by: Nishanth Aravamudan <nacc@linux.vnet.ibm.com>
	Reviewed-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
	Acked-by: Mel Gorman <mgorman@suse.de>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 457c1b27ed56ec472d202731b12417bff023594a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/hugetlb.c
diff --cc mm/hugetlb.c
index e9ed3cb4a5b2,c82290b9c1fc..000000000000
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@@ -1862,11 -1979,9 +1862,17 @@@ module_exit(hugetlb_exit)
  
  static int __init hugetlb_init(void)
  {
++<<<<<<< HEAD
 +	/* Some platform decide whether they support huge pages at boot
 +	 * time. On these, such as powerpc, HPAGE_SHIFT is set to 0 when
 +	 * there is no such support
 +	 */
 +	if (HPAGE_SHIFT == 0)
++=======
+ 	int i;
+ 
+ 	if (!hugepages_supported())
++>>>>>>> 457c1b27ed56 (hugetlb: ensure hugepage access is denied if hugepages are not supported)
  		return 0;
  
  	if (!size_to_hstate(default_hstate_size)) {
diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c
index 4e5f332f15d9..5c7c227fd2d7 100644
--- a/fs/hugetlbfs/inode.c
+++ b/fs/hugetlbfs/inode.c
@@ -1007,6 +1007,11 @@ static int __init init_hugetlbfs_fs(void)
 	int error;
 	int i;
 
+	if (!hugepages_supported()) {
+		pr_info("hugetlbfs: disabling because there are no supported hugepage sizes\n");
+		return -ENOTSUPP;
+	}
+
 	error = bdi_init(&hugetlbfs_backing_dev_info);
 	if (error)
 		return error;
diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h
index 3386cad757e9..9c5f4fccf347 100644
--- a/include/linux/hugetlb.h
+++ b/include/linux/hugetlb.h
@@ -373,6 +373,16 @@ static inline spinlock_t *huge_pte_lockptr(struct hstate *h,
 	return &mm->page_table_lock;
 }
 
+static inline bool hugepages_supported(void)
+{
+	/*
+	 * Some platform decide whether they support huge pages at boot
+	 * time. On these, such as powerpc, HPAGE_SHIFT is set to 0 when
+	 * there is no such support
+	 */
+	return HPAGE_SHIFT != 0;
+}
+
 #else	/* CONFIG_HUGETLB_PAGE */
 struct hstate {};
 #define alloc_huge_page_node(h, nid) NULL
* Unmerged path mm/hugetlb.c
