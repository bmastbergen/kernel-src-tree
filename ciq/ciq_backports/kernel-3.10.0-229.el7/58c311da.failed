perf report: Count number of entries separately

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf/report: Count number of entries separately (Jiri Olsa) [1134356]
Rebuild_FUZZ: 97.87%
commit-author Namhyung Kim <namhyung@kernel.org>
commit 58c311da9cec97d7a665156a726bd1653384c65c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/58c311da.failed

The hists->nr_entries is counted in multiple places so that they can
confuse readers of the code.  This is a preparation of later change
and do not intend any functional difference.

Note that report__collapse_hists() now changed to return nothing since
its return value (nr_samples) is only for checking if there's any data
in the input file and this can be acheived by checking ->nr_entries.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
Link: http://lkml.kernel.org/r/1398327843-31845-2-git-send-email-namhyung@kernel.org
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
(cherry picked from commit 58c311da9cec97d7a665156a726bd1653384c65c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-report.c
diff --cc tools/perf/builtin-report.c
index e5db3d32cbee,aed52036468d..000000000000
--- a/tools/perf/builtin-report.c
+++ b/tools/perf/builtin-report.c
@@@ -74,31 -76,21 +75,47 @@@ static int report__config(const char *v
  	return perf_default_config(var, value, cb);
  }
  
++<<<<<<< HEAD
 +static int report__resolve_callchain(struct report *rep, struct symbol **parent,
 +				     struct perf_evsel *evsel, struct addr_location *al,
 +				     struct perf_sample *sample, struct machine *machine)
++=======
+ static void report__inc_stats(struct report *rep, struct hist_entry *he)
+ {
+ 	/*
+ 	 * The @he is either of a newly created one or an existing one
+ 	 * merging current sample.  We only want to count a new one so
+ 	 * checking ->nr_events being 1.
+ 	 */
+ 	if (he->stat.nr_events == 1)
+ 		rep->nr_entries++;
+ }
+ 
+ static int report__add_mem_hist_entry(struct report *rep, struct addr_location *al,
+ 				      struct perf_sample *sample, struct perf_evsel *evsel)
++>>>>>>> 58c311da9cec (perf report: Count number of entries separately)
  {
 +	if ((sort__has_parent || symbol_conf.use_callchain) && sample->callchain) {
 +		return machine__resolve_callchain(machine, evsel, al->thread, sample,
 +						  parent, al, rep->max_stack);
 +	}
 +	return 0;
 +}
 +
 +static int hist_entry__append_callchain(struct hist_entry *he, struct perf_sample *sample)
 +{
 +	if (!symbol_conf.use_callchain)
 +		return 0;
 +	return callchain_append(he->callchain, &callchain_cursor, sample->period);
 +}
 +
 +static int report__add_mem_hist_entry(struct perf_tool *tool, struct addr_location *al,
 +				      struct perf_sample *sample, struct perf_evsel *evsel,
 +				      struct machine *machine, union perf_event *event)
 +{
 +	struct report *rep = container_of(tool, struct report, tool);
  	struct symbol *parent = NULL;
 +	u8 cpumode = event->header.misc & PERF_RECORD_MISC_CPUMODE_MASK;
  	struct hist_entry *he;
  	struct mem_info *mi, *mx;
  	uint64_t cost;
@@@ -130,15 -122,19 +147,17 @@@
  	if (!he)
  		return -ENOMEM;
  
 -	if (ui__has_annotation()) {
 -		err = hist_entry__inc_addr_samples(he, evsel->idx, al->addr);
 -		if (err)
 -			goto out;
 +	err = hist_entry__inc_addr_samples(he, evsel->idx, al->addr);
 +	if (err)
 +		goto out;
  
 -		mx = he->mem_info;
 -		err = addr_map_symbol__inc_samples(&mx->daddr, evsel->idx);
 -		if (err)
 -			goto out;
 -	}
 +	mx = he->mem_info;
 +	err = addr_map_symbol__inc_samples(&mx->daddr, evsel->idx);
 +	if (err)
 +		goto out;
  
+ 	report__inc_stats(rep, he);
+ 
  	evsel->hists.stats.total_period += cost;
  	hists__inc_nr_events(&evsel->hists, PERF_RECORD_SAMPLE);
  	if (!he->filtered)
@@@ -184,15 -177,21 +203,17 @@@ static int report__add_branch_hist_entr
  		he = __hists__add_entry(&evsel->hists, al, parent, &bi[i], NULL,
  					1, 1, 0);
  		if (he) {
 -			if (ui__has_annotation()) {
 -				bx = he->branch_info;
 -				err = addr_map_symbol__inc_samples(&bx->from,
 -								   evsel->idx);
 -				if (err)
 -					goto out;
 -
 -				err = addr_map_symbol__inc_samples(&bx->to,
 -								   evsel->idx);
 -				if (err)
 -					goto out;
 -			}
 +			bx = he->branch_info;
 +			err = addr_map_symbol__inc_samples(&bx->from, evsel->idx);
 +			if (err)
 +				goto out;
 +
 +			err = addr_map_symbol__inc_samples(&bx->to, evsel->idx);
 +			if (err)
 +				goto out;
  
+ 			report__inc_stats(rep, he);
+ 
  			evsel->hists.stats.total_period += 1;
  			hists__inc_nr_events(&evsel->hists, PERF_RECORD_SAMPLE);
  			if (!he->filtered)
@@@ -228,7 -225,11 +249,15 @@@ static int report__add_hist_entry(struc
  	if (err)
  		goto out;
  
++<<<<<<< HEAD
 +	err = hist_entry__inc_addr_samples(he, evsel->idx, al->addr);
++=======
+ 	if (ui__has_annotation())
+ 		err = hist_entry__inc_addr_samples(he, evsel->idx, al->addr);
+ 
+ 	report__inc_stats(rep, he);
+ 
++>>>>>>> 58c311da9cec (perf report: Count number of entries separately)
  	evsel->hists.stats.total_period += sample->period;
  	if (!he->filtered)
  		evsel->hists.stats.nr_non_filtered_samples++;
@@@ -458,13 -459,84 +487,92 @@@ static void report__warn_kptr_restrict(
  	}
  }
  
++<<<<<<< HEAD
 +static int __cmd_report(struct report *rep)
 +{
 +	int ret = -EINVAL;
 +	u64 nr_samples;
++=======
+ static int report__gtk_browse_hists(struct report *rep, const char *help)
+ {
+ 	int (*hist_browser)(struct perf_evlist *evlist, const char *help,
+ 			    struct hist_browser_timer *timer, float min_pcnt);
+ 
+ 	hist_browser = dlsym(perf_gtk_handle, "perf_evlist__gtk_browse_hists");
+ 
+ 	if (hist_browser == NULL) {
+ 		ui__error("GTK browser not found!\n");
+ 		return -1;
+ 	}
+ 
+ 	return hist_browser(rep->session->evlist, help, NULL, rep->min_percent);
+ }
+ 
+ static int report__browse_hists(struct report *rep)
+ {
+ 	int ret;
+ 	struct perf_session *session = rep->session;
+ 	struct perf_evlist *evlist = session->evlist;
+ 	const char *help = "For a higher level overview, try: perf report --sort comm,dso";
+ 
+ 	switch (use_browser) {
+ 	case 1:
+ 		ret = perf_evlist__tui_browse_hists(evlist, help, NULL,
+ 						    rep->min_percent,
+ 						    &session->header.env);
+ 		/*
+ 		 * Usually "ret" is the last pressed key, and we only
+ 		 * care if the key notifies us to switch data file.
+ 		 */
+ 		if (ret != K_SWITCH_INPUT_DATA)
+ 			ret = 0;
+ 		break;
+ 	case 2:
+ 		ret = report__gtk_browse_hists(rep, help);
+ 		break;
+ 	default:
+ 		ret = perf_evlist__tty_browse_hists(evlist, rep, help);
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static void report__collapse_hists(struct report *rep)
+ {
+ 	struct ui_progress prog;
+ 	struct perf_evsel *pos;
+ 
+ 	ui_progress__init(&prog, rep->nr_entries, "Merging related events...");
+ 
+ 	evlist__for_each(rep->session->evlist, pos) {
+ 		struct hists *hists = &pos->hists;
+ 
+ 		if (pos->idx == 0)
+ 			hists->symbol_filter_str = rep->symbol_filter_str;
+ 
+ 		hists__collapse_resort(hists, &prog);
+ 
+ 		/* Non-group events are considered as leader */
+ 		if (symbol_conf.event_group &&
+ 		    !perf_evsel__is_group_leader(pos)) {
+ 			struct hists *leader_hists = &pos->leader->hists;
+ 
+ 			hists__match(leader_hists, hists);
+ 			hists__link(leader_hists, hists);
+ 		}
+ 	}
+ 
+ 	ui_progress__finish();
+ }
+ 
+ static int __cmd_report(struct report *rep)
+ {
+ 	int ret;
++>>>>>>> 58c311da9cec (perf report: Count number of entries separately)
  	struct perf_session *session = rep->session;
  	struct perf_evsel *pos;
 +	const char *help = "For a higher level overview, try: perf report --sort comm,dso";
  	struct perf_data_file *file = session->file;
  
  	signal(SIGINT, sig_handler);
@@@ -502,25 -574,7 +610,29 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	nr_samples = 0;
 +	list_for_each_entry(pos, &session->evlist->entries, node) {
 +		struct hists *hists = &pos->hists;
 +
 +		if (pos->idx == 0)
 +			hists->symbol_filter_str = rep->symbol_filter_str;
 +
 +		hists__collapse_resort(hists);
 +		nr_samples += hists->stats.nr_events[PERF_RECORD_SAMPLE];
 +
 +		/* Non-group events are considered as leader */
 +		if (symbol_conf.event_group &&
 +		    !perf_evsel__is_group_leader(pos)) {
 +			struct hists *leader_hists = &pos->leader->hists;
 +
 +			hists__match(leader_hists, hists);
 +			hists__link(leader_hists, hists);
 +		}
 +	}
++=======
+ 	report__collapse_hists(rep);
++>>>>>>> 58c311da9cec (perf report: Count number of entries separately)
  
  	if (session_done())
  		return 0;
* Unmerged path tools/perf/builtin-report.c
