intel_pstate: Improve initial busy calculation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Doug Smythies <dsmythies@telus.net>
commit bf8102228a8bf053051f311e5486042fe0542894
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/bf810222.failed

This change makes the busy calculation using 64 bit math which prevents
overflow for large values of aperf/mperf.

	Cc: 3.14+ <stable@vger.kernel.org> # 3.14+
	Signed-off-by: Doug Smythies <dsmythies@telus.net>
	Signed-off-by: Dirk Brandewie <dirk.j.brandewie@intel.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit bf8102228a8bf053051f311e5486042fe0542894)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/intel_pstate.c
diff --cc drivers/cpufreq/intel_pstate.c
index ffef765dbef0,db2e45b4808e..000000000000
--- a/drivers/cpufreq/intel_pstate.c
+++ b/drivers/cpufreq/intel_pstate.c
@@@ -549,14 -560,17 +549,25 @@@ static void intel_pstate_get_cpu_pstate
  	intel_pstate_set_pstate(cpu, cpu->pstate.min_pstate);
  }
  
 -static inline void intel_pstate_calc_busy(struct cpudata *cpu,
 -					struct sample *sample)
 +static inline void intel_pstate_calc_busy(struct cpudata *cpu)
  {
++<<<<<<< HEAD
 +	struct sample *sample = &cpu->sample;
 +	int32_t core_pct;
 +
 +	core_pct = div_fp(int_tofp(sample->aperf), int_tofp(sample->mperf));
 +	core_pct = mul_fp(core_pct, int_tofp(100));
 +	FP_ROUNDUP(core_pct);
++=======
+ 	int64_t core_pct;
+ 	int32_t rem;
+ 
+ 	core_pct = int_tofp(sample->aperf) * int_tofp(100);
+ 	core_pct = div_u64_rem(core_pct, int_tofp(sample->mperf), &rem);
+ 
+ 	if ((rem << 1) >= int_tofp(sample->mperf))
+ 		core_pct += 1;
++>>>>>>> bf8102228a8b (intel_pstate: Improve initial busy calculation)
  
  	sample->freq = fp_toint(
  		mul_fp(int_tofp(cpu->pstate.max_pstate * 1000), core_pct));
* Unmerged path drivers/cpufreq/intel_pstate.c
