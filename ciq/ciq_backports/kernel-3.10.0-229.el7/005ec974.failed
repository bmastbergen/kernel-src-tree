udp: Only allow busy read/poll on connected sockets

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Shawn Bohrer <sbohrer@rgmadvisors.com>
commit 005ec9743394010cd37d86c3fd2e81978231cdbf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/005ec974.failed

UDP sockets can receive packets from multiple endpoints and thus may be
received on multiple receive queues.  Since packets packets can arrive
on multiple receive queues we should not mark the napi_id for all
packets.  This makes busy read/poll only work for connected UDP sockets.

This additionally enables busy read/poll for UDP multicast packets as
long as the socket is connected by moving the check into
__udp_queue_rcv_skb().

	Signed-off-by: Shawn Bohrer <sbohrer@rgmadvisors.com>
	Suggested-by: Eric Dumazet <edumazet@google.com>
	Acked-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 005ec9743394010cd37d86c3fd2e81978231cdbf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/udp.c
diff --cc net/ipv6/udp.c
index 83b0a9963a30,37532478e3ba..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -541,8 -549,10 +541,14 @@@ static int __udpv6_queue_rcv_skb(struc
  {
  	int rc;
  
++<<<<<<< HEAD
 +	if (!ipv6_addr_any(&sk->sk_v6_daddr))
++=======
+ 	if (!ipv6_addr_any(&inet6_sk(sk)->daddr)) {
++>>>>>>> 005ec9743394 (udp: Only allow busy read/poll on connected sockets)
  		sock_rps_save_rxhash(sk, skb);
+ 		sk_mark_napi_id(sk, skb);
+ 	}
  
  	rc = sock_queue_rcv_skb(sk, skb);
  	if (rc < 0) {
diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c
index 21404cbc18f8..5f54da2ef81b 100644
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@ -1402,8 +1402,10 @@ static int __udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
 	int rc;
 
-	if (inet_sk(sk)->inet_daddr)
+	if (inet_sk(sk)->inet_daddr) {
 		sock_rps_save_rxhash(sk, skb);
+		sk_mark_napi_id(sk, skb);
+	}
 
 	rc = sock_queue_rcv_skb(sk, skb);
 	if (rc < 0) {
@@ -1698,7 +1700,6 @@ int __udp4_lib_rcv(struct sk_buff *skb, struct udp_table *udptable,
 	if (sk != NULL) {
 		int ret;
 
-		sk_mark_napi_id(sk, skb);
 		ret = udp_queue_rcv_skb(sk, skb);
 		sock_put(sk);
 
* Unmerged path net/ipv6/udp.c
