X.509: Need to export x509_request_asymmetric_key()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [crypto] x509: Need to export x509_request_asymmetric_key() (Vivek Goyal) [1129779]
Rebuild_FUZZ: 99.01%
commit-author David Howells <dhowells@redhat.com>
commit cf5b50fd2d70fdd907d433bcebaf8d89a9490334
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/cf5b50fd.failed

Need to export x509_request_asymmetric_key() so that PKCS#7 can use it if
compiled as a module.

	Reported-by: James Morris <jmorris@namei.org>
	Signed-off-by: David Howells <dhowells@redhat.com>
(cherry picked from commit cf5b50fd2d70fdd907d433bcebaf8d89a9490334)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	crypto/asymmetric_keys/x509_public_key.c
diff --cc crypto/asymmetric_keys/x509_public_key.c
index 2fcf47e69b21,f3d62307e6ee..000000000000
--- a/crypto/asymmetric_keys/x509_public_key.c
+++ b/crypto/asymmetric_keys/x509_public_key.c
@@@ -23,6 -24,80 +23,83 @@@
  #include "public_key.h"
  #include "x509_parser.h"
  
++<<<<<<< HEAD
++=======
+ static bool use_builtin_keys;
+ static char *ca_keyid;
+ 
+ #ifndef MODULE
+ static int __init ca_keys_setup(char *str)
+ {
+ 	if (!str)		/* default system keyring */
+ 		return 1;
+ 
+ 	if (strncmp(str, "id:", 3) == 0)
+ 		ca_keyid = str;	/* owner key 'id:xxxxxx' */
+ 	else if (strcmp(str, "builtin") == 0)
+ 		use_builtin_keys = true;
+ 
+ 	return 1;
+ }
+ __setup("ca_keys=", ca_keys_setup);
+ #endif
+ 
+ /**
+  * x509_request_asymmetric_key - Request a key by X.509 certificate params.
+  * @keyring: The keys to search.
+  * @subject: The name of the subject to whom the key belongs.
+  * @key_id: The subject key ID as a hex string.
+  *
+  * Find a key in the given keyring by subject name and key ID.  These might,
+  * for instance, be the issuer name and the authority key ID of an X.509
+  * certificate that needs to be verified.
+  */
+ struct key *x509_request_asymmetric_key(struct key *keyring,
+ 					const char *subject,
+ 					const char *key_id)
+ {
+ 	key_ref_t key;
+ 	size_t subject_len = strlen(subject), key_id_len = strlen(key_id);
+ 	char *id;
+ 
+ 	/* Construct an identifier "<subjname>:<keyid>". */
+ 	id = kmalloc(subject_len + 2 + key_id_len + 1, GFP_KERNEL);
+ 	if (!id)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	memcpy(id, subject, subject_len);
+ 	id[subject_len + 0] = ':';
+ 	id[subject_len + 1] = ' ';
+ 	memcpy(id + subject_len + 2, key_id, key_id_len);
+ 	id[subject_len + 2 + key_id_len] = 0;
+ 
+ 	pr_debug("Look up: \"%s\"\n", id);
+ 
+ 	key = keyring_search(make_key_ref(keyring, 1),
+ 			     &key_type_asymmetric, id);
+ 	if (IS_ERR(key))
+ 		pr_debug("Request for key '%s' err %ld\n", id, PTR_ERR(key));
+ 	kfree(id);
+ 
+ 	if (IS_ERR(key)) {
+ 		switch (PTR_ERR(key)) {
+ 			/* Hide some search errors */
+ 		case -EACCES:
+ 		case -ENOTDIR:
+ 		case -EAGAIN:
+ 			return ERR_PTR(-ENOKEY);
+ 		default:
+ 			return ERR_CAST(key);
+ 		}
+ 	}
+ 
+ 	pr_devel("<==%s() = 0 [%x]\n", __func__,
+ 		 key_serial(key_ref_to_ptr(key)));
+ 	return key_ref_to_ptr(key);
+ }
+ EXPORT_SYMBOL_GPL(x509_request_asymmetric_key);
+ 
++>>>>>>> cf5b50fd2d70 (X.509: Need to export x509_request_asymmetric_key())
  /*
   * Set up the signature parameters in an X.509 certificate.  This involves
   * digesting the signed data and extracting the signature.
* Unmerged path crypto/asymmetric_keys/x509_public_key.c
