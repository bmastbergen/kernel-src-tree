drm/i915: lock around link status and link training.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] i915: lock around link status and link training (Dave Airlie) [1140440]
Rebuild_FUZZ: 94.95%
commit-author Dave Airlie <airlied@redhat.com>
commit 5b215bcff50d549d73e43c09bcccf8eebcc95bac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5b215bcf.failed

We need to take the connection mutex around the link status
check for non-MST case, but also around the MST link training
on short HPDs.

I suspect we actually should have a dpcd lock in the future as
well, that just lock the local copies of dpcd and flags stored
from that.

	Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 5b215bcff50d549d73e43c09bcccf8eebcc95bac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_dp.c
diff --cc drivers/gpu/drm/i915/intel_dp.c
index 1a431377d83b,eb52ecfe14cf..000000000000
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@@ -2682,6 -3540,8 +2683,11 @@@ intel_dp_check_link_status(struct intel
  	u8 sink_irq_vector;
  	u8 link_status[DP_LINK_STATUS_SIZE];
  
++<<<<<<< HEAD
++=======
+ 	WARN_ON(!drm_modeset_is_locked(&dev->mode_config.connection_mutex));
+ 
++>>>>>>> 5b215bcff50d (drm/i915: lock around link status and link training.)
  	if (!intel_encoder->connectors_active)
  		return;
  
@@@ -3090,12 -4016,64 +3096,67 @@@ static const struct drm_encoder_funcs i
  	.destroy = intel_dp_encoder_destroy,
  };
  
 -void
 +static void
  intel_dp_hot_plug(struct intel_encoder *intel_encoder)
  {
 -	return;
 -}
 +	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);
  
++<<<<<<< HEAD
 +	intel_dp_check_link_status(intel_dp);
++=======
+ bool
+ intel_dp_hpd_pulse(struct intel_digital_port *intel_dig_port, bool long_hpd)
+ {
+ 	struct intel_dp *intel_dp = &intel_dig_port->dp;
+ 	struct drm_device *dev = intel_dig_port->base.base.dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	int ret;
+ 	if (intel_dig_port->base.type != INTEL_OUTPUT_EDP)
+ 		intel_dig_port->base.type = INTEL_OUTPUT_DISPLAYPORT;
+ 
+ 	DRM_DEBUG_KMS("got hpd irq on port %d - %s\n", intel_dig_port->port,
+ 		      long_hpd ? "long" : "short");
+ 
+ 	if (long_hpd) {
+ 		if (!ibx_digital_port_connected(dev_priv, intel_dig_port))
+ 			goto mst_fail;
+ 
+ 		if (!intel_dp_get_dpcd(intel_dp)) {
+ 			goto mst_fail;
+ 		}
+ 
+ 		intel_dp_probe_oui(intel_dp);
+ 
+ 		if (!intel_dp_probe_mst(intel_dp))
+ 			goto mst_fail;
+ 
+ 	} else {
+ 		if (intel_dp->is_mst) {
+ 			ret = intel_dp_check_mst_status(intel_dp);
+ 			if (ret == -EINVAL)
+ 				goto mst_fail;
+ 		}
+ 
+ 		if (!intel_dp->is_mst) {
+ 			/*
+ 			 * we'll check the link status via the normal hot plug path later -
+ 			 * but for short hpds we should check it now
+ 			 */
+ 			drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
+ 			intel_dp_check_link_status(intel_dp);
+ 			drm_modeset_unlock(&dev->mode_config.connection_mutex);
+ 		}
+ 	}
+ 	return false;
+ mst_fail:
+ 	/* if we were in MST mode, and device is not there get out of MST mode */
+ 	if (intel_dp->is_mst) {
+ 		DRM_DEBUG_KMS("MST device may have disappeared %d vs %d\n", intel_dp->is_mst, intel_dp->mst_mgr.mst_state);
+ 		intel_dp->is_mst = false;
+ 		drm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr, intel_dp->is_mst);
+ 	}
+ 	return true;
++>>>>>>> 5b215bcff50d (drm/i915: lock around link status and link training.)
  }
  
  /* Return which DP Port should be selected for Transcoder DP control */
* Unmerged path drivers/gpu/drm/i915/intel_dp.c
