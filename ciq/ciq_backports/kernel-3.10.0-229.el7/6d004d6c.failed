vti: Use the tunnel mark for lookup in the error handlers.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] vti: Use the tunnel mark for lookup in the error handlers (Jiri Pirko) [1091561]
Rebuild_FUZZ: 99.13%
commit-author Steffen Klassert <steffen.klassert@secunet.com>
commit 6d004d6cc73920299adf4cfe25010b348fc94395
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/6d004d6c.failed

We need to use the mark we get from the tunnels o_key to
lookup the right vti state in the error handlers. This patch
ensures that.

Fixes: df3893c1 ("vti: Update the ipv4 side to use it's own receive hook.")
Fixes: fa9ad96d ("vti6: Update the ipv6 side to use its own receive hook.")
	Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
(cherry picked from commit 6d004d6cc73920299adf4cfe25010b348fc94395)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/ip_vti.c
#	net/ipv6/ip6_vti.c
diff --cc net/ipv4/ip_vti.c
index 797275dcfe0f,d3f64d7f355e..000000000000
--- a/net/ipv4/ip_vti.c
+++ b/net/ipv4/ip_vti.c
@@@ -166,6 -206,98 +166,101 @@@ tx_error
  	return NETDEV_TX_OK;
  }
  
++<<<<<<< HEAD
++=======
+ /* This function assumes it is being called from dev_queue_xmit()
+  * and that skb is filled properly by that function.
+  */
+ static netdev_tx_t vti_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)
+ {
+ 	struct ip_tunnel *tunnel = netdev_priv(dev);
+ 	struct flowi fl;
+ 
+ 	memset(&fl, 0, sizeof(fl));
+ 
+ 	skb->mark = be32_to_cpu(tunnel->parms.o_key);
+ 
+ 	switch (skb->protocol) {
+ 	case htons(ETH_P_IP):
+ 		xfrm_decode_session(skb, &fl, AF_INET);
+ 		memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
+ 		break;
+ 	case htons(ETH_P_IPV6):
+ 		xfrm_decode_session(skb, &fl, AF_INET6);
+ 		memset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));
+ 		break;
+ 	default:
+ 		dev->stats.tx_errors++;
+ 		dev_kfree_skb(skb);
+ 		return NETDEV_TX_OK;
+ 	}
+ 
+ 	return vti_xmit(skb, dev, &fl);
+ }
+ 
+ static int vti4_err(struct sk_buff *skb, u32 info)
+ {
+ 	__be32 spi;
+ 	__u32 mark;
+ 	struct xfrm_state *x;
+ 	struct ip_tunnel *tunnel;
+ 	struct ip_esp_hdr *esph;
+ 	struct ip_auth_hdr *ah ;
+ 	struct ip_comp_hdr *ipch;
+ 	struct net *net = dev_net(skb->dev);
+ 	const struct iphdr *iph = (const struct iphdr *)skb->data;
+ 	int protocol = iph->protocol;
+ 	struct ip_tunnel_net *itn = net_generic(net, vti_net_id);
+ 
+ 	tunnel = ip_tunnel_lookup(itn, skb->dev->ifindex, TUNNEL_NO_KEY,
+ 				  iph->daddr, iph->saddr, 0);
+ 	if (!tunnel)
+ 		return -1;
+ 
+ 	mark = be32_to_cpu(tunnel->parms.o_key);
+ 
+ 	switch (protocol) {
+ 	case IPPROTO_ESP:
+ 		esph = (struct ip_esp_hdr *)(skb->data+(iph->ihl<<2));
+ 		spi = esph->spi;
+ 		break;
+ 	case IPPROTO_AH:
+ 		ah = (struct ip_auth_hdr *)(skb->data+(iph->ihl<<2));
+ 		spi = ah->spi;
+ 		break;
+ 	case IPPROTO_COMP:
+ 		ipch = (struct ip_comp_hdr *)(skb->data+(iph->ihl<<2));
+ 		spi = htonl(ntohs(ipch->cpi));
+ 		break;
+ 	default:
+ 		return 0;
+ 	}
+ 
+ 	switch (icmp_hdr(skb)->type) {
+ 	case ICMP_DEST_UNREACH:
+ 		if (icmp_hdr(skb)->code != ICMP_FRAG_NEEDED)
+ 			return 0;
+ 	case ICMP_REDIRECT:
+ 		break;
+ 	default:
+ 		return 0;
+ 	}
+ 
+ 	x = xfrm_state_lookup(net, mark, (const xfrm_address_t *)&iph->daddr,
+ 			      spi, protocol, AF_INET);
+ 	if (!x)
+ 		return 0;
+ 
+ 	if (icmp_hdr(skb)->type == ICMP_DEST_UNREACH)
+ 		ipv4_update_pmtu(skb, net, info, 0, 0, protocol, 0);
+ 	else
+ 		ipv4_redirect(skb, net, 0, 0, protocol, 0);
+ 	xfrm_state_put(x);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> 6d004d6cc739 (vti: Use the tunnel mark for lookup in the error handlers.)
  static int
  vti_tunnel_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
  {
* Unmerged path net/ipv6/ip6_vti.c
* Unmerged path net/ipv4/ip_vti.c
* Unmerged path net/ipv6/ip6_vti.c
