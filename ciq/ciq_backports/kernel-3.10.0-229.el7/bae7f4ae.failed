hugetlb: add hstate_is_gigantic()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Luiz Capitulino <lcapitulino@redhat.com>
commit bae7f4ae14d47008a11b4358b167cb0ae186c06a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/bae7f4ae.failed

	Signed-off-by: Luiz Capitulino <lcapitulino@redhat.com>
	Reviewed-by: Andrea Arcangeli <aarcange@redhat.com>
	Reviewed-by: Naoya Horiguchi <n-horiguchi@ah.jp.nec.com>
	Reviewed-by: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>
	Reviewed-by: Davidlohr Bueso <davidlohr@hp.com>
	Acked-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
	Reviewed-by: Zhang Yanfei <zhangyanfei@cn.fujitsu.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Marcelo Tosatti <mtosatti@redhat.com>
	Cc: Rik van Riel <riel@redhat.com>
	Cc: Yinghai Lu <yinghai@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit bae7f4ae14d47008a11b4358b167cb0ae186c06a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/hugetlb.c
diff --cc mm/hugetlb.c
index 6b7b818a5606,a66310586894..000000000000
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@@ -1241,8 -1355,8 +1241,13 @@@ static void __init gather_bootmem_preal
  		 * fix confusing memory reports from free(1) and another
  		 * side-effects, like CommitLimit going negative.
  		 */
++<<<<<<< HEAD
 +		if (h->order > (MAX_ORDER - 1))
 +			totalram_pages += 1 << h->order;
++=======
+ 		if (hstate_is_gigantic(h))
+ 			adjust_managed_page_count(page, 1 << h->order);
++>>>>>>> bae7f4ae14d4 (hugetlb: add hstate_is_gigantic())
  	}
  }
  
@@@ -1573,10 -1688,10 +1578,10 @@@ static ssize_t nr_overcommit_hugepages_
  	unsigned long input;
  	struct hstate *h = kobj_to_hstate(kobj, NULL);
  
- 	if (h->order >= MAX_ORDER)
+ 	if (hstate_is_gigantic(h))
  		return -EINVAL;
  
 -	err = kstrtoul(buf, 10, &input);
 +	err = strict_strtoul(buf, 10, &input);
  	if (err)
  		return err;
  
@@@ -1982,9 -2107,12 +1987,9 @@@ static int hugetlb_sysctl_handler_commo
  	unsigned long tmp;
  	int ret;
  
 -	if (!hugepages_supported())
 -		return -ENOTSUPP;
 -
  	tmp = h->max_huge_pages;
  
- 	if (write && h->order >= MAX_ORDER)
+ 	if (write && hstate_is_gigantic(h))
  		return -EINVAL;
  
  	table->data = &tmp;
@@@ -2047,9 -2163,12 +2052,9 @@@ int hugetlb_overcommit_handler(struct c
  	unsigned long tmp;
  	int ret;
  
 -	if (!hugepages_supported())
 -		return -ENOTSUPP;
 -
  	tmp = h->nr_overcommit_huge_pages;
  
- 	if (write && h->order >= MAX_ORDER)
+ 	if (write && hstate_is_gigantic(h))
  		return -EINVAL;
  
  	table->data = &tmp;
diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h
index 3386cad757e9..0025449d8af1 100644
--- a/include/linux/hugetlb.h
+++ b/include/linux/hugetlb.h
@@ -318,6 +318,11 @@ static inline unsigned huge_page_shift(struct hstate *h)
 	return h->order + PAGE_SHIFT;
 }
 
+static inline bool hstate_is_gigantic(struct hstate *h)
+{
+	return huge_page_order(h) >= MAX_ORDER;
+}
+
 static inline unsigned int pages_per_huge_page(struct hstate *h)
 {
 	return 1 << h->order;
* Unmerged path mm/hugetlb.c
