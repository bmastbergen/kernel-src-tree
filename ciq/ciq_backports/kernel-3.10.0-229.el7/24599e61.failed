net: sctp: check proc_dointvec result in proc_sctp_do_auth

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] sctp: check proc_dointvec result in proc_sctp_do_auth (Daniel Borkmann) [1110290]
Rebuild_FUZZ: 95.50%
commit-author Daniel Borkmann <dborkman@redhat.com>
commit 24599e61b7552673dd85971cf5a35369cd8c119e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/24599e61.failed

When writing to the sysctl field net.sctp.auth_enable, it can well
be that the user buffer we handed over to proc_dointvec() via
proc_sctp_do_auth() handler contains something other than integers.

In that case, we would set an uninitialized 4-byte value from the
stack to net->sctp.auth_enable that can be leaked back when reading
the sysctl variable, and it can unintentionally turn auth_enable
on/off based on the stack content since auth_enable is interpreted
as a boolean.

Fix it up by making sure proc_dointvec() returned sucessfully.

Fixes: b14878ccb7fa ("net: sctp: cache auth_enable per endpoint")
	Reported-by: Florian Westphal <fwestpha@redhat.com>
	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Acked-by: Neil Horman <nhorman@tuxdriver.com>
	Acked-by: Vlad Yasevich <vyasevich@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 24599e61b7552673dd85971cf5a35369cd8c119e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/sysctl.c
diff --cc net/sctp/sysctl.c
index 5a83d52bc795,12c7e01c2677..000000000000
--- a/net/sctp/sysctl.c
+++ b/net/sctp/sysctl.c
@@@ -410,6 -420,46 +410,49 @@@ static int proc_sctp_do_rto_max(struct 
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int proc_sctp_do_alpha_beta(struct ctl_table *ctl, int write,
+ 				   void __user *buffer, size_t *lenp,
+ 				   loff_t *ppos)
+ {
+ 	pr_warn_once("Changing rto_alpha or rto_beta may lead to "
+ 		     "suboptimal rtt/srtt estimations!\n");
+ 
+ 	return proc_dointvec_minmax(ctl, write, buffer, lenp, ppos);
+ }
+ 
+ static int proc_sctp_do_auth(struct ctl_table *ctl, int write,
+ 			     void __user *buffer, size_t *lenp,
+ 			     loff_t *ppos)
+ {
+ 	struct net *net = current->nsproxy->net_ns;
+ 	struct ctl_table tbl;
+ 	int new_value, ret;
+ 
+ 	memset(&tbl, 0, sizeof(struct ctl_table));
+ 	tbl.maxlen = sizeof(unsigned int);
+ 
+ 	if (write)
+ 		tbl.data = &new_value;
+ 	else
+ 		tbl.data = &net->sctp.auth_enable;
+ 
+ 	ret = proc_dointvec(&tbl, write, buffer, lenp, ppos);
+ 	if (write && ret == 0) {
+ 		struct sock *sk = net->sctp.ctl_sock;
+ 
+ 		net->sctp.auth_enable = new_value;
+ 		/* Update the value in the control socket */
+ 		lock_sock(sk);
+ 		sctp_sk(sk)->ep->auth_enable = new_value;
+ 		release_sock(sk);
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> 24599e61b755 (net: sctp: check proc_dointvec result in proc_sctp_do_auth)
  int sctp_sysctl_net_register(struct net *net)
  {
  	struct ctl_table *table;
* Unmerged path net/sctp/sysctl.c
