vxlan: Do not reuse sockets for a different address family

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Marcelo Leitner <mleitner@redhat.com>
commit 19ca9fc1445b76b60d34148f7ff837b055f5dcf3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/19ca9fc1.failed

Currently, we only match against local port number in order to reuse
socket. But if this new vxlan wants an IPv6 socket and a IPv4 one bound
to that port, vxlan will reuse an IPv4 socket as IPv6 and a panic will
follow. The following steps reproduce it:

   # ip link add vxlan6 type vxlan id 42 group 229.10.10.10 \
       srcport 5000 6000 dev eth0
   # ip link add vxlan7 type vxlan id 43 group ff0e::110 \
       srcport 5000 6000 dev eth0
   # ip link set vxlan6 up
   # ip link set vxlan7 up
   <panic>

[    4.187481] BUG: unable to handle kernel NULL pointer dereference at 0000000000000058
...
[    4.188076] Call Trace:
[    4.188085]  [<ffffffff81667c4a>] ? ipv6_sock_mc_join+0x3a/0x630
[    4.188098]  [<ffffffffa05a6ad6>] vxlan_igmp_join+0x66/0xd0 [vxlan]
[    4.188113]  [<ffffffff810a3430>] process_one_work+0x220/0x710
[    4.188125]  [<ffffffff810a33c4>] ? process_one_work+0x1b4/0x710
[    4.188138]  [<ffffffff810a3a3b>] worker_thread+0x11b/0x3a0
[    4.188149]  [<ffffffff810a3920>] ? process_one_work+0x710/0x710

So address family must also match in order to reuse a socket.

	Reported-by: Jean-Tsung Hsiao <jhsiao@redhat.com>
	Signed-off-by: Marcelo Ricardo Leitner <mleitner@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 19ca9fc1445b76b60d34148f7ff837b055f5dcf3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
diff --cc drivers/net/vxlan.c
index d158096bf15a,fa9dc45b75a6..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1820,7 -1776,8 +1823,12 @@@ static void vxlan_xmit_one(struct sk_bu
  			struct vxlan_dev *dst_vxlan;
  
  			ip_rt_put(rt);
++<<<<<<< HEAD
 +			dst_vxlan = vxlan_find_vni(dev_net(dev), vni, dst_port);
++=======
+ 			dst_vxlan = vxlan_find_vni(vxlan->net, vni,
+ 						   dst->sa.sa_family, dst_port);
++>>>>>>> 19ca9fc1445b (vxlan: Do not reuse sockets for a different address family)
  			if (!dst_vxlan)
  				goto tx_error;
  			vxlan_encap_bypass(skb, vxlan, dst_vxlan);
@@@ -1873,7 -1831,8 +1881,12 @@@
  			struct vxlan_dev *dst_vxlan;
  
  			dst_release(ndst);
++<<<<<<< HEAD
 +			dst_vxlan = vxlan_find_vni(dev_net(dev), vni, dst_port);
++=======
+ 			dst_vxlan = vxlan_find_vni(vxlan->net, vni,
+ 						   dst->sa.sa_family, dst_port);
++>>>>>>> 19ca9fc1445b (vxlan: Do not reuse sockets for a different address family)
  			if (!dst_vxlan)
  				goto tx_error;
  			vxlan_encap_bypass(skb, vxlan, dst_vxlan);
@@@ -2028,15 -1990,17 +2041,21 @@@ static void vxlan_vs_add_dev(struct vxl
  static int vxlan_init(struct net_device *dev)
  {
  	struct vxlan_dev *vxlan = netdev_priv(dev);
 -	struct vxlan_net *vn = net_generic(vxlan->net, vxlan_net_id);
 +	struct vxlan_net *vn = net_generic(dev_net(dev), vxlan_net_id);
  	struct vxlan_sock *vs;
+ 	bool ipv6 = vxlan->flags & VXLAN_F_IPV6;
  
 -	dev->tstats = netdev_alloc_pcpu_stats(struct pcpu_sw_netstats);
 +	dev->tstats = alloc_percpu(struct pcpu_tstats);
  	if (!dev->tstats)
  		return -ENOMEM;
  
  	spin_lock(&vn->sock_lock);
++<<<<<<< HEAD
 +	vs = vxlan_find_sock(dev_net(dev), vxlan->dst_port);
++=======
+ 	vs = vxlan_find_sock(vxlan->net, ipv6 ? AF_INET6 : AF_INET,
+ 			     vxlan->dst_port);
++>>>>>>> 19ca9fc1445b (vxlan: Do not reuse sockets for a different address family)
  	if (vs) {
  		/* If we have a socket with same port already, reuse it */
  		atomic_inc(&vs->refcnt);
* Unmerged path drivers/net/vxlan.c
