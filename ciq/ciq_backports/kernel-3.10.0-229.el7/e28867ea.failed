cpufreq: Implement cpufreq_generic_suspend()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Implement cpufreq_generic_suspend() (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 88.61%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit e28867eab7c0a60cddf0cb59f9f6cbbd9561425d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e28867ea.failed

Multiple platforms need to set CPUs to a particular frequency before
suspending the system, so provide a common infrastructure for them.

Those platforms only need to point their ->suspend callback pointers
to the generic routine.

	Tested-by: Stephen Warren <swarren@nvidia.com>
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
[rjw: Changelog]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit e28867eab7c0a60cddf0cb59f9f6cbbd9561425d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/cpufreq.h
diff --cc include/linux/cpufreq.h
index 4d87da0ff71a,325bab04271b..000000000000
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@@ -270,87 -273,74 +272,122 @@@ struct cpufreq_driver 
  int cpufreq_register_driver(struct cpufreq_driver *driver_data);
  int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
  
 +void cpufreq_notify_transition(struct cpufreq_policy *policy,
 +		struct cpufreq_freqs *freqs, unsigned int state);
 +
 +static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
 +		unsigned int min, unsigned int max)
 +{
 +	if (policy->min < min)
 +		policy->min = min;
 +	if (policy->max < min)
 +		policy->max = min;
 +	if (policy->min > max)
 +		policy->min = max;
 +	if (policy->max > max)
 +		policy->max = max;
 +	if (policy->min > policy->max)
 +		policy->min = policy->max;
 +	return;
 +}
 +
 +static inline void
 +cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
 +{
 +	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
 +			policy->cpuinfo.max_freq);
 +}
 +
 +
 +struct freq_attr {
 +	struct attribute attr;
 +	ssize_t (*show)(struct cpufreq_policy *, char *);
 +	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t count);
 +};
 +
 +#define cpufreq_freq_attr_ro(_name)		\
 +static struct freq_attr _name =			\
 +__ATTR(_name, 0444, show_##_name, NULL)
 +
 +#define cpufreq_freq_attr_ro_perm(_name, _perm)	\
 +static struct freq_attr _name =			\
 +__ATTR(_name, _perm, show_##_name, NULL)
 +
 +#define cpufreq_freq_attr_rw(_name)		\
 +static struct freq_attr _name =			\
 +__ATTR(_name, 0644, show_##_name, store_##_name)
 +
 +struct global_attr {
 +	struct attribute attr;
 +	ssize_t (*show)(struct kobject *kobj,
 +			struct attribute *attr, char *buf);
 +	ssize_t (*store)(struct kobject *a, struct attribute *b,
 +			 const char *c, size_t count);
 +};
 +
 +#define define_one_global_ro(_name)		\
 +static struct global_attr _name =		\
 +__ATTR(_name, 0444, show_##_name, NULL)
 +
 +#define define_one_global_rw(_name)		\
 +static struct global_attr _name =		\
 +__ATTR(_name, 0644, show_##_name, store_##_name)
 +
 +struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
 +void cpufreq_cpu_put(struct cpufreq_policy *data);
  const char *cpufreq_get_current_driver(void);
  
++<<<<<<< HEAD
++=======
+ static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
+ 		unsigned int min, unsigned int max)
+ {
+ 	if (policy->min < min)
+ 		policy->min = min;
+ 	if (policy->max < min)
+ 		policy->max = min;
+ 	if (policy->min > max)
+ 		policy->min = max;
+ 	if (policy->max > max)
+ 		policy->max = max;
+ 	if (policy->min > policy->max)
+ 		policy->min = policy->max;
+ 	return;
+ }
+ 
+ static inline void
+ cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
+ {
+ 	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
+ 			policy->cpuinfo.max_freq);
+ }
+ 
+ #ifdef CONFIG_CPU_FREQ
+ void cpufreq_suspend(void);
+ void cpufreq_resume(void);
+ int cpufreq_generic_suspend(struct cpufreq_policy *policy);
+ #else
+ static inline void cpufreq_suspend(void) {}
+ static inline void cpufreq_resume(void) {}
+ #endif
+ 
++>>>>>>> e28867eab7c0 (cpufreq: Implement cpufreq_generic_suspend())
  /*********************************************************************
 - *                     CPUFREQ NOTIFIER INTERFACE                    *
 + *                        CPUFREQ 2.6. INTERFACE                     *
   *********************************************************************/
 -
 -#define CPUFREQ_TRANSITION_NOTIFIER	(0)
 -#define CPUFREQ_POLICY_NOTIFIER		(1)
 -
 -/* Transition notifiers */
 -#define CPUFREQ_PRECHANGE		(0)
 -#define CPUFREQ_POSTCHANGE		(1)
 -#define CPUFREQ_RESUMECHANGE		(8)
 -#define CPUFREQ_SUSPENDCHANGE		(9)
 -
 -/* Policy Notifiers  */
 -#define CPUFREQ_ADJUST			(0)
 -#define CPUFREQ_INCOMPATIBLE		(1)
 -#define CPUFREQ_NOTIFY			(2)
 -#define CPUFREQ_START			(3)
 -#define CPUFREQ_UPDATE_POLICY_CPU	(4)
 -#define CPUFREQ_CREATE_POLICY		(5)
 -#define CPUFREQ_REMOVE_POLICY		(6)
 +u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
 +int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 +int cpufreq_update_policy(unsigned int cpu);
 +bool have_governor_per_policy(void);
 +struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
  
  #ifdef CONFIG_CPU_FREQ
 -int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
 -int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
 -
 -void cpufreq_notify_transition(struct cpufreq_policy *policy,
 -		struct cpufreq_freqs *freqs, unsigned int state);
 -void cpufreq_notify_post_transition(struct cpufreq_policy *policy,
 -		struct cpufreq_freqs *freqs, int transition_failed);
 -
 -#else /* CONFIG_CPU_FREQ */
 -static inline int cpufreq_register_notifier(struct notifier_block *nb,
 -						unsigned int list)
 +/*
 + * query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it
 + */
 +unsigned int cpufreq_get(unsigned int cpu);
 +#else
 +static inline unsigned int cpufreq_get(unsigned int cpu)
  {
  	return 0;
  }
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index c8bc717e8458..e031d5c662bc 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -1409,6 +1409,32 @@ static struct subsys_interface cpufreq_interface = {
 	.remove_dev	= cpufreq_remove_dev,
 };
 
+/*
+ * In case platform wants some specific frequency to be configured
+ * during suspend..
+ */
+int cpufreq_generic_suspend(struct cpufreq_policy *policy)
+{
+	int ret;
+
+	if (!policy->suspend_freq) {
+		pr_err("%s: suspend_freq can't be zero\n", __func__);
+		return -EINVAL;
+	}
+
+	pr_debug("%s: Setting suspend-freq: %u\n", __func__,
+			policy->suspend_freq);
+
+	ret = __cpufreq_driver_target(policy, policy->suspend_freq,
+			CPUFREQ_RELATION_H);
+	if (ret)
+		pr_err("%s: unable to set suspend-freq: %u. err: %d\n",
+				__func__, policy->suspend_freq, ret);
+
+	return ret;
+}
+EXPORT_SYMBOL(cpufreq_generic_suspend);
+
 /**
  * cpufreq_bp_suspend - Prepare the boot CPU for system suspend.
  *
* Unmerged path include/linux/cpufreq.h
