ALSA: hda - Make position_fix as generic callback

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [alsa] hda: Make position_fix as generic callback (Jaroslav Kysela) [1112200]
Rebuild_FUZZ: 90.11%
commit-author Takashi Iwai <tiwai@suse.de>
commit b6050ef664219a0bc97d0626759ef070ed77fcba
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/b6050ef6.failed

... and move most parts into hda_intel.c from the generic controller
code.  This is a clean up, and there should be no functional change by
this patch.

Now, struct azx obtains the generic callbacks for getting the position
and the delay.  As default NULL, posbuf is read.  These replace the
old position_fix[], and each is implemented as a callback.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit b6050ef664219a0bc97d0626759ef070ed77fcba)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_controller.c
#	sound/pci/hda/hda_controller.h
#	sound/pci/hda/hda_intel.c
#	sound/pci/hda/hda_priv.h
#	sound/pci/hda/hda_tegra.c
diff --cc sound/pci/hda/hda_intel.c
index c74374a10f3c,cb5d807bbd0c..000000000000
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@@ -63,8 -63,18 +63,17 @@@
  #include <linux/firmware.h>
  #include "hda_codec.h"
  #include "hda_i915.h"
 -#include "hda_controller.h"
  #include "hda_priv.h"
  
+ /* position fix mode */
+ enum {
+ 	POS_FIX_AUTO,
+ 	POS_FIX_LPIB,
+ 	POS_FIX_POSBUF,
+ 	POS_FIX_VIACOMBO,
+ 	POS_FIX_COMBO,
+ };
+ 
  
  static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
  static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
@@@ -1029,1103 -443,55 +1038,1137 @@@ static void azx_init_pci(struct azx *ch
          }
  }
  
 -/* calculate runtime delay from LPIB */
 -static int azx_get_delay_from_lpib(struct azx *chip, struct azx_dev *azx_dev,
 -				   unsigned int pos)
++<<<<<<< HEAD
++=======
++/* calculate runtime delay from LPIB */
++static int azx_get_delay_from_lpib(struct azx *chip, struct azx_dev *azx_dev,
++				   unsigned int pos)
++{
++	struct snd_pcm_substream *substream = azx_dev->substream;
++	int stream = substream->stream;
++	unsigned int lpib_pos = azx_get_pos_lpib(chip, azx_dev);
++	int delay;
++
++	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
++		delay = pos - lpib_pos;
++	else
++		delay = lpib_pos - pos;
++	if (delay < 0) {
++		if (delay >= azx_dev->delay_negative_threshold)
++			delay = 0;
++		else
++			delay += azx_dev->bufsize;
++	}
++
++	if (delay >= azx_dev->period_bytes) {
++		dev_info(chip->card->dev,
++			 "Unstable LPIB (%d >= %d); disabling LPIB delay counting\n",
++			 delay, azx_dev->period_bytes);
++		delay = 0;
++		chip->driver_caps &= ~AZX_DCAPS_COUNT_LPIB_DELAY;
++		chip->get_delay[stream] = NULL;
++	}
++
++	return bytes_to_frames(substream->runtime, delay);
++}
++>>>>>>> b6050ef66421 (ALSA: hda - Make position_fix as generic callback)
 +
 +static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev);
 +
 +/*
 + * interrupt handler
 + */
 +static irqreturn_t azx_interrupt(int irq, void *dev_id)
 +{
 +	struct azx *chip = dev_id;
 +	struct azx_dev *azx_dev;
 +	u32 status;
 +	u8 sd_status;
 +	int i, ok;
 +
 +#ifdef CONFIG_PM_RUNTIME
 +	if (chip->driver_caps & AZX_DCAPS_PM_RUNTIME)
 +		if (chip->card->dev->power.runtime_status != RPM_ACTIVE)
 +			return IRQ_NONE;
 +#endif
 +
 +	spin_lock(&chip->reg_lock);
 +
 +	if (chip->disabled) {
 +		spin_unlock(&chip->reg_lock);
 +		return IRQ_NONE;
 +	}
 +
 +	status = azx_readl(chip, INTSTS);
 +	if (status == 0 || status == 0xffffffff) {
 +		spin_unlock(&chip->reg_lock);
 +		return IRQ_NONE;
 +	}
 +	
 +	for (i = 0; i < chip->num_streams; i++) {
 +		azx_dev = &chip->azx_dev[i];
 +		if (status & azx_dev->sd_int_sta_mask) {
 +			sd_status = azx_sd_readb(chip, azx_dev, SD_STS);
 +			azx_sd_writeb(chip, azx_dev, SD_STS, SD_INT_MASK);
 +			if (!azx_dev->substream || !azx_dev->running ||
 +			    !(sd_status & SD_INT_COMPLETE))
 +				continue;
 +			/* check whether this IRQ is really acceptable */
 +			ok = azx_position_ok(chip, azx_dev);
 +			if (ok == 1) {
 +				azx_dev->irq_pending = 0;
 +				spin_unlock(&chip->reg_lock);
 +				snd_pcm_period_elapsed(azx_dev->substream);
 +				spin_lock(&chip->reg_lock);
 +			} else if (ok == 0 && chip->bus && chip->bus->workq) {
 +				/* bogus IRQ, process it later */
 +				azx_dev->irq_pending = 1;
 +				queue_work(chip->bus->workq,
 +					   &chip->irq_pending_work);
 +			}
 +		}
 +	}
 +
 +	/* clear rirb int */
 +	status = azx_readb(chip, RIRBSTS);
 +	if (status & RIRB_INT_MASK) {
 +		if (status & RIRB_INT_RESPONSE) {
 +			if (chip->driver_caps & AZX_DCAPS_RIRB_PRE_DELAY)
 +				udelay(80);
 +			azx_update_rirb(chip);
 +		}
 +		azx_writeb(chip, RIRBSTS, RIRB_INT_MASK);
 +	}
 +
 +	spin_unlock(&chip->reg_lock);
 +	
 +	return IRQ_HANDLED;
 +}
 +
 +
 +/*
 + * set up a BDL entry
 + */
 +static int setup_bdle(struct azx *chip,
 +		      struct snd_dma_buffer *dmab,
 +		      struct azx_dev *azx_dev, u32 **bdlp,
 +		      int ofs, int size, int with_ioc)
 +{
 +	u32 *bdl = *bdlp;
 +
 +	while (size > 0) {
 +		dma_addr_t addr;
 +		int chunk;
 +
 +		if (azx_dev->frags >= AZX_MAX_BDL_ENTRIES)
 +			return -EINVAL;
 +
 +		addr = snd_sgbuf_get_addr(dmab, ofs);
 +		/* program the address field of the BDL entry */
 +		bdl[0] = cpu_to_le32((u32)addr);
 +		bdl[1] = cpu_to_le32(upper_32_bits(addr));
 +		/* program the size field of the BDL entry */
 +		chunk = snd_sgbuf_get_chunk_size(dmab, ofs, size);
 +		/* one BDLE cannot cross 4K boundary on CTHDA chips */
 +		if (chip->driver_caps & AZX_DCAPS_4K_BDLE_BOUNDARY) {
 +			u32 remain = 0x1000 - (ofs & 0xfff);
 +			if (chunk > remain)
 +				chunk = remain;
 +		}
 +		bdl[2] = cpu_to_le32(chunk);
 +		/* program the IOC to enable interrupt
 +		 * only when the whole fragment is processed
 +		 */
 +		size -= chunk;
 +		bdl[3] = (size || !with_ioc) ? 0 : cpu_to_le32(0x01);
 +		bdl += 4;
 +		azx_dev->frags++;
 +		ofs += chunk;
 +	}
 +	*bdlp = bdl;
 +	return ofs;
 +}
 +
 +/*
 + * set up BDL entries
 + */
 +static int azx_setup_periods(struct azx *chip,
 +			     struct snd_pcm_substream *substream,
 +			     struct azx_dev *azx_dev)
 +{
 +	u32 *bdl;
 +	int i, ofs, periods, period_bytes;
 +	int pos_adj;
 +
 +	/* reset BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +
 +	period_bytes = azx_dev->period_bytes;
 +	periods = azx_dev->bufsize / period_bytes;
 +
 +	/* program the initial BDL entries */
 +	bdl = (u32 *)azx_dev->bdl.area;
 +	ofs = 0;
 +	azx_dev->frags = 0;
 +	pos_adj = bdl_pos_adj[chip->dev_index];
 +	if (!azx_dev->no_period_wakeup && pos_adj > 0) {
 +		struct snd_pcm_runtime *runtime = substream->runtime;
 +		int pos_align = pos_adj;
 +		pos_adj = (pos_adj * runtime->rate + 47999) / 48000;
 +		if (!pos_adj)
 +			pos_adj = pos_align;
 +		else
 +			pos_adj = ((pos_adj + pos_align - 1) / pos_align) *
 +				pos_align;
 +		pos_adj = frames_to_bytes(runtime, pos_adj);
 +		if (pos_adj >= period_bytes) {
 +			snd_printk(KERN_WARNING SFX "%s: Too big adjustment %d\n",
 +				   pci_name(chip->pci), bdl_pos_adj[chip->dev_index]);
 +			pos_adj = 0;
 +		} else {
 +			ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
 +					 azx_dev,
 +					 &bdl, ofs, pos_adj, true);
 +			if (ofs < 0)
 +				goto error;
 +		}
 +	} else
 +		pos_adj = 0;
 +	for (i = 0; i < periods; i++) {
 +		if (i == periods - 1 && pos_adj)
 +			ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
 +					 azx_dev, &bdl, ofs,
 +					 period_bytes - pos_adj, 0);
 +		else
 +			ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
 +					 azx_dev, &bdl, ofs,
 +					 period_bytes,
 +					 !azx_dev->no_period_wakeup);
 +		if (ofs < 0)
 +			goto error;
 +	}
 +	return 0;
 +
 + error:
 +	snd_printk(KERN_ERR SFX "%s: Too many BDL entries: buffer=%d, period=%d\n",
 +		   pci_name(chip->pci), azx_dev->bufsize, period_bytes);
 +	return -EINVAL;
 +}
 +
 +/* reset stream */
 +static void azx_stream_reset(struct azx *chip, struct azx_dev *azx_dev)
 +{
 +	unsigned char val;
 +	int timeout;
 +
 +	azx_stream_clear(chip, azx_dev);
 +
 +	azx_sd_writeb(chip, azx_dev, SD_CTL,
 +		      azx_sd_readb(chip, azx_dev, SD_CTL) |
 +		      SD_CTL_STREAM_RESET);
 +	udelay(3);
 +	timeout = 300;
 +	while (!((val = azx_sd_readb(chip, azx_dev, SD_CTL)) &
 +		 SD_CTL_STREAM_RESET) && --timeout)
 +		;
 +	val &= ~SD_CTL_STREAM_RESET;
 +	azx_sd_writeb(chip, azx_dev, SD_CTL, val);
 +	udelay(3);
 +
 +	timeout = 300;
 +	/* waiting for hardware to report that the stream is out of reset */
 +	while (((val = azx_sd_readb(chip, azx_dev, SD_CTL)) &
 +		SD_CTL_STREAM_RESET) && --timeout)
 +		;
 +
 +	/* reset first position - may not be synced with hw at this time */
 +	*azx_dev->posbuf = 0;
 +}
 +
 +/*
 + * set up the SD for streaming
 + */
 +static int azx_setup_controller(struct azx *chip, struct azx_dev *azx_dev)
 +{
 +	unsigned int val;
 +	/* make sure the run bit is zero for SD */
 +	azx_stream_clear(chip, azx_dev);
 +	/* program the stream_tag */
 +	val = azx_sd_readl(chip, azx_dev, SD_CTL);
 +	val = (val & ~SD_CTL_STREAM_TAG_MASK) |
 +		(azx_dev->stream_tag << SD_CTL_STREAM_TAG_SHIFT);
 +	if (!azx_snoop(chip))
 +		val |= SD_CTL_TRAFFIC_PRIO;
 +	azx_sd_writel(chip, azx_dev, SD_CTL, val);
 +
 +	/* program the length of samples in cyclic buffer */
 +	azx_sd_writel(chip, azx_dev, SD_CBL, azx_dev->bufsize);
 +
 +	/* program the stream format */
 +	/* this value needs to be the same as the one programmed */
 +	azx_sd_writew(chip, azx_dev, SD_FORMAT, azx_dev->format_val);
 +
 +	/* program the stream LVI (last valid index) of the BDL */
 +	azx_sd_writew(chip, azx_dev, SD_LVI, azx_dev->frags - 1);
 +
 +	/* program the BDL address */
 +	/* lower BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, (u32)azx_dev->bdl.addr);
 +	/* upper BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU,
 +		      upper_32_bits(azx_dev->bdl.addr));
 +
 +	/* enable the position buffer */
 +	if (chip->position_fix[0] != POS_FIX_LPIB ||
 +	    chip->position_fix[1] != POS_FIX_LPIB) {
 +		if (!(azx_readl(chip, DPLBASE) & ICH6_DPLBASE_ENABLE))
 +			azx_writel(chip, DPLBASE,
 +				(u32)chip->posbuf.addr | ICH6_DPLBASE_ENABLE);
 +	}
 +
 +	/* set the interrupt enable bits in the descriptor control register */
 +	azx_sd_writel(chip, azx_dev, SD_CTL,
 +		      azx_sd_readl(chip, azx_dev, SD_CTL) | SD_INT_MASK);
 +
 +	return 0;
 +}
 +
 +/*
 + * Probe the given codec address
 + */
 +static int probe_codec(struct azx *chip, int addr)
 +{
 +	unsigned int cmd = (addr << 28) | (AC_NODE_ROOT << 20) |
 +		(AC_VERB_PARAMETERS << 8) | AC_PAR_VENDOR_ID;
 +	unsigned int res;
 +
 +	mutex_lock(&chip->bus->cmd_mutex);
 +	chip->probing = 1;
 +	azx_send_cmd(chip->bus, cmd);
 +	res = azx_get_response(chip->bus, addr);
 +	chip->probing = 0;
 +	mutex_unlock(&chip->bus->cmd_mutex);
 +	if (res == -1)
 +		return -EIO;
 +	snd_printdd(SFX "%s: codec #%d probed OK\n", pci_name(chip->pci), addr);
 +	return 0;
 +}
 +
 +static int azx_attach_pcm_stream(struct hda_bus *bus, struct hda_codec *codec,
 +				 struct hda_pcm *cpcm);
 +static void azx_stop_chip(struct azx *chip);
 +
 +static void azx_bus_reset(struct hda_bus *bus)
 +{
 +	struct azx *chip = bus->private_data;
 +
 +	bus->in_reset = 1;
 +	azx_stop_chip(chip);
 +	azx_init_chip(chip, 1);
 +#ifdef CONFIG_PM
 +	if (chip->initialized) {
 +		struct azx_pcm *p;
 +		list_for_each_entry(p, &chip->pcm_list, list)
 +			snd_pcm_suspend_all(p->pcm);
 +		snd_hda_suspend(chip->bus);
 +		snd_hda_resume(chip->bus);
 +	}
 +#endif
 +	bus->in_reset = 0;
 +}
 +
 +static int get_jackpoll_interval(struct azx *chip)
 +{
 +	int i;
 +	unsigned int j;
 +
 +	if (!chip->jackpoll_ms)
 +		return 0;
 +
 +	i = chip->jackpoll_ms[chip->dev_index];
 +	if (i == 0)
 +		return 0;
 +	if (i < 50 || i > 60000)
 +		j = 0;
 +	else
 +		j = msecs_to_jiffies(i);
 +	if (j == 0)
 +		snd_printk(KERN_WARNING SFX
 +			   "jackpoll_ms value out of range: %d\n", i);
 +	return j;
 +}
 +
 +/*
 + * Codec initialization
 + */
 +
 +static int azx_codec_create(struct azx *chip, const char *model,
 +			    unsigned int max_slots,
 +			    int *power_save_to)
 +{
 +	struct hda_bus_template bus_temp;
 +	int c, codecs, err;
 +
 +	memset(&bus_temp, 0, sizeof(bus_temp));
 +	bus_temp.private_data = chip;
 +	bus_temp.modelname = model;
 +	bus_temp.pci = chip->pci;
 +	bus_temp.ops.command = azx_send_cmd;
 +	bus_temp.ops.get_response = azx_get_response;
 +	bus_temp.ops.attach_pcm = azx_attach_pcm_stream;
 +	bus_temp.ops.bus_reset = azx_bus_reset;
 +#ifdef CONFIG_PM
 +	bus_temp.power_save = power_save_to;
 +	bus_temp.ops.pm_notify = azx_power_notify;
 +#endif
 +#ifdef CONFIG_SND_HDA_DSP_LOADER
 +	bus_temp.ops.load_dsp_prepare = azx_load_dsp_prepare;
 +	bus_temp.ops.load_dsp_trigger = azx_load_dsp_trigger;
 +	bus_temp.ops.load_dsp_cleanup = azx_load_dsp_cleanup;
 +#endif
 +
 +	err = snd_hda_bus_new(chip->card, &bus_temp, &chip->bus);
 +	if (err < 0)
 +		return err;
 +
 +	if (chip->driver_caps & AZX_DCAPS_RIRB_DELAY) {
 +		snd_printd(SFX "%s: Enable delay in RIRB handling\n", pci_name(chip->pci));
 +		chip->bus->needs_damn_long_delay = 1;
 +	}
 +
 +	codecs = 0;
 +	if (!max_slots)
 +		max_slots = AZX_DEFAULT_CODECS;
 +
 +	/* First try to probe all given codec slots */
 +	for (c = 0; c < max_slots; c++) {
 +		if ((chip->codec_mask & (1 << c)) & chip->codec_probe_mask) {
 +			if (probe_codec(chip, c) < 0) {
 +				/* Some BIOSen give you wrong codec addresses
 +				 * that don't exist
 +				 */
 +				snd_printk(KERN_WARNING SFX
 +					   "%s: Codec #%d probe error; "
 +					   "disabling it...\n", pci_name(chip->pci), c);
 +				chip->codec_mask &= ~(1 << c);
 +				/* More badly, accessing to a non-existing
 +				 * codec often screws up the controller chip,
 +				 * and disturbs the further communications.
 +				 * Thus if an error occurs during probing,
 +				 * better to reset the controller chip to
 +				 * get back to the sanity state.
 +				 */
 +				azx_stop_chip(chip);
 +				azx_init_chip(chip, 1);
 +			}
 +		}
 +	}
 +
 +	/* AMD chipsets often cause the communication stalls upon certain
 +	 * sequence like the pin-detection.  It seems that forcing the synced
 +	 * access works around the stall.  Grrr...
 +	 */
 +	if (chip->driver_caps & AZX_DCAPS_SYNC_WRITE) {
 +		snd_printd(SFX "%s: Enable sync_write for stable communication\n",
 +			pci_name(chip->pci));
 +		chip->bus->sync_write = 1;
 +		chip->bus->allow_bus_reset = 1;
 +	}
 +
 +	/* Then create codec instances */
 +	for (c = 0; c < max_slots; c++) {
 +		if ((chip->codec_mask & (1 << c)) & chip->codec_probe_mask) {
 +			struct hda_codec *codec;
 +			err = snd_hda_codec_new(chip->bus, c, &codec);
 +			if (err < 0)
 +				continue;
 +			codec->jackpoll_interval = get_jackpoll_interval(chip);
 +			codec->beep_mode = chip->beep_mode;
 +			codecs++;
 +		}
 +	}
 +	if (!codecs) {
 +		snd_printk(KERN_ERR SFX "%s: no codecs initialized\n", pci_name(chip->pci));
 +		return -ENXIO;
 +	}
 +	return 0;
 +}
 +
 +/* configure each codec instance */
 +static int azx_codec_configure(struct azx *chip)
 +{
 +	struct hda_codec *codec;
 +	list_for_each_entry(codec, &chip->bus->codec_list, list) {
 +		snd_hda_codec_configure(codec);
 +	}
 +	return 0;
 +}
 +
 +
 +/*
 + * PCM support
 + */
 +
 +/* assign a stream for the PCM */
 +static inline struct azx_dev *
 +azx_assign_device(struct azx *chip, struct snd_pcm_substream *substream)
 +{
 +	int dev, i, nums;
 +	struct azx_dev *res = NULL;
 +	/* make a non-zero unique key for the substream */
 +	int key = (substream->pcm->device << 16) | (substream->number << 2) |
 +		(substream->stream + 1);
 +
 +	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 +		dev = chip->playback_index_offset;
 +		nums = chip->playback_streams;
 +	} else {
 +		dev = chip->capture_index_offset;
 +		nums = chip->capture_streams;
 +	}
 +	for (i = 0; i < nums; i++, dev++) {
 +		struct azx_dev *azx_dev = &chip->azx_dev[dev];
 +		dsp_lock(azx_dev);
 +		if (!azx_dev->opened && !dsp_is_locked(azx_dev)) {
 +			res = azx_dev;
 +			if (res->assigned_key == key) {
 +				res->opened = 1;
 +				res->assigned_key = key;
 +				dsp_unlock(azx_dev);
 +				return azx_dev;
 +			}
 +		}
 +		dsp_unlock(azx_dev);
 +	}
 +	if (res) {
 +		dsp_lock(res);
 +		res->opened = 1;
 +		res->assigned_key = key;
 +		dsp_unlock(res);
 +	}
 +	return res;
 +}
 +
 +/* release the assigned stream */
 +static inline void azx_release_device(struct azx_dev *azx_dev)
 +{
 +	azx_dev->opened = 0;
 +}
 +
 +static cycle_t azx_cc_read(const struct cyclecounter *cc)
 +{
 +	struct azx_dev *azx_dev = container_of(cc, struct azx_dev, azx_cc);
 +	struct snd_pcm_substream *substream = azx_dev->substream;
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct azx *chip = apcm->chip;
 +
 +	return azx_readl(chip, WALLCLK);
 +}
 +
 +static void azx_timecounter_init(struct snd_pcm_substream *substream,
 +				bool force, cycle_t last)
 +{
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	struct timecounter *tc = &azx_dev->azx_tc;
 +	struct cyclecounter *cc = &azx_dev->azx_cc;
 +	u64 nsec;
 +
 +	cc->read = azx_cc_read;
 +	cc->mask = CLOCKSOURCE_MASK(32);
 +
 +	/*
 +	 * Converting from 24 MHz to ns means applying a 125/3 factor.
 +	 * To avoid any saturation issues in intermediate operations,
 +	 * the 125 factor is applied first. The division is applied
 +	 * last after reading the timecounter value.
 +	 * Applying the 1/3 factor as part of the multiplication
 +	 * requires at least 20 bits for a decent precision, however
 +	 * overflows occur after about 4 hours or less, not a option.
 +	 */
 +
 +	cc->mult = 125; /* saturation after 195 years */
 +	cc->shift = 0;
 +
 +	nsec = 0; /* audio time is elapsed time since trigger */
 +	timecounter_init(tc, cc, nsec);
 +	if (force)
 +		/*
 +		 * force timecounter to use predefined value,
 +		 * used for synchronized starts
 +		 */
 +		tc->cycle_last = last;
 +}
 +
 +static u64 azx_adjust_codec_delay(struct snd_pcm_substream *substream,
 +				u64 nsec)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];
 +	u64 codec_frames, codec_nsecs;
 +
 +	if (!hinfo->ops.get_delay)
 +		return nsec;
 +
 +	codec_frames = hinfo->ops.get_delay(hinfo, apcm->codec, substream);
 +	codec_nsecs = div_u64(codec_frames * 1000000000LL,
 +			      substream->runtime->rate);
 +
 +	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
 +		return nsec + codec_nsecs;
 +
 +	return (nsec > codec_nsecs) ? nsec - codec_nsecs : 0;
 +}
 +
 +static int azx_get_wallclock_tstamp(struct snd_pcm_substream *substream,
 +				struct timespec *ts)
 +{
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	u64 nsec;
 +
 +	nsec = timecounter_read(&azx_dev->azx_tc);
 +	nsec = div_u64(nsec, 3); /* can be optimized */
 +	nsec = azx_adjust_codec_delay(substream, nsec);
 +
 +	*ts = ns_to_timespec(nsec);
 +
 +	return 0;
 +}
 +
 +static struct snd_pcm_hardware azx_pcm_hw = {
 +	.info =			(SNDRV_PCM_INFO_MMAP |
 +				 SNDRV_PCM_INFO_INTERLEAVED |
 +				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
 +				 SNDRV_PCM_INFO_MMAP_VALID |
 +				 /* No full-resume yet implemented */
 +				 /* SNDRV_PCM_INFO_RESUME |*/
 +				 SNDRV_PCM_INFO_PAUSE |
 +				 SNDRV_PCM_INFO_SYNC_START |
 +				 SNDRV_PCM_INFO_HAS_WALL_CLOCK |
 +				 SNDRV_PCM_INFO_NO_PERIOD_WAKEUP),
 +	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
 +	.rates =		SNDRV_PCM_RATE_48000,
 +	.rate_min =		48000,
 +	.rate_max =		48000,
 +	.channels_min =		2,
 +	.channels_max =		2,
 +	.buffer_bytes_max =	AZX_MAX_BUF_SIZE,
 +	.period_bytes_min =	128,
 +	.period_bytes_max =	AZX_MAX_BUF_SIZE / 2,
 +	.periods_min =		2,
 +	.periods_max =		AZX_MAX_FRAG,
 +	.fifo_size =		0,
 +};
 +
 +static int azx_pcm_open(struct snd_pcm_substream *substream)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];
 +	struct azx *chip = apcm->chip;
 +	struct azx_dev *azx_dev;
 +	struct snd_pcm_runtime *runtime = substream->runtime;
 +	unsigned long flags;
 +	int err;
 +	int buff_step;
 +
 +	mutex_lock(&chip->open_mutex);
 +	azx_dev = azx_assign_device(chip, substream);
 +	if (azx_dev == NULL) {
 +		mutex_unlock(&chip->open_mutex);
 +		return -EBUSY;
 +	}
 +	runtime->hw = azx_pcm_hw;
 +	runtime->hw.channels_min = hinfo->channels_min;
 +	runtime->hw.channels_max = hinfo->channels_max;
 +	runtime->hw.formats = hinfo->formats;
 +	runtime->hw.rates = hinfo->rates;
 +	snd_pcm_limit_hw_rates(runtime);
 +	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
 +
 +	/* avoid wrap-around with wall-clock */
 +	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_TIME,
 +				20,
 +				178000000);
 +
 +	if (chip->align_buffer_size)
 +		/* constrain buffer sizes to be multiple of 128
 +		   bytes. This is more efficient in terms of memory
 +		   access but isn't required by the HDA spec and
 +		   prevents users from specifying exact period/buffer
 +		   sizes. For example for 44.1kHz, a period size set
 +		   to 20ms will be rounded to 19.59ms. */
 +		buff_step = 128;
 +	else
 +		/* Don't enforce steps on buffer sizes, still need to
 +		   be multiple of 4 bytes (HDA spec). Tested on Intel
 +		   HDA controllers, may not work on all devices where
 +		   option needs to be disabled */
 +		buff_step = 4;
 +
 +	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
 +				   buff_step);
 +	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
 +				   buff_step);
 +	snd_hda_power_up_d3wait(apcm->codec);
 +	err = hinfo->ops.open(hinfo, apcm->codec, substream);
 +	if (err < 0) {
 +		azx_release_device(azx_dev);
 +		snd_hda_power_down(apcm->codec);
 +		mutex_unlock(&chip->open_mutex);
 +		return err;
 +	}
 +	snd_pcm_limit_hw_rates(runtime);
 +	/* sanity check */
 +	if (snd_BUG_ON(!runtime->hw.channels_min) ||
 +	    snd_BUG_ON(!runtime->hw.channels_max) ||
 +	    snd_BUG_ON(!runtime->hw.formats) ||
 +	    snd_BUG_ON(!runtime->hw.rates)) {
 +		azx_release_device(azx_dev);
 +		hinfo->ops.close(hinfo, apcm->codec, substream);
 +		snd_hda_power_down(apcm->codec);
 +		mutex_unlock(&chip->open_mutex);
 +		return -EINVAL;
 +	}
 +
 +	/* disable WALLCLOCK timestamps for capture streams
 +	   until we figure out how to handle digital inputs */
 +	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
 +		runtime->hw.info &= ~SNDRV_PCM_INFO_HAS_WALL_CLOCK;
 +
 +	spin_lock_irqsave(&chip->reg_lock, flags);
 +	azx_dev->substream = substream;
 +	azx_dev->running = 0;
 +	spin_unlock_irqrestore(&chip->reg_lock, flags);
 +
 +	runtime->private_data = azx_dev;
 +	snd_pcm_set_sync(substream);
 +	mutex_unlock(&chip->open_mutex);
 +	return 0;
 +}
 +
 +static int azx_pcm_close(struct snd_pcm_substream *substream)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];
 +	struct azx *chip = apcm->chip;
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	unsigned long flags;
 +
 +	mutex_lock(&chip->open_mutex);
 +	spin_lock_irqsave(&chip->reg_lock, flags);
 +	azx_dev->substream = NULL;
 +	azx_dev->running = 0;
 +	spin_unlock_irqrestore(&chip->reg_lock, flags);
 +	azx_release_device(azx_dev);
 +	hinfo->ops.close(hinfo, apcm->codec, substream);
 +	snd_hda_power_down(apcm->codec);
 +	mutex_unlock(&chip->open_mutex);
 +	return 0;
 +}
 +
 +static int azx_pcm_hw_params(struct snd_pcm_substream *substream,
 +			     struct snd_pcm_hw_params *hw_params)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct azx *chip = apcm->chip;
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	int ret;
 +
 +	dsp_lock(azx_dev);
 +	if (dsp_is_locked(azx_dev)) {
 +		ret = -EBUSY;
 +		goto unlock;
 +	}
 +
 +	mark_runtime_wc(chip, azx_dev, substream, false);
 +	azx_dev->bufsize = 0;
 +	azx_dev->period_bytes = 0;
 +	azx_dev->format_val = 0;
 +	ret = snd_pcm_lib_malloc_pages(substream,
 +					params_buffer_bytes(hw_params));
 +	if (ret < 0)
 +		goto unlock;
 +	mark_runtime_wc(chip, azx_dev, substream, true);
 + unlock:
 +	dsp_unlock(azx_dev);
 +	return ret;
 +}
 +
 +static int azx_pcm_hw_free(struct snd_pcm_substream *substream)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	struct azx *chip = apcm->chip;
 +	struct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];
 +
 +	/* reset BDL address */
 +	dsp_lock(azx_dev);
 +	if (!dsp_is_locked(azx_dev)) {
 +		azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +		azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +		azx_sd_writel(chip, azx_dev, SD_CTL, 0);
 +		azx_dev->bufsize = 0;
 +		azx_dev->period_bytes = 0;
 +		azx_dev->format_val = 0;
 +	}
 +
 +	snd_hda_codec_cleanup(apcm->codec, hinfo, substream);
 +
 +	mark_runtime_wc(chip, azx_dev, substream, false);
 +	azx_dev->prepared = 0;
 +	dsp_unlock(azx_dev);
 +	return snd_pcm_lib_free_pages(substream);
 +}
 +
 +static int azx_pcm_prepare(struct snd_pcm_substream *substream)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct azx *chip = apcm->chip;
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	struct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];
 +	struct snd_pcm_runtime *runtime = substream->runtime;
 +	unsigned int bufsize, period_bytes, format_val, stream_tag;
 +	int err;
 +	struct hda_spdif_out *spdif =
 +		snd_hda_spdif_out_of_nid(apcm->codec, hinfo->nid);
 +	unsigned short ctls = spdif ? spdif->ctls : 0;
 +
 +	dsp_lock(azx_dev);
 +	if (dsp_is_locked(azx_dev)) {
 +		err = -EBUSY;
 +		goto unlock;
 +	}
 +
 +	azx_stream_reset(chip, azx_dev);
 +	format_val = snd_hda_calc_stream_format(runtime->rate,
 +						runtime->channels,
 +						runtime->format,
 +						hinfo->maxbps,
 +						ctls);
 +	if (!format_val) {
 +		snd_printk(KERN_ERR SFX
 +			   "%s: invalid format_val, rate=%d, ch=%d, format=%d\n",
 +			   pci_name(chip->pci), runtime->rate, runtime->channels, runtime->format);
 +		err = -EINVAL;
 +		goto unlock;
 +	}
 +
 +	bufsize = snd_pcm_lib_buffer_bytes(substream);
 +	period_bytes = snd_pcm_lib_period_bytes(substream);
 +
 +	snd_printdd(SFX "%s: azx_pcm_prepare: bufsize=0x%x, format=0x%x\n",
 +		    pci_name(chip->pci), bufsize, format_val);
 +
 +	if (bufsize != azx_dev->bufsize ||
 +	    period_bytes != azx_dev->period_bytes ||
 +	    format_val != azx_dev->format_val ||
 +	    runtime->no_period_wakeup != azx_dev->no_period_wakeup) {
 +		azx_dev->bufsize = bufsize;
 +		azx_dev->period_bytes = period_bytes;
 +		azx_dev->format_val = format_val;
 +		azx_dev->no_period_wakeup = runtime->no_period_wakeup;
 +		err = azx_setup_periods(chip, substream, azx_dev);
 +		if (err < 0)
 +			goto unlock;
 +	}
 +
 +	/* when LPIB delay correction gives a small negative value,
 +	 * we ignore it; currently set the threshold statically to
 +	 * 64 frames
 +	 */
 +	if (runtime->period_size > 64)
 +		azx_dev->delay_negative_threshold = -frames_to_bytes(runtime, 64);
 +	else
 +		azx_dev->delay_negative_threshold = 0;
 +
 +	/* wallclk has 24Mhz clock source */
 +	azx_dev->period_wallclk = (((runtime->period_size * 24000) /
 +						runtime->rate) * 1000);
 +	azx_setup_controller(chip, azx_dev);
 +	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 +		azx_dev->fifo_size =
 +			azx_sd_readw(chip, azx_dev, SD_FIFOSIZE) + 1;
 +	else
 +		azx_dev->fifo_size = 0;
 +
 +	stream_tag = azx_dev->stream_tag;
 +	/* CA-IBG chips need the playback stream starting from 1 */
 +	if ((chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND) &&
 +	    stream_tag > chip->capture_streams)
 +		stream_tag -= chip->capture_streams;
 +	err = snd_hda_codec_prepare(apcm->codec, hinfo, stream_tag,
 +				     azx_dev->format_val, substream);
 +
 + unlock:
 +	if (!err)
 +		azx_dev->prepared = 1;
 +	dsp_unlock(azx_dev);
 +	return err;
 +}
 +
 +static int azx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct azx *chip = apcm->chip;
 +	struct azx_dev *azx_dev;
 +	struct snd_pcm_substream *s;
 +	int rstart = 0, start, nsync = 0, sbits = 0;
 +	int nwait, timeout;
 +
 +	azx_dev = get_azx_dev(substream);
 +	trace_azx_pcm_trigger(chip, azx_dev, cmd);
 +
 +	if (dsp_is_locked(azx_dev) || !azx_dev->prepared)
 +		return -EPIPE;
 +
 +	switch (cmd) {
 +	case SNDRV_PCM_TRIGGER_START:
 +		rstart = 1;
 +	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 +	case SNDRV_PCM_TRIGGER_RESUME:
 +		start = 1;
 +		break;
 +	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 +	case SNDRV_PCM_TRIGGER_SUSPEND:
 +	case SNDRV_PCM_TRIGGER_STOP:
 +		start = 0;
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +
 +	snd_pcm_group_for_each_entry(s, substream) {
 +		if (s->pcm->card != substream->pcm->card)
 +			continue;
 +		azx_dev = get_azx_dev(s);
 +		sbits |= 1 << azx_dev->index;
 +		nsync++;
 +		snd_pcm_trigger_done(s, substream);
 +	}
 +
 +	spin_lock(&chip->reg_lock);
 +
 +	/* first, set SYNC bits of corresponding streams */
 +	if (chip->driver_caps & AZX_DCAPS_OLD_SSYNC)
 +		azx_writel(chip, OLD_SSYNC,
 +			azx_readl(chip, OLD_SSYNC) | sbits);
 +	else
 +		azx_writel(chip, SSYNC, azx_readl(chip, SSYNC) | sbits);
 +
 +	snd_pcm_group_for_each_entry(s, substream) {
 +		if (s->pcm->card != substream->pcm->card)
 +			continue;
 +		azx_dev = get_azx_dev(s);
 +		if (start) {
 +			azx_dev->start_wallclk = azx_readl(chip, WALLCLK);
 +			if (!rstart)
 +				azx_dev->start_wallclk -=
 +						azx_dev->period_wallclk;
 +			azx_stream_start(chip, azx_dev);
 +		} else {
 +			azx_stream_stop(chip, azx_dev);
 +		}
 +		azx_dev->running = start;
 +	}
 +	spin_unlock(&chip->reg_lock);
 +	if (start) {
 +		/* wait until all FIFOs get ready */
 +		for (timeout = 5000; timeout; timeout--) {
 +			nwait = 0;
 +			snd_pcm_group_for_each_entry(s, substream) {
 +				if (s->pcm->card != substream->pcm->card)
 +					continue;
 +				azx_dev = get_azx_dev(s);
 +				if (!(azx_sd_readb(chip, azx_dev, SD_STS) &
 +				      SD_STS_FIFO_READY))
 +					nwait++;
 +			}
 +			if (!nwait)
 +				break;
 +			cpu_relax();
 +		}
 +	} else {
 +		/* wait until all RUN bits are cleared */
 +		for (timeout = 5000; timeout; timeout--) {
 +			nwait = 0;
 +			snd_pcm_group_for_each_entry(s, substream) {
 +				if (s->pcm->card != substream->pcm->card)
 +					continue;
 +				azx_dev = get_azx_dev(s);
 +				if (azx_sd_readb(chip, azx_dev, SD_CTL) &
 +				    SD_CTL_DMA_START)
 +					nwait++;
 +			}
 +			if (!nwait)
 +				break;
 +			cpu_relax();
 +		}
 +	}
 +	spin_lock(&chip->reg_lock);
 +	/* reset SYNC bits */
 +	if (chip->driver_caps & AZX_DCAPS_OLD_SSYNC)
 +		azx_writel(chip, OLD_SSYNC,
 +			azx_readl(chip, OLD_SSYNC) & ~sbits);
 +	else
 +		azx_writel(chip, SSYNC, azx_readl(chip, SSYNC) & ~sbits);
 +	if (start) {
 +		azx_timecounter_init(substream, 0, 0);
 +		if (nsync > 1) {
 +			cycle_t cycle_last;
 +
 +			/* same start cycle for master and group */
 +			azx_dev = get_azx_dev(substream);
 +			cycle_last = azx_dev->azx_tc.cycle_last;
 +
 +			snd_pcm_group_for_each_entry(s, substream) {
 +				if (s->pcm->card != substream->pcm->card)
 +					continue;
 +				azx_timecounter_init(s, 1, cycle_last);
 +			}
 +		}
 +	}
 +	spin_unlock(&chip->reg_lock);
 +	return 0;
 +}
 +
 +/* get the current DMA position with correction on VIA chips */
 +static unsigned int azx_via_get_position(struct azx *chip,
 +					 struct azx_dev *azx_dev)
 +{
 +	unsigned int link_pos, mini_pos, bound_pos;
 +	unsigned int mod_link_pos, mod_dma_pos, mod_mini_pos;
 +	unsigned int fifo_size;
 +
 +	link_pos = azx_sd_readl(chip, azx_dev, SD_LPIB);
 +	if (azx_dev->substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 +		/* Playback, no problem using link position */
 +		return link_pos;
 +	}
 +
 +	/* Capture */
 +	/* For new chipset,
 +	 * use mod to get the DMA position just like old chipset
 +	 */
 +	mod_dma_pos = le32_to_cpu(*azx_dev->posbuf);
 +	mod_dma_pos %= azx_dev->period_bytes;
 +
 +	/* azx_dev->fifo_size can't get FIFO size of in stream.
 +	 * Get from base address + offset.
 +	 */
 +	fifo_size = readw(chip->remap_addr + VIA_IN_STREAM0_FIFO_SIZE_OFFSET);
 +
 +	if (azx_dev->insufficient) {
 +		/* Link position never gather than FIFO size */
 +		if (link_pos <= fifo_size)
 +			return 0;
 +
 +		azx_dev->insufficient = 0;
 +	}
 +
 +	if (link_pos <= fifo_size)
 +		mini_pos = azx_dev->bufsize + link_pos - fifo_size;
 +	else
 +		mini_pos = link_pos - fifo_size;
 +
 +	/* Find nearest previous boudary */
 +	mod_mini_pos = mini_pos % azx_dev->period_bytes;
 +	mod_link_pos = link_pos % azx_dev->period_bytes;
 +	if (mod_link_pos >= fifo_size)
 +		bound_pos = link_pos - mod_link_pos;
 +	else if (mod_dma_pos >= mod_mini_pos)
 +		bound_pos = mini_pos - mod_mini_pos;
 +	else {
 +		bound_pos = mini_pos - mod_mini_pos + azx_dev->period_bytes;
 +		if (bound_pos >= azx_dev->bufsize)
 +			bound_pos = 0;
 +	}
 +
 +	/* Calculate real DMA position we want */
 +	return bound_pos + mod_dma_pos;
 +}
 +
 +static unsigned int azx_get_position(struct azx *chip,
 +				     struct azx_dev *azx_dev,
 +				     bool with_check)
  {
  	struct snd_pcm_substream *substream = azx_dev->substream;
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	unsigned int pos;
  	int stream = substream->stream;
 -	unsigned int lpib_pos = azx_get_pos_lpib(chip, azx_dev);
 -	int delay;
 +	struct hda_pcm_stream *hinfo = apcm->hinfo[stream];
 +	int delay = 0;
  
 -	if (stream == SNDRV_PCM_STREAM_PLAYBACK)
 -		delay = pos - lpib_pos;
 -	else
 -		delay = lpib_pos - pos;
 -	if (delay < 0) {
 -		if (delay >= azx_dev->delay_negative_threshold)
 -			delay = 0;
 +	switch (chip->position_fix[stream]) {
 +	case POS_FIX_LPIB:
 +		/* read LPIB */
 +		pos = azx_sd_readl(chip, azx_dev, SD_LPIB);
 +		break;
 +	case POS_FIX_VIACOMBO:
 +		pos = azx_via_get_position(chip, azx_dev);
 +		break;
 +	default:
 +		/* use the position buffer */
 +		pos = le32_to_cpu(*azx_dev->posbuf);
 +		if (with_check && chip->position_fix[stream] == POS_FIX_AUTO) {
 +			if (!pos || pos == (u32)-1) {
 +				printk(KERN_WARNING
 +				       "hda-intel: Invalid position buffer, "
 +				       "using LPIB read method instead.\n");
 +				chip->position_fix[stream] = POS_FIX_LPIB;
 +				pos = azx_sd_readl(chip, azx_dev, SD_LPIB);
 +			} else
 +				chip->position_fix[stream] = POS_FIX_POSBUF;
 +		}
 +		break;
 +	}
 +
 +	if (pos >= azx_dev->bufsize)
 +		pos = 0;
 +
 +	/* calculate runtime delay from LPIB */
 +	if (substream->runtime &&
 +	    chip->position_fix[stream] == POS_FIX_POSBUF &&
 +	    (chip->driver_caps & AZX_DCAPS_COUNT_LPIB_DELAY)) {
 +		unsigned int lpib_pos = azx_sd_readl(chip, azx_dev, SD_LPIB);
 +		if (stream == SNDRV_PCM_STREAM_PLAYBACK)
 +			delay = pos - lpib_pos;
  		else
 -			delay += azx_dev->bufsize;
 +			delay = lpib_pos - pos;
 +		if (delay < 0) {
 +			if (delay >= azx_dev->delay_negative_threshold)
 +				delay = 0;
 +			else
 +				delay += azx_dev->bufsize;
 +		}
 +		if (delay >= azx_dev->period_bytes) {
 +			snd_printk(KERN_WARNING SFX
 +				   "%s: Unstable LPIB (%d >= %d); "
 +				   "disabling LPIB delay counting\n",
 +				   pci_name(chip->pci), delay, azx_dev->period_bytes);
 +			delay = 0;
 +			chip->driver_caps &= ~AZX_DCAPS_COUNT_LPIB_DELAY;
 +		}
 +		delay = bytes_to_frames(substream->runtime, delay);
  	}
  
 -	if (delay >= azx_dev->period_bytes) {
 -		dev_info(chip->card->dev,
 -			 "Unstable LPIB (%d >= %d); disabling LPIB delay counting\n",
 -			 delay, azx_dev->period_bytes);
 -		delay = 0;
 -		chip->driver_caps &= ~AZX_DCAPS_COUNT_LPIB_DELAY;
 -		chip->get_delay[stream] = NULL;
 +	if (substream->runtime) {
 +		if (hinfo->ops.get_delay)
 +			delay += hinfo->ops.get_delay(hinfo, apcm->codec,
 +						      substream);
 +		substream->runtime->delay = delay;
  	}
  
 -	return bytes_to_frames(substream->runtime, delay);
 +	trace_azx_get_position(chip, azx_dev, pos, delay);
 +	return pos;
  }
  
 -static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev);
 -
 -/* called from IRQ */
 -static int azx_position_check(struct azx *chip, struct azx_dev *azx_dev)
 +static snd_pcm_uframes_t azx_pcm_pointer(struct snd_pcm_substream *substream)
  {
 -	int ok;
 -
 -	ok = azx_position_ok(chip, azx_dev);
 -	if (ok == 1) {
 -		azx_dev->irq_pending = 0;
 -		return ok;
 -	} else if (ok == 0 && chip->bus && chip->bus->workq) {
 -		/* bogus IRQ, process it later */
 -		azx_dev->irq_pending = 1;
 -		queue_work(chip->bus->workq, &chip->irq_pending_work);
 -	}
 -	return 0;
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct azx *chip = apcm->chip;
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	return bytes_to_frames(substream->runtime,
 +			       azx_get_position(chip, azx_dev, false));
  }
  
  /*
@@@ -2357,160 -615,63 +2420,219 @@@ static int azx_acquire_irq(struct azx *
  	return 0;
  }
  
++<<<<<<< HEAD
 +
 +static void azx_stop_chip(struct azx *chip)
 +{
 +	if (!chip->initialized)
 +		return;
 +
 +	/* disable interrupts */
 +	azx_int_disable(chip);
 +	azx_int_clear(chip);
 +
 +	/* disable CORB/RIRB */
 +	azx_free_cmd_io(chip);
 +
 +	/* disable position buffer */
 +	azx_writel(chip, DPLBASE, 0);
 +	azx_writel(chip, DPUBASE, 0);
 +
 +	chip->initialized = 0;
 +}
 +
 +#ifdef CONFIG_SND_HDA_DSP_LOADER
 +/*
 + * DSP loading code (e.g. for CA0132)
 + */
 +
 +/* use the first stream for loading DSP */
 +static struct azx_dev *
 +azx_get_dsp_loader_dev(struct azx *chip)
 +{
 +	return &chip->azx_dev[chip->playback_index_offset];
 +}
 +
 +static int azx_load_dsp_prepare(struct hda_bus *bus, unsigned int format,
 +				unsigned int byte_size,
 +				struct snd_dma_buffer *bufp)
 +{
 +	u32 *bdl;
 +	struct azx *chip = bus->private_data;
 +	struct azx_dev *azx_dev;
 +	int err;
 +
 +	azx_dev = azx_get_dsp_loader_dev(chip);
 +
 +	dsp_lock(azx_dev);
 +	spin_lock_irq(&chip->reg_lock);
 +	if (azx_dev->running || azx_dev->locked) {
 +		spin_unlock_irq(&chip->reg_lock);
 +		err = -EBUSY;
 +		goto unlock;
 +	}
 +	azx_dev->prepared = 0;
 +	chip->saved_azx_dev = *azx_dev;
 +	azx_dev->locked = 1;
 +	spin_unlock_irq(&chip->reg_lock);
 +
 +	err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV_SG,
 +				  chip->card->dev,
 +				  byte_size, bufp);
 +	if (err < 0)
 +		goto err_alloc;
 +
 +	mark_pages_wc(chip, bufp, true);
 +	azx_dev->bufsize = byte_size;
 +	azx_dev->period_bytes = byte_size;
 +	azx_dev->format_val = format;
 +
 +	azx_stream_reset(chip, azx_dev);
 +
 +	/* reset BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +
 +	azx_dev->frags = 0;
 +	bdl = (u32 *)azx_dev->bdl.area;
 +	err = setup_bdle(chip, bufp, azx_dev, &bdl, 0, byte_size, 0);
 +	if (err < 0)
 +		goto error;
 +
 +	azx_setup_controller(chip, azx_dev);
 +	dsp_unlock(azx_dev);
 +	return azx_dev->stream_tag;
 +
 + error:
 +	mark_pages_wc(chip, bufp, false);
 +	snd_dma_free_pages(bufp);
 + err_alloc:
 +	spin_lock_irq(&chip->reg_lock);
 +	if (azx_dev->opened)
 +		*azx_dev = chip->saved_azx_dev;
 +	azx_dev->locked = 0;
 +	spin_unlock_irq(&chip->reg_lock);
 + unlock:
 +	dsp_unlock(azx_dev);
 +	return err;
 +}
 +
 +static void azx_load_dsp_trigger(struct hda_bus *bus, bool start)
 +{
 +	struct azx *chip = bus->private_data;
 +	struct azx_dev *azx_dev = azx_get_dsp_loader_dev(chip);
 +
 +	if (start)
 +		azx_stream_start(chip, azx_dev);
 +	else
 +		azx_stream_stop(chip, azx_dev);
 +	azx_dev->running = start;
 +}
 +
 +static void azx_load_dsp_cleanup(struct hda_bus *bus,
 +				 struct snd_dma_buffer *dmab)
 +{
 +	struct azx *chip = bus->private_data;
 +	struct azx_dev *azx_dev = azx_get_dsp_loader_dev(chip);
 +
 +	if (!dmab->area || !azx_dev->locked)
 +		return;
 +
 +	dsp_lock(azx_dev);
 +	/* reset BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +	azx_sd_writel(chip, azx_dev, SD_CTL, 0);
 +	azx_dev->bufsize = 0;
 +	azx_dev->period_bytes = 0;
 +	azx_dev->format_val = 0;
 +
 +	mark_pages_wc(chip, dmab, false);
 +	snd_dma_free_pages(dmab);
 +	dmab->area = NULL;
 +
 +	spin_lock_irq(&chip->reg_lock);
 +	if (azx_dev->opened)
 +		*azx_dev = chip->saved_azx_dev;
 +	azx_dev->locked = 0;
 +	spin_unlock_irq(&chip->reg_lock);
 +	dsp_unlock(azx_dev);
 +}
 +#endif /* CONFIG_SND_HDA_DSP_LOADER */
 +
++=======
+ /* get the current DMA position with correction on VIA chips */
+ static unsigned int azx_via_get_position(struct azx *chip,
+ 					 struct azx_dev *azx_dev)
+ {
+ 	unsigned int link_pos, mini_pos, bound_pos;
+ 	unsigned int mod_link_pos, mod_dma_pos, mod_mini_pos;
+ 	unsigned int fifo_size;
+ 
+ 	link_pos = azx_sd_readl(chip, azx_dev, SD_LPIB);
+ 	if (azx_dev->substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+ 		/* Playback, no problem using link position */
+ 		return link_pos;
+ 	}
+ 
+ 	/* Capture */
+ 	/* For new chipset,
+ 	 * use mod to get the DMA position just like old chipset
+ 	 */
+ 	mod_dma_pos = le32_to_cpu(*azx_dev->posbuf);
+ 	mod_dma_pos %= azx_dev->period_bytes;
+ 
+ 	/* azx_dev->fifo_size can't get FIFO size of in stream.
+ 	 * Get from base address + offset.
+ 	 */
+ 	fifo_size = readw(chip->remap_addr + VIA_IN_STREAM0_FIFO_SIZE_OFFSET);
+ 
+ 	if (azx_dev->insufficient) {
+ 		/* Link position never gather than FIFO size */
+ 		if (link_pos <= fifo_size)
+ 			return 0;
+ 
+ 		azx_dev->insufficient = 0;
+ 	}
+ 
+ 	if (link_pos <= fifo_size)
+ 		mini_pos = azx_dev->bufsize + link_pos - fifo_size;
+ 	else
+ 		mini_pos = link_pos - fifo_size;
+ 
+ 	/* Find nearest previous boudary */
+ 	mod_mini_pos = mini_pos % azx_dev->period_bytes;
+ 	mod_link_pos = link_pos % azx_dev->period_bytes;
+ 	if (mod_link_pos >= fifo_size)
+ 		bound_pos = link_pos - mod_link_pos;
+ 	else if (mod_dma_pos >= mod_mini_pos)
+ 		bound_pos = mini_pos - mod_mini_pos;
+ 	else {
+ 		bound_pos = mini_pos - mod_mini_pos + azx_dev->period_bytes;
+ 		if (bound_pos >= azx_dev->bufsize)
+ 			bound_pos = 0;
+ 	}
+ 
+ 	/* Calculate real DMA position we want */
+ 	return bound_pos + mod_dma_pos;
+ }
+ 
++>>>>>>> b6050ef66421 (ALSA: hda - Make position_fix as generic callback)
  #ifdef CONFIG_PM
 +/* power-up/down the controller */
 +static void azx_power_notify(struct hda_bus *bus, bool power_up)
 +{
 +	struct azx *chip = bus->private_data;
 +
 +	if (!(chip->driver_caps & AZX_DCAPS_PM_RUNTIME))
 +		return;
 +
 +	if (power_up)
 +		pm_runtime_get_sync(chip->card->dev);
 +	else
 +		pm_runtime_put_sync(chip->card->dev);
 +}
 +
  static DEFINE_MUTEX(card_list_lock);
  static LIST_HEAD(card_list);
  
diff --cc sound/pci/hda/hda_priv.h
index 31c45c8ab247,43dd8a19cc09..000000000000
--- a/sound/pci/hda/hda_priv.h
+++ b/sound/pci/hda/hda_priv.h
@@@ -186,16 -186,8 +186,7 @@@ enum { SDI0, SDI1, SDI2, SDI3, SDO0, SD
  #define AZX_DCAPS_COUNT_LPIB_DELAY  (1 << 25)	/* Take LPIB as delay */
  #define AZX_DCAPS_PM_RUNTIME	(1 << 26)	/* runtime PM support */
  #define AZX_DCAPS_I915_POWERWELL (1 << 27)	/* HSW i915 powerwell support */
 -#define AZX_DCAPS_CORBRP_SELF_CLEAR (1 << 28)	/* CORBRP clears itself after reset */
  
- /* position fix mode */
- enum {
- 	POS_FIX_AUTO,
- 	POS_FIX_LPIB,
- 	POS_FIX_POSBUF,
- 	POS_FIX_VIACOMBO,
- 	POS_FIX_COMBO,
- };
- 
  /* Defines for ATI HD Audio support in SB450 south bridge */
  #define ATI_SB450_HDAUDIO_MISC_CNTR2_ADDR   0x42
  #define ATI_SB450_HDAUDIO_ENABLE_SNOOP      0x02
@@@ -354,7 -372,7 +352,11 @@@ struct azx 
  #endif
  
  	/* flags */
++<<<<<<< HEAD
 +	int position_fix[2]; /* for both playback/capture streams */
++=======
+ 	const int *bdl_pos_adj;
++>>>>>>> b6050ef66421 (ALSA: hda - Make position_fix as generic callback)
  	int poll_count;
  	unsigned int running:1;
  	unsigned int initialized:1;
* Unmerged path sound/pci/hda/hda_controller.c
* Unmerged path sound/pci/hda/hda_controller.h
* Unmerged path sound/pci/hda/hda_tegra.c
* Unmerged path sound/pci/hda/hda_controller.c
* Unmerged path sound/pci/hda/hda_controller.h
* Unmerged path sound/pci/hda/hda_intel.c
* Unmerged path sound/pci/hda/hda_priv.h
* Unmerged path sound/pci/hda/hda_tegra.c
