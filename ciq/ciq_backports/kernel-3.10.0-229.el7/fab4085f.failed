netfilter: log: nf_log_packet() as real unified interface

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit fab4085f4e248b8a80bb1dadbbacb2bacd8017c3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/fab4085f.failed

Before this patch, the nf_loginfo parameter specified the logging
configuration in case the specified default logger was loaded. This
patch updates the semantics of the nf_loginfo parameter in
nf_log_packet() which now indicates the logger that you explicitly
want to use.

Thus, nf_log_packet() is exposed as an unified interface which
internally routes the log message to the corresponding logger type
by family.

The module dependencies are expressed by the new nf_logger_find_get()
and nf_logger_put() functions which bump the logger module refcount.
Thus, you can not remove logger modules that are used by rules anymore.

Another important effect of this change is that the family specific
module is only loaded when required. Therefore, xt_LOG and nft_log
will just trigger the autoload of the nf_log_{ip,ip6} modules
according to the family.

	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit fab4085f4e248b8a80bb1dadbbacb2bacd8017c3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/netfilter/nf_log.h
#	net/ipv4/netfilter/nf_log_ipv4.c
#	net/ipv6/netfilter/nf_log_ipv6.c
#	net/netfilter/xt_LOG.c
diff --cc include/net/netfilter/nf_log.h
index aaec845de106,b82dd19b8f26..000000000000
--- a/include/net/netfilter/nf_log.h
+++ b/include/net/netfilter/nf_log.h
@@@ -78,4 -84,18 +84,21 @@@ struct nf_log_buf *nf_log_buf_open(void
  __printf(2, 3) int nf_log_buf_add(struct nf_log_buf *m, const char *f, ...);
  void nf_log_buf_close(struct nf_log_buf *m);
  
++<<<<<<< HEAD
++=======
+ /* common logging functions */
+ int nf_log_dump_udp_header(struct nf_log_buf *m, const struct sk_buff *skb,
+ 			   u8 proto, int fragment, unsigned int offset);
+ int nf_log_dump_tcp_header(struct nf_log_buf *m, const struct sk_buff *skb,
+ 			   u8 proto, int fragment, unsigned int offset,
+ 			   unsigned int logflags);
+ void nf_log_dump_sk_uid_gid(struct nf_log_buf *m, struct sock *sk);
+ void nf_log_dump_packet_common(struct nf_log_buf *m, u_int8_t pf,
+ 			       unsigned int hooknum, const struct sk_buff *skb,
+ 			       const struct net_device *in,
+ 			       const struct net_device *out,
+ 			       const struct nf_loginfo *loginfo,
+ 			       const char *prefix);
+ 
++>>>>>>> fab4085f4e24 (netfilter: log: nf_log_packet() as real unified interface)
  #endif /* _NF_LOG_H */
diff --cc net/netfilter/xt_LOG.c
index 649b85fc5463,00eb49196e75..000000000000
--- a/net/netfilter/xt_LOG.c
+++ b/net/netfilter/xt_LOG.c
@@@ -846,17 -39,8 +846,22 @@@ log_tg(struct sk_buff *skb, const struc
  	li.u.log.level = loginfo->level;
  	li.u.log.logflags = loginfo->logflags;
  
++<<<<<<< HEAD
 +	if (par->family == NFPROTO_IPV4)
 +		ipt_log_packet(net, NFPROTO_IPV4, par->hooknum, skb, par->in,
 +			       par->out, &li, loginfo->prefix);
 +#if IS_ENABLED(CONFIG_IP6_NF_IPTABLES)
 +	else if (par->family == NFPROTO_IPV6)
 +		ip6t_log_packet(net, NFPROTO_IPV6, par->hooknum, skb, par->in,
 +				par->out, &li, loginfo->prefix);
 +#endif
 +	else
 +		WARN_ON_ONCE(1);
 +
++=======
+ 	nf_log_packet(net, par->family, par->hooknum, skb, par->in, par->out,
+ 		      &li, loginfo->prefix);
++>>>>>>> fab4085f4e24 (netfilter: log: nf_log_packet() as real unified interface)
  	return XT_CONTINUE;
  }
  
* Unmerged path net/ipv4/netfilter/nf_log_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_log_ipv6.c
* Unmerged path include/net/netfilter/nf_log.h
* Unmerged path net/ipv4/netfilter/nf_log_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_log_ipv6.c
diff --git a/net/netfilter/nf_log.c b/net/netfilter/nf_log.c
index 0b6b2c874199..0b2161c689e0 100644
--- a/net/netfilter/nf_log.c
+++ b/net/netfilter/nf_log.c
@@ -132,6 +132,41 @@ void nf_log_unbind_pf(struct net *net, u_int8_t pf)
 }
 EXPORT_SYMBOL(nf_log_unbind_pf);
 
+int nf_logger_find_get(int pf, enum nf_log_type type)
+{
+	struct nf_logger *logger;
+	int ret = -ENOENT;
+
+	logger = loggers[pf][type];
+	if (logger == NULL)
+		request_module("nf-logger-%u-%u", pf, type);
+
+	rcu_read_lock();
+	logger = rcu_dereference(loggers[pf][type]);
+	if (logger == NULL)
+		goto out;
+
+	if (logger && try_module_get(logger->me))
+		ret = 0;
+out:
+	rcu_read_unlock();
+	return ret;
+}
+EXPORT_SYMBOL_GPL(nf_logger_find_get);
+
+void nf_logger_put(int pf, enum nf_log_type type)
+{
+	struct nf_logger *logger;
+
+	BUG_ON(loggers[pf][type] == NULL);
+
+	rcu_read_lock();
+	logger = rcu_dereference(loggers[pf][type]);
+	module_put(logger->me);
+	rcu_read_unlock();
+}
+EXPORT_SYMBOL_GPL(nf_logger_put);
+
 void nf_log_packet(struct net *net,
 		   u_int8_t pf,
 		   unsigned int hooknum,
@@ -146,7 +181,11 @@ void nf_log_packet(struct net *net,
 	const struct nf_logger *logger;
 
 	rcu_read_lock();
-	logger = rcu_dereference(net->nf.nf_loggers[pf]);
+	if (loginfo != NULL)
+		logger = rcu_dereference(loggers[pf][loginfo->type]);
+	else
+		logger = rcu_dereference(net->nf.nf_loggers[pf]);
+
 	if (logger) {
 		va_start(args, fmt);
 		vsnprintf(prefix, sizeof(prefix), fmt, args);
diff --git a/net/netfilter/nfnetlink_log.c b/net/netfilter/nfnetlink_log.c
index 7f93a4483c99..80b94a26337d 100644
--- a/net/netfilter/nfnetlink_log.c
+++ b/net/netfilter/nfnetlink_log.c
@@ -1112,6 +1112,9 @@ MODULE_DESCRIPTION("netfilter userspace logging");
 MODULE_AUTHOR("Harald Welte <laforge@netfilter.org>");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS_NFNL_SUBSYS(NFNL_SUBSYS_ULOG);
+MODULE_ALIAS_NF_LOGGER(AF_INET, 1);
+MODULE_ALIAS_NF_LOGGER(AF_INET6, 1);
+MODULE_ALIAS_NF_LOGGER(AF_BRIDGE, 1);
 
 module_init(nfnetlink_log_init);
 module_exit(nfnetlink_log_fini);
* Unmerged path net/netfilter/xt_LOG.c
