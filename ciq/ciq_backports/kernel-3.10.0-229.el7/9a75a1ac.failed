ixgbe: Add new support for X550 MAC's

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Don Skidmore <donald.c.skidmore@intel.com>
commit 9a75a1ac77fac4f63d7013c66c550fbf8e213715
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/9a75a1ac.failed

This patch will add in the new MAC defines and fit it into the switch
cases throughout the driver.  New functionality and enablement support will
be added in following patches.

	Signed-off-by: Don Skidmore <donald.c.skidmore@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 9a75a1ac77fac4f63d7013c66c550fbf8e213715)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
#	drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
index 2f6b7c5a81ad,a507a6fe3624..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
@@@ -287,14 -282,14 +287,21 @@@ s32 ixgbe_dcb_hw_config(struct ixgbe_h
  
  	switch (hw->mac.type) {
  	case ixgbe_mac_82598EB:
 -		return ixgbe_dcb_hw_config_82598(hw, pfc_en, refill, max,
 -						 bwgid, ptype);
 +		ret = ixgbe_dcb_hw_config_82598(hw, pfc_en, refill, max,
 +						bwgid, ptype);
 +		break;
  	case ixgbe_mac_82599EB:
  	case ixgbe_mac_X540:
++<<<<<<< HEAD
 +		ret = ixgbe_dcb_hw_config_82599(hw, pfc_en, refill, max,
 +						bwgid, ptype, prio_tc);
 +		break;
++=======
+ 	case ixgbe_mac_X550:
+ 	case ixgbe_mac_X550EM_x:
+ 		return ixgbe_dcb_hw_config_82599(hw, pfc_en, refill, max,
+ 						 bwgid, ptype, prio_tc);
++>>>>>>> 9a75a1ac77fa (ixgbe: Add new support for X550 MAC's)
  	default:
  		break;
  	}
@@@ -304,16 -299,14 +311,22 @@@
  /* Helper routines to abstract HW specifics from DCB netlink ops */
  s32 ixgbe_dcb_hw_pfc_config(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc)
  {
 +	int ret = -EINVAL;
 +
  	switch (hw->mac.type) {
  	case ixgbe_mac_82598EB:
 -		return ixgbe_dcb_config_pfc_82598(hw, pfc_en);
 +		ret = ixgbe_dcb_config_pfc_82598(hw, pfc_en);
 +		break;
  	case ixgbe_mac_82599EB:
  	case ixgbe_mac_X540:
++<<<<<<< HEAD
 +		ret = ixgbe_dcb_config_pfc_82599(hw, pfc_en, prio_tc);
 +		break;
++=======
+ 	case ixgbe_mac_X550:
+ 	case ixgbe_mac_X550EM_x:
+ 		return ixgbe_dcb_config_pfc_82599(hw, pfc_en, prio_tc);
++>>>>>>> 9a75a1ac77fa (ixgbe: Add new support for X550 MAC's)
  	default:
  		break;
  	}
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
index 11b928034f56,26fd85e2bca5..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
@@@ -583,22 -602,55 +585,68 @@@ static void ixgbe_get_regs(struct net_d
  	regs_buff[828] = IXGBE_READ_REG(hw, IXGBE_FHFT(0));
  
  	/* DCB */
++<<<<<<< HEAD
 +	regs_buff[829] = IXGBE_READ_REG(hw, IXGBE_RMCS);
 +	regs_buff[830] = IXGBE_READ_REG(hw, IXGBE_DPMCS);
 +	regs_buff[831] = IXGBE_READ_REG(hw, IXGBE_PDPMCS);
 +	regs_buff[832] = IXGBE_READ_REG(hw, IXGBE_RUPPBMR);
++=======
+ 	regs_buff[829] = IXGBE_READ_REG(hw, IXGBE_RMCS);   /* same as FCCFG  */
+ 	regs_buff[831] = IXGBE_READ_REG(hw, IXGBE_PDPMCS); /* same as RTTPCS */
+ 
+ 	switch (hw->mac.type) {
+ 	case ixgbe_mac_82598EB:
+ 		regs_buff[830] = IXGBE_READ_REG(hw, IXGBE_DPMCS);
+ 		regs_buff[832] = IXGBE_READ_REG(hw, IXGBE_RUPPBMR);
+ 		for (i = 0; i < 8; i++)
+ 			regs_buff[833 + i] =
+ 				IXGBE_READ_REG(hw, IXGBE_RT2CR(i));
+ 		for (i = 0; i < 8; i++)
+ 			regs_buff[841 + i] =
+ 				IXGBE_READ_REG(hw, IXGBE_RT2SR(i));
+ 		for (i = 0; i < 8; i++)
+ 			regs_buff[849 + i] =
+ 				IXGBE_READ_REG(hw, IXGBE_TDTQ2TCCR(i));
+ 		for (i = 0; i < 8; i++)
+ 			regs_buff[857 + i] =
+ 				IXGBE_READ_REG(hw, IXGBE_TDTQ2TCSR(i));
+ 		break;
+ 	case ixgbe_mac_82599EB:
+ 	case ixgbe_mac_X540:
+ 	case ixgbe_mac_X550:
+ 	case ixgbe_mac_X550EM_x:
+ 		regs_buff[830] = IXGBE_READ_REG(hw, IXGBE_RTTDCS);
+ 		regs_buff[832] = IXGBE_READ_REG(hw, IXGBE_RTRPCS);
+ 		for (i = 0; i < 8; i++)
+ 			regs_buff[833 + i] =
+ 				IXGBE_READ_REG(hw, IXGBE_RTRPT4C(i));
+ 		for (i = 0; i < 8; i++)
+ 			regs_buff[841 + i] =
+ 				IXGBE_READ_REG(hw, IXGBE_RTRPT4S(i));
+ 		for (i = 0; i < 8; i++)
+ 			regs_buff[849 + i] =
+ 				IXGBE_READ_REG(hw, IXGBE_RTTDT2C(i));
+ 		for (i = 0; i < 8; i++)
+ 			regs_buff[857 + i] =
+ 				IXGBE_READ_REG(hw, IXGBE_RTTDT2S(i));
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
++>>>>>>> 9a75a1ac77fa (ixgbe: Add new support for X550 MAC's)
 +	for (i = 0; i < 8; i++)
 +		regs_buff[833 + i] = IXGBE_READ_REG(hw, IXGBE_RT2CR(i));
  	for (i = 0; i < 8; i++)
 -		regs_buff[865 + i] =
 -		IXGBE_READ_REG(hw, IXGBE_TDPT2TCCR(i)); /* same as RTTPT2C */
 +		regs_buff[841 + i] = IXGBE_READ_REG(hw, IXGBE_RT2SR(i));
  	for (i = 0; i < 8; i++)
 -		regs_buff[873 + i] =
 -		IXGBE_READ_REG(hw, IXGBE_TDPT2TCSR(i)); /* same as RTTPT2S */
 +		regs_buff[849 + i] = IXGBE_READ_REG(hw, IXGBE_TDTQ2TCCR(i));
 +	for (i = 0; i < 8; i++)
 +		regs_buff[857 + i] = IXGBE_READ_REG(hw, IXGBE_TDTQ2TCSR(i));
 +	for (i = 0; i < 8; i++)
 +		regs_buff[865 + i] = IXGBE_READ_REG(hw, IXGBE_TDPT2TCCR(i));
 +	for (i = 0; i < 8; i++)
 +		regs_buff[873 + i] = IXGBE_READ_REG(hw, IXGBE_TDPT2TCSR(i));
  
  	/* Statistics */
  	regs_buff[881] = IXGBE_GET_STAT(adapter, crcerrs);
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 9170c21882f9,355d1f79d274..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@@ -3714,8 -3679,14 +3736,10 @@@ static void ixgbe_vlan_strip_disable(st
  		break;
  	case ixgbe_mac_82599EB:
  	case ixgbe_mac_X540:
+ 	case ixgbe_mac_X550:
+ 	case ixgbe_mac_X550EM_x:
  		for (i = 0; i < adapter->num_rx_queues; i++) {
 -			struct ixgbe_ring *ring = adapter->rx_ring[i];
 -
 -			if (ring->l2_accel_priv)
 -				continue;
 -			j = ring->reg_idx;
 +			j = adapter->rx_ring[i]->reg_idx;
  			vlnctrl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(j));
  			vlnctrl &= ~IXGBE_RXDCTL_VME;
  			IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(j), vlnctrl);
@@@ -3744,8 -3715,14 +3768,10 @@@ static void ixgbe_vlan_strip_enable(str
  		break;
  	case ixgbe_mac_82599EB:
  	case ixgbe_mac_X540:
+ 	case ixgbe_mac_X550:
+ 	case ixgbe_mac_X550EM_x:
  		for (i = 0; i < adapter->num_rx_queues; i++) {
 -			struct ixgbe_ring *ring = adapter->rx_ring[i];
 -
 -			if (ring->l2_accel_priv)
 -				continue;
 -			j = ring->reg_idx;
 +			j = adapter->rx_ring[i]->reg_idx;
  			vlnctrl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(j));
  			vlnctrl |= IXGBE_RXDCTL_VME;
  			IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(j), vlnctrl);
@@@ -5873,6 -6248,50 +5925,53 @@@ static void ixgbe_watchdog_link_is_down
  	ixgbe_ping_all_vfs(adapter);
  }
  
++<<<<<<< HEAD
++=======
+ static bool ixgbe_ring_tx_pending(struct ixgbe_adapter *adapter)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < adapter->num_tx_queues; i++) {
+ 		struct ixgbe_ring *tx_ring = adapter->tx_ring[i];
+ 
+ 		if (tx_ring->next_to_use != tx_ring->next_to_clean)
+ 			return true;
+ 	}
+ 
+ 	return false;
+ }
+ 
+ static bool ixgbe_vf_tx_pending(struct ixgbe_adapter *adapter)
+ {
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	struct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];
+ 	u32 q_per_pool = __ALIGN_MASK(1, ~vmdq->mask);
+ 
+ 	int i, j;
+ 
+ 	if (!adapter->num_vfs)
+ 		return false;
+ 
+ 	/* resetting the PF is only needed for MAC before X550 */
+ 	if (hw->mac.type >= ixgbe_mac_X550)
+ 		return false;
+ 
+ 	for (i = 0; i < adapter->num_vfs; i++) {
+ 		for (j = 0; j < q_per_pool; j++) {
+ 			u32 h, t;
+ 
+ 			h = IXGBE_READ_REG(hw, IXGBE_PVFTDHN(q_per_pool, i, j));
+ 			t = IXGBE_READ_REG(hw, IXGBE_PVFTDTN(q_per_pool, i, j));
+ 
+ 			if (h != t)
+ 				return true;
+ 		}
+ 	}
+ 
+ 	return false;
+ }
+ 
++>>>>>>> 9a75a1ac77fa (ixgbe: Add new support for X550 MAC's)
  /**
   * ixgbe_watchdog_flush_tx - flush queues on link down
   * @adapter: pointer to the device adapter structure
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
index 994e3ba61aa8,dc97c03134ec..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
@@@ -627,9 -642,6 +634,12 @@@ s32 ixgbe_check_phy_link_tnx(struct ixg
   **/
  s32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw)
  {
++<<<<<<< HEAD
 +	s32 status = 0;
 +	u32 time_out;
 +	u32 max_time_out = 10;
++=======
++>>>>>>> 9a75a1ac77fa (ixgbe: Add new support for X550 MAC's)
  	u16 autoneg_reg = IXGBE_MII_AUTONEG_REG;
  	bool autoneg = false;
  	ixgbe_link_speed speed;
@@@ -691,25 -707,7 +701,29 @@@
  	hw->phy.ops.write_reg(hw, MDIO_CTRL1,
  			      MDIO_MMD_AN, autoneg_reg);
  
++<<<<<<< HEAD
 +	/* Wait for autonegotiation to finish */
 +	for (time_out = 0; time_out < max_time_out; time_out++) {
 +		udelay(10);
 +		/* Restart PHY autonegotiation and wait for completion */
 +		status = hw->phy.ops.read_reg(hw, MDIO_STAT1,
 +					      MDIO_MMD_AN,
 +					      &autoneg_reg);
 +
 +		autoneg_reg &= MDIO_AN_STAT1_COMPLETE;
 +		if (autoneg_reg == MDIO_AN_STAT1_COMPLETE)
 +			break;
 +	}
 +
 +	if (time_out == max_time_out) {
 +		status = IXGBE_ERR_LINK_SETUP;
 +		hw_dbg(hw, "ixgbe_setup_phy_link_tnx: time out");
 +	}
 +
 +	return status;
++=======
+ 	return 0;
++>>>>>>> 9a75a1ac77fa (ixgbe: Add new support for X550 MAC's)
  }
  
  /**
@@@ -1911,27 -1871,25 +1925,32 @@@ static void ixgbe_lower_i2c_clk(struct 
   **/
  static s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl, bool data)
  {
 +	s32 status = 0;
 +
  	if (data)
- 		*i2cctl |= IXGBE_I2C_DATA_OUT;
+ 		*i2cctl |= IXGBE_I2C_DATA_OUT_BY_MAC(hw);
  	else
- 		*i2cctl &= ~IXGBE_I2C_DATA_OUT;
+ 		*i2cctl &= ~IXGBE_I2C_DATA_OUT_BY_MAC(hw);
  
- 	IXGBE_WRITE_REG(hw, IXGBE_I2CCTL, *i2cctl);
+ 	IXGBE_WRITE_REG(hw, IXGBE_I2CCTL_BY_MAC(hw), *i2cctl);
  	IXGBE_WRITE_FLUSH(hw);
  
  	/* Data rise/fall (1000ns/300ns) and set-up time (250ns) */
  	udelay(IXGBE_I2C_T_RISE + IXGBE_I2C_T_FALL + IXGBE_I2C_T_SU_DATA);
  
  	/* Verify data was set correctly */
++<<<<<<< HEAD
 +	*i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL);
 +	if (data != ixgbe_get_i2c_data(i2cctl)) {
 +		status = IXGBE_ERR_I2C;
++=======
+ 	*i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL_BY_MAC(hw));
+ 	if (data != ixgbe_get_i2c_data(hw, i2cctl)) {
++>>>>>>> 9a75a1ac77fa (ixgbe: Add new support for X550 MAC's)
  		hw_dbg(hw, "Error - I2C data was not set to %X.\n", data);
 -		return IXGBE_ERR_I2C;
  	}
  
 -	return 0;
 +	return status;
  }
  
  /**
@@@ -1941,16 -1899,11 +1960,22 @@@
   *
   *  Returns the I2C data bit value
   **/
- static bool ixgbe_get_i2c_data(u32 *i2cctl)
+ static bool ixgbe_get_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl)
  {
++<<<<<<< HEAD
 +	bool data;
 +
 +	if (*i2cctl & IXGBE_I2C_DATA_IN)
 +		data = true;
 +	else
 +		data = false;
 +
 +	return data;
++=======
+ 	if (*i2cctl & IXGBE_I2C_DATA_IN_BY_MAC(hw))
+ 		return true;
+ 	return false;
++>>>>>>> 9a75a1ac77fa (ixgbe: Add new support for X550 MAC's)
  }
  
  /**
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
index b73e2c21aefe,04eee7c7b653..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
@@@ -1077,6 -1092,62 +1077,65 @@@ int ixgbe_ndo_set_vf_mac(struct net_dev
  	return ixgbe_set_vf_mac(adapter, vf, mac);
  }
  
++<<<<<<< HEAD
++=======
+ static int ixgbe_enable_port_vlan(struct ixgbe_adapter *adapter, int vf,
+ 				  u16 vlan, u8 qos)
+ {
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	int err = 0;
+ 
+ 	if (adapter->vfinfo[vf].pf_vlan)
+ 		err = ixgbe_set_vf_vlan(adapter, false,
+ 					adapter->vfinfo[vf].pf_vlan,
+ 					vf);
+ 	if (err)
+ 		goto out;
+ 	ixgbe_set_vmvir(adapter, vlan, qos, vf);
+ 	ixgbe_set_vmolr(hw, vf, false);
+ 	if (adapter->vfinfo[vf].spoofchk_enabled)
+ 		hw->mac.ops.set_vlan_anti_spoofing(hw, true, vf);
+ 	adapter->vfinfo[vf].vlan_count++;
+ 
+ 	/* enable hide vlan on X550 */
+ 	if (hw->mac.type >= ixgbe_mac_X550)
+ 		ixgbe_write_qde(adapter, vf, IXGBE_QDE_ENABLE |
+ 				IXGBE_QDE_HIDE_VLAN);
+ 
+ 	adapter->vfinfo[vf].pf_vlan = vlan;
+ 	adapter->vfinfo[vf].pf_qos = qos;
+ 	dev_info(&adapter->pdev->dev,
+ 		 "Setting VLAN %d, QOS 0x%x on VF %d\n", vlan, qos, vf);
+ 	if (test_bit(__IXGBE_DOWN, &adapter->state)) {
+ 		dev_warn(&adapter->pdev->dev,
+ 			 "The VF VLAN has been set, but the PF device is not up.\n");
+ 		dev_warn(&adapter->pdev->dev,
+ 			 "Bring the PF device up before attempting to use the VF device.\n");
+ 	}
+ 
+ out:
+ 	return err;
+ }
+ 
+ static int ixgbe_disable_port_vlan(struct ixgbe_adapter *adapter, int vf)
+ {
+ 	struct ixgbe_hw *hw = &adapter->hw;
+ 	int err;
+ 
+ 	err = ixgbe_set_vf_vlan(adapter, false,
+ 				adapter->vfinfo[vf].pf_vlan, vf);
+ 	ixgbe_clear_vmvir(adapter, vf);
+ 	ixgbe_set_vmolr(hw, vf, true);
+ 	hw->mac.ops.set_vlan_anti_spoofing(hw, false, vf);
+ 	if (adapter->vfinfo[vf].vlan_count)
+ 		adapter->vfinfo[vf].vlan_count--;
+ 	adapter->vfinfo[vf].pf_vlan = 0;
+ 	adapter->vfinfo[vf].pf_qos = 0;
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 9a75a1ac77fa (ixgbe: Add new support for X550 MAC's)
  int ixgbe_ndo_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos)
  {
  	int err = 0;
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
index 6c106e6e34c8,64de20d1de56..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
@@@ -1990,9 -2021,11 +2012,17 @@@ enum 
  #define IXGBE_FWSM_TS_ENABLED	0x1
  
  /* Queue Drop Enable */
++<<<<<<< HEAD
 +#define IXGBE_QDE_ENABLE     0x00000001
 +#define IXGBE_QDE_IDX_MASK   0x00007F00
 +#define IXGBE_QDE_IDX_SHIFT           8
++=======
+ #define IXGBE_QDE_ENABLE	0x00000001
+ #define IXGBE_QDE_HIDE_VLAN	0x00000002
+ #define IXGBE_QDE_IDX_MASK	0x00007F00
+ #define IXGBE_QDE_IDX_SHIFT	8
+ #define IXGBE_QDE_WRITE		0x00010000
++>>>>>>> 9a75a1ac77fa (ixgbe: Add new support for X550 MAC's)
  
  #define IXGBE_TXD_POPTS_IXSM 0x01       /* Insert IP checksum */
  #define IXGBE_TXD_POPTS_TXSM 0x02       /* Insert TCP/UDP checksum */
@@@ -2412,34 -2460,17 +2442,36 @@@ struct ixgbe_adv_tx_context_desc 
  typedef u32 ixgbe_autoneg_advertised;
  /* Link speed */
  typedef u32 ixgbe_link_speed;
- #define IXGBE_LINK_SPEED_UNKNOWN   0
- #define IXGBE_LINK_SPEED_100_FULL  0x0008
- #define IXGBE_LINK_SPEED_1GB_FULL  0x0020
- #define IXGBE_LINK_SPEED_10GB_FULL 0x0080
+ #define IXGBE_LINK_SPEED_UNKNOWN	0
+ #define IXGBE_LINK_SPEED_100_FULL	0x0008
+ #define IXGBE_LINK_SPEED_1GB_FULL	0x0020
+ #define IXGBE_LINK_SPEED_2_5GB_FULL	0x0400
+ #define IXGBE_LINK_SPEED_5GB_FULL	0x0800
+ #define IXGBE_LINK_SPEED_10GB_FULL	0x0080
  #define IXGBE_LINK_SPEED_82598_AUTONEG (IXGBE_LINK_SPEED_1GB_FULL | \
 -					IXGBE_LINK_SPEED_10GB_FULL)
 +                                        IXGBE_LINK_SPEED_10GB_FULL)
  #define IXGBE_LINK_SPEED_82599_AUTONEG (IXGBE_LINK_SPEED_100_FULL | \
 -					IXGBE_LINK_SPEED_1GB_FULL | \
 -					IXGBE_LINK_SPEED_10GB_FULL)
 +                                        IXGBE_LINK_SPEED_1GB_FULL | \
 +                                        IXGBE_LINK_SPEED_10GB_FULL)
 +
 +
 +/* Physical layer type */
 +typedef u32 ixgbe_physical_layer;
 +#define IXGBE_PHYSICAL_LAYER_UNKNOWN      0
 +#define IXGBE_PHYSICAL_LAYER_10GBASE_T    0x0001
 +#define IXGBE_PHYSICAL_LAYER_1000BASE_T   0x0002
 +#define IXGBE_PHYSICAL_LAYER_100BASE_TX   0x0004
 +#define IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU  0x0008
 +#define IXGBE_PHYSICAL_LAYER_10GBASE_LR   0x0010
 +#define IXGBE_PHYSICAL_LAYER_10GBASE_LRM  0x0020
 +#define IXGBE_PHYSICAL_LAYER_10GBASE_SR   0x0040
 +#define IXGBE_PHYSICAL_LAYER_10GBASE_KX4  0x0080
 +#define IXGBE_PHYSICAL_LAYER_10GBASE_CX4  0x0100
 +#define IXGBE_PHYSICAL_LAYER_1000BASE_KX  0x0200
 +#define IXGBE_PHYSICAL_LAYER_1000BASE_BX  0x0400
 +#define IXGBE_PHYSICAL_LAYER_10GBASE_KR   0x0800
 +#define IXGBE_PHYSICAL_LAYER_10GBASE_XAUI 0x1000
 +#define IXGBE_PHYSICAL_LAYER_SFP_ACTIVE_DA 0x2000
  
  /* Flow Control Data Sheet defined values
   * Calculation and defines taken from 802.1bb Annex O
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
index b74bcba8af7f..96c8958dda43 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
@@ -2897,6 +2897,8 @@ u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw)
 		break;
 	case ixgbe_mac_82599EB:
 	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
 		pcie_offset = IXGBE_PCIE_MSIX_82599_CAPS;
 		max_msix_count = IXGBE_MAX_MSIX_VECTORS_82599;
 		break;
@@ -3289,17 +3291,27 @@ s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
 			*link_up = false;
 	}
 
-	if ((links_reg & IXGBE_LINKS_SPEED_82599) ==
-	    IXGBE_LINKS_SPEED_10G_82599)
-		*speed = IXGBE_LINK_SPEED_10GB_FULL;
-	else if ((links_reg & IXGBE_LINKS_SPEED_82599) ==
-		 IXGBE_LINKS_SPEED_1G_82599)
+	switch (links_reg & IXGBE_LINKS_SPEED_82599) {
+	case IXGBE_LINKS_SPEED_10G_82599:
+		if ((hw->mac.type >= ixgbe_mac_X550) &&
+		    (links_reg & IXGBE_LINKS_SPEED_NON_STD))
+			*speed = IXGBE_LINK_SPEED_2_5GB_FULL;
+		else
+			*speed = IXGBE_LINK_SPEED_10GB_FULL;
+		break;
+	case IXGBE_LINKS_SPEED_1G_82599:
 		*speed = IXGBE_LINK_SPEED_1GB_FULL;
-	else if ((links_reg & IXGBE_LINKS_SPEED_82599) ==
-		 IXGBE_LINKS_SPEED_100_82599)
-		*speed = IXGBE_LINK_SPEED_100_FULL;
-	else
+		break;
+	case IXGBE_LINKS_SPEED_100_82599:
+		if ((hw->mac.type >= ixgbe_mac_X550) &&
+		    (links_reg & IXGBE_LINKS_SPEED_NON_STD))
+			*speed = IXGBE_LINK_SPEED_5GB_FULL;
+		else
+			*speed = IXGBE_LINK_SPEED_100_FULL;
+		break;
+	default:
 		*speed = IXGBE_LINK_SPEED_UNKNOWN;
+	}
 
 	return 0;
 }
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c
index edd89a1ef27f..4c60a130adb2 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c
@@ -183,6 +183,7 @@ static void ixgbe_dcbnl_get_perm_hw_addr(struct net_device *netdev,
 	switch (adapter->hw.mac.type) {
 	case ixgbe_mac_82599EB:
 	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
 		for (j = 0; j < netdev->addr_len; j++, i++)
 			perm_addr[i] = adapter->hw.mac.san_addr[j];
 		break;
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c
index 287cee79b331..dcd2d1ec635c 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c
@@ -126,6 +126,8 @@ static void ixgbe_get_first_reg_idx(struct ixgbe_adapter *adapter, u8 tc,
 		break;
 	case ixgbe_mac_82599EB:
 	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
 		if (num_tcs > 4) {
 			/*
 			 * TCs    : TC0/1 TC2/3 TC4-7
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
index f5c6af2b891b..db7873945789 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
@@ -318,6 +318,8 @@ static s32 ixgbe_check_for_rst_pf(struct ixgbe_hw *hw, u16 vf_number)
 		vflre = IXGBE_READ_REG(hw, IXGBE_VFLRE(reg_offset));
 		break;
 	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
 		vflre = IXGBE_READ_REG(hw, IXGBE_VFLREC(reg_offset));
 		break;
 	default:
@@ -443,6 +445,8 @@ void ixgbe_init_mbx_params_pf(struct ixgbe_hw *hw)
 	struct ixgbe_mbx_info *mbx = &hw->mbx;
 
 	if (hw->mac.type != ixgbe_mac_82599EB &&
+	    hw->mac.type != ixgbe_mac_X550 &&
+	    hw->mac.type != ixgbe_mac_X550EM_x &&
 	    hw->mac.type != ixgbe_mac_X540)
 		return;
 
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
