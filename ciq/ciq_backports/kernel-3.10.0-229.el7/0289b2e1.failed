blk-mq: bitmap tag: use clear_bit_unlock in bt_clear_tag()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [block] blk-mq: use clear_bit_unlock in bt_clear_tag() (Mike Snitzer) [1105204]
Rebuild_FUZZ: 88.46%
commit-author Ming Lei <tom.leiming@gmail.com>
commit 0289b2e110b7824b2f76d194ad6f8f0844e270ad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0289b2e1.failed

The unlock memory barrier need to order access to req in free
path and clearing tag bit, otherwise either request free path
may see a allocated request, or initialized request in allocate
path might be modified by the ongoing free path.

	Signed-off-by: Ming Lei <tom.leiming@gmail.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 0289b2e110b7824b2f76d194ad6f8f0844e270ad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq-tag.c
diff --cc block/blk-mq-tag.c
index 83ae96c51a27,a81b138e89fe..000000000000
--- a/block/blk-mq-tag.c
+++ b/block/blk-mq-tag.c
@@@ -68,6 -210,47 +68,50 @@@ unsigned int blk_mq_get_tag(struct blk_
  	return __blk_mq_get_reserved_tag(tags, gfp);
  }
  
++<<<<<<< HEAD
++=======
+ static struct bt_wait_state *bt_wake_ptr(struct blk_mq_bitmap_tags *bt)
+ {
+ 	int i, wake_index;
+ 
+ 	wake_index = bt->wake_index;
+ 	for (i = 0; i < BT_WAIT_QUEUES; i++) {
+ 		struct bt_wait_state *bs = &bt->bs[wake_index];
+ 
+ 		if (waitqueue_active(&bs->wait)) {
+ 			if (wake_index != bt->wake_index)
+ 				bt->wake_index = wake_index;
+ 
+ 			return bs;
+ 		}
+ 
+ 		bt_index_inc(&wake_index);
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static void bt_clear_tag(struct blk_mq_bitmap_tags *bt, unsigned int tag)
+ {
+ 	const int index = TAG_TO_INDEX(bt, tag);
+ 	struct bt_wait_state *bs;
+ 
+ 	/*
+ 	 * The unlock memory barrier need to order access to req in free
+ 	 * path and clearing tag bit
+ 	 */
+ 	clear_bit_unlock(TAG_TO_BIT(bt, tag), &bt->map[index].word);
+ 
+ 	bs = bt_wake_ptr(bt);
+ 	if (bs && atomic_dec_and_test(&bs->wait_cnt)) {
+ 		smp_mb__after_clear_bit();
+ 		atomic_set(&bs->wait_cnt, bt->wake_cnt);
+ 		bt_index_inc(&bt->wake_index);
+ 		wake_up(&bs->wait);
+ 	}
+ }
+ 
++>>>>>>> 0289b2e110b7 (blk-mq: bitmap tag: use clear_bit_unlock in bt_clear_tag())
  static void __blk_mq_put_tag(struct blk_mq_tags *tags, unsigned int tag)
  {
  	BUG_ON(tag >= tags->nr_tags);
* Unmerged path block/blk-mq-tag.c
