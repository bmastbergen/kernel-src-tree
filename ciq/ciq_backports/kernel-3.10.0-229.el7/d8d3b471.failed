cpufreq: Pass policy to cpufreq_add_policy_cpu()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Pass policy to cpufreq_add_policy_cpu() (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 89.66%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit d8d3b4711297e101bbad826474013edbe342c333
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d8d3b471.failed

The caller of cpufreq_add_policy_cpu() already has a pointer to the
policy structure and there is no need to look it up again in
cpufreq_add_policy_cpu().  Let's pass it directly.

	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit d8d3b4711297e101bbad826474013edbe342c333)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index ff27961af2ee,1faf320a5038..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -874,10 -897,10 +874,15 @@@ static void cpufreq_init_policy(struct 
  }
  
  #ifdef CONFIG_HOTPLUG_CPU
++<<<<<<< HEAD
 +static int cpufreq_add_policy_cpu(unsigned int cpu, unsigned int sibling,
 +				  struct device *dev)
++=======
+ static int cpufreq_add_policy_cpu(struct cpufreq_policy *policy,
+ 				  unsigned int cpu, struct device *dev,
+ 				  bool frozen)
++>>>>>>> d8d3b4711297 (cpufreq: Pass policy to cpufreq_add_policy_cpu())
  {
- 	struct cpufreq_policy *policy;
  	int ret = 0, has_target = !!cpufreq_driver->target;
  	unsigned long flags;
  
@@@ -904,9 -923,10 +905,8 @@@
  		__cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
  	}
  
 -	/* Don't touch sysfs links during light-weight init */
 -	if (!frozen)
 -		ret = sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");
 +	ret = sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");
  
- 	cpufreq_cpu_put(policy);
  	return ret;
  }
  #endif
@@@ -955,9 -1009,7 +955,13 @@@ static int cpufreq_add_dev(struct devic
  		struct cpufreq_policy *cp = per_cpu(cpufreq_cpu_data, sibling);
  		if (cp && cpumask_test_cpu(cpu, cp->related_cpus)) {
  			read_unlock_irqrestore(&cpufreq_driver_lock, flags);
++<<<<<<< HEAD
 +			ret = cpufreq_add_policy_cpu(cpu, sibling, dev);
 +			up_read(&cpufreq_rwsem);
 +			return ret;
++=======
+ 			return cpufreq_add_policy_cpu(cp, cpu, dev, frozen);
++>>>>>>> d8d3b4711297 (cpufreq: Pass policy to cpufreq_add_policy_cpu())
  		}
  	}
  	read_unlock_irqrestore(&cpufreq_driver_lock, flags);
* Unmerged path drivers/cpufreq/cpufreq.c
