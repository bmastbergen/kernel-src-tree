nfs: handle multiple reqs in nfs_page_async_flush

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Weston Andros Adamson <dros@primarydata.com>
commit d458138353726ea6dcbc53ae3597e489d0432c25
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d4581383.failed

Change nfs_find_and_lock_request so nfs_page_async_flush can handle multiple
requests in a page. There is only one request for a page the first time
nfs_page_async_flush is called, but if a write or commit fails, async_flush
is called again and there may be multiple requests associated with the page.
The solution is to merge all the requests in a page group into a single
request before calling nfs_pageio_add_request.

Rename nfs_find_and_lock_request to nfs_lock_and_join_requests and
change it to first lock all requests for the page, then cancel and merge
all subrequests into the head request.

	Signed-off-by: Weston Andros Adamson <dros@primarydata.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit d458138353726ea6dcbc53ae3597e489d0432c25)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/internal.h
#	fs/nfs/pagelist.c
#	fs/nfs/write.c
diff --cc fs/nfs/internal.h
index 96bd22580dbf,f415cbf9f6c3..000000000000
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@@ -238,6 -237,15 +238,18 @@@ extern void nfs_pgheader_init(struct nf
  void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
  int nfs_iocounter_wait(struct nfs_io_counter *c);
  
++<<<<<<< HEAD
++=======
+ extern const struct nfs_pageio_ops nfs_pgio_rw_ops;
+ struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *);
+ void nfs_rw_header_free(struct nfs_pgio_header *);
+ void nfs_pgio_data_release(struct nfs_pgio_data *);
+ int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
+ int nfs_initiate_pgio(struct rpc_clnt *, struct nfs_pgio_data *,
+ 		      const struct rpc_call_ops *, int, int);
+ void nfs_free_request(struct nfs_page *req);
+ 
++>>>>>>> d45813835372 (nfs: handle multiple reqs in nfs_page_async_flush)
  static inline void nfs_iocounter_init(struct nfs_io_counter *c)
  {
  	c->flags = 0;
diff --cc fs/nfs/pagelist.c
index 3e37cab99ceb,0aefc8102b6b..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -24,9 -24,12 +24,13 @@@
  #include "internal.h"
  #include "pnfs.h"
  
 -#define NFSDBG_FACILITY		NFSDBG_PAGECACHE
 -
  static struct kmem_cache *nfs_page_cachep;
 -static const struct rpc_call_ops nfs_pgio_common_ops;
  
++<<<<<<< HEAD
 +bool nfs_pgarray_set(struct nfs_page_array *p, unsigned int pagecount)
++=======
+ static bool nfs_pgarray_set(struct nfs_page_array *p, unsigned int pagecount)
++>>>>>>> d45813835372 (nfs: handle multiple reqs in nfs_page_async_flush)
  {
  	p->npages = pagecount;
  	if (pagecount <= ARRAY_SIZE(p->page_array))
@@@ -242,9 -404,16 +246,13 @@@ static void nfs_clear_request(struct nf
   *
   * Note: Should never be called with the spinlock held!
   */
++<<<<<<< HEAD
 +static void nfs_free_request(struct kref *kref)
++=======
+ void nfs_free_request(struct nfs_page *req)
++>>>>>>> d45813835372 (nfs: handle multiple reqs in nfs_page_async_flush)
  {
 -	WARN_ON_ONCE(req->wb_this_page != req);
 -
 -	/* extra debug: make sure no sync bits are still set */
 -	WARN_ON_ONCE(test_bit(PG_TEARDOWN, &req->wb_flags));
 -	WARN_ON_ONCE(test_bit(PG_UNLOCKPAGE, &req->wb_flags));
 -	WARN_ON_ONCE(test_bit(PG_UPTODATE, &req->wb_flags));
 -	WARN_ON_ONCE(test_bit(PG_WB_END, &req->wb_flags));
 -	WARN_ON_ONCE(test_bit(PG_REMOVE, &req->wb_flags));
 +	struct nfs_page *req = container_of(kref, struct nfs_page, wb_kref);
  
  	/* Release struct file and open context */
  	nfs_clear_request(req);
diff --cc fs/nfs/write.c
index a89cdd72f163,9f4424c464a0..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -46,6 -45,8 +46,11 @@@ static const struct rpc_call_ops nfs_wr
  static const struct rpc_call_ops nfs_commit_ops;
  static const struct nfs_pgio_completion_ops nfs_async_write_completion_ops;
  static const struct nfs_commit_completion_ops nfs_commit_completion_ops;
++<<<<<<< HEAD
++=======
+ static const struct nfs_rw_ops nfs_rw_write_ops;
+ static void nfs_clear_request_commit(struct nfs_page *req);
++>>>>>>> d45813835372 (nfs: handle multiple reqs in nfs_page_async_flush)
  
  static struct kmem_cache *nfs_wdata_cachep;
  static mempool_t *nfs_wdata_mempool;
* Unmerged path fs/nfs/internal.h
* Unmerged path fs/nfs/pagelist.c
* Unmerged path fs/nfs/write.c
