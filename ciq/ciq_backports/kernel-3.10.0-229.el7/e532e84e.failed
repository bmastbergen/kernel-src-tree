ACPI / hotplug / PCI: Use _OST to notify firmware about notify status

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Use _OST to notify firmware about notify status (Myron Stowe) [1114228]
Rebuild_FUZZ: 93.02%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit e532e84ea11399a6066f31641425a76dd012ce77
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e532e84e.failed

The spec suggests that we should use _OST to notify the platform
about the status of notifications it sends us, for example so that
it doesn't repeate a notification that has been handled already.

This turns out to help reduce the amount of diagnostic output from
the ACPIPHP subsystem and speed up boot on at least one system that
generates multiple device check notifies for PCIe devices on the root
bus during boot.

Reported-and-tested-by: Alex Williamson <alex.williamson@redhat.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit e532e84ea11399a6066f31641425a76dd012ce77)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index d210006fa4ad,1971d2943de4..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -1021,144 -849,92 +1021,201 @@@ static void _handle_hotplug_event_bridg
  
  	case ACPI_NOTIFY_EJECT_REQUEST:
  		/* request device eject */
 -		dbg("%s: Device eject notify on %s\n", __func__, objname);
 -		acpiphp_disable_and_eject_slot(func->slot);
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {
 +			struct acpiphp_slot *slot;
 +			slot = bridge->func->slot;
 +			if (!acpiphp_disable_slot(slot))
 +				acpiphp_eject_slot(slot);
 +		}
  		break;
 -	}
  
 -	if (bridge)
 -		put_bridge(bridge);
 -}
 +	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
 +		printk(KERN_ERR "Device %s cannot be configured due"
 +				" to a frequency mismatch\n", objname);
 +		break;
  
 -static void hotplug_event_work(struct work_struct *work)
 -{
 -	struct acpiphp_context *context;
 -	struct acpi_hp_work *hp_work;
 +	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
 +		printk(KERN_ERR "Device %s cannot be configured due"
 +				" to a bus mode mismatch\n", objname);
 +		break;
  
 -	hp_work = container_of(work, struct acpi_hp_work, work);
 -	context = hp_work->context;
 -	acpi_scan_lock_acquire();
 +	case ACPI_NOTIFY_POWER_FAULT:
 +		printk(KERN_ERR "Device %s has suffered a power fault\n",
 +				objname);
 +		break;
  
 -	hotplug_event(hp_work->handle, hp_work->type, context);
 +	default:
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
 +		break;
 +	}
  
  	acpi_scan_lock_release();
++<<<<<<< HEAD
 +	kfree(hp_work); /* allocated in handle_hotplug_event_bridge */
 +	put_bridge(bridge);
++=======
+ 	acpi_evaluate_hotplug_ost(hp_work->handle, hp_work->type,
+ 				  ACPI_OST_SC_SUCCESS, NULL);
+ 	kfree(hp_work); /* allocated in handle_hotplug_event() */
+ 	put_bridge(context->func.parent);
++>>>>>>> e532e84ea113 (ACPI / hotplug / PCI: Use _OST to notify firmware about notify status)
  }
  
  /**
 - * handle_hotplug_event - handle ACPI hotplug event
 + * handle_hotplug_event_bridge - handle ACPI event on bridges
   * @handle: Notify()'ed acpi_handle
   * @type: Notify code
 - * @data: pointer to acpiphp_context structure
 + * @context: pointer to acpiphp_bridge structure
   *
 - * Handles ACPI event notification on slots.
 + * Handles ACPI event notification on {host,p2p} bridges.
   */
 -static void handle_hotplug_event(acpi_handle handle, u32 type, void *data)
 +static void handle_hotplug_event_bridge(acpi_handle handle, u32 type,
 +					void *context)
  {
++<<<<<<< HEAD
 +	struct acpiphp_bridge *bridge = context;
 +
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_bridge);
 +}
 +
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context)
 +{
 +	struct acpiphp_func *func = context;
 +	char objname[64];
 +	struct acpi_buffer buffer = { .length = sizeof(objname),
 +				      .pointer = objname };
 +
 +	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
++=======
+ 	struct acpiphp_context *context;
+ 	u32 ost_code = ACPI_OST_SC_SUCCESS;
++>>>>>>> e532e84ea113 (ACPI / hotplug / PCI: Use _OST to notify firmware about notify status)
  
  	switch (type) {
  	case ACPI_NOTIFY_BUS_CHECK:
 +		/* bus re-enumerate */
 +		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
 +		acpiphp_enable_slot(func->slot);
 +		break;
 +
  	case ACPI_NOTIFY_DEVICE_CHECK:
++<<<<<<< HEAD
 +		/* device check : re-enumerate from parent bus */
 +		pr_debug("%s: Device check notify on %s\n", __func__, objname);
 +		acpiphp_check_bridge(func->slot->bridge);
++=======
+ 		break;
+ 	case ACPI_NOTIFY_EJECT_REQUEST:
+ 		ost_code = ACPI_OST_SC_EJECT_IN_PROGRESS;
+ 		acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
++>>>>>>> e532e84ea113 (ACPI / hotplug / PCI: Use _OST to notify firmware about notify status)
  		break;
  
  	case ACPI_NOTIFY_DEVICE_WAKE:
 -		return;
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
 +		break;
 +
++<<<<<<< HEAD
 +	case ACPI_NOTIFY_EJECT_REQUEST:
 +		/* request device eject */
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if (!(acpiphp_disable_slot(func->slot)))
 +			acpiphp_eject_slot(func->slot);
 +		break;
  
 +	default:
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
 +		break;
++=======
+ 	case ACPI_NOTIFY_FREQUENCY_MISMATCH:
+ 		acpi_handle_err(handle, "Device cannot be configured due "
+ 				"to a frequency mismatch\n");
+ 		goto out;
+ 
+ 	case ACPI_NOTIFY_BUS_MODE_MISMATCH:
+ 		acpi_handle_err(handle, "Device cannot be configured due "
+ 				"to a bus mode mismatch\n");
+ 		goto out;
+ 
+ 	case ACPI_NOTIFY_POWER_FAULT:
+ 		acpi_handle_err(handle, "Device has suffered a power fault\n");
+ 		goto out;
+ 
+ 	default:
+ 		acpi_handle_warn(handle, "Unsupported event type 0x%x\n", type);
+ 		ost_code = ACPI_OST_SC_UNRECOGNIZED_NOTIFY;
+ 		goto out;
++>>>>>>> e532e84ea113 (ACPI / hotplug / PCI: Use _OST to notify firmware about notify status)
  	}
 +}
 +
++<<<<<<< HEAD
 +static void _handle_hotplug_event_func(struct work_struct *work)
 +{
 +	struct acpi_hp_work *hp_work;
 +	struct acpiphp_func *func;
 +
 +	hp_work = container_of(work, struct acpi_hp_work, work);
 +	func = hp_work->context;
 +	acpi_scan_lock_acquire();
 +
 +	hotplug_event_func(hp_work->handle, hp_work->type, func);
 +
 +	acpi_scan_lock_release();
 +	kfree(hp_work); /* allocated in handle_hotplug_event_func */
 +	put_bridge(func->slot->bridge);
 +}
  
 +/**
 + * handle_hotplug_event_func - handle ACPI event on functions (i.e. slots)
 + * @handle: Notify()'ed acpi_handle
 + * @type: Notify code
 + * @context: pointer to acpiphp_func structure
 + *
 + * Handles ACPI event notification on slots.
 + */
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type,
 +				      void *context)
 +{
 +	struct acpiphp_func *func = context;
 +
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(func->slot->bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_func);
++=======
+ 	mutex_lock(&acpiphp_context_lock);
+ 	context = acpiphp_get_context(handle);
+ 	if (context) {
+ 		get_bridge(context->func.parent);
+ 		acpiphp_put_context(context);
+ 		alloc_acpi_hp_work(handle, type, context, hotplug_event_work);
+ 		mutex_unlock(&acpiphp_context_lock);
+ 		return;
+ 	}
+ 	mutex_unlock(&acpiphp_context_lock);
+ 	ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
+ 
+  out:
+ 	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
++>>>>>>> e532e84ea113 (ACPI / hotplug / PCI: Use _OST to notify firmware about notify status)
  }
  
  /*
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
