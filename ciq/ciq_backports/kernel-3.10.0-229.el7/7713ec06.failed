iommu/vt-d: Fix error handling in ANDD processing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Fix error handling in ANDD processing (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 93.48%
commit-author David Woodhouse <David.Woodhouse@intel.com>
commit 7713ec066ae8adc49dd8daa02a73e6b60af6ee5f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/7713ec06.failed

If we failed to find an ACPI device to correspond to an ANDD record, we
would fail to increment our pointer and would just process the same record
over and over again, with predictable results.

Turn it from a while() loop into a for() loop to let the 'continue' in
the error paths work correctly.

	Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
(cherry picked from commit 7713ec066ae8adc49dd8daa02a73e6b60af6ee5f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/dmar.c
diff --cc drivers/iommu/dmar.c
index e2ae85c4b46e,f445c10df8df..000000000000
--- a/drivers/iommu/dmar.c
+++ b/drivers/iommu/dmar.c
@@@ -457,10 -603,89 +457,90 @@@ dmar_find_matched_drhd_unit(struct pci_
  
  		if (dmar_pci_device_match(dmaru->devices,
  					  dmaru->devices_cnt, dev))
 -			goto out;
 +			return dmaru;
  	}
 -	dmaru = NULL;
 -out:
 -	rcu_read_unlock();
  
++<<<<<<< HEAD
 +	return NULL;
++=======
+ 	return dmaru;
+ }
+ 
+ static void __init dmar_acpi_insert_dev_scope(u8 device_number,
+ 					      struct acpi_device *adev)
+ {
+ 	struct dmar_drhd_unit *dmaru;
+ 	struct acpi_dmar_hardware_unit *drhd;
+ 	struct acpi_dmar_device_scope *scope;
+ 	struct device *tmp;
+ 	int i;
+ 	struct acpi_dmar_pci_path *path;
+ 
+ 	for_each_drhd_unit(dmaru) {
+ 		drhd = container_of(dmaru->hdr,
+ 				    struct acpi_dmar_hardware_unit,
+ 				    header);
+ 
+ 		for (scope = (void *)(drhd + 1);
+ 		     (unsigned long)scope < ((unsigned long)drhd) + drhd->header.length;
+ 		     scope = ((void *)scope) + scope->length) {
+ 			if (scope->entry_type != ACPI_DMAR_SCOPE_TYPE_ACPI)
+ 				continue;
+ 			if (scope->enumeration_id != device_number)
+ 				continue;
+ 
+ 			path = (void *)(scope + 1);
+ 			pr_info("ACPI device \"%s\" under DMAR at %llx as %02x:%02x.%d\n",
+ 				dev_name(&adev->dev), dmaru->reg_base_addr,
+ 				scope->bus, path->device, path->function);
+ 			for_each_dev_scope(dmaru->devices, dmaru->devices_cnt, i, tmp)
+ 				if (tmp == NULL) {
+ 					dmaru->devices[i].bus = scope->bus;
+ 					dmaru->devices[i].devfn = PCI_DEVFN(path->device,
+ 									    path->function);
+ 					rcu_assign_pointer(dmaru->devices[i].dev,
+ 							   get_device(&adev->dev));
+ 					return;
+ 				}
+ 			BUG_ON(i >= dmaru->devices_cnt);
+ 		}
+ 	}
+ 	pr_warn("No IOMMU scope found for ANDD enumeration ID %d (%s)\n",
+ 		device_number, dev_name(&adev->dev));
+ }
+ 
+ static int __init dmar_acpi_dev_scope_init(void)
+ {
+ 	struct acpi_dmar_andd *andd;
+ 
+ 	if (dmar_tbl == NULL)
+ 		return -ENODEV;
+ 
+ 	for (andd = (void *)dmar_tbl + sizeof(struct acpi_table_dmar);
+ 	     ((unsigned long)andd) < ((unsigned long)dmar_tbl) + dmar_tbl->length;
+ 	     andd = ((void *)andd) + andd->header.length) {
+ 		if (andd->header.type == ACPI_DMAR_TYPE_ANDD) {
+ 			acpi_handle h;
+ 			struct acpi_device *adev;
+ 
+ 			if (!ACPI_SUCCESS(acpi_get_handle(ACPI_ROOT_OBJECT,
+ 							  andd->object_name,
+ 							  &h))) {
+ 				pr_err("Failed to find handle for ACPI object %s\n",
+ 				       andd->object_name);
+ 				continue;
+ 			}
+ 			acpi_bus_get_device(h, &adev);
+ 			if (!adev) {
+ 				pr_err("Failed to get device for ACPI object %s\n",
+ 				       andd->object_name);
+ 				continue;
+ 			}
+ 			dmar_acpi_insert_dev_scope(andd->device_number, adev);
+ 		}
+ 	}
+ 	return 0;
++>>>>>>> 7713ec066ae8 (iommu/vt-d: Fix error handling in ANDD processing)
  }
  
  int __init dmar_dev_scope_init(void)
* Unmerged path drivers/iommu/dmar.c
