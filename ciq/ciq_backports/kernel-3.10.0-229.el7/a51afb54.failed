NVMe: Fix nvme get/put queue semantics

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Keith Busch <keith.busch@intel.com>
commit a51afb54339c5e9ee72df66ae0f2ac5aacfed365
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a51afb54.failed

The routines to get and lock nvme queues required the caller to "put"
or "unlock" them even if getting one returned NULL. This patch fixes that.

	Signed-off-by: Keith Busch <keith.busch@intel.com>
	Signed-off-by: Matthew Wilcox <matthew.r.wilcox@intel.com>
(cherry picked from commit a51afb54339c5e9ee72df66ae0f2ac5aacfed365)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/nvme-core.c
diff --cc drivers/block/nvme-core.c
index 4f8521eb298a,29a3e85873b5..000000000000
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@@ -265,14 -278,49 +265,53 @@@ static void *cancel_cmdid(struct nvme_q
  	return ctx;
  }
  
 -static struct nvme_queue *raw_nvmeq(struct nvme_dev *dev, int qid)
 +struct nvme_queue *get_nvmeq(struct nvme_dev *dev)
  {
 -	return rcu_dereference_raw(dev->queues[qid]);
 +	return dev->queues[get_cpu() + 1];
  }
  
 -static struct nvme_queue *get_nvmeq(struct nvme_dev *dev) __acquires(RCU)
 +void put_nvmeq(struct nvme_queue *nvmeq)
  {
++<<<<<<< HEAD
 +	put_cpu();
++=======
+ 	struct nvme_queue *nvmeq;
+ 	unsigned queue_id = get_cpu_var(*dev->io_queue);
+ 
+ 	rcu_read_lock();
+ 	nvmeq = rcu_dereference(dev->queues[queue_id]);
+ 	if (nvmeq)
+ 		return nvmeq;
+ 
+ 	rcu_read_unlock();
+ 	put_cpu_var(*dev->io_queue);
+ 	return NULL;
+ }
+ 
+ static void put_nvmeq(struct nvme_queue *nvmeq) __releases(RCU)
+ {
+ 	rcu_read_unlock();
+ 	put_cpu_var(nvmeq->dev->io_queue);
+ }
+ 
+ static struct nvme_queue *lock_nvmeq(struct nvme_dev *dev, int q_idx)
+ 							__acquires(RCU)
+ {
+ 	struct nvme_queue *nvmeq;
+ 
+ 	rcu_read_lock();
+ 	nvmeq = rcu_dereference(dev->queues[q_idx]);
+ 	if (nvmeq)
+ 		return nvmeq;
+ 
+ 	rcu_read_unlock();
+ 	return NULL;
+ }
+ 
+ static void unlock_nvmeq(struct nvme_queue *nvmeq) __releases(RCU)
+ {
+ 	rcu_read_unlock();
++>>>>>>> a51afb54339c (NVMe: Fix nvme get/put queue semantics)
  }
  
  /**
@@@ -889,11 -889,17 +927,19 @@@ static void sync_completion(struct nvme
   * Returns 0 on success.  If the result is negative, it's a Linux error code;
   * if the result is positive, it's an NVM Express status code
   */
 -static int nvme_submit_sync_cmd(struct nvme_dev *dev, int q_idx,
 -						struct nvme_command *cmd,
 +int nvme_submit_sync_cmd(struct nvme_queue *nvmeq, struct nvme_command *cmd,
  						u32 *result, unsigned timeout)
  {
 -	int cmdid, ret;
 +	int cmdid;
  	struct sync_cmd_info cmdinfo;
++<<<<<<< HEAD
++=======
+ 	struct nvme_queue *nvmeq;
+ 
+ 	nvmeq = lock_nvmeq(dev, q_idx);
+ 	if (!nvmeq)
+ 		return -ENODEV;
++>>>>>>> a51afb54339c (NVMe: Fix nvme get/put queue semantics)
  
  	cmdinfo.task = current;
  	cmdinfo.status = -EINTR;
@@@ -909,7 -923,11 +955,15 @@@
  	schedule_timeout(timeout);
  
  	if (cmdinfo.status == -EINTR) {
++<<<<<<< HEAD
 +		nvme_abort_command(nvmeq, cmdid);
++=======
+ 		nvmeq = lock_nvmeq(dev, q_idx);
+ 		if (nvmeq) {
+ 			nvme_abort_command(nvmeq, cmdid);
+ 			unlock_nvmeq(nvmeq);
+ 		}
++>>>>>>> a51afb54339c (NVMe: Fix nvme get/put queue semantics)
  		return -EINTR;
  	}
  
* Unmerged path drivers/block/nvme-core.c
