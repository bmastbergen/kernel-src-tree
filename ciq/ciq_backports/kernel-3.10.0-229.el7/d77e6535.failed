libiscsi, iser: Adjust data_length to include protection information

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [infiniband] iser: Adjust data_length to include protection information (Amir Vadai) [1107622]
Rebuild_FUZZ: 92.06%
commit-author Sagi Grimberg <sagig@mellanox.com>
commit d77e65350f2d82dfa0557707d505711f5a43c8fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d77e6535.failed

In case protection information exists over the wire
iscsi header data length is required to include it.
Use protection information aware scsi helpers to set
the correct transfer length.

In order to avoid breakage, remove iser transfer length
checks for each task as they are not always true and
somewhat redundant anyway.

	Signed-off-by: Sagi Grimberg <sagig@mellanox.com>
	Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
	Acked-by: Mike Christie <michaelc@cs.wisc.edu>
	Cc: stable@vger.kernel.org # 3.15+
	Signed-off-by: Nicholas Bellinger <nab@linux-iscsi.org>
(cherry picked from commit d77e65350f2d82dfa0557707d505711f5a43c8fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/ulp/iser/iser_initiator.c
diff --cc drivers/infiniband/ulp/iser/iser_initiator.c
index 4f1fe70f000f,8d44a4060634..000000000000
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@@ -73,14 -73,6 +73,17 @@@ static int iser_prepare_read_cmd(struc
  			return err;
  	}
  
++<<<<<<< HEAD
 +	if (edtl > iser_task->data[ISER_DIR_IN].data_len) {
 +		iser_err("Total data length: %ld, less than EDTL: "
 +			 "%d, in READ cmd BHS itt: %d, conn: 0x%p\n",
 +			 iser_task->data[ISER_DIR_IN].data_len, edtl,
 +			 task->itt, iser_task->iser_conn);
 +		return -EINVAL;
 +	}
 +
++=======
++>>>>>>> d77e65350f2d (libiscsi, iser: Adjust data_length to include protection information)
  	err = device->iser_reg_rdma_mem(iser_task, ISER_DIR_IN);
  	if (err) {
  		iser_err("Failed to set up Data-IN RDMA\n");
* Unmerged path drivers/infiniband/ulp/iser/iser_initiator.c
diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c
index 2194d9022944..6d9989e75c9a 100644
--- a/drivers/scsi/libiscsi.c
+++ b/drivers/scsi/libiscsi.c
@@ -346,7 +346,7 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 	struct iscsi_session *session = conn->session;
 	struct scsi_cmnd *sc = task->sc;
 	struct iscsi_scsi_req *hdr;
-	unsigned hdrlength, cmd_len;
+	unsigned hdrlength, cmd_len, transfer_length;
 	itt_t itt;
 	int rc;
 
@@ -399,11 +399,11 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 	if (scsi_get_prot_op(sc) != SCSI_PROT_NORMAL)
 		task->protected = true;
 
+	transfer_length = scsi_transfer_length(sc);
+	hdr->data_length = cpu_to_be32(transfer_length);
 	if (sc->sc_data_direction == DMA_TO_DEVICE) {
-		unsigned out_len = scsi_out(sc)->length;
 		struct iscsi_r2t_info *r2t = &task->unsol_r2t;
 
-		hdr->data_length = cpu_to_be32(out_len);
 		hdr->flags |= ISCSI_FLAG_CMD_WRITE;
 		/*
 		 * Write counters:
@@ -422,18 +422,19 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 		memset(r2t, 0, sizeof(*r2t));
 
 		if (session->imm_data_en) {
-			if (out_len >= session->first_burst)
+			if (transfer_length >= session->first_burst)
 				task->imm_count = min(session->first_burst,
 							conn->max_xmit_dlength);
 			else
-				task->imm_count = min(out_len,
-							conn->max_xmit_dlength);
+				task->imm_count = min(transfer_length,
+						      conn->max_xmit_dlength);
 			hton24(hdr->dlength, task->imm_count);
 		} else
 			zero_data(hdr->dlength);
 
 		if (!session->initial_r2t_en) {
-			r2t->data_length = min(session->first_burst, out_len) -
+			r2t->data_length = min(session->first_burst,
+					       transfer_length) -
 					       task->imm_count;
 			r2t->data_offset = task->imm_count;
 			r2t->ttt = cpu_to_be32(ISCSI_RESERVED_TAG);
@@ -446,7 +447,6 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 	} else {
 		hdr->flags |= ISCSI_FLAG_CMD_FINAL;
 		zero_data(hdr->dlength);
-		hdr->data_length = cpu_to_be32(scsi_in(sc)->length);
 
 		if (sc->sc_data_direction == DMA_FROM_DEVICE)
 			hdr->flags |= ISCSI_FLAG_CMD_READ;
@@ -474,7 +474,7 @@ static int iscsi_prep_scsi_cmd_pdu(struct iscsi_task *task)
 			  scsi_bidi_cmnd(sc) ? "bidirectional" :
 			  sc->sc_data_direction == DMA_TO_DEVICE ?
 			  "write" : "read", conn->id, sc, sc->cmnd[0],
-			  task->itt, scsi_bufflen(sc),
+			  task->itt, transfer_length,
 			  scsi_bidi_cmnd(sc) ? scsi_in(sc)->length : 0,
 			  session->cmdsn,
 			  session->max_cmdsn - session->exp_cmdsn + 1);
