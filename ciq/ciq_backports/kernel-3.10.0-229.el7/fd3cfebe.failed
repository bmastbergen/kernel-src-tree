ACPI / hotplug / PCI: Drop WARN_ON() from acpiphp_enumerate_slots()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Drop WARN_ON() from acpiphp_enumerate_slots() (Myron Stowe) [1114228]
Rebuild_FUZZ: 92.80%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit fd3cfebec3199bb89acead236b1ab12c349ed4e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/fd3cfebe.failed

The WARN_ON() in acpiphp_enumerate_slots() triggers unnecessarily for
devices whose bridges are going to be handled by native PCIe hotplug
(pciehp) and the simplest way to prevent that from happening is to
drop the WARN_ON().

References: https://bugzilla.kernel.org/show_bug.cgi?id=62831
	Reported-by: Steven Rostedt <rostedt@goodmis.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit fd3cfebec3199bb89acead236b1ab12c349ed4e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index d210006fa4ad,be12fbfcae10..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -1195,15 -989,44 +1195,41 @@@ void acpiphp_enumerate_slots(struct pci
  	 */
  	get_device(&bus->dev);
  
++<<<<<<< HEAD
 +	if (!pci_is_root_bus(bridge->pci_bus) &&
 +	    ACPI_SUCCESS(acpi_get_handle(bridge->handle,
 +					"_EJ0", &dummy_handle))) {
 +		pr_debug("found ejectable p2p bridge\n");
 +		bridge->flags |= BRIDGE_HAS_EJ0;
 +		bridge->func = acpiphp_bridge_handle_to_function(handle);
++=======
+ 	if (!pci_is_root_bus(bridge->pci_bus)) {
+ 		struct acpiphp_context *context;
+ 
+ 		/*
+ 		 * This bridge should have been registered as a hotplug function
+ 		 * under its parent, so the context should be there, unless the
+ 		 * parent is going to be handled by pciehp, in which case this
+ 		 * bridge is not interesting to us either.
+ 		 */
+ 		mutex_lock(&acpiphp_context_lock);
+ 		context = acpiphp_get_context(handle);
+ 		if (!context) {
+ 			mutex_unlock(&acpiphp_context_lock);
+ 			put_device(&bus->dev);
+ 			pci_dev_put(bridge->pci_dev);
+ 			kfree(bridge);
+ 			return;
+ 		}
+ 		bridge->context = context;
+ 		context->bridge = bridge;
+ 		/* Get a reference to the parent bridge. */
+ 		get_bridge(context->func.parent);
+ 		mutex_unlock(&acpiphp_context_lock);
++>>>>>>> fd3cfebec319 (ACPI / hotplug / PCI: Drop WARN_ON() from acpiphp_enumerate_slots())
  	}
  
 -	/* must be added to the list prior to calling register_slot */
 -	mutex_lock(&bridge_mutex);
 -	list_add(&bridge->list, &bridge_list);
 -	mutex_unlock(&bridge_mutex);
 -
 -	/* register all slot objects under this bridge */
 -	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
 -				     register_slot, NULL, bridge, NULL);
 -	if (ACPI_FAILURE(status)) {
 -		acpi_handle_err(handle, "failed to register slots\n");
 -		cleanup_bridge(bridge);
 -		put_bridge(bridge);
 -	}
 +	init_bridge_misc(bridge);
  }
  
  /* Destroy hotplug slots associated with the PCI bus */
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
