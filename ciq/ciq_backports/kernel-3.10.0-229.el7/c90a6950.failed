uprobes/x86: Simplify riprel_{pre,post}_xol() and make them similar

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [kernel] uprobes: Simplify riprel_{pre,post}_xol() and make them similar (Oleg Nesterov) [1073627]
Rebuild_FUZZ: 96.92%
commit-author Oleg Nesterov <oleg@redhat.com>
commit c90a6950120a7e45f31a22653fe6543507ae64d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/c90a6950.failed

Ignoring the "correction" logic riprel_pre_xol() and riprel_post_xol()
are very similar but look quite differently.

1. Add the "UPROBE_FIX_RIP_AX | UPROBE_FIX_RIP_CX" check at the start
   of riprel_pre_xol(), like the same check in riprel_post_xol().

2. Add the trivial scratch_reg() helper which returns the address of
   scratch register pre_xol/post_xol need to change.

3. Change these functions to use the new helper and avoid copy-and-paste
   under if/else branches.

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Acked-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
(cherry picked from commit c90a6950120a7e45f31a22653fe6543507ae64d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/uprobes.c
diff --cc arch/x86/kernel/uprobes.c
index 99569dc5b83d,2ebadb252093..000000000000
--- a/arch/x86/kernel/uprobes.c
+++ b/arch/x86/kernel/uprobes.c
@@@ -331,33 -336,25 +337,49 @@@ scratch_reg(struct arch_uprobe *auprobe
   * If we're emulating a rip-relative instruction, save the contents
   * of the scratch register and store the target address in that register.
   */
 -static void riprel_pre_xol(struct arch_uprobe *auprobe, struct pt_regs *regs)
 -{
 +static void
 +pre_xol_rip_insn(struct arch_uprobe *auprobe, struct pt_regs *regs,
 +				struct arch_uprobe_task *autask)
 +{
++<<<<<<< HEAD
 +	if (auprobe->fixups & UPROBE_FIX_RIP_AX) {
 +		autask->saved_scratch_register = regs->ax;
 +		regs->ax = current->utask->vaddr;
 +		regs->ax += auprobe->rip_rela_target_address;
 +	} else if (auprobe->fixups & UPROBE_FIX_RIP_CX) {
 +		autask->saved_scratch_register = regs->cx;
 +		regs->cx = current->utask->vaddr;
 +		regs->cx += auprobe->rip_rela_target_address;
++=======
+ 	if (auprobe->def.fixups & (UPROBE_FIX_RIP_AX | UPROBE_FIX_RIP_CX)) {
+ 		struct uprobe_task *utask = current->utask;
+ 		unsigned long *sr = scratch_reg(auprobe, regs);
+ 
+ 		utask->autask.saved_scratch_register = *sr;
+ 		*sr = utask->vaddr + auprobe->def.riprel_target;
++>>>>>>> c90a6950120a (uprobes/x86: Simplify riprel_{pre,post}_xol() and make them similar)
  	}
  }
  
 -static void riprel_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs,
 -				long *correction)
 +static void
 +handle_riprel_post_xol(struct arch_uprobe *auprobe, struct pt_regs *regs, long *correction)
  {
++<<<<<<< HEAD
 +	if (auprobe->fixups & (UPROBE_FIX_RIP_AX | UPROBE_FIX_RIP_CX)) {
 +		struct arch_uprobe_task *autask;
 +
 +		autask = &current->utask->autask;
 +		if (auprobe->fixups & UPROBE_FIX_RIP_AX)
 +			regs->ax = autask->saved_scratch_register;
 +		else
 +			regs->cx = autask->saved_scratch_register;
++=======
+ 	if (auprobe->def.fixups & (UPROBE_FIX_RIP_AX | UPROBE_FIX_RIP_CX)) {
+ 		struct uprobe_task *utask = current->utask;
+ 		unsigned long *sr = scratch_reg(auprobe, regs);
++>>>>>>> c90a6950120a (uprobes/x86: Simplify riprel_{pre,post}_xol() and make them similar)
  
+ 		*sr = utask->autask.saved_scratch_register;
  		/*
  		 * The original instruction includes a displacement, and so
  		 * is 4 bytes longer than what we've just single-stepped.
* Unmerged path arch/x86/kernel/uprobes.c
