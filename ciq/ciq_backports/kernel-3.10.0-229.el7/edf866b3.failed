blk-mq: export blk_mq_tag_busy_iter

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Sam Bradshaw <sbradshaw@micron.com>
commit edf866b3805c5651bf7d035b72dc0190cb6ff4a7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/edf866b3.failed

Export the blk-mq in-flight tag iterator for driver consumption.
This is particularly useful in exception paths or SRSI where
in-flight IOs need to be cancelled and/or reissued. The NVMe driver
conversion will use this.

	Signed-off-by: Sam Bradshaw <sbradshaw@micron.com>
	Signed-off-by: Matias Bj√∏rling <m@bjorling.me>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit edf866b3805c5651bf7d035b72dc0190cb6ff4a7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq-tag.h
#	include/linux/blk-mq.h
diff --cc block/blk-mq-tag.h
index 947ba2c6148e,2e5e6872d089..000000000000
--- a/block/blk-mq-tag.h
+++ b/block/blk-mq-tag.h
@@@ -6,12 -48,13 +6,18 @@@ struct blk_mq_tags
  extern struct blk_mq_tags *blk_mq_init_tags(unsigned int nr_tags, unsigned int reserved_tags, int node);
  extern void blk_mq_free_tags(struct blk_mq_tags *tags);
  
++<<<<<<< HEAD
 +extern unsigned int blk_mq_get_tag(struct blk_mq_tags *tags, gfp_t gfp, bool reserved);
 +extern void blk_mq_wait_for_tags(struct blk_mq_tags *tags);
 +extern void blk_mq_put_tag(struct blk_mq_tags *tags, unsigned int tag);
 +extern void blk_mq_tag_busy_iter(struct blk_mq_tags *tags, void (*fn)(void *data, unsigned long *), void *data);
++=======
+ extern unsigned int blk_mq_get_tag(struct blk_mq_hw_ctx *hctx, unsigned int *last_tag, gfp_t gfp, bool reserved);
+ extern void blk_mq_wait_for_tags(struct blk_mq_hw_ctx *hctx, bool reserved);
+ extern void blk_mq_put_tag(struct blk_mq_hw_ctx *hctx, unsigned int tag, unsigned int *last_tag);
++>>>>>>> edf866b3805c (blk-mq: export blk_mq_tag_busy_iter)
  extern bool blk_mq_has_free_tags(struct blk_mq_tags *tags);
  extern ssize_t blk_mq_tag_sysfs_show(struct blk_mq_tags *tags, char *page);
 -extern void blk_mq_tag_init_last_tag(struct blk_mq_tags *tags, unsigned int *last_tag);
 -extern int blk_mq_tag_update_depth(struct blk_mq_tags *tags, unsigned int depth);
  
  enum {
  	BLK_MQ_TAG_CACHE_MIN	= 1,
diff --cc include/linux/blk-mq.h
index 7b4bdadee022,f76bb18350af..000000000000
--- a/include/linux/blk-mq.h
+++ b/include/linux/blk-mq.h
@@@ -146,7 -178,10 +146,14 @@@ void blk_mq_complete_request(struct req
  void blk_mq_stop_hw_queue(struct blk_mq_hw_ctx *hctx);
  void blk_mq_start_hw_queue(struct blk_mq_hw_ctx *hctx);
  void blk_mq_stop_hw_queues(struct request_queue *q);
++<<<<<<< HEAD
 +void blk_mq_start_stopped_hw_queues(struct request_queue *q);
++=======
+ void blk_mq_start_hw_queues(struct request_queue *q);
+ void blk_mq_start_stopped_hw_queues(struct request_queue *q, bool async);
+ void blk_mq_delay_queue(struct blk_mq_hw_ctx *hctx, unsigned long msecs);
+ void blk_mq_tag_busy_iter(struct blk_mq_tags *tags, void (*fn)(void *data, unsigned long *), void *data);
++>>>>>>> edf866b3805c (blk-mq: export blk_mq_tag_busy_iter)
  
  /*
   * Driver command data is immediately after the request. So subtract request
diff --git a/block/blk-mq-tag.c b/block/blk-mq-tag.c
index 83ae96c51a27..4b35bf497820 100644
--- a/block/blk-mq-tag.c
+++ b/block/blk-mq-tag.c
@@ -117,6 +117,7 @@ void blk_mq_tag_busy_iter(struct blk_mq_tags *tags,
 	fn(data, tag_map);
 	kfree(tag_map);
 }
+EXPORT_SYMBOL(blk_mq_tag_busy_iter);
 
 struct blk_mq_tags *blk_mq_init_tags(unsigned int total_tags,
 				     unsigned int reserved_tags, int node)
* Unmerged path block/blk-mq-tag.h
* Unmerged path include/linux/blk-mq.h
