Drivers: hv: vmbus: Properly protect calls to smp_processor_id()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] hyperv/vmbus: Properly protect calls to smp_processor_id() (Jason Wang) [1146358]
Rebuild_FUZZ: 88.52%
commit-author K. Y. Srinivasan <kys@microsoft.com>
commit 2115b5617adf2eecca49e78f3810f359ddc5c396
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2115b561.failed

Disable preemption when sampling current processor ID when preemption
is otherwise possible.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Tested-by: Sitsofe Wheeler <sitsofe@yahoo.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 2115b5617adf2eecca49e78f3810f359ddc5c396)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hv/channel_mgmt.c
diff --cc drivers/hv/channel_mgmt.c
index 6f7fdd9a7e77,a2d1a9612c86..000000000000
--- a/drivers/hv/channel_mgmt.c
+++ b/drivers/hv/channel_mgmt.c
@@@ -210,6 -224,15 +210,18 @@@ static void vmbus_process_rescind_offer
  	msg.header.msgtype = CHANNELMSG_RELID_RELEASED;
  	vmbus_post_msg(&msg, sizeof(struct vmbus_channel_relid_released));
  
++<<<<<<< HEAD
++=======
+ 	if (channel->target_cpu != get_cpu()) {
+ 		put_cpu();
+ 		smp_call_function_single(channel->target_cpu,
+ 					 percpu_channel_deq, channel, true);
+ 	} else {
+ 		percpu_channel_deq(channel);
+ 		put_cpu();
+ 	}
+ 
++>>>>>>> 2115b5617adf (Drivers: hv: vmbus: Properly protect calls to smp_processor_id())
  	if (channel->primary_channel == NULL) {
  		spin_lock_irqsave(&vmbus_connection.channel_lock, flags);
  		list_del(&channel->listentry);
@@@ -270,6 -294,19 +282,20 @@@ static void vmbus_process_offer(struct 
  
  	spin_unlock_irqrestore(&vmbus_connection.channel_lock, flags);
  
++<<<<<<< HEAD
++=======
+ 	if (enq) {
+ 		if (newchannel->target_cpu != get_cpu()) {
+ 			put_cpu();
+ 			smp_call_function_single(newchannel->target_cpu,
+ 						 percpu_channel_enq,
+ 						 newchannel, true);
+ 		} else {
+ 			percpu_channel_enq(newchannel);
+ 			put_cpu();
+ 		}
+ 	}
++>>>>>>> 2115b5617adf (Drivers: hv: vmbus: Properly protect calls to smp_processor_id())
  	if (!fnew) {
  		/*
  		 * Check to see if this is a sub-channel.
@@@ -282,6 -319,17 +308,20 @@@
  			spin_lock_irqsave(&channel->sc_lock, flags);
  			list_add_tail(&newchannel->sc_list, &channel->sc_list);
  			spin_unlock_irqrestore(&channel->sc_lock, flags);
++<<<<<<< HEAD
++=======
+ 
+ 			if (newchannel->target_cpu != get_cpu()) {
+ 				put_cpu();
+ 				smp_call_function_single(newchannel->target_cpu,
+ 							 percpu_channel_enq,
+ 							 newchannel, true);
+ 			} else {
+ 				percpu_channel_enq(newchannel);
+ 				put_cpu();
+ 			}
+ 
++>>>>>>> 2115b5617adf (Drivers: hv: vmbus: Properly protect calls to smp_processor_id())
  			newchannel->state = CHANNEL_OPEN_STATE;
  			if (channel->sc_creation_callback != NULL)
  				channel->sc_creation_callback(newchannel);
diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c
index da2bbfa910f5..0303a1bf5031 100644
--- a/drivers/hv/channel.c
+++ b/drivers/hv/channel.c
@@ -529,11 +529,14 @@ static void vmbus_close_internal(struct vmbus_channel *channel)
 	channel->state = CHANNEL_OPEN_STATE;
 	channel->sc_creation_callback = NULL;
 	/* Stop callback and cancel the timer asap */
-	if (channel->target_cpu != smp_processor_id())
+	if (channel->target_cpu != get_cpu()) {
+		put_cpu();
 		smp_call_function_single(channel->target_cpu, reset_channel_cb,
 					 channel, true);
-	else
+	} else {
 		reset_channel_cb(channel);
+		put_cpu();
+	}
 
 	/* Send a closing message */
 
* Unmerged path drivers/hv/channel_mgmt.c
