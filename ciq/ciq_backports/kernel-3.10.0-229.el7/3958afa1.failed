net: Change skb_get_rxhash to skb_get_hash

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] Change skb_get_rxhash to skb_get_hash (Jiri Benc) [1110384]
Rebuild_FUZZ: 93.67%
commit-author Tom Herbert <therbert@google.com>
commit 3958afa1b272eb07109fd31549e69193b4d7c364
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3958afa1.failed

Changing name of function as part of making the hash in skbuff to be
generic property, not just for receive path.

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3958afa1b272eb07109fd31549e69193b4d7c364)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/skbuff.h
#	net/core/dev.c
#	net/sched/sch_fq.c
diff --cc include/linux/skbuff.h
index ec5f8c433d9d,4725b953e00d..000000000000
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@@ -741,62 -693,21 +741,67 @@@ struct skb_seq_state 
  	__u8		*frag_data;
  };
  
 -void skb_prepare_seq_read(struct sk_buff *skb, unsigned int from,
 -			  unsigned int to, struct skb_seq_state *st);
 -unsigned int skb_seq_read(unsigned int consumed, const u8 **data,
 -			  struct skb_seq_state *st);
 -void skb_abort_seq_read(struct skb_seq_state *st);
 +extern void	      skb_prepare_seq_read(struct sk_buff *skb,
 +					   unsigned int from, unsigned int to,
 +					   struct skb_seq_state *st);
 +extern unsigned int   skb_seq_read(unsigned int consumed, const u8 **data,
 +				   struct skb_seq_state *st);
 +extern void	      skb_abort_seq_read(struct skb_seq_state *st);
 +
 +extern unsigned int   skb_find_text(struct sk_buff *skb, unsigned int from,
 +				    unsigned int to, struct ts_config *config,
 +				    struct ts_state *state);
 +
++<<<<<<< HEAD
 +/*
 + * Packet hash types specify the type of hash in skb_set_hash.
 + *
 + * Hash types refer to the protocol layer addresses which are used to
 + * construct a packet's hash. The hashes are used to differentiate or identify
 + * flows of the protocol layer for the hash type. Hash types are either
 + * layer-2 (L2), layer-3 (L3), or layer-4 (L4).
 + *
 + * Properties of hashes:
 + *
 + * 1) Two packets in different flows have different hash values
 + * 2) Two packets in the same flow should have the same hash value
 + *
 + * A hash at a higher layer is considered to be more specific. A driver should
 + * set the most specific hash possible.
 + *
 + * A driver cannot indicate a more specific hash than the layer at which a hash
 + * was computed. For instance an L3 hash cannot be set as an L4 hash.
 + *
 + * A driver may indicate a hash level which is less specific than the
 + * actual layer the hash was computed on. For instance, a hash computed
 + * at L4 may be considered an L3 hash. This should only be done if the
 + * driver can't unambiguously determine that the HW computed the hash at
 + * the higher layer. Note that the "should" in the second property above
 + * permits this.
 + */
 +enum pkt_hash_types {
 +	PKT_HASH_TYPE_NONE,	/* Undefined type */
 +	PKT_HASH_TYPE_L2,	/* Input: src_MAC, dest_MAC */
 +	PKT_HASH_TYPE_L3,	/* Input: src_IP, dst_IP */
 +	PKT_HASH_TYPE_L4,	/* Input: src_IP, dst_IP, src_port, dst_port */
 +};
  
 -unsigned int skb_find_text(struct sk_buff *skb, unsigned int from,
 -			   unsigned int to, struct ts_config *config,
 -			   struct ts_state *state);
 +static inline void
 +skb_set_hash(struct sk_buff *skb, __u32 hash, enum pkt_hash_types type)
 +{
 +	skb->l4_rxhash = (type == PKT_HASH_TYPE_L4);
 +	skb->rxhash = hash;
 +}
  
 +extern void __skb_get_rxhash(struct sk_buff *skb);
 +static inline __u32 skb_get_rxhash(struct sk_buff *skb)
++=======
+ void __skb_get_hash(struct sk_buff *skb);
+ static inline __u32 skb_get_hash(struct sk_buff *skb)
++>>>>>>> 3958afa1b272 (net: Change skb_get_rxhash to skb_get_hash)
  {
  	if (!skb->l4_rxhash)
- 		__skb_get_rxhash(skb);
+ 		__skb_get_hash(skb);
  
  	return skb->rxhash;
  }
diff --cc net/core/dev.c
index 7c7615547be2,c482fe8abf87..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -3093,6 -3132,46 +3093,49 @@@ static int rps_ipi_queued(struct softne
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_NET_FLOW_LIMIT
+ int netdev_flow_limit_table_len __read_mostly = (1 << 12);
+ #endif
+ 
+ static bool skb_flow_limit(struct sk_buff *skb, unsigned int qlen)
+ {
+ #ifdef CONFIG_NET_FLOW_LIMIT
+ 	struct sd_flow_limit *fl;
+ 	struct softnet_data *sd;
+ 	unsigned int old_flow, new_flow;
+ 
+ 	if (qlen < (netdev_max_backlog >> 1))
+ 		return false;
+ 
+ 	sd = &__get_cpu_var(softnet_data);
+ 
+ 	rcu_read_lock();
+ 	fl = rcu_dereference(sd->flow_limit);
+ 	if (fl) {
+ 		new_flow = skb_get_hash(skb) & (fl->num_buckets - 1);
+ 		old_flow = fl->history[fl->history_head];
+ 		fl->history[fl->history_head] = new_flow;
+ 
+ 		fl->history_head++;
+ 		fl->history_head &= FLOW_LIMIT_HISTORY - 1;
+ 
+ 		if (likely(fl->buckets[old_flow]))
+ 			fl->buckets[old_flow]--;
+ 
+ 		if (++fl->buckets[new_flow] > (FLOW_LIMIT_HISTORY >> 1)) {
+ 			fl->count++;
+ 			rcu_read_unlock();
+ 			return true;
+ 		}
+ 	}
+ 	rcu_read_unlock();
+ #endif
+ 	return false;
+ }
+ 
++>>>>>>> 3958afa1b272 (net: Change skb_get_rxhash to skb_get_hash)
  /*
   * enqueue_to_backlog is called to queue an skb to a per CPU backlog
   * queue (may be a remote CPU queue).
* Unmerged path net/sched/sch_fq.c
diff --git a/drivers/net/macvtap.c b/drivers/net/macvtap.c
index 6326656f5ac1..1b9e93ffecb1 100644
--- a/drivers/net/macvtap.c
+++ b/drivers/net/macvtap.c
@@ -215,7 +215,7 @@ static struct macvtap_queue *macvtap_get_queue(struct net_device *dev,
 		goto out;
 
 	/* Check if we can use flow to select a queue */
-	rxq = skb_get_rxhash(skb);
+	rxq = skb_get_hash(skb);
 	if (rxq) {
 		tap = rcu_dereference(vlan->taps[rxq % numvtaps]);
 		goto out;
diff --git a/drivers/net/tun.c b/drivers/net/tun.c
index f05cf4bfbe66..3821951611cf 100644
--- a/drivers/net/tun.c
+++ b/drivers/net/tun.c
@@ -354,7 +354,7 @@ static u16 tun_select_queue(struct net_device *dev, struct sk_buff *skb)
 	rcu_read_lock();
 	numqueues = ACCESS_ONCE(tun->numqueues);
 
-	txq = skb_get_rxhash(skb);
+	txq = skb_get_hash(skb);
 	if (txq) {
 		e = tun_flow_find(&tun->flows[tun_hashfn(txq)], txq);
 		if (e)
@@ -1236,7 +1236,7 @@ static ssize_t tun_get_user(struct tun_struct *tun, struct tun_file *tfile,
 	skb_reset_network_header(skb);
 	skb_probe_transport_header(skb, 0);
 
-	rxhash = skb_get_rxhash(skb);
+	rxhash = skb_get_hash(skb);
 	netif_rx_ni(skb);
 
 	tun->dev->stats.rx_packets++;
diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c
index d158096bf15a..5acd556b2e35 100644
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -1566,7 +1566,7 @@ __be16 vxlan_src_port(__u16 port_min, __u16 port_max, struct sk_buff *skb)
 	unsigned int range = (port_max - port_min) + 1;
 	u32 hash;
 
-	hash = skb_get_rxhash(skb);
+	hash = skb_get_hash(skb);
 	if (!hash)
 		hash = jhash(skb->data, 2 * ETH_ALEN,
 			     (__force u32) skb->protocol);
* Unmerged path include/linux/skbuff.h
* Unmerged path net/core/dev.c
diff --git a/net/core/flow_dissector.c b/net/core/flow_dissector.c
index f4742c2c1237..6a5c78b76323 100644
--- a/net/core/flow_dissector.c
+++ b/net/core/flow_dissector.c
@@ -165,12 +165,12 @@ EXPORT_SYMBOL(skb_flow_dissect);
 static u32 hashrnd __read_mostly;
 
 /*
- * __skb_get_rxhash: calculate a flow hash based on src/dst addresses
+ * __skb_get_hash: calculate a flow hash based on src/dst addresses
  * and src/dst port numbers.  Sets rxhash in skb to non-zero hash value
  * on success, zero indicates no valid hash.  Also, sets l4_rxhash in skb
  * if hash is a canonical 4-tuple hash over transport ports.
  */
-void __skb_get_rxhash(struct sk_buff *skb)
+void __skb_get_hash(struct sk_buff *skb)
 {
 	struct flow_keys keys;
 	u32 hash;
@@ -197,7 +197,7 @@ void __skb_get_rxhash(struct sk_buff *skb)
 
 	skb->rxhash = hash;
 }
-EXPORT_SYMBOL(__skb_get_rxhash);
+EXPORT_SYMBOL(__skb_get_hash);
 
 /*
  * Returns a Tx hash based on the given packet descriptor a Tx queues' number
diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 8bef6f34b793..35e4ede50857 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -911,7 +911,7 @@ static void prb_clear_blk_fill_status(struct packet_ring_buffer *rb)
 static void prb_fill_rxhash(struct tpacket_kbdq_core *pkc,
 			struct tpacket3_hdr *ppd)
 {
-	ppd->hv1.tp_rxhash = skb_get_rxhash(pkc->skb);
+	ppd->hv1.tp_rxhash = skb_get_hash(pkc->skb);
 }
 
 static void prb_clear_rxhash(struct tpacket_kbdq_core *pkc,
@@ -1284,7 +1284,7 @@ static int packet_rcv_fanout(struct sk_buff *skb, struct net_device *dev,
 			if (!skb)
 				return 0;
 		}
-		skb_get_rxhash(skb);
+		skb_get_hash(skb);
 		idx = fanout_demux_hash(f, skb, num);
 		break;
 	case PACKET_FANOUT_LB:
diff --git a/net/sched/cls_flow.c b/net/sched/cls_flow.c
index 7881e2fccbc2..83a6322b7751 100644
--- a/net/sched/cls_flow.c
+++ b/net/sched/cls_flow.c
@@ -220,7 +220,7 @@ static u32 flow_get_vlan_tag(const struct sk_buff *skb)
 
 static u32 flow_get_rxhash(struct sk_buff *skb)
 {
-	return skb_get_rxhash(skb);
+	return skb_get_hash(skb);
 }
 
 static u32 flow_key_get(struct sk_buff *skb, int key, struct flow_keys *flow)
diff --git a/net/sched/em_meta.c b/net/sched/em_meta.c
index 7c3de6ffa516..2c04ce77a278 100644
--- a/net/sched/em_meta.c
+++ b/net/sched/em_meta.c
@@ -222,7 +222,7 @@ META_COLLECTOR(int_maclen)
 
 META_COLLECTOR(int_rxhash)
 {
-	dst->value = skb_get_rxhash(skb);
+	dst->value = skb_get_hash(skb);
 }
 
 /**************************************************************************
* Unmerged path net/sched/sch_fq.c
