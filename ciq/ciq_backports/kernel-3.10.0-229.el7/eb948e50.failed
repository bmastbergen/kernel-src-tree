perf probe: Allow to add events on the local functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf/probe: Allow to add events on the local functions (Jiri Olsa) [1134356]
Rebuild_FUZZ: 98.15%
commit-author Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
commit eb948e50831bc64e6bb2589be7575ed7c159a429
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/eb948e50.failed

Allow to add events on the local functions without debuginfo.
(With the debuginfo, we can add events even on inlined functions)
Currently, probing on local functions requires debuginfo to
locate actual address. It is also possible without debuginfo since
we have symbol maps.

Without this change;
  ----
  # ./perf probe -a t_show
  Added new event:
    probe:t_show         (on t_show)

  You can now use it in all perf tools, such as:

          perf record -e probe:t_show -aR sleep 1

  # ./perf probe -x perf -a identity__map_ip
  no symbols found in /kbuild/ksrc/linux-3/tools/perf/perf, maybe install a debug package?
  Failed to load map.
    Error: Failed to add events. (-22)
  ----
As the above results, perf probe just put one event
on the first found symbol for kprobe event. Moreover,
for uprobe event, perf probe failed to find local
functions.

With this change;
  ----
  # ./perf probe -a t_show
  Added new events:
    probe:t_show         (on t_show)
    probe:t_show_1       (on t_show)
    probe:t_show_2       (on t_show)
    probe:t_show_3       (on t_show)

  You can now use it in all perf tools, such as:

          perf record -e probe:t_show_3 -aR sleep 1

  # ./perf probe -x perf -a identity__map_ip
  Added new events:
    probe_perf:identity__map_ip (on identity__map_ip in /kbuild/ksrc/linux-3/tools/perf/perf)
    probe_perf:identity__map_ip_1 (on identity__map_ip in /kbuild/ksrc/linux-3/tools/perf/perf)
    probe_perf:identity__map_ip_2 (on identity__map_ip in /kbuild/ksrc/linux-3/tools/perf/perf)
    probe_perf:identity__map_ip_3 (on identity__map_ip in /kbuild/ksrc/linux-3/tools/perf/perf)

  You can now use it in all perf tools, such as:

          perf record -e probe_perf:identity__map_ip_3 -aR sleep 1
  ----
Now we succeed to put events on every given local functions
for both kprobes and uprobes. :)

Note that this also introduces some symbol rbtree
iteration macros; symbols__for_each, dso__for_each_symbol,
and map__for_each_symbol. These are for walking through
the symbol list in a map.

Changes from v2:
  - Fix add_exec_to_probe_trace_events() not to convert address
    to tp->symbol any more.
  - Fix to set kernel probes based on ref_reloc_sym.

	Signed-off-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: "David A. Long" <dave.long@linaro.org>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Oleg Nesterov <oleg@redhat.com>
	Cc: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Cc: Steven Rostedt <rostedt@goodmis.org>
	Cc: yrl.pp-manager.tt@hitachi.com
Link: http://lkml.kernel.org/r/20140206053225.29635.15026.stgit@kbuild-fedora.yrl.intra.hitachi.co.jp
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit eb948e50831bc64e6bb2589be7575ed7c159a429)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/util/probe-event.c
diff --cc tools/perf/util/probe-event.c
index 1c9c96559614,42bec67aaa38..000000000000
--- a/tools/perf/util/probe-event.c
+++ b/tools/perf/util/probe-event.c
@@@ -70,12 -70,11 +70,17 @@@ static int e_snprintf(char *str, size_
  }
  
  static char *synthesize_perf_probe_point(struct perf_probe_point *pp);
++<<<<<<< HEAD
 +static int convert_name_to_addr(struct perf_probe_event *pev,
 +				const char *exec);
 +static struct machine machine;
++=======
+ static void clear_probe_trace_event(struct probe_trace_event *tev);
+ static struct machine *host_machine;
++>>>>>>> eb948e50831b (perf probe: Allow to add events on the local functions)
  
  /* Initialize symbol maps and path of vmlinux/modules */
 -static int init_symbol_maps(bool user_only)
 +static int init_vmlinux(void)
  {
  	int ret;
  
@@@ -186,21 -245,17 +191,33 @@@ static int init_user_exec(void
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int convert_to_perf_probe_point(struct probe_trace_point *tp,
 +					struct perf_probe_point *pp)
 +{
 +	pp->function = strdup(tp->symbol);
 +
 +	if (pp->function == NULL)
 +		return -ENOMEM;
 +
 +	pp->offset = tp->offset;
 +	pp->retprobe = tp->retprobe;
 +
 +	return 0;
 +}
 +
 +#ifdef DWARF_SUPPORT
++=======
+ static void clear_probe_trace_events(struct probe_trace_event *tevs, int ntevs)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < ntevs; i++)
+ 		clear_probe_trace_event(tevs + i);
+ }
+ 
+ #ifdef HAVE_DWARF_SUPPORT
++>>>>>>> eb948e50831b (perf probe: Allow to add events on the local functions)
  /* Open new debuginfo of given module */
  static struct debuginfo *open_debuginfo(const char *module)
  {
@@@ -221,44 -276,110 +238,82 @@@
  	return debuginfo__new(path);
  }
  
 -static int get_text_start_address(const char *exec, unsigned long *address)
 -{
 -	Elf *elf;
 -	GElf_Ehdr ehdr;
 -	GElf_Shdr shdr;
 -	int fd, ret = -ENOENT;
 -
 -	fd = open(exec, O_RDONLY);
 -	if (fd < 0)
 -		return -errno;
 -
 -	elf = elf_begin(fd, PERF_ELF_C_READ_MMAP, NULL);
 -	if (elf == NULL)
 -		return -EINVAL;
 -
 -	if (gelf_getehdr(elf, &ehdr) == NULL)
 -		goto out;
 -
 -	if (!elf_section_by_name(elf, &ehdr, &shdr, ".text", NULL))
 -		goto out;
 -
 -	*address = shdr.sh_addr - shdr.sh_offset;
 -	ret = 0;
 -out:
 -	elf_end(elf);
 -	return ret;
 -}
 -
  /*
   * Convert trace point to probe point with debuginfo
 + * Currently only handles kprobes.
   */
 -static int find_perf_probe_point_from_dwarf(struct probe_trace_point *tp,
 -					    struct perf_probe_point *pp,
 -					    bool is_kprobe)
 +static int kprobe_convert_to_perf_probe(struct probe_trace_point *tp,
 +					struct perf_probe_point *pp)
  {
 -	struct debuginfo *dinfo = NULL;
 -	unsigned long stext = 0;
 -	u64 addr = tp->address;
 +	struct symbol *sym;
 +	struct map *map;
 +	u64 addr;
  	int ret = -ENOENT;
 +	struct debuginfo *dinfo;
  
 -	/* convert the address to dwarf address */
 -	if (!is_kprobe) {
 -		if (!addr) {
 -			ret = -EINVAL;
 -			goto error;
 -		}
 -		ret = get_text_start_address(tp->module, &stext);
 -		if (ret < 0)
 -			goto error;
 -		addr += stext;
 -	} else {
 -		addr = kernel_get_symbol_address_by_name(tp->symbol, false);
 -		if (addr == 0)
 -			goto error;
 -		addr += tp->offset;
 -	}
 -
 -	pr_debug("try to find information at %" PRIx64 " in %s\n", addr,
 -		 tp->module ? : "kernel");
 +	sym = __find_kernel_function_by_name(tp->symbol, &map);
 +	if (sym) {
 +		addr = map->unmap_ip(map, sym->start + tp->offset);
 +		pr_debug("try to find %s+%ld@%" PRIx64 "\n", tp->symbol,
 +			 tp->offset, addr);
  
 -	dinfo = open_debuginfo(tp->module);
 -	if (dinfo) {
 -		ret = debuginfo__find_probe_point(dinfo,
 +		dinfo = debuginfo__new_online_kernel(addr);
 +		if (dinfo) {
 +			ret = debuginfo__find_probe_point(dinfo,
  						 (unsigned long)addr, pp);
++<<<<<<< HEAD
 +			debuginfo__delete(dinfo);
 +		} else {
 +			pr_debug("Failed to open debuginfo at 0x%" PRIx64 "\n",
 +				 addr);
 +			ret = -ENOENT;
++=======
+ 		debuginfo__delete(dinfo);
+ 	} else {
+ 		pr_debug("Failed to open debuginfo at 0x%" PRIx64 "\n", addr);
+ 		ret = -ENOENT;
+ 	}
+ 
+ 	if (ret > 0) {
+ 		pp->retprobe = tp->retprobe;
+ 		return 0;
+ 	}
+ error:
+ 	pr_debug("Failed to find corresponding probes from debuginfo.\n");
+ 	return ret ? : -ENOENT;
+ }
+ 
+ static int add_exec_to_probe_trace_events(struct probe_trace_event *tevs,
+ 					  int ntevs, const char *exec)
+ {
+ 	int i, ret = 0;
+ 	unsigned long stext = 0;
+ 
+ 	if (!exec)
+ 		return 0;
+ 
+ 	ret = get_text_start_address(exec, &stext);
+ 	if (ret < 0)
+ 		return ret;
+ 
+ 	for (i = 0; i < ntevs && ret >= 0; i++) {
+ 		/* point.address is the addres of point.symbol + point.offset */
+ 		tevs[i].point.address -= stext;
+ 		tevs[i].point.module = strdup(exec);
+ 		if (!tevs[i].point.module) {
+ 			ret = -ENOMEM;
+ 			break;
++>>>>>>> eb948e50831b (perf probe: Allow to add events on the local functions)
  		}
 -		tevs[i].uprobes = true;
  	}
 +	if (ret <= 0) {
 +		pr_debug("Failed to find corresponding probes from "
 +			 "debuginfo. Use kprobe event information.\n");
 +		return convert_to_perf_probe_point(tp, pp);
 +	}
 +	pp->retprobe = tp->retprobe;
  
 -	return ret;
 +	return 0;
  }
  
  static int add_module_to_probe_trace_events(struct probe_trace_event *tevs,
@@@ -294,6 -415,42 +349,45 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /* Post processing the probe events */
+ static int post_process_probe_trace_events(struct probe_trace_event *tevs,
+ 					   int ntevs, const char *module,
+ 					   bool uprobe)
+ {
+ 	struct ref_reloc_sym *reloc_sym;
+ 	char *tmp;
+ 	int i;
+ 
+ 	if (uprobe)
+ 		return add_exec_to_probe_trace_events(tevs, ntevs, module);
+ 
+ 	/* Note that currently ref_reloc_sym based probe is not for drivers */
+ 	if (module)
+ 		return add_module_to_probe_trace_events(tevs, ntevs, module);
+ 
+ 	reloc_sym = kernel_get_ref_reloc_sym();
+ 	if (!reloc_sym) {
+ 		pr_warning("Relocated base symbol is not found!\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	for (i = 0; i < ntevs; i++) {
+ 		if (tevs[i].point.address) {
+ 			tmp = strdup(reloc_sym->name);
+ 			if (!tmp)
+ 				return -ENOMEM;
+ 			free(tevs[i].point.symbol);
+ 			tevs[i].point.symbol = tmp;
+ 			tevs[i].point.offset = tevs[i].point.address -
+ 					       reloc_sym->unrelocated_addr;
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> eb948e50831b (perf probe: Allow to add events on the local functions)
  /* Try to find perf_probe_event with debuginfo */
  static int try_to_find_probe_trace_events(struct perf_probe_event *pev,
  					  struct probe_trace_event **tevs,
@@@ -1908,94 -2300,23 +2157,102 @@@ static int convert_to_probe_trace_event
  					  struct probe_trace_event **tevs,
  					  int max_tevs, const char *target)
  {
++<<<<<<< HEAD
 +	struct symbol *sym;
 +	int ret = 0, i;
 +	struct probe_trace_event *tev;
++=======
+ 	int ret;
 -
 -	if (pev->uprobes && !pev->group) {
 -		/* Replace group name if not given */
 -		ret = convert_exec_to_group(target, &pev->group);
 -		if (ret != 0) {
 -			pr_warning("Failed to make a group name.\n");
 -			return ret;
 -		}
 -	}
++>>>>>>> eb948e50831b (perf probe: Allow to add events on the local functions)
  
  	/* Convert perf_probe_event with debuginfo */
  	ret = try_to_find_probe_trace_events(pev, tevs, max_tevs, target);
  	if (ret != 0)
  		return ret;	/* Found in debuginfo or got an error */
  
++<<<<<<< HEAD
 +	/* Allocate trace event buffer */
 +	tev = *tevs = zalloc(sizeof(struct probe_trace_event));
 +	if (tev == NULL)
 +		return -ENOMEM;
 +
 +	/* Copy parameters */
 +	tev->point.symbol = strdup(pev->point.function);
 +	if (tev->point.symbol == NULL) {
 +		ret = -ENOMEM;
 +		goto error;
 +	}
 +
 +	if (target) {
 +		tev->point.module = strdup(target);
 +		if (tev->point.module == NULL) {
 +			ret = -ENOMEM;
 +			goto error;
 +		}
 +	}
 +
 +	tev->point.offset = pev->point.offset;
 +	tev->point.retprobe = pev->point.retprobe;
 +	tev->nargs = pev->nargs;
 +	tev->uprobes = pev->uprobes;
 +
 +	if (tev->nargs) {
 +		tev->args = zalloc(sizeof(struct probe_trace_arg)
 +				   * tev->nargs);
 +		if (tev->args == NULL) {
 +			ret = -ENOMEM;
 +			goto error;
 +		}
 +		for (i = 0; i < tev->nargs; i++) {
 +			if (pev->args[i].name) {
 +				tev->args[i].name = strdup(pev->args[i].name);
 +				if (tev->args[i].name == NULL) {
 +					ret = -ENOMEM;
 +					goto error;
 +				}
 +			}
 +			tev->args[i].value = strdup(pev->args[i].var);
 +			if (tev->args[i].value == NULL) {
 +				ret = -ENOMEM;
 +				goto error;
 +			}
 +			if (pev->args[i].type) {
 +				tev->args[i].type = strdup(pev->args[i].type);
 +				if (tev->args[i].type == NULL) {
 +					ret = -ENOMEM;
 +					goto error;
 +				}
 +			}
 +		}
 +	}
 +
 +	if (pev->uprobes)
 +		return 1;
 +
 +	/* Currently just checking function name from symbol map */
 +	sym = __find_kernel_function_by_name(tev->point.symbol, NULL);
 +	if (!sym) {
 +		pr_warning("Kernel symbol \'%s\' not found.\n",
 +			   tev->point.symbol);
 +		ret = -ENOENT;
 +		goto error;
 +	} else if (tev->point.offset > sym->end - sym->start) {
 +		pr_warning("Offset specified is greater than size of %s\n",
 +			   tev->point.symbol);
 +		ret = -ENOENT;
 +		goto error;
 +
 +	}
 +
 +	return 1;
 +error:
 +	clear_probe_trace_event(tev);
 +	free(tev);
 +	*tevs = NULL;
 +	return ret;
++=======
+ 	return find_probe_trace_events_from_map(pev, tevs, max_tevs, target);
++>>>>>>> eb948e50831b (perf probe: Allow to add events on the local functions)
  }
  
  struct __event_package {
@@@ -2232,131 -2537,35 +2489,134 @@@ static int available_kernel_funcs(cons
  	if (ret < 0)
  		return ret;
  
 -	/* Get a symbol map */
 -	if (user)
 -		map = dso__new_map(target);
 -	else
 -		map = kernel_get_module_map(target);
 +	map = kernel_get_module_map(module);
  	if (!map) {
 -		pr_err("Failed to get a map for %s\n", (target) ? : "kernel");
 +		pr_err("Failed to find %s map.\n", (module) ? : "kernel");
  		return -EINVAL;
  	}
 +	return __show_available_funcs(map);
 +}
 +
 +static int available_user_funcs(const char *target)
 +{
 +	struct map *map;
 +	int ret;
  
 -	/* Load symbols with given filter */
 +	ret = init_user_exec();
 +	if (ret < 0)
 +		return ret;
 +
 +	map = dso__new_map(target);
 +	ret = __show_available_funcs(map);
 +	dso__delete(map->dso);
 +	map__delete(map);
 +	return ret;
 +}
 +
++<<<<<<< HEAD
 +int show_available_funcs(const char *target, struct strfilter *_filter,
 +					bool user)
 +{
 +	setup_pager();
  	available_func_filter = _filter;
 +
 +	if (!user)
 +		return available_kernel_funcs(target);
 +
 +	return available_user_funcs(target);
 +}
 +
 +/*
 + * uprobe_events only accepts address:
 + * Convert function and any offset to address
 + */
 +static int convert_name_to_addr(struct perf_probe_event *pev, const char *exec)
 +{
 +	struct perf_probe_point *pp = &pev->point;
 +	struct symbol *sym;
 +	struct map *map = NULL;
 +	char *function = NULL;
 +	int ret = -EINVAL;
 +	unsigned long long vaddr = 0;
 +
 +	if (!pp->function) {
 +		pr_warning("No function specified for uprobes");
 +		goto out;
 +	}
 +
 +	function = strdup(pp->function);
 +	if (!function) {
 +		pr_warning("Failed to allocate memory by strdup.\n");
 +		ret = -ENOMEM;
 +		goto out;
 +	}
 +
 +	map = dso__new_map(exec);
 +	if (!map) {
 +		pr_warning("Cannot find appropriate DSO for %s.\n", exec);
 +		goto out;
 +	}
 +	available_func_filter = strfilter__new(function, NULL);
  	if (map__load(map, filter_available_functions)) {
 -		pr_err("Failed to load symbols in %s\n", (target) ? : "kernel");
 -		goto end;
 +		pr_err("Failed to load map.\n");
 +		goto out;
  	}
 -	if (!dso__sorted_by_name(map->dso, map->type))
 -		dso__sort_by_name(map->dso, map->type);
  
 -	/* Show all (filtered) symbols */
 -	setup_pager();
 -	dso__fprintf_symbols_by_name(map->dso, map->type, stdout);
 -end:
 -	if (user) {
 +	sym = map__find_symbol_by_name(map, function, NULL);
 +	if (!sym) {
 +		pr_warning("Cannot find %s in DSO %s\n", function, exec);
 +		goto out;
 +	}
 +
 +	if (map->start > sym->start)
 +		vaddr = map->start;
 +	vaddr += sym->start + pp->offset + map->pgoff;
 +	pp->offset = 0;
 +
 +	if (!pev->event) {
 +		pev->event = function;
 +		function = NULL;
 +	}
 +	if (!pev->group) {
 +		char *ptr1, *ptr2, *exec_copy;
 +
 +		pev->group = zalloc(sizeof(char *) * 64);
 +		exec_copy = strdup(exec);
 +		if (!exec_copy) {
 +			ret = -ENOMEM;
 +			pr_warning("Failed to copy exec string.\n");
 +			goto out;
 +		}
 +
 +		ptr1 = strdup(basename(exec_copy));
 +		if (ptr1) {
 +			ptr2 = strpbrk(ptr1, "-._");
 +			if (ptr2)
 +				*ptr2 = '\0';
 +			e_snprintf(pev->group, 64, "%s_%s", PERFPROBE_GROUP,
 +					ptr1);
 +			free(ptr1);
 +		}
 +		free(exec_copy);
 +	}
 +	free(pp->function);
 +	pp->function = zalloc(sizeof(char *) * MAX_PROBE_ARGS);
 +	if (!pp->function) {
 +		ret = -ENOMEM;
 +		pr_warning("Failed to allocate memory by zalloc.\n");
 +		goto out;
 +	}
 +	e_snprintf(pp->function, MAX_PROBE_ARGS, "0x%llx", vaddr);
 +	ret = 0;
 +
 +out:
 +	if (map) {
  		dso__delete(map->dso);
  		map__delete(map);
  	}
 -	exit_symbol_maps();
 -
 +	if (function)
 +		free(function);
  	return ret;
  }
 -
++=======
++>>>>>>> eb948e50831b (perf probe: Allow to add events on the local functions)
diff --git a/tools/perf/util/dso.h b/tools/perf/util/dso.h
index a2d71292f746..754eca108445 100644
--- a/tools/perf/util/dso.h
+++ b/tools/perf/util/dso.h
@@ -102,6 +102,16 @@ struct dso {
 	char		 name[0];
 };
 
+/* dso__for_each_symbol - iterate over the symbols of given type
+ *
+ * @dso: the 'struct dso *' in which symbols itereated
+ * @pos: the 'struct symbol *' to use as a loop cursor
+ * @n: the 'struct rb_node *' to use as a temporary storage
+ * @type: the 'enum map_type' type of symbols
+ */
+#define dso__for_each_symbol(dso, pos, n, type)	\
+	symbols__for_each_entry(&(dso)->symbols[(type)], pos, n)
+
 static inline void dso__set_loaded(struct dso *dso, enum map_type type)
 {
 	dso->loaded |= (1 << type);
diff --git a/tools/perf/util/map.h b/tools/perf/util/map.h
index 257e513205ce..f00f058afb3b 100644
--- a/tools/perf/util/map.h
+++ b/tools/perf/util/map.h
@@ -90,6 +90,16 @@ u64 map__objdump_2mem(struct map *map, u64 ip);
 
 struct symbol;
 
+/* map__for_each_symbol - iterate over the symbols in the given map
+ *
+ * @map: the 'struct map *' in which symbols itereated
+ * @pos: the 'struct symbol *' to use as a loop cursor
+ * @n: the 'struct rb_node *' to use as a temporary storage
+ * Note: caller must ensure map->dso is not NULL (map is loaded).
+ */
+#define map__for_each_symbol(map, pos, n)	\
+	dso__for_each_symbol(map->dso, pos, n, map->type)
+
 typedef int (*symbol_filter_t)(struct map *map, struct symbol *sym);
 
 void map__init(struct map *map, enum map_type type,
* Unmerged path tools/perf/util/probe-event.c
diff --git a/tools/perf/util/symbol.h b/tools/perf/util/symbol.h
index ae59038469e8..b12926aa931f 100644
--- a/tools/perf/util/symbol.h
+++ b/tools/perf/util/symbol.h
@@ -74,6 +74,17 @@ struct symbol {
 void symbol__delete(struct symbol *sym);
 void symbols__delete(struct rb_root *symbols);
 
+/* symbols__for_each_entry - iterate over symbols (rb_root)
+ *
+ * @symbols: the rb_root of symbols
+ * @pos: the 'struct symbol *' to use as a loop cursor
+ * @nd: the 'struct rb_node *' to use as a temporary storage
+ */
+#define symbols__for_each_entry(symbols, pos, nd)			\
+	for (nd = rb_first(symbols);					\
+	     nd && (pos = rb_entry(nd, struct symbol, rb_node));	\
+	     nd = rb_next(nd))
+
 static inline size_t symbol__size(const struct symbol *sym)
 {
 	return sym->end - sym->start + 1;
