cpufreq: Introduce cpufreq_notify_post_transition()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Introduce cpufreq_notify_post_transition() (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 90.32%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit f7ba3b41e27129575201f0f9656e83fb67e86c3b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/f7ba3b41.failed

This introduces a new routine cpufreq_notify_post_transition() which
can be used to send POSTCHANGE notification for new freq with or
without both {PRE|POST}CHANGE notifications for last freq. This is
useful at multiple places, especially for sending transition failure
notifications.

	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit f7ba3b41e27129575201f0f9656e83fb67e86c3b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/cpufreq.h
diff --cc include/linux/cpufreq.h
index 241e07069182,88aa0f342e85..000000000000
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@@ -296,87 -280,119 +296,120 @@@ cpufreq_verify_within_cpu_limits(struc
  			policy->cpuinfo.max_freq);
  }
  
 -/*********************************************************************
 - *                     CPUFREQ NOTIFIER INTERFACE                    *
 - *********************************************************************/
  
 -#define CPUFREQ_TRANSITION_NOTIFIER	(0)
 -#define CPUFREQ_POLICY_NOTIFIER		(1)
 +struct freq_attr {
 +	struct attribute attr;
 +	ssize_t (*show)(struct cpufreq_policy *, char *);
 +	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t count);
 +};
  
 -/* Transition notifiers */
 -#define CPUFREQ_PRECHANGE		(0)
 -#define CPUFREQ_POSTCHANGE		(1)
 -#define CPUFREQ_RESUMECHANGE		(8)
 -#define CPUFREQ_SUSPENDCHANGE		(9)
 +#define cpufreq_freq_attr_ro(_name)		\
 +static struct freq_attr _name =			\
 +__ATTR(_name, 0444, show_##_name, NULL)
  
 -/* Policy Notifiers  */
 -#define CPUFREQ_ADJUST			(0)
 -#define CPUFREQ_INCOMPATIBLE		(1)
 -#define CPUFREQ_NOTIFY			(2)
 -#define CPUFREQ_START			(3)
 -#define CPUFREQ_UPDATE_POLICY_CPU	(4)
 +#define cpufreq_freq_attr_ro_perm(_name, _perm)	\
 +static struct freq_attr _name =			\
 +__ATTR(_name, _perm, show_##_name, NULL)
 +
 +#define cpufreq_freq_attr_rw(_name)		\
 +static struct freq_attr _name =			\
 +__ATTR(_name, 0644, show_##_name, store_##_name)
 +
 +struct global_attr {
 +	struct attribute attr;
 +	ssize_t (*show)(struct kobject *kobj,
 +			struct attribute *attr, char *buf);
 +	ssize_t (*store)(struct kobject *a, struct attribute *b,
 +			 const char *c, size_t count);
 +};
 +
 +#define define_one_global_ro(_name)		\
 +static struct global_attr _name =		\
 +__ATTR(_name, 0444, show_##_name, NULL)
 +
 +#define define_one_global_rw(_name)		\
 +static struct global_attr _name =		\
 +__ATTR(_name, 0644, show_##_name, store_##_name)
 +
 +struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
 +void cpufreq_cpu_put(struct cpufreq_policy *data);
 +const char *cpufreq_get_current_driver(void);
 +
 +/*********************************************************************
 + *                        CPUFREQ 2.6. INTERFACE                     *
 + *********************************************************************/
 +u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
 +int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 +int cpufreq_update_policy(unsigned int cpu);
 +bool have_governor_per_policy(void);
 +struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
  
  #ifdef CONFIG_CPU_FREQ
++<<<<<<< HEAD
 +/*
 + * query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it
++=======
+ int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
+ int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
+ 
+ void cpufreq_notify_transition(struct cpufreq_policy *policy,
+ 		struct cpufreq_freqs *freqs, unsigned int state);
+ void cpufreq_notify_post_transition(struct cpufreq_policy *policy,
+ 		struct cpufreq_freqs *freqs, int transition_failed);
+ 
+ #else /* CONFIG_CPU_FREQ */
+ static inline int cpufreq_register_notifier(struct notifier_block *nb,
+ 						unsigned int list)
+ {
+ 	return 0;
+ }
+ static inline int cpufreq_unregister_notifier(struct notifier_block *nb,
+ 						unsigned int list)
+ {
+ 	return 0;
+ }
+ #endif /* !CONFIG_CPU_FREQ */
+ 
+ /**
+  * cpufreq_scale - "old * mult / div" calculation for large values (32-bit-arch
+  * safe)
+  * @old:   old value
+  * @div:   divisor
+  * @mult:  multiplier
+  *
+  *
+  * new = old * mult / div
++>>>>>>> f7ba3b41e271 (cpufreq: Introduce cpufreq_notify_post_transition())
   */
 -static inline unsigned long cpufreq_scale(unsigned long old, u_int div,
 -		u_int mult)
 +unsigned int cpufreq_get(unsigned int cpu);
 +#else
 +static inline unsigned int cpufreq_get(unsigned int cpu)
  {
 -#if BITS_PER_LONG == 32
 -	u64 result = ((u64) old) * ((u64) mult);
 -	do_div(result, div);
 -	return (unsigned long) result;
 -
 -#elif BITS_PER_LONG == 64
 -	unsigned long result = old * ((u64) mult);
 -	result /= div;
 -	return result;
 -#endif
 +	return 0;
  }
 -
 -/*********************************************************************
 - *                          CPUFREQ GOVERNORS                        *
 - *********************************************************************/
 +#endif
  
  /*
 - * If (cpufreq_driver->target) exists, the ->governor decides what frequency
 - * within the limits is used. If (cpufreq_driver->setpolicy> exists, these
 - * two generic policies are available:
 + * query the last known CPU freq (in kHz). If zero, cpufreq couldn't detect it
   */
 -#define CPUFREQ_POLICY_POWERSAVE	(1)
 -#define CPUFREQ_POLICY_PERFORMANCE	(2)
 -
 -/* Governor Events */
 -#define CPUFREQ_GOV_START	1
 -#define CPUFREQ_GOV_STOP	2
 -#define CPUFREQ_GOV_LIMITS	3
 -#define CPUFREQ_GOV_POLICY_INIT	4
 -#define CPUFREQ_GOV_POLICY_EXIT	5
 -
 -struct cpufreq_governor {
 -	char	name[CPUFREQ_NAME_LEN];
 -	int	initialized;
 -	int	(*governor)	(struct cpufreq_policy *policy,
 -				 unsigned int event);
 -	ssize_t	(*show_setspeed)	(struct cpufreq_policy *policy,
 -					 char *buf);
 -	int	(*store_setspeed)	(struct cpufreq_policy *policy,
 -					 unsigned int freq);
 -	unsigned int max_transition_latency; /* HW must be able to switch to
 -			next freq faster than this value in nano secs or we
 -			will fallback to performance governor */
 -	struct list_head	governor_list;
 -	struct module		*owner;
 -};
 +#ifdef CONFIG_CPU_FREQ
 +unsigned int cpufreq_quick_get(unsigned int cpu);
 +unsigned int cpufreq_quick_get_max(unsigned int cpu);
 +#else
 +static inline unsigned int cpufreq_quick_get(unsigned int cpu)
 +{
 +	return 0;
 +}
 +static inline unsigned int cpufreq_quick_get_max(unsigned int cpu)
 +{
 +	return 0;
 +}
 +#endif
  
 -/* Pass a target to the cpufreq driver */
 -int cpufreq_driver_target(struct cpufreq_policy *policy,
 -				 unsigned int target_freq,
 -				 unsigned int relation);
 -int __cpufreq_driver_target(struct cpufreq_policy *policy,
 -				   unsigned int target_freq,
 -				   unsigned int relation);
 -int cpufreq_register_governor(struct cpufreq_governor *governor);
 -void cpufreq_unregister_governor(struct cpufreq_governor *governor);
 +/*********************************************************************
 + *                       CPUFREQ DEFAULT GOVERNOR                    *
 + *********************************************************************/
  
 -/* CPUFREQ DEFAULT GOVERNOR */
  /*
   * Performance governor is fallback governor if any other gov failed to auto
   * load due latency restrictions
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index 7e78bc2de297..f68da32dd5cf 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -339,6 +339,20 @@ void cpufreq_notify_transition(struct cpufreq_policy *policy,
 }
 EXPORT_SYMBOL_GPL(cpufreq_notify_transition);
 
+/* Do post notifications when there are chances that transition has failed */
+void cpufreq_notify_post_transition(struct cpufreq_policy *policy,
+		struct cpufreq_freqs *freqs, int transition_failed)
+{
+	cpufreq_notify_transition(policy, freqs, CPUFREQ_POSTCHANGE);
+	if (!transition_failed)
+		return;
+
+	swap(freqs->old, freqs->new);
+	cpufreq_notify_transition(policy, freqs, CPUFREQ_PRECHANGE);
+	cpufreq_notify_transition(policy, freqs, CPUFREQ_POSTCHANGE);
+}
+EXPORT_SYMBOL_GPL(cpufreq_notify_post_transition);
+
 
 /*********************************************************************
  *                          SYSFS INTERFACE                          *
* Unmerged path include/linux/cpufreq.h
