s390/uaccess: get rid of indirect function calls

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [s390] uaccess: get rid of indirect function calls (Hendrik Brueckner) [1099147]
Rebuild_FUZZ: 94.51%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit 4f41c2b4567dbfb7ff93e5c552b869e2865bcd9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/4f41c2b4.failed

There are only two uaccess variants on s390 left: the version that is used
if the mvcos instruction is available, and the page table walk variant.
So there is no need for expensive indirect function calls.

By default the mvcos variant will be called. If the mvcos instruction is not
available it will call the page table walk variant.

For minimal performance impact the "if (mvcos_is_available)" is implemented
with a jump label, which will be a six byte nop on machines with mvcos.

	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 4f41c2b4567dbfb7ff93e5c552b869e2865bcd9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/uaccess.h
#	arch/s390/kernel/setup.c
#	arch/s390/lib/Makefile
#	arch/s390/lib/uaccess_mvcos.c
#	arch/s390/lib/uaccess_pt.c
diff --cc arch/s390/include/asm/uaccess.h
index 9c33ed4e666f,49885a518e5e..000000000000
--- a/arch/s390/include/asm/uaccess.h
+++ b/arch/s390/include/asm/uaccess.h
@@@ -92,37 -92,58 +92,89 @@@ static inline unsigned long extable_fix
  #define ARCH_HAS_SORT_EXTABLE
  #define ARCH_HAS_SEARCH_EXTABLE
  
++<<<<<<< HEAD
 +struct uaccess_ops {
 +	size_t (*copy_from_user)(size_t, const void __user *, void *);
 +	size_t (*copy_from_user_small)(size_t, const void __user *, void *);
 +	size_t (*copy_to_user)(size_t, void __user *, const void *);
 +	size_t (*copy_to_user_small)(size_t, void __user *, const void *);
 +	size_t (*copy_in_user)(size_t, void __user *, const void __user *);
 +	size_t (*clear_user)(size_t, void __user *);
 +	size_t (*strnlen_user)(size_t, const char __user *);
 +	size_t (*strncpy_from_user)(size_t, const char __user *, char *);
 +	int (*futex_atomic_op)(int op, u32 __user *, int oparg, int *old);
 +	int (*futex_atomic_cmpxchg)(u32 *, u32 __user *, u32 old, u32 new);
 +};
 +
 +extern struct uaccess_ops uaccess;
 +extern struct uaccess_ops uaccess_std;
 +extern struct uaccess_ops uaccess_mvcos;
 +extern struct uaccess_ops uaccess_mvcos_switch;
 +extern struct uaccess_ops uaccess_pt;
++=======
+ int __handle_fault(unsigned long, unsigned long, int);
  
- extern int __handle_fault(unsigned long, unsigned long, int);
+ /**
+  * __copy_from_user: - Copy a block of data from user space, with less checking.
+  * @to:   Destination address, in kernel space.
+  * @from: Source address, in user space.
+  * @n:	  Number of bytes to copy.
+  *
+  * Context: User context only.	This function may sleep.
+  *
+  * Copy data from user space to kernel space.  Caller must check
+  * the specified block with access_ok() before calling this function.
+  *
+  * Returns number of bytes that could not be copied.
+  * On success, this will be zero.
+  *
+  * If some data could not be copied, this function will pad the copied
+  * data to the requested size using zero bytes.
+  */
+ size_t __must_check __copy_from_user(void *to, const void __user *from,
+ 				     size_t n);
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
+ 
+ /**
+  * __copy_to_user: - Copy a block of data into user space, with less checking.
+  * @to:   Destination address, in user space.
+  * @from: Source address, in kernel space.
+  * @n:	  Number of bytes to copy.
+  *
+  * Context: User context only.	This function may sleep.
+  *
+  * Copy data from kernel space to user space.  Caller must check
+  * the specified block with access_ok() before calling this function.
+  *
+  * Returns number of bytes that could not be copied.
+  * On success, this will be zero.
+  */
+ unsigned long __must_check __copy_to_user(void __user *to, const void *from,
+ 					  unsigned long n);
+ 
+ #define __copy_to_user_inatomic __copy_to_user
+ #define __copy_from_user_inatomic __copy_from_user
  
 -static inline int __put_user_fn(void *x, void __user *ptr, size_t size)
 +static inline int __put_user_fn(size_t size, void __user *ptr, void *x)
  {
++<<<<<<< HEAD
 +	size = uaccess.copy_to_user_small(size, ptr, x);
 +	return size ? -EFAULT : size;
++=======
+ 	size = __copy_to_user(ptr, x, size);
+ 	return size ? -EFAULT : 0;
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  }
  
 -static inline int __get_user_fn(void *x, const void __user *ptr, size_t size)
 +static inline int __get_user_fn(size_t size, const void __user *ptr, void *x)
  {
++<<<<<<< HEAD
 +	size = uaccess.copy_from_user_small(size, ptr, x);
 +	return size ? -EFAULT : size;
++=======
+ 	size = __copy_from_user(x, ptr, size);
+ 	return size ? -EFAULT : 0;
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  }
  
  /*
@@@ -210,32 -231,6 +262,35 @@@ int __get_user_bad(void) __attribute__(
  #define __get_user_unaligned __get_user
  
  /**
++<<<<<<< HEAD
 + * __copy_to_user: - Copy a block of data into user space, with less checking.
 + * @to:   Destination address, in user space.
 + * @from: Source address, in kernel space.
 + * @n:    Number of bytes to copy.
 + *
 + * Context: User context only.  This function may sleep.
 + *
 + * Copy data from kernel space to user space.  Caller must check
 + * the specified block with access_ok() before calling this function.
 + *
 + * Returns number of bytes that could not be copied.
 + * On success, this will be zero.
 + */
 +static inline unsigned long __must_check
 +__copy_to_user(void __user *to, const void *from, unsigned long n)
 +{
 +	if (__builtin_constant_p(n) && (n <= 256))
 +		return uaccess.copy_to_user_small(n, to, from);
 +	else
 +		return uaccess.copy_to_user(n, to, from);
 +}
 +
 +#define __copy_to_user_inatomic __copy_to_user
 +#define __copy_from_user_inatomic __copy_from_user
 +
 +/**
++=======
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
   * copy_to_user: - Copy a block of data into user space.
   * @to:   Destination address, in user space.
   * @from: Source address, in kernel space.
@@@ -255,33 -250,7 +310,37 @@@ copy_to_user(void __user *to, const voi
  	return __copy_to_user(to, from, n);
  }
  
++<<<<<<< HEAD
 +/**
 + * __copy_from_user: - Copy a block of data from user space, with less checking.
 + * @to:   Destination address, in kernel space.
 + * @from: Source address, in user space.
 + * @n:    Number of bytes to copy.
 + *
 + * Context: User context only.  This function may sleep.
 + *
 + * Copy data from user space to kernel space.  Caller must check
 + * the specified block with access_ok() before calling this function.
 + *
 + * Returns number of bytes that could not be copied.
 + * On success, this will be zero.
 + *
 + * If some data could not be copied, this function will pad the copied
 + * data to the requested size using zero bytes.
 + */
 +static inline unsigned long __must_check
 +__copy_from_user(void *to, const void __user *from, unsigned long n)
 +{
 +	if (__builtin_constant_p(n) && (n <= 256))
 +		return uaccess.copy_from_user_small(n, from, to);
 +	else
 +		return uaccess.copy_from_user(n, from, to);
 +}
 +
 +extern void copy_from_user_overflow(void)
++=======
+ void copy_from_user_overflow(void)
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  #ifdef CONFIG_DEBUG_STRICT_USER_COPY_CHECKS
  __compiletime_warning("copy_from_user() buffer size is not provably correct")
  #endif
@@@ -316,11 -285,8 +375,16 @@@ copy_from_user(void *to, const void __u
  	return __copy_from_user(to, from, n);
  }
  
++<<<<<<< HEAD
 +static inline unsigned long __must_check
 +__copy_in_user(void __user *to, const void __user *from, unsigned long n)
 +{
 +	return uaccess.copy_in_user(n, to, from);
 +}
++=======
+ unsigned long __must_check
+ __copy_in_user(void __user *to, const void __user *from, unsigned long n);
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  
  static inline unsigned long __must_check
  copy_in_user(void __user *to, const void __user *from, unsigned long n)
@@@ -336,14 -305,15 +403,23 @@@ static inline long __must_chec
  strncpy_from_user(char *dst, const char __user *src, long count)
  {
  	might_fault();
++<<<<<<< HEAD
 +	return uaccess.strncpy_from_user(count, src, dst);
++=======
+ 	return __strncpy_from_user(dst, src, count);
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  }
  
- static inline unsigned long
- strnlen_user(const char __user * src, unsigned long n)
+ size_t __must_check __strnlen_user(const char __user *src, size_t count);
+ 
+ static inline size_t strnlen_user(const char __user *src, size_t n)
  {
  	might_fault();
++<<<<<<< HEAD
 +	return uaccess.strnlen_user(n, src);
++=======
+ 	return __strnlen_user(src, n);
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  }
  
  /**
@@@ -365,21 -335,15 +441,29 @@@
  /*
   * Zero Userspace
   */
+ size_t __must_check __clear_user(void __user *to, size_t size);
  
++<<<<<<< HEAD
 +static inline unsigned long __must_check
 +__clear_user(void __user *to, unsigned long n)
 +{
 +	return uaccess.clear_user(n, to);
 +}
 +
 +static inline unsigned long __must_check
 +clear_user(void __user *to, unsigned long n)
 +{
 +	might_fault();
 +	return uaccess.clear_user(n, to);
++=======
+ static inline size_t __must_check clear_user(void __user *to, size_t n)
+ {
+ 	might_fault();
+ 	return __clear_user(to, n);
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  }
  
- extern int copy_to_user_real(void __user *dest, void *src, size_t count);
- extern int copy_from_user_real(void *dest, void __user *src, size_t count);
+ int copy_to_user_real(void __user *dest, void *src, size_t count);
+ int copy_from_user_real(void *dest, void __user *src, size_t count);
  
  #endif /* __S390_UACCESS_H */
diff --cc arch/s390/kernel/setup.c
index 77adf32d5eaa,91ea00955db7..000000000000
--- a/arch/s390/kernel/setup.c
+++ b/arch/s390/kernel/setup.c
@@@ -64,18 -63,6 +63,12 @@@
  #include <asm/sclp.h>
  #include "entry.h"
  
 +long psw_kernel_bits	= PSW_DEFAULT_KEY | PSW_MASK_BASE | PSW_ASC_PRIMARY |
 +			  PSW_MASK_EA | PSW_MASK_BA;
 +long psw_user_bits	= PSW_MASK_DAT | PSW_MASK_IO | PSW_MASK_EXT |
 +			  PSW_DEFAULT_KEY | PSW_MASK_BASE | PSW_MASK_MCHECK |
 +			  PSW_MASK_PSTATE | PSW_ASC_HOME;
 +
- /*
-  * User copy operations.
-  */
- struct uaccess_ops uaccess;
- EXPORT_SYMBOL(uaccess);
- 
  /*
   * Machine setup..
   */
@@@ -1048,11 -1002,6 +1041,14 @@@ void __init setup_arch(char **cmdline_p
  	init_mm.end_data = (unsigned long) &_edata;
  	init_mm.brk = (unsigned long) &_end;
  
++<<<<<<< HEAD
 +	if (MACHINE_HAS_MVCOS)
 +		memcpy(&uaccess, &uaccess_mvcos, sizeof(uaccess));
 +	else
 +		memcpy(&uaccess, &uaccess_std, sizeof(uaccess));
 +
++=======
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  	parse_early_param();
  	detect_memory_layout(memory_chunk, memory_end);
  	os_info_init();
diff --cc arch/s390/lib/Makefile
index 20b0e97a7df2,e3fffe1dff51..000000000000
--- a/arch/s390/lib/Makefile
+++ b/arch/s390/lib/Makefile
@@@ -2,8 -2,7 +2,11 @@@
  # Makefile for s390-specific library files..
  #
  
++<<<<<<< HEAD
 +lib-y += delay.o string.o uaccess_std.o uaccess_pt.o
++=======
+ lib-y += delay.o string.o uaccess_pt.o uaccess_mvcos.o find.o
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  obj-$(CONFIG_32BIT) += div64.o qrnnd.o ucmpdi2.o mem32.o
  obj-$(CONFIG_64BIT) += mem64.o
- lib-$(CONFIG_64BIT) += uaccess_mvcos.o
  lib-$(CONFIG_SMP) += spinlock.o
diff --cc arch/s390/lib/uaccess_mvcos.c
index 1829742bf479,66f35e15db2d..000000000000
--- a/arch/s390/lib/uaccess_mvcos.c
+++ b/arch/s390/lib/uaccess_mvcos.c
@@@ -26,7 -28,10 +28,14 @@@
  #define SLR	"slgr"
  #endif
  
++<<<<<<< HEAD
 +static size_t copy_from_user_mvcos(size_t size, const void __user *ptr, void *x)
++=======
+ static struct static_key have_mvcos = STATIC_KEY_INIT_TRUE;
+ 
+ static inline size_t copy_from_user_mvcos(void *x, const void __user *ptr,
+ 					  size_t size)
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  {
  	register unsigned long reg0 asm("0") = 0x81UL;
  	unsigned long tmp1, tmp2;
@@@ -65,14 -70,16 +74,27 @@@
  	return size;
  }
  
++<<<<<<< HEAD
 +static size_t copy_from_user_mvcos_check(size_t size, const void __user *ptr, void *x)
 +{
 +	if (size <= 256)
 +		return copy_from_user_std(size, ptr, x);
 +	return copy_from_user_mvcos(size, ptr, x);
 +}
 +
 +static size_t copy_to_user_mvcos(size_t size, void __user *ptr, const void *x)
++=======
+ size_t __copy_from_user(void *to, const void __user *from, size_t n)
+ {
+ 	if (static_key_true(&have_mvcos))
+ 		return copy_from_user_mvcos(to, from, n);
+ 	return copy_from_user_pt(to, from, n);
+ }
+ EXPORT_SYMBOL(__copy_from_user);
+ 
+ static inline size_t copy_to_user_mvcos(void __user *ptr, const void *x,
+ 					size_t size)
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  {
  	register unsigned long reg0 asm("0") = 0x810000UL;
  	unsigned long tmp1, tmp2;
@@@ -101,16 -108,16 +123,29 @@@
  	return size;
  }
  
++<<<<<<< HEAD
 +static size_t copy_to_user_mvcos_check(size_t size, void __user *ptr,
 +				       const void *x)
 +{
 +	if (size <= 256)
 +		return copy_to_user_std(size, ptr, x);
 +	return copy_to_user_mvcos(size, ptr, x);
 +}
 +
 +static size_t copy_in_user_mvcos(size_t size, void __user *to,
 +				 const void __user *from)
++=======
+ size_t __copy_to_user(void __user *to, const void *from, size_t n)
+ {
+ 	if (static_key_true(&have_mvcos))
+ 		return copy_to_user_mvcos(to, from, n);
+ 	return copy_to_user_pt(to, from, n);
+ }
+ EXPORT_SYMBOL(__copy_to_user);
+ 
+ static inline size_t copy_in_user_mvcos(void __user *to, const void __user *from,
+ 					size_t size)
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  {
  	register unsigned long reg0 asm("0") = 0x810081UL;
  	unsigned long tmp1, tmp2;
@@@ -132,7 -139,15 +167,19 @@@
  	return size;
  }
  
++<<<<<<< HEAD
 +static size_t clear_user_mvcos(size_t size, void __user *to)
++=======
+ size_t __copy_in_user(void __user *to, const void __user *from, size_t n)
+ {
+ 	if (static_key_true(&have_mvcos))
+ 		return copy_in_user_mvcos(to, from, n);
+ 	return copy_in_user_pt(to, from, n);
+ }
+ EXPORT_SYMBOL(__copy_in_user);
+ 
+ static inline size_t clear_user_mvcos(void __user *to, size_t size)
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  {
  	register unsigned long reg0 asm("0") = 0x810000UL;
  	unsigned long tmp1, tmp2;
@@@ -160,7 -175,15 +207,19 @@@
  	return size;
  }
  
++<<<<<<< HEAD
 +static size_t strnlen_user_mvcos(size_t count, const char __user *src)
++=======
+ size_t __clear_user(void __user *to, size_t size)
+ {
+ 	if (static_key_true(&have_mvcos))
+ 		return clear_user_mvcos(to, size);
+ 	return clear_user_pt(to, size);
+ }
+ EXPORT_SYMBOL(__clear_user);
+ 
+ static inline size_t strnlen_user_mvcos(const char __user *src, size_t count)
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  {
  	size_t done, len, offset, len_str;
  	char buf[256];
@@@ -179,10 -202,18 +238,23 @@@
  	return done + 1;
  }
  
++<<<<<<< HEAD
 +static size_t strncpy_from_user_mvcos(size_t count, const char __user *src,
 +				      char *dst)
++=======
+ size_t __strnlen_user(const char __user *src, size_t count)
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  {
- 	size_t done, len, offset, len_str;
+ 	if (static_key_true(&have_mvcos))
+ 		return strnlen_user_mvcos(src, count);
+ 	return strnlen_user_pt(src, count);
+ }
+ EXPORT_SYMBOL(__strnlen_user);
+ 
+ static inline size_t strncpy_from_user_mvcos(char *dst, const char __user *src,
+ 					     size_t count)
+ {
+ 	unsigned long done, len, offset, len_str;
  
  	if (unlikely(!count))
  		return 0;
@@@ -200,28 -231,18 +272,46 @@@
  	return done;
  }
  
++<<<<<<< HEAD
 +struct uaccess_ops uaccess_mvcos = {
 +	.copy_from_user = copy_from_user_mvcos_check,
 +	.copy_from_user_small = copy_from_user_std,
 +	.copy_to_user = copy_to_user_mvcos_check,
 +	.copy_to_user_small = copy_to_user_std,
 +	.copy_in_user = copy_in_user_mvcos,
 +	.clear_user = clear_user_mvcos,
 +	.strnlen_user = strnlen_user_std,
 +	.strncpy_from_user = strncpy_from_user_std,
 +	.futex_atomic_op = futex_atomic_op_std,
 +	.futex_atomic_cmpxchg = futex_atomic_cmpxchg_std,
 +};
 +
 +struct uaccess_ops uaccess_mvcos_switch = {
 +	.copy_from_user = copy_from_user_mvcos,
 +	.copy_from_user_small = copy_from_user_mvcos,
 +	.copy_to_user = copy_to_user_mvcos,
 +	.copy_to_user_small = copy_to_user_mvcos,
 +	.copy_in_user = copy_in_user_mvcos,
 +	.clear_user = clear_user_mvcos,
 +	.strnlen_user = strnlen_user_mvcos,
 +	.strncpy_from_user = strncpy_from_user_mvcos,
 +	.futex_atomic_op = futex_atomic_op_pt,
 +	.futex_atomic_cmpxchg = futex_atomic_cmpxchg_pt,
 +};
++=======
+ long __strncpy_from_user(char *dst, const char __user *src, long count)
+ {
+ 	if (static_key_true(&have_mvcos))
+ 		return strncpy_from_user_mvcos(dst, src, count);
+ 	return strncpy_from_user_pt(dst, src, count);
+ }
+ EXPORT_SYMBOL(__strncpy_from_user);
+ 
+ static int __init uaccess_init(void)
+ {
+ 	if (!MACHINE_HAS_MVCOS)
+ 		static_key_slow_dec(&have_mvcos);
+ 	return 0;
+ }
+ early_initcall(uaccess_init);
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
diff --cc arch/s390/lib/uaccess_pt.c
index f4df0e3aabe2,b49c3a440a24..000000000000
--- a/arch/s390/lib/uaccess_pt.c
+++ b/arch/s390/lib/uaccess_pt.c
@@@ -211,7 -211,7 +211,11 @@@ fault
  	return 0;
  }
  
++<<<<<<< HEAD
 +static size_t copy_from_user_pt(size_t n, const void __user *from, void *to)
++=======
+ size_t copy_from_user_pt(void *to, const void __user *from, size_t n)
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  {
  	size_t rc;
  
@@@ -223,14 -223,14 +227,22 @@@
  	return rc;
  }
  
++<<<<<<< HEAD
 +static size_t copy_to_user_pt(size_t n, void __user *to, const void *from)
++=======
+ size_t copy_to_user_pt(void __user *to, const void *from, size_t n)
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  {
  	if (segment_eq(get_fs(), KERNEL_DS))
 -		return copy_in_kernel(to, (void __user *) from, n);
 +		return copy_in_kernel(n, to, (void __user *) from);
  	return __user_copy_pt((unsigned long) to, (void *) from, n, 1);
  }
  
++<<<<<<< HEAD
 +static size_t clear_user_pt(size_t n, void __user *to)
++=======
+ size_t clear_user_pt(void __user *to, size_t n)
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  {
  	void *zpage = (void *) empty_zero_page;
  	long done, size, ret;
@@@ -253,7 -253,7 +265,11 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static size_t strnlen_user_pt(size_t count, const char __user *src)
++=======
+ size_t strnlen_user_pt(const char __user *src, size_t count)
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  {
  	unsigned long uaddr = (unsigned long) src;
  	struct mm_struct *mm = current->mm;
@@@ -289,8 -289,7 +305,12 @@@ fault
  	goto retry;
  }
  
++<<<<<<< HEAD
 +static size_t strncpy_from_user_pt(size_t count, const char __user *src,
 +				   char *dst)
++=======
+ size_t strncpy_from_user_pt(char *dst, const char __user *src, size_t count)
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  {
  	size_t done, len, offset, len_str;
  
@@@ -315,8 -314,7 +335,12 @@@
  	return done;
  }
  
++<<<<<<< HEAD
 +static size_t copy_in_user_pt(size_t n, void __user *to,
 +			      const void __user *from)
++=======
+ size_t copy_in_user_pt(void __user *to, const void __user *from, size_t n)
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
  {
  	struct mm_struct *mm = current->mm;
  	unsigned long offset_max, uaddr, done, size, error_code;
@@@ -471,16 -469,3 +495,19 @@@ int futex_atomic_cmpxchg_inatomic(u32 *
  	put_page(virt_to_page(uaddr));
  	return ret;
  }
++<<<<<<< HEAD
 +
 +struct uaccess_ops uaccess_pt = {
 +	.copy_from_user		= copy_from_user_pt,
 +	.copy_from_user_small	= copy_from_user_pt,
 +	.copy_to_user		= copy_to_user_pt,
 +	.copy_to_user_small	= copy_to_user_pt,
 +	.copy_in_user		= copy_in_user_pt,
 +	.clear_user		= clear_user_pt,
 +	.strnlen_user		= strnlen_user_pt,
 +	.strncpy_from_user	= strncpy_from_user_pt,
 +	.futex_atomic_op	= futex_atomic_op_pt,
 +	.futex_atomic_cmpxchg	= futex_atomic_cmpxchg_pt,
 +};
++=======
++>>>>>>> 4f41c2b4567d (s390/uaccess: get rid of indirect function calls)
diff --git a/arch/s390/include/asm/futex.h b/arch/s390/include/asm/futex.h
index 51bcaa0fdeef..fda46bd38c99 100644
--- a/arch/s390/include/asm/futex.h
+++ b/arch/s390/include/asm/futex.h
@@ -5,7 +5,10 @@
 #include <linux/uaccess.h>
 #include <asm/errno.h>
 
-static inline int futex_atomic_op_inuser (int encoded_op, u32 __user *uaddr)
+int futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr, u32 oldval, u32 newval);
+int __futex_atomic_op_inuser(int op, u32 __user *uaddr, int oparg, int *old);
+
+static inline int futex_atomic_op_inuser(int encoded_op, u32 __user *uaddr)
 {
 	int op = (encoded_op >> 28) & 7;
 	int cmp = (encoded_op >> 24) & 15;
@@ -17,7 +20,7 @@ static inline int futex_atomic_op_inuser (int encoded_op, u32 __user *uaddr)
 		oparg = 1 << oparg;
 
 	pagefault_disable();
-	ret = uaccess.futex_atomic_op(op, uaddr, oparg, &oldval);
+	ret = __futex_atomic_op_inuser(op, uaddr, oparg, &oldval);
 	pagefault_enable();
 
 	if (!ret) {
@@ -34,10 +37,4 @@ static inline int futex_atomic_op_inuser (int encoded_op, u32 __user *uaddr)
 	return ret;
 }
 
-static inline int futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,
-						u32 oldval, u32 newval)
-{
-	return uaccess.futex_atomic_cmpxchg(uval, uaddr, oldval, newval);
-}
-
 #endif /* _ASM_S390_FUTEX_H */
* Unmerged path arch/s390/include/asm/uaccess.h
* Unmerged path arch/s390/kernel/setup.c
* Unmerged path arch/s390/lib/Makefile
diff --git a/arch/s390/lib/uaccess.h b/arch/s390/lib/uaccess.h
index b1a22173d027..e5b9c924b733 100644
--- a/arch/s390/lib/uaccess.h
+++ b/arch/s390/lib/uaccess.h
@@ -6,7 +6,11 @@
 #ifndef __ARCH_S390_LIB_UACCESS_H
 #define __ARCH_S390_LIB_UACCESS_H
 
-extern int futex_atomic_op_pt(int, u32 __user *, int, int *);
-extern int futex_atomic_cmpxchg_pt(u32 *, u32 __user *, u32, u32);
+size_t copy_from_user_pt(void *to, const void __user *from, size_t n);
+size_t copy_to_user_pt(void __user *to, const void *from, size_t n);
+size_t copy_in_user_pt(void __user *to, const void __user *from, size_t n);
+size_t clear_user_pt(void __user *to, size_t n);
+size_t strnlen_user_pt(const char __user *src, size_t count);
+size_t strncpy_from_user_pt(char *dst, const char __user *src, size_t count);
 
 #endif /* __ARCH_S390_LIB_UACCESS_H */
* Unmerged path arch/s390/lib/uaccess_mvcos.c
* Unmerged path arch/s390/lib/uaccess_pt.c
