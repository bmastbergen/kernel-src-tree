ixgbevf: Add bit to mark work queue initialization

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Mark Rustad <mark.d.rustad@intel.com>
commit ea699569b150daa5d5f6c23040da997b83e4cfa3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/ea699569.failed

An indication of work queue initialization is needed. This is
because register accesses prior to that time can detect a removal
and attempt to schedule the watchdog task. Adding the
__IXGBEVF_WORK_INIT bit allows this to be checked and if not
set prevent the watchdog task scheduling. By checking for a
removal right after initialization, the probe can be failed
at that point without getting the watchdog task involved.

	Signed-off-by: Mark Rustad <mark.d.rustad@intel.com>
	Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit ea699569b150daa5d5f6c23040da997b83e4cfa3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbevf/ixgbevf.h
#	drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c
diff --cc drivers/net/ethernet/intel/ixgbevf/ixgbevf.h
index 473539fc8dfa,a0a1de9ce238..000000000000
--- a/drivers/net/ethernet/intel/ixgbevf/ixgbevf.h
+++ b/drivers/net/ethernet/intel/ixgbevf/ixgbevf.h
@@@ -401,7 -418,10 +401,14 @@@ struct ixgbevf_adapter 
  enum ixbgevf_state_t {
  	__IXGBEVF_TESTING,
  	__IXGBEVF_RESETTING,
++<<<<<<< HEAD
 +	__IXGBEVF_DOWN
++=======
+ 	__IXGBEVF_DOWN,
+ 	__IXGBEVF_DISABLED,
+ 	__IXGBEVF_REMOVING,
+ 	__IXGBEVF_WORK_INIT,
++>>>>>>> ea699569b150 (ixgbevf: Add bit to mark work queue initialization)
  };
  
  struct ixgbevf_cb {
diff --cc drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c
index 54346386d9ca,905c26cfa600..000000000000
--- a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c
+++ b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c
@@@ -3718,10 -3673,16 +3724,17 @@@ static pci_ers_result_t ixgbevf_io_erro
  	struct net_device *netdev = pci_get_drvdata(pdev);
  	struct ixgbevf_adapter *adapter = netdev_priv(netdev);
  
++<<<<<<< HEAD
++=======
+ 	if (!test_bit(__IXGBEVF_WORK_INIT, &adapter->state))
+ 		return PCI_ERS_RESULT_DISCONNECT;
+ 
+ 	rtnl_lock();
++>>>>>>> ea699569b150 (ixgbevf: Add bit to mark work queue initialization)
  	netif_device_detach(netdev);
  
 -	if (state == pci_channel_io_perm_failure) {
 -		rtnl_unlock();
 +	if (state == pci_channel_io_perm_failure)
  		return PCI_ERS_RESULT_DISCONNECT;
 -	}
  
  	if (netif_running(netdev))
  		ixgbevf_down(adapter);
* Unmerged path drivers/net/ethernet/intel/ixgbevf/ixgbevf.h
* Unmerged path drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c
