bridge: Add filtering support for default_pvid

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Vlad Yasevich <vyasevich@gmail.com>
commit 5be5a2df40f005ea7fb7e280e87bbbcfcf1c2fc0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5be5a2df.failed

Currently when vlan filtering is turned on on the bridge, the bridge
will drop all traffic untill the user configures the filter.  This
isn't very nice for ports that don't care about vlans and just
want untagged traffic.

A concept of a default_pvid was recently introduced.  This patch
adds filtering support for default_pvid.   Now, ports that don't
care about vlans and don't define there own filter will belong
to the VLAN of the default_pvid and continue to receive untagged
traffic.

This filtering can be disabled by setting default_pvid to 0.

	Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5be5a2df40f005ea7fb7e280e87bbbcfcf1c2fc0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_if.c
#	net/bridge/br_private.h
#	net/bridge/br_vlan.c
diff --cc net/bridge/br_if.c
index 0a55727b8233,ed307db7a12b..000000000000
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@@ -383,8 -490,19 +383,20 @@@ int br_add_if(struct net_bridge *br, st
  
  	list_add_rcu(&p->list, &br->port_list);
  
 -	nbp_update_port_count(br);
 -
  	netdev_update_features(br->dev);
  
++<<<<<<< HEAD
++=======
+ 	if (br->dev->needed_headroom < dev->needed_headroom)
+ 		br->dev->needed_headroom = dev->needed_headroom;
+ 
+ 	if (br_fdb_insert(br, p, dev->dev_addr, 0))
+ 		netdev_err(dev, "failed insert local address bridge forwarding table\n");
+ 
+ 	if (nbp_vlan_init(p))
+ 		netdev_err(dev, "failed to initialize vlan filtering on this port\n");
+ 
++>>>>>>> 5be5a2df40f0 (bridge: Add filtering support for default_pvid)
  	spin_lock_bh(&br->lock);
  	changed_addr = br_stp_recalculate_bridge_id(br);
  
diff --cc net/bridge/br_private.h
index 10b5654d52ef,d8cbaa694227..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -611,22 -590,28 +611,47 @@@ static inline void br_mdb_uninit(void
  
  /* br_vlan.c */
  #ifdef CONFIG_BRIDGE_VLAN_FILTERING
++<<<<<<< HEAD
 +extern bool br_allowed_ingress(struct net_bridge *br, struct net_port_vlans *v,
 +			       struct sk_buff *skb, u16 *vid);
 +extern bool br_allowed_egress(struct net_bridge *br,
 +			      const struct net_port_vlans *v,
 +			      const struct sk_buff *skb);
 +extern struct sk_buff *br_handle_vlan(struct net_bridge *br,
 +				      const struct net_port_vlans *v,
 +				      struct sk_buff *skb);
 +extern int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
 +extern int br_vlan_delete(struct net_bridge *br, u16 vid);
 +extern void br_vlan_flush(struct net_bridge *br);
 +extern int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 +extern int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
 +extern int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 +extern void nbp_vlan_flush(struct net_bridge_port *port);
 +extern bool nbp_vlan_find(struct net_bridge_port *port, u16 vid);
++=======
+ bool br_allowed_ingress(struct net_bridge *br, struct net_port_vlans *v,
+ 			struct sk_buff *skb, u16 *vid);
+ bool br_allowed_egress(struct net_bridge *br, const struct net_port_vlans *v,
+ 		       const struct sk_buff *skb);
+ bool br_should_learn(struct net_bridge_port *p, struct sk_buff *skb, u16 *vid);
+ struct sk_buff *br_handle_vlan(struct net_bridge *br,
+ 			       const struct net_port_vlans *v,
+ 			       struct sk_buff *skb);
+ int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
+ int br_vlan_delete(struct net_bridge *br, u16 vid);
+ void br_vlan_flush(struct net_bridge *br);
+ bool br_vlan_find(struct net_bridge *br, u16 vid);
+ void br_recalculate_fwd_mask(struct net_bridge *br);
+ int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
+ int br_vlan_set_proto(struct net_bridge *br, unsigned long val);
+ int br_vlan_init(struct net_bridge *br);
+ int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val);
+ int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
+ int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
+ void nbp_vlan_flush(struct net_bridge_port *port);
+ bool nbp_vlan_find(struct net_bridge_port *port, u16 vid);
+ int nbp_vlan_init(struct net_bridge_port *port);
++>>>>>>> 5be5a2df40f0 (bridge: Add filtering support for default_pvid)
  
  static inline struct net_port_vlans *br_get_vlan_info(
  						const struct net_bridge *br)
@@@ -659,13 -644,17 +684,19 @@@ static inline int br_vlan_get_tag(cons
  
  static inline u16 br_get_pvid(const struct net_port_vlans *v)
  {
++<<<<<<< HEAD
 +	/* Return just the VID if it is set, or VLAN_N_VID (invalid vid) if
 +	 * vid wasn't set
 +	 */
++=======
+ 	if (!v)
+ 		return 0;
+ 
++>>>>>>> 5be5a2df40f0 (bridge: Add filtering support for default_pvid)
  	smp_rmb();
 -	return v->pvid;
 +	return v->pvid ?: VLAN_N_VID;
  }
  
 -static inline int br_vlan_enabled(struct net_bridge *br)
 -{
 -	return br->vlan_enabled;
 -}
  #else
  static inline bool br_allowed_ingress(struct net_bridge *br,
  				      struct net_port_vlans *v,
@@@ -703,6 -698,20 +734,23 @@@ static inline void br_vlan_flush(struc
  {
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool br_vlan_find(struct net_bridge *br, u16 vid)
+ {
+ 	return false;
+ }
+ 
+ static inline void br_recalculate_fwd_mask(struct net_bridge *br)
+ {
+ }
+ 
+ static inline int br_vlan_init(struct net_bridge *br)
+ {
+ 	return 0;
+ }
+ 
++>>>>>>> 5be5a2df40f0 (bridge: Add filtering support for default_pvid)
  static inline int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags)
  {
  	return -EOPNOTSUPP;
diff --cc net/bridge/br_vlan.c
index c5c15c7d9539,150048fb99b0..000000000000
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@@ -307,6 -431,211 +307,214 @@@ unlock
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ int br_vlan_set_proto(struct net_bridge *br, unsigned long val)
+ {
+ 	int err = 0;
+ 	struct net_bridge_port *p;
+ 	struct net_port_vlans *pv;
+ 	__be16 proto, oldproto;
+ 	u16 vid, errvid;
+ 
+ 	if (val != ETH_P_8021Q && val != ETH_P_8021AD)
+ 		return -EPROTONOSUPPORT;
+ 
+ 	if (!rtnl_trylock())
+ 		return restart_syscall();
+ 
+ 	proto = htons(val);
+ 	if (br->vlan_proto == proto)
+ 		goto unlock;
+ 
+ 	/* Add VLANs for the new proto to the device filter. */
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		pv = rtnl_dereference(p->vlan_info);
+ 		if (!pv)
+ 			continue;
+ 
+ 		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {
+ 			err = vlan_vid_add(p->dev, proto, vid);
+ 			if (err)
+ 				goto err_filt;
+ 		}
+ 	}
+ 
+ 	oldproto = br->vlan_proto;
+ 	br->vlan_proto = proto;
+ 
+ 	recalculate_group_addr(br);
+ 	br_recalculate_fwd_mask(br);
+ 
+ 	/* Delete VLANs for the old proto from the device filter. */
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		pv = rtnl_dereference(p->vlan_info);
+ 		if (!pv)
+ 			continue;
+ 
+ 		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID)
+ 			vlan_vid_del(p->dev, oldproto, vid);
+ 	}
+ 
+ unlock:
+ 	rtnl_unlock();
+ 	return err;
+ 
+ err_filt:
+ 	errvid = vid;
+ 	for_each_set_bit(vid, pv->vlan_bitmap, errvid)
+ 		vlan_vid_del(p->dev, proto, vid);
+ 
+ 	list_for_each_entry_continue_reverse(p, &br->port_list, list) {
+ 		pv = rtnl_dereference(p->vlan_info);
+ 		if (!pv)
+ 			continue;
+ 
+ 		for_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID)
+ 			vlan_vid_del(p->dev, proto, vid);
+ 	}
+ 
+ 	goto unlock;
+ }
+ 
+ static bool vlan_default_pvid(struct net_port_vlans *pv, u16 vid)
+ {
+ 	return pv && vid == pv->pvid && test_bit(vid, pv->untagged_bitmap);
+ }
+ 
+ static void br_vlan_disable_default_pvid(struct net_bridge *br)
+ {
+ 	struct net_bridge_port *p;
+ 	u16 pvid = br->default_pvid;
+ 
+ 	/* Disable default_pvid on all ports where it is still
+ 	 * configured.
+ 	 */
+ 	if (vlan_default_pvid(br_get_vlan_info(br), pvid))
+ 		br_vlan_delete(br, pvid);
+ 
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		if (vlan_default_pvid(nbp_get_vlan_info(p), pvid))
+ 			nbp_vlan_delete(p, pvid);
+ 	}
+ 
+ 	br->default_pvid = 0;
+ }
+ 
+ static int __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid)
+ {
+ 	struct net_bridge_port *p;
+ 	u16 old_pvid;
+ 	int err = 0;
+ 	unsigned long *changed;
+ 
+ 	changed = kcalloc(BITS_TO_LONGS(BR_MAX_PORTS), sizeof(unsigned long),
+ 			  GFP_KERNEL);
+ 	if (!changed)
+ 		return -ENOMEM;
+ 
+ 	old_pvid = br->default_pvid;
+ 
+ 	/* Update default_pvid config only if we do not conflict with
+ 	 * user configuration.
+ 	 */
+ 	if ((!old_pvid || vlan_default_pvid(br_get_vlan_info(br), old_pvid)) &&
+ 	    !br_vlan_find(br, pvid)) {
+ 		err = br_vlan_add(br, pvid,
+ 				  BRIDGE_VLAN_INFO_PVID |
+ 				  BRIDGE_VLAN_INFO_UNTAGGED);
+ 		if (err)
+ 			goto out;
+ 		br_vlan_delete(br, old_pvid);
+ 		set_bit(0, changed);
+ 	}
+ 
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		/* Update default_pvid config only if we do not conflict with
+ 		 * user configuration.
+ 		 */
+ 		if ((old_pvid &&
+ 		     !vlan_default_pvid(nbp_get_vlan_info(p), old_pvid)) ||
+ 		    nbp_vlan_find(p, pvid))
+ 			continue;
+ 
+ 		err = nbp_vlan_add(p, pvid,
+ 				   BRIDGE_VLAN_INFO_PVID |
+ 				   BRIDGE_VLAN_INFO_UNTAGGED);
+ 		if (err)
+ 			goto err_port;
+ 		nbp_vlan_delete(p, old_pvid);
+ 		set_bit(p->port_no, changed);
+ 	}
+ 
+ 	br->default_pvid = pvid;
+ 
+ out:
+ 	kfree(changed);
+ 	return err;
+ 
+ err_port:
+ 	list_for_each_entry_continue_reverse(p, &br->port_list, list) {
+ 		if (!test_bit(p->port_no, changed))
+ 			continue;
+ 
+ 		if (old_pvid)
+ 			nbp_vlan_add(p, old_pvid,
+ 				     BRIDGE_VLAN_INFO_PVID |
+ 				     BRIDGE_VLAN_INFO_UNTAGGED);
+ 		nbp_vlan_delete(p, pvid);
+ 	}
+ 
+ 	if (test_bit(0, changed)) {
+ 		if (old_pvid)
+ 			br_vlan_add(br, old_pvid,
+ 				    BRIDGE_VLAN_INFO_PVID |
+ 				    BRIDGE_VLAN_INFO_UNTAGGED);
+ 		br_vlan_delete(br, pvid);
+ 	}
+ 	goto out;
+ }
+ 
+ int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val)
+ {
+ 	u16 pvid = val;
+ 	int err = 0;
+ 
+ 	if (val >= VLAN_VID_MASK)
+ 		return -EINVAL;
+ 
+ 	if (!rtnl_trylock())
+ 		return restart_syscall();
+ 
+ 	if (pvid == br->default_pvid)
+ 		goto unlock;
+ 
+ 	/* Only allow default pvid change when filtering is disabled */
+ 	if (br->vlan_enabled) {
+ 		pr_info_once("Please disable vlan filtering to change default_pvid\n");
+ 		err = -EPERM;
+ 		goto unlock;
+ 	}
+ 
+ 	if (!pvid)
+ 		br_vlan_disable_default_pvid(br);
+ 	else
+ 		err = __br_vlan_set_default_pvid(br, pvid);
+ 
+ unlock:
+ 	rtnl_unlock();
+ 	return err;
+ }
+ 
+ int br_vlan_init(struct net_bridge *br)
+ {
+ 	br->vlan_proto = htons(ETH_P_8021Q);
+ 	br->default_pvid = 1;
+ 	return br_vlan_add(br, 1,
+ 			   BRIDGE_VLAN_INFO_PVID | BRIDGE_VLAN_INFO_UNTAGGED);
+ }
+ 
++>>>>>>> 5be5a2df40f0 (bridge: Add filtering support for default_pvid)
  /* Must be protected by RTNL.
   * Must be called with vid in range from 1 to 4094 inclusive.
   */
diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c
index 38068a9ebc44..b9f82f65828f 100644
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@ -88,12 +88,17 @@ out:
 static int br_dev_init(struct net_device *dev)
 {
 	struct net_bridge *br = netdev_priv(dev);
+	int err;
 
 	br->stats = alloc_percpu(struct br_cpu_netstats);
 	if (!br->stats)
 		return -ENOMEM;
 
-	return 0;
+	err = br_vlan_init(br);
+	if (err)
+		free_percpu(br->stats);
+
+	return err;
 }
 
 static int br_dev_open(struct net_device *dev)
* Unmerged path net/bridge/br_if.c
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_vlan.c
