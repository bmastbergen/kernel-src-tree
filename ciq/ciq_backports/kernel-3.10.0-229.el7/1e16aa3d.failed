net: gso: use feature flag argument in all protocol gso handlers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] gso: use feature flag argument in all protocol gso handlers (Jiri Benc) [1144571]
Rebuild_FUZZ: 95.93%
commit-author Florian Westphal <fw@strlen.de>
commit 1e16aa3ddf863c6b9f37eddf52503230a62dedb3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/1e16aa3d.failed

skb_gso_segment() has a 'features' argument representing offload features
available to the output path.

A few handlers, e.g. GRE, instead re-fetch the features of skb->dev and use
those instead of the provided ones when handing encapsulation/tunnels.

Depending on dev->hw_enc_features of the output device skb_gso_segment() can
then return NULL even when the caller has disabled all GSO feature bits,
as segmentation of inner header thinks device will take care of segmentation.

This e.g. affects the tbf scheduler, which will silently drop GRE-encap GSO skbs
that did not fit the remaining token quota as the segmentation does not work
when device supports corresponding hw offload capabilities.

	Cc: Pravin B Shelar <pshelar@nicira.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1e16aa3ddf863c6b9f37eddf52503230a62dedb3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp_offload.c
#	net/ipv6/ip6_offload.c
diff --cc net/ipv4/udp_offload.c
index 1d2f12fcbc52,6480cea7aa53..000000000000
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@@ -25,26 -25,121 +25,58 @@@ struct udp_offload_priv 
  	struct udp_offload_priv __rcu *next;
  };
  
 -static struct sk_buff *__skb_udp_tunnel_segment(struct sk_buff *skb,
 -	netdev_features_t features,
 -	struct sk_buff *(*gso_inner_segment)(struct sk_buff *skb,
 -					     netdev_features_t features),
 -	__be16 new_protocol)
 +static int udp4_ufo_send_check(struct sk_buff *skb)
  {
 -	struct sk_buff *segs = ERR_PTR(-EINVAL);
 -	u16 mac_offset = skb->mac_header;
 -	int mac_len = skb->mac_len;
 -	int tnl_hlen = skb_inner_mac_header(skb) - skb_transport_header(skb);
 -	__be16 protocol = skb->protocol;
 -	netdev_features_t enc_features;
 -	int udp_offset, outer_hlen;
 -	unsigned int oldlen;
 -	bool need_csum;
 +	if (!pskb_may_pull(skb, sizeof(struct udphdr)))
 +		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (likely(!skb->encapsulation)) {
 +		const struct iphdr *iph;
++=======
+ 	oldlen = (u16)~skb->len;
+ 
+ 	if (unlikely(!pskb_may_pull(skb, tnl_hlen)))
+ 		goto out;
+ 
+ 	skb->encapsulation = 0;
+ 	__skb_pull(skb, tnl_hlen);
+ 	skb_reset_mac_header(skb);
+ 	skb_set_network_header(skb, skb_inner_network_offset(skb));
+ 	skb->mac_len = skb_inner_network_offset(skb);
+ 	skb->protocol = new_protocol;
+ 
+ 	need_csum = !!(skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL_CSUM);
+ 	if (need_csum)
+ 		skb->encap_hdr_csum = 1;
+ 
+ 	/* segment inner packet. */
+ 	enc_features = skb->dev->hw_enc_features & features;
+ 	segs = gso_inner_segment(skb, enc_features);
+ 	if (IS_ERR_OR_NULL(segs)) {
+ 		skb_gso_error_unwind(skb, protocol, tnl_hlen, mac_offset,
+ 				     mac_len);
+ 		goto out;
+ 	}
+ 
+ 	outer_hlen = skb_tnl_header_len(skb);
+ 	udp_offset = outer_hlen - tnl_hlen;
+ 	skb = segs;
+ 	do {
++>>>>>>> 1e16aa3ddf86 (net: gso: use feature flag argument in all protocol gso handlers)
  		struct udphdr *uh;
 -		int len;
 -
 -		skb_reset_inner_headers(skb);
 -		skb->encapsulation = 1;
  
 -		skb->mac_len = mac_len;
 -
 -		skb_push(skb, outer_hlen);
 -		skb_reset_mac_header(skb);
 -		skb_set_network_header(skb, mac_len);
 -		skb_set_transport_header(skb, udp_offset);
 -		len = skb->len - udp_offset;
 +		iph = ip_hdr(skb);
  		uh = udp_hdr(skb);
 -		uh->len = htons(len);
 -
 -		if (need_csum) {
 -			__be32 delta = htonl(oldlen + len);
 -
 -			uh->check = ~csum_fold((__force __wsum)
 -					       ((__force u32)uh->check +
 -						(__force u32)delta));
 -			uh->check = gso_make_checksum(skb, ~uh->check);
 -
 -			if (uh->check == 0)
 -				uh->check = CSUM_MANGLED_0;
 -		}
 -
 -		skb->protocol = protocol;
 -	} while ((skb = skb->next));
 -out:
 -	return segs;
 -}
  
 -struct sk_buff *skb_udp_tunnel_segment(struct sk_buff *skb,
 -				       netdev_features_t features,
 -				       bool is_ipv6)
 -{
 -	__be16 protocol = skb->protocol;
 -	const struct net_offload **offloads;
 -	const struct net_offload *ops;
 -	struct sk_buff *segs = ERR_PTR(-EINVAL);
 -	struct sk_buff *(*gso_inner_segment)(struct sk_buff *skb,
 -					     netdev_features_t features);
 -
 -	rcu_read_lock();
 -
 -	switch (skb->inner_protocol_type) {
 -	case ENCAP_TYPE_ETHER:
 -		protocol = skb->inner_protocol;
 -		gso_inner_segment = skb_mac_gso_segment;
 -		break;
 -	case ENCAP_TYPE_IPPROTO:
 -		offloads = is_ipv6 ? inet6_offloads : inet_offloads;
 -		ops = rcu_dereference(offloads[skb->inner_ipproto]);
 -		if (!ops || !ops->callbacks.gso_segment)
 -			goto out_unlock;
 -		gso_inner_segment = ops->callbacks.gso_segment;
 -		break;
 -	default:
 -		goto out_unlock;
 +		uh->check = ~csum_tcpudp_magic(iph->saddr, iph->daddr, skb->len,
 +				IPPROTO_UDP, 0);
 +		skb->csum_start = skb_transport_header(skb) - skb->head;
 +		skb->csum_offset = offsetof(struct udphdr, check);
 +		skb->ip_summed = CHECKSUM_PARTIAL;
  	}
  
 -	segs = __skb_udp_tunnel_segment(skb, features, gso_inner_segment,
 -					protocol);
 -
 -out_unlock:
 -	rcu_read_unlock();
 -
 -	return segs;
 +	return 0;
  }
  
  static struct sk_buff *udp4_ufo_fragment(struct sk_buff *skb,
diff --cc net/ipv6/ip6_offload.c
index c12d5c7a859a,a071563a7e6e..000000000000
--- a/net/ipv6/ip6_offload.c
+++ b/net/ipv6/ip6_offload.c
@@@ -114,9 -88,9 +114,15 @@@ static struct sk_buff *ipv6_gso_segment
  	if (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))
  		goto out;
  
++<<<<<<< HEAD
 +	tunnel = SKB_GSO_CB(skb)->encap_level > 0;
 +	if (tunnel)
 +		features = skb->dev->hw_enc_features & netif_skb_features(skb);
++=======
+ 	encap = SKB_GSO_CB(skb)->encap_level > 0;
+ 	if (encap)
+ 		features &= skb->dev->hw_enc_features;
++>>>>>>> 1e16aa3ddf86 (net: gso: use feature flag argument in all protocol gso handlers)
  	SKB_GSO_CB(skb)->encap_level += sizeof(*ipv6h);
  
  	ipv6h = ipv6_hdr(skb);
diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c
index b64f59dcda8d..b2ae6a00be41 100644
--- a/net/ipv4/af_inet.c
+++ b/net/ipv4/af_inet.c
@@ -1321,7 +1321,7 @@ static struct sk_buff *inet_gso_segment(struct sk_buff *skb,
 
 	encap = SKB_GSO_CB(skb)->encap_level > 0;
 	if (encap)
-		features = skb->dev->hw_enc_features & netif_skb_features(skb);
+		features &= skb->dev->hw_enc_features;
 	SKB_GSO_CB(skb)->encap_level += ihl;
 
 	skb_reset_transport_header(skb);
diff --git a/net/ipv4/gre_offload.c b/net/ipv4/gre_offload.c
index df0559ff857a..76c92d8f5890 100644
--- a/net/ipv4/gre_offload.c
+++ b/net/ipv4/gre_offload.c
@@ -72,7 +72,7 @@ static struct sk_buff *gre_gso_segment(struct sk_buff *skb,
 	skb->mac_len = skb_inner_network_offset(skb);
 
 	/* segment inner packet. */
-	enc_features = skb->dev->hw_enc_features & netif_skb_features(skb);
+	enc_features = skb->dev->hw_enc_features & features;
 	segs = skb_mac_gso_segment(skb, enc_features);
 	if (IS_ERR_OR_NULL(segs)) {
 		skb_gso_error_unwind(skb, protocol, ghl, mac_offset, mac_len);
* Unmerged path net/ipv4/udp_offload.c
* Unmerged path net/ipv6/ip6_offload.c
diff --git a/net/mpls/mpls_gso.c b/net/mpls/mpls_gso.c
index 6b38d083e1c9..fefda6cc61fa 100644
--- a/net/mpls/mpls_gso.c
+++ b/net/mpls/mpls_gso.c
@@ -48,7 +48,7 @@ static struct sk_buff *mpls_gso_segment(struct sk_buff *skb,
 	__skb_push(skb, skb->mac_len);
 
 	/* Segment inner packet. */
-	mpls_features = skb->dev->mpls_features & netif_skb_features(skb);
+	mpls_features = skb->dev->mpls_features & features;
 	segs = skb_mac_gso_segment(skb, mpls_features);
 
 
