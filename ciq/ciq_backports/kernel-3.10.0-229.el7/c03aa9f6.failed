udf: Avoid infinite loop when processing indirect ICBs

jira LE-1907
cve CVE-2014-6410
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Jan Kara <jack@suse.cz>
commit c03aa9f6e1f938618e6db2e23afef0574efeeb65
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/c03aa9f6.failed

We did not implement any bound on number of indirect ICBs we follow when
loading inode. Thus corrupted medium could cause kernel to go into an
infinite loop, possibly causing a stack overflow.

Fix the possible stack overflow by removing recursion from
__udf_read_inode() and limit number of indirect ICBs we follow to avoid
infinite loops.

	Signed-off-by: Jan Kara <jack@suse.cz>
(cherry picked from commit c03aa9f6e1f938618e6db2e23afef0574efeeb65)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/udf/inode.c
diff --cc fs/udf/inode.c
index d1842c5da202,a6a40536ebf1..000000000000
--- a/fs/udf/inode.c
+++ b/fs/udf/inode.c
@@@ -1274,9 -1281,14 +1281,16 @@@ static void __udf_read_inode(struct ino
  {
  	struct buffer_head *bh = NULL;
  	struct fileEntry *fe;
 -	struct extendedFileEntry *efe;
  	uint16_t ident;
  	struct udf_inode_info *iinfo = UDF_I(inode);
++<<<<<<< HEAD
++=======
+ 	struct udf_sb_info *sbi = UDF_SB(inode->i_sb);
+ 	unsigned int link_count;
+ 	unsigned int indirections = 0;
++>>>>>>> c03aa9f6e1f9 (udf: Avoid infinite loop when processing indirect ICBs)
  
+ reread:
  	/*
  	 * Set defaults, but the inode is still incomplete!
  	 * Note: get_new_inode() sets the following on a new inode:
* Unmerged path fs/udf/inode.c
