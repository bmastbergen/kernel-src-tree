uprobes/x86: Teach arch_uprobe_post_xol() to restart if possible

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [kernel] uprobes: Teach arch_uprobe_post_xol() to restart if possible (Oleg Nesterov) [1073627]
Rebuild_FUZZ: 96.77%
commit-author Oleg Nesterov <oleg@redhat.com>
commit 75f9ef0b7f1aae33b7be7ba8d9c23c8cb48c2212
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/75f9ef0b.failed

SIGILL after the failed arch_uprobe_post_xol() should only be used as
a last resort, we should try to restart the probed insn if possible.

Currently only adjust_ret_addr() can fail, and this can only happen if
another thread unmapped our stack after we executed "call" out-of-line.
Most probably the application if buggy, but even in this case it can
have a handler for SIGSEGV/etc. And in theory it can be even correct
and do something non-trivial with its memory.

Of course we can't restart unconditionally, so arch_uprobe_post_xol()
does this only if ->post_xol() returns -ERESTART even if currently this
is the only possible error.

default_post_xol_op(UPROBE_FIX_CALL) can always restart, but as Jim
pointed out it should not forget to pop off the return address pushed
by this insn executed out-of-line.

Note: this is not "perfect", we do not want the extra handler_chain()
after restart, but I think this is the best solution we can realistically
do without too much uglifications.

	Signed-off-by: Oleg Nesterov <oleg@redhat.com>
	Reviewed-by: Masami Hiramatsu <masami.hiramatsu.pt@hitachi.com>
	Reviewed-by: Jim Keniston <jkenisto@us.ibm.com>
(cherry picked from commit 75f9ef0b7f1aae33b7be7ba8d9c23c8cb48c2212)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/uprobes.c
diff --cc arch/x86/kernel/uprobes.c
index 7ea7d2b3594b,cdd6909affcb..000000000000
--- a/arch/x86/kernel/uprobes.c
+++ b/arch/x86/kernel/uprobes.c
@@@ -402,6 -402,70 +402,73 @@@ static int validate_insn_bits(struct ar
  }
  #endif /* CONFIG_X86_64 */
  
++<<<<<<< HEAD
++=======
+ struct uprobe_xol_ops {
+ 	bool	(*emulate)(struct arch_uprobe *, struct pt_regs *);
+ 	int	(*pre_xol)(struct arch_uprobe *, struct pt_regs *);
+ 	int	(*post_xol)(struct arch_uprobe *, struct pt_regs *);
+ };
+ 
+ static int default_pre_xol_op(struct arch_uprobe *auprobe, struct pt_regs *regs)
+ {
+ 	pre_xol_rip_insn(auprobe, regs, &current->utask->autask);
+ 	return 0;
+ }
+ 
+ /*
+  * Adjust the return address pushed by a call insn executed out of line.
+  */
+ static int adjust_ret_addr(unsigned long sp, long correction)
+ {
+ 	int rasize, ncopied;
+ 	long ra = 0;
+ 
+ 	if (is_ia32_task())
+ 		rasize = 4;
+ 	else
+ 		rasize = 8;
+ 
+ 	ncopied = copy_from_user(&ra, (void __user *)sp, rasize);
+ 	if (unlikely(ncopied))
+ 		return -EFAULT;
+ 
+ 	ra += correction;
+ 	ncopied = copy_to_user((void __user *)sp, &ra, rasize);
+ 	if (unlikely(ncopied))
+ 		return -EFAULT;
+ 
+ 	return 0;
+ }
+ 
+ static int default_post_xol_op(struct arch_uprobe *auprobe, struct pt_regs *regs)
+ {
+ 	struct uprobe_task *utask = current->utask;
+ 	long correction = (long)(utask->vaddr - utask->xol_vaddr);
+ 
+ 	handle_riprel_post_xol(auprobe, regs, &correction);
+ 	if (auprobe->fixups & UPROBE_FIX_IP)
+ 		regs->ip += correction;
+ 
+ 	if (auprobe->fixups & UPROBE_FIX_CALL) {
+ 		if (adjust_ret_addr(regs->sp, correction)) {
+ 			if (is_ia32_task())
+ 				regs->sp += 4;
+ 			else
+ 				regs->sp += 8;
+ 			return -ERESTART;
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static struct uprobe_xol_ops default_xol_ops = {
+ 	.pre_xol  = default_pre_xol_op,
+ 	.post_xol = default_post_xol_op,
+ };
+ 
++>>>>>>> 75f9ef0b7f1a (uprobes/x86: Teach arch_uprobe_post_xol() to restart if possible)
  /**
   * arch_uprobe_analyze_insn - instruction analysis including validity and fixups.
   * @mm: the probed address space.
@@@ -563,6 -601,20 +630,23 @@@ int arch_uprobe_post_xol(struct arch_up
  
  	WARN_ON_ONCE(current->thread.trap_nr != UPROBE_TRAP_NR);
  
++<<<<<<< HEAD
++=======
+ 	if (auprobe->ops->post_xol) {
+ 		int err = auprobe->ops->post_xol(auprobe, regs);
+ 		if (err) {
+ 			arch_uprobe_abort_xol(auprobe, regs);
+ 			/*
+ 			 * Restart the probed insn. ->post_xol() must ensure
+ 			 * this is really possible if it returns -ERESTART.
+ 			 */
+ 			if (err == -ERESTART)
+ 				return 0;
+ 			return err;
+ 		}
+ 	}
+ 
++>>>>>>> 75f9ef0b7f1a (uprobes/x86: Teach arch_uprobe_post_xol() to restart if possible)
  	current->thread.trap_nr = utask->autask.saved_trap_nr;
  	/*
  	 * arch_uprobe_pre_xol() doesn't save the state of TIF_BLOCKSTEP
* Unmerged path arch/x86/kernel/uprobes.c
