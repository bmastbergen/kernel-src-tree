virtio_net: don't crash if virtqueue is broken.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] virtio_net: don't crash if virtqueue is broken (Hendrik Brueckner) [1088554]
Rebuild_FUZZ: 98.92%
commit-author Rusty Russell <rusty@rustcorp.com.au>
commit a7c58146cf9a782113629021ba5420582fef265e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a7c58146.failed

A bad implementation of virtio might cause us to mark the virtqueue
broken: we'll dev_err() in that case, and the device is useless, but
let's not BUG_ON().

	Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
(cherry picked from commit a7c58146cf9a782113629021ba5420582fef265e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/virtio_net.c
diff --cc drivers/net/virtio_net.c
index ddc1d2b10b59,274e99722e35..000000000000
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@@ -855,13 -935,13 +855,18 @@@ static bool virtnet_send_command(struc
  
  	/* Add return status. */
  	sg_init_one(&stat, &status, sizeof(status));
 -	sgs[out_num] = &stat;
 +	sgs[out_num + in_num++] = &stat;
  
++<<<<<<< HEAD
 +	BUG_ON(out_num + in_num > ARRAY_SIZE(sgs));
 +	BUG_ON(virtqueue_add_sgs(vi->cvq, sgs, out_num, in_num, vi, GFP_ATOMIC)
 +	       < 0);
++=======
+ 	BUG_ON(out_num + 1 > ARRAY_SIZE(sgs));
+ 	virtqueue_add_sgs(vi->cvq, sgs, out_num, 1, vi, GFP_ATOMIC);
++>>>>>>> a7c58146cf9a (virtio_net: don't crash if virtqueue is broken.)
  
 -	if (unlikely(!virtqueue_kick(vi->cvq)))
 -		return status == VIRTIO_NET_OK;
 +	virtqueue_kick(vi->cvq);
  
  	/* Spin for a response, the kick causes an ioport write, trapping
  	 * into the hypervisor, so the request should be handled immediately.
* Unmerged path drivers/net/virtio_net.c
