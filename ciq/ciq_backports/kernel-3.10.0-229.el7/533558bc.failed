KVM: nVMX: Pass vmexit parameters to nested_vmx_vmexit

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/nvmx: Pass vmexit parameters to nested_vmx_vmexit (Paolo Bonzini) [1116936]
Rebuild_FUZZ: 97.20%
commit-author Jan Kiszka <jan.kiszka@siemens.com>
commit 533558bcb69ef28aff81b6ae9acda8943575319f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/533558bc.failed

Instead of fixing up the vmcs12 after the nested vmexit, pass key
parameters already when calling nested_vmx_vmexit. This will help
tracing those vmexits.

	Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 533558bcb69ef28aff81b6ae9acda8943575319f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/vmx.c
diff --cc arch/x86/kvm/vmx.c
index aa0d9234664b,e3578b301d81..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -7522,6 -7586,61 +7521,64 @@@ static void vmx_set_supported_cpuid(u3
  		entry->ecx |= bit(X86_FEATURE_VMX);
  }
  
++<<<<<<< HEAD
++=======
+ static void nested_ept_inject_page_fault(struct kvm_vcpu *vcpu,
+ 		struct x86_exception *fault)
+ {
+ 	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
+ 	u32 exit_reason;
+ 
+ 	if (fault->error_code & PFERR_RSVD_MASK)
+ 		exit_reason = EXIT_REASON_EPT_MISCONFIG;
+ 	else
+ 		exit_reason = EXIT_REASON_EPT_VIOLATION;
+ 	nested_vmx_vmexit(vcpu, exit_reason, 0, vcpu->arch.exit_qualification);
+ 	vmcs12->guest_physical_address = fault->address;
+ }
+ 
+ /* Callbacks for nested_ept_init_mmu_context: */
+ 
+ static unsigned long nested_ept_get_cr3(struct kvm_vcpu *vcpu)
+ {
+ 	/* return the page table to be shadowed - in our case, EPT12 */
+ 	return get_vmcs12(vcpu)->ept_pointer;
+ }
+ 
+ static void nested_ept_init_mmu_context(struct kvm_vcpu *vcpu)
+ {
+ 	kvm_init_shadow_ept_mmu(vcpu, &vcpu->arch.mmu,
+ 			nested_vmx_ept_caps & VMX_EPT_EXECUTE_ONLY_BIT);
+ 
+ 	vcpu->arch.mmu.set_cr3           = vmx_set_cr3;
+ 	vcpu->arch.mmu.get_cr3           = nested_ept_get_cr3;
+ 	vcpu->arch.mmu.inject_page_fault = nested_ept_inject_page_fault;
+ 
+ 	vcpu->arch.walk_mmu              = &vcpu->arch.nested_mmu;
+ }
+ 
+ static void nested_ept_uninit_mmu_context(struct kvm_vcpu *vcpu)
+ {
+ 	vcpu->arch.walk_mmu = &vcpu->arch.mmu;
+ }
+ 
+ static void vmx_inject_page_fault_nested(struct kvm_vcpu *vcpu,
+ 		struct x86_exception *fault)
+ {
+ 	struct vmcs12 *vmcs12 = get_vmcs12(vcpu);
+ 
+ 	WARN_ON(!is_guest_mode(vcpu));
+ 
+ 	/* TODO: also check PFEC_MATCH/MASK, not just EB.PF. */
+ 	if (vmcs12->exception_bitmap & (1u << PF_VECTOR))
+ 		nested_vmx_vmexit(vcpu, to_vmx(vcpu)->exit_reason,
+ 				  vmcs_read32(VM_EXIT_INTR_INFO),
+ 				  vmcs_readl(EXIT_QUALIFICATION));
+ 	else
+ 		kvm_inject_page_fault(vcpu, fault);
+ }
+ 
++>>>>>>> 533558bcb69e (KVM: nVMX: Pass vmexit parameters to nested_vmx_vmexit)
  /*
   * prepare_vmcs02 is called when the L1 guest hypervisor runs its nested
   * L2 guest. L1 has a vmcs for L2 (vmcs12), and this function "merges" it
* Unmerged path arch/x86/kvm/vmx.c
