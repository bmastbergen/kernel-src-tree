drm: add a path blob property

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] add a path blob property (Dave Airlie) [1140440]
Rebuild_FUZZ: 90.57%
commit-author Dave Airlie <airlied@redhat.com>
commit 43aba7eb0dc052d84e88f3569ea3f030868d49b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/43aba7eb.failed

This property will be used by the MST code to provide userspace
with a path to parse so it can recognise connectors around hotplugs.

	Reviewed-by: Todd Previte <tprevite@gmail.com>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 43aba7eb0dc052d84e88f3569ea3f030868d49b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/drm_crtc.c
#	include/drm/drm_crtc.h
diff --cc drivers/gpu/drm/drm_crtc.c
index bff2fa941f60,bd7422676638..000000000000
--- a/drivers/gpu/drm/drm_crtc.c
+++ b/drivers/gpu/drm/drm_crtc.c
@@@ -3159,6 -3762,36 +3166,39 @@@ done
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ int drm_mode_connector_set_path_property(struct drm_connector *connector,
+ 					 char *path)
+ {
+ 	struct drm_device *dev = connector->dev;
+ 	int ret, size;
+ 	size = strlen(path) + 1;
+ 
+ 	connector->path_blob_ptr = drm_property_create_blob(connector->dev,
+ 							    size, path);
+ 	if (!connector->path_blob_ptr)
+ 		return -EINVAL;
+ 
+ 	ret = drm_object_property_set_value(&connector->base,
+ 					    dev->mode_config.path_property,
+ 					    connector->path_blob_ptr->base.id);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(drm_mode_connector_set_path_property);
+ 
+ /**
+  * drm_mode_connector_update_edid_property - update the edid property of a connector
+  * @connector: drm connector
+  * @edid: new value of the edid property
+  *
+  * This function creates a new blob modeset object and assigns its id to the
+  * connector's edid property.
+  *
+  * Returns:
+  * Zero on success, errno on failure.
+  */
++>>>>>>> 43aba7eb0dc0 (drm: add a path blob property)
  int drm_mode_connector_update_edid_property(struct drm_connector *connector,
  					    struct edid *edid)
  {
diff --cc include/drm/drm_crtc.h
index 24f499569a2f,4da62072701c..000000000000
--- a/include/drm/drm_crtc.h
+++ b/include/drm/drm_crtc.h
@@@ -867,6 -805,8 +869,11 @@@ struct drm_mode_config 
  	struct list_head property_blob_list;
  	struct drm_property *edid_property;
  	struct drm_property *dpms_property;
++<<<<<<< HEAD
++=======
+ 	struct drm_property *path_property;
+ 	struct drm_property *plane_type_property;
++>>>>>>> 43aba7eb0dc0 (drm: add a path blob property)
  
  	/* DVI-I properties */
  	struct drm_property *dvi_i_subconnector_property;
@@@ -973,28 -954,28 +980,33 @@@ extern void drm_mode_debug_printmodelin
  extern void drm_mode_config_init(struct drm_device *dev);
  extern void drm_mode_config_reset(struct drm_device *dev);
  extern void drm_mode_config_cleanup(struct drm_device *dev);
 -
 +extern void drm_mode_set_name(struct drm_display_mode *mode);
 +extern bool drm_mode_equal(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2);
 +extern bool drm_mode_equal_no_clocks(const struct drm_display_mode *mode1, const struct drm_display_mode *mode2);
 +extern int drm_mode_width(const struct drm_display_mode *mode);
 +extern int drm_mode_height(const struct drm_display_mode *mode);
 +
++<<<<<<< HEAD
 +/* for us by fb module */
 +extern struct drm_display_mode *drm_mode_create(struct drm_device *dev);
 +extern void drm_mode_destroy(struct drm_device *dev, struct drm_display_mode *mode);
 +extern void drm_mode_validate_size(struct drm_device *dev,
 +				   struct list_head *mode_list,
 +				   int maxX, int maxY, int maxPitch);
 +extern void drm_mode_prune_invalid(struct drm_device *dev,
 +				   struct list_head *mode_list, bool verbose);
 +extern void drm_mode_sort(struct list_head *mode_list);
 +extern int drm_mode_hsync(const struct drm_display_mode *mode);
 +extern int drm_mode_vrefresh(const struct drm_display_mode *mode);
 +extern void drm_mode_set_crtcinfo(struct drm_display_mode *p,
 +				  int adjust_flags);
 +extern void drm_mode_connector_list_update(struct drm_connector *connector);
++=======
+ extern int drm_mode_connector_set_path_property(struct drm_connector *connector,
+ 						char *path);
++>>>>>>> 43aba7eb0dc0 (drm: add a path blob property)
  extern int drm_mode_connector_update_edid_property(struct drm_connector *connector,
  						struct edid *edid);
 -
 -static inline bool drm_property_type_is(struct drm_property *property,
 -		uint32_t type)
 -{
 -	/* instanceof for props.. handles extended type vs original types: */
 -	if (property->flags & DRM_MODE_PROP_EXTENDED_TYPE)
 -		return (property->flags & DRM_MODE_PROP_EXTENDED_TYPE) == type;
 -	return property->flags & type;
 -}
 -
 -static inline bool drm_property_type_valid(struct drm_property *property)
 -{
 -	if (property->flags & DRM_MODE_PROP_EXTENDED_TYPE)
 -		return !(property->flags & DRM_MODE_PROP_LEGACY_TYPE);
 -	return !!(property->flags & DRM_MODE_PROP_LEGACY_TYPE);
 -}
 -
  extern int drm_object_property_set_value(struct drm_mode_object *obj,
  					 struct drm_property *property,
  					 uint64_t val);
* Unmerged path drivers/gpu/drm/drm_crtc.c
* Unmerged path include/drm/drm_crtc.h
