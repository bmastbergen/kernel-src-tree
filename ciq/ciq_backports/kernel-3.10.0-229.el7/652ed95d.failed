cpufreq: introduce cpufreq_generic_get() routine

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] introduce cpufreq_generic_get() routine (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 89.66%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 652ed95d5fa6074b3c4ea245deb0691f1acb6656
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/652ed95d.failed

CPUFreq drivers that use clock frameworks interface,i.e. clk_get_rate(),
to get CPUs clk rate, have similar sort of code used in most of them.

This patch adds a generic ->get() which will do the same thing for them.
All those drivers are required to now is to set .get to cpufreq_generic_get()
and set their clk pointer in policy->clk during ->init().

	Acked-by: Hans-Christian Egtvedt <egtvedt@samfundet.no>
	Acked-by: Shawn Guo <shawn.guo@linaro.org>
	Acked-by: Linus Walleij <linus.walleij@linaro.org>
	Acked-by: Shawn Guo <shawn.guo@linaro.org>
	Acked-by: Stephen Warren <swarren@nvidia.com>
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 652ed95d5fa6074b3c4ea245deb0691f1acb6656)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm/mach-s3c24xx/cpufreq.c
#	drivers/cpufreq/at32ap-cpufreq.c
#	drivers/cpufreq/cpufreq-cpu0.c
#	drivers/cpufreq/cpufreq.c
#	drivers/cpufreq/davinci-cpufreq.c
#	drivers/cpufreq/dbx500-cpufreq.c
#	drivers/cpufreq/exynos-cpufreq.c
#	drivers/cpufreq/exynos5440-cpufreq.c
#	drivers/cpufreq/imx6q-cpufreq.c
#	drivers/cpufreq/loongson2_cpufreq.c
#	drivers/cpufreq/omap-cpufreq.c
#	drivers/cpufreq/ppc-corenet-cpufreq.c
#	drivers/cpufreq/s3c64xx-cpufreq.c
#	drivers/cpufreq/s5pv210-cpufreq.c
#	drivers/cpufreq/spear-cpufreq.c
#	drivers/cpufreq/tegra-cpufreq.c
#	drivers/cpufreq/unicore2-cpufreq.c
#	include/linux/cpufreq.h
diff --cc arch/arm/mach-s3c24xx/cpufreq.c
index 3c0e78ede0da,25069741b507..000000000000
--- a/arch/arm/mach-s3c24xx/cpufreq.c
+++ b/arch/arm/mach-s3c24xx/cpufreq.c
@@@ -373,26 -368,11 +368,31 @@@ struct clk *s3c_cpufreq_clk_get(struct 
  
  static int s3c_cpufreq_init(struct cpufreq_policy *policy)
  {
++<<<<<<< HEAD:arch/arm/mach-s3c24xx/cpufreq.c
 +	printk(KERN_INFO "%s: initialising policy %p\n", __func__, policy);
 +
 +	if (policy->cpu != 0)
 +		return -EINVAL;
 +
 +	policy->cur = s3c_cpufreq_get(0);
 +	policy->min = policy->cpuinfo.min_freq = 0;
 +	policy->max = policy->cpuinfo.max_freq = cpu_cur.info->max.fclk / 1000;
 +	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 +
 +	/* feed the latency information from the cpu driver */
 +	policy->cpuinfo.transition_latency = cpu_cur.info->latency;
 +
 +	if (ftab)
 +		cpufreq_frequency_table_cpuinfo(policy, ftab);
 +
 +	return 0;
++=======
+ 	policy->clk = clk_arm;
+ 	return cpufreq_generic_init(policy, ftab, cpu_cur.info->latency);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine):drivers/cpufreq/s3c24xx-cpufreq.c
  }
  
 -static int __init s3c_cpufreq_initclks(void)
 +static __init int s3c_cpufreq_initclks(void)
  {
  	_clk_mpll = s3c_cpufreq_clk_get(NULL, "mpll");
  	_clk_xtal = s3c_cpufreq_clk_get(NULL, "xtal");
@@@ -431,8 -403,8 +431,13 @@@ static unsigned int suspend_freq
  static int s3c_cpufreq_suspend(struct cpufreq_policy *policy)
  {
  	suspend_pll.frequency = clk_get_rate(_clk_mpll);
++<<<<<<< HEAD:arch/arm/mach-s3c24xx/cpufreq.c
 +	suspend_pll.index = __raw_readl(S3C2410_MPLLCON);
 +	suspend_freq = s3c_cpufreq_get(0) * 1000;
++=======
+ 	suspend_pll.driver_data = __raw_readl(S3C2410_MPLLCON);
+ 	suspend_freq = clk_get_rate(clk_arm);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine):drivers/cpufreq/s3c24xx-cpufreq.c
  
  	return 0;
  }
@@@ -472,10 -444,9 +477,10 @@@ static int s3c_cpufreq_resume(struct cp
  #endif
  
  static struct cpufreq_driver s3c24xx_driver = {
 -	.flags		= CPUFREQ_STICKY | CPUFREQ_NEED_INITIAL_FREQ_CHECK,
 +	.flags		= CPUFREQ_STICKY,
 +	.verify		= s3c_cpufreq_verify,
  	.target		= s3c_cpufreq_target,
- 	.get		= s3c_cpufreq_get,
+ 	.get		= cpufreq_generic_get,
  	.init		= s3c_cpufreq_init,
  	.suspend	= s3c_cpufreq_suspend,
  	.resume		= s3c_cpufreq_resume,
diff --cc drivers/cpufreq/at32ap-cpufreq.c
index 654488723cb5,a1c79f549edb..000000000000
--- a/drivers/cpufreq/at32ap-cpufreq.c
+++ b/drivers/cpufreq/at32ap-cpufreq.c
@@@ -19,100 -19,104 +19,148 @@@
  #include <linux/clk.h>
  #include <linux/err.h>
  #include <linux/export.h>
 -#include <linux/slab.h>
  
++<<<<<<< HEAD
 +static struct clk *cpuclk;
 +
 +static int at32_verify_speed(struct cpufreq_policy *policy)
 +{
 +	if (policy->cpu != 0)
 +		return -EINVAL;
 +
 +	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
 +			policy->cpuinfo.max_freq);
 +	return 0;
 +}
- 
- static unsigned int at32_get_speed(unsigned int cpu)
- {
- 	/* No SMP support */
- 	if (cpu)
- 		return 0;
- 	return (unsigned int)((clk_get_rate(cpuclk) + 500) / 1000);
- }
++=======
+ static struct cpufreq_frequency_table *freq_table;
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  
  static unsigned int	ref_freq;
  static unsigned long	loops_per_jiffy_ref;
  
 -static int at32_set_target(struct cpufreq_policy *policy, unsigned int index)
 +static int at32_set_target(struct cpufreq_policy *policy,
 +			  unsigned int target_freq,
 +			  unsigned int relation)
  {
 -	unsigned int old_freq, new_freq;
 +	struct cpufreq_freqs freqs;
 +	long freq;
 +
++<<<<<<< HEAD
 +	/* Convert target_freq from kHz to Hz */
 +	freq = clk_round_rate(cpuclk, target_freq * 1000);
  
 +	/* Check if policy->min <= new_freq <= policy->max */
 +	if(freq < (policy->min * 1000) || freq > (policy->max * 1000))
 +		return -EINVAL;
 +
 +	pr_debug("cpufreq: requested frequency %u Hz\n", target_freq * 1000);
 +
 +	freqs.old = at32_get_speed(0);
 +	freqs.new = (freq + 500) / 1000;
 +	freqs.flags = 0;
++=======
+ 	old_freq = policy->cur;
+ 	new_freq = freq_table[index].frequency;
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  
  	if (!ref_freq) {
 -		ref_freq = old_freq;
 +		ref_freq = freqs.old;
  		loops_per_jiffy_ref = boot_cpu_data.loops_per_jiffy;
  	}
  
 -	if (old_freq < new_freq)
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +	if (freqs.old < freqs.new)
  		boot_cpu_data.loops_per_jiffy = cpufreq_scale(
++<<<<<<< HEAD
 +				loops_per_jiffy_ref, ref_freq, freqs.new);
 +	clk_set_rate(cpuclk, freq);
 +	if (freqs.new < freqs.old)
++=======
+ 				loops_per_jiffy_ref, ref_freq, new_freq);
+ 	clk_set_rate(policy->clk, new_freq * 1000);
+ 	if (new_freq < old_freq)
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  		boot_cpu_data.loops_per_jiffy = cpufreq_scale(
 -				loops_per_jiffy_ref, ref_freq, new_freq);
 +				loops_per_jiffy_ref, ref_freq, freqs.new);
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
 +	pr_debug("cpufreq: set frequency %lu Hz\n", freq);
  
  	return 0;
  }
  
 -static int at32_cpufreq_driver_init(struct cpufreq_policy *policy)
 +static int __init at32_cpufreq_driver_init(struct cpufreq_policy *policy)
  {
++<<<<<<< HEAD
++=======
+ 	unsigned int frequency, rate, min_freq;
+ 	static struct clk *cpuclk;
+ 	int retval, steps, i;
+ 
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	if (policy->cpu != 0)
  		return -EINVAL;
  
  	cpuclk = clk_get(NULL, "cpu");
  	if (IS_ERR(cpuclk)) {
  		pr_debug("cpufreq: could not get CPU clk\n");
 -		retval = PTR_ERR(cpuclk);
 -		goto out_err;
 +		return PTR_ERR(cpuclk);
  	}
  
 -	min_freq = (clk_round_rate(cpuclk, 1) + 500) / 1000;
 -	frequency = (clk_round_rate(cpuclk, ~0UL) + 500) / 1000;
 +	policy->cpuinfo.min_freq = (clk_round_rate(cpuclk, 1) + 500) / 1000;
 +	policy->cpuinfo.max_freq = (clk_round_rate(cpuclk, ~0UL) + 500) / 1000;
  	policy->cpuinfo.transition_latency = 0;
 +	policy->cur = at32_get_speed(0);
 +	policy->min = policy->cpuinfo.min_freq;
 +	policy->max = policy->cpuinfo.max_freq;
  
 -	/*
 -	 * AVR32 CPU frequency rate scales in power of two between maximum and
 -	 * minimum, also add space for the table end marker.
 -	 *
 -	 * Further validate that the frequency is usable, and append it to the
 -	 * frequency table.
 -	 */
 -	steps = fls(frequency / min_freq) + 1;
 -	freq_table = kzalloc(steps * sizeof(struct cpufreq_frequency_table),
 -			GFP_KERNEL);
 -	if (!freq_table) {
 -		retval = -ENOMEM;
 -		goto out_err_put_clk;
 -	}
 +	printk("cpufreq: AT32AP CPU frequency driver\n");
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	for (i = 0; i < (steps - 1); i++) {
+ 		rate = clk_round_rate(cpuclk, frequency * 1000) / 1000;
+ 
+ 		if (rate != frequency)
+ 			freq_table[i].frequency = CPUFREQ_ENTRY_INVALID;
+ 		else
+ 			freq_table[i].frequency = frequency;
+ 
+ 		frequency /= 2;
+ 	}
+ 
+ 	policy->clk = cpuclk;
+ 	freq_table[steps - 1].frequency = CPUFREQ_TABLE_END;
+ 
+ 	retval = cpufreq_table_validate_and_show(policy, freq_table);
+ 	if (!retval) {
+ 		printk("cpufreq: AT32AP CPU frequency driver\n");
+ 		return 0;
+ 	}
+ 
+ 	kfree(freq_table);
+ out_err_put_clk:
+ 	clk_put(cpuclk);
+ out_err:
+ 	return retval;
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  }
  
  static struct cpufreq_driver at32_driver = {
  	.name		= "at32ap",
 +	.owner		= THIS_MODULE,
  	.init		= at32_cpufreq_driver_init,
++<<<<<<< HEAD
 +	.verify		= at32_verify_speed,
 +	.target		= at32_set_target,
 +	.get		= at32_get_speed,
++=======
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= at32_set_target,
+ 	.get		= cpufreq_generic_get,
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	.flags		= CPUFREQ_STICKY,
  };
  
diff --cc drivers/cpufreq/cpufreq-cpu0.c
index ad1fde277661,bb7b3082efb3..000000000000
--- a/drivers/cpufreq/cpufreq-cpu0.c
+++ b/drivers/cpufreq/cpufreq-cpu0.c
@@@ -29,49 -30,25 +29,53 @@@ static struct clk *cpu_clk
  static struct regulator *cpu_reg;
  static struct cpufreq_frequency_table *freq_table;
  
++<<<<<<< HEAD
 +static int cpu0_verify_speed(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, freq_table);
 +}
 +
 +static unsigned int cpu0_get_speed(unsigned int cpu)
 +{
 +	return clk_get_rate(cpu_clk) / 1000;
 +}
 +
 +static int cpu0_set_target(struct cpufreq_policy *policy,
 +			   unsigned int target_freq, unsigned int relation)
++=======
+ static int cpu0_set_target(struct cpufreq_policy *policy, unsigned int index)
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  {
 -	struct dev_pm_opp *opp;
 +	struct cpufreq_freqs freqs;
 +	struct opp *opp;
  	unsigned long volt = 0, volt_old = 0, tol = 0;
 -	unsigned int old_freq, new_freq;
  	long freq_Hz, freq_exact;
 +	unsigned int index;
  	int ret;
  
 +	ret = cpufreq_frequency_table_target(policy, freq_table, target_freq,
 +					     relation, &index);
 +	if (ret) {
 +		pr_err("failed to match target freqency %d: %d\n",
 +		       target_freq, ret);
 +		return ret;
 +	}
 +
  	freq_Hz = clk_round_rate(cpu_clk, freq_table[index].frequency * 1000);
 -	if (freq_Hz <= 0)
 +	if (freq_Hz < 0)
  		freq_Hz = freq_table[index].frequency * 1000;
 -
  	freq_exact = freq_Hz;
 -	new_freq = freq_Hz / 1000;
 -	old_freq = clk_get_rate(cpu_clk) / 1000;
 +	freqs.new = freq_Hz / 1000;
 +	freqs.old = clk_get_rate(cpu_clk) / 1000;
 +
 +	if (freqs.old == freqs.new)
 +		return 0;
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
  
 -	if (!IS_ERR(cpu_reg)) {
 +	if (cpu_reg) {
  		rcu_read_lock();
 -		opp = dev_pm_opp_find_freq_ceil(cpu_dev, &freq_Hz);
 +		opp = opp_find_freq_ceil(cpu_dev, &freq_Hz);
  		if (IS_ERR(opp)) {
  			rcu_read_unlock();
  			pr_err("failed to find OPP for %ld\n", freq_Hz);
@@@ -126,50 -95,19 +130,61 @@@ post_notify
  
  static int cpu0_cpufreq_init(struct cpufreq_policy *policy)
  {
++<<<<<<< HEAD
 +	int ret;
 +
 +	ret = cpufreq_frequency_table_cpuinfo(policy, freq_table);
 +	if (ret) {
 +		pr_err("invalid frequency table: %d\n", ret);
 +		return ret;
 +	}
 +
 +	policy->cpuinfo.transition_latency = transition_latency;
 +	policy->cur = clk_get_rate(cpu_clk) / 1000;
 +
 +	/*
 +	 * The driver only supports the SMP configuartion where all processors
 +	 * share the clock and voltage and clock.  Use cpufreq affected_cpus
 +	 * interface to have all CPUs scaled together.
 +	 */
 +	cpumask_setall(policy->cpus);
 +
 +	cpufreq_frequency_table_get_attr(freq_table, policy->cpu);
 +
 +	return 0;
++=======
+ 	policy->clk = cpu_clk;
+ 	return cpufreq_generic_init(policy, freq_table, transition_latency);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
 +}
 +
 +static int cpu0_cpufreq_exit(struct cpufreq_policy *policy)
 +{
 +	cpufreq_frequency_table_put_attr(policy->cpu);
 +
 +	return 0;
  }
  
 +static struct freq_attr *cpu0_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver cpu0_cpufreq_driver = {
  	.flags = CPUFREQ_STICKY,
++<<<<<<< HEAD
 +	.verify = cpu0_verify_speed,
 +	.target = cpu0_set_target,
 +	.get = cpu0_get_speed,
++=======
+ 	.verify = cpufreq_generic_frequency_table_verify,
+ 	.target_index = cpu0_set_target,
+ 	.get = cpufreq_generic_get,
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	.init = cpu0_cpufreq_init,
 -	.exit = cpufreq_generic_exit,
 +	.exit = cpu0_cpufreq_exit,
  	.name = "generic_cpu0",
 -	.attr = cpufreq_generic_attr,
 +	.attr = cpu0_cpufreq_attr,
  };
  
  static int cpu0_cpufreq_probe(struct platform_device *pdev)
diff --cc drivers/cpufreq/cpufreq.c
index c8bc717e8458,d7efdfe0c12c..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -182,6 -145,51 +182,54 @@@ u64 get_cpu_idle_time(unsigned int cpu
  }
  EXPORT_SYMBOL_GPL(get_cpu_idle_time);
  
++<<<<<<< HEAD
++=======
+ /*
+  * This is a generic cpufreq init() routine which can be used by cpufreq
+  * drivers of SMP systems. It will do following:
+  * - validate & show freq table passed
+  * - set policies transition latency
+  * - policy->cpus with all possible CPUs
+  */
+ int cpufreq_generic_init(struct cpufreq_policy *policy,
+ 		struct cpufreq_frequency_table *table,
+ 		unsigned int transition_latency)
+ {
+ 	int ret;
+ 
+ 	ret = cpufreq_table_validate_and_show(policy, table);
+ 	if (ret) {
+ 		pr_err("%s: invalid frequency table: %d\n", __func__, ret);
+ 		return ret;
+ 	}
+ 
+ 	policy->cpuinfo.transition_latency = transition_latency;
+ 
+ 	/*
+ 	 * The driver only supports the SMP configuartion where all processors
+ 	 * share the clock and voltage and clock.
+ 	 */
+ 	cpumask_setall(policy->cpus);
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(cpufreq_generic_init);
+ 
+ unsigned int cpufreq_generic_get(unsigned int cpu)
+ {
+ 	struct cpufreq_policy *policy = per_cpu(cpufreq_cpu_data, cpu);
+ 
+ 	if (!policy || IS_ERR(policy->clk)) {
+ 		pr_err("%s: No %s associated to cpu: %d\n", __func__,
+ 				policy ? "clk" : "policy", cpu);
+ 		return 0;
+ 	}
+ 
+ 	return clk_get_rate(policy->clk) / 1000;
+ }
+ EXPORT_SYMBOL_GPL(cpufreq_generic_get);
+ 
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu)
  {
  	struct cpufreq_policy *policy = NULL;
@@@ -1065,18 -1161,24 +1118,27 @@@ static int cpufreq_add_dev(struct devic
  	}
  #endif
  
++<<<<<<< HEAD
 +	write_lock_irqsave(&cpufreq_driver_lock, flags);
 +	for_each_cpu(j, policy->cpus) {
 +		per_cpu(cpufreq_cpu_data, j) = policy;
 +		per_cpu(cpufreq_policy_cpu, j) = policy->cpu;
++=======
+ 	if (!frozen) {
+ 		ret = cpufreq_add_dev_interface(policy, dev);
+ 		if (ret)
+ 			goto err_out_unregister;
+ 		blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
+ 				CPUFREQ_CREATE_POLICY, policy);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	}
 -
 -	write_lock_irqsave(&cpufreq_driver_lock, flags);
 -	list_add(&policy->policy_list, &cpufreq_policy_list);
  	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
  
 -	cpufreq_init_policy(policy);
 +	ret = cpufreq_add_dev_interface(cpu, policy, dev);
 +	if (ret)
 +		goto err_out_unregister;
  
 -	if (!frozen) {
 -		policy->user_policy.policy = policy->policy;
 -		policy->user_policy.governor = policy->governor;
 -	}
 +	cpufreq_init_policy(policy);
  
  	kobject_uevent(&policy->kobj, KOBJ_ADD);
  	up_read(&cpufreq_rwsem);
@@@ -1085,15 -1188,12 +1147,15 @@@
  	return 0;
  
  err_out_unregister:
+ err_get_freq:
  	write_lock_irqsave(&cpufreq_driver_lock, flags);
 -	for_each_cpu(j, policy->cpus)
 +	for_each_cpu(j, policy->cpus) {
  		per_cpu(cpufreq_cpu_data, j) = NULL;
 +		if (j != cpu)
 +			per_cpu(cpufreq_policy_cpu, j) = -1;
 +	}
  	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
  
- err_get_freq:
  	if (cpufreq_driver->exit)
  		cpufreq_driver->exit(policy);
  err_set_policy_cpu:
diff --cc drivers/cpufreq/davinci-cpufreq.c
index 7c60c8b54e11,2cf33848d86e..000000000000
--- a/drivers/cpufreq/davinci-cpufreq.c
+++ b/drivers/cpufreq/davinci-cpufreq.c
@@@ -58,43 -58,21 +58,52 @@@ static int davinci_verify_speed(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +static unsigned int davinci_getspeed(unsigned int cpu)
 +{
 +	if (cpu)
 +		return 0;
 +
 +	return clk_get_rate(cpufreq.armclk) / 1000;
 +}
 +
 +static int davinci_target(struct cpufreq_policy *policy,
 +				unsigned int target_freq, unsigned int relation)
++=======
+ static int davinci_target(struct cpufreq_policy *policy, unsigned int idx)
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  {
 +	int ret = 0;
 +	unsigned int idx;
 +	struct cpufreq_freqs freqs;
  	struct davinci_cpufreq_config *pdata = cpufreq.dev->platform_data;
  	struct clk *armclk = cpufreq.armclk;
 -	unsigned int old_freq, new_freq;
 -	int ret = 0;
  
++<<<<<<< HEAD
 +	freqs.old = davinci_getspeed(0);
 +	freqs.new = clk_round_rate(armclk, target_freq * 1000) / 1000;
 +
 +	if (freqs.old == freqs.new)
 +		return ret;
 +
 +	dev_dbg(cpufreq.dev, "transition: %u --> %u\n", freqs.old, freqs.new);
 +
 +	ret = cpufreq_frequency_table_target(policy, pdata->freq_table,
 +						freqs.new, relation, &idx);
 +	if (ret)
 +		return -EINVAL;
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
++=======
+ 	old_freq = policy->cur;
+ 	new_freq = pdata->freq_table[idx].frequency;
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  
  	/* if moving to higher frequency, up the voltage beforehand */
 -	if (pdata->set_voltage && new_freq > old_freq) {
 +	if (pdata->set_voltage && freqs.new > freqs.old) {
  		ret = pdata->set_voltage(idx);
  		if (ret)
 -			return ret;
 +			goto out;
  	}
  
  	ret = clk_set_rate(armclk, idx);
@@@ -133,16 -108,7 +142,20 @@@ static int davinci_cpu_init(struct cpuf
  			return result;
  	}
  
++<<<<<<< HEAD
 +	policy->cur = davinci_getspeed(0);
 +
 +	result = cpufreq_frequency_table_cpuinfo(policy, freq_table);
 +	if (result) {
 +		pr_err("%s: cpufreq_frequency_table_cpuinfo() failed",
 +				__func__);
 +		return result;
 +	}
 +
 +	cpufreq_frequency_table_get_attr(freq_table, policy->cpu);
++=======
+ 	policy->clk = cpufreq.armclk;
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  
  	/*
  	 * Time measurement across the target() function yields ~1500-1800us
@@@ -150,30 -116,18 +163,35 @@@
  	 * Setting the latency to 2000 us to accommodate addition of drivers
  	 * to pre/post change notification list.
  	 */
 -	return cpufreq_generic_init(policy, freq_table, 2000 * 1000);
 +	policy->cpuinfo.transition_latency = 2000 * 1000;
 +	return 0;
  }
  
 +static int davinci_cpu_exit(struct cpufreq_policy *policy)
 +{
 +	cpufreq_frequency_table_put_attr(policy->cpu);
 +	return 0;
 +}
 +
 +static struct freq_attr *davinci_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver davinci_driver = {
 -	.flags		= CPUFREQ_STICKY | CPUFREQ_NEED_INITIAL_FREQ_CHECK,
 +	.flags		= CPUFREQ_STICKY,
  	.verify		= davinci_verify_speed,
++<<<<<<< HEAD
 +	.target		= davinci_target,
 +	.get		= davinci_getspeed,
++=======
+ 	.target_index	= davinci_target,
+ 	.get		= cpufreq_generic_get,
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	.init		= davinci_cpu_init,
 -	.exit		= cpufreq_generic_exit,
 +	.exit		= davinci_cpu_exit,
  	.name		= "davinci",
 -	.attr		= cpufreq_generic_attr,
 +	.attr		= davinci_cpufreq_attr,
  };
  
  static int __init davinci_cpufreq_probe(struct platform_device *pdev)
diff --cc drivers/cpufreq/dbx500-cpufreq.c
index 8c005ac8b701,412a78bb0c94..000000000000
--- a/drivers/cpufreq/dbx500-cpufreq.c
+++ b/drivers/cpufreq/dbx500-cpufreq.c
@@@ -19,108 -19,28 +19,105 @@@
  static struct cpufreq_frequency_table *freq_table;
  static struct clk *armss_clk;
  
 +static struct freq_attr *dbx500_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
 +static int dbx500_cpufreq_verify_speed(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, freq_table);
 +}
 +
  static int dbx500_cpufreq_target(struct cpufreq_policy *policy,
 -				unsigned int index)
 +				unsigned int target_freq,
 +				unsigned int relation)
  {
 +	struct cpufreq_freqs freqs;
 +	unsigned int idx;
 +	int ret;
 +
 +	/* Lookup the next frequency */
 +	if (cpufreq_frequency_table_target(policy, freq_table, target_freq,
 +					relation, &idx))
 +		return -EINVAL;
 +
 +	freqs.old = policy->cur;
 +	freqs.new = freq_table[idx].frequency;
 +
 +	if (freqs.old == freqs.new)
 +		return 0;
 +
 +	/* pre-change notification */
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +
  	/* update armss clk frequency */
 -	return clk_set_rate(armss_clk, freq_table[index].frequency * 1000);
 +	ret = clk_set_rate(armss_clk, freqs.new * 1000);
 +
 +	if (ret) {
 +		pr_err("dbx500-cpufreq: Failed to set armss_clk to %d Hz: error %d\n",
 +		       freqs.new * 1000, ret);
 +		return ret;
 +	}
 +
 +	/* post change notification */
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
 +	return 0;
  }
  
- static unsigned int dbx500_cpufreq_getspeed(unsigned int cpu)
- {
- 	int i = 0;
- 	unsigned long freq = clk_get_rate(armss_clk) / 1000;
- 
- 	/* The value is rounded to closest frequency in the defined table. */
- 	while (freq_table[i + 1].frequency != CPUFREQ_TABLE_END) {
- 		if (freq < freq_table[i].frequency +
- 		   (freq_table[i + 1].frequency - freq_table[i].frequency) / 2)
- 			return freq_table[i].frequency;
- 		i++;
- 	}
- 
- 	return freq_table[i].frequency;
- }
- 
  static int dbx500_cpufreq_init(struct cpufreq_policy *policy)
  {
++<<<<<<< HEAD
 +	int res;
 +
 +	/* get policy fields based on the table */
 +	res = cpufreq_frequency_table_cpuinfo(policy, freq_table);
 +	if (!res)
 +		cpufreq_frequency_table_get_attr(freq_table, policy->cpu);
 +	else {
 +		pr_err("dbx500-cpufreq: Failed to read policy table\n");
 +		return res;
 +	}
 +
 +	policy->min = policy->cpuinfo.min_freq;
 +	policy->max = policy->cpuinfo.max_freq;
 +	policy->cur = dbx500_cpufreq_getspeed(policy->cpu);
 +	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
 +
 +	/*
 +	 * FIXME : Need to take time measurement across the target()
 +	 *	   function with no/some/all drivers in the notification
 +	 *	   list.
 +	 */
 +	policy->cpuinfo.transition_latency = 20 * 1000; /* in ns */
 +
 +	/* policy sharing between dual CPUs */
 +	cpumask_setall(policy->cpus);
 +
 +	return 0;
 +}
 +
 +static struct cpufreq_driver dbx500_cpufreq_driver = {
 +	.flags  = CPUFREQ_STICKY | CPUFREQ_CONST_LOOPS,
 +	.verify = dbx500_cpufreq_verify_speed,
 +	.target = dbx500_cpufreq_target,
 +	.get    = dbx500_cpufreq_getspeed,
++=======
+ 	policy->clk = armss_clk;
+ 	return cpufreq_generic_init(policy, freq_table, 20 * 1000);
+ }
+ 
+ static struct cpufreq_driver dbx500_cpufreq_driver = {
+ 	.flags  = CPUFREQ_STICKY | CPUFREQ_CONST_LOOPS |
+ 			CPUFREQ_NEED_INITIAL_FREQ_CHECK,
+ 	.verify = cpufreq_generic_frequency_table_verify,
+ 	.target_index = dbx500_cpufreq_target,
+ 	.get    = cpufreq_generic_get,
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	.init   = dbx500_cpufreq_init,
  	.name   = "DBX500",
 -	.attr   = cpufreq_generic_attr,
 +	.attr   = dbx500_cpufreq_attr,
  };
  
  static int dbx500_cpufreq_probe(struct platform_device *pdev)
diff --cc drivers/cpufreq/exynos-cpufreq.c
index 475b4f607f0d,4ee3804637be..000000000000
--- a/drivers/cpufreq/exynos-cpufreq.c
+++ b/drivers/cpufreq/exynos-cpufreq.c
@@@ -31,17 -31,6 +31,20 @@@ static unsigned int locking_frequency
  static bool frequency_locked;
  static DEFINE_MUTEX(cpufreq_lock);
  
++<<<<<<< HEAD
 +static int exynos_verify_speed(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy,
 +					      exynos_info->freq_table);
 +}
 +
 +static unsigned int exynos_getspeed(unsigned int cpu)
 +{
 +	return clk_get_rate(exynos_info->cpu_clk) / 1000;
 +}
 +
++=======
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  static int exynos_cpufreq_get_index(unsigned int freq)
  {
  	struct cpufreq_frequency_table *freq_table = exynos_info->freq_table;
@@@ -241,38 -210,19 +244,50 @@@ static struct notifier_block exynos_cpu
  
  static int exynos_cpufreq_cpu_init(struct cpufreq_policy *policy)
  {
++<<<<<<< HEAD
 +	policy->cur = policy->min = policy->max = exynos_getspeed(policy->cpu);
 +
 +	cpufreq_frequency_table_get_attr(exynos_info->freq_table, policy->cpu);
 +
 +	/* set the transition latency value */
 +	policy->cpuinfo.transition_latency = 100000;
 +
 +	cpumask_setall(policy->cpus);
 +
 +	return cpufreq_frequency_table_cpuinfo(policy, exynos_info->freq_table);
++=======
+ 	policy->clk = exynos_info->cpu_clk;
+ 	return cpufreq_generic_init(policy, exynos_info->freq_table, 100000);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
 +}
 +
 +static int exynos_cpufreq_cpu_exit(struct cpufreq_policy *policy)
 +{
 +	cpufreq_frequency_table_put_attr(policy->cpu);
 +	return 0;
  }
  
 +static struct freq_attr *exynos_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver exynos_driver = {
++<<<<<<< HEAD
 +	.flags		= CPUFREQ_STICKY,
 +	.verify		= exynos_verify_speed,
 +	.target		= exynos_target,
 +	.get		= exynos_getspeed,
++=======
+ 	.flags		= CPUFREQ_STICKY | CPUFREQ_NEED_INITIAL_FREQ_CHECK,
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= exynos_target,
+ 	.get		= cpufreq_generic_get,
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	.init		= exynos_cpufreq_cpu_init,
 -	.exit		= cpufreq_generic_exit,
 +	.exit		= exynos_cpufreq_cpu_exit,
  	.name		= "exynos_cpufreq",
 -	.attr		= cpufreq_generic_attr,
 +	.attr		= exynos_cpufreq_attr,
  #ifdef CONFIG_PM
  	.suspend	= exynos_cpufreq_suspend,
  	.resume		= exynos_cpufreq_resume,
diff --cc drivers/cpufreq/exynos5440-cpufreq.c
index 0c74018eda47,49b756015316..000000000000
--- a/drivers/cpufreq/exynos5440-cpufreq.c
+++ b/drivers/cpufreq/exynos5440-cpufreq.c
@@@ -209,33 -208,15 +208,41 @@@ static void exynos_enable_dvfs(unsigne
  				dvfs_info->base + XMU_DVFS_CTRL);
  }
  
++<<<<<<< HEAD
 +static int exynos_verify_speed(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy,
 +					      dvfs_info->freq_table);
 +}
 +
 +static unsigned int exynos_getspeed(unsigned int cpu)
 +{
 +	return dvfs_info->cur_frequency;
 +}
 +
 +static int exynos_target(struct cpufreq_policy *policy,
 +			  unsigned int target_freq,
 +			  unsigned int relation)
++=======
+ static int exynos_target(struct cpufreq_policy *policy, unsigned int index)
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  {
 -	unsigned int tmp;
 -	int i;
 +	unsigned int index, tmp;
 +	int ret = 0, i;
  	struct cpufreq_frequency_table *freq_table = dvfs_info->freq_table;
  
  	mutex_lock(&cpufreq_lock);
  
++<<<<<<< HEAD
 +	ret = cpufreq_frequency_table_target(policy, freq_table,
 +					   target_freq, relation, &index);
 +	if (ret)
 +		goto out;
 +
 +	freqs.old = dvfs_info->cur_frequency;
++=======
+ 	freqs.old = policy->cur;
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	freqs.new = freq_table[index].frequency;
  
  	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
@@@ -321,30 -300,21 +327,44 @@@ static void exynos_sort_descend_freq_ta
  
  static int exynos_cpufreq_cpu_init(struct cpufreq_policy *policy)
  {
++<<<<<<< HEAD
 +	int ret;
 +
 +	ret = cpufreq_frequency_table_cpuinfo(policy, dvfs_info->freq_table);
 +	if (ret) {
 +		dev_err(dvfs_info->dev, "Invalid frequency table: %d\n", ret);
 +		return ret;
 +	}
 +
 +	policy->cur = dvfs_info->cur_frequency;
 +	policy->cpuinfo.transition_latency = dvfs_info->latency;
 +	cpumask_setall(policy->cpus);
 +
 +	cpufreq_frequency_table_get_attr(dvfs_info->freq_table, policy->cpu);
 +
 +	return 0;
 +}
 +
 +static struct cpufreq_driver exynos_driver = {
 +	.flags		= CPUFREQ_STICKY,
 +	.verify		= exynos_verify_speed,
 +	.target		= exynos_target,
 +	.get		= exynos_getspeed,
++=======
+ 	policy->clk = dvfs_info->cpu_clk;
+ 	return cpufreq_generic_init(policy, dvfs_info->freq_table,
+ 			dvfs_info->latency);
+ }
+ 
+ static struct cpufreq_driver exynos_driver = {
+ 	.flags		= CPUFREQ_STICKY | CPUFREQ_ASYNC_NOTIFICATION |
+ 				CPUFREQ_NEED_INITIAL_FREQ_CHECK,
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= exynos_target,
+ 	.get		= cpufreq_generic_get,
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	.init		= exynos_cpufreq_cpu_init,
 -	.exit		= cpufreq_generic_exit,
  	.name		= CPUFREQ_NAME,
 -	.attr		= cpufreq_generic_attr,
  };
  
  static const struct of_device_id exynos_cpufreq_match[] = {
diff --cc drivers/cpufreq/imx6q-cpufreq.c
index b78bc35973ba,ce69059be1fc..000000000000
--- a/drivers/cpufreq/imx6q-cpufreq.c
+++ b/drivers/cpufreq/imx6q-cpufreq.c
@@@ -34,44 -35,22 +34,48 @@@ static struct device *cpu_dev
  static struct cpufreq_frequency_table *freq_table;
  static unsigned int transition_latency;
  
 -static u32 *imx6_soc_volt;
 -static u32 soc_opp_count;
 +static int imx6q_verify_speed(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, freq_table);
 +}
 +
++<<<<<<< HEAD
 +static unsigned int imx6q_get_speed(unsigned int cpu)
 +{
 +	return clk_get_rate(arm_clk) / 1000;
 +}
  
 +static int imx6q_set_target(struct cpufreq_policy *policy,
 +			    unsigned int target_freq, unsigned int relation)
++=======
+ static int imx6q_set_target(struct cpufreq_policy *policy, unsigned int index)
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  {
 -	struct dev_pm_opp *opp;
 +	struct cpufreq_freqs freqs;
 +	struct opp *opp;
  	unsigned long freq_hz, volt, volt_old;
 -	unsigned int old_freq, new_freq;
 +	unsigned int index;
  	int ret;
  
 -	new_freq = freq_table[index].frequency;
 -	freq_hz = new_freq * 1000;
 -	old_freq = clk_get_rate(arm_clk) / 1000;
 +	ret = cpufreq_frequency_table_target(policy, freq_table, target_freq,
 +					     relation, &index);
 +	if (ret) {
 +		dev_err(cpu_dev, "failed to match target frequency %d: %d\n",
 +			target_freq, ret);
 +		return ret;
 +	}
 +
 +	freqs.new = freq_table[index].frequency;
 +	freq_hz = freqs.new * 1000;
 +	freqs.old = clk_get_rate(arm_clk) / 1000;
 +
 +	if (freqs.old == freqs.new)
 +		return 0;
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
  
  	rcu_read_lock();
 -	opp = dev_pm_opp_find_freq_ceil(cpu_dev, &freq_hz);
 +	opp = opp_find_freq_ceil(cpu_dev, &freq_hz);
  	if (IS_ERR(opp)) {
  		rcu_read_unlock();
  		dev_err(cpu_dev, "failed to find OPP for %ld\n", freq_hz);
@@@ -170,41 -134,19 +174,53 @@@
  
  static int imx6q_cpufreq_init(struct cpufreq_policy *policy)
  {
++<<<<<<< HEAD
 +	int ret;
 +
 +	ret = cpufreq_frequency_table_cpuinfo(policy, freq_table);
 +	if (ret) {
 +		dev_err(cpu_dev, "invalid frequency table: %d\n", ret);
 +		return ret;
 +	}
 +
 +	policy->cpuinfo.transition_latency = transition_latency;
 +	policy->cur = clk_get_rate(arm_clk) / 1000;
 +	cpumask_setall(policy->cpus);
 +	cpufreq_frequency_table_get_attr(freq_table, policy->cpu);
 +
 +	return 0;
++=======
+ 	policy->clk = arm_clk;
+ 	return cpufreq_generic_init(policy, freq_table, transition_latency);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  }
  
 +static int imx6q_cpufreq_exit(struct cpufreq_policy *policy)
 +{
 +	cpufreq_frequency_table_put_attr(policy->cpu);
 +	return 0;
 +}
 +
 +static struct freq_attr *imx6q_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver imx6q_cpufreq_driver = {
++<<<<<<< HEAD
 +	.verify = imx6q_verify_speed,
 +	.target = imx6q_set_target,
 +	.get = imx6q_get_speed,
++=======
+ 	.flags = CPUFREQ_NEED_INITIAL_FREQ_CHECK,
+ 	.verify = cpufreq_generic_frequency_table_verify,
+ 	.target_index = imx6q_set_target,
+ 	.get = cpufreq_generic_get,
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	.init = imx6q_cpufreq_init,
 -	.exit = cpufreq_generic_exit,
 +	.exit = imx6q_cpufreq_exit,
  	.name = "imx6q-cpufreq",
 -	.attr = cpufreq_generic_attr,
 +	.attr = imx6q_cpufreq_attr,
  };
  
  static int imx6q_cpufreq_probe(struct platform_device *pdev)
diff --cc drivers/cpufreq/loongson2_cpufreq.c
index f92b02ae20be,b6581abc9207..000000000000
--- a/drivers/cpufreq/loongson2_cpufreq.c
+++ b/drivers/cpufreq/loongson2_cpufreq.c
@@@ -91,13 -62,8 +84,13 @@@ static int loongson2_cpufreq_target(str
  	set_cpus_allowed_ptr(current, &cpus_allowed);
  
  	/* setting the cpu frequency */
- 	clk_set_rate(cpuclk, freq);
+ 	clk_set_rate(policy->clk, freq);
  
 +	/* notifiers */
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
 +	pr_debug("cpufreq: set frequency %u kHz\n", freq);
 +
  	return 0;
  }
  
@@@ -131,41 -98,25 +125,57 @@@ static int loongson2_cpufreq_cpu_init(s
  		return ret;
  	}
  
++<<<<<<< HEAD
 +	policy->cur = loongson2_cpufreq_get(policy->cpu);
 +
 +	cpufreq_frequency_table_get_attr(&loongson2_clockmod_table[0],
 +					 policy->cpu);
 +
 +	return cpufreq_frequency_table_cpuinfo(policy,
 +					    &loongson2_clockmod_table[0]);
 +}
 +
 +static int loongson2_cpufreq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy,
 +					      &loongson2_clockmod_table[0]);
++=======
+ 	policy->clk = cpuclk;
+ 	return cpufreq_generic_init(policy, &loongson2_clockmod_table[0], 0);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  }
  
  static int loongson2_cpufreq_exit(struct cpufreq_policy *policy)
  {
++<<<<<<< HEAD
 +	clk_put(cpuclk);
++=======
+ 	cpufreq_frequency_table_put_attr(policy->cpu);
+ 	clk_put(policy->clk);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	return 0;
  }
  
 +static struct freq_attr *loongson2_table_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver loongson2_cpufreq_driver = {
 +	.owner = THIS_MODULE,
  	.name = "loongson2",
  	.init = loongson2_cpufreq_cpu_init,
++<<<<<<< HEAD
 +	.verify = loongson2_cpufreq_verify,
 +	.target = loongson2_cpufreq_target,
 +	.get = loongson2_cpufreq_get,
++=======
+ 	.verify = cpufreq_generic_frequency_table_verify,
+ 	.target_index = loongson2_cpufreq_target,
+ 	.get = cpufreq_generic_get,
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	.exit = loongson2_cpufreq_exit,
 -	.attr = cpufreq_generic_attr,
 +	.attr = loongson2_table_attr,
  };
  
  static struct platform_device_id platform_device_ids[] = {
diff --cc drivers/cpufreq/omap-cpufreq.c
index 4b81d3e9f0ab,590f5b66d181..000000000000
--- a/drivers/cpufreq/omap-cpufreq.c
+++ b/drivers/cpufreq/omap-cpufreq.c
@@@ -39,65 -39,18 +39,76 @@@ static atomic_t freq_table_users = ATOM
  static struct device *mpu_dev;
  static struct regulator *mpu_reg;
  
++<<<<<<< HEAD
 +static int omap_verify_speed(struct cpufreq_policy *policy)
 +{
 +	if (!freq_table)
 +		return -EINVAL;
 +	return cpufreq_frequency_table_verify(policy, freq_table);
 +}
 +
 +static unsigned int omap_getspeed(unsigned int cpu)
 +{
 +	unsigned long rate;
 +
 +	if (cpu >= NR_CPUS)
 +		return 0;
 +
 +	rate = clk_get_rate(mpu_clk) / 1000;
 +	return rate;
 +}
 +
 +static int omap_target(struct cpufreq_policy *policy,
 +		       unsigned int target_freq,
 +		       unsigned int relation)
++=======
+ static int omap_target(struct cpufreq_policy *policy, unsigned int index)
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  {
 -	int r, ret;
 -	struct dev_pm_opp *opp;
 +	unsigned int i;
 +	int r, ret = 0;
 +	struct cpufreq_freqs freqs;
 +	struct opp *opp;
  	unsigned long freq, volt = 0, volt_old = 0, tol = 0;
 -	unsigned int old_freq, new_freq;
  
++<<<<<<< HEAD
 +	if (!freq_table) {
 +		dev_err(mpu_dev, "%s: cpu%d: no freq table!\n", __func__,
 +				policy->cpu);
 +		return -EINVAL;
 +	}
 +
 +	ret = cpufreq_frequency_table_target(policy, freq_table, target_freq,
 +			relation, &i);
 +	if (ret) {
 +		dev_dbg(mpu_dev, "%s: cpu%d: no freq match for %d(ret=%d)\n",
 +			__func__, policy->cpu, target_freq, ret);
 +		return ret;
 +	}
 +	freqs.new = freq_table[i].frequency;
 +	if (!freqs.new) {
 +		dev_err(mpu_dev, "%s: cpu%d: no match for freq %d\n", __func__,
 +			policy->cpu, target_freq);
 +		return -EINVAL;
 +	}
 +
 +	freqs.old = omap_getspeed(policy->cpu);
 +
 +	if (freqs.old == freqs.new && policy->cur == freqs.new)
 +		return ret;
 +
 +	/* notifiers */
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
 +
 +	freq = freqs.new * 1000;
 +	ret = clk_round_rate(mpu_clk, freq);
++=======
+ 	old_freq = policy->cur;
+ 	new_freq = freq_table[index].frequency;
+ 
+ 	freq = new_freq * 1000;
+ 	ret = clk_round_rate(policy->clk, freq);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	if (IS_ERR_VALUE(ret)) {
  		dev_warn(mpu_dev,
  			 "CPUfreq: Cannot find matching frequency for %lu\n",
@@@ -136,17 -88,16 +147,26 @@@
  		}
  	}
  
++<<<<<<< HEAD
 +	ret = clk_set_rate(mpu_clk, freqs.new * 1000);
++=======
+ 	ret = clk_set_rate(policy->clk, new_freq * 1000);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  
  	/* scaling down?  scale voltage after frequency */
 -	if (mpu_reg && (new_freq < old_freq)) {
 +	if (mpu_reg && (freqs.new < freqs.old)) {
  		r = regulator_set_voltage(mpu_reg, volt - tol, volt + tol);
  		if (r < 0) {
  			dev_warn(mpu_dev, "%s: unable to scale voltage down.\n",
  				 __func__);
++<<<<<<< HEAD
 +			ret = clk_set_rate(mpu_clk, freqs.old * 1000);
 +			freqs.new = freqs.old;
 +			goto done;
++=======
+ 			clk_set_rate(policy->clk, old_freq * 1000);
+ 			return r;
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  		}
  	}
  
@@@ -167,77 -112,48 +187,89 @@@ static inline void freq_table_free(void
  
  static int omap_cpu_init(struct cpufreq_policy *policy)
  {
 -	int result;
 +	int result = 0;
  
- 	mpu_clk = clk_get(NULL, "cpufreq_ck");
- 	if (IS_ERR(mpu_clk))
- 		return PTR_ERR(mpu_clk);
+ 	policy->clk = clk_get(NULL, "cpufreq_ck");
+ 	if (IS_ERR(policy->clk))
+ 		return PTR_ERR(policy->clk);
  
 -	if (!freq_table) {
 -		result = dev_pm_opp_init_cpufreq_table(mpu_dev, &freq_table);
 -		if (result) {
 -			dev_err(mpu_dev,
 -				"%s: cpu%d: failed creating freq table[%d]\n",
 +	if (policy->cpu >= NR_CPUS) {
 +		result = -EINVAL;
 +		goto fail_ck;
 +	}
 +
 +	policy->cur = omap_getspeed(policy->cpu);
 +
 +	if (!freq_table)
 +		result = opp_init_cpufreq_table(mpu_dev, &freq_table);
 +
 +	if (result) {
 +		dev_err(mpu_dev, "%s: cpu%d: failed creating freq table[%d]\n",
  				__func__, policy->cpu, result);
 -			goto fail;
 -		}
 +		goto fail_ck;
  	}
  
  	atomic_inc_return(&freq_table_users);
  
 +	result = cpufreq_frequency_table_cpuinfo(policy, freq_table);
 +	if (result)
 +		goto fail_table;
 +
 +	cpufreq_frequency_table_get_attr(freq_table, policy->cpu);
 +
 +	policy->cur = omap_getspeed(policy->cpu);
 +
 +	/*
 +	 * On OMAP SMP configuartion, both processors share the voltage
 +	 * and clock. So both CPUs needs to be scaled together and hence
 +	 * needs software co-ordination. Use cpufreq affected_cpus
 +	 * interface to handle this scenario. Additional is_smp() check
 +	 * is to keep SMP_ON_UP build working.
 +	 */
 +	if (is_smp())
 +		cpumask_setall(policy->cpus);
 +
  	/* FIXME: what's the actual transition time? */
 -	result = cpufreq_generic_init(policy, freq_table, 300 * 1000);
 -	if (!result)
 -		return 0;
 +	policy->cpuinfo.transition_latency = 300 * 1000;
  
 +	return 0;
 +
 +fail_table:
  	freq_table_free();
++<<<<<<< HEAD
 +fail_ck:
 +	clk_put(mpu_clk);
++=======
+ fail:
+ 	clk_put(policy->clk);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	return result;
  }
  
  static int omap_cpu_exit(struct cpufreq_policy *policy)
  {
 -	cpufreq_frequency_table_put_attr(policy->cpu);
  	freq_table_free();
- 	clk_put(mpu_clk);
+ 	clk_put(policy->clk);
  	return 0;
  }
  
 +static struct freq_attr *omap_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver omap_driver = {
++<<<<<<< HEAD
 +	.flags		= CPUFREQ_STICKY,
 +	.verify		= omap_verify_speed,
 +	.target		= omap_target,
 +	.get		= omap_getspeed,
++=======
+ 	.flags		= CPUFREQ_STICKY | CPUFREQ_NEED_INITIAL_FREQ_CHECK,
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= omap_target,
+ 	.get		= cpufreq_generic_get,
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	.init		= omap_cpu_init,
  	.exit		= omap_cpu_exit,
  	.name		= "omap",
diff --cc drivers/cpufreq/s3c64xx-cpufreq.c
index 27cacb524796,c4226de079ab..000000000000
--- a/drivers/cpufreq/s3c64xx-cpufreq.c
+++ b/drivers/cpufreq/s3c64xx-cpufreq.c
@@@ -54,50 -53,19 +53,59 @@@ static struct cpufreq_frequency_table s
  };
  #endif
  
++<<<<<<< HEAD
 +static int s3c64xx_cpufreq_verify_speed(struct cpufreq_policy *policy)
 +{
 +	if (policy->cpu != 0)
 +		return -EINVAL;
 +
 +	return cpufreq_frequency_table_verify(policy, s3c64xx_freq_table);
 +}
 +
 +static unsigned int s3c64xx_cpufreq_get_speed(unsigned int cpu)
 +{
 +	if (cpu != 0)
 +		return 0;
 +
 +	return clk_get_rate(armclk) / 1000;
 +}
 +
++=======
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  static int s3c64xx_cpufreq_set_target(struct cpufreq_policy *policy,
 -				      unsigned int index)
 +				      unsigned int target_freq,
 +				      unsigned int relation)
  {
 -	struct s3c64xx_dvfs *dvfs;
 -	unsigned int old_freq, new_freq;
  	int ret;
 +	unsigned int i;
 +	struct cpufreq_freqs freqs;
 +	struct s3c64xx_dvfs *dvfs;
 +
++<<<<<<< HEAD
 +	ret = cpufreq_frequency_table_target(policy, s3c64xx_freq_table,
 +					     target_freq, relation, &i);
 +	if (ret != 0)
 +		return ret;
 +
 +	freqs.old = clk_get_rate(armclk) / 1000;
 +	freqs.new = s3c64xx_freq_table[i].frequency;
 +	freqs.flags = 0;
 +	dvfs = &s3c64xx_dvfs_table[s3c64xx_freq_table[i].index];
 +
 +	if (freqs.old == freqs.new)
 +		return 0;
 +
 +	pr_debug("Transition %d-%dkHz\n", freqs.old, freqs.new);
  
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
++=======
+ 	old_freq = clk_get_rate(policy->clk) / 1000;
+ 	new_freq = s3c64xx_freq_table[index].frequency;
+ 	dvfs = &s3c64xx_dvfs_table[s3c64xx_freq_table[index].driver_data];
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  
  #ifdef CONFIG_REGULATOR
 -	if (vddarm && new_freq > old_freq) {
 +	if (vddarm && freqs.new > freqs.old) {
  		ret = regulator_set_voltage(vddarm,
  					    dvfs->vddarm_min,
  					    dvfs->vddarm_max);
@@@ -109,40 -77,33 +117,52 @@@
  	}
  #endif
  
++<<<<<<< HEAD
 +	ret = clk_set_rate(armclk, freqs.new * 1000);
++=======
+ 	ret = clk_set_rate(policy->clk, new_freq * 1000);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	if (ret < 0) {
  		pr_err("Failed to set rate %dkHz: %d\n",
 -		       new_freq, ret);
 -		return ret;
 +		       freqs.new, ret);
 +		goto err;
  	}
  
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
  #ifdef CONFIG_REGULATOR
 -	if (vddarm && new_freq < old_freq) {
 +	if (vddarm && freqs.new < freqs.old) {
  		ret = regulator_set_voltage(vddarm,
  					    dvfs->vddarm_min,
  					    dvfs->vddarm_max);
  		if (ret != 0) {
  			pr_err("Failed to set VDDARM for %dkHz: %d\n",
++<<<<<<< HEAD
 +			       freqs.new, ret);
 +			goto err_clk;
++=======
+ 			       new_freq, ret);
+ 			if (clk_set_rate(policy->clk, old_freq * 1000) < 0)
+ 				pr_err("Failed to restore original clock rate\n");
+ 
+ 			return ret;
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  		}
  	}
  #endif
  
  	pr_debug("Set actual frequency %lukHz\n",
- 		 clk_get_rate(armclk) / 1000);
+ 		 clk_get_rate(policy->clk) / 1000);
  
  	return 0;
 +
 +err_clk:
 +	if (clk_set_rate(armclk, freqs.old * 1000) < 0)
 +		pr_err("Failed to restore original clock rate\n");
 +err:
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
 +	return ret;
  }
  
  #ifdef CONFIG_REGULATOR
@@@ -259,11 -217,10 +279,18 @@@ static int s3c64xx_cpufreq_driver_init(
  }
  
  static struct cpufreq_driver s3c64xx_cpufreq_driver = {
++<<<<<<< HEAD
 +	.owner		= THIS_MODULE,
 +	.flags          = 0,
 +	.verify		= s3c64xx_cpufreq_verify_speed,
 +	.target		= s3c64xx_cpufreq_set_target,
 +	.get		= s3c64xx_cpufreq_get_speed,
++=======
+ 	.flags		= CPUFREQ_NEED_INITIAL_FREQ_CHECK,
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= s3c64xx_cpufreq_set_target,
+ 	.get		= cpufreq_generic_get,
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	.init		= s3c64xx_cpufreq_driver_init,
  	.name		= "s3c",
  };
diff --cc drivers/cpufreq/s5pv210-cpufreq.c
index 5c7757073793,55a8e9fa9435..000000000000
--- a/drivers/cpufreq/s5pv210-cpufreq.c
+++ b/drivers/cpufreq/s5pv210-cpufreq.c
@@@ -23,10 -23,8 +23,9 @@@
  #include <mach/map.h>
  #include <mach/regs-clock.h>
  
- static struct clk *cpu_clk;
  static struct clk *dmc0_clk;
  static struct clk *dmc1_clk;
 +static struct cpufreq_freqs freqs;
  static DEFINE_MUTEX(set_freq_lock);
  
  /* APLL M,P,S values for 1G/800Mhz */
@@@ -174,30 -163,13 +173,34 @@@ static void s5pv210_set_refresh(enum s5
  	__raw_writel(tmp1, reg);
  }
  
++<<<<<<< HEAD
 +static int s5pv210_verify_speed(struct cpufreq_policy *policy)
 +{
 +	if (policy->cpu)
 +		return -EINVAL;
 +
 +	return cpufreq_frequency_table_verify(policy, s5pv210_freq_table);
 +}
 +
 +static unsigned int s5pv210_getspeed(unsigned int cpu)
 +{
 +	if (cpu)
 +		return 0;
 +
 +	return clk_get_rate(cpu_clk) / 1000;
 +}
 +
 +static int s5pv210_target(struct cpufreq_policy *policy,
 +			  unsigned int target_freq,
 +			  unsigned int relation)
++=======
+ static int s5pv210_target(struct cpufreq_policy *policy, unsigned int index)
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  {
  	unsigned long reg;
 -	unsigned int priv_index;
 +	unsigned int index, priv_index;
  	unsigned int pll_changing = 0;
  	unsigned int bus_speed_changing = 0;
 -	unsigned int old_freq, new_freq;
  	int arm_volt, int_volt;
  	int ret = 0;
  
@@@ -215,23 -184,8 +218,28 @@@
  		goto exit;
  	}
  
++<<<<<<< HEAD
 +	if (relation & DISABLE_FURTHER_CPUFREQ)
 +		no_cpufreq_access = true;
 +
 +	relation &= ~(ENABLE_FURTHER_CPUFREQ | DISABLE_FURTHER_CPUFREQ);
 +
 +	freqs.old = s5pv210_getspeed(0);
 +
 +	if (cpufreq_frequency_table_target(policy, s5pv210_freq_table,
 +					   target_freq, relation, &index)) {
 +		ret = -EINVAL;
 +		goto exit;
 +	}
 +
 +	freqs.new = s5pv210_freq_table[index].frequency;
 +
 +	if (freqs.new == freqs.old)
 +		goto exit;
++=======
+ 	old_freq = policy->cur;
+ 	new_freq = s5pv210_freq_table[index].frequency;
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  
  	/* Finding current running level index */
  	if (cpufreq_frequency_table_target(policy, s5pv210_freq_table,
@@@ -604,10 -551,10 +612,17 @@@ static int s5pv210_cpufreq_reboot_notif
  }
  
  static struct cpufreq_driver s5pv210_driver = {
++<<<<<<< HEAD
 +	.flags		= CPUFREQ_STICKY,
 +	.verify		= s5pv210_verify_speed,
 +	.target		= s5pv210_target,
 +	.get		= s5pv210_getspeed,
++=======
+ 	.flags		= CPUFREQ_STICKY | CPUFREQ_NEED_INITIAL_FREQ_CHECK,
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= s5pv210_target,
+ 	.get		= cpufreq_generic_get,
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	.init		= s5pv210_cpu_init,
  	.name		= "s5pv210",
  #ifdef CONFIG_PM
diff --cc drivers/cpufreq/spear-cpufreq.c
index 156829f4576d,5c86e3fa5593..000000000000
--- a/drivers/cpufreq/spear-cpufreq.c
+++ b/drivers/cpufreq/spear-cpufreq.c
@@@ -30,16 -30,6 +30,19 @@@ static struct 
  	u32 cnt;
  } spear_cpufreq;
  
++<<<<<<< HEAD
 +static int spear_cpufreq_verify(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, spear_cpufreq.freq_tbl);
 +}
 +
 +static unsigned int spear_cpufreq_get(unsigned int cpu)
 +{
 +	return clk_get_rate(spear_cpufreq.clk) / 1000;
 +}
 +
++=======
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  static struct clk *spear1340_cpu_get_possible_parent(unsigned long newfreq)
  {
  	struct clk *sys_pclk;
@@@ -176,43 -151,20 +179,56 @@@ static int spear_cpufreq_target(struct 
  
  static int spear_cpufreq_init(struct cpufreq_policy *policy)
  {
++<<<<<<< HEAD
 +	int ret;
 +
 +	ret = cpufreq_frequency_table_cpuinfo(policy, spear_cpufreq.freq_tbl);
 +	if (ret) {
 +		pr_err("cpufreq_frequency_table_cpuinfo() failed");
 +		return ret;
 +	}
 +
 +	cpufreq_frequency_table_get_attr(spear_cpufreq.freq_tbl, policy->cpu);
 +	policy->cpuinfo.transition_latency = spear_cpufreq.transition_latency;
 +	policy->cur = spear_cpufreq_get(0);
 +
 +	cpumask_setall(policy->cpus);
 +
 +	return 0;
++=======
+ 	policy->clk = spear_cpufreq.clk;
+ 	return cpufreq_generic_init(policy, spear_cpufreq.freq_tbl,
+ 			spear_cpufreq.transition_latency);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  }
  
 +static int spear_cpufreq_exit(struct cpufreq_policy *policy)
 +{
 +	cpufreq_frequency_table_put_attr(policy->cpu);
 +	return 0;
 +}
 +
 +static struct freq_attr *spear_cpufreq_attr[] = {
 +	 &cpufreq_freq_attr_scaling_available_freqs,
 +	 NULL,
 +};
 +
  static struct cpufreq_driver spear_cpufreq_driver = {
  	.name		= "cpufreq-spear",
++<<<<<<< HEAD
 +	.flags		= CPUFREQ_STICKY,
 +	.verify		= spear_cpufreq_verify,
 +	.target		= spear_cpufreq_target,
 +	.get		= spear_cpufreq_get,
++=======
+ 	.flags		= CPUFREQ_STICKY | CPUFREQ_NEED_INITIAL_FREQ_CHECK,
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= spear_cpufreq_target,
+ 	.get		= cpufreq_generic_get,
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	.init		= spear_cpufreq_init,
 -	.exit		= cpufreq_generic_exit,
 -	.attr		= cpufreq_generic_attr,
 +	.exit		= spear_cpufreq_exit,
 +	.attr		= spear_cpufreq_attr,
  };
  
  static int spear_cpufreq_driver_init(void)
diff --cc drivers/cpufreq/tegra-cpufreq.c
index c74c0e130ef4,e652c1bd8d0f..000000000000
--- a/drivers/cpufreq/tegra-cpufreq.c
+++ b/drivers/cpufreq/tegra-cpufreq.c
@@@ -51,23 -50,6 +51,25 @@@ static struct clk *emc_clk
  static DEFINE_MUTEX(tegra_cpu_lock);
  static bool is_suspended;
  
++<<<<<<< HEAD
 +static int tegra_verify_speed(struct cpufreq_policy *policy)
 +{
 +	return cpufreq_frequency_table_verify(policy, freq_table);
 +}
 +
 +static unsigned int tegra_getspeed(unsigned int cpu)
 +{
 +	unsigned long rate;
 +
 +	if (cpu >= NUM_CPUS)
 +		return 0;
 +
 +	rate = clk_get_rate(cpu_clk) / 1000;
 +	return rate;
 +}
 +
++=======
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  static int tegra_cpu_clk_set_rate(unsigned long rate)
  {
  	int ret;
@@@ -108,14 -90,7 +110,17 @@@ static int tegra_update_cpu_speed(struc
  		unsigned long rate)
  {
  	int ret = 0;
 +	struct cpufreq_freqs freqs;
 +
++<<<<<<< HEAD
 +	freqs.old = tegra_getspeed(0);
 +	freqs.new = rate;
  
 +	if (freqs.old == freqs.new)
 +		return ret;
 +
++=======
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	/*
  	 * Vote on memory bus frequency based on cpu frequency
  	 * This sets the minimum frequency, display or avp may request higher
@@@ -127,60 -102,24 +132,73 @@@
  	else
  		clk_set_rate(emc_clk, 100000000);  /* emc 50Mhz */
  
 -	ret = tegra_cpu_clk_set_rate(rate * 1000);
 -	if (ret)
 -		pr_err("cpu-tegra: Failed to set cpu frequency to %lu kHz\n",
 -			rate);
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
  
 -	return ret;
 +#ifdef CONFIG_CPU_FREQ_DEBUG
 +	printk(KERN_DEBUG "cpufreq-tegra: transition: %u --> %u\n",
 +	       freqs.old, freqs.new);
 +#endif
 +
 +	ret = tegra_cpu_clk_set_rate(freqs.new * 1000);
 +	if (ret) {
 +		pr_err("cpu-tegra: Failed to set cpu frequency to %d kHz\n",
 +			freqs.new);
 +		return ret;
 +	}
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
 +	return 0;
 +}
 +
++<<<<<<< HEAD
 +static unsigned long tegra_cpu_highest_speed(void)
 +{
 +	unsigned long rate = 0;
 +	int i;
 +
 +	for_each_online_cpu(i)
 +		rate = max(rate, target_cpu_speed[i]);
 +	return rate;
  }
  
 +static int tegra_target(struct cpufreq_policy *policy,
 +		       unsigned int target_freq,
 +		       unsigned int relation)
 +{
 +	unsigned int idx;
 +	unsigned int freq;
 +	int ret = 0;
 +
 +	mutex_lock(&tegra_cpu_lock);
 +
 +	if (is_suspended) {
 +		ret = -EBUSY;
 +		goto out;
 +	}
 +
 +	cpufreq_frequency_table_target(policy, freq_table, target_freq,
 +		relation, &idx);
 +
 +	freq = freq_table[idx].frequency;
 +
 +	target_cpu_speed[policy->cpu] = freq;
 +
 +	ret = tegra_update_cpu_speed(policy, tegra_cpu_highest_speed());
 +
 +out:
++=======
+ static int tegra_target(struct cpufreq_policy *policy, unsigned int index)
+ {
+ 	int ret = -EBUSY;
+ 
+ 	mutex_lock(&tegra_cpu_lock);
+ 
+ 	if (!is_suspended)
+ 		ret = tegra_update_cpu_speed(policy,
+ 				freq_table[index].frequency);
+ 
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	mutex_unlock(&tegra_cpu_lock);
  	return ret;
  }
@@@ -216,15 -158,13 +235,18 @@@ static int tegra_cpu_init(struct cpufre
  	clk_prepare_enable(emc_clk);
  	clk_prepare_enable(cpu_clk);
  
++<<<<<<< HEAD
 +	cpufreq_frequency_table_cpuinfo(policy, freq_table);
 +	cpufreq_frequency_table_get_attr(freq_table, policy->cpu);
 +	policy->cur = tegra_getspeed(policy->cpu);
 +	target_cpu_speed[policy->cpu] = policy->cur;
 +
++=======
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	/* FIXME: what's the actual transition time? */
 -	ret = cpufreq_generic_init(policy, freq_table, 300 * 1000);
 -	if (ret) {
 -		clk_disable_unprepare(cpu_clk);
 -		clk_disable_unprepare(emc_clk);
 -		return ret;
 -	}
 +	policy->cpuinfo.transition_latency = 300 * 1000;
 +
 +	cpumask_copy(policy->cpus, cpu_possible_mask);
  
  	if (policy->cpu == 0)
  		register_pm_notifier(&tegra_cpu_pm_notifier);
@@@ -239,15 -181,11 +262,22 @@@ static int tegra_cpu_exit(struct cpufre
  	return 0;
  }
  
 +static struct freq_attr *tegra_cpufreq_attr[] = {
 +	&cpufreq_freq_attr_scaling_available_freqs,
 +	NULL,
 +};
 +
  static struct cpufreq_driver tegra_cpufreq_driver = {
++<<<<<<< HEAD
 +	.verify		= tegra_verify_speed,
 +	.target		= tegra_target,
 +	.get		= tegra_getspeed,
++=======
+ 	.flags		= CPUFREQ_NEED_INITIAL_FREQ_CHECK,
+ 	.verify		= cpufreq_generic_frequency_table_verify,
+ 	.target_index	= tegra_target,
+ 	.get		= cpufreq_generic_get,
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	.init		= tegra_cpu_init,
  	.exit		= tegra_cpu_exit,
  	.name		= "tegra",
diff --cc drivers/cpufreq/unicore2-cpufreq.c
index 6e56ae0997e2,36cc330b8747..000000000000
--- a/drivers/cpufreq/unicore2-cpufreq.c
+++ b/drivers/cpufreq/unicore2-cpufreq.c
@@@ -46,27 -38,24 +38,42 @@@ static int ucv2_target(struct cpufreq_p
  			 unsigned int target_freq,
  			 unsigned int relation)
  {
 +	unsigned int cur = ucv2_getspeed(0);
  	struct cpufreq_freqs freqs;
++<<<<<<< HEAD
 +	struct clk *mclk = clk_get(NULL, "MAIN_CLK");
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
++=======
+ 	int ret;
+ 
+ 	freqs.old = policy->cur;
+ 	freqs.new = target_freq;
+ 
+ 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
+ 	ret = clk_set_rate(policy->mclk, target_freq * 1000);
+ 	cpufreq_notify_post_transition(policy, &freqs, ret);
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
 +
 +	if (!clk_set_rate(mclk, target_freq * 1000)) {
 +		freqs.old = cur;
 +		freqs.new = target_freq;
 +	}
  
 -	return ret;
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
 +	return 0;
  }
  
  static int __init ucv2_cpu_init(struct cpufreq_policy *policy)
  {
  	if (policy->cpu != 0)
  		return -EINVAL;
++<<<<<<< HEAD
 +	policy->cur = ucv2_getspeed(0);
++=======
+ 
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  	policy->min = policy->cpuinfo.min_freq = 250000;
  	policy->max = policy->cpuinfo.max_freq = 1000000;
  	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
diff --cc include/linux/cpufreq.h
index 4d87da0ff71a,422f10561e0b..000000000000
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@@ -441,6 -472,14 +443,18 @@@ void cpufreq_frequency_table_put_attr(u
  int cpufreq_table_validate_and_show(struct cpufreq_policy *policy,
  				      struct cpufreq_frequency_table *table);
  
++<<<<<<< HEAD
 +ssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf);
++=======
+ unsigned int cpufreq_generic_get(unsigned int cpu);
+ int cpufreq_generic_init(struct cpufreq_policy *policy,
+ 		struct cpufreq_frequency_table *table,
+ 		unsigned int transition_latency);
+ static inline int cpufreq_generic_exit(struct cpufreq_policy *policy)
+ {
+ 	cpufreq_frequency_table_put_attr(policy->cpu);
+ 	return 0;
+ }
++>>>>>>> 652ed95d5fa6 (cpufreq: introduce cpufreq_generic_get() routine)
  
  #endif /* _LINUX_CPUFREQ_H */
* Unmerged path drivers/cpufreq/ppc-corenet-cpufreq.c
* Unmerged path arch/arm/mach-s3c24xx/cpufreq.c
* Unmerged path drivers/cpufreq/at32ap-cpufreq.c
* Unmerged path drivers/cpufreq/cpufreq-cpu0.c
* Unmerged path drivers/cpufreq/cpufreq.c
* Unmerged path drivers/cpufreq/davinci-cpufreq.c
* Unmerged path drivers/cpufreq/dbx500-cpufreq.c
* Unmerged path drivers/cpufreq/exynos-cpufreq.c
* Unmerged path drivers/cpufreq/exynos5440-cpufreq.c
* Unmerged path drivers/cpufreq/imx6q-cpufreq.c
* Unmerged path drivers/cpufreq/loongson2_cpufreq.c
* Unmerged path drivers/cpufreq/omap-cpufreq.c
* Unmerged path drivers/cpufreq/ppc-corenet-cpufreq.c
* Unmerged path drivers/cpufreq/s3c64xx-cpufreq.c
* Unmerged path drivers/cpufreq/s5pv210-cpufreq.c
* Unmerged path drivers/cpufreq/spear-cpufreq.c
* Unmerged path drivers/cpufreq/tegra-cpufreq.c
* Unmerged path drivers/cpufreq/unicore2-cpufreq.c
* Unmerged path include/linux/cpufreq.h
