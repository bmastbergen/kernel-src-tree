xfs: flush the range before zero range conversion

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Brian Foster <bfoster@redhat.com>
commit da5f10969d54006a24777a84ed3eaeeb2a21047f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/da5f1096.failed

XFS currently discards delalloc blocks within the target range of a
zero range request. Unaligned start and end offsets are zeroed
through the page cache and the internal, aligned blocks are
converted to unwritten extents.

If EOF is page aligned and covered by a delayed allocation extent.
The inode size is not updated until I/O completion. If a zero range
request discards a delalloc range that covers page aligned EOF as
such, the inode size update never occurs. For example:

$ rm -f /mnt/file
$ xfs_io -fc "pwrite 0 64k" -c "zero 60k 4k" /mnt/file
$ stat -c "%s" /mnt/file
65536
$ umount /mnt
$ mount <dev> /mnt
$ stat -c "%s" /mnt/file
61440

Update xfs_zero_file_space() to flush the range rather than discard
delalloc blocks to ensure that inode size updates occur
appropriately.

[dchinner: Note that this is really a workaround to avoid the
underlying problems. More work is needed (and ongoing) to fix those
issues so this fix is being added as a temporary stop-gap measure. ]

	Signed-off-by: Brian Foster <bfoster@redhat.com>
	Reviewed-by: Dave Chinner <dchinner@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit da5f10969d54006a24777a84ed3eaeeb2a21047f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_bmap_util.c
diff --cc fs/xfs/xfs_bmap_util.c
index 94eb31033c80,6f5cb63bed17..000000000000
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@@ -1390,9 -1391,18 +1390,21 @@@ xfs_zero_file_space
  	ASSERT(end_boundary <= offset + len);
  
  	if (start_boundary < end_boundary - 1) {
++<<<<<<< HEAD
 +		/* punch out the page cache over the conversion range */
++=======
+ 		/*
+ 		 * Writeback the range to ensure any inode size updates due to
+ 		 * appending writes make it to disk (otherwise we could just
+ 		 * punch out the delalloc blocks).
+ 		 */
+ 		error = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,
+ 				start_boundary, end_boundary - 1);
+ 		if (error)
+ 			goto out;
++>>>>>>> da5f10969d54 (xfs: flush the range before zero range conversion)
  		truncate_pagecache_range(VFS_I(ip), start_boundary,
  					 end_boundary - 1);
 -
  		/* convert the blocks */
  		error = xfs_alloc_file_space(ip, start_boundary,
  					end_boundary - start_boundary - 1,
* Unmerged path fs/xfs/xfs_bmap_util.c
