acpi-cpufreq: Fix CPU hotplug callback registration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
commit 0197fbd212461f25666272b9e4654f2ccd94cff8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0197fbd2.failed

Subsystems that want to register CPU hotplug callbacks, as well as perform
initialization for the CPUs that are already online, often do it as shown
below:

	get_online_cpus();

	for_each_online_cpu(cpu)
		init_cpu(cpu);

	register_cpu_notifier(&foobar_cpu_notifier);

	put_online_cpus();

This is wrong, since it is prone to ABBA deadlocks involving the
cpu_add_remove_lock and the cpu_hotplug.lock (when running concurrently
with CPU hotplug operations).

Instead, the correct and race-free way of performing the callback
registration is:

	cpu_notifier_register_begin();

	for_each_online_cpu(cpu)
		init_cpu(cpu);

	/* Note the use of the double underscored version of the API */
	__register_cpu_notifier(&foobar_cpu_notifier);

	cpu_notifier_register_done();

Fix the acpi-cpufreq code by using this latter form of callback registration.

	Cc: Ingo Molnar <mingo@kernel.org>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 0197fbd212461f25666272b9e4654f2ccd94cff8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/acpi-cpufreq.c
diff --cc drivers/cpufreq/acpi-cpufreq.c
index 8e964dd05506,245ae078e68e..000000000000
--- a/drivers/cpufreq/acpi-cpufreq.c
+++ b/drivers/cpufreq/acpi-cpufreq.c
@@@ -952,33 -905,23 +952,45 @@@ static void __init acpi_cpufreq_boost_i
  		if (!msrs)
  			return;
  
++<<<<<<< HEAD
 +		boost_supported = true;
 +		boost_enabled = boost_state(0);
 +
 +		get_online_cpus();
++=======
+ 		acpi_cpufreq_driver.boost_supported = true;
+ 		acpi_cpufreq_driver.boost_enabled = boost_state(0);
+ 
+ 		cpu_notifier_register_begin();
++>>>>>>> 0197fbd21246 (acpi-cpufreq: Fix CPU hotplug callback registration)
  
  		/* Force all MSRs to the same value */
 -		boost_set_msrs(acpi_cpufreq_driver.boost_enabled,
 -			       cpu_online_mask);
 +		boost_set_msrs(boost_enabled, cpu_online_mask);
  
- 		register_cpu_notifier(&boost_nb);
+ 		__register_cpu_notifier(&boost_nb);
  
++<<<<<<< HEAD
 +		put_online_cpus();
 +	} else
 +		global_boost.attr.mode = 0444;
 +
 +	/* We create the boost file in any case, though for systems without
 +	 * hardware support it will be read-only and hardwired to return 0.
 +	 */
 +	if (cpufreq_sysfs_create_file(&(global_boost.attr)))
 +		pr_warn(PFX "could not register global boost sysfs file\n");
 +	else
 +		pr_debug("registered global boost sysfs file\n");
++=======
+ 		cpu_notifier_register_done();
+ 	}
++>>>>>>> 0197fbd21246 (acpi-cpufreq: Fix CPU hotplug callback registration)
  }
  
 -static void acpi_cpufreq_boost_exit(void)
 +static void __exit acpi_cpufreq_boost_exit(void)
  {
 +	cpufreq_sysfs_remove_file(&(global_boost.attr));
 +
  	if (msrs) {
  		unregister_cpu_notifier(&boost_nb);
  
* Unmerged path drivers/cpufreq/acpi-cpufreq.c
