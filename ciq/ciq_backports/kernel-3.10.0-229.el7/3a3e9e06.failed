cpufreq: Give consistent names to cpufreq_policy objects

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Give consistent names to cpufreq_policy objects (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 91.26%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 3a3e9e06d0c11b8efa95933a88c9e67209fa4330
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3a3e9e06.failed

They are called policy, cur_policy, new_policy, data, etc.  Just call
them policy wherever possible.

	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 3a3e9e06d0c11b8efa95933a88c9e67209fa4330)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
#	include/linux/cpufreq.h
diff --cc drivers/cpufreq/cpufreq.c
index 3e5c5b7058fc,1793fe82595d..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -182,46 -177,78 +182,97 @@@ u64 get_cpu_idle_time(unsigned int cpu
  }
  EXPORT_SYMBOL_GPL(get_cpu_idle_time);
  
 -static struct cpufreq_policy *__cpufreq_cpu_get(unsigned int cpu, bool sysfs)
 +struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu)
  {
++<<<<<<< HEAD
 +	struct cpufreq_policy *policy = NULL;
++=======
+ 	struct cpufreq_policy *policy;
++>>>>>>> 3a3e9e06d0c1 (cpufreq: Give consistent names to cpufreq_policy objects)
  	unsigned long flags;
  
 -	if (cpu >= nr_cpu_ids)
 -		goto err_out;
 +	if (cpufreq_disabled() || (cpu >= nr_cpu_ids))
 +		return NULL;
 +
 +	if (!down_read_trylock(&cpufreq_rwsem))
 +		return NULL;
  
  	/* get the cpufreq driver */
  	read_lock_irqsave(&cpufreq_driver_lock, flags);
  
++<<<<<<< HEAD
 +	if (cpufreq_driver) {
 +		/* get the CPU */
 +		policy = per_cpu(cpufreq_cpu_data, cpu);
 +		if (policy)
 +			kobject_get(&policy->kobj);
 +	}
 +
 +	read_unlock_irqrestore(&cpufreq_driver_lock, flags);
++=======
+ 	if (!cpufreq_driver)
+ 		goto err_out_unlock;
+ 
+ 	if (!try_module_get(cpufreq_driver->owner))
+ 		goto err_out_unlock;
+ 
+ 	/* get the CPU */
+ 	policy = per_cpu(cpufreq_cpu_data, cpu);
+ 
+ 	if (!policy)
+ 		goto err_out_put_module;
+ 
+ 	if (!sysfs && !kobject_get(&policy->kobj))
+ 		goto err_out_put_module;
+ 
+ 	read_unlock_irqrestore(&cpufreq_driver_lock, flags);
+ 	return policy;
++>>>>>>> 3a3e9e06d0c1 (cpufreq: Give consistent names to cpufreq_policy objects)
  
 -err_out_put_module:
 -	module_put(cpufreq_driver->owner);
 -err_out_unlock:
 -	read_unlock_irqrestore(&cpufreq_driver_lock, flags);
 -err_out:
 -	return NULL;
 -}
 -
 -struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu)
 -{
 -	if (cpufreq_disabled())
 -		return NULL;
 +	if (!policy)
 +		up_read(&cpufreq_rwsem);
  
 -	return __cpufreq_cpu_get(cpu, false);
 +	return policy;
  }
  EXPORT_SYMBOL_GPL(cpufreq_cpu_get);
  
++<<<<<<< HEAD
++=======
+ static struct cpufreq_policy *cpufreq_cpu_get_sysfs(unsigned int cpu)
+ {
+ 	return __cpufreq_cpu_get(cpu, true);
+ }
+ 
+ static void __cpufreq_cpu_put(struct cpufreq_policy *policy, bool sysfs)
+ {
+ 	if (!sysfs)
+ 		kobject_put(&policy->kobj);
+ 	module_put(cpufreq_driver->owner);
+ }
+ 
++>>>>>>> 3a3e9e06d0c1 (cpufreq: Give consistent names to cpufreq_policy objects)
  void cpufreq_cpu_put(struct cpufreq_policy *policy)
  {
  	if (cpufreq_disabled())
  		return;
  
++<<<<<<< HEAD
 +	kobject_put(&policy->kobj);
 +	up_read(&cpufreq_rwsem);
 +}
 +EXPORT_SYMBOL_GPL(cpufreq_cpu_put);
 +
++=======
+ 	__cpufreq_cpu_put(policy, false);
+ }
+ EXPORT_SYMBOL_GPL(cpufreq_cpu_put);
+ 
+ static void cpufreq_cpu_put_sysfs(struct cpufreq_policy *policy)
+ {
+ 	__cpufreq_cpu_put(policy, true);
+ }
+ 
++>>>>>>> 3a3e9e06d0c1 (cpufreq: Give consistent names to cpufreq_policy objects)
  /*********************************************************************
   *            EXTERNALLY AFFECTING FREQUENCY CHANGES                 *
   *********************************************************************/
@@@ -1067,17 -1136,22 +1118,31 @@@ static void update_policy_cpu(struct cp
  			CPUFREQ_UPDATE_POLICY_CPU, policy);
  }
  
++<<<<<<< HEAD
 +static int cpufreq_nominate_new_policy_cpu(struct cpufreq_policy *data,
 +					   unsigned int old_cpu)
++=======
+ static int cpufreq_nominate_new_policy_cpu(struct cpufreq_policy *policy,
+ 					   unsigned int old_cpu, bool frozen)
++>>>>>>> 3a3e9e06d0c1 (cpufreq: Give consistent names to cpufreq_policy objects)
  {
  	struct device *cpu_dev;
  	unsigned long flags;
  	int ret;
  
  	/* first sibling now owns the new sysfs dir */
++<<<<<<< HEAD
 +	cpu_dev = get_cpu_device(cpumask_first(data->cpus));
++=======
+ 	cpu_dev = get_cpu_device(cpumask_first(policy->cpus));
+ 
+ 	/* Don't touch sysfs files during light-weight tear-down */
+ 	if (frozen)
+ 		return cpu_dev->id;
+ 
++>>>>>>> 3a3e9e06d0c1 (cpufreq: Give consistent names to cpufreq_policy objects)
  	sysfs_remove_link(&cpu_dev->kobj, "cpufreq");
- 	ret = kobject_move(&data->kobj, &cpu_dev->kobj);
+ 	ret = kobject_move(&policy->kobj, &cpu_dev->kobj);
  	if (ret) {
  		pr_err("%s: Failed to move kobj: %d", __func__, ret);
  
@@@ -1120,12 -1194,16 +1185,19 @@@ static int __cpufreq_remove_dev(struct 
  
  	write_lock_irqsave(&cpufreq_driver_lock, flags);
  
- 	data = per_cpu(cpufreq_cpu_data, cpu);
+ 	policy = per_cpu(cpufreq_cpu_data, cpu);
  	per_cpu(cpufreq_cpu_data, cpu) = NULL;
  
++<<<<<<< HEAD
++=======
+ 	/* Save the policy somewhere when doing a light-weight tear-down */
+ 	if (frozen)
+ 		per_cpu(cpufreq_cpu_data_fallback, cpu) = policy;
+ 
++>>>>>>> 3a3e9e06d0c1 (cpufreq: Give consistent names to cpufreq_policy objects)
  	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
  
- 	if (!data) {
+ 	if (!policy) {
  		pr_debug("%s: No cpu_data found\n", __func__);
  		return -EINVAL;
  	}
@@@ -1140,55 -1218,65 +1212,77 @@@
  #endif
  
  	WARN_ON(lock_policy_rwsem_write(cpu));
- 	cpus = cpumask_weight(data->cpus);
+ 	cpus = cpumask_weight(policy->cpus);
  
  	if (cpus > 1)
- 		cpumask_clear_cpu(cpu, data->cpus);
+ 		cpumask_clear_cpu(cpu, policy->cpus);
  	unlock_policy_rwsem_write(cpu);
  
++<<<<<<< HEAD
 +	if (cpu != data->cpu) {
 +		sysfs_remove_link(&dev->kobj, "cpufreq");
 +	} else if (cpus > 1) {
 +
 +		new_cpu = cpufreq_nominate_new_policy_cpu(data, cpu);
++=======
+ 	if (cpu != policy->cpu && !frozen) {
+ 		sysfs_remove_link(&dev->kobj, "cpufreq");
+ 	} else if (cpus > 1) {
+ 
+ 		new_cpu = cpufreq_nominate_new_policy_cpu(policy, cpu, frozen);
++>>>>>>> 3a3e9e06d0c1 (cpufreq: Give consistent names to cpufreq_policy objects)
  		if (new_cpu >= 0) {
  			WARN_ON(lock_policy_rwsem_write(cpu));
- 			update_policy_cpu(data, new_cpu);
+ 			update_policy_cpu(policy, new_cpu);
  			unlock_policy_rwsem_write(cpu);
 -
 -			if (!frozen) {
 -				pr_debug("%s: policy Kobject moved to cpu: %d "
 -					 "from: %d\n",__func__, new_cpu, cpu);
 -			}
 +			pr_debug("%s: policy Kobject moved to cpu: %d "
 +				 "from: %d\n",__func__, new_cpu, cpu);
  		}
  	}
  
  	/* If cpu is last user of policy, free policy */
  	if (cpus == 1) {
  		if (cpufreq_driver->target)
- 			__cpufreq_governor(data, CPUFREQ_GOV_POLICY_EXIT);
+ 			__cpufreq_governor(policy, CPUFREQ_GOV_POLICY_EXIT);
  
++<<<<<<< HEAD
 +		lock_policy_rwsem_read(cpu);
 +		kobj = &data->kobj;
 +		cmp = &data->kobj_unregister;
 +		unlock_policy_rwsem_read(cpu);
 +		kobject_put(kobj);
++=======
+ 		if (!frozen) {
+ 			lock_policy_rwsem_read(cpu);
+ 			kobj = &policy->kobj;
+ 			cmp = &policy->kobj_unregister;
+ 			unlock_policy_rwsem_read(cpu);
+ 			kobject_put(kobj);
++>>>>>>> 3a3e9e06d0c1 (cpufreq: Give consistent names to cpufreq_policy objects)
  
 -			/*
 -			 * We need to make sure that the underlying kobj is
 -			 * actually not referenced anymore by anybody before we
 -			 * proceed with unloading.
 -			 */
 -			pr_debug("waiting for dropping of refcount\n");
 -			wait_for_completion(cmp);
 -			pr_debug("wait complete\n");
 -		}
 -
 -		/*
 -		 * Perform the ->exit() even during light-weight tear-down,
 -		 * since this is a core component, and is essential for the
 -		 * subsequent light-weight ->init() to succeed.
 +		/* we need to make sure that the underlying kobj is actually
 +		 * not referenced anymore by anybody before we proceed with
 +		 * unloading.
  		 */
 +		pr_debug("waiting for dropping of refcount\n");
 +		wait_for_completion(cmp);
 +		pr_debug("wait complete\n");
 +
  		if (cpufreq_driver->exit)
- 			cpufreq_driver->exit(data);
+ 			cpufreq_driver->exit(policy);
  
++<<<<<<< HEAD
 +		free_cpumask_var(data->related_cpus);
 +		free_cpumask_var(data->cpus);
 +		kfree(data);
++=======
+ 		if (!frozen)
+ 			cpufreq_policy_free(policy);
++>>>>>>> 3a3e9e06d0c1 (cpufreq: Give consistent names to cpufreq_policy objects)
  	} else {
  		if (cpufreq_driver->target) {
- 			__cpufreq_governor(data, CPUFREQ_GOV_START);
- 			__cpufreq_governor(data, CPUFREQ_GOV_LIMITS);
+ 			__cpufreq_governor(policy, CPUFREQ_GOV_START);
+ 			__cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
  		}
  	}
  
diff --cc include/linux/cpufreq.h
index 94c9bbcb39e4,29208923c9d3..000000000000
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@@ -129,6 -93,9 +129,12 @@@ struct cpufreq_policy 
  #define CPUFREQ_SHARED_TYPE_ALL	 (2) /* All dependent CPUs should set freq */
  #define CPUFREQ_SHARED_TYPE_ANY	 (3) /* Freq can be set from any dependent CPU*/
  
++<<<<<<< HEAD
++=======
+ struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
+ void cpufreq_cpu_put(struct cpufreq_policy *policy);
+ 
++>>>>>>> 3a3e9e06d0c1 (cpufreq: Give consistent names to cpufreq_policy objects)
  static inline bool policy_is_shared(struct cpufreq_policy *policy)
  {
  	return cpumask_weight(policy->cpus) > 1;
* Unmerged path drivers/cpufreq/cpufreq.c
diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index 7db437370f38..a02d78b25898 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -221,7 +221,7 @@ struct od_ops {
 	void (*powersave_bias_init_cpu)(int cpu);
 	unsigned int (*powersave_bias_target)(struct cpufreq_policy *policy,
 			unsigned int freq_next, unsigned int relation);
-	void (*freq_increase)(struct cpufreq_policy *p, unsigned int freq);
+	void (*freq_increase)(struct cpufreq_policy *policy, unsigned int freq);
 };
 
 struct cs_ops {
diff --git a/drivers/cpufreq/cpufreq_ondemand.c b/drivers/cpufreq/cpufreq_ondemand.c
index 232de607a7a7..8f134b3d7904 100644
--- a/drivers/cpufreq/cpufreq_ondemand.c
+++ b/drivers/cpufreq/cpufreq_ondemand.c
@@ -132,18 +132,18 @@ static void ondemand_powersave_bias_init(void)
 	}
 }
 
-static void dbs_freq_increase(struct cpufreq_policy *p, unsigned int freq)
+static void dbs_freq_increase(struct cpufreq_policy *policy, unsigned int freq)
 {
-	struct dbs_data *dbs_data = p->governor_data;
+	struct dbs_data *dbs_data = policy->governor_data;
 	struct od_dbs_tuners *od_tuners = dbs_data->tuners;
 
 	if (od_tuners->powersave_bias)
-		freq = od_ops.powersave_bias_target(p, freq,
+		freq = od_ops.powersave_bias_target(policy, freq,
 				CPUFREQ_RELATION_H);
-	else if (p->cur == p->max)
+	else if (policy->cur == policy->max)
 		return;
 
-	__cpufreq_driver_target(p, freq, od_tuners->powersave_bias ?
+	__cpufreq_driver_target(policy, freq, od_tuners->powersave_bias ?
 			CPUFREQ_RELATION_L : CPUFREQ_RELATION_H);
 }
 
diff --git a/drivers/cpufreq/cpufreq_stats.c b/drivers/cpufreq/cpufreq_stats.c
index ee6a6db3cbe4..dc261f7aa100 100644
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@ -193,7 +193,7 @@ static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 {
 	unsigned int i, j, count = 0, ret = 0;
 	struct cpufreq_stats *stat;
-	struct cpufreq_policy *data;
+	struct cpufreq_policy *current_policy;
 	unsigned int alloc_size;
 	unsigned int cpu = policy->cpu;
 	if (per_cpu(cpufreq_stats_table, cpu))
@@ -202,13 +202,13 @@ static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 	if ((stat) == NULL)
 		return -ENOMEM;
 
-	data = cpufreq_cpu_get(cpu);
-	if (data == NULL) {
+	current_policy = cpufreq_cpu_get(cpu);
+	if (current_policy == NULL) {
 		ret = -EINVAL;
 		goto error_get_fail;
 	}
 
-	ret = sysfs_create_group(&data->kobj, &stats_attr_group);
+	ret = sysfs_create_group(&current_policy->kobj, &stats_attr_group);
 	if (ret)
 		goto error_out;
 
@@ -251,10 +251,10 @@ static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 	stat->last_time = get_jiffies_64();
 	stat->last_index = freq_table_get_index(stat, policy->cur);
 	spin_unlock(&cpufreq_stats_lock);
-	cpufreq_cpu_put(data);
+	cpufreq_cpu_put(current_policy);
 	return 0;
 error_out:
-	cpufreq_cpu_put(data);
+	cpufreq_cpu_put(current_policy);
 error_get_fail:
 	kfree(stat);
 	per_cpu(cpufreq_stats_table, cpu) = NULL;
* Unmerged path include/linux/cpufreq.h
