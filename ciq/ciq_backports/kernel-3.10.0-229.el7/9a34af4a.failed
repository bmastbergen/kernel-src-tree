ALSA: hda - Move more PCI-controller-specific stuff from generic code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [alsa] hda: Move more PCI-controller-specific stuff from generic code (Jaroslav Kysela) [1112200]
Rebuild_FUZZ: 93.13%
commit-author Takashi Iwai <tiwai@suse.de>
commit 9a34af4a33270acbd60a85f819553463866aecbb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/9a34af4a.failed

Just move struct fields between struct azx and struct hda_intel, and
move some definitions from hda_priv.h to hda_intel.c.

	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit 9a34af4a33270acbd60a85f819553463866aecbb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_intel.c
diff --cc sound/pci/hda/hda_intel.c
index c74374a10f3c,bbb446aef67a..000000000000
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@@ -63,8 -63,38 +63,40 @@@
  #include <linux/firmware.h>
  #include "hda_codec.h"
  #include "hda_i915.h"
 -#include "hda_controller.h"
  #include "hda_priv.h"
  
++<<<<<<< HEAD
++=======
+ /* position fix mode */
+ enum {
+ 	POS_FIX_AUTO,
+ 	POS_FIX_LPIB,
+ 	POS_FIX_POSBUF,
+ 	POS_FIX_VIACOMBO,
+ 	POS_FIX_COMBO,
+ };
+ 
+ /* Defines for ATI HD Audio support in SB450 south bridge */
+ #define ATI_SB450_HDAUDIO_MISC_CNTR2_ADDR   0x42
+ #define ATI_SB450_HDAUDIO_ENABLE_SNOOP      0x02
+ 
+ /* Defines for Nvidia HDA support */
+ #define NVIDIA_HDA_TRANSREG_ADDR      0x4e
+ #define NVIDIA_HDA_ENABLE_COHBITS     0x0f
+ #define NVIDIA_HDA_ISTRM_COH          0x4d
+ #define NVIDIA_HDA_OSTRM_COH          0x4c
+ #define NVIDIA_HDA_ENABLE_COHBIT      0x01
+ 
+ /* Defines for Intel SCH HDA snoop control */
+ #define INTEL_SCH_HDA_DEVC      0x78
+ #define INTEL_SCH_HDA_DEVC_NOSNOOP       (0x1<<11)
+ 
+ /* Define IN stream 0 FIFO size offset in VIA controller */
+ #define VIA_IN_STREAM0_FIFO_SIZE_OFFSET	0x90
+ /* Define VIA HD Audio Device ID*/
+ #define VIA_HDAC_DEVICE_ID		0x3288
+ 
++>>>>>>> 9a34af4a3327 (ALSA: hda - Move more PCI-controller-specific stuff from generic code)
  
  static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
  static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;
@@@ -308,8 -317,43 +340,48 @@@ static char *driver_short_names[] = 
  	[AZX_DRIVER_GENERIC] = "HD-Audio Generic",
  };
  
++<<<<<<< HEAD
 +/* for pcm support */
 +#define get_azx_dev(substream) (substream->runtime->private_data)
++=======
+ 
+ /* Intel HSW/BDW display HDA controller Extended Mode registers.
+  * EM4 (M value) and EM5 (N Value) are used to convert CDClk (Core Display
+  * Clock) to 24MHz BCLK: BCLK = CDCLK * M / N
+  * The values will be lost when the display power well is disabled.
+  */
+ #define ICH6_REG_EM4			0x100c
+ #define ICH6_REG_EM5			0x1010
+ 
+ struct hda_intel {
+ 	struct azx chip;
+ 
+ 	/* HSW/BDW display HDA controller to restore BCLK from CDCLK */
+ 	unsigned int bclk_m;
+ 	unsigned int bclk_n;
+ 
+ 	/* for pending irqs */
+ 	struct work_struct irq_pending_work;
+ 
+ 	/* sync probing */
+ 	struct completion probe_wait;
+ 	struct work_struct probe_work;
+ 
+ 	/* card list (for power_save trigger) */
+ 	struct list_head list;
+ 
+ 	/* extra flags */
+ 	unsigned int irq_pending_warned:1;
+ 
+ 	/* VGA-switcheroo setup */
+ 	unsigned int use_vga_switcheroo:1;
+ 	unsigned int vga_switcheroo_registered:1;
+ 	unsigned int init_failed:1; /* delayed init failed */
+ 
+ 	/* secondary power domain for hdmi audio under vga device */
+ 	struct dev_pm_domain hdmi_pm_domain;
+ };
++>>>>>>> 9a34af4a3327 (ALSA: hda - Move more PCI-controller-specific stuff from generic code)
  
  #ifdef CONFIG_X86
  static void __mark_pages_wc(struct azx *chip, struct snd_dma_buffer *dmab, bool on)
@@@ -1032,1121 -486,94 +1104,1173 @@@ static void azx_init_pci(struct azx *ch
  
  static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev);
  
++<<<<<<< HEAD
++=======
+ /* called from IRQ */
+ static int azx_position_check(struct azx *chip, struct azx_dev *azx_dev)
+ {
+ 	struct hda_intel *hda = container_of(chip, struct hda_intel, chip);
+ 	int ok;
+ 
+ 	ok = azx_position_ok(chip, azx_dev);
+ 	if (ok == 1) {
+ 		azx_dev->irq_pending = 0;
+ 		return ok;
+ 	} else if (ok == 0 && chip->bus && chip->bus->workq) {
+ 		/* bogus IRQ, process it later */
+ 		azx_dev->irq_pending = 1;
+ 		queue_work(chip->bus->workq, &hda->irq_pending_work);
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 9a34af4a3327 (ALSA: hda - Move more PCI-controller-specific stuff from generic code)
  /*
 - * Check whether the current DMA position is acceptable for updating
 - * periods.  Returns non-zero if it's OK.
 - *
 - * Many HD-audio controllers appear pretty inaccurate about
 - * the update-IRQ timing.  The IRQ is issued before actually the
 - * data is processed.  So, we need to process it afterwords in a
 - * workqueue.
 + * interrupt handler
   */
 -static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev)
 +static irqreturn_t azx_interrupt(int irq, void *dev_id)
  {
 -	struct snd_pcm_substream *substream = azx_dev->substream;
 -	int stream = substream->stream;
 -	u32 wallclk;
 -	unsigned int pos;
 +	struct azx *chip = dev_id;
 +	struct azx_dev *azx_dev;
 +	u32 status;
 +	u8 sd_status;
 +	int i, ok;
  
 -	wallclk = azx_readl(chip, WALLCLK) - azx_dev->start_wallclk;
 -	if (wallclk < (azx_dev->period_wallclk * 2) / 3)
 -		return -1;	/* bogus (too early) interrupt */
 +#ifdef CONFIG_PM_RUNTIME
 +	if (chip->driver_caps & AZX_DCAPS_PM_RUNTIME)
 +		if (chip->card->dev->power.runtime_status != RPM_ACTIVE)
 +			return IRQ_NONE;
 +#endif
  
 -	if (chip->get_position[stream])
 -		pos = chip->get_position[stream](chip, azx_dev);
 -	else { /* use the position buffer as default */
 -		pos = azx_get_pos_posbuf(chip, azx_dev);
 -		if (!pos || pos == (u32)-1) {
 -			dev_info(chip->card->dev,
 -				 "Invalid position buffer, using LPIB read method instead.\n");
 -			chip->get_position[stream] = azx_get_pos_lpib;
 -			pos = azx_get_pos_lpib(chip, azx_dev);
 -			chip->get_delay[stream] = NULL;
 -		} else {
 -			chip->get_position[stream] = azx_get_pos_posbuf;
 -			if (chip->driver_caps & AZX_DCAPS_COUNT_LPIB_DELAY)
 -				chip->get_delay[stream] = azx_get_delay_from_lpib;
 -		}
 +	spin_lock(&chip->reg_lock);
 +
 +	if (chip->disabled) {
 +		spin_unlock(&chip->reg_lock);
 +		return IRQ_NONE;
  	}
  
 -	if (pos >= azx_dev->bufsize)
 -		pos = 0;
++<<<<<<< HEAD
 +	status = azx_readl(chip, INTSTS);
 +	if (status == 0 || status == 0xffffffff) {
 +		spin_unlock(&chip->reg_lock);
 +		return IRQ_NONE;
++=======
++	if (pos >= azx_dev->bufsize)
++		pos = 0;
++
++	if (WARN_ONCE(!azx_dev->period_bytes,
++		      "hda-intel: zero azx_dev->period_bytes"))
++		return -1; /* this shouldn't happen! */
++	if (wallclk < (azx_dev->period_wallclk * 5) / 4 &&
++	    pos % azx_dev->period_bytes > azx_dev->period_bytes / 2)
++		/* NG - it's below the first next period boundary */
++		return chip->bdl_pos_adj[chip->dev_index] ? 0 : -1;
++	azx_dev->start_wallclk += wallclk;
++	return 1; /* OK, it's fine */
++}
++
++/*
++ * The work for pending PCM period updates.
++ */
++static void azx_irq_pending_work(struct work_struct *work)
++{
++	struct hda_intel *hda = container_of(work, struct hda_intel, irq_pending_work);
++	struct azx *chip = &hda->chip;
++	int i, pending, ok;
++
++	if (!hda->irq_pending_warned) {
++		dev_info(chip->card->dev,
++			 "IRQ timing workaround is activated for card #%d. Suggest a bigger bdl_pos_adj.\n",
++			 chip->card->number);
++		hda->irq_pending_warned = 1;
++>>>>>>> 9a34af4a3327 (ALSA: hda - Move more PCI-controller-specific stuff from generic code)
 +	}
 +	
 +	for (i = 0; i < chip->num_streams; i++) {
 +		azx_dev = &chip->azx_dev[i];
 +		if (status & azx_dev->sd_int_sta_mask) {
 +			sd_status = azx_sd_readb(chip, azx_dev, SD_STS);
 +			azx_sd_writeb(chip, azx_dev, SD_STS, SD_INT_MASK);
 +			if (!azx_dev->substream || !azx_dev->running ||
 +			    !(sd_status & SD_INT_COMPLETE))
 +				continue;
 +			/* check whether this IRQ is really acceptable */
 +			ok = azx_position_ok(chip, azx_dev);
 +			if (ok == 1) {
 +				azx_dev->irq_pending = 0;
 +				spin_unlock(&chip->reg_lock);
 +				snd_pcm_period_elapsed(azx_dev->substream);
 +				spin_lock(&chip->reg_lock);
 +			} else if (ok == 0 && chip->bus && chip->bus->workq) {
 +				/* bogus IRQ, process it later */
 +				azx_dev->irq_pending = 1;
 +				queue_work(chip->bus->workq,
 +					   &chip->irq_pending_work);
 +			}
 +		}
 +	}
 +
 +	/* clear rirb int */
 +	status = azx_readb(chip, RIRBSTS);
 +	if (status & RIRB_INT_MASK) {
 +		if (status & RIRB_INT_RESPONSE) {
 +			if (chip->driver_caps & AZX_DCAPS_RIRB_PRE_DELAY)
 +				udelay(80);
 +			azx_update_rirb(chip);
 +		}
 +		azx_writeb(chip, RIRBSTS, RIRB_INT_MASK);
 +	}
 +
 +	spin_unlock(&chip->reg_lock);
 +	
 +	return IRQ_HANDLED;
 +}
 +
 +
 +/*
 + * set up a BDL entry
 + */
 +static int setup_bdle(struct azx *chip,
 +		      struct snd_dma_buffer *dmab,
 +		      struct azx_dev *azx_dev, u32 **bdlp,
 +		      int ofs, int size, int with_ioc)
 +{
 +	u32 *bdl = *bdlp;
 +
 +	while (size > 0) {
 +		dma_addr_t addr;
 +		int chunk;
 +
 +		if (azx_dev->frags >= AZX_MAX_BDL_ENTRIES)
 +			return -EINVAL;
 +
 +		addr = snd_sgbuf_get_addr(dmab, ofs);
 +		/* program the address field of the BDL entry */
 +		bdl[0] = cpu_to_le32((u32)addr);
 +		bdl[1] = cpu_to_le32(upper_32_bits(addr));
 +		/* program the size field of the BDL entry */
 +		chunk = snd_sgbuf_get_chunk_size(dmab, ofs, size);
 +		/* one BDLE cannot cross 4K boundary on CTHDA chips */
 +		if (chip->driver_caps & AZX_DCAPS_4K_BDLE_BOUNDARY) {
 +			u32 remain = 0x1000 - (ofs & 0xfff);
 +			if (chunk > remain)
 +				chunk = remain;
 +		}
 +		bdl[2] = cpu_to_le32(chunk);
 +		/* program the IOC to enable interrupt
 +		 * only when the whole fragment is processed
 +		 */
 +		size -= chunk;
 +		bdl[3] = (size || !with_ioc) ? 0 : cpu_to_le32(0x01);
 +		bdl += 4;
 +		azx_dev->frags++;
 +		ofs += chunk;
 +	}
 +	*bdlp = bdl;
 +	return ofs;
 +}
 +
 +/*
 + * set up BDL entries
 + */
 +static int azx_setup_periods(struct azx *chip,
 +			     struct snd_pcm_substream *substream,
 +			     struct azx_dev *azx_dev)
 +{
 +	u32 *bdl;
 +	int i, ofs, periods, period_bytes;
 +	int pos_adj;
 +
 +	/* reset BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +
 +	period_bytes = azx_dev->period_bytes;
 +	periods = azx_dev->bufsize / period_bytes;
 +
 +	/* program the initial BDL entries */
 +	bdl = (u32 *)azx_dev->bdl.area;
 +	ofs = 0;
 +	azx_dev->frags = 0;
 +	pos_adj = bdl_pos_adj[chip->dev_index];
 +	if (!azx_dev->no_period_wakeup && pos_adj > 0) {
 +		struct snd_pcm_runtime *runtime = substream->runtime;
 +		int pos_align = pos_adj;
 +		pos_adj = (pos_adj * runtime->rate + 47999) / 48000;
 +		if (!pos_adj)
 +			pos_adj = pos_align;
 +		else
 +			pos_adj = ((pos_adj + pos_align - 1) / pos_align) *
 +				pos_align;
 +		pos_adj = frames_to_bytes(runtime, pos_adj);
 +		if (pos_adj >= period_bytes) {
 +			snd_printk(KERN_WARNING SFX "%s: Too big adjustment %d\n",
 +				   pci_name(chip->pci), bdl_pos_adj[chip->dev_index]);
 +			pos_adj = 0;
 +		} else {
 +			ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
 +					 azx_dev,
 +					 &bdl, ofs, pos_adj, true);
 +			if (ofs < 0)
 +				goto error;
 +		}
 +	} else
 +		pos_adj = 0;
 +	for (i = 0; i < periods; i++) {
 +		if (i == periods - 1 && pos_adj)
 +			ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
 +					 azx_dev, &bdl, ofs,
 +					 period_bytes - pos_adj, 0);
 +		else
 +			ofs = setup_bdle(chip, snd_pcm_get_dma_buf(substream),
 +					 azx_dev, &bdl, ofs,
 +					 period_bytes,
 +					 !azx_dev->no_period_wakeup);
 +		if (ofs < 0)
 +			goto error;
 +	}
 +	return 0;
 +
 + error:
 +	snd_printk(KERN_ERR SFX "%s: Too many BDL entries: buffer=%d, period=%d\n",
 +		   pci_name(chip->pci), azx_dev->bufsize, period_bytes);
 +	return -EINVAL;
 +}
 +
 +/* reset stream */
 +static void azx_stream_reset(struct azx *chip, struct azx_dev *azx_dev)
 +{
 +	unsigned char val;
 +	int timeout;
 +
 +	azx_stream_clear(chip, azx_dev);
 +
 +	azx_sd_writeb(chip, azx_dev, SD_CTL,
 +		      azx_sd_readb(chip, azx_dev, SD_CTL) |
 +		      SD_CTL_STREAM_RESET);
 +	udelay(3);
 +	timeout = 300;
 +	while (!((val = azx_sd_readb(chip, azx_dev, SD_CTL)) &
 +		 SD_CTL_STREAM_RESET) && --timeout)
 +		;
 +	val &= ~SD_CTL_STREAM_RESET;
 +	azx_sd_writeb(chip, azx_dev, SD_CTL, val);
 +	udelay(3);
 +
 +	timeout = 300;
 +	/* waiting for hardware to report that the stream is out of reset */
 +	while (((val = azx_sd_readb(chip, azx_dev, SD_CTL)) &
 +		SD_CTL_STREAM_RESET) && --timeout)
 +		;
 +
 +	/* reset first position - may not be synced with hw at this time */
 +	*azx_dev->posbuf = 0;
 +}
 +
 +/*
 + * set up the SD for streaming
 + */
 +static int azx_setup_controller(struct azx *chip, struct azx_dev *azx_dev)
 +{
 +	unsigned int val;
 +	/* make sure the run bit is zero for SD */
 +	azx_stream_clear(chip, azx_dev);
 +	/* program the stream_tag */
 +	val = azx_sd_readl(chip, azx_dev, SD_CTL);
 +	val = (val & ~SD_CTL_STREAM_TAG_MASK) |
 +		(azx_dev->stream_tag << SD_CTL_STREAM_TAG_SHIFT);
 +	if (!azx_snoop(chip))
 +		val |= SD_CTL_TRAFFIC_PRIO;
 +	azx_sd_writel(chip, azx_dev, SD_CTL, val);
 +
 +	/* program the length of samples in cyclic buffer */
 +	azx_sd_writel(chip, azx_dev, SD_CBL, azx_dev->bufsize);
 +
 +	/* program the stream format */
 +	/* this value needs to be the same as the one programmed */
 +	azx_sd_writew(chip, azx_dev, SD_FORMAT, azx_dev->format_val);
 +
 +	/* program the stream LVI (last valid index) of the BDL */
 +	azx_sd_writew(chip, azx_dev, SD_LVI, azx_dev->frags - 1);
 +
 +	/* program the BDL address */
 +	/* lower BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPL, (u32)azx_dev->bdl.addr);
 +	/* upper BDL address */
 +	azx_sd_writel(chip, azx_dev, SD_BDLPU,
 +		      upper_32_bits(azx_dev->bdl.addr));
 +
 +	/* enable the position buffer */
 +	if (chip->position_fix[0] != POS_FIX_LPIB ||
 +	    chip->position_fix[1] != POS_FIX_LPIB) {
 +		if (!(azx_readl(chip, DPLBASE) & ICH6_DPLBASE_ENABLE))
 +			azx_writel(chip, DPLBASE,
 +				(u32)chip->posbuf.addr | ICH6_DPLBASE_ENABLE);
 +	}
 +
 +	/* set the interrupt enable bits in the descriptor control register */
 +	azx_sd_writel(chip, azx_dev, SD_CTL,
 +		      azx_sd_readl(chip, azx_dev, SD_CTL) | SD_INT_MASK);
 +
 +	return 0;
 +}
 +
 +/*
 + * Probe the given codec address
 + */
 +static int probe_codec(struct azx *chip, int addr)
 +{
 +	unsigned int cmd = (addr << 28) | (AC_NODE_ROOT << 20) |
 +		(AC_VERB_PARAMETERS << 8) | AC_PAR_VENDOR_ID;
 +	unsigned int res;
 +
 +	mutex_lock(&chip->bus->cmd_mutex);
 +	chip->probing = 1;
 +	azx_send_cmd(chip->bus, cmd);
 +	res = azx_get_response(chip->bus, addr);
 +	chip->probing = 0;
 +	mutex_unlock(&chip->bus->cmd_mutex);
 +	if (res == -1)
 +		return -EIO;
 +	snd_printdd(SFX "%s: codec #%d probed OK\n", pci_name(chip->pci), addr);
 +	return 0;
 +}
 +
 +static int azx_attach_pcm_stream(struct hda_bus *bus, struct hda_codec *codec,
 +				 struct hda_pcm *cpcm);
 +static void azx_stop_chip(struct azx *chip);
 +
 +static void azx_bus_reset(struct hda_bus *bus)
 +{
 +	struct azx *chip = bus->private_data;
 +
 +	bus->in_reset = 1;
 +	azx_stop_chip(chip);
 +	azx_init_chip(chip, 1);
 +#ifdef CONFIG_PM
 +	if (chip->initialized) {
 +		struct azx_pcm *p;
 +		list_for_each_entry(p, &chip->pcm_list, list)
 +			snd_pcm_suspend_all(p->pcm);
 +		snd_hda_suspend(chip->bus);
 +		snd_hda_resume(chip->bus);
 +	}
 +#endif
 +	bus->in_reset = 0;
 +}
 +
 +static int get_jackpoll_interval(struct azx *chip)
 +{
 +	int i;
 +	unsigned int j;
 +
 +	if (!chip->jackpoll_ms)
 +		return 0;
 +
 +	i = chip->jackpoll_ms[chip->dev_index];
 +	if (i == 0)
 +		return 0;
 +	if (i < 50 || i > 60000)
 +		j = 0;
 +	else
 +		j = msecs_to_jiffies(i);
 +	if (j == 0)
 +		snd_printk(KERN_WARNING SFX
 +			   "jackpoll_ms value out of range: %d\n", i);
 +	return j;
 +}
 +
 +/*
 + * Codec initialization
 + */
 +
 +static int azx_codec_create(struct azx *chip, const char *model,
 +			    unsigned int max_slots,
 +			    int *power_save_to)
 +{
 +	struct hda_bus_template bus_temp;
 +	int c, codecs, err;
 +
 +	memset(&bus_temp, 0, sizeof(bus_temp));
 +	bus_temp.private_data = chip;
 +	bus_temp.modelname = model;
 +	bus_temp.pci = chip->pci;
 +	bus_temp.ops.command = azx_send_cmd;
 +	bus_temp.ops.get_response = azx_get_response;
 +	bus_temp.ops.attach_pcm = azx_attach_pcm_stream;
 +	bus_temp.ops.bus_reset = azx_bus_reset;
 +#ifdef CONFIG_PM
 +	bus_temp.power_save = power_save_to;
 +	bus_temp.ops.pm_notify = azx_power_notify;
 +#endif
 +#ifdef CONFIG_SND_HDA_DSP_LOADER
 +	bus_temp.ops.load_dsp_prepare = azx_load_dsp_prepare;
 +	bus_temp.ops.load_dsp_trigger = azx_load_dsp_trigger;
 +	bus_temp.ops.load_dsp_cleanup = azx_load_dsp_cleanup;
 +#endif
 +
 +	err = snd_hda_bus_new(chip->card, &bus_temp, &chip->bus);
 +	if (err < 0)
 +		return err;
 +
 +	if (chip->driver_caps & AZX_DCAPS_RIRB_DELAY) {
 +		snd_printd(SFX "%s: Enable delay in RIRB handling\n", pci_name(chip->pci));
 +		chip->bus->needs_damn_long_delay = 1;
 +	}
 +
 +	codecs = 0;
 +	if (!max_slots)
 +		max_slots = AZX_DEFAULT_CODECS;
 +
 +	/* First try to probe all given codec slots */
 +	for (c = 0; c < max_slots; c++) {
 +		if ((chip->codec_mask & (1 << c)) & chip->codec_probe_mask) {
 +			if (probe_codec(chip, c) < 0) {
 +				/* Some BIOSen give you wrong codec addresses
 +				 * that don't exist
 +				 */
 +				snd_printk(KERN_WARNING SFX
 +					   "%s: Codec #%d probe error; "
 +					   "disabling it...\n", pci_name(chip->pci), c);
 +				chip->codec_mask &= ~(1 << c);
 +				/* More badly, accessing to a non-existing
 +				 * codec often screws up the controller chip,
 +				 * and disturbs the further communications.
 +				 * Thus if an error occurs during probing,
 +				 * better to reset the controller chip to
 +				 * get back to the sanity state.
 +				 */
 +				azx_stop_chip(chip);
 +				azx_init_chip(chip, 1);
 +			}
 +		}
 +	}
 +
 +	/* AMD chipsets often cause the communication stalls upon certain
 +	 * sequence like the pin-detection.  It seems that forcing the synced
 +	 * access works around the stall.  Grrr...
 +	 */
 +	if (chip->driver_caps & AZX_DCAPS_SYNC_WRITE) {
 +		snd_printd(SFX "%s: Enable sync_write for stable communication\n",
 +			pci_name(chip->pci));
 +		chip->bus->sync_write = 1;
 +		chip->bus->allow_bus_reset = 1;
 +	}
 +
 +	/* Then create codec instances */
 +	for (c = 0; c < max_slots; c++) {
 +		if ((chip->codec_mask & (1 << c)) & chip->codec_probe_mask) {
 +			struct hda_codec *codec;
 +			err = snd_hda_codec_new(chip->bus, c, &codec);
 +			if (err < 0)
 +				continue;
 +			codec->jackpoll_interval = get_jackpoll_interval(chip);
 +			codec->beep_mode = chip->beep_mode;
 +			codecs++;
 +		}
 +	}
 +	if (!codecs) {
 +		snd_printk(KERN_ERR SFX "%s: no codecs initialized\n", pci_name(chip->pci));
 +		return -ENXIO;
 +	}
 +	return 0;
 +}
 +
 +/* configure each codec instance */
 +static int azx_codec_configure(struct azx *chip)
 +{
 +	struct hda_codec *codec;
 +	list_for_each_entry(codec, &chip->bus->codec_list, list) {
 +		snd_hda_codec_configure(codec);
 +	}
 +	return 0;
 +}
 +
 +
 +/*
 + * PCM support
 + */
 +
 +/* assign a stream for the PCM */
 +static inline struct azx_dev *
 +azx_assign_device(struct azx *chip, struct snd_pcm_substream *substream)
 +{
 +	int dev, i, nums;
 +	struct azx_dev *res = NULL;
 +	/* make a non-zero unique key for the substream */
 +	int key = (substream->pcm->device << 16) | (substream->number << 2) |
 +		(substream->stream + 1);
 +
 +	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 +		dev = chip->playback_index_offset;
 +		nums = chip->playback_streams;
 +	} else {
 +		dev = chip->capture_index_offset;
 +		nums = chip->capture_streams;
 +	}
 +	for (i = 0; i < nums; i++, dev++) {
 +		struct azx_dev *azx_dev = &chip->azx_dev[dev];
 +		dsp_lock(azx_dev);
 +		if (!azx_dev->opened && !dsp_is_locked(azx_dev)) {
 +			res = azx_dev;
 +			if (res->assigned_key == key) {
 +				res->opened = 1;
 +				res->assigned_key = key;
 +				dsp_unlock(azx_dev);
 +				return azx_dev;
 +			}
 +		}
 +		dsp_unlock(azx_dev);
 +	}
 +	if (res) {
 +		dsp_lock(res);
 +		res->opened = 1;
 +		res->assigned_key = key;
 +		dsp_unlock(res);
 +	}
 +	return res;
 +}
 +
 +/* release the assigned stream */
 +static inline void azx_release_device(struct azx_dev *azx_dev)
 +{
 +	azx_dev->opened = 0;
 +}
 +
 +static cycle_t azx_cc_read(const struct cyclecounter *cc)
 +{
 +	struct azx_dev *azx_dev = container_of(cc, struct azx_dev, azx_cc);
 +	struct snd_pcm_substream *substream = azx_dev->substream;
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct azx *chip = apcm->chip;
 +
 +	return azx_readl(chip, WALLCLK);
 +}
 +
 +static void azx_timecounter_init(struct snd_pcm_substream *substream,
 +				bool force, cycle_t last)
 +{
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	struct timecounter *tc = &azx_dev->azx_tc;
 +	struct cyclecounter *cc = &azx_dev->azx_cc;
 +	u64 nsec;
 +
 +	cc->read = azx_cc_read;
 +	cc->mask = CLOCKSOURCE_MASK(32);
 +
 +	/*
 +	 * Converting from 24 MHz to ns means applying a 125/3 factor.
 +	 * To avoid any saturation issues in intermediate operations,
 +	 * the 125 factor is applied first. The division is applied
 +	 * last after reading the timecounter value.
 +	 * Applying the 1/3 factor as part of the multiplication
 +	 * requires at least 20 bits for a decent precision, however
 +	 * overflows occur after about 4 hours or less, not a option.
 +	 */
 +
 +	cc->mult = 125; /* saturation after 195 years */
 +	cc->shift = 0;
 +
 +	nsec = 0; /* audio time is elapsed time since trigger */
 +	timecounter_init(tc, cc, nsec);
 +	if (force)
 +		/*
 +		 * force timecounter to use predefined value,
 +		 * used for synchronized starts
 +		 */
 +		tc->cycle_last = last;
 +}
 +
 +static u64 azx_adjust_codec_delay(struct snd_pcm_substream *substream,
 +				u64 nsec)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];
 +	u64 codec_frames, codec_nsecs;
 +
 +	if (!hinfo->ops.get_delay)
 +		return nsec;
 +
 +	codec_frames = hinfo->ops.get_delay(hinfo, apcm->codec, substream);
 +	codec_nsecs = div_u64(codec_frames * 1000000000LL,
 +			      substream->runtime->rate);
 +
 +	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
 +		return nsec + codec_nsecs;
 +
 +	return (nsec > codec_nsecs) ? nsec - codec_nsecs : 0;
 +}
 +
 +static int azx_get_wallclock_tstamp(struct snd_pcm_substream *substream,
 +				struct timespec *ts)
 +{
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	u64 nsec;
 +
 +	nsec = timecounter_read(&azx_dev->azx_tc);
 +	nsec = div_u64(nsec, 3); /* can be optimized */
 +	nsec = azx_adjust_codec_delay(substream, nsec);
 +
 +	*ts = ns_to_timespec(nsec);
 +
 +	return 0;
 +}
 +
 +static struct snd_pcm_hardware azx_pcm_hw = {
 +	.info =			(SNDRV_PCM_INFO_MMAP |
 +				 SNDRV_PCM_INFO_INTERLEAVED |
 +				 SNDRV_PCM_INFO_BLOCK_TRANSFER |
 +				 SNDRV_PCM_INFO_MMAP_VALID |
 +				 /* No full-resume yet implemented */
 +				 /* SNDRV_PCM_INFO_RESUME |*/
 +				 SNDRV_PCM_INFO_PAUSE |
 +				 SNDRV_PCM_INFO_SYNC_START |
 +				 SNDRV_PCM_INFO_HAS_WALL_CLOCK |
 +				 SNDRV_PCM_INFO_NO_PERIOD_WAKEUP),
 +	.formats =		SNDRV_PCM_FMTBIT_S16_LE,
 +	.rates =		SNDRV_PCM_RATE_48000,
 +	.rate_min =		48000,
 +	.rate_max =		48000,
 +	.channels_min =		2,
 +	.channels_max =		2,
 +	.buffer_bytes_max =	AZX_MAX_BUF_SIZE,
 +	.period_bytes_min =	128,
 +	.period_bytes_max =	AZX_MAX_BUF_SIZE / 2,
 +	.periods_min =		2,
 +	.periods_max =		AZX_MAX_FRAG,
 +	.fifo_size =		0,
 +};
 +
 +static int azx_pcm_open(struct snd_pcm_substream *substream)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];
 +	struct azx *chip = apcm->chip;
 +	struct azx_dev *azx_dev;
 +	struct snd_pcm_runtime *runtime = substream->runtime;
 +	unsigned long flags;
 +	int err;
 +	int buff_step;
 +
 +	mutex_lock(&chip->open_mutex);
 +	azx_dev = azx_assign_device(chip, substream);
 +	if (azx_dev == NULL) {
 +		mutex_unlock(&chip->open_mutex);
 +		return -EBUSY;
 +	}
 +	runtime->hw = azx_pcm_hw;
 +	runtime->hw.channels_min = hinfo->channels_min;
 +	runtime->hw.channels_max = hinfo->channels_max;
 +	runtime->hw.formats = hinfo->formats;
 +	runtime->hw.rates = hinfo->rates;
 +	snd_pcm_limit_hw_rates(runtime);
 +	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
 +
 +	/* avoid wrap-around with wall-clock */
 +	snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_TIME,
 +				20,
 +				178000000);
 +
 +	if (chip->align_buffer_size)
 +		/* constrain buffer sizes to be multiple of 128
 +		   bytes. This is more efficient in terms of memory
 +		   access but isn't required by the HDA spec and
 +		   prevents users from specifying exact period/buffer
 +		   sizes. For example for 44.1kHz, a period size set
 +		   to 20ms will be rounded to 19.59ms. */
 +		buff_step = 128;
 +	else
 +		/* Don't enforce steps on buffer sizes, still need to
 +		   be multiple of 4 bytes (HDA spec). Tested on Intel
 +		   HDA controllers, may not work on all devices where
 +		   option needs to be disabled */
 +		buff_step = 4;
 +
 +	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_BUFFER_BYTES,
 +				   buff_step);
 +	snd_pcm_hw_constraint_step(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_BYTES,
 +				   buff_step);
 +	snd_hda_power_up_d3wait(apcm->codec);
 +	err = hinfo->ops.open(hinfo, apcm->codec, substream);
 +	if (err < 0) {
 +		azx_release_device(azx_dev);
 +		snd_hda_power_down(apcm->codec);
 +		mutex_unlock(&chip->open_mutex);
 +		return err;
 +	}
 +	snd_pcm_limit_hw_rates(runtime);
 +	/* sanity check */
 +	if (snd_BUG_ON(!runtime->hw.channels_min) ||
 +	    snd_BUG_ON(!runtime->hw.channels_max) ||
 +	    snd_BUG_ON(!runtime->hw.formats) ||
 +	    snd_BUG_ON(!runtime->hw.rates)) {
 +		azx_release_device(azx_dev);
 +		hinfo->ops.close(hinfo, apcm->codec, substream);
 +		snd_hda_power_down(apcm->codec);
 +		mutex_unlock(&chip->open_mutex);
 +		return -EINVAL;
 +	}
 +
 +	/* disable WALLCLOCK timestamps for capture streams
 +	   until we figure out how to handle digital inputs */
 +	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
 +		runtime->hw.info &= ~SNDRV_PCM_INFO_HAS_WALL_CLOCK;
 +
 +	spin_lock_irqsave(&chip->reg_lock, flags);
 +	azx_dev->substream = substream;
 +	azx_dev->running = 0;
 +	spin_unlock_irqrestore(&chip->reg_lock, flags);
 +
 +	runtime->private_data = azx_dev;
 +	snd_pcm_set_sync(substream);
 +	mutex_unlock(&chip->open_mutex);
 +	return 0;
 +}
 +
 +static int azx_pcm_close(struct snd_pcm_substream *substream)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];
 +	struct azx *chip = apcm->chip;
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	unsigned long flags;
 +
 +	mutex_lock(&chip->open_mutex);
 +	spin_lock_irqsave(&chip->reg_lock, flags);
 +	azx_dev->substream = NULL;
 +	azx_dev->running = 0;
 +	spin_unlock_irqrestore(&chip->reg_lock, flags);
 +	azx_release_device(azx_dev);
 +	hinfo->ops.close(hinfo, apcm->codec, substream);
 +	snd_hda_power_down(apcm->codec);
 +	mutex_unlock(&chip->open_mutex);
 +	return 0;
 +}
 +
 +static int azx_pcm_hw_params(struct snd_pcm_substream *substream,
 +			     struct snd_pcm_hw_params *hw_params)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct azx *chip = apcm->chip;
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	int ret;
 +
 +	dsp_lock(azx_dev);
 +	if (dsp_is_locked(azx_dev)) {
 +		ret = -EBUSY;
 +		goto unlock;
 +	}
 +
 +	mark_runtime_wc(chip, azx_dev, substream, false);
 +	azx_dev->bufsize = 0;
 +	azx_dev->period_bytes = 0;
 +	azx_dev->format_val = 0;
 +	ret = snd_pcm_lib_malloc_pages(substream,
 +					params_buffer_bytes(hw_params));
 +	if (ret < 0)
 +		goto unlock;
 +	mark_runtime_wc(chip, azx_dev, substream, true);
 + unlock:
 +	dsp_unlock(azx_dev);
 +	return ret;
 +}
 +
 +static int azx_pcm_hw_free(struct snd_pcm_substream *substream)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	struct azx *chip = apcm->chip;
 +	struct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];
 +
 +	/* reset BDL address */
 +	dsp_lock(azx_dev);
 +	if (!dsp_is_locked(azx_dev)) {
 +		azx_sd_writel(chip, azx_dev, SD_BDLPL, 0);
 +		azx_sd_writel(chip, azx_dev, SD_BDLPU, 0);
 +		azx_sd_writel(chip, azx_dev, SD_CTL, 0);
 +		azx_dev->bufsize = 0;
 +		azx_dev->period_bytes = 0;
 +		azx_dev->format_val = 0;
 +	}
 +
 +	snd_hda_codec_cleanup(apcm->codec, hinfo, substream);
 +
 +	mark_runtime_wc(chip, azx_dev, substream, false);
 +	azx_dev->prepared = 0;
 +	dsp_unlock(azx_dev);
 +	return snd_pcm_lib_free_pages(substream);
 +}
 +
 +static int azx_pcm_prepare(struct snd_pcm_substream *substream)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct azx *chip = apcm->chip;
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	struct hda_pcm_stream *hinfo = apcm->hinfo[substream->stream];
 +	struct snd_pcm_runtime *runtime = substream->runtime;
 +	unsigned int bufsize, period_bytes, format_val, stream_tag;
 +	int err;
 +	struct hda_spdif_out *spdif =
 +		snd_hda_spdif_out_of_nid(apcm->codec, hinfo->nid);
 +	unsigned short ctls = spdif ? spdif->ctls : 0;
 +
 +	dsp_lock(azx_dev);
 +	if (dsp_is_locked(azx_dev)) {
 +		err = -EBUSY;
 +		goto unlock;
 +	}
 +
 +	azx_stream_reset(chip, azx_dev);
 +	format_val = snd_hda_calc_stream_format(runtime->rate,
 +						runtime->channels,
 +						runtime->format,
 +						hinfo->maxbps,
 +						ctls);
 +	if (!format_val) {
 +		snd_printk(KERN_ERR SFX
 +			   "%s: invalid format_val, rate=%d, ch=%d, format=%d\n",
 +			   pci_name(chip->pci), runtime->rate, runtime->channels, runtime->format);
 +		err = -EINVAL;
 +		goto unlock;
 +	}
 +
 +	bufsize = snd_pcm_lib_buffer_bytes(substream);
 +	period_bytes = snd_pcm_lib_period_bytes(substream);
 +
 +	snd_printdd(SFX "%s: azx_pcm_prepare: bufsize=0x%x, format=0x%x\n",
 +		    pci_name(chip->pci), bufsize, format_val);
 +
 +	if (bufsize != azx_dev->bufsize ||
 +	    period_bytes != azx_dev->period_bytes ||
 +	    format_val != azx_dev->format_val ||
 +	    runtime->no_period_wakeup != azx_dev->no_period_wakeup) {
 +		azx_dev->bufsize = bufsize;
 +		azx_dev->period_bytes = period_bytes;
 +		azx_dev->format_val = format_val;
 +		azx_dev->no_period_wakeup = runtime->no_period_wakeup;
 +		err = azx_setup_periods(chip, substream, azx_dev);
 +		if (err < 0)
 +			goto unlock;
 +	}
 +
 +	/* when LPIB delay correction gives a small negative value,
 +	 * we ignore it; currently set the threshold statically to
 +	 * 64 frames
 +	 */
 +	if (runtime->period_size > 64)
 +		azx_dev->delay_negative_threshold = -frames_to_bytes(runtime, 64);
 +	else
 +		azx_dev->delay_negative_threshold = 0;
 +
 +	/* wallclk has 24Mhz clock source */
 +	azx_dev->period_wallclk = (((runtime->period_size * 24000) /
 +						runtime->rate) * 1000);
 +	azx_setup_controller(chip, azx_dev);
 +	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 +		azx_dev->fifo_size =
 +			azx_sd_readw(chip, azx_dev, SD_FIFOSIZE) + 1;
 +	else
 +		azx_dev->fifo_size = 0;
 +
 +	stream_tag = azx_dev->stream_tag;
 +	/* CA-IBG chips need the playback stream starting from 1 */
 +	if ((chip->driver_caps & AZX_DCAPS_CTX_WORKAROUND) &&
 +	    stream_tag > chip->capture_streams)
 +		stream_tag -= chip->capture_streams;
 +	err = snd_hda_codec_prepare(apcm->codec, hinfo, stream_tag,
 +				     azx_dev->format_val, substream);
 +
 + unlock:
 +	if (!err)
 +		azx_dev->prepared = 1;
 +	dsp_unlock(azx_dev);
 +	return err;
 +}
 +
 +static int azx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct azx *chip = apcm->chip;
 +	struct azx_dev *azx_dev;
 +	struct snd_pcm_substream *s;
 +	int rstart = 0, start, nsync = 0, sbits = 0;
 +	int nwait, timeout;
 +
 +	azx_dev = get_azx_dev(substream);
 +	trace_azx_pcm_trigger(chip, azx_dev, cmd);
 +
 +	if (dsp_is_locked(azx_dev) || !azx_dev->prepared)
 +		return -EPIPE;
 +
 +	switch (cmd) {
 +	case SNDRV_PCM_TRIGGER_START:
 +		rstart = 1;
 +	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
 +	case SNDRV_PCM_TRIGGER_RESUME:
 +		start = 1;
 +		break;
 +	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
 +	case SNDRV_PCM_TRIGGER_SUSPEND:
 +	case SNDRV_PCM_TRIGGER_STOP:
 +		start = 0;
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +
 +	snd_pcm_group_for_each_entry(s, substream) {
 +		if (s->pcm->card != substream->pcm->card)
 +			continue;
 +		azx_dev = get_azx_dev(s);
 +		sbits |= 1 << azx_dev->index;
 +		nsync++;
 +		snd_pcm_trigger_done(s, substream);
 +	}
 +
 +	spin_lock(&chip->reg_lock);
 +
 +	/* first, set SYNC bits of corresponding streams */
 +	if (chip->driver_caps & AZX_DCAPS_OLD_SSYNC)
 +		azx_writel(chip, OLD_SSYNC,
 +			azx_readl(chip, OLD_SSYNC) | sbits);
 +	else
 +		azx_writel(chip, SSYNC, azx_readl(chip, SSYNC) | sbits);
 +
 +	snd_pcm_group_for_each_entry(s, substream) {
 +		if (s->pcm->card != substream->pcm->card)
 +			continue;
 +		azx_dev = get_azx_dev(s);
 +		if (start) {
 +			azx_dev->start_wallclk = azx_readl(chip, WALLCLK);
 +			if (!rstart)
 +				azx_dev->start_wallclk -=
 +						azx_dev->period_wallclk;
 +			azx_stream_start(chip, azx_dev);
 +		} else {
 +			azx_stream_stop(chip, azx_dev);
 +		}
 +		azx_dev->running = start;
 +	}
 +	spin_unlock(&chip->reg_lock);
 +	if (start) {
 +		/* wait until all FIFOs get ready */
 +		for (timeout = 5000; timeout; timeout--) {
 +			nwait = 0;
 +			snd_pcm_group_for_each_entry(s, substream) {
 +				if (s->pcm->card != substream->pcm->card)
 +					continue;
 +				azx_dev = get_azx_dev(s);
 +				if (!(azx_sd_readb(chip, azx_dev, SD_STS) &
 +				      SD_STS_FIFO_READY))
 +					nwait++;
 +			}
 +			if (!nwait)
 +				break;
 +			cpu_relax();
 +		}
 +	} else {
 +		/* wait until all RUN bits are cleared */
 +		for (timeout = 5000; timeout; timeout--) {
 +			nwait = 0;
 +			snd_pcm_group_for_each_entry(s, substream) {
 +				if (s->pcm->card != substream->pcm->card)
 +					continue;
 +				azx_dev = get_azx_dev(s);
 +				if (azx_sd_readb(chip, azx_dev, SD_CTL) &
 +				    SD_CTL_DMA_START)
 +					nwait++;
 +			}
 +			if (!nwait)
 +				break;
 +			cpu_relax();
 +		}
 +	}
 +	spin_lock(&chip->reg_lock);
 +	/* reset SYNC bits */
 +	if (chip->driver_caps & AZX_DCAPS_OLD_SSYNC)
 +		azx_writel(chip, OLD_SSYNC,
 +			azx_readl(chip, OLD_SSYNC) & ~sbits);
 +	else
 +		azx_writel(chip, SSYNC, azx_readl(chip, SSYNC) & ~sbits);
 +	if (start) {
 +		azx_timecounter_init(substream, 0, 0);
 +		if (nsync > 1) {
 +			cycle_t cycle_last;
 +
 +			/* same start cycle for master and group */
 +			azx_dev = get_azx_dev(substream);
 +			cycle_last = azx_dev->azx_tc.cycle_last;
 +
 +			snd_pcm_group_for_each_entry(s, substream) {
 +				if (s->pcm->card != substream->pcm->card)
 +					continue;
 +				azx_timecounter_init(s, 1, cycle_last);
 +			}
 +		}
 +	}
 +	spin_unlock(&chip->reg_lock);
 +	return 0;
 +}
 +
 +/* get the current DMA position with correction on VIA chips */
 +static unsigned int azx_via_get_position(struct azx *chip,
 +					 struct azx_dev *azx_dev)
 +{
 +	unsigned int link_pos, mini_pos, bound_pos;
 +	unsigned int mod_link_pos, mod_dma_pos, mod_mini_pos;
 +	unsigned int fifo_size;
 +
 +	link_pos = azx_sd_readl(chip, azx_dev, SD_LPIB);
 +	if (azx_dev->substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 +		/* Playback, no problem using link position */
 +		return link_pos;
 +	}
 +
 +	/* Capture */
 +	/* For new chipset,
 +	 * use mod to get the DMA position just like old chipset
 +	 */
 +	mod_dma_pos = le32_to_cpu(*azx_dev->posbuf);
 +	mod_dma_pos %= azx_dev->period_bytes;
 +
 +	/* azx_dev->fifo_size can't get FIFO size of in stream.
 +	 * Get from base address + offset.
 +	 */
 +	fifo_size = readw(chip->remap_addr + VIA_IN_STREAM0_FIFO_SIZE_OFFSET);
 +
 +	if (azx_dev->insufficient) {
 +		/* Link position never gather than FIFO size */
 +		if (link_pos <= fifo_size)
 +			return 0;
 +
 +		azx_dev->insufficient = 0;
 +	}
 +
 +	if (link_pos <= fifo_size)
 +		mini_pos = azx_dev->bufsize + link_pos - fifo_size;
 +	else
 +		mini_pos = link_pos - fifo_size;
 +
 +	/* Find nearest previous boudary */
 +	mod_mini_pos = mini_pos % azx_dev->period_bytes;
 +	mod_link_pos = link_pos % azx_dev->period_bytes;
 +	if (mod_link_pos >= fifo_size)
 +		bound_pos = link_pos - mod_link_pos;
 +	else if (mod_dma_pos >= mod_mini_pos)
 +		bound_pos = mini_pos - mod_mini_pos;
 +	else {
 +		bound_pos = mini_pos - mod_mini_pos + azx_dev->period_bytes;
 +		if (bound_pos >= azx_dev->bufsize)
 +			bound_pos = 0;
 +	}
 +
 +	/* Calculate real DMA position we want */
 +	return bound_pos + mod_dma_pos;
 +}
 +
 +static unsigned int azx_get_position(struct azx *chip,
 +				     struct azx_dev *azx_dev,
 +				     bool with_check)
 +{
 +	struct snd_pcm_substream *substream = azx_dev->substream;
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	unsigned int pos;
 +	int stream = substream->stream;
 +	struct hda_pcm_stream *hinfo = apcm->hinfo[stream];
 +	int delay = 0;
 +
 +	switch (chip->position_fix[stream]) {
 +	case POS_FIX_LPIB:
 +		/* read LPIB */
 +		pos = azx_sd_readl(chip, azx_dev, SD_LPIB);
 +		break;
 +	case POS_FIX_VIACOMBO:
 +		pos = azx_via_get_position(chip, azx_dev);
 +		break;
 +	default:
 +		/* use the position buffer */
 +		pos = le32_to_cpu(*azx_dev->posbuf);
 +		if (with_check && chip->position_fix[stream] == POS_FIX_AUTO) {
 +			if (!pos || pos == (u32)-1) {
 +				printk(KERN_WARNING
 +				       "hda-intel: Invalid position buffer, "
 +				       "using LPIB read method instead.\n");
 +				chip->position_fix[stream] = POS_FIX_LPIB;
 +				pos = azx_sd_readl(chip, azx_dev, SD_LPIB);
 +			} else
 +				chip->position_fix[stream] = POS_FIX_POSBUF;
 +		}
 +		break;
 +	}
 +
 +	if (pos >= azx_dev->bufsize)
 +		pos = 0;
 +
 +	/* calculate runtime delay from LPIB */
 +	if (substream->runtime &&
 +	    chip->position_fix[stream] == POS_FIX_POSBUF &&
 +	    (chip->driver_caps & AZX_DCAPS_COUNT_LPIB_DELAY)) {
 +		unsigned int lpib_pos = azx_sd_readl(chip, azx_dev, SD_LPIB);
 +		if (stream == SNDRV_PCM_STREAM_PLAYBACK)
 +			delay = pos - lpib_pos;
 +		else
 +			delay = lpib_pos - pos;
 +		if (delay < 0) {
 +			if (delay >= azx_dev->delay_negative_threshold)
 +				delay = 0;
 +			else
 +				delay += azx_dev->bufsize;
 +		}
 +		if (delay >= azx_dev->period_bytes) {
 +			snd_printk(KERN_WARNING SFX
 +				   "%s: Unstable LPIB (%d >= %d); "
 +				   "disabling LPIB delay counting\n",
 +				   pci_name(chip->pci), delay, azx_dev->period_bytes);
 +			delay = 0;
 +			chip->driver_caps &= ~AZX_DCAPS_COUNT_LPIB_DELAY;
 +		}
 +		delay = bytes_to_frames(substream->runtime, delay);
 +	}
 +
 +	if (substream->runtime) {
 +		if (hinfo->ops.get_delay)
 +			delay += hinfo->ops.get_delay(hinfo, apcm->codec,
 +						      substream);
 +		substream->runtime->delay = delay;
 +	}
 +
 +	trace_azx_get_position(chip, azx_dev, pos, delay);
 +	return pos;
 +}
 +
 +static snd_pcm_uframes_t azx_pcm_pointer(struct snd_pcm_substream *substream)
 +{
 +	struct azx_pcm *apcm = snd_pcm_substream_chip(substream);
 +	struct azx *chip = apcm->chip;
 +	struct azx_dev *azx_dev = get_azx_dev(substream);
 +	return bytes_to_frames(substream->runtime,
 +			       azx_get_position(chip, azx_dev, false));
 +}
 +
 +/*
 + * Check whether the current DMA position is acceptable for updating
 + * periods.  Returns non-zero if it's OK.
 + *
 + * Many HD-audio controllers appear pretty inaccurate about
 + * the update-IRQ timing.  The IRQ is issued before actually the
 + * data is processed.  So, we need to process it afterwords in a
 + * workqueue.
 + */
 +static int azx_position_ok(struct azx *chip, struct azx_dev *azx_dev)
 +{
 +	u32 wallclk;
 +	unsigned int pos;
 +
 +	wallclk = azx_readl(chip, WALLCLK) - azx_dev->start_wallclk;
 +	if (wallclk < (azx_dev->period_wallclk * 2) / 3)
 +		return -1;	/* bogus (too early) interrupt */
 +
 +	pos = azx_get_position(chip, azx_dev, true);
  
  	if (WARN_ONCE(!azx_dev->period_bytes,
  		      "hda-intel: zero azx_dev->period_bytes"))
@@@ -2762,14 -999,11 +2891,19 @@@ static void azx_vs_set_state(struct pci
  	if (!chip->bus) {
  		chip->disabled = disabled;
  		if (!disabled) {
 -			dev_info(chip->card->dev,
 -				 "Start delayed initialization\n");
 +			snd_printk(KERN_INFO SFX
 +				   "%s: Start delayed initialization\n",
 +				   pci_name(chip->pci));
  			if (azx_probe_continue(chip) < 0) {
++<<<<<<< HEAD
 +				snd_printk(KERN_ERR SFX
 +					   "%s: initialization error\n",
 +					   pci_name(chip->pci));
 +				chip->init_failed = true;
++=======
+ 				dev_err(chip->card->dev, "initialization error\n");
+ 				hda->init_failed = true;
++>>>>>>> 9a34af4a3327 (ALSA: hda - Move more PCI-controller-specific stuff from generic code)
  			}
  		}
  	} else {
@@@ -2814,12 -1048,12 +2949,19 @@@ static bool azx_vs_can_switch(struct pc
  
  static void init_vga_switcheroo(struct azx *chip)
  {
+ 	struct hda_intel *hda = container_of(chip, struct hda_intel, chip);
  	struct pci_dev *p = get_bound_vga(chip->pci);
  	if (p) {
++<<<<<<< HEAD
 +		snd_printk(KERN_INFO SFX
 +			   "%s: Handle VGA-switcheroo audio client\n",
 +			   pci_name(chip->pci));
 +		chip->use_vga_switcheroo = 1;
++=======
+ 		dev_info(chip->card->dev,
+ 			 "Handle VGA-switcheroo audio client\n");
+ 		hda->use_vga_switcheroo = 1;
++>>>>>>> 9a34af4a3327 (ALSA: hda - Move more PCI-controller-specific stuff from generic code)
  		pci_dev_put(p);
  	}
  }
@@@ -2862,6 -1097,7 +3005,10 @@@ static int register_vga_switcheroo(stru
  static int azx_free(struct azx *chip)
  {
  	struct pci_dev *pci = chip->pci;
++<<<<<<< HEAD
++=======
+ 	struct hda_intel *hda = container_of(chip, struct hda_intel, chip);
++>>>>>>> 9a34af4a3327 (ALSA: hda - Move more PCI-controller-specific stuff from generic code)
  	int i;
  
  	if ((chip->driver_caps & AZX_DCAPS_PM_RUNTIME)
@@@ -3196,19 -1443,13 +3344,19 @@@ static int azx_create(struct snd_card *
  	check_msi(chip);
  	chip->dev_index = dev;
  	chip->jackpoll_ms = jackpoll_ms;
- 	INIT_WORK(&chip->irq_pending_work, azx_irq_pending_work);
  	INIT_LIST_HEAD(&chip->pcm_list);
- 	INIT_LIST_HEAD(&chip->list);
+ 	INIT_WORK(&hda->irq_pending_work, azx_irq_pending_work);
+ 	INIT_LIST_HEAD(&hda->list);
  	init_vga_switcheroo(chip);
- 	init_completion(&chip->probe_wait);
+ 	init_completion(&hda->probe_wait);
  
 -	assign_position_fix(chip, check_position_fix(chip, position_fix[dev]));
 +	chip->position_fix[0] = chip->position_fix[1] =
 +		check_position_fix(chip, position_fix[dev]);
 +	/* combo mode uses LPIB for playback */
 +	if (chip->position_fix[0] == POS_FIX_COMBO) {
 +		chip->position_fix[0] = POS_FIX_LPIB;
 +		chip->position_fix[1] = POS_FIX_AUTO;
 +	}
  
  	check_probe_mask(chip, dev);
  
* Unmerged path sound/pci/hda/hda_intel.c
diff --git a/sound/pci/hda/hda_priv.h b/sound/pci/hda/hda_priv.h
index 31c45c8ab247..7b7d5baacc3f 100644
--- a/sound/pci/hda/hda_priv.h
+++ b/sound/pci/hda/hda_priv.h
@@ -196,26 +196,6 @@ enum {
 	POS_FIX_COMBO,
 };
 
-/* Defines for ATI HD Audio support in SB450 south bridge */
-#define ATI_SB450_HDAUDIO_MISC_CNTR2_ADDR   0x42
-#define ATI_SB450_HDAUDIO_ENABLE_SNOOP      0x02
-
-/* Defines for Nvidia HDA support */
-#define NVIDIA_HDA_TRANSREG_ADDR      0x4e
-#define NVIDIA_HDA_ENABLE_COHBITS     0x0f
-#define NVIDIA_HDA_ISTRM_COH          0x4d
-#define NVIDIA_HDA_OSTRM_COH          0x4c
-#define NVIDIA_HDA_ENABLE_COHBIT      0x01
-
-/* Defines for Intel SCH HDA snoop control */
-#define INTEL_SCH_HDA_DEVC      0x78
-#define INTEL_SCH_HDA_DEVC_NOSNOOP       (0x1<<11)
-
-/* Define IN stream 0 FIFO size offset in VIA controller */
-#define VIA_IN_STREAM0_FIFO_SIZE_OFFSET	0x90
-/* Define VIA HD Audio Device ID*/
-#define VIA_HDAC_DEVICE_ID		0x3288
-
 /* HD Audio class code */
 #define PCI_CLASS_MULTIMEDIA_HD_AUDIO	0x0403
 
@@ -327,7 +307,6 @@ struct azx {
 	/* locks */
 	spinlock_t reg_lock;
 	struct mutex open_mutex; /* Prevents concurrent open/close operations */
-	struct completion probe_wait;
 
 	/* streams (x num_streams) */
 	struct azx_dev *azx_dev;
@@ -361,38 +340,21 @@ struct azx {
 	unsigned int single_cmd:1;
 	unsigned int polling_mode:1;
 	unsigned int msi:1;
-	unsigned int irq_pending_warned:1;
 	unsigned int probing:1; /* codec probing phase */
 	unsigned int snoop:1;
 	unsigned int align_buffer_size:1;
 	unsigned int region_requested:1;
-
-	/* VGA-switcheroo setup */
-	unsigned int use_vga_switcheroo:1;
-	unsigned int vga_switcheroo_registered:1;
-	unsigned int init_failed:1; /* delayed init failed */
 	unsigned int disabled:1; /* disabled by VGA-switcher */
 
 	/* for debugging */
 	unsigned int last_cmd[AZX_MAX_CODECS];
 
-	/* for pending irqs */
-	struct work_struct irq_pending_work;
-
-	struct work_struct probe_work;
-
 	/* reboot notifier (for mysterious hangup problem at power-down) */
 	struct notifier_block reboot_notifier;
 
-	/* card list (for power_save trigger) */
-	struct list_head list;
-
 #ifdef CONFIG_SND_HDA_DSP_LOADER
 	struct azx_dev saved_azx_dev;
 #endif
-
-	/* secondary power domain for hdmi audio under vga device */
-	struct dev_pm_domain hdmi_pm_domain;
 };
 
 #ifdef CONFIG_SND_VERBOSE_PRINTK
