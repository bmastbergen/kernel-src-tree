blk-mq: split make request handler for multi and single queue

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Jens Axboe <axboe@fb.com>
commit 07068d5b8ed8fa6759b2826ba9197e49b69a1fc3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/07068d5b.failed

We want slightly different behavior from them:

- On single queue devices, we currently use the per-process plug
  for deferred IO and for merging.

- On multi queue devices, we don't use the per-process plug, but
  we want to go straight to hardware for SYNC IO.

Split blk_mq_make_request() into a blk_sq_make_request() for single
queue devices, and retain blk_mq_make_request() for multi queue
devices. Then we don't need multiple checks for q->nr_hw_queues
in the request mapping.

	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 07068d5b8ed8fa6759b2826ba9197e49b69a1fc3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index a6fc109357ae,54e78863c083..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -887,10 -1120,11 +900,11 @@@ static struct request *blk_mq_map_reque
  	ctx = blk_mq_get_ctx(q);
  	hctx = q->mq_ops->map_queue(q, ctx->cpu);
  
- 	if (is_sync)
+ 	if (rw_is_sync(bio->bi_rw))
  		rw |= REQ_SYNC;
+ 
  	trace_block_getrq(q, bio, rw);
 -	rq = __blk_mq_alloc_request(hctx, ctx, GFP_ATOMIC, false);
 +	rq = __blk_mq_alloc_request(hctx, GFP_ATOMIC, false);
  	if (likely(rq))
  		blk_mq_rq_ctx_init(q, ctx, rq, rw);
  	else {
@@@ -1358,19 -1773,29 +1461,30 @@@ struct request_queue *blk_mq_init_queue
  
  	q->sg_reserved_size = INT_MAX;
  
++<<<<<<< HEAD
 +	blk_queue_make_request(q, blk_mq_make_request);
 +	blk_queue_rq_timed_out(q, reg->ops->timeout);
 +	if (reg->timeout)
 +		blk_queue_rq_timeout(q, reg->timeout);
++=======
+ 	if (q->nr_hw_queues > 1)
+ 		blk_queue_make_request(q, blk_mq_make_request);
+ 	else
+ 		blk_queue_make_request(q, blk_sq_make_request);
+ 
+ 	blk_queue_rq_timed_out(q, blk_mq_rq_timed_out);
+ 	if (set->timeout)
+ 		blk_queue_rq_timeout(q, set->timeout);
++>>>>>>> 07068d5b8ed8 (blk-mq: split make request handler for multi and single queue)
  
 -	/*
 -	 * Do this after blk_queue_make_request() overrides it...
 -	 */
 -	q->nr_requests = set->queue_depth;
 -
 -	if (set->ops->complete)
 -		blk_queue_softirq_done(q, set->ops->complete);
 +	if (reg->ops->complete)
 +		blk_queue_softirq_done(q, reg->ops->complete);
  
  	blk_mq_init_flush(q);
 -	blk_mq_init_cpu_queues(q, set->nr_hw_queues);
 +	blk_mq_init_cpu_queues(q, reg->nr_hw_queues);
  
 -	q->flush_rq = kzalloc(round_up(sizeof(struct request) +
 -				set->cmd_size, cache_line_size()),
 -				GFP_KERNEL);
 +	q->flush_rq = kzalloc(round_up(sizeof(struct request) + reg->cmd_size,
 +				cache_line_size()), GFP_KERNEL);
  	if (!q->flush_rq)
  		goto err_hw;
  
* Unmerged path block/blk-mq.c
