cpufreq: use cpufreq_cpu_get() to avoid cpufreq_get() race conditions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] use cpufreq_cpu_get() to avoid cpufreq_get() race conditions (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 93.02%
commit-author Aaron Plattner <aplattner@nvidia.com>
commit 999976e0f6233322a878b0b7148c810544d6c8a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/999976e0.failed

If a module calls cpufreq_get while cpufreq is initializing, it's
possible for it to be called after cpufreq_driver is set but before
cpufreq_cpu_data is written during subsys_interface_register.  This
happens because cpufreq_get doesn't take the cpufreq_driver_lock
around its use of cpufreq_cpu_data.

Fix this by using cpufreq_cpu_get(cpu) to look up the policy rather
than reading it out of cpufreq_cpu_data directly.  cpufreq_cpu_get()
takes the appropriate locks to prevent this race from happening.

Since it's possible for policy to be NULL if the caller passes in an
invalid CPU number or calls the function before cpufreq is initialized,
delete the BUG_ON(!policy) and simply return 0.  Don't try to return
-ENOENT because that's negative and the function returns an unsigned
integer.

References: https://bbs.archlinux.org/viewtopic.php?id=177934
	Signed-off-by: Aaron Plattner <aplattner@nvidia.com>
	Cc: 3.13+ <stable@vger.kernel.org> # 3.13+
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 999976e0f6233322a878b0b7148c810544d6c8a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index c8bc717e8458,c4cacabbbb55..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -1380,23 -1546,16 +1380,34 @@@ static unsigned int __cpufreq_get(unsig
   */
  unsigned int cpufreq_get(unsigned int cpu)
  {
++<<<<<<< HEAD
++=======
+ 	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
++>>>>>>> 999976e0f623 (cpufreq: use cpufreq_cpu_get() to avoid cpufreq_get() race conditions)
  	unsigned int ret_freq = 0;
  
- 	if (cpufreq_disabled() || !cpufreq_driver)
- 		return -ENOENT;
+ 	if (policy) {
+ 		down_read(&policy->rwsem);
+ 		ret_freq = __cpufreq_get(cpu);
+ 		up_read(&policy->rwsem);
  
++<<<<<<< HEAD
 +	if (!down_read_trylock(&cpufreq_rwsem))
 +		return 0;
 +
 +	if (unlikely(lock_policy_rwsem_read(cpu)))
 +		goto out_policy;
 +
 +	ret_freq = __cpufreq_get(cpu);
 +
 +	unlock_policy_rwsem_read(cpu);
 +
 +out_policy:
 +	up_read(&cpufreq_rwsem);
++=======
+ 		cpufreq_cpu_put(policy);
+ 	}
++>>>>>>> 999976e0f623 (cpufreq: use cpufreq_cpu_get() to avoid cpufreq_get() race conditions)
  
  	return ret_freq;
  }
* Unmerged path drivers/cpufreq/cpufreq.c
