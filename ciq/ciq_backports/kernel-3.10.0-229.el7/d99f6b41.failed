usb: rename usb_port device objects

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [usb] rename usb_port device objects (Don Zickus) [1110939]
Rebuild_FUZZ: 92.31%
commit-author Dan Williams <dan.j.williams@intel.com>
commit d99f6b41308779244662109a9c2bad09a82e8ac6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d99f6b41.failed

The current port name "portX" is ambiguous.  Before adding more port
messages rename ports to "<hub-device-name>-portX"

This is an ABI change, but the suspicion is that it will go unnoticed as
the port power control implementation has been broken since its
introduction.  If however, someone was relying on the old name we can
add sysfs links from the old name to the new name.

Additionally, it unifies/simplifies port dev_printk messages and modifies
instances of:
	dev_XXX(hub->intfdev, ..."port %d"...
	dev_XXX(&hdev->dev, ..."port%d"...
into:
	dev_XXX(&port_dev->dev, ...

Now that the names are unique usb_port devices it would be nice if they
could be included in /sys/bus/usb.  However, it turns out that this
breaks 'lsusb -t'.  For now, create a dummy port driver so that print
messages are prefixed "usb 1-1-port3" rather than the
subsystem-ambiguous " 1-1-port3".

Finally, it corrects an odd usage of sscanf("port%d") in usb-acpi.c.

	Suggested-by: Alan Stern <stern@rowland.harvard.edu>
	Acked-by: Alan Stern <stern@rowland.harvard.edu>
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit d99f6b41308779244662109a9c2bad09a82e8ac6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/core/hub.c
#	drivers/usb/core/usb-acpi.c
diff --cc drivers/usb/core/hub.c
index fecd71f106f9,653f80c52486..000000000000
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@@ -408,26 -432,15 +424,30 @@@ static char *to_led_name(int selector
   * USB 2.0 spec Section 11.24.2.7.1.10 and table 11-7
   * for info about using port indicators
   */
- static void set_port_led(
- 	struct usb_hub *hub,
- 	int port1,
- 	int selector
- )
+ static void set_port_led(struct usb_hub *hub, int port1, int selector)
  {
- 	int status = set_port_feature(hub->hdev, (selector << 8) | port1,
+ 	struct usb_port *port_dev = hub->ports[port1 - 1];
+ 	int status;
+ 
+ 	status = set_port_feature(hub->hdev, (selector << 8) | port1,
  			USB_PORT_FEAT_INDICATOR);
++<<<<<<< HEAD
 +	if (status < 0)
 +		dev_dbg (hub->intfdev,
 +			"port %d indicator %s status %d\n",
 +			port1,
 +			({ char *s; switch (selector) {
 +			case HUB_LED_AMBER: s = "amber"; break;
 +			case HUB_LED_GREEN: s = "green"; break;
 +			case HUB_LED_OFF: s = "off"; break;
 +			case HUB_LED_AUTO: s = "auto"; break;
 +			default: s = "??"; break;
 +			}; s; }),
 +			status);
++=======
+ 	dev_dbg(&port_dev->dev, "indicator %s status %d\n",
+ 		to_led_name(selector), status);
++>>>>>>> d99f6b413087 (usb: rename usb_port device objects)
  }
  
  #define	LED_CYCLE_PERIOD	((2*HZ)/3)
@@@ -3257,8 -3239,6 +3277,11 @@@ int usb_port_resume(struct usb_device *
  	if (status == 0 && !port_is_suspended(hub, portstatus))
  		goto SuspendCleared;
  
++<<<<<<< HEAD
 +	// dev_dbg(hub->intfdev, "resume port %d\n", port1);
 +
++=======
++>>>>>>> d99f6b413087 (usb: rename usb_port device objects)
  	set_bit(port1, hub->busy_bits);
  
  	/* see 7.1.7.7; affects power usage, but not budgeting */
@@@ -4660,10 -4640,10 +4680,10 @@@ loop
  			!hcd->driver->port_handed_over ||
  			!(hcd->driver->port_handed_over)(hcd, port1)) {
  		if (status != -ENOTCONN && status != -ENODEV)
- 			dev_err(hub_dev, "unable to enumerate USB device on port %d\n",
- 					port1);
+ 			dev_err(&port_dev->dev,
+ 					"unable to enumerate USB device\n");
  	}
 -
 + 
  done:
  	hub_port_disable(hub, port1, 1);
  	if (hcd->driver->relinquish_port && !hub->hdev->parent)
@@@ -4830,16 -4810,12 +4850,12 @@@ static void hub_events(void
  				 * EM interference sometimes causes badly
  				 * shielded USB devices to be shutdown by
  				 * the hub, this hack enables them again.
 -				 * Works at least with mouse driver.
 +				 * Works at least with mouse driver. 
  				 */
  				if (!(portstatus & USB_PORT_STAT_ENABLE)
- 				    && !connect_change
- 				    && hub->ports[i - 1]->child) {
- 					dev_err (hub_dev,
- 					    "port %i "
- 					    "disabled by hub (EMI?), "
- 					    "re-enabling...\n",
- 						i);
+ 				    && !connect_change && udev) {
+ 					dev_err(&port_dev->dev,
+ 							"disabled by hub (EMI?), re-enabling...\n");
  					connect_change = 1;
  				}
  			}
diff --cc drivers/usb/core/usb-acpi.c
index ca63c1ef7144,f91ef0220066..000000000000
--- a/drivers/usb/core/usb-acpi.c
+++ b/drivers/usb/core/usb-acpi.c
@@@ -16,9 -16,8 +16,9 @@@
  #include <linux/acpi.h>
  #include <linux/pci.h>
  #include <linux/usb/hcd.h>
 +#include <acpi/acpi_bus.h>
  
- #include "usb.h"
+ #include "hub.h"
  
  /**
   * usb_acpi_power_manageable - check whether usb port has
@@@ -127,11 -134,11 +135,11 @@@ out
  	return ret;
  }
  
 -static struct acpi_device *usb_acpi_find_companion(struct device *dev)
 +static int usb_acpi_find_device(struct device *dev, acpi_handle *handle)
  {
+ 	int port1;
  	struct usb_device *udev;
  	acpi_handle *parent_handle;
- 	int port_num;
  
  	/*
  	 * In the ACPI DSDT table, only usb root hub and usb ports are
@@@ -173,15 -180,15 +181,25 @@@
  		}
  
  		/* root hub's parent is the usb hcd. */
++<<<<<<< HEAD
 +		parent_handle = DEVICE_ACPI_HANDLE(dev->parent);
 +		*handle = acpi_get_child(parent_handle, udev->portnum);
 +		if (!*handle)
 +			return -ENODEV;
 +		return 0;
 +	} else if (is_usb_port(dev)) {
 +		sscanf(dev_name(dev), "port%d", &port_num);
++=======
+ 		return acpi_find_child_device(ACPI_COMPANION(dev->parent),
+ 				port1, false);
+ 	} else if (is_usb_port(dev)) {
+ 		struct usb_port *port_dev = to_usb_port(dev);
+ 		struct acpi_device *adev = NULL;
+ 
++>>>>>>> d99f6b413087 (usb: rename usb_port device objects)
  		/* Get the struct usb_device point of port's hub */
  		udev = to_usb_device(dev->parent->parent);
+ 		port1 = port_dev->portnum;
  
  		/*
  		 * The root hub ports' parent is the root hub. The non-root-hub
@@@ -190,30 -197,30 +208,49 @@@
  		 */
  		if (!udev->parent) {
  			struct usb_hcd *hcd = bus_to_hcd(udev->bus);
- 			int raw_port_num;
+ 			int raw;
  
++<<<<<<< HEAD
 +			raw_port_num = usb_hcd_find_raw_port_number(hcd,
 +				port_num);
 +			*handle = acpi_get_child(DEVICE_ACPI_HANDLE(&udev->dev),
 +				raw_port_num);
 +			if (!*handle)
 +				return -ENODEV;
++=======
+ 			raw = usb_hcd_find_raw_port_number(hcd, port1);
+ 			adev = acpi_find_child_device(ACPI_COMPANION(&udev->dev),
+ 					raw, false);
+ 			if (!adev)
+ 				return NULL;
++>>>>>>> d99f6b413087 (usb: rename usb_port device objects)
  		} else {
  			parent_handle =
  				usb_get_hub_port_acpi_handle(udev->parent,
  				udev->portnum);
  			if (!parent_handle)
 -				return NULL;
 +				return -ENODEV;
  
++<<<<<<< HEAD
 +			*handle = acpi_get_child(parent_handle,	port_num);
 +			if (!*handle)
 +				return -ENODEV;
 +		}
 +		usb_acpi_check_port_connect_type(udev, *handle, port_num);
 +	} else
 +		return -ENODEV;
++=======
+ 			acpi_bus_get_device(parent_handle, &adev);
+ 			adev = acpi_find_child_device(adev, port1, false);
+ 			if (!adev)
+ 				return NULL;
+ 		}
+ 		usb_acpi_check_port_connect_type(udev, adev->handle, port1);
+ 		return adev;
+ 	}
++>>>>>>> d99f6b413087 (usb: rename usb_port device objects)
  
 -	return NULL;
 +	return 0;
  }
  
  static bool usb_acpi_bus_match(struct device *dev)
* Unmerged path drivers/usb/core/hub.c
diff --git a/drivers/usb/core/port.c b/drivers/usb/core/port.c
index 168fa6ee3348..6a8999728cbf 100644
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@ -152,6 +152,11 @@ struct device_type usb_port_device_type = {
 	.pm =		&usb_port_pm_ops,
 };
 
+static struct device_driver usb_port_driver = {
+	.name = "usb",
+	.owner = THIS_MODULE,
+};
+
 int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 {
 	struct usb_port *port_dev = NULL;
@@ -169,8 +174,9 @@ int usb_hub_create_port_device(struct usb_hub *hub, int port1)
 	port_dev->dev.parent = hub->intfdev;
 	port_dev->dev.groups = port_dev_group;
 	port_dev->dev.type = &usb_port_device_type;
-	dev_set_name(&port_dev->dev, "port%d", port1);
-
+	port_dev->dev.driver = &usb_port_driver;
+	dev_set_name(&port_dev->dev, "%s-port%d", dev_name(&hub->hdev->dev),
+			port1);
 	retval = device_register(&port_dev->dev);
 	if (retval)
 		goto error_register;
* Unmerged path drivers/usb/core/usb-acpi.c
diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h
index 0923add72b59..981d3404fa55 100644
--- a/drivers/usb/core/usb.h
+++ b/drivers/usb/core/usb.h
@@ -179,10 +179,6 @@ extern void usb_notify_add_device(struct usb_device *udev);
 extern void usb_notify_remove_device(struct usb_device *udev);
 extern void usb_notify_add_bus(struct usb_bus *ubus);
 extern void usb_notify_remove_bus(struct usb_bus *ubus);
-extern enum usb_port_connect_type
-	usb_get_hub_port_connect_type(struct usb_device *hdev, int port1);
-extern void usb_set_hub_port_connect_type(struct usb_device *hdev, int port1,
-	enum usb_port_connect_type type);
 extern void usb_hub_adjust_deviceremovable(struct usb_device *hdev,
 		struct usb_hub_descriptor *desc);
 
