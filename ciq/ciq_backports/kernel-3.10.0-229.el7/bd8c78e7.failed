nl80211: clear skb cb before passing to netlink

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Johannes Berg <johannes.berg@intel.com>
commit bd8c78e78d5011d8111bc2533ee73b13a3bd6c42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/bd8c78e7.failed

In testmode and vendor command reply/event SKBs we use the
skb cb data to store nl80211 parameters between allocation
and sending. This causes the code for CONFIG_NETLINK_MMAP
to get confused, because it takes ownership of the skb cb
data when the SKB is handed off to netlink, and it doesn't
explicitly clear it.

Clear the skb cb explicitly when we're done and before it
gets passed to netlink to avoid this issue.

	Cc: stable@vger.kernel.org [this goes way back]
	Reported-by: Assaf Azulay <assaf.azulay@intel.com>
	Reported-by: David Spinadel <david.spinadel@intel.com>
	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
(cherry picked from commit bd8c78e78d5011d8111bc2533ee73b13a3bd6c42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/wireless/nl80211.c
diff --cc net/wireless/nl80211.c
index ac2cb32ea023,7257164af91b..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -6393,12 -6884,106 +6393,113 @@@ static int nl80211_set_mcast_rate(struc
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static struct sk_buff *
+ __cfg80211_alloc_vendor_skb(struct cfg80211_registered_device *rdev,
+ 			    int approxlen, u32 portid, u32 seq,
+ 			    enum nl80211_commands cmd,
+ 			    enum nl80211_attrs attr,
+ 			    const struct nl80211_vendor_cmd_info *info,
+ 			    gfp_t gfp)
+ {
+ 	struct sk_buff *skb;
+ 	void *hdr;
+ 	struct nlattr *data;
+ 
+ 	skb = nlmsg_new(approxlen + 100, gfp);
+ 	if (!skb)
+ 		return NULL;
+ 
+ 	hdr = nl80211hdr_put(skb, portid, seq, 0, cmd);
+ 	if (!hdr) {
+ 		kfree_skb(skb);
+ 		return NULL;
+ 	}
+ 
+ 	if (nla_put_u32(skb, NL80211_ATTR_WIPHY, rdev->wiphy_idx))
+ 		goto nla_put_failure;
+ 
+ 	if (info) {
+ 		if (nla_put_u32(skb, NL80211_ATTR_VENDOR_ID,
+ 				info->vendor_id))
+ 			goto nla_put_failure;
+ 		if (nla_put_u32(skb, NL80211_ATTR_VENDOR_SUBCMD,
+ 				info->subcmd))
+ 			goto nla_put_failure;
+ 	}
+ 
+ 	data = nla_nest_start(skb, attr);
+ 
+ 	((void **)skb->cb)[0] = rdev;
+ 	((void **)skb->cb)[1] = hdr;
+ 	((void **)skb->cb)[2] = data;
+ 
+ 	return skb;
+ 
+  nla_put_failure:
+ 	kfree_skb(skb);
+ 	return NULL;
+ }
+ 
+ struct sk_buff *__cfg80211_alloc_event_skb(struct wiphy *wiphy,
+ 					   enum nl80211_commands cmd,
+ 					   enum nl80211_attrs attr,
+ 					   int vendor_event_idx,
+ 					   int approxlen, gfp_t gfp)
+ {
+ 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+ 	const struct nl80211_vendor_cmd_info *info;
+ 
+ 	switch (cmd) {
+ 	case NL80211_CMD_TESTMODE:
+ 		if (WARN_ON(vendor_event_idx != -1))
+ 			return NULL;
+ 		info = NULL;
+ 		break;
+ 	case NL80211_CMD_VENDOR:
+ 		if (WARN_ON(vendor_event_idx < 0 ||
+ 			    vendor_event_idx >= wiphy->n_vendor_events))
+ 			return NULL;
+ 		info = &wiphy->vendor_events[vendor_event_idx];
+ 		break;
+ 	default:
+ 		WARN_ON(1);
+ 		return NULL;
+ 	}
+ 
+ 	return __cfg80211_alloc_vendor_skb(rdev, approxlen, 0, 0,
+ 					   cmd, attr, info, gfp);
+ }
+ EXPORT_SYMBOL(__cfg80211_alloc_event_skb);
+ 
+ void __cfg80211_send_event_skb(struct sk_buff *skb, gfp_t gfp)
+ {
+ 	struct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];
+ 	void *hdr = ((void **)skb->cb)[1];
+ 	struct nlattr *data = ((void **)skb->cb)[2];
+ 	enum nl80211_multicast_groups mcgrp = NL80211_MCGRP_TESTMODE;
+ 
+ 	/* clear CB data for netlink core to own from now on */
+ 	memset(skb->cb, 0, sizeof(skb->cb));
+ 
+ 	nla_nest_end(skb, data);
+ 	genlmsg_end(skb, hdr);
+ 
+ 	if (data->nla_type == NL80211_ATTR_VENDOR_DATA)
+ 		mcgrp = NL80211_MCGRP_VENDOR;
+ 
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), skb, 0,
+ 				mcgrp, gfp);
+ }
+ EXPORT_SYMBOL(__cfg80211_send_event_skb);
++>>>>>>> bd8c78e78d50 (nl80211: clear skb cb before passing to netlink)
  
  #ifdef CONFIG_NL80211_TESTMODE
 +static struct genl_multicast_group nl80211_testmode_mcgrp = {
 +	.name = "testmode",
 +};
 +
  static int nl80211_testmode_do(struct sk_buff *skb, struct genl_info *info)
  {
  	struct cfg80211_registered_device *rdev = info->user_ptr[0];
@@@ -8291,6 -9204,165 +8392,168 @@@ static int nl80211_crit_protocol_stop(s
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int nl80211_vendor_cmd(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ 	struct wireless_dev *wdev =
+ 		__cfg80211_wdev_from_attrs(genl_info_net(info), info->attrs);
+ 	int i, err;
+ 	u32 vid, subcmd;
+ 
+ 	if (!rdev->wiphy.vendor_commands)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (IS_ERR(wdev)) {
+ 		err = PTR_ERR(wdev);
+ 		if (err != -EINVAL)
+ 			return err;
+ 		wdev = NULL;
+ 	} else if (wdev->wiphy != &rdev->wiphy) {
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!info->attrs[NL80211_ATTR_VENDOR_ID] ||
+ 	    !info->attrs[NL80211_ATTR_VENDOR_SUBCMD])
+ 		return -EINVAL;
+ 
+ 	vid = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_ID]);
+ 	subcmd = nla_get_u32(info->attrs[NL80211_ATTR_VENDOR_SUBCMD]);
+ 	for (i = 0; i < rdev->wiphy.n_vendor_commands; i++) {
+ 		const struct wiphy_vendor_command *vcmd;
+ 		void *data = NULL;
+ 		int len = 0;
+ 
+ 		vcmd = &rdev->wiphy.vendor_commands[i];
+ 
+ 		if (vcmd->info.vendor_id != vid || vcmd->info.subcmd != subcmd)
+ 			continue;
+ 
+ 		if (vcmd->flags & (WIPHY_VENDOR_CMD_NEED_WDEV |
+ 				   WIPHY_VENDOR_CMD_NEED_NETDEV)) {
+ 			if (!wdev)
+ 				return -EINVAL;
+ 			if (vcmd->flags & WIPHY_VENDOR_CMD_NEED_NETDEV &&
+ 			    !wdev->netdev)
+ 				return -EINVAL;
+ 
+ 			if (vcmd->flags & WIPHY_VENDOR_CMD_NEED_RUNNING) {
+ 				if (wdev->netdev &&
+ 				    !netif_running(wdev->netdev))
+ 					return -ENETDOWN;
+ 				if (!wdev->netdev && !wdev->p2p_started)
+ 					return -ENETDOWN;
+ 			}
+ 		} else {
+ 			wdev = NULL;
+ 		}
+ 
+ 		if (info->attrs[NL80211_ATTR_VENDOR_DATA]) {
+ 			data = nla_data(info->attrs[NL80211_ATTR_VENDOR_DATA]);
+ 			len = nla_len(info->attrs[NL80211_ATTR_VENDOR_DATA]);
+ 		}
+ 
+ 		rdev->cur_cmd_info = info;
+ 		err = rdev->wiphy.vendor_commands[i].doit(&rdev->wiphy, wdev,
+ 							  data, len);
+ 		rdev->cur_cmd_info = NULL;
+ 		return err;
+ 	}
+ 
+ 	return -EOPNOTSUPP;
+ }
+ 
+ struct sk_buff *__cfg80211_alloc_reply_skb(struct wiphy *wiphy,
+ 					   enum nl80211_commands cmd,
+ 					   enum nl80211_attrs attr,
+ 					   int approxlen)
+ {
+ 	struct cfg80211_registered_device *rdev = wiphy_to_rdev(wiphy);
+ 
+ 	if (WARN_ON(!rdev->cur_cmd_info))
+ 		return NULL;
+ 
+ 	return __cfg80211_alloc_vendor_skb(rdev, approxlen,
+ 					   rdev->cur_cmd_info->snd_portid,
+ 					   rdev->cur_cmd_info->snd_seq,
+ 					   cmd, attr, NULL, GFP_KERNEL);
+ }
+ EXPORT_SYMBOL(__cfg80211_alloc_reply_skb);
+ 
+ int cfg80211_vendor_cmd_reply(struct sk_buff *skb)
+ {
+ 	struct cfg80211_registered_device *rdev = ((void **)skb->cb)[0];
+ 	void *hdr = ((void **)skb->cb)[1];
+ 	struct nlattr *data = ((void **)skb->cb)[2];
+ 
+ 	/* clear CB data for netlink core to own from now on */
+ 	memset(skb->cb, 0, sizeof(skb->cb));
+ 
+ 	if (WARN_ON(!rdev->cur_cmd_info)) {
+ 		kfree_skb(skb);
+ 		return -EINVAL;
+ 	}
+ 
+ 	nla_nest_end(skb, data);
+ 	genlmsg_end(skb, hdr);
+ 	return genlmsg_reply(skb, rdev->cur_cmd_info);
+ }
+ EXPORT_SYMBOL_GPL(cfg80211_vendor_cmd_reply);
+ 
+ 
+ static int nl80211_set_qos_map(struct sk_buff *skb,
+ 			       struct genl_info *info)
+ {
+ 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+ 	struct cfg80211_qos_map *qos_map = NULL;
+ 	struct net_device *dev = info->user_ptr[1];
+ 	u8 *pos, len, num_des, des_len, des;
+ 	int ret;
+ 
+ 	if (!rdev->ops->set_qos_map)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (info->attrs[NL80211_ATTR_QOS_MAP]) {
+ 		pos = nla_data(info->attrs[NL80211_ATTR_QOS_MAP]);
+ 		len = nla_len(info->attrs[NL80211_ATTR_QOS_MAP]);
+ 
+ 		if (len % 2 || len < IEEE80211_QOS_MAP_LEN_MIN ||
+ 		    len > IEEE80211_QOS_MAP_LEN_MAX)
+ 			return -EINVAL;
+ 
+ 		qos_map = kzalloc(sizeof(struct cfg80211_qos_map), GFP_KERNEL);
+ 		if (!qos_map)
+ 			return -ENOMEM;
+ 
+ 		num_des = (len - IEEE80211_QOS_MAP_LEN_MIN) >> 1;
+ 		if (num_des) {
+ 			des_len = num_des *
+ 				sizeof(struct cfg80211_dscp_exception);
+ 			memcpy(qos_map->dscp_exception, pos, des_len);
+ 			qos_map->num_des = num_des;
+ 			for (des = 0; des < num_des; des++) {
+ 				if (qos_map->dscp_exception[des].up > 7) {
+ 					kfree(qos_map);
+ 					return -EINVAL;
+ 				}
+ 			}
+ 			pos += des_len;
+ 		}
+ 		memcpy(qos_map->up, pos, IEEE80211_QOS_MAP_LEN_MIN);
+ 	}
+ 
+ 	wdev_lock(dev->ieee80211_ptr);
+ 	ret = nl80211_key_allowed(dev->ieee80211_ptr);
+ 	if (!ret)
+ 		ret = rdev_set_qos_map(rdev, dev, qos_map);
+ 	wdev_unlock(dev->ieee80211_ptr);
+ 
+ 	kfree(qos_map);
+ 	return ret;
+ }
+ 
++>>>>>>> bd8c78e78d50 (nl80211: clear skb cb before passing to netlink)
  #define NL80211_FLAG_NEED_WIPHY		0x01
  #define NL80211_FLAG_NEED_NETDEV	0x02
  #define NL80211_FLAG_NEED_RTNL		0x04
* Unmerged path net/wireless/nl80211.c
