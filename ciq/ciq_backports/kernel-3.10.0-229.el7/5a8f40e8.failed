iommu/vt-d: Always store iommu in device_domain_info

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Always store iommu in device_domain_info (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 93.88%
commit-author David Woodhouse <David.Woodhouse@intel.com>
commit 5a8f40e8c8801a9805bbe60d140ed2b0b3b91d18
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5a8f40e8.failed

	Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
(cherry picked from commit 5a8f40e8c8801a9805bbe60d140ed2b0b3b91d18)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 2d7348365b6d,8303f256fe84..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -1158,17 -1263,17 +1158,15 @@@ static struct device_domain_info *iommu
  		}
  	spin_unlock_irqrestore(&device_domain_lock, flags);
  
 -	if (!found || !info->dev || !dev_is_pci(info->dev))
 +	if (!found || !info->dev)
  		return NULL;
  
 -	pdev = to_pci_dev(info->dev);
 -
 -	if (!pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_ATS))
 +	if (!pci_find_ext_capability(info->dev, PCI_EXT_CAP_ID_ATS))
  		return NULL;
  
 -	if (!dmar_find_matched_atsr_unit(pdev))
 +	if (!dmar_find_matched_atsr_unit(info->dev))
  		return NULL;
  
- 	info->iommu = iommu;
- 
  	return info;
  }
  
@@@ -2036,10 -2145,12 +2034,19 @@@ dmar_search_domain_by_dev_info(int segm
  	return NULL;
  }
  
++<<<<<<< HEAD
 +static int dmar_insert_dev_info(int segment, int bus, int devfn,
 +				struct pci_dev *dev, struct dmar_domain **domp)
 +{
 +	struct dmar_domain *found, *domain = *domp;
++=======
+ static struct dmar_domain *dmar_insert_dev_info(struct intel_iommu *iommu,
+ 						int segment, int bus, int devfn,
+ 						struct device *dev,
+ 						struct dmar_domain *domain)
+ {
+ 	struct dmar_domain *found = NULL;
++>>>>>>> 5a8f40e8c880 (iommu/vt-d: Always store iommu in device_domain_info)
  	struct device_domain_info *info;
  	unsigned long flags;
  
@@@ -2057,9 -2169,13 +2065,19 @@@
  
  	spin_lock_irqsave(&device_domain_lock, flags);
  	if (dev)
++<<<<<<< HEAD
 +		found = find_domain(&dev->dev);
 +	else
 +		found = dmar_search_domain_by_dev_info(segment, bus, devfn);
++=======
+ 		found = find_domain(dev);
+ 	else {
+ 		struct device_domain_info *info2;
+ 		info2 = dmar_search_domain_by_dev_info(segment, bus, devfn);
+ 		if (info2)
+ 			found = info2->domain;
+ 	}
++>>>>>>> 5a8f40e8c880 (iommu/vt-d: Always store iommu in device_domain_info)
  	if (found) {
  		spin_unlock_irqrestore(&device_domain_lock, flags);
  		free_devinfo_mem(info);
@@@ -2134,21 -2252,20 +2156,32 @@@ static struct dmar_domain *get_domain_f
  
  	/* register pcie-to-pci device */
  	if (dev_tmp) {
++<<<<<<< HEAD
 +		if (dmar_insert_dev_info(segment, bus, devfn, NULL, &domain))
++=======
+ 		domain = dmar_insert_dev_info(iommu, segment, bus, devfn, NULL,
+ 					      domain);
+ 		if (!domain)
++>>>>>>> 5a8f40e8c880 (iommu/vt-d: Always store iommu in device_domain_info)
  			goto error;
 +		else
 +			free = NULL;
  	}
  
  found_domain:
++<<<<<<< HEAD
 +	if (dmar_insert_dev_info(segment, pdev->bus->number, pdev->devfn,
 +				 pdev, &domain) == 0)
 +		return domain;
++=======
+ 	domain = dmar_insert_dev_info(iommu, segment, pdev->bus->number,
+ 				      pdev->devfn, &pdev->dev, domain);
++>>>>>>> 5a8f40e8c880 (iommu/vt-d: Always store iommu in device_domain_info)
  error:
 -	if (free != domain)
 +	if (free)
  		domain_exit(free);
 -
 -	return domain;
 +	/* recheck it here, maybe others set it */
 +	return find_domain(&pdev->dev);
  }
  
  static int iommu_identity_mapping;
@@@ -2343,25 -2461,20 +2376,42 @@@ static int domain_add_dev_info(struct d
  			       struct pci_dev *pdev,
  			       int translation)
  {
++<<<<<<< HEAD
 +	struct device_domain_info *info;
 +	unsigned long flags;
 +	int ret;
 +
 +	info = alloc_devinfo_mem();
 +	if (!info)
 +		return -ENOMEM;
 +
 +	info->segment = pci_domain_nr(pdev->bus);
 +	info->bus = pdev->bus->number;
 +	info->devfn = pdev->devfn;
 +	info->dev = pdev;
 +	info->domain = domain;
 +
 +	spin_lock_irqsave(&device_domain_lock, flags);
 +	list_add(&info->link, &domain->devices);
 +	list_add(&info->global, &device_domain_list);
 +	pdev->dev.archdata.iommu = info;
 +	spin_unlock_irqrestore(&device_domain_lock, flags);
++=======
+ 	struct dmar_domain *ndomain;
+ 	struct intel_iommu *iommu;
+ 	int ret;
+ 
+ 	iommu = device_to_iommu(pci_domain_nr(pdev->bus),
+ 				pdev->bus->number, pdev->devfn);
+ 	if (!iommu)
+ 		return -ENODEV;
+ 
+ 	ndomain = dmar_insert_dev_info(iommu, pci_domain_nr(pdev->bus),
+ 				       pdev->bus->number, pdev->devfn,
+ 				       &pdev->dev, domain);
+ 	if (ndomain != domain)
+ 		return -EBUSY;
++>>>>>>> 5a8f40e8c880 (iommu/vt-d: Always store iommu in device_domain_info)
  
  	ret = domain_context_mapping(domain, pdev, translation);
  	if (ret) {
* Unmerged path drivers/iommu/intel-iommu.c
