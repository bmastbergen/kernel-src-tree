kvm: vmx: handle invvpid vm exit gracefully

jira LE-1907
cve CVE-2014-3646
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/vmx: handle invvpid vm exit gracefully (Petr  Matousek) [1144829] {CVE-2014-3646}
Rebuild_FUZZ: 96.47%
commit-author Petr Matousek <pmatouse@redhat.com>
commit a642fc305053cc1c6e47e4f4df327895747ab485
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a642fc30.failed

On systems with invvpid instruction support (corresponding bit in
IA32_VMX_EPT_VPID_CAP MSR is set) guest invocation of invvpid
causes vm exit, which is currently not handled and results in
propagation of unknown exit to userspace.

Fix this by installing an invvpid vm exit handler.

This is CVE-2014-3646.

	Cc: stable@vger.kernel.org
	Signed-off-by: Petr Matousek <pmatouse@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit a642fc305053cc1c6e47e4f4df327895747ab485)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/uapi/asm/vmx.h
diff --cc arch/x86/include/uapi/asm/vmx.h
index 7a34e8fe54bd,990a2fe1588d..000000000000
--- a/arch/x86/include/uapi/asm/vmx.h
+++ b/arch/x86/include/uapi/asm/vmx.h
@@@ -112,7 -115,7 +113,12 @@@
  	{ EXIT_REASON_EOI_INDUCED,           "EOI_INDUCED" }, \
  	{ EXIT_REASON_INVALID_STATE,         "INVALID_STATE" }, \
  	{ EXIT_REASON_INVD,                  "INVD" }, \
++<<<<<<< HEAD
 +	{ EXIT_REASON_INVPCID,               "INVPCID" }, \
 +	{ EXIT_REASON_PREEMPTION_TIMER,      "PREEMPTION_TIMER" }
++=======
+ 	{ EXIT_REASON_INVVPID,               "INVVPID" }, \
+ 	{ EXIT_REASON_INVPCID,               "INVPCID" }
++>>>>>>> a642fc305053 (kvm: vmx: handle invvpid vm exit gracefully)
  
  #endif /* _UAPIVMX_H */
* Unmerged path arch/x86/include/uapi/asm/vmx.h
diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index b3da590a90a6..fabe7c5cb60e 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -6551,6 +6551,12 @@ static int handle_invept(struct kvm_vcpu *vcpu)
 	return 1;
 }
 
+static int handle_invvpid(struct kvm_vcpu *vcpu)
+{
+	kvm_queue_exception(vcpu, UD_VECTOR);
+	return 1;
+}
+
 /*
  * The exit handlers return 1 if the exit was handled fully and guest execution
  * may resume.  Otherwise they set the kvm_run parameter to indicate what needs
@@ -6596,6 +6602,7 @@ static int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {
 	[EXIT_REASON_MWAIT_INSTRUCTION]	      = handle_mwait,
 	[EXIT_REASON_MONITOR_INSTRUCTION]     = handle_monitor,
 	[EXIT_REASON_INVEPT]                  = handle_invept,
+	[EXIT_REASON_INVVPID]                 = handle_invvpid,
 };
 
 static const int kvm_vmx_max_exit_handlers =
@@ -6831,7 +6838,7 @@ static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu)
 	case EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD:
 	case EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE:
 	case EXIT_REASON_VMOFF: case EXIT_REASON_VMON:
-	case EXIT_REASON_INVEPT:
+	case EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:
 		/*
 		 * VMX instructions trap unconditionally. This allows L1 to
 		 * emulate them for its L2 guest, i.e., allows 3-level nesting!
