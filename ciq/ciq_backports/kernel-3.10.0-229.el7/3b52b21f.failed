ACPI / dock: Use ACPI device object pointers instead of ACPI handles

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] dock: Use ACPI device object pointers instead of ACPI handles (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 94.57%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 3b52b21fa1f44c8956e21dfba645eda959111b5e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3b52b21f.failed

Rework the ACPI dock station driver to store ACPI device object
pointers instead of ACPI handles in its internal data structures.

The purpose is moslty to make subsequent simplifications possible,
but also this allows the overall code size to be reduced slightly.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 3b52b21fa1f44c8956e21dfba645eda959111b5e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/dock.c
#	drivers/pci/hotplug/acpiphp_glue.c
#	include/acpi/acpi_drivers.h
diff --cc drivers/acpi/dock.c
index c3bab54256c4,8c3967cb4830..000000000000
--- a/drivers/acpi/dock.c
+++ b/drivers/acpi/dock.c
@@@ -99,8 -103,8 +99,13 @@@ struct dock_dependent_device 
   *
   * Add the dependent device to the dock's dependent device list.
   */
++<<<<<<< HEAD
 +static int __init
 +add_dock_dependent_device(struct dock_station *ds, acpi_handle handle)
++=======
+ static int add_dock_dependent_device(struct dock_station *ds,
+ 				     struct acpi_device *adev)
++>>>>>>> 3b52b21fa1f4 (ACPI / dock: Use ACPI device object pointers instead of ACPI handles)
  {
  	struct dock_dependent_device *dd;
  
@@@ -224,6 -249,15 +229,18 @@@ find_dock_dependent_device(struct dock_
  	return NULL;
  }
  
++<<<<<<< HEAD
++=======
+ void register_dock_dependent_device(struct acpi_device *adev,
+ 				    acpi_handle dshandle)
+ {
+ 	struct dock_station *ds = find_dock_station(dshandle);
+ 
+ 	if (ds && !find_dock_dependent_device(ds, adev))
+ 		add_dock_dependent_device(ds, adev);
+ }
+ 
++>>>>>>> 3b52b21fa1f4 (ACPI / dock: Use ACPI device object pointers instead of ACPI handles)
  /*****************************************************************************
   *                         Dock functions                                    *
   *****************************************************************************/
@@@ -299,46 -309,6 +316,49 @@@ static int dock_present(struct dock_sta
  }
  
  /**
++<<<<<<< HEAD
 + * dock_create_acpi_device - add new devices to acpi
 + * @handle - handle of the device to add
 + *
 + *  This function will create a new acpi_device for the given
 + *  handle if one does not exist already.  This should cause
 + *  acpi to scan for drivers for the given devices, and call
 + *  matching driver's add routine.
 + */
 +static void dock_create_acpi_device(acpi_handle handle)
 +{
 +	struct acpi_device *device;
 +	int ret;
 +
 +	if (acpi_bus_get_device(handle, &device)) {
 +		/*
 +		 * no device created for this object,
 +		 * so we should create one.
 +		 */
 +		ret = acpi_bus_scan(handle);
 +		if (ret)
 +			pr_debug("error adding bus, %x\n", -ret);
 +	}
 +}
 +
 +/**
 + * dock_remove_acpi_device - remove the acpi_device struct from acpi
 + * @handle - the handle of the device to remove
 + *
 + *  Tell acpi to remove the acpi_device.  This should cause any loaded
 + *  driver to have it's remove routine called.
 + */
 +static void dock_remove_acpi_device(acpi_handle handle)
 +{
 +	struct acpi_device *device;
 +
 +	if (!acpi_bus_get_device(handle, &device))
 +		acpi_bus_trim(device);
 +}
 +
 +/**
++=======
++>>>>>>> 3b52b21fa1f4 (ACPI / dock: Use ACPI device object pointers instead of ACPI handles)
   * hot_remove_dock_devices - Remove dock station devices.
   * @ds: Dock station.
   */
@@@ -372,17 -342,29 +392,25 @@@ static void hotplug_dock_devices(struc
  {
  	struct dock_dependent_device *dd;
  
 -	/* Call driver specific post-dock fixups. */
 -	list_for_each_entry(dd, &ds->dependent_devices, list)
 -		dock_hotplug_event(dd, event, DOCK_CALL_FIXUP);
 -
  	/* Call driver specific hotplug functions. */
  	list_for_each_entry(dd, &ds->dependent_devices, list)
 -		dock_hotplug_event(dd, event, DOCK_CALL_HANDLER);
 +		dock_hotplug_event(dd, event, false);
  
  	/*
- 	 * Now make sure that an acpi_device is created for each dependent
- 	 * device.  That will cause scan handlers to be attached to device
- 	 * objects or acpi_drivers to be stopped/started if they are present.
+ 	 * Check if all devices have been enumerated already.  If not, run
+ 	 * acpi_bus_scan() for them and that will cause scan handlers to be
+ 	 * attached to device objects or acpi_drivers to be stopped/started if
+ 	 * they are present.
  	 */
- 	list_for_each_entry(dd, &ds->dependent_devices, list)
- 		dock_create_acpi_device(dd->handle);
+ 	list_for_each_entry(dd, &ds->dependent_devices, list) {
+ 		struct acpi_device *adev = dd->adev;
+ 
+ 		if (!acpi_device_enumerated(adev)) {
+ 			int ret = acpi_bus_scan(adev->handle);
+ 			if (ret)
+ 				dev_dbg(&adev->dev, "scan error %d\n", -ret);
+ 		}
+ 	}
  }
  
  static void dock_event(struct dock_station *ds, u32 event, int num)
@@@ -883,13 -786,8 +920,13 @@@ static int __init dock_add(acpi_handle 
  	if (ret)
  		goto err_unregister;
  
 +	/* Find dependent devices */
 +	acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
 +			    ACPI_UINT32_MAX, find_dock_devices, NULL,
 +			    dock_station, NULL);
 +
  	/* add the dock station as a device dependent on itself */
- 	ret = add_dock_dependent_device(dock_station, handle);
+ 	ret = add_dock_dependent_device(dock_station, adev);
  	if (ret)
  		goto err_rmgroup;
  
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,cd886725c42e..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -258,38 -311,49 +258,57 @@@ register_slot(acpi_handle handle, u32 l
  
  	/* search for objects that share the same slot */
  	list_for_each_entry(slot, &bridge->slots, node)
 -		if (slot->device == device)
 -			goto slot_found;
 +		if (slot->device == device) {
 +			if (slot->sun != sun)
 +				pr_warn("sibling found, but _SUN doesn't match!\n");
 +			found = 1;
 +			break;
 +		}
  
 -	slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 -	if (!slot) {
 -		acpi_lock_hp_context();
 -		acpiphp_put_context(context);
 -		acpi_unlock_hp_context();
 -		return AE_NO_MEMORY;
 -	}
 +	if (!found) {
 +		slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 +		if (!slot) {
 +			kfree(newfunc);
 +			return AE_NO_MEMORY;
 +		}
  
++<<<<<<< HEAD
 +		slot->bridge = bridge;
 +		slot->device = device;
 +		slot->sun = sun;
 +		INIT_LIST_HEAD(&slot->funcs);
 +		mutex_init(&slot->crit_sect);
++=======
+ 	slot->bus = bridge->pci_bus;
+ 	slot->device = device;
+ 	INIT_LIST_HEAD(&slot->funcs);
+ 
+ 	list_add_tail(&slot->node, &bridge->slots);
+ 
+ 	/*
+ 	 * Expose slots to user space for functions that have _EJ0 or _RMV or
+ 	 * are located in dock stations.  Do not expose them for devices handled
+ 	 * by the native PCIe hotplug (PCIeHP), becuase that code is supposed to
+ 	 * expose slots to user space in those cases.
+ 	 */
+ 	if ((acpi_pci_check_ejectable(pbus, handle) || is_dock_device(adev))
+ 	    && !(pdev && device_is_managed_by_native_pciehp(pdev))) {
+ 		unsigned long long sun;
+ 		int retval;
++>>>>>>> 3b52b21fa1f4 (ACPI / dock: Use ACPI device object pointers instead of ACPI handles)
  
 +		mutex_lock(&bridge_mutex);
 +		list_add_tail(&slot->node, &bridge->slots);
 +		mutex_unlock(&bridge_mutex);
  		bridge->nr_slots++;
 -		status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 -		if (ACPI_FAILURE(status))
 -			sun = bridge->nr_slots;
  
  		pr_debug("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",
 -		    sun, pci_domain_nr(pbus), pbus->number, device);
 -
 -		retval = acpiphp_register_hotplug_slot(slot, sun);
 +		    slot->sun, pci_domain_nr(pbus), pbus->number, device);
 +		retval = acpiphp_register_hotplug_slot(slot);
  		if (retval) {
 -			slot->slot = NULL;
 -			bridge->nr_slots--;
  			if (retval == -EBUSY)
  				pr_warn("Slot %llu already registered by another "
 -					"hotplug driver\n", sun);
 +					"hotplug driver\n", slot->sun);
  			else
  				pr_warn("acpiphp_register_hotplug_slot failed "
  					"(err code = 0x%x)\n", retval);
@@@ -304,9 -367,9 +323,9 @@@
  
  	if (pci_bus_read_dev_vendor_id(pbus, PCI_DEVFN(device, function),
  				       &val, 60*1000))
 -		slot->flags |= SLOT_ENABLED;
 +		slot->flags |= (SLOT_ENABLED | SLOT_POWEREDON);
  
- 	if (is_dock_device(handle)) {
+ 	if (is_dock_device(adev)) {
  		/* we don't want to call this device's _EJ0
  		 * because we want the dock notify handler
  		 * to call it after it calls _DCK
@@@ -473,19 -409,18 +492,30 @@@ static void cleanup_bridge(struct acpip
  
  	list_for_each_entry(slot, &bridge->slots, node) {
  		list_for_each_entry(func, &slot->funcs, sibling) {
++<<<<<<< HEAD
 +			if (is_dock_device(func->handle)) {
 +				unregister_hotplug_dock_device(func->handle);
 +				unregister_dock_notifier(&func->nb);
 +			}
 +			if (!(func->flags & FUNC_HAS_DCK)) {
 +				status = acpi_remove_notify_handler(func->handle,
 +						ACPI_SYSTEM_NOTIFY,
 +						handle_hotplug_event_func);
 +				if (ACPI_FAILURE(status))
 +					pr_err("failed to remove notify handler\n");
 +			}
++=======
+ 			struct acpi_device *adev = func_to_acpi_device(func);
+ 
+ 			if (is_dock_device(adev))
+ 				unregister_hotplug_dock_device(adev->handle);
+ 
+ 			acpi_lock_hp_context();
+ 			adev->hp->event = NULL;
+ 			acpi_unlock_hp_context();
++>>>>>>> 3b52b21fa1f4 (ACPI / dock: Use ACPI device object pointers instead of ACPI handles)
  		}
 -		slot->flags |= SLOT_IS_GOING_AWAY;
 -		if (slot->slot)
 -			acpiphp_unregister_hotplug_slot(slot);
 +		acpiphp_unregister_hotplug_slot(slot);
  	}
  
  	mutex_lock(&bridge_mutex);
diff --cc include/acpi/acpi_drivers.h
index 0cf85786ed21,d6c98b9cbe38..000000000000
--- a/include/acpi/acpi_drivers.h
+++ b/include/acpi/acpi_drivers.h
@@@ -118,9 -116,7 +118,13 @@@ struct acpi_dock_ops 
  };
  
  #ifdef CONFIG_ACPI_DOCK
++<<<<<<< HEAD
 +extern int is_dock_device(acpi_handle handle);
 +extern int register_dock_notifier(struct notifier_block *nb);
 +extern void unregister_dock_notifier(struct notifier_block *nb);
++=======
+ extern int is_dock_device(struct acpi_device *adev);
++>>>>>>> 3b52b21fa1f4 (ACPI / dock: Use ACPI device object pointers instead of ACPI handles)
  extern int register_hotplug_dock_device(acpi_handle handle,
  					const struct acpi_dock_ops *ops,
  					void *context,
* Unmerged path drivers/acpi/dock.c
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
* Unmerged path include/acpi/acpi_drivers.h
