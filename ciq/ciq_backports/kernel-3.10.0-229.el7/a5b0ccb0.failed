KVM: PPC: Book3S HV: Remove bogus duplicate code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/ppc: book3s/hv - Remove bogus duplicate code (David Gibson) [1123145 1123133 1123367]
Rebuild_FUZZ: 91.67%
commit-author Paul Mackerras <paulus@samba.org>
commit a5b0ccb0b5d080c0decb4c9208d9bb6072defa50
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a5b0ccb0.failed

Commit 7b490411c37f ("KVM: PPC: Book3S HV: Add new state for
transactional memory") incorrectly added some duplicate code to the
guest exit path because I didn't manage to clean up after a rebase
correctly.  This removes the extraneous material.  The presence of
this extraneous code causes host crashes whenever a guest is run.

	Signed-off-by: Paul Mackerras <paulus@samba.org>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit a5b0ccb0b5d080c0decb4c9208d9bb6072defa50)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_hv_rmhandlers.S
diff --cc arch/powerpc/kvm/book3s_hv_rmhandlers.S
index 0ae4c28ae4b6,781e6bf69afb..000000000000
--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S
+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S
@@@ -1214,151 -1504,14 +1214,163 @@@ END_FTR_SECTION_IFSET(CPU_FTR_ARCH_201
  1:	addi	r8,r8,16
  	.endr
  
 +	/* Save DEC */
 +	mfspr	r5,SPRN_DEC
 +	mftb	r6
 +	extsw	r5,r5
 +	add	r5,r5,r6
 +	std	r5,VCPU_DEC_EXPIRES(r9)
 +
 +	/* Save and reset AMR and UAMOR before turning on the MMU */
 +BEGIN_FTR_SECTION
 +	mfspr	r5,SPRN_AMR
 +	mfspr	r6,SPRN_UAMOR
 +	std	r5,VCPU_AMR(r9)
 +	std	r6,VCPU_UAMOR(r9)
 +	li	r6,0
 +	mtspr	SPRN_AMR,r6
 +END_FTR_SECTION_IFSET(CPU_FTR_ARCH_206)
 +
 +	/* Unset guest mode */
 +	li	r0, KVM_GUEST_MODE_NONE
 +	stb	r0, HSTATE_IN_GUEST(r13)
 +
 +	/* Switch DSCR back to host value */
 +BEGIN_FTR_SECTION
 +	mfspr	r8, SPRN_DSCR
 +	ld	r7, HSTATE_DSCR(r13)
 +	std	r8, VCPU_DSCR(r9)
 +	mtspr	SPRN_DSCR, r7
 +END_FTR_SECTION_IFSET(CPU_FTR_ARCH_206)
 +
 +	/* Save non-volatile GPRs */
 +	std	r14, VCPU_GPR(R14)(r9)
 +	std	r15, VCPU_GPR(R15)(r9)
 +	std	r16, VCPU_GPR(R16)(r9)
 +	std	r17, VCPU_GPR(R17)(r9)
 +	std	r18, VCPU_GPR(R18)(r9)
 +	std	r19, VCPU_GPR(R19)(r9)
 +	std	r20, VCPU_GPR(R20)(r9)
 +	std	r21, VCPU_GPR(R21)(r9)
 +	std	r22, VCPU_GPR(R22)(r9)
 +	std	r23, VCPU_GPR(R23)(r9)
 +	std	r24, VCPU_GPR(R24)(r9)
 +	std	r25, VCPU_GPR(R25)(r9)
 +	std	r26, VCPU_GPR(R26)(r9)
 +	std	r27, VCPU_GPR(R27)(r9)
 +	std	r28, VCPU_GPR(R28)(r9)
 +	std	r29, VCPU_GPR(R29)(r9)
 +	std	r30, VCPU_GPR(R30)(r9)
 +	std	r31, VCPU_GPR(R31)(r9)
 +
 +	/* Save SPRGs */
 +	mfspr	r3, SPRN_SPRG0
 +	mfspr	r4, SPRN_SPRG1
 +	mfspr	r5, SPRN_SPRG2
 +	mfspr	r6, SPRN_SPRG3
 +	std	r3, VCPU_SPRG0(r9)
 +	std	r4, VCPU_SPRG1(r9)
 +	std	r5, VCPU_SPRG2(r9)
 +	std	r6, VCPU_SPRG3(r9)
 +
 +	/* save FP state */
 +	mr	r3, r9
 +	bl	kvmppc_save_fp
 +
 +	/* Increment yield count if they have a VPA */
 +	ld	r8, VCPU_VPA(r9)	/* do they have a VPA? */
 +	cmpdi	r8, 0
 +	beq	25f
 +	lwz	r3, LPPACA_YIELDCOUNT(r8)
 +	addi	r3, r3, 1
 +	stw	r3, LPPACA_YIELDCOUNT(r8)
 +	li	r3, 1
 +	stb	r3, VCPU_VPA_DIRTY(r9)
 +25:
 +	/* Save PMU registers if requested */
 +	/* r8 and cr0.eq are live here */
 +	li	r3, 1
 +	sldi	r3, r3, 31		/* MMCR0_FC (freeze counters) bit */
 +	mfspr	r4, SPRN_MMCR0		/* save MMCR0 */
 +	mtspr	SPRN_MMCR0, r3		/* freeze all counters, disable ints */
 +	mfspr	r6, SPRN_MMCRA
 +BEGIN_FTR_SECTION
 +	/* On P7, clear MMCRA in order to disable SDAR updates */
 +	li	r7, 0
 +	mtspr	SPRN_MMCRA, r7
 +END_FTR_SECTION_IFSET(CPU_FTR_ARCH_206)
 +	isync
 +	beq	21f			/* if no VPA, save PMU stuff anyway */
 +	lbz	r7, LPPACA_PMCINUSE(r8)
 +	cmpwi	r7, 0			/* did they ask for PMU stuff to be saved? */
 +	bne	21f
 +	std	r3, VCPU_MMCR(r9)	/* if not, set saved MMCR0 to FC */
 +	b	22f
 +21:	mfspr	r5, SPRN_MMCR1
 +	mfspr	r7, SPRN_SIAR
 +	mfspr	r8, SPRN_SDAR
 +	std	r4, VCPU_MMCR(r9)
 +	std	r5, VCPU_MMCR + 8(r9)
 +	std	r6, VCPU_MMCR + 16(r9)
 +	std	r7, VCPU_SIAR(r9)
 +	std	r8, VCPU_SDAR(r9)
 +	mfspr	r3, SPRN_PMC1
 +	mfspr	r4, SPRN_PMC2
 +	mfspr	r5, SPRN_PMC3
 +	mfspr	r6, SPRN_PMC4
 +	mfspr	r7, SPRN_PMC5
 +	mfspr	r8, SPRN_PMC6
 +BEGIN_FTR_SECTION
 +	mfspr	r10, SPRN_PMC7
 +	mfspr	r11, SPRN_PMC8
 +END_FTR_SECTION_IFSET(CPU_FTR_ARCH_201)
 +	stw	r3, VCPU_PMC(r9)
 +	stw	r4, VCPU_PMC + 4(r9)
 +	stw	r5, VCPU_PMC + 8(r9)
 +	stw	r6, VCPU_PMC + 12(r9)
 +	stw	r7, VCPU_PMC + 16(r9)
 +	stw	r8, VCPU_PMC + 20(r9)
 +BEGIN_FTR_SECTION
 +	stw	r10, VCPU_PMC + 24(r9)
 +	stw	r11, VCPU_PMC + 28(r9)
 +END_FTR_SECTION_IFSET(CPU_FTR_ARCH_201)
 +22:
 +	ld	r0, 112+PPC_LR_STKOFF(r1)
 +	addi	r1, r1, 112
 +	mtlr	r0
 +	blr
 +secondary_too_late:
 +	ld	r5,HSTATE_KVM_VCORE(r13)
 +	HMT_LOW
 +13:	lbz	r3,VCORE_IN_GUEST(r5)
 +	cmpwi	r3,0
 +	bne	13b
 +	HMT_MEDIUM
 +	li	r0, KVM_GUEST_MODE_NONE
 +	stb	r0, HSTATE_IN_GUEST(r13)
 +	ld	r11,PACA_SLBSHADOWPTR(r13)
 +
 +	.rept	SLB_NUM_BOLTED
 +	ld	r5,SLBSHADOW_SAVEAREA(r11)
 +	ld	r6,SLBSHADOW_SAVEAREA+8(r11)
 +	andis.	r7,r5,SLB_ESID_V@h
 +	beq	1f
 +	slbmte	r6,r5
 +1:	addi	r11,r11,16
 +	.endr
++<<<<<<< HEAD
 +	b	22b
++=======
++
+ 	/* Unset guest mode */
+ 	li	r0, KVM_GUEST_MODE_NONE
+ 	stb	r0, HSTATE_IN_GUEST(r13)
+ 
+ 	ld	r0, 112+PPC_LR_STKOFF(r1)
+ 	addi	r1, r1, 112
+ 	mtlr	r0
+ 	blr
++>>>>>>> a5b0ccb0b5d0 (KVM: PPC: Book3S HV: Remove bogus duplicate code)
  
  /*
   * Check whether an HDSI is an HPTE not found fault or something else.
* Unmerged path arch/powerpc/kvm/book3s_hv_rmhandlers.S
