ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Embed function struct into struct acpiphp_context (Myron Stowe) [1114228]
Rebuild_FUZZ: 93.23%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit bd4674dfc5fc704837148f36af41e1e0a640dfec
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/bd4674df.failed

Since there has to be a struct acpiphp_func object for every struct
acpiphp_context created by register_slot(), the struct acpiphp_func
one can be embedded into the struct acpiphp_context one, which allows
some code simplifications to be made.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit bd4674dfc5fc704837148f36af41e1e0a640dfec)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp.h
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp.h
index 8d99e4e1e51d,31c84bdd2bef..000000000000
--- a/drivers/pci/hotplug/acpiphp.h
+++ b/drivers/pci/hotplug/acpiphp.h
@@@ -119,6 -125,18 +119,21 @@@ struct acpiphp_func 
  	u32		flags;		/* see below */
  };
  
++<<<<<<< HEAD
++=======
+ struct acpiphp_context {
+ 	acpi_handle handle;
+ 	struct acpiphp_func func;
+ 	struct acpiphp_bridge *bridge;
+ 	unsigned int refcount;
+ };
+ 
+ static inline struct acpiphp_context *func_to_context(struct acpiphp_func *func)
+ {
+ 	return container_of(func, struct acpiphp_context, func);
+ }
+ 
++>>>>>>> bd4674dfc5fc (ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context)
  /*
   * struct acpiphp_attention_info - device specific attention registration
   *
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index b5069ad47c47,cc7453e0722e..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -57,26 -55,82 +57,68 @@@
  
  static LIST_HEAD(bridge_list);
  static DEFINE_MUTEX(bridge_mutex);
 -static DEFINE_MUTEX(acpiphp_context_lock);
 -
 -#define MY_NAME "acpiphp_glue"
  
 -static void handle_hotplug_event(acpi_handle handle, u32 type, void *data);
 +static void handle_hotplug_event_bridge (acpi_handle, u32, void *);
  static void acpiphp_sanitize_bus(struct pci_bus *bus);
  static void acpiphp_set_hpp_values(struct pci_bus *bus);
 -static void hotplug_event(acpi_handle handle, u32 type, void *data);
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context);
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type, void *context);
  static void free_bridge(struct kref *kref);
  
 -static void acpiphp_context_handler(acpi_handle handle, void *context)
 -{
 -	/* Intentionally empty. */
 -}
 -
 -/**
 - * acpiphp_init_context - Create hotplug context and grab a reference to it.
 - * @handle: ACPI object handle to create the context for.
 - *
 - * Call under acpiphp_context_lock.
 - */
 -static struct acpiphp_context *acpiphp_init_context(acpi_handle handle)
 +/* callback routine to check for the existence of a pci dock device */
 +static acpi_status
 +is_pci_dock_device(acpi_handle handle, u32 lvl, void *context, void **rv)
  {
 -	struct acpiphp_context *context;
 -	acpi_status status;
 -
 -	context = kzalloc(sizeof(*context), GFP_KERNEL);
 -	if (!context)
 -		return NULL;
 +	int *count = (int *)context;
  
 -	context->handle = handle;
 -	context->refcount = 1;
 -	status = acpi_attach_data(handle, acpiphp_context_handler, context);
 -	if (ACPI_FAILURE(status)) {
 -		kfree(context);
 -		return NULL;
 +	if (is_dock_device(handle)) {
 +		(*count)++;
 +		return AE_CTRL_TERMINATE;
 +	} else {
 +		return AE_OK;
  	}
++<<<<<<< HEAD
++=======
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_get_context - Get hotplug context and grab a reference to it.
+  * @handle: ACPI object handle to get the context for.
+  *
+  * Call under acpiphp_context_lock.
+  */
+ static struct acpiphp_context *acpiphp_get_context(acpi_handle handle)
+ {
+ 	struct acpiphp_context *context = NULL;
+ 	acpi_status status;
+ 	void *data;
+ 
+ 	status = acpi_get_data(handle, acpiphp_context_handler, &data);
+ 	if (ACPI_SUCCESS(status)) {
+ 		context = data;
+ 		context->refcount++;
+ 	}
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_put_context - Drop a reference to ACPI hotplug context.
+  * @handle: ACPI object handle to put the context for.
+  *
+  * The context object is removed if there are no more references to it.
+  *
+  * Call under acpiphp_context_lock.
+  */
+ static void acpiphp_put_context(struct acpiphp_context *context)
+ {
+ 	if (--context->refcount)
+ 		return;
+ 
+ 	WARN_ON(context->bridge);
+ 	acpi_detach_data(context->handle, acpiphp_context_handler);
+ 	kfree(context);
++>>>>>>> bd4674dfc5fc (ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context)
  }
  
  static inline void get_bridge(struct acpiphp_bridge *bridge)
@@@ -98,15 -153,23 +140,33 @@@ static void free_bridge(struct kref *kr
  	bridge = container_of(kref, struct acpiphp_bridge, ref);
  
  	list_for_each_entry_safe(slot, next, &bridge->slots, node) {
++<<<<<<< HEAD
 +		list_for_each_entry_safe(func, tmp, &slot->funcs, sibling) {
 +			kfree(func);
 +		}
 +		kfree(slot);
 +	}
 +
 +	/* Release reference acquired by acpiphp_bridge_handle_to_function() */
 +	if ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func)
 +		put_bridge(bridge->func->slot->bridge);
++=======
+ 		list_for_each_entry_safe(func, tmp, &slot->funcs, sibling)
+ 			acpiphp_put_context(func_to_context(func));
+ 
+ 		kfree(slot);
+ 	}
+ 
+ 	context = bridge->context;
+ 	/* Root bridges will not have hotplug context. */
+ 	if (context) {
+ 		/* Release the reference taken by acpiphp_enumerate_slots(). */
+ 		put_bridge(context->func.slot->bridge);
+ 		context->bridge = NULL;
+ 		acpiphp_put_context(context);
+ 	}
+ 
++>>>>>>> bd4674dfc5fc (ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context)
  	put_device(&bridge->pci_bus->dev);
  	pci_dev_put(bridge->pci_dev);
  	kfree(bridge);
@@@ -119,11 -184,10 +179,16 @@@
   * TBD - figure out a way to only call fixups for
   * systems that require them.
   */
 -static void post_dock_fixups(acpi_handle not_used, u32 event, void *data)
 +static int post_dock_fixups(struct notifier_block *nb, unsigned long val,
 +	void *v)
  {
++<<<<<<< HEAD
 +	struct acpiphp_func *func = container_of(nb, struct acpiphp_func, nb);
 +	struct pci_bus *bus = func->slot->bridge->pci_bus;
++=======
+ 	struct acpiphp_context *context = data;
+ 	struct pci_bus *bus = context->func.slot->bridge->pci_bus;
++>>>>>>> bd4674dfc5fc (ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context)
  	u32 buses;
  
  	if (!bus->self)
@@@ -182,16 -246,16 +247,24 @@@ static bool device_is_managed_by_native
  
  static void acpiphp_dock_init(void *data)
  {
 -	struct acpiphp_context *context = data;
 +	struct acpiphp_func *func = data;
  
++<<<<<<< HEAD
 +	get_bridge(func->slot->bridge);
++=======
+ 	get_bridge(context->func.slot->bridge);
++>>>>>>> bd4674dfc5fc (ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context)
  }
  
  static void acpiphp_dock_release(void *data)
  {
 -	struct acpiphp_context *context = data;
 +	struct acpiphp_func *func = data;
  
++<<<<<<< HEAD
 +	put_bridge(func->slot->bridge);
++=======
+ 	put_bridge(context->func.slot->bridge);
++>>>>>>> bd4674dfc5fc (ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context)
  }
  
  /* callback routine to register each ACPI PCI slot object */
@@@ -221,82 -285,80 +294,98 @@@ register_slot(acpi_handle handle, u32 l
  	device = (adr >> 16) & 0xffff;
  	function = adr & 0xffff;
  
++<<<<<<< HEAD
 +	pdev = bridge->pci_dev;
 +	if (pdev && device_is_managed_by_native_pciehp(pdev))
 +		return AE_OK;
 +
 +	newfunc = kzalloc(sizeof(struct acpiphp_func), GFP_KERNEL);
 +	if (!newfunc)
 +		return AE_NO_MEMORY;
 +
 +	newfunc->handle = handle;
 +	newfunc->function = function;
 +
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
++=======
+ 	mutex_lock(&acpiphp_context_lock);
+ 	context = acpiphp_init_context(handle);
+ 	if (!context) {
+ 		mutex_unlock(&acpiphp_context_lock);
+ 		acpi_handle_err(handle, "No hotplug context\n");
+ 		return AE_NOT_EXIST;
+ 	}
+ 	newfunc = &context->func;
+ 	newfunc->handle = handle;
+ 	newfunc->function = function;
+ 	mutex_unlock(&acpiphp_context_lock);
+ 
+ 	if (acpi_has_method(handle, "_EJ0"))
++>>>>>>> bd4674dfc5fc (ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context)
  		newfunc->flags = FUNC_HAS_EJ0;
  
 -	if (acpi_has_method(handle, "_STA"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_STA", &tmp)))
  		newfunc->flags |= FUNC_HAS_STA;
  
 -	if (acpi_has_method(handle, "_PS0"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS0", &tmp)))
  		newfunc->flags |= FUNC_HAS_PS0;
  
 -	if (acpi_has_method(handle, "_PS3"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS3", &tmp)))
  		newfunc->flags |= FUNC_HAS_PS3;
  
 -	if (acpi_has_method(handle, "_DCK"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_DCK", &tmp)))
  		newfunc->flags |= FUNC_HAS_DCK;
  
 -	/* search for objects that share the same slot */
 -	list_for_each_entry(slot, &bridge->slots, node)
 -		if (slot->device == device)
 -			goto slot_found;
 -
 -	slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 -	if (!slot) {
 -		status = AE_NO_MEMORY;
 -		goto err;
 +	status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 +	if (ACPI_FAILURE(status)) {
 +		/*
 +		 * use the count of the number of slots we've found
 +		 * for the number of the slot
 +		 */
 +		sun = bridge->nr_slots+1;
  	}
  
 -	slot->bridge = bridge;
 -	slot->device = device;
 -	INIT_LIST_HEAD(&slot->funcs);
 -	mutex_init(&slot->crit_sect);
 +	/* search for objects that share the same slot */
 +	list_for_each_entry(slot, &bridge->slots, node)
 +		if (slot->device == device) {
 +			if (slot->sun != sun)
 +				pr_warn("sibling found, but _SUN doesn't match!\n");
 +			found = 1;
 +			break;
 +		}
  
 -	mutex_lock(&bridge_mutex);
 -	list_add_tail(&slot->node, &bridge->slots);
 -	mutex_unlock(&bridge_mutex);
 +	if (!found) {
 +		slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 +		if (!slot) {
 +			kfree(newfunc);
 +			return AE_NO_MEMORY;
 +		}
  
 -	/* Register slots for ejectable funtions only. */
 -	if (acpi_pci_check_ejectable(pbus, handle)  || is_dock_device(handle)) {
 -		unsigned long long sun;
 -		int retval;
 +		slot->bridge = bridge;
 +		slot->device = device;
 +		slot->sun = sun;
 +		INIT_LIST_HEAD(&slot->funcs);
 +		mutex_init(&slot->crit_sect);
  
 +		mutex_lock(&bridge_mutex);
 +		list_add_tail(&slot->node, &bridge->slots);
 +		mutex_unlock(&bridge_mutex);
  		bridge->nr_slots++;
 -		status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 -		if (ACPI_FAILURE(status))
 -			sun = bridge->nr_slots;
  
 -		dbg("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",
 -		    sun, pci_domain_nr(pbus), pbus->number, device);
 -
 -		retval = acpiphp_register_hotplug_slot(slot, sun);
 +		pr_debug("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",
 +		    slot->sun, pci_domain_nr(pbus), pbus->number, device);
 +		retval = acpiphp_register_hotplug_slot(slot);
  		if (retval) {
 -			bridge->nr_slots--;
  			if (retval == -EBUSY)
 -				warn("Slot %llu already registered by another "
 -					"hotplug driver\n", sun);
 +				pr_warn("Slot %llu already registered by another "
 +					"hotplug driver\n", slot->sun);
  			else
 -				warn("acpiphp_register_hotplug_slot failed "
 +				pr_warn("acpiphp_register_hotplug_slot failed "
  					"(err code = 0x%x)\n", retval);
 +			goto err_exit;
  		}
 -		/* Even if the slot registration fails, we can still use it. */
  	}
  
 - slot_found:
  	newfunc->slot = slot;
  	mutex_lock(&bridge_mutex);
  	list_add_tail(&newfunc->sibling, &slot->funcs);
@@@ -328,107 -382,23 +417,116 @@@
  
  	/* install notify handler */
  	if (!(newfunc->flags & FUNC_HAS_DCK)) {
 -		status = acpi_install_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
 -						     handle_hotplug_event,
 -						     context);
 +		status = acpi_install_notify_handler(handle,
 +					     ACPI_SYSTEM_NOTIFY,
 +					     handle_hotplug_event_func,
 +					     newfunc);
 +
  		if (ACPI_FAILURE(status))
 -			acpi_handle_err(handle,
 -					"failed to install notify handler\n");
 -	}
 +			pr_err("failed to register interrupt notify handler\n");
 +	} else
 +		status = AE_OK;
 +
 +	return status;
 +
 + err_exit:
 +	bridge->nr_slots--;
 +	mutex_lock(&bridge_mutex);
 +	list_del(&slot->node);
 +	mutex_unlock(&bridge_mutex);
 +	kfree(slot);
 +	kfree(newfunc);
  
  	return AE_OK;
++<<<<<<< HEAD
++=======
+ 
+  err:
+ 	mutex_lock(&acpiphp_context_lock);
+ 	acpiphp_put_context(context);
+ 	mutex_unlock(&acpiphp_context_lock);
+ 	return status;
++>>>>>>> bd4674dfc5fc (ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context)
 +}
 +
 +
 +/* see if it's worth looking at this bridge */
 +static int detect_ejectable_slots(acpi_handle handle)
 +{
 +	int found = acpi_pci_detect_ejectable(handle);
 +	if (!found) {
 +		acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, (u32)1,
 +				    is_pci_dock_device, NULL, (void *)&found, NULL);
 +	}
 +	return found;
  }
  
 +/* initialize miscellaneous stuff for both root and PCI-to-PCI bridge */
 +static void init_bridge_misc(struct acpiphp_bridge *bridge)
 +{
 +	acpi_status status;
 +
 +	/* must be added to the list prior to calling register_slot */
 +	mutex_lock(&bridge_mutex);
 +	list_add(&bridge->list, &bridge_list);
 +	mutex_unlock(&bridge_mutex);
 +
 +	/* register all slot objects under this bridge */
 +	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, bridge->handle, (u32)1,
 +				     register_slot, NULL, bridge, NULL);
 +	if (ACPI_FAILURE(status)) {
 +		mutex_lock(&bridge_mutex);
 +		list_del(&bridge->list);
 +		mutex_unlock(&bridge_mutex);
 +		return;
 +	}
 +
 +	/* install notify handler for P2P bridges */
 +	if (!pci_is_root_bus(bridge->pci_bus)) {
 +		if ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {
 +			status = acpi_remove_notify_handler(bridge->func->handle,
 +						ACPI_SYSTEM_NOTIFY,
 +						handle_hotplug_event_func);
 +			if (ACPI_FAILURE(status))
 +				pr_err("failed to remove notify handler\n");
 +		}
 +		status = acpi_install_notify_handler(bridge->handle,
 +					     ACPI_SYSTEM_NOTIFY,
 +					     handle_hotplug_event_bridge,
 +					     bridge);
 +
 +		if (ACPI_FAILURE(status)) {
 +			pr_err("failed to register interrupt notify handler\n");
 +		}
 +	}
 +}
 +
 +
 +/* find acpiphp_func from acpiphp_bridge */
 +static struct acpiphp_func *acpiphp_bridge_handle_to_function(acpi_handle handle)
 +{
 +	struct acpiphp_bridge *bridge;
 +	struct acpiphp_slot *slot;
 +	struct acpiphp_func *func = NULL;
 +
 +	mutex_lock(&bridge_mutex);
 +	list_for_each_entry(bridge, &bridge_list, list) {
 +		list_for_each_entry(slot, &bridge->slots, node) {
 +			list_for_each_entry(func, &slot->funcs, sibling) {
 +				if (func->handle == handle) {
 +					get_bridge(func->slot->bridge);
 +					mutex_unlock(&bridge_mutex);
 +					return func;
 +				}
 +			}
 +		}
 +	}
 +	mutex_unlock(&bridge_mutex);
 +
 +	return NULL;
 +}
 +
 +
  static struct acpiphp_bridge *acpiphp_handle_to_bridge(acpi_handle handle)
  {
  	struct acpiphp_context *context;
@@@ -984,8 -923,10 +1082,13 @@@ void acpiphp_check_host_bridge(acpi_han
  		ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
  }
  
 -static void hotplug_event(acpi_handle handle, u32 type, void *data)
 +static void _handle_hotplug_event_bridge(struct work_struct *work)
  {
++<<<<<<< HEAD
++=======
+ 	struct acpiphp_context *context = data;
+ 	struct acpiphp_func *func = &context->func;
++>>>>>>> bd4674dfc5fc (ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context)
  	struct acpiphp_bridge *bridge;
  	char objname[64];
  	struct acpi_buffer buffer = { .length = sizeof(objname),
@@@ -1056,90 -1000,24 +1159,105 @@@
  		break;
  	}
  
 -	if (bridge)
 -		put_bridge(bridge);
 +	acpi_scan_lock_release();
++<<<<<<< HEAD
 +	kfree(hp_work); /* allocated in handle_hotplug_event_bridge */
 +	put_bridge(bridge);
++=======
++	kfree(hp_work); /* allocated in handle_hotplug_event() */
++	put_bridge(context->func.slot->bridge);
++>>>>>>> bd4674dfc5fc (ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context)
  }
  
 -static void hotplug_event_work(struct work_struct *work)
 +/**
 + * handle_hotplug_event_bridge - handle ACPI event on bridges
 + * @handle: Notify()'ed acpi_handle
 + * @type: Notify code
 + * @context: pointer to acpiphp_bridge structure
 + *
 + * Handles ACPI event notification on {host,p2p} bridges.
 + */
 +static void handle_hotplug_event_bridge(acpi_handle handle, u32 type,
 +					void *context)
 +{
 +	struct acpiphp_bridge *bridge = context;
 +
++<<<<<<< HEAD
++=======
++	mutex_lock(&acpiphp_context_lock);
++	context = acpiphp_get_context(handle);
++	if (context) {
++		get_bridge(context->func.slot->bridge);
++		acpiphp_put_context(context);
++	}
++	mutex_unlock(&acpiphp_context_lock);
++>>>>>>> bd4674dfc5fc (ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context)
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_bridge);
 +}
 +
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context)
 +{
 +	struct acpiphp_func *func = context;
 +	char objname[64];
 +	struct acpi_buffer buffer = { .length = sizeof(objname),
 +				      .pointer = objname };
 +
 +	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 +
 +	switch (type) {
 +	case ACPI_NOTIFY_BUS_CHECK:
 +		/* bus re-enumerate */
 +		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
 +		acpiphp_enable_slot(func->slot);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_CHECK:
 +		/* device check : re-enumerate from parent bus */
 +		pr_debug("%s: Device check notify on %s\n", __func__, objname);
 +		acpiphp_check_bridge(func->slot->bridge);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_WAKE:
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
 +		break;
 +
 +	case ACPI_NOTIFY_EJECT_REQUEST:
 +		/* request device eject */
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if (!(acpiphp_disable_slot(func->slot)))
 +			acpiphp_eject_slot(func->slot);
 +		break;
 +
 +	default:
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
 +		break;
 +	}
 +}
 +
 +static void _handle_hotplug_event_func(struct work_struct *work)
  {
 -	struct acpiphp_context *context;
  	struct acpi_hp_work *hp_work;
 +	struct acpiphp_func *func;
  
  	hp_work = container_of(work, struct acpi_hp_work, work);
 -	context = hp_work->context;
 +	func = hp_work->context;
  	acpi_scan_lock_acquire();
  
 -	hotplug_event(hp_work->handle, hp_work->type, context);
 +	hotplug_event_func(hp_work->handle, hp_work->type, func);
  
  	acpi_scan_lock_release();
 -	kfree(hp_work); /* allocated in handle_hotplug_event() */
 -	put_bridge(context->func.slot->bridge);
 +	kfree(hp_work); /* allocated in handle_hotplug_event_func */
 +	put_bridge(func->slot->bridge);
  }
  
  /**
@@@ -1201,15 -1087,42 +1319,39 @@@ void acpiphp_enumerate_slots(struct pci
  	 */
  	get_device(&bus->dev);
  
++<<<<<<< HEAD
 +	if (!pci_is_root_bus(bridge->pci_bus) &&
 +	    ACPI_SUCCESS(acpi_get_handle(bridge->handle,
 +					"_EJ0", &dummy_handle))) {
 +		pr_debug("found ejectable p2p bridge\n");
 +		bridge->flags |= BRIDGE_HAS_EJ0;
 +		bridge->func = acpiphp_bridge_handle_to_function(handle);
++=======
+ 	if (!pci_is_root_bus(bridge->pci_bus)) {
+ 		struct acpiphp_context *context;
+ 
+ 		/*
+ 		 * This bridge should have been registered as a hotplug function
+ 		 * under its parent, so the context has to be there.  If not, we
+ 		 * are in deep goo.
+ 		 */
+ 		mutex_lock(&acpiphp_context_lock);
+ 		context = acpiphp_get_context(handle);
+ 		if (WARN_ON(!context)) {
+ 			mutex_unlock(&acpiphp_context_lock);
+ 			put_device(&bus->dev);
+ 			kfree(bridge);
+ 			return;
+ 		}
+ 		bridge->context = context;
+ 		context->bridge = bridge;
+ 		/* Get a reference to the parent bridge. */
+ 		get_bridge(context->func.slot->bridge);
+ 		mutex_unlock(&acpiphp_context_lock);
++>>>>>>> bd4674dfc5fc (ACPI / hotplug / PCI: Embed function struct into struct acpiphp_context)
  	}
  
 -	/* must be added to the list prior to calling register_slot */
 -	mutex_lock(&bridge_mutex);
 -	list_add(&bridge->list, &bridge_list);
 -	mutex_unlock(&bridge_mutex);
 -
 -	/* register all slot objects under this bridge */
 -	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, bridge->handle, 1,
 -				     register_slot, NULL, bridge, NULL);
 -	if (ACPI_FAILURE(status)) {
 -		acpi_handle_err(bridge->handle, "failed to register slots\n");
 -		cleanup_bridge(bridge);
 -		put_bridge(bridge);
 -	}
 +	init_bridge_misc(bridge);
  }
  
  /* Destroy hotplug slots associated with the PCI bus */
* Unmerged path drivers/pci/hotplug/acpiphp.h
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
