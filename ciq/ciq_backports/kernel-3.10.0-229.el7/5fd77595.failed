smp: Iterate functions through llist_for_each_entry_safe()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Jan Kara <jack@suse.cz>
commit 5fd77595ec62141fa71e575bdbf410e0192f87d0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5fd77595.failed

The IPI function llist iteration is open coded. Lets simplify this
with using an llist iterator.

Also we want to keep the iteration safe against possible
csd.llist->next value reuse from the IPI handler. At least the block
subsystem used to do such things so lets stay careful and use
llist_for_each_entry_safe().

	Signed-off-by: Jan Kara <jack@suse.cz>
	Cc: Andrew Morton <akpm@linux-foundation.org>
	Cc: Christoph Hellwig <hch@infradead.org>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Jens Axboe <axboe@fb.com>
	Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 5fd77595ec62141fa71e575bdbf410e0192f87d0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/smp.c
diff --cc kernel/smp.c
index 74100ac030d3,e3852de042a6..000000000000
--- a/kernel/smp.c
+++ b/kernel/smp.c
@@@ -178,26 -151,19 +178,36 @@@ static void generic_exec_single(int cpu
   */
  void generic_smp_call_function_single_interrupt(void)
  {
++<<<<<<< HEAD
 +	struct call_single_queue *q = &__get_cpu_var(call_single_queue);
 +	LIST_HEAD(list);
++=======
+ 	struct llist_node *entry;
+ 	struct call_single_data *csd, *csd_next;
++>>>>>>> 5fd77595ec62 (smp: Iterate functions through llist_for_each_entry_safe())
  
  	/*
  	 * Shouldn't receive this interrupt on a cpu that is not yet online.
  	 */
  	WARN_ON_ONCE(!cpu_online(smp_processor_id()));
  
 -	entry = llist_del_all(&__get_cpu_var(call_single_queue));
 -	entry = llist_reverse_order(entry);
 +	raw_spin_lock(&q->lock);
 +	list_replace_init(&q->list, &list);
 +	raw_spin_unlock(&q->lock);
 +
++<<<<<<< HEAD
 +	while (!list_empty(&list)) {
 +		struct call_single_data *csd;
  
 +		csd = list_entry(list.next, struct call_single_data, list);
 +		list_del(&csd->list);
 +
 +		csd->func(csd->info);
 +
++=======
+ 	llist_for_each_entry_safe(csd, csd_next, entry, llist) {
+ 		csd->func(csd->info);
++>>>>>>> 5fd77595ec62 (smp: Iterate functions through llist_for_each_entry_safe())
  		csd_unlock(csd);
  	}
  }
* Unmerged path kernel/smp.c
