ceph: clear directory's completeness when creating file

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Yan, Zheng <zheng.z.yan@intel.com>
commit 0a8a70f96fe1bd3e07c15bb86fd247e76102398a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0a8a70f9.failed

When creating a file, ceph_set_dentry_offset() puts the new dentry
at the end of directory's d_subdirs, then set the dentry's offset
based on directory's max offset. The offset does not reflect the
real postion of the dentry in directory. Later readdir reply from
MDS may change the dentry's position/offset. This inconsistency
can cause missing/duplicate entries in readdir result if readdir
is partly satisfied by dcache_readdir().

The fix is clear directory's completeness after creating/renaming
file. It prevents later readdir from using dcache_readdir().

Fixes: http://tracker.ceph.com/issues/8025
	Signed-off-by: Yan, Zheng <zheng.z.yan@intel.com>
	Reviewed-by: Sage Weil <sage@inktank.com>
(cherry picked from commit 0a8a70f96fe1bd3e07c15bb86fd247e76102398a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ceph/dir.c
#	fs/ceph/inode.c
diff --cc fs/ceph/dir.c
index 9c6549f6a540,c29d6ae68874..000000000000
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@@ -438,7 -448,6 +438,10 @@@ more
  	if (atomic_read(&ci->i_release_count) == fi->dir_release_count) {
  		dout(" marking %p complete\n", inode);
  		__ceph_dir_set_complete(ci, fi->dir_release_count);
++<<<<<<< HEAD
 +		ci->i_max_offset = filp->f_pos;
++=======
++>>>>>>> 0a8a70f96fe1 (ceph: clear directory's completeness when creating file)
  	}
  	spin_unlock(&ci->i_ceph_lock);
  
diff --cc fs/ceph/inode.c
index f30bedb11ab8,233c6f96910a..000000000000
--- a/fs/ceph/inode.c
+++ b/fs/ceph/inode.c
@@@ -1158,14 -1144,11 +1122,22 @@@ retry_lookup
  			   rehashing bug in vfs_rename_dir */
  			ceph_invalidate_dentry_lease(dn);
  
++<<<<<<< HEAD
 +			/*
 +			 * d_move() puts the renamed dentry at the end of
 +			 * d_subdirs.  We need to assign it an appropriate
 +			 * directory offset so we can behave when dir is
 +			 * complete.
 +			 */
 +			ceph_set_dentry_offset(req->r_old_dentry);
 +			dout("dn %p gets new offset %lld\n", req->r_old_dentry, 
++=======
+ 			/* d_move screws up sibling dentries' offsets */
+ 			ceph_dir_clear_complete(dir);
+ 			ceph_dir_clear_complete(olddir);
+ 
+ 			dout("dn %p gets new offset %lld\n", req->r_old_dentry,
++>>>>>>> 0a8a70f96fe1 (ceph: clear directory's completeness when creating file)
  			     ceph_dentry(req->r_old_dentry)->offset);
  
  			dn = req->r_old_dentry;  /* use old_dentry */
* Unmerged path fs/ceph/dir.c
* Unmerged path fs/ceph/inode.c
diff --git a/fs/ceph/super.h b/fs/ceph/super.h
index adae624ea4fb..fd896860b02e 100644
--- a/fs/ceph/super.h
+++ b/fs/ceph/super.h
@@ -255,7 +255,6 @@ struct ceph_inode_info {
 	struct timespec i_rctime;
 	u64 i_rbytes, i_rfiles, i_rsubdirs;
 	u64 i_files, i_subdirs;
-	u64 i_max_offset;  /* largest readdir offset, set with complete dir */
 
 	struct rb_root i_fragtree;
 	struct mutex i_fragtree_mutex;
