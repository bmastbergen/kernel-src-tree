cpufreq: improve error checking on return values of __cpufreq_governor()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] improve error checking on return values of __cpufreq_governor() (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 93.33%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 3de9bdeb28638e164d1f0eb38dd68e3f5d2ac95c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3de9bdeb.failed

The __cpufreq_governor() function can fail in rare cases especially
if there are bugs in cpufreq drivers.  Thus we must stop processing
as soon as this routine fails, otherwise it may result in undefined
behavior.

This patch adds error checking code whenever this routine is called
from any place.

	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 3de9bdeb28638e164d1f0eb38dd68e3f5d2ac95c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index 7ca34bc0090e,37a687467329..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -874,14 -874,15 +874,24 @@@ static int cpufreq_add_policy_cpu(unsig
  	int ret = 0, has_target = !!cpufreq_driver->target;
  	unsigned long flags;
  
++<<<<<<< HEAD
 +	policy = cpufreq_cpu_get(sibling);
 +	if (WARN_ON_ONCE(!policy))
 +		return -ENODATA;
 +
 +	if (has_target)
 +		__cpufreq_governor(policy, CPUFREQ_GOV_STOP);
++=======
+ 	if (has_target) {
+ 		ret = __cpufreq_governor(policy, CPUFREQ_GOV_STOP);
+ 		if (ret) {
+ 			pr_err("%s: Failed to stop governor\n", __func__);
+ 			return ret;
+ 		}
+ 	}
++>>>>>>> 3de9bdeb2863 (cpufreq: improve error checking on return values of __cpufreq_governor())
  
 -	lock_policy_rwsem_write(policy->cpu);
 +	lock_policy_rwsem_write(sibling);
  
  	write_lock_irqsave(&cpufreq_driver_lock, flags);
  
@@@ -890,16 -891,20 +900,19 @@@
  	per_cpu(cpufreq_cpu_data, cpu) = policy;
  	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
  
 -	unlock_policy_rwsem_write(policy->cpu);
 +	unlock_policy_rwsem_write(sibling);
  
  	if (has_target) {
- 		__cpufreq_governor(policy, CPUFREQ_GOV_START);
- 		__cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
+ 		if ((ret = __cpufreq_governor(policy, CPUFREQ_GOV_START)) ||
+ 			(ret = __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS))) {
+ 			pr_err("%s: Failed to start governor\n", __func__);
+ 			return ret;
+ 		}
  	}
  
 -	/* Don't touch sysfs links during light-weight init */
 -	if (!frozen)
 -		ret = sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");
 +	ret = sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");
  
 +	cpufreq_cpu_put(policy);
  	return ret;
  }
  #endif
@@@ -1107,12 -1177,12 +1120,12 @@@ static int cpufreq_nominate_new_policy_
   * This routine frees the rwsem before returning.
   */
  static int __cpufreq_remove_dev(struct device *dev,
 -				struct subsys_interface *sif, bool frozen)
 +		struct subsys_interface *sif)
  {
  	unsigned int cpu = dev->id, cpus;
- 	int new_cpu;
+ 	int new_cpu, ret;
  	unsigned long flags;
 -	struct cpufreq_policy *policy;
 +	struct cpufreq_policy *data;
  	struct kobject *kobj;
  	struct completion *cmp;
  
@@@ -1130,8 -1204,13 +1143,18 @@@
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	if (cpufreq_driver->target)
 +		__cpufreq_governor(data, CPUFREQ_GOV_STOP);
++=======
+ 	if (cpufreq_driver->target) {
+ 		ret = __cpufreq_governor(policy, CPUFREQ_GOV_STOP);
+ 		if (ret) {
+ 			pr_err("%s: Failed to stop governor\n", __func__);
+ 			return ret;
+ 		}
+ 	}
++>>>>>>> 3de9bdeb2863 (cpufreq: improve error checking on return values of __cpufreq_governor())
  
  #ifdef CONFIG_HOTPLUG_CPU
  	if (!cpufreq_driver->setpolicy)
@@@ -1162,33 -1244,51 +1185,54 @@@
  
  	/* If cpu is last user of policy, free policy */
  	if (cpus == 1) {
++<<<<<<< HEAD
 +		if (cpufreq_driver->target)
 +			__cpufreq_governor(data, CPUFREQ_GOV_POLICY_EXIT);
++=======
+ 		if (cpufreq_driver->target) {
+ 			ret = __cpufreq_governor(policy,
+ 					CPUFREQ_GOV_POLICY_EXIT);
+ 			if (ret) {
+ 				pr_err("%s: Failed to exit governor\n",
+ 						__func__);
+ 				return ret;
+ 			}
+ 	}
++>>>>>>> 3de9bdeb2863 (cpufreq: improve error checking on return values of __cpufreq_governor())
  
 -		if (!frozen) {
 -			lock_policy_rwsem_read(cpu);
 -			kobj = &policy->kobj;
 -			cmp = &policy->kobj_unregister;
 -			unlock_policy_rwsem_read(cpu);
 -			kobject_put(kobj);
 -
 -			/*
 -			 * We need to make sure that the underlying kobj is
 -			 * actually not referenced anymore by anybody before we
 -			 * proceed with unloading.
 -			 */
 -			pr_debug("waiting for dropping of refcount\n");
 -			wait_for_completion(cmp);
 -			pr_debug("wait complete\n");
 -		}
 +		lock_policy_rwsem_read(cpu);
 +		kobj = &data->kobj;
 +		cmp = &data->kobj_unregister;
 +		unlock_policy_rwsem_read(cpu);
 +		kobject_put(kobj);
  
 -		/*
 -		 * Perform the ->exit() even during light-weight tear-down,
 -		 * since this is a core component, and is essential for the
 -		 * subsequent light-weight ->init() to succeed.
 +		/* we need to make sure that the underlying kobj is actually
 +		 * not referenced anymore by anybody before we proceed with
 +		 * unloading.
  		 */
 +		pr_debug("waiting for dropping of refcount\n");
 +		wait_for_completion(cmp);
 +		pr_debug("wait complete\n");
 +
  		if (cpufreq_driver->exit)
 -			cpufreq_driver->exit(policy);
 +			cpufreq_driver->exit(data);
  
 -		if (!frozen)
 -			cpufreq_policy_free(policy);
 +		free_cpumask_var(data->related_cpus);
 +		free_cpumask_var(data->cpus);
 +		kfree(data);
  	} else {
  		if (cpufreq_driver->target) {
++<<<<<<< HEAD
 +			__cpufreq_governor(data, CPUFREQ_GOV_START);
 +			__cpufreq_governor(data, CPUFREQ_GOV_LIMITS);
++=======
+ 			if ((ret = __cpufreq_governor(policy, CPUFREQ_GOV_START)) ||
+ 					(ret = __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS))) {
+ 				pr_err("%s: Failed to start governor\n",
+ 						__func__);
+ 				return ret;
+ 			}
++>>>>>>> 3de9bdeb2863 (cpufreq: improve error checking on return values of __cpufreq_governor())
  		}
  	}
  
@@@ -1840,7 -1936,7 +1884,11 @@@ static int __cpufreq_set_policy(struct 
  			/* might be a policy change, too, so fall through */
  		}
  		pr_debug("governor: change or update limits\n");
++<<<<<<< HEAD
 +		__cpufreq_governor(data, CPUFREQ_GOV_LIMITS);
++=======
+ 		ret = __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
++>>>>>>> 3de9bdeb2863 (cpufreq: improve error checking on return values of __cpufreq_governor())
  	}
  
  error_out:
* Unmerged path drivers/cpufreq/cpufreq.c
