ipv4: add a sock pointer to dst->output() path.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] ipv4: add a sock pointer to dst->output() path (Jiri Pirko) [1081956]
Rebuild_FUZZ: 98.92%
commit-author Eric Dumazet <edumazet@google.com>
commit aad88724c9d54acb1a9737cb6069d8470fa85f74
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/aad88724.failed

In the dst->output() path for ipv4, the code assumes the skb it has to
transmit is attached to an inet socket, specifically via
ip_mc_output() : The sk_mc_loop() test triggers a WARN_ON() when the
provider of the packet is an AF_PACKET socket.

The dst->output() method gets an additional 'struct sock *sk'
parameter. This needs a cascade of changes so that this parameter can
be propagated from vxlan to final consumer.

Fixes: 8f646c922d55 ("vxlan: keep original skb ownership")
	Reported-by: lucien xin <lucien.xin@gmail.com>
	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit aad88724c9d54acb1a9737cb6069d8470fa85f74)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/vxlan.c
#	include/net/dst.h
#	include/net/ip.h
#	include/net/ip_tunnels.h
#	include/net/ipv6.h
#	include/net/xfrm.h
#	net/ipv4/ip_tunnel.c
#	net/ipv4/ip_tunnel_core.c
#	net/ipv6/route.c
#	net/ipv6/sit.c
#	net/openvswitch/vport-gre.c
diff --cc drivers/net/vxlan.c
index 33559a1aa9f1,82355d5d155a..000000000000
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@@ -1645,8 -1755,8 +1645,13 @@@ int vxlan_xmit_skb(struct net *net, str
  	if (err)
  		return err;
  
++<<<<<<< HEAD
 +	return iptunnel_xmit(net, rt, skb, src, dst,
 +			IPPROTO_UDP, tos, ttl, df);
++=======
+ 	return iptunnel_xmit(vs->sock->sk, rt, skb, src, dst, IPPROTO_UDP,
+ 			     tos, ttl, df, false);
++>>>>>>> aad88724c9d5 (ipv4: add a sock pointer to dst->output() path.)
  }
  EXPORT_SYMBOL_GPL(vxlan_xmit_skb);
  
diff --cc include/net/dst.h
index dcb1a26b6671,71c60f42be48..000000000000
--- a/include/net/dst.h
+++ b/include/net/dst.h
@@@ -371,12 -367,15 +371,24 @@@ static inline struct dst_entry *skb_dst
  	return child;
  }
  
++<<<<<<< HEAD
 +extern int dst_discard(struct sk_buff *skb);
 +extern void *dst_alloc(struct dst_ops *ops, struct net_device *dev,
 +		       int initial_ref, int initial_obsolete,
 +		       unsigned short flags);
 +extern void __dst_free(struct dst_entry *dst);
 +extern struct dst_entry *dst_destroy(struct dst_entry *dst);
++=======
+ int dst_discard_sk(struct sock *sk, struct sk_buff *skb);
+ static inline int dst_discard(struct sk_buff *skb)
+ {
+ 	return dst_discard_sk(skb->sk, skb);
+ }
+ void *dst_alloc(struct dst_ops *ops, struct net_device *dev, int initial_ref,
+ 		int initial_obsolete, unsigned short flags);
+ void __dst_free(struct dst_entry *dst);
+ struct dst_entry *dst_destroy(struct dst_entry *dst);
++>>>>>>> aad88724c9d5 (ipv4: add a sock pointer to dst->output() path.)
  
  static inline void dst_free(struct dst_entry *dst)
  {
diff --cc include/net/ip.h
index f7fd2014374f,3ec2b0fb9d83..000000000000
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@@ -96,47 -97,50 +96,94 @@@ extern int		igmp_mc_proc_init(void)
   *	Functions provided by ip.c
   */
  
++<<<<<<< HEAD
 +extern int		ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,
 +					      __be32 saddr, __be32 daddr,
 +					      struct ip_options_rcu *opt);
 +extern int		ip_rcv(struct sk_buff *skb, struct net_device *dev,
 +			       struct packet_type *pt, struct net_device *orig_dev);
 +extern int		ip_local_deliver(struct sk_buff *skb);
 +extern int		ip_mr_input(struct sk_buff *skb);
 +extern int		ip_output(struct sk_buff *skb);
 +extern int		ip_mc_output(struct sk_buff *skb);
 +extern int		ip_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *));
 +extern int		ip_do_nat(struct sk_buff *skb);
 +extern void		ip_send_check(struct iphdr *ip);
 +extern int		__ip_local_out(struct sk_buff *skb);
 +extern int		ip_local_out(struct sk_buff *skb);
 +extern int		ip_queue_xmit(struct sk_buff *skb, struct flowi *fl);
 +extern void		ip_init(void);
 +extern int		ip_append_data(struct sock *sk, struct flowi4 *fl4,
 +				       int getfrag(void *from, char *to, int offset, int len,
 +						   int odd, struct sk_buff *skb),
 +				void *from, int len, int protolen,
 +				struct ipcm_cookie *ipc,
 +				struct rtable **rt,
 +				unsigned int flags);
 +extern int		ip_generic_getfrag(void *from, char *to, int offset, int len, int odd, struct sk_buff *skb);
 +extern ssize_t		ip_append_page(struct sock *sk, struct flowi4 *fl4, struct page *page,
 +				int offset, size_t size, int flags);
 +extern struct sk_buff  *__ip_make_skb(struct sock *sk,
 +				      struct flowi4 *fl4,
 +				      struct sk_buff_head *queue,
 +				      struct inet_cork *cork);
 +extern int		ip_send_skb(struct net *net, struct sk_buff *skb);
 +extern int		ip_push_pending_frames(struct sock *sk, struct flowi4 *fl4);
 +extern void		ip_flush_pending_frames(struct sock *sk);
 +extern struct sk_buff  *ip_make_skb(struct sock *sk,
 +				    struct flowi4 *fl4,
 +				    int getfrag(void *from, char *to, int offset, int len,
 +						int odd, struct sk_buff *skb),
 +				    void *from, int length, int transhdrlen,
 +				    struct ipcm_cookie *ipc,
 +				    struct rtable **rtp,
 +				    unsigned int flags);
++=======
+ int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,
+ 			  __be32 saddr, __be32 daddr,
+ 			  struct ip_options_rcu *opt);
+ int ip_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt,
+ 	   struct net_device *orig_dev);
+ int ip_local_deliver(struct sk_buff *skb);
+ int ip_mr_input(struct sk_buff *skb);
+ int ip_output(struct sock *sk, struct sk_buff *skb);
+ int ip_mc_output(struct sock *sk, struct sk_buff *skb);
+ int ip_fragment(struct sk_buff *skb, int (*output)(struct sk_buff *));
+ int ip_do_nat(struct sk_buff *skb);
+ void ip_send_check(struct iphdr *ip);
+ int __ip_local_out(struct sk_buff *skb);
+ int ip_local_out_sk(struct sock *sk, struct sk_buff *skb);
+ static inline int ip_local_out(struct sk_buff *skb)
+ {
+ 	return ip_local_out_sk(skb->sk, skb);
+ }
+ 
+ int ip_queue_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl);
+ void ip_init(void);
+ int ip_append_data(struct sock *sk, struct flowi4 *fl4,
+ 		   int getfrag(void *from, char *to, int offset, int len,
+ 			       int odd, struct sk_buff *skb),
+ 		   void *from, int len, int protolen,
+ 		   struct ipcm_cookie *ipc,
+ 		   struct rtable **rt,
+ 		   unsigned int flags);
+ int ip_generic_getfrag(void *from, char *to, int offset, int len, int odd,
+ 		       struct sk_buff *skb);
+ ssize_t ip_append_page(struct sock *sk, struct flowi4 *fl4, struct page *page,
+ 		       int offset, size_t size, int flags);
+ struct sk_buff *__ip_make_skb(struct sock *sk, struct flowi4 *fl4,
+ 			      struct sk_buff_head *queue,
+ 			      struct inet_cork *cork);
+ int ip_send_skb(struct net *net, struct sk_buff *skb);
+ int ip_push_pending_frames(struct sock *sk, struct flowi4 *fl4);
+ void ip_flush_pending_frames(struct sock *sk);
+ struct sk_buff *ip_make_skb(struct sock *sk, struct flowi4 *fl4,
+ 			    int getfrag(void *from, char *to, int offset,
+ 					int len, int odd, struct sk_buff *skb),
+ 			    void *from, int length, int transhdrlen,
+ 			    struct ipcm_cookie *ipc, struct rtable **rtp,
+ 			    unsigned int flags);
++>>>>>>> aad88724c9d5 (ipv4: add a sock pointer to dst->output() path.)
  
  static inline struct sk_buff *ip_finish_skb(struct sock *sk, struct flowi4 *fl4)
  {
diff --cc include/net/ip_tunnels.h
index 8f3d6c1c1802,a4daf9eb8562..000000000000
--- a/include/net/ip_tunnels.h
+++ b/include/net/ip_tunnels.h
@@@ -156,10 -153,9 +156,14 @@@ static inline u8 ip_tunnel_ecn_encap(u
  }
  
  int iptunnel_pull_header(struct sk_buff *skb, int hdr_len, __be16 inner_proto);
++<<<<<<< HEAD
 +int iptunnel_xmit(struct net *net, struct rtable *rt,
 +		  struct sk_buff *skb,
++=======
+ int iptunnel_xmit(struct sock *sk, struct rtable *rt, struct sk_buff *skb,
++>>>>>>> aad88724c9d5 (ipv4: add a sock pointer to dst->output() path.)
  		  __be32 src, __be32 dst, __u8 proto,
 -		  __u8 tos, __u8 ttl, __be16 df, bool xnet);
 +		  __u8 tos, __u8 ttl, __be16 df);
  
  struct sk_buff *iptunnel_handle_offloads(struct sk_buff *skb, bool gre_csum,
  					 int gso_type_mask);
diff --cc include/net/ipv6.h
index face22bfd545,d640925bc454..000000000000
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@@ -729,13 -731,13 +729,20 @@@ extern struct dst_entry *	ip6_blackhole
   *	skb processing functions
   */
  
++<<<<<<< HEAD
 +extern int			ip6_output(struct sk_buff *skb);
 +extern int			ip6_forward(struct sk_buff *skb);
 +extern int			ip6_input(struct sk_buff *skb);
 +extern int			ip6_mc_input(struct sk_buff *skb);
++=======
+ int ip6_output(struct sock *sk, struct sk_buff *skb);
+ int ip6_forward(struct sk_buff *skb);
+ int ip6_input(struct sk_buff *skb);
+ int ip6_mc_input(struct sk_buff *skb);
++>>>>>>> aad88724c9d5 (ipv4: add a sock pointer to dst->output() path.)
  
 -int __ip6_local_out(struct sk_buff *skb);
 -int ip6_local_out(struct sk_buff *skb);
 +extern int			__ip6_local_out(struct sk_buff *skb);
 +extern int			ip6_local_out(struct sk_buff *skb);
  
  /*
   *	Extension header (options) processing
diff --cc include/net/xfrm.h
index 5451c688530a,116e9c7e19cb..000000000000
--- a/include/net/xfrm.h
+++ b/include/net/xfrm.h
@@@ -1492,38 -1532,48 +1492,72 @@@ extern int xfrm4_rcv(struct sk_buff *sk
  
  static inline int xfrm4_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi)
  {
 -	XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;
 -	XFRM_SPI_SKB_CB(skb)->family = AF_INET;
 -	XFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);
 -	return xfrm_input(skb, nexthdr, spi, 0);
 -}
 -
 +	return xfrm4_rcv_encap(skb, nexthdr, spi, 0);
 +}
 +
++<<<<<<< HEAD
 +extern int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm4_output(struct sk_buff *skb);
 +extern int xfrm4_output_finish(struct sk_buff *skb);
 +extern int xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family);
 +extern int xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family);
 +extern int xfrm4_mode_tunnel_input_register(struct xfrm_tunnel_notifier *handler);
 +extern int xfrm4_mode_tunnel_input_deregister(struct xfrm_tunnel_notifier *handler);
 +extern int xfrm6_extract_header(struct sk_buff *skb);
 +extern int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi);
 +extern int xfrm6_transport_finish(struct sk_buff *skb, int async);
 +extern int xfrm6_rcv(struct sk_buff *skb);
 +extern int xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,
 +			    xfrm_address_t *saddr, u8 proto);
 +extern int xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family);
 +extern int xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler, unsigned short family);
 +extern __be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr);
 +extern __be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr);
 +extern int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
 +extern int xfrm6_output(struct sk_buff *skb);
 +extern int xfrm6_output_finish(struct sk_buff *skb);
 +extern int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
 +				 u8 **prevhdr);
++=======
+ int xfrm4_extract_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm4_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm4_output(struct sock *sk, struct sk_buff *skb);
+ int xfrm4_output_finish(struct sk_buff *skb);
+ int xfrm4_rcv_cb(struct sk_buff *skb, u8 protocol, int err);
+ int xfrm4_protocol_register(struct xfrm4_protocol *handler, unsigned char protocol);
+ int xfrm4_protocol_deregister(struct xfrm4_protocol *handler, unsigned char protocol);
+ int xfrm4_tunnel_register(struct xfrm_tunnel *handler, unsigned short family);
+ int xfrm4_tunnel_deregister(struct xfrm_tunnel *handler, unsigned short family);
+ void xfrm4_local_error(struct sk_buff *skb, u32 mtu);
+ int xfrm6_extract_header(struct sk_buff *skb);
+ int xfrm6_extract_input(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm6_rcv_spi(struct sk_buff *skb, int nexthdr, __be32 spi);
+ int xfrm6_transport_finish(struct sk_buff *skb, int async);
+ int xfrm6_rcv(struct sk_buff *skb);
+ int xfrm6_input_addr(struct sk_buff *skb, xfrm_address_t *daddr,
+ 		     xfrm_address_t *saddr, u8 proto);
+ void xfrm6_local_error(struct sk_buff *skb, u32 mtu);
+ int xfrm6_rcv_cb(struct sk_buff *skb, u8 protocol, int err);
+ int xfrm6_protocol_register(struct xfrm6_protocol *handler, unsigned char protocol);
+ int xfrm6_protocol_deregister(struct xfrm6_protocol *handler, unsigned char protocol);
+ int xfrm6_tunnel_register(struct xfrm6_tunnel *handler, unsigned short family);
+ int xfrm6_tunnel_deregister(struct xfrm6_tunnel *handler, unsigned short family);
+ __be32 xfrm6_tunnel_alloc_spi(struct net *net, xfrm_address_t *saddr);
+ __be32 xfrm6_tunnel_spi_lookup(struct net *net, const xfrm_address_t *saddr);
+ int xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb);
+ int xfrm6_output(struct sock *sk, struct sk_buff *skb);
+ int xfrm6_output_finish(struct sk_buff *skb);
+ int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,
+ 			  u8 **prevhdr);
++>>>>>>> aad88724c9d5 (ipv4: add a sock pointer to dst->output() path.)
  
  #ifdef CONFIG_XFRM
 -int xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);
 -int xfrm_user_policy(struct sock *sk, int optname,
 -		     u8 __user *optval, int optlen);
 +extern int xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb);
 +extern int xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen);
  #else
  static inline int xfrm_user_policy(struct sock *sk, int optname, u8 __user *optval, int optlen)
  {
diff --cc net/ipv4/ip_tunnel.c
index 26bb30d12002,484d0ce27ef7..000000000000
--- a/net/ipv4/ip_tunnel.c
+++ b/net/ipv4/ip_tunnel.c
@@@ -646,18 -661,17 +646,23 @@@ void ip_tunnel_xmit(struct sk_buff *skb
  
  	max_headroom = LL_RESERVED_SPACE(rt->dst.dev) + sizeof(struct iphdr)
  			+ rt->dst.header_len;
 -	if (max_headroom > dev->needed_headroom)
 +	if (max_headroom > dev->needed_headroom) {
  		dev->needed_headroom = max_headroom;
 -
 -	if (skb_cow_head(skb, dev->needed_headroom)) {
 -		dev->stats.tx_dropped++;
 -		kfree_skb(skb);
 -		return;
 +		if (skb_cow_head(skb, dev->needed_headroom)) {
 +			dev->stats.tx_dropped++;
 +			dev_kfree_skb(skb);
 +			return;
 +		}
  	}
  
++<<<<<<< HEAD
 +	err = iptunnel_xmit(dev_net(dev), rt, skb,
 +			    fl4.saddr, fl4.daddr, protocol,
 +			    ip_tunnel_ecn_encap(tos, inner_iph, skb), ttl, df);
++=======
+ 	err = iptunnel_xmit(skb->sk, rt, skb, fl4.saddr, fl4.daddr, protocol,
+ 			    tos, ttl, df, !net_eq(tunnel->net, dev_net(dev)));
++>>>>>>> aad88724c9d5 (ipv4: add a sock pointer to dst->output() path.)
  	iptunnel_xmit_stats(err, &dev->stats, dev->tstats);
  
  	return;
diff --cc net/ipv4/ip_tunnel_core.c
index 88e0d3412e71,bcf206c79005..000000000000
--- a/net/ipv4/ip_tunnel_core.c
+++ b/net/ipv4/ip_tunnel_core.c
@@@ -46,10 -46,9 +46,14 @@@
  #include <net/netns/generic.h>
  #include <net/rtnetlink.h>
  
++<<<<<<< HEAD
 +int iptunnel_xmit(struct net *net, struct rtable *rt,
 +		  struct sk_buff *skb,
++=======
+ int iptunnel_xmit(struct sock *sk, struct rtable *rt, struct sk_buff *skb,
++>>>>>>> aad88724c9d5 (ipv4: add a sock pointer to dst->output() path.)
  		  __be32 src, __be32 dst, __u8 proto,
 -		  __u8 tos, __u8 ttl, __be16 df, bool xnet)
 +		  __u8 tos, __u8 ttl, __be16 df)
  {
  	int pkt_len = skb->len;
  	struct iphdr *iph;
diff --cc net/ipv6/route.c
index b0c3ed9cd865,4011617cca68..000000000000
--- a/net/ipv6/route.c
+++ b/net/ipv6/route.c
@@@ -84,7 -84,9 +84,13 @@@ static void		ip6_dst_ifdown(struct dst_
  static int		 ip6_dst_gc(struct dst_ops *ops);
  
  static int		ip6_pkt_discard(struct sk_buff *skb);
++<<<<<<< HEAD
 +static int		ip6_pkt_discard_out(struct sk_buff *skb);
++=======
+ static int		ip6_pkt_discard_out(struct sock *sk, struct sk_buff *skb);
+ static int		ip6_pkt_prohibit(struct sk_buff *skb);
+ static int		ip6_pkt_prohibit_out(struct sock *sk, struct sk_buff *skb);
++>>>>>>> aad88724c9d5 (ipv4: add a sock pointer to dst->output() path.)
  static void		ip6_link_failure(struct sk_buff *skb);
  static void		ip6_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,
  					   struct sk_buff *skb, u32 mtu);
@@@ -1579,6 -1577,8 +1585,11 @@@ int ip6_route_add(struct fib6_config *c
  		switch (cfg->fc_type) {
  		case RTN_BLACKHOLE:
  			rt->dst.error = -EINVAL;
++<<<<<<< HEAD
++=======
+ 			rt->dst.output = dst_discard_sk;
+ 			rt->dst.input = dst_discard;
++>>>>>>> aad88724c9d5 (ipv4: add a sock pointer to dst->output() path.)
  			break;
  		case RTN_PROHIBIT:
  			rt->dst.error = -EACCES;
diff --cc net/ipv6/sit.c
index aff21b3145f9,8da8268d65f8..000000000000
--- a/net/ipv6/sit.c
+++ b/net/ipv6/sit.c
@@@ -892,8 -974,9 +892,14 @@@ static netdev_tx_t ipip6_tunnel_xmit(st
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	err = iptunnel_xmit(dev_net(dev), rt, skb, fl4.saddr, fl4.daddr,
 +			    IPPROTO_IPV6, tos, ttl, df);
++=======
+ 	err = iptunnel_xmit(skb->sk, rt, skb, fl4.saddr, fl4.daddr,
+ 			    IPPROTO_IPV6, tos, ttl, df,
+ 			    !net_eq(tunnel->net, dev_net(dev)));
++>>>>>>> aad88724c9d5 (ipv4: add a sock pointer to dst->output() path.)
  	iptunnel_xmit_stats(err, &dev->stats, dev->tstats);
  	return NETDEV_TX_OK;
  
diff --cc net/openvswitch/vport-gre.c
index 98c14288f964,ebb6e2442554..000000000000
--- a/net/openvswitch/vport-gre.c
+++ b/net/openvswitch/vport-gre.c
@@@ -175,10 -174,10 +175,14 @@@ static int gre_tnl_send(struct vport *v
  
  	skb->local_df = 1;
  
++<<<<<<< HEAD
 +	return iptunnel_xmit(net, rt, skb, fl.saddr,
++=======
+ 	return iptunnel_xmit(skb->sk, rt, skb, fl.saddr,
++>>>>>>> aad88724c9d5 (ipv4: add a sock pointer to dst->output() path.)
  			     OVS_CB(skb)->tun_key->ipv4_dst, IPPROTO_GRE,
  			     OVS_CB(skb)->tun_key->ipv4_tos,
 -			     OVS_CB(skb)->tun_key->ipv4_ttl, df, false);
 +			     OVS_CB(skb)->tun_key->ipv4_ttl, df);
  err_free_rt:
  	ip_rt_put(rt);
  error:
* Unmerged path drivers/net/vxlan.c
* Unmerged path include/net/dst.h
* Unmerged path include/net/ip.h
* Unmerged path include/net/ip_tunnels.h
* Unmerged path include/net/ipv6.h
* Unmerged path include/net/xfrm.h
diff --git a/net/core/dst.c b/net/core/dst.c
index df9cc810ec8e..6e3f8cbdf21c 100644
--- a/net/core/dst.c
+++ b/net/core/dst.c
@@ -142,12 +142,12 @@ loop:
 	mutex_unlock(&dst_gc_mutex);
 }
 
-int dst_discard(struct sk_buff *skb)
+int dst_discard_sk(struct sock *sk, struct sk_buff *skb)
 {
 	kfree_skb(skb);
 	return 0;
 }
-EXPORT_SYMBOL(dst_discard);
+EXPORT_SYMBOL(dst_discard_sk);
 
 const u32 dst_default_metrics[RTAX_MAX + 1] = {
 	/* This initializer is needed to force linker to place this variable
@@ -184,7 +184,7 @@ void *dst_alloc(struct dst_ops *ops, struct net_device *dev,
 	dst->xfrm = NULL;
 #endif
 	dst->input = dst_discard;
-	dst->output = dst_discard;
+	dst->output = dst_discard_sk;
 	dst->error = 0;
 	dst->obsolete = initial_obsolete;
 	dst->header_len = 0;
@@ -209,8 +209,10 @@ static void ___dst_free(struct dst_entry *dst)
 	/* The first case (dev==NULL) is required, when
 	   protocol module is unloaded.
 	 */
-	if (dst->dev == NULL || !(dst->dev->flags&IFF_UP))
-		dst->input = dst->output = dst_discard;
+	if (dst->dev == NULL || !(dst->dev->flags&IFF_UP)) {
+		dst->input = dst_discard;
+		dst->output = dst_discard_sk;
+	}
 	dst->obsolete = DST_OBSOLETE_DEAD;
 }
 
@@ -361,7 +363,8 @@ static void dst_ifdown(struct dst_entry *dst, struct net_device *dev,
 		return;
 
 	if (!unregister) {
-		dst->input = dst->output = dst_discard;
+		dst->input = dst_discard;
+		dst->output = dst_discard_sk;
 	} else {
 		dst->dev = dev_net(dst->dev)->loopback_dev;
 		dev_hold(dst->dev);
diff --git a/net/decnet/dn_route.c b/net/decnet/dn_route.c
index fe32388ea24f..4cea10115f2e 100644
--- a/net/decnet/dn_route.c
+++ b/net/decnet/dn_route.c
@@ -752,7 +752,7 @@ static int dn_to_neigh_output(struct sk_buff *skb)
 	return n->output(n, skb);
 }
 
-static int dn_output(struct sk_buff *skb)
+static int dn_output(struct sock *sk, struct sk_buff *skb)
 {
 	struct dst_entry *dst = skb_dst(skb);
 	struct dn_route *rt = (struct dn_route *)dst;
@@ -838,6 +838,18 @@ drop:
  * Used to catch bugs. This should never normally get
  * called.
  */
+static int dn_rt_bug_sk(struct sock *sk, struct sk_buff *skb)
+{
+	struct dn_skb_cb *cb = DN_SKB_CB(skb);
+
+	net_dbg_ratelimited("dn_rt_bug: skb from:%04x to:%04x\n",
+			    le16_to_cpu(cb->src), le16_to_cpu(cb->dst));
+
+	kfree_skb(skb);
+
+	return NET_RX_DROP;
+}
+
 static int dn_rt_bug(struct sk_buff *skb)
 {
 	struct dn_skb_cb *cb = DN_SKB_CB(skb);
@@ -1465,7 +1477,7 @@ make_route:
 
 	rt->n = neigh;
 	rt->dst.lastuse = jiffies;
-	rt->dst.output = dn_rt_bug;
+	rt->dst.output = dn_rt_bug_sk;
 	switch (res.type) {
 	case RTN_UNICAST:
 		rt->dst.input = dn_forward;
diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c
index b29ba5853083..6fccf3691ef9 100644
--- a/net/ipv4/ip_output.c
+++ b/net/ipv4/ip_output.c
@@ -101,17 +101,17 @@ int __ip_local_out(struct sk_buff *skb)
 		       skb_dst(skb)->dev, dst_output);
 }
 
-int ip_local_out(struct sk_buff *skb)
+int ip_local_out_sk(struct sock *sk, struct sk_buff *skb)
 {
 	int err;
 
 	err = __ip_local_out(skb);
 	if (likely(err == 1))
-		err = dst_output(skb);
+		err = dst_output_sk(sk, skb);
 
 	return err;
 }
-EXPORT_SYMBOL_GPL(ip_local_out);
+EXPORT_SYMBOL_GPL(ip_local_out_sk);
 
 static inline int ip_select_ttl(struct inet_sock *inet, struct dst_entry *dst)
 {
@@ -234,9 +234,8 @@ static int ip_finish_output(struct sk_buff *skb)
 		return ip_finish_output2(skb);
 }
 
-int ip_mc_output(struct sk_buff *skb)
+int ip_mc_output(struct sock *sk, struct sk_buff *skb)
 {
-	struct sock *sk = skb->sk;
 	struct rtable *rt = skb_rtable(skb);
 	struct net_device *dev = rt->dst.dev;
 
@@ -295,7 +294,7 @@ int ip_mc_output(struct sk_buff *skb)
 			    !(IPCB(skb)->flags & IPSKB_REROUTED));
 }
 
-int ip_output(struct sk_buff *skb)
+int ip_output(struct sock *sk, struct sk_buff *skb)
 {
 	struct net_device *dev = skb_dst(skb)->dev;
 
* Unmerged path net/ipv4/ip_tunnel.c
* Unmerged path net/ipv4/ip_tunnel_core.c
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index 29976f7af6c1..d9f68b256547 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -1088,7 +1088,7 @@ static void ipv4_link_failure(struct sk_buff *skb)
 		dst_set_expires(&rt->dst, 0);
 }
 
-static int ip_rt_bug(struct sk_buff *skb)
+static int ip_rt_bug(struct sock *sk, struct sk_buff *skb)
 {
 	pr_debug("%s: %pI4 -> %pI4, %s\n",
 		 __func__, &ip_hdr(skb)->saddr, &ip_hdr(skb)->daddr,
@@ -2167,7 +2167,7 @@ struct dst_entry *ipv4_blackhole_route(struct net *net, struct dst_entry *dst_or
 
 		new->__use = 1;
 		new->input = dst_discard;
-		new->output = dst_discard;
+		new->output = dst_discard_sk;
 
 		new->dev = ort->dst.dev;
 		if (new->dev)
diff --git a/net/ipv4/xfrm4_output.c b/net/ipv4/xfrm4_output.c
index 327a617d594c..67227615f25b 100644
--- a/net/ipv4/xfrm4_output.c
+++ b/net/ipv4/xfrm4_output.c
@@ -89,7 +89,7 @@ int xfrm4_output_finish(struct sk_buff *skb)
 	return xfrm_output(skb);
 }
 
-int xfrm4_output(struct sk_buff *skb)
+int xfrm4_output(struct sock *sk, struct sk_buff *skb)
 {
 	struct dst_entry *dst = skb_dst(skb);
 	struct xfrm_state *x = dst->xfrm;
diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c
index 67265a1c5199..98aaa880739c 100644
--- a/net/ipv6/ip6_output.c
+++ b/net/ipv6/ip6_output.c
@@ -132,7 +132,7 @@ static int ip6_finish_output(struct sk_buff *skb)
 		return ip6_finish_output2(skb);
 }
 
-int ip6_output(struct sk_buff *skb)
+int ip6_output(struct sock *sk, struct sk_buff *skb)
 {
 	struct net_device *dev = skb_dst(skb)->dev;
 	struct inet6_dev *idev = ip6_dst_idev(skb_dst(skb));
* Unmerged path net/ipv6/route.c
* Unmerged path net/ipv6/sit.c
diff --git a/net/ipv6/xfrm6_output.c b/net/ipv6/xfrm6_output.c
index 8755a3079d0f..2066d2bf9480 100644
--- a/net/ipv6/xfrm6_output.c
+++ b/net/ipv6/xfrm6_output.c
@@ -154,7 +154,7 @@ static int __xfrm6_output(struct sk_buff *skb)
 	return x->outer_mode->afinfo->output_finish(skb);
 }
 
-int xfrm6_output(struct sk_buff *skb)
+int xfrm6_output(struct sock *sk, struct sk_buff *skb)
 {
 	return NF_HOOK(NFPROTO_IPV6, NF_INET_POST_ROUTING, skb, NULL,
 		       skb_dst(skb)->dev, __xfrm6_output);
* Unmerged path net/openvswitch/vport-gre.c
diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c
index 22e58f3502d3..5b1af27164c2 100644
--- a/net/xfrm/xfrm_policy.c
+++ b/net/xfrm/xfrm_policy.c
@@ -1820,7 +1820,7 @@ purge_queue:
 	xfrm_queue_purge(&pq->hold_queue);
 }
 
-static int xdst_queue_output(struct sk_buff *skb)
+static int xdst_queue_output(struct sock *sk, struct sk_buff *skb)
 {
 	unsigned long sched_next;
 	struct dst_entry *dst = skb_dst(skb);
