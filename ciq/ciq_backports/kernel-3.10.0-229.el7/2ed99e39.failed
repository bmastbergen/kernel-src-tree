cpufreq: Skip current frequency initialization for ->setpolicy drivers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Skip current frequency initialization for ->setpolicy drivers (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 93.13%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 2ed99e39cb9392312c100d9da591c20641c64d12
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2ed99e39.failed

After commit da60ce9f2fac (cpufreq: call cpufreq_driver->get() after
calling ->init()) __cpufreq_add_dev() sometimes fails for CPUs handled
by intel_pstate, because that driver may return 0 from its ->get()
callback if it has not run long enough to collect enough samples on the
given CPU.  That didn't happen before commit da60ce9f2fac which added
policy->cur initialization to __cpufreq_add_dev() to help reduce code
duplication in other cpufreq drivers.

However, the code added by commit da60ce9f2fac need not be executed
for cpufreq drivers having the ->setpolicy callback defined, because
the subsequent invocation of cpufreq_set_policy() will use that
callback to initialize the policy anyway and it doesn't need
policy->cur to be initialized upfront.  The analogous code in
cpufreq_update_policy() is also unnecessary for cpufreq drivers
having ->setpolicy set and may be skipped for them as well.

Since intel_pstate provides ->setpolicy, skipping the upfront
policy->cur initialization for cpufreq drivers with that callback
set will cover intel_pstate and the problem it's been having after
commit da60ce9f2fac will be addressed.

Fixes: da60ce9f2fac (cpufreq: call cpufreq_driver->get() after calling ->init())
References: https://bugzilla.kernel.org/show_bug.cgi?id=71931
Reported-and-tested-by: Patrik Lundquist <patrik.lundquist@gmail.com>
	Acked-by: Dirk Brandewie <dirk.j.brandewie@intel.com>
	Cc: 3.13+ <stable@vger.kernel.org> # 3.13+
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 2ed99e39cb9392312c100d9da591c20641c64d12)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index c8bc717e8458,199b52b7c3e1..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -993,7 -1109,27 +993,31 @@@ static int cpufreq_add_dev(struct devic
  		goto err_set_policy_cpu;
  	}
  
++<<<<<<< HEAD
 +	if (cpufreq_driver->get) {
++=======
+ 	/* related cpus should atleast have policy->cpus */
+ 	cpumask_or(policy->related_cpus, policy->related_cpus, policy->cpus);
+ 
+ 	/*
+ 	 * affected cpus must always be the one, which are online. We aren't
+ 	 * managing offline cpus here.
+ 	 */
+ 	cpumask_and(policy->cpus, policy->cpus, cpu_online_mask);
+ 
+ 	if (!frozen) {
+ 		policy->user_policy.min = policy->min;
+ 		policy->user_policy.max = policy->max;
+ 	}
+ 
+ 	down_write(&policy->rwsem);
+ 	write_lock_irqsave(&cpufreq_driver_lock, flags);
+ 	for_each_cpu(j, policy->cpus)
+ 		per_cpu(cpufreq_cpu_data, j) = policy;
+ 	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
+ 
+ 	if (cpufreq_driver->get && !cpufreq_driver->setpolicy) {
++>>>>>>> 2ed99e39cb93 (cpufreq: Skip current frequency initialization for ->setpolicy drivers)
  		policy->cur = cpufreq_driver->get(policy->cpu);
  		if (!policy->cur) {
  			pr_err("%s: ->get() failed\n", __func__);
@@@ -1936,15 -2143,15 +1960,21 @@@ int cpufreq_update_policy(unsigned int 
  	 * BIOS might change freq behind our back
  	 * -> ask driver for current freq and notify governors about a change
  	 */
++<<<<<<< HEAD
 +	if (cpufreq_driver->get) {
 +		policy.cur = cpufreq_driver->get(cpu);
 +		if (!data->cur) {
++=======
+ 	if (cpufreq_driver->get && !cpufreq_driver->setpolicy) {
+ 		new_policy.cur = cpufreq_driver->get(cpu);
+ 		if (!policy->cur) {
++>>>>>>> 2ed99e39cb93 (cpufreq: Skip current frequency initialization for ->setpolicy drivers)
  			pr_debug("Driver did not initialize current freq");
 -			policy->cur = new_policy.cur;
 +			data->cur = policy.cur;
  		} else {
 -			if (policy->cur != new_policy.cur && has_target())
 -				cpufreq_out_of_sync(cpu, policy->cur,
 -								new_policy.cur);
 +			if (data->cur != policy.cur && cpufreq_driver->target)
 +				cpufreq_out_of_sync(cpu, data->cur,
 +								policy.cur);
  		}
  	}
  
* Unmerged path drivers/cpufreq/cpufreq.c
