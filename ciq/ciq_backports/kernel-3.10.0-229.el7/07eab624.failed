lpfc: Fix locking for postbufq when freeing

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [scsi] lpfc 10.2.8000.0: Fix locking for postbufq when freeing (Rob Evers) [1088574]
Rebuild_FUZZ: 87.76%
commit-author James Smart <james.smart@emulex.com>
commit 07eab624e5cf471450ed7b8c4ba8521e910dc9cf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/07eab624.failed

Fix locking for postbufq when freeing

	Signed-off-by: James Smart <james.smart@emulex.com>
Reviewed-By: Dick Kennedy <dick.kennedy@emulex.com>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
(cherry picked from commit 07eab624e5cf471450ed7b8c4ba8521e910dc9cf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/lpfc/lpfc_init.c
diff --cc drivers/scsi/lpfc/lpfc_init.c
index 48a96e7338cc,512f91ed5d25..000000000000
--- a/drivers/scsi/lpfc/lpfc_init.c
+++ b/drivers/scsi/lpfc/lpfc_init.c
@@@ -820,7 -820,94 +820,96 @@@ lpfc_hba_down_prep(struct lpfc_hba *phb
  }
  
  /**
++<<<<<<< HEAD
++=======
+  * lpfc_hba_free_post_buf - Perform lpfc uninitialization after HBA reset
+  * @phba: pointer to lpfc HBA data structure.
+  *
+  * This routine will cleanup posted ELS buffers after the HBA is reset
+  * when bringing down the SLI Layer.
+  *
+  *
+  * Return codes
+  *   void.
+  **/
+ static void
+ lpfc_hba_free_post_buf(struct lpfc_hba *phba)
+ {
+ 	struct lpfc_sli *psli = &phba->sli;
+ 	struct lpfc_sli_ring *pring;
+ 	struct lpfc_dmabuf *mp, *next_mp;
+ 	LIST_HEAD(buflist);
+ 	int count;
+ 
+ 	if (phba->sli3_options & LPFC_SLI3_HBQ_ENABLED)
+ 		lpfc_sli_hbqbuf_free_all(phba);
+ 	else {
+ 		/* Cleanup preposted buffers on the ELS ring */
+ 		pring = &psli->ring[LPFC_ELS_RING];
+ 		spin_lock_irq(&phba->hbalock);
+ 		list_splice_init(&pring->postbufq, &buflist);
+ 		spin_unlock_irq(&phba->hbalock);
+ 
+ 		count = 0;
+ 		list_for_each_entry_safe(mp, next_mp, &buflist, list) {
+ 			list_del(&mp->list);
+ 			count++;
+ 			lpfc_mbuf_free(phba, mp->virt, mp->phys);
+ 			kfree(mp);
+ 		}
+ 
+ 		spin_lock_irq(&phba->hbalock);
+ 		pring->postbufq_cnt -= count;
+ 		spin_unlock_irq(&phba->hbalock);
+ 	}
+ }
+ 
+ /**
+  * lpfc_hba_clean_txcmplq - Perform lpfc uninitialization after HBA reset
+  * @phba: pointer to lpfc HBA data structure.
+  *
+  * This routine will cleanup the txcmplq after the HBA is reset when bringing
+  * down the SLI Layer.
+  *
+  * Return codes
+  *   void
+  **/
+ static void
+ lpfc_hba_clean_txcmplq(struct lpfc_hba *phba)
+ {
+ 	struct lpfc_sli *psli = &phba->sli;
+ 	struct lpfc_sli_ring *pring;
+ 	LIST_HEAD(completions);
+ 	int i;
+ 
+ 
+ 
+ 	for (i = 0; i < psli->num_rings; i++) {
+ 		pring = &psli->ring[i];
+ 		if (phba->sli_rev >= LPFC_SLI_REV4)
+ 			spin_lock_irq(&pring->ring_lock);
+ 		else
+ 			spin_lock_irq(&phba->hbalock);
+ 		/* At this point in time the HBA is either reset or DOA. Either
+ 		 * way, nothing should be on txcmplq as it will NEVER complete.
+ 		 */
+ 		list_splice_init(&pring->txcmplq, &completions);
+ 
+ 		if (phba->sli_rev >= LPFC_SLI_REV4)
+ 			spin_unlock_irq(&pring->ring_lock);
+ 		else
+ 			spin_unlock_irq(&phba->hbalock);
+ 
+ 		/* Cancel all the IOCBs from the completions list */
+ 		lpfc_sli_cancel_iocbs(phba, &completions, IOSTAT_LOCAL_REJECT,
+ 				      IOERR_SLI_ABORTED);
+ 		lpfc_sli_abort_iocb_ring(phba, pring);
+ 	}
+ }
+ 
+ /**
++>>>>>>> 07eab624e5cf (lpfc: Fix locking for postbufq when freeing)
   * lpfc_hba_down_post_s3 - Perform lpfc uninitialization after HBA reset
 -	int i;
   * @phba: pointer to lpfc HBA data structure.
   *
   * This routine will do uninitialization after the HBA is reset when bring
* Unmerged path drivers/scsi/lpfc/lpfc_init.c
