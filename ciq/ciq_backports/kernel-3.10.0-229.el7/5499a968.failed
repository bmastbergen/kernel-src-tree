igb: fix last_rx_timestamp usage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Jakub Kicinski <kubakici@wp.pl>
commit 5499a968d49f22ef166a360ffd74364bfb7233d6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5499a968.failed

last_rx_timestamp should be updated only when rx time stamp is
read. Also it's only used with NICs that have per-interface time
stamping resources so it can be moved to adapter structure and
set in igb_ptp_rx_rgtstamp().

	Signed-off-by: Jakub Kicinski <kubakici@wp.pl>
	Acked-by: Matthew Vick <matthew.vick@intel.com>
	Tested-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
(cherry picked from commit 5499a968d49f22ef166a360ffd74364bfb7233d6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/igb/igb.h
diff --cc drivers/net/ethernet/intel/igb/igb.h
index 7efb87caea4a,27130065d92a..000000000000
--- a/drivers/net/ethernet/intel/igb/igb.h
+++ b/drivers/net/ethernet/intel/igb/igb.h
@@@ -429,8 -433,10 +428,9 @@@ struct igb_adapter 
  	struct delayed_work ptp_overflow_work;
  	struct work_struct ptp_tx_work;
  	struct sk_buff *ptp_tx_skb;
 -	struct hwtstamp_config tstamp_config;
  	unsigned long ptp_tx_start;
  	unsigned long last_rx_ptp_check;
+ 	unsigned long last_rx_timestamp;
  	spinlock_t tmreg_lock;
  	struct cyclecounter cc;
  	struct timecounter tc;
@@@ -494,59 -503,41 +494,94 @@@ enum igb_boards 
  extern char igb_driver_name[];
  extern char igb_driver_version[];
  
++<<<<<<< HEAD
 +extern int igb_up(struct igb_adapter *);
 +extern void igb_down(struct igb_adapter *);
 +extern void igb_reinit_locked(struct igb_adapter *);
 +extern void igb_reset(struct igb_adapter *);
 +extern void igb_write_rss_indir_tbl(struct igb_adapter *);
 +extern int igb_set_spd_dplx(struct igb_adapter *, u32, u8);
 +extern int igb_setup_tx_resources(struct igb_ring *);
 +extern int igb_setup_rx_resources(struct igb_ring *);
 +extern void igb_free_tx_resources(struct igb_ring *);
 +extern void igb_free_rx_resources(struct igb_ring *);
 +extern void igb_configure_tx_ring(struct igb_adapter *, struct igb_ring *);
 +extern void igb_configure_rx_ring(struct igb_adapter *, struct igb_ring *);
 +extern void igb_setup_tctl(struct igb_adapter *);
 +extern void igb_setup_rctl(struct igb_adapter *);
 +extern netdev_tx_t igb_xmit_frame_ring(struct sk_buff *, struct igb_ring *);
 +extern void igb_unmap_and_free_tx_resource(struct igb_ring *,
 +					   struct igb_tx_buffer *);
 +extern void igb_alloc_rx_buffers(struct igb_ring *, u16);
 +extern void igb_update_stats(struct igb_adapter *, struct rtnl_link_stats64 *);
 +extern bool igb_has_link(struct igb_adapter *adapter);
 +extern void igb_set_ethtool_ops(struct net_device *);
 +extern void igb_power_up_link(struct igb_adapter *);
 +extern void igb_set_fw_version(struct igb_adapter *);
 +extern void igb_ptp_init(struct igb_adapter *adapter);
 +extern void igb_ptp_stop(struct igb_adapter *adapter);
 +extern void igb_ptp_reset(struct igb_adapter *adapter);
 +extern void igb_ptp_tx_work(struct work_struct *work);
 +extern void igb_ptp_rx_hang(struct igb_adapter *adapter);
 +extern void igb_ptp_tx_hwtstamp(struct igb_adapter *adapter);
 +extern void igb_ptp_rx_rgtstamp(struct igb_q_vector *q_vector,
 +				struct sk_buff *skb);
 +extern void igb_ptp_rx_pktstamp(struct igb_q_vector *q_vector,
 +				unsigned char *va,
 +				struct sk_buff *skb);
 +static inline void igb_ptp_rx_hwtstamp(struct igb_ring *rx_ring,
 +				       union e1000_adv_rx_desc *rx_desc,
 +				       struct sk_buff *skb)
 +{
 +	if (igb_test_staterr(rx_desc, E1000_RXDADV_STAT_TS) &&
 +	    !igb_test_staterr(rx_desc, E1000_RXDADV_STAT_TSIP))
 +		igb_ptp_rx_rgtstamp(rx_ring->q_vector, skb);
 +
 +	/* Update the last_rx_timestamp timer in order to enable watchdog check
 +	 * for error case of latched timestamp on a dropped packet.
 +	 */
 +	rx_ring->last_rx_timestamp = jiffies;
 +}
 +
 +extern int igb_ptp_hwtstamp_ioctl(struct net_device *netdev,
 +				  struct ifreq *ifr, int cmd);
++=======
+ int igb_up(struct igb_adapter *);
+ void igb_down(struct igb_adapter *);
+ void igb_reinit_locked(struct igb_adapter *);
+ void igb_reset(struct igb_adapter *);
+ int igb_reinit_queues(struct igb_adapter *);
+ void igb_write_rss_indir_tbl(struct igb_adapter *);
+ int igb_set_spd_dplx(struct igb_adapter *, u32, u8);
+ int igb_setup_tx_resources(struct igb_ring *);
+ int igb_setup_rx_resources(struct igb_ring *);
+ void igb_free_tx_resources(struct igb_ring *);
+ void igb_free_rx_resources(struct igb_ring *);
+ void igb_configure_tx_ring(struct igb_adapter *, struct igb_ring *);
+ void igb_configure_rx_ring(struct igb_adapter *, struct igb_ring *);
+ void igb_setup_tctl(struct igb_adapter *);
+ void igb_setup_rctl(struct igb_adapter *);
+ netdev_tx_t igb_xmit_frame_ring(struct sk_buff *, struct igb_ring *);
+ void igb_unmap_and_free_tx_resource(struct igb_ring *, struct igb_tx_buffer *);
+ void igb_alloc_rx_buffers(struct igb_ring *, u16);
+ void igb_update_stats(struct igb_adapter *, struct rtnl_link_stats64 *);
+ bool igb_has_link(struct igb_adapter *adapter);
+ void igb_set_ethtool_ops(struct net_device *);
+ void igb_power_up_link(struct igb_adapter *);
+ void igb_set_fw_version(struct igb_adapter *);
+ void igb_ptp_init(struct igb_adapter *adapter);
+ void igb_ptp_stop(struct igb_adapter *adapter);
+ void igb_ptp_reset(struct igb_adapter *adapter);
+ void igb_ptp_rx_hang(struct igb_adapter *adapter);
+ void igb_ptp_rx_rgtstamp(struct igb_q_vector *q_vector, struct sk_buff *skb);
+ void igb_ptp_rx_pktstamp(struct igb_q_vector *q_vector, unsigned char *va,
+ 			 struct sk_buff *skb);
+ int igb_ptp_set_ts_config(struct net_device *netdev, struct ifreq *ifr);
+ int igb_ptp_get_ts_config(struct net_device *netdev, struct ifreq *ifr);
++>>>>>>> 5499a968d49f (igb: fix last_rx_timestamp usage)
  #ifdef CONFIG_IGB_HWMON
 -void igb_sysfs_exit(struct igb_adapter *adapter);
 -int igb_sysfs_init(struct igb_adapter *adapter);
 +extern void igb_sysfs_exit(struct igb_adapter *adapter);
 +extern int igb_sysfs_init(struct igb_adapter *adapter);
  #endif
  static inline s32 igb_reset_phy(struct e1000_hw *hw)
  {
* Unmerged path drivers/net/ethernet/intel/igb/igb.h
diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c
index bee3a70d4f42..2d36c1f97244 100644
--- a/drivers/net/ethernet/intel/igb/igb_main.c
+++ b/drivers/net/ethernet/intel/igb/igb_main.c
@@ -6893,7 +6893,9 @@ static void igb_process_skb_fields(struct igb_ring *rx_ring,
 
 	igb_rx_checksum(rx_ring, rx_desc, skb);
 
-	igb_ptp_rx_hwtstamp(rx_ring, rx_desc, skb);
+	if (igb_test_staterr(rx_desc, E1000_RXDADV_STAT_TS) &&
+	    !igb_test_staterr(rx_desc, E1000_RXDADV_STAT_TSIP))
+		igb_ptp_rx_rgtstamp(rx_ring->q_vector, skb);
 
 	if ((dev->features & NETIF_F_HW_VLAN_CTAG_RX) &&
 	    igb_test_staterr(rx_desc, E1000_RXD_STAT_VP)) {
diff --git a/drivers/net/ethernet/intel/igb/igb_ptp.c b/drivers/net/ethernet/intel/igb/igb_ptp.c
index 31d74e3c9a03..f88365516f1f 100644
--- a/drivers/net/ethernet/intel/igb/igb_ptp.c
+++ b/drivers/net/ethernet/intel/igb/igb_ptp.c
@@ -425,10 +425,8 @@ static void igb_ptp_overflow_check(struct work_struct *work)
 void igb_ptp_rx_hang(struct igb_adapter *adapter)
 {
 	struct e1000_hw *hw = &adapter->hw;
-	struct igb_ring *rx_ring;
 	u32 tsyncrxctl = rd32(E1000_TSYNCRXCTL);
 	unsigned long rx_event;
-	int n;
 
 	if (hw->mac.type != e1000_82576)
 		return;
@@ -443,11 +441,8 @@ void igb_ptp_rx_hang(struct igb_adapter *adapter)
 
 	/* Determine the most recent watchdog or rx_timestamp event */
 	rx_event = adapter->last_rx_ptp_check;
-	for (n = 0; n < adapter->num_rx_queues; n++) {
-		rx_ring = adapter->rx_ring[n];
-		if (time_after(rx_ring->last_rx_timestamp, rx_event))
-			rx_event = rx_ring->last_rx_timestamp;
-	}
+	if (time_after(adapter->last_rx_timestamp, rx_event))
+		rx_event = adapter->last_rx_timestamp;
 
 	/* Only need to read the high RXSTMP register to clear the lock */
 	if (time_is_before_jiffies(rx_event + 5 * HZ)) {
@@ -538,6 +533,11 @@ void igb_ptp_rx_rgtstamp(struct igb_q_vector *q_vector,
 	regval |= (u64)rd32(E1000_RXSTMPH) << 32;
 
 	igb_ptp_systim_to_hwtstamp(adapter, skb_hwtstamps(skb), regval);
+
+	/* Update the last_rx_timestamp timer in order to enable watchdog check
+	 * for error case of latched timestamp on a dropped packet.
+	 */
+	adapter->last_rx_timestamp = jiffies;
 }
 
 /**
