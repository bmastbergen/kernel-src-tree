NFS: Create a common rw_header_alloc and rw_header_free function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Anna Schumaker <Anna.Schumaker@netapp.com>
commit 4a0de55c565a36cac8422b76a948c4634a90781e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/4a0de55c.failed

I create a new struct nfs_rw_ops to decide the differences between reads
and writes.  This struct will be set when initializing a new
nfs_pgio_descriptor, and then passed on to the nfs_rw_header when a new
header is allocated.

	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 4a0de55c565a36cac8422b76a948c4634a90781e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/internal.h
#	fs/nfs/pagelist.c
#	fs/nfs/read.c
#	fs/nfs/write.c
diff --cc fs/nfs/internal.h
index 96bd22580dbf,9d6a40eae11c..000000000000
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@@ -238,6 -237,11 +238,14 @@@ extern void nfs_pgheader_init(struct nf
  void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
  int nfs_iocounter_wait(struct nfs_io_counter *c);
  
++<<<<<<< HEAD
++=======
+ struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *);
+ void nfs_rw_header_free(struct nfs_pgio_header *);
+ struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *, unsigned int);
+ void nfs_pgio_data_release(struct nfs_pgio_data *);
+ 
++>>>>>>> 4a0de55c565a (NFS: Create a common rw_header_alloc and rw_header_free function)
  static inline void nfs_iocounter_init(struct nfs_io_counter *c)
  {
  	c->flags = 0;
@@@ -392,8 -399,6 +400,11 @@@ extern int nfs4_get_rootfh(struct nfs_s
  
  struct nfs_pgio_completion_ops;
  /* read.c */
++<<<<<<< HEAD
 +extern struct nfs_read_header *nfs_readhdr_alloc(void);
 +extern void nfs_readhdr_free(struct nfs_pgio_header *hdr);
++=======
++>>>>>>> 4a0de55c565a (NFS: Create a common rw_header_alloc and rw_header_free function)
  extern void nfs_pageio_init_read(struct nfs_pageio_descriptor *pgio,
  			struct inode *inode, bool force_mds,
  			const struct nfs_pgio_completion_ops *compl_ops);
@@@ -421,8 -425,6 +432,11 @@@ int nfs_remount(struct super_block *sb
  extern void nfs_pageio_init_write(struct nfs_pageio_descriptor *pgio,
  			struct inode *inode, int ioflags, bool force_mds,
  			const struct nfs_pgio_completion_ops *compl_ops);
++<<<<<<< HEAD
 +extern struct nfs_write_header *nfs_writehdr_alloc(void);
 +extern void nfs_writehdr_free(struct nfs_pgio_header *hdr);
++=======
++>>>>>>> 4a0de55c565a (NFS: Create a common rw_header_alloc and rw_header_free function)
  extern int nfs_generic_flush(struct nfs_pageio_descriptor *desc,
  			     struct nfs_pgio_header *hdr);
  extern void nfs_pageio_reset_write_mds(struct nfs_pageio_descriptor *pgio);
diff --cc fs/nfs/pagelist.c
index 2ffebf2081ce,ca356fe0836b..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -295,6 -295,97 +295,100 @@@ bool nfs_generic_pg_test(struct nfs_pag
  }
  EXPORT_SYMBOL_GPL(nfs_generic_pg_test);
  
++<<<<<<< HEAD
++=======
+ static inline struct nfs_rw_header *NFS_RW_HEADER(struct nfs_pgio_header *hdr)
+ {
+ 	return container_of(hdr, struct nfs_rw_header, header);
+ }
+ 
+ /**
+  * nfs_rw_header_alloc - Allocate a header for a read or write
+  * @ops: Read or write function vector
+  */
+ struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *ops)
+ {
+ 	struct nfs_rw_header *header = ops->rw_alloc_header();
+ 
+ 	if (header) {
+ 		struct nfs_pgio_header *hdr = &header->header;
+ 
+ 		INIT_LIST_HEAD(&hdr->pages);
+ 		INIT_LIST_HEAD(&hdr->rpc_list);
+ 		spin_lock_init(&hdr->lock);
+ 		atomic_set(&hdr->refcnt, 0);
+ 		hdr->rw_ops = ops;
+ 	}
+ 	return header;
+ }
+ EXPORT_SYMBOL_GPL(nfs_rw_header_alloc);
+ 
+ /*
+  * nfs_rw_header_free - Free a read or write header
+  * @hdr: The header to free
+  */
+ void nfs_rw_header_free(struct nfs_pgio_header *hdr)
+ {
+ 	hdr->rw_ops->rw_free_header(NFS_RW_HEADER(hdr));
+ }
+ EXPORT_SYMBOL_GPL(nfs_rw_header_free);
+ 
+ /**
+  * nfs_pgio_data_alloc - Allocate pageio data
+  * @hdr: The header making a request
+  * @pagecount: Number of pages to create
+  */
+ struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *hdr,
+ 					  unsigned int pagecount)
+ {
+ 	struct nfs_pgio_data *data, *prealloc;
+ 
+ 	prealloc = &NFS_RW_HEADER(hdr)->rpc_data;
+ 	if (prealloc->header == NULL)
+ 		data = prealloc;
+ 	else
+ 		data = kzalloc(sizeof(*data), GFP_KERNEL);
+ 	if (!data)
+ 		goto out;
+ 
+ 	if (nfs_pgarray_set(&data->pages, pagecount)) {
+ 		data->header = hdr;
+ 		atomic_inc(&hdr->refcnt);
+ 	} else {
+ 		if (data != prealloc)
+ 			kfree(data);
+ 		data = NULL;
+ 	}
+ out:
+ 	return data;
+ }
+ 
+ /**
+  * nfs_pgio_data_release - Properly free pageio data
+  * @data: The data to release
+  */
+ void nfs_pgio_data_release(struct nfs_pgio_data *data)
+ {
+ 	struct nfs_pgio_header *hdr = data->header;
+ 	struct nfs_rw_header *pageio_header = NFS_RW_HEADER(hdr);
+ 
+ 	put_nfs_open_context(data->args.context);
+ 	if (data->pages.pagevec != data->pages.page_array)
+ 		kfree(data->pages.pagevec);
+ 	if (data == &pageio_header->rpc_data) {
+ 		data->header = NULL;
+ 		data = NULL;
+ 	}
+ 	if (atomic_dec_and_test(&hdr->refcnt))
+ 		hdr->completion_ops->completion(hdr);
+ 	/* Note: we only free the rpc_task after callbacks are done.
+ 	 * See the comment in rpc_free_task() for why
+ 	 */
+ 	kfree(data);
+ }
+ EXPORT_SYMBOL_GPL(nfs_pgio_data_release);
+ 
++>>>>>>> 4a0de55c565a (NFS: Create a common rw_header_alloc and rw_header_free function)
  /**
   * nfs_pageio_init - initialise a page io descriptor
   * @desc: pointer to descriptor
diff --cc fs/nfs/read.c
index 473bba35a2cb,4cf3577bd54e..000000000000
--- a/fs/nfs/read.c
+++ b/fs/nfs/read.c
@@@ -34,77 -35,16 +35,86 @@@ static const struct nfs_rw_ops nfs_rw_r
  
  static struct kmem_cache *nfs_rdata_cachep;
  
++<<<<<<< HEAD
 +struct nfs_read_header *nfs_readhdr_alloc(void)
 +{
 +	struct nfs_read_header *rhdr;
 +
 +	rhdr = kmem_cache_zalloc(nfs_rdata_cachep, GFP_KERNEL);
 +	if (rhdr) {
 +		struct nfs_pgio_header *hdr = &rhdr->header;
 +
 +		INIT_LIST_HEAD(&hdr->pages);
 +		INIT_LIST_HEAD(&hdr->rpc_list);
 +		spin_lock_init(&hdr->lock);
 +		atomic_set(&hdr->refcnt, 0);
 +	}
 +	return rhdr;
++=======
+ static struct nfs_rw_header *nfs_readhdr_alloc(void)
+ {
+ 	return kmem_cache_zalloc(nfs_rdata_cachep, GFP_KERNEL);
++>>>>>>> 4a0de55c565a (NFS: Create a common rw_header_alloc and rw_header_free function)
 +}
- EXPORT_SYMBOL_GPL(nfs_readhdr_alloc);
 +
++<<<<<<< HEAD
 +static struct nfs_read_data *nfs_readdata_alloc(struct nfs_pgio_header *hdr,
 +						unsigned int pagecount)
 +{
 +	struct nfs_read_data *data, *prealloc;
 +
 +	prealloc = &container_of(hdr, struct nfs_read_header, header)->rpc_data;
 +	if (prealloc->header == NULL)
 +		data = prealloc;
 +	else
 +		data = kzalloc(sizeof(*data), GFP_KERNEL);
 +	if (!data)
 +		goto out;
 +
 +	if (nfs_pgarray_set(&data->pages, pagecount)) {
 +		data->header = hdr;
 +		atomic_inc(&hdr->refcnt);
 +	} else {
 +		if (data != prealloc)
 +			kfree(data);
 +		data = NULL;
 +	}
 +out:
 +	return data;
  }
  
 +void nfs_readhdr_free(struct nfs_pgio_header *hdr)
 +{
 +	struct nfs_read_header *rhdr = container_of(hdr, struct nfs_read_header, header);
 +
++=======
+ static void nfs_readhdr_free(struct nfs_rw_header *rhdr)
+ {
++>>>>>>> 4a0de55c565a (NFS: Create a common rw_header_alloc and rw_header_free function)
  	kmem_cache_free(nfs_rdata_cachep, rhdr);
  }
- EXPORT_SYMBOL_GPL(nfs_readhdr_free);
  
 +void nfs_readdata_release(struct nfs_read_data *rdata)
 +{
 +	struct nfs_pgio_header *hdr = rdata->header;
 +	struct nfs_read_header *read_header = container_of(hdr, struct nfs_read_header, header);
 +
 +	put_nfs_open_context(rdata->args.context);
 +	if (rdata->pages.pagevec != rdata->pages.page_array)
 +		kfree(rdata->pages.pagevec);
 +	if (rdata == &read_header->rpc_data) {
 +		rdata->header = NULL;
 +		rdata = NULL;
 +	}
 +	if (atomic_dec_and_test(&hdr->refcnt))
 +		hdr->completion_ops->completion(hdr);
 +	/* Note: we only free the rpc_task after callbacks are done.
 +	 * See the comment in rpc_free_task() for why
 +	 */
 +	kfree(rdata);
 +}
 +EXPORT_SYMBOL_GPL(nfs_readdata_release);
 +
  static
  int nfs_return_empty_page(struct page *page)
  {
diff --cc fs/nfs/write.c
index f9fc82c305d1,9c5cde38da45..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -70,77 -71,20 +71,85 @@@ void nfs_commit_free(struct nfs_commit_
  }
  EXPORT_SYMBOL_GPL(nfs_commit_free);
  
++<<<<<<< HEAD
 +struct nfs_write_header *nfs_writehdr_alloc(void)
++=======
+ static struct nfs_rw_header *nfs_writehdr_alloc(void)
++>>>>>>> 4a0de55c565a (NFS: Create a common rw_header_alloc and rw_header_free function)
  {
 -	struct nfs_rw_header *p = mempool_alloc(nfs_wdata_mempool, GFP_NOIO);
 +	struct nfs_write_header *p = mempool_alloc(nfs_wdata_mempool, GFP_NOIO);
  
- 	if (p) {
- 		struct nfs_pgio_header *hdr = &p->header;
- 
+ 	if (p)
  		memset(p, 0, sizeof(*p));
++<<<<<<< HEAD
 +		INIT_LIST_HEAD(&hdr->pages);
 +		INIT_LIST_HEAD(&hdr->rpc_list);
 +		spin_lock_init(&hdr->lock);
 +		atomic_set(&hdr->refcnt, 0);
 +		hdr->verf = &p->verf;
 +	}
++=======
++>>>>>>> 4a0de55c565a (NFS: Create a common rw_header_alloc and rw_header_free function)
  	return p;
  }
- EXPORT_SYMBOL_GPL(nfs_writehdr_alloc);
  
++<<<<<<< HEAD
 +static struct nfs_write_data *nfs_writedata_alloc(struct nfs_pgio_header *hdr,
 +						  unsigned int pagecount)
 +{
 +	struct nfs_write_data *data, *prealloc;
 +
 +	prealloc = &container_of(hdr, struct nfs_write_header, header)->rpc_data;
 +	if (prealloc->header == NULL)
 +		data = prealloc;
 +	else
 +		data = kzalloc(sizeof(*data), GFP_KERNEL);
 +	if (!data)
 +		goto out;
 +
 +	if (nfs_pgarray_set(&data->pages, pagecount)) {
 +		data->header = hdr;
 +		atomic_inc(&hdr->refcnt);
 +	} else {
 +		if (data != prealloc)
 +			kfree(data);
 +		data = NULL;
 +	}
 +out:
 +	return data;
 +}
 +
 +void nfs_writehdr_free(struct nfs_pgio_header *hdr)
 +{
 +	struct nfs_write_header *whdr = container_of(hdr, struct nfs_write_header, header);
++=======
+ static void nfs_writehdr_free(struct nfs_rw_header *whdr)
+ {
++>>>>>>> 4a0de55c565a (NFS: Create a common rw_header_alloc and rw_header_free function)
  	mempool_free(whdr, nfs_wdata_mempool);
  }
- EXPORT_SYMBOL_GPL(nfs_writehdr_free);
  
 +void nfs_writedata_release(struct nfs_write_data *wdata)
 +{
 +	struct nfs_pgio_header *hdr = wdata->header;
 +	struct nfs_write_header *write_header = container_of(hdr, struct nfs_write_header, header);
 +
 +	put_nfs_open_context(wdata->args.context);
 +	if (wdata->pages.pagevec != wdata->pages.page_array)
 +		kfree(wdata->pages.pagevec);
 +	if (wdata == &write_header->rpc_data) {
 +		wdata->header = NULL;
 +		wdata = NULL;
 +	}
 +	if (atomic_dec_and_test(&hdr->refcnt))
 +		hdr->completion_ops->completion(hdr);
 +	/* Note: we only free the rpc_task after callbacks are done.
 +	 * See the comment in rpc_free_task() for why
 +	 */
 +	kfree(wdata);
 +}
 +EXPORT_SYMBOL_GPL(nfs_writedata_release);
 +
  static void nfs_context_set_write_error(struct nfs_open_context *ctx, int error)
  {
  	ctx->error = error;
* Unmerged path fs/nfs/internal.h
* Unmerged path fs/nfs/pagelist.c
diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c
index 3d5bc2baafd1..1abd1cea9468 100644
--- a/fs/nfs/pnfs.c
+++ b/fs/nfs/pnfs.c
@@ -1585,7 +1585,7 @@ pnfs_do_multiple_writes(struct nfs_pageio_descriptor *desc, struct list_head *he
 static void pnfs_writehdr_free(struct nfs_pgio_header *hdr)
 {
 	pnfs_put_lseg(hdr->lseg);
-	nfs_writehdr_free(hdr);
+	nfs_rw_header_free(hdr);
 }
 EXPORT_SYMBOL_GPL(pnfs_writehdr_free);
 
@@ -1596,7 +1596,7 @@ pnfs_generic_pg_writepages(struct nfs_pageio_descriptor *desc)
 	struct nfs_pgio_header *hdr;
 	int ret;
 
-	whdr = nfs_writehdr_alloc();
+	whdr = nfs_rw_header_alloc(desc->pg_rw_ops);
 	if (!whdr) {
 		desc->pg_completion_ops->error_cleanup(&desc->pg_list);
 		pnfs_put_lseg(desc->pg_lseg);
@@ -1743,7 +1743,7 @@ pnfs_do_multiple_reads(struct nfs_pageio_descriptor *desc, struct list_head *hea
 static void pnfs_readhdr_free(struct nfs_pgio_header *hdr)
 {
 	pnfs_put_lseg(hdr->lseg);
-	nfs_readhdr_free(hdr);
+	nfs_rw_header_free(hdr);
 }
 EXPORT_SYMBOL_GPL(pnfs_readhdr_free);
 
@@ -1754,7 +1754,7 @@ pnfs_generic_pg_readpages(struct nfs_pageio_descriptor *desc)
 	struct nfs_pgio_header *hdr;
 	int ret;
 
-	rhdr = nfs_readhdr_alloc();
+	rhdr = nfs_rw_header_alloc(desc->pg_rw_ops);
 	if (!rhdr) {
 		desc->pg_completion_ops->error_cleanup(&desc->pg_list);
 		ret = -ENOMEM;
* Unmerged path fs/nfs/read.c
* Unmerged path fs/nfs/write.c
diff --git a/include/linux/nfs_page.h b/include/linux/nfs_page.h
index 92ce5783b707..594812546c25 100644
--- a/include/linux/nfs_page.h
+++ b/include/linux/nfs_page.h
@@ -52,6 +52,11 @@ struct nfs_pageio_ops {
 	int	(*pg_doio)(struct nfs_pageio_descriptor *);
 };
 
+struct nfs_rw_ops {
+	struct nfs_rw_header *(*rw_alloc_header)(void);
+	void (*rw_free_header)(struct nfs_rw_header *);
+};
+
 struct nfs_pageio_descriptor {
 	struct list_head	pg_list;
 	unsigned long		pg_bytes_written;
@@ -63,6 +68,7 @@ struct nfs_pageio_descriptor {
 
 	struct inode		*pg_inode;
 	const struct nfs_pageio_ops *pg_ops;
+	const struct nfs_rw_ops *pg_rw_ops;
 	int 			pg_ioflags;
 	int			pg_error;
 	const struct rpc_call_ops *pg_rpc_callops;
@@ -86,6 +92,7 @@ extern	void nfs_pageio_init(struct nfs_pageio_descriptor *desc,
 			     struct inode *inode,
 			     const struct nfs_pageio_ops *pg_ops,
 			     const struct nfs_pgio_completion_ops *compl_ops,
+			     const struct nfs_rw_ops *rw_ops,
 			     size_t bsize,
 			     int how);
 extern	int nfs_pageio_add_request(struct nfs_pageio_descriptor *,
diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h
index 381f832b03c6..5959714bc2b9 100644
--- a/include/linux/nfs_xdr.h
+++ b/include/linux/nfs_xdr.h
@@ -1283,6 +1283,7 @@ struct nfs_pgio_header {
 	const struct rpc_call_ops *mds_ops;
 	void (*release) (struct nfs_pgio_header *hdr);
 	const struct nfs_pgio_completion_ops *completion_ops;
+	const struct nfs_rw_ops	*rw_ops;
 	struct nfs_direct_req	*dreq;
 	void			*layout_private;
 	spinlock_t		lock;
