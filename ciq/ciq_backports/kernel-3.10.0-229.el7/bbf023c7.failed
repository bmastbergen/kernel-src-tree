ext4: pair trace_ext4_writepages & trace_ext4_writepages_result

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Ming Lei <ming.lei@canonical.com>
commit bbf023c74dcf380769aec00aedd706a266b7d9ef
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/bbf023c7.failed

Pair the two trace events to make troubeshooting writepages
easier, and it should be more convinient to write a simple script
to parse the traces.

	Cc: linux-ext4@vger.kernel.org
	Cc: Jan Kara <jack@suse.cz>
	Signed-off-by: Ming Lei <ming.lei@canonical.com>
	Signed-off-by: "Theodore Ts'o" <tytso@mit.edu>
(cherry picked from commit bbf023c74dcf380769aec00aedd706a266b7d9ef)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/inode.c
diff --cc fs/ext4/inode.c
index 9b251a9a30ad,43015fa69c3a..000000000000
--- a/fs/ext4/inode.c
+++ b/fs/ext4/inode.c
@@@ -2409,8 -2423,17 +2409,20 @@@ static int ext4_da_writepages(struct ad
  	 * because that could violate lock ordering on umount
  	 */
  	if (!mapping->nrpages || !mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))
- 		return 0;
+ 		goto out_writepages;
+ 
++<<<<<<< HEAD
++=======
+ 	if (ext4_should_journal_data(inode)) {
+ 		struct blk_plug plug;
  
+ 		blk_start_plug(&plug);
+ 		ret = write_cache_pages(mapping, wbc, __writepage, mapping);
+ 		blk_finish_plug(&plug);
+ 		goto out_writepages;
+ 	}
+ 
++>>>>>>> bbf023c74dcf (ext4: pair trace_ext4_writepages & trace_ext4_writepages_result)
  	/*
  	 * If the filesystem has aborted, it is read-only, so return
  	 * right away instead of dumping stack traces later on that
@@@ -2421,9 -2444,37 +2433,11 @@@
  	 * *never* be called, so if that ever happens, we would want
  	 * the stack trace.
  	 */
- 	if (unlikely(sbi->s_mount_flags & EXT4_MF_FS_ABORTED))
- 		return -EROFS;
+ 	if (unlikely(sbi->s_mount_flags & EXT4_MF_FS_ABORTED)) {
+ 		ret = -EROFS;
+ 		goto out_writepages;
+ 	}
  
 -	if (ext4_should_dioread_nolock(inode)) {
 -		/*
 -		 * We may need to convert up to one extent per block in
 -		 * the page and we may dirty the inode.
 -		 */
 -		rsv_blocks = 1 + (PAGE_CACHE_SIZE >> inode->i_blkbits);
 -	}
 -
 -	/*
 -	 * If we have inline data and arrive here, it means that
 -	 * we will soon create the block for the 1st page, so
 -	 * we'd better clear the inline data here.
 -	 */
 -	if (ext4_has_inline_data(inode)) {
 -		/* Just inode will be modified... */
 -		handle = ext4_journal_start(inode, EXT4_HT_INODE, 1);
 -		if (IS_ERR(handle)) {
 -			ret = PTR_ERR(handle);
 -			goto out_writepages;
 -		}
 -		BUG_ON(ext4_test_inode_state(inode,
 -				EXT4_STATE_MAY_INLINE_DATA));
 -		ext4_destroy_inline_data(handle, inode);
 -		ext4_journal_stop(handle);
 -	}
 -
  	if (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)
  		range_whole = 1;
  
* Unmerged path fs/ext4/inode.c
