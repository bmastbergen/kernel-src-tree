drm/i915: handle G45/GM45 pulse detection connected state.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] i915: handle G45/GM45 pulse detection connected state (Dave Airlie) [1140440]
Rebuild_FUZZ: 95.50%
commit-author Dave Airlie <airlied@redhat.com>
commit 2a592bec50994597716c633191ed6bf7af14defc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2a592bec.failed

In the HPD pulse handler we check for long pulses if the port is actually
connected, however we do that for IBX, but we use the pulse handling code on
GM45 systems as well, so we need to use a diffent check.

This patch refactors the digital port connected check out of the g4x detection
path and reuses it in the hpd pulse path.

Fixes: http://lkml.kernel.org/r/1409382202.5141.36.camel@marge.simpson.net
	Reported-by: Mike Galbraith <umgwanakikbuti@gmail.com>
	Signed-off-by: Dave Airlie <airlied@redhat.com>
	Reviewed-by: Daniel Vetter <daniel.vetter@ffwll.ch>
	Acked-by: Imre Deak <imre.deak@intel.com>
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
(cherry picked from commit 2a592bec50994597716c633191ed6bf7af14defc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_dp.c
diff --cc drivers/gpu/drm/i915/intel_dp.c
index 1a431377d83b,81d7681faa63..000000000000
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@@ -2785,36 -3661,40 +2785,65 @@@ ironlake_dp_detect(struct intel_dp *int
  	return intel_dp_detect_dpcd(intel_dp);
  }
  
- static enum drm_connector_status
- g4x_dp_detect(struct intel_dp *intel_dp)
+ static int g4x_digital_port_connected(struct drm_device *dev,
+ 				       struct intel_digital_port *intel_dig_port)
  {
- 	struct drm_device *dev = intel_dp_to_dev(intel_dp);
  	struct drm_i915_private *dev_priv = dev->dev_private;
- 	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
  	uint32_t bit;
  
++<<<<<<< HEAD
 +	/* Can't disconnect eDP, but you can close the lid... */
 +	if (is_edp(intel_dp)) {
 +		enum drm_connector_status status;
 +
 +		status = intel_panel_detect(dev);
 +		if (status == connector_status_unknown)
 +			status = connector_status_connected;
 +		return status;
 +	}
 +
 +	switch (intel_dig_port->port) {
 +	case PORT_B:
 +		bit = PORTB_HOTPLUG_LIVE_STATUS;
 +		break;
 +	case PORT_C:
 +		bit = PORTC_HOTPLUG_LIVE_STATUS;
 +		break;
 +	case PORT_D:
 +		bit = PORTD_HOTPLUG_LIVE_STATUS;
 +		break;
 +	default:
 +		return connector_status_unknown;
++=======
+ 	if (IS_VALLEYVIEW(dev)) {
+ 		switch (intel_dig_port->port) {
+ 		case PORT_B:
+ 			bit = PORTB_HOTPLUG_LIVE_STATUS_VLV;
+ 			break;
+ 		case PORT_C:
+ 			bit = PORTC_HOTPLUG_LIVE_STATUS_VLV;
+ 			break;
+ 		case PORT_D:
+ 			bit = PORTD_HOTPLUG_LIVE_STATUS_VLV;
+ 			break;
+ 		default:
+ 			return -EINVAL;
+ 		}
+ 	} else {
+ 		switch (intel_dig_port->port) {
+ 		case PORT_B:
+ 			bit = PORTB_HOTPLUG_LIVE_STATUS_G4X;
+ 			break;
+ 		case PORT_C:
+ 			bit = PORTC_HOTPLUG_LIVE_STATUS_G4X;
+ 			break;
+ 		case PORT_D:
+ 			bit = PORTD_HOTPLUG_LIVE_STATUS_G4X;
+ 			break;
+ 		default:
+ 			return -EINVAL;
+ 		}
++>>>>>>> 2a592bec5099 (drm/i915: handle G45/GM45 pulse detection connected state.)
  	}
  
  	if ((I915_READ(PORT_HOTPLUG_STAT) & bit) == 0)
@@@ -3090,12 -4052,80 +3144,82 @@@ static const struct drm_encoder_funcs i
  	.destroy = intel_dp_encoder_destroy,
  };
  
 -void
 +static void
  intel_dp_hot_plug(struct intel_encoder *intel_encoder)
  {
 -	return;
 -}
 +	struct intel_dp *intel_dp = enc_to_intel_dp(&intel_encoder->base);
  
++<<<<<<< HEAD
 +	intel_dp_check_link_status(intel_dp);
++=======
+ bool
+ intel_dp_hpd_pulse(struct intel_digital_port *intel_dig_port, bool long_hpd)
+ {
+ 	struct intel_dp *intel_dp = &intel_dig_port->dp;
+ 	struct intel_encoder *intel_encoder = &intel_dig_port->base;
+ 	struct drm_device *dev = intel_dig_port->base.base.dev;
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	enum intel_display_power_domain power_domain;
+ 	bool ret = true;
+ 
+ 	if (intel_dig_port->base.type != INTEL_OUTPUT_EDP)
+ 		intel_dig_port->base.type = INTEL_OUTPUT_DISPLAYPORT;
+ 
+ 	DRM_DEBUG_KMS("got hpd irq on port %d - %s\n", intel_dig_port->port,
+ 		      long_hpd ? "long" : "short");
+ 
+ 	power_domain = intel_display_port_power_domain(intel_encoder);
+ 	intel_display_power_get(dev_priv, power_domain);
+ 
+ 	if (long_hpd) {
+ 
+ 		if (HAS_PCH_SPLIT(dev)) {
+ 			if (!ibx_digital_port_connected(dev_priv, intel_dig_port))
+ 				goto mst_fail;
+ 		} else {
+ 			if (g4x_digital_port_connected(dev, intel_dig_port) != 1)
+ 				goto mst_fail;
+ 		}
+ 
+ 		if (!intel_dp_get_dpcd(intel_dp)) {
+ 			goto mst_fail;
+ 		}
+ 
+ 		intel_dp_probe_oui(intel_dp);
+ 
+ 		if (!intel_dp_probe_mst(intel_dp))
+ 			goto mst_fail;
+ 
+ 	} else {
+ 		if (intel_dp->is_mst) {
+ 			if (intel_dp_check_mst_status(intel_dp) == -EINVAL)
+ 				goto mst_fail;
+ 		}
+ 
+ 		if (!intel_dp->is_mst) {
+ 			/*
+ 			 * we'll check the link status via the normal hot plug path later -
+ 			 * but for short hpds we should check it now
+ 			 */
+ 			drm_modeset_lock(&dev->mode_config.connection_mutex, NULL);
+ 			intel_dp_check_link_status(intel_dp);
+ 			drm_modeset_unlock(&dev->mode_config.connection_mutex);
+ 		}
+ 	}
+ 	ret = false;
+ 	goto put_power;
+ mst_fail:
+ 	/* if we were in MST mode, and device is not there get out of MST mode */
+ 	if (intel_dp->is_mst) {
+ 		DRM_DEBUG_KMS("MST device may have disappeared %d vs %d\n", intel_dp->is_mst, intel_dp->mst_mgr.mst_state);
+ 		intel_dp->is_mst = false;
+ 		drm_dp_mst_topology_mgr_set_mst(&intel_dp->mst_mgr, intel_dp->is_mst);
+ 	}
+ put_power:
+ 	intel_display_power_put(dev_priv, power_domain);
+ 
+ 	return ret;
++>>>>>>> 2a592bec5099 (drm/i915: handle G45/GM45 pulse detection connected state.)
  }
  
  /* Return which DP Port should be selected for Transcoder DP control */
* Unmerged path drivers/gpu/drm/i915/intel_dp.c
