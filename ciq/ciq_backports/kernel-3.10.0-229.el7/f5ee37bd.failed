rbd: use a single workqueue for all devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Ilya Dryomov <idryomov@redhat.com>
commit f5ee37bd31678d6cb2313631f203794b5c25e862
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/f5ee37bd.failed

Using one queue per device doesn't make much sense given that our
workfn processes "devices" and not "requests".  Switch to a single
workqueue for all devices.

	Signed-off-by: Ilya Dryomov <idryomov@redhat.com>
	Reviewed-by: Sage Weil <sage@redhat.com>
(cherry picked from commit f5ee37bd31678d6cb2313631f203794b5c25e862)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/rbd.c
diff --cc drivers/block/rbd.c
index 9b655d9d484e,be8d44af6ae1..000000000000
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@@ -396,8 -398,19 +395,21 @@@ static struct kmem_cache	*rbd_img_reque
  static struct kmem_cache	*rbd_obj_request_cache;
  static struct kmem_cache	*rbd_segment_name_cache;
  
 -static int rbd_major;
  static DEFINE_IDA(rbd_dev_id_ida);
  
++<<<<<<< HEAD
++=======
+ static struct workqueue_struct *rbd_wq;
+ 
+ /*
+  * Default to false for now, as single-major requires >= 0.75 version of
+  * userspace rbd utility.
+  */
+ static bool single_major = false;
+ module_param(single_major, bool, S_IRUGO);
+ MODULE_PARM_DESC(single_major, "Use a single major number for all rbd devices (default: false)");
+ 
++>>>>>>> f5ee37bd3167 (rbd: use a single workqueue for all devices)
  static int rbd_img_request_submit(struct rbd_img_request *img_request);
  
  static void rbd_dev_device_release(struct device *dev);
@@@ -5582,13 -5706,40 +5583,42 @@@ static int __init rbd_init(void
  	if (rc)
  		return rc;
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * The number of active work items is limited by the number of
+ 	 * rbd devices, so leave @max_active at default.
+ 	 */
+ 	rbd_wq = alloc_workqueue(RBD_DRV_NAME, WQ_MEM_RECLAIM, 0);
+ 	if (!rbd_wq) {
+ 		rc = -ENOMEM;
+ 		goto err_out_slab;
+ 	}
+ 
+ 	if (single_major) {
+ 		rbd_major = register_blkdev(0, RBD_DRV_NAME);
+ 		if (rbd_major < 0) {
+ 			rc = rbd_major;
+ 			goto err_out_wq;
+ 		}
+ 	}
+ 
++>>>>>>> f5ee37bd3167 (rbd: use a single workqueue for all devices)
  	rc = rbd_sysfs_init();
  	if (rc)
 -		goto err_out_blkdev;
 -
 -	if (single_major)
 -		pr_info("loaded (major %d)\n", rbd_major);
 -	else
 -		pr_info("loaded\n");
 +		goto err_out_slab;
  
 +	pr_info("loaded\n");
  	return 0;
  
++<<<<<<< HEAD
++=======
+ err_out_blkdev:
+ 	if (single_major)
+ 		unregister_blkdev(rbd_major, RBD_DRV_NAME);
+ err_out_wq:
+ 	destroy_workqueue(rbd_wq);
++>>>>>>> f5ee37bd3167 (rbd: use a single workqueue for all devices)
  err_out_slab:
  	rbd_slab_exit();
  	return rc;
@@@ -5598,6 -5749,9 +5628,12 @@@ static void __exit rbd_exit(void
  {
  	ida_destroy(&rbd_dev_id_ida);
  	rbd_sysfs_cleanup();
++<<<<<<< HEAD
++=======
+ 	if (single_major)
+ 		unregister_blkdev(rbd_major, RBD_DRV_NAME);
+ 	destroy_workqueue(rbd_wq);
++>>>>>>> f5ee37bd3167 (rbd: use a single workqueue for all devices)
  	rbd_slab_exit();
  }
  
* Unmerged path drivers/block/rbd.c
