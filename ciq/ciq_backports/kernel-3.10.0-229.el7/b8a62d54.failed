ACPI / hotplug / PCI: Use pci_device_is_present()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Use pci_device_is_present() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 89.89%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit b8a62d540240387c7e97a69127cab3ab9cadc70a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/b8a62d54.failed

Make the ACPI-based PCI hotplug (ACPIPHP) code use
pci_device_is_present() for checking if devices are present instead
of open coding the same thing.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit b8a62d540240387c7e97a69127cab3ab9cadc70a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,2d51bf7e9fe0..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -832,35 -660,52 +832,58 @@@ static unsigned int get_slot_status(str
  	return (unsigned int)sta;
  }
  
 -static inline bool device_status_valid(unsigned int sta)
 -{
 -	/*
 -	 * ACPI spec says that _STA may return bit 0 clear with bit 3 set
 -	 * if the device is valid but does not require a device driver to be
 -	 * loaded (Section 6.3.7 of ACPI 5.0A).
 -	 */
 -	unsigned int mask = ACPI_STA_DEVICE_ENABLED | ACPI_STA_DEVICE_FUNCTIONING;
 -	return (sta & mask) == mask;
 -}
 -
  /**
 - * trim_stale_devices - remove PCI devices that are not responding.
 - * @dev: PCI device to start walking the hierarchy from.
 + * acpiphp_eject_slot - physically eject the slot
 + * @slot: ACPI PHP slot
   */
 -static void trim_stale_devices(struct pci_dev *dev)
 +int acpiphp_eject_slot(struct acpiphp_slot *slot)
  {
 -	struct acpi_device *adev = ACPI_COMPANION(&dev->dev);
 -	struct pci_bus *bus = dev->subordinate;
 -	bool alive = false;
 -
 -	if (adev) {
 -		acpi_status status;
 -		unsigned long long sta;
 +	acpi_status status;
 +	struct acpiphp_func *func;
 +	struct acpi_object_list arg_list;
 +	union acpi_object arg;
  
 +	list_for_each_entry(func, &slot->funcs, sibling) {
 +		/* We don't want to call _EJ0 on non-existing functions. */
 +		if ((func->flags & FUNC_HAS_EJ0)) {
 +			/* _EJ0 method take one argument */
 +			arg_list.count = 1;
 +			arg_list.pointer = &arg;
 +			arg.type = ACPI_TYPE_INTEGER;
 +			arg.integer.value = 1;
 +
++<<<<<<< HEAD
 +			status = acpi_evaluate_object(func->handle, "_EJ0", &arg_list, NULL);
 +			if (ACPI_FAILURE(status)) {
 +				pr_warn("%s: _EJ0 failed\n", __func__);
 +				return -1;
 +			} else
 +				break;
 +		}
++=======
+ 		status = acpi_evaluate_integer(adev->handle, "_STA", NULL, &sta);
+ 		alive = (ACPI_SUCCESS(status) && device_status_valid(sta))
+ 			|| acpiphp_no_hotplug(adev);
+ 	}
+ 	if (!alive)
+ 		alive = pci_device_is_present(dev);
+ 
+ 	if (!alive) {
+ 		pci_stop_and_remove_bus_device(dev);
+ 		if (adev)
+ 			acpi_bus_trim(adev);
+ 	} else if (bus) {
+ 		struct pci_dev *child, *tmp;
+ 
+ 		/* The device is a bridge. so check the bus below it. */
+ 		pm_runtime_get_sync(&dev->dev);
+ 		list_for_each_entry_safe_reverse(child, tmp, &bus->devices, bus_list)
+ 			trim_stale_devices(child);
+ 
+ 		pm_runtime_put(&dev->dev);
++>>>>>>> b8a62d540240 (ACPI / hotplug / PCI: Use pci_device_is_present())
  	}
 +	return 0;
  }
  
  /**
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
