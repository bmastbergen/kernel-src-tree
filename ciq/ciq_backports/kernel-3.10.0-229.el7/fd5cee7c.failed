powerpc/powernv: Reset root port in firmware

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [powerpc] powernv: Reset root port in firmware (Don Zickus) [1127366]
Rebuild_FUZZ: 90.00%
commit-author Gavin Shan <gwshan@linux.vnet.ibm.com>
commit fd5cee7ce8f488768f918e73231d4859a520eb33
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/fd5cee7c.failed

Resetting root port has more stuff to do than that for PCIe switch
ports and we should have resetting root port done in firmware instead
of the kernel itself. The problem was introduced by commit 5b2e198e
("powerpc/powernv: Rework EEH reset").

	Cc: linux-stable <stable@vger.kernel.org>
	Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit fd5cee7ce8f488768f918e73231d4859a520eb33)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/platforms/powernv/eeh-ioda.c
diff --cc arch/powerpc/platforms/powernv/eeh-ioda.c
index be33a16408be,0844e00ccdd8..000000000000
--- a/arch/powerpc/platforms/powernv/eeh-ioda.c
+++ b/arch/powerpc/platforms/powernv/eeh-ioda.c
@@@ -505,56 -510,28 +505,77 @@@ static int ioda_eeh_reset(struct eeh_p
  	int ret;
  
  	/*
++<<<<<<< HEAD
 +	 * Anyway, we have to clear the problematic state for the
 +	 * corresponding PE. However, we needn't do it if the PE
 +	 * is PHB associated. That means the PHB is having fatal
 +	 * errors and it needs reset. Further more, the AIB interface
 +	 * isn't reliable any more.
 +	 */
 +	if (!(pe->type & EEH_PE_PHB) &&
 +	    (option == EEH_RESET_HOT ||
 +	    option == EEH_RESET_FUNDAMENTAL)) {
 +		ret = ioda_eeh_pe_clear(pe);
 +		if (ret)
 +			return -EIO;
 +	}
 +
 +	/*
 +	 * The rules applied to reset, either fundamental or hot reset:
 +	 *
 +	 * We always reset the direct upstream bridge of the PE. If the
 +	 * direct upstream bridge isn't root bridge, we always take hot
 +	 * reset no matter what option (fundamental or hot) is. Otherwise,
 +	 * we should do the reset according to the required option.
++=======
+ 	 * For PHB reset, we always have complete reset. For those PEs whose
+ 	 * primary bus derived from root complex (root bus) or root port
+ 	 * (usually bus#1), we apply hot or fundamental reset on the root port.
+ 	 * For other PEs, we always have hot reset on the PE primary bus.
+ 	 *
+ 	 * Here, we have different design to pHyp, which always clear the
+ 	 * frozen state during PE reset. However, the good idea here from
+ 	 * benh is to keep frozen state before we get PE reset done completely
+ 	 * (until BAR restore). With the frozen state, HW drops illegal IO
+ 	 * or MMIO access, which can incur recrusive frozen PE during PE
+ 	 * reset. The side effect is that EEH core has to clear the frozen
+ 	 * state explicitly after BAR restore.
++>>>>>>> fd5cee7ce8f4 (powerpc/powernv: Reset root port in firmware)
  	 */
  	if (pe->type & EEH_PE_PHB) {
  		ret = ioda_eeh_phb_reset(hose, option);
  	} else {
++<<<<<<< HEAD
 +		if (pe->type & EEH_PE_DEVICE) {
 +			/*
 +			 * If it's device PE, we didn't refer to the parent
 +			 * PCI bus yet. So we have to figure it out indirectly.
 +			 */
 +			edev = list_first_entry(&pe->edevs,
 +					struct eeh_dev, list);
 +			dev = eeh_dev_to_pci_dev(edev);
 +			dev = dev->bus->self;
 +		} else {
 +			/*
 +			 * If it's bus PE, the parent PCI bus is already there
 +			 * and just pick it up.
 +			 */
 +			dev = pe->bus->self;
 +		}
 +
 +		/*
 +		 * Do reset based on the fact that the direct upstream bridge
 +		 * is root bridge (port) or not.
 +		 */
 +		if (dev->bus->number == 0)
++=======
+ 		bus = eeh_pe_bus_get(pe);
+ 		if (pci_is_root_bus(bus) ||
+ 		    pci_is_root_bus(bus->parent))
++>>>>>>> fd5cee7ce8f4 (powerpc/powernv: Reset root port in firmware)
  			ret = ioda_eeh_root_reset(hose, option);
  		else
 -			ret = ioda_eeh_bridge_reset(bus->self, option);
 +			ret = ioda_eeh_bridge_reset(hose, dev, option);
  	}
  
  	return ret;
* Unmerged path arch/powerpc/platforms/powernv/eeh-ioda.c
