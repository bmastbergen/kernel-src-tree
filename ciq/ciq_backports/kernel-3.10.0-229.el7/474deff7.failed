cpufreq: remove cpufreq_policy_cpu per-cpu variable

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] remove cpufreq_policy_cpu per-cpu variable (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 90.32%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 474deff744c4012f07cfa994947d7c6260c9ab89
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/474deff7.failed

cpufreq_policy_cpu per-cpu variables are used for storing the ID of
the CPU that manages the given CPU's policy.  However, we also store
a policy pointer for each cpu in cpufreq_cpu_data, so the
cpufreq_policy_cpu information is simply redundant.

It is better to use cpufreq_cpu_data to retrieve a policy and get
policy->cpu from there, so make that happen everywhere and drop the
cpufreq_policy_cpu per-cpu variables which aren't necessary any more.

[rjw: Changelog]
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 474deff744c4012f07cfa994947d7c6260c9ab89)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index 7ca34bc0090e,0586bd20a474..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -1011,15 -1048,19 +1006,13 @@@ static int cpufreq_add_dev(struct devic
  #endif
  
  	write_lock_irqsave(&cpufreq_driver_lock, flags);
- 	for_each_cpu(j, policy->cpus) {
+ 	for_each_cpu(j, policy->cpus)
  		per_cpu(cpufreq_cpu_data, j) = policy;
- 		per_cpu(cpufreq_policy_cpu, j) = policy->cpu;
- 	}
  	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
  
 -	if (!frozen) {
 -		ret = cpufreq_add_dev_interface(policy, dev);
 -		if (ret)
 -			goto err_out_unregister;
 -	}
 -
 -	write_lock_irqsave(&cpufreq_driver_lock, flags);
 -	list_add(&policy->policy_list, &cpufreq_policy_list);
 -	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
 +	ret = cpufreq_add_dev_interface(cpu, policy, dev);
 +	if (ret)
 +		goto err_out_unregister;
  
  	cpufreq_init_policy(policy);
  
@@@ -1036,24 -1078,29 +1029,23 @@@ err_out_unregister
  	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
  
  err_set_policy_cpu:
++<<<<<<< HEAD
 +	per_cpu(cpufreq_policy_cpu, cpu) = -1;
 +	free_cpumask_var(policy->related_cpus);
 +err_free_cpumask:
 +	free_cpumask_var(policy->cpus);
 +err_free_policy:
 +	kfree(policy);
++=======
+ 	cpufreq_policy_free(policy);
++>>>>>>> 474deff744c4 (cpufreq: remove cpufreq_policy_cpu per-cpu variable)
  nomem_out:
  	up_read(&cpufreq_rwsem);
 -
  	return ret;
  }
  
 -/**
 - * cpufreq_add_dev - add a CPU device
 - *
 - * Adds the cpufreq interface for a CPU device.
 - *
 - * The Oracle says: try running cpufreq registration/unregistration concurrently
 - * with with cpu hotplugging and all hell will break loose. Tried to clean this
 - * mess up, but more thorough testing is needed. - Mathieu
 - */
 -static int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)
 -{
 -	return __cpufreq_add_dev(dev, sif, false);
 -}
 -
  static void update_policy_cpu(struct cpufreq_policy *policy, unsigned int cpu)
  {
- 	int j;
- 
  	policy->last_cpu = policy->cpu;
  	policy->cpu = cpu;
  
@@@ -1067,11 -1111,10 +1056,10 @@@
  			CPUFREQ_UPDATE_POLICY_CPU, policy);
  }
  
 -static int cpufreq_nominate_new_policy_cpu(struct cpufreq_policy *policy,
 -					   unsigned int old_cpu, bool frozen)
 +static int cpufreq_nominate_new_policy_cpu(struct cpufreq_policy *data,
 +					   unsigned int old_cpu)
  {
  	struct device *cpu_dev;
- 	unsigned long flags;
  	int ret;
  
  	/* first sibling now owns the new sysfs dir */
@@@ -1082,15 -1130,10 +1070,19 @@@
  		pr_err("%s: Failed to move kobj: %d", __func__, ret);
  
  		WARN_ON(lock_policy_rwsem_write(old_cpu));
++<<<<<<< HEAD
 +		cpumask_set_cpu(old_cpu, data->cpus);
 +
 +		write_lock_irqsave(&cpufreq_driver_lock, flags);
 +		per_cpu(cpufreq_cpu_data, old_cpu) = data;
 +		write_unlock_irqrestore(&cpufreq_driver_lock, flags);
 +
++=======
+ 		cpumask_set_cpu(old_cpu, policy->cpus);
++>>>>>>> 474deff744c4 (cpufreq: remove cpufreq_policy_cpu per-cpu variable)
  		unlock_policy_rwsem_write(old_cpu);
  
 -		ret = sysfs_create_link(&cpu_dev->kobj, &policy->kobj,
 +		ret = sysfs_create_link(&cpu_dev->kobj, &data->kobj,
  					"cpufreq");
  
  		return -EINVAL;
@@@ -1120,8 -1163,11 +1112,12 @@@ static int __cpufreq_remove_dev(struct 
  
  	write_lock_irqsave(&cpufreq_driver_lock, flags);
  
++<<<<<<< HEAD
 +	data = per_cpu(cpufreq_cpu_data, cpu);
 +	per_cpu(cpufreq_cpu_data, cpu) = NULL;
++=======
+ 	policy = per_cpu(cpufreq_cpu_data, cpu);
 -
 -	/* Save the policy somewhere when doing a light-weight tear-down */
 -	if (frozen)
 -		per_cpu(cpufreq_cpu_data_fallback, cpu) = policy;
++>>>>>>> 474deff744c4 (cpufreq: remove cpufreq_policy_cpu per-cpu variable)
  
  	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
  
* Unmerged path drivers/cpufreq/cpufreq.c
