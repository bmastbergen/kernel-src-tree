cif: fix dead code

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [fs] cifs: fix dead code (Sachin Prabhu) [1082049]
Rebuild_FUZZ: 97.30%
commit-author Michael Opdenacker <michael.opdenacker@free-electrons.com>
commit 1f80c0cc39e587edd06a36b43ba3a3b09d4ac428
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/1f80c0cc.failed

This issue was found by Coverity (CID 1202536)

This proposes a fix for a statement that creates dead code.
The "rc < 0" statement is within code that is run
with "rc > 0".

It seems like "err < 0" was meant to be used here.
This way, the error code is returned by the function.

	Signed-off-by: Michael Opdenacker <michael.opdenacker@free-electrons.com>
	Acked-by: Al Viro <viro@zeniv.linux.org.uk>
	Signed-off-by: Steve French <smfrench@gmail.com>
(cherry picked from commit 1f80c0cc39e587edd06a36b43ba3a3b09d4ac428)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/file.c
diff --cc fs/cifs/file.c
index c34438c63ed6,5ed03e0b8b40..000000000000
--- a/fs/cifs/file.c
+++ b/fs/cifs/file.c
@@@ -2587,23 -2586,25 +2587,37 @@@ cifs_writev(struct kiocb *iocb, const s
  	 * with a brlock that prevents writing.
  	 */
  	down_read(&cinode->lock_sem);
 -	mutex_lock(&inode->i_mutex);
 -	if (file->f_flags & O_APPEND)
 -		lock_pos = i_size_read(inode);
 -	if (!cifs_find_lock_conflict(cfile, lock_pos, iov_length(iov, nr_segs),
 +	if (!cifs_find_lock_conflict(cfile, pos, iov_length(iov, nr_segs),
  				     server->vals->exclusive_lock_type, NULL,
  				     CIFS_WRITE_OP)) {
++<<<<<<< HEAD
 +		mutex_lock(&inode->i_mutex);
 +		rc = __generic_file_aio_write(iocb, iov, nr_segs,
 +					       &iocb->ki_pos);
++=======
+ 		rc = __generic_file_aio_write(iocb, iov, nr_segs);
+ 		mutex_unlock(&inode->i_mutex);
+ 
+ 		if (rc > 0) {
+ 			ssize_t err;
+ 
+ 			err = generic_write_sync(file, iocb->ki_pos - rc, rc);
+ 			if (err < 0)
+ 				rc = err;
+ 		}
+ 	} else {
++>>>>>>> 1f80c0cc39e5 (cif: fix dead code)
  		mutex_unlock(&inode->i_mutex);
  	}
 +
 +	if (rc > 0 || rc == -EIOCBQUEUED) {
 +		ssize_t err;
 +
 +		err = generic_write_sync(file, pos, rc);
 +		if (err < 0 && rc > 0)
 +			rc = err;
 +	}
 +
  	up_read(&cinode->lock_sem);
  	return rc;
  }
* Unmerged path fs/cifs/file.c
