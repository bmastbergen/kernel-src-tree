xprtrdma: Make rpcrdma_ep_disconnect() return void

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Chuck Lever <chuck.lever@oracle.com>
commit 282191cb725db9a1aa80269e8369b06e9270a948
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/282191cb.failed

Clean up: The return code is used only for dprintk's that are
already redundant.

	Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
	Tested-by: Steve Wise <swise@opengridcomputing.com>
	Tested-by: Shirley Ma <shirley.ma@oracle.com>
	Tested-by: Devesh Sharma <devesh.sharma@emulex.com>
	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
(cherry picked from commit 282191cb725db9a1aa80269e8369b06e9270a948)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sunrpc/xprtrdma/verbs.c
diff --cc net/sunrpc/xprtrdma/verbs.c
index 499e0d7e7773,1208ab2e655f..000000000000
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@@ -851,11 -868,12 +848,20 @@@ rpcrdma_ep_connect(struct rpcrdma_ep *e
  		struct rpcrdma_xprt *xprt;
  retry:
  		dprintk("RPC:       %s: reconnecting...\n", __func__);
++<<<<<<< HEAD
 +		rc = rpcrdma_ep_disconnect(ep, ia);
 +		if (rc && rc != -ENOTCONN)
 +			dprintk("RPC:       %s: rpcrdma_ep_disconnect"
 +				" status %i\n", __func__, rc);
 +		rpcrdma_clean_cq(ep->rep_cq);
++=======
+ 
+ 		rpcrdma_ep_disconnect(ep, ia);
+ 		rpcrdma_flush_cqs(ep);
+ 
+ 		if (ia->ri_memreg_strategy == RPCRDMA_FRMR)
+ 			rpcrdma_reset_frmrs(ia);
++>>>>>>> 282191cb725d (xprtrdma: Make rpcrdma_ep_disconnect() return void)
  
  		xprt = container_of(ia, struct rpcrdma_xprt, rx_ia);
  		id = rpcrdma_create_id(xprt, ia,
@@@ -978,12 -996,93 +984,11 @@@ rpcrdma_ep_disconnect(struct rpcrdma_e
  		dprintk("RPC:       %s: rdma_disconnect %i\n", __func__, rc);
  		ep->rep_connected = rc;
  	}
- 	return rc;
  }
  
 -static int
 -rpcrdma_init_fmrs(struct rpcrdma_ia *ia, struct rpcrdma_buffer *buf)
 -{
 -	int mr_access_flags = IB_ACCESS_REMOTE_WRITE | IB_ACCESS_REMOTE_READ;
 -	struct ib_fmr_attr fmr_attr = {
 -		.max_pages	= RPCRDMA_MAX_DATA_SEGS,
 -		.max_maps	= 1,
 -		.page_shift	= PAGE_SHIFT
 -	};
 -	struct rpcrdma_mw *r;
 -	int i, rc;
 -
 -	i = (buf->rb_max_requests + 1) * RPCRDMA_MAX_SEGS;
 -	dprintk("RPC:       %s: initalizing %d FMRs\n", __func__, i);
 -
 -	while (i--) {
 -		r = kzalloc(sizeof(*r), GFP_KERNEL);
 -		if (r == NULL)
 -			return -ENOMEM;
 -
 -		r->r.fmr = ib_alloc_fmr(ia->ri_pd, mr_access_flags, &fmr_attr);
 -		if (IS_ERR(r->r.fmr)) {
 -			rc = PTR_ERR(r->r.fmr);
 -			dprintk("RPC:       %s: ib_alloc_fmr failed %i\n",
 -				__func__, rc);
 -			goto out_free;
 -		}
 -
 -		list_add(&r->mw_list, &buf->rb_mws);
 -		list_add(&r->mw_all, &buf->rb_all);
 -	}
 -	return 0;
 -
 -out_free:
 -	kfree(r);
 -	return rc;
 -}
 -
 -static int
 -rpcrdma_init_frmrs(struct rpcrdma_ia *ia, struct rpcrdma_buffer *buf)
 -{
 -	struct rpcrdma_frmr *f;
 -	struct rpcrdma_mw *r;
 -	int i, rc;
 -
 -	i = (buf->rb_max_requests + 1) * RPCRDMA_MAX_SEGS;
 -	dprintk("RPC:       %s: initalizing %d FRMRs\n", __func__, i);
 -
 -	while (i--) {
 -		r = kzalloc(sizeof(*r), GFP_KERNEL);
 -		if (r == NULL)
 -			return -ENOMEM;
 -		f = &r->r.frmr;
 -
 -		f->fr_mr = ib_alloc_fast_reg_mr(ia->ri_pd,
 -						ia->ri_max_frmr_depth);
 -		if (IS_ERR(f->fr_mr)) {
 -			rc = PTR_ERR(f->fr_mr);
 -			dprintk("RPC:       %s: ib_alloc_fast_reg_mr "
 -				"failed %i\n", __func__, rc);
 -			goto out_free;
 -		}
 -
 -		f->fr_pgl = ib_alloc_fast_reg_page_list(ia->ri_id->device,
 -							ia->ri_max_frmr_depth);
 -		if (IS_ERR(f->fr_pgl)) {
 -			rc = PTR_ERR(f->fr_pgl);
 -			dprintk("RPC:       %s: ib_alloc_fast_reg_page_list "
 -				"failed %i\n", __func__, rc);
 -
 -			ib_dereg_mr(f->fr_mr);
 -			goto out_free;
 -		}
 -
 -		list_add(&r->mw_list, &buf->rb_mws);
 -		list_add(&r->mw_all, &buf->rb_all);
 -	}
 -
 -	return 0;
 -
 -out_free:
 -	kfree(r);
 -	return rc;
 -}
 -
 +/*
 + * Initialize buffer memory
 + */
  int
  rpcrdma_buffer_create(struct rpcrdma_buffer *buf, struct rpcrdma_ep *ep,
  	struct rpcrdma_ia *ia, struct rpcrdma_create_data_internal *cdata)
diff --git a/net/sunrpc/xprtrdma/transport.c b/net/sunrpc/xprtrdma/transport.c
index 3f26245da10e..bad461e45ac7 100644
--- a/net/sunrpc/xprtrdma/transport.c
+++ b/net/sunrpc/xprtrdma/transport.c
@@ -414,7 +414,7 @@ xprt_rdma_close(struct rpc_xprt *xprt)
 	if (r_xprt->rx_ep.rep_connected > 0)
 		xprt->reestablish_timeout = 0;
 	xprt_disconnect_done(xprt);
-	(void) rpcrdma_ep_disconnect(&r_xprt->rx_ep, &r_xprt->rx_ia);
+	rpcrdma_ep_disconnect(&r_xprt->rx_ep, &r_xprt->rx_ia);
 }
 
 static void
* Unmerged path net/sunrpc/xprtrdma/verbs.c
diff --git a/net/sunrpc/xprtrdma/xprt_rdma.h b/net/sunrpc/xprtrdma/xprt_rdma.h
index 4ef6e3f9b67c..80d8f92be85e 100644
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@ -306,7 +306,7 @@ int rpcrdma_ep_create(struct rpcrdma_ep *, struct rpcrdma_ia *,
 				struct rpcrdma_create_data_internal *);
 void rpcrdma_ep_destroy(struct rpcrdma_ep *, struct rpcrdma_ia *);
 int rpcrdma_ep_connect(struct rpcrdma_ep *, struct rpcrdma_ia *);
-int rpcrdma_ep_disconnect(struct rpcrdma_ep *, struct rpcrdma_ia *);
+void rpcrdma_ep_disconnect(struct rpcrdma_ep *, struct rpcrdma_ia *);
 
 int rpcrdma_ep_post(struct rpcrdma_ia *, struct rpcrdma_ep *,
 				struct rpcrdma_req *);
