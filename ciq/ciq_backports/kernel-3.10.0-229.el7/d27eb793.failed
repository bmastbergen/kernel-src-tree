Input: alps - v7: fix finger counting for > 2 fingers on clickpads

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [input] alps: v7 - fix finger counting for > 2 fingers on clickpads (Benjamin Tissoires) [1107819]
Rebuild_FUZZ: 89.60%
commit-author Hans de Goede <hdegoede@redhat.com>
commit d27eb7931c98a1ebfc9b2fcc48939846bcbfc804
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/d27eb793.failed

Protocol v7 uses the middle / right button bits on clickpads to communicate
"location" information of a 3th touch (and possible 4th) touch on
clickpads.

Specifically when 3 touches are down, if one of the 3 touches is in the
left / right button area, this will get reported in the middle / right
button bits and the touchpad will still send a TWO type packet rather then
a MULTI type packet, so when this happens we must add the finger reported
in the button area to the finger count.

Likewise we must also add fingers reported this way to the finger count
when we get MULTI packets.

BugLink: https://bugs.freedesktop.org/show_bug.cgi?id=86338
	Cc: stable@vger.kernel.org # 3.17
	Signed-off-by: Hans de Goede <hdegoede@redhat.com>
	Tested-by: Benjamin Tissoires <benjamin.tissoires@redhat.com>
	Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
(cherry picked from commit d27eb7931c98a1ebfc9b2fcc48939846bcbfc804)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/input/mouse/alps.c
diff --cc drivers/input/mouse/alps.c
index 566ef5285082,b48c6fb317ed..000000000000
--- a/drivers/input/mouse/alps.c
+++ b/drivers/input/mouse/alps.c
@@@ -842,6 -846,221 +842,224 @@@ static void alps_process_packet_v4(stru
  	alps_report_semi_mt_data(psmouse, f->fingers);
  }
  
++<<<<<<< HEAD
++=======
+ static bool alps_is_valid_package_v7(struct psmouse *psmouse)
+ {
+ 	switch (psmouse->pktcnt) {
+ 	case 3:
+ 		return (psmouse->packet[2] & 0x40) == 0x40;
+ 	case 4:
+ 		return (psmouse->packet[3] & 0x48) == 0x48;
+ 	case 6:
+ 		return (psmouse->packet[5] & 0x40) == 0x00;
+ 	}
+ 	return true;
+ }
+ 
+ static unsigned char alps_get_packet_id_v7(char *byte)
+ {
+ 	unsigned char packet_id;
+ 
+ 	if (byte[4] & 0x40)
+ 		packet_id = V7_PACKET_ID_TWO;
+ 	else if (byte[4] & 0x01)
+ 		packet_id = V7_PACKET_ID_MULTI;
+ 	else if ((byte[0] & 0x10) && !(byte[4] & 0x43))
+ 		packet_id = V7_PACKET_ID_NEW;
+ 	else if (byte[1] == 0x00 && byte[4] == 0x00)
+ 		packet_id = V7_PACKET_ID_IDLE;
+ 	else
+ 		packet_id = V7_PACKET_ID_UNKNOWN;
+ 
+ 	return packet_id;
+ }
+ 
+ static void alps_get_finger_coordinate_v7(struct input_mt_pos *mt,
+ 					  unsigned char *pkt,
+ 					  unsigned char pkt_id)
+ {
+ 	mt[0].x = ((pkt[2] & 0x80) << 4);
+ 	mt[0].x |= ((pkt[2] & 0x3F) << 5);
+ 	mt[0].x |= ((pkt[3] & 0x30) >> 1);
+ 	mt[0].x |= (pkt[3] & 0x07);
+ 	mt[0].y = (pkt[1] << 3) | (pkt[0] & 0x07);
+ 
+ 	mt[1].x = ((pkt[3] & 0x80) << 4);
+ 	mt[1].x |= ((pkt[4] & 0x80) << 3);
+ 	mt[1].x |= ((pkt[4] & 0x3F) << 4);
+ 	mt[1].y = ((pkt[5] & 0x80) << 3);
+ 	mt[1].y |= ((pkt[5] & 0x3F) << 4);
+ 
+ 	switch (pkt_id) {
+ 	case V7_PACKET_ID_TWO:
+ 		mt[1].x &= ~0x000F;
+ 		mt[1].y |= 0x000F;
+ 		break;
+ 
+ 	case V7_PACKET_ID_MULTI:
+ 		mt[1].x &= ~0x003F;
+ 		mt[1].y &= ~0x0020;
+ 		mt[1].y |= ((pkt[4] & 0x02) << 4);
+ 		mt[1].y |= 0x001F;
+ 		break;
+ 
+ 	case V7_PACKET_ID_NEW:
+ 		mt[1].x &= ~0x003F;
+ 		mt[1].x |= (pkt[0] & 0x20);
+ 		mt[1].y |= 0x000F;
+ 		break;
+ 	}
+ 
+ 	mt[0].y = 0x7FF - mt[0].y;
+ 	mt[1].y = 0x7FF - mt[1].y;
+ }
+ 
+ static int alps_get_mt_count(struct input_mt_pos *mt)
+ {
+ 	int i, fingers = 0;
+ 
+ 	for (i = 0; i < MAX_TOUCHES; i++) {
+ 		if (mt[i].x != 0 || mt[i].y != 0)
+ 			fingers++;
+ 	}
+ 
+ 	return fingers;
+ }
+ 
+ static int alps_decode_packet_v7(struct alps_fields *f,
+ 				  unsigned char *p,
+ 				  struct psmouse *psmouse)
+ {
+ 	struct alps_data *priv = psmouse->private;
+ 	unsigned char pkt_id;
+ 
+ 	pkt_id = alps_get_packet_id_v7(p);
+ 	if (pkt_id == V7_PACKET_ID_IDLE)
+ 		return 0;
+ 	if (pkt_id == V7_PACKET_ID_UNKNOWN)
+ 		return -1;
+ 	/*
+ 	 * NEW packets are send to indicate a discontinuity in the finger
+ 	 * coordinate reporting. Specifically a finger may have moved from
+ 	 * slot 0 to 1 or vice versa. INPUT_MT_TRACK takes care of this for
+ 	 * us.
+ 	 *
+ 	 * NEW packets have 3 problems:
+ 	 * 1) They do not contain middle / right button info (on non clickpads)
+ 	 *    this can be worked around by preserving the old button state
+ 	 * 2) They do not contain an accurate fingercount, and they are
+ 	 *    typically send when the number of fingers changes. We cannot use
+ 	 *    the old finger count as that may mismatch with the amount of
+ 	 *    touch coordinates we've available in the NEW packet
+ 	 * 3) Their x data for the second touch is inaccurate leading to
+ 	 *    a possible jump of the x coordinate by 16 units when the first
+ 	 *    non NEW packet comes in
+ 	 * Since problems 2 & 3 cannot be worked around, just ignore them.
+ 	 */
+ 	if (pkt_id == V7_PACKET_ID_NEW)
+ 		return 1;
+ 
+ 	alps_get_finger_coordinate_v7(f->mt, p, pkt_id);
+ 
+ 	if (pkt_id == V7_PACKET_ID_TWO)
+ 		f->fingers = alps_get_mt_count(f->mt);
+ 	else /* pkt_id == V7_PACKET_ID_MULTI */
+ 		f->fingers = 3 + (p[5] & 0x03);
+ 
+ 	f->left = (p[0] & 0x80) >> 7;
+ 	if (priv->flags & ALPS_BUTTONPAD) {
+ 		if (p[0] & 0x20)
+ 			f->fingers++;
+ 		if (p[0] & 0x10)
+ 			f->fingers++;
+ 	} else {
+ 		f->right = (p[0] & 0x20) >> 5;
+ 		f->middle = (p[0] & 0x10) >> 4;
+ 	}
+ 
+ 	/* Sometimes a single touch is reported in mt[1] rather then mt[0] */
+ 	if (f->fingers == 1 && f->mt[0].x == 0 && f->mt[0].y == 0) {
+ 		f->mt[0].x = f->mt[1].x;
+ 		f->mt[0].y = f->mt[1].y;
+ 		f->mt[1].x = 0;
+ 		f->mt[1].y = 0;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static void alps_process_trackstick_packet_v7(struct psmouse *psmouse)
+ {
+ 	struct alps_data *priv = psmouse->private;
+ 	unsigned char *packet = psmouse->packet;
+ 	struct input_dev *dev2 = priv->dev2;
+ 	int x, y, z, left, right, middle;
+ 
+ 	/*
+ 	 *        b7 b6 b5 b4 b3 b2 b1 b0
+ 	 * Byte0   0  1  0  0  1  0  0  0
+ 	 * Byte1   1  1  *  *  1  M  R  L
+ 	 * Byte2  X7  1 X5 X4 X3 X2 X1 X0
+ 	 * Byte3  Z6  1 Y6 X6  1 Y2 Y1 Y0
+ 	 * Byte4  Y7  0 Y5 Y4 Y3  1  1  0
+ 	 * Byte5 T&P  0 Z5 Z4 Z3 Z2 Z1 Z0
+ 	 * M / R / L: Middle / Right / Left button
+ 	 */
+ 
+ 	x = ((packet[2] & 0xbf)) | ((packet[3] & 0x10) << 2);
+ 	y = (packet[3] & 0x07) | (packet[4] & 0xb8) |
+ 	    ((packet[3] & 0x20) << 1);
+ 	z = (packet[5] & 0x3f) | ((packet[3] & 0x80) >> 1);
+ 
+ 	left = (packet[1] & 0x01);
+ 	right = (packet[1] & 0x02) >> 1;
+ 	middle = (packet[1] & 0x04) >> 2;
+ 
+ 	/* Divide 2 since trackpoint's speed is too fast */
+ 	input_report_rel(dev2, REL_X, (char)x / 2);
+ 	input_report_rel(dev2, REL_Y, -((char)y / 2));
+ 
+ 	input_report_key(dev2, BTN_LEFT, left);
+ 	input_report_key(dev2, BTN_RIGHT, right);
+ 	input_report_key(dev2, BTN_MIDDLE, middle);
+ 
+ 	input_sync(dev2);
+ }
+ 
+ static void alps_process_touchpad_packet_v7(struct psmouse *psmouse)
+ {
+ 	struct alps_data *priv = psmouse->private;
+ 	struct input_dev *dev = psmouse->dev;
+ 	struct alps_fields *f = &priv->f;
+ 
+ 	memset(f, 0, sizeof(*f));
+ 
+ 	if (priv->decode_fields(f, psmouse->packet, psmouse))
+ 		return;
+ 
+ 	alps_report_mt_data(psmouse, alps_get_mt_count(f->mt));
+ 
+ 	input_mt_report_finger_count(dev, f->fingers);
+ 
+ 	input_report_key(dev, BTN_LEFT, f->left);
+ 	input_report_key(dev, BTN_RIGHT, f->right);
+ 	input_report_key(dev, BTN_MIDDLE, f->middle);
+ 
+ 	input_sync(dev);
+ }
+ 
+ static void alps_process_packet_v7(struct psmouse *psmouse)
+ {
+ 	unsigned char *packet = psmouse->packet;
+ 
+ 	if (packet[0] == 0x48 && (packet[4] & 0x47) == 0x06)
+ 		alps_process_trackstick_packet_v7(psmouse);
+ 	else
+ 		alps_process_touchpad_packet_v7(psmouse);
+ }
+ 
++>>>>>>> d27eb7931c98 (Input: alps - v7: fix finger counting for > 2 fingers on clickpads)
  static void alps_report_bare_ps2_packet(struct psmouse *psmouse,
  					unsigned char packet[],
  					bool report_buttons)
* Unmerged path drivers/input/mouse/alps.c
