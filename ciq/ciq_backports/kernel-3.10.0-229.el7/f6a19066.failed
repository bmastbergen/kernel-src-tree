drm/i915: Do a dummy DPCD read before the actual read

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] i915: Do a dummy DPCD read before the actual read (Rob Clark) [1173317]
Rebuild_FUZZ: 96.08%
commit-author Ville Syrj채l채 <ville.syrjala@linux.intel.com>
commit f6a1906674005377b64ee5431c1418077c1b2425
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/f6a19066.failed

Sometimes we seem to get utter garbage from DPCD reads. The resulting
buffer is filled with the same byte, and the operation completed without
errors. My HP ZR24w monitor seems particularly susceptible to this
problem once it's gone into a sleep mode.

The issue seems to happen only for the first AUX message that wakes the
sink up. But as the first AUX read we often do is the DPCD receiver
cap it does wreak a bit of havoc with subsequent link training etc. when
the receiver cap bw/lane/etc. information is garbage.

A sufficient workaround seems to be to perform a single byte dummy read
before reading the actual data. I suppose that just wakes up the sink
sufficiently and we can just throw away the returned data in case it's
crap. DP_DPCD_REV seems like a sufficiently safe location to read here.

	Signed-off-by: Ville Syrj채l채 <ville.syrjala@linux.intel.com>
	Reviewed-by: Todd Previte <tprevite@gmail.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
(cherry picked from commit f6a1906674005377b64ee5431c1418077c1b2425)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_dp.c
diff --cc drivers/gpu/drm/i915/intel_dp.c
index a4f2fedc61d6,f9c5f17af9d8..000000000000
--- a/drivers/gpu/drm/i915/intel_dp.c
+++ b/drivers/gpu/drm/i915/intel_dp.c
@@@ -1811,22 -2795,28 +1811,31 @@@ static void intel_dp_pre_pll_enable(str
  /*
   * Native read with retry for link status and receiver capability reads for
   * cases where the sink may still be asleep.
 - *
 - * Sinks are *supposed* to come up within 1ms from an off state, but we're also
 - * supposed to retry 3 times per the spec.
   */
 -static ssize_t
 -intel_dp_dpcd_read_wake(struct drm_dp_aux *aux, unsigned int offset,
 -			void *buffer, size_t size)
 +static bool
 +intel_dp_aux_native_read_retry(struct intel_dp *intel_dp, uint16_t address,
 +			       uint8_t *recv, int recv_bytes)
  {
 -	ssize_t ret;
 -	int i;
 +	int ret, i;
  
  	/*
++<<<<<<< HEAD
 +	 * Sinks are *supposed* to come up within 1ms from an off state,
 +	 * but we're also supposed to retry 3 times per the spec.
 +	 */
++=======
+ 	 * Sometime we just get the same incorrect byte repeated
+ 	 * over the entire buffer. Doing just one throw away read
+ 	 * initially seems to "solve" it.
+ 	 */
+ 	drm_dp_dpcd_read(aux, DP_DPCD_REV, buffer, 1);
+ 
++>>>>>>> f6a190667400 (drm/i915: Do a dummy DPCD read before the actual read)
  	for (i = 0; i < 3; i++) {
 -		ret = drm_dp_dpcd_read(aux, offset, buffer, size);
 -		if (ret == size)
 -			return ret;
 +		ret = intel_dp_aux_native_read(intel_dp, address, recv,
 +					       recv_bytes);
 +		if (ret == recv_bytes)
 +			return true;
  		msleep(1);
  	}
  
* Unmerged path drivers/gpu/drm/i915/intel_dp.c
