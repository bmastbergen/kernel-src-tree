ipv4: irq safe sk_dst_[re]set() and ipv4_sk_update_pmtu() fix

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Eric Dumazet <edumazet@google.com>
commit 7f502361531e9eecb396cf99bdc9e9a59f7ebd7f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/7f502361.failed

We have two different ways to handle changes to sk->sk_dst

First way (used by TCP) assumes socket lock is owned by caller, and use
no extra lock : __sk_dst_set() & __sk_dst_reset()

Another way (used by UDP) uses sk_dst_lock because socket lock is not
always taken. Note that sk_dst_lock is not softirq safe.

These ways are not inter changeable for a given socket type.

ipv4_sk_update_pmtu(), added in linux-3.8, added a race, as it used
the socket lock as synchronization, but users might be UDP sockets.

Instead of converting sk_dst_lock to a softirq safe version, use xchg()
as we did for sk_rx_dst in commit e47eb5dfb296b ("udp: ipv4: do not use
sk_dst_lock from softirq context")

In a follow up patch, we probably can remove sk_dst_lock, as it is
only used in IPv6.

	Signed-off-by: Eric Dumazet <edumazet@google.com>
	Cc: Steffen Klassert <steffen.klassert@secunet.com>
Fixes: 9cb3a50c5f63e ("ipv4: Invalidate the socket cached route on pmtu events if possible")
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7f502361531e9eecb396cf99bdc9e9a59f7ebd7f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/route.c
diff --cc net/ipv4/route.c
index ce17fb5a888d,3162ea923ded..000000000000
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@@ -1013,9 -1014,13 +1013,17 @@@ void ipv4_sk_update_pmtu(struct sk_buf
  	bool new = false;
  
  	bh_lock_sock(sk);
++<<<<<<< HEAD
 +	rt = (struct rtable *) __sk_dst_get(sk);
++=======
  
- 	if (sock_owned_by_user(sk) || !rt) {
+ 	if (!ip_sk_accept_pmtu(sk))
+ 		goto out;
+ 
+ 	odst = sk_dst_get(sk);
++>>>>>>> 7f502361531e (ipv4: irq safe sk_dst_[re]set() and ipv4_sk_update_pmtu() fix)
+ 
+ 	if (sock_owned_by_user(sk) || !odst) {
  		__ipv4_sk_update_pmtu(skb, sk, mtu);
  		goto out;
  	}
diff --git a/include/net/sock.h b/include/net/sock.h
index 64ff6c79a908..0b66545f329e 100644
--- a/include/net/sock.h
+++ b/include/net/sock.h
@@ -1808,9 +1808,11 @@ __sk_dst_set(struct sock *sk, struct dst_entry *dst)
 static inline void
 sk_dst_set(struct sock *sk, struct dst_entry *dst)
 {
-	spin_lock(&sk->sk_dst_lock);
-	__sk_dst_set(sk, dst);
-	spin_unlock(&sk->sk_dst_lock);
+	struct dst_entry *old_dst;
+
+	sk_tx_queue_clear(sk);
+	old_dst = xchg(&sk->sk_dst_cache, dst);
+	dst_release(old_dst);
 }
 
 static inline void
@@ -1822,9 +1824,7 @@ __sk_dst_reset(struct sock *sk)
 static inline void
 sk_dst_reset(struct sock *sk)
 {
-	spin_lock(&sk->sk_dst_lock);
-	__sk_dst_reset(sk);
-	spin_unlock(&sk->sk_dst_lock);
+	sk_dst_set(sk, NULL);
 }
 
 extern struct dst_entry *__sk_dst_check(struct sock *sk, u32 cookie);
* Unmerged path net/ipv4/route.c
