ACPI / bind: Redefine acpi_preset_companion()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] bind: Redefine acpi_preset_companion() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 91.57%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 9c5ad36d987a1b06f6b0b9dc7bc61a45d277455d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/9c5ad36d.failed

Modify acpi_preset_companion() to take a struct acpi_device pointer
instead of an ACPI handle as its second argument and redefine it as
a static inline wrapper around ACPI_COMPANION_SET() passing the
return value of acpi_find_child_device() directly as the second
argument to it.  Update its users to pass struct acpi_device
pointers instead of ACPI handles to it.

This allows some unnecessary acpi_bus_get_device() calls to be
avoided.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Reviewed-by: Aaron Lu <aaron.lu@intel.com>
	Tested-by: Aaron Lu <aaron.lu@intel.com> # for ATA binding
(cherry picked from commit 9c5ad36d987a1b06f6b0b9dc7bc61a45d277455d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/ata/libata-acpi.c
#	drivers/mmc/core/sdio_bus.c
#	include/acpi/acpi_bus.h
#	include/linux/acpi.h
diff --cc drivers/ata/libata-acpi.c
index da8170dfc90f,9e69a5308693..000000000000
--- a/drivers/ata/libata-acpi.c
+++ b/drivers/ata/libata-acpi.c
@@@ -216,37 -175,55 +216,80 @@@ static const struct acpi_dock_ops ata_a
  	.uevent = ata_acpi_ap_uevent,
  };
  
 -/* bind acpi handle to pata port */
 -void ata_acpi_bind_port(struct ata_port *ap)
 +void ata_acpi_hotplug_init(struct ata_host *host)
  {
++<<<<<<< HEAD
 +	int i;
 +
 +	for (i = 0; i < host->n_ports; i++) {
 +		struct ata_port *ap = host->ports[i];
 +		acpi_handle handle;
 +		struct ata_device *dev;
 +
 +		if (!ap)
 +			continue;
++=======
+ 	struct acpi_device *host_companion = ACPI_COMPANION(ap->host->dev);
+ 
+ 	if (libata_noacpi || ap->flags & ATA_FLAG_ACPI_SATA || !host_companion)
+ 		return;
+ 
+ 	acpi_preset_companion(&ap->tdev, host_companion, ap->port_no);
++>>>>>>> 9c5ad36d987a (ACPI / bind: Redefine acpi_preset_companion())
 +
 +		handle = ata_ap_acpi_handle(ap);
 +		if (handle) {
 +			/* we might be on a docking station */
 +			register_hotplug_dock_device(handle,
 +						     &ata_acpi_ap_dock_ops, ap,
 +						     NULL, NULL);
 +		}
  
 -	if (ata_acpi_gtm(ap, &ap->__acpi_init_gtm) == 0)
 -		ap->pflags |= ATA_PFLAG_INIT_GTM_VALID;
 -
 -	/* we might be on a docking station */
 -	register_hotplug_dock_device(ACPI_HANDLE(&ap->tdev),
 -				     &ata_acpi_ap_dock_ops, ap, NULL, NULL);
 -}
 +		ata_for_each_dev(dev, &ap->link, ALL) {
 +			handle = ata_dev_acpi_handle(dev);
 +			if (!handle)
 +				continue;
  
++<<<<<<< HEAD
 +			/* we might be on a docking station */
 +			register_hotplug_dock_device(handle,
 +						     &ata_acpi_dev_dock_ops,
 +						     dev, NULL, NULL);
 +		}
 +	}
++=======
+ void ata_acpi_bind_dev(struct ata_device *dev)
+ {
+ 	struct ata_port *ap = dev->link->ap;
+ 	struct acpi_device *port_companion = ACPI_COMPANION(&ap->tdev);
+ 	struct acpi_device *host_companion = ACPI_COMPANION(ap->host->dev);
+ 	struct acpi_device *parent;
+ 	u64 adr;
+ 
+ 	/*
+ 	 * For both sata/pata devices, host companion device is required.
+ 	 * For pata device, port companion device is also required.
+ 	 */
+ 	if (libata_noacpi || !host_companion ||
+ 			(!(ap->flags & ATA_FLAG_ACPI_SATA) && !port_companion))
+ 		return;
+ 
+ 	if (ap->flags & ATA_FLAG_ACPI_SATA) {
+ 		if (!sata_pmp_attached(ap))
+ 			adr = SATA_ADR(ap->port_no, NO_PORT_MULT);
+ 		else
+ 			adr = SATA_ADR(ap->port_no, dev->link->pmp);
+ 		parent = host_companion;
+ 	} else {
+ 		adr = dev->devno;
+ 		parent = port_companion;
+ 	}
+ 
+ 	acpi_preset_companion(&dev->tdev, parent, adr);
+ 
+ 	register_hotplug_dock_device(ata_dev_acpi_handle(dev),
+ 				     &ata_acpi_dev_dock_ops, dev, NULL, NULL);
++>>>>>>> 9c5ad36d987a (ACPI / bind: Redefine acpi_preset_companion())
  }
  
  /**
diff --cc drivers/mmc/core/sdio_bus.c
index 6d67492a9247,92d1ba8e8153..000000000000
--- a/drivers/mmc/core/sdio_bus.c
+++ b/drivers/mmc/core/sdio_bus.c
@@@ -305,8 -308,7 +305,12 @@@ static void sdio_acpi_set_handle(struc
  	struct mmc_host *host = func->card->host;
  	u64 addr = (host->slotno << 16) | func->num;
  
++<<<<<<< HEAD
 +	ACPI_HANDLE_SET(&func->dev,
 +			acpi_get_child(ACPI_HANDLE(host->parent), addr));
++=======
+ 	acpi_preset_companion(&func->dev, ACPI_COMPANION(host->parent), addr);
++>>>>>>> 9c5ad36d987a (ACPI / bind: Redefine acpi_preset_companion())
  }
  #else
  static inline void sdio_acpi_set_handle(struct sdio_func *func) {}
diff --cc include/acpi/acpi_bus.h
index f5d6e1e4030e,918eaab892e1..000000000000
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@@ -440,14 -434,9 +440,18 @@@ struct acpi_pci_root 
  
  struct acpi_device *acpi_find_child_device(struct acpi_device *parent,
  					   u64 address, bool check_children);
++<<<<<<< HEAD
 +acpi_handle acpi_find_child(acpi_handle, u64, bool);
 +static inline acpi_handle acpi_get_child(acpi_handle handle, u64 addr)
 +{
 +	return acpi_find_child(handle, addr, false);
 +}
++=======
+ acpi_handle acpi_get_child(acpi_handle handle, u64 addr);
++>>>>>>> 9c5ad36d987a (ACPI / bind: Redefine acpi_preset_companion())
  int acpi_is_root_bridge(acpi_handle);
  struct acpi_pci_root *acpi_pci_find_root(acpi_handle handle);
 +#define DEVICE_ACPI_HANDLE(dev) ((acpi_handle)ACPI_HANDLE(dev))
  
  int acpi_enable_wakeup_device_power(struct acpi_device *dev, int state);
  int acpi_disable_wakeup_device_power(struct acpi_device *dev);
diff --cc include/linux/acpi.h
index 73fb5592c8db,115c610324d1..000000000000
--- a/include/linux/acpi.h
+++ b/include/linux/acpi.h
@@@ -44,6 -44,26 +44,29 @@@
  #include <acpi/acpi_numa.h>
  #include <asm/acpi.h>
  
++<<<<<<< HEAD
++=======
+ static inline acpi_handle acpi_device_handle(struct acpi_device *adev)
+ {
+ 	return adev ? adev->handle : NULL;
+ }
+ 
+ #define ACPI_COMPANION(dev)		((dev)->acpi_node.companion)
+ #define ACPI_COMPANION_SET(dev, adev)	ACPI_COMPANION(dev) = (adev)
+ #define ACPI_HANDLE(dev)		acpi_device_handle(ACPI_COMPANION(dev))
+ 
+ static inline void acpi_preset_companion(struct device *dev,
+ 					 struct acpi_device *parent, u64 addr)
+ {
+ 	ACPI_COMPANION_SET(dev, acpi_find_child_device(parent, addr, NULL));
+ }
+ 
+ static inline const char *acpi_dev_name(struct acpi_device *adev)
+ {
+ 	return dev_name(&adev->dev);
+ }
+ 
++>>>>>>> 9c5ad36d987a (ACPI / bind: Redefine acpi_preset_companion())
  enum acpi_irq_model_id {
  	ACPI_IRQ_MODEL_PIC = 0,
  	ACPI_IRQ_MODEL_IOAPIC,
diff --git a/drivers/acpi/glue.c b/drivers/acpi/glue.c
index 7b82e04a359a..333ccd841dc5 100644
--- a/drivers/acpi/glue.c
+++ b/drivers/acpi/glue.c
@@ -149,6 +149,7 @@ struct acpi_device *acpi_find_child_device(struct acpi_device *parent,
 	}
 	return ret;
 }
+EXPORT_SYMBOL_GPL(acpi_find_child_device);
 
 acpi_handle acpi_find_child(acpi_handle handle, u64 addr, bool is_bridge)
 {
* Unmerged path drivers/ata/libata-acpi.c
* Unmerged path drivers/mmc/core/sdio_bus.c
* Unmerged path include/acpi/acpi_bus.h
* Unmerged path include/linux/acpi.h
