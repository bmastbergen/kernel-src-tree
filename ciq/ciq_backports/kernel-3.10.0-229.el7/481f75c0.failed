x86/efi: Cleanup efi_enter_virtual_mode() function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [firmware] efi: Cleanup efi_enter_virtual_mode() function (Dave Young) [1080109]
Rebuild_FUZZ: 95.83%
commit-author Dave Young <dyoung@redhat.com>
commit 481f75c043cf44ec11c7fbdbbf37d43463f1e719
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/481f75c0.failed

Add two small functions:
efi_merge_regions() and efi_map_regions(), efi_enter_virtual_mode()
calls them instead of embedding two long for loop.

	Signed-off-by: Dave Young <dyoung@redhat.com>
	Acked-by: Borislav Petkov <bp@suse.de>
	Tested-by: Toshi Kani <toshi.kani@hp.com>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit 481f75c043cf44ec11c7fbdbbf37d43463f1e719)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/platform/efi/efi.c
diff --cc arch/x86/platform/efi/efi.c
index 4753e06eea3d,4694632ef581..000000000000
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@@ -745,36 -747,38 +745,72 @@@ void efi_memory_uc(u64 addr, unsigned l
  	set_memory_uc(addr, npages);
  }
  
++<<<<<<< HEAD
 +/*
 + * This function will switch the EFI runtime services to virtual mode.
 + * Essentially, look through the EFI memmap and map every region that
 + * has the runtime attribute bit set in its memory descriptor and update
 + * that memory descriptor with the virtual address obtained from ioremap().
 + * This enables the runtime services to be called without having to
 + * thunk back into physical mode for every invocation.
 + */
 +void __init efi_enter_virtual_mode(void)
++=======
+ void __init old_map_region(efi_memory_desc_t *md)
  {
+ 	u64 start_pfn, end_pfn, end;
+ 	unsigned long size;
+ 	void *va;
+ 
+ 	start_pfn = PFN_DOWN(md->phys_addr);
+ 	size	  = md->num_pages << PAGE_SHIFT;
+ 	end	  = md->phys_addr + size;
+ 	end_pfn   = PFN_UP(end);
+ 
+ 	if (pfn_range_is_mapped(start_pfn, end_pfn)) {
+ 		va = __va(md->phys_addr);
+ 
+ 		if (!(md->attribute & EFI_MEMORY_WB))
+ 			efi_memory_uc((u64)(unsigned long)va, size);
+ 	} else
+ 		va = efi_ioremap(md->phys_addr, size,
+ 				 md->type, md->attribute);
+ 
+ 	md->virt_addr = (u64) (unsigned long) va;
+ 	if (!va)
+ 		pr_err("ioremap of 0x%llX failed!\n",
+ 		       (unsigned long long)md->phys_addr);
+ }
+ 
+ /* Merge contiguous regions of the same type and attribute */
+ static void __init efi_merge_regions(void)
++>>>>>>> 481f75c043cf (x86/efi: Cleanup efi_enter_virtual_mode() function)
+ {
+ 	void *p;
  	efi_memory_desc_t *md, *prev_md = NULL;
++<<<<<<< HEAD
 +	efi_status_t status;
 +	unsigned long size;
 +	u64 end, systab, start_pfn, end_pfn;
 +	void *p, *va, *new_memmap = NULL;
 +	int count = 0;
 +
 +	efi.systab = NULL;
 +
 +	/*
 +	 * We don't do virtual mode, since we don't do runtime services, on
 +	 * non-native EFI
 +	 */
 +
 +	if (!efi_is_native()) {
 +		efi_unmap_memmap();
 +		return;
 +	}
 +
 +	/* Merge contiguous regions of the same type and attribute */
++=======
+ 
++>>>>>>> 481f75c043cf (x86/efi: Cleanup efi_enter_virtual_mode() function)
  	for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
  		u64 prev_size;
  		md = p;
@@@ -811,42 -839,65 +871,102 @@@ static void * __init efi_map_regions(in
  				continue;
  		}
  
++<<<<<<< HEAD
 +		size = md->num_pages << EFI_PAGE_SHIFT;
 +		end = md->phys_addr + size;
 +
 +		start_pfn = PFN_DOWN(md->phys_addr);
 +		end_pfn = PFN_UP(end);
 +		if (pfn_range_is_mapped(start_pfn, end_pfn)) {
 +			va = __va(md->phys_addr);
 +
 +			if (!(md->attribute & EFI_MEMORY_WB))
 +				efi_memory_uc((u64)(unsigned long)va, size);
 +		} else
 +			va = efi_ioremap(md->phys_addr, size,
 +					 md->type, md->attribute);
 +
 +		md->virt_addr = (u64) (unsigned long) va;
 +
 +		if (!va) {
 +			pr_err("ioremap of 0x%llX failed!\n",
 +			       (unsigned long long)md->phys_addr);
 +			continue;
 +		}
 +
 +		systab = (u64) (unsigned long) efi_phys.systab;
 +		if (md->phys_addr <= systab && systab < end) {
 +			systab += md->virt_addr - md->phys_addr;
 +			efi.systab = (efi_system_table_t *) (unsigned long) systab;
 +		}
 +		new_memmap = krealloc(new_memmap,
 +				      (count + 1) * memmap.desc_size,
 +				      GFP_KERNEL);
 +		if (!new_memmap)
 +			goto err_out;
 +
 +		memcpy(new_memmap + (count * memmap.desc_size), md,
++=======
+ 		efi_map_region(md);
+ 		get_systab_virt_addr(md);
+ 
+ 		tmp = krealloc(new_memmap, (*count + 1) * memmap.desc_size,
+ 			       GFP_KERNEL);
+ 		if (!tmp)
+ 			goto out_krealloc;
+ 		new_memmap = tmp;
+ 		memcpy(new_memmap + (*count * memmap.desc_size), md,
++>>>>>>> 481f75c043cf (x86/efi: Cleanup efi_enter_virtual_mode() function)
  		       memmap.desc_size);
- 		count++;
+ 		(*count)++;
+ 	}
+ 
+ 	return new_memmap;
+ out_krealloc:
+ 	kfree(new_memmap);
+ 	return NULL;
+ }
+ 
+ /*
+  * This function will switch the EFI runtime services to virtual mode.
+  * Essentially, we look through the EFI memmap and map every region that
+  * has the runtime attribute bit set in its memory descriptor into the
+  * ->trampoline_pgd page table using a top-down VA allocation scheme.
+  *
+  * The old method which used to update that memory descriptor with the
+  * virtual address obtained from ioremap() is still supported when the
+  * kernel is booted with efi=old_map on its command line. Same old
+  * method enabled the runtime services to be called without having to
+  * thunk back into physical mode for every invocation.
+  *
+  * The new method does a pagetable switch in a preemption-safe manner
+  * so that we're in a different address space when calling a runtime
+  * function. For function arguments passing we do copy the PGDs of the
+  * kernel page table into ->trampoline_pgd prior to each call.
+  */
+ void __init efi_enter_virtual_mode(void)
+ {
+ 	efi_status_t status;
+ 	void *new_memmap = NULL;
+ 	int count = 0;
+ 
+ 	efi.systab = NULL;
+ 
+ 	/*
+ 	 * We don't do virtual mode, since we don't do runtime services, on
+ 	 * non-native EFI
+ 	 */
+ 	if (!efi_is_native()) {
+ 		efi_unmap_memmap();
+ 		return;
+ 	}
+ 
+ 	efi_merge_regions();
+ 
+ 	new_memmap = efi_map_regions(&count);
+ 	if (!new_memmap) {
+ 		pr_err("Error reallocating memory, EFI runtime non-functional!\n");
+ 		return;
  	}
  
  	BUG_ON(!efi.systab);
* Unmerged path arch/x86/platform/efi/efi.c
