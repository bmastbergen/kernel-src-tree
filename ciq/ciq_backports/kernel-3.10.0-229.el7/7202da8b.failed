ethtool, net/mlx4_en: Cable info, get_module_info/eeprom ethtool support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [ethernet] mlx4: Cable info, get_module_info/eeprom ethtool support (Amir Vadai) [1060221]
Rebuild_FUZZ: 87.50%
commit-author Saeed Mahameed <saeedm@mellanox.com>
commit 7202da8b7f7131d25411d81aa557e28cd941c5b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/7202da8b.failed

Added support for get_module_info/get_module_eeprom ethtool support for cable info reading.

Added new cable types enum in include/uapi/linux/ethtool.h for ethtool use.
+#define ETH_MODULE_SFF_8636            0x3
+#define ETH_MODULE_SFF_8636_LEN        256
+#define ETH_MODULE_SFF_8436            0x4
+#define ETH_MODULE_SFF_8436_LEN        256

	Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>
	Signed-off-by: Amir Vadai <amirv@mellanox.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7202da8b7f7131d25411d81aa557e28cd941c5b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
diff --cc drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index 7979f98d885e,279f4233de59..000000000000
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@@ -1266,6 -1268,128 +1267,131 @@@ static u32 mlx4_en_get_priv_flags(struc
  	return priv->pflags;
  }
  
++<<<<<<< HEAD
++=======
+ static int mlx4_en_get_tunable(struct net_device *dev,
+ 			       const struct ethtool_tunable *tuna,
+ 			       void *data)
+ {
+ 	const struct mlx4_en_priv *priv = netdev_priv(dev);
+ 	int ret = 0;
+ 
+ 	switch (tuna->id) {
+ 	case ETHTOOL_TX_COPYBREAK:
+ 		*(u32 *)data = priv->prof->inline_thold;
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int mlx4_en_set_tunable(struct net_device *dev,
+ 			       const struct ethtool_tunable *tuna,
+ 			       const void *data)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 	int val, ret = 0;
+ 
+ 	switch (tuna->id) {
+ 	case ETHTOOL_TX_COPYBREAK:
+ 		val = *(u32 *)data;
+ 		if (val < MIN_PKT_LEN || val > MAX_INLINE)
+ 			ret = -EINVAL;
+ 		else
+ 			priv->prof->inline_thold = val;
+ 		break;
+ 	default:
+ 		ret = -EINVAL;
+ 		break;
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ static int mlx4_en_get_module_info(struct net_device *dev,
+ 				   struct ethtool_modinfo *modinfo)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 	struct mlx4_en_dev *mdev = priv->mdev;
+ 	int ret;
+ 	u8 data[4];
+ 
+ 	/* Read first 2 bytes to get Module & REV ID */
+ 	ret = mlx4_get_module_info(mdev->dev, priv->port,
+ 				   0/*offset*/, 2/*size*/, data);
+ 	if (ret < 2)
+ 		return -EIO;
+ 
+ 	switch (data[0] /* identifier */) {
+ 	case MLX4_MODULE_ID_QSFP:
+ 		modinfo->type = ETH_MODULE_SFF_8436;
+ 		modinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;
+ 		break;
+ 	case MLX4_MODULE_ID_QSFP_PLUS:
+ 		if (data[1] >= 0x3) { /* revision id */
+ 			modinfo->type = ETH_MODULE_SFF_8636;
+ 			modinfo->eeprom_len = ETH_MODULE_SFF_8636_LEN;
+ 		} else {
+ 			modinfo->type = ETH_MODULE_SFF_8436;
+ 			modinfo->eeprom_len = ETH_MODULE_SFF_8436_LEN;
+ 		}
+ 		break;
+ 	case MLX4_MODULE_ID_QSFP28:
+ 		modinfo->type = ETH_MODULE_SFF_8636;
+ 		modinfo->eeprom_len = ETH_MODULE_SFF_8636_LEN;
+ 		break;
+ 	case MLX4_MODULE_ID_SFP:
+ 		modinfo->type = ETH_MODULE_SFF_8472;
+ 		modinfo->eeprom_len = ETH_MODULE_SFF_8472_LEN;
+ 		break;
+ 	default:
+ 		return -ENOSYS;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int mlx4_en_get_module_eeprom(struct net_device *dev,
+ 				     struct ethtool_eeprom *ee,
+ 				     u8 *data)
+ {
+ 	struct mlx4_en_priv *priv = netdev_priv(dev);
+ 	struct mlx4_en_dev *mdev = priv->mdev;
+ 	int offset = ee->offset;
+ 	int i = 0, ret;
+ 
+ 	if (ee->len == 0)
+ 		return -EINVAL;
+ 
+ 	memset(data, 0, ee->len);
+ 
+ 	while (i < ee->len) {
+ 		en_dbg(DRV, priv,
+ 		       "mlx4_get_module_info i(%d) offset(%d) len(%d)\n",
+ 		       i, offset, ee->len - i);
+ 
+ 		ret = mlx4_get_module_info(mdev->dev, priv->port,
+ 					   offset, ee->len - i, data + i);
+ 
+ 		if (!ret) /* Done reading */
+ 			return 0;
+ 
+ 		if (ret < 0) {
+ 			en_err(priv,
+ 			       "mlx4_get_module_info i(%d) offset(%d) bytes_to_read(%d) - FAILED (0x%x)\n",
+ 			       i, offset, ee->len - i, ret);
+ 			return 0;
+ 		}
+ 
+ 		i += ret;
+ 		offset += ret;
+ 	}
+ 	return 0;
+ }
++>>>>>>> 7202da8b7f71 (ethtool, net/mlx4_en: Cable info, get_module_info/eeprom ethtool support)
  
  const struct ethtool_ops mlx4_en_ethtool_ops = {
  	.get_drvinfo = mlx4_en_get_drvinfo,
@@@ -1296,6 -1420,10 +1422,13 @@@
  	.get_ts_info = mlx4_en_get_ts_info,
  	.set_priv_flags = mlx4_en_set_priv_flags,
  	.get_priv_flags = mlx4_en_get_priv_flags,
++<<<<<<< HEAD
++=======
+ 	.get_tunable		= mlx4_en_get_tunable,
+ 	.set_tunable		= mlx4_en_set_tunable,
+ 	.get_module_info = mlx4_en_get_module_info,
+ 	.get_module_eeprom = mlx4_en_get_module_eeprom
++>>>>>>> 7202da8b7f71 (ethtool, net/mlx4_en: Cable info, get_module_info/eeprom ethtool support)
  };
  
  
* Unmerged path drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
diff --git a/include/uapi/linux/ethtool.h b/include/uapi/linux/ethtool.h
index c51382e3cd5d..33e7d120c39c 100644
--- a/include/uapi/linux/ethtool.h
+++ b/include/uapi/linux/ethtool.h
@@ -1101,6 +1101,10 @@ enum ethtool_sfeatures_retval_bits {
 #define ETH_MODULE_SFF_8079_LEN		256
 #define ETH_MODULE_SFF_8472		0x2
 #define ETH_MODULE_SFF_8472_LEN		512
+#define ETH_MODULE_SFF_8636		0x3
+#define ETH_MODULE_SFF_8636_LEN		256
+#define ETH_MODULE_SFF_8436		0x4
+#define ETH_MODULE_SFF_8436_LEN		256
 
 /* Reset flags */
 /* The reset() operation must clear the flags for the components which
