ACPI / hotplug: Add .fixup() callback to struct acpi_hotplug_context

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug: Add .fixup() callback to struct acpi_hotplug_context (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 94.57%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 59b42fa01fe2d84f3c3f28ee6f25510820ace35b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/59b42fa0.failed

In order for the ACPI dock station code to be able to use the
callbacks pointed to by the ACPI device objects' hotplug contexts
add a .fixup() callback pointer to struct acpi_hotplug_context.
That callback will be useful to handle PCI devices located in
dock stations.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 59b42fa01fe2d84f3c3f28ee6f25510820ace35b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
#	include/acpi/acpi_bus.h
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 0f3f960473bc,4228c67ceffe..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -58,25 -59,65 +58,71 @@@
  static LIST_HEAD(bridge_list);
  static DEFINE_MUTEX(bridge_mutex);
  
 -static int acpiphp_hotplug_event(struct acpi_device *adev, u32 type);
 +static void handle_hotplug_event_bridge (acpi_handle, u32, void *);
  static void acpiphp_sanitize_bus(struct pci_bus *bus);
  static void acpiphp_set_hpp_values(struct pci_bus *bus);
 -static void hotplug_event(u32 type, struct acpiphp_context *context);
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context);
 +static void handle_hotplug_event_func(acpi_handle handle, u32 type, void *context);
  static void free_bridge(struct kref *kref);
  
 -/**
 - * acpiphp_init_context - Create hotplug context and grab a reference to it.
 - * @adev: ACPI device object to create the context for.
 - *
 - * Call under acpi_hp_context_lock.
 - */
 -static struct acpiphp_context *acpiphp_init_context(struct acpi_device *adev)
 +/* callback routine to check for the existence of a pci dock device */
 +static acpi_status
 +is_pci_dock_device(acpi_handle handle, u32 lvl, void *context, void **rv)
  {
 -	struct acpiphp_context *context;
 +	int *count = (int *)context;
  
++<<<<<<< HEAD
 +	if (is_dock_device(handle)) {
 +		(*count)++;
 +		return AE_CTRL_TERMINATE;
 +	} else {
 +		return AE_OK;
 +	}
++=======
+ 	context = kzalloc(sizeof(*context), GFP_KERNEL);
+ 	if (!context)
+ 		return NULL;
+ 
+ 	context->refcount = 1;
+ 	acpi_set_hp_context(adev, &context->hp, acpiphp_hotplug_event, NULL);
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_get_context - Get hotplug context and grab a reference to it.
+  * @adev: ACPI device object to get the context for.
+  *
+  * Call under acpi_hp_context_lock.
+  */
+ static struct acpiphp_context *acpiphp_get_context(struct acpi_device *adev)
+ {
+ 	struct acpiphp_context *context;
+ 
+ 	if (!adev->hp)
+ 		return NULL;
+ 
+ 	context = to_acpiphp_context(adev->hp);
+ 	context->refcount++;
+ 	return context;
+ }
+ 
+ /**
+  * acpiphp_put_context - Drop a reference to ACPI hotplug context.
+  * @context: ACPI hotplug context to drop a reference to.
+  *
+  * The context object is removed if there are no more references to it.
+  *
+  * Call under acpi_hp_context_lock.
+  */
+ static void acpiphp_put_context(struct acpiphp_context *context)
+ {
+ 	if (--context->refcount)
+ 		return;
+ 
+ 	WARN_ON(context->bridge);
+ 	context->hp.self->hp = NULL;
+ 	kfree(context);
++>>>>>>> 59b42fa01fe2 (ACPI / hotplug: Add .fixup() callback to struct acpi_hotplug_context)
  }
  
  static inline void get_bridge(struct acpiphp_bridge *bridge)
diff --cc include/acpi/acpi_bus.h
index 717f4adcfbd4,007fe99e29f5..000000000000
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@@ -124,6 -137,17 +124,20 @@@ struct acpi_scan_handler 
  };
  
  /*
++<<<<<<< HEAD
++=======
+  * ACPI Hotplug Context
+  * --------------------
+  */
+ 
+ struct acpi_hotplug_context {
+ 	struct acpi_device *self;
+ 	int (*event)(struct acpi_device *, u32);
+ 	void (*fixup)(struct acpi_device *);
+ };
+ 
+ /*
++>>>>>>> 59b42fa01fe2 (ACPI / hotplug: Add .fixup() callback to struct acpi_hotplug_context)
   * ACPI Driver
   * -----------
   */
@@@ -327,6 -360,22 +341,25 @@@ static inline void *acpi_driver_data(st
  #define to_acpi_device(d)	container_of(d, struct acpi_device, dev)
  #define to_acpi_driver(d)	container_of(d, struct acpi_driver, drv)
  
++<<<<<<< HEAD
++=======
+ static inline void acpi_set_device_status(struct acpi_device *adev, u32 sta)
+ {
+ 	*((u32 *)&adev->status) = sta;
+ }
+ 
+ static inline void acpi_set_hp_context(struct acpi_device *adev,
+ 				       struct acpi_hotplug_context *hp,
+ 				       int (*event)(struct acpi_device *, u32),
+ 				       void (*fixup)(struct acpi_device *))
+ {
+ 	hp->self = adev;
+ 	hp->event = event;
+ 	hp->fixup = fixup;
+ 	adev->hp = hp;
+ }
+ 
++>>>>>>> 59b42fa01fe2 (ACPI / hotplug: Add .fixup() callback to struct acpi_hotplug_context)
  /* acpi_device.dev.bus == &acpi_bus_type */
  extern struct bus_type acpi_bus_type;
  
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
* Unmerged path include/acpi/acpi_bus.h
