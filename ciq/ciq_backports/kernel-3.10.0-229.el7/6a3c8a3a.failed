blk-mq: initialize req->q in allocation

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Ming Lei <tom.leiming@gmail.com>
commit 6a3c8a3ac0e68dcfc2a01f4aa1ca0edd1a1701eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/6a3c8a3a.failed

The patch basically reverts the patch of(blk-mq:
initialize request on allocation) in Jens's tree(already
in -next), and only initialize req->q in allocation
for two reasons:

	- presumed cache hotness on completion
	- blk_rq_tagged(rq) depends on reset of req->mq_ctx

	Signed-off-by: Ming Lei <tom.leiming@gmail.com>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 6a3c8a3ac0e68dcfc2a01f4aa1ca0edd1a1701eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-mq.c
diff --cc block/blk-mq.c
index 1e5a2766fa8d,c26b3be1893c..000000000000
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@@ -81,7 -81,7 +81,11 @@@ static struct request *__blk_mq_alloc_r
  
  	tag = blk_mq_get_tag(hctx->tags, gfp, reserved);
  	if (tag != BLK_MQ_TAG_FAIL) {
++<<<<<<< HEAD
 +		rq = hctx->rqs[tag];
++=======
+ 		rq = hctx->tags->rqs[tag];
++>>>>>>> 6a3c8a3ac0e6 (blk-mq: initialize req->q in allocation)
  		rq->tag = tag;
  
  		return rq;
@@@ -268,9 -258,8 +273,13 @@@ static void __blk_mq_free_request(struc
  	const int tag = rq->tag;
  	struct request_queue *q = rq->q;
  
++<<<<<<< HEAD
 +	blk_mq_rq_init(hctx, rq);
++=======
+ 	blk_rq_init(hctx->queue, rq);
++>>>>>>> 6a3c8a3ac0e6 (blk-mq: initialize req->q in allocation)
  	blk_mq_put_tag(hctx->tags, tag);
 +
  	blk_mq_queue_exit(q);
  }
  
@@@ -1116,11 -1191,18 +1125,23 @@@ static int blk_mq_init_rq_map(struct bl
  
  		p = page_address(page);
  		entries_per_page = order_to_size(this_order) / rq_size;
 -		to_do = min(entries_per_page, set->queue_depth - i);
 +		to_do = min(entries_per_page, hctx->queue_depth - i);
  		left -= to_do * rq_size;
  		for (j = 0; j < to_do; j++) {
++<<<<<<< HEAD
 +			hctx->rqs[i] = p;
 +			blk_mq_rq_init(hctx, hctx->rqs[i]);
++=======
+ 			tags->rqs[i] = p;
+ 			blk_rq_init(NULL, tags->rqs[i]);
+ 			if (set->ops->init_request) {
+ 				if (set->ops->init_request(set->driver_data,
+ 						tags->rqs[i], hctx_idx, i,
+ 						set->numa_node))
+ 					goto fail;
+ 			}
+ 
++>>>>>>> 6a3c8a3ac0e6 (blk-mq: initialize req->q in allocation)
  			p += rq_size;
  			i++;
  		}
* Unmerged path block/blk-mq.c
