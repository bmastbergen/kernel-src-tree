KVM: PPC: Book3S PR: Expose EBB registers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/ppc: book3s/pr - Expose EBB registers (David Gibson) [1123145 1123133 1123367]
Rebuild_FUZZ: 90.24%
commit-author Alexander Graf <agraf@suse.de>
commit 2e23f544135e7b5fc2f0bcb6fa935c4b4f5058b2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2e23f544.failed

POWER8 introduces a new facility called the "Event Based Branch" facility.
It contains of a few registers that indicate where a guest should branch to
when a defined event occurs and it's in PR mode.

We don't want to really enable EBB as it will create a big mess with !PR guest
mode while hardware is in PR and we don't really emulate the PMU anyway.

So instead, let's just leave it at emulation of all its registers.

	Signed-off-by: Alexander Graf <agraf@suse.de>
(cherry picked from commit 2e23f544135e7b5fc2f0bcb6fa935c4b4f5058b2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s.c
#	arch/powerpc/kvm/book3s_emulate.c
#	arch/powerpc/kvm/book3s_hv.c
diff --cc arch/powerpc/kvm/book3s.c
index be63f63c167b,52c654dbd41a..000000000000
--- a/arch/powerpc/kvm/book3s.c
+++ b/arch/powerpc/kvm/book3s.c
@@@ -561,6 -631,21 +561,24 @@@ int kvm_vcpu_ioctl_get_one_reg(struct k
  			val = get_reg_val(reg->id, kvmppc_xics_get_icp(vcpu));
  			break;
  #endif /* CONFIG_KVM_XICS */
++<<<<<<< HEAD
++=======
+ 		case KVM_REG_PPC_FSCR:
+ 			val = get_reg_val(reg->id, vcpu->arch.fscr);
+ 			break;
+ 		case KVM_REG_PPC_TAR:
+ 			val = get_reg_val(reg->id, vcpu->arch.tar);
+ 			break;
+ 		case KVM_REG_PPC_EBBHR:
+ 			val = get_reg_val(reg->id, vcpu->arch.ebbhr);
+ 			break;
+ 		case KVM_REG_PPC_EBBRR:
+ 			val = get_reg_val(reg->id, vcpu->arch.ebbrr);
+ 			break;
+ 		case KVM_REG_PPC_BESCR:
+ 			val = get_reg_val(reg->id, vcpu->arch.bescr);
+ 			break;
++>>>>>>> 2e23f544135e (KVM: PPC: Book3S PR: Expose EBB registers)
  		default:
  			r = -EINVAL;
  			break;
@@@ -651,6 -735,21 +669,24 @@@ int kvm_vcpu_ioctl_set_one_reg(struct k
  						set_reg_val(reg->id, val));
  			break;
  #endif /* CONFIG_KVM_XICS */
++<<<<<<< HEAD
++=======
+ 		case KVM_REG_PPC_FSCR:
+ 			vcpu->arch.fscr = set_reg_val(reg->id, val);
+ 			break;
+ 		case KVM_REG_PPC_TAR:
+ 			vcpu->arch.tar = set_reg_val(reg->id, val);
+ 			break;
+ 		case KVM_REG_PPC_EBBHR:
+ 			vcpu->arch.ebbhr = set_reg_val(reg->id, val);
+ 			break;
+ 		case KVM_REG_PPC_EBBRR:
+ 			vcpu->arch.ebbrr = set_reg_val(reg->id, val);
+ 			break;
+ 		case KVM_REG_PPC_BESCR:
+ 			vcpu->arch.bescr = set_reg_val(reg->id, val);
+ 			break;
++>>>>>>> 2e23f544135e (KVM: PPC: Book3S PR: Expose EBB registers)
  		default:
  			r = -EINVAL;
  			break;
diff --cc arch/powerpc/kvm/book3s_emulate.c
index b7863af892e8,e1165bae693a..000000000000
--- a/arch/powerpc/kvm/book3s_emulate.c
+++ b/arch/powerpc/kvm/book3s_emulate.c
@@@ -438,6 -438,20 +438,23 @@@ int kvmppc_core_emulate_mtspr(struct kv
  	case SPRN_GQR7:
  		to_book3s(vcpu)->gqr[sprn - SPRN_GQR0] = spr_val;
  		break;
++<<<<<<< HEAD
++=======
+ 	case SPRN_FSCR:
+ 		vcpu->arch.fscr = spr_val;
+ 		break;
+ #ifdef CONFIG_PPC_BOOK3S_64
+ 	case SPRN_BESCR:
+ 		vcpu->arch.bescr = spr_val;
+ 		break;
+ 	case SPRN_EBBHR:
+ 		vcpu->arch.ebbhr = spr_val;
+ 		break;
+ 	case SPRN_EBBRR:
+ 		vcpu->arch.ebbrr = spr_val;
+ 		break;
+ #endif
++>>>>>>> 2e23f544135e (KVM: PPC: Book3S PR: Expose EBB registers)
  	case SPRN_ICTC:
  	case SPRN_THRM1:
  	case SPRN_THRM2:
@@@ -545,6 -559,20 +562,23 @@@ int kvmppc_core_emulate_mfspr(struct kv
  	case SPRN_GQR7:
  		*spr_val = to_book3s(vcpu)->gqr[sprn - SPRN_GQR0];
  		break;
++<<<<<<< HEAD
++=======
+ 	case SPRN_FSCR:
+ 		*spr_val = vcpu->arch.fscr;
+ 		break;
+ #ifdef CONFIG_PPC_BOOK3S_64
+ 	case SPRN_BESCR:
+ 		*spr_val = vcpu->arch.bescr;
+ 		break;
+ 	case SPRN_EBBHR:
+ 		*spr_val = vcpu->arch.ebbhr;
+ 		break;
+ 	case SPRN_EBBRR:
+ 		*spr_val = vcpu->arch.ebbrr;
+ 		break;
+ #endif
++>>>>>>> 2e23f544135e (KVM: PPC: Book3S PR: Expose EBB registers)
  	case SPRN_THRM1:
  	case SPRN_THRM2:
  	case SPRN_THRM3:
diff --cc arch/powerpc/kvm/book3s_hv.c
index 14588bcd5db5,3a9456165224..000000000000
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@@ -836,6 -873,51 +836,54 @@@ int kvmppc_get_one_reg(struct kvm_vcpu 
  	case KVM_REG_PPC_SDAR:
  		*val = get_reg_val(id, vcpu->arch.sdar);
  		break;
++<<<<<<< HEAD
++=======
+ 	case KVM_REG_PPC_SIER:
+ 		*val = get_reg_val(id, vcpu->arch.sier);
+ 		break;
+ 	case KVM_REG_PPC_IAMR:
+ 		*val = get_reg_val(id, vcpu->arch.iamr);
+ 		break;
+ 	case KVM_REG_PPC_PSPB:
+ 		*val = get_reg_val(id, vcpu->arch.pspb);
+ 		break;
+ 	case KVM_REG_PPC_DPDES:
+ 		*val = get_reg_val(id, vcpu->arch.vcore->dpdes);
+ 		break;
+ 	case KVM_REG_PPC_DAWR:
+ 		*val = get_reg_val(id, vcpu->arch.dawr);
+ 		break;
+ 	case KVM_REG_PPC_DAWRX:
+ 		*val = get_reg_val(id, vcpu->arch.dawrx);
+ 		break;
+ 	case KVM_REG_PPC_CIABR:
+ 		*val = get_reg_val(id, vcpu->arch.ciabr);
+ 		break;
+ 	case KVM_REG_PPC_IC:
+ 		*val = get_reg_val(id, vcpu->arch.ic);
+ 		break;
+ 	case KVM_REG_PPC_VTB:
+ 		*val = get_reg_val(id, vcpu->arch.vtb);
+ 		break;
+ 	case KVM_REG_PPC_CSIGR:
+ 		*val = get_reg_val(id, vcpu->arch.csigr);
+ 		break;
+ 	case KVM_REG_PPC_TACR:
+ 		*val = get_reg_val(id, vcpu->arch.tacr);
+ 		break;
+ 	case KVM_REG_PPC_TCSCR:
+ 		*val = get_reg_val(id, vcpu->arch.tcscr);
+ 		break;
+ 	case KVM_REG_PPC_PID:
+ 		*val = get_reg_val(id, vcpu->arch.pid);
+ 		break;
+ 	case KVM_REG_PPC_ACOP:
+ 		*val = get_reg_val(id, vcpu->arch.acop);
+ 		break;
+ 	case KVM_REG_PPC_WORT:
+ 		*val = get_reg_val(id, vcpu->arch.wort);
+ 		break;
++>>>>>>> 2e23f544135e (KVM: PPC: Book3S PR: Expose EBB registers)
  	case KVM_REG_PPC_VPA_ADDR:
  		spin_lock(&vcpu->arch.vpa_update_lock);
  		*val = get_reg_val(id, vcpu->arch.vpa.next_gpa);
@@@ -917,6 -1070,54 +965,57 @@@ int kvmppc_set_one_reg(struct kvm_vcpu 
  	case KVM_REG_PPC_SDAR:
  		vcpu->arch.sdar = set_reg_val(id, *val);
  		break;
++<<<<<<< HEAD
++=======
+ 	case KVM_REG_PPC_SIER:
+ 		vcpu->arch.sier = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_IAMR:
+ 		vcpu->arch.iamr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_PSPB:
+ 		vcpu->arch.pspb = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_DPDES:
+ 		vcpu->arch.vcore->dpdes = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_DAWR:
+ 		vcpu->arch.dawr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_DAWRX:
+ 		vcpu->arch.dawrx = set_reg_val(id, *val) & ~DAWRX_HYP;
+ 		break;
+ 	case KVM_REG_PPC_CIABR:
+ 		vcpu->arch.ciabr = set_reg_val(id, *val);
+ 		/* Don't allow setting breakpoints in hypervisor code */
+ 		if ((vcpu->arch.ciabr & CIABR_PRIV) == CIABR_PRIV_HYPER)
+ 			vcpu->arch.ciabr &= ~CIABR_PRIV;	/* disable */
+ 		break;
+ 	case KVM_REG_PPC_IC:
+ 		vcpu->arch.ic = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_VTB:
+ 		vcpu->arch.vtb = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_CSIGR:
+ 		vcpu->arch.csigr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_TACR:
+ 		vcpu->arch.tacr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_TCSCR:
+ 		vcpu->arch.tcscr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_PID:
+ 		vcpu->arch.pid = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_ACOP:
+ 		vcpu->arch.acop = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_WORT:
+ 		vcpu->arch.wort = set_reg_val(id, *val);
+ 		break;
++>>>>>>> 2e23f544135e (KVM: PPC: Book3S PR: Expose EBB registers)
  	case KVM_REG_PPC_VPA_ADDR:
  		addr = set_reg_val(id, *val);
  		r = -EINVAL;
* Unmerged path arch/powerpc/kvm/book3s.c
* Unmerged path arch/powerpc/kvm/book3s_emulate.c
* Unmerged path arch/powerpc/kvm/book3s_hv.c
