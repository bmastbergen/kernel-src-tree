drm/ttm: Fix possible stack overflow by recursive shrinker calls.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] ttm: Fix possible stack overflow by recursive shrinker calls (Rob Clark) [1173317]
Rebuild_FUZZ: 96.00%
commit-author Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
commit 71336e011d1d2312bcbcaa8fcec7365024f3a95d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/71336e01.failed

While ttm_dma_pool_shrink_scan() tries to take mutex before doing GFP_KERNEL
allocation, ttm_pool_shrink_scan() does not do it. This can result in stack
overflow if kmalloc() in ttm_page_pool_free() triggered recursion due to
memory pressure.

  shrink_slab()
  => ttm_pool_shrink_scan()
     => ttm_page_pool_free()
        => kmalloc(GFP_KERNEL)
           => shrink_slab()
              => ttm_pool_shrink_scan()
                 => ttm_page_pool_free()
                    => kmalloc(GFP_KERNEL)

Change ttm_pool_shrink_scan() to do like ttm_dma_pool_shrink_scan() does.

	Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
	Cc: stable <stable@kernel.org> [2.6.35+]
	Signed-off-by: Dave Airlie <airlied@redhat.com>
(cherry picked from commit 71336e011d1d2312bcbcaa8fcec7365024f3a95d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/ttm/ttm_page_alloc.c
diff --cc drivers/gpu/drm/ttm/ttm_page_alloc.c
index bd2a3b40cd12,edb83151041f..000000000000
--- a/drivers/gpu/drm/ttm/ttm_page_alloc.c
+++ b/drivers/gpu/drm/ttm/ttm_page_alloc.c
@@@ -377,30 -377,31 +377,33 @@@ out
  	return nr_free;
  }
  
 +/* Get good estimation how many pages are free in pools */
 +static int ttm_pool_get_num_unused_pages(void)
 +{
 +	unsigned i;
 +	int total = 0;
 +	for (i = 0; i < NUM_POOLS; ++i)
 +		total += _manager->pools[i].npages;
 +
 +	return total;
 +}
 +
  /**
   * Callback for mm to request pool to reduce number of page held.
 - *
 - * XXX: (dchinner) Deadlock warning!
 - *
 - * ttm_page_pool_free() does memory allocation using GFP_KERNEL.  that means
 - * this can deadlock when called a sc->gfp_mask that is not equal to
 - * GFP_KERNEL.
 - *
 - * This code is crying out for a shrinker per pool....
   */
 -static unsigned long
 -ttm_pool_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)
 +static int ttm_pool_mm_shrink(struct shrinker *shrink,
 +			      struct shrink_control *sc)
  {
- 	static atomic_t start_pool = ATOMIC_INIT(0);
+ 	static DEFINE_MUTEX(lock);
+ 	static unsigned start_pool;
  	unsigned i;
- 	unsigned pool_offset = atomic_add_return(1, &start_pool);
+ 	unsigned pool_offset;
  	struct ttm_page_pool *pool;
  	int shrink_pages = sc->nr_to_scan;
 -	unsigned long freed = 0;
  
- 	pool_offset = pool_offset % NUM_POOLS;
+ 	if (!mutex_trylock(&lock))
+ 		return SHRINK_STOP;
+ 	pool_offset = ++start_pool % NUM_POOLS;
  	/* select start pool in round robin fashion */
  	for (i = 0; i < NUM_POOLS; ++i) {
  		unsigned nr_free = shrink_pages;
@@@ -408,9 -409,23 +411,27 @@@
  			break;
  		pool = &_manager->pools[(i + pool_offset)%NUM_POOLS];
  		shrink_pages = ttm_page_pool_free(pool, nr_free);
 -		freed += nr_free - shrink_pages;
  	}
++<<<<<<< HEAD
 +	/* return estimated number of unused pages in pool */
 +	return ttm_pool_get_num_unused_pages();
++=======
+ 	mutex_unlock(&lock);
+ 	return freed;
+ }
+ 
+ 
+ static unsigned long
+ ttm_pool_shrink_count(struct shrinker *shrink, struct shrink_control *sc)
+ {
+ 	unsigned i;
+ 	unsigned long count = 0;
+ 
+ 	for (i = 0; i < NUM_POOLS; ++i)
+ 		count += _manager->pools[i].npages;
+ 
+ 	return count;
++>>>>>>> 71336e011d1d (drm/ttm: Fix possible stack overflow by recursive shrinker calls.)
  }
  
  static void ttm_pool_mm_shrink_init(struct ttm_pool_manager *manager)
* Unmerged path drivers/gpu/drm/ttm/ttm_page_alloc.c
