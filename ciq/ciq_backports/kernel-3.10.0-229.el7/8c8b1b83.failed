openvswitch: Use tun_key only for egress tunnel path.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] openvswitch: Use tun_key only for egress tunnel path (Jiri Benc) [1110384]
Rebuild_FUZZ: 99.05%
commit-author Pravin B Shelar <pshelar@nicira.com>
commit 8c8b1b83fcdd0f05e1f66ed6f8a2e831d5d374a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/8c8b1b83.failed

Currently tun_key is used for passing tunnel information
on ingress and egress path, this cause confusion.  Following
patch removes its use on ingress path make it egress only parameter.

	Signed-off-by: Pravin B Shelar <pshelar@nicira.com>
	Acked-by: Andy Zhou <azhou@nicira.com>
(cherry picked from commit 8c8b1b83fcdd0f05e1f66ed6f8a2e831d5d374a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/vport-gre.c
#	net/openvswitch/vport-vxlan.c
#	net/openvswitch/vport.c
diff --cc net/openvswitch/vport-gre.c
index d693d5ffb38a,309cca6e816f..000000000000
--- a/net/openvswitch/vport-gre.c
+++ b/net/openvswitch/vport-gre.c
@@@ -186,15 -187,14 +188,21 @@@ static int gre_tnl_send(struct vport *v
  		goto err_free_rt;
  	}
  
- 	df = OVS_CB(skb)->tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ?
+ 	df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ?
  		htons(IP_DF) : 0;
  
 -	skb->ignore_df = 1;
 +	skb->local_df = 1;
  
++<<<<<<< HEAD
 +	return iptunnel_xmit(net, rt, skb, fl.saddr,
 +			     OVS_CB(skb)->tun_key->ipv4_dst, IPPROTO_GRE,
 +			     OVS_CB(skb)->tun_key->ipv4_tos,
 +			     OVS_CB(skb)->tun_key->ipv4_ttl, df);
++=======
+ 	return iptunnel_xmit(skb->sk, rt, skb, fl.saddr,
+ 			     tun_key->ipv4_dst, IPPROTO_GRE,
+ 			     tun_key->ipv4_tos, tun_key->ipv4_ttl, df, false);
++>>>>>>> 8c8b1b83fcdd (openvswitch: Use tun_key only for egress tunnel path.)
  err_free_rt:
  	ip_rt_put(rt);
  error:
diff --cc net/openvswitch/vport-vxlan.c
index 05c0853994c1,f19539bb8adc..000000000000
--- a/net/openvswitch/vport-vxlan.c
+++ b/net/openvswitch/vport-vxlan.c
@@@ -167,20 -167,19 +169,29 @@@ static int vxlan_tnl_send(struct vport 
  		goto error;
  	}
  
- 	df = OVS_CB(skb)->tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ?
+ 	df = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ?
  		htons(IP_DF) : 0;
  
 -	skb->ignore_df = 1;
 +	skb->local_df = 1;
  
 -	src_port = udp_flow_src_port(net, skb, 0, 0, true);
 +	inet_get_local_port_range(&port_min, &port_max);
 +	src_port = vxlan_src_port(port_min, port_max, skb);
  
++<<<<<<< HEAD
 +	err = vxlan_xmit_skb(net, vxlan_port->vs, rt, skb,
 +			     fl.saddr, OVS_CB(skb)->tun_key->ipv4_dst,
 +			     OVS_CB(skb)->tun_key->ipv4_tos,
 +			     OVS_CB(skb)->tun_key->ipv4_ttl, df,
 +			     src_port, dst_port,
 +			     htonl(be64_to_cpu(OVS_CB(skb)->tun_key->tun_id) << 8));
++=======
+ 	err = vxlan_xmit_skb(vxlan_port->vs, rt, skb,
+ 			     fl.saddr, tun_key->ipv4_dst,
+ 			     tun_key->ipv4_tos, tun_key->ipv4_ttl, df,
+ 			     src_port, dst_port,
+ 			     htonl(be64_to_cpu(tun_key->tun_id) << 8),
+ 			     false);
++>>>>>>> 8c8b1b83fcdd (openvswitch: Use tun_key only for egress tunnel path.)
  	if (err < 0)
  		ip_rt_put(rt);
  error:
diff --cc net/openvswitch/vport.c
index c4a6dab8101c,5df8377fcfb1..000000000000
--- a/net/openvswitch/vport.c
+++ b/net/openvswitch/vport.c
@@@ -330,7 -434,9 +330,13 @@@ int ovs_vport_get_options(const struct 
  void ovs_vport_receive(struct vport *vport, struct sk_buff *skb,
  		       struct ovs_key_ipv4_tunnel *tun_key)
  {
++<<<<<<< HEAD
 +	struct pcpu_tstats *stats;
++=======
+ 	struct pcpu_sw_netstats *stats;
+ 	struct sw_flow_key key;
+ 	int error;
++>>>>>>> 8c8b1b83fcdd (openvswitch: Use tun_key only for egress tunnel path.)
  
  	stats = this_cpu_ptr(vport->percpu_stats);
  	u64_stats_update_begin(&stats->syncp);
diff --git a/net/openvswitch/actions.c b/net/openvswitch/actions.c
index 0008afc7a34a..37e6f1aa2d2b 100644
--- a/net/openvswitch/actions.c
+++ b/net/openvswitch/actions.c
@@ -510,7 +510,7 @@ static int execute_set_action(struct sk_buff *skb,
 		break;
 
 	case OVS_KEY_ATTR_IPV4_TUNNEL:
-		OVS_CB(skb)->tun_key = nla_data(nested_attr);
+		OVS_CB(skb)->egress_tun_key = nla_data(nested_attr);
 		break;
 
 	case OVS_KEY_ATTR_ETHERNET:
@@ -613,7 +613,6 @@ int ovs_execute_actions(struct datapath *dp, struct sk_buff *skb,
 {
 	struct sw_flow_actions *acts = rcu_dereference(OVS_CB(skb)->flow->sf_acts);
 
-	OVS_CB(skb)->tun_key = NULL;
 	return do_execute_actions(dp, skb, key,
 				  acts->actions, acts->actions_len);
 }
diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c
index 786222d76e75..5d495a2b45f1 100644
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@ -214,33 +214,25 @@ void ovs_dp_detach_port(struct vport *p)
 }
 
 /* Must be called with rcu_read_lock. */
-void ovs_dp_process_received_packet(struct sk_buff *skb)
+void ovs_dp_process_packet(struct sk_buff *skb, struct sw_flow_key *key)
 {
 	const struct vport *p = OVS_CB(skb)->input_vport;
 	struct datapath *dp = p->dp;
 	struct sw_flow *flow;
 	struct dp_stats_percpu *stats;
-	struct sw_flow_key key;
 	u64 *stats_counter;
 	u32 n_mask_hit;
-	int error;
 
 	stats = this_cpu_ptr(dp->stats_percpu);
 
-	/* Extract flow from 'skb' into 'key'. */
-	error = ovs_flow_key_extract(skb, &key);
-	if (unlikely(error)) {
-		kfree_skb(skb);
-		return;
-	}
-
 	/* Look up flow. */
-	flow = ovs_flow_tbl_lookup_stats(&dp->table, &key, &n_mask_hit);
+	flow = ovs_flow_tbl_lookup_stats(&dp->table, key, &n_mask_hit);
 	if (unlikely(!flow)) {
 		struct dp_upcall_info upcall;
+		int error;
 
 		upcall.cmd = OVS_PACKET_CMD_MISS;
-		upcall.key = &key;
+		upcall.key = key;
 		upcall.userdata = NULL;
 		upcall.portid = p->upcall_portid;
 		ovs_dp_upcall(dp, skb, &upcall);
@@ -251,8 +243,8 @@ void ovs_dp_process_received_packet(struct sk_buff *skb)
 
 	OVS_CB(skb)->flow = flow;
 
-	ovs_flow_stats_update(OVS_CB(skb)->flow, key.tp.flags, skb);
-	ovs_execute_actions(dp, skb, &key);
+	ovs_flow_stats_update(OVS_CB(skb)->flow, key->tp.flags, skb);
+	ovs_execute_actions(dp, skb, key);
 	stats_counter = &stats->n_hit;
 
 out:
diff --git a/net/openvswitch/datapath.h b/net/openvswitch/datapath.h
index 17f4728e86c2..e1eeea15dd22 100644
--- a/net/openvswitch/datapath.h
+++ b/net/openvswitch/datapath.h
@@ -95,15 +95,15 @@ struct datapath {
 /**
  * struct ovs_skb_cb - OVS data in skb CB
  * @flow: The flow associated with this packet.  May be %NULL if no flow.
- * @tun_key: Key for the tunnel that encapsulated this packet. NULL if the
- * packet is not being tunneled.
+ * @egress_tun_key: Tunnel information about this packet on egress path.
+ * NULL if the packet is not being tunneled.
  * @input_vport: The original vport packet came in on. This value is cached
  * when a packet is received by OVS.
  */
 struct ovs_skb_cb {
 	struct sw_flow		*flow;
-	struct ovs_key_ipv4_tunnel  *tun_key;
 	struct vport		*input_vport;
+	struct ovs_key_ipv4_tunnel  *egress_tun_key;
 };
 #define OVS_CB(skb) ((struct ovs_skb_cb *)(skb)->cb)
 
@@ -184,7 +184,7 @@ static inline struct vport *ovs_vport_ovsl(const struct datapath *dp, int port_n
 extern struct notifier_block ovs_dp_device_notifier;
 extern struct genl_multicast_group ovs_dp_vport_multicast_group;
 
-void ovs_dp_process_received_packet(struct sk_buff *);
+void ovs_dp_process_packet(struct sk_buff *skb, struct sw_flow_key *key);
 void ovs_dp_detach_port(struct vport *);
 int ovs_dp_upcall(struct datapath *, struct sk_buff *,
 		  const struct dp_upcall_info *);
diff --git a/net/openvswitch/flow.c b/net/openvswitch/flow.c
index 762c8c362838..49fd57299c1e 100644
--- a/net/openvswitch/flow.c
+++ b/net/openvswitch/flow.c
@@ -606,12 +606,13 @@ static int key_extract(struct sk_buff *skb, struct sw_flow_key *key)
 	return 0;
 }
 
-int ovs_flow_key_extract(struct sk_buff *skb, struct sw_flow_key *key)
+int ovs_flow_key_extract(struct ovs_key_ipv4_tunnel *tun_key,
+			 struct sk_buff *skb, struct sw_flow_key *key)
 {
 	/* Extract metadata from packet. */
 	memset(key, 0, sizeof(*key));
-	if (OVS_CB(skb)->tun_key)
-		memcpy(&key->tun_key, OVS_CB(skb)->tun_key, sizeof(key->tun_key));
+	if (tun_key)
+		memcpy(&key->tun_key, tun_key, sizeof(key->tun_key));
 
 	key->phy.priority = skb->priority;
 	key->phy.in_port = OVS_CB(skb)->input_vport->port_no;
diff --git a/net/openvswitch/flow.h b/net/openvswitch/flow.h
index 251789b6ec45..3869a540365c 100644
--- a/net/openvswitch/flow.h
+++ b/net/openvswitch/flow.h
@@ -187,7 +187,8 @@ void ovs_flow_stats_get(const struct sw_flow *, struct ovs_flow_stats *,
 void ovs_flow_stats_clear(struct sw_flow *);
 u64 ovs_flow_used_time(unsigned long flow_jiffies);
 
-int ovs_flow_key_extract(struct sk_buff *skb, struct sw_flow_key *key);
+int ovs_flow_key_extract(struct ovs_key_ipv4_tunnel *tun_key,
+			 struct sk_buff *skb, struct sw_flow_key *key);
 /* Extract key from packet coming from userspace. */
 int ovs_flow_key_extract_userspace(const struct nlattr *attr,
 				   struct sk_buff *skb,
* Unmerged path net/openvswitch/vport-gre.c
* Unmerged path net/openvswitch/vport-vxlan.c
* Unmerged path net/openvswitch/vport.c
