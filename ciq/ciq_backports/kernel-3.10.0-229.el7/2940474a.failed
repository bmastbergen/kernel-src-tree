block: remove elv_abort_queue and blk_abort_flushes

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [block] remove elv_abort_queue and blk_abort_flushes (Mike Snitzer) [1105204]
Rebuild_FUZZ: 92.63%
commit-author Christoph Hellwig <hch@lst.de>
commit 2940474af79744411da0cb63b041ad52c57bc443
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2940474a.failed

elv_abort_queue has no callers, and blk_abort_flushes is only called by
elv_abort_queue.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Jens Axboe <axboe@fb.com>
(cherry picked from commit 2940474af79744411da0cb63b041ad52c57bc443)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	block/blk-flush.c
diff --cc block/blk-flush.c
index 1c9013bca5a0,3cb5e9e7108a..000000000000
--- a/block/blk-flush.c
+++ b/block/blk-flush.c
@@@ -442,53 -422,6 +442,56 @@@ void blk_insert_flush(struct request *r
  }
  
  /**
++<<<<<<< HEAD
 + * blk_abort_flushes - @q is being aborted, abort flush requests
 + * @q: request_queue being aborted
 + *
 + * To be called from elv_abort_queue().  @q is being aborted.  Prepare all
 + * FLUSH/FUA requests for abortion.
 + *
 + * CONTEXT:
 + * spin_lock_irq(q->queue_lock)
 + */
 +void blk_abort_flushes(struct request_queue *q)
 +{
 +	struct request *rq, *n;
 +	int i;
 +
 +	/*
 +	 * Requests in flight for data are already owned by the dispatch
 +	 * queue or the device driver.  Just restore for normal completion.
 +	 */
 +	list_for_each_entry_safe(rq, n, &q->flush_data_in_flight, flush.list) {
 +		list_del_init(&rq->flush.list);
 +		blk_flush_restore_request(rq);
 +	}
 +
 +	/*
 +	 * We need to give away requests on flush queues.  Restore for
 +	 * normal completion and put them on the dispatch queue.
 +	 */
 +	for (i = 0; i < ARRAY_SIZE(q->flush_queue); i++) {
 +		list_for_each_entry_safe(rq, n, &q->flush_queue[i],
 +					 flush.list) {
 +			list_del_init(&rq->flush.list);
 +			blk_flush_restore_request(rq);
 +			list_add_tail(&rq->queuelist, &q->queue_head);
 +		}
 +	}
 +}
 +
 +static void bio_end_flush(struct bio *bio, int err)
 +{
 +	if (err)
 +		clear_bit(BIO_UPTODATE, &bio->bi_flags);
 +	if (bio->bi_private)
 +		complete(bio->bi_private);
 +	bio_put(bio);
 +}
 +
 +/**
++=======
++>>>>>>> 2940474af797 (block: remove elv_abort_queue and blk_abort_flushes)
   * blkdev_issue_flush - queue a flush
   * @bdev:	blockdev to issue flush for
   * @gfp_mask:	memory allocation flags (for bio_alloc)
* Unmerged path block/blk-flush.c
diff --git a/block/blk.h b/block/blk.h
index d23b415b8a28..4d383f94d624 100644
--- a/block/blk.h
+++ b/block/blk.h
@@ -81,7 +81,6 @@ static inline void blk_clear_rq_complete(struct request *rq)
 #define ELV_ON_HASH(rq) hash_hashed(&(rq)->hash)
 
 void blk_insert_flush(struct request *rq);
-void blk_abort_flushes(struct request_queue *q);
 
 static inline struct request *__elv_next_request(struct request_queue *q)
 {
diff --git a/block/elevator.c b/block/elevator.c
index 27d33dc2fe7d..09ce96d58753 100644
--- a/block/elevator.c
+++ b/block/elevator.c
@@ -728,26 +728,6 @@ int elv_may_queue(struct request_queue *q, int rw)
 	return ELV_MQUEUE_MAY;
 }
 
-void elv_abort_queue(struct request_queue *q)
-{
-	struct request *rq;
-
-	blk_abort_flushes(q);
-
-	while (!list_empty(&q->queue_head)) {
-		rq = list_entry_rq(q->queue_head.next);
-		rq->cmd_flags |= REQ_QUIET;
-		trace_block_rq_abort(q, rq);
-		/*
-		 * Mark this request as started so we don't trigger
-		 * any debug logic in the end I/O path.
-		 */
-		blk_start_request(rq);
-		__blk_end_request_all(rq, -EIO);
-	}
-}
-EXPORT_SYMBOL(elv_abort_queue);
-
 void elv_completed_request(struct request_queue *q, struct request *rq)
 {
 	struct elevator_queue *e = q->elevator;
diff --git a/include/linux/elevator.h b/include/linux/elevator.h
index 080812bd881c..25410625f1e2 100644
--- a/include/linux/elevator.h
+++ b/include/linux/elevator.h
@@ -133,7 +133,6 @@ extern struct request *elv_latter_request(struct request_queue *, struct request
 extern int elv_register_queue(struct request_queue *q);
 extern void elv_unregister_queue(struct request_queue *q);
 extern int elv_may_queue(struct request_queue *, int);
-extern void elv_abort_queue(struct request_queue *);
 extern void elv_completed_request(struct request_queue *, struct request *);
 extern int elv_set_request(struct request_queue *q, struct request *rq,
 			   struct bio *bio, gfp_t gfp_mask);
