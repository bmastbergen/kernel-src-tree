drm/i915: demote opregion excessive timeout WARN_ONCE to DRM_INFO_ONCE

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] i915: demote opregion excessive timeout WARN_ONCE to DRM_INFO_ONCE (Rob Clark) [1145627]
Rebuild_FUZZ: 97.06%
commit-author Jani Nikula <jani.nikula@intel.com>
commit bdde5c6a258a702bdfa7d1f4ae804a7bc405e788
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/bdde5c6a.failed

The WARN_ONCE is a bit too verbose, make it a DRM_INFO_ONCE.

While at it, add a #define for MAX_DSLP and make the message a bit more
informative.

v2: use DRM_INFO_ONCE, add MAX_DSLP, pimp the message.

	Suggested-by: Chris Wilson <chris@chris-wilson.co.uk>
	Signed-off-by: Jani Nikula <jani.nikula@intel.com>
	Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
	Signed-off-by: Daniel Vetter <daniel.vetter@ffwll.ch>
(cherry picked from commit bdde5c6a258a702bdfa7d1f4ae804a7bc405e788)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/i915/intel_opregion.c
diff --cc drivers/gpu/drm/i915/intel_opregion.c
index 119771ff46ab,68459605bd12..000000000000
--- a/drivers/gpu/drm/i915/intel_opregion.c
+++ b/drivers/gpu/drm/i915/intel_opregion.c
@@@ -157,7 -227,175 +157,178 @@@ struct opregion_asle 
  #define ACPI_DIGITAL_OUTPUT (3<<8)
  #define ACPI_LVDS_OUTPUT (4<<8)
  
+ #define MAX_DSLP	1500
+ 
  #ifdef CONFIG_ACPI
++<<<<<<< HEAD
++=======
+ static int swsci(struct drm_device *dev, u32 function, u32 parm, u32 *parm_out)
+ {
+ 	struct drm_i915_private *dev_priv = dev->dev_private;
+ 	struct opregion_swsci __iomem *swsci = dev_priv->opregion.swsci;
+ 	u32 main_function, sub_function, scic;
+ 	u16 pci_swsci;
+ 	u32 dslp;
+ 
+ 	if (!swsci)
+ 		return -ENODEV;
+ 
+ 	main_function = (function & SWSCI_SCIC_MAIN_FUNCTION_MASK) >>
+ 		SWSCI_SCIC_MAIN_FUNCTION_SHIFT;
+ 	sub_function = (function & SWSCI_SCIC_SUB_FUNCTION_MASK) >>
+ 		SWSCI_SCIC_SUB_FUNCTION_SHIFT;
+ 
+ 	/* Check if we can call the function. See swsci_setup for details. */
+ 	if (main_function == SWSCI_SBCB) {
+ 		if ((dev_priv->opregion.swsci_sbcb_sub_functions &
+ 		     (1 << sub_function)) == 0)
+ 			return -EINVAL;
+ 	} else if (main_function == SWSCI_GBDA) {
+ 		if ((dev_priv->opregion.swsci_gbda_sub_functions &
+ 		     (1 << sub_function)) == 0)
+ 			return -EINVAL;
+ 	}
+ 
+ 	/* Driver sleep timeout in ms. */
+ 	dslp = ioread32(&swsci->dslp);
+ 	if (!dslp) {
+ 		/* The spec says 2ms should be the default, but it's too small
+ 		 * for some machines. */
+ 		dslp = 50;
+ 	} else if (dslp > MAX_DSLP) {
+ 		/* Hey bios, trust must be earned. */
+ 		DRM_INFO_ONCE("ACPI BIOS requests an excessive sleep of %u ms, "
+ 			      "using %u ms instead\n", dslp, MAX_DSLP);
+ 		dslp = MAX_DSLP;
+ 	}
+ 
+ 	/* The spec tells us to do this, but we are the only user... */
+ 	scic = ioread32(&swsci->scic);
+ 	if (scic & SWSCI_SCIC_INDICATOR) {
+ 		DRM_DEBUG_DRIVER("SWSCI request already in progress\n");
+ 		return -EBUSY;
+ 	}
+ 
+ 	scic = function | SWSCI_SCIC_INDICATOR;
+ 
+ 	iowrite32(parm, &swsci->parm);
+ 	iowrite32(scic, &swsci->scic);
+ 
+ 	/* Ensure SCI event is selected and event trigger is cleared. */
+ 	pci_read_config_word(dev->pdev, PCI_SWSCI, &pci_swsci);
+ 	if (!(pci_swsci & PCI_SWSCI_SCISEL) || (pci_swsci & PCI_SWSCI_GSSCIE)) {
+ 		pci_swsci |= PCI_SWSCI_SCISEL;
+ 		pci_swsci &= ~PCI_SWSCI_GSSCIE;
+ 		pci_write_config_word(dev->pdev, PCI_SWSCI, pci_swsci);
+ 	}
+ 
+ 	/* Use event trigger to tell bios to check the mail. */
+ 	pci_swsci |= PCI_SWSCI_GSSCIE;
+ 	pci_write_config_word(dev->pdev, PCI_SWSCI, pci_swsci);
+ 
+ 	/* Poll for the result. */
+ #define C (((scic = ioread32(&swsci->scic)) & SWSCI_SCIC_INDICATOR) == 0)
+ 	if (wait_for(C, dslp)) {
+ 		DRM_DEBUG_DRIVER("SWSCI request timed out\n");
+ 		return -ETIMEDOUT;
+ 	}
+ 
+ 	scic = (scic & SWSCI_SCIC_EXIT_STATUS_MASK) >>
+ 		SWSCI_SCIC_EXIT_STATUS_SHIFT;
+ 
+ 	/* Note: scic == 0 is an error! */
+ 	if (scic != SWSCI_SCIC_EXIT_STATUS_SUCCESS) {
+ 		DRM_DEBUG_DRIVER("SWSCI request error %u\n", scic);
+ 		return -EIO;
+ 	}
+ 
+ 	if (parm_out)
+ 		*parm_out = ioread32(&swsci->parm);
+ 
+ 	return 0;
+ 
+ #undef C
+ }
+ 
+ #define DISPLAY_TYPE_CRT			0
+ #define DISPLAY_TYPE_TV				1
+ #define DISPLAY_TYPE_EXTERNAL_FLAT_PANEL	2
+ #define DISPLAY_TYPE_INTERNAL_FLAT_PANEL	3
+ 
+ int intel_opregion_notify_encoder(struct intel_encoder *intel_encoder,
+ 				  bool enable)
+ {
+ 	struct drm_device *dev = intel_encoder->base.dev;
+ 	u32 parm = 0;
+ 	u32 type = 0;
+ 	u32 port;
+ 
+ 	/* don't care about old stuff for now */
+ 	if (!HAS_DDI(dev))
+ 		return 0;
+ 
+ 	port = intel_ddi_get_encoder_port(intel_encoder);
+ 	if (port == PORT_E) {
+ 		port = 0;
+ 	} else {
+ 		parm |= 1 << port;
+ 		port++;
+ 	}
+ 
+ 	if (!enable)
+ 		parm |= 4 << 8;
+ 
+ 	switch (intel_encoder->type) {
+ 	case INTEL_OUTPUT_ANALOG:
+ 		type = DISPLAY_TYPE_CRT;
+ 		break;
+ 	case INTEL_OUTPUT_UNKNOWN:
+ 	case INTEL_OUTPUT_DISPLAYPORT:
+ 	case INTEL_OUTPUT_HDMI:
+ 		type = DISPLAY_TYPE_EXTERNAL_FLAT_PANEL;
+ 		break;
+ 	case INTEL_OUTPUT_EDP:
+ 		type = DISPLAY_TYPE_INTERNAL_FLAT_PANEL;
+ 		break;
+ 	default:
+ 		WARN_ONCE(1, "unsupported intel_encoder type %d\n",
+ 			  intel_encoder->type);
+ 		return -EINVAL;
+ 	}
+ 
+ 	parm |= type << (16 + port * 3);
+ 
+ 	return swsci(dev, SWSCI_SBCB_DISPLAY_POWER_STATE, parm, NULL);
+ }
+ 
+ static const struct {
+ 	pci_power_t pci_power_state;
+ 	u32 parm;
+ } power_state_map[] = {
+ 	{ PCI_D0,	0x00 },
+ 	{ PCI_D1,	0x01 },
+ 	{ PCI_D2,	0x02 },
+ 	{ PCI_D3hot,	0x04 },
+ 	{ PCI_D3cold,	0x04 },
+ };
+ 
+ int intel_opregion_notify_adapter(struct drm_device *dev, pci_power_t state)
+ {
+ 	int i;
+ 
+ 	if (!HAS_DDI(dev))
+ 		return 0;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(power_state_map); i++) {
+ 		if (state == power_state_map[i].pci_power_state)
+ 			return swsci(dev, SWSCI_SBCB_ADAPTER_POWER_STATE,
+ 				     power_state_map[i].parm, NULL);
+ 	}
+ 
+ 	return -EINVAL;
+ }
+ 
++>>>>>>> bdde5c6a258a (drm/i915: demote opregion excessive timeout WARN_ONCE to DRM_INFO_ONCE)
  static u32 asle_set_backlight(struct drm_device *dev, u32 bclp)
  {
  	struct drm_i915_private *dev_priv = dev->dev_private;
* Unmerged path drivers/gpu/drm/i915/intel_opregion.c
