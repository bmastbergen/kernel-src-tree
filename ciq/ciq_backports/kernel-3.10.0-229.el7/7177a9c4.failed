fs: call rename2 if exists

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [fs] call rename2 if exists (David Howells) [985875]
Rebuild_FUZZ: 91.67%
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit 7177a9c4b509eb357cc450256bc3cf39f1a1e639
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/7177a9c4.failed

Christoph Hellwig suggests:

1) make vfs_rename call ->rename2 if it exists instead of ->rename
2) switch all filesystems that you're adding NOREPLACE support for to
   use ->rename2
3) see how many ->rename instances we'll have left after a few
   iterations of 2.

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
(cherry picked from commit 7177a9c4b509eb357cc450256bc3cf39f1a1e639)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/ext4/namei.c
#	fs/fuse/dir.c
#	fs/namei.c
diff --cc fs/ext4/namei.c
index 02ee66b9dd7b,b147a67baa0d..000000000000
--- a/fs/ext4/namei.c
+++ b/fs/ext4/namei.c
@@@ -3260,7 -3454,8 +3260,12 @@@ const struct inode_operations ext4_dir_
  	.mkdir		= ext4_mkdir,
  	.rmdir		= ext4_rmdir,
  	.mknod		= ext4_mknod,
++<<<<<<< HEAD
 +	.rename		= ext4_rename,
++=======
+ 	.tmpfile	= ext4_tmpfile,
+ 	.rename2	= ext4_rename2,
++>>>>>>> 7177a9c4b509 (fs: call rename2 if exists)
  	.setattr	= ext4_setattr,
  	.setxattr	= generic_setxattr,
  	.getxattr	= generic_getxattr,
diff --cc fs/fuse/dir.c
index 8353dae6b4a4,de1d84af9f7c..000000000000
--- a/fs/fuse/dir.c
+++ b/fs/fuse/dir.c
@@@ -811,6 -815,36 +811,39 @@@ static int fuse_rename(struct inode *ol
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int fuse_rename2(struct inode *olddir, struct dentry *oldent,
+ 			struct inode *newdir, struct dentry *newent,
+ 			unsigned int flags)
+ {
+ 	struct fuse_conn *fc = get_fuse_conn(olddir);
+ 	int err;
+ 
+ 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE))
+ 		return -EINVAL;
+ 
+ 	if (flags) {
+ 		if (fc->no_rename2 || fc->minor < 23)
+ 			return -EINVAL;
+ 
+ 		err = fuse_rename_common(olddir, oldent, newdir, newent, flags,
+ 					 FUSE_RENAME2,
+ 					 sizeof(struct fuse_rename2_in));
+ 		if (err == -ENOSYS) {
+ 			fc->no_rename2 = 1;
+ 			err = -EINVAL;
+ 		}
+ 	} else {
+ 		err = fuse_rename_common(olddir, oldent, newdir, newent, 0,
+ 					 FUSE_RENAME,
+ 					 sizeof(struct fuse_rename_in));
+ 	}
+ 
+ 	return err;
+ }
+ 
++>>>>>>> 7177a9c4b509 (fs: call rename2 if exists)
  static int fuse_link(struct dentry *entry, struct inode *newdir,
  		     struct dentry *newent)
  {
@@@ -1899,7 -2018,7 +1932,11 @@@ static const struct inode_operations fu
  	.symlink	= fuse_symlink,
  	.unlink		= fuse_unlink,
  	.rmdir		= fuse_rmdir,
++<<<<<<< HEAD
 +	.rename		= fuse_rename,
++=======
+ 	.rename2	= fuse_rename2,
++>>>>>>> 7177a9c4b509 (fs: call rename2 if exists)
  	.link		= fuse_link,
  	.setattr	= fuse_setattr,
  	.create		= fuse_create,
diff --cc fs/namei.c
index d87d2e09b208,0ff23cecb1bb..000000000000
--- a/fs/namei.c
+++ b/fs/namei.c
@@@ -3981,13 -4043,44 +3981,42 @@@ SYSCALL_DEFINE2(link, const char __use
   *	   ->i_mutex on parents, which works but leads to some truly excessive
   *	   locking].
   */
 -int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
 -	       struct inode *new_dir, struct dentry *new_dentry,
 -	       struct inode **delegated_inode, unsigned int flags)
 +static int vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry,
 +			  struct inode *new_dir, struct dentry *new_dentry)
  {
 -	int error;
 -	bool is_dir = d_is_dir(old_dentry);
 -	const unsigned char *old_name;
 -	struct inode *source = old_dentry->d_inode;
 +	int error = 0;
  	struct inode *target = new_dentry->d_inode;
 -	bool new_is_dir = false;
  	unsigned max_links = new_dir->i_sb->s_max_links;
  
++<<<<<<< HEAD
++=======
+ 	if (source == target)
+ 		return 0;
+ 
+ 	error = may_delete(old_dir, old_dentry, is_dir);
+ 	if (error)
+ 		return error;
+ 
+ 	if (!target) {
+ 		error = may_create(new_dir, new_dentry);
+ 	} else {
+ 		new_is_dir = d_is_dir(new_dentry);
+ 
+ 		if (!(flags & RENAME_EXCHANGE))
+ 			error = may_delete(new_dir, new_dentry, is_dir);
+ 		else
+ 			error = may_delete(new_dir, new_dentry, new_is_dir);
+ 	}
+ 	if (error)
+ 		return error;
+ 
+ 	if (!old_dir->i_op->rename && !old_dir->i_op->rename2)
+ 		return -EPERM;
+ 
+ 	if (flags && !old_dir->i_op->rename2)
+ 		return -EINVAL;
+ 
++>>>>>>> 7177a9c4b509 (fs: call rename2 if exists)
  	/*
  	 * If we are going to change the parent - check write permissions,
  	 * we'll need to flip '..'.
@@@ -4062,7 -4134,14 +4091,18 @@@ static int vfs_rename_other(struct inod
  		if (error)
  			goto out;
  	}
++<<<<<<< HEAD
 +	error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);
++=======
+ 	if (!old_dir->i_op->rename2) {
+ 		error = old_dir->i_op->rename(old_dir, old_dentry,
+ 					      new_dir, new_dentry);
+ 	} else {
+ 		WARN_ON(old_dir->i_op->rename != NULL);
+ 		error = old_dir->i_op->rename2(old_dir, old_dentry,
+ 					       new_dir, new_dentry, flags);
+ 	}
++>>>>>>> 7177a9c4b509 (fs: call rename2 if exists)
  	if (error)
  		goto out;
  
* Unmerged path fs/ext4/namei.c
* Unmerged path fs/fuse/dir.c
* Unmerged path fs/namei.c
