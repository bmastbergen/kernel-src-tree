qlcnic: Allow single Tx/Rx queue for all adapters.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [ethernet] qlcnic: Allow single Tx/Rx queue for all adapters (Chad Dupuis) [1089352]
Rebuild_FUZZ: 98.99%
commit-author Himanshu Madhani <himanshu.madhani@qlogic.com>
commit 80c0e4f3a3a43664b38477fa5d9e6b6149b34d80
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/80c0e4f3.failed

o Allow user to set sigle Tx/Rx queue in MSI-x mode,
  for ALL supported adapters.

	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Signed-off-by: Manish Chopra <manish.chopra@qlogic.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 80c0e4f3a3a43664b38477fa5d9e6b6149b34d80)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
index cbeb43df6391,9e1494aab4d7..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
@@@ -1458,14 -1460,13 +1458,18 @@@ int qlcnic_82xx_napi_add(struct qlcnic_
  	struct qlcnic_recv_context *recv_ctx = adapter->recv_ctx;
  	struct qlcnic_host_tx_ring *tx_ring;
  
 -	if (qlcnic_alloc_sds_rings(recv_ctx, adapter->drv_sds_rings))
 +	if (qlcnic_alloc_sds_rings(recv_ctx, adapter->max_sds_rings))
  		return -ENOMEM;
  
 -	for (ring = 0; ring < adapter->drv_sds_rings; ring++) {
 +	for (ring = 0; ring < adapter->max_sds_rings; ring++) {
  		sds_ring = &recv_ctx->sds_rings[ring];
  		if (qlcnic_check_multi_tx(adapter) &&
++<<<<<<< HEAD
 +		    !adapter->ahw->diag_test &&
 +		    (adapter->max_drv_tx_rings > 1)) {
++=======
+ 		    !adapter->ahw->diag_test) {
++>>>>>>> 80c0e4f3a3a4 (qlcnic: Allow single Tx/Rx queue for all adapters.)
  			netif_napi_add(netdev, &sds_ring->napi, qlcnic_rx_poll,
  				       NAPI_POLL_WEIGHT);
  		} else {
@@@ -1538,9 -1539,8 +1542,14 @@@ void qlcnic_82xx_napi_enable(struct qlc
  
  	if (qlcnic_check_multi_tx(adapter) &&
  	    (adapter->flags & QLCNIC_MSIX_ENABLED) &&
++<<<<<<< HEAD
 +	    !adapter->ahw->diag_test &&
 +	    (adapter->max_drv_tx_rings > 1)) {
 +		for (ring = 0; ring < adapter->max_drv_tx_rings; ring++) {
++=======
+ 	    !adapter->ahw->diag_test) {
+ 		for (ring = 0; ring < adapter->drv_tx_rings; ring++) {
++>>>>>>> 80c0e4f3a3a4 (qlcnic: Allow single Tx/Rx queue for all adapters.)
  			tx_ring = &adapter->tx_ring[ring];
  			napi_enable(&tx_ring->napi);
  			qlcnic_enable_tx_intr(adapter, tx_ring);
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index 55ff51be212c,72a1c12decde..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@@ -607,13 -646,12 +607,18 @@@ int qlcnic_enable_msix(struct qlcnic_ad
  			} else {
  				adapter->ahw->num_msix = num_msix;
  				if (qlcnic_check_multi_tx(adapter) &&
++<<<<<<< HEAD
 +				    !adapter->ahw->diag_test &&
 +				    (adapter->max_drv_tx_rings > 1))
 +					max_sds_rings = num_msix - max_tx_rings;
++=======
+ 				    !adapter->ahw->diag_test)
+ 					drv_sds_rings = num_msix - drv_tx_rings;
++>>>>>>> 80c0e4f3a3a4 (qlcnic: Allow single Tx/Rx queue for all adapters.)
  				else
 -					drv_sds_rings = num_msix;
 +					max_sds_rings = num_msix;
  
 -				adapter->drv_sds_rings = drv_sds_rings;
 +				adapter->max_sds_rings = max_sds_rings;
  			}
  			dev_info(&pdev->dev, "using msi-x interrupts\n");
  			return err;
@@@ -3673,22 -3716,27 +3678,41 @@@ int qlcnic_validate_max_tx_rings(struc
  		return -EINVAL;
  	}
  
 -	if (adapter->flags & QLCNIC_MSI_ENABLED) {
 -		netdev_err(netdev, "No RSS/TSS support in MSI mode\n");
++<<<<<<< HEAD
 +	if (txq > QLCNIC_MAX_TX_RINGS) {
 +		netdev_err(netdev, "Invalid ring count\n");
  		return -EINVAL;
  	}
  
 +	max_allowed = rounddown_pow_of_two(min_t(int, max_hw,
 +						 num_online_cpus()));
 +	if ((txq > max_allowed) || !is_power_of_2(txq)) {
 +		if (!is_power_of_2(txq))
 +			netdev_err(netdev,
 +				   "TX queue should be a power of 2\n");
 +		if (txq > num_online_cpus())
 +			netdev_err(netdev,
 +				   "Tx queue should not be higher than [%u], number of online CPUs in the system\n",
 +				   num_online_cpus());
 +		netdev_err(netdev, "Unable to configure %u Tx rings\n", txq);
++=======
+ 	if (!is_power_of_2(ring_cnt)) {
+ 		netdev_err(netdev, "%s rings value should be a power of 2\n",
+ 			   buf);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (qlcnic_82xx_check(adapter) && (queue_type == QLCNIC_TX_QUEUE) &&
+ 	    !qlcnic_check_multi_tx(adapter)) {
+ 			netdev_err(netdev, "No Multi Tx queue support\n");
+ 			return -EINVAL;
+ 	}
+ 
+ 	if (ring_cnt > num_online_cpus()) {
+ 		netdev_err(netdev,
+ 			   "%s value[%u] should not be higher than, number of online CPUs\n",
+ 			   buf, num_online_cpus());
++>>>>>>> 80c0e4f3a3a4 (qlcnic: Allow single Tx/Rx queue for all adapters.)
  		return -EINVAL;
  	}
  
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
index 3b8f8ff4c895..57123f8db523 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
@@ -292,6 +292,7 @@ int qlcnic_83xx_setup_intr(struct qlcnic_adapter *adapter, u8 num_intr, int txq)
 		if (qlcnic_sriov_vf_check(adapter))
 			return -EINVAL;
 		num_msix = 1;
+		adapter->drv_tx_rings = QLCNIC_SINGLE_RING;
 	}
 	/* setup interrupt mapping table for fw */
 	ahw->intr_tbl = vzalloc(num_msix *
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
