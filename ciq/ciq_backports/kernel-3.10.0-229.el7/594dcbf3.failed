perf ui/hist: Add support to accumulated hist stat

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf/ui/hist: Add support to accumulated hist stat (Jiri Olsa) [1134356]
Rebuild_FUZZ: 98.00%
commit-author Namhyung Kim <namhyung@kernel.org>
commit 594dcbf3186e2e1e5c08fa21e8826b90d347f23f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/594dcbf3.failed

Print accumulated stat of a hist entry if requested.

To do that, add new HPP_PERCENT_ACC_FNS macro and generate a
perf_hpp_fmt using it.  The __hpp__sort_acc() function sorts entries
by accumulated period value.  When accumulated periods of two entries
are same (i.e. single path callchain) put the caller above since
accumulation tends to put callers on higher position for obvious
reason.

Also add "overhead_children" output field to be selected by user.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Tested-by: Arun Sharma <asharma@fb.com>
	Tested-by: Rodrigo Campos <rodrigo@sdfg.com.ar>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
Link: http://lkml.kernel.org/r/1401335910-16832-11-git-send-email-namhyung@kernel.org
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
(cherry picked from commit 594dcbf3186e2e1e5c08fa21e8826b90d347f23f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/ui/hist.c
diff --cc tools/perf/ui/hist.c
index 24116a48298f,0ce3e79b2ca7..000000000000
--- a/tools/perf/ui/hist.c
+++ b/tools/perf/ui/hist.c
@@@ -355,6 -441,19 +441,22 @@@ void perf_hpp__init(void
  			INIT_LIST_HEAD(&fmt->sort_list);
  	}
  
++<<<<<<< HEAD
++=======
+ 	/*
+ 	 * If user specified field order, no need to setup default fields.
+ 	 */
+ 	if (field_order)
+ 		return;
+ 
+ 	if (symbol_conf.cumulate_callchain) {
+ 		perf_hpp__column_enable(PERF_HPP__OVERHEAD_ACC);
+ 
+ 		perf_hpp__format[PERF_HPP__OVERHEAD].header =
+ 						hpp__header_overhead_self;
+ 	}
+ 
++>>>>>>> 594dcbf3186e (perf ui/hist: Add support to accumulated hist stat)
  	perf_hpp__column_enable(PERF_HPP__OVERHEAD);
  
  	if (symbol_conf.show_cpu_utilization) {
@@@ -378,7 -477,11 +480,15 @@@
  	if (list_empty(list))
  		list_add(list, &perf_hpp__sort_list);
  
++<<<<<<< HEAD
 +	perf_hpp__setup_output_field();
++=======
+ 	if (symbol_conf.cumulate_callchain) {
+ 		list = &perf_hpp__format[PERF_HPP__OVERHEAD_ACC].sort_list;
+ 		if (list_empty(list))
+ 			list_add(list, &perf_hpp__sort_list);
+ 	}
++>>>>>>> 594dcbf3186e (perf ui/hist: Add support to accumulated hist stat)
  }
  
  void perf_hpp__column_register(struct perf_hpp_fmt *format)
* Unmerged path tools/perf/ui/hist.c
diff --git a/tools/perf/util/hist.h b/tools/perf/util/hist.h
index 4b860e6a25f0..dc0c0cedb125 100644
--- a/tools/perf/util/hist.h
+++ b/tools/perf/util/hist.h
@@ -181,6 +181,7 @@ enum {
 	PERF_HPP__OVERHEAD_US,
 	PERF_HPP__OVERHEAD_GUEST_SYS,
 	PERF_HPP__OVERHEAD_GUEST_US,
+	PERF_HPP__OVERHEAD_ACC,
 	PERF_HPP__SAMPLES,
 	PERF_HPP__PERIOD,
 
@@ -200,6 +201,9 @@ typedef int (*hpp_snprint_fn)(struct perf_hpp *hpp, const char *fmt, ...);
 int __hpp__fmt(struct perf_hpp *hpp, struct hist_entry *he,
 	       hpp_field_fn get_field, const char *fmt,
 	       hpp_snprint_fn print_fn, bool fmt_percent);
+int __hpp__fmt_acc(struct perf_hpp *hpp, struct hist_entry *he,
+		   hpp_field_fn get_field, const char *fmt,
+		   hpp_snprint_fn print_fn, bool fmt_percent);
 
 static inline void advance_hpp(struct perf_hpp *hpp, int inc)
 {
diff --git a/tools/perf/util/sort.c b/tools/perf/util/sort.c
index 916652af8304..bd78ee3ce591 100644
--- a/tools/perf/util/sort.c
+++ b/tools/perf/util/sort.c
@@ -1042,6 +1042,7 @@ static struct hpp_dimension hpp_sort_dimensions[] = {
 	DIM(PERF_HPP__OVERHEAD_US, "overhead_us"),
 	DIM(PERF_HPP__OVERHEAD_GUEST_SYS, "overhead_guest_sys"),
 	DIM(PERF_HPP__OVERHEAD_GUEST_US, "overhead_guest_us"),
+	DIM(PERF_HPP__OVERHEAD_ACC, "overhead_children"),
 	DIM(PERF_HPP__SAMPLES, "sample"),
 	DIM(PERF_HPP__PERIOD, "period"),
 };
