GFS2: Increase the max number of ACLs

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Bob Peterson <rpeterso@redhat.com>
commit b00263d1cafdd667de56cde47f35d5ee8dd37e14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/b00263d1.failed

This patch increases the maximum number of ACLs from 25 to 300 for
a 4K block size. The value is adjusted accordingly if the block size
is smaller. Note that this is an arbitrary limit with a performance
tradeoff, and that the physical limit is slightly over 500.

	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Signed-off-by: Steven Whitehouse <swhiteho@redhat.com>

(cherry picked from commit b00263d1cafdd667de56cde47f35d5ee8dd37e14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/acl.c
diff --cc fs/gfs2/acl.c
index f69ac0af5496,394dc5561842..000000000000
--- a/fs/gfs2/acl.c
+++ b/fs/gfs2/acl.c
@@@ -88,18 -84,48 +88,57 @@@ static int gfs2_acl_set(struct inode *i
  	const char *name = gfs2_acl_name(type);
  
  	BUG_ON(name == NULL);
++<<<<<<< HEAD
 +	len = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);
 +	if (len == 0)
 +		return 0;
 +	data = kmalloc(len, GFP_NOFS);
 +	if (data == NULL)
 +		return -ENOMEM;
 +	error = posix_acl_to_xattr(&init_user_ns, acl, data, len);
 +	if (error < 0)
++=======
+ 
+ 	if (acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))
+ 		return -E2BIG;
+ 
+ 	if (type == ACL_TYPE_ACCESS) {
+ 		umode_t mode = inode->i_mode;
+ 
+ 		error = posix_acl_equiv_mode(acl, &mode);
+ 		if (error < 0)
+ 			return error;
+ 
+ 		if (error == 0)
+ 			acl = NULL;
+ 
+ 		error = gfs2_set_mode(inode, mode);
+ 		if (error)
+ 			return error;
+ 	}
+ 
+ 	if (acl) {
+ 		len = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);
+ 		if (len == 0)
+ 			return 0;
+ 		data = kmalloc(len, GFP_NOFS);
+ 		if (data == NULL)
+ 			return -ENOMEM;
+ 		error = posix_acl_to_xattr(&init_user_ns, acl, data, len);
+ 		if (error < 0)
+ 			goto out;
+ 	} else {
+ 		data = NULL;
+ 		len = 0;
+ 	}
+ 
+ 	error = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);
+ 	if (error)
++>>>>>>> b00263d1cafd (GFS2: Increase the max number of ACLs)
  		goto out;
 -
 -	if (acl)
 +	error = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);
 +	if (!error)
  		set_cached_acl(inode, type, acl);
 -	else
 -		forget_cached_acl(inode, type);
  out:
  	kfree(data);
  	return error;
* Unmerged path fs/gfs2/acl.c
diff --git a/fs/gfs2/acl.h b/fs/gfs2/acl.h
index 0da38dc7efec..ddc2cc8ab933 100644
--- a/fs/gfs2/acl.h
+++ b/fs/gfs2/acl.h
@@ -14,7 +14,7 @@
 
 #define GFS2_POSIX_ACL_ACCESS		"posix_acl_access"
 #define GFS2_POSIX_ACL_DEFAULT		"posix_acl_default"
-#define GFS2_ACL_MAX_ENTRIES		25
+#define GFS2_ACL_MAX_ENTRIES(sdp) ((300 << (sdp)->sd_sb.sb_bsize_shift) >> 12)
 
 extern struct posix_acl *gfs2_get_acl(struct inode *inode, int type);
 extern int gfs2_acl_create(struct gfs2_inode *dip, struct inode *inode);
