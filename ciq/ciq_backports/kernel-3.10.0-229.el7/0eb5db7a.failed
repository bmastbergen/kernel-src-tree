netfilter: nfnetlink: add rcu_dereference_protected() helpers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Patrick McHardy <kaber@trash.net>
commit 0eb5db7ad302a24fe6f0eb4bfd235357047a28db
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0eb5db7a.failed

Add a lockdep_nfnl_is_held() function and a nfnl_dereference() macro for
RCU dereferences protected by a NFNL subsystem mutex.

	Signed-off-by: Patrick McHardy <kaber@trash.net>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 0eb5db7ad302a24fe6f0eb4bfd235357047a28db)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/netfilter/nfnetlink.h
diff --cc include/linux/netfilter/nfnetlink.h
index 683ebd4bf728,e955d4730625..000000000000
--- a/include/linux/netfilter/nfnetlink.h
+++ b/include/linux/netfilter/nfnetlink.h
@@@ -30,20 -30,41 +30,46 @@@ struct nfnetlink_subsystem 
  	int (*abort)(struct sk_buff *skb);
  };
  
 -int nfnetlink_subsys_register(const struct nfnetlink_subsystem *n);
 -int nfnetlink_subsys_unregister(const struct nfnetlink_subsystem *n);
 +extern int nfnetlink_subsys_register(const struct nfnetlink_subsystem *n);
 +extern int nfnetlink_subsys_unregister(const struct nfnetlink_subsystem *n);
  
 -int nfnetlink_has_listeners(struct net *net, unsigned int group);
 -struct sk_buff *nfnetlink_alloc_skb(struct net *net, unsigned int size,
 -				    u32 dst_portid, gfp_t gfp_mask);
 -int nfnetlink_send(struct sk_buff *skb, struct net *net, u32 portid,
 -		   unsigned int group, int echo, gfp_t flags);
 -int nfnetlink_set_err(struct net *net, u32 portid, u32 group, int error);
 -int nfnetlink_unicast(struct sk_buff *skb, struct net *net, u32 portid,
 -		      int flags);
 +extern int nfnetlink_has_listeners(struct net *net, unsigned int group);
 +extern struct sk_buff *nfnetlink_alloc_skb(struct net *net, unsigned int size,
 +					   u32 dst_portid, gfp_t gfp_mask);
 +extern int nfnetlink_send(struct sk_buff *skb, struct net *net, u32 portid,
 +			  unsigned int group, int echo, gfp_t flags);
 +extern int nfnetlink_set_err(struct net *net, u32 portid, u32 group, int error);
 +extern int nfnetlink_unicast(struct sk_buff *skb, struct net *net,
 +			     u32 portid, int flags);
  
++<<<<<<< HEAD
 +extern void nfnl_lock(__u8 subsys_id);
 +extern void nfnl_unlock(__u8 subsys_id);
++=======
+ void nfnl_lock(__u8 subsys_id);
+ void nfnl_unlock(__u8 subsys_id);
+ #ifdef CONFIG_PROVE_LOCKING
+ int lockdep_nfnl_is_held(__u8 subsys_id);
+ #else
+ static inline int lockdep_nfnl_is_held(__u8 subsys_id)
+ {
+ 	return 1;
+ }
+ #endif /* CONFIG_PROVE_LOCKING */
+ 
+ /*
+  * nfnl_dereference - fetch RCU pointer when updates are prevented by subsys mutex
+  *
+  * @p: The pointer to read, prior to dereferencing
+  * @ss: The nfnetlink subsystem ID
+  *
+  * Return the value of the specified RCU-protected pointer, but omit
+  * both the smp_read_barrier_depends() and the ACCESS_ONCE(), because
+  * caller holds the NFNL subsystem mutex.
+  */
+ #define nfnl_dereference(p, ss)					\
+ 	rcu_dereference_protected(p, lockdep_nfnl_is_held(ss))
++>>>>>>> 0eb5db7ad302 (netfilter: nfnetlink: add rcu_dereference_protected() helpers)
  
  #define MODULE_ALIAS_NFNL_SUBSYS(subsys) \
  	MODULE_ALIAS("nfnetlink-subsys-" __stringify(subsys))
* Unmerged path include/linux/netfilter/nfnetlink.h
diff --git a/net/netfilter/nfnetlink.c b/net/netfilter/nfnetlink.c
index 046aa13b4fea..e8138da4c14f 100644
--- a/net/netfilter/nfnetlink.c
+++ b/net/netfilter/nfnetlink.c
@@ -61,6 +61,14 @@ void nfnl_unlock(__u8 subsys_id)
 }
 EXPORT_SYMBOL_GPL(nfnl_unlock);
 
+#ifdef CONFIG_PROVE_LOCKING
+int lockdep_nfnl_is_held(u8 subsys_id)
+{
+	return lockdep_is_held(&table[subsys_id].mutex);
+}
+EXPORT_SYMBOL_GPL(lockdep_nfnl_is_held);
+#endif
+
 int nfnetlink_subsys_register(const struct nfnetlink_subsystem *n)
 {
 	nfnl_lock(n->subsys_id);
