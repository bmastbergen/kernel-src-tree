drm/nouveau: make sure display hardware is reinitialised on runtime resume

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] nouveau: make sure display hardware is reinitialised on runtime resume (Rob Clark) [1173317]
Rebuild_FUZZ: 97.22%
commit-author Ben Skeggs <bskeggs@redhat.com>
commit 6fbb702e27d78ad2458df048b58cca3454bc0965
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/6fbb702e.failed

Linus commit 05c63c2ff23a80b654d6c088ac3ba21628db0173 modified the
runtime suspend/resume paths to skip over display-related tasks to
avoid locking issues on resume.

Unfortunately, this resulted in the display hardware being left in
a partially initialised state, preventing subsequent modesets from
completing.

This commit unifies the (many) suspend/resume paths, bringing back
display (and fbcon) handling in the runtime paths.

	Signed-off-by: Ben Skeggs <bskeggs@redhat.com>
(cherry picked from commit 6fbb702e27d78ad2458df048b58cca3454bc0965)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/nouveau/nouveau_display.c
#	drivers/gpu/drm/nouveau/nouveau_drm.c
diff --cc drivers/gpu/drm/nouveau/nouveau_display.c
index e05c9e8b96c2,4a21b2b06ce2..000000000000
--- a/drivers/gpu/drm/nouveau/nouveau_display.c
+++ b/drivers/gpu/drm/nouveau/nouveau_display.c
@@@ -462,7 -556,6 +461,10 @@@ nouveau_display_suspend(struct drm_devi
  
  	nouveau_display_fini(dev);
  
++<<<<<<< HEAD
 +	NV_SUSPEND(drm, "unpinning framebuffer(s)...\n");
++=======
++>>>>>>> 6fbb702e27d7 (drm/nouveau: make sure display hardware is reinitialised on runtime resume)
  	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
  		struct nouveau_framebuffer *nouveau_fb;
  
diff --cc drivers/gpu/drm/nouveau/nouveau_drm.c
index 1e7180b3602d,3ed32dd90303..000000000000
--- a/drivers/gpu/drm/nouveau/nouveau_drm.c
+++ b/drivers/gpu/drm/nouveau/nouveau_drm.c
@@@ -461,8 -548,10 +461,15 @@@ nouveau_do_suspend(struct drm_device *d
  	int ret;
  
  	if (dev->mode_config.num_crtc) {
++<<<<<<< HEAD
 +		NV_SUSPEND(drm, "suspending display...\n");
 +		ret = nouveau_display_suspend(dev);
++=======
+ 		NV_INFO(drm, "suspending console...\n");
+ 		nouveau_fbcon_set_suspend(dev, 1);
+ 		NV_INFO(drm, "suspending display...\n");
+ 		ret = nouveau_display_suspend(dev, runtime);
++>>>>>>> 6fbb702e27d7 (drm/nouveau: make sure display hardware is reinitialised on runtime resume)
  		if (ret)
  			return ret;
  	}
@@@ -505,12 -596,16 +512,17 @@@
  
  fail_client:
  	list_for_each_entry_continue_reverse(cli, &drm->clients, head) {
 -		nvif_client_resume(&cli->base);
 +		nouveau_client_init(&cli->base);
  	}
  
 -	if (drm->fence && nouveau_fence(drm)->resume)
 -		nouveau_fence(drm)->resume(drm);
 -
 -fail_display:
  	if (dev->mode_config.num_crtc) {
++<<<<<<< HEAD
 +		NV_SUSPEND(drm, "resuming display...\n");
 +		nouveau_display_resume(dev);
++=======
+ 		NV_INFO(drm, "resuming display...\n");
+ 		nouveau_display_resume(dev, runtime);
++>>>>>>> 6fbb702e27d7 (drm/nouveau: make sure display hardware is reinitialised on runtime resume)
  	}
  	return ret;
  }
@@@ -525,11 -620,7 +537,15 @@@ int nouveau_pmops_suspend(struct devic
  	    drm_dev->switch_power_state == DRM_SWITCH_POWER_DYNAMIC_OFF)
  		return 0;
  
++<<<<<<< HEAD
 +	if (drm_dev->mode_config.num_crtc)
 +		nouveau_fbcon_set_suspend(drm_dev, 1);
 +
 +	nv_suspend_set_printk_level(NV_DBG_INFO);
 +	ret = nouveau_do_suspend(drm_dev);
++=======
+ 	ret = nouveau_do_suspend(drm_dev, false);
++>>>>>>> 6fbb702e27d7 (drm/nouveau: make sure display hardware is reinitialised on runtime resume)
  	if (ret)
  		return ret;
  
@@@ -564,11 -654,12 +580,18 @@@ nouveau_do_resume(struct drm_device *de
  	}
  
  	nouveau_run_vbios_init(dev);
 +	nouveau_pm_resume(dev);
  
  	if (dev->mode_config.num_crtc) {
++<<<<<<< HEAD
 +		NV_SUSPEND(drm, "resuming display...\n");
 +		nouveau_display_repin(dev);
++=======
+ 		NV_INFO(drm, "resuming display...\n");
+ 		nouveau_display_resume(dev, runtime);
+ 		NV_INFO(drm, "resuming console...\n");
+ 		nouveau_fbcon_set_suspend(dev, 0);
++>>>>>>> 6fbb702e27d7 (drm/nouveau: make sure display hardware is reinitialised on runtime resume)
  	}
  
  	return 0;
@@@ -591,56 -682,21 +614,68 @@@ int nouveau_pmops_resume(struct device 
  		return ret;
  	pci_set_master(pdev);
  
++<<<<<<< HEAD
 +	nv_suspend_set_printk_level(NV_DBG_INFO);
 +	ret = nouveau_do_resume(drm_dev);
 +	if (ret) {
 +		nv_suspend_set_printk_level(NV_DBG_DEBUG);
 +		return ret;
 +	}
 +	if (drm_dev->mode_config.num_crtc)
 +		nouveau_fbcon_set_suspend(drm_dev, 0);
 +
 +	nouveau_fbcon_zfill_all(drm_dev);
 +	if (drm_dev->mode_config.num_crtc)
 +		nouveau_display_resume(drm_dev);
 +	nv_suspend_set_printk_level(NV_DBG_DEBUG);
 +	return 0;
++=======
+ 	return nouveau_do_resume(drm_dev, false);
++>>>>>>> 6fbb702e27d7 (drm/nouveau: make sure display hardware is reinitialised on runtime resume)
  }
  
  static int nouveau_pmops_freeze(struct device *dev)
  {
  	struct pci_dev *pdev = to_pci_dev(dev);
  	struct drm_device *drm_dev = pci_get_drvdata(pdev);
++<<<<<<< HEAD
 +	int ret;
 +
 +	nv_suspend_set_printk_level(NV_DBG_INFO);
 +	if (drm_dev->mode_config.num_crtc)
 +		nouveau_fbcon_set_suspend(drm_dev, 1);
 +
 +	ret = nouveau_do_suspend(drm_dev);
 +	nv_suspend_set_printk_level(NV_DBG_DEBUG);
 +	return ret;
++=======
+ 	return nouveau_do_suspend(drm_dev, false);
++>>>>>>> 6fbb702e27d7 (drm/nouveau: make sure display hardware is reinitialised on runtime resume)
  }
  
  static int nouveau_pmops_thaw(struct device *dev)
  {
  	struct pci_dev *pdev = to_pci_dev(dev);
  	struct drm_device *drm_dev = pci_get_drvdata(pdev);
++<<<<<<< HEAD
 +	int ret;
 +
 +	nv_suspend_set_printk_level(NV_DBG_INFO);
 +	ret = nouveau_do_resume(drm_dev);
 +	if (ret) {
 +		nv_suspend_set_printk_level(NV_DBG_DEBUG);
 +		return ret;
 +	}
 +	if (drm_dev->mode_config.num_crtc)
 +		nouveau_fbcon_set_suspend(drm_dev, 0);
 +	nouveau_fbcon_zfill_all(drm_dev);
 +	if (drm_dev->mode_config.num_crtc)
 +		nouveau_display_resume(drm_dev);
 +	nv_suspend_set_printk_level(NV_DBG_DEBUG);
 +	return 0;
++=======
+ 	return nouveau_do_resume(drm_dev, false);
++>>>>>>> 6fbb702e27d7 (drm/nouveau: make sure display hardware is reinitialised on runtime resume)
  }
  
  
@@@ -878,14 -952,13 +913,18 @@@ static int nouveau_pmops_runtime_resume
  		return ret;
  	pci_set_master(pdev);
  
++<<<<<<< HEAD
 +	ret = nouveau_do_resume(drm_dev);
 +	if (drm_dev->mode_config.num_crtc)
 +		nouveau_display_resume(drm_dev);
++=======
+ 	ret = nouveau_do_resume(drm_dev, true);
++>>>>>>> 6fbb702e27d7 (drm/nouveau: make sure display hardware is reinitialised on runtime resume)
  	drm_kms_helper_poll_enable(drm_dev);
  	/* do magic */
 -	nvif_mask(device, 0x88488, (1 << 25), (1 << 25));
 +	nv_mask(device, 0x88488, (1 << 25), (1 << 25));
  	vga_switcheroo_set_dynamic_switch(pdev, VGA_SWITCHEROO_ON);
  	drm_dev->switch_power_state = DRM_SWITCH_POWER_ON;
 -	nv_debug_level(NORMAL);
  	return ret;
  }
  
* Unmerged path drivers/gpu/drm/nouveau/nouveau_display.c
diff --git a/drivers/gpu/drm/nouveau/nouveau_display.h b/drivers/gpu/drm/nouveau/nouveau_display.h
index 8bc8bab90e8d..e8261c193bda 100644
--- a/drivers/gpu/drm/nouveau/nouveau_display.h
+++ b/drivers/gpu/drm/nouveau/nouveau_display.h
@@ -58,9 +58,8 @@ int  nouveau_display_create(struct drm_device *dev);
 void nouveau_display_destroy(struct drm_device *dev);
 int  nouveau_display_init(struct drm_device *dev);
 void nouveau_display_fini(struct drm_device *dev);
-int  nouveau_display_suspend(struct drm_device *dev);
-void nouveau_display_repin(struct drm_device *dev);
-void nouveau_display_resume(struct drm_device *dev);
+int  nouveau_display_suspend(struct drm_device *dev, bool runtime);
+void nouveau_display_resume(struct drm_device *dev, bool runtime);
 int  nouveau_display_vblank_enable(struct drm_device *, int);
 void nouveau_display_vblank_disable(struct drm_device *, int);
 
* Unmerged path drivers/gpu/drm/nouveau/nouveau_drm.c
