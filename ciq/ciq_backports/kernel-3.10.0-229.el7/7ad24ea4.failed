net: get rid of SET_ETHTOOL_OPS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [ethernet] netxen: get rid of SET_ETHTOOL_OPS (Veaceslav Falico) [1089356]
Rebuild_FUZZ: 95.38%
commit-author Wilfried Klaebe <w-lkml@lebenslange-mailadresse.de>
commit 7ad24ea4bf620a32631d7b3069c3e30c078b0c3e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/7ad24ea4.failed

net: get rid of SET_ETHTOOL_OPS

Dave Miller mentioned he'd like to see SET_ETHTOOL_OPS gone.
This does that.

Mostly done via coccinelle script:
@@
struct ethtool_ops *ops;
struct net_device *dev;
@@
-       SET_ETHTOOL_OPS(dev, ops);
+       dev->ethtool_ops = ops;

Compile tested only, but I'd seriously wonder if this broke anything.

	Suggested-by: Dave Miller <davem@davemloft.net>
	Signed-off-by: Wilfried Klaebe <w-lkml@lebenslange-mailadresse.de>
	Acked-by: Felipe Balbi <balbi@ti.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7ad24ea4bf620a32631d7b3069c3e30c078b0c3e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/3com/3c589_cs.c
#	drivers/net/ethernet/altera/altera_tse_ethtool.c
#	drivers/net/ethernet/atheros/atlx/atl2.c
#	drivers/net/ethernet/broadcom/bcm63xx_enet.c
#	drivers/net/ethernet/broadcom/bcmsysport.c
#	drivers/net/ethernet/broadcom/genet/bcmgenet.c
#	drivers/net/ethernet/renesas/sh_eth.c
#	drivers/net/ethernet/samsung/sxgbe/sxgbe_ethtool.c
#	drivers/net/rionet.c
#	drivers/net/usb/r8152.c
#	drivers/net/xen-netback/interface.c
#	drivers/usb/gadget/u_ether.c
#	net/dsa/slave.c
diff --cc drivers/net/ethernet/3com/3c589_cs.c
index 078480aaa168,f18647c23559..000000000000
--- a/drivers/net/ethernet/3com/3c589_cs.c
+++ b/drivers/net/ethernet/3com/3c589_cs.c
@@@ -191,32 -195,32 +191,36 @@@ static const struct net_device_ops el3_
  
  static int tc589_probe(struct pcmcia_device *link)
  {
 -	struct el3_private *lp;
 -	struct net_device *dev;
 +    struct el3_private *lp;
 +    struct net_device *dev;
  
 -	dev_dbg(&link->dev, "3c589_attach()\n");
 +    dev_dbg(&link->dev, "3c589_attach()\n");
  
 -	/* Create new ethernet device */
 -	dev = alloc_etherdev(sizeof(struct el3_private));
 -	if (!dev)
 -		return -ENOMEM;
 -	lp = netdev_priv(dev);
 -	link->priv = dev;
 -	lp->p_dev = link;
 +    /* Create new ethernet device */
 +    dev = alloc_etherdev(sizeof(struct el3_private));
 +    if (!dev)
 +	 return -ENOMEM;
 +    lp = netdev_priv(dev);
 +    link->priv = dev;
 +    lp->p_dev = link;
  
 -	spin_lock_init(&lp->lock);
 -	link->resource[0]->end = 16;
 -	link->resource[0]->flags |= IO_DATA_PATH_WIDTH_16;
 +    spin_lock_init(&lp->lock);
 +    link->resource[0]->end = 16;
 +    link->resource[0]->flags |= IO_DATA_PATH_WIDTH_16;
  
 -	link->config_flags |= CONF_ENABLE_IRQ;
 -	link->config_index = 1;
 +    link->config_flags |= CONF_ENABLE_IRQ;
 +    link->config_index = 1;
  
 -	dev->netdev_ops = &el3_netdev_ops;
 -	dev->watchdog_timeo = TX_TIMEOUT;
 +    dev->netdev_ops = &el3_netdev_ops;
 +    dev->watchdog_timeo = TX_TIMEOUT;
  
++<<<<<<< HEAD
 +    SET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);
++=======
+ 	dev->ethtool_ops = &netdev_ethtool_ops;
++>>>>>>> 7ad24ea4bf62 (net: get rid of SET_ETHTOOL_OPS)
  
 -	return tc589_config(link);
 +    return tc589_config(link);
  }
  
  static void tc589_detach(struct pcmcia_device *link)
diff --cc drivers/net/ethernet/atheros/atlx/atl2.c
index 265ce1b752ed,2587fed7b02c..000000000000
--- a/drivers/net/ethernet/atheros/atlx/atl2.c
+++ b/drivers/net/ethernet/atheros/atlx/atl2.c
@@@ -1397,7 -1396,7 +1397,11 @@@ static int atl2_probe(struct pci_dev *p
  	atl2_setup_pcicmd(pdev);
  
  	netdev->netdev_ops = &atl2_netdev_ops;
++<<<<<<< HEAD
 +	atl2_set_ethtool_ops(netdev);
++=======
+ 	netdev->ethtool_ops = &atl2_ethtool_ops;
++>>>>>>> 7ad24ea4bf62 (net: get rid of SET_ETHTOOL_OPS)
  	netdev->watchdog_timeo = 5 * HZ;
  	strncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);
  
diff --cc drivers/net/ethernet/broadcom/bcm63xx_enet.c
index 0b3e23ec37f7,3e8d1a88ed3d..000000000000
--- a/drivers/net/ethernet/broadcom/bcm63xx_enet.c
+++ b/drivers/net/ethernet/broadcom/bcm63xx_enet.c
@@@ -1862,8 -1986,864 +1862,867 @@@ struct platform_driver bcm63xx_enet_dri
  };
  
  /*
 - * switch mii access callbacks
 + * reserve & remap memory space shared between all macs
   */
++<<<<<<< HEAD
++=======
+ static int bcmenet_sw_mdio_read(struct bcm_enet_priv *priv,
+ 				int ext, int phy_id, int location)
+ {
+ 	u32 reg;
+ 	int ret;
+ 
+ 	spin_lock_bh(&priv->enetsw_mdio_lock);
+ 	enetsw_writel(priv, 0, ENETSW_MDIOC_REG);
+ 
+ 	reg = ENETSW_MDIOC_RD_MASK |
+ 		(phy_id << ENETSW_MDIOC_PHYID_SHIFT) |
+ 		(location << ENETSW_MDIOC_REG_SHIFT);
+ 
+ 	if (ext)
+ 		reg |= ENETSW_MDIOC_EXT_MASK;
+ 
+ 	enetsw_writel(priv, reg, ENETSW_MDIOC_REG);
+ 	udelay(50);
+ 	ret = enetsw_readw(priv, ENETSW_MDIOD_REG);
+ 	spin_unlock_bh(&priv->enetsw_mdio_lock);
+ 	return ret;
+ }
+ 
+ static void bcmenet_sw_mdio_write(struct bcm_enet_priv *priv,
+ 				 int ext, int phy_id, int location,
+ 				 uint16_t data)
+ {
+ 	u32 reg;
+ 
+ 	spin_lock_bh(&priv->enetsw_mdio_lock);
+ 	enetsw_writel(priv, 0, ENETSW_MDIOC_REG);
+ 
+ 	reg = ENETSW_MDIOC_WR_MASK |
+ 		(phy_id << ENETSW_MDIOC_PHYID_SHIFT) |
+ 		(location << ENETSW_MDIOC_REG_SHIFT);
+ 
+ 	if (ext)
+ 		reg |= ENETSW_MDIOC_EXT_MASK;
+ 
+ 	reg |= data;
+ 
+ 	enetsw_writel(priv, reg, ENETSW_MDIOC_REG);
+ 	udelay(50);
+ 	spin_unlock_bh(&priv->enetsw_mdio_lock);
+ }
+ 
+ static inline int bcm_enet_port_is_rgmii(int portid)
+ {
+ 	return portid >= ENETSW_RGMII_PORT0;
+ }
+ 
+ /*
+  * enet sw PHY polling
+  */
+ static void swphy_poll_timer(unsigned long data)
+ {
+ 	struct bcm_enet_priv *priv = (struct bcm_enet_priv *)data;
+ 	unsigned int i;
+ 
+ 	for (i = 0; i < priv->num_ports; i++) {
+ 		struct bcm63xx_enetsw_port *port;
+ 		int val, j, up, advertise, lpa, lpa2, speed, duplex, media;
+ 		int external_phy = bcm_enet_port_is_rgmii(i);
+ 		u8 override;
+ 
+ 		port = &priv->used_ports[i];
+ 		if (!port->used)
+ 			continue;
+ 
+ 		if (port->bypass_link)
+ 			continue;
+ 
+ 		/* dummy read to clear */
+ 		for (j = 0; j < 2; j++)
+ 			val = bcmenet_sw_mdio_read(priv, external_phy,
+ 						   port->phy_id, MII_BMSR);
+ 
+ 		if (val == 0xffff)
+ 			continue;
+ 
+ 		up = (val & BMSR_LSTATUS) ? 1 : 0;
+ 		if (!(up ^ priv->sw_port_link[i]))
+ 			continue;
+ 
+ 		priv->sw_port_link[i] = up;
+ 
+ 		/* link changed */
+ 		if (!up) {
+ 			dev_info(&priv->pdev->dev, "link DOWN on %s\n",
+ 				 port->name);
+ 			enetsw_writeb(priv, ENETSW_PORTOV_ENABLE_MASK,
+ 				      ENETSW_PORTOV_REG(i));
+ 			enetsw_writeb(priv, ENETSW_PTCTRL_RXDIS_MASK |
+ 				      ENETSW_PTCTRL_TXDIS_MASK,
+ 				      ENETSW_PTCTRL_REG(i));
+ 			continue;
+ 		}
+ 
+ 		advertise = bcmenet_sw_mdio_read(priv, external_phy,
+ 						 port->phy_id, MII_ADVERTISE);
+ 
+ 		lpa = bcmenet_sw_mdio_read(priv, external_phy, port->phy_id,
+ 					   MII_LPA);
+ 
+ 		lpa2 = bcmenet_sw_mdio_read(priv, external_phy, port->phy_id,
+ 					    MII_STAT1000);
+ 
+ 		/* figure out media and duplex from advertise and LPA values */
+ 		media = mii_nway_result(lpa & advertise);
+ 		duplex = (media & ADVERTISE_FULL) ? 1 : 0;
+ 		if (lpa2 & LPA_1000FULL)
+ 			duplex = 1;
+ 
+ 		if (lpa2 & (LPA_1000FULL | LPA_1000HALF))
+ 			speed = 1000;
+ 		else {
+ 			if (media & (ADVERTISE_100FULL | ADVERTISE_100HALF))
+ 				speed = 100;
+ 			else
+ 				speed = 10;
+ 		}
+ 
+ 		dev_info(&priv->pdev->dev,
+ 			 "link UP on %s, %dMbps, %s-duplex\n",
+ 			 port->name, speed, duplex ? "full" : "half");
+ 
+ 		override = ENETSW_PORTOV_ENABLE_MASK |
+ 			ENETSW_PORTOV_LINKUP_MASK;
+ 
+ 		if (speed == 1000)
+ 			override |= ENETSW_IMPOV_1000_MASK;
+ 		else if (speed == 100)
+ 			override |= ENETSW_IMPOV_100_MASK;
+ 		if (duplex)
+ 			override |= ENETSW_IMPOV_FDX_MASK;
+ 
+ 		enetsw_writeb(priv, override, ENETSW_PORTOV_REG(i));
+ 		enetsw_writeb(priv, 0, ENETSW_PTCTRL_REG(i));
+ 	}
+ 
+ 	priv->swphy_poll.expires = jiffies + HZ;
+ 	add_timer(&priv->swphy_poll);
+ }
+ 
+ /*
+  * open callback, allocate dma rings & buffers and start rx operation
+  */
+ static int bcm_enetsw_open(struct net_device *dev)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	struct device *kdev;
+ 	int i, ret;
+ 	unsigned int size;
+ 	void *p;
+ 	u32 val;
+ 
+ 	priv = netdev_priv(dev);
+ 	kdev = &priv->pdev->dev;
+ 
+ 	/* mask all interrupts and request them */
+ 	enet_dmac_writel(priv, 0, ENETDMAC_IRMASK, priv->rx_chan);
+ 	enet_dmac_writel(priv, 0, ENETDMAC_IRMASK, priv->tx_chan);
+ 
+ 	ret = request_irq(priv->irq_rx, bcm_enet_isr_dma,
+ 			  0, dev->name, dev);
+ 	if (ret)
+ 		goto out_freeirq;
+ 
+ 	if (priv->irq_tx != -1) {
+ 		ret = request_irq(priv->irq_tx, bcm_enet_isr_dma,
+ 				  0, dev->name, dev);
+ 		if (ret)
+ 			goto out_freeirq_rx;
+ 	}
+ 
+ 	/* allocate rx dma ring */
+ 	size = priv->rx_ring_size * sizeof(struct bcm_enet_desc);
+ 	p = dma_alloc_coherent(kdev, size, &priv->rx_desc_dma, GFP_KERNEL);
+ 	if (!p) {
+ 		dev_err(kdev, "cannot allocate rx ring %u\n", size);
+ 		ret = -ENOMEM;
+ 		goto out_freeirq_tx;
+ 	}
+ 
+ 	memset(p, 0, size);
+ 	priv->rx_desc_alloc_size = size;
+ 	priv->rx_desc_cpu = p;
+ 
+ 	/* allocate tx dma ring */
+ 	size = priv->tx_ring_size * sizeof(struct bcm_enet_desc);
+ 	p = dma_alloc_coherent(kdev, size, &priv->tx_desc_dma, GFP_KERNEL);
+ 	if (!p) {
+ 		dev_err(kdev, "cannot allocate tx ring\n");
+ 		ret = -ENOMEM;
+ 		goto out_free_rx_ring;
+ 	}
+ 
+ 	memset(p, 0, size);
+ 	priv->tx_desc_alloc_size = size;
+ 	priv->tx_desc_cpu = p;
+ 
+ 	priv->tx_skb = kzalloc(sizeof(struct sk_buff *) * priv->tx_ring_size,
+ 			       GFP_KERNEL);
+ 	if (!priv->tx_skb) {
+ 		dev_err(kdev, "cannot allocate rx skb queue\n");
+ 		ret = -ENOMEM;
+ 		goto out_free_tx_ring;
+ 	}
+ 
+ 	priv->tx_desc_count = priv->tx_ring_size;
+ 	priv->tx_dirty_desc = 0;
+ 	priv->tx_curr_desc = 0;
+ 	spin_lock_init(&priv->tx_lock);
+ 
+ 	/* init & fill rx ring with skbs */
+ 	priv->rx_skb = kzalloc(sizeof(struct sk_buff *) * priv->rx_ring_size,
+ 			       GFP_KERNEL);
+ 	if (!priv->rx_skb) {
+ 		dev_err(kdev, "cannot allocate rx skb queue\n");
+ 		ret = -ENOMEM;
+ 		goto out_free_tx_skb;
+ 	}
+ 
+ 	priv->rx_desc_count = 0;
+ 	priv->rx_dirty_desc = 0;
+ 	priv->rx_curr_desc = 0;
+ 
+ 	/* disable all ports */
+ 	for (i = 0; i < priv->num_ports; i++) {
+ 		enetsw_writeb(priv, ENETSW_PORTOV_ENABLE_MASK,
+ 			      ENETSW_PORTOV_REG(i));
+ 		enetsw_writeb(priv, ENETSW_PTCTRL_RXDIS_MASK |
+ 			      ENETSW_PTCTRL_TXDIS_MASK,
+ 			      ENETSW_PTCTRL_REG(i));
+ 
+ 		priv->sw_port_link[i] = 0;
+ 	}
+ 
+ 	/* reset mib */
+ 	val = enetsw_readb(priv, ENETSW_GMCR_REG);
+ 	val |= ENETSW_GMCR_RST_MIB_MASK;
+ 	enetsw_writeb(priv, val, ENETSW_GMCR_REG);
+ 	mdelay(1);
+ 	val &= ~ENETSW_GMCR_RST_MIB_MASK;
+ 	enetsw_writeb(priv, val, ENETSW_GMCR_REG);
+ 	mdelay(1);
+ 
+ 	/* force CPU port state */
+ 	val = enetsw_readb(priv, ENETSW_IMPOV_REG);
+ 	val |= ENETSW_IMPOV_FORCE_MASK | ENETSW_IMPOV_LINKUP_MASK;
+ 	enetsw_writeb(priv, val, ENETSW_IMPOV_REG);
+ 
+ 	/* enable switch forward engine */
+ 	val = enetsw_readb(priv, ENETSW_SWMODE_REG);
+ 	val |= ENETSW_SWMODE_FWD_EN_MASK;
+ 	enetsw_writeb(priv, val, ENETSW_SWMODE_REG);
+ 
+ 	/* enable jumbo on all ports */
+ 	enetsw_writel(priv, 0x1ff, ENETSW_JMBCTL_PORT_REG);
+ 	enetsw_writew(priv, 9728, ENETSW_JMBCTL_MAXSIZE_REG);
+ 
+ 	/* initialize flow control buffer allocation */
+ 	enet_dma_writel(priv, ENETDMA_BUFALLOC_FORCE_MASK | 0,
+ 			ENETDMA_BUFALLOC_REG(priv->rx_chan));
+ 
+ 	if (bcm_enet_refill_rx(dev)) {
+ 		dev_err(kdev, "cannot allocate rx skb queue\n");
+ 		ret = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	/* write rx & tx ring addresses */
+ 	enet_dmas_writel(priv, priv->rx_desc_dma,
+ 			 ENETDMAS_RSTART_REG, priv->rx_chan);
+ 	enet_dmas_writel(priv, priv->tx_desc_dma,
+ 			 ENETDMAS_RSTART_REG, priv->tx_chan);
+ 
+ 	/* clear remaining state ram for rx & tx channel */
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM2_REG, priv->rx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM2_REG, priv->tx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM3_REG, priv->rx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM3_REG, priv->tx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM4_REG, priv->rx_chan);
+ 	enet_dmas_writel(priv, 0, ENETDMAS_SRAM4_REG, priv->tx_chan);
+ 
+ 	/* set dma maximum burst len */
+ 	enet_dmac_writel(priv, priv->dma_maxburst,
+ 			 ENETDMAC_MAXBURST, priv->rx_chan);
+ 	enet_dmac_writel(priv, priv->dma_maxburst,
+ 			 ENETDMAC_MAXBURST, priv->tx_chan);
+ 
+ 	/* set flow control low/high threshold to 1/3 / 2/3 */
+ 	val = priv->rx_ring_size / 3;
+ 	enet_dma_writel(priv, val, ENETDMA_FLOWCL_REG(priv->rx_chan));
+ 	val = (priv->rx_ring_size * 2) / 3;
+ 	enet_dma_writel(priv, val, ENETDMA_FLOWCH_REG(priv->rx_chan));
+ 
+ 	/* all set, enable mac and interrupts, start dma engine and
+ 	 * kick rx dma channel
+ 	 */
+ 	wmb();
+ 	enet_dma_writel(priv, ENETDMA_CFG_EN_MASK, ENETDMA_CFG_REG);
+ 	enet_dmac_writel(priv, ENETDMAC_CHANCFG_EN_MASK,
+ 			 ENETDMAC_CHANCFG, priv->rx_chan);
+ 
+ 	/* watch "packet transferred" interrupt in rx and tx */
+ 	enet_dmac_writel(priv, ENETDMAC_IR_PKTDONE_MASK,
+ 			 ENETDMAC_IR, priv->rx_chan);
+ 	enet_dmac_writel(priv, ENETDMAC_IR_PKTDONE_MASK,
+ 			 ENETDMAC_IR, priv->tx_chan);
+ 
+ 	/* make sure we enable napi before rx interrupt  */
+ 	napi_enable(&priv->napi);
+ 
+ 	enet_dmac_writel(priv, ENETDMAC_IR_PKTDONE_MASK,
+ 			 ENETDMAC_IRMASK, priv->rx_chan);
+ 	enet_dmac_writel(priv, ENETDMAC_IR_PKTDONE_MASK,
+ 			 ENETDMAC_IRMASK, priv->tx_chan);
+ 
+ 	netif_carrier_on(dev);
+ 	netif_start_queue(dev);
+ 
+ 	/* apply override config for bypass_link ports here. */
+ 	for (i = 0; i < priv->num_ports; i++) {
+ 		struct bcm63xx_enetsw_port *port;
+ 		u8 override;
+ 		port = &priv->used_ports[i];
+ 		if (!port->used)
+ 			continue;
+ 
+ 		if (!port->bypass_link)
+ 			continue;
+ 
+ 		override = ENETSW_PORTOV_ENABLE_MASK |
+ 			ENETSW_PORTOV_LINKUP_MASK;
+ 
+ 		switch (port->force_speed) {
+ 		case 1000:
+ 			override |= ENETSW_IMPOV_1000_MASK;
+ 			break;
+ 		case 100:
+ 			override |= ENETSW_IMPOV_100_MASK;
+ 			break;
+ 		case 10:
+ 			break;
+ 		default:
+ 			pr_warn("invalid forced speed on port %s: assume 10\n",
+ 			       port->name);
+ 			break;
+ 		}
+ 
+ 		if (port->force_duplex_full)
+ 			override |= ENETSW_IMPOV_FDX_MASK;
+ 
+ 
+ 		enetsw_writeb(priv, override, ENETSW_PORTOV_REG(i));
+ 		enetsw_writeb(priv, 0, ENETSW_PTCTRL_REG(i));
+ 	}
+ 
+ 	/* start phy polling timer */
+ 	init_timer(&priv->swphy_poll);
+ 	priv->swphy_poll.function = swphy_poll_timer;
+ 	priv->swphy_poll.data = (unsigned long)priv;
+ 	priv->swphy_poll.expires = jiffies;
+ 	add_timer(&priv->swphy_poll);
+ 	return 0;
+ 
+ out:
+ 	for (i = 0; i < priv->rx_ring_size; i++) {
+ 		struct bcm_enet_desc *desc;
+ 
+ 		if (!priv->rx_skb[i])
+ 			continue;
+ 
+ 		desc = &priv->rx_desc_cpu[i];
+ 		dma_unmap_single(kdev, desc->address, priv->rx_skb_size,
+ 				 DMA_FROM_DEVICE);
+ 		kfree_skb(priv->rx_skb[i]);
+ 	}
+ 	kfree(priv->rx_skb);
+ 
+ out_free_tx_skb:
+ 	kfree(priv->tx_skb);
+ 
+ out_free_tx_ring:
+ 	dma_free_coherent(kdev, priv->tx_desc_alloc_size,
+ 			  priv->tx_desc_cpu, priv->tx_desc_dma);
+ 
+ out_free_rx_ring:
+ 	dma_free_coherent(kdev, priv->rx_desc_alloc_size,
+ 			  priv->rx_desc_cpu, priv->rx_desc_dma);
+ 
+ out_freeirq_tx:
+ 	if (priv->irq_tx != -1)
+ 		free_irq(priv->irq_tx, dev);
+ 
+ out_freeirq_rx:
+ 	free_irq(priv->irq_rx, dev);
+ 
+ out_freeirq:
+ 	return ret;
+ }
+ 
+ /* stop callback */
+ static int bcm_enetsw_stop(struct net_device *dev)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	struct device *kdev;
+ 	int i;
+ 
+ 	priv = netdev_priv(dev);
+ 	kdev = &priv->pdev->dev;
+ 
+ 	del_timer_sync(&priv->swphy_poll);
+ 	netif_stop_queue(dev);
+ 	napi_disable(&priv->napi);
+ 	del_timer_sync(&priv->rx_timeout);
+ 
+ 	/* mask all interrupts */
+ 	enet_dmac_writel(priv, 0, ENETDMAC_IRMASK, priv->rx_chan);
+ 	enet_dmac_writel(priv, 0, ENETDMAC_IRMASK, priv->tx_chan);
+ 
+ 	/* disable dma & mac */
+ 	bcm_enet_disable_dma(priv, priv->tx_chan);
+ 	bcm_enet_disable_dma(priv, priv->rx_chan);
+ 
+ 	/* force reclaim of all tx buffers */
+ 	bcm_enet_tx_reclaim(dev, 1);
+ 
+ 	/* free the rx skb ring */
+ 	for (i = 0; i < priv->rx_ring_size; i++) {
+ 		struct bcm_enet_desc *desc;
+ 
+ 		if (!priv->rx_skb[i])
+ 			continue;
+ 
+ 		desc = &priv->rx_desc_cpu[i];
+ 		dma_unmap_single(kdev, desc->address, priv->rx_skb_size,
+ 				 DMA_FROM_DEVICE);
+ 		kfree_skb(priv->rx_skb[i]);
+ 	}
+ 
+ 	/* free remaining allocated memory */
+ 	kfree(priv->rx_skb);
+ 	kfree(priv->tx_skb);
+ 	dma_free_coherent(kdev, priv->rx_desc_alloc_size,
+ 			  priv->rx_desc_cpu, priv->rx_desc_dma);
+ 	dma_free_coherent(kdev, priv->tx_desc_alloc_size,
+ 			  priv->tx_desc_cpu, priv->tx_desc_dma);
+ 	if (priv->irq_tx != -1)
+ 		free_irq(priv->irq_tx, dev);
+ 	free_irq(priv->irq_rx, dev);
+ 
+ 	return 0;
+ }
+ 
+ /* try to sort out phy external status by walking the used_port field
+  * in the bcm_enet_priv structure. in case the phy address is not
+  * assigned to any physical port on the switch, assume it is external
+  * (and yell at the user).
+  */
+ static int bcm_enetsw_phy_is_external(struct bcm_enet_priv *priv, int phy_id)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < priv->num_ports; ++i) {
+ 		if (!priv->used_ports[i].used)
+ 			continue;
+ 		if (priv->used_ports[i].phy_id == phy_id)
+ 			return bcm_enet_port_is_rgmii(i);
+ 	}
+ 
+ 	printk_once(KERN_WARNING  "bcm63xx_enet: could not find a used port with phy_id %i, assuming phy is external\n",
+ 		    phy_id);
+ 	return 1;
+ }
+ 
+ /* can't use bcmenet_sw_mdio_read directly as we need to sort out
+  * external/internal status of the given phy_id first.
+  */
+ static int bcm_enetsw_mii_mdio_read(struct net_device *dev, int phy_id,
+ 				    int location)
+ {
+ 	struct bcm_enet_priv *priv;
+ 
+ 	priv = netdev_priv(dev);
+ 	return bcmenet_sw_mdio_read(priv,
+ 				    bcm_enetsw_phy_is_external(priv, phy_id),
+ 				    phy_id, location);
+ }
+ 
+ /* can't use bcmenet_sw_mdio_write directly as we need to sort out
+  * external/internal status of the given phy_id first.
+  */
+ static void bcm_enetsw_mii_mdio_write(struct net_device *dev, int phy_id,
+ 				      int location,
+ 				      int val)
+ {
+ 	struct bcm_enet_priv *priv;
+ 
+ 	priv = netdev_priv(dev);
+ 	bcmenet_sw_mdio_write(priv, bcm_enetsw_phy_is_external(priv, phy_id),
+ 			      phy_id, location, val);
+ }
+ 
+ static int bcm_enetsw_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+ {
+ 	struct mii_if_info mii;
+ 
+ 	mii.dev = dev;
+ 	mii.mdio_read = bcm_enetsw_mii_mdio_read;
+ 	mii.mdio_write = bcm_enetsw_mii_mdio_write;
+ 	mii.phy_id = 0;
+ 	mii.phy_id_mask = 0x3f;
+ 	mii.reg_num_mask = 0x1f;
+ 	return generic_mii_ioctl(&mii, if_mii(rq), cmd, NULL);
+ 
+ }
+ 
+ static const struct net_device_ops bcm_enetsw_ops = {
+ 	.ndo_open		= bcm_enetsw_open,
+ 	.ndo_stop		= bcm_enetsw_stop,
+ 	.ndo_start_xmit		= bcm_enet_start_xmit,
+ 	.ndo_change_mtu		= bcm_enet_change_mtu,
+ 	.ndo_do_ioctl		= bcm_enetsw_ioctl,
+ };
+ 
+ 
+ static const struct bcm_enet_stats bcm_enetsw_gstrings_stats[] = {
+ 	{ "rx_packets", DEV_STAT(rx_packets), -1 },
+ 	{ "tx_packets",	DEV_STAT(tx_packets), -1 },
+ 	{ "rx_bytes", DEV_STAT(rx_bytes), -1 },
+ 	{ "tx_bytes", DEV_STAT(tx_bytes), -1 },
+ 	{ "rx_errors", DEV_STAT(rx_errors), -1 },
+ 	{ "tx_errors", DEV_STAT(tx_errors), -1 },
+ 	{ "rx_dropped",	DEV_STAT(rx_dropped), -1 },
+ 	{ "tx_dropped",	DEV_STAT(tx_dropped), -1 },
+ 
+ 	{ "tx_good_octets", GEN_STAT(mib.tx_gd_octets), ETHSW_MIB_RX_GD_OCT },
+ 	{ "tx_unicast", GEN_STAT(mib.tx_unicast), ETHSW_MIB_RX_BRDCAST },
+ 	{ "tx_broadcast", GEN_STAT(mib.tx_brdcast), ETHSW_MIB_RX_BRDCAST },
+ 	{ "tx_multicast", GEN_STAT(mib.tx_mult), ETHSW_MIB_RX_MULT },
+ 	{ "tx_64_octets", GEN_STAT(mib.tx_64), ETHSW_MIB_RX_64 },
+ 	{ "tx_65_127_oct", GEN_STAT(mib.tx_65_127), ETHSW_MIB_RX_65_127 },
+ 	{ "tx_128_255_oct", GEN_STAT(mib.tx_128_255), ETHSW_MIB_RX_128_255 },
+ 	{ "tx_256_511_oct", GEN_STAT(mib.tx_256_511), ETHSW_MIB_RX_256_511 },
+ 	{ "tx_512_1023_oct", GEN_STAT(mib.tx_512_1023), ETHSW_MIB_RX_512_1023},
+ 	{ "tx_1024_1522_oct", GEN_STAT(mib.tx_1024_max),
+ 	  ETHSW_MIB_RX_1024_1522 },
+ 	{ "tx_1523_2047_oct", GEN_STAT(mib.tx_1523_2047),
+ 	  ETHSW_MIB_RX_1523_2047 },
+ 	{ "tx_2048_4095_oct", GEN_STAT(mib.tx_2048_4095),
+ 	  ETHSW_MIB_RX_2048_4095 },
+ 	{ "tx_4096_8191_oct", GEN_STAT(mib.tx_4096_8191),
+ 	  ETHSW_MIB_RX_4096_8191 },
+ 	{ "tx_8192_9728_oct", GEN_STAT(mib.tx_8192_9728),
+ 	  ETHSW_MIB_RX_8192_9728 },
+ 	{ "tx_oversize", GEN_STAT(mib.tx_ovr), ETHSW_MIB_RX_OVR },
+ 	{ "tx_oversize_drop", GEN_STAT(mib.tx_ovr), ETHSW_MIB_RX_OVR_DISC },
+ 	{ "tx_dropped",	GEN_STAT(mib.tx_drop), ETHSW_MIB_RX_DROP },
+ 	{ "tx_undersize", GEN_STAT(mib.tx_underrun), ETHSW_MIB_RX_UND },
+ 	{ "tx_pause", GEN_STAT(mib.tx_pause), ETHSW_MIB_RX_PAUSE },
+ 
+ 	{ "rx_good_octets", GEN_STAT(mib.rx_gd_octets), ETHSW_MIB_TX_ALL_OCT },
+ 	{ "rx_broadcast", GEN_STAT(mib.rx_brdcast), ETHSW_MIB_TX_BRDCAST },
+ 	{ "rx_multicast", GEN_STAT(mib.rx_mult), ETHSW_MIB_TX_MULT },
+ 	{ "rx_unicast", GEN_STAT(mib.rx_unicast), ETHSW_MIB_TX_MULT },
+ 	{ "rx_pause", GEN_STAT(mib.rx_pause), ETHSW_MIB_TX_PAUSE },
+ 	{ "rx_dropped", GEN_STAT(mib.rx_drop), ETHSW_MIB_TX_DROP_PKTS },
+ 
+ };
+ 
+ #define BCM_ENETSW_STATS_LEN	\
+ 	(sizeof(bcm_enetsw_gstrings_stats) / sizeof(struct bcm_enet_stats))
+ 
+ static void bcm_enetsw_get_strings(struct net_device *netdev,
+ 				   u32 stringset, u8 *data)
+ {
+ 	int i;
+ 
+ 	switch (stringset) {
+ 	case ETH_SS_STATS:
+ 		for (i = 0; i < BCM_ENETSW_STATS_LEN; i++) {
+ 			memcpy(data + i * ETH_GSTRING_LEN,
+ 			       bcm_enetsw_gstrings_stats[i].stat_string,
+ 			       ETH_GSTRING_LEN);
+ 		}
+ 		break;
+ 	}
+ }
+ 
+ static int bcm_enetsw_get_sset_count(struct net_device *netdev,
+ 				     int string_set)
+ {
+ 	switch (string_set) {
+ 	case ETH_SS_STATS:
+ 		return BCM_ENETSW_STATS_LEN;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ }
+ 
+ static void bcm_enetsw_get_drvinfo(struct net_device *netdev,
+ 				   struct ethtool_drvinfo *drvinfo)
+ {
+ 	strncpy(drvinfo->driver, bcm_enet_driver_name, 32);
+ 	strncpy(drvinfo->version, bcm_enet_driver_version, 32);
+ 	strncpy(drvinfo->fw_version, "N/A", 32);
+ 	strncpy(drvinfo->bus_info, "bcm63xx", 32);
+ 	drvinfo->n_stats = BCM_ENETSW_STATS_LEN;
+ }
+ 
+ static void bcm_enetsw_get_ethtool_stats(struct net_device *netdev,
+ 					 struct ethtool_stats *stats,
+ 					 u64 *data)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	int i;
+ 
+ 	priv = netdev_priv(netdev);
+ 
+ 	for (i = 0; i < BCM_ENETSW_STATS_LEN; i++) {
+ 		const struct bcm_enet_stats *s;
+ 		u32 lo, hi;
+ 		char *p;
+ 		int reg;
+ 
+ 		s = &bcm_enetsw_gstrings_stats[i];
+ 
+ 		reg = s->mib_reg;
+ 		if (reg == -1)
+ 			continue;
+ 
+ 		lo = enetsw_readl(priv, ENETSW_MIB_REG(reg));
+ 		p = (char *)priv + s->stat_offset;
+ 
+ 		if (s->sizeof_stat == sizeof(u64)) {
+ 			hi = enetsw_readl(priv, ENETSW_MIB_REG(reg + 1));
+ 			*(u64 *)p = ((u64)hi << 32 | lo);
+ 		} else {
+ 			*(u32 *)p = lo;
+ 		}
+ 	}
+ 
+ 	for (i = 0; i < BCM_ENETSW_STATS_LEN; i++) {
+ 		const struct bcm_enet_stats *s;
+ 		char *p;
+ 
+ 		s = &bcm_enetsw_gstrings_stats[i];
+ 
+ 		if (s->mib_reg == -1)
+ 			p = (char *)&netdev->stats + s->stat_offset;
+ 		else
+ 			p = (char *)priv + s->stat_offset;
+ 
+ 		data[i] = (s->sizeof_stat == sizeof(u64)) ?
+ 			*(u64 *)p : *(u32 *)p;
+ 	}
+ }
+ 
+ static void bcm_enetsw_get_ringparam(struct net_device *dev,
+ 				     struct ethtool_ringparam *ering)
+ {
+ 	struct bcm_enet_priv *priv;
+ 
+ 	priv = netdev_priv(dev);
+ 
+ 	/* rx/tx ring is actually only limited by memory */
+ 	ering->rx_max_pending = 8192;
+ 	ering->tx_max_pending = 8192;
+ 	ering->rx_mini_max_pending = 0;
+ 	ering->rx_jumbo_max_pending = 0;
+ 	ering->rx_pending = priv->rx_ring_size;
+ 	ering->tx_pending = priv->tx_ring_size;
+ }
+ 
+ static int bcm_enetsw_set_ringparam(struct net_device *dev,
+ 				    struct ethtool_ringparam *ering)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	int was_running;
+ 
+ 	priv = netdev_priv(dev);
+ 
+ 	was_running = 0;
+ 	if (netif_running(dev)) {
+ 		bcm_enetsw_stop(dev);
+ 		was_running = 1;
+ 	}
+ 
+ 	priv->rx_ring_size = ering->rx_pending;
+ 	priv->tx_ring_size = ering->tx_pending;
+ 
+ 	if (was_running) {
+ 		int err;
+ 
+ 		err = bcm_enetsw_open(dev);
+ 		if (err)
+ 			dev_close(dev);
+ 	}
+ 	return 0;
+ }
+ 
+ static struct ethtool_ops bcm_enetsw_ethtool_ops = {
+ 	.get_strings		= bcm_enetsw_get_strings,
+ 	.get_sset_count		= bcm_enetsw_get_sset_count,
+ 	.get_ethtool_stats      = bcm_enetsw_get_ethtool_stats,
+ 	.get_drvinfo		= bcm_enetsw_get_drvinfo,
+ 	.get_ringparam		= bcm_enetsw_get_ringparam,
+ 	.set_ringparam		= bcm_enetsw_set_ringparam,
+ };
+ 
+ /* allocate netdevice, request register memory and register device. */
+ static int bcm_enetsw_probe(struct platform_device *pdev)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	struct net_device *dev;
+ 	struct bcm63xx_enetsw_platform_data *pd;
+ 	struct resource *res_mem;
+ 	int ret, irq_rx, irq_tx;
+ 
+ 	/* stop if shared driver failed, assume driver->probe will be
+ 	 * called in the same order we register devices (correct ?)
+ 	 */
+ 	if (!bcm_enet_shared_base[0])
+ 		return -ENODEV;
+ 
+ 	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	irq_rx = platform_get_irq(pdev, 0);
+ 	irq_tx = platform_get_irq(pdev, 1);
+ 	if (!res_mem || irq_rx < 0)
+ 		return -ENODEV;
+ 
+ 	ret = 0;
+ 	dev = alloc_etherdev(sizeof(*priv));
+ 	if (!dev)
+ 		return -ENOMEM;
+ 	priv = netdev_priv(dev);
+ 	memset(priv, 0, sizeof(*priv));
+ 
+ 	/* initialize default and fetch platform data */
+ 	priv->enet_is_sw = true;
+ 	priv->irq_rx = irq_rx;
+ 	priv->irq_tx = irq_tx;
+ 	priv->rx_ring_size = BCMENET_DEF_RX_DESC;
+ 	priv->tx_ring_size = BCMENET_DEF_TX_DESC;
+ 	priv->dma_maxburst = BCMENETSW_DMA_MAXBURST;
+ 
+ 	pd = dev_get_platdata(&pdev->dev);
+ 	if (pd) {
+ 		memcpy(dev->dev_addr, pd->mac_addr, ETH_ALEN);
+ 		memcpy(priv->used_ports, pd->used_ports,
+ 		       sizeof(pd->used_ports));
+ 		priv->num_ports = pd->num_ports;
+ 		priv->dma_has_sram = pd->dma_has_sram;
+ 		priv->dma_chan_en_mask = pd->dma_chan_en_mask;
+ 		priv->dma_chan_int_mask = pd->dma_chan_int_mask;
+ 		priv->dma_chan_width = pd->dma_chan_width;
+ 	}
+ 
+ 	ret = compute_hw_mtu(priv, dev->mtu);
+ 	if (ret)
+ 		goto out;
+ 
+ 	if (!request_mem_region(res_mem->start, resource_size(res_mem),
+ 				"bcm63xx_enetsw")) {
+ 		ret = -EBUSY;
+ 		goto out;
+ 	}
+ 
+ 	priv->base = ioremap(res_mem->start, resource_size(res_mem));
+ 	if (priv->base == NULL) {
+ 		ret = -ENOMEM;
+ 		goto out_release_mem;
+ 	}
+ 
+ 	priv->mac_clk = clk_get(&pdev->dev, "enetsw");
+ 	if (IS_ERR(priv->mac_clk)) {
+ 		ret = PTR_ERR(priv->mac_clk);
+ 		goto out_unmap;
+ 	}
+ 	clk_enable(priv->mac_clk);
+ 
+ 	priv->rx_chan = 0;
+ 	priv->tx_chan = 1;
+ 	spin_lock_init(&priv->rx_lock);
+ 
+ 	/* init rx timeout (used for oom) */
+ 	init_timer(&priv->rx_timeout);
+ 	priv->rx_timeout.function = bcm_enet_refill_rx_timer;
+ 	priv->rx_timeout.data = (unsigned long)dev;
+ 
+ 	/* register netdevice */
+ 	dev->netdev_ops = &bcm_enetsw_ops;
+ 	netif_napi_add(dev, &priv->napi, bcm_enet_poll, 16);
+ 	dev->ethtool_ops = &bcm_enetsw_ethtool_ops;
+ 	SET_NETDEV_DEV(dev, &pdev->dev);
+ 
+ 	spin_lock_init(&priv->enetsw_mdio_lock);
+ 
+ 	ret = register_netdev(dev);
+ 	if (ret)
+ 		goto out_put_clk;
+ 
+ 	netif_carrier_off(dev);
+ 	platform_set_drvdata(pdev, dev);
+ 	priv->pdev = pdev;
+ 	priv->net_dev = dev;
+ 
+ 	return 0;
+ 
+ out_put_clk:
+ 	clk_put(priv->mac_clk);
+ 
+ out_unmap:
+ 	iounmap(priv->base);
+ 
+ out_release_mem:
+ 	release_mem_region(res_mem->start, resource_size(res_mem));
+ out:
+ 	free_netdev(dev);
+ 	return ret;
+ }
+ 
+ 
+ /* exit func, stops hardware and unregisters netdevice */
+ static int bcm_enetsw_remove(struct platform_device *pdev)
+ {
+ 	struct bcm_enet_priv *priv;
+ 	struct net_device *dev;
+ 	struct resource *res;
+ 
+ 	/* stop netdevice */
+ 	dev = platform_get_drvdata(pdev);
+ 	priv = netdev_priv(dev);
+ 	unregister_netdev(dev);
+ 
+ 	/* release device resources */
+ 	iounmap(priv->base);
+ 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ 	release_mem_region(res->start, resource_size(res));
+ 
+ 	free_netdev(dev);
+ 	return 0;
+ }
+ 
+ struct platform_driver bcm63xx_enetsw_driver = {
+ 	.probe	= bcm_enetsw_probe,
+ 	.remove	= bcm_enetsw_remove,
+ 	.driver	= {
+ 		.name	= "bcm63xx_enetsw",
+ 		.owner  = THIS_MODULE,
+ 	},
+ };
+ 
+ /* reserve & remap memory space shared between all macs */
++>>>>>>> 7ad24ea4bf62 (net: get rid of SET_ETHTOOL_OPS)
  static int bcm_enet_shared_probe(struct platform_device *pdev)
  {
  	struct resource *res;
diff --cc drivers/net/ethernet/renesas/sh_eth.c
index e29fe8dbd226,967314cade95..000000000000
--- a/drivers/net/ethernet/renesas/sh_eth.c
+++ b/drivers/net/ethernet/renesas/sh_eth.c
@@@ -2737,8 -2839,11 +2737,16 @@@ static int sh_eth_drv_probe(struct plat
  	sh_eth_set_default_cpu_data(mdp->cd);
  
  	/* set function */
++<<<<<<< HEAD
 +	ndev->netdev_ops = &sh_eth_netdev_ops;
 +	SET_ETHTOOL_OPS(ndev, &sh_eth_ethtool_ops);
++=======
+ 	if (mdp->cd->tsu)
+ 		ndev->netdev_ops = &sh_eth_netdev_ops_tsu;
+ 	else
+ 		ndev->netdev_ops = &sh_eth_netdev_ops;
+ 	ndev->ethtool_ops = &sh_eth_ethtool_ops;
++>>>>>>> 7ad24ea4bf62 (net: get rid of SET_ETHTOOL_OPS)
  	ndev->watchdog_timeo = TX_TIMEOUT;
  
  	/* debug message level */
diff --cc drivers/net/rionet.c
index f433b594388e,dac7a0d9bb46..000000000000
--- a/drivers/net/rionet.c
+++ b/drivers/net/rionet.c
@@@ -478,7 -493,8 +478,12 @@@ static int rionet_setup_netdev(struct r
  	ndev->netdev_ops = &rionet_netdev_ops;
  	ndev->mtu = RIO_MAX_MSG_SIZE - 14;
  	ndev->features = NETIF_F_LLTX;
++<<<<<<< HEAD
 +	SET_ETHTOOL_OPS(ndev, &rionet_ethtool_ops);
++=======
+ 	SET_NETDEV_DEV(ndev, &mport->dev);
+ 	ndev->ethtool_ops = &rionet_ethtool_ops;
++>>>>>>> 7ad24ea4bf62 (net: get rid of SET_ETHTOOL_OPS)
  
  	spin_lock_init(&rnet->lock);
  	spin_lock_init(&rnet->tx_lock);
diff --cc drivers/net/usb/r8152.c
index 14e519888631,9f91c7aba4b0..000000000000
--- a/drivers/net/usb/r8152.c
+++ b/drivers/net/usb/r8152.c
@@@ -1644,16 -3430,30 +1644,29 @@@ static int rtl8152_probe(struct usb_int
  	tp = netdev_priv(netdev);
  	tp->msg_enable = 0x7FFF;
  
 -	tp->udev = udev;
 -	tp->netdev = netdev;
 -	tp->intf = intf;
 -
 -	ret = rtl_ops_init(tp, id);
 -	if (ret)
 -		goto out;
 -
 -	tasklet_init(&tp->tl, bottom_half, (unsigned long)tp);
 +	tasklet_init(&tp->tl, rx_fixup, (unsigned long)tp);
  	INIT_DELAYED_WORK(&tp->schedule, rtl_work_func_t);
  
 +	tp->udev = udev;
 +	tp->netdev = netdev;
  	netdev->netdev_ops = &rtl8152_netdev_ops;
  	netdev->watchdog_timeo = RTL8152_TX_TIMEOUT;
++<<<<<<< HEAD
 +	netdev->features &= ~NETIF_F_IP_CSUM;
 +	SET_ETHTOOL_OPS(netdev, &ops);
 +	tp->speed = 0;
++=======
+ 
+ 	netdev->features |= NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG |
+ 			    NETIF_F_TSO | NETIF_F_FRAGLIST | NETIF_F_IPV6_CSUM |
+ 			    NETIF_F_TSO6;
+ 	netdev->hw_features = NETIF_F_RXCSUM | NETIF_F_IP_CSUM | NETIF_F_SG |
+ 			      NETIF_F_TSO | NETIF_F_FRAGLIST |
+ 			      NETIF_F_IPV6_CSUM | NETIF_F_TSO6;
+ 
+ 	netdev->ethtool_ops = &ops;
+ 	netif_set_gso_max_size(netdev, RTL_LIMITED_TSO_SIZE);
++>>>>>>> 7ad24ea4bf62 (net: get rid of SET_ETHTOOL_OPS)
  
  	tp->mii.dev = netdev;
  	tp->mii.mdio_read = read_mii_word;
diff --cc drivers/net/xen-netback/interface.c
index 540a796593a3,a7557331699f..000000000000
--- a/drivers/net/xen-netback/interface.c
+++ b/drivers/net/xen-netback/interface.c
@@@ -277,10 -379,14 +277,18 @@@ struct xenvif *xenvif_alloc(struct devi
  	init_timer(&vif->credit_timeout);
  	vif->credit_window_start = get_jiffies_64();
  
 -	init_timer(&vif->wake_queue);
 -
  	dev->netdev_ops	= &xenvif_netdev_ops;
++<<<<<<< HEAD
 +	dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO;
 +	dev->features = dev->hw_features;
 +	SET_ETHTOOL_OPS(dev, &xenvif_ethtool_ops);
++=======
+ 	dev->hw_features = NETIF_F_SG |
+ 		NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+ 		NETIF_F_TSO | NETIF_F_TSO6;
+ 	dev->features = dev->hw_features | NETIF_F_RXCSUM;
+ 	dev->ethtool_ops = &xenvif_ethtool_ops;
++>>>>>>> 7ad24ea4bf62 (net: get rid of SET_ETHTOOL_OPS)
  
  	dev->tx_queue_len = XENVIF_QUEUE_LENGTH;
  
diff --cc drivers/usb/gadget/u_ether.c
index 4b76124ce96b,ce8e28146162..000000000000
--- a/drivers/usb/gadget/u_ether.c
+++ b/drivers/usb/gadget/u_ether.c
@@@ -815,6 -818,186 +815,189 @@@ struct eth_dev *gether_setup_name(struc
  
  	return dev;
  }
++<<<<<<< HEAD
++=======
+ EXPORT_SYMBOL(gether_setup_name);
+ 
+ struct net_device *gether_setup_name_default(const char *netname)
+ {
+ 	struct net_device	*net;
+ 	struct eth_dev		*dev;
+ 
+ 	net = alloc_etherdev(sizeof(*dev));
+ 	if (!net)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	dev = netdev_priv(net);
+ 	spin_lock_init(&dev->lock);
+ 	spin_lock_init(&dev->req_lock);
+ 	INIT_WORK(&dev->work, eth_work);
+ 	INIT_LIST_HEAD(&dev->tx_reqs);
+ 	INIT_LIST_HEAD(&dev->rx_reqs);
+ 
+ 	skb_queue_head_init(&dev->rx_frames);
+ 
+ 	/* network device setup */
+ 	dev->net = net;
+ 	dev->qmult = QMULT_DEFAULT;
+ 	snprintf(net->name, sizeof(net->name), "%s%%d", netname);
+ 
+ 	eth_random_addr(dev->dev_mac);
+ 	pr_warn("using random %s ethernet address\n", "self");
+ 	eth_random_addr(dev->host_mac);
+ 	pr_warn("using random %s ethernet address\n", "host");
+ 
+ 	net->netdev_ops = &eth_netdev_ops;
+ 
+ 	net->ethtool_ops = &ops;
+ 	SET_NETDEV_DEVTYPE(net, &gadget_type);
+ 
+ 	return net;
+ }
+ EXPORT_SYMBOL(gether_setup_name_default);
+ 
+ int gether_register_netdev(struct net_device *net)
+ {
+ 	struct eth_dev *dev;
+ 	struct usb_gadget *g;
+ 	struct sockaddr sa;
+ 	int status;
+ 
+ 	if (!net->dev.parent)
+ 		return -EINVAL;
+ 	dev = netdev_priv(net);
+ 	g = dev->gadget;
+ 	status = register_netdev(net);
+ 	if (status < 0) {
+ 		dev_dbg(&g->dev, "register_netdev failed, %d\n", status);
+ 		return status;
+ 	} else {
+ 		INFO(dev, "HOST MAC %pM\n", dev->host_mac);
+ 
+ 		/* two kinds of host-initiated state changes:
+ 		 *  - iff DATA transfer is active, carrier is "on"
+ 		 *  - tx queueing enabled if open *and* carrier is "on"
+ 		 */
+ 		netif_carrier_off(net);
+ 	}
+ 	sa.sa_family = net->type;
+ 	memcpy(sa.sa_data, dev->dev_mac, ETH_ALEN);
+ 	rtnl_lock();
+ 	status = dev_set_mac_address(net, &sa);
+ 	rtnl_unlock();
+ 	if (status)
+ 		pr_warn("cannot set self ethernet address: %d\n", status);
+ 	else
+ 		INFO(dev, "MAC %pM\n", dev->dev_mac);
+ 
+ 	return status;
+ }
+ EXPORT_SYMBOL(gether_register_netdev);
+ 
+ void gether_set_gadget(struct net_device *net, struct usb_gadget *g)
+ {
+ 	struct eth_dev *dev;
+ 
+ 	dev = netdev_priv(net);
+ 	dev->gadget = g;
+ 	SET_NETDEV_DEV(net, &g->dev);
+ }
+ EXPORT_SYMBOL(gether_set_gadget);
+ 
+ int gether_set_dev_addr(struct net_device *net, const char *dev_addr)
+ {
+ 	struct eth_dev *dev;
+ 	u8 new_addr[ETH_ALEN];
+ 
+ 	dev = netdev_priv(net);
+ 	if (get_ether_addr(dev_addr, new_addr))
+ 		return -EINVAL;
+ 	memcpy(dev->dev_mac, new_addr, ETH_ALEN);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(gether_set_dev_addr);
+ 
+ int gether_get_dev_addr(struct net_device *net, char *dev_addr, int len)
+ {
+ 	struct eth_dev *dev;
+ 
+ 	dev = netdev_priv(net);
+ 	return get_ether_addr_str(dev->dev_mac, dev_addr, len);
+ }
+ EXPORT_SYMBOL(gether_get_dev_addr);
+ 
+ int gether_set_host_addr(struct net_device *net, const char *host_addr)
+ {
+ 	struct eth_dev *dev;
+ 	u8 new_addr[ETH_ALEN];
+ 
+ 	dev = netdev_priv(net);
+ 	if (get_ether_addr(host_addr, new_addr))
+ 		return -EINVAL;
+ 	memcpy(dev->host_mac, new_addr, ETH_ALEN);
+ 	return 0;
+ }
+ EXPORT_SYMBOL(gether_set_host_addr);
+ 
+ int gether_get_host_addr(struct net_device *net, char *host_addr, int len)
+ {
+ 	struct eth_dev *dev;
+ 
+ 	dev = netdev_priv(net);
+ 	return get_ether_addr_str(dev->host_mac, host_addr, len);
+ }
+ EXPORT_SYMBOL(gether_get_host_addr);
+ 
+ int gether_get_host_addr_cdc(struct net_device *net, char *host_addr, int len)
+ {
+ 	struct eth_dev *dev;
+ 
+ 	if (len < 13)
+ 		return -EINVAL;
+ 
+ 	dev = netdev_priv(net);
+ 	snprintf(host_addr, len, "%pm", dev->host_mac);
+ 
+ 	return strlen(host_addr);
+ }
+ EXPORT_SYMBOL(gether_get_host_addr_cdc);
+ 
+ void gether_get_host_addr_u8(struct net_device *net, u8 host_mac[ETH_ALEN])
+ {
+ 	struct eth_dev *dev;
+ 
+ 	dev = netdev_priv(net);
+ 	memcpy(host_mac, dev->host_mac, ETH_ALEN);
+ }
+ EXPORT_SYMBOL(gether_get_host_addr_u8);
+ 
+ void gether_set_qmult(struct net_device *net, unsigned qmult)
+ {
+ 	struct eth_dev *dev;
+ 
+ 	dev = netdev_priv(net);
+ 	dev->qmult = qmult;
+ }
+ EXPORT_SYMBOL(gether_set_qmult);
+ 
+ unsigned gether_get_qmult(struct net_device *net)
+ {
+ 	struct eth_dev *dev;
+ 
+ 	dev = netdev_priv(net);
+ 	return dev->qmult;
+ }
+ EXPORT_SYMBOL(gether_get_qmult);
+ 
+ int gether_get_ifname(struct net_device *net, char *name, int len)
+ {
+ 	rtnl_lock();
+ 	strlcpy(name, netdev_name(net), len);
+ 	rtnl_unlock();
+ 	return strlen(name);
+ }
+ EXPORT_SYMBOL(gether_get_ifname);
++>>>>>>> 7ad24ea4bf62 (net: get rid of SET_ETHTOOL_OPS)
  
  /**
   * gether_cleanup - remove Ethernet-over-USB device
diff --cc net/dsa/slave.c
index 6ebd8fbd9285,64c5af0a10dd..000000000000
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@@ -346,8 -346,8 +346,13 @@@ dsa_slave_create(struct dsa_switch *ds
  		return slave_dev;
  
  	slave_dev->features = master->vlan_features;
++<<<<<<< HEAD
 +	SET_ETHTOOL_OPS(slave_dev, &dsa_slave_ethtool_ops);
 +	memcpy(slave_dev->dev_addr, master->dev_addr, ETH_ALEN);
++=======
+ 	slave_dev->ethtool_ops = &dsa_slave_ethtool_ops;
+ 	eth_hw_addr_inherit(slave_dev, master);
++>>>>>>> 7ad24ea4bf62 (net: get rid of SET_ETHTOOL_OPS)
  	slave_dev->tx_queue_len = 0;
  
  	switch (ds->dst->tag_protocol) {
* Unmerged path drivers/net/ethernet/altera/altera_tse_ethtool.c
* Unmerged path drivers/net/ethernet/broadcom/bcmsysport.c
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmgenet.c
* Unmerged path drivers/net/ethernet/samsung/sxgbe/sxgbe_ethtool.c
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.c b/drivers/infiniband/ulp/ipoib/ipoib_ethtool.c
index c4b3940845e6..078cadd6c797 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_ethtool.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_ethtool.c
@@ -105,5 +105,5 @@ static const struct ethtool_ops ipoib_ethtool_ops = {
 
 void ipoib_set_ethtool_ops(struct net_device *dev)
 {
-	SET_ETHTOOL_OPS(dev, &ipoib_ethtool_ops);
+	dev->ethtool_ops = &ipoib_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/3com/3c509.c b/drivers/net/ethernet/3com/3c509.c
index adb4bf5eb4b4..7fba8e236e9f 100644
--- a/drivers/net/ethernet/3com/3c509.c
+++ b/drivers/net/ethernet/3com/3c509.c
@@ -535,7 +535,7 @@ static int el3_common_init(struct net_device *dev)
 	/* The EL3-specific entries in the device structure. */
 	dev->netdev_ops = &netdev_ops;
 	dev->watchdog_timeo = TX_TIMEOUT;
-	SET_ETHTOOL_OPS(dev, &ethtool_ops);
+	dev->ethtool_ops = &ethtool_ops;
 
 	err = register_netdev(dev);
 	if (err) {
* Unmerged path drivers/net/ethernet/3com/3c589_cs.c
diff --git a/drivers/net/ethernet/3com/typhoon.c b/drivers/net/ethernet/3com/typhoon.c
index 144942f6372b..a606f6671baa 100644
--- a/drivers/net/ethernet/3com/typhoon.c
+++ b/drivers/net/ethernet/3com/typhoon.c
@@ -2435,7 +2435,7 @@ typhoon_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	netif_napi_add(dev, &tp->napi, typhoon_poll, 16);
 	dev->watchdog_timeo	= TX_TIMEOUT;
 
-	SET_ETHTOOL_OPS(dev, &typhoon_ethtool_ops);
+	dev->ethtool_ops = &typhoon_ethtool_ops;
 
 	/* We can handle scatter gather, up to 16 entries, and
 	 * we can do IP checksumming (only version 4, doh...)
diff --git a/drivers/net/ethernet/adaptec/starfire.c b/drivers/net/ethernet/adaptec/starfire.c
index 8b04bfc20cfb..b65889d86e89 100644
--- a/drivers/net/ethernet/adaptec/starfire.c
+++ b/drivers/net/ethernet/adaptec/starfire.c
@@ -784,7 +784,7 @@ static int starfire_init_one(struct pci_dev *pdev,
 
 	dev->netdev_ops = &netdev_ops;
 	dev->watchdog_timeo = TX_TIMEOUT;
-	SET_ETHTOOL_OPS(dev, &ethtool_ops);
+	dev->ethtool_ops = &ethtool_ops;
 
 	netif_napi_add(dev, &np->napi, netdev_poll, max_interrupt_work);
 
diff --git a/drivers/net/ethernet/alteon/acenic.c b/drivers/net/ethernet/alteon/acenic.c
index b7894f8af9d1..962a9d949f9e 100644
--- a/drivers/net/ethernet/alteon/acenic.c
+++ b/drivers/net/ethernet/alteon/acenic.c
@@ -477,7 +477,7 @@ static int acenic_probe_one(struct pci_dev *pdev,
 	dev->watchdog_timeo = 5*HZ;
 
 	dev->netdev_ops = &ace_netdev_ops;
-	SET_ETHTOOL_OPS(dev, &ace_ethtool_ops);
+	dev->ethtool_ops = &ace_ethtool_ops;
 
 	/* we only display this string ONCE */
 	if (!boards_found)
* Unmerged path drivers/net/ethernet/altera/altera_tse_ethtool.c
diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c
index 8e6b665a6726..339392235b62 100644
--- a/drivers/net/ethernet/amd/amd8111e.c
+++ b/drivers/net/ethernet/amd/amd8111e.c
@@ -1901,7 +1901,7 @@ static int amd8111e_probe_one(struct pci_dev *pdev,
 
 	/* Initialize driver entry points */
 	dev->netdev_ops = &amd8111e_netdev_ops;
-	SET_ETHTOOL_OPS(dev, &ops);
+	dev->ethtool_ops = &ops;
 	dev->irq =pdev->irq;
 	dev->watchdog_timeo = AMD8111E_TX_TIMEOUT;
 	netif_napi_add(dev, &lp->napi, amd8111e_rx_poll, 32);
diff --git a/drivers/net/ethernet/amd/au1000_eth.c b/drivers/net/ethernet/amd/au1000_eth.c
index 688aede742c7..911fd90fb17f 100644
--- a/drivers/net/ethernet/amd/au1000_eth.c
+++ b/drivers/net/ethernet/amd/au1000_eth.c
@@ -1231,7 +1231,7 @@ static int au1000_probe(struct platform_device *pdev)
 	dev->base_addr = base->start;
 	dev->irq = irq;
 	dev->netdev_ops = &au1000_netdev_ops;
-	SET_ETHTOOL_OPS(dev, &au1000_ethtool_ops);
+	dev->ethtool_ops = &au1000_ethtool_ops;
 	dev->watchdog_timeo = ETH_TX_TIMEOUT;
 
 	/*
diff --git a/drivers/net/ethernet/amd/nmclan_cs.c b/drivers/net/ethernet/amd/nmclan_cs.c
index d4ed89130c52..67e76a12208a 100644
--- a/drivers/net/ethernet/amd/nmclan_cs.c
+++ b/drivers/net/ethernet/amd/nmclan_cs.c
@@ -458,7 +458,7 @@ static int nmclan_probe(struct pcmcia_device *link)
     lp->tx_free_frames=AM2150_MAX_TX_FRAMES;
 
     dev->netdev_ops = &mace_netdev_ops;
-    SET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);
+    dev->ethtool_ops = &netdev_ethtool_ops;
     dev->watchdog_timeo = TX_TIMEOUT;
 
     return nmclan_config(link);
diff --git a/drivers/net/ethernet/atheros/alx/main.c b/drivers/net/ethernet/atheros/alx/main.c
index d30085c2b454..e002f97d029f 100644
--- a/drivers/net/ethernet/atheros/alx/main.c
+++ b/drivers/net/ethernet/atheros/alx/main.c
@@ -1320,7 +1320,7 @@ static int alx_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	}
 
 	netdev->netdev_ops = &alx_netdev_ops;
-	SET_ETHTOOL_OPS(netdev, &alx_ethtool_ops);
+	netdev->ethtool_ops = &alx_ethtool_ops;
 	netdev->irq = pdev->irq;
 	netdev->watchdog_timeo = ALX_WATCHDOG_TIME;
 
diff --git a/drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c b/drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c
index 859ea844ba0f..ecacaaeb2b92 100644
--- a/drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c
+++ b/drivers/net/ethernet/atheros/atl1c/atl1c_ethtool.c
@@ -305,5 +305,5 @@ static const struct ethtool_ops atl1c_ethtool_ops = {
 
 void atl1c_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &atl1c_ethtool_ops);
+	netdev->ethtool_ops = &atl1c_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/atheros/atl1e/atl1e_ethtool.c b/drivers/net/ethernet/atheros/atl1e/atl1e_ethtool.c
index 82b23861bf55..206e9b7be431 100644
--- a/drivers/net/ethernet/atheros/atl1e/atl1e_ethtool.c
+++ b/drivers/net/ethernet/atheros/atl1e/atl1e_ethtool.c
@@ -388,5 +388,5 @@ static const struct ethtool_ops atl1e_ethtool_ops = {
 
 void atl1e_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &atl1e_ethtool_ops);
+	netdev->ethtool_ops = &atl1e_ethtool_ops;
 }
* Unmerged path drivers/net/ethernet/atheros/atlx/atl2.c
diff --git a/drivers/net/ethernet/broadcom/b44.c b/drivers/net/ethernet/broadcom/b44.c
index 9b017d9c58e9..180579364e24 100644
--- a/drivers/net/ethernet/broadcom/b44.c
+++ b/drivers/net/ethernet/broadcom/b44.c
@@ -2174,7 +2174,7 @@ static int b44_init_one(struct ssb_device *sdev,
 	netif_napi_add(dev, &bp->napi, b44_poll, 64);
 	dev->watchdog_timeo = B44_TX_TIMEOUT;
 	dev->irq = sdev->irq;
-	SET_ETHTOOL_OPS(dev, &b44_ethtool_ops);
+	dev->ethtool_ops = &b44_ethtool_ops;
 
 	err = ssb_bus_powerup(sdev->bus, 0);
 	if (err) {
* Unmerged path drivers/net/ethernet/broadcom/bcm63xx_enet.c
* Unmerged path drivers/net/ethernet/broadcom/bcmsysport.c
diff --git a/drivers/net/ethernet/broadcom/bgmac.c b/drivers/net/ethernet/broadcom/bgmac.c
index 1c6bc9678774..17dd4639e276 100644
--- a/drivers/net/ethernet/broadcom/bgmac.c
+++ b/drivers/net/ethernet/broadcom/bgmac.c
@@ -1409,7 +1409,7 @@ static int bgmac_probe(struct bcma_device *core)
 		return -ENOMEM;
 	net_dev->netdev_ops = &bgmac_netdev_ops;
 	net_dev->irq = core->irq;
-	SET_ETHTOOL_OPS(net_dev, &bgmac_ethtool_ops);
+	net_dev->ethtool_ops = &bgmac_ethtool_ops;
 	bgmac = netdev_priv(net_dev);
 	bgmac->net_dev = net_dev;
 	bgmac->core = core;
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c
index e7153bcb18a1..13fb12cac7d6 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_ethtool.c
@@ -3507,8 +3507,6 @@ static const struct ethtool_ops bnx2x_vf_ethtool_ops = {
 
 void bnx2x_set_ethtool_ops(struct bnx2x *bp, struct net_device *netdev)
 {
-	if (IS_PF(bp))
-		SET_ETHTOOL_OPS(netdev, &bnx2x_ethtool_ops);
-	else /* vf */
-		SET_ETHTOOL_OPS(netdev, &bnx2x_vf_ethtool_ops);
+	netdev->ethtool_ops = (IS_PF(bp)) ?
+		&bnx2x_ethtool_ops : &bnx2x_vf_ethtool_ops;
 }
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmgenet.c
diff --git a/drivers/net/ethernet/brocade/bna/bnad_ethtool.c b/drivers/net/ethernet/brocade/bna/bnad_ethtool.c
index b4083008c697..0b71f4dc12d0 100644
--- a/drivers/net/ethernet/brocade/bna/bnad_ethtool.c
+++ b/drivers/net/ethernet/brocade/bna/bnad_ethtool.c
@@ -1135,5 +1135,5 @@ static const struct ethtool_ops bnad_ethtool_ops = {
 void
 bnad_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &bnad_ethtool_ops);
+	netdev->ethtool_ops = &bnad_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/calxeda/xgmac.c b/drivers/net/ethernet/calxeda/xgmac.c
index 4a1f2fa812ab..079b13f5b93f 100644
--- a/drivers/net/ethernet/calxeda/xgmac.c
+++ b/drivers/net/ethernet/calxeda/xgmac.c
@@ -1706,7 +1706,7 @@ static int xgmac_probe(struct platform_device *pdev)
 	platform_set_drvdata(pdev, ndev);
 	ether_setup(ndev);
 	ndev->netdev_ops = &xgmac_netdev_ops;
-	SET_ETHTOOL_OPS(ndev, &xgmac_ethtool_ops);
+	ndev->ethtool_ops = &xgmac_ethtool_ops;
 	spin_lock_init(&priv->stats_lock);
 
 	priv->device = &pdev->dev;
diff --git a/drivers/net/ethernet/chelsio/cxgb/cxgb2.c b/drivers/net/ethernet/chelsio/cxgb/cxgb2.c
index 9624cfe7df57..f5fcd8a02eea 100644
--- a/drivers/net/ethernet/chelsio/cxgb/cxgb2.c
+++ b/drivers/net/ethernet/chelsio/cxgb/cxgb2.c
@@ -1102,7 +1102,7 @@ static int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 		netif_napi_add(netdev, &adapter->napi, t1_poll, 64);
 
-		SET_ETHTOOL_OPS(netdev, &t1_ethtool_ops);
+		netdev->ethtool_ops = &t1_ethtool_ops;
 	}
 
 	if (t1_init_sw_modules(adapter, bi) < 0) {
diff --git a/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c b/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c
index 45d77334d7d9..1ebb9d60c089 100644
--- a/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb3/cxgb3_main.c
@@ -3299,7 +3299,7 @@ static int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 			netdev->features |= NETIF_F_HIGHDMA;
 
 		netdev->netdev_ops = &cxgb_netdev_ops;
-		SET_ETHTOOL_OPS(netdev, &cxgb_ethtool_ops);
+		netdev->ethtool_ops = &cxgb_ethtool_ops;
 	}
 
 	pci_set_drvdata(pdev, adapter);
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
index b254c730b56f..8c78fed206da 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c
@@ -6249,7 +6249,7 @@ static int init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 		netdev->priv_flags |= IFF_UNICAST_FLT;
 
 		netdev->netdev_ops = &cxgb4_netdev_ops;
-		SET_ETHTOOL_OPS(netdev, &cxgb_ethtool_ops);
+		netdev->ethtool_ops = &cxgb_ethtool_ops;
 	}
 
 	pci_set_drvdata(pdev, adapter);
diff --git a/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c b/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
index 0899c0983594..7874ed88ed56 100644
--- a/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
+++ b/drivers/net/ethernet/chelsio/cxgb4vf/cxgb4vf_main.c
@@ -2667,7 +2667,7 @@ static int cxgb4vf_pci_probe(struct pci_dev *pdev,
 		netdev->priv_flags |= IFF_UNICAST_FLT;
 
 		netdev->netdev_ops = &cxgb4vf_netdev_ops;
-		SET_ETHTOOL_OPS(netdev, &cxgb4vf_ethtool_ops);
+		netdev->ethtool_ops = &cxgb4vf_ethtool_ops;
 
 		/*
 		 * Initialize the hardware/software state for the port.
diff --git a/drivers/net/ethernet/cisco/enic/enic_ethtool.c b/drivers/net/ethernet/cisco/enic/enic_ethtool.c
index 6a5d7b51a23a..11db603d7dbc 100644
--- a/drivers/net/ethernet/cisco/enic/enic_ethtool.c
+++ b/drivers/net/ethernet/cisco/enic/enic_ethtool.c
@@ -297,5 +297,5 @@ static const struct ethtool_ops enic_ethtool_ops = {
 
 void enic_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &enic_ethtool_ops);
+	netdev->ethtool_ops = &enic_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/dec/tulip/tulip_core.c b/drivers/net/ethernet/dec/tulip/tulip_core.c
index 1e9443d9fb57..97b4a65c7f2c 100644
--- a/drivers/net/ethernet/dec/tulip/tulip_core.c
+++ b/drivers/net/ethernet/dec/tulip/tulip_core.c
@@ -1707,7 +1707,7 @@ static int tulip_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 #ifdef CONFIG_TULIP_NAPI
 	netif_napi_add(dev, &tp->napi, tulip_poll, 16);
 #endif
-	SET_ETHTOOL_OPS(dev, &ops);
+	dev->ethtool_ops = &ops;
 
 	if (register_netdev(dev))
 		goto err_out_free_ring;
diff --git a/drivers/net/ethernet/dlink/dl2k.c b/drivers/net/ethernet/dlink/dl2k.c
index afa8e3af2c4d..60a5c465b93b 100644
--- a/drivers/net/ethernet/dlink/dl2k.c
+++ b/drivers/net/ethernet/dlink/dl2k.c
@@ -227,7 +227,7 @@ rio_probe1 (struct pci_dev *pdev, const struct pci_device_id *ent)
 	}
 	dev->netdev_ops = &netdev_ops;
 	dev->watchdog_timeo = TX_TIMEOUT;
-	SET_ETHTOOL_OPS(dev, &ethtool_ops);
+	dev->ethtool_ops = &ethtool_ops;
 #if 0
 	dev->features = NETIF_F_IP_CSUM;
 #endif
diff --git a/drivers/net/ethernet/dlink/sundance.c b/drivers/net/ethernet/dlink/sundance.c
index 50d9c6315930..04cd44e1eae3 100644
--- a/drivers/net/ethernet/dlink/sundance.c
+++ b/drivers/net/ethernet/dlink/sundance.c
@@ -563,7 +563,7 @@ static int sundance_probe1(struct pci_dev *pdev,
 
 	/* The chip-specific entries in the device structure. */
 	dev->netdev_ops = &netdev_ops;
-	SET_ETHTOOL_OPS(dev, &ethtool_ops);
+	dev->ethtool_ops = &ethtool_ops;
 	dev->watchdog_timeo = TX_TIMEOUT;
 
 	pci_set_drvdata(pdev, dev);
diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c
index 9923bf6b69c7..126f8e428bcc 100644
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@ -4370,7 +4370,7 @@ static void be_netdev_init(struct net_device *netdev)
 
 	netdev->netdev_ops = &be_netdev_ops;
 
-	SET_ETHTOOL_OPS(netdev, &be_ethtool_ops);
+	netdev->ethtool_ops = &be_ethtool_ops;
 }
 
 static void be_unmap_pci_bars(struct be_adapter *adapter)
diff --git a/drivers/net/ethernet/faraday/ftgmac100.c b/drivers/net/ethernet/faraday/ftgmac100.c
index 21b85fb7d05f..748877d2dfcc 100644
--- a/drivers/net/ethernet/faraday/ftgmac100.c
+++ b/drivers/net/ethernet/faraday/ftgmac100.c
@@ -1217,7 +1217,7 @@ static int ftgmac100_probe(struct platform_device *pdev)
 
 	SET_NETDEV_DEV(netdev, &pdev->dev);
 
-	SET_ETHTOOL_OPS(netdev, &ftgmac100_ethtool_ops);
+	netdev->ethtool_ops = &ftgmac100_ethtool_ops;
 	netdev->netdev_ops = &ftgmac100_netdev_ops;
 	netdev->features = NETIF_F_IP_CSUM | NETIF_F_GRO;
 
diff --git a/drivers/net/ethernet/faraday/ftmac100.c b/drivers/net/ethernet/faraday/ftmac100.c
index a6eda8d83138..190a169d254d 100644
--- a/drivers/net/ethernet/faraday/ftmac100.c
+++ b/drivers/net/ethernet/faraday/ftmac100.c
@@ -1085,7 +1085,7 @@ static int ftmac100_probe(struct platform_device *pdev)
 	}
 
 	SET_NETDEV_DEV(netdev, &pdev->dev);
-	SET_ETHTOOL_OPS(netdev, &ftmac100_ethtool_ops);
+	netdev->ethtool_ops = &ftmac100_ethtool_ops;
 	netdev->netdev_ops = &ftmac100_netdev_ops;
 
 	platform_set_drvdata(pdev, netdev);
diff --git a/drivers/net/ethernet/freescale/ucc_geth_ethtool.c b/drivers/net/ethernet/freescale/ucc_geth_ethtool.c
index e79aaf9ae52a..04fe62877eb1 100644
--- a/drivers/net/ethernet/freescale/ucc_geth_ethtool.c
+++ b/drivers/net/ethernet/freescale/ucc_geth_ethtool.c
@@ -418,5 +418,5 @@ static const struct ethtool_ops uec_ethtool_ops = {
 
 void uec_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &uec_ethtool_ops);
+	netdev->ethtool_ops = &uec_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/fujitsu/fmvj18x_cs.c b/drivers/net/ethernet/fujitsu/fmvj18x_cs.c
index ef46b58cb4e9..0ebdc35a76b4 100644
--- a/drivers/net/ethernet/fujitsu/fmvj18x_cs.c
+++ b/drivers/net/ethernet/fujitsu/fmvj18x_cs.c
@@ -257,7 +257,7 @@ static int fmvj18x_probe(struct pcmcia_device *link)
     dev->netdev_ops = &fjn_netdev_ops;
     dev->watchdog_timeo = TX_TIMEOUT;
 
-    SET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);
+    dev->ethtool_ops = &netdev_ethtool_ops;
 
     return fmvj18x_config(link);
 } /* fmvj18x_attach */
diff --git a/drivers/net/ethernet/ibm/ehea/ehea_ethtool.c b/drivers/net/ethernet/ibm/ehea/ehea_ethtool.c
index 95837b99a464..6055e3eaf49c 100644
--- a/drivers/net/ethernet/ibm/ehea/ehea_ethtool.c
+++ b/drivers/net/ethernet/ibm/ehea/ehea_ethtool.c
@@ -278,5 +278,5 @@ static const struct ethtool_ops ehea_ethtool_ops = {
 
 void ehea_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &ehea_ethtool_ops);
+	netdev->ethtool_ops = &ehea_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/ibm/emac/core.c b/drivers/net/ethernet/ibm/emac/core.c
index d300a0c0eafc..4e255b9e2a92 100644
--- a/drivers/net/ethernet/ibm/emac/core.c
+++ b/drivers/net/ethernet/ibm/emac/core.c
@@ -2877,7 +2877,7 @@ static int emac_probe(struct platform_device *ofdev)
 		dev->commac.ops = &emac_commac_sg_ops;
 	} else
 		ndev->netdev_ops = &emac_netdev_ops;
-	SET_ETHTOOL_OPS(ndev, &emac_ethtool_ops);
+	ndev->ethtool_ops = &emac_ethtool_ops;
 
 	netif_carrier_off(ndev);
 
diff --git a/drivers/net/ethernet/icplus/ipg.c b/drivers/net/ethernet/icplus/ipg.c
index 068d78151658..4c5e1375c050 100644
--- a/drivers/net/ethernet/icplus/ipg.c
+++ b/drivers/net/ethernet/icplus/ipg.c
@@ -2246,7 +2246,7 @@ static int ipg_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	 */
 	dev->netdev_ops = &ipg_netdev_ops;
 	SET_NETDEV_DEV(dev, &pdev->dev);
-	SET_ETHTOOL_OPS(dev, &ipg_ethtool_ops);
+	dev->ethtool_ops = &ipg_ethtool_ops;
 
 	rc = pci_request_regions(pdev, DRV_NAME);
 	if (rc)
diff --git a/drivers/net/ethernet/intel/e100.c b/drivers/net/ethernet/intel/e100.c
index d2bea3f07c73..fa5428876ea2 100644
--- a/drivers/net/ethernet/intel/e100.c
+++ b/drivers/net/ethernet/intel/e100.c
@@ -2857,7 +2857,7 @@ static int e100_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	netdev->hw_features |= NETIF_F_RXALL;
 
 	netdev->netdev_ops = &e100_netdev_ops;
-	SET_ETHTOOL_OPS(netdev, &e100_ethtool_ops);
+	netdev->ethtool_ops = &e100_ethtool_ops;
 	netdev->watchdog_timeo = E100_WATCHDOG_PERIOD;
 	strncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1);
 
diff --git a/drivers/net/ethernet/intel/e1000/e1000_ethtool.c b/drivers/net/ethernet/intel/e1000/e1000_ethtool.c
index 82a967c95598..aafd6c14cc36 100644
--- a/drivers/net/ethernet/intel/e1000/e1000_ethtool.c
+++ b/drivers/net/ethernet/intel/e1000/e1000_ethtool.c
@@ -1905,5 +1905,5 @@ static const struct ethtool_ops e1000_ethtool_ops = {
 
 void e1000_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &e1000_ethtool_ops);
+	netdev->ethtool_ops = &e1000_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/intel/e1000e/ethtool.c b/drivers/net/ethernet/intel/e1000e/ethtool.c
index 77dfe960263b..3255b7ff0691 100644
--- a/drivers/net/ethernet/intel/e1000e/ethtool.c
+++ b/drivers/net/ethernet/intel/e1000e/ethtool.c
@@ -2313,5 +2313,5 @@ static const struct ethtool_ops e1000_ethtool_ops = {
 
 void e1000e_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &e1000_ethtool_ops);
+	netdev->ethtool_ops = &e1000_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
index cad97f2c2053..dd007fa79627 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@ -2158,5 +2158,5 @@ static const struct ethtool_ops i40e_ethtool_ops = {
 
 void i40e_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &i40e_ethtool_ops);
+	netdev->ethtool_ops = &i40e_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c b/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
index e83453bc2fa4..4a8e3fb75895 100644
--- a/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
+++ b/drivers/net/ethernet/intel/i40evf/i40evf_ethtool.c
@@ -699,5 +699,5 @@ static const struct ethtool_ops i40evf_ethtool_ops = {
  **/
 void i40evf_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &i40evf_ethtool_ops);
+	netdev->ethtool_ops = &i40evf_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/intel/igb/igb_ethtool.c b/drivers/net/ethernet/intel/igb/igb_ethtool.c
index e8a72afe4f1a..d8e4d9298fbc 100644
--- a/drivers/net/ethernet/intel/igb/igb_ethtool.c
+++ b/drivers/net/ethernet/intel/igb/igb_ethtool.c
@@ -2938,5 +2938,5 @@ static const struct ethtool_ops igb_ethtool_ops = {
 
 void igb_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &igb_ethtool_ops);
+	netdev->ethtool_ops = &igb_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/intel/igbvf/ethtool.c b/drivers/net/ethernet/intel/igbvf/ethtool.c
index 90eef07943f4..f58170bae18b 100644
--- a/drivers/net/ethernet/intel/igbvf/ethtool.c
+++ b/drivers/net/ethernet/intel/igbvf/ethtool.c
@@ -476,5 +476,5 @@ static const struct ethtool_ops igbvf_ethtool_ops = {
 
 void igbvf_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &igbvf_ethtool_ops);
+	netdev->ethtool_ops = &igbvf_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/intel/ixgb/ixgb_ethtool.c b/drivers/net/ethernet/intel/ixgb/ixgb_ethtool.c
index dbb7dd2f8e36..1da2d987d370 100644
--- a/drivers/net/ethernet/intel/ixgb/ixgb_ethtool.c
+++ b/drivers/net/ethernet/intel/ixgb/ixgb_ethtool.c
@@ -656,5 +656,5 @@ static const struct ethtool_ops ixgb_ethtool_ops = {
 
 void ixgb_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &ixgb_ethtool_ops);
+	netdev->ethtool_ops = &ixgb_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
index d0415fb94697..0b52a2d037b4 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
@@ -3004,5 +3004,5 @@ static const struct ethtool_ops ixgbe_ethtool_ops = {
 
 void ixgbe_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &ixgbe_ethtool_ops);
+	netdev->ethtool_ops = &ixgbe_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/intel/ixgbevf/ethtool.c b/drivers/net/ethernet/intel/ixgbevf/ethtool.c
index f18da0be3a72..a8c2f21d0134 100644
--- a/drivers/net/ethernet/intel/ixgbevf/ethtool.c
+++ b/drivers/net/ethernet/intel/ixgbevf/ethtool.c
@@ -785,5 +785,5 @@ static const struct ethtool_ops ixgbevf_ethtool_ops = {
 
 void ixgbevf_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &ixgbevf_ethtool_ops);
+	netdev->ethtool_ops = &ixgbevf_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/marvell/mv643xx_eth.c b/drivers/net/ethernet/marvell/mv643xx_eth.c
index 4be11ff516a0..f898b22ea2e4 100644
--- a/drivers/net/ethernet/marvell/mv643xx_eth.c
+++ b/drivers/net/ethernet/marvell/mv643xx_eth.c
@@ -2727,7 +2727,7 @@ static int mv643xx_eth_probe(struct platform_device *pdev)
 		phy_init(mp, pd->speed, pd->duplex);
 	}
 
-	SET_ETHTOOL_OPS(dev, &mv643xx_eth_ethtool_ops);
+	dev->ethtool_ops = &mv643xx_eth_ethtool_ops;
 
 	init_pscr(mp, pd->speed, pd->duplex);
 
diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index 4d66a5e6db80..dc6f771ae2a2 100644
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -2726,7 +2726,7 @@ static int mvneta_probe(struct platform_device *pdev)
 	dev->watchdog_timeo = 5 * HZ;
 	dev->netdev_ops = &mvneta_netdev_ops;
 
-	SET_ETHTOOL_OPS(dev, &mvneta_eth_tool_ops);
+	dev->ethtool_ops = &mvneta_eth_tool_ops;
 
 	pp = netdev_priv(dev);
 
diff --git a/drivers/net/ethernet/marvell/pxa168_eth.c b/drivers/net/ethernet/marvell/pxa168_eth.c
index 1c8af8ba08d9..50c67342c6e8 100644
--- a/drivers/net/ethernet/marvell/pxa168_eth.c
+++ b/drivers/net/ethernet/marvell/pxa168_eth.c
@@ -1510,7 +1510,7 @@ static int pxa168_eth_probe(struct platform_device *pdev)
 	dev->netdev_ops = &pxa168_eth_netdev_ops;
 	dev->watchdog_timeo = 2 * HZ;
 	dev->base_addr = 0;
-	SET_ETHTOOL_OPS(dev, &pxa168_ethtool_ops);
+	dev->ethtool_ops = &pxa168_ethtool_ops;
 
 	INIT_WORK(&pep->tx_timeout_task, pxa168_eth_tx_timeout_task);
 
diff --git a/drivers/net/ethernet/marvell/sky2.c b/drivers/net/ethernet/marvell/sky2.c
index d175bbd3ffd3..63b6031b88e0 100644
--- a/drivers/net/ethernet/marvell/sky2.c
+++ b/drivers/net/ethernet/marvell/sky2.c
@@ -4754,7 +4754,7 @@ static struct net_device *sky2_init_netdev(struct sky2_hw *hw, unsigned port,
 
 	SET_NETDEV_DEV(dev, &hw->pdev->dev);
 	dev->irq = hw->pdev->irq;
-	SET_ETHTOOL_OPS(dev, &sky2_ethtool_ops);
+	dev->ethtool_ops = &sky2_ethtool_ops;
 	dev->watchdog_timeo = TX_WATCHDOG;
 	dev->netdev_ops = &sky2_netdev_ops[port];
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 4965eb72dff5..c7e2bc10d502 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -2510,7 +2510,7 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	netif_set_real_num_tx_queues(dev, priv->tx_ring_num);
 	netif_set_real_num_rx_queues(dev, priv->rx_ring_num);
 
-	SET_ETHTOOL_OPS(dev, &mlx4_en_ethtool_ops);
+	dev->ethtool_ops = &mlx4_en_ethtool_ops;
 
 	/*
 	 * Set driver features
diff --git a/drivers/net/ethernet/micrel/ks8695net.c b/drivers/net/ethernet/micrel/ks8695net.c
index b6c60fdef4ff..5833ca58bc2e 100644
--- a/drivers/net/ethernet/micrel/ks8695net.c
+++ b/drivers/net/ethernet/micrel/ks8695net.c
@@ -1505,15 +1505,15 @@ ks8695_probe(struct platform_device *pdev)
 	if (ksp->phyiface_regs && ksp->link_irq == -1) {
 		ks8695_init_switch(ksp);
 		ksp->dtype = KS8695_DTYPE_LAN;
-		SET_ETHTOOL_OPS(ndev, &ks8695_ethtool_ops);
+		ndev->ethtool_ops = &ks8695_ethtool_ops;
 	} else if (ksp->phyiface_regs && ksp->link_irq != -1) {
 		ks8695_init_wan_phy(ksp);
 		ksp->dtype = KS8695_DTYPE_WAN;
-		SET_ETHTOOL_OPS(ndev, &ks8695_wan_ethtool_ops);
+		ndev->ethtool_ops = &ks8695_wan_ethtool_ops;
 	} else {
 		/* No initialisation since HPNA does not have a PHY */
 		ksp->dtype = KS8695_DTYPE_HPNA;
-		SET_ETHTOOL_OPS(ndev, &ks8695_ethtool_ops);
+		ndev->ethtool_ops = &ks8695_ethtool_ops;
 	}
 
 	/* And bring up the net_device with the net core */
diff --git a/drivers/net/ethernet/micrel/ks8851.c b/drivers/net/ethernet/micrel/ks8851.c
index 727b546a9eb8..c73d87d56cf6 100644
--- a/drivers/net/ethernet/micrel/ks8851.c
+++ b/drivers/net/ethernet/micrel/ks8851.c
@@ -1453,7 +1453,7 @@ static int ks8851_probe(struct spi_device *spi)
 
 	skb_queue_head_init(&ks->txq);
 
-	SET_ETHTOOL_OPS(ndev, &ks8851_ethtool_ops);
+	ndev->ethtool_ops = &ks8851_ethtool_ops;
 	SET_NETDEV_DEV(ndev, &spi->dev);
 
 	spi_set_drvdata(spi, ks);
diff --git a/drivers/net/ethernet/micrel/ksz884x.c b/drivers/net/ethernet/micrel/ksz884x.c
index 8ebc352bcbe6..26b87e4b5b95 100644
--- a/drivers/net/ethernet/micrel/ksz884x.c
+++ b/drivers/net/ethernet/micrel/ksz884x.c
@@ -7110,7 +7110,7 @@ static int pcidev_init(struct pci_dev *pdev, const struct pci_device_id *id)
 		}
 
 		dev->netdev_ops = &netdev_ops;
-		SET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);
+		dev->ethtool_ops = &netdev_ethtool_ops;
 		if (register_netdev(dev))
 			goto pcidev_init_reg_err;
 		port_set_power_saving(port, true);
diff --git a/drivers/net/ethernet/microchip/enc28j60.c b/drivers/net/ethernet/microchip/enc28j60.c
index c7b40aa21f22..b1b5f66b8b69 100644
--- a/drivers/net/ethernet/microchip/enc28j60.c
+++ b/drivers/net/ethernet/microchip/enc28j60.c
@@ -1593,7 +1593,7 @@ static int enc28j60_probe(struct spi_device *spi)
 	dev->irq = spi->irq;
 	dev->netdev_ops = &enc28j60_netdev_ops;
 	dev->watchdog_timeo = TX_TIMEOUT;
-	SET_ETHTOOL_OPS(dev, &enc28j60_ethtool_ops);
+	dev->ethtool_ops = &enc28j60_ethtool_ops;
 
 	enc28j60_lowpower(priv, true);
 
diff --git a/drivers/net/ethernet/myricom/myri10ge/myri10ge.c b/drivers/net/ethernet/myricom/myri10ge/myri10ge.c
index a85e1b55eb40..24c63d927bc7 100644
--- a/drivers/net/ethernet/myricom/myri10ge/myri10ge.c
+++ b/drivers/net/ethernet/myricom/myri10ge/myri10ge.c
@@ -4113,7 +4113,7 @@ static int myri10ge_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	setup_timer(&mgp->watchdog_timer, myri10ge_watchdog_timer,
 		    (unsigned long)mgp);
 
-	SET_ETHTOOL_OPS(netdev, &myri10ge_ethtool_ops);
+	netdev->ethtool_ops = &myri10ge_ethtool_ops;
 	INIT_WORK(&mgp->watchdog_work, myri10ge_watchdog);
 	status = register_netdev(netdev);
 	if (status != 0) {
diff --git a/drivers/net/ethernet/natsemi/natsemi.c b/drivers/net/ethernet/natsemi/natsemi.c
index 7a5e295588b0..5e4738043086 100644
--- a/drivers/net/ethernet/natsemi/natsemi.c
+++ b/drivers/net/ethernet/natsemi/natsemi.c
@@ -927,7 +927,7 @@ static int natsemi_probe1(struct pci_dev *pdev, const struct pci_device_id *ent)
 	dev->netdev_ops = &natsemi_netdev_ops;
 	dev->watchdog_timeo = TX_TIMEOUT;
 
-	SET_ETHTOOL_OPS(dev, &ethtool_ops);
+	dev->ethtool_ops = &ethtool_ops;
 
 	if (mtu)
 		dev->mtu = mtu;
diff --git a/drivers/net/ethernet/natsemi/ns83820.c b/drivers/net/ethernet/natsemi/ns83820.c
index d3b47003a575..d5c328e28c15 100644
--- a/drivers/net/ethernet/natsemi/ns83820.c
+++ b/drivers/net/ethernet/natsemi/ns83820.c
@@ -2031,7 +2031,7 @@ static int ns83820_init_one(struct pci_dev *pci_dev,
 		pci_dev->subsystem_vendor, pci_dev->subsystem_device);
 
 	ndev->netdev_ops = &netdev_ops;
-	SET_ETHTOOL_OPS(ndev, &ops);
+	ndev->ethtool_ops = &ops;
 	ndev->watchdog_timeo = 5 * HZ;
 	pci_set_drvdata(pci_dev, ndev);
 
diff --git a/drivers/net/ethernet/neterion/s2io.c b/drivers/net/ethernet/neterion/s2io.c
index 51b00941302c..60f0b8a91da2 100644
--- a/drivers/net/ethernet/neterion/s2io.c
+++ b/drivers/net/ethernet/neterion/s2io.c
@@ -7915,7 +7915,7 @@ s2io_init_nic(struct pci_dev *pdev, const struct pci_device_id *pre)
 
 	/*  Driver entry points */
 	dev->netdev_ops = &s2io_netdev_ops;
-	SET_ETHTOOL_OPS(dev, &netdev_ethtool_ops);
+	dev->ethtool_ops = &netdev_ethtool_ops;
 	dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM |
 		NETIF_F_TSO | NETIF_F_TSO6 |
 		NETIF_F_RXCSUM | NETIF_F_LRO;
diff --git a/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c b/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c
index f8f073880f84..ddcc81ad1ae1 100644
--- a/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c
+++ b/drivers/net/ethernet/neterion/vxge/vxge-ethtool.c
@@ -1128,5 +1128,5 @@ static const struct ethtool_ops vxge_ethtool_ops = {
 
 void vxge_initialize_ethtool_ops(struct net_device *ndev)
 {
-	SET_ETHTOOL_OPS(ndev, &vxge_ethtool_ops);
+	ndev->ethtool_ops = &vxge_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/nvidia/forcedeth.c b/drivers/net/ethernet/nvidia/forcedeth.c
index b003fe53c8e2..cafcf17cd44b 100644
--- a/drivers/net/ethernet/nvidia/forcedeth.c
+++ b/drivers/net/ethernet/nvidia/forcedeth.c
@@ -5755,7 +5755,7 @@ static int nv_probe(struct pci_dev *pci_dev, const struct pci_device_id *id)
 		dev->netdev_ops = &nv_netdev_ops_optimized;
 
 	netif_napi_add(dev, &np->napi, nv_napi_poll, RX_WORK_PER_LOOP);
-	SET_ETHTOOL_OPS(dev, &ops);
+	dev->ethtool_ops = &ops;
 	dev->watchdog_timeo = NV_WATCHDOG_TIMEO;
 
 	pci_set_drvdata(pci_dev, dev);
diff --git a/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_ethtool.c b/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_ethtool.c
index 24b787be6062..e3f4d93bd4a3 100644
--- a/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_ethtool.c
+++ b/drivers/net/ethernet/oki-semi/pch_gbe/pch_gbe_ethtool.c
@@ -508,5 +508,5 @@ static const struct ethtool_ops pch_gbe_ethtool_ops = {
 
 void pch_gbe_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &pch_gbe_ethtool_ops);
+	netdev->ethtool_ops = &pch_gbe_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/packetengines/hamachi.c b/drivers/net/ethernet/packetengines/hamachi.c
index cac33e5f9bc2..e16e2a0c508f 100644
--- a/drivers/net/ethernet/packetengines/hamachi.c
+++ b/drivers/net/ethernet/packetengines/hamachi.c
@@ -724,10 +724,8 @@ static int hamachi_init_one(struct pci_dev *pdev,
 
 	/* The Hamachi-specific entries in the device structure. */
 	dev->netdev_ops = &hamachi_netdev_ops;
-	if (chip_tbl[hmp->chip_id].flags & CanHaveMII)
-		SET_ETHTOOL_OPS(dev, &ethtool_ops);
-	else
-		SET_ETHTOOL_OPS(dev, &ethtool_ops_no_mii);
+	dev->ethtool_ops = (chip_tbl[hmp->chip_id].flags & CanHaveMII) ?
+		&ethtool_ops : &ethtool_ops_no_mii;
 	dev->watchdog_timeo = TX_TIMEOUT;
 	if (mtu)
 		dev->mtu = mtu;
diff --git a/drivers/net/ethernet/packetengines/yellowfin.c b/drivers/net/ethernet/packetengines/yellowfin.c
index d28593b1fc3e..db22c9d9e57a 100644
--- a/drivers/net/ethernet/packetengines/yellowfin.c
+++ b/drivers/net/ethernet/packetengines/yellowfin.c
@@ -472,7 +472,7 @@ static int yellowfin_init_one(struct pci_dev *pdev,
 
 	/* The Yellowfin-specific entries in the device structure. */
 	dev->netdev_ops = &netdev_ops;
-	SET_ETHTOOL_OPS(dev, &ethtool_ops);
+	dev->ethtool_ops = &ethtool_ops;
 	dev->watchdog_timeo = TX_TIMEOUT;
 
 	if (mtu)
diff --git a/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c b/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c
index 7460d586b451..0d707d45e82a 100644
--- a/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c
+++ b/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c
@@ -1374,7 +1374,7 @@ netxen_setup_netdev(struct netxen_adapter *adapter,
 
 	netxen_nic_change_mtu(netdev, netdev->mtu);
 
-	SET_ETHTOOL_OPS(netdev, &netxen_nic_ethtool_ops);
+	netdev->ethtool_ops = &netxen_nic_ethtool_ops;
 
 	netdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
 	                      NETIF_F_RXCSUM;
diff --git a/drivers/net/ethernet/qlogic/qla3xxx.c b/drivers/net/ethernet/qlogic/qla3xxx.c
index 91a8fcd6c246..7e2f3ace9c37 100644
--- a/drivers/net/ethernet/qlogic/qla3xxx.c
+++ b/drivers/net/ethernet/qlogic/qla3xxx.c
@@ -3839,7 +3839,7 @@ static int ql3xxx_probe(struct pci_dev *pdev,
 
 	/* Set driver entry points */
 	ndev->netdev_ops = &ql3xxx_netdev_ops;
-	SET_ETHTOOL_OPS(ndev, &ql3xxx_ethtool_ops);
+	ndev->ethtool_ops = &ql3xxx_ethtool_ops;
 	ndev->watchdog_timeo = 5 * HZ;
 
 	netif_napi_add(ndev, &qdev->napi, ql_poll, 64);
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index ccf682b59be0..23ca9d8e972a 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@ -2034,10 +2034,8 @@ qlcnic_setup_netdev(struct qlcnic_adapter *adapter, struct net_device *netdev,
 
 	qlcnic_change_mtu(netdev, netdev->mtu);
 
-	if (qlcnic_sriov_vf_check(adapter))
-		SET_ETHTOOL_OPS(netdev, &qlcnic_sriov_vf_ethtool_ops);
-	else
-		SET_ETHTOOL_OPS(netdev, &qlcnic_ethtool_ops);
+	netdev->ethtool_ops = (qlcnic_sriov_vf_check(adapter)) ?
+		&qlcnic_sriov_vf_ethtool_ops : &qlcnic_ethtool_ops;
 
 	netdev->features |= (NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_RXCSUM |
 			     NETIF_F_IPV6_CSUM | NETIF_F_GRO |
@@ -2448,7 +2446,7 @@ err_out_disable_pdev:
 err_out_maintenance_mode:
 	set_bit(__QLCNIC_MAINTENANCE_MODE, &adapter->state);
 	netdev->netdev_ops = &qlcnic_netdev_failed_ops;
-	SET_ETHTOOL_OPS(netdev, &qlcnic_ethtool_failed_ops);
+	netdev->ethtool_ops = &qlcnic_ethtool_failed_ops;
 	ahw->port_type = QLCNIC_XGBE;
 
 	if (qlcnic_83xx_check(adapter))
diff --git a/drivers/net/ethernet/qlogic/qlge/qlge_main.c b/drivers/net/ethernet/qlogic/qlge/qlge_main.c
index 6fca5b0f4359..c6e2936b7e81 100644
--- a/drivers/net/ethernet/qlogic/qlge/qlge_main.c
+++ b/drivers/net/ethernet/qlogic/qlge/qlge_main.c
@@ -4778,7 +4778,7 @@ static int qlge_probe(struct pci_dev *pdev,
 	ndev->irq = pdev->irq;
 
 	ndev->netdev_ops = &qlge_netdev_ops;
-	SET_ETHTOOL_OPS(ndev, &qlge_ethtool_ops);
+	ndev->ethtool_ops = &qlge_ethtool_ops;
 	ndev->watchdog_timeo = 10 * HZ;
 
 	err = register_netdev(ndev);
diff --git a/drivers/net/ethernet/realtek/r8169.c b/drivers/net/ethernet/realtek/r8169.c
index 3049228916a4..426a9b2283a3 100644
--- a/drivers/net/ethernet/realtek/r8169.c
+++ b/drivers/net/ethernet/realtek/r8169.c
@@ -7723,7 +7723,7 @@ rtl_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	for (i = 0; i < ETH_ALEN; i++)
 		dev->dev_addr[i] = RTL_R8(MAC0 + i);
 
-	SET_ETHTOOL_OPS(dev, &rtl8169_ethtool_ops);
+	dev->ethtool_ops = &rtl8169_ethtool_ops;
 	dev->watchdog_timeo = RTL8169_TX_TIMEOUT;
 
 	netif_napi_add(dev, &tp->napi, rtl8169_poll, R8169_NAPI_WEIGHT);
* Unmerged path drivers/net/ethernet/renesas/sh_eth.c
* Unmerged path drivers/net/ethernet/samsung/sxgbe/sxgbe_ethtool.c
diff --git a/drivers/net/ethernet/sfc/efx.c b/drivers/net/ethernet/sfc/efx.c
index e2a54ed98814..d257270bbdb9 100644
--- a/drivers/net/ethernet/sfc/efx.c
+++ b/drivers/net/ethernet/sfc/efx.c
@@ -2296,7 +2296,7 @@ static int efx_register_netdev(struct efx_nic *efx)
 	} else {
 		net_dev->netdev_ops = &efx_farch_netdev_ops;
 	}
-	SET_ETHTOOL_OPS(net_dev, &efx_ethtool_ops);
+	net_dev->ethtool_ops = &efx_ethtool_ops;
 	net_dev->gso_max_segs = EFX_TSO_MAX_SEGS;
 
 	rtnl_lock();
diff --git a/drivers/net/ethernet/sis/sis190.c b/drivers/net/ethernet/sis/sis190.c
index f27dd869fe2d..9bdd37eb7fb7 100644
--- a/drivers/net/ethernet/sis/sis190.c
+++ b/drivers/net/ethernet/sis/sis190.c
@@ -1877,7 +1877,7 @@ static int sis190_init_one(struct pci_dev *pdev,
 
 	dev->netdev_ops = &sis190_netdev_ops;
 
-	SET_ETHTOOL_OPS(dev, &sis190_ethtool_ops);
+	dev->ethtool_ops = &sis190_ethtool_ops;
 	dev->watchdog_timeo = SIS190_TX_TIMEOUT;
 
 	spin_lock_init(&tp->lock);
diff --git a/drivers/net/ethernet/smsc/smc91c92_cs.c b/drivers/net/ethernet/smsc/smc91c92_cs.c
index 656d2e2ebfc9..f62f4e3ce0a0 100644
--- a/drivers/net/ethernet/smsc/smc91c92_cs.c
+++ b/drivers/net/ethernet/smsc/smc91c92_cs.c
@@ -319,7 +319,7 @@ static int smc91c92_probe(struct pcmcia_device *link)
 
     /* The SMC91c92-specific entries in the device structure. */
     dev->netdev_ops = &smc_netdev_ops;
-    SET_ETHTOOL_OPS(dev, &ethtool_ops);
+    dev->ethtool_ops = &ethtool_ops;
     dev->watchdog_timeo = TX_TIMEOUT;
 
     smc->mii_if.dev = dev;
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
index c5f9cb85c8ef..c963394ded6c 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ethtool.c
@@ -784,5 +784,5 @@ static const struct ethtool_ops stmmac_ethtool_ops = {
 
 void stmmac_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &stmmac_ethtool_ops);
+	netdev->ethtool_ops = &stmmac_ethtool_ops;
 }
diff --git a/drivers/net/ethernet/tehuti/tehuti.c b/drivers/net/ethernet/tehuti/tehuti.c
index 571452e786d5..3a813404275a 100644
--- a/drivers/net/ethernet/tehuti/tehuti.c
+++ b/drivers/net/ethernet/tehuti/tehuti.c
@@ -2414,7 +2414,7 @@ static void bdx_set_ethtool_ops(struct net_device *netdev)
 		.get_ethtool_stats = bdx_get_ethtool_stats,
 	};
 
-	SET_ETHTOOL_OPS(netdev, &bdx_ethtool_ops);
+	netdev->ethtool_ops = &bdx_ethtool_ops;
 }
 
 /**
diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c
index d1a769f35f9d..59adfcda3492 100644
--- a/drivers/net/ethernet/ti/cpsw.c
+++ b/drivers/net/ethernet/ti/cpsw.c
@@ -1636,7 +1636,7 @@ static int cpsw_probe_dual_emac(struct platform_device *pdev,
 	ndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
 
 	ndev->netdev_ops = &cpsw_netdev_ops;
-	SET_ETHTOOL_OPS(ndev, &cpsw_ethtool_ops);
+	ndev->ethtool_ops = &cpsw_ethtool_ops;
 	netif_napi_add(ndev, &priv_sl2->napi, cpsw_poll, CPSW_POLL_WEIGHT);
 
 	/* register the network device */
@@ -1875,7 +1875,7 @@ static int cpsw_probe(struct platform_device *pdev)
 	ndev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
 
 	ndev->netdev_ops = &cpsw_netdev_ops;
-	SET_ETHTOOL_OPS(ndev, &cpsw_ethtool_ops);
+	ndev->ethtool_ops = &cpsw_ethtool_ops;
 	netif_napi_add(ndev, &priv->napi, cpsw_poll, CPSW_POLL_WEIGHT);
 
 	/* register the network device */
diff --git a/drivers/net/ethernet/ti/davinci_emac.c b/drivers/net/ethernet/ti/davinci_emac.c
index 7233610164cd..31610cf20b3f 100644
--- a/drivers/net/ethernet/ti/davinci_emac.c
+++ b/drivers/net/ethernet/ti/davinci_emac.c
@@ -1987,7 +1987,7 @@ static int davinci_emac_probe(struct platform_device *pdev)
 	}
 
 	ndev->netdev_ops = &emac_netdev_ops;
-	SET_ETHTOOL_OPS(ndev, &ethtool_ops);
+	ndev->ethtool_ops = &ethtool_ops;
 	netif_napi_add(ndev, &priv->napi, emac_poll, EMAC_POLL_WEIGHT);
 
 	/* register the network device */
diff --git a/drivers/net/hyperv/netvsc_drv.c b/drivers/net/hyperv/netvsc_drv.c
index 71baeb3ed905..ee5ef648e97b 100644
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@ -430,7 +430,7 @@ static int netvsc_probe(struct hv_device *dev,
 	net->hw_features = 0;
 	net->features = NETIF_F_HW_VLAN_CTAG_TX;
 
-	SET_ETHTOOL_OPS(net, &ethtool_ops);
+	net->ethtool_ops = &ethtool_ops;
 	SET_NETDEV_DEV(net, &dev->device);
 
 	/* Notify the netvsc driver of the new device */
diff --git a/drivers/net/ntb_netdev.c b/drivers/net/ntb_netdev.c
index f3cdf64997d6..008a2585186a 100644
--- a/drivers/net/ntb_netdev.c
+++ b/drivers/net/ntb_netdev.c
@@ -338,7 +338,7 @@ static int ntb_netdev_probe(struct pci_dev *pdev)
 	memcpy(ndev->dev_addr, ndev->perm_addr, ndev->addr_len);
 
 	ndev->netdev_ops = &ntb_netdev_ops;
-	SET_ETHTOOL_OPS(ndev, &ntb_ethtool_ops);
+	ndev->ethtool_ops = &ntb_ethtool_ops;
 
 	dev->qp = ntb_transport_create_queue(ndev, pdev, &ntb_netdev_handlers);
 	if (!dev->qp) {
* Unmerged path drivers/net/rionet.c
diff --git a/drivers/net/usb/catc.c b/drivers/net/usb/catc.c
index 8d5cac2d8e33..2269b7d2b3fa 100644
--- a/drivers/net/usb/catc.c
+++ b/drivers/net/usb/catc.c
@@ -795,7 +795,7 @@ static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id
 
 	netdev->netdev_ops = &catc_netdev_ops;
 	netdev->watchdog_timeo = TX_TIMEOUT;
-	SET_ETHTOOL_OPS(netdev, &ops);
+	netdev->ethtool_ops = &ops;
 
 	catc->usbdev = usbdev;
 	catc->netdev = netdev;
diff --git a/drivers/net/usb/hso.c b/drivers/net/usb/hso.c
index cba1d46e672e..816a4f88e7c2 100644
--- a/drivers/net/usb/hso.c
+++ b/drivers/net/usb/hso.c
@@ -2426,7 +2426,7 @@ static void hso_net_init(struct net_device *net)
 	net->type = ARPHRD_NONE;
 	net->mtu = DEFAULT_MTU - 14;
 	net->tx_queue_len = 10;
-	SET_ETHTOOL_OPS(net, &ops);
+	net->ethtool_ops = &ops;
 
 	/* and initialize the semaphore */
 	spin_lock_init(&hso_net->net_lock);
diff --git a/drivers/net/usb/ipheth.c b/drivers/net/usb/ipheth.c
index 534d8becbbdc..7ba6ccf2e674 100644
--- a/drivers/net/usb/ipheth.c
+++ b/drivers/net/usb/ipheth.c
@@ -520,7 +520,7 @@ static int ipheth_probe(struct usb_interface *intf,
 	usb_set_intfdata(intf, dev);
 
 	SET_NETDEV_DEV(netdev, &intf->dev);
-	SET_ETHTOOL_OPS(netdev, &ops);
+	netdev->ethtool_ops = &ops;
 
 	retval = register_netdev(netdev);
 	if (retval) {
diff --git a/drivers/net/usb/kaweth.c b/drivers/net/usb/kaweth.c
index afb117c16d2d..ce3b12b38e0c 100644
--- a/drivers/net/usb/kaweth.c
+++ b/drivers/net/usb/kaweth.c
@@ -1173,7 +1173,7 @@ err_fw:
 	netdev->netdev_ops = &kaweth_netdev_ops;
 	netdev->watchdog_timeo = KAWETH_TX_TIMEOUT;
 	netdev->mtu = le16_to_cpu(kaweth->configuration.segment_size);
-	SET_ETHTOOL_OPS(netdev, &ops);
+	netdev->ethtool_ops = &ops;
 
 	/* kaweth is zeroed as part of alloc_netdev */
 	INIT_DELAYED_WORK(&kaweth->lowmem_work, kaweth_resubmit_tl);
diff --git a/drivers/net/usb/pegasus.c b/drivers/net/usb/pegasus.c
index 03e8a15d7deb..f84080215915 100644
--- a/drivers/net/usb/pegasus.c
+++ b/drivers/net/usb/pegasus.c
@@ -1159,7 +1159,7 @@ static int pegasus_probe(struct usb_interface *intf,
 
 	net->watchdog_timeo = PEGASUS_TX_TIMEOUT;
 	net->netdev_ops = &pegasus_netdev_ops;
-	SET_ETHTOOL_OPS(net, &ops);
+	net->ethtool_ops = &ops;
 	pegasus->mii.dev = net;
 	pegasus->mii.mdio_read = mdio_read;
 	pegasus->mii.mdio_write = mdio_write;
* Unmerged path drivers/net/usb/r8152.c
diff --git a/drivers/net/usb/rtl8150.c b/drivers/net/usb/rtl8150.c
index 6cbdac67f3a0..b69a8540af44 100644
--- a/drivers/net/usb/rtl8150.c
+++ b/drivers/net/usb/rtl8150.c
@@ -879,7 +879,7 @@ static int rtl8150_probe(struct usb_interface *intf,
 	dev->netdev = netdev;
 	netdev->netdev_ops = &rtl8150_netdev_ops;
 	netdev->watchdog_timeo = RTL8150_TX_TIMEOUT;
-	SET_ETHTOOL_OPS(netdev, &ops);
+	netdev->ethtool_ops = &ops;
 	dev->intr_interval = 100;	/* 100ms */
 
 	if (!alloc_all_urbs(dev)) {
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index cdf1de0ba5c0..f8d8c60a61fa 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -1565,7 +1565,7 @@ static int virtnet_probe(struct virtio_device *vdev)
 	dev->netdev_ops = &virtnet_netdev;
 	dev->features = NETIF_F_HIGHDMA;
 
-	SET_ETHTOOL_OPS(dev, &virtnet_ethtool_ops);
+	dev->ethtool_ops = &virtnet_ethtool_ops;
 	SET_NETDEV_DEV(dev, &vdev->dev);
 
 	/* Do we support "hardware" checksums? */
diff --git a/drivers/net/vmxnet3/vmxnet3_ethtool.c b/drivers/net/vmxnet3/vmxnet3_ethtool.c
index 600ab56c0008..00e120296e92 100644
--- a/drivers/net/vmxnet3/vmxnet3_ethtool.c
+++ b/drivers/net/vmxnet3/vmxnet3_ethtool.c
@@ -635,5 +635,5 @@ static const struct ethtool_ops vmxnet3_ethtool_ops = {
 
 void vmxnet3_set_ethtool_ops(struct net_device *netdev)
 {
-	SET_ETHTOOL_OPS(netdev, &vmxnet3_ethtool_ops);
+	netdev->ethtool_ops = &vmxnet3_ethtool_ops;
 }
diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c
index 59a6a5a6a6b2..a62e791f659e 100644
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -2580,7 +2580,7 @@ static int vxlan_newlink(struct net *net, struct net_device *dev,
 		return -EEXIST;
 	}
 
-	SET_ETHTOOL_OPS(dev, &vxlan_ethtool_ops);
+	dev->ethtool_ops = &vxlan_ethtool_ops;
 
 	/* create an fdb entry for a valid default destination */
 	if (!vxlan_addr_any(&vxlan->default_dst.remote_ip)) {
diff --git a/drivers/net/wireless/hostap/hostap_main.c b/drivers/net/wireless/hostap/hostap_main.c
index 15f0fad39add..e8157eefb3bf 100644
--- a/drivers/net/wireless/hostap/hostap_main.c
+++ b/drivers/net/wireless/hostap/hostap_main.c
@@ -884,7 +884,7 @@ void hostap_setup_dev(struct net_device *dev, local_info_t *local,
 	dev->mtu = local->mtu;
 
 
-	SET_ETHTOOL_OPS(dev, &prism2_ethtool_ops);
+	dev->ethtool_ops = &prism2_ethtool_ops;
 
 }
 
* Unmerged path drivers/net/xen-netback/interface.c
diff --git a/drivers/net/xen-netfront.c b/drivers/net/xen-netfront.c
index 3f0f20081979..b2df1a03e4df 100644
--- a/drivers/net/xen-netfront.c
+++ b/drivers/net/xen-netfront.c
@@ -1345,7 +1345,7 @@ static struct net_device *xennet_create_dev(struct xenbus_device *dev)
          */
 	netdev->features |= netdev->hw_features;
 
-	SET_ETHTOOL_OPS(netdev, &xennet_ethtool_ops);
+	netdev->ethtool_ops = &xennet_ethtool_ops;
 	SET_NETDEV_DEV(netdev, &dev->dev);
 
 	netif_set_gso_max_size(netdev, XEN_NETIF_MAX_TX_SIZE - MAX_TCP_HEADER);
diff --git a/drivers/s390/net/qeth_l2_main.c b/drivers/s390/net/qeth_l2_main.c
index eb7e44356b43..b96a8f8e45f3 100644
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@ -956,10 +956,9 @@ static int qeth_l2_setup_netdev(struct qeth_card *card)
 	card->dev->watchdog_timeo = QETH_TX_TIMEOUT;
 	card->dev->mtu = card->info.initial_mtu;
 	card->dev->netdev_ops = &qeth_l2_netdev_ops;
-	if (card->info.type != QETH_CARD_TYPE_OSN)
-		SET_ETHTOOL_OPS(card->dev, &qeth_l2_ethtool_ops);
-	else
-		SET_ETHTOOL_OPS(card->dev, &qeth_l2_osn_ops);
+	card->dev->ethtool_ops =
+		(card->info.type != QETH_CARD_TYPE_OSN) ?
+		&qeth_l2_ethtool_ops : &qeth_l2_osn_ops;
 	card->dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
 	card->info.broadcast_capable = 1;
 	qeth_l2_request_initial_mac(card);
diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c
index c8cbc6835e31..30fe08f140e7 100644
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@ -3298,7 +3298,7 @@ static int qeth_l3_setup_netdev(struct qeth_card *card)
 	card->dev->ml_priv = card;
 	card->dev->watchdog_timeo = QETH_TX_TIMEOUT;
 	card->dev->mtu = card->info.initial_mtu;
-	SET_ETHTOOL_OPS(card->dev, &qeth_l3_ethtool_ops);
+	card->dev->ethtool_ops = &qeth_l3_ethtool_ops;
 	card->dev->features |=	NETIF_F_HW_VLAN_CTAG_TX |
 				NETIF_F_HW_VLAN_CTAG_RX |
 				NETIF_F_HW_VLAN_CTAG_FILTER;
diff --git a/drivers/staging/et131x/et131x.c b/drivers/staging/et131x/et131x.c
index f73e58f5ef8d..06540d724dfe 100644
--- a/drivers/staging/et131x/et131x.c
+++ b/drivers/staging/et131x/et131x.c
@@ -4829,7 +4829,7 @@ static int et131x_pci_setup(struct pci_dev *pdev,
 	netdev->netdev_ops     = &et131x_netdev_ops;
 
 	SET_NETDEV_DEV(netdev, &pdev->dev);
-	SET_ETHTOOL_OPS(netdev, &et131x_ethtool_ops);
+	netdev->ethtool_ops = &et131x_ethtool_ops;
 
 	adapter = et131x_adapter_init(netdev, pdev);
 
diff --git a/drivers/staging/ft1000/ft1000-pcmcia/ft1000_hw.c b/drivers/staging/ft1000/ft1000-pcmcia/ft1000_hw.c
index 29d0a72f0d65..8d200d1798db 100644
--- a/drivers/staging/ft1000/ft1000-pcmcia/ft1000_hw.c
+++ b/drivers/staging/ft1000/ft1000-pcmcia/ft1000_hw.c
@@ -2219,7 +2219,7 @@ struct net_device *init_ft1000_card(struct pcmcia_device *link,
 
 	ft1000InitProc(dev);
 	ft1000_card_present = 1;
-	SET_ETHTOOL_OPS(dev, &ops);
+	dev->ethtool_ops = &ops;
 	printk(KERN_INFO "ft1000: %s: addr 0x%04lx irq %d, MAC addr %pM\n",
 			dev->name, dev->base_addr, dev->irq, dev->dev_addr);
 	return dev;
diff --git a/drivers/staging/netlogic/xlr_net.c b/drivers/staging/netlogic/xlr_net.c
index dd98cb1468a4..a1a8d4a0205e 100644
--- a/drivers/staging/netlogic/xlr_net.c
+++ b/drivers/staging/netlogic/xlr_net.c
@@ -1052,7 +1052,7 @@ static int xlr_net_probe(struct platform_device *pdev)
 	xlr_set_rx_mode(ndev);
 
 	priv->num_rx_desc += MAX_NUM_DESC_SPILL;
-	SET_ETHTOOL_OPS(ndev, &xlr_ethtool_ops);
+	ndev->ethtool_ops = &xlr_ethtool_ops;
 	SET_NETDEV_DEV(ndev, &pdev->dev);
 
 	/* Common registers, do one time initialization */
diff --git a/drivers/staging/octeon/ethernet.c b/drivers/staging/octeon/ethernet.c
index c3a90e7012af..010195b0dd48 100644
--- a/drivers/staging/octeon/ethernet.c
+++ b/drivers/staging/octeon/ethernet.c
@@ -474,7 +474,7 @@ int cvm_oct_common_init(struct net_device *dev)
 
 	/* We do our own locking, Linux doesn't need to */
 	dev->features |= NETIF_F_LLTX;
-	SET_ETHTOOL_OPS(dev, &cvm_oct_ethtool_ops);
+	dev->ethtool_ops = &cvm_oct_ethtool_ops;
 
 	cvm_oct_phy_setup_device(dev);
 	cvm_oct_set_mac_filter(dev);
* Unmerged path drivers/usb/gadget/u_ether.c
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 0ce0a1e8a268..5c67a075279a 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -56,9 +56,6 @@ struct device;
 struct phy_device;
 /* 802.11 specific */
 struct wireless_dev;
-					/* source back-compat hooks */
-#define SET_ETHTOOL_OPS(netdev,ops) \
-	( (netdev)->ethtool_ops = (ops) )
 
 extern void netdev_set_default_ethtool_ops(struct net_device *dev,
 					   const struct ethtool_ops *ops);
diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 819dfb006cdf..ce2193b2fb6b 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -617,7 +617,7 @@ static void batadv_softif_init_early(struct net_device *dev)
 	/* generate random address */
 	eth_hw_addr_random(dev);
 
-	SET_ETHTOOL_OPS(dev, &batadv_ethtool_ops);
+	dev->ethtool_ops = &batadv_ethtool_ops;
 
 	memset(priv, 0, sizeof(*priv));
 }
diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c
index eddbc2454775..d2c2923579cf 100644
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@ -345,7 +345,7 @@ void br_dev_setup(struct net_device *dev)
 
 	dev->netdev_ops = &br_netdev_ops;
 	dev->destructor = br_dev_free;
-	SET_ETHTOOL_OPS(dev, &br_ethtool_ops);
+	dev->ethtool_ops = &br_ethtool_ops;
 	SET_NETDEV_DEVTYPE(dev, &br_type);
 	dev->tx_queue_len = 0;
 	dev->priv_flags = IFF_EBRIDGE;
* Unmerged path net/dsa/slave.c
diff --git a/net/openvswitch/vport-internal_dev.c b/net/openvswitch/vport-internal_dev.c
index 729c68763fe7..789af9280e77 100644
--- a/net/openvswitch/vport-internal_dev.c
+++ b/net/openvswitch/vport-internal_dev.c
@@ -130,7 +130,7 @@ static void do_setup(struct net_device *netdev)
 	netdev->priv_flags &= ~IFF_TX_SKB_SHARING;
 	netdev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
 	netdev->destructor = internal_dev_destructor;
-	SET_ETHTOOL_OPS(netdev, &internal_dev_ethtool_ops);
+	netdev->ethtool_ops = &internal_dev_ethtool_ops;
 	netdev->tx_queue_len = 0;
 
 	netdev->features = NETIF_F_LLTX | NETIF_F_SG | NETIF_F_FRAGLIST |
