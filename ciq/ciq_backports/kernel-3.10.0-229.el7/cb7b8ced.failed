ACPI / hotplug / PCI: Hotplug context objects for bridges and functions

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Hotplug context objects for bridges and functions (Myron Stowe) [1114228]
Rebuild_FUZZ: 93.23%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit cb7b8cedf6c88b9d1d08e0565e8da52180921071
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/cb7b8ced.failed

When either a new hotplug bridge or a new hotplug function is added
by the ACPI-based PCI hotplug (ACPIPHP) code, attach a context object
to its ACPI handle to store hotplug-related information in it.  To
start with, put the handle's bridge and function pointers into that
object.  Count references to the context objects and drop them when
they are not needed any more.

First of all, this makes it possible to find out if the given bridge
has been registered as a function already in a much more
straightforward way and acpiphp_bridge_handle_to_function() can be
dropped (Yay!).

This also will allow some more simplifications to be made going
forward.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit cb7b8cedf6c88b9d1d08e0565e8da52180921071)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp.h
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp.h
index 8d99e4e1e51d,f946e47eca7c..000000000000
--- a/drivers/pci/hotplug/acpiphp.h
+++ b/drivers/pci/hotplug/acpiphp.h
@@@ -39,6 -39,17 +39,20 @@@
  #include <linux/mutex.h>
  #include <linux/pci_hotplug.h>
  
++<<<<<<< HEAD
++=======
+ #define dbg(format, arg...)					\
+ 	do {							\
+ 		if (acpiphp_debug)				\
+ 			printk(KERN_DEBUG "%s: " format,	\
+ 				MY_NAME , ## arg);		\
+ 	} while (0)
+ #define err(format, arg...) printk(KERN_ERR "%s: " format, MY_NAME , ## arg)
+ #define info(format, arg...) printk(KERN_INFO "%s: " format, MY_NAME , ## arg)
+ #define warn(format, arg...) printk(KERN_WARNING "%s: " format, MY_NAME , ## arg)
+ 
+ struct acpiphp_context;
++>>>>>>> cb7b8cedf6c8 (ACPI / hotplug / PCI: Hotplug context objects for bridges and functions)
  struct acpiphp_bridge;
  struct acpiphp_slot;
  
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 7d4cb0d082b8,a0c518c2185e..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -57,7 -55,10 +57,8 @@@
  
  static LIST_HEAD(bridge_list);
  static DEFINE_MUTEX(bridge_mutex);
+ static DEFINE_MUTEX(acpiphp_context_lock);
  
 -#define MY_NAME "acpiphp_glue"
 -
  static void handle_hotplug_event_bridge (acpi_handle, u32, void *);
  static void acpiphp_sanitize_bus(struct pci_bus *bus);
  static void acpiphp_set_hpp_values(struct pci_bus *bus);
@@@ -195,13 -275,13 +276,14 @@@ static void acpiphp_dock_release(void *
  }
  
  /* callback routine to register each ACPI PCI slot object */
- static acpi_status
- register_slot(acpi_handle handle, u32 lvl, void *context, void **rv)
+ static acpi_status register_slot(acpi_handle handle, u32 lvl, void *data,
+ 				 void **rv)
  {
- 	struct acpiphp_bridge *bridge = (struct acpiphp_bridge *)context;
+ 	struct acpiphp_bridge *bridge = data;
+ 	struct acpiphp_context *context;
  	struct acpiphp_slot *slot;
  	struct acpiphp_func *newfunc;
 +	acpi_handle tmp;
  	acpi_status status = AE_OK;
  	unsigned long long adr, sun;
  	int device, function, retval, found = 0;
@@@ -232,19 -312,31 +314,35 @@@
  	newfunc->handle = handle;
  	newfunc->function = function;
  
++<<<<<<< HEAD
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
++=======
+ 	mutex_lock(&acpiphp_context_lock);
+ 	context = acpiphp_init_context(handle);
+ 	if (!context) {
+ 		mutex_unlock(&acpiphp_context_lock);
+ 		acpi_handle_err(handle, "No hotplug context\n");
+ 		kfree(newfunc);
+ 		return AE_NOT_EXIST;
+ 	}
+ 	newfunc->context = context;
+ 	context->func = newfunc;
+ 	mutex_unlock(&acpiphp_context_lock);
+ 
+ 	if (acpi_has_method(handle, "_EJ0"))
++>>>>>>> cb7b8cedf6c8 (ACPI / hotplug / PCI: Hotplug context objects for bridges and functions)
  		newfunc->flags = FUNC_HAS_EJ0;
  
 -	if (acpi_has_method(handle, "_STA"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_STA", &tmp)))
  		newfunc->flags |= FUNC_HAS_STA;
  
 -	if (acpi_has_method(handle, "_PS0"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS0", &tmp)))
  		newfunc->flags |= FUNC_HAS_PS0;
  
 -	if (acpi_has_method(handle, "_PS3"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS3", &tmp)))
  		newfunc->flags |= FUNC_HAS_PS3;
  
 -	if (acpi_has_method(handle, "_DCK"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_DCK", &tmp)))
  		newfunc->flags |= FUNC_HAS_DCK;
  
  	status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
@@@ -288,12 -380,14 +386,14 @@@
  		retval = acpiphp_register_hotplug_slot(slot);
  		if (retval) {
  			if (retval == -EBUSY)
 -				warn("Slot %llu already registered by another "
 +				pr_warn("Slot %llu already registered by another "
  					"hotplug driver\n", slot->sun);
  			else
 -				warn("acpiphp_register_hotplug_slot failed "
 +				pr_warn("acpiphp_register_hotplug_slot failed "
  					"(err code = 0x%x)\n", retval);
- 			goto err_exit;
+ 
+ 			status = AE_OK;
+ 			goto err;
  		}
  	}
  
@@@ -334,13 -420,12 +434,13 @@@
  					     newfunc);
  
  		if (ACPI_FAILURE(status))
 -			err("failed to register interrupt notify handler\n");
 -	}
 +			pr_err("failed to register interrupt notify handler\n");
 +	} else
 +		status = AE_OK;
  
 -	return AE_OK;
 +	return status;
  
-  err_exit:
+  err:
  	bridge->nr_slots--;
  	mutex_lock(&bridge_mutex);
  	list_del(&slot->node);
@@@ -363,72 -453,6 +468,75 @@@ static int detect_ejectable_slots(acpi_
  	return found;
  }
  
++<<<<<<< HEAD
 +/* initialize miscellaneous stuff for both root and PCI-to-PCI bridge */
 +static void init_bridge_misc(struct acpiphp_bridge *bridge)
 +{
 +	acpi_status status;
 +
 +	/* must be added to the list prior to calling register_slot */
 +	mutex_lock(&bridge_mutex);
 +	list_add(&bridge->list, &bridge_list);
 +	mutex_unlock(&bridge_mutex);
 +
 +	/* register all slot objects under this bridge */
 +	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, bridge->handle, (u32)1,
 +				     register_slot, NULL, bridge, NULL);
 +	if (ACPI_FAILURE(status)) {
 +		mutex_lock(&bridge_mutex);
 +		list_del(&bridge->list);
 +		mutex_unlock(&bridge_mutex);
 +		return;
 +	}
 +
 +	/* install notify handler for P2P bridges */
 +	if (!pci_is_root_bus(bridge->pci_bus)) {
 +		if ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {
 +			status = acpi_remove_notify_handler(bridge->func->handle,
 +						ACPI_SYSTEM_NOTIFY,
 +						handle_hotplug_event_func);
 +			if (ACPI_FAILURE(status))
 +				pr_err("failed to remove notify handler\n");
 +		}
 +		status = acpi_install_notify_handler(bridge->handle,
 +					     ACPI_SYSTEM_NOTIFY,
 +					     handle_hotplug_event_bridge,
 +					     bridge);
 +
 +		if (ACPI_FAILURE(status)) {
 +			pr_err("failed to register interrupt notify handler\n");
 +		}
 +	}
 +}
 +
 +
 +/* find acpiphp_func from acpiphp_bridge */
 +static struct acpiphp_func *acpiphp_bridge_handle_to_function(acpi_handle handle)
 +{
 +	struct acpiphp_bridge *bridge;
 +	struct acpiphp_slot *slot;
 +	struct acpiphp_func *func = NULL;
 +
 +	mutex_lock(&bridge_mutex);
 +	list_for_each_entry(bridge, &bridge_list, list) {
 +		list_for_each_entry(slot, &bridge->slots, node) {
 +			list_for_each_entry(func, &slot->funcs, sibling) {
 +				if (func->handle == handle) {
 +					get_bridge(func->slot->bridge);
 +					mutex_unlock(&bridge_mutex);
 +					return func;
 +				}
 +			}
 +		}
 +	}
 +	mutex_unlock(&bridge_mutex);
 +
 +	return NULL;
 +}
 +
 +
++=======
++>>>>>>> cb7b8cedf6c8 (ACPI / hotplug / PCI: Hotplug context objects for bridges and functions)
  static struct acpiphp_bridge *acpiphp_handle_to_bridge(acpi_handle handle)
  {
  	struct acpiphp_bridge *bridge;
@@@ -1169,10 -1181,12 +1277,14 @@@ static void handle_hotplug_event_func(a
   * Create hotplug slots for the PCI bus.
   * It should always return 0 to avoid skipping following notifiers.
   */
 -void acpiphp_enumerate_slots(struct pci_bus *bus)
 +void acpiphp_enumerate_slots(struct pci_bus *bus, acpi_handle handle)
  {
++<<<<<<< HEAD
 +	acpi_handle dummy_handle;
++=======
+ 	struct acpiphp_context *context;
++>>>>>>> cb7b8cedf6c8 (ACPI / hotplug / PCI: Hotplug context objects for bridges and functions)
  	struct acpiphp_bridge *bridge;
 -	acpi_handle handle;
 -	acpi_status status;
  
  	if (acpiphp_disabled)
  		return;
@@@ -1181,8 -1196,8 +1293,13 @@@
  		return;
  
  	bridge = kzalloc(sizeof(struct acpiphp_bridge), GFP_KERNEL);
++<<<<<<< HEAD
 +	if (bridge == NULL) {
 +		pr_err("out of memory\n");
++=======
+ 	if (!bridge) {
+ 		acpi_handle_err(handle, "No memory for bridge object\n");
++>>>>>>> cb7b8cedf6c8 (ACPI / hotplug / PCI: Hotplug context objects for bridges and functions)
  		return;
  	}
  
@@@ -1199,15 -1229,53 +1331,52 @@@
  	 */
  	get_device(&bus->dev);
  
 -	/* must be added to the list prior to calling register_slot */
 -	mutex_lock(&bridge_mutex);
 -	list_add(&bridge->list, &bridge_list);
 -	mutex_unlock(&bridge_mutex);
 -
 -	/* register all slot objects under this bridge */
 -	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, bridge->handle, 1,
 -				     register_slot, NULL, bridge, NULL);
 -	if (ACPI_FAILURE(status)) {
 -		acpi_handle_err(bridge->handle, "failed to register slots\n");
 -		goto err;
 +	if (!pci_is_root_bus(bridge->pci_bus) &&
 +	    ACPI_SUCCESS(acpi_get_handle(bridge->handle,
 +					"_EJ0", &dummy_handle))) {
 +		pr_debug("found ejectable p2p bridge\n");
 +		bridge->flags |= BRIDGE_HAS_EJ0;
 +		bridge->func = acpiphp_bridge_handle_to_function(handle);
  	}
  
++<<<<<<< HEAD
 +	init_bridge_misc(bridge);
++=======
+ 	if (pci_is_root_bus(bridge->pci_bus))
+ 		return;
+ 
+ 	/* install notify handler for P2P bridges */
+ 	status = acpi_install_notify_handler(bridge->handle, ACPI_SYSTEM_NOTIFY,
+ 					     handle_hotplug_event_bridge,
+ 					     bridge);
+ 	if (ACPI_FAILURE(status)) {
+ 		acpi_handle_err(bridge->handle,
+ 				"failed to register notify handler\n");
+ 		goto err;
+ 	}
+ 
+ 	if (!acpi_has_method(bridge->handle, "_EJ0"))
+ 		return;
+ 
+ 	dbg("found ejectable p2p bridge\n");
+ 	bridge->flags |= BRIDGE_HAS_EJ0;
+ 	if (context->func) {
+ 		get_bridge(context->func->slot->bridge);
+ 		bridge->func = context->func;
+ 		handle = context->handle;
+ 		WARN_ON(bridge->handle != handle);
+ 		status = acpi_remove_notify_handler(handle, ACPI_SYSTEM_NOTIFY,
+ 						    handle_hotplug_event_func);
+ 		if (ACPI_FAILURE(status))
+ 			acpi_handle_err(handle,
+ 					"failed to remove notify handler\n");
+ 	}
+ 	return;
+ 
+  err:
+ 	cleanup_bridge(bridge);
+ 	put_bridge(bridge);
++>>>>>>> cb7b8cedf6c8 (ACPI / hotplug / PCI: Hotplug context objects for bridges and functions)
  }
  
  /* Destroy hotplug slots associated with the PCI bus */
* Unmerged path drivers/pci/hotplug/acpiphp.h
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
