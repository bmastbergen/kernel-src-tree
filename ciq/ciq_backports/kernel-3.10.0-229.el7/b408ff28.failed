iw_cxgb4: don't truncate the recv window size

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [infiniband] cxgb4: don't truncate the recv window size (Sai Vemuri) [1124947]
Rebuild_FUZZ: 96.55%
commit-author Hariprasad Shenai <hariprasad@chelsio.com>
commit b408ff282dda0ef7a3218dc2e5f1399c665d4c20
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/b408ff28.failed

Fixed a bug that shows up with recv window sizes that exceed the size of
the RCV_BUFSIZ field in opt0 (>= 1024K).  If the recv window exceeds
this, then we specify the max possible in opt0, add add the rest in via
a RX_DATA_ACK credits.

	Signed-off-by: Steve Wise <swise@opengridcomputing.com>
	Signed-off-by: Hariprasad Shenai <hariprasad@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b408ff282dda0ef7a3218dc2e5f1399c665d4c20)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/cxgb4/cm.c
diff --cc drivers/infiniband/hw/cxgb4/cm.c
index 96d7131ab974,965eaafd5851..000000000000
--- a/drivers/infiniband/hw/cxgb4/cm.c
+++ b/drivers/infiniband/hw/cxgb4/cm.c
@@@ -583,14 -561,11 +583,22 @@@ static int send_connect(struct c4iw_ep 
  	int sizev6 = is_t4(ep->com.dev->rdev.lldi.adapter_type) ?
  				sizeof(struct cpl_act_open_req6) :
  				sizeof(struct cpl_t5_act_open_req6);
++<<<<<<< HEAD
 +	struct sockaddr_in *la = (struct sockaddr_in *)
 +				 &ep->com.mapped_local_addr;
 +	struct sockaddr_in *ra = (struct sockaddr_in *)
 +				 &ep->com.mapped_remote_addr;
 +	struct sockaddr_in6 *la6 = (struct sockaddr_in6 *)
 +				   &ep->com.mapped_local_addr;
 +	struct sockaddr_in6 *ra6 = (struct sockaddr_in6 *)
 +				   &ep->com.mapped_remote_addr;
++=======
+ 	struct sockaddr_in *la = (struct sockaddr_in *)&ep->com.local_addr;
+ 	struct sockaddr_in *ra = (struct sockaddr_in *)&ep->com.remote_addr;
+ 	struct sockaddr_in6 *la6 = (struct sockaddr_in6 *)&ep->com.local_addr;
+ 	struct sockaddr_in6 *ra6 = (struct sockaddr_in6 *)&ep->com.remote_addr;
+ 	int win;
++>>>>>>> b408ff282dda (iw_cxgb4: don't truncate the recv window size)
  
  	wrlen = (ep->com.remote_addr.ss_family == AF_INET) ?
  			roundup(sizev4, 16) :
@@@ -606,8 -581,18 +614,17 @@@
  	}
  	set_wr_txq(skb, CPL_PRIORITY_SETUP, ep->ctrlq_idx);
  
 -	best_mtu(ep->com.dev->rdev.lldi.mtus, ep->mtu, &mtu_idx,
 -		 enable_tcp_timestamps);
 +	cxgb4_best_mtu(ep->com.dev->rdev.lldi.mtus, ep->mtu, &mtu_idx);
  	wscale = compute_wscale(rcv_win);
+ 
+ 	/*
+ 	 * Specify the largest window that will fit in opt0. The
+ 	 * remainder will be specified in the rx_data_ack.
+ 	 */
+ 	win = ep->rcv_win >> 10;
+ 	if (win > RCV_BUFSIZ_MASK)
+ 		win = RCV_BUFSIZ_MASK;
+ 
  	opt0 = (nocong ? NO_CONG(1) : 0) |
  	       KEEP_ALIVE(1) |
  	       DELACK(1) |
@@@ -1681,8 -1688,18 +1707,17 @@@ static void send_fw_act_open_req(struc
  			htons(F_FW_OFLD_CONNECTION_WR_CPLRXDATAACK);
  	req->tcb.tx_max = (__force __be32) jiffies;
  	req->tcb.rcv_adv = htons(1);
 -	best_mtu(ep->com.dev->rdev.lldi.mtus, ep->mtu, &mtu_idx,
 -		 enable_tcp_timestamps);
 +	cxgb4_best_mtu(ep->com.dev->rdev.lldi.mtus, ep->mtu, &mtu_idx);
  	wscale = compute_wscale(rcv_win);
+ 
+ 	/*
+ 	 * Specify the largest window that will fit in opt0. The
+ 	 * remainder will be specified in the rx_data_ack.
+ 	 */
+ 	win = ep->rcv_win >> 10;
+ 	if (win > RCV_BUFSIZ_MASK)
+ 		win = RCV_BUFSIZ_MASK;
+ 
  	req->tcb.opt0 = (__force __be64) (TCAM_BYPASS(1) |
  		(nocong ? NO_CONG(1) : 0) |
  		KEEP_ALIVE(1) |
@@@ -1796,7 -1821,8 +1839,12 @@@ static int import_ep(struct c4iw_ep *ep
  		step = cdev->rdev.lldi.nrxq /
  			cdev->rdev.lldi.nchan;
  		ep->rss_qid = cdev->rdev.lldi.rxq_ids[
++<<<<<<< HEAD
 +			cxgb4_port_idx(pdev) * step];
++=======
+ 			cxgb4_port_idx(n->dev) * step];
+ 		set_tcp_window(ep, (struct port_info *)netdev_priv(pdev));
++>>>>>>> b408ff282dda (iw_cxgb4: don't truncate the recv window size)
  
  		if (clear_mpa_v1) {
  			ep->retry_with_mpa_v1 = 0;
@@@ -2027,13 -2053,36 +2075,26 @@@ static void accept_cr(struct c4iw_ep *e
  	u64 opt0;
  	u32 opt2;
  	int wscale;
++<<<<<<< HEAD
++=======
+ 	struct cpl_t5_pass_accept_rpl *rpl5 = NULL;
+ 	int win;
++>>>>>>> b408ff282dda (iw_cxgb4: don't truncate the recv window size)
  
  	PDBG("%s ep %p tid %u\n", __func__, ep, ep->hwtid);
  	BUG_ON(skb_cloned(skb));
 -
 +	skb_trim(skb, sizeof(*rpl));
  	skb_get(skb);
 -	rpl = cplhdr(skb);
 -	if (is_t5(ep->com.dev->rdev.lldi.adapter_type)) {
 -		skb_trim(skb, roundup(sizeof(*rpl5), 16));
 -		rpl5 = (void *)rpl;
 -		INIT_TP_WR(rpl5, ep->hwtid);
 -	} else {
 -		skb_trim(skb, sizeof(*rpl));
 -		INIT_TP_WR(rpl, ep->hwtid);
 -	}
 -	OPCODE_TID(rpl) = cpu_to_be32(MK_OPCODE_TID(CPL_PASS_ACCEPT_RPL,
 -						    ep->hwtid));
 -
 -	best_mtu(ep->com.dev->rdev.lldi.mtus, ep->mtu, &mtu_idx,
 -		 enable_tcp_timestamps && req->tcpopt.tstamp);
 +	cxgb4_best_mtu(ep->com.dev->rdev.lldi.mtus, ep->mtu, &mtu_idx);
  	wscale = compute_wscale(rcv_win);
+ 
+ 	/*
+ 	 * Specify the largest window that will fit in opt0. The
+ 	 * remainder will be specified in the rx_data_ack.
+ 	 */
+ 	win = ep->rcv_win >> 10;
+ 	if (win > RCV_BUFSIZ_MASK)
+ 		win = RCV_BUFSIZ_MASK;
  	opt0 = (nocong ? NO_CONG(1) : 0) |
  	       KEEP_ALIVE(1) |
  	       DELACK(1) |
* Unmerged path drivers/infiniband/hw/cxgb4/cm.c
diff --git a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
index 6f533fbcc4b3..125bc5d1e175 100644
--- a/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
+++ b/drivers/infiniband/hw/cxgb4/iw_cxgb4.h
@@ -810,6 +810,8 @@ struct c4iw_ep {
 	u8 retry_with_mpa_v1;
 	u8 tried_with_mpa_v1;
 	unsigned int retry_count;
+	int snd_win;
+	int rcv_win;
 };
 
 static inline void print_addr(struct c4iw_ep_common *epc, const char *func,
diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h b/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
index f2738c710789..330bc1441848 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_msg.h
@@ -227,6 +227,7 @@ struct cpl_pass_open_req {
 #define DELACK(x)     ((x) << 5)
 #define ULP_MODE(x)   ((x) << 8)
 #define RCV_BUFSIZ(x) ((x) << 12)
+#define RCV_BUFSIZ_MASK 0x3FFU
 #define DSCP(x)       ((x) << 22)
 #define SMAC_SEL(x)   ((u64)(x) << 28)
 #define L2T_IDX(x)    ((u64)(x) << 36)
