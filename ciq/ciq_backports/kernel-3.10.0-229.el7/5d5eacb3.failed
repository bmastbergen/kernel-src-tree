bridge: fdb dumping takes a filter device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Jamal Hadi Salim <jhs@mojatatu.com>
commit 5d5eacb34c9e1fdc0a47b885d832eaa4de860dc7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5d5eacb3.failed

Dumping a bridge fdb dumps every fdb entry
held. With this change we are going to filter
on selected bridge port.

	Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 5d5eacb34c9e1fdc0a47b885d832eaa4de860dc7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
#	net/bridge/br_private.h
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index 3f4c4a313837,0fdbcc8319f7..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@@ -418,10 -433,11 +419,16 @@@ static int qlcnic_fdb_dump(struct sk_bu
  	struct qlcnic_adapter *adapter = netdev_priv(netdev);
  
  	if (!adapter->fdb_mac_learn)
- 		return ndo_dflt_fdb_dump(skb, ncb, netdev, idx);
+ 		return ndo_dflt_fdb_dump(skb, ncb, netdev, filter_dev, idx);
  
++<<<<<<< HEAD
 +	if (adapter->flags & QLCNIC_ESWITCH_ENABLED)
 +		idx = ndo_dflt_fdb_dump(skb, ncb, netdev, idx);
++=======
+ 	if ((adapter->flags & QLCNIC_ESWITCH_ENABLED) ||
+ 	    qlcnic_sriov_check(adapter))
+ 		idx = ndo_dflt_fdb_dump(skb, ncb, netdev, filter_dev, idx);
++>>>>>>> 5d5eacb34c9e (bridge: fdb dumping takes a filter device)
  
  	return idx;
  }
diff --cc net/bridge/br_private.h
index c7fe759dc8ea,62a7fa2e3569..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -383,70 -373,61 +383,81 @@@ static inline void br_netpoll_disable(s
  #endif
  
  /* br_fdb.c */
 -int br_fdb_init(void);
 -void br_fdb_fini(void);
 -void br_fdb_flush(struct net_bridge *br);
 -void br_fdb_find_delete_local(struct net_bridge *br,
 -			      const struct net_bridge_port *p,
 -			      const unsigned char *addr, u16 vid);
 -void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr);
 -void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
 -void br_fdb_cleanup(unsigned long arg);
 -void br_fdb_delete_by_port(struct net_bridge *br,
 -			   const struct net_bridge_port *p, int do_all);
 -struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
 -					  const unsigned char *addr, __u16 vid);
 -int br_fdb_test_addr(struct net_device *dev, unsigned char *addr);
 -int br_fdb_fillbuf(struct net_bridge *br, void *buf, unsigned long count,
 -		   unsigned long off);
 -int br_fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
 -		  const unsigned char *addr, u16 vid);
 -void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
 -		   const unsigned char *addr, u16 vid, bool added_by_user);
 -
 +extern int br_fdb_init(void);
 +extern void br_fdb_fini(void);
 +extern void br_fdb_flush(struct net_bridge *br);
 +extern void br_fdb_changeaddr(struct net_bridge_port *p,
 +			      const unsigned char *newaddr);
 +extern void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
 +extern void br_fdb_cleanup(unsigned long arg);
 +extern void br_fdb_delete_by_port(struct net_bridge *br,
 +				  const struct net_bridge_port *p, int do_all);
 +extern struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
 +						 const unsigned char *addr,
 +						 __u16 vid);
 +extern int br_fdb_test_addr(struct net_device *dev, unsigned char *addr);
 +extern int br_fdb_fillbuf(struct net_bridge *br, void *buf,
 +			  unsigned long count, unsigned long off);
 +extern int br_fdb_insert(struct net_bridge *br,
 +			 struct net_bridge_port *source,
 +			 const unsigned char *addr,
 +			 u16 vid);
 +extern void br_fdb_update(struct net_bridge *br,
 +			  struct net_bridge_port *source,
 +			  const unsigned char *addr,
 +			  u16 vid);
 +extern int fdb_delete_by_addr(struct net_bridge *br, const u8 *addr, u16 vid);
 +
++<<<<<<< HEAD
 +extern int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 +			 struct net_device *dev,
 +			 const unsigned char *addr);
 +extern int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[],
 +		      struct net_device *dev,
 +		      const unsigned char *addr,
 +		      u16 nlh_flags);
 +extern int br_fdb_dump(struct sk_buff *skb,
 +		       struct netlink_callback *cb,
 +		       struct net_device *dev,
 +		       int idx);
++=======
+ int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
+ 		  struct net_device *dev, const unsigned char *addr);
+ int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[], struct net_device *dev,
+ 	       const unsigned char *addr, u16 nlh_flags);
+ int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,
+ 		struct net_device *dev, struct net_device *fdev, int idx);
+ int br_fdb_sync_static(struct net_bridge *br, struct net_bridge_port *p);
+ void br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p);
++>>>>>>> 5d5eacb34c9e (bridge: fdb dumping takes a filter device)
  
  /* br_forward.c */
 -void br_deliver(const struct net_bridge_port *to, struct sk_buff *skb);
 -int br_dev_queue_push_xmit(struct sk_buff *skb);
 -void br_forward(const struct net_bridge_port *to,
 +extern void br_deliver(const struct net_bridge_port *to,
 +		struct sk_buff *skb);
 +extern int br_dev_queue_push_xmit(struct sk_buff *skb);
 +extern void br_forward(const struct net_bridge_port *to,
  		struct sk_buff *skb, struct sk_buff *skb0);
 -int br_forward_finish(struct sk_buff *skb);
 -void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb, bool unicast);
 -void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
 -		      struct sk_buff *skb2, bool unicast);
 +extern int br_forward_finish(struct sk_buff *skb);
 +extern void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb);
 +extern void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
 +			     struct sk_buff *skb2);
  
  /* br_if.c */
 -void br_port_carrier_check(struct net_bridge_port *p);
 -int br_add_bridge(struct net *net, const char *name);
 -int br_del_bridge(struct net *net, const char *name);
 -int br_add_if(struct net_bridge *br, struct net_device *dev);
 -int br_del_if(struct net_bridge *br, struct net_device *dev);
 -int br_min_mtu(const struct net_bridge *br);
 -netdev_features_t br_features_recompute(struct net_bridge *br,
 -					netdev_features_t features);
 -void br_port_flags_change(struct net_bridge_port *port, unsigned long mask);
 -void br_manage_promisc(struct net_bridge *br);
 +extern void br_port_carrier_check(struct net_bridge_port *p);
 +extern int br_add_bridge(struct net *net, const char *name);
 +extern int br_del_bridge(struct net *net, const char *name);
 +extern void br_net_exit(struct net *net);
 +extern int br_add_if(struct net_bridge *br,
 +	      struct net_device *dev);
 +extern int br_del_if(struct net_bridge *br,
 +	      struct net_device *dev);
 +extern int br_min_mtu(const struct net_bridge *br);
 +extern netdev_features_t br_features_recompute(struct net_bridge *br,
 +	netdev_features_t features);
  
  /* br_input.c */
 -int br_handle_frame_finish(struct sk_buff *skb);
 -rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
 +extern int br_handle_frame_finish(struct sk_buff *skb);
 +extern rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
  
  static inline bool br_rx_handler_check_rcu(const struct net_device *dev)
  {
diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c
index b8421d2b483d..2704121bae9b 100644
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -6936,13 +6936,14 @@ static int i40e_ndo_fdb_del(struct ndmsg *ndm,
 static int i40e_ndo_fdb_dump(struct sk_buff *skb,
 			     struct netlink_callback *cb,
 			     struct net_device *dev,
+			     struct net_device *filter_dev,
 			     int idx)
 {
 	struct i40e_netdev_priv *np = netdev_priv(dev);
 	struct i40e_pf *pf = np->vsi->back;
 
 	if (pf->flags & I40E_FLAG_SRIOV_ENABLED)
-		idx = ndo_dflt_fdb_dump(skb, cb, dev, idx);
+		idx = ndo_dflt_fdb_dump(skb, cb, dev, filter_dev, idx);
 
 	return idx;
 }
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c
index 33559a1aa9f1..8653ae0eaa1f 100644
--- a/drivers/net/vxlan.c
+++ b/drivers/net/vxlan.c
@@ -937,7 +937,8 @@ out:
 
 /* Dump forwarding table */
 static int vxlan_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,
-			  struct net_device *dev, int idx)
+			  struct net_device *dev,
+			  struct net_device *filter_dev, int idx)
 {
 	struct vxlan_dev *vxlan = netdev_priv(dev);
 	unsigned int h;
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 42e58d229b1f..f8350521a8d2 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -927,7 +927,8 @@ struct netdev_phys_port_id {
  *		      const unsigned char *addr)
  *	Deletes the FDB entry from dev coresponding to addr.
  * int (*ndo_fdb_dump)(struct sk_buff *skb, struct netlink_callback *cb,
- *		       struct net_device *dev, int idx)
+ *		       struct net_device *dev, struct net_device *filter_dev,
+ *		       int idx)
  *	Used to add FDB entries to dump requests. Implementers should add
  *	entries to skb and update idx with the number of entries.
  *
@@ -1077,6 +1078,7 @@ struct net_device_ops {
 	int			(*ndo_fdb_dump)(struct sk_buff *skb,
 						struct netlink_callback *cb,
 						struct net_device *dev,
+						struct net_device *filter_dev,
 						int idx);
 
 	int			(*ndo_bridge_setlink)(struct net_device *dev,
diff --git a/include/linux/rtnetlink.h b/include/linux/rtnetlink.h
index f28544b2f9af..120b0f7d73d6 100644
--- a/include/linux/rtnetlink.h
+++ b/include/linux/rtnetlink.h
@@ -68,6 +68,7 @@ extern void __rtnl_unlock(void);
 extern int ndo_dflt_fdb_dump(struct sk_buff *skb,
 			     struct netlink_callback *cb,
 			     struct net_device *dev,
+			     struct net_device *filter_dev,
 			     int idx);
 extern int ndo_dflt_fdb_add(struct ndmsg *ndm,
 			    struct nlattr *tb[],
diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c
index ee27e08f9b4b..c43cc7ef7c50 100644
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@ -578,6 +578,7 @@ errout:
 int br_fdb_dump(struct sk_buff *skb,
 		struct netlink_callback *cb,
 		struct net_device *dev,
+		struct net_device *filter_dev,
 		int idx)
 {
 	struct net_bridge *br = netdev_priv(dev);
@@ -593,6 +594,10 @@ int br_fdb_dump(struct sk_buff *skb,
 			if (idx < cb->args[0])
 				goto skip;
 
+			if (filter_dev && (!f->dst || !f->dst->dev ||
+					   f->dst->dev != filter_dev))
+				goto skip;
+
 			if (fdb_fill_info(skb, br, f,
 					  NETLINK_CB(cb->skb).portid,
 					  cb->nlh->nlmsg_seq,
* Unmerged path net/bridge/br_private.h
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index 58cc593f9f44..ecf3cc9b283c 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -2318,6 +2318,7 @@ skip:
 int ndo_dflt_fdb_dump(struct sk_buff *skb,
 		      struct netlink_callback *cb,
 		      struct net_device *dev,
+		      struct net_device *filter_dev,
 		      int idx)
 {
 	int err;
@@ -2348,13 +2349,15 @@ static int rtnl_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb)
 			br_dev = netdev_master_upper_dev_get(dev);
 			ops = br_dev->netdev_ops;
 			if (ops->ndo_fdb_dump)
-				idx = ops->ndo_fdb_dump(skb, cb, dev, idx);
+				idx = ops->ndo_fdb_dump(skb, cb, dev, NULL,
+							idx);
 		}
 
 		if (dev->netdev_ops->ndo_fdb_dump)
-			idx = dev->netdev_ops->ndo_fdb_dump(skb, cb, dev, idx);
+			idx = dev->netdev_ops->ndo_fdb_dump(skb, cb, dev, NULL,
+							    idx);
 		else
-			idx = ndo_dflt_fdb_dump(skb, cb, dev, idx);
+			idx = ndo_dflt_fdb_dump(skb, cb, dev, NULL, idx);
 	}
 	rcu_read_unlock();
 
