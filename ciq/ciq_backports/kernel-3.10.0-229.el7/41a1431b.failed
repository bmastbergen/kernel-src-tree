sched/wait: Introduce ___wait_event()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Peter Zijlstra <peterz@infradead.org>
commit 41a1431b178c3b731d6dfc40b987528b333dd93e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/41a1431b.failed

There's far too much duplication in the __wait_event macros; in order
to fix this introduce ___wait_event() a macro with the capability to
replace most other macros.

With the previous patches changing the various __wait_event*()
implementations to be more uniform; we can now collapse the lot
without also changing generated code.

	Reviewed-by: Oleg Nesterov <oleg@redhat.com>
	Signed-off-by: Peter Zijlstra <peterz@infradead.org>
Link: http://lkml.kernel.org/r/20131002092528.181897111@infradead.org
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 41a1431b178c3b731d6dfc40b987528b333dd93e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/wait.h
diff --cc include/linux/wait.h
index c8e576022234,29d0249e03ab..000000000000
--- a/include/linux/wait.h
+++ b/include/linux/wait.h
@@@ -173,6 -179,50 +173,53 @@@ wait_queue_head_t *bit_waitqueue(void *
  #define wake_up_interruptible_sync_poll(x, m)				\
  	__wake_up_sync_key((x), TASK_INTERRUPTIBLE, 1, (void *) (m))
  
++<<<<<<< HEAD
++=======
+ #define ___wait_cond_timeout(condition, ret)				\
+ ({									\
+  	bool __cond = (condition);					\
+  	if (__cond && !ret)						\
+  		ret = 1;						\
+  	__cond || !ret;							\
+ })
+ 
+ #define ___wait_signal_pending(state)					\
+ 	((state == TASK_INTERRUPTIBLE && signal_pending(current)) ||	\
+ 	 (state == TASK_KILLABLE && fatal_signal_pending(current)))
+ 
+ #define ___wait_nop_ret		int ret __always_unused
+ 
+ #define ___wait_event(wq, condition, state, exclusive, ret, cmd)	\
+ do {									\
+ 	__label__ __out;						\
+ 	DEFINE_WAIT(__wait);						\
+ 									\
+ 	for (;;) {							\
+ 		if (exclusive)						\
+ 			prepare_to_wait_exclusive(&wq, &__wait, state); \
+ 		else							\
+ 			prepare_to_wait(&wq, &__wait, state);		\
+ 									\
+ 		if (condition)						\
+ 			break;						\
+ 									\
+ 		if (___wait_signal_pending(state)) {			\
+ 			ret = -ERESTARTSYS;				\
+ 			if (exclusive) {				\
+ 				abort_exclusive_wait(&wq, &__wait, 	\
+ 						     state, NULL); 	\
+ 				goto __out;				\
+ 			}						\
+ 			break;						\
+ 		}							\
+ 									\
+ 		cmd;							\
+ 	}								\
+ 	finish_wait(&wq, &__wait);					\
+ __out:	;								\
+ } while (0)
+ 
++>>>>>>> 41a1431b178c (sched/wait: Introduce ___wait_event())
  #define __wait_event(wq, condition) 					\
  do {									\
  	DEFINE_WAIT(__wait);						\
* Unmerged path include/linux/wait.h
