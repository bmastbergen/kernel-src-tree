l2tp: call udp{6}_set_csum

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Tom Herbert <therbert@google.com>
commit 77157e1973cbdb8d60bdb0ec749d6014bedc5bd5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/77157e19.failed

Call common functions to set checksum for UDP tunnel.

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 77157e1973cbdb8d60bdb0ec749d6014bedc5bd5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/l2tp/l2tp_core.c
diff --cc net/l2tp/l2tp_core.c
index c3cdfb8ebb39,bea259043205..000000000000
--- a/net/l2tp/l2tp_core.c
+++ b/net/l2tp/l2tp_core.c
@@@ -1096,50 -1095,6 +1096,53 @@@ static int l2tp_xmit_core(struct l2tp_s
  	return 0;
  }
  
++<<<<<<< HEAD
 +/* Automatically called when the skb is freed.
 + */
 +static void l2tp_sock_wfree(struct sk_buff *skb)
 +{
 +	sock_put(skb->sk);
 +}
 +
 +/* For data skbs that we transmit, we associate with the tunnel socket
 + * but don't do accounting.
 + */
 +static inline void l2tp_skb_set_owner_w(struct sk_buff *skb, struct sock *sk)
 +{
 +	sock_hold(sk);
 +	skb->sk = sk;
 +	skb->destructor = l2tp_sock_wfree;
 +}
 +
 +#if IS_ENABLED(CONFIG_IPV6)
 +static void l2tp_xmit_ipv6_csum(struct sock *sk, struct sk_buff *skb,
 +				int udp_len)
 +{
 +	struct ipv6_pinfo *np = inet6_sk(sk);
 +	struct udphdr *uh = udp_hdr(skb);
 +
 +	if (udp_get_no_check6_tx(sk))
 +		skb->ip_summed = CHECKSUM_NONE;
 +	else if (!skb_dst(skb) || !skb_dst(skb)->dev ||
 +	    !(skb_dst(skb)->dev->features & NETIF_F_IPV6_CSUM)) {
 +		__wsum csum = skb_checksum(skb, 0, udp_len, 0);
 +		skb->ip_summed = CHECKSUM_UNNECESSARY;
 +		uh->check = csum_ipv6_magic(&np->saddr, &sk->sk_v6_daddr, udp_len,
 +					    IPPROTO_UDP, csum);
 +		if (uh->check == 0)
 +			uh->check = CSUM_MANGLED_0;
 +	} else {
 +		skb->ip_summed = CHECKSUM_PARTIAL;
 +		skb->csum_start = skb_transport_header(skb) - skb->head;
 +		skb->csum_offset = offsetof(struct udphdr, check);
 +		uh->check = ~csum_ipv6_magic(&np->saddr, &sk->sk_v6_daddr,
 +					     udp_len, IPPROTO_UDP, 0);
 +	}
 +}
 +#endif
 +
++=======
++>>>>>>> 77157e1973cb (l2tp: call udp{6}_set_csum)
  /* If caller requires the skb to have a ppp header, the header must be
   * inserted in the skb data before calling this function.
   */
@@@ -1206,28 -1158,13 +1207,35 @@@ int l2tp_xmit_skb(struct l2tp_session *
  		/* Calculate UDP checksum if configured to do so */
  #if IS_ENABLED(CONFIG_IPV6)
  		if (sk->sk_family == PF_INET6 && !tunnel->v4mapped)
- 			l2tp_xmit_ipv6_csum(sk, skb, udp_len);
+ 			udp6_set_csum(udp_get_no_check6_tx(sk),
+ 				      skb, &inet6_sk(sk)->saddr,
+ 				      &sk->sk_v6_daddr, udp_len);
  		else
  #endif
++<<<<<<< HEAD
 +		if (sk->sk_no_check == UDP_CSUM_NOXMIT)
 +			skb->ip_summed = CHECKSUM_NONE;
 +		else if ((skb_dst(skb) && skb_dst(skb)->dev) &&
 +			 (!(skb_dst(skb)->dev->features & NETIF_F_V4_CSUM))) {
 +			skb->ip_summed = CHECKSUM_COMPLETE;
 +			csum = skb_checksum(skb, 0, udp_len, 0);
 +			uh->check = csum_tcpudp_magic(inet->inet_saddr,
 +						      inet->inet_daddr,
 +						      udp_len, IPPROTO_UDP, csum);
 +			if (uh->check == 0)
 +				uh->check = CSUM_MANGLED_0;
 +		} else {
 +			skb->ip_summed = CHECKSUM_PARTIAL;
 +			skb->csum_start = skb_transport_header(skb) - skb->head;
 +			skb->csum_offset = offsetof(struct udphdr, check);
 +			uh->check = ~csum_tcpudp_magic(inet->inet_saddr,
 +						       inet->inet_daddr,
 +						       udp_len, IPPROTO_UDP, 0);
 +		}
++=======
+ 		udp_set_csum(sk->sk_no_check_tx, skb, inet->inet_saddr,
+ 			     inet->inet_daddr, udp_len);
++>>>>>>> 77157e1973cb (l2tp: call udp{6}_set_csum)
  		break;
  
  	case L2TP_ENCAPTYPE_IP:
* Unmerged path net/l2tp/l2tp_core.c
