iommu/vt-d: fix bug in handling multiple RMRRs for the same PCI device

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: fix bug in handling multiple RMRRs for the same PCI device (Myron Stowe) [1136537]
Rebuild_FUZZ: 95.52%
commit-author Jiang Liu <jiang.liu@linux.intel.com>
commit 27e249501ca06a3010519c306206cc402b61b5ab
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/27e24950.failed

Function dmar_iommu_notify_scope_dev() makes a wrong assumption that
there's one RMRR for each PCI device at most, which causes DMA failure
on some HP platforms. So enhance dmar_iommu_notify_scope_dev() to
handle multiple RMRRs for the same PCI device.

Fixbug: https://bugzilla.novell.com/show_bug.cgi?id=879482

	Cc: <stable@vger.kernel.org> # 3.15
	Reported-by: Tom Mingarelli <thomas.mingarelli@hp.com>
	Tested-by: Linda Knippers <linda.knippers@hp.com>
	Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 27e249501ca06a3010519c306206cc402b61b5ab)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel-iommu.c
diff --cc drivers/iommu/intel-iommu.c
index 3869cde5d60a,51b6b77dc3e5..000000000000
--- a/drivers/iommu/intel-iommu.c
+++ b/drivers/iommu/intel-iommu.c
@@@ -3627,12 -3783,66 +3627,70 @@@ int dmar_find_matched_atsr_unit(struct 
  		if (atsr->segment != pci_domain_nr(dev->bus))
  			continue;
  
 -		for_each_dev_scope(atsru->devices, atsru->devices_cnt, i, tmp)
 -			if (tmp == &bridge->dev)
 -				goto out;
 +		for (i = 0; i < atsru->devices_cnt; i++)
 +			if (atsru->devices[i] == bridge)
 +				return 1;
  
  		if (atsru->include_all)
++<<<<<<< HEAD
 +			return 1;
++=======
+ 			goto out;
+ 	}
+ 	ret = 0;
+ out:
+ 	rcu_read_unlock();
+ 
+ 	return ret;
+ }
+ 
+ int dmar_iommu_notify_scope_dev(struct dmar_pci_notify_info *info)
+ {
+ 	int ret = 0;
+ 	struct dmar_rmrr_unit *rmrru;
+ 	struct dmar_atsr_unit *atsru;
+ 	struct acpi_dmar_atsr *atsr;
+ 	struct acpi_dmar_reserved_memory *rmrr;
+ 
+ 	if (!intel_iommu_enabled && system_state != SYSTEM_BOOTING)
+ 		return 0;
+ 
+ 	list_for_each_entry(rmrru, &dmar_rmrr_units, list) {
+ 		rmrr = container_of(rmrru->hdr,
+ 				    struct acpi_dmar_reserved_memory, header);
+ 		if (info->event == BUS_NOTIFY_ADD_DEVICE) {
+ 			ret = dmar_insert_dev_scope(info, (void *)(rmrr + 1),
+ 				((void *)rmrr) + rmrr->header.length,
+ 				rmrr->segment, rmrru->devices,
+ 				rmrru->devices_cnt);
+ 			if(ret < 0)
+ 				return ret;
+ 		} else if (info->event == BUS_NOTIFY_DEL_DEVICE) {
+ 			dmar_remove_dev_scope(info, rmrr->segment,
+ 				rmrru->devices, rmrru->devices_cnt);
+ 		}
+ 	}
+ 
+ 	list_for_each_entry(atsru, &dmar_atsr_units, list) {
+ 		if (atsru->include_all)
+ 			continue;
+ 
+ 		atsr = container_of(atsru->hdr, struct acpi_dmar_atsr, header);
+ 		if (info->event == BUS_NOTIFY_ADD_DEVICE) {
+ 			ret = dmar_insert_dev_scope(info, (void *)(atsr + 1),
+ 					(void *)atsr + atsr->header.length,
+ 					atsr->segment, atsru->devices,
+ 					atsru->devices_cnt);
+ 			if (ret > 0)
+ 				break;
+ 			else if(ret < 0)
+ 				return ret;
+ 		} else if (info->event == BUS_NOTIFY_DEL_DEVICE) {
+ 			if (dmar_remove_dev_scope(info, atsr->segment,
+ 					atsru->devices, atsru->devices_cnt))
+ 				break;
+ 		}
++>>>>>>> 27e249501ca0 (iommu/vt-d: fix bug in handling multiple RMRRs for the same PCI device)
  	}
  
  	return 0;
* Unmerged path drivers/iommu/intel-iommu.c
