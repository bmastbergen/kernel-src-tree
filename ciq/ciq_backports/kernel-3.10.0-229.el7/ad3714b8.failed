xfs: dquot recovery needs verifiers

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Dave Chinner <dchinner@redhat.com>
commit ad3714b82c631a34724da09a7daa53afcab952fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/ad3714b8.failed

dquot recovery should add verifiers to the dquot buffers that it
recovers changes into. Unfortunately, it doesn't attached the
verifiers to the buffers in a consistent manner. For example,
xlog_recover_dquot_pass2() reads dquot buffers without a verifier
and then writes it without ever having attached a verifier to the
buffer.

Further, dquot buffer recovery may write a dquot buffer that has not
been modified, or indeed, shoul dbe written because quotas are not
enabled and hence changes to the buffer were not replayed. In this
case, we again write buffers without verifiers attached because that
doesn't happen until after the buffer changes have been replayed.

	Signed-off-by: Dave Chinner <dchinner@redhat.com>
	Reviewed-by: Brian Foster <bfoster@redhat.com>
	Signed-off-by: Dave Chinner <david@fromorbit.com>

(cherry picked from commit ad3714b82c631a34724da09a7daa53afcab952fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/xfs/xfs_log_recover.c
diff --cc fs/xfs/xfs_log_recover.c
index eb26418814fe,1fd5787add99..000000000000
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@@ -3016,12 -3026,19 +3023,19 @@@ xlog_recover_dquot_pass2
  	error = xfs_dqcheck(mp, recddq, dq_f->qlf_id, 0, XFS_QMOPT_DOWARN,
  			   "xlog_recover_dquot_pass2 (log copy)");
  	if (error)
 -		return -EIO;
 +		return XFS_ERROR(EIO);
  	ASSERT(dq_f->qlf_len == 1);
  
+ 	/*
+ 	 * At this point we are assuming that the dquots have been allocated
+ 	 * and hence the buffer has valid dquots stamped in it. It should,
+ 	 * therefore, pass verifier validation. If the dquot is bad, then the
+ 	 * we'll return an error here, so we don't need to specifically check
+ 	 * the dquot in the buffer after the verifier has run.
+ 	 */
  	error = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp, dq_f->qlf_blkno,
  				   XFS_FSB_TO_BB(mp, dq_f->qlf_len), 0, &bp,
- 				   NULL);
+ 				   &xfs_dquot_buf_ops);
  	if (error)
  		return error;
  
@@@ -3029,18 -3046,6 +3043,21 @@@
  	ddq = (xfs_disk_dquot_t *)xfs_buf_offset(bp, dq_f->qlf_boffset);
  
  	/*
++<<<<<<< HEAD
 +	 * At least the magic num portion should be on disk because this
 +	 * was among a chunk of dquots created earlier, and we did some
 +	 * minimal initialization then.
 +	 */
 +	error = xfs_dqcheck(mp, ddq, dq_f->qlf_id, 0, XFS_QMOPT_DOWARN,
 +			   "xlog_recover_dquot_pass2");
 +	if (error) {
 +		xfs_buf_relse(bp);
 +		return XFS_ERROR(EIO);
 +	}
 +
 +	/*
++=======
++>>>>>>> ad3714b82c63 (xfs: dquot recovery needs verifiers)
  	 * If the dquot has an LSN in it, recover the dquot only if it's less
  	 * than the lsn of the transaction we are replaying.
  	 */
* Unmerged path fs/xfs/xfs_log_recover.c
