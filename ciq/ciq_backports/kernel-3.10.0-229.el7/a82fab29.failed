cpufreq: Introduce a flag ('frozen') to separate full vs temporary init/teardown

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Introduce a flag ('frozen') to separate full vs temporary init/teardown (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 94.04%
commit-author Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
commit a82fab292898f88ea9ca99dd10c1773dcada08b6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/a82fab29.failed

During suspend/resume we would like to do a light-weight init/teardown of
CPUs in the cpufreq subsystem and preserve certain things such as sysfs files
etc across suspend/resume transitions. Add a flag called 'frozen' to help
distinguish the full init/teardown sequence from the light-weight one.

	Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit a82fab292898f88ea9ca99dd10c1773dcada08b6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index 04f364d37cba,1d041aff4d48..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -904,23 -931,54 +904,73 @@@ static int cpufreq_add_policy_cpu(unsig
  		__cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
  	}
  
++<<<<<<< HEAD
 +	ret = sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");
 +
 +	cpufreq_cpu_put(policy);
++=======
+ 	/* Don't touch sysfs links during light-weight init */
+ 	if (frozen) {
+ 		/* Drop the extra refcount that we took above */
+ 		cpufreq_cpu_put(policy);
+ 		return 0;
+ 	}
+ 
+ 	ret = sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");
+ 	if (ret)
+ 		cpufreq_cpu_put(policy);
+ 
++>>>>>>> a82fab292898 (cpufreq: Introduce a flag ('frozen') to separate full vs temporary init/teardown)
  	return ret;
  }
  #endif
  
++<<<<<<< HEAD
 +/**
 + * cpufreq_add_dev - add a CPU device
 + *
 + * Adds the cpufreq interface for a CPU device.
 + *
 + * The Oracle says: try running cpufreq registration/unregistration concurrently
 + * with with cpu hotplugging and all hell will break loose. Tried to clean this
 + * mess up, but more thorough testing is needed. - Mathieu
 + */
 +static int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)
++=======
+ static struct cpufreq_policy *cpufreq_policy_alloc(void)
+ {
+ 	struct cpufreq_policy *policy;
+ 
+ 	policy = kzalloc(sizeof(*policy), GFP_KERNEL);
+ 	if (!policy)
+ 		return NULL;
+ 
+ 	if (!alloc_cpumask_var(&policy->cpus, GFP_KERNEL))
+ 		goto err_free_policy;
+ 
+ 	if (!zalloc_cpumask_var(&policy->related_cpus, GFP_KERNEL))
+ 		goto err_free_cpumask;
+ 
+ 	return policy;
+ 
+ err_free_cpumask:
+ 	free_cpumask_var(policy->cpus);
+ err_free_policy:
+ 	kfree(policy);
+ 
+ 	return NULL;
+ }
+ 
+ static void cpufreq_policy_free(struct cpufreq_policy *policy)
+ {
+ 	free_cpumask_var(policy->related_cpus);
+ 	free_cpumask_var(policy->cpus);
+ 	kfree(policy);
+ }
+ 
+ static int __cpufreq_add_dev(struct device *dev, struct subsys_interface *sif,
+ 			     bool frozen)
++>>>>>>> a82fab292898 (cpufreq: Introduce a flag ('frozen') to separate full vs temporary init/teardown)
  {
  	unsigned int j, cpu = dev->id;
  	int ret = -ENOMEM;
@@@ -955,9 -1010,8 +1005,14 @@@
  		struct cpufreq_policy *cp = per_cpu(cpufreq_cpu_data, sibling);
  		if (cp && cpumask_test_cpu(cpu, cp->related_cpus)) {
  			read_unlock_irqrestore(&cpufreq_driver_lock, flags);
++<<<<<<< HEAD
 +			ret = cpufreq_add_policy_cpu(cpu, sibling, dev);
 +			up_read(&cpufreq_rwsem);
 +			return ret;
++=======
+ 			return cpufreq_add_policy_cpu(cpu, sibling, dev,
+ 						      frozen);
++>>>>>>> a82fab292898 (cpufreq: Introduce a flag ('frozen') to separate full vs temporary init/teardown)
  		}
  	}
  	read_unlock_irqrestore(&cpufreq_driver_lock, flags);
* Unmerged path drivers/cpufreq/cpufreq.c
