cpufreq: Convert existing drivers to use cpufreq_freq_transition_{begin|end}

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Convert existing drivers to use cpufreq_freq_transition_{begin|end} (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 93.71%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 8fec051eea736ec1d8060a2c8766bf3a6b32c3d2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/8fec051e.failed

CPUFreq core has new infrastructure that would guarantee serialized calls to
target() or target_index() callbacks. These are called
cpufreq_freq_transition_begin() and cpufreq_freq_transition_end().

This patch converts existing drivers to use these new set of routines.

	Reviewed-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 8fec051eea736ec1d8060a2c8766bf3a6b32c3d2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
#	drivers/cpufreq/pcc-cpufreq.c
#	drivers/cpufreq/powernow-k7.c
#	drivers/cpufreq/powernow-k8.c
#	drivers/cpufreq/unicore2-cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index c8bc717e8458,eb562d043412..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -1610,7 -1834,53 +1610,51 @@@ int __cpufreq_driver_target(struct cpuf
  
  	if (cpufreq_driver->target)
  		retval = cpufreq_driver->target(policy, target_freq, relation);
 -	else if (cpufreq_driver->target_index) {
 -		struct cpufreq_frequency_table *freq_table;
 -		struct cpufreq_freqs freqs;
 -		bool notify;
 -		int index;
  
++<<<<<<< HEAD
++=======
+ 		freq_table = cpufreq_frequency_get_table(policy->cpu);
+ 		if (unlikely(!freq_table)) {
+ 			pr_err("%s: Unable to find freq_table\n", __func__);
+ 			goto out;
+ 		}
+ 
+ 		retval = cpufreq_frequency_table_target(policy, freq_table,
+ 				target_freq, relation, &index);
+ 		if (unlikely(retval)) {
+ 			pr_err("%s: Unable to find matching freq\n", __func__);
+ 			goto out;
+ 		}
+ 
+ 		if (freq_table[index].frequency == policy->cur) {
+ 			retval = 0;
+ 			goto out;
+ 		}
+ 
+ 		notify = !(cpufreq_driver->flags & CPUFREQ_ASYNC_NOTIFICATION);
+ 
+ 		if (notify) {
+ 			freqs.old = policy->cur;
+ 			freqs.new = freq_table[index].frequency;
+ 			freqs.flags = 0;
+ 
+ 			pr_debug("%s: cpu: %d, oldfreq: %u, new freq: %u\n",
+ 				 __func__, policy->cpu, freqs.old, freqs.new);
+ 
+ 			cpufreq_freq_transition_begin(policy, &freqs);
+ 		}
+ 
+ 		retval = cpufreq_driver->target_index(policy, index);
+ 		if (retval)
+ 			pr_err("%s: Failed to change cpu frequency: %d\n",
+ 			       __func__, retval);
+ 
+ 		if (notify)
+ 			cpufreq_freq_transition_end(policy, &freqs, retval);
+ 	}
+ 
+ out:
++>>>>>>> 8fec051eea73 (cpufreq: Convert existing drivers to use cpufreq_freq_transition_{begin|end})
  	return retval;
  }
  EXPORT_SYMBOL_GPL(__cpufreq_driver_target);
diff --cc drivers/cpufreq/pcc-cpufreq.c
index 1a306ce8f1de,728a2d879499..000000000000
--- a/drivers/cpufreq/pcc-cpufreq.c
+++ b/drivers/cpufreq/pcc-cpufreq.c
@@@ -213,8 -213,9 +213,8 @@@ static int pcc_cpufreq_target(struct cp
  		cpu, target_freq,
  		(pcch_virt_addr + pcc_cpu_data->input_offset));
  
 -	freqs.old = policy->cur;
  	freqs.new = target_freq;
- 	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
+ 	cpufreq_freq_transition_begin(policy, &freqs);
  
  	input_buffer = 0x1 | (((target_freq * 100)
  			       / (ioread32(&pcch_hdr->nominal) * 1000)) << 8);
@@@ -228,6 -229,11 +228,14 @@@
  	memset_io((pcch_virt_addr + pcc_cpu_data->input_offset), 0, BUF_SZ);
  
  	status = ioread16(&pcch_hdr->status);
++<<<<<<< HEAD
++=======
+ 	iowrite16(0, &pcch_hdr->status);
+ 
+ 	cpufreq_freq_transition_end(policy, &freqs, status != CMD_COMPLETE);
+ 	spin_unlock(&pcc_lock);
+ 
++>>>>>>> 8fec051eea73 (cpufreq: Convert existing drivers to use cpufreq_freq_transition_{begin|end})
  	if (status != CMD_COMPLETE) {
  		pr_debug("target: FAILED for cpu %d, with status: 0x%x\n",
  			cpu, status);
diff --cc drivers/cpufreq/powernow-k7.c
index e369f59f7aa1,f911645c3f6d..000000000000
--- a/drivers/cpufreq/powernow-k7.c
+++ b/drivers/cpufreq/powernow-k7.c
@@@ -290,7 -290,9 +290,13 @@@ static void change_speed(struct cpufreq
  	if (have_a0 == 1)
  		local_irq_enable();
  
++<<<<<<< HEAD
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
++=======
+ 	cpufreq_freq_transition_end(policy, &freqs, 0);
+ 
+ 	return 0;
++>>>>>>> 8fec051eea73 (cpufreq: Convert existing drivers to use cpufreq_freq_transition_{begin|end})
  }
  
  
diff --cc drivers/cpufreq/powernow-k8.c
index 0895590c15f4,770a9e1b3468..000000000000
--- a/drivers/cpufreq/powernow-k8.c
+++ b/drivers/cpufreq/powernow-k8.c
@@@ -963,15 -963,10 +963,21 @@@ static int transition_frequency_fidvid(
  	policy = cpufreq_cpu_get(smp_processor_id());
  	cpufreq_cpu_put(policy);
  
++<<<<<<< HEAD
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
++=======
+ 	cpufreq_freq_transition_begin(policy, &freqs);
+ 	res = transition_fid_vid(data, fid, vid);
+ 	cpufreq_freq_transition_end(policy, &freqs, res);
++>>>>>>> 8fec051eea73 (cpufreq: Convert existing drivers to use cpufreq_freq_transition_{begin|end})
  
 +	res = transition_fid_vid(data, fid, vid);
 +	if (res)
 +		freqs.new = freqs.old;
 +	else
 +		freqs.new = find_khz_freq_from_fid(data->currfid);
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
  	return res;
  }
  
diff --cc drivers/cpufreq/unicore2-cpufreq.c
index 6e56ae0997e2,13be802b6170..000000000000
--- a/drivers/cpufreq/unicore2-cpufreq.c
+++ b/drivers/cpufreq/unicore2-cpufreq.c
@@@ -46,20 -38,17 +46,26 @@@ static int ucv2_target(struct cpufreq_p
  			 unsigned int target_freq,
  			 unsigned int relation)
  {
 +	unsigned int cur = ucv2_getspeed(0);
  	struct cpufreq_freqs freqs;
 -	int ret;
 -
 -	freqs.old = policy->cur;
 -	freqs.new = target_freq;
 +	struct clk *mclk = clk_get(NULL, "MAIN_CLK");
  
++<<<<<<< HEAD
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
++=======
+ 	cpufreq_freq_transition_begin(policy, &freqs);
+ 	ret = clk_set_rate(policy->mclk, target_freq * 1000);
+ 	cpufreq_freq_transition_end(policy, &freqs, ret);
++>>>>>>> 8fec051eea73 (cpufreq: Convert existing drivers to use cpufreq_freq_transition_{begin|end})
  
 -	return ret;
 +	if (!clk_set_rate(mclk, target_freq * 1000)) {
 +		freqs.old = cur;
 +		freqs.new = target_freq;
 +	}
 +
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
 +
 +	return 0;
  }
  
  static int __init ucv2_cpu_init(struct cpufreq_policy *policy)
diff --git a/arch/arm/mach-s3c24xx/cpufreq.c b/arch/arm/mach-s3c24xx/cpufreq.c
index 3c0e78ede0da..27904c800b97 100644
--- a/arch/arm/mach-s3c24xx/cpufreq.c
+++ b/arch/arm/mach-s3c24xx/cpufreq.c
@@ -217,7 +217,7 @@ static int s3c_cpufreq_settarget(struct cpufreq_policy *policy,
 	s3c_cpufreq_updateclk(clk_pclk, cpu_new.freq.pclk);
 
 	/* start the frequency change */
-	cpufreq_notify_transition(policy, &freqs.freqs, CPUFREQ_PRECHANGE);
+	cpufreq_freq_transition_begin(policy, &freqs.freqs);
 
 	/* If hclk is staying the same, then we do not need to
 	 * re-write the IO or the refresh timings whilst we are changing
@@ -261,7 +261,7 @@ static int s3c_cpufreq_settarget(struct cpufreq_policy *policy,
 	local_irq_restore(flags);
 
 	/* notify everyone we've done this */
-	cpufreq_notify_transition(policy, &freqs.freqs, CPUFREQ_POSTCHANGE);
+	cpufreq_freq_transition_end(policy, &freqs.freqs, 0);
 
 	s3c_freq_dbg("%s: finished\n", __func__);
 	return 0;
diff --git a/drivers/cpufreq/cpufreq-nforce2.c b/drivers/cpufreq/cpufreq-nforce2.c
index 09227d9dc060..0835baeaf33f 100644
--- a/drivers/cpufreq/cpufreq-nforce2.c
+++ b/drivers/cpufreq/cpufreq-nforce2.c
@@ -270,7 +270,7 @@ static int nforce2_target(struct cpufreq_policy *policy,
 	pr_debug("Old CPU frequency %d kHz, new %d kHz\n",
 	       freqs.old, freqs.new);
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
+	cpufreq_freq_transition_begin(policy, &freqs);
 
 	/* Disable IRQs */
 	/* local_irq_save(flags); */
@@ -285,7 +285,7 @@ static int nforce2_target(struct cpufreq_policy *policy,
 	/* Enable IRQs */
 	/* local_irq_restore(flags); */
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
+	cpufreq_freq_transition_end(policy, &freqs, 0);
 
 	return 0;
 }
* Unmerged path drivers/cpufreq/cpufreq.c
diff --git a/drivers/cpufreq/exynos5440-cpufreq.c b/drivers/cpufreq/exynos5440-cpufreq.c
index 0c74018eda47..bc3e0bccc864 100644
--- a/drivers/cpufreq/exynos5440-cpufreq.c
+++ b/drivers/cpufreq/exynos5440-cpufreq.c
@@ -238,7 +238,7 @@ static int exynos_target(struct cpufreq_policy *policy,
 	freqs.old = dvfs_info->cur_frequency;
 	freqs.new = freq_table[index].frequency;
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
+	cpufreq_freq_transition_begin(policy, &freqs);
 
 	/* Set the target frequency in all C0_3_PSTATE register */
 	for_each_cpu(i, policy->cpus) {
@@ -279,7 +279,7 @@ static void exynos_cpufreq_work(struct work_struct *work)
 		dev_crit(dvfs_info->dev, "New frequency out of range\n");
 		freqs.new = dvfs_info->cur_frequency;
 	}
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
+	cpufreq_freq_transition_end(policy, &freqs, 0);
 
 	cpufreq_cpu_put(policy);
 	mutex_unlock(&cpufreq_lock);
diff --git a/drivers/cpufreq/gx-suspmod.c b/drivers/cpufreq/gx-suspmod.c
index 3dfc99b9ca86..20e1600f8fd5 100644
--- a/drivers/cpufreq/gx-suspmod.c
+++ b/drivers/cpufreq/gx-suspmod.c
@@ -265,7 +265,7 @@ static void gx_set_cpuspeed(struct cpufreq_policy *policy, unsigned int khz)
 
 	freqs.new = new_khz;
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
+	cpufreq_freq_transition_begin(policy, &freqs);
 	local_irq_save(flags);
 
 	if (new_khz != stock_freq) {
@@ -314,7 +314,7 @@ static void gx_set_cpuspeed(struct cpufreq_policy *policy, unsigned int khz)
 
 	gx_params->pci_suscfg = suscfg;
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
+	cpufreq_freq_transition_end(policy, &freqs, 0);
 
 	pr_debug("suspend modulation w/ duration of ON:%d us, OFF:%d us\n",
 		gx_params->on_duration * 32, gx_params->off_duration * 32);
diff --git a/drivers/cpufreq/integrator-cpufreq.c b/drivers/cpufreq/integrator-cpufreq.c
index 8152a9bb7e2c..d6e758d60cf0 100644
--- a/drivers/cpufreq/integrator-cpufreq.c
+++ b/drivers/cpufreq/integrator-cpufreq.c
@@ -121,7 +121,7 @@ static int integrator_set_target(struct cpufreq_policy *policy,
 		return 0;
 	}
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
+	cpufreq_freq_transition_begin(policy, &freqs);
 
 	cm_osc = __raw_readl(CM_OSC);
 
@@ -142,7 +142,7 @@ static int integrator_set_target(struct cpufreq_policy *policy,
 	 */
 	set_cpus_allowed(current, cpus_allowed);
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
+	cpufreq_freq_transition_end(policy, &freqs, 0);
 
 	return 0;
 }
diff --git a/drivers/cpufreq/longhaul.c b/drivers/cpufreq/longhaul.c
index 51a0420c0c78..07f0a2dfb32d 100644
--- a/drivers/cpufreq/longhaul.c
+++ b/drivers/cpufreq/longhaul.c
@@ -269,7 +269,7 @@ static void longhaul_setstate(struct cpufreq_policy *policy,
 	freqs.old = calc_speed(longhaul_get_cpu_mult());
 	freqs.new = speed;
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
+	cpufreq_freq_transition_begin(policy, &freqs);
 
 	pr_debug("Setting to FSB:%dMHz Mult:%d.%dx (%s)\n",
 			fsb, mult/10, mult%10, print_speed(speed/1000));
@@ -386,7 +386,7 @@ retry_loop:
 		}
 	}
 	/* Report true CPU frequency */
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
+	cpufreq_freq_transition_end(policy, &freqs, 0);
 
 	if (!bm_timeout)
 		printk(KERN_INFO PFX "Warning: Timeout while waiting for "
* Unmerged path drivers/cpufreq/pcc-cpufreq.c
diff --git a/drivers/cpufreq/powernow-k6.c b/drivers/cpufreq/powernow-k6.c
index a5b23da513dc..d34ab66c5b85 100644
--- a/drivers/cpufreq/powernow-k6.c
+++ b/drivers/cpufreq/powernow-k6.c
@@ -83,7 +83,7 @@ static void powernow_k6_set_state(struct cpufreq_policy *policy,
 	freqs.old = busfreq * powernow_k6_get_cpu_multiplier();
 	freqs.new = busfreq * clock_ratio[best_i].driver_data;
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
+	cpufreq_freq_transition_begin(policy, &freqs);
 
 	/* we now need to transform best_i to the BVC format, see AMD#23446 */
 
@@ -98,7 +98,7 @@ static void powernow_k6_set_state(struct cpufreq_policy *policy,
 	msrval = POWERNOW_IOPORT + 0x0;
 	wrmsr(MSR_K6_EPMR, msrval, 0); /* disable it again */
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
+	cpufreq_freq_transition_end(policy, &freqs, 0);
 
 	return;
 }
* Unmerged path drivers/cpufreq/powernow-k7.c
* Unmerged path drivers/cpufreq/powernow-k8.c
diff --git a/drivers/cpufreq/sh-cpufreq.c b/drivers/cpufreq/sh-cpufreq.c
index bf6083325a6f..19f897713069 100644
--- a/drivers/cpufreq/sh-cpufreq.c
+++ b/drivers/cpufreq/sh-cpufreq.c
@@ -68,10 +68,10 @@ static int sh_cpufreq_target(struct cpufreq_policy *policy,
 	freqs.new	= (freq + 500) / 1000;
 	freqs.flags	= 0;
 
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_PRECHANGE);
+	cpufreq_freq_transition_begin(policy, &freqs);
 	set_cpus_allowed_ptr(current, &cpus_allowed);
 	clk_set_rate(cpuclk, freq);
-	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
+	cpufreq_freq_transition_end(policy, &freqs, 0);
 
 	dev_dbg(dev, "set frequency %lu Hz\n", freq);
 
* Unmerged path drivers/cpufreq/unicore2-cpufreq.c
