usb: quiet peer failure warning, disable poweroff

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [usb] quiet peer failure warning, disable poweroff (Don Zickus) [1110939]
Rebuild_FUZZ: 94.62%
commit-author Dan Williams <dan.j.williams@intel.com>
commit 6c79fe4afcb0450bd638f6e959e512aad270ff2f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/6c79fe4a.failed

In the case where platform firmware has specified conflicting values for
port locations it is confusing and otherwise not helpful to throw a
backtrace.  Instead, include enough information to determine that
firmware has done something wrong and globally disable port poweroff.

	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 6c79fe4afcb0450bd638f6e959e512aad270ff2f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/core/port.c
diff --cc drivers/usb/core/port.c
index 7cfc3c98920d,9347ade7d5fe..000000000000
--- a/drivers/usb/core/port.c
+++ b/drivers/usb/core/port.c
@@@ -127,8 -144,10 +129,11 @@@ static int usb_port_runtime_suspend(str
  			== PM_QOS_FLAGS_ALL)
  		return -EAGAIN;
  
+ 	if (usb_port_block_power_off)
+ 		return -EBUSY;
+ 
  	usb_autopm_get_interface(intf);
 +	set_bit(port1, hub->busy_bits);
  	retval = usb_hub_set_port_power(hdev, hub, port1, false);
  	usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);
  	if (!port_dev->is_superspeed)
@@@ -152,9 -179,224 +157,227 @@@ struct device_type usb_port_device_typ
  	.pm =		&usb_port_pm_ops,
  };
  
++<<<<<<< HEAD
++=======
+ static struct device_driver usb_port_driver = {
+ 	.name = "usb",
+ 	.owner = THIS_MODULE,
+ };
+ 
+ static int link_peers(struct usb_port *left, struct usb_port *right)
+ {
+ 	struct usb_port *ss_port, *hs_port;
+ 	int rc;
+ 
+ 	if (left->peer == right && right->peer == left)
+ 		return 0;
+ 
+ 	if (left->peer || right->peer) {
+ 		struct usb_port *lpeer = left->peer;
+ 		struct usb_port *rpeer = right->peer;
+ 		char *method;
+ 
+ 		if (left->location && left->location == right->location)
+ 			method = "location";
+ 		else
+ 			method = "default";
+ 
+ 		pr_warn("usb: failed to peer %s and %s by %s (%s:%s) (%s:%s)\n",
+ 			dev_name(&left->dev), dev_name(&right->dev), method,
+ 			dev_name(&left->dev),
+ 			lpeer ? dev_name(&lpeer->dev) : "none",
+ 			dev_name(&right->dev),
+ 			rpeer ? dev_name(&rpeer->dev) : "none");
+ 		return -EBUSY;
+ 	}
+ 
+ 	rc = sysfs_create_link(&left->dev.kobj, &right->dev.kobj, "peer");
+ 	if (rc)
+ 		return rc;
+ 	rc = sysfs_create_link(&right->dev.kobj, &left->dev.kobj, "peer");
+ 	if (rc) {
+ 		sysfs_remove_link(&left->dev.kobj, "peer");
+ 		return rc;
+ 	}
+ 
+ 	/*
+ 	 * We need to wake the HiSpeed port to make sure we don't race
+ 	 * setting ->peer with usb_port_runtime_suspend().  Otherwise we
+ 	 * may miss a suspend event for the SuperSpeed port.
+ 	 */
+ 	if (left->is_superspeed) {
+ 		ss_port = left;
+ 		WARN_ON(right->is_superspeed);
+ 		hs_port = right;
+ 	} else {
+ 		ss_port = right;
+ 		WARN_ON(!right->is_superspeed);
+ 		hs_port = left;
+ 	}
+ 	pm_runtime_get_sync(&hs_port->dev);
+ 
+ 	left->peer = right;
+ 	right->peer = left;
+ 
+ 	/*
+ 	 * The SuperSpeed reference is dropped when the HiSpeed port in
+ 	 * this relationship suspends, i.e. when it is safe to allow a
+ 	 * SuperSpeed connection to drop since there is no risk of a
+ 	 * device degrading to its powered-off HiSpeed connection.
+ 	 *
+ 	 * Also, drop the HiSpeed ref taken above.
+ 	 */
+ 	pm_runtime_get_sync(&ss_port->dev);
+ 	pm_runtime_put(&hs_port->dev);
+ 
+ 	return 0;
+ }
+ 
+ static void link_peers_report(struct usb_port *left, struct usb_port *right)
+ {
+ 	int rc;
+ 
+ 	rc = link_peers(left, right);
+ 	if (rc == 0) {
+ 		dev_dbg(&left->dev, "peered to %s\n", dev_name(&right->dev));
+ 	} else {
+ 		dev_warn(&left->dev, "failed to peer to %s (%d)\n",
+ 				dev_name(&right->dev), rc);
+ 		pr_warn_once("usb: port power management may be unreliable\n");
+ 		usb_port_block_power_off = 1;
+ 	}
+ }
+ 
+ static void unlink_peers(struct usb_port *left, struct usb_port *right)
+ {
+ 	struct usb_port *ss_port, *hs_port;
+ 
+ 	WARN(right->peer != left || left->peer != right,
+ 			"%s and %s are not peers?\n",
+ 			dev_name(&left->dev), dev_name(&right->dev));
+ 
+ 	/*
+ 	 * We wake the HiSpeed port to make sure we don't race its
+ 	 * usb_port_runtime_resume() event which takes a SuperSpeed ref
+ 	 * when ->peer is !NULL.
+ 	 */
+ 	if (left->is_superspeed) {
+ 		ss_port = left;
+ 		hs_port = right;
+ 	} else {
+ 		ss_port = right;
+ 		hs_port = left;
+ 	}
+ 
+ 	pm_runtime_get_sync(&hs_port->dev);
+ 
+ 	sysfs_remove_link(&left->dev.kobj, "peer");
+ 	right->peer = NULL;
+ 	sysfs_remove_link(&right->dev.kobj, "peer");
+ 	left->peer = NULL;
+ 
+ 	/* Drop the SuperSpeed ref held on behalf of the active HiSpeed port */
+ 	pm_runtime_put(&ss_port->dev);
+ 
+ 	/* Drop the ref taken above */
+ 	pm_runtime_put(&hs_port->dev);
+ }
+ 
+ /*
+  * For each usb hub device in the system check to see if it is in the
+  * peer domain of the given port_dev, and if it is check to see if it
+  * has a port that matches the given port by location
+  */
+ static int match_location(struct usb_device *peer_hdev, void *p)
+ {
+ 	int port1;
+ 	struct usb_hcd *hcd, *peer_hcd;
+ 	struct usb_port *port_dev = p, *peer;
+ 	struct usb_hub *peer_hub = usb_hub_to_struct_hub(peer_hdev);
+ 	struct usb_device *hdev = to_usb_device(port_dev->dev.parent->parent);
+ 
+ 	if (!peer_hub)
+ 		return 0;
+ 
+ 	hcd = bus_to_hcd(hdev->bus);
+ 	peer_hcd = bus_to_hcd(peer_hdev->bus);
+ 	/* peer_hcd is provisional until we verify it against the known peer */
+ 	if (peer_hcd != hcd->shared_hcd)
+ 		return 0;
+ 
+ 	for (port1 = 1; port1 <= peer_hdev->maxchild; port1++) {
+ 		peer = peer_hub->ports[port1 - 1];
+ 		if (peer && peer->location == port_dev->location) {
+ 			link_peers_report(port_dev, peer);
+ 			return 1; /* done */
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * Find the peer port either via explicit platform firmware "location"
+  * data, the peer hcd for root hubs, or the upstream peer relationship
+  * for all other hubs.
+  */
+ static void find_and_link_peer(struct usb_hub *hub, int port1)
+ {
+ 	struct usb_port *port_dev = hub->ports[port1 - 1], *peer;
+ 	struct usb_device *hdev = hub->hdev;
+ 	struct usb_device *peer_hdev;
+ 	struct usb_hub *peer_hub;
+ 
+ 	/*
+ 	 * If location data is available then we can only peer this port
+ 	 * by a location match, not the default peer (lest we create a
+ 	 * situation where we need to go back and undo a default peering
+ 	 * when the port is later peered by location data)
+ 	 */
+ 	if (port_dev->location) {
+ 		/* we link the peer in match_location() if found */
+ 		usb_for_each_dev(port_dev, match_location);
+ 		return;
+ 	} else if (!hdev->parent) {
+ 		struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
+ 		struct usb_hcd *peer_hcd = hcd->shared_hcd;
+ 
+ 		if (!peer_hcd)
+ 			return;
+ 
+ 		peer_hdev = peer_hcd->self.root_hub;
+ 	} else {
+ 		struct usb_port *upstream;
+ 		struct usb_device *parent = hdev->parent;
+ 		struct usb_hub *parent_hub = usb_hub_to_struct_hub(parent);
+ 
+ 		if (!parent_hub)
+ 			return;
+ 
+ 		upstream = parent_hub->ports[hdev->portnum - 1];
+ 		if (!upstream || !upstream->peer)
+ 			return;
+ 
+ 		peer_hdev = upstream->peer->child;
+ 	}
+ 
+ 	peer_hub = usb_hub_to_struct_hub(peer_hdev);
+ 	if (!peer_hub || port1 > peer_hdev->maxchild)
+ 		return;
+ 
+ 	/*
+ 	 * we found a valid default peer, last check is to make sure it
+ 	 * does not have location data
+ 	 */
+ 	peer = peer_hub->ports[port1 - 1];
+ 	if (peer && peer->location == 0)
+ 		link_peers_report(port_dev, peer);
+ }
+ 
++>>>>>>> 6c79fe4afcb0 (usb: quiet peer failure warning, disable poweroff)
  int usb_hub_create_port_device(struct usb_hub *hub, int port1)
  {
 -	struct usb_port *port_dev;
 +	struct usb_port *port_dev = NULL;
  	int retval;
  
  	port_dev = kzalloc(sizeof(*port_dev), GFP_KERNEL);
* Unmerged path drivers/usb/core/port.c
