net: sctp: only warn in proc_sctp_do_alpha_beta if write

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] sctp: only warn in proc_sctp_do_alpha_beta if write (Daniel Borkmann) [1110290]
Rebuild_FUZZ: 95.33%
commit-author Daniel Borkmann <dborkman@redhat.com>
commit eaea2da7286ebc56d557b40ad7e59e715a84e4a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/eaea2da7.failed

Only warn if the value is written to alpha or beta. We don't care
emitting a one-time warning when only reading it.

	Reported-by: Jiri Pirko <jpirko@redhat.com>
	Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
	Reviewed-by: Jiri Pirko <jiri@resnulli.us>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit eaea2da7286ebc56d557b40ad7e59e715a84e4a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/sysctl.c
diff --cc net/sctp/sysctl.c
index 5a83d52bc795,2e9ada10fd84..000000000000
--- a/net/sctp/sysctl.c
+++ b/net/sctp/sysctl.c
@@@ -410,6 -420,47 +410,50 @@@ static int proc_sctp_do_rto_max(struct 
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ static int proc_sctp_do_alpha_beta(struct ctl_table *ctl, int write,
+ 				   void __user *buffer, size_t *lenp,
+ 				   loff_t *ppos)
+ {
+ 	if (write)
+ 		pr_warn_once("Changing rto_alpha or rto_beta may lead to "
+ 			     "suboptimal rtt/srtt estimations!\n");
+ 
+ 	return proc_dointvec_minmax(ctl, write, buffer, lenp, ppos);
+ }
+ 
+ static int proc_sctp_do_auth(struct ctl_table *ctl, int write,
+ 			     void __user *buffer, size_t *lenp,
+ 			     loff_t *ppos)
+ {
+ 	struct net *net = current->nsproxy->net_ns;
+ 	struct ctl_table tbl;
+ 	int new_value, ret;
+ 
+ 	memset(&tbl, 0, sizeof(struct ctl_table));
+ 	tbl.maxlen = sizeof(unsigned int);
+ 
+ 	if (write)
+ 		tbl.data = &new_value;
+ 	else
+ 		tbl.data = &net->sctp.auth_enable;
+ 
+ 	ret = proc_dointvec(&tbl, write, buffer, lenp, ppos);
+ 	if (write && ret == 0) {
+ 		struct sock *sk = net->sctp.ctl_sock;
+ 
+ 		net->sctp.auth_enable = new_value;
+ 		/* Update the value in the control socket */
+ 		lock_sock(sk);
+ 		sctp_sk(sk)->ep->auth_enable = new_value;
+ 		release_sock(sk);
+ 	}
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> eaea2da7286e (net: sctp: only warn in proc_sctp_do_alpha_beta if write)
  int sctp_sysctl_net_register(struct net *net)
  {
  	struct ctl_table *table;
* Unmerged path net/sctp/sysctl.c
