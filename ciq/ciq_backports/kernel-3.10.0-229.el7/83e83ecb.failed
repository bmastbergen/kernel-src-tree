usb: core: get config and string descriptors for unauthorized devices

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [usb] core: get config and string descriptors for unauthorized devices (Don Zickus) [1110939]
Rebuild_FUZZ: 96.24%
commit-author Thomas Pugliese <thomas.pugliese@gmail.com>
commit 83e83ecb79a8225e79bc8e54e9aff3e0e27658a2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/83e83ecb.failed

There is no need to skip querying the config and string descriptors for
unauthorized WUSB devices when usb_new_device is called.  It is allowed
by WUSB spec.  The only action that needs to be delayed until
authorization time is the set config.  This change allows user mode
tools to see the config and string descriptors earlier in enumeration
which is needed for some WUSB devices to function properly on Android
systems.  It also reduces the amount of divergent code paths needed
for WUSB devices.

	Signed-off-by: Thomas Pugliese <thomas.pugliese@gmail.com>
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 83e83ecb79a8225e79bc8e54e9aff3e0e27658a2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/usb/core/hub.c
diff --cc drivers/usb/core/hub.c
index 99a20850137d,32e1035d4f59..000000000000
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@@ -2235,18 -2235,13 +2235,28 @@@ static int usb_enumerate_device(struct 
  			return err;
  		}
  	}
++<<<<<<< HEAD
 +	if (udev->wusb == 1 && udev->authorized == 0) {
 +		udev->product = kstrdup("n/a (unauthorized)", GFP_KERNEL);
 +		udev->manufacturer = kstrdup("n/a (unauthorized)", GFP_KERNEL);
 +		udev->serial = kstrdup("n/a (unauthorized)", GFP_KERNEL);
 +	}
 +	else {
 +		/* read the standard strings and cache them if present */
 +		udev->product = usb_cache_string(udev, udev->descriptor.iProduct);
 +		udev->manufacturer = usb_cache_string(udev,
 +						      udev->descriptor.iManufacturer);
 +		udev->serial = usb_cache_string(udev, udev->descriptor.iSerialNumber);
 +	}
++=======
+ 
+ 	/* read the standard strings and cache them if present */
+ 	udev->product = usb_cache_string(udev, udev->descriptor.iProduct);
+ 	udev->manufacturer = usb_cache_string(udev,
+ 					      udev->descriptor.iManufacturer);
+ 	udev->serial = usb_cache_string(udev, udev->descriptor.iSerialNumber);
+ 
++>>>>>>> 83e83ecb79a8 (usb: core: get config and string descriptors for unauthorized devices)
  	err = usb_enumerate_device_otg(udev);
  	if (err < 0)
  		return err;
diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c
index a6b2cabe7930..548d1996590f 100644
--- a/drivers/usb/core/config.c
+++ b/drivers/usb/core/config.c
@@ -651,10 +651,6 @@ void usb_destroy_configuration(struct usb_device *dev)
  *
  * hub-only!! ... and only in reset path, or usb_new_device()
  * (used by real hubs and virtual root hubs)
- *
- * NOTE: if this is a WUSB device and is not authorized, we skip the
- *       whole thing. A non-authorized USB device has no
- *       configurations.
  */
 int usb_get_configuration(struct usb_device *dev)
 {
@@ -666,8 +662,6 @@ int usb_get_configuration(struct usb_device *dev)
 	struct usb_config_descriptor *desc;
 
 	cfgno = 0;
-	if (dev->authorized == 0)	/* Not really an error */
-		goto out_not_authorized;
 	result = -ENOMEM;
 	if (ncfg > USB_MAXCONFIG) {
 		dev_warn(ddev, "too many configurations: %d, "
@@ -751,7 +745,6 @@ int usb_get_configuration(struct usb_device *dev)
 
 err:
 	kfree(desc);
-out_not_authorized:
 	dev->descriptor.bNumConfigurations = cfgno;
 err2:
 	if (result == -ENOMEM)
* Unmerged path drivers/usb/core/hub.c
