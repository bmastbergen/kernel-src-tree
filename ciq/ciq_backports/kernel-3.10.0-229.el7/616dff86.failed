KVM: PPC: Book3S PR: Handle Facility interrupt and FSCR

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/ppc: book3s/pr - Handle Facility interrupt and FSCR (David Gibson) [1123145 1123133 1123367]
Rebuild_FUZZ: 92.73%
commit-author Alexander Graf <agraf@suse.de>
commit 616dff86028298dbc91174fb3d12b8ed8cd74955
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/616dff86.failed

POWER8 introduced a new interrupt type called "Facility unavailable interrupt"
which contains its status message in a new register called FSCR.

Handle these exits and try to emulate instructions for unhandled facilities.
Follow-on patches enable KVM to expose specific facilities into the guest.

	Signed-off-by: Alexander Graf <agraf@suse.de>
(cherry picked from commit 616dff86028298dbc91174fb3d12b8ed8cd74955)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/kvm_host.h
#	arch/powerpc/kernel/asm-offsets.c
#	arch/powerpc/kvm/book3s_hv.c
#	arch/powerpc/kvm/book3s_pr.c
diff --cc arch/powerpc/include/asm/kvm_host.h
index db69ef15e5ee,232ec5f0b886..000000000000
--- a/arch/powerpc/include/asm/kvm_host.h
+++ b/arch/powerpc/include/asm/kvm_host.h
@@@ -468,10 -462,28 +468,24 @@@ struct kvm_vcpu_arch 
  	ulong dscr;
  	ulong amr;
  	ulong uamor;
 -	ulong iamr;
  	u32 ctrl;
 -	u32 dabrx;
  	ulong dabr;
 -	ulong dawr;
 -	ulong dawrx;
 -	ulong ciabr;
  	ulong cfar;
  	ulong ppr;
++<<<<<<< HEAD
++=======
+ 	ulong pspb;
+ 	ulong fscr;
+ 	ulong shadow_fscr;
+ 	ulong ebbhr;
+ 	ulong ebbrr;
+ 	ulong bescr;
+ 	ulong csigr;
+ 	ulong tacr;
+ 	ulong tcscr;
+ 	ulong acop;
+ 	ulong wort;
++>>>>>>> 616dff860282 (KVM: PPC: Book3S PR: Handle Facility interrupt and FSCR)
  	ulong shadow_srr1;
  #endif
  	u32 vrsave; /* also USPRG0 */
diff --cc arch/powerpc/kernel/asm-offsets.c
index 79fa5c26d629,e2b86b5c02b3..000000000000
--- a/arch/powerpc/kernel/asm-offsets.c
+++ b/arch/powerpc/kernel/asm-offsets.c
@@@ -509,11 -531,22 +509,25 @@@ int main(void
  	DEFINE(VCPU_SLB_NR, offsetof(struct kvm_vcpu, arch.slb_nr));
  	DEFINE(VCPU_FAULT_DSISR, offsetof(struct kvm_vcpu, arch.fault_dsisr));
  	DEFINE(VCPU_FAULT_DAR, offsetof(struct kvm_vcpu, arch.fault_dar));
 -	DEFINE(VCPU_INTR_MSR, offsetof(struct kvm_vcpu, arch.intr_msr));
  	DEFINE(VCPU_LAST_INST, offsetof(struct kvm_vcpu, arch.last_inst));
  	DEFINE(VCPU_TRAP, offsetof(struct kvm_vcpu, arch.trap));
 +	DEFINE(VCPU_PTID, offsetof(struct kvm_vcpu, arch.ptid));
  	DEFINE(VCPU_CFAR, offsetof(struct kvm_vcpu, arch.cfar));
  	DEFINE(VCPU_PPR, offsetof(struct kvm_vcpu, arch.ppr));
++<<<<<<< HEAD
++=======
+ 	DEFINE(VCPU_FSCR, offsetof(struct kvm_vcpu, arch.fscr));
+ 	DEFINE(VCPU_SHADOW_FSCR, offsetof(struct kvm_vcpu, arch.shadow_fscr));
+ 	DEFINE(VCPU_PSPB, offsetof(struct kvm_vcpu, arch.pspb));
+ 	DEFINE(VCPU_EBBHR, offsetof(struct kvm_vcpu, arch.ebbhr));
+ 	DEFINE(VCPU_EBBRR, offsetof(struct kvm_vcpu, arch.ebbrr));
+ 	DEFINE(VCPU_BESCR, offsetof(struct kvm_vcpu, arch.bescr));
+ 	DEFINE(VCPU_CSIGR, offsetof(struct kvm_vcpu, arch.csigr));
+ 	DEFINE(VCPU_TACR, offsetof(struct kvm_vcpu, arch.tacr));
+ 	DEFINE(VCPU_TCSCR, offsetof(struct kvm_vcpu, arch.tcscr));
+ 	DEFINE(VCPU_ACOP, offsetof(struct kvm_vcpu, arch.acop));
+ 	DEFINE(VCPU_WORT, offsetof(struct kvm_vcpu, arch.wort));
++>>>>>>> 616dff860282 (KVM: PPC: Book3S PR: Handle Facility interrupt and FSCR)
  	DEFINE(VCPU_SHADOW_SRR1, offsetof(struct kvm_vcpu, arch.shadow_srr1));
  	DEFINE(VCORE_ENTRY_EXIT, offsetof(struct kvmppc_vcore, entry_exit_count));
  	DEFINE(VCORE_NAP_COUNT, offsetof(struct kvmppc_vcore, nap_count));
diff --cc arch/powerpc/kvm/book3s_hv.c
index 14588bcd5db5,0092e12b3e46..000000000000
--- a/arch/powerpc/kvm/book3s_hv.c
+++ b/arch/powerpc/kvm/book3s_hv.c
@@@ -836,6 -873,63 +836,66 @@@ int kvmppc_get_one_reg(struct kvm_vcpu 
  	case KVM_REG_PPC_SDAR:
  		*val = get_reg_val(id, vcpu->arch.sdar);
  		break;
++<<<<<<< HEAD
++=======
+ 	case KVM_REG_PPC_SIER:
+ 		*val = get_reg_val(id, vcpu->arch.sier);
+ 		break;
+ 	case KVM_REG_PPC_IAMR:
+ 		*val = get_reg_val(id, vcpu->arch.iamr);
+ 		break;
+ 	case KVM_REG_PPC_PSPB:
+ 		*val = get_reg_val(id, vcpu->arch.pspb);
+ 		break;
+ 	case KVM_REG_PPC_EBBHR:
+ 		*val = get_reg_val(id, vcpu->arch.ebbhr);
+ 		break;
+ 	case KVM_REG_PPC_EBBRR:
+ 		*val = get_reg_val(id, vcpu->arch.ebbrr);
+ 		break;
+ 	case KVM_REG_PPC_BESCR:
+ 		*val = get_reg_val(id, vcpu->arch.bescr);
+ 		break;
+ 	case KVM_REG_PPC_TAR:
+ 		*val = get_reg_val(id, vcpu->arch.tar);
+ 		break;
+ 	case KVM_REG_PPC_DPDES:
+ 		*val = get_reg_val(id, vcpu->arch.vcore->dpdes);
+ 		break;
+ 	case KVM_REG_PPC_DAWR:
+ 		*val = get_reg_val(id, vcpu->arch.dawr);
+ 		break;
+ 	case KVM_REG_PPC_DAWRX:
+ 		*val = get_reg_val(id, vcpu->arch.dawrx);
+ 		break;
+ 	case KVM_REG_PPC_CIABR:
+ 		*val = get_reg_val(id, vcpu->arch.ciabr);
+ 		break;
+ 	case KVM_REG_PPC_IC:
+ 		*val = get_reg_val(id, vcpu->arch.ic);
+ 		break;
+ 	case KVM_REG_PPC_VTB:
+ 		*val = get_reg_val(id, vcpu->arch.vtb);
+ 		break;
+ 	case KVM_REG_PPC_CSIGR:
+ 		*val = get_reg_val(id, vcpu->arch.csigr);
+ 		break;
+ 	case KVM_REG_PPC_TACR:
+ 		*val = get_reg_val(id, vcpu->arch.tacr);
+ 		break;
+ 	case KVM_REG_PPC_TCSCR:
+ 		*val = get_reg_val(id, vcpu->arch.tcscr);
+ 		break;
+ 	case KVM_REG_PPC_PID:
+ 		*val = get_reg_val(id, vcpu->arch.pid);
+ 		break;
+ 	case KVM_REG_PPC_ACOP:
+ 		*val = get_reg_val(id, vcpu->arch.acop);
+ 		break;
+ 	case KVM_REG_PPC_WORT:
+ 		*val = get_reg_val(id, vcpu->arch.wort);
+ 		break;
++>>>>>>> 616dff860282 (KVM: PPC: Book3S PR: Handle Facility interrupt and FSCR)
  	case KVM_REG_PPC_VPA_ADDR:
  		spin_lock(&vcpu->arch.vpa_update_lock);
  		*val = get_reg_val(id, vcpu->arch.vpa.next_gpa);
@@@ -917,6 -1082,66 +977,69 @@@ int kvmppc_set_one_reg(struct kvm_vcpu 
  	case KVM_REG_PPC_SDAR:
  		vcpu->arch.sdar = set_reg_val(id, *val);
  		break;
++<<<<<<< HEAD
++=======
+ 	case KVM_REG_PPC_SIER:
+ 		vcpu->arch.sier = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_IAMR:
+ 		vcpu->arch.iamr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_PSPB:
+ 		vcpu->arch.pspb = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_EBBHR:
+ 		vcpu->arch.ebbhr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_EBBRR:
+ 		vcpu->arch.ebbrr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_BESCR:
+ 		vcpu->arch.bescr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_TAR:
+ 		vcpu->arch.tar = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_DPDES:
+ 		vcpu->arch.vcore->dpdes = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_DAWR:
+ 		vcpu->arch.dawr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_DAWRX:
+ 		vcpu->arch.dawrx = set_reg_val(id, *val) & ~DAWRX_HYP;
+ 		break;
+ 	case KVM_REG_PPC_CIABR:
+ 		vcpu->arch.ciabr = set_reg_val(id, *val);
+ 		/* Don't allow setting breakpoints in hypervisor code */
+ 		if ((vcpu->arch.ciabr & CIABR_PRIV) == CIABR_PRIV_HYPER)
+ 			vcpu->arch.ciabr &= ~CIABR_PRIV;	/* disable */
+ 		break;
+ 	case KVM_REG_PPC_IC:
+ 		vcpu->arch.ic = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_VTB:
+ 		vcpu->arch.vtb = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_CSIGR:
+ 		vcpu->arch.csigr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_TACR:
+ 		vcpu->arch.tacr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_TCSCR:
+ 		vcpu->arch.tcscr = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_PID:
+ 		vcpu->arch.pid = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_ACOP:
+ 		vcpu->arch.acop = set_reg_val(id, *val);
+ 		break;
+ 	case KVM_REG_PPC_WORT:
+ 		vcpu->arch.wort = set_reg_val(id, *val);
+ 		break;
++>>>>>>> 616dff860282 (KVM: PPC: Book3S PR: Handle Facility interrupt and FSCR)
  	case KVM_REG_PPC_VPA_ADDR:
  		addr = set_reg_val(id, *val);
  		r = -EINVAL;
diff --cc arch/powerpc/kvm/book3s_pr.c
index 4a72f612a23b,ddc626eea2da..000000000000
--- a/arch/powerpc/kvm/book3s_pr.c
+++ b/arch/powerpc/kvm/book3s_pr.c
@@@ -718,8 -759,52 +736,57 @@@ static void kvmppc_handle_lost_ext(stru
  	current->thread.regs->msr |= lost_ext;
  }
  
++<<<<<<< HEAD
 +int kvmppc_handle_exit(struct kvm_run *run, struct kvm_vcpu *vcpu,
 +                       unsigned int exit_nr)
++=======
+ #ifdef CONFIG_PPC_BOOK3S_64
+ 
+ static void kvmppc_trigger_fac_interrupt(struct kvm_vcpu *vcpu, ulong fac)
+ {
+ 	/* Inject the Interrupt Cause field and trigger a guest interrupt */
+ 	vcpu->arch.fscr &= ~(0xffULL << 56);
+ 	vcpu->arch.fscr |= (fac << 56);
+ 	kvmppc_book3s_queue_irqprio(vcpu, BOOK3S_INTERRUPT_FAC_UNAVAIL);
+ }
+ 
+ static void kvmppc_emulate_fac(struct kvm_vcpu *vcpu, ulong fac)
+ {
+ 	enum emulation_result er = EMULATE_FAIL;
+ 
+ 	if (!(kvmppc_get_msr(vcpu) & MSR_PR))
+ 		er = kvmppc_emulate_instruction(vcpu->run, vcpu);
+ 
+ 	if ((er != EMULATE_DONE) && (er != EMULATE_AGAIN)) {
+ 		/* Couldn't emulate, trigger interrupt in guest */
+ 		kvmppc_trigger_fac_interrupt(vcpu, fac);
+ 	}
+ }
+ 
+ /* Enable facilities (TAR, EBB, DSCR) for the guest */
+ static int kvmppc_handle_fac(struct kvm_vcpu *vcpu, ulong fac)
+ {
+ 	BUG_ON(!cpu_has_feature(CPU_FTR_ARCH_207S));
+ 
+ 	if (!(vcpu->arch.fscr & (1ULL << fac))) {
+ 		/* Facility not enabled by the guest */
+ 		kvmppc_trigger_fac_interrupt(vcpu, fac);
+ 		return RESUME_GUEST;
+ 	}
+ 
+ 	switch (fac) {
+ 	default:
+ 		kvmppc_emulate_fac(vcpu, fac);
+ 		break;
+ 	}
+ 
+ 	return RESUME_GUEST;
+ }
+ #endif
+ 
+ int kvmppc_handle_exit_pr(struct kvm_run *run, struct kvm_vcpu *vcpu,
+ 			  unsigned int exit_nr)
++>>>>>>> 616dff860282 (KVM: PPC: Book3S PR: Handle Facility interrupt and FSCR)
  {
  	int r = RESUME_HOST;
  	int s;
diff --git a/arch/powerpc/include/asm/kvm_asm.h b/arch/powerpc/include/asm/kvm_asm.h
index 572beb8bd96f..6faba6c87e5e 100644
--- a/arch/powerpc/include/asm/kvm_asm.h
+++ b/arch/powerpc/include/asm/kvm_asm.h
@@ -100,6 +100,7 @@
 #define BOOK3S_INTERRUPT_PERFMON	0xf00
 #define BOOK3S_INTERRUPT_ALTIVEC	0xf20
 #define BOOK3S_INTERRUPT_VSX		0xf40
+#define BOOK3S_INTERRUPT_FAC_UNAVAIL	0xf60
 #define BOOK3S_INTERRUPT_H_FAC_UNAVAIL	0xf80
 
 #define BOOK3S_IRQPRIO_SYSTEM_RESET		0
@@ -112,14 +113,15 @@
 #define BOOK3S_IRQPRIO_FP_UNAVAIL		7
 #define BOOK3S_IRQPRIO_ALTIVEC			8
 #define BOOK3S_IRQPRIO_VSX			9
-#define BOOK3S_IRQPRIO_SYSCALL			10
-#define BOOK3S_IRQPRIO_MACHINE_CHECK		11
-#define BOOK3S_IRQPRIO_DEBUG			12
-#define BOOK3S_IRQPRIO_EXTERNAL			13
-#define BOOK3S_IRQPRIO_DECREMENTER		14
-#define BOOK3S_IRQPRIO_PERFORMANCE_MONITOR	15
-#define BOOK3S_IRQPRIO_EXTERNAL_LEVEL		16
-#define BOOK3S_IRQPRIO_MAX			17
+#define BOOK3S_IRQPRIO_FAC_UNAVAIL		10
+#define BOOK3S_IRQPRIO_SYSCALL			11
+#define BOOK3S_IRQPRIO_MACHINE_CHECK		12
+#define BOOK3S_IRQPRIO_DEBUG			13
+#define BOOK3S_IRQPRIO_EXTERNAL			14
+#define BOOK3S_IRQPRIO_DECREMENTER		15
+#define BOOK3S_IRQPRIO_PERFORMANCE_MONITOR	16
+#define BOOK3S_IRQPRIO_EXTERNAL_LEVEL		17
+#define BOOK3S_IRQPRIO_MAX			18
 
 #define BOOK3S_HFLAG_DCBZ32			0x1
 #define BOOK3S_HFLAG_SLB			0x2
diff --git a/arch/powerpc/include/asm/kvm_book3s_asm.h b/arch/powerpc/include/asm/kvm_book3s_asm.h
index 412b2f389474..f529d3c1b150 100644
--- a/arch/powerpc/include/asm/kvm_book3s_asm.h
+++ b/arch/powerpc/include/asm/kvm_book3s_asm.h
@@ -102,6 +102,7 @@ struct kvmppc_host_state {
 #ifdef CONFIG_PPC_BOOK3S_64
 	u64 cfar;
 	u64 ppr;
+	u64 host_fscr;
 #endif
 };
 
@@ -131,6 +132,7 @@ struct kvmppc_book3s_shadow_vcpu {
 		u64     esid;
 		u64     vsid;
 	} slb[64];			/* guest SLB */
+	u64 shadow_fscr;
 #endif
 };
 
* Unmerged path arch/powerpc/include/asm/kvm_host.h
* Unmerged path arch/powerpc/kernel/asm-offsets.c
diff --git a/arch/powerpc/kvm/book3s.c b/arch/powerpc/kvm/book3s.c
index be63f63c167b..2904c914b411 100644
--- a/arch/powerpc/kvm/book3s.c
+++ b/arch/powerpc/kvm/book3s.c
@@ -98,6 +98,7 @@ static int kvmppc_book3s_vec2irqprio(unsigned int vec)
 	case 0xd00: prio = BOOK3S_IRQPRIO_DEBUG;		break;
 	case 0xf20: prio = BOOK3S_IRQPRIO_ALTIVEC;		break;
 	case 0xf40: prio = BOOK3S_IRQPRIO_VSX;			break;
+	case 0xf60: prio = BOOK3S_IRQPRIO_FAC_UNAVAIL;		break;
 	default:    prio = BOOK3S_IRQPRIO_MAX;			break;
 	}
 
@@ -224,6 +225,9 @@ int kvmppc_book3s_irqprio_deliver(struct kvm_vcpu *vcpu, unsigned int priority)
 	case BOOK3S_IRQPRIO_PERFORMANCE_MONITOR:
 		vec = BOOK3S_INTERRUPT_PERFMON;
 		break;
+	case BOOK3S_IRQPRIO_FAC_UNAVAIL:
+		vec = BOOK3S_INTERRUPT_FAC_UNAVAIL;
+		break;
 	default:
 		deliver = 0;
 		printk(KERN_ERR "KVM: Unknown interrupt: 0x%x\n", priority);
@@ -561,6 +565,9 @@ int kvm_vcpu_ioctl_get_one_reg(struct kvm_vcpu *vcpu, struct kvm_one_reg *reg)
 			val = get_reg_val(reg->id, kvmppc_xics_get_icp(vcpu));
 			break;
 #endif /* CONFIG_KVM_XICS */
+		case KVM_REG_PPC_FSCR:
+			val = get_reg_val(reg->id, vcpu->arch.fscr);
+			break;
 		default:
 			r = -EINVAL;
 			break;
@@ -651,6 +658,9 @@ int kvm_vcpu_ioctl_set_one_reg(struct kvm_vcpu *vcpu, struct kvm_one_reg *reg)
 						set_reg_val(reg->id, val));
 			break;
 #endif /* CONFIG_KVM_XICS */
+		case KVM_REG_PPC_FSCR:
+			vcpu->arch.fscr = set_reg_val(reg->id, val);
+			break;
 		default:
 			r = -EINVAL;
 			break;
diff --git a/arch/powerpc/kvm/book3s_emulate.c b/arch/powerpc/kvm/book3s_emulate.c
index b7863af892e8..ea63063b7925 100644
--- a/arch/powerpc/kvm/book3s_emulate.c
+++ b/arch/powerpc/kvm/book3s_emulate.c
@@ -438,6 +438,9 @@ int kvmppc_core_emulate_mtspr(struct kvm_vcpu *vcpu, int sprn, ulong spr_val)
 	case SPRN_GQR7:
 		to_book3s(vcpu)->gqr[sprn - SPRN_GQR0] = spr_val;
 		break;
+	case SPRN_FSCR:
+		vcpu->arch.fscr = spr_val;
+		break;
 	case SPRN_ICTC:
 	case SPRN_THRM1:
 	case SPRN_THRM2:
@@ -545,6 +548,9 @@ int kvmppc_core_emulate_mfspr(struct kvm_vcpu *vcpu, int sprn, ulong *spr_val)
 	case SPRN_GQR7:
 		*spr_val = to_book3s(vcpu)->gqr[sprn - SPRN_GQR0];
 		break;
+	case SPRN_FSCR:
+		*spr_val = vcpu->arch.fscr;
+		break;
 	case SPRN_THRM1:
 	case SPRN_THRM2:
 	case SPRN_THRM3:
* Unmerged path arch/powerpc/kvm/book3s_hv.c
* Unmerged path arch/powerpc/kvm/book3s_pr.c
diff --git a/arch/powerpc/kvm/book3s_segment.S b/arch/powerpc/kvm/book3s_segment.S
index 1e0cc2adfd40..acee37cde840 100644
--- a/arch/powerpc/kvm/book3s_segment.S
+++ b/arch/powerpc/kvm/book3s_segment.S
@@ -90,6 +90,15 @@ kvmppc_handler_trampoline_enter:
 	LOAD_GUEST_SEGMENTS
 
 #ifdef CONFIG_PPC_BOOK3S_64
+BEGIN_FTR_SECTION
+	/* Save host FSCR */
+	mfspr	r8, SPRN_FSCR
+	std	r8, HSTATE_HOST_FSCR(r13)
+	/* Set FSCR during guest execution */
+	ld	r9, SVCPU_SHADOW_FSCR(r13)
+	mtspr	SPRN_FSCR, r9
+END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
+
 	/* Some guests may need to have dcbz set to 32 byte length.
 	 *
 	 * Usually we ensure that by patching the guest's instructions
@@ -255,6 +264,10 @@ BEGIN_FTR_SECTION
 	cmpwi	r12, BOOK3S_INTERRUPT_H_EMUL_ASSIST
 	beq-	ld_last_inst
 END_FTR_SECTION_IFSET(CPU_FTR_HVMODE)
+BEGIN_FTR_SECTION
+	cmpwi	r12, BOOK3S_INTERRUPT_FAC_UNAVAIL
+	beq-	ld_last_inst
+END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
 #endif
 
 	b	no_ld_last_inst
@@ -311,6 +324,18 @@ no_ld_last_inst:
 
 no_dcbz32_off:
 
+BEGIN_FTR_SECTION
+	/* Save guest FSCR on a FAC_UNAVAIL interrupt */
+	cmpwi	r12, BOOK3S_INTERRUPT_FAC_UNAVAIL
+	bne+	no_fscr_save
+	mfspr	r7, SPRN_FSCR
+	std	r7, SVCPU_SHADOW_FSCR(r13)
+no_fscr_save:
+	/* Restore host FSCR */
+	ld	r8, HSTATE_HOST_FSCR(r13)
+	mtspr	SPRN_FSCR, r8
+END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
+
 #endif /* CONFIG_PPC_BOOK3S_64 */
 
 	/*
