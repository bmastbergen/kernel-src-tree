ACPI / hotplug / PCI: Clean up bridge_mutex usage

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Clean up bridge_mutex usage (Myron Stowe) [1114228]
Rebuild_FUZZ: 89.89%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit ff181e5a4f6b536e5f3f1601cd5c54e792cd9abc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/ff181e5a.failed

Do not acquire bridge_mutex around the addition of a slot to its
bridge's list of slots and arount the addition of a function to
its slot's list of functions, because that doesn't help anything
right now (those lists are walked without any locking anyway).

However, acquire bridge_mutex around the list walk in
acpiphp_remove_slots() and use list_for_each_entry() there,
because we terminate the walk as soon as we find the first matching
entry.  This prevents that list walk from colliding with bridge
addition and removal.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit ff181e5a4f6b536e5f3f1601cd5c54e792cd9abc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index d210006fa4ad,e4b7f2bc94df..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -221,86 -286,74 +221,125 @@@ register_slot(acpi_handle handle, u32 l
  	device = (adr >> 16) & 0xffff;
  	function = adr & 0xffff;
  
 -	mutex_lock(&acpiphp_context_lock);
 -	context = acpiphp_init_context(handle);
 -	if (!context) {
 -		mutex_unlock(&acpiphp_context_lock);
 -		acpi_handle_err(handle, "No hotplug context\n");
 -		return AE_NOT_EXIST;
 -	}
 -	newfunc = &context->func;
 +	pdev = bridge->pci_dev;
 +	if (pdev && device_is_managed_by_native_pciehp(pdev))
 +		return AE_OK;
 +
 +	newfunc = kzalloc(sizeof(struct acpiphp_func), GFP_KERNEL);
 +	if (!newfunc)
 +		return AE_NO_MEMORY;
 +
 +	newfunc->handle = handle;
  	newfunc->function = function;
 -	newfunc->parent = bridge;
 -	mutex_unlock(&acpiphp_context_lock);
  
 -	if (acpi_has_method(handle, "_EJ0"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
  		newfunc->flags = FUNC_HAS_EJ0;
  
 -	if (acpi_has_method(handle, "_STA"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_STA", &tmp)))
  		newfunc->flags |= FUNC_HAS_STA;
  
 -	if (acpi_has_method(handle, "_DCK"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS0", &tmp)))
 +		newfunc->flags |= FUNC_HAS_PS0;
 +
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS3", &tmp)))
 +		newfunc->flags |= FUNC_HAS_PS3;
 +
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_DCK", &tmp)))
  		newfunc->flags |= FUNC_HAS_DCK;
  
 +	status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 +	if (ACPI_FAILURE(status)) {
 +		/*
 +		 * use the count of the number of slots we've found
 +		 * for the number of the slot
 +		 */
 +		sun = bridge->nr_slots+1;
 +	}
 +
  	/* search for objects that share the same slot */
  	list_for_each_entry(slot, &bridge->slots, node)
++<<<<<<< HEAD
 +		if (slot->device == device) {
 +			if (slot->sun != sun)
 +				pr_warn("sibling found, but _SUN doesn't match!\n");
 +			found = 1;
 +			break;
 +		}
 +
 +	if (!found) {
 +		slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 +		if (!slot) {
 +			kfree(newfunc);
 +			return AE_NO_MEMORY;
 +		}
 +
 +		slot->bridge = bridge;
 +		slot->device = device;
 +		slot->sun = sun;
 +		INIT_LIST_HEAD(&slot->funcs);
 +		mutex_init(&slot->crit_sect);
 +
 +		mutex_lock(&bridge_mutex);
 +		list_add_tail(&slot->node, &bridge->slots);
 +		mutex_unlock(&bridge_mutex);
 +		bridge->nr_slots++;
 +
 +		pr_debug("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",
 +		    slot->sun, pci_domain_nr(pbus), pbus->number, device);
 +		retval = acpiphp_register_hotplug_slot(slot);
 +		if (retval) {
 +			if (retval == -EBUSY)
 +				pr_warn("Slot %llu already registered by another "
 +					"hotplug driver\n", slot->sun);
 +			else
 +				pr_warn("acpiphp_register_hotplug_slot failed "
 +					"(err code = 0x%x)\n", retval);
 +			goto err_exit;
++=======
+ 		if (slot->device == device)
+ 			goto slot_found;
+ 
+ 	slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
+ 	if (!slot) {
+ 		status = AE_NO_MEMORY;
+ 		goto err;
+ 	}
+ 
+ 	slot->bus = bridge->pci_bus;
+ 	slot->device = device;
+ 	INIT_LIST_HEAD(&slot->funcs);
+ 	mutex_init(&slot->crit_sect);
+ 
+ 	list_add_tail(&slot->node, &bridge->slots);
+ 
+ 	/* Register slots for ejectable funtions only. */
+ 	if (acpi_pci_check_ejectable(pbus, handle)  || is_dock_device(handle)) {
+ 		unsigned long long sun;
+ 		int retval;
+ 
+ 		bridge->nr_slots++;
+ 		status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
+ 		if (ACPI_FAILURE(status))
+ 			sun = bridge->nr_slots;
+ 
+ 		dbg("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",
+ 		    sun, pci_domain_nr(pbus), pbus->number, device);
+ 
+ 		retval = acpiphp_register_hotplug_slot(slot, sun);
+ 		if (retval) {
+ 			bridge->nr_slots--;
+ 			if (retval == -EBUSY)
+ 				warn("Slot %llu already registered by another "
+ 					"hotplug driver\n", sun);
+ 			else
+ 				warn("acpiphp_register_hotplug_slot failed "
+ 					"(err code = 0x%x)\n", retval);
++>>>>>>> ff181e5a4f6b (ACPI / hotplug / PCI: Clean up bridge_mutex usage)
  		}
 -		/* Even if the slot registration fails, we can still use it. */
  	}
  
 - slot_found:
  	newfunc->slot = slot;
- 	mutex_lock(&bridge_mutex);
  	list_add_tail(&newfunc->sibling, &slot->funcs);
- 	mutex_unlock(&bridge_mutex);
  
  	if (pci_bus_read_dev_vendor_id(pbus, PCI_DEVFN(device, function),
  				       &val, 60*1000))
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
