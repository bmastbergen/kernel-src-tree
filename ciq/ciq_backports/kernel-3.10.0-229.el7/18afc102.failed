qlcnic: Enable multiple Tx queue support for 83xx/84xx Series adapters.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [ethernet] qlcnic: Enable multiple Tx queue support for 83xx/84xx Series adapters (Chad Dupuis) [1089352]
Rebuild_FUZZ: 99.29%
commit-author Himanshu Madhani <himanshu.madhani@qlogic.com>
commit 18afc102fdcb95d6c7d57f2967a06f2f8fe3ba4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/18afc102.failed

o 83xx and 84xx firmware is capable of multiple Tx queues.
  This patch will enable multiple Tx queues for 83xx/84xx
  series adapters. Max number of Tx queues supported will be 8.

	Signed-off-by: Himanshu Madhani <himanshu.madhani@qlogic.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 18afc102fdcb95d6c7d57f2967a06f2f8fe3ba4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
#	drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
index 7545698efd1a,09810ddd11ec..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
@@@ -1655,7 -1653,9 +1655,13 @@@ int qlcnic_83xx_loopback_test(struct ne
  {
  	struct qlcnic_adapter *adapter = netdev_priv(netdev);
  	struct qlcnic_hardware_context *ahw = adapter->ahw;
++<<<<<<< HEAD
 +	int ret = 0, loop = 0, max_sds_rings = adapter->max_sds_rings;
++=======
+ 	u8 drv_sds_rings = adapter->drv_sds_rings;
+ 	u8 drv_tx_rings = adapter->drv_tx_rings;
+ 	int ret = 0, loop = 0;
++>>>>>>> 18afc102fdcb (qlcnic: Enable multiple Tx queue support for 83xx/84xx Series adapters.)
  
  	if (ahw->op_mode == QLCNIC_NON_PRIV_FUNC) {
  		netdev_warn(netdev,
@@@ -1715,10 -1715,11 +1721,15 @@@
  	qlcnic_83xx_clear_lb_mode(adapter, mode);
  
  free_diag_res:
 -	qlcnic_83xx_diag_free_res(netdev, drv_sds_rings);
 +	qlcnic_83xx_diag_free_res(netdev, max_sds_rings);
  
  fail_diag_alloc:
++<<<<<<< HEAD
 +	adapter->max_sds_rings = max_sds_rings;
++=======
+ 	adapter->drv_sds_rings = drv_sds_rings;
+ 	adapter->drv_tx_rings = drv_tx_rings;
++>>>>>>> 18afc102fdcb (qlcnic: Enable multiple Tx queue support for 83xx/84xx Series adapters.)
  	qlcnic_release_diag_lock(adapter);
  	return ret;
  }
@@@ -3303,10 -3304,11 +3314,15 @@@ int qlcnic_83xx_interrupt_test(struct n
  	struct qlcnic_adapter *adapter = netdev_priv(netdev);
  	struct qlcnic_hardware_context *ahw = adapter->ahw;
  	struct qlcnic_cmd_args cmd;
++<<<<<<< HEAD
++=======
+ 	u8 val, drv_sds_rings = adapter->drv_sds_rings;
+ 	u8 drv_tx_rings = adapter->drv_tx_rings;
++>>>>>>> 18afc102fdcb (qlcnic: Enable multiple Tx queue support for 83xx/84xx Series adapters.)
  	u32 data;
  	u16 intrpt_id, id;
 -	int ret;
 +	u8 val;
 +	int ret, max_sds_rings = adapter->max_sds_rings;
  
  	if (test_bit(__QLCNIC_RESETTING, &adapter->state)) {
  		netdev_info(netdev, "Device is resetting\n");
@@@ -3356,10 -3358,11 +3372,15 @@@
  
  done:
  	qlcnic_free_mbx_args(&cmd);
 -	qlcnic_83xx_diag_free_res(netdev, drv_sds_rings);
 +	qlcnic_83xx_diag_free_res(netdev, max_sds_rings);
  
  fail_diag_irq:
++<<<<<<< HEAD
 +	adapter->max_sds_rings = max_sds_rings;
++=======
+ 	adapter->drv_sds_rings = drv_sds_rings;
+ 	adapter->drv_tx_rings = drv_tx_rings;
++>>>>>>> 18afc102fdcb (qlcnic: Enable multiple Tx queue support for 83xx/84xx Series adapters.)
  	qlcnic_release_diag_lock(adapter);
  	return ret;
  }
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c
index 4a8a3f1b0345,89208e5b25d6..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c
@@@ -2064,10 -2067,14 +2064,20 @@@ int qlcnic_83xx_configure_opmode(struc
  		if (qlcnic_83xx_config_vnic_opmode(adapter))
  			return -EIO;
  
++<<<<<<< HEAD
++=======
+ 		adapter->max_sds_rings = QLCNIC_MAX_VNIC_SDS_RINGS;
+ 		adapter->max_tx_rings = QLCNIC_MAX_VNIC_TX_RINGS;
++>>>>>>> 18afc102fdcb (qlcnic: Enable multiple Tx queue support for 83xx/84xx Series adapters.)
  	} else if (ret == QLC_83XX_DEFAULT_OPMODE) {
 -		ahw->nic_mode = QLCNIC_DEFAULT_MODE;
 +		ahw->nic_mode = QLC_83XX_DEFAULT_MODE;
  		adapter->nic_ops->init_driver = qlcnic_83xx_init_default_driver;
  		ahw->idc.state_entry = qlcnic_83xx_idc_ready_state_entry;
++<<<<<<< HEAD
++=======
+ 		adapter->max_sds_rings = ahw->max_rx_ques;
+ 		adapter->max_tx_rings = ahw->max_tx_ques;
++>>>>>>> 18afc102fdcb (qlcnic: Enable multiple Tx queue support for 83xx/84xx Series adapters.)
  	} else {
  		return -EIO;
  	}
@@@ -2170,6 -2177,23 +2180,26 @@@ static int qlcnic_83xx_get_fw_info(stru
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static void qlcnic_83xx_init_rings(struct qlcnic_adapter *adapter)
+ {
+ 	u8 rx_cnt = QLCNIC_DEF_SDS_RINGS;
+ 	u8 tx_cnt = QLCNIC_DEF_TX_RINGS;
+ 
+ 	adapter->max_tx_rings = QLCNIC_MAX_TX_RINGS;
+ 	adapter->max_sds_rings = QLCNIC_MAX_SDS_RINGS;
+ 
+ 	if (!adapter->ahw->msix_supported) {
+ 		rx_cnt = QLCNIC_SINGLE_RING;
+ 		tx_cnt = QLCNIC_SINGLE_RING;
+ 	}
+ 
+ 	/* compute and set drv sds rings */
+ 	qlcnic_set_tx_ring_count(adapter, tx_cnt);
+ 	qlcnic_set_sds_ring_count(adapter, rx_cnt);
+ }
++>>>>>>> 18afc102fdcb (qlcnic: Enable multiple Tx queue support for 83xx/84xx Series adapters.)
  
  int qlcnic_83xx_init(struct qlcnic_adapter *adapter, int pci_using_dac)
  {
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
index b37ff7828969,b36c02fafcfd..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
@@@ -688,22 -716,36 +688,31 @@@ static int qlcnic_set_channels(struct n
  	if (channel->other_count || channel->combined_count)
  		return -EINVAL;
  
 -	err = qlcnic_validate_ring_count(adapter, channel->rx_count,
 -					 channel->tx_count);
 -	if (err)
 -		return err;
 -
  	if (channel->rx_count) {
 -		err = qlcnic_validate_rings(adapter, channel->rx_count,
 -					    QLCNIC_RX_QUEUE);
 -		if (err) {
 -			netdev_err(dev, "Unable to configure %u SDS rings\n",
 -				   channel->rx_count);
 +		err = qlcnic_validate_max_rss(adapter, channel->rx_count);
 +		if (err)
  			return err;
 -		}
  	}
  
++<<<<<<< HEAD
 +	if (qlcnic_82xx_check(adapter) && channel->tx_count) {
 +		err = qlcnic_validate_max_tx_rings(adapter, channel->tx_count);
 +		if (err)
++=======
+ 	if (channel->tx_count) {
+ 		err = qlcnic_validate_rings(adapter, channel->tx_count,
+ 					    QLCNIC_TX_QUEUE);
+ 		if (err) {
+ 			netdev_err(dev, "Unable to configure %u Tx rings\n",
+ 				   channel->tx_count);
++>>>>>>> 18afc102fdcb (qlcnic: Enable multiple Tx queue support for 83xx/84xx Series adapters.)
  			return err;
 -		}
 +		txq = channel->tx_count;
  	}
  
 -	err = qlcnic_setup_rings(adapter, channel->rx_count,
 -				 channel->tx_count);
 -	netdev_info(dev, "Allocated %d SDS rings and %d Tx rings\n",
 -		    adapter->drv_sds_rings, adapter->drv_tx_rings);
 -
 +	err = qlcnic_set_max_rss(adapter, channel->rx_count, txq);
 +	netdev_info(dev, "allocated 0x%x sds rings and  0x%x tx rings\n",
 +		    adapter->max_sds_rings, adapter->max_drv_tx_rings);
  	return err;
  }
  
diff --cc drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
index 0566a4688bc1,05c1eef8df13..000000000000
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
@@@ -3657,14 -3697,26 +3657,30 @@@ qlcnicvf_start_firmware(struct qlcnic_a
  	return err;
  }
  
 -int qlcnic_validate_rings(struct qlcnic_adapter *adapter, __u32 ring_cnt,
 -			  int queue_type)
 +int qlcnic_validate_max_tx_rings(struct qlcnic_adapter *adapter, u32 txq)
  {
  	struct net_device *netdev = adapter->netdev;
++<<<<<<< HEAD
 +	u8 max_hw = QLCNIC_MAX_TX_RINGS;
 +	u32 max_allowed;
++=======
+ 	u8 max_hw_rings = 0;
+ 	char buf[8];
+ 	int cur_rings;
+ 
+ 	if (queue_type == QLCNIC_RX_QUEUE) {
+ 		max_hw_rings = adapter->max_sds_rings;
+ 		cur_rings = adapter->drv_sds_rings;
+ 		strcpy(buf, "SDS");
+ 	} else if (queue_type == QLCNIC_TX_QUEUE) {
+ 		max_hw_rings = adapter->max_tx_rings;
+ 		cur_rings = adapter->drv_tx_rings;
+ 		strcpy(buf, "Tx");
+ 	}
++>>>>>>> 18afc102fdcb (qlcnic: Enable multiple Tx queue support for 83xx/84xx Series adapters.)
  
  	if (!qlcnic_use_msi_x && !qlcnic_use_msi) {
 -		netdev_err(netdev, "No RSS/TSS support in INT-x mode\n");
 +		netdev_err(netdev, "No Multi TX-Q support in INT-x mode\n");
  		return -EINVAL;
  	}
  
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_hw.c
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_83xx_init.c
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_ethtool.c
diff --git a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
index cbeb43df6391..15a5253e6b96 100644
--- a/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
+++ b/drivers/net/ethernet/qlogic/qlcnic/qlcnic_io.c
@@ -581,10 +581,7 @@ netdev_tx_t qlcnic_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
 			goto drop_packet;
 	}
 
-	if (qlcnic_check_multi_tx(adapter))
-		tx_ring = &adapter->tx_ring[skb_get_queue_mapping(skb)];
-	else
-		tx_ring = &adapter->tx_ring[0];
+	tx_ring = &adapter->tx_ring[skb_get_queue_mapping(skb)];
 	num_txd = tx_ring->num_desc;
 
 	frag_count = skb_shinfo(skb)->nr_frags + 1;
* Unmerged path drivers/net/ethernet/qlogic/qlcnic/qlcnic_main.c
