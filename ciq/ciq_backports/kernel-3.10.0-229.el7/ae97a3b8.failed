KVM: x86: introduce sched_in to kvm_x86_ops

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm: introduce sched_in to kvm_x86_ops (Radim Krcmar) [1163296]
Rebuild_FUZZ: 93.83%
commit-author Radim Krčmář <rkrcmar@redhat.com>
commit ae97a3b818324b92b5b9cc885c63c3f4bd46ee9d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/ae97a3b8.failed

sched_in preempt notifier is available for x86, allow its use in
specific virtualization technlogies as well.

	Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit ae97a3b818324b92b5b9cc885c63c3f4bd46ee9d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/kvm_host.h
#	arch/x86/kvm/vmx.c
#	arch/x86/kvm/x86.c
diff --cc arch/x86/include/asm/kvm_host.h
index 31cd3909a583,ac0f90e26a0b..000000000000
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@@ -765,6 -769,10 +765,13 @@@ struct kvm_x86_ops 
  			       enum x86_intercept_stage stage);
  	void (*handle_external_intr)(struct kvm_vcpu *vcpu);
  	bool (*mpx_supported)(void);
++<<<<<<< HEAD
++=======
+ 
+ 	int (*check_nested_events)(struct kvm_vcpu *vcpu, bool external_intr);
+ 
+ 	void (*sched_in)(struct kvm_vcpu *kvm, int cpu);
++>>>>>>> ae97a3b81832 (KVM: x86: introduce sched_in to kvm_x86_ops)
  };
  
  struct kvm_arch_async_pf {
diff --cc arch/x86/kvm/vmx.c
index 42ee3e9734f0,7c26533e149c..000000000000
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@@ -8717,6 -8954,10 +8721,13 @@@ static struct kvm_x86_ops vmx_x86_ops 
  	.check_intercept = vmx_check_intercept,
  	.handle_external_intr = vmx_handle_external_intr,
  	.mpx_supported = vmx_mpx_supported,
++<<<<<<< HEAD
++=======
+ 
+ 	.check_nested_events = vmx_check_nested_events,
+ 
+ 	.sched_in = vmx_sched_in,
++>>>>>>> ae97a3b81832 (KVM: x86: introduce sched_in to kvm_x86_ops)
  };
  
  static int __init vmx_init(void)
diff --cc arch/x86/kvm/x86.c
index 374a65f4180b,575d3fc67e7e..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -7073,6 -7171,11 +7073,14 @@@ void kvm_arch_vcpu_uninit(struct kvm_vc
  		static_key_slow_dec(&kvm_no_apic_vcpu);
  }
  
++<<<<<<< HEAD
++=======
+ void kvm_arch_sched_in(struct kvm_vcpu *vcpu, int cpu)
+ {
+ 	kvm_x86_ops->sched_in(vcpu, cpu);
+ }
+ 
++>>>>>>> ae97a3b81832 (KVM: x86: introduce sched_in to kvm_x86_ops)
  int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
  {
  	if (type)
* Unmerged path arch/x86/include/asm/kvm_host.h
diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c
index 0024092728ef..ccde45812ba1 100644
--- a/arch/x86/kvm/svm.c
+++ b/arch/x86/kvm/svm.c
@@ -4305,6 +4305,10 @@ static void svm_handle_external_intr(struct kvm_vcpu *vcpu)
 	local_irq_enable();
 }
 
+static void svm_sched_in(struct kvm_vcpu *vcpu, int cpu)
+{
+}
+
 static struct kvm_x86_ops svm_x86_ops = {
 	.cpu_has_kvm_support = has_svm,
 	.disabled_by_bios = is_disabled,
@@ -4406,6 +4410,8 @@ static struct kvm_x86_ops svm_x86_ops = {
 
 	.check_intercept = svm_check_intercept,
 	.handle_external_intr = svm_handle_external_intr,
+
+	.sched_in = svm_sched_in,
 };
 
 static int __init svm_init(void)
* Unmerged path arch/x86/kvm/vmx.c
* Unmerged path arch/x86/kvm/x86.c
