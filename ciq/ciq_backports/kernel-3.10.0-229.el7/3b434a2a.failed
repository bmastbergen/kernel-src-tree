rbd: extract a method for adding object operations

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Josh Durgin <josh.durgin@inktank.com>
commit 3b434a2aff38029ea053ce6c8fced53b2d01f7f0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3b434a2a.failed

rbd_img_request_fill() creates a ceph_osd_request and has logic for
adding the appropriate osd ops to it based on the request type and
image properties.

For layered images, the original rbd_obj_request is resent with a
copyup operation in front, using a new ceph_osd_request. The logic for
adding the original operations should be the same as when first
sending them, so move it to a helper function.

op_type only needs to be checked once, so create a helper for that as
well and call it outside the loop in rbd_img_request_fill().

	Signed-off-by: Josh Durgin <josh.durgin@inktank.com>
(cherry picked from commit 3b434a2aff38029ea053ce6c8fced53b2d01f7f0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/rbd.c
diff --cc drivers/block/rbd.c
index 0c349c7388a9,c07cb1dbc1c5..000000000000
--- a/drivers/block/rbd.c
+++ b/drivers/block/rbd.c
@@@ -2355,47 -2465,20 +2427,58 @@@ static int rbd_img_request_fill(struct 
  			pages += page_count;
  		}
  
++<<<<<<< HEAD
 +		if (img_request_write_test(img_request)) {
 +			op_type = OBJ_OP_WRITE;
 +			opcode = CEPH_OSD_OP_WRITE;
 +		} else {
 +			op_type = OBJ_OP_READ;
 +			opcode = CEPH_OSD_OP_READ;
 +		}
 +
++=======
++>>>>>>> 3b434a2aff38 (rbd: extract a method for adding object operations)
  		osd_req = rbd_osd_req_create(rbd_dev, op_type,
  					(op_type == OBJ_OP_WRITE) ? 2 : 1,
  					obj_request);
  		if (!osd_req)
  			goto out_unwind;
+ 
  		obj_request->osd_req = osd_req;
  		obj_request->callback = rbd_img_obj_callback;
++<<<<<<< HEAD
 +		rbd_img_request_get(img_request);
 +
 +		if (op_type == OBJ_OP_WRITE) {
 +			osd_req_op_alloc_hint_init(osd_req, which,
 +					     rbd_obj_bytes(&rbd_dev->header),
 +					     rbd_obj_bytes(&rbd_dev->header));
 +			which++;
 +		}
 +
 +		osd_req_op_extent_init(osd_req, which, opcode, offset, length,
 +				       0, 0);
 +		if (type == OBJ_REQUEST_BIO)
 +			osd_req_op_extent_osd_data_bio(osd_req, which,
 +					obj_request->bio_list, length);
 +		else
 +			osd_req_op_extent_osd_data_pages(osd_req, which,
 +					obj_request->pages, length,
 +					offset & ~PAGE_MASK, false, false);
 +
 +		if (op_type == OBJ_OP_WRITE)
 +			rbd_osd_req_format_write(obj_request);
 +		else
 +			rbd_osd_req_format_read(obj_request);
 +
++=======
++>>>>>>> 3b434a2aff38 (rbd: extract a method for adding object operations)
  		obj_request->img_offset = img_offset;
  
+ 		rbd_img_obj_request_fill(obj_request, osd_req, op_type, 0);
+ 
+ 		rbd_img_request_get(img_request);
+ 
  		img_offset += length;
  		resid -= length;
  	}
* Unmerged path drivers/block/rbd.c
