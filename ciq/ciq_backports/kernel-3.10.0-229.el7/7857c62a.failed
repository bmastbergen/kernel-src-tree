cxgb4i: fix credit check for tx_data_wr

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Karen Xie <kxie@chelsio.com>
commit 7857c62a35041a21a66ccab551601c942b748330
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/7857c62a.failed

make sure any tx credit related checking is done before adding the wr header.

	Signed-off-by: Karen Xie <kxie@chelsio.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 7857c62a35041a21a66ccab551601c942b748330)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
diff --cc drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
index 6ce80d6bbcf1,197d7de189fb..000000000000
--- a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
+++ b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
@@@ -589,30 -548,32 +589,44 @@@ static inline void make_tx_data_wr(stru
  {
  	struct fw_ofld_tx_data_wr *req;
  	unsigned int submode = cxgbi_skcb_ulp_mode(skb) & 3;
++<<<<<<< HEAD
 +	unsigned int wr_ulp_mode = 0;
 +
 +	req = (struct fw_ofld_tx_data_wr *)__skb_push(skb, sizeof(*req));
 +
 +	if (is_ofld_imm(skb)) {
 +		req->op_to_immdlen = htonl(FW_WR_OP(FW_OFLD_TX_DATA_WR) |
 +					FW_WR_COMPL(1) |
 +					FW_WR_IMMDLEN(dlen));
 +		req->flowid_len16 = htonl(FW_WR_FLOWID(csk->tid) |
 +						FW_WR_LEN16(credits));
++=======
+ 	unsigned int wr_ulp_mode = 0, val;
+ 	bool imm = is_ofld_imm(skb);
+ 
+ 	req = (struct fw_ofld_tx_data_wr *)__skb_push(skb, sizeof(*req));
+ 
+ 	if (imm) {
+ 		req->op_to_immdlen = htonl(FW_WR_OP_V(FW_OFLD_TX_DATA_WR) |
+ 					FW_WR_COMPL_F |
+ 					FW_WR_IMMDLEN_V(dlen));
+ 		req->flowid_len16 = htonl(FW_WR_FLOWID_V(csk->tid) |
+ 						FW_WR_LEN16_V(credits));
++>>>>>>> 7857c62a3504 (cxgb4i: fix credit check for tx_data_wr)
  	} else {
  		req->op_to_immdlen =
 -			cpu_to_be32(FW_WR_OP_V(FW_OFLD_TX_DATA_WR) |
 -					FW_WR_COMPL_F |
 -					FW_WR_IMMDLEN_V(0));
 +			cpu_to_be32(FW_WR_OP(FW_OFLD_TX_DATA_WR) |
 +					FW_WR_COMPL(1) |
 +					FW_WR_IMMDLEN(0));
  		req->flowid_len16 =
 -			cpu_to_be32(FW_WR_FLOWID_V(csk->tid) |
 -					FW_WR_LEN16_V(credits));
 +			cpu_to_be32(FW_WR_FLOWID(csk->tid) |
 +					FW_WR_LEN16(credits));
  	}
  	if (submode)
 -		wr_ulp_mode = FW_OFLD_TX_DATA_WR_ULPMODE_V(ULP2_MODE_ISCSI) |
 -				FW_OFLD_TX_DATA_WR_ULPSUBMODE_V(submode);
 -	val = skb_peek(&csk->write_queue) ? 0 : 1;
 +		wr_ulp_mode = FW_OFLD_TX_DATA_WR_ULPMODE(ULP2_MODE_ISCSI) |
 +				FW_OFLD_TX_DATA_WR_ULPSUBMODE(submode);
  	req->tunnel_to_proxy = htonl(wr_ulp_mode |
 -				     FW_OFLD_TX_DATA_WR_SHOVE_V(val));
 +		 FW_OFLD_TX_DATA_WR_SHOVE(skb_peek(&csk->write_queue) ? 0 : 1));
  	req->plen = htonl(len);
  	if (!cxgbi_sock_flag(csk, CTPF_TX_DATA_SENT))
  		cxgbi_sock_set_flag(csk, CTPF_TX_DATA_SENT);
* Unmerged path drivers/scsi/cxgbi/cxgb4i/cxgb4i.c
