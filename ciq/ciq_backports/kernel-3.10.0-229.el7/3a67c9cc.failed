hyperv: Fix a bug in netvsc_send()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author KY Srinivasan <kys@microsoft.com>
commit 3a67c9ccad926a168d8b7891537a452018368a5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3a67c9cc.failed

After the packet is successfully sent, we should not touch the packet
as it may have been freed. This patch is based on the work done by
Long Li <longli@microsoft.com>.

David, please queue this up for stable.

	Signed-off-by: K. Y. Srinivasan <kys@microsoft.com>
	Reported-by: Sitsofe Wheeler <sitsofe@yahoo.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 3a67c9ccad926a168d8b7891537a452018368a5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/netvsc.c
diff --cc drivers/net/hyperv/netvsc.c
index 8a1913177584,da2d34688370..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -509,7 -700,13 +509,15 @@@ int netvsc_send(struct hv_device *devic
  	int ret = 0;
  	struct nvsp_message sendMessage;
  	struct net_device *ndev;
 -	struct vmbus_channel *out_channel = NULL;
  	u64 req_id;
++<<<<<<< HEAD
++=======
+ 	unsigned int section_index = NETVSC_INVALID_INDEX;
+ 	u32 msg_size = 0;
+ 	struct sk_buff *skb;
+ 	u16 q_idx = packet->q_idx;
+ 
++>>>>>>> 3a67c9ccad92 (hyperv: Fix a bug in netvsc_send())
  
  	net_device = get_outbound_net_device(device);
  	if (!net_device)
@@@ -552,17 -770,24 +560,38 @@@
  
  	if (ret == 0) {
  		atomic_inc(&net_device->num_outstanding_sends);
++<<<<<<< HEAD
 +		if (hv_ringbuf_avail_percent(&device->channel->outbound) <
 +			RING_AVAIL_PERCENT_LOWATER) {
 +			netif_stop_queue(ndev);
 +			if (atomic_read(&net_device->
 +				num_outstanding_sends) < 1)
 +				netif_wake_queue(ndev);
 +		}
 +	} else if (ret == -EAGAIN) {
 +		netif_stop_queue(ndev);
 +		if (atomic_read(&net_device->num_outstanding_sends) < 1) {
 +			netif_wake_queue(ndev);
++=======
+ 		atomic_inc(&net_device->queue_sends[q_idx]);
+ 
+ 		if (hv_ringbuf_avail_percent(&out_channel->outbound) <
+ 			RING_AVAIL_PERCENT_LOWATER) {
+ 			netif_tx_stop_queue(netdev_get_tx_queue(
+ 					    ndev, q_idx));
+ 
+ 			if (atomic_read(&net_device->
+ 				queue_sends[q_idx]) < 1)
+ 				netif_tx_wake_queue(netdev_get_tx_queue(
+ 						    ndev, q_idx));
+ 		}
+ 	} else if (ret == -EAGAIN) {
+ 		netif_tx_stop_queue(netdev_get_tx_queue(
+ 				    ndev, q_idx));
+ 		if (atomic_read(&net_device->queue_sends[q_idx]) < 1) {
+ 			netif_tx_wake_queue(netdev_get_tx_queue(
+ 					    ndev, q_idx));
++>>>>>>> 3a67c9ccad92 (hyperv: Fix a bug in netvsc_send())
  			ret = -ENOSPC;
  		}
  	} else {
* Unmerged path drivers/net/hyperv/netvsc.c
