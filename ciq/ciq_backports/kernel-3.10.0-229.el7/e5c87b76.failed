cpufreq: Fix checkpatch errors and warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Fix checkpatch errors and warnings (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 88.31%
commit-author Stratos Karafotis <stratosk@semaphore.gr>
commit e5c87b762871c3377e456f6a57769dc63bdddd4b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e5c87b76.failed

Fix 2 checkpatch errors about using assignment in if condition,
1 checkpatch error about a required space after comma
and 3 warnings about line over 80 characters.

	Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit e5c87b762871c3377e456f6a57769dc63bdddd4b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index c8bc717e8458,77a99bfea9a9..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -897,30 -936,114 +897,42 @@@ static int cpufreq_add_policy_cpu(unsig
  	per_cpu(cpufreq_cpu_data, cpu) = policy;
  	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
  
 -	up_write(&policy->rwsem);
 +	unlock_policy_rwsem_write(sibling);
  
++<<<<<<< HEAD
 +	if (has_target) {
 +		__cpufreq_governor(policy, CPUFREQ_GOV_START);
 +		__cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
++=======
+ 	if (has_target()) {
+ 		ret = __cpufreq_governor(policy, CPUFREQ_GOV_START);
+ 		if (!ret)
+ 			ret = __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
+ 
+ 		if (ret) {
+ 			pr_err("%s: Failed to start governor\n", __func__);
+ 			return ret;
+ 		}
++>>>>>>> e5c87b762871 (cpufreq: Fix checkpatch errors and warnings)
  	}
  
 -	return sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");
 -}
 -#endif
 -
 -static struct cpufreq_policy *cpufreq_policy_restore(unsigned int cpu)
 -{
 -	struct cpufreq_policy *policy;
 -	unsigned long flags;
 -
 -	read_lock_irqsave(&cpufreq_driver_lock, flags);
 -
 -	policy = per_cpu(cpufreq_cpu_data_fallback, cpu);
 -
 -	read_unlock_irqrestore(&cpufreq_driver_lock, flags);
 -
 -	policy->governor = NULL;
 -
 -	return policy;
 -}
 -
 -static struct cpufreq_policy *cpufreq_policy_alloc(void)
 -{
 -	struct cpufreq_policy *policy;
 -
 -	policy = kzalloc(sizeof(*policy), GFP_KERNEL);
 -	if (!policy)
 -		return NULL;
 -
 -	if (!alloc_cpumask_var(&policy->cpus, GFP_KERNEL))
 -		goto err_free_policy;
 -
 -	if (!zalloc_cpumask_var(&policy->related_cpus, GFP_KERNEL))
 -		goto err_free_cpumask;
 -
 -	INIT_LIST_HEAD(&policy->policy_list);
 -	init_rwsem(&policy->rwsem);
 -
 -	return policy;
 -
 -err_free_cpumask:
 -	free_cpumask_var(policy->cpus);
 -err_free_policy:
 -	kfree(policy);
 -
 -	return NULL;
 -}
 -
 -static void cpufreq_policy_put_kobj(struct cpufreq_policy *policy)
 -{
 -	struct kobject *kobj;
 -	struct completion *cmp;
 -
 -	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
 -			CPUFREQ_REMOVE_POLICY, policy);
 -
 -	down_read(&policy->rwsem);
 -	kobj = &policy->kobj;
 -	cmp = &policy->kobj_unregister;
 -	up_read(&policy->rwsem);
 -	kobject_put(kobj);
 +	ret = sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");
  
 -	/*
 -	 * We need to make sure that the underlying kobj is
 -	 * actually not referenced anymore by anybody before we
 -	 * proceed with unloading.
 -	 */
 -	pr_debug("waiting for dropping of refcount\n");
 -	wait_for_completion(cmp);
 -	pr_debug("wait complete\n");
 -}
 -
 -static void cpufreq_policy_free(struct cpufreq_policy *policy)
 -{
 -	free_cpumask_var(policy->related_cpus);
 -	free_cpumask_var(policy->cpus);
 -	kfree(policy);
 -}
 -
 -static void update_policy_cpu(struct cpufreq_policy *policy, unsigned int cpu)
 -{
 -	if (WARN_ON(cpu == policy->cpu))
 -		return;
 -
 -	down_write(&policy->rwsem);
 -
 -	policy->last_cpu = policy->cpu;
 -	policy->cpu = cpu;
 -
 -	up_write(&policy->rwsem);
 -
 -	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
 -			CPUFREQ_UPDATE_POLICY_CPU, policy);
 +	cpufreq_cpu_put(policy);
 +	return ret;
  }
 +#endif
  
 -static int __cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)
 +/**
 + * cpufreq_add_dev - add a CPU device
 + *
 + * Adds the cpufreq interface for a CPU device.
 + *
 + * The Oracle says: try running cpufreq registration/unregistration concurrently
 + * with with cpu hotplugging and all hell will break loose. Tried to clean this
 + * mess up, but more thorough testing is needed. - Mathieu
 + */
 +static int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)
  {
  	unsigned int j, cpu = dev->id;
  	int ret = -ENOMEM;
@@@ -1216,35 -1340,71 +1228,53 @@@ static int __cpufreq_remove_dev(struct 
  		}
  	}
  
 -	return 0;
 -}
 -
 -static int __cpufreq_remove_dev_finish(struct device *dev,
 -				       struct subsys_interface *sif)
 -{
 -	unsigned int cpu = dev->id, cpus;
 -	int ret;
 -	unsigned long flags;
 -	struct cpufreq_policy *policy;
 -
 -	read_lock_irqsave(&cpufreq_driver_lock, flags);
 -	policy = per_cpu(cpufreq_cpu_data, cpu);
 -	read_unlock_irqrestore(&cpufreq_driver_lock, flags);
 -
 -	if (!policy) {
 -		pr_debug("%s: No cpu_data found\n", __func__);
 -		return -EINVAL;
 -	}
 -
 -	down_write(&policy->rwsem);
 -	cpus = cpumask_weight(policy->cpus);
 -
 -	if (cpus > 1)
 -		cpumask_clear_cpu(cpu, policy->cpus);
 -	up_write(&policy->rwsem);
 -
  	/* If cpu is last user of policy, free policy */
  	if (cpus == 1) {
 -		if (has_target()) {
 -			ret = __cpufreq_governor(policy,
 -					CPUFREQ_GOV_POLICY_EXIT);
 -			if (ret) {
 -				pr_err("%s: Failed to exit governor\n",
 -				       __func__);
 -				return ret;
 -			}
 -		}
 -
 -		if (!cpufreq_suspended)
 -			cpufreq_policy_put_kobj(policy);
 -
 -		/*
 -		 * Perform the ->exit() even during light-weight tear-down,
 -		 * since this is a core component, and is essential for the
 -		 * subsequent light-weight ->init() to succeed.
 +		if (cpufreq_driver->target)
 +			__cpufreq_governor(data, CPUFREQ_GOV_POLICY_EXIT);
 +
 +		lock_policy_rwsem_read(cpu);
 +		kobj = &data->kobj;
 +		cmp = &data->kobj_unregister;
 +		unlock_policy_rwsem_read(cpu);
 +		kobject_put(kobj);
 +
 +		/* we need to make sure that the underlying kobj is actually
 +		 * not referenced anymore by anybody before we proceed with
 +		 * unloading.
  		 */
 +		pr_debug("waiting for dropping of refcount\n");
 +		wait_for_completion(cmp);
 +		pr_debug("wait complete\n");
 +
  		if (cpufreq_driver->exit)
 -			cpufreq_driver->exit(policy);
 +			cpufreq_driver->exit(data);
  
++<<<<<<< HEAD
 +		free_cpumask_var(data->related_cpus);
 +		free_cpumask_var(data->cpus);
 +		kfree(data);
 +	} else {
 +		if (cpufreq_driver->target) {
 +			__cpufreq_governor(data, CPUFREQ_GOV_START);
 +			__cpufreq_governor(data, CPUFREQ_GOV_LIMITS);
++=======
+ 		/* Remove policy from list of active policies */
+ 		write_lock_irqsave(&cpufreq_driver_lock, flags);
+ 		list_del(&policy->policy_list);
+ 		write_unlock_irqrestore(&cpufreq_driver_lock, flags);
+ 
+ 		if (!cpufreq_suspended)
+ 			cpufreq_policy_free(policy);
+ 	} else if (has_target()) {
+ 		ret = __cpufreq_governor(policy, CPUFREQ_GOV_START);
+ 		if (!ret)
+ 			ret = __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
+ 
+ 		if (ret) {
+ 			pr_err("%s: Failed to start governor\n", __func__);
+ 			return ret;
++>>>>>>> e5c87b762871 (cpufreq: Fix checkpatch errors and warnings)
  		}
  	}
  
@@@ -1837,69 -2064,59 +1867,111 @@@ static int __cpufreq_set_policy(struct 
  
  	/* notification of the new policy */
  	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
 -			CPUFREQ_NOTIFY, new_policy);
 +			CPUFREQ_NOTIFY, policy);
  
 -	policy->min = new_policy->min;
 -	policy->max = new_policy->max;
 +	data->min = policy->min;
 +	data->max = policy->max;
  
  	pr_debug("new min and max freqs are %u - %u kHz\n",
 -		 policy->min, policy->max);
 +					data->min, data->max);
  
  	if (cpufreq_driver->setpolicy) {
 -		policy->policy = new_policy->policy;
 +		data->policy = policy->policy;
  		pr_debug("setting range\n");
 -		return cpufreq_driver->setpolicy(new_policy);
 +		ret = cpufreq_driver->setpolicy(policy);
 +	} else {
 +		if (policy->governor != data->governor) {
 +			/* save old, working values */
 +			struct cpufreq_governor *old_gov = data->governor;
 +
 +			pr_debug("governor switch\n");
 +
 +			/* end old governor */
 +			if (data->governor) {
 +				__cpufreq_governor(data, CPUFREQ_GOV_STOP);
 +				unlock_policy_rwsem_write(policy->cpu);
 +				__cpufreq_governor(data,
 +						CPUFREQ_GOV_POLICY_EXIT);
 +				lock_policy_rwsem_write(policy->cpu);
 +			}
 +
 +			/* start new governor */
 +			data->governor = policy->governor;
 +			if (!__cpufreq_governor(data, CPUFREQ_GOV_POLICY_INIT)) {
 +				if (!__cpufreq_governor(data, CPUFREQ_GOV_START)) {
 +					failed = 0;
 +				} else {
 +					unlock_policy_rwsem_write(policy->cpu);
 +					__cpufreq_governor(data,
 +							CPUFREQ_GOV_POLICY_EXIT);
 +					lock_policy_rwsem_write(policy->cpu);
 +				}
 +			}
 +
 +			if (failed) {
 +				/* new governor failed, so re-start old one */
 +				pr_debug("starting governor %s failed\n",
 +							data->governor->name);
 +				if (old_gov) {
 +					data->governor = old_gov;
 +					__cpufreq_governor(data,
 +							CPUFREQ_GOV_POLICY_INIT);
 +					__cpufreq_governor(data,
 +							   CPUFREQ_GOV_START);
 +				}
 +				ret = -EINVAL;
 +				goto error_out;
 +			}
 +			/* might be a policy change, too, so fall through */
 +		}
 +		pr_debug("governor: change or update limits\n");
 +		__cpufreq_governor(data, CPUFREQ_GOV_LIMITS);
  	}
  
++<<<<<<< HEAD
 +error_out:
 +	return ret;
++=======
+ 	if (new_policy->governor == policy->governor)
+ 		goto out;
+ 
+ 	pr_debug("governor switch\n");
+ 
+ 	/* save old, working values */
+ 	old_gov = policy->governor;
+ 	/* end old governor */
+ 	if (old_gov) {
+ 		__cpufreq_governor(policy, CPUFREQ_GOV_STOP);
+ 		up_write(&policy->rwsem);
+ 		__cpufreq_governor(policy, CPUFREQ_GOV_POLICY_EXIT);
+ 		down_write(&policy->rwsem);
+ 	}
+ 
+ 	/* start new governor */
+ 	policy->governor = new_policy->governor;
+ 	if (!__cpufreq_governor(policy, CPUFREQ_GOV_POLICY_INIT)) {
+ 		if (!__cpufreq_governor(policy, CPUFREQ_GOV_START))
+ 			goto out;
+ 
+ 		up_write(&policy->rwsem);
+ 		__cpufreq_governor(policy, CPUFREQ_GOV_POLICY_EXIT);
+ 		down_write(&policy->rwsem);
+ 	}
+ 
+ 	/* new governor failed, so re-start old one */
+ 	pr_debug("starting governor %s failed\n", policy->governor->name);
+ 	if (old_gov) {
+ 		policy->governor = old_gov;
+ 		__cpufreq_governor(policy, CPUFREQ_GOV_POLICY_INIT);
+ 		__cpufreq_governor(policy, CPUFREQ_GOV_START);
+ 	}
+ 
+ 	return -EINVAL;
+ 
+  out:
+ 	pr_debug("governor: change or update limits\n");
+ 	return __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);
++>>>>>>> e5c87b762871 (cpufreq: Fix checkpatch errors and warnings)
  }
  
  /**
* Unmerged path drivers/cpufreq/cpufreq.c
