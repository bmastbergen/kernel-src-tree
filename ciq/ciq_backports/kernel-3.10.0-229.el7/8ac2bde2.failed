netfilter: log: protect nf_log_register against double registering

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Marcelo Leitner <mleitner@redhat.com>
commit 8ac2bde2a4a05c38e2bd733bea94507cb1461e06
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/8ac2bde2.failed

Currently, despite the comment right before the function,
nf_log_register allows registering two loggers on with the same type and
end up overwriting the previous register.

Not a real issue today as current tree doesn't have two loggers for the
same type but it's better to get this protected.

Also make sure that all of its callers do error checking.

	Signed-off-by: Marcelo Ricardo Leitner <mleitner@redhat.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 8ac2bde2a4a05c38e2bd733bea94507cb1461e06)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/netfilter/nf_log_arp.c
#	net/ipv4/netfilter/nf_log_ipv4.c
#	net/ipv6/netfilter/nf_log_ipv6.c
* Unmerged path net/ipv4/netfilter/nf_log_arp.c
* Unmerged path net/ipv4/netfilter/nf_log_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_log_ipv6.c
* Unmerged path net/ipv4/netfilter/nf_log_arp.c
* Unmerged path net/ipv4/netfilter/nf_log_ipv4.c
* Unmerged path net/ipv6/netfilter/nf_log_ipv6.c
diff --git a/net/netfilter/nf_log.c b/net/netfilter/nf_log.c
index 0b6b2c874199..e3127d363178 100644
--- a/net/netfilter/nf_log.c
+++ b/net/netfilter/nf_log.c
@@ -75,6 +75,7 @@ EXPORT_SYMBOL(nf_log_unset);
 int nf_log_register(u_int8_t pf, struct nf_logger *logger)
 {
 	int i;
+	int ret = 0;
 
 	if (pf >= ARRAY_SIZE(init_net.nf.nf_loggers))
 		return -EINVAL;
@@ -82,16 +83,25 @@ int nf_log_register(u_int8_t pf, struct nf_logger *logger)
 	mutex_lock(&nf_log_mutex);
 
 	if (pf == NFPROTO_UNSPEC) {
+		for (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++) {
+			if (rcu_access_pointer(loggers[i][logger->type])) {
+				ret = -EEXIST;
+				goto unlock;
+			}
+		}
 		for (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++)
 			rcu_assign_pointer(loggers[i][logger->type], logger);
 	} else {
-		/* register at end of list to honor first register win */
+		if (rcu_access_pointer(loggers[pf][logger->type])) {
+			ret = -EEXIST;
+			goto unlock;
+		}
 		rcu_assign_pointer(loggers[pf][logger->type], logger);
 	}
 
+unlock:
 	mutex_unlock(&nf_log_mutex);
-
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL(nf_log_register);
 
