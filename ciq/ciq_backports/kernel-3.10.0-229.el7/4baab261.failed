hyperv: Remove recv_pkt_list and lock

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Haiyang Zhang <haiyangz@microsoft.com>
commit 4baab26129e0540746744232022110dbe9e011e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/4baab261.failed

Removed recv_pkt_list and lock, and updated related code, so that
the locking overhead is reduced especially when multiple channels
are in use.

The recv_pkt_list isn't actually necessary because the packets are
processed sequentially in each channel. It has been replaced by a
local variable, and the related lock for this list is also removed.
The is_data_pkt field is not used in receive path, so its assignment
is cleaned up.

	Signed-off-by: Haiyang Zhang <haiyangz@microsoft.com>
	Reviewed-by: K. Y. Srinivasan <kys@microsoft.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4baab26129e0540746744232022110dbe9e011e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/hyperv/hyperv_net.h
#	drivers/net/hyperv/netvsc.c
#	drivers/net/hyperv/netvsc_drv.c
diff --cc drivers/net/hyperv/hyperv_net.h
index a2561fea6d21,a1af0f7711e2..000000000000
--- a/drivers/net/hyperv/hyperv_net.h
+++ b/drivers/net/hyperv/hyperv_net.h
@@@ -29,18 -28,99 +29,23 @@@
  #include <linux/hyperv.h>
  #include <linux/rndis.h>
  
 -/* RSS related */
 -#define OID_GEN_RECEIVE_SCALE_CAPABILITIES 0x00010203  /* query only */
 -#define OID_GEN_RECEIVE_SCALE_PARAMETERS 0x00010204  /* query and set */
 -
 -#define NDIS_OBJECT_TYPE_RSS_CAPABILITIES 0x88
 -#define NDIS_OBJECT_TYPE_RSS_PARAMETERS 0x89
 -
 -#define NDIS_RECEIVE_SCALE_CAPABILITIES_REVISION_2 2
 -#define NDIS_RECEIVE_SCALE_PARAMETERS_REVISION_2 2
 -
 -struct ndis_obj_header {
 -	u8 type;
 -	u8 rev;
 -	u16 size;
 -} __packed;
 -
 -/* ndis_recv_scale_cap/cap_flag */
 -#define NDIS_RSS_CAPS_MESSAGE_SIGNALED_INTERRUPTS 0x01000000
 -#define NDIS_RSS_CAPS_CLASSIFICATION_AT_ISR       0x02000000
 -#define NDIS_RSS_CAPS_CLASSIFICATION_AT_DPC       0x04000000
 -#define NDIS_RSS_CAPS_USING_MSI_X                 0x08000000
 -#define NDIS_RSS_CAPS_RSS_AVAILABLE_ON_PORTS      0x10000000
 -#define NDIS_RSS_CAPS_SUPPORTS_MSI_X              0x20000000
 -#define NDIS_RSS_CAPS_HASH_TYPE_TCP_IPV4          0x00000100
 -#define NDIS_RSS_CAPS_HASH_TYPE_TCP_IPV6          0x00000200
 -#define NDIS_RSS_CAPS_HASH_TYPE_TCP_IPV6_EX       0x00000400
 -
 -struct ndis_recv_scale_cap { /* NDIS_RECEIVE_SCALE_CAPABILITIES */
 -	struct ndis_obj_header hdr;
 -	u32 cap_flag;
 -	u32 num_int_msg;
 -	u32 num_recv_que;
 -	u16 num_indirect_tabent;
 -} __packed;
 -
 -
 -/* ndis_recv_scale_param flags */
 -#define NDIS_RSS_PARAM_FLAG_BASE_CPU_UNCHANGED     0x0001
 -#define NDIS_RSS_PARAM_FLAG_HASH_INFO_UNCHANGED    0x0002
 -#define NDIS_RSS_PARAM_FLAG_ITABLE_UNCHANGED       0x0004
 -#define NDIS_RSS_PARAM_FLAG_HASH_KEY_UNCHANGED     0x0008
 -#define NDIS_RSS_PARAM_FLAG_DISABLE_RSS            0x0010
 -
 -/* Hash info bits */
 -#define NDIS_HASH_FUNC_TOEPLITZ 0x00000001
 -#define NDIS_HASH_IPV4          0x00000100
 -#define NDIS_HASH_TCP_IPV4      0x00000200
 -#define NDIS_HASH_IPV6          0x00000400
 -#define NDIS_HASH_IPV6_EX       0x00000800
 -#define NDIS_HASH_TCP_IPV6      0x00001000
 -#define NDIS_HASH_TCP_IPV6_EX   0x00002000
 -
 -#define NDIS_RSS_INDIRECTION_TABLE_MAX_SIZE_REVISION_2 (128 * 4)
 -#define NDIS_RSS_HASH_SECRET_KEY_MAX_SIZE_REVISION_2   40
 -
 -#define ITAB_NUM 128
 -#define HASH_KEYLEN NDIS_RSS_HASH_SECRET_KEY_MAX_SIZE_REVISION_2
 -extern u8 netvsc_hash_key[];
 -
 -struct ndis_recv_scale_param { /* NDIS_RECEIVE_SCALE_PARAMETERS */
 -	struct ndis_obj_header hdr;
 -
 -	/* Qualifies the rest of the information */
 -	u16 flag;
 -
 -	/* The base CPU number to do receive processing. not used */
 -	u16 base_cpu_number;
 -
 -	/* This describes the hash function and type being enabled */
 -	u32 hashinfo;
 -
 -	/* The size of indirection table array */
 -	u16 indirect_tabsize;
 -
 -	/* The offset of the indirection table from the beginning of this
 -	 * structure
 -	 */
 -	u32 indirect_taboffset;
 -
 -	/* The size of the hash secret key */
 -	u16 hashkey_size;
 +/* Fwd declaration */
++<<<<<<< HEAD
 +struct hv_netvsc_packet;
  
 -	/* The offset of the secret key from the beginning of this structure */
 -	u32 kashkey_offset;
 +/* Represent the xfer page packet which contains 1 or more netvsc packet */
 +struct xferpage_packet {
 +	struct list_head list_ent;
 +	u32 status;
  
 -	u32 processor_masks_offset;
 -	u32 num_processor_masks;
 -	u32 processor_masks_entry_size;
 +	/* # of netvsc packets this xfer packet contains */
 +	u32 count;
  };
  
 -/* Fwd declaration */
++=======
+ struct ndis_tcp_ip_checksum_info;
+ 
++>>>>>>> 4baab26129e0 (hyperv: Remove recv_pkt_list and lock)
  /*
   * Represent netvsc packet which contains 1 RNDIS and 1 ethernet frame
   * within the RNDIS
@@@ -54,18 -133,10 +58,18 @@@ struct hv_netvsc_packet 
  	bool is_data_pkt;
  	u16 vlan_tci;
  
++<<<<<<< HEAD
 +	/*
 +	 * Valid only for receives when we break a xfer page packet
 +	 * into multiple netvsc packets
 +	 */
 +	struct xferpage_packet *xfer_page_pkt;
++=======
+ 	u16 q_idx;
+ 	struct vmbus_channel *channel;
++>>>>>>> 4baab26129e0 (hyperv: Remove recv_pkt_list and lock)
  
  	union {
- 		struct {
- 			u64 recv_completion_tid;
- 			void *recv_completion_ctx;
- 			void (*recv_completion)(void *context);
- 		} recv;
  		struct {
  			u64 send_completion_tid;
  			void *send_completion_ctx;
@@@ -521,11 -589,10 +525,8 @@@ struct nvsp_message 
  
  #define NETVSC_RECEIVE_BUFFER_ID		0xcafe
  
- /* Preallocated receive packets */
- #define NETVSC_RECEIVE_PACKETLIST_COUNT		256
- 
  #define NETVSC_PACKET_SIZE                      2048
  
 -#define VRSS_SEND_TAB_SIZE 16
 -
  /* Per netvsc channel-specific */
  struct netvsc_device {
  	struct hv_device *dev;
diff --cc drivers/net/hyperv/netvsc.c
index 9cc0753cff9d,b10334773b32..000000000000
--- a/drivers/net/hyperv/netvsc.c
+++ b/drivers/net/hyperv/netvsc.c
@@@ -417,11 -415,8 +416,16 @@@ int netvsc_device_remove(struct hv_devi
  	vmbus_close(device->channel);
  
  	/* Release all resources */
++<<<<<<< HEAD
 +	list_for_each_entry_safe(netvsc_packet, pos,
 +				 &net_device->recv_pkt_list, list_ent) {
 +		list_del(&netvsc_packet->list_ent);
 +		kfree(netvsc_packet);
 +	}
++=======
+ 	if (net_device->sub_cb_buf)
+ 		vfree(net_device->sub_cb_buf);
++>>>>>>> 4baab26129e0 (hyperv: Remove recv_pkt_list and lock)
  
  	kfree(net_device);
  	return 0;
@@@ -617,78 -634,20 +621,87 @@@ retry_send_cmplt
  	}
  }
  
++<<<<<<< HEAD
 +/* Send a receive completion packet to RNDIS device (ie NetVsp) */
 +static void netvsc_receive_completion(void *context)
 +{
 +	struct hv_netvsc_packet *packet = context;
 +	struct hv_device *device = packet->device;
 +	struct netvsc_device *net_device;
 +	u64 transaction_id = 0;
 +	bool fsend_receive_comp = false;
 +	unsigned long flags;
 +	struct net_device *ndev;
 +	u32 status = NVSP_STAT_NONE;
 +
 +	/*
 +	 * Even though it seems logical to do a GetOutboundNetDevice() here to
 +	 * send out receive completion, we are using GetInboundNetDevice()
 +	 * since we may have disable outbound traffic already.
 +	 */
 +	net_device = get_inbound_net_device(device);
 +	if (!net_device)
 +		return;
 +	ndev = net_device->ndev;
 +
 +	/* Overloading use of the lock. */
 +	spin_lock_irqsave(&net_device->recv_pkt_list_lock, flags);
 +
 +	if (packet->status != NVSP_STAT_SUCCESS)
 +		packet->xfer_page_pkt->status = NVSP_STAT_FAIL;
 +
 +	packet->xfer_page_pkt->count--;
 +
 +	/*
 +	 * Last one in the line that represent 1 xfer page packet.
 +	 * Return the xfer page packet itself to the freelist
 +	 */
 +	if (packet->xfer_page_pkt->count == 0) {
 +		fsend_receive_comp = true;
 +		transaction_id = packet->completion.recv.recv_completion_tid;
 +		status = packet->xfer_page_pkt->status;
 +		list_add_tail(&packet->xfer_page_pkt->list_ent,
 +			      &net_device->recv_pkt_list);
 +
 +	}
 +
 +	/* Put the packet back */
 +	list_add_tail(&packet->list_ent, &net_device->recv_pkt_list);
 +	spin_unlock_irqrestore(&net_device->recv_pkt_list_lock, flags);
 +
 +	/* Send a receive completion for the xfer page packet */
 +	if (fsend_receive_comp)
 +		netvsc_send_recv_completion(device, transaction_id, status);
 +
 +}
 +
 +static void netvsc_receive(struct hv_device *device,
 +			    struct vmpacket_descriptor *packet)
++=======
+ static void netvsc_receive(struct netvsc_device *net_device,
+ 			struct vmbus_channel *channel,
+ 			struct hv_device *device,
+ 			struct vmpacket_descriptor *packet)
++>>>>>>> 4baab26129e0 (hyperv: Remove recv_pkt_list and lock)
  {
 +	struct netvsc_device *net_device;
  	struct vmtransfer_page_packet_header *vmxferpage_packet;
  	struct nvsp_message *nvsp_packet;
- 	struct hv_netvsc_packet *netvsc_packet = NULL;
- 	/* struct netvsc_driver *netvscDriver; */
- 	struct xferpage_packet *xferpage_packet = NULL;
+ 	struct hv_netvsc_packet nv_pkt;
+ 	struct hv_netvsc_packet *netvsc_packet = &nv_pkt;
+ 	u32 status = NVSP_STAT_SUCCESS;
  	int i;
  	int count = 0;
- 	unsigned long flags;
  	struct net_device *ndev;
  
++<<<<<<< HEAD
 +	LIST_HEAD(listHead);
 +
 +	net_device = get_inbound_net_device(device);
 +	if (!net_device)
 +		return;
++=======
++>>>>>>> 4baab26129e0 (hyperv: Remove recv_pkt_list and lock)
  	ndev = net_device->ndev;
  
  	/*
@@@ -721,77 -680,14 +734,70 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	/*
 +	 * Grab free packets (range count + 1) to represent this xfer
 +	 * page packet. +1 to represent the xfer page packet itself.
 +	 * We grab it here so that we know exactly how many we can
 +	 * fulfil
 +	 */
 +	spin_lock_irqsave(&net_device->recv_pkt_list_lock, flags);
 +	while (!list_empty(&net_device->recv_pkt_list)) {
 +		list_move_tail(net_device->recv_pkt_list.next, &listHead);
 +		if (++count == vmxferpage_packet->range_cnt + 1)
 +			break;
 +	}
 +	spin_unlock_irqrestore(&net_device->recv_pkt_list_lock, flags);
 +
 +	/*
 +	 * We need at least 2 netvsc pkts (1 to represent the xfer
 +	 * page and at least 1 for the range) i.e. we can handled
 +	 * some of the xfer page packet ranges...
 +	 */
 +	if (count < 2) {
 +		netdev_err(ndev, "Got only %d netvsc pkt...needed "
 +			"%d pkts. Dropping this xfer page packet completely!\n",
 +			count, vmxferpage_packet->range_cnt + 1);
 +
 +		/* Return it to the freelist */
 +		spin_lock_irqsave(&net_device->recv_pkt_list_lock, flags);
 +		for (i = count; i != 0; i--) {
 +			list_move_tail(listHead.next,
 +				       &net_device->recv_pkt_list);
 +		}
 +		spin_unlock_irqrestore(&net_device->recv_pkt_list_lock,
 +				       flags);
 +
 +		netvsc_send_recv_completion(device,
 +					    vmxferpage_packet->d.trans_id,
 +					    NVSP_STAT_FAIL);
 +
 +		return;
 +	}
 +
 +	/* Remove the 1st packet to represent the xfer page packet itself */
 +	xferpage_packet = (struct xferpage_packet *)listHead.next;
 +	list_del(&xferpage_packet->list_ent);
 +	xferpage_packet->status = NVSP_STAT_SUCCESS;
 +
 +	/* This is how much we can satisfy */
 +	xferpage_packet->count = count - 1;
 +
 +	if (xferpage_packet->count != vmxferpage_packet->range_cnt) {
 +		netdev_err(ndev, "Needed %d netvsc pkts to satisfy "
 +			"this xfer page...got %d\n",
 +			vmxferpage_packet->range_cnt, xferpage_packet->count);
 +	}
++=======
+ 	count = vmxferpage_packet->range_cnt;
+ 	netvsc_packet->device = device;
+ 	netvsc_packet->channel = channel;
++>>>>>>> 4baab26129e0 (hyperv: Remove recv_pkt_list and lock)
  
  	/* Each range represents 1 RNDIS pkt that contains 1 ethernet frame */
- 	for (i = 0; i < (count - 1); i++) {
- 		netvsc_packet = (struct hv_netvsc_packet *)listHead.next;
- 		list_del(&netvsc_packet->list_ent);
- 
+ 	for (i = 0; i < count; i++) {
  		/* Initialize the netvsc packet */
  		netvsc_packet->status = NVSP_STAT_SUCCESS;
- 		netvsc_packet->xfer_page_pkt = xferpage_packet;
- 		netvsc_packet->completion.recv.recv_completion =
- 					netvsc_receive_completion;
- 		netvsc_packet->completion.recv.recv_completion_ctx =
- 					netvsc_packet;
- 		netvsc_packet->device = device;
- 		/* Save this so that we can send it back */
- 		netvsc_packet->completion.recv.recv_completion_tid =
- 					vmxferpage_packet->d.trans_id;
- 
  		netvsc_packet->data = (void *)((unsigned long)net_device->
  			recv_buf + vmxferpage_packet->ranges[i].byte_offset);
  		netvsc_packet->total_data_buflen =
@@@ -800,16 -696,53 +806,18 @@@
  		/* Pass it to the upper layer */
  		rndis_filter_receive(device, netvsc_packet);
  
- 		netvsc_receive_completion(netvsc_packet->
- 				completion.recv.recv_completion_ctx);
+ 		if (netvsc_packet->status != NVSP_STAT_SUCCESS)
+ 			status = NVSP_STAT_FAIL;
  	}
  
+ 	netvsc_send_recv_completion(device, channel, net_device,
+ 				    vmxferpage_packet->d.trans_id, status);
  }
  
 -
 -static void netvsc_send_table(struct hv_device *hdev,
 -			      struct vmpacket_descriptor *vmpkt)
 -{
 -	struct netvsc_device *nvscdev;
 -	struct net_device *ndev;
 -	struct nvsp_message *nvmsg;
 -	int i;
 -	u32 count, *tab;
 -
 -	nvscdev = get_outbound_net_device(hdev);
 -	if (!nvscdev)
 -		return;
 -	ndev = nvscdev->ndev;
 -
 -	nvmsg = (struct nvsp_message *)((unsigned long)vmpkt +
 -					(vmpkt->offset8 << 3));
 -
 -	if (nvmsg->hdr.msg_type != NVSP_MSG5_TYPE_SEND_INDIRECTION_TABLE)
 -		return;
 -
 -	count = nvmsg->msg.v5_msg.send_table.count;
 -	if (count != VRSS_SEND_TAB_SIZE) {
 -		netdev_err(ndev, "Received wrong send-table size:%u\n", count);
 -		return;
 -	}
 -
 -	tab = (u32 *)((unsigned long)&nvmsg->msg.v5_msg.send_table +
 -		      nvmsg->msg.v5_msg.send_table.offset);
 -
 -	for (i = 0; i < count; i++)
 -		nvscdev->send_table[i] = tab[i];
 -}
 -
 -void netvsc_channel_cb(void *context)
 +static void netvsc_channel_cb(void *context)
  {
  	int ret;
 -	struct vmbus_channel *channel = (struct vmbus_channel *)context;
 -	struct hv_device *device;
 +	struct hv_device *device = context;
  	struct netvsc_device *net_device;
  	u32 bytes_recvd;
  	u64 request_id;
@@@ -920,20 -851,10 +926,8 @@@ int netvsc_device_add(struct hv_device 
  	ndev = net_device->ndev;
  
  	/* Initialize the NetVSC channel extension */
- 	spin_lock_init(&net_device->recv_pkt_list_lock);
- 
- 	INIT_LIST_HEAD(&net_device->recv_pkt_list);
- 
- 	for (i = 0; i < NETVSC_RECEIVE_PACKETLIST_COUNT; i++) {
- 		packet = kzalloc(sizeof(struct hv_netvsc_packet), GFP_KERNEL);
- 		if (!packet)
- 			break;
- 
- 		list_add_tail(&packet->list_ent,
- 			      &net_device->recv_pkt_list);
- 	}
  	init_completion(&net_device->channel_init_wait);
  
 -	set_per_channel_state(device->channel, net_device->cb_buffer);
 -
  	/* Open the channel */
  	ret = vmbus_open(device->channel, ring_size * PAGE_SIZE,
  			 ring_size * PAGE_SIZE, NULL, 0,
diff --cc drivers/net/hyperv/netvsc_drv.c
index 854b31f1a85a,8f6d53a2ed95..000000000000
--- a/drivers/net/hyperv/netvsc_drv.c
+++ b/drivers/net/hyperv/netvsc_drv.c
@@@ -297,6 -638,10 +297,13 @@@ int netvsc_recv_callback(struct hv_devi
  		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
  				       packet->vlan_tci);
  
++<<<<<<< HEAD
++=======
+ 	skb_record_rx_queue(skb, packet->channel->
+ 			    offermsg.offer.sub_channel_index %
+ 			    net->real_num_rx_queues);
+ 
++>>>>>>> 4baab26129e0 (hyperv: Remove recv_pkt_list and lock)
  	net->stats.rx_packets++;
  	net->stats.rx_bytes += packet->total_data_buflen;
  
* Unmerged path drivers/net/hyperv/hyperv_net.h
* Unmerged path drivers/net/hyperv/netvsc.c
* Unmerged path drivers/net/hyperv/netvsc_drv.c
diff --git a/drivers/net/hyperv/rndis_filter.c b/drivers/net/hyperv/rndis_filter.c
index 4b3b201565af..444a56533469 100644
--- a/drivers/net/hyperv/rndis_filter.c
+++ b/drivers/net/hyperv/rndis_filter.c
@@ -402,8 +402,6 @@ static void rndis_filter_receive_data(struct rndis_device *dev,
 	pkt->total_data_buflen = rndis_pkt->data_len;
 	pkt->data = (void *)((unsigned long)pkt->data + data_offset);
 
-	pkt->is_data_pkt = true;
-
 	vlan = rndis_get_ppi(rndis_pkt, IEEE_8021Q_INFO);
 	if (vlan) {
 		pkt->vlan_tci = VLAN_TAG_PRESENT | vlan->vlanid |
