NFS: Fix an uninitialised pointer Oops in the writeback error path

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Trond Myklebust <trond.myklebust@primarydata.com>
commit 3caa0c6ed754d91b15266abf222498edbef982bd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/3caa0c6e.failed

SteveD reports the following Oops:
 RIP: 0010:[<ffffffffa053461d>]  [<ffffffffa053461d>] __put_nfs_open_context+0x1d/0x100 [nfs]
 RSP: 0018:ffff880fed687b90  EFLAGS: 00010286
 RAX: 0000000000000024 RBX: 0000000000000000 RCX: 0000000000000006
 RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
 RBP: ffff880fed687bc0 R08: 0000000000000092 R09: 000000000000047a
 R10: 0000000000000000 R11: ffff880fed6878d6 R12: ffff880fed687d20
 R13: ffff880fed687d20 R14: 0000000000000070 R15: ffffea000aa33ec0
 FS:  00007fce290f0740(0000) GS:ffff8807ffc60000(0000) knlGS:0000000000000000
 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
 CR2: 0000000000000070 CR3: 00000007f2e79000 CR4: 00000000000007e0
 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
 DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
 Stack:
  0000000000000000 ffff880036c5e510 ffff880fed687d20 ffff880fed687d20
  ffff880036c5e200 ffffea000aa33ec0 ffff880fed687bd0 ffffffffa0534710
  ffff880fed687be8 ffffffffa053d5f0 ffff880036c5e200 ffff880fed687c08
 Call Trace:
  [<ffffffffa0534710>] put_nfs_open_context+0x10/0x20 [nfs]
  [<ffffffffa053d5f0>] nfs_pgio_data_destroy+0x20/0x40 [nfs]
  [<ffffffffa053d672>] nfs_pgio_error+0x22/0x40 [nfs]
  [<ffffffffa053d8f4>] nfs_generic_pgio+0x74/0x2e0 [nfs]
  [<ffffffffa06b18c3>] pnfs_generic_pg_writepages+0x63/0x210 [nfsv4]
  [<ffffffffa053d579>] nfs_pageio_doio+0x19/0x50 [nfs]
  [<ffffffffa053eb84>] nfs_pageio_complete+0x24/0x30 [nfs]
  [<ffffffffa053cb25>] nfs_direct_write_schedule_iovec+0x115/0x1f0 [nfs]
  [<ffffffffa053675f>] ? nfs_get_lock_context+0x4f/0x120 [nfs]
  [<ffffffffa053d252>] nfs_file_direct_write+0x262/0x420 [nfs]
  [<ffffffffa0532d91>] nfs_file_write+0x131/0x1d0 [nfs]
  [<ffffffffa0532c60>] ? nfs_need_sync_write.isra.17+0x40/0x40 [nfs]
  [<ffffffff812127b8>] do_io_submit+0x3b8/0x840
  [<ffffffff81212c50>] SyS_io_submit+0x10/0x20
  [<ffffffff81610f29>] system_call_fastpath+0x16/0x1b

This is due to the calls to nfs_pgio_error() in nfs_generic_pgio(), which
happen before the nfs_pgio_header's open context is referenced in
nfs_pgio_rpcsetup().

	Reported-by: Steve Dickson <SteveD@redhat.com>
	Cc: stable@vger.kernel.org # 3.16.x
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 3caa0c6ed754d91b15266abf222498edbef982bd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/pagelist.c
diff --cc fs/nfs/pagelist.c
index 5f18707a0319,08085de879ed..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -307,6 -493,178 +307,181 @@@ size_t nfs_generic_pg_test(struct nfs_p
  }
  EXPORT_SYMBOL_GPL(nfs_generic_pg_test);
  
++<<<<<<< HEAD
++=======
+ struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *ops)
+ {
+ 	struct nfs_pgio_header *hdr = ops->rw_alloc_header();
+ 
+ 	if (hdr) {
+ 		INIT_LIST_HEAD(&hdr->pages);
+ 		spin_lock_init(&hdr->lock);
+ 		hdr->rw_ops = ops;
+ 	}
+ 	return hdr;
+ }
+ EXPORT_SYMBOL_GPL(nfs_pgio_header_alloc);
+ 
+ /*
+  * nfs_pgio_header_free - Free a read or write header
+  * @hdr: The header to free
+  */
+ void nfs_pgio_header_free(struct nfs_pgio_header *hdr)
+ {
+ 	hdr->rw_ops->rw_free_header(hdr);
+ }
+ EXPORT_SYMBOL_GPL(nfs_pgio_header_free);
+ 
+ /**
+  * nfs_pgio_data_destroy - make @hdr suitable for reuse
+  *
+  * Frees memory and releases refs from nfs_generic_pgio, so that it may
+  * be called again.
+  *
+  * @hdr: A header that has had nfs_generic_pgio called
+  */
+ void nfs_pgio_data_destroy(struct nfs_pgio_header *hdr)
+ {
+ 	if (hdr->args.context)
+ 		put_nfs_open_context(hdr->args.context);
+ 	if (hdr->page_array.pagevec != hdr->page_array.page_array)
+ 		kfree(hdr->page_array.pagevec);
+ }
+ EXPORT_SYMBOL_GPL(nfs_pgio_data_destroy);
+ 
+ /**
+  * nfs_pgio_rpcsetup - Set up arguments for a pageio call
+  * @hdr: The pageio hdr
+  * @count: Number of bytes to read
+  * @offset: Initial offset
+  * @how: How to commit data (writes only)
+  * @cinfo: Commit information for the call (writes only)
+  */
+ static void nfs_pgio_rpcsetup(struct nfs_pgio_header *hdr,
+ 			      unsigned int count, unsigned int offset,
+ 			      int how, struct nfs_commit_info *cinfo)
+ {
+ 	struct nfs_page *req = hdr->req;
+ 
+ 	/* Set up the RPC argument and reply structs
+ 	 * NB: take care not to mess about with hdr->commit et al. */
+ 
+ 	hdr->args.fh     = NFS_FH(hdr->inode);
+ 	hdr->args.offset = req_offset(req) + offset;
+ 	/* pnfs_set_layoutcommit needs this */
+ 	hdr->mds_offset = hdr->args.offset;
+ 	hdr->args.pgbase = req->wb_pgbase + offset;
+ 	hdr->args.pages  = hdr->page_array.pagevec;
+ 	hdr->args.count  = count;
+ 	hdr->args.context = get_nfs_open_context(req->wb_context);
+ 	hdr->args.lock_context = req->wb_lock_context;
+ 	hdr->args.stable  = NFS_UNSTABLE;
+ 	switch (how & (FLUSH_STABLE | FLUSH_COND_STABLE)) {
+ 	case 0:
+ 		break;
+ 	case FLUSH_COND_STABLE:
+ 		if (nfs_reqs_to_commit(cinfo))
+ 			break;
+ 	default:
+ 		hdr->args.stable = NFS_FILE_SYNC;
+ 	}
+ 
+ 	hdr->res.fattr   = &hdr->fattr;
+ 	hdr->res.count   = count;
+ 	hdr->res.eof     = 0;
+ 	hdr->res.verf    = &hdr->verf;
+ 	nfs_fattr_init(&hdr->fattr);
+ }
+ 
+ /**
+  * nfs_pgio_prepare - Prepare pageio hdr to go over the wire
+  * @task: The current task
+  * @calldata: pageio header to prepare
+  */
+ static void nfs_pgio_prepare(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs_pgio_header *hdr = calldata;
+ 	int err;
+ 	err = NFS_PROTO(hdr->inode)->pgio_rpc_prepare(task, hdr);
+ 	if (err)
+ 		rpc_exit(task, err);
+ }
+ 
+ int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,
+ 		      const struct rpc_call_ops *call_ops, int how, int flags)
+ {
+ 	struct rpc_task *task;
+ 	struct rpc_message msg = {
+ 		.rpc_argp = &hdr->args,
+ 		.rpc_resp = &hdr->res,
+ 		.rpc_cred = hdr->cred,
+ 	};
+ 	struct rpc_task_setup task_setup_data = {
+ 		.rpc_client = clnt,
+ 		.task = &hdr->task,
+ 		.rpc_message = &msg,
+ 		.callback_ops = call_ops,
+ 		.callback_data = hdr,
+ 		.workqueue = nfsiod_workqueue,
+ 		.flags = RPC_TASK_ASYNC | flags,
+ 	};
+ 	int ret = 0;
+ 
+ 	hdr->rw_ops->rw_initiate(hdr, &msg, &task_setup_data, how);
+ 
+ 	dprintk("NFS: %5u initiated pgio call "
+ 		"(req %s/%llu, %u bytes @ offset %llu)\n",
+ 		hdr->task.tk_pid,
+ 		hdr->inode->i_sb->s_id,
+ 		(unsigned long long)NFS_FILEID(hdr->inode),
+ 		hdr->args.count,
+ 		(unsigned long long)hdr->args.offset);
+ 
+ 	task = rpc_run_task(&task_setup_data);
+ 	if (IS_ERR(task)) {
+ 		ret = PTR_ERR(task);
+ 		goto out;
+ 	}
+ 	if (how & FLUSH_SYNC) {
+ 		ret = rpc_wait_for_completion_task(task);
+ 		if (ret == 0)
+ 			ret = task->tk_status;
+ 	}
+ 	rpc_put_task(task);
+ out:
+ 	return ret;
+ }
+ EXPORT_SYMBOL_GPL(nfs_initiate_pgio);
+ 
+ /**
+  * nfs_pgio_error - Clean up from a pageio error
+  * @desc: IO descriptor
+  * @hdr: pageio header
+  */
+ static int nfs_pgio_error(struct nfs_pageio_descriptor *desc,
+ 			  struct nfs_pgio_header *hdr)
+ {
+ 	set_bit(NFS_IOHDR_REDO, &hdr->flags);
+ 	nfs_pgio_data_destroy(hdr);
+ 	hdr->completion_ops->completion(hdr);
+ 	desc->pg_completion_ops->error_cleanup(&desc->pg_list);
+ 	return -ENOMEM;
+ }
+ 
+ /**
+  * nfs_pgio_release - Release pageio data
+  * @calldata: The pageio header to release
+  */
+ static void nfs_pgio_release(void *calldata)
+ {
+ 	struct nfs_pgio_header *hdr = calldata;
+ 	if (hdr->rw_ops->rw_release)
+ 		hdr->rw_ops->rw_release(hdr);
+ 	nfs_pgio_data_destroy(hdr);
+ 	hdr->completion_ops->completion(hdr);
+ }
+ 
++>>>>>>> 3caa0c6ed754 (NFS: Fix an uninitialised pointer Oops in the writeback error path)
  /**
   * nfs_pageio_init - initialise a page io descriptor
   * @desc: pointer to descriptor
* Unmerged path fs/nfs/pagelist.c
