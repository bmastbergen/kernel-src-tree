drm/radeon: sync all BOs involved in a CS

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [drm] radeon: sync all BOs involved in a CS (Rob Clark) [1173317]
Rebuild_FUZZ: 94.87%
commit-author Christian König <christian.koenig@amd.com>
commit c1f0a9c2d461a50c1a4c36d01b73c1325519b5fa
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/c1f0a9c2.failed

Not just the userspace relocs, otherwise we won't wait
for a swapped out page tables to be swapped in again.

	Signed-off-by: Christian König <christian.koenig@amd.com>
	Cc: stable@vger.kernel.org
	Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
(cherry picked from commit c1f0a9c2d461a50c1a4c36d01b73c1325519b5fa)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/gpu/drm/radeon/radeon_cs.c
diff --cc drivers/gpu/drm/radeon/radeon_cs.c
index 80285e35bc65,f5e0a696d2fe..000000000000
--- a/drivers/gpu/drm/radeon/radeon_cs.c
+++ b/drivers/gpu/drm/radeon/radeon_cs.c
@@@ -151,16 -249,22 +151,33 @@@ static int radeon_cs_get_ring(struct ra
  	return 0;
  }
  
 -static int radeon_cs_sync_rings(struct radeon_cs_parser *p)
 +static void radeon_cs_sync_rings(struct radeon_cs_parser *p)
  {
++<<<<<<< HEAD
 +	int i;
 +
 +	for (i = 0; i < p->nrelocs; i++) {
 +		if (!p->relocs[i].robj)
 +			continue;
 +
 +		radeon_ib_sync_to(&p->ib, p->relocs[i].robj->tbo.sync_obj);
 +	}
++=======
+ 	struct radeon_cs_reloc *reloc;
+ 	int r;
+ 
+ 	list_for_each_entry(reloc, &p->validated, tv.head) {
+ 		struct reservation_object *resv;
+ 
+ 		resv = reloc->robj->tbo.resv;
+ 		r = radeon_sync_resv(p->rdev, &p->ib.sync, resv,
+ 				     reloc->tv.shared);
+ 
+ 		if (r)
+ 			return r;
+ 	}
+ 	return 0;
++>>>>>>> c1f0a9c2d461 (drm/radeon: sync all BOs involved in a CS)
  }
  
  /* XXX: note that this is called from the legacy UMS CS ioctl as well */
@@@ -398,26 -492,53 +415,37 @@@ static int radeon_cs_ib_chunk(struct ra
  	return r;
  }
  
 -static int radeon_bo_vm_update_pte(struct radeon_cs_parser *p,
 +static int radeon_bo_vm_update_pte(struct radeon_cs_parser *parser,
  				   struct radeon_vm *vm)
  {
 -	struct radeon_device *rdev = p->rdev;
 -	struct radeon_bo_va *bo_va;
 -	int i, r;
 +	struct radeon_device *rdev = parser->rdev;
 +	struct radeon_bo_list *lobj;
 +	struct radeon_bo *bo;
 +	int r;
  
 -	r = radeon_vm_update_page_directory(rdev, vm);
 -	if (r)
 +	r = radeon_vm_bo_update_pte(rdev, vm, rdev->ring_tmp_bo.bo, &rdev->ring_tmp_bo.bo->tbo.mem);
 +	if (r) {
  		return r;
++<<<<<<< HEAD
++=======
+ 
+ 	r = radeon_vm_clear_freed(rdev, vm);
+ 	if (r)
+ 		return r;
+ 
+ 	if (vm->ib_bo_va == NULL) {
+ 		DRM_ERROR("Tmp BO not in VM!\n");
+ 		return -EINVAL;
++>>>>>>> c1f0a9c2d461 (drm/radeon: sync all BOs involved in a CS)
  	}
 -
 -	r = radeon_vm_bo_update(rdev, vm->ib_bo_va,
 -				&rdev->ring_tmp_bo.bo->tbo.mem);
 -	if (r)
 -		return r;
 -
 -	for (i = 0; i < p->nrelocs; i++) {
 -		struct radeon_bo *bo;
 -
 -		/* ignore duplicates */
 -		if (p->relocs_ptr[i] != &p->relocs[i])
 -			continue;
 -
 -		bo = p->relocs[i].robj;
 -		bo_va = radeon_vm_bo_find(vm, bo);
 -		if (bo_va == NULL) {
 -			dev_err(rdev->dev, "bo %p not in vm %p\n", bo, vm);
 -			return -EINVAL;
 -		}
 -
 -		r = radeon_vm_bo_update(rdev, bo_va, &bo->tbo.mem);
 -		if (r)
 +	list_for_each_entry(lobj, &parser->validated, tv.head) {
 +		bo = lobj->bo;
 +		r = radeon_vm_bo_update_pte(parser->rdev, vm, bo, &bo->tbo.mem);
 +		if (r) {
  			return r;
 -
 -		radeon_sync_fence(&p->ib.sync, bo_va->last_pt_update);
 +		}
  	}
 -
 -	return radeon_vm_clear_invalids(rdev, vm);
 +	return 0;
  }
  
  static int radeon_cs_ib_vm_chunk(struct radeon_device *rdev,
* Unmerged path drivers/gpu/drm/radeon/radeon_cs.c
