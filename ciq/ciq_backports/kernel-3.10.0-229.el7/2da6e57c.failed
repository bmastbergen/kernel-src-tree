x86/efi: Remove unused variables in __map_region()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [firmware] efi: Remove unused variables in __map_region() (Dave Young) [1080109]
Rebuild_FUZZ: 95.83%
commit-author Dave Young <dyoung@redhat.com>
commit 2da6e57cce14a1c3b0692d6f877b72e185110e2e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2da6e57c.failed

variables size and end is useless in this function, thus remove them.

	Reported-by: Toshi Kani <toshi.kani@hp.com>
	Tested-by: Toshi Kani <toshi.kani@hp.com>
	Signed-off-by: Dave Young <dyoung@redhat.com>
	Acked-by: Borislav Petkov <bp@suse.de>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit 2da6e57cce14a1c3b0692d6f877b72e185110e2e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/platform/efi/efi_64.c
diff --cc arch/x86/platform/efi/efi_64.c
index 39a0e7f1f0a3,c5a6491d95da..000000000000
--- a/arch/x86/platform/efi/efi_64.c
+++ b/arch/x86/platform/efi/efi_64.c
@@@ -94,6 -119,86 +94,89 @@@ void __init efi_call_phys_epilog(void
  	early_code_mapping_set_exec(0);
  }
  
++<<<<<<< HEAD
++=======
+ /*
+  * Add low kernel mappings for passing arguments to EFI functions.
+  */
+ void efi_sync_low_kernel_mappings(void)
+ {
+ 	unsigned num_pgds;
+ 	pgd_t *pgd = (pgd_t *)__va(real_mode_header->trampoline_pgd);
+ 
+ 	if (efi_enabled(EFI_OLD_MEMMAP))
+ 		return;
+ 
+ 	num_pgds = pgd_index(MODULES_END - 1) - pgd_index(PAGE_OFFSET);
+ 
+ 	memcpy(pgd + pgd_index(PAGE_OFFSET),
+ 		init_mm.pgd + pgd_index(PAGE_OFFSET),
+ 		sizeof(pgd_t) * num_pgds);
+ }
+ 
+ void efi_setup_page_tables(void)
+ {
+ 	efi_scratch.efi_pgt = (pgd_t *)(unsigned long)real_mode_header->trampoline_pgd;
+ 
+ 	if (!efi_enabled(EFI_OLD_MEMMAP))
+ 		efi_scratch.use_pgd = true;
+ }
+ 
+ static void __init __map_region(efi_memory_desc_t *md, u64 va)
+ {
+ 	pgd_t *pgd = (pgd_t *)__va(real_mode_header->trampoline_pgd);
+ 	unsigned long pf = 0;
+ 
+ 	if (!(md->attribute & EFI_MEMORY_WB))
+ 		pf |= _PAGE_PCD;
+ 
+ 	if (kernel_map_pages_in_pgd(pgd, md->phys_addr, va, md->num_pages, pf))
+ 		pr_warn("Error mapping PA 0x%llx -> VA 0x%llx!\n",
+ 			   md->phys_addr, va);
+ }
+ 
+ void __init efi_map_region(efi_memory_desc_t *md)
+ {
+ 	unsigned long size = md->num_pages << PAGE_SHIFT;
+ 	u64 pa = md->phys_addr;
+ 
+ 	if (efi_enabled(EFI_OLD_MEMMAP))
+ 		return old_map_region(md);
+ 
+ 	/*
+ 	 * Make sure the 1:1 mappings are present as a catch-all for b0rked
+ 	 * firmware which doesn't update all internal pointers after switching
+ 	 * to virtual mode and would otherwise crap on us.
+ 	 */
+ 	__map_region(md, md->phys_addr);
+ 
+ 	efi_va -= size;
+ 
+ 	/* Is PA 2M-aligned? */
+ 	if (!(pa & (PMD_SIZE - 1))) {
+ 		efi_va &= PMD_MASK;
+ 	} else {
+ 		u64 pa_offset = pa & (PMD_SIZE - 1);
+ 		u64 prev_va = efi_va;
+ 
+ 		/* get us the same offset within this 2M page */
+ 		efi_va = (efi_va & PMD_MASK) + pa_offset;
+ 
+ 		if (efi_va > prev_va)
+ 			efi_va -= PMD_SIZE;
+ 	}
+ 
+ 	if (efi_va < EFI_VA_END) {
+ 		pr_warn(FW_WARN "VA address range overflow!\n");
+ 		return;
+ 	}
+ 
+ 	/* Do the VA map */
+ 	__map_region(md, efi_va);
+ 	md->virt_addr = efi_va;
+ }
+ 
++>>>>>>> 2da6e57cce14 (x86/efi: Remove unused variables in __map_region())
  void __iomem *__init efi_ioremap(unsigned long phys_addr, unsigned long size,
  				 u32 type, u64 attribute)
  {
* Unmerged path arch/x86/platform/efi/efi_64.c
