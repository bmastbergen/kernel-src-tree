NFS: Create a common pgio_error function

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Anna Schumaker <Anna.Schumaker@netapp.com>
commit 844c9e691d8723853ca8f2de0207683538645824
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/844c9e69.failed

At this point, the read and write versions of this function look
identical so both should use the same function.

	Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
	Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>
(cherry picked from commit 844c9e691d8723853ca8f2de0207683538645824)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/nfs/internal.h
#	fs/nfs/pagelist.c
#	fs/nfs/read.c
#	fs/nfs/write.c
diff --cc fs/nfs/internal.h
index 96bd22580dbf,a4b9e754756b..000000000000
--- a/fs/nfs/internal.h
+++ b/fs/nfs/internal.h
@@@ -238,6 -237,15 +238,18 @@@ extern void nfs_pgheader_init(struct nf
  void nfs_set_pgio_error(struct nfs_pgio_header *hdr, int error, loff_t pos);
  int nfs_iocounter_wait(struct nfs_io_counter *c);
  
++<<<<<<< HEAD
++=======
+ extern const struct rpc_call_ops nfs_pgio_common_ops;
+ struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *);
+ void nfs_rw_header_free(struct nfs_pgio_header *);
+ struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *, unsigned int);
+ void nfs_pgio_data_release(struct nfs_pgio_data *);
+ int nfs_pgio_error(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
+ void nfs_pgio_rpcsetup(struct nfs_pgio_data *, unsigned int, unsigned int, int,
+ 		       struct nfs_commit_info *);
+ 
++>>>>>>> 844c9e691d87 (NFS: Create a common pgio_error function)
  static inline void nfs_iocounter_init(struct nfs_io_counter *c)
  {
  	c->flags = 0;
diff --cc fs/nfs/pagelist.c
index 2ffebf2081ce,b0a98daae14c..000000000000
--- a/fs/nfs/pagelist.c
+++ b/fs/nfs/pagelist.c
@@@ -295,6 -297,187 +295,190 @@@ bool nfs_generic_pg_test(struct nfs_pag
  }
  EXPORT_SYMBOL_GPL(nfs_generic_pg_test);
  
++<<<<<<< HEAD
++=======
+ static inline struct nfs_rw_header *NFS_RW_HEADER(struct nfs_pgio_header *hdr)
+ {
+ 	return container_of(hdr, struct nfs_rw_header, header);
+ }
+ 
+ /**
+  * nfs_rw_header_alloc - Allocate a header for a read or write
+  * @ops: Read or write function vector
+  */
+ struct nfs_rw_header *nfs_rw_header_alloc(const struct nfs_rw_ops *ops)
+ {
+ 	struct nfs_rw_header *header = ops->rw_alloc_header();
+ 
+ 	if (header) {
+ 		struct nfs_pgio_header *hdr = &header->header;
+ 
+ 		INIT_LIST_HEAD(&hdr->pages);
+ 		INIT_LIST_HEAD(&hdr->rpc_list);
+ 		spin_lock_init(&hdr->lock);
+ 		atomic_set(&hdr->refcnt, 0);
+ 		hdr->rw_ops = ops;
+ 	}
+ 	return header;
+ }
+ EXPORT_SYMBOL_GPL(nfs_rw_header_alloc);
+ 
+ /*
+  * nfs_rw_header_free - Free a read or write header
+  * @hdr: The header to free
+  */
+ void nfs_rw_header_free(struct nfs_pgio_header *hdr)
+ {
+ 	hdr->rw_ops->rw_free_header(NFS_RW_HEADER(hdr));
+ }
+ EXPORT_SYMBOL_GPL(nfs_rw_header_free);
+ 
+ /**
+  * nfs_pgio_data_alloc - Allocate pageio data
+  * @hdr: The header making a request
+  * @pagecount: Number of pages to create
+  */
+ struct nfs_pgio_data *nfs_pgio_data_alloc(struct nfs_pgio_header *hdr,
+ 					  unsigned int pagecount)
+ {
+ 	struct nfs_pgio_data *data, *prealloc;
+ 
+ 	prealloc = &NFS_RW_HEADER(hdr)->rpc_data;
+ 	if (prealloc->header == NULL)
+ 		data = prealloc;
+ 	else
+ 		data = kzalloc(sizeof(*data), GFP_KERNEL);
+ 	if (!data)
+ 		goto out;
+ 
+ 	if (nfs_pgarray_set(&data->pages, pagecount)) {
+ 		data->header = hdr;
+ 		atomic_inc(&hdr->refcnt);
+ 	} else {
+ 		if (data != prealloc)
+ 			kfree(data);
+ 		data = NULL;
+ 	}
+ out:
+ 	return data;
+ }
+ 
+ /**
+  * nfs_pgio_data_release - Properly free pageio data
+  * @data: The data to release
+  */
+ void nfs_pgio_data_release(struct nfs_pgio_data *data)
+ {
+ 	struct nfs_pgio_header *hdr = data->header;
+ 	struct nfs_rw_header *pageio_header = NFS_RW_HEADER(hdr);
+ 
+ 	put_nfs_open_context(data->args.context);
+ 	if (data->pages.pagevec != data->pages.page_array)
+ 		kfree(data->pages.pagevec);
+ 	if (data == &pageio_header->rpc_data) {
+ 		data->header = NULL;
+ 		data = NULL;
+ 	}
+ 	if (atomic_dec_and_test(&hdr->refcnt))
+ 		hdr->completion_ops->completion(hdr);
+ 	/* Note: we only free the rpc_task after callbacks are done.
+ 	 * See the comment in rpc_free_task() for why
+ 	 */
+ 	kfree(data);
+ }
+ EXPORT_SYMBOL_GPL(nfs_pgio_data_release);
+ 
+ /**
+  * nfs_pgio_rpcsetup - Set up arguments for a pageio call
+  * @data: The pageio data
+  * @count: Number of bytes to read
+  * @offset: Initial offset
+  * @how: How to commit data (writes only)
+  * @cinfo: Commit information for the call (writes only)
+  */
+ void nfs_pgio_rpcsetup(struct nfs_pgio_data *data,
+ 			      unsigned int count, unsigned int offset,
+ 			      int how, struct nfs_commit_info *cinfo)
+ {
+ 	struct nfs_page *req = data->header->req;
+ 
+ 	/* Set up the RPC argument and reply structs
+ 	 * NB: take care not to mess about with data->commit et al. */
+ 
+ 	data->args.fh     = NFS_FH(data->header->inode);
+ 	data->args.offset = req_offset(req) + offset;
+ 	/* pnfs_set_layoutcommit needs this */
+ 	data->mds_offset = data->args.offset;
+ 	data->args.pgbase = req->wb_pgbase + offset;
+ 	data->args.pages  = data->pages.pagevec;
+ 	data->args.count  = count;
+ 	data->args.context = get_nfs_open_context(req->wb_context);
+ 	data->args.lock_context = req->wb_lock_context;
+ 	data->args.stable  = NFS_UNSTABLE;
+ 	switch (how & (FLUSH_STABLE | FLUSH_COND_STABLE)) {
+ 	case 0:
+ 		break;
+ 	case FLUSH_COND_STABLE:
+ 		if (nfs_reqs_to_commit(cinfo))
+ 			break;
+ 	default:
+ 		data->args.stable = NFS_FILE_SYNC;
+ 	}
+ 
+ 	data->res.fattr   = &data->fattr;
+ 	data->res.count   = count;
+ 	data->res.eof     = 0;
+ 	data->res.verf    = &data->verf;
+ 	nfs_fattr_init(&data->fattr);
+ }
+ 
+ /**
+  * nfs_pgio_prepare - Prepare pageio data to go over the wire
+  * @task: The current task
+  * @calldata: pageio data to prepare
+  */
+ static void nfs_pgio_prepare(struct rpc_task *task, void *calldata)
+ {
+ 	struct nfs_pgio_data *data = calldata;
+ 	int err;
+ 	err = NFS_PROTO(data->header->inode)->pgio_rpc_prepare(task, data);
+ 	if (err)
+ 		rpc_exit(task, err);
+ }
+ 
+ /**
+  * nfs_pgio_error - Clean up from a pageio error
+  * @desc: IO descriptor
+  * @hdr: pageio header
+  */
+ int nfs_pgio_error(struct nfs_pageio_descriptor *desc,
+ 			  struct nfs_pgio_header *hdr)
+ {
+ 	struct nfs_pgio_data *data;
+ 
+ 	set_bit(NFS_IOHDR_REDO, &hdr->flags);
+ 	while (!list_empty(&hdr->rpc_list)) {
+ 		data = list_first_entry(&hdr->rpc_list, struct nfs_pgio_data, list);
+ 		list_del(&data->list);
+ 		nfs_pgio_data_release(data);
+ 	}
+ 	desc->pg_completion_ops->error_cleanup(&desc->pg_list);
+ 	return -ENOMEM;
+ }
+ 
+ /**
+  * nfs_pgio_release - Release pageio data
+  * @calldata: The pageio data to release
+  */
+ static void nfs_pgio_release(void *calldata)
+ {
+ 	struct nfs_pgio_data *data = calldata;
+ 	if (data->header->rw_ops->rw_release)
+ 		data->header->rw_ops->rw_release(data);
+ 	nfs_pgio_data_release(data);
+ }
+ 
++>>>>>>> 844c9e691d87 (NFS: Create a common pgio_error function)
  /**
   * nfs_pageio_init - initialise a page io descriptor
   * @desc: pointer to descriptor
diff --cc fs/nfs/read.c
index 473bba35a2cb,64f8eefec76a..000000000000
--- a/fs/nfs/read.c
+++ b/fs/nfs/read.c
@@@ -319,19 -237,6 +319,22 @@@ static const struct nfs_pgio_completion
  	.completion = nfs_read_completion,
  };
  
++<<<<<<< HEAD
 +static void nfs_pagein_error(struct nfs_pageio_descriptor *desc,
 +		struct nfs_pgio_header *hdr)
 +{
 +	set_bit(NFS_IOHDR_REDO, &hdr->flags);
 +	while (!list_empty(&hdr->rpc_list)) {
 +		struct nfs_read_data *data = list_first_entry(&hdr->rpc_list,
 +				struct nfs_read_data, list);
 +		list_del(&data->list);
 +		nfs_readdata_release(data);
 +	}
 +	desc->pg_completion_ops->error_cleanup(&desc->pg_list);
 +}
 +
++=======
++>>>>>>> 844c9e691d87 (NFS: Create a common pgio_error function)
  /*
   * Generate multiple requests to fill a single page.
   *
@@@ -359,13 -264,11 +362,19 @@@ static int nfs_pagein_multi(struct nfs_
  	do {
  		size_t len = min(nbytes,rsize);
  
++<<<<<<< HEAD
 +		data = nfs_readdata_alloc(hdr, 1);
 +		if (!data) {
 +			nfs_pagein_error(desc, hdr);
 +			return -ENOMEM;
 +		}
++=======
+ 		data = nfs_pgio_data_alloc(hdr, 1);
+ 		if (!data)
+ 			return nfs_pgio_error(desc, hdr);
++>>>>>>> 844c9e691d87 (NFS: Create a common pgio_error function)
  		data->pages.pagevec[0] = page;
 -		nfs_pgio_rpcsetup(data, len, offset, 0, NULL);
 +		nfs_read_rpcsetup(data, len, offset);
  		list_add(&data->list, &hdr->rpc_list);
  		nbytes -= len;
  		offset += len;
@@@ -382,15 -285,13 +391,13 @@@ static int nfs_pagein_one(struct nfs_pa
  {
  	struct nfs_page		*req;
  	struct page		**pages;
 -	struct nfs_pgio_data	*data;
 +	struct nfs_read_data    *data;
  	struct list_head *head = &desc->pg_list;
  
 -	data = nfs_pgio_data_alloc(hdr, nfs_page_array_len(desc->pg_base,
 +	data = nfs_readdata_alloc(hdr, nfs_page_array_len(desc->pg_base,
  							  desc->pg_count));
- 	if (!data) {
- 		nfs_pagein_error(desc, hdr);
- 		return -ENOMEM;
- 	}
+ 	if (!data)
+ 		return nfs_pgio_error(desc, hdr);
  
  	pages = data->pages.pagevec;
  	while (!list_empty(head)) {
diff --cc fs/nfs/write.c
index f9fc82c305d1,02d088b1d8e4..000000000000
--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@@ -1141,19 -1044,6 +1141,22 @@@ static const struct nfs_pgio_completion
  	.completion = nfs_write_completion,
  };
  
++<<<<<<< HEAD
 +static void nfs_flush_error(struct nfs_pageio_descriptor *desc,
 +		struct nfs_pgio_header *hdr)
 +{
 +	set_bit(NFS_IOHDR_REDO, &hdr->flags);
 +	while (!list_empty(&hdr->rpc_list)) {
 +		struct nfs_write_data *data = list_first_entry(&hdr->rpc_list,
 +				struct nfs_write_data, list);
 +		list_del(&data->list);
 +		nfs_writedata_release(data);
 +	}
 +	desc->pg_completion_ops->error_cleanup(&desc->pg_list);
 +}
 +
++=======
++>>>>>>> 844c9e691d87 (NFS: Create a common pgio_error function)
  /*
   * Generate multiple small requests to write out a single
   * contiguous dirty area on one page.
@@@ -1182,13 -1072,11 +1185,19 @@@ static int nfs_flush_multi(struct nfs_p
  	do {
  		size_t len = min(nbytes, wsize);
  
++<<<<<<< HEAD
 +		data = nfs_writedata_alloc(hdr, 1);
 +		if (!data) {
 +			nfs_flush_error(desc, hdr);
 +			return -ENOMEM;
 +		}
++=======
+ 		data = nfs_pgio_data_alloc(hdr, 1);
+ 		if (!data)
+ 			return nfs_pgio_error(desc, hdr);
++>>>>>>> 844c9e691d87 (NFS: Create a common pgio_error function)
  		data->pages.pagevec[0] = page;
 -		nfs_pgio_rpcsetup(data, len, offset, desc->pg_ioflags, &cinfo);
 +		nfs_write_rpcsetup(data, len, offset, desc->pg_ioflags, &cinfo);
  		list_add(&data->list, &hdr->rpc_list);
  		requests++;
  		nbytes -= len;
@@@ -1217,12 -1105,10 +1226,10 @@@ static int nfs_flush_one(struct nfs_pag
  	struct list_head *head = &desc->pg_list;
  	struct nfs_commit_info cinfo;
  
 -	data = nfs_pgio_data_alloc(hdr, nfs_page_array_len(desc->pg_base,
 +	data = nfs_writedata_alloc(hdr, nfs_page_array_len(desc->pg_base,
  							   desc->pg_count));
- 	if (!data) {
- 		nfs_flush_error(desc, hdr);
- 		return -ENOMEM;
- 	}
+ 	if (!data)
+ 		return nfs_pgio_error(desc, hdr);
  
  	nfs_init_cinfo(&cinfo, desc->pg_inode, desc->pg_dreq);
  	pages = data->pages.pagevec;
* Unmerged path fs/nfs/internal.h
* Unmerged path fs/nfs/pagelist.c
* Unmerged path fs/nfs/read.c
* Unmerged path fs/nfs/write.c
