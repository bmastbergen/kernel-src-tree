cpufreq: unlock correct rwsem while updating policy->cpu

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] unlock correct rwsem while updating policy->cpu (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 91.26%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 8efd57657d8ef666810b55e609da72de92314dc4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/8efd5765.failed

Current code looks like this:

        WARN_ON(lock_policy_rwsem_write(cpu));
        update_policy_cpu(policy, new_cpu);
        unlock_policy_rwsem_write(cpu);

{lock|unlock}_policy_rwsem_write(cpu) takes/releases policy->cpu's rwsem.
Because cpu is changing with the call to update_policy_cpu(), the
unlock_policy_rwsem_write() will release the incorrect lock.

The right solution would be to release the same lock as was taken earlier. Also
update_policy_cpu() was also called from cpufreq_add_dev() without any locks and
so its better if we move this locking to inside update_policy_cpu().

This patch fixes a regression introduced in 3.12 by commit f9ba680d23
(cpufreq: Extract the handover of policy cpu to a helper function).

Reported-and-tested-by: Jon Medhurst<tixy@linaro.org>
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 8efd57657d8ef666810b55e609da72de92314dc4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/cpufreq.c
diff --cc drivers/cpufreq/cpufreq.c
index 806f30d4db8c,82ecbe39dfb0..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -911,16 -901,80 +911,93 @@@ static int cpufreq_add_policy_cpu(unsig
  }
  #endif
  
++<<<<<<< HEAD
 +/**
 + * cpufreq_add_dev - add a CPU device
 + *
 + * Adds the cpufreq interface for a CPU device.
 + *
 + * The Oracle says: try running cpufreq registration/unregistration concurrently
 + * with with cpu hotplugging and all hell will break loose. Tried to clean this
 + * mess up, but more thorough testing is needed. - Mathieu
 + */
 +static int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)
++=======
+ static struct cpufreq_policy *cpufreq_policy_restore(unsigned int cpu)
+ {
+ 	struct cpufreq_policy *policy;
+ 	unsigned long flags;
+ 
+ 	read_lock_irqsave(&cpufreq_driver_lock, flags);
+ 
+ 	policy = per_cpu(cpufreq_cpu_data_fallback, cpu);
+ 
+ 	read_unlock_irqrestore(&cpufreq_driver_lock, flags);
+ 
+ 	return policy;
+ }
+ 
+ static struct cpufreq_policy *cpufreq_policy_alloc(void)
+ {
+ 	struct cpufreq_policy *policy;
+ 
+ 	policy = kzalloc(sizeof(*policy), GFP_KERNEL);
+ 	if (!policy)
+ 		return NULL;
+ 
+ 	if (!alloc_cpumask_var(&policy->cpus, GFP_KERNEL))
+ 		goto err_free_policy;
+ 
+ 	if (!zalloc_cpumask_var(&policy->related_cpus, GFP_KERNEL))
+ 		goto err_free_cpumask;
+ 
+ 	INIT_LIST_HEAD(&policy->policy_list);
+ 	return policy;
+ 
+ err_free_cpumask:
+ 	free_cpumask_var(policy->cpus);
+ err_free_policy:
+ 	kfree(policy);
+ 
+ 	return NULL;
+ }
+ 
+ static void cpufreq_policy_free(struct cpufreq_policy *policy)
+ {
+ 	free_cpumask_var(policy->related_cpus);
+ 	free_cpumask_var(policy->cpus);
+ 	kfree(policy);
+ }
+ 
+ static void update_policy_cpu(struct cpufreq_policy *policy, unsigned int cpu)
+ {
+ 	if (cpu == policy->cpu)
+ 		return;
+ 
+ 	/*
+ 	 * Take direct locks as lock_policy_rwsem_write wouldn't work here.
+ 	 * Also lock for last cpu is enough here as contention will happen only
+ 	 * after policy->cpu is changed and after it is changed, other threads
+ 	 * will try to acquire lock for new cpu. And policy is already updated
+ 	 * by then.
+ 	 */
+ 	down_write(&per_cpu(cpu_policy_rwsem, policy->cpu));
+ 
+ 	policy->last_cpu = policy->cpu;
+ 	policy->cpu = cpu;
+ 
+ 	up_write(&per_cpu(cpu_policy_rwsem, policy->last_cpu));
+ 
+ #ifdef CONFIG_CPU_FREQ_TABLE
+ 	cpufreq_frequency_table_update_policy_cpu(policy);
+ #endif
+ 	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
+ 			CPUFREQ_UPDATE_POLICY_CPU, policy);
+ }
+ 
+ static int __cpufreq_add_dev(struct device *dev, struct subsys_interface *sif,
+ 			     bool frozen)
++>>>>>>> 8efd57657d8e (cpufreq: unlock correct rwsem while updating policy->cpu)
  {
  	unsigned int j, cpu = dev->id;
  	int ret = -ENOMEM;
@@@ -1106,6 -1160,155 +1183,158 @@@ static int cpufreq_nominate_new_policy_
  	return cpu_dev->id;
  }
  
++<<<<<<< HEAD
++=======
+ static int __cpufreq_remove_dev_prepare(struct device *dev,
+ 					struct subsys_interface *sif,
+ 					bool frozen)
+ {
+ 	unsigned int cpu = dev->id, cpus;
+ 	int new_cpu, ret;
+ 	unsigned long flags;
+ 	struct cpufreq_policy *policy;
+ 
+ 	pr_debug("%s: unregistering CPU %u\n", __func__, cpu);
+ 
+ 	write_lock_irqsave(&cpufreq_driver_lock, flags);
+ 
+ 	policy = per_cpu(cpufreq_cpu_data, cpu);
+ 
+ 	/* Save the policy somewhere when doing a light-weight tear-down */
+ 	if (frozen)
+ 		per_cpu(cpufreq_cpu_data_fallback, cpu) = policy;
+ 
+ 	write_unlock_irqrestore(&cpufreq_driver_lock, flags);
+ 
+ 	if (!policy) {
+ 		pr_debug("%s: No cpu_data found\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (cpufreq_driver->target) {
+ 		ret = __cpufreq_governor(policy, CPUFREQ_GOV_STOP);
+ 		if (ret) {
+ 			pr_err("%s: Failed to stop governor\n", __func__);
+ 			return ret;
+ 		}
+ 	}
+ 
+ #ifdef CONFIG_HOTPLUG_CPU
+ 	if (!cpufreq_driver->setpolicy)
+ 		strncpy(per_cpu(cpufreq_cpu_governor, cpu),
+ 			policy->governor->name, CPUFREQ_NAME_LEN);
+ #endif
+ 
+ 	lock_policy_rwsem_read(cpu);
+ 	cpus = cpumask_weight(policy->cpus);
+ 	unlock_policy_rwsem_read(cpu);
+ 
+ 	if (cpu != policy->cpu) {
+ 		if (!frozen)
+ 			sysfs_remove_link(&dev->kobj, "cpufreq");
+ 	} else if (cpus > 1) {
+ 
+ 		new_cpu = cpufreq_nominate_new_policy_cpu(policy, cpu, frozen);
+ 		if (new_cpu >= 0) {
+ 			update_policy_cpu(policy, new_cpu);
+ 
+ 			if (!frozen) {
+ 				pr_debug("%s: policy Kobject moved to cpu: %d "
+ 					 "from: %d\n",__func__, new_cpu, cpu);
+ 			}
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int __cpufreq_remove_dev_finish(struct device *dev,
+ 				       struct subsys_interface *sif,
+ 				       bool frozen)
+ {
+ 	unsigned int cpu = dev->id, cpus;
+ 	int ret;
+ 	unsigned long flags;
+ 	struct cpufreq_policy *policy;
+ 	struct kobject *kobj;
+ 	struct completion *cmp;
+ 
+ 	read_lock_irqsave(&cpufreq_driver_lock, flags);
+ 	policy = per_cpu(cpufreq_cpu_data, cpu);
+ 	read_unlock_irqrestore(&cpufreq_driver_lock, flags);
+ 
+ 	if (!policy) {
+ 		pr_debug("%s: No cpu_data found\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 
+ 	WARN_ON(lock_policy_rwsem_write(cpu));
+ 	cpus = cpumask_weight(policy->cpus);
+ 
+ 	if (cpus > 1)
+ 		cpumask_clear_cpu(cpu, policy->cpus);
+ 	unlock_policy_rwsem_write(cpu);
+ 
+ 	/* If cpu is last user of policy, free policy */
+ 	if (cpus == 1) {
+ 		if (cpufreq_driver->target) {
+ 			ret = __cpufreq_governor(policy,
+ 					CPUFREQ_GOV_POLICY_EXIT);
+ 			if (ret) {
+ 				pr_err("%s: Failed to exit governor\n",
+ 						__func__);
+ 				return ret;
+ 			}
+ 		}
+ 
+ 		if (!frozen) {
+ 			lock_policy_rwsem_read(cpu);
+ 			kobj = &policy->kobj;
+ 			cmp = &policy->kobj_unregister;
+ 			unlock_policy_rwsem_read(cpu);
+ 			kobject_put(kobj);
+ 
+ 			/*
+ 			 * We need to make sure that the underlying kobj is
+ 			 * actually not referenced anymore by anybody before we
+ 			 * proceed with unloading.
+ 			 */
+ 			pr_debug("waiting for dropping of refcount\n");
+ 			wait_for_completion(cmp);
+ 			pr_debug("wait complete\n");
+ 		}
+ 
+ 		/*
+ 		 * Perform the ->exit() even during light-weight tear-down,
+ 		 * since this is a core component, and is essential for the
+ 		 * subsequent light-weight ->init() to succeed.
+ 		 */
+ 		if (cpufreq_driver->exit)
+ 			cpufreq_driver->exit(policy);
+ 
+ 		/* Remove policy from list of active policies */
+ 		write_lock_irqsave(&cpufreq_driver_lock, flags);
+ 		list_del(&policy->policy_list);
+ 		write_unlock_irqrestore(&cpufreq_driver_lock, flags);
+ 
+ 		if (!frozen)
+ 			cpufreq_policy_free(policy);
+ 	} else {
+ 		if (cpufreq_driver->target) {
+ 			if ((ret = __cpufreq_governor(policy, CPUFREQ_GOV_START)) ||
+ 					(ret = __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS))) {
+ 				pr_err("%s: Failed to start governor\n",
+ 						__func__);
+ 				return ret;
+ 			}
+ 		}
+ 	}
+ 
+ 	per_cpu(cpufreq_cpu_data, cpu) = NULL;
+ 	return 0;
+ }
+ 
++>>>>>>> 8efd57657d8e (cpufreq: unlock correct rwsem while updating policy->cpu)
  /**
   * __cpufreq_remove_dev - remove a CPU device
   *
* Unmerged path drivers/cpufreq/cpufreq.c
