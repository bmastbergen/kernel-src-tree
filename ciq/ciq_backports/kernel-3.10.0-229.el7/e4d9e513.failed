ALSA: hda - restore BCLK M/N value as per CDCLK for HSW/BDW display HDA controller

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [alsa] hda: restore BCLK M/N value as per CDCLK for HSW/BDW display HDA controller (Jaroslav Kysela) [1112200]
Rebuild_FUZZ: 94.27%
commit-author Mengdong Lin <mengdong.lin@intel.com>
commit e4d9e513dedb5ac4e166c1053314fa935ddecc8c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e4d9e513.failed

For HSW/BDW display HD-A controller, hda_set_bclk() is defined to set BCLK
by programming the M/N values as per the core display clock (CDCLK) queried from
i915 display driver.

And the audio driver will also set BCLK in azx_first_init() since the display
driver can turn off the shared power in boot phase if only eDP is connected
and M/N values will be lost and must be reprogrammed.

	Signed-off-by: Mengdong Lin <mengdong.lin@intel.com>
	Cc: <stable@vger.kernel.org>
	Signed-off-by: Takashi Iwai <tiwai@suse.de>
(cherry picked from commit e4d9e513dedb5ac4e166c1053314fa935ddecc8c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	sound/pci/hda/hda_i915.c
#	sound/pci/hda/hda_i915.h
#	sound/pci/hda/hda_intel.c
diff --cc sound/pci/hda/hda_i915.c
index 76c13d5b3ca0,8b4940ba33d6..000000000000
--- a/sound/pci/hda/hda_i915.c
+++ b/sound/pci/hda/hda_i915.c
@@@ -20,24 -20,71 +20,76 @@@
  #include <linux/module.h>
  #include <sound/core.h>
  #include <drm/i915_powerwell.h>
+ #include "hda_priv.h"
  #include "hda_i915.h"
  
++<<<<<<< HEAD
 +static void (*get_power)(void);
 +static void (*put_power)(void);
++=======
+ /* Intel HSW/BDW display HDA controller Extended Mode registers.
+  * EM4 (M value) and EM5 (N Value) are used to convert CDClk (Core Display
+  * Clock) to 24MHz BCLK: BCLK = CDCLK * M / N
+  * The values will be lost when the display power well is disabled.
+  */
+ #define ICH6_REG_EM4			0x100c
+ #define ICH6_REG_EM5			0x1010
+ 
+ static int (*get_power)(void);
+ static int (*put_power)(void);
+ static int (*get_cdclk)(void);
++>>>>>>> e4d9e513dedb (ALSA: hda - restore BCLK M/N value as per CDCLK for HSW/BDW display HDA controller)
  
 -int hda_display_power(bool enable)
 +void hda_display_power(bool enable)
  {
  	if (!get_power || !put_power)
 -		return -ENODEV;
 +		return;
  
 -	pr_debug("HDA display power %s \n",
 +	snd_printdd("HDA display power %s \n",
  			enable ? "Enable" : "Disable");
  	if (enable)
 -		return get_power();
 +		get_power();
  	else
 -		return put_power();
 +		put_power();
  }
  
+ void haswell_set_bclk(struct azx *chip)
+ {
+ 	int cdclk_freq;
+ 	unsigned int bclk_m, bclk_n;
+ 
+ 	if (!get_cdclk)
+ 		return;
+ 
+ 	cdclk_freq = get_cdclk();
+ 	switch (cdclk_freq) {
+ 	case 337500:
+ 		bclk_m = 16;
+ 		bclk_n = 225;
+ 		break;
+ 
+ 	case 450000:
+ 	default: /* default CDCLK 450MHz */
+ 		bclk_m = 4;
+ 		bclk_n = 75;
+ 		break;
+ 
+ 	case 540000:
+ 		bclk_m = 4;
+ 		bclk_n = 90;
+ 		break;
+ 
+ 	case 675000:
+ 		bclk_m = 8;
+ 		bclk_n = 225;
+ 		break;
+ 	}
+ 
+ 	azx_writew(chip, EM4, bclk_m);
+ 	azx_writew(chip, EM5, bclk_n);
+ }
+ 
+ 
  int hda_i915_init(void)
  {
  	int err = 0;
@@@ -55,7 -102,11 +107,15 @@@
  		return -ENODEV;
  	}
  
++<<<<<<< HEAD
 +	snd_printd("HDA driver get symbol successfully from i915 module\n");
++=======
+ 	get_cdclk = symbol_request(i915_get_cdclk_freq);
+ 	if (!get_cdclk)	/* may have abnormal BCLK and audio playback rate */
+ 		pr_warn("hda-i915: get_cdclk symbol get fail\n");
+ 
+ 	pr_debug("HDA driver get symbol successfully from i915 module\n");
++>>>>>>> e4d9e513dedb (ALSA: hda - restore BCLK M/N value as per CDCLK for HSW/BDW display HDA controller)
  
  	return err;
  }
diff --cc sound/pci/hda/hda_i915.h
index 5a63da2c53e5,e6072c627583..000000000000
--- a/sound/pci/hda/hda_i915.h
+++ b/sound/pci/hda/hda_i915.h
@@@ -17,11 -17,13 +17,21 @@@
  #define __SOUND_HDA_I915_H
  
  #ifdef CONFIG_SND_HDA_I915
++<<<<<<< HEAD
 +void hda_display_power(bool enable);
 +int hda_i915_init(void);
 +int hda_i915_exit(void);
 +#else
 +static inline void hda_display_power(bool enable) {}
++=======
+ int hda_display_power(bool enable);
+ void haswell_set_bclk(struct azx *chip);
+ int hda_i915_init(void);
+ int hda_i915_exit(void);
+ #else
+ static inline int hda_display_power(bool enable) { return 0; }
+ static inline void haswell_set_bclk(struct azx *chip) { return; }
++>>>>>>> e4d9e513dedb (ALSA: hda - restore BCLK M/N value as per CDCLK for HSW/BDW display HDA controller)
  static inline int hda_i915_init(void)
  {
  	return -ENODEV;
diff --cc sound/pci/hda/hda_intel.c
index c74374a10f3c,b6b4e71a0b0b..000000000000
--- a/sound/pci/hda/hda_intel.c
+++ b/sound/pci/hda/hda_intel.c
@@@ -62,8 -62,9 +62,13 @@@
  #include <linux/vga_switcheroo.h>
  #include <linux/firmware.h>
  #include "hda_codec.h"
++<<<<<<< HEAD
 +#include "hda_i915.h"
++=======
+ #include "hda_controller.h"
++>>>>>>> e4d9e513dedb (ALSA: hda - restore BCLK M/N value as per CDCLK for HSW/BDW display HDA controller)
  #include "hda_priv.h"
+ #include "hda_i915.h"
  
  
  static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;
@@@ -308,8 -288,10 +313,15 @@@ static char *driver_short_names[] = 
  	[AZX_DRIVER_GENERIC] = "HD-Audio Generic",
  };
  
++<<<<<<< HEAD
 +/* for pcm support */
 +#define get_azx_dev(substream) (substream->runtime->private_data)
++=======
+ struct hda_intel {
+ 	struct azx chip;
+ };
+ 
++>>>>>>> e4d9e513dedb (ALSA: hda - restore BCLK M/N value as per CDCLK for HSW/BDW display HDA controller)
  
  #ifdef CONFIG_X86
  static void __mark_pages_wc(struct azx *chip, struct snd_dma_buffer *dmab, bool on)
@@@ -2580,6 -611,7 +2592,10 @@@ static int azx_suspend(struct device *d
  		free_irq(chip->irq, chip);
  		chip->irq = -1;
  	}
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> e4d9e513dedb (ALSA: hda - restore BCLK M/N value as per CDCLK for HSW/BDW display HDA controller)
  	if (chip->msi)
  		pci_disable_msi(chip->pci);
  	pci_disable_device(pci);
@@@ -2599,8 -631,10 +2615,13 @@@ static int azx_resume(struct device *de
  	if (chip->disabled)
  		return 0;
  
 -	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {
 +	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL)
  		hda_display_power(true);
++<<<<<<< HEAD
++=======
+ 		haswell_set_bclk(chip);
+ 	}
++>>>>>>> e4d9e513dedb (ALSA: hda - restore BCLK M/N value as per CDCLK for HSW/BDW display HDA controller)
  	pci_set_power_state(pci, PCI_D0);
  	pci_restore_state(pci);
  	if (pci_enable_device(pci) < 0) {
@@@ -2646,6 -680,7 +2667,10 @@@ static int azx_runtime_suspend(struct d
  	azx_clear_irq_pending(chip);
  	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL)
  		hda_display_power(false);
++<<<<<<< HEAD
++=======
+ 
++>>>>>>> e4d9e513dedb (ALSA: hda - restore BCLK M/N value as per CDCLK for HSW/BDW display HDA controller)
  	return 0;
  }
  
@@@ -2663,8 -698,10 +2688,13 @@@ static int azx_runtime_resume(struct de
  	if (!(chip->driver_caps & AZX_DCAPS_PM_RUNTIME))
  		return 0;
  
 -	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL) {
 +	if (chip->driver_caps & AZX_DCAPS_I915_POWERWELL)
  		hda_display_power(true);
++<<<<<<< HEAD
++=======
+ 		haswell_set_bclk(chip);
+ 	}
++>>>>>>> e4d9e513dedb (ALSA: hda - restore BCLK M/N value as per CDCLK for HSW/BDW display HDA controller)
  
  	/* Read STATESTS before controller reset */
  	status = azx_readw(chip, STATESTS);
* Unmerged path sound/pci/hda/hda_i915.c
* Unmerged path sound/pci/hda/hda_i915.h
* Unmerged path sound/pci/hda/hda_intel.c
