ACPI / hotplug / PCI: Check for new devices on enabled slots

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Check for new devices on enabled slots (Myron Stowe) [1114228]
Rebuild_FUZZ: 91.89%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 4ebe34503baa0644c9352bcd76d4cf573bffe206
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/4ebe3450.failed

The current implementation of acpiphp_check_bridge() is pretty dumb:
 - It enables a slot if it's not enabled and the slot status is
   ACPI_STA_ALL.
 - It disables a slot if it's enabled and the slot status is not
   ACPI_STA_ALL.

This behavior is not sufficient to handle the Thunderbolt daisy
chaining case properly, however, because in that case the bus
behind the already enabled slot needs to be rescanned for new
devices.

For this reason, modify acpiphp_check_bridge() so that slots are
disabled and stopped if they are not in the ACPI_STA_ALL state.

For slots in the ACPI_STA_ALL state, devices behind them that don't
respond are trimmed using a new function, trim_stale_devices(),
introduced specifically for this purpose.  That function walks
the given bus and checks each device on it.  If the device doesn't
respond, it is assumed to be gone and is removed.

Once all of the stale devices directy behind the slot have been
removed, acpiphp_check_bridge() will start looking for new devices
that might have appeared on the given bus.  It will do that even if
the slot is already enabled (SLOT_ENABLED is set for it).

In addition to that, make the bus check notification ignore
SLOT_ENABLED and go for enable_device() directly if bridge is NULL,
so that devices behind the slot are re-enumerated in that case too.

This change is based on earlier patches from Kirill A Shutemov
and Mika Westerberg.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 4ebe34503baa0644c9352bcd76d4cf573bffe206)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index d210006fa4ad,e2e5e3088816..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -833,34 -688,42 +834,73 @@@ static unsigned int get_slot_status(str
  }
  
  /**
++<<<<<<< HEAD
 + * acpiphp_eject_slot - physically eject the slot
 + * @slot: ACPI PHP slot
 + */
 +int acpiphp_eject_slot(struct acpiphp_slot *slot)
 +{
 +	acpi_status status;
 +	struct acpiphp_func *func;
 +	struct acpi_object_list arg_list;
 +	union acpi_object arg;
 +
 +	list_for_each_entry(func, &slot->funcs, sibling) {
 +		/* We don't want to call _EJ0 on non-existing functions. */
 +		if ((func->flags & FUNC_HAS_EJ0)) {
 +			/* _EJ0 method take one argument */
 +			arg_list.count = 1;
 +			arg_list.pointer = &arg;
 +			arg.type = ACPI_TYPE_INTEGER;
 +			arg.integer.value = 1;
 +
 +			status = acpi_evaluate_object(func->handle, "_EJ0", &arg_list, NULL);
 +			if (ACPI_FAILURE(status)) {
 +				pr_warn("%s: _EJ0 failed\n", __func__);
 +				return -1;
 +			} else
 +				break;
 +		}
 +	}
 +	return 0;
++=======
+  * trim_stale_devices - remove PCI devices that are not responding.
+  * @dev: PCI device to start walking the hierarchy from.
+  */
+ static void trim_stale_devices(struct pci_dev *dev)
+ {
+ 	acpi_handle handle = ACPI_HANDLE(&dev->dev);
+ 	struct pci_bus *bus = dev->subordinate;
+ 	bool alive = false;
+ 
+ 	if (handle) {
+ 		acpi_status status;
+ 		unsigned long long sta;
+ 
+ 		status = acpi_evaluate_integer(handle, "_STA", NULL, &sta);
+ 		alive = ACPI_SUCCESS(status) && sta == ACPI_STA_ALL;
+ 	}
+ 	if (!alive) {
+ 		u32 v;
+ 
+ 		/* Check if the device responds. */
+ 		alive = pci_bus_read_dev_vendor_id(dev->bus, dev->devfn, &v, 0);
+ 	}
+ 	if (!alive) {
+ 		pci_stop_and_remove_bus_device(dev);
+ 		if (handle)
+ 			acpiphp_bus_trim(handle);
+ 	} else if (bus) {
+ 		struct pci_dev *child, *tmp;
+ 
+ 		/* The device is a bridge. so check the bus below it. */
+ 		pm_runtime_get_sync(&dev->dev);
+ 		list_for_each_entry_safe(child, tmp, &bus->devices, bus_list)
+ 			trim_stale_devices(child);
+ 
+ 		pm_runtime_put(&dev->dev);
+ 	}
++>>>>>>> 4ebe34503baa (ACPI / hotplug / PCI: Check for new devices on enabled slots)
  }
  
  /**
@@@ -870,43 -733,30 +910,62 @@@
   * Iterate over all slots under this bridge and make sure that if a
   * card is present they are enabled, and if not they are disabled.
   */
- static int acpiphp_check_bridge(struct acpiphp_bridge *bridge)
+ static void acpiphp_check_bridge(struct acpiphp_bridge *bridge)
  {
  	struct acpiphp_slot *slot;
- 	int retval = 0;
- 	int enabled, disabled;
- 
- 	enabled = disabled = 0;
  
  	list_for_each_entry(slot, &bridge->slots, node) {
++<<<<<<< HEAD
 +		unsigned int status = get_slot_status(slot);
 +		if (slot->flags & SLOT_ENABLED) {
 +			if (status == ACPI_STA_ALL)
 +				continue;
 +			retval = acpiphp_disable_slot(slot);
 +			if (retval) {
 +				pr_err("Error occurred in disabling\n");
 +				goto err_exit;
 +			} else {
 +				acpiphp_eject_slot(slot);
 +			}
 +			disabled++;
 +		} else {
 +			if (status != ACPI_STA_ALL)
 +				continue;
 +			retval = acpiphp_enable_slot(slot);
 +			if (retval) {
 +				pr_err("Error occurred in enabling\n");
 +				goto err_exit;
 +			}
 +			enabled++;
++=======
+ 		struct pci_bus *bus = slot->bus;
+ 		struct pci_dev *dev, *tmp;
+ 
+ 		mutex_lock(&slot->crit_sect);
+ 		/* wake up all functions */
+ 		if (get_slot_status(slot) == ACPI_STA_ALL) {
+ 			/* remove stale devices if any */
+ 			list_for_each_entry_safe(dev, tmp, &bus->devices,
+ 						 bus_list)
+ 				if (PCI_SLOT(dev->devfn) == slot->device)
+ 					trim_stale_devices(dev);
+ 
+ 			/* configure all functions */
+ 			enable_device(slot);
+ 		} else {
+ 			disable_device(slot);
++>>>>>>> 4ebe34503baa (ACPI / hotplug / PCI: Check for new devices on enabled slots)
  		}
+ 		mutex_unlock(&slot->crit_sect);
  	}
++<<<<<<< HEAD
 +
 +	pr_debug("%s: %d enabled, %d disabled\n", __func__, enabled, disabled);
 +
 + err_exit:
 +	return retval;
++=======
++>>>>>>> 4ebe34503baa (ACPI / hotplug / PCI: Check for new devices on enabled slots)
  }
  
  static void acpiphp_set_hpp_values(struct pci_bus *bus)
@@@ -1000,12 -849,20 +1059,29 @@@ static void _handle_hotplug_event_bridg
  	switch (type) {
  	case ACPI_NOTIFY_BUS_CHECK:
  		/* bus re-enumerate */
++<<<<<<< HEAD
 +		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
 +		pr_debug("%s: re-enumerating slots under %s\n",
 +			 __func__, objname);
 +		acpiphp_check_bridge(bridge);
 +		acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
 +			ACPI_UINT32_MAX, check_sub_bridges, NULL, NULL, NULL);
++=======
+ 		dbg("%s: Bus check notify on %s\n", __func__, objname);
+ 		dbg("%s: re-enumerating slots under %s\n", __func__, objname);
+ 		if (bridge) {
+ 			acpiphp_check_bridge(bridge);
+ 			acpi_walk_namespace(ACPI_TYPE_DEVICE, handle,
+ 					    ACPI_UINT32_MAX, check_sub_bridges,
+ 					    NULL, NULL, NULL);
+ 		} else {
+ 			struct acpiphp_slot *slot = func->slot;
+ 
+ 			mutex_lock(&slot->crit_sect);
+ 			enable_device(slot);
+ 			mutex_unlock(&slot->crit_sect);
+ 		}
++>>>>>>> 4ebe34503baa (ACPI / hotplug / PCI: Check for new devices on enabled slots)
  		break;
  
  	case ACPI_NOTIFY_DEVICE_CHECK:
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
