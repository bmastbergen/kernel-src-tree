ixgbe: Additional adapter removal checks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Mark Rustad <mark.d.rustad@intel.com>
commit b0483c8f363c7ab1e8c19ac4578bec91c8e5aea2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/b0483c8f.failed

Additional checks are needed for a detected removal not to cause
problems. Some involve simply avoiding a lot of stuff that can't
do anything good, and also cases where the phony return value can
cause problems. In addition, down the adapter when the removal is
sensed.

	Signed-off-by: Mark Rustad <mark.d.rustad@intel.com>
	Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
	Signed-off-by: Aaron Brown <aaron.f.brown@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit b0483c8f363c7ab1e8c19ac4578bec91c8e5aea2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
diff --cc drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
index 0e1b973659b0,043307024c4a..000000000000
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
@@@ -1277,11 -1342,14 +1277,15 @@@ static bool reg_pattern_test(struct ixg
  	static const u32 test_pattern[] = {
  		0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF};
  
+ 	if (ixgbe_removed(adapter->hw.hw_addr)) {
+ 		*data = 1;
+ 		return 1;
+ 	}
  	for (pat = 0; pat < ARRAY_SIZE(test_pattern); pat++) {
 -		before = ixgbe_read_reg(&adapter->hw, reg);
 -		ixgbe_write_reg(&adapter->hw, reg, test_pattern[pat] & write);
 -		val = ixgbe_read_reg(&adapter->hw, reg);
 +		before = readl(adapter->hw.hw_addr + reg);
 +		writel((test_pattern[pat] & write),
 +		       (adapter->hw.hw_addr + reg));
 +		val = readl(adapter->hw.hw_addr + reg);
  		if (val != (test_pattern[pat] & write & mask)) {
  			e_err(drv, "pattern test reg %04X failed: got "
  			      "0x%08X expected 0x%08X\n",
@@@ -1299,9 -1367,14 +1303,20 @@@ static bool reg_set_and_check(struct ix
  			      u32 mask, u32 write)
  {
  	u32 val, before;
++<<<<<<< HEAD
 +	before = readl(adapter->hw.hw_addr + reg);
 +	writel((write & mask), (adapter->hw.hw_addr + reg));
 +	val = readl(adapter->hw.hw_addr + reg);
++=======
+ 
+ 	if (ixgbe_removed(adapter->hw.hw_addr)) {
+ 		*data = 1;
+ 		return 1;
+ 	}
+ 	before = ixgbe_read_reg(&adapter->hw, reg);
+ 	ixgbe_write_reg(&adapter->hw, reg, write & mask);
+ 	val = ixgbe_read_reg(&adapter->hw, reg);
++>>>>>>> b0483c8f363c (ixgbe: Additional adapter removal checks)
  	if ((write & mask) != (val & mask)) {
  		e_err(drv, "set/check reg %04X test failed: got 0x%08X "
  		      "expected 0x%08X\n", reg, (val & mask), (write & mask));
* Unmerged path drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 4f56b8d50ae6..f68c3241c197 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -291,6 +291,7 @@ static void ixgbe_remove_adapter(struct ixgbe_hw *hw)
 		return;
 	hw->hw_addr = NULL;
 	e_dev_err("Adapter removed\n");
+	ixgbe_service_event_schedule(adapter);
 }
 
 void ixgbe_check_remove(struct ixgbe_hw *hw, u32 reg)
@@ -3337,6 +3338,8 @@ static void ixgbe_rx_desc_queue_enable(struct ixgbe_adapter *adapter,
 	u32 rxdctl;
 	u8 reg_idx = ring->reg_idx;
 
+	if (ixgbe_removed(hw->hw_addr))
+		return;
 	/* RXDCTL.EN will return 0 on 82598 if link is down, so skip it */
 	if (hw->mac.type == ixgbe_mac_82598EB &&
 	    !(IXGBE_READ_REG(hw, IXGBE_LINKS) & IXGBE_LINKS_UP))
@@ -3361,6 +3364,8 @@ void ixgbe_disable_rx_queue(struct ixgbe_adapter *adapter,
 	u32 rxdctl;
 	u8 reg_idx = ring->reg_idx;
 
+	if (ixgbe_removed(hw->hw_addr))
+		return;
 	rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
 	rxdctl &= ~IXGBE_RXDCTL_ENABLE;
 
@@ -4437,6 +4442,8 @@ void ixgbe_reset(struct ixgbe_adapter *adapter)
 	struct ixgbe_hw *hw = &adapter->hw;
 	int err;
 
+	if (ixgbe_removed(hw->hw_addr))
+		return;
 	/* lock SFP init bit to prevent race conditions with the watchdog */
 	while (test_and_set_bit(__IXGBE_IN_SFP_INIT, &adapter->state))
 		usleep_range(1000, 2000);
@@ -6153,6 +6160,15 @@ static void ixgbe_service_task(struct work_struct *work)
 	struct ixgbe_adapter *adapter = container_of(work,
 						     struct ixgbe_adapter,
 						     service_task);
+	if (ixgbe_removed(adapter->hw.hw_addr)) {
+		if (!test_bit(__IXGBE_DOWN, &adapter->state)) {
+			rtnl_lock();
+			ixgbe_down(adapter);
+			rtnl_unlock();
+		}
+		ixgbe_service_event_complete(adapter);
+		return;
+	}
 	ixgbe_reset_subtask(adapter);
 	ixgbe_sfp_detection_subtask(adapter);
 	ixgbe_sfp_link_config_subtask(adapter);
