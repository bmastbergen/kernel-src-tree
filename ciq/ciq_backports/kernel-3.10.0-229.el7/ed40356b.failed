iommu/vt-d: Add ACPI devices into dmaru->devices[] array

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Add ACPI devices into dmaru->devices[] array (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 91.26%
commit-author David Woodhouse <David.Woodhouse@intel.com>
commit ed40356b5fcf1ce28e026ab39c5b2b6939068b50
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/ed40356b.failed

	Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
(cherry picked from commit ed40356b5fcf1ce28e026ab39c5b2b6939068b50)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/dmar.c
diff --cc drivers/iommu/dmar.c
index af997da05f06,7ea086f61073..000000000000
--- a/drivers/iommu/dmar.c
+++ b/drivers/iommu/dmar.c
@@@ -457,40 -603,121 +457,122 @@@ dmar_find_matched_drhd_unit(struct pci_
  
  		if (dmar_pci_device_match(dmaru->devices,
  					  dmaru->devices_cnt, dev))
 -			goto out;
 +			return dmaru;
  	}
 -	dmaru = NULL;
 -out:
 -	rcu_read_unlock();
  
 -	return dmaru;
 +	return NULL;
  }
  
+ static void __init dmar_acpi_insert_dev_scope(u8 device_number,
+ 					      struct acpi_device *adev)
+ {
+ 	struct dmar_drhd_unit *dmaru;
+ 	struct acpi_dmar_hardware_unit *drhd;
+ 	struct acpi_dmar_device_scope *scope;
+ 	struct device *tmp;
+ 	int i;
+ 	struct acpi_dmar_pci_path *path;
+ 
+ 	for_each_drhd_unit(dmaru) {
+ 		drhd = container_of(dmaru->hdr,
+ 				    struct acpi_dmar_hardware_unit,
+ 				    header);
+ 
+ 		for (scope = (void *)(drhd + 1);
+ 		     (unsigned long)scope < ((unsigned long)drhd) + drhd->header.length;
+ 		     scope = ((void *)scope) + scope->length) {
+ 			if (scope->entry_type != ACPI_DMAR_SCOPE_TYPE_ACPI)
+ 				continue;
+ 			if (scope->enumeration_id != device_number)
+ 				continue;
+ 
+ 			path = (void *)(scope + 1);
+ 			pr_info("ACPI device \"%s\" under DMAR at %llx as %02x:%02x.%d\n",
+ 				dev_name(&adev->dev), dmaru->reg_base_addr,
+ 				scope->bus, path->device, path->function);
+ 			for_each_dev_scope(dmaru->devices, dmaru->devices_cnt, i, tmp)
+ 				if (tmp == NULL) {
+ 					dmaru->devices[i].bus = scope->bus;
+ 					dmaru->devices[i].devfn = PCI_DEVFN(path->device,
+ 									    path->function);
+ 					rcu_assign_pointer(dmaru->devices[i].dev,
+ 							   get_device(&adev->dev));
+ 					return;
+ 				}
+ 			BUG_ON(i >= dmaru->devices_cnt);
+ 		}
+ 	}
+ 	pr_warn("No IOMMU scope found for ANDD enumeration ID %d (%s)\n",
+ 		device_number, dev_name(&adev->dev));
+ }
+ 
+ static int __init dmar_acpi_dev_scope_init(void)
+ {
+ 	struct acpi_dmar_andd *andd = (void *)dmar_tbl + sizeof(struct acpi_table_dmar);
+ 
+ 	while (((unsigned long)andd) <
+ 	       ((unsigned long)dmar_tbl) + dmar_tbl->length) {
+ 		if (andd->header.type == ACPI_DMAR_TYPE_ANDD) {
+ 			acpi_handle h;
+ 			struct acpi_device *adev;
+ 
+ 			if (!ACPI_SUCCESS(acpi_get_handle(ACPI_ROOT_OBJECT,
+ 							  andd->object_name,
+ 							  &h))) {
+ 				pr_err("Failed to find handle for ACPI object %s\n",
+ 				       andd->object_name);
+ 				continue;
+ 			}
+ 			acpi_bus_get_device(h, &adev);
+ 			if (!adev) {
+ 				pr_err("Failed to get device for ACPI object %s\n",
+ 				       andd->object_name);
+ 				continue;
+ 			}
+ 			dmar_acpi_insert_dev_scope(andd->device_number, adev);
+ 		}
+ 		andd = ((void *)andd) + andd->header.length;
+ 	}
+ 	return 0;
+ }
+ 
  int __init dmar_dev_scope_init(void)
  {
 -	struct pci_dev *dev = NULL;
 -	struct dmar_pci_notify_info *info;
 +	static int dmar_dev_scope_initialized;
 +	struct dmar_drhd_unit *drhd, *drhd_n;
 +	int ret = -ENODEV;
  
 -	if (dmar_dev_scope_status != 1)
 -		return dmar_dev_scope_status;
 +	if (dmar_dev_scope_initialized)
 +		return dmar_dev_scope_initialized;
  
++<<<<<<< HEAD
 +	if (list_empty(&dmar_drhd_units))
 +		goto fail;
++=======
+ 	dmar_acpi_dev_scope_init();
+ 
+ 	if (list_empty(&dmar_drhd_units)) {
+ 		dmar_dev_scope_status = -ENODEV;
+ 	} else {
+ 		dmar_dev_scope_status = 0;
++>>>>>>> ed40356b5fcf (iommu/vt-d: Add ACPI devices into dmaru->devices[] array)
  
 -		for_each_pci_dev(dev) {
 -			if (dev->is_virtfn)
 -				continue;
 +	list_for_each_entry_safe(drhd, drhd_n, &dmar_drhd_units, list) {
 +		ret = dmar_parse_dev(drhd);
 +		if (ret)
 +			goto fail;
 +	}
  
 -			info = dmar_alloc_pci_notify_info(dev,
 -					BUS_NOTIFY_ADD_DEVICE);
 -			if (!info) {
 -				return dmar_dev_scope_status;
 -			} else {
 -				dmar_pci_bus_add_dev(info);
 -				dmar_free_pci_notify_info(info);
 -			}
 -		}
 +	ret = dmar_parse_rmrr_atsr_dev();
 +	if (ret)
 +		goto fail;
  
 -		bus_register_notifier(&pci_bus_type, &dmar_pci_bus_nb);
 -	}
 +	dmar_dev_scope_initialized = 1;
 +	return 0;
  
 -	return dmar_dev_scope_status;
 +fail:
 +	dmar_dev_scope_initialized = ret;
 +	return ret;
  }
  
  
* Unmerged path drivers/iommu/dmar.c
