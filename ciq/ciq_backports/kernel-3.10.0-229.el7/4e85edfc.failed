perf tests: Add thread maps lookup automated tests

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf/tests: Add thread maps lookup automated tests (Jiri Olsa) [1134356]
Rebuild_FUZZ: 98.00%
commit-author Jiri Olsa <jolsa@kernel.org>
commit 4e85edfc3f5c0e016a960c1dcbe0217e86602525
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/4e85edfc.failed

Adding automated test for memory maps lookup within multiple machines
threads.

The test creates 4 threads and separated memory maps. It checks that we
could use thread__find_addr_map function with thread object based on TID
to find memory maps.

	Acked-by: Namhyung Kim <namhyung@kernel.org>
	Cc: Adrian Hunter <adrian.hunter@intel.com>
	Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
	Cc: Corey Ashford <cjashfor@linux.vnet.ibm.com>
	Cc: David Ahern <dsahern@gmail.com>
	Cc: Don Zickus <dzickus@redhat.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Mike Galbraith <efault@gmx.de>
	Cc: Namhyung Kim <namhyung@kernel.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Stephane Eranian <eranian@google.com>
Link: http://lkml.kernel.org/r/1397490723-1992-2-git-send-email-jolsa@redhat.com
	Signed-off-by: Jiri Olsa <jolsa@kernel.org>
(cherry picked from commit 4e85edfc3f5c0e016a960c1dcbe0217e86602525)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/Makefile.perf
#	tools/perf/perf.h
#	tools/perf/tests/tests.h
diff --cc tools/perf/Makefile.perf
index 01fd40359345,16d4f4ee8a69..000000000000
--- a/tools/perf/Makefile.perf
+++ b/tools/perf/Makefile.perf
@@@ -412,6 -411,12 +412,15 @@@ endi
  LIB_OBJS += $(OUTPUT)tests/code-reading.o
  LIB_OBJS += $(OUTPUT)tests/sample-parsing.o
  LIB_OBJS += $(OUTPUT)tests/parse-no-sample-id-all.o
++<<<<<<< HEAD
++=======
+ ifndef NO_DWARF_UNWIND
+ ifeq ($(ARCH),x86)
+ LIB_OBJS += $(OUTPUT)tests/dwarf-unwind.o
+ endif
+ endif
+ LIB_OBJS += $(OUTPUT)tests/mmap-thread-lookup.o
++>>>>>>> 4e85edfc3f5c (perf tests: Add thread maps lookup automated tests)
  
  BUILTIN_OBJS += $(OUTPUT)builtin-annotate.o
  BUILTIN_OBJS += $(OUTPUT)builtin-bench.o
diff --cc tools/perf/perf.h
index 6898ad0e199f,ebdad3376c67..000000000000
--- a/tools/perf/perf.h
+++ b/tools/perf/perf.h
@@@ -12,6 -12,12 +12,15 @@@
  #ifndef __NR_perf_event_open
  # define __NR_perf_event_open 336
  #endif
++<<<<<<< HEAD
++=======
+ #ifndef __NR_futex
+ # define __NR_futex 240
+ #endif
+ #ifndef __NR_gettid
+ # define __NR_gettid 224
+ #endif
++>>>>>>> 4e85edfc3f5c (perf tests: Add thread maps lookup automated tests)
  #endif
  
  #if defined(__x86_64__)
@@@ -23,6 -29,12 +32,15 @@@
  #ifndef __NR_perf_event_open
  # define __NR_perf_event_open 298
  #endif
++<<<<<<< HEAD
++=======
+ #ifndef __NR_futex
+ # define __NR_futex 202
+ #endif
+ #ifndef __NR_gettid
+ # define __NR_gettid 186
+ #endif
++>>>>>>> 4e85edfc3f5c (perf tests: Add thread maps lookup automated tests)
  #endif
  
  #ifdef __powerpc__
diff --cc tools/perf/tests/tests.h
index e0ac713857ba,82e8061df46e..000000000000
--- a/tools/perf/tests/tests.h
+++ b/tools/perf/tests/tests.h
@@@ -40,5 -40,16 +40,11 @@@ int test__code_reading(void)
  int test__sample_parsing(void);
  int test__keep_tracking(void);
  int test__parse_no_sample_id_all(void);
++<<<<<<< HEAD
++=======
+ int test__dwarf_unwind(void);
+ int test__hists_filter(void);
+ int test__mmap_thread_lookup(void);
++>>>>>>> 4e85edfc3f5c (perf tests: Add thread maps lookup automated tests)
  
 -#if defined(__x86_64__) || defined(__i386__)
 -#ifdef HAVE_DWARF_UNWIND_SUPPORT
 -struct thread;
 -struct perf_sample;
 -int test__arch_unwind_sample(struct perf_sample *sample,
 -			     struct thread *thread);
 -#endif
 -#endif
  #endif /* TESTS_H */
* Unmerged path tools/perf/Makefile.perf
* Unmerged path tools/perf/perf.h
diff --git a/tools/perf/tests/builtin-test.c b/tools/perf/tests/builtin-test.c
index 1e67437fb4ca..6715c25ad2c1 100644
--- a/tools/perf/tests/builtin-test.c
+++ b/tools/perf/tests/builtin-test.c
@@ -115,6 +115,10 @@ static struct test {
 		.desc = "Test parsing with no sample_id_all bit set",
 		.func = test__parse_no_sample_id_all,
 	},
+	{
+		.desc = "Test mmap thread lookup",
+		.func = test__mmap_thread_lookup,
+	},
 	{
 		.func = NULL,
 	},
diff --git a/tools/perf/tests/mmap-thread-lookup.c b/tools/perf/tests/mmap-thread-lookup.c
new file mode 100644
index 000000000000..4a456fef66ca
--- /dev/null
+++ b/tools/perf/tests/mmap-thread-lookup.c
@@ -0,0 +1,233 @@
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <pthread.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include "debug.h"
+#include "tests.h"
+#include "machine.h"
+#include "thread_map.h"
+#include "symbol.h"
+#include "thread.h"
+
+#define THREADS 4
+
+static int go_away;
+
+struct thread_data {
+	pthread_t	pt;
+	pid_t		tid;
+	void		*map;
+	int		ready[2];
+};
+
+static struct thread_data threads[THREADS];
+
+static int thread_init(struct thread_data *td)
+{
+	void *map;
+
+	map = mmap(NULL, page_size,
+		   PROT_READ|PROT_WRITE|PROT_EXEC,
+		   MAP_SHARED|MAP_ANONYMOUS, -1, 0);
+
+	if (map == MAP_FAILED) {
+		perror("mmap failed");
+		return -1;
+	}
+
+	td->map = map;
+	td->tid = syscall(SYS_gettid);
+
+	pr_debug("tid = %d, map = %p\n", td->tid, map);
+	return 0;
+}
+
+static void *thread_fn(void *arg)
+{
+	struct thread_data *td = arg;
+	ssize_t ret;
+	int go;
+
+	if (thread_init(td))
+		return NULL;
+
+	/* Signal thread_create thread is initialized. */
+	ret = write(td->ready[1], &go, sizeof(int));
+	if (ret != sizeof(int)) {
+		pr_err("failed to notify\n");
+		return NULL;
+	}
+
+	while (!go_away) {
+		/* Waiting for main thread to kill us. */
+		usleep(100);
+	}
+
+	munmap(td->map, page_size);
+	return NULL;
+}
+
+static int thread_create(int i)
+{
+	struct thread_data *td = &threads[i];
+	int err, go;
+
+	if (pipe(td->ready))
+		return -1;
+
+	err = pthread_create(&td->pt, NULL, thread_fn, td);
+	if (!err) {
+		/* Wait for thread initialization. */
+		ssize_t ret = read(td->ready[0], &go, sizeof(int));
+		err = ret != sizeof(int);
+	}
+
+	close(td->ready[0]);
+	close(td->ready[1]);
+	return err;
+}
+
+static int threads_create(void)
+{
+	struct thread_data *td0 = &threads[0];
+	int i, err = 0;
+
+	go_away = 0;
+
+	/* 0 is main thread */
+	if (thread_init(td0))
+		return -1;
+
+	for (i = 1; !err && i < THREADS; i++)
+		err = thread_create(i);
+
+	return err;
+}
+
+static int threads_destroy(void)
+{
+	struct thread_data *td0 = &threads[0];
+	int i, err = 0;
+
+	/* cleanup the main thread */
+	munmap(td0->map, page_size);
+
+	go_away = 1;
+
+	for (i = 1; !err && i < THREADS; i++)
+		err = pthread_join(threads[i].pt, NULL);
+
+	return err;
+}
+
+typedef int (*synth_cb)(struct machine *machine);
+
+static int synth_all(struct machine *machine)
+{
+	return perf_event__synthesize_threads(NULL,
+					      perf_event__process,
+					      machine, 0);
+}
+
+static int synth_process(struct machine *machine)
+{
+	struct thread_map *map;
+	int err;
+
+	map = thread_map__new_by_pid(getpid());
+
+	err = perf_event__synthesize_thread_map(NULL, map,
+						perf_event__process,
+						machine, 0);
+
+	thread_map__delete(map);
+	return err;
+}
+
+static int mmap_events(synth_cb synth)
+{
+	struct machines machines;
+	struct machine *machine;
+	int err, i;
+
+	/*
+	 * The threads_create will not return before all threads
+	 * are spawned and all created memory map.
+	 *
+	 * They will loop until threads_destroy is called, so we
+	 * can safely run synthesizing function.
+	 */
+	TEST_ASSERT_VAL("failed to create threads", !threads_create());
+
+	machines__init(&machines);
+	machine = &machines.host;
+
+	dump_trace = verbose > 1 ? 1 : 0;
+
+	err = synth(machine);
+
+	dump_trace = 0;
+
+	TEST_ASSERT_VAL("failed to destroy threads", !threads_destroy());
+	TEST_ASSERT_VAL("failed to synthesize maps", !err);
+
+	/*
+	 * All data is synthesized, try to find map for each
+	 * thread object.
+	 */
+	for (i = 0; i < THREADS; i++) {
+		struct thread_data *td = &threads[i];
+		struct addr_location al;
+		struct thread *thread;
+
+		thread = machine__findnew_thread(machine, getpid(), td->tid);
+
+		pr_debug("looking for map %p\n", td->map);
+
+		thread__find_addr_map(thread, machine,
+				      PERF_RECORD_MISC_USER, MAP__FUNCTION,
+				      (unsigned long) (td->map + 1), &al);
+
+		if (!al.map) {
+			pr_debug("failed, couldn't find map\n");
+			err = -1;
+			break;
+		}
+
+		pr_debug("map %p, addr %" PRIx64 "\n", al.map, al.map->start);
+	}
+
+	machine__delete_threads(machine);
+	machines__exit(&machines);
+	return err;
+}
+
+/*
+ * This test creates 'THREADS' number of threads (including
+ * main thread) and each thread creates memory map.
+ *
+ * When threads are created, we synthesize them with both
+ * (separate tests):
+ *   perf_event__synthesize_thread_map (process based)
+ *   perf_event__synthesize_threads    (global)
+ *
+ * We test we can find all memory maps via:
+ *   thread__find_addr_map
+ *
+ * by using all thread objects.
+ */
+int test__mmap_thread_lookup(void)
+{
+	/* perf_event__synthesize_threads synthesize */
+	TEST_ASSERT_VAL("failed with sythesizing all",
+			!mmap_events(synth_all));
+
+	/* perf_event__synthesize_thread_map synthesize */
+	TEST_ASSERT_VAL("failed with sythesizing process",
+			!mmap_events(synth_process));
+
+	return 0;
+}
* Unmerged path tools/perf/tests/tests.h
