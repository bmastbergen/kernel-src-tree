tcp: zero retrans_stamp if all retrans were acked

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Marcelo Leitner <mleitner@redhat.com>
commit 1f37bf87aa7523d28e7e4c4f7bb5dba98faa3e00
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/1f37bf87.failed

Ueki Kohei reported that when we are using NewReno with connections that
have a very low traffic, we may timeout the connection too early if a
second loss occurs after the first one was successfully acked but no
data was transfered later. Below is his description of it:

When SACK is disabled, and a socket suffers multiple separate TCP
retransmissions, that socket's ETIMEDOUT value is calculated from the
time of the *first* retransmission instead of the *latest*
retransmission.

This happens because the tcp_sock's retrans_stamp is set once then never
cleared.

Take the following connection:

                      Linux                    remote-machine
                        |                           |
         send#1---->(*1)|--------> data#1 --------->|
                  |     |                           |
                 RTO    :                           :
                  |     |                           |
                 ---(*2)|----> data#1(retrans) ---->|
                  | (*3)|<---------- ACK <----------|
                  |     |                           |
                  |     :                           :
                  |     :                           :
                  |     :                           :
                16 minutes (or more)                :
                  |     :                           :
                  |     :                           :
                  |     :                           :
                  |     |                           |
         send#2---->(*4)|--------> data#2 --------->|
                  |     |                           |
                 RTO    :                           :
                  |     |                           |
                 ---(*5)|----> data#2(retrans) ---->|
                  |     |                           |
                  |     |                           |
                RTO*2   :                           :
                  |     |                           |
                  |     |                           |
      ETIMEDOUT<----(*6)|                           |

(*1) One data packet sent.
(*2) Because no ACK packet is received, the packet is retransmitted.
(*3) The ACK packet is received. The transmitted packet is acknowledged.

At this point the first "retransmission event" has passed and been
recovered from. Any future retransmission is a completely new "event".

(*4) After 16 minutes (to correspond with retries2=15), a new data
packet is sent. Note: No data is transmitted between (*3) and (*4).

The socket's timeout SHOULD be calculated from this point in time, but
instead it's calculated from the prior "event" 16 minutes ago.

(*5) Because no ACK packet is received, the packet is retransmitted.
(*6) At the time of the 2nd retransmission, the socket returns
ETIMEDOUT.

Therefore, now we clear retrans_stamp as soon as all data during the
loss window is fully acked.

	Reported-by: Ueki Kohei
	Cc: Neal Cardwell <ncardwell@google.com>
	Cc: Yuchung Cheng <ycheng@google.com>
	Signed-off-by: Marcelo Ricardo Leitner <mleitner@redhat.com>
	Acked-by: Neal Cardwell <ncardwell@google.com>
	Tested-by: Neal Cardwell <ncardwell@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 1f37bf87aa7523d28e7e4c4f7bb5dba98faa3e00)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/tcp_input.c
diff --cc net/ipv4/tcp_input.c
index 35158b5fc07c,88fa2d160685..000000000000
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@@ -2404,71 -2454,13 +2435,74 @@@ static void tcp_try_undo_dsack(struct s
  
  	if (tp->undo_marker && !tp->undo_retrans) {
  		DBGUNDO(sk, "D-SACK");
 -		tcp_undo_cwnd_reduction(sk, false);
 +		tcp_undo_cwr(sk, true);
 +		tp->undo_marker = 0;
  		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPDSACKUNDO);
 -		return true;
  	}
 +}
 +
++<<<<<<< HEAD
 +/* We can clear retrans_stamp when there are no retransmissions in the
 + * window. It would seem that it is trivially available for us in
 + * tp->retrans_out, however, that kind of assumptions doesn't consider
 + * what will happen if errors occur when sending retransmission for the
 + * second time. ...It could the that such segment has only
 + * TCPCB_EVER_RETRANS set at the present time. It seems that checking
 + * the head skb is enough except for some reneging corner cases that
 + * are not worth the effort.
 + *
 + * Main reason for all this complexity is the fact that connection dying
 + * time now depends on the validity of the retrans_stamp, in particular,
 + * that successive retransmissions of a segment must not advance
 + * retrans_stamp under any conditions.
 + */
 +static bool tcp_any_retrans_done(const struct sock *sk)
 +{
 +	const struct tcp_sock *tp = tcp_sk(sk);
 +	struct sk_buff *skb;
 +
 +	if (tp->retrans_out)
 +		return true;
 +
 +	skb = tcp_write_queue_head(sk);
 +	if (unlikely(skb && TCP_SKB_CB(skb)->sacked & TCPCB_EVER_RETRANS))
 +		return true;
 +
  	return false;
  }
  
 +/* Undo during fast recovery after partial ACK. */
 +
 +static int tcp_try_undo_partial(struct sock *sk, int acked)
 +{
 +	struct tcp_sock *tp = tcp_sk(sk);
 +	/* Partial ACK arrived. Force Hoe's retransmit. */
 +	int failed = tcp_is_reno(tp) || (tcp_fackets_out(tp) > tp->reordering);
 +
 +	if (tcp_may_undo(tp)) {
 +		/* Plain luck! Hole if filled with delayed
 +		 * packet, rather than with a retransmit.
 +		 */
 +		if (!tcp_any_retrans_done(sk))
 +			tp->retrans_stamp = 0;
 +
 +		tcp_update_reordering(sk, tcp_fackets_out(tp) + acked, 1);
 +
 +		DBGUNDO(sk, "Hoe");
 +		tcp_undo_cwr(sk, false);
 +		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPPARTIALUNDO);
 +
 +		/* So... Do not make Hoe's retransmit yet.
 +		 * If the first packet was delayed, the rest
 +		 * ones are most probably delayed as well.
 +		 */
 +		failed = 0;
 +	}
 +	return failed;
 +}
 +
++=======
++>>>>>>> 1f37bf87aa75 (tcp: zero retrans_stamp if all retrans were acked)
  /* Undo during loss recovery after partial ACK or using F-RTO. */
  static bool tcp_try_undo_loss(struct sock *sk, bool frto_undo)
  {
* Unmerged path net/ipv4/tcp_input.c
