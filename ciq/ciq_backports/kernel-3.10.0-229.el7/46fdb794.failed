shmem: support RENAME_WHITEOUT

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Miklos Szeredi <mszeredi@suse.cz>
commit 46fdb794e3f52ef18b859ebc92f0a9d7db21c5df
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/46fdb794.failed

Allocate a dentry, initialize it with a whiteout and hash it in the place
of the old dentry.  Later the old dentry will be moved away and the
whiteout will remain.

i_mutex protects agains concurrent readdir.

	Signed-off-by: Miklos Szeredi <mszeredi@suse.cz>
	Cc: Hugh Dickins <hughd@google.com>
(cherry picked from commit 46fdb794e3f52ef18b859ebc92f0a9d7db21c5df)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/shmem.c
diff --cc mm/shmem.c
index 22692ea1ab67,185836ba53ef..000000000000
--- a/mm/shmem.c
+++ b/mm/shmem.c
@@@ -2052,6 -2323,54 +2052,57 @@@ static int shmem_rmdir(struct inode *di
  	return shmem_unlink(dir, dentry);
  }
  
++<<<<<<< HEAD
++=======
+ static int shmem_exchange(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
+ {
+ 	bool old_is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
+ 	bool new_is_dir = S_ISDIR(new_dentry->d_inode->i_mode);
+ 
+ 	if (old_dir != new_dir && old_is_dir != new_is_dir) {
+ 		if (old_is_dir) {
+ 			drop_nlink(old_dir);
+ 			inc_nlink(new_dir);
+ 		} else {
+ 			drop_nlink(new_dir);
+ 			inc_nlink(old_dir);
+ 		}
+ 	}
+ 	old_dir->i_ctime = old_dir->i_mtime =
+ 	new_dir->i_ctime = new_dir->i_mtime =
+ 	old_dentry->d_inode->i_ctime =
+ 	new_dentry->d_inode->i_ctime = CURRENT_TIME;
+ 
+ 	return 0;
+ }
+ 
+ static int shmem_whiteout(struct inode *old_dir, struct dentry *old_dentry)
+ {
+ 	struct dentry *whiteout;
+ 	int error;
+ 
+ 	whiteout = d_alloc(old_dentry->d_parent, &old_dentry->d_name);
+ 	if (!whiteout)
+ 		return -ENOMEM;
+ 
+ 	error = shmem_mknod(old_dir, whiteout,
+ 			    S_IFCHR | WHITEOUT_MODE, WHITEOUT_DEV);
+ 	dput(whiteout);
+ 	if (error)
+ 		return error;
+ 
+ 	/*
+ 	 * Cheat and hash the whiteout while the old dentry is still in
+ 	 * place, instead of playing games with FS_RENAME_DOES_D_MOVE.
+ 	 *
+ 	 * d_lookup() will consistently find one of them at this point,
+ 	 * not sure which one, but that isn't even important.
+ 	 */
+ 	d_rehash(whiteout);
+ 	return 0;
+ }
+ 
++>>>>>>> 46fdb794e3f5 (shmem: support RENAME_WHITEOUT)
  /*
   * The VFS layer already does all the dentry stuff for rename,
   * we just have to decrement the usage count for the target if
@@@ -2063,13 -2382,29 +2114,30 @@@ static int shmem_rename(struct inode *o
  	struct inode *inode = old_dentry->d_inode;
  	int they_are_dirs = S_ISDIR(inode->i_mode);
  
++<<<<<<< HEAD
++=======
+ 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
+ 		return -EINVAL;
+ 
+ 	if (flags & RENAME_EXCHANGE)
+ 		return shmem_exchange(old_dir, old_dentry, new_dir, new_dentry);
+ 
++>>>>>>> 46fdb794e3f5 (shmem: support RENAME_WHITEOUT)
  	if (!simple_empty(new_dentry))
  		return -ENOTEMPTY;
  
+ 	if (flags & RENAME_WHITEOUT) {
+ 		int error;
+ 
+ 		error = shmem_whiteout(old_dir, old_dentry);
+ 		if (error)
+ 			return error;
+ 	}
+ 
  	if (new_dentry->d_inode) {
  		(void) shmem_unlink(new_dir, new_dentry);
 -		if (they_are_dirs) {
 -			drop_nlink(new_dentry->d_inode);
 +		if (they_are_dirs)
  			drop_nlink(old_dir);
 -		}
  	} else if (they_are_dirs) {
  		drop_nlink(old_dir);
  		inc_nlink(new_dir);
* Unmerged path mm/shmem.c
