netfilter: ctnetlink: fix dumping of dying/unconfirmed conntracks

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Pablo Neira Ayuso <pablo@netfilter.org>
commit 266155b2de8fb721ae353688529b2f8bcdde2f90
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/266155b2.failed

The dumping prematurely stops, it seems the callback argument that
indicates that all entries have been dumped is set after iterating
on the first cpu list. The dumping also may stop before the entire
per-cpu list content is also dumped.

With this patch, conntrack -L dying now shows the dying list content
again.

Fixes: b7779d06 ("netfilter: conntrack: spinlock per cpu to protect special lists.")
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 266155b2de8fb721ae353688529b2f8bcdde2f90)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_netlink.c
diff --cc net/netfilter/nf_conntrack_netlink.c
index 45b335fdc999,ef0eedd70541..000000000000
--- a/net/netfilter/nf_conntrack_netlink.c
+++ b/net/netfilter/nf_conntrack_netlink.c
@@@ -1150,37 -1163,48 +1150,82 @@@ ctnetlink_dump_list(struct sk_buff *skb
  	if (cb->args[2])
  		return 0;
  
++<<<<<<< HEAD
 +	spin_lock_bh(&nf_conntrack_lock);
 +	last = (struct nf_conn *)cb->args[1];
 +restart:
 +	hlist_nulls_for_each_entry(h, n, list, hnnode) {
 +		ct = nf_ct_tuplehash_to_ctrack(h);
 +		if (l3proto && nf_ct_l3num(ct) != l3proto)
 +			continue;
++=======
+ 	for (cpu = cb->args[0]; cpu < nr_cpu_ids; cpu++) {
+ 		struct ct_pcpu *pcpu;
+ 
+ 		if (!cpu_possible(cpu))
+ 			continue;
+ 
+ 		pcpu = per_cpu_ptr(net->ct.pcpu_lists, cpu);
+ 		spin_lock_bh(&pcpu->lock);
+ 		last = (struct nf_conn *)cb->args[1];
+ 		list = dying ? &pcpu->dying : &pcpu->unconfirmed;
+ restart:
+ 		hlist_nulls_for_each_entry(h, n, list, hnnode) {
+ 			ct = nf_ct_tuplehash_to_ctrack(h);
+ 			if (l3proto && nf_ct_l3num(ct) != l3proto)
+ 				continue;
+ 			if (cb->args[1]) {
+ 				if (ct != last)
+ 					continue;
+ 				cb->args[1] = 0;
+ 			}
+ 			rcu_read_lock();
+ 			res = ctnetlink_fill_info(skb, NETLINK_CB(cb->skb).portid,
+ 						  cb->nlh->nlmsg_seq,
+ 						  NFNL_MSG_TYPE(cb->nlh->nlmsg_type),
+ 						  ct);
+ 			rcu_read_unlock();
+ 			if (res < 0) {
+ 				nf_conntrack_get(&ct->ct_general);
+ 				cb->args[0] = cpu;
+ 				cb->args[1] = (unsigned long)ct;
+ 				spin_unlock_bh(&pcpu->lock);
+ 				goto out;
+ 			}
+ 		}
++>>>>>>> 266155b2de8f (netfilter: ctnetlink: fix dumping of dying/unconfirmed conntracks)
  		if (cb->args[1]) {
 +			if (ct != last)
 +				continue;
  			cb->args[1] = 0;
++<<<<<<< HEAD
 +		}
 +		rcu_read_lock();
 +		res = ctnetlink_fill_info(skb, NETLINK_CB(cb->skb).portid,
 +					  cb->nlh->nlmsg_seq,
 +					  NFNL_MSG_TYPE(cb->nlh->nlmsg_type),
 +					  ct);
 +		rcu_read_unlock();
 +		if (res < 0) {
 +			nf_conntrack_get(&ct->ct_general);
 +			cb->args[1] = (unsigned long)ct;
 +			goto out;
 +		}
 +	}
 +	if (cb->args[1]) {
 +		cb->args[1] = 0;
 +		goto restart;
 +	} else
 +		cb->args[2] = 1;
++=======
+ 			goto restart;
+ 		}
+ 		spin_unlock_bh(&pcpu->lock);
+ 	}
+ 	cb->args[2] = 1;
++>>>>>>> 266155b2de8f (netfilter: ctnetlink: fix dumping of dying/unconfirmed conntracks)
  out:
 +	spin_unlock_bh(&nf_conntrack_lock);
  	if (last)
  		nf_ct_put(last);
  
* Unmerged path net/netfilter/nf_conntrack_netlink.c
