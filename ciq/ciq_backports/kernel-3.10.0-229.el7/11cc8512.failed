x86/efi: Dump the EFI page table

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [x86] efi: Dump the EFI page table (Dave Young) [1080109]
Rebuild_FUZZ: 93.33%
commit-author Borislav Petkov <bp@suse.de>
commit 11cc851254b4bc3bd4430be8db2a41469303a427
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/11cc8512.failed

This is very useful for debugging issues with the recently added
pagetable switching code for EFI virtual mode.

	Signed-off-by: Borislav Petkov <bp@suse.de>
	Tested-by: Toshi Kani <toshi.kani@hp.com>
	Signed-off-by: Matt Fleming <matt.fleming@intel.com>
(cherry picked from commit 11cc851254b4bc3bd4430be8db2a41469303a427)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/include/asm/efi.h
#	arch/x86/platform/efi/efi.c
#	arch/x86/platform/efi/efi_32.c
#	arch/x86/platform/efi/efi_64.c
diff --cc arch/x86/include/asm/efi.h
index 0062a0125041,4afd3b3b658f..000000000000
--- a/arch/x86/include/asm/efi.h
+++ b/arch/x86/include/asm/efi.h
@@@ -101,6 -126,24 +101,27 @@@ extern void efi_call_phys_prelog(void)
  extern void efi_call_phys_epilog(void);
  extern void efi_unmap_memmap(void);
  extern void efi_memory_uc(u64 addr, unsigned long size);
++<<<<<<< HEAD
++=======
+ extern void __init efi_map_region(efi_memory_desc_t *md);
+ extern void __init efi_map_region_fixed(efi_memory_desc_t *md);
+ extern void efi_sync_low_kernel_mappings(void);
+ extern void efi_setup_page_tables(void);
+ extern void __init old_map_region(efi_memory_desc_t *md);
+ extern void __init runtime_code_page_mkexec(void);
+ extern void __init efi_runtime_mkexec(void);
+ extern void __init efi_dump_pagetable(void);
+ 
+ struct efi_setup_data {
+ 	u64 fw_vendor;
+ 	u64 runtime;
+ 	u64 tables;
+ 	u64 smbios;
+ 	u64 reserved[8];
+ };
+ 
+ extern u64 efi_setup;
++>>>>>>> 11cc851254b4 (x86/efi: Dump the EFI page table)
  
  #ifdef CONFIG_EFI
  
diff --cc arch/x86/platform/efi/efi.c
index 4ba4bd5dfe10,37f20d71ec4b..000000000000
--- a/arch/x86/platform/efi/efi.c
+++ b/arch/x86/platform/efi/efi.c
@@@ -855,16 -1019,22 +855,22 @@@ void __init efi_enter_virtual_mode(void
  
  	BUG_ON(!efi.systab);
  
++<<<<<<< HEAD
 +	status = phys_efi_set_virtual_address_map(
 +		memmap.desc_size * count,
 +		memmap.desc_size,
 +		memmap.desc_version,
 +		(efi_memory_desc_t *)__pa(new_memmap));
++=======
+ 	efi_setup_page_tables();
+ 	efi_sync_low_kernel_mappings();
+ 	efi_dump_pagetable();
++>>>>>>> 11cc851254b4 (x86/efi: Dump the EFI page table)
  
 -	if (!efi_setup) {
 -		status = phys_efi_set_virtual_address_map(
 -			memmap.desc_size * count,
 -			memmap.desc_size,
 -			memmap.desc_version,
 -			(efi_memory_desc_t *)__pa(new_memmap));
 -
 -		if (status != EFI_SUCCESS) {
 -			pr_alert("Unable to switch EFI into virtual mode (status=%lx)!\n",
 -				 status);
 -			panic("EFI call to SetVirtualAddressMap() failed!");
 -		}
 +	if (status != EFI_SUCCESS) {
 +		pr_alert("Unable to switch EFI into virtual mode "
 +			 "(status=%lx)!\n", status);
 +		panic("EFI call to SetVirtualAddressMap() failed!");
  	}
  
  	/*
diff --cc arch/x86/platform/efi/efi_32.c
index 40e446941dd7,39496ae3928a..000000000000
--- a/arch/x86/platform/efi/efi_32.c
+++ b/arch/x86/platform/efi/efi_32.c
@@@ -37,9 -37,20 +37,24 @@@
   * claim EFI runtime service handler exclusively and to duplicate a memory in
   * low memory space say 0 - 3G.
   */
 +
  static unsigned long efi_rt_eflags;
  
++<<<<<<< HEAD
++=======
+ void efi_sync_low_kernel_mappings(void) {}
+ void efi_setup_page_tables(void) {}
+ void __init efi_dump_pagetable(void) {}
+ 
+ void __init efi_map_region(efi_memory_desc_t *md)
+ {
+ 	old_map_region(md);
+ }
+ 
+ void __init efi_map_region_fixed(efi_memory_desc_t *md) {}
+ void __init parse_efi_setup(u64 phys_addr, u32 data_len) {}
+ 
++>>>>>>> 11cc851254b4 (x86/efi: Dump the EFI page table)
  void efi_call_phys_prelog(void)
  {
  	struct desc_ptr gdt_descr;
diff --cc arch/x86/platform/efi/efi_64.c
index 39a0e7f1f0a3,e05c69b46f05..000000000000
--- a/arch/x86/platform/efi/efi_64.c
+++ b/arch/x86/platform/efi/efi_64.c
@@@ -113,3 -228,26 +113,29 @@@ void __iomem *__init efi_ioremap(unsign
  
  	return (void __iomem *)__va(phys_addr);
  }
++<<<<<<< HEAD
++=======
+ 
+ void __init parse_efi_setup(u64 phys_addr, u32 data_len)
+ {
+ 	efi_setup = phys_addr + sizeof(struct setup_data);
+ }
+ 
+ void __init efi_runtime_mkexec(void)
+ {
+ 	if (!efi_enabled(EFI_OLD_MEMMAP))
+ 		return;
+ 
+ 	if (__supported_pte_mask & _PAGE_NX)
+ 		runtime_code_page_mkexec();
+ }
+ 
+ void __init efi_dump_pagetable(void)
+ {
+ #ifdef CONFIG_EFI_PGT_DUMP
+ 	pgd_t *pgd = (pgd_t *)__va(real_mode_header->trampoline_pgd);
+ 
+ 	ptdump_walk_pgd_level(NULL, pgd);
+ #endif
+ }
++>>>>>>> 11cc851254b4 (x86/efi: Dump the EFI page table)
diff --git a/arch/x86/Kconfig.debug b/arch/x86/Kconfig.debug
index c198b7e13e7b..11b3fd964074 100644
--- a/arch/x86/Kconfig.debug
+++ b/arch/x86/Kconfig.debug
@@ -81,6 +81,15 @@ config X86_PTDUMP
 	  kernel.
 	  If in doubt, say "N"
 
+config EFI_PGT_DUMP
+	bool "Dump the EFI pagetable"
+	depends on EFI && X86_PTDUMP
+	---help---
+	  Enable this if you want to dump the EFI page table before
+	  enabling virtual mode. This can be used to debug miscellaneous
+	  issues with the mapping of the EFI runtime regions into that
+	  table.
+
 config DEBUG_RODATA
 	bool "Write protect kernel read-only data structures"
 	default y
* Unmerged path arch/x86/include/asm/efi.h
* Unmerged path arch/x86/platform/efi/efi.c
* Unmerged path arch/x86/platform/efi/efi_32.c
* Unmerged path arch/x86/platform/efi/efi_64.c
