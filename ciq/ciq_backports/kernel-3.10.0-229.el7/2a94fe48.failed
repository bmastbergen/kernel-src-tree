genetlink: make multicast groups const, prevent abuse

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Johannes Berg <johannes.berg@intel.com>
commit 2a94fe48f32ccf7321450a2cc07f2b724a444e5b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2a94fe48.failed

Register generic netlink multicast groups as an array with
the family and give them contiguous group IDs. Then instead
of passing the global group ID to the various functions that
send messages, pass the ID relative to the family - for most
families that's just 0 because the only have one group.

This avoids the list_head and ID in each group, adding a new
field for the mcast group ID offset to the family.

At the same time, this allows us to prevent abusing groups
again like the quota and dropmon code did, since we can now
check that a family only uses a group it owns.

	Signed-off-by: Johannes Berg <johannes.berg@intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2a94fe48f32ccf7321450a2cc07f2b724a444e5b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/event.c
#	drivers/net/team/team.c
#	drivers/thermal/thermal_core.c
#	fs/quota/netlink.c
#	include/linux/genl_magic_func.h
#	include/net/genetlink.h
#	net/core/drop_monitor.c
#	net/hsr/hsr_netlink.c
#	net/ieee802154/netlink.c
#	net/netlink/genetlink.c
#	net/nfc/netlink.c
#	net/openvswitch/datapath.c
#	net/openvswitch/dp_notify.c
#	net/wimax/op-msg.c
#	net/wimax/stack.c
#	net/wireless/nl80211.c
diff --cc drivers/acpi/event.c
index 1442737cedec,aeb5aa6ce068..000000000000
--- a/drivers/acpi/event.c
+++ b/drivers/acpi/event.c
@@@ -240,7 -148,7 +242,11 @@@ int acpi_bus_generate_netlink_event(con
  		return result;
  	}
  
++<<<<<<< HEAD
 +	genlmsg_multicast(skb, 0, acpi_event_mcgrp.id, GFP_ATOMIC);
++=======
+ 	genlmsg_multicast(&acpi_event_genl_family, skb, 0, 0, GFP_ATOMIC);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return 0;
  }
  
diff --cc drivers/net/team/team.c
index b69a91a1b3d0,0715de50b3dc..000000000000
--- a/drivers/net/team/team.c
+++ b/drivers/net/team/team.c
@@@ -2713,8 -2677,8 +2713,13 @@@ static const struct genl_multicast_grou
  static int team_nl_send_multicast(struct sk_buff *skb,
  				  struct team *team, u32 portid)
  {
++<<<<<<< HEAD
 +	return genlmsg_multicast_netns(dev_net(team->dev), skb, 0,
 +				       team_change_event_mcgrp.id, GFP_KERNEL);
++=======
+ 	return genlmsg_multicast_netns(&team_nl_family, dev_net(team->dev),
+ 				       skb, 0, 0, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  static int team_nl_send_event_options_get(struct team *team,
@@@ -2733,23 -2697,8 +2738,28 @@@ static int team_nl_send_event_port_get(
  
  static int team_nl_init(void)
  {
++<<<<<<< HEAD
 +	int err;
 +
 +	err = genl_register_family_with_ops(&team_nl_family, team_nl_ops,
 +					    ARRAY_SIZE(team_nl_ops));
 +	if (err)
 +		return err;
 +
 +	err = genl_register_mc_group(&team_nl_family, &team_change_event_mcgrp);
 +	if (err)
 +		goto err_change_event_grp_reg;
 +
 +	return 0;
 +
 +err_change_event_grp_reg:
 +	genl_unregister_family(&team_nl_family);
 +
 +	return err;
++=======
+ 	return genl_register_family_with_ops_groups(&team_nl_family, team_nl_ops,
+ 						    team_nl_mcgrps);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  static void team_nl_fini(void)
diff --cc drivers/thermal/thermal_core.c
index d755440791b7,19edd6124ca3..000000000000
--- a/drivers/thermal/thermal_core.c
+++ b/drivers/thermal/thermal_core.c
@@@ -1910,7 -1677,8 +1912,12 @@@ int thermal_generate_netlink_event(stru
  		return result;
  	}
  
++<<<<<<< HEAD
 +	result = genlmsg_multicast(skb, 0, thermal_event_mcgrp.id, GFP_ATOMIC);
++=======
+ 	result = genlmsg_multicast(&thermal_event_genl_family, skb, 0,
+ 				   0, GFP_ATOMIC);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	if (result)
  		dev_err(&tz->device, "Failed to send netlink event:%d", result);
  
diff --cc fs/quota/netlink.c
index aa22fe03b76c,72d29177998e..000000000000
--- a/fs/quota/netlink.c
+++ b/fs/quota/netlink.c
@@@ -88,7 -90,7 +90,11 @@@ void quota_send_warning(struct kqid qid
  		goto attr_err_out;
  	genlmsg_end(skb, msg_head);
  
++<<<<<<< HEAD
 +	genlmsg_multicast(skb, 0, quota_mcgrp.id, GFP_NOFS);
++=======
+ 	genlmsg_multicast(&quota_genl_family, skb, 0, 0, GFP_NOFS);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  attr_err_out:
  	printk(KERN_ERR "VFS: Not enough space to compose quota message!\n");
diff --cc include/linux/genl_magic_func.h
index 023bc346b877,c0894dd8827b..000000000000
--- a/include/linux/genl_magic_func.h
+++ b/include/linux/genl_magic_func.h
@@@ -283,39 -292,21 +292,50 @@@ static int CONCAT_(GENL_MAGIC_FAMILY, _
  	struct sk_buff *skb, gfp_t flags)				\
  {									\
  	unsigned int group_id =						\
++<<<<<<< HEAD
 +		CONCAT_(GENL_MAGIC_FAMILY, _mcg_ ## group).id;	\
 +	if (!group_id)							\
 +		return -EINVAL;						\
 +	return genlmsg_multicast(skb, 0, group_id, flags);		\
++=======
+ 		CONCAT_(GENL_MAGIC_FAMILY, _group_ ## group);		\
+ 	return genlmsg_multicast(&ZZZ_genl_family, skb, 0,		\
+ 				 group_id, flags);			\
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  #include GENL_MAGIC_INCLUDE_FILE
  
++<<<<<<< HEAD
 +int CONCAT_(GENL_MAGIC_FAMILY, _genl_register)(void)
 +{
 +	int err = genl_register_family_with_ops(&ZZZ_genl_family,
 +		ZZZ_genl_ops, ARRAY_SIZE(ZZZ_genl_ops));
 +	if (err)
 +		return err;
 +#undef GENL_mc_group
 +#define GENL_mc_group(group)						\
 +	err = genl_register_mc_group(&ZZZ_genl_family,			\
 +		&CONCAT_(GENL_MAGIC_FAMILY, _mcg_ ## group));		\
 +	if (err)							\
 +		goto fail;						\
 +	else								\
 +		pr_info("%s: mcg %s: %u\n", #group,			\
 +			__stringify(GENL_MAGIC_FAMILY),			\
 +			CONCAT_(GENL_MAGIC_FAMILY, _mcg_ ## group).id);
 +
 +#include GENL_MAGIC_INCLUDE_FILE
 +
++=======
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  #undef GENL_mc_group
  #define GENL_mc_group(group)
- 	return 0;
- fail:
- 	genl_unregister_family(&ZZZ_genl_family);
- 	return err;
+ 
+ int CONCAT_(GENL_MAGIC_FAMILY, _genl_register)(void)
+ {
+ 	return genl_register_family_with_ops_groups(&ZZZ_genl_family,	\
+ 						    ZZZ_genl_ops,	\
+ 						    ZZZ_genl_mcgrps);
  }
  
  void CONCAT_(GENL_MAGIC_FAMILY, _genl_unregister)(void)
diff --cc include/net/genetlink.h
index 27c2f8bde546,ace4abf118d7..000000000000
--- a/include/net/genetlink.h
+++ b/include/net/genetlink.h
@@@ -58,17 -55,12 +55,19 @@@ struct genl_family 
  					     struct genl_info *info);
  	struct nlattr **	attrbuf;	/* private */
  	const struct genl_ops *	ops;		/* private */
+ 	const struct genl_multicast_group *mcgrps; /* private */
  	unsigned int		n_ops;		/* private */
+ 	unsigned int		n_mcgrps;	/* private */
+ 	unsigned int		mcgrp_offset;	/* private */
  	struct list_head	family_list;	/* private */
- 	struct list_head	mcast_groups;	/* private */
  	struct module		*module;
 +
 +	/* Reserved slots. For Red Hat usage only, modules are required to
 +	 * set them to zero. */
 +	unsigned long		rh_reserved1;
 +	unsigned long		rh_reserved2;
 +	unsigned long		rh_reserved3;
 +	unsigned long		rh_reserved4;
  };
  
  /**
@@@ -159,8 -149,11 +158,16 @@@ static inline int genl_register_family(
   *
   * Return 0 on success or a negative error code.
   */
++<<<<<<< HEAD
 +static inline int genl_register_family_with_ops(struct genl_family *family,
 +	const struct genl_ops *ops, size_t n_ops)
++=======
+ static inline int
+ _genl_register_family_with_ops_grps(struct genl_family *family,
+ 				    const struct genl_ops *ops, size_t n_ops,
+ 				    const struct genl_multicast_group *mcgrps,
+ 				    size_t n_mcgrps)
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  {
  	family->module = THIS_MODULE;
  	family->ops = ops;
@@@ -168,14 -163,20 +177,29 @@@
  	return __genl_register_family(family);
  }
  
++<<<<<<< HEAD
 +int genl_unregister_family(struct genl_family *family);
 +int genl_register_mc_group(struct genl_family *family,
 +			   struct genl_multicast_group *grp);
 +void genl_notify(struct sk_buff *skb, struct net *net, u32 portid,
++=======
+ #define genl_register_family_with_ops(family, ops)			\
+ 	_genl_register_family_with_ops_grps((family),			\
+ 					    (ops), ARRAY_SIZE(ops),	\
+ 					    NULL, 0)
+ #define genl_register_family_with_ops_groups(family, ops, grps)	\
+ 	_genl_register_family_with_ops_grps((family),			\
+ 					    (ops), ARRAY_SIZE(ops),	\
+ 					    (grps), ARRAY_SIZE(grps))
+ 
+ int genl_unregister_family(struct genl_family *family);
+ void genl_notify(struct genl_family *family,
+ 		 struct sk_buff *skb, struct net *net, u32 portid,
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  		 u32 group, struct nlmsghdr *nlh, gfp_t flags);
  
 +struct sk_buff *genlmsg_new_unicast(size_t payload, struct genl_info *info,
 +				    gfp_t flags);
  void *genlmsg_put(struct sk_buff *skb, u32 portid, u32 seq,
  		  struct genl_family *family, int flags, u8 cmd);
  
@@@ -256,33 -257,45 +280,44 @@@ static inline void genlmsg_cancel(struc
   * @net: the net namespace
   * @skb: netlink message as socket buffer
   * @portid: own netlink portid to avoid sending to yourself
-  * @group: multicast group id
+  * @group: offset of multicast group in groups array
   * @flags: allocation flags
   */
 -static inline int genlmsg_multicast_netns(struct genl_family *family,
 -					  struct net *net, struct sk_buff *skb,
 +static inline int genlmsg_multicast_netns(struct net *net, struct sk_buff *skb,
  					  u32 portid, unsigned int group, gfp_t flags)
  {
+ 	if (group >= family->n_mcgrps)
+ 		return -EINVAL;
+ 	group = family->mcgrp_offset + group;
  	return nlmsg_multicast(net->genl_sock, skb, portid, group, flags);
  }
  
  /**
   * genlmsg_multicast - multicast a netlink message to the default netns
 - * @family: the generic netlink family
   * @skb: netlink message as socket buffer
   * @portid: own netlink portid to avoid sending to yourself
-  * @group: multicast group id
+  * @group: offset of multicast group in groups array
   * @flags: allocation flags
   */
 -static inline int genlmsg_multicast(struct genl_family *family,
 -				    struct sk_buff *skb, u32 portid,
 +static inline int genlmsg_multicast(struct sk_buff *skb, u32 portid,
  				    unsigned int group, gfp_t flags)
  {
++<<<<<<< HEAD
 +	return genlmsg_multicast_netns(&init_net, skb, portid, group, flags);
++=======
+ 	if (group >= family->n_mcgrps)
+ 		return -EINVAL;
+ 	group = family->mcgrp_offset + group;
+ 	return genlmsg_multicast_netns(family, &init_net, skb,
+ 				       portid, group, flags);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  /**
   * genlmsg_multicast_allns - multicast a netlink message to all net namespaces
 - * @family: the generic netlink family
   * @skb: netlink message as socket buffer
   * @portid: own netlink portid to avoid sending to yourself
-  * @group: multicast group id
+  * @group: offset of multicast group in groups array
   * @flags: allocation flags
   *
   * This function must hold the RTNL or rcu_read_lock().
diff --cc net/core/drop_monitor.c
index 383213606109,95897183226e..000000000000
--- a/net/core/drop_monitor.c
+++ b/net/core/drop_monitor.c
@@@ -120,7 -120,8 +120,12 @@@ static void send_dm_alert(struct work_s
  	skb = reset_per_cpu_data(data);
  
  	if (skb)
++<<<<<<< HEAD
 +		genlmsg_multicast(skb, 0, dm_mcgrp.id, GFP_KERNEL);
++=======
+ 		genlmsg_multicast(&net_drop_monitor_family, skb, 0,
+ 				  0, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  /*
@@@ -368,9 -369,8 +373,14 @@@ static int __init init_net_drop_monitor
  		return -ENOSPC;
  	}
  
++<<<<<<< HEAD
 +	rc = genl_register_family_with_ops(&net_drop_monitor_family,
 +					   dropmon_ops,
 +					   ARRAY_SIZE(dropmon_ops));
++=======
+ 	rc = genl_register_family_with_ops_groups(&net_drop_monitor_family,
+ 						  dropmon_ops, dropmon_mcgrps);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	if (rc) {
  		pr_err("Could not create drop monitor netlink family\n");
  		return rc;
diff --cc net/ieee802154/netlink.c
index eb9faef6782a,43f1b2bf469f..000000000000
--- a/net/ieee802154/netlink.c
+++ b/net/ieee802154/netlink.c
@@@ -125,26 -125,17 +125,38 @@@ static struct genl_ops ieee8021154_ops[
  			ieee802154_dump_iface),
  };
  
+ static const struct genl_multicast_group ieee802154_mcgrps[] = {
+ 	[IEEE802154_COORD_MCGRP] = { .name = IEEE802154_MCAST_COORD_NAME, },
+ 	[IEEE802154_BEACON_MCGRP] = { .name = IEEE802154_MCAST_BEACON_NAME, },
+ };
+ 
+ 
  int __init ieee802154_nl_init(void)
  {
++<<<<<<< HEAD
 +	int rc;
 +
 +	rc = genl_register_family_with_ops(&nl802154_family, ieee8021154_ops,
 +					   ARRAY_SIZE(ieee8021154_ops));
 +	if (rc)
 +		return rc;
 +
 +	rc = genl_register_mc_group(&nl802154_family, &ieee802154_coord_mcgrp);
 +	if (rc)
 +		goto fail;
 +
 +	rc = genl_register_mc_group(&nl802154_family, &ieee802154_beacon_mcgrp);
 +	if (rc)
 +		goto fail;
 +	return 0;
 +fail:
 +	genl_unregister_family(&nl802154_family);
 +	return rc;
++=======
+ 	return genl_register_family_with_ops_groups(&nl802154_family,
+ 						    ieee8021154_ops,
+ 						    ieee802154_mcgrps);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  void __exit ieee802154_nl_exit(void)
diff --cc net/netlink/genetlink.c
index fa66966658bc,7dbc4f732c75..000000000000
--- a/net/netlink/genetlink.c
+++ b/net/netlink/genetlink.c
@@@ -904,26 -934,29 +955,35 @@@ static int genl_ctrl_event(int event, s
  		return PTR_ERR(msg);
  
  	if (!family->netnsok) {
++<<<<<<< HEAD
 +		genlmsg_multicast_netns(&init_net, msg, 0,
 +					GENL_ID_CTRL, GFP_KERNEL);
 +	} else {
 +		rcu_read_lock();
 +		genlmsg_multicast_allns(msg, 0, GENL_ID_CTRL, GFP_ATOMIC);
++=======
+ 		genlmsg_multicast_netns(&genl_ctrl, &init_net, msg, 0,
+ 					0, GFP_KERNEL);
+ 	} else {
+ 		rcu_read_lock();
+ 		genlmsg_multicast_allns(&genl_ctrl, msg, 0,
+ 					0, GFP_ATOMIC);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  		rcu_read_unlock();
  	}
  
  	return 0;
  }
  
 -static struct genl_ops genl_ctrl_ops[] = {
 -	{
 -		.cmd		= CTRL_CMD_GETFAMILY,
 -		.doit		= ctrl_getfamily,
 -		.dumpit		= ctrl_dumpfamily,
 -		.policy		= ctrl_policy,
 -	},
 +static struct genl_ops genl_ctrl_ops = {
 +	.cmd		= CTRL_CMD_GETFAMILY,
 +	.doit		= ctrl_getfamily,
 +	.dumpit		= ctrl_dumpfamily,
 +	.policy		= ctrl_policy,
  };
  
- static struct genl_multicast_group notify_grp = {
- 	.name		= "notify",
+ static struct genl_multicast_group genl_ctrl_groups[] = {
+ 	{ .name = "notify", },
  };
  
  static int __net_init genl_pernet_init(struct net *net)
@@@ -963,7 -996,8 +1023,12 @@@ static int __init genl_init(void
  	for (i = 0; i < GENL_FAM_TAB_SIZE; i++)
  		INIT_LIST_HEAD(&family_ht[i]);
  
++<<<<<<< HEAD
 +	err = genl_register_family_with_ops(&genl_ctrl, &genl_ctrl_ops, 1);
++=======
+ 	err = genl_register_family_with_ops_groups(&genl_ctrl, genl_ctrl_ops,
+ 						   genl_ctrl_groups);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	if (err < 0)
  		goto problem;
  
@@@ -1012,9 -1042,12 +1073,12 @@@ static int genlmsg_mcast(struct sk_buf
  	return err;
  }
  
 -int genlmsg_multicast_allns(struct genl_family *family, struct sk_buff *skb,
 -			    u32 portid, unsigned int group, gfp_t flags)
 +int genlmsg_multicast_allns(struct sk_buff *skb, u32 portid, unsigned int group,
 +			    gfp_t flags)
  {
+ 	if (group >= family->n_mcgrps)
+ 		return -EINVAL;
+ 	group = family->mcgrp_offset + group;
  	return genlmsg_mcast(skb, portid, group, flags);
  }
  EXPORT_SYMBOL(genlmsg_multicast_allns);
diff --cc net/nfc/netlink.c
index f0c4d61f37c0,a9b2342d5253..000000000000
--- a/net/nfc/netlink.c
+++ b/net/nfc/netlink.c
@@@ -191,7 -194,7 +191,11 @@@ int nfc_genl_targets_found(struct nfc_d
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	return genlmsg_multicast(msg, 0, nfc_genl_event_mcgrp.id, GFP_ATOMIC);
++=======
+ 	return genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  
  nla_put_failure:
  	genlmsg_cancel(msg, hdr);
@@@ -220,7 -223,7 +224,11 @@@ int nfc_genl_target_lost(struct nfc_de
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast(msg, 0, nfc_genl_event_mcgrp.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  
  	return 0;
  
@@@ -252,7 -255,7 +260,11 @@@ int nfc_genl_tm_activated(struct nfc_de
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast(msg, 0, nfc_genl_event_mcgrp.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  
  	return 0;
  
@@@ -282,7 -285,7 +294,11 @@@ int nfc_genl_tm_deactivated(struct nfc_
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast(msg, 0, nfc_genl_event_mcgrp.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  
  	return 0;
  
@@@ -315,7 -318,7 +331,11 @@@ int nfc_genl_device_added(struct nfc_de
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast(msg, 0, nfc_genl_event_mcgrp.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  
  	return 0;
  
@@@ -345,7 -348,7 +365,11 @@@ int nfc_genl_device_removed(struct nfc_
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast(msg, 0, nfc_genl_event_mcgrp.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  
  	return 0;
  
@@@ -411,7 -414,7 +435,11 @@@ int nfc_genl_llc_send_sdres(struct nfc_
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	return genlmsg_multicast(msg, 0, nfc_genl_event_mcgrp.id, GFP_ATOMIC);
++=======
+ 	return genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  
  nla_put_failure:
  	genlmsg_cancel(msg, hdr);
@@@ -424,6 -427,69 +452,72 @@@ free_msg
  	return rc;
  }
  
++<<<<<<< HEAD
++=======
+ int nfc_genl_se_added(struct nfc_dev *dev, u32 se_idx, u16 type)
+ {
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	hdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,
+ 			  NFC_EVENT_SE_ADDED);
+ 	if (!hdr)
+ 		goto free_msg;
+ 
+ 	if (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||
+ 	    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx) ||
+ 	    nla_put_u8(msg, NFC_ATTR_SE_TYPE, type))
+ 		goto nla_put_failure;
+ 
+ 	genlmsg_end(msg, hdr);
+ 
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ 	genlmsg_cancel(msg, hdr);
+ free_msg:
+ 	nlmsg_free(msg);
+ 	return -EMSGSIZE;
+ }
+ 
+ int nfc_genl_se_removed(struct nfc_dev *dev, u32 se_idx)
+ {
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	hdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,
+ 			  NFC_EVENT_SE_REMOVED);
+ 	if (!hdr)
+ 		goto free_msg;
+ 
+ 	if (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||
+ 	    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se_idx))
+ 		goto nla_put_failure;
+ 
+ 	genlmsg_end(msg, hdr);
+ 
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ 	genlmsg_cancel(msg, hdr);
+ free_msg:
+ 	nlmsg_free(msg);
+ 	return -EMSGSIZE;
+ }
+ 
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  static int nfc_genl_send_device(struct sk_buff *msg, struct nfc_dev *dev,
  				u32 portid, u32 seq,
  				struct netlink_callback *cb,
@@@ -535,7 -600,7 +629,11 @@@ int nfc_genl_dep_link_up_event(struct n
  
  	dev->dep_link_up = true;
  
++<<<<<<< HEAD
 +	genlmsg_multicast(msg, 0, nfc_genl_event_mcgrp.id, GFP_ATOMIC);
++=======
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  
  	return 0;
  
@@@ -567,7 -632,7 +665,11 @@@ int nfc_genl_dep_link_down_event(struc
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast(msg, 0, nfc_genl_event_mcgrp.id, GFP_ATOMIC);
++=======
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  
  	return 0;
  
@@@ -1025,7 -1090,281 +1127,285 @@@ exit
  	return rc;
  }
  
++<<<<<<< HEAD
 +static struct genl_ops nfc_genl_ops[] = {
++=======
+ static int nfc_genl_fw_download(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct nfc_dev *dev;
+ 	int rc;
+ 	u32 idx;
+ 	char firmware_name[NFC_FIRMWARE_NAME_MAXSIZE + 1];
+ 
+ 	if (!info->attrs[NFC_ATTR_DEVICE_INDEX])
+ 		return -EINVAL;
+ 
+ 	idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);
+ 
+ 	dev = nfc_get_device(idx);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	nla_strlcpy(firmware_name, info->attrs[NFC_ATTR_FIRMWARE_NAME],
+ 		    sizeof(firmware_name));
+ 
+ 	rc = nfc_fw_download(dev, firmware_name);
+ 
+ 	nfc_put_device(dev);
+ 	return rc;
+ }
+ 
+ int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,
+ 			      u32 result)
+ {
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	hdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,
+ 			  NFC_CMD_FW_DOWNLOAD);
+ 	if (!hdr)
+ 		goto free_msg;
+ 
+ 	if (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||
+ 	    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||
+ 	    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))
+ 		goto nla_put_failure;
+ 
+ 	genlmsg_end(msg, hdr);
+ 
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ 	genlmsg_cancel(msg, hdr);
+ free_msg:
+ 	nlmsg_free(msg);
+ 	return -EMSGSIZE;
+ }
+ 
+ static int nfc_genl_enable_se(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct nfc_dev *dev;
+ 	int rc;
+ 	u32 idx, se_idx;
+ 
+ 	if (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||
+ 	    !info->attrs[NFC_ATTR_SE_INDEX])
+ 		return -EINVAL;
+ 
+ 	idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);
+ 	se_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);
+ 
+ 	dev = nfc_get_device(idx);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	rc = nfc_enable_se(dev, se_idx);
+ 
+ 	nfc_put_device(dev);
+ 	return rc;
+ }
+ 
+ static int nfc_genl_disable_se(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct nfc_dev *dev;
+ 	int rc;
+ 	u32 idx, se_idx;
+ 
+ 	if (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||
+ 	    !info->attrs[NFC_ATTR_SE_INDEX])
+ 		return -EINVAL;
+ 
+ 	idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);
+ 	se_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);
+ 
+ 	dev = nfc_get_device(idx);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	rc = nfc_disable_se(dev, se_idx);
+ 
+ 	nfc_put_device(dev);
+ 	return rc;
+ }
+ 
+ static int nfc_genl_send_se(struct sk_buff *msg, struct nfc_dev *dev,
+ 				u32 portid, u32 seq,
+ 				struct netlink_callback *cb,
+ 				int flags)
+ {
+ 	void *hdr;
+ 	struct nfc_se *se, *n;
+ 
+ 	list_for_each_entry_safe(se, n, &dev->secure_elements, list) {
+ 		hdr = genlmsg_put(msg, portid, seq, &nfc_genl_family, flags,
+ 				  NFC_CMD_GET_SE);
+ 		if (!hdr)
+ 			goto nla_put_failure;
+ 
+ 		if (cb)
+ 			genl_dump_check_consistent(cb, hdr, &nfc_genl_family);
+ 
+ 		if (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx) ||
+ 		    nla_put_u32(msg, NFC_ATTR_SE_INDEX, se->idx) ||
+ 		    nla_put_u8(msg, NFC_ATTR_SE_TYPE, se->type))
+ 			goto nla_put_failure;
+ 
+ 		if (genlmsg_end(msg, hdr) < 0)
+ 			goto nla_put_failure;
+ 	}
+ 
+ 	return 0;
+ 
+ nla_put_failure:
+ 	genlmsg_cancel(msg, hdr);
+ 	return -EMSGSIZE;
+ }
+ 
+ static int nfc_genl_dump_ses(struct sk_buff *skb,
+ 				 struct netlink_callback *cb)
+ {
+ 	struct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];
+ 	struct nfc_dev *dev = (struct nfc_dev *) cb->args[1];
+ 	bool first_call = false;
+ 
+ 	if (!iter) {
+ 		first_call = true;
+ 		iter = kmalloc(sizeof(struct class_dev_iter), GFP_KERNEL);
+ 		if (!iter)
+ 			return -ENOMEM;
+ 		cb->args[0] = (long) iter;
+ 	}
+ 
+ 	mutex_lock(&nfc_devlist_mutex);
+ 
+ 	cb->seq = nfc_devlist_generation;
+ 
+ 	if (first_call) {
+ 		nfc_device_iter_init(iter);
+ 		dev = nfc_device_iter_next(iter);
+ 	}
+ 
+ 	while (dev) {
+ 		int rc;
+ 
+ 		rc = nfc_genl_send_se(skb, dev, NETLINK_CB(cb->skb).portid,
+ 					  cb->nlh->nlmsg_seq, cb, NLM_F_MULTI);
+ 		if (rc < 0)
+ 			break;
+ 
+ 		dev = nfc_device_iter_next(iter);
+ 	}
+ 
+ 	mutex_unlock(&nfc_devlist_mutex);
+ 
+ 	cb->args[1] = (long) dev;
+ 
+ 	return skb->len;
+ }
+ 
+ static int nfc_genl_dump_ses_done(struct netlink_callback *cb)
+ {
+ 	struct class_dev_iter *iter = (struct class_dev_iter *) cb->args[0];
+ 
+ 	nfc_device_iter_exit(iter);
+ 	kfree(iter);
+ 
+ 	return 0;
+ }
+ 
+ struct se_io_ctx {
+ 	u32 dev_idx;
+ 	u32 se_idx;
+ };
+ 
+ static void se_io_cb(void *context, u8 *apdu, size_t apdu_len, int err)
+ {
+ 	struct se_io_ctx *ctx = context;
+ 	struct sk_buff *msg;
+ 	void *hdr;
+ 
+ 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
+ 	if (!msg) {
+ 		kfree(ctx);
+ 		return;
+ 	}
+ 
+ 	hdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,
+ 			  NFC_CMD_SE_IO);
+ 	if (!hdr)
+ 		goto free_msg;
+ 
+ 	if (nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, ctx->dev_idx) ||
+ 	    nla_put_u32(msg, NFC_ATTR_SE_INDEX, ctx->se_idx) ||
+ 	    nla_put(msg, NFC_ATTR_SE_APDU, apdu_len, apdu))
+ 		goto nla_put_failure;
+ 
+ 	genlmsg_end(msg, hdr);
+ 
+ 	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
+ 
+ 	kfree(ctx);
+ 
+ 	return;
+ 
+ nla_put_failure:
+ 	genlmsg_cancel(msg, hdr);
+ free_msg:
+ 	nlmsg_free(msg);
+ 	kfree(ctx);
+ 
+ 	return;
+ }
+ 
+ static int nfc_genl_se_io(struct sk_buff *skb, struct genl_info *info)
+ {
+ 	struct nfc_dev *dev;
+ 	struct se_io_ctx *ctx;
+ 	u32 dev_idx, se_idx;
+ 	u8 *apdu;
+ 	size_t apdu_len;
+ 
+ 	if (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||
+ 	    !info->attrs[NFC_ATTR_SE_INDEX] ||
+ 	    !info->attrs[NFC_ATTR_SE_APDU])
+ 		return -EINVAL;
+ 
+ 	dev_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);
+ 	se_idx = nla_get_u32(info->attrs[NFC_ATTR_SE_INDEX]);
+ 
+ 	dev = nfc_get_device(dev_idx);
+ 	if (!dev)
+ 		return -ENODEV;
+ 
+ 	if (!dev->ops || !dev->ops->se_io)
+ 		return -ENOTSUPP;
+ 
+ 	apdu_len = nla_len(info->attrs[NFC_ATTR_SE_APDU]);
+ 	if (apdu_len == 0)
+ 		return -EINVAL;
+ 
+ 	apdu = nla_data(info->attrs[NFC_ATTR_SE_APDU]);
+ 	if (!apdu)
+ 		return -EINVAL;
+ 
+ 	ctx = kzalloc(sizeof(struct se_io_ctx), GFP_KERNEL);
+ 	if (!ctx)
+ 		return -ENOMEM;
+ 
+ 	ctx->dev_idx = dev_idx;
+ 	ctx->se_idx = se_idx;
+ 
+ 	return dev->ops->se_io(dev, se_idx, apdu, apdu_len, se_io_cb, ctx);
+ }
+ 
+ static const struct genl_ops nfc_genl_ops[] = {
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	{
  		.cmd = NFC_CMD_GET_DEVICE,
  		.doit = nfc_genl_get_device,
@@@ -1171,8 -1536,9 +1551,14 @@@ int __init nfc_genl_init(void
  {
  	int rc;
  
++<<<<<<< HEAD
 +	rc = genl_register_family_with_ops(&nfc_genl_family, nfc_genl_ops,
 +					   ARRAY_SIZE(nfc_genl_ops));
++=======
+ 	rc = genl_register_family_with_ops_groups(&nfc_genl_family,
+ 						  nfc_genl_ops,
+ 						  nfc_genl_mcgrps);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	if (rc)
  		return rc;
  
diff --cc net/openvswitch/datapath.c
index 4cd9aea30532,1de4d281e3f1..000000000000
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@@ -62,11 -61,11 +62,19 @@@
  
  int ovs_net_id __read_mostly;
  
++<<<<<<< HEAD
 +static void ovs_notify(struct sk_buff *skb, struct genl_info *info,
 +		       struct genl_multicast_group *grp)
 +{
 +	genl_notify(skb, genl_info_net(info), info->snd_portid,
 +		    grp->id, info->nlhdr, GFP_KERNEL);
++=======
+ static void ovs_notify(struct genl_family *family,
+ 		       struct sk_buff *skb, struct genl_info *info)
+ {
+ 	genl_notify(family, skb, genl_info_net(info), info->snd_portid,
+ 		    0, info->nlhdr, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  /**
@@@ -877,10 -877,10 +885,17 @@@ static int ovs_flow_cmd_new_or_set(stru
  	ovs_unlock();
  
  	if (!IS_ERR(reply))
++<<<<<<< HEAD
 +		ovs_notify(reply, info, &ovs_dp_flow_multicast_group);
 +	else
 +		genl_set_err(sock_net(skb->sk), 0,
 +			     ovs_dp_flow_multicast_group.id, PTR_ERR(reply));
++=======
+ 		ovs_notify(&dp_flow_genl_family, reply, info);
+ 	else
+ 		genl_set_err(&dp_flow_genl_family, sock_net(skb->sk), 0,
+ 			     0, PTR_ERR(reply));
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return 0;
  
  err_flow_free:
@@@ -989,7 -990,7 +1004,11 @@@ static int ovs_flow_cmd_del(struct sk_b
  	ovs_flow_free(flow, true);
  	ovs_unlock();
  
++<<<<<<< HEAD
 +	ovs_notify(reply, info, &ovs_dp_flow_multicast_group);
++=======
+ 	ovs_notify(&dp_flow_genl_family, reply, info);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return 0;
  unlock:
  	ovs_unlock();
@@@ -1269,7 -1237,7 +1288,11 @@@ static int ovs_dp_cmd_new(struct sk_buf
  
  	ovs_unlock();
  
++<<<<<<< HEAD
 +	ovs_notify(reply, info, &ovs_dp_datapath_multicast_group);
++=======
+ 	ovs_notify(&dp_datapath_genl_family, reply, info);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return 0;
  
  err_destroy_local_port:
@@@ -1336,7 -1302,7 +1359,11 @@@ static int ovs_dp_cmd_del(struct sk_buf
  	__dp_destroy(dp);
  	ovs_unlock();
  
++<<<<<<< HEAD
 +	ovs_notify(reply, info, &ovs_dp_datapath_multicast_group);
++=======
+ 	ovs_notify(&dp_datapath_genl_family, reply, info);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  
  	return 0;
  unlock:
@@@ -1356,19 -1322,18 +1383,28 @@@ static int ovs_dp_cmd_set(struct sk_buf
  	if (IS_ERR(dp))
  		goto unlock;
  
 -	reply = ovs_dp_cmd_build_info(dp, info->snd_portid,
 -				      info->snd_seq, OVS_DP_CMD_NEW);
 +	ovs_dp_change(dp, info->attrs);
 +
 +	reply = ovs_dp_cmd_build_info(dp, info, OVS_DP_CMD_NEW);
  	if (IS_ERR(reply)) {
  		err = PTR_ERR(reply);
++<<<<<<< HEAD
 +		genl_set_err(sock_net(skb->sk), 0,
 +			     ovs_dp_datapath_multicast_group.id, err);
++=======
+ 		genl_set_err(&dp_datapath_genl_family, sock_net(skb->sk), 0,
+ 			     0, err);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  		err = 0;
  		goto unlock;
  	}
  
  	ovs_unlock();
++<<<<<<< HEAD
 +	ovs_notify(reply, info, &ovs_dp_datapath_multicast_group);
++=======
+ 	ovs_notify(&dp_datapath_genl_family, reply, info);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  
  	return 0;
  unlock:
@@@ -1629,7 -1595,7 +1665,11 @@@ static int ovs_vport_cmd_new(struct sk_
  		goto exit_unlock;
  	}
  
++<<<<<<< HEAD
 +	ovs_notify(reply, info, &ovs_dp_vport_multicast_group);
++=======
+ 	ovs_notify(&dp_vport_genl_family, reply, info);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  
  exit_unlock:
  	ovs_unlock();
@@@ -1676,7 -1642,7 +1716,11 @@@ static int ovs_vport_cmd_set(struct sk_
  	BUG_ON(err < 0);
  
  	ovs_unlock();
++<<<<<<< HEAD
 +	ovs_notify(reply, info, &ovs_dp_vport_multicast_group);
++=======
+ 	ovs_notify(&dp_vport_genl_family, reply, info);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return 0;
  
  exit_free:
@@@ -1713,7 -1679,7 +1757,11 @@@ static int ovs_vport_cmd_del(struct sk_
  	err = 0;
  	ovs_dp_detach_port(vport);
  
++<<<<<<< HEAD
 +	ovs_notify(reply, info, &ovs_dp_vport_multicast_group);
++=======
+ 	ovs_notify(&dp_vport_genl_family, reply, info);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  
  exit_unlock:
  	ovs_unlock();
@@@ -1813,9 -1779,9 +1861,9 @@@ static struct genl_ops dp_vport_genl_op
  
  struct genl_family_and_ops {
  	struct genl_family *family;
 -	const struct genl_ops *ops;
 +	struct genl_ops *ops;
  	int n_ops;
- 	struct genl_multicast_group *group;
+ 	const struct genl_multicast_group *group;
  };
  
  static const struct genl_family_and_ops dp_genl_families[] = {
@@@ -1851,8 -1817,11 +1899,16 @@@ static int dp_register_genl(void
  	for (i = 0; i < ARRAY_SIZE(dp_genl_families); i++) {
  		const struct genl_family_and_ops *f = &dp_genl_families[i];
  
++<<<<<<< HEAD
 +		err = genl_register_family_with_ops(f->family, f->ops,
 +						    f->n_ops);
++=======
+ 		f->family->ops = f->ops;
+ 		f->family->n_ops = f->n_ops;
+ 		f->family->mcgrps = f->group;
+ 		f->family->n_mcgrps = f->group ? 1 : 0;
+ 		err = genl_register_family(f->family);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  		if (err)
  			goto error;
  		n_registered++;
diff --cc net/openvswitch/dp_notify.c
index 9e3111a1038d,2c631fe76be1..000000000000
--- a/net/openvswitch/dp_notify.c
+++ b/net/openvswitch/dp_notify.c
@@@ -34,15 -34,14 +34,26 @@@ static void dp_detach_port_notify(struc
  					  OVS_VPORT_CMD_DEL);
  	ovs_dp_detach_port(vport);
  	if (IS_ERR(notify)) {
++<<<<<<< HEAD
 +		genl_set_err(ovs_dp_get_net(dp), 0,
 +			     ovs_dp_vport_multicast_group.id,
 +			     PTR_ERR(notify));
 +		return;
 +	}
 +
 +	genlmsg_multicast_netns(ovs_dp_get_net(dp), notify, 0,
 +				ovs_dp_vport_multicast_group.id,
 +				GFP_KERNEL);
++=======
+ 		genl_set_err(&dp_vport_genl_family, ovs_dp_get_net(dp), 0,
+ 			     0, PTR_ERR(notify));
+ 		return;
+ 	}
+ 
+ 	genlmsg_multicast_netns(&dp_vport_genl_family,
+ 				ovs_dp_get_net(dp), notify, 0,
+ 				0, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  void ovs_dp_notify_wq(struct work_struct *work)
diff --cc net/wimax/op-msg.c
index 0694d62e4dbc,c278b3356f75..000000000000
--- a/net/wimax/op-msg.c
+++ b/net/wimax/op-msg.c
@@@ -279,7 -279,7 +279,11 @@@ int wimax_msg_send(struct wimax_dev *wi
  
  	d_printf(1, dev, "CTX: wimax msg, %zu bytes\n", size);
  	d_dump(2, dev, msg, size);
++<<<<<<< HEAD
 +	genlmsg_multicast(skb, 0, wimax_gnl_mcg.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast(&wimax_gnl_family, skb, 0, 0, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	d_printf(1, dev, "CTX: genl multicast done\n");
  	return 0;
  }
diff --cc net/wimax/stack.c
index a6470ac39498,ef2191b969a7..000000000000
--- a/net/wimax/stack.c
+++ b/net/wimax/stack.c
@@@ -177,7 -178,7 +178,11 @@@ int wimax_gnl_re_state_change_send
  		goto out;
  	}
  	genlmsg_end(report_skb, header);
++<<<<<<< HEAD
 +	genlmsg_multicast(report_skb, 0, wimax_gnl_mcg.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast(&wimax_gnl_family, report_skb, 0, 0, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  out:
  	d_fnend(3, dev, "(wimax_dev %p report_skb %p) = %d\n",
  		wimax_dev, report_skb, result);
@@@ -575,37 -598,18 +580,49 @@@ int __init wimax_subsys_init(void
  
  	snprintf(wimax_gnl_family.name, sizeof(wimax_gnl_family.name),
  		 "WiMAX");
++<<<<<<< HEAD
 +	result = genl_register_family(&wimax_gnl_family);
++=======
+ 	result = genl_register_family_with_ops_groups(&wimax_gnl_family,
+ 						      wimax_gnl_ops,
+ 						      wimax_gnl_mcgrps);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	if (unlikely(result < 0)) {
  		printk(KERN_ERR "cannot register generic netlink family: %d\n",
  		       result);
  		goto error_register_family;
  	}
  
++<<<<<<< HEAD
 +	for (cnt = 0; cnt < ARRAY_SIZE(wimax_gnl_ops); cnt++) {
 +		result = genl_register_ops(&wimax_gnl_family,
 +					   wimax_gnl_ops[cnt]);
 +		d_printf(4, NULL, "registering generic netlink op code "
 +			 "%u: %d\n", wimax_gnl_ops[cnt]->cmd, result);
 +		if (unlikely(result < 0)) {
 +			printk(KERN_ERR "cannot register generic netlink op "
 +			       "code %u: %d\n",
 +			       wimax_gnl_ops[cnt]->cmd, result);
 +			goto error_register_ops;
 +		}
 +	}
 +
 +	result = genl_register_mc_group(&wimax_gnl_family, &wimax_gnl_mcg);
 +	if (result < 0)
 +		goto error_mc_group;
 +	d_fnend(4, NULL, "() = 0\n");
 +	return 0;
 +
 +error_mc_group:
 +error_register_ops:
 +	for (cnt--; cnt >= 0; cnt--)
 +		genl_unregister_ops(&wimax_gnl_family,
 +				    wimax_gnl_ops[cnt]);
++=======
+ 	d_fnend(4, NULL, "() = 0\n");
+ 	return 0;
+ 
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	genl_unregister_family(&wimax_gnl_family);
  error_register_family:
  	d_fnend(4, NULL, "() = %d\n", result);
diff --cc net/wireless/nl80211.c
index ac2cb32ea023,a1eb21073176..000000000000
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@@ -6596,8 -6883,8 +6611,13 @@@ void cfg80211_testmode_event(struct sk_
  
  	nla_nest_end(skb, data);
  	genlmsg_end(skb, hdr);
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), skb, 0,
 +				nl80211_testmode_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), skb, 0,
+ 				NL80211_MCGRP_TESTMODE, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  EXPORT_SYMBOL(cfg80211_testmode_event);
  #endif
@@@ -8995,24 -9555,32 +9015,9 @@@ static struct genl_ops nl80211_ops[] = 
  		.flags = GENL_ADMIN_PERM,
  		.internal_flags = NL80211_FLAG_NEED_WDEV_UP |
  				  NL80211_FLAG_NEED_RTNL,
 -	},
 -	{
 -		.cmd = NL80211_CMD_GET_COALESCE,
 -		.doit = nl80211_get_coalesce,
 -		.policy = nl80211_policy,
 -		.internal_flags = NL80211_FLAG_NEED_WIPHY |
 -				  NL80211_FLAG_NEED_RTNL,
 -	},
 -	{
 -		.cmd = NL80211_CMD_SET_COALESCE,
 -		.doit = nl80211_set_coalesce,
 -		.policy = nl80211_policy,
 -		.flags = GENL_ADMIN_PERM,
 -		.internal_flags = NL80211_FLAG_NEED_WIPHY |
 -				  NL80211_FLAG_NEED_RTNL,
 -	},
 -	{
 -		.cmd = NL80211_CMD_CHANNEL_SWITCH,
 -		.doit = nl80211_channel_switch,
 -		.policy = nl80211_policy,
 -		.flags = GENL_ADMIN_PERM,
 -		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
 -				  NL80211_FLAG_NEED_RTNL,
 -	},
 +	}
  };
  
- static struct genl_multicast_group nl80211_mlme_mcgrp = {
- 	.name = "mlme",
- };
- 
- /* multicast groups */
- static struct genl_multicast_group nl80211_config_mcgrp = {
- 	.name = "config",
- };
- static struct genl_multicast_group nl80211_scan_mcgrp = {
- 	.name = "scan",
- };
- static struct genl_multicast_group nl80211_regulatory_mcgrp = {
- 	.name = "regulatory",
- };
- 
  /* notification functions */
  
  void nl80211_notify_dev_rename(struct cfg80211_registered_device *rdev)
@@@ -9029,8 -9597,8 +9034,13 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_config_mcgrp.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_CONFIG, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  static int nl80211_add_scan_req(struct sk_buff *msg,
@@@ -9141,8 -9707,8 +9151,13 @@@ void nl80211_send_scan_start(struct cfg
  		return;
  	}
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_scan_mcgrp.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_SCAN, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  void nl80211_send_scan_done(struct cfg80211_registered_device *rdev,
@@@ -9160,8 -9726,8 +9175,13 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_scan_mcgrp.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_SCAN, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  void nl80211_send_scan_aborted(struct cfg80211_registered_device *rdev,
@@@ -9179,8 -9745,8 +9199,13 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_scan_mcgrp.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_SCAN, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  void nl80211_send_sched_scan_results(struct cfg80211_registered_device *rdev,
@@@ -9198,8 -9764,8 +9223,13 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_scan_mcgrp.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_SCAN, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  void nl80211_send_sched_scan(struct cfg80211_registered_device *rdev,
@@@ -9216,8 -9782,8 +9246,13 @@@
  		return;
  	}
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_scan_mcgrp.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_SCAN, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  
  /*
@@@ -9271,8 -9837,8 +9306,13 @@@ void nl80211_send_reg_change_event(stru
  	genlmsg_end(msg, hdr);
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	genlmsg_multicast_allns(msg, 0, nl80211_regulatory_mcgrp.id,
 +				GFP_ATOMIC);
++=======
+ 	genlmsg_multicast_allns(&nl80211_fam, msg, 0,
+ 				NL80211_MCGRP_REGULATORY, GFP_ATOMIC);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	rcu_read_unlock();
  
  	return;
@@@ -9307,8 -9873,8 +9347,13 @@@ static void nl80211_send_mlme_event(str
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -9399,8 -9961,8 +9444,13 @@@ static void nl80211_send_mlme_timeout(s
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -9455,8 -10017,8 +9505,13 @@@ void nl80211_send_connect_result(struc
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -9494,8 -10056,8 +9549,13 @@@ void nl80211_send_roamed(struct cfg8021
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -9532,8 -10094,8 +9592,13 @@@ void nl80211_send_disconnected(struct c
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -9566,8 -10128,8 +9631,13 @@@ void nl80211_send_ibss_bssid(struct cfg
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -9607,8 -10169,8 +9677,13 @@@ void cfg80211_notify_new_peer_candidate
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -9646,8 -10208,8 +9721,13 @@@ void nl80211_michael_mic_failure(struc
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -9699,8 -10261,8 +9779,13 @@@ void nl80211_send_beacon_hint_event(str
  	genlmsg_end(msg, hdr);
  
  	rcu_read_lock();
++<<<<<<< HEAD
 +	genlmsg_multicast_allns(msg, 0, nl80211_regulatory_mcgrp.id,
 +				GFP_ATOMIC);
++=======
+ 	genlmsg_multicast_allns(&nl80211_fam, msg, 0,
+ 				NL80211_MCGRP_REGULATORY, GFP_ATOMIC);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	rcu_read_unlock();
  
  	return;
@@@ -9745,8 -10307,8 +9830,13 @@@ static void nl80211_send_remain_on_chan
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -9800,8 -10362,8 +9890,13 @@@ void cfg80211_new_sta(struct net_devic
  		return;
  	}
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  EXPORT_SYMBOL(cfg80211_new_sta);
  
@@@ -9830,8 -10392,8 +9925,13 @@@ void cfg80211_del_sta(struct net_devic
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -9866,8 -10428,8 +9966,13 @@@ void cfg80211_conn_failed(struct net_de
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -10032,8 -10590,8 +10137,13 @@@ void cfg80211_mgmt_tx_status(struct wir
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -10081,8 -10639,8 +10191,13 @@@ void cfg80211_cqm_rssi_notify(struct ne
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -10126,8 -10684,8 +10241,13 @@@ static void nl80211_gtk_rekey_notify(st
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -10184,8 -10742,8 +10304,13 @@@ nl80211_pmksa_candidate_notify(struct c
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -10231,8 -10789,8 +10356,13 @@@ static void nl80211_ch_switch_notify(st
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -10306,8 -10866,8 +10436,13 @@@ void cfg80211_cqm_txe_notify(struct net
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -10353,13 -10913,10 +10488,18 @@@ nl80211_radar_notify(struct cfg80211_re
  	if (nl80211_send_chandef(msg, chandef))
  		goto nla_put_failure;
  
 -	genlmsg_end(msg, hdr);
 +	if (genlmsg_end(msg, hdr) < 0) {
 +		nlmsg_free(msg);
 +		return;
 +	}
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -10405,8 -10962,8 +10545,13 @@@ void cfg80211_cqm_pktloss_notify(struc
  
  	genlmsg_end(msg, hdr);
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -10444,14 -11000,10 +10589,19 @@@ void cfg80211_probe_status(struct net_d
  	    (acked && nla_put_flag(msg, NL80211_ATTR_ACK)))
  		goto nla_put_failure;
  
 -	genlmsg_end(msg, hdr);
 +	err = genlmsg_end(msg, hdr);
 +	if (err < 0) {
 +		nlmsg_free(msg);
 +		return;
 +	}
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -10600,12 -11152,10 +10750,17 @@@ void cfg80211_report_wowlan_wakeup(stru
  		nla_nest_end(msg, reasons);
  	}
  
 -	genlmsg_end(msg, hdr);
 +	err = genlmsg_end(msg, hdr);
 +	if (err < 0)
 +		goto free_msg;
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   free_msg:
@@@ -10645,14 -11194,10 +10800,19 @@@ void cfg80211_tdls_oper_request(struct 
  	     nla_put_u16(msg, NL80211_ATTR_REASON_CODE, reason_code)))
  		goto nla_put_failure;
  
 -	genlmsg_end(msg, hdr);
 +	err = genlmsg_end(msg, hdr);
 +	if (err < 0) {
 +		nlmsg_free(msg);
 +		return;
 +	}
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, gfp);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, gfp);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	return;
  
   nla_put_failure:
@@@ -10733,14 -11277,10 +10893,19 @@@ void cfg80211_ft_event(struct net_devic
  		nla_put(msg, NL80211_ATTR_IE_RIC, ft_event->ric_ies_len,
  			ft_event->ric_ies);
  
 -	genlmsg_end(msg, hdr);
 +	err = genlmsg_end(msg, hdr);
 +	if (err < 0) {
 +		nlmsg_free(msg);
 +		return;
 +	}
  
++<<<<<<< HEAD
 +	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
 +				nl80211_mlme_mcgrp.id, GFP_KERNEL);
++=======
+ 	genlmsg_multicast_netns(&nl80211_fam, wiphy_net(&rdev->wiphy), msg, 0,
+ 				NL80211_MCGRP_MLME, GFP_KERNEL);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  }
  EXPORT_SYMBOL(cfg80211_ft_event);
  
@@@ -10789,8 -11329,8 +10954,13 @@@ int nl80211_init(void
  {
  	int err;
  
++<<<<<<< HEAD
 +	err = genl_register_family_with_ops(&nl80211_fam,
 +		nl80211_ops, ARRAY_SIZE(nl80211_ops));
++=======
+ 	err = genl_register_family_with_ops_groups(&nl80211_fam, nl80211_ops,
+ 						   nl80211_mcgrps);
++>>>>>>> 2a94fe48f32c (genetlink: make multicast groups const, prevent abuse)
  	if (err)
  		return err;
  
* Unmerged path net/hsr/hsr_netlink.c
* Unmerged path drivers/acpi/event.c
* Unmerged path drivers/net/team/team.c
* Unmerged path drivers/thermal/thermal_core.c
* Unmerged path fs/quota/netlink.c
* Unmerged path include/linux/genl_magic_func.h
* Unmerged path include/net/genetlink.h
* Unmerged path net/core/drop_monitor.c
* Unmerged path net/hsr/hsr_netlink.c
diff --git a/net/ieee802154/ieee802154.h b/net/ieee802154/ieee802154.h
index 14d5dab4436f..cee4425b9956 100644
--- a/net/ieee802154/ieee802154.h
+++ b/net/ieee802154/ieee802154.h
@@ -54,8 +54,10 @@ int ieee802154_dump_phy(struct sk_buff *skb, struct netlink_callback *cb);
 int ieee802154_add_iface(struct sk_buff *skb, struct genl_info *info);
 int ieee802154_del_iface(struct sk_buff *skb, struct genl_info *info);
 
-extern struct genl_multicast_group ieee802154_coord_mcgrp;
-extern struct genl_multicast_group ieee802154_beacon_mcgrp;
+enum ieee802154_mcgrp_ids {
+	IEEE802154_COORD_MCGRP,
+	IEEE802154_BEACON_MCGRP,
+};
 
 int ieee802154_associate_req(struct sk_buff *skb, struct genl_info *info);
 int ieee802154_associate_resp(struct sk_buff *skb, struct genl_info *info);
* Unmerged path net/ieee802154/netlink.c
diff --git a/net/ieee802154/nl-mac.c b/net/ieee802154/nl-mac.c
index 28d493032132..ba5c1e002f37 100644
--- a/net/ieee802154/nl-mac.c
+++ b/net/ieee802154/nl-mac.c
@@ -39,14 +39,6 @@
 
 #include "ieee802154.h"
 
-struct genl_multicast_group ieee802154_coord_mcgrp = {
-	.name		= IEEE802154_MCAST_COORD_NAME,
-};
-
-struct genl_multicast_group ieee802154_beacon_mcgrp = {
-	.name		= IEEE802154_MCAST_BEACON_NAME,
-};
-
 int ieee802154_nl_assoc_indic(struct net_device *dev,
 		struct ieee802154_addr *addr, u8 cap)
 {
@@ -72,7 +64,7 @@ int ieee802154_nl_assoc_indic(struct net_device *dev,
 	    nla_put_u8(msg, IEEE802154_ATTR_CAPABILITY, cap))
 		goto nla_put_failure;
 
-	return ieee802154_nl_mcast(msg, ieee802154_coord_mcgrp.id);
+	return ieee802154_nl_mcast(msg, IEEE802154_COORD_MCGRP);
 
 nla_put_failure:
 	nlmsg_free(msg);
@@ -98,7 +90,7 @@ int ieee802154_nl_assoc_confirm(struct net_device *dev, u16 short_addr,
 	    nla_put_u16(msg, IEEE802154_ATTR_SHORT_ADDR, short_addr) ||
 	    nla_put_u8(msg, IEEE802154_ATTR_STATUS, status))
 		goto nla_put_failure;
-	return ieee802154_nl_mcast(msg, ieee802154_coord_mcgrp.id);
+	return ieee802154_nl_mcast(msg, IEEE802154_COORD_MCGRP);
 
 nla_put_failure:
 	nlmsg_free(msg);
@@ -133,7 +125,7 @@ int ieee802154_nl_disassoc_indic(struct net_device *dev,
 	}
 	if (nla_put_u8(msg, IEEE802154_ATTR_REASON, reason))
 		goto nla_put_failure;
-	return ieee802154_nl_mcast(msg, ieee802154_coord_mcgrp.id);
+	return ieee802154_nl_mcast(msg, IEEE802154_COORD_MCGRP);
 
 nla_put_failure:
 	nlmsg_free(msg);
@@ -157,7 +149,7 @@ int ieee802154_nl_disassoc_confirm(struct net_device *dev, u8 status)
 		    dev->dev_addr) ||
 	    nla_put_u8(msg, IEEE802154_ATTR_STATUS, status))
 		goto nla_put_failure;
-	return ieee802154_nl_mcast(msg, ieee802154_coord_mcgrp.id);
+	return ieee802154_nl_mcast(msg, IEEE802154_COORD_MCGRP);
 
 nla_put_failure:
 	nlmsg_free(msg);
@@ -183,7 +175,7 @@ int ieee802154_nl_beacon_indic(struct net_device *dev,
 	    nla_put_u16(msg, IEEE802154_ATTR_COORD_SHORT_ADDR, coord_addr) ||
 	    nla_put_u16(msg, IEEE802154_ATTR_COORD_PAN_ID, panid))
 		goto nla_put_failure;
-	return ieee802154_nl_mcast(msg, ieee802154_coord_mcgrp.id);
+	return ieee802154_nl_mcast(msg, IEEE802154_COORD_MCGRP);
 
 nla_put_failure:
 	nlmsg_free(msg);
@@ -214,7 +206,7 @@ int ieee802154_nl_scan_confirm(struct net_device *dev,
 	    (edl &&
 	     nla_put(msg, IEEE802154_ATTR_ED_LIST, 27, edl)))
 		goto nla_put_failure;
-	return ieee802154_nl_mcast(msg, ieee802154_coord_mcgrp.id);
+	return ieee802154_nl_mcast(msg, IEEE802154_COORD_MCGRP);
 
 nla_put_failure:
 	nlmsg_free(msg);
@@ -238,7 +230,7 @@ int ieee802154_nl_start_confirm(struct net_device *dev, u8 status)
 		    dev->dev_addr) ||
 	    nla_put_u8(msg, IEEE802154_ATTR_STATUS, status))
 		goto nla_put_failure;
-	return ieee802154_nl_mcast(msg, ieee802154_coord_mcgrp.id);
+	return ieee802154_nl_mcast(msg, IEEE802154_COORD_MCGRP);
 
 nla_put_failure:
 	nlmsg_free(msg);
* Unmerged path net/netlink/genetlink.c
* Unmerged path net/nfc/netlink.c
* Unmerged path net/openvswitch/datapath.c
* Unmerged path net/openvswitch/dp_notify.c
* Unmerged path net/wimax/op-msg.c
* Unmerged path net/wimax/stack.c
diff --git a/net/wimax/wimax-internal.h b/net/wimax/wimax-internal.h
index 1e743d214856..363ac76d35e2 100644
--- a/net/wimax/wimax-internal.h
+++ b/net/wimax/wimax-internal.h
@@ -85,7 +85,6 @@ extern int wimax_rfkill_add(struct wimax_dev *);
 extern void wimax_rfkill_rm(struct wimax_dev *);
 
 extern struct genl_family wimax_gnl_family;
-extern struct genl_multicast_group wimax_gnl_mcg;
 
 #endif /* #ifdef __KERNEL__ */
 #endif /* #ifndef __WIMAX_INTERNAL_H__ */
* Unmerged path net/wireless/nl80211.c
