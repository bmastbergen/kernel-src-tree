powerpc/powernv: Check for IRQHAPPENED before sleeping

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [powerpc] powernv: Check for IRQHAPPENED before sleeping (Don Zickus) [1127366]
Rebuild_FUZZ: 92.00%
commit-author Preeti U Murthy <preeti@linux.vnet.ibm.com>
commit c733cf83bbd2b0978456822cdac8c726085dcc14
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/c733cf83.failed

Commit 8d6f7c5a: "powerpc/powernv: Make it possible to skip the IRQHAPPENED
check in power7_nap()" added code that prevents cpus from checking for
pending interrupts just before entering sleep state, which is wrong. These
interrupts are delivered during the soft irq disabled state of the cpu.

A cpu cannot enter any idle state with pending interrupts because they will
never be serviced until the next time the cpu is woken up by some other
interrupt. Its only then that the pending interrupts are replayed. This can result
in device timeouts or warnings about this cpu being stuck.

This patch fixes ths issue by ensuring that cpus check for pending interrupts
just before entering any idle state as long as they are not in the path of split
core operations.

	Signed-off-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
	Acked-by: Michael Ellerman <mpe@ellerman.id.au>
	Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
(cherry picked from commit c733cf83bbd2b0978456822cdac8c726085dcc14)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/idle_power7.S
diff --cc arch/powerpc/kernel/idle_power7.S
index 3fdef0f0c67f,5cf3d367190d..000000000000
--- a/arch/powerpc/kernel/idle_power7.S
+++ b/arch/powerpc/kernel/idle_power7.S
@@@ -90,15 -107,59 +90,64 @@@ _GLOBAL(power7_enter_nap_mode
  	li	r4,KVM_HWTHREAD_IN_NAP
  	stb	r4,HSTATE_HWTHREAD_STATE(r13)
  #endif
 -	cmpwi	cr0,r3,1
 -	beq	2f
 -	IDLE_STATE_ENTER_SEQ(PPC_NAP)
 -	/* No return */
 -2:	IDLE_STATE_ENTER_SEQ(PPC_SLEEP)
 -	/* No return */
  
++<<<<<<< HEAD
 +	/* Magic NAP mode enter sequence */
 +	std	r0,0(r1)
 +	ptesync
 +	ld	r0,0(r1)
 +1:	cmp	cr0,r0,r0
 +	bne	1b
 +	PPC_NAP
 +	b	.
++=======
+ _GLOBAL(power7_idle)
+ 	/* Now check if user or arch enabled NAP mode */
+ 	LOAD_REG_ADDRBASE(r3,powersave_nap)
+ 	lwz	r4,ADDROFF(powersave_nap)(r3)
+ 	cmpwi	0,r4,0
+ 	beqlr
+ 	li	r3, 1
+ 	/* fall through */
+ 
+ _GLOBAL(power7_nap)
+ 	mr	r4,r3
+ 	li	r3,0
+ 	b	power7_powersave_common
+ 	/* No return */
+ 
+ _GLOBAL(power7_sleep)
+ 	li	r3,1
+ 	li	r4,1
+ 	b	power7_powersave_common
+ 	/* No return */
+ 
+ _GLOBAL(power7_wakeup_tb_loss)
+ 	ld	r2,PACATOC(r13);
+ 	ld	r1,PACAR1(r13)
+ 
+ 	/* Time base re-sync */
+ 	li	r0,OPAL_RESYNC_TIMEBASE
+ 	LOAD_REG_ADDR(r11,opal);
+ 	ld	r12,8(r11);
+ 	ld	r2,0(r11);
+ 	mtctr	r12
+ 	bctrl
+ 
+ 	/* TODO: Check r3 for failure */
+ 
+ 	REST_NVGPRS(r1)
+ 	REST_GPR(2, r1)
+ 	ld	r3,_CCR(r1)
+ 	ld	r4,_MSR(r1)
+ 	ld	r5,_NIP(r1)
+ 	addi	r1,r1,INT_FRAME_SIZE
+ 	mtcr	r3
+ 	mfspr	r3,SPRN_SRR1		/* Return SRR1 */
+ 	mtspr	SPRN_SRR1,r4
+ 	mtspr	SPRN_SRR0,r5
+ 	rfid
++>>>>>>> c733cf83bbd2 (powerpc/powernv: Check for IRQHAPPENED before sleeping)
  
  _GLOBAL(power7_wakeup_loss)
  	ld	r1,PACAR1(r13)
* Unmerged path arch/powerpc/kernel/idle_power7.S
