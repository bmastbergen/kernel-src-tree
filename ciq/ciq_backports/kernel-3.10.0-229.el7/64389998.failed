x86/uv/nmi, kgdb/kdb: Fix UV NMI handler when KDB not configured

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [x86] uv/nmi: Fix UV NMI handler when KDB not configured (George Beshers) [1138519]
Rebuild_FUZZ: 87.72%
commit-author Mike Travis <travis@sgi.com>
commit 64389998151214c71ba59ac893180744fd880052
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/64389998.failed

Fix UV call into kgdb to depend only on whether KGDB is defined
and not both KGDB and KDB.  This allows the power nmi command to
use the gdb remote connection if enabled.  Note new action of
'kgdb' needs to be set as well to indicate user wants to wait
for gdb to be connected.  If it's set to 'kdb' then an error
message is displayed if KDB is not configured.

Also note that if both KGDB and KDB are enabled, then the action
of 'kgdb' or 'kdb' has no affect on which is used.  See the KGDB
documentation for further information.

	Signed-off-by: Mike Travis <travis@sgi.com>
	Reviewed-by: Hedi Berriche <hedi@sgi.com>
	Cc: Russ Anderson <rja@sgi.com>
	Cc: Jason Wessel <jason.wessel@windriver.com>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Link: http://lkml.kernel.org/r/20140114162551.635540667@asylum.americas.sgi.com
	Signed-off-by: Ingo Molnar <mingo@kernel.org>
(cherry picked from commit 64389998151214c71ba59ac893180744fd880052)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/platform/uv/uv_nmi.c
diff --cc arch/x86/platform/uv/uv_nmi.c
index d61dfb77d1c5,be27da60dc8f..000000000000
--- a/arch/x86/platform/uv/uv_nmi.c
+++ b/arch/x86/platform/uv/uv_nmi.c
@@@ -537,18 -538,45 +538,50 @@@ static inline void uv_nmi_kdump(int cpu
  }
  #endif /* !CONFIG_KEXEC */
  
+ #ifdef CONFIG_KGDB
  #ifdef CONFIG_KGDB_KDB
- /* Call KDB from NMI handler */
- static void uv_call_kdb(int cpu, struct pt_regs *regs, int master)
+ static inline int uv_nmi_kdb_reason(void)
  {
- 	int ret;
+ 	return KDB_REASON_SYSTEM_NMI;
+ }
+ #else /* !CONFIG_KGDB_KDB */
+ static inline int uv_nmi_kdb_reason(void)
+ {
+ 	/* Insure user is expecting to attach gdb remote */
+ 	if (uv_nmi_action_is("kgdb"))
+ 		return 0;
  
+ 	pr_err("UV: NMI error: KDB is not enabled in this kernel\n");
+ 	return -1;
+ }
+ #endif /* CONFIG_KGDB_KDB */
+ 
+ /*
+  * Call KGDB/KDB from NMI handler
+  *
+  * Note that if both KGDB and KDB are configured, then the action of 'kgdb' or
+  * 'kdb' has no affect on which is used.  See the KGDB documention for further
+  * information.
+  */
+ static void uv_call_kgdb_kdb(int cpu, struct pt_regs *regs, int master)
+ {
  	if (master) {
+ 		int reason = uv_nmi_kdb_reason();
+ 		int ret;
+ 
+ 		if (reason < 0)
+ 			return;
+ 
  		/* call KGDB NMI handler as MASTER */
++<<<<<<< HEAD
 +		ret = kgdb_nmicallin(cpu, X86_TRAP_NMI, regs,
 +					&uv_nmi_slave_continue);
++=======
+ 		ret = kgdb_nmicallin(cpu, X86_TRAP_NMI, regs, reason,
+ 				&uv_nmi_slave_continue);
++>>>>>>> 643899981512 (x86/uv/nmi, kgdb/kdb: Fix UV NMI handler when KDB not configured)
  		if (ret) {
- 			pr_alert("KDB returned error, is kgdboc set?\n");
+ 			pr_alert("KGDB returned error, is kgdboc set?\n");
  			atomic_set(&uv_nmi_slave_continue, SLAVE_EXIT);
  		}
  	} else {
* Unmerged path arch/x86/platform/uv/uv_nmi.c
