ACPI / hotplug / PCI: Consolidate acpiphp_enumerate_slots()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Consolidate acpiphp_enumerate_slots() (Myron Stowe) [1114228]
Rebuild_FUZZ: 91.74%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 2552002a46cd6a7a262ea1718db33d1a1517008e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2552002a.failed

The acpiphp_enumerate_slots() function is now split into two parts,
acpiphp_enumerate_slots() proper and init_bridge_misc() which is
only called by the former.  If these functions are combined,
it is possible to make the code easier to follow and to clean up
the error handling (to prevent memory leaks on error from
happening in particular), so do that.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit 2552002a46cd6a7a262ea1718db33d1a1517008e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index 7d4cb0d082b8,68c3809ed7ce..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -363,46 -353,6 +363,49 @@@ static int detect_ejectable_slots(acpi_
  	return found;
  }
  
++<<<<<<< HEAD
 +/* initialize miscellaneous stuff for both root and PCI-to-PCI bridge */
 +static void init_bridge_misc(struct acpiphp_bridge *bridge)
 +{
 +	acpi_status status;
 +
 +	/* must be added to the list prior to calling register_slot */
 +	mutex_lock(&bridge_mutex);
 +	list_add(&bridge->list, &bridge_list);
 +	mutex_unlock(&bridge_mutex);
 +
 +	/* register all slot objects under this bridge */
 +	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, bridge->handle, (u32)1,
 +				     register_slot, NULL, bridge, NULL);
 +	if (ACPI_FAILURE(status)) {
 +		mutex_lock(&bridge_mutex);
 +		list_del(&bridge->list);
 +		mutex_unlock(&bridge_mutex);
 +		return;
 +	}
 +
 +	/* install notify handler for P2P bridges */
 +	if (!pci_is_root_bus(bridge->pci_bus)) {
 +		if ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func) {
 +			status = acpi_remove_notify_handler(bridge->func->handle,
 +						ACPI_SYSTEM_NOTIFY,
 +						handle_hotplug_event_func);
 +			if (ACPI_FAILURE(status))
 +				pr_err("failed to remove notify handler\n");
 +		}
 +		status = acpi_install_notify_handler(bridge->handle,
 +					     ACPI_SYSTEM_NOTIFY,
 +					     handle_hotplug_event_bridge,
 +					     bridge);
 +
 +		if (ACPI_FAILURE(status)) {
 +			pr_err("failed to register interrupt notify handler\n");
 +		}
 +	}
 +}
 +
++=======
++>>>>>>> 2552002a46cd (ACPI / hotplug / PCI: Consolidate acpiphp_enumerate_slots())
  
  /* find acpiphp_func from acpiphp_bridge */
  static struct acpiphp_func *acpiphp_bridge_handle_to_function(acpi_handle handle)
@@@ -1169,10 -1107,11 +1172,15 @@@ static void handle_hotplug_event_func(a
   * Create hotplug slots for the PCI bus.
   * It should always return 0 to avoid skipping following notifiers.
   */
 -void acpiphp_enumerate_slots(struct pci_bus *bus)
 +void acpiphp_enumerate_slots(struct pci_bus *bus, acpi_handle handle)
  {
++<<<<<<< HEAD
 +	acpi_handle dummy_handle;
++=======
++>>>>>>> 2552002a46cd (ACPI / hotplug / PCI: Consolidate acpiphp_enumerate_slots())
  	struct acpiphp_bridge *bridge;
+ 	acpi_handle handle;
+ 	acpi_status status;
  
  	if (acpiphp_disabled)
  		return;
@@@ -1199,15 -1139,51 +1207,60 @@@
  	 */
  	get_device(&bus->dev);
  
++<<<<<<< HEAD
 +	if (!pci_is_root_bus(bridge->pci_bus) &&
 +	    ACPI_SUCCESS(acpi_get_handle(bridge->handle,
 +					"_EJ0", &dummy_handle))) {
 +		pr_debug("found ejectable p2p bridge\n");
 +		bridge->flags |= BRIDGE_HAS_EJ0;
 +		bridge->func = acpiphp_bridge_handle_to_function(handle);
++=======
+ 	/* must be added to the list prior to calling register_slot */
+ 	mutex_lock(&bridge_mutex);
+ 	list_add(&bridge->list, &bridge_list);
+ 	mutex_unlock(&bridge_mutex);
+ 
+ 	/* register all slot objects under this bridge */
+ 	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, bridge->handle, 1,
+ 				     register_slot, NULL, bridge, NULL);
+ 	if (ACPI_FAILURE(status)) {
+ 		acpi_handle_err(bridge->handle, "failed to register slots\n");
+ 		goto err;
++>>>>>>> 2552002a46cd (ACPI / hotplug / PCI: Consolidate acpiphp_enumerate_slots())
+ 	}
+ 
+ 	if (pci_is_root_bus(bridge->pci_bus))
+ 		return;
+ 
+ 	/* install notify handler for P2P bridges */
+ 	status = acpi_install_notify_handler(bridge->handle, ACPI_SYSTEM_NOTIFY,
+ 					     handle_hotplug_event_bridge,
+ 					     bridge);
+ 	if (ACPI_FAILURE(status)) {
+ 		acpi_handle_err(bridge->handle,
+ 				"failed to register notify handler\n");
+ 		goto err;
  	}
  
- 	init_bridge_misc(bridge);
+ 	if (!acpi_has_method(bridge->handle, "_EJ0"))
+ 		return;
+ 
+ 	dbg("found ejectable p2p bridge\n");
+ 	bridge->flags |= BRIDGE_HAS_EJ0;
+ 	bridge->func = acpiphp_bridge_handle_to_function(bridge->handle);
+ 	if (bridge->func) {
+ 		status = acpi_remove_notify_handler(bridge->func->handle,
+ 						    ACPI_SYSTEM_NOTIFY,
+ 						    handle_hotplug_event_func);
+ 		if (ACPI_FAILURE(status))
+ 			acpi_handle_err(bridge->func->handle,
+ 					"failed to remove notify handler\n");
+ 	}
+ 	return;
+ 
+  err:
+ 	cleanup_bridge(bridge);
+ 	put_bridge(bridge);
  }
  
  /* Destroy hotplug slots associated with the PCI bus */
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
