net: Implmement RFC 6936 (zero RX csums for UDP/IPv6)

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] ipv6: Implmement RFC 6936 (zero RX csums for UDP/IPv6) (Florian Westphal) [1131999]
Rebuild_FUZZ: 93.46%
commit-author Tom Herbert <therbert@google.com>
commit 4068579e1e098fa81d48db9ba4432ab664c58561
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/4068579e.failed

RFC 6936 relaxes the requirement of RFC 2460 that UDP/IPv6 packets which
are received with a zero UDP checksum value must be dropped. RFC 6936
allows zero checksums to support tunnels over UDP.

When sk_no_check is set we allow on a socket we allow a zero IPv6
UDP checksum. This is for both sending zero checksum and accepting
a zero checksum on receive.

	Signed-off-by: Tom Herbert <therbert@google.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 4068579e1e098fa81d48db9ba4432ab664c58561)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/ip6_checksum.c
#	net/ipv6/udp.c
diff --cc net/ipv6/ip6_checksum.c
index ee7a97f510cb,da26224a5993..000000000000
--- a/net/ipv6/ip6_checksum.c
+++ b/net/ipv6/ip6_checksum.c
@@@ -75,25 -75,12 +75,35 @@@ int udp6_csum_init(struct sk_buff *skb
  			return err;
  	}
  
++<<<<<<< HEAD
 +	if (uh->check == 0) {
 +		/* RFC 2460 section 8.1 says that we SHOULD log
 +		   this error. Well, it is reasonable.
 +		 */
 +		LIMIT_NETDEBUG(KERN_INFO "IPv6: udp checksum is 0 for [%pI6c]:%u->[%pI6c]:%u\n",
 +			       &ipv6_hdr(skb)->saddr, ntohs(uh->source),
 +			       &ipv6_hdr(skb)->daddr, ntohs(uh->dest));
 +		return 1;
 +	}
 +	if (skb->ip_summed == CHECKSUM_COMPLETE &&
 +	    !csum_ipv6_magic(&ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr,
 +			     skb->len, proto, skb->csum))
 +		skb->ip_summed = CHECKSUM_UNNECESSARY;
 +
 +	if (!skb_csum_unnecessary(skb))
 +		skb->csum = ~csum_unfold(csum_ipv6_magic(&ipv6_hdr(skb)->saddr,
 +							 &ipv6_hdr(skb)->daddr,
 +							 skb->len, proto, 0));
 +
 +	return 0;
++=======
+ 	/* To support RFC 6936 (allow zero checksum in UDP/IPV6 for tunnels)
+ 	 * we accept a checksum of zero here. When we find the socket
+ 	 * for the UDP packet we'll check if that socket allows zero checksum
+ 	 * for IPv6 (set by socket option).
+ 	 */
+ 	return skb_checksum_init_zero_check(skb, proto, uh->check,
+ 					   ip6_compute_pseudo);
++>>>>>>> 4068579e1e09 (net: Implmement RFC 6936 (zero RX csums for UDP/IPv6))
  }
  EXPORT_SYMBOL(udp6_csum_init);
diff --cc net/ipv6/udp.c
index 83b0a9963a30,4fcd9bca950e..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -835,7 -883,11 +851,15 @@@ int __udp6_lib_rcv(struct sk_buff *skb
  	if (sk != NULL) {
  		int ret;
  
++<<<<<<< HEAD
 +		sk_mark_napi_id(sk, skb);
++=======
+ 		if (!uh->check && !sk->sk_no_check) {
+ 			udp6_csum_zero_error(skb);
+ 			goto csum_error;
+ 		}
+ 
++>>>>>>> 4068579e1e09 (net: Implmement RFC 6936 (zero RX csums for UDP/IPv6))
  		ret = udpv6_queue_rcv_skb(sk, skb);
  		sock_put(sk);
  
* Unmerged path net/ipv6/ip6_checksum.c
* Unmerged path net/ipv6/udp.c
