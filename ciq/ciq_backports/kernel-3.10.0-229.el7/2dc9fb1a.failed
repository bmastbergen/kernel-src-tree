perf tools: Factor out sample__resolve_callchain()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [tools] perf: Factor out sample__resolve_callchain() (Jiri Olsa) [1133083]
Rebuild_FUZZ: 93.62%
commit-author Namhyung Kim <namhyung@kernel.org>
commit 2dc9fb1a7bf013ce24dd34bc25283b60b966f015
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/2dc9fb1a.failed

The report__resolve_callchain() can be shared with perf top code as it
doesn't really depend on the perf report code.  Factor it out as
sample__resolve_callchain().  The same goes to the hist_entry__append_
callchain() too.

	Signed-off-by: Namhyung Kim <namhyung@kernel.org>
	Acked-by: Jiri Olsa <jolsa@redhat.com>
	Cc: Andi Kleen <andi@firstfloor.org>
	Cc: Arun Sharma <asharma@fb.com>
	Cc: Frederic Weisbecker <fweisbec@gmail.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Jiri Olsa <jolsa@redhat.com>
	Cc: Namhyung Kim <namhyung.kim@lge.com>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
	Cc: Rodrigo Campos <rodrigo@sdfg.com.ar>
Link: http://lkml.kernel.org/r/1389677157-30513-3-git-send-email-namhyung@kernel.org
	Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
(cherry picked from commit 2dc9fb1a7bf013ce24dd34bc25283b60b966f015)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/perf/builtin-report.c
#	tools/perf/builtin-top.c
diff --cc tools/perf/builtin-report.c
index e3b253d3e27e,3c53ec268fbc..000000000000
--- a/tools/perf/builtin-report.c
+++ b/tools/perf/builtin-report.c
@@@ -74,27 -75,9 +74,30 @@@ static int report__config(const char *v
  	return perf_default_config(var, value, cb);
  }
  
++<<<<<<< HEAD
 +static int report__resolve_callchain(struct report *rep, struct symbol **parent,
 +				     struct perf_evsel *evsel, struct addr_location *al,
 +				     struct perf_sample *sample, struct machine *machine)
 +{
 +	if ((sort__has_parent || symbol_conf.use_callchain) && sample->callchain) {
 +		return machine__resolve_callchain(machine, evsel, al->thread, sample,
 +						  parent, al, rep->max_stack);
 +	}
 +	return 0;
 +}
 +
 +static int hist_entry__append_callchain(struct hist_entry *he, struct perf_sample *sample)
 +{
 +	if (!symbol_conf.use_callchain)
 +		return 0;
 +	return callchain_append(he->callchain, &callchain_cursor, sample->period);
 +}
 +
++=======
++>>>>>>> 2dc9fb1a7bf0 (perf tools: Factor out sample__resolve_callchain())
  static int report__add_mem_hist_entry(struct perf_tool *tool, struct addr_location *al,
  				      struct perf_sample *sample, struct perf_evsel *evsel,
 -				      union perf_event *event)
 +				      struct machine *machine, union perf_event *event)
  {
  	struct report *rep = container_of(tool, struct report, tool);
  	struct symbol *parent = NULL;
@@@ -102,7 -85,7 +105,11 @@@
  	struct hist_entry *he;
  	struct mem_info *mi, *mx;
  	uint64_t cost;
++<<<<<<< HEAD
 +	int err = report__resolve_callchain(rep, &parent, evsel, al, sample, machine);
++=======
+ 	int err = sample__resolve_callchain(sample, &parent, evsel, al, rep->max_stack);
++>>>>>>> 2dc9fb1a7bf0 (perf tools: Factor out sample__resolve_callchain())
  
  	if (err)
  		return err;
@@@ -155,7 -137,7 +162,11 @@@ static int report__add_branch_hist_entr
  	unsigned i;
  	struct hist_entry *he;
  	struct branch_info *bi, *bx;
++<<<<<<< HEAD
 +	int err = report__resolve_callchain(rep, &parent, evsel, al, sample, machine);
++=======
+ 	int err = sample__resolve_callchain(sample, &parent, evsel, al, rep->max_stack);
++>>>>>>> 2dc9fb1a7bf0 (perf tools: Factor out sample__resolve_callchain())
  
  	if (err)
  		return err;
@@@ -209,7 -190,7 +220,11 @@@ static int report__add_hist_entry(struc
  	struct report *rep = container_of(tool, struct report, tool);
  	struct symbol *parent = NULL;
  	struct hist_entry *he;
++<<<<<<< HEAD
 +	int err = report__resolve_callchain(rep, &parent, evsel, al, sample, machine);
++=======
+ 	int err = sample__resolve_callchain(sample, &parent, evsel, al, rep->max_stack);
++>>>>>>> 2dc9fb1a7bf0 (perf tools: Factor out sample__resolve_callchain())
  
  	if (err)
  		return err;
diff --cc tools/perf/builtin-top.c
index c1b5d3b13b56,76cd510d34d0..000000000000
--- a/tools/perf/builtin-top.c
+++ b/tools/perf/builtin-top.c
@@@ -743,15 -743,10 +743,22 @@@ static void perf_event__process_sample(
  	if (al.sym == NULL || !al.sym->ignore) {
  		struct hist_entry *he;
  
++<<<<<<< HEAD
 +		if ((sort__has_parent || symbol_conf.use_callchain) &&
 +		    sample->callchain) {
 +			err = machine__resolve_callchain(machine, evsel,
 +							 al.thread, sample,
 +							 &parent, &al,
 +							 PERF_MAX_STACK_DEPTH);
 +			if (err)
 +				return;
 +		}
++=======
+ 		err = sample__resolve_callchain(sample, &parent, evsel, &al,
+ 						top->max_stack);
+ 		if (err)
+ 			return;
++>>>>>>> 2dc9fb1a7bf0 (perf tools: Factor out sample__resolve_callchain())
  
  		he = perf_evsel__add_hist_entry(evsel, &al, sample);
  		if (he == NULL) {
* Unmerged path tools/perf/builtin-report.c
* Unmerged path tools/perf/builtin-top.c
diff --git a/tools/perf/util/callchain.c b/tools/perf/util/callchain.c
index e3970e3eaacf..9eb4f57f8663 100644
--- a/tools/perf/util/callchain.c
+++ b/tools/perf/util/callchain.c
@@ -17,6 +17,8 @@
 
 #include "hist.h"
 #include "util.h"
+#include "sort.h"
+#include "machine.h"
 #include "callchain.h"
 
 __thread struct callchain_cursor callchain_cursor;
@@ -531,3 +533,24 @@ int callchain_cursor_append(struct callchain_cursor *cursor,
 
 	return 0;
 }
+
+int sample__resolve_callchain(struct perf_sample *sample, struct symbol **parent,
+			      struct perf_evsel *evsel, struct addr_location *al,
+			      int max_stack)
+{
+	if (sample->callchain == NULL)
+		return 0;
+
+	if (symbol_conf.use_callchain || sort__has_parent) {
+		return machine__resolve_callchain(al->machine, evsel, al->thread,
+						  sample, parent, al, max_stack);
+	}
+	return 0;
+}
+
+int hist_entry__append_callchain(struct hist_entry *he, struct perf_sample *sample)
+{
+	if (!symbol_conf.use_callchain)
+		return 0;
+	return callchain_append(he->callchain, &callchain_cursor, sample->period);
+}
diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h
index 08b25af9eea1..8ad97e9b119f 100644
--- a/tools/perf/util/callchain.h
+++ b/tools/perf/util/callchain.h
@@ -145,10 +145,16 @@ static inline void callchain_cursor_advance(struct callchain_cursor *cursor)
 }
 
 struct option;
+struct hist_entry;
 
 int record_parse_callchain(const char *arg, struct record_opts *opts);
 int record_parse_callchain_opt(const struct option *opt, const char *arg, int unset);
 int record_callchain_opt(const struct option *opt, const char *arg, int unset);
 
+int sample__resolve_callchain(struct perf_sample *sample, struct symbol **parent,
+			      struct perf_evsel *evsel, struct addr_location *al,
+			      int max_stack);
+int hist_entry__append_callchain(struct hist_entry *he, struct perf_sample *sample);
+
 extern const char record_callchain_help[];
 #endif	/* __PERF_CALLCHAIN_H */
