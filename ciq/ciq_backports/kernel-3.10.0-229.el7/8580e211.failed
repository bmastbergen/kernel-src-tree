bridge: Prepare for 802.1ad vlan filtering support

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
commit 8580e2117c06ac0c97a561219eaab6dab968ea3f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/8580e211.failed

This enables a bridge to have vlan protocol informantion and allows vlan
tag manipulation (retrieve, insert and remove tags) according to the vlan
protocol.

	Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8580e2117c06ac0c97a561219eaab6dab968ea3f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_private.h
#	net/bridge/br_vlan.c
diff --cc net/bridge/br_private.h
index 10b5654d52ef,13e570e8b0fc..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -296,8 -291,10 +296,9 @@@ struct net_bridg
  	struct timer_list		topology_change_timer;
  	struct timer_list		gc_timer;
  	struct kobject			*ifobj;
 -	u32				auto_cnt;
  #ifdef CONFIG_BRIDGE_VLAN_FILTERING
  	u8				vlan_enabled;
+ 	__be16				vlan_proto;
  	struct net_port_vlans __rcu	*vlan_info;
  #endif
  };
@@@ -611,22 -582,24 +612,43 @@@ static inline void br_mdb_uninit(void
  
  /* br_vlan.c */
  #ifdef CONFIG_BRIDGE_VLAN_FILTERING
++<<<<<<< HEAD
 +extern bool br_allowed_ingress(struct net_bridge *br, struct net_port_vlans *v,
 +			       struct sk_buff *skb, u16 *vid);
 +extern bool br_allowed_egress(struct net_bridge *br,
 +			      const struct net_port_vlans *v,
 +			      const struct sk_buff *skb);
 +extern struct sk_buff *br_handle_vlan(struct net_bridge *br,
 +				      const struct net_port_vlans *v,
 +				      struct sk_buff *skb);
 +extern int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
 +extern int br_vlan_delete(struct net_bridge *br, u16 vid);
 +extern void br_vlan_flush(struct net_bridge *br);
 +extern int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 +extern int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
 +extern int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 +extern void nbp_vlan_flush(struct net_bridge_port *port);
 +extern bool nbp_vlan_find(struct net_bridge_port *port, u16 vid);
++=======
+ bool br_allowed_ingress(struct net_bridge *br, struct net_port_vlans *v,
+ 			struct sk_buff *skb, u16 *vid);
+ bool br_allowed_egress(struct net_bridge *br, const struct net_port_vlans *v,
+ 		       const struct sk_buff *skb);
+ bool br_should_learn(struct net_bridge_port *p, struct sk_buff *skb, u16 *vid);
+ struct sk_buff *br_handle_vlan(struct net_bridge *br,
+ 			       const struct net_port_vlans *v,
+ 			       struct sk_buff *skb);
+ int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
+ int br_vlan_delete(struct net_bridge *br, u16 vid);
+ void br_vlan_flush(struct net_bridge *br);
+ bool br_vlan_find(struct net_bridge *br, u16 vid);
+ int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
+ void br_vlan_init(struct net_bridge *br);
+ int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
+ int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
+ void nbp_vlan_flush(struct net_bridge_port *port);
+ bool nbp_vlan_find(struct net_bridge_port *port, u16 vid);
++>>>>>>> 8580e2117c06 (bridge: Prepare for 802.1ad vlan filtering support)
  
  static inline struct net_port_vlans *br_get_vlan_info(
  						const struct net_bridge *br)
@@@ -703,6 -686,15 +725,18 @@@ static inline void br_vlan_flush(struc
  {
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool br_vlan_find(struct net_bridge *br, u16 vid)
+ {
+ 	return false;
+ }
+ 
+ static inline void br_vlan_init(struct net_bridge *br)
+ {
+ }
+ 
++>>>>>>> 8580e2117c06 (bridge: Prepare for 802.1ad vlan filtering support)
  static inline int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags)
  {
  	return -EOPNOTSUPP;
diff --cc net/bridge/br_vlan.c
index c5c15c7d9539,63bd98137a42..000000000000
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@@ -227,6 -266,36 +252,39 @@@ bool br_allowed_egress(struct net_bridg
  	return false;
  }
  
++<<<<<<< HEAD
++=======
+ /* Called under RCU */
+ bool br_should_learn(struct net_bridge_port *p, struct sk_buff *skb, u16 *vid)
+ {
+ 	struct net_bridge *br = p->br;
+ 	struct net_port_vlans *v;
+ 
+ 	if (!br->vlan_enabled)
+ 		return true;
+ 
+ 	v = rcu_dereference(p->vlan_info);
+ 	if (!v)
+ 		return false;
+ 
+ 	if (!br_vlan_get_tag(skb, vid) && skb->vlan_proto != br->vlan_proto)
+ 		*vid = 0;
+ 
+ 	if (!*vid) {
+ 		*vid = br_get_pvid(v);
+ 		if (*vid == VLAN_N_VID)
+ 			return false;
+ 
+ 		return true;
+ 	}
+ 
+ 	if (test_bit(*vid, v->vlan_bitmap))
+ 		return true;
+ 
+ 	return false;
+ }
+ 
++>>>>>>> 8580e2117c06 (bridge: Prepare for 802.1ad vlan filtering support)
  /* Must be protected by RTNL.
   * Must be called with vid in range from 1 to 4094 inclusive.
   */
diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c
index 38068a9ebc44..34d4c40092eb 100644
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@ -377,4 +377,5 @@ void br_dev_setup(struct net_device *dev)
 	br_netfilter_rtable_init(br);
 	br_stp_timer_init(br);
 	br_multicast_init(br);
+	br_vlan_init(br);
 }
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_vlan.c
