ACPI / hotplug / PCI: Store parent in functions and bus in slots

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug/pci: Store parent in functions and bus in slots (Myron Stowe) [1114228]
Rebuild_FUZZ: 92.44%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit bda46dbb6626c923a800b4033c86fefa613cd64c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/bda46dbb.failed

To avoid chasing more pointers than necessary in some situations,
move the bridge pointer from struct acpiphp_slot to struct
acpiphp_func (and call it 'parent') and add a bus pointer to
struct acpiphp_slot.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Tested-by: Mika Westerberg <mika.westerberg@linux.intel.com>
(cherry picked from commit bda46dbb6626c923a800b4033c86fefa613cd64c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/hotplug/acpiphp_glue.c
diff --cc drivers/pci/hotplug/acpiphp_glue.c
index b5069ad47c47,7ac315afa430..000000000000
--- a/drivers/pci/hotplug/acpiphp_glue.c
+++ b/drivers/pci/hotplug/acpiphp_glue.c
@@@ -104,9 -161,15 +104,21 @@@ static void free_bridge(struct kref *kr
  		kfree(slot);
  	}
  
++<<<<<<< HEAD
 +	/* Release reference acquired by acpiphp_bridge_handle_to_function() */
 +	if ((bridge->flags & BRIDGE_HAS_EJ0) && bridge->func)
 +		put_bridge(bridge->func->slot->bridge);
++=======
+ 	context = bridge->context;
+ 	/* Root bridges will not have hotplug context. */
+ 	if (context) {
+ 		/* Release the reference taken by acpiphp_enumerate_slots(). */
+ 		put_bridge(context->func.parent);
+ 		context->bridge = NULL;
+ 		acpiphp_put_context(context);
+ 	}
+ 
++>>>>>>> bda46dbb6626 (ACPI / hotplug / PCI: Store parent in functions and bus in slots)
  	put_device(&bridge->pci_bus->dev);
  	pci_dev_put(bridge->pci_dev);
  	kfree(bridge);
@@@ -119,11 -184,10 +131,16 @@@
   * TBD - figure out a way to only call fixups for
   * systems that require them.
   */
 -static void post_dock_fixups(acpi_handle not_used, u32 event, void *data)
 +static int post_dock_fixups(struct notifier_block *nb, unsigned long val,
 +	void *v)
  {
++<<<<<<< HEAD
 +	struct acpiphp_func *func = container_of(nb, struct acpiphp_func, nb);
 +	struct pci_bus *bus = func->slot->bridge->pci_bus;
++=======
+ 	struct acpiphp_context *context = data;
+ 	struct pci_bus *bus = context->func.slot->bus;
++>>>>>>> bda46dbb6626 (ACPI / hotplug / PCI: Store parent in functions and bus in slots)
  	u32 buses;
  
  	if (!bus->self)
@@@ -182,16 -246,16 +199,24 @@@ static bool device_is_managed_by_native
  
  static void acpiphp_dock_init(void *data)
  {
 -	struct acpiphp_context *context = data;
 +	struct acpiphp_func *func = data;
  
++<<<<<<< HEAD
 +	get_bridge(func->slot->bridge);
++=======
+ 	get_bridge(context->func.parent);
++>>>>>>> bda46dbb6626 (ACPI / hotplug / PCI: Store parent in functions and bus in slots)
  }
  
  static void acpiphp_dock_release(void *data)
  {
 -	struct acpiphp_context *context = data;
 +	struct acpiphp_func *func = data;
  
++<<<<<<< HEAD
 +	put_bridge(func->slot->bridge);
++=======
+ 	put_bridge(context->func.parent);
++>>>>>>> bda46dbb6626 (ACPI / hotplug / PCI: Store parent in functions and bus in slots)
  }
  
  /* callback routine to register each ACPI PCI slot object */
@@@ -221,82 -285,80 +246,139 @@@ register_slot(acpi_handle handle, u32 l
  	device = (adr >> 16) & 0xffff;
  	function = adr & 0xffff;
  
++<<<<<<< HEAD
 +	pdev = bridge->pci_dev;
 +	if (pdev && device_is_managed_by_native_pciehp(pdev))
 +		return AE_OK;
++=======
+ 	mutex_lock(&acpiphp_context_lock);
+ 	context = acpiphp_init_context(handle);
+ 	if (!context) {
+ 		mutex_unlock(&acpiphp_context_lock);
+ 		acpi_handle_err(handle, "No hotplug context\n");
+ 		return AE_NOT_EXIST;
+ 	}
+ 	newfunc = &context->func;
+ 	newfunc->function = function;
+ 	newfunc->parent = bridge;
+ 	mutex_unlock(&acpiphp_context_lock);
++>>>>>>> bda46dbb6626 (ACPI / hotplug / PCI: Store parent in functions and bus in slots)
  
 -	if (acpi_has_method(handle, "_EJ0"))
 +	newfunc = kzalloc(sizeof(struct acpiphp_func), GFP_KERNEL);
 +	if (!newfunc)
 +		return AE_NO_MEMORY;
 +
 +	newfunc->handle = handle;
 +	newfunc->function = function;
 +
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_EJ0", &tmp)))
  		newfunc->flags = FUNC_HAS_EJ0;
  
 -	if (acpi_has_method(handle, "_STA"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_STA", &tmp)))
  		newfunc->flags |= FUNC_HAS_STA;
  
 -	if (acpi_has_method(handle, "_PS0"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS0", &tmp)))
  		newfunc->flags |= FUNC_HAS_PS0;
  
 -	if (acpi_has_method(handle, "_PS3"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_PS3", &tmp)))
  		newfunc->flags |= FUNC_HAS_PS3;
  
 -	if (acpi_has_method(handle, "_DCK"))
 +	if (ACPI_SUCCESS(acpi_get_handle(handle, "_DCK", &tmp)))
  		newfunc->flags |= FUNC_HAS_DCK;
  
 +	status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
 +	if (ACPI_FAILURE(status)) {
 +		/*
 +		 * use the count of the number of slots we've found
 +		 * for the number of the slot
 +		 */
 +		sun = bridge->nr_slots+1;
 +	}
 +
  	/* search for objects that share the same slot */
  	list_for_each_entry(slot, &bridge->slots, node)
++<<<<<<< HEAD
 +		if (slot->device == device) {
 +			if (slot->sun != sun)
 +				pr_warn("sibling found, but _SUN doesn't match!\n");
 +			found = 1;
 +			break;
 +		}
 +
 +	if (!found) {
 +		slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
 +		if (!slot) {
 +			kfree(newfunc);
 +			return AE_NO_MEMORY;
 +		}
 +
 +		slot->bridge = bridge;
 +		slot->device = device;
 +		slot->sun = sun;
 +		INIT_LIST_HEAD(&slot->funcs);
 +		mutex_init(&slot->crit_sect);
 +
 +		mutex_lock(&bridge_mutex);
 +		list_add_tail(&slot->node, &bridge->slots);
 +		mutex_unlock(&bridge_mutex);
 +		bridge->nr_slots++;
 +
 +		pr_debug("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",
 +		    slot->sun, pci_domain_nr(pbus), pbus->number, device);
 +		retval = acpiphp_register_hotplug_slot(slot);
 +		if (retval) {
 +			if (retval == -EBUSY)
 +				pr_warn("Slot %llu already registered by another "
 +					"hotplug driver\n", slot->sun);
 +			else
 +				pr_warn("acpiphp_register_hotplug_slot failed "
 +					"(err code = 0x%x)\n", retval);
 +			goto err_exit;
++=======
+ 		if (slot->device == device)
+ 			goto slot_found;
+ 
+ 	slot = kzalloc(sizeof(struct acpiphp_slot), GFP_KERNEL);
+ 	if (!slot) {
+ 		status = AE_NO_MEMORY;
+ 		goto err;
+ 	}
+ 
+ 	slot->bus = bridge->pci_bus;
+ 	slot->device = device;
+ 	INIT_LIST_HEAD(&slot->funcs);
+ 	mutex_init(&slot->crit_sect);
+ 
+ 	mutex_lock(&bridge_mutex);
+ 	list_add_tail(&slot->node, &bridge->slots);
+ 	mutex_unlock(&bridge_mutex);
+ 
+ 	/* Register slots for ejectable funtions only. */
+ 	if (acpi_pci_check_ejectable(pbus, handle)  || is_dock_device(handle)) {
+ 		unsigned long long sun;
+ 		int retval;
+ 
+ 		bridge->nr_slots++;
+ 		status = acpi_evaluate_integer(handle, "_SUN", NULL, &sun);
+ 		if (ACPI_FAILURE(status))
+ 			sun = bridge->nr_slots;
+ 
+ 		dbg("found ACPI PCI Hotplug slot %llu at PCI %04x:%02x:%02x\n",
+ 		    sun, pci_domain_nr(pbus), pbus->number, device);
+ 
+ 		retval = acpiphp_register_hotplug_slot(slot, sun);
+ 		if (retval) {
+ 			bridge->nr_slots--;
+ 			if (retval == -EBUSY)
+ 				warn("Slot %llu already registered by another "
+ 					"hotplug driver\n", sun);
+ 			else
+ 				warn("acpiphp_register_hotplug_slot failed "
+ 					"(err code = 0x%x)\n", retval);
++>>>>>>> bda46dbb6626 (ACPI / hotplug / PCI: Store parent in functions and bus in slots)
  		}
 -		/* Even if the slot registration fails, we can still use it. */
  	}
  
 - slot_found:
  	newfunc->slot = slot;
  	mutex_lock(&bridge_mutex);
  	list_add_tail(&newfunc->sibling, &slot->funcs);
@@@ -824,7 -780,9 +906,13 @@@ static unsigned int get_slot_status(str
  			if (ACPI_SUCCESS(status) && sta)
  				break;
  		} else {
++<<<<<<< HEAD
 +			pci_bus_read_config_dword(slot->bridge->pci_bus,
++=======
+ 			u32 dvid;
+ 
+ 			pci_bus_read_config_dword(slot->bus,
++>>>>>>> bda46dbb6626 (ACPI / hotplug / PCI: Store parent in functions and bus in slots)
  						  PCI_DEVFN(slot->device,
  							    func->function),
  						  PCI_VENDOR_ID, &dvid);
@@@ -1016,8 -967,12 +1104,17 @@@ static void _handle_hotplug_event_bridg
  
  	case ACPI_NOTIFY_DEVICE_CHECK:
  		/* device check */
++<<<<<<< HEAD
 +		pr_debug("%s: Device check notify on %s\n", __func__, objname);
 +		acpiphp_check_bridge(bridge);
++=======
+ 		dbg("%s: Device check notify on %s\n", __func__, objname);
+ 		if (bridge)
+ 			acpiphp_check_bridge(bridge);
+ 		else
+ 			acpiphp_check_bridge(func->parent);
+ 
++>>>>>>> bda46dbb6626 (ACPI / hotplug / PCI: Store parent in functions and bus in slots)
  		break;
  
  	case ACPI_NOTIFY_DEVICE_WAKE:
@@@ -1056,90 -1009,24 +1153,105 @@@
  		break;
  	}
  
 -	if (bridge)
 -		put_bridge(bridge);
 +	acpi_scan_lock_release();
++<<<<<<< HEAD
 +	kfree(hp_work); /* allocated in handle_hotplug_event_bridge */
 +	put_bridge(bridge);
++=======
++	kfree(hp_work); /* allocated in handle_hotplug_event() */
++	put_bridge(context->func.parent);
++>>>>>>> bda46dbb6626 (ACPI / hotplug / PCI: Store parent in functions and bus in slots)
  }
  
 -static void hotplug_event_work(struct work_struct *work)
 +/**
 + * handle_hotplug_event_bridge - handle ACPI event on bridges
 + * @handle: Notify()'ed acpi_handle
 + * @type: Notify code
 + * @context: pointer to acpiphp_bridge structure
 + *
 + * Handles ACPI event notification on {host,p2p} bridges.
 + */
 +static void handle_hotplug_event_bridge(acpi_handle handle, u32 type,
 +					void *context)
 +{
 +	struct acpiphp_bridge *bridge = context;
 +
++<<<<<<< HEAD
++=======
++	mutex_lock(&acpiphp_context_lock);
++	context = acpiphp_get_context(handle);
++	if (context) {
++		get_bridge(context->func.parent);
++		acpiphp_put_context(context);
++	}
++	mutex_unlock(&acpiphp_context_lock);
++>>>>>>> bda46dbb6626 (ACPI / hotplug / PCI: Store parent in functions and bus in slots)
 +	/*
 +	 * Currently the code adds all hotplug events to the kacpid_wq
 +	 * queue when it should add hotplug events to the kacpi_hotplug_wq.
 +	 * The proper way to fix this is to reorganize the code so that
 +	 * drivers (dock, etc.) do not call acpi_os_execute(), etc.
 +	 * For now just re-add this work to the kacpi_hotplug_wq so we
 +	 * don't deadlock on hotplug actions.
 +	 */
 +	get_bridge(bridge);
 +	alloc_acpi_hp_work(handle, type, context, _handle_hotplug_event_bridge);
 +}
 +
 +static void hotplug_event_func(acpi_handle handle, u32 type, void *context)
 +{
 +	struct acpiphp_func *func = context;
 +	char objname[64];
 +	struct acpi_buffer buffer = { .length = sizeof(objname),
 +				      .pointer = objname };
 +
 +	acpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);
 +
 +	switch (type) {
 +	case ACPI_NOTIFY_BUS_CHECK:
 +		/* bus re-enumerate */
 +		pr_debug("%s: Bus check notify on %s\n", __func__, objname);
 +		acpiphp_enable_slot(func->slot);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_CHECK:
 +		/* device check : re-enumerate from parent bus */
 +		pr_debug("%s: Device check notify on %s\n", __func__, objname);
 +		acpiphp_check_bridge(func->slot->bridge);
 +		break;
 +
 +	case ACPI_NOTIFY_DEVICE_WAKE:
 +		/* wake event */
 +		pr_debug("%s: Device wake notify on %s\n", __func__, objname);
 +		break;
 +
 +	case ACPI_NOTIFY_EJECT_REQUEST:
 +		/* request device eject */
 +		pr_debug("%s: Device eject notify on %s\n", __func__, objname);
 +		if (!(acpiphp_disable_slot(func->slot)))
 +			acpiphp_eject_slot(func->slot);
 +		break;
 +
 +	default:
 +		pr_warn("notify_handler: unknown event type 0x%x for %s\n", type, objname);
 +		break;
 +	}
 +}
 +
 +static void _handle_hotplug_event_func(struct work_struct *work)
  {
 -	struct acpiphp_context *context;
  	struct acpi_hp_work *hp_work;
 +	struct acpiphp_func *func;
  
  	hp_work = container_of(work, struct acpi_hp_work, work);
 -	context = hp_work->context;
 +	func = hp_work->context;
  	acpi_scan_lock_acquire();
  
 -	hotplug_event(hp_work->handle, hp_work->type, context);
 +	hotplug_event_func(hp_work->handle, hp_work->type, func);
  
  	acpi_scan_lock_release();
 -	kfree(hp_work); /* allocated in handle_hotplug_event() */
 -	put_bridge(context->func.parent);
 +	kfree(hp_work); /* allocated in handle_hotplug_event_func */
 +	put_bridge(func->slot->bridge);
  }
  
  /**
@@@ -1201,15 -1095,42 +1313,39 @@@ void acpiphp_enumerate_slots(struct pci
  	 */
  	get_device(&bus->dev);
  
++<<<<<<< HEAD
 +	if (!pci_is_root_bus(bridge->pci_bus) &&
 +	    ACPI_SUCCESS(acpi_get_handle(bridge->handle,
 +					"_EJ0", &dummy_handle))) {
 +		pr_debug("found ejectable p2p bridge\n");
 +		bridge->flags |= BRIDGE_HAS_EJ0;
 +		bridge->func = acpiphp_bridge_handle_to_function(handle);
++=======
+ 	if (!pci_is_root_bus(bridge->pci_bus)) {
+ 		struct acpiphp_context *context;
+ 
+ 		/*
+ 		 * This bridge should have been registered as a hotplug function
+ 		 * under its parent, so the context has to be there.  If not, we
+ 		 * are in deep goo.
+ 		 */
+ 		mutex_lock(&acpiphp_context_lock);
+ 		context = acpiphp_get_context(handle);
+ 		if (WARN_ON(!context)) {
+ 			mutex_unlock(&acpiphp_context_lock);
+ 			put_device(&bus->dev);
+ 			kfree(bridge);
+ 			return;
+ 		}
+ 		bridge->context = context;
+ 		context->bridge = bridge;
+ 		/* Get a reference to the parent bridge. */
+ 		get_bridge(context->func.parent);
+ 		mutex_unlock(&acpiphp_context_lock);
++>>>>>>> bda46dbb6626 (ACPI / hotplug / PCI: Store parent in functions and bus in slots)
  	}
  
 -	/* must be added to the list prior to calling register_slot */
 -	mutex_lock(&bridge_mutex);
 -	list_add(&bridge->list, &bridge_list);
 -	mutex_unlock(&bridge_mutex);
 -
 -	/* register all slot objects under this bridge */
 -	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
 -				     register_slot, NULL, bridge, NULL);
 -	if (ACPI_FAILURE(status)) {
 -		acpi_handle_err(handle, "failed to register slots\n");
 -		cleanup_bridge(bridge);
 -		put_bridge(bridge);
 -	}
 +	init_bridge_misc(bridge);
  }
  
  /* Destroy hotplug slots associated with the PCI bus */
diff --git a/drivers/pci/hotplug/acpiphp.h b/drivers/pci/hotplug/acpiphp.h
index 8d99e4e1e51d..ba7f3c872a5a 100644
--- a/drivers/pci/hotplug/acpiphp.h
+++ b/drivers/pci/hotplug/acpiphp.h
@@ -89,7 +89,7 @@ struct acpiphp_bridge {
  */
 struct acpiphp_slot {
 	struct list_head node;
-	struct acpiphp_bridge *bridge;	/* parent */
+	struct pci_bus *bus;
 	struct list_head funcs;		/* one slot may have different
 					   objects (i.e. for each function) */
 	struct slot *slot;
@@ -109,7 +109,8 @@ struct acpiphp_slot {
  * typically 8 objects per slot (i.e. for each PCI function)
  */
 struct acpiphp_func {
-	struct acpiphp_slot *slot;	/* parent */
+	struct acpiphp_bridge *parent;
+	struct acpiphp_slot *slot;
 
 	struct list_head sibling;
 	struct notifier_block nb;
diff --git a/drivers/pci/hotplug/acpiphp_core.c b/drivers/pci/hotplug/acpiphp_core.c
index 548bab80163b..93182b773f7b 100644
--- a/drivers/pci/hotplug/acpiphp_core.c
+++ b/drivers/pci/hotplug/acpiphp_core.c
@@ -318,10 +318,8 @@ int acpiphp_register_hotplug_slot(struct acpiphp_slot *acpiphp_slot)
 	acpiphp_slot->slot = slot;
 	snprintf(name, SLOT_NAME_SIZE, "%llu", slot->acpi_slot->sun);
 
-	retval = pci_hp_register(slot->hotplug_slot,
-					acpiphp_slot->bridge->pci_bus,
-					acpiphp_slot->device,
-					name);
+	retval = pci_hp_register(slot->hotplug_slot, acpiphp_slot->bus,
+				 acpiphp_slot->device, name);
 	if (retval == -EBUSY)
 		goto error_hpslot;
 	if (retval) {
* Unmerged path drivers/pci/hotplug/acpiphp_glue.c
