s390/uaccess: consistent types

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [s390] uaccess: consistent types (Hendrik Brueckner) [1099147]
Rebuild_FUZZ: 90.91%
commit-author Heiko Carstens <heiko.carstens@de.ibm.com>
commit 211deca6bf413560b562d69748ebc4df5d80d65e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/211deca6.failed

The types 'size_t' and 'unsigned long' have been used randomly for the
uaccess functions. This looks rather confusing.
So let's change all functions to use unsigned long instead and get rid
of size_t in order to have a consistent interface.

The only exception is strncpy_from_user() which uses 'long' since it
may return a signed value (-EFAULT).

	Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
	Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
(cherry picked from commit 211deca6bf413560b562d69748ebc4df5d80d65e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/s390/include/asm/uaccess.h
#	arch/s390/lib/uaccess.h
#	arch/s390/lib/uaccess_mvcos.c
#	arch/s390/lib/uaccess_pt.c
diff --cc arch/s390/include/asm/uaccess.h
index 9c33ed4e666f,2710b41eed22..000000000000
--- a/arch/s390/include/asm/uaccess.h
+++ b/arch/s390/include/asm/uaccess.h
@@@ -92,37 -92,58 +92,70 @@@ static inline unsigned long extable_fix
  #define ARCH_HAS_SORT_EXTABLE
  #define ARCH_HAS_SEARCH_EXTABLE
  
 -int __handle_fault(unsigned long, unsigned long, int);
 +struct uaccess_ops {
 +	size_t (*copy_from_user)(size_t, const void __user *, void *);
 +	size_t (*copy_from_user_small)(size_t, const void __user *, void *);
 +	size_t (*copy_to_user)(size_t, void __user *, const void *);
 +	size_t (*copy_to_user_small)(size_t, void __user *, const void *);
 +	size_t (*copy_in_user)(size_t, void __user *, const void __user *);
 +	size_t (*clear_user)(size_t, void __user *);
 +	size_t (*strnlen_user)(size_t, const char __user *);
 +	size_t (*strncpy_from_user)(size_t, const char __user *, char *);
 +	int (*futex_atomic_op)(int op, u32 __user *, int oparg, int *old);
 +	int (*futex_atomic_cmpxchg)(u32 *, u32 __user *, u32 old, u32 new);
 +};
  
++<<<<<<< HEAD
 +extern struct uaccess_ops uaccess;
 +extern struct uaccess_ops uaccess_std;
 +extern struct uaccess_ops uaccess_mvcos;
 +extern struct uaccess_ops uaccess_mvcos_switch;
 +extern struct uaccess_ops uaccess_pt;
++=======
+ /**
+  * __copy_from_user: - Copy a block of data from user space, with less checking.
+  * @to:   Destination address, in kernel space.
+  * @from: Source address, in user space.
+  * @n:	  Number of bytes to copy.
+  *
+  * Context: User context only.	This function may sleep.
+  *
+  * Copy data from user space to kernel space.  Caller must check
+  * the specified block with access_ok() before calling this function.
+  *
+  * Returns number of bytes that could not be copied.
+  * On success, this will be zero.
+  *
+  * If some data could not be copied, this function will pad the copied
+  * data to the requested size using zero bytes.
+  */
+ unsigned long __must_check __copy_from_user(void *to, const void __user *from,
+ 					    unsigned long n);
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  
 -/**
 - * __copy_to_user: - Copy a block of data into user space, with less checking.
 - * @to:   Destination address, in user space.
 - * @from: Source address, in kernel space.
 - * @n:	  Number of bytes to copy.
 - *
 - * Context: User context only.	This function may sleep.
 - *
 - * Copy data from kernel space to user space.  Caller must check
 - * the specified block with access_ok() before calling this function.
 - *
 - * Returns number of bytes that could not be copied.
 - * On success, this will be zero.
 - */
 -unsigned long __must_check __copy_to_user(void __user *to, const void *from,
 -					  unsigned long n);
 +extern int __handle_fault(unsigned long, unsigned long, int);
  
++<<<<<<< HEAD
 +static inline int __put_user_fn(size_t size, void __user *ptr, void *x)
++=======
+ #define __copy_to_user_inatomic __copy_to_user
+ #define __copy_from_user_inatomic __copy_from_user
+ 
+ static inline int __put_user_fn(void *x, void __user *ptr, unsigned long size)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
 -	size = __copy_to_user(ptr, x, size);
 -	return size ? -EFAULT : 0;
 +	size = uaccess.copy_to_user_small(size, ptr, x);
 +	return size ? -EFAULT : size;
  }
  
++<<<<<<< HEAD
 +static inline int __get_user_fn(size_t size, const void __user *ptr, void *x)
++=======
+ static inline int __get_user_fn(void *x, const void __user *ptr, unsigned long size)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
 -	size = __copy_from_user(x, ptr, size);
 -	return size ? -EFAULT : 0;
 +	size = uaccess.copy_from_user_small(size, ptr, x);
 +	return size ? -EFAULT : size;
  }
  
  /*
@@@ -336,14 -305,15 +369,20 @@@ static inline long __must_chec
  strncpy_from_user(char *dst, const char __user *src, long count)
  {
  	might_fault();
 -	return __strncpy_from_user(dst, src, count);
 +	return uaccess.strncpy_from_user(count, src, dst);
  }
  
++<<<<<<< HEAD
 +static inline unsigned long
 +strnlen_user(const char __user * src, unsigned long n)
++=======
+ unsigned long __must_check __strnlen_user(const char __user *src, unsigned long count);
+ 
+ static inline unsigned long strnlen_user(const char __user *src, unsigned long n)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
  	might_fault();
 -	return __strnlen_user(src, n);
 +	return uaccess.strnlen_user(n, src);
  }
  
  /**
@@@ -365,21 -335,15 +404,32 @@@
  /*
   * Zero Userspace
   */
++<<<<<<< HEAD
 +
 +static inline unsigned long __must_check
 +__clear_user(void __user *to, unsigned long n)
++=======
+ unsigned long __must_check __clear_user(void __user *to, unsigned long size);
+ 
+ static inline unsigned long __must_check clear_user(void __user *to, unsigned long n)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
 +{
 +	return uaccess.clear_user(n, to);
 +}
 +
++<<<<<<< HEAD
 +static inline unsigned long __must_check
 +clear_user(void __user *to, unsigned long n)
  {
  	might_fault();
 -	return __clear_user(to, n);
 +	return uaccess.clear_user(n, to);
  }
  
 +extern int copy_to_user_real(void __user *dest, void *src, size_t count);
 +extern int copy_from_user_real(void *dest, void __user *src, size_t count);
++=======
+ int copy_to_user_real(void __user *dest, void *src, unsigned long count);
+ int copy_from_user_real(void *dest, void __user *src, unsigned long count);
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  
  #endif /* __S390_UACCESS_H */
diff --cc arch/s390/lib/uaccess.h
index b1a22173d027,c7e0e81f4b4e..000000000000
--- a/arch/s390/lib/uaccess.h
+++ b/arch/s390/lib/uaccess.h
@@@ -6,7 -6,11 +6,16 @@@
  #ifndef __ARCH_S390_LIB_UACCESS_H
  #define __ARCH_S390_LIB_UACCESS_H
  
++<<<<<<< HEAD
 +extern int futex_atomic_op_pt(int, u32 __user *, int, int *);
 +extern int futex_atomic_cmpxchg_pt(u32 *, u32 __user *, u32, u32);
++=======
+ unsigned long copy_from_user_pt(void *to, const void __user *from, unsigned long n);
+ unsigned long copy_to_user_pt(void __user *to, const void *from, unsigned long n);
+ unsigned long copy_in_user_pt(void __user *to, const void __user *from, unsigned long n);
+ unsigned long clear_user_pt(void __user *to, unsigned long n);
+ unsigned long strnlen_user_pt(const char __user *src, unsigned long count);
+ long strncpy_from_user_pt(char *dst, const char __user *src, long count);
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  
  #endif /* __ARCH_S390_LIB_UACCESS_H */
diff --cc arch/s390/lib/uaccess_mvcos.c
index 1829742bf479,8c01f3aaf95c..000000000000
--- a/arch/s390/lib/uaccess_mvcos.c
+++ b/arch/s390/lib/uaccess_mvcos.c
@@@ -26,7 -28,10 +26,14 @@@
  #define SLR	"slgr"
  #endif
  
++<<<<<<< HEAD
 +static size_t copy_from_user_mvcos(size_t size, const void __user *ptr, void *x)
++=======
+ static struct static_key have_mvcos = STATIC_KEY_INIT_TRUE;
+ 
+ static inline unsigned long copy_from_user_mvcos(void *x, const void __user *ptr,
+ 						 unsigned long size)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
  	register unsigned long reg0 asm("0") = 0x81UL;
  	unsigned long tmp1, tmp2;
@@@ -65,14 -70,16 +72,23 @@@
  	return size;
  }
  
++<<<<<<< HEAD
 +static size_t copy_from_user_mvcos_check(size_t size, const void __user *ptr, void *x)
++=======
+ unsigned long __copy_from_user(void *to, const void __user *from, unsigned long n)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
 -	if (static_key_true(&have_mvcos))
 -		return copy_from_user_mvcos(to, from, n);
 -	return copy_from_user_pt(to, from, n);
 +	if (size <= 256)
 +		return copy_from_user_std(size, ptr, x);
 +	return copy_from_user_mvcos(size, ptr, x);
  }
 -EXPORT_SYMBOL(__copy_from_user);
  
++<<<<<<< HEAD
 +static size_t copy_to_user_mvcos(size_t size, void __user *ptr, const void *x)
++=======
+ static inline unsigned long copy_to_user_mvcos(void __user *ptr, const void *x,
+ 					       unsigned long size)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
  	register unsigned long reg0 asm("0") = 0x810000UL;
  	unsigned long tmp1, tmp2;
@@@ -101,16 -108,16 +117,25 @@@
  	return size;
  }
  
++<<<<<<< HEAD
 +static size_t copy_to_user_mvcos_check(size_t size, void __user *ptr,
 +				       const void *x)
++=======
+ unsigned long __copy_to_user(void __user *to, const void *from, unsigned long n)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
 -	if (static_key_true(&have_mvcos))
 -		return copy_to_user_mvcos(to, from, n);
 -	return copy_to_user_pt(to, from, n);
 +	if (size <= 256)
 +		return copy_to_user_std(size, ptr, x);
 +	return copy_to_user_mvcos(size, ptr, x);
  }
 -EXPORT_SYMBOL(__copy_to_user);
  
++<<<<<<< HEAD
 +static size_t copy_in_user_mvcos(size_t size, void __user *to,
 +				 const void __user *from)
++=======
+ static inline unsigned long copy_in_user_mvcos(void __user *to, const void __user *from,
+ 					       unsigned long size)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
  	register unsigned long reg0 asm("0") = 0x810081UL;
  	unsigned long tmp1, tmp2;
@@@ -132,7 -139,15 +157,19 @@@
  	return size;
  }
  
++<<<<<<< HEAD
 +static size_t clear_user_mvcos(size_t size, void __user *to)
++=======
+ unsigned long __copy_in_user(void __user *to, const void __user *from, unsigned long n)
+ {
+ 	if (static_key_true(&have_mvcos))
+ 		return copy_in_user_mvcos(to, from, n);
+ 	return copy_in_user_pt(to, from, n);
+ }
+ EXPORT_SYMBOL(__copy_in_user);
+ 
+ static inline unsigned long clear_user_mvcos(void __user *to, unsigned long size)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
  	register unsigned long reg0 asm("0") = 0x810000UL;
  	unsigned long tmp1, tmp2;
@@@ -160,17 -175,26 +197,30 @@@
  	return size;
  }
  
++<<<<<<< HEAD
 +static size_t strnlen_user_mvcos(size_t count, const char __user *src)
++=======
+ unsigned long __clear_user(void __user *to, unsigned long size)
  {
- 	size_t done, len, offset, len_str;
+ 	if (static_key_true(&have_mvcos))
+ 		return clear_user_mvcos(to, size);
+ 	return clear_user_pt(to, size);
+ }
+ EXPORT_SYMBOL(__clear_user);
+ 
+ static inline unsigned long strnlen_user_mvcos(const char __user *src,
+ 					       unsigned long count)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
+ {
+ 	unsigned long done, len, offset, len_str;
  	char buf[256];
  
  	done = 0;
  	do {
- 		offset = (size_t)src & ~PAGE_MASK;
+ 		offset = (unsigned long)src & ~PAGE_MASK;
  		len = min(256UL, PAGE_SIZE - offset);
  		len = min(count - done, len);
 -		if (copy_from_user_mvcos(buf, src, len))
 +		if (copy_from_user_mvcos(len, src, buf))
  			return 0;
  		len_str = strnlen(buf, len);
  		done += len_str;
@@@ -179,18 -203,26 +229,33 @@@
  	return done + 1;
  }
  
++<<<<<<< HEAD
 +static size_t strncpy_from_user_mvcos(size_t count, const char __user *src,
 +				      char *dst)
 +{
 +	size_t done, len, offset, len_str;
++=======
+ unsigned long __strnlen_user(const char __user *src, unsigned long count)
+ {
+ 	if (static_key_true(&have_mvcos))
+ 		return strnlen_user_mvcos(src, count);
+ 	return strnlen_user_pt(src, count);
+ }
+ EXPORT_SYMBOL(__strnlen_user);
+ 
+ static inline long strncpy_from_user_mvcos(char *dst, const char __user *src,
+ 					   long count)
+ {
+ 	unsigned long done, len, offset, len_str;
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  
- 	if (unlikely(!count))
+ 	if (unlikely(count <= 0))
  		return 0;
  	done = 0;
  	do {
- 		offset = (size_t)src & ~PAGE_MASK;
+ 		offset = (unsigned long)src & ~PAGE_MASK;
  		len = min(count - done, PAGE_SIZE - offset);
 -		if (copy_from_user_mvcos(dst, src, len))
 +		if (copy_from_user_mvcos(len, src, dst))
  			return -EFAULT;
  		len_str = strnlen(dst, len);
  		done += len_str;
diff --cc arch/s390/lib/uaccess_pt.c
index f4df0e3aabe2,8d39760bae68..000000000000
--- a/arch/s390/lib/uaccess_pt.c
+++ b/arch/s390/lib/uaccess_pt.c
@@@ -22,7 -22,7 +22,11 @@@
  #define SLR	"slgr"
  #endif
  
++<<<<<<< HEAD
 +static size_t strnlen_kernel(size_t count, const char __user *src)
++=======
+ static unsigned long strnlen_kernel(const char __user *src, unsigned long count)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
  	register unsigned long reg0 asm("0") = 0UL;
  	unsigned long tmp1, tmp2;
@@@ -42,8 -42,8 +46,13 @@@
  	return count;
  }
  
++<<<<<<< HEAD
 +static size_t copy_in_kernel(size_t count, void __user *to,
 +			     const void __user *from)
++=======
+ static unsigned long copy_in_kernel(void __user *to, const void __user *from,
+ 				    unsigned long count)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
  	unsigned long tmp1;
  
@@@ -211,29 -210,29 +219,41 @@@ fault
  	return 0;
  }
  
++<<<<<<< HEAD
 +static size_t copy_from_user_pt(size_t n, const void __user *from, void *to)
++=======
+ unsigned long copy_from_user_pt(void *to, const void __user *from, unsigned long n)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
- 	size_t rc;
+ 	unsigned long rc;
  
  	if (segment_eq(get_fs(), KERNEL_DS))
 -		return copy_in_kernel((void __user *) to, from, n);
 +		return copy_in_kernel(n, (void __user *) to, from);
  	rc = __user_copy_pt((unsigned long) from, to, n, 0);
  	if (unlikely(rc))
  		memset(to + n - rc, 0, rc);
  	return rc;
  }
  
++<<<<<<< HEAD
 +static size_t copy_to_user_pt(size_t n, void __user *to, const void *from)
++=======
+ unsigned long copy_to_user_pt(void __user *to, const void *from, unsigned long n)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
  	if (segment_eq(get_fs(), KERNEL_DS))
 -		return copy_in_kernel(to, (void __user *) from, n);
 +		return copy_in_kernel(n, to, (void __user *) from);
  	return __user_copy_pt((unsigned long) to, (void *) from, n, 1);
  }
  
++<<<<<<< HEAD
 +static size_t clear_user_pt(size_t n, void __user *to)
++=======
+ unsigned long clear_user_pt(void __user *to, unsigned long n)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
  	void *zpage = (void *) empty_zero_page;
- 	long done, size, ret;
+ 	unsigned long done, size, ret;
  
  	done = 0;
  	do {
@@@ -253,7 -252,7 +273,11 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
 +static size_t strnlen_user_pt(size_t count, const char __user *src)
++=======
+ unsigned long strnlen_user_pt(const char __user *src, unsigned long count)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
  	unsigned long uaddr = (unsigned long) src;
  	struct mm_struct *mm = current->mm;
@@@ -289,19 -288,18 +313,23 @@@ fault
  	goto retry;
  }
  
++<<<<<<< HEAD
 +static size_t strncpy_from_user_pt(size_t count, const char __user *src,
 +				   char *dst)
++=======
+ long strncpy_from_user_pt(char *dst, const char __user *src, long count)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
- 	size_t done, len, offset, len_str;
+ 	unsigned long done, len, offset, len_str;
  
- 	if (unlikely(!count))
+ 	if (unlikely(count <= 0))
  		return 0;
  	done = 0;
  	do {
- 		offset = (size_t)src & ~PAGE_MASK;
+ 		offset = (unsigned long)src & ~PAGE_MASK;
  		len = min(count - done, PAGE_SIZE - offset);
  		if (segment_eq(get_fs(), KERNEL_DS)) {
 -			if (copy_in_kernel((void __user *) dst, src, len))
 +			if (copy_in_kernel(len, (void __user *) dst, src))
  				return -EFAULT;
  		} else {
  			if (__user_copy_pt((unsigned long) src, dst, len, 0))
@@@ -315,8 -313,8 +343,13 @@@
  	return done;
  }
  
++<<<<<<< HEAD
 +static size_t copy_in_user_pt(size_t n, void __user *to,
 +			      const void __user *from)
++=======
+ unsigned long copy_in_user_pt(void __user *to, const void __user *from,
+ 			      unsigned long n)
++>>>>>>> 211deca6bf41 (s390/uaccess: consistent types)
  {
  	struct mm_struct *mm = current->mm;
  	unsigned long offset_max, uaddr, done, size, error_code;
* Unmerged path arch/s390/include/asm/uaccess.h
* Unmerged path arch/s390/lib/uaccess.h
* Unmerged path arch/s390/lib/uaccess_mvcos.c
* Unmerged path arch/s390/lib/uaccess_pt.c
diff --git a/arch/s390/mm/maccess.c b/arch/s390/mm/maccess.c
index 54faff904b34..309340ae035a 100644
--- a/arch/s390/mm/maccess.c
+++ b/arch/s390/mm/maccess.c
@@ -128,7 +128,7 @@ void memcpy_absolute(void *dest, void *src, size_t count)
 /*
  * Copy memory from kernel (real) to user (virtual)
  */
-int copy_to_user_real(void __user *dest, void *src, size_t count)
+int copy_to_user_real(void __user *dest, void *src, unsigned long count)
 {
 	int offs = 0, size, rc;
 	char *buf;
@@ -154,7 +154,7 @@ out:
 /*
  * Copy memory from user (virtual) to kernel (real)
  */
-int copy_from_user_real(void *dest, void __user *src, size_t count)
+int copy_from_user_real(void *dest, void __user *src, unsigned long count)
 {
 	int offs = 0, size, rc;
 	char *buf;
