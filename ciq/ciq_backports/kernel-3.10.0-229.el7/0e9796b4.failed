openvswitch: Reduce locking requirements.

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] openvswitch: Reduce locking requirements (Jiri Benc) [1110384]
Rebuild_FUZZ: 98.77%
commit-author Jarno Rajahalme <jrajahalme@nicira.com>
commit 0e9796b4af9ef490e203158cb738a5a4986eb75c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/0e9796b4.failed

Reduce and clarify locking requirements for ovs_flow_cmd_alloc_info(),
ovs_flow_cmd_fill_info() and ovs_flow_cmd_build_info().

A datapath pointer is available only when holding a lock.  Change
ovs_flow_cmd_fill_info() and ovs_flow_cmd_build_info() to take a
dp_ifindex directly, rather than a datapath pointer that is then
(only) used to get the dp_ifindex.  This is useful, since the
dp_ifindex is available even when the datapath pointer is not, both
before and after taking a lock, which makes further critical section
reduction possible.

Make ovs_flow_cmd_alloc_info() take an 'acts' argument instead a
'flow' pointer.  This allows some future patches to do the allocation
before acquiring the flow pointer.

The locking requirements after this patch are:

ovs_flow_cmd_alloc_info(): May be called without locking, must not be
called while holding the RCU read lock (due to memory allocation).
If 'acts' belong to a flow in the flow table, however, then the
caller must hold ovs_mutex.

ovs_flow_cmd_fill_info(): Either ovs_mutex or RCU read lock must be held.

ovs_flow_cmd_build_info(): This calls both of the above, so the caller
must hold ovs_mutex.

	Signed-off-by: Jarno Rajahalme <jrajahalme@nicira.com>
	Signed-off-by: Pravin B Shelar <pshelar@nicira.com>
(cherry picked from commit 0e9796b4af9ef490e203158cb738a5a4986eb75c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/openvswitch/datapath.c
diff --cc net/openvswitch/datapath.c
index d01b30b9528a,949fc7fadaf0..000000000000
--- a/net/openvswitch/datapath.c
+++ b/net/openvswitch/datapath.c
@@@ -740,32 -754,40 +741,65 @@@ error
  	return err;
  }
  
++<<<<<<< HEAD
 +/* Must be called with ovs_mutex. */
 +static struct sk_buff *ovs_flow_cmd_alloc_info(struct sw_flow *flow,
 +					       struct genl_info *info)
 +{
 +	size_t len;
 +
 +	len = ovs_flow_cmd_msg_size(ovsl_dereference(flow->sf_acts));
 +
 +	return genlmsg_new_unicast(len, info, GFP_KERNEL);
 +}
 +
 +/* Must be called with ovs_mutex. */
 +static struct sk_buff *ovs_flow_cmd_build_info(struct sw_flow *flow,
 +					       struct datapath *dp,
 +					       struct genl_info *info,
 +					       u8 cmd)
++=======
+ /* May not be called with RCU read lock. */
+ static struct sk_buff *ovs_flow_cmd_alloc_info(const struct sw_flow_actions *acts,
+ 					       struct genl_info *info,
+ 					       bool always)
+ {
+ 	struct sk_buff *skb;
+ 
+ 	if (!always && !ovs_must_notify(info, &ovs_dp_flow_multicast_group))
+ 		return NULL;
+ 
+ 	skb = genlmsg_new_unicast(ovs_flow_cmd_msg_size(acts), info, GFP_KERNEL);
+ 	if (!skb)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	return skb;
+ }
+ 
+ /* Called with ovs_mutex. */
+ static struct sk_buff *ovs_flow_cmd_build_info(const struct sw_flow *flow,
+ 					       int dp_ifindex,
+ 					       struct genl_info *info, u8 cmd,
+ 					       bool always)
++>>>>>>> 0e9796b4af9e (openvswitch: Reduce locking requirements.)
  {
  	struct sk_buff *skb;
  	int retval;
  
++<<<<<<< HEAD
 +	skb = ovs_flow_cmd_alloc_info(flow, info);
 +	if (!skb)
 +		return ERR_PTR(-ENOMEM);
- 
- 	retval = ovs_flow_cmd_fill_info(flow, dp, skb, info->snd_portid,
- 					info->snd_seq, 0, cmd);
++=======
+ 	skb = ovs_flow_cmd_alloc_info(ovsl_dereference(flow->sf_acts), info,
+ 				      always);
+ 	if (!skb || IS_ERR(skb))
+ 		return skb;
++>>>>>>> 0e9796b4af9e (openvswitch: Reduce locking requirements.)
+ 
+ 	retval = ovs_flow_cmd_fill_info(flow, dp_ifindex, skb,
+ 					info->snd_portid, info->snd_seq, 0,
+ 					cmd);
  	BUG_ON(retval < 0);
  	return skb;
  }
@@@ -846,7 -868,8 +880,12 @@@ static int ovs_flow_cmd_new_or_set(stru
  			goto err_flow_free;
  		}
  
++<<<<<<< HEAD
 +		reply = ovs_flow_cmd_build_info(flow, dp, info, OVS_FLOW_CMD_NEW);
++=======
+ 		reply = ovs_flow_cmd_build_info(flow, ovs_header->dp_ifindex,
+ 						info, OVS_FLOW_CMD_NEW, false);
++>>>>>>> 0e9796b4af9e (openvswitch: Reduce locking requirements.)
  	} else {
  		/* We found a matching flow. */
  		/* Bail out if we're not allowed to modify an existing flow.
@@@ -872,7 -895,9 +911,13 @@@
  			rcu_assign_pointer(flow->sf_acts, acts);
  			ovs_nla_free_flow_actions(old_acts);
  		}
++<<<<<<< HEAD
 +		reply = ovs_flow_cmd_build_info(flow, dp, info, OVS_FLOW_CMD_NEW);
++=======
+ 
+ 		reply = ovs_flow_cmd_build_info(flow, ovs_header->dp_ifindex,
+ 						info, OVS_FLOW_CMD_NEW, false);
++>>>>>>> 0e9796b4af9e (openvswitch: Reduce locking requirements.)
  
  		/* Clear stats. */
  		if (a[OVS_FLOW_ATTR_CLEAR])
@@@ -931,7 -959,8 +976,12 @@@ static int ovs_flow_cmd_get(struct sk_b
  		goto unlock;
  	}
  
++<<<<<<< HEAD
 +	reply = ovs_flow_cmd_build_info(flow, dp, info, OVS_FLOW_CMD_NEW);
++=======
+ 	reply = ovs_flow_cmd_build_info(flow, ovs_header->dp_ifindex, info,
+ 					OVS_FLOW_CMD_NEW, true);
++>>>>>>> 0e9796b4af9e (openvswitch: Reduce locking requirements.)
  	if (IS_ERR(reply)) {
  		err = PTR_ERR(reply);
  		goto unlock;
@@@ -978,18 -1007,22 +1028,35 @@@ static int ovs_flow_cmd_del(struct sk_b
  		goto unlock;
  	}
  
++<<<<<<< HEAD
 +	reply = ovs_flow_cmd_alloc_info(flow, info);
 +	if (!reply) {
 +		err = -ENOMEM;
++=======
+ 	reply = ovs_flow_cmd_alloc_info(ovsl_dereference(flow->sf_acts), info,
+ 					false);
+ 	if (IS_ERR(reply)) {
+ 		err = PTR_ERR(reply);
++>>>>>>> 0e9796b4af9e (openvswitch: Reduce locking requirements.)
  		goto unlock;
  	}
  
  	ovs_flow_tbl_remove(&dp->table, flow);
  
++<<<<<<< HEAD
 +	err = ovs_flow_cmd_fill_info(flow, dp, reply, info->snd_portid,
 +				     info->snd_seq, 0, OVS_FLOW_CMD_DEL);
 +	BUG_ON(err < 0);
 +
++=======
+ 	if (reply) {
+ 		err = ovs_flow_cmd_fill_info(flow, ovs_header->dp_ifindex,
+ 					     reply, info->snd_portid,
+ 					     info->snd_seq, 0,
+ 					     OVS_FLOW_CMD_DEL);
+ 		BUG_ON(err < 0);
+ 	}
++>>>>>>> 0e9796b4af9e (openvswitch: Reduce locking requirements.)
  	ovs_flow_free(flow, true);
  	ovs_unlock();
  
* Unmerged path net/openvswitch/datapath.c
