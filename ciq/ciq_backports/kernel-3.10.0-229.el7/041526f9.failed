cpufreq: Use cpufreq_for_each_* macros for frequency table iteration

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] Use cpufreq_for_each_* macros for frequency table iteration (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 92.91%
commit-author Stratos Karafotis <stratosk@semaphore.gr>
commit 041526f915a90b2b628cd0253e2c85da8040276d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/041526f9.failed

The cpufreq core now supports the cpufreq_for_each_entry and
cpufreq_for_each_valid_entry macros helpers for iteration over the
cpufreq_frequency_table, so use them.

It should have no functional changes.

	Signed-off-by: Stratos Karafotis <stratosk@semaphore.gr>
	Acked-by: Lad, Prabhakar <prabhakar.csengg@gmail.com>
	Acked-by: Viresh Kumar <viresh.kumar@linaro.org>
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 041526f915a90b2b628cd0253e2c85da8040276d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/cpufreq/arm_big_little.c
#	drivers/cpufreq/cpufreq_stats.c
#	drivers/cpufreq/elanfreq.c
#	drivers/cpufreq/exynos5440-cpufreq.c
#	drivers/cpufreq/freq_table.c
#	drivers/cpufreq/longhaul.c
#	drivers/cpufreq/powernow-k6.c
#	drivers/cpufreq/s3c2416-cpufreq.c
#	drivers/cpufreq/s3c64xx-cpufreq.c
diff --cc drivers/cpufreq/arm_big_little.c
index 5d7f53fcd6f5,1f4d4e315057..000000000000
--- a/drivers/cpufreq/arm_big_little.c
+++ b/drivers/cpufreq/arm_big_little.c
@@@ -87,11 -158,137 +87,86 @@@ static int bL_cpufreq_set_target(struc
  		return ret;
  	}
  
 -	mutex_unlock(&cluster_lock[new_cluster]);
 -
 -	/* Recalc freq for old cluster when switching clusters */
 -	if (old_cluster != new_cluster) {
 -		pr_debug("%s: cpu: %d, old cluster: %d, new cluster: %d\n",
 -				__func__, cpu, old_cluster, new_cluster);
 +	policy->cur = freqs.new;
  
 -		/* Switch cluster */
 -		bL_switch_request(cpu, new_cluster);
 -
 -		mutex_lock(&cluster_lock[old_cluster]);
 -
 -		/* Set freq of old cluster if there are cpus left on it */
 -		new_rate = find_cluster_maxfreq(old_cluster);
 -		new_rate = ACTUAL_FREQ(old_cluster, new_rate);
 -
 -		if (new_rate) {
 -			pr_debug("%s: Updating rate of old cluster: %d, to freq: %d\n",
 -					__func__, old_cluster, new_rate);
 -
 -			if (clk_set_rate(clk[old_cluster], new_rate * 1000))
 -				pr_err("%s: clk_set_rate failed: %d, old cluster: %d\n",
 -						__func__, ret, old_cluster);
 -		}
 -		mutex_unlock(&cluster_lock[old_cluster]);
 -	}
 -
 -	return 0;
 -}
 -
 -/* Set clock frequency */
 -static int bL_cpufreq_set_target(struct cpufreq_policy *policy,
 -		unsigned int index)
 -{
 -	u32 cpu = policy->cpu, cur_cluster, new_cluster, actual_cluster;
 -	unsigned int freqs_new;
 -
 -	cur_cluster = cpu_to_cluster(cpu);
 -	new_cluster = actual_cluster = per_cpu(physical_cluster, cpu);
 -
 -	freqs_new = freq_table[cur_cluster][index].frequency;
 -
 -	if (is_bL_switching_enabled()) {
 -		if ((actual_cluster == A15_CLUSTER) &&
 -				(freqs_new < clk_big_min)) {
 -			new_cluster = A7_CLUSTER;
 -		} else if ((actual_cluster == A7_CLUSTER) &&
 -				(freqs_new > clk_little_max)) {
 -			new_cluster = A15_CLUSTER;
 -		}
 -	}
 -
 -	return bL_cpufreq_set_rate(cpu, actual_cluster, new_cluster, freqs_new);
 -}
 -
 -static inline u32 get_table_count(struct cpufreq_frequency_table *table)
 -{
 -	int count;
 +	cpufreq_notify_transition(policy, &freqs, CPUFREQ_POSTCHANGE);
  
++<<<<<<< HEAD
 +	return ret;
++=======
+ 	for (count = 0; table[count].frequency != CPUFREQ_TABLE_END; count++)
+ 		;
+ 
+ 	return count;
+ }
+ 
+ /* get the minimum frequency in the cpufreq_frequency_table */
+ static inline u32 get_table_min(struct cpufreq_frequency_table *table)
+ {
+ 	struct cpufreq_frequency_table *pos;
+ 	uint32_t min_freq = ~0;
+ 	cpufreq_for_each_entry(pos, table)
+ 		if (pos->frequency < min_freq)
+ 			min_freq = pos->frequency;
+ 	return min_freq;
+ }
+ 
+ /* get the maximum frequency in the cpufreq_frequency_table */
+ static inline u32 get_table_max(struct cpufreq_frequency_table *table)
+ {
+ 	struct cpufreq_frequency_table *pos;
+ 	uint32_t max_freq = 0;
+ 	cpufreq_for_each_entry(pos, table)
+ 		if (pos->frequency > max_freq)
+ 			max_freq = pos->frequency;
+ 	return max_freq;
+ }
+ 
+ static int merge_cluster_tables(void)
+ {
+ 	int i, j, k = 0, count = 1;
+ 	struct cpufreq_frequency_table *table;
+ 
+ 	for (i = 0; i < MAX_CLUSTERS; i++)
+ 		count += get_table_count(freq_table[i]);
+ 
+ 	table = kzalloc(sizeof(*table) * count, GFP_KERNEL);
+ 	if (!table)
+ 		return -ENOMEM;
+ 
+ 	freq_table[MAX_CLUSTERS] = table;
+ 
+ 	/* Add in reverse order to get freqs in increasing order */
+ 	for (i = MAX_CLUSTERS - 1; i >= 0; i--) {
+ 		for (j = 0; freq_table[i][j].frequency != CPUFREQ_TABLE_END;
+ 				j++) {
+ 			table[k].frequency = VIRT_FREQ(i,
+ 					freq_table[i][j].frequency);
+ 			pr_debug("%s: index: %d, freq: %d\n", __func__, k,
+ 					table[k].frequency);
+ 			k++;
+ 		}
+ 	}
+ 
+ 	table[k].driver_data = k;
+ 	table[k].frequency = CPUFREQ_TABLE_END;
+ 
+ 	pr_debug("%s: End, table: %p, count: %d\n", __func__, table, k);
+ 
+ 	return 0;
+ }
+ 
+ static void _put_cluster_clk_and_freq_table(struct device *cpu_dev)
+ {
+ 	u32 cluster = raw_cpu_to_cluster(cpu_dev->id);
+ 
+ 	if (!freq_table[cluster])
+ 		return;
+ 
+ 	clk_put(clk[cluster]);
+ 	dev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table[cluster]);
+ 	dev_dbg(cpu_dev, "%s: cluster: %d\n", __func__, cluster);
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  }
  
  static void put_cluster_clk_and_freq_table(struct device *cpu_dev)
diff --cc drivers/cpufreq/cpufreq_stats.c
index 04c5a81b41f0,0cd9b4dcef99..000000000000
--- a/drivers/cpufreq/cpufreq_stats.c
+++ b/drivers/cpufreq/cpufreq_stats.c
@@@ -188,17 -180,21 +188,26 @@@ put_ref
  	cpufreq_cpu_put(policy);
  }
  
 -static int __cpufreq_stats_create_table(struct cpufreq_policy *policy)
 +static int cpufreq_stats_create_table(struct cpufreq_policy *policy,
 +		struct cpufreq_frequency_table *table)
  {
- 	unsigned int i, j, count = 0, ret = 0;
+ 	unsigned int i, count = 0, ret = 0;
  	struct cpufreq_stats *stat;
 +	struct cpufreq_policy *data;
  	unsigned int alloc_size;
  	unsigned int cpu = policy->cpu;
++<<<<<<< HEAD
++=======
+ 	struct cpufreq_frequency_table *pos, *table;
+ 
+ 	table = cpufreq_frequency_get_table(cpu);
+ 	if (unlikely(!table))
+ 		return 0;
+ 
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  	if (per_cpu(cpufreq_stats_table, cpu))
  		return -EBUSY;
 -	stat = kzalloc(sizeof(*stat), GFP_KERNEL);
 +	stat = kzalloc(sizeof(struct cpufreq_stats), GFP_KERNEL);
  	if ((stat) == NULL)
  		return -ENOMEM;
  
diff --cc drivers/cpufreq/elanfreq.c
index 658d860344b0,1c06e786c9ba..000000000000
--- a/drivers/cpufreq/elanfreq.c
+++ b/drivers/cpufreq/elanfreq.c
@@@ -201,8 -147,7 +201,12 @@@ static int elanfreq_target(struct cpufr
  static int elanfreq_cpu_init(struct cpufreq_policy *policy)
  {
  	struct cpuinfo_x86 *c = &cpu_data(0);
++<<<<<<< HEAD
 +	unsigned int i;
 +	int result;
++=======
+ 	struct cpufreq_frequency_table *pos;
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  
  	/* capability check */
  	if ((c->x86_vendor != X86_VENDOR_AMD) ||
diff --cc drivers/cpufreq/exynos5440-cpufreq.c
index 0c74018eda47,f33f25b483ca..000000000000
--- a/drivers/cpufreq/exynos5440-cpufreq.c
+++ b/drivers/cpufreq/exynos5440-cpufreq.c
@@@ -115,16 -114,14 +115,25 @@@ static struct cpufreq_freqs freqs
  
  static int init_div_table(void)
  {
- 	struct cpufreq_frequency_table *freq_tbl = dvfs_info->freq_table;
+ 	struct cpufreq_frequency_table *pos, *freq_tbl = dvfs_info->freq_table;
  	unsigned int tmp, clk_div, ema_div, freq, volt_id;
++<<<<<<< HEAD
 +	int i = 0;
 +	struct opp *opp;
 +
 +	rcu_read_lock();
 +	for (i = 0; freq_tbl[i].frequency != CPUFREQ_TABLE_END; i++) {
 +
 +		opp = opp_find_freq_exact(dvfs_info->dev,
 +					freq_tbl[i].frequency * 1000, true);
++=======
+ 	struct dev_pm_opp *opp;
+ 
+ 	rcu_read_lock();
+ 	cpufreq_for_each_entry(pos, freq_tbl) {
+ 		opp = dev_pm_opp_find_freq_exact(dvfs_info->dev,
+ 					pos->frequency * 1000, true);
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  		if (IS_ERR(opp)) {
  			rcu_read_unlock();
  			dev_err(dvfs_info->dev,
@@@ -165,10 -163,11 +175,11 @@@
  	return 0;
  }
  
 -static void exynos_enable_dvfs(unsigned int cur_frequency)
 +static void exynos_enable_dvfs(void)
  {
- 	unsigned int tmp, i, cpu;
+ 	unsigned int tmp, cpu;
  	struct cpufreq_frequency_table *freq_table = dvfs_info->freq_table;
+ 	struct cpufreq_frequency_table *pos;
  	/* Disable DVFS */
  	__raw_writel(0,	dvfs_info->base + XMU_DVFS_CTRL);
  
@@@ -183,15 -182,15 +194,25 @@@
  	 __raw_writel(tmp, dvfs_info->base + XMU_PMUIRQEN);
  
  	/* Set initial performance index */
++<<<<<<< HEAD
 +	for (i = 0; freq_table[i].frequency != CPUFREQ_TABLE_END; i++)
 +		if (freq_table[i].frequency == dvfs_info->cur_frequency)
++=======
+ 	cpufreq_for_each_entry(pos, freq_table)
+ 		if (pos->frequency == cur_frequency)
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  			break;
  
- 	if (freq_table[i].frequency == CPUFREQ_TABLE_END) {
+ 	if (pos->frequency == CPUFREQ_TABLE_END) {
  		dev_crit(dvfs_info->dev, "Boot up frequency not supported\n");
  		/* Assign the highest frequency */
++<<<<<<< HEAD
 +		i = 0;
 +		dvfs_info->cur_frequency = freq_table[i].frequency;
++=======
+ 		pos = freq_table;
+ 		cur_frequency = pos->frequency;
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  	}
  
  	dev_info(dvfs_info->dev, "Setting dvfs initial frequency = %uKHZ",
diff --cc drivers/cpufreq/freq_table.c
index 8962d53f6e56,8e518c689393..000000000000
--- a/drivers/cpufreq/freq_table.c
+++ b/drivers/cpufreq/freq_table.c
@@@ -21,19 -21,19 +21,26 @@@
  int cpufreq_frequency_table_cpuinfo(struct cpufreq_policy *policy,
  				    struct cpufreq_frequency_table *table)
  {
+ 	struct cpufreq_frequency_table *pos;
  	unsigned int min_freq = ~0;
  	unsigned int max_freq = 0;
- 	unsigned int i;
+ 	unsigned int freq;
  
- 	for (i = 0; (table[i].frequency != CPUFREQ_TABLE_END); i++) {
- 		unsigned int freq = table[i].frequency;
- 		if (freq == CPUFREQ_ENTRY_INVALID) {
- 			pr_debug("table entry %u is invalid, skipping\n", i);
+ 	cpufreq_for_each_valid_entry(pos, table) {
+ 		freq = pos->frequency;
  
++<<<<<<< HEAD
 +			continue;
 +		}
 +		pr_debug("table entry %u: %u kHz, %u driver_data\n",
 +					i, freq, table[i].driver_data);
++=======
+ 		if (!cpufreq_boost_enabled()
+ 		    && (pos->flags & CPUFREQ_BOOST_FREQ))
+ 			continue;
+ 
+ 		pr_debug("table entry %u: %u kHz\n", (int)(pos - table), freq);
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  		if (freq < min_freq)
  			min_freq = freq;
  		if (freq > max_freq)
@@@ -190,22 -202,31 +197,46 @@@ static DEFINE_PER_CPU(struct cpufreq_fr
  /**
   * show_available_freqs - show available frequencies for the specified CPU
   */
 -static ssize_t show_available_freqs(struct cpufreq_policy *policy, char *buf,
 -				    bool show_boost)
 +static ssize_t show_available_freqs(struct cpufreq_policy *policy, char *buf)
  {
++<<<<<<< HEAD
 +	unsigned int i = 0;
 +	unsigned int cpu = policy->cpu;
 +	ssize_t count = 0;
 +	struct cpufreq_frequency_table *table;
++=======
+ 	ssize_t count = 0;
+ 	struct cpufreq_frequency_table *pos, *table = policy->freq_table;
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  
 -	if (!table)
 +	if (!per_cpu(cpufreq_show_table, cpu))
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	table = per_cpu(cpufreq_show_table, cpu);
 +
 +	for (i = 0; (table[i].frequency != CPUFREQ_TABLE_END); i++) {
 +		if (table[i].frequency == CPUFREQ_ENTRY_INVALID)
 +			continue;
 +		count += sprintf(&buf[count], "%d ", table[i].frequency);
++=======
+ 	cpufreq_for_each_valid_entry(pos, table) {
+ 		/*
+ 		 * show_boost = true and driver_data = BOOST freq
+ 		 * display BOOST freqs
+ 		 *
+ 		 * show_boost = false and driver_data = BOOST freq
+ 		 * show_boost = true and driver_data != BOOST freq
+ 		 * continue - do not display anything
+ 		 *
+ 		 * show_boost = false and driver_data != BOOST freq
+ 		 * display NON BOOST freqs
+ 		 */
+ 		if (show_boost ^ (pos->flags & CPUFREQ_BOOST_FREQ))
+ 			continue;
+ 
+ 		count += sprintf(&buf[count], "%d ", pos->frequency);
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  	}
  	count += sprintf(&buf[count], "\n");
  
diff --cc drivers/cpufreq/longhaul.c
index 51a0420c0c78,f4024d4d3534..000000000000
--- a/drivers/cpufreq/longhaul.c
+++ b/drivers/cpufreq/longhaul.c
@@@ -613,11 -613,10 +613,14 @@@ static void longhaul_setup_voltagescali
  			pos = (speed - min_vid_speed) / kHz_step + minvid.pos;
  		else
  			pos = minvid.pos;
++<<<<<<< HEAD
 +		longhaul_table[j].index |= mV_vrm_table[pos] << 8;
++=======
+ 		freq_pos->driver_data |= mV_vrm_table[pos] << 8;
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  		vid = vrm_mV_table[mV_vrm_table[pos]];
  		printk(KERN_INFO PFX "f: %d kHz, index: %d, vid: %d mV\n",
- 				speed, j, vid.mV);
- 		j++;
+ 			speed, (int)(freq_pos - longhaul_table), vid.mV);
  	}
  
  	can_scale_voltage = 1;
diff --cc drivers/cpufreq/powernow-k6.c
index a5b23da513dc,a133236a0013..000000000000
--- a/drivers/cpufreq/powernow-k6.c
+++ b/drivers/cpufreq/powernow-k6.c
@@@ -141,25 -157,64 +141,70 @@@ static int powernow_k6_target(struct cp
  	return 0;
  }
  
 +
  static int powernow_k6_cpu_init(struct cpufreq_policy *policy)
  {
+ 	struct cpufreq_frequency_table *pos;
  	unsigned int i, f;
 -	unsigned khz;
  
  	if (policy->cpu != 0)
  		return -ENODEV;
  
++<<<<<<< HEAD
 +	/* get frequencies */
 +	max_multiplier = powernow_k6_get_cpu_multiplier();
 +	busfreq = cpu_khz / max_multiplier;
++=======
+ 	max_multiplier = 0;
+ 	khz = cpu_khz;
+ 	for (i = 0; i < ARRAY_SIZE(usual_frequency_table); i++) {
+ 		if (khz >= usual_frequency_table[i].freq - FREQ_RANGE &&
+ 		    khz <= usual_frequency_table[i].freq + FREQ_RANGE) {
+ 			khz = usual_frequency_table[i].freq;
+ 			max_multiplier = usual_frequency_table[i].mult;
+ 			break;
+ 		}
+ 	}
+ 	if (param_max_multiplier) {
+ 		cpufreq_for_each_entry(pos, clock_ratio)
+ 			if (pos->driver_data == param_max_multiplier) {
+ 				max_multiplier = param_max_multiplier;
+ 				goto have_max_multiplier;
+ 			}
+ 		printk(KERN_ERR "powernow-k6: invalid max_multiplier parameter, valid parameters 20, 30, 35, 40, 45, 50, 55, 60\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (!max_multiplier) {
+ 		printk(KERN_WARNING "powernow-k6: unknown frequency %u, cannot determine current multiplier\n", khz);
+ 		printk(KERN_WARNING "powernow-k6: use module parameters max_multiplier and bus_frequency\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+ have_max_multiplier:
+ 	param_max_multiplier = max_multiplier;
+ 
+ 	if (param_busfreq) {
+ 		if (param_busfreq >= 50000 && param_busfreq <= 150000) {
+ 			busfreq = param_busfreq / 10;
+ 			goto have_busfreq;
+ 		}
+ 		printk(KERN_ERR "powernow-k6: invalid bus_frequency parameter, allowed range 50000 - 150000 kHz\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	busfreq = khz / max_multiplier;
+ have_busfreq:
+ 	param_busfreq = busfreq * 10;
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  
  	/* table init */
- 	for (i = 0; (clock_ratio[i].frequency != CPUFREQ_TABLE_END); i++) {
- 		f = clock_ratio[i].driver_data;
+ 	cpufreq_for_each_entry(pos, clock_ratio) {
+ 		f = pos->driver_data;
  		if (f > max_multiplier)
- 			clock_ratio[i].frequency = CPUFREQ_ENTRY_INVALID;
+ 			pos->frequency = CPUFREQ_ENTRY_INVALID;
  		else
- 			clock_ratio[i].frequency = busfreq * f;
+ 			pos->frequency = busfreq * f;
  	}
  
  	/* cpuinfo and default policy values */
diff --cc drivers/cpufreq/s3c2416-cpufreq.c
index 4f1881eee3f1,2fd53eaaec20..000000000000
--- a/drivers/cpufreq/s3c2416-cpufreq.c
+++ b/drivers/cpufreq/s3c2416-cpufreq.c
@@@ -307,12 -275,11 +307,15 @@@ static void __init s3c2416_cpufreq_cfg_
  		return;
  	}
  
- 	freq = s3c_freq->freq_table;
- 	while (count > 0 && freq->frequency != CPUFREQ_TABLE_END) {
- 		if (freq->frequency == CPUFREQ_ENTRY_INVALID)
- 			continue;
+ 	if (!count)
+ 		goto out;
  
++<<<<<<< HEAD
 +		dvfs = &s3c2416_dvfs_table[freq->index];
++=======
+ 	cpufreq_for_each_valid_entry(pos, s3c_freq->freq_table) {
+ 		dvfs = &s3c2416_dvfs_table[pos->driver_data];
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  		found = 0;
  
  		/* Check only the min-voltage, more is always ok on S3C2416 */
@@@ -459,35 -425,29 +461,35 @@@ static int __init s3c2416_cpufreq_drive
  	s3c_freq->regulator_latency = 0;
  #endif
  
- 	freq = s3c_freq->freq_table;
- 	while (freq->frequency != CPUFREQ_TABLE_END) {
+ 	cpufreq_for_each_entry(pos, s3c_freq->freq_table) {
  		/* special handling for dvs mode */
++<<<<<<< HEAD
 +		if (freq->index == 0) {
++=======
+ 		if (pos->driver_data == 0) {
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  			if (!s3c_freq->hclk) {
  				pr_debug("cpufreq: %dkHz unsupported as it would need unavailable dvs mode\n",
- 					 freq->frequency);
- 				freq->frequency = CPUFREQ_ENTRY_INVALID;
+ 					 pos->frequency);
+ 				pos->frequency = CPUFREQ_ENTRY_INVALID;
  			} else {
- 				freq++;
  				continue;
  			}
  		}
  
  		/* Check for frequencies we can generate */
  		rate = clk_round_rate(s3c_freq->armdiv,
- 				      freq->frequency * 1000);
+ 				      pos->frequency * 1000);
  		rate /= 1000;
- 		if (rate != freq->frequency) {
+ 		if (rate != pos->frequency) {
  			pr_debug("cpufreq: %dkHz unsupported by clock (clk_round_rate return %lu)\n",
- 				 freq->frequency, rate);
- 			freq->frequency = CPUFREQ_ENTRY_INVALID;
+ 				pos->frequency, rate);
+ 			pos->frequency = CPUFREQ_ENTRY_INVALID;
  		}
- 
- 		freq++;
  	}
  
 +	policy->cur = clk_get_rate(s3c_freq->armclk) / 1000;
 +
  	/* Datasheet says PLL stabalisation time must be at least 300us,
  	 * so but add some fudge. (reference in LOCKCON0 register description)
  	 */
diff --cc drivers/cpufreq/s3c64xx-cpufreq.c
index 27cacb524796,176e84cc3991..000000000000
--- a/drivers/cpufreq/s3c64xx-cpufreq.c
+++ b/drivers/cpufreq/s3c64xx-cpufreq.c
@@@ -157,12 -118,11 +157,15 @@@ static void __init s3c64xx_cpufreq_conf
  		pr_err("Unable to check supported voltages\n");
  	}
  
- 	freq = s3c64xx_freq_table;
- 	while (count > 0 && freq->frequency != CPUFREQ_TABLE_END) {
- 		if (freq->frequency == CPUFREQ_ENTRY_INVALID)
- 			continue;
+ 	if (!count)
+ 		goto out;
  
++<<<<<<< HEAD
 +		dvfs = &s3c64xx_dvfs_table[freq->index];
++=======
+ 	cpufreq_for_each_valid_entry(freq, s3c64xx_freq_table) {
+ 		dvfs = &s3c64xx_dvfs_table[freq->driver_data];
++>>>>>>> 041526f915a9 (cpufreq: Use cpufreq_for_each_* macros for frequency table iteration)
  		found = 0;
  
  		for (i = 0; i < count; i++) {
@@@ -233,14 -191,10 +234,12 @@@ static int s3c64xx_cpufreq_driver_init(
  
  		/* If we have no regulator then assume startup
  		 * frequency is the maximum we can support. */
 -		if (!vddarm && freq->frequency > clk_get_rate(policy->clk) / 1000)
 +		if (!vddarm && freq->frequency > s3c64xx_cpufreq_get_speed(0))
  			freq->frequency = CPUFREQ_ENTRY_INVALID;
- 
- 		freq++;
  	}
  
 +	policy->cur = clk_get_rate(armclk) / 1000;
 +
  	/* Datasheet says PLL stabalisation time (if we were to use
  	 * the PLLs, which we don't currently) is ~300us worst case,
  	 * but add some fudge.
diff --git a/drivers/cpufreq/acpi-cpufreq.c b/drivers/cpufreq/acpi-cpufreq.c
index 10095bf1ccaa..3f6b6c07785d 100644
--- a/drivers/cpufreq/acpi-cpufreq.c
+++ b/drivers/cpufreq/acpi-cpufreq.c
@@ -214,7 +214,7 @@ static unsigned extract_io(u32 value, struct acpi_cpufreq_data *data)
 
 static unsigned extract_msr(u32 msr, struct acpi_cpufreq_data *data)
 {
-	int i;
+	struct cpufreq_frequency_table *pos;
 	struct acpi_processor_performance *perf;
 
 	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD)
@@ -224,10 +224,9 @@ static unsigned extract_msr(u32 msr, struct acpi_cpufreq_data *data)
 
 	perf = data->acpi_data;
 
-	for (i = 0; data->freq_table[i].frequency != CPUFREQ_TABLE_END; i++) {
-		if (msr == perf->states[data->freq_table[i].driver_data].status)
-			return data->freq_table[i].frequency;
-	}
+	cpufreq_for_each_entry(pos, data->freq_table)
+		if (msr == perf->states[pos->driver_data].status)
+			return pos->frequency;
 	return data->freq_table[0].frequency;
 }
 
* Unmerged path drivers/cpufreq/arm_big_little.c
* Unmerged path drivers/cpufreq/cpufreq_stats.c
diff --git a/drivers/cpufreq/dbx500-cpufreq.c b/drivers/cpufreq/dbx500-cpufreq.c
index 8c005ac8b701..0d2608ec2e93 100644
--- a/drivers/cpufreq/dbx500-cpufreq.c
+++ b/drivers/cpufreq/dbx500-cpufreq.c
@@ -125,7 +125,7 @@ static struct cpufreq_driver dbx500_cpufreq_driver = {
 
 static int dbx500_cpufreq_probe(struct platform_device *pdev)
 {
-	int i = 0;
+	struct cpufreq_frequency_table *pos;
 
 	freq_table = dev_get_platdata(&pdev->dev);
 	if (!freq_table) {
@@ -140,10 +140,8 @@ static int dbx500_cpufreq_probe(struct platform_device *pdev)
 	}
 
 	pr_info("dbx500-cpufreq: Available frequencies:\n");
-	while (freq_table[i].frequency != CPUFREQ_TABLE_END) {
-		pr_info("  %d Mhz\n", freq_table[i].frequency/1000);
-		i++;
-	}
+	cpufreq_for_each_entry(pos, freq_table)
+		pr_info("  %d Mhz\n", pos->frequency / 1000);
 
 	return cpufreq_register_driver(&dbx500_cpufreq_driver);
 }
* Unmerged path drivers/cpufreq/elanfreq.c
diff --git a/drivers/cpufreq/exynos-cpufreq.c b/drivers/cpufreq/exynos-cpufreq.c
index 475b4f607f0d..c6fa1bb612de 100644
--- a/drivers/cpufreq/exynos-cpufreq.c
+++ b/drivers/cpufreq/exynos-cpufreq.c
@@ -45,17 +45,16 @@ static unsigned int exynos_getspeed(unsigned int cpu)
 static int exynos_cpufreq_get_index(unsigned int freq)
 {
 	struct cpufreq_frequency_table *freq_table = exynos_info->freq_table;
-	int index;
+	struct cpufreq_frequency_table *pos;
 
-	for (index = 0;
-		freq_table[index].frequency != CPUFREQ_TABLE_END; index++)
-		if (freq_table[index].frequency == freq)
+	cpufreq_for_each_entry(pos, freq_table)
+		if (pos->frequency == freq)
 			break;
 
-	if (freq_table[index].frequency == CPUFREQ_TABLE_END)
+	if (pos->frequency == CPUFREQ_TABLE_END)
 		return -EINVAL;
 
-	return index;
+	return pos - freq_table;
 }
 
 static int exynos_cpufreq_scale(unsigned int target_freq)
* Unmerged path drivers/cpufreq/exynos5440-cpufreq.c
* Unmerged path drivers/cpufreq/freq_table.c
* Unmerged path drivers/cpufreq/longhaul.c
diff --git a/drivers/cpufreq/pasemi-cpufreq.c b/drivers/cpufreq/pasemi-cpufreq.c
index b704da404067..bce124374f62 100644
--- a/drivers/cpufreq/pasemi-cpufreq.c
+++ b/drivers/cpufreq/pasemi-cpufreq.c
@@ -142,9 +142,10 @@ void restore_astate(int cpu)
 
 static int pas_cpufreq_cpu_init(struct cpufreq_policy *policy)
 {
+	struct cpufreq_frequency_table *pos;
 	const u32 *max_freqp;
 	u32 max_freq;
-	int i, cur_astate;
+	int cur_astate;
 	struct resource res;
 	struct device_node *cpu, *dn;
 	int err = -ENODEV;
@@ -203,10 +204,9 @@ static int pas_cpufreq_cpu_init(struct cpufreq_policy *policy)
 	pr_debug("initializing frequency table\n");
 
 	/* initialize frequency table */
-	for (i=0; pas_freqs[i].frequency!=CPUFREQ_TABLE_END; i++) {
-		pas_freqs[i].frequency =
-			get_astate_freq(pas_freqs[i].driver_data) * 100000;
-		pr_debug("%d: %d\n", i, pas_freqs[i].frequency);
+	cpufreq_for_each_entry(pos, pas_freqs) {
+		pos->frequency = get_astate_freq(pos->driver_data) * 100000;
+		pr_debug("%d: %d\n", (int)(pos - pas_freqs), pos->frequency);
 	}
 
 	policy->cpuinfo.transition_latency = get_gizmo_latency();
* Unmerged path drivers/cpufreq/powernow-k6.c
diff --git a/drivers/cpufreq/ppc_cbe_cpufreq.c b/drivers/cpufreq/ppc_cbe_cpufreq.c
index 5936f8d6f2cc..2ee928aaecb4 100644
--- a/drivers/cpufreq/ppc_cbe_cpufreq.c
+++ b/drivers/cpufreq/ppc_cbe_cpufreq.c
@@ -70,9 +70,10 @@ static int set_pmode(unsigned int cpu, unsigned int slow_mode)
 
 static int cbe_cpufreq_cpu_init(struct cpufreq_policy *policy)
 {
+	struct cpufreq_frequency_table *pos;
 	const u32 *max_freqp;
 	u32 max_freq;
-	int i, cur_pmode;
+	int cur_pmode;
 	struct device_node *cpu;
 
 	cpu = of_get_cpu_node(policy->cpu, NULL);
@@ -105,9 +106,9 @@ static int cbe_cpufreq_cpu_init(struct cpufreq_policy *policy)
 	pr_debug("initializing frequency table\n");
 
 	/* initialize frequency table */
-	for (i=0; cbe_freqs[i].frequency!=CPUFREQ_TABLE_END; i++) {
-		cbe_freqs[i].frequency = max_freq / cbe_freqs[i].driver_data;
-		pr_debug("%d: %d\n", i, cbe_freqs[i].frequency);
+	cpufreq_for_each_entry(pos, cbe_freqs) {
+		pos->frequency = max_freq / pos->driver_data;
+		pr_debug("%d: %d\n", (int)(pos - cbe_freqs), pos->frequency);
 	}
 
 	/* if DEBUG is enabled set_pmode() measures the latency
* Unmerged path drivers/cpufreq/s3c2416-cpufreq.c
* Unmerged path drivers/cpufreq/s3c64xx-cpufreq.c
