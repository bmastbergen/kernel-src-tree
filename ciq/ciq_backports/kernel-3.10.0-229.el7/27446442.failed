net/udp_offload: Use IS_ERR_OR_NULL

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [net] udp_offload: Use IS_ERR_OR_NULL (Jiri Benc) [1144571]
Rebuild_FUZZ: 93.94%
commit-author Himangi Saraogi <himangi774@gmail.com>
commit 27446442a810f29d0fa97356bbc11f45e7ecfa6e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/27446442.failed

This patch introduces the use of the macro IS_ERR_OR_NULL in place of
tests for NULL and IS_ERR.

The following Coccinelle semantic patch was used for making the change:

@@
expression e;
@@

- e == NULL || IS_ERR(e)
+ IS_ERR_OR_NULL(e)
 || ...

	Signed-off-by: Himangi Saraogi <himangi774@gmail.com>
	Acked-by: Julia Lawall <julia.lawall@lip6.fr>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 27446442a810f29d0fa97356bbc11f45e7ecfa6e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp_offload.c
diff --cc net/ipv4/udp_offload.c
index 1d2f12fcbc52,59035bc3008d..000000000000
--- a/net/ipv4/udp_offload.c
+++ b/net/ipv4/udp_offload.c
@@@ -47,6 -47,82 +47,85 @@@ static int udp4_ufo_send_check(struct s
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ struct sk_buff *skb_udp_tunnel_segment(struct sk_buff *skb,
+ 				       netdev_features_t features)
+ {
+ 	struct sk_buff *segs = ERR_PTR(-EINVAL);
+ 	u16 mac_offset = skb->mac_header;
+ 	int mac_len = skb->mac_len;
+ 	int tnl_hlen = skb_inner_mac_header(skb) - skb_transport_header(skb);
+ 	__be16 protocol = skb->protocol;
+ 	netdev_features_t enc_features;
+ 	int udp_offset, outer_hlen;
+ 	unsigned int oldlen;
+ 	bool need_csum;
+ 
+ 	oldlen = (u16)~skb->len;
+ 
+ 	if (unlikely(!pskb_may_pull(skb, tnl_hlen)))
+ 		goto out;
+ 
+ 	skb->encapsulation = 0;
+ 	__skb_pull(skb, tnl_hlen);
+ 	skb_reset_mac_header(skb);
+ 	skb_set_network_header(skb, skb_inner_network_offset(skb));
+ 	skb->mac_len = skb_inner_network_offset(skb);
+ 	skb->protocol = htons(ETH_P_TEB);
+ 
+ 	need_csum = !!(skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL_CSUM);
+ 	if (need_csum)
+ 		skb->encap_hdr_csum = 1;
+ 
+ 	/* segment inner packet. */
+ 	enc_features = skb->dev->hw_enc_features & netif_skb_features(skb);
+ 	segs = skb_mac_gso_segment(skb, enc_features);
+ 	if (IS_ERR_OR_NULL(segs)) {
+ 		skb_gso_error_unwind(skb, protocol, tnl_hlen, mac_offset,
+ 				     mac_len);
+ 		goto out;
+ 	}
+ 
+ 	outer_hlen = skb_tnl_header_len(skb);
+ 	udp_offset = outer_hlen - tnl_hlen;
+ 	skb = segs;
+ 	do {
+ 		struct udphdr *uh;
+ 		int len;
+ 
+ 		skb_reset_inner_headers(skb);
+ 		skb->encapsulation = 1;
+ 
+ 		skb->mac_len = mac_len;
+ 
+ 		skb_push(skb, outer_hlen);
+ 		skb_reset_mac_header(skb);
+ 		skb_set_network_header(skb, mac_len);
+ 		skb_set_transport_header(skb, udp_offset);
+ 		len = skb->len - udp_offset;
+ 		uh = udp_hdr(skb);
+ 		uh->len = htons(len);
+ 
+ 		if (need_csum) {
+ 			__be32 delta = htonl(oldlen + len);
+ 
+ 			uh->check = ~csum_fold((__force __wsum)
+ 					       ((__force u32)uh->check +
+ 						(__force u32)delta));
+ 			uh->check = gso_make_checksum(skb, ~uh->check);
+ 
+ 			if (uh->check == 0)
+ 				uh->check = CSUM_MANGLED_0;
+ 		}
+ 
+ 		skb->protocol = protocol;
+ 	} while ((skb = skb->next));
+ out:
+ 	return segs;
+ }
+ 
++>>>>>>> 27446442a810 (net/udp_offload: Use IS_ERR_OR_NULL)
  static struct sk_buff *udp4_ufo_fragment(struct sk_buff *skb,
  					 netdev_features_t features)
  {
* Unmerged path net/ipv4/udp_offload.c
