resource: Add resource_contains()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Bjorn Helgaas <bhelgaas@google.com>
commit 5edb93b89f6cc3089ee283656555e7a9ad36a8a0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5edb93b8.failed

We have two identical copies of resource_contains() already, and more
places that could use it.  This moves it to ioport.h where it can be
shared.

resource_contains(struct resource *r1, struct resource *r2) returns true
iff r1 and r2 are the same type (most callers already checked this
separately) and the r1 address range completely contains r2.

In addition, the new resource_contains() checks that both r1 and r2 have
addresses assigned to them.  If a resource is IORESOURCE_UNSET, it doesn't
have a valid address and can't contain or be contained by another resource.
Some callers already check this or for res->start.

No functional change.

	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit 5edb93b89f6cc3089ee283656555e7a9ad36a8a0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/host-bridge.c
diff --cc drivers/pci/host-bridge.c
index a68dc613a5be,47aaf22d814e..000000000000
--- a/drivers/pci/host-bridge.c
+++ b/drivers/pci/host-bridge.c
@@@ -35,15 -32,10 +35,19 @@@ void pci_set_host_bridge_release(struc
  	bridge->release_data = release_data;
  }
  
++<<<<<<< HEAD
 +static bool resource_contains(struct resource *res1, struct resource *res2)
 +{
 +	return res1->start <= res2->start && res1->end >= res2->end;
 +}
 +
 +void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
++=======
+ void pcibios_resource_to_bus(struct pci_bus *bus, struct pci_bus_region *region,
++>>>>>>> 5edb93b89f6c (resource: Add resource_contains())
  			     struct resource *res)
  {
 -	struct pci_host_bridge *bridge = find_pci_host_bridge(bus);
 +	struct pci_host_bridge *bridge = find_pci_host_bridge(dev);
  	struct pci_host_bridge_window *window;
  	resource_size_t offset = 0;
  
* Unmerged path drivers/pci/host-bridge.c
diff --git a/include/linux/ioport.h b/include/linux/ioport.h
index 89b7c24a36e9..9fcaac8bc4f6 100644
--- a/include/linux/ioport.h
+++ b/include/linux/ioport.h
@@ -169,6 +169,16 @@ static inline unsigned long resource_type(const struct resource *res)
 {
 	return res->flags & IORESOURCE_TYPE_BITS;
 }
+/* True iff r1 completely contains r2 */
+static inline bool resource_contains(struct resource *r1, struct resource *r2)
+{
+	if (resource_type(r1) != resource_type(r2))
+		return false;
+	if (r1->flags & IORESOURCE_UNSET || r2->flags & IORESOURCE_UNSET)
+		return false;
+	return r1->start <= r2->start && r1->end >= r2->end;
+}
+
 
 /* Convenience shorthand with allocation */
 #define request_region(start,n,name)		__request_region(&ioport_resource, (start), (n), (name), 0)
diff --git a/kernel/resource.c b/kernel/resource.c
index 77bf11a86c7d..a79cc6f17de8 100644
--- a/kernel/resource.c
+++ b/kernel/resource.c
@@ -432,11 +432,6 @@ static void resource_clip(struct resource *res, resource_size_t min,
 		res->end = max;
 }
 
-static bool resource_contains(struct resource *res1, struct resource *res2)
-{
-	return res1->start <= res2->start && res1->end >= res2->end;
-}
-
 /*
  * Find empty slot in the resource tree with the given range and
  * alignment constraints
@@ -472,10 +467,11 @@ static int __find_resource(struct resource *root, struct resource *old,
 		arch_remove_reservations(&tmp);
 
 		/* Check for overflow after ALIGN() */
-		avail = *new;
 		avail.start = ALIGN(tmp.start, constraint->align);
 		avail.end = tmp.end;
+		avail.flags = new->flags & ~IORESOURCE_UNSET;
 		if (avail.start >= tmp.start) {
+			alloc.flags = avail.flags;
 			alloc.start = constraint->alignf(constraint->alignf_data, &avail,
 					size, constraint->align);
 			alloc.end = alloc.start + size - 1;
