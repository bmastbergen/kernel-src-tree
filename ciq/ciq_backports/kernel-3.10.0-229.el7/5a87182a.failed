cpufreq: suspend governors on system suspend/hibernate

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [cpufreq] suspend governors on system suspend/hibernate (Prarit Bhargava) [1134369]
Rebuild_FUZZ: 90.91%
commit-author Viresh Kumar <viresh.kumar@linaro.org>
commit 5a87182aa21d6d5d306840feab9321818dd3e2a3
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/5a87182a.failed

This patch adds cpufreq suspend/resume calls to dpm_{suspend|resume}_noirq()
for handling suspend/resume of cpufreq governors.

Lan Tianyu (Intel) & Jinhyuk Choi (Broadcom) found anr issue where
tunables configuration for clusters/sockets with non-boot CPUs was
getting lost after suspend/resume, as we were notifying governors
with CPUFREQ_GOV_POLICY_EXIT on removal of the last cpu for that
policy and so deallocating memory for tunables. This is fixed by
this patch as we don't allow any operation on governors after
device suspend and before device resume now.

Reported-and-tested-by: Lan Tianyu <tianyu.lan@intel.com>
	Reported-by: Jinhyuk Choi <jinchoi@broadcom.com>
	Signed-off-by: Viresh Kumar <viresh.kumar@linaro.org>
[rjw: Changelog, minor cleanups]
	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
(cherry picked from commit 5a87182aa21d6d5d306840feab9321818dd3e2a3)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/power/main.c
#	drivers/cpufreq/cpufreq.c
#	include/linux/cpufreq.h
diff --cc drivers/base/power/main.c
index 5a9b6569dd74,10c3510d72a9..000000000000
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@@ -28,6 -28,8 +28,11 @@@
  #include <linux/sched.h>
  #include <linux/async.h>
  #include <linux/suspend.h>
++<<<<<<< HEAD
++=======
+ #include <trace/events/power.h>
+ #include <linux/cpufreq.h>
++>>>>>>> 5a87182aa21d (cpufreq: suspend governors on system suspend/hibernate)
  #include <linux/cpuidle.h>
  #include "../base.h"
  #include "power.h"
diff --cc drivers/cpufreq/cpufreq.c
index c8bc717e8458,606224a8abc2..000000000000
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@@ -45,50 -48,14 +46,59 @@@ static DEFINE_MUTEX(cpufreq_governor_lo
  static DEFINE_PER_CPU(char[CPUFREQ_NAME_LEN], cpufreq_cpu_governor);
  #endif
  
++<<<<<<< HEAD
 +/*
 + * cpu_policy_rwsem is a per CPU reader-writer semaphore designed to cure
 + * all cpufreq/hotplug/workqueue/etc related lock issues.
 + *
 + * The rules for this semaphore:
 + * - Any routine that wants to read from the policy structure will
 + *   do a down_read on this semaphore.
 + * - Any routine that will write to the policy structure and/or may take away
 + *   the policy altogether (eg. CPU hotplug), will hold this lock in write
 + *   mode before doing so.
 + *
 + * Additional rules:
 + * - Governor routines that can be called in cpufreq hotplug path should not
 + *   take this sem as top level hotplug notifier handler takes this.
 + * - Lock should not be held across
 + *     __cpufreq_governor(data, CPUFREQ_GOV_STOP);
 + */
 +static DEFINE_PER_CPU(int, cpufreq_policy_cpu);
 +static DEFINE_PER_CPU(struct rw_semaphore, cpu_policy_rwsem);
 +
 +#define lock_policy_rwsem(mode, cpu)					\
 +static int lock_policy_rwsem_##mode(int cpu)				\
 +{									\
 +	int policy_cpu = per_cpu(cpufreq_policy_cpu, cpu);		\
 +	BUG_ON(policy_cpu == -1);					\
 +	down_##mode(&per_cpu(cpu_policy_rwsem, policy_cpu));		\
 +									\
 +	return 0;							\
++=======
+ /* Flag to suspend/resume CPUFreq governors */
+ static bool cpufreq_suspended;
+ 
+ static inline bool has_target(void)
+ {
+ 	return cpufreq_driver->target_index || cpufreq_driver->target;
++>>>>>>> 5a87182aa21d (cpufreq: suspend governors on system suspend/hibernate)
 +}
 +
 +lock_policy_rwsem(read, cpu);
 +lock_policy_rwsem(write, cpu);
 +
 +#define unlock_policy_rwsem(mode, cpu)					\
 +static void unlock_policy_rwsem_##mode(int cpu)				\
 +{									\
 +	int policy_cpu = per_cpu(cpufreq_policy_cpu, cpu);		\
 +	BUG_ON(policy_cpu == -1);					\
 +	up_##mode(&per_cpu(cpu_policy_rwsem, policy_cpu));		\
  }
  
 +unlock_policy_rwsem(read, cpu);
 +unlock_policy_rwsem(write, cpu);
 +
  /*
   * rwsem to guarantee that cpufreq driver module doesn't unload during critical
   * sections
diff --cc include/linux/cpufreq.h
index 4d87da0ff71a,91716658e9a1..000000000000
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@@ -270,87 -247,69 +270,121 @@@ struct cpufreq_driver 
  int cpufreq_register_driver(struct cpufreq_driver *driver_data);
  int cpufreq_unregister_driver(struct cpufreq_driver *driver_data);
  
 +void cpufreq_notify_transition(struct cpufreq_policy *policy,
 +		struct cpufreq_freqs *freqs, unsigned int state);
 +
 +static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
 +		unsigned int min, unsigned int max)
 +{
 +	if (policy->min < min)
 +		policy->min = min;
 +	if (policy->max < min)
 +		policy->max = min;
 +	if (policy->min > max)
 +		policy->min = max;
 +	if (policy->max > max)
 +		policy->max = max;
 +	if (policy->min > policy->max)
 +		policy->min = policy->max;
 +	return;
 +}
 +
 +static inline void
 +cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
 +{
 +	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
 +			policy->cpuinfo.max_freq);
 +}
 +
 +
 +struct freq_attr {
 +	struct attribute attr;
 +	ssize_t (*show)(struct cpufreq_policy *, char *);
 +	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t count);
 +};
 +
 +#define cpufreq_freq_attr_ro(_name)		\
 +static struct freq_attr _name =			\
 +__ATTR(_name, 0444, show_##_name, NULL)
 +
 +#define cpufreq_freq_attr_ro_perm(_name, _perm)	\
 +static struct freq_attr _name =			\
 +__ATTR(_name, _perm, show_##_name, NULL)
 +
 +#define cpufreq_freq_attr_rw(_name)		\
 +static struct freq_attr _name =			\
 +__ATTR(_name, 0644, show_##_name, store_##_name)
 +
 +struct global_attr {
 +	struct attribute attr;
 +	ssize_t (*show)(struct kobject *kobj,
 +			struct attribute *attr, char *buf);
 +	ssize_t (*store)(struct kobject *a, struct attribute *b,
 +			 const char *c, size_t count);
 +};
 +
 +#define define_one_global_ro(_name)		\
 +static struct global_attr _name =		\
 +__ATTR(_name, 0444, show_##_name, NULL)
 +
 +#define define_one_global_rw(_name)		\
 +static struct global_attr _name =		\
 +__ATTR(_name, 0644, show_##_name, store_##_name)
 +
 +struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu);
 +void cpufreq_cpu_put(struct cpufreq_policy *data);
  const char *cpufreq_get_current_driver(void);
  
++<<<<<<< HEAD
++=======
+ static inline void cpufreq_verify_within_limits(struct cpufreq_policy *policy,
+ 		unsigned int min, unsigned int max)
+ {
+ 	if (policy->min < min)
+ 		policy->min = min;
+ 	if (policy->max < min)
+ 		policy->max = min;
+ 	if (policy->min > max)
+ 		policy->min = max;
+ 	if (policy->max > max)
+ 		policy->max = max;
+ 	if (policy->min > policy->max)
+ 		policy->min = policy->max;
+ 	return;
+ }
+ 
+ static inline void
+ cpufreq_verify_within_cpu_limits(struct cpufreq_policy *policy)
+ {
+ 	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
+ 			policy->cpuinfo.max_freq);
+ }
+ 
+ #ifdef CONFIG_CPU_FREQ
+ void cpufreq_suspend(void);
+ void cpufreq_resume(void);
+ #else
+ static inline void cpufreq_suspend(void) {}
+ static inline void cpufreq_resume(void) {}
+ #endif
+ 
++>>>>>>> 5a87182aa21d (cpufreq: suspend governors on system suspend/hibernate)
  /*********************************************************************
 - *                     CPUFREQ NOTIFIER INTERFACE                    *
 + *                        CPUFREQ 2.6. INTERFACE                     *
   *********************************************************************/
 -
 -#define CPUFREQ_TRANSITION_NOTIFIER	(0)
 -#define CPUFREQ_POLICY_NOTIFIER		(1)
 -
 -/* Transition notifiers */
 -#define CPUFREQ_PRECHANGE		(0)
 -#define CPUFREQ_POSTCHANGE		(1)
 -#define CPUFREQ_RESUMECHANGE		(8)
 -#define CPUFREQ_SUSPENDCHANGE		(9)
 -
 -/* Policy Notifiers  */
 -#define CPUFREQ_ADJUST			(0)
 -#define CPUFREQ_INCOMPATIBLE		(1)
 -#define CPUFREQ_NOTIFY			(2)
 -#define CPUFREQ_START			(3)
 -#define CPUFREQ_UPDATE_POLICY_CPU	(4)
 +u64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy);
 +int cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu);
 +int cpufreq_update_policy(unsigned int cpu);
 +bool have_governor_per_policy(void);
 +struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy);
  
  #ifdef CONFIG_CPU_FREQ
 -int cpufreq_register_notifier(struct notifier_block *nb, unsigned int list);
 -int cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list);
 -
 -void cpufreq_notify_transition(struct cpufreq_policy *policy,
 -		struct cpufreq_freqs *freqs, unsigned int state);
 -
 -#else /* CONFIG_CPU_FREQ */
 -static inline int cpufreq_register_notifier(struct notifier_block *nb,
 -						unsigned int list)
 +/*
 + * query the current CPU frequency (in kHz). If zero, cpufreq couldn't detect it
 + */
 +unsigned int cpufreq_get(unsigned int cpu);
 +#else
 +static inline unsigned int cpufreq_get(unsigned int cpu)
  {
  	return 0;
  }
* Unmerged path drivers/base/power/main.c
* Unmerged path drivers/cpufreq/cpufreq.c
* Unmerged path include/linux/cpufreq.h
