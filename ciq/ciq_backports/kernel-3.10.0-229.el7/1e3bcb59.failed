ACPI / hotplug: Rework deferred execution of acpi_device_hotplug()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [acpi] hotplug: Rework deferred execution of acpi_device_hotplug() (Prarit Bhargava) [1141846]
Rebuild_FUZZ: 94.40%
commit-author Rafael J. Wysocki <rafael.j.wysocki@intel.com>
commit 1e3bcb596c6b1cf6db93f8f506e2de260e771bad
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/1e3bcb59.failed

Since the only function executed by acpi_hotplug_execute() is
acpi_device_hotplug() and it only is called by the ACPI core,
simplify its definition so that it only takes two arguments, the
ACPI device object pointer and event code, rename it to
acpi_hotplug_schedule() and move its header from acpi_bus.h to
the ACPI core's internal header file internal.h.  Modify the
definition of acpi_device_hotplug() so that its first argument is
an ACPI device object pointer and modify the definition of
struct acpi_hp_work accordingly.

	Signed-off-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
	Acked-by: Toshi Kani <toshi.kani@hp.com>
(cherry picked from commit 1e3bcb596c6b1cf6db93f8f506e2de260e771bad)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/acpi/bus.c
#	drivers/acpi/internal.h
#	drivers/acpi/osl.c
#	drivers/acpi/scan.c
#	include/acpi/acpi_bus.h
diff --cc drivers/acpi/bus.c
index f7cd8718b651,afe6f9a919c1..000000000000
--- a/drivers/acpi/bus.c
+++ b/drivers/acpi/bus.c
@@@ -474,19 -382,35 +474,44 @@@ static void acpi_bus_notify(acpi_handl
  		break;
  
  	default:
++<<<<<<< HEAD
 +		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
 +				  "Received unknown/unsupported notification [%08x]\n",
 +				  type));
++=======
+ 		acpi_handle_warn(handle, "Unsupported event type 0x%x\n", type);
+ 		ost_code = ACPI_OST_SC_UNRECOGNIZED_NOTIFY;
+ 		goto err;
+ 	}
+ 
+ 	adev = acpi_bus_get_acpi_device(handle);
+ 	if (!adev)
+ 		goto err;
+ 
+ 	driver = adev->driver;
+ 	if (driver && driver->ops.notify &&
+ 	    (driver->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS))
+ 		driver->ops.notify(adev, type);
+ 
+ 	switch (type) {
+ 	case ACPI_NOTIFY_BUS_CHECK:
+ 	case ACPI_NOTIFY_DEVICE_CHECK:
+ 	case ACPI_NOTIFY_EJECT_REQUEST:
+ 		status = acpi_hotplug_schedule(adev, type);
+ 		if (ACPI_SUCCESS(status))
+ 			return;
+ 	default:
++>>>>>>> 1e3bcb596c6b (ACPI / hotplug: Rework deferred execution of acpi_device_hotplug())
  		break;
  	}
 -	acpi_bus_put_acpi_device(adev);
 -	return;
  
 - err:
 -	acpi_evaluate_hotplug_ost(handle, type, ost_code, NULL);
 +	acpi_bus_get_device(handle, &device);
 +	if (device) {
 +		driver = device->driver;
 +		if (driver && driver->ops.notify &&
 +		    (driver->flags & ACPI_DRIVER_ALL_NOTIFY_EVENTS))
 +			driver->ops.notify(device, type);
 +	}
  }
  
  /* --------------------------------------------------------------------------
diff --cc drivers/acpi/internal.h
index f54dd71472f9,957391306cbf..000000000000
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@@ -73,6 -78,11 +73,14 @@@ void acpi_lpss_init(void)
  static inline void acpi_lpss_init(void) {}
  #endif
  
++<<<<<<< HEAD
++=======
+ acpi_status acpi_hotplug_schedule(struct acpi_device *adev, u32 src);
+ bool acpi_queue_hotplug_work(struct work_struct *work);
+ void acpi_device_hotplug(struct acpi_device *adev, u32 src);
+ bool acpi_scan_is_offline(struct acpi_device *adev, bool uevent);
+ 
++>>>>>>> 1e3bcb596c6b (ACPI / hotplug: Rework deferred execution of acpi_device_hotplug())
  /* --------------------------------------------------------------------------
                       Device Node Initialization / Removal
     -------------------------------------------------------------------------- */
diff --cc drivers/acpi/osl.c
index 0a421e1e4e8d,afb4be566940..000000000000
--- a/drivers/acpi/osl.c
+++ b/drivers/acpi/osl.c
@@@ -1172,7 -1166,53 +1172,57 @@@ void acpi_os_wait_events_complete(void
  	flush_workqueue(kacpi_notify_wq);
  }
  
++<<<<<<< HEAD
 +EXPORT_SYMBOL(acpi_os_wait_events_complete);
++=======
+ struct acpi_hp_work {
+ 	struct work_struct work;
+ 	struct acpi_device *adev;
+ 	u32 src;
+ };
+ 
+ static void acpi_hotplug_work_fn(struct work_struct *work)
+ {
+ 	struct acpi_hp_work *hpw = container_of(work, struct acpi_hp_work, work);
+ 
+ 	acpi_os_wait_events_complete();
+ 	acpi_device_hotplug(hpw->adev, hpw->src);
+ 	kfree(hpw);
+ }
+ 
+ acpi_status acpi_hotplug_schedule(struct acpi_device *adev, u32 src)
+ {
+ 	struct acpi_hp_work *hpw;
+ 
+ 	ACPI_DEBUG_PRINT((ACPI_DB_EXEC,
+ 		  "Scheduling hotplug event (%p, %u) for deferred execution.\n",
+ 		  adev, src));
+ 
+ 	hpw = kmalloc(sizeof(*hpw), GFP_KERNEL);
+ 	if (!hpw)
+ 		return AE_NO_MEMORY;
+ 
+ 	INIT_WORK(&hpw->work, acpi_hotplug_work_fn);
+ 	hpw->adev = adev;
+ 	hpw->src = src;
+ 	/*
+ 	 * We can't run hotplug code in kacpid_wq/kacpid_notify_wq etc., because
+ 	 * the hotplug code may call driver .remove() functions, which may
+ 	 * invoke flush_scheduled_work()/acpi_os_wait_events_complete() to flush
+ 	 * these workqueues.
+ 	 */
+ 	if (!queue_work(kacpi_hotplug_wq, &hpw->work)) {
+ 		kfree(hpw);
+ 		return AE_ERROR;
+ 	}
+ 	return AE_OK;
+ }
+ 
+ bool acpi_queue_hotplug_work(struct work_struct *work)
+ {
+ 	return queue_work(kacpi_hotplug_wq, work);
+ }
++>>>>>>> 1e3bcb596c6b (ACPI / hotplug: Rework deferred execution of acpi_device_hotplug())
  
  acpi_status
  acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)
diff --cc drivers/acpi/scan.c
index b30a50799f84,eb7a1ff224e7..000000000000
--- a/drivers/acpi/scan.c
+++ b/drivers/acpi/scan.c
@@@ -285,11 -391,100 +285,109 @@@ static int acpi_scan_hot_remove(struct 
  	return 0;
  }
  
++<<<<<<< HEAD
 +void acpi_bus_device_eject(struct acpi_device *device, u32 ost_src)
++=======
+ static int acpi_scan_device_not_present(struct acpi_device *adev)
+ {
+ 	if (!acpi_device_enumerated(adev)) {
+ 		dev_warn(&adev->dev, "Still not present\n");
+ 		return -EALREADY;
+ 	}
+ 	acpi_bus_trim(adev);
+ 	return 0;
+ }
+ 
+ static int acpi_scan_device_check(struct acpi_device *adev)
+ {
+ 	int error;
+ 
+ 	acpi_bus_get_status(adev);
+ 	if (adev->status.present || adev->status.functional) {
+ 		/*
+ 		 * This function is only called for device objects for which
+ 		 * matching scan handlers exist.  The only situation in which
+ 		 * the scan handler is not attached to this device object yet
+ 		 * is when the device has just appeared (either it wasn't
+ 		 * present at all before or it was removed and then added
+ 		 * again).
+ 		 */
+ 		if (adev->handler) {
+ 			dev_warn(&adev->dev, "Already enumerated\n");
+ 			return -EALREADY;
+ 		}
+ 		error = acpi_bus_scan(adev->handle);
+ 		if (error) {
+ 			dev_warn(&adev->dev, "Namespace scan failure\n");
+ 			return error;
+ 		}
+ 		if (!adev->handler) {
+ 			dev_warn(&adev->dev, "Enumeration failure\n");
+ 			error = -ENODEV;
+ 		}
+ 	} else {
+ 		error = acpi_scan_device_not_present(adev);
+ 	}
+ 	return error;
+ }
+ 
+ static int acpi_scan_bus_check(struct acpi_device *adev)
+ {
+ 	struct acpi_scan_handler *handler = adev->handler;
+ 	struct acpi_device *child;
+ 	int error;
+ 
+ 	acpi_bus_get_status(adev);
+ 	if (!(adev->status.present || adev->status.functional)) {
+ 		acpi_scan_device_not_present(adev);
+ 		return 0;
+ 	}
+ 	if (handler && handler->hotplug.scan_dependent)
+ 		return handler->hotplug.scan_dependent(adev);
+ 
+ 	error = acpi_bus_scan(adev->handle);
+ 	if (error) {
+ 		dev_warn(&adev->dev, "Namespace scan failure\n");
+ 		return error;
+ 	}
+ 	list_for_each_entry(child, &adev->children, node) {
+ 		error = acpi_scan_bus_check(child);
+ 		if (error)
+ 			return error;
+ 	}
+ 	return 0;
+ }
+ 
+ static int acpi_generic_hotplug_event(struct acpi_device *adev, u32 type)
+ {
+ 	switch (type) {
+ 	case ACPI_NOTIFY_BUS_CHECK:
+ 		return acpi_scan_bus_check(adev);
+ 	case ACPI_NOTIFY_DEVICE_CHECK:
+ 		return acpi_scan_device_check(adev);
+ 	case ACPI_NOTIFY_EJECT_REQUEST:
+ 	case ACPI_OST_EC_OSPM_EJECT:
+ 		if (adev->handler && !adev->handler->hotplug.enabled) {
+ 			dev_info(&adev->dev, "Eject disabled\n");
+ 			return -EPERM;
+ 		}
+ 		acpi_evaluate_hotplug_ost(adev->handle, ACPI_NOTIFY_EJECT_REQUEST,
+ 					  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
+ 		return acpi_scan_hot_remove(adev);
+ 	}
+ 	return -EINVAL;
+ }
+ 
+ void acpi_device_hotplug(struct acpi_device *adev, u32 src)
++>>>>>>> 1e3bcb596c6b (ACPI / hotplug: Rework deferred execution of acpi_device_hotplug())
  {
 +	acpi_handle handle = device->handle;
  	u32 ost_code = ACPI_OST_SC_NON_SPECIFIC_FAILURE;
++<<<<<<< HEAD
 +	int error;
++=======
+ 	int error = -ENODEV;
++>>>>>>> 1e3bcb596c6b (ACPI / hotplug: Rework deferred execution of acpi_device_hotplug())
  
  	lock_device_hotplug();
  	mutex_lock(&acpi_scan_lock);
@@@ -500,10 -577,8 +598,14 @@@ acpi_eject_store(struct device *d, stru
  	if (ACPI_FAILURE(status) || !acpi_device->flags.ejectable)
  		return -ENODEV;
  
 +	acpi_evaluate_hotplug_ost(acpi_device->handle, ACPI_OST_EC_OSPM_EJECT,
 +				  ACPI_OST_SC_EJECT_IN_PROGRESS, NULL);
  	get_device(&acpi_device->dev);
++<<<<<<< HEAD
 +	status = acpi_os_hotplug_execute(acpi_eject_store_work, acpi_device);
++=======
+ 	status = acpi_hotplug_schedule(acpi_device, ACPI_OST_EC_OSPM_EJECT);
++>>>>>>> 1e3bcb596c6b (ACPI / hotplug: Rework deferred execution of acpi_device_hotplug())
  	if (ACPI_SUCCESS(status))
  		return count;
  
diff --cc include/acpi/acpi_bus.h
index 717f4adcfbd4,660f5056a37f..000000000000
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@@ -406,6 -450,10 +406,13 @@@ int acpi_match_device_ids(struct acpi_d
  int acpi_create_dir(struct acpi_device *);
  void acpi_remove_dir(struct acpi_device *);
  
++<<<<<<< HEAD
++=======
+ static inline bool acpi_device_enumerated(struct acpi_device *adev)
+ {
+ 	return adev && adev->flags.initialized && adev->flags.visited;
+ }
++>>>>>>> 1e3bcb596c6b (ACPI / hotplug: Rework deferred execution of acpi_device_hotplug())
  
  /**
   * module_acpi_driver(acpi_driver) - Helper macro for registering an ACPI driver
* Unmerged path drivers/acpi/bus.c
* Unmerged path drivers/acpi/internal.h
* Unmerged path drivers/acpi/osl.c
* Unmerged path drivers/acpi/scan.c
* Unmerged path include/acpi/acpi_bus.h
