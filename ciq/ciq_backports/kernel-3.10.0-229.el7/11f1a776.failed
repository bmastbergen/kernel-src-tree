iommu/vt-d: Check for NULL pointer in dmar_acpi_dev_scope_init()

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [iommu] vt-d: Check for NULL pointer in dmar_acpi_dev_scope_init() (Myron Stowe) [1129880 1087643]
Rebuild_FUZZ: 95.08%
commit-author Joerg Roedel <joro@8bytes.org>
commit 11f1a7768cb9179b1f1ce6b8027df7531e0704e7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/11f1a776.failed

When ir_dev_scope_init() is called via a rootfs initcall it
will check for irq_remapping_enabled before it calls
(indirectly) into dmar_acpi_dev_scope_init() which uses the
dmar_tbl pointer without any checks.

The AMD IOMMU driver also sets the irq_remapping_enabled
flag which causes the dmar_acpi_dev_scope_init() function to
be called on systems with AMD IOMMU hardware too, causing a
boot-time kernel crash.

	Signed-off-by: Joerg Roedel <joro@8bytes.org>
(cherry picked from commit 11f1a7768cb9179b1f1ce6b8027df7531e0704e7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/dmar.c
diff --cc drivers/iommu/dmar.c
index e2ae85c4b46e,e531a2b07207..000000000000
--- a/drivers/iommu/dmar.c
+++ b/drivers/iommu/dmar.c
@@@ -457,10 -603,91 +457,92 @@@ dmar_find_matched_drhd_unit(struct pci_
  
  		if (dmar_pci_device_match(dmaru->devices,
  					  dmaru->devices_cnt, dev))
 -			goto out;
 +			return dmaru;
  	}
 -	dmaru = NULL;
 -out:
 -	rcu_read_unlock();
  
++<<<<<<< HEAD
 +	return NULL;
++=======
+ 	return dmaru;
+ }
+ 
+ static void __init dmar_acpi_insert_dev_scope(u8 device_number,
+ 					      struct acpi_device *adev)
+ {
+ 	struct dmar_drhd_unit *dmaru;
+ 	struct acpi_dmar_hardware_unit *drhd;
+ 	struct acpi_dmar_device_scope *scope;
+ 	struct device *tmp;
+ 	int i;
+ 	struct acpi_dmar_pci_path *path;
+ 
+ 	for_each_drhd_unit(dmaru) {
+ 		drhd = container_of(dmaru->hdr,
+ 				    struct acpi_dmar_hardware_unit,
+ 				    header);
+ 
+ 		for (scope = (void *)(drhd + 1);
+ 		     (unsigned long)scope < ((unsigned long)drhd) + drhd->header.length;
+ 		     scope = ((void *)scope) + scope->length) {
+ 			if (scope->entry_type != ACPI_DMAR_SCOPE_TYPE_ACPI)
+ 				continue;
+ 			if (scope->enumeration_id != device_number)
+ 				continue;
+ 
+ 			path = (void *)(scope + 1);
+ 			pr_info("ACPI device \"%s\" under DMAR at %llx as %02x:%02x.%d\n",
+ 				dev_name(&adev->dev), dmaru->reg_base_addr,
+ 				scope->bus, path->device, path->function);
+ 			for_each_dev_scope(dmaru->devices, dmaru->devices_cnt, i, tmp)
+ 				if (tmp == NULL) {
+ 					dmaru->devices[i].bus = scope->bus;
+ 					dmaru->devices[i].devfn = PCI_DEVFN(path->device,
+ 									    path->function);
+ 					rcu_assign_pointer(dmaru->devices[i].dev,
+ 							   get_device(&adev->dev));
+ 					return;
+ 				}
+ 			BUG_ON(i >= dmaru->devices_cnt);
+ 		}
+ 	}
+ 	pr_warn("No IOMMU scope found for ANDD enumeration ID %d (%s)\n",
+ 		device_number, dev_name(&adev->dev));
+ }
+ 
+ static int __init dmar_acpi_dev_scope_init(void)
+ {
+ 	struct acpi_dmar_andd *andd;
+ 
+ 	if (dmar_tbl == NULL)
+ 		return -ENODEV;
+ 
+ 	andd = (void *)dmar_tbl + sizeof(struct acpi_table_dmar);
+ 
+ 	while (((unsigned long)andd) <
+ 	       ((unsigned long)dmar_tbl) + dmar_tbl->length) {
+ 		if (andd->header.type == ACPI_DMAR_TYPE_ANDD) {
+ 			acpi_handle h;
+ 			struct acpi_device *adev;
+ 
+ 			if (!ACPI_SUCCESS(acpi_get_handle(ACPI_ROOT_OBJECT,
+ 							  andd->object_name,
+ 							  &h))) {
+ 				pr_err("Failed to find handle for ACPI object %s\n",
+ 				       andd->object_name);
+ 				continue;
+ 			}
+ 			acpi_bus_get_device(h, &adev);
+ 			if (!adev) {
+ 				pr_err("Failed to get device for ACPI object %s\n",
+ 				       andd->object_name);
+ 				continue;
+ 			}
+ 			dmar_acpi_insert_dev_scope(andd->device_number, adev);
+ 		}
+ 		andd = ((void *)andd) + andd->header.length;
+ 	}
+ 	return 0;
++>>>>>>> 11f1a7768cb9 (iommu/vt-d: Check for NULL pointer in dmar_acpi_dev_scope_init())
  }
  
  int __init dmar_dev_scope_init(void)
* Unmerged path drivers/iommu/dmar.c
