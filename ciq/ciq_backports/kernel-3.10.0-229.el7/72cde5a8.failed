KVM: PPC: Book3S HV: Save/restore host PMU registers that are new in POWER8

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
Rebuild_CHGLOG: - [virt] kvm/ppc: book3s hv - Save/restore host PMU registers that are new in POWER8 (Don Zickus) [1127366]
Rebuild_FUZZ: 96.00%
commit-author Paul Mackerras <paulus@samba.org>
commit 72cde5a88d37ba88ad1d47aecf957a9e528636d7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/72cde5a8.failed

Currently we save the host PMU configuration, counter values, etc.,
when entering a guest, and restore it on return from the guest.
(We have to do this because the guest has control of the PMU while
it is executing.)  However, we missed saving/restoring the SIAR and
SDAR registers, as well as the registers which are new on POWER8,
namely SIER and MMCR2.

This adds code to save the values of these registers when entering
the guest and restore them on exit.  This also works around the bug
in POWER8 where setting PMAE with a counter already negative doesn't
generate an interrupt.

	Signed-off-by: Paul Mackerras <paulus@samba.org>
	Acked-by: Scott Wood <scottwood@freescale.com>
(cherry picked from commit 72cde5a88d37ba88ad1d47aecf957a9e528636d7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kvm/book3s_hv_interrupts.S
diff --cc arch/powerpc/kvm/book3s_hv_interrupts.S
index 00b7ed41ea17,e18e3cfc32de..000000000000
--- a/arch/powerpc/kvm/book3s_hv_interrupts.S
+++ b/arch/powerpc/kvm/book3s_hv_interrupts.S
@@@ -71,7 -71,14 +71,18 @@@ END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S
  	mtmsrd  r10,1
  
  	/* Save host PMU registers */
++<<<<<<< HEAD
 +	/* R4 is live here (vcpu pointer) but not r3 or r5 */
++=======
+ BEGIN_FTR_SECTION
+ 	/* Work around P8 PMAE bug */
+ 	li	r3, -1
+ 	clrrdi	r3, r3, 10
+ 	mfspr	r8, SPRN_MMCR2
+ 	mtspr	SPRN_MMCR2, r3		/* freeze all counters using MMCR2 */
+ 	isync
+ END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
++>>>>>>> 72cde5a88d37 (KVM: PPC: Book3S HV: Save/restore host PMU registers that are new in POWER8)
  	li	r3, 1
  	sldi	r3, r3, 31		/* MMCR0_FC (freeze counters) bit */
  	mfspr	r7, SPRN_MMCR0		/* save MMCR0 */
diff --git a/arch/powerpc/include/asm/kvm_book3s_asm.h b/arch/powerpc/include/asm/kvm_book3s_asm.h
index 0bd9348a4db9..244e70ff7def 100644
--- a/arch/powerpc/include/asm/kvm_book3s_asm.h
+++ b/arch/powerpc/include/asm/kvm_book3s_asm.h
@@ -92,7 +92,7 @@ struct kvmppc_host_state {
 	unsigned long xics_phys;
 	u32 saved_xirr;
 	u64 dabr;
-	u64 host_mmcr[3];
+	u64 host_mmcr[7];	/* MMCR 0,1,A, SIAR, SDAR, MMCR2, SIER */
 	u32 host_pmc[8];
 	u64 host_purr;
 	u64 host_spurr;
* Unmerged path arch/powerpc/kvm/book3s_hv_interrupts.S
diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S
index 0ae4c28ae4b6..9d22c80799ec 100644
--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S
+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S
@@ -110,8 +110,18 @@ END_FTR_SECTION_IFSET(CPU_FTR_ARCH_201)
 	ld	r3, HSTATE_MMCR(r13)
 	ld	r4, HSTATE_MMCR + 8(r13)
 	ld	r5, HSTATE_MMCR + 16(r13)
+	ld	r6, HSTATE_MMCR + 24(r13)
+	ld	r7, HSTATE_MMCR + 32(r13)
 	mtspr	SPRN_MMCR1, r4
 	mtspr	SPRN_MMCRA, r5
+	mtspr	SPRN_SIAR, r6
+	mtspr	SPRN_SDAR, r7
+BEGIN_FTR_SECTION
+	ld	r8, HSTATE_MMCR + 40(r13)
+	ld	r9, HSTATE_MMCR + 48(r13)
+	mtspr	SPRN_MMCR2, r8
+	mtspr	SPRN_SIER, r9
+END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
 	mtspr	SPRN_MMCR0, r3
 	isync
 23:
