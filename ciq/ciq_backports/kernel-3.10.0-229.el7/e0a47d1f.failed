bridge: Fix incorrect judgment of promisc

jira LE-1907
Rebuild_History Non-Buildable kernel-3.10.0-229.el7
commit-author Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
commit e0a47d1f781665d2aa126b804572314d128a0070
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-3.10.0-229.el7/e0a47d1f.failed

br_manage_promisc() incorrectly expects br_auto_port() to return only 0
or 1, while it actually returns flags, i.e., a subset of BR_AUTO_MASK.

	Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e0a47d1f781665d2aa126b804572314d128a0070)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_if.c
diff --cc net/bridge/br_if.c
index 0a55727b8233,3eca3fdf8fe1..000000000000
--- a/net/bridge/br_if.c
+++ b/net/bridge/br_if.c
@@@ -85,6 -85,111 +85,114 @@@ void br_port_carrier_check(struct net_b
  	spin_unlock_bh(&br->lock);
  }
  
++<<<<<<< HEAD
++=======
+ static void br_port_set_promisc(struct net_bridge_port *p)
+ {
+ 	int err = 0;
+ 
+ 	if (br_promisc_port(p))
+ 		return;
+ 
+ 	err = dev_set_promiscuity(p->dev, 1);
+ 	if (err)
+ 		return;
+ 
+ 	br_fdb_unsync_static(p->br, p);
+ 	p->flags |= BR_PROMISC;
+ }
+ 
+ static void br_port_clear_promisc(struct net_bridge_port *p)
+ {
+ 	int err;
+ 
+ 	/* Check if the port is already non-promisc or if it doesn't
+ 	 * support UNICAST filtering.  Without unicast filtering support
+ 	 * we'll end up re-enabling promisc mode anyway, so just check for
+ 	 * it here.
+ 	 */
+ 	if (!br_promisc_port(p) || !(p->dev->priv_flags & IFF_UNICAST_FLT))
+ 		return;
+ 
+ 	/* Since we'll be clearing the promisc mode, program the port
+ 	 * first so that we don't have interruption in traffic.
+ 	 */
+ 	err = br_fdb_sync_static(p->br, p);
+ 	if (err)
+ 		return;
+ 
+ 	dev_set_promiscuity(p->dev, -1);
+ 	p->flags &= ~BR_PROMISC;
+ }
+ 
+ /* When a port is added or removed or when certain port flags
+  * change, this function is called to automatically manage
+  * promiscuity setting of all the bridge ports.  We are always called
+  * under RTNL so can skip using rcu primitives.
+  */
+ void br_manage_promisc(struct net_bridge *br)
+ {
+ 	struct net_bridge_port *p;
+ 	bool set_all = false;
+ 
+ 	/* If vlan filtering is disabled or bridge interface is placed
+ 	 * into promiscuous mode, place all ports in promiscuous mode.
+ 	 */
+ 	if ((br->dev->flags & IFF_PROMISC) || !br_vlan_enabled(br))
+ 		set_all = true;
+ 
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		if (set_all) {
+ 			br_port_set_promisc(p);
+ 		} else {
+ 			/* If the number of auto-ports is <= 1, then all other
+ 			 * ports will have their output configuration
+ 			 * statically specified through fdbs.  Since ingress
+ 			 * on the auto-port becomes forwarding/egress to other
+ 			 * ports and egress configuration is statically known,
+ 			 * we can say that ingress configuration of the
+ 			 * auto-port is also statically known.
+ 			 * This lets us disable promiscuous mode and write
+ 			 * this config to hw.
+ 			 */
+ 			if (br->auto_cnt == 0 ||
+ 			    (br->auto_cnt == 1 && br_auto_port(p)))
+ 				br_port_clear_promisc(p);
+ 			else
+ 				br_port_set_promisc(p);
+ 		}
+ 	}
+ }
+ 
+ static void nbp_update_port_count(struct net_bridge *br)
+ {
+ 	struct net_bridge_port *p;
+ 	u32 cnt = 0;
+ 
+ 	list_for_each_entry(p, &br->port_list, list) {
+ 		if (br_auto_port(p))
+ 			cnt++;
+ 	}
+ 	if (br->auto_cnt != cnt) {
+ 		br->auto_cnt = cnt;
+ 		br_manage_promisc(br);
+ 	}
+ }
+ 
+ static void nbp_delete_promisc(struct net_bridge_port *p)
+ {
+ 	/* If port is currently promiscuous, unset promiscuity.
+ 	 * Otherwise, it is a static port so remove all addresses
+ 	 * from it.
+ 	 */
+ 	dev_set_allmulti(p->dev, -1);
+ 	if (br_promisc_port(p))
+ 		dev_set_promiscuity(p->dev, -1);
+ 	else
+ 		br_fdb_unsync_static(p->br, p);
+ }
+ 
++>>>>>>> e0a47d1f7816 (bridge: Fix incorrect judgment of promisc)
  static void release_nbp(struct kobject *kobj)
  {
  	struct net_bridge_port *p
* Unmerged path net/bridge/br_if.c
