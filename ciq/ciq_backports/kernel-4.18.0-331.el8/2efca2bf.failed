mlxsw: spectrum_router: Add an indication if a nexthop group can be destroyed

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Ido Schimmel <idosch@nvidia.com>
commit 2efca2bfba995e67a5372288a4d745fcefc6e8ce
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/2efca2bf.failed

Currently, a nexthop group is destroyed when the last FIB entry is
detached from it.

When nexthop objects are supported, this can no longer be the case, as
the group is a separate object whose lifetime is managed by user space.

Add an indication if a nexthop group can be destroyed and always set it
to true for the existing IPv4 and IPv6 nexthop groups.

	Signed-off-by: Ido Schimmel <idosch@nvidia.com>
	Reviewed-by: Jiri Pirko <jiri@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 2efca2bfba995e67a5372288a4d745fcefc6e8ce)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index e9b6239efe36,87b8c8db688b..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -2888,6 -2887,19 +2888,22 @@@ struct mlxsw_sp_nexthop_group 
  #define nh_rif	nexthops[0].rif
  };
  
++<<<<<<< HEAD
++=======
+ struct mlxsw_sp_nexthop_group {
+ 	struct rhash_head ht_node;
+ 	struct list_head fib_list; /* list of fib entries that use this group */
+ 	union {
+ 		struct {
+ 			struct fib_info *fi;
+ 		} ipv4;
+ 	};
+ 	struct mlxsw_sp_nexthop_group_info *nhgi;
+ 	enum mlxsw_sp_nexthop_group_type type;
+ 	bool can_destroy;
+ };
+ 
++>>>>>>> 2efca2bfba99 (mlxsw: spectrum_router: Add an indication if a nexthop group can be destroyed)
  void mlxsw_sp_nexthop_counter_alloc(struct mlxsw_sp *mlxsw_sp,
  				    struct mlxsw_sp_nexthop *nh)
  {
@@@ -4124,7 -4173,9 +4140,13 @@@ mlxsw_sp_nexthop4_group_create(struct m
  	err = mlxsw_sp_nexthop_group_insert(mlxsw_sp, nh_grp);
  	if (err)
  		goto err_nexthop_group_insert;
++<<<<<<< HEAD
 +	mlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh_grp);
++=======
+ 
+ 	nh_grp->can_destroy = true;
+ 
++>>>>>>> 2efca2bfba99 (mlxsw: spectrum_router: Add an indication if a nexthop group can be destroyed)
  	return nh_grp;
  
  err_nexthop_group_insert:
@@@ -4142,17 -4190,11 +4164,22 @@@ static voi
  mlxsw_sp_nexthop4_group_destroy(struct mlxsw_sp *mlxsw_sp,
  				struct mlxsw_sp_nexthop_group *nh_grp)
  {
++<<<<<<< HEAD
 +	struct mlxsw_sp_nexthop *nh;
 +	int i;
 +
++=======
+ 	if (!nh_grp->can_destroy)
+ 		return;
++>>>>>>> 2efca2bfba99 (mlxsw: spectrum_router: Add an indication if a nexthop group can be destroyed)
  	mlxsw_sp_nexthop_group_remove(mlxsw_sp, nh_grp);
 -	mlxsw_sp_nexthop4_group_info_fini(mlxsw_sp, nh_grp);
 -	fib_info_put(nh_grp->ipv4.fi);
 +	for (i = 0; i < nh_grp->count; i++) {
 +		nh = &nh_grp->nexthops[i];
 +		mlxsw_sp_nexthop4_fini(mlxsw_sp, nh);
 +	}
 +	mlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh_grp);
 +	WARN_ON_ONCE(nh_grp->adj_index_valid);
 +	fib_info_put(mlxsw_sp_nexthop4_group_fi(nh_grp));
  	kfree(nh_grp);
  }
  
@@@ -5438,7 -5484,8 +5465,12 @@@ mlxsw_sp_nexthop6_group_create(struct m
  	if (err)
  		goto err_nexthop_group_insert;
  
++<<<<<<< HEAD
 +	mlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh_grp);
++=======
+ 	nh_grp->can_destroy = true;
+ 
++>>>>>>> 2efca2bfba99 (mlxsw: spectrum_router: Add an indication if a nexthop group can be destroyed)
  	return nh_grp;
  
  err_nexthop_group_insert:
@@@ -5455,16 -5499,10 +5487,21 @@@ static voi
  mlxsw_sp_nexthop6_group_destroy(struct mlxsw_sp *mlxsw_sp,
  				struct mlxsw_sp_nexthop_group *nh_grp)
  {
++<<<<<<< HEAD
 +	struct mlxsw_sp_nexthop *nh;
 +	int i = nh_grp->count;
 +
++=======
+ 	if (!nh_grp->can_destroy)
+ 		return;
++>>>>>>> 2efca2bfba99 (mlxsw: spectrum_router: Add an indication if a nexthop group can be destroyed)
  	mlxsw_sp_nexthop_group_remove(mlxsw_sp, nh_grp);
 -	mlxsw_sp_nexthop6_group_info_fini(mlxsw_sp, nh_grp);
 +	for (i--; i >= 0; i--) {
 +		nh = &nh_grp->nexthops[i];
 +		mlxsw_sp_nexthop6_fini(mlxsw_sp, nh);
 +	}
 +	mlxsw_sp_nexthop_group_refresh(mlxsw_sp, nh_grp);
 +	WARN_ON(nh_grp->adj_index_valid);
  	kfree(nh_grp);
  }
  
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
