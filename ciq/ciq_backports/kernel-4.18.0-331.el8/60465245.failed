hwmon: (k10temp) Reorganize and simplify temperature support detection

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Guenter Roeck <linux@roeck-us.net>
commit 60465245e6ce06691f1aa5d89c59b26679df7617
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/60465245.failed

Use a bit map to describe if temperature channels are supported,
and use it for all temperature channels. Use a separate flag,
independent of Tdie support, to indicate if the system is running
on a Ryzen CPU.

	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
(cherry picked from commit 60465245e6ce06691f1aa5d89c59b26679df7617)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hwmon/k10temp.c
diff --cc drivers/hwmon/k10temp.c
index c73c6199bfdb,3f37d5d81fe4..000000000000
--- a/drivers/hwmon/k10temp.c
+++ b/drivers/hwmon/k10temp.c
@@@ -67,9 -96,20 +67,24 @@@ struct k10temp_data 
  	void (*read_tempreg)(struct pci_dev *pdev, u32 *regval);
  	int temp_offset;
  	u32 temp_adjust_mask;
++<<<<<<< HEAD
 +	bool show_tdie;
++=======
+ 	u32 show_temp;
+ 	u32 svi_addr[2];
+ 	bool is_zen;
+ 	bool show_current;
+ 	int cfactor[2];
++>>>>>>> 60465245e6ce (hwmon: (k10temp) Reorganize and simplify temperature support detection)
  };
  
+ #define TCTL_BIT	0
+ #define TDIE_BIT	1
+ #define TCCD_BIT(x)	((x) + 2)
+ 
+ #define HAVE_TEMP(d, channel)	((d)->show_temp & BIT(channel))
+ #define HAVE_TDIE(d)		HAVE_TEMP(d, TDIE_BIT)
+ 
  struct tctl_offset {
  	u8 model;
  	char const *id;
@@@ -202,7 -340,7 +217,11 @@@ static umode_t k10temp_is_visible(cons
  	case hwmon_temp:
  		switch (attr) {
  		case hwmon_temp_input:
++<<<<<<< HEAD
 +			if (channel && !data->show_tdie)
++=======
+ 			if (!HAVE_TEMP(data, channel))
++>>>>>>> 60465245e6ce (hwmon: (k10temp) Reorganize and simplify temperature support detection)
  				return 0;
  			break;
  		case hwmon_temp_max:
@@@ -225,7 -363,8 +244,12 @@@
  				return 0;
  			break;
  		case hwmon_temp_label:
++<<<<<<< HEAD
 +			if (!data->show_tdie)
++=======
+ 			/* Show temperature labels only on Zen CPUs */
+ 			if (!data->is_zen || !HAVE_TEMP(data, channel))
++>>>>>>> 60465245e6ce (hwmon: (k10temp) Reorganize and simplify temperature support detection)
  				return 0;
  			break;
  		default:
@@@ -272,6 -416,76 +296,79 @@@ static bool has_erratum_319(struct pci_
  	       (boot_cpu_data.x86_model == 4 && boot_cpu_data.x86_stepping <= 2);
  }
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_DEBUG_FS
+ 
+ static void k10temp_smn_regs_show(struct seq_file *s, struct pci_dev *pdev,
+ 				  u32 addr, int count)
+ {
+ 	u32 reg;
+ 	int i;
+ 
+ 	for (i = 0; i < count; i++) {
+ 		if (!(i & 3))
+ 			seq_printf(s, "0x%06x: ", addr + i * 4);
+ 		amd_smn_read(amd_pci_dev_to_node_id(pdev), addr + i * 4, &reg);
+ 		seq_printf(s, "%08x ", reg);
+ 		if ((i & 3) == 3)
+ 			seq_puts(s, "\n");
+ 	}
+ }
+ 
+ static int svi_show(struct seq_file *s, void *unused)
+ {
+ 	struct k10temp_data *data = s->private;
+ 
+ 	k10temp_smn_regs_show(s, data->pdev, F17H_M01H_SVI, 32);
+ 	return 0;
+ }
+ DEFINE_SHOW_ATTRIBUTE(svi);
+ 
+ static int thm_show(struct seq_file *s, void *unused)
+ {
+ 	struct k10temp_data *data = s->private;
+ 
+ 	k10temp_smn_regs_show(s, data->pdev,
+ 			      F17H_M01H_REPORTED_TEMP_CTRL_OFFSET, 256);
+ 	return 0;
+ }
+ DEFINE_SHOW_ATTRIBUTE(thm);
+ 
+ static void k10temp_debugfs_cleanup(void *ddir)
+ {
+ 	debugfs_remove_recursive(ddir);
+ }
+ 
+ static void k10temp_init_debugfs(struct k10temp_data *data)
+ {
+ 	struct dentry *debugfs;
+ 	char name[32];
+ 
+ 	/* Only show debugfs data for Family 17h/18h CPUs */
+ 	if (!data->is_zen)
+ 		return;
+ 
+ 	scnprintf(name, sizeof(name), "k10temp-%s", pci_name(data->pdev));
+ 
+ 	debugfs = debugfs_create_dir(name, NULL);
+ 	if (debugfs) {
+ 		debugfs_create_file("svi", 0444, debugfs, data, &svi_fops);
+ 		debugfs_create_file("thm", 0444, debugfs, data, &thm_fops);
+ 		devm_add_action_or_reset(&data->pdev->dev,
+ 					 k10temp_debugfs_cleanup, debugfs);
+ 	}
+ }
+ 
+ #else
+ 
+ static void k10temp_init_debugfs(struct k10temp_data *data)
+ {
+ }
+ 
+ #endif
+ 
++>>>>>>> 60465245e6ce (hwmon: (k10temp) Reorganize and simplify temperature support detection)
  static const struct hwmon_channel_info *k10temp_info[] = {
  	HWMON_CHANNEL_INFO(temp,
  			   HWMON_T_INPUT | HWMON_T_MAX |
@@@ -292,6 -520,20 +389,23 @@@ static const struct hwmon_chip_info k10
  	.info = k10temp_info,
  };
  
++<<<<<<< HEAD
++=======
+ static void k10temp_get_ccd_support(struct pci_dev *pdev,
+ 				    struct k10temp_data *data, int limit)
+ {
+ 	u32 regval;
+ 	int i;
+ 
+ 	for (i = 0; i < limit; i++) {
+ 		amd_smn_read(amd_pci_dev_to_node_id(pdev),
+ 			     F17H_M70H_CCD_TEMP(i), &regval);
+ 		if (regval & F17H_M70H_CCD_TEMP_VALID)
+ 			data->show_temp |= BIT(TCCD_BIT(i));
+ 	}
+ }
+ 
++>>>>>>> 60465245e6ce (hwmon: (k10temp) Reorganize and simplify temperature support detection)
  static int k10temp_probe(struct pci_dev *pdev, const struct pci_device_id *id)
  {
  	int unreliable = has_erratum_319(pdev);
@@@ -321,10 -564,34 +436,38 @@@
  	     (boot_cpu_data.x86_model & 0xf0) == 0x70)) {
  		data->read_htcreg = read_htcreg_nb_f15;
  		data->read_tempreg = read_tempreg_nb_f15;
 -	} else if (boot_cpu_data.x86 == 0x17 || boot_cpu_data.x86 == 0x18) {
 -		data->temp_adjust_mask = CUR_TEMP_RANGE_SEL_MASK;
 +	} else if (boot_cpu_data.x86 == 0x17 || boot_cpu_data.x86 == 0x19) {
 +		data->temp_adjust_mask = 0x80000;
  		data->read_tempreg = read_tempreg_nb_f17;
++<<<<<<< HEAD
 +		data->show_tdie = true;
++=======
+ 		data->show_temp |= BIT(TDIE_BIT);	/* show Tdie */
+ 		data->is_zen = true;
+ 
+ 		switch (boot_cpu_data.x86_model) {
+ 		case 0x1:	/* Zen */
+ 		case 0x8:	/* Zen+ */
+ 		case 0x11:	/* Zen APU */
+ 		case 0x18:	/* Zen+ APU */
+ 			data->show_current = !is_threadripper() && !is_epyc();
+ 			data->svi_addr[0] = F17H_M01H_SVI_TEL_PLANE0;
+ 			data->svi_addr[1] = F17H_M01H_SVI_TEL_PLANE1;
+ 			data->cfactor[0] = CFACTOR_ICORE;
+ 			data->cfactor[1] = CFACTOR_ISOC;
+ 			k10temp_get_ccd_support(pdev, data, 4);
+ 			break;
+ 		case 0x31:	/* Zen2 Threadripper */
+ 		case 0x71:	/* Zen2 */
+ 			data->show_current = !is_threadripper() && !is_epyc();
+ 			data->cfactor[0] = CFACTOR_ICORE;
+ 			data->cfactor[1] = CFACTOR_ISOC;
+ 			data->svi_addr[0] = F17H_M01H_SVI_TEL_PLANE1;
+ 			data->svi_addr[1] = F17H_M01H_SVI_TEL_PLANE0;
+ 			k10temp_get_ccd_support(pdev, data, 8);
+ 			break;
+ 		}
++>>>>>>> 60465245e6ce (hwmon: (k10temp) Reorganize and simplify temperature support detection)
  	} else {
  		data->read_htcreg = read_htcreg_pci;
  		data->read_tempreg = read_tempreg_pci;
* Unmerged path drivers/hwmon/k10temp.c
