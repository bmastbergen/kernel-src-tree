s390/qeth: remove forward declarations in L2 code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 58fa357576d8e9f03054d226448c5eede95fad24
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/58fa3575.failed

Shuffle some code around (primarily all the discipline-related stuff) to
get rid of all the unnecessary forward declarations.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 58fa357576d8e9f03054d226448c5eede95fad24)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_l2_main.c
diff --cc drivers/s390/net/qeth_l2_main.c
index c683634669dd,1852d0a3c10a..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -588,46 -576,6 +577,49 @@@ static u16 qeth_l2_select_queue(struct 
  				 qeth_get_priority_queue(card, skb);
  }
  
++<<<<<<< HEAD
 +static const struct device_type qeth_l2_devtype = {
 +	.name = "qeth_layer2",
 +	.groups = qeth_l2_attr_groups,
 +};
 +
 +static int qeth_l2_probe_device(struct ccwgroup_device *gdev)
 +{
 +	struct qeth_card *card = dev_get_drvdata(&gdev->dev);
 +	int rc;
 +
 +	qeth_l2_vnicc_set_defaults(card);
 +	mutex_init(&card->sbp_lock);
 +
 +	if (gdev->dev.type == &qeth_generic_devtype) {
 +		rc = qeth_l2_create_device_attributes(&gdev->dev);
 +		if (rc)
 +			return rc;
 +	}
 +
 +	INIT_WORK(&card->rx_mode_work, qeth_l2_rx_mode_work);
 +	return 0;
 +}
 +
 +static void qeth_l2_remove_device(struct ccwgroup_device *cgdev)
 +{
 +	struct qeth_card *card = dev_get_drvdata(&cgdev->dev);
 +
 +	if (cgdev->dev.type == &qeth_generic_devtype)
 +		qeth_l2_remove_device_attributes(&cgdev->dev);
 +	qeth_set_allowed_threads(card, 0, 1);
 +	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
 +
 +	if (cgdev->state == CCWGROUP_ONLINE)
 +		qeth_set_offline(card, false);
 +
 +	cancel_work_sync(&card->close_dev_work);
 +	if (card->dev->reg_state == NETREG_REGISTERED)
 +		unregister_netdev(card->dev);
 +}
 +
++=======
++>>>>>>> 58fa357576d8 (s390/qeth: remove forward declarations in L2 code)
  static void qeth_l2_set_rx_mode(struct net_device *dev)
  {
  	struct qeth_card *card = dev->ml_priv;
@@@ -1095,129 -1056,6 +1087,132 @@@ static void qeth_l2_enable_brport_featu
  	}
  }
  
++<<<<<<< HEAD
 +static int qeth_l2_set_online(struct qeth_card *card, bool carrier_ok)
 +{
 +	struct net_device *dev = card->dev;
 +	int rc = 0;
 +
 +	qeth_l2_detect_dev2br_support(card);
 +
 +	mutex_lock(&card->sbp_lock);
 +	qeth_bridgeport_query_support(card);
 +	if (card->options.sbp.supported_funcs) {
 +		qeth_l2_setup_bridgeport_attrs(card);
 +		dev_info(&card->gdev->dev,
 +			 "The device represents a Bridge Capable Port\n");
 +	}
 +	mutex_unlock(&card->sbp_lock);
 +
 +	qeth_l2_register_dev_addr(card);
 +
 +	/* for the rx_bcast characteristic, init VNICC after setmac */
 +	qeth_l2_vnicc_init(card);
 +
 +	qeth_l2_trace_features(card);
 +
 +	/* softsetup */
 +	QETH_CARD_TEXT(card, 2, "softsetp");
 +
 +	card->state = CARD_STATE_SOFTSETUP;
 +
 +	qeth_set_allowed_threads(card, 0xffffffff, 0);
 +
 +	if (dev->reg_state != NETREG_REGISTERED) {
 +		rc = qeth_l2_setup_netdev(card);
 +		if (rc)
 +			goto err_setup;
 +
 +		if (carrier_ok)
 +			netif_carrier_on(dev);
 +	} else {
 +		rtnl_lock();
 +		if (carrier_ok)
 +			netif_carrier_on(dev);
 +		else
 +			netif_carrier_off(dev);
 +
 +		netif_device_attach(dev);
 +		qeth_enable_hw_features(dev);
 +		qeth_l2_enable_brport_features(card);
 +
 +		if (card->info.open_when_online) {
 +			card->info.open_when_online = 0;
 +			dev_open(dev, NULL);
 +		}
 +		rtnl_unlock();
 +	}
 +	return 0;
 +
 +err_setup:
 +	qeth_set_allowed_threads(card, 0, 1);
 +	card->state = CARD_STATE_DOWN;
 +	return rc;
 +}
 +
 +static void qeth_l2_set_offline(struct qeth_card *card)
 +{
 +	struct qeth_priv *priv = netdev_priv(card->dev);
 +
 +	qeth_set_allowed_threads(card, 0, 1);
 +	qeth_l2_drain_rx_mode_cache(card);
 +
 +	if (card->state == CARD_STATE_SOFTSETUP)
 +		card->state = CARD_STATE_DOWN;
 +
 +	qeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);
 +	if (priv->brport_features & BR_LEARNING_SYNC) {
 +		rtnl_lock();
 +		qeth_l2_dev2br_fdb_flush(card);
 +		rtnl_unlock();
 +	}
 +}
 +
 +static int __init qeth_l2_init(void)
 +{
 +	pr_info("register layer 2 discipline\n");
 +	return 0;
 +}
 +
 +static void __exit qeth_l2_exit(void)
 +{
 +	pr_info("unregister layer 2 discipline\n");
 +}
 +
 +/* Returns zero if the command is successfully "consumed" */
 +static int qeth_l2_control_event(struct qeth_card *card,
 +					struct qeth_ipa_cmd *cmd)
 +{
 +	switch (cmd->hdr.command) {
 +	case IPA_CMD_SETBRIDGEPORT_OSA:
 +	case IPA_CMD_SETBRIDGEPORT_IQD:
 +		if (cmd->data.sbp.hdr.command_code ==
 +				IPA_SBP_BRIDGE_PORT_STATE_CHANGE) {
 +			qeth_bridge_state_change(card, cmd);
 +			return 0;
 +		} else
 +			return 1;
 +	case IPA_CMD_ADDRESS_CHANGE_NOTIF:
 +		qeth_addr_change_event(card, cmd);
 +		return 0;
 +	default:
 +		return 1;
 +	}
 +}
 +
 +struct qeth_discipline qeth_l2_discipline = {
 +	.devtype = &qeth_l2_devtype,
 +	.setup = qeth_l2_probe_device,
 +	.remove = qeth_l2_remove_device,
 +	.set_online = qeth_l2_set_online,
 +	.set_offline = qeth_l2_set_offline,
 +	.do_ioctl = NULL,
 +	.control_event_handler = qeth_l2_control_event,
 +};
 +EXPORT_SYMBOL_GPL(qeth_l2_discipline);
 +
++=======
++>>>>>>> 58fa357576d8 (s390/qeth: remove forward declarations in L2 code)
  #ifdef CONFIG_QETH_OSN
  static void qeth_osn_assist_cb(struct qeth_card *card,
  			       struct qeth_cmd_buffer *iob,
diff --git a/drivers/s390/net/qeth_l2.h b/drivers/s390/net/qeth_l2.h
index cc95675c8bc4..296d73d84326 100644
--- a/drivers/s390/net/qeth_l2.h
+++ b/drivers/s390/net/qeth_l2.h
@@ -31,4 +31,11 @@ struct qeth_mac {
 	struct hlist_node hnode;
 };
 
+static inline bool qeth_bridgeport_is_in_use(struct qeth_card *card)
+{
+	return card->options.sbp.role ||
+	       card->options.sbp.reflect_promisc ||
+	       card->options.sbp.hostnotification;
+}
+
 #endif /* __QETH_L2_H__ */
* Unmerged path drivers/s390/net/qeth_l2_main.c
