s390/qeth: constify the disciplines

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 50144f675363c368400eedd52c6680163b3260eb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/50144f67.failed

The discipline struct is a fixed group of function pointers.
So declare the L2 and L3 disciplines as constant.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 50144f675363c368400eedd52c6680163b3260eb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_l2_main.c
diff --cc drivers/s390/net/qeth_l2_main.c
index c683634669dd,2e9d3fea60e6..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -2359,6 -2186,182 +2359,185 @@@ static void qeth_l2_vnicc_set_defaults(
  	card->options.vnicc.wanted_chars = QETH_VNICC_DEFAULT;
  }
  
++<<<<<<< HEAD
++=======
+ static const struct device_type qeth_l2_devtype = {
+ 	.name = "qeth_layer2",
+ 	.groups = qeth_l2_attr_groups,
+ };
+ 
+ static int qeth_l2_probe_device(struct ccwgroup_device *gdev)
+ {
+ 	struct qeth_card *card = dev_get_drvdata(&gdev->dev);
+ 	int rc;
+ 
+ 	if (IS_OSN(card))
+ 		dev_notice(&gdev->dev, "OSN support will be dropped in 2021\n");
+ 
+ 	qeth_l2_vnicc_set_defaults(card);
+ 	mutex_init(&card->sbp_lock);
+ 
+ 	if (gdev->dev.type == &qeth_generic_devtype) {
+ 		rc = qeth_l2_create_device_attributes(&gdev->dev);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	INIT_WORK(&card->rx_mode_work, qeth_l2_rx_mode_work);
+ 	return 0;
+ }
+ 
+ static void qeth_l2_remove_device(struct ccwgroup_device *gdev)
+ {
+ 	struct qeth_card *card = dev_get_drvdata(&gdev->dev);
+ 
+ 	if (gdev->dev.type == &qeth_generic_devtype)
+ 		qeth_l2_remove_device_attributes(&gdev->dev);
+ 	qeth_set_allowed_threads(card, 0, 1);
+ 	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
+ 
+ 	if (gdev->state == CCWGROUP_ONLINE)
+ 		qeth_set_offline(card, false);
+ 
+ 	cancel_work_sync(&card->close_dev_work);
+ 	if (card->dev->reg_state == NETREG_REGISTERED)
+ 		unregister_netdev(card->dev);
+ }
+ 
+ static int qeth_l2_set_online(struct qeth_card *card, bool carrier_ok)
+ {
+ 	struct net_device *dev = card->dev;
+ 	int rc = 0;
+ 
+ 	/* query before bridgeport_notification may be enabled */
+ 	qeth_l2_detect_dev2br_support(card);
+ 
+ 	mutex_lock(&card->sbp_lock);
+ 	qeth_bridgeport_query_support(card);
+ 	if (card->options.sbp.supported_funcs) {
+ 		qeth_l2_setup_bridgeport_attrs(card);
+ 		dev_info(&card->gdev->dev,
+ 			 "The device represents a Bridge Capable Port\n");
+ 	}
+ 	mutex_unlock(&card->sbp_lock);
+ 
+ 	qeth_l2_register_dev_addr(card);
+ 
+ 	/* for the rx_bcast characteristic, init VNICC after setmac */
+ 	qeth_l2_vnicc_init(card);
+ 
+ 	qeth_l2_trace_features(card);
+ 
+ 	/* softsetup */
+ 	QETH_CARD_TEXT(card, 2, "softsetp");
+ 
+ 	card->state = CARD_STATE_SOFTSETUP;
+ 
+ 	qeth_set_allowed_threads(card, 0xffffffff, 0);
+ 
+ 	if (dev->reg_state != NETREG_REGISTERED) {
+ 		rc = qeth_l2_setup_netdev(card);
+ 		if (rc)
+ 			goto err_setup;
+ 
+ 		if (carrier_ok)
+ 			netif_carrier_on(dev);
+ 	} else {
+ 		rtnl_lock();
+ 		rc = qeth_set_real_num_tx_queues(card,
+ 						 qeth_tx_actual_queues(card));
+ 		if (rc) {
+ 			rtnl_unlock();
+ 			goto err_set_queues;
+ 		}
+ 
+ 		if (carrier_ok)
+ 			netif_carrier_on(dev);
+ 		else
+ 			netif_carrier_off(dev);
+ 
+ 		netif_device_attach(dev);
+ 		qeth_enable_hw_features(dev);
+ 		qeth_l2_enable_brport_features(card);
+ 
+ 		if (card->info.open_when_online) {
+ 			card->info.open_when_online = 0;
+ 			dev_open(dev, NULL);
+ 		}
+ 		rtnl_unlock();
+ 	}
+ 	return 0;
+ 
+ err_set_queues:
+ err_setup:
+ 	qeth_set_allowed_threads(card, 0, 1);
+ 	card->state = CARD_STATE_DOWN;
+ 	return rc;
+ }
+ 
+ static void qeth_l2_set_offline(struct qeth_card *card)
+ {
+ 	struct qeth_priv *priv = netdev_priv(card->dev);
+ 
+ 	qeth_set_allowed_threads(card, 0, 1);
+ 	qeth_l2_drain_rx_mode_cache(card);
+ 
+ 	if (card->state == CARD_STATE_SOFTSETUP)
+ 		card->state = CARD_STATE_DOWN;
+ 
+ 	qeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);
+ 	if (priv->brport_features & BR_LEARNING_SYNC) {
+ 		rtnl_lock();
+ 		qeth_l2_dev2br_fdb_flush(card);
+ 		rtnl_unlock();
+ 	}
+ }
+ 
+ /* Returns zero if the command is successfully "consumed" */
+ static int qeth_l2_control_event(struct qeth_card *card,
+ 				 struct qeth_ipa_cmd *cmd)
+ {
+ 	switch (cmd->hdr.command) {
+ 	case IPA_CMD_SETBRIDGEPORT_OSA:
+ 	case IPA_CMD_SETBRIDGEPORT_IQD:
+ 		if (cmd->data.sbp.hdr.command_code ==
+ 		    IPA_SBP_BRIDGE_PORT_STATE_CHANGE) {
+ 			qeth_bridge_state_change(card, cmd);
+ 			return 0;
+ 		}
+ 
+ 		return 1;
+ 	case IPA_CMD_ADDRESS_CHANGE_NOTIF:
+ 		qeth_addr_change_event(card, cmd);
+ 		return 0;
+ 	default:
+ 		return 1;
+ 	}
+ }
+ 
+ const struct qeth_discipline qeth_l2_discipline = {
+ 	.devtype = &qeth_l2_devtype,
+ 	.setup = qeth_l2_probe_device,
+ 	.remove = qeth_l2_remove_device,
+ 	.set_online = qeth_l2_set_online,
+ 	.set_offline = qeth_l2_set_offline,
+ 	.do_ioctl = NULL,
+ 	.control_event_handler = qeth_l2_control_event,
+ };
+ EXPORT_SYMBOL_GPL(qeth_l2_discipline);
+ 
+ static int __init qeth_l2_init(void)
+ {
+ 	pr_info("register layer 2 discipline\n");
+ 	return 0;
+ }
+ 
+ static void __exit qeth_l2_exit(void)
+ {
+ 	pr_info("unregister layer 2 discipline\n");
+ }
+ 
++>>>>>>> 50144f675363 (s390/qeth: constify the disciplines)
  module_init(qeth_l2_init);
  module_exit(qeth_l2_exit);
  MODULE_AUTHOR("Frank Blaschka <frank.blaschka@de.ibm.com>");
diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h
index 4550380cb5d0..6dca4eb2a3ab 100644
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@ -836,7 +836,7 @@ struct qeth_card {
 	struct qeth_qdio_info qdio;
 	int read_or_write_problem;
 	struct qeth_osn_info osn_info;
-	struct qeth_discipline *discipline;
+	const struct qeth_discipline *discipline;
 	atomic_t force_alloc_skb;
 	struct service_level qeth_service_level;
 	struct qdio_ssqd_desc ssqd;
@@ -1014,8 +1014,8 @@ static inline int qeth_send_simple_setassparms_v6(struct qeth_card *card,
 
 int qeth_get_priority_queue(struct qeth_card *card, struct sk_buff *skb);
 
-extern struct qeth_discipline qeth_l2_discipline;
-extern struct qeth_discipline qeth_l3_discipline;
+extern const struct qeth_discipline qeth_l2_discipline;
+extern const struct qeth_discipline qeth_l3_discipline;
 extern const struct ethtool_ops qeth_ethtool_ops;
 extern const struct ethtool_ops qeth_osn_ethtool_ops;
 extern const struct attribute_group *qeth_generic_attr_groups[];
* Unmerged path drivers/s390/net/qeth_l2_main.c
diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c
index 7d591f3bc4ee..80ee4fa2d284 100644
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@ -2070,7 +2070,7 @@ static int qeth_l3_control_event(struct qeth_card *card,
 	return 1;
 }
 
-struct qeth_discipline qeth_l3_discipline = {
+const struct qeth_discipline qeth_l3_discipline = {
 	.devtype = &qeth_l3_devtype,
 	.setup = qeth_l3_probe_device,
 	.remove = qeth_l3_remove_device,
