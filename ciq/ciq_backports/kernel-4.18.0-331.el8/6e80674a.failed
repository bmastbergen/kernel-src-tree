gfs2: Clean up ail2_empty

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 6e80674af06c0dca6e0153d492d437f3f07fe3e9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/6e80674a.failed

Clean up the logic in ail2_empty (no functional change).

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 6e80674af06c0dca6e0153d492d437f3f07fe3e9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/log.c
diff --cc fs/gfs2/log.c
index 1a5aad0b1fab,e4dc23a24569..000000000000
--- a/fs/gfs2/log.c
+++ b/fs/gfs2/log.c
@@@ -336,29 -367,33 +336,49 @@@ static void gfs2_ail_empty_tr(struct gf
  	}
  }
  
+ static void __ail2_empty(struct gfs2_sbd *sdp, struct gfs2_trans *tr)
+ {
+ 	gfs2_ail_empty_tr(sdp, tr, &tr->tr_ail2_list);
+ 	list_del(&tr->tr_list);
+ 	gfs2_assert_warn(sdp, list_empty(&tr->tr_ail1_list));
+ 	gfs2_assert_warn(sdp, list_empty(&tr->tr_ail2_list));
+ 	gfs2_trans_free(sdp, tr);
+ }
+ 
  static void ail2_empty(struct gfs2_sbd *sdp, unsigned int new_tail)
  {
- 	struct gfs2_trans *tr, *safe;
+ 	struct list_head *ail2_list = &sdp->sd_ail2_list;
  	unsigned int old_tail = sdp->sd_log_tail;
- 	int wrap = (new_tail < old_tail);
- 	int a, b, rm;
+ 	struct gfs2_trans *tr, *safe;
  
  	spin_lock(&sdp->sd_ail_lock);
++<<<<<<< HEAD
 +
 +	list_for_each_entry_safe(tr, safe, &sdp->sd_ail2_list, tr_list) {
 +		a = (old_tail <= tr->tr_first);
 +		b = (tr->tr_first < new_tail);
 +		rm = (wrap) ? (a || b) : (a && b);
 +		if (!rm)
 +			continue;
 +
 +		gfs2_ail_empty_tr(sdp, tr, &tr->tr_ail2_list);
 +		list_del(&tr->tr_list);
 +		gfs2_assert_warn(sdp, list_empty(&tr->tr_ail1_list));
 +		gfs2_assert_warn(sdp, list_empty(&tr->tr_ail2_list));
 +		kfree(tr);
++=======
+ 	if (old_tail <= new_tail) {
+ 		list_for_each_entry_safe(tr, safe, ail2_list, tr_list) {
+ 			if (old_tail <= tr->tr_first && tr->tr_first < new_tail)
+ 				__ail2_empty(sdp, tr);
+ 		}
+ 	} else {
+ 		list_for_each_entry_safe(tr, safe, ail2_list, tr_list) {
+ 			if (old_tail <= tr->tr_first || tr->tr_first < new_tail)
+ 				__ail2_empty(sdp, tr);
+ 		}
++>>>>>>> 6e80674af06c (gfs2: Clean up ail2_empty)
  	}
- 
  	spin_unlock(&sdp->sd_ail_lock);
  }
  
* Unmerged path fs/gfs2/log.c
