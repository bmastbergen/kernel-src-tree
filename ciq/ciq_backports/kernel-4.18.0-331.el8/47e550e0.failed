veth: refine napi usage

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 47e550e0105be9b716a3860545731735a67c6b3c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/47e550e0.failed

After the previous patch, when enabling GRO, locally generated
TCP traffic experiences some measurable overhead, as it traverses
the GRO engine without any chance of aggregation.

This change refine the NAPI receive path admission test, to avoid
unnecessary GRO overhead in most scenarios, when GRO is enabled
on a veth peer.

Only skbs that are eligible for aggregation enter the GRO layer,
the others will go through the traditional receive path.

	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 47e550e0105be9b716a3860545731735a67c6b3c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/veth.c
diff --cc drivers/net/veth.c
index c00053f98ad5,15b2e3923c47..000000000000
--- a/drivers/net/veth.c
+++ b/drivers/net/veth.c
@@@ -299,7 -333,13 +318,17 @@@ static netdev_tx_t veth_xmit(struct sk_
  	rxq = skb_get_queue_mapping(skb);
  	if (rxq < rcv->real_num_rx_queues) {
  		rq = &rcv_priv->rq[rxq];
++<<<<<<< HEAD
 +		rcv_xdp = rcu_access_pointer(rq->xdp_prog);
++=======
+ 
+ 		/* The napi pointer is available when an XDP program is
+ 		 * attached or when GRO is enabled
+ 		 * Don't bother with napi/GRO if the skb can't be aggregated
+ 		 */
+ 		use_napi = rcu_access_pointer(rq->napi) &&
+ 			   veth_skb_is_eligible_for_gro(dev, rcv, skb);
++>>>>>>> 47e550e0105b (veth: refine napi usage)
  		skb_record_rx_queue(skb, rxq);
  	}
  
* Unmerged path drivers/net/veth.c
