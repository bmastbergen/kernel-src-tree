gfs2: Clean up gfs2_unstuff_dinode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 7a607a41cdc6c6f27b8e234cb44ce57070513dac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/7a607a41.failed

Split __gfs2_unstuff_inode off from gfs2_unstuff_dinode and clean up the
code a little.  All remaining callers now pass NULL as the page argument
of gfs2_unstuff_dinode, so remove that argument.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 7a607a41cdc6c6f27b8e234cb44ce57070513dac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/bmap.c
#	fs/gfs2/file.c
diff --cc fs/gfs2/bmap.c
index db72f03c4a2b,ed8b67b21718..000000000000
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@@ -59,15 -56,6 +59,18 @@@ static int gfs2_unstuffer_page(struct g
  			       u64 block, struct page *page)
  {
  	struct inode *inode = &ip->i_inode;
++<<<<<<< HEAD
 +	struct buffer_head *bh;
 +	int release = 0;
 +
 +	if (!page || page->index) {
 +		page = find_or_create_page(inode->i_mapping, 0, GFP_NOFS);
 +		if (!page)
 +			return -ENOMEM;
 +		release = 1;
 +	}
++=======
++>>>>>>> 7a607a41cdc6 (gfs2: Clean up gfs2_unstuff_dinode)
  
  	if (!PageUptodate(page)) {
  		void *kaddr = kmap(page);
diff --cc fs/gfs2/file.c
index e69af279b7fd,84ec053d43b4..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -463,19 -504,22 +463,32 @@@ static vm_fault_t gfs2_page_mkwrite(str
  		rblocks += RES_STATFS + RES_QUOTA;
  		rblocks += gfs2_rg_blocks(ip, data_blocks + ind_blocks);
  	}
 -	err = gfs2_trans_begin(sdp, rblocks, 0);
 -	if (err) {
 -		ret = block_page_mkwrite_return(err);
 +	ret = gfs2_trans_begin(sdp, rblocks, 0);
 +	if (ret)
  		goto out_trans_fail;
++<<<<<<< HEAD
++=======
+ 	}
+ 
+ 	/* Unstuff, if required, and allocate backing blocks for page */
+ 	if (gfs2_is_stuffed(ip)) {
+ 		err = gfs2_unstuff_dinode(ip);
+ 		if (err) {
+ 			ret = block_page_mkwrite_return(err);
+ 			goto out_trans_end;
+ 		}
+ 	}
++>>>>>>> 7a607a41cdc6 (gfs2: Clean up gfs2_unstuff_dinode)
  
  	lock_page(page);
 +	ret = -EINVAL;
 +	size = i_size_read(inode);
 +	last_index = (size - 1) >> PAGE_SHIFT;
 +	/* Check page index against inode size */
 +	if (size == 0 || (page->index > last_index))
 +		goto out_trans_end;
 +
 +	ret = -EAGAIN;
  	/* If truncated, we must retry the operation, we may have raced
  	 * with the glock demotion code.
  	 */
* Unmerged path fs/gfs2/bmap.c
diff --git a/fs/gfs2/bmap.h b/fs/gfs2/bmap.h
index 19a1fd772c61..a4864ef4e4d9 100644
--- a/fs/gfs2/bmap.h
+++ b/fs/gfs2/bmap.h
@@ -48,7 +48,7 @@ static inline void gfs2_write_calc_reserv(const struct gfs2_inode *ip,
 
 extern const struct iomap_ops gfs2_iomap_ops;
 
-extern int gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page);
+extern int gfs2_unstuff_dinode(struct gfs2_inode *ip);
 extern int gfs2_block_map(struct inode *inode, sector_t lblock,
 			  struct buffer_head *bh, int create);
 extern int gfs2_iomap_get_alloc(struct inode *inode, loff_t pos, loff_t length,
diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 85c2e747093d..242841beed98 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -178,7 +178,7 @@ static int gfs2_dir_write_data(struct gfs2_inode *ip, const char *buf,
 		return -EINVAL;
 
 	if (gfs2_is_stuffed(ip)) {
-		error = gfs2_unstuff_dinode(ip, NULL);
+		error = gfs2_unstuff_dinode(ip);
 		if (error)
 			return error;
 	}
* Unmerged path fs/gfs2/file.c
diff --git a/fs/gfs2/quota.c b/fs/gfs2/quota.c
index 61f288860ad8..ebccb97dbb9b 100644
--- a/fs/gfs2/quota.c
+++ b/fs/gfs2/quota.c
@@ -828,7 +828,7 @@ static int gfs2_adjust_quota(struct gfs2_inode *ip, loff_t loc,
 	u64 size;
 
 	if (gfs2_is_stuffed(ip)) {
-		err = gfs2_unstuff_dinode(ip, NULL);
+		err = gfs2_unstuff_dinode(ip);
 		if (err)
 			return err;
 	}
