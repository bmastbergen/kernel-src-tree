s390/qeth: allocate initial TX Buffer structs with GFP_KERNEL

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit e47ded97f9728da5ced038c627c6b607e9706a13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/e47ded97.failed

qeth_init_qdio_out_buf() is typically called during initialization, and
the GFP_ATOMIC is only needed for a very specific & rare case during TX
completion.

Allow callers to specify a gfp mask, so that the initialization path can
select GFP_KERNEL. While at it also clarify the function name.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e47ded97f9728da5ced038c627c6b607e9706a13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index 060f69ebe884,abd1e49cf97a..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -2635,11 -2626,23 +2636,20 @@@ static struct qeth_qdio_out_q *qeth_all
  	if (!q)
  		return NULL;
  
++<<<<<<< HEAD
 +	if (qdio_alloc_buffers(q->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q)) {
 +		kfree(q);
 +		return NULL;
++=======
+ 	if (qdio_alloc_buffers(q->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q))
+ 		goto err_qdio_bufs;
+ 
+ 	for (i = 0; i < QDIO_MAX_BUFFERS_PER_Q; i++) {
+ 		if (qeth_alloc_out_buf(q, i, GFP_KERNEL))
+ 			goto err_out_bufs;
++>>>>>>> e47ded97f972 (s390/qeth: allocate initial TX Buffer structs with GFP_KERNEL)
  	}
 -
  	return q;
 -
 -err_out_bufs:
 -	while (i > 0)
 -		kmem_cache_free(qeth_qdio_outbuf_cache, q->bufs[--i]);
 -	qdio_free_buffers(q->qdio_bufs, QDIO_MAX_BUFFERS_PER_Q);
 -err_qdio_bufs:
 -	kfree(q);
 -	return NULL;
  }
  
  static void qeth_tx_completion_timer(struct timer_list *timer)
* Unmerged path drivers/s390/net/qeth_core_main.c
