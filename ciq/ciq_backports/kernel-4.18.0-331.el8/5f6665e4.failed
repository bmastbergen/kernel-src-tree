powerpc/rtas: remove rtas_ibm_suspend_me_unsafe()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Nathan Lynch <nathanl@linux.ibm.com>
commit 5f6665e400569de479733677e77862542aebb6cc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/5f6665e4.failed

rtas_ibm_suspend_me_unsafe() is now unused; remove it and
rtas_percpu_suspend_me() which becomes unused as a result.

	Signed-off-by: Nathan Lynch <nathanl@linux.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20201207215200.1785968-17-nathanl@linux.ibm.com
(cherry picked from commit 5f6665e400569de479733677e77862542aebb6cc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/kernel/rtas.c
diff --cc arch/powerpc/kernel/rtas.c
index 7920f0612180,7e6024f570da..000000000000
--- a/arch/powerpc/kernel/rtas.c
+++ b/arch/powerpc/kernel/rtas.c
@@@ -928,72 -925,57 +928,126 @@@ int rtas_suspend_cpu(struct rtas_suspen
  	return __rtas_suspend_cpu(data, 0);
  }
  
++<<<<<<< HEAD
 +static void rtas_percpu_suspend_me(void *info)
 +{
 +	__rtas_suspend_cpu((struct rtas_suspend_me_data *)info, 1);
 +}
 +
 +int rtas_ibm_suspend_me_unsafe(u64 handle)
 +{
 +	long state;
 +	long rc;
 +	unsigned long retbuf[PLPAR_HCALL_BUFSIZE];
 +	struct rtas_suspend_me_data data;
 +	DECLARE_COMPLETION_ONSTACK(done);
 +
 +	if (!rtas_service_present("ibm,suspend-me"))
 +		return -ENOSYS;
 +
 +	/* Make sure the state is valid */
 +	rc = plpar_hcall(H_VASI_STATE, retbuf, handle);
 +
 +	state = retbuf[0];
 +
 +	if (rc) {
 +		printk(KERN_ERR "rtas_ibm_suspend_me: vasi_state returned %ld\n",rc);
 +		return rc;
 +	} else if (state == H_VASI_ENABLED) {
 +		return -EAGAIN;
 +	} else if (state != H_VASI_SUSPENDING) {
 +		printk(KERN_ERR "rtas_ibm_suspend_me: vasi_state returned state %ld\n",
 +		       state);
 +		return -EIO;
 +	}
 +
 +	atomic_set(&data.working, 0);
 +	atomic_set(&data.done, 0);
 +	atomic_set(&data.error, 0);
 +	data.token = rtas_token("ibm,suspend-me");
 +	data.complete = &done;
 +
 +	lock_device_hotplug();
 +
 +	cpu_hotplug_disable();
 +
 +	/* Call function on all CPUs.  One of us will make the
 +	 * rtas call
 +	 */
 +	if (on_each_cpu(rtas_percpu_suspend_me, &data, 0))
 +		atomic_set(&data.error, -EINVAL);
 +
 +	wait_for_completion(&done);
 +
 +	if (atomic_read(&data.error) != 0)
 +		printk(KERN_ERR "Error doing global join\n");
 +
 +
 +	cpu_hotplug_enable();
 +
 +	unlock_device_hotplug();
 +
 +	return atomic_read(&data.error);
 +}
 +#else /* CONFIG_PPC_PSERIES */
 +int rtas_ibm_suspend_me_unsafe(u64 handle)
 +{
 +	return -ENOSYS;
 +}
 +#endif
++=======
+ /**
+  * rtas_call_reentrant() - Used for reentrant rtas calls
+  * @token:	Token for desired reentrant RTAS call
+  * @nargs:	Number of Input Parameters
+  * @nret:	Number of Output Parameters
+  * @outputs:	Array of outputs
+  * @...:	Inputs for desired RTAS call
+  *
+  * According to LoPAR documentation, only "ibm,int-on", "ibm,int-off",
+  * "ibm,get-xive" and "ibm,set-xive" are currently reentrant.
+  * Reentrant calls need their own rtas_args buffer, so not using rtas.args, but
+  * PACA one instead.
+  *
+  * Return:	-1 on error,
+  *		First output value of RTAS call if (nret > 0),
+  *		0 otherwise,
+  */
+ int rtas_call_reentrant(int token, int nargs, int nret, int *outputs, ...)
+ {
+ 	va_list list;
+ 	struct rtas_args *args;
+ 	unsigned long flags;
+ 	int i, ret = 0;
+ 
+ 	if (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)
+ 		return -1;
+ 
+ 	local_irq_save(flags);
+ 	preempt_disable();
+ 
+ 	/* We use the per-cpu (PACA) rtas args buffer */
+ 	args = local_paca->rtas_args_reentrant;
+ 
+ 	va_start(list, outputs);
+ 	va_rtas_call_unlocked(args, token, nargs, nret, list);
+ 	va_end(list);
+ 
+ 	if (nret > 1 && outputs)
+ 		for (i = 0; i < nret - 1; ++i)
+ 			outputs[i] = be32_to_cpu(args->rets[i + 1]);
+ 
+ 	if (nret > 0)
+ 		ret = be32_to_cpu(args->rets[0]);
+ 
+ 	local_irq_restore(flags);
+ 	preempt_enable();
+ 
+ 	return ret;
+ }
+ 
+ #endif /* CONFIG_PPC_PSERIES */
++>>>>>>> 5f6665e40056 (powerpc/rtas: remove rtas_ibm_suspend_me_unsafe())
  
  /**
   * Find a specific pseries error log in an RTAS extended event log.
diff --git a/arch/powerpc/include/asm/rtas.h b/arch/powerpc/include/asm/rtas.h
index 2a80269da3c4..14198e795637 100644
--- a/arch/powerpc/include/asm/rtas.h
+++ b/arch/powerpc/include/asm/rtas.h
@@ -376,7 +376,6 @@ extern int rtas_set_indicator_fast(int indicator, int index, int new_value);
 extern void rtas_progress(char *s, unsigned short hex);
 extern int rtas_suspend_cpu(struct rtas_suspend_me_data *data);
 extern int rtas_suspend_last_cpu(struct rtas_suspend_me_data *data);
-int rtas_ibm_suspend_me_unsafe(u64 handle);
 int rtas_ibm_suspend_me(int *fw_status);
 
 struct rtc_time;
* Unmerged path arch/powerpc/kernel/rtas.c
