sctp: trim optlen when it's a huge value in sctp_setsockopt

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Xin Long <lucien.xin@gmail.com>
commit 2f3fdd8d4805015fa964807e1c7f3d88f31bd389
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/2f3fdd8d.failed

After commit ca84bd058dae ("sctp: copy the optval from user space in
sctp_setsockopt"), it does memory allocation in sctp_setsockopt with
the optlen, and it would fail the allocation and return error if the
optlen from user space is a huge value.

This breaks some sockopts, like SCTP_HMAC_IDENT, SCTP_RESET_STREAMS and
SCTP_AUTH_KEY, as when processing these sockopts before, optlen would
be trimmed to a biggest value it needs when optlen is a huge value,
instead of failing the allocation and returning error.

This patch is to fix the allocation failure when it's a huge optlen from
user space by trimming it to the biggest size sctp sockopt may need when
necessary, and this biggest size is from sctp_setsockopt_reset_streams()
for SCTP_RESET_STREAMS, which is bigger than those for SCTP_HMAC_IDENT
and SCTP_AUTH_KEY.

Fixes: ca84bd058dae ("sctp: copy the optval from user space in sctp_setsockopt")
	Signed-off-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 2f3fdd8d4805015fa964807e1c7f3d88f31bd389)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/sctp/socket.c
diff --cc net/sctp/socket.c
index 68e4f7116e91,6b937bfd4751..000000000000
--- a/net/sctp/socket.c
+++ b/net/sctp/socket.c
@@@ -4768,7 -4577,11 +4768,15 @@@ static int sctp_setsockopt(struct sock 
  	}
  
  	if (optlen > 0) {
++<<<<<<< HEAD
 +		kopt = memdup_user(optval, optlen);
++=======
+ 		/* Trim it to the biggest size sctp sockopt may need if necessary */
+ 		optlen = min_t(unsigned int, optlen,
+ 			       PAGE_ALIGN(USHRT_MAX +
+ 					  sizeof(__u16) * sizeof(struct sctp_reset_streams)));
+ 		kopt = memdup_sockptr(optval, optlen);
++>>>>>>> 2f3fdd8d4805 (sctp: trim optlen when it's a huge value in sctp_setsockopt)
  		if (IS_ERR(kopt))
  			return PTR_ERR(kopt);
  	}
* Unmerged path net/sctp/socket.c
