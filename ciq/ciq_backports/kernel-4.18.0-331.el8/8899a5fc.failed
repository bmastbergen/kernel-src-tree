KVM: x86: Fix potential fput on a null source_kvm_file

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Colin Ian King <colin.king@canonical.com>
commit 8899a5fc7da516460f841189a28aac0b52b554fd
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/8899a5fc.failed

The fget can potentially return null, so the fput on the error return
path can cause a null pointer dereference. Fix this by checking for
a null source_kvm_file before doing a fput.

Addresses-Coverity: ("Dereference null return")
Fixes: 54526d1fd593 ("KVM: x86: Support KVM VMs sharing SEV context")
	Signed-off-by: Colin Ian King <colin.king@canonical.com>
Message-Id: <20210430170303.131924-1-colin.king@canonical.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit 8899a5fc7da516460f841189a28aac0b52b554fd)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/svm/sev.c
diff --cc arch/x86/kvm/svm/sev.c
index 47046f928f5b,8b11c711a0e4..000000000000
--- a/arch/x86/kvm/svm/sev.c
+++ b/arch/x86/kvm/svm/sev.c
@@@ -1630,6 -1703,72 +1630,75 @@@ failed
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ int svm_vm_copy_asid_from(struct kvm *kvm, unsigned int source_fd)
+ {
+ 	struct file *source_kvm_file;
+ 	struct kvm *source_kvm;
+ 	struct kvm_sev_info *mirror_sev;
+ 	unsigned int asid;
+ 	int ret;
+ 
+ 	source_kvm_file = fget(source_fd);
+ 	if (!file_is_kvm(source_kvm_file)) {
+ 		ret = -EBADF;
+ 		goto e_source_put;
+ 	}
+ 
+ 	source_kvm = source_kvm_file->private_data;
+ 	mutex_lock(&source_kvm->lock);
+ 
+ 	if (!sev_guest(source_kvm)) {
+ 		ret = -EINVAL;
+ 		goto e_source_unlock;
+ 	}
+ 
+ 	/* Mirrors of mirrors should work, but let's not get silly */
+ 	if (is_mirroring_enc_context(source_kvm) || source_kvm == kvm) {
+ 		ret = -EINVAL;
+ 		goto e_source_unlock;
+ 	}
+ 
+ 	asid = to_kvm_svm(source_kvm)->sev_info.asid;
+ 
+ 	/*
+ 	 * The mirror kvm holds an enc_context_owner ref so its asid can't
+ 	 * disappear until we're done with it
+ 	 */
+ 	kvm_get_kvm(source_kvm);
+ 
+ 	fput(source_kvm_file);
+ 	mutex_unlock(&source_kvm->lock);
+ 	mutex_lock(&kvm->lock);
+ 
+ 	if (sev_guest(kvm)) {
+ 		ret = -EINVAL;
+ 		goto e_mirror_unlock;
+ 	}
+ 
+ 	/* Set enc_context_owner and copy its encryption context over */
+ 	mirror_sev = &to_kvm_svm(kvm)->sev_info;
+ 	mirror_sev->enc_context_owner = source_kvm;
+ 	mirror_sev->asid = asid;
+ 	mirror_sev->active = true;
+ 
+ 	mutex_unlock(&kvm->lock);
+ 	return 0;
+ 
+ e_mirror_unlock:
+ 	mutex_unlock(&kvm->lock);
+ 	kvm_put_kvm(source_kvm);
+ 	return ret;
+ e_source_unlock:
+ 	mutex_unlock(&source_kvm->lock);
+ e_source_put:
+ 	if (source_kvm_file)
+ 		fput(source_kvm_file);
+ 	return ret;
+ }
+ 
++>>>>>>> 8899a5fc7da5 (KVM: x86: Fix potential fput on a null source_kvm_file)
  void sev_vm_destroy(struct kvm *kvm)
  {
  	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
* Unmerged path arch/x86/kvm/svm/sev.c
