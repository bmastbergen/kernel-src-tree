cifs: simplify handling of cifs_sb/ctx->local_nls

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Ronnie Sahlberg <lsahlber@redhat.com>
commit 387ec58f339b0c45e3767395f11fa8dd3772131e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/387ec58f.failed

Only load/unload local_nls from cifs_sb and just make the ctx
contain a pointer to cifs_sb->ctx.

	Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 387ec58f339b0c45e3767395f11fa8dd3772131e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/fs_context.c
diff --cc fs/cifs/fs_context.c
index 84354cd4c960,c3c6d0cd291b..000000000000
--- a/fs/cifs/fs_context.c
+++ b/fs/cifs/fs_context.c
@@@ -239,7 -303,7 +239,11 @@@ smb3_fs_context_dup(struct smb3_fs_cont
  
  	memcpy(new_ctx, ctx, sizeof(*ctx));
  	new_ctx->prepath = NULL;
++<<<<<<< HEAD
 +	new_ctx->local_nls = NULL;
++=======
+ 	new_ctx->mount_options = NULL;
++>>>>>>> 387ec58f339b (cifs: simplify handling of cifs_sb/ctx->local_nls)
  	new_ctx->nodename = NULL;
  	new_ctx->username = NULL;
  	new_ctx->password = NULL;
@@@ -316,3 -452,910 +320,913 @@@ smb3_parse_devname(const char *devname
  
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static void smb3_fs_context_free(struct fs_context *fc);
+ static int smb3_fs_context_parse_param(struct fs_context *fc,
+ 				       struct fs_parameter *param);
+ static int smb3_fs_context_parse_monolithic(struct fs_context *fc,
+ 					    void *data);
+ static int smb3_get_tree(struct fs_context *fc);
+ static int smb3_reconfigure(struct fs_context *fc);
+ 
+ static const struct fs_context_operations smb3_fs_context_ops = {
+ 	.free			= smb3_fs_context_free,
+ 	.parse_param		= smb3_fs_context_parse_param,
+ 	.parse_monolithic	= smb3_fs_context_parse_monolithic,
+ 	.get_tree		= smb3_get_tree,
+ 	.reconfigure		= smb3_reconfigure,
+ };
+ 
+ /*
+  * Parse a monolithic block of data from sys_mount().
+  * smb3_fs_context_parse_monolithic - Parse key[=val][,key[=val]]* mount data
+  * @ctx: The superblock configuration to fill in.
+  * @data: The data to parse
+  *
+  * Parse a blob of data that's in key[=val][,key[=val]]* form.  This can be
+  * called from the ->monolithic_mount_data() fs_context operation.
+  *
+  * Returns 0 on success or the error returned by the ->parse_option() fs_context
+  * operation on failure.
+  */
+ static int smb3_fs_context_parse_monolithic(struct fs_context *fc,
+ 					   void *data)
+ {
+ 	struct smb3_fs_context *ctx = smb3_fc2context(fc);
+ 	char *options = data, *key;
+ 	int ret = 0;
+ 
+ 	if (!options)
+ 		return 0;
+ 
+ 	ctx->mount_options = kstrdup(data, GFP_KERNEL);
+ 	if (ctx->mount_options == NULL)
+ 		return -ENOMEM;
+ 
+ 	ret = security_sb_eat_lsm_opts(options, &fc->security);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* BB Need to add support for sep= here TBD */
+ 	while ((key = strsep(&options, ",")) != NULL) {
+ 		if (*key) {
+ 			size_t v_len = 0;
+ 			char *value = strchr(key, '=');
+ 
+ 			if (value) {
+ 				if (value == key)
+ 					continue;
+ 				*value++ = 0;
+ 				v_len = strlen(value);
+ 			}
+ 			ret = vfs_parse_fs_string(fc, key, value, v_len);
+ 			if (ret < 0)
+ 				break;
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ /*
+  * Validate the preparsed information in the config.
+  */
+ static int smb3_fs_context_validate(struct fs_context *fc)
+ {
+ 	struct smb3_fs_context *ctx = smb3_fc2context(fc);
+ 
+ 	if (ctx->rdma && ctx->vals->protocol_id < SMB30_PROT_ID) {
+ 		cifs_dbg(VFS, "SMB Direct requires Version >=3.0\n");
+ 		return -1;
+ 	}
+ 
+ #ifndef CONFIG_KEYS
+ 	/* Muliuser mounts require CONFIG_KEYS support */
+ 	if (ctx->multiuser) {
+ 		cifs_dbg(VFS, "Multiuser mounts require kernels with CONFIG_KEYS enabled\n");
+ 		return -1;
+ 	}
+ #endif
+ 
+ 	if (ctx->got_version == false)
+ 		pr_warn_once("No dialect specified on mount. Default has changed to a more secure dialect, SMB2.1 or later (e.g. SMB3.1.1), from CIFS (SMB1). To use the less secure SMB1 dialect to access old servers which do not support SMB3.1.1 (or even SMB3 or SMB2.1) specify vers=1.0 on mount.\n");
+ 
+ 
+ 	if (!ctx->UNC) {
+ 		cifs_dbg(VFS, "CIFS mount error: No usable UNC path provided in device string!\n");
+ 		return -1;
+ 	}
+ 
+ 	/* make sure UNC has a share name */
+ 	if (strlen(ctx->UNC) < 3 || !strchr(ctx->UNC + 3, '\\')) {
+ 		cifs_dbg(VFS, "Malformed UNC. Unable to find share name.\n");
+ 		return -1;
+ 	}
+ 
+ 	if (!ctx->got_ip) {
+ 		int len;
+ 		const char *slash;
+ 
+ 		/* No ip= option specified? Try to get it from UNC */
+ 		/* Use the address part of the UNC. */
+ 		slash = strchr(&ctx->UNC[2], '\\');
+ 		len = slash - &ctx->UNC[2];
+ 		if (!cifs_convert_address((struct sockaddr *)&ctx->dstaddr,
+ 					  &ctx->UNC[2], len)) {
+ 			pr_err("Unable to determine destination address\n");
+ 			return -1;
+ 		}
+ 	}
+ 
+ 	/* set the port that we got earlier */
+ 	cifs_set_port((struct sockaddr *)&ctx->dstaddr, ctx->port);
+ 
+ 	if (ctx->override_uid && !ctx->uid_specified) {
+ 		ctx->override_uid = 0;
+ 		pr_notice("ignoring forceuid mount option specified with no uid= option\n");
+ 	}
+ 
+ 	if (ctx->override_gid && !ctx->gid_specified) {
+ 		ctx->override_gid = 0;
+ 		pr_notice("ignoring forcegid mount option specified with no gid= option\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int smb3_get_tree_common(struct fs_context *fc)
+ {
+ 	struct smb3_fs_context *ctx = smb3_fc2context(fc);
+ 	struct dentry *root;
+ 	int rc = 0;
+ 
+ 	root = cifs_smb3_do_mount(fc->fs_type, 0, ctx);
+ 	if (IS_ERR(root))
+ 		return PTR_ERR(root);
+ 
+ 	fc->root = root;
+ 
+ 	return rc;
+ }
+ 
+ /*
+  * Create an SMB3 superblock from the parameters passed.
+  */
+ static int smb3_get_tree(struct fs_context *fc)
+ {
+ 	int err = smb3_fs_context_validate(fc);
+ 
+ 	if (err)
+ 		return err;
+ 	return smb3_get_tree_common(fc);
+ }
+ 
+ static void smb3_fs_context_free(struct fs_context *fc)
+ {
+ 	struct smb3_fs_context *ctx = smb3_fc2context(fc);
+ 
+ 	smb3_cleanup_fs_context(ctx);
+ }
+ 
+ /*
+  * Compare the old and new proposed context during reconfigure
+  * and check if the changes are compatible.
+  */
+ static int smb3_verify_reconfigure_ctx(struct smb3_fs_context *new_ctx,
+ 				       struct smb3_fs_context *old_ctx)
+ {
+ 	if (new_ctx->sectype != old_ctx->sectype) {
+ 		cifs_dbg(VFS, "can not change sec during remount\n");
+ 		return -EINVAL;
+ 	}
+ 	if (new_ctx->multiuser != old_ctx->multiuser) {
+ 		cifs_dbg(VFS, "can not change multiuser during remount\n");
+ 		return -EINVAL;
+ 	}
+ 	if (new_ctx->UNC &&
+ 	    (!old_ctx->UNC || strcmp(new_ctx->UNC, old_ctx->UNC))) {
+ 		cifs_dbg(VFS, "can not change UNC during remount\n");
+ 		return -EINVAL;
+ 	}
+ 	if (new_ctx->username &&
+ 	    (!old_ctx->username || strcmp(new_ctx->username, old_ctx->username))) {
+ 		cifs_dbg(VFS, "can not change username during remount\n");
+ 		return -EINVAL;
+ 	}
+ 	if (new_ctx->password &&
+ 	    (!old_ctx->password || strcmp(new_ctx->password, old_ctx->password))) {
+ 		cifs_dbg(VFS, "can not change password during remount\n");
+ 		return -EINVAL;
+ 	}
+ 	if (new_ctx->domainname &&
+ 	    (!old_ctx->domainname || strcmp(new_ctx->domainname, old_ctx->domainname))) {
+ 		cifs_dbg(VFS, "can not change domainname during remount\n");
+ 		return -EINVAL;
+ 	}
+ 	if (new_ctx->nodename &&
+ 	    (!old_ctx->nodename || strcmp(new_ctx->nodename, old_ctx->nodename))) {
+ 		cifs_dbg(VFS, "can not change nodename during remount\n");
+ 		return -EINVAL;
+ 	}
+ 	if (new_ctx->iocharset &&
+ 	    (!old_ctx->iocharset || strcmp(new_ctx->iocharset, old_ctx->iocharset))) {
+ 		cifs_dbg(VFS, "can not change iocharset during remount\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ #define STEAL_STRING(cifs_sb, ctx, field)				\
+ do {									\
+ 	kfree(ctx->field);						\
+ 	ctx->field = cifs_sb->ctx->field;				\
+ 	cifs_sb->ctx->field = NULL;					\
+ } while (0)
+ 
+ static int smb3_reconfigure(struct fs_context *fc)
+ {
+ 	struct smb3_fs_context *ctx = smb3_fc2context(fc);
+ 	struct dentry *root = fc->root;
+ 	struct cifs_sb_info *cifs_sb = CIFS_SB(root->d_sb);
+ 	int rc;
+ 
+ 	rc = smb3_verify_reconfigure_ctx(ctx, cifs_sb->ctx);
+ 	if (rc)
+ 		return rc;
+ 
+ 	/*
+ 	 * We can not change UNC/username/password/domainname/nodename/iocharset
+ 	 * during reconnect so ignore what we have in the new context and
+ 	 * just use what we already have in cifs_sb->ctx.
+ 	 */
+ 	STEAL_STRING(cifs_sb, ctx, UNC);
+ 	STEAL_STRING(cifs_sb, ctx, username);
+ 	STEAL_STRING(cifs_sb, ctx, password);
+ 	STEAL_STRING(cifs_sb, ctx, domainname);
+ 	STEAL_STRING(cifs_sb, ctx, nodename);
+ 	STEAL_STRING(cifs_sb, ctx, iocharset);
+ 
+ 	smb3_cleanup_fs_context_contents(cifs_sb->ctx);
+ 	rc = smb3_fs_context_dup(cifs_sb->ctx, ctx);
+ 
+ 	return rc;
+ }
+ 
+ static int smb3_fs_context_parse_param(struct fs_context *fc,
+ 				      struct fs_parameter *param)
+ {
+ 	struct fs_parse_result result;
+ 	struct smb3_fs_context *ctx = smb3_fc2context(fc);
+ 	int i, opt;
+ 	bool is_smb3 = !strcmp(fc->fs_type->name, "smb3");
+ 	bool skip_parsing = false;
+ 
+ 	cifs_dbg(FYI, "CIFS: parsing cifs mount option '%s'\n", param->key);
+ 
+ 	/*
+ 	 * fs_parse can not handle string options with an empty value so
+ 	 * we will need special handling of them.
+ 	 */
+ 	if (param->type == fs_value_is_string && param->string[0] == 0) {
+ 		if (!strcmp("pass", param->key) || !strcmp("password", param->key))
+ 			skip_parsing = true;
+ 	}
+ 
+ 	if (!skip_parsing) {
+ 		opt = fs_parse(fc, smb3_fs_parameters, param, &result);
+ 		if (opt < 0)
+ 			return ctx->sloppy ? 1 : opt;
+ 	}
+ 
+ 	switch (opt) {
+ 	case Opt_compress:
+ 		ctx->compression = UNKNOWN_TYPE;
+ 		cifs_dbg(VFS,
+ 			"SMB3 compression support is experimental\n");
+ 		break;
+ 	case Opt_nodfs:
+ 		ctx->nodfs = 1;
+ 		break;
+ 	case Opt_hard:
+ 		if (result.negated)
+ 			ctx->retry = 0;
+ 		else
+ 			ctx->retry = 1;
+ 		break;
+ 	case Opt_soft:
+ 		if (result.negated)
+ 			ctx->retry = 1;
+ 		else
+ 			ctx->retry = 0;
+ 		break;
+ 	case Opt_mapposix:
+ 		if (result.negated)
+ 			ctx->remap = false;
+ 		else {
+ 			ctx->remap = true;
+ 			ctx->sfu_remap = false; /* disable SFU mapping */
+ 		}
+ 		break;
+ 	case Opt_user_xattr:
+ 		if (result.negated)
+ 			ctx->no_xattr = 1;
+ 		else
+ 			ctx->no_xattr = 0;
+ 		break;
+ 	case Opt_forceuid:
+ 		if (result.negated)
+ 			ctx->override_uid = 0;
+ 		else
+ 			ctx->override_uid = 1;
+ 		break;
+ 	case Opt_forcegid:
+ 		if (result.negated)
+ 			ctx->override_gid = 0;
+ 		else
+ 			ctx->override_gid = 1;
+ 		break;
+ 	case Opt_perm:
+ 		if (result.negated)
+ 			ctx->noperm = 1;
+ 		else
+ 			ctx->noperm = 0;
+ 		break;
+ 	case Opt_dynperm:
+ 		if (result.negated)
+ 			ctx->dynperm = 0;
+ 		else
+ 			ctx->dynperm = 1;
+ 		break;
+ 	case Opt_sfu:
+ 		if (result.negated)
+ 			ctx->sfu_emul = 0;
+ 		else
+ 			ctx->sfu_emul = 1;
+ 		break;
+ 	case Opt_noblocksend:
+ 		ctx->noblocksnd = 1;
+ 		break;
+ 	case Opt_noautotune:
+ 		ctx->noautotune = 1;
+ 		break;
+ 	case Opt_nolease:
+ 		ctx->no_lease = 1;
+ 		break;
+ 	case Opt_nodelete:
+ 		ctx->nodelete = 1;
+ 		break;
+ 	case Opt_multichannel:
+ 		if (result.negated) {
+ 			ctx->multichannel = false;
+ 			ctx->max_channels = 1;
+ 		} else {
+ 			ctx->multichannel = true;
+ 			/* if number of channels not specified, default to 2 */
+ 			if (ctx->max_channels < 2)
+ 				ctx->max_channels = 2;
+ 		}
+ 		break;
+ 	case Opt_uid:
+ 		ctx->linux_uid.val = result.uint_32;
+ 		ctx->uid_specified = true;
+ 		break;
+ 	case Opt_cruid:
+ 		ctx->cred_uid.val = result.uint_32;
+ 		break;
+ 	case Opt_backupgid:
+ 		ctx->backupgid.val = result.uint_32;
+ 		ctx->backupgid_specified = true;
+ 		break;
+ 	case Opt_gid:
+ 		ctx->linux_gid.val = result.uint_32;
+ 		ctx->gid_specified = true;
+ 		break;
+ 	case Opt_port:
+ 		ctx->port = result.uint_32;
+ 		break;
+ 	case Opt_file_mode:
+ 		ctx->file_mode = result.uint_32;
+ 		break;
+ 	case Opt_dirmode:
+ 		ctx->dir_mode = result.uint_32;
+ 		break;
+ 	case Opt_min_enc_offload:
+ 		ctx->min_offload = result.uint_32;
+ 		break;
+ 	case Opt_blocksize:
+ 		/*
+ 		 * inode blocksize realistically should never need to be
+ 		 * less than 16K or greater than 16M and default is 1MB.
+ 		 * Note that small inode block sizes (e.g. 64K) can lead
+ 		 * to very poor performance of common tools like cp and scp
+ 		 */
+ 		if ((result.uint_32 < CIFS_MAX_MSGSIZE) ||
+ 		   (result.uint_32 > (4 * SMB3_DEFAULT_IOSIZE))) {
+ 			cifs_dbg(VFS, "%s: Invalid blocksize\n",
+ 				__func__);
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		ctx->bsize = result.uint_32;
+ 		ctx->got_bsize = true;
+ 		break;
+ 	case Opt_rsize:
+ 		ctx->rsize = result.uint_32;
+ 		ctx->got_rsize = true;
+ 		break;
+ 	case Opt_wsize:
+ 		ctx->wsize = result.uint_32;
+ 		ctx->got_wsize = true;
+ 		break;
+ 	case Opt_actimeo:
+ 		ctx->actimeo = HZ * result.uint_32;
+ 		if (ctx->actimeo > CIFS_MAX_ACTIMEO) {
+ 			cifs_dbg(VFS, "attribute cache timeout too large\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		break;
+ 	case Opt_echo_interval:
+ 		ctx->echo_interval = result.uint_32;
+ 		break;
+ 	case Opt_snapshot:
+ 		ctx->snapshot_time = result.uint_32;
+ 		break;
+ 	case Opt_max_credits:
+ 		if (result.uint_32 < 20 || result.uint_32 > 60000) {
+ 			cifs_dbg(VFS, "%s: Invalid max_credits value\n",
+ 				 __func__);
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		ctx->max_credits = result.uint_32;
+ 		break;
+ 	case Opt_max_channels:
+ 		if (result.uint_32 < 1 || result.uint_32 > CIFS_MAX_CHANNELS) {
+ 			cifs_dbg(VFS, "%s: Invalid max_channels value, needs to be 1-%d\n",
+ 				 __func__, CIFS_MAX_CHANNELS);
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		ctx->max_channels = result.uint_32;
+ 		break;
+ 	case Opt_handletimeout:
+ 		ctx->handle_timeout = result.uint_32;
+ 		if (ctx->handle_timeout > SMB3_MAX_HANDLE_TIMEOUT) {
+ 			cifs_dbg(VFS, "Invalid handle cache timeout, longer than 16 minutes\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		break;
+ 	case Opt_source:
+ 		kfree(ctx->UNC);
+ 		ctx->UNC = NULL;
+ 		switch (smb3_parse_devname(param->string, ctx)) {
+ 		case 0:
+ 			break;
+ 		case -ENOMEM:
+ 			cifs_dbg(VFS, "Unable to allocate memory for devname\n");
+ 			goto cifs_parse_mount_err;
+ 		case -EINVAL:
+ 			cifs_dbg(VFS, "Malformed UNC in devname\n");
+ 			goto cifs_parse_mount_err;
+ 		default:
+ 			cifs_dbg(VFS, "Unknown error parsing devname\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		fc->source = kstrdup(param->string, GFP_KERNEL);
+ 		if (fc->source == NULL) {
+ 			cifs_dbg(VFS, "OOM when copying UNC string\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		break;
+ 	case Opt_user:
+ 		kfree(ctx->username);
+ 		ctx->username = NULL;
+ 		if (strlen(param->string) == 0) {
+ 			/* null user, ie. anonymous authentication */
+ 			ctx->nullauth = 1;
+ 			break;
+ 		}
+ 
+ 		if (strnlen(param->string, CIFS_MAX_USERNAME_LEN) >
+ 		    CIFS_MAX_USERNAME_LEN) {
+ 			pr_warn("username too long\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		ctx->username = kstrdup(param->string, GFP_KERNEL);
+ 		if (ctx->username == NULL) {
+ 			cifs_dbg(VFS, "OOM when copying username string\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		break;
+ 	case Opt_pass:
+ 		kfree(ctx->password);
+ 		ctx->password = NULL;
+ 		if (strlen(param->string) == 0)
+ 			break;
+ 
+ 		ctx->password = kstrdup(param->string, GFP_KERNEL);
+ 		if (ctx->password == NULL) {
+ 			cifs_dbg(VFS, "OOM when copying password string\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		break;
+ 	case Opt_ip:
+ 		if (strlen(param->string) == 0) {
+ 			ctx->got_ip = false;
+ 			break;
+ 		}
+ 		if (!cifs_convert_address((struct sockaddr *)&ctx->dstaddr,
+ 					  param->string,
+ 					  strlen(param->string))) {
+ 			pr_err("bad ip= option (%s)\n", param->string);
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		ctx->got_ip = true;
+ 		break;
+ 	case Opt_domain:
+ 		if (strnlen(param->string, CIFS_MAX_DOMAINNAME_LEN)
+ 				== CIFS_MAX_DOMAINNAME_LEN) {
+ 			pr_warn("domain name too long\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 
+ 		kfree(ctx->domainname);
+ 		ctx->domainname = kstrdup(param->string, GFP_KERNEL);
+ 		if (ctx->domainname == NULL) {
+ 			cifs_dbg(VFS, "OOM when copying domainname string\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		cifs_dbg(FYI, "Domain name set\n");
+ 		break;
+ 	case Opt_srcaddr:
+ 		if (!cifs_convert_address(
+ 				(struct sockaddr *)&ctx->srcaddr,
+ 				param->string, strlen(param->string))) {
+ 			pr_warn("Could not parse srcaddr: %s\n",
+ 				param->string);
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		break;
+ 	case Opt_iocharset:
+ 		if (strnlen(param->string, 1024) >= 65) {
+ 			pr_warn("iocharset name too long\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 
+ 		if (strncasecmp(param->string, "default", 7) != 0) {
+ 			kfree(ctx->iocharset);
+ 			ctx->iocharset = kstrdup(param->string, GFP_KERNEL);
+ 			if (ctx->iocharset == NULL) {
+ 				cifs_dbg(VFS, "OOM when copying iocharset string\n");
+ 				goto cifs_parse_mount_err;
+ 			}
+ 		}
+ 		/* if iocharset not set then load_nls_default
+ 		 * is used by caller
+ 		 */
+ 		 cifs_dbg(FYI, "iocharset set to %s\n", ctx->iocharset);
+ 		break;
+ 	case Opt_netbiosname:
+ 		memset(ctx->source_rfc1001_name, 0x20,
+ 			RFC1001_NAME_LEN);
+ 		/*
+ 		 * FIXME: are there cases in which a comma can
+ 		 * be valid in workstation netbios name (and
+ 		 * need special handling)?
+ 		 */
+ 		for (i = 0; i < RFC1001_NAME_LEN; i++) {
+ 			/* don't ucase netbiosname for user */
+ 			if (param->string[i] == 0)
+ 				break;
+ 			ctx->source_rfc1001_name[i] = param->string[i];
+ 		}
+ 		/* The string has 16th byte zero still from
+ 		 * set at top of the function
+ 		 */
+ 		if (i == RFC1001_NAME_LEN && param->string[i] != 0)
+ 			pr_warn("netbiosname longer than 15 truncated\n");
+ 		break;
+ 	case Opt_servern:
+ 		/* last byte, type, is 0x20 for servr type */
+ 		memset(ctx->target_rfc1001_name, 0x20,
+ 			RFC1001_NAME_LEN_WITH_NULL);
+ 		/*
+ 		 * BB are there cases in which a comma can be valid in this
+ 		 * workstation netbios name (and need special handling)?
+ 		 */
+ 
+ 		/* user or mount helper must uppercase the netbios name */
+ 		for (i = 0; i < 15; i++) {
+ 			if (param->string[i] == 0)
+ 				break;
+ 			ctx->target_rfc1001_name[i] = param->string[i];
+ 		}
+ 
+ 		/* The string has 16th byte zero still from set at top of function */
+ 		if (i == RFC1001_NAME_LEN && param->string[i] != 0)
+ 			pr_warn("server netbiosname longer than 15 truncated\n");
+ 		break;
+ 	case Opt_ver:
+ 		/* version of mount userspace tools, not dialect */
+ 		/* If interface changes in mount.cifs bump to new ver */
+ 		if (strncasecmp(param->string, "1", 1) == 0) {
+ 			if (strlen(param->string) > 1) {
+ 				pr_warn("Bad mount helper ver=%s. Did you want SMB1 (CIFS) dialect and mean to type vers=1.0 instead?\n",
+ 					param->string);
+ 				goto cifs_parse_mount_err;
+ 			}
+ 			/* This is the default */
+ 			break;
+ 		}
+ 		/* For all other value, error */
+ 		pr_warn("Invalid mount helper version specified\n");
+ 		goto cifs_parse_mount_err;
+ 	case Opt_vers:
+ 		/* protocol version (dialect) */
+ 		if (cifs_parse_smb_version(param->string, ctx, is_smb3) != 0)
+ 			goto cifs_parse_mount_err;
+ 		ctx->got_version = true;
+ 		break;
+ 	case Opt_sec:
+ 		if (cifs_parse_security_flavors(param->string, ctx) != 0)
+ 			goto cifs_parse_mount_err;
+ 		break;
+ 	case Opt_cache:
+ 		if (cifs_parse_cache_flavor(param->string, ctx) != 0)
+ 			goto cifs_parse_mount_err;
+ 		break;
+ 	case Opt_witness:
+ #ifndef CONFIG_CIFS_SWN_UPCALL
+ 		cifs_dbg(VFS, "Witness support needs CONFIG_CIFS_SWN_UPCALL config option\n");
+ 			goto cifs_parse_mount_err;
+ #endif
+ 		ctx->witness = true;
+ 		break;
+ 	case Opt_rootfs:
+ #ifdef CONFIG_CIFS_ROOT
+ 		ctx->rootfs = true;
+ #endif
+ 		break;
+ 	case Opt_posixpaths:
+ 		if (result.negated)
+ 			ctx->posix_paths = 0;
+ 		else
+ 			ctx->posix_paths = 1;
+ 		break;
+ 	case Opt_unix:
+ 		if (result.negated)
+ 			ctx->linux_ext = 0;
+ 		else
+ 			ctx->no_linux_ext = 1;
+ 		break;
+ 	case Opt_nocase:
+ 		ctx->nocase = 1;
+ 		break;
+ 	case Opt_brl:
+ 		if (result.negated) {
+ 			/*
+ 			 * turn off mandatory locking in mode
+ 			 * if remote locking is turned off since the
+ 			 * local vfs will do advisory
+ 			 */
+ 			if (ctx->file_mode ==
+ 				(S_IALLUGO & ~(S_ISUID | S_IXGRP)))
+ 				ctx->file_mode = S_IALLUGO;
+ 			ctx->nobrl =  1;
+ 		} else
+ 			ctx->nobrl =  0;
+ 		break;
+ 	case Opt_handlecache:
+ 		if (result.negated)
+ 			ctx->nohandlecache = 1;
+ 		else
+ 			ctx->nohandlecache = 0;
+ 		break;
+ 	case Opt_forcemandatorylock:
+ 		ctx->mand_lock = 1;
+ 		break;
+ 	case Opt_setuids:
+ 		ctx->setuids = result.negated;
+ 		break;
+ 	case Opt_intr:
+ 		ctx->intr = !result.negated;
+ 		break;
+ 	case Opt_setuidfromacl:
+ 		ctx->setuidfromacl = 1;
+ 		break;
+ 	case Opt_strictsync:
+ 		ctx->nostrictsync = result.negated;
+ 		break;
+ 	case Opt_serverino:
+ 		ctx->server_ino = !result.negated;
+ 		break;
+ 	case Opt_rwpidforward:
+ 		ctx->rwpidforward = 1;
+ 		break;
+ 	case Opt_modesid:
+ 		ctx->mode_ace = 1;
+ 		break;
+ 	case Opt_cifsacl:
+ 		ctx->cifs_acl = !result.negated;
+ 		break;
+ 	case Opt_acl:
+ 		ctx->no_psx_acl = result.negated;
+ 		break;
+ 	case Opt_locallease:
+ 		ctx->local_lease = 1;
+ 		break;
+ 	case Opt_sign:
+ 		ctx->sign = true;
+ 		break;
+ 	case Opt_ignore_signature:
+ 		ctx->sign = true;
+ 		ctx->ignore_signature = true;
+ 		break;
+ 	case Opt_seal:
+ 		/* we do not do the following in secFlags because seal
+ 		 * is a per tree connection (mount) not a per socket
+ 		 * or per-smb connection option in the protocol
+ 		 * vol->secFlg |= CIFSSEC_MUST_SEAL;
+ 		 */
+ 		ctx->seal = 1;
+ 		break;
+ 	case Opt_noac:
+ 		pr_warn("Mount option noac not supported. Instead set /proc/fs/cifs/LookupCacheEnabled to 0\n");
+ 		break;
+ 	case Opt_fsc:
+ #ifndef CONFIG_CIFS_FSCACHE
+ 		cifs_dbg(VFS, "FS-Cache support needs CONFIG_CIFS_FSCACHE kernel config option set\n");
+ 		goto cifs_parse_mount_err;
+ #endif
+ 		ctx->fsc = true;
+ 		break;
+ 	case Opt_mfsymlinks:
+ 		ctx->mfsymlinks = true;
+ 		break;
+ 	case Opt_multiuser:
+ 		ctx->multiuser = true;
+ 		break;
+ 	case Opt_sloppy:
+ 		ctx->sloppy = true;
+ 		break;
+ 	case Opt_nosharesock:
+ 		ctx->nosharesock = true;
+ 		break;
+ 	case Opt_persistent:
+ 		if (result.negated) {
+ 			if ((ctx->nopersistent) || (ctx->resilient)) {
+ 				cifs_dbg(VFS,
+ 				  "persistenthandles mount options conflict\n");
+ 				goto cifs_parse_mount_err;
+ 			}
+ 		} else {
+ 			ctx->nopersistent = true;
+ 			if (ctx->persistent) {
+ 				cifs_dbg(VFS,
+ 				  "persistenthandles mount options conflict\n");
+ 				goto cifs_parse_mount_err;
+ 			}
+ 		}
+ 		break;
+ 	case Opt_resilient:
+ 		if (result.negated) {
+ 			ctx->resilient = false; /* already the default */
+ 		} else {
+ 			ctx->resilient = true;
+ 			if (ctx->persistent) {
+ 				cifs_dbg(VFS,
+ 				  "persistenthandles mount options conflict\n");
+ 				goto cifs_parse_mount_err;
+ 			}
+ 		}
+ 		break;
+ 	case Opt_domainauto:
+ 		ctx->domainauto = true;
+ 		break;
+ 	case Opt_rdma:
+ 		ctx->rdma = true;
+ 		break;
+ 	}
+ 
+ 	return 0;
+ 
+  cifs_parse_mount_err:
+ 	return 1;
+ }
+ 
+ int smb3_init_fs_context(struct fs_context *fc)
+ {
+ 	struct smb3_fs_context *ctx;
+ 	char *nodename = utsname()->nodename;
+ 	int i;
+ 
+ 	ctx = kzalloc(sizeof(struct smb3_fs_context), GFP_KERNEL);
+ 	if (unlikely(!ctx))
+ 		return -ENOMEM;
+ 
+ 	/*
+ 	 * does not have to be perfect mapping since field is
+ 	 * informational, only used for servers that do not support
+ 	 * port 445 and it can be overridden at mount time
+ 	 */
+ 	memset(ctx->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);
+ 	for (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)
+ 		ctx->source_rfc1001_name[i] = toupper(nodename[i]);
+ 
+ 	ctx->source_rfc1001_name[RFC1001_NAME_LEN] = 0;
+ 	/*
+ 	 * null target name indicates to use *SMBSERVR default called name
+ 	 *  if we end up sending RFC1001 session initialize
+ 	 */
+ 	ctx->target_rfc1001_name[0] = 0;
+ 	ctx->cred_uid = current_uid();
+ 	ctx->linux_uid = current_uid();
+ 	ctx->linux_gid = current_gid();
+ 	ctx->bsize = 1024 * 1024; /* can improve cp performance significantly */
+ 
+ 	/*
+ 	 * default to SFM style remapping of seven reserved characters
+ 	 * unless user overrides it or we negotiate CIFS POSIX where
+ 	 * it is unnecessary.  Can not simultaneously use more than one mapping
+ 	 * since then readdir could list files that open could not open
+ 	 */
+ 	ctx->remap = true;
+ 
+ 	/* default to only allowing write access to owner of the mount */
+ 	ctx->dir_mode = ctx->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;
+ 
+ 	/* ctx->retry default is 0 (i.e. "soft" limited retry not hard retry) */
+ 	/* default is always to request posix paths. */
+ 	ctx->posix_paths = 1;
+ 	/* default to using server inode numbers where available */
+ 	ctx->server_ino = 1;
+ 
+ 	/* default is to use strict cifs caching semantics */
+ 	ctx->strict_io = true;
+ 
+ 	ctx->actimeo = CIFS_DEF_ACTIMEO;
+ 
+ 	/* Most clients set timeout to 0, allows server to use its default */
+ 	ctx->handle_timeout = 0; /* See MS-SMB2 spec section 2.2.14.2.12 */
+ 
+ 	/* offer SMB2.1 and later (SMB3 etc). Secure and widely accepted */
+ 	ctx->ops = &smb30_operations;
+ 	ctx->vals = &smbdefault_values;
+ 
+ 	ctx->echo_interval = SMB_ECHO_INTERVAL_DEFAULT;
+ 
+ 	/* default to no multichannel (single server connection) */
+ 	ctx->multichannel = false;
+ 	ctx->max_channels = 1;
+ 
+ 	ctx->backupuid_specified = false; /* no backup intent for a user */
+ 	ctx->backupgid_specified = false; /* no backup intent for a group */
+ 
+ /*
+  *	short int override_uid = -1;
+  *	short int override_gid = -1;
+  *	char *nodename = strdup(utsname()->nodename);
+  *	struct sockaddr *dstaddr = (struct sockaddr *)&vol->dstaddr;
+  */
+ 
+ 	fc->fs_private = ctx;
+ 	fc->ops = &smb3_fs_context_ops;
+ 	return 0;
+ }
+ 
+ void
+ smb3_cleanup_fs_context_contents(struct smb3_fs_context *ctx)
+ {
+ 	if (ctx == NULL)
+ 		return;
+ 
+ 	/*
+ 	 * Make sure this stays in sync with smb3_fs_context_dup()
+ 	 */
+ 	kfree(ctx->mount_options);
+ 	ctx->mount_options = NULL;
+ 	kfree(ctx->username);
+ 	ctx->username = NULL;
+ 	kfree_sensitive(ctx->password);
+ 	ctx->password = NULL;
+ 	kfree(ctx->UNC);
+ 	ctx->UNC = NULL;
+ 	kfree(ctx->domainname);
+ 	ctx->domainname = NULL;
+ 	kfree(ctx->nodename);
+ 	ctx->nodename = NULL;
+ 	kfree(ctx->iocharset);
+ 	ctx->iocharset = NULL;
+ 	kfree(ctx->prepath);
+ 	ctx->prepath = NULL;
+ }
+ 
+ void
+ smb3_cleanup_fs_context(struct smb3_fs_context *ctx)
+ {
+ 	if (!ctx)
+ 		return;
+ 	smb3_cleanup_fs_context_contents(ctx);
+ 	kfree(ctx);
+ }
++>>>>>>> 387ec58f339b (cifs: simplify handling of cifs_sb/ctx->local_nls)
diff --git a/fs/cifs/cifsproto.h b/fs/cifs/cifsproto.h
index aa66a6b9aaf5..2b3292449e66 100644
--- a/fs/cifs/cifsproto.h
+++ b/fs/cifs/cifsproto.h
@@ -605,9 +605,7 @@ extern void rqst_page_get_length(struct smb_rqst *rqst, unsigned int page,
 				unsigned int *len, unsigned int *offset);
 struct cifs_chan *
 cifs_ses_find_chan(struct cifs_ses *ses, struct TCP_Server_Info *server);
-int cifs_try_adding_channels(struct cifs_ses *ses);
-int cifs_ses_add_channel(struct cifs_ses *ses,
-				struct cifs_server_iface *iface);
+int cifs_try_adding_channels(struct cifs_sb_info *cifs_sb, struct cifs_ses *ses);
 bool is_server_using_iface(struct TCP_Server_Info *server,
 			   struct cifs_server_iface *iface);
 bool is_ses_using_iface(struct cifs_ses *ses, struct cifs_server_iface *iface);
diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c
index b833d5b568a2..44606ca94d64 100644
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@ -3798,7 +3798,19 @@ int cifs_setup_cifs_sb(struct smb3_fs_context *ctx,
 	cifs_dbg(FYI, "file mode: %04ho  dir mode: %04ho\n",
 		 cifs_sb->ctx->file_mode, cifs_sb->ctx->dir_mode);
 
-	cifs_sb->local_nls = ctx->local_nls;
+	/* this is needed for ASCII cp to Unicode converts */
+	if (ctx->iocharset == NULL) {
+		/* load_nls_default cannot return null */
+		cifs_sb->local_nls = load_nls_default();
+	} else {
+		cifs_sb->local_nls = load_nls(ctx->iocharset);
+		if (cifs_sb->local_nls == NULL) {
+			cifs_dbg(VFS, "CIFS mount error: iocharset %s not found\n",
+				 ctx->iocharset);
+			return -ELIBACC;
+		}
+	}
+	ctx->local_nls = cifs_sb->local_nls;
 
 	if (ctx->nodfs)
 		cifs_sb->mnt_cifs_flags |= CIFS_MOUNT_NO_DFS;
@@ -4292,19 +4304,6 @@ cifs_setup_volume_info(struct smb3_fs_context *ctx, char *mount_data,
 		return -EINVAL;
 	}
 
-	/* this is needed for ASCII cp to Unicode converts */
-	if (ctx->iocharset == NULL) {
-		/* load_nls_default cannot return null */
-		ctx->local_nls = load_nls_default();
-	} else {
-		ctx->local_nls = load_nls(ctx->iocharset);
-		if (ctx->local_nls == NULL) {
-			cifs_dbg(VFS, "CIFS mount error: iocharset %s not found\n",
-				 ctx->iocharset);
-			return -ELIBACC;
-		}
-	}
-
 	return rc;
 }
 
@@ -4644,7 +4643,7 @@ int cifs_mount(struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx)
 
 out:
 	free_xid(xid);
-	cifs_try_adding_channels(ses);
+	cifs_try_adding_channels(cifs_sb, ses);
 	return mount_setup_tlink(cifs_sb, ses, tcon);
 
 error:
* Unmerged path fs/cifs/fs_context.c
diff --git a/fs/cifs/fs_context.h b/fs/cifs/fs_context.h
index 3a66199f3cb7..14219d265883 100644
--- a/fs/cifs/fs_context.h
+++ b/fs/cifs/fs_context.h
@@ -239,7 +239,7 @@ struct smb3_fs_context {
 	char *prepath;
 	struct sockaddr_storage dstaddr; /* destination address */
 	struct sockaddr_storage srcaddr; /* allow binding to a local IP */
-	struct nls_table *local_nls;
+	struct nls_table *local_nls; /* This is a copy of the pointer in cifs_sb */
 	unsigned int echo_interval; /* echo interval in secs */
 	__u64 snapshot_time; /* needed for timewarp tokens */
 	__u32 handle_timeout; /* persistent and durable handle timeout in ms */
diff --git a/fs/cifs/sess.c b/fs/cifs/sess.c
index e7892bc3eb6c..f716e1c2efd4 100644
--- a/fs/cifs/sess.c
+++ b/fs/cifs/sess.c
@@ -34,6 +34,10 @@
 #include "smb2proto.h"
 #include "fs_context.h"
 
+static int
+cifs_ses_add_channel(struct cifs_sb_info *cifs_sb, struct cifs_ses *ses,
+		     struct cifs_server_iface *iface);
+
 bool
 is_server_using_iface(struct TCP_Server_Info *server,
 		      struct cifs_server_iface *iface)
@@ -71,7 +75,7 @@ bool is_ses_using_iface(struct cifs_ses *ses, struct cifs_server_iface *iface)
 }
 
 /* returns number of channels added */
-int cifs_try_adding_channels(struct cifs_ses *ses)
+int cifs_try_adding_channels(struct cifs_sb_info *cifs_sb, struct cifs_ses *ses)
 {
 	int old_chan_count = ses->chan_count;
 	int left = ses->chan_max - ses->chan_count;
@@ -134,7 +138,7 @@ int cifs_try_adding_channels(struct cifs_ses *ses)
 			continue;
 		}
 
-		rc = cifs_ses_add_channel(ses, iface);
+		rc = cifs_ses_add_channel(cifs_sb, ses, iface);
 		if (rc) {
 			cifs_dbg(FYI, "failed to open extra channel on iface#%d rc=%d\n",
 				 i, rc);
@@ -167,8 +171,9 @@ cifs_ses_find_chan(struct cifs_ses *ses, struct TCP_Server_Info *server)
 	return NULL;
 }
 
-int
-cifs_ses_add_channel(struct cifs_ses *ses, struct cifs_server_iface *iface)
+static int
+cifs_ses_add_channel(struct cifs_sb_info *cifs_sb, struct cifs_ses *ses,
+		     struct cifs_server_iface *iface)
 {
 	struct cifs_chan *chan;
 	struct smb3_fs_context ctx = {NULL};
@@ -229,13 +234,8 @@ cifs_ses_add_channel(struct cifs_ses *ses, struct cifs_server_iface *iface)
 	/*
 	 * This will be used for encoding/decoding user/domain/pw
 	 * during sess setup auth.
-	 *
-	 * XXX: We use the default for simplicity but the proper way
-	 * would be to use the one that ses used, which is not
-	 * stored. This might break when dealing with non-ascii
-	 * strings.
 	 */
-	ctx.local_nls = load_nls_default();
+	ctx.local_nls = cifs_sb->local_nls;
 
 	/* Use RDMA if possible */
 	ctx.rdma = iface->rdma_capable;
@@ -275,7 +275,7 @@ cifs_ses_add_channel(struct cifs_ses *ses, struct cifs_server_iface *iface)
 	if (rc)
 		goto out;
 
-	rc = cifs_setup_session(xid, ses, ctx.local_nls);
+	rc = cifs_setup_session(xid, ses, cifs_sb->local_nls);
 	if (rc)
 		goto out;
 
@@ -298,7 +298,6 @@ cifs_ses_add_channel(struct cifs_ses *ses, struct cifs_server_iface *iface)
 
 	if (rc && chan->server)
 		cifs_put_tcp_session(chan->server, 0);
-	unload_nls(ctx.local_nls);
 
 	return rc;
 }
