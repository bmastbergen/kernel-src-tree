s390/qeth: allow configuration of TX queues for OSA devices

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 949bbf4d2db873a6c229a43d816d9f8152b31704
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/949bbf4d.failed

For OSA devices that are _not_ configured in prio-queue mode, give users
the option of selecting the number of active TX queues.
This requires setting up the HW queues with a reasonable default QoS
value in the QIB's PQUE parm area.

As with the other device types, we bring up the device with a minimal
number of TX queues for compatibility reasons.

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 949bbf4d2db873a6c229a43d816d9f8152b31704)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core.h
#	drivers/s390/net/qeth_core_main.c
#	drivers/s390/net/qeth_l2_main.c
#	drivers/s390/net/qeth_l3_main.c
diff --cc drivers/s390/net/qeth_core.h
index 4550380cb5d0,707a1634f621..000000000000
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@@ -278,6 -278,26 +278,29 @@@ struct qeth_hdr 
  	} hdr;
  } __attribute__ ((packed));
  
++<<<<<<< HEAD
++=======
+ #define QETH_QIB_PQUE_ORDER_RR		0
+ #define QETH_QIB_PQUE_UNITS_SBAL	2
+ #define QETH_QIB_PQUE_PRIO_DEFAULT	4
+ 
+ struct qeth_qib_parms {
+ 	char pcit_magic[4];
+ 	u32 pcit_a;
+ 	u32 pcit_b;
+ 	u32 pcit_c;
+ 	char blkt_magic[4];
+ 	u32 blkt_total;
+ 	u32 blkt_inter_packet;
+ 	u32 blkt_inter_packet_jumbo;
+ 	char pque_magic[4];
+ 	u8 pque_order;
+ 	u8 pque_units;
+ 	u16 reserved;
+ 	u32 pque_priority[4];
+ };
+ 
++>>>>>>> 949bbf4d2db8 (s390/qeth: allow configuration of TX queues for OSA devices)
  /*TCP Segmentation Offload header*/
  struct qeth_hdr_ext_tso {
  	__u16 hdr_tot_len;
@@@ -873,6 -895,21 +897,24 @@@ struct qeth_trap_id 
  /*some helper functions*/
  #define QETH_CARD_IFNAME(card) (((card)->dev)? (card)->dev->name : "")
  
++<<<<<<< HEAD
++=======
+ static inline bool qeth_uses_tx_prio_queueing(struct qeth_card *card)
+ {
+ 	return card->qdio.do_prio_queueing != QETH_NO_PRIO_QUEUEING;
+ }
+ 
+ static inline unsigned int qeth_tx_actual_queues(struct qeth_card *card)
+ {
+ 	struct qeth_priv *priv = netdev_priv(card->dev);
+ 
+ 	if (qeth_uses_tx_prio_queueing(card))
+ 		return min(card->dev->num_tx_queues, card->qdio.no_out_queues);
+ 
+ 	return min(priv->tx_wanted_queues, card->qdio.no_out_queues);
+ }
+ 
++>>>>>>> 949bbf4d2db8 (s390/qeth: allow configuration of TX queues for OSA devices)
  static inline u16 qeth_iqd_translate_txq(struct net_device *dev, u16 txq)
  {
  	if (txq == QETH_IQD_MCAST_TXQ)
diff --cc drivers/s390/net/qeth_core_main.c
index d384629799fe,9e9c229e2780..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -2757,30 -2744,44 +2758,68 @@@ static void qeth_free_qdio_queues(struc
  	}
  }
  
 -static void qeth_fill_qib_parms(struct qeth_card *card,
 -				struct qeth_qib_parms *parms)
 +static void qeth_create_qib_param_field(struct qeth_card *card,
 +		char *param_field)
  {
++<<<<<<< HEAD
 +
 +	param_field[0] = _ascebc['P'];
 +	param_field[1] = _ascebc['C'];
 +	param_field[2] = _ascebc['I'];
 +	param_field[3] = _ascebc['T'];
 +	*((unsigned int *) (&param_field[4])) = QETH_PCI_THRESHOLD_A(card);
 +	*((unsigned int *) (&param_field[8])) = QETH_PCI_THRESHOLD_B(card);
 +	*((unsigned int *) (&param_field[12])) = QETH_PCI_TIMER_VALUE(card);
 +}
 +
 +static void qeth_create_qib_param_field_blkt(struct qeth_card *card,
 +		char *param_field)
 +{
 +	param_field[16] = _ascebc['B'];
 +	param_field[17] = _ascebc['L'];
 +	param_field[18] = _ascebc['K'];
 +	param_field[19] = _ascebc['T'];
 +	*((unsigned int *) (&param_field[20])) = card->info.blkt.time_total;
 +	*((unsigned int *) (&param_field[24])) = card->info.blkt.inter_packet;
 +	*((unsigned int *) (&param_field[28])) =
 +		card->info.blkt.inter_packet_jumbo;
++=======
+ 	struct qeth_qdio_out_q *queue;
+ 	unsigned int i;
+ 
+ 	parms->pcit_magic[0] = 'P';
+ 	parms->pcit_magic[1] = 'C';
+ 	parms->pcit_magic[2] = 'I';
+ 	parms->pcit_magic[3] = 'T';
+ 	ASCEBC(parms->pcit_magic, sizeof(parms->pcit_magic));
+ 	parms->pcit_a = QETH_PCI_THRESHOLD_A(card);
+ 	parms->pcit_b = QETH_PCI_THRESHOLD_B(card);
+ 	parms->pcit_c = QETH_PCI_TIMER_VALUE(card);
+ 
+ 	parms->blkt_magic[0] = 'B';
+ 	parms->blkt_magic[1] = 'L';
+ 	parms->blkt_magic[2] = 'K';
+ 	parms->blkt_magic[3] = 'T';
+ 	ASCEBC(parms->blkt_magic, sizeof(parms->blkt_magic));
+ 	parms->blkt_total = card->info.blkt.time_total;
+ 	parms->blkt_inter_packet = card->info.blkt.inter_packet;
+ 	parms->blkt_inter_packet_jumbo = card->info.blkt.inter_packet_jumbo;
+ 
+ 	/* Prio-queueing implicitly uses the default priorities: */
+ 	if (qeth_uses_tx_prio_queueing(card) || card->qdio.no_out_queues == 1)
+ 		return;
+ 
+ 	parms->pque_magic[0] = 'P';
+ 	parms->pque_magic[1] = 'Q';
+ 	parms->pque_magic[2] = 'U';
+ 	parms->pque_magic[3] = 'E';
+ 	ASCEBC(parms->pque_magic, sizeof(parms->pque_magic));
+ 	parms->pque_order = QETH_QIB_PQUE_ORDER_RR;
+ 	parms->pque_units = QETH_QIB_PQUE_UNITS_SBAL;
+ 
+ 	qeth_for_each_output_queue(card, queue, i)
+ 		parms->pque_priority[i] = queue->priority;
++>>>>>>> 949bbf4d2db8 (s390/qeth: allow configuration of TX queues for OSA devices)
  }
  
  static int qeth_qdio_activate(struct qeth_card *card)
@@@ -5317,6 -5317,10 +5356,13 @@@ static int qeth_set_online(struct qeth_
  
  	qeth_print_status_message(card);
  
++<<<<<<< HEAD
++=======
+ 	if (card->dev->reg_state != NETREG_REGISTERED)
+ 		/* no need for locking / error handling at this early stage: */
+ 		qeth_set_real_num_tx_queues(card, qeth_tx_actual_queues(card));
+ 
++>>>>>>> 949bbf4d2db8 (s390/qeth: allow configuration of TX queues for OSA devices)
  	rc = card->discipline->set_online(card, carrier_ok);
  	if (rc)
  		goto err_online;
diff --cc drivers/s390/net/qeth_l2_main.c
index c683634669dd,c0ceeddd1549..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -582,50 -570,11 +582,58 @@@ static u16 qeth_l2_select_queue(struct 
  	if (IS_IQD(card))
  		return qeth_iqd_select_queue(dev, skb,
  					     qeth_get_ether_cast_type(skb),
++<<<<<<< HEAD
 +					     sb_dev, fallback);
 +
 +	return IS_VM_NIC(card) ? fallback(dev, skb, sb_dev) :
 +				 qeth_get_priority_queue(card, skb);
++=======
+ 					     sb_dev);
+ 	if (qeth_uses_tx_prio_queueing(card))
+ 		return qeth_get_priority_queue(card, skb);
+ 
+ 	return netdev_pick_tx(dev, skb, sb_dev);
++>>>>>>> 949bbf4d2db8 (s390/qeth: allow configuration of TX queues for OSA devices)
 +}
 +
 +static const struct device_type qeth_l2_devtype = {
 +	.name = "qeth_layer2",
 +	.groups = qeth_l2_attr_groups,
 +};
 +
 +static int qeth_l2_probe_device(struct ccwgroup_device *gdev)
 +{
 +	struct qeth_card *card = dev_get_drvdata(&gdev->dev);
 +	int rc;
 +
 +	qeth_l2_vnicc_set_defaults(card);
 +	mutex_init(&card->sbp_lock);
 +
 +	if (gdev->dev.type == &qeth_generic_devtype) {
 +		rc = qeth_l2_create_device_attributes(&gdev->dev);
 +		if (rc)
 +			return rc;
 +	}
 +
 +	INIT_WORK(&card->rx_mode_work, qeth_l2_rx_mode_work);
 +	return 0;
 +}
 +
 +static void qeth_l2_remove_device(struct ccwgroup_device *cgdev)
 +{
 +	struct qeth_card *card = dev_get_drvdata(&cgdev->dev);
 +
 +	if (cgdev->dev.type == &qeth_generic_devtype)
 +		qeth_l2_remove_device_attributes(&cgdev->dev);
 +	qeth_set_allowed_threads(card, 0, 1);
 +	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
 +
 +	if (cgdev->state == CCWGROUP_ONLINE)
 +		qeth_set_offline(card, false);
 +
 +	cancel_work_sync(&card->close_dev_work);
 +	if (card->dev->reg_state == NETREG_REGISTERED)
 +		unregister_netdev(card->dev);
  }
  
  static void qeth_l2_set_rx_mode(struct net_device *dev)
diff --cc drivers/s390/net/qeth_l3_main.c
index 7d591f3bc4ee,803ccbcf3511..000000000000
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@@ -1834,8 -1831,10 +1834,15 @@@ static u16 qeth_l3_osa_select_queue(str
  {
  	struct qeth_card *card = dev->ml_priv;
  
++<<<<<<< HEAD
 +	return IS_VM_NIC(card) ? fallback(dev, skb, sb_dev) :
 +				 qeth_get_priority_queue(card, skb);
++=======
+ 	if (qeth_uses_tx_prio_queueing(card))
+ 		return qeth_get_priority_queue(card, skb);
+ 
+ 	return netdev_pick_tx(dev, skb, sb_dev);
++>>>>>>> 949bbf4d2db8 (s390/qeth: allow configuration of TX queues for OSA devices)
  }
  
  static const struct net_device_ops qeth_l3_netdev_ops = {
* Unmerged path drivers/s390/net/qeth_core.h
* Unmerged path drivers/s390/net/qeth_core_main.c
diff --git a/drivers/s390/net/qeth_core_sys.c b/drivers/s390/net/qeth_core_sys.c
index 74c70364edc1..7cc5649dfffe 100644
--- a/drivers/s390/net/qeth_core_sys.c
+++ b/drivers/s390/net/qeth_core_sys.c
@@ -164,9 +164,11 @@ static ssize_t qeth_dev_prioqing_show(struct device *dev,
 		return sprintf(buf, "%s\n", "by skb-priority");
 	case QETH_PRIO_Q_ING_VLAN:
 		return sprintf(buf, "%s\n", "by VLAN headers");
-	default:
+	case QETH_PRIO_Q_ING_FIXED:
 		return sprintf(buf, "always queue %i\n",
 			       card->qdio.default_out_queue);
+	default:
+		return sprintf(buf, "disabled\n");
 	}
 }
 
diff --git a/drivers/s390/net/qeth_ethtool.c b/drivers/s390/net/qeth_ethtool.c
index ebdc03210608..b41dda03a56f 100644
--- a/drivers/s390/net/qeth_ethtool.c
+++ b/drivers/s390/net/qeth_ethtool.c
@@ -218,6 +218,10 @@ static int qeth_set_channels(struct net_device *dev,
 	if (channels->tx_count > card->qdio.no_out_queues)
 		return -EINVAL;
 
+	/* Prio-queueing needs all TX queues: */
+	if (qeth_uses_tx_prio_queueing(card))
+		return -EPERM;
+
 	if (IS_IQD(card)) {
 		if (channels->tx_count < QETH_IQD_MIN_TXQ)
 			return -EINVAL;
@@ -228,10 +232,6 @@ static int qeth_set_channels(struct net_device *dev,
 		if (netif_running(dev) &&
 		    channels->tx_count < dev->real_num_tx_queues)
 			return -EPERM;
-	} else {
-		/* OSA still uses the legacy prio-queue mechanism: */
-		if (!IS_VM_NIC(card))
-			return -EOPNOTSUPP;
 	}
 
 	return qeth_set_real_num_tx_queues(card, channels->tx_count);
* Unmerged path drivers/s390/net/qeth_l2_main.c
* Unmerged path drivers/s390/net/qeth_l3_main.c
