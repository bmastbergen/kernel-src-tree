s390/qeth: reduce rtnl locking for switchdev events

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 09840f70b088df1ec24f9b4e345983e7d5f63628
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/09840f70.failed

call_switchdev_notifiers() doesn't require holding the RTNL lock since
commit ff5cf100110c ("net: switchdev: Change notifier chain to be atomic").

We still need it for the "lost event" slow path, to avoid racing against
a concurrent .ndo_bridge_setlink().

	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Reviewed-by: Alexandra Winter <wintera@linux.ibm.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 09840f70b088df1ec24f9b4e345983e7d5f63628)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_l2_main.c
diff --cc drivers/s390/net/qeth_l2_main.c
index 8df43a961040,daeb837abec3..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -2358,6 -2185,179 +2358,182 @@@ static void qeth_l2_vnicc_set_defaults(
  	card->options.vnicc.wanted_chars = QETH_VNICC_DEFAULT;
  }
  
++<<<<<<< HEAD
++=======
+ static const struct device_type qeth_l2_devtype = {
+ 	.name = "qeth_layer2",
+ 	.groups = qeth_l2_attr_groups,
+ };
+ 
+ static int qeth_l2_probe_device(struct ccwgroup_device *gdev)
+ {
+ 	struct qeth_card *card = dev_get_drvdata(&gdev->dev);
+ 	int rc;
+ 
+ 	if (IS_OSN(card))
+ 		dev_notice(&gdev->dev, "OSN support will be dropped in 2021\n");
+ 
+ 	qeth_l2_vnicc_set_defaults(card);
+ 	mutex_init(&card->sbp_lock);
+ 
+ 	if (gdev->dev.type == &qeth_generic_devtype) {
+ 		rc = qeth_l2_create_device_attributes(&gdev->dev);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	INIT_WORK(&card->rx_mode_work, qeth_l2_rx_mode_work);
+ 	return 0;
+ }
+ 
+ static void qeth_l2_remove_device(struct ccwgroup_device *gdev)
+ {
+ 	struct qeth_card *card = dev_get_drvdata(&gdev->dev);
+ 
+ 	if (gdev->dev.type == &qeth_generic_devtype)
+ 		qeth_l2_remove_device_attributes(&gdev->dev);
+ 	qeth_set_allowed_threads(card, 0, 1);
+ 	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
+ 
+ 	if (gdev->state == CCWGROUP_ONLINE)
+ 		qeth_set_offline(card, false);
+ 
+ 	cancel_work_sync(&card->close_dev_work);
+ 	if (card->dev->reg_state == NETREG_REGISTERED)
+ 		unregister_netdev(card->dev);
+ }
+ 
+ static int qeth_l2_set_online(struct qeth_card *card, bool carrier_ok)
+ {
+ 	struct net_device *dev = card->dev;
+ 	int rc = 0;
+ 
+ 	/* query before bridgeport_notification may be enabled */
+ 	qeth_l2_detect_dev2br_support(card);
+ 
+ 	mutex_lock(&card->sbp_lock);
+ 	qeth_bridgeport_query_support(card);
+ 	if (card->options.sbp.supported_funcs) {
+ 		qeth_l2_setup_bridgeport_attrs(card);
+ 		dev_info(&card->gdev->dev,
+ 			 "The device represents a Bridge Capable Port\n");
+ 	}
+ 	mutex_unlock(&card->sbp_lock);
+ 
+ 	qeth_l2_register_dev_addr(card);
+ 
+ 	/* for the rx_bcast characteristic, init VNICC after setmac */
+ 	qeth_l2_vnicc_init(card);
+ 
+ 	qeth_l2_trace_features(card);
+ 
+ 	/* softsetup */
+ 	QETH_CARD_TEXT(card, 2, "softsetp");
+ 
+ 	card->state = CARD_STATE_SOFTSETUP;
+ 
+ 	qeth_set_allowed_threads(card, 0xffffffff, 0);
+ 
+ 	if (dev->reg_state != NETREG_REGISTERED) {
+ 		rc = qeth_l2_setup_netdev(card);
+ 		if (rc)
+ 			goto err_setup;
+ 
+ 		if (carrier_ok)
+ 			netif_carrier_on(dev);
+ 	} else {
+ 		rtnl_lock();
+ 		rc = qeth_set_real_num_tx_queues(card,
+ 						 qeth_tx_actual_queues(card));
+ 		if (rc) {
+ 			rtnl_unlock();
+ 			goto err_set_queues;
+ 		}
+ 
+ 		if (carrier_ok)
+ 			netif_carrier_on(dev);
+ 		else
+ 			netif_carrier_off(dev);
+ 
+ 		netif_device_attach(dev);
+ 		qeth_enable_hw_features(dev);
+ 		qeth_l2_enable_brport_features(card);
+ 
+ 		if (card->info.open_when_online) {
+ 			card->info.open_when_online = 0;
+ 			dev_open(dev, NULL);
+ 		}
+ 		rtnl_unlock();
+ 	}
+ 	return 0;
+ 
+ err_set_queues:
+ err_setup:
+ 	qeth_set_allowed_threads(card, 0, 1);
+ 	card->state = CARD_STATE_DOWN;
+ 	return rc;
+ }
+ 
+ static void qeth_l2_set_offline(struct qeth_card *card)
+ {
+ 	struct qeth_priv *priv = netdev_priv(card->dev);
+ 
+ 	qeth_set_allowed_threads(card, 0, 1);
+ 	qeth_l2_drain_rx_mode_cache(card);
+ 
+ 	if (card->state == CARD_STATE_SOFTSETUP)
+ 		card->state = CARD_STATE_DOWN;
+ 
+ 	qeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);
+ 	if (priv->brport_features & BR_LEARNING_SYNC)
+ 		qeth_l2_dev2br_fdb_flush(card);
+ }
+ 
+ /* Returns zero if the command is successfully "consumed" */
+ static int qeth_l2_control_event(struct qeth_card *card,
+ 				 struct qeth_ipa_cmd *cmd)
+ {
+ 	switch (cmd->hdr.command) {
+ 	case IPA_CMD_SETBRIDGEPORT_OSA:
+ 	case IPA_CMD_SETBRIDGEPORT_IQD:
+ 		if (cmd->data.sbp.hdr.command_code ==
+ 		    IPA_SBP_BRIDGE_PORT_STATE_CHANGE) {
+ 			qeth_bridge_state_change(card, cmd);
+ 			return 0;
+ 		}
+ 
+ 		return 1;
+ 	case IPA_CMD_ADDRESS_CHANGE_NOTIF:
+ 		qeth_addr_change_event(card, cmd);
+ 		return 0;
+ 	default:
+ 		return 1;
+ 	}
+ }
+ 
+ const struct qeth_discipline qeth_l2_discipline = {
+ 	.devtype = &qeth_l2_devtype,
+ 	.setup = qeth_l2_probe_device,
+ 	.remove = qeth_l2_remove_device,
+ 	.set_online = qeth_l2_set_online,
+ 	.set_offline = qeth_l2_set_offline,
+ 	.do_ioctl = NULL,
+ 	.control_event_handler = qeth_l2_control_event,
+ };
+ EXPORT_SYMBOL_GPL(qeth_l2_discipline);
+ 
+ static int __init qeth_l2_init(void)
+ {
+ 	pr_info("register layer 2 discipline\n");
+ 	return 0;
+ }
+ 
+ static void __exit qeth_l2_exit(void)
+ {
+ 	pr_info("unregister layer 2 discipline\n");
+ }
+ 
++>>>>>>> 09840f70b088 (s390/qeth: reduce rtnl locking for switchdev events)
  module_init(qeth_l2_init);
  module_exit(qeth_l2_exit);
  MODULE_AUTHOR("Frank Blaschka <frank.blaschka@de.ibm.com>");
* Unmerged path drivers/s390/net/qeth_l2_main.c
