cifs: move cifs_cleanup_volume_info[_content] to fs_context.c

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
Rebuild_CHGLOG: - cifs: move cifs_cleanup_volume_info[_content] to fs_context.c (Ronnie Sahlberg) [1812436]
Rebuild_FUZZ: 90.09%
commit-author Ronnie Sahlberg <lsahlber@redhat.com>
commit c741cba2cd1d145c71f928c329cac007e6f99e42
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/c741cba2.failed

and rename it to smb3_cleanup_fs_context[_content]

	Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit c741cba2cd1d145c71f928c329cac007e6f99e42)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifsfs.c
#	fs/cifs/cifsproto.h
#	fs/cifs/connect.c
#	fs/cifs/fs_context.c
#	fs/cifs/fs_context.h
diff --cc fs/cifs/cifsfs.c
index a4dcb1531a42,9c2959f552e0..000000000000
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@@ -872,31 -872,14 +872,39 @@@ cifs_smb3_do_mount(struct file_system_t
  out_super:
  	deactivate_locked_super(sb);
  out:
++<<<<<<< HEAD
 +	cifs_cleanup_volume_info(ctx);
++=======
+ 	if (cifs_sb) {
+ 		kfree(cifs_sb->prepath);
+ 		smb3_cleanup_fs_context(cifs_sb->ctx);
+ 		kfree(cifs_sb);
+ 	}
++>>>>>>> c741cba2cd1d (cifs: move cifs_cleanup_volume_info[_content] to fs_context.c)
  	return root;
 +
 +out_free:
 +	kfree(cifs_sb->prepath);
 +	kfree(cifs_sb->mountdata);
 +	kfree(cifs_sb);
 +out_nls:
 +	unload_nls(ctx->local_nls);
 +	goto out;
  }
  
 +static struct dentry *
 +smb3_do_mount(struct file_system_type *fs_type,
 +	      int flags, const char *dev_name, void *data)
 +{
 +	return cifs_smb3_do_mount(fs_type, flags, dev_name, data, true);
 +}
 +
 +static struct dentry *
 +cifs_do_mount(struct file_system_type *fs_type,
 +	      int flags, const char *dev_name, void *data)
 +{
 +	return cifs_smb3_do_mount(fs_type, flags, dev_name, data, false);
 +}
  
  static ssize_t
  cifs_loose_read_iter(struct kiocb *iocb, struct iov_iter *iter)
diff --cc fs/cifs/cifsproto.h
index aa66a6b9aaf5,891c8d8c2bb5..000000000000
--- a/fs/cifs/cifsproto.h
+++ b/fs/cifs/cifsproto.h
@@@ -238,9 -237,6 +238,12 @@@ extern int cifs_read_page_from_socket(s
  extern int cifs_setup_cifs_sb(struct smb3_fs_context *ctx,
  			       struct cifs_sb_info *cifs_sb);
  extern int cifs_match_super(struct super_block *, void *);
++<<<<<<< HEAD
 +extern void cifs_cleanup_volume_info(struct smb3_fs_context *ctx);
 +extern struct smb3_fs_context *cifs_get_volume_info(char *mount_data,
 +					    const char *devname, bool is_smb3);
++=======
++>>>>>>> c741cba2cd1d (cifs: move cifs_cleanup_volume_info[_content] to fs_context.c)
  extern int cifs_mount(struct cifs_sb_info *cifs_sb, struct smb3_fs_context *ctx);
  extern void cifs_umount(struct cifs_sb_info *);
  extern void cifs_mark_open_files_invalid(struct cifs_tcon *tcon);
@@@ -554,10 -550,7 +557,14 @@@ extern int SMBencrypt(unsigned char *pa
  			unsigned char *p24);
  
  extern int
++<<<<<<< HEAD
 +cifs_setup_volume_info(struct smb3_fs_context *ctx, char *mount_data,
 +		       const char *devname, bool is_smb3);
 +extern void
 +cifs_cleanup_volume_info_contents(struct smb3_fs_context *ctx);
++=======
+ cifs_setup_volume_info(struct smb3_fs_context *ctx);
++>>>>>>> c741cba2cd1d (cifs: move cifs_cleanup_volume_info[_content] to fs_context.c)
  
  extern struct TCP_Server_Info *
  cifs_find_tcp_session(struct smb3_fs_context *ctx);
diff --cc fs/cifs/connect.c
index b833d5b568a2,16d92ff4ae5e..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -3893,26 -2820,6 +3893,29 @@@ int cifs_setup_cifs_sb(struct smb3_fs_c
  	return 0;
  }
  
++<<<<<<< HEAD
 +void
 +cifs_cleanup_volume_info_contents(struct smb3_fs_context *ctx)
 +{
 +	kfree(ctx->username);
 +	kfree_sensitive(ctx->password);
 +	kfree(ctx->UNC);
 +	kfree(ctx->domainname);
 +	kfree(ctx->iocharset);
 +	kfree(ctx->prepath);
 +}
 +
 +void
 +cifs_cleanup_volume_info(struct smb3_fs_context *ctx)
 +{
 +	if (!ctx)
 +		return;
 +	cifs_cleanup_volume_info_contents(ctx);
 +	kfree(ctx);
 +}
 +
++=======
++>>>>>>> c741cba2cd1d (cifs: move cifs_cleanup_volume_info[_content] to fs_context.c)
  /* Release all succeed connections */
  static inline void mount_put_conns(struct cifs_sb_info *cifs_sb,
  				   unsigned int xid,
@@@ -4127,13 -3030,11 +4130,18 @@@ expand_dfs_referral(const unsigned int 
  			rc = PTR_ERR(mdata);
  			mdata = NULL;
  		} else {
++<<<<<<< HEAD
 +			cifs_cleanup_volume_info_contents(ctx);
 +			rc = cifs_setup_volume_info(ctx, mdata,
 +						    fake_devname, false);
++=======
+ 			smb3_cleanup_fs_context_contents(ctx);
+ 			rc = cifs_setup_volume_info(ctx);
++>>>>>>> c741cba2cd1d (cifs: move cifs_cleanup_volume_info[_content] to fs_context.c)
  		}
 -		kfree(cifs_sb->ctx->mount_options);
 -		cifs_sb->ctx->mount_options = mdata;
 +		kfree(fake_devname);
 +		kfree(cifs_sb->mountdata);
 +		cifs_sb->mountdata = mdata;
  	}
  	kfree(full_path);
  	return rc;
@@@ -4223,7 -3122,7 +4231,11 @@@ static int setup_dfs_tgt_conn(const cha
  			rc = update_vol_info(tgt_it, &fake_ctx, ctx);
  		}
  	}
++<<<<<<< HEAD
 +	cifs_cleanup_volume_info_contents((struct smb3_fs_context *)&fake_ctx);
++=======
+ 	smb3_cleanup_fs_context_contents(&fake_ctx);
++>>>>>>> c741cba2cd1d (cifs: move cifs_cleanup_volume_info[_content] to fs_context.c)
  	return rc;
  }
  
@@@ -4851,9 -3731,11 +4863,17 @@@ CIFSTCon(const unsigned int xid, struc
  
  static void delayed_free(struct rcu_head *p)
  {
++<<<<<<< HEAD
 +	struct cifs_sb_info *sbi = container_of(p, struct cifs_sb_info, rcu);
 +	unload_nls(sbi->local_nls);
 +	kfree(sbi);
++=======
+ 	struct cifs_sb_info *cifs_sb = container_of(p, struct cifs_sb_info, rcu);
+ 
+ 	unload_nls(cifs_sb->local_nls);
+ 	smb3_cleanup_fs_context(cifs_sb->ctx);
+ 	kfree(cifs_sb);
++>>>>>>> c741cba2cd1d (cifs: move cifs_cleanup_volume_info[_content] to fs_context.c)
  }
  
  void
diff --cc fs/cifs/fs_context.c
index 84354cd4c960,4d8caf5b9519..000000000000
--- a/fs/cifs/fs_context.c
+++ b/fs/cifs/fs_context.c
@@@ -248,9 -313,10 +248,9 @@@ smb3_fs_context_dup(struct smb3_fs_cont
  	new_ctx->iocharset = NULL;
  
  	/*
- 	 * Make sure to stay in sync with cifs_cleanup_volume_info_contents()
+ 	 * Make sure to stay in sync with smb3_cleanup_fs_context_contents()
  	 */
  	DUP_CTX_STR(prepath);
 -	DUP_CTX_STR(mount_options);
  	DUP_CTX_STR(username);
  	DUP_CTX_STR(password);
  	DUP_CTX_STR(UNC);
@@@ -316,3 -453,833 +316,836 @@@ smb3_parse_devname(const char *devname
  
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static void smb3_fs_context_free(struct fs_context *fc);
+ static int smb3_fs_context_parse_param(struct fs_context *fc,
+ 				       struct fs_parameter *param);
+ static int smb3_fs_context_parse_monolithic(struct fs_context *fc,
+ 					    void *data);
+ static int smb3_get_tree(struct fs_context *fc);
+ static int smb3_reconfigure(struct fs_context *fc);
+ 
+ static const struct fs_context_operations smb3_fs_context_ops = {
+ 	.free			= smb3_fs_context_free,
+ 	.parse_param		= smb3_fs_context_parse_param,
+ 	.parse_monolithic	= smb3_fs_context_parse_monolithic,
+ 	.get_tree		= smb3_get_tree,
+ 	.reconfigure		= smb3_reconfigure,
+ };
+ 
+ /*
+  * Parse a monolithic block of data from sys_mount().
+  * smb3_fs_context_parse_monolithic - Parse key[=val][,key[=val]]* mount data
+  * @ctx: The superblock configuration to fill in.
+  * @data: The data to parse
+  *
+  * Parse a blob of data that's in key[=val][,key[=val]]* form.  This can be
+  * called from the ->monolithic_mount_data() fs_context operation.
+  *
+  * Returns 0 on success or the error returned by the ->parse_option() fs_context
+  * operation on failure.
+  */
+ static int smb3_fs_context_parse_monolithic(struct fs_context *fc,
+ 					   void *data)
+ {
+ 	struct smb3_fs_context *ctx = smb3_fc2context(fc);
+ 	char *options = data, *key;
+ 	int ret = 0;
+ 
+ 	if (!options)
+ 		return 0;
+ 
+ 	ctx->mount_options = kstrdup(data, GFP_KERNEL);
+ 	if (ctx->mount_options == NULL)
+ 		return -ENOMEM;
+ 
+ 	ret = security_sb_eat_lsm_opts(options, &fc->security);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* BB Need to add support for sep= here TBD */
+ 	while ((key = strsep(&options, ",")) != NULL) {
+ 		if (*key) {
+ 			size_t v_len = 0;
+ 			char *value = strchr(key, '=');
+ 
+ 			if (value) {
+ 				if (value == key)
+ 					continue;
+ 				*value++ = 0;
+ 				v_len = strlen(value);
+ 			}
+ 			ret = vfs_parse_fs_string(fc, key, value, v_len);
+ 			if (ret < 0)
+ 				break;
+ 		}
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ /*
+  * Validate the preparsed information in the config.
+  */
+ static int smb3_fs_context_validate(struct fs_context *fc)
+ {
+ 	struct smb3_fs_context *ctx = smb3_fc2context(fc);
+ 
+ 	if (ctx->rdma && ctx->vals->protocol_id < SMB30_PROT_ID) {
+ 		cifs_dbg(VFS, "SMB Direct requires Version >=3.0\n");
+ 		return -1;
+ 	}
+ 
+ #ifndef CONFIG_KEYS
+ 	/* Muliuser mounts require CONFIG_KEYS support */
+ 	if (ctx->multiuser) {
+ 		cifs_dbg(VFS, "Multiuser mounts require kernels with CONFIG_KEYS enabled\n");
+ 		return -1;
+ 	}
+ #endif
+ 
+ 	if (ctx->got_version == false)
+ 		pr_warn_once("No dialect specified on mount. Default has changed to a more secure dialect, SMB2.1 or later (e.g. SMB3.1.1), from CIFS (SMB1). To use the less secure SMB1 dialect to access old servers which do not support SMB3.1.1 (or even SMB3 or SMB2.1) specify vers=1.0 on mount.\n");
+ 
+ 
+ 	if (!ctx->UNC) {
+ 		cifs_dbg(VFS, "CIFS mount error: No usable UNC path provided in device string!\n");
+ 		return -1;
+ 	}
+ 
+ 	/* make sure UNC has a share name */
+ 	if (strlen(ctx->UNC) < 3 || !strchr(ctx->UNC + 3, '\\')) {
+ 		cifs_dbg(VFS, "Malformed UNC. Unable to find share name.\n");
+ 		return -1;
+ 	}
+ 
+ 	if (!ctx->got_ip) {
+ 		int len;
+ 		const char *slash;
+ 
+ 		/* No ip= option specified? Try to get it from UNC */
+ 		/* Use the address part of the UNC. */
+ 		slash = strchr(&ctx->UNC[2], '\\');
+ 		len = slash - &ctx->UNC[2];
+ 		if (!cifs_convert_address((struct sockaddr *)&ctx->dstaddr,
+ 					  &ctx->UNC[2], len)) {
+ 			pr_err("Unable to determine destination address\n");
+ 			return -1;
+ 		}
+ 	}
+ 
+ 	/* set the port that we got earlier */
+ 	cifs_set_port((struct sockaddr *)&ctx->dstaddr, ctx->port);
+ 
+ 	if (ctx->override_uid && !ctx->uid_specified) {
+ 		ctx->override_uid = 0;
+ 		pr_notice("ignoring forceuid mount option specified with no uid= option\n");
+ 	}
+ 
+ 	if (ctx->override_gid && !ctx->gid_specified) {
+ 		ctx->override_gid = 0;
+ 		pr_notice("ignoring forcegid mount option specified with no gid= option\n");
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int smb3_get_tree_common(struct fs_context *fc)
+ {
+ 	struct smb3_fs_context *ctx = smb3_fc2context(fc);
+ 	struct dentry *root;
+ 	int rc = 0;
+ 
+ 	root = cifs_smb3_do_mount(fc->fs_type, 0, ctx);
+ 	if (IS_ERR(root))
+ 		return PTR_ERR(root);
+ 
+ 	fc->root = root;
+ 
+ 	return rc;
+ }
+ 
+ /*
+  * Create an SMB3 superblock from the parameters passed.
+  */
+ static int smb3_get_tree(struct fs_context *fc)
+ {
+ 	int err = smb3_fs_context_validate(fc);
+ 
+ 	if (err)
+ 		return err;
+ 	return smb3_get_tree_common(fc);
+ }
+ 
+ static void smb3_fs_context_free(struct fs_context *fc)
+ {
+ 	struct smb3_fs_context *ctx = smb3_fc2context(fc);
+ 
+ 	smb3_cleanup_fs_context(ctx);
+ }
+ 
+ static int smb3_reconfigure(struct fs_context *fc)
+ {
+ 	// TODO:  struct smb3_fs_context *ctx = smb3_fc2context(fc);
+ 
+ 	/* FIXME : add actual reconfigure */
+ 	return 0;
+ }
+ 
+ static int smb3_fs_context_parse_param(struct fs_context *fc,
+ 				      struct fs_parameter *param)
+ {
+ 	struct fs_parse_result result;
+ 	struct smb3_fs_context *ctx = smb3_fc2context(fc);
+ 	int i, opt;
+ 	bool is_smb3 = !strcmp(fc->fs_type->name, "smb3");
+ 	bool skip_parsing = false;
+ 
+ 	cifs_dbg(FYI, "CIFS: parsing cifs mount option '%s'\n", param->key);
+ 
+ 	/*
+ 	 * fs_parse can not handle string options with an empty value so
+ 	 * we will need special handling of them.
+ 	 */
+ 	if (param->type == fs_value_is_string && param->string[0] == 0) {
+ 		if (!strcmp("pass", param->key) || !strcmp("password", param->key))
+ 			skip_parsing = true;
+ 	}
+ 
+ 	if (!skip_parsing) {
+ 		opt = fs_parse(fc, smb3_fs_parameters, param, &result);
+ 		if (opt < 0)
+ 			return ctx->sloppy ? 1 : opt;
+ 	}
+ 
+ 	switch (opt) {
+ 	case Opt_compress:
+ 		ctx->compression = UNKNOWN_TYPE;
+ 		cifs_dbg(VFS,
+ 			"SMB3 compression support is experimental\n");
+ 		break;
+ 	case Opt_nodfs:
+ 		ctx->nodfs = 1;
+ 		break;
+ 	case Opt_hard:
+ 		if (result.negated)
+ 			ctx->retry = 0;
+ 		else
+ 			ctx->retry = 1;
+ 		break;
+ 	case Opt_soft:
+ 		if (result.negated)
+ 			ctx->retry = 1;
+ 		else
+ 			ctx->retry = 0;
+ 		break;
+ 	case Opt_mapposix:
+ 		if (result.negated)
+ 			ctx->remap = false;
+ 		else {
+ 			ctx->remap = true;
+ 			ctx->sfu_remap = false; /* disable SFU mapping */
+ 		}
+ 		break;
+ 	case Opt_user_xattr:
+ 		if (result.negated)
+ 			ctx->no_xattr = 1;
+ 		else
+ 			ctx->no_xattr = 0;
+ 		break;
+ 	case Opt_forceuid:
+ 		if (result.negated)
+ 			ctx->override_uid = 0;
+ 		else
+ 			ctx->override_uid = 1;
+ 		break;
+ 	case Opt_forcegid:
+ 		if (result.negated)
+ 			ctx->override_gid = 0;
+ 		else
+ 			ctx->override_gid = 1;
+ 		break;
+ 	case Opt_perm:
+ 		if (result.negated)
+ 			ctx->noperm = 1;
+ 		else
+ 			ctx->noperm = 0;
+ 		break;
+ 	case Opt_dynperm:
+ 		if (result.negated)
+ 			ctx->dynperm = 0;
+ 		else
+ 			ctx->dynperm = 1;
+ 		break;
+ 	case Opt_sfu:
+ 		if (result.negated)
+ 			ctx->sfu_emul = 0;
+ 		else
+ 			ctx->sfu_emul = 1;
+ 		break;
+ 	case Opt_noblocksend:
+ 		ctx->noblocksnd = 1;
+ 		break;
+ 	case Opt_noautotune:
+ 		ctx->noautotune = 1;
+ 		break;
+ 	case Opt_nolease:
+ 		ctx->no_lease = 1;
+ 		break;
+ 	case Opt_nodelete:
+ 		ctx->nodelete = 1;
+ 		break;
+ 	case Opt_multichannel:
+ 		if (result.negated) {
+ 			ctx->multichannel = false;
+ 			ctx->max_channels = 1;
+ 		} else {
+ 			ctx->multichannel = true;
+ 			/* if number of channels not specified, default to 2 */
+ 			if (ctx->max_channels < 2)
+ 				ctx->max_channels = 2;
+ 		}
+ 		break;
+ 	case Opt_uid:
+ 		ctx->linux_uid.val = result.uint_32;
+ 		ctx->uid_specified = true;
+ 		break;
+ 	case Opt_cruid:
+ 		ctx->cred_uid.val = result.uint_32;
+ 		break;
+ 	case Opt_backupgid:
+ 		ctx->backupgid.val = result.uint_32;
+ 		ctx->backupgid_specified = true;
+ 		break;
+ 	case Opt_gid:
+ 		ctx->linux_gid.val = result.uint_32;
+ 		ctx->gid_specified = true;
+ 		break;
+ 	case Opt_port:
+ 		ctx->port = result.uint_32;
+ 		break;
+ 	case Opt_file_mode:
+ 		ctx->file_mode = result.uint_32;
+ 		break;
+ 	case Opt_dirmode:
+ 		ctx->dir_mode = result.uint_32;
+ 		break;
+ 	case Opt_min_enc_offload:
+ 		ctx->min_offload = result.uint_32;
+ 		break;
+ 	case Opt_blocksize:
+ 		/*
+ 		 * inode blocksize realistically should never need to be
+ 		 * less than 16K or greater than 16M and default is 1MB.
+ 		 * Note that small inode block sizes (e.g. 64K) can lead
+ 		 * to very poor performance of common tools like cp and scp
+ 		 */
+ 		if ((result.uint_32 < CIFS_MAX_MSGSIZE) ||
+ 		   (result.uint_32 > (4 * SMB3_DEFAULT_IOSIZE))) {
+ 			cifs_dbg(VFS, "%s: Invalid blocksize\n",
+ 				__func__);
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		ctx->bsize = result.uint_32;
+ 		break;
+ 	case Opt_rsize:
+ 		ctx->rsize = result.uint_32;
+ 		break;
+ 	case Opt_wsize:
+ 		ctx->wsize = result.uint_32;
+ 		break;
+ 	case Opt_actimeo:
+ 		ctx->actimeo = HZ * result.uint_32;
+ 		if (ctx->actimeo > CIFS_MAX_ACTIMEO) {
+ 			cifs_dbg(VFS, "attribute cache timeout too large\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		break;
+ 	case Opt_echo_interval:
+ 		ctx->echo_interval = result.uint_32;
+ 		break;
+ 	case Opt_snapshot:
+ 		ctx->snapshot_time = result.uint_32;
+ 		break;
+ 	case Opt_max_credits:
+ 		if (result.uint_32 < 20 || result.uint_32 > 60000) {
+ 			cifs_dbg(VFS, "%s: Invalid max_credits value\n",
+ 				 __func__);
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		ctx->max_credits = result.uint_32;
+ 		break;
+ 	case Opt_max_channels:
+ 		if (result.uint_32 < 1 || result.uint_32 > CIFS_MAX_CHANNELS) {
+ 			cifs_dbg(VFS, "%s: Invalid max_channels value, needs to be 1-%d\n",
+ 				 __func__, CIFS_MAX_CHANNELS);
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		ctx->max_channels = result.uint_32;
+ 		break;
+ 	case Opt_handletimeout:
+ 		ctx->handle_timeout = result.uint_32;
+ 		if (ctx->handle_timeout > SMB3_MAX_HANDLE_TIMEOUT) {
+ 			cifs_dbg(VFS, "Invalid handle cache timeout, longer than 16 minutes\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		break;
+ 	case Opt_source:
+ 		kfree(ctx->UNC);
+ 		ctx->UNC = NULL;
+ 		switch (smb3_parse_devname(param->string, ctx)) {
+ 		case 0:
+ 			break;
+ 		case -ENOMEM:
+ 			cifs_dbg(VFS, "Unable to allocate memory for devname\n");
+ 			goto cifs_parse_mount_err;
+ 		case -EINVAL:
+ 			cifs_dbg(VFS, "Malformed UNC in devname\n");
+ 			goto cifs_parse_mount_err;
+ 		default:
+ 			cifs_dbg(VFS, "Unknown error parsing devname\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		fc->source = kstrdup(param->string, GFP_KERNEL);
+ 		if (fc->source == NULL) {
+ 			cifs_dbg(VFS, "OOM when copying UNC string\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		break;
+ 	case Opt_user:
+ 		kfree(ctx->username);
+ 		ctx->username = NULL;
+ 		if (strlen(param->string) == 0) {
+ 			/* null user, ie. anonymous authentication */
+ 			ctx->nullauth = 1;
+ 			break;
+ 		}
+ 
+ 		if (strnlen(param->string, CIFS_MAX_USERNAME_LEN) >
+ 		    CIFS_MAX_USERNAME_LEN) {
+ 			pr_warn("username too long\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		ctx->username = kstrdup(param->string, GFP_KERNEL);
+ 		if (ctx->username == NULL) {
+ 			cifs_dbg(VFS, "OOM when copying username string\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		break;
+ 	case Opt_pass:
+ 		kfree(ctx->password);
+ 		ctx->password = NULL;
+ 		if (strlen(param->string) == 0)
+ 			break;
+ 
+ 		ctx->password = kstrdup(param->string, GFP_KERNEL);
+ 		if (ctx->password == NULL) {
+ 			cifs_dbg(VFS, "OOM when copying password string\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		break;
+ 	case Opt_ip:
+ 		if (strlen(param->string) == 0) {
+ 			ctx->got_ip = false;
+ 			break;
+ 		}
+ 		if (!cifs_convert_address((struct sockaddr *)&ctx->dstaddr,
+ 					  param->string,
+ 					  strlen(param->string))) {
+ 			pr_err("bad ip= option (%s)\n", param->string);
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		ctx->got_ip = true;
+ 		break;
+ 	case Opt_domain:
+ 		if (strnlen(param->string, CIFS_MAX_DOMAINNAME_LEN)
+ 				== CIFS_MAX_DOMAINNAME_LEN) {
+ 			pr_warn("domain name too long\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 
+ 		kfree(ctx->domainname);
+ 		ctx->domainname = kstrdup(param->string, GFP_KERNEL);
+ 		if (ctx->domainname == NULL) {
+ 			cifs_dbg(VFS, "OOM when copying domainname string\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		cifs_dbg(FYI, "Domain name set\n");
+ 		break;
+ 	case Opt_srcaddr:
+ 		if (!cifs_convert_address(
+ 				(struct sockaddr *)&ctx->srcaddr,
+ 				param->string, strlen(param->string))) {
+ 			pr_warn("Could not parse srcaddr: %s\n",
+ 				param->string);
+ 			goto cifs_parse_mount_err;
+ 		}
+ 		break;
+ 	case Opt_iocharset:
+ 		if (strnlen(param->string, 1024) >= 65) {
+ 			pr_warn("iocharset name too long\n");
+ 			goto cifs_parse_mount_err;
+ 		}
+ 
+ 		if (strncasecmp(param->string, "default", 7) != 0) {
+ 			kfree(ctx->iocharset);
+ 			ctx->iocharset = kstrdup(param->string, GFP_KERNEL);
+ 			if (ctx->iocharset == NULL) {
+ 				cifs_dbg(VFS, "OOM when copying iocharset string\n");
+ 				goto cifs_parse_mount_err;
+ 			}
+ 		}
+ 		/* if iocharset not set then load_nls_default
+ 		 * is used by caller
+ 		 */
+ 		 cifs_dbg(FYI, "iocharset set to %s\n", ctx->iocharset);
+ 		break;
+ 	case Opt_netbiosname:
+ 		memset(ctx->source_rfc1001_name, 0x20,
+ 			RFC1001_NAME_LEN);
+ 		/*
+ 		 * FIXME: are there cases in which a comma can
+ 		 * be valid in workstation netbios name (and
+ 		 * need special handling)?
+ 		 */
+ 		for (i = 0; i < RFC1001_NAME_LEN; i++) {
+ 			/* don't ucase netbiosname for user */
+ 			if (param->string[i] == 0)
+ 				break;
+ 			ctx->source_rfc1001_name[i] = param->string[i];
+ 		}
+ 		/* The string has 16th byte zero still from
+ 		 * set at top of the function
+ 		 */
+ 		if (i == RFC1001_NAME_LEN && param->string[i] != 0)
+ 			pr_warn("netbiosname longer than 15 truncated\n");
+ 		break;
+ 	case Opt_servern:
+ 		/* last byte, type, is 0x20 for servr type */
+ 		memset(ctx->target_rfc1001_name, 0x20,
+ 			RFC1001_NAME_LEN_WITH_NULL);
+ 		/*
+ 		 * BB are there cases in which a comma can be valid in this
+ 		 * workstation netbios name (and need special handling)?
+ 		 */
+ 
+ 		/* user or mount helper must uppercase the netbios name */
+ 		for (i = 0; i < 15; i++) {
+ 			if (param->string[i] == 0)
+ 				break;
+ 			ctx->target_rfc1001_name[i] = param->string[i];
+ 		}
+ 
+ 		/* The string has 16th byte zero still from set at top of function */
+ 		if (i == RFC1001_NAME_LEN && param->string[i] != 0)
+ 			pr_warn("server netbiosname longer than 15 truncated\n");
+ 		break;
+ 	case Opt_ver:
+ 		/* version of mount userspace tools, not dialect */
+ 		/* If interface changes in mount.cifs bump to new ver */
+ 		if (strncasecmp(param->string, "1", 1) == 0) {
+ 			if (strlen(param->string) > 1) {
+ 				pr_warn("Bad mount helper ver=%s. Did you want SMB1 (CIFS) dialect and mean to type vers=1.0 instead?\n",
+ 					param->string);
+ 				goto cifs_parse_mount_err;
+ 			}
+ 			/* This is the default */
+ 			break;
+ 		}
+ 		/* For all other value, error */
+ 		pr_warn("Invalid mount helper version specified\n");
+ 		goto cifs_parse_mount_err;
+ 	case Opt_vers:
+ 		/* protocol version (dialect) */
+ 		if (cifs_parse_smb_version(param->string, ctx, is_smb3) != 0)
+ 			goto cifs_parse_mount_err;
+ 		ctx->got_version = true;
+ 		break;
+ 	case Opt_sec:
+ 		if (cifs_parse_security_flavors(param->string, ctx) != 0)
+ 			goto cifs_parse_mount_err;
+ 		break;
+ 	case Opt_cache:
+ 		if (cifs_parse_cache_flavor(param->string, ctx) != 0)
+ 			goto cifs_parse_mount_err;
+ 		break;
+ 	case Opt_witness:
+ #ifndef CONFIG_CIFS_SWN_UPCALL
+ 		cifs_dbg(VFS, "Witness support needs CONFIG_CIFS_SWN_UPCALL config option\n");
+ 			goto cifs_parse_mount_err;
+ #endif
+ 		ctx->witness = true;
+ 		break;
+ 	case Opt_rootfs:
+ #ifdef CONFIG_CIFS_ROOT
+ 		ctx->rootfs = true;
+ #endif
+ 		break;
+ 	case Opt_posixpaths:
+ 		if (result.negated)
+ 			ctx->posix_paths = 0;
+ 		else
+ 			ctx->posix_paths = 1;
+ 		break;
+ 	case Opt_unix:
+ 		if (result.negated)
+ 			ctx->linux_ext = 0;
+ 		else
+ 			ctx->no_linux_ext = 1;
+ 		break;
+ 	case Opt_nocase:
+ 		ctx->nocase = 1;
+ 		break;
+ 	case Opt_brl:
+ 		if (result.negated) {
+ 			/*
+ 			 * turn off mandatory locking in mode
+ 			 * if remote locking is turned off since the
+ 			 * local vfs will do advisory
+ 			 */
+ 			if (ctx->file_mode ==
+ 				(S_IALLUGO & ~(S_ISUID | S_IXGRP)))
+ 				ctx->file_mode = S_IALLUGO;
+ 			ctx->nobrl =  1;
+ 		} else
+ 			ctx->nobrl =  0;
+ 		break;
+ 	case Opt_handlecache:
+ 		if (result.negated)
+ 			ctx->nohandlecache = 1;
+ 		else
+ 			ctx->nohandlecache = 0;
+ 		break;
+ 	case Opt_forcemandatorylock:
+ 		ctx->mand_lock = 1;
+ 		break;
+ 	case Opt_setuids:
+ 		ctx->setuids = result.negated;
+ 		break;
+ 	case Opt_intr:
+ 		ctx->intr = !result.negated;
+ 		break;
+ 	case Opt_setuidfromacl:
+ 		ctx->setuidfromacl = 1;
+ 		break;
+ 	case Opt_strictsync:
+ 		ctx->nostrictsync = result.negated;
+ 		break;
+ 	case Opt_serverino:
+ 		ctx->server_ino = !result.negated;
+ 		break;
+ 	case Opt_rwpidforward:
+ 		ctx->rwpidforward = 1;
+ 		break;
+ 	case Opt_modesid:
+ 		ctx->mode_ace = 1;
+ 		break;
+ 	case Opt_cifsacl:
+ 		ctx->cifs_acl = !result.negated;
+ 		break;
+ 	case Opt_acl:
+ 		ctx->no_psx_acl = result.negated;
+ 		break;
+ 	case Opt_locallease:
+ 		ctx->local_lease = 1;
+ 		break;
+ 	case Opt_sign:
+ 		ctx->sign = true;
+ 		break;
+ 	case Opt_ignore_signature:
+ 		ctx->sign = true;
+ 		ctx->ignore_signature = true;
+ 		break;
+ 	case Opt_seal:
+ 		/* we do not do the following in secFlags because seal
+ 		 * is a per tree connection (mount) not a per socket
+ 		 * or per-smb connection option in the protocol
+ 		 * vol->secFlg |= CIFSSEC_MUST_SEAL;
+ 		 */
+ 		ctx->seal = 1;
+ 		break;
+ 	case Opt_noac:
+ 		pr_warn("Mount option noac not supported. Instead set /proc/fs/cifs/LookupCacheEnabled to 0\n");
+ 		break;
+ 	case Opt_fsc:
+ #ifndef CONFIG_CIFS_FSCACHE
+ 		cifs_dbg(VFS, "FS-Cache support needs CONFIG_CIFS_FSCACHE kernel config option set\n");
+ 		goto cifs_parse_mount_err;
+ #endif
+ 		ctx->fsc = true;
+ 		break;
+ 	case Opt_mfsymlinks:
+ 		ctx->mfsymlinks = true;
+ 		break;
+ 	case Opt_multiuser:
+ 		ctx->multiuser = true;
+ 		break;
+ 	case Opt_sloppy:
+ 		ctx->sloppy = true;
+ 		break;
+ 	case Opt_nosharesock:
+ 		ctx->nosharesock = true;
+ 		break;
+ 	case Opt_persistent:
+ 		if (result.negated) {
+ 			if ((ctx->nopersistent) || (ctx->resilient)) {
+ 				cifs_dbg(VFS,
+ 				  "persistenthandles mount options conflict\n");
+ 				goto cifs_parse_mount_err;
+ 			}
+ 		} else {
+ 			ctx->nopersistent = true;
+ 			if (ctx->persistent) {
+ 				cifs_dbg(VFS,
+ 				  "persistenthandles mount options conflict\n");
+ 				goto cifs_parse_mount_err;
+ 			}
+ 		}
+ 		break;
+ 	case Opt_resilient:
+ 		if (result.negated) {
+ 			ctx->resilient = false; /* already the default */
+ 		} else {
+ 			ctx->resilient = true;
+ 			if (ctx->persistent) {
+ 				cifs_dbg(VFS,
+ 				  "persistenthandles mount options conflict\n");
+ 				goto cifs_parse_mount_err;
+ 			}
+ 		}
+ 		break;
+ 	case Opt_domainauto:
+ 		ctx->domainauto = true;
+ 		break;
+ 	case Opt_rdma:
+ 		ctx->rdma = true;
+ 		break;
+ 	}
+ 
+ 	return 0;
+ 
+  cifs_parse_mount_err:
+ 	return 1;
+ }
+ 
+ int smb3_init_fs_context(struct fs_context *fc)
+ {
+ 	struct smb3_fs_context *ctx;
+ 	char *nodename = utsname()->nodename;
+ 	int i;
+ 
+ 	ctx = kzalloc(sizeof(struct smb3_fs_context), GFP_KERNEL);
+ 	if (unlikely(!ctx))
+ 		return -ENOMEM;
+ 
+ 	/*
+ 	 * does not have to be perfect mapping since field is
+ 	 * informational, only used for servers that do not support
+ 	 * port 445 and it can be overridden at mount time
+ 	 */
+ 	memset(ctx->source_rfc1001_name, 0x20, RFC1001_NAME_LEN);
+ 	for (i = 0; i < strnlen(nodename, RFC1001_NAME_LEN); i++)
+ 		ctx->source_rfc1001_name[i] = toupper(nodename[i]);
+ 
+ 	ctx->source_rfc1001_name[RFC1001_NAME_LEN] = 0;
+ 	/*
+ 	 * null target name indicates to use *SMBSERVR default called name
+ 	 *  if we end up sending RFC1001 session initialize
+ 	 */
+ 	ctx->target_rfc1001_name[0] = 0;
+ 	ctx->cred_uid = current_uid();
+ 	ctx->linux_uid = current_uid();
+ 	ctx->linux_gid = current_gid();
+ 	ctx->bsize = 1024 * 1024; /* can improve cp performance significantly */
+ 
+ 	/*
+ 	 * default to SFM style remapping of seven reserved characters
+ 	 * unless user overrides it or we negotiate CIFS POSIX where
+ 	 * it is unnecessary.  Can not simultaneously use more than one mapping
+ 	 * since then readdir could list files that open could not open
+ 	 */
+ 	ctx->remap = true;
+ 
+ 	/* default to only allowing write access to owner of the mount */
+ 	ctx->dir_mode = ctx->file_mode = S_IRUGO | S_IXUGO | S_IWUSR;
+ 
+ 	/* ctx->retry default is 0 (i.e. "soft" limited retry not hard retry) */
+ 	/* default is always to request posix paths. */
+ 	ctx->posix_paths = 1;
+ 	/* default to using server inode numbers where available */
+ 	ctx->server_ino = 1;
+ 
+ 	/* default is to use strict cifs caching semantics */
+ 	ctx->strict_io = true;
+ 
+ 	ctx->actimeo = CIFS_DEF_ACTIMEO;
+ 
+ 	/* Most clients set timeout to 0, allows server to use its default */
+ 	ctx->handle_timeout = 0; /* See MS-SMB2 spec section 2.2.14.2.12 */
+ 
+ 	/* offer SMB2.1 and later (SMB3 etc). Secure and widely accepted */
+ 	ctx->ops = &smb30_operations;
+ 	ctx->vals = &smbdefault_values;
+ 
+ 	ctx->echo_interval = SMB_ECHO_INTERVAL_DEFAULT;
+ 
+ 	/* default to no multichannel (single server connection) */
+ 	ctx->multichannel = false;
+ 	ctx->max_channels = 1;
+ 
+ 	ctx->backupuid_specified = false; /* no backup intent for a user */
+ 	ctx->backupgid_specified = false; /* no backup intent for a group */
+ 
+ /*
+  *	short int override_uid = -1;
+  *	short int override_gid = -1;
+  *	char *nodename = strdup(utsname()->nodename);
+  *	struct sockaddr *dstaddr = (struct sockaddr *)&vol->dstaddr;
+  */
+ 
+ 	fc->fs_private = ctx;
+ 	fc->ops = &smb3_fs_context_ops;
+ 	return 0;
+ }
+ 
+ void
+ smb3_cleanup_fs_context_contents(struct smb3_fs_context *ctx)
+ {
+ 	if (ctx == NULL)
+ 		return;
+ 
+ 	/*
+ 	 * Make sure this stays in sync with smb3_fs_context_dup()
+ 	 */
+ 	kfree(ctx->mount_options);
+ 	ctx->mount_options = NULL;
+ 	kfree(ctx->username);
+ 	ctx->username = NULL;
+ 	kfree_sensitive(ctx->password);
+ 	ctx->password = NULL;
+ 	kfree(ctx->UNC);
+ 	ctx->UNC = NULL;
+ 	kfree(ctx->domainname);
+ 	ctx->domainname = NULL;
+ 	kfree(ctx->nodename);
+ 	ctx->nodename = NULL;
+ 	kfree(ctx->iocharset);
+ 	ctx->iocharset = NULL;
+ 	kfree(ctx->prepath);
+ 	ctx->prepath = NULL;
+ 
+ 	unload_nls(ctx->local_nls);
+ 	ctx->local_nls = NULL;
+ }
+ 
+ void
+ smb3_cleanup_fs_context(struct smb3_fs_context *ctx)
+ {
+ 	if (!ctx)
+ 		return;
+ 	smb3_cleanup_fs_context_contents(ctx);
+ 	kfree(ctx);
+ }
++>>>>>>> c741cba2cd1d (cifs: move cifs_cleanup_volume_info[_content] to fs_context.c)
diff --cc fs/cifs/fs_context.h
index 3a66199f3cb7,4c4c392b9767..000000000000
--- a/fs/cifs/fs_context.h
+++ b/fs/cifs/fs_context.h
@@@ -247,9 -242,26 +247,27 @@@ struct smb3_fs_context 
  	unsigned int max_channels;
  	__u16 compression; /* compression algorithm 0xFFFF default 0=disabled */
  	bool rootfs:1; /* if it's a SMB root file system */
 -	bool witness:1; /* use witness protocol */
 -
 -	char *mount_options;
  };
  
++<<<<<<< HEAD
 +extern int cifs_parse_security_flavors(char *value, struct smb3_fs_context *ctx);
++=======
+ extern const struct fs_parameter_spec smb3_fs_parameters[];
+ 
+ extern int cifs_parse_cache_flavor(char *value,
+ 				   struct smb3_fs_context *ctx);
+ extern int cifs_parse_security_flavors(char *value,
+ 				       struct smb3_fs_context *ctx);
+ extern int smb3_init_fs_context(struct fs_context *fc);
+ extern void smb3_cleanup_fs_context_contents(struct smb3_fs_context *ctx);
+ extern void smb3_cleanup_fs_context(struct smb3_fs_context *ctx);
+ 
+ static inline struct smb3_fs_context *smb3_fc2context(const struct fs_context *fc)
+ {
+ 	return fc->fs_private;
+ }
+ 
++>>>>>>> c741cba2cd1d (cifs: move cifs_cleanup_volume_info[_content] to fs_context.c)
  extern int smb3_fs_context_dup(struct smb3_fs_context *new_ctx, struct smb3_fs_context *ctx);
  
  #endif
* Unmerged path fs/cifs/cifsfs.c
* Unmerged path fs/cifs/cifsproto.h
* Unmerged path fs/cifs/connect.c
diff --git a/fs/cifs/dfs_cache.c b/fs/cifs/dfs_cache.c
index 14029a7cec23..a2c1af53041a 100644
--- a/fs/cifs/dfs_cache.c
+++ b/fs/cifs/dfs_cache.c
@@ -586,7 +586,7 @@ static void __vol_release(struct vol_info *vi)
 {
 	kfree(vi->fullpath);
 	kfree(vi->mntdata);
-	cifs_cleanup_volume_info_contents(&vi->ctx);
+	smb3_cleanup_fs_context_contents(&vi->ctx);
 	kfree(vi);
 }
 
@@ -1469,7 +1469,7 @@ static struct cifs_ses *find_root_ses(struct vol_info *vi,
 	ses = cifs_get_smb_ses(server, &ctx);
 
 out:
-	cifs_cleanup_volume_info_contents(&ctx);
+	smb3_cleanup_fs_context_contents(&ctx);
 	kfree(mdata);
 	kfree(rpath);
 
* Unmerged path fs/cifs/fs_context.c
* Unmerged path fs/cifs/fs_context.h
