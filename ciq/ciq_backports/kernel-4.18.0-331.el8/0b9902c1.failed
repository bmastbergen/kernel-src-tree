s390/qeth: fix deadlock during recovery

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Julian Wiedmann <jwi@linux.ibm.com>
commit 0b9902c1fcc59ba75268386c0420a554f8844168
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/0b9902c1.failed

When qeth_dev_layer2_store() - holding the discipline_mutex - waits
inside qeth_l*_remove_device() for a qeth_do_reset() thread to complete,
we can hit a deadlock if qeth_do_reset() concurrently calls
qeth_set_online() and thus tries to aquire the discipline_mutex.

Move the discipline_mutex locking outside of qeth_set_online() and
qeth_set_offline(), and turn the discipline into a parameter so that
callers understand the dependency.

To fix the deadlock, we can now relax the locking:
As already established, qeth_l*_remove_device() waits for
qeth_do_reset() to complete. So qeth_do_reset() itself is under no risk
of having card->discipline ripped out while it's running, and thus
doesn't need to take the discipline_mutex.

Fixes: 9dc48ccc68b9 ("qeth: serialize sysfs-triggered device configurations")
	Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
	Reviewed-by: Alexandra Winter <wintera@linux.ibm.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 0b9902c1fcc59ba75268386c0420a554f8844168)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/s390/net/qeth_core_main.c
#	drivers/s390/net/qeth_l2_main.c
diff --cc drivers/s390/net/qeth_core_main.c
index df4f9c49c6d3,d45e223fc521..000000000000
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@@ -5513,7 -5525,11 +5513,15 @@@ static int qeth_set_online(struct qeth_
  
  	qeth_print_status_message(card);
  
++<<<<<<< HEAD
 +	rc = card->discipline->set_online(card, carrier_ok);
++=======
+ 	if (card->dev->reg_state != NETREG_REGISTERED)
+ 		/* no need for locking / error handling at this early stage: */
+ 		qeth_set_real_num_tx_queues(card, qeth_tx_actual_queues(card));
+ 
+ 	rc = disc->set_online(card, carrier_ok);
++>>>>>>> 0b9902c1fcc5 (s390/qeth: fix deadlock during recovery)
  	if (rc)
  		goto err_online;
  
diff --cc drivers/s390/net/qeth_l2_main.c
index 8df43a961040,37279b1e29f6..000000000000
--- a/drivers/s390/net/qeth_l2_main.c
+++ b/drivers/s390/net/qeth_l2_main.c
@@@ -2358,6 -2172,181 +2358,184 @@@ static void qeth_l2_vnicc_set_defaults(
  	card->options.vnicc.wanted_chars = QETH_VNICC_DEFAULT;
  }
  
++<<<<<<< HEAD
++=======
+ static const struct device_type qeth_l2_devtype = {
+ 	.name = "qeth_layer2",
+ 	.groups = qeth_l2_attr_groups,
+ };
+ 
+ static int qeth_l2_probe_device(struct ccwgroup_device *gdev)
+ {
+ 	struct qeth_card *card = dev_get_drvdata(&gdev->dev);
+ 	int rc;
+ 
+ 	if (IS_OSN(card))
+ 		dev_notice(&gdev->dev, "OSN support will be dropped in 2021\n");
+ 
+ 	qeth_l2_vnicc_set_defaults(card);
+ 	mutex_init(&card->sbp_lock);
+ 
+ 	if (gdev->dev.type == &qeth_generic_devtype) {
+ 		rc = device_add_groups(&gdev->dev, qeth_l2_attr_groups);
+ 		if (rc)
+ 			return rc;
+ 	}
+ 
+ 	INIT_WORK(&card->rx_mode_work, qeth_l2_rx_mode_work);
+ 	return 0;
+ }
+ 
+ static void qeth_l2_remove_device(struct ccwgroup_device *gdev)
+ {
+ 	struct qeth_card *card = dev_get_drvdata(&gdev->dev);
+ 
+ 	if (gdev->dev.type == &qeth_generic_devtype)
+ 		device_remove_groups(&gdev->dev, qeth_l2_attr_groups);
+ 	qeth_set_allowed_threads(card, 0, 1);
+ 	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
+ 
+ 	if (gdev->state == CCWGROUP_ONLINE) {
+ 		mutex_lock(&card->discipline_mutex);
+ 		qeth_set_offline(card, card->discipline, false);
+ 		mutex_unlock(&card->discipline_mutex);
+ 	}
+ 
+ 	cancel_work_sync(&card->close_dev_work);
+ 	if (card->dev->reg_state == NETREG_REGISTERED)
+ 		unregister_netdev(card->dev);
+ }
+ 
+ static int qeth_l2_set_online(struct qeth_card *card, bool carrier_ok)
+ {
+ 	struct net_device *dev = card->dev;
+ 	int rc = 0;
+ 
+ 	qeth_l2_detect_dev2br_support(card);
+ 
+ 	mutex_lock(&card->sbp_lock);
+ 	qeth_bridgeport_query_support(card);
+ 	if (card->options.sbp.supported_funcs) {
+ 		qeth_l2_setup_bridgeport_attrs(card);
+ 		dev_info(&card->gdev->dev,
+ 			 "The device represents a Bridge Capable Port\n");
+ 	}
+ 	mutex_unlock(&card->sbp_lock);
+ 
+ 	qeth_l2_register_dev_addr(card);
+ 
+ 	/* for the rx_bcast characteristic, init VNICC after setmac */
+ 	qeth_l2_vnicc_init(card);
+ 
+ 	qeth_l2_trace_features(card);
+ 
+ 	/* softsetup */
+ 	QETH_CARD_TEXT(card, 2, "softsetp");
+ 
+ 	card->state = CARD_STATE_SOFTSETUP;
+ 
+ 	qeth_set_allowed_threads(card, 0xffffffff, 0);
+ 
+ 	if (dev->reg_state != NETREG_REGISTERED) {
+ 		rc = qeth_l2_setup_netdev(card);
+ 		if (rc)
+ 			goto err_setup;
+ 
+ 		if (carrier_ok)
+ 			netif_carrier_on(dev);
+ 	} else {
+ 		rtnl_lock();
+ 		rc = qeth_set_real_num_tx_queues(card,
+ 						 qeth_tx_actual_queues(card));
+ 		if (rc) {
+ 			rtnl_unlock();
+ 			goto err_set_queues;
+ 		}
+ 
+ 		if (carrier_ok)
+ 			netif_carrier_on(dev);
+ 		else
+ 			netif_carrier_off(dev);
+ 
+ 		netif_device_attach(dev);
+ 		qeth_enable_hw_features(dev);
+ 		qeth_l2_enable_brport_features(card);
+ 
+ 		if (card->info.open_when_online) {
+ 			card->info.open_when_online = 0;
+ 			dev_open(dev, NULL);
+ 		}
+ 		rtnl_unlock();
+ 	}
+ 	return 0;
+ 
+ err_set_queues:
+ err_setup:
+ 	qeth_set_allowed_threads(card, 0, 1);
+ 	card->state = CARD_STATE_DOWN;
+ 	return rc;
+ }
+ 
+ static void qeth_l2_set_offline(struct qeth_card *card)
+ {
+ 	struct qeth_priv *priv = netdev_priv(card->dev);
+ 
+ 	qeth_set_allowed_threads(card, 0, 1);
+ 	qeth_l2_drain_rx_mode_cache(card);
+ 
+ 	if (card->state == CARD_STATE_SOFTSETUP)
+ 		card->state = CARD_STATE_DOWN;
+ 
+ 	qeth_l2_set_pnso_mode(card, QETH_PNSO_NONE);
+ 	if (priv->brport_features & BR_LEARNING_SYNC)
+ 		qeth_l2_dev2br_fdb_flush(card);
+ }
+ 
+ /* Returns zero if the command is successfully "consumed" */
+ static int qeth_l2_control_event(struct qeth_card *card,
+ 				 struct qeth_ipa_cmd *cmd)
+ {
+ 	switch (cmd->hdr.command) {
+ 	case IPA_CMD_SETBRIDGEPORT_OSA:
+ 	case IPA_CMD_SETBRIDGEPORT_IQD:
+ 		if (cmd->data.sbp.hdr.command_code ==
+ 		    IPA_SBP_BRIDGE_PORT_STATE_CHANGE) {
+ 			qeth_bridge_state_change(card, cmd);
+ 			return 0;
+ 		}
+ 
+ 		return 1;
+ 	case IPA_CMD_ADDRESS_CHANGE_NOTIF:
+ 		qeth_addr_change_event(card, cmd);
+ 		return 0;
+ 	default:
+ 		return 1;
+ 	}
+ }
+ 
+ const struct qeth_discipline qeth_l2_discipline = {
+ 	.devtype = &qeth_l2_devtype,
+ 	.setup = qeth_l2_probe_device,
+ 	.remove = qeth_l2_remove_device,
+ 	.set_online = qeth_l2_set_online,
+ 	.set_offline = qeth_l2_set_offline,
+ 	.do_ioctl = NULL,
+ 	.control_event_handler = qeth_l2_control_event,
+ };
+ EXPORT_SYMBOL_GPL(qeth_l2_discipline);
+ 
+ static int __init qeth_l2_init(void)
+ {
+ 	pr_info("register layer 2 discipline\n");
+ 	return 0;
+ }
+ 
+ static void __exit qeth_l2_exit(void)
+ {
+ 	pr_info("unregister layer 2 discipline\n");
+ }
+ 
++>>>>>>> 0b9902c1fcc5 (s390/qeth: fix deadlock during recovery)
  module_init(qeth_l2_init);
  module_exit(qeth_l2_exit);
  MODULE_AUTHOR("Frank Blaschka <frank.blaschka@de.ibm.com>");
diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h
index 1253c108a9a2..5dc2eb10a74a 100644
--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@ -1040,7 +1040,8 @@ struct qeth_card *qeth_get_card_by_busid(char *bus_id);
 void qeth_set_allowed_threads(struct qeth_card *card, unsigned long threads,
 			      int clear_start_mask);
 int qeth_threads_running(struct qeth_card *, unsigned long);
-int qeth_set_offline(struct qeth_card *card, bool resetting);
+int qeth_set_offline(struct qeth_card *card, const struct qeth_discipline *disc,
+		     bool resetting);
 
 int qeth_send_ipa_cmd(struct qeth_card *, struct qeth_cmd_buffer *,
 		  int (*reply_cb)
* Unmerged path drivers/s390/net/qeth_core_main.c
* Unmerged path drivers/s390/net/qeth_l2_main.c
diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c
index 000c05b39ba7..590d1e6aaf25 100644
--- a/drivers/s390/net/qeth_l3_main.c
+++ b/drivers/s390/net/qeth_l3_main.c
@@ -1973,8 +1973,11 @@ static void qeth_l3_remove_device(struct ccwgroup_device *cgdev)
 	qeth_set_allowed_threads(card, 0, 1);
 	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
 
-	if (cgdev->state == CCWGROUP_ONLINE)
-		qeth_set_offline(card, false);
+	if (cgdev->state == CCWGROUP_ONLINE) {
+		mutex_lock(&card->discipline_mutex);
+		qeth_set_offline(card, card->discipline, false);
+		mutex_unlock(&card->discipline_mutex);
+	}
 
 	cancel_work_sync(&card->close_dev_work);
 	if (card->dev->reg_state == NETREG_REGISTERED)
