mlxsw: spectrum_router: Consolidate mlxsw_sp_nexthop{4, 6}_type_fini()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Ido Schimmel <idosch@nvidia.com>
commit 9ed2b4d28795948303e516edbdd73e4265bdfc73
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/9ed2b4d2.failed

The two functions are identical, so consolidate them to
mlxsw_sp_nexthop_type_fini().

	Signed-off-by: Ido Schimmel <idosch@nvidia.com>
	Reviewed-by: Jiri Pirko <jiri@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 9ed2b4d28795948303e516edbdd73e4265bdfc73)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
diff --cc drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
index 2ec7cd201d01,ca9f7d06eab1..000000000000
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
@@@ -3938,10 -3929,19 +3938,26 @@@ err_neigh_init
  	return err;
  }
  
++<<<<<<< HEAD
 +static void mlxsw_sp_nexthop4_type_fini(struct mlxsw_sp *mlxsw_sp,
 +					struct mlxsw_sp_nexthop *nh)
 +{
 +	mlxsw_sp_nexthop_type_fini(mlxsw_sp, nh);
++=======
+ static void mlxsw_sp_nexthop_type_fini(struct mlxsw_sp *mlxsw_sp,
+ 				       struct mlxsw_sp_nexthop *nh)
+ {
+ 	switch (nh->type) {
+ 	case MLXSW_SP_NEXTHOP_TYPE_ETH:
+ 		mlxsw_sp_nexthop_neigh_fini(mlxsw_sp, nh);
+ 		mlxsw_sp_nexthop_rif_fini(nh);
+ 		break;
+ 	case MLXSW_SP_NEXTHOP_TYPE_IPIP:
+ 		mlxsw_sp_nexthop_rif_fini(nh);
+ 		mlxsw_sp_nexthop_ipip_fini(mlxsw_sp, nh);
+ 		break;
+ 	}
++>>>>>>> 9ed2b4d28795 (mlxsw: spectrum_router: Consolidate mlxsw_sp_nexthop{4, 6}_type_fini())
  }
  
  static int mlxsw_sp_nexthop4_init(struct mlxsw_sp *mlxsw_sp,
@@@ -4016,10 -4017,10 +4032,10 @@@ static void mlxsw_sp_nexthop4_event(str
  
  	switch (event) {
  	case FIB_EVENT_NH_ADD:
 -		mlxsw_sp_nexthop_type_init(mlxsw_sp, nh, fib_nh->fib_nh_dev);
 +		mlxsw_sp_nexthop4_type_init(mlxsw_sp, nh, fib_nh);
  		break;
  	case FIB_EVENT_NH_DEL:
- 		mlxsw_sp_nexthop4_type_fini(mlxsw_sp, nh);
+ 		mlxsw_sp_nexthop_type_fini(mlxsw_sp, nh);
  		break;
  	}
  
@@@ -5304,54 -5341,10 +5320,48 @@@ static bool mlxsw_sp_nexthop6_ipip_type
  					const struct fib6_info *rt,
  					enum mlxsw_sp_ipip_type *ret)
  {
 -	return rt->fib6_nh->fib_nh_dev &&
 -	       mlxsw_sp_netdev_ipip_type(mlxsw_sp, rt->fib6_nh->fib_nh_dev, ret);
 +	return rt->fib6_nh.nh_dev &&
 +	       mlxsw_sp_netdev_ipip_type(mlxsw_sp, rt->fib6_nh.nh_dev, ret);
 +}
 +
 +static int mlxsw_sp_nexthop6_type_init(struct mlxsw_sp *mlxsw_sp,
 +				       struct mlxsw_sp_nexthop_group *nh_grp,
 +				       struct mlxsw_sp_nexthop *nh,
 +				       const struct fib6_info *rt)
 +{
 +	const struct mlxsw_sp_ipip_ops *ipip_ops;
 +	struct mlxsw_sp_ipip_entry *ipip_entry;
 +	struct net_device *dev = rt->fib6_nh.nh_dev;
 +	struct mlxsw_sp_rif *rif;
 +	int err;
 +
 +	ipip_entry = mlxsw_sp_ipip_entry_find_by_ol_dev(mlxsw_sp, dev);
 +	if (ipip_entry) {
 +		ipip_ops = mlxsw_sp->router->ipip_ops_arr[ipip_entry->ipipt];
 +		if (ipip_ops->can_offload(mlxsw_sp, dev)) {
 +			nh->type = MLXSW_SP_NEXTHOP_TYPE_IPIP;
 +			mlxsw_sp_nexthop_ipip_init(mlxsw_sp, nh, ipip_entry);
 +			return 0;
 +		}
 +	}
 +
 +	nh->type = MLXSW_SP_NEXTHOP_TYPE_ETH;
 +	rif = mlxsw_sp_rif_find_by_dev(mlxsw_sp, dev);
 +	if (!rif)
 +		return 0;
 +	mlxsw_sp_nexthop_rif_init(nh, rif);
 +
 +	err = mlxsw_sp_nexthop_neigh_init(mlxsw_sp, nh);
 +	if (err)
 +		goto err_nexthop_neigh_init;
 +
 +	return 0;
 +
 +err_nexthop_neigh_init:
 +	mlxsw_sp_nexthop_rif_fini(nh);
 +	return err;
  }
  
- static void mlxsw_sp_nexthop6_type_fini(struct mlxsw_sp *mlxsw_sp,
- 					struct mlxsw_sp_nexthop *nh)
- {
- 	mlxsw_sp_nexthop_type_fini(mlxsw_sp, nh);
- }
- 
  static int mlxsw_sp_nexthop6_init(struct mlxsw_sp *mlxsw_sp,
  				  struct mlxsw_sp_nexthop_group *nh_grp,
  				  struct mlxsw_sp_nexthop *nh,
* Unmerged path drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c
