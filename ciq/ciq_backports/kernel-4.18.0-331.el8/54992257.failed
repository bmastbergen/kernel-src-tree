gfs2: Add new gfs2_iomap_get helper

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 54992257fe4bb9f76f66b3863492aa8cc5567790
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/54992257.failed

Rename the current gfs2_iomap_get and gfs2_iomap_alloc functions to __*.
Add a new gfs2_iomap_get helper that doesn't expose struct metapath.
Rename gfs2_iomap_get_alloc to gfs2_iomap_alloc.  Use the new helpers
where they make sense.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 54992257fe4bb9f76f66b3863492aa8cc5567790)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/bmap.c
diff --cc fs/gfs2/bmap.c
index 43b2618706ac,cc12dc0d6955..000000000000
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@@ -635,10 -632,9 +635,10 @@@ enum alloc_state 
  };
  
  /**
-  * gfs2_iomap_alloc - Build a metadata tree of the requested height
+  * __gfs2_iomap_alloc - Build a metadata tree of the requested height
   * @inode: The GFS2 inode
   * @iomap: The iomap structure
 + * @flags: iomap flags
   * @mp: The metapath, with proper height information calculated
   *
   * In this routine we may have to alloc:
@@@ -664,8 -660,8 +664,13 @@@
   * Returns: errno on error
   */
  
++<<<<<<< HEAD
 +static int gfs2_iomap_alloc(struct inode *inode, struct iomap *iomap,
 +			    unsigned flags, struct metapath *mp)
++=======
+ static int __gfs2_iomap_alloc(struct inode *inode, struct iomap *iomap,
+ 			      struct metapath *mp)
++>>>>>>> 54992257fe4b (gfs2: Add new gfs2_iomap_get helper)
  {
  	struct gfs2_inode *ip = GFS2_I(inode);
  	struct gfs2_sbd *sdp = GFS2_SB(inode);
@@@ -1120,7 -1114,7 +1123,11 @@@ static int gfs2_iomap_begin_write(struc
  		}
  
  		if (iomap->type == IOMAP_HOLE) {
++<<<<<<< HEAD
 +			ret = gfs2_iomap_alloc(inode, iomap, flags, mp);
++=======
+ 			ret = __gfs2_iomap_alloc(inode, iomap, mp);
++>>>>>>> 54992257fe4b (gfs2: Add new gfs2_iomap_get helper)
  			if (ret) {
  				gfs2_trans_end(sdp);
  				gfs2_inplace_release(ip);
@@@ -1303,10 -1296,10 +1308,17 @@@ int gfs2_block_map(struct inode *inode
  	clear_buffer_boundary(bh_map);
  	trace_gfs2_bmap(ip, bh_map, lblock, create, 1);
  
++<<<<<<< HEAD
 +	ret = gfs2_iomap_get(inode, pos, length, flags, &iomap, &mp);
 +	if (create && !ret && iomap.type == IOMAP_HOLE)
 +		ret = gfs2_iomap_alloc(inode, &iomap, IOMAP_WRITE, &mp);
 +	release_metapath(&mp);
++=======
+ 	if (!create)
+ 		ret = gfs2_iomap_get(inode, pos, length, &iomap);
+ 	else
+ 		ret = gfs2_iomap_alloc(inode, pos, length, &iomap);
++>>>>>>> 54992257fe4b (gfs2: Add new gfs2_iomap_get helper)
  	if (ret)
  		goto out;
  
@@@ -1470,9 -1474,9 +1493,13 @@@ int gfs2_iomap_alloc(struct inode *inod
  	struct metapath mp = { .mp_aheight = 1, };
  	int ret;
  
- 	ret = gfs2_iomap_get(inode, pos, length, IOMAP_WRITE, iomap, &mp);
+ 	ret = __gfs2_iomap_get(inode, pos, length, IOMAP_WRITE, iomap, &mp);
  	if (!ret && iomap->type == IOMAP_HOLE)
++<<<<<<< HEAD
 +		ret = gfs2_iomap_alloc(inode, iomap, IOMAP_WRITE, &mp);
++=======
+ 		ret = __gfs2_iomap_alloc(inode, iomap, &mp);
++>>>>>>> 54992257fe4b (gfs2: Add new gfs2_iomap_get helper)
  	release_metapath(&mp);
  	return ret;
  }
@@@ -2518,3 -2522,24 +2545,27 @@@ out
  		gfs2_trans_end(sdp);
  	return error;
  }
++<<<<<<< HEAD
++=======
+ 
+ static int gfs2_map_blocks(struct iomap_writepage_ctx *wpc, struct inode *inode,
+ 		loff_t offset)
+ {
+ 	int ret;
+ 
+ 	if (WARN_ON_ONCE(gfs2_is_stuffed(GFS2_I(inode))))
+ 		return -EIO;
+ 
+ 	if (offset >= wpc->iomap.offset &&
+ 	    offset < wpc->iomap.offset + wpc->iomap.length)
+ 		return 0;
+ 
+ 	memset(&wpc->iomap, 0, sizeof(wpc->iomap));
+ 	ret = gfs2_iomap_get(inode, offset, INT_MAX, &wpc->iomap);
+ 	return ret;
+ }
+ 
+ const struct iomap_writeback_ops gfs2_writeback_ops = {
+ 	.map_blocks		= gfs2_map_blocks,
+ };
++>>>>>>> 54992257fe4b (gfs2: Add new gfs2_iomap_get helper)
* Unmerged path fs/gfs2/bmap.c
diff --git a/fs/gfs2/bmap.h b/fs/gfs2/bmap.h
index 19a1fd772c61..7652f802ec4b 100644
--- a/fs/gfs2/bmap.h
+++ b/fs/gfs2/bmap.h
@@ -51,8 +51,10 @@ extern const struct iomap_ops gfs2_iomap_ops;
 extern int gfs2_unstuff_dinode(struct gfs2_inode *ip, struct page *page);
 extern int gfs2_block_map(struct inode *inode, sector_t lblock,
 			  struct buffer_head *bh, int create);
-extern int gfs2_iomap_get_alloc(struct inode *inode, loff_t pos, loff_t length,
-				struct iomap *iomap);
+extern int gfs2_iomap_get(struct inode *inode, loff_t pos, loff_t length,
+			  struct iomap *iomap);
+extern int gfs2_iomap_alloc(struct inode *inode, loff_t pos, loff_t length,
+			    struct iomap *iomap);
 extern int gfs2_extent_map(struct inode *inode, u64 lblock, int *new,
 			   u64 *dblock, unsigned *extlen);
 extern int gfs2_setattr_size(struct inode *inode, u64 size);
diff --git a/fs/gfs2/file.c b/fs/gfs2/file.c
index ac633238b304..32be4f8a8081 100644
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@ -384,7 +384,7 @@ static int gfs2_allocate_page_backing(struct page *page, unsigned int length)
 	do {
 		struct iomap iomap = { };
 
-		if (gfs2_iomap_get_alloc(page->mapping->host, pos, length, &iomap))
+		if (gfs2_iomap_alloc(page->mapping->host, pos, length, &iomap))
 			return -EIO;
 
 		if (length < iomap.length)
@@ -898,8 +898,7 @@ static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,
 	while (offset < end) {
 		struct iomap iomap = { };
 
-		error = gfs2_iomap_get_alloc(inode, offset, end - offset,
-					     &iomap);
+		error = gfs2_iomap_alloc(inode, offset, end - offset, &iomap);
 		if (error)
 			goto out;
 		offset = iomap.offset + iomap.length;
