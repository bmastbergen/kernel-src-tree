hwmon: (k10temp) Remove support for displaying voltage and current on Zen CPUs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Guenter Roeck <linux@roeck-us.net>
commit 0a4e668b5d52eed8026f5d717196b02b55fb2dc6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/0a4e668b.failed

Voltages and current are reported by Zen CPUs. However, the means
to do so is undocumented, changes from CPU to CPU, and the raw data
is not calibrated. Calibration information is available, but again
not documented. This results in less than perfect user experience,
up to concerns that loading the driver might possibly damage
the hardware (by reporting out-of range voltages). Effectively
support for reporting voltages and current is not maintainable.
Drop it.

	Cc: Artem S. Tashkinov <aros@gmx.com>
	Cc: Wei Huang <wei.huang2@amd.com>
	Tested-by: Wei Huang <wei.huang2@amd.com>
	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
(cherry picked from commit 0a4e668b5d52eed8026f5d717196b02b55fb2dc6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hwmon/k10temp.c
diff --cc drivers/hwmon/k10temp.c
index c73c6199bfdb,3bc2551577a3..000000000000
--- a/drivers/hwmon/k10temp.c
+++ b/drivers/hwmon/k10temp.c
@@@ -5,8 -5,15 +5,17 @@@
   *
   * Copyright (c) 2009 Clemens Ladisch <clemens@ladisch.de>
   * Copyright (c) 2020 Guenter Roeck <linux@roeck-us.net>
++<<<<<<< HEAD
++=======
+  *
+  * Implementation notes:
+  * - CCD register address information as well as the calculation to
+  *   convert raw register values is from https://github.com/ocerman/zenpower.
+  *   The information is not confirmed from chip datasheets, but experiments
+  *   suggest that it provides reasonable temperature values.
++>>>>>>> 0a4e668b5d52 (hwmon: (k10temp) Remove support for displaying voltage and current on Zen CPUs)
   */
  
 -#include <linux/bitops.h>
  #include <linux/err.h>
  #include <linux/hwmon.h>
  #include <linux/init.h>
@@@ -67,9 -101,17 +76,14 @@@ struct k10temp_data 
  	void (*read_tempreg)(struct pci_dev *pdev, u32 *regval);
  	int temp_offset;
  	u32 temp_adjust_mask;
++<<<<<<< HEAD
 +	bool show_tdie;
++=======
+ 	u32 show_temp;
+ 	bool is_zen;
++>>>>>>> 0a4e668b5d52 (hwmon: (k10temp) Remove support for displaying voltage and current on Zen CPUs)
  };
  
 -#define TCTL_BIT	0
 -#define TDIE_BIT	1
 -#define TCCD_BIT(x)	((x) + 2)
 -
 -#define HAVE_TEMP(d, channel)	((d)->show_temp & BIT(channel))
 -#define HAVE_TDIE(d)		HAVE_TEMP(d, TDIE_BIT)
 -
  struct tctl_offset {
  	u8 model;
  	char const *id;
@@@ -136,21 -178,35 +150,47 @@@ static long get_raw_temp(struct k10temp
  	return temp;
  }
  
 -static const char *k10temp_temp_label[] = {
 -	"Tctl",
 +const char *k10temp_temp_label[] = {
  	"Tdie",
++<<<<<<< HEAD
 +	"Tctl",
++=======
+ 	"Tccd1",
+ 	"Tccd2",
+ 	"Tccd3",
+ 	"Tccd4",
+ 	"Tccd5",
+ 	"Tccd6",
+ 	"Tccd7",
+ 	"Tccd8",
++>>>>>>> 0a4e668b5d52 (hwmon: (k10temp) Remove support for displaying voltage and current on Zen CPUs)
  };
  
  static int k10temp_read_labels(struct device *dev,
  			       enum hwmon_sensor_types type,
  			       u32 attr, int channel, const char **str)
  {
++<<<<<<< HEAD
 +	*str = k10temp_temp_label[channel];
 +	return 0;
 +}
 +
 +static int k10temp_read(struct device *dev, enum hwmon_sensor_types type,
 +			u32 attr, int channel, long *val)
++=======
+ 	switch (type) {
+ 	case hwmon_temp:
+ 		*str = k10temp_temp_label[channel];
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ 	return 0;
+ }
+ 
+ static int k10temp_read_temp(struct device *dev, u32 attr, int channel,
+ 			     long *val)
++>>>>>>> 0a4e668b5d52 (hwmon: (k10temp) Remove support for displaying voltage and current on Zen CPUs)
  {
  	struct k10temp_data *data = dev_get_drvdata(dev);
  	u32 regval;
@@@ -190,6 -251,17 +230,20 @@@
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int k10temp_read(struct device *dev, enum hwmon_sensor_types type,
+ 			u32 attr, int channel, long *val)
+ {
+ 	switch (type) {
+ 	case hwmon_temp:
+ 		return k10temp_read_temp(dev, attr, channel, val);
+ 	default:
+ 		return -EOPNOTSUPP;
+ 	}
+ }
+ 
++>>>>>>> 0a4e668b5d52 (hwmon: (k10temp) Remove support for displaying voltage and current on Zen CPUs)
  static umode_t k10temp_is_visible(const void *_data,
  				  enum hwmon_sensor_types type,
  				  u32 attr, int channel)
@@@ -321,10 -423,35 +375,42 @@@ static int k10temp_probe(struct pci_de
  	     (boot_cpu_data.x86_model & 0xf0) == 0x70)) {
  		data->read_htcreg = read_htcreg_nb_f15;
  		data->read_tempreg = read_tempreg_nb_f15;
++<<<<<<< HEAD
 +	} else if (boot_cpu_data.x86 == 0x17 || boot_cpu_data.x86 == 0x19) {
 +		data->temp_adjust_mask = 0x80000;
 +		data->read_tempreg = read_tempreg_nb_f17;
 +		data->show_tdie = true;
++=======
+ 	} else if (boot_cpu_data.x86 == 0x17 || boot_cpu_data.x86 == 0x18) {
+ 		data->temp_adjust_mask = ZEN_CUR_TEMP_RANGE_SEL_MASK;
+ 		data->read_tempreg = read_tempreg_nb_zen;
+ 		data->show_temp |= BIT(TDIE_BIT);	/* show Tdie */
+ 		data->is_zen = true;
+ 
+ 		switch (boot_cpu_data.x86_model) {
+ 		case 0x1:	/* Zen */
+ 		case 0x8:	/* Zen+ */
+ 		case 0x11:	/* Zen APU */
+ 		case 0x18:	/* Zen+ APU */
+ 			k10temp_get_ccd_support(pdev, data, 4);
+ 			break;
+ 		case 0x31:	/* Zen2 Threadripper */
+ 		case 0x71:	/* Zen2 */
+ 			k10temp_get_ccd_support(pdev, data, 8);
+ 			break;
+ 		}
+ 	} else if (boot_cpu_data.x86 == 0x19) {
+ 		data->temp_adjust_mask = ZEN_CUR_TEMP_RANGE_SEL_MASK;
+ 		data->read_tempreg = read_tempreg_nb_zen;
+ 		data->show_temp |= BIT(TDIE_BIT);
+ 		data->is_zen = true;
+ 
+ 		switch (boot_cpu_data.x86_model) {
+ 		case 0x0 ... 0x1:	/* Zen3 */
+ 			k10temp_get_ccd_support(pdev, data, 8);
+ 			break;
+ 		}
++>>>>>>> 0a4e668b5d52 (hwmon: (k10temp) Remove support for displaying voltage and current on Zen CPUs)
  	} else {
  		data->read_htcreg = read_htcreg_pci;
  		data->read_tempreg = read_tempreg_pci;
* Unmerged path drivers/hwmon/k10temp.c
