udpv6: fix possible user after free in error handler

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 424a7cd078401591fc45587ffb2c012d7f402fb7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/424a7cd0.failed

Before derefencing the encap pointer, commit e7cc082455cb ("udp: Support
for error handlers of tunnels with arbitrary destination port") checks
for a NULL value, but the two fetch operation can race with removal.
Fix the above using a single access.
Also fix a couple of type annotations, to make sparse happy.

Fixes: e7cc082455cb ("udp: Support for error handlers of tunnels with arbitrary destination port")
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Acked-by: Stefano Brivio <sbrivio@redhat.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 424a7cd078401591fc45587ffb2c012d7f402fb7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv6/udp.c
diff --cc net/ipv6/udp.c
index 95b045e9a4aa,b444483cdb2b..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -479,6 -415,31 +479,34 @@@ void udpv6_encap_enable(void
  }
  EXPORT_SYMBOL(udpv6_encap_enable);
  
++<<<<<<< HEAD
++=======
+ /* Handler for tunnels with arbitrary destination ports: no socket lookup, go
+  * through error handlers in encapsulations looking for a match.
+  */
+ static int __udp6_lib_err_encap_no_sk(struct sk_buff *skb,
+ 				      struct inet6_skb_parm *opt,
+ 				      u8 type, u8 code, int offset, __be32 info)
+ {
+ 	int i;
+ 
+ 	for (i = 0; i < MAX_IPTUN_ENCAP_OPS; i++) {
+ 		int (*handler)(struct sk_buff *skb, struct inet6_skb_parm *opt,
+ 			       u8 type, u8 code, int offset, __be32 info);
+ 		const struct ip6_tnl_encap_ops *encap;
+ 
+ 		encap = rcu_dereference(ip6tun_encaps[i]);
+ 		if (!encap)
+ 			continue;
+ 		handler = encap->err_handler;
+ 		if (handler && !handler(skb, opt, type, code, offset, info))
+ 			return 0;
+ 	}
+ 
+ 	return -ENOENT;
+ }
+ 
++>>>>>>> 424a7cd07840 (udpv6: fix possible user after free in error handler)
  /* Try to match ICMP errors to UDP tunnels by looking up a socket without
   * reversing source and destination port: this will match tunnels that force the
   * same destination port on both endpoints (e.g. VXLAN, GENEVE). Note that
* Unmerged path net/ipv6/udp.c
