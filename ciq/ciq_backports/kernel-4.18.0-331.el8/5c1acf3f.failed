cifs: fix regression when mounting shares with prefix paths

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Paulo Alcantara <pc@cjr.nz>
commit 5c1acf3fe05ce443edba5e2110c9e581765f66a8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/5c1acf3f.failed

The commit 315db9a05b7a ("cifs: fix leak in cifs_smb3_do_mount() ctx")
revealed an existing bug when mounting shares that contain a prefix
path or DFS links.

cifs_setup_volume_info() requires the @devname to contain the full
path (UNC + prefix) to update the fs context with the new UNC and
prepath values, however we were passing only the UNC
path (old_ctx->UNC) in @device thus discarding any prefix paths.

Instead of concatenating both old_ctx->{UNC,prepath} and pass it in
@devname, just keep the dup'ed values of UNC and prepath in
cifs_sb->ctx after calling smb3_fs_context_dup(), and fix
smb3_parse_devname() to correctly parse and not leak the new UNC and
prefix paths.

	Cc: <stable@vger.kernel.org> # v5.11+
Fixes: 315db9a05b7a ("cifs: fix leak in cifs_smb3_do_mount() ctx")
	Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Acked-by: David Disseldorp <ddiss@suse.de>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 5c1acf3fe05ce443edba5e2110c9e581765f66a8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifsfs.c
#	fs/cifs/connect.c
diff --cc fs/cifs/cifsfs.c
index e1f4772cf344,d7ea9c5fe0f8..000000000000
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@@ -819,22 -849,33 +819,38 @@@ cifs_smb3_do_mount(struct file_system_t
  	cifs_sb = kzalloc(sizeof(struct cifs_sb_info), GFP_KERNEL);
  	if (cifs_sb == NULL) {
  		root = ERR_PTR(-ENOMEM);
 -		goto out;
 +		goto out_nls;
  	}
  
 -	cifs_sb->ctx = kzalloc(sizeof(struct smb3_fs_context), GFP_KERNEL);
 -	if (!cifs_sb->ctx) {
 +	cifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
 +	if (cifs_sb->mountdata == NULL) {
  		root = ERR_PTR(-ENOMEM);
 -		goto out;
 +		goto out_free;
  	}
 -	rc = smb3_fs_context_dup(cifs_sb->ctx, old_ctx);
 +
 +	rc = cifs_setup_cifs_sb(ctx, cifs_sb);
  	if (rc) {
  		root = ERR_PTR(rc);
 -		goto out;
 +		goto out_free;
  	}
  
++<<<<<<< HEAD
 +	rc = cifs_mount(cifs_sb, ctx);
++=======
+ 	rc = cifs_setup_volume_info(cifs_sb->ctx, NULL, NULL);
+ 	if (rc) {
+ 		root = ERR_PTR(rc);
+ 		goto out;
+ 	}
+ 
+ 	rc = cifs_setup_cifs_sb(cifs_sb);
+ 	if (rc) {
+ 		root = ERR_PTR(rc);
+ 		goto out;
+ 	}
+ 
+ 	rc = cifs_mount(cifs_sb, cifs_sb->ctx);
++>>>>>>> 5c1acf3fe05c (cifs: fix regression when mounting shares with prefix paths)
  	if (rc) {
  		if (!(flags & SB_SILENT))
  			cifs_dbg(VFS, "cifs_mount failed w/return code = %d\n",
diff --cc fs/cifs/connect.c
index 7193908acec7,495c395f9def..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -4265,14 -3143,39 +4265,42 @@@ static int do_dfs_failover(const char *
  }
  #endif
  
 -/* TODO: all callers to this are broken. We are not parsing mount_options here
 - * we should pass a clone of the original context?
 - */
  int
 -cifs_setup_volume_info(struct smb3_fs_context *ctx, const char *mntopts, const char *devname)
 +cifs_setup_volume_info(struct smb3_fs_context *ctx, char *mount_data,
 +			const char *devname, bool is_smb3)
  {
- 	int rc = 0;
+ 	int rc;
  
++<<<<<<< HEAD
 +	if (cifs_parse_mount_options(mount_data, devname, ctx, is_smb3))
 +		return -EINVAL;
++=======
+ 	if (devname) {
+ 		cifs_dbg(FYI, "%s: devname=%s\n", __func__, devname);
+ 		rc = smb3_parse_devname(devname, ctx);
+ 		if (rc) {
+ 			cifs_dbg(VFS, "%s: failed to parse %s: %d\n", __func__, devname, rc);
+ 			return rc;
+ 		}
+ 	}
+ 
+ 	if (mntopts) {
+ 		char *ip;
+ 
+ 		rc = smb3_parse_opt(mntopts, "ip", &ip);
+ 		if (rc) {
+ 			cifs_dbg(VFS, "%s: failed to parse ip options: %d\n", __func__, rc);
+ 			return rc;
+ 		}
+ 
+ 		rc = cifs_convert_address((struct sockaddr *)&ctx->dstaddr, ip, strlen(ip));
+ 		kfree(ip);
+ 		if (!rc) {
+ 			cifs_dbg(VFS, "%s: failed to convert ip address\n", __func__);
+ 			return -EINVAL;
+ 		}
+ 	}
++>>>>>>> 5c1acf3fe05c (cifs: fix regression when mounting shares with prefix paths)
  
  	if (ctx->nullauth) {
  		cifs_dbg(FYI, "Anonymous login\n");
@@@ -4288,39 -3191,7 +4316,43 @@@
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	/* this is needed for ASCII cp to Unicode converts */
 +	if (ctx->iocharset == NULL) {
 +		/* load_nls_default cannot return null */
 +		ctx->local_nls = load_nls_default();
 +	} else {
 +		ctx->local_nls = load_nls(ctx->iocharset);
 +		if (ctx->local_nls == NULL) {
 +			cifs_dbg(VFS, "CIFS mount error: iocharset %s not found\n",
 +				 ctx->iocharset);
 +			return -ELIBACC;
 +		}
 +	}
 +
 +	return rc;
++=======
+ 	return 0;
++>>>>>>> 5c1acf3fe05c (cifs: fix regression when mounting shares with prefix paths)
 +}
 +
 +struct smb3_fs_context *
 +cifs_get_volume_info(char *mount_data, const char *devname, bool is_smb3)
 +{
 +	int rc;
 +	struct smb3_fs_context *ctx;
 +
 +	ctx = kmalloc(sizeof(*ctx), GFP_KERNEL);
 +	if (!ctx)
 +		return ERR_PTR(-ENOMEM);
 +
 +	rc = cifs_setup_volume_info(ctx, mount_data, devname, is_smb3);
 +	if (rc) {
 +		cifs_cleanup_volume_info(ctx);
 +		ctx = ERR_PTR(rc);
 +	}
 +
 +	return ctx;
  }
  
  static int
* Unmerged path fs/cifs/cifsfs.c
* Unmerged path fs/cifs/connect.c
diff --git a/fs/cifs/fs_context.c b/fs/cifs/fs_context.c
index d19634975a18..32b3469ce2c4 100644
--- a/fs/cifs/fs_context.c
+++ b/fs/cifs/fs_context.c
@@ -294,6 +294,7 @@ smb3_parse_devname(const char *devname, struct smb3_fs_context *ctx)
 
 	/* move "pos" up to delimiter or NULL */
 	pos += len;
+	kfree(ctx->UNC);
 	ctx->UNC = kstrndup(devname, pos - devname, GFP_KERNEL);
 	if (!ctx->UNC)
 		return -ENOMEM;
@@ -304,6 +305,9 @@ smb3_parse_devname(const char *devname, struct smb3_fs_context *ctx)
 	if (*pos == '/' || *pos == '\\')
 		pos++;
 
+	kfree(ctx->prepath);
+	ctx->prepath = NULL;
+
 	/* If pos is NULL then no prepath */
 	if (!*pos)
 		return 0;
