gfs2: Pass resource group to rgblk_free

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 0ddeded4ae768882e5c3a5558f77f27e4e445a6a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/0ddeded4.failed

Function rgblk_free can only deal with one resource group at a time, so
pass that resource group is as a parameter.  Several of the callers
already have the resource group at hand, so we only need additional
lookup code in a few places.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
	Signed-off-by: Bob Peterson <rpeterso@redhat.com>
	Reviewed-by: Steven Whitehouse <swhiteho@redhat.com>
(cherry picked from commit 0ddeded4ae768882e5c3a5558f77f27e4e445a6a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/rgrp.c
#	fs/gfs2/rgrp.h
diff --cc fs/gfs2/rgrp.c
index 34201b1db602,ffe3032b1043..000000000000
--- a/fs/gfs2/rgrp.c
+++ b/fs/gfs2/rgrp.c
@@@ -2204,15 -2227,9 +2203,19 @@@ static void rgblk_free(struct gfs2_sbd 
  	struct gfs2_rbm rbm;
  	struct gfs2_bitmap *bi, *bi_prev = NULL;
  
++<<<<<<< HEAD
 +	rbm.rgd = gfs2_blk2rgrpd(sdp, bstart, 1);
 +	if (!rbm.rgd) {
 +		gfs2_lm(sdp, "block = %llu\n", (unsigned long long)bstart);
 +		gfs2_consist(sdp);
 +		return NULL;
 +	}
 +
++=======
+ 	rbm.rgd = rgd;
++>>>>>>> 0ddeded4ae76 (gfs2: Pass resource group to rgblk_free)
  	if (WARN_ON_ONCE(gfs2_rbm_from_block(&rbm, bstart)))
- 		return NULL;
+ 		return;
  	while (blen--) {
  		bi = rbm_bi(&rbm);
  		if (bi != bi_prev) {
diff --cc fs/gfs2/rgrp.h
index 71df56692f82,b596c3d17988..000000000000
--- a/fs/gfs2/rgrp.h
+++ b/fs/gfs2/rgrp.h
@@@ -47,10 -48,13 +47,18 @@@ extern void gfs2_inplace_release(struc
  extern int gfs2_alloc_blocks(struct gfs2_inode *ip, u64 *bn, unsigned int *n,
  			     bool dinode, u64 *generation);
  
 -extern int gfs2_rsqa_alloc(struct gfs2_inode *ip);
  extern void gfs2_rs_deltree(struct gfs2_blkreserv *rs);
++<<<<<<< HEAD
 +extern void gfs2_rs_delete(struct gfs2_inode *ip, atomic_t *wcount);
 +extern void __gfs2_free_blocks(struct gfs2_inode *ip, u64 bstart, u32 blen, int meta);
 +extern void gfs2_free_meta(struct gfs2_inode *ip, u64 bstart, u32 blen);
++=======
+ extern void gfs2_rsqa_delete(struct gfs2_inode *ip, atomic_t *wcount);
+ extern void __gfs2_free_blocks(struct gfs2_inode *ip, struct gfs2_rgrpd *rgd,
+ 			       u64 bstart, u32 blen, int meta);
+ extern void gfs2_free_meta(struct gfs2_inode *ip, struct gfs2_rgrpd *rgd,
+ 			   u64 bstart, u32 blen);
++>>>>>>> 0ddeded4ae76 (gfs2: Pass resource group to rgblk_free)
  extern void gfs2_free_di(struct gfs2_rgrpd *rgd, struct gfs2_inode *ip);
  extern void gfs2_unlink_di(struct inode *inode);
  extern int gfs2_check_blk_type(struct gfs2_sbd *sdp, u64 no_addr,
diff --git a/fs/gfs2/bmap.c b/fs/gfs2/bmap.c
index ddcadb251cde..65fc2cf0c54b 100644
--- a/fs/gfs2/bmap.c
+++ b/fs/gfs2/bmap.c
@@ -1651,7 +1651,7 @@ static int sweep_bh_for_rgrps(struct gfs2_inode *ip, struct gfs2_holder *rd_gh,
 			continue;
 		}
 		if (bstart) {
-			__gfs2_free_blocks(ip, bstart, (u32)blen, meta);
+			__gfs2_free_blocks(ip, rgd, bstart, (u32)blen, meta);
 			(*btotal) += blen;
 			gfs2_add_inode_blocks(&ip->i_inode, -blen);
 		}
@@ -1659,7 +1659,7 @@ static int sweep_bh_for_rgrps(struct gfs2_inode *ip, struct gfs2_holder *rd_gh,
 		blen = 1;
 	}
 	if (bstart) {
-		__gfs2_free_blocks(ip, bstart, (u32)blen, meta);
+		__gfs2_free_blocks(ip, rgd, bstart, (u32)blen, meta);
 		(*btotal) += blen;
 		gfs2_add_inode_blocks(&ip->i_inode, -blen);
 	}
diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c
index 78b3e76dad22..af396848b3b0 100644
--- a/fs/gfs2/dir.c
+++ b/fs/gfs2/dir.c
@@ -2042,6 +2042,8 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 	bh = leaf_bh;
 
 	for (blk = leaf_no; blk; blk = nblk) {
+		struct gfs2_rgrpd *rgd;
+
 		if (blk != leaf_no) {
 			error = get_leaf(dip, blk, &bh);
 			if (error)
@@ -2052,7 +2054,8 @@ static int leaf_dealloc(struct gfs2_inode *dip, u32 index, u32 len,
 		if (blk != leaf_no)
 			brelse(bh);
 
-		gfs2_free_meta(dip, blk, 1);
+		rgd = gfs2_blk2rgrpd(sdp, blk, true);
+		gfs2_free_meta(dip, rgd, blk, 1);
 		gfs2_add_inode_blocks(&dip->i_inode, -1);
 	}
 
* Unmerged path fs/gfs2/rgrp.c
* Unmerged path fs/gfs2/rgrp.h
diff --git a/fs/gfs2/xattr.c b/fs/gfs2/xattr.c
index 4b448d4cb7be..58884256aeda 100644
--- a/fs/gfs2/xattr.c
+++ b/fs/gfs2/xattr.c
@@ -283,7 +283,7 @@ static int ea_dealloc_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,
 			blen++;
 		else {
 			if (bstart)
-				gfs2_free_meta(ip, bstart, blen);
+				gfs2_free_meta(ip, rgd, bstart, blen);
 			bstart = bn;
 			blen = 1;
 		}
@@ -292,7 +292,7 @@ static int ea_dealloc_unstuffed(struct gfs2_inode *ip, struct buffer_head *bh,
 		gfs2_add_inode_blocks(&ip->i_inode, -1);
 	}
 	if (bstart)
-		gfs2_free_meta(ip, bstart, blen);
+		gfs2_free_meta(ip, rgd, bstart, blen);
 
 	if (prev && !leave) {
 		u32 len;
@@ -1254,6 +1254,7 @@ static int ea_dealloc_indirect(struct gfs2_inode *ip)
 {
 	struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);
 	struct gfs2_rgrp_list rlist;
+	struct gfs2_rgrpd *rgd;
 	struct buffer_head *indbh, *dibh;
 	__be64 *eablk, *end;
 	unsigned int rg_blocks = 0;
@@ -1306,8 +1307,7 @@ static int ea_dealloc_indirect(struct gfs2_inode *ip)
 	gfs2_rlist_alloc(&rlist);
 
 	for (x = 0; x < rlist.rl_rgrps; x++) {
-		struct gfs2_rgrpd *rgd = gfs2_glock2rgrp(rlist.rl_ghs[x].gh_gl);
-
+		rgd = gfs2_glock2rgrp(rlist.rl_ghs[x].gh_gl);
 		rg_blocks += rgd->rd_length;
 	}
 
@@ -1324,6 +1324,7 @@ static int ea_dealloc_indirect(struct gfs2_inode *ip)
 
 	eablk = (__be64 *)(indbh->b_data + sizeof(struct gfs2_meta_header));
 	bstart = 0;
+	rgd = NULL;
 	blen = 0;
 
 	for (; eablk < end; eablk++) {
@@ -1337,8 +1338,9 @@ static int ea_dealloc_indirect(struct gfs2_inode *ip)
 			blen++;
 		else {
 			if (bstart)
-				gfs2_free_meta(ip, bstart, blen);
+				gfs2_free_meta(ip, rgd, bstart, blen);
 			bstart = bn;
+			rgd = gfs2_blk2rgrpd(sdp, bstart, true);
 			blen = 1;
 		}
 
@@ -1346,7 +1348,7 @@ static int ea_dealloc_indirect(struct gfs2_inode *ip)
 		gfs2_add_inode_blocks(&ip->i_inode, -1);
 	}
 	if (bstart)
-		gfs2_free_meta(ip, bstart, blen);
+		gfs2_free_meta(ip, rgd, bstart, blen);
 
 	ip->i_diskflags &= ~GFS2_DIF_EA_INDIRECT;
 
@@ -1395,7 +1397,7 @@ static int ea_dealloc_block(struct gfs2_inode *ip)
 	if (error)
 		goto out_gunlock;
 
-	gfs2_free_meta(ip, ip->i_eattr, 1);
+	gfs2_free_meta(ip, rgd, ip->i_eattr, 1);
 
 	ip->i_eattr = 0;
 	gfs2_add_inode_blocks(&ip->i_inode, -1);
