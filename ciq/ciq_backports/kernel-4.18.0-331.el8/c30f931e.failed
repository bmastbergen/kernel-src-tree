powerpc/numa: remove ability to enable topology updates

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Nathan Lynch <nathanl@linux.ibm.com>
commit c30f931e891eb0a32885ecd79984e1e7366fceda
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/c30f931e.failed

Remove the /proc/powerpc/topology_updates interface and the
topology_updates=on/off command line argument. The internal
topology_updates_enabled flag remains for now, but always false.

	Signed-off-by: Nathan Lynch <nathanl@linux.ibm.com>
	Reviewed-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200612051238.1007764-4-nathanl@linux.ibm.com
(cherry picked from commit c30f931e891eb0a32885ecd79984e1e7366fceda)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/mm/numa.c
diff --cc arch/powerpc/mm/numa.c
index d9a705182ada,34d95de77bdd..000000000000
--- a/arch/powerpc/mm/numa.c
+++ b/arch/powerpc/mm/numa.c
@@@ -1671,77 -1612,6 +1651,80 @@@ int prrn_is_enabled(void
  	return prrn_enabled;
  }
  
++<<<<<<< HEAD
 +static int topology_read(struct seq_file *file, void *v)
 +{
 +	if (vphn_enabled || prrn_enabled)
 +		seq_puts(file, "on\n");
 +	else
 +		seq_puts(file, "off\n");
 +
 +	return 0;
 +}
 +
 +static int topology_open(struct inode *inode, struct file *file)
 +{
 +	return single_open(file, topology_read, NULL);
 +}
 +
 +static ssize_t topology_write(struct file *file, const char __user *buf,
 +			      size_t count, loff_t *off)
 +{
 +	char kbuf[4]; /* "on" or "off" plus null. */
 +	int read_len;
 +
 +	read_len = count < 3 ? count : 3;
 +	if (copy_from_user(kbuf, buf, read_len))
 +		return -EINVAL;
 +
 +	kbuf[read_len] = '\0';
 +
 +	if (!strncmp(kbuf, "on", 2)) {
 +		topology_updates_enabled = true;
 +		start_topology_update();
 +	} else if (!strncmp(kbuf, "off", 3)) {
 +		stop_topology_update();
 +		topology_updates_enabled = false;
 +	} else
 +		return -EINVAL;
 +
 +	return count;
 +}
 +
 +static const struct file_operations topology_ops = {
 +	.read = seq_read,
 +	.write = topology_write,
 +	.open = topology_open,
 +	.release = single_release
 +};
 +
 +int cpu_to_coregroup_id(int cpu)
 +{
 +	__be32 associativity[VPHN_ASSOC_BUFSIZE] = {0};
 +	int index;
 +
 +	if (cpu < 0 || cpu > nr_cpu_ids)
 +		return -1;
 +
 +	if (!coregroup_enabled)
 +		goto out;
 +
 +	if (!firmware_has_feature(FW_FEATURE_VPHN))
 +		goto out;
 +
 +	if (vphn_get_associativity(cpu, associativity))
 +		goto out;
 +
 +	index = of_read_number(associativity, 1);
 +	if (index > min_common_depth + 1)
 +		return of_read_number(&associativity[index - 1], 1);
 +
 +out:
 +	return cpu_to_core_id(cpu);
 +}
 +
++=======
++>>>>>>> c30f931e891e (powerpc/numa: remove ability to enable topology updates)
  static int topology_update_init(void)
  {
  	start_topology_update();
@@@ -1749,9 -1619,6 +1732,12 @@@
  	if (vphn_enabled)
  		topology_schedule_update();
  
++<<<<<<< HEAD
 +	if (!proc_create("powerpc/topology_updates", 0644, NULL, &topology_ops))
 +		return -ENOMEM;
 +
++=======
++>>>>>>> c30f931e891e (powerpc/numa: remove ability to enable topology updates)
  	topology_inited = 1;
  	return 0;
  }
* Unmerged path arch/powerpc/mm/numa.c
