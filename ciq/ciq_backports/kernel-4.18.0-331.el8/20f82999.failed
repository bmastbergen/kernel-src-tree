gfs2: Rework read and page fault locking

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 20f829999c38b18e3d17f9e40dea3a28f721fac4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/20f82999.failed

So far, gfs2 has taken the inode glocks inside the ->readpage and
->readahead address space operations.  Since commit d4388340ae0b ("fs:
convert mpage_readpages to mpage_readahead"), gfs2_readahead is passed
the pages to read ahead locked.  With that, the current holder of the
inode glock may be trying to lock one of those pages while
gfs2_readahead is trying to take the inode glock, resulting in a
deadlock.

Fix that by moving the lock taking to the higher-level ->read_iter file
and ->fault vm operations.  This also gets rid of an ugly lock inversion
workaround in gfs2_readpage.

The cache consistency model of filesystems like gfs2 is such that if
data is found in the page cache, the data is up to date and can be used
without taking any filesystem locks.  If a page is not cached,
filesystem locks must be taken before populating the page cache.

To avoid taking the inode glock when the data is already cached,
gfs2_file_read_iter first tries to read the data with the IOCB_NOIO flag
set.  If that fails, the inode glock is taken and the operation is
retried with the IOCB_NOIO flag cleared.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 20f829999c38b18e3d17f9e40dea3a28f721fac4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/aops.c
diff --cc fs/gfs2/aops.c
index 1ae3611c9c3d,68cd700a2719..000000000000
--- a/fs/gfs2/aops.c
+++ b/fs/gfs2/aops.c
@@@ -624,27 -558,13 +588,33 @@@ int gfs2_internal_read(struct gfs2_inod
   * 4. gfs2_block_map() is relied upon to set BH_Boundary in the right places.
   */
  
 -static void gfs2_readahead(struct readahead_control *rac)
 +static int gfs2_readpages(struct file *file, struct address_space *mapping,
 +			  struct list_head *pages, unsigned nr_pages)
  {
 -	struct inode *inode = rac->mapping->host;
 +	struct inode *inode = mapping->host;
  	struct gfs2_inode *ip = GFS2_I(inode);
++<<<<<<< HEAD
 +	struct gfs2_sbd *sdp = GFS2_SB(inode);
 +	struct gfs2_holder gh;
 +	int ret;
 +
 +	gfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);
 +	ret = gfs2_glock_nq(&gh);
 +	if (unlikely(ret))
 +		goto out_uninit;
 +	if (!gfs2_is_stuffed(ip))
 +		ret = mpage_readpages(mapping, pages, nr_pages, gfs2_block_map);
 +	gfs2_glock_dq(&gh);
 +out_uninit:
 +	gfs2_holder_uninit(&gh);
 +	if (unlikely(gfs2_withdrawn(sdp)))
 +		ret = -EIO;
 +	return ret;
++=======
+ 
+ 	if (!gfs2_is_stuffed(ip))
+ 		mpage_readahead(rac, gfs2_block_map);
++>>>>>>> 20f829999c38 (gfs2: Rework read and page fault locking)
  }
  
  /**
* Unmerged path fs/gfs2/aops.c
diff --git a/fs/gfs2/file.c b/fs/gfs2/file.c
index ac633238b304..c08df3ad00f7 100644
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@ -509,8 +509,29 @@ static vm_fault_t gfs2_page_mkwrite(struct vm_fault *vmf)
 	return block_page_mkwrite_return(ret);
 }
 
+static vm_fault_t gfs2_fault(struct vm_fault *vmf)
+{
+	struct inode *inode = file_inode(vmf->vma->vm_file);
+	struct gfs2_inode *ip = GFS2_I(inode);
+	struct gfs2_holder gh;
+	vm_fault_t ret;
+	int err;
+
+	gfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);
+	err = gfs2_glock_nq(&gh);
+	if (err) {
+		ret = block_page_mkwrite_return(err);
+		goto out_uninit;
+	}
+	ret = filemap_fault(vmf);
+	gfs2_glock_dq(&gh);
+out_uninit:
+	gfs2_holder_uninit(&gh);
+	return ret;
+}
+
 static const struct vm_operations_struct gfs2_vm_ops = {
-	.fault = filemap_fault,
+	.fault = gfs2_fault,
 	.map_pages = filemap_map_pages,
 	.page_mkwrite = gfs2_page_mkwrite,
 };
@@ -776,6 +797,9 @@ static ssize_t gfs2_file_direct_write(struct kiocb *iocb, struct iov_iter *from)
 
 static ssize_t gfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *to)
 {
+	struct gfs2_inode *ip;
+	struct gfs2_holder gh;
+	size_t written = 0;
 	ssize_t ret;
 
 	if (iocb->ki_flags & IOCB_DIRECT) {
@@ -784,7 +808,31 @@ static ssize_t gfs2_file_read_iter(struct kiocb *iocb, struct iov_iter *to)
 			return ret;
 		iocb->ki_flags &= ~IOCB_DIRECT;
 	}
-	return generic_file_read_iter(iocb, to);
+	iocb->ki_flags |= IOCB_NOIO;
+	ret = generic_file_read_iter(iocb, to);
+	iocb->ki_flags &= ~IOCB_NOIO;
+	if (ret >= 0) {
+		if (!iov_iter_count(to))
+			return ret;
+		written = ret;
+	} else {
+		if (ret != -EAGAIN)
+			return ret;
+		if (iocb->ki_flags & IOCB_NOWAIT)
+			return ret;
+	}
+	ip = GFS2_I(iocb->ki_filp->f_mapping->host);
+	gfs2_holder_init(ip->i_gl, LM_ST_SHARED, 0, &gh);
+	ret = gfs2_glock_nq(&gh);
+	if (ret)
+		goto out_uninit;
+	ret = generic_file_read_iter(iocb, to);
+	if (ret > 0)
+		written += ret;
+	gfs2_glock_dq(&gh);
+out_uninit:
+	gfs2_holder_uninit(&gh);
+	return written ? written : ret;
 }
 
 /**
