gfs2: Unstuff before locking page in gfs2_page_mkwrite

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Andreas Gruenbacher <agruenba@redhat.com>
commit 64090cbe4bff240e9a5266e956fcaf449ea6b327
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/64090cbe.failed

In gfs2_page_mkwrite, unstuff inodes before locking the page.  That
way, we won't have to pass in the locked page to gfs2_unstuff_inode,
and gfs2_unstuff_inode can look up and lock the page itself.

	Signed-off-by: Andreas Gruenbacher <agruenba@redhat.com>
(cherry picked from commit 64090cbe4bff240e9a5266e956fcaf449ea6b327)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/gfs2/file.c
diff --cc fs/gfs2/file.c
index e69af279b7fd,4a14616b2c0a..000000000000
--- a/fs/gfs2/file.c
+++ b/fs/gfs2/file.c
@@@ -463,35 -504,38 +463,59 @@@ static vm_fault_t gfs2_page_mkwrite(str
  		rblocks += RES_STATFS + RES_QUOTA;
  		rblocks += gfs2_rg_blocks(ip, data_blocks + ind_blocks);
  	}
 -	err = gfs2_trans_begin(sdp, rblocks, 0);
 -	if (err) {
 -		ret = block_page_mkwrite_return(err);
 +	ret = gfs2_trans_begin(sdp, rblocks, 0);
 +	if (ret)
  		goto out_trans_fail;
 -	}
  
+ 	/* Unstuff, if required, and allocate backing blocks for page */
+ 	if (gfs2_is_stuffed(ip)) {
+ 		err = gfs2_unstuff_dinode(ip, NULL);
+ 		if (err) {
+ 			ret = block_page_mkwrite_return(err);
+ 			goto out_trans_end;
+ 		}
+ 	}
+ 
  	lock_page(page);
 +	ret = -EINVAL;
 +	size = i_size_read(inode);
 +	last_index = (size - 1) >> PAGE_SHIFT;
 +	/* Check page index against inode size */
 +	if (size == 0 || (page->index > last_index))
 +		goto out_trans_end;
 +
 +	ret = -EAGAIN;
  	/* If truncated, we must retry the operation, we may have raced
  	 * with the glock demotion code.
  	 */
++<<<<<<< HEAD
 +	if (!PageUptodate(page) || page->mapping != inode->i_mapping)
 +		goto out_trans_end;
 +
 +	/* Unstuff, if required, and allocate backing blocks for page */
 +	ret = 0;
 +	if (gfs2_is_stuffed(ip))
 +		ret = gfs2_unstuff_dinode(ip, page);
 +	if (ret == 0)
 +		ret = gfs2_allocate_page_backing(page, PAGE_SIZE);
 +
 +out_trans_end:
 +	if (ret)
++=======
+ 	if (!PageUptodate(page) || page->mapping != inode->i_mapping) {
+ 		ret = VM_FAULT_NOPAGE;
+ 		goto out_page_locked;
+ 	}
+ 
+ 	err = gfs2_allocate_page_backing(page, length);
+ 	if (err)
+ 		ret = block_page_mkwrite_return(err);
+ 
+ out_page_locked:
+ 	if (ret != VM_FAULT_LOCKED)
++>>>>>>> 64090cbe4bff (gfs2: Unstuff before locking page in gfs2_page_mkwrite)
  		unlock_page(page);
+ out_trans_end:
  	gfs2_trans_end(sdp);
  out_trans_fail:
  	gfs2_inplace_release(ip);
* Unmerged path fs/gfs2/file.c
