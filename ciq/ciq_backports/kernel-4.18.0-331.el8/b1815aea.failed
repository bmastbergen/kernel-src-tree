powerpc/numa: remove timed_topology_update()

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Nathan Lynch <nathanl@linux.ibm.com>
commit b1815aeac7fde2dc3412daf2efaededd21cd58e0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/b1815aea.failed

timed_topology_update is a no-op now, so remove it and all call sites.

	Signed-off-by: Nathan Lynch <nathanl@linux.ibm.com>
	Reviewed-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200612051238.1007764-11-nathanl@linux.ibm.com
(cherry picked from commit b1815aeac7fde2dc3412daf2efaededd21cd58e0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/topology.h
#	arch/powerpc/mm/numa.c
diff --cc arch/powerpc/include/asm/topology.h
index 590f3fd3ef02,379e2cc3789f..000000000000
--- a/arch/powerpc/include/asm/topology.h
+++ b/arch/powerpc/include/asm/topology.h
@@@ -97,8 -97,6 +97,11 @@@ extern int start_topology_update(void)
  extern int stop_topology_update(void);
  extern int prrn_is_enabled(void);
  extern int find_and_online_cpu_nid(int cpu);
++<<<<<<< HEAD
 +extern int timed_topology_update(int nsecs);
 +extern int cpu_to_coregroup_id(int cpu);
++=======
++>>>>>>> b1815aeac7fd (powerpc/numa: remove timed_topology_update())
  #else
  static inline int start_topology_update(void)
  {
@@@ -116,20 -114,7 +119,16 @@@ static inline int find_and_online_cpu_n
  {
  	return 0;
  }
- static inline int timed_topology_update(int nsecs)
- {
- 	return 0;
- }
  
 +static inline int cpu_to_coregroup_id(int cpu)
 +{
 +#ifdef CONFIG_SMP
 +	return cpu_to_core_id(cpu);
 +#else
 +	return 0;
 +#endif
 +}
 +
  #endif /* CONFIG_NUMA && CONFIG_PPC_SPLPAR */
  
  #include <asm-generic/topology.h>
diff --cc arch/powerpc/mm/numa.c
index ea9e6ad56631,6c579ac3e679..000000000000
--- a/arch/powerpc/mm/numa.c
+++ b/arch/powerpc/mm/numa.c
@@@ -1208,80 -1125,6 +1208,83 @@@ static int topology_timer_secs = 1
  static int topology_inited;
  
  /*
++<<<<<<< HEAD
 + * Change polling interval for associativity changes.
 + */
 +int timed_topology_update(int nsecs)
 +{
 +	if (vphn_enabled) {
 +		if (nsecs > 0)
 +			topology_timer_secs = nsecs;
 +		else
 +			topology_timer_secs = TOPOLOGY_DEF_TIMER_SECS;
 +
 +		reset_topology_timer();
 +	}
 +
 +	return 0;
 +}
 +
 +/*
 + * Store the current values of the associativity change counters in the
 + * hypervisor.
 + */
 +static void setup_cpu_associativity_change_counters(void)
 +{
 +	int cpu;
 +
 +	/* The VPHN feature supports a maximum of 8 reference points */
 +	BUILD_BUG_ON(MAX_DISTANCE_REF_POINTS > 8);
 +
 +	for_each_possible_cpu(cpu) {
 +		int i;
 +		u8 *counts = vphn_cpu_change_counts[cpu];
 +		volatile u8 *hypervisor_counts = lppaca_of(cpu).vphn_assoc_counts;
 +
 +		for (i = 0; i < distance_ref_points_depth; i++)
 +			counts[i] = hypervisor_counts[i];
 +	}
 +}
 +
 +/*
 + * The hypervisor maintains a set of 8 associativity change counters in
 + * the VPA of each cpu that correspond to the associativity levels in the
 + * ibm,associativity-reference-points property. When an associativity
 + * level changes, the corresponding counter is incremented.
 + *
 + * Set a bit in cpu_associativity_changes_mask for each cpu whose home
 + * node associativity levels have changed.
 + *
 + * Returns the number of cpus with unhandled associativity changes.
 + */
 +static int update_cpu_associativity_changes_mask(void)
 +{
 +	int cpu;
 +	cpumask_t *changes = &cpu_associativity_changes_mask;
 +
 +	for_each_possible_cpu(cpu) {
 +		int i, changed = 0;
 +		u8 *counts = vphn_cpu_change_counts[cpu];
 +		volatile u8 *hypervisor_counts = lppaca_of(cpu).vphn_assoc_counts;
 +
 +		for (i = 0; i < distance_ref_points_depth; i++) {
 +			if (hypervisor_counts[i] != counts[i]) {
 +				counts[i] = hypervisor_counts[i];
 +				changed = 1;
 +			}
 +		}
 +		if (changed) {
 +			cpumask_or(changes, changes, cpu_sibling_mask(cpu));
 +			cpu = cpu_last_thread_sibling(cpu);
 +		}
 +	}
 +
 +	return cpumask_weight(changes);
 +}
 +
 +/*
++=======
++>>>>>>> b1815aeac7fd (powerpc/numa: remove timed_topology_update())
   * Retrieve the new associativity information for a virtual processor's
   * home node.
   */
* Unmerged path arch/powerpc/include/asm/topology.h
* Unmerged path arch/powerpc/mm/numa.c
diff --git a/arch/powerpc/platforms/pseries/hotplug-cpu.c b/arch/powerpc/platforms/pseries/hotplug-cpu.c
index eae061a904f7..a1a54c5b2592 100644
--- a/arch/powerpc/platforms/pseries/hotplug-cpu.c
+++ b/arch/powerpc/platforms/pseries/hotplug-cpu.c
@@ -276,7 +276,6 @@ static int dlpar_offline_cpu(struct device_node *dn)
 				break;
 
 			cpu_maps_update_done();
-			timed_topology_update(1);
 			rc = device_offline(get_cpu_device(cpu));
 			if (rc)
 				goto out;
@@ -315,7 +314,6 @@ static int dlpar_online_cpu(struct device_node *dn)
 			if (get_hard_smp_processor_id(cpu) != thread)
 				continue;
 			cpu_maps_update_done();
-			timed_topology_update(1);
 			find_and_online_cpu_nid(cpu);
 			rc = device_online(get_cpu_device(cpu));
 			if (rc) {
