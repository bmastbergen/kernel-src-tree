netfilter: conntrack: Introduce udp offload timeout configuration

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Oz Shlomo <ozsh@nvidia.com>
commit 975c57504da1114551fdb3a91ed61dda7739613e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/975c5750.failed

UDP connections may be offloaded from nf conntrack to nf flow table.
Offloaded connections are aged after 30 seconds of inactivity.
Once aged, ownership is returned to conntrack with a hard coded pickup
time of 30 seconds, after which the connection may be deleted.
eted. The current aging intervals may be too aggressive for some users.

Provide users with the ability to control the nf flow table offload
aging and pickup time intervals via sysctl parameter as a pre-step for
configuring the nf flow table GC timeout intervals.

	Signed-off-by: Oz Shlomo <ozsh@nvidia.com>
	Reviewed-by: Paul Blakey <paulb@nvidia.com>
	Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
(cherry picked from commit 975c57504da1114551fdb3a91ed61dda7739613e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/netfilter/nf_conntrack_proto_udp.c
#	net/netfilter/nf_conntrack_standalone.c
diff --cc net/netfilter/nf_conntrack_proto_udp.c
index f1df1d893e1c,68911fcaa0f1..000000000000
--- a/net/netfilter/nf_conntrack_proto_udp.c
+++ b/net/netfilter/nf_conntrack_proto_udp.c
@@@ -266,59 -263,18 +266,69 @@@ udp_timeout_nla_policy[CTA_TIMEOUT_UDP_
  };
  #endif /* CONFIG_NF_CONNTRACK_TIMEOUT */
  
 -void nf_conntrack_udp_init_net(struct net *net)
 +#ifdef CONFIG_SYSCTL
 +static struct ctl_table udp_sysctl_table[] = {
 +	{
 +		.procname	= "nf_conntrack_udp_timeout",
 +		.maxlen		= sizeof(unsigned int),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec_jiffies,
 +	},
 +	{
 +		.procname	= "nf_conntrack_udp_timeout_stream",
 +		.maxlen		= sizeof(unsigned int),
 +		.mode		= 0644,
 +		.proc_handler	= proc_dointvec_jiffies,
 +	},
 +	{ }
 +};
 +#endif /* CONFIG_SYSCTL */
 +
 +static int udp_kmemdup_sysctl_table(struct nf_proto_net *pn,
 +				    struct nf_udp_net *un)
 +{
 +#ifdef CONFIG_SYSCTL
 +	if (pn->ctl_table)
 +		return 0;
 +	pn->ctl_table = kmemdup(udp_sysctl_table,
 +				sizeof(udp_sysctl_table),
 +				GFP_KERNEL);
 +	if (!pn->ctl_table)
 +		return -ENOMEM;
 +	pn->ctl_table[0].data = &un->timeouts[UDP_CT_UNREPLIED];
 +	pn->ctl_table[1].data = &un->timeouts[UDP_CT_REPLIED];
 +#endif
 +	return 0;
 +}
 +
 +static int udp_init_net(struct net *net)
  {
  	struct nf_udp_net *un = nf_udp_pernet(net);
 -	int i;
 +	struct nf_proto_net *pn = &un->pn;
 +
++<<<<<<< HEAD
 +	if (!pn->users) {
 +		int i;
  
 +		for (i = 0; i < UDP_CT_MAX; i++)
 +			un->timeouts[i] = udp_timeouts[i];
 +	}
 +
 +	return udp_kmemdup_sysctl_table(pn, un);
 +}
 +
 +static struct nf_proto_net *udp_get_net_proto(struct net *net)
 +{
 +	return &net->ct.nf_ct_proto.udp.pn;
++=======
+ 	for (i = 0; i < UDP_CT_MAX; i++)
+ 		un->timeouts[i] = udp_timeouts[i];
+ 
+ #if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
+ 	un->offload_timeout = 30 * HZ;
+ 	un->offload_pickup = 30 * HZ;
+ #endif
++>>>>>>> 975c57504da1 (netfilter: conntrack: Introduce udp offload timeout configuration)
  }
  
  const struct nf_conntrack_l4proto nf_conntrack_l4proto_udp =
diff --cc net/netfilter/nf_conntrack_standalone.c
index 7124e0586e2f,f57a951c9b5e..000000000000
--- a/net/netfilter/nf_conntrack_standalone.c
+++ b/net/netfilter/nf_conntrack_standalone.c
@@@ -517,8 -547,80 +517,83 @@@ nf_conntrack_hash_sysctl(struct ctl_tab
  
  static struct ctl_table_header *nf_ct_netfilter_header;
  
++<<<<<<< HEAD
++=======
+ enum nf_ct_sysctl_index {
+ 	NF_SYSCTL_CT_MAX,
+ 	NF_SYSCTL_CT_COUNT,
+ 	NF_SYSCTL_CT_BUCKETS,
+ 	NF_SYSCTL_CT_CHECKSUM,
+ 	NF_SYSCTL_CT_LOG_INVALID,
+ 	NF_SYSCTL_CT_EXPECT_MAX,
+ 	NF_SYSCTL_CT_ACCT,
+ 	NF_SYSCTL_CT_HELPER,
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
+ 	NF_SYSCTL_CT_EVENTS,
+ #endif
+ #ifdef CONFIG_NF_CONNTRACK_TIMESTAMP
+ 	NF_SYSCTL_CT_TIMESTAMP,
+ #endif
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_SENT,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_RECV,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_ESTABLISHED,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_FIN_WAIT,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE_WAIT,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_LAST_ACK,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_TIME_WAIT,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_RETRANS,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_UNACK,
+ #if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_OFFLOAD,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_OFFLOAD_PICKUP,
+ #endif
+ 	NF_SYSCTL_CT_PROTO_TCP_LOOSE,
+ 	NF_SYSCTL_CT_PROTO_TCP_LIBERAL,
+ 	NF_SYSCTL_CT_PROTO_TCP_MAX_RETRANS,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_UDP,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM,
+ #if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_OFFLOAD,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_OFFLOAD_PICKUP,
+ #endif
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6,
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_CLOSED,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_WAIT,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_ECHOED,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_ESTABLISHED,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_SENT,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_RECD,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_ACK_SENT,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_HEARTBEAT_SENT,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_HEARTBEAT_ACKED,
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_REQUEST,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_RESPOND,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_PARTOPEN,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_OPEN,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSEREQ,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSING,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_TIMEWAIT,
+ 	NF_SYSCTL_CT_PROTO_DCCP_LOOSE,
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_GRE
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_GRE,
+ 	NF_SYSCTL_CT_PROTO_TIMEOUT_GRE_STREAM,
+ #endif
+ 
+ 	__NF_SYSCTL_CT_LAST_SYSCTL,
+ };
+ 
+ #define NF_SYSCTL_CT_LAST_SYSCTL (__NF_SYSCTL_CT_LAST_SYSCTL + 1)
+ 
++>>>>>>> 975c57504da1 (netfilter: conntrack: Introduce udp offload timeout configuration)
  static struct ctl_table nf_ct_sysctl_table[] = {
 -	[NF_SYSCTL_CT_MAX] = {
 +	{
  		.procname	= "nf_conntrack_max",
  		.data		= &nf_conntrack_max,
  		.maxlen		= sizeof(int),
@@@ -562,7 -663,308 +637,312 @@@
  		.mode		= 0644,
  		.proc_handler	= proc_dointvec,
  	},
++<<<<<<< HEAD
 +	{ }
++=======
+ 	[NF_SYSCTL_CT_ACCT] = {
+ 		.procname	= "nf_conntrack_acct",
+ 		.data		= &init_net.ct.sysctl_acct,
+ 		.maxlen		= sizeof(u8),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dou8vec_minmax,
+ 		.extra1 	= SYSCTL_ZERO,
+ 		.extra2 	= SYSCTL_ONE,
+ 	},
+ 	[NF_SYSCTL_CT_HELPER] = {
+ 		.procname	= "nf_conntrack_helper",
+ 		.maxlen		= sizeof(u8),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dou8vec_minmax,
+ 		.extra1 	= SYSCTL_ZERO,
+ 		.extra2 	= SYSCTL_ONE,
+ 	},
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
+ 	[NF_SYSCTL_CT_EVENTS] = {
+ 		.procname	= "nf_conntrack_events",
+ 		.data		= &init_net.ct.sysctl_events,
+ 		.maxlen		= sizeof(u8),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dou8vec_minmax,
+ 		.extra1 	= SYSCTL_ZERO,
+ 		.extra2 	= SYSCTL_ONE,
+ 	},
+ #endif
+ #ifdef CONFIG_NF_CONNTRACK_TIMESTAMP
+ 	[NF_SYSCTL_CT_TIMESTAMP] = {
+ 		.procname	= "nf_conntrack_timestamp",
+ 		.data		= &init_net.ct.sysctl_tstamp,
+ 		.maxlen		= sizeof(u8),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dou8vec_minmax,
+ 		.extra1 	= SYSCTL_ZERO,
+ 		.extra2 	= SYSCTL_ONE,
+ 	},
+ #endif
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC] = {
+ 		.procname	= "nf_conntrack_generic_timeout",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_SENT] = {
+ 		.procname	= "nf_conntrack_tcp_timeout_syn_sent",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_SYN_RECV] = {
+ 		.procname	= "nf_conntrack_tcp_timeout_syn_recv",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_ESTABLISHED] = {
+ 		.procname	= "nf_conntrack_tcp_timeout_established",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_FIN_WAIT] = {
+ 		.procname	= "nf_conntrack_tcp_timeout_fin_wait",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE_WAIT] = {
+ 		.procname	= "nf_conntrack_tcp_timeout_close_wait",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_LAST_ACK] = {
+ 		.procname	= "nf_conntrack_tcp_timeout_last_ack",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_TIME_WAIT] = {
+ 		.procname	= "nf_conntrack_tcp_timeout_time_wait",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_CLOSE] = {
+ 		.procname	= "nf_conntrack_tcp_timeout_close",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_RETRANS] = {
+ 		.procname	= "nf_conntrack_tcp_timeout_max_retrans",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_UNACK] = {
+ 		.procname	= "nf_conntrack_tcp_timeout_unacknowledged",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ #if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_OFFLOAD] = {
+ 		.procname	= "nf_flowtable_tcp_timeout",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_TCP_OFFLOAD_PICKUP] = {
+ 		.procname	= "nf_flowtable_tcp_pickup",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ #endif
+ 	[NF_SYSCTL_CT_PROTO_TCP_LOOSE] = {
+ 		.procname	= "nf_conntrack_tcp_loose",
+ 		.maxlen		= sizeof(u8),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dou8vec_minmax,
+ 		.extra1 	= SYSCTL_ZERO,
+ 		.extra2 	= SYSCTL_ONE,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TCP_LIBERAL] = {
+ 		.procname       = "nf_conntrack_tcp_be_liberal",
+ 		.maxlen		= sizeof(u8),
+ 		.mode           = 0644,
+ 		.proc_handler	= proc_dou8vec_minmax,
+ 		.extra1 	= SYSCTL_ZERO,
+ 		.extra2 	= SYSCTL_ONE,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TCP_MAX_RETRANS] = {
+ 		.procname	= "nf_conntrack_tcp_max_retrans",
+ 		.maxlen		= sizeof(u8),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dou8vec_minmax,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP] = {
+ 		.procname	= "nf_conntrack_udp_timeout",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM] = {
+ 		.procname	= "nf_conntrack_udp_timeout_stream",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ #if IS_ENABLED(CONFIG_NFT_FLOW_OFFLOAD)
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_OFFLOAD] = {
+ 		.procname	= "nf_flowtable_udp_timeout",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_OFFLOAD_PICKUP] = {
+ 		.procname	= "nf_flowtable_udp_pickup",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ #endif
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP] = {
+ 		.procname	= "nf_conntrack_icmp_timeout",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6] = {
+ 		.procname	= "nf_conntrack_icmpv6_timeout",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ #ifdef CONFIG_NF_CT_PROTO_SCTP
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_CLOSED] = {
+ 		.procname	= "nf_conntrack_sctp_timeout_closed",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_WAIT] = {
+ 		.procname	= "nf_conntrack_sctp_timeout_cookie_wait",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_COOKIE_ECHOED] = {
+ 		.procname	= "nf_conntrack_sctp_timeout_cookie_echoed",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_ESTABLISHED] = {
+ 		.procname	= "nf_conntrack_sctp_timeout_established",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_SENT] = {
+ 		.procname	= "nf_conntrack_sctp_timeout_shutdown_sent",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_RECD] = {
+ 		.procname	= "nf_conntrack_sctp_timeout_shutdown_recd",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_SHUTDOWN_ACK_SENT] = {
+ 		.procname	= "nf_conntrack_sctp_timeout_shutdown_ack_sent",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_HEARTBEAT_SENT] = {
+ 		.procname	= "nf_conntrack_sctp_timeout_heartbeat_sent",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_SCTP_HEARTBEAT_ACKED] = {
+ 		.procname       = "nf_conntrack_sctp_timeout_heartbeat_acked",
+ 		.maxlen         = sizeof(unsigned int),
+ 		.mode           = 0644,
+ 		.proc_handler   = proc_dointvec_jiffies,
+ 	},
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_DCCP
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_REQUEST] = {
+ 		.procname	= "nf_conntrack_dccp_timeout_request",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_RESPOND] = {
+ 		.procname	= "nf_conntrack_dccp_timeout_respond",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_PARTOPEN] = {
+ 		.procname	= "nf_conntrack_dccp_timeout_partopen",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_OPEN] = {
+ 		.procname	= "nf_conntrack_dccp_timeout_open",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSEREQ] = {
+ 		.procname	= "nf_conntrack_dccp_timeout_closereq",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_CLOSING] = {
+ 		.procname	= "nf_conntrack_dccp_timeout_closing",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_DCCP_TIMEWAIT] = {
+ 		.procname	= "nf_conntrack_dccp_timeout_timewait",
+ 		.maxlen		= sizeof(unsigned int),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_DCCP_LOOSE] = {
+ 		.procname	= "nf_conntrack_dccp_loose",
+ 		.maxlen		= sizeof(u8),
+ 		.mode		= 0644,
+ 		.proc_handler	= proc_dou8vec_minmax,
+ 		.extra1 	= SYSCTL_ZERO,
+ 		.extra2 	= SYSCTL_ONE,
+ 	},
+ #endif
+ #ifdef CONFIG_NF_CT_PROTO_GRE
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_GRE] = {
+ 		.procname       = "nf_conntrack_gre_timeout",
+ 		.maxlen         = sizeof(unsigned int),
+ 		.mode           = 0644,
+ 		.proc_handler   = proc_dointvec_jiffies,
+ 	},
+ 	[NF_SYSCTL_CT_PROTO_TIMEOUT_GRE_STREAM] = {
+ 		.procname       = "nf_conntrack_gre_timeout_stream",
+ 		.maxlen         = sizeof(unsigned int),
+ 		.mode           = 0644,
+ 		.proc_handler   = proc_dointvec_jiffies,
+ 	},
+ #endif
+ 	{}
++>>>>>>> 975c57504da1 (netfilter: conntrack: Introduce udp offload timeout configuration)
  };
  
  static struct ctl_table nf_ct_netfilter_table[] = {
@@@ -583,21 -1079,45 +963,44 @@@ static int nf_conntrack_standalone_init
  	table = kmemdup(nf_ct_sysctl_table, sizeof(nf_ct_sysctl_table),
  			GFP_KERNEL);
  	if (!table)
 -		return -ENOMEM;
 +		goto out_kmemdup;
  
++<<<<<<< HEAD
 +	table[1].data = &net->ct.count;
 +	table[3].data = &net->ct.sysctl_checksum;
 +	table[4].data = &net->ct.sysctl_log_invalid;
++=======
+ 	table[NF_SYSCTL_CT_COUNT].data = &cnet->count;
+ 	table[NF_SYSCTL_CT_CHECKSUM].data = &net->ct.sysctl_checksum;
+ 	table[NF_SYSCTL_CT_LOG_INVALID].data = &net->ct.sysctl_log_invalid;
+ 	table[NF_SYSCTL_CT_ACCT].data = &net->ct.sysctl_acct;
+ 	table[NF_SYSCTL_CT_HELPER].data = &cnet->sysctl_auto_assign_helper;
+ #ifdef CONFIG_NF_CONNTRACK_EVENTS
+ 	table[NF_SYSCTL_CT_EVENTS].data = &net->ct.sysctl_events;
+ #endif
+ #ifdef CONFIG_NF_CONNTRACK_TIMESTAMP
+ 	table[NF_SYSCTL_CT_TIMESTAMP].data = &net->ct.sysctl_tstamp;
+ #endif
+ 	table[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;
+ 	table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;
+ 	table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;
+ 	table[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP].data = &un->timeouts[UDP_CT_UNREPLIED];
+ 	table[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM].data = &un->timeouts[UDP_CT_REPLIED];
+ #if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
+ 	table[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_OFFLOAD].data = &un->offload_timeout;
+ 	table[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_OFFLOAD_PICKUP].data = &un->offload_pickup;
+ #endif
++>>>>>>> 975c57504da1 (netfilter: conntrack: Introduce udp offload timeout configuration)
  
 -	nf_conntrack_standalone_init_tcp_sysctl(net, table);
 -	nf_conntrack_standalone_init_sctp_sysctl(net, table);
 -	nf_conntrack_standalone_init_dccp_sysctl(net, table);
 -	nf_conntrack_standalone_init_gre_sysctl(net, table);
 +	/* Don't export sysctls to unprivileged users */
 +	if (net->user_ns != &init_user_ns)
 +		table[0].procname = NULL;
  
 -	/* Don't allow non-init_net ns to alter global sysctls */
 -	if (!net_eq(&init_net, net)) {
 -		table[NF_SYSCTL_CT_MAX].mode = 0444;
 -		table[NF_SYSCTL_CT_EXPECT_MAX].mode = 0444;
 -		table[NF_SYSCTL_CT_BUCKETS].mode = 0444;
 -	}
 +	if (!net_eq(&init_net, net))
 +		table[2].mode = 0444;
  
 -	cnet->sysctl_header = register_net_sysctl(net, "net/netfilter", table);
 -	if (!cnet->sysctl_header)
 +	net->ct.sysctl_header = register_net_sysctl(net, "net/netfilter", table);
 +	if (!net->ct.sysctl_header)
  		goto out_unregister_netfilter;
  
  	return 0;
diff --git a/include/net/netns/conntrack.h b/include/net/netns/conntrack.h
index 42c8b69c1113..cd9b80080c40 100644
--- a/include/net/netns/conntrack.h
+++ b/include/net/netns/conntrack.h
@@ -48,6 +48,10 @@ enum udp_conntrack {
 struct nf_udp_net {
 	struct nf_proto_net pn;
 	unsigned int timeouts[UDP_CT_MAX];
+#if IS_ENABLED(CONFIG_NF_FLOW_TABLE)
+	unsigned int offload_timeout;
+	unsigned int offload_pickup;
+#endif
 };
 
 struct nf_icmp_net {
* Unmerged path net/netfilter/nf_conntrack_proto_udp.c
* Unmerged path net/netfilter/nf_conntrack_standalone.c
