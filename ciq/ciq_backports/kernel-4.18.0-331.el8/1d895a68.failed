vDPA/ifcvf: verify mandatory feature bits for vDPA

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Zhu Lingshan <lingshan.zhu@intel.com>
commit 1d895a68085b28d098893570b024229aacc9a057
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/1d895a68.failed

vDPA requres VIRTIO_F_ACCESS_PLATFORM as a must, this commit
examines this when set features.

	Signed-off-by: Zhu Lingshan <lingshan.zhu@intel.com>
	Acked-by: Jason Wang <jasowang@redhat.com>
Link: https://lore.kernel.org/r/20210317094933.16417-7-lingshan.zhu@intel.com
	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
(cherry picked from commit 1d895a68085b28d098893570b024229aacc9a057)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vdpa/ifcvf/ifcvf_base.h
diff --cc drivers/vdpa/ifcvf/ifcvf_base.h
index 794d1505d857,f77239fc1644..000000000000
--- a/drivers/vdpa/ifcvf/ifcvf_base.h
+++ b/drivers/vdpa/ifcvf/ifcvf_base.h
@@@ -121,6 -122,8 +121,11 @@@ void ifcvf_set_status(struct ifcvf_hw *
  void io_write64_twopart(u64 val, u32 *lo, u32 *hi);
  void ifcvf_reset(struct ifcvf_hw *hw);
  u64 ifcvf_get_features(struct ifcvf_hw *hw);
++<<<<<<< HEAD
++=======
+ u64 ifcvf_get_hw_features(struct ifcvf_hw *hw);
+ int ifcvf_verify_min_features(struct ifcvf_hw *hw, u64 features);
++>>>>>>> 1d895a68085b (vDPA/ifcvf: verify mandatory feature bits for vDPA)
  u16 ifcvf_get_vq_state(struct ifcvf_hw *hw, u16 qid);
  int ifcvf_set_vq_state(struct ifcvf_hw *hw, u16 qid, u16 num);
  struct ifcvf_adapter *vf_to_adapter(struct ifcvf_hw *hw);
diff --git a/drivers/vdpa/ifcvf/ifcvf_base.c b/drivers/vdpa/ifcvf/ifcvf_base.c
index f2a128e56de5..b64a4e056731 100644
--- a/drivers/vdpa/ifcvf/ifcvf_base.c
+++ b/drivers/vdpa/ifcvf/ifcvf_base.c
@@ -216,6 +216,18 @@ u64 ifcvf_get_features(struct ifcvf_hw *hw)
 	return ((u64)features_hi << 32) | features_lo;
 }
 
+int ifcvf_verify_min_features(struct ifcvf_hw *hw, u64 features)
+{
+	struct ifcvf_adapter *ifcvf = vf_to_adapter(hw);
+
+	if (!(features & BIT_ULL(VIRTIO_F_ACCESS_PLATFORM)) && features) {
+		IFCVF_ERR(ifcvf->pdev, "VIRTIO_F_ACCESS_PLATFORM is not negotiated\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
 void ifcvf_read_net_config(struct ifcvf_hw *hw, u64 offset,
 			   void *dst, int length)
 {
* Unmerged path drivers/vdpa/ifcvf/ifcvf_base.h
diff --git a/drivers/vdpa/ifcvf/ifcvf_main.c b/drivers/vdpa/ifcvf/ifcvf_main.c
index 26ae968c8563..b73accb31e04 100644
--- a/drivers/vdpa/ifcvf/ifcvf_main.c
+++ b/drivers/vdpa/ifcvf/ifcvf_main.c
@@ -179,6 +179,11 @@ static u64 ifcvf_vdpa_get_features(struct vdpa_device *vdpa_dev)
 static int ifcvf_vdpa_set_features(struct vdpa_device *vdpa_dev, u64 features)
 {
 	struct ifcvf_hw *vf = vdpa_to_vf(vdpa_dev);
+	int ret;
+
+	ret = ifcvf_verify_min_features(vf, features);
+	if (ret)
+		return ret;
 
 	vf->req_features = features;
 
