vDPA/ifcvf: deduce VIRTIO device ID when probe

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Zhu Lingshan <lingshan.zhu@intel.com>
commit 26bfea1309f5d4faad33383d2d82a3463f518982
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/26bfea13.failed

This commit deduces VIRTIO device ID as device type when probe,
then ifcvf_vdpa_get_device_id() can simply return the ID.
ifcvf_vdpa_get_features() and ifcvf_vdpa_get_config_size()
can work properly based on the device ID.

	Signed-off-by: Zhu Lingshan <lingshan.zhu@intel.com>
Link: https://lore.kernel.org/r/20210419063326.3748-2-lingshan.zhu@intel.com
	Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
	Acked-by: Jason Wang <jasowang@redhat.com>
(cherry picked from commit 26bfea1309f5d4faad33383d2d82a3463f518982)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/vdpa/ifcvf/ifcvf_base.h
diff --cc drivers/vdpa/ifcvf/ifcvf_base.h
index 90157383850f,1c04cd256fa7..000000000000
--- a/drivers/vdpa/ifcvf/ifcvf_base.h
+++ b/drivers/vdpa/ifcvf/ifcvf_base.h
@@@ -83,6 -83,8 +83,11 @@@ struct ifcvf_hw 
  	void __iomem *notify_base;
  	u32 notify_off_multiplier;
  	u64 req_features;
++<<<<<<< HEAD
++=======
+ 	u64 hw_features;
+ 	u32 dev_type;
++>>>>>>> 26bfea1309f5 (vDPA/ifcvf: deduce VIRTIO device ID when probe)
  	struct virtio_pci_common_cfg __iomem *common_cfg;
  	void __iomem *net_cfg;
  	struct vring_info vring[IFCVF_MAX_QUEUE_PAIRS * 2];
* Unmerged path drivers/vdpa/ifcvf/ifcvf_base.h
diff --git a/drivers/vdpa/ifcvf/ifcvf_main.c b/drivers/vdpa/ifcvf/ifcvf_main.c
index 5a730c5bb297..9d4626342e02 100644
--- a/drivers/vdpa/ifcvf/ifcvf_main.c
+++ b/drivers/vdpa/ifcvf/ifcvf_main.c
@@ -318,19 +318,9 @@ static u32 ifcvf_vdpa_get_generation(struct vdpa_device *vdpa_dev)
 
 static u32 ifcvf_vdpa_get_device_id(struct vdpa_device *vdpa_dev)
 {
-	struct ifcvf_adapter *adapter = vdpa_to_adapter(vdpa_dev);
-	struct pci_dev *pdev = adapter->pdev;
-	u32 ret = -ENODEV;
-
-	if (pdev->device < 0x1000 || pdev->device > 0x107f)
-		return ret;
-
-	if (pdev->device < 0x1040)
-		ret =  pdev->subsystem_device;
-	else
-		ret =  pdev->device - 0x1040;
+	struct ifcvf_hw *vf = vdpa_to_vf(vdpa_dev);
 
-	return ret;
+	return vf->dev_type;
 }
 
 static u32 ifcvf_vdpa_get_vendor_id(struct vdpa_device *vdpa_dev)
@@ -462,6 +452,19 @@ static int ifcvf_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 	pci_set_drvdata(pdev, adapter);
 
 	vf = &adapter->vf;
+
+	/* This drirver drives both modern virtio devices and transitional
+	 * devices in modern mode.
+	 * vDPA requires feature bit VIRTIO_F_ACCESS_PLATFORM,
+	 * so legacy devices and transitional devices in legacy
+	 * mode will not work for vDPA, this driver will not
+	 * drive devices with legacy interface.
+	 */
+	if (pdev->device < 0x1040)
+		vf->dev_type =  pdev->subsystem_device;
+	else
+		vf->dev_type =  pdev->device - 0x1040;
+
 	vf->base = pcim_iomap_table(pdev);
 
 	adapter->pdev = pdev;
