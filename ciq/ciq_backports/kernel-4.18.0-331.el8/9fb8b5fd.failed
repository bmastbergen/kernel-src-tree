powerpc/numa: remove vphn_enabled and prrn_enabled internal flags

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Nathan Lynch <nathanl@linux.ibm.com>
commit 9fb8b5fd1bf782a8257506ad5198237f4124d556
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/9fb8b5fd.failed

These flags are always zero now; remove them and suitably adjust the
remaining references to them.

	Signed-off-by: Nathan Lynch <nathanl@linux.ibm.com>
	Reviewed-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
	Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
Link: https://lore.kernel.org/r/20200612051238.1007764-9-nathanl@linux.ibm.com
(cherry picked from commit 9fb8b5fd1bf782a8257506ad5198237f4124d556)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/mm/numa.c
diff --cc arch/powerpc/mm/numa.c
index 25c8877a4b95,8749d7f2b1a6..000000000000
--- a/arch/powerpc/mm/numa.c
+++ b/arch/powerpc/mm/numa.c
@@@ -1197,14 -1129,7 +1197,17 @@@ struct topology_update_data 
  	int new_nid;
  };
  
 +#define TOPOLOGY_DEF_TIMER_SECS	60
 +
 +static u8 vphn_cpu_change_counts[NR_CPUS][MAX_DISTANCE_REF_POINTS];
  static cpumask_t cpu_associativity_changes_mask;
++<<<<<<< HEAD
 +static const int vphn_enabled;
 +static const int prrn_enabled;
 +static void reset_topology_timer(void);
 +static int topology_timer_secs = 1;
++=======
++>>>>>>> 9fb8b5fd1bf7 (powerpc/numa: remove vphn_enabled and prrn_enabled internal flags)
  static int topology_inited;
  
  /*
@@@ -1668,80 -1430,9 +1671,80 @@@ int stop_topology_update(void
  
  int prrn_is_enabled(void)
  {
- 	return prrn_enabled;
+ 	return 0;
  }
  
 +static int topology_read(struct seq_file *file, void *v)
 +{
 +	if (vphn_enabled || prrn_enabled)
 +		seq_puts(file, "on\n");
 +	else
 +		seq_puts(file, "off\n");
 +
 +	return 0;
 +}
 +
 +static int topology_open(struct inode *inode, struct file *file)
 +{
 +	return single_open(file, topology_read, NULL);
 +}
 +
 +static ssize_t topology_write(struct file *file, const char __user *buf,
 +			      size_t count, loff_t *off)
 +{
 +	char kbuf[4]; /* "on" or "off" plus null. */
 +	int read_len;
 +
 +	read_len = count < 3 ? count : 3;
 +	if (copy_from_user(kbuf, buf, read_len))
 +		return -EINVAL;
 +
 +	kbuf[read_len] = '\0';
 +
 +	if (!strncmp(kbuf, "on", 2)) {
 +		topology_updates_enabled = true;
 +		start_topology_update();
 +	} else if (!strncmp(kbuf, "off", 3)) {
 +		stop_topology_update();
 +		topology_updates_enabled = false;
 +	} else
 +		return -EINVAL;
 +
 +	return count;
 +}
 +
 +static const struct file_operations topology_ops = {
 +	.read = seq_read,
 +	.write = topology_write,
 +	.open = topology_open,
 +	.release = single_release
 +};
 +
 +int cpu_to_coregroup_id(int cpu)
 +{
 +	__be32 associativity[VPHN_ASSOC_BUFSIZE] = {0};
 +	int index;
 +
 +	if (cpu < 0 || cpu > nr_cpu_ids)
 +		return -1;
 +
 +	if (!coregroup_enabled)
 +		goto out;
 +
 +	if (!firmware_has_feature(FW_FEATURE_VPHN))
 +		goto out;
 +
 +	if (vphn_get_associativity(cpu, associativity))
 +		goto out;
 +
 +	index = of_read_number(associativity, 1);
 +	if (index > min_common_depth + 1)
 +		return of_read_number(&associativity[index - 1], 1);
 +
 +out:
 +	return cpu_to_core_id(cpu);
 +}
 +
  static int topology_update_init(void)
  {
  	start_topology_update();
* Unmerged path arch/powerpc/mm/numa.c
