net: fix hangup on napi_disable for threaded napi

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Paolo Abeni <pabeni@redhat.com>
commit 27f0ad71699de41bae013c367b95a6b319cc46a9
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/27f0ad71.failed

napi_disable() is subject to an hangup, when the threaded
mode is enabled and the napi is under heavy traffic.

If the relevant napi has been scheduled and the napi_disable()
kicks in before the next napi_threaded_wait() completes - so
that the latter quits due to the napi_disable_pending() condition,
the existing code leaves the NAPI_STATE_SCHED bit set and the
napi_disable() loop waiting for such bit will hang.

This patch addresses the issue by dropping the NAPI_STATE_DISABLE
bit test in napi_thread_wait(). The later napi_threaded_poll()
iteration will take care of clearing the NAPI_STATE_SCHED.

This also addresses a related problem reported by Jakub:
before this patch a napi_disable()/napi_enable() pair killed
the napi thread, effectively disabling the threaded mode.
On the patched kernel napi_disable() simply stops scheduling
the relevant thread.

v1 -> v2:
  - let the main napi_thread_poll() loop clear the SCHED bit

	Reported-by: Jakub Kicinski <kuba@kernel.org>
Fixes: 29863d41bb6e ("net: implement threaded-able napi poll loop support")
	Signed-off-by: Paolo Abeni <pabeni@redhat.com>
	Reviewed-by: Eric Dumazet <edumazet@google.com>
Link: https://lore.kernel.org/r/883923fa22745a9589e8610962b7dc59df09fb1f.1617981844.git.pabeni@redhat.com
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 27f0ad71699de41bae013c367b95a6b319cc46a9)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/core/dev.c
diff --cc net/core/dev.c
index a223efdd8606,af8c1ea040b9..000000000000
--- a/net/core/dev.c
+++ b/net/core/dev.c
@@@ -6483,6 -6986,60 +6483,63 @@@ out_unlock
  	return work;
  }
  
++<<<<<<< HEAD
++=======
+ static int napi_thread_wait(struct napi_struct *napi)
+ {
+ 	bool woken = false;
+ 
+ 	set_current_state(TASK_INTERRUPTIBLE);
+ 
+ 	while (!kthread_should_stop()) {
+ 		/* Testing SCHED_THREADED bit here to make sure the current
+ 		 * kthread owns this napi and could poll on this napi.
+ 		 * Testing SCHED bit is not enough because SCHED bit might be
+ 		 * set by some other busy poll thread or by napi_disable().
+ 		 */
+ 		if (test_bit(NAPI_STATE_SCHED_THREADED, &napi->state) || woken) {
+ 			WARN_ON(!list_empty(&napi->poll_list));
+ 			__set_current_state(TASK_RUNNING);
+ 			return 0;
+ 		}
+ 
+ 		schedule();
+ 		/* woken being true indicates this thread owns this napi. */
+ 		woken = true;
+ 		set_current_state(TASK_INTERRUPTIBLE);
+ 	}
+ 	__set_current_state(TASK_RUNNING);
+ 
+ 	return -1;
+ }
+ 
+ static int napi_threaded_poll(void *data)
+ {
+ 	struct napi_struct *napi = data;
+ 	void *have;
+ 
+ 	while (!napi_thread_wait(napi)) {
+ 		for (;;) {
+ 			bool repoll = false;
+ 
+ 			local_bh_disable();
+ 
+ 			have = netpoll_poll_lock(napi);
+ 			__napi_poll(napi, &repoll);
+ 			netpoll_poll_unlock(have);
+ 
+ 			local_bh_enable();
+ 
+ 			if (!repoll)
+ 				break;
+ 
+ 			cond_resched();
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
++>>>>>>> 27f0ad71699d (net: fix hangup on napi_disable for threaded napi)
  static __latent_entropy void net_rx_action(struct softirq_action *h)
  {
  	struct softnet_data *sd = this_cpu_ptr(&softnet_data);
* Unmerged path net/core/dev.c
