hwmon: (k10temp) Report temperatures per CPU die

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Guenter Roeck <linux@roeck-us.net>
commit c757938929c9e1de52e31400f673fac02e1f26bb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/c7579389.failed

Zen2 reports reporting temperatures per CPU die (called Core Complex Dies,
or CCD, by AMD). Add support for it to the k10temp driver.

	Tested-by: Brad Campbell <lists2009@fnarfbargle.com>
	Tested-by: Bernhard Gebetsberger <bernhard.gebetsberger@gmx.at>
	Tested-by: Holger Kiehl <holger.kiehl@dwd.de>
	Tested-by: Michael Larabel <michael@phoronix.com>
	Tested-by: Jonathan McDowell <noodles@earth.li>
	Tested-by: Ken Moffat <zarniwhoop73@googlemail.com>
	Tested-by: Darren Salt <devspam@moreofthesa.me.uk>
	Signed-off-by: Guenter Roeck <linux@roeck-us.net>
(cherry picked from commit c757938929c9e1de52e31400f673fac02e1f26bb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/hwmon/k10temp.c
diff --cc drivers/hwmon/k10temp.c
index db492da74e93,0af096b061fa..000000000000
--- a/drivers/hwmon/k10temp.c
+++ b/drivers/hwmon/k10temp.c
@@@ -5,8 -5,15 +5,14 @@@
   *
   * Copyright (c) 2009 Clemens Ladisch <clemens@ladisch.de>
   * Copyright (c) 2020 Guenter Roeck <linux@roeck-us.net>
+  *
+  * Implementation notes:
+  * - CCD1 and CCD2 register address information as well as the calculation to
+  *   convert raw register values is from https://github.com/ocerman/zenpower.
+  *   The information is not confirmed from chip datasheets, but experiments
+  *   suggest that it provides reasonable temperature values.
   */
  
 -#include <linux/bitops.h>
  #include <linux/err.h>
  #include <linux/hwmon.h>
  #include <linux/init.h>
@@@ -60,7 -67,12 +66,9 @@@ static DEFINE_MUTEX(nb_smu_ind_mutex)
  
  /* F17h M01h Access througn SMN */
  #define F17H_M01H_REPORTED_TEMP_CTRL_OFFSET	0x00059800
+ #define F17H_M70H_CCD1_TEMP			0x00059954
+ #define F17H_M70H_CCD2_TEMP			0x00059958
  
 -#define CUR_TEMP_SHIFT				21
 -#define CUR_TEMP_RANGE_SEL_MASK			BIT(19)
 -
  struct k10temp_data {
  	struct pci_dev *pdev;
  	void (*read_htcreg)(struct pci_dev *pdev, u32 *regval);
@@@ -321,10 -381,32 +377,37 @@@ static int k10temp_probe(struct pci_de
  	     (boot_cpu_data.x86_model & 0xf0) == 0x70)) {
  		data->read_htcreg = read_htcreg_nb_f15;
  		data->read_tempreg = read_tempreg_nb_f15;
++<<<<<<< HEAD
 +	} else if (boot_cpu_data.x86 == 0x17 || boot_cpu_data.x86 == 0x19) {
 +		data->temp_adjust_mask = 0x80000;
++=======
+ 	} else if (boot_cpu_data.x86 == 0x17 || boot_cpu_data.x86 == 0x18) {
+ 		u32 regval;
+ 
+ 		data->temp_adjust_mask = CUR_TEMP_RANGE_SEL_MASK;
++>>>>>>> c757938929c9 (hwmon: (k10temp) Report temperatures per CPU die)
  		data->read_tempreg = read_tempreg_nb_f17;
  		data->show_tdie = true;
+ 
+ 		switch (boot_cpu_data.x86_model) {
+ 		case 0x1:	/* Zen */
+ 		case 0x8:	/* Zen+ */
+ 		case 0x11:	/* Zen APU */
+ 		case 0x18:	/* Zen+ APU */
+ 			break;
+ 		case 0x31:	/* Zen2 Threadripper */
+ 		case 0x71:	/* Zen2 */
+ 			amd_smn_read(amd_pci_dev_to_node_id(pdev),
+ 				     F17H_M70H_CCD1_TEMP, &regval);
+ 			if (regval & 0xfff)
+ 				data->show_tccd1 = true;
+ 
+ 			amd_smn_read(amd_pci_dev_to_node_id(pdev),
+ 				     F17H_M70H_CCD2_TEMP, &regval);
+ 			if (regval & 0xfff)
+ 				data->show_tccd2 = true;
+ 			break;
+ 		}
  	} else {
  		data->read_htcreg = read_htcreg_pci;
  		data->read_tempreg = read_tempreg_pci;
* Unmerged path drivers/hwmon/k10temp.c
