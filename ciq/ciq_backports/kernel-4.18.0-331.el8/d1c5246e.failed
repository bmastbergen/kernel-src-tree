x86/mm: Fix leak of pmd ptlock

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Dan Williams <dan.j.williams@intel.com>
commit d1c5246e08eb64991001d97a3bd119c93edbc79a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/d1c5246e.failed

Commit

  28ee90fe6048 ("x86/mm: implement free pmd/pte page interfaces")

introduced a new location where a pmd was released, but neglected to
run the pmd page destructor. In fact, this happened previously for a
different pmd release path and was fixed by commit:

  c283610e44ec ("x86, mm: do not leak page->ptl for pmd page tables").

This issue was hidden until recently because the failure mode is silent,
but commit:

  b2b29d6d0119 ("mm: account PMD tables like PTE tables")

turns the failure mode into this signature:

 BUG: Bad page state in process lt-pmem-ns  pfn:15943d
 page:000000007262ed7b refcount:0 mapcount:-1024 mapping:0000000000000000 index:0x0 pfn:0x15943d
 flags: 0xaffff800000000()
 raw: 00affff800000000 dead000000000100 0000000000000000 0000000000000000
 raw: 0000000000000000 ffff913a029bcc08 00000000fffffbff 0000000000000000
 page dumped because: nonzero mapcount
 [..]
  dump_stack+0x8b/0xb0
  bad_page.cold+0x63/0x94
  free_pcp_prepare+0x224/0x270
  free_unref_page+0x18/0xd0
  pud_free_pmd_page+0x146/0x160
  ioremap_pud_range+0xe3/0x350
  ioremap_page_range+0x108/0x160
  __ioremap_caller.constprop.0+0x174/0x2b0
  ? memremap+0x7a/0x110
  memremap+0x7a/0x110
  devm_memremap+0x53/0xa0
  pmem_attach_disk+0x4ed/0x530 [nd_pmem]
  ? __devm_release_region+0x52/0x80
  nvdimm_bus_probe+0x85/0x210 [libnvdimm]

Given this is a repeat occurrence it seemed prudent to look for other
places where this destructor might be missing and whether a better
helper is needed. try_to_free_pmd_page() looks like a candidate, but
testing with setting up and tearing down pmd mappings via the dax unit
tests is thus far not triggering the failure.

As for a better helper pmd_free() is close, but it is a messy fit
due to requiring an @mm arg. Also, ___pmd_free_tlb() wants to call
paravirt_tlb_remove_table() instead of free_page(), so open-coded
pgtable_pmd_page_dtor() seems the best way forward for now.

Debugged together with Matthew Wilcox <willy@infradead.org>.

Fixes: 28ee90fe6048 ("x86/mm: implement free pmd/pte page interfaces")
	Signed-off-by: Dan Williams <dan.j.williams@intel.com>
	Signed-off-by: Borislav Petkov <bp@suse.de>
	Tested-by: Yi Zhang <yi.zhang@redhat.com>
	Acked-by: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: <stable@vger.kernel.org>
Link: https://lkml.kernel.org/r/160697689204.605323.17629854984697045602.stgit@dwillia2-desk3.amr.corp.intel.com
(cherry picked from commit d1c5246e08eb64991001d97a3bd119c93edbc79a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/mm/pgtable.c
diff --cc arch/x86/mm/pgtable.c
index 8f2753a96f7c,f6a9e2e36642..000000000000
--- a/arch/x86/mm/pgtable.c
+++ b/arch/x86/mm/pgtable.c
@@@ -738,19 -799,38 +738,36 @@@ int pmd_clear_huge(pmd_t *pmd
   */
  int pud_free_pmd_page(pud_t *pud, unsigned long addr)
  {
 -	pmd_t *pmd, *pmd_sv;
 -	pte_t *pte;
 +	pmd_t *pmd;
  	int i;
  
 +	if (pud_none(*pud))
 +		return 1;
 +
  	pmd = (pmd_t *)pud_page_vaddr(*pud);
 -	pmd_sv = (pmd_t *)__get_free_page(GFP_KERNEL);
 -	if (!pmd_sv)
 -		return 0;
  
 -	for (i = 0; i < PTRS_PER_PMD; i++) {
 -		pmd_sv[i] = pmd[i];
 -		if (!pmd_none(pmd[i]))
 -			pmd_clear(&pmd[i]);
 -	}
 +	for (i = 0; i < PTRS_PER_PMD; i++)
 +		if (!pmd_free_pte_page(&pmd[i], addr + (i * PMD_SIZE)))
 +			return 0;
  
  	pud_clear(pud);
++<<<<<<< HEAD
++=======
+ 
+ 	/* INVLPG to clear all paging-structure caches */
+ 	flush_tlb_kernel_range(addr, addr + PAGE_SIZE-1);
+ 
+ 	for (i = 0; i < PTRS_PER_PMD; i++) {
+ 		if (!pmd_none(pmd_sv[i])) {
+ 			pte = (pte_t *)pmd_page_vaddr(pmd_sv[i]);
+ 			free_page((unsigned long)pte);
+ 		}
+ 	}
+ 
+ 	free_page((unsigned long)pmd_sv);
+ 
+ 	pgtable_pmd_page_dtor(virt_to_page(pmd));
++>>>>>>> d1c5246e08eb (x86/mm: Fix leak of pmd ptlock)
  	free_page((unsigned long)pmd);
  
  	return 1;
* Unmerged path arch/x86/mm/pgtable.c
