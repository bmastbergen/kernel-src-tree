net: stmmac: Add support for external trigger timestamping

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Tan Tee Min <tee.min.tan@intel.com>
commit f4da56529da602010979e8497d1f02eaf5df8883
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/f4da5652.failed

The Synopsis MAC controller supports auxiliary snapshot feature that
allows user to store a snapshot of the system time based on an external
event.

This patch add supports to the above mentioned feature. Users will be
able to triggered capturing the time snapshot from user-space using
application such as testptp or any other applications that uses the
PTP_EXTTS_REQUEST ioctl request.

	Cc: Richard Cochran <richardcochran@gmail.com>
	Signed-off-by: Tan Tee Min <tee.min.tan@intel.com>
Co-developed-by: Wong Vee Khee <vee.khee.wong@linux.intel.com>
	Signed-off-by: Wong Vee Khee <vee.khee.wong@linux.intel.com>
	Acked-by: Richard Cochran <richardcochran@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit f4da56529da602010979e8497d1f02eaf5df8883)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
#	drivers/net/ethernet/stmicro/stmmac/hwif.h
#	drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
#	drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.h
#	include/linux/stmmac.h
diff --cc drivers/net/ethernet/stmicro/stmmac/hwif.h
index 3201a5557898,2cc91759b91f..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/hwif.h
+++ b/drivers/net/ethernet/stmicro/stmmac/hwif.h
@@@ -514,6 -516,8 +516,11 @@@ struct stmmac_hwtimestamp 
  	int (*adjust_systime) (void __iomem *ioaddr, u32 sec, u32 nsec,
  			       int add_sub, int gmac4);
  	void (*get_systime) (void __iomem *ioaddr, u64 *systime);
++<<<<<<< HEAD
++=======
+ 	void (*get_ptptime)(void __iomem *ioaddr, u64 *ptp_time);
+ 	void (*timestamp_interrupt)(struct stmmac_priv *priv);
++>>>>>>> f4da56529da6 (net: stmmac: Add support for external trigger timestamping)
  };
  
  #define stmmac_config_hw_tstamping(__priv, __args...) \
@@@ -528,6 -532,10 +535,13 @@@
  	stmmac_do_callback(__priv, ptp, adjust_systime, __args)
  #define stmmac_get_systime(__priv, __args...) \
  	stmmac_do_void_callback(__priv, ptp, get_systime, __args)
++<<<<<<< HEAD
++=======
+ #define stmmac_get_ptptime(__priv, __args...) \
+ 	stmmac_do_void_callback(__priv, ptp, get_ptptime, __args)
+ #define stmmac_timestamp_interrupt(__priv, __args...) \
+ 	stmmac_do_void_callback(__priv, ptp, timestamp_interrupt, __args)
++>>>>>>> f4da56529da6 (net: stmmac: Add support for external trigger timestamping)
  
  /* Helpers to manage the descriptors for chain and ring modes */
  struct stmmac_mode_ops {
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
index 6d30fa557927,074e2cdfb0fa..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
@@@ -163,6 -156,51 +166,54 @@@ static void get_systime(void __iomem *i
  		*systime = ns;
  }
  
++<<<<<<< HEAD
++=======
+ static void get_ptptime(void __iomem *ptpaddr, u64 *ptp_time)
+ {
+ 	u64 ns;
+ 
+ 	ns = readl(ptpaddr + PTP_ATNR);
+ 	ns += readl(ptpaddr + PTP_ATSR) * NSEC_PER_SEC;
+ 
+ 	*ptp_time = ns;
+ }
+ 
+ static void timestamp_interrupt(struct stmmac_priv *priv)
+ {
+ 	u32 num_snapshot, ts_status, tsync_int;
+ 	struct ptp_clock_event event;
+ 	unsigned long flags;
+ 	u64 ptp_time;
+ 	int i;
+ 
+ 	tsync_int = readl(priv->ioaddr + GMAC_INT_STATUS) & GMAC_INT_TSIE;
+ 
+ 	if (!tsync_int)
+ 		return;
+ 
+ 	/* Read timestamp status to clear interrupt from either external
+ 	 * timestamp or start/end of PPS.
+ 	 */
+ 	ts_status = readl(priv->ioaddr + GMAC_TIMESTAMP_STATUS);
+ 
+ 	if (!priv->plat->ext_snapshot_en)
+ 		return;
+ 
+ 	num_snapshot = (ts_status & GMAC_TIMESTAMP_ATSNS_MASK) >>
+ 		       GMAC_TIMESTAMP_ATSNS_SHIFT;
+ 
+ 	for (i = 0; i < num_snapshot; i++) {
+ 		spin_lock_irqsave(&priv->ptp_lock, flags);
+ 		get_ptptime(priv->ptpaddr, &ptp_time);
+ 		spin_unlock_irqrestore(&priv->ptp_lock, flags);
+ 		event.type = PTP_CLOCK_EXTTS;
+ 		event.index = 0;
+ 		event.timestamp = ptp_time;
+ 		ptp_clock_event(priv->ptp_clock, &event);
+ 	}
+ }
+ 
++>>>>>>> f4da56529da6 (net: stmmac: Add support for external trigger timestamping)
  const struct stmmac_hwtimestamp stmmac_ptp = {
  	.config_hw_tstamping = config_hw_tstamping,
  	.init_systime = init_systime,
@@@ -170,4 -208,6 +221,9 @@@
  	.config_addend = config_addend,
  	.adjust_systime = adjust_systime,
  	.get_systime = get_systime,
++<<<<<<< HEAD
++=======
+ 	.get_ptptime = get_ptptime,
+ 	.timestamp_interrupt = timestamp_interrupt,
++>>>>>>> f4da56529da6 (net: stmmac: Add support for external trigger timestamping)
  };
diff --cc drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.h
index e852821289cf,53172a439810..000000000000
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.h
@@@ -74,4 -67,25 +74,28 @@@
  #define	PTP_SSIR_SSINC_MASK		0xff
  #define	GMAC4_PTP_SSIR_SSINC_SHIFT	16
  
++<<<<<<< HEAD
++=======
+ /* Auxiliary Control defines */
+ #define	PTP_ACR_ATSFC		BIT(0)	/* Auxiliary Snapshot FIFO Clear */
+ #define	PTP_ACR_ATSEN0		BIT(4)	/* Auxiliary Snapshot 0 Enable */
+ #define	PTP_ACR_ATSEN1		BIT(5)	/* Auxiliary Snapshot 1 Enable */
+ #define	PTP_ACR_ATSEN2		BIT(6)	/* Auxiliary Snapshot 2 Enable */
+ #define	PTP_ACR_ATSEN3		BIT(7)	/* Auxiliary Snapshot 3 Enable */
+ #define	PTP_ACR_ATSEN_SHIFT	5	/* Auxiliary Snapshot shift */
+ #define	PTP_ACR_MASK		GENMASK(7, 4)	/* Aux Snapshot Mask */
+ #define	PMC_ART_VALUE0		0x01	/* PMC_ART[15:0] timer value */
+ #define	PMC_ART_VALUE1		0x02	/* PMC_ART[31:16] timer value */
+ #define	PMC_ART_VALUE2		0x03	/* PMC_ART[47:32] timer value */
+ #define	PMC_ART_VALUE3		0x04	/* PMC_ART[63:48] timer value */
+ #define	GMAC4_ART_TIME_SHIFT	16	/* ART TIME 16-bits shift */
+ 
+ enum aux_snapshot {
+ 	AUX_SNAPSHOT0 = 0x10,
+ 	AUX_SNAPSHOT1 = 0x20,
+ 	AUX_SNAPSHOT2 = 0x40,
+ 	AUX_SNAPSHOT3 = 0x80,
+ };
+ 
++>>>>>>> f4da56529da6 (net: stmmac: Add support for external trigger timestamping)
  #endif	/* __STMMAC_PTP_H__ */
diff --cc include/linux/stmmac.h
index 3f0b13d7afc6,97edb31d6310..000000000000
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@@ -243,5 -234,19 +243,22 @@@ struct plat_stmmacenet_data 
  	int has_xgmac;
  	bool vlan_fail_q_en;
  	u8 vlan_fail_q;
++<<<<<<< HEAD
++=======
+ 	unsigned int eee_usecs_rate;
+ 	struct pci_dev *pdev;
+ 	bool has_crossts;
+ 	int int_snapshot_num;
+ 	int ext_snapshot_num;
+ 	bool ext_snapshot_en;
+ 	bool multi_msi_en;
+ 	int msi_mac_vec;
+ 	int msi_wol_vec;
+ 	int msi_lpi_vec;
+ 	int msi_sfty_ce_vec;
+ 	int msi_sfty_ue_vec;
+ 	int msi_rx_base_vec;
+ 	int msi_tx_base_vec;
++>>>>>>> f4da56529da6 (net: stmmac: Add support for external trigger timestamping)
  };
  #endif
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/dwmac-intel.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/hwif.h
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac.h b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
index e120928a6768..f78b4854df42 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac.h
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac.h
@@ -233,6 +233,9 @@ struct stmmac_priv {
 	int use_riwt;
 	int irq_wake;
 	spinlock_t ptp_lock;
+	/* Protects auxiliary snapshot registers from concurrent access. */
+	struct mutex aux_ts_lock;
+
 	void __iomem *mmcaddr;
 	void __iomem *ptpaddr;
 	unsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 84c075422e66..62fab49ca930 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -4363,6 +4363,8 @@ static void stmmac_common_interrupt(struct stmmac_priv *priv)
 			else
 				netif_carrier_off(priv->dev);
 		}
+
+		stmmac_timestamp_interrupt(priv, priv);
 	}
 }
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c
index f9b6ebec1381..a75e5f9e1077 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.c
@@ -144,7 +144,10 @@ static int stmmac_enable(struct ptp_clock_info *ptp,
 {
 	struct stmmac_priv *priv =
 	    container_of(ptp, struct stmmac_priv, ptp_clock_ops);
+	void __iomem *ptpaddr = priv->ptpaddr;
+	void __iomem *ioaddr = priv->hw->pcsr;
 	struct stmmac_pps_cfg *cfg;
+	u32 intr_value, acr_value;
 	int ret = -EOPNOTSUPP;
 	unsigned long flags;
 
@@ -168,6 +171,37 @@ static int stmmac_enable(struct ptp_clock_info *ptp,
 					     priv->systime_flags);
 		spin_unlock_irqrestore(&priv->ptp_lock, flags);
 		break;
+	case PTP_CLK_REQ_EXTTS:
+		priv->plat->ext_snapshot_en = on;
+		mutex_lock(&priv->aux_ts_lock);
+		acr_value = readl(ptpaddr + PTP_ACR);
+		acr_value &= ~PTP_ACR_MASK;
+		if (on) {
+			/* Enable External snapshot trigger */
+			acr_value |= priv->plat->ext_snapshot_num;
+			acr_value |= PTP_ACR_ATSFC;
+			netdev_dbg(priv->dev, "Auxiliary Snapshot %d enabled.\n",
+				   priv->plat->ext_snapshot_num >>
+				   PTP_ACR_ATSEN_SHIFT);
+			/* Enable Timestamp Interrupt */
+			intr_value = readl(ioaddr + GMAC_INT_EN);
+			intr_value |= GMAC_INT_TSIE;
+			writel(intr_value, ioaddr + GMAC_INT_EN);
+
+		} else {
+			netdev_dbg(priv->dev, "Auxiliary Snapshot %d disabled.\n",
+				   priv->plat->ext_snapshot_num >>
+				   PTP_ACR_ATSEN_SHIFT);
+			/* Disable Timestamp Interrupt */
+			intr_value = readl(ioaddr + GMAC_INT_EN);
+			intr_value &= ~GMAC_INT_TSIE;
+			writel(intr_value, ioaddr + GMAC_INT_EN);
+		}
+		writel(acr_value, ptpaddr + PTP_ACR);
+		mutex_unlock(&priv->aux_ts_lock);
+		ret = 0;
+		break;
+
 	default:
 		break;
 	}
@@ -181,7 +215,7 @@ static struct ptp_clock_info stmmac_ptp_clock_ops = {
 	.name = "stmmac ptp",
 	.max_adj = 62500000,
 	.n_alarm = 0,
-	.n_ext_ts = 0,
+	.n_ext_ts = 0, /* will be overwritten in stmmac_ptp_register */
 	.n_per_out = 0, /* will be overwritten in stmmac_ptp_register */
 	.n_pins = 0,
 	.pps = 0,
@@ -212,8 +246,10 @@ void stmmac_ptp_register(struct stmmac_priv *priv)
 		stmmac_ptp_clock_ops.max_adj = priv->plat->ptp_max_adj;
 
 	stmmac_ptp_clock_ops.n_per_out = priv->dma_cap.pps_out_num;
+	stmmac_ptp_clock_ops.n_ext_ts = priv->dma_cap.aux_snapshot_n;
 
 	spin_lock_init(&priv->ptp_lock);
+	mutex_init(&priv->aux_ts_lock);
 	priv->ptp_clock_ops = stmmac_ptp_clock_ops;
 
 	priv->ptp_clock = ptp_clock_register(&priv->ptp_clock_ops,
@@ -239,4 +275,6 @@ void stmmac_ptp_unregister(struct stmmac_priv *priv)
 		pr_debug("Removed PTP HW clock successfully on %s\n",
 			 priv->dev->name);
 	}
+
+	mutex_destroy(&priv->aux_ts_lock);
 }
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_ptp.h
* Unmerged path include/linux/stmmac.h
