cifs: fix dfs domain referrals

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Ronnie Sahlberg <lsahlber@redhat.com>
commit 0d4873f9aa4ff8fc1d63a5755395b794d32ce046
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/0d4873f9.failed

The new mount API requires additional changes to how DFS
is handled. Additional testing of DFS uncovered problems
with domain based DFS referrals (a follow on patch addresses
DFS links) which this patch addresses.

	Signed-off-by: Ronnie Sahlberg <lsahlber@redhat.com>
	Signed-off-by: Paulo Alcantara (SUSE) <pc@cjr.nz>
	Signed-off-by: Steve French <stfrench@microsoft.com>
(cherry picked from commit 0d4873f9aa4ff8fc1d63a5755395b794d32ce046)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/cifs/cifs_dfs_ref.c
#	fs/cifs/cifsfs.c
#	fs/cifs/cifsproto.h
#	fs/cifs/connect.c
#	fs/cifs/dfs_cache.c
#	fs/cifs/fs_context.c
diff --cc fs/cifs/cifs_dfs_ref.c
index b57afa90dc46,6b1ce4efb591..000000000000
--- a/fs/cifs/cifs_dfs_ref.c
+++ b/fs/cifs/cifs_dfs_ref.c
@@@ -136,9 -133,9 +136,15 @@@ cifs_build_devname(char *nodename, cons
   * Caller is responsible for freeing returned value if it is not error.
   */
  char *cifs_compose_mount_options(const char *sb_mountdata,
++<<<<<<< HEAD
 +				   const char *fullpath,
 +				   const struct dfs_info3_param *ref,
 +				   char **devname)
++=======
+ 				 const char *fullpath,
+ 				 const struct dfs_info3_param *ref,
+ 				 char **devname)
++>>>>>>> 0d4873f9aa4f (cifs: fix dfs domain referrals)
  {
  	int rc;
  	char *name;
@@@ -278,8 -276,12 +284,12 @@@ static struct vfsmount *cifs_dfs_do_mou
  
  	convert_delimiter(devname, '/');
  
 -	/* TODO: change to call fs_context_for_mount(), fill in context directly, call fc_mount */
 -
 -	/* See afs_mntpt_do_automount in fs/afs/mntpt.c for an example */
 -
  	/* strip first '\' from fullpath */
++<<<<<<< HEAD
 +	mountdata = cifs_compose_mount_options(cifs_sb->mountdata,
++=======
+ 	mountdata = cifs_compose_mount_options(cifs_sb->ctx->mount_options,
++>>>>>>> 0d4873f9aa4f (cifs: fix dfs domain referrals)
  					       fullpath + 1, NULL, NULL);
  	if (IS_ERR(mountdata)) {
  		kfree(devname);
diff --cc fs/cifs/cifsfs.c
index e1f4772cf344,e46da536ed33..000000000000
--- a/fs/cifs/cifsfs.c
+++ b/fs/cifs/cifsfs.c
@@@ -819,22 -808,33 +819,26 @@@ cifs_smb3_do_mount(struct file_system_t
  	cifs_sb = kzalloc(sizeof(struct cifs_sb_info), GFP_KERNEL);
  	if (cifs_sb == NULL) {
  		root = ERR_PTR(-ENOMEM);
 -		goto out;
 +		goto out_nls;
  	}
  
 -	cifs_sb->ctx = kzalloc(sizeof(struct smb3_fs_context), GFP_KERNEL);
 -	if (!cifs_sb->ctx) {
 +	cifs_sb->mountdata = kstrndup(data, PAGE_SIZE, GFP_KERNEL);
 +	if (cifs_sb->mountdata == NULL) {
  		root = ERR_PTR(-ENOMEM);
 -		goto out;
 -	}
 -	rc = smb3_fs_context_dup(cifs_sb->ctx, old_ctx);
 -	if (rc) {
 -		root = ERR_PTR(rc);
 -		goto out;
 +		goto out_free;
  	}
  
++<<<<<<< HEAD
 +	rc = cifs_setup_cifs_sb(ctx, cifs_sb);
++=======
+ 	rc = cifs_setup_volume_info(cifs_sb->ctx, NULL, old_ctx->UNC);
++>>>>>>> 0d4873f9aa4f (cifs: fix dfs domain referrals)
  	if (rc) {
  		root = ERR_PTR(rc);
 -		goto out;
 +		goto out_free;
  	}
  
 -	rc = cifs_setup_cifs_sb(cifs_sb);
 -	if (rc) {
 -		root = ERR_PTR(rc);
 -		goto out;
 -	}
 -
 -	rc = cifs_mount(cifs_sb, cifs_sb->ctx);
 +	rc = cifs_mount(cifs_sb, ctx);
  	if (rc) {
  		if (!(flags & SB_SILENT))
  			cifs_dbg(VFS, "cifs_mount failed w/return code = %d\n",
diff --cc fs/cifs/cifsproto.h
index aa66a6b9aaf5,32f7a013402e..000000000000
--- a/fs/cifs/cifsproto.h
+++ b/fs/cifs/cifsproto.h
@@@ -554,10 -551,7 +555,14 @@@ extern int SMBencrypt(unsigned char *pa
  			unsigned char *p24);
  
  extern int
++<<<<<<< HEAD
 +cifs_setup_volume_info(struct smb3_fs_context *ctx, char *mount_data,
 +		       const char *devname, bool is_smb3);
 +extern void
 +cifs_cleanup_volume_info_contents(struct smb3_fs_context *ctx);
++=======
+ cifs_setup_volume_info(struct smb3_fs_context *ctx, const char *mntopts, const char *devname);
++>>>>>>> 0d4873f9aa4f (cifs: fix dfs domain referrals)
  
  extern struct TCP_Server_Info *
  cifs_find_tcp_session(struct smb3_fs_context *ctx);
diff --cc fs/cifs/connect.c
index e113512460ff,10fe6d6d2dee..000000000000
--- a/fs/cifs/connect.c
+++ b/fs/cifs/connect.c
@@@ -4113,7 -2974,7 +4113,11 @@@ expand_dfs_referral(const unsigned int 
  	if (!rc) {
  		char *fake_devname = NULL;
  
++<<<<<<< HEAD
 +		mdata = cifs_compose_mount_options(cifs_sb->mountdata,
++=======
+ 		mdata = cifs_compose_mount_options(cifs_sb->ctx->mount_options,
++>>>>>>> 0d4873f9aa4f (cifs: fix dfs domain referrals)
  						   full_path + 1, &referral,
  						   &fake_devname);
  		free_dfs_info_param(&referral);
@@@ -4122,13 -2983,11 +4126,21 @@@
  			rc = PTR_ERR(mdata);
  			mdata = NULL;
  		} else {
++<<<<<<< HEAD
 +			cifs_cleanup_volume_info_contents(ctx);
 +			rc = cifs_setup_volume_info(ctx, mdata,
 +						    fake_devname, false);
 +		}
 +		kfree(fake_devname);
 +		kfree(cifs_sb->mountdata);
 +		cifs_sb->mountdata = mdata;
++=======
+ 			rc = cifs_setup_volume_info(ctx, mdata, fake_devname);
+ 		}
+ 		kfree(fake_devname);
+ 		kfree(cifs_sb->ctx->mount_options);
+ 		cifs_sb->ctx->mount_options = mdata;
++>>>>>>> 0d4873f9aa4f (cifs: fix dfs domain referrals)
  	}
  	kfree(full_path);
  	return rc;
@@@ -4178,8 -3037,9 +4190,9 @@@ static int setup_dfs_tgt_conn(const cha
  {
  	int rc;
  	struct dfs_info3_param ref = {0};
 -	char *mdata = NULL;
 +	char *mdata = NULL, *fake_devname = NULL;
  	struct smb3_fs_context fake_ctx = {NULL};
+ 	char *fake_devname = NULL;
  
  	cifs_dbg(FYI, "%s: dfs path: %s\n", __func__, path);
  
@@@ -4187,17 -3047,17 +4200,29 @@@
  	if (rc)
  		return rc;
  
++<<<<<<< HEAD
 +	mdata = cifs_compose_mount_options(cifs_sb->mountdata, full_path + 1, &ref, &fake_devname);
++=======
+ 	mdata = cifs_compose_mount_options(cifs_sb->ctx->mount_options,
+ 					   full_path + 1, &ref,
+ 					   &fake_devname);
++>>>>>>> 0d4873f9aa4f (cifs: fix dfs domain referrals)
  	free_dfs_info_param(&ref);
  
  	if (IS_ERR(mdata)) {
  		rc = PTR_ERR(mdata);
  		mdata = NULL;
++<<<<<<< HEAD
 +	} else {
 +		cifs_dbg(FYI, "%s: fake_devname: %s\n", __func__, fake_devname);
 +		rc = cifs_setup_volume_info((struct smb3_fs_context *)&fake_ctx,
 +					    mdata, fake_devname, false);
 +	}
++=======
+ 	} else
+ 		rc = cifs_setup_volume_info(&fake_ctx, mdata, fake_devname);
+ 
++>>>>>>> 0d4873f9aa4f (cifs: fix dfs domain referrals)
  	kfree(mdata);
  	kfree(fake_devname);
  
@@@ -4264,14 -3124,27 +4289,34 @@@ static int do_dfs_failover(const char *
  }
  #endif
  
 -/* TODO: all callers to this are broken. We are not parsing mount_options here
 - * we should pass a clone of the original context?
 - */
  int
++<<<<<<< HEAD
 +cifs_setup_volume_info(struct smb3_fs_context *ctx, char *mount_data,
 +			const char *devname, bool is_smb3)
 +{
 +	int rc = 0;
 +
 +	if (cifs_parse_mount_options(mount_data, devname, ctx, is_smb3))
 +		return -EINVAL;
++=======
+ cifs_setup_volume_info(struct smb3_fs_context *ctx, const char *mntopts, const char *devname)
+ {
+ 	int rc = 0;
+ 
+ 	smb3_parse_devname(devname, ctx);
+ 
+ 	if (mntopts) {
+ 		char *ip;
+ 
+ 		cifs_dbg(FYI, "%s: mntopts=%s\n", __func__, mntopts);
+ 		rc = smb3_parse_opt(mntopts, "ip", &ip);
+ 		if (!rc && !cifs_convert_address((struct sockaddr *)&ctx->dstaddr, ip,
+ 						 strlen(ip))) {
+ 			cifs_dbg(VFS, "%s: failed to convert ip address\n", __func__);
+ 			return -EINVAL;
+ 		}
+ 	}
++>>>>>>> 0d4873f9aa4f (cifs: fix dfs domain referrals)
  
  	if (ctx->nullauth) {
  		cifs_dbg(FYI, "Anonymous login\n");
diff --cc fs/cifs/dfs_cache.c
index 14029a7cec23,4950ab0486ae..000000000000
--- a/fs/cifs/dfs_cache.c
+++ b/fs/cifs/dfs_cache.c
@@@ -1452,8 -1454,7 +1452,12 @@@ static struct cifs_ses *find_root_ses(s
  		goto out;
  	}
  
++<<<<<<< HEAD
 +	rc = cifs_setup_volume_info(&ctx, mdata, devname, false);
 +	kfree(devname);
++=======
+ 	rc = cifs_setup_volume_info(&ctx, NULL, devname);
++>>>>>>> 0d4873f9aa4f (cifs: fix dfs domain referrals)
  
  	if (rc) {
  		ses = ERR_PTR(rc);
@@@ -1469,9 -1470,10 +1473,10 @@@
  	ses = cifs_get_smb_ses(server, &ctx);
  
  out:
 -	smb3_cleanup_fs_context_contents(&ctx);
 +	cifs_cleanup_volume_info_contents(&ctx);
  	kfree(mdata);
  	kfree(rpath);
+ 	kfree(devname);
  
  	return ses;
  }
diff --cc fs/cifs/fs_context.c
index d19634975a18,5111aadfdb6b..000000000000
--- a/fs/cifs/fs_context.c
+++ b/fs/cifs/fs_context.c
@@@ -259,6 -330,108 +259,111 @@@ smb3_fs_context_dup(struct smb3_fs_cont
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ cifs_parse_smb_version(char *value, struct smb3_fs_context *ctx, bool is_smb3)
+ {
+ 	substring_t args[MAX_OPT_ARGS];
+ 
+ 	switch (match_token(value, cifs_smb_version_tokens, args)) {
+ #ifdef CONFIG_CIFS_ALLOW_INSECURE_LEGACY
+ 	case Smb_1:
+ 		if (disable_legacy_dialects) {
+ 			cifs_dbg(VFS, "mount with legacy dialect disabled\n");
+ 			return 1;
+ 		}
+ 		if (is_smb3) {
+ 			cifs_dbg(VFS, "vers=1.0 (cifs) not permitted when mounting with smb3\n");
+ 			return 1;
+ 		}
+ 		cifs_dbg(VFS, "Use of the less secure dialect vers=1.0 is not recommended unless required for access to very old servers\n");
+ 		ctx->ops = &smb1_operations;
+ 		ctx->vals = &smb1_values;
+ 		break;
+ 	case Smb_20:
+ 		if (disable_legacy_dialects) {
+ 			cifs_dbg(VFS, "mount with legacy dialect disabled\n");
+ 			return 1;
+ 		}
+ 		if (is_smb3) {
+ 			cifs_dbg(VFS, "vers=2.0 not permitted when mounting with smb3\n");
+ 			return 1;
+ 		}
+ 		ctx->ops = &smb20_operations;
+ 		ctx->vals = &smb20_values;
+ 		break;
+ #else
+ 	case Smb_1:
+ 		cifs_dbg(VFS, "vers=1.0 (cifs) mount not permitted when legacy dialects disabled\n");
+ 		return 1;
+ 	case Smb_20:
+ 		cifs_dbg(VFS, "vers=2.0 mount not permitted when legacy dialects disabled\n");
+ 		return 1;
+ #endif /* CIFS_ALLOW_INSECURE_LEGACY */
+ 	case Smb_21:
+ 		ctx->ops = &smb21_operations;
+ 		ctx->vals = &smb21_values;
+ 		break;
+ 	case Smb_30:
+ 		ctx->ops = &smb30_operations;
+ 		ctx->vals = &smb30_values;
+ 		break;
+ 	case Smb_302:
+ 		ctx->ops = &smb30_operations; /* currently identical with 3.0 */
+ 		ctx->vals = &smb302_values;
+ 		break;
+ 	case Smb_311:
+ 		ctx->ops = &smb311_operations;
+ 		ctx->vals = &smb311_values;
+ 		break;
+ 	case Smb_3any:
+ 		ctx->ops = &smb30_operations; /* currently identical with 3.0 */
+ 		ctx->vals = &smb3any_values;
+ 		break;
+ 	case Smb_default:
+ 		ctx->ops = &smb30_operations; /* currently identical with 3.0 */
+ 		ctx->vals = &smbdefault_values;
+ 		break;
+ 	default:
+ 		cifs_dbg(VFS, "Unknown vers= option specified: %s\n", value);
+ 		return 1;
+ 	}
+ 	return 0;
+ }
+ 
+ int smb3_parse_opt(const char *options, const char *key, char **val)
+ {
+ 	int rc = -ENOENT;
+ 	char *opts, *orig, *p;
+ 
+ 	orig = opts = kstrdup(options, GFP_KERNEL);
+ 	if (!opts)
+ 		return -ENOMEM;
+ 
+ 	while ((p = strsep(&opts, ","))) {
+ 		char *nval;
+ 
+ 		if (!*p)
+ 			continue;
+ 		if (strncasecmp(p, key, strlen(key)))
+ 			continue;
+ 		nval = strchr(p, '=');
+ 		if (nval) {
+ 			if (nval == p)
+ 				continue;
+ 			*nval++ = 0;
+ 			*val = kstrndup(nval, strlen(nval), GFP_KERNEL);
+ 			rc = !*val ? -ENOMEM : 0;
+ 			goto out;
+ 		}
+ 	}
+ out:
+ 	kfree(orig);
+ 	return rc;
+ }
+ 
++>>>>>>> 0d4873f9aa4f (cifs: fix dfs domain referrals)
  /*
   * Parse a devname into substrings and populate the ctx->UNC and ctx->prepath
   * fields with the result. Returns 0 on success and an error otherwise
* Unmerged path fs/cifs/cifs_dfs_ref.c
* Unmerged path fs/cifs/cifsfs.c
* Unmerged path fs/cifs/cifsproto.h
* Unmerged path fs/cifs/connect.c
* Unmerged path fs/cifs/dfs_cache.c
* Unmerged path fs/cifs/fs_context.c
