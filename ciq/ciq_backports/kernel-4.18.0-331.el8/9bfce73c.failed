udp: check encap socket in __udp_lib_err

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-331.el8
commit-author Vadim Fedorenko <vfedorenko@novek.ru>
commit 9bfce73c8921c92a9565562e6e7d458d37b7ce80
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-331.el8/9bfce73c.failed

Commit d26796ae5894 ("udp: check udp sock encap_type in __udp_lib_err")
added checks for encapsulated sockets but it broke cases when there is
no implementation of encap_err_lookup for encapsulation, i.e. ESP in
UDP encapsulation. Fix it by calling encap_err_lookup only if socket
implements this method otherwise treat it as legal socket.

Fixes: d26796ae5894 ("udp: check udp sock encap_type in __udp_lib_err")
	Signed-off-by: Vadim Fedorenko <vfedorenko@novek.ru>
	Reviewed-by: Xin Long <lucien.xin@gmail.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9bfce73c8921c92a9565562e6e7d458d37b7ce80)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/ipv4/udp.c
#	net/ipv6/udp.c
diff --cc net/ipv4/udp.c
index 792b00229902,1a742b710e54..000000000000
--- a/net/ipv4/udp.c
+++ b/net/ipv4/udp.c
@@@ -623,18 -645,12 +623,26 @@@ static struct sock *__udp4_lib_err_enca
  					 const struct iphdr *iph,
  					 struct udphdr *uh,
  					 struct udp_table *udptable,
++<<<<<<< HEAD
 +					 struct sk_buff *skb)
++=======
+ 					 struct sock *sk,
+ 					 struct sk_buff *skb, u32 info)
++>>>>>>> 9bfce73c8921 (udp: check encap socket in __udp_lib_err)
  {
  	int (*lookup)(struct sock *sk, struct sk_buff *skb);
  	int network_offset, transport_offset;
  	struct udp_sock *up;
++<<<<<<< HEAD
 +	struct sock *sk;
++=======
++>>>>>>> 9bfce73c8921 (udp: check encap socket in __udp_lib_err)
 +
 +	sk = __udp4_lib_lookup(net, iph->daddr, uh->source,
 +			       iph->saddr, uh->dest, skb->dev->ifindex, 0,
 +			       udptable, NULL);
 +	if (!sk)
 +		return NULL;
  
  	network_offset = skb_network_offset(skb);
  	transport_offset = skb_transport_offset(skb);
@@@ -645,10 -661,30 +653,37 @@@
  	/* Transport header needs to point to the UDP header */
  	skb_set_transport_header(skb, iph->ihl << 2);
  
++<<<<<<< HEAD
 +	up = udp_sk(sk);
 +	lookup = READ_ONCE(up->encap_err_lookup);
 +	if (!lookup || lookup(sk, skb))
 +		sk = NULL;
++=======
+ 	if (sk) {
+ 		up = udp_sk(sk);
+ 
+ 		lookup = READ_ONCE(up->encap_err_lookup);
+ 		if (lookup && lookup(sk, skb))
+ 			sk = NULL;
+ 
+ 		goto out;
+ 	}
+ 
+ 	sk = __udp4_lib_lookup(net, iph->daddr, uh->source,
+ 			       iph->saddr, uh->dest, skb->dev->ifindex, 0,
+ 			       udptable, NULL);
+ 	if (sk) {
+ 		up = udp_sk(sk);
+ 
+ 		lookup = READ_ONCE(up->encap_err_lookup);
+ 		if (!lookup || lookup(sk, skb))
+ 			sk = NULL;
+ 	}
+ 
+ out:
+ 	if (!sk)
+ 		sk = ERR_PTR(__udp4_lib_err_encap_no_sk(skb, info));
++>>>>>>> 9bfce73c8921 (udp: check encap socket in __udp_lib_err)
  
  	skb_set_transport_header(skb, transport_offset);
  	skb_set_network_header(skb, network_offset);
@@@ -683,15 -719,22 +718,26 @@@ int __udp4_lib_err(struct sk_buff *skb
  	sk = __udp4_lib_lookup(net, iph->daddr, uh->dest,
  			       iph->saddr, uh->source, skb->dev->ifindex,
  			       inet_sdif(skb), udptable, NULL);
+ 
  	if (!sk || udp_sk(sk)->encap_type) {
  		/* No socket for error: try tunnels before discarding */
++<<<<<<< HEAD
 +		if (static_branch_unlikely(&udp_encap_needed_key))
 +			sk = __udp4_lib_err_encap(net, iph, uh, udptable, skb);
++=======
+ 		if (static_branch_unlikely(&udp_encap_needed_key)) {
+ 			sk = __udp4_lib_err_encap(net, iph, uh, udptable, sk, skb,
+ 						  info);
+ 			if (!sk)
+ 				return 0;
+ 		} else
+ 			sk = ERR_PTR(-ENOENT);
++>>>>>>> 9bfce73c8921 (udp: check encap socket in __udp_lib_err)
  
 -		if (IS_ERR(sk)) {
 +		if (!sk) {
  			__ICMP_INC_STATS(net, ICMP_MIB_INERRORS);
 -			return PTR_ERR(sk);
 +			return -ENOENT;
  		}
 -
  		tunnel = true;
  	}
  
diff --cc net/ipv6/udp.c
index 95b045e9a4aa,c5e15e94bb00..000000000000
--- a/net/ipv6/udp.c
+++ b/net/ipv6/udp.c
@@@ -495,18 -502,14 +495,28 @@@ static struct sock *__udp6_lib_err_enca
  					 const struct ipv6hdr *hdr, int offset,
  					 struct udphdr *uh,
  					 struct udp_table *udptable,
++<<<<<<< HEAD
 +					 struct sk_buff *skb)
++=======
+ 					 struct sock *sk,
+ 					 struct sk_buff *skb,
+ 					 struct inet6_skb_parm *opt,
+ 					 u8 type, u8 code, __be32 info)
++>>>>>>> 9bfce73c8921 (udp: check encap socket in __udp_lib_err)
  {
  	int (*lookup)(struct sock *sk, struct sk_buff *skb);
  	int network_offset, transport_offset;
  	struct udp_sock *up;
++<<<<<<< HEAD
 +	struct sock *sk;
++=======
++>>>>>>> 9bfce73c8921 (udp: check encap socket in __udp_lib_err)
 +
 +	sk = __udp6_lib_lookup(net, &hdr->daddr, uh->source,
 +			       &hdr->saddr, uh->dest,
 +			       inet6_iif(skb), 0, udptable, skb);
 +	if (!sk)
 +		return NULL;
  
  	network_offset = skb_network_offset(skb);
  	transport_offset = skb_transport_offset(skb);
@@@ -517,10 -520,32 +527,39 @@@
  	/* Transport header needs to point to the UDP header */
  	skb_set_transport_header(skb, offset);
  
++<<<<<<< HEAD
 +	up = udp_sk(sk);
 +	lookup = READ_ONCE(up->encap_err_lookup);
 +	if (!lookup || lookup(sk, skb))
 +		sk = NULL;
++=======
+ 	if (sk) {
+ 		up = udp_sk(sk);
+ 
+ 		lookup = READ_ONCE(up->encap_err_lookup);
+ 		if (lookup && lookup(sk, skb))
+ 			sk = NULL;
+ 
+ 		goto out;
+ 	}
+ 
+ 	sk = __udp6_lib_lookup(net, &hdr->daddr, uh->source,
+ 			       &hdr->saddr, uh->dest,
+ 			       inet6_iif(skb), 0, udptable, skb);
+ 	if (sk) {
+ 		up = udp_sk(sk);
+ 
+ 		lookup = READ_ONCE(up->encap_err_lookup);
+ 		if (!lookup || lookup(sk, skb))
+ 			sk = NULL;
+ 	}
+ 
+ out:
+ 	if (!sk) {
+ 		sk = ERR_PTR(__udp6_lib_err_encap_no_sk(skb, opt, type, code,
+ 							offset, info));
+ 	}
++>>>>>>> 9bfce73c8921 (udp: check encap socket in __udp_lib_err)
  
  	skb_set_transport_header(skb, transport_offset);
  	skb_set_network_header(skb, network_offset);
@@@ -548,14 -575,19 +588,23 @@@ int __udp6_lib_err(struct sk_buff *skb
  		/* No socket for error: try tunnels before discarding */
  		if (static_branch_unlikely(&udpv6_encap_needed_key)) {
  			sk = __udp6_lib_err_encap(net, hdr, offset, uh,
++<<<<<<< HEAD
 +						  udptable, skb);
 +		}
++=======
+ 						  udptable, sk, skb,
+ 						  opt, type, code, info);
+ 			if (!sk)
+ 				return 0;
+ 		} else
+ 			sk = ERR_PTR(-ENOENT);
++>>>>>>> 9bfce73c8921 (udp: check encap socket in __udp_lib_err)
  
 -		if (IS_ERR(sk)) {
 +		if (!sk) {
  			__ICMP6_INC_STATS(net, __in6_dev_get(skb->dev),
  					  ICMP6_MIB_INERRORS);
 -			return PTR_ERR(sk);
 +			return -ENOENT;
  		}
 -
  		tunnel = true;
  	}
  
* Unmerged path net/ipv4/udp.c
* Unmerged path net/ipv6/udp.c
