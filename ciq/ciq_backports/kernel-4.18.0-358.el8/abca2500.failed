arch/kunmap_atomic: consolidate duplicate code

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Ira Weiny <ira.weiny@intel.com>
commit abca2500c0c1b20c3e552f259da4c4a99db3b4d1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/abca2500.failed

Every single architecture (including !CONFIG_HIGHMEM) calls...

	pagefault_enable();
	preempt_enable();

... before returning from __kunmap_atomic().  Lift this code into the
kunmap_atomic() macro.

While we are at it rename __kunmap_atomic() to kunmap_atomic_high() to
be consistent.

[ira.weiny@intel.com: don't enable pagefault/preempt twice]
  Link: http://lkml.kernel.org/r/20200518184843.3029640-1-ira.weiny@intel.com
[akpm@linux-foundation.org: coding style fixes]
	Signed-off-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Christoph Hellwig <hch@lst.de>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Christian KÃ¶nig <christian.koenig@amd.com>
	Cc: Chris Zankel <chris@zankel.net>
	Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Helge Deller <deller@gmx.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: "James E.J. Bottomley" <James.Bottomley@HansenPartnership.com>
	Cc: Max Filippov <jcmvbkbc@gmail.com>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Guenter Roeck <linux@roeck-us.net>
Link: http://lkml.kernel.org/r/20200507150004.1423069-8-ira.weiny@intel.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit abca2500c0c1b20c3e552f259da4c4a99db3b4d1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arc/include/asm/highmem.h
#	arch/arm/include/asm/highmem.h
#	arch/csky/include/asm/highmem.h
#	arch/csky/mm/highmem.c
#	arch/microblaze/include/asm/highmem.h
#	arch/mips/include/asm/highmem.h
#	arch/nds32/include/asm/highmem.h
#	arch/nds32/mm/highmem.c
#	arch/powerpc/include/asm/highmem.h
#	arch/sparc/include/asm/highmem.h
#	arch/x86/include/asm/highmem.h
#	arch/xtensa/include/asm/highmem.h
#	include/linux/highmem.h
diff --cc arch/arc/include/asm/highmem.h
index b1585c96324a,70900a73bfc8..000000000000
--- a/arch/arc/include/asm/highmem.h
+++ b/arch/arc/include/asm/highmem.h
@@@ -34,12 -30,6 +34,15 @@@
  
  #include <asm/cacheflush.h>
  
++<<<<<<< HEAD
 +extern void *kmap(struct page *page);
 +extern void *kmap_high(struct page *page);
 +extern void *kmap_atomic(struct page *page);
 +extern void __kunmap_atomic(void *kvaddr);
 +extern void kunmap_high(struct page *page);
 +
++=======
++>>>>>>> abca2500c0c1 (arch/kunmap_atomic: consolidate duplicate code)
  extern void kmap_init(void);
  
  static inline void flush_cache_kmaps(void)
diff --cc arch/arm/include/asm/highmem.h
index eb4e4207cd3c,b0d4bd8dc3c1..000000000000
--- a/arch/arm/include/asm/highmem.h
+++ b/arch/arm/include/asm/highmem.h
@@@ -63,10 -60,6 +63,13 @@@ static inline void *kmap_high_get(struc
   * when CONFIG_HIGHMEM is not set.
   */
  #ifdef CONFIG_HIGHMEM
++<<<<<<< HEAD
 +extern void *kmap(struct page *page);
 +extern void kunmap(struct page *page);
 +extern void *kmap_atomic(struct page *page);
 +extern void __kunmap_atomic(void *kvaddr);
++=======
++>>>>>>> abca2500c0c1 (arch/kunmap_atomic: consolidate duplicate code)
  extern void *kmap_atomic_pfn(unsigned long pfn);
  #endif
  
diff --cc arch/microblaze/include/asm/highmem.h
index 332c78e15198,c3cbda90391d..000000000000
--- a/arch/microblaze/include/asm/highmem.h
+++ b/arch/microblaze/include/asm/highmem.h
@@@ -51,30 -51,20 +51,43 @@@ extern pte_t *pkmap_page_table
  #define PKMAP_NR(virt)  ((virt - PKMAP_BASE) >> PAGE_SHIFT)
  #define PKMAP_ADDR(nr)  (PKMAP_BASE + ((nr) << PAGE_SHIFT))
  
++<<<<<<< HEAD
 +extern void *kmap_high(struct page *page);
 +extern void kunmap_high(struct page *page);
 +extern void *kmap_atomic_prot(struct page *page, pgprot_t prot);
 +extern void __kunmap_atomic(void *kvaddr);
++=======
+ extern void *kmap_atomic_high_prot(struct page *page, pgprot_t prot);
+ static inline void *kmap_atomic_prot(struct page *page, pgprot_t prot)
+ {
+ 	preempt_disable();
+ 	pagefault_disable();
+ 	if (!PageHighMem(page))
+ 		return page_address(page);
+ 
+ 	return kmap_atomic_high_prot(page, prot);
+ }
++>>>>>>> abca2500c0c1 (arch/kunmap_atomic: consolidate duplicate code)
  
 -static inline void *kmap_atomic_high(struct page *page)
 +static inline void *kmap(struct page *page)
  {
 -	return kmap_atomic_high_prot(page, kmap_prot);
 +	might_sleep();
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	return kmap_high(page);
 +}
 +
 +static inline void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +
 +static inline void *kmap_atomic(struct page *page)
 +{
 +	return kmap_atomic_prot(page, kmap_prot);
  }
  
  #define flush_cache_kmaps()	{ flush_icache(); flush_dcache(); }
diff --cc arch/mips/include/asm/highmem.h
index 9d84aafc33d0,76dec0bd4f59..000000000000
--- a/arch/mips/include/asm/highmem.h
+++ b/arch/mips/include/asm/highmem.h
@@@ -46,13 -46,8 +46,18 @@@ extern pte_t *pkmap_page_table
  #define PKMAP_NR(virt)	((virt-PKMAP_BASE) >> PAGE_SHIFT)
  #define PKMAP_ADDR(nr)	(PKMAP_BASE + ((nr) << PAGE_SHIFT))
  
++<<<<<<< HEAD
 +extern void * kmap_high(struct page *page);
 +extern void kunmap_high(struct page *page);
 +
 +extern void *kmap(struct page *page);
 +extern void kunmap(struct page *page);
 +extern void *kmap_atomic(struct page *page);
 +extern void __kunmap_atomic(void *kvaddr);
++=======
+ #define ARCH_HAS_KMAP_FLUSH_TLB
+ extern void kmap_flush_tlb(unsigned long addr);
++>>>>>>> abca2500c0c1 (arch/kunmap_atomic: consolidate duplicate code)
  extern void *kmap_atomic_pfn(unsigned long pfn);
  
  #define flush_cache_kmaps()	BUG_ON(cpu_has_dc_aliases)
diff --cc arch/nds32/include/asm/highmem.h
index 425d546cb059,4d21308549c9..000000000000
--- a/arch/nds32/include/asm/highmem.h
+++ b/arch/nds32/include/asm/highmem.h
@@@ -54,10 -51,6 +54,13 @@@ extern void kmap_init(void)
   * when CONFIG_HIGHMEM is not set.
   */
  #ifdef CONFIG_HIGHMEM
++<<<<<<< HEAD
 +extern void *kmap(struct page *page);
 +extern void kunmap(struct page *page);
 +extern void *kmap_atomic(struct page *page);
 +extern void __kunmap_atomic(void *kvaddr);
++=======
++>>>>>>> abca2500c0c1 (arch/kunmap_atomic: consolidate duplicate code)
  extern void *kmap_atomic_pfn(unsigned long pfn);
  extern struct page *kmap_atomic_to_page(void *ptr);
  #endif
diff --cc arch/nds32/mm/highmem.c
index 022779af6148,d25c815fda21..000000000000
--- a/arch/nds32/mm/highmem.c
+++ b/arch/nds32/mm/highmem.c
@@@ -58,10 -31,9 +58,10 @@@ void *kmap_atomic(struct page *page
  	__nds32__isb();
  	return (void *)vaddr;
  }
 -EXPORT_SYMBOL(kmap_atomic_high);
 +
 +EXPORT_SYMBOL(kmap_atomic);
  
- void __kunmap_atomic(void *kvaddr)
+ void kunmap_atomic_high(void *kvaddr)
  {
  	if (kvaddr >= (void *)FIXADDR_START) {
  		unsigned long vaddr = (unsigned long)kvaddr;
@@@ -72,8 -44,5 +72,10 @@@
  		ptep = pte_offset_kernel(pmd_off_k(vaddr), vaddr);
  		set_pte(ptep, 0);
  	}
- 	pagefault_enable();
- 	preempt_enable();
  }
++<<<<<<< HEAD
 +
 +EXPORT_SYMBOL(__kunmap_atomic);
++=======
+ EXPORT_SYMBOL(kunmap_atomic_high);
++>>>>>>> abca2500c0c1 (arch/kunmap_atomic: consolidate duplicate code)
diff --cc arch/powerpc/include/asm/highmem.h
index cec820f961da,373a470df205..000000000000
--- a/arch/powerpc/include/asm/highmem.h
+++ b/arch/powerpc/include/asm/highmem.h
@@@ -59,30 -59,20 +59,43 @@@ extern pte_t *pkmap_page_table
  #define PKMAP_NR(virt)  ((virt-PKMAP_BASE) >> PAGE_SHIFT)
  #define PKMAP_ADDR(nr)  (PKMAP_BASE + ((nr) << PAGE_SHIFT))
  
++<<<<<<< HEAD
 +extern void *kmap_high(struct page *page);
 +extern void kunmap_high(struct page *page);
 +extern void *kmap_atomic_prot(struct page *page, pgprot_t prot);
 +extern void __kunmap_atomic(void *kvaddr);
++=======
+ extern void *kmap_atomic_high_prot(struct page *page, pgprot_t prot);
+ static inline void *kmap_atomic_prot(struct page *page, pgprot_t prot)
+ {
+ 	preempt_disable();
+ 	pagefault_disable();
+ 	if (!PageHighMem(page))
+ 		return page_address(page);
+ 
+ 	return kmap_atomic_high_prot(page, prot);
+ }
++>>>>>>> abca2500c0c1 (arch/kunmap_atomic: consolidate duplicate code)
  
 -static inline void *kmap_atomic_high(struct page *page)
 +static inline void *kmap(struct page *page)
  {
 -	return kmap_atomic_high_prot(page, kmap_prot);
 +	might_sleep();
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	return kmap_high(page);
 +}
 +
 +static inline void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +
 +static inline void *kmap_atomic(struct page *page)
 +{
 +	return kmap_atomic_prot(page, kmap_prot);
  }
  
  
diff --cc arch/sparc/include/asm/highmem.h
index 18d776925c45,f4babe67cb5d..000000000000
--- a/arch/sparc/include/asm/highmem.h
+++ b/arch/sparc/include/asm/highmem.h
@@@ -50,28 -50,6 +50,31 @@@ void kmap_init(void) __init
  
  #define PKMAP_END (PKMAP_ADDR(LAST_PKMAP))
  
++<<<<<<< HEAD
 +void *kmap_high(struct page *page);
 +void kunmap_high(struct page *page);
 +
 +static inline void *kmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	return kmap_high(page);
 +}
 +
 +static inline void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +
 +void *kmap_atomic(struct page *page);
 +void __kunmap_atomic(void *kvaddr);
 +
++=======
++>>>>>>> abca2500c0c1 (arch/kunmap_atomic: consolidate duplicate code)
  #define flush_cache_kmaps()	flush_cache_all()
  
  #endif /* __KERNEL__ */
diff --cc arch/x86/include/asm/highmem.h
index a8059930056d,be66b77885a0..000000000000
--- a/arch/x86/include/asm/highmem.h
+++ b/arch/x86/include/asm/highmem.h
@@@ -58,15 -58,20 +58,24 @@@ extern unsigned long highstart_pfn, hig
  #define PKMAP_NR(virt)  ((virt-PKMAP_BASE) >> PAGE_SHIFT)
  #define PKMAP_ADDR(nr)  (PKMAP_BASE + ((nr) << PAGE_SHIFT))
  
 -extern void *kmap_atomic_high_prot(struct page *page, pgprot_t prot);
 -static inline void *kmap_atomic_prot(struct page *page, pgprot_t prot)
 -{
 -	preempt_disable();
 -	pagefault_disable();
 -	if (!PageHighMem(page))
 -		return page_address(page);
 +extern void *kmap_high(struct page *page);
 +extern void kunmap_high(struct page *page);
 +
++<<<<<<< HEAD
 +void *kmap(struct page *page);
 +void kunmap(struct page *page);
  
 +void *kmap_atomic_prot(struct page *page, pgprot_t prot);
 +void *kmap_atomic(struct page *page);
 +void __kunmap_atomic(void *kvaddr);
++=======
+ 	return kmap_atomic_high_prot(page, prot);
+ }
+ static inline void *kmap_atomic_high(struct page *page)
+ {
+ 	return kmap_atomic_high_prot(page, kmap_prot);
+ }
++>>>>>>> abca2500c0c1 (arch/kunmap_atomic: consolidate duplicate code)
  void *kmap_atomic_pfn(unsigned long pfn);
  void *kmap_atomic_prot_pfn(unsigned long pfn, pgprot_t prot);
  
diff --cc arch/xtensa/include/asm/highmem.h
index 04e9340eac4b,d6a10704307a..000000000000
--- a/arch/xtensa/include/asm/highmem.h
+++ b/arch/xtensa/include/asm/highmem.h
@@@ -92,9 -68,6 +92,12 @@@ static inline void flush_cache_kmaps(vo
  	flush_cache_all();
  }
  
++<<<<<<< HEAD
 +void *kmap_atomic(struct page *page);
 +void __kunmap_atomic(void *kvaddr);
 +
++=======
++>>>>>>> abca2500c0c1 (arch/kunmap_atomic: consolidate duplicate code)
  void kmap_init(void);
  
  #endif
diff --cc include/linux/highmem.h
index ea5cdbd8c2c3,945b58d8a57b..000000000000
--- a/include/linux/highmem.h
+++ b/include/linux/highmem.h
@@@ -32,8 -32,60 +32,13 @@@ static inline void invalidate_kernel_vm
  #include <asm/kmap_types.h>
  
  #ifdef CONFIG_HIGHMEM
++<<<<<<< HEAD
++=======
+ extern void *kmap_atomic_high(struct page *page);
+ extern void kunmap_atomic_high(void *kvaddr);
++>>>>>>> abca2500c0c1 (arch/kunmap_atomic: consolidate duplicate code)
  #include <asm/highmem.h>
  
 -#ifndef ARCH_HAS_KMAP_FLUSH_TLB
 -static inline void kmap_flush_tlb(unsigned long addr) { }
 -#endif
 -
 -void *kmap_high(struct page *page);
 -static inline void *kmap(struct page *page)
 -{
 -	void *addr;
 -
 -	might_sleep();
 -	if (!PageHighMem(page))
 -		addr = page_address(page);
 -	else
 -		addr = kmap_high(page);
 -	kmap_flush_tlb((unsigned long)addr);
 -	return addr;
 -}
 -
 -void kunmap_high(struct page *page);
 -
 -static inline void kunmap(struct page *page)
 -{
 -	might_sleep();
 -	if (!PageHighMem(page))
 -		return;
 -	kunmap_high(page);
 -}
 -
 -/*
 - * kmap_atomic/kunmap_atomic is significantly faster than kmap/kunmap because
 - * no global lock is needed and because the kmap code must perform a global TLB
 - * invalidation when the kmap pool wraps.
 - *
 - * However when holding an atomic kmap is is not legal to sleep, so atomic
 - * kmaps are appropriate for short, tight code paths only.
 - *
 - * The use of kmap_atomic/kunmap_atomic is discouraged - kmap/kunmap
 - * gives a more generic (and caching) interface. But kmap_atomic can
 - * be used in IRQ contexts, so in some (very limited) cases we need
 - * it.
 - */
 -static inline void *kmap_atomic(struct page *page)
 -{
 -	preempt_disable();
 -	pagefault_disable();
 -	if (!PageHighMem(page))
 -		return page_address(page);
 -	return kmap_atomic_high(page);
 -}
 -
  /* declarations for linux/mm/highmem.c */
  unsigned int nr_free_highpages(void);
  extern atomic_long_t _totalhigh_pages;
* Unmerged path arch/csky/include/asm/highmem.h
* Unmerged path arch/csky/mm/highmem.c
* Unmerged path arch/arc/include/asm/highmem.h
diff --git a/arch/arc/mm/highmem.c b/arch/arc/mm/highmem.c
index 48e700151810..34ff5545dc4e 100644
--- a/arch/arc/mm/highmem.c
+++ b/arch/arc/mm/highmem.c
@@ -84,7 +84,7 @@ void *kmap_atomic(struct page *page)
 }
 EXPORT_SYMBOL(kmap_atomic);
 
-void __kunmap_atomic(void *kv)
+void kunmap_atomic_high(void *kv)
 {
 	unsigned long kvaddr = (unsigned long)kv;
 
@@ -106,11 +106,8 @@ void __kunmap_atomic(void *kv)
 
 		kmap_atomic_idx_pop();
 	}
-
-	pagefault_enable();
-	preempt_enable();
 }
-EXPORT_SYMBOL(__kunmap_atomic);
+EXPORT_SYMBOL(kunmap_atomic_high);
 
 static noinline pte_t * __init alloc_kmap_pgtable(unsigned long kvaddr)
 {
* Unmerged path arch/arm/include/asm/highmem.h
diff --git a/arch/arm/mm/highmem.c b/arch/arm/mm/highmem.c
index d02f8187b1cc..b6a3c3a216ef 100644
--- a/arch/arm/mm/highmem.c
+++ b/arch/arm/mm/highmem.c
@@ -99,7 +99,7 @@ void *kmap_atomic(struct page *page)
 }
 EXPORT_SYMBOL(kmap_atomic);
 
-void __kunmap_atomic(void *kvaddr)
+void kunmap_atomic_high(void *kvaddr)
 {
 	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
 	int idx, type;
@@ -121,10 +121,8 @@ void __kunmap_atomic(void *kvaddr)
 		/* this address was obtained through kmap_high_get() */
 		kunmap_high(pte_page(pkmap_page_table[PKMAP_NR(vaddr)]));
 	}
-	pagefault_enable();
-	preempt_enable();
 }
-EXPORT_SYMBOL(__kunmap_atomic);
+EXPORT_SYMBOL(kunmap_atomic_high);
 
 void *kmap_atomic_pfn(unsigned long pfn)
 {
* Unmerged path arch/csky/include/asm/highmem.h
* Unmerged path arch/csky/mm/highmem.c
* Unmerged path arch/microblaze/include/asm/highmem.h
diff --git a/arch/microblaze/mm/highmem.c b/arch/microblaze/mm/highmem.c
index d7569f77fa15..94120a7687f9 100644
--- a/arch/microblaze/mm/highmem.c
+++ b/arch/microblaze/mm/highmem.c
@@ -57,17 +57,14 @@ void *kmap_atomic_prot(struct page *page, pgprot_t prot)
 }
 EXPORT_SYMBOL(kmap_atomic_prot);
 
-void __kunmap_atomic(void *kvaddr)
+void kunmap_atomic_high(void *kvaddr)
 {
 	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
 	int type;
 	unsigned int idx;
 
-	if (vaddr < __fix_to_virt(FIX_KMAP_END)) {
-		pagefault_enable();
-		preempt_enable();
+	if (vaddr < __fix_to_virt(FIX_KMAP_END))
 		return;
-	}
 
 	type = kmap_atomic_idx();
 
@@ -83,7 +80,5 @@ void __kunmap_atomic(void *kvaddr)
 	local_flush_tlb_page(NULL, vaddr);
 
 	kmap_atomic_idx_pop();
-	pagefault_enable();
-	preempt_enable();
 }
-EXPORT_SYMBOL(__kunmap_atomic);
+EXPORT_SYMBOL(kunmap_atomic_high);
* Unmerged path arch/mips/include/asm/highmem.h
diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c
index 84d6847a403b..c7d32a32ecaf 100644
--- a/arch/mips/mm/cache.c
+++ b/arch/mips/mm/cache.c
@@ -107,7 +107,7 @@ void __flush_dcache_page(struct page *page)
 	flush_data_cache_page(addr);
 
 	if (PageHighMem(page))
-		__kunmap_atomic((void *)addr);
+		kunmap_atomic((void *)addr);
 }
 
 EXPORT_SYMBOL(__flush_dcache_page);
@@ -150,7 +150,7 @@ void __update_cache(unsigned long address, pte_t pte)
 			flush_data_cache_page(addr);
 
 		if (PageHighMem(page))
-			__kunmap_atomic((void *)addr);
+			kunmap_atomic((void *)addr);
 
 		ClearPageDcacheDirty(page);
 	}
diff --git a/arch/mips/mm/highmem.c b/arch/mips/mm/highmem.c
index d08e6d7d533b..91c1c509d21f 100644
--- a/arch/mips/mm/highmem.c
+++ b/arch/mips/mm/highmem.c
@@ -67,16 +67,13 @@ void *kmap_atomic(struct page *page)
 }
 EXPORT_SYMBOL(kmap_atomic);
 
-void __kunmap_atomic(void *kvaddr)
+void kunmap_atomic_high(void *kvaddr)
 {
 	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
 	int type __maybe_unused;
 
-	if (vaddr < FIXADDR_START) { // FIXME
-		pagefault_enable();
-		preempt_enable();
+	if (vaddr < FIXADDR_START)
 		return;
-	}
 
 	type = kmap_atomic_idx();
 #ifdef CONFIG_DEBUG_HIGHMEM
@@ -94,10 +91,8 @@ void __kunmap_atomic(void *kvaddr)
 	}
 #endif
 	kmap_atomic_idx_pop();
-	pagefault_enable();
-	preempt_enable();
 }
-EXPORT_SYMBOL(__kunmap_atomic);
+EXPORT_SYMBOL(kunmap_atomic_high);
 
 /*
  * This is the same as kmap_atomic() but can map memory that doesn't
* Unmerged path arch/nds32/include/asm/highmem.h
* Unmerged path arch/nds32/mm/highmem.c
diff --git a/arch/parisc/include/asm/cacheflush.h b/arch/parisc/include/asm/cacheflush.h
index 0c83644bfa5c..119c9a7681bc 100644
--- a/arch/parisc/include/asm/cacheflush.h
+++ b/arch/parisc/include/asm/cacheflush.h
@@ -122,11 +122,9 @@ static inline void *kmap_atomic(struct page *page)
 	return page_address(page);
 }
 
-static inline void __kunmap_atomic(void *addr)
+static inline void kunmap_atomic_high(void *addr)
 {
 	flush_kernel_dcache_page_addr(addr);
-	pagefault_enable();
-	preempt_enable();
 }
 
 #define kmap_atomic_prot(page, prot)	kmap_atomic(page)
* Unmerged path arch/powerpc/include/asm/highmem.h
diff --git a/arch/powerpc/mm/highmem.c b/arch/powerpc/mm/highmem.c
index 668e87d03f9e..35bda8c03f75 100644
--- a/arch/powerpc/mm/highmem.c
+++ b/arch/powerpc/mm/highmem.c
@@ -53,16 +53,13 @@ void *kmap_atomic_prot(struct page *page, pgprot_t prot)
 }
 EXPORT_SYMBOL(kmap_atomic_prot);
 
-void __kunmap_atomic(void *kvaddr)
+void kunmap_atomic_high(void *kvaddr)
 {
 	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
 	int type;
 
-	if (vaddr < __fix_to_virt(FIX_KMAP_END)) {
-		pagefault_enable();
-		preempt_enable();
+	if (vaddr < __fix_to_virt(FIX_KMAP_END))
 		return;
-	}
 
 	type = kmap_atomic_idx();
 
@@ -83,7 +80,5 @@ void __kunmap_atomic(void *kvaddr)
 #endif
 
 	kmap_atomic_idx_pop();
-	pagefault_enable();
-	preempt_enable();
 }
-EXPORT_SYMBOL(__kunmap_atomic);
+EXPORT_SYMBOL(kunmap_atomic_high);
* Unmerged path arch/sparc/include/asm/highmem.h
diff --git a/arch/sparc/mm/highmem.c b/arch/sparc/mm/highmem.c
index 86bc2a58d26c..fc64d379daef 100644
--- a/arch/sparc/mm/highmem.c
+++ b/arch/sparc/mm/highmem.c
@@ -85,16 +85,13 @@ void *kmap_atomic(struct page *page)
 }
 EXPORT_SYMBOL(kmap_atomic);
 
-void __kunmap_atomic(void *kvaddr)
+void kunmap_atomic_high(void *kvaddr)
 {
 	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
 	int type;
 
-	if (vaddr < FIXADDR_START) { // FIXME
-		pagefault_enable();
-		preempt_enable();
+	if (vaddr < FIXADDR_START)
 		return;
-	}
 
 	type = kmap_atomic_idx();
 
@@ -127,7 +124,5 @@ void __kunmap_atomic(void *kvaddr)
 #endif
 
 	kmap_atomic_idx_pop();
-	pagefault_enable();
-	preempt_enable();
 }
-EXPORT_SYMBOL(__kunmap_atomic);
+EXPORT_SYMBOL(kunmap_atomic_high);
* Unmerged path arch/x86/include/asm/highmem.h
diff --git a/arch/x86/mm/highmem_32.c b/arch/x86/mm/highmem_32.c
index 0d4bdcb84da5..af5a46b922e9 100644
--- a/arch/x86/mm/highmem_32.c
+++ b/arch/x86/mm/highmem_32.c
@@ -68,7 +68,7 @@ void *kmap_atomic_pfn(unsigned long pfn)
 }
 EXPORT_SYMBOL_GPL(kmap_atomic_pfn);
 
-void __kunmap_atomic(void *kvaddr)
+void kunmap_atomic_high(void *kvaddr)
 {
 	unsigned long vaddr = (unsigned long) kvaddr & PAGE_MASK;
 
@@ -98,11 +98,8 @@ void __kunmap_atomic(void *kvaddr)
 		BUG_ON(vaddr >= (unsigned long)high_memory);
 	}
 #endif
-
-	pagefault_enable();
-	preempt_enable();
 }
-EXPORT_SYMBOL(__kunmap_atomic);
+EXPORT_SYMBOL(kunmap_atomic_high);
 
 void __init set_highmem_pages_init(void)
 {
* Unmerged path arch/xtensa/include/asm/highmem.h
diff --git a/arch/xtensa/mm/highmem.c b/arch/xtensa/mm/highmem.c
index 184ceadccc1a..21af6b59ae01 100644
--- a/arch/xtensa/mm/highmem.c
+++ b/arch/xtensa/mm/highmem.c
@@ -59,7 +59,7 @@ void *kmap_atomic(struct page *page)
 }
 EXPORT_SYMBOL(kmap_atomic);
 
-void __kunmap_atomic(void *kvaddr)
+void kunmap_atomic_high(void *kvaddr)
 {
 	if (kvaddr >= (void *)FIXADDR_START &&
 	    kvaddr < (void *)FIXADDR_TOP) {
@@ -78,11 +78,8 @@ void __kunmap_atomic(void *kvaddr)
 
 		kmap_atomic_idx_pop();
 	}
-
-	pagefault_enable();
-	preempt_enable();
 }
-EXPORT_SYMBOL(__kunmap_atomic);
+EXPORT_SYMBOL(kunmap_atomic_high);
 
 void __init kmap_init(void)
 {
* Unmerged path include/linux/highmem.h
