printk: use atomic64_t for devkmsg_user.seq

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author John Ogness <john.ogness@linutronix.de>
commit 35b2b1634849ac19b2dd28cae6c97b64c4299830
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/35b2b163.failed

@user->seq is indirectly protected by @logbuf_lock. Once @logbuf_lock
is removed, @user->seq will be no longer safe from an atomicity point
of view.

In preparation for the removal of @logbuf_lock, change it to
atomic64_t to provide this safety.

	Signed-off-by: John Ogness <john.ogness@linutronix.de>
	Reviewed-by: Petr Mladek <pmladek@suse.com>
	Signed-off-by: Petr Mladek <pmladek@suse.com>
Link: https://lore.kernel.org/r/20210303101528.29901-10-john.ogness@linutronix.de
(cherry picked from commit 35b2b1634849ac19b2dd28cae6c97b64c4299830)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/printk/printk.c
diff --cc kernel/printk/printk.c
index 9c33249065a6,65e216ca6ca6..000000000000
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@@ -794,8 -662,7 +794,12 @@@ static ssize_t msg_print_ext_body(char 
  
  /* /dev/kmsg - userspace message inject/listen interface */
  struct devkmsg_user {
++<<<<<<< HEAD
 +	u64 seq;
 +	u32 idx;
++=======
+ 	atomic64_t seq;
++>>>>>>> 35b2b1634849 (printk: use atomic64_t for devkmsg_user.seq)
  	struct ratelimit_state rs;
  	struct mutex lock;
  	char buf[CONSOLE_EXT_LOG_MAX];
@@@ -892,7 -763,7 +896,11 @@@ static ssize_t devkmsg_read(struct fil
  		return ret;
  
  	logbuf_lock_irq();
++<<<<<<< HEAD
 +	while (user->seq == log_next_seq) {
++=======
+ 	if (!prb_read_valid(prb, atomic64_read(&user->seq), r)) {
++>>>>>>> 35b2b1634849 (printk: use atomic64_t for devkmsg_user.seq)
  		if (file->f_flags & O_NONBLOCK) {
  			ret = -EAGAIN;
  			logbuf_unlock_irq();
@@@ -901,30 -772,26 +909,44 @@@
  
  		logbuf_unlock_irq();
  		ret = wait_event_interruptible(log_wait,
++<<<<<<< HEAD
 +					       user->seq != log_next_seq);
++=======
+ 				prb_read_valid(prb, atomic64_read(&user->seq), r));
++>>>>>>> 35b2b1634849 (printk: use atomic64_t for devkmsg_user.seq)
  		if (ret)
  			goto out;
  		logbuf_lock_irq();
  	}
  
++<<<<<<< HEAD
 +	if (user->seq < log_first_seq) {
 +		/* our last seen message is gone, return error and reset */
 +		user->idx = log_first_idx;
 +		user->seq = log_first_seq;
++=======
+ 	if (r->info->seq != atomic64_read(&user->seq)) {
+ 		/* our last seen message is gone, return error and reset */
+ 		atomic64_set(&user->seq, r->info->seq);
++>>>>>>> 35b2b1634849 (printk: use atomic64_t for devkmsg_user.seq)
  		ret = -EPIPE;
  		logbuf_unlock_irq();
  		goto out;
  	}
  
 -	len = info_print_ext_header(user->buf, sizeof(user->buf), r->info);
 +	msg = log_from_idx(user->idx);
 +	len = msg_print_ext_header(user->buf, sizeof(user->buf),
 +				   msg, user->seq);
  	len += msg_print_ext_body(user->buf + len, sizeof(user->buf) - len,
 -				  &r->text_buf[0], r->info->text_len,
 -				  &r->info->dev_info);
 +				  log_dict(msg), msg->dict_len,
 +				  log_text(msg), msg->text_len);
  
++<<<<<<< HEAD
 +	user->idx = log_next(user->idx);
 +	user->seq++;
++=======
+ 	atomic64_set(&user->seq, r->info->seq + 1);
++>>>>>>> 35b2b1634849 (printk: use atomic64_t for devkmsg_user.seq)
  	logbuf_unlock_irq();
  
  	if (len > count) {
@@@ -956,8 -831,7 +978,12 @@@ static loff_t devkmsg_llseek(struct fil
  	switch (whence) {
  	case SEEK_SET:
  		/* the first record */
++<<<<<<< HEAD
 +		user->idx = log_first_idx;
 +		user->seq = log_first_seq;
++=======
+ 		atomic64_set(&user->seq, prb_first_valid_seq(prb));
++>>>>>>> 35b2b1634849 (printk: use atomic64_t for devkmsg_user.seq)
  		break;
  	case SEEK_DATA:
  		/*
@@@ -965,13 -839,11 +991,21 @@@
  		 * like issued by 'dmesg -c'. Reading /dev/kmsg itself
  		 * changes no global state, and does not clear anything.
  		 */
++<<<<<<< HEAD
 +		user->idx = clear_idx;
 +		user->seq = clear_seq;
 +		break;
 +	case SEEK_END:
 +		/* after the last record */
 +		user->idx = log_next_idx;
 +		user->seq = log_next_seq;
++=======
+ 		atomic64_set(&user->seq, latched_seq_read_nolock(&clear_seq));
+ 		break;
+ 	case SEEK_END:
+ 		/* after the last record */
+ 		atomic64_set(&user->seq, prb_next_seq(prb));
++>>>>>>> 35b2b1634849 (printk: use atomic64_t for devkmsg_user.seq)
  		break;
  	default:
  		ret = -EINVAL;
@@@ -991,9 -864,9 +1025,15 @@@ static __poll_t devkmsg_poll(struct fil
  	poll_wait(file, &log_wait, wait);
  
  	logbuf_lock_irq();
++<<<<<<< HEAD
 +	if (user->seq < log_next_seq) {
 +		/* return error when data has vanished underneath us */
 +		if (user->seq < log_first_seq)
++=======
+ 	if (prb_read_valid_info(prb, atomic64_read(&user->seq), &info, NULL)) {
+ 		/* return error when data has vanished underneath us */
+ 		if (info.seq != atomic64_read(&user->seq))
++>>>>>>> 35b2b1634849 (printk: use atomic64_t for devkmsg_user.seq)
  			ret = EPOLLIN|EPOLLRDNORM|EPOLLERR|EPOLLPRI;
  		else
  			ret = EPOLLIN|EPOLLRDNORM;
@@@ -1028,9 -901,11 +1068,13 @@@ static int devkmsg_open(struct inode *i
  
  	mutex_init(&user->lock);
  
 -	prb_rec_init_rd(&user->record, &user->info,
 -			&user->text_buf[0], sizeof(user->text_buf));
 -
  	logbuf_lock_irq();
++<<<<<<< HEAD
 +	user->idx = log_first_idx;
 +	user->seq = log_first_seq;
++=======
+ 	atomic64_set(&user->seq, prb_first_valid_seq(prb));
++>>>>>>> 35b2b1634849 (printk: use atomic64_t for devkmsg_user.seq)
  	logbuf_unlock_irq();
  
  	file->private_data = user;
* Unmerged path kernel/printk/printk.c
