Bluetooth: Change MGMT security info CMD to be more generic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Daniel Winkler <danielwinkler@google.com>
commit 4d9b952857533b61c662d59dc413094b0c4c8231
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/4d9b9528.failed

For advertising, we wish to know the LE tx power capabilities of the
controller in userspace, so this patch edits the Security Info MGMT
command to be more generic, such that other various controller
capabilities can be included in the EIR data. This change also includes
the LE min and max tx power into this newly-named command.

The change was tested by manually verifying that the MGMT command
returns the tx power range as expected in userspace.

	Reviewed-by: Sonny Sasaka <sonnysasaka@chromium.org>
	Signed-off-by: Daniel Winkler <danielwinkler@google.com>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
(cherry picked from commit 4d9b952857533b61c662d59dc413094b0c4c8231)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/bluetooth/mgmt.h
#	net/bluetooth/mgmt.c
diff --cc include/net/bluetooth/mgmt.h
index 5b34e2732311,f9a6638e20b3..000000000000
--- a/include/net/bluetooth/mgmt.h
+++ b/include/net/bluetooth/mgmt.h
@@@ -676,6 -684,143 +676,146 @@@ struct mgmt_cp_set_blocked_keys 
  } __packed;
  #define MGMT_OP_SET_BLOCKED_KEYS_SIZE 2
  
++<<<<<<< HEAD
++=======
+ #define MGMT_OP_SET_WIDEBAND_SPEECH	0x0047
+ 
+ #define MGMT_CAP_SEC_FLAGS		0x01
+ #define MGMT_CAP_MAX_ENC_KEY_SIZE	0x02
+ #define MGMT_CAP_SMP_MAX_ENC_KEY_SIZE	0x03
+ #define MGMT_CAP_LE_TX_PWR		0x04
+ 
+ #define MGMT_OP_READ_CONTROLLER_CAP	0x0048
+ #define MGMT_READ_CONTROLLER_CAP_SIZE	0
+ struct mgmt_rp_read_controller_cap {
+ 	__le16   cap_len;
+ 	__u8     cap[0];
+ } __packed;
+ 
+ #define MGMT_OP_READ_EXP_FEATURES_INFO	0x0049
+ #define MGMT_READ_EXP_FEATURES_INFO_SIZE 0
+ struct mgmt_rp_read_exp_features_info {
+ 	__le16 feature_count;
+ 	struct {
+ 		__u8   uuid[16];
+ 		__le32 flags;
+ 	} features[];
+ } __packed;
+ 
+ #define MGMT_OP_SET_EXP_FEATURE		0x004a
+ struct mgmt_cp_set_exp_feature {
+ 	__u8   uuid[16];
+ 	__u8   param[];
+ } __packed;
+ #define MGMT_SET_EXP_FEATURE_SIZE	16
+ struct mgmt_rp_set_exp_feature {
+ 	__u8   uuid[16];
+ 	__le32 flags;
+ } __packed;
+ 
+ #define MGMT_OP_READ_DEF_SYSTEM_CONFIG	0x004b
+ #define MGMT_READ_DEF_SYSTEM_CONFIG_SIZE	0
+ 
+ #define MGMT_OP_SET_DEF_SYSTEM_CONFIG	0x004c
+ #define MGMT_SET_DEF_SYSTEM_CONFIG_SIZE		0
+ 
+ #define MGMT_OP_READ_DEF_RUNTIME_CONFIG	0x004d
+ #define MGMT_READ_DEF_RUNTIME_CONFIG_SIZE	0
+ 
+ #define MGMT_OP_SET_DEF_RUNTIME_CONFIG	0x004e
+ #define MGMT_SET_DEF_RUNTIME_CONFIG_SIZE	0
+ 
+ #define MGMT_OP_GET_DEVICE_FLAGS	0x004F
+ #define MGMT_GET_DEVICE_FLAGS_SIZE	7
+ struct mgmt_cp_get_device_flags {
+ 	struct mgmt_addr_info addr;
+ } __packed;
+ struct mgmt_rp_get_device_flags {
+ 	struct mgmt_addr_info addr;
+ 	__le32 supported_flags;
+ 	__le32 current_flags;
+ } __packed;
+ 
+ #define MGMT_OP_SET_DEVICE_FLAGS	0x0050
+ #define MGMT_SET_DEVICE_FLAGS_SIZE	11
+ struct mgmt_cp_set_device_flags {
+ 	struct mgmt_addr_info addr;
+ 	__le32 current_flags;
+ } __packed;
+ struct mgmt_rp_set_device_flags {
+ 	struct mgmt_addr_info addr;
+ } __packed;
+ 
+ #define MGMT_ADV_MONITOR_FEATURE_MASK_OR_PATTERNS    BIT(0)
+ 
+ #define MGMT_OP_READ_ADV_MONITOR_FEATURES	0x0051
+ #define MGMT_READ_ADV_MONITOR_FEATURES_SIZE	0
+ struct mgmt_rp_read_adv_monitor_features {
+ 	__le32 supported_features;
+ 	__le32 enabled_features;
+ 	__le16 max_num_handles;
+ 	__u8 max_num_patterns;
+ 	__le16 num_handles;
+ 	__le16 handles[];
+ }  __packed;
+ 
+ struct mgmt_adv_pattern {
+ 	__u8 ad_type;
+ 	__u8 offset;
+ 	__u8 length;
+ 	__u8 value[31];
+ } __packed;
+ 
+ #define MGMT_OP_ADD_ADV_PATTERNS_MONITOR	0x0052
+ struct mgmt_cp_add_adv_patterns_monitor {
+ 	__u8 pattern_count;
+ 	struct mgmt_adv_pattern patterns[];
+ } __packed;
+ #define MGMT_ADD_ADV_PATTERNS_MONITOR_SIZE	1
+ struct mgmt_rp_add_adv_patterns_monitor {
+ 	__le16 monitor_handle;
+ } __packed;
+ 
+ #define MGMT_OP_REMOVE_ADV_MONITOR		0x0053
+ struct mgmt_cp_remove_adv_monitor {
+ 	__le16 monitor_handle;
+ } __packed;
+ #define MGMT_REMOVE_ADV_MONITOR_SIZE		2
+ struct mgmt_rp_remove_adv_monitor {
+ 	__le16 monitor_handle;
+ } __packed;
+ 
+ #define MGMT_OP_ADD_EXT_ADV_PARAMS		0x0054
+ struct mgmt_cp_add_ext_adv_params {
+ 	__u8	instance;
+ 	__le32	flags;
+ 	__le16	duration;
+ 	__le16	timeout;
+ 	__le32	min_interval;
+ 	__le32	max_interval;
+ 	__s8	tx_power;
+ } __packed;
+ #define MGMT_ADD_EXT_ADV_PARAMS_MIN_SIZE	18
+ struct mgmt_rp_add_ext_adv_params {
+ 	__u8	instance;
+ 	__s8	tx_power;
+ 	__u8	max_adv_data_len;
+ 	__u8	max_scan_rsp_len;
+ } __packed;
+ 
+ #define MGMT_OP_ADD_EXT_ADV_DATA		0x0055
+ struct mgmt_cp_add_ext_adv_data {
+ 	__u8	instance;
+ 	__u8	adv_data_len;
+ 	__u8	scan_rsp_len;
+ 	__u8	data[];
+ } __packed;
+ #define MGMT_ADD_EXT_ADV_DATA_SIZE	3
+ struct mgmt_rp_add_ext_adv_data {
+ 	__u8	instance;
+ } __packed;
+ 
++>>>>>>> 4d9b95285753 (Bluetooth: Change MGMT security info CMD to be more generic)
  #define MGMT_EV_CMD_COMPLETE		0x0001
  struct mgmt_ev_cmd_complete {
  	__le16	opcode;
diff --cc net/bluetooth/mgmt.c
index bd9aa408640d,754489e4e065..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -108,6 -110,20 +108,23 @@@ static const u16 mgmt_commands[] = 
  	MGMT_OP_SET_APPEARANCE,
  	MGMT_OP_SET_BLOCKED_KEYS,
  	MGMT_OP_SET_WIDEBAND_SPEECH,
++<<<<<<< HEAD
++=======
+ 	MGMT_OP_READ_CONTROLLER_CAP,
+ 	MGMT_OP_READ_EXP_FEATURES_INFO,
+ 	MGMT_OP_SET_EXP_FEATURE,
+ 	MGMT_OP_READ_DEF_SYSTEM_CONFIG,
+ 	MGMT_OP_SET_DEF_SYSTEM_CONFIG,
+ 	MGMT_OP_READ_DEF_RUNTIME_CONFIG,
+ 	MGMT_OP_SET_DEF_RUNTIME_CONFIG,
+ 	MGMT_OP_GET_DEVICE_FLAGS,
+ 	MGMT_OP_SET_DEVICE_FLAGS,
+ 	MGMT_OP_READ_ADV_MONITOR_FEATURES,
+ 	MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
+ 	MGMT_OP_REMOVE_ADV_MONITOR,
+ 	MGMT_OP_ADD_EXT_ADV_PARAMS,
+ 	MGMT_OP_ADD_EXT_ADV_DATA,
++>>>>>>> 4d9b95285753 (Bluetooth: Change MGMT security info CMD to be more generic)
  };
  
  static const u16 mgmt_events[] = {
@@@ -156,6 -176,10 +173,13 @@@ static const u16 mgmt_untrusted_command
  	MGMT_OP_READ_CONFIG_INFO,
  	MGMT_OP_READ_EXT_INDEX_LIST,
  	MGMT_OP_READ_EXT_INFO,
++<<<<<<< HEAD
++=======
+ 	MGMT_OP_READ_CONTROLLER_CAP,
+ 	MGMT_OP_READ_EXP_FEATURES_INFO,
+ 	MGMT_OP_READ_DEF_SYSTEM_CONFIG,
+ 	MGMT_OP_READ_DEF_RUNTIME_CONFIG,
++>>>>>>> 4d9b95285753 (Bluetooth: Change MGMT security info CMD to be more generic)
  };
  
  static const u16 mgmt_untrusted_events[] = {
@@@ -3630,31 -3710,412 +3654,423 @@@ unlock
  	return err;
  }
  
++<<<<<<< HEAD
 +static int set_blocked_keys(struct sock *sk, struct hci_dev *hdev, void *data,
++=======
+ static int read_controller_cap(struct sock *sk, struct hci_dev *hdev,
+ 			       void *data, u16 data_len)
+ {
+ 	char buf[20];
+ 	struct mgmt_rp_read_controller_cap *rp = (void *)buf;
+ 	u16 cap_len = 0;
+ 	u8 flags = 0;
+ 	u8 tx_power_range[2];
+ 
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	memset(&buf, 0, sizeof(buf));
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	/* When the Read Simple Pairing Options command is supported, then
+ 	 * the remote public key validation is supported.
+ 	 */
+ 	if (hdev->commands[41] & 0x08)
+ 		flags |= 0x01;	/* Remote public key validation (BR/EDR) */
+ 
+ 	flags |= 0x02;		/* Remote public key validation (LE) */
+ 
+ 	/* When the Read Encryption Key Size command is supported, then the
+ 	 * encryption key size is enforced.
+ 	 */
+ 	if (hdev->commands[20] & 0x10)
+ 		flags |= 0x04;	/* Encryption key size enforcement (BR/EDR) */
+ 
+ 	flags |= 0x08;		/* Encryption key size enforcement (LE) */
+ 
+ 	cap_len = eir_append_data(rp->cap, cap_len, MGMT_CAP_SEC_FLAGS,
+ 				  &flags, 1);
+ 
+ 	/* When the Read Simple Pairing Options command is supported, then
+ 	 * also max encryption key size information is provided.
+ 	 */
+ 	if (hdev->commands[41] & 0x08)
+ 		cap_len = eir_append_le16(rp->cap, cap_len,
+ 					  MGMT_CAP_MAX_ENC_KEY_SIZE,
+ 					  hdev->max_enc_key_size);
+ 
+ 	cap_len = eir_append_le16(rp->cap, cap_len,
+ 				  MGMT_CAP_SMP_MAX_ENC_KEY_SIZE,
+ 				  SMP_MAX_ENC_KEY_SIZE);
+ 
+ 	/* Append the min/max LE tx power parameters if we were able to fetch
+ 	 * it from the controller
+ 	 */
+ 	if (hdev->commands[38] & 0x80) {
+ 		memcpy(&tx_power_range[0], &hdev->min_le_tx_power, 1);
+ 		memcpy(&tx_power_range[1], &hdev->max_le_tx_power, 1);
+ 		cap_len = eir_append_data(rp->cap, cap_len, MGMT_CAP_LE_TX_PWR,
+ 					  tx_power_range, 2);
+ 	}
+ 
+ 	rp->cap_len = cpu_to_le16(cap_len);
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_CONTROLLER_CAP, 0,
+ 				 rp, sizeof(*rp) + cap_len);
+ }
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ /* d4992530-b9ec-469f-ab01-6c481c47da1c */
+ static const u8 debug_uuid[16] = {
+ 	0x1c, 0xda, 0x47, 0x1c, 0x48, 0x6c, 0x01, 0xab,
+ 	0x9f, 0x46, 0xec, 0xb9, 0x30, 0x25, 0x99, 0xd4,
+ };
+ #endif
+ 
+ /* 671b10b5-42c0-4696-9227-eb28d1b049d6 */
+ static const u8 simult_central_periph_uuid[16] = {
+ 	0xd6, 0x49, 0xb0, 0xd1, 0x28, 0xeb, 0x27, 0x92,
+ 	0x96, 0x46, 0xc0, 0x42, 0xb5, 0x10, 0x1b, 0x67,
+ };
+ 
+ /* 15c0a148-c273-11ea-b3de-0242ac130004 */
+ static const u8 rpa_resolution_uuid[16] = {
+ 	0x04, 0x00, 0x13, 0xac, 0x42, 0x02, 0xde, 0xb3,
+ 	0xea, 0x11, 0x73, 0xc2, 0x48, 0xa1, 0xc0, 0x15,
+ };
+ 
+ static int read_exp_features_info(struct sock *sk, struct hci_dev *hdev,
+ 				  void *data, u16 data_len)
+ {
+ 	char buf[62];	/* Enough space for 3 features */
+ 	struct mgmt_rp_read_exp_features_info *rp = (void *)buf;
+ 	u16 idx = 0;
+ 	u32 flags;
+ 
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	memset(&buf, 0, sizeof(buf));
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ 	if (!hdev) {
+ 		flags = bt_dbg_get() ? BIT(0) : 0;
+ 
+ 		memcpy(rp->features[idx].uuid, debug_uuid, 16);
+ 		rp->features[idx].flags = cpu_to_le32(flags);
+ 		idx++;
+ 	}
+ #endif
+ 
+ 	if (hdev) {
+ 		if (test_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks) &&
+ 		    (hdev->le_states[4] & 0x08) &&	/* Central */
+ 		    (hdev->le_states[4] & 0x40) &&	/* Peripheral */
+ 		    (hdev->le_states[3] & 0x10))	/* Simultaneous */
+ 			flags = BIT(0);
+ 		else
+ 			flags = 0;
+ 
+ 		memcpy(rp->features[idx].uuid, simult_central_periph_uuid, 16);
+ 		rp->features[idx].flags = cpu_to_le32(flags);
+ 		idx++;
+ 	}
+ 
+ 	if (hdev && use_ll_privacy(hdev)) {
+ 		if (hci_dev_test_flag(hdev, HCI_ENABLE_LL_PRIVACY))
+ 			flags = BIT(0) | BIT(1);
+ 		else
+ 			flags = BIT(1);
+ 
+ 		memcpy(rp->features[idx].uuid, rpa_resolution_uuid, 16);
+ 		rp->features[idx].flags = cpu_to_le32(flags);
+ 		idx++;
+ 	}
+ 
+ 	rp->feature_count = cpu_to_le16(idx);
+ 
+ 	/* After reading the experimental features information, enable
+ 	 * the events to update client on any future change.
+ 	 */
+ 	hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 	return mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
+ 				 MGMT_OP_READ_EXP_FEATURES_INFO,
+ 				 0, rp, sizeof(*rp) + (20 * idx));
+ }
+ 
+ static int exp_ll_privacy_feature_changed(bool enabled, struct hci_dev *hdev,
+ 					  struct sock *skip)
+ {
+ 	struct mgmt_ev_exp_feature_changed ev;
+ 
+ 	memset(&ev, 0, sizeof(ev));
+ 	memcpy(ev.uuid, rpa_resolution_uuid, 16);
+ 	ev.flags = cpu_to_le32((enabled ? BIT(0) : 0) | BIT(1));
+ 
+ 	return mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, hdev,
+ 				  &ev, sizeof(ev),
+ 				  HCI_MGMT_EXP_FEATURE_EVENTS, skip);
+ 
+ }
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ static int exp_debug_feature_changed(bool enabled, struct sock *skip)
+ {
+ 	struct mgmt_ev_exp_feature_changed ev;
+ 
+ 	memset(&ev, 0, sizeof(ev));
+ 	memcpy(ev.uuid, debug_uuid, 16);
+ 	ev.flags = cpu_to_le32(enabled ? BIT(0) : 0);
+ 
+ 	return mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, NULL,
+ 				  &ev, sizeof(ev),
+ 				  HCI_MGMT_EXP_FEATURE_EVENTS, skip);
+ }
+ #endif
+ 
+ static int set_exp_feature(struct sock *sk, struct hci_dev *hdev,
+ 			   void *data, u16 data_len)
+ {
+ 	struct mgmt_cp_set_exp_feature *cp = data;
+ 	struct mgmt_rp_set_exp_feature rp;
+ 
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	if (!memcmp(cp->uuid, ZERO_KEY, 16)) {
+ 		memset(rp.uuid, 0, 16);
+ 		rp.flags = cpu_to_le32(0);
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ 		if (!hdev) {
+ 			bool changed = bt_dbg_get();
+ 
+ 			bt_dbg_set(false);
+ 
+ 			if (changed)
+ 				exp_debug_feature_changed(false, sk);
+ 		}
+ #endif
+ 
+ 		if (hdev && use_ll_privacy(hdev) && !hdev_is_powered(hdev)) {
+ 			bool changed = hci_dev_test_flag(hdev,
+ 							 HCI_ENABLE_LL_PRIVACY);
+ 
+ 			hci_dev_clear_flag(hdev, HCI_ENABLE_LL_PRIVACY);
+ 
+ 			if (changed)
+ 				exp_ll_privacy_feature_changed(false, hdev, sk);
+ 		}
+ 
+ 		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 		return mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
+ 					 MGMT_OP_SET_EXP_FEATURE, 0,
+ 					 &rp, sizeof(rp));
+ 	}
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ 	if (!memcmp(cp->uuid, debug_uuid, 16)) {
+ 		bool val, changed;
+ 		int err;
+ 
+ 		/* Command requires to use the non-controller index */
+ 		if (hdev)
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_INDEX);
+ 
+ 		/* Parameters are limited to a single octet */
+ 		if (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)
+ 			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		/* Only boolean on/off is supported */
+ 		if (cp->param[0] != 0x00 && cp->param[0] != 0x01)
+ 			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		val = !!cp->param[0];
+ 		changed = val ? !bt_dbg_get() : bt_dbg_get();
+ 		bt_dbg_set(val);
+ 
+ 		memcpy(rp.uuid, debug_uuid, 16);
+ 		rp.flags = cpu_to_le32(val ? BIT(0) : 0);
+ 
+ 		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 		err = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,
+ 					MGMT_OP_SET_EXP_FEATURE, 0,
+ 					&rp, sizeof(rp));
+ 
+ 		if (changed)
+ 			exp_debug_feature_changed(val, sk);
+ 
+ 		return err;
+ 	}
+ #endif
+ 
+ 	if (!memcmp(cp->uuid, rpa_resolution_uuid, 16)) {
+ 		bool val, changed;
+ 		int err;
+ 		u32 flags;
+ 
+ 		/* Command requires to use the controller index */
+ 		if (!hdev)
+ 			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_INDEX);
+ 
+ 		/* Changes can only be made when controller is powered down */
+ 		if (hdev_is_powered(hdev))
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_NOT_POWERED);
+ 
+ 		/* Parameters are limited to a single octet */
+ 		if (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		/* Only boolean on/off is supported */
+ 		if (cp->param[0] != 0x00 && cp->param[0] != 0x01)
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		val = !!cp->param[0];
+ 
+ 		if (val) {
+ 			changed = !hci_dev_test_flag(hdev,
+ 						     HCI_ENABLE_LL_PRIVACY);
+ 			hci_dev_set_flag(hdev, HCI_ENABLE_LL_PRIVACY);
+ 			hci_dev_clear_flag(hdev, HCI_ADVERTISING);
+ 
+ 			/* Enable LL privacy + supported settings changed */
+ 			flags = BIT(0) | BIT(1);
+ 		} else {
+ 			changed = hci_dev_test_flag(hdev,
+ 						    HCI_ENABLE_LL_PRIVACY);
+ 			hci_dev_clear_flag(hdev, HCI_ENABLE_LL_PRIVACY);
+ 
+ 			/* Disable LL privacy + supported settings changed */
+ 			flags = BIT(1);
+ 		}
+ 
+ 		memcpy(rp.uuid, rpa_resolution_uuid, 16);
+ 		rp.flags = cpu_to_le32(flags);
+ 
+ 		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 		err = mgmt_cmd_complete(sk, hdev->id,
+ 					MGMT_OP_SET_EXP_FEATURE, 0,
+ 					&rp, sizeof(rp));
+ 
+ 		if (changed)
+ 			exp_ll_privacy_feature_changed(val, hdev, sk);
+ 
+ 		return err;
+ 	}
+ 
+ 	return mgmt_cmd_status(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
+ 			       MGMT_OP_SET_EXP_FEATURE,
+ 			       MGMT_STATUS_NOT_SUPPORTED);
+ }
+ 
+ #define SUPPORTED_DEVICE_FLAGS() ((1U << HCI_CONN_FLAG_MAX) - 1)
+ 
+ static int get_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
+ 			    u16 data_len)
+ {
+ 	struct mgmt_cp_get_device_flags *cp = data;
+ 	struct mgmt_rp_get_device_flags rp;
+ 	struct bdaddr_list_with_flags *br_params;
+ 	struct hci_conn_params *params;
+ 	u32 supported_flags = SUPPORTED_DEVICE_FLAGS();
+ 	u32 current_flags = 0;
+ 	u8 status = MGMT_STATUS_INVALID_PARAMS;
+ 
+ 	bt_dev_dbg(hdev, "Get device flags %pMR (type 0x%x)\n",
+ 		   &cp->addr.bdaddr, cp->addr.type);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (cp->addr.type == BDADDR_BREDR) {
+ 		br_params = hci_bdaddr_list_lookup_with_flags(&hdev->whitelist,
+ 							      &cp->addr.bdaddr,
+ 							      cp->addr.type);
+ 		if (!br_params)
+ 			goto done;
+ 
+ 		current_flags = br_params->current_flags;
+ 	} else {
+ 		params = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,
+ 						le_addr_type(cp->addr.type));
+ 
+ 		if (!params)
+ 			goto done;
+ 
+ 		current_flags = params->current_flags;
+ 	}
+ 
+ 	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+ 	rp.addr.type = cp->addr.type;
+ 	rp.supported_flags = cpu_to_le32(supported_flags);
+ 	rp.current_flags = cpu_to_le32(current_flags);
+ 
+ 	status = MGMT_STATUS_SUCCESS;
+ 
+ done:
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_DEVICE_FLAGS, status,
+ 				&rp, sizeof(rp));
+ }
+ 
+ static void device_flags_changed(struct sock *sk, struct hci_dev *hdev,
+ 				 bdaddr_t *bdaddr, u8 bdaddr_type,
+ 				 u32 supported_flags, u32 current_flags)
+ {
+ 	struct mgmt_ev_device_flags_changed ev;
+ 
+ 	bacpy(&ev.addr.bdaddr, bdaddr);
+ 	ev.addr.type = bdaddr_type;
+ 	ev.supported_flags = cpu_to_le32(supported_flags);
+ 	ev.current_flags = cpu_to_le32(current_flags);
+ 
+ 	mgmt_event(MGMT_EV_DEVICE_FLAGS_CHANGED, hdev, &ev, sizeof(ev), sk);
+ }
+ 
+ static int set_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
++>>>>>>> 4d9b95285753 (Bluetooth: Change MGMT security info CMD to be more generic)
  			    u16 len)
  {
 -	struct mgmt_cp_set_device_flags *cp = data;
 -	struct bdaddr_list_with_flags *br_params;
 -	struct hci_conn_params *params;
 -	u8 status = MGMT_STATUS_INVALID_PARAMS;
 -	u32 supported_flags = SUPPORTED_DEVICE_FLAGS();
 -	u32 current_flags = __le32_to_cpu(cp->current_flags);
 +	int err = MGMT_STATUS_SUCCESS;
 +	struct mgmt_cp_set_blocked_keys *keys = data;
 +	const u16 max_key_count = ((U16_MAX - sizeof(*keys)) /
 +				   sizeof(struct mgmt_blocked_key_info));
 +	u16 key_count, expected_len;
 +	int i;
  
 -	bt_dev_dbg(hdev, "Set device flags %pMR (type 0x%x) = 0x%x",
 -		   &cp->addr.bdaddr, cp->addr.type,
 -		   __le32_to_cpu(current_flags));
 +	BT_DBG("request for %s", hdev->name);
  
 -	if ((supported_flags | current_flags) != supported_flags) {
 -		bt_dev_warn(hdev, "Bad flag given (0x%x) vs supported (0x%0x)",
 -			    current_flags, supported_flags);
 -		goto done;
 +	key_count = __le16_to_cpu(keys->key_count);
 +	if (key_count > max_key_count) {
 +		bt_dev_err(hdev, "too big key_count value %u", key_count);
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				       MGMT_STATUS_INVALID_PARAMS);
 +	}
 +
 +	expected_len = struct_size(keys, keys, key_count);
 +	if (expected_len != len) {
 +		bt_dev_err(hdev, "expected %u bytes, got %u bytes",
 +			   expected_len, len);
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				       MGMT_STATUS_INVALID_PARAMS);
  	}
  
  	hci_dev_lock(hdev);
@@@ -7128,6 -8208,32 +7544,35 @@@ static const struct hci_mgmt_handler mg
  	{ set_blocked_keys,	   MGMT_OP_SET_BLOCKED_KEYS_SIZE,
  						HCI_MGMT_VAR_LEN },
  	{ set_wideband_speech,	   MGMT_SETTING_SIZE },
++<<<<<<< HEAD
++=======
+ 	{ read_controller_cap,     MGMT_READ_CONTROLLER_CAP_SIZE,
+ 						HCI_MGMT_UNTRUSTED },
+ 	{ read_exp_features_info,  MGMT_READ_EXP_FEATURES_INFO_SIZE,
+ 						HCI_MGMT_UNTRUSTED |
+ 						HCI_MGMT_HDEV_OPTIONAL },
+ 	{ set_exp_feature,         MGMT_SET_EXP_FEATURE_SIZE,
+ 						HCI_MGMT_VAR_LEN |
+ 						HCI_MGMT_HDEV_OPTIONAL },
+ 	{ read_def_system_config,  MGMT_READ_DEF_SYSTEM_CONFIG_SIZE,
+ 						HCI_MGMT_UNTRUSTED },
+ 	{ set_def_system_config,   MGMT_SET_DEF_SYSTEM_CONFIG_SIZE,
+ 						HCI_MGMT_VAR_LEN },
+ 	{ read_def_runtime_config, MGMT_READ_DEF_RUNTIME_CONFIG_SIZE,
+ 						HCI_MGMT_UNTRUSTED },
+ 	{ set_def_runtime_config,  MGMT_SET_DEF_RUNTIME_CONFIG_SIZE,
+ 						HCI_MGMT_VAR_LEN },
+ 	{ get_device_flags,        MGMT_GET_DEVICE_FLAGS_SIZE },
+ 	{ set_device_flags,        MGMT_SET_DEVICE_FLAGS_SIZE },
+ 	{ read_adv_mon_features,   MGMT_READ_ADV_MONITOR_FEATURES_SIZE },
+ 	{ add_adv_patterns_monitor,MGMT_ADD_ADV_PATTERNS_MONITOR_SIZE,
+ 						HCI_MGMT_VAR_LEN },
+ 	{ remove_adv_monitor,      MGMT_REMOVE_ADV_MONITOR_SIZE },
+ 	{ add_ext_adv_params,      MGMT_ADD_EXT_ADV_PARAMS_MIN_SIZE,
+ 						HCI_MGMT_VAR_LEN },
+ 	{ add_ext_adv_data,        MGMT_ADD_EXT_ADV_DATA_SIZE,
+ 						HCI_MGMT_VAR_LEN },
++>>>>>>> 4d9b95285753 (Bluetooth: Change MGMT security info CMD to be more generic)
  };
  
  void mgmt_index_added(struct hci_dev *hdev)
* Unmerged path include/net/bluetooth/mgmt.h
* Unmerged path net/bluetooth/mgmt.c
