net: bridge: mcast: account for ipv6 size when dumping querier state

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 175e66924719090f3f43884a419e7c32dabb800f
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/175e6692.failed

We need to account for the IPv6 attributes when dumping querier state.

Fixes: 5e924fe6ccfd ("net: bridge: mcast: dump ipv6 querier state")
	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 175e66924719090f3f43884a419e7c32dabb800f)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
diff --cc net/bridge/br_multicast.c
index def6f1840985,e411dd814c58..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -2095,32 -2905,119 +2095,110 @@@ update
  	return true;
  }
  
++<<<<<<< HEAD
++=======
+ static struct net_bridge_port *
+ __br_multicast_get_querier_port(struct net_bridge *br,
+ 				const struct bridge_mcast_querier *querier)
+ {
+ 	int port_ifidx = READ_ONCE(querier->port_ifidx);
+ 	struct net_bridge_port *p;
+ 	struct net_device *dev;
+ 
+ 	if (port_ifidx == 0)
+ 		return NULL;
+ 
+ 	dev = dev_get_by_index_rcu(dev_net(br->dev), port_ifidx);
+ 	if (!dev)
+ 		return NULL;
+ 	p = br_port_get_rtnl_rcu(dev);
+ 	if (!p || p->br != br)
+ 		return NULL;
+ 
+ 	return p;
+ }
+ 
+ size_t br_multicast_querier_state_size(void)
+ {
+ 	return nla_total_size(0) +		/* nest attribute */
+ 	       nla_total_size(sizeof(__be32)) + /* BRIDGE_QUERIER_IP_ADDRESS */
+ 	       nla_total_size(sizeof(int)) +    /* BRIDGE_QUERIER_IP_PORT */
+ 	       nla_total_size_64bit(sizeof(u64)) + /* BRIDGE_QUERIER_IP_OTHER_TIMER */
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	       nla_total_size(sizeof(struct in6_addr)) + /* BRIDGE_QUERIER_IPV6_ADDRESS */
+ 	       nla_total_size(sizeof(int)) +		 /* BRIDGE_QUERIER_IPV6_PORT */
+ 	       nla_total_size_64bit(sizeof(u64)) +	 /* BRIDGE_QUERIER_IPV6_OTHER_TIMER */
+ #endif
+ 	       0;
+ }
+ 
+ /* protected by rtnl or rcu */
+ int br_multicast_dump_querier_state(struct sk_buff *skb,
+ 				    const struct net_bridge_mcast *brmctx,
+ 				    int nest_attr)
+ {
+ 	struct bridge_mcast_querier querier = {};
+ 	struct net_bridge_port *p;
+ 	struct nlattr *nest;
+ 
+ 	if (!br_opt_get(brmctx->br, BROPT_MULTICAST_ENABLED) ||
+ 	    br_multicast_ctx_vlan_global_disabled(brmctx))
+ 		return 0;
+ 
+ 	nest = nla_nest_start(skb, nest_attr);
+ 	if (!nest)
+ 		return -EMSGSIZE;
+ 
+ 	rcu_read_lock();
+ 	if (!brmctx->multicast_querier &&
+ 	    !timer_pending(&brmctx->ip4_other_query.timer))
+ 		goto out_v6;
+ 
+ 	br_multicast_read_querier(&brmctx->ip4_querier, &querier);
+ 	if (nla_put_in_addr(skb, BRIDGE_QUERIER_IP_ADDRESS,
+ 			    querier.addr.src.ip4)) {
+ 		rcu_read_unlock();
+ 		goto out_err;
+ 	}
+ 
+ 	p = __br_multicast_get_querier_port(brmctx->br, &querier);
+ 	if (timer_pending(&brmctx->ip4_other_query.timer) &&
+ 	    (nla_put_u64_64bit(skb, BRIDGE_QUERIER_IP_OTHER_TIMER,
+ 			       br_timer_value(&brmctx->ip4_other_query.timer),
+ 			       BRIDGE_QUERIER_PAD) ||
+ 	     (p && nla_put_u32(skb, BRIDGE_QUERIER_IP_PORT, p->dev->ifindex)))) {
+ 		rcu_read_unlock();
+ 		goto out_err;
+ 	}
+ 
+ out_v6:
++>>>>>>> 175e66924719 (net: bridge: mcast: account for ipv6 size when dumping querier state)
  #if IS_ENABLED(CONFIG_IPV6)
 -	if (!brmctx->multicast_querier &&
 -	    !timer_pending(&brmctx->ip6_other_query.timer))
 -		goto out;
 +static bool br_ip6_multicast_select_querier(struct net_bridge *br,
 +					    struct net_bridge_port *port,
 +					    struct in6_addr *saddr)
 +{
 +	if (!timer_pending(&br->ip6_own_query.timer) &&
 +	    !timer_pending(&br->ip6_other_query.timer))
 +		goto update;
  
 -	br_multicast_read_querier(&brmctx->ip6_querier, &querier);
 -	if (nla_put_in6_addr(skb, BRIDGE_QUERIER_IPV6_ADDRESS,
 -			     &querier.addr.src.ip6)) {
 -		rcu_read_unlock();
 -		goto out_err;
 -	}
 +	if (ipv6_addr_cmp(saddr, &br->ip6_querier.addr.src.ip6) <= 0)
 +		goto update;
  
 -	p = __br_multicast_get_querier_port(brmctx->br, &querier);
 -	if (timer_pending(&brmctx->ip6_other_query.timer) &&
 -	    (nla_put_u64_64bit(skb, BRIDGE_QUERIER_IPV6_OTHER_TIMER,
 -			       br_timer_value(&brmctx->ip6_other_query.timer),
 -			       BRIDGE_QUERIER_PAD) ||
 -	     (p && nla_put_u32(skb, BRIDGE_QUERIER_IPV6_PORT,
 -			       p->dev->ifindex)))) {
 -		rcu_read_unlock();
 -		goto out_err;
 -	}
 -out:
 -#endif
 -	rcu_read_unlock();
 -	nla_nest_end(skb, nest);
 -	if (!nla_len(nest))
 -		nla_nest_cancel(skb, nest);
 +	return false;
  
 -	return 0;
 +update:
 +	br->ip6_querier.addr.src.ip6 = *saddr;
 +
 +	/* update protected by general multicast_lock by caller */
 +	rcu_assign_pointer(br->ip6_querier.port, port);
  
 -out_err:
 -	nla_nest_cancel(skb, nest);
 -	return -EMSGSIZE;
 +	return true;
  }
 +#endif
  
  static void
 -br_multicast_update_query_timer(struct net_bridge_mcast *brmctx,
 +br_multicast_update_query_timer(struct net_bridge *br,
  				struct bridge_mcast_other_query *query,
  				unsigned long max_delay)
  {
* Unmerged path net/bridge/br_multicast.c
