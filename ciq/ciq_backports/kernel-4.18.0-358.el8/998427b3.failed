mm/notifier: add migration invalidation type

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Ralph Campbell <rcampbell@nvidia.com>
commit 998427b3ad2c769082853880cf353557ec0ec77d
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/998427b3.failed

Currently migrate_vma_setup() calls mmu_notifier_invalidate_range_start()
which flushes all device private page mappings whether or not a page is
being migrated to/from device private memory.

In order to not disrupt device mappings that are not being migrated, shift
the responsibility for clearing device private mappings to the device
driver and leave CPU page table unmapping handled by
migrate_vma_setup().

To support this, the caller of migrate_vma_setup() should always set
struct migrate_vma::pgmap_owner to a non NULL value that matches the
device private page->pgmap->owner. This value is then passed to the struct
mmu_notifier_range with a new event type which the driver's invalidation
function can use to avoid device MMU invalidations.

Link: https://lore.kernel.org/r/20200723223004.9586-4-rcampbell@nvidia.com
	Signed-off-by: Ralph Campbell <rcampbell@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit 998427b3ad2c769082853880cf353557ec0ec77d)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/migrate.h
#	mm/migrate.c
diff --cc include/linux/migrate.h
index 5d26156a9fa6,540998d9810b..000000000000
--- a/include/linux/migrate.h
+++ b/include/linux/migrate.h
@@@ -178,11 -204,14 +178,19 @@@ struct migrate_vma 
  
  	/*
  	 * Set to the owner value also stored in page->pgmap->owner for
++<<<<<<< HEAD
 +	 * migrating out of device private memory.  If set only device
 +	 * private pages with this owner are migrated.  If not set
 +	 * device private pages are not migrated at all.
++=======
+ 	 * migrating out of device private memory. The flags also need to
+ 	 * be set to MIGRATE_VMA_SELECT_DEVICE_PRIVATE.
+ 	 * The caller should always set this field when using mmu notifier
+ 	 * callbacks to avoid device MMU invalidations for device private
+ 	 * pages that are not being migrated.
++>>>>>>> 998427b3ad2c (mm/notifier: add migration invalidation type)
  	 */
 -	void			*pgmap_owner;
 -	unsigned long		flags;
 +	void			*src_owner;
  };
  
  int migrate_vma_setup(struct migrate_vma *args);
diff --cc mm/migrate.c
index 6e0b070f8524,96e1f41a991e..000000000000
--- a/mm/migrate.c
+++ b/mm/migrate.c
@@@ -2448,9 -2392,14 +2448,20 @@@ static void migrate_vma_collect(struct 
  {
  	struct mmu_notifier_range range;
  
++<<<<<<< HEAD
 +	mmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, NULL,
 +				migrate->vma->vm_mm, migrate->start,
 +				migrate->end);
++=======
+ 	/*
+ 	 * Note that the pgmap_owner is passed to the mmu notifier callback so
+ 	 * that the registered device driver can skip invalidating device
+ 	 * private page mappings that won't be migrated.
+ 	 */
+ 	mmu_notifier_range_init(&range, MMU_NOTIFY_MIGRATE, 0, migrate->vma,
+ 			migrate->vma->vm_mm, migrate->start, migrate->end);
+ 	range.migrate_pgmap_owner = migrate->pgmap_owner;
++>>>>>>> 998427b3ad2c (mm/notifier: add migration invalidation type)
  	mmu_notifier_invalidate_range_start(&range);
  
  	walk_page_range(migrate->vma->vm_mm, migrate->start, migrate->end,
* Unmerged path include/linux/migrate.h
diff --git a/include/linux/mmu_notifier.h b/include/linux/mmu_notifier.h
index d924803cea7c..f8e53917fac7 100644
--- a/include/linux/mmu_notifier.h
+++ b/include/linux/mmu_notifier.h
@@ -42,6 +42,10 @@ struct mmu_notifier_ops;
  *
  * @MMU_NOTIFY_RELEASE: used during mmu_interval_notifier invalidate to signal
  * that the mm refcount is zero and the range is no longer accessible.
+ *
+ * @MMU_NOTIFY_MIGRATE: used during migrate_vma_collect() invalidate to signal
+ * a device driver to possibly ignore the invalidation if the
+ * migrate_pgmap_owner field matches the driver's device private pgmap owner.
  */
 enum mmu_notifier_event {
 	MMU_NOTIFY_UNMAP = 0,
@@ -50,6 +54,7 @@ enum mmu_notifier_event {
 	MMU_NOTIFY_PROTECTION_PAGE,
 	MMU_NOTIFY_SOFT_DIRTY,
 	MMU_NOTIFY_RELEASE,
+	MMU_NOTIFY_MIGRATE,
 };
 
 #ifdef CONFIG_LOCKDEP
@@ -303,6 +308,7 @@ struct mmu_notifier_range {
 	unsigned long end;
 	unsigned flags;
 	enum mmu_notifier_event event;
+	void *migrate_pgmap_owner;
 };
 
 static inline int mm_has_notifiers(struct mm_struct *mm)
* Unmerged path mm/migrate.c
