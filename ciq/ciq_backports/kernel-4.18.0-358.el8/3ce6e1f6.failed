loop: reintroduce global lock for safe loop_validate_file() traversal

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Tetsuo Handa <penguin-kernel@i-love.sakura.ne.jp>
commit 3ce6e1f662a910970880188ea7bfd00542bd3934
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/3ce6e1f6.failed

Commit 6cc8e7430801fa23 ("loop: scale loop device by introducing per
device lock") re-opened a race window for NULL pointer dereference at
loop_validate_file() where commit 310ca162d779efee ("block/loop: Use
global lock for ioctl() operation.") has closed.

Although we need to guarantee that other loop devices will not change
during traversal, we can't take remote "struct loop_device"->lo_mutex
inside loop_validate_file() in order to avoid AB-BA deadlock. Therefore,
introduce a global lock dedicated for loop_validate_file() which is
conditionally taken before local "struct loop_device"->lo_mutex is taken.

	Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Fixes: 6cc8e7430801fa23 ("loop: scale loop device by introducing per device lock")
	Signed-off-by: Jens Axboe <axboe@kernel.dk>
(cherry picked from commit 3ce6e1f662a910970880188ea7bfd00542bd3934)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/block/loop.c
diff --cc drivers/block/loop.c
index 397b50df6eec,f0cdff0c5fbf..000000000000
--- a/drivers/block/loop.c
+++ b/drivers/block/loop.c
@@@ -83,8 -84,51 +83,49 @@@
  
  #include <linux/uaccess.h>
  
 -#define LOOP_IDLE_WORKER_TIMEOUT (60 * HZ)
 -
  static DEFINE_IDR(loop_index_idr);
  static DEFINE_MUTEX(loop_ctl_mutex);
+ static DEFINE_MUTEX(loop_validate_mutex);
+ 
+ /**
+  * loop_global_lock_killable() - take locks for safe loop_validate_file() test
+  *
+  * @lo: struct loop_device
+  * @global: true if @lo is about to bind another "struct loop_device", false otherwise
+  *
+  * Returns 0 on success, -EINTR otherwise.
+  *
+  * Since loop_validate_file() traverses on other "struct loop_device" if
+  * is_loop_device() is true, we need a global lock for serializing concurrent
+  * loop_configure()/loop_change_fd()/__loop_clr_fd() calls.
+  */
+ static int loop_global_lock_killable(struct loop_device *lo, bool global)
+ {
+ 	int err;
+ 
+ 	if (global) {
+ 		err = mutex_lock_killable(&loop_validate_mutex);
+ 		if (err)
+ 			return err;
+ 	}
+ 	err = mutex_lock_killable(&lo->lo_mutex);
+ 	if (err && global)
+ 		mutex_unlock(&loop_validate_mutex);
+ 	return err;
+ }
+ 
+ /**
+  * loop_global_unlock() - release locks taken by loop_global_lock_killable()
+  *
+  * @lo: struct loop_device
+  * @global: true if @lo was about to bind another "struct loop_device", false otherwise
+  */
+ static void loop_global_unlock(struct loop_device *lo, bool global)
+ {
+ 	mutex_unlock(&lo->lo_mutex);
+ 	if (global)
+ 		mutex_unlock(&loop_validate_mutex);
+ }
  
  static int max_part;
  static int part_shift;
@@@ -683,13 -713,15 +724,23 @@@ static int loop_validate_file(struct fi
  	while (is_loop_device(f)) {
  		struct loop_device *l;
  
++<<<<<<< HEAD
 +		if (f->f_mapping->host->i_bdev == bdev)
 +			return -EBADF;
 +
 +		l = f->f_mapping->host->i_bdev->bd_disk->private_data;
 +		if (l->lo_state != Lo_bound) {
++=======
+ 		lockdep_assert_held(&loop_validate_mutex);
+ 		if (f->f_mapping->host->i_rdev == bdev->bd_dev)
+ 			return -EBADF;
+ 
+ 		l = I_BDEV(f->f_mapping->host)->bd_disk->private_data;
+ 		if (l->lo_state != Lo_bound)
++>>>>>>> 3ce6e1f662a9 (loop: reintroduce global lock for safe loop_validate_file() traversal)
  			return -EINVAL;
- 		}
+ 		/* Order wrt setting lo->lo_backing_file in loop_configure(). */
+ 		rmb();
  		f = l->lo_backing_file;
  	}
  	if (!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))
@@@ -751,10 -783,19 +802,19 @@@ static int loop_change_fd(struct loop_d
  	loop_update_dio(lo);
  	blk_mq_unfreeze_queue(lo->lo_queue);
  	partscan = lo->lo_flags & LO_FLAGS_PARTSCAN;
- 	mutex_unlock(&lo->lo_mutex);
+ 	loop_global_unlock(lo, is_loop);
+ 
+ 	/*
+ 	 * Flush loop_validate_file() before fput(), for l->lo_backing_file
+ 	 * might be pointing at old_file which might be the last reference.
+ 	 */
+ 	if (!is_loop) {
+ 		mutex_lock(&loop_validate_mutex);
+ 		mutex_unlock(&loop_validate_mutex);
+ 	}
  	/*
  	 * We must drop file reference outside of lo_mutex as dropping
 -	 * the file ref can take open_mutex which creates circular locking
 +	 * the file ref can take bd_mutex which creates circular locking
  	 * dependency.
  	 */
  	fput(old_file);
@@@ -1076,14 -1188,18 +1136,26 @@@ static int loop_configure(struct loop_d
  			  struct block_device *bdev,
  			  const struct loop_config *config)
  {
- 	struct file	*file;
- 	struct inode	*inode;
+ 	struct file *file = fget(config->fd);
+ 	struct inode *inode;
  	struct address_space *mapping;
++<<<<<<< HEAD
 +	struct block_device *claimed_bdev = NULL;
 +	int		error;
 +	loff_t		size;
 +	bool		partscan;
 +	unsigned short  bsize;
++=======
+ 	int error;
+ 	loff_t size;
+ 	bool partscan;
+ 	unsigned short bsize;
+ 	bool is_loop;
+ 
+ 	if (!file)
+ 		return -EBADF;
+ 	is_loop = is_loop_device(file);
++>>>>>>> 3ce6e1f662a9 (loop: reintroduce global lock for safe loop_validate_file() traversal)
  
  	/* This is safe, since we have a reference from open(). */
  	__module_get(THIS_MODULE);
@@@ -1186,21 -1308,20 +1256,20 @@@
  	 * put /dev/loopXX inode. Later in __loop_clr_fd() we bdput(bdev).
  	 */
  	bdgrab(bdev);
- 	mutex_unlock(&lo->lo_mutex);
+ 	loop_global_unlock(lo, is_loop);
  	if (partscan)
 -		loop_reread_partitions(lo);
 -	if (!(mode & FMODE_EXCL))
 -		bd_abort_claiming(bdev, loop_configure);
 +		loop_reread_partitions(lo, bdev);
 +	if (claimed_bdev)
 +		bd_abort_claiming(bdev, claimed_bdev, loop_configure);
  	return 0;
  
  out_unlock:
- 	mutex_unlock(&lo->lo_mutex);
+ 	loop_global_unlock(lo, is_loop);
  out_bdev:
 -	if (!(mode & FMODE_EXCL))
 -		bd_abort_claiming(bdev, loop_configure);
 +	if (claimed_bdev)
 +		bd_abort_claiming(bdev, claimed_bdev, loop_configure);
  out_putf:
  	fput(file);
- out:
  	/* This is safe: open() is still holding a reference. */
  	module_put(THIS_MODULE);
  	return error;
@@@ -1214,7 -1335,20 +1283,19 @@@ static int __loop_clr_fd(struct loop_de
  	int err = 0;
  	bool partscan = false;
  	int lo_number;
 -	struct loop_worker *pos, *worker;
  
+ 	/*
+ 	 * Flush loop_configure() and loop_change_fd(). It is acceptable for
+ 	 * loop_validate_file() to succeed, for actual clear operation has not
+ 	 * started yet.
+ 	 */
+ 	mutex_lock(&loop_validate_mutex);
+ 	mutex_unlock(&loop_validate_mutex);
+ 	/*
+ 	 * loop_validate_file() now fails because l->lo_state != Lo_bound
+ 	 * became visible.
+ 	 */
+ 
  	mutex_lock(&lo->lo_mutex);
  	if (WARN_ON_ONCE(lo->lo_state != Lo_rundown)) {
  		err = -ENXIO;
* Unmerged path drivers/block/loop.c
