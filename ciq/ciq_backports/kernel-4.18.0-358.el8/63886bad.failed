mm/mmu_notifier: silence PROVE_RCU_LIST warnings

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Qian Cai <cai@lca.pw>
commit 63886bad904b73f7470fd582fbc41c5ae04d6785
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/63886bad.failed

It is safe to traverse mm->notifier_subscriptions->list either under
SRCU read lock or mm->notifier_subscriptions->lock using
hlist_for_each_entry_rcu().  Silence the PROVE_RCU_LIST false positives,
for example,

  WARNING: suspicious RCU usage
  -----------------------------
  mm/mmu_notifier.c:484 RCU-list traversed in non-reader section!!

  other info that might help us debug this:

  rcu_scheduler_active = 2, debug_locks = 1
  3 locks held by libvirtd/802:
   #0: ffff9321e3f58148 (&mm->mmap_sem#2){++++}, at: do_mprotect_pkey+0xe1/0x3e0
   #1: ffffffff91ae6160 (mmu_notifier_invalidate_range_start){+.+.}, at: change_p4d_range+0x5fa/0x800
   #2: ffffffff91ae6e08 (srcu){....}, at: __mmu_notifier_invalidate_range_start+0x178/0x460

  stack backtrace:
  CPU: 7 PID: 802 Comm: libvirtd Tainted: G          I       5.6.0-rc6-next-20200317+ #2
  Hardware name: HP ProLiant BL460c Gen8, BIOS I31 11/02/2014
  Call Trace:
    dump_stack+0xa4/0xfe
    lockdep_rcu_suspicious+0xeb/0xf5
    __mmu_notifier_invalidate_range_start+0x3ff/0x460
    change_p4d_range+0x746/0x800
    change_protection+0x1df/0x300
    mprotect_fixup+0x245/0x3e0
    do_mprotect_pkey+0x23b/0x3e0
    __x64_sys_mprotect+0x51/0x70
    do_syscall_64+0x91/0xae8
    entry_SYSCALL_64_after_hwframe+0x49/0xb3

	Signed-off-by: Qian Cai <cai@lca.pw>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Reviewed-by: Paul E. McKenney <paulmck@kernel.org>
	Reviewed-by: Jason Gunthorpe <jgg@mellanox.com>
Link: http://lkml.kernel.org/r/20200317175640.2047-1-cai@lca.pw
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 63886bad904b73f7470fd582fbc41c5ae04d6785)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mmu_notifier.c
diff --cc mm/mmu_notifier.c
index 4361d699fa34,06852b896fa6..000000000000
--- a/mm/mmu_notifier.c
+++ b/mm/mmu_notifier.c
@@@ -312,7 -307,8 +312,12 @@@ static void mn_hlist_release(struct mmu
  	 * ->release returns.
  	 */
  	id = srcu_read_lock(&srcu);
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(mn, &mmn_mm->list, hlist)
++=======
+ 	hlist_for_each_entry_rcu(subscription, &subscriptions->list, hlist,
+ 				 srcu_read_lock_held(&srcu))
++>>>>>>> 63886bad904b (mm/mmu_notifier: silence PROVE_RCU_LIST warnings)
  		/*
  		 * If ->release runs before mmu_notifier_unregister it must be
  		 * handled, as it's the only way for the driver to flush all
@@@ -373,9 -370,12 +378,18 @@@ int __mmu_notifier_clear_flush_young(st
  	int young = 0, id;
  
  	id = srcu_read_lock(&srcu);
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {
 +		if (mn->ops->clear_flush_young)
 +			young |= mn->ops->clear_flush_young(mn, mm, start, end);
++=======
+ 	hlist_for_each_entry_rcu(subscription,
+ 				 &mm->notifier_subscriptions->list, hlist,
+ 				 srcu_read_lock_held(&srcu)) {
+ 		if (subscription->ops->clear_flush_young)
+ 			young |= subscription->ops->clear_flush_young(
+ 				subscription, mm, start, end);
++>>>>>>> 63886bad904b (mm/mmu_notifier: silence PROVE_RCU_LIST warnings)
  	}
  	srcu_read_unlock(&srcu, id);
  
@@@ -390,9 -390,12 +404,18 @@@ int __mmu_notifier_clear_young(struct m
  	int young = 0, id;
  
  	id = srcu_read_lock(&srcu);
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {
 +		if (mn->ops->clear_young)
 +			young |= mn->ops->clear_young(mn, mm, start, end);
++=======
+ 	hlist_for_each_entry_rcu(subscription,
+ 				 &mm->notifier_subscriptions->list, hlist,
+ 				 srcu_read_lock_held(&srcu)) {
+ 		if (subscription->ops->clear_young)
+ 			young |= subscription->ops->clear_young(subscription,
+ 								mm, start, end);
++>>>>>>> 63886bad904b (mm/mmu_notifier: silence PROVE_RCU_LIST warnings)
  	}
  	srcu_read_unlock(&srcu, id);
  
@@@ -406,9 -409,12 +429,18 @@@ int __mmu_notifier_test_young(struct mm
  	int young = 0, id;
  
  	id = srcu_read_lock(&srcu);
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {
 +		if (mn->ops->test_young) {
 +			young = mn->ops->test_young(mn, mm, address);
++=======
+ 	hlist_for_each_entry_rcu(subscription,
+ 				 &mm->notifier_subscriptions->list, hlist,
+ 				 srcu_read_lock_held(&srcu)) {
+ 		if (subscription->ops->test_young) {
+ 			young = subscription->ops->test_young(subscription, mm,
+ 							      address);
++>>>>>>> 63886bad904b (mm/mmu_notifier: silence PROVE_RCU_LIST warnings)
  			if (young)
  				break;
  		}
@@@ -425,9 -431,12 +457,18 @@@ void __mmu_notifier_change_pte(struct m
  	int id;
  
  	id = srcu_read_lock(&srcu);
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {
 +		if (mn->ops->change_pte)
 +			mn->ops->change_pte(mn, mm, address, pte);
++=======
+ 	hlist_for_each_entry_rcu(subscription,
+ 				 &mm->notifier_subscriptions->list, hlist,
+ 				 srcu_read_lock_held(&srcu)) {
+ 		if (subscription->ops->change_pte)
+ 			subscription->ops->change_pte(subscription, mm, address,
+ 						      pte);
++>>>>>>> 63886bad904b (mm/mmu_notifier: silence PROVE_RCU_LIST warnings)
  	}
  	srcu_read_unlock(&srcu, id);
  }
@@@ -452,9 -481,28 +493,34 @@@ static void mn_hlist_invalidate_range_s
  	int id;
  
  	id = srcu_read_lock(&srcu);
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(mn, &mmn_mm->list, hlist) {
 +		if (mn->ops->invalidate_range_start) {
 +			mn->ops->invalidate_range_start(mn, range->mm, range->start, range->end);
++=======
+ 	hlist_for_each_entry_rcu(subscription, &subscriptions->list, hlist,
+ 				 srcu_read_lock_held(&srcu)) {
+ 		const struct mmu_notifier_ops *ops = subscription->ops;
+ 
+ 		if (ops->invalidate_range_start) {
+ 			int _ret;
+ 
+ 			if (!mmu_notifier_range_blockable(range))
+ 				non_block_start();
+ 			_ret = ops->invalidate_range_start(subscription, range);
+ 			if (!mmu_notifier_range_blockable(range))
+ 				non_block_end();
+ 			if (_ret) {
+ 				pr_info("%pS callback failed with %d in %sblockable context.\n",
+ 					ops->invalidate_range_start, _ret,
+ 					!mmu_notifier_range_blockable(range) ?
+ 						"non-" :
+ 						"");
+ 				WARN_ON(mmu_notifier_range_blockable(range) ||
+ 					_ret != -EAGAIN);
+ 				ret = _ret;
+ 			}
++>>>>>>> 63886bad904b (mm/mmu_notifier: silence PROVE_RCU_LIST warnings)
  		}
  	}
  	srcu_read_unlock(&srcu, id);
@@@ -479,7 -534,8 +545,12 @@@ static void mn_hlist_invalidate_end(str
  	int id;
  
  	id = srcu_read_lock(&srcu);
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(mn, &mmn_mm->list, hlist) {
++=======
+ 	hlist_for_each_entry_rcu(subscription, &subscriptions->list, hlist,
+ 				 srcu_read_lock_held(&srcu)) {
++>>>>>>> 63886bad904b (mm/mmu_notifier: silence PROVE_RCU_LIST warnings)
  		/*
  		 * Call invalidate_range here too to avoid the need for the
  		 * subsystem of having to register an invalidate_range_end
@@@ -525,9 -588,12 +596,18 @@@ void __mmu_notifier_invalidate_range(st
  	int id;
  
  	id = srcu_read_lock(&srcu);
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(mn, &mm->mmu_notifier_mm->list, hlist) {
 +		if (mn->ops->invalidate_range)
 +			mn->ops->invalidate_range(mn, mm, start, end);
++=======
+ 	hlist_for_each_entry_rcu(subscription,
+ 				 &mm->notifier_subscriptions->list, hlist,
+ 				 srcu_read_lock_held(&srcu)) {
+ 		if (subscription->ops->invalidate_range)
+ 			subscription->ops->invalidate_range(subscription, mm,
+ 							    start, end);
++>>>>>>> 63886bad904b (mm/mmu_notifier: silence PROVE_RCU_LIST warnings)
  	}
  	srcu_read_unlock(&srcu, id);
  }
@@@ -689,24 -718,23 +769,32 @@@ EXPORT_SYMBOL_GPL(mmu_notifier_register
  static struct mmu_notifier *
  find_get_mmu_notifier(struct mm_struct *mm, const struct mmu_notifier_ops *ops)
  {
 -	struct mmu_notifier *subscription;
 +	struct mmu_notifier *mn;
  
++<<<<<<< HEAD
 +	spin_lock(&mm->mmu_notifier_mm->lock);
 +	hlist_for_each_entry_rcu (mn, &mm->mmu_notifier_mm->list, hlist) {
 +		if (mn->ops != ops)
++=======
+ 	spin_lock(&mm->notifier_subscriptions->lock);
+ 	hlist_for_each_entry_rcu(subscription,
+ 				 &mm->notifier_subscriptions->list, hlist,
+ 				 lockdep_is_held(&mm->notifier_subscriptions->lock)) {
+ 		if (subscription->ops != ops)
++>>>>>>> 63886bad904b (mm/mmu_notifier: silence PROVE_RCU_LIST warnings)
 +			continue;
 +
 +		if (!RH_KABI_AUX(mn, mmu_notifier, mm))
  			continue;
  
 -		if (likely(subscription->users != UINT_MAX))
 -			subscription->users++;
 +		if (likely(mn->_rh->users != UINT_MAX))
 +			mn->_rh->users++;
  		else
 -			subscription = ERR_PTR(-EOVERFLOW);
 -		spin_unlock(&mm->notifier_subscriptions->lock);
 -		return subscription;
 +			mn = ERR_PTR(-EOVERFLOW);
 +		spin_unlock(&mm->mmu_notifier_mm->lock);
 +		return mn;
  	}
 -	spin_unlock(&mm->notifier_subscriptions->lock);
 +	spin_unlock(&mm->mmu_notifier_mm->lock);
  	return NULL;
  }
  
* Unmerged path mm/mmu_notifier.c
