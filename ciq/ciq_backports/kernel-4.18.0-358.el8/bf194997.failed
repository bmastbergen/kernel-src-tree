RDMA: Fix kernel-doc warnings about wrong comment

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Leon Romanovsky <leonro@nvidia.com>
commit bf194997c7319ba968d3f7c47258b4be5f01f81e
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/bf194997.failed

Compilation with W=1 produces warnings similar to the below.

  drivers/infiniband/ulp/ipoib/ipoib_main.c:320: warning: This comment
	starts with '/**', but isn't a kernel-doc comment. Refer
	Documentation/doc-guide/kernel-doc.rst

All such occurrences were found with the following one line
 git grep -A 1 "\/\*\*" drivers/infiniband/

Link: https://lore.kernel.org/r/e57d5f4ddd08b7a19934635b44d6d632841b9ba7.1623823612.git.leonro@nvidia.com
	Reviewed-by: Jack Wang <jinpu.wang@ionos.com> #rtrs
	Reviewed-by: Dennis Dalessandro <dennis.dalessandro@cornelisnetworks.com>
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit bf194997c7319ba968d3f7c47258b4be5f01f81e)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/hw/hns/hns_roce_hem.c
#	drivers/infiniband/ulp/rtrs/rtrs-clt.c
#	drivers/infiniband/ulp/rtrs/rtrs-srv.c
diff --cc drivers/infiniband/hw/hns/hns_roce_hem.c
index f6faefed96e8,fa15d79eabb3..000000000000
--- a/drivers/infiniband/hw/hns/hns_roce_hem.c
+++ b/drivers/infiniband/hw/hns/hns_roce_hem.c
@@@ -1048,8 -962,536 +1048,539 @@@ void hns_roce_cleanup_hem(struct hns_ro
  	hns_roce_cleanup_hem_table(hr_dev, &hr_dev->qp_table.irrl_table);
  	hns_roce_cleanup_hem_table(hr_dev, &hr_dev->qp_table.qp_table);
  	hns_roce_cleanup_hem_table(hr_dev, &hr_dev->mr_table.mtpt_table);
++<<<<<<< HEAD
 +	if (hns_roce_check_whether_mhop(hr_dev, HEM_TYPE_CQE))
 +		hns_roce_cleanup_hem_table(hr_dev,
 +					   &hr_dev->mr_table.mtt_cqe_table);
 +	hns_roce_cleanup_hem_table(hr_dev, &hr_dev->mr_table.mtt_table);
++=======
+ }
+ 
+ struct hns_roce_hem_item {
+ 	struct list_head list; /* link all hems in the same bt level */
+ 	struct list_head sibling; /* link all hems in last hop for mtt */
+ 	void *addr;
+ 	dma_addr_t dma_addr;
+ 	size_t count; /* max ba numbers */
+ 	int start; /* start buf offset in this hem */
+ 	int end; /* end buf offset in this hem */
+ };
+ 
+ /* All HEM items are linked in a tree structure */
+ struct hns_roce_hem_head {
+ 	struct list_head branch[HNS_ROCE_MAX_BT_REGION];
+ 	struct list_head root;
+ 	struct list_head leaf;
+ };
+ 
+ static struct hns_roce_hem_item *
+ hem_list_alloc_item(struct hns_roce_dev *hr_dev, int start, int end, int count,
+ 		    bool exist_bt, int bt_level)
+ {
+ 	struct hns_roce_hem_item *hem;
+ 
+ 	hem = kzalloc(sizeof(*hem), GFP_KERNEL);
+ 	if (!hem)
+ 		return NULL;
+ 
+ 	if (exist_bt) {
+ 		hem->addr = dma_alloc_coherent(hr_dev->dev, count * BA_BYTE_LEN,
+ 					       &hem->dma_addr, GFP_KERNEL);
+ 		if (!hem->addr) {
+ 			kfree(hem);
+ 			return NULL;
+ 		}
+ 	}
+ 
+ 	hem->count = count;
+ 	hem->start = start;
+ 	hem->end = end;
+ 	INIT_LIST_HEAD(&hem->list);
+ 	INIT_LIST_HEAD(&hem->sibling);
+ 
+ 	return hem;
+ }
+ 
+ static void hem_list_free_item(struct hns_roce_dev *hr_dev,
+ 			       struct hns_roce_hem_item *hem, bool exist_bt)
+ {
+ 	if (exist_bt)
+ 		dma_free_coherent(hr_dev->dev, hem->count * BA_BYTE_LEN,
+ 				  hem->addr, hem->dma_addr);
+ 	kfree(hem);
+ }
+ 
+ static void hem_list_free_all(struct hns_roce_dev *hr_dev,
+ 			      struct list_head *head, bool exist_bt)
+ {
+ 	struct hns_roce_hem_item *hem, *temp_hem;
+ 
+ 	list_for_each_entry_safe(hem, temp_hem, head, list) {
+ 		list_del(&hem->list);
+ 		hem_list_free_item(hr_dev, hem, exist_bt);
+ 	}
+ }
+ 
+ static void hem_list_link_bt(struct hns_roce_dev *hr_dev, void *base_addr,
+ 			     u64 table_addr)
+ {
+ 	*(u64 *)(base_addr) = table_addr;
+ }
+ 
+ /* assign L0 table address to hem from root bt */
+ static void hem_list_assign_bt(struct hns_roce_dev *hr_dev,
+ 			       struct hns_roce_hem_item *hem, void *cpu_addr,
+ 			       u64 phy_addr)
+ {
+ 	hem->addr = cpu_addr;
+ 	hem->dma_addr = (dma_addr_t)phy_addr;
+ }
+ 
+ static inline bool hem_list_page_is_in_range(struct hns_roce_hem_item *hem,
+ 					     int offset)
+ {
+ 	return (hem->start <= offset && offset <= hem->end);
+ }
+ 
+ static struct hns_roce_hem_item *hem_list_search_item(struct list_head *ba_list,
+ 						      int page_offset)
+ {
+ 	struct hns_roce_hem_item *hem, *temp_hem;
+ 	struct hns_roce_hem_item *found = NULL;
+ 
+ 	list_for_each_entry_safe(hem, temp_hem, ba_list, list) {
+ 		if (hem_list_page_is_in_range(hem, page_offset)) {
+ 			found = hem;
+ 			break;
+ 		}
+ 	}
+ 
+ 	return found;
+ }
+ 
+ static bool hem_list_is_bottom_bt(int hopnum, int bt_level)
+ {
+ 	/*
+ 	 * hopnum    base address table levels
+ 	 * 0		L0(buf)
+ 	 * 1		L0 -> buf
+ 	 * 2		L0 -> L1 -> buf
+ 	 * 3		L0 -> L1 -> L2 -> buf
+ 	 */
+ 	return bt_level >= (hopnum ? hopnum - 1 : hopnum);
+ }
+ 
+ /*
+  * calc base address entries num
+  * @hopnum: num of mutihop addressing
+  * @bt_level: base address table level
+  * @unit: ba entries per bt page
+  */
+ static u32 hem_list_calc_ba_range(int hopnum, int bt_level, int unit)
+ {
+ 	u32 step;
+ 	int max;
+ 	int i;
+ 
+ 	if (hopnum <= bt_level)
+ 		return 0;
+ 	/*
+ 	 * hopnum  bt_level   range
+ 	 * 1	      0       unit
+ 	 * ------------
+ 	 * 2	      0       unit * unit
+ 	 * 2	      1       unit
+ 	 * ------------
+ 	 * 3	      0       unit * unit * unit
+ 	 * 3	      1       unit * unit
+ 	 * 3	      2       unit
+ 	 */
+ 	step = 1;
+ 	max = hopnum - bt_level;
+ 	for (i = 0; i < max; i++)
+ 		step = step * unit;
+ 
+ 	return step;
+ }
+ 
+ /*
+  * calc the root ba entries which could cover all regions
+  * @regions: buf region array
+  * @region_cnt: array size of @regions
+  * @unit: ba entries per bt page
+  */
+ int hns_roce_hem_list_calc_root_ba(const struct hns_roce_buf_region *regions,
+ 				   int region_cnt, int unit)
+ {
+ 	struct hns_roce_buf_region *r;
+ 	int total = 0;
+ 	int step;
+ 	int i;
+ 
+ 	for (i = 0; i < region_cnt; i++) {
+ 		r = (struct hns_roce_buf_region *)&regions[i];
+ 		if (r->hopnum > 1) {
+ 			step = hem_list_calc_ba_range(r->hopnum, 1, unit);
+ 			if (step > 0)
+ 				total += (r->count + step - 1) / step;
+ 		} else {
+ 			total += r->count;
+ 		}
+ 	}
+ 
+ 	return total;
+ }
+ 
+ static int hem_list_alloc_mid_bt(struct hns_roce_dev *hr_dev,
+ 				 const struct hns_roce_buf_region *r, int unit,
+ 				 int offset, struct list_head *mid_bt,
+ 				 struct list_head *btm_bt)
+ {
+ 	struct hns_roce_hem_item *hem_ptrs[HNS_ROCE_MAX_BT_LEVEL] = { NULL };
+ 	struct list_head temp_list[HNS_ROCE_MAX_BT_LEVEL];
+ 	struct hns_roce_hem_item *cur, *pre;
+ 	const int hopnum = r->hopnum;
+ 	int start_aligned;
+ 	int distance;
+ 	int ret = 0;
+ 	int max_ofs;
+ 	int level;
+ 	u32 step;
+ 	int end;
+ 
+ 	if (hopnum <= 1)
+ 		return 0;
+ 
+ 	if (hopnum > HNS_ROCE_MAX_BT_LEVEL) {
+ 		dev_err(hr_dev->dev, "invalid hopnum %d!\n", hopnum);
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (offset < r->offset) {
+ 		dev_err(hr_dev->dev, "invalid offset %d, min %u!\n",
+ 			offset, r->offset);
+ 		return -EINVAL;
+ 	}
+ 
+ 	distance = offset - r->offset;
+ 	max_ofs = r->offset + r->count - 1;
+ 	for (level = 0; level < hopnum; level++)
+ 		INIT_LIST_HEAD(&temp_list[level]);
+ 
+ 	/* config L1 bt to last bt and link them to corresponding parent */
+ 	for (level = 1; level < hopnum; level++) {
+ 		cur = hem_list_search_item(&mid_bt[level], offset);
+ 		if (cur) {
+ 			hem_ptrs[level] = cur;
+ 			continue;
+ 		}
+ 
+ 		step = hem_list_calc_ba_range(hopnum, level, unit);
+ 		if (step < 1) {
+ 			ret = -EINVAL;
+ 			goto err_exit;
+ 		}
+ 
+ 		start_aligned = (distance / step) * step + r->offset;
+ 		end = min_t(int, start_aligned + step - 1, max_ofs);
+ 		cur = hem_list_alloc_item(hr_dev, start_aligned, end, unit,
+ 					  true, level);
+ 		if (!cur) {
+ 			ret = -ENOMEM;
+ 			goto err_exit;
+ 		}
+ 		hem_ptrs[level] = cur;
+ 		list_add(&cur->list, &temp_list[level]);
+ 		if (hem_list_is_bottom_bt(hopnum, level))
+ 			list_add(&cur->sibling, &temp_list[0]);
+ 
+ 		/* link bt to parent bt */
+ 		if (level > 1) {
+ 			pre = hem_ptrs[level - 1];
+ 			step = (cur->start - pre->start) / step * BA_BYTE_LEN;
+ 			hem_list_link_bt(hr_dev, pre->addr + step,
+ 					 cur->dma_addr);
+ 		}
+ 	}
+ 
+ 	list_splice(&temp_list[0], btm_bt);
+ 	for (level = 1; level < hopnum; level++)
+ 		list_splice(&temp_list[level], &mid_bt[level]);
+ 
+ 	return 0;
+ 
+ err_exit:
+ 	for (level = 1; level < hopnum; level++)
+ 		hem_list_free_all(hr_dev, &temp_list[level], true);
+ 
+ 	return ret;
+ }
+ 
+ static struct hns_roce_hem_item *
+ alloc_root_hem(struct hns_roce_dev *hr_dev, int unit, int *max_ba_num,
+ 	       const struct hns_roce_buf_region *regions, int region_cnt)
+ {
+ 	const struct hns_roce_buf_region *r;
+ 	struct hns_roce_hem_item *hem;
+ 	int ba_num;
+ 	int offset;
+ 
+ 	ba_num = hns_roce_hem_list_calc_root_ba(regions, region_cnt, unit);
+ 	if (ba_num < 1)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	if (ba_num > unit)
+ 		return ERR_PTR(-ENOBUFS);
+ 
+ 	offset = regions[0].offset;
+ 	/* indicate to last region */
+ 	r = &regions[region_cnt - 1];
+ 	hem = hem_list_alloc_item(hr_dev, offset, r->offset + r->count - 1,
+ 				  ba_num, true, 0);
+ 	if (!hem)
+ 		return ERR_PTR(-ENOMEM);
+ 
+ 	*max_ba_num = ba_num;
+ 
+ 	return hem;
+ }
+ 
+ static int alloc_fake_root_bt(struct hns_roce_dev *hr_dev, void *cpu_base,
+ 			      u64 phy_base, const struct hns_roce_buf_region *r,
+ 			      struct list_head *branch_head,
+ 			      struct list_head *leaf_head)
+ {
+ 	struct hns_roce_hem_item *hem;
+ 
+ 	hem = hem_list_alloc_item(hr_dev, r->offset, r->offset + r->count - 1,
+ 				  r->count, false, 0);
+ 	if (!hem)
+ 		return -ENOMEM;
+ 
+ 	hem_list_assign_bt(hr_dev, hem, cpu_base, phy_base);
+ 	list_add(&hem->list, branch_head);
+ 	list_add(&hem->sibling, leaf_head);
+ 
+ 	return r->count;
+ }
+ 
+ static int setup_middle_bt(struct hns_roce_dev *hr_dev, void *cpu_base,
+ 			   int unit, const struct hns_roce_buf_region *r,
+ 			   const struct list_head *branch_head)
+ {
+ 	struct hns_roce_hem_item *hem, *temp_hem;
+ 	int total = 0;
+ 	int offset;
+ 	int step;
+ 
+ 	step = hem_list_calc_ba_range(r->hopnum, 1, unit);
+ 	if (step < 1)
+ 		return -EINVAL;
+ 
+ 	/* if exist mid bt, link L1 to L0 */
+ 	list_for_each_entry_safe(hem, temp_hem, branch_head, list) {
+ 		offset = (hem->start - r->offset) / step * BA_BYTE_LEN;
+ 		hem_list_link_bt(hr_dev, cpu_base + offset, hem->dma_addr);
+ 		total++;
+ 	}
+ 
+ 	return total;
+ }
+ 
+ static int
+ setup_root_hem(struct hns_roce_dev *hr_dev, struct hns_roce_hem_list *hem_list,
+ 	       int unit, int max_ba_num, struct hns_roce_hem_head *head,
+ 	       const struct hns_roce_buf_region *regions, int region_cnt)
+ {
+ 	const struct hns_roce_buf_region *r;
+ 	struct hns_roce_hem_item *root_hem;
+ 	void *cpu_base;
+ 	u64 phy_base;
+ 	int i, total;
+ 	int ret;
+ 
+ 	root_hem = list_first_entry(&head->root,
+ 				    struct hns_roce_hem_item, list);
+ 	if (!root_hem)
+ 		return -ENOMEM;
+ 
+ 	total = 0;
+ 	for (i = 0; i < region_cnt && total < max_ba_num; i++) {
+ 		r = &regions[i];
+ 		if (!r->count)
+ 			continue;
+ 
+ 		/* all regions's mid[x][0] shared the root_bt's trunk */
+ 		cpu_base = root_hem->addr + total * BA_BYTE_LEN;
+ 		phy_base = root_hem->dma_addr + total * BA_BYTE_LEN;
+ 
+ 		/* if hopnum is 0 or 1, cut a new fake hem from the root bt
+ 		 * which's address share to all regions.
+ 		 */
+ 		if (hem_list_is_bottom_bt(r->hopnum, 0))
+ 			ret = alloc_fake_root_bt(hr_dev, cpu_base, phy_base, r,
+ 						 &head->branch[i], &head->leaf);
+ 		else
+ 			ret = setup_middle_bt(hr_dev, cpu_base, unit, r,
+ 					      &hem_list->mid_bt[i][1]);
+ 
+ 		if (ret < 0)
+ 			return ret;
+ 
+ 		total += ret;
+ 	}
+ 
+ 	list_splice(&head->leaf, &hem_list->btm_bt);
+ 	list_splice(&head->root, &hem_list->root_bt);
+ 	for (i = 0; i < region_cnt; i++)
+ 		list_splice(&head->branch[i], &hem_list->mid_bt[i][0]);
+ 
+ 	return 0;
+ }
+ 
+ static int hem_list_alloc_root_bt(struct hns_roce_dev *hr_dev,
+ 				  struct hns_roce_hem_list *hem_list, int unit,
+ 				  const struct hns_roce_buf_region *regions,
+ 				  int region_cnt)
+ {
+ 	struct hns_roce_hem_item *root_hem;
+ 	struct hns_roce_hem_head head;
+ 	int max_ba_num;
+ 	int ret;
+ 	int i;
+ 
+ 	root_hem = hem_list_search_item(&hem_list->root_bt, regions[0].offset);
+ 	if (root_hem)
+ 		return 0;
+ 
+ 	max_ba_num = 0;
+ 	root_hem = alloc_root_hem(hr_dev, unit, &max_ba_num, regions,
+ 				  region_cnt);
+ 	if (IS_ERR(root_hem))
+ 		return PTR_ERR(root_hem);
+ 
+ 	/* List head for storing all allocated HEM items */
+ 	INIT_LIST_HEAD(&head.root);
+ 	INIT_LIST_HEAD(&head.leaf);
+ 	for (i = 0; i < region_cnt; i++)
+ 		INIT_LIST_HEAD(&head.branch[i]);
+ 
+ 	hem_list->root_ba = root_hem->dma_addr;
+ 	list_add(&root_hem->list, &head.root);
+ 	ret = setup_root_hem(hr_dev, hem_list, unit, max_ba_num, &head, regions,
+ 			     region_cnt);
+ 	if (ret) {
+ 		for (i = 0; i < region_cnt; i++)
+ 			hem_list_free_all(hr_dev, &head.branch[i], false);
+ 
+ 		hem_list_free_all(hr_dev, &head.root, true);
+ 	}
+ 
+ 	return ret;
+ }
+ 
+ /* construct the base address table and link them by address hop config */
+ int hns_roce_hem_list_request(struct hns_roce_dev *hr_dev,
+ 			      struct hns_roce_hem_list *hem_list,
+ 			      const struct hns_roce_buf_region *regions,
+ 			      int region_cnt, unsigned int bt_pg_shift)
+ {
+ 	const struct hns_roce_buf_region *r;
+ 	int ofs, end;
+ 	int unit;
+ 	int ret;
+ 	int i;
+ 
+ 	if (region_cnt > HNS_ROCE_MAX_BT_REGION) {
+ 		dev_err(hr_dev->dev, "invalid region region_cnt %d!\n",
+ 			region_cnt);
+ 		return -EINVAL;
+ 	}
+ 
+ 	unit = (1 << bt_pg_shift) / BA_BYTE_LEN;
+ 	for (i = 0; i < region_cnt; i++) {
+ 		r = &regions[i];
+ 		if (!r->count)
+ 			continue;
+ 
+ 		end = r->offset + r->count;
+ 		for (ofs = r->offset; ofs < end; ofs += unit) {
+ 			ret = hem_list_alloc_mid_bt(hr_dev, r, unit, ofs,
+ 						    hem_list->mid_bt[i],
+ 						    &hem_list->btm_bt);
+ 			if (ret) {
+ 				dev_err(hr_dev->dev,
+ 					"alloc hem trunk fail ret=%d!\n", ret);
+ 				goto err_alloc;
+ 			}
+ 		}
+ 	}
+ 
+ 	ret = hem_list_alloc_root_bt(hr_dev, hem_list, unit, regions,
+ 				     region_cnt);
+ 	if (ret)
+ 		dev_err(hr_dev->dev, "alloc hem root fail ret=%d!\n", ret);
+ 	else
+ 		return 0;
+ 
+ err_alloc:
+ 	hns_roce_hem_list_release(hr_dev, hem_list);
+ 
+ 	return ret;
+ }
+ 
+ void hns_roce_hem_list_release(struct hns_roce_dev *hr_dev,
+ 			       struct hns_roce_hem_list *hem_list)
+ {
+ 	int i, j;
+ 
+ 	for (i = 0; i < HNS_ROCE_MAX_BT_REGION; i++)
+ 		for (j = 0; j < HNS_ROCE_MAX_BT_LEVEL; j++)
+ 			hem_list_free_all(hr_dev, &hem_list->mid_bt[i][j],
+ 					  j != 0);
+ 
+ 	hem_list_free_all(hr_dev, &hem_list->root_bt, true);
+ 	INIT_LIST_HEAD(&hem_list->btm_bt);
+ 	hem_list->root_ba = 0;
+ }
+ 
+ void hns_roce_hem_list_init(struct hns_roce_hem_list *hem_list)
+ {
+ 	int i, j;
+ 
+ 	INIT_LIST_HEAD(&hem_list->root_bt);
+ 	INIT_LIST_HEAD(&hem_list->btm_bt);
+ 	for (i = 0; i < HNS_ROCE_MAX_BT_REGION; i++)
+ 		for (j = 0; j < HNS_ROCE_MAX_BT_LEVEL; j++)
+ 			INIT_LIST_HEAD(&hem_list->mid_bt[i][j]);
+ }
+ 
+ void *hns_roce_hem_list_find_mtt(struct hns_roce_dev *hr_dev,
+ 				 struct hns_roce_hem_list *hem_list,
+ 				 int offset, int *mtt_cnt, u64 *phy_addr)
+ {
+ 	struct list_head *head = &hem_list->btm_bt;
+ 	struct hns_roce_hem_item *hem, *temp_hem;
+ 	void *cpu_base = NULL;
+ 	u64 phy_base = 0;
+ 	int nr = 0;
+ 
+ 	list_for_each_entry_safe(hem, temp_hem, head, sibling) {
+ 		if (hem_list_page_is_in_range(hem, offset)) {
+ 			nr = offset - hem->start;
+ 			cpu_base = hem->addr + nr * BA_BYTE_LEN;
+ 			phy_base = hem->dma_addr + nr * BA_BYTE_LEN;
+ 			nr = hem->end + 1 - offset;
+ 			break;
+ 		}
+ 	}
+ 
+ 	if (mtt_cnt)
+ 		*mtt_cnt = nr;
+ 
+ 	if (phy_addr)
+ 		*phy_addr = phy_base;
+ 
+ 	return cpu_base;
++>>>>>>> bf194997c731 (RDMA: Fix kernel-doc warnings about wrong comment)
  }
* Unmerged path drivers/infiniband/ulp/rtrs/rtrs-clt.c
* Unmerged path drivers/infiniband/ulp/rtrs/rtrs-srv.c
diff --git a/drivers/infiniband/core/iwpm_util.h b/drivers/infiniband/core/iwpm_util.h
index 5002ac6dfbc3..e201835de733 100644
--- a/drivers/infiniband/core/iwpm_util.h
+++ b/drivers/infiniband/core/iwpm_util.h
@@ -183,7 +183,7 @@ u32 iwpm_check_registration(u8 nl_client, u32 reg);
 void iwpm_set_registration(u8 nl_client, u32 reg);
 
 /**
- * iwpm_get_registration
+ * iwpm_get_registration - Get the client registration
  * @nl_client: The index of the netlink client
  *
  * Returns the client registration type
diff --git a/drivers/infiniband/core/roce_gid_mgmt.c b/drivers/infiniband/core/roce_gid_mgmt.c
index 34fff94eaa38..b7a3fe8aae7b 100644
--- a/drivers/infiniband/core/roce_gid_mgmt.c
+++ b/drivers/infiniband/core/roce_gid_mgmt.c
@@ -186,12 +186,13 @@ is_eth_port_inactive_slave_filter(struct ib_device *ib_dev, u8 port,
 	return res;
 }
 
-/** is_ndev_for_default_gid_filter - Check if a given netdevice
+/**
+ * is_ndev_for_default_gid_filter - Check if a given netdevice
  * can be considered for default GIDs or not.
  * @ib_dev:		IB device to check
  * @port:		Port to consider for adding default GID
  * @rdma_ndev:		rdma netdevice pointer
- * @cookie_ndev:	Netdevice to consider to form a default GID
+ * @cookie:             Netdevice to consider to form a default GID
  *
  * is_ndev_for_default_gid_filter() returns true if a given netdevice can be
  * considered for deriving default RoCE GID, returns false otherwise.
diff --git a/drivers/infiniband/hw/hfi1/chip.c b/drivers/infiniband/hw/hfi1/chip.c
index 993cbf37e0b9..c67c4c4c20cb 100644
--- a/drivers/infiniband/hw/hfi1/chip.c
+++ b/drivers/infiniband/hw/hfi1/chip.c
@@ -14186,7 +14186,7 @@ static void init_kdeth_qp(struct hfi1_devdata *dd)
 }
 
 /**
- * hfi1_get_qp_map
+ * hfi1_get_qp_map - get qp map
  * @dd: device data
  * @idx: index to read
  */
@@ -14199,7 +14199,7 @@ u8 hfi1_get_qp_map(struct hfi1_devdata *dd, u8 idx)
 }
 
 /**
- * init_qpmap_table
+ * init_qpmap_table - init qp map
  * @dd: device data
  * @first_ctxt: first context
  * @last_ctxt: first context
diff --git a/drivers/infiniband/hw/hfi1/file_ops.c b/drivers/infiniband/hw/hfi1/file_ops.c
index 51c607d32e67..7d0cd36cdc94 100644
--- a/drivers/infiniband/hw/hfi1/file_ops.c
+++ b/drivers/infiniband/hw/hfi1/file_ops.c
@@ -736,7 +736,7 @@ static u64 kvirt_to_phys(void *addr)
 }
 
 /**
- * complete_subctxt
+ * complete_subctxt - complete sub-context info
  * @fd: valid filedata pointer
  *
  * Sub-context info can only be set up after the base context
@@ -841,7 +841,7 @@ static int assign_ctxt(struct hfi1_filedata *fd, unsigned long arg, u32 len)
 }
 
 /**
- * match_ctxt
+ * match_ctxt - match context
  * @fd: valid filedata pointer
  * @uinfo: user info to compare base context with
  * @uctxt: context to compare uinfo to.
@@ -898,7 +898,7 @@ static int match_ctxt(struct hfi1_filedata *fd,
 }
 
 /**
- * find_sub_ctxt
+ * find_sub_ctxt - fund sub-context
  * @fd: valid filedata pointer
  * @uinfo: matching info to use to find a possible context to share.
  *
diff --git a/drivers/infiniband/hw/hfi1/hfi.h b/drivers/infiniband/hw/hfi1/hfi.h
index 4aba6416147b..a428a24e6cec 100644
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@ -1770,7 +1770,7 @@ static inline void pause_for_credit_return(struct hfi1_devdata *dd)
 }
 
 /**
- * sc_to_vlt() reverse lookup sc to vl
+ * sc_to_vlt() - reverse lookup sc to vl
  * @dd - devdata
  * @sc5 - 5 bit sc
  */
diff --git a/drivers/infiniband/hw/hfi1/init.c b/drivers/infiniband/hw/hfi1/init.c
index 786c6316273f..44b9b5b49298 100644
--- a/drivers/infiniband/hw/hfi1/init.c
+++ b/drivers/infiniband/hw/hfi1/init.c
@@ -312,7 +312,7 @@ struct hfi1_ctxtdata *hfi1_rcd_get_by_index_safe(struct hfi1_devdata *dd,
 }
 
 /**
- * hfi1_rcd_get_by_index
+ * hfi1_rcd_get_by_index - get by index
  * @dd: pointer to a valid devdata structure
  * @ctxt: the index of an possilbe rcd
  *
@@ -499,7 +499,7 @@ int hfi1_create_ctxtdata(struct hfi1_pportdata *ppd, int numa,
 }
 
 /**
- * hfi1_free_ctxt
+ * hfi1_free_ctxt - free context
  * @rcd: pointer to an initialized rcd data structure
  *
  * This wrapper is the free function that matches hfi1_create_ctxtdata().
diff --git a/drivers/infiniband/hw/hfi1/pio.c b/drivers/infiniband/hw/hfi1/pio.c
index ff864f6f0266..e276522104c6 100644
--- a/drivers/infiniband/hw/hfi1/pio.c
+++ b/drivers/infiniband/hw/hfi1/pio.c
@@ -993,7 +993,7 @@ static bool is_sc_halted(struct hfi1_devdata *dd, u32 hw_context)
 }
 
 /**
- * sc_wait_for_packet_egress
+ * sc_wait_for_packet_egress - wait for packet
  * @sc: valid send context
  * @pause: wait for credit return
  *
* Unmerged path drivers/infiniband/hw/hns/hns_roce_hem.c
diff --git a/drivers/infiniband/sw/rdmavt/mr.c b/drivers/infiniband/sw/rdmavt/mr.c
index 57ad975dfc73..ec15899093f2 100644
--- a/drivers/infiniband/sw/rdmavt/mr.c
+++ b/drivers/infiniband/sw/rdmavt/mr.c
@@ -101,8 +101,8 @@ int rvt_driver_mr_init(struct rvt_dev_info *rdi)
 }
 
 /**
- *rvt_mr_exit: clean up MR
- *@rdi: rvt dev structure
+ * rvt_mr_exit - clean up MR
+ * @rdi: rvt dev structure
  *
  * called when drivers have unregistered or perhaps failed to register with us
  */
diff --git a/drivers/infiniband/sw/rdmavt/qp.c b/drivers/infiniband/sw/rdmavt/qp.c
index 9d13db68283c..e9f3d356b361 100644
--- a/drivers/infiniband/sw/rdmavt/qp.c
+++ b/drivers/infiniband/sw/rdmavt/qp.c
@@ -984,7 +984,8 @@ static void rvt_reset_qp(struct rvt_dev_info *rdi, struct rvt_qp *qp,
 	spin_unlock_irq(&qp->r_lock);
 }
 
-/** rvt_free_qpn - Free a qpn from the bit map
+/**
+ * rvt_free_qpn - Free a qpn from the bit map
  * @qpt: QP table
  * @qpn: queue pair number to free
  */
diff --git a/drivers/infiniband/sw/rdmavt/vt.c b/drivers/infiniband/sw/rdmavt/vt.c
index 8fd0128a9336..30ea2a21e1b8 100644
--- a/drivers/infiniband/sw/rdmavt/vt.c
+++ b/drivers/infiniband/sw/rdmavt/vt.c
@@ -144,7 +144,7 @@ static int rvt_modify_device(struct ib_device *device,
 }
 
 /**
- * rvt_query_port: Passes the query port call to the driver
+ * rvt_query_port - Passes the query port call to the driver
  * @ibdev: Verbs IB dev
  * @port_num: port number, 1 based from ib core
  * @props: structure to hold returned properties
@@ -178,7 +178,7 @@ static int rvt_query_port(struct ib_device *ibdev, u8 port_num,
 }
 
 /**
- * rvt_modify_port
+ * rvt_modify_port - modify port
  * @ibdev: Verbs IB dev
  * @port_num: Port number, 1 based from ib core
  * @port_modify_mask: How to change the port
diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c
index 92750b3b550c..c583bd168b43 100644
--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c
+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c
@@ -316,7 +316,7 @@ static bool ipoib_is_dev_match_addr_rcu(const struct sockaddr *addr,
 	return false;
 }
 
-/**
+/*
  * Find the master net_device on top of the given net_device.
  * @dev: base IPoIB net_device
  *
@@ -361,8 +361,9 @@ static int ipoib_upper_walk(struct net_device *upper,
 }
 
 /**
- * Find a net_device matching the given address, which is an upper device of
- * the given net_device.
+ * ipoib_get_net_dev_match_addr - Find a net_device matching
+ * the given address, which is an upper device of the given net_device.
+ *
  * @addr: IP address to look for.
  * @dev: base IPoIB net_device
  *
diff --git a/drivers/infiniband/ulp/iser/iser_verbs.c b/drivers/infiniband/ulp/iser/iser_verbs.c
index 136f6c4492e0..b44cbb8e84eb 100644
--- a/drivers/infiniband/ulp/iser/iser_verbs.c
+++ b/drivers/infiniband/ulp/iser/iser_verbs.c
@@ -761,7 +761,7 @@ void iser_conn_init(struct iser_conn *iser_conn)
 	ib_conn->reg_cqe.done = iser_reg_comp;
 }
 
- /**
+/*
  * starts the process of connecting to the target
  * sleeps until the connection is established or rejected
  */
diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c
index 97214329c571..636d590765f9 100644
--- a/drivers/infiniband/ulp/isert/ib_isert.c
+++ b/drivers/infiniband/ulp/isert/ib_isert.c
@@ -2397,10 +2397,10 @@ isert_accept_np(struct iscsi_np *np, struct iscsi_conn *conn)
 		spin_unlock_bh(&np->np_thread_lock);
 		isert_dbg("np_thread_state %d\n",
 			 np->np_thread_state);
-		/**
+		/*
 		 * No point in stalling here when np_thread
 		 * is in state RESET/SHUTDOWN/EXIT - bail
-		 **/
+		 */
 		return -ENODEV;
 	}
 	spin_unlock_bh(&np->np_thread_lock);
* Unmerged path drivers/infiniband/ulp/rtrs/rtrs-clt.c
* Unmerged path drivers/infiniband/ulp/rtrs/rtrs-srv.c
