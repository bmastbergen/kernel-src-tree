KVM: stats: Support binary stats retrieval for a VCPU

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Jing Zhang <jingzhangos@google.com>
commit ce55c049459cff0034cc1bcfdce3bf343a2d6317
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/ce55c049.failed

Add a VCPU ioctl to get a statistics file descriptor by which a read
functionality is provided for userspace to read out VCPU stats header,
descriptors and data.
Define VCPU statistics descriptors and header for all architectures.

	Reviewed-by: David Matlack <dmatlack@google.com>
	Reviewed-by: Ricardo Koller <ricarkol@google.com>
	Reviewed-by: Krish Sadhukhan <krish.sadhukhan@oracle.com>
	Reviewed-by: Fuad Tabba <tabba@google.com>
	Tested-by: Fuad Tabba <tabba@google.com> #arm64
	Signed-off-by: Jing Zhang <jingzhangos@google.com>
Message-Id: <20210618222709.1858088-5-jingzhangos@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit ce55c049459cff0034cc1bcfdce3bf343a2d6317)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/arm64/kvm/guest.c
#	arch/mips/kvm/mips.c
#	arch/powerpc/kvm/book3s.c
#	arch/powerpc/kvm/booke.c
#	arch/s390/kvm/kvm-s390.c
#	arch/x86/kvm/x86.c
#	include/linux/kvm_host.h
diff --cc arch/arm64/kvm/guest.c
index 55fc8899da78,f1dc2092d3a0..000000000000
--- a/arch/arm64/kvm/guest.c
+++ b/arch/arm64/kvm/guest.c
@@@ -40,11 -28,47 +40,50 @@@
  
  #include "trace.h"
  
++<<<<<<< HEAD
++=======
+ const struct _kvm_stats_desc kvm_vm_stats_desc[] = {
+ 	KVM_GENERIC_VM_STATS()
+ };
+ static_assert(ARRAY_SIZE(kvm_vm_stats_desc) ==
+ 		sizeof(struct kvm_vm_stat) / sizeof(u64));
+ 
+ const struct kvm_stats_header kvm_vm_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vm_stats_desc),
+ 	.id_offset =  sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vm_stats_desc),
+ };
+ 
+ const struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {
+ 	KVM_GENERIC_VCPU_STATS(),
+ 	STATS_DESC_COUNTER(VCPU, hvc_exit_stat),
+ 	STATS_DESC_COUNTER(VCPU, wfe_exit_stat),
+ 	STATS_DESC_COUNTER(VCPU, wfi_exit_stat),
+ 	STATS_DESC_COUNTER(VCPU, mmio_exit_user),
+ 	STATS_DESC_COUNTER(VCPU, mmio_exit_kernel),
+ 	STATS_DESC_COUNTER(VCPU, exits)
+ };
+ static_assert(ARRAY_SIZE(kvm_vcpu_stats_desc) ==
+ 		sizeof(struct kvm_vcpu_stat) / sizeof(u64));
+ 
+ const struct kvm_stats_header kvm_vcpu_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vcpu_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vcpu_stats_desc),
+ };
+ 
++>>>>>>> ce55c049459c (KVM: stats: Support binary stats retrieval for a VCPU)
  struct kvm_stats_debugfs_item debugfs_entries[] = {
 -	VCPU_STAT("halt_successful_poll", generic.halt_successful_poll),
 -	VCPU_STAT("halt_attempted_poll", generic.halt_attempted_poll),
 -	VCPU_STAT("halt_poll_invalid", generic.halt_poll_invalid),
 -	VCPU_STAT("halt_wakeup", generic.halt_wakeup),
 +	VCPU_STAT("halt_successful_poll", halt_successful_poll),
 +	VCPU_STAT("halt_attempted_poll", halt_attempted_poll),
 +	VCPU_STAT("halt_poll_invalid", halt_poll_invalid),
 +	VCPU_STAT("halt_wakeup", halt_wakeup),
  	VCPU_STAT("hvc_exit_stat", hvc_exit_stat),
  	VCPU_STAT("wfe_exit_stat", wfe_exit_stat),
  	VCPU_STAT("wfi_exit_stat", wfi_exit_stat),
diff --cc arch/mips/kvm/mips.c
index fb7fb30a3287,2aba78c2266d..000000000000
--- a/arch/mips/kvm/mips.c
+++ b/arch/mips/kvm/mips.c
@@@ -39,6 -38,65 +39,68 @@@
  #define VECTORSPACING 0x100	/* for EI/VI mode */
  #endif
  
++<<<<<<< HEAD
++=======
+ const struct _kvm_stats_desc kvm_vm_stats_desc[] = {
+ 	KVM_GENERIC_VM_STATS()
+ };
+ static_assert(ARRAY_SIZE(kvm_vm_stats_desc) ==
+ 		sizeof(struct kvm_vm_stat) / sizeof(u64));
+ 
+ const struct kvm_stats_header kvm_vm_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vm_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vm_stats_desc),
+ };
+ 
+ const struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {
+ 	KVM_GENERIC_VCPU_STATS(),
+ 	STATS_DESC_COUNTER(VCPU, wait_exits),
+ 	STATS_DESC_COUNTER(VCPU, cache_exits),
+ 	STATS_DESC_COUNTER(VCPU, signal_exits),
+ 	STATS_DESC_COUNTER(VCPU, int_exits),
+ 	STATS_DESC_COUNTER(VCPU, cop_unusable_exits),
+ 	STATS_DESC_COUNTER(VCPU, tlbmod_exits),
+ 	STATS_DESC_COUNTER(VCPU, tlbmiss_ld_exits),
+ 	STATS_DESC_COUNTER(VCPU, tlbmiss_st_exits),
+ 	STATS_DESC_COUNTER(VCPU, addrerr_st_exits),
+ 	STATS_DESC_COUNTER(VCPU, addrerr_ld_exits),
+ 	STATS_DESC_COUNTER(VCPU, syscall_exits),
+ 	STATS_DESC_COUNTER(VCPU, resvd_inst_exits),
+ 	STATS_DESC_COUNTER(VCPU, break_inst_exits),
+ 	STATS_DESC_COUNTER(VCPU, trap_inst_exits),
+ 	STATS_DESC_COUNTER(VCPU, msa_fpe_exits),
+ 	STATS_DESC_COUNTER(VCPU, fpe_exits),
+ 	STATS_DESC_COUNTER(VCPU, msa_disabled_exits),
+ 	STATS_DESC_COUNTER(VCPU, flush_dcache_exits),
+ 	STATS_DESC_COUNTER(VCPU, vz_gpsi_exits),
+ 	STATS_DESC_COUNTER(VCPU, vz_gsfc_exits),
+ 	STATS_DESC_COUNTER(VCPU, vz_hc_exits),
+ 	STATS_DESC_COUNTER(VCPU, vz_grr_exits),
+ 	STATS_DESC_COUNTER(VCPU, vz_gva_exits),
+ 	STATS_DESC_COUNTER(VCPU, vz_ghfc_exits),
+ 	STATS_DESC_COUNTER(VCPU, vz_gpa_exits),
+ 	STATS_DESC_COUNTER(VCPU, vz_resvd_exits),
+ #ifdef CONFIG_CPU_LOONGSON64
+ 	STATS_DESC_COUNTER(VCPU, vz_cpucfg_exits),
+ #endif
+ };
+ static_assert(ARRAY_SIZE(kvm_vcpu_stats_desc) ==
+ 		sizeof(struct kvm_vcpu_stat) / sizeof(u64));
+ 
+ const struct kvm_stats_header kvm_vcpu_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vcpu_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vcpu_stats_desc),
+ };
+ 
++>>>>>>> ce55c049459c (KVM: stats: Support binary stats retrieval for a VCPU)
  struct kvm_stats_debugfs_item debugfs_entries[] = {
  	VCPU_STAT("wait", wait_exits),
  	VCPU_STAT("cache", cache_exits),
diff --cc arch/powerpc/kvm/book3s.c
index 5063a9817c96,61229302bce2..000000000000
--- a/arch/powerpc/kvm/book3s.c
+++ b/arch/powerpc/kvm/book3s.c
@@@ -42,6 -38,68 +42,71 @@@
  
  /* #define EXIT_DEBUG */
  
++<<<<<<< HEAD
++=======
+ const struct _kvm_stats_desc kvm_vm_stats_desc[] = {
+ 	KVM_GENERIC_VM_STATS(),
+ 	STATS_DESC_ICOUNTER(VM, num_2M_pages),
+ 	STATS_DESC_ICOUNTER(VM, num_1G_pages)
+ };
+ static_assert(ARRAY_SIZE(kvm_vm_stats_desc) ==
+ 		sizeof(struct kvm_vm_stat) / sizeof(u64));
+ 
+ const struct kvm_stats_header kvm_vm_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vm_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vm_stats_desc),
+ };
+ 
+ const struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {
+ 	KVM_GENERIC_VCPU_STATS(),
+ 	STATS_DESC_COUNTER(VCPU, sum_exits),
+ 	STATS_DESC_COUNTER(VCPU, mmio_exits),
+ 	STATS_DESC_COUNTER(VCPU, signal_exits),
+ 	STATS_DESC_COUNTER(VCPU, light_exits),
+ 	STATS_DESC_COUNTER(VCPU, itlb_real_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, itlb_virt_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, dtlb_real_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, dtlb_virt_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, syscall_exits),
+ 	STATS_DESC_COUNTER(VCPU, isi_exits),
+ 	STATS_DESC_COUNTER(VCPU, dsi_exits),
+ 	STATS_DESC_COUNTER(VCPU, emulated_inst_exits),
+ 	STATS_DESC_COUNTER(VCPU, dec_exits),
+ 	STATS_DESC_COUNTER(VCPU, ext_intr_exits),
+ 	STATS_DESC_TIME_NSEC(VCPU, halt_wait_ns),
+ 	STATS_DESC_COUNTER(VCPU, halt_successful_wait),
+ 	STATS_DESC_COUNTER(VCPU, dbell_exits),
+ 	STATS_DESC_COUNTER(VCPU, gdbell_exits),
+ 	STATS_DESC_COUNTER(VCPU, ld),
+ 	STATS_DESC_COUNTER(VCPU, st),
+ 	STATS_DESC_COUNTER(VCPU, pf_storage),
+ 	STATS_DESC_COUNTER(VCPU, pf_instruc),
+ 	STATS_DESC_COUNTER(VCPU, sp_storage),
+ 	STATS_DESC_COUNTER(VCPU, sp_instruc),
+ 	STATS_DESC_COUNTER(VCPU, queue_intr),
+ 	STATS_DESC_COUNTER(VCPU, ld_slow),
+ 	STATS_DESC_COUNTER(VCPU, st_slow),
+ 	STATS_DESC_COUNTER(VCPU, pthru_all),
+ 	STATS_DESC_COUNTER(VCPU, pthru_host),
+ 	STATS_DESC_COUNTER(VCPU, pthru_bad_aff)
+ };
+ static_assert(ARRAY_SIZE(kvm_vcpu_stats_desc) ==
+ 		sizeof(struct kvm_vcpu_stat) / sizeof(u64));
+ 
+ const struct kvm_stats_header kvm_vcpu_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vcpu_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vcpu_stats_desc),
+ };
+ 
++>>>>>>> ce55c049459c (KVM: stats: Support binary stats retrieval for a VCPU)
  struct kvm_stats_debugfs_item debugfs_entries[] = {
  	VCPU_STAT("exits", sum_exits),
  	VCPU_STAT("mmio", mmio_exits),
diff --cc arch/powerpc/kvm/booke.c
index f7ec42fd14d5,6e8de33bc138..000000000000
--- a/arch/powerpc/kvm/booke.c
+++ b/arch/powerpc/kvm/booke.c
@@@ -46,6 -36,61 +46,64 @@@
  
  unsigned long kvmppc_booke_handlers;
  
++<<<<<<< HEAD
++=======
+ const struct _kvm_stats_desc kvm_vm_stats_desc[] = {
+ 	KVM_GENERIC_VM_STATS(),
+ 	STATS_DESC_ICOUNTER(VM, num_2M_pages),
+ 	STATS_DESC_ICOUNTER(VM, num_1G_pages)
+ };
+ static_assert(ARRAY_SIZE(kvm_vm_stats_desc) ==
+ 		sizeof(struct kvm_vm_stat) / sizeof(u64));
+ 
+ const struct kvm_stats_header kvm_vm_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vm_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vm_stats_desc),
+ };
+ 
+ const struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {
+ 	KVM_GENERIC_VCPU_STATS(),
+ 	STATS_DESC_COUNTER(VCPU, sum_exits),
+ 	STATS_DESC_COUNTER(VCPU, mmio_exits),
+ 	STATS_DESC_COUNTER(VCPU, signal_exits),
+ 	STATS_DESC_COUNTER(VCPU, light_exits),
+ 	STATS_DESC_COUNTER(VCPU, itlb_real_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, itlb_virt_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, dtlb_real_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, dtlb_virt_miss_exits),
+ 	STATS_DESC_COUNTER(VCPU, syscall_exits),
+ 	STATS_DESC_COUNTER(VCPU, isi_exits),
+ 	STATS_DESC_COUNTER(VCPU, dsi_exits),
+ 	STATS_DESC_COUNTER(VCPU, emulated_inst_exits),
+ 	STATS_DESC_COUNTER(VCPU, dec_exits),
+ 	STATS_DESC_COUNTER(VCPU, ext_intr_exits),
+ 	STATS_DESC_TIME_NSEC(VCPU, halt_wait_ns),
+ 	STATS_DESC_COUNTER(VCPU, halt_successful_wait),
+ 	STATS_DESC_COUNTER(VCPU, dbell_exits),
+ 	STATS_DESC_COUNTER(VCPU, gdbell_exits),
+ 	STATS_DESC_COUNTER(VCPU, ld),
+ 	STATS_DESC_COUNTER(VCPU, st),
+ 	STATS_DESC_COUNTER(VCPU, pthru_all),
+ 	STATS_DESC_COUNTER(VCPU, pthru_host),
+ 	STATS_DESC_COUNTER(VCPU, pthru_bad_aff)
+ };
+ static_assert(ARRAY_SIZE(kvm_vcpu_stats_desc) ==
+ 		sizeof(struct kvm_vcpu_stat) / sizeof(u64));
+ 
+ const struct kvm_stats_header kvm_vcpu_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vcpu_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vcpu_stats_desc),
+ };
+ 
++>>>>>>> ce55c049459c (KVM: stats: Support binary stats retrieval for a VCPU)
  struct kvm_stats_debugfs_item debugfs_entries[] = {
  	VCPU_STAT("mmio", mmio_exits),
  	VCPU_STAT("sig", signal_exits),
diff --cc arch/s390/kvm/kvm-s390.c
index 77ac3932fe76,8ac10bcaf8ba..000000000000
--- a/arch/s390/kvm/kvm-s390.c
+++ b/arch/s390/kvm/kvm-s390.c
@@@ -57,6 -58,134 +57,137 @@@
  #define VCPU_IRQS_MAX_BUF (sizeof(struct kvm_s390_irq) * \
  			   (KVM_MAX_VCPUS + LOCAL_IRQS))
  
++<<<<<<< HEAD
++=======
+ const struct _kvm_stats_desc kvm_vm_stats_desc[] = {
+ 	KVM_GENERIC_VM_STATS(),
+ 	STATS_DESC_COUNTER(VM, inject_io),
+ 	STATS_DESC_COUNTER(VM, inject_float_mchk),
+ 	STATS_DESC_COUNTER(VM, inject_pfault_done),
+ 	STATS_DESC_COUNTER(VM, inject_service_signal),
+ 	STATS_DESC_COUNTER(VM, inject_virtio)
+ };
+ static_assert(ARRAY_SIZE(kvm_vm_stats_desc) ==
+ 		sizeof(struct kvm_vm_stat) / sizeof(u64));
+ 
+ const struct kvm_stats_header kvm_vm_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vm_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vm_stats_desc),
+ };
+ 
+ const struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {
+ 	KVM_GENERIC_VCPU_STATS(),
+ 	STATS_DESC_COUNTER(VCPU, exit_userspace),
+ 	STATS_DESC_COUNTER(VCPU, exit_null),
+ 	STATS_DESC_COUNTER(VCPU, exit_external_request),
+ 	STATS_DESC_COUNTER(VCPU, exit_io_request),
+ 	STATS_DESC_COUNTER(VCPU, exit_external_interrupt),
+ 	STATS_DESC_COUNTER(VCPU, exit_stop_request),
+ 	STATS_DESC_COUNTER(VCPU, exit_validity),
+ 	STATS_DESC_COUNTER(VCPU, exit_instruction),
+ 	STATS_DESC_COUNTER(VCPU, exit_pei),
+ 	STATS_DESC_COUNTER(VCPU, halt_no_poll_steal),
+ 	STATS_DESC_COUNTER(VCPU, instruction_lctl),
+ 	STATS_DESC_COUNTER(VCPU, instruction_lctlg),
+ 	STATS_DESC_COUNTER(VCPU, instruction_stctl),
+ 	STATS_DESC_COUNTER(VCPU, instruction_stctg),
+ 	STATS_DESC_COUNTER(VCPU, exit_program_interruption),
+ 	STATS_DESC_COUNTER(VCPU, exit_instr_and_program),
+ 	STATS_DESC_COUNTER(VCPU, exit_operation_exception),
+ 	STATS_DESC_COUNTER(VCPU, deliver_ckc),
+ 	STATS_DESC_COUNTER(VCPU, deliver_cputm),
+ 	STATS_DESC_COUNTER(VCPU, deliver_external_call),
+ 	STATS_DESC_COUNTER(VCPU, deliver_emergency_signal),
+ 	STATS_DESC_COUNTER(VCPU, deliver_service_signal),
+ 	STATS_DESC_COUNTER(VCPU, deliver_virtio),
+ 	STATS_DESC_COUNTER(VCPU, deliver_stop_signal),
+ 	STATS_DESC_COUNTER(VCPU, deliver_prefix_signal),
+ 	STATS_DESC_COUNTER(VCPU, deliver_restart_signal),
+ 	STATS_DESC_COUNTER(VCPU, deliver_program),
+ 	STATS_DESC_COUNTER(VCPU, deliver_io),
+ 	STATS_DESC_COUNTER(VCPU, deliver_machine_check),
+ 	STATS_DESC_COUNTER(VCPU, exit_wait_state),
+ 	STATS_DESC_COUNTER(VCPU, inject_ckc),
+ 	STATS_DESC_COUNTER(VCPU, inject_cputm),
+ 	STATS_DESC_COUNTER(VCPU, inject_external_call),
+ 	STATS_DESC_COUNTER(VCPU, inject_emergency_signal),
+ 	STATS_DESC_COUNTER(VCPU, inject_mchk),
+ 	STATS_DESC_COUNTER(VCPU, inject_pfault_init),
+ 	STATS_DESC_COUNTER(VCPU, inject_program),
+ 	STATS_DESC_COUNTER(VCPU, inject_restart),
+ 	STATS_DESC_COUNTER(VCPU, inject_set_prefix),
+ 	STATS_DESC_COUNTER(VCPU, inject_stop_signal),
+ 	STATS_DESC_COUNTER(VCPU, instruction_epsw),
+ 	STATS_DESC_COUNTER(VCPU, instruction_gs),
+ 	STATS_DESC_COUNTER(VCPU, instruction_io_other),
+ 	STATS_DESC_COUNTER(VCPU, instruction_lpsw),
+ 	STATS_DESC_COUNTER(VCPU, instruction_lpswe),
+ 	STATS_DESC_COUNTER(VCPU, instruction_pfmf),
+ 	STATS_DESC_COUNTER(VCPU, instruction_ptff),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sck),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sckpf),
+ 	STATS_DESC_COUNTER(VCPU, instruction_stidp),
+ 	STATS_DESC_COUNTER(VCPU, instruction_spx),
+ 	STATS_DESC_COUNTER(VCPU, instruction_stpx),
+ 	STATS_DESC_COUNTER(VCPU, instruction_stap),
+ 	STATS_DESC_COUNTER(VCPU, instruction_iske),
+ 	STATS_DESC_COUNTER(VCPU, instruction_ri),
+ 	STATS_DESC_COUNTER(VCPU, instruction_rrbe),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sske),
+ 	STATS_DESC_COUNTER(VCPU, instruction_ipte_interlock),
+ 	STATS_DESC_COUNTER(VCPU, instruction_stsi),
+ 	STATS_DESC_COUNTER(VCPU, instruction_stfl),
+ 	STATS_DESC_COUNTER(VCPU, instruction_tb),
+ 	STATS_DESC_COUNTER(VCPU, instruction_tpi),
+ 	STATS_DESC_COUNTER(VCPU, instruction_tprot),
+ 	STATS_DESC_COUNTER(VCPU, instruction_tsch),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sie),
+ 	STATS_DESC_COUNTER(VCPU, instruction_essa),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sthyi),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_sense),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_sense_running),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_external_call),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_emergency),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_cond_emergency),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_start),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_stop),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_stop_store_status),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_store_status),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_store_adtl_status),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_arch),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_prefix),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_restart),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_init_cpu_reset),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_cpu_reset),
+ 	STATS_DESC_COUNTER(VCPU, instruction_sigp_unknown),
+ 	STATS_DESC_COUNTER(VCPU, diagnose_10),
+ 	STATS_DESC_COUNTER(VCPU, diagnose_44),
+ 	STATS_DESC_COUNTER(VCPU, diagnose_9c),
+ 	STATS_DESC_COUNTER(VCPU, diagnose_9c_ignored),
+ 	STATS_DESC_COUNTER(VCPU, diagnose_9c_forward),
+ 	STATS_DESC_COUNTER(VCPU, diagnose_258),
+ 	STATS_DESC_COUNTER(VCPU, diagnose_308),
+ 	STATS_DESC_COUNTER(VCPU, diagnose_500),
+ 	STATS_DESC_COUNTER(VCPU, diagnose_other),
+ 	STATS_DESC_COUNTER(VCPU, pfault_sync)
+ };
+ static_assert(ARRAY_SIZE(kvm_vcpu_stats_desc) ==
+ 		sizeof(struct kvm_vcpu_stat) / sizeof(u64));
+ 
+ const struct kvm_stats_header kvm_vcpu_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vcpu_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vcpu_stats_desc),
+ };
+ 
++>>>>>>> ce55c049459c (KVM: stats: Support binary stats retrieval for a VCPU)
  struct kvm_stats_debugfs_item debugfs_entries[] = {
  	VCPU_STAT("userspace_handled", exit_userspace),
  	VCPU_STAT("exit_null", exit_null),
diff --cc arch/x86/kvm/x86.c
index 89e29588b837,53b7c25d6ebc..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -214,6 -223,72 +214,75 @@@ EXPORT_SYMBOL_GPL(host_xss)
  u64 __read_mostly supported_xss;
  EXPORT_SYMBOL_GPL(supported_xss);
  
++<<<<<<< HEAD
++=======
+ const struct _kvm_stats_desc kvm_vm_stats_desc[] = {
+ 	KVM_GENERIC_VM_STATS(),
+ 	STATS_DESC_COUNTER(VM, mmu_shadow_zapped),
+ 	STATS_DESC_COUNTER(VM, mmu_pte_write),
+ 	STATS_DESC_COUNTER(VM, mmu_pde_zapped),
+ 	STATS_DESC_COUNTER(VM, mmu_flooded),
+ 	STATS_DESC_COUNTER(VM, mmu_recycled),
+ 	STATS_DESC_COUNTER(VM, mmu_cache_miss),
+ 	STATS_DESC_ICOUNTER(VM, mmu_unsync),
+ 	STATS_DESC_ICOUNTER(VM, lpages),
+ 	STATS_DESC_ICOUNTER(VM, nx_lpage_splits),
+ 	STATS_DESC_ICOUNTER(VM, max_mmu_page_hash_collisions)
+ };
+ static_assert(ARRAY_SIZE(kvm_vm_stats_desc) ==
+ 		sizeof(struct kvm_vm_stat) / sizeof(u64));
+ 
+ const struct kvm_stats_header kvm_vm_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vm_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vm_stats_desc),
+ };
+ 
+ const struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {
+ 	KVM_GENERIC_VCPU_STATS(),
+ 	STATS_DESC_COUNTER(VCPU, pf_fixed),
+ 	STATS_DESC_COUNTER(VCPU, pf_guest),
+ 	STATS_DESC_COUNTER(VCPU, tlb_flush),
+ 	STATS_DESC_COUNTER(VCPU, invlpg),
+ 	STATS_DESC_COUNTER(VCPU, exits),
+ 	STATS_DESC_COUNTER(VCPU, io_exits),
+ 	STATS_DESC_COUNTER(VCPU, mmio_exits),
+ 	STATS_DESC_COUNTER(VCPU, signal_exits),
+ 	STATS_DESC_COUNTER(VCPU, irq_window_exits),
+ 	STATS_DESC_COUNTER(VCPU, nmi_window_exits),
+ 	STATS_DESC_COUNTER(VCPU, l1d_flush),
+ 	STATS_DESC_COUNTER(VCPU, halt_exits),
+ 	STATS_DESC_COUNTER(VCPU, request_irq_exits),
+ 	STATS_DESC_COUNTER(VCPU, irq_exits),
+ 	STATS_DESC_COUNTER(VCPU, host_state_reload),
+ 	STATS_DESC_COUNTER(VCPU, fpu_reload),
+ 	STATS_DESC_COUNTER(VCPU, insn_emulation),
+ 	STATS_DESC_COUNTER(VCPU, insn_emulation_fail),
+ 	STATS_DESC_COUNTER(VCPU, hypercalls),
+ 	STATS_DESC_COUNTER(VCPU, irq_injections),
+ 	STATS_DESC_COUNTER(VCPU, nmi_injections),
+ 	STATS_DESC_COUNTER(VCPU, req_event),
+ 	STATS_DESC_COUNTER(VCPU, nested_run),
+ 	STATS_DESC_COUNTER(VCPU, directed_yield_attempted),
+ 	STATS_DESC_COUNTER(VCPU, directed_yield_successful),
+ 	STATS_DESC_ICOUNTER(VCPU, guest_mode)
+ };
+ static_assert(ARRAY_SIZE(kvm_vcpu_stats_desc) ==
+ 		sizeof(struct kvm_vcpu_stat) / sizeof(u64));
+ 
+ const struct kvm_stats_header kvm_vcpu_stats_header = {
+ 	.name_size = KVM_STATS_NAME_SIZE,
+ 	.num_desc = ARRAY_SIZE(kvm_vcpu_stats_desc),
+ 	.id_offset = sizeof(struct kvm_stats_header),
+ 	.desc_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE,
+ 	.data_offset = sizeof(struct kvm_stats_header) + KVM_STATS_NAME_SIZE +
+ 		       sizeof(kvm_vcpu_stats_desc),
+ };
+ 
++>>>>>>> ce55c049459c (KVM: stats: Support binary stats retrieval for a VCPU)
  struct kvm_stats_debugfs_item debugfs_entries[] = {
  	VCPU_STAT("pf_fixed", pf_fixed),
  	VCPU_STAT("pf_guest", pf_guest),
diff --cc include/linux/kvm_host.h
index 5dcd8faa29b8,9e75afef16b0..000000000000
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@@ -1218,13 -1277,106 +1219,106 @@@ struct kvm_stats_debugfs_item 
  #define KVM_DBGFS_GET_MODE(dbgfs_item)                                         \
  	((dbgfs_item)->mode ? (dbgfs_item)->mode : 0644)
  
 -#define VM_STAT(n, x, ...)						       \
 +#define VM_STAT(n, x, ...) 							\
  	{ n, offsetof(struct kvm, stat.x), KVM_STAT_VM, ## __VA_ARGS__ }
 -#define VCPU_STAT(n, x, ...)						       \
 +#define VCPU_STAT(n, x, ...)							\
  	{ n, offsetof(struct kvm_vcpu, stat.x), KVM_STAT_VCPU, ## __VA_ARGS__ }
  
++<<<<<<< HEAD
++extern struct kvm_stats_debugfs_item debugfs_entries[];
++extern struct dentry *kvm_debugfs_dir;
++=======
+ #define STATS_DESC_COMMON(type, unit, base, exp)			       \
+ 	.flags = type | unit | base |					       \
+ 		 BUILD_BUG_ON_ZERO(type & ~KVM_STATS_TYPE_MASK) |	       \
+ 		 BUILD_BUG_ON_ZERO(unit & ~KVM_STATS_UNIT_MASK) |	       \
+ 		 BUILD_BUG_ON_ZERO(base & ~KVM_STATS_BASE_MASK),	       \
+ 	.exponent = exp,						       \
+ 	.size = 1
+ 
+ #define VM_GENERIC_STATS_DESC(stat, type, unit, base, exp)		       \
+ 	{								       \
+ 		{							       \
+ 			STATS_DESC_COMMON(type, unit, base, exp),	       \
+ 			.offset = offsetof(struct kvm_vm_stat, generic.stat)   \
+ 		},							       \
+ 		.name = #stat,						       \
+ 	}
+ #define VCPU_GENERIC_STATS_DESC(stat, type, unit, base, exp)		       \
+ 	{								       \
+ 		{							       \
+ 			STATS_DESC_COMMON(type, unit, base, exp),	       \
+ 			.offset = offsetof(struct kvm_vcpu_stat, generic.stat) \
+ 		},							       \
+ 		.name = #stat,						       \
+ 	}
+ #define VM_STATS_DESC(stat, type, unit, base, exp)			       \
+ 	{								       \
+ 		{							       \
+ 			STATS_DESC_COMMON(type, unit, base, exp),	       \
+ 			.offset = offsetof(struct kvm_vm_stat, stat)	       \
+ 		},							       \
+ 		.name = #stat,						       \
+ 	}
+ #define VCPU_STATS_DESC(stat, type, unit, base, exp)			       \
+ 	{								       \
+ 		{							       \
+ 			STATS_DESC_COMMON(type, unit, base, exp),	       \
+ 			.offset = offsetof(struct kvm_vcpu_stat, stat)	       \
+ 		},							       \
+ 		.name = #stat,						       \
+ 	}
+ /* SCOPE: VM, VM_GENERIC, VCPU, VCPU_GENERIC */
+ #define STATS_DESC(SCOPE, stat, type, unit, base, exp)			       \
+ 	SCOPE##_STATS_DESC(stat, type, unit, base, exp)
+ 
+ #define STATS_DESC_CUMULATIVE(SCOPE, name, unit, base, exponent)	       \
+ 	STATS_DESC(SCOPE, name, KVM_STATS_TYPE_CUMULATIVE, unit, base, exponent)
+ #define STATS_DESC_INSTANT(SCOPE, name, unit, base, exponent)		       \
+ 	STATS_DESC(SCOPE, name, KVM_STATS_TYPE_INSTANT, unit, base, exponent)
+ #define STATS_DESC_PEAK(SCOPE, name, unit, base, exponent)		       \
+ 	STATS_DESC(SCOPE, name, KVM_STATS_TYPE_PEAK, unit, base, exponent)
+ 
+ /* Cumulative counter, read/write */
+ #define STATS_DESC_COUNTER(SCOPE, name)					       \
+ 	STATS_DESC_CUMULATIVE(SCOPE, name, KVM_STATS_UNIT_NONE,		       \
+ 		KVM_STATS_BASE_POW10, 0)
+ /* Instantaneous counter, read only */
+ #define STATS_DESC_ICOUNTER(SCOPE, name)				       \
+ 	STATS_DESC_INSTANT(SCOPE, name, KVM_STATS_UNIT_NONE,		       \
+ 		KVM_STATS_BASE_POW10, 0)
+ /* Peak counter, read/write */
+ #define STATS_DESC_PCOUNTER(SCOPE, name)				       \
+ 	STATS_DESC_PEAK(SCOPE, name, KVM_STATS_UNIT_NONE,		       \
+ 		KVM_STATS_BASE_POW10, 0)
+ 
+ /* Cumulative time in nanosecond */
+ #define STATS_DESC_TIME_NSEC(SCOPE, name)				       \
+ 	STATS_DESC_CUMULATIVE(SCOPE, name, KVM_STATS_UNIT_SECONDS,	       \
+ 		KVM_STATS_BASE_POW10, -9)
+ 
+ #define KVM_GENERIC_VM_STATS()						       \
+ 	STATS_DESC_COUNTER(VM_GENERIC, remote_tlb_flush)
+ 
+ #define KVM_GENERIC_VCPU_STATS()					       \
+ 	STATS_DESC_COUNTER(VCPU_GENERIC, halt_successful_poll),		       \
+ 	STATS_DESC_COUNTER(VCPU_GENERIC, halt_attempted_poll),		       \
+ 	STATS_DESC_COUNTER(VCPU_GENERIC, halt_poll_invalid),		       \
+ 	STATS_DESC_COUNTER(VCPU_GENERIC, halt_wakeup),			       \
+ 	STATS_DESC_TIME_NSEC(VCPU_GENERIC, halt_poll_success_ns),	       \
+ 	STATS_DESC_TIME_NSEC(VCPU_GENERIC, halt_poll_fail_ns)
+ 
  extern struct kvm_stats_debugfs_item debugfs_entries[];
  extern struct dentry *kvm_debugfs_dir;
+ ssize_t kvm_stats_read(char *id, const struct kvm_stats_header *header,
+ 		       const struct _kvm_stats_desc *desc,
+ 		       void *stats, size_t size_stats,
+ 		       char __user *user_buffer, size_t size, loff_t *offset);
+ extern const struct kvm_stats_header kvm_vm_stats_header;
+ extern const struct _kvm_stats_desc kvm_vm_stats_desc[];
+ extern const struct kvm_stats_header kvm_vcpu_stats_header;
+ extern const struct _kvm_stats_desc kvm_vcpu_stats_desc[];
++>>>>>>> ce55c049459c (KVM: stats: Support binary stats retrieval for a VCPU)
  
  #if defined(CONFIG_MMU_NOTIFIER) && defined(KVM_ARCH_WANT_MMU_NOTIFIER)
  static inline int mmu_notifier_retry(struct kvm *kvm, unsigned long mmu_seq)
* Unmerged path arch/arm64/kvm/guest.c
* Unmerged path arch/mips/kvm/mips.c
* Unmerged path arch/powerpc/kvm/book3s.c
* Unmerged path arch/powerpc/kvm/booke.c
* Unmerged path arch/s390/kvm/kvm-s390.c
* Unmerged path arch/x86/kvm/x86.c
* Unmerged path include/linux/kvm_host.h
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 9d090cc95b7f..a71e51d88c79 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -3301,6 +3301,10 @@ static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)
 	vcpu->vcpu_idx = atomic_read(&kvm->online_vcpus);
 	BUG_ON(kvm->vcpus[vcpu->vcpu_idx]);
 
+	/* Fill the stats id string for the vcpu */
+	snprintf(vcpu->stats_id, sizeof(vcpu->stats_id), "kvm-%d/vcpu-%d",
+		 task_pid_nr(current), id);
+
 	/* Now it's all set up, let userspace reach it */
 	kvm_get_kvm(kvm);
 	r = create_vcpu_fd(vcpu);
@@ -3350,6 +3354,44 @@ static int kvm_vcpu_ioctl_set_sigmask(struct kvm_vcpu *vcpu, sigset_t *sigset)
 	return 0;
 }
 
+static ssize_t kvm_vcpu_stats_read(struct file *file, char __user *user_buffer,
+			      size_t size, loff_t *offset)
+{
+	struct kvm_vcpu *vcpu = file->private_data;
+
+	return kvm_stats_read(vcpu->stats_id, &kvm_vcpu_stats_header,
+			&kvm_vcpu_stats_desc[0], &vcpu->stat,
+			sizeof(vcpu->stat), user_buffer, size, offset);
+}
+
+static const struct file_operations kvm_vcpu_stats_fops = {
+	.read = kvm_vcpu_stats_read,
+	.llseek = noop_llseek,
+};
+
+static int kvm_vcpu_ioctl_get_stats_fd(struct kvm_vcpu *vcpu)
+{
+	int fd;
+	struct file *file;
+	char name[15 + ITOA_MAX_LEN + 1];
+
+	snprintf(name, sizeof(name), "kvm-vcpu-stats:%d", vcpu->vcpu_id);
+
+	fd = get_unused_fd_flags(O_CLOEXEC);
+	if (fd < 0)
+		return fd;
+
+	file = anon_inode_getfile(name, &kvm_vcpu_stats_fops, vcpu, O_RDONLY);
+	if (IS_ERR(file)) {
+		put_unused_fd(fd);
+		return PTR_ERR(file);
+	}
+	file->f_mode |= FMODE_PREAD;
+	fd_install(fd, file);
+
+	return fd;
+}
+
 static long kvm_vcpu_ioctl(struct file *filp,
 			   unsigned int ioctl, unsigned long arg)
 {
@@ -3547,6 +3589,10 @@ static long kvm_vcpu_ioctl(struct file *filp,
 		r = kvm_arch_vcpu_ioctl_set_fpu(vcpu, fpu);
 		break;
 	}
+	case KVM_GET_STATS_FD: {
+		r = kvm_vcpu_ioctl_get_stats_fd(vcpu);
+		break;
+	}
 	default:
 		r = kvm_arch_vcpu_ioctl(filp, ioctl, arg);
 	}
@@ -3805,6 +3851,8 @@ static long kvm_vm_ioctl_check_extension_generic(struct kvm *kvm, long arg)
 #else
 		return 0;
 #endif
+	case KVM_CAP_BINARY_STATS_FD:
+		return 1;
 	default:
 		break;
 	}
@@ -5065,7 +5113,8 @@ int kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align,
 		kmem_cache_create_usercopy("kvm_vcpu", vcpu_size, vcpu_align,
 					   SLAB_ACCOUNT,
 					   offsetof(struct kvm_vcpu, arch),
-					   sizeof_field(struct kvm_vcpu, arch),
+					   offsetofend(struct kvm_vcpu, stats_id)
+					   - offsetof(struct kvm_vcpu, arch),
 					   NULL);
 	if (!kvm_vcpu_cache) {
 		r = -ENOMEM;
