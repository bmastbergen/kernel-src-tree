i2c: drivers: Use generic definitions for bus frequencies

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 90224e6468e15d5eb22a10ae1849cf8ca2e7360a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/90224e64.failed

Since we have generic definitions for bus frequencies, let's use them.

	Reviewed-by: Nicolas Saenz Julienne <nsaenzjulienne@suse.de>
	Acked-by: Robert Richter <rrichter@marvell.com>
	Reviewed-by: Thor Thayer <thor.thayer@linux.intel.com>
	Acked-by: Elie Morisse <syniurge@gmail.com>
	Acked-by: Nehal Shah <nehal-bakulchandra.shah@amd.com>
	Reviewed-by: Brendan Higgins <brendanhiggins@google.com>
	Acked-by: Scott Branden <scott.branden@broadcom.com>
	Reviewed-by: Mika Westerberg <mika.westerberg@linux.intel.com>
	Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
	Acked-by: Baruch Siach <baruch@tkos.co.il>
	Reviewed-by: Guenter Roeck <linux@roeck-us.net>
	Acked-by: Oleksij Rempel <o.rempel@pengutronix.de>
	Acked-by: Vladimir Zapolskiy <vz@mleia.com>
	Acked-by: Gregory CLEMENT <gregory.clement@bootlin.com>
	Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
	Reviewed-by: Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>
	Reviewed-by: Chris Brandt <chris.brandt@renesas.com>
	Reviewed-by: Baolin Wang <baolin.wang7@gmail.com>
	Reviewed-by: Pierre-Yves MORDRET <pierre-yves.mordret@st.com>
	Acked-by: Patrice Chotard <patrice.chotard@st.com>
	Acked-by: Ard Biesheuvel <ardb@kernel.org>
	Reviewed-by: Dmitry Osipenko <digetx@gmail.com>
	Acked-by: Masahiro Yamada <yamada.masahiro@socionext.com>
	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
(cherry picked from commit 90224e6468e15d5eb22a10ae1849cf8ca2e7360a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/busses/i2c-amd-mp2-plat.c
#	drivers/i2c/busses/i2c-bcm-iproc.c
#	drivers/i2c/busses/i2c-bcm2835.c
#	drivers/i2c/busses/i2c-mt65xx.c
#	drivers/i2c/busses/i2c-mt7621.c
#	drivers/i2c/busses/i2c-owl.c
#	drivers/i2c/busses/i2c-riic.c
#	drivers/i2c/busses/i2c-tegra.c
diff --cc drivers/i2c/busses/i2c-bcm-iproc.c
index 4c8c3bc4669c,44be0926b566..000000000000
--- a/drivers/i2c/busses/i2c-bcm-iproc.c
+++ b/drivers/i2c/busses/i2c-bcm-iproc.c
@@@ -425,10 -874,10 +425,17 @@@ static int bcm_iproc_i2c_cfg_speed(stru
  	}
  
  	iproc_i2c->bus_speed = bus_speed;
++<<<<<<< HEAD
 +	val = readl(iproc_i2c->base + TIM_CFG_OFFSET);
 +	val &= ~(1 << TIM_CFG_MODE_400_SHIFT);
 +	val |= (bus_speed == 400000) << TIM_CFG_MODE_400_SHIFT;
 +	writel(val, iproc_i2c->base + TIM_CFG_OFFSET);
++=======
+ 	val = iproc_i2c_rd_reg(iproc_i2c, TIM_CFG_OFFSET);
+ 	val &= ~BIT(TIM_CFG_MODE_400_SHIFT);
+ 	val |= (bus_speed == I2C_MAX_FAST_MODE_FREQ) << TIM_CFG_MODE_400_SHIFT;
+ 	iproc_i2c_wr_reg(iproc_i2c, TIM_CFG_OFFSET, val);
++>>>>>>> 90224e6468e1 (i2c: drivers: Use generic definitions for bus frequencies)
  
  	dev_info(iproc_i2c->device, "bus set to %u Hz\n", bus_speed);
  
@@@ -538,10 -1027,10 +545,17 @@@ static int bcm_iproc_i2c_resume(struct 
  		return ret;
  
  	/* configure to the desired bus speed */
++<<<<<<< HEAD
 +	val = readl(iproc_i2c->base + TIM_CFG_OFFSET);
 +	val &= ~(1 << TIM_CFG_MODE_400_SHIFT);
 +	val |= (iproc_i2c->bus_speed == 400000) << TIM_CFG_MODE_400_SHIFT;
 +	writel(val, iproc_i2c->base + TIM_CFG_OFFSET);
++=======
+ 	val = iproc_i2c_rd_reg(iproc_i2c, TIM_CFG_OFFSET);
+ 	val &= ~BIT(TIM_CFG_MODE_400_SHIFT);
+ 	val |= (iproc_i2c->bus_speed == I2C_MAX_FAST_MODE_FREQ) << TIM_CFG_MODE_400_SHIFT;
+ 	iproc_i2c_wr_reg(iproc_i2c, TIM_CFG_OFFSET, val);
++>>>>>>> 90224e6468e1 (i2c: drivers: Use generic definitions for bus frequencies)
  
  	bcm_iproc_i2c_enable_disable(iproc_i2c, true);
  
diff --cc drivers/i2c/busses/i2c-bcm2835.c
index 44deae78913e,d9b86fcc3825..000000000000
--- a/drivers/i2c/busses/i2c-bcm2835.c
+++ b/drivers/i2c/busses/i2c-bcm2835.c
@@@ -359,7 -439,19 +359,23 @@@ static int bcm2835_i2c_probe(struct pla
  	if (ret < 0) {
  		dev_warn(&pdev->dev,
  			 "Could not read clock-frequency property\n");
++<<<<<<< HEAD
 +		i2c_dev->bus_clk_rate = 100000;
++=======
+ 		bus_clk_rate = I2C_MAX_STANDARD_MODE_FREQ;
+ 	}
+ 
+ 	ret = clk_set_rate_exclusive(i2c_dev->bus_clk, bus_clk_rate);
+ 	if (ret < 0) {
+ 		dev_err(&pdev->dev, "Could not set clock frequency\n");
+ 		return ret;
+ 	}
+ 
+ 	ret = clk_prepare_enable(i2c_dev->bus_clk);
+ 	if (ret) {
+ 		dev_err(&pdev->dev, "Couldn't prepare clock");
+ 		return ret;
++>>>>>>> 90224e6468e1 (i2c: drivers: Use generic definitions for bus frequencies)
  	}
  
  	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
diff --cc drivers/i2c/busses/i2c-mt65xx.c
index 1e57f58fcb00,0ca6c38a15eb..000000000000
--- a/drivers/i2c/busses/i2c-mt65xx.c
+++ b/drivers/i2c/busses/i2c-mt65xx.c
@@@ -396,10 -511,10 +393,15 @@@ static int mtk_i2c_set_speed(struct mtk
  	clk_src = parent_clk / i2c->clk_src_div;
  	target_speed = i2c->speed_hz;
  
- 	if (target_speed > MAX_FS_MODE_SPEED) {
+ 	if (target_speed > I2C_MAX_FAST_MODE_FREQ) {
  		/* Set master code speed register */
++<<<<<<< HEAD
 +		ret = mtk_i2c_calculate_speed(i2c, clk_src, MAX_FS_MODE_SPEED,
 +					      &step_cnt, &sample_cnt);
++=======
+ 		ret = mtk_i2c_calculate_speed(i2c, clk_src, I2C_MAX_FAST_MODE_FREQ,
+ 					      &l_step_cnt, &l_sample_cnt);
++>>>>>>> 90224e6468e1 (i2c: drivers: Use generic definitions for bus frequencies)
  		if (ret < 0)
  			return ret;
  
@@@ -452,33 -576,34 +454,42 @@@ static int mtk_i2c_do_transfer(struct m
  
  	reinit_completion(&i2c->msg_complete);
  
 -	control_reg = mtk_i2c_readw(i2c, OFFSET_CONTROL) &
 +	control_reg = readw(i2c->base + OFFSET_CONTROL) &
  			~(I2C_CONTROL_DIR_CHANGE | I2C_CONTROL_RS);
++<<<<<<< HEAD
 +	if ((i2c->speed_hz > 400000) || (left_num >= 1))
++=======
+ 	if ((i2c->speed_hz > I2C_MAX_FAST_MODE_FREQ) || (left_num >= 1))
++>>>>>>> 90224e6468e1 (i2c: drivers: Use generic definitions for bus frequencies)
  		control_reg |= I2C_CONTROL_RS;
  
  	if (i2c->op == I2C_MASTER_WRRD)
  		control_reg |= I2C_CONTROL_DIR_CHANGE | I2C_CONTROL_RS;
  
 -	mtk_i2c_writew(i2c, control_reg, OFFSET_CONTROL);
 +	writew(control_reg, i2c->base + OFFSET_CONTROL);
  
  	/* set start condition */
++<<<<<<< HEAD
 +	if (i2c->speed_hz <= 100000)
 +		writew(I2C_ST_START_CON, i2c->base + OFFSET_EXT_CONF);
++=======
+ 	if (i2c->speed_hz <= I2C_MAX_STANDARD_MODE_FREQ)
+ 		mtk_i2c_writew(i2c, I2C_ST_START_CON, OFFSET_EXT_CONF);
++>>>>>>> 90224e6468e1 (i2c: drivers: Use generic definitions for bus frequencies)
  	else
 -		mtk_i2c_writew(i2c, I2C_FS_START_CON, OFFSET_EXT_CONF);
 +		writew(I2C_FS_START_CON, i2c->base + OFFSET_EXT_CONF);
  
  	addr_reg = i2c_8bit_addr_from_msg(msgs);
 -	mtk_i2c_writew(i2c, addr_reg, OFFSET_SLAVE_ADDR);
 +	writew(addr_reg, i2c->base + OFFSET_SLAVE_ADDR);
  
  	/* Clear interrupt status */
 -	mtk_i2c_writew(i2c, restart_flag | I2C_HS_NACKERR | I2C_ACKERR |
 -			    I2C_ARB_LOST | I2C_TRANSAC_COMP, OFFSET_INTR_STAT);
 -
 -	mtk_i2c_writew(i2c, I2C_FIFO_ADDR_CLR, OFFSET_FIFO_ADDR_CLR);
 +	writew(restart_flag | I2C_HS_NACKERR | I2C_ACKERR |
 +	       I2C_TRANSAC_COMP, i2c->base + OFFSET_INTR_STAT);
 +	writew(I2C_FIFO_ADDR_CLR, i2c->base + OFFSET_FIFO_ADDR_CLR);
  
  	/* Enable interrupt */
 -	mtk_i2c_writew(i2c, restart_flag | I2C_HS_NACKERR | I2C_ACKERR |
 -			    I2C_ARB_LOST | I2C_TRANSAC_COMP, OFFSET_INTR_MASK);
 +	writew(restart_flag | I2C_HS_NACKERR | I2C_ACKERR |
 +	       I2C_TRANSAC_COMP, i2c->base + OFFSET_INTR_MASK);
  
  	/* Set transfer and transaction len */
  	if (i2c->op == I2C_MASTER_WRRD) {
diff --cc drivers/i2c/busses/i2c-riic.c
index 5f1fca7880b1,4eccc0f69861..000000000000
--- a/drivers/i2c/busses/i2c-riic.c
+++ b/drivers/i2c/busses/i2c-riic.c
@@@ -288,16 -285,14 +288,23 @@@ static int riic_init_hw(struct riic_de
  	unsigned long rate;
  	int total_ticks, cks, brl, brh;
  
 -	pm_runtime_get_sync(riic->adapter.dev.parent);
 +	ret = clk_prepare_enable(riic->clk);
 +	if (ret)
 +		return ret;
  
- 	if (t->bus_freq_hz > 400000) {
+ 	if (t->bus_freq_hz > I2C_MAX_FAST_MODE_FREQ) {
  		dev_err(&riic->adapter.dev,
++<<<<<<< HEAD
 +			"unsupported bus speed (%dHz). 400000 max\n",
 +			t->bus_freq_hz);
 +		clk_disable_unprepare(riic->clk);
 +		return -EINVAL;
++=======
+ 			"unsupported bus speed (%dHz). %d max\n",
+ 			t->bus_freq_hz, I2C_MAX_FAST_MODE_FREQ);
+ 		ret = -EINVAL;
+ 		goto out;
++>>>>>>> 90224e6468e1 (i2c: drivers: Use generic definitions for bus frequencies)
  	}
  
  	rate = clk_get_rate(riic->clk);
diff --cc drivers/i2c/busses/i2c-tegra.c
index 797def5319f1,4c4d17ddc96b..000000000000
--- a/drivers/i2c/busses/i2c-tegra.c
+++ b/drivers/i2c/busses/i2c-tegra.c
@@@ -115,6 -107,33 +115,36 @@@
  
  #define I2C_CONFIG_LOAD_TIMEOUT			1000000
  
++<<<<<<< HEAD
++=======
+ #define I2C_MST_FIFO_CONTROL			0x0b4
+ #define I2C_MST_FIFO_CONTROL_RX_FLUSH		BIT(0)
+ #define I2C_MST_FIFO_CONTROL_TX_FLUSH		BIT(1)
+ #define I2C_MST_FIFO_CONTROL_RX_TRIG(x)		(((x) - 1) <<  4)
+ #define I2C_MST_FIFO_CONTROL_TX_TRIG(x)		(((x) - 1) << 16)
+ 
+ #define I2C_MST_FIFO_STATUS			0x0b8
+ #define I2C_MST_FIFO_STATUS_RX_MASK		0xff
+ #define I2C_MST_FIFO_STATUS_RX_SHIFT		0
+ #define I2C_MST_FIFO_STATUS_TX_MASK		0xff0000
+ #define I2C_MST_FIFO_STATUS_TX_SHIFT		16
+ 
+ #define I2C_INTERFACE_TIMING_0			0x94
+ #define I2C_THIGH_SHIFT				8
+ #define I2C_INTERFACE_TIMING_1			0x98
+ 
+ /* Packet header size in bytes */
+ #define I2C_PACKET_HEADER_SIZE			12
+ 
+ /*
+  * I2C Controller will use PIO mode for transfers up to 32 bytes in order to
+  * avoid DMA overhead, otherwise external APB DMA controller will be used.
+  * Note that the actual MAX PIO length is 20 bytes because 32 bytes include
+  * I2C_PACKET_HEADER_SIZE.
+  */
+ #define I2C_PIO_MODE_PREFERRED_LEN		32
+ 
++>>>>>>> 90224e6468e1 (i2c: drivers: Use generic definitions for bus frequencies)
  /*
   * msg_end_type: The bus control which need to be send at end of transfer.
   * @MSG_END_STOP: Send stop pulse at end of transfer.
@@@ -507,6 -733,41 +537,44 @@@ static int tegra_i2c_init(struct tegra_
  					I2C_CLK_DIVISOR_STD_FAST_MODE_SHIFT;
  	i2c_writel(i2c_dev, clk_divisor, I2C_CLK_DIVISOR);
  
++<<<<<<< HEAD
++=======
+ 	if (i2c_dev->bus_clk_rate > I2C_MAX_STANDARD_MODE_FREQ &&
+ 	    i2c_dev->bus_clk_rate <= I2C_MAX_FAST_MODE_PLUS_FREQ) {
+ 		tlow = i2c_dev->hw->tlow_fast_fastplus_mode;
+ 		thigh = i2c_dev->hw->thigh_fast_fastplus_mode;
+ 		tsu_thd = i2c_dev->hw->setup_hold_time_fast_fast_plus_mode;
+ 	} else {
+ 		tlow = i2c_dev->hw->tlow_std_mode;
+ 		thigh = i2c_dev->hw->thigh_std_mode;
+ 		tsu_thd = i2c_dev->hw->setup_hold_time_std_mode;
+ 	}
+ 
+ 	if (i2c_dev->hw->has_interface_timing_reg) {
+ 		val = (thigh << I2C_THIGH_SHIFT) | tlow;
+ 		i2c_writel(i2c_dev, val, I2C_INTERFACE_TIMING_0);
+ 	}
+ 
+ 	/*
+ 	 * configure setup and hold times only when tsu_thd is non-zero.
+ 	 * otherwise, preserve the chip default values
+ 	 */
+ 	if (i2c_dev->hw->has_interface_timing_reg && tsu_thd)
+ 		i2c_writel(i2c_dev, tsu_thd, I2C_INTERFACE_TIMING_1);
+ 
+ 	if (!clk_reinit) {
+ 		clk_multiplier = (tlow + thigh + 2);
+ 		clk_multiplier *= (i2c_dev->clk_divisor_non_hs_mode + 1);
+ 		err = clk_set_rate(i2c_dev->div_clk,
+ 				   i2c_dev->bus_clk_rate * clk_multiplier);
+ 		if (err) {
+ 			dev_err(i2c_dev->dev,
+ 				"failed changing clock rate: %d\n", err);
+ 			return err;
+ 		}
+ 	}
+ 
++>>>>>>> 90224e6468e1 (i2c: drivers: Use generic definitions for bus frequencies)
  	if (!i2c_dev->is_dvc) {
  		u32 sl_cfg = i2c_readl(i2c_dev, I2C_SL_CNFG);
  
@@@ -771,14 -1332,15 +839,14 @@@ static void tegra_i2c_parse_dt(struct t
  {
  	struct device_node *np = i2c_dev->dev->of_node;
  	int ret;
 -	bool multi_mode;
  
  	ret = of_property_read_u32(np, "clock-frequency",
 -				   &i2c_dev->bus_clk_rate);
 +			&i2c_dev->bus_clk_rate);
  	if (ret)
- 		i2c_dev->bus_clk_rate = 100000; /* default clock rate */
+ 		i2c_dev->bus_clk_rate = I2C_MAX_STANDARD_MODE_FREQ; /* default clock rate */
  
 -	multi_mode = of_property_read_bool(np, "multi-master");
 -	i2c_dev->is_multimaster_mode = multi_mode;
 +	i2c_dev->is_multimaster_mode = of_property_read_bool(np,
 +			"multi-master");
  }
  
  static const struct i2c_algorithm tegra_i2c_algo = {
@@@ -938,20 -1636,17 +1006,34 @@@ static int tegra_i2c_probe(struct platf
  		}
  	}
  
++<<<<<<< HEAD
 +	i2c_dev->clk_divisor_non_hs_mode =
 +			i2c_dev->hw->clk_divisor_std_fast_mode;
 +	if (i2c_dev->hw->clk_divisor_fast_plus_mode &&
 +		(i2c_dev->bus_clk_rate == 1000000))
 +		i2c_dev->clk_divisor_non_hs_mode =
 +			i2c_dev->hw->clk_divisor_fast_plus_mode;
 +
 +	clk_multiplier *= (i2c_dev->clk_divisor_non_hs_mode + 1);
 +	ret = clk_set_rate(i2c_dev->div_clk,
 +			   i2c_dev->bus_clk_rate * clk_multiplier);
 +	if (ret) {
 +		dev_err(i2c_dev->dev, "Clock rate change failed %d\n", ret);
 +		goto unprepare_fast_clk;
 +	}
++=======
+ 	if (i2c_dev->bus_clk_rate > I2C_MAX_FAST_MODE_FREQ &&
+ 	    i2c_dev->bus_clk_rate <= I2C_MAX_FAST_MODE_PLUS_FREQ)
+ 		i2c_dev->clk_divisor_non_hs_mode =
+ 				i2c_dev->hw->clk_divisor_fast_plus_mode;
+ 	else if (i2c_dev->bus_clk_rate > I2C_MAX_STANDARD_MODE_FREQ &&
+ 		 i2c_dev->bus_clk_rate <= I2C_MAX_FAST_MODE_FREQ)
+ 		i2c_dev->clk_divisor_non_hs_mode =
+ 				i2c_dev->hw->clk_divisor_fast_mode;
+ 	else
+ 		i2c_dev->clk_divisor_non_hs_mode =
+ 				i2c_dev->hw->clk_divisor_std_mode;
++>>>>>>> 90224e6468e1 (i2c: drivers: Use generic definitions for bus frequencies)
  
  	ret = clk_prepare(i2c_dev->div_clk);
  	if (ret < 0) {
* Unmerged path drivers/i2c/busses/i2c-amd-mp2-plat.c
* Unmerged path drivers/i2c/busses/i2c-mt7621.c
* Unmerged path drivers/i2c/busses/i2c-owl.c
diff --git a/drivers/i2c/busses/i2c-altera.c b/drivers/i2c/busses/i2c-altera.c
index f5e1941e65b5..24f5aaeed490 100644
--- a/drivers/i2c/busses/i2c-altera.c
+++ b/drivers/i2c/busses/i2c-altera.c
@@ -158,7 +158,7 @@ static void altr_i2c_init(struct altr_i2c_dev *idev)
 		  (ALTR_I2C_THRESHOLD << ALTR_I2C_CTRL_TCT_SHFT);
 	u32 t_high, t_low;
 
-	if (idev->bus_clk_rate <= 100000) {
+	if (idev->bus_clk_rate <= I2C_MAX_STANDARD_MODE_FREQ) {
 		tmp &= ~ALTR_I2C_CTRL_BSPEED;
 		/* Standard mode SCL 50/50 */
 		t_high = divisor * 1 / 2;
@@ -434,10 +434,10 @@ static int altr_i2c_probe(struct platform_device *pdev)
 				       &idev->bus_clk_rate);
 	if (val) {
 		dev_err(&pdev->dev, "Default to 100kHz\n");
-		idev->bus_clk_rate = 100000;	/* default clock rate */
+		idev->bus_clk_rate = I2C_MAX_STANDARD_MODE_FREQ;	/* default clock rate */
 	}
 
-	if (idev->bus_clk_rate > 400000) {
+	if (idev->bus_clk_rate > I2C_MAX_FAST_MODE_FREQ) {
 		dev_err(&pdev->dev, "invalid clock-frequency %d\n",
 			idev->bus_clk_rate);
 		return -EINVAL;
* Unmerged path drivers/i2c/busses/i2c-amd-mp2-plat.c
diff --git a/drivers/i2c/busses/i2c-aspeed.c b/drivers/i2c/busses/i2c-aspeed.c
index 60e4d0e939a3..657c55451cb5 100644
--- a/drivers/i2c/busses/i2c-aspeed.c
+++ b/drivers/i2c/busses/i2c-aspeed.c
@@ -861,7 +861,7 @@ static int aspeed_i2c_probe_bus(struct platform_device *pdev)
 	if (ret < 0) {
 		dev_err(&pdev->dev,
 			"Could not read bus-frequency property\n");
-		bus->bus_frequency = 100000;
+		bus->bus_frequency = I2C_MAX_STANDARD_MODE_FREQ;
 	}
 
 	match = of_match_node(aspeed_i2c_bus_of_table, pdev->dev.of_node);
diff --git a/drivers/i2c/busses/i2c-axxia.c b/drivers/i2c/busses/i2c-axxia.c
index 8e60048a33f8..1f054dd1b522 100644
--- a/drivers/i2c/busses/i2c-axxia.c
+++ b/drivers/i2c/busses/i2c-axxia.c
@@ -158,7 +158,7 @@ static int axxia_i2c_init(struct axxia_i2c_dev *idev)
 	/* Enable Master Mode */
 	writel(0x1, idev->base + GLOBAL_CONTROL);
 
-	if (idev->bus_clk_rate <= 100000) {
+	if (idev->bus_clk_rate <= I2C_MAX_STANDARD_MODE_FREQ) {
 		/* Standard mode SCL 50/50, tSU:DAT = 250 ns */
 		t_high = divisor * 1 / 2;
 		t_low = divisor * 1 / 2;
@@ -531,7 +531,7 @@ static int axxia_i2c_probe(struct platform_device *pdev)
 
 	of_property_read_u32(np, "clock-frequency", &idev->bus_clk_rate);
 	if (idev->bus_clk_rate == 0)
-		idev->bus_clk_rate = 100000;	/* default clock rate */
+		idev->bus_clk_rate = I2C_MAX_STANDARD_MODE_FREQ;	/* default clock rate */
 
 	ret = clk_prepare_enable(idev->i2c_clk);
 	if (ret) {
* Unmerged path drivers/i2c/busses/i2c-bcm-iproc.c
diff --git a/drivers/i2c/busses/i2c-bcm-kona.c b/drivers/i2c/busses/i2c-bcm-kona.c
index 4e489a9d16fb..572aebbb254e 100644
--- a/drivers/i2c/busses/i2c-bcm-kona.c
+++ b/drivers/i2c/busses/i2c-bcm-kona.c
@@ -722,16 +722,16 @@ static int bcm_kona_i2c_assign_bus_speed(struct bcm_kona_i2c_dev *dev)
 	}
 
 	switch (bus_speed) {
-	case 100000:
+	case I2C_MAX_STANDARD_MODE_FREQ:
 		dev->std_cfg = &std_cfg_table[BCM_SPD_100K];
 		break;
-	case 400000:
+	case I2C_MAX_FAST_MODE_FREQ:
 		dev->std_cfg = &std_cfg_table[BCM_SPD_400K];
 		break;
-	case 1000000:
+	case I2C_MAX_FAST_MODE_PLUS_FREQ:
 		dev->std_cfg = &std_cfg_table[BCM_SPD_1MHZ];
 		break;
-	case 3400000:
+	case I2C_MAX_HIGH_SPEED_MODE_FREQ:
 		/* Send mastercode at 100k */
 		dev->std_cfg = &std_cfg_table[BCM_SPD_100K];
 		dev->hs_cfg = &hs_cfg_table[BCM_SPD_3P4MHZ];
* Unmerged path drivers/i2c/busses/i2c-bcm2835.c
diff --git a/drivers/i2c/busses/i2c-cadence.c b/drivers/i2c/busses/i2c-cadence.c
index b13605718291..3dce1ca68a38 100644
--- a/drivers/i2c/busses/i2c-cadence.c
+++ b/drivers/i2c/busses/i2c-cadence.c
@@ -109,9 +109,6 @@
 
 #define DRIVER_NAME		"cdns-i2c"
 
-#define CDNS_I2C_SPEED_MAX	400000
-#define CDNS_I2C_SPEED_DEFAULT	100000
-
 #define CDNS_I2C_DIVA_MAX	4
 #define CDNS_I2C_DIVB_MAX	64
 
@@ -940,8 +937,8 @@ static int cdns_i2c_probe(struct platform_device *pdev)
 
 	ret = of_property_read_u32(pdev->dev.of_node, "clock-frequency",
 			&id->i2c_clk);
-	if (ret || (id->i2c_clk > CDNS_I2C_SPEED_MAX))
-		id->i2c_clk = CDNS_I2C_SPEED_DEFAULT;
+	if (ret || (id->i2c_clk > I2C_MAX_FAST_MODE_FREQ))
+		id->i2c_clk = I2C_MAX_STANDARD_MODE_FREQ;
 
 	cdns_i2c_writereg(CDNS_I2C_CR_ACK_EN | CDNS_I2C_CR_NEA | CDNS_I2C_CR_MS,
 			  CDNS_I2C_CR_OFFSET);
diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index b39c18114bdd..14b70c1a8f2f 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -99,16 +99,16 @@ static int dw_i2c_acpi_configure(struct platform_device *pdev)
 	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt, &fs_ht);
 
 	switch (t->bus_freq_hz) {
-	case 100000:
+	case I2C_MAX_STANDARD_MODE_FREQ:
 		dev->sda_hold_time = ss_ht;
 		break;
-	case 1000000:
+	case I2C_MAX_FAST_MODE_PLUS_FREQ:
 		dev->sda_hold_time = fp_ht;
 		break;
-	case 3400000:
+	case I2C_MAX_HIGH_SPEED_MODE_FREQ:
 		dev->sda_hold_time = hs_ht;
 		break;
-	case 400000:
+	case I2C_MAX_FAST_MODE_FREQ:
 	default:
 		dev->sda_hold_time = fs_ht;
 		break;
@@ -198,10 +198,10 @@ static void i2c_dw_configure_master(struct dw_i2c_dev *dev)
 	dev->mode = DW_IC_MASTER;
 
 	switch (t->bus_freq_hz) {
-	case 100000:
+	case I2C_MAX_STANDARD_MODE_FREQ:
 		dev->master_cfg |= DW_IC_CON_SPEED_STD;
 		break;
-	case 3400000:
+	case I2C_MAX_HIGH_SPEED_MODE_FREQ:
 		dev->master_cfg |= DW_IC_CON_SPEED_HIGH;
 		break;
 	default:
@@ -227,6 +227,13 @@ static void dw_i2c_plat_pm_cleanup(struct dw_i2c_dev *dev)
 		pm_runtime_put_noidle(dev->dev);
 }
 
+static const u32 supported_speeds[] = {
+	I2C_MAX_HIGH_SPEED_MODE_FREQ,
+	I2C_MAX_FAST_MODE_PLUS_FREQ,
+	I2C_MAX_FAST_MODE_FREQ,
+	I2C_MAX_STANDARD_MODE_FREQ,
+};
+
 static int dw_i2c_plat_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
@@ -236,9 +243,6 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	u32 acpi_speed;
 	struct resource *mem;
 	int i, irq, ret;
-	static const int supported_speeds[] = {
-		0, 100000, 400000, 1000000, 3400000
-	};
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
@@ -274,11 +278,11 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	 * Some DSTDs use a non standard speed, round down to the lowest
 	 * standard speed.
 	 */
-	for (i = 1; i < ARRAY_SIZE(supported_speeds); i++) {
-		if (acpi_speed < supported_speeds[i])
+	for (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {
+		if (acpi_speed >= supported_speeds[i])
 			break;
 	}
-	acpi_speed = supported_speeds[i - 1];
+	acpi_speed = i < ARRAY_SIZE(supported_speeds) ? supported_speeds[i] : 0;
 
 	/*
 	 * Find bus speed from the "clock-frequency" device property, ACPI
@@ -289,7 +293,7 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	else if (acpi_speed || t->bus_freq_hz)
 		t->bus_freq_hz = max(t->bus_freq_hz, acpi_speed);
 	else
-		t->bus_freq_hz = 400000;
+		t->bus_freq_hz = I2C_MAX_FAST_MODE_FREQ;
 
 	dev->flags |= (uintptr_t)device_get_match_data(&pdev->dev);
 
@@ -303,8 +307,11 @@ static int dw_i2c_plat_probe(struct platform_device *pdev)
 	 * Only standard mode at 100kHz, fast mode at 400kHz,
 	 * fast mode plus at 1MHz and high speed mode at 3.4MHz are supported.
 	 */
-	if (t->bus_freq_hz != 100000 && t->bus_freq_hz != 400000 &&
-	    t->bus_freq_hz != 1000000 && t->bus_freq_hz != 3400000) {
+	for (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {
+		if (t->bus_freq_hz == supported_speeds[i])
+			break;
+	}
+	if (i == ARRAY_SIZE(supported_speeds)) {
 		dev_err(&pdev->dev,
 			"%d Hz is unsupported, only 100kHz, 400kHz, 1MHz and 3.4MHz are supported\n",
 			t->bus_freq_hz);
diff --git a/drivers/i2c/busses/i2c-digicolor.c b/drivers/i2c/busses/i2c-digicolor.c
index 50813a24c541..cd01db397a7d 100644
--- a/drivers/i2c/busses/i2c-digicolor.c
+++ b/drivers/i2c/busses/i2c-digicolor.c
@@ -21,7 +21,6 @@
 #include <linux/of.h>
 #include <linux/platform_device.h>
 
-#define DEFAULT_FREQ		100000
 #define TIMEOUT_MS		100
 
 #define II_CONTROL		0x0
@@ -303,7 +302,7 @@ static int dc_i2c_probe(struct platform_device *pdev)
 
 	if (of_property_read_u32(pdev->dev.of_node, "clock-frequency",
 				 &i2c->frequency))
-		i2c->frequency = DEFAULT_FREQ;
+		i2c->frequency = I2C_MAX_STANDARD_MODE_FREQ;
 
 	i2c->dev = &pdev->dev;
 	platform_set_drvdata(pdev, i2c);
diff --git a/drivers/i2c/busses/i2c-diolan-u2c.c b/drivers/i2c/busses/i2c-diolan-u2c.c
index 3f28317cde39..2ec94077a005 100644
--- a/drivers/i2c/busses/i2c-diolan-u2c.c
+++ b/drivers/i2c/busses/i2c-diolan-u2c.c
@@ -67,8 +67,6 @@
 #define U2C_I2C_SPEED_2KHZ	242	/* 2 kHz, minimum speed */
 #define U2C_I2C_SPEED(f)	((DIV_ROUND_UP(1000000, (f)) - 10) / 2 + 1)
 
-#define U2C_I2C_FREQ_FAST	400000
-#define U2C_I2C_FREQ_STD	100000
 #define U2C_I2C_FREQ(s)		(1000000 / (2 * (s - 1) + 10))
 
 #define DIOLAN_USB_TIMEOUT	100	/* in ms */
@@ -90,7 +88,7 @@ struct i2c_diolan_u2c {
 	int ocount;			/* Number of enqueued messages */
 };
 
-static uint frequency = U2C_I2C_FREQ_STD;	/* I2C clock frequency in Hz */
+static uint frequency = I2C_MAX_STANDARD_MODE_FREQ;	/* I2C clock frequency in Hz */
 
 module_param(frequency, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(frequency, "I2C clock frequency in hertz");
@@ -302,12 +300,12 @@ static int diolan_init(struct i2c_diolan_u2c *dev)
 {
 	int speed, ret;
 
-	if (frequency >= 200000) {
+	if (frequency >= 2 * I2C_MAX_STANDARD_MODE_FREQ) {
 		speed = U2C_I2C_SPEED_FAST;
-		frequency = U2C_I2C_FREQ_FAST;
-	} else if (frequency >= 100000 || frequency == 0) {
+		frequency = I2C_MAX_FAST_MODE_FREQ;
+	} else if (frequency >= I2C_MAX_STANDARD_MODE_FREQ || frequency == 0) {
 		speed = U2C_I2C_SPEED_STD;
-		frequency = U2C_I2C_FREQ_STD;
+		frequency = I2C_MAX_STANDARD_MODE_FREQ;
 	} else {
 		speed = U2C_I2C_SPEED(frequency);
 		if (speed > U2C_I2C_SPEED_2KHZ)
diff --git a/drivers/i2c/busses/i2c-efm32.c b/drivers/i2c/busses/i2c-efm32.c
index 5f2bab878b2c..472e445698db 100644
--- a/drivers/i2c/busses/i2c-efm32.c
+++ b/drivers/i2c/busses/i2c-efm32.c
@@ -391,7 +391,7 @@ static int efm32_i2c_probe(struct platform_device *pdev)
 	if (!ret) {
 		dev_dbg(&pdev->dev, "using frequency %u\n", frequency);
 	} else {
-		frequency = 100000;
+		frequency = I2C_MAX_STANDARD_MODE_FREQ;
 		dev_info(&pdev->dev, "defaulting to 100 kHz\n");
 	}
 	ddata->frequency = frequency;
diff --git a/drivers/i2c/busses/i2c-exynos5.c b/drivers/i2c/busses/i2c-exynos5.c
index de82ad8ff534..eccf9ab705fe 100644
--- a/drivers/i2c/busses/i2c-exynos5.c
+++ b/drivers/i2c/busses/i2c-exynos5.c
@@ -167,13 +167,6 @@
 #define HSI2C_MASTER_ID(x)			((x & 0xff) << 24)
 #define MASTER_ID(x)				((x & 0x7) + 0x08)
 
-/*
- * Controller operating frequency, timing values for operation
- * are calculated against this frequency
- */
-#define HSI2C_HS_TX_CLOCK	1000000
-#define HSI2C_FS_TX_CLOCK	100000
-
 #define EXYNOS5_I2C_TIMEOUT (msecs_to_jiffies(100))
 
 #define HSI2C_EXYNOS7	BIT(0)
@@ -262,6 +255,9 @@ static void exynos5_i2c_clr_pend_irq(struct exynos5_i2c *i2c)
  * exynos5_i2c_set_timing: updates the registers with appropriate
  * timing values calculated
  *
+ * Timing values for operation are calculated against either 100kHz
+ * or 1MHz controller operating frequency.
+ *
  * Returns 0 on success, -EINVAL if the cycle length cannot
  * be calculated.
  */
@@ -279,7 +275,7 @@ static int exynos5_i2c_set_timing(struct exynos5_i2c *i2c, bool hs_timings)
 	unsigned int t_ftl_cycle;
 	unsigned int clkin = clk_get_rate(i2c->clk);
 	unsigned int op_clk = hs_timings ? i2c->op_clock :
-		(i2c->op_clock >= HSI2C_HS_TX_CLOCK) ? HSI2C_FS_TX_CLOCK :
+		(i2c->op_clock >= I2C_MAX_FAST_MODE_PLUS_FREQ) ? I2C_MAX_STANDARD_MODE_FREQ :
 		i2c->op_clock;
 	int div, clk_cycle, temp;
 
@@ -351,7 +347,7 @@ static int exynos5_hsi2c_clock_setup(struct exynos5_i2c *i2c)
 	/* always set Fast Speed timings */
 	int ret = exynos5_i2c_set_timing(i2c, false);
 
-	if (ret < 0 || i2c->op_clock < HSI2C_HS_TX_CLOCK)
+	if (ret < 0 || i2c->op_clock < I2C_MAX_FAST_MODE_PLUS_FREQ)
 		return ret;
 
 	return exynos5_i2c_set_timing(i2c, true);
@@ -374,7 +370,7 @@ static void exynos5_i2c_init(struct exynos5_i2c *i2c)
 					i2c->regs + HSI2C_CTL);
 	writel(HSI2C_TRAILING_COUNT, i2c->regs + HSI2C_TRAILIG_CTL);
 
-	if (i2c->op_clock >= HSI2C_HS_TX_CLOCK) {
+	if (i2c->op_clock >= I2C_MAX_FAST_MODE_PLUS_FREQ) {
 		writel(HSI2C_MASTER_ID(MASTER_ID(i2c->adap.nr)),
 					i2c->regs + HSI2C_ADDR);
 		i2c_conf |= HSI2C_HS_MODE;
@@ -751,7 +747,7 @@ static int exynos5_i2c_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	if (of_property_read_u32(np, "clock-frequency", &i2c->op_clock))
-		i2c->op_clock = HSI2C_FS_TX_CLOCK;
+		i2c->op_clock = I2C_MAX_STANDARD_MODE_FREQ;
 
 	strlcpy(i2c->adap.name, "exynos5-i2c", sizeof(i2c->adap.name));
 	i2c->adap.owner   = THIS_MODULE;
diff --git a/drivers/i2c/busses/i2c-hix5hd2.c b/drivers/i2c/busses/i2c-hix5hd2.c
index 061a4bfb03f4..879b8f0302e4 100644
--- a/drivers/i2c/busses/i2c-hix5hd2.c
+++ b/drivers/i2c/busses/i2c-hix5hd2.c
@@ -72,8 +72,6 @@
 #define I2C_ARBITRATE_INTR	BIT(1)
 #define I2C_OVER_INTR		BIT(0)
 
-#define HIX5I2C_MAX_FREQ	400000		/* 400k */
-
 enum hix5hd2_i2c_state {
 	HIX5I2C_STAT_RW_ERR = -1,
 	HIX5I2C_STAT_INIT,
@@ -404,12 +402,12 @@ static int hix5hd2_i2c_probe(struct platform_device *pdev)
 
 	if (of_property_read_u32(np, "clock-frequency", &freq)) {
 		/* use 100k as default value */
-		priv->freq = 100000;
+		priv->freq = I2C_MAX_STANDARD_MODE_FREQ;
 	} else {
-		if (freq > HIX5I2C_MAX_FREQ) {
-			priv->freq = HIX5I2C_MAX_FREQ;
+		if (freq > I2C_MAX_FAST_MODE_FREQ) {
+			priv->freq = I2C_MAX_FAST_MODE_FREQ;
 			dev_warn(priv->dev, "use max freq %d instead\n",
-				 HIX5I2C_MAX_FREQ);
+				 I2C_MAX_FAST_MODE_FREQ);
 		} else {
 			priv->freq = freq;
 		}
diff --git a/drivers/i2c/busses/i2c-img-scb.c b/drivers/i2c/busses/i2c-img-scb.c
index f038858b6c54..448c33bf3625 100644
--- a/drivers/i2c/busses/i2c-img-scb.c
+++ b/drivers/i2c/busses/i2c-img-scb.c
@@ -307,7 +307,7 @@ static struct img_i2c_timings timings[] = {
 	/* Standard mode */
 	{
 		.name = "standard",
-		.max_bitrate = 100000,
+		.max_bitrate = I2C_MAX_STANDARD_MODE_FREQ,
 		.tckh = 4000,
 		.tckl = 4700,
 		.tsdh = 4700,
@@ -319,7 +319,7 @@ static struct img_i2c_timings timings[] = {
 	/* Fast mode */
 	{
 		.name = "fast",
-		.max_bitrate = 400000,
+		.max_bitrate = I2C_MAX_FAST_MODE_FREQ,
 		.tckh = 600,
 		.tckl = 1300,
 		.tsdh = 600,
diff --git a/drivers/i2c/busses/i2c-imx-lpi2c.c b/drivers/i2c/busses/i2c-imx-lpi2c.c
index 6d975f5221ca..ddb96558a7a7 100644
--- a/drivers/i2c/busses/i2c-imx-lpi2c.c
+++ b/drivers/i2c/busses/i2c-imx-lpi2c.c
@@ -75,12 +75,6 @@
 #define I2C_CLK_RATIO	2
 #define CHUNK_DATA	256
 
-#define LPI2C_DEFAULT_RATE	100000
-#define STARDARD_MAX_BITRATE	400000
-#define FAST_MAX_BITRATE	1000000
-#define FAST_PLUS_MAX_BITRATE	3400000
-#define HIGHSPEED_MAX_BITRATE	5000000
-
 #define I2C_PM_TIMEOUT		10 /* ms */
 
 enum lpi2c_imx_mode {
@@ -152,13 +146,13 @@ static void lpi2c_imx_set_mode(struct lpi2c_imx_struct *lpi2c_imx)
 	unsigned int bitrate = lpi2c_imx->bitrate;
 	enum lpi2c_imx_mode mode;
 
-	if (bitrate < STARDARD_MAX_BITRATE)
+	if (bitrate < I2C_MAX_FAST_MODE_FREQ)
 		mode = STANDARD;
-	else if (bitrate < FAST_MAX_BITRATE)
+	else if (bitrate < I2C_MAX_FAST_MODE_PLUS_FREQ)
 		mode = FAST;
-	else if (bitrate < FAST_PLUS_MAX_BITRATE)
+	else if (bitrate < I2C_MAX_HIGH_SPEED_MODE_FREQ)
 		mode = FAST_PLUS;
-	else if (bitrate < HIGHSPEED_MAX_BITRATE)
+	else if (bitrate < I2C_MAX_ULTRA_FAST_MODE_FREQ)
 		mode = HS;
 	else
 		mode = ULTRA_FAST;
@@ -581,7 +575,7 @@ static int lpi2c_imx_probe(struct platform_device *pdev)
 	ret = of_property_read_u32(pdev->dev.of_node,
 				   "clock-frequency", &lpi2c_imx->bitrate);
 	if (ret)
-		lpi2c_imx->bitrate = LPI2C_DEFAULT_RATE;
+		lpi2c_imx->bitrate = I2C_MAX_STANDARD_MODE_FREQ;
 
 	ret = devm_request_irq(&pdev->dev, irq, lpi2c_imx_isr, 0,
 			       pdev->name, lpi2c_imx);
diff --git a/drivers/i2c/busses/i2c-imx.c b/drivers/i2c/busses/i2c-imx.c
index 4ae0a1315ea6..0f464bb29a6b 100644
--- a/drivers/i2c/busses/i2c-imx.c
+++ b/drivers/i2c/busses/i2c-imx.c
@@ -49,9 +49,6 @@
 /* This will be the driver name the kernel reports */
 #define DRIVER_NAME "imx-i2c"
 
-/* Default value */
-#define IMX_I2C_BIT_RATE	100000	/* 100kHz */
-
 /*
  * Enable DMA if transfer byte size is bigger than this threshold.
  * As the hardware request, it must bigger than 4 bytes.\
@@ -1136,7 +1133,7 @@ static int i2c_imx_probe(struct platform_device *pdev)
 		goto rpm_disable;
 
 	/* Set up clock divider */
-	i2c_imx->bitrate = IMX_I2C_BIT_RATE;
+	i2c_imx->bitrate = I2C_MAX_STANDARD_MODE_FREQ;
 	ret = of_property_read_u32(pdev->dev.of_node,
 				   "clock-frequency", &i2c_imx->bitrate);
 	if (ret < 0 && pdata && pdata->bitrate)
diff --git a/drivers/i2c/busses/i2c-lpc2k.c b/drivers/i2c/busses/i2c-lpc2k.c
index 59167c018ae7..dcb816899b76 100644
--- a/drivers/i2c/busses/i2c-lpc2k.c
+++ b/drivers/i2c/busses/i2c-lpc2k.c
@@ -401,7 +401,7 @@ static int i2c_lpc2k_probe(struct platform_device *pdev)
 	ret = of_property_read_u32(pdev->dev.of_node, "clock-frequency",
 				   &bus_clk_rate);
 	if (ret)
-		bus_clk_rate = 100000; /* 100 kHz default clock rate */
+		bus_clk_rate = I2C_MAX_STANDARD_MODE_FREQ;
 
 	clkrate = clk_get_rate(i2c->clk);
 	if (clkrate == 0) {
@@ -412,9 +412,9 @@ static int i2c_lpc2k_probe(struct platform_device *pdev)
 
 	/* Setup I2C dividers to generate clock with proper duty cycle */
 	clkrate = clkrate / bus_clk_rate;
-	if (bus_clk_rate <= 100000)
+	if (bus_clk_rate <= I2C_MAX_STANDARD_MODE_FREQ)
 		scl_high = (clkrate * I2C_STD_MODE_DUTY) / 100;
-	else if (bus_clk_rate <= 400000)
+	else if (bus_clk_rate <= I2C_MAX_FAST_MODE_FREQ)
 		scl_high = (clkrate * I2C_FAST_MODE_DUTY) / 100;
 	else
 		scl_high = (clkrate * I2C_FAST_MODE_PLUS_DUTY) / 100;
* Unmerged path drivers/i2c/busses/i2c-mt65xx.c
* Unmerged path drivers/i2c/busses/i2c-mt7621.c
diff --git a/drivers/i2c/busses/i2c-mv64xxx.c b/drivers/i2c/busses/i2c-mv64xxx.c
index febb7c7ea72b..9b8f1d8552ea 100644
--- a/drivers/i2c/busses/i2c-mv64xxx.c
+++ b/drivers/i2c/busses/i2c-mv64xxx.c
@@ -810,7 +810,7 @@ mv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,
 	tclk = clk_get_rate(drv_data->clk);
 
 	if (of_property_read_u32(np, "clock-frequency", &bus_freq))
-		bus_freq = 100000; /* 100kHz by default */
+		bus_freq = I2C_MAX_STANDARD_MODE_FREQ; /* 100kHz by default */
 
 	if (of_device_is_compatible(np, "allwinner,sun4i-a10-i2c") ||
 	    of_device_is_compatible(np, "allwinner,sun6i-a31-i2c"))
@@ -846,14 +846,14 @@ mv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,
 	if (of_device_is_compatible(np, "marvell,mv78230-i2c")) {
 		drv_data->offload_enabled = true;
 		/* The delay is only needed in standard mode (100kHz) */
-		if (bus_freq <= 100000)
+		if (bus_freq <= I2C_MAX_STANDARD_MODE_FREQ)
 			drv_data->errata_delay = true;
 	}
 
 	if (of_device_is_compatible(np, "marvell,mv78230-a0-i2c")) {
 		drv_data->offload_enabled = false;
 		/* The delay is only needed in standard mode (100kHz) */
-		if (bus_freq <= 100000)
+		if (bus_freq <= I2C_MAX_STANDARD_MODE_FREQ)
 			drv_data->errata_delay = true;
 	}
 
diff --git a/drivers/i2c/busses/i2c-mxs.c b/drivers/i2c/busses/i2c-mxs.c
index 642c58946d8d..92a0dbc31b20 100644
--- a/drivers/i2c/busses/i2c-mxs.c
+++ b/drivers/i2c/busses/i2c-mxs.c
@@ -730,7 +730,7 @@ static void mxs_i2c_derive_timing(struct mxs_i2c_dev *i2c, uint32_t speed)
 	 * This is compensated for by subtracting the respective constants
 	 * from the values written to the timing registers.
 	 */
-	if (speed > 100000) {
+	if (speed > I2C_MAX_STANDARD_MODE_FREQ) {
 		/* fast mode */
 		low_count = DIV_ROUND_CLOSEST(divider * 13, (13 + 6));
 		high_count = DIV_ROUND_CLOSEST(divider * 6, (13 + 6));
@@ -768,7 +768,7 @@ static int mxs_i2c_get_ofdata(struct mxs_i2c_dev *i2c)
 	ret = of_property_read_u32(node, "clock-frequency", &speed);
 	if (ret) {
 		dev_warn(dev, "No I2C speed selected, using 100kHz\n");
-		speed = 100000;
+		speed = I2C_MAX_STANDARD_MODE_FREQ;
 	}
 
 	mxs_i2c_derive_timing(i2c, speed);
diff --git a/drivers/i2c/busses/i2c-nomadik.c b/drivers/i2c/busses/i2c-nomadik.c
index 0ed5a41804dc..1648c24e9496 100644
--- a/drivers/i2c/busses/i2c-nomadik.c
+++ b/drivers/i2c/busses/i2c-nomadik.c
@@ -399,7 +399,7 @@ static void setup_i2c_controller(struct nmk_i2c_dev *dev)
 	 * 2 whereas it is 3 for fast and fastplus mode of
 	 * operation. TODO - high speed support.
 	 */
-	div = (dev->clk_freq > 100000) ? 3 : 2;
+	div = (dev->clk_freq > I2C_MAX_STANDARD_MODE_FREQ) ? 3 : 2;
 
 	/*
 	 * generate the mask for baud rate counters. The controller
@@ -423,7 +423,7 @@ static void setup_i2c_controller(struct nmk_i2c_dev *dev)
 	if (dev->sm > I2C_FREQ_MODE_FAST) {
 		dev_err(&dev->adev->dev,
 			"do not support this mode defaulting to std. mode\n");
-		brcr2 = i2c_clk/(100000 * 2) & 0xffff;
+		brcr2 = i2c_clk / (I2C_MAX_STANDARD_MODE_FREQ * 2) & 0xffff;
 		writel((brcr1 | brcr2), dev->virtbase + I2C_BRCR);
 		writel(I2C_FREQ_MODE_STANDARD << 4,
 				dev->virtbase + I2C_CR);
@@ -952,10 +952,10 @@ static void nmk_i2c_of_probe(struct device_node *np,
 {
 	/* Default to 100 kHz if no frequency is given in the node */
 	if (of_property_read_u32(np, "clock-frequency", &nmk->clk_freq))
-		nmk->clk_freq = 100000;
+		nmk->clk_freq = I2C_MAX_STANDARD_MODE_FREQ;
 
 	/* This driver only supports 'standard' and 'fast' modes of operation. */
-	if (nmk->clk_freq <= 100000)
+	if (nmk->clk_freq <= I2C_MAX_STANDARD_MODE_FREQ)
 		nmk->sm = I2C_FREQ_MODE_STANDARD;
 	else
 		nmk->sm = I2C_FREQ_MODE_FAST;
diff --git a/drivers/i2c/busses/i2c-omap.c b/drivers/i2c/busses/i2c-omap.c
index 65d06a819307..b8deb460074a 100644
--- a/drivers/i2c/busses/i2c-omap.c
+++ b/drivers/i2c/busses/i2c-omap.c
@@ -1340,7 +1340,7 @@ omap_i2c_probe(struct platform_device *pdev)
 
 	match = of_match_device(of_match_ptr(omap_i2c_of_match), &pdev->dev);
 	if (match) {
-		u32 freq = 100000; /* default to 100000 Hz */
+		u32 freq = I2C_MAX_STANDARD_MODE_FREQ;
 
 		pdata = match->data;
 		omap->flags = pdata->flags;
* Unmerged path drivers/i2c/busses/i2c-owl.c
diff --git a/drivers/i2c/busses/i2c-qup.c b/drivers/i2c/busses/i2c-qup.c
index c86c3ae1318f..75efddc8aa00 100644
--- a/drivers/i2c/busses/i2c-qup.c
+++ b/drivers/i2c/busses/i2c-qup.c
@@ -136,13 +136,8 @@
  */
 #define TOUT_MIN			2
 
-/* I2C Frequency Modes */
-#define I2C_STANDARD_FREQ		100000
-#define I2C_FAST_MODE_FREQ		400000
-#define I2C_FAST_MODE_PLUS_FREQ		1000000
-
 /* Default values. Use these if FW query fails */
-#define DEFAULT_CLK_FREQ I2C_STANDARD_FREQ
+#define DEFAULT_CLK_FREQ I2C_MAX_STANDARD_MODE_FREQ
 #define DEFAULT_SRC_CLK 20000000
 
 /*
@@ -1758,7 +1753,7 @@ static int qup_i2c_probe(struct platform_device *pdev)
 
 nodma:
 	/* We support frequencies up to FAST Mode Plus (1MHz) */
-	if (!clk_freq || clk_freq > I2C_FAST_MODE_PLUS_FREQ) {
+	if (!clk_freq || clk_freq > I2C_MAX_FAST_MODE_PLUS_FREQ) {
 		dev_err(qup->dev, "clock frequency not supported %d\n",
 			clk_freq);
 		return -EINVAL;
@@ -1863,7 +1858,7 @@ static int qup_i2c_probe(struct platform_device *pdev)
 	qup->in_fifo_sz = qup->in_blk_sz * (2 << size);
 
 	hs_div = 3;
-	if (clk_freq <= I2C_STANDARD_FREQ) {
+	if (clk_freq <= I2C_MAX_STANDARD_MODE_FREQ) {
 		fs_div = ((src_clk_freq / clk_freq) / 2) - 3;
 		qup->clk_ctl = (hs_div << 8) | (fs_div & 0xff);
 	} else {
* Unmerged path drivers/i2c/busses/i2c-riic.c
diff --git a/drivers/i2c/busses/i2c-rk3x.c b/drivers/i2c/busses/i2c-rk3x.c
index b8a2728dd4b6..adc4e3e52c61 100644
--- a/drivers/i2c/busses/i2c-rk3x.c
+++ b/drivers/i2c/busses/i2c-rk3x.c
@@ -542,9 +542,9 @@ static irqreturn_t rk3x_i2c_irq(int irqno, void *dev_id)
  */
 static const struct i2c_spec_values *rk3x_i2c_get_spec(unsigned int speed)
 {
-	if (speed <= 100000)
+	if (speed <= I2C_MAX_STANDARD_MODE_FREQ)
 		return &standard_mode_spec;
-	else if (speed <= 400000)
+	else if (speed <= I2C_MAX_FAST_MODE_FREQ)
 		return &fast_mode_spec;
 	else
 		return &fast_mode_plus_spec;
@@ -581,8 +581,8 @@ static int rk3x_i2c_v0_calc_timings(unsigned long clk_rate,
 	int ret = 0;
 
 	/* Only support standard-mode and fast-mode */
-	if (WARN_ON(t->bus_freq_hz > 400000))
-		t->bus_freq_hz = 400000;
+	if (WARN_ON(t->bus_freq_hz > I2C_MAX_FAST_MODE_FREQ))
+		t->bus_freq_hz = I2C_MAX_FAST_MODE_FREQ;
 
 	/* prevent scl_rate_khz from becoming 0 */
 	if (WARN_ON(t->bus_freq_hz < 1000))
@@ -761,8 +761,8 @@ static int rk3x_i2c_v1_calc_timings(unsigned long clk_rate,
 	int ret = 0;
 
 	/* Support standard-mode, fast-mode and fast-mode plus */
-	if (WARN_ON(t->bus_freq_hz > 1000000))
-		t->bus_freq_hz = 1000000;
+	if (WARN_ON(t->bus_freq_hz > I2C_MAX_FAST_MODE_PLUS_FREQ))
+		t->bus_freq_hz = I2C_MAX_FAST_MODE_PLUS_FREQ;
 
 	/* prevent scl_rate_khz from becoming 0 */
 	if (WARN_ON(t->bus_freq_hz < 1000))
diff --git a/drivers/i2c/busses/i2c-s3c2410.c b/drivers/i2c/busses/i2c-s3c2410.c
index 2f2e28d60ef5..4e6393c270ce 100644
--- a/drivers/i2c/busses/i2c-s3c2410.c
+++ b/drivers/i2c/busses/i2c-s3c2410.c
@@ -847,11 +847,11 @@ static int s3c24xx_i2c_clockrate(struct s3c24xx_i2c *i2c, unsigned int *got)
 	int freq;
 
 	i2c->clkrate = clkin;
-	clkin /= 1000;		/* clkin now in KHz */
+	clkin /= 1000;	/* clkin now in KHz */
 
 	dev_dbg(i2c->dev, "pdata desired frequency %lu\n", pdata->frequency);
 
-	target_frequency = pdata->frequency ? pdata->frequency : 100000;
+	target_frequency = pdata->frequency ?: I2C_MAX_STANDARD_MODE_FREQ;
 
 	target_frequency /= 1000; /* Target frequency now in KHz */
 
diff --git a/drivers/i2c/busses/i2c-sh_mobile.c b/drivers/i2c/busses/i2c-sh_mobile.c
index 5e22d55ea57b..57b97660d4c6 100644
--- a/drivers/i2c/busses/i2c-sh_mobile.c
+++ b/drivers/i2c/busses/i2c-sh_mobile.c
@@ -154,9 +154,6 @@ struct sh_mobile_dt_config {
 
 #define IIC_FLAG_HAS_ICIC67	(1 << 0)
 
-#define STANDARD_MODE		100000
-#define FAST_MODE		400000
-
 /* Register offsets */
 #define ICDR			0x00
 #define ICCR			0x04
@@ -279,11 +276,11 @@ static int sh_mobile_i2c_init(struct sh_mobile_i2c_data *pd)
 
 	i2c_clk_khz = clk_get_rate(pd->clk) / 1000 / pd->clks_per_count;
 
-	if (pd->bus_speed == STANDARD_MODE) {
+	if (pd->bus_speed == I2C_MAX_STANDARD_MODE_FREQ) {
 		tLOW	= 47;	/* tLOW = 4.7 us */
 		tHIGH	= 40;	/* tHD;STA = tHIGH = 4.0 us */
 		tf	= 3;	/* tf = 0.3 us */
-	} else if (pd->bus_speed == FAST_MODE) {
+	} else if (pd->bus_speed == I2C_MAX_FAST_MODE_FREQ) {
 		tLOW	= 13;	/* tLOW = 1.3 us */
 		tHIGH	= 6;	/* tHD;STA = tHIGH = 0.6 us */
 		tf	= 3;	/* tf = 0.3 us */
@@ -892,7 +889,7 @@ static int sh_mobile_i2c_probe(struct platform_device *dev)
 		return PTR_ERR(pd->reg);
 
 	ret = of_property_read_u32(dev->dev.of_node, "clock-frequency", &bus_speed);
-	pd->bus_speed = (ret || !bus_speed) ? STANDARD_MODE : bus_speed;
+	pd->bus_speed = (ret || !bus_speed) ? I2C_MAX_STANDARD_MODE_FREQ : bus_speed;
 	pd->clks_per_count = 1;
 
 	/* Newer variants come with two new bits in ICIC */
diff --git a/drivers/i2c/busses/i2c-sirf.c b/drivers/i2c/busses/i2c-sirf.c
index 87197ece0f90..ad07acc188e9 100644
--- a/drivers/i2c/busses/i2c-sirf.c
+++ b/drivers/i2c/busses/i2c-sirf.c
@@ -63,7 +63,6 @@
 #define SIRFSOC_I2C_STOP		BIT(6)
 #define SIRFSOC_I2C_START		BIT(7)
 
-#define SIRFSOC_I2C_DEFAULT_SPEED 100000
 #define SIRFSOC_I2C_ERR_NOACK      1
 #define SIRFSOC_I2C_ERR_TIMEOUT    2
 
@@ -354,7 +353,7 @@ static int i2c_sirfsoc_probe(struct platform_device *pdev)
 	err = of_property_read_u32(pdev->dev.of_node,
 		"clock-frequency", &bitrate);
 	if (err < 0)
-		bitrate = SIRFSOC_I2C_DEFAULT_SPEED;
+		bitrate = I2C_MAX_STANDARD_MODE_FREQ;
 
 	/*
 	 * Due to some hardware design issues, we need to tune the formula.
diff --git a/drivers/i2c/busses/i2c-sprd.c b/drivers/i2c/busses/i2c-sprd.c
index a94e724f51dc..9b49a02b4d19 100644
--- a/drivers/i2c/busses/i2c-sprd.c
+++ b/drivers/i2c/busses/i2c-sprd.c
@@ -340,9 +340,9 @@ static void sprd_i2c_set_clk(struct sprd_i2c *i2c_dev, u32 freq)
 	writel(div1, i2c_dev->base + ADDR_DVD1);
 
 	/* Start hold timing = hold time(us) * source clock */
-	if (freq == 400000)
+	if (freq == I2C_MAX_FAST_MODE_FREQ)
 		writel((6 * apb_clk) / 10000000, i2c_dev->base + ADDR_STA0_DVD);
-	else if (freq == 100000)
+	else if (freq == I2C_MAX_STANDARD_MODE_FREQ)
 		writel((4 * apb_clk) / 1000000, i2c_dev->base + ADDR_STA0_DVD);
 }
 
@@ -507,7 +507,7 @@ static int sprd_i2c_probe(struct platform_device *pdev)
 	snprintf(i2c_dev->adap.name, sizeof(i2c_dev->adap.name),
 		 "%s", "sprd-i2c");
 
-	i2c_dev->bus_freq = 100000;
+	i2c_dev->bus_freq = I2C_MAX_STANDARD_MODE_FREQ;
 	i2c_dev->adap.owner = THIS_MODULE;
 	i2c_dev->dev = dev;
 	i2c_dev->adap.retries = 3;
@@ -521,7 +521,8 @@ static int sprd_i2c_probe(struct platform_device *pdev)
 		i2c_dev->bus_freq = prop;
 
 	/* We only support 100k and 400k now, otherwise will return error. */
-	if (i2c_dev->bus_freq != 100000 && i2c_dev->bus_freq != 400000)
+	if (i2c_dev->bus_freq != I2C_MAX_STANDARD_MODE_FREQ &&
+	    i2c_dev->bus_freq != I2C_MAX_FAST_MODE_FREQ)
 		return -EINVAL;
 
 	sprd_i2c_clk_init(i2c_dev);
diff --git a/drivers/i2c/busses/i2c-st.c b/drivers/i2c/busses/i2c-st.c
index 9e62f893958a..8560ac6671ce 100644
--- a/drivers/i2c/busses/i2c-st.c
+++ b/drivers/i2c/busses/i2c-st.c
@@ -216,7 +216,7 @@ static inline void st_i2c_clr_bits(void __iomem *reg, u32 mask)
  */
 static struct st_i2c_timings i2c_timings[] = {
 	[I2C_MODE_STANDARD] = {
-		.rate			= 100000,
+		.rate			= I2C_MAX_STANDARD_MODE_FREQ,
 		.rep_start_hold		= 4400,
 		.rep_start_setup	= 5170,
 		.start_hold		= 4400,
@@ -225,7 +225,7 @@ static struct st_i2c_timings i2c_timings[] = {
 		.bus_free_time		= 5170,
 	},
 	[I2C_MODE_FAST] = {
-		.rate			= 400000,
+		.rate			= I2C_MAX_FAST_MODE_FREQ,
 		.rep_start_hold		= 660,
 		.rep_start_setup	= 660,
 		.start_hold		= 660,
@@ -838,7 +838,7 @@ static int st_i2c_probe(struct platform_device *pdev)
 
 	i2c_dev->mode = I2C_MODE_STANDARD;
 	ret = of_property_read_u32(np, "clock-frequency", &clk_rate);
-	if ((!ret) && (clk_rate == 400000))
+	if (!ret && (clk_rate == I2C_MAX_FAST_MODE_FREQ))
 		i2c_dev->mode = I2C_MODE_FAST;
 
 	i2c_dev->dev = &pdev->dev;
diff --git a/drivers/i2c/busses/i2c-stm32f4.c b/drivers/i2c/busses/i2c-stm32f4.c
index ba600d77a3f8..d6a69dfcac3f 100644
--- a/drivers/i2c/busses/i2c-stm32f4.c
+++ b/drivers/i2c/busses/i2c-stm32f4.c
@@ -232,10 +232,10 @@ static void stm32f4_i2c_set_speed_mode(struct stm32f4_i2c_dev *i2c_dev)
 		 * In standard mode:
 		 * t_scl_high = t_scl_low = CCR * I2C parent clk period
 		 * So to reach 100 kHz, we have:
-		 * CCR = I2C parent rate / 100 kHz >> 1
+		 * CCR = I2C parent rate / (100 kHz * 2)
 		 *
 		 * For example with parent rate = 2 MHz:
-		 * CCR = 2000000 / (100000 << 1) = 10
+		 * CCR = 2000000 / (100000 * 2) = 10
 		 * t_scl_high = t_scl_low = 10 * (1 / 2000000) = 5000 ns
 		 * t_scl_high + t_scl_low = 10000 ns so 100 kHz is reached
 		 *
@@ -243,7 +243,7 @@ static void stm32f4_i2c_set_speed_mode(struct stm32f4_i2c_dev *i2c_dev)
 		 * parent rate is not higher than 46 MHz . As a result val
 		 * is at most 8 bits wide and so fits into the CCR bits [11:0].
 		 */
-		val = i2c_dev->parent_rate / (100000 << 1);
+		val = i2c_dev->parent_rate / (I2C_MAX_STANDARD_MODE_FREQ * 2);
 	} else {
 		/*
 		 * In fast mode, we compute CCR with duty = 0 as with low
@@ -263,7 +263,7 @@ static void stm32f4_i2c_set_speed_mode(struct stm32f4_i2c_dev *i2c_dev)
 		 * parent rate is not higher than 46 MHz . As a result val
 		 * is at most 6 bits wide and so fits into the CCR bits [11:0].
 		 */
-		val = DIV_ROUND_UP(i2c_dev->parent_rate, 400000 * 3);
+		val = DIV_ROUND_UP(i2c_dev->parent_rate, I2C_MAX_FAST_MODE_FREQ * 3);
 
 		/* Select Fast mode */
 		ccr |= STM32F4_I2C_CCR_FS;
@@ -807,7 +807,7 @@ static int stm32f4_i2c_probe(struct platform_device *pdev)
 
 	i2c_dev->speed = STM32_I2C_SPEED_STANDARD;
 	ret = of_property_read_u32(np, "clock-frequency", &clk_rate);
-	if (!ret && clk_rate >= 400000)
+	if (!ret && clk_rate >= I2C_MAX_FAST_MODE_FREQ)
 		i2c_dev->speed = STM32_I2C_SPEED_FAST;
 
 	i2c_dev->dev = &pdev->dev;
diff --git a/drivers/i2c/busses/i2c-stu300.c b/drivers/i2c/busses/i2c-stu300.c
index fce52bdab2b7..c3a533c9ecd9 100644
--- a/drivers/i2c/busses/i2c-stu300.c
+++ b/drivers/i2c/busses/i2c-stu300.c
@@ -132,7 +132,7 @@ enum stu300_error {
 #define NUM_ADDR_RESEND_ATTEMPTS 12
 
 /* I2C clock speed, in Hz 0-400kHz*/
-static unsigned int scl_frequency = 100000;
+static unsigned int scl_frequency = I2C_MAX_STANDARD_MODE_FREQ;
 module_param(scl_frequency, uint,  0644);
 
 /**
@@ -510,7 +510,7 @@ static int stu300_set_clk(struct stu300_dev *dev, unsigned long clkrate)
 	dev_dbg(&dev->pdev->dev, "Clock rate %lu Hz, I2C bus speed %d Hz "
 		"virtbase %p\n", clkrate, dev->speed, dev->virtbase);
 
-	if (dev->speed > 100000)
+	if (dev->speed > I2C_MAX_STANDARD_MODE_FREQ)
 		/* Fast Mode I2C */
 		val = ((clkrate/dev->speed) - 9)/3 + 1;
 	else
@@ -531,7 +531,7 @@ static int stu300_set_clk(struct stu300_dev *dev, unsigned long clkrate)
 		return -EINVAL;
 	}
 
-	if (dev->speed > 100000) {
+	if (dev->speed > I2C_MAX_STANDARD_MODE_FREQ) {
 		/* CC6..CC0 */
 		stu300_wr8((val & I2C_CCR_CC_MASK) | I2C_CCR_FMSM,
 			   dev->virtbase + I2C_CCR);
diff --git a/drivers/i2c/busses/i2c-sun6i-p2wi.c b/drivers/i2c/busses/i2c-sun6i-p2wi.c
index 7c07ce116e38..e5293f0b3318 100644
--- a/drivers/i2c/busses/i2c-sun6i-p2wi.c
+++ b/drivers/i2c/busses/i2c-sun6i-p2wi.c
@@ -186,7 +186,7 @@ static int p2wi_probe(struct platform_device *pdev)
 	struct device_node *np = dev->of_node;
 	struct device_node *childnp;
 	unsigned long parent_clk_freq;
-	u32 clk_freq = 100000;
+	u32 clk_freq = I2C_MAX_STANDARD_MODE_FREQ;
 	struct resource *r;
 	struct p2wi *p2wi;
 	u32 slave_addr;
diff --git a/drivers/i2c/busses/i2c-synquacer.c b/drivers/i2c/busses/i2c-synquacer.c
index 915f5edbab33..f90e2bd91e49 100644
--- a/drivers/i2c/busses/i2c-synquacer.c
+++ b/drivers/i2c/busses/i2c-synquacer.c
@@ -67,10 +67,10 @@
 
 /* STANDARD MODE frequency */
 #define SYNQUACER_I2C_CLK_MASTER_STD(rate)			\
-	DIV_ROUND_UP(DIV_ROUND_UP((rate), 100000) - 2, 2)
+	DIV_ROUND_UP(DIV_ROUND_UP((rate), I2C_MAX_STANDARD_MODE_FREQ) - 2, 2)
 /* FAST MODE frequency */
 #define SYNQUACER_I2C_CLK_MASTER_FAST(rate)			\
-	DIV_ROUND_UP((DIV_ROUND_UP((rate), 400000) - 2) * 2, 3)
+	DIV_ROUND_UP((DIV_ROUND_UP((rate), I2C_MAX_FAST_MODE_FREQ) - 2) * 2, 3)
 
 /* (clkrate <= 18000000) */
 /* calculate the value of CS bits in CCR register on standard mode */
@@ -605,7 +605,7 @@ static int synquacer_i2c_probe(struct platform_device *pdev)
 	i2c->adapter.nr = pdev->id;
 	init_completion(&i2c->completion);
 
-	if (bus_speed < 400000)
+	if (bus_speed < I2C_MAX_FAST_MODE_FREQ)
 		i2c->speed_khz = SYNQUACER_I2C_SPEED_SM;
 	else
 		i2c->speed_khz = SYNQUACER_I2C_SPEED_FM;
* Unmerged path drivers/i2c/busses/i2c-tegra.c
diff --git a/drivers/i2c/busses/i2c-thunderx-pcidrv.c b/drivers/i2c/busses/i2c-thunderx-pcidrv.c
index 19f8eec38717..01b6f4eca5d2 100644
--- a/drivers/i2c/busses/i2c-thunderx-pcidrv.c
+++ b/drivers/i2c/busses/i2c-thunderx-pcidrv.c
@@ -178,7 +178,7 @@ static int thunder_i2c_probe_pci(struct pci_dev *pdev,
 	thunder_i2c_clock_enable(dev, i2c);
 	ret = device_property_read_u32(dev, "clock-frequency", &i2c->twsi_freq);
 	if (ret)
-		i2c->twsi_freq = 100000;
+		i2c->twsi_freq = I2C_MAX_STANDARD_MODE_FREQ;
 
 	init_waitqueue_head(&i2c->queue);
 
diff --git a/drivers/i2c/busses/i2c-uniphier-f.c b/drivers/i2c/busses/i2c-uniphier-f.c
index 9918bdd81619..d5c02ab2a58a 100644
--- a/drivers/i2c/busses/i2c-uniphier-f.c
+++ b/drivers/i2c/busses/i2c-uniphier-f.c
@@ -82,8 +82,6 @@
 #define UNIPHIER_FI2C_BYTE_WISE		BIT(3)
 #define UNIPHIER_FI2C_DEFER_STOP_COMP	BIT(4)
 
-#define UNIPHIER_FI2C_DEFAULT_SPEED	100000
-#define UNIPHIER_FI2C_MAX_SPEED		400000
 #define UNIPHIER_FI2C_FIFO_SIZE		8
 
 struct uniphier_fi2c_priv {
@@ -506,9 +504,9 @@ static int uniphier_fi2c_probe(struct platform_device *pdev)
 	}
 
 	if (of_property_read_u32(dev->of_node, "clock-frequency", &bus_speed))
-		bus_speed = UNIPHIER_FI2C_DEFAULT_SPEED;
+		bus_speed = I2C_MAX_STANDARD_MODE_FREQ;
 
-	if (!bus_speed || bus_speed > UNIPHIER_FI2C_MAX_SPEED) {
+	if (!bus_speed || bus_speed > I2C_MAX_FAST_MODE_FREQ) {
 		dev_err(dev, "invalid clock-frequency %d\n", bus_speed);
 		return -EINVAL;
 	}
diff --git a/drivers/i2c/busses/i2c-uniphier.c b/drivers/i2c/busses/i2c-uniphier.c
index bb181b088291..21b02bbcebc0 100644
--- a/drivers/i2c/busses/i2c-uniphier.c
+++ b/drivers/i2c/busses/i2c-uniphier.c
@@ -44,9 +44,6 @@
 #define UNIPHIER_I2C_NOISE	0x1c	/* noise filter control */
 #define UNIPHIER_I2C_SETUP	0x20	/* setup time control */
 
-#define UNIPHIER_I2C_DEFAULT_SPEED	100000
-#define UNIPHIER_I2C_MAX_SPEED		400000
-
 struct uniphier_i2c_priv {
 	struct completion comp;
 	struct i2c_adapter adap;
@@ -353,9 +350,9 @@ static int uniphier_i2c_probe(struct platform_device *pdev)
 	}
 
 	if (of_property_read_u32(dev->of_node, "clock-frequency", &bus_speed))
-		bus_speed = UNIPHIER_I2C_DEFAULT_SPEED;
+		bus_speed = I2C_MAX_STANDARD_MODE_FREQ;
 
-	if (!bus_speed || bus_speed > UNIPHIER_I2C_MAX_SPEED) {
+	if (!bus_speed || bus_speed > I2C_MAX_FAST_MODE_FREQ) {
 		dev_err(dev, "invalid clock-frequency %d\n", bus_speed);
 		return -EINVAL;
 	}
diff --git a/drivers/i2c/busses/i2c-wmt.c b/drivers/i2c/busses/i2c-wmt.c
index fbd0fd59f312..0f8892cf7df9 100644
--- a/drivers/i2c/busses/i2c-wmt.c
+++ b/drivers/i2c/busses/i2c-wmt.c
@@ -403,7 +403,7 @@ static int wmt_i2c_probe(struct platform_device *pdev)
 
 	i2c_dev->mode = I2C_MODE_STANDARD;
 	err = of_property_read_u32(np, "clock-frequency", &clk_rate);
-	if ((!err) && (clk_rate == 400000))
+	if (!err && (clk_rate == I2C_MAX_FAST_MODE_FREQ))
 		i2c_dev->mode = I2C_MODE_FAST;
 
 	i2c_dev->dev = &pdev->dev;
diff --git a/drivers/i2c/busses/i2c-xlp9xx.c b/drivers/i2c/busses/i2c-xlp9xx.c
index 8a873975cf12..f678f8d9abd6 100644
--- a/drivers/i2c/busses/i2c-xlp9xx.c
+++ b/drivers/i2c/busses/i2c-xlp9xx.c
@@ -71,8 +71,6 @@
 #define XLP9XX_I2C_SLAVEADDR_ADDR_SHIFT		1
 
 #define XLP9XX_I2C_IP_CLK_FREQ		133000000UL
-#define XLP9XX_I2C_DEFAULT_FREQ		100000
-#define XLP9XX_I2C_HIGH_FREQ		400000
 #define XLP9XX_I2C_FIFO_SIZE		0x80U
 #define XLP9XX_I2C_TIMEOUT_MS		1000
 #define XLP9XX_I2C_BUSY_TIMEOUT		50
@@ -476,12 +474,12 @@ static int xlp9xx_i2c_get_frequency(struct platform_device *pdev,
 
 	err = device_property_read_u32(&pdev->dev, "clock-frequency", &freq);
 	if (err) {
-		freq = XLP9XX_I2C_DEFAULT_FREQ;
+		freq = I2C_MAX_STANDARD_MODE_FREQ;
 		dev_dbg(&pdev->dev, "using default frequency %u\n", freq);
-	} else if (freq == 0 || freq > XLP9XX_I2C_HIGH_FREQ) {
+	} else if (freq == 0 || freq > I2C_MAX_FAST_MODE_FREQ) {
 		dev_warn(&pdev->dev, "invalid frequency %u, using default\n",
 			 freq);
-		freq = XLP9XX_I2C_DEFAULT_FREQ;
+		freq = I2C_MAX_STANDARD_MODE_FREQ;
 	}
 	priv->clk_hz = freq;
 
diff --git a/drivers/i2c/busses/i2c-xlr.c b/drivers/i2c/busses/i2c-xlr.c
index 484bfa15d58e..39c1d585b6cc 100644
--- a/drivers/i2c/busses/i2c-xlr.c
+++ b/drivers/i2c/busses/i2c-xlr.c
@@ -406,7 +406,7 @@ static int xlr_i2c_probe(struct platform_device *pdev)
 
 	if (of_property_read_u32(pdev->dev.of_node, "clock-frequency",
 				 &busfreq))
-		busfreq = 100000;
+		busfreq = I2C_MAX_STANDARD_MODE_FREQ;
 
 	clk = devm_clk_get(&pdev->dev, NULL);
 	if (!IS_ERR(clk)) {
