net: bridge: multicast: add per-port EHT hosts limit

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 89268b056ed116e13ba39f46481ad8bf5eef7bc4
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/89268b05.failed

Add a default limit of 512 for number of tracked EHT hosts per-port.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 89268b056ed116e13ba39f46481ad8bf5eef7bc4)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast_eht.c
#	net/bridge/br_private_mcast_eht.h
diff --cc net/bridge/br_private_mcast_eht.h
index 0c9c4267969d,b2c8d988721f..000000000000
--- a/net/bridge/br_private_mcast_eht.h
+++ b/net/bridge/br_private_mcast_eht.h
@@@ -47,4 -49,43 +49,46 @@@ struct net_bridge_group_eht_set 
  	struct net_bridge_mcast_gc	mcast_gc;
  };
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ void br_multicast_eht_clean_sets(struct net_bridge_port_group *pg);
+ bool br_multicast_eht_handle(struct net_bridge_port_group *pg,
+ 			     void *h_addr,
+ 			     void *srcs,
+ 			     u32 nsrcs,
+ 			     size_t addr_size,
+ 			     int grec_type);
+ 
+ static inline bool
+ br_multicast_eht_should_del_pg(const struct net_bridge_port_group *pg)
+ {
+ 	return !!((pg->key.port->flags & BR_MULTICAST_FAST_LEAVE) &&
+ 		  RB_EMPTY_ROOT(&pg->eht_host_tree));
+ }
+ 
+ static inline bool
+ br_multicast_eht_hosts_over_limit(const struct net_bridge_port_group *pg)
+ {
+ 	const struct net_bridge_port *p = pg->key.port;
+ 
+ 	return !!(p->multicast_eht_hosts_cnt >= p->multicast_eht_hosts_limit);
+ }
+ 
+ static inline void br_multicast_eht_hosts_inc(struct net_bridge_port_group *pg)
+ {
+ 	struct net_bridge_port *p = pg->key.port;
+ 
+ 	p->multicast_eht_hosts_cnt++;
+ }
+ 
+ static inline void br_multicast_eht_hosts_dec(struct net_bridge_port_group *pg)
+ {
+ 	struct net_bridge_port *p = pg->key.port;
+ 
+ 	p->multicast_eht_hosts_cnt--;
+ }
+ #endif /* CONFIG_BRIDGE_IGMP_SNOOPING */
+ 
++>>>>>>> 89268b056ed1 (net: bridge: multicast: add per-port EHT hosts limit)
  #endif /* _BR_PRIVATE_MCAST_EHT_H_ */
* Unmerged path net/bridge/br_multicast_eht.c
diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c
index 4eaac3b4a6ea..e1479770aaed 100644
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@ -1201,6 +1201,7 @@ static void br_mc_disabled_update(struct net_device *dev, bool value)
 int br_multicast_add_port(struct net_bridge_port *port)
 {
 	port->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
+	port->multicast_eht_hosts_limit = BR_MCAST_DEFAULT_EHT_HOSTS_LIMIT;
 
 	timer_setup(&port->multicast_router_timer,
 		    br_multicast_router_expired, 0);
* Unmerged path net/bridge/br_multicast_eht.c
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 032a117dc438..c94146ef807c 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -301,6 +301,8 @@ struct net_bridge_port {
 #if IS_ENABLED(CONFIG_IPV6)
 	struct bridge_mcast_own_query	ip6_own_query;
 #endif /* IS_ENABLED(CONFIG_IPV6) */
+	u32				multicast_eht_hosts_limit;
+	u32				multicast_eht_hosts_cnt;
 	unsigned char			multicast_router;
 	struct bridge_mcast_stats	__percpu *mcast_stats;
 	struct timer_list		multicast_router_timer;
* Unmerged path net/bridge/br_private_mcast_eht.h
