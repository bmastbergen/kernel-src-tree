KVM: x86: check for interrupts before deciding whether to exit the fast path

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Paolo Bonzini <pbonzini@redhat.com>
commit de7cd3f6761f49bef044ec49493d88737a70f1a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/de7cd3f6.failed

The kvm_x86_sync_pir_to_irr callback can sometimes set KVM_REQ_EVENT.
If that happens exactly at the time that an exit is handled as
EXIT_FASTPATH_REENTER_GUEST, vcpu_enter_guest will go incorrectly
through the loop that calls kvm_x86_run, instead of processing
the request promptly.

Fixes: 379a3c8ee444 ("KVM: VMX: Optimize posted-interrupt delivery for timer fastpath")
	Cc: stable@vger.kernel.org
	Reviewed-by: Sean Christopherson <seanjc@google.com>
	Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
(cherry picked from commit de7cd3f6761f49bef044ec49493d88737a70f1a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kvm/x86.c
diff --cc arch/x86/kvm/x86.c
index b44e3c47d784,381384a54790..000000000000
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@@ -9450,7 -9638,19 +9450,23 @@@ static int vcpu_enter_guest(struct kvm_
  		set_debugreg(0, 7);
  	}
  
++<<<<<<< HEAD
 +	exit_fastpath = static_call(kvm_x86_run)(vcpu);
++=======
+ 	for (;;) {
+ 		exit_fastpath = static_call(kvm_x86_run)(vcpu);
+ 		if (likely(exit_fastpath != EXIT_FASTPATH_REENTER_GUEST))
+ 			break;
+ 
+ 		if (vcpu->arch.apicv_active)
+ 			static_call(kvm_x86_sync_pir_to_irr)(vcpu);
+ 
+ 		if (unlikely(kvm_vcpu_exit_request(vcpu))) {
+ 			exit_fastpath = EXIT_FASTPATH_EXIT_HANDLED;
+ 			break;
+ 		}
+ 	}
++>>>>>>> de7cd3f6761f (KVM: x86: check for interrupts before deciding whether to exit the fast path)
  
  	/*
  	 * Do this here before restoring debug registers on the host.  And
* Unmerged path arch/x86/kvm/x86.c
