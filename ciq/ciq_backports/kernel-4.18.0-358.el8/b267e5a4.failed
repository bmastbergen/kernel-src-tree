selftests/bpf: Introduce xsk statistics tests

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Ciara Loftus <ciara.loftus@intel.com>
commit b267e5a458a719f3f5eaaaebe87c5f4a13584832
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/b267e5a4.failed

This commit introduces a range of tests to the xsk testsuite
for validating xsk statistics.

A new test type called 'stats' is added. Within it there are
four sub-tests. Each test configures a scenario which should
trigger the given error statistic. The test passes if the statistic
is successfully incremented.

The four statistics for which tests have been created are:
1. rx dropped
Increase the UMEM frame headroom to a value which results in
insufficient space in the rx buffer for both the packet and the headroom.
2. tx invalid
Set the 'len' field of tx descriptors to an invalid value (umem frame
size + 1).
3. rx ring full
Reduce the size of the RX ring to a fraction of the fill ring size.
4. fill queue empty
Do not populate the fill queue and then try to receive pkts.

	Signed-off-by: Ciara Loftus <ciara.loftus@intel.com>
	Signed-off-by: Alexei Starovoitov <ast@kernel.org>
	Reviewed-by: Maciej Fijalkowski <maciej.fijalkowski@intel.com>
Link: https://lore.kernel.org/bpf/20210223162304.7450-5-ciara.loftus@intel.com
(cherry picked from commit b267e5a458a719f3f5eaaaebe87c5f4a13584832)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	tools/testing/selftests/bpf/xdpxceiver.c
#	tools/testing/selftests/bpf/xdpxceiver.h
diff --cc tools/testing/selftests/bpf/xdpxceiver.c
index 9b94f4edc542,8b0f7fdd9003..000000000000
--- a/tools/testing/selftests/bpf/xdpxceiver.c
+++ b/tools/testing/selftests/bpf/xdpxceiver.c
@@@ -33,19 -28,21 +33,36 @@@
   *       Configure sockets as bi-directional tx/rx sockets, sets up fill and
   *       completion rings on each socket, tx/rx in both directions. Only nopoll
   *       mode is used
+  *    e. Statistics
+  *       Trigger some error conditions and ensure that the appropriate statistics
+  *       are incremented. Within this test, the following statistics are tested:
+  *       i.   rx dropped
+  *            Increase the UMEM frame headroom to a value which results in
+  *            insufficient space in the rx buffer for both the packet and the headroom.
+  *       ii.  tx invalid
+  *            Set the 'len' field of tx descriptors to an invalid value (umem frame
+  *            size + 1).
+  *       iii. rx ring full
+  *            Reduce the size of the RX ring to a fraction of the fill ring size.
+  *       iv.  fill queue empty
+  *            Do not populate the fill queue and then try to receive pkts.
   *
++<<<<<<< HEAD
 + * 2. AF_XDP DRV/Native mode
 + *    Works on any netdevice with XDP_REDIRECT support, driver dependent. Processes
 + *    packets before SKB allocation. Provides better performance than SKB. Driver
 + *    hook available just after DMA of buffer descriptor.
 + *    a. nopoll
 + *    b. poll
 + *    c. Socket Teardown
 + *    d. Bi-directional sockets
 + *    - Only copy mode is supported because veth does not currently support
 + *      zero-copy mode
 + *
 + * Total tests: 8
++=======
+  * Total tests: 10
++>>>>>>> b267e5a458a7 (selftests/bpf: Introduce xsk statistics tests)
   *
   * Flow:
   * -----
@@@ -106,9 -108,11 +123,17 @@@ static void __exit_with_error(int error
  #define exit_with_error(error) __exit_with_error(error, __FILE__, __func__, __LINE__)
  
  #define print_ksft_result(void)\
++<<<<<<< HEAD
 +	(ksft_test_result_pass("PASS: %s %s %s%s\n", uut ? "DRV" : "SKB", opt_poll ? "POLL" :\
 +			       "NOPOLL", opt_teardown ? "Socket Teardown" : "",\
 +			       opt_bidi ? "Bi-directional Sockets" : ""))
++=======
+ 	(ksft_test_result_pass("PASS: %s %s %s%s%s\n", configured_mode ? "DRV" : "SKB",\
+ 			       test_type == TEST_TYPE_POLL ? "POLL" : "NOPOLL",\
+ 			       test_type == TEST_TYPE_TEARDOWN ? "Socket Teardown" : "",\
+ 			       test_type == TEST_TYPE_BIDI ? "Bi-directional Sockets" : "",\
+ 			       test_type == TEST_TYPE_STATS ? "Stats" : ""))
++>>>>>>> b267e5a458a7 (selftests/bpf: Introduce xsk statistics tests)
  
  static void pthread_init_mutex(void)
  {
@@@ -308,13 -319,13 +340,13 @@@ static int xsk_configure_socket(struct 
  		exit_with_error(errno);
  
  	ifobject->xsk->umem = ifobject->umem;
- 	cfg.rx_size = XSK_RING_CONS__DEFAULT_NUM_DESCS;
+ 	cfg.rx_size = rxqsize;
  	cfg.tx_size = XSK_RING_PROD__DEFAULT_NUM_DESCS;
  	cfg.libbpf_flags = 0;
 -	cfg.xdp_flags = xdp_flags;
 -	cfg.bind_flags = xdp_bind_flags;
 +	cfg.xdp_flags = opt_xdp_flags;
 +	cfg.bind_flags = opt_xdp_bind_flags;
  
 -	if (test_type != TEST_TYPE_BIDI) {
 +	if (!opt_bidi) {
  		rxr = (ifobject->fv.vector == rx) ? &ifobject->xsk->rx : NULL;
  		txr = (ifobject->fv.vector == tx) ? &ifobject->xsk->tx : NULL;
  	} else {
@@@ -895,10 -932,11 +982,11 @@@ static void *worker_testapp_validate(vo
  				break;
  		}
  
- 		print_verbose("Received %d packets on interface %s\n",
- 			       pkt_counter, ifobject->ifname);
+ 		if (test_type != TEST_TYPE_STATS)
+ 			print_verbose("Received %d packets on interface %s\n",
+ 				pkt_counter, ifobject->ifname);
  
 -		if (test_type == TEST_TYPE_TEARDOWN)
 +		if (opt_teardown)
  			print_verbose("Destroying socket\n");
  	}
  
@@@ -969,7 -1008,7 +1057,11 @@@ static void testapp_validate(void
  		free(pkt_buf);
  	}
  
++<<<<<<< HEAD
 +	if (!opt_teardown && !opt_bidi)
++=======
+ 	if (!(test_type == TEST_TYPE_TEARDOWN) && !bidi && !(test_type == TEST_TYPE_STATS))
++>>>>>>> b267e5a458a7 (selftests/bpf: Introduce xsk statistics tests)
  		print_ksft_result();
  }
  
@@@ -1008,6 -1074,104 +1126,107 @@@ static void init_iface_config(struct if
  	ifdict[1]->src_port = ifaceconfig->dst_port;
  }
  
++<<<<<<< HEAD
++=======
+ static void *nsdisablemodethread(void *args)
+ {
+ 	struct targs *targs = args;
+ 
+ 	targs->retptr = false;
+ 
+ 	if (switch_namespace(targs->idx)) {
+ 		targs->retptr = bpf_set_link_xdp_fd(ifdict[targs->idx]->ifindex, -1, targs->flags);
+ 	} else {
+ 		targs->retptr = errno;
+ 		print_verbose("Failed to switch namespace to %s\n", ifdict[targs->idx]->nsname);
+ 	}
+ 
+ 	pthread_exit(NULL);
+ }
+ 
+ static void disable_xdp_mode(int mode)
+ {
+ 	int err = 0;
+ 	__u32 flags = XDP_FLAGS_UPDATE_IF_NOEXIST | mode;
+ 	char *mode_str = mode & XDP_FLAGS_SKB_MODE ? "skb" : "drv";
+ 
+ 	for (int i = 0; i < MAX_INTERFACES; i++) {
+ 		if (strcmp(ifdict[i]->nsname, "")) {
+ 			struct targs *targs;
+ 
+ 			targs = malloc(sizeof(*targs));
+ 			memset(targs, 0, sizeof(*targs));
+ 			if (!targs)
+ 				exit_with_error(errno);
+ 
+ 			targs->idx = i;
+ 			targs->flags = flags;
+ 			if (pthread_create(&ns_thread, NULL, nsdisablemodethread, targs))
+ 				exit_with_error(errno);
+ 
+ 			pthread_join(ns_thread, NULL);
+ 			err = targs->retptr;
+ 			free(targs);
+ 		} else {
+ 			err = bpf_set_link_xdp_fd(ifdict[i]->ifindex, -1, flags);
+ 		}
+ 
+ 		if (err) {
+ 			print_verbose("Failed to disable %s mode on interface %s\n",
+ 						mode_str, ifdict[i]->ifname);
+ 			exit_with_error(err);
+ 		}
+ 
+ 		print_verbose("Disabled %s mode for interface: %s\n", mode_str, ifdict[i]->ifname);
+ 		configured_mode = mode & XDP_FLAGS_SKB_MODE ? TEST_MODE_DRV : TEST_MODE_SKB;
+ 	}
+ }
+ 
+ static void run_pkt_test(int mode, int type)
+ {
+ 	test_type = type;
+ 
+ 	/* reset defaults after potential previous test */
+ 	xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST;
+ 	pkt_counter = 0;
+ 	switching_notify = 0;
+ 	bidi_pass = 0;
+ 	prev_pkt = -1;
+ 	ifdict[0]->fv.vector = tx;
+ 	ifdict[1]->fv.vector = rx;
+ 	sigvar = 0;
+ 	stat_test_type = -1;
+ 	rxqsize = XSK_RING_CONS__DEFAULT_NUM_DESCS;
+ 	frame_headroom = XSK_UMEM__DEFAULT_FRAME_HEADROOM;
+ 
+ 	switch (mode) {
+ 	case (TEST_MODE_SKB):
+ 		if (configured_mode == TEST_MODE_DRV)
+ 			disable_xdp_mode(XDP_FLAGS_DRV_MODE);
+ 		xdp_flags |= XDP_FLAGS_SKB_MODE;
+ 		break;
+ 	case (TEST_MODE_DRV):
+ 		if (configured_mode == TEST_MODE_SKB)
+ 			disable_xdp_mode(XDP_FLAGS_SKB_MODE);
+ 		xdp_flags |= XDP_FLAGS_DRV_MODE;
+ 		break;
+ 	default:
+ 		break;
+ 	}
+ 
+ 	pthread_init_mutex();
+ 
+ 	if (test_type == TEST_TYPE_STATS)
+ 		testapp_stats();
+ 	else if ((test_type != TEST_TYPE_TEARDOWN) && (test_type != TEST_TYPE_BIDI))
+ 		testapp_validate();
+ 	else
+ 		testapp_sockets();
+ 
+ 	pthread_destroy_mutex();
+ }
+ 
++>>>>>>> b267e5a458a7 (selftests/bpf: Introduce xsk statistics tests)
  int main(int argc, char **argv)
  {
  	struct rlimit _rlim = { RLIM_INFINITY, RLIM_INFINITY };
diff --cc tools/testing/selftests/bpf/xdpxceiver.h
index f66f399dfb2d,30314ef305c2..000000000000
--- a/tools/testing/selftests/bpf/xdpxceiver.h
+++ b/tools/testing/selftests/bpf/xdpxceiver.h
@@@ -41,6 -41,8 +41,11 @@@
  #define BATCH_SIZE 64
  #define POLL_TMOUT 1000
  #define NEED_WAKEUP true
++<<<<<<< HEAD
++=======
+ #define DEFAULT_PKT_CNT 10000
+ #define RX_FULL_RXQSIZE 32
++>>>>>>> b267e5a458a7 (selftests/bpf: Introduce xsk statistics tests)
  
  #define print_verbose(x...) do { if (opt_verbose) ksft_print_msg(x); } while (0)
  
@@@ -48,29 -50,50 +53,53 @@@ typedef __u32 u32
  typedef __u16 u16;
  typedef __u8 u8;
  
 -enum TEST_MODES {
 -	TEST_MODE_UNCONFIGURED = -1,
 -	TEST_MODE_SKB,
 -	TEST_MODE_DRV,
 -	TEST_MODE_MAX
 +enum TESTS {
 +	ORDER_CONTENT_VALIDATE_XDP_SKB = 0,
 +	ORDER_CONTENT_VALIDATE_XDP_DRV = 1,
  };
  
++<<<<<<< HEAD
 +static u8 uut;
++=======
+ enum TEST_TYPES {
+ 	TEST_TYPE_NOPOLL,
+ 	TEST_TYPE_POLL,
+ 	TEST_TYPE_TEARDOWN,
+ 	TEST_TYPE_BIDI,
+ 	TEST_TYPE_STATS,
+ 	TEST_TYPE_MAX
+ };
+ 
+ enum STAT_TEST_TYPES {
+ 	STAT_TEST_RX_DROPPED,
+ 	STAT_TEST_TX_INVALID,
+ 	STAT_TEST_RX_FULL,
+ 	STAT_TEST_RX_FILL_EMPTY,
+ 	STAT_TEST_TYPE_MAX
+ };
+ 
+ static int configured_mode = TEST_MODE_UNCONFIGURED;
++>>>>>>> b267e5a458a7 (selftests/bpf: Introduce xsk statistics tests)
  static u8 debug_pkt_dump;
  static u32 num_frames;
  static u8 switching_notify;
  static u8 bidi_pass;
 -static int test_type;
  
 +static u32 opt_xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST;
  static int opt_queue;
  static int opt_pkt_count;
 +static int opt_poll;
 +static int opt_teardown;
 +static int opt_bidi;
 +static u32 opt_xdp_bind_flags = XDP_USE_NEED_WAKEUP;
  static u8 opt_verbose;
 -
 -static u32 xdp_flags = XDP_FLAGS_UPDATE_IF_NOEXIST;
 -static u32 xdp_bind_flags = XDP_USE_NEED_WAKEUP | XDP_COPY;
  static u8 pkt_data[XSK_UMEM__DEFAULT_FRAME_SIZE];
  static u32 pkt_counter;
 -static long prev_pkt = -1;
 +static u32 prev_pkt = -1;
  static int sigvar;
+ static int stat_test_type;
+ static u32 rxqsize;
+ static u32 frame_headroom;
  
  struct xsk_umem_info {
  	struct xsk_ring_prod fq;
* Unmerged path tools/testing/selftests/bpf/xdpxceiver.c
* Unmerged path tools/testing/selftests/bpf/xdpxceiver.h
