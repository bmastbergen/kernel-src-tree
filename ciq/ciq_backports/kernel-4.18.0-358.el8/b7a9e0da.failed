net: switchdev: remove vid_begin -> vid_end range from VLAN objects

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Vladimir Oltean <vladimir.oltean@nxp.com>
commit b7a9e0da2d1c954b7c38217a29e002528b90d174
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/b7a9e0da.failed

The call path of a switchdev VLAN addition to the bridge looks something
like this today:

        nbp_vlan_init
        |  __br_vlan_set_default_pvid
        |  |                       |
        |  |    br_afspec          |
        |  |        |              |
        |  |        v              |
        |  | br_process_vlan_info  |
        |  |        |              |
        |  |        v              |
        |  |   br_vlan_info        |
        |  |       / \            /
        |  |      /   \          /
        |  |     /     \        /
        |  |    /       \      /
        v  v   v         v    v
      nbp_vlan_add   br_vlan_add ------+
       |              ^      ^ |       |
       |             /       | |       |
       |            /       /  /       |
       \ br_vlan_get_master/  /        v
        \        ^        /  /  br_vlan_add_existing
         \       |       /  /          |
          \      |      /  /          /
           \     |     /  /          /
            \    |    /  /          /
             \   |   /  /          /
              v  |   | v          /
              __vlan_add         /
                 / |            /
                /  |           /
               v   |          /
   __vlan_vid_add  |         /
               \   |        /
                v  v        v
      br_switchdev_port_vlan_add

The ranges UAPI was introduced to the bridge in commit bdced7ef7838
("bridge: support for multiple vlans and vlan ranges in setlink and
dellink requests") (Jan 10 2015). But the VLAN ranges (parsed in br_afspec)
have always been passed one by one, through struct bridge_vlan_info
tmp_vinfo, to br_vlan_info. So the range never went too far in depth.

Then Scott Feldman introduced the switchdev_port_bridge_setlink function
in commit 47f8328bb1a4 ("switchdev: add new switchdev bridge setlink").
That marked the introduction of the SWITCHDEV_OBJ_PORT_VLAN, which made
full use of the range. But switchdev_port_bridge_setlink was called like
this:

br_setlink
-> br_afspec
-> switchdev_port_bridge_setlink

Basically, the switchdev and the bridge code were not tightly integrated.
Then commit 41c498b9359e ("bridge: restore br_setlink back to original")
came, and switchdev drivers were required to implement
.ndo_bridge_setlink = switchdev_port_bridge_setlink for a while.

In the meantime, commits such as 0944d6b5a2fa ("bridge: try switchdev op
first in __vlan_vid_add/del") finally made switchdev penetrate the
br_vlan_info() barrier and start to develop the call path we have today.
But remember, br_vlan_info() still receives VLANs one by one.

Then Arkadi Sharshevsky refactored the switchdev API in 2017 in commit
29ab586c3d83 ("net: switchdev: Remove bridge bypass support from
switchdev") so that drivers would not implement .ndo_bridge_setlink any
longer. The switchdev_port_bridge_setlink also got deleted.
This refactoring removed the parallel bridge_setlink implementation from
switchdev, and left the only switchdev VLAN objects to be the ones
offloaded from __vlan_vid_add (basically RX filtering) and  __vlan_add
(the latter coming from commit 9c86ce2c1ae3 ("net: bridge: Notify about
bridge VLANs")).

That is to say, today the switchdev VLAN object ranges are not used in
the kernel. Refactoring the above call path is a bit complicated, when
the bridge VLAN call path is already a bit complicated.

Let's go off and finish the job of commit 29ab586c3d83 by deleting the
bogus iteration through the VLAN ranges from the drivers. Some aspects
of this feature never made too much sense in the first place. For
example, what is a range of VLANs all having the BRIDGE_VLAN_INFO_PVID
flag supposed to mean, when a port can obviously have a single pvid?
This particular configuration _is_ denied as of commit 6623c60dc28e
("bridge: vlan: enforce no pvid flag in vlan ranges"), but from an API
perspective, the driver still has to play pretend, and only offload the
vlan->vid_end as pvid. And the addition of a switchdev VLAN object can
modify the flags of another, completely unrelated, switchdev VLAN
object! (a VLAN that is PVID will invalidate the PVID flag from whatever
other VLAN had previously been offloaded with switchdev and had that
flag. Yet switchdev never notifies about that change, drivers are
supposed to guess).

Nonetheless, having a VLAN range in the API makes error handling look
scarier than it really is - unwinding on errors and all of that.
When in reality, no one really calls this API with more than one VLAN.
It is all unnecessary complexity.

And despite appearing pretentious (two-phase transactional model and
all), the switchdev API is really sloppy because the VLAN addition and
removal operations are not paired with one another (you can add a VLAN
100 times and delete it just once). The bridge notifies through
switchdev of a VLAN addition not only when the flags of an existing VLAN
change, but also when nothing changes. There are switchdev drivers out
there who don't like adding a VLAN that has already been added, and
those checks don't really belong at driver level. But the fact that the
API contains ranges is yet another factor that prevents this from being
addressed in the future.

Of the existing switchdev pieces of hardware, it appears that only
Mellanox Spectrum supports offloading more than one VLAN at a time,
through mlxsw_sp_port_vlan_set. I have kept that code internal to the
driver, because there is some more bookkeeping that makes use of it, but
I deleted it from the switchdev API. But since the switchdev support for
ranges has already been de facto deleted by a Mellanox employee and
nobody noticed for 4 years, I'm going to assume it's not a biggie.

	Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
	Reviewed-by: Ido Schimmel <idosch@nvidia.com> # switchdev and mlxsw
	Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
	Reviewed-by: Kurt Kanzenbach <kurt@linutronix.de> # hellcreek
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit b7a9e0da2d1c954b7c38217a29e002528b90d174)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/dsa/b53/b53_common.c
#	drivers/net/dsa/bcm_sf2_cfp.c
#	drivers/net/dsa/dsa_loop.c
#	drivers/net/dsa/hirschmann/hellcreek.c
#	drivers/net/dsa/lantiq_gswip.c
#	drivers/net/dsa/microchip/ksz8795.c
#	drivers/net/dsa/microchip/ksz9477.c
#	drivers/net/dsa/mv88e6xxx/chip.c
#	drivers/net/dsa/ocelot/felix.c
#	drivers/net/dsa/qca8k.c
#	drivers/net/dsa/rtl8366.c
#	drivers/net/dsa/sja1105/sja1105_main.c
#	drivers/net/ethernet/marvell/prestera/prestera_switchdev.c
#	drivers/net/ethernet/mscc/ocelot_net.c
#	drivers/net/ethernet/ti/cpsw_switchdev.c
#	drivers/staging/fsl-dpaa2/ethsw/ethsw.c
#	net/dsa/slave.c
diff --cc drivers/net/dsa/b53/b53_common.c
index d93c790bfbe8,bab174c052b3..000000000000
--- a/drivers/net/dsa/b53/b53_common.c
+++ b/drivers/net/dsa/b53/b53_common.c
@@@ -1080,13 -1393,21 +1080,25 @@@ int b53_vlan_prepare(struct dsa_switch 
  {
  	struct b53_device *dev = ds->priv;
  
- 	if ((is5325(dev) || is5365(dev)) && vlan->vid_begin == 0)
+ 	if ((is5325(dev) || is5365(dev)) && vlan->vid == 0)
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	if (vlan->vid_end > dev->num_vlans)
++=======
+ 	/* Port 7 on 7278 connects to the ASP's UniMAC which is not capable of
+ 	 * receiving VLAN tagged frames at all, we can still allow the port to
+ 	 * be configured for egress untagged.
+ 	 */
+ 	if (dev->chip_id == BCM7278_DEVICE_ID && port == 7 &&
+ 	    !(vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED))
+ 		return -EINVAL;
+ 
+ 	if (vlan->vid > dev->num_vlans)
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  		return -ERANGE;
  
 -	b53_enable_vlan(dev, true, ds->vlan_filtering);
 +	b53_enable_vlan(dev, true);
  
  	return 0;
  }
@@@ -1099,27 -1420,27 +1111,35 @@@ void b53_vlan_add(struct dsa_switch *ds
  	bool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;
  	bool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;
  	struct b53_vlan *vl;
- 	u16 vid;
  
- 	for (vid = vlan->vid_begin; vid <= vlan->vid_end; ++vid) {
- 		vl = &dev->vlans[vid];
+ 	vl = &dev->vlans[vlan->vid];
  
- 		b53_get_vlan_entry(dev, vid, vl);
+ 	b53_get_vlan_entry(dev, vlan->vid, vl);
  
++<<<<<<< HEAD
 +		vl->members |= BIT(port);
 +		if (untagged)
 +			vl->untag |= BIT(port);
 +		else
 +			vl->untag &= ~BIT(port);
++=======
+ 	if (vlan->vid == 0 && vlan->vid == b53_default_pvid(dev))
+ 		untagged = true;
  
- 		b53_set_vlan_entry(dev, vid, vl);
- 		b53_fast_age_vlan(dev, vid);
- 	}
+ 	vl->members |= BIT(port);
+ 	if (untagged && !dsa_is_cpu_port(ds, port))
+ 		vl->untag |= BIT(port);
+ 	else
+ 		vl->untag &= ~BIT(port);
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
+ 
+ 	b53_set_vlan_entry(dev, vlan->vid, vl);
+ 	b53_fast_age_vlan(dev, vlan->vid);
  
 -	if (pvid && !dsa_is_cpu_port(ds, port)) {
 +	if (pvid) {
  		b53_write16(dev, B53_VLAN_PAGE, B53_VLAN_PORT_DEF_TAG(port),
- 			    vlan->vid_end);
- 		b53_fast_age_vlan(dev, vid);
+ 			    vlan->vid);
+ 		b53_fast_age_vlan(dev, vlan->vid);
  	}
  }
  EXPORT_SYMBOL(b53_vlan_add);
@@@ -1135,26 -1455,20 +1154,32 @@@ int b53_vlan_del(struct dsa_switch *ds
  
  	b53_read16(dev, B53_VLAN_PAGE, B53_VLAN_PORT_DEF_TAG(port), &pvid);
  
- 	for (vid = vlan->vid_begin; vid <= vlan->vid_end; ++vid) {
- 		vl = &dev->vlans[vid];
+ 	vl = &dev->vlans[vlan->vid];
  
- 		b53_get_vlan_entry(dev, vid, vl);
+ 	b53_get_vlan_entry(dev, vlan->vid, vl);
  
- 		vl->members &= ~BIT(port);
+ 	vl->members &= ~BIT(port);
  
++<<<<<<< HEAD
 +		if (pvid == vid) {
 +			if (is5325(dev) || is5365(dev))
 +				pvid = 1;
 +			else
 +				pvid = 0;
 +		}
 +
 +		if (untagged)
 +			vl->untag &= ~(BIT(port));
++=======
+ 	if (pvid == vlan->vid)
+ 		pvid = b53_default_pvid(dev);
  
- 		b53_set_vlan_entry(dev, vid, vl);
- 		b53_fast_age_vlan(dev, vid);
- 	}
+ 	if (untagged && !dsa_is_cpu_port(ds, port))
+ 		vl->untag &= ~(BIT(port));
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
+ 
+ 	b53_set_vlan_entry(dev, vlan->vid, vl);
+ 	b53_fast_age_vlan(dev, vlan->vid);
  
  	b53_write16(dev, B53_VLAN_PAGE, B53_VLAN_PORT_DEF_TAG(port), pvid);
  	b53_fast_age_vlan(dev, pvid);
diff --cc drivers/net/dsa/bcm_sf2_cfp.c
index b89acaee12d4,59d799ac1b60..000000000000
--- a/drivers/net/dsa/bcm_sf2_cfp.c
+++ b/drivers/net/dsa/bcm_sf2_cfp.c
@@@ -752,12 -864,40 +752,42 @@@ static int bcm_sf2_cfp_rule_set(struct 
  	 * destination port is enabled and that we are within the
  	 * number of ports supported by the switch
  	 */
 -	port_num = ring_cookie / SF2_NUM_EGRESS_QUEUES;
 +	port_num = fs->ring_cookie / SF2_NUM_EGRESS_QUEUES;
  
 -	if (ring_cookie == RX_CLS_FLOW_DISC ||
 -	    !(dsa_is_user_port(ds, port_num) ||
 -	      dsa_is_cpu_port(ds, port_num)) ||
 +	if (fs->ring_cookie == RX_CLS_FLOW_DISC ||
 +	    !dsa_is_user_port(ds, port_num) ||
  	    port_num >= priv->hw_params.num_ports)
  		return -EINVAL;
++<<<<<<< HEAD
++=======
+ 
+ 	/* If the rule is matching a particular VLAN, make sure that we honor
+ 	 * the matching and have it tagged or untagged on the destination port,
+ 	 * we do this on egress with a VLAN entry. The egress tagging attribute
+ 	 * is expected to be provided in h_ext.data[1] bit 0. A 1 means untagged,
+ 	 * a 0 means tagged.
+ 	 */
+ 	if (fs->flow_type & FLOW_EXT) {
+ 		/* We cannot support matching multiple VLAN IDs yet */
+ 		if ((be16_to_cpu(fs->m_ext.vlan_tci) & VLAN_VID_MASK) !=
+ 		    VLAN_VID_MASK)
+ 			return -EINVAL;
+ 
+ 		vid = be16_to_cpu(fs->h_ext.vlan_tci) & VLAN_VID_MASK;
+ 		vlan.vid = vid;
+ 		if (cpu_to_be32(fs->h_ext.data[1]) & 1)
+ 			vlan.flags = BRIDGE_VLAN_INFO_UNTAGGED;
+ 		else
+ 			vlan.flags = 0;
+ 
+ 		ret = ds->ops->port_vlan_prepare(ds, port_num, &vlan);
+ 		if (ret)
+ 			return ret;
+ 
+ 		ds->ops->port_vlan_add(ds, port_num, &vlan);
+ 	}
+ 
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  	/*
  	 * We have a small oddity where Port 6 just does not have a
  	 * valid bit here (so we substract by one).
diff --cc drivers/net/dsa/dsa_loop.c
index 17482ae09aa5,3be9f665d174..000000000000
--- a/drivers/net/dsa/dsa_loop.c
+++ b/drivers/net/dsa/dsa_loop.c
@@@ -194,7 -211,7 +193,11 @@@ dsa_loop_port_vlan_prepare(struct dsa_s
  	/* Just do a sleeping operation to make lockdep checks effective */
  	mdiobus_read(bus, ps->port_base + port, MII_BMSR);
  
++<<<<<<< HEAD
 +	if (vlan->vid_end > DSA_LOOP_VLANS)
++=======
+ 	if (vlan->vid > ARRAY_SIZE(ps->vlans))
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  		return -ERANGE;
  
  	return 0;
@@@ -213,21 -229,19 +215,23 @@@ static void dsa_loop_port_vlan_add(stru
  	/* Just do a sleeping operation to make lockdep checks effective */
  	mdiobus_read(bus, ps->port_base + port, MII_BMSR);
  
- 	for (vid = vlan->vid_begin; vid <= vlan->vid_end; ++vid) {
- 		vl = &ps->vlans[vid];
+ 	vl = &ps->vlans[vlan->vid];
  
- 		vl->members |= BIT(port);
- 		if (untagged)
- 			vl->untagged |= BIT(port);
- 		else
- 			vl->untagged &= ~BIT(port);
+ 	vl->members |= BIT(port);
+ 	if (untagged)
+ 		vl->untagged |= BIT(port);
+ 	else
+ 		vl->untagged &= ~BIT(port);
  
- 		dev_dbg(ds->dev, "%s: port: %d vlan: %d, %stagged, pvid: %d\n",
- 			__func__, port, vid, untagged ? "un" : "", pvid);
- 	}
+ 	dev_dbg(ds->dev, "%s: port: %d vlan: %d, %stagged, pvid: %d\n",
+ 		__func__, port, vlan->vid, untagged ? "un" : "", pvid);
  
  	if (pvid)
++<<<<<<< HEAD
 +		ps->pvid = vid;
++=======
+ 		ps->ports[port].pvid = vlan->vid;
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  }
  
  static int dsa_loop_port_vlan_del(struct dsa_switch *ds, int port,
@@@ -235,27 -249,25 +239,36 @@@
  {
  	bool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;
  	struct dsa_loop_priv *ps = ds->priv;
+ 	u16 pvid = ps->ports[port].pvid;
  	struct mii_bus *bus = ps->bus;
  	struct dsa_loop_vlan *vl;
++<<<<<<< HEAD
 +	u16 vid, pvid = ps->pvid;
++=======
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  
  	/* Just do a sleeping operation to make lockdep checks effective */
  	mdiobus_read(bus, ps->port_base + port, MII_BMSR);
  
- 	for (vid = vlan->vid_begin; vid <= vlan->vid_end; ++vid) {
- 		vl = &ps->vlans[vid];
+ 	vl = &ps->vlans[vlan->vid];
  
- 		vl->members &= ~BIT(port);
- 		if (untagged)
- 			vl->untagged &= ~BIT(port);
+ 	vl->members &= ~BIT(port);
+ 	if (untagged)
+ 		vl->untagged &= ~BIT(port);
  
- 		if (pvid == vid)
- 			pvid = 1;
+ 	if (pvid == vlan->vid)
+ 		pvid = 1;
  
++<<<<<<< HEAD
 +		dev_dbg(ds->dev, "%s: port: %d vlan: %d, %stagged, pvid: %d\n",
 +			__func__, port, vid, untagged ? "un" : "", pvid);
 +	}
 +	ps->pvid = pvid;
++=======
+ 	dev_dbg(ds->dev, "%s: port: %d vlan: %d, %stagged, pvid: %d\n",
+ 		__func__, port, vlan->vid, untagged ? "un" : "", pvid);
+ 	ps->ports[port].pvid = pvid;
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  
  	return 0;
  }
diff --cc drivers/net/dsa/mv88e6xxx/chip.c
index bb28c701381a,4834be9e4e86..000000000000
--- a/drivers/net/dsa/mv88e6xxx/chip.c
+++ b/drivers/net/dsa/mv88e6xxx/chip.c
@@@ -1361,103 -1528,58 +1361,131 @@@ static int mv88e6xxx_atu_new(struct mv8
  	return mv88e6xxx_g1_atu_flush(chip, *fid, true);
  }
  
 +static int mv88e6xxx_vtu_get(struct mv88e6xxx_chip *chip, u16 vid,
 +			     struct mv88e6xxx_vtu_entry *entry, bool new)
 +{
 +	int err;
 +
 +	if (!vid)
 +		return -EINVAL;
 +
 +	entry->vid = vid - 1;
 +	entry->valid = false;
 +
 +	err = mv88e6xxx_vtu_getnext(chip, entry);
 +	if (err)
 +		return err;
 +
 +	if (entry->vid == vid && entry->valid)
 +		return 0;
 +
 +	if (new) {
 +		int i;
 +
 +		/* Initialize a fresh VLAN entry */
 +		memset(entry, 0, sizeof(*entry));
 +		entry->valid = true;
 +		entry->vid = vid;
 +
 +		/* Exclude all ports */
 +		for (i = 0; i < mv88e6xxx_num_ports(chip); ++i)
 +			entry->member[i] =
 +				MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_NON_MEMBER;
 +
 +		return mv88e6xxx_atu_new(chip, &entry->fid);
 +	}
 +
 +	/* switchdev expects -EOPNOTSUPP to honor software VLANs */
 +	return -EOPNOTSUPP;
 +}
 +
  static int mv88e6xxx_port_check_hw_vlan(struct dsa_switch *ds, int port,
- 					u16 vid_begin, u16 vid_end)
+ 					u16 vid)
  {
  	struct mv88e6xxx_chip *chip = ds->priv;
 -	struct mv88e6xxx_vtu_entry vlan;
 +	struct mv88e6xxx_vtu_entry vlan = {
 +		.vid = vid_begin - 1,
 +	};
  	int i, err;
  
  	/* DSA and CPU ports have to be members of multiple vlans */
  	if (dsa_is_dsa_port(ds, port) || dsa_is_cpu_port(ds, port))
  		return 0;
  
- 	if (!vid_begin)
+ 	if (!vid)
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	mutex_lock(&chip->reg_lock);
 +
 +	do {
 +		err = mv88e6xxx_vtu_getnext(chip, &vlan);
 +		if (err)
 +			goto unlock;
++=======
+ 	vlan.vid = vid - 1;
+ 	vlan.valid = false;
  
- 		if (!vlan.valid)
- 			break;
+ 	err = mv88e6xxx_vtu_getnext(chip, &vlan);
+ 	if (err)
+ 		return err;
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  
- 		if (vlan.vid > vid_end)
- 			break;
+ 	if (!vlan.valid)
+ 		return 0;
  
- 		for (i = 0; i < mv88e6xxx_num_ports(chip); ++i) {
- 			if (dsa_is_dsa_port(ds, i) || dsa_is_cpu_port(ds, i))
- 				continue;
+ 	if (vlan.vid != vid)
+ 		return 0;
  
+ 	for (i = 0; i < mv88e6xxx_num_ports(chip); ++i) {
+ 		if (dsa_is_dsa_port(ds, i) || dsa_is_cpu_port(ds, i))
+ 			continue;
+ 
++<<<<<<< HEAD
 +			if (!ds->ports[i].slave)
 +				continue;
++=======
+ 		if (!dsa_to_port(ds, i)->slave)
+ 			continue;
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  
- 			if (vlan.member[i] ==
- 			    MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_NON_MEMBER)
- 				continue;
+ 		if (vlan.member[i] ==
+ 		    MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_NON_MEMBER)
+ 			continue;
  
++<<<<<<< HEAD
 +			if (dsa_to_port(ds, i)->bridge_dev ==
 +			    ds->ports[port].bridge_dev)
 +				break; /* same bridge, check next VLAN */
++=======
+ 		if (dsa_to_port(ds, i)->bridge_dev ==
+ 		    dsa_to_port(ds, port)->bridge_dev)
+ 			break; /* same bridge, check next VLAN */
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  
- 			if (!dsa_to_port(ds, i)->bridge_dev)
- 				continue;
+ 		if (!dsa_to_port(ds, i)->bridge_dev)
+ 			continue;
  
++<<<<<<< HEAD
 +			dev_err(ds->dev, "p%d: hw VLAN %d already used by port %d in %s\n",
 +				port, vlan.vid, i,
 +				netdev_name(dsa_to_port(ds, i)->bridge_dev));
 +			err = -EOPNOTSUPP;
 +			goto unlock;
 +		}
 +	} while (vlan.vid < vid_end);
++=======
+ 		dev_err(ds->dev, "p%d: hw VLAN %d already used by port %d in %s\n",
+ 			port, vlan.vid, i,
+ 			netdev_name(dsa_to_port(ds, i)->bridge_dev));
+ 		return -EOPNOTSUPP;
+ 	}
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  
 -	return 0;
 +unlock:
 +	mutex_unlock(&chip->reg_lock);
 +
 +	return err;
  }
  
  static int mv88e6xxx_port_vlan_filtering(struct dsa_switch *ds, int port,
@@@ -1491,59 -1614,280 +1519,65 @@@ mv88e6xxx_port_vlan_prepare(struct dsa_
  	/* If the requested port doesn't belong to the same bridge as the VLAN
  	 * members, do not support it (yet) and fallback to software VLAN.
  	 */
 -	mv88e6xxx_reg_lock(chip);
 -	err = mv88e6xxx_port_check_hw_vlan(ds, port, vlan->vid);
 -	mv88e6xxx_reg_unlock(chip);
 -
 -	/* We don't need any dynamic resource from the kernel (yet),
 -	 * so skip the prepare phase.
 -	 */
 -	return err;
 -}
 -
 -static int mv88e6xxx_port_db_load_purge(struct mv88e6xxx_chip *chip, int port,
 -					const unsigned char *addr, u16 vid,
 -					u8 state)
 -{
 -	struct mv88e6xxx_atu_entry entry;
 -	struct mv88e6xxx_vtu_entry vlan;
 -	u16 fid;
 -	int err;
 -
 -	/* Null VLAN ID corresponds to the port private database */
 -	if (vid == 0) {
 -		err = mv88e6xxx_port_get_fid(chip, port, &fid);
 -		if (err)
 -			return err;
 -	} else {
 -		vlan.vid = vid - 1;
 -		vlan.valid = false;
 -
 -		err = mv88e6xxx_vtu_getnext(chip, &vlan);
 -		if (err)
 -			return err;
 -
 -		/* switchdev expects -EOPNOTSUPP to honor software VLANs */
 -		if (vlan.vid != vid || !vlan.valid)
 -			return -EOPNOTSUPP;
 -
 -		fid = vlan.fid;
 -	}
 -
 -	entry.state = 0;
 -	ether_addr_copy(entry.mac, addr);
 -	eth_addr_dec(entry.mac);
 -
 -	err = mv88e6xxx_g1_atu_getnext(chip, fid, &entry);
++<<<<<<< HEAD
 +	err = mv88e6xxx_port_check_hw_vlan(ds, port, vlan->vid_begin,
 +					   vlan->vid_end);
  	if (err)
 -		return err;
 -
 -	/* Initialize a fresh ATU entry if it isn't found */
 -	if (!entry.state || !ether_addr_equal(entry.mac, addr)) {
 -		memset(&entry, 0, sizeof(entry));
 -		ether_addr_copy(entry.mac, addr);
 -	}
 -
 -	/* Purge the ATU entry only if no port is using it anymore */
 -	if (!state) {
 -		entry.portvec &= ~BIT(port);
 -		if (!entry.portvec)
 -			entry.state = 0;
 -	} else {
 -		entry.portvec |= BIT(port);
 -		entry.state = state;
 -	}
 -
 -	return mv88e6xxx_g1_atu_loadpurge(chip, fid, &entry);
 -}
 -
 -static int mv88e6xxx_policy_apply(struct mv88e6xxx_chip *chip, int port,
 -				  const struct mv88e6xxx_policy *policy)
 -{
 -	enum mv88e6xxx_policy_mapping mapping = policy->mapping;
 -	enum mv88e6xxx_policy_action action = policy->action;
 -	const u8 *addr = policy->addr;
 -	u16 vid = policy->vid;
 -	u8 state;
 -	int err;
 -	int id;
 -
 -	if (!chip->info->ops->port_set_policy)
 -		return -EOPNOTSUPP;
 -
 -	switch (mapping) {
 -	case MV88E6XXX_POLICY_MAPPING_DA:
 -	case MV88E6XXX_POLICY_MAPPING_SA:
 -		if (action == MV88E6XXX_POLICY_ACTION_NORMAL)
 -			state = 0; /* Dissociate the port and address */
 -		else if (action == MV88E6XXX_POLICY_ACTION_DISCARD &&
 -			 is_multicast_ether_addr(addr))
 -			state = MV88E6XXX_G1_ATU_DATA_STATE_MC_STATIC_POLICY;
 -		else if (action == MV88E6XXX_POLICY_ACTION_DISCARD &&
 -			 is_unicast_ether_addr(addr))
 -			state = MV88E6XXX_G1_ATU_DATA_STATE_UC_STATIC_POLICY;
 -		else
 -			return -EOPNOTSUPP;
 -
 -		err = mv88e6xxx_port_db_load_purge(chip, port, addr, vid,
 -						   state);
 -		if (err)
 -			return err;
 -		break;
 -	default:
 -		return -EOPNOTSUPP;
 -	}
 -
 -	/* Skip the port's policy clearing if the mapping is still in use */
 -	if (action == MV88E6XXX_POLICY_ACTION_NORMAL)
 -		idr_for_each_entry(&chip->policies, policy, id)
 -			if (policy->port == port &&
 -			    policy->mapping == mapping &&
 -			    policy->action != action)
 -				return 0;
 -
 -	return chip->info->ops->port_set_policy(chip, port, mapping, action);
 -}
 -
 -static int mv88e6xxx_policy_insert(struct mv88e6xxx_chip *chip, int port,
 -				   struct ethtool_rx_flow_spec *fs)
 -{
 -	struct ethhdr *mac_entry = &fs->h_u.ether_spec;
 -	struct ethhdr *mac_mask = &fs->m_u.ether_spec;
 -	enum mv88e6xxx_policy_mapping mapping;
 -	enum mv88e6xxx_policy_action action;
 -	struct mv88e6xxx_policy *policy;
 -	u16 vid = 0;
 -	u8 *addr;
 -	int err;
 -	int id;
 -
 -	if (fs->location != RX_CLS_LOC_ANY)
 -		return -EINVAL;
 -
 -	if (fs->ring_cookie == RX_CLS_FLOW_DISC)
 -		action = MV88E6XXX_POLICY_ACTION_DISCARD;
 -	else
 -		return -EOPNOTSUPP;
 -
 -	switch (fs->flow_type & ~FLOW_EXT) {
 -	case ETHER_FLOW:
 -		if (!is_zero_ether_addr(mac_mask->h_dest) &&
 -		    is_zero_ether_addr(mac_mask->h_source)) {
 -			mapping = MV88E6XXX_POLICY_MAPPING_DA;
 -			addr = mac_entry->h_dest;
 -		} else if (is_zero_ether_addr(mac_mask->h_dest) &&
 -		    !is_zero_ether_addr(mac_mask->h_source)) {
 -			mapping = MV88E6XXX_POLICY_MAPPING_SA;
 -			addr = mac_entry->h_source;
 -		} else {
 -			/* Cannot support DA and SA mapping in the same rule */
 -			return -EOPNOTSUPP;
 -		}
 -		break;
 -	default:
 -		return -EOPNOTSUPP;
 -	}
 -
 -	if ((fs->flow_type & FLOW_EXT) && fs->m_ext.vlan_tci) {
 -		if (fs->m_ext.vlan_tci != htons(0xffff))
 -			return -EOPNOTSUPP;
 -		vid = be16_to_cpu(fs->h_ext.vlan_tci) & VLAN_VID_MASK;
 -	}
 -
 -	idr_for_each_entry(&chip->policies, policy, id) {
 -		if (policy->port == port && policy->mapping == mapping &&
 -		    policy->action == action && policy->vid == vid &&
 -		    ether_addr_equal(policy->addr, addr))
 -			return -EEXIST;
 -	}
 -
 -	policy = devm_kzalloc(chip->dev, sizeof(*policy), GFP_KERNEL);
 -	if (!policy)
 -		return -ENOMEM;
 -
 -	fs->location = 0;
 -	err = idr_alloc_u32(&chip->policies, policy, &fs->location, 0xffffffff,
 -			    GFP_KERNEL);
 -	if (err) {
 -		devm_kfree(chip->dev, policy);
 -		return err;
 -	}
 -
 -	memcpy(&policy->fs, fs, sizeof(*fs));
 -	ether_addr_copy(policy->addr, addr);
 -	policy->mapping = mapping;
 -	policy->action = action;
 -	policy->port = port;
 -	policy->vid = vid;
 -
 -	err = mv88e6xxx_policy_apply(chip, port, policy);
 -	if (err) {
 -		idr_remove(&chip->policies, fs->location);
 -		devm_kfree(chip->dev, policy);
 -		return err;
 -	}
 -
 -	return 0;
 -}
 -
 -static int mv88e6xxx_get_rxnfc(struct dsa_switch *ds, int port,
 -			       struct ethtool_rxnfc *rxnfc, u32 *rule_locs)
 -{
 -	struct ethtool_rx_flow_spec *fs = &rxnfc->fs;
 -	struct mv88e6xxx_chip *chip = ds->priv;
 -	struct mv88e6xxx_policy *policy;
 -	int err;
 -	int id;
 -
 -	mv88e6xxx_reg_lock(chip);
 -
 -	switch (rxnfc->cmd) {
 -	case ETHTOOL_GRXCLSRLCNT:
 -		rxnfc->data = 0;
 -		rxnfc->data |= RX_CLS_LOC_SPECIAL;
 -		rxnfc->rule_cnt = 0;
 -		idr_for_each_entry(&chip->policies, policy, id)
 -			if (policy->port == port)
 -				rxnfc->rule_cnt++;
 -		err = 0;
 -		break;
 -	case ETHTOOL_GRXCLSRULE:
 -		err = -ENOENT;
 -		policy = idr_find(&chip->policies, fs->location);
 -		if (policy) {
 -			memcpy(fs, &policy->fs, sizeof(*fs));
 -			err = 0;
 -		}
 -		break;
 -	case ETHTOOL_GRXCLSRLALL:
 -		rxnfc->data = 0;
 -		rxnfc->rule_cnt = 0;
 -		idr_for_each_entry(&chip->policies, policy, id)
 -			if (policy->port == port)
 -				rule_locs[rxnfc->rule_cnt++] = id;
 -		err = 0;
 -		break;
 -	default:
 -		err = -EOPNOTSUPP;
 -		break;
 -	}
 -
 +		return err;
++=======
++	mv88e6xxx_reg_lock(chip);
++	err = mv88e6xxx_port_check_hw_vlan(ds, port, vlan->vid);
+ 	mv88e6xxx_reg_unlock(chip);
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  
 -	return err;
 +	/* We don't need any dynamic resource from the kernel (yet),
 +	 * so skip the prepare phase.
 +	 */
 +	return 0;
  }
  
 -static int mv88e6xxx_set_rxnfc(struct dsa_switch *ds, int port,
 -			       struct ethtool_rxnfc *rxnfc)
 +static int mv88e6xxx_port_db_load_purge(struct mv88e6xxx_chip *chip, int port,
 +					const unsigned char *addr, u16 vid,
 +					u8 state)
  {
 -	struct ethtool_rx_flow_spec *fs = &rxnfc->fs;
 -	struct mv88e6xxx_chip *chip = ds->priv;
 -	struct mv88e6xxx_policy *policy;
 +	struct mv88e6xxx_vtu_entry vlan;
 +	struct mv88e6xxx_atu_entry entry;
  	int err;
  
 -	mv88e6xxx_reg_lock(chip);
 +	/* Null VLAN ID corresponds to the port private database */
 +	if (vid == 0)
 +		err = mv88e6xxx_port_get_fid(chip, port, &vlan.fid);
 +	else
 +		err = mv88e6xxx_vtu_get(chip, vid, &vlan, false);
 +	if (err)
 +		return err;
  
 -	switch (rxnfc->cmd) {
 -	case ETHTOOL_SRXCLSRLINS:
 -		err = mv88e6xxx_policy_insert(chip, port, fs);
 -		break;
 -	case ETHTOOL_SRXCLSRLDEL:
 -		err = -ENOENT;
 -		policy = idr_remove(&chip->policies, fs->location);
 -		if (policy) {
 -			policy->action = MV88E6XXX_POLICY_ACTION_NORMAL;
 -			err = mv88e6xxx_policy_apply(chip, port, policy);
 -			devm_kfree(chip->dev, policy);
 -		}
 -		break;
 -	default:
 -		err = -EOPNOTSUPP;
 -		break;
 +	entry.state = MV88E6XXX_G1_ATU_DATA_STATE_UNUSED;
 +	ether_addr_copy(entry.mac, addr);
 +	eth_addr_dec(entry.mac);
 +
 +	err = mv88e6xxx_g1_atu_getnext(chip, vlan.fid, &entry);
 +	if (err)
 +		return err;
 +
 +	/* Initialize a fresh ATU entry if it isn't found */
 +	if (entry.state == MV88E6XXX_G1_ATU_DATA_STATE_UNUSED ||
 +	    !ether_addr_equal(entry.mac, addr)) {
 +		memset(&entry, 0, sizeof(entry));
 +		ether_addr_copy(entry.mac, addr);
  	}
  
 -	mv88e6xxx_reg_unlock(chip);
 +	/* Purge the ATU entry only if no port is using it anymore */
 +	if (state == MV88E6XXX_G1_ATU_DATA_STATE_UNUSED) {
 +		entry.portvec &= ~BIT(port);
 +		if (!entry.portvec)
 +			entry.state = MV88E6XXX_G1_ATU_DATA_STATE_UNUSED;
 +	} else {
 +		entry.portvec |= BIT(port);
 +		entry.state = state;
 +	}
  
 -	return err;
 +	return mv88e6xxx_g1_atu_loadpurge(chip, vlan.fid, &entry);
  }
  
  static int mv88e6xxx_port_add_broadcast(struct mv88e6xxx_chip *chip, int port,
@@@ -1594,10 -1973,10 +1628,9 @@@ static void mv88e6xxx_port_vlan_add(str
  	struct mv88e6xxx_chip *chip = ds->priv;
  	bool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;
  	bool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;
 -	bool warn;
  	u8 member;
- 	u16 vid;
  
 -	if (!mv88e6xxx_max_vid(chip))
 +	if (!chip->info->max_vid)
  		return;
  
  	if (dsa_is_dsa_port(ds, port) || dsa_is_cpu_port(ds, port))
@@@ -1607,22 -1986,26 +1640,28 @@@
  	else
  		member = MV88E6XXX_G1_VTU_DATA_MEMBER_TAG_TAGGED;
  
 -	/* net/dsa/slave.c will call dsa_port_vlan_add() for the affected port
 -	 * and then the CPU port. Do not warn for duplicates for the CPU port.
 -	 */
 -	warn = !dsa_is_cpu_port(ds, port) && !dsa_is_dsa_port(ds, port);
 -
 -	mv88e6xxx_reg_lock(chip);
 +	mutex_lock(&chip->reg_lock);
  
++<<<<<<< HEAD
 +	for (vid = vlan->vid_begin; vid <= vlan->vid_end; ++vid)
 +		if (_mv88e6xxx_port_vlan_add(chip, port, vid, member))
 +			dev_err(ds->dev, "p%d: failed to add VLAN %d%c\n", port,
 +				vid, untagged ? 'u' : 't');
++=======
+ 	if (mv88e6xxx_port_vlan_join(chip, port, vlan->vid, member, warn))
+ 		dev_err(ds->dev, "p%d: failed to add VLAN %d%c\n", port,
+ 			vlan->vid, untagged ? 'u' : 't');
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  
- 	if (pvid && mv88e6xxx_port_set_pvid(chip, port, vlan->vid_end))
+ 	if (pvid && mv88e6xxx_port_set_pvid(chip, port, vlan->vid))
  		dev_err(ds->dev, "p%d: failed to set PVID %d\n", port,
- 			vlan->vid_end);
+ 			vlan->vid);
  
 -	mv88e6xxx_reg_unlock(chip);
 +	mutex_unlock(&chip->reg_lock);
  }
  
 -static int mv88e6xxx_port_vlan_leave(struct mv88e6xxx_chip *chip,
 -				     int port, u16 vid)
 +static int _mv88e6xxx_port_vlan_del(struct mv88e6xxx_chip *chip,
 +				    int port, u16 vid)
  {
  	struct mv88e6xxx_vtu_entry vlan;
  	int i, err;
@@@ -1658,28 -2050,26 +1697,31 @@@ static int mv88e6xxx_port_vlan_del(stru
  				   const struct switchdev_obj_port_vlan *vlan)
  {
  	struct mv88e6xxx_chip *chip = ds->priv;
- 	u16 pvid, vid;
  	int err = 0;
+ 	u16 pvid;
  
 -	if (!mv88e6xxx_max_vid(chip))
 +	if (!chip->info->max_vid)
  		return -EOPNOTSUPP;
  
 -	mv88e6xxx_reg_lock(chip);
 +	mutex_lock(&chip->reg_lock);
  
  	err = mv88e6xxx_port_get_pvid(chip, port, &pvid);
  	if (err)
  		goto unlock;
  
++<<<<<<< HEAD
 +	for (vid = vlan->vid_begin; vid <= vlan->vid_end; ++vid) {
 +		err = _mv88e6xxx_port_vlan_del(chip, port, vid);
++=======
+ 	err = mv88e6xxx_port_vlan_leave(chip, port, vlan->vid);
+ 	if (err)
+ 		goto unlock;
+ 
+ 	if (vlan->vid == pvid) {
+ 		err = mv88e6xxx_port_set_pvid(chip, port, 0);
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  		if (err)
  			goto unlock;
- 
- 		if (vid == pvid) {
- 			err = mv88e6xxx_port_set_pvid(chip, port, 0);
- 			if (err)
- 				goto unlock;
- 		}
  	}
  
  unlock:
diff --cc drivers/net/dsa/qca8k.c
index cdcde7f8e0b2,df99c696b688..000000000000
--- a/drivers/net/dsa/qca8k.c
+++ b/drivers/net/dsa/qca8k.c
@@@ -865,8 -1293,76 +865,78 @@@ qca8k_port_fdb_dump(struct dsa_switch *
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static int
+ qca8k_port_vlan_filtering(struct dsa_switch *ds, int port, bool vlan_filtering,
+ 			  struct switchdev_trans *trans)
+ {
+ 	struct qca8k_priv *priv = ds->priv;
+ 
+ 	if (switchdev_trans_ph_prepare(trans))
+ 		return 0;
+ 
+ 	if (vlan_filtering) {
+ 		qca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(port),
+ 			  QCA8K_PORT_LOOKUP_VLAN_MODE,
+ 			  QCA8K_PORT_LOOKUP_VLAN_MODE_SECURE);
+ 	} else {
+ 		qca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(port),
+ 			  QCA8K_PORT_LOOKUP_VLAN_MODE,
+ 			  QCA8K_PORT_LOOKUP_VLAN_MODE_NONE);
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int
+ qca8k_port_vlan_prepare(struct dsa_switch *ds, int port,
+ 			const struct switchdev_obj_port_vlan *vlan)
+ {
+ 	return 0;
+ }
+ 
+ static void
+ qca8k_port_vlan_add(struct dsa_switch *ds, int port,
+ 		    const struct switchdev_obj_port_vlan *vlan)
+ {
+ 	bool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;
+ 	bool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;
+ 	struct qca8k_priv *priv = ds->priv;
+ 	int ret = 0;
+ 
+ 	ret = qca8k_vlan_add(priv, port, vlan->vid, untagged);
+ 	if (ret)
+ 		dev_err(priv->dev, "Failed to add VLAN to port %d (%d)", port, ret);
+ 
+ 	if (pvid) {
+ 		int shift = 16 * (port % 2);
+ 
+ 		qca8k_rmw(priv, QCA8K_EGRESS_VLAN(port),
+ 			  0xfff << shift, vlan->vid << shift);
+ 		qca8k_write(priv, QCA8K_REG_PORT_VLAN_CTRL0(port),
+ 			    QCA8K_PORT_VLAN_CVID(vlan->vid) |
+ 			    QCA8K_PORT_VLAN_SVID(vlan->vid));
+ 	}
+ }
+ 
+ static int
+ qca8k_port_vlan_del(struct dsa_switch *ds, int port,
+ 		    const struct switchdev_obj_port_vlan *vlan)
+ {
+ 	struct qca8k_priv *priv = ds->priv;
+ 	int ret = 0;
+ 
+ 	ret = qca8k_vlan_del(priv, port, vlan->vid);
+ 	if (ret)
+ 		dev_err(priv->dev, "Failed to delete VLAN from port %d (%d)", port, ret);
+ 
+ 	return ret;
+ }
+ 
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  static enum dsa_tag_protocol
 -qca8k_get_tag_protocol(struct dsa_switch *ds, int port,
 -		       enum dsa_tag_protocol mp)
 +qca8k_get_tag_protocol(struct dsa_switch *ds, int port)
  {
  	return DSA_TAG_PROTO_QCA;
  }
diff --cc drivers/staging/fsl-dpaa2/ethsw/ethsw.c
index 1f9a4c8ef2da,62edb8d01f4e..000000000000
--- a/drivers/staging/fsl-dpaa2/ethsw/ethsw.c
+++ b/drivers/staging/fsl-dpaa2/ethsw/ethsw.c
@@@ -720,35 -974,49 +720,66 @@@ static int swdev_port_attr_set(struct n
  	return err;
  }
  
 -static int dpaa2_switch_port_vlans_add(struct net_device *netdev,
 -				       const struct switchdev_obj_port_vlan *vlan,
 -				       struct switchdev_trans *trans)
 +static int port_vlans_add(struct net_device *netdev,
 +			  const struct switchdev_obj_port_vlan *vlan,
 +			  struct switchdev_trans *trans)
  {
  	struct ethsw_port_priv *port_priv = netdev_priv(netdev);
++<<<<<<< HEAD
 +	int vid, err;
++=======
+ 	struct ethsw_core *ethsw = port_priv->ethsw_data;
+ 	struct dpsw_attr *attr = &ethsw->sw_attr;
+ 	int err = 0;
+ 
+ 	if (switchdev_trans_ph_prepare(trans)) {
+ 		/* Make sure that the VLAN is not already configured
+ 		 * on the switch port
+ 		 */
+ 		if (port_priv->vlans[vlan->vid] & ETHSW_VLAN_MEMBER)
+ 			return -EEXIST;
+ 
+ 		/* Check if there is space for a new VLAN */
+ 		err = dpsw_get_attributes(ethsw->mc_io, 0, ethsw->dpsw_handle,
+ 					  &ethsw->sw_attr);
+ 		if (err) {
+ 			netdev_err(netdev, "dpsw_get_attributes err %d\n", err);
+ 			return err;
+ 		}
+ 		if (attr->max_vlans - attr->num_vlans < 1)
+ 			return -ENOSPC;
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  
 +	if (switchdev_trans_ph_prepare(trans))
  		return 0;
 -	}
  
++<<<<<<< HEAD
 +	for (vid = vlan->vid_begin; vid <= vlan->vid_end; vid++) {
 +		if (!port_priv->ethsw_data->vlans[vid]) {
 +			/* this is a new VLAN */
 +			err = ethsw_add_vlan(port_priv->ethsw_data, vid);
 +			if (err)
 +				return err;
 +
 +			port_priv->ethsw_data->vlans[vid] |= ETHSW_VLAN_GLOBAL;
 +		}
 +		err = ethsw_port_add_vlan(port_priv, vid, vlan->flags);
++=======
+ 	if (!port_priv->ethsw_data->vlans[vlan->vid]) {
+ 		/* this is a new VLAN */
+ 		err = dpaa2_switch_add_vlan(port_priv->ethsw_data, vlan->vid);
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  		if (err)
- 			break;
+ 			return err;
+ 
+ 		port_priv->ethsw_data->vlans[vlan->vid] |= ETHSW_VLAN_GLOBAL;
  	}
  
- 	return err;
+ 	return dpaa2_switch_port_add_vlan(port_priv, vlan->vid, vlan->flags);
  }
  
 -static int dpaa2_switch_port_lookup_address(struct net_device *netdev, int is_uc,
 -					    const unsigned char *addr)
 +static int port_lookup_address(struct net_device *netdev, int is_uc,
 +			       const unsigned char *addr)
  {
  	struct netdev_hw_addr_list *list = (is_uc) ? &netdev->uc : &netdev->mc;
  	struct netdev_hw_addr *ha;
@@@ -873,26 -1141,19 +904,33 @@@ static int ethsw_port_del_vlan(struct e
  	return 0;
  }
  
 -static int dpaa2_switch_port_vlans_del(struct net_device *netdev,
 -				       const struct switchdev_obj_port_vlan *vlan)
 +static int port_vlans_del(struct net_device *netdev,
 +			  const struct switchdev_obj_port_vlan *vlan)
  {
  	struct ethsw_port_priv *port_priv = netdev_priv(netdev);
++<<<<<<< HEAD
 +	int vid, err;
++=======
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  
  	if (netif_is_bridge_master(vlan->obj.orig_dev))
  		return -EOPNOTSUPP;
  
++<<<<<<< HEAD
 +	for (vid = vlan->vid_begin; vid <= vlan->vid_end; vid++) {
 +		err = ethsw_port_del_vlan(port_priv, vid);
 +		if (err)
 +			break;
 +	}
 +
 +	return err;
++=======
+ 	return dpaa2_switch_port_del_vlan(port_priv, vlan->vid);
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  }
  
 -static int dpaa2_switch_port_mdb_del(struct net_device *netdev,
 -				     const struct switchdev_obj_port_mdb *mdb)
 +static int port_mdb_del(struct net_device *netdev,
 +			const struct switchdev_obj_port_mdb *mdb)
  {
  	struct ethsw_port_priv *port_priv = netdev_priv(netdev);
  	int err;
diff --cc net/dsa/slave.c
index 24cc4de02bd3,653d64f4a637..000000000000
--- a/net/dsa/slave.c
+++ b/net/dsa/slave.c
@@@ -300,9 -303,77 +300,79 @@@ static int dsa_slave_port_attr_set(stru
  	return ret;
  }
  
++<<<<<<< HEAD
++=======
+ /* Must be called under rcu_read_lock() */
+ static int
+ dsa_slave_vlan_check_for_8021q_uppers(struct net_device *slave,
+ 				      const struct switchdev_obj_port_vlan *vlan)
+ {
+ 	struct net_device *upper_dev;
+ 	struct list_head *iter;
+ 
+ 	netdev_for_each_upper_dev_rcu(slave, upper_dev, iter) {
+ 		u16 vid;
+ 
+ 		if (!is_vlan_dev(upper_dev))
+ 			continue;
+ 
+ 		vid = vlan_dev_vlan_id(upper_dev);
+ 		if (vid == vlan->vid)
+ 			return -EBUSY;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int dsa_slave_vlan_add(struct net_device *dev,
+ 			      const struct switchdev_obj *obj,
+ 			      struct switchdev_trans *trans)
+ {
+ 	struct net_device *master = dsa_slave_to_master(dev);
+ 	struct dsa_port *dp = dsa_slave_to_port(dev);
+ 	struct switchdev_obj_port_vlan vlan;
+ 	int err;
+ 
+ 	if (obj->orig_dev != dev)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (dsa_port_skip_vlan_configuration(dp))
+ 		return 0;
+ 
+ 	vlan = *SWITCHDEV_OBJ_PORT_VLAN(obj);
+ 
+ 	/* Deny adding a bridge VLAN when there is already an 802.1Q upper with
+ 	 * the same VID.
+ 	 */
+ 	if (trans->ph_prepare && br_vlan_enabled(dp->bridge_dev)) {
+ 		rcu_read_lock();
+ 		err = dsa_slave_vlan_check_for_8021q_uppers(dev, &vlan);
+ 		rcu_read_unlock();
+ 		if (err)
+ 			return err;
+ 	}
+ 
+ 	err = dsa_port_vlan_add(dp, &vlan, trans);
+ 	if (err)
+ 		return err;
+ 
+ 	/* We need the dedicated CPU port to be a member of the VLAN as well.
+ 	 * Even though drivers often handle CPU membership in special ways,
+ 	 * it doesn't make sense to program a PVID, so clear this flag.
+ 	 */
+ 	vlan.flags &= ~BRIDGE_VLAN_INFO_PVID;
+ 
+ 	err = dsa_port_vlan_add(dp->cpu_dp, &vlan, trans);
+ 	if (err)
+ 		return err;
+ 
+ 	return vlan_vid_add(master, htons(ETH_P_8021Q), vlan.vid);
+ }
+ 
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  static int dsa_slave_port_obj_add(struct net_device *dev,
  				  const struct switchdev_obj *obj,
 -				  struct switchdev_trans *trans,
 -				  struct netlink_ext_ack *extack)
 +				  struct switchdev_trans *trans)
  {
  	struct dsa_port *dp = dsa_slave_to_port(dev);
  	int err;
@@@ -335,6 -407,34 +405,37 @@@
  	return err;
  }
  
++<<<<<<< HEAD
++=======
+ static int dsa_slave_vlan_del(struct net_device *dev,
+ 			      const struct switchdev_obj *obj)
+ {
+ 	struct net_device *master = dsa_slave_to_master(dev);
+ 	struct dsa_port *dp = dsa_slave_to_port(dev);
+ 	struct switchdev_obj_port_vlan *vlan;
+ 	int err;
+ 
+ 	if (obj->orig_dev != dev)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (dsa_port_skip_vlan_configuration(dp))
+ 		return 0;
+ 
+ 	vlan = SWITCHDEV_OBJ_PORT_VLAN(obj);
+ 
+ 	/* Do not deprogram the CPU port as it may be shared with other user
+ 	 * ports which can be members of this VLAN as well.
+ 	 */
+ 	err = dsa_port_vlan_del(dp, vlan);
+ 	if (err)
+ 		return err;
+ 
+ 	vlan_vid_del(master, htons(ETH_P_8021Q), vlan->vid);
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  static int dsa_slave_port_obj_del(struct net_device *dev,
  				  const struct switchdev_obj *obj)
  {
@@@ -1003,6 -1275,271 +1104,274 @@@ static int dsa_slave_get_ts_info(struc
  	return ds->ops->get_ts_info(ds, p->dp->index, ts);
  }
  
++<<<<<<< HEAD
++=======
+ static int dsa_slave_vlan_rx_add_vid(struct net_device *dev, __be16 proto,
+ 				     u16 vid)
+ {
+ 	struct net_device *master = dsa_slave_to_master(dev);
+ 	struct dsa_port *dp = dsa_slave_to_port(dev);
+ 	struct switchdev_obj_port_vlan vlan = {
+ 		.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,
+ 		.vid = vid,
+ 		/* This API only allows programming tagged, non-PVID VIDs */
+ 		.flags = 0,
+ 	};
+ 	struct switchdev_trans trans;
+ 	int ret;
+ 
+ 	/* User port... */
+ 	trans.ph_prepare = true;
+ 	ret = dsa_port_vlan_add(dp, &vlan, &trans);
+ 	if (ret)
+ 		return ret;
+ 
+ 	trans.ph_prepare = false;
+ 	ret = dsa_port_vlan_add(dp, &vlan, &trans);
+ 	if (ret)
+ 		return ret;
+ 
+ 	/* And CPU port... */
+ 	trans.ph_prepare = true;
+ 	ret = dsa_port_vlan_add(dp->cpu_dp, &vlan, &trans);
+ 	if (ret)
+ 		return ret;
+ 
+ 	trans.ph_prepare = false;
+ 	ret = dsa_port_vlan_add(dp->cpu_dp, &vlan, &trans);
+ 	if (ret)
+ 		return ret;
+ 
+ 	return vlan_vid_add(master, proto, vid);
+ }
+ 
+ static int dsa_slave_vlan_rx_kill_vid(struct net_device *dev, __be16 proto,
+ 				      u16 vid)
+ {
+ 	struct net_device *master = dsa_slave_to_master(dev);
+ 	struct dsa_port *dp = dsa_slave_to_port(dev);
+ 	struct switchdev_obj_port_vlan vlan = {
+ 		.vid = vid,
+ 		/* This API only allows programming tagged, non-PVID VIDs */
+ 		.flags = 0,
+ 	};
+ 	int err;
+ 
+ 	/* Do not deprogram the CPU port as it may be shared with other user
+ 	 * ports which can be members of this VLAN as well.
+ 	 */
+ 	err = dsa_port_vlan_del(dp, &vlan);
+ 	if (err)
+ 		return err;
+ 
+ 	vlan_vid_del(master, proto, vid);
+ 
+ 	return 0;
+ }
+ 
+ struct dsa_hw_port {
+ 	struct list_head list;
+ 	struct net_device *dev;
+ 	int old_mtu;
+ };
+ 
+ static int dsa_hw_port_list_set_mtu(struct list_head *hw_port_list, int mtu)
+ {
+ 	const struct dsa_hw_port *p;
+ 	int err;
+ 
+ 	list_for_each_entry(p, hw_port_list, list) {
+ 		if (p->dev->mtu == mtu)
+ 			continue;
+ 
+ 		err = dev_set_mtu(p->dev, mtu);
+ 		if (err)
+ 			goto rollback;
+ 	}
+ 
+ 	return 0;
+ 
+ rollback:
+ 	list_for_each_entry_continue_reverse(p, hw_port_list, list) {
+ 		if (p->dev->mtu == p->old_mtu)
+ 			continue;
+ 
+ 		if (dev_set_mtu(p->dev, p->old_mtu))
+ 			netdev_err(p->dev, "Failed to restore MTU\n");
+ 	}
+ 
+ 	return err;
+ }
+ 
+ static void dsa_hw_port_list_free(struct list_head *hw_port_list)
+ {
+ 	struct dsa_hw_port *p, *n;
+ 
+ 	list_for_each_entry_safe(p, n, hw_port_list, list)
+ 		kfree(p);
+ }
+ 
+ /* Make the hardware datapath to/from @dev limited to a common MTU */
+ static void dsa_bridge_mtu_normalization(struct dsa_port *dp)
+ {
+ 	struct list_head hw_port_list;
+ 	struct dsa_switch_tree *dst;
+ 	int min_mtu = ETH_MAX_MTU;
+ 	struct dsa_port *other_dp;
+ 	int err;
+ 
+ 	if (!dp->ds->mtu_enforcement_ingress)
+ 		return;
+ 
+ 	if (!dp->bridge_dev)
+ 		return;
+ 
+ 	INIT_LIST_HEAD(&hw_port_list);
+ 
+ 	/* Populate the list of ports that are part of the same bridge
+ 	 * as the newly added/modified port
+ 	 */
+ 	list_for_each_entry(dst, &dsa_tree_list, list) {
+ 		list_for_each_entry(other_dp, &dst->ports, list) {
+ 			struct dsa_hw_port *hw_port;
+ 			struct net_device *slave;
+ 
+ 			if (other_dp->type != DSA_PORT_TYPE_USER)
+ 				continue;
+ 
+ 			if (other_dp->bridge_dev != dp->bridge_dev)
+ 				continue;
+ 
+ 			if (!other_dp->ds->mtu_enforcement_ingress)
+ 				continue;
+ 
+ 			slave = other_dp->slave;
+ 
+ 			if (min_mtu > slave->mtu)
+ 				min_mtu = slave->mtu;
+ 
+ 			hw_port = kzalloc(sizeof(*hw_port), GFP_KERNEL);
+ 			if (!hw_port)
+ 				goto out;
+ 
+ 			hw_port->dev = slave;
+ 			hw_port->old_mtu = slave->mtu;
+ 
+ 			list_add(&hw_port->list, &hw_port_list);
+ 		}
+ 	}
+ 
+ 	/* Attempt to configure the entire hardware bridge to the newly added
+ 	 * interface's MTU first, regardless of whether the intention of the
+ 	 * user was to raise or lower it.
+ 	 */
+ 	err = dsa_hw_port_list_set_mtu(&hw_port_list, dp->slave->mtu);
+ 	if (!err)
+ 		goto out;
+ 
+ 	/* Clearly that didn't work out so well, so just set the minimum MTU on
+ 	 * all hardware bridge ports now. If this fails too, then all ports will
+ 	 * still have their old MTU rolled back anyway.
+ 	 */
+ 	dsa_hw_port_list_set_mtu(&hw_port_list, min_mtu);
+ 
+ out:
+ 	dsa_hw_port_list_free(&hw_port_list);
+ }
+ 
+ static int dsa_slave_change_mtu(struct net_device *dev, int new_mtu)
+ {
+ 	struct net_device *master = dsa_slave_to_master(dev);
+ 	struct dsa_port *dp = dsa_slave_to_port(dev);
+ 	struct dsa_slave_priv *p = netdev_priv(dev);
+ 	struct dsa_switch *ds = p->dp->ds;
+ 	struct dsa_port *cpu_dp;
+ 	int port = p->dp->index;
+ 	int largest_mtu = 0;
+ 	int new_master_mtu;
+ 	int old_master_mtu;
+ 	int mtu_limit;
+ 	int cpu_mtu;
+ 	int err, i;
+ 
+ 	if (!ds->ops->port_change_mtu)
+ 		return -EOPNOTSUPP;
+ 
+ 	for (i = 0; i < ds->num_ports; i++) {
+ 		int slave_mtu;
+ 
+ 		if (!dsa_is_user_port(ds, i))
+ 			continue;
+ 
+ 		/* During probe, this function will be called for each slave
+ 		 * device, while not all of them have been allocated. That's
+ 		 * ok, it doesn't change what the maximum is, so ignore it.
+ 		 */
+ 		if (!dsa_to_port(ds, i)->slave)
+ 			continue;
+ 
+ 		/* Pretend that we already applied the setting, which we
+ 		 * actually haven't (still haven't done all integrity checks)
+ 		 */
+ 		if (i == port)
+ 			slave_mtu = new_mtu;
+ 		else
+ 			slave_mtu = dsa_to_port(ds, i)->slave->mtu;
+ 
+ 		if (largest_mtu < slave_mtu)
+ 			largest_mtu = slave_mtu;
+ 	}
+ 
+ 	cpu_dp = dsa_to_port(ds, port)->cpu_dp;
+ 
+ 	mtu_limit = min_t(int, master->max_mtu, dev->max_mtu);
+ 	old_master_mtu = master->mtu;
+ 	new_master_mtu = largest_mtu + cpu_dp->tag_ops->overhead;
+ 	if (new_master_mtu > mtu_limit)
+ 		return -ERANGE;
+ 
+ 	/* If the master MTU isn't over limit, there's no need to check the CPU
+ 	 * MTU, since that surely isn't either.
+ 	 */
+ 	cpu_mtu = largest_mtu;
+ 
+ 	/* Start applying stuff */
+ 	if (new_master_mtu != old_master_mtu) {
+ 		err = dev_set_mtu(master, new_master_mtu);
+ 		if (err < 0)
+ 			goto out_master_failed;
+ 
+ 		/* We only need to propagate the MTU of the CPU port to
+ 		 * upstream switches.
+ 		 */
+ 		err = dsa_port_mtu_change(cpu_dp, cpu_mtu, true);
+ 		if (err)
+ 			goto out_cpu_failed;
+ 	}
+ 
+ 	err = dsa_port_mtu_change(dp, new_mtu, false);
+ 	if (err)
+ 		goto out_port_failed;
+ 
+ 	dev->mtu = new_mtu;
+ 
+ 	dsa_bridge_mtu_normalization(dp);
+ 
+ 	return 0;
+ 
+ out_port_failed:
+ 	if (new_master_mtu != old_master_mtu)
+ 		dsa_port_mtu_change(cpu_dp, old_master_mtu -
+ 				    cpu_dp->tag_ops->overhead,
+ 				    true);
+ out_cpu_failed:
+ 	if (new_master_mtu != old_master_mtu)
+ 		dev_set_mtu(master, old_master_mtu);
+ out_master_failed:
+ 	return err;
+ }
+ 
++>>>>>>> b7a9e0da2d1c (net: switchdev: remove vid_begin -> vid_end range from VLAN objects)
  static const struct ethtool_ops dsa_slave_ethtool_ops = {
  	.get_drvinfo		= dsa_slave_get_drvinfo,
  	.get_regs_len		= dsa_slave_get_regs_len,
* Unmerged path drivers/net/dsa/hirschmann/hellcreek.c
* Unmerged path drivers/net/dsa/lantiq_gswip.c
* Unmerged path drivers/net/dsa/microchip/ksz8795.c
* Unmerged path drivers/net/dsa/microchip/ksz9477.c
* Unmerged path drivers/net/dsa/ocelot/felix.c
* Unmerged path drivers/net/dsa/rtl8366.c
* Unmerged path drivers/net/dsa/sja1105/sja1105_main.c
* Unmerged path drivers/net/ethernet/marvell/prestera/prestera_switchdev.c
* Unmerged path drivers/net/ethernet/mscc/ocelot_net.c
* Unmerged path drivers/net/ethernet/ti/cpsw_switchdev.c
* Unmerged path drivers/net/dsa/b53/b53_common.c
* Unmerged path drivers/net/dsa/bcm_sf2_cfp.c
* Unmerged path drivers/net/dsa/dsa_loop.c
* Unmerged path drivers/net/dsa/hirschmann/hellcreek.c
* Unmerged path drivers/net/dsa/lantiq_gswip.c
* Unmerged path drivers/net/dsa/microchip/ksz8795.c
* Unmerged path drivers/net/dsa/microchip/ksz9477.c
diff --git a/drivers/net/dsa/mt7530.c b/drivers/net/dsa/mt7530.c
index 74547f43b938..52a6e3f4599d 100644
--- a/drivers/net/dsa/mt7530.c
+++ b/drivers/net/dsa/mt7530.c
@@ -1130,7 +1130,6 @@ mt7530_port_vlan_add(struct dsa_switch *ds, int port,
 	bool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;
 	struct mt7530_hw_vlan_entry new_entry;
 	struct mt7530_priv *priv = ds->priv;
-	u16 vid;
 
 	/* The port is kept as VLAN-unaware if bridge with vlan_filtering not
 	 * being set.
@@ -1140,16 +1139,13 @@ mt7530_port_vlan_add(struct dsa_switch *ds, int port,
 
 	mutex_lock(&priv->reg_mutex);
 
-	for (vid = vlan->vid_begin; vid <= vlan->vid_end; ++vid) {
-		mt7530_hw_vlan_entry_init(&new_entry, port, untagged);
-		mt7530_hw_vlan_update(priv, vid, &new_entry,
-				      mt7530_hw_vlan_add);
-	}
+	mt7530_hw_vlan_entry_init(&new_entry, port, untagged);
+	mt7530_hw_vlan_update(priv, vlan->vid, &new_entry, mt7530_hw_vlan_add);
 
 	if (pvid) {
 		mt7530_rmw(priv, MT7530_PPBV1_P(port), G0_PORT_VID_MASK,
-			   G0_PORT_VID(vlan->vid_end));
-		priv->ports[port].pvid = vlan->vid_end;
+			   G0_PORT_VID(vlan->vid));
+		priv->ports[port].pvid = vlan->vid;
 	}
 
 	mutex_unlock(&priv->reg_mutex);
@@ -1161,7 +1157,7 @@ mt7530_port_vlan_del(struct dsa_switch *ds, int port,
 {
 	struct mt7530_hw_vlan_entry target_entry;
 	struct mt7530_priv *priv = ds->priv;
-	u16 vid, pvid;
+	u16 pvid;
 
 	/* The port is kept as VLAN-unaware if bridge with vlan_filtering not
 	 * being set.
@@ -1172,17 +1168,15 @@ mt7530_port_vlan_del(struct dsa_switch *ds, int port,
 	mutex_lock(&priv->reg_mutex);
 
 	pvid = priv->ports[port].pvid;
-	for (vid = vlan->vid_begin; vid <= vlan->vid_end; ++vid) {
-		mt7530_hw_vlan_entry_init(&target_entry, port, 0);
-		mt7530_hw_vlan_update(priv, vid, &target_entry,
-				      mt7530_hw_vlan_del);
+	mt7530_hw_vlan_entry_init(&target_entry, port, 0);
+	mt7530_hw_vlan_update(priv, vlan->vid, &target_entry,
+			      mt7530_hw_vlan_del);
 
-		/* PVID is being restored to the default whenever the PVID port
-		 * is being removed from the VLAN.
-		 */
-		if (pvid == vid)
-			pvid = G0_PORT_VID_DEF;
-	}
+	/* PVID is being restored to the default whenever the PVID port
+	 * is being removed from the VLAN.
+	 */
+	if (pvid == vlan->vid)
+		pvid = G0_PORT_VID_DEF;
 
 	mt7530_rmw(priv, MT7530_PPBV1_P(port), G0_PORT_VID_MASK, pvid);
 	priv->ports[port].pvid = pvid;
* Unmerged path drivers/net/dsa/mv88e6xxx/chip.c
* Unmerged path drivers/net/dsa/ocelot/felix.c
* Unmerged path drivers/net/dsa/qca8k.c
* Unmerged path drivers/net/dsa/rtl8366.c
* Unmerged path drivers/net/dsa/sja1105/sja1105_main.c
* Unmerged path drivers/net/ethernet/marvell/prestera/prestera_switchdev.c
diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
index 14ce372c3f85..3c5da529928d 100644
--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c
@@ -1215,23 +1215,20 @@ mlxsw_sp_br_ban_rif_pvid_change(struct mlxsw_sp *mlxsw_sp,
 				const struct switchdev_obj_port_vlan *vlan)
 {
 	u16 pvid;
-	u16 vid;
 
 	pvid = mlxsw_sp_rif_vid(mlxsw_sp, br_dev);
 	if (!pvid)
 		return 0;
 
-	for (vid = vlan->vid_begin; vid <= vlan->vid_end; ++vid) {
-		if (vlan->flags & BRIDGE_VLAN_INFO_PVID) {
-			if (vid != pvid) {
-				netdev_err(br_dev, "Can't change PVID, it's used by router interface\n");
-				return -EBUSY;
-			}
-		} else {
-			if (vid == pvid) {
-				netdev_err(br_dev, "Can't remove PVID, it's used by router interface\n");
-				return -EBUSY;
-			}
+	if (vlan->flags & BRIDGE_VLAN_INFO_PVID) {
+		if (vlan->vid != pvid) {
+			netdev_err(br_dev, "Can't change PVID, it's used by router interface\n");
+			return -EBUSY;
+		}
+	} else {
+		if (vlan->vid == pvid) {
+			netdev_err(br_dev, "Can't remove PVID, it's used by router interface\n");
+			return -EBUSY;
 		}
 	}
 
@@ -1248,7 +1245,6 @@ static int mlxsw_sp_port_vlans_add(struct mlxsw_sp_port *mlxsw_sp_port,
 	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
 	struct net_device *orig_dev = vlan->obj.orig_dev;
 	struct mlxsw_sp_bridge_port *bridge_port;
-	u16 vid;
 
 	if (netif_is_bridge_master(orig_dev)) {
 		int err = 0;
@@ -1273,17 +1269,9 @@ static int mlxsw_sp_port_vlans_add(struct mlxsw_sp_port *mlxsw_sp_port,
 	if (!bridge_port->bridge_device->vlan_enabled)
 		return 0;
 
-	for (vid = vlan->vid_begin; vid <= vlan->vid_end; vid++) {
-		int err;
-
-		err = mlxsw_sp_bridge_port_vlan_add(mlxsw_sp_port, bridge_port,
-						    vid, flag_untagged,
-						    flag_pvid, extack);
-		if (err)
-			return err;
-	}
-
-	return 0;
+	return mlxsw_sp_bridge_port_vlan_add(mlxsw_sp_port, bridge_port,
+					     vlan->vid, flag_untagged,
+					     flag_pvid, extack);
 }
 
 static enum mlxsw_reg_sfdf_flush_type mlxsw_sp_fdb_flush_type(bool lagged)
@@ -1877,7 +1865,6 @@ static int mlxsw_sp_port_vlans_del(struct mlxsw_sp_port *mlxsw_sp_port,
 	struct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;
 	struct net_device *orig_dev = vlan->obj.orig_dev;
 	struct mlxsw_sp_bridge_port *bridge_port;
-	u16 vid;
 
 	if (netif_is_bridge_master(orig_dev))
 		return -EOPNOTSUPP;
@@ -1889,8 +1876,7 @@ static int mlxsw_sp_port_vlans_del(struct mlxsw_sp_port *mlxsw_sp_port,
 	if (!bridge_port->bridge_device->vlan_enabled)
 		return 0;
 
-	for (vid = vlan->vid_begin; vid <= vlan->vid_end; vid++)
-		mlxsw_sp_bridge_port_vlan_del(mlxsw_sp_port, bridge_port, vid);
+	mlxsw_sp_bridge_port_vlan_del(mlxsw_sp_port, bridge_port, vlan->vid);
 
 	return 0;
 }
@@ -3463,7 +3449,6 @@ mlxsw_sp_switchdev_vxlan_vlans_add(struct net_device *vxlan_dev,
 	struct netlink_ext_ack *extack;
 	struct mlxsw_sp *mlxsw_sp;
 	struct net_device *br_dev;
-	u16 vid;
 
 	extack = switchdev_notifier_info_to_extack(&port_obj_info->info);
 	br_dev = netdev_master_upper_dev_get(vxlan_dev);
@@ -3486,18 +3471,10 @@ mlxsw_sp_switchdev_vxlan_vlans_add(struct net_device *vxlan_dev,
 	if (!bridge_device->vlan_enabled)
 		return 0;
 
-	for (vid = vlan->vid_begin; vid <= vlan->vid_end; vid++) {
-		int err;
-
-		err = mlxsw_sp_switchdev_vxlan_vlan_add(mlxsw_sp, bridge_device,
-							vxlan_dev, vid,
-							flag_untagged,
-							flag_pvid, extack);
-		if (err)
-			return err;
-	}
-
-	return 0;
+	return mlxsw_sp_switchdev_vxlan_vlan_add(mlxsw_sp, bridge_device,
+						 vxlan_dev, vlan->vid,
+						 flag_untagged,
+						 flag_pvid, extack);
 }
 
 static void
@@ -3510,7 +3487,6 @@ mlxsw_sp_switchdev_vxlan_vlans_del(struct net_device *vxlan_dev,
 	struct mlxsw_sp_bridge_device *bridge_device;
 	struct mlxsw_sp *mlxsw_sp;
 	struct net_device *br_dev;
-	u16 vid;
 
 	br_dev = netdev_master_upper_dev_get(vxlan_dev);
 	if (!br_dev)
@@ -3529,9 +3505,8 @@ mlxsw_sp_switchdev_vxlan_vlans_del(struct net_device *vxlan_dev,
 	if (!bridge_device->vlan_enabled)
 		return;
 
-	for (vid = vlan->vid_begin; vid <= vlan->vid_end; vid++)
-		mlxsw_sp_switchdev_vxlan_vlan_del(mlxsw_sp, bridge_device,
-						  vxlan_dev, vid);
+	mlxsw_sp_switchdev_vxlan_vlan_del(mlxsw_sp, bridge_device, vxlan_dev,
+					  vlan->vid);
 }
 
 static int
* Unmerged path drivers/net/ethernet/mscc/ocelot_net.c
diff --git a/drivers/net/ethernet/rocker/rocker_ofdpa.c b/drivers/net/ethernet/rocker/rocker_ofdpa.c
index fa296a7c255d..8595b08bc7da 100644
--- a/drivers/net/ethernet/rocker/rocker_ofdpa.c
+++ b/drivers/net/ethernet/rocker/rocker_ofdpa.c
@@ -2543,32 +2543,16 @@ static int ofdpa_port_obj_vlan_add(struct rocker_port *rocker_port,
 				   const struct switchdev_obj_port_vlan *vlan)
 {
 	struct ofdpa_port *ofdpa_port = rocker_port->wpriv;
-	u16 vid;
-	int err;
 
-	for (vid = vlan->vid_begin; vid <= vlan->vid_end; vid++) {
-		err = ofdpa_port_vlan_add(ofdpa_port, vid, vlan->flags);
-		if (err)
-			return err;
-	}
-
-	return 0;
+	return ofdpa_port_vlan_add(ofdpa_port, vlan->vid, vlan->flags);
 }
 
 static int ofdpa_port_obj_vlan_del(struct rocker_port *rocker_port,
 				   const struct switchdev_obj_port_vlan *vlan)
 {
 	struct ofdpa_port *ofdpa_port = rocker_port->wpriv;
-	u16 vid;
-	int err;
 
-	for (vid = vlan->vid_begin; vid <= vlan->vid_end; vid++) {
-		err = ofdpa_port_vlan_del(ofdpa_port, vid, vlan->flags);
-		if (err)
-			return err;
-	}
-
-	return 0;
+	return ofdpa_port_vlan_del(ofdpa_port, vlan->vid, vlan->flags);
 }
 
 static int ofdpa_port_obj_fdb_add(struct rocker_port *rocker_port,
* Unmerged path drivers/net/ethernet/ti/cpsw_switchdev.c
* Unmerged path drivers/staging/fsl-dpaa2/ethsw/ethsw.c
diff --git a/include/net/switchdev.h b/include/net/switchdev.h
index 4c14c5b37237..1a1b9b034c42 100644
--- a/include/net/switchdev.h
+++ b/include/net/switchdev.h
@@ -98,8 +98,7 @@ struct switchdev_obj {
 struct switchdev_obj_port_vlan {
 	struct switchdev_obj obj;
 	u16 flags;
-	u16 vid_begin;
-	u16 vid_end;
+	u16 vid;
 };
 
 #define SWITCHDEV_OBJ_PORT_VLAN(OBJ) \
diff --git a/net/bridge/br_switchdev.c b/net/bridge/br_switchdev.c
index 3439dba24831..4e73d317c016 100644
--- a/net/bridge/br_switchdev.c
+++ b/net/bridge/br_switchdev.c
@@ -135,8 +135,7 @@ int br_switchdev_port_vlan_add(struct net_device *dev, u16 vid, u16 flags,
 		.obj.orig_dev = dev,
 		.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,
 		.flags = flags,
-		.vid_begin = vid,
-		.vid_end = vid,
+		.vid = vid,
 	};
 
 	return switchdev_port_obj_add(dev, &v.obj, extack);
@@ -147,8 +146,7 @@ int br_switchdev_port_vlan_del(struct net_device *dev, u16 vid)
 	struct switchdev_obj_port_vlan v = {
 		.obj.orig_dev = dev,
 		.obj.id = SWITCHDEV_OBJ_ID_PORT_VLAN,
-		.vid_begin = vid,
-		.vid_end = vid,
+		.vid = vid,
 	};
 
 	return switchdev_port_obj_del(dev, &v.obj);
* Unmerged path net/dsa/slave.c
