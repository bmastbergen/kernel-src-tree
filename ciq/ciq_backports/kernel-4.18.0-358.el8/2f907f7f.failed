nvme: simplify block device ioctl handling for the !multipath case

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 2f907f7f96d96c518652410b90ad2edb50305a4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/2f907f7f.failed

Only use the existing ioctl handler for the multipath case, and add a
simpler one that reverts to the pre-multipath case for not shared
use case.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Reviewed-by: Keith Busch <kbusch@kernel.org>
	Reviewed-by: Javier Gonz√°lez <javier.gonz@samsung.com>
(cherry picked from commit 2f907f7f96d96c518652410b90ad2edb50305a4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/nvme/host/core.c
diff --cc drivers/nvme/host/core.c
index bf3ac9d14052,a89de83e12be..000000000000
--- a/drivers/nvme/host/core.c
+++ b/drivers/nvme/host/core.c
@@@ -1803,78 -1757,20 +1803,59 @@@ static bool is_ctrl_ioctl(unsigned int 
  	return false;
  }
  
- static int nvme_handle_ctrl_ioctl(struct nvme_ns *ns, unsigned int cmd,
- 				  void __user *argp,
- 				  struct nvme_ns_head *head,
- 				  int srcu_idx)
+ static int nvme_ctrl_ioctl(struct nvme_ctrl *ctrl, unsigned int cmd,
+ 		void __user *argp)
  {
- 	struct nvme_ctrl *ctrl = ns->ctrl;
- 	int ret;
- 
- 	nvme_get_ctrl(ns->ctrl);
- 	nvme_put_ns_from_disk(head, srcu_idx);
- 
  	switch (cmd) {
  	case NVME_IOCTL_ADMIN_CMD:
- 		ret = nvme_user_cmd(ctrl, NULL, argp);
- 		break;
+ 		return nvme_user_cmd(ctrl, NULL, argp);
  	case NVME_IOCTL_ADMIN64_CMD:
- 		ret = nvme_user_cmd64(ctrl, NULL, argp);
- 		break;
+ 		return nvme_user_cmd64(ctrl, NULL, argp);
  	default:
- 		ret = sed_ioctl(ctrl->opal_dev, cmd, argp);
- 		break;
+ 		return sed_ioctl(ctrl->opal_dev, cmd, argp);
  	}
- 	nvme_put_ctrl(ctrl);
- 	return ret;
  }
  
 -#ifdef COMPAT_FOR_U64_ALIGNMENT
 +static int nvme_ioctl(struct block_device *bdev, fmode_t mode,
 +		unsigned int cmd, unsigned long arg)
 +{
- 	struct nvme_ns_head *head = NULL;
++	struct nvme_ns *ns = bdev->bd_disk->private_data;
 +	void __user *argp = (void __user *)arg;
- 	struct nvme_ns *ns;
- 	int srcu_idx, ret;
 +
- 	ns = nvme_get_ns_from_disk(bdev->bd_disk, &head, &srcu_idx);
- 	if (unlikely(!ns))
- 		return -EWOULDBLOCK;
- 
- 	/*
- 	 * Handle ioctls that apply to the controller instead of the namespace
- 	 * seperately and drop the ns SRCU reference early.  This avoids a
- 	 * deadlock when deleting namespaces using the passthrough interface.
- 	 */
 +	if (is_ctrl_ioctl(cmd))
++<<<<<<< HEAD
 +		return nvme_handle_ctrl_ioctl(ns, cmd, argp, head, srcu_idx);
 +
 +	switch (cmd) {
 +	case NVME_IOCTL_ID:
 +		force_successful_syscall_return();
 +		ret = ns->head->ns_id;
 +		break;
 +	case NVME_IOCTL_IO_CMD:
 +		ret = nvme_user_cmd(ns->ctrl, ns, argp);
 +		break;
 +	case NVME_IOCTL_SUBMIT_IO:
 +		ret = nvme_submit_io(ns, argp);
 +		break;
 +	case NVME_IOCTL_IO64_CMD:
 +		ret = nvme_user_cmd64(ns->ctrl, ns, argp);
 +		break;
 +	default:
 +		if (ns->ndev)
 +			ret = nvme_nvm_ioctl(ns, cmd, argp);
 +		else
 +			ret = -ENOTTY;
 +	}
 +
 +	nvme_put_ns_from_disk(head, srcu_idx);
 +	return ret;
++=======
++		return nvme_ctrl_ioctl(ns->ctrl, cmd, argp);
++	return nvme_ns_ioctl(ns, cmd, argp);
++>>>>>>> 2f907f7f96d9 (nvme: simplify block device ioctl handling for the !multipath case)
 +}
 +
 +#ifdef CONFIG_COMPAT
  struct nvme_user_io32 {
  	__u8	opcode;
  	__u8	flags;
@@@ -2449,12 -2336,50 +2430,54 @@@ static void nvme_ns_head_release(struc
  	nvme_put_ns_head(disk->private_data);
  }
  
+ static int nvme_ns_head_ctrl_ioctl(struct nvme_ns *ns, unsigned int cmd,
+ 		void __user *argp, struct nvme_ns_head *head, int srcu_idx)
+ {
+ 	struct nvme_ctrl *ctrl = ns->ctrl;
+ 	int ret;
+ 
+ 	nvme_get_ctrl(ns->ctrl);
+ 	nvme_put_ns_from_disk(head, srcu_idx);
+ 	ret = nvme_ctrl_ioctl(ns->ctrl, cmd, argp);
+ 	nvme_put_ctrl(ctrl);
+ 	return ret;
+ }
+ 
+ static int nvme_ns_head_ioctl(struct block_device *bdev, fmode_t mode,
+ 		unsigned int cmd, unsigned long arg)
+ {
+ 	struct nvme_ns_head *head = NULL;
+ 	void __user *argp = (void __user *)arg;
+ 	struct nvme_ns *ns;
+ 	int srcu_idx, ret;
+ 
+ 	ns = nvme_get_ns_from_disk(bdev->bd_disk, &head, &srcu_idx);
+ 	if (unlikely(!ns))
+ 		return -EWOULDBLOCK;
+ 
+ 	/*
+ 	 * Handle ioctls that apply to the controller instead of the namespace
+ 	 * seperately and drop the ns SRCU reference early.  This avoids a
+ 	 * deadlock when deleting namespaces using the passthrough interface.
+ 	 */
+ 	if (is_ctrl_ioctl(cmd))
+ 		return nvme_ns_head_ctrl_ioctl(ns, cmd, argp, head, srcu_idx);
+ 
+ 	ret = nvme_ns_ioctl(ns, cmd, argp);
+ 	nvme_put_ns_from_disk(head, srcu_idx);
+ 	return ret;
+ }
+ 
  const struct block_device_operations nvme_ns_head_ops = {
  	.owner		= THIS_MODULE,
 -	.submit_bio	= nvme_ns_head_submit_bio,
  	.open		= nvme_ns_head_open,
  	.release	= nvme_ns_head_release,
++<<<<<<< HEAD
 +	.ioctl		= nvme_ioctl,
 +	.compat_ioctl	= nvme_compat_ioctl,
++=======
+ 	.ioctl		= nvme_ns_head_ioctl,
++>>>>>>> 2f907f7f96d9 (nvme: simplify block device ioctl handling for the !multipath case)
  	.getgeo		= nvme_getgeo,
  	.report_zones	= nvme_report_zones,
  	.pr_ops		= &nvme_pr_ops,
* Unmerged path drivers/nvme/host/core.c
