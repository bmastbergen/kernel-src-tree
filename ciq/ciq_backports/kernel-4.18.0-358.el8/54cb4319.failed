net: bridge: multicast: fix igmp/mld port context null pointer dereferences

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 54cb43199e14c1181ddcd4a3782f1f7eb56bdab8
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/54cb4319.failed

With the recent change to use bridge/port multicast context pointers
instead of bridge/port I missed to convert two locations which pass the
port pointer as-is, but with the new model we need to verify the port
context is non-NULL first and retrieve the port from it. The first
location is when doing querier selection when a query is received, the
second location is when leaving a group. The port context will be null
if the packets originated from the bridge device (i.e. from the host).
The fix is simple just check if the port context exists and retrieve
the port pointer from it.

Fixes: adc47037a7d5 ("net: bridge: multicast: use multicast contexts instead of bridge or port")
	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 54cb43199e14c1181ddcd4a3782f1f7eb56bdab8)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
diff --cc net/bridge/br_multicast.c
index def6f1840985,214d1bf854ad..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -2070,18 -2826,20 +2070,29 @@@ unlock_continue
  }
  #endif
  
++<<<<<<< HEAD
 +static bool br_ip4_multicast_select_querier(struct net_bridge *br,
 +					    struct net_bridge_port *port,
 +					    __be32 saddr)
 +{
 +	if (!timer_pending(&br->ip4_own_query.timer) &&
 +	    !timer_pending(&br->ip4_other_query.timer))
++=======
+ static bool br_ip4_multicast_select_querier(struct net_bridge_mcast *brmctx,
+ 					    struct net_bridge_mcast_port *pmctx,
+ 					    __be32 saddr)
+ {
+ 	struct net_bridge_port *port = pmctx ? pmctx->port : NULL;
+ 
+ 	if (!timer_pending(&brmctx->ip4_own_query.timer) &&
+ 	    !timer_pending(&brmctx->ip4_other_query.timer))
++>>>>>>> 54cb43199e14 (net: bridge: multicast: fix igmp/mld port context null pointer dereferences)
  		goto update;
  
 -	if (!brmctx->ip4_querier.addr.src.ip4)
 +	if (!br->ip4_querier.addr.src.ip4)
  		goto update;
  
 -	if (ntohl(saddr) <= ntohl(brmctx->ip4_querier.addr.src.ip4))
 +	if (ntohl(saddr) <= ntohl(br->ip4_querier.addr.src.ip4))
  		goto update;
  
  	return false;
@@@ -2096,15 -2854,17 +2107,26 @@@ update
  }
  
  #if IS_ENABLED(CONFIG_IPV6)
++<<<<<<< HEAD
 +static bool br_ip6_multicast_select_querier(struct net_bridge *br,
 +					    struct net_bridge_port *port,
 +					    struct in6_addr *saddr)
 +{
 +	if (!timer_pending(&br->ip6_own_query.timer) &&
 +	    !timer_pending(&br->ip6_other_query.timer))
++=======
+ static bool br_ip6_multicast_select_querier(struct net_bridge_mcast *brmctx,
+ 					    struct net_bridge_mcast_port *pmctx,
+ 					    struct in6_addr *saddr)
+ {
+ 	struct net_bridge_port *port = pmctx ? pmctx->port : NULL;
+ 
+ 	if (!timer_pending(&brmctx->ip6_own_query.timer) &&
+ 	    !timer_pending(&brmctx->ip6_other_query.timer))
++>>>>>>> 54cb43199e14 (net: bridge: multicast: fix igmp/mld port context null pointer dereferences)
  		goto update;
  
 -	if (ipv6_addr_cmp(saddr, &brmctx->ip6_querier.addr.src.ip6) <= 0)
 +	if (ipv6_addr_cmp(saddr, &br->ip6_querier.addr.src.ip6) <= 0)
  		goto update;
  
  	return false;
@@@ -2203,11 -3080,11 +2225,15 @@@ br_ip4_multicast_query_received(struct 
  				struct br_ip *saddr,
  				unsigned long max_delay)
  {
++<<<<<<< HEAD
 +	if (!br_ip4_multicast_select_querier(br, port, saddr->src.ip4))
++=======
+ 	if (!br_ip4_multicast_select_querier(brmctx, pmctx, saddr->src.ip4))
++>>>>>>> 54cb43199e14 (net: bridge: multicast: fix igmp/mld port context null pointer dereferences)
  		return;
  
 -	br_multicast_update_query_timer(brmctx, query, max_delay);
 -	br_ip4_multicast_mark_router(brmctx, pmctx);
 +	br_multicast_update_query_timer(br, query, max_delay);
 +	br_multicast_mark_router(br, port);
  }
  
  #if IS_ENABLED(CONFIG_IPV6)
@@@ -2218,11 -3095,11 +2244,15 @@@ br_ip6_multicast_query_received(struct 
  				struct br_ip *saddr,
  				unsigned long max_delay)
  {
++<<<<<<< HEAD
 +	if (!br_ip6_multicast_select_querier(br, port, &saddr->src.ip6))
++=======
+ 	if (!br_ip6_multicast_select_querier(brmctx, pmctx, &saddr->src.ip6))
++>>>>>>> 54cb43199e14 (net: bridge: multicast: fix igmp/mld port context null pointer dereferences)
  		return;
  
 -	br_multicast_update_query_timer(brmctx, query, max_delay);
 -	br_ip6_multicast_mark_router(brmctx, pmctx);
 +	br_multicast_update_query_timer(br, query, max_delay);
 +	br_multicast_mark_router(br, port);
  }
  #endif
  
@@@ -2448,10 -3325,10 +2478,17 @@@ br_multicast_leave_group(struct net_bri
  
  		mod_timer(&own_query->timer, time);
  
++<<<<<<< HEAD
 +		for (p = mlock_dereference(mp->ports, br);
 +		     p != NULL;
 +		     p = mlock_dereference(p->next, br)) {
 +			if (!br_port_group_equal(p, port, src))
++=======
+ 		for (p = mlock_dereference(mp->ports, brmctx->br);
+ 		     p != NULL && pmctx != NULL;
+ 		     p = mlock_dereference(p->next, brmctx->br)) {
+ 			if (!br_port_group_equal(p, pmctx->port, src))
++>>>>>>> 54cb43199e14 (net: bridge: multicast: fix igmp/mld port context null pointer dereferences)
  				continue;
  
  			if (!hlist_unhashed(&p->mglist) &&
* Unmerged path net/bridge/br_multicast.c
