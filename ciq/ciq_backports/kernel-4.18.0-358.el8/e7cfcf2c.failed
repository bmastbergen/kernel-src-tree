net: bridge: multicast: calculate idx position without changing ptr

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit e7cfcf2c18c5fd96320a69e468fdec8ed1c55443
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/e7cfcf2c.failed

We need to preserve the srcs pointer since we'll be passing it for EHT
handling later.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit e7cfcf2c18c5fd96320a69e468fdec8ed1c55443)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
diff --cc net/bridge/br_multicast.c
index 6cf87c6c3626,f8b685ae56d4..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -1403,9 -1810,9 +1403,13 @@@ static bool br_multicast_isinc_allow(st
  	u32 src_idx;
  
  	memset(&src_ip, 0, sizeof(src_ip));
 -	src_ip.proto = pg->key.addr.proto;
 +	src_ip.proto = pg->addr.proto;
  	for (src_idx = 0; src_idx < nsrcs; src_idx++) {
++<<<<<<< HEAD
 +		memcpy(&src_ip.src, srcs, src_size);
++=======
+ 		memcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  		ent = br_multicast_find_group_src(pg, &src_ip);
  		if (!ent) {
  			ent = br_multicast_new_group_src(pg, &src_ip);
@@@ -1414,8 -1821,7 +1418,12 @@@
  		}
  
  		if (ent)
++<<<<<<< HEAD
 +			mod_timer(&ent->timer, now + br_multicast_gmi(br));
 +		srcs += src_size;
++=======
+ 			__grp_src_mod_timer(ent, now + br_multicast_gmi(br));
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  	}
  
  	return changed;
@@@ -1437,15 -1843,16 +1445,25 @@@ static void __grp_src_isexc_incl(struc
  		ent->flags |= BR_SGRP_F_DELETE;
  
  	memset(&src_ip, 0, sizeof(src_ip));
 -	src_ip.proto = pg->key.addr.proto;
 +	src_ip.proto = pg->addr.proto;
  	for (src_idx = 0; src_idx < nsrcs; src_idx++) {
++<<<<<<< HEAD
 +		memcpy(&src_ip.src, srcs, src_size);
++=======
+ 		memcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  		ent = br_multicast_find_group_src(pg, &src_ip);
  		if (ent)
  			ent->flags &= ~BR_SGRP_F_DELETE;
  		else
++<<<<<<< HEAD
 +			br_multicast_new_group_src(pg, &src_ip);
 +		srcs += src_size;
++=======
+ 			ent = br_multicast_new_group_src(pg, &src_ip);
+ 		if (ent)
+ 			br_multicast_fwd_src_handle(ent);
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  	}
  
  	__grp_src_delete_marked(pg);
@@@ -1471,9 -1878,9 +1489,13 @@@ static bool __grp_src_isexc_excl(struc
  		ent->flags |= BR_SGRP_F_DELETE;
  
  	memset(&src_ip, 0, sizeof(src_ip));
 -	src_ip.proto = pg->key.addr.proto;
 +	src_ip.proto = pg->addr.proto;
  	for (src_idx = 0; src_idx < nsrcs; src_idx++) {
++<<<<<<< HEAD
 +		memcpy(&src_ip.src, srcs, src_size);
++=======
+ 		memcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  		ent = br_multicast_find_group_src(pg, &src_ip);
  		if (ent) {
  			ent->flags &= ~BR_SGRP_F_DELETE;
@@@ -1485,7 -1892,6 +1507,10 @@@
  				changed = true;
  			}
  		}
++<<<<<<< HEAD
 +		srcs += src_size;
++=======
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  	}
  
  	if (__grp_src_delete_marked(pg))
@@@ -1534,9 -1941,9 +1559,13 @@@ static bool __grp_src_toin_incl(struct 
  		ent->flags |= BR_SGRP_F_SEND;
  
  	memset(&src_ip, 0, sizeof(src_ip));
 -	src_ip.proto = pg->key.addr.proto;
 +	src_ip.proto = pg->addr.proto;
  	for (src_idx = 0; src_idx < nsrcs; src_idx++) {
++<<<<<<< HEAD
 +		memcpy(&src_ip.src, srcs, src_size);
++=======
+ 		memcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  		ent = br_multicast_find_group_src(pg, &src_ip);
  		if (ent) {
  			ent->flags &= ~BR_SGRP_F_SEND;
@@@ -1547,8 -1954,7 +1576,12 @@@
  				changed = true;
  		}
  		if (ent)
++<<<<<<< HEAD
 +			mod_timer(&ent->timer, now + br_multicast_gmi(br));
 +		srcs += src_size;
++=======
+ 			__grp_src_mod_timer(ent, now + br_multicast_gmi(br));
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  	}
  
  	if (to_send)
@@@ -1577,9 -1983,9 +1610,13 @@@ static bool __grp_src_toin_excl(struct 
  			ent->flags |= BR_SGRP_F_SEND;
  
  	memset(&src_ip, 0, sizeof(src_ip));
 -	src_ip.proto = pg->key.addr.proto;
 +	src_ip.proto = pg->addr.proto;
  	for (src_idx = 0; src_idx < nsrcs; src_idx++) {
++<<<<<<< HEAD
 +		memcpy(&src_ip.src, srcs, src_size);
++=======
+ 		memcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  		ent = br_multicast_find_group_src(pg, &src_ip);
  		if (ent) {
  			if (timer_pending(&ent->timer)) {
@@@ -1592,8 -1998,7 +1629,12 @@@
  				changed = true;
  		}
  		if (ent)
++<<<<<<< HEAD
 +			mod_timer(&ent->timer, now + br_multicast_gmi(br));
 +		srcs += src_size;
++=======
+ 			__grp_src_mod_timer(ent, now + br_multicast_gmi(br));
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  	}
  
  	if (to_send)
@@@ -1638,18 -2043,19 +1679,27 @@@ static void __grp_src_toex_incl(struct 
  		ent->flags = (ent->flags & ~BR_SGRP_F_SEND) | BR_SGRP_F_DELETE;
  
  	memset(&src_ip, 0, sizeof(src_ip));
 -	src_ip.proto = pg->key.addr.proto;
 +	src_ip.proto = pg->addr.proto;
  	for (src_idx = 0; src_idx < nsrcs; src_idx++) {
++<<<<<<< HEAD
 +		memcpy(&src_ip.src, srcs, src_size);
++=======
+ 		memcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  		ent = br_multicast_find_group_src(pg, &src_ip);
  		if (ent) {
  			ent->flags = (ent->flags & ~BR_SGRP_F_DELETE) |
  				     BR_SGRP_F_SEND;
  			to_send++;
  		} else {
 -			ent = br_multicast_new_group_src(pg, &src_ip);
 +			br_multicast_new_group_src(pg, &src_ip);
  		}
++<<<<<<< HEAD
 +		srcs += src_size;
++=======
+ 		if (ent)
+ 			br_multicast_fwd_src_handle(ent);
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  	}
  
  	__grp_src_delete_marked(pg);
@@@ -1676,9 -2082,9 +1726,13 @@@ static bool __grp_src_toex_excl(struct 
  		ent->flags = (ent->flags & ~BR_SGRP_F_SEND) | BR_SGRP_F_DELETE;
  
  	memset(&src_ip, 0, sizeof(src_ip));
 -	src_ip.proto = pg->key.addr.proto;
 +	src_ip.proto = pg->addr.proto;
  	for (src_idx = 0; src_idx < nsrcs; src_idx++) {
++<<<<<<< HEAD
 +		memcpy(&src_ip.src, srcs, src_size);
++=======
+ 		memcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  		ent = br_multicast_find_group_src(pg, &src_ip);
  		if (ent) {
  			ent->flags &= ~BR_SGRP_F_DELETE;
@@@ -1693,7 -2099,6 +1747,10 @@@
  			ent->flags |= BR_SGRP_F_SEND;
  			to_send++;
  		}
++<<<<<<< HEAD
 +		srcs += src_size;
++=======
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  	}
  
  	if (__grp_src_delete_marked(pg))
@@@ -1740,15 -2147,14 +1797,22 @@@ static void __grp_src_block_incl(struc
  		ent->flags &= ~BR_SGRP_F_SEND;
  
  	memset(&src_ip, 0, sizeof(src_ip));
 -	src_ip.proto = pg->key.addr.proto;
 +	src_ip.proto = pg->addr.proto;
  	for (src_idx = 0; src_idx < nsrcs; src_idx++) {
++<<<<<<< HEAD
 +		memcpy(&src_ip.src, srcs, src_size);
++=======
+ 		memcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  		ent = br_multicast_find_group_src(pg, &src_ip);
  		if (ent) {
  			ent->flags |= BR_SGRP_F_SEND;
  			to_send++;
  		}
++<<<<<<< HEAD
 +		srcs += src_size;
++=======
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  	}
  
  	if (to_send)
@@@ -1774,9 -2187,9 +1838,13 @@@ static bool __grp_src_block_excl(struc
  		ent->flags &= ~BR_SGRP_F_SEND;
  
  	memset(&src_ip, 0, sizeof(src_ip));
 -	src_ip.proto = pg->key.addr.proto;
 +	src_ip.proto = pg->addr.proto;
  	for (src_idx = 0; src_idx < nsrcs; src_idx++) {
++<<<<<<< HEAD
 +		memcpy(&src_ip.src, srcs, src_size);
++=======
+ 		memcpy(&src_ip.src, srcs + (src_idx * addr_size), addr_size);
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  		ent = br_multicast_find_group_src(pg, &src_ip);
  		if (!ent) {
  			ent = br_multicast_new_group_src(pg, &src_ip);
@@@ -1789,7 -2202,6 +1857,10 @@@
  			ent->flags |= BR_SGRP_F_SEND;
  			to_send++;
  		}
++<<<<<<< HEAD
 +		srcs += src_size;
++=======
++>>>>>>> e7cfcf2c18c5 (net: bridge: multicast: calculate idx position without changing ptr)
  	}
  
  	if (to_send)
* Unmerged path net/bridge/br_multicast.c
