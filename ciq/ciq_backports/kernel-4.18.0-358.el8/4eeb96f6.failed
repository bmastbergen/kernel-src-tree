iommu/fsl_pamu: replace DOMAIN_ATTR_FSL_PAMU_STASH with a direct call

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 4eeb96f6efac10e66fd10e718d2adeece3879121
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/4eeb96f6.failed

Add a fsl_pamu_configure_l1_stash API that qman_portal can call directly
instead of indirecting through the iommu attr API.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Will Deacon <will@kernel.org>
	Acked-by: Li Yang <leoyang.li@nxp.com>
Link: https://lore.kernel.org/r/20210401155256.298656-8-hch@lst.de
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 4eeb96f6efac10e66fd10e718d2adeece3879121)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/fsl_pamu_domain.c
#	drivers/soc/fsl/qbman/qman_portal.c
#	include/linux/iommu.h
diff --cc drivers/iommu/fsl_pamu_domain.c
index a377b877dcab,557a152c1d2c..000000000000
--- a/drivers/iommu/fsl_pamu_domain.c
+++ b/drivers/iommu/fsl_pamu_domain.c
@@@ -677,45 -371,10 +677,45 @@@ static void fsl_pamu_detach_device(stru
  		pr_debug("missing fsl,liodn property at %pOF\n", dev->of_node);
  }
  
 +static  int configure_domain_geometry(struct iommu_domain *domain, void *data)
 +{
 +	struct iommu_domain_geometry *geom_attr = data;
 +	struct fsl_dma_domain *dma_domain = to_fsl_dma_domain(domain);
 +	dma_addr_t geom_size;
 +	unsigned long flags;
 +
 +	geom_size = geom_attr->aperture_end - geom_attr->aperture_start + 1;
 +	/*
 +	 * Sanity check the geometry size. Also, we do not support
 +	 * DMA outside of the geometry.
 +	 */
 +	if (check_size(geom_size, geom_attr->aperture_start) ||
 +	    !geom_attr->force_aperture) {
 +		pr_debug("Invalid PAMU geometry attributes\n");
 +		return -EINVAL;
 +	}
 +
 +	spin_lock_irqsave(&dma_domain->domain_lock, flags);
 +	if (dma_domain->enabled) {
 +		pr_debug("Can't set geometry attributes as domain is active\n");
 +		spin_unlock_irqrestore(&dma_domain->domain_lock, flags);
 +		return  -EBUSY;
 +	}
 +
 +	/* Copy the domain geometry information */
 +	memcpy(&domain->geometry, geom_attr,
 +	       sizeof(struct iommu_domain_geometry));
 +	dma_domain->geom_size = geom_size;
 +
 +	spin_unlock_irqrestore(&dma_domain->domain_lock, flags);
 +
 +	return 0;
 +}
 +
  /* Set the domain stash attribute */
- static int configure_domain_stash(struct fsl_dma_domain *dma_domain, void *data)
+ int fsl_pamu_configure_l1_stash(struct iommu_domain *domain, u32 cpu)
  {
- 	struct pamu_stash_attribute *stash_attr = data;
+ 	struct fsl_dma_domain *dma_domain = to_fsl_dma_domain(domain);
  	unsigned long flags;
  	int ret;
  
@@@ -823,12 -419,6 +816,15 @@@ static int fsl_pamu_set_domain_attr(str
  	int ret = 0;
  
  	switch (attr_type) {
++<<<<<<< HEAD
 +	case DOMAIN_ATTR_GEOMETRY:
 +		ret = configure_domain_geometry(domain, data);
 +		break;
 +	case DOMAIN_ATTR_FSL_PAMU_STASH:
 +		ret = configure_domain_stash(dma_domain, data);
 +		break;
++=======
++>>>>>>> 4eeb96f6efac (iommu/fsl_pamu: replace DOMAIN_ATTR_FSL_PAMU_STASH with a direct call)
  	case DOMAIN_ATTR_FSL_PAMU_ENABLE:
  		ret = configure_domain_dma_state(dma_domain, *(int *)data);
  		break;
diff --cc drivers/soc/fsl/qbman/qman_portal.c
index a120002b630e,798b3a1ffd0b..000000000000
--- a/drivers/soc/fsl/qbman/qman_portal.c
+++ b/drivers/soc/fsl/qbman/qman_portal.c
@@@ -46,8 -47,6 +46,11 @@@ static void portal_set_cpu(struct qm_po
  #ifdef CONFIG_FSL_PAMU
  	struct device *dev = pcfg->dev;
  	int window_count = 1;
++<<<<<<< HEAD
 +	struct iommu_domain_geometry geom_attr;
 +	struct pamu_stash_attribute stash_attr;
++=======
++>>>>>>> 4eeb96f6efac (iommu/fsl_pamu: replace DOMAIN_ATTR_FSL_PAMU_STASH with a direct call)
  	int ret;
  
  	pcfg->iommu_domain = iommu_domain_alloc(&platform_bus_type);
@@@ -55,31 -54,9 +58,35 @@@
  		dev_err(dev, "%s(): iommu_domain_alloc() failed", __func__);
  		goto no_iommu;
  	}
++<<<<<<< HEAD
 +	geom_attr.aperture_start = 0;
 +	geom_attr.aperture_end =
 +		((dma_addr_t)1 << min(8 * sizeof(dma_addr_t), (size_t)36)) - 1;
 +	geom_attr.force_aperture = true;
 +	ret = iommu_domain_set_attr(pcfg->iommu_domain, DOMAIN_ATTR_GEOMETRY,
 +				    &geom_attr);
 +	if (ret < 0) {
 +		dev_err(dev, "%s(): iommu_domain_set_attr() = %d", __func__,
 +			ret);
 +		goto out_domain_free;
 +	}
 +	ret = iommu_domain_set_attr(pcfg->iommu_domain, DOMAIN_ATTR_WINDOWS,
 +				    &window_count);
 +	if (ret < 0) {
 +		dev_err(dev, "%s(): iommu_domain_set_attr() = %d", __func__,
 +			ret);
 +		goto out_domain_free;
 +	}
 +	stash_attr.cpu = cpu;
 +	stash_attr.cache = PAMU_ATTR_CACHE_L1;
 +	ret = iommu_domain_set_attr(pcfg->iommu_domain,
 +				    DOMAIN_ATTR_FSL_PAMU_STASH,
 +				    &stash_attr);
++=======
+ 	ret = fsl_pamu_configure_l1_stash(pcfg->iommu_domain, cpu);
++>>>>>>> 4eeb96f6efac (iommu/fsl_pamu: replace DOMAIN_ATTR_FSL_PAMU_STASH with a direct call)
  	if (ret < 0) {
- 		dev_err(dev, "%s(): iommu_domain_set_attr() = %d",
+ 		dev_err(dev, "%s(): fsl_pamu_configure_l1_stash() = %d",
  			__func__, ret);
  		goto out_domain_free;
  	}
diff --cc include/linux/iommu.h
index 1d738c608f7d,a3968122aa69..000000000000
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@@ -125,15 -109,10 +125,18 @@@ enum iommu_cap 
  enum iommu_attr {
  	DOMAIN_ATTR_GEOMETRY,
  	DOMAIN_ATTR_PAGING,
++<<<<<<< HEAD
 +	DOMAIN_ATTR_WINDOWS,
 +	DOMAIN_ATTR_FSL_PAMU_STASH,
++=======
++>>>>>>> 4eeb96f6efac (iommu/fsl_pamu: replace DOMAIN_ATTR_FSL_PAMU_STASH with a direct call)
  	DOMAIN_ATTR_FSL_PAMU_ENABLE,
 +	DOMAIN_ATTR_FSL_PAMUV1,
  	DOMAIN_ATTR_NESTING,	/* two stages of translation */
  	DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE,
 +#ifndef __GENKSYMS__
  	DOMAIN_ATTR_IO_PGTABLE_CFG,
 +#endif
  	DOMAIN_ATTR_MAX,
  };
  
diff --git a/arch/powerpc/include/asm/fsl_pamu_stash.h b/arch/powerpc/include/asm/fsl_pamu_stash.h
index 38311c98eed9..c896e94955ab 100644
--- a/arch/powerpc/include/asm/fsl_pamu_stash.h
+++ b/arch/powerpc/include/asm/fsl_pamu_stash.h
@@ -19,6 +19,8 @@
 #ifndef __FSL_PAMU_STASH_H
 #define __FSL_PAMU_STASH_H
 
+struct iommu_domain;
+
 /* cache stash targets */
 enum pamu_stash_target {
 	PAMU_ATTR_CACHE_L1 = 1,
@@ -26,14 +28,6 @@ enum pamu_stash_target {
 	PAMU_ATTR_CACHE_L3,
 };
 
-/*
- * This attribute allows configuring stashig specific parameters
- * in the PAMU hardware.
- */
-
-struct pamu_stash_attribute {
-	u32	cpu;	/* cpu number */
-	u32	cache;	/* cache to stash to: L1,L2,L3 */
-};
+int fsl_pamu_configure_l1_stash(struct iommu_domain *domain, u32 cpu);
 
 #endif  /* __FSL_PAMU_STASH_H */
* Unmerged path drivers/iommu/fsl_pamu_domain.c
diff --git a/drivers/iommu/fsl_pamu_domain.h b/drivers/iommu/fsl_pamu_domain.h
index f2b0f741d3de..1085cfd27e78 100644
--- a/drivers/iommu/fsl_pamu_domain.h
+++ b/drivers/iommu/fsl_pamu_domain.h
@@ -67,9 +67,7 @@ struct fsl_dma_domain {
 	 */
 	int				mapped;
 	int				enabled;
-	/* stash_id obtained from the stash attribute details */
 	u32				stash_id;
-	struct pamu_stash_attribute	dma_stash;
 	u32				snoop_id;
 	struct iommu_domain		iommu_domain;
 	spinlock_t			domain_lock;
* Unmerged path drivers/soc/fsl/qbman/qman_portal.c
* Unmerged path include/linux/iommu.h
