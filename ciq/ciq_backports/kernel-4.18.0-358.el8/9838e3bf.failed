x86/fpu: Make 'no387' and 'nofxsr' command line options useful

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Sebastian Andrzej Siewior <bigeasy@linutronix.de>
commit 9838e3bff0f92f23fcd50fe1ff1d4b3e91b8a448
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/9838e3bf.failed

The command line option `no387' is designed to disable the FPU
entirely. This only 'works' with CONFIG_MATH_EMULATION enabled.

But on 64bit this cannot work because user space expects SSE to work which
required basic FPU support. MATH_EMULATION does not help because SSE is not
emulated.

The command line option `nofxsr' should also be limited to 32bit because
FXSR is part of the required flags on 64bit so turning it off is not
possible.

Clearing X86_FEATURE_FPU without emulation enabled will not work anyway and
hang in fpu__init_system_early_generic() before the console is enabled.

Setting additioal dependencies, ensures that the CPU still boots on a
modern CPU. Otherwise, dropping FPU will leave FXSR enabled causing the
kernel to crash early in fpu__init_system_mxcsr().

With XSAVE support it will crash in fpu__init_cpu_xstate(). The problem is
that xsetbv() with XMM set and SSE cleared is not allowed.  That means
XSAVE has to be disabled. The XSAVE support is disabled in
fpu__init_system_xstate_size_legacy() but it is too late. It can be
removed, it has been added in commit

  1f999ab5a1360 ("x86, xsave: Disable xsave in i387 emulation mode")

to use `no387' on a CPU with XSAVE support.

All this happens before console output.

After hat, the next possible crash is in RAID6 detect code because MMX
remained enabled. With a 3DNOW enabled config it will explode in memcpy()
for instance due to kernel_fpu_begin() but this is unconditionally enabled.

This is enough to boot a Debian Wheezy on a 32bit qemu "host" CPU which
supports everything up to XSAVES, AVX2 without 3DNOW. Later, Debian
increased the minimum requirements to i686 which means it does not boot
userland atleast due to CMOV.

After masking the additional features it still keeps SSE4A and 3DNOW*
enabled (if present on the host) but those are unused in the kernel.

Restrict `no387' and `nofxsr' otions to 32bit only. Add dependencies for
FPU, FXSR to additionaly mask CMOV, MMX, XSAVE if FXSR or FPU is cleared.

	Reported-by: Vegard Nossum <vegard.nossum@oracle.com>
	Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Link: https://lkml.kernel.org/r/20190703083247.57kjrmlxkai3vpw3@linutronix.de

(cherry picked from commit 9838e3bff0f92f23fcd50fe1ff1d4b3e91b8a448)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/x86/kernel/cpu/cpuid-deps.c
diff --cc arch/x86/kernel/cpu/cpuid-deps.c
index 3535c60cac12,e794e3860fc8..000000000000
--- a/arch/x86/kernel/cpu/cpuid-deps.c
+++ b/arch/x86/kernel/cpu/cpuid-deps.c
@@@ -20,56 -20,50 +20,103 @@@ struct cpuid_dep 
   * but it's difficult to tell that to the init reference checker.
   */
  static const struct cpuid_dep cpuid_deps[] = {
++<<<<<<< HEAD
 +	{ X86_FEATURE_XSAVEOPT,			X86_FEATURE_XSAVE     },
 +	{ X86_FEATURE_XSAVEC,			X86_FEATURE_XSAVE     },
 +	{ X86_FEATURE_XSAVES,			X86_FEATURE_XSAVE     },
 +	{ X86_FEATURE_AVX,			X86_FEATURE_XSAVE     },
 +	{ X86_FEATURE_PKU,			X86_FEATURE_XSAVE     },
 +	{ X86_FEATURE_MPX,			X86_FEATURE_XSAVE     },
 +	{ X86_FEATURE_XGETBV1,			X86_FEATURE_XSAVE     },
 +	{ X86_FEATURE_FXSR_OPT,			X86_FEATURE_FXSR      },
 +	{ X86_FEATURE_XMM,			X86_FEATURE_FXSR      },
 +	{ X86_FEATURE_XMM2,			X86_FEATURE_XMM       },
 +	{ X86_FEATURE_XMM3,			X86_FEATURE_XMM2      },
 +	{ X86_FEATURE_XMM4_1,			X86_FEATURE_XMM2      },
 +	{ X86_FEATURE_XMM4_2,			X86_FEATURE_XMM2      },
 +	{ X86_FEATURE_XMM3,			X86_FEATURE_XMM2      },
 +	{ X86_FEATURE_PCLMULQDQ,		X86_FEATURE_XMM2      },
 +	{ X86_FEATURE_SSSE3,			X86_FEATURE_XMM2,     },
 +	{ X86_FEATURE_F16C,			X86_FEATURE_XMM2,     },
 +	{ X86_FEATURE_AES,			X86_FEATURE_XMM2      },
 +	{ X86_FEATURE_SHA_NI,			X86_FEATURE_XMM2      },
 +	{ X86_FEATURE_FMA,			X86_FEATURE_AVX       },
 +	{ X86_FEATURE_AVX2,			X86_FEATURE_AVX,      },
 +	{ X86_FEATURE_AVX512F,			X86_FEATURE_AVX,      },
 +	{ X86_FEATURE_AVX512IFMA,		X86_FEATURE_AVX512F   },
 +	{ X86_FEATURE_AVX512PF,			X86_FEATURE_AVX512F   },
 +	{ X86_FEATURE_AVX512ER,			X86_FEATURE_AVX512F   },
 +	{ X86_FEATURE_AVX512CD,			X86_FEATURE_AVX512F   },
 +	{ X86_FEATURE_AVX512DQ,			X86_FEATURE_AVX512F   },
 +	{ X86_FEATURE_AVX512BW,			X86_FEATURE_AVX512F   },
 +	{ X86_FEATURE_AVX512VL,			X86_FEATURE_AVX512F   },
 +	{ X86_FEATURE_AVX512VBMI,		X86_FEATURE_AVX512F   },
 +	{ X86_FEATURE_AVX512_VBMI2,		X86_FEATURE_AVX512VL  },
 +	{ X86_FEATURE_GFNI,			X86_FEATURE_AVX512VL  },
 +	{ X86_FEATURE_VAES,			X86_FEATURE_AVX512VL  },
 +	{ X86_FEATURE_VPCLMULQDQ,		X86_FEATURE_AVX512VL  },
 +	{ X86_FEATURE_AVX512_VNNI,		X86_FEATURE_AVX512VL  },
 +	{ X86_FEATURE_AVX512_BITALG,		X86_FEATURE_AVX512VL  },
 +	{ X86_FEATURE_AVX512_4VNNIW,		X86_FEATURE_AVX512F   },
 +	{ X86_FEATURE_AVX512_4FMAPS,		X86_FEATURE_AVX512F   },
 +	{ X86_FEATURE_AVX512_VPOPCNTDQ,		X86_FEATURE_AVX512F   },
 +	{ X86_FEATURE_AVX512_VP2INTERSECT,	X86_FEATURE_AVX512VL  },
 +	{ X86_FEATURE_CQM_OCCUP_LLC,		X86_FEATURE_CQM_LLC   },
 +	{ X86_FEATURE_CQM_MBM_TOTAL,		X86_FEATURE_CQM_LLC   },
 +	{ X86_FEATURE_CQM_MBM_LOCAL,		X86_FEATURE_CQM_LLC   },
 +	{ X86_FEATURE_AVX512_BF16,		X86_FEATURE_AVX512VL  },
 +	{ X86_FEATURE_AVX512_FP16,		X86_FEATURE_AVX512BW  },
 +	{ X86_FEATURE_ENQCMD,			X86_FEATURE_XSAVES    },
 +	{ X86_FEATURE_PER_THREAD_MBA,		X86_FEATURE_MBA       },
 +	{ X86_FEATURE_SGX_LC,			X86_FEATURE_SGX	      },
 +	{ X86_FEATURE_SGX1,			X86_FEATURE_SGX       },
 +	{ X86_FEATURE_SGX2,			X86_FEATURE_SGX1      },
++=======
+ 	{ X86_FEATURE_FXSR,		X86_FEATURE_FPU	      },
+ 	{ X86_FEATURE_XSAVEOPT,		X86_FEATURE_XSAVE     },
+ 	{ X86_FEATURE_XSAVEC,		X86_FEATURE_XSAVE     },
+ 	{ X86_FEATURE_XSAVES,		X86_FEATURE_XSAVE     },
+ 	{ X86_FEATURE_AVX,		X86_FEATURE_XSAVE     },
+ 	{ X86_FEATURE_PKU,		X86_FEATURE_XSAVE     },
+ 	{ X86_FEATURE_MPX,		X86_FEATURE_XSAVE     },
+ 	{ X86_FEATURE_XGETBV1,		X86_FEATURE_XSAVE     },
+ 	{ X86_FEATURE_CMOV,		X86_FEATURE_FXSR      },
+ 	{ X86_FEATURE_MMX,		X86_FEATURE_FXSR      },
+ 	{ X86_FEATURE_MMXEXT,		X86_FEATURE_MMX       },
+ 	{ X86_FEATURE_FXSR_OPT,		X86_FEATURE_FXSR      },
+ 	{ X86_FEATURE_XSAVE,		X86_FEATURE_FXSR      },
+ 	{ X86_FEATURE_XMM,		X86_FEATURE_FXSR      },
+ 	{ X86_FEATURE_XMM2,		X86_FEATURE_XMM       },
+ 	{ X86_FEATURE_XMM3,		X86_FEATURE_XMM2      },
+ 	{ X86_FEATURE_XMM4_1,		X86_FEATURE_XMM2      },
+ 	{ X86_FEATURE_XMM4_2,		X86_FEATURE_XMM2      },
+ 	{ X86_FEATURE_XMM3,		X86_FEATURE_XMM2      },
+ 	{ X86_FEATURE_PCLMULQDQ,	X86_FEATURE_XMM2      },
+ 	{ X86_FEATURE_SSSE3,		X86_FEATURE_XMM2,     },
+ 	{ X86_FEATURE_F16C,		X86_FEATURE_XMM2,     },
+ 	{ X86_FEATURE_AES,		X86_FEATURE_XMM2      },
+ 	{ X86_FEATURE_SHA_NI,		X86_FEATURE_XMM2      },
+ 	{ X86_FEATURE_FMA,		X86_FEATURE_AVX       },
+ 	{ X86_FEATURE_AVX2,		X86_FEATURE_AVX,      },
+ 	{ X86_FEATURE_AVX512F,		X86_FEATURE_AVX,      },
+ 	{ X86_FEATURE_AVX512IFMA,	X86_FEATURE_AVX512F   },
+ 	{ X86_FEATURE_AVX512PF,		X86_FEATURE_AVX512F   },
+ 	{ X86_FEATURE_AVX512ER,		X86_FEATURE_AVX512F   },
+ 	{ X86_FEATURE_AVX512CD,		X86_FEATURE_AVX512F   },
+ 	{ X86_FEATURE_AVX512DQ,		X86_FEATURE_AVX512F   },
+ 	{ X86_FEATURE_AVX512BW,		X86_FEATURE_AVX512F   },
+ 	{ X86_FEATURE_AVX512VL,		X86_FEATURE_AVX512F   },
+ 	{ X86_FEATURE_AVX512VBMI,	X86_FEATURE_AVX512F   },
+ 	{ X86_FEATURE_AVX512_VBMI2,	X86_FEATURE_AVX512VL  },
+ 	{ X86_FEATURE_GFNI,		X86_FEATURE_AVX512VL  },
+ 	{ X86_FEATURE_VAES,		X86_FEATURE_AVX512VL  },
+ 	{ X86_FEATURE_VPCLMULQDQ,	X86_FEATURE_AVX512VL  },
+ 	{ X86_FEATURE_AVX512_VNNI,	X86_FEATURE_AVX512VL  },
+ 	{ X86_FEATURE_AVX512_BITALG,	X86_FEATURE_AVX512VL  },
+ 	{ X86_FEATURE_AVX512_4VNNIW,	X86_FEATURE_AVX512F   },
+ 	{ X86_FEATURE_AVX512_4FMAPS,	X86_FEATURE_AVX512F   },
+ 	{ X86_FEATURE_AVX512_VPOPCNTDQ, X86_FEATURE_AVX512F   },
++>>>>>>> 9838e3bff0f9 (x86/fpu: Make 'no387' and 'nofxsr' command line options useful)
  	{}
  };
  
* Unmerged path arch/x86/kernel/cpu/cpuid-deps.c
diff --git a/arch/x86/kernel/fpu/init.c b/arch/x86/kernel/fpu/init.c
index de2aa22fe81e..9d84c342154d 100644
--- a/arch/x86/kernel/fpu/init.c
+++ b/arch/x86/kernel/fpu/init.c
@@ -203,12 +203,6 @@ static void __init fpu__init_system_xstate_size_legacy(void)
 	 */
 
 	if (!boot_cpu_has(X86_FEATURE_FPU)) {
-		/*
-		 * Disable xsave as we do not support it if i387
-		 * emulation is enabled.
-		 */
-		setup_clear_cpu_cap(X86_FEATURE_XSAVE);
-		setup_clear_cpu_cap(X86_FEATURE_XSAVEOPT);
 		fpu_kernel_xstate_size = sizeof(struct swregs_state);
 	} else {
 		if (boot_cpu_has(X86_FEATURE_FXSR))
@@ -252,14 +246,17 @@ static void __init fpu__init_parse_early_param(void)
 	char *argptr = arg;
 	int bit;
 
+#ifdef CONFIG_X86_32
 	if (cmdline_find_option_bool(boot_command_line, "no387"))
+#ifdef CONFIG_MATH_EMULATION
 		setup_clear_cpu_cap(X86_FEATURE_FPU);
+#else
+		pr_err("Option 'no387' required CONFIG_MATH_EMULATION enabled.\n");
+#endif
 
-	if (cmdline_find_option_bool(boot_command_line, "nofxsr")) {
+	if (cmdline_find_option_bool(boot_command_line, "nofxsr"))
 		setup_clear_cpu_cap(X86_FEATURE_FXSR);
-		setup_clear_cpu_cap(X86_FEATURE_FXSR_OPT);
-		setup_clear_cpu_cap(X86_FEATURE_XMM);
-	}
+#endif
 
 	if (cmdline_find_option_bool(boot_command_line, "noxsave"))
 		fpu__xstate_clear_all_cpu_caps();
