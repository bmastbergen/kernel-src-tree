mm, slub: check new pages with restored irqs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Vlastimil Babka <vbabka@suse.cz>
commit 9f101ee89465e0b2c11b477f5b55e03039b2c308
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/9f101ee8.failed

Building on top of the previous patch, re-enable irqs before checking new
pages. alloc_debug_processing() is now called with enabled irqs so we need to
remove VM_BUG_ON(!irqs_disabled()); in check_slab() - there doesn't seem to be
a need for it anyway.

	Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
(cherry picked from commit 9f101ee89465e0b2c11b477f5b55e03039b2c308)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/slub.c
diff --cc mm/slub.c
index 18ea2f53cb90,b5788040d92e..000000000000
--- a/mm/slub.c
+++ b/mm/slub.c
@@@ -2690,23 -2789,30 +2688,39 @@@ new_slab
  		goto redo;
  	}
  
 -	local_irq_save(flags);
 -	if (unlikely(c->page)) {
 -		local_irq_restore(flags);
 -		goto reread_page;
 +	freelist = get_partial(s, gfpflags, node, &page);
 +	if (freelist) {
 +		c->page = page;
 +		goto check_new_page;
  	}
  
++<<<<<<< HEAD
++=======
+ new_objects:
+ 
+ 	lockdep_assert_irqs_disabled();
+ 
+ 	freelist = get_partial(s, gfpflags, node, &page);
+ 	local_irq_restore(flags);
+ 	if (freelist)
+ 		goto check_new_page;
+ 
+ 	put_cpu_ptr(s->cpu_slab);
++>>>>>>> 9f101ee89465 (mm, slub: check new pages with restored irqs)
  	page = new_slab(s, gfpflags, node);
 -	c = get_cpu_ptr(s->cpu_slab);
  
  	if (unlikely(!page)) {
  		slab_out_of_memory(s, gfpflags, node);
  		return NULL;
  	}
  
++<<<<<<< HEAD
 +	c = raw_cpu_ptr(s->cpu_slab);
 +	if (c->page)
 +		flush_slab(s, c);
 +
++=======
++>>>>>>> 9f101ee89465 (mm, slub: check new pages with restored irqs)
  	/*
  	 * No other reference to the page yet so we can
  	 * muck around with it freely without cmpxchg
@@@ -2738,11 -2844,22 +2752,27 @@@ check_new_page
  		 */
  		goto return_single;
  
++<<<<<<< HEAD
++=======
+ 	local_irq_save(flags);
+ 	if (unlikely(c->page))
+ 		flush_slab(s, c);
+ 	c->page = page;
+ 
++>>>>>>> 9f101ee89465 (mm, slub: check new pages with restored irqs)
  	goto load_freelist;
  
  return_single:
  
++<<<<<<< HEAD
++=======
+ 	local_irq_save(flags);
+ 	if (unlikely(c->page))
+ 		flush_slab(s, c);
+ 	c->page = page;
+ 
++>>>>>>> 9f101ee89465 (mm, slub: check new pages with restored irqs)
  	deactivate_slab(s, page, get_freepointer(s, freelist), c);
 -	local_irq_restore(flags);
  	return freelist;
  }
  
* Unmerged path mm/slub.c
