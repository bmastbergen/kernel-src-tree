firmware: psci: Export functions to manage the OSI mode

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Ulf Hansson <ulf.hansson@linaro.org>
commit 49fdcd7577efe9efe863cdbb154f32a96970c1bc
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/49fdcd75.failed

To allow subsequent changes to implement support for OSI mode through the
cpuidle-psci driver, export the existing psci_has_osi_support(). Export
also a new function, psci_set_osi_mode(), that allows its caller to enable
the OS-initiated CPU-suspend mode in the PSCI FW.

To deal with backwards compatibility for a kernel started through a kexec
call, default to set the CPU-suspend mode to the Platform Coordinated mode
during boot.

	Signed-off-by: Ulf Hansson <ulf.hansson@linaro.org>
	Reviewed-by: Sudeep Holla <sudeep.holla@arm.com>
(cherry picked from commit 49fdcd7577efe9efe863cdbb154f32a96970c1bc)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/psci.h
diff --cc include/linux/psci.h
index affcd2128df8,a67712b73b6c..000000000000
--- a/include/linux/psci.h
+++ b/include/linux/psci.h
@@@ -23,8 -16,10 +23,15 @@@
  
  bool psci_tos_resident_on(int cpu);
  
++<<<<<<< HEAD
 +int psci_cpu_init_idle(unsigned int cpu);
 +int psci_cpu_suspend_enter(unsigned long index);
++=======
+ int psci_cpu_suspend_enter(u32 state);
+ bool psci_power_state_is_valid(u32 state);
+ int psci_set_osi_mode(void);
+ bool psci_has_osi_support(void);
++>>>>>>> 49fdcd7577ef (firmware: psci: Export functions to manage the OSI mode)
  
  enum smccc_version {
  	SMCCC_VERSION_1_0,
diff --git a/drivers/firmware/psci/psci.c b/drivers/firmware/psci/psci.c
index 563e8bd2ace8..c35ad9ef37b9 100644
--- a/drivers/firmware/psci/psci.c
+++ b/drivers/firmware/psci/psci.c
@@ -104,7 +104,7 @@ static inline bool psci_has_ext_power_state(void)
 				PSCI_1_0_FEATURES_CPU_SUSPEND_PF_MASK;
 }
 
-static inline bool psci_has_osi_support(void)
+bool psci_has_osi_support(void)
 {
 	return psci_cpu_suspend_feature & PSCI_1_0_OS_INITIATED;
 }
@@ -169,6 +169,15 @@ static u32 psci_get_version(void)
 	return invoke_psci_fn(PSCI_0_2_FN_PSCI_VERSION, 0, 0, 0);
 }
 
+int psci_set_osi_mode(void)
+{
+	int err;
+
+	err = invoke_psci_fn(PSCI_1_0_FN_SET_SUSPEND_MODE,
+			     PSCI_1_0_SUSPEND_MODE_OSI, 0, 0);
+	return psci_to_linux_errno(err);
+}
+
 static int psci_cpu_suspend(u32 state, unsigned long entry_point)
 {
 	int err;
@@ -702,9 +711,14 @@ static int __init psci_1_0_init(struct device_node *np)
 	if (err)
 		return err;
 
-	if (psci_has_osi_support())
+	if (psci_has_osi_support()) {
 		pr_info("OSI mode supported.\n");
 
+		/* Default to PC mode. */
+		invoke_psci_fn(PSCI_1_0_FN_SET_SUSPEND_MODE,
+			       PSCI_1_0_SUSPEND_MODE_PC, 0, 0);
+	}
+
 	return 0;
 }
 
* Unmerged path include/linux/psci.h
