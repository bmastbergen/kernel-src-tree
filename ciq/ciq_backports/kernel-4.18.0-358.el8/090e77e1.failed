kmap: consolidate kmap_prot definitions

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Ira Weiny <ira.weiny@intel.com>
commit 090e77e166334b83f555de408df64b9ab394ea08
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/090e77e1.failed

Most architectures define kmap_prot to be PAGE_KERNEL.

Let sparc and xtensa define there own and define PAGE_KERNEL as the
default if not overridden.

[akpm@linux-foundation.org: coding style fixes]
	Suggested-by: Christoph Hellwig <hch@infradead.org>
	Signed-off-by: Ira Weiny <ira.weiny@intel.com>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Cc: Al Viro <viro@zeniv.linux.org.uk>
	Cc: Andy Lutomirski <luto@kernel.org>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Borislav Petkov <bp@alien8.de>
	Cc: Christian KÃ¶nig <christian.koenig@amd.com>
	Cc: Chris Zankel <chris@zankel.net>
	Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: Dave Hansen <dave.hansen@linux.intel.com>
	Cc: "David S. Miller" <davem@davemloft.net>
	Cc: Helge Deller <deller@gmx.de>
	Cc: "H. Peter Anvin" <hpa@zytor.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: "James E.J. Bottomley" <James.Bottomley@HansenPartnership.com>
	Cc: Max Filippov <jcmvbkbc@gmail.com>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
	Cc: Thomas Gleixner <tglx@linutronix.de>
Link: http://lkml.kernel.org/r/20200507150004.1423069-16-ira.weiny@intel.com
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 090e77e166334b83f555de408df64b9ab394ea08)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/csky/include/asm/highmem.h
#	arch/sparc/mm/highmem.c
#	include/linux/highmem.h
diff --cc arch/sparc/mm/highmem.c
index 86bc2a58d26c,6ff6e2a9f9b3..000000000000
--- a/arch/sparc/mm/highmem.c
+++ b/arch/sparc/mm/highmem.c
@@@ -32,8 -32,6 +32,11 @@@
  #include <asm/pgalloc.h>
  #include <asm/vaddrs.h>
  
++<<<<<<< HEAD
 +pgprot_t kmap_prot;
 +
++=======
++>>>>>>> 090e77e16633 (kmap: consolidate kmap_prot definitions)
  static pte_t *kmap_pte;
  
  void __init kmap_init(void)
@@@ -46,10 -48,9 +49,9 @@@
  
          /* cache the first kmap pte */
          kmap_pte = pte_offset_kernel(dir, address);
-         kmap_prot = __pgprot(SRMMU_ET_PTE | SRMMU_PRIV | SRMMU_CACHE);
  }
  
 -void *kmap_atomic_high_prot(struct page *page, pgprot_t prot)
 +void *kmap_atomic(struct page *page)
  {
  	unsigned long vaddr;
  	long idx, type;
diff --cc include/linux/highmem.h
index ea5cdbd8c2c3,d6e82e3de027..000000000000
--- a/include/linux/highmem.h
+++ b/include/linux/highmem.h
@@@ -32,8 -32,65 +32,66 @@@ static inline void invalidate_kernel_vm
  #include <asm/kmap_types.h>
  
  #ifdef CONFIG_HIGHMEM
 -extern void *kmap_atomic_high_prot(struct page *page, pgprot_t prot);
 -extern void kunmap_atomic_high(void *kvaddr);
  #include <asm/highmem.h>
  
++<<<<<<< HEAD
++=======
+ #ifndef ARCH_HAS_KMAP_FLUSH_TLB
+ static inline void kmap_flush_tlb(unsigned long addr) { }
+ #endif
+ 
+ #ifndef kmap_prot
+ #define kmap_prot PAGE_KERNEL
+ #endif
+ 
+ void *kmap_high(struct page *page);
+ static inline void *kmap(struct page *page)
+ {
+ 	void *addr;
+ 
+ 	might_sleep();
+ 	if (!PageHighMem(page))
+ 		addr = page_address(page);
+ 	else
+ 		addr = kmap_high(page);
+ 	kmap_flush_tlb((unsigned long)addr);
+ 	return addr;
+ }
+ 
+ void kunmap_high(struct page *page);
+ 
+ static inline void kunmap(struct page *page)
+ {
+ 	might_sleep();
+ 	if (!PageHighMem(page))
+ 		return;
+ 	kunmap_high(page);
+ }
+ 
+ /*
+  * kmap_atomic/kunmap_atomic is significantly faster than kmap/kunmap because
+  * no global lock is needed and because the kmap code must perform a global TLB
+  * invalidation when the kmap pool wraps.
+  *
+  * However when holding an atomic kmap is is not legal to sleep, so atomic
+  * kmaps are appropriate for short, tight code paths only.
+  *
+  * The use of kmap_atomic/kunmap_atomic is discouraged - kmap/kunmap
+  * gives a more generic (and caching) interface. But kmap_atomic can
+  * be used in IRQ contexts, so in some (very limited) cases we need
+  * it.
+  */
+ static inline void *kmap_atomic_prot(struct page *page, pgprot_t prot)
+ {
+ 	preempt_disable();
+ 	pagefault_disable();
+ 	if (!PageHighMem(page))
+ 		return page_address(page);
+ 	return kmap_atomic_high_prot(page, prot);
+ }
+ #define kmap_atomic(page)	kmap_atomic_prot(page, kmap_prot)
+ 
++>>>>>>> 090e77e16633 (kmap: consolidate kmap_prot definitions)
  /* declarations for linux/mm/highmem.c */
  unsigned int nr_free_highpages(void);
  extern atomic_long_t _totalhigh_pages;
* Unmerged path arch/csky/include/asm/highmem.h
diff --git a/arch/arc/include/asm/highmem.h b/arch/arc/include/asm/highmem.h
index b1585c96324a..a19072ee9a95 100644
--- a/arch/arc/include/asm/highmem.h
+++ b/arch/arc/include/asm/highmem.h
@@ -29,9 +29,6 @@
 #define PKMAP_ADDR(nr)		(PKMAP_BASE + ((nr) << PAGE_SHIFT))
 #define PKMAP_NR(virt)		(((virt) - PKMAP_BASE) >> PAGE_SHIFT)
 
-#define kmap_prot		PAGE_KERNEL
-
-
 #include <asm/cacheflush.h>
 
 extern void *kmap(struct page *page);
diff --git a/arch/arm/include/asm/highmem.h b/arch/arm/include/asm/highmem.h
index eb4e4207cd3c..3c3614875147 100644
--- a/arch/arm/include/asm/highmem.h
+++ b/arch/arm/include/asm/highmem.h
@@ -10,8 +10,6 @@
 #define PKMAP_NR(virt)		(((virt) - PKMAP_BASE) >> PAGE_SHIFT)
 #define PKMAP_ADDR(nr)		(PKMAP_BASE + ((nr) << PAGE_SHIFT))
 
-#define kmap_prot		PAGE_KERNEL
-
 #define flush_cache_kmaps() \
 	do { \
 		if (cache_is_vivt()) \
* Unmerged path arch/csky/include/asm/highmem.h
diff --git a/arch/mips/include/asm/highmem.h b/arch/mips/include/asm/highmem.h
index 9d84aafc33d0..640f6c156577 100644
--- a/arch/mips/include/asm/highmem.h
+++ b/arch/mips/include/asm/highmem.h
@@ -59,8 +59,6 @@ extern void *kmap_atomic_pfn(unsigned long pfn);
 
 extern void kmap_init(void);
 
-#define kmap_prot PAGE_KERNEL
-
 #endif /* __KERNEL__ */
 
 #endif /* _ASM_HIGHMEM_H */
diff --git a/arch/nds32/include/asm/highmem.h b/arch/nds32/include/asm/highmem.h
index 425d546cb059..08e31827049f 100644
--- a/arch/nds32/include/asm/highmem.h
+++ b/arch/nds32/include/asm/highmem.h
@@ -32,7 +32,6 @@
 #define LAST_PKMAP_MASK		(LAST_PKMAP - 1)
 #define PKMAP_NR(virt)		(((virt) - (PKMAP_BASE)) >> PAGE_SHIFT)
 #define PKMAP_ADDR(nr)		(PKMAP_BASE + ((nr) << PAGE_SHIFT))
-#define kmap_prot		PAGE_KERNEL
 
 static inline void flush_cache_kmaps(void)
 {
diff --git a/arch/sparc/include/asm/highmem.h b/arch/sparc/include/asm/highmem.h
index 18d776925c45..7d658c32b690 100644
--- a/arch/sparc/include/asm/highmem.h
+++ b/arch/sparc/include/asm/highmem.h
@@ -25,11 +25,12 @@
 #include <asm/vaddrs.h>
 #include <asm/kmap_types.h>
 #include <asm/pgtable.h>
+#include <asm/pgtsrmmu.h>
 
 /* declarations for highmem.c */
 extern unsigned long highstart_pfn, highend_pfn;
 
-extern pgprot_t kmap_prot;
+#define kmap_prot __pgprot(SRMMU_ET_PTE | SRMMU_PRIV | SRMMU_CACHE)
 extern pte_t *pkmap_page_table;
 
 void kmap_init(void) __init;
* Unmerged path arch/sparc/mm/highmem.c
diff --git a/arch/x86/include/asm/fixmap.h b/arch/x86/include/asm/fixmap.h
index 3ea818f86acf..90ded6b08ef4 100644
--- a/arch/x86/include/asm/fixmap.h
+++ b/arch/x86/include/asm/fixmap.h
@@ -157,7 +157,6 @@ extern void reserve_top_address(unsigned long reserve);
 extern int fixmaps_set;
 
 extern pte_t *kmap_pte;
-#define kmap_prot PAGE_KERNEL
 extern pte_t *pkmap_page_table;
 
 void __native_set_fixmap(enum fixed_addresses idx, pte_t pte);
* Unmerged path include/linux/highmem.h
