printk: move dictionary keys to dev_printk_info

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author John Ogness <john.ogness@linutronix.de>
commit 74caba7f2a0685575b3ee5330a118f5922485e02
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/74caba7f.failed

Dictionaries are only used for SUBSYSTEM and DEVICE properties. The
current implementation stores the property names each time they are
used. This requires more space than otherwise necessary. Also,
because the dictionary entries are currently considered optional,
it cannot be relied upon that they are always available, even if the
writer wanted to store them. These issues will increase should new
dictionary properties be introduced.

Rather than storing the subsystem and device properties in the
dict ring, introduce a struct dev_printk_info with separate fields
to store only the property values. Embed this struct within the
struct printk_info to provide guaranteed availability.

	Signed-off-by: John Ogness <john.ogness@linutronix.de>
	Reviewed-by: Petr Mladek <pmladek@suse.com>
	Signed-off-by: Petr Mladek <pmladek@suse.com>
Link: https://lore.kernel.org/r/87mu1jl6ne.fsf@jogness.linutronix.de
(cherry picked from commit 74caba7f2a0685575b3ee5330a118f5922485e02)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/dev_printk.h
#	kernel/printk/printk.c
diff --cc kernel/printk/printk.c
index c1fedccb5ed4,f1e243cc284a..000000000000
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@@ -294,30 -295,22 +294,41 @@@ enum con_msg_format_flags 
  static int console_msg_format = MSG_FORMAT_DEFAULT;
  
  /*
++<<<<<<< HEAD
 + * The printk log buffer consists of a chain of concatenated variable
 + * length records. Every record starts with a record header, containing
 + * the overall length of the record.
++=======
+  * The printk log buffer consists of a sequenced collection of records, each
+  * containing variable length message text. Every record also contains its
+  * own meta-data (@info).
 - *
 - * Every record meta-data carries the timestamp in microseconds, as well as
 - * the standard userspace syslog level and syslog facility. The usual kernel
 - * messages use LOG_KERN; userspace-injected messages always carry a matching
 - * syslog facility, by default LOG_USER. The origin of every message can be
 - * reliably determined that way.
 - *
 - * The human readable log message of a record is available in @text, the
 - * length of the message text in @text_len. The stored message is not
 - * terminated.
 - *
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
 + *
 + * The heads to the first and last entry in the buffer, as well as the
 + * sequence numbers of these entries are maintained when messages are
 + * stored.
 + *
 + * If the heads indicate available messages, the length in the header
 + * tells the start next message. A length == 0 for the next message
 + * indicates a wrap-around to the beginning of the buffer.
 + *
++<<<<<<< HEAD
 + * Every record carries the monotonic timestamp in microseconds, as well as
 + * the standard userspace syslog level and syslog facility. The usual
 + * kernel messages use LOG_KERN; userspace-injected messages always carry
 + * a matching syslog facility, by default LOG_USER. The origin of every
 + * message can be reliably determined that way.
 + *
 + * The human readable log message directly follows the message header. The
 + * length of the message text is stored in the header, the stored message
 + * is not terminated.
 + *
 + * Optionally, a message can carry a dictionary of properties (key/value pairs),
 + * to provide userspace with a machine-readable message context.
++=======
+  * Optionally, a record can carry a dictionary of properties (key/value
+  * pairs), to provide userspace with a machine-readable message context.
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
   *
   * Examples for well-defined, commonly used property names are:
   *   DEVICE=b12:8               device identifier
@@@ -327,25 -320,22 +338,38 @@@
   *                                +sound:card0  subsystem:devname
   *   SUBSYSTEM=pci              driver-core subsystem name
   *
-  * Valid characters in property names are [a-zA-Z0-9.-_]. The plain text value
-  * follows directly after a '=' character. Every property is terminated by
-  * a '\0' character. The last property is not terminated.
+  * Valid characters in property names are [a-zA-Z0-9.-_]. Property names
+  * and values are terminated by a '\0' character.
   *
++<<<<<<< HEAD
 + * Example of a message structure:
 + *   0000  ff 8f 00 00 00 00 00 00      monotonic time in nsec
 + *   0008  34 00                        record is 52 bytes long
 + *   000a        0b 00                  text is 11 bytes long
 + *   000c              1f 00            dictionary is 23 bytes long
 + *   000e                    03 00      LOG_KERN (facility) LOG_ERR (level)
 + *   0010  69 74 27 73 20 61 20 6c      "it's a l"
 + *         69 6e 65                     "ine"
 + *   001b           44 45 56 49 43      "DEVIC"
 + *         45 3d 62 38 3a 32 00 44      "E=b8:2\0D"
 + *         52 49 56 45 52 3d 62 75      "RIVER=bu"
 + *         67                           "g"
 + *   0032     00 00 00                  padding to next message header
++=======
+  * Example of record values:
+  *   record.text_buf                = "it's a line" (unterminated)
+  *   record.info.seq                = 56
+  *   record.info.ts_nsec            = 36863
+  *   record.info.text_len           = 11
+  *   record.info.facility           = 0 (LOG_KERN)
+  *   record.info.flags              = 0
+  *   record.info.level              = 3 (LOG_ERR)
+  *   record.info.caller_id          = 299 (task 299)
+  *   record.info.dev_info.subsystem = "pci" (terminated)
+  *   record.info.dev_info.device    = "+pci:0000:00:01.0" (terminated)
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
   *
 - * The 'struct printk_info' buffer must never be directly exported to
 + * The 'struct printk_log' buffer header must never be directly exported to
   * userspace, it is a kernel-private implementation detail that might
   * need to be changed in the future, when the requirements change.
   *
@@@ -615,63 -495,47 +639,90 @@@ static u32 truncate_msg(u16 *text_len, 
  /* insert record into the buffer, discard old ones, update heads */
  static int log_store(u32 caller_id, int facility, int level,
  		     enum log_flags flags, u64 ts_nsec,
- 		     const char *dict, u16 dict_len,
+ 		     const struct dev_printk_info *dev_info,
  		     const char *text, u16 text_len)
  {
 -	struct prb_reserved_entry e;
 -	struct printk_record r;
 +	struct printk_log *msg;
 +	u32 size, pad_len;
  	u16 trunc_msg_len = 0;
  
++<<<<<<< HEAD
 +	/* number of '\0' padding bytes to next message */
 +	size = msg_used_size(text_len, dict_len, &pad_len);
++=======
+ 	prb_rec_init_wr(&r, text_len, 0);
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  
 -	if (!prb_reserve(&e, prb, &r)) {
 +	if (log_make_free_space(size)) {
  		/* truncate the message if it is too long for empty buffer */
++<<<<<<< HEAD
 +		size = truncate_msg(&text_len, &trunc_msg_len,
 +				    &dict_len, &pad_len);
++=======
+ 		truncate_msg(&text_len, &trunc_msg_len);
+ 		prb_rec_init_wr(&r, text_len + trunc_msg_len, 0);
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  		/* survive when the log buffer is too small for trunc_msg */
 -		if (!prb_reserve(&e, prb, &r))
 +		if (log_make_free_space(size))
  			return 0;
  	}
  
++<<<<<<< HEAD
 +	if (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {
 +		/*
 +		 * This message + an additional empty header does not fit
 +		 * at the end of the buffer. Add an empty header with len == 0
 +		 * to signify a wrap around.
 +		 */
 +		memset(log_buf + log_next_idx, 0, sizeof(struct printk_log));
 +		log_next_idx = 0;
 +	}
 +
 +	/* fill message */
 +	msg = (struct printk_log *)(log_buf + log_next_idx);
 +	memcpy(log_text(msg), text, text_len);
 +	msg->text_len = text_len;
 +	if (trunc_msg_len) {
 +		memcpy(log_text(msg) + text_len, trunc_msg, trunc_msg_len);
 +		msg->text_len += trunc_msg_len;
 +	}
 +	memcpy(log_dict(msg), dict, dict_len);
 +	msg->dict_len = dict_len;
 +	msg->facility = facility;
 +	msg->level = level & 7;
 +	msg->flags = flags & 0x1f;
++=======
+ 	/* fill message */
+ 	memcpy(&r.text_buf[0], text, text_len);
+ 	if (trunc_msg_len)
+ 		memcpy(&r.text_buf[text_len], trunc_msg, trunc_msg_len);
+ 	r.info->text_len = text_len + trunc_msg_len;
+ 	r.info->facility = facility;
+ 	r.info->level = level & 7;
+ 	r.info->flags = flags & 0x1f;
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  	if (ts_nsec > 0)
 -		r.info->ts_nsec = ts_nsec;
 +		msg->ts_nsec = ts_nsec;
  	else
++<<<<<<< HEAD
 +		msg->ts_nsec = local_clock();
 +#ifdef CONFIG_PRINTK_CALLER
 +	msg->caller_id = caller_id;
 +#endif
 +	memset(log_dict(msg) + dict_len, 0, pad_len);
 +	msg->len = size;
++=======
+ 		r.info->ts_nsec = local_clock();
+ 	r.info->caller_id = caller_id;
+ 	if (dev_info)
+ 		memcpy(&r.info->dev_info, dev_info, sizeof(r.info->dev_info));
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  
  	/* insert message */
 -	if ((flags & LOG_CONT) || !(flags & LOG_NEWLINE))
 -		prb_commit(&e);
 -	else
 -		prb_final_commit(&e);
 +	log_next_idx += msg->len;
 +	log_next_seq++;
  
 -	return (text_len + trunc_msg_len);
 +	return msg->text_len;
  }
  
  int dmesg_restrict = IS_ENABLED(CONFIG_SECURITY_DMESG_RESTRICT);
@@@ -740,13 -604,13 +791,13 @@@ static ssize_t msg_print_ext_header(cha
  	do_div(ts_usec, 1000);
  
  	return scnprintf(buf, size, "%u,%llu,%llu,%c%s;",
 -			 (info->facility << 3) | info->level, info->seq,
 -			 ts_usec, info->flags & LOG_CONT ? 'c' : '-', caller);
 +			 (msg->facility << 3) | msg->level, seq, ts_usec,
 +			 msg->flags & LOG_CONT ? 'c' : '-', caller);
  }
  
- static ssize_t msg_print_ext_body(char *buf, size_t size,
- 				  char *dict, size_t dict_len,
- 				  char *text, size_t text_len)
+ static ssize_t msg_add_ext_text(char *buf, size_t size,
+ 				const char *text, size_t text_len,
+ 				unsigned char endc)
  {
  	char *p = buf, *e = buf + size;
  	size_t i;
@@@ -799,6 -670,10 +858,13 @@@ struct devkmsg_user 
  	struct ratelimit_state rs;
  	struct mutex lock;
  	char buf[CONSOLE_EXT_LOG_MAX];
++<<<<<<< HEAD
++=======
+ 
+ 	struct printk_info info;
+ 	char text_buf[CONSOLE_EXT_LOG_MAX];
+ 	struct printk_record record;
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  };
  
  static __printf(3, 4) __cold
@@@ -917,15 -791,12 +983,20 @@@ static ssize_t devkmsg_read(struct fil
  		goto out;
  	}
  
 -	len = info_print_ext_header(user->buf, sizeof(user->buf), r->info);
 +	msg = log_from_idx(user->idx);
 +	len = msg_print_ext_header(user->buf, sizeof(user->buf),
 +				   msg, user->seq);
  	len += msg_print_ext_body(user->buf + len, sizeof(user->buf) - len,
++<<<<<<< HEAD
 +				  log_dict(msg), msg->dict_len,
 +				  log_text(msg), msg->text_len);
++=======
+ 				  &r->text_buf[0], r->info->text_len,
+ 				  &r->info->dev_info);
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  
 -	user->seq = r->info->seq + 1;
 +	user->idx = log_next(user->idx);
 +	user->seq++;
  	logbuf_unlock_irq();
  
  	if (len > count) {
@@@ -1029,9 -897,12 +1100,16 @@@ static int devkmsg_open(struct inode *i
  
  	mutex_init(&user->lock);
  
++<<<<<<< HEAD
++=======
+ 	prb_rec_init_rd(&user->record, &user->info,
+ 			&user->text_buf[0], sizeof(user->text_buf),
+ 			NULL, 0);
+ 
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  	logbuf_lock_irq();
 -	user->seq = prb_first_valid_seq(prb);
 +	user->idx = log_first_idx;
 +	user->seq = log_first_seq;
  	logbuf_unlock_irq();
  
  	file->private_data = user;
@@@ -1072,23 -943,61 +1150,80 @@@ const struct file_operations kmsg_fops 
   */
  void log_buf_vmcoreinfo_setup(void)
  {
++<<<<<<< HEAD
 +	VMCOREINFO_SYMBOL(log_buf);
 +	VMCOREINFO_SYMBOL(log_buf_len);
 +	VMCOREINFO_SYMBOL(log_first_idx);
 +	VMCOREINFO_SYMBOL(clear_idx);
 +	VMCOREINFO_SYMBOL(log_next_idx);
++=======
+ 	struct dev_printk_info *dev_info = NULL;
+ 
+ 	VMCOREINFO_SYMBOL(prb);
+ 	VMCOREINFO_SYMBOL(printk_rb_static);
+ 	VMCOREINFO_SYMBOL(clear_seq);
+ 
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  	/*
 -	 * Export struct size and field offsets. User space tools can
 +	 * Export struct printk_log size and field offsets. User space tools can
  	 * parse it and detect any changes to structure down the line.
  	 */
++<<<<<<< HEAD
 +	VMCOREINFO_STRUCT_SIZE(printk_log);
 +	VMCOREINFO_OFFSET(printk_log, ts_nsec);
 +	VMCOREINFO_OFFSET(printk_log, len);
 +	VMCOREINFO_OFFSET(printk_log, text_len);
 +	VMCOREINFO_OFFSET(printk_log, dict_len);
 +#ifdef CONFIG_PRINTK_CALLER
 +	VMCOREINFO_OFFSET(printk_log, caller_id);
 +#endif
++=======
+ 
+ 	VMCOREINFO_STRUCT_SIZE(printk_ringbuffer);
+ 	VMCOREINFO_OFFSET(printk_ringbuffer, desc_ring);
+ 	VMCOREINFO_OFFSET(printk_ringbuffer, text_data_ring);
+ 	VMCOREINFO_OFFSET(printk_ringbuffer, dict_data_ring);
+ 	VMCOREINFO_OFFSET(printk_ringbuffer, fail);
+ 
+ 	VMCOREINFO_STRUCT_SIZE(prb_desc_ring);
+ 	VMCOREINFO_OFFSET(prb_desc_ring, count_bits);
+ 	VMCOREINFO_OFFSET(prb_desc_ring, descs);
+ 	VMCOREINFO_OFFSET(prb_desc_ring, infos);
+ 	VMCOREINFO_OFFSET(prb_desc_ring, head_id);
+ 	VMCOREINFO_OFFSET(prb_desc_ring, tail_id);
+ 
+ 	VMCOREINFO_STRUCT_SIZE(prb_desc);
+ 	VMCOREINFO_OFFSET(prb_desc, state_var);
+ 	VMCOREINFO_OFFSET(prb_desc, text_blk_lpos);
+ 	VMCOREINFO_OFFSET(prb_desc, dict_blk_lpos);
+ 
+ 	VMCOREINFO_STRUCT_SIZE(prb_data_blk_lpos);
+ 	VMCOREINFO_OFFSET(prb_data_blk_lpos, begin);
+ 	VMCOREINFO_OFFSET(prb_data_blk_lpos, next);
+ 
+ 	VMCOREINFO_STRUCT_SIZE(printk_info);
+ 	VMCOREINFO_OFFSET(printk_info, seq);
+ 	VMCOREINFO_OFFSET(printk_info, ts_nsec);
+ 	VMCOREINFO_OFFSET(printk_info, text_len);
+ 	VMCOREINFO_OFFSET(printk_info, dict_len);
+ 	VMCOREINFO_OFFSET(printk_info, caller_id);
+ 	VMCOREINFO_OFFSET(printk_info, dev_info);
+ 
+ 	VMCOREINFO_STRUCT_SIZE(dev_printk_info);
+ 	VMCOREINFO_OFFSET(dev_printk_info, subsystem);
+ 	VMCOREINFO_LENGTH(printk_info_subsystem, sizeof(dev_info->subsystem));
+ 	VMCOREINFO_OFFSET(dev_printk_info, device);
+ 	VMCOREINFO_LENGTH(printk_info_device, sizeof(dev_info->device));
+ 
+ 	VMCOREINFO_STRUCT_SIZE(prb_data_ring);
+ 	VMCOREINFO_OFFSET(prb_data_ring, size_bits);
+ 	VMCOREINFO_OFFSET(prb_data_ring, data);
+ 	VMCOREINFO_OFFSET(prb_data_ring, head_lpos);
+ 	VMCOREINFO_OFFSET(prb_data_ring, tail_lpos);
+ 
+ 	VMCOREINFO_SIZE(atomic_long_t);
+ 	VMCOREINFO_TYPE_OFFSET(atomic_long_t, counter);
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  }
  #endif
  
@@@ -1166,11 -1075,47 +1301,41 @@@ static void __init set_percpu_data_read
  	__printk_percpu_data_ready = true;
  }
  
++<<<<<<< HEAD
++=======
+ static unsigned int __init add_to_rb(struct printk_ringbuffer *rb,
+ 				     struct printk_record *r)
+ {
+ 	struct prb_reserved_entry e;
+ 	struct printk_record dest_r;
+ 
+ 	prb_rec_init_wr(&dest_r, r->info->text_len, 0);
+ 
+ 	if (!prb_reserve(&e, rb, &dest_r))
+ 		return 0;
+ 
+ 	memcpy(&dest_r.text_buf[0], &r->text_buf[0], r->info->text_len);
+ 	dest_r.info->text_len = r->info->text_len;
+ 	dest_r.info->facility = r->info->facility;
+ 	dest_r.info->level = r->info->level;
+ 	dest_r.info->flags = r->info->flags;
+ 	dest_r.info->ts_nsec = r->info->ts_nsec;
+ 	dest_r.info->caller_id = r->info->caller_id;
+ 	memcpy(&dest_r.info->dev_info, &r->info->dev_info, sizeof(dest_r.info->dev_info));
+ 
+ 	prb_final_commit(&e);
+ 
+ 	return prb_record_text_space(&e);
+ }
+ 
+ static char setup_text_buf[CONSOLE_EXT_LOG_MAX] __initdata;
+ 
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  void __init setup_log_buf(int early)
  {
 -	struct printk_info *new_infos;
 -	unsigned int new_descs_count;
 -	struct prb_desc *new_descs;
 -	struct printk_info info;
 -	struct printk_record r;
 -	size_t new_descs_size;
 -	size_t new_infos_size;
  	unsigned long flags;
 -	char *new_dict_buf;
  	char *new_log_buf;
  	unsigned int free;
 -	u64 seq;
  
  	/*
  	 * Some archs call setup_log_buf() multiple times - first is very
@@@ -1203,7 -1147,41 +1368,43 @@@
  		return;
  	}
  
++<<<<<<< HEAD
++=======
+ 	new_dict_buf = memblock_alloc(new_log_buf_len, LOG_ALIGN);
+ 	if (unlikely(!new_dict_buf)) {
+ 		pr_err("log_buf_len: %lu dict bytes not available\n",
+ 		       new_log_buf_len);
+ 		goto err_free_log_buf;
+ 	}
+ 
+ 	new_descs_size = new_descs_count * sizeof(struct prb_desc);
+ 	new_descs = memblock_alloc(new_descs_size, LOG_ALIGN);
+ 	if (unlikely(!new_descs)) {
+ 		pr_err("log_buf_len: %zu desc bytes not available\n",
+ 		       new_descs_size);
+ 		goto err_free_dict_buf;
+ 	}
+ 
+ 	new_infos_size = new_descs_count * sizeof(struct printk_info);
+ 	new_infos = memblock_alloc(new_infos_size, LOG_ALIGN);
+ 	if (unlikely(!new_infos)) {
+ 		pr_err("log_buf_len: %zu info bytes not available\n",
+ 		       new_infos_size);
+ 		goto err_free_descs;
+ 	}
+ 
+ 	prb_rec_init_rd(&r, &info,
+ 			&setup_text_buf[0], sizeof(setup_text_buf),
+ 			NULL, 0);
+ 
+ 	prb_init(&printk_rb_dynamic,
+ 		 new_log_buf, ilog2(new_log_buf_len),
+ 		 new_dict_buf, ilog2(new_log_buf_len),
+ 		 new_descs, ilog2(new_descs_count),
+ 		 new_infos);
+ 
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  	logbuf_lock_irqsave(flags);
 -
  	log_buf_len = new_log_buf_len;
  	log_buf = new_log_buf;
  	new_log_buf_len = 0;
@@@ -1847,63 -1910,9 +2048,69 @@@ static inline u32 printk_caller_id(void
  		0x80000000 + raw_smp_processor_id();
  }
  
++<<<<<<< HEAD
 +/*
 + * Continuation lines are buffered, and not committed to the record buffer
 + * until the line is complete, or a race forces it. The line fragments
 + * though, are printed immediately to the consoles to ensure everything has
 + * reached the console in case of a kernel crash.
 + */
 +static struct cont {
 +	char buf[LOG_LINE_MAX];
 +	size_t len;			/* length == 0 means unused buffer */
 +	u32 caller_id;			/* printk_caller_id() of first print */
 +	u64 ts_nsec;			/* time of first print */
 +	u8 level;			/* log level of first message */
 +	u8 facility;			/* log facility of first message */
 +	enum log_flags flags;		/* prefix, newline flags */
 +} cont;
 +
 +static void cont_flush(void)
 +{
 +	if (cont.len == 0)
 +		return;
 +
 +	log_store(cont.caller_id, cont.facility, cont.level, cont.flags,
 +		  cont.ts_nsec, NULL, 0, cont.buf, cont.len);
 +	cont.len = 0;
 +}
 +
 +static bool cont_add(u32 caller_id, int facility, int level,
 +		     enum log_flags flags, const char *text, size_t len)
 +{
 +	/* If the line gets too long, split it up in separate records. */
 +	if (cont.len + len > sizeof(cont.buf)) {
 +		cont_flush();
 +		return false;
 +	}
 +
 +	if (!cont.len) {
 +		cont.facility = facility;
 +		cont.level = level;
 +		cont.caller_id = caller_id;
 +		cont.ts_nsec = local_clock();
 +		cont.flags = flags;
 +	}
 +
 +	memcpy(cont.buf + cont.len, text, len);
 +	cont.len += len;
 +
 +	// The original flags come from the first line,
 +	// but later continuations can add a newline.
 +	if (flags & LOG_NEWLINE) {
 +		cont.flags |= LOG_NEWLINE;
 +		cont_flush();
 +	}
 +
 +	return true;
 +}
 +
 +static size_t log_output(int facility, int level, enum log_flags lflags, const char *dict, size_t dictlen, char *text, size_t text_len)
++=======
+ static size_t log_output(int facility, int level, enum log_flags lflags,
+ 			 const struct dev_printk_info *dev_info,
+ 			 char *text, size_t text_len)
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  {
  	const u32 caller_id = printk_caller_id();
  
@@@ -2086,24 -2089,27 +2292,24 @@@ EXPORT_SYMBOL(printk)
  #define PREFIX_MAX		0
  #define printk_time		false
  
 -#define prb_read_valid(rb, seq, r)	false
 -#define prb_first_valid_seq(rb)		0
 -
  static u64 syslog_seq;
 +static u32 syslog_idx;
  static u64 console_seq;
 +static u32 console_idx;
  static u64 exclusive_console_stop_seq;
 -static unsigned long console_dropped;
 -
 -static size_t record_print_text(const struct printk_record *r,
 -				bool syslog, bool time)
 -{
 -	return 0;
 -}
 -static ssize_t info_print_ext_header(char *buf, size_t size,
 -				     struct printk_info *info)
 -{
 -	return 0;
 -}
 +static u64 log_first_seq;
 +static u32 log_first_idx;
 +static u64 log_next_seq;
 +static char *log_text(const struct printk_log *msg) { return NULL; }
 +static char *log_dict(const struct printk_log *msg) { return NULL; }
 +static struct printk_log *log_from_idx(u32 idx) { return NULL; }
 +static u32 log_next(u32 idx) { return 0; }
 +static ssize_t msg_print_ext_header(char *buf, size_t size,
 +				    struct printk_log *msg,
 +				    u64 seq) { return 0; }
  static ssize_t msg_print_ext_body(char *buf, size_t size,
- 				  char *dict, size_t dict_len,
- 				  char *text, size_t text_len) { return 0; }
+ 				  char *text, size_t text_len,
+ 				  struct dev_printk_info *dev_info) { return 0; }
  static void console_lock_spinning_enable(void) { }
  static int console_lock_spinning_disable_and_check(void) { return 0; }
  static void call_console_drivers(const char *ext_text, size_t ext_len,
@@@ -2402,6 -2408,8 +2608,11 @@@ void console_unlock(void
  		return;
  	}
  
++<<<<<<< HEAD
++=======
+ 	prb_rec_init_rd(&r, &info, text, sizeof(text), NULL, 0);
+ 
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  	/*
  	 * Console drivers are called with interrupts disabled, so
  	 * @console_may_schedule should be cleared before; however, we may
@@@ -2471,19 -2470,23 +2682,25 @@@ skip
  			exclusive_console = NULL;
  		}
  
 -		/*
 -		 * Handle extended console text first because later
 -		 * record_print_text() will modify the record buffer in-place.
 -		 */
 +		len += msg_print_text(msg,
 +				console_msg_format & MSG_FORMAT_SYSLOG,
 +				printk_time, text + len, sizeof(text) - len);
  		if (nr_ext_console_drivers) {
 -			ext_len = info_print_ext_header(ext_text,
 +			ext_len = msg_print_ext_header(ext_text,
  						sizeof(ext_text),
 -						r.info);
 +						msg, console_seq);
  			ext_len += msg_print_ext_body(ext_text + ext_len,
  						sizeof(ext_text) - ext_len,
++<<<<<<< HEAD
 +						log_dict(msg), msg->dict_len,
 +						log_text(msg), msg->text_len);
++=======
+ 						&r.text_buf[0],
+ 						r.info->text_len,
+ 						&r.info->dev_info);
++>>>>>>> 74caba7f2a06 (printk: move dictionary keys to dev_printk_info)
  		}
 -		len = record_print_text(&r,
 -				console_msg_format & MSG_FORMAT_SYSLOG,
 -				printk_time);
 +		console_idx = log_next(console_idx);
  		console_seq++;
  		raw_spin_unlock(&logbuf_lock);
  
* Unmerged path include/linux/dev_printk.h
diff --git a/Documentation/admin-guide/kdump/gdbmacros.txt b/Documentation/admin-guide/kdump/gdbmacros.txt
index 94fabb165abf..82aecdcae8a6 100644
--- a/Documentation/admin-guide/kdump/gdbmacros.txt
+++ b/Documentation/admin-guide/kdump/gdbmacros.txt
@@ -172,13 +172,13 @@ end
 
 define dump_record
 	set var $desc = $arg0
-	if ($argc > 1)
-		set var $prev_flags = $arg1
+	set var $info = $arg1
+	if ($argc > 2)
+		set var $prev_flags = $arg2
 	else
 		set var $prev_flags = 0
 	end
 
-	set var $info = &$desc->info
 	set var $prefix = 1
 	set var $newline = 1
 
@@ -237,44 +237,36 @@ define dump_record
 
 	# handle dictionary data
 
-	set var $begin = $desc->dict_blk_lpos.begin % (1U << prb->dict_data_ring.size_bits)
-	set var $next = $desc->dict_blk_lpos.next % (1U << prb->dict_data_ring.size_bits)
-
-	# handle data-less record
-	if ($begin & 1)
-		set var $dict_len = 0
-		set var $dict = ""
-	else
-		# handle wrapping data block
-		if ($begin > $next)
-			set var $begin = 0
-		end
-
-		# skip over descriptor id
-		set var $begin = $begin + sizeof(long)
-
-		# handle truncated message
-		if ($next - $begin < $info->dict_len)
-			set var $dict_len = $next - $begin
-		else
-			set var $dict_len = $info->dict_len
+	set var $dict = &$info->dev_info.subsystem[0]
+	set var $dict_len = sizeof($info->dev_info.subsystem)
+	if ($dict[0] != '\0')
+		printf " SUBSYSTEM="
+		set var $idx = 0
+		while ($idx < $dict_len)
+			set var $c = $dict[$idx]
+			if ($c == '\0')
+				loop_break
+			else
+				if ($c < ' ' || $c >= 127 || $c == '\\')
+					printf "\\x%02x", $c
+				else
+					printf "%c", $c
+				end
+			end
+			set var $idx = $idx + 1
 		end
-
-		set var $dict = &prb->dict_data_ring.data[$begin]
+		printf "\n"
 	end
 
-	if ($dict_len > 0)
+	set var $dict = &$info->dev_info.device[0]
+	set var $dict_len = sizeof($info->dev_info.device)
+	if ($dict[0] != '\0')
+		printf " DEVICE="
 		set var $idx = 0
-		set var $line = 1
 		while ($idx < $dict_len)
-			if ($line)
-				printf " "
-				set var $line = 0
-			end
 			set var $c = $dict[$idx]
 			if ($c == '\0')
-				printf "\n"
-				set var $line = 1
+				loop_break
 			else
 				if ($c < ' ' || $c >= 127 || $c == '\\')
 					printf "\\x%02x", $c
@@ -288,10 +280,10 @@ define dump_record
 	end
 end
 document dump_record
-	Dump a single record. The first parameter is the descriptor
-	sequence number, the second is optional and specifies the
-	previous record's flags, used for properly formatting
-	continued lines.
+	Dump a single record. The first parameter is the descriptor,
+	the second parameter is the info, the third parameter is
+	optional and specifies the previous record's flags, used for
+	properly formatting continued lines.
 end
 
 define dmesg
@@ -311,12 +303,13 @@ define dmesg
 
 	while (1)
 		set var $desc = &prb->desc_ring.descs[$id % $desc_count]
+		set var $info = &prb->desc_ring.infos[$id % $desc_count]
 
 		# skip non-committed record
 		set var $state = 3 & ($desc->state_var.counter >> $desc_flags_shift)
 		if ($state == $desc_committed || $state == $desc_finalized)
-			dump_record $desc $prev_flags
-			set var $prev_flags = $desc->info.flags
+			dump_record $desc $info $prev_flags
+			set var $prev_flags = $info->flags
 		end
 
 		set var $id = ($id + 1) & $id_mask
diff --git a/drivers/base/core.c b/drivers/base/core.c
index c73bf3cdd933..ba89970b5ecd 100644
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@ -3884,22 +3884,21 @@ void device_shutdown(void)
  */
 
 #ifdef CONFIG_PRINTK
-static int
-create_syslog_header(const struct device *dev, char *hdr, size_t hdrlen)
+static void
+set_dev_info(const struct device *dev, struct dev_printk_info *dev_info)
 {
 	const char *subsys;
-	size_t pos = 0;
+
+	memset(dev_info, 0, sizeof(*dev_info));
 
 	if (dev->class)
 		subsys = dev->class->name;
 	else if (dev->bus)
 		subsys = dev->bus->name;
 	else
-		return 0;
+		return;
 
-	pos += snprintf(hdr + pos, hdrlen - pos, "SUBSYSTEM=%s", subsys);
-	if (pos >= hdrlen)
-		goto overflow;
+	strscpy(dev_info->subsystem, subsys, sizeof(dev_info->subsystem));
 
 	/*
 	 * Add device identifier DEVICE=:
@@ -3915,41 +3914,28 @@ create_syslog_header(const struct device *dev, char *hdr, size_t hdrlen)
 			c = 'b';
 		else
 			c = 'c';
-		pos++;
-		pos += snprintf(hdr + pos, hdrlen - pos,
-				"DEVICE=%c%u:%u",
-				c, MAJOR(dev->devt), MINOR(dev->devt));
+
+		snprintf(dev_info->device, sizeof(dev_info->device),
+			 "%c%u:%u", c, MAJOR(dev->devt), MINOR(dev->devt));
 	} else if (strcmp(subsys, "net") == 0) {
 		struct net_device *net = to_net_dev(dev);
 
-		pos++;
-		pos += snprintf(hdr + pos, hdrlen - pos,
-				"DEVICE=n%u", net->ifindex);
+		snprintf(dev_info->device, sizeof(dev_info->device),
+			 "n%u", net->ifindex);
 	} else {
-		pos++;
-		pos += snprintf(hdr + pos, hdrlen - pos,
-				"DEVICE=+%s:%s", subsys, dev_name(dev));
+		snprintf(dev_info->device, sizeof(dev_info->device),
+			 "+%s:%s", subsys, dev_name(dev));
 	}
-
-	if (pos >= hdrlen)
-		goto overflow;
-
-	return pos;
-
-overflow:
-	dev_WARN(dev, "device/subsystem name too long");
-	return 0;
 }
 
 int dev_vprintk_emit(int level, const struct device *dev,
 		     const char *fmt, va_list args)
 {
-	char hdr[128];
-	size_t hdrlen;
+	struct dev_printk_info dev_info;
 
-	hdrlen = create_syslog_header(dev, hdr, sizeof(hdr));
+	set_dev_info(dev, &dev_info);
 
-	return vprintk_emit(0, level, hdrlen ? hdr : NULL, hdrlen, fmt, args);
+	return vprintk_emit(0, level, &dev_info, fmt, args);
 }
 EXPORT_SYMBOL(dev_vprintk_emit);
 
* Unmerged path include/linux/dev_printk.h
diff --git a/include/linux/printk.h b/include/linux/printk.h
index 03eff591fd79..acfb60dadff4 100644
--- a/include/linux/printk.h
+++ b/include/linux/printk.h
@@ -161,10 +161,12 @@ static inline void printk_nmi_direct_enter(void) { }
 static inline void printk_nmi_direct_exit(void) { }
 #endif /* PRINTK_NMI */
 
+struct dev_printk_info;
+
 #ifdef CONFIG_PRINTK
-asmlinkage __printf(5, 0)
+asmlinkage __printf(4, 0)
 int vprintk_emit(int facility, int level,
-		 const char *dict, size_t dictlen,
+		 const struct dev_printk_info *dev_info,
 		 const char *fmt, va_list args);
 
 asmlinkage __printf(1, 0)
diff --git a/kernel/printk/internal.h b/kernel/printk/internal.h
index c27d47058841..f51a9681a906 100644
--- a/kernel/printk/internal.h
+++ b/kernel/printk/internal.h
@@ -24,9 +24,9 @@
 
 extern raw_spinlock_t logbuf_lock;
 
-__printf(5, 0)
+__printf(4, 0)
 int vprintk_store(int facility, int level,
-		  const char *dict, size_t dictlen,
+		  const struct dev_printk_info *dev_info,
 		  const char *fmt, va_list args);
 
 __printf(1, 0) int vprintk_default(const char *fmt, va_list args);
* Unmerged path kernel/printk/printk.c
diff --git a/kernel/printk/printk_ringbuffer.h b/kernel/printk/printk_ringbuffer.h
index 853ea62dc5f2..eccf74a89024 100644
--- a/kernel/printk/printk_ringbuffer.h
+++ b/kernel/printk/printk_ringbuffer.h
@@ -4,6 +4,7 @@
 #define _KERNEL_PRINTK_RINGBUFFER_H
 
 #include <linux/atomic.h>
+#include <linux/dev_printk.h>
 
 /*
  * Meta information about each stored message.
@@ -21,6 +22,8 @@ struct printk_info {
 	u8	flags:5;	/* internal record flags */
 	u8	level:3;	/* syslog level */
 	u32	caller_id;	/* thread id or processor id */
+
+	struct dev_printk_info	dev_info;
 };
 
 /*
diff --git a/kernel/printk/printk_safe.c b/kernel/printk/printk_safe.c
index 8f6be8a5d087..2ad11ad0bb14 100644
--- a/kernel/printk/printk_safe.c
+++ b/kernel/printk/printk_safe.c
@@ -371,7 +371,7 @@ __printf(1, 0) int vprintk_func(const char *fmt, va_list args)
 	    raw_spin_trylock(&logbuf_lock)) {
 		int len;
 
-		len = vprintk_store(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);
+		len = vprintk_store(0, LOGLEVEL_DEFAULT, NULL, fmt, args);
 		raw_spin_unlock(&logbuf_lock);
 		defer_console_output();
 		return len;
diff --git a/scripts/gdb/linux/dmesg.py b/scripts/gdb/linux/dmesg.py
index bce14de5f610..a92c55bd8de5 100644
--- a/scripts/gdb/linux/dmesg.py
+++ b/scripts/gdb/linux/dmesg.py
@@ -52,6 +52,12 @@ class LxDmesg(gdb.Command):
         addr = utils.read_ulong(desc_ring, off)
         descs = utils.read_memoryview(inf, addr, desc_sz * desc_ring_count).tobytes()
 
+        # read in info array
+        info_sz = printk_info_type.get_type().sizeof
+        off = prb_desc_ring_type.get_type()['infos'].bitpos // 8
+        addr = utils.read_ulong(desc_ring, off)
+        infos = utils.read_memoryview(inf, addr, info_sz * desc_ring_count).tobytes()
+
         # read in text data ring structure
         off = printk_ringbuffer_type.get_type()['text_data_ring'].bitpos // 8
         addr = prb_addr + off
@@ -73,9 +79,8 @@ class LxDmesg(gdb.Command):
         begin_off = off + (prb_data_blk_lpos_type.get_type()['begin'].bitpos // 8)
         next_off = off + (prb_data_blk_lpos_type.get_type()['next'].bitpos // 8)
 
-        off = prb_desc_type.get_type()['info'].bitpos // 8
-        ts_off = off + printk_info_type.get_type()['ts_nsec'].bitpos // 8
-        len_off = off + printk_info_type.get_type()['text_len'].bitpos // 8
+        ts_off = printk_info_type.get_type()['ts_nsec'].bitpos // 8
+        len_off = printk_info_type.get_type()['text_len'].bitpos // 8
 
         # definitions from kernel/printk/printk_ringbuffer.h
         desc_committed = 1
@@ -95,6 +100,7 @@ class LxDmesg(gdb.Command):
         while True:
             ind = did % desc_ring_count
             desc_off = desc_sz * ind
+            info_off = info_sz * ind
 
             # skip non-committed record
             state = 3 & (utils.read_u64(descs, desc_off + sv_off +
@@ -119,7 +125,7 @@ class LxDmesg(gdb.Command):
                 # skip over descriptor id
                 text_start = begin + utils.get_long_type().sizeof
 
-                text_len = utils.read_u16(descs, desc_off + len_off)
+                text_len = utils.read_u16(infos, info_off + len_off)
 
                 # handle truncated message
                 if end - text_start < text_len:
@@ -128,7 +134,7 @@ class LxDmesg(gdb.Command):
                 text = text_data[text_start:text_start + text_len].decode(
                     encoding='utf8', errors='replace')
 
-            time_stamp = utils.read_u64(descs, desc_off + ts_off)
+            time_stamp = utils.read_u64(infos, info_off + ts_off)
 
             for line in text.splitlines():
                 msg = u"[{time:12.6f}] {line}\n".format(
