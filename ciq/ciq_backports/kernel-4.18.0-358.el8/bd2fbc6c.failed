Bluetooth: Add handler of MGMT_OP_REMOVE_ADV_MONITOR

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Miao-chen Chou <mcchou@chromium.org>
commit bd2fbc6cb815b5171facb42526f6db206d920e13
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/bd2fbc6c.failed

This adds the request handler of MGMT_OP_REMOVE_ADV_MONITOR command.
Note that the controller-based monitoring is not yet in place. This
removes the internal monitor(s) without sending HCI traffic, so the
request returns immediately.

The following test was performed.
- Issue btmgmt advmon-remove with valid and invalid handles.

	Signed-off-by: Miao-chen Chou <mcchou@chromium.org>
	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
(cherry picked from commit bd2fbc6cb815b5171facb42526f6db206d920e13)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/net/bluetooth/hci_core.h
#	net/bluetooth/hci_core.c
#	net/bluetooth/mgmt.c
diff --cc include/net/bluetooth/hci_core.h
index 7a4a7a86d423,c54f9295892e..000000000000
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@@ -1261,6 -1280,11 +1261,14 @@@ int hci_add_adv_instance(struct hci_de
  int hci_remove_adv_instance(struct hci_dev *hdev, u8 instance);
  void hci_adv_instances_set_rpa_expired(struct hci_dev *hdev, bool rpa_expired);
  
++<<<<<<< HEAD
++=======
+ void hci_adv_monitors_clear(struct hci_dev *hdev);
+ void hci_free_adv_monitor(struct adv_monitor *monitor);
+ int hci_add_adv_monitor(struct hci_dev *hdev, struct adv_monitor *monitor);
+ int hci_remove_adv_monitor(struct hci_dev *hdev, u16 handle);
+ 
++>>>>>>> bd2fbc6cb815 (Bluetooth: Add handler of MGMT_OP_REMOVE_ADV_MONITOR)
  void hci_event_packet(struct hci_dev *hdev, struct sk_buff *skb);
  
  void hci_init_sysfs(struct hci_dev *hdev);
diff --cc net/bluetooth/hci_core.c
index 666cd966baa4,59132b3e2cde..000000000000
--- a/net/bluetooth/hci_core.c
+++ b/net/bluetooth/hci_core.c
@@@ -2995,6 -2995,83 +2995,86 @@@ int hci_add_adv_instance(struct hci_de
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ /* This function requires the caller holds hdev->lock */
+ void hci_adv_monitors_clear(struct hci_dev *hdev)
+ {
+ 	struct adv_monitor *monitor;
+ 	int handle;
+ 
+ 	idr_for_each_entry(&hdev->adv_monitors_idr, monitor, handle)
+ 		hci_free_adv_monitor(monitor);
+ 
+ 	idr_destroy(&hdev->adv_monitors_idr);
+ }
+ 
+ void hci_free_adv_monitor(struct adv_monitor *monitor)
+ {
+ 	struct adv_pattern *pattern;
+ 	struct adv_pattern *tmp;
+ 
+ 	if (!monitor)
+ 		return;
+ 
+ 	list_for_each_entry_safe(pattern, tmp, &monitor->patterns, list)
+ 		kfree(pattern);
+ 
+ 	kfree(monitor);
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int hci_add_adv_monitor(struct hci_dev *hdev, struct adv_monitor *monitor)
+ {
+ 	int min, max, handle;
+ 
+ 	if (!monitor)
+ 		return -EINVAL;
+ 
+ 	min = HCI_MIN_ADV_MONITOR_HANDLE;
+ 	max = HCI_MIN_ADV_MONITOR_HANDLE + HCI_MAX_ADV_MONITOR_NUM_HANDLES;
+ 	handle = idr_alloc(&hdev->adv_monitors_idr, monitor, min, max,
+ 			   GFP_KERNEL);
+ 	if (handle < 0)
+ 		return handle;
+ 
+ 	hdev->adv_monitors_cnt++;
+ 	monitor->handle = handle;
+ 	return 0;
+ }
+ 
+ static int free_adv_monitor(int id, void *ptr, void *data)
+ {
+ 	struct hci_dev *hdev = data;
+ 	struct adv_monitor *monitor = ptr;
+ 
+ 	idr_remove(&hdev->adv_monitors_idr, monitor->handle);
+ 	hci_free_adv_monitor(monitor);
+ 
+ 	return 0;
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int hci_remove_adv_monitor(struct hci_dev *hdev, u16 handle)
+ {
+ 	struct adv_monitor *monitor;
+ 
+ 	if (handle) {
+ 		monitor = idr_find(&hdev->adv_monitors_idr, handle);
+ 		if (!monitor)
+ 			return -ENOENT;
+ 
+ 		idr_remove(&hdev->adv_monitors_idr, monitor->handle);
+ 		hci_free_adv_monitor(monitor);
+ 	} else {
+ 		/* Remove all monitors if handle is 0. */
+ 		idr_for_each(&hdev->adv_monitors_idr, &free_adv_monitor, hdev);
+ 	}
+ 
+ 	return 0;
+ }
+ 
++>>>>>>> bd2fbc6cb815 (Bluetooth: Add handler of MGMT_OP_REMOVE_ADV_MONITOR)
  struct bdaddr_list *hci_bdaddr_list_lookup(struct list_head *bdaddr_list,
  					 bdaddr_t *bdaddr, u8 type)
  {
diff --cc net/bluetooth/mgmt.c
index 46a1d1b65411,cff24fde72d2..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -108,6 -110,18 +108,21 @@@ static const u16 mgmt_commands[] = 
  	MGMT_OP_SET_APPEARANCE,
  	MGMT_OP_SET_BLOCKED_KEYS,
  	MGMT_OP_SET_WIDEBAND_SPEECH,
++<<<<<<< HEAD
++=======
+ 	MGMT_OP_READ_SECURITY_INFO,
+ 	MGMT_OP_READ_EXP_FEATURES_INFO,
+ 	MGMT_OP_SET_EXP_FEATURE,
+ 	MGMT_OP_READ_DEF_SYSTEM_CONFIG,
+ 	MGMT_OP_SET_DEF_SYSTEM_CONFIG,
+ 	MGMT_OP_READ_DEF_RUNTIME_CONFIG,
+ 	MGMT_OP_SET_DEF_RUNTIME_CONFIG,
+ 	MGMT_OP_GET_DEVICE_FLAGS,
+ 	MGMT_OP_SET_DEVICE_FLAGS,
+ 	MGMT_OP_READ_ADV_MONITOR_FEATURES,
+ 	MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
+ 	MGMT_OP_REMOVE_ADV_MONITOR,
++>>>>>>> bd2fbc6cb815 (Bluetooth: Add handler of MGMT_OP_REMOVE_ADV_MONITOR)
  };
  
  static const u16 mgmt_events[] = {
@@@ -3623,43 -4035,123 +3638,76 @@@ static int set_blocked_keys(struct soc
  
  	BT_DBG("request for %s", hdev->name);
  
 -	if (len <= sizeof(*cp) || cp->pattern_count == 0) {
 -		err = mgmt_cmd_status(sk, hdev->id,
 -				      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
 -				      MGMT_STATUS_INVALID_PARAMS);
 -		goto failed;
 +	key_count = __le16_to_cpu(keys->key_count);
 +	if (key_count > max_key_count) {
 +		bt_dev_err(hdev, "too big key_count value %u", key_count);
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				       MGMT_STATUS_INVALID_PARAMS);
  	}
  
 -	m = kmalloc(sizeof(*m), GFP_KERNEL);
 -	if (!m) {
 -		err = -ENOMEM;
 -		goto failed;
 +	expected_len = struct_size(keys, keys, key_count);
 +	if (expected_len != len) {
 +		bt_dev_err(hdev, "expected %u bytes, got %u bytes",
 +			   expected_len, len);
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				       MGMT_STATUS_INVALID_PARAMS);
  	}
  
 -	INIT_LIST_HEAD(&m->patterns);
 -	m->active = false;
 +	hci_dev_lock(hdev);
  
 -	for (i = 0; i < cp->pattern_count; i++) {
 -		if (++mp_cnt > HCI_MAX_ADV_MONITOR_NUM_PATTERNS) {
 -			err = mgmt_cmd_status(sk, hdev->id,
 -					      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
 -					      MGMT_STATUS_INVALID_PARAMS);
 -			goto failed;
 -		}
 +	hci_blocked_keys_clear(hdev);
  
 -		cp_ofst = cp->patterns[i].offset;
 -		cp_len = cp->patterns[i].length;
 -		if (cp_ofst >= HCI_MAX_AD_LENGTH ||
 -		    cp_len > HCI_MAX_AD_LENGTH ||
 -		    (cp_ofst + cp_len) > HCI_MAX_AD_LENGTH) {
 -			err = mgmt_cmd_status(sk, hdev->id,
 -					      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
 -					      MGMT_STATUS_INVALID_PARAMS);
 -			goto failed;
 -		}
 +	for (i = 0; i < keys->key_count; ++i) {
 +		struct blocked_key *b = kzalloc(sizeof(*b), GFP_KERNEL);
  
 -		p = kmalloc(sizeof(*p), GFP_KERNEL);
 -		if (!p) {
 -			err = -ENOMEM;
 -			goto failed;
 +		if (!b) {
 +			err = MGMT_STATUS_NO_RESOURCES;
 +			break;
  		}
  
 -		p->ad_type = cp->patterns[i].ad_type;
 -		p->offset = cp->patterns[i].offset;
 -		p->length = cp->patterns[i].length;
 -		memcpy(p->value, cp->patterns[i].value, p->length);
 -
 -		INIT_LIST_HEAD(&p->list);
 -		list_add(&p->list, &m->patterns);
 -	}
 -
 -	if (mp_cnt != cp->pattern_count) {
 -		err = mgmt_cmd_status(sk, hdev->id,
 -				      MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
 -				      MGMT_STATUS_INVALID_PARAMS);
 -		goto failed;
 -	}
 -
 -	hci_dev_lock(hdev);
 -
 -	err = hci_add_adv_monitor(hdev, m);
 -	if (err) {
 -		if (err == -ENOSPC) {
 -			mgmt_cmd_status(sk, hdev->id,
 -					MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
 -					MGMT_STATUS_NO_RESOURCES);
 -		}
 -		goto unlock;
 +		b->type = keys->keys[i].type;
 +		memcpy(b->val, keys->keys[i].val, sizeof(b->val));
 +		list_add_rcu(&b->list, &hdev->blocked_keys);
  	}
 -
  	hci_dev_unlock(hdev);
  
 -	rp.monitor_handle = cpu_to_le16(m->handle);
 -
 -	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_ADD_ADV_PATTERNS_MONITOR,
 -				 MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
 -
 -unlock:
 -	hci_dev_unlock(hdev);
 -
 -failed:
 -	hci_free_adv_monitor(m);
 -	return err;
 +	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				err, NULL, 0);
  }
  
+ static int remove_adv_monitor(struct sock *sk, struct hci_dev *hdev,
+ 			      void *data, u16 len)
+ {
+ 	struct mgmt_cp_remove_adv_monitor *cp = data;
+ 	struct mgmt_rp_remove_adv_monitor rp;
+ 	u16 handle;
+ 	int err;
+ 
+ 	BT_DBG("request for %s", hdev->name);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	handle = __le16_to_cpu(cp->monitor_handle);
+ 
+ 	err = hci_remove_adv_monitor(hdev, handle);
+ 	if (err == -ENOENT) {
+ 		err = mgmt_cmd_status(sk, hdev->id, MGMT_OP_REMOVE_ADV_MONITOR,
+ 				      MGMT_STATUS_INVALID_INDEX);
+ 		goto unlock;
+ 	}
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	rp.monitor_handle = cp->monitor_handle;
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_REMOVE_ADV_MONITOR,
+ 				 MGMT_STATUS_SUCCESS, &rp, sizeof(rp));
+ 
+ unlock:
+ 	hci_dev_unlock(hdev);
+ 	return err;
+ }
+ 
  static void read_local_oob_data_complete(struct hci_dev *hdev, u8 status,
  				         u16 opcode, struct sk_buff *skb)
  {
@@@ -7101,6 -7602,28 +7149,31 @@@ static const struct hci_mgmt_handler mg
  	{ set_blocked_keys,	   MGMT_OP_SET_BLOCKED_KEYS_SIZE,
  						HCI_MGMT_VAR_LEN },
  	{ set_wideband_speech,	   MGMT_SETTING_SIZE },
++<<<<<<< HEAD
++=======
+ 	{ read_security_info,      MGMT_READ_SECURITY_INFO_SIZE,
+ 						HCI_MGMT_UNTRUSTED },
+ 	{ read_exp_features_info,  MGMT_READ_EXP_FEATURES_INFO_SIZE,
+ 						HCI_MGMT_UNTRUSTED |
+ 						HCI_MGMT_HDEV_OPTIONAL },
+ 	{ set_exp_feature,         MGMT_SET_EXP_FEATURE_SIZE,
+ 						HCI_MGMT_VAR_LEN |
+ 						HCI_MGMT_HDEV_OPTIONAL },
+ 	{ read_def_system_config,  MGMT_READ_DEF_SYSTEM_CONFIG_SIZE,
+ 						HCI_MGMT_UNTRUSTED },
+ 	{ set_def_system_config,   MGMT_SET_DEF_SYSTEM_CONFIG_SIZE,
+ 						HCI_MGMT_VAR_LEN },
+ 	{ read_def_runtime_config, MGMT_READ_DEF_RUNTIME_CONFIG_SIZE,
+ 						HCI_MGMT_UNTRUSTED },
+ 	{ set_def_runtime_config,  MGMT_SET_DEF_RUNTIME_CONFIG_SIZE,
+ 						HCI_MGMT_VAR_LEN },
+ 	{ get_device_flags,        MGMT_GET_DEVICE_FLAGS_SIZE },
+ 	{ set_device_flags,        MGMT_SET_DEVICE_FLAGS_SIZE },
+ 	{ read_adv_mon_features,   MGMT_READ_ADV_MONITOR_FEATURES_SIZE },
+ 	{ add_adv_patterns_monitor,MGMT_ADD_ADV_PATTERNS_MONITOR_SIZE,
+ 						HCI_MGMT_VAR_LEN },
+ 	{ remove_adv_monitor,      MGMT_REMOVE_ADV_MONITOR_SIZE },
++>>>>>>> bd2fbc6cb815 (Bluetooth: Add handler of MGMT_OP_REMOVE_ADV_MONITOR)
  };
  
  void mgmt_index_added(struct hci_dev *hdev)
* Unmerged path include/net/bluetooth/hci_core.h
* Unmerged path net/bluetooth/hci_core.c
* Unmerged path net/bluetooth/mgmt.c
