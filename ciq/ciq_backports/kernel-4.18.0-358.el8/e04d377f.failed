net: bridge: mcast: use the proper multicast context when dumping router ports

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit e04d377ff6ce915d2d95ba13e7aff3ca64d50781
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/e04d377f.failed

When we are dumping the router ports of a vlan mcast context we need to
use the bridge/vlan and port/vlan's multicast contexts to check if
IPv4/IPv6 router port is present and later to dump the vlan id.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit e04d377ff6ce915d2d95ba13e7aff3ca64d50781)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_mdb.c
diff --cc net/bridge/br_mdb.c
index 5621f5510fd4,7c16e2c76220..000000000000
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@@ -16,23 -16,73 +16,89 @@@
  
  #include "br_private.h"
  
++<<<<<<< HEAD
 +static int br_rports_fill_info(struct sk_buff *skb, struct netlink_callback *cb,
 +			       struct net_device *dev)
 +{
 +	struct net_bridge *br = netdev_priv(dev);
++=======
+ static bool br_rports_have_mc_router(const struct net_bridge_mcast *brmctx)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	return !hlist_empty(&brmctx->ip4_mc_router_list) ||
+ 	       !hlist_empty(&brmctx->ip6_mc_router_list);
+ #else
+ 	return !hlist_empty(&brmctx->ip4_mc_router_list);
+ #endif
+ }
+ 
+ static bool
+ br_ip4_rports_get_timer(struct net_bridge_mcast_port *pmctx,
+ 			unsigned long *timer)
+ {
+ 	*timer = br_timer_value(&pmctx->ip4_mc_router_timer);
+ 	return !hlist_unhashed(&pmctx->ip4_rlist);
+ }
+ 
+ static bool
+ br_ip6_rports_get_timer(struct net_bridge_mcast_port *pmctx,
+ 			unsigned long *timer)
+ {
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	*timer = br_timer_value(&pmctx->ip6_mc_router_timer);
+ 	return !hlist_unhashed(&pmctx->ip6_rlist);
+ #else
+ 	*timer = 0;
+ 	return false;
+ #endif
+ }
+ 
+ static int br_rports_fill_info(struct sk_buff *skb,
+ 			       const struct net_bridge_mcast *brmctx)
+ {
+ 	u16 vid = brmctx->vlan ? brmctx->vlan->vid : 0;
+ 	bool have_ip4_mc_rtr, have_ip6_mc_rtr;
+ 	unsigned long ip4_timer, ip6_timer;
+ 	struct nlattr *nest, *port_nest;
++>>>>>>> e04d377ff6ce (net: bridge: mcast: use the proper multicast context when dumping router ports)
  	struct net_bridge_port *p;
 +	struct nlattr *nest, *port_nest;
  
++<<<<<<< HEAD
 +	if (!br->multicast_router || hlist_empty(&br->router_list))
++=======
+ 	if (!brmctx->multicast_router || !br_rports_have_mc_router(brmctx))
++>>>>>>> e04d377ff6ce (net: bridge: mcast: use the proper multicast context when dumping router ports)
  		return 0;
  
  	nest = nla_nest_start_noflag(skb, MDBA_ROUTER);
  	if (nest == NULL)
  		return -EMSGSIZE;
  
++<<<<<<< HEAD
 +	hlist_for_each_entry_rcu(p, &br->router_list, rlist) {
 +		if (!p)
++=======
+ 	list_for_each_entry_rcu(p, &brmctx->br->port_list, list) {
+ 		struct net_bridge_mcast_port *pmctx;
+ 
+ 		if (vid) {
+ 			struct net_bridge_vlan *v;
+ 
+ 			v = br_vlan_find(nbp_vlan_group(p), vid);
+ 			if (!v)
+ 				continue;
+ 			pmctx = &v->port_mcast_ctx;
+ 		} else {
+ 			pmctx = &p->multicast_ctx;
+ 		}
+ 
+ 		have_ip4_mc_rtr = br_ip4_rports_get_timer(pmctx, &ip4_timer);
+ 		have_ip6_mc_rtr = br_ip6_rports_get_timer(pmctx, &ip6_timer);
+ 
+ 		if (!have_ip4_mc_rtr && !have_ip6_mc_rtr)
++>>>>>>> e04d377ff6ce (net: bridge: mcast: use the proper multicast context when dumping router ports)
  			continue;
 -
  		port_nest = nla_nest_start_noflag(skb, MDBA_ROUTER_PORT);
  		if (!port_nest)
  			goto fail;
* Unmerged path net/bridge/br_mdb.c
