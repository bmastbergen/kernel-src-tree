iommu: remove DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Robin Murphy <robin.murphy@arm.com>
commit a250c23f15c21c556becd4986f453255e545807c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/a250c23f.failed

Instead make the global iommu_dma_strict paramete in iommu.c canonical by
exporting helpers to get and set it and use those directly in the drivers.

This make sure that the iommu.strict parameter also works for the AMD and
Intel IOMMU drivers on x86.  As those default to lazy flushing a new
IOMMU_CMD_LINE_STRICT is used to turn the value into a tristate to
represent the default if not overriden by an explicit parameter.

[ported on top of the other iommu_attr changes and added a few small
 missing bits]

	Signed-off-by: Robin Murphy <robin.murphy@arm.com>.
	Signed-off-by: Christoph Hellwig <hch@lst.de>
Link: https://lore.kernel.org/r/20210401155256.298656-19-hch@lst.de
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit a250c23f15c21c556becd4986f453255e545807c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
#	drivers/iommu/intel/iommu.c
#	include/linux/iommu.h
diff --cc drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
index e2826471dbec,7fe45838298c..000000000000
--- a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
+++ b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
@@@ -2549,76 -2549,18 +2549,91 @@@ static struct iommu_group *arm_smmu_dev
  	return group;
  }
  
++<<<<<<< HEAD
 +static int arm_smmu_domain_get_attr(struct iommu_domain *domain,
 +				    enum iommu_attr attr, void *data)
 +{
 +	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);
 +
 +	switch (domain->type) {
 +	case IOMMU_DOMAIN_UNMANAGED:
 +		switch (attr) {
 +		case DOMAIN_ATTR_NESTING:
 +			*(int *)data = (smmu_domain->stage == ARM_SMMU_DOMAIN_NESTED);
 +			return 0;
 +		default:
 +			return -ENODEV;
 +		}
 +		break;
 +	case IOMMU_DOMAIN_DMA:
 +		switch (attr) {
 +		case DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE:
 +			*(int *)data = smmu_domain->non_strict;
 +			return 0;
 +		default:
 +			return -ENODEV;
 +		}
 +		break;
 +	default:
 +		return -EINVAL;
 +	}
 +}
 +
 +static int arm_smmu_domain_set_attr(struct iommu_domain *domain,
 +				    enum iommu_attr attr, void *data)
 +{
 +	int ret = 0;
 +	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);
 +
 +	mutex_lock(&smmu_domain->init_mutex);
 +
 +	switch (domain->type) {
 +	case IOMMU_DOMAIN_UNMANAGED:
 +		switch (attr) {
 +		case DOMAIN_ATTR_NESTING:
 +			if (smmu_domain->smmu) {
 +				ret = -EPERM;
 +				goto out_unlock;
 +			}
 +
 +			if (*(int *)data)
 +				smmu_domain->stage = ARM_SMMU_DOMAIN_NESTED;
 +			else
 +				smmu_domain->stage = ARM_SMMU_DOMAIN_S1;
 +			break;
 +		default:
 +			ret = -ENODEV;
 +		}
 +		break;
 +	case IOMMU_DOMAIN_DMA:
 +		switch(attr) {
 +		case DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE:
 +			smmu_domain->non_strict = *(int *)data;
 +			break;
 +		default:
 +			ret = -ENODEV;
 +		}
 +		break;
 +	default:
 +		ret = -EINVAL;
 +	}
 +
 +out_unlock:
 +	mutex_unlock(&smmu_domain->init_mutex);
++=======
+ static int arm_smmu_enable_nesting(struct iommu_domain *domain)
+ {
+ 	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);
+ 	int ret = 0;
+ 
+ 	mutex_lock(&smmu_domain->init_mutex);
+ 	if (smmu_domain->smmu)
+ 		ret = -EPERM;
+ 	else
+ 		smmu_domain->stage = ARM_SMMU_DOMAIN_NESTED;
+ 	mutex_unlock(&smmu_domain->init_mutex);
+ 
++>>>>>>> a250c23f15c2 (iommu: remove DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE)
  	return ret;
  }
  
@@@ -2719,8 -2661,7 +2734,12 @@@ static struct iommu_ops arm_smmu_ops = 
  	.probe_device		= arm_smmu_probe_device,
  	.release_device		= arm_smmu_release_device,
  	.device_group		= arm_smmu_device_group,
++<<<<<<< HEAD
 +	.domain_get_attr	= arm_smmu_domain_get_attr,
 +	.domain_set_attr	= arm_smmu_domain_set_attr,
++=======
+ 	.enable_nesting		= arm_smmu_enable_nesting,
++>>>>>>> a250c23f15c2 (iommu: remove DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE)
  	.of_xlate		= arm_smmu_of_xlate,
  	.get_resv_regions	= arm_smmu_get_resv_regions,
  	.put_resv_regions	= generic_iommu_put_resv_regions,
diff --cc drivers/iommu/intel/iommu.c
index d07794adf618,1db4d8934526..000000000000
--- a/drivers/iommu/intel/iommu.c
+++ b/drivers/iommu/intel/iommu.c
@@@ -5513,8 -5497,7 +5474,12 @@@ const struct iommu_ops intel_iommu_ops 
  	.capable		= intel_iommu_capable,
  	.domain_alloc		= intel_iommu_domain_alloc,
  	.domain_free		= intel_iommu_domain_free,
++<<<<<<< HEAD
 +	.domain_get_attr        = intel_iommu_domain_get_attr,
 +	.domain_set_attr	= intel_iommu_domain_set_attr,
++=======
+ 	.enable_nesting		= intel_iommu_enable_nesting,
++>>>>>>> a250c23f15c2 (iommu: remove DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE)
  	.attach_dev		= intel_iommu_attach_device,
  	.detach_dev		= intel_iommu_detach_device,
  	.aux_attach_dev		= intel_iommu_aux_attach_device,
diff --cc include/linux/iommu.h
index 486407c90575,9349bdd62e91..000000000000
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@@ -123,17 -107,7 +123,20 @@@ enum iommu_cap 
   */
  
  enum iommu_attr {
++<<<<<<< HEAD
 +	DOMAIN_ATTR_GEOMETRY,
 +	DOMAIN_ATTR_PAGING,
 +	DOMAIN_ATTR_WINDOWS,
 +	DOMAIN_ATTR_FSL_PAMU_STASH,
 +	DOMAIN_ATTR_FSL_PAMU_ENABLE,
 +	DOMAIN_ATTR_FSL_PAMUV1,
 +	DOMAIN_ATTR_NESTING,	/* two stages of translation */
 +	DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE,
 +#ifndef __GENKSYMS__
++=======
++>>>>>>> a250c23f15c2 (iommu: remove DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE)
  	DOMAIN_ATTR_IO_PGTABLE_CFG,
 +#endif
  	DOMAIN_ATTR_MAX,
  };
  
@@@ -558,12 -511,11 +561,15 @@@ extern int iommu_domain_get_attr(struc
  				 void *data);
  extern int iommu_domain_set_attr(struct iommu_domain *domain, enum iommu_attr,
  				 void *data);
 -int iommu_enable_nesting(struct iommu_domain *domain);
 +
 +/* Window handling function prototypes */
 +extern int iommu_domain_window_enable(struct iommu_domain *domain, u32 wnd_nr,
 +				      phys_addr_t offset, u64 size,
 +				      int prot);
  
+ void iommu_set_dma_strict(bool val);
+ bool iommu_get_dma_strict(struct iommu_domain *domain);
+ 
  extern int report_iommu_fault(struct iommu_domain *domain, struct device *dev,
  			      unsigned long iova, int flags);
  
diff --git a/drivers/iommu/amd/iommu.c b/drivers/iommu/amd/iommu.c
index b6edea60a424..1bd020e94745 100644
--- a/drivers/iommu/amd/iommu.c
+++ b/drivers/iommu/amd/iommu.c
@@ -1738,26 +1738,6 @@ static struct iommu_group *amd_iommu_device_group(struct device *dev)
 	return acpihid_device_group(dev);
 }
 
-static int amd_iommu_domain_get_attr(struct iommu_domain *domain,
-		enum iommu_attr attr, void *data)
-{
-	switch (domain->type) {
-	case IOMMU_DOMAIN_UNMANAGED:
-		return -ENODEV;
-	case IOMMU_DOMAIN_DMA:
-		switch (attr) {
-		case DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE:
-			*(int *)data = !amd_iommu_unmap_flush;
-			return 0;
-		default:
-			return -ENODEV;
-		}
-		break;
-	default:
-		return -EINVAL;
-	}
-}
-
 /*****************************************************************************
  *
  * The next functions belong to the dma_ops mapping/unmapping code.
@@ -1822,7 +1802,7 @@ int __init amd_iommu_init_dma_ops(void)
 		pr_info("IO/TLB flush on unmap enabled\n");
 	else
 		pr_info("Lazy IO/TLB flushing enabled\n");
-
+	iommu_set_dma_strict(amd_iommu_unmap_flush);
 	return 0;
 
 }
@@ -2220,7 +2200,6 @@ const struct iommu_ops amd_iommu_ops = {
 	.release_device = amd_iommu_release_device,
 	.probe_finalize = amd_iommu_probe_finalize,
 	.device_group = amd_iommu_device_group,
-	.domain_get_attr = amd_iommu_domain_get_attr,
 	.get_resv_regions = amd_iommu_get_resv_regions,
 	.put_resv_regions = generic_iommu_put_resv_regions,
 	.is_attach_deferred = amd_iommu_is_attach_deferred,
* Unmerged path drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
diff --git a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h
index 7281347b56cb..46e8c49214a8 100644
--- a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h
+++ b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h
@@ -675,7 +675,6 @@ struct arm_smmu_domain {
 	struct mutex			init_mutex; /* Protects smmu pointer */
 
 	struct io_pgtable_ops		*pgtbl_ops;
-	bool				non_strict;
 	atomic_t			nr_ats_masters;
 
 	enum arm_smmu_domain_stage	stage;
diff --git a/drivers/iommu/arm/arm-smmu/arm-smmu.c b/drivers/iommu/arm/arm-smmu/arm-smmu.c
index 3c3c49fd26d8..df848eb4d107 100644
--- a/drivers/iommu/arm/arm-smmu/arm-smmu.c
+++ b/drivers/iommu/arm/arm-smmu/arm-smmu.c
@@ -769,6 +769,9 @@ static int arm_smmu_init_domain_context(struct iommu_domain *domain,
 		.iommu_dev	= smmu->dev,
 	};
 
+	if (!iommu_get_dma_strict(domain))
+		pgtbl_cfg.quirks |= IO_PGTABLE_QUIRK_NON_STRICT;
+
 	if (smmu->impl && smmu->impl->init_context) {
 		ret = smmu->impl->init_context(smmu_domain, &pgtbl_cfg, dev);
 		if (ret)
@@ -1501,18 +1504,6 @@ static int arm_smmu_domain_get_attr(struct iommu_domain *domain,
 			return -ENODEV;
 		}
 		break;
-	case IOMMU_DOMAIN_DMA:
-		switch (attr) {
-		case DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE: {
-			bool non_strict = smmu_domain->pgtbl_cfg.quirks &
-					  IO_PGTABLE_QUIRK_NON_STRICT;
-			*(int *)data = non_strict;
-			return 0;
-		}
-		default:
-			return -ENODEV;
-		}
-		break;
 	default:
 		return -EINVAL;
 	}
@@ -1555,18 +1546,6 @@ static int arm_smmu_domain_set_attr(struct iommu_domain *domain,
 			ret = -ENODEV;
 		}
 		break;
-	case IOMMU_DOMAIN_DMA:
-		switch (attr) {
-		case DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE:
-			if (*(int *)data)
-				smmu_domain->pgtbl_cfg.quirks |= IO_PGTABLE_QUIRK_NON_STRICT;
-			else
-				smmu_domain->pgtbl_cfg.quirks &= ~IO_PGTABLE_QUIRK_NON_STRICT;
-			break;
-		default:
-			ret = -ENODEV;
-		}
-		break;
 	default:
 		ret = -EINVAL;
 	}
diff --git a/drivers/iommu/dma-iommu.c b/drivers/iommu/dma-iommu.c
index b1c8bfe6f2ab..4d15f18fa88e 100644
--- a/drivers/iommu/dma-iommu.c
+++ b/drivers/iommu/dma-iommu.c
@@ -318,10 +318,7 @@ static void iommu_dma_flush_iotlb_all(struct iova_domain *iovad)
 
 	cookie = container_of(iovad, struct iommu_dma_cookie, iovad);
 	domain = cookie->fq_domain;
-	/*
-	 * The IOMMU driver supporting DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE
-	 * implies that ops->flush_iotlb_all must be non-NULL.
-	 */
+
 	domain->ops->flush_iotlb_all(domain);
 }
 
@@ -348,7 +345,6 @@ static int iommu_dma_init_domain(struct iommu_domain *domain, dma_addr_t base,
 	struct iommu_dma_cookie *cookie = domain->iova_cookie;
 	unsigned long order, base_pfn;
 	struct iova_domain *iovad;
-	int attr;
 
 	if (!cookie || cookie->type != IOMMU_DMA_IOVA_COOKIE)
 		return -EINVAL;
@@ -385,8 +381,7 @@ static int iommu_dma_init_domain(struct iommu_domain *domain, dma_addr_t base,
 	init_iova_domain(iovad, 1UL << order, base_pfn);
 
 	if (!cookie->fq_domain && (!dev || !dev_is_untrusted(dev)) &&
-	    !iommu_domain_get_attr(domain, DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE, &attr) &&
-	    attr) {
+	    domain->ops->flush_iotlb_all && !iommu_get_dma_strict(domain)) {
 		if (init_iova_flush_queue(iovad, iommu_dma_flush_iotlb_all,
 					  iommu_dma_entry_dtor))
 			pr_warn("iova flush queue initialization failed\n");
* Unmerged path drivers/iommu/intel/iommu.c
diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c
index 3393cee7f54d..c3c209ee9998 100644
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@ -83,6 +83,7 @@ static const char * const iommu_group_resv_type_string[] = {
 };
 
 #define IOMMU_CMD_LINE_DMA_API		BIT(0)
+#define IOMMU_CMD_LINE_STRICT		BIT(1)
 
 static void iommu_set_cmd_line_dma_api(void)
 {
@@ -343,10 +344,29 @@ early_param("iommu.passthrough", iommu_set_def_domain_type);
 
 static int __init iommu_dma_setup(char *str)
 {
-	return kstrtobool(str, &iommu_dma_strict);
+	int ret = kstrtobool(str, &iommu_dma_strict);
+
+	if (!ret)
+		iommu_cmd_line |= IOMMU_CMD_LINE_STRICT;
+	return ret;
 }
 early_param("iommu.strict", iommu_dma_setup);
 
+void iommu_set_dma_strict(bool strict)
+{
+	if (strict || !(iommu_cmd_line & IOMMU_CMD_LINE_STRICT))
+		iommu_dma_strict = strict;
+}
+
+bool iommu_get_dma_strict(struct iommu_domain *domain)
+{
+	/* only allow lazy flushing for DMA domains */
+	if (domain->type == IOMMU_DOMAIN_DMA)
+		return iommu_dma_strict;
+	return true;
+}
+EXPORT_SYMBOL_GPL(iommu_get_dma_strict);
+
 static ssize_t iommu_group_attr_show(struct kobject *kobj,
 				     struct attribute *__attr, char *buf)
 {
@@ -1512,14 +1532,6 @@ static int iommu_group_alloc_default_domain(struct bus_type *bus,
 	group->default_domain = dom;
 	if (!group->domain)
 		group->domain = dom;
-
-	if (!iommu_dma_strict) {
-		int attr = 1;
-		iommu_domain_set_attr(dom,
-				      DOMAIN_ATTR_DMA_USE_FLUSH_QUEUE,
-				      &attr);
-	}
-
 	return 0;
 }
 
* Unmerged path include/linux/iommu.h
