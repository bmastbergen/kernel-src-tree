net: bridge: vlan: add support for mcast igmp/mld version global options

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit df271cd641f101decaa4f7c1dd5c62939900bd4c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/df271cd6.failed

Add support to change and retrieve global vlan IGMP/MLD versions.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit df271cd641f101decaa4f7c1dd5c62939900bd4c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/uapi/linux/if_bridge.h
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
#	net/bridge/br_sysfs_br.c
#	net/bridge/br_vlan_options.c
diff --cc include/uapi/linux/if_bridge.h
index d643fa57361d,5188b9f6da28..000000000000
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@@ -491,6 -548,9 +491,12 @@@ enum 
  	BRIDGE_VLANDB_GOPTS_UNSPEC,
  	BRIDGE_VLANDB_GOPTS_ID,
  	BRIDGE_VLANDB_GOPTS_RANGE,
++<<<<<<< HEAD
++=======
+ 	BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION,
+ 	BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION,
++>>>>>>> df271cd641f1 (net: bridge: vlan: add support for mcast igmp/mld version global options)
  	__BRIDGE_VLANDB_GOPTS_MAX
  };
  #define BRIDGE_VLANDB_GOPTS_MAX (__BRIDGE_VLANDB_GOPTS_MAX - 1)
diff --cc net/bridge/br_multicast.c
index def6f1840985,643b69d767f7..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -3170,9 -4339,9 +3171,15 @@@ int br_multicast_set_igmp_version(struc
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	spin_lock_bh(&br->multicast_lock);
 +	br->multicast_igmp_version = val;
 +	spin_unlock_bh(&br->multicast_lock);
++=======
+ 	spin_lock_bh(&brmctx->br->multicast_lock);
+ 	brmctx->multicast_igmp_version = val;
+ 	spin_unlock_bh(&brmctx->br->multicast_lock);
++>>>>>>> df271cd641f1 (net: bridge: vlan: add support for mcast igmp/mld version global options)
  
  	return 0;
  }
@@@ -3189,9 -4359,9 +3197,15 @@@ int br_multicast_set_mld_version(struc
  		return -EINVAL;
  	}
  
++<<<<<<< HEAD
 +	spin_lock_bh(&br->multicast_lock);
 +	br->multicast_mld_version = val;
 +	spin_unlock_bh(&br->multicast_lock);
++=======
+ 	spin_lock_bh(&brmctx->br->multicast_lock);
+ 	brmctx->multicast_mld_version = val;
+ 	spin_unlock_bh(&brmctx->br->multicast_lock);
++>>>>>>> df271cd641f1 (net: bridge: vlan: add support for mcast igmp/mld version global options)
  
  	return 0;
  }
diff --cc net/bridge/br_private.h
index 30e07225bc94,b0b1e1aa4db4..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -729,16 -874,20 +729,18 @@@ void br_multicast_leave_snoopers(struc
  void br_multicast_open(struct net_bridge *br);
  void br_multicast_stop(struct net_bridge *br);
  void br_multicast_dev_del(struct net_bridge *br);
 -void br_multicast_flood(struct net_bridge_mdb_entry *mdst, struct sk_buff *skb,
 -			struct net_bridge_mcast *brmctx,
 -			bool local_rcv, bool local_orig);
 +void br_multicast_flood(struct net_bridge_mdb_entry *mdst,
 +			struct sk_buff *skb, bool local_rcv, bool local_orig);
  int br_multicast_set_router(struct net_bridge *br, unsigned long val);
  int br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val);
 -int br_multicast_toggle(struct net_bridge *br, unsigned long val,
 -			struct netlink_ext_ack *extack);
 +int br_multicast_toggle(struct net_bridge *br, unsigned long val);
  int br_multicast_set_querier(struct net_bridge *br, unsigned long val);
  int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
- int br_multicast_set_igmp_version(struct net_bridge *br, unsigned long val);
+ int br_multicast_set_igmp_version(struct net_bridge_mcast *brmctx,
+ 				  unsigned long val);
  #if IS_ENABLED(CONFIG_IPV6)
- int br_multicast_set_mld_version(struct net_bridge *br, unsigned long val);
+ int br_multicast_set_mld_version(struct net_bridge_mcast *brmctx,
+ 				 unsigned long val);
  #endif
  struct net_bridge_mdb_entry *
  br_mdb_ip_get(struct net_bridge *br, struct br_ip *dst);
@@@ -822,21 -1094,96 +824,34 @@@ static inline int br_multicast_igmp_typ
  	return BR_INPUT_SKB_CB(skb)->igmp;
  }
  
 -static inline unsigned long br_multicast_lmqt(const struct net_bridge_mcast *brmctx)
 +static inline unsigned long br_multicast_lmqt(const struct net_bridge *br)
  {
 -	return brmctx->multicast_last_member_interval *
 -	       brmctx->multicast_last_member_count;
 +	return br->multicast_last_member_interval *
 +	       br->multicast_last_member_count;
  }
  
 -static inline unsigned long br_multicast_gmi(const struct net_bridge_mcast *brmctx)
 +static inline unsigned long br_multicast_gmi(const struct net_bridge *br)
  {
  	/* use the RFC default of 2 for QRV */
 -	return 2 * brmctx->multicast_query_interval +
 -	       brmctx->multicast_query_response_interval;
 -}
 -
 -static inline bool
 -br_multicast_ctx_is_vlan(const struct net_bridge_mcast *brmctx)
 -{
 -	return !!brmctx->vlan;
 -}
 -
 -static inline bool
 -br_multicast_port_ctx_is_vlan(const struct net_bridge_mcast_port *pmctx)
 -{
 -	return !!pmctx->vlan;
 -}
 -
 -static inline struct net_bridge_mcast *
 -br_multicast_port_ctx_get_global(const struct net_bridge_mcast_port *pmctx)
 -{
 -	if (!br_multicast_port_ctx_is_vlan(pmctx))
 -		return &pmctx->port->br->multicast_ctx;
 -	else
 -		return &pmctx->vlan->brvlan->br_mcast_ctx;
 -}
 -
 -static inline bool
 -br_multicast_ctx_vlan_global_disabled(const struct net_bridge_mcast *brmctx)
 -{
 -	return br_opt_get(brmctx->br, BROPT_MCAST_VLAN_SNOOPING_ENABLED) &&
 -	       br_multicast_ctx_is_vlan(brmctx) &&
 -	       !(brmctx->vlan->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED);
 -}
 -
 -static inline bool
 -br_multicast_ctx_vlan_disabled(const struct net_bridge_mcast *brmctx)
 -{
 -	return br_multicast_ctx_is_vlan(brmctx) &&
 -	       !(brmctx->vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED);
 -}
 -
 -static inline bool
 -br_multicast_port_ctx_vlan_disabled(const struct net_bridge_mcast_port *pmctx)
 -{
 -	return br_multicast_port_ctx_is_vlan(pmctx) &&
 -	       !(pmctx->vlan->priv_flags & BR_VLFLAG_MCAST_ENABLED);
 -}
 -
 -static inline bool
 -br_multicast_port_ctx_state_disabled(const struct net_bridge_mcast_port *pmctx)
 -{
 -	return pmctx->port->state == BR_STATE_DISABLED ||
 -	       (br_multicast_port_ctx_is_vlan(pmctx) &&
 -		(br_multicast_port_ctx_vlan_disabled(pmctx) ||
 -		 pmctx->vlan->state == BR_STATE_DISABLED));
 -}
 -
 -static inline bool
 -br_multicast_port_ctx_state_stopped(const struct net_bridge_mcast_port *pmctx)
 -{
 -	return br_multicast_port_ctx_state_disabled(pmctx) ||
 -	       pmctx->port->state == BR_STATE_BLOCKING ||
 -	       (br_multicast_port_ctx_is_vlan(pmctx) &&
 -		pmctx->vlan->state == BR_STATE_BLOCKING);
 +	return 2 * br->multicast_query_interval +
 +	       br->multicast_query_response_interval;
  }
+ 
+ static inline bool
+ br_multicast_ctx_options_equal(const struct net_bridge_mcast *brmctx1,
+ 			       const struct net_bridge_mcast *brmctx2)
+ {
+ 	return brmctx1->multicast_igmp_version ==
+ 	       brmctx2->multicast_igmp_version &&
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	       brmctx1->multicast_mld_version ==
+ 	       brmctx2->multicast_mld_version &&
+ #endif
+ 	       true;
+ }
  #else
 -static inline int br_multicast_rcv(struct net_bridge_mcast **brmctx,
 -				   struct net_bridge_mcast_port **pmctx,
 -				   struct net_bridge_vlan *vlan,
 +static inline int br_multicast_rcv(struct net_bridge *br,
 +				   struct net_bridge_port *port,
  				   struct sk_buff *skb,
  				   u16 vid)
  {
@@@ -946,6 -1294,64 +961,67 @@@ static inline int br_multicast_igmp_typ
  {
  	return 0;
  }
++<<<<<<< HEAD
++=======
+ 
+ static inline void br_multicast_ctx_init(struct net_bridge *br,
+ 					 struct net_bridge_vlan *vlan,
+ 					 struct net_bridge_mcast *brmctx)
+ {
+ }
+ 
+ static inline void br_multicast_ctx_deinit(struct net_bridge_mcast *brmctx)
+ {
+ }
+ 
+ static inline void br_multicast_port_ctx_init(struct net_bridge_port *port,
+ 					      struct net_bridge_vlan *vlan,
+ 					      struct net_bridge_mcast_port *pmctx)
+ {
+ }
+ 
+ static inline void br_multicast_port_ctx_deinit(struct net_bridge_mcast_port *pmctx)
+ {
+ }
+ 
+ static inline void br_multicast_toggle_one_vlan(struct net_bridge_vlan *vlan,
+ 						bool on)
+ {
+ }
+ 
+ static inline void br_multicast_toggle_vlan(struct net_bridge_vlan *vlan,
+ 					    bool on)
+ {
+ }
+ 
+ static inline int br_multicast_toggle_vlan_snooping(struct net_bridge *br,
+ 						    bool on,
+ 						    struct netlink_ext_ack *extack)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline bool br_multicast_toggle_global_vlan(struct net_bridge_vlan *vlan,
+ 						   bool on)
+ {
+ 	return false;
+ }
+ 
+ static inline int br_mdb_replay(struct net_device *br_dev,
+ 				struct net_device *dev, const void *ctx,
+ 				bool adding, struct notifier_block *nb,
+ 				struct netlink_ext_ack *extack)
+ {
+ 	return -EOPNOTSUPP;
+ }
+ 
+ static inline bool
+ br_multicast_ctx_options_equal(const struct net_bridge_mcast *brmctx1,
+ 			       const struct net_bridge_mcast *brmctx2)
+ {
+ 	return true;
+ }
++>>>>>>> df271cd641f1 (net: bridge: vlan: add support for mcast igmp/mld version global options)
  #endif
  
  /* br_vlan.c */
diff --cc net/bridge/br_sysfs_br.c
index 52b9892eb49f,08e31debd6f2..000000000000
--- a/net/bridge/br_sysfs_br.c
+++ b/net/bridge/br_sysfs_br.c
@@@ -449,7 -514,13 +449,17 @@@ static ssize_t multicast_igmp_version_s
  {
  	struct net_bridge *br = to_bridge(d);
  
++<<<<<<< HEAD
 +	return sprintf(buf, "%u\n", br->multicast_igmp_version);
++=======
+ 	return sprintf(buf, "%u\n", br->multicast_ctx.multicast_igmp_version);
+ }
+ 
+ static int set_multicast_igmp_version(struct net_bridge *br, unsigned long val,
+ 				      struct netlink_ext_ack *extack)
+ {
+ 	return br_multicast_set_igmp_version(&br->multicast_ctx, val);
++>>>>>>> df271cd641f1 (net: bridge: vlan: add support for mcast igmp/mld version global options)
  }
  
  static ssize_t multicast_igmp_version_store(struct device *d,
@@@ -671,7 -751,13 +681,17 @@@ static ssize_t multicast_mld_version_sh
  {
  	struct net_bridge *br = to_bridge(d);
  
++<<<<<<< HEAD
 +	return sprintf(buf, "%u\n", br->multicast_mld_version);
++=======
+ 	return sprintf(buf, "%u\n", br->multicast_ctx.multicast_mld_version);
+ }
+ 
+ static int set_multicast_mld_version(struct net_bridge *br, unsigned long val,
+ 				     struct netlink_ext_ack *extack)
+ {
+ 	return br_multicast_set_mld_version(&br->multicast_ctx, val);
++>>>>>>> df271cd641f1 (net: bridge: vlan: add support for mcast igmp/mld version global options)
  }
  
  static ssize_t multicast_mld_version_store(struct device *d,
diff --cc net/bridge/br_vlan_options.c
index 827bfc319599,ac32fb40b7ba..000000000000
--- a/net/bridge/br_vlan_options.c
+++ b/net/bridge/br_vlan_options.c
@@@ -262,7 -262,11 +262,15 @@@ int br_vlan_process_options(const struc
  bool br_vlan_global_opts_can_enter_range(const struct net_bridge_vlan *v_curr,
  					 const struct net_bridge_vlan *r_end)
  {
++<<<<<<< HEAD
 +	return v_curr->vid - r_end->vid == 1;
++=======
+ 	return v_curr->vid - r_end->vid == 1 &&
+ 	       ((v_curr->priv_flags ^ r_end->priv_flags) &
+ 		BR_VLFLAG_GLOBAL_MCAST_ENABLED) == 0 &&
+ 		br_multicast_ctx_options_equal(&v_curr->br_mcast_ctx,
+ 					       &r_end->br_mcast_ctx);
++>>>>>>> df271cd641f1 (net: bridge: vlan: add support for mcast igmp/mld version global options)
  }
  
  bool br_vlan_global_opts_fill(struct sk_buff *skb, u16 vid, u16 vid_range,
@@@ -281,6 -285,20 +289,23 @@@
  	    nla_put_u16(skb, BRIDGE_VLANDB_GOPTS_RANGE, vid_range))
  		goto out_err;
  
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	if (nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING,
+ 		       !!(v_opts->priv_flags & BR_VLFLAG_GLOBAL_MCAST_ENABLED)) ||
+ 	    nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION,
+ 		       v_opts->br_mcast_ctx.multicast_igmp_version))
+ 		goto out_err;
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (nla_put_u8(skb, BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION,
+ 		       v_opts->br_mcast_ctx.multicast_mld_version))
+ 		goto out_err;
+ #endif
+ #endif
+ 
++>>>>>>> df271cd641f1 (net: bridge: vlan: add support for mcast igmp/mld version global options)
  	nla_nest_end(skb, nest);
  
  	return true;
@@@ -295,6 -313,11 +320,14 @@@ static size_t rtnl_vlan_global_opts_nlm
  	return NLMSG_ALIGN(sizeof(struct br_vlan_msg))
  		+ nla_total_size(0) /* BRIDGE_VLANDB_GLOBAL_OPTIONS */
  		+ nla_total_size(sizeof(u16)) /* BRIDGE_VLANDB_GOPTS_ID */
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION */
+ 		+ nla_total_size(sizeof(u8)) /* BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION */
+ #endif
++>>>>>>> df271cd641f1 (net: bridge: vlan: add support for mcast igmp/mld version global options)
  		+ nla_total_size(sizeof(u16)); /* BRIDGE_VLANDB_GOPTS_RANGE */
  }
  
@@@ -348,13 -371,48 +381,54 @@@ static int br_vlan_process_global_one_o
  					   bool *changed,
  					   struct netlink_ext_ack *extack)
  {
+ 	int err __maybe_unused;
+ 
  	*changed = false;
++<<<<<<< HEAD
++=======
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]) {
+ 		u8 mc_snooping;
+ 
+ 		mc_snooping = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]);
+ 		if (br_multicast_toggle_global_vlan(v, !!mc_snooping))
+ 			*changed = true;
+ 	}
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]) {
+ 		u8 ver;
+ 
+ 		ver = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]);
+ 		err = br_multicast_set_igmp_version(&v->br_mcast_ctx, ver);
+ 		if (err)
+ 			return err;
+ 		*changed = true;
+ 	}
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	if (tb[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]) {
+ 		u8 ver;
+ 
+ 		ver = nla_get_u8(tb[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]);
+ 		err = br_multicast_set_mld_version(&v->br_mcast_ctx, ver);
+ 		if (err)
+ 			return err;
+ 		*changed = true;
+ 	}
+ #endif
+ #endif
+ 
++>>>>>>> df271cd641f1 (net: bridge: vlan: add support for mcast igmp/mld version global options)
  	return 0;
  }
  
  static const struct nla_policy br_vlan_db_gpol[BRIDGE_VLANDB_GOPTS_MAX + 1] = {
  	[BRIDGE_VLANDB_GOPTS_ID]	= { .type = NLA_U16 },
  	[BRIDGE_VLANDB_GOPTS_RANGE]	= { .type = NLA_U16 },
++<<<<<<< HEAD
++=======
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_SNOOPING]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_MLD_VERSION]	= { .type = NLA_U8 },
+ 	[BRIDGE_VLANDB_GOPTS_MCAST_IGMP_VERSION]	= { .type = NLA_U8 },
++>>>>>>> df271cd641f1 (net: bridge: vlan: add support for mcast igmp/mld version global options)
  };
  
  int br_vlan_rtm_process_global_options(struct net_device *dev,
* Unmerged path include/uapi/linux/if_bridge.h
* Unmerged path net/bridge/br_multicast.c
diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c
index 75be8311a010..8962d689d546 100644
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@ -1344,7 +1344,8 @@ static int br_changelink(struct net_device *brdev, struct nlattr *tb[],
 		__u8 igmp_version;
 
 		igmp_version = nla_get_u8(data[IFLA_BR_MCAST_IGMP_VERSION]);
-		err = br_multicast_set_igmp_version(br, igmp_version);
+		err = br_multicast_set_igmp_version(&br->multicast_ctx,
+						    igmp_version);
 		if (err)
 			return err;
 	}
@@ -1354,7 +1355,8 @@ static int br_changelink(struct net_device *brdev, struct nlattr *tb[],
 		__u8 mld_version;
 
 		mld_version = nla_get_u8(data[IFLA_BR_MCAST_MLD_VERSION]);
-		err = br_multicast_set_mld_version(br, mld_version);
+		err = br_multicast_set_mld_version(&br->multicast_ctx,
+						   mld_version);
 		if (err)
 			return err;
 	}
* Unmerged path net/bridge/br_private.h
* Unmerged path net/bridge/br_sysfs_br.c
* Unmerged path net/bridge/br_vlan_options.c
