printk: kmsg_dump: remove _nolock() variants

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author John Ogness <john.ogness@linutronix.de>
commit a4f987653241db9fa1f99531b430cebb83f1eae1
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/a4f98765.failed

kmsg_dump_rewind() and kmsg_dump_get_line() are lockless, so there is
no need for _nolock() variants. Remove these functions and switch all
callers of the _nolock() variants.

The functions without _nolock() were chosen because they are already
exported to kernel modules.

	Signed-off-by: John Ogness <john.ogness@linutronix.de>
	Reviewed-by: Petr Mladek <pmladek@suse.com>
	Signed-off-by: Petr Mladek <pmladek@suse.com>
Link: https://lore.kernel.org/r/20210303101528.29901-15-john.ogness@linutronix.de
(cherry picked from commit a4f987653241db9fa1f99531b430cebb83f1eae1)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/xmon/xmon.c
#	include/linux/kmsg_dump.h
#	kernel/debug/kdb/kdb_main.c
#	kernel/printk/printk.c
diff --cc arch/powerpc/xmon/xmon.c
index feb327dbc17f,dd0e0aac954e..000000000000
--- a/arch/powerpc/xmon/xmon.c
+++ b/arch/powerpc/xmon/xmon.c
@@@ -2962,9 -3017,9 +2962,15 @@@ dump_log_buf(void
  	catch_memory_errors = 1;
  	sync();
  
++<<<<<<< HEAD
 +	kmsg_dump_rewind_nolock(&dumper);
 +	xmon_start_pagination();
 +	while (kmsg_dump_get_line_nolock(&dumper, false, buf, sizeof(buf), &len)) {
++=======
+ 	kmsg_dump_rewind(&iter);
+ 	xmon_start_pagination();
+ 	while (kmsg_dump_get_line(&iter, false, buf, sizeof(buf), &len)) {
++>>>>>>> a4f987653241 (printk: kmsg_dump: remove _nolock() variants)
  		buf[len] = '\0';
  		printf("%s", buf);
  	}
diff --cc include/linux/kmsg_dump.h
index b833daa05587,906521c2329c..000000000000
--- a/include/linux/kmsg_dump.h
+++ b/include/linux/kmsg_dump.h
@@@ -56,18 -57,13 +56,26 @@@ struct kmsg_dumper 
  #ifdef CONFIG_PRINTK
  void kmsg_dump(enum kmsg_dump_reason reason);
  
++<<<<<<< HEAD
 +bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,
 +			       char *line, size_t size, size_t *len);
 +
 +bool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,
++=======
+ bool kmsg_dump_get_line(struct kmsg_dump_iter *iter, bool syslog,
++>>>>>>> a4f987653241 (printk: kmsg_dump: remove _nolock() variants)
  			char *line, size_t size, size_t *len);
  
 -bool kmsg_dump_get_buffer(struct kmsg_dump_iter *iter, bool syslog,
 -			  char *buf, size_t size, size_t *len_out);
 +bool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,
 +			  char *buf, size_t size, size_t *len);
 +
++<<<<<<< HEAD
 +void kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper);
  
 +void kmsg_dump_rewind(struct kmsg_dumper *dumper);
++=======
+ void kmsg_dump_rewind(struct kmsg_dump_iter *iter);
++>>>>>>> a4f987653241 (printk: kmsg_dump: remove _nolock() variants)
  
  int kmsg_dump_register(struct kmsg_dumper *dumper);
  
@@@ -77,14 -75,7 +85,18 @@@ static inline void kmsg_dump(enum kmsg_
  {
  }
  
++<<<<<<< HEAD
 +static inline bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper,
 +					     bool syslog, const char *line,
 +					     size_t size, size_t *len)
 +{
 +	return false;
 +}
 +
 +static inline bool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,
++=======
+ static inline bool kmsg_dump_get_line(struct kmsg_dump_iter *iter, bool syslog,
++>>>>>>> a4f987653241 (printk: kmsg_dump: remove _nolock() variants)
  				const char *line, size_t size, size_t *len)
  {
  	return false;
@@@ -96,11 -87,7 +108,15 @@@ static inline bool kmsg_dump_get_buffer
  	return false;
  }
  
++<<<<<<< HEAD
 +static inline void kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)
 +{
 +}
 +
 +static inline void kmsg_dump_rewind(struct kmsg_dumper *dumper)
++=======
+ static inline void kmsg_dump_rewind(struct kmsg_dump_iter *iter)
++>>>>>>> a4f987653241 (printk: kmsg_dump: remove _nolock() variants)
  {
  }
  
diff --cc kernel/debug/kdb/kdb_main.c
index f3aee10cce6f,67d9f2403b52..000000000000
--- a/kernel/debug/kdb/kdb_main.c
+++ b/kernel/debug/kdb/kdb_main.c
@@@ -2113,8 -2126,8 +2113,13 @@@ static int kdb_dmesg(int argc, const ch
  		kdb_set(2, setargs);
  	}
  
++<<<<<<< HEAD
 +	kmsg_dump_rewind_nolock(&dumper);
 +	while (kmsg_dump_get_line_nolock(&dumper, 1, NULL, 0, NULL))
++=======
+ 	kmsg_dump_rewind(&iter);
+ 	while (kmsg_dump_get_line(&iter, 1, NULL, 0, NULL))
++>>>>>>> a4f987653241 (printk: kmsg_dump: remove _nolock() variants)
  		n++;
  
  	if (lines < 0) {
@@@ -2146,8 -2159,8 +2151,13 @@@
  	if (skip >= n || skip < 0)
  		return 0;
  
++<<<<<<< HEAD
 +	kmsg_dump_rewind_nolock(&dumper);
 +	while (kmsg_dump_get_line_nolock(&dumper, 1, buf, sizeof(buf), &len)) {
++=======
+ 	kmsg_dump_rewind(&iter);
+ 	while (kmsg_dump_get_line(&iter, 1, buf, sizeof(buf), &len)) {
++>>>>>>> a4f987653241 (printk: kmsg_dump: remove _nolock() variants)
  		if (skip) {
  			skip--;
  			continue;
diff --cc kernel/printk/printk.c
index 9c33249065a6,602de86d4e76..000000000000
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@@ -3210,8 -3373,8 +3210,13 @@@ void kmsg_dump(enum kmsg_dump_reason re
  }
  
  /**
++<<<<<<< HEAD
 + * kmsg_dump_get_line_nolock - retrieve one kmsg log line (unlocked version)
 + * @dumper: registered kmsg dumper
++=======
+  * kmsg_dump_get_line - retrieve one kmsg log line
+  * @iter: kmsg dump iterator
++>>>>>>> a4f987653241 (printk: kmsg_dump: remove _nolock() variants)
   * @syslog: include the "<4>" prefixes
   * @line: buffer to copy the line to
   * @size: maximum size of the buffer
@@@ -3225,70 -3388,47 +3230,104 @@@
   *
   * A return value of FALSE indicates that there are no more records to
   * read.
-  *
-  * The function is similar to kmsg_dump_get_line(), but grabs no locks.
   */
++<<<<<<< HEAD
 +bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,
 +			       char *line, size_t size, size_t *len)
 +{
 +	struct printk_log *msg;
 +	size_t l = 0;
 +	bool ret = false;
 +
 +	if (!dumper->active)
 +		goto out;
++=======
+ bool kmsg_dump_get_line(struct kmsg_dump_iter *iter, bool syslog,
+ 			char *line, size_t size, size_t *len)
+ {
+ 	u64 min_seq = latched_seq_read_nolock(&clear_seq);
+ 	struct printk_info info;
+ 	unsigned int line_count;
+ 	struct printk_record r;
+ 	unsigned long flags;
+ 	size_t l = 0;
+ 	bool ret = false;
+ 
+ 	if (iter->cur_seq < min_seq)
+ 		iter->cur_seq = min_seq;
+ 
+ 	printk_safe_enter_irqsave(flags);
+ 	prb_rec_init_rd(&r, &info, line, size);
+ 
+ 	/* Read text or count text lines? */
+ 	if (line) {
+ 		if (!prb_read_valid(prb, iter->cur_seq, &r))
+ 			goto out;
+ 		l = record_print_text(&r, syslog, printk_time);
+ 	} else {
+ 		if (!prb_read_valid_info(prb, iter->cur_seq,
+ 					 &info, &line_count)) {
+ 			goto out;
+ 		}
+ 		l = get_record_print_text_size(&info, line_count, syslog,
+ 					       printk_time);
++>>>>>>> a4f987653241 (printk: kmsg_dump: remove _nolock() variants)
  
 +	if (dumper->cur_seq < log_first_seq) {
 +		/* messages are gone, move to first available one */
 +		dumper->cur_seq = log_first_seq;
 +		dumper->cur_idx = log_first_idx;
  	}
  
 -	iter->cur_seq = r.info->seq + 1;
 +	/* last entry */
 +	if (dumper->cur_seq >= log_next_seq)
 +		goto out;
 +
 +	msg = log_from_idx(dumper->cur_idx);
 +	l = msg_print_text(msg, syslog, printk_time, line, size);
 +
 +	dumper->cur_idx = log_next(dumper->cur_idx);
 +	dumper->cur_seq++;
  	ret = true;
  out:
+ 	printk_safe_exit_irqrestore(flags);
  	if (len)
  		*len = l;
  	return ret;
  }
++<<<<<<< HEAD
 +
 +/**
 + * kmsg_dump_get_line - retrieve one kmsg log line
 + * @dumper: registered kmsg dumper
 + * @syslog: include the "<4>" prefixes
 + * @line: buffer to copy the line to
 + * @size: maximum size of the buffer
 + * @len: length of line placed into buffer
 + *
 + * Start at the beginning of the kmsg buffer, with the oldest kmsg
 + * record, and copy one record into the provided buffer.
 + *
 + * Consecutive calls will return the next available record moving
 + * towards the end of the buffer with the youngest messages.
 + *
 + * A return value of FALSE indicates that there are no more records to
 + * read.
 + */
 +bool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,
 +			char *line, size_t size, size_t *len)
 +{
 +	unsigned long flags;
 +	bool ret;
 +
 +	logbuf_lock_irqsave(flags);
 +	ret = kmsg_dump_get_line_nolock(dumper, syslog, line, size, len);
 +	logbuf_unlock_irqrestore(flags);
 +
 +	return ret;
 +}
++=======
++>>>>>>> a4f987653241 (printk: kmsg_dump: remove _nolock() variants)
  EXPORT_SYMBOL_GPL(kmsg_dump_get_line);
  
  /**
@@@ -3385,26 -3522,8 +3424,29 @@@ out
  EXPORT_SYMBOL_GPL(kmsg_dump_get_buffer);
  
  /**
++<<<<<<< HEAD
 + * kmsg_dump_rewind_nolock - reset the iterator (unlocked version)
 + * @dumper: registered kmsg dumper
 + *
 + * Reset the dumper's iterator so that kmsg_dump_get_line() and
 + * kmsg_dump_get_buffer() can be called again and used multiple
 + * times within the same dumper.dump() callback.
 + *
 + * The function is similar to kmsg_dump_rewind(), but grabs no locks.
 + */
 +void kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)
 +{
 +	dumper->cur_seq = clear_seq;
 +	dumper->cur_idx = clear_idx;
 +	dumper->next_seq = log_next_seq;
 +	dumper->next_idx = log_next_idx;
 +}
 +
 +/**
++=======
++>>>>>>> a4f987653241 (printk: kmsg_dump: remove _nolock() variants)
   * kmsg_dump_rewind - reset the iterator
 - * @iter: kmsg dump iterator
 + * @dumper: registered kmsg dumper
   *
   * Reset the dumper's iterator so that kmsg_dump_get_line() and
   * kmsg_dump_get_buffer() can be called again and used multiple
@@@ -3414,9 -3533,10 +3456,16 @@@ void kmsg_dump_rewind(struct kmsg_dumpe
  {
  	unsigned long flags;
  
++<<<<<<< HEAD
 +	logbuf_lock_irqsave(flags);
 +	kmsg_dump_rewind_nolock(dumper);
 +	logbuf_unlock_irqrestore(flags);
++=======
+ 	printk_safe_enter_irqsave(flags);
+ 	iter->cur_seq = latched_seq_read_nolock(&clear_seq);
+ 	iter->next_seq = prb_next_seq(prb);
+ 	printk_safe_exit_irqrestore(flags);
++>>>>>>> a4f987653241 (printk: kmsg_dump: remove _nolock() variants)
  }
  EXPORT_SYMBOL_GPL(kmsg_dump_rewind);
  
* Unmerged path arch/powerpc/xmon/xmon.c
* Unmerged path include/linux/kmsg_dump.h
* Unmerged path kernel/debug/kdb/kdb_main.c
* Unmerged path kernel/printk/printk.c
