driver core: Add fwnode link support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Saravana Kannan <saravanak@google.com>
commit 7b337cb3ebde384cba7405b61dfb84200bf623bf
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/7b337cb3.failed

Add support for creating supplier-consumer links between fwnodes.  It is
intended for internal use the driver core and generic firmware support
code (eg. Device Tree, ACPI), so it is simple by design and the API
provided is limited.

	Acked-by: Rob Herring <robh@kernel.org>
	Signed-off-by: Saravana Kannan <saravanak@google.com>
Link: https://lore.kernel.org/r/20201121020232.908850-9-saravanak@google.com
	Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
(cherry picked from commit 7b337cb3ebde384cba7405b61dfb84200bf623bf)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/base/core.c
#	include/linux/fwnode.h
diff --cc drivers/base/core.c
index c73bf3cdd933,972d42dedfc8..000000000000
--- a/drivers/base/core.c
+++ b/drivers/base/core.c
@@@ -49,10 -50,104 +49,111 @@@ static LIST_HEAD(wait_for_suppliers)
  static DEFINE_MUTEX(wfs_lock);
  static LIST_HEAD(deferred_sync);
  static unsigned int defer_sync_state_count = 1;
++<<<<<<< HEAD
 +static unsigned int defer_fw_devlink_count;
 +static LIST_HEAD(deferred_fw_devlink);
 +static DEFINE_MUTEX(defer_fw_devlink_lock);
 +static bool fw_devlink_is_permissive(void);
++=======
+ static DEFINE_MUTEX(fwnode_link_lock);
+ 
+ /**
+  * fwnode_link_add - Create a link between two fwnode_handles.
+  * @con: Consumer end of the link.
+  * @sup: Supplier end of the link.
+  *
+  * Create a fwnode link between fwnode handles @con and @sup. The fwnode link
+  * represents the detail that the firmware lists @sup fwnode as supplying a
+  * resource to @con.
+  *
+  * The driver core will use the fwnode link to create a device link between the
+  * two device objects corresponding to @con and @sup when they are created. The
+  * driver core will automatically delete the fwnode link between @con and @sup
+  * after doing that.
+  *
+  * Attempts to create duplicate links between the same pair of fwnode handles
+  * are ignored and there is no reference counting.
+  */
+ int fwnode_link_add(struct fwnode_handle *con, struct fwnode_handle *sup)
+ {
+ 	struct fwnode_link *link;
+ 	int ret = 0;
+ 
+ 	mutex_lock(&fwnode_link_lock);
+ 
+ 	list_for_each_entry(link, &sup->consumers, s_hook)
+ 		if (link->consumer == con)
+ 			goto out;
+ 
+ 	link = kzalloc(sizeof(*link), GFP_KERNEL);
+ 	if (!link) {
+ 		ret = -ENOMEM;
+ 		goto out;
+ 	}
+ 
+ 	link->supplier = sup;
+ 	INIT_LIST_HEAD(&link->s_hook);
+ 	link->consumer = con;
+ 	INIT_LIST_HEAD(&link->c_hook);
+ 
+ 	list_add(&link->s_hook, &sup->consumers);
+ 	list_add(&link->c_hook, &con->suppliers);
+ out:
+ 	mutex_unlock(&fwnode_link_lock);
+ 
+ 	return ret;
+ }
+ 
+ /**
+  * fwnode_links_purge_suppliers - Delete all supplier links of fwnode_handle.
+  * @fwnode: fwnode whose supplier links need to be deleted
+  *
+  * Deletes all supplier links connecting directly to @fwnode.
+  */
+ static void fwnode_links_purge_suppliers(struct fwnode_handle *fwnode)
+ {
+ 	struct fwnode_link *link, *tmp;
+ 
+ 	mutex_lock(&fwnode_link_lock);
+ 	list_for_each_entry_safe(link, tmp, &fwnode->suppliers, c_hook) {
+ 		list_del(&link->s_hook);
+ 		list_del(&link->c_hook);
+ 		kfree(link);
+ 	}
+ 	mutex_unlock(&fwnode_link_lock);
+ }
+ 
+ /**
+  * fwnode_links_purge_consumers - Delete all consumer links of fwnode_handle.
+  * @fwnode: fwnode whose consumer links need to be deleted
+  *
+  * Deletes all consumer links connecting directly to @fwnode.
+  */
+ static void fwnode_links_purge_consumers(struct fwnode_handle *fwnode)
+ {
+ 	struct fwnode_link *link, *tmp;
+ 
+ 	mutex_lock(&fwnode_link_lock);
+ 	list_for_each_entry_safe(link, tmp, &fwnode->consumers, s_hook) {
+ 		list_del(&link->s_hook);
+ 		list_del(&link->c_hook);
+ 		kfree(link);
+ 	}
+ 	mutex_unlock(&fwnode_link_lock);
+ }
+ 
+ /**
+  * fwnode_links_purge - Delete all links connected to a fwnode_handle.
+  * @fwnode: fwnode whose links needs to be deleted
+  *
+  * Deletes all links connecting directly to a fwnode.
+  */
+ void fwnode_links_purge(struct fwnode_handle *fwnode)
+ {
+ 	fwnode_links_purge_suppliers(fwnode);
+ 	fwnode_links_purge_consumers(fwnode);
+ }
++>>>>>>> 7b337cb3ebde (driver core: Add fwnode link support)
  
  #ifdef CONFIG_SRCU
  static DEFINE_MUTEX(device_links_lock);
diff --cc include/linux/fwnode.h
index e1e5a96e9010,b88365187347..000000000000
--- a/include/linux/fwnode.h
+++ b/include/linux/fwnode.h
@@@ -13,7 -10,7 +13,11 @@@
  #define _LINUX_FWNODE_H_
  
  #include <linux/types.h>
++<<<<<<< HEAD
 +#include <linux/rh_kabi.h>
++=======
+ #include <linux/list.h>
++>>>>>>> 7b337cb3ebde (driver core: Add fwnode link support)
  
  struct fwnode_operations;
  struct device;
@@@ -21,7 -18,16 +25,20 @@@
  struct fwnode_handle {
  	struct fwnode_handle *secondary;
  	const struct fwnode_operations *ops;
++<<<<<<< HEAD
 +	RH_KABI_EXTEND(struct device *dev)
++=======
+ 	struct device *dev;
+ 	struct list_head suppliers;
+ 	struct list_head consumers;
+ };
+ 
+ struct fwnode_link {
+ 	struct fwnode_handle *supplier;
+ 	struct list_head s_hook;
+ 	struct fwnode_handle *consumer;
+ 	struct list_head c_hook;
++>>>>>>> 7b337cb3ebde (driver core: Add fwnode link support)
  };
  
  /**
@@@ -181,7 -189,7 +200,12 @@@ static inline void fwnode_init(struct f
  }
  
  extern u32 fw_devlink_get_flags(void);
++<<<<<<< HEAD
 +void fw_devlink_pause(void);
 +void fw_devlink_resume(void);
++=======
+ int fwnode_link_add(struct fwnode_handle *con, struct fwnode_handle *sup);
+ void fwnode_links_purge(struct fwnode_handle *fwnode);
++>>>>>>> 7b337cb3ebde (driver core: Add fwnode link support)
  
  #endif
* Unmerged path drivers/base/core.c
diff --git a/drivers/of/dynamic.c b/drivers/of/dynamic.c
index a09c1c3cf831..239f10aa8899 100644
--- a/drivers/of/dynamic.c
+++ b/drivers/of/dynamic.c
@@ -360,6 +360,7 @@ void of_node_release(struct kobject *kobj)
 
 	property_list_free(node->properties);
 	property_list_free(node->deadprops);
+	fwnode_links_purge(of_fwnode_handle(node));
 
 	kfree(node->full_name);
 	kfree(node->data);
* Unmerged path include/linux/fwnode.h
