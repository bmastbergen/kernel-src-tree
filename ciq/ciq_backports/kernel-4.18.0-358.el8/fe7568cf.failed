PCI/VPD: Treat invalid VPD like missing VPD capability

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Heiner Kallweit <hkallweit1@gmail.com>
commit fe7568cf2f2dc3a0783f6ffdb3802c1ce2085466
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/fe7568cf.failed

Exporting sysfs files that can't be accessed doesn't make much sense.
Therefore, if either a quirk or the dynamic size calculation result in VPD
being marked as invalid, treat this as though the device has no VPD
capability.  One consequence is that the "vpd" sysfs file is not visible.

Link: https://lore.kernel.org/r/6a02b204-4ed2-4553-c3b2-eacf9554fa8d@gmail.com
	Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
	Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
(cherry picked from commit fe7568cf2f2dc3a0783f6ffdb3802c1ce2085466)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/pci/vpd.c
diff --cc drivers/pci/vpd.c
index 9d9cff5f89e2,3b0425fb49f5..000000000000
--- a/drivers/pci/vpd.c
+++ b/drivers/pci/vpd.c
@@@ -130,12 -124,6 +130,15 @@@ static ssize_t pci_vpd_read(struct pci_
  	if (pos < 0)
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (!vpd->len)
 +		vpd->len = pci_vpd_size(dev);
 +
 +	if (vpd->len == PCI_VPD_SZ_INVALID)
 +		return -EIO;
 +
++=======
++>>>>>>> fe7568cf2f2d (PCI/VPD: Treat invalid VPD like missing VPD capability)
  	if (pos > vpd->len)
  		return 0;
  
@@@ -197,12 -185,6 +200,15 @@@ static ssize_t pci_vpd_write(struct pci
  	if (pos < 0 || (pos & 3) || (count & 3))
  		return -EINVAL;
  
++<<<<<<< HEAD
 +	if (!vpd->len)
 +		vpd->len = pci_vpd_size(dev);
 +
 +	if (vpd->len == PCI_VPD_SZ_INVALID)
 +		return -EIO;
 +
++=======
++>>>>>>> fe7568cf2f2d (PCI/VPD: Treat invalid VPD like missing VPD capability)
  	if (end > vpd->len)
  		return -EINVAL;
  
@@@ -238,25 -220,14 +244,33 @@@
  
  void pci_vpd_init(struct pci_dev *dev)
  {
 -	dev->vpd.cap = pci_find_capability(dev, PCI_CAP_ID_VPD);
 -	mutex_init(&dev->vpd.lock);
 +	struct pci_vpd *vpd;
 +	u8 cap;
 +
++<<<<<<< HEAD
 +	cap = pci_find_capability(dev, PCI_CAP_ID_VPD);
 +	if (!cap)
 +		return;
 +
 +	vpd = kzalloc(sizeof(*vpd), GFP_ATOMIC);
 +	if (!vpd)
 +		return;
  
 +	mutex_init(&vpd->lock);
 +	vpd->cap = cap;
 +	dev->vpd = vpd;
 +}
 +
 +void pci_vpd_release(struct pci_dev *dev)
 +{
 +	kfree(dev->vpd);
++=======
+ 	if (!dev->vpd.len)
+ 		dev->vpd.len = pci_vpd_size(dev);
+ 
+ 	if (dev->vpd.len == PCI_VPD_SZ_INVALID)
+ 		dev->vpd.cap = 0;
++>>>>>>> fe7568cf2f2d (PCI/VPD: Treat invalid VPD like missing VPD capability)
  }
  
  static ssize_t vpd_read(struct file *filp, struct kobject *kobj,
* Unmerged path drivers/pci/vpd.c
