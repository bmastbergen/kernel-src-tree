mm, slub: call deactivate_slab() without disabling irqs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Vlastimil Babka <vbabka@suse.cz>
commit cfdf836e1f93df56ddd9a1d48b2deadf02f441fe
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/cfdf836e.failed

The function is now safe to be called with irqs enabled, so move the calls
outside of irq disabled sections.

When called from ___slab_alloc() -> flush_slab() we have irqs disabled, so to
reenable them before deactivate_slab() we need to open-code flush_slab() in
___slab_alloc() and reenable irqs after modifying the kmem_cache_cpu fields.
But that means a IRQ handler meanwhile might have assigned a new page to
kmem_cache_cpu.page so we have to retry the whole check.

The remaining callers of flush_slab() are the IPI handler which has disabled
irqs anyway, and slub_cpu_dead() which will be dealt with in the following
patch.

	Signed-off-by: Vlastimil Babka <vbabka@suse.cz>
(cherry picked from commit cfdf836e1f93df56ddd9a1d48b2deadf02f441fe)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/slub.c
diff --cc mm/slub.c
index ce2dfb191f83,cb12a077c61c..000000000000
--- a/mm/slub.c
+++ b/mm/slub.c
@@@ -2680,8 -2766,22 +2680,24 @@@ load_freelist
  	VM_BUG_ON(!c->page->frozen);
  	c->freelist = get_freepointer(s, freelist);
  	c->tid = next_tid(c->tid);
 -	local_irq_restore(flags);
  	return freelist;
  
++<<<<<<< HEAD
++=======
+ deactivate_slab:
+ 
+ 	local_irq_save(flags);
+ 	if (page != c->page) {
+ 		local_irq_restore(flags);
+ 		goto reread_page;
+ 	}
+ 	freelist = c->freelist;
+ 	c->page = NULL;
+ 	c->freelist = NULL;
+ 	local_irq_restore(flags);
+ 	deactivate_slab(s, page, freelist);
+ 
++>>>>>>> cfdf836e1f93 (mm, slub: call deactivate_slab() without disabling irqs)
  new_slab:
  
  	if (slub_percpu_partial(c)) {
@@@ -2739,11 -2848,32 +2755,39 @@@ check_new_page
  		 */
  		goto return_single;
  
++<<<<<<< HEAD
++=======
+ retry_load_page:
+ 
+ 	local_irq_save(flags);
+ 	if (unlikely(c->page)) {
+ 		void *flush_freelist = c->freelist;
+ 		struct page *flush_page = c->page;
+ 
+ 		c->page = NULL;
+ 		c->freelist = NULL;
+ 		c->tid = next_tid(c->tid);
+ 
+ 		local_irq_restore(flags);
+ 
+ 		deactivate_slab(s, flush_page, flush_freelist);
+ 
+ 		stat(s, CPUSLAB_FLUSH);
+ 
+ 		goto retry_load_page;
+ 	}
+ 	c->page = page;
+ 
++>>>>>>> cfdf836e1f93 (mm, slub: call deactivate_slab() without disabling irqs)
  	goto load_freelist;
  
  return_single:
  
++<<<<<<< HEAD
 +	deactivate_slab(s, page, get_freepointer(s, freelist), c);
++=======
+ 	deactivate_slab(s, page, get_freepointer(s, freelist));
++>>>>>>> cfdf836e1f93 (mm, slub: call deactivate_slab() without disabling irqs)
  	return freelist;
  }
  
* Unmerged path mm/slub.c
