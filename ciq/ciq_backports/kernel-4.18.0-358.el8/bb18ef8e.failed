net: bridge: mcast: record querier port device ifindex instead of pointer

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit bb18ef8e7e180d8590df2808ec4014af114756cb
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/bb18ef8e.failed

Currently when a querier port is detected its net_bridge_port pointer is
recorded, but it's used only for comparisons so it's fine to have stale
pointer, in order to dereference and use the port pointer a proper
accounting of its usage must be implemented adding unnecessary
complexity. To solve the problem we can just store the netdevice ifindex
instead of the port pointer and retrieve the bridge port. It is a best
effort and the device needs to be validated that is still part of that
bridge before use, but that is small price to pay for avoiding querier
reference counting for each port/vlan.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit bb18ef8e7e180d8590df2808ec4014af114756cb)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
diff --cc net/bridge/br_multicast.c
index def6f1840985,853b947edf87..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -2087,10 -2847,11 +2087,15 @@@ static bool br_ip4_multicast_select_que
  	return false;
  
  update:
 -	brmctx->ip4_querier.addr.src.ip4 = saddr;
 +	br->ip4_querier.addr.src.ip4 = saddr;
  
  	/* update protected by general multicast_lock by caller */
++<<<<<<< HEAD
 +	rcu_assign_pointer(br->ip4_querier.port, port);
++=======
+ 	if (port)
+ 		brmctx->ip4_querier.port_ifidx = port->dev->ifindex;
++>>>>>>> bb18ef8e7e18 (net: bridge: mcast: record querier port device ifindex instead of pointer)
  
  	return true;
  }
@@@ -2110,10 -2873,11 +2115,15 @@@ static bool br_ip6_multicast_select_que
  	return false;
  
  update:
 -	brmctx->ip6_querier.addr.src.ip6 = *saddr;
 +	br->ip6_querier.addr.src.ip6 = *saddr;
  
  	/* update protected by general multicast_lock by caller */
++<<<<<<< HEAD
 +	rcu_assign_pointer(br->ip6_querier.port, port);
++=======
+ 	if (port)
+ 		brmctx->ip6_querier.port_ifidx = port->dev->ifindex;
++>>>>>>> bb18ef8e7e18 (net: bridge: mcast: record querier port device ifindex instead of pointer)
  
  	return true;
  }
@@@ -2756,13 -3670,17 +2766,20 @@@ static void br_multicast_query_expired(
  				       struct bridge_mcast_own_query *query,
  				       struct bridge_mcast_querier *querier)
  {
 -	spin_lock(&brmctx->br->multicast_lock);
 -	if (br_multicast_ctx_vlan_disabled(brmctx))
 -		goto out;
 -
 -	if (query->startup_sent < brmctx->multicast_startup_query_count)
 +	spin_lock(&br->multicast_lock);
 +	if (query->startup_sent < br->multicast_startup_query_count)
  		query->startup_sent++;
  
++<<<<<<< HEAD
 +	RCU_INIT_POINTER(querier->port, NULL);
 +	br_multicast_send_query(br, NULL, query);
 +	spin_unlock(&br->multicast_lock);
++=======
+ 	querier->port_ifidx = 0;
+ 	br_multicast_send_query(brmctx, NULL, query);
+ out:
+ 	spin_unlock(&brmctx->br->multicast_lock);
++>>>>>>> bb18ef8e7e18 (net: bridge: mcast: record querier port device ifindex instead of pointer)
  }
  
  static void br_ip4_multicast_query_expired(struct timer_list *t)
@@@ -2794,6 -3716,53 +2811,56 @@@ static void br_multicast_gc_work(struc
  	br_multicast_gc(&deleted_head);
  }
  
++<<<<<<< HEAD
++=======
+ void br_multicast_ctx_init(struct net_bridge *br,
+ 			   struct net_bridge_vlan *vlan,
+ 			   struct net_bridge_mcast *brmctx)
+ {
+ 	brmctx->br = br;
+ 	brmctx->vlan = vlan;
+ 	brmctx->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;
+ 	brmctx->multicast_last_member_count = 2;
+ 	brmctx->multicast_startup_query_count = 2;
+ 
+ 	brmctx->multicast_last_member_interval = HZ;
+ 	brmctx->multicast_query_response_interval = 10 * HZ;
+ 	brmctx->multicast_startup_query_interval = 125 * HZ / 4;
+ 	brmctx->multicast_query_interval = 125 * HZ;
+ 	brmctx->multicast_querier_interval = 255 * HZ;
+ 	brmctx->multicast_membership_interval = 260 * HZ;
+ 
+ 	brmctx->ip4_other_query.delay_time = 0;
+ 	brmctx->ip4_querier.port_ifidx = 0;
+ 	brmctx->multicast_igmp_version = 2;
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	brmctx->multicast_mld_version = 1;
+ 	brmctx->ip6_other_query.delay_time = 0;
+ 	brmctx->ip6_querier.port_ifidx = 0;
+ #endif
+ 
+ 	timer_setup(&brmctx->ip4_mc_router_timer,
+ 		    br_ip4_multicast_local_router_expired, 0);
+ 	timer_setup(&brmctx->ip4_other_query.timer,
+ 		    br_ip4_multicast_querier_expired, 0);
+ 	timer_setup(&brmctx->ip4_own_query.timer,
+ 		    br_ip4_multicast_query_expired, 0);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	timer_setup(&brmctx->ip6_mc_router_timer,
+ 		    br_ip6_multicast_local_router_expired, 0);
+ 	timer_setup(&brmctx->ip6_other_query.timer,
+ 		    br_ip6_multicast_querier_expired, 0);
+ 	timer_setup(&brmctx->ip6_own_query.timer,
+ 		    br_ip6_multicast_query_expired, 0);
+ #endif
+ }
+ 
+ void br_multicast_ctx_deinit(struct net_bridge_mcast *brmctx)
+ {
+ 	__br_multicast_stop(brmctx);
+ }
+ 
++>>>>>>> bb18ef8e7e18 (net: bridge: mcast: record querier port device ifindex instead of pointer)
  void br_multicast_init(struct net_bridge *br)
  {
  	br->hash_max = BR_MULTICAST_DEFAULT_HASH_MAX;
@@@ -3318,14 -4495,17 +3386,26 @@@ bool br_multicast_has_querier_adjacent(
  
  	switch (proto) {
  	case ETH_P_IP:
++<<<<<<< HEAD
 +		if (!timer_pending(&br->ip4_other_query.timer) ||
 +		    rcu_dereference(br->ip4_querier.port) == port)
++=======
+ 		port_ifidx = brmctx->ip4_querier.port_ifidx;
+ 		if (!timer_pending(&brmctx->ip4_other_query.timer) ||
+ 		    port_ifidx == port->dev->ifindex)
++>>>>>>> bb18ef8e7e18 (net: bridge: mcast: record querier port device ifindex instead of pointer)
  			goto unlock;
  		break;
  #if IS_ENABLED(CONFIG_IPV6)
  	case ETH_P_IPV6:
++<<<<<<< HEAD
 +		if (!timer_pending(&br->ip6_other_query.timer) ||
 +		    rcu_dereference(br->ip6_querier.port) == port)
++=======
+ 		port_ifidx = brmctx->ip6_querier.port_ifidx;
+ 		if (!timer_pending(&brmctx->ip6_other_query.timer) ||
+ 		    port_ifidx == port->dev->ifindex)
++>>>>>>> bb18ef8e7e18 (net: bridge: mcast: record querier port device ifindex instead of pointer)
  			goto unlock;
  		break;
  #endif
* Unmerged path net/bridge/br_multicast.c
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 30e07225bc94..a0df03692ad0 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -83,7 +83,7 @@ struct bridge_mcast_other_query {
 /* selected querier */
 struct bridge_mcast_querier {
 	struct br_ip addr;
-	struct net_bridge_port __rcu	*port;
+	int port_ifidx;
 };
 
 /* IGMP/MLD statistics */
