scsi: qla2xxx: Fix NVMe session down detection

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Quinn Tran <qutran@marvell.com>
commit 7a8ff7d9854a1727435557184c8255bbbca60920
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/7a8ff7d9.failed

When Target port transitions personality from one to another (NVMe <-->
FCP), there could be some overlap of the two where one layer is going down
while the other layer is coming up. This overlap can cause temporary I/O
error. Detect those errors/transitions and recover from them. Triggers
session tear down and allow relogin to re-drive the connection under the
following conditions:

 - NVMe command error

 - On PRLO + N2N (rida format 2)

Link: https://lore.kernel.org/r/20210817051315.2477-11-njavali@marvell.com
	Signed-off-by: Quinn Tran <qutran@marvell.com>
	Signed-off-by: Nilesh Javali <njavali@marvell.com>
	Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
(cherry picked from commit 7a8ff7d9854a1727435557184c8255bbbca60920)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/scsi/qla2xxx/qla_isr.c
diff --cc drivers/scsi/qla2xxx/qla_isr.c
index e13915491b32,ece60267b971..000000000000
--- a/drivers/scsi/qla2xxx/qla_isr.c
+++ b/drivers/scsi/qla2xxx/qla_isr.c
@@@ -2426,7 -2652,16 +2426,20 @@@ static void qla24xx_nvme_iocb_entry(scs
  	case CS_PORT_UNAVAILABLE:
  	case CS_PORT_LOGGED_OUT:
  		fcport->nvme_flag |= NVME_FLAG_RESETTING;
++<<<<<<< HEAD
 +		/* fall through */
++=======
+ 		if (atomic_read(&fcport->state) == FCS_ONLINE) {
+ 			ql_dbg(ql_dbg_disc, fcport->vha, 0x3021,
+ 			       "Port to be marked lost on fcport=%06x, current "
+ 			       "port state= %s comp_status %x.\n",
+ 			       fcport->d_id.b24, port_state_str[FCS_ONLINE],
+ 			       comp_status);
+ 
+ 			qlt_schedule_sess_for_deletion(fcport);
+ 		}
+ 		fallthrough;
++>>>>>>> 7a8ff7d9854a (scsi: qla2xxx: Fix NVMe session down detection)
  	case CS_ABORTED:
  	case CS_PORT_BUSY:
  		fd->transferred_length = 0;
diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c
index f781e4a61afe..9a1bf868157c 100644
--- a/drivers/scsi/qla2xxx/qla_attr.c
+++ b/drivers/scsi/qla2xxx/qla_attr.c
@@ -2628,12 +2628,14 @@ qla2x00_terminate_rport_io(struct fc_rport *rport)
 	 * final cleanup of firmware resources (PCBs and XCBs).
 	 */
 	if (fcport->loop_id != FC_NO_LOOP_ID) {
-		if (IS_FWI2_CAPABLE(fcport->vha->hw))
-			fcport->vha->hw->isp_ops->fabric_logout(fcport->vha,
-			    fcport->loop_id, fcport->d_id.b.domain,
-			    fcport->d_id.b.area, fcport->d_id.b.al_pa);
-		else
+		if (IS_FWI2_CAPABLE(fcport->vha->hw)) {
+			if (fcport->loop_id != FC_NO_LOOP_ID)
+				fcport->logout_on_delete = 1;
+
+			qlt_schedule_sess_for_deletion(fcport);
+		} else {
 			qla2x00_port_logout(fcport->vha, fcport);
+		}
 	}
 }
 
* Unmerged path drivers/scsi/qla2xxx/qla_isr.c
diff --git a/drivers/scsi/qla2xxx/qla_mbx.c b/drivers/scsi/qla2xxx/qla_mbx.c
index a3a82430134a..c71e97236212 100644
--- a/drivers/scsi/qla2xxx/qla_mbx.c
+++ b/drivers/scsi/qla2xxx/qla_mbx.c
@@ -4173,6 +4173,16 @@ qla24xx_report_id_acquisition(scsi_qla_host_t *vha,
 				rptid_entry->u.f2.remote_nport_id[1];
 			fcport->d_id.b.al_pa =
 				rptid_entry->u.f2.remote_nport_id[0];
+
+			/*
+			 * For the case where remote port sending PRLO, FW
+			 * sends up RIDA Format 2 as an indication of session
+			 * loss. In other word, FW state change from PRLI
+			 * complete back to PLOGI complete. Delete the
+			 * session and let relogin drive the reconnect.
+			 */
+			if (atomic_read(&fcport->state) == FCS_ONLINE)
+				qlt_schedule_sess_for_deletion(fcport);
 		}
 	}
 }
