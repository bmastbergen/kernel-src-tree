include/linux/mm_inline.h: fold page_lru_base_type() into its sole caller

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Yu Zhao <yuzhao@google.com>
commit c1770e34f3e7640887d8129fc05d13fe17101301
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/c1770e34.failed

We've removed all other references to this function.

Link: https://lore.kernel.org/linux-mm/20201207220949.830352-9-yuzhao@google.com/
Link: https://lkml.kernel.org/r/20210122220600.906146-9-yuzhao@google.com
	Signed-off-by: Yu Zhao <yuzhao@google.com>
	Reviewed-by: Alex Shi <alex.shi@linux.alibaba.com>
	Cc: Hugh Dickins <hughd@google.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Roman Gushchin <guro@fb.com>
	Cc: Vladimir Davydov <vdavydov.dev@gmail.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit c1770e34f3e7640887d8129fc05d13fe17101301)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/mm_inline.h
diff --cc include/linux/mm_inline.h
index b714bf7a0dfe,7183c7a03f09..000000000000
--- a/include/linux/mm_inline.h
+++ b/include/linux/mm_inline.h
@@@ -45,64 -45,22 +45,69 @@@ static __always_inline void update_lru_
  #endif
  }
  
 +static __always_inline void add_page_to_lru_list(struct page *page,
 +				struct lruvec *lruvec, enum lru_list lru)
 +{
 +	update_lru_size(lruvec, lru, page_zonenum(page), thp_nr_pages(page));
 +	list_add(&page->lru, &lruvec->lists[lru]);
 +}
 +
 +static __always_inline void add_page_to_lru_list_tail(struct page *page,
 +				struct lruvec *lruvec, enum lru_list lru)
 +{
 +	update_lru_size(lruvec, lru, page_zonenum(page), thp_nr_pages(page));
 +	list_add_tail(&page->lru, &lruvec->lists[lru]);
 +}
 +
 +static __always_inline void del_page_from_lru_list(struct page *page,
 +				struct lruvec *lruvec, enum lru_list lru)
 +{
 +	list_del(&page->lru);
 +	update_lru_size(lruvec, lru, page_zonenum(page), -thp_nr_pages(page));
 +}
 +
 +/**
++<<<<<<< HEAD
 + * page_lru_base_type - which LRU list type should a page be on?
 + * @page: the page to test
 + *
 + * Used for LRU list index arithmetic.
 + *
 + * Returns the base LRU type - file or anon - @page should be on.
 + */
 +static inline enum lru_list page_lru_base_type(struct page *page)
 +{
 +	if (page_is_file_lru(page))
 +		return LRU_INACTIVE_FILE;
 +	return LRU_INACTIVE_ANON;
 +}
 +
  /**
 + * page_off_lru - which LRU list was page on? clearing its lru flags.
 + * @page: the page to test
 + *
 + * Returns the LRU list a page was on, as an index into the array of LRU
 + * lists; and clears its Unevictable or Active flags, ready for freeing.
++=======
+  * __clear_page_lru_flags - clear page lru flags before releasing a page
+  * @page: the page that was on lru and now has a zero reference
++>>>>>>> c1770e34f3e7 (include/linux/mm_inline.h: fold page_lru_base_type() into its sole caller)
   */
 -static __always_inline void __clear_page_lru_flags(struct page *page)
 +static __always_inline enum lru_list page_off_lru(struct page *page)
  {
 -	VM_BUG_ON_PAGE(!PageLRU(page), page);
 -
 -	__ClearPageLRU(page);
 -
 -	/* this shouldn't happen, so leave the flags to bad_page() */
 -	if (PageActive(page) && PageUnevictable(page))
 -		return;
 +	enum lru_list lru;
  
 -	__ClearPageActive(page);
 -	__ClearPageUnevictable(page);
 +	if (PageUnevictable(page)) {
 +		__ClearPageUnevictable(page);
 +		lru = LRU_UNEVICTABLE;
 +	} else {
 +		lru = page_lru_base_type(page);
 +		if (PageActive(page)) {
 +			__ClearPageActive(page);
 +			lru += LRU_ACTIVE;
 +		}
 +	}
 +	return lru;
  }
  
  /**
@@@ -116,13 -74,15 +121,13 @@@ static __always_inline enum lru_list pa
  {
  	enum lru_list lru;
  
 -	VM_BUG_ON_PAGE(PageActive(page) && PageUnevictable(page), page);
 -
  	if (PageUnevictable(page))
- 		lru = LRU_UNEVICTABLE;
- 	else {
- 		lru = page_lru_base_type(page);
- 		if (PageActive(page))
- 			lru += LRU_ACTIVE;
- 	}
+ 		return LRU_UNEVICTABLE;
+ 
+ 	lru = page_is_file_lru(page) ? LRU_INACTIVE_FILE : LRU_INACTIVE_ANON;
+ 	if (PageActive(page))
+ 		lru += LRU_ACTIVE;
+ 
  	return lru;
  }
  
* Unmerged path include/linux/mm_inline.h
