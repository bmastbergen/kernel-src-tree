ethernet: constify references to netdev->dev_addr in drivers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Jakub Kicinski <kuba@kernel.org>
commit 766607570becbd26cab6d66a544dd8d0d964df5a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/76660757.failed

This big patch sprinkles const on local variables and
function arguments which may refer to netdev->dev_addr.

Commit 406f42fa0d3c ("net-next: When a bond have a massive amount
of VLANs...") introduced a rbtree for faster Ethernet address look
up. To maintain netdev->dev_addr in this tree we need to make all
the writes to it got through appropriate helpers.

Some of the changes here are not strictly required - const
is sometimes cast off but pointer is not used for writing.
It seems like it's still better to add the const in case
the code changes later or relevant -W flags get enabled
for the build.

No functional changes.

Link: https://lore.kernel.org/r/20211014142432.449314-1-kuba@kernel.org
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 766607570becbd26cab6d66a544dd8d0d964df5a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/net/ethernet/actions/owl-emac.c
#	drivers/net/ethernet/aquantia/atlantic/aq_macsec.c
#	drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.c
#	drivers/net/ethernet/broadcom/genet/bcmgenet.c
#	drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
#	drivers/net/ethernet/freescale/fman/fman_dtsec.c
#	drivers/net/ethernet/freescale/fman/fman_memac.c
#	drivers/net/ethernet/freescale/fman/fman_tgec.c
#	drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
#	drivers/net/ethernet/mediatek/mtk_star_emac.c
#	drivers/net/ethernet/stmicro/stmmac/stmmac_selftests.c
diff --cc drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.c
index 6b0025c418c5,1d177fed44a6..000000000000
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.c
@@@ -1119,38 -1151,9 +1119,42 @@@ void bnxt_hwrm_exec_fwd_req(struct bnx
  	}
  }
  
++<<<<<<< HEAD
 +void bnxt_update_vf_mac(struct bnxt *bp)
 +{
 +	struct hwrm_func_qcaps_input req = {0};
 +	struct hwrm_func_qcaps_output *resp = bp->hwrm_cmd_resp_addr;
 +
 +	bnxt_hwrm_cmd_hdr_init(bp, &req, HWRM_FUNC_QCAPS, -1, -1);
 +	req.fid = cpu_to_le16(0xffff);
 +
 +	mutex_lock(&bp->hwrm_cmd_lock);
 +	if (_hwrm_send_message(bp, &req, sizeof(req), HWRM_CMD_TIMEOUT))
 +		goto update_vf_mac_exit;
 +
 +	/* Store MAC address from the firmware.  There are 2 cases:
 +	 * 1. MAC address is valid.  It is assigned from the PF and we
 +	 *    need to override the current VF MAC address with it.
 +	 * 2. MAC address is zero.  The VF will use a random MAC address by
 +	 *    default but the stored zero MAC will allow the VF user to change
 +	 *    the random MAC address using ndo_set_mac_address() if he wants.
 +	 */
 +	if (!ether_addr_equal(resp->mac_address, bp->vf.mac_addr))
 +		memcpy(bp->vf.mac_addr, resp->mac_address, ETH_ALEN);
 +
 +	/* overwrite netdev dev_addr with admin VF MAC */
 +	if (is_valid_ether_addr(bp->vf.mac_addr))
 +		memcpy(bp->dev->dev_addr, bp->vf.mac_addr, ETH_ALEN);
 +update_vf_mac_exit:
 +	mutex_unlock(&bp->hwrm_cmd_lock);
 +}
 +
 +int bnxt_approve_mac(struct bnxt *bp, u8 *mac, bool strict)
++=======
+ int bnxt_approve_mac(struct bnxt *bp, const u8 *mac, bool strict)
++>>>>>>> 766607570bec (ethernet: constify references to netdev->dev_addr in drivers)
  {
 -	struct hwrm_func_vf_cfg_input *req;
 +	struct hwrm_func_vf_cfg_input req = {0};
  	int rc = 0;
  
  	if (!BNXT_VF(bp))
diff --cc drivers/net/ethernet/broadcom/genet/bcmgenet.c
index 231c7ca5d58a,ed53859b6f7d..000000000000
--- a/drivers/net/ethernet/broadcom/genet/bcmgenet.c
+++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.c
@@@ -2768,11 -3266,21 +2768,11 @@@ static void bcmgenet_umac_reset(struct 
  }
  
  static void bcmgenet_set_hw_addr(struct bcmgenet_priv *priv,
- 				 unsigned char *addr)
+ 				 const unsigned char *addr)
  {
 -	bcmgenet_umac_writel(priv, get_unaligned_be32(&addr[0]), UMAC_MAC0);
 -	bcmgenet_umac_writel(priv, get_unaligned_be16(&addr[4]), UMAC_MAC1);
 -}
 -
 -static void bcmgenet_get_hw_addr(struct bcmgenet_priv *priv,
 -				 unsigned char *addr)
 -{
 -	u32 addr_tmp;
 -
 -	addr_tmp = bcmgenet_umac_readl(priv, UMAC_MAC0);
 -	put_unaligned_be32(addr_tmp, &addr[0]);
 -	addr_tmp = bcmgenet_umac_readl(priv, UMAC_MAC1);
 -	put_unaligned_be16(addr_tmp, &addr[4]);
 +	bcmgenet_umac_writel(priv, (addr[0] << 24) | (addr[1] << 16) |
 +			(addr[2] << 8) | addr[3], UMAC_MAC0);
 +	bcmgenet_umac_writel(priv, (addr[4] << 8) | addr[5], UMAC_MAC1);
  }
  
  /* Returns a reusable dma control register value */
@@@ -3082,15 -3557,12 +3082,20 @@@ static void bcmgenet_timeout(struct net
  	netif_tx_wake_all_queues(dev);
  }
  
 -#define MAX_MDF_FILTER	17
 +#define MAX_MC_COUNT	16
  
  static inline void bcmgenet_set_mdf_addr(struct bcmgenet_priv *priv,
++<<<<<<< HEAD
 +					 unsigned char *addr,
 +					 int *i,
 +					 int *mc)
++=======
+ 					 const unsigned char *addr,
+ 					 int *i)
++>>>>>>> 766607570bec (ethernet: constify references to netdev->dev_addr in drivers)
  {
 +	u32 reg;
 +
  	bcmgenet_umac_writel(priv, addr[0] << 8 | addr[1],
  			     UMAC_MDF_ADDR + (*i * 4));
  	bcmgenet_umac_writel(priv, addr[2] << 24 | addr[3] << 16 |
diff --cc drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
index 15fe3d780457,6b2927d863e2..000000000000
--- a/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
@@@ -255,8 -266,20 +255,25 @@@ static int dpaa_netdev_init(struct net_
  	net_dev->features |= net_dev->hw_features;
  	net_dev->vlan_features = net_dev->features;
  
++<<<<<<< HEAD
 +	memcpy(net_dev->perm_addr, mac_addr, net_dev->addr_len);
 +	memcpy(net_dev->dev_addr, mac_addr, net_dev->addr_len);
++=======
+ 	if (is_valid_ether_addr(mac_addr)) {
+ 		memcpy(net_dev->perm_addr, mac_addr, net_dev->addr_len);
+ 		eth_hw_addr_set(net_dev, mac_addr);
+ 	} else {
+ 		eth_hw_addr_random(net_dev);
+ 		err = priv->mac_dev->change_addr(priv->mac_dev->fman_mac,
+ 			(const enet_addr_t *)net_dev->dev_addr);
+ 		if (err) {
+ 			dev_err(dev, "Failed to set random MAC address\n");
+ 			return -EINVAL;
+ 		}
+ 		dev_info(dev, "Using random MAC address: %pM\n",
+ 			 net_dev->dev_addr);
+ 	}
++>>>>>>> 766607570bec (ethernet: constify references to netdev->dev_addr in drivers)
  
  	net_dev->ethtool_ops = &dpaa_ethtool_ops;
  
diff --cc drivers/net/ethernet/freescale/fman/fman_dtsec.c
index 57b1e2b47c0a,1950a8936bc0..000000000000
--- a/drivers/net/ethernet/freescale/fman/fman_dtsec.c
+++ b/drivers/net/ethernet/freescale/fman/fman_dtsec.c
@@@ -364,8 -366,20 +364,23 @@@ static void set_dflts(struct dtsec_cfg 
  	cfg->maximum_frame = DEFAULT_MAXIMUM_FRAME;
  }
  
++<<<<<<< HEAD
++=======
+ static void set_mac_address(struct dtsec_regs __iomem *regs, const u8 *adr)
+ {
+ 	u32 tmp;
+ 
+ 	tmp = (u32)((adr[5] << 24) |
+ 		    (adr[4] << 16) | (adr[3] << 8) | adr[2]);
+ 	iowrite32be(tmp, &regs->macstnaddr1);
+ 
+ 	tmp = (u32)((adr[1] << 24) | (adr[0] << 16));
+ 	iowrite32be(tmp, &regs->macstnaddr2);
+ }
+ 
++>>>>>>> 766607570bec (ethernet: constify references to netdev->dev_addr in drivers)
  static int init(struct dtsec_regs __iomem *regs, struct dtsec_cfg *cfg,
 -		phy_interface_t iface, u16 iface_speed, u64 addr,
 +		phy_interface_t iface, u16 iface_speed, u8 *macaddr,
  		u32 exception_mask, u8 tbi_addr)
  {
  	bool is_rgmii, is_sgmii, is_qsgmii;
@@@ -499,12 -514,10 +514,19 @@@
  
  	iowrite32be(0xffffffff, &regs->ievent);
  
++<<<<<<< HEAD
 +	tmp = (u32)((macaddr[5] << 24) |
 +		    (macaddr[4] << 16) | (macaddr[3] << 8) | macaddr[2]);
 +	iowrite32be(tmp, &regs->macstnaddr1);
 +
 +	tmp = (u32)((macaddr[1] << 24) | (macaddr[0] << 16));
 +	iowrite32be(tmp, &regs->macstnaddr2);
++=======
+ 	if (addr) {
+ 		MAKE_ENET_ADDR_FROM_UINT64(addr, eth_addr);
+ 		set_mac_address(regs, (const u8 *)eth_addr);
+ 	}
++>>>>>>> 766607570bec (ethernet: constify references to netdev->dev_addr in drivers)
  
  	/* HASH */
  	for (i = 0; i < NUM_OF_HASH_REGS; i++) {
diff --cc drivers/net/ethernet/freescale/fman/fman_memac.c
index 446a97b792e3,2216b7f51d26..000000000000
--- a/drivers/net/ethernet/freescale/fman/fman_memac.c
+++ b/drivers/net/ethernet/freescale/fman/fman_memac.c
@@@ -1052,8 -1056,10 +1052,15 @@@ int memac_init(struct fman_mac *memac
  	}
  
  	/* MAC Address */
++<<<<<<< HEAD
 +	MAKE_ENET_ADDR_FROM_UINT64(memac->addr, eth_addr);
 +	add_addr_in_paddr(memac->regs, (u8 *)eth_addr, 0);
++=======
+ 	if (memac->addr != 0) {
+ 		MAKE_ENET_ADDR_FROM_UINT64(memac->addr, eth_addr);
+ 		add_addr_in_paddr(memac->regs, (const u8 *)eth_addr, 0);
+ 	}
++>>>>>>> 766607570bec (ethernet: constify references to netdev->dev_addr in drivers)
  
  	fixed_link = memac_drv_param->fixed_link;
  
diff --cc drivers/net/ethernet/freescale/fman/fman_tgec.c
index 284735d4ebe9,311c1906e044..000000000000
--- a/drivers/net/ethernet/freescale/fman/fman_tgec.c
+++ b/drivers/net/ethernet/freescale/fman/fman_tgec.c
@@@ -685,8 -702,10 +685,15 @@@ int tgec_init(struct fman_mac *tgec
  
  	cfg = tgec->cfg;
  
++<<<<<<< HEAD
 +	MAKE_ENET_ADDR_FROM_UINT64(tgec->addr, eth_addr);
 +	set_mac_address(tgec->regs, (u8 *)eth_addr);
++=======
+ 	if (tgec->addr) {
+ 		MAKE_ENET_ADDR_FROM_UINT64(tgec->addr, eth_addr);
+ 		set_mac_address(tgec->regs, (const u8 *)eth_addr);
+ 	}
++>>>>>>> 766607570bec (ethernet: constify references to netdev->dev_addr in drivers)
  
  	/* interrupts */
  	/* FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005 Errata workaround */
diff --cc drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
index 9dd91b956462,7bb34af3981e..000000000000
--- a/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
@@@ -4474,492 -6848,3814 +4474,540 @@@ static void hclge_get_mac_addr(struct h
  	struct hclge_vport *vport = hclge_get_vport(handle);
  	struct hclge_dev *hdev = vport->back;
  
 -	if (!hnae3_dev_fd_supported(hdev) || hclge_is_cls_flower_active(handle))
 -		return -EOPNOTSUPP;
 -
 -	cmd->rule_cnt = hdev->hclge_fd_rule_num;
 -	cmd->data = hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1];
 -
 -	return 0;
 -}
 -
 -static void hclge_fd_get_tcpip4_info(struct hclge_fd_rule *rule,
 -				     struct ethtool_tcpip4_spec *spec,
 -				     struct ethtool_tcpip4_spec *spec_mask)
 -{
 -	spec->ip4src = cpu_to_be32(rule->tuples.src_ip[IPV4_INDEX]);
 -	spec_mask->ip4src = rule->unused_tuple & BIT(INNER_SRC_IP) ?
 -			0 : cpu_to_be32(rule->tuples_mask.src_ip[IPV4_INDEX]);
 -
 -	spec->ip4dst = cpu_to_be32(rule->tuples.dst_ip[IPV4_INDEX]);
 -	spec_mask->ip4dst = rule->unused_tuple & BIT(INNER_DST_IP) ?
 -			0 : cpu_to_be32(rule->tuples_mask.dst_ip[IPV4_INDEX]);
 -
 -	spec->psrc = cpu_to_be16(rule->tuples.src_port);
 -	spec_mask->psrc = rule->unused_tuple & BIT(INNER_SRC_PORT) ?
 -			0 : cpu_to_be16(rule->tuples_mask.src_port);
 -
 -	spec->pdst = cpu_to_be16(rule->tuples.dst_port);
 -	spec_mask->pdst = rule->unused_tuple & BIT(INNER_DST_PORT) ?
 -			0 : cpu_to_be16(rule->tuples_mask.dst_port);
 -
 -	spec->tos = rule->tuples.ip_tos;
 -	spec_mask->tos = rule->unused_tuple & BIT(INNER_IP_TOS) ?
 -			0 : rule->tuples_mask.ip_tos;
 +	ether_addr_copy(p, hdev->hw.mac.mac_addr);
  }
  
 -static void hclge_fd_get_ip4_info(struct hclge_fd_rule *rule,
 -				  struct ethtool_usrip4_spec *spec,
 -				  struct ethtool_usrip4_spec *spec_mask)
++<<<<<<< HEAD
 +static int hclge_set_mac_addr(struct hnae3_handle *handle, void *p,
++=======
++int hclge_update_mac_node_for_dev_addr(struct hclge_vport *vport,
++				       const u8 *old_addr, const u8 *new_addr)
+ {
 -	spec->ip4src = cpu_to_be32(rule->tuples.src_ip[IPV4_INDEX]);
 -	spec_mask->ip4src = rule->unused_tuple & BIT(INNER_SRC_IP) ?
 -			0 : cpu_to_be32(rule->tuples_mask.src_ip[IPV4_INDEX]);
 -
 -	spec->ip4dst = cpu_to_be32(rule->tuples.dst_ip[IPV4_INDEX]);
 -	spec_mask->ip4dst = rule->unused_tuple & BIT(INNER_DST_IP) ?
 -			0 : cpu_to_be32(rule->tuples_mask.dst_ip[IPV4_INDEX]);
 -
 -	spec->tos = rule->tuples.ip_tos;
 -	spec_mask->tos = rule->unused_tuple & BIT(INNER_IP_TOS) ?
 -			0 : rule->tuples_mask.ip_tos;
 -
 -	spec->proto = rule->tuples.ip_proto;
 -	spec_mask->proto = rule->unused_tuple & BIT(INNER_IP_PROTO) ?
 -			0 : rule->tuples_mask.ip_proto;
 -
 -	spec->ip_ver = ETH_RX_NFC_IP4;
 -}
 -
 -static void hclge_fd_get_tcpip6_info(struct hclge_fd_rule *rule,
 -				     struct ethtool_tcpip6_spec *spec,
 -				     struct ethtool_tcpip6_spec *spec_mask)
 -{
 -	cpu_to_be32_array(spec->ip6src,
 -			  rule->tuples.src_ip, IPV6_SIZE);
 -	cpu_to_be32_array(spec->ip6dst,
 -			  rule->tuples.dst_ip, IPV6_SIZE);
 -	if (rule->unused_tuple & BIT(INNER_SRC_IP))
 -		memset(spec_mask->ip6src, 0, sizeof(spec_mask->ip6src));
 -	else
 -		cpu_to_be32_array(spec_mask->ip6src, rule->tuples_mask.src_ip,
 -				  IPV6_SIZE);
 -
 -	if (rule->unused_tuple & BIT(INNER_DST_IP))
 -		memset(spec_mask->ip6dst, 0, sizeof(spec_mask->ip6dst));
 -	else
 -		cpu_to_be32_array(spec_mask->ip6dst, rule->tuples_mask.dst_ip,
 -				  IPV6_SIZE);
 -
 -	spec->tclass = rule->tuples.ip_tos;
 -	spec_mask->tclass = rule->unused_tuple & BIT(INNER_IP_TOS) ?
 -			0 : rule->tuples_mask.ip_tos;
 -
 -	spec->psrc = cpu_to_be16(rule->tuples.src_port);
 -	spec_mask->psrc = rule->unused_tuple & BIT(INNER_SRC_PORT) ?
 -			0 : cpu_to_be16(rule->tuples_mask.src_port);
 -
 -	spec->pdst = cpu_to_be16(rule->tuples.dst_port);
 -	spec_mask->pdst = rule->unused_tuple & BIT(INNER_DST_PORT) ?
 -			0 : cpu_to_be16(rule->tuples_mask.dst_port);
 -}
 -
 -static void hclge_fd_get_ip6_info(struct hclge_fd_rule *rule,
 -				  struct ethtool_usrip6_spec *spec,
 -				  struct ethtool_usrip6_spec *spec_mask)
 -{
 -	cpu_to_be32_array(spec->ip6src, rule->tuples.src_ip, IPV6_SIZE);
 -	cpu_to_be32_array(spec->ip6dst, rule->tuples.dst_ip, IPV6_SIZE);
 -	if (rule->unused_tuple & BIT(INNER_SRC_IP))
 -		memset(spec_mask->ip6src, 0, sizeof(spec_mask->ip6src));
 -	else
 -		cpu_to_be32_array(spec_mask->ip6src,
 -				  rule->tuples_mask.src_ip, IPV6_SIZE);
 -
 -	if (rule->unused_tuple & BIT(INNER_DST_IP))
 -		memset(spec_mask->ip6dst, 0, sizeof(spec_mask->ip6dst));
 -	else
 -		cpu_to_be32_array(spec_mask->ip6dst,
 -				  rule->tuples_mask.dst_ip, IPV6_SIZE);
 -
 -	spec->tclass = rule->tuples.ip_tos;
 -	spec_mask->tclass = rule->unused_tuple & BIT(INNER_IP_TOS) ?
 -			0 : rule->tuples_mask.ip_tos;
 -
 -	spec->l4_proto = rule->tuples.ip_proto;
 -	spec_mask->l4_proto = rule->unused_tuple & BIT(INNER_IP_PROTO) ?
 -			0 : rule->tuples_mask.ip_proto;
 -}
 -
 -static void hclge_fd_get_ether_info(struct hclge_fd_rule *rule,
 -				    struct ethhdr *spec,
 -				    struct ethhdr *spec_mask)
 -{
 -	ether_addr_copy(spec->h_source, rule->tuples.src_mac);
 -	ether_addr_copy(spec->h_dest, rule->tuples.dst_mac);
 -
 -	if (rule->unused_tuple & BIT(INNER_SRC_MAC))
 -		eth_zero_addr(spec_mask->h_source);
 -	else
 -		ether_addr_copy(spec_mask->h_source, rule->tuples_mask.src_mac);
 -
 -	if (rule->unused_tuple & BIT(INNER_DST_MAC))
 -		eth_zero_addr(spec_mask->h_dest);
 -	else
 -		ether_addr_copy(spec_mask->h_dest, rule->tuples_mask.dst_mac);
 -
 -	spec->h_proto = cpu_to_be16(rule->tuples.ether_proto);
 -	spec_mask->h_proto = rule->unused_tuple & BIT(INNER_ETH_TYPE) ?
 -			0 : cpu_to_be16(rule->tuples_mask.ether_proto);
 -}
 -
 -static void hclge_fd_get_user_def_info(struct ethtool_rx_flow_spec *fs,
 -				       struct hclge_fd_rule *rule)
 -{
 -	if ((rule->unused_tuple & HCLGE_FD_TUPLE_USER_DEF_TUPLES) ==
 -	    HCLGE_FD_TUPLE_USER_DEF_TUPLES) {
 -		fs->h_ext.data[0] = 0;
 -		fs->h_ext.data[1] = 0;
 -		fs->m_ext.data[0] = 0;
 -		fs->m_ext.data[1] = 0;
 -	} else {
 -		fs->h_ext.data[0] = cpu_to_be32(rule->ep.user_def.offset);
 -		fs->h_ext.data[1] = cpu_to_be32(rule->ep.user_def.data);
 -		fs->m_ext.data[0] =
 -				cpu_to_be32(HCLGE_FD_USER_DEF_OFFSET_UNMASK);
 -		fs->m_ext.data[1] = cpu_to_be32(rule->ep.user_def.data_mask);
 -	}
 -}
 -
 -static void hclge_fd_get_ext_info(struct ethtool_rx_flow_spec *fs,
 -				  struct hclge_fd_rule *rule)
 -{
 -	if (fs->flow_type & FLOW_EXT) {
 -		fs->h_ext.vlan_tci = cpu_to_be16(rule->tuples.vlan_tag1);
 -		fs->m_ext.vlan_tci =
 -				rule->unused_tuple & BIT(INNER_VLAN_TAG_FST) ?
 -				0 : cpu_to_be16(rule->tuples_mask.vlan_tag1);
 -
 -		hclge_fd_get_user_def_info(fs, rule);
 -	}
 -
 -	if (fs->flow_type & FLOW_MAC_EXT) {
 -		ether_addr_copy(fs->h_ext.h_dest, rule->tuples.dst_mac);
 -		if (rule->unused_tuple & BIT(INNER_DST_MAC))
 -			eth_zero_addr(fs->m_u.ether_spec.h_dest);
 -		else
 -			ether_addr_copy(fs->m_u.ether_spec.h_dest,
 -					rule->tuples_mask.dst_mac);
 -	}
 -}
 -
 -static int hclge_get_fd_rule_info(struct hnae3_handle *handle,
 -				  struct ethtool_rxnfc *cmd)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_fd_rule *rule = NULL;
 -	struct hclge_dev *hdev = vport->back;
 -	struct ethtool_rx_flow_spec *fs;
 -	struct hlist_node *node2;
 -
 -	if (!hnae3_dev_fd_supported(hdev))
 -		return -EOPNOTSUPP;
 -
 -	fs = (struct ethtool_rx_flow_spec *)&cmd->fs;
 -
 -	spin_lock_bh(&hdev->fd_rule_lock);
 -
 -	hlist_for_each_entry_safe(rule, node2, &hdev->fd_rule_list, rule_node) {
 -		if (rule->location >= fs->location)
 -			break;
 -	}
 -
 -	if (!rule || fs->location != rule->location) {
 -		spin_unlock_bh(&hdev->fd_rule_lock);
 -
 -		return -ENOENT;
 -	}
 -
 -	fs->flow_type = rule->flow_type;
 -	switch (fs->flow_type & ~(FLOW_EXT | FLOW_MAC_EXT)) {
 -	case SCTP_V4_FLOW:
 -	case TCP_V4_FLOW:
 -	case UDP_V4_FLOW:
 -		hclge_fd_get_tcpip4_info(rule, &fs->h_u.tcp_ip4_spec,
 -					 &fs->m_u.tcp_ip4_spec);
 -		break;
 -	case IP_USER_FLOW:
 -		hclge_fd_get_ip4_info(rule, &fs->h_u.usr_ip4_spec,
 -				      &fs->m_u.usr_ip4_spec);
 -		break;
 -	case SCTP_V6_FLOW:
 -	case TCP_V6_FLOW:
 -	case UDP_V6_FLOW:
 -		hclge_fd_get_tcpip6_info(rule, &fs->h_u.tcp_ip6_spec,
 -					 &fs->m_u.tcp_ip6_spec);
 -		break;
 -	case IPV6_USER_FLOW:
 -		hclge_fd_get_ip6_info(rule, &fs->h_u.usr_ip6_spec,
 -				      &fs->m_u.usr_ip6_spec);
 -		break;
 -	/* The flow type of fd rule has been checked before adding in to rule
 -	 * list. As other flow types have been handled, it must be ETHER_FLOW
 -	 * for the default case
 -	 */
 -	default:
 -		hclge_fd_get_ether_info(rule, &fs->h_u.ether_spec,
 -					&fs->m_u.ether_spec);
 -		break;
 -	}
 -
 -	hclge_fd_get_ext_info(fs, rule);
 -
 -	if (rule->action == HCLGE_FD_ACTION_DROP_PACKET) {
 -		fs->ring_cookie = RX_CLS_FLOW_DISC;
 -	} else {
 -		u64 vf_id;
 -
 -		fs->ring_cookie = rule->queue_id;
 -		vf_id = rule->vf_id;
 -		vf_id <<= ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF;
 -		fs->ring_cookie |= vf_id;
 -	}
 -
 -	spin_unlock_bh(&hdev->fd_rule_lock);
 -
 -	return 0;
 -}
 -
 -static int hclge_get_all_rules(struct hnae3_handle *handle,
 -			       struct ethtool_rxnfc *cmd, u32 *rule_locs)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -	struct hclge_fd_rule *rule;
 -	struct hlist_node *node2;
 -	int cnt = 0;
 -
 -	if (!hnae3_dev_fd_supported(hdev))
 -		return -EOPNOTSUPP;
 -
 -	cmd->data = hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1];
 -
 -	spin_lock_bh(&hdev->fd_rule_lock);
 -	hlist_for_each_entry_safe(rule, node2,
 -				  &hdev->fd_rule_list, rule_node) {
 -		if (cnt == cmd->rule_cnt) {
 -			spin_unlock_bh(&hdev->fd_rule_lock);
 -			return -EMSGSIZE;
 -		}
 -
 -		if (rule->state == HCLGE_FD_TO_DEL)
 -			continue;
 -
 -		rule_locs[cnt] = rule->location;
 -		cnt++;
 -	}
 -
 -	spin_unlock_bh(&hdev->fd_rule_lock);
 -
 -	cmd->rule_cnt = cnt;
 -
 -	return 0;
 -}
 -
 -static void hclge_fd_get_flow_tuples(const struct flow_keys *fkeys,
 -				     struct hclge_fd_rule_tuples *tuples)
 -{
 -#define flow_ip6_src fkeys->addrs.v6addrs.src.in6_u.u6_addr32
 -#define flow_ip6_dst fkeys->addrs.v6addrs.dst.in6_u.u6_addr32
 -
 -	tuples->ether_proto = be16_to_cpu(fkeys->basic.n_proto);
 -	tuples->ip_proto = fkeys->basic.ip_proto;
 -	tuples->dst_port = be16_to_cpu(fkeys->ports.dst);
 -
 -	if (fkeys->basic.n_proto == htons(ETH_P_IP)) {
 -		tuples->src_ip[3] = be32_to_cpu(fkeys->addrs.v4addrs.src);
 -		tuples->dst_ip[3] = be32_to_cpu(fkeys->addrs.v4addrs.dst);
 -	} else {
 -		int i;
 -
 -		for (i = 0; i < IPV6_SIZE; i++) {
 -			tuples->src_ip[i] = be32_to_cpu(flow_ip6_src[i]);
 -			tuples->dst_ip[i] = be32_to_cpu(flow_ip6_dst[i]);
 -		}
 -	}
 -}
 -
 -/* traverse all rules, check whether an existed rule has the same tuples */
 -static struct hclge_fd_rule *
 -hclge_fd_search_flow_keys(struct hclge_dev *hdev,
 -			  const struct hclge_fd_rule_tuples *tuples)
 -{
 -	struct hclge_fd_rule *rule = NULL;
 -	struct hlist_node *node;
 -
 -	hlist_for_each_entry_safe(rule, node, &hdev->fd_rule_list, rule_node) {
 -		if (!memcmp(tuples, &rule->tuples, sizeof(*tuples)))
 -			return rule;
 -	}
 -
 -	return NULL;
 -}
 -
 -static void hclge_fd_build_arfs_rule(const struct hclge_fd_rule_tuples *tuples,
 -				     struct hclge_fd_rule *rule)
 -{
 -	rule->unused_tuple = BIT(INNER_SRC_MAC) | BIT(INNER_DST_MAC) |
 -			     BIT(INNER_VLAN_TAG_FST) | BIT(INNER_IP_TOS) |
 -			     BIT(INNER_SRC_PORT);
 -	rule->action = 0;
 -	rule->vf_id = 0;
 -	rule->rule_type = HCLGE_FD_ARFS_ACTIVE;
 -	rule->state = HCLGE_FD_TO_ADD;
 -	if (tuples->ether_proto == ETH_P_IP) {
 -		if (tuples->ip_proto == IPPROTO_TCP)
 -			rule->flow_type = TCP_V4_FLOW;
 -		else
 -			rule->flow_type = UDP_V4_FLOW;
 -	} else {
 -		if (tuples->ip_proto == IPPROTO_TCP)
 -			rule->flow_type = TCP_V6_FLOW;
 -		else
 -			rule->flow_type = UDP_V6_FLOW;
 -	}
 -	memcpy(&rule->tuples, tuples, sizeof(rule->tuples));
 -	memset(&rule->tuples_mask, 0xFF, sizeof(rule->tuples_mask));
 -}
 -
 -static int hclge_add_fd_entry_by_arfs(struct hnae3_handle *handle, u16 queue_id,
 -				      u16 flow_id, struct flow_keys *fkeys)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_fd_rule_tuples new_tuples = {};
 -	struct hclge_dev *hdev = vport->back;
 -	struct hclge_fd_rule *rule;
 -	u16 bit_id;
 -
 -	if (!hnae3_dev_fd_supported(hdev))
 -		return -EOPNOTSUPP;
 -
 -	/* when there is already fd rule existed add by user,
 -	 * arfs should not work
 -	 */
 -	spin_lock_bh(&hdev->fd_rule_lock);
 -	if (hdev->fd_active_type != HCLGE_FD_ARFS_ACTIVE &&
 -	    hdev->fd_active_type != HCLGE_FD_RULE_NONE) {
 -		spin_unlock_bh(&hdev->fd_rule_lock);
 -		return -EOPNOTSUPP;
 -	}
 -
 -	hclge_fd_get_flow_tuples(fkeys, &new_tuples);
 -
 -	/* check is there flow director filter existed for this flow,
 -	 * if not, create a new filter for it;
 -	 * if filter exist with different queue id, modify the filter;
 -	 * if filter exist with same queue id, do nothing
 -	 */
 -	rule = hclge_fd_search_flow_keys(hdev, &new_tuples);
 -	if (!rule) {
 -		bit_id = find_first_zero_bit(hdev->fd_bmap, MAX_FD_FILTER_NUM);
 -		if (bit_id >= hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1]) {
 -			spin_unlock_bh(&hdev->fd_rule_lock);
 -			return -ENOSPC;
 -		}
 -
 -		rule = kzalloc(sizeof(*rule), GFP_ATOMIC);
 -		if (!rule) {
 -			spin_unlock_bh(&hdev->fd_rule_lock);
 -			return -ENOMEM;
 -		}
 -
 -		rule->location = bit_id;
 -		rule->arfs.flow_id = flow_id;
 -		rule->queue_id = queue_id;
 -		hclge_fd_build_arfs_rule(&new_tuples, rule);
 -		hclge_update_fd_list(hdev, rule->state, rule->location, rule);
 -		hdev->fd_active_type = HCLGE_FD_ARFS_ACTIVE;
 -	} else if (rule->queue_id != queue_id) {
 -		rule->queue_id = queue_id;
 -		rule->state = HCLGE_FD_TO_ADD;
 -		set_bit(HCLGE_STATE_FD_TBL_CHANGED, &hdev->state);
 -		hclge_task_schedule(hdev, 0);
 -	}
 -	spin_unlock_bh(&hdev->fd_rule_lock);
 -	return rule->location;
 -}
 -
 -static void hclge_rfs_filter_expire(struct hclge_dev *hdev)
 -{
 -#ifdef CONFIG_RFS_ACCEL
 -	struct hnae3_handle *handle = &hdev->vport[0].nic;
 -	struct hclge_fd_rule *rule;
 -	struct hlist_node *node;
 -
 -	spin_lock_bh(&hdev->fd_rule_lock);
 -	if (hdev->fd_active_type != HCLGE_FD_ARFS_ACTIVE) {
 -		spin_unlock_bh(&hdev->fd_rule_lock);
 -		return;
 -	}
 -	hlist_for_each_entry_safe(rule, node, &hdev->fd_rule_list, rule_node) {
 -		if (rule->state != HCLGE_FD_ACTIVE)
 -			continue;
 -		if (rps_may_expire_flow(handle->netdev, rule->queue_id,
 -					rule->arfs.flow_id, rule->location)) {
 -			rule->state = HCLGE_FD_TO_DEL;
 -			set_bit(HCLGE_STATE_FD_TBL_CHANGED, &hdev->state);
 -		}
 -	}
 -	spin_unlock_bh(&hdev->fd_rule_lock);
 -#endif
 -}
 -
 -/* make sure being called after lock up with fd_rule_lock */
 -static int hclge_clear_arfs_rules(struct hclge_dev *hdev)
 -{
 -#ifdef CONFIG_RFS_ACCEL
 -	struct hclge_fd_rule *rule;
 -	struct hlist_node *node;
 -	int ret;
 -
 -	if (hdev->fd_active_type != HCLGE_FD_ARFS_ACTIVE)
 -		return 0;
 -
 -	hlist_for_each_entry_safe(rule, node, &hdev->fd_rule_list, rule_node) {
 -		switch (rule->state) {
 -		case HCLGE_FD_TO_DEL:
 -		case HCLGE_FD_ACTIVE:
 -			ret = hclge_fd_tcam_config(hdev, HCLGE_FD_STAGE_1, true,
 -						   rule->location, NULL, false);
 -			if (ret)
 -				return ret;
 -			fallthrough;
 -		case HCLGE_FD_TO_ADD:
 -			hclge_fd_dec_rule_cnt(hdev, rule->location);
 -			hlist_del(&rule->rule_node);
 -			kfree(rule);
 -			break;
 -		default:
 -			break;
 -		}
 -	}
 -	hclge_sync_fd_state(hdev);
 -
 -#endif
 -	return 0;
 -}
 -
 -static void hclge_get_cls_key_basic(const struct flow_rule *flow,
 -				    struct hclge_fd_rule *rule)
 -{
 -	if (flow_rule_match_key(flow, FLOW_DISSECTOR_KEY_BASIC)) {
 -		struct flow_match_basic match;
 -		u16 ethtype_key, ethtype_mask;
 -
 -		flow_rule_match_basic(flow, &match);
 -		ethtype_key = ntohs(match.key->n_proto);
 -		ethtype_mask = ntohs(match.mask->n_proto);
 -
 -		if (ethtype_key == ETH_P_ALL) {
 -			ethtype_key = 0;
 -			ethtype_mask = 0;
 -		}
 -		rule->tuples.ether_proto = ethtype_key;
 -		rule->tuples_mask.ether_proto = ethtype_mask;
 -		rule->tuples.ip_proto = match.key->ip_proto;
 -		rule->tuples_mask.ip_proto = match.mask->ip_proto;
 -	} else {
 -		rule->unused_tuple |= BIT(INNER_IP_PROTO);
 -		rule->unused_tuple |= BIT(INNER_ETH_TYPE);
 -	}
 -}
 -
 -static void hclge_get_cls_key_mac(const struct flow_rule *flow,
 -				  struct hclge_fd_rule *rule)
 -{
 -	if (flow_rule_match_key(flow, FLOW_DISSECTOR_KEY_ETH_ADDRS)) {
 -		struct flow_match_eth_addrs match;
 -
 -		flow_rule_match_eth_addrs(flow, &match);
 -		ether_addr_copy(rule->tuples.dst_mac, match.key->dst);
 -		ether_addr_copy(rule->tuples_mask.dst_mac, match.mask->dst);
 -		ether_addr_copy(rule->tuples.src_mac, match.key->src);
 -		ether_addr_copy(rule->tuples_mask.src_mac, match.mask->src);
 -	} else {
 -		rule->unused_tuple |= BIT(INNER_DST_MAC);
 -		rule->unused_tuple |= BIT(INNER_SRC_MAC);
 -	}
 -}
 -
 -static void hclge_get_cls_key_vlan(const struct flow_rule *flow,
 -				   struct hclge_fd_rule *rule)
 -{
 -	if (flow_rule_match_key(flow, FLOW_DISSECTOR_KEY_VLAN)) {
 -		struct flow_match_vlan match;
 -
 -		flow_rule_match_vlan(flow, &match);
 -		rule->tuples.vlan_tag1 = match.key->vlan_id |
 -				(match.key->vlan_priority << VLAN_PRIO_SHIFT);
 -		rule->tuples_mask.vlan_tag1 = match.mask->vlan_id |
 -				(match.mask->vlan_priority << VLAN_PRIO_SHIFT);
 -	} else {
 -		rule->unused_tuple |= BIT(INNER_VLAN_TAG_FST);
 -	}
 -}
 -
 -static void hclge_get_cls_key_ip(const struct flow_rule *flow,
 -				 struct hclge_fd_rule *rule)
 -{
 -	u16 addr_type = 0;
 -
 -	if (flow_rule_match_key(flow, FLOW_DISSECTOR_KEY_CONTROL)) {
 -		struct flow_match_control match;
 -
 -		flow_rule_match_control(flow, &match);
 -		addr_type = match.key->addr_type;
 -	}
 -
 -	if (addr_type == FLOW_DISSECTOR_KEY_IPV4_ADDRS) {
 -		struct flow_match_ipv4_addrs match;
 -
 -		flow_rule_match_ipv4_addrs(flow, &match);
 -		rule->tuples.src_ip[IPV4_INDEX] = be32_to_cpu(match.key->src);
 -		rule->tuples_mask.src_ip[IPV4_INDEX] =
 -						be32_to_cpu(match.mask->src);
 -		rule->tuples.dst_ip[IPV4_INDEX] = be32_to_cpu(match.key->dst);
 -		rule->tuples_mask.dst_ip[IPV4_INDEX] =
 -						be32_to_cpu(match.mask->dst);
 -	} else if (addr_type == FLOW_DISSECTOR_KEY_IPV6_ADDRS) {
 -		struct flow_match_ipv6_addrs match;
 -
 -		flow_rule_match_ipv6_addrs(flow, &match);
 -		be32_to_cpu_array(rule->tuples.src_ip, match.key->src.s6_addr32,
 -				  IPV6_SIZE);
 -		be32_to_cpu_array(rule->tuples_mask.src_ip,
 -				  match.mask->src.s6_addr32, IPV6_SIZE);
 -		be32_to_cpu_array(rule->tuples.dst_ip, match.key->dst.s6_addr32,
 -				  IPV6_SIZE);
 -		be32_to_cpu_array(rule->tuples_mask.dst_ip,
 -				  match.mask->dst.s6_addr32, IPV6_SIZE);
 -	} else {
 -		rule->unused_tuple |= BIT(INNER_SRC_IP);
 -		rule->unused_tuple |= BIT(INNER_DST_IP);
 -	}
 -}
 -
 -static void hclge_get_cls_key_port(const struct flow_rule *flow,
 -				   struct hclge_fd_rule *rule)
 -{
 -	if (flow_rule_match_key(flow, FLOW_DISSECTOR_KEY_PORTS)) {
 -		struct flow_match_ports match;
 -
 -		flow_rule_match_ports(flow, &match);
 -
 -		rule->tuples.src_port = be16_to_cpu(match.key->src);
 -		rule->tuples_mask.src_port = be16_to_cpu(match.mask->src);
 -		rule->tuples.dst_port = be16_to_cpu(match.key->dst);
 -		rule->tuples_mask.dst_port = be16_to_cpu(match.mask->dst);
 -	} else {
 -		rule->unused_tuple |= BIT(INNER_SRC_PORT);
 -		rule->unused_tuple |= BIT(INNER_DST_PORT);
 -	}
 -}
 -
 -static int hclge_parse_cls_flower(struct hclge_dev *hdev,
 -				  struct flow_cls_offload *cls_flower,
 -				  struct hclge_fd_rule *rule)
 -{
 -	struct flow_rule *flow = flow_cls_offload_flow_rule(cls_flower);
 -	struct flow_dissector *dissector = flow->match.dissector;
 -
 -	if (dissector->used_keys &
 -	    ~(BIT(FLOW_DISSECTOR_KEY_CONTROL) |
 -	      BIT(FLOW_DISSECTOR_KEY_BASIC) |
 -	      BIT(FLOW_DISSECTOR_KEY_ETH_ADDRS) |
 -	      BIT(FLOW_DISSECTOR_KEY_VLAN) |
 -	      BIT(FLOW_DISSECTOR_KEY_IPV4_ADDRS) |
 -	      BIT(FLOW_DISSECTOR_KEY_IPV6_ADDRS) |
 -	      BIT(FLOW_DISSECTOR_KEY_PORTS))) {
 -		dev_err(&hdev->pdev->dev, "unsupported key set: %#x\n",
 -			dissector->used_keys);
 -		return -EOPNOTSUPP;
 -	}
 -
 -	hclge_get_cls_key_basic(flow, rule);
 -	hclge_get_cls_key_mac(flow, rule);
 -	hclge_get_cls_key_vlan(flow, rule);
 -	hclge_get_cls_key_ip(flow, rule);
 -	hclge_get_cls_key_port(flow, rule);
 -
 -	return 0;
 -}
 -
 -static int hclge_check_cls_flower(struct hclge_dev *hdev,
 -				  struct flow_cls_offload *cls_flower, int tc)
 -{
 -	u32 prio = cls_flower->common.prio;
 -
 -	if (tc < 0 || tc > hdev->tc_max) {
 -		dev_err(&hdev->pdev->dev, "invalid traffic class\n");
 -		return -EINVAL;
 -	}
 -
 -	if (prio == 0 ||
 -	    prio > hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1]) {
 -		dev_err(&hdev->pdev->dev,
 -			"prio %u should be in range[1, %u]\n",
 -			prio, hdev->fd_cfg.rule_num[HCLGE_FD_STAGE_1]);
 -		return -EINVAL;
 -	}
 -
 -	if (test_bit(prio - 1, hdev->fd_bmap)) {
 -		dev_err(&hdev->pdev->dev, "prio %u is already used\n", prio);
 -		return -EINVAL;
 -	}
 -	return 0;
 -}
 -
 -static int hclge_add_cls_flower(struct hnae3_handle *handle,
 -				struct flow_cls_offload *cls_flower,
 -				int tc)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -	struct hclge_fd_rule *rule;
 -	int ret;
 -
 -	ret = hclge_check_cls_flower(hdev, cls_flower, tc);
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"failed to check cls flower params, ret = %d\n", ret);
 -		return ret;
 -	}
 -
 -	rule = kzalloc(sizeof(*rule), GFP_KERNEL);
 -	if (!rule)
 -		return -ENOMEM;
 -
 -	ret = hclge_parse_cls_flower(hdev, cls_flower, rule);
 -	if (ret) {
 -		kfree(rule);
 -		return ret;
 -	}
 -
 -	rule->action = HCLGE_FD_ACTION_SELECT_TC;
 -	rule->cls_flower.tc = tc;
 -	rule->location = cls_flower->common.prio - 1;
 -	rule->vf_id = 0;
 -	rule->cls_flower.cookie = cls_flower->cookie;
 -	rule->rule_type = HCLGE_FD_TC_FLOWER_ACTIVE;
 -
 -	ret = hclge_add_fd_entry_common(hdev, rule);
 -	if (ret)
 -		kfree(rule);
 -
 -	return ret;
 -}
 -
 -static struct hclge_fd_rule *hclge_find_cls_flower(struct hclge_dev *hdev,
 -						   unsigned long cookie)
 -{
 -	struct hclge_fd_rule *rule;
 -	struct hlist_node *node;
 -
 -	hlist_for_each_entry_safe(rule, node, &hdev->fd_rule_list, rule_node) {
 -		if (rule->cls_flower.cookie == cookie)
 -			return rule;
 -	}
 -
 -	return NULL;
 -}
 -
 -static int hclge_del_cls_flower(struct hnae3_handle *handle,
 -				struct flow_cls_offload *cls_flower)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -	struct hclge_fd_rule *rule;
 -	int ret;
 -
 -	spin_lock_bh(&hdev->fd_rule_lock);
 -
 -	rule = hclge_find_cls_flower(hdev, cls_flower->cookie);
 -	if (!rule) {
 -		spin_unlock_bh(&hdev->fd_rule_lock);
 -		return -EINVAL;
 -	}
 -
 -	ret = hclge_fd_tcam_config(hdev, HCLGE_FD_STAGE_1, true, rule->location,
 -				   NULL, false);
 -	if (ret) {
 -		spin_unlock_bh(&hdev->fd_rule_lock);
 -		return ret;
 -	}
 -
 -	hclge_update_fd_list(hdev, HCLGE_FD_DELETED, rule->location, NULL);
 -	spin_unlock_bh(&hdev->fd_rule_lock);
 -
 -	return 0;
 -}
 -
 -static void hclge_sync_fd_list(struct hclge_dev *hdev, struct hlist_head *hlist)
 -{
 -	struct hclge_fd_rule *rule;
 -	struct hlist_node *node;
 -	int ret = 0;
 -
 -	if (!test_and_clear_bit(HCLGE_STATE_FD_TBL_CHANGED, &hdev->state))
 -		return;
 -
 -	spin_lock_bh(&hdev->fd_rule_lock);
 -
 -	hlist_for_each_entry_safe(rule, node, hlist, rule_node) {
 -		switch (rule->state) {
 -		case HCLGE_FD_TO_ADD:
 -			ret = hclge_fd_config_rule(hdev, rule);
 -			if (ret)
 -				goto out;
 -			rule->state = HCLGE_FD_ACTIVE;
 -			break;
 -		case HCLGE_FD_TO_DEL:
 -			ret = hclge_fd_tcam_config(hdev, HCLGE_FD_STAGE_1, true,
 -						   rule->location, NULL, false);
 -			if (ret)
 -				goto out;
 -			hclge_fd_dec_rule_cnt(hdev, rule->location);
 -			hclge_fd_free_node(hdev, rule);
 -			break;
 -		default:
 -			break;
 -		}
 -	}
 -
 -out:
 -	if (ret)
 -		set_bit(HCLGE_STATE_FD_TBL_CHANGED, &hdev->state);
 -
 -	spin_unlock_bh(&hdev->fd_rule_lock);
 -}
 -
 -static void hclge_sync_fd_table(struct hclge_dev *hdev)
 -{
 -	if (test_and_clear_bit(HCLGE_STATE_FD_CLEAR_ALL, &hdev->state)) {
 -		bool clear_list = hdev->fd_active_type == HCLGE_FD_ARFS_ACTIVE;
 -
 -		hclge_clear_fd_rules_in_list(hdev, clear_list);
 -	}
 -
 -	hclge_sync_fd_user_def_cfg(hdev, false);
 -
 -	hclge_sync_fd_list(hdev, &hdev->fd_rule_list);
 -}
 -
 -static bool hclge_get_hw_reset_stat(struct hnae3_handle *handle)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -
 -	return hclge_read_dev(&hdev->hw, HCLGE_GLOBAL_RESET_REG) ||
 -	       hclge_read_dev(&hdev->hw, HCLGE_FUN_RST_ING);
 -}
 -
 -static bool hclge_get_cmdq_stat(struct hnae3_handle *handle)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -
 -	return test_bit(HCLGE_STATE_CMD_DISABLE, &hdev->state);
 -}
 -
 -static bool hclge_ae_dev_resetting(struct hnae3_handle *handle)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -
 -	return test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state);
 -}
 -
 -static unsigned long hclge_ae_dev_reset_cnt(struct hnae3_handle *handle)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -
 -	return hdev->rst_stats.hw_reset_done_cnt;
 -}
 -
 -static void hclge_enable_fd(struct hnae3_handle *handle, bool enable)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -
 -	hdev->fd_en = enable;
 -
 -	if (!enable)
 -		set_bit(HCLGE_STATE_FD_CLEAR_ALL, &hdev->state);
 -	else
 -		hclge_restore_fd_entries(handle);
 -
 -	hclge_task_schedule(hdev, 0);
 -}
 -
 -static void hclge_cfg_mac_mode(struct hclge_dev *hdev, bool enable)
 -{
 -	struct hclge_desc desc;
 -	struct hclge_config_mac_mode_cmd *req =
 -		(struct hclge_config_mac_mode_cmd *)desc.data;
 -	u32 loop_en = 0;
 -	int ret;
 -
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CONFIG_MAC_MODE, false);
 -
 -	if (enable) {
 -		hnae3_set_bit(loop_en, HCLGE_MAC_TX_EN_B, 1U);
 -		hnae3_set_bit(loop_en, HCLGE_MAC_RX_EN_B, 1U);
 -		hnae3_set_bit(loop_en, HCLGE_MAC_PAD_TX_B, 1U);
 -		hnae3_set_bit(loop_en, HCLGE_MAC_PAD_RX_B, 1U);
 -		hnae3_set_bit(loop_en, HCLGE_MAC_FCS_TX_B, 1U);
 -		hnae3_set_bit(loop_en, HCLGE_MAC_RX_FCS_B, 1U);
 -		hnae3_set_bit(loop_en, HCLGE_MAC_RX_FCS_STRIP_B, 1U);
 -		hnae3_set_bit(loop_en, HCLGE_MAC_TX_OVERSIZE_TRUNCATE_B, 1U);
 -		hnae3_set_bit(loop_en, HCLGE_MAC_RX_OVERSIZE_TRUNCATE_B, 1U);
 -		hnae3_set_bit(loop_en, HCLGE_MAC_TX_UNDER_MIN_ERR_B, 1U);
 -	}
 -
 -	req->txrx_pad_fcs_loop_en = cpu_to_le32(loop_en);
 -
 -	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (ret)
 -		dev_err(&hdev->pdev->dev,
 -			"mac enable fail, ret =%d.\n", ret);
 -}
 -
 -static int hclge_config_switch_param(struct hclge_dev *hdev, int vfid,
 -				     u8 switch_param, u8 param_mask)
 -{
 -	struct hclge_mac_vlan_switch_cmd *req;
 -	struct hclge_desc desc;
 -	u32 func_id;
 -	int ret;
 -
 -	func_id = hclge_get_port_number(HOST_PORT, 0, vfid, 0);
 -	req = (struct hclge_mac_vlan_switch_cmd *)desc.data;
 -
 -	/* read current config parameter */
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_VLAN_SWITCH_PARAM,
 -				   true);
 -	req->roce_sel = HCLGE_MAC_VLAN_NIC_SEL;
 -	req->func_id = cpu_to_le32(func_id);
 -
 -	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"read mac vlan switch parameter fail, ret = %d\n", ret);
 -		return ret;
 -	}
 -
 -	/* modify and write new config parameter */
 -	hclge_cmd_reuse_desc(&desc, false);
 -	req->switch_param = (req->switch_param & param_mask) | switch_param;
 -	req->param_mask = param_mask;
 -
 -	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (ret)
 -		dev_err(&hdev->pdev->dev,
 -			"set mac vlan switch parameter fail, ret = %d\n", ret);
 -	return ret;
 -}
 -
 -static void hclge_phy_link_status_wait(struct hclge_dev *hdev,
 -				       int link_ret)
 -{
 -#define HCLGE_PHY_LINK_STATUS_NUM  200
 -
 -	struct phy_device *phydev = hdev->hw.mac.phydev;
 -	int i = 0;
 -	int ret;
 -
 -	do {
 -		ret = phy_read_status(phydev);
 -		if (ret) {
 -			dev_err(&hdev->pdev->dev,
 -				"phy update link status fail, ret = %d\n", ret);
 -			return;
 -		}
 -
 -		if (phydev->link == link_ret)
 -			break;
 -
 -		msleep(HCLGE_LINK_STATUS_MS);
 -	} while (++i < HCLGE_PHY_LINK_STATUS_NUM);
 -}
 -
 -static int hclge_mac_link_status_wait(struct hclge_dev *hdev, int link_ret)
 -{
 -#define HCLGE_MAC_LINK_STATUS_NUM  100
 -
 -	int link_status;
 -	int i = 0;
 -	int ret;
 -
 -	do {
 -		ret = hclge_get_mac_link_status(hdev, &link_status);
 -		if (ret)
 -			return ret;
 -		if (link_status == link_ret)
 -			return 0;
 -
 -		msleep(HCLGE_LINK_STATUS_MS);
 -	} while (++i < HCLGE_MAC_LINK_STATUS_NUM);
 -	return -EBUSY;
 -}
 -
 -static int hclge_mac_phy_link_status_wait(struct hclge_dev *hdev, bool en,
 -					  bool is_phy)
 -{
 -	int link_ret;
 -
 -	link_ret = en ? HCLGE_LINK_STATUS_UP : HCLGE_LINK_STATUS_DOWN;
 -
 -	if (is_phy)
 -		hclge_phy_link_status_wait(hdev, link_ret);
 -
 -	return hclge_mac_link_status_wait(hdev, link_ret);
 -}
 -
 -static int hclge_set_app_loopback(struct hclge_dev *hdev, bool en)
 -{
 -	struct hclge_config_mac_mode_cmd *req;
 -	struct hclge_desc desc;
 -	u32 loop_en;
 -	int ret;
 -
 -	req = (struct hclge_config_mac_mode_cmd *)&desc.data[0];
 -	/* 1 Read out the MAC mode config at first */
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CONFIG_MAC_MODE, true);
 -	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"mac loopback get fail, ret =%d.\n", ret);
 -		return ret;
 -	}
 -
 -	/* 2 Then setup the loopback flag */
 -	loop_en = le32_to_cpu(req->txrx_pad_fcs_loop_en);
 -	hnae3_set_bit(loop_en, HCLGE_MAC_APP_LP_B, en ? 1 : 0);
 -
 -	req->txrx_pad_fcs_loop_en = cpu_to_le32(loop_en);
 -
 -	/* 3 Config mac work mode with loopback flag
 -	 * and its original configure parameters
 -	 */
 -	hclge_cmd_reuse_desc(&desc, false);
 -	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (ret)
 -		dev_err(&hdev->pdev->dev,
 -			"mac loopback set fail, ret =%d.\n", ret);
 -	return ret;
 -}
 -
 -static int hclge_cfg_common_loopback(struct hclge_dev *hdev, bool en,
 -				     enum hnae3_loop loop_mode)
 -{
 -#define HCLGE_COMMON_LB_RETRY_MS	10
 -#define HCLGE_COMMON_LB_RETRY_NUM	100
 -
 -	struct hclge_common_lb_cmd *req;
 -	struct hclge_desc desc;
 -	int ret, i = 0;
 -	u8 loop_mode_b;
 -
 -	req = (struct hclge_common_lb_cmd *)desc.data;
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_COMMON_LOOPBACK, false);
 -
 -	switch (loop_mode) {
 -	case HNAE3_LOOP_SERIAL_SERDES:
 -		loop_mode_b = HCLGE_CMD_SERDES_SERIAL_INNER_LOOP_B;
 -		break;
 -	case HNAE3_LOOP_PARALLEL_SERDES:
 -		loop_mode_b = HCLGE_CMD_SERDES_PARALLEL_INNER_LOOP_B;
 -		break;
 -	case HNAE3_LOOP_PHY:
 -		loop_mode_b = HCLGE_CMD_GE_PHY_INNER_LOOP_B;
 -		break;
 -	default:
 -		dev_err(&hdev->pdev->dev,
 -			"unsupported common loopback mode %d\n", loop_mode);
 -		return -ENOTSUPP;
 -	}
 -
 -	if (en) {
 -		req->enable = loop_mode_b;
 -		req->mask = loop_mode_b;
 -	} else {
 -		req->mask = loop_mode_b;
 -	}
 -
 -	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"common loopback set fail, ret = %d\n", ret);
 -		return ret;
 -	}
 -
 -	do {
 -		msleep(HCLGE_COMMON_LB_RETRY_MS);
 -		hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_COMMON_LOOPBACK,
 -					   true);
 -		ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -		if (ret) {
 -			dev_err(&hdev->pdev->dev,
 -				"common loopback get, ret = %d\n", ret);
 -			return ret;
 -		}
 -	} while (++i < HCLGE_COMMON_LB_RETRY_NUM &&
 -		 !(req->result & HCLGE_CMD_COMMON_LB_DONE_B));
 -
 -	if (!(req->result & HCLGE_CMD_COMMON_LB_DONE_B)) {
 -		dev_err(&hdev->pdev->dev, "common loopback set timeout\n");
 -		return -EBUSY;
 -	} else if (!(req->result & HCLGE_CMD_COMMON_LB_SUCCESS_B)) {
 -		dev_err(&hdev->pdev->dev, "common loopback set failed in fw\n");
 -		return -EIO;
 -	}
 -	return ret;
 -}
 -
 -static int hclge_set_common_loopback(struct hclge_dev *hdev, bool en,
 -				     enum hnae3_loop loop_mode)
 -{
 -	int ret;
 -
 -	ret = hclge_cfg_common_loopback(hdev, en, loop_mode);
 -	if (ret)
 -		return ret;
 -
 -	hclge_cfg_mac_mode(hdev, en);
 -
 -	ret = hclge_mac_phy_link_status_wait(hdev, en, false);
 -	if (ret)
 -		dev_err(&hdev->pdev->dev,
 -			"serdes loopback config mac mode timeout\n");
 -
 -	return ret;
 -}
 -
 -static int hclge_enable_phy_loopback(struct hclge_dev *hdev,
 -				     struct phy_device *phydev)
 -{
 -	int ret;
 -
 -	if (!phydev->suspended) {
 -		ret = phy_suspend(phydev);
 -		if (ret)
 -			return ret;
 -	}
 -
 -	ret = phy_resume(phydev);
 -	if (ret)
 -		return ret;
 -
 -	return phy_loopback(phydev, true);
 -}
 -
 -static int hclge_disable_phy_loopback(struct hclge_dev *hdev,
 -				      struct phy_device *phydev)
 -{
 -	int ret;
 -
 -	ret = phy_loopback(phydev, false);
 -	if (ret)
 -		return ret;
 -
 -	return phy_suspend(phydev);
 -}
 -
 -static int hclge_set_phy_loopback(struct hclge_dev *hdev, bool en)
 -{
 -	struct phy_device *phydev = hdev->hw.mac.phydev;
 -	int ret;
 -
 -	if (!phydev) {
 -		if (hnae3_dev_phy_imp_supported(hdev))
 -			return hclge_set_common_loopback(hdev, en,
 -							 HNAE3_LOOP_PHY);
 -		return -ENOTSUPP;
 -	}
 -
 -	if (en)
 -		ret = hclge_enable_phy_loopback(hdev, phydev);
 -	else
 -		ret = hclge_disable_phy_loopback(hdev, phydev);
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"set phy loopback fail, ret = %d\n", ret);
 -		return ret;
 -	}
 -
 -	hclge_cfg_mac_mode(hdev, en);
 -
 -	ret = hclge_mac_phy_link_status_wait(hdev, en, true);
 -	if (ret)
 -		dev_err(&hdev->pdev->dev,
 -			"phy loopback config mac mode timeout\n");
 -
 -	return ret;
 -}
 -
 -static int hclge_tqp_enable_cmd_send(struct hclge_dev *hdev, u16 tqp_id,
 -				     u16 stream_id, bool enable)
 -{
 -	struct hclge_desc desc;
 -	struct hclge_cfg_com_tqp_queue_cmd *req =
 -		(struct hclge_cfg_com_tqp_queue_cmd *)desc.data;
 -
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_CFG_COM_TQP_QUEUE, false);
 -	req->tqp_id = cpu_to_le16(tqp_id);
 -	req->stream_id = cpu_to_le16(stream_id);
 -	if (enable)
 -		req->enable |= 1U << HCLGE_TQP_ENABLE_B;
 -
 -	return hclge_cmd_send(&hdev->hw, &desc, 1);
 -}
 -
 -static int hclge_tqp_enable(struct hnae3_handle *handle, bool enable)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -	int ret;
 -	u16 i;
 -
 -	for (i = 0; i < handle->kinfo.num_tqps; i++) {
 -		ret = hclge_tqp_enable_cmd_send(hdev, i, 0, enable);
 -		if (ret)
 -			return ret;
 -	}
 -	return 0;
 -}
 -
 -static int hclge_set_loopback(struct hnae3_handle *handle,
 -			      enum hnae3_loop loop_mode, bool en)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -	int ret;
 -
 -	/* Loopback can be enabled in three places: SSU, MAC, and serdes. By
 -	 * default, SSU loopback is enabled, so if the SMAC and the DMAC are
 -	 * the same, the packets are looped back in the SSU. If SSU loopback
 -	 * is disabled, packets can reach MAC even if SMAC is the same as DMAC.
 -	 */
 -	if (hdev->ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V2) {
 -		u8 switch_param = en ? 0 : BIT(HCLGE_SWITCH_ALW_LPBK_B);
 -
 -		ret = hclge_config_switch_param(hdev, PF_VPORT_ID, switch_param,
 -						HCLGE_SWITCH_ALW_LPBK_MASK);
 -		if (ret)
 -			return ret;
 -	}
 -
 -	switch (loop_mode) {
 -	case HNAE3_LOOP_APP:
 -		ret = hclge_set_app_loopback(hdev, en);
 -		break;
 -	case HNAE3_LOOP_SERIAL_SERDES:
 -	case HNAE3_LOOP_PARALLEL_SERDES:
 -		ret = hclge_set_common_loopback(hdev, en, loop_mode);
 -		break;
 -	case HNAE3_LOOP_PHY:
 -		ret = hclge_set_phy_loopback(hdev, en);
 -		break;
 -	default:
 -		ret = -ENOTSUPP;
 -		dev_err(&hdev->pdev->dev,
 -			"loop_mode %d is not supported\n", loop_mode);
 -		break;
 -	}
 -
 -	if (ret)
 -		return ret;
 -
 -	ret = hclge_tqp_enable(handle, en);
 -	if (ret)
 -		dev_err(&hdev->pdev->dev, "failed to %s tqp in loopback, ret = %d\n",
 -			en ? "enable" : "disable", ret);
 -
 -	return ret;
 -}
 -
 -static int hclge_set_default_loopback(struct hclge_dev *hdev)
 -{
 -	int ret;
 -
 -	ret = hclge_set_app_loopback(hdev, false);
 -	if (ret)
 -		return ret;
 -
 -	ret = hclge_cfg_common_loopback(hdev, false, HNAE3_LOOP_SERIAL_SERDES);
 -	if (ret)
 -		return ret;
 -
 -	return hclge_cfg_common_loopback(hdev, false,
 -					 HNAE3_LOOP_PARALLEL_SERDES);
 -}
 -
 -static void hclge_reset_tqp_stats(struct hnae3_handle *handle)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hnae3_knic_private_info *kinfo;
 -	struct hnae3_queue *queue;
 -	struct hclge_tqp *tqp;
 -	int i;
 -
 -	kinfo = &vport->nic.kinfo;
 -	for (i = 0; i < kinfo->num_tqps; i++) {
 -		queue = handle->kinfo.tqp[i];
 -		tqp = container_of(queue, struct hclge_tqp, q);
 -		memset(&tqp->tqp_stats, 0, sizeof(tqp->tqp_stats));
 -	}
 -}
 -
 -static void hclge_flush_link_update(struct hclge_dev *hdev)
 -{
 -#define HCLGE_FLUSH_LINK_TIMEOUT	100000
 -
 -	unsigned long last = hdev->serv_processed_cnt;
 -	int i = 0;
 -
 -	while (test_bit(HCLGE_STATE_LINK_UPDATING, &hdev->state) &&
 -	       i++ < HCLGE_FLUSH_LINK_TIMEOUT &&
 -	       last == hdev->serv_processed_cnt)
 -		usleep_range(1, 1);
 -}
 -
 -static void hclge_set_timer_task(struct hnae3_handle *handle, bool enable)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -
 -	if (enable) {
 -		hclge_task_schedule(hdev, 0);
 -	} else {
 -		/* Set the DOWN flag here to disable link updating */
 -		set_bit(HCLGE_STATE_DOWN, &hdev->state);
 -
 -		/* flush memory to make sure DOWN is seen by service task */
 -		smp_mb__before_atomic();
 -		hclge_flush_link_update(hdev);
 -	}
 -}
 -
 -static int hclge_ae_start(struct hnae3_handle *handle)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -
 -	/* mac enable */
 -	hclge_cfg_mac_mode(hdev, true);
 -	clear_bit(HCLGE_STATE_DOWN, &hdev->state);
 -	hdev->hw.mac.link = 0;
 -
 -	/* reset tqp stats */
 -	hclge_reset_tqp_stats(handle);
 -
 -	hclge_mac_start_phy(hdev);
 -
 -	return 0;
 -}
 -
 -static void hclge_ae_stop(struct hnae3_handle *handle)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -
 -	set_bit(HCLGE_STATE_DOWN, &hdev->state);
 -	spin_lock_bh(&hdev->fd_rule_lock);
 -	hclge_clear_arfs_rules(hdev);
 -	spin_unlock_bh(&hdev->fd_rule_lock);
 -
 -	/* If it is not PF reset or FLR, the firmware will disable the MAC,
 -	 * so it only need to stop phy here.
 -	 */
 -	if (test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state) &&
 -	    hdev->reset_type != HNAE3_FUNC_RESET &&
 -	    hdev->reset_type != HNAE3_FLR_RESET) {
 -		hclge_mac_stop_phy(hdev);
 -		hclge_update_link_status(hdev);
 -		return;
 -	}
 -
 -	hclge_reset_tqp(handle);
 -
 -	hclge_config_mac_tnl_int(hdev, false);
 -
 -	/* Mac disable */
 -	hclge_cfg_mac_mode(hdev, false);
 -
 -	hclge_mac_stop_phy(hdev);
 -
 -	/* reset tqp stats */
 -	hclge_reset_tqp_stats(handle);
 -	hclge_update_link_status(hdev);
 -}
 -
 -int hclge_vport_start(struct hclge_vport *vport)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -
 -	set_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state);
 -	set_bit(HCLGE_VPORT_STATE_PROMISC_CHANGE, &vport->state);
 -	vport->last_active_jiffies = jiffies;
 -
 -	if (test_bit(vport->vport_id, hdev->vport_config_block)) {
 -		if (vport->vport_id) {
 -			hclge_restore_mac_table_common(vport);
 -			hclge_restore_vport_vlan_table(vport);
 -		} else {
 -			hclge_restore_hw_table(hdev);
 -		}
 -	}
 -
 -	clear_bit(vport->vport_id, hdev->vport_config_block);
 -
 -	return 0;
 -}
 -
 -void hclge_vport_stop(struct hclge_vport *vport)
 -{
 -	clear_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state);
 -}
 -
 -static int hclge_client_start(struct hnae3_handle *handle)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -
 -	return hclge_vport_start(vport);
 -}
 -
 -static void hclge_client_stop(struct hnae3_handle *handle)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -
 -	hclge_vport_stop(vport);
 -}
 -
 -static int hclge_get_mac_vlan_cmd_status(struct hclge_vport *vport,
 -					 u16 cmdq_resp, u8  resp_code,
 -					 enum hclge_mac_vlan_tbl_opcode op)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -
 -	if (cmdq_resp) {
 -		dev_err(&hdev->pdev->dev,
 -			"cmdq execute failed for get_mac_vlan_cmd_status,status=%u.\n",
 -			cmdq_resp);
 -		return -EIO;
 -	}
 -
 -	if (op == HCLGE_MAC_VLAN_ADD) {
 -		if (!resp_code || resp_code == 1)
 -			return 0;
 -		else if (resp_code == HCLGE_ADD_UC_OVERFLOW ||
 -			 resp_code == HCLGE_ADD_MC_OVERFLOW)
 -			return -ENOSPC;
 -
 -		dev_err(&hdev->pdev->dev,
 -			"add mac addr failed for undefined, code=%u.\n",
 -			resp_code);
 -		return -EIO;
 -	} else if (op == HCLGE_MAC_VLAN_REMOVE) {
 -		if (!resp_code) {
 -			return 0;
 -		} else if (resp_code == 1) {
 -			dev_dbg(&hdev->pdev->dev,
 -				"remove mac addr failed for miss.\n");
 -			return -ENOENT;
 -		}
 -
 -		dev_err(&hdev->pdev->dev,
 -			"remove mac addr failed for undefined, code=%u.\n",
 -			resp_code);
 -		return -EIO;
 -	} else if (op == HCLGE_MAC_VLAN_LKUP) {
 -		if (!resp_code) {
 -			return 0;
 -		} else if (resp_code == 1) {
 -			dev_dbg(&hdev->pdev->dev,
 -				"lookup mac addr failed for miss.\n");
 -			return -ENOENT;
 -		}
 -
 -		dev_err(&hdev->pdev->dev,
 -			"lookup mac addr failed for undefined, code=%u.\n",
 -			resp_code);
 -		return -EIO;
 -	}
 -
 -	dev_err(&hdev->pdev->dev,
 -		"unknown opcode for get_mac_vlan_cmd_status, opcode=%d.\n", op);
 -
 -	return -EINVAL;
 -}
 -
 -static int hclge_update_desc_vfid(struct hclge_desc *desc, int vfid, bool clr)
 -{
 -#define HCLGE_VF_NUM_IN_FIRST_DESC 192
 -
 -	unsigned int word_num;
 -	unsigned int bit_num;
 -
 -	if (vfid > 255 || vfid < 0)
 -		return -EIO;
 -
 -	if (vfid >= 0 && vfid < HCLGE_VF_NUM_IN_FIRST_DESC) {
 -		word_num = vfid / 32;
 -		bit_num  = vfid % 32;
 -		if (clr)
 -			desc[1].data[word_num] &= cpu_to_le32(~(1 << bit_num));
 -		else
 -			desc[1].data[word_num] |= cpu_to_le32(1 << bit_num);
 -	} else {
 -		word_num = (vfid - HCLGE_VF_NUM_IN_FIRST_DESC) / 32;
 -		bit_num  = vfid % 32;
 -		if (clr)
 -			desc[2].data[word_num] &= cpu_to_le32(~(1 << bit_num));
 -		else
 -			desc[2].data[word_num] |= cpu_to_le32(1 << bit_num);
 -	}
 -
 -	return 0;
 -}
 -
 -static bool hclge_is_all_function_id_zero(struct hclge_desc *desc)
 -{
 -#define HCLGE_DESC_NUMBER 3
 -#define HCLGE_FUNC_NUMBER_PER_DESC 6
 -	int i, j;
 -
 -	for (i = 1; i < HCLGE_DESC_NUMBER; i++)
 -		for (j = 0; j < HCLGE_FUNC_NUMBER_PER_DESC; j++)
 -			if (desc[i].data[j])
 -				return false;
 -
 -	return true;
 -}
 -
 -static void hclge_prepare_mac_addr(struct hclge_mac_vlan_tbl_entry_cmd *new_req,
 -				   const u8 *addr, bool is_mc)
 -{
 -	const unsigned char *mac_addr = addr;
 -	u32 high_val = mac_addr[2] << 16 | (mac_addr[3] << 24) |
 -		       (mac_addr[0]) | (mac_addr[1] << 8);
 -	u32 low_val  = mac_addr[4] | (mac_addr[5] << 8);
 -
 -	hnae3_set_bit(new_req->flags, HCLGE_MAC_VLAN_BIT0_EN_B, 1);
 -	if (is_mc) {
 -		hnae3_set_bit(new_req->entry_type, HCLGE_MAC_VLAN_BIT1_EN_B, 1);
 -		hnae3_set_bit(new_req->mc_mac_en, HCLGE_MAC_VLAN_BIT0_EN_B, 1);
 -	}
 -
 -	new_req->mac_addr_hi32 = cpu_to_le32(high_val);
 -	new_req->mac_addr_lo16 = cpu_to_le16(low_val & 0xffff);
 -}
 -
 -static int hclge_remove_mac_vlan_tbl(struct hclge_vport *vport,
 -				     struct hclge_mac_vlan_tbl_entry_cmd *req)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -	struct hclge_desc desc;
 -	u8 resp_code;
 -	u16 retval;
 -	int ret;
 -
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_VLAN_REMOVE, false);
 -
 -	memcpy(desc.data, req, sizeof(struct hclge_mac_vlan_tbl_entry_cmd));
 -
 -	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"del mac addr failed for cmd_send, ret =%d.\n",
 -			ret);
 -		return ret;
 -	}
 -	resp_code = (le32_to_cpu(desc.data[0]) >> 8) & 0xff;
 -	retval = le16_to_cpu(desc.retval);
 -
 -	return hclge_get_mac_vlan_cmd_status(vport, retval, resp_code,
 -					     HCLGE_MAC_VLAN_REMOVE);
 -}
 -
 -static int hclge_lookup_mac_vlan_tbl(struct hclge_vport *vport,
 -				     struct hclge_mac_vlan_tbl_entry_cmd *req,
 -				     struct hclge_desc *desc,
 -				     bool is_mc)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -	u8 resp_code;
 -	u16 retval;
 -	int ret;
 -
 -	hclge_cmd_setup_basic_desc(&desc[0], HCLGE_OPC_MAC_VLAN_ADD, true);
 -	if (is_mc) {
 -		desc[0].flag |= cpu_to_le16(HCLGE_CMD_FLAG_NEXT);
 -		memcpy(desc[0].data,
 -		       req,
 -		       sizeof(struct hclge_mac_vlan_tbl_entry_cmd));
 -		hclge_cmd_setup_basic_desc(&desc[1],
 -					   HCLGE_OPC_MAC_VLAN_ADD,
 -					   true);
 -		desc[1].flag |= cpu_to_le16(HCLGE_CMD_FLAG_NEXT);
 -		hclge_cmd_setup_basic_desc(&desc[2],
 -					   HCLGE_OPC_MAC_VLAN_ADD,
 -					   true);
 -		ret = hclge_cmd_send(&hdev->hw, desc, 3);
 -	} else {
 -		memcpy(desc[0].data,
 -		       req,
 -		       sizeof(struct hclge_mac_vlan_tbl_entry_cmd));
 -		ret = hclge_cmd_send(&hdev->hw, desc, 1);
 -	}
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"lookup mac addr failed for cmd_send, ret =%d.\n",
 -			ret);
 -		return ret;
 -	}
 -	resp_code = (le32_to_cpu(desc[0].data[0]) >> 8) & 0xff;
 -	retval = le16_to_cpu(desc[0].retval);
 -
 -	return hclge_get_mac_vlan_cmd_status(vport, retval, resp_code,
 -					     HCLGE_MAC_VLAN_LKUP);
 -}
 -
 -static int hclge_add_mac_vlan_tbl(struct hclge_vport *vport,
 -				  struct hclge_mac_vlan_tbl_entry_cmd *req,
 -				  struct hclge_desc *mc_desc)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -	int cfg_status;
 -	u8 resp_code;
 -	u16 retval;
 -	int ret;
 -
 -	if (!mc_desc) {
 -		struct hclge_desc desc;
 -
 -		hclge_cmd_setup_basic_desc(&desc,
 -					   HCLGE_OPC_MAC_VLAN_ADD,
 -					   false);
 -		memcpy(desc.data, req,
 -		       sizeof(struct hclge_mac_vlan_tbl_entry_cmd));
 -		ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -		resp_code = (le32_to_cpu(desc.data[0]) >> 8) & 0xff;
 -		retval = le16_to_cpu(desc.retval);
 -
 -		cfg_status = hclge_get_mac_vlan_cmd_status(vport, retval,
 -							   resp_code,
 -							   HCLGE_MAC_VLAN_ADD);
 -	} else {
 -		hclge_cmd_reuse_desc(&mc_desc[0], false);
 -		mc_desc[0].flag |= cpu_to_le16(HCLGE_CMD_FLAG_NEXT);
 -		hclge_cmd_reuse_desc(&mc_desc[1], false);
 -		mc_desc[1].flag |= cpu_to_le16(HCLGE_CMD_FLAG_NEXT);
 -		hclge_cmd_reuse_desc(&mc_desc[2], false);
 -		mc_desc[2].flag &= cpu_to_le16(~HCLGE_CMD_FLAG_NEXT);
 -		memcpy(mc_desc[0].data, req,
 -		       sizeof(struct hclge_mac_vlan_tbl_entry_cmd));
 -		ret = hclge_cmd_send(&hdev->hw, mc_desc, 3);
 -		resp_code = (le32_to_cpu(mc_desc[0].data[0]) >> 8) & 0xff;
 -		retval = le16_to_cpu(mc_desc[0].retval);
 -
 -		cfg_status = hclge_get_mac_vlan_cmd_status(vport, retval,
 -							   resp_code,
 -							   HCLGE_MAC_VLAN_ADD);
 -	}
 -
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"add mac addr failed for cmd_send, ret =%d.\n",
 -			ret);
 -		return ret;
 -	}
 -
 -	return cfg_status;
 -}
 -
 -static int hclge_set_umv_space(struct hclge_dev *hdev, u16 space_size,
 -			       u16 *allocated_size)
 -{
 -	struct hclge_umv_spc_alc_cmd *req;
 -	struct hclge_desc desc;
 -	int ret;
 -
 -	req = (struct hclge_umv_spc_alc_cmd *)desc.data;
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_VLAN_ALLOCATE, false);
 -
 -	req->space_size = cpu_to_le32(space_size);
 -
 -	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev, "failed to set umv space, ret = %d\n",
 -			ret);
 -		return ret;
 -	}
 -
 -	*allocated_size = le32_to_cpu(desc.data[1]);
 -
 -	return 0;
 -}
 -
 -static int hclge_init_umv_space(struct hclge_dev *hdev)
 -{
 -	u16 allocated_size = 0;
 -	int ret;
 -
 -	ret = hclge_set_umv_space(hdev, hdev->wanted_umv_size, &allocated_size);
 -	if (ret)
 -		return ret;
 -
 -	if (allocated_size < hdev->wanted_umv_size)
 -		dev_warn(&hdev->pdev->dev,
 -			 "failed to alloc umv space, want %u, get %u\n",
 -			 hdev->wanted_umv_size, allocated_size);
 -
 -	hdev->max_umv_size = allocated_size;
 -	hdev->priv_umv_size = hdev->max_umv_size / (hdev->num_alloc_vport + 1);
 -	hdev->share_umv_size = hdev->priv_umv_size +
 -			hdev->max_umv_size % (hdev->num_alloc_vport + 1);
 -
 -	if (hdev->ae_dev->dev_specs.mc_mac_size)
 -		set_bit(HNAE3_DEV_SUPPORT_MC_MAC_MNG_B, hdev->ae_dev->caps);
 -
 -	return 0;
 -}
 -
 -static void hclge_reset_umv_space(struct hclge_dev *hdev)
 -{
 -	struct hclge_vport *vport;
 -	int i;
 -
 -	for (i = 0; i < hdev->num_alloc_vport; i++) {
 -		vport = &hdev->vport[i];
 -		vport->used_umv_num = 0;
 -	}
 -
 -	mutex_lock(&hdev->vport_lock);
 -	hdev->share_umv_size = hdev->priv_umv_size +
 -			hdev->max_umv_size % (hdev->num_alloc_vport + 1);
 -	mutex_unlock(&hdev->vport_lock);
 -
 -	hdev->used_mc_mac_num = 0;
 -}
 -
 -static bool hclge_is_umv_space_full(struct hclge_vport *vport, bool need_lock)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -	bool is_full;
 -
 -	if (need_lock)
 -		mutex_lock(&hdev->vport_lock);
 -
 -	is_full = (vport->used_umv_num >= hdev->priv_umv_size &&
 -		   hdev->share_umv_size == 0);
 -
 -	if (need_lock)
 -		mutex_unlock(&hdev->vport_lock);
 -
 -	return is_full;
 -}
 -
 -static void hclge_update_umv_space(struct hclge_vport *vport, bool is_free)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -
 -	if (is_free) {
 -		if (vport->used_umv_num > hdev->priv_umv_size)
 -			hdev->share_umv_size++;
 -
 -		if (vport->used_umv_num > 0)
 -			vport->used_umv_num--;
 -	} else {
 -		if (vport->used_umv_num >= hdev->priv_umv_size &&
 -		    hdev->share_umv_size > 0)
 -			hdev->share_umv_size--;
 -		vport->used_umv_num++;
 -	}
 -}
 -
 -static struct hclge_mac_node *hclge_find_mac_node(struct list_head *list,
 -						  const u8 *mac_addr)
 -{
 -	struct hclge_mac_node *mac_node, *tmp;
 -
 -	list_for_each_entry_safe(mac_node, tmp, list, node)
 -		if (ether_addr_equal(mac_addr, mac_node->mac_addr))
 -			return mac_node;
 -
 -	return NULL;
 -}
 -
 -static void hclge_update_mac_node(struct hclge_mac_node *mac_node,
 -				  enum HCLGE_MAC_NODE_STATE state)
 -{
 -	switch (state) {
 -	/* from set_rx_mode or tmp_add_list */
 -	case HCLGE_MAC_TO_ADD:
 -		if (mac_node->state == HCLGE_MAC_TO_DEL)
 -			mac_node->state = HCLGE_MAC_ACTIVE;
 -		break;
 -	/* only from set_rx_mode */
 -	case HCLGE_MAC_TO_DEL:
 -		if (mac_node->state == HCLGE_MAC_TO_ADD) {
 -			list_del(&mac_node->node);
 -			kfree(mac_node);
 -		} else {
 -			mac_node->state = HCLGE_MAC_TO_DEL;
 -		}
 -		break;
 -	/* only from tmp_add_list, the mac_node->state won't be
 -	 * ACTIVE.
 -	 */
 -	case HCLGE_MAC_ACTIVE:
 -		if (mac_node->state == HCLGE_MAC_TO_ADD)
 -			mac_node->state = HCLGE_MAC_ACTIVE;
 -
 -		break;
 -	}
 -}
 -
 -int hclge_update_mac_list(struct hclge_vport *vport,
 -			  enum HCLGE_MAC_NODE_STATE state,
 -			  enum HCLGE_MAC_ADDR_TYPE mac_type,
 -			  const unsigned char *addr)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -	struct hclge_mac_node *mac_node;
 -	struct list_head *list;
 -
 -	list = (mac_type == HCLGE_MAC_ADDR_UC) ?
 -		&vport->uc_mac_list : &vport->mc_mac_list;
 -
 -	spin_lock_bh(&vport->mac_list_lock);
 -
 -	/* if the mac addr is already in the mac list, no need to add a new
 -	 * one into it, just check the mac addr state, convert it to a new
 -	 * state, or just remove it, or do nothing.
 -	 */
 -	mac_node = hclge_find_mac_node(list, addr);
 -	if (mac_node) {
 -		hclge_update_mac_node(mac_node, state);
 -		spin_unlock_bh(&vport->mac_list_lock);
 -		set_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE, &vport->state);
 -		return 0;
 -	}
 -
 -	/* if this address is never added, unnecessary to delete */
 -	if (state == HCLGE_MAC_TO_DEL) {
 -		spin_unlock_bh(&vport->mac_list_lock);
 -		dev_err(&hdev->pdev->dev,
 -			"failed to delete address %pM from mac list\n",
 -			addr);
 -		return -ENOENT;
 -	}
 -
 -	mac_node = kzalloc(sizeof(*mac_node), GFP_ATOMIC);
 -	if (!mac_node) {
 -		spin_unlock_bh(&vport->mac_list_lock);
 -		return -ENOMEM;
 -	}
 -
 -	set_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE, &vport->state);
 -
 -	mac_node->state = state;
 -	ether_addr_copy(mac_node->mac_addr, addr);
 -	list_add_tail(&mac_node->node, list);
 -
 -	spin_unlock_bh(&vport->mac_list_lock);
 -
 -	return 0;
 -}
 -
 -static int hclge_add_uc_addr(struct hnae3_handle *handle,
 -			     const unsigned char *addr)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -
 -	return hclge_update_mac_list(vport, HCLGE_MAC_TO_ADD, HCLGE_MAC_ADDR_UC,
 -				     addr);
 -}
 -
 -int hclge_add_uc_addr_common(struct hclge_vport *vport,
 -			     const unsigned char *addr)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -	struct hclge_mac_vlan_tbl_entry_cmd req;
 -	struct hclge_desc desc;
 -	u16 egress_port = 0;
 -	int ret;
 -
 -	/* mac addr check */
 -	if (is_zero_ether_addr(addr) ||
 -	    is_broadcast_ether_addr(addr) ||
 -	    is_multicast_ether_addr(addr)) {
 -		dev_err(&hdev->pdev->dev,
 -			"Set_uc mac err! invalid mac:%pM. is_zero:%d,is_br=%d,is_mul=%d\n",
 -			 addr, is_zero_ether_addr(addr),
 -			 is_broadcast_ether_addr(addr),
 -			 is_multicast_ether_addr(addr));
 -		return -EINVAL;
 -	}
 -
 -	memset(&req, 0, sizeof(req));
 -
 -	hnae3_set_field(egress_port, HCLGE_MAC_EPORT_VFID_M,
 -			HCLGE_MAC_EPORT_VFID_S, vport->vport_id);
 -
 -	req.egress_port = cpu_to_le16(egress_port);
 -
 -	hclge_prepare_mac_addr(&req, addr, false);
 -
 -	/* Lookup the mac address in the mac_vlan table, and add
 -	 * it if the entry is inexistent. Repeated unicast entry
 -	 * is not allowed in the mac vlan table.
 -	 */
 -	ret = hclge_lookup_mac_vlan_tbl(vport, &req, &desc, false);
 -	if (ret == -ENOENT) {
 -		mutex_lock(&hdev->vport_lock);
 -		if (!hclge_is_umv_space_full(vport, false)) {
 -			ret = hclge_add_mac_vlan_tbl(vport, &req, NULL);
 -			if (!ret)
 -				hclge_update_umv_space(vport, false);
 -			mutex_unlock(&hdev->vport_lock);
 -			return ret;
 -		}
 -		mutex_unlock(&hdev->vport_lock);
 -
 -		if (!(vport->overflow_promisc_flags & HNAE3_OVERFLOW_UPE))
 -			dev_err(&hdev->pdev->dev, "UC MAC table full(%u)\n",
 -				hdev->priv_umv_size);
 -
 -		return -ENOSPC;
 -	}
 -
 -	/* check if we just hit the duplicate */
 -	if (!ret)
 -		return -EEXIST;
 -
 -	return ret;
 -}
 -
 -static int hclge_rm_uc_addr(struct hnae3_handle *handle,
 -			    const unsigned char *addr)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -
 -	return hclge_update_mac_list(vport, HCLGE_MAC_TO_DEL, HCLGE_MAC_ADDR_UC,
 -				     addr);
 -}
 -
 -int hclge_rm_uc_addr_common(struct hclge_vport *vport,
 -			    const unsigned char *addr)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -	struct hclge_mac_vlan_tbl_entry_cmd req;
 -	int ret;
 -
 -	/* mac addr check */
 -	if (is_zero_ether_addr(addr) ||
 -	    is_broadcast_ether_addr(addr) ||
 -	    is_multicast_ether_addr(addr)) {
 -		dev_dbg(&hdev->pdev->dev, "Remove mac err! invalid mac:%pM.\n",
 -			addr);
 -		return -EINVAL;
 -	}
 -
 -	memset(&req, 0, sizeof(req));
 -	hnae3_set_bit(req.entry_type, HCLGE_MAC_VLAN_BIT0_EN_B, 0);
 -	hclge_prepare_mac_addr(&req, addr, false);
 -	ret = hclge_remove_mac_vlan_tbl(vport, &req);
 -	if (!ret) {
 -		mutex_lock(&hdev->vport_lock);
 -		hclge_update_umv_space(vport, true);
 -		mutex_unlock(&hdev->vport_lock);
 -	} else if (ret == -ENOENT) {
 -		ret = 0;
 -	}
 -
 -	return ret;
 -}
 -
 -static int hclge_add_mc_addr(struct hnae3_handle *handle,
 -			     const unsigned char *addr)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -
 -	return hclge_update_mac_list(vport, HCLGE_MAC_TO_ADD, HCLGE_MAC_ADDR_MC,
 -				     addr);
 -}
 -
 -int hclge_add_mc_addr_common(struct hclge_vport *vport,
 -			     const unsigned char *addr)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -	struct hclge_mac_vlan_tbl_entry_cmd req;
 -	struct hclge_desc desc[3];
 -	bool is_new_addr = false;
 -	int status;
 -
 -	/* mac addr check */
 -	if (!is_multicast_ether_addr(addr)) {
 -		dev_err(&hdev->pdev->dev,
 -			"Add mc mac err! invalid mac:%pM.\n",
 -			 addr);
 -		return -EINVAL;
 -	}
 -	memset(&req, 0, sizeof(req));
 -	hclge_prepare_mac_addr(&req, addr, true);
 -	status = hclge_lookup_mac_vlan_tbl(vport, &req, desc, true);
 -	if (status) {
 -		if (hnae3_ae_dev_mc_mac_mng_supported(hdev->ae_dev) &&
 -		    hdev->used_mc_mac_num >=
 -		    hdev->ae_dev->dev_specs.mc_mac_size)
 -			goto err_no_space;
 -
 -		is_new_addr = true;
 -
 -		/* This mac addr do not exist, add new entry for it */
 -		memset(desc[0].data, 0, sizeof(desc[0].data));
 -		memset(desc[1].data, 0, sizeof(desc[0].data));
 -		memset(desc[2].data, 0, sizeof(desc[0].data));
 -	}
 -	status = hclge_update_desc_vfid(desc, vport->vport_id, false);
 -	if (status)
 -		return status;
 -	status = hclge_add_mac_vlan_tbl(vport, &req, desc);
 -	if (status == -ENOSPC)
 -		goto err_no_space;
 -	else if (!status && is_new_addr)
 -		hdev->used_mc_mac_num++;
 -
 -	return status;
 -
 -err_no_space:
 -	/* if already overflow, not to print each time */
 -	if (!(vport->overflow_promisc_flags & HNAE3_OVERFLOW_MPE))
 -		dev_err(&hdev->pdev->dev, "mc mac vlan table is full\n");
 -	return -ENOSPC;
 -}
 -
 -static int hclge_rm_mc_addr(struct hnae3_handle *handle,
 -			    const unsigned char *addr)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -
 -	return hclge_update_mac_list(vport, HCLGE_MAC_TO_DEL, HCLGE_MAC_ADDR_MC,
 -				     addr);
 -}
 -
 -int hclge_rm_mc_addr_common(struct hclge_vport *vport,
 -			    const unsigned char *addr)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -	struct hclge_mac_vlan_tbl_entry_cmd req;
 -	enum hclge_cmd_status status;
 -	struct hclge_desc desc[3];
 -
 -	/* mac addr check */
 -	if (!is_multicast_ether_addr(addr)) {
 -		dev_dbg(&hdev->pdev->dev,
 -			"Remove mc mac err! invalid mac:%pM.\n",
 -			 addr);
 -		return -EINVAL;
 -	}
 -
 -	memset(&req, 0, sizeof(req));
 -	hclge_prepare_mac_addr(&req, addr, true);
 -	status = hclge_lookup_mac_vlan_tbl(vport, &req, desc, true);
 -	if (!status) {
 -		/* This mac addr exist, remove this handle's VFID for it */
 -		status = hclge_update_desc_vfid(desc, vport->vport_id, true);
 -		if (status)
 -			return status;
 -
 -		if (hclge_is_all_function_id_zero(desc)) {
 -			/* All the vfid is zero, so need to delete this entry */
 -			status = hclge_remove_mac_vlan_tbl(vport, &req);
 -			if (!status)
 -				hdev->used_mc_mac_num--;
 -		} else {
 -			/* Not all the vfid is zero, update the vfid */
 -			status = hclge_add_mac_vlan_tbl(vport, &req, desc);
 -		}
 -	} else if (status == -ENOENT) {
 -		status = 0;
 -	}
 -
 -	return status;
 -}
 -
 -static void hclge_sync_vport_mac_list(struct hclge_vport *vport,
 -				      struct list_head *list,
 -				      int (*sync)(struct hclge_vport *,
 -						  const unsigned char *))
 -{
 -	struct hclge_mac_node *mac_node, *tmp;
 -	int ret;
 -
 -	list_for_each_entry_safe(mac_node, tmp, list, node) {
 -		ret = sync(vport, mac_node->mac_addr);
 -		if (!ret) {
 -			mac_node->state = HCLGE_MAC_ACTIVE;
 -		} else {
 -			set_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE,
 -				&vport->state);
 -
 -			/* If one unicast mac address is existing in hardware,
 -			 * we need to try whether other unicast mac addresses
 -			 * are new addresses that can be added.
 -			 */
 -			if (ret != -EEXIST)
 -				break;
 -		}
 -	}
 -}
 -
 -static void hclge_unsync_vport_mac_list(struct hclge_vport *vport,
 -					struct list_head *list,
 -					int (*unsync)(struct hclge_vport *,
 -						      const unsigned char *))
 -{
 -	struct hclge_mac_node *mac_node, *tmp;
 -	int ret;
 -
 -	list_for_each_entry_safe(mac_node, tmp, list, node) {
 -		ret = unsync(vport, mac_node->mac_addr);
 -		if (!ret || ret == -ENOENT) {
 -			list_del(&mac_node->node);
 -			kfree(mac_node);
 -		} else {
 -			set_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE,
 -				&vport->state);
 -			break;
 -		}
 -	}
 -}
 -
 -static bool hclge_sync_from_add_list(struct list_head *add_list,
 -				     struct list_head *mac_list)
 -{
 -	struct hclge_mac_node *mac_node, *tmp, *new_node;
 -	bool all_added = true;
 -
 -	list_for_each_entry_safe(mac_node, tmp, add_list, node) {
 -		if (mac_node->state == HCLGE_MAC_TO_ADD)
 -			all_added = false;
 -
 -		/* if the mac address from tmp_add_list is not in the
 -		 * uc/mc_mac_list, it means have received a TO_DEL request
 -		 * during the time window of adding the mac address into mac
 -		 * table. if mac_node state is ACTIVE, then change it to TO_DEL,
 -		 * then it will be removed at next time. else it must be TO_ADD,
 -		 * this address hasn't been added into mac table,
 -		 * so just remove the mac node.
 -		 */
 -		new_node = hclge_find_mac_node(mac_list, mac_node->mac_addr);
 -		if (new_node) {
 -			hclge_update_mac_node(new_node, mac_node->state);
 -			list_del(&mac_node->node);
 -			kfree(mac_node);
 -		} else if (mac_node->state == HCLGE_MAC_ACTIVE) {
 -			mac_node->state = HCLGE_MAC_TO_DEL;
 -			list_move_tail(&mac_node->node, mac_list);
 -		} else {
 -			list_del(&mac_node->node);
 -			kfree(mac_node);
 -		}
 -	}
 -
 -	return all_added;
 -}
 -
 -static void hclge_sync_from_del_list(struct list_head *del_list,
 -				     struct list_head *mac_list)
 -{
 -	struct hclge_mac_node *mac_node, *tmp, *new_node;
 -
 -	list_for_each_entry_safe(mac_node, tmp, del_list, node) {
 -		new_node = hclge_find_mac_node(mac_list, mac_node->mac_addr);
 -		if (new_node) {
 -			/* If the mac addr exists in the mac list, it means
 -			 * received a new TO_ADD request during the time window
 -			 * of configuring the mac address. For the mac node
 -			 * state is TO_ADD, and the address is already in the
 -			 * in the hardware(due to delete fail), so we just need
 -			 * to change the mac node state to ACTIVE.
 -			 */
 -			new_node->state = HCLGE_MAC_ACTIVE;
 -			list_del(&mac_node->node);
 -			kfree(mac_node);
 -		} else {
 -			list_move_tail(&mac_node->node, mac_list);
 -		}
 -	}
 -}
 -
 -static void hclge_update_overflow_flags(struct hclge_vport *vport,
 -					enum HCLGE_MAC_ADDR_TYPE mac_type,
 -					bool is_all_added)
 -{
 -	if (mac_type == HCLGE_MAC_ADDR_UC) {
 -		if (is_all_added)
 -			vport->overflow_promisc_flags &= ~HNAE3_OVERFLOW_UPE;
 -		else
 -			vport->overflow_promisc_flags |= HNAE3_OVERFLOW_UPE;
 -	} else {
 -		if (is_all_added)
 -			vport->overflow_promisc_flags &= ~HNAE3_OVERFLOW_MPE;
 -		else
 -			vport->overflow_promisc_flags |= HNAE3_OVERFLOW_MPE;
 -	}
 -}
 -
 -static void hclge_sync_vport_mac_table(struct hclge_vport *vport,
 -				       enum HCLGE_MAC_ADDR_TYPE mac_type)
 -{
 -	struct hclge_mac_node *mac_node, *tmp, *new_node;
 -	struct list_head tmp_add_list, tmp_del_list;
 -	struct list_head *list;
 -	bool all_added;
 -
 -	INIT_LIST_HEAD(&tmp_add_list);
 -	INIT_LIST_HEAD(&tmp_del_list);
 -
 -	/* move the mac addr to the tmp_add_list and tmp_del_list, then
 -	 * we can add/delete these mac addr outside the spin lock
 -	 */
 -	list = (mac_type == HCLGE_MAC_ADDR_UC) ?
 -		&vport->uc_mac_list : &vport->mc_mac_list;
 -
 -	spin_lock_bh(&vport->mac_list_lock);
 -
 -	list_for_each_entry_safe(mac_node, tmp, list, node) {
 -		switch (mac_node->state) {
 -		case HCLGE_MAC_TO_DEL:
 -			list_move_tail(&mac_node->node, &tmp_del_list);
 -			break;
 -		case HCLGE_MAC_TO_ADD:
 -			new_node = kzalloc(sizeof(*new_node), GFP_ATOMIC);
 -			if (!new_node)
 -				goto stop_traverse;
 -			ether_addr_copy(new_node->mac_addr, mac_node->mac_addr);
 -			new_node->state = mac_node->state;
 -			list_add_tail(&new_node->node, &tmp_add_list);
 -			break;
 -		default:
 -			break;
 -		}
 -	}
 -
 -stop_traverse:
 -	spin_unlock_bh(&vport->mac_list_lock);
 -
 -	/* delete first, in order to get max mac table space for adding */
 -	if (mac_type == HCLGE_MAC_ADDR_UC) {
 -		hclge_unsync_vport_mac_list(vport, &tmp_del_list,
 -					    hclge_rm_uc_addr_common);
 -		hclge_sync_vport_mac_list(vport, &tmp_add_list,
 -					  hclge_add_uc_addr_common);
 -	} else {
 -		hclge_unsync_vport_mac_list(vport, &tmp_del_list,
 -					    hclge_rm_mc_addr_common);
 -		hclge_sync_vport_mac_list(vport, &tmp_add_list,
 -					  hclge_add_mc_addr_common);
 -	}
 -
 -	/* if some mac addresses were added/deleted fail, move back to the
 -	 * mac_list, and retry at next time.
 -	 */
 -	spin_lock_bh(&vport->mac_list_lock);
 -
 -	hclge_sync_from_del_list(&tmp_del_list, list);
 -	all_added = hclge_sync_from_add_list(&tmp_add_list, list);
 -
 -	spin_unlock_bh(&vport->mac_list_lock);
 -
 -	hclge_update_overflow_flags(vport, mac_type, all_added);
 -}
 -
 -static bool hclge_need_sync_mac_table(struct hclge_vport *vport)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -
 -	if (test_bit(vport->vport_id, hdev->vport_config_block))
 -		return false;
 -
 -	if (test_and_clear_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE, &vport->state))
 -		return true;
 -
 -	return false;
 -}
 -
 -static void hclge_sync_mac_table(struct hclge_dev *hdev)
 -{
 -	int i;
 -
 -	for (i = 0; i < hdev->num_alloc_vport; i++) {
 -		struct hclge_vport *vport = &hdev->vport[i];
 -
 -		if (!hclge_need_sync_mac_table(vport))
 -			continue;
 -
 -		hclge_sync_vport_mac_table(vport, HCLGE_MAC_ADDR_UC);
 -		hclge_sync_vport_mac_table(vport, HCLGE_MAC_ADDR_MC);
 -	}
 -}
 -
 -static void hclge_build_del_list(struct list_head *list,
 -				 bool is_del_list,
 -				 struct list_head *tmp_del_list)
 -{
 -	struct hclge_mac_node *mac_cfg, *tmp;
 -
 -	list_for_each_entry_safe(mac_cfg, tmp, list, node) {
 -		switch (mac_cfg->state) {
 -		case HCLGE_MAC_TO_DEL:
 -		case HCLGE_MAC_ACTIVE:
 -			list_move_tail(&mac_cfg->node, tmp_del_list);
 -			break;
 -		case HCLGE_MAC_TO_ADD:
 -			if (is_del_list) {
 -				list_del(&mac_cfg->node);
 -				kfree(mac_cfg);
 -			}
 -			break;
 -		}
 -	}
 -}
 -
 -static void hclge_unsync_del_list(struct hclge_vport *vport,
 -				  int (*unsync)(struct hclge_vport *vport,
 -						const unsigned char *addr),
 -				  bool is_del_list,
 -				  struct list_head *tmp_del_list)
 -{
 -	struct hclge_mac_node *mac_cfg, *tmp;
 -	int ret;
 -
 -	list_for_each_entry_safe(mac_cfg, tmp, tmp_del_list, node) {
 -		ret = unsync(vport, mac_cfg->mac_addr);
 -		if (!ret || ret == -ENOENT) {
 -			/* clear all mac addr from hardware, but remain these
 -			 * mac addr in the mac list, and restore them after
 -			 * vf reset finished.
 -			 */
 -			if (!is_del_list &&
 -			    mac_cfg->state == HCLGE_MAC_ACTIVE) {
 -				mac_cfg->state = HCLGE_MAC_TO_ADD;
 -			} else {
 -				list_del(&mac_cfg->node);
 -				kfree(mac_cfg);
 -			}
 -		} else if (is_del_list) {
 -			mac_cfg->state = HCLGE_MAC_TO_DEL;
 -		}
 -	}
 -}
 -
 -void hclge_rm_vport_all_mac_table(struct hclge_vport *vport, bool is_del_list,
 -				  enum HCLGE_MAC_ADDR_TYPE mac_type)
 -{
 -	int (*unsync)(struct hclge_vport *vport, const unsigned char *addr);
 -	struct hclge_dev *hdev = vport->back;
 -	struct list_head tmp_del_list, *list;
 -
 -	if (mac_type == HCLGE_MAC_ADDR_UC) {
 -		list = &vport->uc_mac_list;
 -		unsync = hclge_rm_uc_addr_common;
 -	} else {
 -		list = &vport->mc_mac_list;
 -		unsync = hclge_rm_mc_addr_common;
 -	}
 -
 -	INIT_LIST_HEAD(&tmp_del_list);
 -
 -	if (!is_del_list)
 -		set_bit(vport->vport_id, hdev->vport_config_block);
 -
 -	spin_lock_bh(&vport->mac_list_lock);
 -
 -	hclge_build_del_list(list, is_del_list, &tmp_del_list);
 -
 -	spin_unlock_bh(&vport->mac_list_lock);
 -
 -	hclge_unsync_del_list(vport, unsync, is_del_list, &tmp_del_list);
 -
 -	spin_lock_bh(&vport->mac_list_lock);
 -
 -	hclge_sync_from_del_list(&tmp_del_list, list);
 -
 -	spin_unlock_bh(&vport->mac_list_lock);
 -}
 -
 -/* remove all mac address when uninitailize */
 -static void hclge_uninit_vport_mac_list(struct hclge_vport *vport,
 -					enum HCLGE_MAC_ADDR_TYPE mac_type)
 -{
 -	struct hclge_mac_node *mac_node, *tmp;
 -	struct hclge_dev *hdev = vport->back;
 -	struct list_head tmp_del_list, *list;
 -
 -	INIT_LIST_HEAD(&tmp_del_list);
 -
 -	list = (mac_type == HCLGE_MAC_ADDR_UC) ?
 -		&vport->uc_mac_list : &vport->mc_mac_list;
 -
 -	spin_lock_bh(&vport->mac_list_lock);
 -
 -	list_for_each_entry_safe(mac_node, tmp, list, node) {
 -		switch (mac_node->state) {
 -		case HCLGE_MAC_TO_DEL:
 -		case HCLGE_MAC_ACTIVE:
 -			list_move_tail(&mac_node->node, &tmp_del_list);
 -			break;
 -		case HCLGE_MAC_TO_ADD:
 -			list_del(&mac_node->node);
 -			kfree(mac_node);
 -			break;
 -		}
 -	}
 -
 -	spin_unlock_bh(&vport->mac_list_lock);
 -
 -	if (mac_type == HCLGE_MAC_ADDR_UC)
 -		hclge_unsync_vport_mac_list(vport, &tmp_del_list,
 -					    hclge_rm_uc_addr_common);
 -	else
 -		hclge_unsync_vport_mac_list(vport, &tmp_del_list,
 -					    hclge_rm_mc_addr_common);
 -
 -	if (!list_empty(&tmp_del_list))
 -		dev_warn(&hdev->pdev->dev,
 -			 "uninit %s mac list for vport %u not completely.\n",
 -			 mac_type == HCLGE_MAC_ADDR_UC ? "uc" : "mc",
 -			 vport->vport_id);
 -
 -	list_for_each_entry_safe(mac_node, tmp, &tmp_del_list, node) {
 -		list_del(&mac_node->node);
 -		kfree(mac_node);
 -	}
 -}
 -
 -static void hclge_uninit_mac_table(struct hclge_dev *hdev)
 -{
 -	struct hclge_vport *vport;
 -	int i;
 -
 -	for (i = 0; i < hdev->num_alloc_vport; i++) {
 -		vport = &hdev->vport[i];
 -		hclge_uninit_vport_mac_list(vport, HCLGE_MAC_ADDR_UC);
 -		hclge_uninit_vport_mac_list(vport, HCLGE_MAC_ADDR_MC);
 -	}
 -}
 -
 -static int hclge_get_mac_ethertype_cmd_status(struct hclge_dev *hdev,
 -					      u16 cmdq_resp, u8 resp_code)
 -{
 -#define HCLGE_ETHERTYPE_SUCCESS_ADD		0
 -#define HCLGE_ETHERTYPE_ALREADY_ADD		1
 -#define HCLGE_ETHERTYPE_MGR_TBL_OVERFLOW	2
 -#define HCLGE_ETHERTYPE_KEY_CONFLICT		3
 -
 -	int return_status;
 -
 -	if (cmdq_resp) {
 -		dev_err(&hdev->pdev->dev,
 -			"cmdq execute failed for get_mac_ethertype_cmd_status, status=%u.\n",
 -			cmdq_resp);
 -		return -EIO;
 -	}
 -
 -	switch (resp_code) {
 -	case HCLGE_ETHERTYPE_SUCCESS_ADD:
 -	case HCLGE_ETHERTYPE_ALREADY_ADD:
 -		return_status = 0;
 -		break;
 -	case HCLGE_ETHERTYPE_MGR_TBL_OVERFLOW:
 -		dev_err(&hdev->pdev->dev,
 -			"add mac ethertype failed for manager table overflow.\n");
 -		return_status = -EIO;
 -		break;
 -	case HCLGE_ETHERTYPE_KEY_CONFLICT:
 -		dev_err(&hdev->pdev->dev,
 -			"add mac ethertype failed for key conflict.\n");
 -		return_status = -EIO;
 -		break;
 -	default:
 -		dev_err(&hdev->pdev->dev,
 -			"add mac ethertype failed for undefined, code=%u.\n",
 -			resp_code);
 -		return_status = -EIO;
 -	}
 -
 -	return return_status;
 -}
 -
 -static bool hclge_check_vf_mac_exist(struct hclge_vport *vport, int vf_idx,
 -				     u8 *mac_addr)
 -{
 -	struct hclge_mac_vlan_tbl_entry_cmd req;
 -	struct hclge_dev *hdev = vport->back;
 -	struct hclge_desc desc;
 -	u16 egress_port = 0;
 -	int i;
 -
 -	if (is_zero_ether_addr(mac_addr))
 -		return false;
 -
 -	memset(&req, 0, sizeof(req));
 -	hnae3_set_field(egress_port, HCLGE_MAC_EPORT_VFID_M,
 -			HCLGE_MAC_EPORT_VFID_S, vport->vport_id);
 -	req.egress_port = cpu_to_le16(egress_port);
 -	hclge_prepare_mac_addr(&req, mac_addr, false);
 -
 -	if (hclge_lookup_mac_vlan_tbl(vport, &req, &desc, false) != -ENOENT)
 -		return true;
 -
 -	vf_idx += HCLGE_VF_VPORT_START_NUM;
 -	for (i = HCLGE_VF_VPORT_START_NUM; i < hdev->num_alloc_vport; i++)
 -		if (i != vf_idx &&
 -		    ether_addr_equal(mac_addr, hdev->vport[i].vf_info.mac))
 -			return true;
 -
 -	return false;
 -}
 -
 -static int hclge_set_vf_mac(struct hnae3_handle *handle, int vf,
 -			    u8 *mac_addr)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -
 -	vport = hclge_get_vf_vport(hdev, vf);
 -	if (!vport)
 -		return -EINVAL;
 -
 -	if (ether_addr_equal(mac_addr, vport->vf_info.mac)) {
 -		dev_info(&hdev->pdev->dev,
 -			 "Specified MAC(=%pM) is same as before, no change committed!\n",
 -			 mac_addr);
 -		return 0;
 -	}
 -
 -	if (hclge_check_vf_mac_exist(vport, vf, mac_addr)) {
 -		dev_err(&hdev->pdev->dev, "Specified MAC(=%pM) exists!\n",
 -			mac_addr);
 -		return -EEXIST;
 -	}
 -
 -	ether_addr_copy(vport->vf_info.mac, mac_addr);
 -
 -	if (test_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state)) {
 -		dev_info(&hdev->pdev->dev,
 -			 "MAC of VF %d has been set to %pM, and it will be reinitialized!\n",
 -			 vf, mac_addr);
 -		return hclge_inform_reset_assert_to_vf(vport);
 -	}
 -
 -	dev_info(&hdev->pdev->dev, "MAC of VF %d has been set to %pM\n",
 -		 vf, mac_addr);
 -	return 0;
 -}
 -
 -static int hclge_add_mgr_tbl(struct hclge_dev *hdev,
 -			     const struct hclge_mac_mgr_tbl_entry_cmd *req)
 -{
 -	struct hclge_desc desc;
 -	u8 resp_code;
 -	u16 retval;
 -	int ret;
 -
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_ETHTYPE_ADD, false);
 -	memcpy(desc.data, req, sizeof(struct hclge_mac_mgr_tbl_entry_cmd));
 -
 -	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"add mac ethertype failed for cmd_send, ret =%d.\n",
 -			ret);
 -		return ret;
 -	}
 -
 -	resp_code = (le32_to_cpu(desc.data[0]) >> 8) & 0xff;
 -	retval = le16_to_cpu(desc.retval);
 -
 -	return hclge_get_mac_ethertype_cmd_status(hdev, retval, resp_code);
 -}
 -
 -static int init_mgr_tbl(struct hclge_dev *hdev)
 -{
 -	int ret;
 -	int i;
 -
 -	for (i = 0; i < ARRAY_SIZE(hclge_mgr_table); i++) {
 -		ret = hclge_add_mgr_tbl(hdev, &hclge_mgr_table[i]);
 -		if (ret) {
 -			dev_err(&hdev->pdev->dev,
 -				"add mac ethertype failed, ret =%d.\n",
 -				ret);
 -			return ret;
 -		}
 -	}
 -
 -	return 0;
 -}
 -
 -static void hclge_get_mac_addr(struct hnae3_handle *handle, u8 *p)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -
 -	ether_addr_copy(p, hdev->hw.mac.mac_addr);
 -}
 -
 -int hclge_update_mac_node_for_dev_addr(struct hclge_vport *vport,
 -				       const u8 *old_addr, const u8 *new_addr)
 -{
 -	struct list_head *list = &vport->uc_mac_list;
 -	struct hclge_mac_node *old_node, *new_node;
 -
 -	new_node = hclge_find_mac_node(list, new_addr);
 -	if (!new_node) {
 -		new_node = kzalloc(sizeof(*new_node), GFP_ATOMIC);
 -		if (!new_node)
 -			return -ENOMEM;
 -
 -		new_node->state = HCLGE_MAC_TO_ADD;
 -		ether_addr_copy(new_node->mac_addr, new_addr);
 -		list_add(&new_node->node, list);
 -	} else {
 -		if (new_node->state == HCLGE_MAC_TO_DEL)
 -			new_node->state = HCLGE_MAC_ACTIVE;
 -
 -		/* make sure the new addr is in the list head, avoid dev
 -		 * addr may be not re-added into mac table for the umv space
 -		 * limitation after global/imp reset which will clear mac
 -		 * table by hardware.
 -		 */
 -		list_move(&new_node->node, list);
 -	}
 -
 -	if (old_addr && !ether_addr_equal(old_addr, new_addr)) {
 -		old_node = hclge_find_mac_node(list, old_addr);
 -		if (old_node) {
 -			if (old_node->state == HCLGE_MAC_TO_ADD) {
 -				list_del(&old_node->node);
 -				kfree(old_node);
 -			} else {
 -				old_node->state = HCLGE_MAC_TO_DEL;
 -			}
 -		}
 -	}
 -
 -	set_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE, &vport->state);
 -
 -	return 0;
 -}
 -
 -static int hclge_set_mac_addr(struct hnae3_handle *handle, const void *p,
 -			      bool is_first)
 -{
 -	const unsigned char *new_addr = (const unsigned char *)p;
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -	unsigned char *old_addr = NULL;
 -	int ret;
 -
 -	/* mac addr check */
 -	if (is_zero_ether_addr(new_addr) ||
 -	    is_broadcast_ether_addr(new_addr) ||
 -	    is_multicast_ether_addr(new_addr)) {
 -		dev_err(&hdev->pdev->dev,
 -			"change uc mac err! invalid mac: %pM.\n",
 -			 new_addr);
 -		return -EINVAL;
 -	}
 -
 -	ret = hclge_pause_addr_cfg(hdev, new_addr);
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"failed to configure mac pause address, ret = %d\n",
 -			ret);
 -		return ret;
 -	}
 -
 -	if (!is_first)
 -		old_addr = hdev->hw.mac.mac_addr;
 -
 -	spin_lock_bh(&vport->mac_list_lock);
 -	ret = hclge_update_mac_node_for_dev_addr(vport, old_addr, new_addr);
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"failed to change the mac addr:%pM, ret = %d\n",
 -			new_addr, ret);
 -		spin_unlock_bh(&vport->mac_list_lock);
 -
 -		if (!is_first)
 -			hclge_pause_addr_cfg(hdev, old_addr);
 -
 -		return ret;
 -	}
 -	/* we must update dev addr with spin lock protect, preventing dev addr
 -	 * being removed by set_rx_mode path.
 -	 */
 -	ether_addr_copy(hdev->hw.mac.mac_addr, new_addr);
 -	spin_unlock_bh(&vport->mac_list_lock);
 -
 -	hclge_task_schedule(hdev, 0);
 -
 -	return 0;
 -}
 -
 -static int hclge_mii_ioctl(struct hclge_dev *hdev, struct ifreq *ifr, int cmd)
 -{
 -	struct mii_ioctl_data *data = if_mii(ifr);
 -
 -	if (!hnae3_dev_phy_imp_supported(hdev))
 -		return -EOPNOTSUPP;
 -
 -	switch (cmd) {
 -	case SIOCGMIIPHY:
 -		data->phy_id = hdev->hw.mac.phy_addr;
 -		/* this command reads phy id and register at the same time */
 -		fallthrough;
 -	case SIOCGMIIREG:
 -		data->val_out = hclge_read_phy_reg(hdev, data->reg_num);
 -		return 0;
 -
 -	case SIOCSMIIREG:
 -		return hclge_write_phy_reg(hdev, data->reg_num, data->val_in);
 -	default:
 -		return -EOPNOTSUPP;
 -	}
 -}
 -
 -static int hclge_do_ioctl(struct hnae3_handle *handle, struct ifreq *ifr,
 -			  int cmd)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -
 -	switch (cmd) {
 -	case SIOCGHWTSTAMP:
 -		return hclge_ptp_get_cfg(hdev, ifr);
 -	case SIOCSHWTSTAMP:
 -		return hclge_ptp_set_cfg(hdev, ifr);
 -	default:
 -		if (!hdev->hw.mac.phydev)
 -			return hclge_mii_ioctl(hdev, ifr, cmd);
 -	}
 -
 -	return phy_mii_ioctl(hdev->hw.mac.phydev, ifr, cmd);
 -}
 -
 -static int hclge_set_port_vlan_filter_bypass(struct hclge_dev *hdev, u8 vf_id,
 -					     bool bypass_en)
 -{
 -	struct hclge_port_vlan_filter_bypass_cmd *req;
 -	struct hclge_desc desc;
 -	int ret;
 -
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_PORT_VLAN_BYPASS, false);
 -	req = (struct hclge_port_vlan_filter_bypass_cmd *)desc.data;
 -	req->vf_id = vf_id;
 -	hnae3_set_bit(req->bypass_state, HCLGE_INGRESS_BYPASS_B,
 -		      bypass_en ? 1 : 0);
 -
 -	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (ret)
 -		dev_err(&hdev->pdev->dev,
 -			"failed to set vport%u port vlan filter bypass state, ret = %d.\n",
 -			vf_id, ret);
 -
 -	return ret;
 -}
 -
 -static int hclge_set_vlan_filter_ctrl(struct hclge_dev *hdev, u8 vlan_type,
 -				      u8 fe_type, bool filter_en, u8 vf_id)
 -{
 -	struct hclge_vlan_filter_ctrl_cmd *req;
 -	struct hclge_desc desc;
 -	int ret;
 -
 -	/* read current vlan filter parameter */
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_FILTER_CTRL, true);
 -	req = (struct hclge_vlan_filter_ctrl_cmd *)desc.data;
 -	req->vlan_type = vlan_type;
 -	req->vf_id = vf_id;
 -
 -	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"failed to get vlan filter config, ret = %d.\n", ret);
 -		return ret;
 -	}
 -
 -	/* modify and write new config parameter */
 -	hclge_cmd_reuse_desc(&desc, false);
 -	req->vlan_fe = filter_en ?
 -			(req->vlan_fe | fe_type) : (req->vlan_fe & ~fe_type);
 -
 -	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (ret)
 -		dev_err(&hdev->pdev->dev, "failed to set vlan filter, ret = %d.\n",
 -			ret);
 -
 -	return ret;
 -}
 -
 -static int hclge_set_vport_vlan_filter(struct hclge_vport *vport, bool enable)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -	struct hnae3_ae_dev *ae_dev = hdev->ae_dev;
 -	int ret;
 -
 -	if (hdev->ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2)
 -		return hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_VF,
 -						  HCLGE_FILTER_FE_EGRESS_V1_B,
 -						  enable, vport->vport_id);
 -
 -	ret = hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_VF,
 -					 HCLGE_FILTER_FE_EGRESS, enable,
 -					 vport->vport_id);
 -	if (ret)
 -		return ret;
 -
 -	if (test_bit(HNAE3_DEV_SUPPORT_PORT_VLAN_BYPASS_B, ae_dev->caps)) {
 -		ret = hclge_set_port_vlan_filter_bypass(hdev, vport->vport_id,
 -							!enable);
 -	} else if (!vport->vport_id) {
 -		if (test_bit(HNAE3_DEV_SUPPORT_VLAN_FLTR_MDF_B, ae_dev->caps))
 -			enable = false;
 -
 -		ret = hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_PORT,
 -						 HCLGE_FILTER_FE_INGRESS,
 -						 enable, 0);
 -	}
 -
 -	return ret;
 -}
 -
 -static bool hclge_need_enable_vport_vlan_filter(struct hclge_vport *vport)
 -{
 -	struct hnae3_handle *handle = &vport->nic;
 -	struct hclge_vport_vlan_cfg *vlan, *tmp;
 -	struct hclge_dev *hdev = vport->back;
 -
 -	if (vport->vport_id) {
 -		if (vport->port_base_vlan_cfg.state !=
 -			HNAE3_PORT_BASE_VLAN_DISABLE)
 -			return true;
 -
 -		if (vport->vf_info.trusted && vport->vf_info.request_uc_en)
 -			return false;
 -	} else if (handle->netdev_flags & HNAE3_USER_UPE) {
 -		return false;
 -	}
 -
 -	if (!vport->req_vlan_fltr_en)
 -		return false;
 -
 -	/* compatible with former device, always enable vlan filter */
 -	if (!test_bit(HNAE3_DEV_SUPPORT_VLAN_FLTR_MDF_B, hdev->ae_dev->caps))
 -		return true;
 -
 -	list_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node)
 -		if (vlan->vlan_id != 0)
 -			return true;
 -
 -	return false;
 -}
 -
 -int hclge_enable_vport_vlan_filter(struct hclge_vport *vport, bool request_en)
 -{
 -	struct hclge_dev *hdev = vport->back;
 -	bool need_en;
 -	int ret;
 -
 -	mutex_lock(&hdev->vport_lock);
 -
 -	vport->req_vlan_fltr_en = request_en;
 -
 -	need_en = hclge_need_enable_vport_vlan_filter(vport);
 -	if (need_en == vport->cur_vlan_fltr_en) {
 -		mutex_unlock(&hdev->vport_lock);
 -		return 0;
 -	}
 -
 -	ret = hclge_set_vport_vlan_filter(vport, need_en);
 -	if (ret) {
 -		mutex_unlock(&hdev->vport_lock);
 -		return ret;
 -	}
 -
 -	vport->cur_vlan_fltr_en = need_en;
 -
 -	mutex_unlock(&hdev->vport_lock);
 -
 -	return 0;
 -}
 -
 -static int hclge_enable_vlan_filter(struct hnae3_handle *handle, bool enable)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -
 -	return hclge_enable_vport_vlan_filter(vport, enable);
 -}
 -
 -static int hclge_set_vf_vlan_filter_cmd(struct hclge_dev *hdev, u16 vfid,
 -					bool is_kill, u16 vlan,
 -					struct hclge_desc *desc)
 -{
 -	struct hclge_vlan_filter_vf_cfg_cmd *req0;
 -	struct hclge_vlan_filter_vf_cfg_cmd *req1;
 -	u8 vf_byte_val;
 -	u8 vf_byte_off;
 -	int ret;
 -
 -	hclge_cmd_setup_basic_desc(&desc[0],
 -				   HCLGE_OPC_VLAN_FILTER_VF_CFG, false);
 -	hclge_cmd_setup_basic_desc(&desc[1],
 -				   HCLGE_OPC_VLAN_FILTER_VF_CFG, false);
 -
 -	desc[0].flag |= cpu_to_le16(HCLGE_CMD_FLAG_NEXT);
 -
 -	vf_byte_off = vfid / 8;
 -	vf_byte_val = 1 << (vfid % 8);
 -
 -	req0 = (struct hclge_vlan_filter_vf_cfg_cmd *)desc[0].data;
 -	req1 = (struct hclge_vlan_filter_vf_cfg_cmd *)desc[1].data;
 -
 -	req0->vlan_id  = cpu_to_le16(vlan);
 -	req0->vlan_cfg = is_kill;
 -
 -	if (vf_byte_off < HCLGE_MAX_VF_BYTES)
 -		req0->vf_bitmap[vf_byte_off] = vf_byte_val;
 -	else
 -		req1->vf_bitmap[vf_byte_off - HCLGE_MAX_VF_BYTES] = vf_byte_val;
 -
 -	ret = hclge_cmd_send(&hdev->hw, desc, 2);
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"Send vf vlan command fail, ret =%d.\n",
 -			ret);
 -		return ret;
 -	}
 -
 -	return 0;
 -}
 -
 -static int hclge_check_vf_vlan_cmd_status(struct hclge_dev *hdev, u16 vfid,
 -					  bool is_kill, struct hclge_desc *desc)
 -{
 -	struct hclge_vlan_filter_vf_cfg_cmd *req;
 -
 -	req = (struct hclge_vlan_filter_vf_cfg_cmd *)desc[0].data;
 -
 -	if (!is_kill) {
 -#define HCLGE_VF_VLAN_NO_ENTRY	2
 -		if (!req->resp_code || req->resp_code == 1)
 -			return 0;
 -
 -		if (req->resp_code == HCLGE_VF_VLAN_NO_ENTRY) {
 -			set_bit(vfid, hdev->vf_vlan_full);
 -			dev_warn(&hdev->pdev->dev,
 -				 "vf vlan table is full, vf vlan filter is disabled\n");
 -			return 0;
 -		}
 -
 -		dev_err(&hdev->pdev->dev,
 -			"Add vf vlan filter fail, ret =%u.\n",
 -			req->resp_code);
 -	} else {
 -#define HCLGE_VF_VLAN_DEL_NO_FOUND	1
 -		if (!req->resp_code)
 -			return 0;
 -
 -		/* vf vlan filter is disabled when vf vlan table is full,
 -		 * then new vlan id will not be added into vf vlan table.
 -		 * Just return 0 without warning, avoid massive verbose
 -		 * print logs when unload.
 -		 */
 -		if (req->resp_code == HCLGE_VF_VLAN_DEL_NO_FOUND)
 -			return 0;
 -
 -		dev_err(&hdev->pdev->dev,
 -			"Kill vf vlan filter fail, ret =%u.\n",
 -			req->resp_code);
 -	}
 -
 -	return -EIO;
 -}
 -
 -static int hclge_set_vf_vlan_common(struct hclge_dev *hdev, u16 vfid,
 -				    bool is_kill, u16 vlan)
 -{
 -	struct hclge_vport *vport = &hdev->vport[vfid];
 -	struct hclge_desc desc[2];
 -	int ret;
 -
 -	/* if vf vlan table is full, firmware will close vf vlan filter, it
 -	 * is unable and unnecessary to add new vlan id to vf vlan filter.
 -	 * If spoof check is enable, and vf vlan is full, it shouldn't add
 -	 * new vlan, because tx packets with these vlan id will be dropped.
 -	 */
 -	if (test_bit(vfid, hdev->vf_vlan_full) && !is_kill) {
 -		if (vport->vf_info.spoofchk && vlan) {
 -			dev_err(&hdev->pdev->dev,
 -				"Can't add vlan due to spoof check is on and vf vlan table is full\n");
 -			return -EPERM;
 -		}
 -		return 0;
 -	}
 -
 -	ret = hclge_set_vf_vlan_filter_cmd(hdev, vfid, is_kill, vlan, desc);
 -	if (ret)
 -		return ret;
 -
 -	return hclge_check_vf_vlan_cmd_status(hdev, vfid, is_kill, desc);
 -}
 -
 -static int hclge_set_port_vlan_filter(struct hclge_dev *hdev, __be16 proto,
 -				      u16 vlan_id, bool is_kill)
 -{
 -	struct hclge_vlan_filter_pf_cfg_cmd *req;
 -	struct hclge_desc desc;
 -	u8 vlan_offset_byte_val;
 -	u8 vlan_offset_byte;
 -	u8 vlan_offset_160;
 -	int ret;
 -
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_FILTER_PF_CFG, false);
 -
 -	vlan_offset_160 = vlan_id / HCLGE_VLAN_ID_OFFSET_STEP;
 -	vlan_offset_byte = (vlan_id % HCLGE_VLAN_ID_OFFSET_STEP) /
 -			   HCLGE_VLAN_BYTE_SIZE;
 -	vlan_offset_byte_val = 1 << (vlan_id % HCLGE_VLAN_BYTE_SIZE);
 -
 -	req = (struct hclge_vlan_filter_pf_cfg_cmd *)desc.data;
 -	req->vlan_offset = vlan_offset_160;
 -	req->vlan_cfg = is_kill;
 -	req->vlan_offset_bitmap[vlan_offset_byte] = vlan_offset_byte_val;
 -
 -	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (ret)
 -		dev_err(&hdev->pdev->dev,
 -			"port vlan command, send fail, ret =%d.\n", ret);
 -	return ret;
 -}
 -
 -static int hclge_set_vlan_filter_hw(struct hclge_dev *hdev, __be16 proto,
 -				    u16 vport_id, u16 vlan_id,
 -				    bool is_kill)
 -{
 -	u16 vport_idx, vport_num = 0;
 -	int ret;
 -
 -	if (is_kill && !vlan_id)
 -		return 0;
 -
 -	if (vlan_id >= VLAN_N_VID)
 -		return -EINVAL;
 -
 -	ret = hclge_set_vf_vlan_common(hdev, vport_id, is_kill, vlan_id);
 -	if (ret) {
 -		dev_err(&hdev->pdev->dev,
 -			"Set %u vport vlan filter config fail, ret =%d.\n",
 -			vport_id, ret);
 -		return ret;
 -	}
 -
 -	/* vlan 0 may be added twice when 8021q module is enabled */
 -	if (!is_kill && !vlan_id &&
 -	    test_bit(vport_id, hdev->vlan_table[vlan_id]))
 -		return 0;
 -
 -	if (!is_kill && test_and_set_bit(vport_id, hdev->vlan_table[vlan_id])) {
 -		dev_err(&hdev->pdev->dev,
 -			"Add port vlan failed, vport %u is already in vlan %u\n",
 -			vport_id, vlan_id);
 -		return -EINVAL;
 -	}
 -
 -	if (is_kill &&
 -	    !test_and_clear_bit(vport_id, hdev->vlan_table[vlan_id])) {
 -		dev_err(&hdev->pdev->dev,
 -			"Delete port vlan failed, vport %u is not in vlan %u\n",
 -			vport_id, vlan_id);
 -		return -EINVAL;
 -	}
 -
 -	for_each_set_bit(vport_idx, hdev->vlan_table[vlan_id], HCLGE_VPORT_NUM)
 -		vport_num++;
 -
 -	if ((is_kill && vport_num == 0) || (!is_kill && vport_num == 1))
 -		ret = hclge_set_port_vlan_filter(hdev, proto, vlan_id,
 -						 is_kill);
 -
 -	return ret;
 -}
 -
 -static int hclge_set_vlan_tx_offload_cfg(struct hclge_vport *vport)
 -{
 -	struct hclge_tx_vtag_cfg *vcfg = &vport->txvlan_cfg;
 -	struct hclge_vport_vtag_tx_cfg_cmd *req;
 -	struct hclge_dev *hdev = vport->back;
 -	struct hclge_desc desc;
 -	u16 bmap_index;
 -	int status;
 -
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_PORT_TX_CFG, false);
 -
 -	req = (struct hclge_vport_vtag_tx_cfg_cmd *)desc.data;
 -	req->def_vlan_tag1 = cpu_to_le16(vcfg->default_tag1);
 -	req->def_vlan_tag2 = cpu_to_le16(vcfg->default_tag2);
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_ACCEPT_TAG1_B,
 -		      vcfg->accept_tag1 ? 1 : 0);
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_ACCEPT_UNTAG1_B,
 -		      vcfg->accept_untag1 ? 1 : 0);
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_ACCEPT_TAG2_B,
 -		      vcfg->accept_tag2 ? 1 : 0);
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_ACCEPT_UNTAG2_B,
 -		      vcfg->accept_untag2 ? 1 : 0);
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_PORT_INS_TAG1_EN_B,
 -		      vcfg->insert_tag1_en ? 1 : 0);
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_PORT_INS_TAG2_EN_B,
 -		      vcfg->insert_tag2_en ? 1 : 0);
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_TAG_SHIFT_MODE_EN_B,
 -		      vcfg->tag_shift_mode_en ? 1 : 0);
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_CFG_NIC_ROCE_SEL_B, 0);
 -
 -	req->vf_offset = vport->vport_id / HCLGE_VF_NUM_PER_CMD;
 -	bmap_index = vport->vport_id % HCLGE_VF_NUM_PER_CMD /
 -			HCLGE_VF_NUM_PER_BYTE;
 -	req->vf_bitmap[bmap_index] =
 -		1U << (vport->vport_id % HCLGE_VF_NUM_PER_BYTE);
 -
 -	status = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (status)
 -		dev_err(&hdev->pdev->dev,
 -			"Send port txvlan cfg command fail, ret =%d\n",
 -			status);
 -
 -	return status;
 -}
 -
 -static int hclge_set_vlan_rx_offload_cfg(struct hclge_vport *vport)
 -{
 -	struct hclge_rx_vtag_cfg *vcfg = &vport->rxvlan_cfg;
 -	struct hclge_vport_vtag_rx_cfg_cmd *req;
 -	struct hclge_dev *hdev = vport->back;
 -	struct hclge_desc desc;
 -	u16 bmap_index;
 -	int status;
 -
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_PORT_RX_CFG, false);
 -
 -	req = (struct hclge_vport_vtag_rx_cfg_cmd *)desc.data;
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_REM_TAG1_EN_B,
 -		      vcfg->strip_tag1_en ? 1 : 0);
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_REM_TAG2_EN_B,
 -		      vcfg->strip_tag2_en ? 1 : 0);
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_SHOW_TAG1_EN_B,
 -		      vcfg->vlan1_vlan_prionly ? 1 : 0);
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_SHOW_TAG2_EN_B,
 -		      vcfg->vlan2_vlan_prionly ? 1 : 0);
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_DISCARD_TAG1_EN_B,
 -		      vcfg->strip_tag1_discard_en ? 1 : 0);
 -	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_DISCARD_TAG2_EN_B,
 -		      vcfg->strip_tag2_discard_en ? 1 : 0);
 -
 -	req->vf_offset = vport->vport_id / HCLGE_VF_NUM_PER_CMD;
 -	bmap_index = vport->vport_id % HCLGE_VF_NUM_PER_CMD /
 -			HCLGE_VF_NUM_PER_BYTE;
 -	req->vf_bitmap[bmap_index] =
 -		1U << (vport->vport_id % HCLGE_VF_NUM_PER_BYTE);
 -
 -	status = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (status)
 -		dev_err(&hdev->pdev->dev,
 -			"Send port rxvlan cfg command fail, ret =%d\n",
 -			status);
 -
 -	return status;
 -}
 -
 -static int hclge_vlan_offload_cfg(struct hclge_vport *vport,
 -				  u16 port_base_vlan_state,
 -				  u16 vlan_tag, u8 qos)
 -{
 -	int ret;
 -
 -	if (port_base_vlan_state == HNAE3_PORT_BASE_VLAN_DISABLE) {
 -		vport->txvlan_cfg.accept_tag1 = true;
 -		vport->txvlan_cfg.insert_tag1_en = false;
 -		vport->txvlan_cfg.default_tag1 = 0;
 -	} else {
 -		struct hnae3_ae_dev *ae_dev = pci_get_drvdata(vport->nic.pdev);
 -
 -		vport->txvlan_cfg.accept_tag1 =
 -			ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V3;
 -		vport->txvlan_cfg.insert_tag1_en = true;
 -		vport->txvlan_cfg.default_tag1 = (qos << VLAN_PRIO_SHIFT) |
 -						 vlan_tag;
 -	}
 -
 -	vport->txvlan_cfg.accept_untag1 = true;
 -
 -	/* accept_tag2 and accept_untag2 are not supported on
 -	 * pdev revision(0x20), new revision support them,
 -	 * this two fields can not be configured by user.
 -	 */
 -	vport->txvlan_cfg.accept_tag2 = true;
 -	vport->txvlan_cfg.accept_untag2 = true;
 -	vport->txvlan_cfg.insert_tag2_en = false;
 -	vport->txvlan_cfg.default_tag2 = 0;
 -	vport->txvlan_cfg.tag_shift_mode_en = true;
 -
 -	if (port_base_vlan_state == HNAE3_PORT_BASE_VLAN_DISABLE) {
 -		vport->rxvlan_cfg.strip_tag1_en = false;
 -		vport->rxvlan_cfg.strip_tag2_en =
 -				vport->rxvlan_cfg.rx_vlan_offload_en;
 -		vport->rxvlan_cfg.strip_tag2_discard_en = false;
 -	} else {
 -		vport->rxvlan_cfg.strip_tag1_en =
 -				vport->rxvlan_cfg.rx_vlan_offload_en;
 -		vport->rxvlan_cfg.strip_tag2_en = true;
 -		vport->rxvlan_cfg.strip_tag2_discard_en = true;
 -	}
 -
 -	vport->rxvlan_cfg.strip_tag1_discard_en = false;
 -	vport->rxvlan_cfg.vlan1_vlan_prionly = false;
 -	vport->rxvlan_cfg.vlan2_vlan_prionly = false;
 -
 -	ret = hclge_set_vlan_tx_offload_cfg(vport);
 -	if (ret)
 -		return ret;
 -
 -	return hclge_set_vlan_rx_offload_cfg(vport);
 -}
 -
 -static int hclge_set_vlan_protocol_type(struct hclge_dev *hdev)
 -{
 -	struct hclge_rx_vlan_type_cfg_cmd *rx_req;
 -	struct hclge_tx_vlan_type_cfg_cmd *tx_req;
 -	struct hclge_desc desc;
 -	int status;
 -
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_VLAN_TYPE_ID, false);
 -	rx_req = (struct hclge_rx_vlan_type_cfg_cmd *)desc.data;
 -	rx_req->ot_fst_vlan_type =
 -		cpu_to_le16(hdev->vlan_type_cfg.rx_ot_fst_vlan_type);
 -	rx_req->ot_sec_vlan_type =
 -		cpu_to_le16(hdev->vlan_type_cfg.rx_ot_sec_vlan_type);
 -	rx_req->in_fst_vlan_type =
 -		cpu_to_le16(hdev->vlan_type_cfg.rx_in_fst_vlan_type);
 -	rx_req->in_sec_vlan_type =
 -		cpu_to_le16(hdev->vlan_type_cfg.rx_in_sec_vlan_type);
 -
 -	status = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (status) {
 -		dev_err(&hdev->pdev->dev,
 -			"Send rxvlan protocol type command fail, ret =%d\n",
 -			status);
 -		return status;
 -	}
 -
 -	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_VLAN_INSERT, false);
 -
 -	tx_req = (struct hclge_tx_vlan_type_cfg_cmd *)desc.data;
 -	tx_req->ot_vlan_type = cpu_to_le16(hdev->vlan_type_cfg.tx_ot_vlan_type);
 -	tx_req->in_vlan_type = cpu_to_le16(hdev->vlan_type_cfg.tx_in_vlan_type);
 -
 -	status = hclge_cmd_send(&hdev->hw, &desc, 1);
 -	if (status)
 -		dev_err(&hdev->pdev->dev,
 -			"Send txvlan protocol type command fail, ret =%d\n",
 -			status);
 -
 -	return status;
 -}
 -
 -static int hclge_init_vlan_config(struct hclge_dev *hdev)
 -{
 -#define HCLGE_DEF_VLAN_TYPE		0x8100
 -
 -	struct hnae3_handle *handle = &hdev->vport[0].nic;
 -	struct hclge_vport *vport;
 -	int ret;
 -	int i;
 -
 -	if (hdev->ae_dev->dev_version >= HNAE3_DEVICE_VERSION_V2) {
 -		/* for revision 0x21, vf vlan filter is per function */
 -		for (i = 0; i < hdev->num_alloc_vport; i++) {
 -			vport = &hdev->vport[i];
 -			ret = hclge_set_vlan_filter_ctrl(hdev,
 -							 HCLGE_FILTER_TYPE_VF,
 -							 HCLGE_FILTER_FE_EGRESS,
 -							 true,
 -							 vport->vport_id);
 -			if (ret)
 -				return ret;
 -			vport->cur_vlan_fltr_en = true;
 -		}
 -
 -		ret = hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_PORT,
 -						 HCLGE_FILTER_FE_INGRESS, true,
 -						 0);
 -		if (ret)
 -			return ret;
 -	} else {
 -		ret = hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_VF,
 -						 HCLGE_FILTER_FE_EGRESS_V1_B,
 -						 true, 0);
 -		if (ret)
 -			return ret;
 -	}
 -
 -	hdev->vlan_type_cfg.rx_in_fst_vlan_type = HCLGE_DEF_VLAN_TYPE;
 -	hdev->vlan_type_cfg.rx_in_sec_vlan_type = HCLGE_DEF_VLAN_TYPE;
 -	hdev->vlan_type_cfg.rx_ot_fst_vlan_type = HCLGE_DEF_VLAN_TYPE;
 -	hdev->vlan_type_cfg.rx_ot_sec_vlan_type = HCLGE_DEF_VLAN_TYPE;
 -	hdev->vlan_type_cfg.tx_ot_vlan_type = HCLGE_DEF_VLAN_TYPE;
 -	hdev->vlan_type_cfg.tx_in_vlan_type = HCLGE_DEF_VLAN_TYPE;
 -
 -	ret = hclge_set_vlan_protocol_type(hdev);
 -	if (ret)
 -		return ret;
 -
 -	for (i = 0; i < hdev->num_alloc_vport; i++) {
 -		u16 vlan_tag;
 -		u8 qos;
 -
 -		vport = &hdev->vport[i];
 -		vlan_tag = vport->port_base_vlan_cfg.vlan_info.vlan_tag;
 -		qos = vport->port_base_vlan_cfg.vlan_info.qos;
 -
 -		ret = hclge_vlan_offload_cfg(vport,
 -					     vport->port_base_vlan_cfg.state,
 -					     vlan_tag, qos);
 -		if (ret)
 -			return ret;
 -	}
 -
 -	return hclge_set_vlan_filter(handle, htons(ETH_P_8021Q), 0, false);
 -}
 -
 -static void hclge_add_vport_vlan_table(struct hclge_vport *vport, u16 vlan_id,
 -				       bool writen_to_tbl)
 -{
 -	struct hclge_vport_vlan_cfg *vlan, *tmp;
 -
 -	list_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node)
 -		if (vlan->vlan_id == vlan_id)
 -			return;
 -
 -	vlan = kzalloc(sizeof(*vlan), GFP_KERNEL);
 -	if (!vlan)
 -		return;
++	struct list_head *list = &vport->uc_mac_list;
++	struct hclge_mac_node *old_node, *new_node;
+ 
 -	vlan->hd_tbl_status = writen_to_tbl;
 -	vlan->vlan_id = vlan_id;
++	new_node = hclge_find_mac_node(list, new_addr);
++	if (!new_node) {
++		new_node = kzalloc(sizeof(*new_node), GFP_ATOMIC);
++		if (!new_node)
++			return -ENOMEM;
+ 
 -	list_add_tail(&vlan->node, &vport->vlan_list);
 -}
++		new_node->state = HCLGE_MAC_TO_ADD;
++		ether_addr_copy(new_node->mac_addr, new_addr);
++		list_add(&new_node->node, list);
++	} else {
++		if (new_node->state == HCLGE_MAC_TO_DEL)
++			new_node->state = HCLGE_MAC_ACTIVE;
+ 
 -static int hclge_add_vport_all_vlan_table(struct hclge_vport *vport)
 -{
 -	struct hclge_vport_vlan_cfg *vlan, *tmp;
 -	struct hclge_dev *hdev = vport->back;
 -	int ret;
++		/* make sure the new addr is in the list head, avoid dev
++		 * addr may be not re-added into mac table for the umv space
++		 * limitation after global/imp reset which will clear mac
++		 * table by hardware.
++		 */
++		list_move(&new_node->node, list);
++	}
+ 
 -	list_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node) {
 -		if (!vlan->hd_tbl_status) {
 -			ret = hclge_set_vlan_filter_hw(hdev, htons(ETH_P_8021Q),
 -						       vport->vport_id,
 -						       vlan->vlan_id, false);
 -			if (ret) {
 -				dev_err(&hdev->pdev->dev,
 -					"restore vport vlan list failed, ret=%d\n",
 -					ret);
 -				return ret;
++	if (old_addr && !ether_addr_equal(old_addr, new_addr)) {
++		old_node = hclge_find_mac_node(list, old_addr);
++		if (old_node) {
++			if (old_node->state == HCLGE_MAC_TO_ADD) {
++				list_del(&old_node->node);
++				kfree(old_node);
++			} else {
++				old_node->state = HCLGE_MAC_TO_DEL;
+ 			}
+ 		}
 -		vlan->hd_tbl_status = true;
+ 	}
+ 
++	set_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE, &vport->state);
++
+ 	return 0;
+ }
+ 
 -static void hclge_rm_vport_vlan_table(struct hclge_vport *vport, u16 vlan_id,
 -				      bool is_write_tbl)
++static int hclge_set_mac_addr(struct hnae3_handle *handle, const void *p,
++>>>>>>> 766607570bec (ethernet: constify references to netdev->dev_addr in drivers)
 +			      bool is_first)
  {
 -	struct hclge_vport_vlan_cfg *vlan, *tmp;
 +	const unsigned char *new_addr = (const unsigned char *)p;
 +	struct hclge_vport *vport = hclge_get_vport(handle);
  	struct hclge_dev *hdev = vport->back;
 +	int ret;
  
 -	list_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node) {
 -		if (vlan->vlan_id == vlan_id) {
 -			if (is_write_tbl && vlan->hd_tbl_status)
 -				hclge_set_vlan_filter_hw(hdev,
 -							 htons(ETH_P_8021Q),
 -							 vport->vport_id,
 -							 vlan_id,
 -							 true);
 -
 -			list_del(&vlan->node);
 -			kfree(vlan);
 -			break;
 -		}
 +	/* mac addr check */
 +	if (is_zero_ether_addr(new_addr) ||
 +	    is_broadcast_ether_addr(new_addr) ||
 +	    is_multicast_ether_addr(new_addr)) {
 +		dev_err(&hdev->pdev->dev,
 +			"Change uc mac err! invalid mac:%p.\n",
 +			 new_addr);
 +		return -EINVAL;
  	}
 -}
  
 -void hclge_rm_vport_all_vlan_table(struct hclge_vport *vport, bool is_del_list)
 -{
 -	struct hclge_vport_vlan_cfg *vlan, *tmp;
 -	struct hclge_dev *hdev = vport->back;
 +	if (!is_first && hclge_rm_uc_addr(handle, hdev->hw.mac.mac_addr))
 +		dev_warn(&hdev->pdev->dev,
 +			 "remove old uc mac address fail.\n");
  
 -	list_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node) {
 -		if (vlan->hd_tbl_status)
 -			hclge_set_vlan_filter_hw(hdev,
 -						 htons(ETH_P_8021Q),
 -						 vport->vport_id,
 -						 vlan->vlan_id,
 -						 true);
 +	ret = hclge_add_uc_addr(handle, new_addr);
 +	if (ret) {
 +		dev_err(&hdev->pdev->dev,
 +			"add uc mac address fail, ret =%d.\n",
 +			ret);
  
 -		vlan->hd_tbl_status = false;
 -		if (is_del_list) {
 -			list_del(&vlan->node);
 -			kfree(vlan);
 -		}
 -	}
 -	clear_bit(vport->vport_id, hdev->vf_vlan_full);
 -}
 +		if (!is_first &&
 +		    hclge_add_uc_addr(handle, hdev->hw.mac.mac_addr))
 +			dev_err(&hdev->pdev->dev,
 +				"restore uc mac address fail.\n");
  
 -void hclge_uninit_vport_vlan_table(struct hclge_dev *hdev)
 -{
 -	struct hclge_vport_vlan_cfg *vlan, *tmp;
 -	struct hclge_vport *vport;
 -	int i;
 +		return -EIO;
 +	}
  
 -	for (i = 0; i < hdev->num_alloc_vport; i++) {
 -		vport = &hdev->vport[i];
 -		list_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node) {
 -			list_del(&vlan->node);
 -			kfree(vlan);
 -		}
 +	ret = hclge_pause_addr_cfg(hdev, new_addr);
 +	if (ret) {
 +		dev_err(&hdev->pdev->dev,
 +			"configure mac pause address fail, ret =%d.\n",
 +			ret);
 +		return -EIO;
  	}
 +
 +	ether_addr_copy(hdev->hw.mac.mac_addr, new_addr);
 +
 +	return 0;
  }
  
 -void hclge_restore_vport_vlan_table(struct hclge_vport *vport)
 +static int hclge_set_vlan_filter_ctrl(struct hclge_dev *hdev, u8 vlan_type,
 +				      u8 fe_type, bool filter_en)
  {
 -	struct hclge_vport_vlan_cfg *vlan, *tmp;
 -	struct hclge_dev *hdev = vport->back;
 -	u16 vlan_proto;
 -	u16 vlan_id;
 -	u16 state;
 +	struct hclge_vlan_filter_ctrl_cmd *req;
 +	struct hclge_desc desc;
  	int ret;
  
 -	vlan_proto = vport->port_base_vlan_cfg.vlan_info.vlan_proto;
 -	vlan_id = vport->port_base_vlan_cfg.vlan_info.vlan_tag;
 -	state = vport->port_base_vlan_cfg.state;
 +	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_FILTER_CTRL, false);
  
 -	if (state != HNAE3_PORT_BASE_VLAN_DISABLE) {
 -		clear_bit(vport->vport_id, hdev->vlan_table[vlan_id]);
 -		hclge_set_vlan_filter_hw(hdev, htons(vlan_proto),
 -					 vport->vport_id, vlan_id,
 -					 false);
 -		return;
 -	}
 +	req = (struct hclge_vlan_filter_ctrl_cmd *)desc.data;
 +	req->vlan_type = vlan_type;
 +	req->vlan_fe = filter_en ? fe_type : 0;
  
 -	list_for_each_entry_safe(vlan, tmp, &vport->vlan_list, node) {
 -		ret = hclge_set_vlan_filter_hw(hdev, htons(ETH_P_8021Q),
 -					       vport->vport_id,
 -					       vlan->vlan_id, false);
 -		if (ret)
 -			break;
 -		vlan->hd_tbl_status = true;
 +	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 +	if (ret) {
 +		dev_err(&hdev->pdev->dev, "set vlan filter fail, ret =%d.\n",
 +			ret);
 +		return ret;
  	}
 +
 +	return 0;
  }
  
 -/* For global reset and imp reset, hardware will clear the mac table,
 - * so we change the mac address state from ACTIVE to TO_ADD, then they
 - * can be restored in the service task after reset complete. Furtherly,
 - * the mac addresses with state TO_DEL or DEL_FAIL are unnecessary to
 - * be restored after reset, so just remove these mac nodes from mac_list.
 - */
 -static void hclge_mac_node_convert_for_reset(struct list_head *list)
 +#define HCLGE_FILTER_TYPE_VF		0
 +#define HCLGE_FILTER_TYPE_PORT		1
 +#define HCLGE_FILTER_FE_EGRESS_V1_B	BIT(0)
 +#define HCLGE_FILTER_FE_NIC_INGRESS_B	BIT(0)
 +#define HCLGE_FILTER_FE_NIC_EGRESS_B	BIT(1)
 +#define HCLGE_FILTER_FE_ROCE_INGRESS_B	BIT(2)
 +#define HCLGE_FILTER_FE_ROCE_EGRESS_B	BIT(3)
 +#define HCLGE_FILTER_FE_EGRESS		(HCLGE_FILTER_FE_NIC_EGRESS_B \
 +					| HCLGE_FILTER_FE_ROCE_EGRESS_B)
 +#define HCLGE_FILTER_FE_INGRESS		(HCLGE_FILTER_FE_NIC_INGRESS_B \
 +					| HCLGE_FILTER_FE_ROCE_INGRESS_B)
 +
 +static void hclge_enable_vlan_filter(struct hnae3_handle *handle, bool enable)
  {
 -	struct hclge_mac_node *mac_node, *tmp;
 +	struct hclge_vport *vport = hclge_get_vport(handle);
 +	struct hclge_dev *hdev = vport->back;
  
 -	list_for_each_entry_safe(mac_node, tmp, list, node) {
 -		if (mac_node->state == HCLGE_MAC_ACTIVE) {
 -			mac_node->state = HCLGE_MAC_TO_ADD;
 -		} else if (mac_node->state == HCLGE_MAC_TO_DEL) {
 -			list_del(&mac_node->node);
 -			kfree(mac_node);
 -		}
 +	if (hdev->pdev->revision >= 0x21) {
 +		hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_VF,
 +					   HCLGE_FILTER_FE_EGRESS, enable);
 +		hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_PORT,
 +					   HCLGE_FILTER_FE_INGRESS, enable);
 +	} else {
 +		hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_VF,
 +					   HCLGE_FILTER_FE_EGRESS_V1_B, enable);
  	}
 +	if (enable)
 +		handle->netdev_flags |= HNAE3_VLAN_FLTR;
 +	else
 +		handle->netdev_flags &= ~HNAE3_VLAN_FLTR;
  }
  
 -void hclge_restore_mac_table_common(struct hclge_vport *vport)
 +static int hclge_set_vf_vlan_common(struct hclge_dev *hdev, int vfid,
 +				    bool is_kill, u16 vlan, u8 qos,
 +				    __be16 proto)
  {
 -	spin_lock_bh(&vport->mac_list_lock);
 +#define HCLGE_MAX_VF_BYTES  16
 +	struct hclge_vlan_filter_vf_cfg_cmd *req0;
 +	struct hclge_vlan_filter_vf_cfg_cmd *req1;
 +	struct hclge_desc desc[2];
 +	u8 vf_byte_val;
 +	u8 vf_byte_off;
 +	int ret;
  
 -	hclge_mac_node_convert_for_reset(&vport->uc_mac_list);
 -	hclge_mac_node_convert_for_reset(&vport->mc_mac_list);
 -	set_bit(HCLGE_VPORT_STATE_MAC_TBL_CHANGE, &vport->state);
 +	hclge_cmd_setup_basic_desc(&desc[0],
 +				   HCLGE_OPC_VLAN_FILTER_VF_CFG, false);
 +	hclge_cmd_setup_basic_desc(&desc[1],
 +				   HCLGE_OPC_VLAN_FILTER_VF_CFG, false);
  
 -	spin_unlock_bh(&vport->mac_list_lock);
 -}
 +	desc[0].flag |= cpu_to_le16(HCLGE_CMD_FLAG_NEXT);
  
 -static void hclge_restore_hw_table(struct hclge_dev *hdev)
 -{
 -	struct hclge_vport *vport = &hdev->vport[0];
 -	struct hnae3_handle *handle = &vport->nic;
 +	vf_byte_off = vfid / 8;
 +	vf_byte_val = 1 << (vfid % 8);
  
 -	hclge_restore_mac_table_common(vport);
 -	hclge_restore_vport_vlan_table(vport);
 -	set_bit(HCLGE_STATE_FD_USER_DEF_CHANGED, &hdev->state);
 -	hclge_restore_fd_entries(handle);
 -}
 +	req0 = (struct hclge_vlan_filter_vf_cfg_cmd *)desc[0].data;
 +	req1 = (struct hclge_vlan_filter_vf_cfg_cmd *)desc[1].data;
  
 -int hclge_en_hw_strip_rxvtag(struct hnae3_handle *handle, bool enable)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 +	req0->vlan_id  = cpu_to_le16(vlan);
 +	req0->vlan_cfg = is_kill;
  
 -	if (vport->port_base_vlan_cfg.state == HNAE3_PORT_BASE_VLAN_DISABLE) {
 -		vport->rxvlan_cfg.strip_tag1_en = false;
 -		vport->rxvlan_cfg.strip_tag2_en = enable;
 -		vport->rxvlan_cfg.strip_tag2_discard_en = false;
 -	} else {
 -		vport->rxvlan_cfg.strip_tag1_en = enable;
 -		vport->rxvlan_cfg.strip_tag2_en = true;
 -		vport->rxvlan_cfg.strip_tag2_discard_en = true;
 +	if (vf_byte_off < HCLGE_MAX_VF_BYTES)
 +		req0->vf_bitmap[vf_byte_off] = vf_byte_val;
 +	else
 +		req1->vf_bitmap[vf_byte_off - HCLGE_MAX_VF_BYTES] = vf_byte_val;
 +
 +	ret = hclge_cmd_send(&hdev->hw, desc, 2);
 +	if (ret) {
 +		dev_err(&hdev->pdev->dev,
 +			"Send vf vlan command fail, ret =%d.\n",
 +			ret);
 +		return ret;
  	}
  
 -	vport->rxvlan_cfg.strip_tag1_discard_en = false;
 -	vport->rxvlan_cfg.vlan1_vlan_prionly = false;
 -	vport->rxvlan_cfg.vlan2_vlan_prionly = false;
 -	vport->rxvlan_cfg.rx_vlan_offload_en = enable;
 +	if (!is_kill) {
 +#define HCLGE_VF_VLAN_NO_ENTRY	2
 +		if (!req0->resp_code || req0->resp_code == 1)
 +			return 0;
  
 -	return hclge_set_vlan_rx_offload_cfg(vport);
 -}
 +		if (req0->resp_code == HCLGE_VF_VLAN_NO_ENTRY) {
 +			dev_warn(&hdev->pdev->dev,
 +				 "vf vlan table is full, vf vlan filter is disabled\n");
 +			return 0;
 +		}
  
 -static void hclge_set_vport_vlan_fltr_change(struct hclge_vport *vport)
 -{
 -	struct hclge_dev *hdev = vport->back;
 +		dev_err(&hdev->pdev->dev,
 +			"Add vf vlan filter fail, ret =%d.\n",
 +			req0->resp_code);
 +	} else {
 +#define HCLGE_VF_VLAN_DEL_NO_FOUND	1
 +		if (!req0->resp_code)
 +			return 0;
 +
 +		if (req0->resp_code == HCLGE_VF_VLAN_DEL_NO_FOUND) {
 +			dev_warn_once(&hdev->pdev->dev,
 +				 "vlan %d filter is not in vf vlan table\n",
 +				 vlan);
 +			return 0;
 +		}
 +
 +		dev_err(&hdev->pdev->dev,
 +			"Kill vf vlan filter fail, ret =%d.\n",
 +			req0->resp_code);
 +	}
  
 -	if (test_bit(HNAE3_DEV_SUPPORT_VLAN_FLTR_MDF_B, hdev->ae_dev->caps))
 -		set_bit(HCLGE_VPORT_STATE_VLAN_FLTR_CHANGE, &vport->state);
 +	return -EIO;
  }
  
 -static int hclge_update_vlan_filter_entries(struct hclge_vport *vport,
 -					    u16 port_base_vlan_state,
 -					    struct hclge_vlan_info *new_info,
 -					    struct hclge_vlan_info *old_info)
 +static int hclge_set_port_vlan_filter(struct hclge_dev *hdev, __be16 proto,
 +				      u16 vlan_id, bool is_kill)
  {
 -	struct hclge_dev *hdev = vport->back;
 +	struct hclge_vlan_filter_pf_cfg_cmd *req;
 +	struct hclge_desc desc;
 +	u8 vlan_offset_byte_val;
 +	u8 vlan_offset_byte;
 +	u8 vlan_offset_160;
  	int ret;
  
 -	if (port_base_vlan_state == HNAE3_PORT_BASE_VLAN_ENABLE) {
 -		hclge_rm_vport_all_vlan_table(vport, false);
 -		/* force clear VLAN 0 */
 -		ret = hclge_set_vf_vlan_common(hdev, vport->vport_id, true, 0);
 -		if (ret)
 -			return ret;
 -		return hclge_set_vlan_filter_hw(hdev,
 -						 htons(new_info->vlan_proto),
 -						 vport->vport_id,
 -						 new_info->vlan_tag,
 -						 false);
 -	}
 +	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_FILTER_PF_CFG, false);
  
 -	/* force add VLAN 0 */
 -	ret = hclge_set_vf_vlan_common(hdev, vport->vport_id, false, 0);
 -	if (ret)
 -		return ret;
 +	vlan_offset_160 = vlan_id / 160;
 +	vlan_offset_byte = (vlan_id % 160) / 8;
 +	vlan_offset_byte_val = 1 << (vlan_id % 8);
  
 -	ret = hclge_set_vlan_filter_hw(hdev, htons(old_info->vlan_proto),
 -				       vport->vport_id, old_info->vlan_tag,
 -				       true);
 -	if (ret)
 -		return ret;
 +	req = (struct hclge_vlan_filter_pf_cfg_cmd *)desc.data;
 +	req->vlan_offset = vlan_offset_160;
 +	req->vlan_cfg = is_kill;
 +	req->vlan_offset_bitmap[vlan_offset_byte] = vlan_offset_byte_val;
  
 -	return hclge_add_vport_all_vlan_table(vport);
 +	ret = hclge_cmd_send(&hdev->hw, &desc, 1);
 +	if (ret)
 +		dev_err(&hdev->pdev->dev,
 +			"port vlan command, send fail, ret =%d.\n", ret);
 +	return ret;
  }
  
 -static bool hclge_need_update_vlan_filter(const struct hclge_vlan_info *new_cfg,
 -					  const struct hclge_vlan_info *old_cfg)
 +static int hclge_set_vlan_filter_hw(struct hclge_dev *hdev, __be16 proto,
 +				    u16 vport_id, u16 vlan_id, u8 qos,
 +				    bool is_kill)
  {
 -	if (new_cfg->vlan_tag != old_cfg->vlan_tag)
 -		return true;
 +	u16 vport_idx, vport_num = 0;
 +	int ret;
  
 -	if (new_cfg->vlan_tag == 0 && (new_cfg->qos == 0 || old_cfg->qos == 0))
 -		return true;
 +	if (is_kill && !vlan_id)
 +		return 0;
  
 -	return false;
 -}
 +	ret = hclge_set_vf_vlan_common(hdev, vport_id, is_kill, vlan_id,
 +				       0, proto);
 +	if (ret) {
 +		dev_err(&hdev->pdev->dev,
 +			"Set %d vport vlan filter config fail, ret =%d.\n",
 +			vport_id, ret);
 +		return ret;
 +	}
  
 -int hclge_update_port_base_vlan_cfg(struct hclge_vport *vport, u16 state,
 -				    struct hclge_vlan_info *vlan_info)
 -{
 -	struct hnae3_handle *nic = &vport->nic;
 -	struct hclge_vlan_info *old_vlan_info;
 -	struct hclge_dev *hdev = vport->back;
 -	int ret;
 +	/* vlan 0 may be added twice when 8021q module is enabled */
 +	if (!is_kill && !vlan_id &&
 +	    test_bit(vport_id, hdev->vlan_table[vlan_id]))
 +		return 0;
  
 -	old_vlan_info = &vport->port_base_vlan_cfg.vlan_info;
 +	if (!is_kill && test_and_set_bit(vport_id, hdev->vlan_table[vlan_id])) {
 +		dev_err(&hdev->pdev->dev,
 +			"Add port vlan failed, vport %d is already in vlan %d\n",
 +			vport_id, vlan_id);
 +		return -EINVAL;
 +	}
  
 -	ret = hclge_vlan_offload_cfg(vport, state, vlan_info->vlan_tag,
 -				     vlan_info->qos);
 -	if (ret)
 -		return ret;
 +	if (is_kill &&
 +	    !test_and_clear_bit(vport_id, hdev->vlan_table[vlan_id])) {
 +		dev_err(&hdev->pdev->dev,
 +			"Delete port vlan failed, vport %d is not in vlan %d\n",
 +			vport_id, vlan_id);
 +		return -EINVAL;
 +	}
  
 -	if (!hclge_need_update_vlan_filter(vlan_info, old_vlan_info))
 -		goto out;
 +	for_each_set_bit(vport_idx, hdev->vlan_table[vlan_id], HCLGE_VPORT_NUM)
 +		vport_num++;
  
 -	if (state == HNAE3_PORT_BASE_VLAN_MODIFY) {
 -		/* add new VLAN tag */
 -		ret = hclge_set_vlan_filter_hw(hdev,
 -					       htons(vlan_info->vlan_proto),
 -					       vport->vport_id,
 -					       vlan_info->vlan_tag,
 -					       false);
 -		if (ret)
 -			return ret;
 +	if ((is_kill && vport_num == 0) || (!is_kill && vport_num == 1))
 +		ret = hclge_set_port_vlan_filter(hdev, proto, vlan_id,
 +						 is_kill);
  
 -		/* remove old VLAN tag */
 -		if (old_vlan_info->vlan_tag == 0)
 -			ret = hclge_set_vf_vlan_common(hdev, vport->vport_id,
 -						       true, 0);
 -		else
 -			ret = hclge_set_vlan_filter_hw(hdev,
 -						       htons(ETH_P_8021Q),
 -						       vport->vport_id,
 -						       old_vlan_info->vlan_tag,
 -						       true);
 -		if (ret) {
 -			dev_err(&hdev->pdev->dev,
 -				"failed to clear vport%u port base vlan %u, ret = %d.\n",
 -				vport->vport_id, old_vlan_info->vlan_tag, ret);
 -			return ret;
 -		}
 +	return ret;
 +}
  
 -		goto out;
 -	}
 +int hclge_set_vlan_filter(struct hnae3_handle *handle, __be16 proto,
 +			  u16 vlan_id, bool is_kill)
 +{
 +	struct hclge_vport *vport = hclge_get_vport(handle);
 +	struct hclge_dev *hdev = vport->back;
  
 -	ret = hclge_update_vlan_filter_entries(vport, state, vlan_info,
 -					       old_vlan_info);
 -	if (ret)
 -		return ret;
 +	return hclge_set_vlan_filter_hw(hdev, proto, vport->vport_id, vlan_id,
 +					0, is_kill);
 +}
  
 -out:
 -	vport->port_base_vlan_cfg.state = state;
 -	if (state == HNAE3_PORT_BASE_VLAN_DISABLE)
 -		nic->port_base_vlan_state = HNAE3_PORT_BASE_VLAN_DISABLE;
 -	else
 -		nic->port_base_vlan_state = HNAE3_PORT_BASE_VLAN_ENABLE;
 +static int hclge_set_vf_vlan_filter(struct hnae3_handle *handle, int vfid,
 +				    u16 vlan, u8 qos, __be16 proto)
 +{
 +	struct hclge_vport *vport = hclge_get_vport(handle);
 +	struct hclge_dev *hdev = vport->back;
  
 -	vport->port_base_vlan_cfg.vlan_info = *vlan_info;
 -	hclge_set_vport_vlan_fltr_change(vport);
 +	if ((vfid >= hdev->num_alloc_vfs) || (vlan > 4095) || (qos > 7))
 +		return -EINVAL;
 +	if (proto != htons(ETH_P_8021Q))
 +		return -EPROTONOSUPPORT;
  
 -	return 0;
 +	return hclge_set_vlan_filter_hw(hdev, proto, vfid, vlan, qos, false);
  }
  
 -static u16 hclge_get_port_base_vlan_state(struct hclge_vport *vport,
 -					  enum hnae3_port_base_vlan_state state,
 -					  u16 vlan, u8 qos)
 +static int hclge_set_vlan_tx_offload_cfg(struct hclge_vport *vport)
  {
 -	if (state == HNAE3_PORT_BASE_VLAN_DISABLE) {
 -		if (!vlan && !qos)
 -			return HNAE3_PORT_BASE_VLAN_NOCHANGE;
 +	struct hclge_tx_vtag_cfg *vcfg = &vport->txvlan_cfg;
 +	struct hclge_vport_vtag_tx_cfg_cmd *req;
 +	struct hclge_dev *hdev = vport->back;
 +	struct hclge_desc desc;
 +	int status;
  
 -		return HNAE3_PORT_BASE_VLAN_ENABLE;
 -	}
 +	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_PORT_TX_CFG, false);
 +
 +	req = (struct hclge_vport_vtag_tx_cfg_cmd *)desc.data;
 +	req->def_vlan_tag1 = cpu_to_le16(vcfg->default_tag1);
 +	req->def_vlan_tag2 = cpu_to_le16(vcfg->default_tag2);
 +	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_ACCEPT_TAG1_B,
 +		      vcfg->accept_tag1 ? 1 : 0);
 +	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_ACCEPT_UNTAG1_B,
 +		      vcfg->accept_untag1 ? 1 : 0);
 +	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_ACCEPT_TAG2_B,
 +		      vcfg->accept_tag2 ? 1 : 0);
 +	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_ACCEPT_UNTAG2_B,
 +		      vcfg->accept_untag2 ? 1 : 0);
 +	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_PORT_INS_TAG1_EN_B,
 +		      vcfg->insert_tag1_en ? 1 : 0);
 +	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_PORT_INS_TAG2_EN_B,
 +		      vcfg->insert_tag2_en ? 1 : 0);
 +	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_CFG_NIC_ROCE_SEL_B, 0);
  
 -	if (!vlan && !qos)
 -		return HNAE3_PORT_BASE_VLAN_DISABLE;
 +	req->vf_offset = vport->vport_id / HCLGE_VF_NUM_PER_CMD;
 +	req->vf_bitmap[req->vf_offset] =
 +		1 << (vport->vport_id % HCLGE_VF_NUM_PER_BYTE);
  
 -	if (vport->port_base_vlan_cfg.vlan_info.vlan_tag == vlan &&
 -	    vport->port_base_vlan_cfg.vlan_info.qos == qos)
 -		return HNAE3_PORT_BASE_VLAN_NOCHANGE;
 +	status = hclge_cmd_send(&hdev->hw, &desc, 1);
 +	if (status)
 +		dev_err(&hdev->pdev->dev,
 +			"Send port txvlan cfg command fail, ret =%d\n",
 +			status);
  
 -	return HNAE3_PORT_BASE_VLAN_MODIFY;
 +	return status;
  }
  
 -static int hclge_set_vf_vlan_filter(struct hnae3_handle *handle, int vfid,
 -				    u16 vlan, u8 qos, __be16 proto)
 +static int hclge_set_vlan_rx_offload_cfg(struct hclge_vport *vport)
  {
 -	struct hnae3_ae_dev *ae_dev = pci_get_drvdata(handle->pdev);
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 +	struct hclge_rx_vtag_cfg *vcfg = &vport->rxvlan_cfg;
 +	struct hclge_vport_vtag_rx_cfg_cmd *req;
  	struct hclge_dev *hdev = vport->back;
 -	struct hclge_vlan_info vlan_info;
 -	u16 state;
 -	int ret;
 +	struct hclge_desc desc;
 +	int status;
  
 -	if (hdev->ae_dev->dev_version < HNAE3_DEVICE_VERSION_V2)
 -		return -EOPNOTSUPP;
 +	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_VLAN_PORT_RX_CFG, false);
  
 -	vport = hclge_get_vf_vport(hdev, vfid);
 -	if (!vport)
 -		return -EINVAL;
 +	req = (struct hclge_vport_vtag_rx_cfg_cmd *)desc.data;
 +	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_REM_TAG1_EN_B,
 +		      vcfg->strip_tag1_en ? 1 : 0);
 +	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_REM_TAG2_EN_B,
 +		      vcfg->strip_tag2_en ? 1 : 0);
 +	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_SHOW_TAG1_EN_B,
 +		      vcfg->vlan1_vlan_prionly ? 1 : 0);
 +	hnae3_set_bit(req->vport_vlan_cfg, HCLGE_SHOW_TAG2_EN_B,
 +		      vcfg->vlan2_vlan_prionly ? 1 : 0);
  
 -	/* qos is a 3 bits value, so can not be bigger than 7 */
 -	if (vlan > VLAN_N_VID - 1 || qos > 7)
 -		return -EINVAL;
 -	if (proto != htons(ETH_P_8021Q))
 -		return -EPROTONOSUPPORT;
 +	req->vf_offset = vport->vport_id / HCLGE_VF_NUM_PER_CMD;
 +	req->vf_bitmap[req->vf_offset] =
 +		1 << (vport->vport_id % HCLGE_VF_NUM_PER_BYTE);
  
 -	state = hclge_get_port_base_vlan_state(vport,
 -					       vport->port_base_vlan_cfg.state,
 -					       vlan, qos);
 -	if (state == HNAE3_PORT_BASE_VLAN_NOCHANGE)
 -		return 0;
 +	status = hclge_cmd_send(&hdev->hw, &desc, 1);
 +	if (status)
 +		dev_err(&hdev->pdev->dev,
 +			"Send port rxvlan cfg command fail, ret =%d\n",
 +			status);
  
 -	vlan_info.vlan_tag = vlan;
 -	vlan_info.qos = qos;
 -	vlan_info.vlan_proto = ntohs(proto);
 +	return status;
 +}
  
 -	ret = hclge_update_port_base_vlan_cfg(vport, state, &vlan_info);
 -	if (ret) {
 +static int hclge_set_vlan_protocol_type(struct hclge_dev *hdev)
 +{
 +	struct hclge_rx_vlan_type_cfg_cmd *rx_req;
 +	struct hclge_tx_vlan_type_cfg_cmd *tx_req;
 +	struct hclge_desc desc;
 +	int status;
 +
 +	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_VLAN_TYPE_ID, false);
 +	rx_req = (struct hclge_rx_vlan_type_cfg_cmd *)desc.data;
 +	rx_req->ot_fst_vlan_type =
 +		cpu_to_le16(hdev->vlan_type_cfg.rx_ot_fst_vlan_type);
 +	rx_req->ot_sec_vlan_type =
 +		cpu_to_le16(hdev->vlan_type_cfg.rx_ot_sec_vlan_type);
 +	rx_req->in_fst_vlan_type =
 +		cpu_to_le16(hdev->vlan_type_cfg.rx_in_fst_vlan_type);
 +	rx_req->in_sec_vlan_type =
 +		cpu_to_le16(hdev->vlan_type_cfg.rx_in_sec_vlan_type);
 +
 +	status = hclge_cmd_send(&hdev->hw, &desc, 1);
 +	if (status) {
  		dev_err(&hdev->pdev->dev,
 -			"failed to update port base vlan for vf %d, ret = %d\n",
 -			vfid, ret);
 -		return ret;
 +			"Send rxvlan protocol type command fail, ret =%d\n",
 +			status);
 +		return status;
  	}
  
 -	/* for DEVICE_VERSION_V3, vf doesn't need to know about the port based
 -	 * VLAN state.
 -	 */
 -	if (ae_dev->dev_version < HNAE3_DEVICE_VERSION_V3 &&
 -	    test_bit(HCLGE_VPORT_STATE_ALIVE, &vport->state))
 -		hclge_push_vf_port_base_vlan_info(&hdev->vport[0],
 -						  vport->vport_id, state,
 -						  &vlan_info);
 +	hclge_cmd_setup_basic_desc(&desc, HCLGE_OPC_MAC_VLAN_INSERT, false);
  
 -	return 0;
 +	tx_req = (struct hclge_tx_vlan_type_cfg_cmd *)&desc.data;
 +	tx_req->ot_vlan_type = cpu_to_le16(hdev->vlan_type_cfg.tx_ot_vlan_type);
 +	tx_req->in_vlan_type = cpu_to_le16(hdev->vlan_type_cfg.tx_in_vlan_type);
 +
 +	status = hclge_cmd_send(&hdev->hw, &desc, 1);
 +	if (status)
 +		dev_err(&hdev->pdev->dev,
 +			"Send txvlan protocol type command fail, ret =%d\n",
 +			status);
 +
 +	return status;
  }
  
 -static void hclge_clear_vf_vlan(struct hclge_dev *hdev)
 +static int hclge_init_vlan_config(struct hclge_dev *hdev)
  {
 -	struct hclge_vlan_info *vlan_info;
 +#define HCLGE_DEF_VLAN_TYPE		0x8100
 +
 +	struct hnae3_handle *handle = &hdev->vport[0].nic;
  	struct hclge_vport *vport;
  	int ret;
 -	int vf;
 +	int i;
  
 -	/* clear port base vlan for all vf */
 -	for (vf = HCLGE_VF_VPORT_START_NUM; vf < hdev->num_alloc_vport; vf++) {
 -		vport = &hdev->vport[vf];
 -		vlan_info = &vport->port_base_vlan_cfg.vlan_info;
 +	if (hdev->pdev->revision >= 0x21) {
 +		ret = hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_VF,
 +						 HCLGE_FILTER_FE_EGRESS, true);
 +		if (ret)
 +			return ret;
  
 -		ret = hclge_set_vlan_filter_hw(hdev, htons(ETH_P_8021Q),
 -					       vport->vport_id,
 -					       vlan_info->vlan_tag, true);
 +		ret = hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_PORT,
 +						 HCLGE_FILTER_FE_INGRESS, true);
  		if (ret)
 -			dev_err(&hdev->pdev->dev,
 -				"failed to clear vf vlan for vf%d, ret = %d\n",
 -				vf - HCLGE_VF_VPORT_START_NUM, ret);
 +			return ret;
 +	} else {
 +		ret = hclge_set_vlan_filter_ctrl(hdev, HCLGE_FILTER_TYPE_VF,
 +						 HCLGE_FILTER_FE_EGRESS_V1_B,
 +						 true);
 +		if (ret)
 +			return ret;
  	}
 -}
  
 -int hclge_set_vlan_filter(struct hnae3_handle *handle, __be16 proto,
 -			  u16 vlan_id, bool is_kill)
 -{
 -	struct hclge_vport *vport = hclge_get_vport(handle);
 -	struct hclge_dev *hdev = vport->back;
 -	bool writen_to_tbl = false;
 -	int ret = 0;
 +	handle->netdev_flags |= HNAE3_VLAN_FLTR;
  
 -	/* When device is resetting or reset failed, firmware is unable to
 -	 * handle mailbox. Just record the vlan id, and remove it after
 -	 * reset finished.
 -	 */
 -	if ((test_bit(HCLGE_STATE_RST_HANDLING, &hdev->state) ||
 -	     test_bit(HCLGE_STATE_RST_FAIL, &hdev->state)) && is_kill) {
 -		set_bit(vlan_id, vport->vlan_del_fail_bmap);
 -		return -EBUSY;
 -	}
 +	hdev->vlan_type_cfg.rx_in_fst_vlan_type = HCLGE_DEF_VLAN_TYPE;
 +	hdev->vlan_type_cfg.rx_in_sec_vlan_type = HCLGE_DEF_VLAN_TYPE;
 +	hdev->vlan_type_cfg.rx_ot_fst_vlan_type = HCLGE_DEF_VLAN_TYPE;
 +	hdev->vlan_type_cfg.rx_ot_sec_vlan_type = HCLGE_DEF_VLAN_TYPE;
 +	hdev->vlan_type_cfg.tx_ot_vlan_type = HCLGE_DEF_VLAN_TYPE;
 +	hdev->vlan_type_cfg.tx_in_vlan_type = HCLGE_DEF_VLAN_TYPE;
  
 -	/* when port base vlan enabled, we use port base vlan as the vlan
 -	 * filter entry. In this case, we don't update vlan filter table
 -	 * when user add new vlan or remove exist vlan, just update the vport
 -	 * vlan list. The vlan id in vlan list will be writen in vlan filter
 -	 * table until port base vlan disabled
 -	 */
 -	if (handle->port_base_vlan_state == HNAE3_PORT_BASE_VLAN_DISABLE) {
 -		ret = hclge_set_vlan_filter_hw(hdev, proto, vport->vport_id,
 -					       vlan_id, is_kill);
 -		writen_to_tbl = true;
 -	}
 +	ret = hclge_set_vlan_protocol_type(hdev);
 +	if (ret)
 +		return ret;
  
 -	if (!ret) {
 -		if (is_kill)
 -			hclge_rm_vport_vlan_table(vport, vlan_id, false);
 -		else
 -			hclge_add_vport_vlan_table(vport, vlan_id,
 -						   writen_to_tbl);
 -	} else if (is_kill) {
 -		/* when remove hw vlan filter failed, record the vlan id,
 -		 * and try to remove it from hw later, to be consistence
 -		 * with stack
 -		 */
 -		set_bit(vlan_id, vport->vlan_del_fail_bmap);
 -	}
 +	for (i = 0; i < hdev->num_alloc_vport; i++) {
 +		vport = &hdev->vport[i];
 +		vport->txvlan_cfg.accept_tag1 = true;
 +		vport->txvlan_cfg.accept_untag1 = true;
  
 -	hclge_set_vport_vlan_fltr_change(vport);
 +		/* accept_tag2 and accept_untag2 are not supported on
 +		 * pdev revision(0x20), new revision support them. The
 +		 * value of this two fields will not return error when driver
 +		 * send command to fireware in revision(0x20).
 +		 * This two fields can not configured by user.
 +		 */
 +		vport->txvlan_cfg.accept_tag2 = true;
 +		vport->txvlan_cfg.accept_untag2 = true;
  
 -	return ret;
 -}
 +		vport->txvlan_cfg.insert_tag1_en = false;
 +		vport->txvlan_cfg.insert_tag2_en = false;
 +		vport->txvlan_cfg.default_tag1 = 0;
 +		vport->txvlan_cfg.default_tag2 = 0;
  
 -static void hclge_sync_vlan_fltr_state(struct hclge_dev *hdev)
 -{
 -	struct hclge_vport *vport;
 -	int ret;
 -	u16 i;
 +		ret = hclge_set_vlan_tx_offload_cfg(vport);
 +		if (ret)
 +			return ret;
  
 -	for (i = 0; i < hdev->num_alloc_vport; i++) {
 -		vport = &hdev->vport[i];
 -		if (!test_and_clear_bit(HCLGE_VPORT_STATE_VLAN_FLTR_CHANGE,
 -					&vport->state))
 -			continue;
 +		vport->rxvlan_cfg.strip_tag1_en = false;
 +		vport->rxvlan_cfg.strip_tag2_en = true;
 +		vport->rxvlan_cfg.vlan1_vlan_prionly = false;
 +		vport->rxvlan_cfg.vlan2_vlan_prionly = false;
  
 -		ret = hclge_enable_vport_vlan_filter(vport,
 -						     vport->req_vlan_fltr_en);
 -		if (ret) {
 -			dev_err(&hdev->pdev->dev,
 -				"failed to sync vlan filter state for vport%u, ret = %d\n",
 -				vport->vport_id, ret);
 -			set_bit(HCLGE_VPORT_STATE_VLAN_FLTR_CHANGE,
 -				&vport->state);
 -			return;
 -		}
 +		ret = hclge_set_vlan_rx_offload_cfg(vport);
 +		if (ret)
 +			return ret;
  	}
 +
 +	return hclge_set_vlan_filter(handle, htons(ETH_P_8021Q), 0, false);
  }
  
 -static void hclge_sync_vlan_filter(struct hclge_dev *hdev)
 +int hclge_en_hw_strip_rxvtag(struct hnae3_handle *handle, bool enable)
  {
 -#define HCLGE_MAX_SYNC_COUNT	60
 -
 -	int i, ret, sync_cnt = 0;
 -	u16 vlan_id;
 +	struct hclge_vport *vport = hclge_get_vport(handle);
  
 -	/* start from vport 1 for PF is always alive */
 -	for (i = 0; i < hdev->num_alloc_vport; i++) {
 -		struct hclge_vport *vport = &hdev->vport[i];
 -
 -		vlan_id = find_first_bit(vport->vlan_del_fail_bmap,
 -					 VLAN_N_VID);
 -		while (vlan_id != VLAN_N_VID) {
 -			ret = hclge_set_vlan_filter_hw(hdev, htons(ETH_P_8021Q),
 -						       vport->vport_id, vlan_id,
 -						       true);
 -			if (ret && ret != -EINVAL)
 -				return;
 -
 -			clear_bit(vlan_id, vport->vlan_del_fail_bmap);
 -			hclge_rm_vport_vlan_table(vport, vlan_id, false);
 -			hclge_set_vport_vlan_fltr_change(vport);
 -
 -			sync_cnt++;
 -			if (sync_cnt >= HCLGE_MAX_SYNC_COUNT)
 -				return;
 -
 -			vlan_id = find_first_bit(vport->vlan_del_fail_bmap,
 -						 VLAN_N_VID);
 -		}
 -	}
 +	vport->rxvlan_cfg.strip_tag1_en = false;
 +	vport->rxvlan_cfg.strip_tag2_en = enable;
 +	vport->rxvlan_cfg.vlan1_vlan_prionly = false;
 +	vport->rxvlan_cfg.vlan2_vlan_prionly = false;
  
 -	hclge_sync_vlan_fltr_state(hdev);
 +	return hclge_set_vlan_rx_offload_cfg(vport);
  }
  
 -static int hclge_set_mac_mtu(struct hclge_dev *hdev, int new_mps)
 +static int hclge_set_mac_mtu(struct hclge_dev *hdev, int new_mtu)
  {
  	struct hclge_config_max_frm_size_cmd *req;
  	struct hclge_desc desc;
* Unmerged path drivers/net/ethernet/actions/owl-emac.c
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_macsec.c
* Unmerged path drivers/net/ethernet/mediatek/mtk_star_emac.c
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_selftests.c
* Unmerged path drivers/net/ethernet/actions/owl-emac.c
diff --git a/drivers/net/ethernet/adaptec/starfire.c b/drivers/net/ethernet/adaptec/starfire.c
index 265400c7061b..954a828b5581 100644
--- a/drivers/net/ethernet/adaptec/starfire.c
+++ b/drivers/net/ethernet/adaptec/starfire.c
@@ -968,7 +968,7 @@ static int netdev_open(struct net_device *dev)
 	writew(0, ioaddr + PerfFilterTable + 4);
 	writew(0, ioaddr + PerfFilterTable + 8);
 	for (i = 1; i < 16; i++) {
-		__be16 *eaddrs = (__be16 *)dev->dev_addr;
+		const __be16 *eaddrs = (const __be16 *)dev->dev_addr;
 		void __iomem *setup_frm = ioaddr + PerfFilterTable + i * 16;
 		writew(be16_to_cpu(eaddrs[2]), setup_frm); setup_frm += 4;
 		writew(be16_to_cpu(eaddrs[1]), setup_frm); setup_frm += 4;
@@ -1797,14 +1797,14 @@ static void set_rx_mode(struct net_device *dev)
 	} else if (netdev_mc_count(dev) <= 14) {
 		/* Use the 16 element perfect filter, skip first two entries. */
 		void __iomem *filter_addr = ioaddr + PerfFilterTable + 2 * 16;
-		__be16 *eaddrs;
+		const __be16 *eaddrs;
 		netdev_for_each_mc_addr(ha, dev) {
 			eaddrs = (__be16 *) ha->addr;
 			writew(be16_to_cpu(eaddrs[2]), filter_addr); filter_addr += 4;
 			writew(be16_to_cpu(eaddrs[1]), filter_addr); filter_addr += 4;
 			writew(be16_to_cpu(eaddrs[0]), filter_addr); filter_addr += 8;
 		}
-		eaddrs = (__be16 *)dev->dev_addr;
+		eaddrs = (const __be16 *)dev->dev_addr;
 		i = netdev_mc_count(dev) + 2;
 		while (i++ < 16) {
 			writew(be16_to_cpu(eaddrs[0]), filter_addr); filter_addr += 4;
@@ -1815,7 +1815,7 @@ static void set_rx_mode(struct net_device *dev)
 	} else {
 		/* Must use a multicast hash table. */
 		void __iomem *filter_addr;
-		__be16 *eaddrs;
+		const __be16 *eaddrs;
 		__le16 mc_filter[32] __attribute__ ((aligned(sizeof(long))));	/* Multicast hash filter */
 
 		memset(mc_filter, 0, sizeof(mc_filter));
@@ -1829,7 +1829,7 @@ static void set_rx_mode(struct net_device *dev)
 		}
 		/* Clear the perfect filter list, skip first two entries. */
 		filter_addr = ioaddr + PerfFilterTable + 2 * 16;
-		eaddrs = (__be16 *)dev->dev_addr;
+		eaddrs = (const __be16 *)dev->dev_addr;
 		for (i = 2; i < 16; i++) {
 			writew(be16_to_cpu(eaddrs[0]), filter_addr); filter_addr += 4;
 			writew(be16_to_cpu(eaddrs[1]), filter_addr); filter_addr += 4;
diff --git a/drivers/net/ethernet/alacritech/slicoss.c b/drivers/net/ethernet/alacritech/slicoss.c
index bae468be5d7d..76cf8c76d4c8 100644
--- a/drivers/net/ethernet/alacritech/slicoss.c
+++ b/drivers/net/ethernet/alacritech/slicoss.c
@@ -1018,7 +1018,7 @@ static void slic_set_link_autoneg(struct slic_device *sdev)
 
 static void slic_set_mac_address(struct slic_device *sdev)
 {
-	u8 *addr = sdev->netdev->dev_addr;
+	const u8 *addr = sdev->netdev->dev_addr;
 	u32 val;
 
 	val = addr[5] | addr[4] << 8 | addr[3] << 16 | addr[2] << 24;
diff --git a/drivers/net/ethernet/alteon/acenic.c b/drivers/net/ethernet/alteon/acenic.c
index 30e03970eb4f..10ea314f4102 100644
--- a/drivers/net/ethernet/alteon/acenic.c
+++ b/drivers/net/ethernet/alteon/acenic.c
@@ -2723,7 +2723,7 @@ static int ace_set_mac_addr(struct net_device *dev, void *p)
 	struct ace_private *ap = netdev_priv(dev);
 	struct ace_regs __iomem *regs = ap->regs;
 	struct sockaddr *addr=p;
-	u8 *da;
+	const u8 *da;
 	struct cmd cmd;
 
 	if(netif_running(dev))
@@ -2731,7 +2731,7 @@ static int ace_set_mac_addr(struct net_device *dev, void *p)
 
 	memcpy(dev->dev_addr, addr->sa_data,dev->addr_len);
 
-	da = (u8 *)dev->dev_addr;
+	da = (const u8 *)dev->dev_addr;
 
 	writel(da[0] << 8 | da[1], &regs->MacAddrHi);
 	writel((da[2] << 24) | (da[3] << 16) | (da[4] << 8) | da[5],
diff --git a/drivers/net/ethernet/altera/altera_tse_main.c b/drivers/net/ethernet/altera/altera_tse_main.c
index 02921d877c08..216e379e003f 100644
--- a/drivers/net/ethernet/altera/altera_tse_main.c
+++ b/drivers/net/ethernet/altera/altera_tse_main.c
@@ -858,7 +858,7 @@ static int init_phy(struct net_device *dev)
 	return 0;
 }
 
-static void tse_update_mac_addr(struct altera_tse_private *priv, u8 *addr)
+static void tse_update_mac_addr(struct altera_tse_private *priv, const u8 *addr)
 {
 	u32 msb;
 	u32 lsb;
diff --git a/drivers/net/ethernet/amd/nmclan_cs.c b/drivers/net/ethernet/amd/nmclan_cs.c
index 023aecf6ab30..e43b5edcc3ea 100644
--- a/drivers/net/ethernet/amd/nmclan_cs.c
+++ b/drivers/net/ethernet/amd/nmclan_cs.c
@@ -531,7 +531,8 @@ static void mace_write(mace_private *lp, unsigned int ioaddr, int reg,
 mace_init
 	Resets the MACE chip.
 ---------------------------------------------------------------------------- */
-static int mace_init(mace_private *lp, unsigned int ioaddr, char *enet_addr)
+static int mace_init(mace_private *lp, unsigned int ioaddr,
+		     const char *enet_addr)
 {
   int i;
   int ct = 0;
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
index 96ba5bd1e369..6ab829888cc1 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c
@@ -1080,7 +1080,7 @@ static int xgbe_add_mac_addresses(struct xgbe_prv_data *pdata)
 	return 0;
 }
 
-static int xgbe_set_mac_address(struct xgbe_prv_data *pdata, u8 *addr)
+static int xgbe_set_mac_address(struct xgbe_prv_data *pdata, const u8 *addr)
 {
 	unsigned int mac_addr_hi, mac_addr_lo;
 
diff --git a/drivers/net/ethernet/amd/xgbe/xgbe.h b/drivers/net/ethernet/amd/xgbe/xgbe.h
index 47bcbcf58048..99c3dc79eb1a 100644
--- a/drivers/net/ethernet/amd/xgbe/xgbe.h
+++ b/drivers/net/ethernet/amd/xgbe/xgbe.h
@@ -730,7 +730,7 @@ struct xgbe_ext_stats {
 struct xgbe_hw_if {
 	int (*tx_complete)(struct xgbe_ring_desc *);
 
-	int (*set_mac_address)(struct xgbe_prv_data *, u8 *addr);
+	int (*set_mac_address)(struct xgbe_prv_data *, const u8 *addr);
 	int (*config_rx_mode)(struct xgbe_prv_data *);
 
 	int (*enable_rx_csum)(struct xgbe_prv_data *);
diff --git a/drivers/net/ethernet/apm/xgene-v2/mac.c b/drivers/net/ethernet/apm/xgene-v2/mac.c
index ee431e397e57..990cf166b604 100644
--- a/drivers/net/ethernet/apm/xgene-v2/mac.c
+++ b/drivers/net/ethernet/apm/xgene-v2/mac.c
@@ -77,7 +77,7 @@ void xge_mac_set_speed(struct xge_pdata *pdata)
 
 void xge_mac_set_station_addr(struct xge_pdata *pdata)
 {
-	u8 *dev_addr = pdata->ndev->dev_addr;
+	const u8 *dev_addr = pdata->ndev->dev_addr;
 	u32 addr0, addr1;
 
 	addr0 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |
diff --git a/drivers/net/ethernet/apm/xgene/xgene_enet_hw.c b/drivers/net/ethernet/apm/xgene/xgene_enet_hw.c
index e3560311711a..b8a293837efb 100644
--- a/drivers/net/ethernet/apm/xgene/xgene_enet_hw.c
+++ b/drivers/net/ethernet/apm/xgene/xgene_enet_hw.c
@@ -390,8 +390,8 @@ u32 xgene_enet_rd_stat(struct xgene_enet_pdata *pdata, u32 rd_addr)
 
 static void xgene_gmac_set_mac_addr(struct xgene_enet_pdata *pdata)
 {
+	const u8 *dev_addr = pdata->ndev->dev_addr;
 	u32 addr0, addr1;
-	u8 *dev_addr = pdata->ndev->dev_addr;
 
 	addr0 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |
 		(dev_addr[1] << 8) | dev_addr[0];
diff --git a/drivers/net/ethernet/apm/xgene/xgene_enet_sgmac.c b/drivers/net/ethernet/apm/xgene/xgene_enet_sgmac.c
index b1a83fdbefb8..0900ce4cd621 100644
--- a/drivers/net/ethernet/apm/xgene/xgene_enet_sgmac.c
+++ b/drivers/net/ethernet/apm/xgene/xgene_enet_sgmac.c
@@ -177,8 +177,8 @@ static void xgene_sgmac_reset(struct xgene_enet_pdata *p)
 
 static void xgene_sgmac_set_mac_addr(struct xgene_enet_pdata *p)
 {
+	const u8 *dev_addr = p->ndev->dev_addr;
 	u32 addr0, addr1;
-	u8 *dev_addr = p->ndev->dev_addr;
 
 	addr0 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |
 		(dev_addr[1] << 8) | dev_addr[0];
diff --git a/drivers/net/ethernet/apm/xgene/xgene_enet_xgmac.c b/drivers/net/ethernet/apm/xgene/xgene_enet_xgmac.c
index b7d75d067c7a..f7c2ceaa0a43 100644
--- a/drivers/net/ethernet/apm/xgene/xgene_enet_xgmac.c
+++ b/drivers/net/ethernet/apm/xgene/xgene_enet_xgmac.c
@@ -219,8 +219,8 @@ static void xgene_pcs_reset(struct xgene_enet_pdata *pdata)
 
 static void xgene_xgmac_set_mac_addr(struct xgene_enet_pdata *pdata)
 {
+	const u8 *dev_addr = pdata->ndev->dev_addr;
 	u32 addr0, addr1;
-	u8 *dev_addr = pdata->ndev->dev_addr;
 
 	addr0 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |
 		(dev_addr[1] << 8) | dev_addr[0];
diff --git a/drivers/net/ethernet/apple/bmac.c b/drivers/net/ethernet/apple/bmac.c
index 5a655d289dd5..5f1c42afac7e 100644
--- a/drivers/net/ethernet/apple/bmac.c
+++ b/drivers/net/ethernet/apple/bmac.c
@@ -311,7 +311,7 @@ bmac_init_registers(struct net_device *dev)
 {
 	struct bmac_data *bp = netdev_priv(dev);
 	volatile unsigned short regValue;
-	unsigned short *pWord16;
+	const unsigned short *pWord16;
 	int i;
 
 	/* XXDEBUG(("bmac: enter init_registers\n")); */
@@ -374,7 +374,7 @@ bmac_init_registers(struct net_device *dev)
 	bmwrite(dev, BHASH1, bp->hash_table_mask[2]); 	/* bits 47 - 32 */
 	bmwrite(dev, BHASH0, bp->hash_table_mask[3]); 	/* bits 63 - 48 */
 
-	pWord16 = (unsigned short *)dev->dev_addr;
+	pWord16 = (const unsigned short *)dev->dev_addr;
 	bmwrite(dev, MADD0, *pWord16++);
 	bmwrite(dev, MADD1, *pWord16++);
 	bmwrite(dev, MADD2, *pWord16);
@@ -525,7 +525,7 @@ static int bmac_set_address(struct net_device *dev, void *addr)
 {
 	struct bmac_data *bp = netdev_priv(dev);
 	unsigned char *p = addr;
-	unsigned short *pWord16;
+	const unsigned short *pWord16;
 	unsigned long flags;
 	int i;
 
@@ -536,7 +536,7 @@ static int bmac_set_address(struct net_device *dev, void *addr)
 		dev->dev_addr[i] = p[i];
 	}
 	/* load up the hardware address */
-	pWord16  = (unsigned short *)dev->dev_addr;
+	pWord16  = (const unsigned short *)dev->dev_addr;
 	bmwrite(dev, MADD0, *pWord16++);
 	bmwrite(dev, MADD1, *pWord16++);
 	bmwrite(dev, MADD2, *pWord16);
diff --git a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
index 386026f2c9ca..6cb117c70c71 100644
--- a/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
+++ b/drivers/net/ethernet/aquantia/atlantic/aq_hw.h
@@ -215,7 +215,7 @@ struct aq_hw_ops {
 	int (*hw_ring_tx_head_update)(struct aq_hw_s *self,
 				      struct aq_ring_s *aq_ring);
 
-	int (*hw_set_mac_address)(struct aq_hw_s *self, u8 *mac_addr);
+	int (*hw_set_mac_address)(struct aq_hw_s *self, const u8 *mac_addr);
 
 	int (*hw_soft_reset)(struct aq_hw_s *self);
 
@@ -224,7 +224,7 @@ struct aq_hw_ops {
 
 	int (*hw_reset)(struct aq_hw_s *self);
 
-	int (*hw_init)(struct aq_hw_s *self, u8 *mac_addr);
+	int (*hw_init)(struct aq_hw_s *self, const u8 *mac_addr);
 
 	int (*hw_start)(struct aq_hw_s *self);
 
@@ -371,7 +371,7 @@ struct aq_fw_ops {
 	int (*set_phyloopback)(struct aq_hw_s *self, u32 mode, bool enable);
 
 	int (*set_power)(struct aq_hw_s *self, unsigned int power_state,
-			 u8 *mac);
+			 const u8 *mac);
 
 	int (*send_fw_request)(struct aq_hw_s *self,
 			       const struct hw_fw_request_iface *fw_req,
* Unmerged path drivers/net/ethernet/aquantia/atlantic/aq_macsec.c
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
index 611875ef2cd1..4625ccb79499 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_a0.c
@@ -322,7 +322,7 @@ static int hw_atl_a0_hw_init_rx_path(struct aq_hw_s *self)
 	return aq_hw_err_from_flags(self);
 }
 
-static int hw_atl_a0_hw_mac_addr_set(struct aq_hw_s *self, u8 *mac_addr)
+static int hw_atl_a0_hw_mac_addr_set(struct aq_hw_s *self, const u8 *mac_addr)
 {
 	unsigned int h = 0U;
 	unsigned int l = 0U;
@@ -348,7 +348,7 @@ static int hw_atl_a0_hw_mac_addr_set(struct aq_hw_s *self, u8 *mac_addr)
 	return err;
 }
 
-static int hw_atl_a0_hw_init(struct aq_hw_s *self, u8 *mac_addr)
+static int hw_atl_a0_hw_init(struct aq_hw_s *self, const u8 *mac_addr)
 {
 	static u32 aq_hw_atl_igcr_table_[4][2] = {
 		[AQ_HW_IRQ_INVALID] = { 0x20000000U, 0x20000000U },
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
index 8941ac4df9e3..1860fa6ec3d0 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.c
@@ -533,7 +533,7 @@ static int hw_atl_b0_hw_init_rx_path(struct aq_hw_s *self)
 	return aq_hw_err_from_flags(self);
 }
 
-int hw_atl_b0_hw_mac_addr_set(struct aq_hw_s *self, u8 *mac_addr)
+int hw_atl_b0_hw_mac_addr_set(struct aq_hw_s *self, const u8 *mac_addr)
 {
 	unsigned int h = 0U;
 	unsigned int l = 0U;
@@ -558,7 +558,7 @@ int hw_atl_b0_hw_mac_addr_set(struct aq_hw_s *self, u8 *mac_addr)
 	return err;
 }
 
-static int hw_atl_b0_hw_init(struct aq_hw_s *self, u8 *mac_addr)
+static int hw_atl_b0_hw_init(struct aq_hw_s *self, const u8 *mac_addr)
 {
 	static u32 aq_hw_atl_igcr_table_[4][2] = {
 		[AQ_HW_IRQ_INVALID] = { 0x20000000U, 0x20000000U },
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
index d8db972113ec..5298846dd9f7 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_b0.h
@@ -58,7 +58,7 @@ int hw_atl_b0_hw_ring_rx_stop(struct aq_hw_s *self, struct aq_ring_s *ring);
 
 void hw_atl_b0_hw_init_rx_rss_ctrl1(struct aq_hw_s *self);
 
-int hw_atl_b0_hw_mac_addr_set(struct aq_hw_s *self, u8 *mac_addr);
+int hw_atl_b0_hw_mac_addr_set(struct aq_hw_s *self, const u8 *mac_addr);
 
 int hw_atl_b0_set_fc(struct aq_hw_s *self, u32 fc, u32 tc);
 int hw_atl_b0_set_loopback(struct aq_hw_s *self, u32 mode, bool enable);
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
index 404cbf60d3f2..fc0e66006644 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils.c
@@ -944,7 +944,7 @@ u32 hw_atl_utils_get_fw_version(struct aq_hw_s *self)
 }
 
 static int aq_fw1x_set_wake_magic(struct aq_hw_s *self, bool wol_enabled,
-				  u8 *mac)
+				  const u8 *mac)
 {
 	struct hw_atl_utils_fw_rpc *prpc = NULL;
 	unsigned int rpc_size = 0U;
@@ -987,7 +987,7 @@ static int aq_fw1x_set_wake_magic(struct aq_hw_s *self, bool wol_enabled,
 }
 
 static int aq_fw1x_set_power(struct aq_hw_s *self, unsigned int power_state,
-			     u8 *mac)
+			     const u8 *mac)
 {
 	struct hw_atl_utils_fw_rpc *prpc = NULL;
 	unsigned int rpc_size = 0U;
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
index 90f8c11318a1..670caf1b6570 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl/hw_atl_utils_fw2x.c
@@ -355,7 +355,7 @@ static int aq_fw2x_get_phy_temp(struct aq_hw_s *self, int *temp)
 	return 0;
 }
 
-static int aq_fw2x_set_wol(struct aq_hw_s *self, u8 *mac)
+static int aq_fw2x_set_wol(struct aq_hw_s *self, const u8 *mac)
 {
 	struct hw_atl_utils_fw_rpc *rpc = NULL;
 	struct offload_info *info = NULL;
@@ -401,7 +401,7 @@ static int aq_fw2x_set_wol(struct aq_hw_s *self, u8 *mac)
 }
 
 static int aq_fw2x_set_power(struct aq_hw_s *self, unsigned int power_state,
-			     u8 *mac)
+			     const u8 *mac)
 {
 	int err = 0;
 
diff --git a/drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c b/drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
index 92f64048bf69..c98708bb044c 100644
--- a/drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
+++ b/drivers/net/ethernet/aquantia/atlantic/hw_atl2/hw_atl2.c
@@ -516,7 +516,7 @@ static int hw_atl2_hw_init_rx_path(struct aq_hw_s *self)
 	return aq_hw_err_from_flags(self);
 }
 
-static int hw_atl2_hw_init(struct aq_hw_s *self, u8 *mac_addr)
+static int hw_atl2_hw_init(struct aq_hw_s *self, const u8 *mac_addr)
 {
 	static u32 aq_hw_atl2_igcr_table_[4][2] = {
 		[AQ_HW_IRQ_INVALID] = { 0x20000000U, 0x20000000U },
diff --git a/drivers/net/ethernet/broadcom/b44.c b/drivers/net/ethernet/broadcom/b44.c
index 0346546a8d2e..2e596fee281e 100644
--- a/drivers/net/ethernet/broadcom/b44.c
+++ b/drivers/net/ethernet/broadcom/b44.c
@@ -220,7 +220,8 @@ static inline void __b44_cam_read(struct b44 *bp, unsigned char *data, int index
 	data[1] = (val >> 0) & 0xFF;
 }
 
-static inline void __b44_cam_write(struct b44 *bp, unsigned char *data, int index)
+static inline void __b44_cam_write(struct b44 *bp,
+				   const unsigned char *data, int index)
 {
 	u32 val;
 
@@ -1512,7 +1513,8 @@ static void bwfilter_table(struct b44 *bp, u8 *pp, u32 bytes, u32 table_offset)
 	}
 }
 
-static int b44_magic_pattern(u8 *macaddr, u8 *ppattern, u8 *pmask, int offset)
+static int b44_magic_pattern(const u8 *macaddr, u8 *ppattern, u8 *pmask,
+			     int offset)
 {
 	int magicsync = 6;
 	int k, j, len = offset;
diff --git a/drivers/net/ethernet/broadcom/bcmsysport.c b/drivers/net/ethernet/broadcom/bcmsysport.c
index 2e492a6512c0..83c9b4f3b917 100644
--- a/drivers/net/ethernet/broadcom/bcmsysport.c
+++ b/drivers/net/ethernet/broadcom/bcmsysport.c
@@ -1782,7 +1782,7 @@ static inline void umac_reset(struct bcm_sysport_priv *priv)
 }
 
 static void umac_set_hw_addr(struct bcm_sysport_priv *priv,
-			     unsigned char *addr)
+			     const unsigned char *addr)
 {
 	u32 mac0 = (addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) |
 		    addr[3];
diff --git a/drivers/net/ethernet/broadcom/bgmac.c b/drivers/net/ethernet/broadcom/bgmac.c
index 01e81d0708cb..f9a69d496a41 100644
--- a/drivers/net/ethernet/broadcom/bgmac.c
+++ b/drivers/net/ethernet/broadcom/bgmac.c
@@ -772,7 +772,7 @@ static void bgmac_cmdcfg_maskset(struct bgmac *bgmac, u32 mask, u32 set,
 	udelay(2);
 }
 
-static void bgmac_write_mac_address(struct bgmac *bgmac, u8 *addr)
+static void bgmac_write_mac_address(struct bgmac *bgmac, const u8 *addr)
 {
 	u32 tmp;
 
diff --git a/drivers/net/ethernet/broadcom/bnx2.c b/drivers/net/ethernet/broadcom/bnx2.c
index abb1fae25972..38d64d1a2fcf 100644
--- a/drivers/net/ethernet/broadcom/bnx2.c
+++ b/drivers/net/ethernet/broadcom/bnx2.c
@@ -2706,7 +2706,7 @@ bnx2_alloc_bad_rbuf(struct bnx2 *bp)
 }
 
 static void
-bnx2_set_mac_addr(struct bnx2 *bp, u8 *mac_addr, u32 pos)
+bnx2_set_mac_addr(struct bnx2 *bp, const u8 *mac_addr, u32 pos)
 {
 	u32 val;
 
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h b/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h
index 96c5d18b7b82..4464b1576bf5 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h
@@ -1994,7 +1994,7 @@ int bnx2x_idle_chk(struct bnx2x *bp);
  * operation has been successfully scheduled and a negative - if a requested
  * operations has failed.
  */
-int bnx2x_set_mac_one(struct bnx2x *bp, u8 *mac,
+int bnx2x_set_mac_one(struct bnx2x *bp, const u8 *mac,
 		      struct bnx2x_vlan_mac_obj *obj, bool set,
 		      int mac_type, unsigned long *ramrod_flags);
 
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
index 723b5d045686..5c26f505d151 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c
@@ -8423,7 +8423,7 @@ int bnx2x_alloc_mem(struct bnx2x *bp)
  * Init service functions
  */
 
-int bnx2x_set_mac_one(struct bnx2x *bp, u8 *mac,
+int bnx2x_set_mac_one(struct bnx2x *bp, const u8 *mac,
 		      struct bnx2x_vlan_mac_obj *obj, bool set,
 		      int mac_type, unsigned long *ramrod_flags)
 {
@@ -9152,7 +9152,7 @@ u32 bnx2x_send_unload_req(struct bnx2x *bp, int unload_mode)
 
 	else if (bp->wol) {
 		u32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
-		u8 *mac_addr = bp->dev->dev_addr;
+		const u8 *mac_addr = bp->dev->dev_addr;
 		struct pci_dev *pdev = bp->pdev;
 		u32 val;
 		u16 pmc;
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.h b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.h
index 3a716c015415..3c08f12d57fe 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.h
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_sriov.h
@@ -509,7 +509,8 @@ int bnx2x_vfpf_init(struct bnx2x *bp);
 void bnx2x_vfpf_close_vf(struct bnx2x *bp);
 int bnx2x_vfpf_setup_q(struct bnx2x *bp, struct bnx2x_fastpath *fp,
 		       bool is_leading);
-int bnx2x_vfpf_config_mac(struct bnx2x *bp, u8 *addr, u8 vf_qid, bool set);
+int bnx2x_vfpf_config_mac(struct bnx2x *bp, const u8 *addr, u8 vf_qid,
+			  bool set);
 int bnx2x_vfpf_config_rss(struct bnx2x *bp,
 			  struct bnx2x_config_rss_params *params);
 int bnx2x_vfpf_set_mcast(struct net_device *dev);
diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c
index ea0e9394f898..05d861679a02 100644
--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c
+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_vfpf.c
@@ -722,7 +722,7 @@ static int bnx2x_vfpf_teardown_queue(struct bnx2x *bp, int qidx)
 }
 
 /* request pf to add a mac for the vf */
-int bnx2x_vfpf_config_mac(struct bnx2x *bp, u8 *addr, u8 vf_qid, bool set)
+int bnx2x_vfpf_config_mac(struct bnx2x *bp, const u8 *addr, u8 vf_qid, bool set)
 {
 	struct vfpf_set_q_filters_tlv *req = &bp->vf2pf_mbox->req.set_q_filters;
 	struct pfvf_general_resp_tlv *resp = &bp->vf2pf_mbox->resp.general_resp;
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 569d83aa68f5..ffe1c740f825 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -4929,7 +4929,7 @@ static int bnxt_hwrm_cfa_ntuple_filter_alloc(struct bnxt *bp,
 #endif
 
 static int bnxt_hwrm_set_vnic_filter(struct bnxt *bp, u16 vnic_id, u16 idx,
-				     u8 *mac_addr)
+				     const u8 *mac_addr)
 {
 	u32 rc = 0;
 	struct hwrm_cfa_l2_filter_alloc_input req = {0};
* Unmerged path drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.c
diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.h b/drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.h
index 995535e4c11b..9a4bacba477b 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.h
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt_sriov.h
@@ -41,5 +41,5 @@ int bnxt_cfg_hw_sriov(struct bnxt *bp, int *num_vfs, bool reset);
 void bnxt_sriov_disable(struct bnxt *);
 void bnxt_hwrm_exec_fwd_req(struct bnxt *);
 void bnxt_update_vf_mac(struct bnxt *);
-int bnxt_approve_mac(struct bnxt *, u8 *, bool);
+int bnxt_approve_mac(struct bnxt *, const u8 *, bool);
 #endif
* Unmerged path drivers/net/ethernet/broadcom/genet/bcmgenet.c
diff --git a/drivers/net/ethernet/calxeda/xgmac.c b/drivers/net/ethernet/calxeda/xgmac.c
index 5de07bb4f248..0481e4547e5f 100644
--- a/drivers/net/ethernet/calxeda/xgmac.c
+++ b/drivers/net/ethernet/calxeda/xgmac.c
@@ -617,7 +617,7 @@ static inline void xgmac_mac_disable(void __iomem *ioaddr)
 	writel(value, ioaddr + XGMAC_CONTROL);
 }
 
-static void xgmac_set_mac_addr(void __iomem *ioaddr, unsigned char *addr,
+static void xgmac_set_mac_addr(void __iomem *ioaddr, const unsigned char *addr,
 			       int num)
 {
 	u32 data;
diff --git a/drivers/net/ethernet/chelsio/cxgb/gmac.h b/drivers/net/ethernet/chelsio/cxgb/gmac.h
index dfa77491a910..5913eaf442b5 100644
--- a/drivers/net/ethernet/chelsio/cxgb/gmac.h
+++ b/drivers/net/ethernet/chelsio/cxgb/gmac.h
@@ -117,7 +117,7 @@ struct cmac_ops {
 	const struct cmac_statistics *(*statistics_update)(struct cmac *, int);
 
 	int (*macaddress_get)(struct cmac *, u8 mac_addr[6]);
-	int (*macaddress_set)(struct cmac *, u8 mac_addr[6]);
+	int (*macaddress_set)(struct cmac *, const u8 mac_addr[6]);
 };
 
 typedef struct _cmac_instance cmac_instance;
diff --git a/drivers/net/ethernet/chelsio/cxgb/pm3393.c b/drivers/net/ethernet/chelsio/cxgb/pm3393.c
index c27908e66f5e..0bb37e4680c7 100644
--- a/drivers/net/ethernet/chelsio/cxgb/pm3393.c
+++ b/drivers/net/ethernet/chelsio/cxgb/pm3393.c
@@ -496,7 +496,7 @@ static int pm3393_macaddress_get(struct cmac *cmac, u8 mac_addr[6])
 	return 0;
 }
 
-static int pm3393_macaddress_set(struct cmac *cmac, u8 ma[6])
+static int pm3393_macaddress_set(struct cmac *cmac, const u8 ma[6])
 {
 	u32 val, lo, mid, hi, enabled = cmac->instance->enabled;
 
diff --git a/drivers/net/ethernet/chelsio/cxgb/vsc7326.c b/drivers/net/ethernet/chelsio/cxgb/vsc7326.c
index 873c1c7b4ca0..81317a9baf1a 100644
--- a/drivers/net/ethernet/chelsio/cxgb/vsc7326.c
+++ b/drivers/net/ethernet/chelsio/cxgb/vsc7326.c
@@ -379,7 +379,7 @@ static int mac_intr_clear(struct cmac *mac)
 }
 
 /* Expect MAC address to be in network byte order. */
-static int mac_set_address(struct cmac* mac, u8 addr[6])
+static int mac_set_address(struct cmac* mac, const u8 addr[6])
 {
 	u32 val;
 	int port = mac->instance->index;
diff --git a/drivers/net/ethernet/chelsio/cxgb3/common.h b/drivers/net/ethernet/chelsio/cxgb3/common.h
index 86b9d9e8af64..2a179aa54e33 100644
--- a/drivers/net/ethernet/chelsio/cxgb3/common.h
+++ b/drivers/net/ethernet/chelsio/cxgb3/common.h
@@ -708,7 +708,7 @@ int t3_mac_enable(struct cmac *mac, int which);
 int t3_mac_disable(struct cmac *mac, int which);
 int t3_mac_set_mtu(struct cmac *mac, unsigned int mtu);
 int t3_mac_set_rx_mode(struct cmac *mac, struct net_device *dev);
-int t3_mac_set_address(struct cmac *mac, unsigned int idx, u8 addr[6]);
+int t3_mac_set_address(struct cmac *mac, unsigned int idx, const u8 addr[6]);
 int t3_mac_set_num_ucast(struct cmac *mac, int n);
 const struct mac_stats *t3_mac_update_stats(struct cmac *mac);
 int t3_mac_set_speed_duplex_fc(struct cmac *mac, int speed, int duplex, int fc);
diff --git a/drivers/net/ethernet/chelsio/cxgb3/xgmac.c b/drivers/net/ethernet/chelsio/cxgb3/xgmac.c
index 3af19a550372..1bdc6cad1e49 100644
--- a/drivers/net/ethernet/chelsio/cxgb3/xgmac.c
+++ b/drivers/net/ethernet/chelsio/cxgb3/xgmac.c
@@ -240,7 +240,7 @@ static void set_addr_filter(struct cmac *mac, int idx, const u8 * addr)
 }
 
 /* Set one of the station's unicast MAC addresses. */
-int t3_mac_set_address(struct cmac *mac, unsigned int idx, u8 addr[6])
+int t3_mac_set_address(struct cmac *mac, unsigned int idx, const u8 addr[6])
 {
 	if (idx >= mac->nucast)
 		return -EINVAL;
diff --git a/drivers/net/ethernet/cisco/enic/enic_pp.c b/drivers/net/ethernet/cisco/enic/enic_pp.c
index e6a83198c3dd..80f46dbd5117 100644
--- a/drivers/net/ethernet/cisco/enic/enic_pp.c
+++ b/drivers/net/ethernet/cisco/enic/enic_pp.c
@@ -73,9 +73,9 @@ static int enic_set_port_profile(struct enic *enic, int vf)
 	struct vic_provinfo *vp;
 	const u8 oui[3] = VIC_PROVINFO_CISCO_OUI;
 	const __be16 os_type = htons(VIC_GENERIC_PROV_OS_TYPE_LINUX);
+	const u8 *client_mac;
 	char uuid_str[38];
 	char client_mac_str[18];
-	u8 *client_mac;
 	int err;
 
 	ENIC_PP_BY_INDEX(enic, vf, pp, &err);
diff --git a/drivers/net/ethernet/dlink/dl2k.c b/drivers/net/ethernet/dlink/dl2k.c
index e2395c128aa7..ea71f13595e6 100644
--- a/drivers/net/ethernet/dlink/dl2k.c
+++ b/drivers/net/ethernet/dlink/dl2k.c
@@ -576,7 +576,7 @@ static void rio_hw_init(struct net_device *dev)
 	 */
 	for (i = 0; i < 3; i++)
 		dw16(StationAddr0 + 2 * i,
-		     cpu_to_le16(((u16 *)dev->dev_addr)[i]));
+		     cpu_to_le16(((const u16 *)dev->dev_addr)[i]));
 
 	set_multicast (dev);
 	if (np->coalesce) {
diff --git a/drivers/net/ethernet/dnet.c b/drivers/net/ethernet/dnet.c
index 2426cc1c9ea8..63dabbd6a1bc 100644
--- a/drivers/net/ethernet/dnet.c
+++ b/drivers/net/ethernet/dnet.c
@@ -63,11 +63,11 @@ static void __dnet_set_hwaddr(struct dnet *bp)
 {
 	u16 tmp;
 
-	tmp = be16_to_cpup((__be16 *)bp->dev->dev_addr);
+	tmp = be16_to_cpup((const __be16 *)bp->dev->dev_addr);
 	dnet_writew_mac(bp, DNET_INTERNAL_MAC_ADDR_0_REG, tmp);
-	tmp = be16_to_cpup((__be16 *)(bp->dev->dev_addr + 2));
+	tmp = be16_to_cpup((const __be16 *)(bp->dev->dev_addr + 2));
 	dnet_writew_mac(bp, DNET_INTERNAL_MAC_ADDR_1_REG, tmp);
-	tmp = be16_to_cpup((__be16 *)(bp->dev->dev_addr + 4));
+	tmp = be16_to_cpup((const __be16 *)(bp->dev->dev_addr + 4));
 	dnet_writew_mac(bp, DNET_INTERNAL_MAC_ADDR_2_REG, tmp);
 }
 
diff --git a/drivers/net/ethernet/emulex/benet/be_cmds.c b/drivers/net/ethernet/emulex/benet/be_cmds.c
index 649c5c429bd7..528eb0f223b1 100644
--- a/drivers/net/ethernet/emulex/benet/be_cmds.c
+++ b/drivers/net/ethernet/emulex/benet/be_cmds.c
@@ -1080,7 +1080,7 @@ int be_cmd_mac_addr_query(struct be_adapter *adapter, u8 *mac_addr,
 }
 
 /* Uses synchronous MCCQ */
-int be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr,
+int be_cmd_pmac_add(struct be_adapter *adapter, const u8 *mac_addr,
 		    u32 if_id, u32 *pmac_id, u32 domain)
 {
 	struct be_mcc_wrb *wrb;
diff --git a/drivers/net/ethernet/emulex/benet/be_cmds.h b/drivers/net/ethernet/emulex/benet/be_cmds.h
index c30d6d6f0f3a..db1f3b908582 100644
--- a/drivers/net/ethernet/emulex/benet/be_cmds.h
+++ b/drivers/net/ethernet/emulex/benet/be_cmds.h
@@ -2385,7 +2385,7 @@ int be_pci_fnum_get(struct be_adapter *adapter);
 int be_fw_wait_ready(struct be_adapter *adapter);
 int be_cmd_mac_addr_query(struct be_adapter *adapter, u8 *mac_addr,
 			  bool permanent, u32 if_handle, u32 pmac_id);
-int be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr, u32 if_id,
+int be_cmd_pmac_add(struct be_adapter *adapter, const u8 *mac_addr, u32 if_id,
 		    u32 *pmac_id, u32 domain);
 int be_cmd_pmac_del(struct be_adapter *adapter, u32 if_id, int pmac_id,
 		    u32 domain);
diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c
index e6e3669fd7b7..02d21d6c374e 100644
--- a/drivers/net/ethernet/emulex/benet/be_main.c
+++ b/drivers/net/ethernet/emulex/benet/be_main.c
@@ -273,7 +273,7 @@ void be_cq_notify(struct be_adapter *adapter, u16 qid, bool arm, u16 num_popped)
 	iowrite32(val, adapter->db + DB_CQ_OFFSET);
 }
 
-static int be_dev_mac_add(struct be_adapter *adapter, u8 *mac)
+static int be_dev_mac_add(struct be_adapter *adapter, const u8 *mac)
 {
 	int i;
 
diff --git a/drivers/net/ethernet/ethoc.c b/drivers/net/ethernet/ethoc.c
index c0c7a35d0af6..e274b0700b13 100644
--- a/drivers/net/ethernet/ethoc.c
+++ b/drivers/net/ethernet/ethoc.c
@@ -805,8 +805,8 @@ static int ethoc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 
 static void ethoc_do_set_mac_address(struct net_device *dev)
 {
+	const unsigned char *mac = dev->dev_addr;
 	struct ethoc *priv = netdev_priv(dev);
-	unsigned char *mac = dev->dev_addr;
 
 	ethoc_write(priv, MAC_ADDR0, (mac[2] << 24) | (mac[3] << 16) |
 				     (mac[4] <<  8) | (mac[5] <<  0));
diff --git a/drivers/net/ethernet/fealnx.c b/drivers/net/ethernet/fealnx.c
index e3f92d38464f..726fe5229425 100644
--- a/drivers/net/ethernet/fealnx.c
+++ b/drivers/net/ethernet/fealnx.c
@@ -837,7 +837,7 @@ static int netdev_open(struct net_device *dev)
 		return -EAGAIN;
 
 	for (i = 0; i < 3; i++)
-		iowrite16(((unsigned short*)dev->dev_addr)[i],
+		iowrite16(((const unsigned short *)dev->dev_addr)[i],
 				ioaddr + PAR0 + i*2);
 
 	init_ring(dev);
* Unmerged path drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
* Unmerged path drivers/net/ethernet/freescale/fman/fman_dtsec.c
diff --git a/drivers/net/ethernet/freescale/fman/fman_dtsec.h b/drivers/net/ethernet/freescale/fman/fman_dtsec.h
index 1a689adf5a22..ed8bb494e8b6 100644
--- a/drivers/net/ethernet/freescale/fman/fman_dtsec.h
+++ b/drivers/net/ethernet/freescale/fman/fman_dtsec.h
@@ -37,7 +37,7 @@
 
 struct fman_mac *dtsec_config(struct fman_mac_params *params);
 int dtsec_set_promiscuous(struct fman_mac *dtsec, bool new_val);
-int dtsec_modify_mac_address(struct fman_mac *dtsec, enet_addr_t *enet_addr);
+int dtsec_modify_mac_address(struct fman_mac *dtsec, const enet_addr_t *enet_addr);
 int dtsec_adjust_link(struct fman_mac *dtsec,
 		      u16 speed);
 int dtsec_restart_autoneg(struct fman_mac *dtsec);
* Unmerged path drivers/net/ethernet/freescale/fman/fman_memac.c
diff --git a/drivers/net/ethernet/freescale/fman/fman_memac.h b/drivers/net/ethernet/freescale/fman/fman_memac.h
index b5a50338ed9a..62c687f0359c 100644
--- a/drivers/net/ethernet/freescale/fman/fman_memac.h
+++ b/drivers/net/ethernet/freescale/fman/fman_memac.h
@@ -40,7 +40,7 @@
 
 struct fman_mac *memac_config(struct fman_mac_params *params);
 int memac_set_promiscuous(struct fman_mac *memac, bool new_val);
-int memac_modify_mac_address(struct fman_mac *memac, enet_addr_t *enet_addr);
+int memac_modify_mac_address(struct fman_mac *memac, const enet_addr_t *enet_addr);
 int memac_adjust_link(struct fman_mac *memac, u16 speed);
 int memac_cfg_max_frame_len(struct fman_mac *memac, u16 new_val);
 int memac_cfg_reset_on_init(struct fman_mac *memac, bool enable);
* Unmerged path drivers/net/ethernet/freescale/fman/fman_tgec.c
diff --git a/drivers/net/ethernet/freescale/fman/fman_tgec.h b/drivers/net/ethernet/freescale/fman/fman_tgec.h
index cbbd3b422a98..43f4cb6dd2bc 100644
--- a/drivers/net/ethernet/freescale/fman/fman_tgec.h
+++ b/drivers/net/ethernet/freescale/fman/fman_tgec.h
@@ -37,7 +37,7 @@
 
 struct fman_mac *tgec_config(struct fman_mac_params *params);
 int tgec_set_promiscuous(struct fman_mac *tgec, bool new_val);
-int tgec_modify_mac_address(struct fman_mac *tgec, enet_addr_t *enet_addr);
+int tgec_modify_mac_address(struct fman_mac *tgec, const enet_addr_t *enet_addr);
 int tgec_cfg_max_frame_len(struct fman_mac *tgec, u16 new_val);
 int tgec_enable(struct fman_mac *tgec, enum comm_mode mode);
 int tgec_disable(struct fman_mac *tgec, enum comm_mode mode);
diff --git a/drivers/net/ethernet/freescale/fman/mac.h b/drivers/net/ethernet/freescale/fman/mac.h
index b520cec120ee..e7d7da672bda 100644
--- a/drivers/net/ethernet/freescale/fman/mac.h
+++ b/drivers/net/ethernet/freescale/fman/mac.h
@@ -66,7 +66,7 @@ struct mac_device {
 	int (*stop)(struct mac_device *mac_dev);
 	void (*adjust_link)(struct mac_device *mac_dev);
 	int (*set_promisc)(struct fman_mac *mac_dev, bool enable);
-	int (*change_addr)(struct fman_mac *mac_dev, enet_addr_t *enet_addr);
+	int (*change_addr)(struct fman_mac *mac_dev, const enet_addr_t *enet_addr);
 	int (*set_allmulti)(struct fman_mac *mac_dev, bool enable);
 	int (*set_multi)(struct net_device *net_dev,
 			 struct mac_device *mac_dev);
diff --git a/drivers/net/ethernet/hisilicon/hisi_femac.c b/drivers/net/ethernet/hisilicon/hisi_femac.c
index 2c2808830e95..4cc00e3da41c 100644
--- a/drivers/net/ethernet/hisilicon/hisi_femac.c
+++ b/drivers/net/ethernet/hisilicon/hisi_femac.c
@@ -439,7 +439,7 @@ static void hisi_femac_free_skb_rings(struct hisi_femac_priv *priv)
 }
 
 static int hisi_femac_set_hw_mac_addr(struct hisi_femac_priv *priv,
-				      unsigned char *mac)
+				      const unsigned char *mac)
 {
 	u32 reg;
 
diff --git a/drivers/net/ethernet/hisilicon/hix5hd2_gmac.c b/drivers/net/ethernet/hisilicon/hix5hd2_gmac.c
index 1d55968d4e6b..a31404690a1c 100644
--- a/drivers/net/ethernet/hisilicon/hix5hd2_gmac.c
+++ b/drivers/net/ethernet/hisilicon/hix5hd2_gmac.c
@@ -433,7 +433,7 @@ static void hix5hd2_port_disable(struct hix5hd2_priv *priv)
 static void hix5hd2_hw_set_mac_addr(struct net_device *dev)
 {
 	struct hix5hd2_priv *priv = netdev_priv(dev);
-	unsigned char *mac = dev->dev_addr;
+	const unsigned char *mac = dev->dev_addr;
 	u32 val;
 
 	val = mac[1] | (mac[0] << 8);
diff --git a/drivers/net/ethernet/hisilicon/hns/hnae.h b/drivers/net/ethernet/hisilicon/hns/hnae.h
index d6fb83437230..e2a9ac624d97 100644
--- a/drivers/net/ethernet/hisilicon/hns/hnae.h
+++ b/drivers/net/ethernet/hisilicon/hns/hnae.h
@@ -512,7 +512,7 @@ struct hnae_ae_ops {
 				   u32 *tx_usecs_high, u32 *rx_usecs_high);
 	void (*set_promisc_mode)(struct hnae_handle *handle, u32 en);
 	int (*get_mac_addr)(struct hnae_handle *handle, void **p);
-	int (*set_mac_addr)(struct hnae_handle *handle, void *p);
+	int (*set_mac_addr)(struct hnae_handle *handle, const void *p);
 	int (*add_uc_addr)(struct hnae_handle *handle,
 			   const unsigned char *addr);
 	int (*rm_uc_addr)(struct hnae_handle *handle,
diff --git a/drivers/net/ethernet/hisilicon/hns/hns_ae_adapt.c b/drivers/net/ethernet/hisilicon/hns/hns_ae_adapt.c
index a78bfafd212c..f95025f5f626 100644
--- a/drivers/net/ethernet/hisilicon/hns/hns_ae_adapt.c
+++ b/drivers/net/ethernet/hisilicon/hns/hns_ae_adapt.c
@@ -213,7 +213,7 @@ static void hns_ae_fini_queue(struct hnae_queue *q)
 		hns_rcb_reset_ring_hw(q);
 }
 
-static int hns_ae_set_mac_address(struct hnae_handle *handle, void *p)
+static int hns_ae_set_mac_address(struct hnae_handle *handle, const void *p)
 {
 	int ret;
 	struct hns_mac_cb *mac_cb = hns_get_mac_cb(handle);
diff --git a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c
index 1790cdafd9b8..ec51d24bebc2 100644
--- a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c
+++ b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_gmac.c
@@ -470,7 +470,7 @@ static void hns_gmac_update_stats(void *mac_drv)
 		+= dsaf_read_dev(drv, GMAC_TX_PAUSE_FRAMES_REG);
 }
 
-static void hns_gmac_set_mac_addr(void *mac_drv, char *mac_addr)
+static void hns_gmac_set_mac_addr(void *mac_drv, const char *mac_addr)
 {
 	struct mac_driver *drv = (struct mac_driver *)mac_drv;
 
diff --git a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_mac.c b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_mac.c
index 5e0241f2359d..df1bfbd93a9d 100644
--- a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_mac.c
+++ b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_mac.c
@@ -244,7 +244,7 @@ int hns_mac_get_inner_port_num(struct hns_mac_cb *mac_cb, u8 vmid, u8 *port_num)
  *@addr:mac address
  */
 int hns_mac_change_vf_addr(struct hns_mac_cb *mac_cb,
-			   u32 vmid, char *addr)
+			   u32 vmid, const char *addr)
 {
 	int ret;
 	struct mac_driver *mac_ctrl_drv = hns_mac_get_drv(mac_cb);
diff --git a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_mac.h b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_mac.h
index 22589799f1a5..c6783a78d63d 100644
--- a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_mac.h
+++ b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_mac.h
@@ -352,7 +352,7 @@ struct mac_driver {
 	/*disable mac when disable nic or dsaf*/
 	void (*mac_disable)(void *mac_drv, enum mac_commom_mode mode);
 	/* config mac address*/
-	void (*set_mac_addr)(void *mac_drv,	char *mac_addr);
+	void (*set_mac_addr)(void *mac_drv,	const char *mac_addr);
 	/*adjust mac mode of port,include speed and duplex*/
 	int (*adjust_link)(void *mac_drv, enum mac_speed speed,
 			   u32 full_duplex);
@@ -433,7 +433,8 @@ int hns_mac_init(struct dsaf_device *dsaf_dev);
 void mac_adjust_link(struct net_device *net_dev);
 bool hns_mac_need_adjust_link(struct hns_mac_cb *mac_cb, int speed, int duplex);
 void hns_mac_get_link_status(struct hns_mac_cb *mac_cb,	u32 *link_status);
-int hns_mac_change_vf_addr(struct hns_mac_cb *mac_cb, u32 vmid, char *addr);
+int hns_mac_change_vf_addr(struct hns_mac_cb *mac_cb, u32 vmid,
+			   const char *addr);
 int hns_mac_set_multi(struct hns_mac_cb *mac_cb,
 		      u32 port_num, char *addr, bool enable);
 int hns_mac_vm_config_bc_en(struct hns_mac_cb *mac_cb, u32 vm, bool enable);
diff --git a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_xgmac.c b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_xgmac.c
index a60f207768fc..10dbcb14d314 100644
--- a/drivers/net/ethernet/hisilicon/hns/hns_dsaf_xgmac.c
+++ b/drivers/net/ethernet/hisilicon/hns/hns_dsaf_xgmac.c
@@ -258,7 +258,7 @@ static void hns_xgmac_pausefrm_cfg(void *mac_drv, u32 rx_en, u32 tx_en)
 	dsaf_write_dev(drv, XGMAC_MAC_PAUSE_CTRL_REG, origin);
 }
 
-static void hns_xgmac_set_pausefrm_mac_addr(void *mac_drv, char *mac_addr)
+static void hns_xgmac_set_pausefrm_mac_addr(void *mac_drv, const char *mac_addr)
 {
 	struct mac_driver *drv = (struct mac_driver *)mac_drv;
 
diff --git a/drivers/net/ethernet/hisilicon/hns3/hnae3.h b/drivers/net/ethernet/hisilicon/hns3/hnae3.h
index bc3d111a2ba9..93b1ea1a7388 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hnae3.h
+++ b/drivers/net/ethernet/hisilicon/hns3/hnae3.h
@@ -343,7 +343,7 @@ struct hnae3_ae_ops {
 				   u32 *tx_usecs_high, u32 *rx_usecs_high);
 
 	void (*get_mac_addr)(struct hnae3_handle *handle, u8 *p);
-	int (*set_mac_addr)(struct hnae3_handle *handle, void *p,
+	int (*set_mac_addr)(struct hnae3_handle *handle, const void *p,
 			    bool is_first);
 	int (*add_uc_addr)(struct hnae3_handle *handle,
 			   const unsigned char *addr);
* Unmerged path drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_main.c
diff --git a/drivers/net/ethernet/hisilicon/hns3/hns3vf/hclgevf_main.c b/drivers/net/ethernet/hisilicon/hns3/hns3vf/hclgevf_main.c
index 890479ed4903..ba6ffac09dc4 100644
--- a/drivers/net/ethernet/hisilicon/hns3/hns3vf/hclgevf_main.c
+++ b/drivers/net/ethernet/hisilicon/hns3/hns3vf/hclgevf_main.c
@@ -873,7 +873,7 @@ static void hclgevf_get_mac_addr(struct hnae3_handle *handle, u8 *p)
 	ether_addr_copy(p, hdev->hw.mac.mac_addr);
 }
 
-static int hclgevf_set_mac_addr(struct hnae3_handle *handle, void *p,
+static int hclgevf_set_mac_addr(struct hnae3_handle *handle, const void *p,
 				bool is_first)
 {
 	struct hclgevf_dev *hdev = hclgevf_ae_get_hdev(handle);
diff --git a/drivers/net/ethernet/i825xx/sun3_82586.c b/drivers/net/ethernet/i825xx/sun3_82586.c
index eff693badbfb..2dfbd120e57f 100644
--- a/drivers/net/ethernet/i825xx/sun3_82586.c
+++ b/drivers/net/ethernet/i825xx/sun3_82586.c
@@ -463,7 +463,7 @@ static int init586(struct net_device *dev)
 	ias_cmd->cmd_cmd	= swab16(CMD_IASETUP | CMD_LAST);
 	ias_cmd->cmd_link	= 0xffff;
 
-	memcpy((char *)&ias_cmd->iaddr,(char *) dev->dev_addr,ETH_ALEN);
+	memcpy((char *)&ias_cmd->iaddr,(const char *) dev->dev_addr,ETH_ALEN);
 
 	p->scb->cbl_offset = make16(ias_cmd);
 
diff --git a/drivers/net/ethernet/intel/i40e/i40e.h b/drivers/net/ethernet/intel/i40e/i40e.h
index 6d040e81112c..91df2b92b489 100644
--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -435,7 +435,7 @@ static inline bool i40e_is_channel_macvlan(struct i40e_channel *ch)
 	return !!ch->fwd;
 }
 
-static inline u8 *i40e_channel_mac(struct i40e_channel *ch)
+static inline const u8 *i40e_channel_mac(struct i40e_channel *ch)
 {
 	if (i40e_is_channel_macvlan(ch))
 		return ch->fwd->netdev->dev_addr;
diff --git a/drivers/net/ethernet/intel/ixgb/ixgb_hw.c b/drivers/net/ethernet/intel/ixgb/ixgb_hw.c
index cbaa933ef30d..303455cb1c84 100644
--- a/drivers/net/ethernet/intel/ixgb/ixgb_hw.c
+++ b/drivers/net/ethernet/intel/ixgb/ixgb_hw.c
@@ -551,7 +551,7 @@ ixgb_mta_set(struct ixgb_hw *hw,
  *****************************************************************************/
 void
 ixgb_rar_set(struct ixgb_hw *hw,
-		  u8 *addr,
+		  const u8 *addr,
 		  u32 index)
 {
 	u32 rar_low, rar_high;
diff --git a/drivers/net/ethernet/intel/ixgb/ixgb_hw.h b/drivers/net/ethernet/intel/ixgb/ixgb_hw.h
index 6064583095da..70bcff5fb3db 100644
--- a/drivers/net/ethernet/intel/ixgb/ixgb_hw.h
+++ b/drivers/net/ethernet/intel/ixgb/ixgb_hw.h
@@ -740,7 +740,7 @@ bool ixgb_adapter_start(struct ixgb_hw *hw);
 void ixgb_check_for_link(struct ixgb_hw *hw);
 bool ixgb_check_for_bad_link(struct ixgb_hw *hw);
 
-void ixgb_rar_set(struct ixgb_hw *hw, u8 *addr, u32 index);
+void ixgb_rar_set(struct ixgb_hw *hw, const u8 *addr, u32 index);
 
 /* Filters (multicast, vlan, receive) */
 void ixgb_mc_addr_list_update(struct ixgb_hw *hw, u8 *mc_addr_list,
diff --git a/drivers/net/ethernet/marvell/mv643xx_eth.c b/drivers/net/ethernet/marvell/mv643xx_eth.c
index 6179bef41ec6..b77f0a5cc499 100644
--- a/drivers/net/ethernet/marvell/mv643xx_eth.c
+++ b/drivers/net/ethernet/marvell/mv643xx_eth.c
@@ -1781,7 +1781,7 @@ static void uc_addr_get(struct mv643xx_eth_private *mp, unsigned char *addr)
 	addr[5] = mac_l & 0xff;
 }
 
-static void uc_addr_set(struct mv643xx_eth_private *mp, unsigned char *addr)
+static void uc_addr_set(struct mv643xx_eth_private *mp, const u8 *addr)
 {
 	wrlp(mp, MAC_ADDR_HIGH,
 		(addr[0] << 24) | (addr[1] << 16) | (addr[2] << 8) | addr[3]);
diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c
index aa243112d05c..aeece4b03674 100644
--- a/drivers/net/ethernet/marvell/mvneta.c
+++ b/drivers/net/ethernet/marvell/mvneta.c
@@ -1530,8 +1530,8 @@ static void mvneta_set_ucast_addr(struct mvneta_port *pp, u8 last_nibble,
 }
 
 /* Set mac address */
-static void mvneta_mac_addr_set(struct mvneta_port *pp, unsigned char *addr,
-				int queue)
+static void mvneta_mac_addr_set(struct mvneta_port *pp,
+				const unsigned char *addr, int queue)
 {
 	unsigned int mac_h;
 	unsigned int mac_l;
diff --git a/drivers/net/ethernet/marvell/pxa168_eth.c b/drivers/net/ethernet/marvell/pxa168_eth.c
index 8acd668c1a43..20d62fcec102 100644
--- a/drivers/net/ethernet/marvell/pxa168_eth.c
+++ b/drivers/net/ethernet/marvell/pxa168_eth.c
@@ -400,7 +400,7 @@ static void inverse_every_nibble(unsigned char *mac_addr)
  * Outputs
  * return the calculated entry.
  */
-static u32 hash_function(unsigned char *mac_addr_orig)
+static u32 hash_function(const unsigned char *mac_addr_orig)
 {
 	u32 hash_result;
 	u32 addr0;
@@ -445,7 +445,7 @@ static u32 hash_function(unsigned char *mac_addr_orig)
  * -ENOSPC if table full
  */
 static int add_del_hash_entry(struct pxa168_eth_private *pep,
-			      unsigned char *mac_addr,
+			      const unsigned char *mac_addr,
 			      u32 rd, u32 skip, int del)
 {
 	struct addr_table_entry *entry, *start;
@@ -532,7 +532,7 @@ static int add_del_hash_entry(struct pxa168_eth_private *pep,
  */
 static void update_hash_table_mac_address(struct pxa168_eth_private *pep,
 					  unsigned char *oaddr,
-					  unsigned char *addr)
+					  const unsigned char *addr)
 {
 	/* Delete old entry */
 	if (oaddr)
* Unmerged path drivers/net/ethernet/mediatek/mtk_star_emac.c
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
index 8f87ddcc4d61..c46c25b18b81 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_fs.c
@@ -70,12 +70,12 @@ struct mlx5e_l2_hash_node {
 	bool   mpfs;
 };
 
-static inline int mlx5e_hash_l2(u8 *addr)
+static inline int mlx5e_hash_l2(const u8 *addr)
 {
 	return addr[5];
 }
 
-static void mlx5e_add_l2_to_hash(struct hlist_head *hash, u8 *addr)
+static void mlx5e_add_l2_to_hash(struct hlist_head *hash, const u8 *addr)
 {
 	struct mlx5e_l2_hash_node *hn;
 	int ix = mlx5e_hash_l2(addr);
diff --git a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
index 79f26b56e0a4..58fec228550d 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/ipoib/ipoib.c
@@ -219,7 +219,7 @@ void mlx5i_uninit_underlay_qp(struct mlx5e_priv *priv)
 
 int mlx5i_create_underlay_qp(struct mlx5e_priv *priv)
 {
-	unsigned char *dev_addr = priv->netdev->dev_addr;
+	const unsigned char *dev_addr = priv->netdev->dev_addr;
 	u32 out[MLX5_ST_SZ_DW(create_qp_out)] = {};
 	u32 in[MLX5_ST_SZ_DW(create_qp_in)] = {};
 	struct mlx5i_priv *ipriv = priv->ppriv;
diff --git a/drivers/net/ethernet/micrel/ks8842.c b/drivers/net/ethernet/micrel/ks8842.c
index 8e6e0b501a37..a4d566afc734 100644
--- a/drivers/net/ethernet/micrel/ks8842.c
+++ b/drivers/net/ethernet/micrel/ks8842.c
@@ -392,7 +392,7 @@ static void ks8842_read_mac_addr(struct ks8842_adapter *adapter, u8 *dest)
 	}
 }
 
-static void ks8842_write_mac_addr(struct ks8842_adapter *adapter, u8 *mac)
+static void ks8842_write_mac_addr(struct ks8842_adapter *adapter, const u8 *mac)
 {
 	unsigned long flags;
 	unsigned i;
diff --git a/drivers/net/ethernet/micrel/ksz884x.c b/drivers/net/ethernet/micrel/ksz884x.c
index d339acc0b659..894bd3c7e46a 100644
--- a/drivers/net/ethernet/micrel/ksz884x.c
+++ b/drivers/net/ethernet/micrel/ksz884x.c
@@ -4117,7 +4117,7 @@ static void hw_set_add_addr(struct ksz_hw *hw)
 	}
 }
 
-static int hw_add_addr(struct ksz_hw *hw, u8 *mac_addr)
+static int hw_add_addr(struct ksz_hw *hw, const u8 *mac_addr)
 {
 	int i;
 	int j = ADDITIONAL_ENTRIES;
@@ -4138,7 +4138,7 @@ static int hw_add_addr(struct ksz_hw *hw, u8 *mac_addr)
 	return -1;
 }
 
-static int hw_del_addr(struct ksz_hw *hw, u8 *mac_addr)
+static int hw_del_addr(struct ksz_hw *hw, const u8 *mac_addr)
 {
 	int i;
 
diff --git a/drivers/net/ethernet/myricom/myri10ge/myri10ge.c b/drivers/net/ethernet/myricom/myri10ge/myri10ge.c
index e882d3b48e8f..9c406b64a501 100644
--- a/drivers/net/ethernet/myricom/myri10ge/myri10ge.c
+++ b/drivers/net/ethernet/myricom/myri10ge/myri10ge.c
@@ -797,7 +797,8 @@ static int myri10ge_load_firmware(struct myri10ge_priv *mgp, int adopt)
 	return status;
 }
 
-static int myri10ge_update_mac_address(struct myri10ge_priv *mgp, u8 * addr)
+static int myri10ge_update_mac_address(struct myri10ge_priv *mgp,
+				       const u8 * addr)
 {
 	struct myri10ge_cmd cmd;
 	int status;
diff --git a/drivers/net/ethernet/neterion/s2io.c b/drivers/net/ethernet/neterion/s2io.c
index 7545eaf07d74..7faa378910f6 100644
--- a/drivers/net/ethernet/neterion/s2io.c
+++ b/drivers/net/ethernet/neterion/s2io.c
@@ -5203,7 +5203,7 @@ static int s2io_set_mac_addr(struct net_device *dev, void *p)
  *  as defined in errno.h file on failure.
  */
 
-static int do_s2io_prog_unicast(struct net_device *dev, u8 *addr)
+static int do_s2io_prog_unicast(struct net_device *dev, const u8 *addr)
 {
 	struct s2io_nic *sp = netdev_priv(dev);
 	register u64 mac_addr = 0, perm_addr = 0;
diff --git a/drivers/net/ethernet/neterion/s2io.h b/drivers/net/ethernet/neterion/s2io.h
index b908cbed15d3..77463b32c559 100644
--- a/drivers/net/ethernet/neterion/s2io.h
+++ b/drivers/net/ethernet/neterion/s2io.h
@@ -1093,7 +1093,7 @@ static void s2io_reset(struct s2io_nic * sp);
 static int s2io_poll_msix(struct napi_struct *napi, int budget);
 static int s2io_poll_inta(struct napi_struct *napi, int budget);
 static void s2io_init_pci(struct s2io_nic * sp);
-static int do_s2io_prog_unicast(struct net_device *dev, u8 *addr);
+static int do_s2io_prog_unicast(struct net_device *dev, const u8 *addr);
 static void s2io_alarm_handle(struct timer_list *t);
 static irqreturn_t
 s2io_msix_ring_handle(int irq, void *dev_id);
diff --git a/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c b/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
index 7248d248f604..a14169b66177 100644
--- a/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
+++ b/drivers/net/ethernet/netronome/nfp/flower/tunnel_conf.c
@@ -836,7 +836,7 @@ nfp_tunnel_put_ipv6_off(struct nfp_app *app, struct nfp_ipv6_addr_entry *entry)
 }
 
 static int
-__nfp_tunnel_offload_mac(struct nfp_app *app, u8 *mac, u16 idx, bool del)
+__nfp_tunnel_offload_mac(struct nfp_app *app, const u8 *mac, u16 idx, bool del)
 {
 	struct nfp_tun_mac_addr_offload payload;
 
@@ -885,7 +885,7 @@ static bool nfp_tunnel_is_mac_idx_global(u16 nfp_mac_idx)
 }
 
 static struct nfp_tun_offloaded_mac *
-nfp_tunnel_lookup_offloaded_macs(struct nfp_app *app, u8 *mac)
+nfp_tunnel_lookup_offloaded_macs(struct nfp_app *app, const u8 *mac)
 {
 	struct nfp_flower_priv *priv = app->priv;
 
@@ -1004,7 +1004,7 @@ nfp_tunnel_add_shared_mac(struct nfp_app *app, struct net_device *netdev,
 
 static int
 nfp_tunnel_del_shared_mac(struct nfp_app *app, struct net_device *netdev,
-			  u8 *mac, bool mod)
+			  const u8 *mac, bool mod)
 {
 	struct nfp_flower_priv *priv = app->priv;
 	struct nfp_flower_repr_priv *repr_priv;
diff --git a/drivers/net/ethernet/nxp/lpc_eth.c b/drivers/net/ethernet/nxp/lpc_eth.c
index f378a450e51b..17a1a51af8fe 100644
--- a/drivers/net/ethernet/nxp/lpc_eth.c
+++ b/drivers/net/ethernet/nxp/lpc_eth.c
@@ -444,7 +444,7 @@ struct netdata_local {
 /*
  * MAC support functions
  */
-static void __lpc_set_mac(struct netdata_local *pldat, u8 *mac)
+static void __lpc_set_mac(struct netdata_local *pldat, const u8 *mac)
 {
 	u32 tmp;
 
diff --git a/drivers/net/ethernet/qlogic/qed/qed_dev.c b/drivers/net/ethernet/qlogic/qed/qed_dev.c
index f8c6f753e831..bd37567a31d9 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_dev.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev.c
@@ -951,7 +951,7 @@ qed_llh_remove_filter(struct qed_hwfn *p_hwfn,
 }
 
 int qed_llh_add_mac_filter(struct qed_dev *cdev,
-			   u8 ppfid, u8 mac_addr[ETH_ALEN])
+			   u8 ppfid, const u8 mac_addr[ETH_ALEN])
 {
 	struct qed_hwfn *p_hwfn = QED_LEADING_HWFN(cdev);
 	struct qed_ptt *p_ptt = qed_ptt_acquire(p_hwfn);
diff --git a/drivers/net/ethernet/qlogic/qed/qed_dev_api.h b/drivers/net/ethernet/qlogic/qed/qed_dev_api.h
index d3c1f3879be8..e0d444cb98c5 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_dev_api.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_dev_api.h
@@ -345,7 +345,7 @@ int qed_llh_set_roce_affinity(struct qed_dev *cdev, enum qed_eng eng);
  * @param mac_addr - MAC to add
  */
 int qed_llh_add_mac_filter(struct qed_dev *cdev,
-			   u8 ppfid, u8 mac_addr[ETH_ALEN]);
+			   u8 ppfid, const u8 mac_addr[ETH_ALEN]);
 
 /**
  * @brief qed_llh_remove_mac_filter - Remove a LLH MAC filter from the given
diff --git a/drivers/net/ethernet/qlogic/qed/qed_l2.c b/drivers/net/ethernet/qlogic/qed/qed_l2.c
index dfaf10edfabf..715b19e8150d 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_l2.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_l2.c
@@ -2867,7 +2867,7 @@ static int qed_fp_cqe_completion(struct qed_dev *dev,
 				      cqe);
 }
 
-static int qed_req_bulletin_update_mac(struct qed_dev *cdev, u8 *mac)
+static int qed_req_bulletin_update_mac(struct qed_dev *cdev, const u8 *mac)
 {
 	int i, ret;
 
diff --git a/drivers/net/ethernet/qlogic/qed/qed_main.c b/drivers/net/ethernet/qlogic/qed/qed_main.c
index 5856fa56c330..0b3bc06409bc 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_main.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_main.c
@@ -2892,7 +2892,7 @@ static int qed_update_drv_state(struct qed_dev *cdev, bool active)
 	return status;
 }
 
-static int qed_update_mac(struct qed_dev *cdev, u8 *mac)
+static int qed_update_mac(struct qed_dev *cdev, const u8 *mac)
 {
 	struct qed_hwfn *hwfn = QED_LEADING_HWFN(cdev);
 	struct qed_ptt *ptt;
diff --git a/drivers/net/ethernet/qlogic/qed/qed_mcp.c b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
index 0c2236641e8e..d5dc61d748b6 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.c
@@ -2855,7 +2855,7 @@ int qed_mcp_ov_update_mtu(struct qed_hwfn *p_hwfn,
 }
 
 int qed_mcp_ov_update_mac(struct qed_hwfn *p_hwfn,
-			  struct qed_ptt *p_ptt, u8 *mac)
+			  struct qed_ptt *p_ptt, const u8 *mac)
 {
 	struct qed_mcp_mb_params mb_params;
 	u32 mfw_mac[2];
diff --git a/drivers/net/ethernet/qlogic/qed/qed_mcp.h b/drivers/net/ethernet/qlogic/qed/qed_mcp.h
index 8edb450d0abf..0dd036d95c34 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_mcp.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_mcp.h
@@ -534,7 +534,7 @@ int qed_mcp_ov_update_mtu(struct qed_hwfn *p_hwfn,
  * @return int - 0 - operation was successful.
  */
 int qed_mcp_ov_update_mac(struct qed_hwfn *p_hwfn,
-			  struct qed_ptt *p_ptt, u8 *mac);
+			  struct qed_ptt *p_ptt, const u8 *mac);
 
 /**
  * @brief Send WOL mode to MFW
diff --git a/drivers/net/ethernet/qlogic/qed/qed_rdma.c b/drivers/net/ethernet/qlogic/qed/qed_rdma.c
index 4f4b79250a2b..725ace88272e 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_rdma.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_rdma.c
@@ -1966,7 +1966,7 @@ static void qed_rdma_remove_user(void *rdma_cxt, u16 dpi)
 
 static int qed_roce_ll2_set_mac_filter(struct qed_dev *cdev,
 				       u8 *old_mac_address,
-				       u8 *new_mac_address)
+				       const u8 *new_mac_address)
 {
 	int rc = 0;
 
diff --git a/drivers/net/ethernet/qlogic/qed/qed_vf.c b/drivers/net/ethernet/qlogic/qed/qed_vf.c
index 72a38d53d33f..bc8cbcd0a5f7 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_vf.c
+++ b/drivers/net/ethernet/qlogic/qed/qed_vf.c
@@ -1372,7 +1372,7 @@ int qed_vf_pf_get_coalesce(struct qed_hwfn *p_hwfn,
 
 int
 qed_vf_pf_bulletin_update_mac(struct qed_hwfn *p_hwfn,
-			      u8 *p_mac)
+			      const u8 *p_mac)
 {
 	struct qed_vf_iov *p_iov = p_hwfn->vf_iov_info;
 	struct vfpf_bulletin_update_mac_tlv *p_req;
diff --git a/drivers/net/ethernet/qlogic/qed/qed_vf.h b/drivers/net/ethernet/qlogic/qed/qed_vf.h
index 60d2bb64e65f..a8b0243515ee 100644
--- a/drivers/net/ethernet/qlogic/qed/qed_vf.h
+++ b/drivers/net/ethernet/qlogic/qed/qed_vf.h
@@ -1033,7 +1033,7 @@ u32 qed_vf_hw_bar_size(struct qed_hwfn *p_hwfn, enum BAR_ID bar_id);
  *
  * @param p_mac - mac address to be updated in bulletin board
  */
-int qed_vf_pf_bulletin_update_mac(struct qed_hwfn *p_hwfn, u8 *p_mac);
+int qed_vf_pf_bulletin_update_mac(struct qed_hwfn *p_hwfn, const u8 *p_mac);
 
 #else
 static inline void qed_vf_get_link_params(struct qed_hwfn *p_hwfn,
@@ -1222,7 +1222,7 @@ static inline int qed_vf_pf_tunnel_param_update(struct qed_hwfn *p_hwfn,
 }
 
 static inline int qed_vf_pf_bulletin_update_mac(struct qed_hwfn *p_hwfn,
-						u8 *p_mac)
+						const u8 *p_mac)
 {
 	return -EINVAL;
 }
diff --git a/drivers/net/ethernet/qlogic/qede/qede_filter.c b/drivers/net/ethernet/qlogic/qede/qede_filter.c
index 01f3c2dd638f..077621ec2b1f 100644
--- a/drivers/net/ethernet/qlogic/qede/qede_filter.c
+++ b/drivers/net/ethernet/qlogic/qede/qede_filter.c
@@ -617,7 +617,7 @@ void qede_fill_rss_params(struct qede_dev *edev,
 
 static int qede_set_ucast_rx_mac(struct qede_dev *edev,
 				 enum qed_filter_xcast_params_type opcode,
-				 unsigned char mac[ETH_ALEN])
+				 const unsigned char mac[ETH_ALEN])
 {
 	struct qed_filter_params filter_cmd;
 
diff --git a/drivers/net/ethernet/qualcomm/emac/emac-mac.c b/drivers/net/ethernet/qualcomm/emac/emac-mac.c
index 031f6e6ee9c1..0b606d7e351f 100644
--- a/drivers/net/ethernet/qualcomm/emac/emac-mac.c
+++ b/drivers/net/ethernet/qualcomm/emac/emac-mac.c
@@ -428,7 +428,7 @@ static void emac_mac_dma_config(struct emac_adapter *adpt)
 }
 
 /* set MAC address */
-static void emac_set_mac_address(struct emac_adapter *adpt, u8 *addr)
+static void emac_set_mac_address(struct emac_adapter *adpt, const u8 *addr)
 {
 	u32 sta;
 
diff --git a/drivers/net/ethernet/rdc/r6040.c b/drivers/net/ethernet/rdc/r6040.c
index 25b4c8152b43..19af93bcd984 100644
--- a/drivers/net/ethernet/rdc/r6040.c
+++ b/drivers/net/ethernet/rdc/r6040.c
@@ -459,7 +459,7 @@ static void r6040_down(struct net_device *dev)
 {
 	struct r6040_private *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
-	u16 *adrp;
+	const u16 *adrp;
 
 	/* Stop MAC */
 	iowrite16(MSK_INT, ioaddr + MIER);	/* Mask Off Interrupt */
@@ -468,7 +468,7 @@ static void r6040_down(struct net_device *dev)
 	r6040_reset_mac(lp);
 
 	/* Restore MAC Address to MIDx */
-	adrp = (u16 *) dev->dev_addr;
+	adrp = (const u16 *) dev->dev_addr;
 	iowrite16(adrp[0], ioaddr + MID_0L);
 	iowrite16(adrp[1], ioaddr + MID_0M);
 	iowrite16(adrp[2], ioaddr + MID_0H);
@@ -744,13 +744,13 @@ static void r6040_mac_address(struct net_device *dev)
 {
 	struct r6040_private *lp = netdev_priv(dev);
 	void __iomem *ioaddr = lp->base;
-	u16 *adrp;
+	const u16 *adrp;
 
 	/* Reset MAC */
 	r6040_reset_mac(lp);
 
 	/* Restore MAC Address */
-	adrp = (u16 *) dev->dev_addr;
+	adrp = (const u16 *) dev->dev_addr;
 	iowrite16(adrp[0], ioaddr + MID_0L);
 	iowrite16(adrp[1], ioaddr + MID_0M);
 	iowrite16(adrp[2], ioaddr + MID_0H);
@@ -860,13 +860,13 @@ static void r6040_multicast_list(struct net_device *dev)
 	unsigned long flags;
 	struct netdev_hw_addr *ha;
 	int i;
-	u16 *adrp;
+	const u16 *adrp;
 	u16 hash_table[4] = { 0 };
 
 	spin_lock_irqsave(&lp->lock, flags);
 
 	/* Keep our MAC Address */
-	adrp = (u16 *)dev->dev_addr;
+	adrp = (const u16 *)dev->dev_addr;
 	iowrite16(adrp[0], ioaddr + MID_0L);
 	iowrite16(adrp[1], ioaddr + MID_0M);
 	iowrite16(adrp[2], ioaddr + MID_0H);
diff --git a/drivers/net/ethernet/samsung/sxgbe/sxgbe_common.h b/drivers/net/ethernet/samsung/sxgbe/sxgbe_common.h
index c61f260e18a4..2fddaa5adfe7 100644
--- a/drivers/net/ethernet/samsung/sxgbe/sxgbe_common.h
+++ b/drivers/net/ethernet/samsung/sxgbe/sxgbe_common.h
@@ -332,7 +332,7 @@ struct sxgbe_core_ops {
 	/* Set power management mode (e.g. magic frame) */
 	void (*pmt)(void __iomem *ioaddr, unsigned long mode);
 	/* Set/Get Unicast MAC addresses */
-	void (*set_umac_addr)(void __iomem *ioaddr, unsigned char *addr,
+	void (*set_umac_addr)(void __iomem *ioaddr, const unsigned char *addr,
 			      unsigned int reg_n);
 	void (*get_umac_addr)(void __iomem *ioaddr, unsigned char *addr,
 			      unsigned int reg_n);
diff --git a/drivers/net/ethernet/samsung/sxgbe/sxgbe_core.c b/drivers/net/ethernet/samsung/sxgbe/sxgbe_core.c
index 58c35692560e..91fdde4b8052 100644
--- a/drivers/net/ethernet/samsung/sxgbe/sxgbe_core.c
+++ b/drivers/net/ethernet/samsung/sxgbe/sxgbe_core.c
@@ -88,7 +88,8 @@ static void sxgbe_core_pmt(void __iomem *ioaddr, unsigned long mode)
 }
 
 /* Set/Get Unicast MAC addresses */
-static void sxgbe_core_set_umac_addr(void __iomem *ioaddr, unsigned char *addr,
+static void sxgbe_core_set_umac_addr(void __iomem *ioaddr,
+				     const unsigned char *addr,
 				     unsigned int reg_n)
 {
 	u32 high_word, low_word;
diff --git a/drivers/net/ethernet/sfc/ef10.c b/drivers/net/ethernet/sfc/ef10.c
index b9dd2c7b5450..36d1966b08b6 100644
--- a/drivers/net/ethernet/sfc/ef10.c
+++ b/drivers/net/ethernet/sfc/ef10.c
@@ -1038,7 +1038,7 @@ int efx_ef10_vadaptor_free(struct efx_nic *efx, unsigned int port_id)
 }
 
 int efx_ef10_vport_add_mac(struct efx_nic *efx,
-			   unsigned int port_id, u8 *mac)
+			   unsigned int port_id, const u8 *mac)
 {
 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_ADD_MAC_ADDRESS_IN_LEN);
 
@@ -1050,7 +1050,7 @@ int efx_ef10_vport_add_mac(struct efx_nic *efx,
 }
 
 int efx_ef10_vport_del_mac(struct efx_nic *efx,
-			   unsigned int port_id, u8 *mac)
+			   unsigned int port_id, const u8 *mac)
 {
 	MCDI_DECLARE_BUF(inbuf, MC_CMD_VPORT_DEL_MAC_ADDRESS_IN_LEN);
 
diff --git a/drivers/net/ethernet/sfc/ef10_sriov.c b/drivers/net/ethernet/sfc/ef10_sriov.c
index 752d6406f07e..78daf8d20e23 100644
--- a/drivers/net/ethernet/sfc/ef10_sriov.c
+++ b/drivers/net/ethernet/sfc/ef10_sriov.c
@@ -480,7 +480,7 @@ static int efx_ef10_vport_del_vf_mac(struct efx_nic *efx, unsigned int port_id,
 	return rc;
 }
 
-int efx_ef10_sriov_set_vf_mac(struct efx_nic *efx, int vf_i, u8 *mac)
+int efx_ef10_sriov_set_vf_mac(struct efx_nic *efx, int vf_i, const u8 *mac)
 {
 	struct efx_ef10_nic_data *nic_data = efx->nic_data;
 	struct ef10_vf *vf;
diff --git a/drivers/net/ethernet/sfc/ef10_sriov.h b/drivers/net/ethernet/sfc/ef10_sriov.h
index cfe556d17313..3c703ca878b0 100644
--- a/drivers/net/ethernet/sfc/ef10_sriov.h
+++ b/drivers/net/ethernet/sfc/ef10_sriov.h
@@ -39,7 +39,7 @@ static inline void efx_ef10_sriov_reset(struct efx_nic *efx) {}
 void efx_ef10_sriov_fini(struct efx_nic *efx);
 static inline void efx_ef10_sriov_flr(struct efx_nic *efx, unsigned vf_i) {}
 
-int efx_ef10_sriov_set_vf_mac(struct efx_nic *efx, int vf, u8 *mac);
+int efx_ef10_sriov_set_vf_mac(struct efx_nic *efx, int vf, const u8 *mac);
 
 int efx_ef10_sriov_set_vf_vlan(struct efx_nic *efx, int vf_i,
 			       u16 vlan, u8 qos);
@@ -60,9 +60,9 @@ int efx_ef10_vswitching_restore_vf(struct efx_nic *efx);
 void efx_ef10_vswitching_remove_pf(struct efx_nic *efx);
 void efx_ef10_vswitching_remove_vf(struct efx_nic *efx);
 int efx_ef10_vport_add_mac(struct efx_nic *efx,
-			   unsigned int port_id, u8 *mac);
+			   unsigned int port_id, const u8 *mac);
 int efx_ef10_vport_del_mac(struct efx_nic *efx,
-			   unsigned int port_id, u8 *mac);
+			   unsigned int port_id, const u8 *mac);
 int efx_ef10_vadaptor_alloc(struct efx_nic *efx, unsigned int port_id);
 int efx_ef10_vadaptor_query(struct efx_nic *efx, unsigned int port_id,
 			    u32 *port_flags, u32 *vadaptor_flags,
diff --git a/drivers/net/ethernet/sfc/net_driver.h b/drivers/net/ethernet/sfc/net_driver.h
index 9f7dfdf708cf..1d99f81ff730 100644
--- a/drivers/net/ethernet/sfc/net_driver.h
+++ b/drivers/net/ethernet/sfc/net_driver.h
@@ -1429,7 +1429,7 @@ struct efx_nic_type {
 	bool (*sriov_wanted)(struct efx_nic *efx);
 	void (*sriov_reset)(struct efx_nic *efx);
 	void (*sriov_flr)(struct efx_nic *efx, unsigned vf_i);
-	int (*sriov_set_vf_mac)(struct efx_nic *efx, int vf_i, u8 *mac);
+	int (*sriov_set_vf_mac)(struct efx_nic *efx, int vf_i, const u8 *mac);
 	int (*sriov_set_vf_vlan)(struct efx_nic *efx, int vf_i, u16 vlan,
 				 u8 qos);
 	int (*sriov_set_vf_spoofchk)(struct efx_nic *efx, int vf_i,
diff --git a/drivers/net/ethernet/sfc/siena_sriov.c b/drivers/net/ethernet/sfc/siena_sriov.c
index 83dcfcae3d4b..e9095cf06368 100644
--- a/drivers/net/ethernet/sfc/siena_sriov.c
+++ b/drivers/net/ethernet/sfc/siena_sriov.c
@@ -1591,7 +1591,7 @@ void efx_fini_sriov(void)
 	destroy_workqueue(vfdi_workqueue);
 }
 
-int efx_siena_sriov_set_vf_mac(struct efx_nic *efx, int vf_i, u8 *mac)
+int efx_siena_sriov_set_vf_mac(struct efx_nic *efx, int vf_i, const u8 *mac)
 {
 	struct siena_nic_data *nic_data = efx->nic_data;
 	struct siena_vf *vf;
diff --git a/drivers/net/ethernet/sfc/siena_sriov.h b/drivers/net/ethernet/sfc/siena_sriov.h
index e441c89c25ce..e548c4daf189 100644
--- a/drivers/net/ethernet/sfc/siena_sriov.h
+++ b/drivers/net/ethernet/sfc/siena_sriov.h
@@ -46,7 +46,7 @@ bool efx_siena_sriov_wanted(struct efx_nic *efx);
 void efx_siena_sriov_reset(struct efx_nic *efx);
 void efx_siena_sriov_flr(struct efx_nic *efx, unsigned flr);
 
-int efx_siena_sriov_set_vf_mac(struct efx_nic *efx, int vf, u8 *mac);
+int efx_siena_sriov_set_vf_mac(struct efx_nic *efx, int vf, const u8 *mac);
 int efx_siena_sriov_set_vf_vlan(struct efx_nic *efx, int vf,
 				u16 vlan, u8 qos);
 int efx_siena_sriov_set_vf_spoofchk(struct efx_nic *efx, int vf,
diff --git a/drivers/net/ethernet/sis/sis900.c b/drivers/net/ethernet/sis/sis900.c
index c50a8834f80e..c89c7a283534 100644
--- a/drivers/net/ethernet/sis/sis900.c
+++ b/drivers/net/ethernet/sis/sis900.c
@@ -1095,7 +1095,7 @@ sis900_init_rxfilter (struct net_device * net_dev)
 
 	/* load MAC addr to filter data register */
 	for (i = 0 ; i < 3 ; i++) {
-		u32 w = (u32) *((u16 *)(net_dev->dev_addr)+i);
+		u32 w = (u32) *((const u16 *)(net_dev->dev_addr)+i);
 
 		sw32(rfcr, i << RFADDR_shift);
 		sw32(rfdr, w);
diff --git a/drivers/net/ethernet/smsc/smsc911x.c b/drivers/net/ethernet/smsc/smsc911x.c
index c009407618d9..b7ac2f7d0768 100644
--- a/drivers/net/ethernet/smsc/smsc911x.c
+++ b/drivers/net/ethernet/smsc/smsc911x.c
@@ -1513,7 +1513,7 @@ static int smsc911x_soft_reset(struct smsc911x_data *pdata)
 
 /* Sets the device MAC address to dev_addr, called with mac_lock held */
 static void
-smsc911x_set_hw_mac_address(struct smsc911x_data *pdata, u8 dev_addr[6])
+smsc911x_set_hw_mac_address(struct smsc911x_data *pdata, const u8 dev_addr[6])
 {
 	u32 mac_high16 = (dev_addr[5] << 8) | dev_addr[4];
 	u32 mac_low32 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |
diff --git a/drivers/net/ethernet/smsc/smsc9420.c b/drivers/net/ethernet/smsc/smsc9420.c
index 9b6366b20110..d95e14c5a636 100644
--- a/drivers/net/ethernet/smsc/smsc9420.c
+++ b/drivers/net/ethernet/smsc/smsc9420.c
@@ -425,7 +425,7 @@ static const struct ethtool_ops smsc9420_ethtool_ops = {
 static void smsc9420_set_mac_address(struct net_device *dev)
 {
 	struct smsc9420_pdata *pd = netdev_priv(dev);
-	u8 *dev_addr = dev->dev_addr;
+	const u8 *dev_addr = dev->dev_addr;
 	u32 mac_high16 = (dev_addr[5] << 8) | dev_addr[4];
 	u32 mac_low32 = (dev_addr[3] << 24) | (dev_addr[2] << 16) |
 	    (dev_addr[1] << 8) | dev_addr[0];
diff --git a/drivers/net/ethernet/stmicro/stmmac/common.h b/drivers/net/ethernet/stmicro/stmmac/common.h
index 6f70b6456265..b0f958004a75 100644
--- a/drivers/net/ethernet/stmicro/stmmac/common.h
+++ b/drivers/net/ethernet/stmicro/stmmac/common.h
@@ -537,13 +537,13 @@ int dwmac1000_setup(struct stmmac_priv *priv);
 int dwmac4_setup(struct stmmac_priv *priv);
 int dwxgmac2_setup(struct stmmac_priv *priv);
 
-void stmmac_set_mac_addr(void __iomem *ioaddr, u8 addr[6],
+void stmmac_set_mac_addr(void __iomem *ioaddr, const u8 addr[6],
 			 unsigned int high, unsigned int low);
 void stmmac_get_mac_addr(void __iomem *ioaddr, unsigned char *addr,
 			 unsigned int high, unsigned int low);
 void stmmac_set_mac(void __iomem *ioaddr, bool enable);
 
-void stmmac_dwmac4_set_mac_addr(void __iomem *ioaddr, u8 addr[6],
+void stmmac_dwmac4_set_mac_addr(void __iomem *ioaddr, const u8 addr[6],
 				unsigned int high, unsigned int low);
 void stmmac_dwmac4_get_mac_addr(void __iomem *ioaddr, unsigned char *addr,
 				unsigned int high, unsigned int low);
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
index a91adf929fa3..650fa8ec6ed4 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
@@ -612,7 +612,7 @@ static void sun8i_dwmac_set_mac(void __iomem *ioaddr, bool enable)
  * If addr is NULL, clear the slot
  */
 static void sun8i_dwmac_set_umac_addr(struct mac_device_info *hw,
-				      unsigned char *addr,
+				      const unsigned char *addr,
 				      unsigned int reg_n)
 {
 	void __iomem *ioaddr = hw->pcsr;
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
index cb9ea5f3afdd..623970d43e0e 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
@@ -114,7 +114,7 @@ static void dwmac1000_dump_regs(struct mac_device_info *hw, u32 *reg_space)
 }
 
 static void dwmac1000_set_umac_addr(struct mac_device_info *hw,
-				    unsigned char *addr,
+				    const unsigned char *addr,
 				    unsigned int reg_n)
 {
 	void __iomem *ioaddr = hw->pcsr;
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
index d621b5189c41..650d62b1f6ba 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac100_core.c
@@ -78,7 +78,7 @@ static int dwmac100_irq_status(struct mac_device_info *hw,
 }
 
 static void dwmac100_set_umac_addr(struct mac_device_info *hw,
-				   unsigned char *addr,
+				   const unsigned char *addr,
 				   unsigned int reg_n)
 {
 	void __iomem *ioaddr = hw->pcsr;
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
index 1df9930ab228..82c1610e26a3 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
@@ -325,7 +325,7 @@ static void dwmac4_pmt(struct mac_device_info *hw, unsigned long mode)
 }
 
 static void dwmac4_set_umac_addr(struct mac_device_info *hw,
-				 unsigned char *addr, unsigned int reg_n)
+				 const unsigned char *addr, unsigned int reg_n)
 {
 	void __iomem *ioaddr = hw->pcsr;
 
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac4_lib.c b/drivers/net/ethernet/stmicro/stmmac/dwmac4_lib.c
index 698ee1d5ca95..cd296a5583f8 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_lib.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_lib.c
@@ -191,7 +191,7 @@ int dwmac4_dma_interrupt(void __iomem *ioaddr,
 	return ret;
 }
 
-void stmmac_dwmac4_set_mac_addr(void __iomem *ioaddr, u8 addr[6],
+void stmmac_dwmac4_set_mac_addr(void __iomem *ioaddr, const u8 addr[6],
 				unsigned int high, unsigned int low)
 {
 	unsigned long data;
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c b/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c
index 9e38659769d1..16691d676e07 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac_lib.c
@@ -249,7 +249,7 @@ void dwmac_dma_flush_tx_fifo(void __iomem *ioaddr)
 	do {} while ((readl(ioaddr + DMA_CONTROL) & DMA_CONTROL_FTF));
 }
 
-void stmmac_set_mac_addr(void __iomem *ioaddr, u8 addr[6],
+void stmmac_set_mac_addr(void __iomem *ioaddr, const u8 addr[6],
 			 unsigned int high, unsigned int low)
 {
 	unsigned long data;
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c b/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
index a7d7a05d2aff..8ceafe66eb64 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwxgmac2_core.c
@@ -334,7 +334,8 @@ static void dwxgmac2_pmt(struct mac_device_info *hw, unsigned long mode)
 }
 
 static void dwxgmac2_set_umac_addr(struct mac_device_info *hw,
-				   unsigned char *addr, unsigned int reg_n)
+				   const unsigned char *addr,
+				   unsigned int reg_n)
 {
 	void __iomem *ioaddr = hw->pcsr;
 	u32 value;
diff --git a/drivers/net/ethernet/stmicro/stmmac/hwif.h b/drivers/net/ethernet/stmicro/stmmac/hwif.h
index e3bc40c17ebe..086b61125214 100644
--- a/drivers/net/ethernet/stmicro/stmmac/hwif.h
+++ b/drivers/net/ethernet/stmicro/stmmac/hwif.h
@@ -330,7 +330,8 @@ struct stmmac_ops {
 	/* Set power management mode (e.g. magic frame) */
 	void (*pmt)(struct mac_device_info *hw, unsigned long mode);
 	/* Set/Get Unicast MAC addresses */
-	void (*set_umac_addr)(struct mac_device_info *hw, unsigned char *addr,
+	void (*set_umac_addr)(struct mac_device_info *hw,
+			      const unsigned char *addr,
 			      unsigned int reg_n);
 	void (*get_umac_addr)(struct mac_device_info *hw, unsigned char *addr,
 			      unsigned int reg_n);
* Unmerged path drivers/net/ethernet/stmicro/stmmac/stmmac_selftests.c
diff --git a/drivers/net/ethernet/sun/sunbmac.c b/drivers/net/ethernet/sun/sunbmac.c
index e504c0df0b83..6aa6aa231504 100644
--- a/drivers/net/ethernet/sun/sunbmac.c
+++ b/drivers/net/ethernet/sun/sunbmac.c
@@ -623,7 +623,7 @@ static int bigmac_init_hw(struct bigmac *bp, int from_irq)
 	void __iomem *cregs        = bp->creg;
 	void __iomem *bregs        = bp->bregs;
 	__u32 bblk_dvma = (__u32)bp->bblock_dvma;
-	unsigned char *e = &bp->dev->dev_addr[0];
+	const unsigned char *e = &bp->dev->dev_addr[0];
 
 	/* Latch current counters into statistics. */
 	bigmac_get_counters(bp, bregs);
diff --git a/drivers/net/ethernet/sun/sunqe.c b/drivers/net/ethernet/sun/sunqe.c
index d39a0de7aca0..dd1dded92810 100644
--- a/drivers/net/ethernet/sun/sunqe.c
+++ b/drivers/net/ethernet/sun/sunqe.c
@@ -144,7 +144,7 @@ static int qe_init(struct sunqe *qep, int from_irq)
 	void __iomem *cregs = qep->qcregs;
 	void __iomem *mregs = qep->mregs;
 	void __iomem *gregs = qecp->gregs;
-	unsigned char *e = &qep->dev->dev_addr[0];
+	const unsigned char *e = &qep->dev->dev_addr[0];
 	__u32 qblk_dvma = (__u32)qep->qblock_dvma;
 	u32 tmp;
 	int i;
diff --git a/drivers/net/ethernet/synopsys/dwc-xlgmac-hw.c b/drivers/net/ethernet/synopsys/dwc-xlgmac-hw.c
index cc3f37d110ac..422a8630274f 100644
--- a/drivers/net/ethernet/synopsys/dwc-xlgmac-hw.c
+++ b/drivers/net/ethernet/synopsys/dwc-xlgmac-hw.c
@@ -56,7 +56,7 @@ static int xlgmac_enable_rx_csum(struct xlgmac_pdata *pdata)
 	return 0;
 }
 
-static int xlgmac_set_mac_address(struct xlgmac_pdata *pdata, u8 *addr)
+static int xlgmac_set_mac_address(struct xlgmac_pdata *pdata, const u8 *addr)
 {
 	unsigned int mac_addr_hi, mac_addr_lo;
 
diff --git a/drivers/net/ethernet/synopsys/dwc-xlgmac.h b/drivers/net/ethernet/synopsys/dwc-xlgmac.h
index cab3e40a86b9..83c0abf83405 100644
--- a/drivers/net/ethernet/synopsys/dwc-xlgmac.h
+++ b/drivers/net/ethernet/synopsys/dwc-xlgmac.h
@@ -410,7 +410,7 @@ struct xlgmac_hw_ops {
 	void (*dev_xmit)(struct xlgmac_channel *channel);
 	int (*dev_read)(struct xlgmac_channel *channel);
 
-	int (*set_mac_address)(struct xlgmac_pdata *pdata, u8 *addr);
+	int (*set_mac_address)(struct xlgmac_pdata *pdata, const u8 *addr);
 	int (*config_rx_mode)(struct xlgmac_pdata *pdata);
 	int (*enable_rx_csum)(struct xlgmac_pdata *pdata);
 	int (*disable_rx_csum)(struct xlgmac_pdata *pdata);
diff --git a/drivers/net/ethernet/ti/tlan.c b/drivers/net/ethernet/ti/tlan.c
index fd2dba0e1792..45e12191f302 100644
--- a/drivers/net/ethernet/ti/tlan.c
+++ b/drivers/net/ethernet/ti/tlan.c
@@ -182,7 +182,7 @@ static void	tlan_print_list(struct tlan_list *, char *, int);
 static void	tlan_read_and_clear_stats(struct net_device *, int);
 static void	tlan_reset_adapter(struct net_device *);
 static void	tlan_finish_reset(struct net_device *);
-static void	tlan_set_mac(struct net_device *, int areg, char *mac);
+static void	tlan_set_mac(struct net_device *, int areg, const char *mac);
 
 static void	tlan_phy_print(struct net_device *);
 static void	tlan_phy_detect(struct net_device *);
@@ -2371,7 +2371,7 @@ tlan_finish_reset(struct net_device *dev)
  *
  **************************************************************/
 
-static void tlan_set_mac(struct net_device *dev, int areg, char *mac)
+static void tlan_set_mac(struct net_device *dev, int areg, const char *mac)
 {
 	int i;
 
diff --git a/drivers/net/ethernet/toshiba/tc35815.c b/drivers/net/ethernet/toshiba/tc35815.c
index b802ba8746ae..c47e144e06f6 100644
--- a/drivers/net/ethernet/toshiba/tc35815.c
+++ b/drivers/net/ethernet/toshiba/tc35815.c
@@ -1850,7 +1850,8 @@ static struct net_device_stats *tc35815_get_stats(struct net_device *dev)
 	return &dev->stats;
 }
 
-static void tc35815_set_cam_entry(struct net_device *dev, int index, unsigned char *addr)
+static void tc35815_set_cam_entry(struct net_device *dev, int index,
+				  const unsigned char *addr)
 {
 	struct tc35815_local *lp = netdev_priv(dev);
 	struct tc35815_regs __iomem *tr =
diff --git a/drivers/net/ethernet/xilinx/xilinx_emaclite.c b/drivers/net/ethernet/xilinx/xilinx_emaclite.c
index b1700225a984..7f457a75d6c3 100644
--- a/drivers/net/ethernet/xilinx/xilinx_emaclite.c
+++ b/drivers/net/ethernet/xilinx/xilinx_emaclite.c
@@ -207,12 +207,13 @@ static void xemaclite_disable_interrupts(struct net_local *drvdata)
  * This function writes data from a 16-bit aligned buffer to a 32-bit aligned
  * address in the EmacLite device.
  */
-static void xemaclite_aligned_write(void *src_ptr, u32 *dest_ptr,
+static void xemaclite_aligned_write(const void *src_ptr, u32 *dest_ptr,
 				    unsigned length)
 {
+	const u16 *from_u16_ptr;
 	u32 align_buffer;
 	u32 *to_u32_ptr;
-	u16 *from_u16_ptr, *to_u16_ptr;
+	u16 *to_u16_ptr;
 
 	to_u32_ptr = dest_ptr;
 	from_u16_ptr = src_ptr;
@@ -463,7 +464,7 @@ static u16 xemaclite_recv_data(struct net_local *drvdata, u8 *data, int maxlen)
  * buffers (if configured).
  */
 static void xemaclite_update_address(struct net_local *drvdata,
-				     u8 *address_ptr)
+				     const u8 *address_ptr)
 {
 	void __iomem *addr;
 	u32 reg_data;
diff --git a/drivers/net/ethernet/xircom/xirc2ps_cs.c b/drivers/net/ethernet/xircom/xirc2ps_cs.c
index 480ab7251515..134dd09d1e51 100644
--- a/drivers/net/ethernet/xircom/xirc2ps_cs.c
+++ b/drivers/net/ethernet/xircom/xirc2ps_cs.c
@@ -1273,7 +1273,7 @@ struct set_address_info {
 	unsigned int ioaddr;
 };
 
-static void set_address(struct set_address_info *sa_info, char *addr)
+static void set_address(struct set_address_info *sa_info, const char *addr)
 {
 	unsigned int ioaddr = sa_info->ioaddr;
 	int i;
diff --git a/drivers/net/phy/mscc.c b/drivers/net/phy/mscc.c
index 972c20ee1bb1..d8ffb7ebb428 100644
--- a/drivers/net/phy/mscc.c
+++ b/drivers/net/phy/mscc.c
@@ -612,12 +612,12 @@ static int vsc85xx_downshift_set(struct phy_device *phydev, u8 count)
 static int vsc85xx_wol_set(struct phy_device *phydev,
 			   struct ethtool_wolinfo *wol)
 {
+	const u8 *mac_addr = phydev->attached_dev->dev_addr;
 	int rc;
 	u16 reg_val;
 	u8  i;
 	u16 pwd[3] = {0, 0, 0};
 	struct ethtool_wolinfo *wol_conf = wol;
-	u8 *mac_addr = phydev->attached_dev->dev_addr;
 
 	mutex_lock(&phydev->lock);
 	rc = phy_select_page(phydev, MSCC_PHY_PAGE_EXTENDED_2);
diff --git a/drivers/net/usb/aqc111.c b/drivers/net/usb/aqc111.c
index 7e44110746dd..09ebb418af81 100644
--- a/drivers/net/usb/aqc111.c
+++ b/drivers/net/usb/aqc111.c
@@ -119,7 +119,7 @@ static int aqc111_write_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,
 }
 
 static int aqc111_write_cmd(struct usbnet *dev, u8 cmd, u16 value,
-			    u16 index, u16 size, void *data)
+			    u16 index, u16 size, const void *data)
 {
 	int ret;
 
diff --git a/drivers/net/usb/ax88179_178a.c b/drivers/net/usb/ax88179_178a.c
index 2eb02808812c..995695d5eac2 100644
--- a/drivers/net/usb/ax88179_178a.c
+++ b/drivers/net/usb/ax88179_178a.c
@@ -221,7 +221,7 @@ static int __ax88179_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
 }
 
 static int __ax88179_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-			       u16 size, void *data, int in_pm)
+			       u16 size, const void *data, int in_pm)
 {
 	int ret;
 	int (*fn)(struct usbnet *, u8, u8, u16, u16, const void *, u16);
@@ -284,7 +284,7 @@ static int ax88179_read_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,
 }
 
 static int ax88179_write_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,
-				  u16 index, u16 size, void *data)
+				  u16 index, u16 size, const void *data)
 {
 	int ret;
 
@@ -325,7 +325,7 @@ static int ax88179_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
 }
 
 static int ax88179_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-			     u16 size, void *data)
+			     u16 size, const void *data)
 {
 	int ret;
 
@@ -475,7 +475,7 @@ static int ax88179_auto_detach(struct usbnet *dev, int in_pm)
 	u16 tmp16;
 	u8 tmp8;
 	int (*fnr)(struct usbnet *, u8, u16, u16, u16, void *);
-	int (*fnw)(struct usbnet *, u8, u16, u16, u16, void *);
+	int (*fnw)(struct usbnet *, u8, u16, u16, u16, const void *);
 
 	if (!in_pm) {
 		fnr = ax88179_read_cmd;
diff --git a/drivers/net/usb/catc.c b/drivers/net/usb/catc.c
index 1bb5a82f05be..3e760369f1e1 100644
--- a/drivers/net/usb/catc.c
+++ b/drivers/net/usb/catc.c
@@ -626,7 +626,7 @@ static void catc_stats_timer(struct timer_list *t)
  * Receive modes. Broadcast, Multicast, Promisc.
  */
 
-static void catc_multicast(unsigned char *addr, u8 *multicast)
+static void catc_multicast(const unsigned char *addr, u8 *multicast)
 {
 	u32 crc;
 
diff --git a/drivers/net/usb/dm9601.c b/drivers/net/usb/dm9601.c
index 915ac75b55fc..355ebd504cd9 100644
--- a/drivers/net/usb/dm9601.c
+++ b/drivers/net/usb/dm9601.c
@@ -93,7 +93,8 @@ static int dm_write_reg(struct usbnet *dev, u8 reg, u8 value)
 				value, reg, NULL, 0);
 }
 
-static void dm_write_async(struct usbnet *dev, u8 reg, u16 length, void *data)
+static void dm_write_async(struct usbnet *dev, u8 reg, u16 length,
+			   const void *data)
 {
 	usbnet_write_cmd_async(dev, DM_WRITE_REGS,
 			       USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
diff --git a/drivers/net/usb/mcs7830.c b/drivers/net/usb/mcs7830.c
index 5a47e5510ca8..3ff8444e3970 100644
--- a/drivers/net/usb/mcs7830.c
+++ b/drivers/net/usb/mcs7830.c
@@ -145,7 +145,8 @@ static int mcs7830_hif_get_mac_address(struct usbnet *dev, unsigned char *addr)
 	return 0;
 }
 
-static int mcs7830_hif_set_mac_address(struct usbnet *dev, unsigned char *addr)
+static int mcs7830_hif_set_mac_address(struct usbnet *dev,
+				       const unsigned char *addr)
 {
 	int ret = mcs7830_set_reg(dev, HIF_REG_ETHERNET_ADDR, ETH_ALEN, addr);
 
diff --git a/drivers/net/usb/sr9700.c b/drivers/net/usb/sr9700.c
index 6ac232e52bf7..e5a6dd3e05b7 100644
--- a/drivers/net/usb/sr9700.c
+++ b/drivers/net/usb/sr9700.c
@@ -56,7 +56,8 @@ static int sr_write_reg(struct usbnet *dev, u8 reg, u8 value)
 				value, reg, NULL, 0);
 }
 
-static void sr_write_async(struct usbnet *dev, u8 reg, u16 length, void *data)
+static void sr_write_async(struct usbnet *dev, u8 reg, u16 length,
+			   const void *data)
 {
 	usbnet_write_cmd_async(dev, SR_WR_REGS, SR_REQ_WR_REG,
 			       0, reg, data, length);
diff --git a/include/linux/qed/qed_eth_if.h b/include/linux/qed/qed_eth_if.h
index 812a4d751163..ed2e521c13fb 100644
--- a/include/linux/qed/qed_eth_if.h
+++ b/include/linux/qed/qed_eth_if.h
@@ -336,7 +336,7 @@ struct qed_eth_ops {
 	int (*configure_arfs_searcher)(struct qed_dev *cdev,
 				       enum qed_filter_config_mode mode);
 	int (*get_coalesce)(struct qed_dev *cdev, u16 *coal, void *handle);
-	int (*req_bulletin_update_mac)(struct qed_dev *cdev, u8 *mac);
+	int (*req_bulletin_update_mac)(struct qed_dev *cdev, const u8 *mac);
 };
 
 const struct qed_eth_ops *qed_get_eth_ops(void);
diff --git a/include/linux/qed/qed_if.h b/include/linux/qed/qed_if.h
index 22d557b1c3f6..894584fd6b4c 100644
--- a/include/linux/qed/qed_if.h
+++ b/include/linux/qed/qed_if.h
@@ -1097,7 +1097,7 @@ struct qed_common_ops {
  * @param mac
  *
  */
-	int (*update_mac)(struct qed_dev *cdev, u8 *mac);
+	int (*update_mac)(struct qed_dev *cdev, const u8 *mac);
 
 /**
  * @brief update_mtu - API to inform the change in the mtu
diff --git a/include/linux/qed/qed_rdma_if.h b/include/linux/qed/qed_rdma_if.h
index aeb242cefebf..3b76c07fbcf8 100644
--- a/include/linux/qed/qed_rdma_if.h
+++ b/include/linux/qed/qed_rdma_if.h
@@ -662,7 +662,8 @@ struct qed_rdma_ops {
 			     u8 connection_handle,
 			     struct qed_ll2_stats *p_stats);
 	int (*ll2_set_mac_filter)(struct qed_dev *cdev,
-				  u8 *old_mac_address, u8 *new_mac_address);
+				  u8 *old_mac_address,
+				  const u8 *new_mac_address);
 
 	int (*iwarp_set_engine_affin)(struct qed_dev *cdev, bool b_reset);
 
