net: bridge: multicast: __grp_src_block_incl can modify pg

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 0ad57c99e857f4c7354c3629d4168061fba4a22a
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/0ad57c99.failed

Prepare __grp_src_block_incl() for being able to cause a notification
due to changes. Currently it cannot happen, but EHT would change that
since we'll be deleting sources immediately. Make sure that if the pg is
deleted we don't return true as that would cause the caller to access
freed pg. This patch shouldn't cause any functional change.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 0ad57c99e857f4c7354c3629d4168061fba4a22a)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_multicast.c
diff --cc net/bridge/br_multicast.c
index 6cf87c6c3626,79569a398669..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -1729,8 -2142,8 +1729,13 @@@ static bool br_multicast_toex(struct ne
  /* State          Msg type      New state                Actions
   * INCLUDE (A)    BLOCK (B)     INCLUDE (A)              Send Q(G,A*B)
   */
++<<<<<<< HEAD
 +static void __grp_src_block_incl(struct net_bridge_port_group *pg,
 +				 void *srcs, u32 nsrcs, size_t src_size)
++=======
+ static bool __grp_src_block_incl(struct net_bridge_port_group *pg, void *h_addr,
+ 				 void *srcs, u32 nsrcs, size_t addr_size)
++>>>>>>> 0ad57c99e857 (net: bridge: multicast: __grp_src_block_incl can modify pg)
  {
  	struct net_bridge_group_src *ent;
  	u32 src_idx, to_send = 0;
@@@ -1754,8 -2168,15 +1760,20 @@@
  	if (to_send)
  		__grp_src_query_marked_and_rexmit(pg);
  
++<<<<<<< HEAD
 +	if (pg->filter_mode == MCAST_INCLUDE && hlist_empty(&pg->src_list))
 +		br_multicast_find_del_pg(pg->port->br, pg);
++=======
+ 	if (pg->filter_mode == MCAST_INCLUDE && hlist_empty(&pg->src_list)) {
+ 		br_multicast_find_del_pg(pg->key.port->br, pg);
+ 		/* a notification has already been sent and we shouldn't access
+ 		 * pg after the delete thus we have to return false
+ 		 */
+ 		changed = false;
+ 	}
+ 
+ 	return changed;
++>>>>>>> 0ad57c99e857 (net: bridge: multicast: __grp_src_block_incl can modify pg)
  }
  
  /* State          Msg type      New state                Actions
@@@ -1805,10 -2226,10 +1823,14 @@@ static bool br_multicast_block(struct n
  
  	switch (pg->filter_mode) {
  	case MCAST_INCLUDE:
++<<<<<<< HEAD
 +		__grp_src_block_incl(pg, srcs, nsrcs, src_size);
++=======
+ 		changed = __grp_src_block_incl(pg, h_addr, srcs, nsrcs, addr_size);
++>>>>>>> 0ad57c99e857 (net: bridge: multicast: __grp_src_block_incl can modify pg)
  		break;
  	case MCAST_EXCLUDE:
 -		changed = __grp_src_block_excl(pg, h_addr, srcs, nsrcs, addr_size);
 +		changed = __grp_src_block_excl(pg, srcs, nsrcs, src_size);
  		break;
  	}
  
* Unmerged path net/bridge/br_multicast.c
