net: bridge: mcast: handle port group filter modes

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 8266a0491e92d39dc9af739e8380a0daa9b8836b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/8266a049.failed

We need to handle group filter mode transitions and initial state.
To change a port group's INCLUDE -> EXCLUDE mode (or when we have added
a new port group in EXCLUDE mode) we need to add that port to all of
*,G ports' S,G entries for proper replication. When the EXCLUDE state is
changed from IGMPv3 report, br_multicast_fwd_filter_exclude() must be
called after the source list processing because the assumption is that
all of the group's S,G entries will be created before transitioning to
EXCLUDE mode, i.e. most importantly its blocked entries will already be
added so it will not get automatically added to them.
The transition EXCLUDE -> INCLUDE happens only when a port group timer
expires, it requires us to remove that port from all of *,G ports' S,G
entries where it was automatically added previously.
Finally when we are adding a new S,G entry we must add all of *,G's
EXCLUDE ports to it.
In order to distinguish automatically added *,G EXCLUDE ports we have a
new port group flag - MDB_PG_FLAGS_STAR_EXCL.

	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 8266a0491e92d39dc9af739e8380a0daa9b8836b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_mdb.c
#	net/bridge/br_multicast.c
#	net/bridge/br_private.h
diff --cc net/bridge/br_mdb.c
index 40754c5e5bdc,28cd35a9cf37..000000000000
--- a/net/bridge/br_mdb.c
+++ b/net/bridge/br_mdb.c
@@@ -62,9 -62,12 +62,11 @@@ static void __mdb_entry_fill_flags(stru
  		e->flags |= MDB_FLAGS_OFFLOAD;
  	if (flags & MDB_PG_FLAGS_FAST_LEAVE)
  		e->flags |= MDB_FLAGS_FAST_LEAVE;
+ 	if (flags & MDB_PG_FLAGS_STAR_EXCL)
+ 		e->flags |= MDB_FLAGS_STAR_EXCL;
  }
  
 -static void __mdb_entry_to_br_ip(struct br_mdb_entry *entry, struct br_ip *ip,
 -				 struct nlattr **mdb_attrs)
 +static void __mdb_entry_to_br_ip(struct br_mdb_entry *entry, struct br_ip *ip)
  {
  	memset(ip, 0, sizeof(struct br_ip));
  	ip->vid = entry->vid;
@@@ -737,18 -820,36 +739,23 @@@ static int br_mdb_parse(struct sk_buff 
  }
  
  static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
 -			    struct br_mdb_entry *entry,
 -			    struct nlattr **mdb_attrs,
 +			    struct br_ip *group, struct br_mdb_entry *entry,
  			    struct netlink_ext_ack *extack)
  {
- 	struct net_bridge_mdb_entry *mp;
+ 	struct net_bridge_mdb_entry *mp, *star_mp;
  	struct net_bridge_port_group *p;
  	struct net_bridge_port_group __rcu **pp;
+ 	struct br_ip group, star_group;
  	unsigned long now = jiffies;
++<<<<<<< HEAD
++=======
+ 	u8 filter_mode;
++>>>>>>> 8266a0491e92 (net: bridge: mcast: handle port group filter modes)
  	int err;
  
 -	__mdb_entry_to_br_ip(entry, &group, mdb_attrs);
 -
 -	/* host join errors which can happen before creating the group */
 -	if (!port) {
 -		/* don't allow any flags for host-joined groups */
 -		if (entry->state) {
 -			NL_SET_ERR_MSG_MOD(extack, "Flags are not allowed for host groups");
 -			return -EINVAL;
 -		}
 -		if (!br_multicast_is_star_g(&group)) {
 -			NL_SET_ERR_MSG_MOD(extack, "Groups with sources cannot be manually host joined");
 -			return -EINVAL;
 -		}
 -	}
 -
 -	mp = br_mdb_ip_get(br, &group);
 +	mp = br_mdb_ip_get(br, group);
  	if (!mp) {
 -		mp = br_multicast_new_group(br, &group);
 +		mp = br_multicast_new_group(br, group);
  		err = PTR_ERR_OR_ZERO(mp);
  		if (err)
  			return err;
diff --cc net/bridge/br_multicast.c
index 28b757a17768,f39bbd733722..000000000000
--- a/net/bridge/br_multicast.c
+++ b/net/bridge/br_multicast.c
@@@ -65,6 -66,25 +65,28 @@@ static void br_ip6_multicast_leave_grou
  					 const struct in6_addr *group,
  					 __u16 vid, const unsigned char *src);
  #endif
++<<<<<<< HEAD
++=======
+ static struct net_bridge_port_group *
+ __br_multicast_add_group(struct net_bridge *br,
+ 			 struct net_bridge_port *port,
+ 			 struct br_ip *group,
+ 			 const unsigned char *src,
+ 			 u8 filter_mode,
+ 			 bool igmpv2_mldv1);
+ static void br_multicast_find_del_pg(struct net_bridge *br,
+ 				     struct net_bridge_port_group *pg);
+ 
+ static struct net_bridge_port_group *
+ br_sg_port_find(struct net_bridge *br,
+ 		struct net_bridge_port_group_sg_key *sg_p)
+ {
+ 	lockdep_assert_held_once(&br->multicast_lock);
+ 
+ 	return rhashtable_lookup_fast(&br->sg_port_tbl, sg_p,
+ 				      br_sg_port_rht_params);
+ }
++>>>>>>> 8266a0491e92 (net: bridge: mcast: handle port group filter modes)
  
  static struct net_bridge_mdb_entry *br_mdb_ip_get_rcu(struct net_bridge *br,
  						      struct br_ip *dst)
@@@ -146,6 -184,242 +168,245 @@@ struct net_bridge_mdb_entry *br_mdb_get
  	return br_mdb_ip_get_rcu(br, &ip);
  }
  
++<<<<<<< HEAD
++=======
+ static bool br_port_group_equal(struct net_bridge_port_group *p,
+ 				struct net_bridge_port *port,
+ 				const unsigned char *src)
+ {
+ 	if (p->key.port != port)
+ 		return false;
+ 
+ 	if (!(port->flags & BR_MULTICAST_TO_UNICAST))
+ 		return true;
+ 
+ 	return ether_addr_equal(src, p->eth_addr);
+ }
+ 
+ static void __fwd_add_star_excl(struct net_bridge_port_group *pg,
+ 				struct br_ip *sg_ip)
+ {
+ 	struct net_bridge_port_group_sg_key sg_key;
+ 	struct net_bridge *br = pg->key.port->br;
+ 	struct net_bridge_port_group *src_pg;
+ 
+ 	memset(&sg_key, 0, sizeof(sg_key));
+ 	sg_key.port = pg->key.port;
+ 	sg_key.addr = *sg_ip;
+ 	if (br_sg_port_find(br, &sg_key))
+ 		return;
+ 
+ 	src_pg = __br_multicast_add_group(br, pg->key.port, sg_ip, pg->eth_addr,
+ 					  MCAST_INCLUDE, false);
+ 	if (IS_ERR_OR_NULL(src_pg) ||
+ 	    src_pg->rt_protocol != RTPROT_KERNEL)
+ 		return;
+ 
+ 	src_pg->flags |= MDB_PG_FLAGS_STAR_EXCL;
+ }
+ 
+ static void __fwd_del_star_excl(struct net_bridge_port_group *pg,
+ 				struct br_ip *sg_ip)
+ {
+ 	struct net_bridge_port_group_sg_key sg_key;
+ 	struct net_bridge *br = pg->key.port->br;
+ 	struct net_bridge_port_group *src_pg;
+ 
+ 	memset(&sg_key, 0, sizeof(sg_key));
+ 	sg_key.port = pg->key.port;
+ 	sg_key.addr = *sg_ip;
+ 	src_pg = br_sg_port_find(br, &sg_key);
+ 	if (!src_pg || !(src_pg->flags & MDB_PG_FLAGS_STAR_EXCL) ||
+ 	    src_pg->rt_protocol != RTPROT_KERNEL)
+ 		return;
+ 
+ 	br_multicast_find_del_pg(br, src_pg);
+ }
+ 
+ /* When a port group transitions to (or is added as) EXCLUDE we need to add it
+  * to all other ports' S,G entries which are not blocked by the current group
+  * for proper replication, the assumption is that any S,G blocked entries
+  * are already added so the S,G,port lookup should skip them.
+  * When a port group transitions from EXCLUDE -> INCLUDE mode or is being
+  * deleted we need to remove it from all ports' S,G entries where it was
+  * automatically installed before (i.e. where it's MDB_PG_FLAGS_STAR_EXCL).
+  */
+ void br_multicast_star_g_handle_mode(struct net_bridge_port_group *pg,
+ 				     u8 filter_mode)
+ {
+ 	struct net_bridge *br = pg->key.port->br;
+ 	struct net_bridge_port_group *pg_lst;
+ 	struct net_bridge_mdb_entry *mp;
+ 	struct br_ip sg_ip;
+ 
+ 	if (WARN_ON(!br_multicast_is_star_g(&pg->key.addr)))
+ 		return;
+ 
+ 	mp = br_mdb_ip_get(br, &pg->key.addr);
+ 	if (!mp)
+ 		return;
+ 
+ 	memset(&sg_ip, 0, sizeof(sg_ip));
+ 	sg_ip = pg->key.addr;
+ 	for (pg_lst = mlock_dereference(mp->ports, br);
+ 	     pg_lst;
+ 	     pg_lst = mlock_dereference(pg_lst->next, br)) {
+ 		struct net_bridge_group_src *src_ent;
+ 
+ 		if (pg_lst == pg)
+ 			continue;
+ 		hlist_for_each_entry(src_ent, &pg_lst->src_list, node) {
+ 			if (!(src_ent->flags & BR_SGRP_F_INSTALLED))
+ 				continue;
+ 			sg_ip.src = src_ent->addr.src;
+ 			switch (filter_mode) {
+ 			case MCAST_INCLUDE:
+ 				__fwd_del_star_excl(pg, &sg_ip);
+ 				break;
+ 			case MCAST_EXCLUDE:
+ 				__fwd_add_star_excl(pg, &sg_ip);
+ 				break;
+ 			}
+ 		}
+ 	}
+ }
+ 
+ static void br_multicast_sg_del_exclude_ports(struct net_bridge_mdb_entry *sgmp)
+ {
+ 	struct net_bridge_port_group __rcu **pp;
+ 	struct net_bridge_port_group *p;
+ 
+ 	/* *,G exclude ports are only added to S,G entries */
+ 	if (WARN_ON(br_multicast_is_star_g(&sgmp->addr)))
+ 		return;
+ 
+ 	/* we need the STAR_EXCLUDE ports if there are non-STAR_EXCLUDE ports
+ 	 * we should ignore perm entries since they're managed by user-space
+ 	 */
+ 	for (pp = &sgmp->ports;
+ 	     (p = mlock_dereference(*pp, sgmp->br)) != NULL;
+ 	     pp = &p->next)
+ 		if (!(p->flags & (MDB_PG_FLAGS_STAR_EXCL |
+ 				  MDB_PG_FLAGS_PERMANENT)))
+ 			return;
+ 
+ 	for (pp = &sgmp->ports;
+ 	     (p = mlock_dereference(*pp, sgmp->br)) != NULL;) {
+ 		if (!(p->flags & MDB_PG_FLAGS_PERMANENT))
+ 			br_multicast_del_pg(sgmp, p, pp);
+ 		else
+ 			pp = &p->next;
+ 	}
+ }
+ 
+ void br_multicast_sg_add_exclude_ports(struct net_bridge_mdb_entry *star_mp,
+ 				       struct net_bridge_port_group *sg)
+ {
+ 	struct net_bridge_port_group_sg_key sg_key;
+ 	struct net_bridge *br = star_mp->br;
+ 	struct net_bridge_port_group *pg;
+ 
+ 	if (WARN_ON(br_multicast_is_star_g(&sg->key.addr)))
+ 		return;
+ 	if (WARN_ON(!br_multicast_is_star_g(&star_mp->addr)))
+ 		return;
+ 
+ 	memset(&sg_key, 0, sizeof(sg_key));
+ 	sg_key.addr = sg->key.addr;
+ 	/* we need to add all exclude ports to the S,G */
+ 	for (pg = mlock_dereference(star_mp->ports, br);
+ 	     pg;
+ 	     pg = mlock_dereference(pg->next, br)) {
+ 		struct net_bridge_port_group *src_pg;
+ 
+ 		if (pg == sg || pg->filter_mode == MCAST_INCLUDE)
+ 			continue;
+ 
+ 		sg_key.port = pg->key.port;
+ 		if (br_sg_port_find(br, &sg_key))
+ 			continue;
+ 
+ 		src_pg = __br_multicast_add_group(br, pg->key.port,
+ 						  &sg->key.addr,
+ 						  sg->eth_addr,
+ 						  MCAST_INCLUDE, false);
+ 		if (IS_ERR_OR_NULL(src_pg) ||
+ 		    src_pg->rt_protocol != RTPROT_KERNEL)
+ 			continue;
+ 		src_pg->flags |= MDB_PG_FLAGS_STAR_EXCL;
+ 	}
+ }
+ 
+ static void br_multicast_fwd_src_add(struct net_bridge_group_src *src)
+ {
+ 	struct net_bridge_mdb_entry *star_mp;
+ 	struct net_bridge_port_group *sg;
+ 	struct br_ip sg_ip;
+ 
+ 	if (src->flags & BR_SGRP_F_INSTALLED)
+ 		return;
+ 
+ 	memset(&sg_ip, 0, sizeof(sg_ip));
+ 	sg_ip = src->pg->key.addr;
+ 	sg_ip.src = src->addr.src;
+ 	sg = __br_multicast_add_group(src->br, src->pg->key.port, &sg_ip,
+ 				      src->pg->eth_addr, MCAST_INCLUDE, false);
+ 	if (IS_ERR_OR_NULL(sg))
+ 		return;
+ 	src->flags |= BR_SGRP_F_INSTALLED;
+ 	sg->flags &= ~MDB_PG_FLAGS_STAR_EXCL;
+ 
+ 	/* if it was added by user-space as perm we can skip next steps */
+ 	if (sg->rt_protocol != RTPROT_KERNEL &&
+ 	    (sg->flags & MDB_PG_FLAGS_PERMANENT))
+ 		return;
+ 
+ 	/* the kernel is now responsible for removing this S,G */
+ 	del_timer(&sg->timer);
+ 	star_mp = br_mdb_ip_get(src->br, &src->pg->key.addr);
+ 	if (!star_mp)
+ 		return;
+ 
+ 	br_multicast_sg_add_exclude_ports(star_mp, sg);
+ }
+ 
+ static void br_multicast_fwd_src_remove(struct net_bridge_group_src *src)
+ {
+ 	struct net_bridge_port_group *p, *pg = src->pg;
+ 	struct net_bridge_port_group __rcu **pp;
+ 	struct net_bridge_mdb_entry *mp;
+ 	struct br_ip sg_ip;
+ 
+ 	memset(&sg_ip, 0, sizeof(sg_ip));
+ 	sg_ip = pg->key.addr;
+ 	sg_ip.src = src->addr.src;
+ 
+ 	mp = br_mdb_ip_get(src->br, &sg_ip);
+ 	if (!mp)
+ 		return;
+ 
+ 	for (pp = &mp->ports;
+ 	     (p = mlock_dereference(*pp, src->br)) != NULL;
+ 	     pp = &p->next) {
+ 		if (!br_port_group_equal(p, pg->key.port, pg->eth_addr))
+ 			continue;
+ 
+ 		if (p->rt_protocol != RTPROT_KERNEL &&
+ 		    (p->flags & MDB_PG_FLAGS_PERMANENT))
+ 			break;
+ 
+ 		br_multicast_del_pg(mp, p, pp);
+ 		break;
+ 	}
+ 	src->flags &= ~BR_SGRP_F_INSTALLED;
+ }
+ 
+ static void br_multicast_fwd_src_handle(struct net_bridge_group_src *src)
+ {
+ 	br_multicast_fwd_src_add(src);
+ }
+ 
++>>>>>>> 8266a0491e92 (net: bridge: mcast: handle port group filter modes)
  static void br_multicast_destroy_mdb_entry(struct net_bridge_mcast_gc *gc)
  {
  	struct net_bridge_mdb_entry *mp;
@@@ -290,8 -572,11 +555,11 @@@ static void br_multicast_port_group_exp
  	if (hlist_empty(&pg->src_list)) {
  		br_multicast_find_del_pg(br, pg);
  	} else if (changed) {
 -		struct net_bridge_mdb_entry *mp = br_mdb_ip_get(br, &pg->key.addr);
 +		struct net_bridge_mdb_entry *mp = br_mdb_ip_get(br, &pg->addr);
  
+ 		if (changed && br_multicast_is_star_g(&pg->key.addr))
+ 			br_multicast_star_g_handle_mode(pg, MCAST_INCLUDE);
+ 
  		if (WARN_ON(!mp))
  			goto out;
  		br_mdb_notify(br->dev, mp, pg, RTM_NEWMDB);
diff --cc net/bridge/br_private.h
index 26b3cc8b3453,128d2d0417a0..000000000000
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@@ -804,6 -886,35 +809,38 @@@ static inline bool br_multicast_querier
  	}
  }
  
++<<<<<<< HEAD
++=======
+ static inline bool br_multicast_is_star_g(const struct br_ip *ip)
+ {
+ 	switch (ip->proto) {
+ 	case htons(ETH_P_IP):
+ 		return ipv4_is_zeronet(ip->src.ip4);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case htons(ETH_P_IPV6):
+ 		return ipv6_addr_any(&ip->src.ip6);
+ #endif
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
+ static inline bool br_multicast_should_handle_mode(const struct net_bridge *br,
+ 						   __be16 proto)
+ {
+ 	switch (proto) {
+ 	case htons(ETH_P_IP):
+ 		return !!(br->multicast_igmp_version == 3);
+ #if IS_ENABLED(CONFIG_IPV6)
+ 	case htons(ETH_P_IPV6):
+ 		return !!(br->multicast_mld_version == 2);
+ #endif
+ 	default:
+ 		return false;
+ 	}
+ }
+ 
++>>>>>>> 8266a0491e92 (net: bridge: mcast: handle port group filter modes)
  static inline int br_multicast_igmp_type(const struct sk_buff *skb)
  {
  	return BR_INPUT_SKB_CB(skb)->igmp;
diff --git a/include/uapi/linux/if_bridge.h b/include/uapi/linux/if_bridge.h
index c424bb8708cd..f8c67c674b7d 100644
--- a/include/uapi/linux/if_bridge.h
+++ b/include/uapi/linux/if_bridge.h
@@ -459,6 +459,7 @@ struct br_mdb_entry {
 	__u8 state;
 #define MDB_FLAGS_OFFLOAD	(1 << 0)
 #define MDB_FLAGS_FAST_LEAVE	(1 << 1)
+#define MDB_FLAGS_STAR_EXCL	(1 << 2)
 	__u8 flags;
 	__u16 vid;
 	struct {
* Unmerged path net/bridge/br_mdb.c
* Unmerged path net/bridge/br_multicast.c
* Unmerged path net/bridge/br_private.h
