Bluetooth: Allow Microsoft extension to indicate curve validation

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Marcel Holtmann <marcel@holtmann.org>
commit a61d67188f29ff678e94fb3ffba6c6d292e852c7
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/a61d6718.failed

Some controllers don't support the Simple Pairing Options feature that
can indicate the support for P-192 and P-256 public key validation.
However they might support the Microsoft vendor extension that can
indicate the validiation capability as well.

	Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
	Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
(cherry picked from commit a61d67188f29ff678e94fb3ffba6c6d292e852c7)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bluetooth/mgmt.c
#	net/bluetooth/msft.c
#	net/bluetooth/msft.h
diff --cc net/bluetooth/mgmt.c
index 838b33fb3b28,f9be7f9084d6..000000000000
--- a/net/bluetooth/mgmt.c
+++ b/net/bluetooth/mgmt.c
@@@ -3632,122 -3713,540 +3632,517 @@@ unlock
  	return err;
  }
  
++<<<<<<< HEAD
 +static int set_blocked_keys(struct sock *sk, struct hci_dev *hdev, void *data,
++=======
+ static int read_controller_cap(struct sock *sk, struct hci_dev *hdev,
+ 			       void *data, u16 data_len)
+ {
+ 	char buf[20];
+ 	struct mgmt_rp_read_controller_cap *rp = (void *)buf;
+ 	u16 cap_len = 0;
+ 	u8 flags = 0;
+ 	u8 tx_power_range[2];
+ 
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	memset(&buf, 0, sizeof(buf));
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	/* When the Read Simple Pairing Options command is supported, then
+ 	 * the remote public key validation is supported.
+ 	 *
+ 	 * Alternatively, when Microsoft extensions are available, they can
+ 	 * indicate support for public key validation as well.
+ 	 */
+ 	if ((hdev->commands[41] & 0x08) || msft_curve_validity(hdev))
+ 		flags |= 0x01;	/* Remote public key validation (BR/EDR) */
+ 
+ 	flags |= 0x02;		/* Remote public key validation (LE) */
+ 
+ 	/* When the Read Encryption Key Size command is supported, then the
+ 	 * encryption key size is enforced.
+ 	 */
+ 	if (hdev->commands[20] & 0x10)
+ 		flags |= 0x04;	/* Encryption key size enforcement (BR/EDR) */
+ 
+ 	flags |= 0x08;		/* Encryption key size enforcement (LE) */
+ 
+ 	cap_len = eir_append_data(rp->cap, cap_len, MGMT_CAP_SEC_FLAGS,
+ 				  &flags, 1);
+ 
+ 	/* When the Read Simple Pairing Options command is supported, then
+ 	 * also max encryption key size information is provided.
+ 	 */
+ 	if (hdev->commands[41] & 0x08)
+ 		cap_len = eir_append_le16(rp->cap, cap_len,
+ 					  MGMT_CAP_MAX_ENC_KEY_SIZE,
+ 					  hdev->max_enc_key_size);
+ 
+ 	cap_len = eir_append_le16(rp->cap, cap_len,
+ 				  MGMT_CAP_SMP_MAX_ENC_KEY_SIZE,
+ 				  SMP_MAX_ENC_KEY_SIZE);
+ 
+ 	/* Append the min/max LE tx power parameters if we were able to fetch
+ 	 * it from the controller
+ 	 */
+ 	if (hdev->commands[38] & 0x80) {
+ 		memcpy(&tx_power_range[0], &hdev->min_le_tx_power, 1);
+ 		memcpy(&tx_power_range[1], &hdev->max_le_tx_power, 1);
+ 		cap_len = eir_append_data(rp->cap, cap_len, MGMT_CAP_LE_TX_PWR,
+ 					  tx_power_range, 2);
+ 	}
+ 
+ 	rp->cap_len = cpu_to_le16(cap_len);
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_READ_CONTROLLER_CAP, 0,
+ 				 rp, sizeof(*rp) + cap_len);
+ }
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ /* d4992530-b9ec-469f-ab01-6c481c47da1c */
+ static const u8 debug_uuid[16] = {
+ 	0x1c, 0xda, 0x47, 0x1c, 0x48, 0x6c, 0x01, 0xab,
+ 	0x9f, 0x46, 0xec, 0xb9, 0x30, 0x25, 0x99, 0xd4,
+ };
+ #endif
+ 
+ /* 671b10b5-42c0-4696-9227-eb28d1b049d6 */
+ static const u8 simult_central_periph_uuid[16] = {
+ 	0xd6, 0x49, 0xb0, 0xd1, 0x28, 0xeb, 0x27, 0x92,
+ 	0x96, 0x46, 0xc0, 0x42, 0xb5, 0x10, 0x1b, 0x67,
+ };
+ 
+ /* 15c0a148-c273-11ea-b3de-0242ac130004 */
+ static const u8 rpa_resolution_uuid[16] = {
+ 	0x04, 0x00, 0x13, 0xac, 0x42, 0x02, 0xde, 0xb3,
+ 	0xea, 0x11, 0x73, 0xc2, 0x48, 0xa1, 0xc0, 0x15,
+ };
+ 
+ static int read_exp_features_info(struct sock *sk, struct hci_dev *hdev,
+ 				  void *data, u16 data_len)
+ {
+ 	char buf[62];	/* Enough space for 3 features */
+ 	struct mgmt_rp_read_exp_features_info *rp = (void *)buf;
+ 	u16 idx = 0;
+ 	u32 flags;
+ 
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	memset(&buf, 0, sizeof(buf));
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ 	if (!hdev) {
+ 		flags = bt_dbg_get() ? BIT(0) : 0;
+ 
+ 		memcpy(rp->features[idx].uuid, debug_uuid, 16);
+ 		rp->features[idx].flags = cpu_to_le32(flags);
+ 		idx++;
+ 	}
+ #endif
+ 
+ 	if (hdev) {
+ 		if (test_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks) &&
+ 		    (hdev->le_states[4] & 0x08) &&	/* Central */
+ 		    (hdev->le_states[4] & 0x40) &&	/* Peripheral */
+ 		    (hdev->le_states[3] & 0x10))	/* Simultaneous */
+ 			flags = BIT(0);
+ 		else
+ 			flags = 0;
+ 
+ 		memcpy(rp->features[idx].uuid, simult_central_periph_uuid, 16);
+ 		rp->features[idx].flags = cpu_to_le32(flags);
+ 		idx++;
+ 	}
+ 
+ 	if (hdev && use_ll_privacy(hdev)) {
+ 		if (hci_dev_test_flag(hdev, HCI_ENABLE_LL_PRIVACY))
+ 			flags = BIT(0) | BIT(1);
+ 		else
+ 			flags = BIT(1);
+ 
+ 		memcpy(rp->features[idx].uuid, rpa_resolution_uuid, 16);
+ 		rp->features[idx].flags = cpu_to_le32(flags);
+ 		idx++;
+ 	}
+ 
+ 	rp->feature_count = cpu_to_le16(idx);
+ 
+ 	/* After reading the experimental features information, enable
+ 	 * the events to update client on any future change.
+ 	 */
+ 	hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 	return mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
+ 				 MGMT_OP_READ_EXP_FEATURES_INFO,
+ 				 0, rp, sizeof(*rp) + (20 * idx));
+ }
+ 
+ static int exp_ll_privacy_feature_changed(bool enabled, struct hci_dev *hdev,
+ 					  struct sock *skip)
+ {
+ 	struct mgmt_ev_exp_feature_changed ev;
+ 
+ 	memset(&ev, 0, sizeof(ev));
+ 	memcpy(ev.uuid, rpa_resolution_uuid, 16);
+ 	ev.flags = cpu_to_le32((enabled ? BIT(0) : 0) | BIT(1));
+ 
+ 	return mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, hdev,
+ 				  &ev, sizeof(ev),
+ 				  HCI_MGMT_EXP_FEATURE_EVENTS, skip);
+ 
+ }
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ static int exp_debug_feature_changed(bool enabled, struct sock *skip)
+ {
+ 	struct mgmt_ev_exp_feature_changed ev;
+ 
+ 	memset(&ev, 0, sizeof(ev));
+ 	memcpy(ev.uuid, debug_uuid, 16);
+ 	ev.flags = cpu_to_le32(enabled ? BIT(0) : 0);
+ 
+ 	return mgmt_limited_event(MGMT_EV_EXP_FEATURE_CHANGED, NULL,
+ 				  &ev, sizeof(ev),
+ 				  HCI_MGMT_EXP_FEATURE_EVENTS, skip);
+ }
+ #endif
+ 
+ static int set_exp_feature(struct sock *sk, struct hci_dev *hdev,
+ 			   void *data, u16 data_len)
+ {
+ 	struct mgmt_cp_set_exp_feature *cp = data;
+ 	struct mgmt_rp_set_exp_feature rp;
+ 
+ 	bt_dev_dbg(hdev, "sock %p", sk);
+ 
+ 	if (!memcmp(cp->uuid, ZERO_KEY, 16)) {
+ 		memset(rp.uuid, 0, 16);
+ 		rp.flags = cpu_to_le32(0);
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ 		if (!hdev) {
+ 			bool changed = bt_dbg_get();
+ 
+ 			bt_dbg_set(false);
+ 
+ 			if (changed)
+ 				exp_debug_feature_changed(false, sk);
+ 		}
+ #endif
+ 
+ 		if (hdev && use_ll_privacy(hdev) && !hdev_is_powered(hdev)) {
+ 			bool changed = hci_dev_test_flag(hdev,
+ 							 HCI_ENABLE_LL_PRIVACY);
+ 
+ 			hci_dev_clear_flag(hdev, HCI_ENABLE_LL_PRIVACY);
+ 
+ 			if (changed)
+ 				exp_ll_privacy_feature_changed(false, hdev, sk);
+ 		}
+ 
+ 		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 		return mgmt_cmd_complete(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
+ 					 MGMT_OP_SET_EXP_FEATURE, 0,
+ 					 &rp, sizeof(rp));
+ 	}
+ 
+ #ifdef CONFIG_BT_FEATURE_DEBUG
+ 	if (!memcmp(cp->uuid, debug_uuid, 16)) {
+ 		bool val, changed;
+ 		int err;
+ 
+ 		/* Command requires to use the non-controller index */
+ 		if (hdev)
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_INDEX);
+ 
+ 		/* Parameters are limited to a single octet */
+ 		if (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)
+ 			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		/* Only boolean on/off is supported */
+ 		if (cp->param[0] != 0x00 && cp->param[0] != 0x01)
+ 			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		val = !!cp->param[0];
+ 		changed = val ? !bt_dbg_get() : bt_dbg_get();
+ 		bt_dbg_set(val);
+ 
+ 		memcpy(rp.uuid, debug_uuid, 16);
+ 		rp.flags = cpu_to_le32(val ? BIT(0) : 0);
+ 
+ 		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 		err = mgmt_cmd_complete(sk, MGMT_INDEX_NONE,
+ 					MGMT_OP_SET_EXP_FEATURE, 0,
+ 					&rp, sizeof(rp));
+ 
+ 		if (changed)
+ 			exp_debug_feature_changed(val, sk);
+ 
+ 		return err;
+ 	}
+ #endif
+ 
+ 	if (!memcmp(cp->uuid, rpa_resolution_uuid, 16)) {
+ 		bool val, changed;
+ 		int err;
+ 		u32 flags;
+ 
+ 		/* Command requires to use the controller index */
+ 		if (!hdev)
+ 			return mgmt_cmd_status(sk, MGMT_INDEX_NONE,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_INDEX);
+ 
+ 		/* Changes can only be made when controller is powered down */
+ 		if (hdev_is_powered(hdev))
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_REJECTED);
+ 
+ 		/* Parameters are limited to a single octet */
+ 		if (data_len != MGMT_SET_EXP_FEATURE_SIZE + 1)
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		/* Only boolean on/off is supported */
+ 		if (cp->param[0] != 0x00 && cp->param[0] != 0x01)
+ 			return mgmt_cmd_status(sk, hdev->id,
+ 					       MGMT_OP_SET_EXP_FEATURE,
+ 					       MGMT_STATUS_INVALID_PARAMS);
+ 
+ 		val = !!cp->param[0];
+ 
+ 		if (val) {
+ 			changed = !hci_dev_test_flag(hdev,
+ 						     HCI_ENABLE_LL_PRIVACY);
+ 			hci_dev_set_flag(hdev, HCI_ENABLE_LL_PRIVACY);
+ 			hci_dev_clear_flag(hdev, HCI_ADVERTISING);
+ 
+ 			/* Enable LL privacy + supported settings changed */
+ 			flags = BIT(0) | BIT(1);
+ 		} else {
+ 			changed = hci_dev_test_flag(hdev,
+ 						    HCI_ENABLE_LL_PRIVACY);
+ 			hci_dev_clear_flag(hdev, HCI_ENABLE_LL_PRIVACY);
+ 
+ 			/* Disable LL privacy + supported settings changed */
+ 			flags = BIT(1);
+ 		}
+ 
+ 		memcpy(rp.uuid, rpa_resolution_uuid, 16);
+ 		rp.flags = cpu_to_le32(flags);
+ 
+ 		hci_sock_set_flag(sk, HCI_MGMT_EXP_FEATURE_EVENTS);
+ 
+ 		err = mgmt_cmd_complete(sk, hdev->id,
+ 					MGMT_OP_SET_EXP_FEATURE, 0,
+ 					&rp, sizeof(rp));
+ 
+ 		if (changed)
+ 			exp_ll_privacy_feature_changed(val, hdev, sk);
+ 
+ 		return err;
+ 	}
+ 
+ 	return mgmt_cmd_status(sk, hdev ? hdev->id : MGMT_INDEX_NONE,
+ 			       MGMT_OP_SET_EXP_FEATURE,
+ 			       MGMT_STATUS_NOT_SUPPORTED);
+ }
+ 
+ #define SUPPORTED_DEVICE_FLAGS() ((1U << HCI_CONN_FLAG_MAX) - 1)
+ 
+ static int get_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
+ 			    u16 data_len)
+ {
+ 	struct mgmt_cp_get_device_flags *cp = data;
+ 	struct mgmt_rp_get_device_flags rp;
+ 	struct bdaddr_list_with_flags *br_params;
+ 	struct hci_conn_params *params;
+ 	u32 supported_flags = SUPPORTED_DEVICE_FLAGS();
+ 	u32 current_flags = 0;
+ 	u8 status = MGMT_STATUS_INVALID_PARAMS;
+ 
+ 	bt_dev_dbg(hdev, "Get device flags %pMR (type 0x%x)\n",
+ 		   &cp->addr.bdaddr, cp->addr.type);
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	if (cp->addr.type == BDADDR_BREDR) {
+ 		br_params = hci_bdaddr_list_lookup_with_flags(&hdev->whitelist,
+ 							      &cp->addr.bdaddr,
+ 							      cp->addr.type);
+ 		if (!br_params)
+ 			goto done;
+ 
+ 		current_flags = br_params->current_flags;
+ 	} else {
+ 		params = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,
+ 						le_addr_type(cp->addr.type));
+ 
+ 		if (!params)
+ 			goto done;
+ 
+ 		current_flags = params->current_flags;
+ 	}
+ 
+ 	bacpy(&rp.addr.bdaddr, &cp->addr.bdaddr);
+ 	rp.addr.type = cp->addr.type;
+ 	rp.supported_flags = cpu_to_le32(supported_flags);
+ 	rp.current_flags = cpu_to_le32(current_flags);
+ 
+ 	status = MGMT_STATUS_SUCCESS;
+ 
+ done:
+ 	hci_dev_unlock(hdev);
+ 
+ 	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_GET_DEVICE_FLAGS, status,
+ 				&rp, sizeof(rp));
+ }
+ 
+ static void device_flags_changed(struct sock *sk, struct hci_dev *hdev,
+ 				 bdaddr_t *bdaddr, u8 bdaddr_type,
+ 				 u32 supported_flags, u32 current_flags)
+ {
+ 	struct mgmt_ev_device_flags_changed ev;
+ 
+ 	bacpy(&ev.addr.bdaddr, bdaddr);
+ 	ev.addr.type = bdaddr_type;
+ 	ev.supported_flags = cpu_to_le32(supported_flags);
+ 	ev.current_flags = cpu_to_le32(current_flags);
+ 
+ 	mgmt_event(MGMT_EV_DEVICE_FLAGS_CHANGED, hdev, &ev, sizeof(ev), sk);
+ }
+ 
+ static int set_device_flags(struct sock *sk, struct hci_dev *hdev, void *data,
++>>>>>>> a61d67188f29 (Bluetooth: Allow Microsoft extension to indicate curve validation)
  			    u16 len)
  {
 -	struct mgmt_cp_set_device_flags *cp = data;
 -	struct bdaddr_list_with_flags *br_params;
 -	struct hci_conn_params *params;
 -	u8 status = MGMT_STATUS_INVALID_PARAMS;
 -	u32 supported_flags = SUPPORTED_DEVICE_FLAGS();
 -	u32 current_flags = __le32_to_cpu(cp->current_flags);
 +	int err = MGMT_STATUS_SUCCESS;
 +	struct mgmt_cp_set_blocked_keys *keys = data;
 +	const u16 max_key_count = ((U16_MAX - sizeof(*keys)) /
 +				   sizeof(struct mgmt_blocked_key_info));
 +	u16 key_count, expected_len;
 +	int i;
  
 -	bt_dev_dbg(hdev, "Set device flags %pMR (type 0x%x) = 0x%x",
 -		   &cp->addr.bdaddr, cp->addr.type,
 -		   __le32_to_cpu(current_flags));
 +	BT_DBG("request for %s", hdev->name);
  
 -	if ((supported_flags | current_flags) != supported_flags) {
 -		bt_dev_warn(hdev, "Bad flag given (0x%x) vs supported (0x%0x)",
 -			    current_flags, supported_flags);
 -		goto done;
 +	key_count = __le16_to_cpu(keys->key_count);
 +	if (key_count > max_key_count) {
 +		bt_dev_err(hdev, "too big key_count value %u", key_count);
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				       MGMT_STATUS_INVALID_PARAMS);
  	}
  
 -	hci_dev_lock(hdev);
 -
 -	if (cp->addr.type == BDADDR_BREDR) {
 -		br_params = hci_bdaddr_list_lookup_with_flags(&hdev->whitelist,
 -							      &cp->addr.bdaddr,
 -							      cp->addr.type);
 -
 -		if (br_params) {
 -			br_params->current_flags = current_flags;
 -			status = MGMT_STATUS_SUCCESS;
 -		} else {
 -			bt_dev_warn(hdev, "No such BR/EDR device %pMR (0x%x)",
 -				    &cp->addr.bdaddr, cp->addr.type);
 -		}
 -	} else {
 -		params = hci_conn_params_lookup(hdev, &cp->addr.bdaddr,
 -						le_addr_type(cp->addr.type));
 -		if (params) {
 -			params->current_flags = current_flags;
 -			status = MGMT_STATUS_SUCCESS;
 -		} else {
 -			bt_dev_warn(hdev, "No such LE device %pMR (0x%x)",
 -				    &cp->addr.bdaddr,
 -				    le_addr_type(cp->addr.type));
 -		}
 +	expected_len = struct_size(keys, keys, key_count);
 +	if (expected_len != len) {
 +		bt_dev_err(hdev, "expected %u bytes, got %u bytes",
 +			   expected_len, len);
 +		return mgmt_cmd_status(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				       MGMT_STATUS_INVALID_PARAMS);
  	}
  
 -done:
 -	hci_dev_unlock(hdev);
 +	hci_dev_lock(hdev);
  
 -	if (status == MGMT_STATUS_SUCCESS)
 -		device_flags_changed(sk, hdev, &cp->addr.bdaddr, cp->addr.type,
 -				     supported_flags, current_flags);
 +	hci_blocked_keys_clear(hdev);
  
 -	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_DEVICE_FLAGS, status,
 -				 &cp->addr, sizeof(cp->addr));
 -}
 +	for (i = 0; i < keys->key_count; ++i) {
 +		struct blocked_key *b = kzalloc(sizeof(*b), GFP_KERNEL);
  
 -static void mgmt_adv_monitor_added(struct sock *sk, struct hci_dev *hdev,
 -				   u16 handle)
 -{
 -	struct mgmt_ev_adv_monitor_added ev;
 +		if (!b) {
 +			err = MGMT_STATUS_NO_RESOURCES;
 +			break;
 +		}
  
 -	ev.monitor_handle = cpu_to_le16(handle);
 +		b->type = keys->keys[i].type;
 +		memcpy(b->val, keys->keys[i].val, sizeof(b->val));
 +		list_add_rcu(&b->list, &hdev->blocked_keys);
 +	}
 +	hci_dev_unlock(hdev);
  
 -	mgmt_event(MGMT_EV_ADV_MONITOR_ADDED, hdev, &ev, sizeof(ev), sk);
 +	return mgmt_cmd_complete(sk, hdev->id, MGMT_OP_SET_BLOCKED_KEYS,
 +				err, NULL, 0);
  }
  
 -void mgmt_adv_monitor_removed(struct hci_dev *hdev, u16 handle)
 +static void read_local_oob_data_complete(struct hci_dev *hdev, u8 status,
 +				         u16 opcode, struct sk_buff *skb)
  {
 -	struct mgmt_ev_adv_monitor_removed ev;
 +	struct mgmt_rp_read_local_oob_data mgmt_rp;
 +	size_t rp_size = sizeof(mgmt_rp);
  	struct mgmt_pending_cmd *cmd;
 -	struct sock *sk_skip = NULL;
 -	struct mgmt_cp_remove_adv_monitor *cp;
 -
 -	cmd = pending_find(MGMT_OP_REMOVE_ADV_MONITOR, hdev);
 -	if (cmd) {
 -		cp = cmd->param;
 -
 -		if (cp->monitor_handle)
 -			sk_skip = cmd->sk;
 -	}
  
 -	ev.monitor_handle = cpu_to_le16(handle);
 +	BT_DBG("%s status %u", hdev->name, status);
  
 -	mgmt_event(MGMT_EV_ADV_MONITOR_REMOVED, hdev, &ev, sizeof(ev), sk_skip);
 -}
 -
 -static int read_adv_mon_features(struct sock *sk, struct hci_dev *hdev,
 -				 void *data, u16 len)
 -{
 -	struct adv_monitor *monitor = NULL;
 -	struct mgmt_rp_read_adv_monitor_features *rp = NULL;
 -	int handle, err;
 -	size_t rp_size = 0;
 -	__u32 supported = 0;
 -	__u32 enabled = 0;
 -	__u16 num_handles = 0;
 -	__u16 handles[HCI_MAX_ADV_MONITOR_NUM_HANDLES];
 +	cmd = pending_find(MGMT_OP_READ_LOCAL_OOB_DATA, hdev);
 +	if (!cmd)
 +		return;
  
 -	BT_DBG("request for %s", hdev->name);
 +	if (status || !skb) {
 +		mgmt_cmd_status(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
 +				status ? mgmt_status(status) : MGMT_STATUS_FAILED);
 +		goto remove;
 +	}
  
 -	hci_dev_lock(hdev);
 +	memset(&mgmt_rp, 0, sizeof(mgmt_rp));
  
 -	if (msft_monitor_supported(hdev))
 -		supported |= MGMT_ADV_MONITOR_FEATURE_MASK_OR_PATTERNS;
 +	if (opcode == HCI_OP_READ_LOCAL_OOB_DATA) {
 +		struct hci_rp_read_local_oob_data *rp = (void *) skb->data;
  
 -	idr_for_each_entry(&hdev->adv_monitors_idr, monitor, handle)
 -		handles[num_handles++] = monitor->handle;
 +		if (skb->len < sizeof(*rp)) {
 +			mgmt_cmd_status(cmd->sk, hdev->id,
 +					MGMT_OP_READ_LOCAL_OOB_DATA,
 +					MGMT_STATUS_FAILED);
 +			goto remove;
 +		}
  
 -	hci_dev_unlock(hdev);
 +		memcpy(mgmt_rp.hash192, rp->hash, sizeof(rp->hash));
 +		memcpy(mgmt_rp.rand192, rp->rand, sizeof(rp->rand));
  
 -	rp_size = sizeof(*rp) + (num_handles * sizeof(u16));
 -	rp = kmalloc(rp_size, GFP_KERNEL);
 -	if (!rp)
 -		return -ENOMEM;
 +		rp_size -= sizeof(mgmt_rp.hash256) + sizeof(mgmt_rp.rand256);
 +	} else {
 +		struct hci_rp_read_local_oob_ext_data *rp = (void *) skb->data;
  
 -	/* All supported features are currently enabled */
 -	enabled = supported;
 +		if (skb->len < sizeof(*rp)) {
 +			mgmt_cmd_status(cmd->sk, hdev->id,
 +					MGMT_OP_READ_LOCAL_OOB_DATA,
 +					MGMT_STATUS_FAILED);
 +			goto remove;
 +		}
  
 -	rp->supported_features = cpu_to_le32(supported);
 -	rp->enabled_features = cpu_to_le32(enabled);
 -	rp->max_num_handles = cpu_to_le16(HCI_MAX_ADV_MONITOR_NUM_HANDLES);
 -	rp->max_num_patterns = HCI_MAX_ADV_MONITOR_NUM_PATTERNS;
 -	rp->num_handles = cpu_to_le16(num_handles);
 -	if (num_handles)
 -		memcpy(&rp->handles, &handles, (num_handles * sizeof(u16)));
 +		memcpy(mgmt_rp.hash192, rp->hash192, sizeof(rp->hash192));
 +		memcpy(mgmt_rp.rand192, rp->rand192, sizeof(rp->rand192));
  
 -	err = mgmt_cmd_complete(sk, hdev->id,
 -				MGMT_OP_READ_ADV_MONITOR_FEATURES,
 -				MGMT_STATUS_SUCCESS, rp, rp_size);
 +		memcpy(mgmt_rp.hash256, rp->hash256, sizeof(rp->hash256));
 +		memcpy(mgmt_rp.rand256, rp->rand256, sizeof(rp->rand256));
 +	}
  
 -	kfree(rp);
 +	mgmt_cmd_complete(cmd->sk, hdev->id, MGMT_OP_READ_LOCAL_OOB_DATA,
 +			  MGMT_STATUS_SUCCESS, &mgmt_rp, rp_size);
  
 -	return err;
 +remove:
 +	mgmt_pending_remove(cmd);
  }
  
 -int mgmt_add_adv_patterns_monitor_complete(struct hci_dev *hdev, u8 status)
 +static int read_local_oob_data(struct sock *sk, struct hci_dev *hdev,
 +			       void *data, u16 data_len)
  {
 -	struct mgmt_rp_add_adv_patterns_monitor rp;
  	struct mgmt_pending_cmd *cmd;
 -	struct adv_monitor *monitor;
 -	int err = 0;
 +	struct hci_request req;
 +	int err;
 +
 +	BT_DBG("%s", hdev->name);
  
  	hci_dev_lock(hdev);
  
diff --cc net/bluetooth/msft.c
index d6c4e6b5ae77,e28f15439ce4..000000000000
--- a/net/bluetooth/msft.c
+++ b/net/bluetooth/msft.c
@@@ -139,3 -270,346 +142,349 @@@ void msft_vendor_evt(struct hci_dev *hd
  
  	bt_dev_dbg(hdev, "MSFT vendor event %u", event);
  }
++<<<<<<< HEAD
++=======
+ 
+ __u64 msft_get_features(struct hci_dev *hdev)
+ {
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	return msft ? msft->features : 0;
+ }
+ 
+ /* is_mgmt = true matches the handle exposed to userspace via mgmt.
+  * is_mgmt = false matches the handle used by the msft controller.
+  * This function requires the caller holds hdev->lock
+  */
+ static struct msft_monitor_advertisement_handle_data *msft_find_handle_data
+ 				(struct hci_dev *hdev, u16 handle, bool is_mgmt)
+ {
+ 	struct msft_monitor_advertisement_handle_data *entry;
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	list_for_each_entry(entry, &msft->handle_map, list) {
+ 		if (is_mgmt && entry->mgmt_handle == handle)
+ 			return entry;
+ 		if (!is_mgmt && entry->msft_handle == handle)
+ 			return entry;
+ 	}
+ 
+ 	return NULL;
+ }
+ 
+ static void msft_le_monitor_advertisement_cb(struct hci_dev *hdev,
+ 					     u8 status, u16 opcode,
+ 					     struct sk_buff *skb)
+ {
+ 	struct msft_rp_le_monitor_advertisement *rp;
+ 	struct adv_monitor *monitor;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	monitor = idr_find(&hdev->adv_monitors_idr, msft->pending_add_handle);
+ 	if (!monitor) {
+ 		bt_dev_err(hdev, "msft add advmon: monitor %d is not found!",
+ 			   msft->pending_add_handle);
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	if (status)
+ 		goto unlock;
+ 
+ 	rp = (struct msft_rp_le_monitor_advertisement *)skb->data;
+ 	if (skb->len < sizeof(*rp)) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	handle_data = kmalloc(sizeof(*handle_data), GFP_KERNEL);
+ 	if (!handle_data) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto unlock;
+ 	}
+ 
+ 	handle_data->mgmt_handle = monitor->handle;
+ 	handle_data->msft_handle = rp->handle;
+ 	INIT_LIST_HEAD(&handle_data->list);
+ 	list_add(&handle_data->list, &msft->handle_map);
+ 
+ 	monitor->state = ADV_MONITOR_STATE_OFFLOADED;
+ 
+ unlock:
+ 	if (status && monitor)
+ 		hci_free_adv_monitor(hdev, monitor);
+ 
+ 	/* If in restart/reregister sequence, keep registering. */
+ 	if (msft->reregistering)
+ 		reregister_monitor_on_restart(hdev,
+ 					      msft->pending_add_handle + 1);
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ 	if (!msft->reregistering)
+ 		hci_add_adv_patterns_monitor_complete(hdev, status);
+ }
+ 
+ static void msft_le_cancel_monitor_advertisement_cb(struct hci_dev *hdev,
+ 						    u8 status, u16 opcode,
+ 						    struct sk_buff *skb)
+ {
+ 	struct msft_cp_le_cancel_monitor_advertisement *cp;
+ 	struct msft_rp_le_cancel_monitor_advertisement *rp;
+ 	struct adv_monitor *monitor;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	int err;
+ 	bool pending;
+ 
+ 	if (status)
+ 		goto done;
+ 
+ 	rp = (struct msft_rp_le_cancel_monitor_advertisement *)skb->data;
+ 	if (skb->len < sizeof(*rp)) {
+ 		status = HCI_ERROR_UNSPECIFIED;
+ 		goto done;
+ 	}
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	cp = hci_sent_cmd_data(hdev, hdev->msft_opcode);
+ 	handle_data = msft_find_handle_data(hdev, cp->handle, false);
+ 
+ 	if (handle_data) {
+ 		monitor = idr_find(&hdev->adv_monitors_idr,
+ 				   handle_data->mgmt_handle);
+ 		if (monitor)
+ 			hci_free_adv_monitor(hdev, monitor);
+ 
+ 		list_del(&handle_data->list);
+ 		kfree(handle_data);
+ 	}
+ 
+ 	/* If remove all monitors is required, we need to continue the process
+ 	 * here because the earlier it was paused when waiting for the
+ 	 * response from controller.
+ 	 */
+ 	if (msft->pending_remove_handle == 0) {
+ 		pending = hci_remove_all_adv_monitor(hdev, &err);
+ 		if (pending) {
+ 			hci_dev_unlock(hdev);
+ 			return;
+ 		}
+ 
+ 		if (err)
+ 			status = HCI_ERROR_UNSPECIFIED;
+ 	}
+ 
+ 	hci_dev_unlock(hdev);
+ 
+ done:
+ 	hci_remove_adv_monitor_complete(hdev, status);
+ }
+ 
+ static void msft_le_set_advertisement_filter_enable_cb(struct hci_dev *hdev,
+ 						       u8 status, u16 opcode,
+ 						       struct sk_buff *skb)
+ {
+ 	struct msft_cp_le_set_advertisement_filter_enable *cp;
+ 	struct msft_rp_le_set_advertisement_filter_enable *rp;
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	rp = (struct msft_rp_le_set_advertisement_filter_enable *)skb->data;
+ 	if (skb->len < sizeof(*rp))
+ 		return;
+ 
+ 	/* Error 0x0C would be returned if the filter enabled status is
+ 	 * already set to whatever we were trying to set.
+ 	 * Although the default state should be disabled, some controller set
+ 	 * the initial value to enabled. Because there is no way to know the
+ 	 * actual initial value before sending this command, here we also treat
+ 	 * error 0x0C as success.
+ 	 */
+ 	if (status != 0x00 && status != 0x0C)
+ 		return;
+ 
+ 	hci_dev_lock(hdev);
+ 
+ 	cp = hci_sent_cmd_data(hdev, hdev->msft_opcode);
+ 	msft->filter_enabled = cp->enable;
+ 
+ 	if (status == 0x0C)
+ 		bt_dev_warn(hdev, "MSFT filter_enable is already %s",
+ 			    cp->enable ? "on" : "off");
+ 
+ 	hci_dev_unlock(hdev);
+ }
+ 
+ static bool msft_monitor_rssi_valid(struct adv_monitor *monitor)
+ {
+ 	struct adv_rssi_thresholds *r = &monitor->rssi;
+ 
+ 	if (r->high_threshold < MSFT_RSSI_THRESHOLD_VALUE_MIN ||
+ 	    r->high_threshold > MSFT_RSSI_THRESHOLD_VALUE_MAX ||
+ 	    r->low_threshold < MSFT_RSSI_THRESHOLD_VALUE_MIN ||
+ 	    r->low_threshold > MSFT_RSSI_THRESHOLD_VALUE_MAX)
+ 		return false;
+ 
+ 	/* High_threshold_timeout is not supported,
+ 	 * once high_threshold is reached, events are immediately reported.
+ 	 */
+ 	if (r->high_threshold_timeout != 0)
+ 		return false;
+ 
+ 	if (r->low_threshold_timeout > MSFT_RSSI_LOW_TIMEOUT_MAX)
+ 		return false;
+ 
+ 	/* Sampling period from 0x00 to 0xFF are all allowed */
+ 	return true;
+ }
+ 
+ static bool msft_monitor_pattern_valid(struct adv_monitor *monitor)
+ {
+ 	return msft_monitor_rssi_valid(monitor);
+ 	/* No additional check needed for pattern-based monitor */
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ static int __msft_add_monitor_pattern(struct hci_dev *hdev,
+ 				      struct adv_monitor *monitor)
+ {
+ 	struct msft_cp_le_monitor_advertisement *cp;
+ 	struct msft_le_monitor_advertisement_pattern_data *pattern_data;
+ 	struct msft_le_monitor_advertisement_pattern *pattern;
+ 	struct adv_pattern *entry;
+ 	struct hci_request req;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	size_t total_size = sizeof(*cp) + sizeof(*pattern_data);
+ 	ptrdiff_t offset = 0;
+ 	u8 pattern_count = 0;
+ 	int err = 0;
+ 
+ 	if (!msft_monitor_pattern_valid(monitor))
+ 		return -EINVAL;
+ 
+ 	list_for_each_entry(entry, &monitor->patterns, list) {
+ 		pattern_count++;
+ 		total_size += sizeof(*pattern) + entry->length;
+ 	}
+ 
+ 	cp = kmalloc(total_size, GFP_KERNEL);
+ 	if (!cp)
+ 		return -ENOMEM;
+ 
+ 	cp->sub_opcode = MSFT_OP_LE_MONITOR_ADVERTISEMENT;
+ 	cp->rssi_high = monitor->rssi.high_threshold;
+ 	cp->rssi_low = monitor->rssi.low_threshold;
+ 	cp->rssi_low_interval = (u8)monitor->rssi.low_threshold_timeout;
+ 	cp->rssi_sampling_period = monitor->rssi.sampling_period;
+ 
+ 	cp->cond_type = MSFT_MONITOR_ADVERTISEMENT_TYPE_PATTERN;
+ 
+ 	pattern_data = (void *)cp->data;
+ 	pattern_data->count = pattern_count;
+ 
+ 	list_for_each_entry(entry, &monitor->patterns, list) {
+ 		pattern = (void *)(pattern_data->data + offset);
+ 		/* the length also includes data_type and offset */
+ 		pattern->length = entry->length + 2;
+ 		pattern->data_type = entry->ad_type;
+ 		pattern->start_byte = entry->offset;
+ 		memcpy(pattern->pattern, entry->value, entry->length);
+ 		offset += sizeof(*pattern) + entry->length;
+ 	}
+ 
+ 	hci_req_init(&req, hdev);
+ 	hci_req_add(&req, hdev->msft_opcode, total_size, cp);
+ 	err = hci_req_run_skb(&req, msft_le_monitor_advertisement_cb);
+ 	kfree(cp);
+ 
+ 	if (!err)
+ 		msft->pending_add_handle = monitor->handle;
+ 
+ 	return err;
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int msft_add_monitor_pattern(struct hci_dev *hdev, struct adv_monitor *monitor)
+ {
+ 	struct msft_data *msft = hdev->msft_data;
+ 
+ 	if (!msft)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (msft->reregistering)
+ 		return -EBUSY;
+ 
+ 	return __msft_add_monitor_pattern(hdev, monitor);
+ }
+ 
+ /* This function requires the caller holds hdev->lock */
+ int msft_remove_monitor(struct hci_dev *hdev, struct adv_monitor *monitor,
+ 			u16 handle)
+ {
+ 	struct msft_cp_le_cancel_monitor_advertisement cp;
+ 	struct msft_monitor_advertisement_handle_data *handle_data;
+ 	struct hci_request req;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	int err = 0;
+ 
+ 	if (!msft)
+ 		return -EOPNOTSUPP;
+ 
+ 	if (msft->reregistering)
+ 		return -EBUSY;
+ 
+ 	handle_data = msft_find_handle_data(hdev, monitor->handle, true);
+ 
+ 	/* If no matched handle, just remove without telling controller */
+ 	if (!handle_data)
+ 		return -ENOENT;
+ 
+ 	cp.sub_opcode = MSFT_OP_LE_CANCEL_MONITOR_ADVERTISEMENT;
+ 	cp.handle = handle_data->msft_handle;
+ 
+ 	hci_req_init(&req, hdev);
+ 	hci_req_add(&req, hdev->msft_opcode, sizeof(cp), &cp);
+ 	err = hci_req_run_skb(&req, msft_le_cancel_monitor_advertisement_cb);
+ 
+ 	if (!err)
+ 		msft->pending_remove_handle = handle;
+ 
+ 	return err;
+ }
+ 
+ void msft_req_add_set_filter_enable(struct hci_request *req, bool enable)
+ {
+ 	struct hci_dev *hdev = req->hdev;
+ 	struct msft_cp_le_set_advertisement_filter_enable cp;
+ 
+ 	cp.sub_opcode = MSFT_OP_LE_SET_ADVERTISEMENT_FILTER_ENABLE;
+ 	cp.enable = enable;
+ 
+ 	hci_req_add(req, hdev->msft_opcode, sizeof(cp), &cp);
+ }
+ 
+ int msft_set_filter_enable(struct hci_dev *hdev, bool enable)
+ {
+ 	struct hci_request req;
+ 	struct msft_data *msft = hdev->msft_data;
+ 	int err;
+ 
+ 	if (!msft)
+ 		return -EOPNOTSUPP;
+ 
+ 	hci_req_init(&req, hdev);
+ 	msft_req_add_set_filter_enable(&req, enable);
+ 	err = hci_req_run_skb(&req, msft_le_set_advertisement_filter_enable_cb);
+ 
+ 	return err;
+ }
+ 
+ bool msft_curve_validity(struct hci_dev *hdev)
+ {
+ 	return hdev->msft_curve_validity;
+ }
++>>>>>>> a61d67188f29 (Bluetooth: Allow Microsoft extension to indicate curve validation)
diff --cc net/bluetooth/msft.h
index 5aa9130e1f8a,6e56d94b88d8..000000000000
--- a/net/bluetooth/msft.h
+++ b/net/bluetooth/msft.h
@@@ -8,11 -15,49 +8,26 @@@
  void msft_do_open(struct hci_dev *hdev);
  void msft_do_close(struct hci_dev *hdev);
  void msft_vendor_evt(struct hci_dev *hdev, struct sk_buff *skb);
++<<<<<<< HEAD
++=======
+ __u64 msft_get_features(struct hci_dev *hdev);
+ int msft_add_monitor_pattern(struct hci_dev *hdev, struct adv_monitor *monitor);
+ int msft_remove_monitor(struct hci_dev *hdev, struct adv_monitor *monitor,
+ 			u16 handle);
+ void msft_req_add_set_filter_enable(struct hci_request *req, bool enable);
+ int msft_set_filter_enable(struct hci_dev *hdev, bool enable);
+ bool msft_curve_validity(struct hci_dev *hdev);
++>>>>>>> a61d67188f29 (Bluetooth: Allow Microsoft extension to indicate curve validation)
  
  #else
  
  static inline void msft_do_open(struct hci_dev *hdev) {}
  static inline void msft_do_close(struct hci_dev *hdev) {}
  static inline void msft_vendor_evt(struct hci_dev *hdev, struct sk_buff *skb) {}
 -static inline __u64 msft_get_features(struct hci_dev *hdev) { return 0; }
 -static inline int msft_add_monitor_pattern(struct hci_dev *hdev,
 -					   struct adv_monitor *monitor)
 -{
 -	return -EOPNOTSUPP;
 -}
 -
 -static inline int msft_remove_monitor(struct hci_dev *hdev,
 -				      struct adv_monitor *monitor,
 -				      u16 handle)
 -{
 -	return -EOPNOTSUPP;
 -}
 -
 -static inline void msft_req_add_set_filter_enable(struct hci_request *req,
 -						  bool enable) {}
 -static inline int msft_set_filter_enable(struct hci_dev *hdev, bool enable)
 -{
 -	return -EOPNOTSUPP;
 -}
  
+ static inline bool msft_curve_validity(struct hci_dev *hdev)
+ {
+ 	return false;
+ }
+ 
  #endif
diff --git a/include/net/bluetooth/hci_core.h b/include/net/bluetooth/hci_core.h
index 8e03a2dc5f4a..e8cb9ba642bb 100644
--- a/include/net/bluetooth/hci_core.h
+++ b/include/net/bluetooth/hci_core.h
@@ -526,6 +526,7 @@ struct hci_dev {
 #if IS_ENABLED(CONFIG_BT_MSFTEXT)
 	__u16			msft_opcode;
 	void			*msft_data;
+	bool			msft_curve_validity;
 #endif
 
 #if IS_ENABLED(CONFIG_BT_AOSPEXT)
* Unmerged path net/bluetooth/mgmt.c
* Unmerged path net/bluetooth/msft.c
* Unmerged path net/bluetooth/msft.h
