mptcp: remove tx_pending_data

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Florian Westphal <fw@strlen.de>
commit 9e65b6a5aaa3236488b4f4e3e8b914d73124a5a5
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/9e65b6a5.failed

The update on recovery is not correct.

msk->tx_pending_data += msk->snd_nxt - rtx_head->data_seq;

will update tx_pending_data multiple times when a subflow is declared
stale while earlier recovery is still in progress.
This means that tx_pending_data will still be positive even after
all data as has been transmitted.

Rather than fix it, remove this field: there are no consumers.
The outstanding data byte count can be computed either via

 "msk->write_seq - rtx_head->data_seq" or
 "msk->write_seq - msk->snd_una".

The latter is more recent/accurate estimate as rtx_head adjustment
is deferred until mptcp lock can be acquired.

	Acked-by: Paolo Abeni <pabeni@redhat.com>
	Signed-off-by: Florian Westphal <fw@strlen.de>
	Signed-off-by: Mat Martineau <mathew.j.martineau@linux.intel.com>
	Signed-off-by: David S. Miller <davem@davemloft.net>
(cherry picked from commit 9e65b6a5aaa3236488b4f4e3e8b914d73124a5a5)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/mptcp/protocol.c
diff --cc net/mptcp/protocol.c
index 3c6947aa65c4,5b0ed64c5cd2..000000000000
--- a/net/mptcp/protocol.c
+++ b/net/mptcp/protocol.c
@@@ -1454,7 -1522,32 +1454,36 @@@ static void mptcp_push_release(struct s
  	release_sock(ssk);
  }
  
++<<<<<<< HEAD
 +static void __mptcp_push_pending(struct sock *sk, unsigned int flags)
++=======
+ static void mptcp_update_post_push(struct mptcp_sock *msk,
+ 				   struct mptcp_data_frag *dfrag,
+ 				   u32 sent)
+ {
+ 	u64 snd_nxt_new = dfrag->data_seq;
+ 
+ 	dfrag->already_sent += sent;
+ 
+ 	msk->snd_burst -= sent;
+ 
+ 	snd_nxt_new += dfrag->already_sent;
+ 
+ 	/* snd_nxt_new can be smaller than snd_nxt in case mptcp
+ 	 * is recovering after a failover. In that event, this re-sends
+ 	 * old segments.
+ 	 *
+ 	 * Thus compute snd_nxt_new candidate based on
+ 	 * the dfrag->data_seq that was sent and the data
+ 	 * that has been handed to the subflow for transmission
+ 	 * and skip update in case it was old dfrag.
+ 	 */
+ 	if (likely(after64(snd_nxt_new, msk->snd_nxt)))
+ 		msk->snd_nxt = snd_nxt_new;
+ }
+ 
+ void __mptcp_push_pending(struct sock *sk, unsigned int flags)
++>>>>>>> 9e65b6a5aaa3 (mptcp: remove tx_pending_data)
  {
  	struct sock *prev_ssk = NULL, *ssk = NULL;
  	struct mptcp_sock *msk = mptcp_sk(sk);
@@@ -2105,6 -2224,46 +2133,49 @@@ static void mptcp_dispose_initial_subfl
  	}
  }
  
++<<<<<<< HEAD
++=======
+ bool __mptcp_retransmit_pending_data(struct sock *sk)
+ {
+ 	struct mptcp_data_frag *cur, *rtx_head;
+ 	struct mptcp_sock *msk = mptcp_sk(sk);
+ 
+ 	if (__mptcp_check_fallback(mptcp_sk(sk)))
+ 		return false;
+ 
+ 	if (tcp_rtx_and_write_queues_empty(sk))
+ 		return false;
+ 
+ 	/* the closing socket has some data untransmitted and/or unacked:
+ 	 * some data in the mptcp rtx queue has not really xmitted yet.
+ 	 * keep it simple and re-inject the whole mptcp level rtx queue
+ 	 */
+ 	mptcp_data_lock(sk);
+ 	__mptcp_clean_una_wakeup(sk);
+ 	rtx_head = mptcp_rtx_head(sk);
+ 	if (!rtx_head) {
+ 		mptcp_data_unlock(sk);
+ 		return false;
+ 	}
+ 
+ 	msk->recovery_snd_nxt = msk->snd_nxt;
+ 	msk->recovery = true;
+ 	mptcp_data_unlock(sk);
+ 
+ 	msk->first_pending = rtx_head;
+ 	msk->snd_burst = 0;
+ 
+ 	/* be sure to clear the "sent status" on all re-injected fragments */
+ 	list_for_each_entry(cur, &msk->rtx_queue, list) {
+ 		if (!cur->already_sent)
+ 			break;
+ 		cur->already_sent = 0;
+ 	}
+ 
+ 	return true;
+ }
+ 
++>>>>>>> 9e65b6a5aaa3 (mptcp: remove tx_pending_data)
  /* subflow sockets can be either outgoing (connect) or incoming
   * (accept).
   *
* Unmerged path net/mptcp/protocol.c
diff --git a/net/mptcp/protocol.h b/net/mptcp/protocol.h
index 5c8dbbab0f7e..f09b1159a5e4 100644
--- a/net/mptcp/protocol.h
+++ b/net/mptcp/protocol.h
@@ -240,7 +240,6 @@ struct mptcp_sock {
 	struct sk_buff  *ooo_last_skb;
 	struct rb_root  out_of_order_queue;
 	struct sk_buff_head receive_queue;
-	int		tx_pending_data;
 	struct list_head conn_list;
 	struct list_head rtx_queue;
 	struct mptcp_data_frag *first_pending;
