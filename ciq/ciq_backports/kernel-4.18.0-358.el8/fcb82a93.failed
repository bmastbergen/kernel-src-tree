i2c: designware: Add Baikal-T1 System I2C support

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Serge Semin <Sergey.Semin@baikalelectronics.ru>
commit fcb82a939df86018641f38124cb9a7811a5f8505
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/fcb82a93.failed

Baikal-T1 System Controller is equipped with a dedicated I2C Controller
which functionality is based on the DW APB I2C IP-core, the only
difference in a way it' registers are accessed. There are three access
register provided in the System Controller registers map, which indirectly
address the normal DW APB I2C registers space. So in order to have the
Baikal-T1 System I2C Controller supported by the common DW APB I2C driver
we created a dedicated Dw I2C controller model quirk, which retrieves the
syscon regmap from the parental dt node and creates a new regmap based on
it.

	Signed-off-by: Serge Semin <Sergey.Semin@baikalelectronics.ru>
	Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Signed-off-by: Wolfram Sang <wsa@kernel.org>
(cherry picked from commit fcb82a939df86018641f38124cb9a7811a5f8505)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/busses/i2c-designware-core.h
diff --cc drivers/i2c/busses/i2c-designware-core.h
index a5f6db491e44,556673a1f61b..000000000000
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@@ -175,7 -182,10 +175,12 @@@
  /**
   * struct dw_i2c_dev - private i2c-designware data
   * @dev: driver model device node
++<<<<<<< HEAD
++=======
+  * @map: IO registers map
+  * @sysmap: System controller registers map
++>>>>>>> fcb82a939df8 (i2c: designware: Add Baikal-T1 System I2C support)
   * @base: IO registers pointer
 - * @ext: Extended IO registers pointer
   * @cmd_complete: tx completion indicator
   * @clk: input reference clock
   * @pclk: clock required to access the registers
@@@ -226,6 -235,8 +231,11 @@@
   */
  struct dw_i2c_dev {
  	struct device		*dev;
++<<<<<<< HEAD
++=======
+ 	struct regmap		*map;
+ 	struct regmap		*sysmap;
++>>>>>>> fcb82a939df8 (i2c: designware: Add Baikal-T1 System I2C support)
  	void __iomem		*base;
  	void __iomem		*ext;
  	struct completion	cmd_complete;
@@@ -278,18 -288,14 +288,23 @@@
  	bool			suspended;
  };
  
 -#define ACCESS_INTR_MASK	0x00000001
 -#define ACCESS_NO_IRQ_SUSPEND	0x00000002
 +#define ACCESS_SWAP		0x00000001
 +#define ACCESS_16BIT		0x00000002
 +#define ACCESS_INTR_MASK	0x00000004
 +#define ACCESS_NO_IRQ_SUSPEND	0x00000008
  
++<<<<<<< HEAD
 +#define MODEL_CHERRYTRAIL	0x00000100
 +#define MODEL_MSCC_OCELOT	0x00000200
++=======
+ #define MODEL_MSCC_OCELOT	0x00000100
+ #define MODEL_BAIKAL_BT1	0x00000200
++>>>>>>> fcb82a939df8 (i2c: designware: Add Baikal-T1 System I2C support)
  #define MODEL_MASK		0x00000f00
  
 -int i2c_dw_init_regmap(struct dw_i2c_dev *dev);
 +u32 dw_readl(struct dw_i2c_dev *dev, int offset);
 +void dw_writel(struct dw_i2c_dev *dev, u32 b, int offset);
 +int i2c_dw_set_reg_access(struct dw_i2c_dev *dev);
  u32 i2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset);
  u32 i2c_dw_scl_lcnt(u32 ic_clk, u32 tLOW, u32 tf, int offset);
  int i2c_dw_set_sda_hold(struct dw_i2c_dev *dev);
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index e64e626f23cc..ed3164c545f7 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -514,8 +514,9 @@ config I2C_DESIGNWARE_SLAVE
 
 config I2C_DESIGNWARE_PLATFORM
 	tristate "Synopsys DesignWare Platform"
-	select I2C_DESIGNWARE_CORE
 	depends on (ACPI && COMMON_CLK) || !ACPI
+	select I2C_DESIGNWARE_CORE
+	select MFD_SYSCON if MIPS_BAIKAL_T1
 	help
 	  If you say yes to this option, support will be included for the
 	  Synopsys DesignWare I2C adapter.
* Unmerged path drivers/i2c/busses/i2c-designware-core.h
diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 094d8604af68..f73af4b46601 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -19,6 +19,7 @@
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_data/i2c-designware.h>
@@ -26,6 +27,7 @@
 #include <linux/pm.h>
 #include <linux/pm_runtime.h>
 #include <linux/property.h>
+#include <linux/regmap.h>
 #include <linux/reset.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
@@ -142,6 +144,63 @@ static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
 #endif
 
 #ifdef CONFIG_OF
+#define BT1_I2C_CTL			0x100
+#define BT1_I2C_CTL_ADDR_MASK		GENMASK(7, 0)
+#define BT1_I2C_CTL_WR			BIT(8)
+#define BT1_I2C_CTL_GO			BIT(31)
+#define BT1_I2C_DI			0x104
+#define BT1_I2C_DO			0x108
+
+static int bt1_i2c_read(void *context, unsigned int reg, unsigned int *val)
+{
+	struct dw_i2c_dev *dev = context;
+	int ret;
+
+	/*
+	 * Note these methods shouldn't ever fail because the system controller
+	 * registers are memory mapped. We check the return value just in case.
+	 */
+	ret = regmap_write(dev->sysmap, BT1_I2C_CTL,
+			   BT1_I2C_CTL_GO | (reg & BT1_I2C_CTL_ADDR_MASK));
+	if (ret)
+		return ret;
+
+	return regmap_read(dev->sysmap, BT1_I2C_DO, val);
+}
+
+static int bt1_i2c_write(void *context, unsigned int reg, unsigned int val)
+{
+	struct dw_i2c_dev *dev = context;
+	int ret;
+
+	ret = regmap_write(dev->sysmap, BT1_I2C_DI, val);
+	if (ret)
+		return ret;
+
+	return regmap_write(dev->sysmap, BT1_I2C_CTL,
+		BT1_I2C_CTL_GO | BT1_I2C_CTL_WR | (reg & BT1_I2C_CTL_ADDR_MASK));
+}
+
+static struct regmap_config bt1_i2c_cfg = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.fast_io = true,
+	.reg_read = bt1_i2c_read,
+	.reg_write = bt1_i2c_write,
+	.max_register = DW_IC_COMP_TYPE,
+};
+
+static int bt1_i2c_request_regs(struct dw_i2c_dev *dev)
+{
+	dev->sysmap = syscon_node_to_regmap(dev->dev->of_node->parent);
+	if (IS_ERR(dev->sysmap))
+		return PTR_ERR(dev->sysmap);
+
+	dev->map = devm_regmap_init(dev->dev, NULL, dev, &bt1_i2c_cfg);
+	return PTR_ERR_OR_ZERO(dev->map);
+}
+
 #define MSCC_ICPU_CFG_TWI_DELAY		0x0
 #define MSCC_ICPU_CFG_TWI_DELAY_ENABLE	BIT(0)
 #define MSCC_ICPU_CFG_TWI_SPIKE_FILTER	0x4
@@ -174,10 +233,16 @@ static int dw_i2c_of_configure(struct platform_device *pdev)
 static const struct of_device_id dw_i2c_of_match[] = {
 	{ .compatible = "snps,designware-i2c", },
 	{ .compatible = "mscc,ocelot-i2c", .data = (void *)MODEL_MSCC_OCELOT },
+	{ .compatible = "baikal,bt1-sys-i2c", .data = (void *)MODEL_BAIKAL_BT1 },
 	{},
 };
 MODULE_DEVICE_TABLE(of, dw_i2c_of_match);
 #else
+static int bt1_i2c_request_regs(struct dw_i2c_dev *dev)
+{
+	return -ENODEV;
+}
+
 static inline int dw_i2c_of_configure(struct platform_device *pdev)
 {
 	return -ENODEV;
@@ -228,10 +293,19 @@ static void dw_i2c_plat_pm_cleanup(struct dw_i2c_dev *dev)
 static int dw_i2c_plat_request_regs(struct dw_i2c_dev *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev->dev);
+	int ret;
 
-	dev->base = devm_platform_ioremap_resource(pdev, 0);
+	switch (dev->flags & MODEL_MASK) {
+	case MODEL_BAIKAL_BT1:
+		ret = bt1_i2c_request_regs(dev);
+		break;
+	default:
+		dev->base = devm_platform_ioremap_resource(pdev, 0);
+		ret = PTR_ERR_OR_ZERO(dev->base);
+		break;
+	}
 
-	return PTR_ERR_OR_ZERO(dev->base);
+	return ret;
 }
 
 static int dw_i2c_plat_probe(struct platform_device *pdev)
