iommu/vt-d: Allow devices to have more than 32 outstanding PRs

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Lu Baolu <baolu.lu@linux.intel.com>
commit 48811c44349ffbb778d3e36b53beb03ad43a979c
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/48811c44.failed

The minimum per-IOMMU PRQ queue size is one 4K page, this is more entries
than the hardcoded limit of 32 in the current VT-d code. Some devices can
support up to 512 outstanding PRQs but underutilized by this limit of 32.
Although, 32 gives some rough fairness when multiple devices share the same
IOMMU PRQ queue, but far from optimal for customized use case. This extends
the per-IOMMU PRQ queue size to four 4K pages and let the devices have as
many outstanding page requests as they can.

	Signed-off-by: Jacob Pan <jacob.jun.pan@linux.intel.com>
	Signed-off-by: Lu Baolu <baolu.lu@linux.intel.com>
Link: https://lore.kernel.org/r/20210720013856.4143880-1-baolu.lu@linux.intel.com
Link: https://lore.kernel.org/r/20210818134852.1847070-7-baolu.lu@linux.intel.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 48811c44349ffbb778d3e36b53beb03ad43a979c)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/intel/svm.c
diff --cc drivers/iommu/intel/svm.c
index 81ccbea925a8,813438a07b62..000000000000
--- a/drivers/iommu/intel/svm.c
+++ b/drivers/iommu/intel/svm.c
@@@ -729,24 -722,6 +727,27 @@@ struct page_req_dsc 
  	u64 priv_data[2];
  };
  
++<<<<<<< HEAD
 +#define PRQ_RING_MASK	((0x1000 << PRQ_ORDER) - 0x20)
 +
 +static bool access_error(struct vm_area_struct *vma, struct page_req_dsc *req)
 +{
 +	unsigned long requested = 0;
 +
 +	if (req->exe_req)
 +		requested |= VM_EXEC;
 +
 +	if (req->rd_req)
 +		requested |= VM_READ;
 +
 +	if (req->wr_req)
 +		requested |= VM_WRITE;
 +
 +	return (requested & ~vma->vm_flags) != 0;
 +}
 +
++=======
++>>>>>>> 48811c44349f (iommu/vt-d: Allow devices to have more than 32 outstanding PRs)
  static bool is_canonical_address(u64 addr)
  {
  	int shift = 64 - (__VIRTUAL_MASK_SHIFT + 1);
diff --git a/drivers/iommu/intel/iommu.c b/drivers/iommu/intel/iommu.c
index 710fc10c4b7d..829015798697 100644
--- a/drivers/iommu/intel/iommu.c
+++ b/drivers/iommu/intel/iommu.c
@@ -41,6 +41,7 @@
 #include <linux/iommu.h>
 #include <linux/dma-iommu.h>
 #include <linux/intel-iommu.h>
+#include <linux/intel-svm.h>
 #include <linux/syscore_ops.h>
 #include <linux/tboot.h>
 #include <linux/dmi.h>
@@ -1547,7 +1548,7 @@ static void iommu_enable_dev_iotlb(struct device_domain_info *info)
 
 	if (info->pri_supported &&
 	    (info->pasid_enabled ? pci_prg_resp_pasid_required(pdev) : 1)  &&
-	    !pci_reset_pri(pdev) && !pci_enable_pri(pdev, 32))
+	    !pci_reset_pri(pdev) && !pci_enable_pri(pdev, PRQ_DEPTH))
 		info->pri_enabled = 1;
 #endif
 	if (info->ats_supported && pci_ats_page_aligned(pdev) &&
* Unmerged path drivers/iommu/intel/svm.c
diff --git a/include/linux/intel-svm.h b/include/linux/intel-svm.h
index cd883b349bb6..9cdf18b2ceaa 100644
--- a/include/linux/intel-svm.h
+++ b/include/linux/intel-svm.h
@@ -22,6 +22,11 @@
 #define SVM_REQ_EXEC	(1<<1)
 #define SVM_REQ_PRIV	(1<<0)
 
+/* Page Request Queue depth */
+#define PRQ_ORDER	2
+#define PRQ_RING_MASK	((0x1000 << PRQ_ORDER) - 0x20)
+#define PRQ_DEPTH	((0x1000 << PRQ_ORDER) >> 5)
+
 /*
  * The SVM_FLAG_SUPERVISOR_MODE flag requests a PASID which can be used only
  * for access to kernel addresses. No IOTLB flushes are automatically done
