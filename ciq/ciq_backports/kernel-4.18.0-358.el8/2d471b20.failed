iommu: Streamline registration interface

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Robin Murphy <robin.murphy@arm.com>
commit 2d471b20c55e13c98d1dba413bf2de618e89cdac
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/2d471b20.failed

Rather than have separate opaque setter functions that are easy to
overlook and lead to repetitive boilerplate in drivers, let's pass the
relevant initialisation parameters directly to iommu_device_register().

	Acked-by: Will Deacon <will@kernel.org>
	Signed-off-by: Robin Murphy <robin.murphy@arm.com>
Link: https://lore.kernel.org/r/ab001b87c533b6f4db71eb90db6f888953986c36.1617285386.git.robin.murphy@arm.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 2d471b20c55e13c98d1dba413bf2de618e89cdac)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/omap-iommu.c
#	drivers/iommu/sprd-iommu.c
#	drivers/iommu/sun50i-iommu.c
#	drivers/iommu/tegra-gart.c
#	drivers/iommu/tegra-smmu.c
#	include/linux/iommu.h
diff --cc drivers/iommu/omap-iommu.c
index bef7c11ef869,26e517eb0dd3..000000000000
--- a/drivers/iommu/omap-iommu.c
+++ b/drivers/iommu/omap-iommu.c
@@@ -1033,9 -1235,7 +1033,13 @@@ static int omap_iommu_probe(struct plat
  		if (err)
  			goto out_group;
  
++<<<<<<< HEAD
 +		iommu_device_set_ops(&obj->iommu, &omap_iommu_ops);
 +
 +		err = iommu_device_register(&obj->iommu);
++=======
+ 		err = iommu_device_register(&obj->iommu, &omap_iommu_ops, &pdev->dev);
++>>>>>>> 2d471b20c55e (iommu: Streamline registration interface)
  		if (err)
  			goto out_sysfs;
  	}
diff --cc drivers/iommu/tegra-gart.c
index 55ec647f9891,6a358f92c7e5..000000000000
--- a/drivers/iommu/tegra-gart.c
+++ b/drivers/iommu/tegra-gart.c
@@@ -475,60 -340,41 +475,97 @@@ static int tegra_gart_probe(struct plat
  
  	gart_handle = gart;
  
++<<<<<<< HEAD
 +	return 0;
++=======
+ 	gart->dev = dev;
+ 	gart->regs = mc->regs + GART_REG_BASE;
+ 	gart->iovmm_base = res->start;
+ 	gart->iovmm_end = res->end + 1;
+ 	spin_lock_init(&gart->pte_lock);
+ 	spin_lock_init(&gart->dom_lock);
+ 
+ 	do_gart_setup(gart, NULL);
+ 
+ 	err = iommu_device_sysfs_add(&gart->iommu, dev, NULL, "gart");
+ 	if (err)
+ 		goto free_gart;
+ 
+ 	err = iommu_device_register(&gart->iommu, &gart_iommu_ops, dev);
+ 	if (err)
+ 		goto remove_sysfs;
+ 
+ 	gart->savedata = vmalloc(resource_size(res) / GART_PAGE_SIZE *
+ 				 sizeof(u32));
+ 	if (!gart->savedata) {
+ 		err = -ENOMEM;
+ 		goto unregister_iommu;
+ 	}
+ 
+ 	return gart;
+ 
+ unregister_iommu:
+ 	iommu_device_unregister(&gart->iommu);
+ remove_sysfs:
+ 	iommu_device_sysfs_remove(&gart->iommu);
+ free_gart:
+ 	kfree(gart);
+ 
+ 	return ERR_PTR(err);
++>>>>>>> 2d471b20c55e (iommu: Streamline registration interface)
 +}
 +
 +static int tegra_gart_remove(struct platform_device *pdev)
 +{
 +	struct gart_device *gart = platform_get_drvdata(pdev);
 +
 +	iommu_device_unregister(&gart->iommu);
 +	iommu_device_sysfs_remove(&gart->iommu);
 +
 +	writel(0, gart->regs + GART_CONFIG);
 +	if (gart->savedata)
 +		vfree(gart->savedata);
 +	gart_handle = NULL;
 +	return 0;
  }
  
 +static const struct dev_pm_ops tegra_gart_pm_ops = {
 +	.suspend	= tegra_gart_suspend,
 +	.resume		= tegra_gart_resume,
 +};
 +
 +static const struct of_device_id tegra_gart_of_match[] = {
 +	{ .compatible = "nvidia,tegra20-gart", },
 +	{ },
 +};
 +MODULE_DEVICE_TABLE(of, tegra_gart_of_match);
 +
 +static struct platform_driver tegra_gart_driver = {
 +	.probe		= tegra_gart_probe,
 +	.remove		= tegra_gart_remove,
 +	.driver = {
 +		.name	= "tegra-gart",
 +		.pm	= &tegra_gart_pm_ops,
 +		.of_match_table = tegra_gart_of_match,
 +	},
 +};
 +
 +static int tegra_gart_init(void)
 +{
 +	return platform_driver_register(&tegra_gart_driver);
 +}
 +
 +static void __exit tegra_gart_exit(void)
 +{
 +	platform_driver_unregister(&tegra_gart_driver);
 +}
 +
 +subsys_initcall(tegra_gart_init);
 +module_exit(tegra_gart_exit);
  module_param(gart_debug, bool, 0644);
 +
  MODULE_PARM_DESC(gart_debug, "Enable GART debugging");
 +MODULE_DESCRIPTION("IOMMU API for GART in Tegra20");
 +MODULE_AUTHOR("Hiroshi DOYU <hdoyu@nvidia.com>");
 +MODULE_ALIAS("platform:tegra-gart");
 +MODULE_LICENSE("GPL v2");
diff --cc drivers/iommu/tegra-smmu.c
index 6fa39998efd6,1e98dc63ad13..000000000000
--- a/drivers/iommu/tegra-smmu.c
+++ b/drivers/iommu/tegra-smmu.c
@@@ -1067,21 -1145,19 +1067,27 @@@ struct tegra_smmu *tegra_smmu_probe(str
  	if (err)
  		return ERR_PTR(err);
  
++<<<<<<< HEAD
 +	iommu_device_set_ops(&smmu->iommu, &tegra_smmu_ops);
 +	iommu_device_set_fwnode(&smmu->iommu, dev->fwnode);
 +
 +	err = iommu_device_register(&smmu->iommu);
 +	if (err) {
 +		iommu_device_sysfs_remove(&smmu->iommu);
 +		return ERR_PTR(err);
 +	}
++=======
+ 	err = iommu_device_register(&smmu->iommu, &tegra_smmu_ops, dev);
+ 	if (err)
+ 		goto remove_sysfs;
++>>>>>>> 2d471b20c55e (iommu: Streamline registration interface)
  
  	err = bus_set_iommu(&platform_bus_type, &tegra_smmu_ops);
 -	if (err < 0)
 -		goto unregister;
 -
 -#ifdef CONFIG_PCI
 -	err = bus_set_iommu(&pci_bus_type, &tegra_smmu_ops);
 -	if (err < 0)
 -		goto unset_platform_bus;
 -#endif
 +	if (err < 0) {
 +		iommu_device_unregister(&smmu->iommu);
 +		iommu_device_sysfs_remove(&smmu->iommu);
 +		return ERR_PTR(err);
 +	}
  
  	if (IS_ENABLED(CONFIG_DEBUG_FS))
  		tegra_smmu_debugfs_init(smmu);
diff --cc include/linux/iommu.h
index 486407c90575,32d448050bf7..000000000000
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@@ -426,25 -363,6 +428,28 @@@ int  iommu_device_link(struct iommu_dev
  void iommu_device_unlink(struct iommu_device *iommu, struct device *link);
  int iommu_deferred_attach(struct device *dev, struct iommu_domain *domain);
  
++<<<<<<< HEAD
 +static inline void __iommu_device_set_ops(struct iommu_device *iommu,
 +					  const struct iommu_ops *ops)
 +{
 +	iommu->ops = ops;
 +}
 +
 +#define iommu_device_set_ops(iommu, ops)				\
 +do {									\
 +	struct iommu_ops *__ops = (struct iommu_ops *)(ops);		\
 +	__ops->owner = THIS_MODULE;					\
 +	__iommu_device_set_ops(iommu, __ops);				\
 +} while (0)
 +
 +static inline void iommu_device_set_fwnode(struct iommu_device *iommu,
 +					   struct fwnode_handle *fwnode)
 +{
 +	iommu->fwnode = fwnode;
 +}
 +
++=======
++>>>>>>> 2d471b20c55e (iommu: Streamline registration interface)
  static inline struct iommu_device *dev_to_iommu_device(struct device *dev)
  {
  	return (struct iommu_device *)dev_get_drvdata(dev);
@@@ -935,19 -842,15 +940,21 @@@ static inline int iommu_group_id(struc
  	return -ENODEV;
  }
  
 -static inline int iommu_set_pgtable_quirks(struct iommu_domain *domain,
 -		unsigned long quirks)
 +static inline int iommu_domain_get_attr(struct iommu_domain *domain,
 +					enum iommu_attr attr, void *data)
  {
 -	return 0;
 +	return -EINVAL;
 +}
 +
 +static inline int iommu_domain_set_attr(struct iommu_domain *domain,
 +					enum iommu_attr attr, void *data)
 +{
 +	return -EINVAL;
  }
  
- static inline int  iommu_device_register(struct iommu_device *iommu)
+ static inline int iommu_device_register(struct iommu_device *iommu,
+ 					const struct iommu_ops *ops,
+ 					struct device *hwdev)
  {
  	return -ENODEV;
  }
* Unmerged path drivers/iommu/sprd-iommu.c
* Unmerged path drivers/iommu/sun50i-iommu.c
diff --git a/drivers/iommu/amd/init.c b/drivers/iommu/amd/init.c
index 987dc258b436..9fabb16f0769 100644
--- a/drivers/iommu/amd/init.c
+++ b/drivers/iommu/amd/init.c
@@ -1898,8 +1898,7 @@ static int __init iommu_init_pci(struct amd_iommu *iommu)
 
 	iommu_device_sysfs_add(&iommu->iommu, &iommu->dev->dev,
 			       amd_iommu_groups, "ivhd%d", iommu->index);
-	iommu_device_set_ops(&iommu->iommu, &amd_iommu_ops);
-	iommu_device_register(&iommu->iommu);
+	iommu_device_register(&iommu->iommu, &amd_iommu_ops, NULL);
 
 	return pci_enable_device(iommu->dev);
 }
diff --git a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
index e2826471dbec..d4230f3d8c40 100644
--- a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
+++ b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
@@ -3723,10 +3723,7 @@ static int arm_smmu_device_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	iommu_device_set_ops(&smmu->iommu, &arm_smmu_ops);
-	iommu_device_set_fwnode(&smmu->iommu, dev->fwnode);
-
-	ret = iommu_device_register(&smmu->iommu);
+	ret = iommu_device_register(&smmu->iommu, &arm_smmu_ops, dev);
 	if (ret) {
 		dev_err(dev, "Failed to register iommu\n");
 		return ret;
diff --git a/drivers/iommu/arm/arm-smmu/arm-smmu.c b/drivers/iommu/arm/arm-smmu/arm-smmu.c
index 3c3c49fd26d8..e98134345533 100644
--- a/drivers/iommu/arm/arm-smmu/arm-smmu.c
+++ b/drivers/iommu/arm/arm-smmu/arm-smmu.c
@@ -2213,10 +2213,7 @@ static int arm_smmu_device_probe(struct platform_device *pdev)
 		return err;
 	}
 
-	iommu_device_set_ops(&smmu->iommu, &arm_smmu_ops);
-	iommu_device_set_fwnode(&smmu->iommu, dev->fwnode);
-
-	err = iommu_device_register(&smmu->iommu);
+	err = iommu_device_register(&smmu->iommu, &arm_smmu_ops, dev);
 	if (err) {
 		dev_err(dev, "Failed to register iommu\n");
 		return err;
diff --git a/drivers/iommu/arm/arm-smmu/qcom_iommu.c b/drivers/iommu/arm/arm-smmu/qcom_iommu.c
index 9a53035cb7e5..f4db59432acc 100644
--- a/drivers/iommu/arm/arm-smmu/qcom_iommu.c
+++ b/drivers/iommu/arm/arm-smmu/qcom_iommu.c
@@ -868,10 +868,7 @@ static int qcom_iommu_device_probe(struct platform_device *pdev)
 		return ret;
 	}
 
-	iommu_device_set_ops(&qcom_iommu->iommu, &qcom_iommu_ops);
-	iommu_device_set_fwnode(&qcom_iommu->iommu, dev->fwnode);
-
-	ret = iommu_device_register(&qcom_iommu->iommu);
+	ret = iommu_device_register(&qcom_iommu->iommu, &qcom_iommu_ops, dev);
 	if (ret) {
 		dev_err(dev, "Failed to register iommu\n");
 		return ret;
diff --git a/drivers/iommu/exynos-iommu.c b/drivers/iommu/exynos-iommu.c
index aa932a06b9b6..48aa8eb29e8e 100644
--- a/drivers/iommu/exynos-iommu.c
+++ b/drivers/iommu/exynos-iommu.c
@@ -635,10 +635,7 @@ static int __init exynos_sysmmu_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	iommu_device_set_ops(&data->iommu, &exynos_iommu_ops);
-	iommu_device_set_fwnode(&data->iommu, &dev->of_node->fwnode);
-
-	ret = iommu_device_register(&data->iommu);
+	ret = iommu_device_register(&data->iommu, &exynos_iommu_ops, dev);
 	if (ret)
 		return ret;
 
diff --git a/drivers/iommu/fsl_pamu_domain.c b/drivers/iommu/fsl_pamu_domain.c
index f83965ee3095..c72f53575372 100644
--- a/drivers/iommu/fsl_pamu_domain.c
+++ b/drivers/iommu/fsl_pamu_domain.c
@@ -1100,9 +1100,7 @@ int __init pamu_domain_init(void)
 	if (ret)
 		return ret;
 
-	iommu_device_set_ops(&pamu_iommu, &fsl_pamu_ops);
-
-	ret = iommu_device_register(&pamu_iommu);
+	ret = iommu_device_register(&pamu_iommu, &fsl_pamu_ops, NULL);
 	if (ret) {
 		iommu_device_sysfs_remove(&pamu_iommu);
 		pr_err("Can't register iommu device\n");
diff --git a/drivers/iommu/intel/dmar.c b/drivers/iommu/intel/dmar.c
index eab229e0f616..82d34c4e4f14 100644
--- a/drivers/iommu/intel/dmar.c
+++ b/drivers/iommu/intel/dmar.c
@@ -1124,9 +1124,7 @@ static int alloc_iommu(struct dmar_drhd_unit *drhd)
 		if (err)
 			goto err_unmap;
 
-		iommu_device_set_ops(&iommu->iommu, &intel_iommu_ops);
-
-		err = iommu_device_register(&iommu->iommu);
+		err = iommu_device_register(&iommu->iommu, &intel_iommu_ops, NULL);
 		if (err)
 			goto err_sysfs;
 	}
diff --git a/drivers/iommu/intel/iommu.c b/drivers/iommu/intel/iommu.c
index d07794adf618..66e5a99cf043 100644
--- a/drivers/iommu/intel/iommu.c
+++ b/drivers/iommu/intel/iommu.c
@@ -4309,8 +4309,7 @@ int __init intel_iommu_init(void)
 		iommu_device_sysfs_add(&iommu->iommu, NULL,
 				       intel_iommu_groups,
 				       "%s", iommu->name);
-		iommu_device_set_ops(&iommu->iommu, &intel_iommu_ops);
-		iommu_device_register(&iommu->iommu);
+		iommu_device_register(&iommu->iommu, &intel_iommu_ops, NULL);
 	}
 	up_read(&dmar_global_lock);
 
diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c
index 3393cee7f54d..63ea0c81869a 100644
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@ -166,8 +166,25 @@ static int __init iommu_subsys_init(void)
 }
 subsys_initcall(iommu_subsys_init);
 
-int iommu_device_register(struct iommu_device *iommu)
+/**
+ * iommu_device_register() - Register an IOMMU hardware instance
+ * @iommu: IOMMU handle for the instance
+ * @ops:   IOMMU ops to associate with the instance
+ * @hwdev: (optional) actual instance device, used for fwnode lookup
+ *
+ * Return: 0 on success, or an error.
+ */
+int iommu_device_register(struct iommu_device *iommu,
+			  const struct iommu_ops *ops, struct device *hwdev)
 {
+	/* We need to be able to take module references appropriately */
+	if (WARN_ON(is_module_address((unsigned long)ops) && !ops->owner))
+		return -EINVAL;
+
+	iommu->ops = ops;
+	if (hwdev)
+		iommu->fwnode = hwdev->fwnode;
+
 	spin_lock(&iommu_device_lock);
 	list_add_tail(&iommu->list, &iommu_device_list);
 	spin_unlock(&iommu_device_lock);
diff --git a/drivers/iommu/ipmmu-vmsa.c b/drivers/iommu/ipmmu-vmsa.c
index 5a8da82fc7ca..939d62e04acd 100644
--- a/drivers/iommu/ipmmu-vmsa.c
+++ b/drivers/iommu/ipmmu-vmsa.c
@@ -1036,11 +1036,7 @@ static int ipmmu_probe(struct platform_device *pdev)
 		if (ret)
 			return ret;
 
-		iommu_device_set_ops(&mmu->iommu, &ipmmu_ops);
-		iommu_device_set_fwnode(&mmu->iommu,
-					&pdev->dev.of_node->fwnode);
-
-		ret = iommu_device_register(&mmu->iommu);
+		ret = iommu_device_register(&mmu->iommu, &ipmmu_ops, &pdev->dev);
 		if (ret)
 			return ret;
 
diff --git a/drivers/iommu/msm_iommu.c b/drivers/iommu/msm_iommu.c
index d8227caba891..02d2e0ac1200 100644
--- a/drivers/iommu/msm_iommu.c
+++ b/drivers/iommu/msm_iommu.c
@@ -829,10 +829,7 @@ static int msm_iommu_probe(struct platform_device *pdev)
 		goto fail;
 	}
 
-	iommu_device_set_ops(&iommu->iommu, &msm_iommu_ops);
-	iommu_device_set_fwnode(&iommu->iommu, &pdev->dev.of_node->fwnode);
-
-	ret = iommu_device_register(&iommu->iommu);
+	ret = iommu_device_register(&iommu->iommu, &msm_iommu_ops, &pdev->dev);
 	if (ret) {
 		pr_err("Could not register msm-smmu at %pa\n", &ioaddr);
 		goto fail;
diff --git a/drivers/iommu/mtk_iommu.c b/drivers/iommu/mtk_iommu.c
index 38aceac865e2..45e57aa6c7d8 100644
--- a/drivers/iommu/mtk_iommu.c
+++ b/drivers/iommu/mtk_iommu.c
@@ -685,10 +685,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	iommu_device_set_ops(&data->iommu, &mtk_iommu_ops);
-	iommu_device_set_fwnode(&data->iommu, &pdev->dev.of_node->fwnode);
-
-	ret = iommu_device_register(&data->iommu);
+	ret = iommu_device_register(&data->iommu, &mtk_iommu_ops, dev);
 	if (ret)
 		return ret;
 
diff --git a/drivers/iommu/mtk_iommu_v1.c b/drivers/iommu/mtk_iommu_v1.c
index a02af2e4510f..f3f743016917 100644
--- a/drivers/iommu/mtk_iommu_v1.c
+++ b/drivers/iommu/mtk_iommu_v1.c
@@ -629,9 +629,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
-	iommu_device_set_ops(&data->iommu, &mtk_iommu_ops);
-
-	ret = iommu_device_register(&data->iommu);
+	ret = iommu_device_register(&data->iommu, &mtk_iommu_ops, dev);
 	if (ret)
 		return ret;
 
* Unmerged path drivers/iommu/omap-iommu.c
diff --git a/drivers/iommu/rockchip-iommu.c b/drivers/iommu/rockchip-iommu.c
index 4326ad7e94fc..95640cc7c054 100644
--- a/drivers/iommu/rockchip-iommu.c
+++ b/drivers/iommu/rockchip-iommu.c
@@ -1197,10 +1197,7 @@ static int rk_iommu_probe(struct platform_device *pdev)
 	if (err)
 		goto err_put_group;
 
-	iommu_device_set_ops(&iommu->iommu, &rk_iommu_ops);
-	iommu_device_set_fwnode(&iommu->iommu, &dev->of_node->fwnode);
-
-	err = iommu_device_register(&iommu->iommu);
+	err = iommu_device_register(&iommu->iommu, &rk_iommu_ops, dev);
 	if (err)
 		goto err_remove_sysfs;
 
diff --git a/drivers/iommu/s390-iommu.c b/drivers/iommu/s390-iommu.c
index 8895dbb705eb..6019e58ce4fb 100644
--- a/drivers/iommu/s390-iommu.c
+++ b/drivers/iommu/s390-iommu.c
@@ -333,9 +333,7 @@ int zpci_init_iommu(struct zpci_dev *zdev)
 	if (rc)
 		goto out_err;
 
-	iommu_device_set_ops(&zdev->iommu_dev, &s390_iommu_ops);
-
-	rc = iommu_device_register(&zdev->iommu_dev);
+	rc = iommu_device_register(&zdev->iommu_dev, &s390_iommu_ops, NULL);
 	if (rc)
 		goto out_sysfs;
 
* Unmerged path drivers/iommu/sprd-iommu.c
* Unmerged path drivers/iommu/sun50i-iommu.c
* Unmerged path drivers/iommu/tegra-gart.c
* Unmerged path drivers/iommu/tegra-smmu.c
diff --git a/drivers/iommu/virtio-iommu.c b/drivers/iommu/virtio-iommu.c
index 7aa289c18da1..656b901597fc 100644
--- a/drivers/iommu/virtio-iommu.c
+++ b/drivers/iommu/virtio-iommu.c
@@ -1065,10 +1065,7 @@ static int viommu_probe(struct virtio_device *vdev)
 	if (ret)
 		goto err_free_vqs;
 
-	iommu_device_set_ops(&viommu->iommu, &viommu_ops);
-	iommu_device_set_fwnode(&viommu->iommu, parent_dev->fwnode);
-
-	iommu_device_register(&viommu->iommu);
+	iommu_device_register(&viommu->iommu, &viommu_ops, parent_dev);
 
 #ifdef CONFIG_PCI
 	if (pci_bus_type.iommu_ops != &viommu_ops) {
* Unmerged path include/linux/iommu.h
