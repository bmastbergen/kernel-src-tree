powerpc/mm/highmem: Switch to generic kmap atomic

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Thomas Gleixner <tglx@linutronix.de>
commit 47da42b27a56f3ee5abace2858b69e277703f707
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/47da42b2.failed

No reason having the same code in every architecture

	Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
	Cc: Michael Ellerman <mpe@ellerman.id.au>
	Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
	Cc: Paul Mackerras <paulus@samba.org>
	Cc: Arnd Bergmann <arnd@arndb.de>
Link: https://lore.kernel.org/r/20201103095858.087635810@linutronix.de

(cherry picked from commit 47da42b27a56f3ee5abace2858b69e277703f707)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	arch/powerpc/include/asm/highmem.h
#	arch/powerpc/include/asm/kmap_types.h
#	arch/powerpc/mm/highmem.c
#	arch/powerpc/mm/mem.c
diff --cc arch/powerpc/include/asm/highmem.h
index cec820f961da,80a5ae771c65..000000000000
--- a/arch/powerpc/include/asm/highmem.h
+++ b/arch/powerpc/include/asm/highmem.h
@@@ -24,13 -24,10 +24,20 @@@
  #ifdef __KERNEL__
  
  #include <linux/interrupt.h>
++<<<<<<< HEAD
 +#include <asm/kmap_types.h>
 +#include <asm/tlbflush.h>
 +#include <asm/page.h>
 +#include <asm/fixmap.h>
 +
 +extern pte_t *kmap_pte;
 +extern pgprot_t kmap_prot;
++=======
+ #include <asm/cacheflush.h>
+ #include <asm/page.h>
+ #include <asm/fixmap.h>
+ 
++>>>>>>> 47da42b27a56 (powerpc/mm/highmem: Switch to generic kmap atomic)
  extern pte_t *pkmap_page_table;
  
  /*
@@@ -59,35 -56,13 +66,40 @@@
  #define PKMAP_NR(virt)  ((virt-PKMAP_BASE) >> PAGE_SHIFT)
  #define PKMAP_ADDR(nr)  (PKMAP_BASE + ((nr) << PAGE_SHIFT))
  
 +extern void *kmap_high(struct page *page);
 +extern void kunmap_high(struct page *page);
 +extern void *kmap_atomic_prot(struct page *page, pgprot_t prot);
 +extern void __kunmap_atomic(void *kvaddr);
 +
 +static inline void *kmap(struct page *page)
 +{
 +	might_sleep();
 +	if (!PageHighMem(page))
 +		return page_address(page);
 +	return kmap_high(page);
 +}
 +
 +static inline void kunmap(struct page *page)
 +{
 +	BUG_ON(in_interrupt());
 +	if (!PageHighMem(page))
 +		return;
 +	kunmap_high(page);
 +}
 +
 +static inline void *kmap_atomic(struct page *page)
 +{
 +	return kmap_atomic_prot(page, kmap_prot);
 +}
 +
 +
  #define flush_cache_kmaps()	flush_cache_all()
  
+ #define arch_kmap_local_post_map(vaddr, pteval)	\
+ 	local_flush_tlb_page(NULL, vaddr)
+ #define arch_kmap_local_post_unmap(vaddr)	\
+ 	local_flush_tlb_page(NULL, vaddr)
+ 
  #endif /* __KERNEL__ */
  
  #endif /* _ASM_HIGHMEM_H */
diff --cc arch/powerpc/mm/mem.c
index 463f11d5645d,375a9894063b..000000000000
--- a/arch/powerpc/mm/mem.c
+++ b/arch/powerpc/mm/mem.c
@@@ -66,24 -61,6 +66,27 @@@
  unsigned long long memory_limit;
  bool init_mem_is_free;
  
++<<<<<<< HEAD
 +#ifdef CONFIG_HIGHMEM
 +pte_t *kmap_pte;
 +EXPORT_SYMBOL(kmap_pte);
 +pgprot_t kmap_prot;
 +EXPORT_SYMBOL(kmap_prot);
 +
 +static inline pte_t *virt_to_kpte(unsigned long vaddr)
 +{
 +	return pte_offset_kernel(pmd_offset(pud_offset(pgd_offset_k(vaddr),
 +			vaddr), vaddr), vaddr);
 +}
 +#endif
 +
 +int page_is_ram(unsigned long pfn)
 +{
 +	return memblock_is_memory(__pfn_to_phys(pfn));
 +}
 +
++=======
++>>>>>>> 47da42b27a56 (powerpc/mm/highmem: Switch to generic kmap atomic)
  pgprot_t phys_mem_access_prot(struct file *file, unsigned long pfn,
  			      unsigned long size, pgprot_t vma_prot)
  {
@@@ -279,14 -227,9 +282,17 @@@ void __init paging_init(void
  
  	for (; v < end; v += PAGE_SIZE)
  		map_kernel_page(v, 0, __pgprot(0)); /* XXX gross */
 +#endif
  
 +#ifdef CONFIG_HIGHMEM
  	map_kernel_page(PKMAP_BASE, 0, __pgprot(0));	/* XXX gross */
  	pkmap_page_table = virt_to_kpte(PKMAP_BASE);
++<<<<<<< HEAD
 +
 +	kmap_pte = virt_to_kpte(__fix_to_virt(FIX_KMAP_BEGIN));
 +	kmap_prot = PAGE_KERNEL;
++=======
++>>>>>>> 47da42b27a56 (powerpc/mm/highmem: Switch to generic kmap atomic)
  #endif /* CONFIG_HIGHMEM */
  
  	printk(KERN_DEBUG "Top of RAM: 0x%llx, Total RAM: 0x%llx\n",
* Unmerged path arch/powerpc/include/asm/kmap_types.h
* Unmerged path arch/powerpc/mm/highmem.c
diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index bdca42482d27..10c4df6e3e91 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -410,6 +410,7 @@ menu "Kernel options"
 config HIGHMEM
 	bool "High memory support"
 	depends on PPC32
+	select KMAP_LOCAL
 
 source kernel/Kconfig.hz
 source kernel/Kconfig.preempt
diff --git a/arch/powerpc/include/asm/fixmap.h b/arch/powerpc/include/asm/fixmap.h
index 8cccd0bf76e2..9c7927a7c5c4 100644
--- a/arch/powerpc/include/asm/fixmap.h
+++ b/arch/powerpc/include/asm/fixmap.h
@@ -20,7 +20,7 @@
 #include <asm/pgtable.h>
 #ifdef CONFIG_HIGHMEM
 #include <linux/threads.h>
-#include <asm/kmap_types.h>
+#include <asm/kmap_size.h>
 #endif
 
 #define FIXADDR_TOP	((unsigned long)(-PAGE_SIZE))
@@ -50,7 +50,7 @@ enum fixed_addresses {
 	FIX_EARLY_DEBUG_BASE = FIX_EARLY_DEBUG_TOP+((128*1024)/PAGE_SIZE)-1,
 #ifdef CONFIG_HIGHMEM
 	FIX_KMAP_BEGIN,	/* reserved pte's for temporary kernel mappings */
-	FIX_KMAP_END = FIX_KMAP_BEGIN+(KM_TYPE_NR*NR_CPUS)-1,
+	FIX_KMAP_END = FIX_KMAP_BEGIN + (KM_MAX_IDX * NR_CPUS) - 1,
 #endif
 #ifdef CONFIG_PPC_8xx
 	/* For IMMR we need an aligned 512K area */
* Unmerged path arch/powerpc/include/asm/highmem.h
* Unmerged path arch/powerpc/include/asm/kmap_types.h
diff --git a/arch/powerpc/mm/Makefile b/arch/powerpc/mm/Makefile
index 990e1204c32a..13975ab8ae87 100644
--- a/arch/powerpc/mm/Makefile
+++ b/arch/powerpc/mm/Makefile
@@ -28,7 +28,6 @@ ifdef CONFIG_HUGETLB_PAGE
 obj-$(CONFIG_PPC_BOOK3E_MMU)	+= hugetlbpage-book3e.o
 endif
 obj-$(CONFIG_NOT_COHERENT_CACHE) += dma-noncoherent.o
-obj-$(CONFIG_HIGHMEM)		+= highmem.o
 obj-$(CONFIG_PPC_COPRO_BASE)	+= copro_fault.o
 obj-$(CONFIG_PPC_PTDUMP)	+= dump_linuxpagetables.o
 obj-$(CONFIG_PPC_HTDUMP)	+= dump_hashpagetable.o
* Unmerged path arch/powerpc/mm/highmem.c
* Unmerged path arch/powerpc/mm/mem.c
