exec: Rename the flag called_exec_mmap point_of_no_return

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Eric W. Biederman <ebiederm@xmission.com>
commit 1507b7a30ad284a2a136ee79c214c0e86c62da64
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/1507b7a3.failed

Update the comments and make the code easier to understand by
renaming this flag.

	Reviewed-by: Kees Cook <keescook@chromium.org>
	Reviewed-by: Greg Ungerer <gerg@linux-m68k.org>
	Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
(cherry picked from commit 1507b7a30ad284a2a136ee79c214c0e86c62da64)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	fs/exec.c
#	include/linux/binfmts.h
diff --cc fs/exec.c
index 671dee5c3348,71de9f57ae09..000000000000
--- a/fs/exec.c
+++ b/fs/exec.c
@@@ -1293,11 -1326,12 +1293,20 @@@ int flush_old_exec(struct linux_binprm 
  		goto out;
  
  	/*
++<<<<<<< HEAD
 +	 * After clearing bprm->mm (to mark that current is using the
 +	 * prepared mm now), we have nothing left of the original
 +	 * process. If anything from here on returns an error, the check
 +	 * in search_binary_handler() will SEGV current.
 +	 */
++=======
+ 	 * With the new mm installed it is completely impossible to
+ 	 * fail and return to the original process.  If anything from
+ 	 * here on returns an error, the check in
+ 	 * search_binary_handler() will SEGV current.
+ 	 */
+ 	bprm->point_of_no_return = true;
++>>>>>>> 1507b7a30ad2 (exec: Rename the flag called_exec_mmap point_of_no_return)
  	bprm->mm = NULL;
  
  #ifdef CONFIG_POSIX_TIMERS
@@@ -1684,10 -1720,10 +1693,14 @@@ int search_binary_handler(struct linux_
  
  		read_lock(&binfmt_lock);
  		put_binfmt(fmt);
++<<<<<<< HEAD
 +		if (retval < 0 && !bprm->mm) {
++=======
+ 		if (retval < 0 && bprm->point_of_no_return) {
++>>>>>>> 1507b7a30ad2 (exec: Rename the flag called_exec_mmap point_of_no_return)
  			/* we got to flush_old_exec() and failed after it */
  			read_unlock(&binfmt_lock);
 -			force_sigsegv(SIGSEGV);
 +			force_sigsegv(SIGSEGV, current);
  			return retval;
  		}
  		if (retval != -ENOEXEC || !bprm->file) {
diff --cc include/linux/binfmts.h
index 8c12228326b0,8f479dad7931..000000000000
--- a/include/linux/binfmts.h
+++ b/include/linux/binfmts.h
@@@ -44,7 -44,12 +44,16 @@@ struct linux_binprm 
  		 * exec has happened. Used to sanitize execution environment
  		 * and to set AT_SECURE auxv for glibc.
  		 */
++<<<<<<< HEAD
 +		secureexec:1;
++=======
+ 		secureexec:1,
+ 		/*
+ 		 * Set when errors can no longer be returned to the
+ 		 * original userspace.
+ 		 */
+ 		point_of_no_return:1;
++>>>>>>> 1507b7a30ad2 (exec: Rename the flag called_exec_mmap point_of_no_return)
  #ifdef __alpha__
  	unsigned int taso:1;
  #endif
* Unmerged path fs/exec.c
* Unmerged path include/linux/binfmts.h
