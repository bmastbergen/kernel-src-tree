RDMA: Change ops->init_port to ops->port_groups

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Jason Gunthorpe <jgg@nvidia.com>
commit d7407d16699884817f3a93218e77b0801942362b
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/d7407d16.failed

init_port was only being used to register sysfs attributes against the
port kobject. Now that all users are creating static attribute_group's we
can simply set the attribute_group list in the ops and the core code can
just handle it directly.

This makes all the sysfs management quite straightforward and prevents any
driver from abusing the naked port kobject in future because no driver
code can access it.

Link: https://lore.kernel.org/r/114f68f3d921460eafe14cea5a80ca65d81729c3.1623427137.git.leonro@nvidia.com
	Signed-off-by: Leon Romanovsky <leonro@nvidia.com>
	Signed-off-by: Jason Gunthorpe <jgg@nvidia.com>
(cherry picked from commit d7407d16699884817f3a93218e77b0801942362b)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/infiniband/core/device.c
#	drivers/infiniband/core/sysfs.c
#	drivers/infiniband/hw/hfi1/hfi.h
#	drivers/infiniband/hw/hfi1/sysfs.c
#	drivers/infiniband/hw/qib/qib.h
#	drivers/infiniband/hw/qib/qib_sysfs.c
#	include/rdma/ib_sysfs.h
#	include/rdma/ib_verbs.h
diff --cc drivers/infiniband/core/device.c
index 0379573534a3,2cbd77933ea5..000000000000
--- a/drivers/infiniband/core/device.c
+++ b/drivers/infiniband/core/device.c
@@@ -2656,8 -2668,6 +2656,11 @@@ void ib_set_device_ops(struct ib_devic
  	SET_DEVICE_OP(dev_ops, get_vf_config);
  	SET_DEVICE_OP(dev_ops, get_vf_guid);
  	SET_DEVICE_OP(dev_ops, get_vf_stats);
++<<<<<<< HEAD
 +	SET_DEVICE_OP(dev_ops, init_port);
 +	SET_DEVICE_OP(dev_ops, invalidate_range);
++=======
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
  	SET_DEVICE_OP(dev_ops, iw_accept);
  	SET_DEVICE_OP(dev_ops, iw_add_ref);
  	SET_DEVICE_OP(dev_ops, iw_connect);
diff --cc drivers/infiniband/core/sysfs.c
index 1ae9eecb09be,09a2e1066df0..000000000000
--- a/drivers/infiniband/core/sysfs.c
+++ b/drivers/infiniband/core/sysfs.c
@@@ -120,9 -125,19 +120,22 @@@ static ssize_t port_attr_store(struct k
  
  	if (!port_attr->store)
  		return -EIO;
 -	return port_attr->store(p->ibdev, p->port_num, port_attr, buf, count);
 +	return port_attr->store(p, port_attr, buf, count);
  }
  
++<<<<<<< HEAD
++=======
+ struct ib_device *ib_port_sysfs_get_ibdev_kobj(struct kobject *kobj,
+ 					       u32 *port_num)
+ {
+ 	struct ib_port *port = container_of(kobj, struct ib_port, kobj);
+ 
+ 	*port_num = port->port_num;
+ 	return port->ibdev;
+ }
+ EXPORT_SYMBOL(ib_port_sysfs_get_ibdev_kobj);
+ 
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
  static const struct sysfs_ops port_sysfs_ops = {
  	.show	= port_attr_show,
  	.store	= port_attr_store
@@@ -1160,77 -1216,81 +1173,148 @@@ static int add_port(struct ib_core_devi
  
  	/*
  	 * If port == 0, it means hw_counters are per device and not per
 -	 * port, so holder should be device. Therefore skip per port
 -	 * counter initialization.
 +	 * port, so holder should be device. Therefore skip per port conunter
 +	 * initialization.
  	 */
++<<<<<<< HEAD
 +	if (device->ops.alloc_hw_stats && port_num && is_full_dev)
 +		setup_hw_stats(device, p, port_num);
++=======
+ 	if (port_num && is_full_dev) {
+ 		ret = setup_hw_port_stats(p, &p->groups[2]);
+ 		if (ret && ret != -EOPNOTSUPP)
+ 			goto err_put;
+ 		if (!ret)
+ 			*cur_group++ = &p->groups[2];
+ 	}
+ 
+ 	if (device->ops.process_mad && is_full_dev)
+ 		*cur_group++ = get_counter_table(device, port_num);
+ 
+ 	ret = kobject_add(&p->kobj, coredev->ports_kobj, "%d", port_num);
+ 	if (ret)
+ 		goto err_put;
+ 	ret = sysfs_create_groups(&p->kobj, p->groups_list);
+ 	if (ret)
+ 		goto err_del;
+ 	if (is_full_dev) {
+ 		ret = sysfs_create_groups(&p->kobj, device->ops.port_groups);
+ 		if (ret)
+ 			goto err_groups;
+ 	}
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
  
  	list_add_tail(&p->kobj.entry, &coredev->port_list);
  	if (device->port_data && is_full_dev)
  		device->port_data[port_num].sysfs = p;
  
 -	return p;
 +	kobject_uevent(&p->kobj, KOBJ_ADD);
 +	return 0;
 +
 +err_remove_pkey:
 +	if (p->pkey_group)
 +		sysfs_remove_group(&p->kobj, p->pkey_group);
 +
 +err_free_pkey:
 +	if (p->pkey_group) {
 +		for (i = 0; i < attr.pkey_tbl_len; ++i)
 +			kfree(p->pkey_group->attrs[i]);
  
 +		kfree(p->pkey_group->attrs);
 +		p->pkey_group->attrs = NULL;
 +	}
 +
 +err_free_pkey_group:
 +	kfree(p->pkey_group);
 +
 +err_remove_gid_type:
 +	sysfs_remove_group(&p->gid_attr_group->kobj,
 +			   &p->gid_attr_group->type);
 +
 +err_free_gid_type:
 +	for (i = 0; i < attr.gid_tbl_len; ++i)
 +		kfree(p->gid_attr_group->type.attrs[i]);
 +
 +	kfree(p->gid_attr_group->type.attrs);
 +	p->gid_attr_group->type.attrs = NULL;
 +
 +err_remove_gid_ndev:
 +	sysfs_remove_group(&p->gid_attr_group->kobj,
 +			   &p->gid_attr_group->ndev);
 +
 +err_free_gid_ndev:
 +	for (i = 0; i < attr.gid_tbl_len; ++i)
 +		kfree(p->gid_attr_group->ndev.attrs[i]);
 +
 +	kfree(p->gid_attr_group->ndev.attrs);
 +	p->gid_attr_group->ndev.attrs = NULL;
 +
 +err_remove_gid:
 +	sysfs_remove_group(&p->kobj, &p->gid_group);
 +
 +err_free_gid:
 +	for (i = 0; i < attr.gid_tbl_len; ++i)
 +		kfree(p->gid_group.attrs[i]);
 +
 +	kfree(p->gid_group.attrs);
 +	p->gid_group.attrs = NULL;
 +
 +err_remove_pma:
 +	if (p->pma_table)
 +		sysfs_remove_group(&p->kobj, p->pma_table);
 +
 +err_put_gid_attrs:
 +	kobject_put(&p->gid_attr_group->kobj);
 +
++<<<<<<< HEAD
 +err_put:
 +	kobject_put(&p->kobj);
 +	return ret;
++=======
+ err_groups:
+ 	sysfs_remove_groups(&p->kobj, p->groups_list);
+ err_del:
+ 	kobject_del(&p->kobj);
+ err_put:
+ 	kobject_put(&p->kobj);
+ 	return ERR_PTR(ret);
+ }
+ 
+ static void destroy_port(struct ib_core_device *coredev, struct ib_port *port)
+ {
+ 	bool is_full_dev = &port->ibdev->coredev == coredev;
+ 
+ 	if (port->ibdev->port_data &&
+ 	    port->ibdev->port_data[port->port_num].sysfs == port)
+ 		port->ibdev->port_data[port->port_num].sysfs = NULL;
+ 	list_del(&port->kobj.entry);
+ 	if (is_full_dev)
+ 		sysfs_remove_groups(&port->kobj, port->ibdev->ops.port_groups);
+ 	sysfs_remove_groups(&port->kobj, port->groups_list);
+ 	kobject_del(&port->kobj);
+ 	kobject_put(&port->kobj);
+ }
+ 
+ static const char *node_type_string(int node_type)
+ {
+ 	switch (node_type) {
+ 	case RDMA_NODE_IB_CA:
+ 		return "CA";
+ 	case RDMA_NODE_IB_SWITCH:
+ 		return "switch";
+ 	case RDMA_NODE_IB_ROUTER:
+ 		return "router";
+ 	case RDMA_NODE_RNIC:
+ 		return "RNIC";
+ 	case RDMA_NODE_USNIC:
+ 		return "usNIC";
+ 	case RDMA_NODE_USNIC_UDP:
+ 		return "usNIC UDP";
+ 	case RDMA_NODE_UNSPECIFIED:
+ 		return "unspecified";
+ 	}
+ 	return "<unknown>";
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
  }
  
  static ssize_t node_type_show(struct device *device,
@@@ -1338,24 -1391,8 +1422,29 @@@ void ib_free_port_attrs(struct ib_core_
  	list_for_each_entry_safe(p, t, &coredev->port_list, entry) {
  		struct ib_port *port = container_of(p, struct ib_port, kobj);
  
++<<<<<<< HEAD
 +		list_del(&p->entry);
 +		if (port->hw_stats_ag)
 +			free_hsag(&port->kobj, port->hw_stats_ag);
 +		kfree(port->hw_stats);
 +		if (device->port_data && is_full_dev)
 +			device->port_data[port->port_num].sysfs = NULL;
 +
 +		if (port->pma_table)
 +			sysfs_remove_group(p, port->pma_table);
 +		if (port->pkey_group)
 +			sysfs_remove_group(p, port->pkey_group);
 +		sysfs_remove_group(p, &port->gid_group);
 +		sysfs_remove_group(&port->gid_attr_group->kobj,
 +				   &port->gid_attr_group->ndev);
 +		sysfs_remove_group(&port->gid_attr_group->kobj,
 +				   &port->gid_attr_group->type);
 +		kobject_put(&port->gid_attr_group->kobj);
 +		kobject_put(p);
++=======
+ 		destroy_gid_attrs(port);
+ 		destroy_port(coredev, port);
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
  	}
  
  	kobject_put(coredev->ports_kobj);
@@@ -1364,7 -1401,7 +1453,11 @@@
  int ib_setup_port_attrs(struct ib_core_device *coredev)
  {
  	struct ib_device *device = rdma_device_to_ibdev(&coredev->dev);
++<<<<<<< HEAD
 +	unsigned int port;
++=======
+ 	u32 port_num;
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
  	int ret;
  
  	coredev->ports_kobj = kobject_create_and_add("ports",
@@@ -1372,12 -1409,24 +1465,25 @@@
  	if (!coredev->ports_kobj)
  		return -ENOMEM;
  
 -	rdma_for_each_port (device, port_num) {
 -		struct ib_port_attr attr;
 -		struct ib_port *port;
 -
 -		ret = ib_query_port(device, port_num, &attr);
 +	rdma_for_each_port (device, port) {
 +		ret = add_port(coredev, port);
  		if (ret)
  			goto err_put;
++<<<<<<< HEAD
++=======
+ 
+ 		port = setup_port(coredev, port_num, &attr);
+ 		if (IS_ERR(port)) {
+ 			ret = PTR_ERR(port);
+ 			goto err_put;
+ 		}
+ 
+ 		ret = setup_gid_attrs(port, &attr);
+ 		if (ret)
+ 			goto err_put;
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
  	}
 +
  	return 0;
  
  err_put:
diff --cc drivers/infiniband/hw/hfi1/hfi.h
index 4aba6416147b,5632ef4d159c..000000000000
--- a/drivers/infiniband/hw/hfi1/hfi.h
+++ b/drivers/infiniband/hw/hfi1/hfi.h
@@@ -2198,8 -2189,6 +2199,11 @@@ extern const struct attribute_group *hf
  int hfi1_device_create(struct hfi1_devdata *dd);
  void hfi1_device_remove(struct hfi1_devdata *dd);
  
++<<<<<<< HEAD
 +int hfi1_create_port_files(struct ib_device *ibdev, u8 port_num,
 +			   struct kobject *kobj);
++=======
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
  int hfi1_verbs_register_sysfs(struct hfi1_devdata *dd);
  void hfi1_verbs_unregister_sysfs(struct hfi1_devdata *dd);
  /* Hook for sysfs read of QSFP */
diff --cc drivers/infiniband/hw/hfi1/sysfs.c
index 074ec71772d2,acfcbedebe0d..000000000000
--- a/drivers/infiniband/hw/hfi1/sysfs.c
+++ b/drivers/infiniband/hw/hfi1/sysfs.c
@@@ -653,101 -599,13 +653,111 @@@ const struct attribute_group ib_hfi1_at
  	.attrs = hfi1_attributes,
  };
  
++<<<<<<< HEAD
 +int hfi1_create_port_files(struct ib_device *ibdev, u8 port_num,
 +			   struct kobject *kobj)
 +{
 +	struct hfi1_pportdata *ppd;
 +	struct hfi1_devdata *dd = dd_from_ibdev(ibdev);
 +	int ret;
 +
 +	if (!port_num || port_num > dd->num_pports) {
 +		dd_dev_err(dd,
 +			   "Skipping infiniband class with invalid port %u\n",
 +			   port_num);
 +		return -ENODEV;
 +	}
 +	ppd = &dd->pport[port_num - 1];
 +
 +	ret = kobject_init_and_add(&ppd->sc2vl_kobj, &hfi1_sc2vl_ktype, kobj,
 +				   "sc2vl");
 +	if (ret) {
 +		dd_dev_err(dd,
 +			   "Skipping sc2vl sysfs info, (err %d) port %u\n",
 +			   ret, port_num);
 +		/*
 +		 * Based on the documentation for kobject_init_and_add(), the
 +		 * caller should call kobject_put even if this call fails.
 +		 */
 +		goto bail_sc2vl;
 +	}
 +	kobject_uevent(&ppd->sc2vl_kobj, KOBJ_ADD);
 +
 +	ret = kobject_init_and_add(&ppd->sl2sc_kobj, &hfi1_sl2sc_ktype, kobj,
 +				   "sl2sc");
 +	if (ret) {
 +		dd_dev_err(dd,
 +			   "Skipping sl2sc sysfs info, (err %d) port %u\n",
 +			   ret, port_num);
 +		goto bail_sl2sc;
 +	}
 +	kobject_uevent(&ppd->sl2sc_kobj, KOBJ_ADD);
 +
 +	ret = kobject_init_and_add(&ppd->vl2mtu_kobj, &hfi1_vl2mtu_ktype, kobj,
 +				   "vl2mtu");
 +	if (ret) {
 +		dd_dev_err(dd,
 +			   "Skipping vl2mtu sysfs info, (err %d) port %u\n",
 +			   ret, port_num);
 +		goto bail_vl2mtu;
 +	}
 +	kobject_uevent(&ppd->vl2mtu_kobj, KOBJ_ADD);
 +
 +	ret = kobject_init_and_add(&ppd->pport_cc_kobj, &port_cc_ktype,
 +				   kobj, "CCMgtA");
 +	if (ret) {
 +		dd_dev_err(dd,
 +			   "Skipping Congestion Control sysfs info, (err %d) port %u\n",
 +			   ret, port_num);
 +		goto bail_cc;
 +	}
 +
 +	kobject_uevent(&ppd->pport_cc_kobj, KOBJ_ADD);
 +
 +	ret = sysfs_create_bin_file(&ppd->pport_cc_kobj, &cc_setting_bin_attr);
 +	if (ret) {
 +		dd_dev_err(dd,
 +			   "Skipping Congestion Control setting sysfs info, (err %d) port %u\n",
 +			   ret, port_num);
 +		goto bail_cc;
 +	}
 +
 +	ret = sysfs_create_bin_file(&ppd->pport_cc_kobj, &cc_table_bin_attr);
 +	if (ret) {
 +		dd_dev_err(dd,
 +			   "Skipping Congestion Control table sysfs info, (err %d) port %u\n",
 +			   ret, port_num);
 +		goto bail_cc_entry_bin;
 +	}
 +
 +	dd_dev_info(dd,
 +		    "Congestion Control Agent enabled for port %d\n",
 +		    port_num);
 +
 +	return 0;
 +
 +bail_cc_entry_bin:
 +	sysfs_remove_bin_file(&ppd->pport_cc_kobj,
 +			      &cc_setting_bin_attr);
 +bail_cc:
 +	kobject_put(&ppd->pport_cc_kobj);
 +bail_vl2mtu:
 +	kobject_put(&ppd->vl2mtu_kobj);
 +bail_sl2sc:
 +	kobject_put(&ppd->sl2sc_kobj);
 +bail_sc2vl:
 +	kobject_put(&ppd->sc2vl_kobj);
 +	return ret;
 +}
++=======
+ const struct attribute_group *hfi1_attr_port_groups[] = {
+ 	&port_cc_group,
+ 	&port_sc2vl_group,
+ 	&port_sl2sc_group,
+ 	&port_vl2mtu_group,
+ 	NULL,
+ };
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
  
  struct sde_attribute {
  	struct attribute attr;
@@@ -878,17 -735,4 +888,20 @@@ void hfi1_verbs_unregister_sysfs(struc
  	/* Unwind operations in hfi1_verbs_register_sysfs() */
  	for (i = 0; i < dd->num_sdma; i++)
  		kobject_put(&dd->per_sdma[i].kobj);
++<<<<<<< HEAD
 +
 +	for (i = 0; i < dd->num_pports; i++) {
 +		ppd = &dd->pport[i];
 +
 +		sysfs_remove_bin_file(&ppd->pport_cc_kobj,
 +				      &cc_setting_bin_attr);
 +		sysfs_remove_bin_file(&ppd->pport_cc_kobj,
 +				      &cc_table_bin_attr);
 +		kobject_put(&ppd->pport_cc_kobj);
 +		kobject_put(&ppd->vl2mtu_kobj);
 +		kobject_put(&ppd->sl2sc_kobj);
 +		kobject_put(&ppd->sc2vl_kobj);
 +	}
++=======
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
  }
diff --cc drivers/infiniband/hw/qib/qib.h
index 2350ad3c0ec2,9363bccfc6e7..000000000000
--- a/drivers/infiniband/hw/qib/qib.h
+++ b/drivers/infiniband/hw/qib/qib.h
@@@ -1395,9 -1366,6 +1396,12 @@@ extern const struct attribute_group *qi
  int qib_device_create(struct qib_devdata *);
  void qib_device_remove(struct qib_devdata *);
  
++<<<<<<< HEAD
 +int qib_create_port_files(struct ib_device *ibdev, u8 port_num,
 +			  struct kobject *kobj);
 +void qib_verbs_unregister_sysfs(struct qib_devdata *);
++=======
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
  /* Hook for sysfs read of QSFP */
  extern int qib_qsfp_dump(struct qib_pportdata *ppd, char *buf, int len);
  
diff --cc drivers/infiniband/hw/qib/qib_sysfs.c
index 3926be78036e,d57e49de6650..000000000000
--- a/drivers/infiniband/hw/qib/qib_sysfs.c
+++ b/drivers/infiniband/hw/qib/qib_sysfs.c
@@@ -547,6 -545,14 +547,17 @@@ static struct kobj_type qib_diagc_ktyp
  
  /* End diag_counters */
  
++<<<<<<< HEAD
++=======
+ const struct attribute_group *qib_attr_port_groups[] = {
+ 	&port_linkcontrol_group,
+ 	&port_ccmgta_attribute_group,
+ 	&port_sl2vl_group,
+ 	&port_diagc_group,
+ 	NULL,
+ };
+ 
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
  /* end of per-port file structures and support code */
  
  /*
@@@ -731,124 -733,3 +742,127 @@@ static struct attribute *qib_attributes
  const struct attribute_group qib_attr_group = {
  	.attrs = qib_attributes,
  };
++<<<<<<< HEAD
 +
 +int qib_create_port_files(struct ib_device *ibdev, u8 port_num,
 +			  struct kobject *kobj)
 +{
 +	struct qib_pportdata *ppd;
 +	struct qib_devdata *dd = dd_from_ibdev(ibdev);
 +	int ret;
 +
 +	if (!port_num || port_num > dd->num_pports) {
 +		qib_dev_err(dd,
 +			"Skipping infiniband class with invalid port %u\n",
 +			port_num);
 +		ret = -ENODEV;
 +		goto bail;
 +	}
 +	ppd = &dd->pport[port_num - 1];
 +
 +	ret = kobject_init_and_add(&ppd->pport_kobj, &qib_port_ktype, kobj,
 +				   "linkcontrol");
 +	if (ret) {
 +		qib_dev_err(dd,
 +			"Skipping linkcontrol sysfs info, (err %d) port %u\n",
 +			ret, port_num);
 +		goto bail;
 +	}
 +	kobject_uevent(&ppd->pport_kobj, KOBJ_ADD);
 +
 +	ret = kobject_init_and_add(&ppd->sl2vl_kobj, &qib_sl2vl_ktype, kobj,
 +				   "sl2vl");
 +	if (ret) {
 +		qib_dev_err(dd,
 +			"Skipping sl2vl sysfs info, (err %d) port %u\n",
 +			ret, port_num);
 +		goto bail_link;
 +	}
 +	kobject_uevent(&ppd->sl2vl_kobj, KOBJ_ADD);
 +
 +	ret = kobject_init_and_add(&ppd->diagc_kobj, &qib_diagc_ktype, kobj,
 +				   "diag_counters");
 +	if (ret) {
 +		qib_dev_err(dd,
 +			"Skipping diag_counters sysfs info, (err %d) port %u\n",
 +			ret, port_num);
 +		goto bail_sl;
 +	}
 +	kobject_uevent(&ppd->diagc_kobj, KOBJ_ADD);
 +
 +	if (!qib_cc_table_size || !ppd->congestion_entries_shadow)
 +		return 0;
 +
 +	ret = kobject_init_and_add(&ppd->pport_cc_kobj, &qib_port_cc_ktype,
 +				kobj, "CCMgtA");
 +	if (ret) {
 +		qib_dev_err(dd,
 +		 "Skipping Congestion Control sysfs info, (err %d) port %u\n",
 +		 ret, port_num);
 +		goto bail_diagc;
 +	}
 +
 +	kobject_uevent(&ppd->pport_cc_kobj, KOBJ_ADD);
 +
 +	ret = sysfs_create_bin_file(&ppd->pport_cc_kobj,
 +				&cc_setting_bin_attr);
 +	if (ret) {
 +		qib_dev_err(dd,
 +		 "Skipping Congestion Control setting sysfs info, (err %d) port %u\n",
 +		 ret, port_num);
 +		goto bail_cc;
 +	}
 +
 +	ret = sysfs_create_bin_file(&ppd->pport_cc_kobj,
 +				&cc_table_bin_attr);
 +	if (ret) {
 +		qib_dev_err(dd,
 +		 "Skipping Congestion Control table sysfs info, (err %d) port %u\n",
 +		 ret, port_num);
 +		goto bail_cc_entry_bin;
 +	}
 +
 +	qib_devinfo(dd->pcidev,
 +		"IB%u: Congestion Control Agent enabled for port %d\n",
 +		dd->unit, port_num);
 +
 +	return 0;
 +
 +bail_cc_entry_bin:
 +	sysfs_remove_bin_file(&ppd->pport_cc_kobj, &cc_setting_bin_attr);
 +bail_cc:
 +	kobject_put(&ppd->pport_cc_kobj);
 +bail_diagc:
 +	kobject_put(&ppd->diagc_kobj);
 +bail_sl:
 +	kobject_put(&ppd->sl2vl_kobj);
 +bail_link:
 +	kobject_put(&ppd->pport_kobj);
 +bail:
 +	return ret;
 +}
 +
 +/*
 + * Unregister and remove our files in /sys/class/infiniband.
 + */
 +void qib_verbs_unregister_sysfs(struct qib_devdata *dd)
 +{
 +	struct qib_pportdata *ppd;
 +	int i;
 +
 +	for (i = 0; i < dd->num_pports; i++) {
 +		ppd = &dd->pport[i];
 +		if (qib_cc_table_size &&
 +			ppd->congestion_entries_shadow) {
 +			sysfs_remove_bin_file(&ppd->pport_cc_kobj,
 +				&cc_setting_bin_attr);
 +			sysfs_remove_bin_file(&ppd->pport_cc_kobj,
 +				&cc_table_bin_attr);
 +			kobject_put(&ppd->pport_cc_kobj);
 +		}
 +		kobject_put(&ppd->sl2vl_kobj);
 +		kobject_put(&ppd->pport_kobj);
 +	}
 +}
++=======
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
diff --cc include/rdma/ib_verbs.h
index bfcbec0959ce,303471585dde..000000000000
--- a/include/rdma/ib_verbs.h
+++ b/include/rdma/ib_verbs.h
@@@ -2543,13 -2547,8 +2545,18 @@@ struct ib_device_ops 
  	 *   one given in index at their option
  	 */
  	int (*get_hw_stats)(struct ib_device *device,
++<<<<<<< HEAD
 +			    struct rdma_hw_stats *stats, u8 port, int index);
 +	/*
 +	 * This function is called once for each port when a ib device is
 +	 * registered.
 +	 */
 +	int (*init_port)(struct ib_device *device, u8 port_num,
 +			 struct kobject *port_sysfs);
++=======
+ 			    struct rdma_hw_stats *stats, u32 port, int index);
+ 
++>>>>>>> d7407d166998 (RDMA: Change ops->init_port to ops->port_groups)
  	/**
  	 * Allows rdma drivers to add their own restrack attributes.
  	 */
* Unmerged path include/rdma/ib_sysfs.h
* Unmerged path drivers/infiniband/core/device.c
* Unmerged path drivers/infiniband/core/sysfs.c
* Unmerged path drivers/infiniband/hw/hfi1/hfi.h
* Unmerged path drivers/infiniband/hw/hfi1/sysfs.c
diff --git a/drivers/infiniband/hw/hfi1/verbs.c b/drivers/infiniband/hw/hfi1/verbs.c
index 0dd4bb0a5a7e..5c6232aa9c1c 100644
--- a/drivers/infiniband/hw/hfi1/verbs.c
+++ b/drivers/infiniband/hw/hfi1/verbs.c
@@ -1791,8 +1791,8 @@ static const struct ib_device_ops hfi1_dev_ops = {
 	.alloc_rdma_netdev = hfi1_vnic_alloc_rn,
 	.get_dev_fw_str = hfi1_get_dev_fw_str,
 	.get_hw_stats = get_hw_stats,
-	.init_port = hfi1_create_port_files,
 	.modify_device = modify_device,
+	.port_groups = hfi1_attr_port_groups,
 	/* keep process mad in the driver */
 	.process_mad = hfi1_process_mad,
 	.rdma_netdev_get_params = hfi1_ipoib_rn_get_params,
* Unmerged path drivers/infiniband/hw/qib/qib.h
* Unmerged path drivers/infiniband/hw/qib/qib_sysfs.c
diff --git a/drivers/infiniband/hw/qib/qib_verbs.c b/drivers/infiniband/hw/qib/qib_verbs.c
index e388c8ace92c..1f5675f5e611 100644
--- a/drivers/infiniband/hw/qib/qib_verbs.c
+++ b/drivers/infiniband/hw/qib/qib_verbs.c
@@ -1484,7 +1484,7 @@ static const struct ib_device_ops qib_dev_ops = {
 	.owner = THIS_MODULE,
 	.driver_id = RDMA_DRIVER_QIB,
 
-	.init_port = qib_create_port_files,
+	.port_groups = qib_attr_port_groups,
 	.modify_device = qib_modify_device,
 	.process_mad = qib_process_mad,
 };
@@ -1646,8 +1646,6 @@ void qib_unregister_ib_device(struct qib_devdata *dd)
 {
 	struct qib_ibdev *dev = &dd->verbs_dev;
 
-	qib_verbs_unregister_sysfs(dd);
-
 	rvt_unregister_device(&dd->verbs_dev.rdi);
 
 	if (!list_empty(&dev->piowait))
diff --git a/drivers/infiniband/sw/rdmavt/vt.c b/drivers/infiniband/sw/rdmavt/vt.c
index 8fd0128a9336..302594017dbd 100644
--- a/drivers/infiniband/sw/rdmavt/vt.c
+++ b/drivers/infiniband/sw/rdmavt/vt.c
@@ -432,7 +432,7 @@ static noinline int check_support(struct rvt_dev_info *rdi, int verb)
 		 * These functions are not part of verbs specifically but are
 		 * required for rdmavt to function.
 		 */
-		if ((!rdi->ibdev.ops.init_port) ||
+		if ((!rdi->ibdev.ops.port_groups) ||
 		    (!rdi->driver_f.get_pci_dev))
 			return -EINVAL;
 		break;
* Unmerged path include/rdma/ib_sysfs.h
* Unmerged path include/rdma/ib_verbs.h
