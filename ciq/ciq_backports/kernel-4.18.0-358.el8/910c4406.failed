iommu: Add a map_pages() op for IOMMU drivers

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Isaac J. Manjarres <isaacm@codeaurora.org>
commit 910c4406ccc9613de0a54abf910edc4bf8a575c0
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/910c4406.failed

Add a callback for IOMMU drivers to provide a path for the
IOMMU framework to call into an IOMMU driver, which can
call into the io-pgtable code, to map a physically contiguous
rnage of pages of the same size.

For IOMMU drivers that do not specify a map_pages() callback,
the existing logic of mapping memory one page block at a time
will be used.

	Signed-off-by: Isaac J. Manjarres <isaacm@codeaurora.org>
	Suggested-by: Will Deacon <will@kernel.org>
	Acked-by: Lu Baolu <baolu.lu@linux.intel.com>
	Signed-off-by: Georgi Djakov <quic_c_gdjako@quicinc.com>
Link: https://lore.kernel.org/r/1623850736-389584-5-git-send-email-quic_c_gdjako@quicinc.com
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 910c4406ccc9613de0a54abf910edc4bf8a575c0)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/iommu.h
diff --cc include/linux/iommu.h
index 486407c90575,d7989d4a7404..000000000000
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@@ -223,7 -180,10 +223,9 @@@ struct iommu_iotlb_gather 
   * @attach_dev: attach device to an iommu domain
   * @detach_dev: detach device from an iommu domain
   * @map: map a physically contiguous memory region to an iommu domain
+  * @map_pages: map a physically contiguous set of pages of the same size to
+  *             an iommu domain.
   * @unmap: unmap a physically contiguous memory region from an iommu domain
 - * @unmap_pages: unmap a number of pages of the same size from an iommu domain
   * @flush_iotlb_all: Synchronously flush all hardware TLBs for this domain
   * @iotlb_sync_map: Sync mappings created recently using @map to the hardware
   * @iotlb_sync: Flush all queued ranges from the hardware TLBs and empty flush
@@@ -274,29 -230,29 +276,42 @@@ struct iommu_ops 
  
  	int (*attach_dev)(struct iommu_domain *domain, struct device *dev);
  	void (*detach_dev)(struct iommu_domain *domain, struct device *dev);
++<<<<<<< HEAD
 +	RH_KABI_BROKEN_REPLACE(int (*map)(struct iommu_domain *domain, unsigned long iova,\
 +					  phys_addr_t paddr, size_t size, int prot),\
 +			       int (*map)(struct iommu_domain *domain, unsigned long iova,\
 +					  phys_addr_t paddr, size_t size, int prot, gfp_t gfp))
 +	RH_KABI_BROKEN_REPLACE(size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,\
 +					       size_t size),size_t (*unmap)(struct iommu_domain *domain, unsigned long iova, \
 +									    size_t size, struct iommu_iotlb_gather *iotlb_gather))
++=======
+ 	int (*map)(struct iommu_domain *domain, unsigned long iova,
+ 		   phys_addr_t paddr, size_t size, int prot, gfp_t gfp);
+ 	int (*map_pages)(struct iommu_domain *domain, unsigned long iova,
+ 			 phys_addr_t paddr, size_t pgsize, size_t pgcount,
+ 			 int prot, gfp_t gfp, size_t *mapped);
+ 	size_t (*unmap)(struct iommu_domain *domain, unsigned long iova,
+ 		     size_t size, struct iommu_iotlb_gather *iotlb_gather);
+ 	size_t (*unmap_pages)(struct iommu_domain *domain, unsigned long iova,
+ 			      size_t pgsize, size_t pgcount,
+ 			      struct iommu_iotlb_gather *iotlb_gather);
++>>>>>>> 910c4406ccc9 (iommu: Add a map_pages() op for IOMMU drivers)
  	void (*flush_iotlb_all)(struct iommu_domain *domain);
 -	void (*iotlb_sync_map)(struct iommu_domain *domain, unsigned long iova,
 -			       size_t size);
 -	void (*iotlb_sync)(struct iommu_domain *domain,
 -			   struct iommu_iotlb_gather *iotlb_gather);
 +	RH_KABI_BROKEN_REPLACE(void (*iotlb_range_add)(struct iommu_domain *domain,\
 +						       unsigned long iova, size_t size), \
 +			       void (*iotlb_sync_map)(struct iommu_domain *domain, unsigned long iova,\
 +				       size_t size))
 +	RH_KABI_BROKEN_REPLACE(void (*iotlb_sync)(struct iommu_domain *domain),\
 +			       void (*iotlb_sync)(struct iommu_domain *domain, \
 +						  struct iommu_iotlb_gather *iotlb_gather))
  	phys_addr_t (*iova_to_phys)(struct iommu_domain *domain, dma_addr_t iova);
 -	struct iommu_device *(*probe_device)(struct device *dev);
 -	void (*release_device)(struct device *dev);
 -	void (*probe_finalize)(struct device *dev);
 +	RH_KABI_BROKEN_REMOVE(int (*add_device)(struct device *dev))
 +	RH_KABI_BROKEN_REMOVE(void (*remove_device)(struct device *dev))
  	struct iommu_group *(*device_group)(struct device *dev);
 -	int (*enable_nesting)(struct iommu_domain *domain);
 -	int (*set_pgtable_quirks)(struct iommu_domain *domain,
 -				  unsigned long quirks);
 +	int (*domain_get_attr)(struct iommu_domain *domain,
 +			       enum iommu_attr attr, void *data);
 +	int (*domain_set_attr)(struct iommu_domain *domain,
 +			       enum iommu_attr attr, void *data);
  
  	/* Request/Free a list of reserved regions for a device */
  	void (*get_resv_regions)(struct device *dev, struct list_head *list);
* Unmerged path include/linux/iommu.h
