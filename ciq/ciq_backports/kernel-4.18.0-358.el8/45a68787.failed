net: bridge: fix flags interpretation for extern learn fdb entries

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Aleksandrov <nikolay@nvidia.com>
commit 45a687879b31caae4032abd1c2402e289d2b8083
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/45a68787.failed

Ignore fdb flags when adding port extern learn entries and always set
BR_FDB_LOCAL flag when adding bridge extern learn entries. This is
closest to the behaviour we had before and avoids breaking any use cases
which were allowed.

This patch fixes iproute2 calls which assume NUD_PERMANENT and were
allowed before, example:
$ bridge fdb add 00:11:22:33:44:55 dev swp1 extern_learn

Extern learn entries are allowed to roam, but do not expire, so static
or dynamic flags make no sense for them.

Also add a comment for future reference.

Fixes: eb100e0e24a2 ("net: bridge: allow to add externally learned entries from user-space")
Fixes: 0541a6293298 ("net: bridge: validate the NUD_PERMANENT bit when adding an extern_learn FDB entry")
	Reviewed-by: Ido Schimmel <idosch@nvidia.com>
	Tested-by: Ido Schimmel <idosch@nvidia.com>
	Signed-off-by: Nikolay Aleksandrov <nikolay@nvidia.com>
	Reviewed-by: Vladimir Oltean <vladimir.oltean@nxp.com>
Link: https://lore.kernel.org/r/20210810110010.43859-1-razor@blackwall.org
	Signed-off-by: Jakub Kicinski <kuba@kernel.org>
(cherry picked from commit 45a687879b31caae4032abd1c2402e289d2b8083)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	net/bridge/br_fdb.c
diff --cc net/bridge/br_fdb.c
index 727e4c29f2d6,5dee30966ed3..000000000000
--- a/net/bridge/br_fdb.c
+++ b/net/bridge/br_fdb.c
@@@ -963,6 -1039,11 +963,14 @@@ static int __br_fdb_add(struct ndmsg *n
  		rcu_read_unlock();
  		local_bh_enable();
  	} else if (ndm->ndm_flags & NTF_EXT_LEARNED) {
++<<<<<<< HEAD
++=======
+ 		if (!p && !(ndm->ndm_state & NUD_PERMANENT)) {
+ 			NL_SET_ERR_MSG_MOD(extack,
+ 					   "FDB entry towards bridge must be permanent");
+ 			return -EINVAL;
+ 		}
++>>>>>>> 45a687879b31 (net: bridge: fix flags interpretation for extern learn fdb entries)
  		err = br_fdb_external_learn_add(br, p, addr, vid, true);
  	} else {
  		spin_lock_bh(&br->hash_lock);
@@@ -1189,6 -1289,10 +1197,13 @@@ int br_fdb_external_learn_add(struct ne
  
  		if (swdev_notify)
  			flags |= BIT(BR_FDB_ADDED_BY_USER);
++<<<<<<< HEAD
++=======
+ 
+ 		if (!p)
+ 			flags |= BIT(BR_FDB_LOCAL);
+ 
++>>>>>>> 45a687879b31 (net: bridge: fix flags interpretation for extern learn fdb entries)
  		fdb = fdb_create(br, p, addr, vid, flags);
  		if (!fdb) {
  			err = -ENOMEM;
@@@ -1215,6 -1319,9 +1230,12 @@@
  		if (swdev_notify)
  			set_bit(BR_FDB_ADDED_BY_USER, &fdb->flags);
  
++<<<<<<< HEAD
++=======
+ 		if (!p)
+ 			set_bit(BR_FDB_LOCAL, &fdb->flags);
+ 
++>>>>>>> 45a687879b31 (net: bridge: fix flags interpretation for extern learn fdb entries)
  		if (modified)
  			fdb_notify(br, fdb, RTM_NEWNEIGH, swdev_notify);
  	}
diff --git a/include/uapi/linux/neighbour.h b/include/uapi/linux/neighbour.h
index cd144e3099a3..8e25ac9e3344 100644
--- a/include/uapi/linux/neighbour.h
+++ b/include/uapi/linux/neighbour.h
@@ -64,8 +64,11 @@ enum {
 #define NUD_NONE	0x00
 
 /* NUD_NOARP & NUD_PERMANENT are pseudostates, they never change
-   and make no address resolution or NUD.
-   NUD_PERMANENT also cannot be deleted by garbage collectors.
+ * and make no address resolution or NUD.
+ * NUD_PERMANENT also cannot be deleted by garbage collectors.
+ * When NTF_EXT_LEARNED is set for a bridge fdb entry the different cache entry
+ * states don't make sense and thus are ignored. Such entries don't age and
+ * can roam.
  */
 
 struct nda_cacheinfo {
* Unmerged path net/bridge/br_fdb.c
