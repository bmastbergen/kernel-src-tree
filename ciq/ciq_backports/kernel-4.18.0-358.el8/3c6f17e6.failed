mm: vmscan: add per memcg shrinker nr_deferred

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Yang Shi <shy828301@gmail.com>
commit 3c6f17e6c5d048c8029578c475dd037dd5db58af
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/3c6f17e6.failed

Currently the number of deferred objects are per shrinker, but some
slabs, for example, vfs inode/dentry cache are per memcg, this would
result in poor isolation among memcgs.

The deferred objects typically are generated by __GFP_NOFS allocations,
one memcg with excessive __GFP_NOFS allocations may blow up deferred
objects, then other innocent memcgs may suffer from over shrink,
excessive reclaim latency, etc.

For example, two workloads run in memcgA and memcgB respectively,
workload in B is vfs heavy workload.  Workload in A generates excessive
deferred objects, then B's vfs cache might be hit heavily (drop half of
caches) by B's limit reclaim or global reclaim.

We observed this hit in our production environment which was running vfs
heavy workload shown as the below tracing log:

  <...>-409454 [016] .... 28286961.747146: mm_shrink_slab_start: super_cache_scan+0x0/0x1a0 ffff9a83046f3458:
  nid: 1 objects to shrink 3641681686040 gfp_flags GFP_HIGHUSER_MOVABLE|__GFP_ZERO pgs_scanned 1 lru_pgs 15721
  cache items 246404277 delta 31345 total_scan 123202138
  <...>-409454 [022] .... 28287105.928018: mm_shrink_slab_end: super_cache_scan+0x0/0x1a0 ffff9a83046f3458:
  nid: 1 unused scan count 3641681686040 new scan count 3641798379189 total_scan 602
  last shrinker return val 123186855

The vfs cache and page cache ratio was 10:1 on this machine, and half of
caches were dropped.  This also resulted in significant amount of page
caches were dropped due to inodes eviction.

Make nr_deferred per memcg for memcg aware shrinkers would solve the
unfairness and bring better isolation.

The following patch will add nr_deferred to parent memcg when memcg
offline.  To preserve nr_deferred when reparenting memcgs to root, root
memcg needs shrinker_info allocated too.

When memcg is not enabled (!CONFIG_MEMCG or memcg disabled), the
shrinker's nr_deferred would be used.  And non memcg aware shrinkers use
shrinker's nr_deferred all the time.

Link: https://lkml.kernel.org/r/20210311190845.9708-10-shy828301@gmail.com
	Signed-off-by: Yang Shi <shy828301@gmail.com>
	Acked-by: Roman Gushchin <guro@fb.com>
	Acked-by: Kirill Tkhai <ktkhai@virtuozzo.com>
	Reviewed-by: Shakeel Butt <shakeelb@google.com>
	Cc: Dave Chinner <david@fromorbit.com>
	Cc: Johannes Weiner <hannes@cmpxchg.org>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 3c6f17e6c5d048c8029578c475dd037dd5db58af)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	include/linux/memcontrol.h
#	mm/vmscan.c
diff --cc include/linux/memcontrol.h
index d53bb138ac39,32bd62047238..000000000000
--- a/include/linux/memcontrol.h
+++ b/include/linux/memcontrol.h
@@@ -110,12 -114,13 +110,17 @@@ struct batched_lruvec_stat 
  };
  
  /*
-  * Bitmap of shrinker::id corresponding to memcg-aware shrinkers,
-  * which have elements charged to this memcg.
+  * Bitmap and deferred work of shrinker::id corresponding to memcg-aware
+  * shrinkers, which have elements charged to this memcg.
   */
 -struct shrinker_info {
 +struct memcg_shrinker_map {
  	struct rcu_head rcu;
++<<<<<<< HEAD
 +	unsigned long RH_KABI_RENAME(map[0], map[]);
++=======
+ 	atomic_long_t *nr_deferred;
+ 	unsigned long *map;
++>>>>>>> 3c6f17e6c5d0 (mm: vmscan: add per memcg shrinker nr_deferred)
  };
  
  /*
diff --cc mm/vmscan.c
index 4e1f2a131616,db668c4c78f4..000000000000
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@@ -199,12 -193,26 +200,33 @@@ static inline int shrinker_map_size(in
  	return (DIV_ROUND_UP(nr_items, BITS_PER_LONG) * sizeof(unsigned long));
  }
  
++<<<<<<< HEAD
 +static int expand_one_shrinker_map(struct mem_cgroup *memcg,
 +				   int size, int old_size)
 +{
 +	struct memcg_shrinker_map *new, *old;
++=======
+ static inline int shrinker_defer_size(int nr_items)
+ {
+ 	return (round_up(nr_items, BITS_PER_LONG) * sizeof(atomic_long_t));
+ }
+ 
+ static struct shrinker_info *shrinker_info_protected(struct mem_cgroup *memcg,
+ 						     int nid)
+ {
+ 	return rcu_dereference_protected(memcg->nodeinfo[nid]->shrinker_info,
+ 					 lockdep_is_held(&shrinker_rwsem));
+ }
+ 
+ static int expand_one_shrinker_info(struct mem_cgroup *memcg,
+ 				    int map_size, int defer_size,
+ 				    int old_map_size, int old_defer_size)
+ {
+ 	struct shrinker_info *new, *old;
++>>>>>>> 3c6f17e6c5d0 (mm: vmscan: add per memcg shrinker nr_deferred)
  	struct mem_cgroup_per_node *pn;
  	int nid;
+ 	int size = map_size + defer_size;
  
  	for_each_node(nid) {
  		pn = memcg->nodeinfo[nid];
@@@ -217,67 -225,79 +239,87 @@@
  		if (!new)
  			return -ENOMEM;
  
- 		/* Set all old bits, clear all new bits */
- 		memset(new->map, (int)0xff, old_size);
- 		memset((void *)new->map + old_size, 0, size - old_size);
+ 		new->nr_deferred = (atomic_long_t *)(new + 1);
+ 		new->map = (void *)new->nr_deferred + defer_size;
+ 
+ 		/* map: set all old bits, clear all new bits */
+ 		memset(new->map, (int)0xff, old_map_size);
+ 		memset((void *)new->map + old_map_size, 0, map_size - old_map_size);
+ 		/* nr_deferred: copy old values, clear all new values */
+ 		memcpy(new->nr_deferred, old->nr_deferred, old_defer_size);
+ 		memset((void *)new->nr_deferred + old_defer_size, 0,
+ 		       defer_size - old_defer_size);
  
 -		rcu_assign_pointer(pn->shrinker_info, new);
 +		rcu_assign_pointer(pn->shrinker_map, new);
  		kvfree_rcu(old, rcu);
  	}
  
  	return 0;
  }
  
 -void free_shrinker_info(struct mem_cgroup *memcg)
 +void free_shrinker_maps(struct mem_cgroup *memcg)
  {
  	struct mem_cgroup_per_node *pn;
 -	struct shrinker_info *info;
 +	struct memcg_shrinker_map *map;
  	int nid;
  
- 	if (mem_cgroup_is_root(memcg))
- 		return;
- 
  	for_each_node(nid) {
  		pn = memcg->nodeinfo[nid];
 -		info = rcu_dereference_protected(pn->shrinker_info, true);
 -		kvfree(info);
 -		rcu_assign_pointer(pn->shrinker_info, NULL);
 +		map = rcu_dereference_protected(pn->shrinker_map, true);
 +		kvfree(map);
 +		rcu_assign_pointer(pn->shrinker_map, NULL);
  	}
  }
  
 -int alloc_shrinker_info(struct mem_cgroup *memcg)
 +int alloc_shrinker_maps(struct mem_cgroup *memcg)
  {
 -	struct shrinker_info *info;
 +	struct memcg_shrinker_map *map;
  	int nid, size, ret = 0;
- 
- 	if (mem_cgroup_is_root(memcg))
- 		return 0;
+ 	int map_size, defer_size = 0;
  
  	down_write(&shrinker_rwsem);
- 	size = shrinker_map_size(shrinker_nr_max);
+ 	map_size = shrinker_map_size(shrinker_nr_max);
+ 	defer_size = shrinker_defer_size(shrinker_nr_max);
+ 	size = map_size + defer_size;
  	for_each_node(nid) {
 -		info = kvzalloc_node(sizeof(*info) + size, GFP_KERNEL, nid);
 -		if (!info) {
 -			free_shrinker_info(memcg);
 +		map = kvzalloc_node(sizeof(*map) + size, GFP_KERNEL, nid);
 +		if (!map) {
 +			free_shrinker_maps(memcg);
  			ret = -ENOMEM;
  			break;
  		}
++<<<<<<< HEAD
 +		rcu_assign_pointer(memcg->nodeinfo[nid]->shrinker_map, map);
++=======
+ 		info->nr_deferred = (atomic_long_t *)(info + 1);
+ 		info->map = (void *)info->nr_deferred + defer_size;
+ 		rcu_assign_pointer(memcg->nodeinfo[nid]->shrinker_info, info);
++>>>>>>> 3c6f17e6c5d0 (mm: vmscan: add per memcg shrinker nr_deferred)
  	}
  	up_write(&shrinker_rwsem);
  
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int expand_shrinker_maps(int new_id)
++=======
+ static inline bool need_expand(int nr_max)
  {
- 	int size, old_size, ret = 0;
+ 	return round_up(nr_max, BITS_PER_LONG) >
+ 	       round_up(shrinker_nr_max, BITS_PER_LONG);
+ }
+ 
+ static int expand_shrinker_info(int new_id)
++>>>>>>> 3c6f17e6c5d0 (mm: vmscan: add per memcg shrinker nr_deferred)
+ {
+ 	int ret = 0;
  	int new_nr_max = new_id + 1;
+ 	int map_size, defer_size = 0;
+ 	int old_map_size, old_defer_size = 0;
  	struct mem_cgroup *memcg;
  
- 	size = shrinker_map_size(new_nr_max);
- 	old_size = shrinker_map_size(shrinker_nr_max);
- 	if (size <= old_size)
+ 	if (!need_expand(new_nr_max))
  		goto out;
  
  	if (!root_mem_cgroup)
@@@ -285,11 -305,15 +327,21 @@@
  
  	lockdep_assert_held(&shrinker_rwsem);
  
+ 	map_size = shrinker_map_size(new_nr_max);
+ 	defer_size = shrinker_defer_size(new_nr_max);
+ 	old_map_size = shrinker_map_size(shrinker_nr_max);
+ 	old_defer_size = shrinker_defer_size(shrinker_nr_max);
+ 
  	memcg = mem_cgroup_iter(NULL, NULL, NULL);
  	do {
++<<<<<<< HEAD
 +		if (mem_cgroup_is_root(memcg))
 +			continue;
 +		ret = expand_one_shrinker_map(memcg, size, old_size);
++=======
+ 		ret = expand_one_shrinker_info(memcg, map_size, defer_size,
+ 					       old_map_size, old_defer_size);
++>>>>>>> 3c6f17e6c5d0 (mm: vmscan: add per memcg shrinker nr_deferred)
  		if (ret) {
  			mem_cgroup_iter_break(NULL, memcg);
  			goto out;
* Unmerged path include/linux/memcontrol.h
* Unmerged path mm/vmscan.c
