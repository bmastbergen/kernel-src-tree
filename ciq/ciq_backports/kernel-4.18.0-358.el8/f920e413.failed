mm: track mmu notifiers in fs_reclaim_acquire/release

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Daniel Vetter <daniel.vetter@ffwll.ch>
commit f920e413ff9c33c297c0bde7cc5fe8cd736112e2
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/f920e413.failed

fs_reclaim_acquire/release nicely catch recursion issues when allocating
GFP_KERNEL memory against shrinkers (which gpu drivers tend to use to keep
the excessive caches in check).  For mmu notifier recursions we do have
lockdep annotations since 23b68395c7c7 ("mm/mmu_notifiers: add a lockdep
map for invalidate_range_start/end").

But these only fire if a path actually results in some pte invalidation -
for most small allocations that's very rarely the case.  The other trouble
is that pte invalidation can happen any time when __GFP_RECLAIM is set.
Which means only really GFP_ATOMIC is a safe choice, GFP_NOIO isn't good
enough to avoid potential mmu notifier recursion.

I was pondering whether we should just do the general annotation, but
there's always the risk for false positives.  Plus I'm assuming that the
core fs and io code is a lot better reviewed and tested than random mmu
notifier code in drivers.  Hence why I decide to only annotate for that
specific case.

Furthermore even if we'd create a lockdep map for direct reclaim, we'd
still need to explicit pull in the mmu notifier map - there's a lot more
places that do pte invalidation than just direct reclaim, these two
contexts arent the same.

Note that the mmu notifiers needing their own independent lockdep map is
also the reason we can't hold them from fs_reclaim_acquire to
fs_reclaim_release - it would nest with the acquistion in the pte
invalidation code, causing a lockdep splat.  And we can't remove the
annotations from pte invalidation and all the other places since they're
called from many other places than page reclaim.  Hence we can only do the
equivalent of might_lock, but on the raw lockdep map.

With this we can also remove the lockdep priming added in 66204f1d2d1b
("mm/mmu_notifiers: prime lockdep") since the new annotations are strictly
more powerful.

Link: https://lkml.kernel.org/r/20201125162532.1299794-2-daniel.vetter@ffwll.ch
	Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
	Reviewed-by: Jason Gunthorpe <jgg@nvidia.com>
	Cc: Dave Chinner <david@fromorbit.com>
	Cc: Qian Cai <cai@lca.pw>
	Cc: Thomas Hellström (Intel) <thomas_os@shipmail.org>
	Cc: Jason Gunthorpe <jgg@mellanox.com>
	Cc: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
	Cc: Christian König <christian.koenig@amd.com>
	Cc: "Matthew Wilcox (Oracle)" <willy@infradead.org>
	Cc: Christoph Lameter <cl@linux.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Ingo Molnar <mingo@kernel.org>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
	Cc: Michel Lespinasse <walken@google.com>
	Cc: Paul E. McKenney <paulmck@kernel.org>
	Cc: Pekka Enberg <penberg@kernel.org>
	Cc: Peter Zijlstra (Intel) <peterz@infradead.org>
	Cc: Randy Dunlap <rdunlap@infradead.org>
	Cc: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
	Cc: Thomas Gleixner <tglx@linutronix.de>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Cc: Waiman Long <longman@redhat.com>
	Cc: Will Deacon <will@kernel.org>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit f920e413ff9c33c297c0bde7cc5fe8cd736112e2)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/mmu_notifier.c
diff --cc mm/mmu_notifier.c
index 4361d699fa34,61ee40ed804e..000000000000
--- a/mm/mmu_notifier.c
+++ b/mm/mmu_notifier.c
@@@ -577,34 -612,23 +577,38 @@@ int __mmu_notifier_register(struct mmu_
  	mmap_assert_write_locked(mm);
  	BUG_ON(atomic_read(&mm->mm_users) <= 0);
  
++<<<<<<< HEAD
 +	if (mn) {
 +		mn->_rh = kmalloc(sizeof(*mn->_rh), GFP_KERNEL);
 +		if (!mn->_rh) {
 +			return -ENOMEM;
 +		}
 +		mn->_rh->back_ptr = mn;
 +		RH_KABI_AUX_SET_SIZE(mn, mmu_notifier);
 +	}
 +
 +	if (!mm->mmu_notifier_mm) {
++=======
+ 	if (!mm->notifier_subscriptions) {
++>>>>>>> f920e413ff9c (mm: track mmu notifiers in fs_reclaim_acquire/release)
  		/*
  		 * kmalloc cannot be called under mm_take_all_locks(), but we
 -		 * know that mm->notifier_subscriptions can't change while we
 -		 * hold the write side of the mmap_lock.
 +		 * know that mm->mmu_notifier_mm can't change while we hold
 +		 * the write side of the mmap_sem.
  		 */
 -		subscriptions = kzalloc(
 -			sizeof(struct mmu_notifier_subscriptions), GFP_KERNEL);
 -		if (!subscriptions)
 -			return -ENOMEM;
 +		mmu_notifier_mm =
 +			kzalloc(sizeof(struct mmu_notifier_mm), GFP_KERNEL);
 +		if (!mmu_notifier_mm) {
 +			ret = -ENOMEM;
 +			goto out_free_rh;
 +		}
  
 -		INIT_HLIST_HEAD(&subscriptions->list);
 -		spin_lock_init(&subscriptions->lock);
 -		subscriptions->invalidate_seq = 2;
 -		subscriptions->itree = RB_ROOT_CACHED;
 -		init_waitqueue_head(&subscriptions->wq);
 -		INIT_HLIST_HEAD(&subscriptions->deferred_list);
 +		INIT_HLIST_HEAD(&mmu_notifier_mm->list);
 +		spin_lock_init(&mmu_notifier_mm->lock);
 +		mmu_notifier_mm->invalidate_seq = 2;
 +		mmu_notifier_mm->itree = RB_ROOT_CACHED;
 +		init_waitqueue_head(&mmu_notifier_mm->wq);
 +		INIT_HLIST_HEAD(&mmu_notifier_mm->deferred_list);
  	}
  
  	ret = mm_take_all_locks(mm);
* Unmerged path mm/mmu_notifier.c
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index fc1a06c816f3..dbea512d4141 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -59,6 +59,7 @@
 #include <trace/events/oom.h>
 #include <linux/prefetch.h>
 #include <linux/mm_inline.h>
+#include <linux/mmu_notifier.h>
 #include <linux/migrate.h>
 #include <linux/hugetlb.h>
 #include <linux/sched/rt.h>
@@ -4254,10 +4255,8 @@ should_compact_retry(struct alloc_context *ac, unsigned int order, int alloc_fla
 static struct lockdep_map __fs_reclaim_map =
 	STATIC_LOCKDEP_MAP_INIT("fs_reclaim", &__fs_reclaim_map);
 
-static bool __need_fs_reclaim(gfp_t gfp_mask)
+static bool __need_reclaim(gfp_t gfp_mask)
 {
-	gfp_mask = current_gfp_context(gfp_mask);
-
 	/* no reclaim without waiting on it */
 	if (!(gfp_mask & __GFP_DIRECT_RECLAIM))
 		return false;
@@ -4266,10 +4265,6 @@ static bool __need_fs_reclaim(gfp_t gfp_mask)
 	if (current->flags & PF_MEMALLOC)
 		return false;
 
-	/* We're only interested __GFP_FS allocations for now */
-	if (!(gfp_mask & __GFP_FS))
-		return false;
-
 	if (gfp_mask & __GFP_NOLOCKDEP)
 		return false;
 
@@ -4288,15 +4283,29 @@ void __fs_reclaim_release(void)
 
 void fs_reclaim_acquire(gfp_t gfp_mask)
 {
-	if (__need_fs_reclaim(gfp_mask))
-		__fs_reclaim_acquire();
+	gfp_mask = current_gfp_context(gfp_mask);
+
+	if (__need_reclaim(gfp_mask)) {
+		if (gfp_mask & __GFP_FS)
+			__fs_reclaim_acquire();
+
+#ifdef CONFIG_MMU_NOTIFIER
+		lock_map_acquire(&__mmu_notifier_invalidate_range_start_map);
+		lock_map_release(&__mmu_notifier_invalidate_range_start_map);
+#endif
+
+	}
 }
 EXPORT_SYMBOL_GPL(fs_reclaim_acquire);
 
 void fs_reclaim_release(gfp_t gfp_mask)
 {
-	if (__need_fs_reclaim(gfp_mask))
-		__fs_reclaim_release();
+	gfp_mask = current_gfp_context(gfp_mask);
+
+	if (__need_reclaim(gfp_mask)) {
+		if (gfp_mask & __GFP_FS)
+			__fs_reclaim_release();
+	}
 }
 EXPORT_SYMBOL_GPL(fs_reclaim_release);
 #endif
