i2c: designware: Drop hard coded FIFO depth assignment

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Andy Shevchenko <andriy.shevchenko@linux.intel.com>
commit 3f35064a7cfef4ed8d25cdb16da0abfbbd525f63
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/3f35064a.failed

It's not clear why the commit fe20ff5c7e9c
  ("i2c-designware: Add support for Designware core behind PCI devices.")
followed by commit b61b14154b19
  ("i2c-designware: add support for Intel Lynxpoint")
chose to hard code FIFO depth size. The FIFO depth on all hardware,
I have tested on, can be nicely detected automatically.

Thus, we may safely drop hard coded FIFO sizes from the driver.

	Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
	Acked-by: Jarkko Nikula <jarkko.nikula@linux.intel.com>
	Signed-off-by: Wolfram Sang <wsa@kernel.org>
(cherry picked from commit 3f35064a7cfef4ed8d25cdb16da0abfbbd525f63)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/i2c/busses/i2c-designware-common.c
diff --cc drivers/i2c/busses/i2c-designware-common.c
index 37ca1ea69f2b,ed302342f8db..000000000000
--- a/drivers/i2c/busses/i2c-designware-common.c
+++ b/drivers/i2c/busses/i2c-designware-common.c
@@@ -116,6 -120,148 +116,151 @@@ int i2c_dw_set_reg_access(struct dw_i2c
  	return 0;
  }
  
++<<<<<<< HEAD
++=======
+ static const u32 supported_speeds[] = {
+ 	I2C_MAX_HIGH_SPEED_MODE_FREQ,
+ 	I2C_MAX_FAST_MODE_PLUS_FREQ,
+ 	I2C_MAX_FAST_MODE_FREQ,
+ 	I2C_MAX_STANDARD_MODE_FREQ,
+ };
+ 
+ int i2c_dw_validate_speed(struct dw_i2c_dev *dev)
+ {
+ 	struct i2c_timings *t = &dev->timings;
+ 	unsigned int i;
+ 
+ 	/*
+ 	 * Only standard mode at 100kHz, fast mode at 400kHz,
+ 	 * fast mode plus at 1MHz and high speed mode at 3.4MHz are supported.
+ 	 */
+ 	for (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {
+ 		if (t->bus_freq_hz == supported_speeds[i])
+ 			return 0;
+ 	}
+ 
+ 	dev_err(dev->dev,
+ 		"%d Hz is unsupported, only 100kHz, 400kHz, 1MHz and 3.4MHz are supported\n",
+ 		t->bus_freq_hz);
+ 
+ 	return -EINVAL;
+ }
+ EXPORT_SYMBOL_GPL(i2c_dw_validate_speed);
+ 
+ #ifdef CONFIG_ACPI
+ 
+ #include <linux/dmi.h>
+ 
+ /*
+  * The HCNT/LCNT information coming from ACPI should be the most accurate
+  * for given platform. However, some systems get it wrong. On such systems
+  * we get better results by calculating those based on the input clock.
+  */
+ static const struct dmi_system_id i2c_dw_no_acpi_params[] = {
+ 	{
+ 		.ident = "Dell Inspiron 7348",
+ 		.matches = {
+ 			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
+ 			DMI_MATCH(DMI_PRODUCT_NAME, "Inspiron 7348"),
+ 		},
+ 	},
+ 	{}
+ };
+ 
+ static void i2c_dw_acpi_params(struct device *device, char method[],
+ 			       u16 *hcnt, u16 *lcnt, u32 *sda_hold)
+ {
+ 	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
+ 	acpi_handle handle = ACPI_HANDLE(device);
+ 	union acpi_object *obj;
+ 
+ 	if (dmi_check_system(i2c_dw_no_acpi_params))
+ 		return;
+ 
+ 	if (ACPI_FAILURE(acpi_evaluate_object(handle, method, NULL, &buf)))
+ 		return;
+ 
+ 	obj = (union acpi_object *)buf.pointer;
+ 	if (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 3) {
+ 		const union acpi_object *objs = obj->package.elements;
+ 
+ 		*hcnt = (u16)objs[0].integer.value;
+ 		*lcnt = (u16)objs[1].integer.value;
+ 		*sda_hold = (u32)objs[2].integer.value;
+ 	}
+ 
+ 	kfree(buf.pointer);
+ }
+ 
+ int i2c_dw_acpi_configure(struct device *device)
+ {
+ 	struct dw_i2c_dev *dev = dev_get_drvdata(device);
+ 	struct i2c_timings *t = &dev->timings;
+ 	u32 ss_ht = 0, fp_ht = 0, hs_ht = 0, fs_ht = 0;
+ 
+ 	/*
+ 	 * Try to get SDA hold time and *CNT values from an ACPI method for
+ 	 * selected speed modes.
+ 	 */
+ 	i2c_dw_acpi_params(device, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt, &ss_ht);
+ 	i2c_dw_acpi_params(device, "FPCN", &dev->fp_hcnt, &dev->fp_lcnt, &fp_ht);
+ 	i2c_dw_acpi_params(device, "HSCN", &dev->hs_hcnt, &dev->hs_lcnt, &hs_ht);
+ 	i2c_dw_acpi_params(device, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt, &fs_ht);
+ 
+ 	switch (t->bus_freq_hz) {
+ 	case I2C_MAX_STANDARD_MODE_FREQ:
+ 		dev->sda_hold_time = ss_ht;
+ 		break;
+ 	case I2C_MAX_FAST_MODE_PLUS_FREQ:
+ 		dev->sda_hold_time = fp_ht;
+ 		break;
+ 	case I2C_MAX_HIGH_SPEED_MODE_FREQ:
+ 		dev->sda_hold_time = hs_ht;
+ 		break;
+ 	case I2C_MAX_FAST_MODE_FREQ:
+ 	default:
+ 		dev->sda_hold_time = fs_ht;
+ 		break;
+ 	}
+ 
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(i2c_dw_acpi_configure);
+ 
+ void i2c_dw_acpi_adjust_bus_speed(struct device *device)
+ {
+ 	struct dw_i2c_dev *dev = dev_get_drvdata(device);
+ 	struct i2c_timings *t = &dev->timings;
+ 	u32 acpi_speed;
+ 	int i;
+ 
+ 	acpi_speed = i2c_acpi_find_bus_speed(device);
+ 	/*
+ 	 * Some DSTDs use a non standard speed, round down to the lowest
+ 	 * standard speed.
+ 	 */
+ 	for (i = 0; i < ARRAY_SIZE(supported_speeds); i++) {
+ 		if (acpi_speed >= supported_speeds[i])
+ 			break;
+ 	}
+ 	acpi_speed = i < ARRAY_SIZE(supported_speeds) ? supported_speeds[i] : 0;
+ 
+ 	/*
+ 	 * Find bus speed from the "clock-frequency" device property, ACPI
+ 	 * or by using fast mode if neither is set.
+ 	 */
+ 	if (acpi_speed && t->bus_freq_hz)
+ 		t->bus_freq_hz = min(t->bus_freq_hz, acpi_speed);
+ 	else if (acpi_speed || t->bus_freq_hz)
+ 		t->bus_freq_hz = max(t->bus_freq_hz, acpi_speed);
+ 	else
+ 		t->bus_freq_hz = I2C_MAX_FAST_MODE_FREQ;
+ }
+ EXPORT_SYMBOL_GPL(i2c_dw_acpi_adjust_bus_speed);
+ 
+ #endif	/* CONFIG_ACPI */
+ 
++>>>>>>> 3f35064a7cfe (i2c: designware: Drop hard coded FIFO depth assignment)
  u32 i2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset)
  {
  	/*
* Unmerged path drivers/i2c/busses/i2c-designware-common.c
diff --git a/drivers/i2c/busses/i2c-designware-pcidrv.c b/drivers/i2c/busses/i2c-designware-pcidrv.c
index 3664d76bb976..11a5e4751eab 100644
--- a/drivers/i2c/busses/i2c-designware-pcidrv.c
+++ b/drivers/i2c/busses/i2c-designware-pcidrv.c
@@ -46,8 +46,6 @@ struct dw_scl_sda_cfg {
 
 struct dw_pci_controller {
 	u32 bus_num;
-	u32 tx_fifo_depth;
-	u32 rx_fifo_depth;
 	u32 flags;
 	struct dw_scl_sda_cfg *scl_sda_cfg;
 	int (*setup)(struct pci_dev *pdev, struct dw_pci_controller *c);
@@ -133,41 +131,29 @@ static u32 ehl_get_clk_rate_khz(struct dw_i2c_dev *dev)
 static struct dw_pci_controller dw_pci_controllers[] = {
 	[medfield] = {
 		.bus_num = -1,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
 		.setup = mfld_setup,
 		.get_clk_rate_khz = mfld_get_clk_rate_khz,
 	},
 	[merrifield] = {
 		.bus_num = -1,
-		.tx_fifo_depth = 64,
-		.rx_fifo_depth = 64,
 		.scl_sda_cfg = &mrfld_config,
 		.setup = mrfld_setup,
 	},
 	[baytrail] = {
 		.bus_num = -1,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
 		.scl_sda_cfg = &byt_config,
 	},
 	[haswell] = {
 		.bus_num = -1,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
 		.scl_sda_cfg = &hsw_config,
 	},
 	[cherrytrail] = {
 		.bus_num = -1,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
 		.flags = MODEL_CHERRYTRAIL,
 		.scl_sda_cfg = &byt_config,
 	},
 	[elkhartlake] = {
 		.bus_num = -1,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
 		.get_clk_rate_khz = ehl_get_clk_rate_khz,
 	},
 };
@@ -277,9 +263,6 @@ static int i2c_dw_pci_probe(struct pci_dev *pdev,
 		dev->sda_hold_time = cfg->sda_hold;
 	}
 
-	dev->tx_fifo_depth = controller->tx_fifo_depth;
-	dev->rx_fifo_depth = controller->rx_fifo_depth;
-
 	adap = &dev->adapter;
 	adap->owner = THIS_MODULE;
 	adap->class = 0;
