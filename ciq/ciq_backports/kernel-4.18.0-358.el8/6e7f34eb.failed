mm/gup: check for isolation errors

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Pavel Tatashin <pasha.tatashin@soleen.com>
commit 6e7f34ebb8d25d71ce7f4580ba3cbfc10b895580
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/6e7f34eb.failed

It is still possible that we pin movable CMA pages if there are
isolation errors and cma_page_list stays empty when we check again.

Check for isolation errors, and return success only when there are no
isolation errors, and cma_page_list is empty after checking.

Because isolation errors are transient, we retry indefinitely.

Link: https://lkml.kernel.org/r/20210215161349.246722-5-pasha.tatashin@soleen.com
Fixes: 9a4e9f3b2d73 ("mm: update get_user_pages_longterm to migrate pages allocated from CMA region")
	Signed-off-by: Pavel Tatashin <pasha.tatashin@soleen.com>
	Reviewed-by: Jason Gunthorpe <jgg@nvidia.com>
	Cc: Dan Williams <dan.j.williams@intel.com>
	Cc: David Hildenbrand <david@redhat.com>
	Cc: David Rientjes <rientjes@google.com>
	Cc: Ingo Molnar <mingo@redhat.com>
	Cc: Ira Weiny <ira.weiny@intel.com>
	Cc: James Morris <jmorris@namei.org>
	Cc: Jason Gunthorpe <jgg@ziepe.ca>
	Cc: John Hubbard <jhubbard@nvidia.com>
	Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
	Cc: Matthew Wilcox <willy@infradead.org>
	Cc: Mel Gorman <mgorman@suse.de>
	Cc: Michal Hocko <mhocko@kernel.org>
	Cc: Michal Hocko <mhocko@suse.com>
	Cc: Mike Kravetz <mike.kravetz@oracle.com>
	Cc: Oscar Salvador <osalvador@suse.de>
	Cc: Peter Zijlstra <peterz@infradead.org>
	Cc: Sasha Levin <sashal@kernel.org>
	Cc: Steven Rostedt (VMware) <rostedt@goodmis.org>
	Cc: Tyler Hicks <tyhicks@linux.microsoft.com>
	Cc: Vlastimil Babka <vbabka@suse.cz>
	Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
	Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
(cherry picked from commit 6e7f34ebb8d25d71ce7f4580ba3cbfc10b895580)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	mm/gup.c
diff --cc mm/gup.c
index 3eb41df3c3e6,3a00f6a8ffd6..000000000000
--- a/mm/gup.c
+++ b/mm/gup.c
@@@ -1739,27 -1681,22 +1751,40 @@@ check_again
  			return ret > 0 ? -ENOMEM : ret;
  		}
  
++<<<<<<< HEAD
 +		/*
 +		 * We did migrate all the pages, Try to get the page references
 +		 * again migrating any new CMA pages which we failed to isolate
 +		 * earlier.
 +		 */
 +		ret = __get_user_pages_locked(tsk, mm, start, nr_pages,
 +						   pages, vmas, NULL,
 +						   gup_flags);
 +
 +		if (ret > 0) {
 +			nr_pages = ret;
 +			drain_allow = true;
 +			goto check_again;
 +		}
++=======
+ 		/* We unpinned pages before migration, pin them again */
+ 		ret = __get_user_pages_locked(mm, start, nr_pages, pages, vmas,
+ 					      NULL, gup_flags);
+ 		if (ret <= 0)
+ 			return ret;
+ 		nr_pages = ret;
++>>>>>>> 6e7f34ebb8d2 (mm/gup: check for isolation errors)
  	}
  
- 	return ret;
+ 	/*
+ 	 * check again because pages were unpinned, and we also might have
+ 	 * had isolation errors and need more pages to migrate.
+ 	 */
+ 	goto check_again;
  }
  #else
 -static long check_and_migrate_cma_pages(struct mm_struct *mm,
 +static long check_and_migrate_cma_pages(struct task_struct *tsk,
 +					struct mm_struct *mm,
  					unsigned long start,
  					unsigned long nr_pages,
  					struct page **pages,
* Unmerged path mm/gup.c
