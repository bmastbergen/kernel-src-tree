printk: ringbuffer: Reference text_data_ring directly in callees.

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Nikolay Borisov <nborisov@suse.com>
commit 584da076866f38ffb952efcc25af039f9551df81
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/584da076.failed

A bunch of functions in the new ringbuffer code take both a
printk_ringbuffer struct and a separate prb_data_ring. This is a relic
from an earlier version of the code when a second data ring was present.
Since this is no longer the case remove the extra function argument
from:
 - data_make_reusable()
 - data_push_tail()
 - data_alloc()
 - data_realloc()

	Signed-off-by: Nikolay Borisov <nborisov@suse.com>
	Reviewed-by: John Ogness <john.ogness@linutronix.de>
	Reviewed-by: Petr Mladek <pmladek@suse.com>
	Signed-off-by: Petr Mladek <pmladek@suse.com>
(cherry picked from commit 584da076866f38ffb952efcc25af039f9551df81)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	kernel/printk/printk_ringbuffer.c
diff --cc kernel/printk/printk_ringbuffer.c
index 6a191324e965,3b24c3aa55f4..000000000000
--- a/kernel/printk/printk_ringbuffer.c
+++ b/kernel/printk/printk_ringbuffer.c
@@@ -555,8 -563,9 +554,10 @@@ static bool data_make_reusable(struct p
  			       unsigned long lpos_end,
  			       unsigned long *lpos_out)
  {
+ 
+ 	struct prb_data_ring *data_ring = &rb->text_data_ring;
  	struct prb_desc_ring *desc_ring = &rb->desc_ring;
 +	struct prb_data_blk_lpos *blk_lpos;
  	struct prb_data_block *blk;
  	enum desc_state d_state;
  	struct prb_desc desc;
@@@ -806,10 -806,8 +805,10 @@@ static bool desc_push_tail(struct print
  	 * data blocks once their associated descriptor is gone.
  	 */
  
- 	if (!data_push_tail(rb, &rb->text_data_ring, desc.text_blk_lpos.next))
+ 	if (!data_push_tail(rb, desc.text_blk_lpos.next))
  		return false;
 +	if (!data_push_tail(rb, &rb->dict_data_ring, desc.dict_blk_lpos.next))
 +		return false;
  
  	/*
  	 * Check the next descriptor after @tail_id before pushing the tail
@@@ -1391,7 -1393,10 +1390,14 @@@ bool prb_reserve_in_last(struct prb_res
  		if (!data_check_size(&rb->text_data_ring, r->text_buf_size))
  			goto fail;
  
++<<<<<<< HEAD
 +		r->text_buf = data_alloc(rb, &rb->text_data_ring, r->text_buf_size,
++=======
+ 		if (r->text_buf_size > max_size)
+ 			goto fail;
+ 
+ 		r->text_buf = data_alloc(rb, r->text_buf_size,
++>>>>>>> 584da076866f (printk: ringbuffer: Reference text_data_ring directly in callees.)
  					 &d->text_blk_lpos, id);
  	} else {
  		if (!get_data(&rb->text_data_ring, &d->text_blk_lpos, &data_size))
@@@ -1412,7 -1417,10 +1418,14 @@@
  		if (!data_check_size(&rb->text_data_ring, r->text_buf_size))
  			goto fail;
  
++<<<<<<< HEAD
 +		r->text_buf = data_realloc(rb, &rb->text_data_ring, r->text_buf_size,
++=======
+ 		if (r->text_buf_size > max_size)
+ 			goto fail;
+ 
+ 		r->text_buf = data_realloc(rb, r->text_buf_size,
++>>>>>>> 584da076866f (printk: ringbuffer: Reference text_data_ring directly in callees.)
  					   &d->text_blk_lpos, id);
  	}
  	if (r->text_buf_size && !r->text_buf)
@@@ -1539,15 -1545,12 +1552,14 @@@ bool prb_reserve(struct prb_reserved_en
  	 * previous descriptor now so that it can be made available to
  	 * readers. (For seq==0 there is no previous descriptor.)
  	 */
 -	if (info->seq > 0)
 +	if (d->info.seq > 0)
  		desc_make_final(desc_ring, DESC_ID(id - 1));
  
- 	r->text_buf = data_alloc(rb, &rb->text_data_ring, r->text_buf_size,
- 				 &d->text_blk_lpos, id);
+ 	r->text_buf = data_alloc(rb, r->text_buf_size, &d->text_blk_lpos, id);
  	/* If text data allocation fails, a data-less record is committed. */
  	if (r->text_buf_size && !r->text_buf) {
 +		d->info.text_len = 0;
 +		d->info.dict_len = 0;
  		prb_commit(e);
  		/* prb_commit() re-enabled interrupts. */
  		goto fail;
* Unmerged path kernel/printk/printk_ringbuffer.c
