iommu/fsl_pamu: remove ->domain_window_enable

jira LE-1907
Rebuild_History Non-Buildable kernel-4.18.0-358.el8
commit-author Christoph Hellwig <hch@lst.de>
commit 376dfd2a2ff41596a6efc8ea56f8b0de172b04a6
Empty-Commit: Cherry-Pick Conflicts during history rebuild.
Will be included in final tarball splat. Ref for failed cherry-pick at:
ciq/ciq_backports/kernel-4.18.0-358.el8/376dfd2a.failed

The only thing that fsl_pamu_window_enable does for the current caller
is to fill in the prot value in the only dma_window structure, and to
propagate a few values from the iommu_domain_geometry struture into the
dma_window.  Remove the dma_window entirely, hardcode the prot value and
otherwise use the iommu_domain_geometry structure instead.

Remove the now unused ->domain_window_enable iommu method.

	Signed-off-by: Christoph Hellwig <hch@lst.de>
	Acked-by: Li Yang <leoyang.li@nxp.com>
Link: https://lore.kernel.org/r/20210401155256.298656-7-hch@lst.de
	Signed-off-by: Joerg Roedel <jroedel@suse.de>
(cherry picked from commit 376dfd2a2ff41596a6efc8ea56f8b0de172b04a6)
	Signed-off-by: Jonathan Maple <jmaple@ciq.com>

# Conflicts:
#	drivers/iommu/fsl_pamu_domain.c
#	drivers/iommu/fsl_pamu_domain.h
diff --cc drivers/iommu/fsl_pamu_domain.c
index a377b877dcab,689035e9d409..000000000000
--- a/drivers/iommu/fsl_pamu_domain.c
+++ b/drivers/iommu/fsl_pamu_domain.c
@@@ -66,80 -54,18 +66,91 @@@ static int __init iommu_init_mempool(vo
  	return 0;
  }
  
++<<<<<<< HEAD
 +static phys_addr_t get_phys_addr(struct fsl_dma_domain *dma_domain, dma_addr_t iova)
 +{
 +	u32 win_cnt = dma_domain->win_cnt;
 +	struct dma_window *win_ptr = &dma_domain->win_arr[0];
 +	struct iommu_domain_geometry *geom;
 +
 +	geom = &dma_domain->iommu_domain.geometry;
 +
 +	if (!win_cnt || !dma_domain->geom_size) {
 +		pr_debug("Number of windows/geometry not configured for the domain\n");
 +		return 0;
 +	}
 +
 +	if (win_cnt > 1) {
 +		u64 subwin_size;
 +		dma_addr_t subwin_iova;
 +		u32 wnd;
 +
 +		subwin_size = dma_domain->geom_size >> ilog2(win_cnt);
 +		subwin_iova = iova & ~(subwin_size - 1);
 +		wnd = (subwin_iova - geom->aperture_start) >> ilog2(subwin_size);
 +		win_ptr = &dma_domain->win_arr[wnd];
 +	}
 +
 +	if (win_ptr->valid)
 +		return win_ptr->paddr + (iova & (win_ptr->size - 1));
 +
 +	return 0;
 +}
 +
 +static int map_subwins(int liodn, struct fsl_dma_domain *dma_domain)
 +{
 +	struct dma_window *sub_win_ptr = &dma_domain->win_arr[0];
 +	int i, ret;
 +	unsigned long rpn, flags;
 +
 +	for (i = 0; i < dma_domain->win_cnt; i++) {
 +		if (sub_win_ptr[i].valid) {
 +			rpn = sub_win_ptr[i].paddr >> PAMU_PAGE_SHIFT;
 +			spin_lock_irqsave(&iommu_lock, flags);
 +			ret = pamu_config_spaace(liodn, dma_domain->win_cnt, i,
 +						 sub_win_ptr[i].size,
 +						 ~(u32)0,
 +						 rpn,
 +						 dma_domain->snoop_id,
 +						 dma_domain->stash_id,
 +						 (i > 0) ? 1 : 0,
 +						 sub_win_ptr[i].prot);
 +			spin_unlock_irqrestore(&iommu_lock, flags);
 +			if (ret) {
 +				pr_debug("SPAACE configuration failed for liodn %d\n",
 +					 liodn);
 +				return ret;
 +			}
 +		}
 +	}
 +
 +	return ret;
 +}
 +
 +static int map_win(int liodn, struct fsl_dma_domain *dma_domain)
++=======
+ /* Map the DMA window corresponding to the LIODN */
+ static int map_liodn(int liodn, struct fsl_dma_domain *dma_domain)
++>>>>>>> 376dfd2a2ff4 (iommu/fsl_pamu: remove ->domain_window_enable)
  {
  	int ret;
- 	struct dma_window *wnd = &dma_domain->win_arr[0];
- 	phys_addr_t wnd_addr = dma_domain->iommu_domain.geometry.aperture_start;
+ 	struct iommu_domain_geometry *geom = &dma_domain->iommu_domain.geometry;
  	unsigned long flags;
  
  	spin_lock_irqsave(&iommu_lock, flags);
++<<<<<<< HEAD
 +	ret = pamu_config_ppaace(liodn, wnd_addr,
 +				 wnd->size,
 +				 ~(u32)0,
 +				 wnd->paddr >> PAMU_PAGE_SHIFT,
 +				 dma_domain->snoop_id, dma_domain->stash_id,
 +				 0, wnd->prot);
++=======
+ 	ret = pamu_config_ppaace(liodn, geom->aperture_start,
+ 				 geom->aperture_end + 1, ~(u32)0,
+ 				 0, dma_domain->snoop_id, dma_domain->stash_id,
+ 				 PAACE_AP_PERMS_QUERY | PAACE_AP_PERMS_UPDATE);
++>>>>>>> 376dfd2a2ff4 (iommu/fsl_pamu: remove ->domain_window_enable)
  	spin_unlock_irqrestore(&iommu_lock, flags);
  	if (ret)
  		pr_debug("PAACE configuration failed for liodn %d\n", liodn);
@@@ -147,56 -73,6 +158,59 @@@
  	return ret;
  }
  
++<<<<<<< HEAD
 +/* Map the DMA window corresponding to the LIODN */
 +static int map_liodn(int liodn, struct fsl_dma_domain *dma_domain)
 +{
 +	if (dma_domain->win_cnt > 1)
 +		return map_subwins(liodn, dma_domain);
 +	else
 +		return map_win(liodn, dma_domain);
 +}
 +
 +/* Update window/subwindow mapping for the LIODN */
 +static int update_liodn(int liodn, struct fsl_dma_domain *dma_domain, u32 wnd_nr)
 +{
 +	int ret;
 +	struct dma_window *wnd = &dma_domain->win_arr[wnd_nr];
 +	unsigned long flags;
 +
 +	spin_lock_irqsave(&iommu_lock, flags);
 +	if (dma_domain->win_cnt > 1) {
 +		ret = pamu_config_spaace(liodn, dma_domain->win_cnt, wnd_nr,
 +					 wnd->size,
 +					 ~(u32)0,
 +					 wnd->paddr >> PAMU_PAGE_SHIFT,
 +					 dma_domain->snoop_id,
 +					 dma_domain->stash_id,
 +					 (wnd_nr > 0) ? 1 : 0,
 +					 wnd->prot);
 +		if (ret)
 +			pr_debug("Subwindow reconfiguration failed for liodn %d\n",
 +				 liodn);
 +	} else {
 +		phys_addr_t wnd_addr;
 +
 +		wnd_addr = dma_domain->iommu_domain.geometry.aperture_start;
 +
 +		ret = pamu_config_ppaace(liodn, wnd_addr,
 +					 wnd->size,
 +					 ~(u32)0,
 +					 wnd->paddr >> PAMU_PAGE_SHIFT,
 +					 dma_domain->snoop_id, dma_domain->stash_id,
 +					 0, wnd->prot);
 +		if (ret)
 +			pr_debug("Window reconfiguration failed for liodn %d\n",
 +				 liodn);
 +	}
 +
 +	spin_unlock_irqrestore(&iommu_lock, flags);
 +
 +	return ret;
 +}
 +
++=======
++>>>>>>> 376dfd2a2ff4 (iommu/fsl_pamu: remove ->domain_window_enable)
  static int update_liodn_stash(int liodn, struct fsl_dma_domain *dma_domain,
  			      u32 val)
  {
@@@ -284,47 -129,7 +298,51 @@@ static int pamu_set_liodn(int liodn, st
  	return ret;
  }
  
++<<<<<<< HEAD
 +static int check_size(u64 size, dma_addr_t iova)
 +{
 +	/*
 +	 * Size must be a power of two and at least be equal
 +	 * to PAMU page size.
 +	 */
 +	if ((size & (size - 1)) || size < PAMU_PAGE_SIZE) {
 +		pr_debug("Size too small or not a power of two\n");
 +		return -EINVAL;
 +	}
 +
 +	/* iova must be page size aligned */
 +	if (iova & (size - 1)) {
 +		pr_debug("Address is not aligned with window size\n");
 +		return -EINVAL;
 +	}
 +
 +	return 0;
 +}
 +
 +static struct fsl_dma_domain *iommu_alloc_dma_domain(void)
 +{
 +	struct fsl_dma_domain *domain;
 +
 +	domain = kmem_cache_zalloc(fsl_pamu_domain_cache, GFP_KERNEL);
 +	if (!domain)
 +		return NULL;
 +
 +	domain->stash_id = ~(u32)0;
 +	domain->snoop_id = ~(u32)0;
 +	domain->win_cnt = pamu_get_max_subwin_cnt();
 +	domain->geom_size = 0;
 +
 +	INIT_LIST_HEAD(&domain->devices);
 +
 +	spin_lock_init(&domain->domain_lock);
 +
 +	return domain;
 +}
 +
 +static void remove_device_ref(struct device_domain_info *info, u32 win_cnt)
++=======
+ static void remove_device_ref(struct device_domain_info *info)
++>>>>>>> 376dfd2a2ff4 (iommu/fsl_pamu: remove ->domain_window_enable)
  {
  	unsigned long flags;
  
@@@ -471,92 -256,6 +485,95 @@@ static int update_domain_stash(struct f
  	return ret;
  }
  
++<<<<<<< HEAD
 +/* Update domain mappings for all LIODNs associated with the domain */
 +static int update_domain_mapping(struct fsl_dma_domain *dma_domain, u32 wnd_nr)
 +{
 +	struct device_domain_info *info;
 +	int ret = 0;
 +
 +	list_for_each_entry(info, &dma_domain->devices, link) {
 +		ret = update_liodn(info->liodn, dma_domain, wnd_nr);
 +		if (ret)
 +			break;
 +	}
 +	return ret;
 +}
 +
 +
 +static int fsl_pamu_window_enable(struct iommu_domain *domain, u32 wnd_nr,
 +				  phys_addr_t paddr, u64 size, int prot)
 +{
 +	struct fsl_dma_domain *dma_domain = to_fsl_dma_domain(domain);
 +	struct dma_window *wnd;
 +	int pamu_prot = 0;
 +	int ret;
 +	unsigned long flags;
 +	u64 win_size;
 +
 +	if (prot & IOMMU_READ)
 +		pamu_prot |= PAACE_AP_PERMS_QUERY;
 +	if (prot & IOMMU_WRITE)
 +		pamu_prot |= PAACE_AP_PERMS_UPDATE;
 +
 +	spin_lock_irqsave(&dma_domain->domain_lock, flags);
 +	if (!dma_domain->win_arr) {
 +		pr_debug("Number of windows not configured\n");
 +		spin_unlock_irqrestore(&dma_domain->domain_lock, flags);
 +		return -ENODEV;
 +	}
 +
 +	if (wnd_nr >= dma_domain->win_cnt) {
 +		pr_debug("Invalid window index\n");
 +		spin_unlock_irqrestore(&dma_domain->domain_lock, flags);
 +		return -EINVAL;
 +	}
 +
 +	win_size = dma_domain->geom_size >> ilog2(dma_domain->win_cnt);
 +	if (size > win_size) {
 +		pr_debug("Invalid window size\n");
 +		spin_unlock_irqrestore(&dma_domain->domain_lock, flags);
 +		return -EINVAL;
 +	}
 +
 +	if (dma_domain->win_cnt == 1) {
 +		if (dma_domain->enabled) {
 +			pr_debug("Disable the window before updating the mapping\n");
 +			spin_unlock_irqrestore(&dma_domain->domain_lock, flags);
 +			return -EBUSY;
 +		}
 +
 +		ret = check_size(size, domain->geometry.aperture_start);
 +		if (ret) {
 +			pr_debug("Aperture start not aligned to the size\n");
 +			spin_unlock_irqrestore(&dma_domain->domain_lock, flags);
 +			return -EINVAL;
 +		}
 +	}
 +
 +	wnd = &dma_domain->win_arr[wnd_nr];
 +	if (!wnd->valid) {
 +		wnd->paddr = paddr;
 +		wnd->size = size;
 +		wnd->prot = pamu_prot;
 +
 +		ret = update_domain_mapping(dma_domain, wnd_nr);
 +		if (!ret) {
 +			wnd->valid = 1;
 +			dma_domain->mapped++;
 +		}
 +	} else {
 +		pr_debug("Disable the window before updating the mapping\n");
 +		ret = -EBUSY;
 +	}
 +
 +	spin_unlock_irqrestore(&dma_domain->domain_lock, flags);
 +
 +	return ret;
 +}
 +
++=======
++>>>>>>> 376dfd2a2ff4 (iommu/fsl_pamu: remove ->domain_window_enable)
  /*
   * Attach the LIODN to the DMA domain and configure the geometry
   * and window mappings.
@@@ -586,23 -285,18 +603,38 @@@ static int handle_attach_device(struct 
  		 * for the domain. If yes, set the geometry for
  		 * the LIODN.
  		 */
++<<<<<<< HEAD
 +		if (dma_domain->win_arr) {
 +			u32 win_cnt = dma_domain->win_cnt > 1 ? dma_domain->win_cnt : 0;
 +
 +			ret = pamu_set_liodn(liodn[i], dev, dma_domain,
 +					     &domain->geometry, win_cnt);
 +			if (ret)
 +				break;
 +			if (dma_domain->mapped) {
 +				/*
 +				 * Create window/subwindow mapping for
 +				 * the LIODN.
 +				 */
 +				ret = map_liodn(liodn[i], dma_domain);
 +				if (ret)
 +					break;
 +			}
 +		}
++=======
+ 		ret = pamu_set_liodn(liodn[i], dev, dma_domain,
+ 				     &domain->geometry);
+ 		if (ret)
+ 			break;
+ 
+ 		/*
+ 		 * Create window/subwindow mapping for
+ 		 * the LIODN.
+ 		 */
+ 		ret = map_liodn(liodn[i], dma_domain);
+ 		if (ret)
+ 			break;
++>>>>>>> 376dfd2a2ff4 (iommu/fsl_pamu: remove ->domain_window_enable)
  	}
  	spin_unlock_irqrestore(&dma_domain->domain_lock, flags);
  
@@@ -1008,12 -564,10 +1033,11 @@@ static const struct iommu_ops fsl_pamu_
  	.domain_free    = fsl_pamu_domain_free,
  	.attach_dev	= fsl_pamu_attach_device,
  	.detach_dev	= fsl_pamu_detach_device,
- 	.domain_window_enable = fsl_pamu_window_enable,
  	.iova_to_phys	= fsl_pamu_iova_to_phys,
  	.domain_set_attr = fsl_pamu_set_domain_attr,
 -	.probe_device	= fsl_pamu_probe_device,
 -	.release_device	= fsl_pamu_release_device,
 +	.domain_get_attr = fsl_pamu_get_domain_attr,
 +	.add_device	= fsl_pamu_add_device,
 +	.remove_device	= fsl_pamu_remove_device,
  	.device_group   = fsl_pamu_device_group,
  };
  
diff --cc drivers/iommu/fsl_pamu_domain.h
index f2b0f741d3de,13ee06e0ef01..000000000000
--- a/drivers/iommu/fsl_pamu_domain.h
+++ b/drivers/iommu/fsl_pamu_domain.h
@@@ -21,37 -9,7 +21,33 @@@
  
  #include "fsl_pamu.h"
  
- struct dma_window {
- 	phys_addr_t paddr;
- 	u64 size;
- 	int valid;
- 	int prot;
- };
- 
  struct fsl_dma_domain {
++<<<<<<< HEAD
 +	/*
 +	 * Indicates the geometry size for the domain.
 +	 * This would be set when the geometry is
 +	 * configured for the domain.
 +	 */
 +	dma_addr_t			geom_size;
 +	/*
 +	 * Number of windows assocaited with this domain.
 +	 * During domain initialization, it is set to the
 +	 * the maximum number of subwindows allowed for a LIODN.
 +	 * Minimum value for this is 1 indicating a single PAMU
 +	 * window, without any sub windows. Value can be set/
 +	 * queried by set_attr/get_attr API for DOMAIN_ATTR_WINDOWS.
 +	 * Value can only be set once the geometry has been configured.
 +	 */
 +	u32				win_cnt;
 +	/*
 +	 * win_arr contains information of the configured
 +	 * windows for a domain. This is allocated only
 +	 * when the number of windows for the domain are
 +	 * set.
 +	 */
 +	struct dma_window		*win_arr;
++=======
++>>>>>>> 376dfd2a2ff4 (iommu/fsl_pamu: remove ->domain_window_enable)
  	/* list of devices associated with the domain */
  	struct list_head		devices;
  	/* dma_domain states:
* Unmerged path drivers/iommu/fsl_pamu_domain.c
* Unmerged path drivers/iommu/fsl_pamu_domain.h
diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c
index 1134fe3f7517..04dace299232 100644
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@ -2681,17 +2681,6 @@ size_t iommu_map_sg_atomic(struct iommu_domain *domain, unsigned long iova,
 	return __iommu_map_sg(domain, iova, sg, nents, prot, GFP_ATOMIC);
 }
 
-int iommu_domain_window_enable(struct iommu_domain *domain, u32 wnd_nr,
-			       phys_addr_t paddr, u64 size, int prot)
-{
-	if (unlikely(domain->ops->domain_window_enable == NULL))
-		return -ENODEV;
-
-	return domain->ops->domain_window_enable(domain, wnd_nr, paddr, size,
-						 prot);
-}
-EXPORT_SYMBOL_GPL(iommu_domain_window_enable);
-
 /**
  * report_iommu_fault() - report about an IOMMU fault to the IOMMU framework
  * @domain: the iommu domain where the fault has happened
diff --git a/drivers/soc/fsl/qbman/qman_portal.c b/drivers/soc/fsl/qbman/qman_portal.c
index a120002b630e..eadca57ba017 100644
--- a/drivers/soc/fsl/qbman/qman_portal.c
+++ b/drivers/soc/fsl/qbman/qman_portal.c
@@ -83,13 +83,6 @@ static void portal_set_cpu(struct qm_portal_config *pcfg, int cpu)
 			__func__, ret);
 		goto out_domain_free;
 	}
-	ret = iommu_domain_window_enable(pcfg->iommu_domain, 0, 0, 1ULL << 36,
-					 IOMMU_READ | IOMMU_WRITE);
-	if (ret < 0) {
-		dev_err(dev, "%s(): iommu_domain_window_enable() = %d",
-			__func__, ret);
-		goto out_domain_free;
-	}
 	ret = iommu_attach_device(pcfg->iommu_domain, dev);
 	if (ret < 0) {
 		dev_err(dev, "%s(): iommu_device_attach() = %d", __func__,
diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 1d738c608f7d..ac02e243207a 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -239,7 +239,6 @@ struct iommu_iotlb_gather {
  * @get_resv_regions: Request list of reserved regions for a device
  * @put_resv_regions: Free list of reserved regions for a device
  * @apply_resv_region: Temporary helper call-back for iova reserved ranges
- * @domain_window_enable: Configure and enable a particular window for a domain
  * @of_xlate: add OF master IDs to iommu grouping
  * @is_attach_deferred: Check if domain attach should be deferred from iommu
  *                      driver init to device driver init (default no)
@@ -302,10 +301,6 @@ struct iommu_ops {
 				  struct iommu_domain *domain,
 				  struct iommu_resv_region *region);
 
-	/* Window handling functions */
-	int (*domain_window_enable)(struct iommu_domain *domain, u32 wnd_nr,
-				    phys_addr_t paddr, u64 size, int prot);
-
 	int (*of_xlate)(struct device *dev, struct of_phandle_args *args);
 	bool (*is_attach_deferred)(struct iommu_domain *domain, struct device *dev);
 
@@ -551,11 +546,6 @@ extern int iommu_domain_get_attr(struct iommu_domain *domain, enum iommu_attr,
 extern int iommu_domain_set_attr(struct iommu_domain *domain, enum iommu_attr,
 				 void *data);
 
-/* Window handling function prototypes */
-extern int iommu_domain_window_enable(struct iommu_domain *domain, u32 wnd_nr,
-				      phys_addr_t offset, u64 size,
-				      int prot);
-
 extern int report_iommu_fault(struct iommu_domain *domain, struct device *dev,
 			      unsigned long iova, int flags);
 
@@ -780,13 +770,6 @@ static inline void iommu_iotlb_sync(struct iommu_domain *domain,
 {
 }
 
-static inline int iommu_domain_window_enable(struct iommu_domain *domain,
-					     u32 wnd_nr, phys_addr_t paddr,
-					     u64 size, int prot)
-{
-	return -ENODEV;
-}
-
 static inline phys_addr_t iommu_iova_to_phys(struct iommu_domain *domain, dma_addr_t iova)
 {
 	return 0;
